# 科技庄园

## 题目背景

Life种了一块田，里面种了有一些桃树。

Life对PFT说：“我给你一定的时间去摘桃，你必须在规定的时间之内回到我面前，否则你摘的桃都要归我吃！”

PFT思考了一会，最终答应了！

由于PFT的数学不好！它并不知道怎样才能在规定的时间获得最大的价值，

由于PFT不是机器人，所以他的体力并不是无限的，他不想摘很多的桃以至体力为0，而白白把桃给Life。同时PFT每次只能摘一棵桃树，，每棵桃树都可以摘K次（对于同一棵桃每次摘的桃数相同）。每次摘完后都要返回出发点（PFT一次拿不了很多）即Life的所在地（0，0）{试验田左上角的桃坐标是（1，1）}。

PFT每秒只能移动一个单位，每移动一个单位耗费体力1(摘取不花费时间和体力,但只限上下左右移动)。


## 说明/提示

样例说明：

可以摘到1次（1，1）和1次（2，3），体力和时间不满足再摘桃了。

范围：

对于M，N，TI，A   10<=30%<=50  10<=100%<=100

对于K  10<=100%<=100

保证结果在long int范围内


## 样例 #1

### 输入

```
4 4 13 20
10 0  0  0
0  0  10 0
0  0  10 0
0  0  0  0
1 0 0 0
0 0 2 0
0 0 4 0
0 0 0 0```

### 输出

```
10```

# 题解

## 作者：Diamiko (赞：45)

### 分析题目

#### 要素无非就以下几个：

* 总时间，总体力

* 每棵树的桃数

* 每棵树所耗的时间和体力

* 每棵树能摘的次数

#### 再转变一下

* 总体积

* 每个物品的价值

* 每个物品的消耗

* 每个物品使用的次数

#### 不难看出，这就是多重背包



------------


### 注意点：

#### 背包总体积的处理

乍一看，题目有两个“体积”，一个时间，一个体力。但实际并非如此。

因为我们每走一步，时间和体力都减一，只要时间到 0 或者 体力到 1 就不能再走了，所以背包体积就可以取 `总时间` 和 `总体力-1` 的较小值 。

另外，为什么总体力要减一？

>由于PFT不是机器人，所以他的体力并不是无限的，他不想摘很多的桃以至体力为0，而白白把桃给Life。

体力不能到0的哦~

#### 物品消耗的处理

每个物品的消耗就是`(0,0)`到当前坐标的距离，但需要注意的是**这里的距离不是欧几里得距离！！**

因为PFT只能上下左右移动，不能斜着跑。

所以每个物品的消耗：

设当前坐标为`(x,y)`，则消耗为`2*(x+y)`


为什么乘2？因为是往返啊……

### 代码

这里使用了二进制优化

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
struct Object
{
	long long cost,value,number;
	//每个物品的消耗，价值和次数
	//每个桃数的距离，桃子数量，和采摘次数
}a[10005];
long long dp[10005];
int n,h,l,Time,Tili,Bag;
//总物品数，行，列，总时间，总体力，背包体积
void ZeroOnePack(int cost,int value)
{
	for(int i=Bag;i>=cost;i--)
	{
		dp[i]=max(dp[i],dp[i-cost]+value);
	}
}
//01背包板子
void CompletePack(int cost,int value)
{
	for(int i=cost;i<=Bag;i++)
	{
		dp[i]=max(dp[i],dp[i-cost]+value);
	}
}
//完全背包板子
void MultiPack(int cost,int value,int amount)
{
	if(Bag<=cost*amount)
	{
		//背包体积小于等于物品的总体积
		//那么随便拿，完全背包
		//Trace On!
		CompletePack(cost,value);
		return;
	}
	for(int k=1;k<amount;k<<=1)
	{
		ZeroOnePack(cost*k,value*k);
		amount-=k;
	}
	ZeroOnePack(cost*amount,value*amount);
	//二进制优化的过程↑
}
//上面是二进制优化的多重背包板子
//如果有不会二进制优化的同学，可以把我这个板子粘下来背
//我感觉这个板子相比别的大佬写的板子还是很简单好记的
int main()
{
	scanf("%d%d%d%d",&h,&l,&Time,&Tili);
	n=h*l;
	//获得总物品数
	int cnt=0;
	//记录物品下标
	for(int i=1;i<=h;i++)
	{
		for(int j=1;j<=l;j++)
		{
			scanf("%lld",&a[++cnt].value);
			//输入当前桃子数量，即物品价值
			a[cnt].cost=i+j<<1;
			//同时处理出当前桃数的距离
			//位运算，等价于(i+j)*2
		}
	}
	cnt=0;
	//重新输入，清零下标
	for(int i=1;i<=h;i++)
	{
		for(int j=1;j<=l;j++)
		{
			scanf("%lld",&a[++cnt].number);
			//输入可采摘次数
		}
	}
	Bag=min(Time,Tili-1);
	//计算背包体积
	for(int i=1;i<=n;i++)
	{
		MultiPack(a[i].cost,a[i].value,a[i].number);
	}
	printf("%lld\n",dp[Bag]);
	return 0;
}
```
附赠多重背包二进制优化的板子
```cpp
void ZeroOnePack(int cost,int value)
{
	for(int i=Bag;i>=cost;i--)
	{
		dp[i]=max(dp[i],dp[i-cost]+value);
	}
}
void CompletePack(int cost,int value)
{
	for(int i=cost;i<=Bag;i++)
	{
		dp[i]=max(dp[i],dp[i-cost]+value);
	}
}
void MultiPack(int cost,int value,int amount)
{
	if(Bag<=cost*amount)
	{
		CompletePack(cost,value);
		return;
	}
	for(int k=1;k<amount;k<<=1)
	{
		ZeroOnePack(cost*k,value*k);
		amount-=k;
	}
	ZeroOnePack(cost*amount,value*amount);
}
signed main()
{
	......
	//省略输入……
	for(int i=1;i<=n;i++)
	{
		MultiPack(a[i].cost,a[i].value,a[i].number);
	}
	printf("%lld\n",dp[Bag]);
}
```

都看完了，不点个赞再走吗（滑稽

---

## 作者：Star_Wind (赞：22)

蒟蒻的第一眼就想到了搜索

但是看完样例的我笑了

**原来是多重背包！！！**

高兴坏了，昨天刚学的

但是一看发现还是得动点脑筋

首先这题有两个限制条件，二维背包？不可能！其实可以变成一个限制条件

因为时间和体力必须取小的，并且这里注意体力要减一

接着就是构造了

两个二维数组可以压缩一下

如果这个可摘次数是0，或者树上没有桃子，就可以不用考虑

接下来把压缩后的数组变成一维，t[i]表示可摘次数，c[i]表示几个

主要的是摘一次的花费w[i],其实也很简单，因为是来回，所以就（i+j）*2

构造完之后就打个纯多重背包就行了，大家应该都会

好了，上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<cstdlib>
#include<algorithm>//头文件写的有点长。。。
using namespace std;
int n,m,s,r,W,a[210][210],b[210][210],c[20101],f[21100],t[21010],w[20110],p;
int main()
{
    cin>>n>>m>>s>>r;
    W=min(s,r-1); 
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++) 
        cin>>a[i][j];
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++) 
        cin>>b[i][j];
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        if(a[i][j]>0&&b[i][j]>0)
        {
            w[++p]=(i+j)*2;
            c[p]=a[i][j];
            t[p]=b[i][j];
        }
    for(int i=1;i<=p;i++)
      for(int k=1;k<=t[i];k++)
        for(int j=W;j>=w[i];j--)
          f[j]=max(f[j],f[j-w[i]]+c[i]);
    cout<<f[W];
    return 0;
}
```
最后总结一下，这个绿题其实也没有那么难，主要还是考察了一个背包

提交后发现时间这么少？？？3ms？？？（逃

---

## 作者：Strong_Jelly (赞：6)

## 这道题是一道多重背包的问题

多重背包问题需要有5个已知量

- n：背包里物品的**数量**
- m：背包的**容量**
- w[i]：背包里其中一个物品的**重量**
- c[i]：背包里其中一个物品的**价值**
- num[i]：背包里其中一个物品的**数量**

n和num还有c就不用说了，题目里显而易见，主要讲一讲m和w

___

- m：背包容量 —— **这里是min(PFT的时间, PFT的体力 - 1)**，因为他的时间和体力是同时进行的，而且体力和时间中任何一样用完了就会~~挂掉~~，体力要减一是因为PFT不想让他的体力为0（[看题](https://www.luogu.org/problemnew/show/P2760)）~~，这样他连吃桃的力气都没有了~~
___
- w：背包里其中一个物品的重量 —— **这里是(i + j) * 2**，因为这道题中PFT走的是曼哈顿距离（即D(a, b) = |x1 - x2| + |y1 - y2|）这里由于终点是0所以就省去了，因为PFT要走一个来回（~~他总不能走过去不继续回来摘桃了吧~~），所以要乘2

___

**code**（我用的是二进制优化的多重背包，不会的看[这里](https://www.luogu.org/blog/JustinRochester/solution-p1776)，或[这里](https://dankuroto.blog.luogu.org/solution-p1776)）:

```cpp
#include <bits/stdc++.h>
using namespace std;
int N, M, n, m, q[1001][1001], c[100001], w[100001], f[100001], a, b;//q表示价值，a是时间，b是体力，其他的看名字都能看懂吧 
int main()
{
	scanf("%d %d %d %d", &N, &M, &a, &b); 
	m = min(a, b - 1);//取min 
	for(register int i = 1; i <= N; ++i)
	{
		for(register int j = 1; j <= M; ++j)
		{
			scanf("%d", &q[i][j]);
		}
	}
	for(register int i = 1; i <= N; ++i)
	{
		for(register int j = 1; j <= M; ++j)
		{
			int z;
			scanf("%d", &z);//z表示数量 
			if(!z || !q[i][j])
			{
				continue;
			}
			int x = q[i][j];//x表示价值 
			int y = (i + j) * 2;//y表示重量 
			//二进制优化(不会的不用管它，写正常的好像也能过，也许这就是才绿题的原因吧) 
			for(register int k = 1; k <= z; k *= 2)
			{
				c[++n] = x * k;
				w[n] = y * k;
				z -= k;
			}
			if(z)
			{
				c[++n] = x * z;
				w[n] = y * z;
			}
			//二进制优化结束
		}
	}
	//二进制优化完之后直接打个01背包模板就好了 
	for(register int i = 1; i <= n; ++i)
	{
		for(register int j = m; j >= w[i]; --j)
		{
			f[j] = max(f[j], f[j - w[i]] + c[i]);
		}
	}
	printf("%d", f[m]);
	return 0;
}
```


---

## 作者：Twilight_ (赞：5)

嗯很明显的，是一个背包问题，又因为每一件物品有自己采摘的次数，所以是一个**多重背包**。


在这里，可以将**采摘桃子的个数**作为物品的价值，而**往返所需要的时间2\*（x+y）**就是一件物品的**代价**。

题解里面大部分貌似都是写的01，所以来一发二进制拆分解~

二进制的拆分，就是将s个物品拆分为1+2+4+8+16……个，相当于是对01背包进行的一个优化。


代码里面还有注释~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,v[100000],c[100000],l[1000][1000],dp[100000],t,e,q=0,s;//v：value；c：cost；
int main()
{
    cin>>n>>m>>t>>e;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)cin>>l[i][j];//第（i,j）棵树采摘一次可以得到的桃子数
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            cin>>s;//物品的个数
            int t=1,x=2*(i+j);
            if(l[i][j])//二进制的拆分；
            {
                while(s>=t)
                {
                    c[++q]=t*x;
                    v[q]=t*l[i][j];
                    s-=t;t*=2;
                }
                c[++q]=x*s;//重要重要重要！别忘记啦 
                v[q]=s*l[i][j];//重要重要重要！ 
            }
        }
    t=min(t,e-1);//因为时间和体力的消耗相等，所以可以看做是一个限制，因为体力>0，所以限制取t,e-1的小值；
    for(int i=1;i<=q;i++)
        for(int j=t;j>=c[i];j--)
            dp[j]=max(dp[j],dp[j-c[i]]+v[i]);//状态转移方程，和01是一样的；
    cout<<dp[t];
    return 0;
}
```

---

## 作者：L_Y_T (赞：5)

**别的不说，上代码！**


------------
```
#include<iostream>
using namespace std;
int i,j,k,l,n,m,v,u,g,tim;
int f[11000],s[1100][1100],q[1100][1100];
int w[1110000],c[1100000];
int num=1,ans;
int main()
{
	//乍一看，有一个想法，这不是一个二维背包咩？ 
	//但这题有个很好的BUG，其实也不算了，就是一个很好玩的条件
	//PET童鞋每秒移动一个单位，每移动一个单位耗一点体力 
	//这就成了01了！ 
	//对了，还有，注意PET童鞋比较那啥，他的路程是要跑两次的！ 
	int t;
	cin>>n>>m>>tim>>t;//矩阵长 宽 时间 体力 
    f[0]=0;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			cin>>s[i][j];
		}//能摘的桃数量 
	} 
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
	{
	cin>>q[i][j];//能摘的次数 
		if(s[i][j]>0)//如果这棵树能摘 
		{
			for(int v=num;v<=num+q[i][j];v++)
			//有一点提醒一下，就是上面那句for循环，注意num的值！ 
			//num是可摘总数 （物品数量！） 
			{
				w[v]=(i+j)*2;//w[]是花费（可以这么说），就是物体体积了啦！
				c[v]=s[i][j]; //提一下，c[]为价值，就不说了哈！ 
			}
		}num+=q[i][j];//桃纸的总数 
	}
	}
	t=min(t-1,tim);//不多解释 ，前面有讲（应该讲了，没讲提醒一下）； 
	for(i=1;i<=num;i++)
	for(j=t;j>=w[i];j--)
	{
		if(j-w[i]<0) break;//这一部分不解释 
		else
		f[j]=max(f[j],f[j-w[i]]+c[i]);//状态转移大方程，不多解释（要解释的童鞋~吱~一声） 
	}
	cout<<f[t]<<endl;
}
```


---

## 作者：雅儿贝德 (赞：3)

看到题目，不是很容易去想出背包DP。此时需要去看题目，有桃子数目和采摘次数。等等，这不是很像多重背包吗。再回头看，题目需要我们去考虑曼哈顿距离（因为只能上下左右移动）。神了，背包需要的条件齐了!

价值——桃子数目

次数——题目给出

代价——可使用曼哈顿距离计算公式。用x，y来表示当前点位置，（x-0）+（y-0）=x+y。因为需要来回，所以\*2。

（虽然我也不知道为什么，似乎不能把可以摘n次m个桃子拆开成n个m个桃子用01做，会90（玄学））

下方贴代码：

    

    
```cpp
var    
    n,m,tx,ty,i,j,tot,x,time,k:longint;
    f,c,w,p:array[0..100001]of longint;
    num:array[0..2010,0..2010]of longint;
function min(x,y:longint):longint;
begin 
    if x<y then exit(x) else exit(y);
end;
function max(x,y:longint):longint;
begin 
    if x>y then exit(x) else exit(y);
end; 
begin 
    fillchar(f,sizeof(f),0);
    tot:=0;
    readln(n,m,tx,ty);
    for i:= 1 to n do 
        for j:= 1 to m do 
                read(num[i,j]);
    for i:= 1 to n do 
        for j:= 1 to m do 
            begin 
                read(x);    
                if x<>0 then 
                    begin 
                        {for k:= tot+1 to tot+x do
                            begin 
                                c[k]:=num[i,j];
                                w[k]:=(i+j)*2;
                            end; 
                        tot:=tot+x;}
                        inc(tot);
                        c[tot]:=num[i,j];
                        w[tot]:=(i+j)*2;
                        p[tot]:=x;
                    end; 
            end; 
    time:=min(tx,ty-1);
    for i:= 1 to tot do 
        for k:= 1 to p[i] do 
            for j:=time downto w[i] do 
                f[j]:=max(f[j],f[j-w[i]]+c[i]);
    writeln(f[time]);
end. 
（代码很丑请见谅 ）
```

---

## 作者：killerlist (赞：3)

#科技庄园

**解题报告：**

1. 第一眼看似是个跟背包半毛线都没有的东西，更像棋盘DP

2. 然后就发现其实预处理一下即可，把处理后的数据【路程】&&【收益】拿来背包就好了

3. 所以其实不难

···cpp

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn1=100+5;
const int maxn2=1000000+5;
```
int mapa[maxn1][maxn1],mapk[maxn1][maxn1],w[maxn2],v[maxn2],dp[maxn1],
```cpp
    n,m,ti,a,sum,bian;
int main(){
    cin>>n>>m>>ti>>a;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>mapa[i][j];//读入
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>mapk[i][j];//读入
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            while(mapk[i][j]--){//转化成背包问题
                sum++;
                w[sum]=2*(i+j);//距离
                v[sum]=mapa[i][j];//收益
            }
        }
    }
    bian=min(ti,a-1);//预处理边界
    for(int i=1;i<=sum;i++){//一下全是背包DP
        for(int j=bian;j>=w[i];j--){
            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        }
    }
    cout<<dp[bian]<<endl;
    return 0;
}
```
···
##壮哉我大MIT！！！


---

## 作者：Snitro (赞：1)

**数据中有两个需要注意的地方：**

1. **存在桃树上有桃子但是摘 0 次的情况**

2.**题目中要求体力不能为0，因此就算到达了重点体力也不能为0，所以实际上允许使用的体力为 a - 1**


把每个桃树想象成物品，体力和时间的最小值想象成空间

由于摘完一次就要回到起点，所以每颗桃树的体力为 2 \* (x + y),   x    y 分别为此桃树对应的横纵坐标


[类似题目](http://blog.csdn.net/fine\_rose/article/details/69577919)


附上代码:


```cpp
#include<iostream>
#include<cstdio>
#define l long
using namespace std;
l n,m,td,a;//行 列 时间 体力
l map[101][101];
l f[10005];
struct peach{
    l num;//一次摘的个数 
    l ti;//最多摘的次数 
    l td;//单程需要时间 等于 花费的体力 
}peach[10005];
l k = 0;
int main(){
    freopen("in.txt","r",stdin);
    cin >> n >> m >> td >> a;
    td = min(td,a - 1);//由于要求2因此这里a应该取a - 1
    for(int y = 1;y <= n;y++){
        for(int x = 1;x <= m;x++){
            cin >> map[x][y];//  避免出现次数为0 的情况
            if(map[x][y]){
                peach[++k].num = map[x][y];
                peach[k].td = (x + y) * 2;
            }
        }
    }
    k = 0;
    for(int y = 1;y <= n;y++){
        for(int x = 1;x <= m;x++){
            cin >> a;
            if(map[x][y])
                peach[++k].ti = a;
        }
    }
    for(int i = 1;i <= k;i++){
        for(int j = td;j >= 1;j--){
            for(int g = 1;g <= peach[i].ti;g++){
                if(j - g * peach[i].td >= 0)
                    f[j] = max(f[j] , f[j - g * peach[i].td] + g * peach[i].num);
            }
        }
    }
    cout << f[td];
    return 0;
}

```

---

## 作者：revenger (赞：1)

这道题可以把每个桃树看做一个物品 预处理出摘取的时间和体力 其实就是个二维费用背包

但是由于移动一格消耗的时间和体力是一样的 所以也用不到二维背包 把时间和体力合并成一维即可

最后就是一个多重背包

本来应该可以用二进制拆分的 但是手懒没办法╮(╯▽╰)╭ 反正数据也不大

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long f[101][101],f1[101];
long m,n,ti,a,i,j,l,p,g;
int t[10001],k[10001],c[10001];
main()
{
    scanf("%d%d%d%d",&n,&m,&ti,&a);
    ti=min(ti,a-1);
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    scanf("%d",&f[i][j]);
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    {
    scanf("%d",&l);
    if(f[i][j])
    {
        g++;
        t[g]=2*(i+j);
        k[g]=l;
        c[g]=f[i][j];
    }
    }
    for(i=1;i<=g;i++)
    for(l=ti;l>=0;l--)
    for(j=1;j<=k[i];j++)
    if(l-j*t[i]>=0)
    f1[l]=max(f1[l],f1[l-t[i]*j]+j*c[i]);
    printf("%d",f1[ti]);
}
```

---

## 作者：Rubyonly (赞：0)

一个比较裸的多重背包，二进制优化一下会更好。

首先将每个点的距离记录下来，横纵坐标加起来就是到这个点的距离，因为要往返，别忘了乘以 $2$。

记录下每棵桃树能够摘的次数，走完全背包就可以了。

不过记录背包的最大容量时要注意，限制的时间和体力$-1$取最小值。

因为PFT回来时不能体力为 $0$，所以要留 $1$ 个体力，所以要 $-1$
```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e5+50;
int n,m;
int T,a;
int tot;
int V;
struct Node{
	int v,w,k;
}e[maxn];
int f[maxn];
void Bag(){//多重背包
	for(int i=1;i<=tot;i++){
		int sum=0;
		for(int k=1;k*e[i].v<=V&&sum+k<=e[i].k;k<<=1){//二进制优化
			sum+=k;
			for(int j=V;j>=k*e[i].v;j--){
				f[j]=max(f[j],f[j-k*e[i].v]+k*e[i].w);
			}
		}
		int x=e[i].k-sum;
		if(x!=0){
			for(int j=V;j>=x*e[i].v;j--){
				f[j]=max(f[j],f[j-x*e[i].v]+x*e[i].w);
			}
		}
	}
}
int main(){
	scanf("%d%d%d%d",&n,&m,&T,&a);
	int nt=n*m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%lld",&e[++tot].w);
			e[tot].v=(i+j)*2;//记录距离
		}
	}
	tot=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&e[++tot].k);
		}
	}
	V=min(T,a-1);//得出最大容量
	Bag();
	printf("%d\n",f[V]);
	return 0;
}
```

---

## 作者：不存在之人 (赞：0)

### 分析：

多重背包，但有两个条件，看似很烦，但只要我们留意题目：每次的代价都是一样的(一个单位)！

那么我们只要求出他们其中最小的那个，将其用在循环条件即可。

当然，题目还有一个细节：ta不想体力值为0，那我们就提前将体力值-1，避免以后的操作。

### Code:
```cpp
#include<cstdio>
#include<iostream>
#define LL long long
using namespace std;
inline LL read()
{
	LL d=0,f=1;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){d=d*10+s-'0';s=getchar();}
	return d*f;
}
int max(int x,int y)
{
	return x>y? x:y;
}
void write(int x)
{    
    if (!x) return;    
    write(x/10);    
    putchar(x%10+48);    
}
int f[10001];  
int main()
{
	int a,b,n,m,v[10001],w[10001],s[10001];//v为桃数，w为代价(时间和体力的消耗)，s为可摘次数
	a=read();b=read();n=read();m=read();m--;//体力值-1	
	for(int i=1;i<=a;i++) 
	  	for(int j=1;j<=b;j++)
	    	v[(i-1)*b+j]=read(),w[(i-1)*b+j]=i+j;//数学求消耗
	for(int i=1;i<=a;i++) 
	  	for(int j=1;j<=b;j++)
	    	s[(i-1)*b+j]=read();
	int minm=n<m? n:m;//求时间与体力中的最小数
	for(int i=1;i<=a*b;i++)
	  	for(int j=minm;j>=0;j--)
	    	for(int k=0;k<=s[i];k++)
	    	{
		    	if(j-k*2*w[i]<0) break;//来回→*2
		    	f[j]=max(f[j],f[j-k*2*w[i]]+k*v[i]);
	    	}
	if(!f[minm]) printf("0\n"); else write(f[minm]);
	return 0;
}
```

---


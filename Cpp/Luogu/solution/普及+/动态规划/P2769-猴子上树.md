# 猴子上树

## 题目描述

在猴村有一条笔直的山路，这条山路很窄，宽度忽略不计。有 $n$ 只猴子正站在山路上静静地观望今天来参加比赛的各位同学。用一个正整数 $X_i$ 表示第 $i$ 只猴子所站位置，任意两只猴子的所站位置互不相同。在这条山路的 $m$ 个位置上种着一些高大的树木，正整数 $Y_j$ 表示第 $j$ 棵树木所在的位置，任意两棵树的位置互不相同。

正当猴子们聚精会神的欣赏各位高超编程技能 聚精会神的欣赏各位高超编程技能时，一只老虎大摇摆的走了过来。猴子们吓得直冒冷汗，第一反应就是找棵大树爬上去这样能避免被老虎咬死或者吃掉（不考虑老虎上树问题）。

在位置 $a$ 的猴子跑到在位置 $b$ 的大树上，需要消耗能量为 $|a-b|$（即 $a-b$ 的绝对值）。为了尽可能有效利用这些大树避难，每棵上至少要一只猴子。
请编程计算 $n$ 只猴子全部上树最少需要消耗多少能量？


## 说明/提示

$30%$ 的数据，$1\le n \le 500$，$1≤X_i,Y_i≤10^5$。

$100%$ 的数据，$1≤n≤5000$，$1≤m≤n$，$1≤Xi,Yi≤10^9$。


## 样例 #1

### 输入

```
3
1 4 5
2
3 8
```

### 输出

```
6
```

## 样例 #2

### 输入

```
3
3 1 10
2
8 3
```

### 输出

```
4
```

# 题解

## 作者：wasa855 (赞：17)

首先此题一定要先对两个数组排序。   
然后采用动态规划的思想，定义```f[i][j]=```前i只猴子上前j棵树的消耗的最小能量。   
对于转移方程：如果```j==1```，即只有一棵树，那么```f[i][j]```必然等于```f[i-1][j]+abs(a[i]-b[j])```。   
如果```j==i```，即```i```只猴子上```i```棵树，又因为每棵树上必有一致猴子，```f[i][i]```必然等于```f[i-1][i-1]+abs(a[i]-b[i])```。   
对于其他情况，有两种情况，第一是第```i```只猴子独占第```j```棵树，第二是第```i```只猴子和其他猴子共享第```j```棵树，即从```min(f[i-1][j],f[i-1][j-1])```转移而来，最后加上```abs(a[i]-b[j])```就好了。   
看到数据范围，最后结果可能会超过$int(c++)$的范围，所以要开$long long(c++)$，但经计算需要约$190MB$的空间，所以要开滚动数组。   
###### 最后，祝大家$NOIP2018 RP++$。   
附上代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define INF 4611686018427387903
ll mon[5005];
ll tree[5005];
ll f[2][5005];
int main()
{
	int n,m;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&mon[i]);
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		scanf("%lld",&tree[i]);
	}
	sort(mon+1,mon+n+1);
	sort(tree+1,tree+m+1);
	f[1][1]=abs(mon[1]-tree[1]);
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(j==1)
			{
				f[i%2][1]=f[(i-1)%2][1]+abs(mon[i]-tree[j]);
				continue;
			}
			if(i==j)
			{
				f[i%2][j]=f[(i-1)%2][j-1]+abs(mon[i]-tree[j]);
				break;
			}
			f[i%2][j]=min(f[(i-1)%2][j],f[(i-1)%2][j-1])+abs(mon[i]-tree[j]);
		}
	}
	cout<<f[n%2][m]<<endl;
	return 0;
}
```

---

## 作者：Tiffany_Tendering (赞：6)

本题是一道dp的题目
先看题目里的关键条件
m <= n 以及 每一棵树上都要有至少一只猴子

这就决定了我们的程序循环里主要的部分是枚举树 而不是猴子
注意 是主要的部分！

再往下 看数据范围 n <= 5000很明显我们可以O（n ^ 2） 

但我们不能开二维空间

不过我们可以先从二维开始思考 （我就是从二维开始做... 第一次用二维过了75分）
用f[i][i]来表示前 i 只猴子上了前 j 课树
最后易发现我们的 i 只要从 1 开始枚举即可 这样就可以少一维空间

注意这里我们要用long long

具体见代码啦！！

    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #include<cmath>
    using namespace std;
    const long long maxn = 5005 ;
    long long n,mon[maxn],tree[maxn],m,f[3][maxn];
    int main() {
	    scanf("%d",&n) ;
	    for(long long i = 1;i <= n ;++i) scanf("%d",&mon[i]) ;
	    scanf("%d",&m) ;
	    for(long long i = 1;i <= m ;++i) scanf("%d",&tree[i]) ;
	    sort(mon + 1,mon + n + 1) ;
	    sort(tree + 1,tree + m + 1) ;
	    memset(f,0x7f,sizeof(f)) ;
	    f[1][1] = abs(mon[1] - tree[1]) ;
	    for(long long i = 2;i <= n ;++i)
	     for(long long j = 1;j <= m ;++j) {
	      	f[i % 2][j] = min(f[(i - 1 ) % 2][j] , f[(i - 1 ) % 2][j - 1]) + abs(mon[i] - tree[j]) ;
	  }
	    cout<<f[n % 2][m] ;
	    return 0;
}


---

## 作者：Exber (赞：4)

## 做法
二维 DP。

先对猴子的位置和树的位置排一下序，再来跑 DP。

定义 $dp_{i,j}$ 为前 $i$ 只猴子爬前 $j$ 棵树所消耗的最小能量值，考虑一下状态转移方程

对于某些特殊情况：如果 $j$ 为 ```1```，那么就只有一棵树，所以 $dp_{i,1}=dp_{i-1,1}+\left|a_{i}-b_{j}\right|$；如果 $j=i$，那么因为每棵树上至少要有一只猴子，所以 $dp_{i,i}=dp_{i-1,i-1}+\left|a_{i}-b_{j}\right|$。

对于其它情况，则有两种可能。即第 $i$ 只猴子自己上第 $j$ 棵树或者第 $i$ 只猴子和其他猴子一起上第 $j$ 棵树，所以 $dp_{i,j}=\min(dp_{i-1,j},dp_{i-1,j-1})+\left|a_{i}-b_{j}\right|$。

但是，出题人实在是太坏了 quq，竟然卡空间，导致二维的 DP 数组会 MLE。

所以需要压缩一下空间，由于我们只需要用到第 $i$ 层的结果和第 $i-1$ 层的结果，所以我们完全可以把 DP 数组前面的一维去掉，然后把第二层循环改成倒序的，就可以轻松 AC 本题啦。

DP 数组记得开 ```longlong```。


## AC 代码
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

int n,m;
long long a[5005],b[5005];
long long dp[5005]; // 滚动数组压空间 

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>b[i];
	}
	// 排序 
	sort(a+1,a+n+1);
	sort(b+1,b+m+1); 
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=1;j--) // 滚动数组：倒序枚举 
		{
			if(j==1)
			{
				dp[j]=dp[j]+abs(a[i]-b[j]); // 第一种特殊情况 
			}
			else if(i==j)
			{
				dp[j]=dp[j-1]+abs(a[i]-b[j]); // 第二种特殊情况 
			}
			else
			{
				dp[j]=min(dp[j],dp[j-1])+abs(a[i]-b[j]); // 普通情况 
			}
		}
	}
	cout<<dp[m]<<endl;
	return 0;
}
```


---

## 作者：Trimsteanima (赞：3)

首先可以想到贪心，所以，先把a、b数组快排

但是此题可用DP

$f[i,j]$表示前i只猴子到前j棵树上的最小价值（第i只猴子在第j棵树上）

前i-1只猴子可以到前j棵树或前j-1棵树上

$f[i,j]=min(f[i-1,j],f[i-1,j-1]) +abs(a[i]-b[j]);$

$abs(a[i]-b[j])$表示现在的价值

时间复杂度：$O(n^2)$

可是会爆内存！！

发现$f[i]$只和$f[i-1]$有关

故使用滚动数组

```pas
var n,m,i,j:longint;
    a,b:array[0..5001]of longint;
    f:array[0..5001,0..5001]of int64;
procedure sorta(l,r:longint);//快排a
var i,j,x,y:longint;
begin
  i:=l;j:=r;
  x:=a[(l+r) div 2];
  repeat
    while a[i]<x do inc(i);
    while x<a[j] do dec(j);
    if not(i>j) then
      begin
      y:=a[i];a[i]:=a[j];a[j]:=y;
      inc(i);j:=j-1;
      end;
  until i>j;
  if l<j then sorta(l,j);
  if i<r then sorta(i,r);
end;
procedure sortb(l,r:longint); //快排b
var i,j,x,y:longint;
begin
  i:=l;j:=r;
  x:=b[(l+r) div 2];
  repeat
    while b[i]<x do inc(i);
    while x<b[j] do dec(j);
    if not(i>j) then
      begin
      y:=b[i];b[i]:=b[j];b[j]:=y;
      inc(i);j:=j-1;
      end;
  until i>j;
  if l<j then sortb(l,j);
  if i<r then sortb(i,r);
end;
function min(x,y:int64):int64;//求最小
begin if x<y then exit(x) else exit(y);end;
begin
read(n);for i:=1 to n do read(a[i]);
  read(m);for i:=1 to m do read(b[i]);
  sorta(1,n);sortb(1,m);
  for i:=1 to n do     //猴子一只只取
    begin
    if i<=m then        //可以取1~i棵树
      begin
      if i>1 then f[i,i]:=f[i-1,i-1]+abs(a[i]-b[i]);   //取第i棵树不能取到f[i-1,i]
      for j:=i-1 downto 2 do
        f[i,j]:=min(f[i-1,j],f[i-1,j-1])+abs(a[i]-b[j]);
      end
    else for j:=m downto 2 do      //可以取1~m棵树
           f[i,j]:=min(f[i-1,j],f[i-1,j-1])+abs(a[i]-b[j]);
    f[i,1]:=f[i,1]+abs(a[i]-b[1]);    //取第1棵树不能取到f[i,0]
    end;
  writeln(f[n,m]);
end.
ps：滚动数组可减小对空间的使用
```

---

## 作者：66666a (赞：3)

作为数据的提供者，我发了第一个题解

代码略长，主要是有两个快排

那么这题呢，首先是使用dp的思想

先两个数组分别快排，设f[i,j]为第i只猴子上第j棵树时的最小距离

初始值f[1,1]:=abs(a[1]-b[1])，因为第1只猴子必须要上第一棵树，不然会让其他的猴子多走路

所以转移方程就是f[i,j]:=max(f[I-1,j],f[i-1,j-1])+abs(a[i]-b[j])

最后的值就在f[n,m]中

另外，由于和可能超过maxlongint，所以当然要定int64，但那样会爆内存，所以自然地想到了背包问题的优化，一维就够了

还有，由于之前需要赋较大的值，但不能赋maxlongint，需要赋maxint64左右的值，大约是18000000000000000000

```cpp
uses math;
var a,b:array[0..100000] of longint;
f:array[0..100000] of int64;
i,j,n,m:longint;
procedure sort1(l,r: longint);
var
i,j,x,y: longint;
begin
i:=l;
j:=r;
x:=a[(l+r) div 2];
repeat
while a[i]<x do inc(i);
while x<a[j] do dec(j);
if not(i>j) then
begin
y:=a[i];
a[i]:=a[j];
a[j]:=y;
inc(i);
j:=j-1;
end;
until i>j;
if l<j then sort1(l,j);
if i<r then sort1(i,r);
end;
procedure sort2(l,r: longint);
var
i,j,x,y: longint;
begin
i:=l;
j:=r;
x:=b[(l+r) div 2];
repeat
while b[i]<x do inc(i);
while x<b[j] do dec(j);
if not(i>j) then
begin
y:=b[i];
b[i]:=b[j];
b[j]:=y;
inc(i);
j:=j-1;
end;
until i>j;
if l<j then sort2(l,j);
if i<r then sort2(i,r);
end;
begin
readln(n);
for i:=1 to n do read(a[i]);
readln;
readln(m);
for i:=1 to m do read(b[i]);
sort1(1,n);
sort2(1,m);
for i:=0 to m do f[i]:=18000000000000000000
f[1]:=abs(a[1]-b[1]);
for i:=2 to n do
for j:=m downto 1 do
f[j]:=min(f[j],f[j-1])+abs(a[i]-b[j]);
writeln(f[m]);
end.

```

---

## 作者：vgccyaj (赞：2)

本题是一个dp题

有两种思路

1、设f[i][j]为前i只猴子爬到j棵树上的最小需要消耗的能量怎么转移 f[i][j]呢， 我们考虑爬到第j棵树上的猴子情况：

设从第k…i只猴子爬到第j棵树上，则f[i][j]=min{f[k-1][j-1]+s[k][i][j]}(j≤k≤i)

s[k][i][j]预处理，时间复杂度为O(n^2\*m)

显然 这是超时的

所以有法二、

2、转移

（1）只有第i只猴子爬到第j棵树上

（2）除了第i只猴子外还有别的猴子爬到第j棵树上

f[i][j]=min{f[i-1][j-1],f[i-1][j]}+abs(a[i]-b[j]) 

时间复杂度为O(n^2)


特别注意要有滚动数组，否则会超空间

下附程序



```cpp
#include <iostream>
using namespace std;
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
const int N=5005;
int n,m;
int x[N],y[N];
long long f[2][N];
int main(){
    int i,j;
    scanf("%d",&n);for(i=1;i<=n;i++) scanf("%d",&x[i]);
    scanf("%d",&m);for(i=1;i<=m;i++) scanf("%d",&y[i]);;
    sort(x+1,x+n+1);//排序
    sort(y+1,y+m+1);//排序
    memset(f,0x7f,sizeof(f));
    f[1][1]=abs(x[1]-y[1]);
    for(i=2;i<=n;i++)
        for(j=1;j<=m;j++)
            f[i&1][j]=min(f[i-1&1][j-1],f[i-1&1][j])+(long long)abs(x[i]-y[j]);
    cout<<f[n&1][m]<<endl;
    return 0;
    }

```

---

## 作者：loceaner (赞：1)

## 题意

> 给出 $n$ 个起始点和 $m$ 个目标点，从位置 $x$ 到位置 $y$ 的花费为 $|x-y|$。现在要所有的起始点移动到某个目标点，满足每个目标点上都至少有一个起始点且总花费最小。

## 思路

显然要先把两个数组从小到大排序，因为走到离自己近的位置一定比走到离自己远的位置要更优。

之后考虑 DP，用 $f_{i,j}$ 表示前 $i$ 只猴子移动到前 $j$ 颗大树能够消耗的最小能量值，$a_i$ 表示第 $i$ 只猴子的位置，$t_i$ 表示第 $i$ 棵树的位置

显然当 $j=1$ 时有 $f_{i,1}=f_{i-1,1}+|a_i-t_j|$

否则有 $f_{i,j}=\min(f_{i-1,j-1},f_{i-1,j})+|a_i-t_j|$

但是还需要特判 $j=i$ 的情况，此时不能从 $f_{i-1,j}$ 转移过来。因为当 $j=i$ 时，每只猴子所到达的树都不同，所以此时只能从 $f_{i-1,j-1}$ 转移

最后一点：这样会炸空间，但是发现每次转移都是从 $i-1$ 转移过来的，所以可以用滚动数组

## 代码

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;

const int A = 5e3 + 11;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

ll f[2][A];
int n, m, a[A], t[A], now = 0, last = 1;

int main() {
  n = read();
  for (int i = 1; i <= n; i++) a[i] = read();
  sort(a + 1, a + 1 + n);
  m = read();
  for (int i = 1; i <= m; i++) t[i] = read();
  sort(t + 1, t + 1 + m);
  for (int i = 1; i <= n; i++) {
    swap(now, last);
    f[now][1] = f[last][1] + 1ll * abs(a[i] - t[1]); 
    for (int j = 2; j <= min(i, m); j++) {
      if (j == i) f[now][j] = f[last][j - 1] + 1ll * abs(a[i] - t[j]);
      else f[now][j] = min(f[last][j - 1], f[last][j]) + 1ll * abs(a[i] - t[j]);
    } 
    memset(f[last], 0, sizeof(f[last]));
  }
  cout << f[now][m] << '\n';
  return 0;
}

```

---

## 作者：wtxy2006 (赞：0)

#### 题目大意：
有 $n$ 只猴子和 $m$ 棵树，在位置 $a$ 的猴子跑到在位置 $b$ 的大树上，需要消耗能量为 $\left|a-b\right|$，要求每颗树上至少一只猴子，求最少消耗的能量。
#### 题目分析：
这是一道dp题，首先设计状态，$f[i][j]$ 表示前 $i$ 个猴子上了前 $j$ 棵树，所需的最小花费。
考虑转移，
首先定义：
```cpp
#define cost(i, j) (abs(a[i] - b[j]))
```
- 只有第 $i$ 只猴子**一只**爬到第 $j$ 棵树上。
- 除了第 $i$ 只猴子外还有**别的猴子**爬到第 $j$ 棵树上。
  
所以可以写出如下转移方程：
$$f[i][j] = \min\left({f[i-1][j-1], f[i-1][j]}\right) + cost\left(i,j\right) $$
从这个转移方程我们可以发现 $f[i][j]$ 的状态只和 $f[i - 1][j]$有关，所以可以用滚动数组优化空间。
首先定义：
``` cpp
#define pre(i) ((i + 1) % 2)
#define now(i) (i % 2)
```
方程变成了这样：
$$f[now(i)][j] = \min(f[pre(i)][j], f[pre(i)][j - 1]) + cost(i, j);$$
最后提醒大家：**三年oi一场空，不开long long见祖宗**。
#### 完整代码：
```cpp
// P2769 猴子上树
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#define cost(i, j) (abs(a[i] - b[j]))
#define pre(i) ((i + 1) % 2)
#define now(i) (i % 2)
#define ll long long
#define MN 5010
using namespace std;
inline ll read() {
  ll x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9')
    x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
  return x * f;
}
ll n, m, a[MN], b[MN], f[2][MN];
int main() {
  n = read();
  for (int i = 1; i <= n; i++) a[i] = read();
  m = read(), memset(f, 0x3f, sizeof(f));
  for (int i = 1; i <= m; i++) b[i] = read();
  sort(a + 1, a + n + 1), sort(b + 1, b + m + 1), f[1][1] = cost(1, 1);
  for (int i = 2; i <= n; i++)
    for (int j = 1; j <= i && j <= m; j++)
      f[now(i)][j] = min(f[pre(i)][j], f[pre(i)][j - 1]) + cost(i, j);
  printf("%lld", f[now(n)][m]);
}
```
复杂度 $O(n*m)$。

---

## 作者：木木！ (赞：0)

首先呢，我们想到贪心，每棵树找到和他最近的猴几。

然而，可能会有多棵树找到同一只猴几，处理起来很麻烦。

于是就能想到dp求解。

如果`dp[i][j]`表示第i个猴子，第j颗树开始所耗费的最小能量，那么就可以推出状态转移方程：

`dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + dist(mi[i],ti[j])`

小秘诀：如果状态转移方程读不懂就按照状态定义大声读出来。

时间复杂度为$\Theta(n^2)$，发现能过，但是空间炸了，然后就想到用滚动数组。

这里滚动数组比较巧妙，因为求解`dp[i][j]`只参考到其后面的值，因此可以直接用一维数组，不用`dp[2][5005]`了。

然后是边界判定。

我边界判定写烦了，就直接用初始化成最大值来规避掉边界判定。这似乎是一个很常用的方法，比如bfs一幅图的时候可以在四周缀上障碍物来避免边界判定。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

#define int long long

int mi[5005];
int ti[5005];
int dp[5005];

inline int min(int a,int b)
{
	return a<b?a:b;
}

inline int myabs(int x)
{
	return x<0?-x:x;
}

inline int dist(int x,int y)
{
	return myabs(x-y);
}

bool cmp(int x,int y)
{
	return x<y;
}

signed main()
{
	int n;
	scanf("%lld",&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%lld",mi+i);
	}
	int m;
	scanf("%lld",&m);
	for(int i=1; i<=m; ++i)
	{
		scanf("%lld",ti+i);
	}

	sort(mi+1,mi+1+n,cmp);
	sort(ti+1,ti+1+m,cmp);

	for(int j=1; j<=m; ++j)
	{
		dp[j] = 0x7f7f7f7f7f7f7f7fLL;
	}

	for(int i=n; i>=1; --i)
	{
		for(int j=1; j<=min(m,i); ++j)
		{
			dp[j] = min(dp[j],dp[j+1]) + dist(mi[i],ti[j]);
		}
		dp[m+1] = 0x7f7f7f7f7f7f7f7fLL; //WA好多次的原因就是没加这句话
	}

	printf("%lld\n",dp[1]);

	return 0;
}
```

---

## 作者：Rather_LYJ (赞：0)

  首先，看完题目就会有一个O(N)的贪心想法，但是仔细想一下，实际上，猴子选择的树木是具有后效性的，所以贪心KO。
  
  想到后效性，就可以想到DP。脑子里很快就想到一个DP的定义：f[i][j]表示前i棵树已经有j只猴子上树了。一下子，再认真思考一下，f[i][j]由f[i-1][j-1]与f[i][j-1]推过来。可以得，f[i][j]=min(f[i-1][j-1],f[i][j-1])+abs(a[j]-tree[i])----加上当前第j只猴子爬上第i棵树的价值。很快，一个DP的转移方程就写出来了。一估空间复杂度，不行(再加上数据类型是超长整形),再看转移方程，只跟第i-1棵树有关，所以可以得，f[i&1][j]=min(f[1-i&1][j-1],f[i&1][j])+abs(a[j]-tree[i])
  
  注意：这里的f[i&1]一定要清成很大的数。
  
  写好了转移方程，考虑初始和循环。初始也很简单,先初始清成很大的数字，根据定义有可得f[0][0]=0。在考虑循环。第一层循环是棵数的循环，第二层是猴子数量的循环。在做第二层循环时，可以进行优化。因为“为了尽可能有效利用这些大树避难，每棵大树上至少要有一只猴子”，所以我们第二层的起点是i，终点是N-(M-i)。这样能节省不少时间。
  
  答案不用说，看懂上面的就知道一定是f[M&1][N]。
  
  PS：N是猴子数量，M是树木的数量。
  
以下内容是代码实现：
```cpp
#include<bits/stdc++.h>
#define maxn 5005
using namespace std;
inline int read()
{
	int ret=0;char ch=getchar();
	while (!isdigit(ch)) ch=getchar();
	while (isdigit(ch)) ret=ret*10+ch-48,ch=getchar();
	return ret;
}
long long f[2][maxn];
int N,M,tree[maxn],a[maxn];
int main()
{
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
	N=read();
	for (int i=1;i<=N;i++) a[i]=read();
	M=read();
	for (int i=1;i<=M;i++) tree[i]=read();
	sort(a+1,a+1+N);sort(tree+1,tree+1+M);
	memset(f,127,sizeof f);
	f[0][0]=0;
	for (int i=1;i<=M;i++)
	{
		memset(f[i&1],127,sizeof(f[i&1]));
		for (int j=i;j<=N-(M-i);j++)
		f[i&1][j]=min(f[1-i&1][j-1],f[i&1][j-1])+abs(a[j]-tree[i]);
	}
	printf("%lld\n",f[M&1][N]);
	return 0;
}
```

###    祝各位新年快乐！

---


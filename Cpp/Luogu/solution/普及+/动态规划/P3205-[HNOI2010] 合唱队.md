# [HNOI2010] 合唱队

## 题目描述

为了在即将到来的晚会上有更好的演出效果，作为 AAA 合唱队负责人的小 A 需要将合唱队的人根据他们的身高排出一个队形。假定合唱队一共 $n$ 个人，第 $i$ 个人的身高为 $h_i$ 米（$1000 \le h_i \le 2000$），并已知任何两个人的身高都不同。假定最终排出的队形是 $A$ 个人站成一排，为了简化问题，小 A 想出了如下排队的方式：他让所有的人先按任意顺序站成一个初始队形，然后从左到右按以下原则依次将每个人插入最终棑排出的队形中：

- 第一个人直接插入空的当前队形中。

- 对从第二个人开始的每个人，如果他比前面那个人高（$h$ 较大），那么将他插入当前队形的最右边。如果他比前面那个人矮（$h$ 较小），那么将他插入当前队形的最左边。

当 $n$ 个人全部插入当前队形后便获得最终排出的队形。

例如，有 $6$ 个人站成一个初始队形，身高依次为 $1850, 1900, 1700, 1650, 1800, 1750$，  
那么小 A 会按以下步骤获得最终排出的队形：

- $1850$。

- $1850, 1900$，因为 $1900 > 1850$。

- $1700, 1850, 1900$，因为 $1700 < 1900$。

- $1650, 1700, 1850, 1900$，因为 $1650 < 1700$。

- $1650, 1700, 1850, 1900, 1800$，因为 $1800 > 1650$。

- $1750, 1650, 1700, 1850, 1900, 1800$，因为 $1750 < 1800$。

因此，最终排出的队形是 $1750, 1650, 1700, 1850, 1900, 1800$。

小 A 心中有一个理想队形，他想知道多少种初始队形可以获得理想的队形。

请求出答案对 $19650827$ 取模的值。

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$。  
对于 $100\%$ 的数据，$n \le 1000$，$1000 \le h_i \le 2000$。

## 样例 #1

### 输入

```
4
1701 1702 1703 1704```

### 输出

```
8```

# 题解

## 作者：kradcigam (赞：478)

### 讲讲我的做法

看了题目发现要用区间 dp，为什么?

我们发现区间 dp 有一个性质——大区间包含小区间，这道题就符合这样的一个性质:

![](https://cdn.luogu.com.cn/upload/pic/75397.png)

所以我们要用区间 dp 来解决这道题。
#### 如何设计状态
那么我们要怎么设计状态，我们想，每给人进入队伍里，只有 2 种可能：

1. 从左边加入;

2. 从右边进入。

所以我们的状态是有3个数：

$f_{i,j,0}$ 表示的是第 $i$ 人从左边进来的方案数；

$f_{i,j,1}$ 表示的是第 $j$ 人从右边进来的方案数。

#### 推导状态转移方程

从左边进来肯定前 $1$ 个人比他高，前 $1$ 个人有 $2$ 种情况，要么在 $i+1$ 号位置，要么在 $j$ 号位置。

同理，

从右边进来肯定前 $1$ 个人比他矮，前 $1$ 个人有 $2$ 种情况，要么在 $j-1$ 号位置，要么在 $i$ 号位置。

那么状态转移方程就出来了：

```cpp
if(a[i]<a[i+1])f[i][j][0]+=f[i+1][j][0];
if(a[i]<a[j])f[i][j][0]+=f[i+1][j][1];
if(a[j]>a[i])f[i][j][1]+=f[i][j-1][0];
if(a[j]>a[j-1])f[i][j][1]+=f[i][j-1][1];
f[i][j][0]%=19650827;
f[i][j][1]%=19650827;
```
#### 边界条件
当 $i=j$ 的时候显然只有一种方案，所以边界条件是：

```cpp
for(int i=1;i<=n;i++)f[i][i][0]=1,f[i][i][1]=1;
```
然而你会发现你 WA 了，为什么？

因为，只有一个人的时候方案只有 $1$ 种，可是我们这里却有 $2$ 种方案，所以我们得默认 $1$ 个人的时候，是从左边进来，于是我们就有了正确的边界条件：

```cpp
for(int i=1;i<=n;i++)f[i][i][0]=1;
```
#### 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[2010][2010][2],a[2010];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)f[i][i][0]=1;
	for(int len=1;len<=n;len++)
		for(int i=1,j=i+len;j<=n;i++,j++){
			if(a[i]<a[i+1])f[i][j][0]+=f[i+1][j][0];
			if(a[i]<a[j])f[i][j][0]+=f[i+1][j][1];
			if(a[j]>a[i])f[i][j][1]+=f[i][j-1][0];
			if(a[j]>a[j-1])f[i][j][1]+=f[i][j-1][1];
			f[i][j][0]%=19650827;
			f[i][j][1]%=19650827;
		}
	cout<<(f[1][n][0]+f[1][n][1])%19650827;
	return 0;
}

```


---

## 作者：Rush_Hht (赞：151)

# 区间DP
 这道题还是很有意思的呢！

题目的话，我就不在此赘诉了！
想必大家都不是刚接触区间DP，对于区间DP的做法一定有自己的见解吧！要是萌新的话，这道题还是有点困难的哦，但是不要害怕，我会带你安全到达目的地的！

 一、让我们开始推状态转移方程吧!

### 【实例推演】

 小提示：要想发掘状态转移方程式，首先就要**善于观察**。但要注意的一点：千万**不能一根筋**哦，就比如我，刚开始看到这道题的时候，以为是排列组合的题，想到的就是乘法，事实上乘法是行不通的呢。

 我们先从简单的入手，举个栗子先吧：
如：****11 22 33 （理想队列）****
它可能是由什么转移过来的呢？

因为它包含了3个元素，那我们就想一想它是由哪个含2个元素的队列转化过来的呢？转化过来后种数会有什么变化呢？

好像是11 22转化过来的；22 33也可能！对的。

对于队列11 22 ：33可能是跟在11后面的，也可能是跟在22后面的（因为11，22都比33小啊，而且11，22是在一头一尾的，那么33的前面有可能是11或22）。

对于队列22 33 ：11可能是跟在22后面的，也可能是跟在33后面的（因为22，33都比11小啊，而且22，33是在一头一尾的，那么11的前面有可能是22或33）。

所以对于理想队列11 22 33它的初始队形的情况种数 = 理想队列11 22种数  \*  2种 + 理想队形22 33种数 \* 2种。

诶，我们好像发现了状态转移方程了呢：

_**f[i][j] = 2 \* f[i][j - 1] + 2 \* f[i + 1][j]。**_ 

但其实我们忽略了一点情况：不知道你们有没有注意到我在括号里的内容，第一：11 ， 22是在一头一尾的；第二：11 22 都比33小，不是所有的队列都满足这种情况的NA。

****其实我们对于33后放转移的种数应该是：队列 11 22 中 11 后放的情况（条件:33 > 11）+ 队列 11 22 中 22 后放的情况（条件：33 > 22）都是有条件的哦****

所以我们的状态转移方程式应该是这样的：**队列 11 22 33 = 队列 11 22 中 11 后放的情况（条件:33 > 11）+ 队列 11 22 中 22 后放的情况（条件：33 > 22）+ 队列 22 33 中 22 后放的情况（条件:11 < 22）+ 队列 22 33 中 33 后放的情况（条件：11 < 33）**

注意哦：我们的判断条件是队列的一前一后两个元素的大小。

是的，我们很快就能想到式子：

_**f[j][i] = f[j][i + 1] (num[i] < num[i + 1]) + f[i + 1][j] (num[i] <num[j])**_   
_**f[i][j] = f[i][j - 1] (num[j] > num[j - 1])  + f[j - 1][i] (num[j] > num[i])**_  
这就是我们的状态转移方程式了！

是不是我的转移方程式把你搞迷糊了？： _**f[i][j]**_ 我知道是什么意思：元素 i 到元素 j 嘛，那么 _**f[j][i]**_ 呢？是元素 j 到元素 i 吗？怎么反着来啊？

听我道来！这里的 _**f[i][j]**_ 表示的是队列i、i+1、i+2、...、j-1、j 中 **j** 元素最后放的情况种数，那么 _**f[j][i]**_ 表示的就是元素 **i** 最后放的情况种数咯，能理解吗？好像有点道理吧！**（因为元素i必定是跟在元素i+1或者是元素j后被放入的，所以还要考虑一下元素 i+1 和 元素 j哪个是最后放进来的。好好理解一下吧，么么哒！）**
### 【方程确立】
再总结一下我们所得出的状态转移方程，以代码形式呈现咯！
```cpp
if (num[i] < num[i + 1]) f[j][i] += f[j][i + 1];
if (num[i] < num[  j  ]) f[j][i] += f[i + 1][j];
if (num[j] > num[j - 1]) f[i][j] += f[i][j - 1];
if (num[j] > num[  i  ]) f[i][j] += f[j - 1][i]
```

**二、进入区间枚举问题。**


这道题枚举区间显而易见需要从小范围到大范围。对于我自己的话，我是比较喜欢这样枚举区间的：
```cpp
	for (int i = 2; i <= n; i++)
	    for (int j = 1; i + j - 1 <= n; j++)
	    	 int k = i + j - 1;
```
**i 表示序列的长度；**

**j 表示序列的首项的位置；**

**k 表示序列的末项的位置。**

亲爱的小伙伴们看懂了吗？

这只是我个人的枚举方法，如果你们有自己的方法，也可以自己试试哟。

有小伙伴就问了这样的枚举方法这道题试用吗,当然试用。

这道题要求原来的排列情况有多少种，当然是可以用“从小的区间拓展到大的的区间”这种方法解决的，刚才我们推状态转移方程式的时候不就是从小到大的吗。

OK!问题解决了,注意要mod19650827哦。

最后给你们附上代码。（自己写的时候要注意细节哦！么么哒！）
```cpp
#include <cstdio>
using namespace std;
int num[1111], dp[1111][1111];
int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
	    scanf("%d", num + i);
	    dp[i][i] = 1;//要初始化哦！
	}
	for (int i = 2; i <= n; i++)
	    for (int j = 1; i + j - 1 <= n; j++){
	    	int k = i + j - 1;
	    	if (num[j] < num[j + 1])           dp[k][j] += dp[k][j + 1];
	    	if (num[j] < num[k] && j != k - 1) dp[k][j] += dp[j + 1][k];//注意哦，当序列元素只有2的时候j == k - 1的呢
	    	if (num[k] > num[k - 1])           dp[j][k] += dp[j][k - 1];
	    	if (num[k] > num[j] && j != k - 1) dp[j][k] += dp[k - 1][j];
	    	dp[j][k] %= 19650827, dp[k][j] %= 19650827;
		}
	printf("%d\n", (dp[1][n] + dp[n][1]) % 19650827);
	return 0;
}
```
以上为我的题解，如果有什么不足之处请管理员大大和各位Oier指出。


---

## 作者：zhylj (赞：78)

设$f[i][j]$为可以排成理想队列中$[i,j]$区间，且以最后一个排进去是第$i$人的初始队列种数。

$g[i][j]$为可以排成理想队列中$[i,j]$区间，且以最后一个排进去是第$j$人的初始队列种数。

---

$f$数组情况：

①前一个排进去的人是$i+1$，当前人插到最左边，有：

$f[i+1][j]\qquad\cdots\qquad(a[i]<a[i+1])$

②前一个排进去的人是$j$，当前人插到最左边，有：

$g[i+1][j]\qquad\cdots\qquad(a[i]<a[j])$

根据加法原理，求和，即

```cpp
f[i][i+len]=
	(f[i+1][i+len]*(a[i]<a[i+1])+g[i+1][i+len]*(a[i]<a[i+len]))%mod;
```

---

$g$数组情况：

③前一个排进去的人是$i$，当前人插到最右边，有：

$f[i][j-1]\qquad\cdots\qquad(a[i]>a[j])$

④前一个排进去的人是$j-1$，当前人插到最右边，有：

$g[i][j-1]\qquad\cdots\qquad(a[i]>a[j-1])$

根据加法原理，求和，即：

```cpp
g[i][i+len]=
	(f[i][i+len-1]*(a[i+len]>a[i])+g[i][i+len-1]*(a[i+len]>a[i+len-1]))%mod;
```

---

代码： (76ms / 9.62MB)

```
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1005, mod = 19650827;

int n, a[MAXN];

int f[MAXN][MAXN], g[MAXN][MAXN];
int sovle()
{
    for(int i=0;i<n;i++)  //初始值，只有一个人的区间只有1种情况
        f[i][i]=1;
    for(int len=1;len<n;len++)  //最基础的区间dp
        for(int i=0;i+len<n;i++)
        {
            f[i][i+len]=( f[i+1][i+len]*(a[i]<a[i+1]) + 
                          g[i+1][i+len]*(a[i]<a[i+len]) )%mod;  //这部分上面已经说得很清楚了
            g[i][i+len]=( f[i][i+len-1]*(a[i+len]>a[i]) +
                          g[i][i+len-1]*(a[i+len]>a[i+len-1]) )%mod;
        }
    return (f[0][n-1]+g[0][n-1])%mod;
}

int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=0;i<n;i++)  //读入
        cin>>a[i];
    cout<<sovle()<<endl;
    return 0;
}
```

---

## 作者：帅到报警 (赞：31)

### 【题意描述】
给定一串序列，问有多少种初始序列经过如题操作可以得到此序列。

### 【分析】
~~我其实是想刷区间 dp 题才看这道题的，，，，~~
我们知道这是一道区间 dp 题，那么状态转移方程该怎么写呢？

当我们没有想到如何枚举区间处理的时候，我们首先可以先联想到以前做过的 dp 题。

这道题是要我们向左向右插入数字，这让我想起了**p2858奶牛的零食**。

[来看一看~~](https://www.luogu.org/problemnew/show/P2858)

那么我们可以归纳出**左端点的数只与下一个或者右端点的在初始序列中相邻，右端点的数只与前一个或者左端点的在初始序列中相邻。**



我们可以定义 f[ i ][ j ][ k ]为 i 到 j 这一段将 i 或 j 插入的情况数， k = 1 表示在右端插入， k = 0 在左端插入。因为每一次的插入位置只与上一个数有关，那么我们只要分出 4 种情况进行讨论即可。

1. 当右端点的数大于上一个且上一个插入在右端时：

	f[ i ][ j ][ 1 ] += f[ i ][j - 1][ 1 ];
    
1. 当右端点的数大于左端点且上一个插入在左端时：

	f[ i ][ j ][ 1 ] += f[ i ][ j - 1 ][ 0 ]; 
    
1. 当左端点的数小于后一个且上一个插入在左端时：

	f[ i ][ j ][ 0 ] += f[ i + 1 ][ j ][ 0 ];
    
1. 当左端点的数小于右端点且上一个插入在右端时：
	
    f[ i ][ j ][ 0 ] += f[ i + 1 ][ j ][ 1 ];
    
### 【核心代码】
注意答案为最后一个插入的为右端点和最后一个插入的为左端点之和。**还有千万别忘了取模！！！！**
```cpp
for(int l = 2; l <= n; l++)
{
	for(int i = 1; i <= n - l + 1; i++)
	{
		int j = i + l - 1;
		if(a[j] > a[j - 1])
			f[i][j][1] += f[i][j - 1][1];
		if(a[j] > a[i])
			f[i][j][1] += f[i][j - 1][0];
		if(a[i] < a[i + 1])
			f[i][j][0] += f[i + 1][j][0];
		if(a[i] < a[j])
			f[i][j][0] += f[i + 1][j][1];
		f[i][j][0] %= MOD;
		f[i][j][1] %= MOD; 
	}
}
printf("%d", (f[1][n][0] + f[1][n][1]) % MOD);
```

### 【正解】
```cpp
#include <bits/stdc++.h>
#define N 2001
#define MOD 19650827
using namespace std;

int n;
int a[N];
int f[N][N][2];

inline int read()
{
    char ch = getchar();
	int x = 0, f = 1;
    while(ch > '9' || ch < '0')
	{
		if(ch == '-')
			f = -1;
		ch = getchar();
	}
    while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
    return x * f;
}

void Solve()
{
	for(int i = 1; i <= n; i++)
		f[i][i][0] = 1;
	for(int l = 2; l <= n; l++)
	{
		for(int i = 1; i <= n - l + 1; i++)
		{
			int j = i + l - 1;
			if(a[j] > a[j - 1])
				f[i][j][1] += f[i][j - 1][1];
			if(a[j] > a[i])
				f[i][j][1] += f[i][j - 1][0];
			if(a[i] < a[i + 1])
				f[i][j][0] += f[i + 1][j][0];
			if(a[i] < a[j])
				f[i][j][0] += f[i + 1][j][1];
			f[i][j][0] %= MOD;
			f[i][j][1] %= MOD; 
		}
	}
	printf("%d", (f[1][n][0] + f[1][n][1]) % MOD);
}

int main()
{
	n = read();
	for(int i = 1; i <= n; i++)
		a[i] = read();
	Solve();
	
	return 0;
}
```

---

## 作者：CuSO4_and_5H2O (赞：30)

### [区间 DP 的题目 QwQ](https://www.luogu.com.cn/problem/P3205)
  （浅浅的修改了下笔误~~好多~~）
  
  [~~无耻的推销一下我的动态规划笔记~~](https://www.luogu.com.cn/blog/zhuaigezhangzixuan/DP-shi-God)。
  
  本片题解将我的思考过程写了出来，可以帮您更好的学习动态规划的思路过程。
  
  这个题目我第一眼看上去毫无思路，看了题解发现还是很简单的。
  
  思考一下我当初为什么没有思路（大部分初学者都这样吧），因为刚做完板子题目，觉得区间动态规划的 $f_{i,j}$ 就是应该表示 $i$ 到 $j$ 合并的方案数，思维被模板禁锢，就一直在这个思路上去想，去尝试状态转移方程，但是这个题目真正的思路是这个吗？很明显并不是。
  
  思考一下这个题目的状态和什么有关系，当一个人进来的时候他在左或右是根据上一个人的身高来确定的，也就是说，上一个人的身高影响当前人的位置。所以状态数组之中一定要体现出上一个人的身高这一关键信息，如果按照合并石子的思想来做他并不可以表示上一个人的身高。就思考如何让状态方程去记录。
  
  下边一段思考当前人放在队列右边的情况（放在左边的情况是一样的，只不过翻过来，请读者自己思考）。
  
  这里注意，题目中的完美队列是已知固定的，当一个区间的一个人进去所排成的队列的方案数和一个人有关，就是最后进去的那个人，那个人（他的前一个人）有两个人选，一是当前队列最后边那个，二是当前队列最前边那个，所以只要当前人（注意断句，当前人而不是当 前人）比那两个人高新形成的队列的排列方式就是两者之和，如果有一个人（最后入队的那两个人）比他（当前人）高就把这个加数删掉就好了。
  
  思考到这里思路就明了了，想办法表示出从 $i$ 个人到第 $j$ 个人中 $i$ 先入队和 $j$ 先入队的数量，然后枚举区间就可以了。
  
  如何设计方程？
  
  设 $f_{i,j}$ 表示从 $i$ 到 $j$，$j$ 先入队的队列数量，这样就完成了状态数组的设置。状态转移方程呢？
  
  $f_{i,j}=f_{i,j-1} (a_{j-1} < a_j) + f_{j-1,i} (a_i < a_j)$
  
  $f_{j,i}$ 同理，和上边的一样（对于状态转移方程要看完题解之后自己写出来，这个你就自己写吧）。
  
  ~~真不是懒~~因为我觉得做动态规划如果只是单纯的比这题解打下来式子是没有意义的，要理解式子里每个值得意义然后自己推到，自己看着自己的推导打出来。
  
  **最后，做动态规划思路一定要灵活多变，根据题目的条件设置转移数组，之后推导方程。**
  
  ## 代码实现

  不要比着题解写啊，自己推出来然后自己实现。
  
  ```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+1,mod=19650827;

int n,a[N],f[N][N];

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],f[i][i]=1;
	for(int len=2;len<=n;len++)
	{
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			if(a[j-1]<a[j]) f[i][j]+=f[i][j-1];
			if(a[i]<a[j] && len!=2) f[i][j]+=f[j-1][i];
			//为什么要len!=2因为当len==2的时候就是说第一个人从左进来或从右（这样就是两个方案了）但是第一个人明显只有一个方案啊。所以就特判一下，让第一个人只有一个方案 
			f[i][j]%=mod;f[j][i]%=mod;
			if(a[i]<a[i+1]) f[j][i]+=f[j][i+1];
			if(a[i]<a[j] && len!=2) f[j][i]+=f[i+1][j];
			f[i][j]%=mod;f[j][i]%=mod;
		}
	}
	cout<<(f[1][n]+f[n][1])%mod;
}

```

  

---

## 作者：55555g (赞：17)

这道题很坑啊，没有给出数据范围，应该是0<n<=1000,然后还漏了一个条件，就是将答案对19650827进行取模。

对于这道题，一开始可以想到对最终序列进行搜索，根据题目要求来还原原序列，找到一个序列就ans++。但是数据范围显然承受不住。

进一步分析，对于最终序列的一个区间[l,r]，最后一个添加的只可能是第l个人或者第r个人。如果最后一个是l，则对于这个区间，a[l]<a[l+1]或者a[l]<a[r]。如果最后一个是r，则对于这个区间a[r]>a[r-1]或者a[r]>a[l]。

于是想到一个区间动态规划，定义f[l,r]表示在最终序列区间序列[l,r]中，最后一个添加的人是l时所得到的方案数，g[l,r]表示在最终序列区间序列[l,r]中，最后一个添加的人是r时所得到的方案数。[l,r]这个区间可以从[l+1,r]和[l,r-1]转移过来，判断最后这个人和上一个人的大小关系，分成两类:除去最后这个人，上一个人添加在区间左边/右边。

得到动态转移方程：f[l,r]:=f[l+1,r]\*(a[l]<a[l+1])+g[l+1,r]\*(a[l]<a[r]);

g[l,r]:=f[l,r-1]\*(a[l]<a[r])+g[l,r-1]\*(a[r-1]<a[r]);

```pascal
var i,n,j,l,r,mo:longint;
    f,g:array[0..1001,0..1001] of longint;
    a:array[0..1001] of longint;

function pd(a,b:longint):longint;
begin
if a<b then exit(1) else exit(0);
end;

begin
mo:=19650827;
read(n);
for i:=1 to n do read(a[i]);
for i:=1 to n do
        begin
        f[i,i]:=1;
        end;
for i:=1 to n-1 do
for j:=1 to n do
        begin
        if j+i>n then continue;
        l:=j;r:=j+i;
        f[l,r]:=(f[l+1,r]*pd(a[l],a[l+1])+g[l+1,r]*pd(a[l],a[r])) mod mo;
        g[l,r]:=(f[l,r-1]*pd(a[l],a[r])+g[l,r-1]*pd(a[r-1],a[r])) mod mo;
        end;
writeln((f[1,n]+g[1,n]) mod mo);
end.
```

---

## 作者：xzyxzy (赞：15)

# 区间DP，用记忆化搜索实现
~~没有卡常，10分钟做出来，还跑最快代码最短，写个题解留念下~~

dp[i][j]表示现在还剩[i,j]这一段没有处理，op=0表示上一次删掉的是左边的，op=1表示上次删的右边的，方案数

转移的话条件就是从左边转移那么这次丢掉的要比上一次大，从右边则反

临界条件就是l==r

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
const int MAXN=1010;
const int mod=19650827;
int N,A[MAXN],dp[MAXN][MAXN][2];
int DFS(int l,int r,int op)
{
	if(l==r) dp[l][r][op]=((A[l]<A[l+1]&&op)|(A[l]>A[l-1]&&!op))?1:0;
	if(dp[l][r][op]!=-1) return dp[l][r][op];
	int ans=0;
	if(op==1)
	{
		if(A[l]<A[r+1]) ans+=DFS(l+1,r,0);
		if(A[r]<A[r+1]) ans+=DFS(l,r-1,1);
	}
	else
	{
		if(A[l]>A[l-1]) ans+=DFS(l+1,r,0);
		if(A[r]>A[l-1]) ans+=DFS(l,r-1,1);
	}
	return dp[l][r][op]=ans%mod;
}
int main()
{
	scanf("%d",&N);memset(dp,-1,sizeof(dp));
	for(int i=1;i<=N;i++) scanf("%d",&A[i]);
	printf("%d\n",DFS(1,N,0)); return 0;
}
```

### 顺便安利一波[我的博客](https://www.cnblogs.com/xzyxzy/)

---

## 作者：撤云 (赞：14)

## [_$$blog$$_](https://www.cnblogs.com/hbxblog/p/10253422.html)
---
### 题目链接  
[戳我](https://www.luogu.org/problemnew/show/P3205)
### $Solution$
令:
$f[i][j]$为$[i,j]$中最后排进去的是第i人  
$dp[i][j]$为$[i,j]$中最后排进去的是第j人  


则排头的元素即$f[i][j]$有两种插入方式：

1. $a[i]<=a[i+1]$
2. $a[i]<a[j]$

因为你在插入的时候可以放在队列两边

所以尾部的元素即$dp[i][j]$也有两种插入方式

1. $a[j-1]<a[j]$
2. $a[i]<a[j]$

所以直接枚举$j$转移就好了,复杂度为$O(n^2)$


### Code 

```cpp
#include<bits/stdc++.h>
#define rg register
#define int long long
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
const int mod=19650827;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
int f[1001][1001],dp[1001][1001],a[1001];
main(){
    int n=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    for(int i=1;i<=n;i++)
        f[i][i]=1;
    for(int i=n;i>=1;i--)
        for(int j=i+1;j<=n;j++){
            if(a[i+1]>a[i])
                f[i][j]+=f[i+1][j];
            if(a[j]>a[j-1])
                dp[i][j]+=dp[i][j-1];
            if(a[i]<a[j])
                f[i][j]+=dp[i+1][j],dp[i][j]+=f[i][j-1];
            f[i][j]%=mod,dp[i][j]%=mod;
        }
    printf("%lld",(f[1][n]+dp[1][n])%mod);
}
```

---

## 作者：Vin_1999 (赞：7)

区间dp。注意初始化。转移方程在下面。






```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<string>
#include<cstdio>
#include<queue>
#include<stack>
#include<set>
#include<map>
#include<vector>
#include<climits>
#define rep(i,s,n) for(int (i)=(s);(i)<=(n);(i)++)
using namespace std;
const int maxn=1000+7,mod=19650827;
static int dp[maxn][maxn][2],n,a[maxn];
int main()
{
  freopen("e:/in.txt","r",stdin);
  //freopen("e:/out.txt","w",stdout);
     scanf("%d",&n);
     rep(i,1,n) scanf("%d",&a[i]);
     rep(i,1,n) dp[i][i][0]=1;
  rep(l,2,n) 
    {
      rep(i,1,n-l+1)
      {
          int j=i+l-1;
          if(a[j]>a[j-1]) dp[i][j][1]+=dp[i][j-1][1];
          if(a[j]>a[i]) dp[i][j][1]+=dp[i][j-1][0];
          if(a[i]<a[i+1]) dp[i][j][0]+=dp[i+1][j][0];
          if(a[i]<a[j]) dp[i][j][0]+=dp[i+1][j][1];
          dp[i][j][0]%=mod;
          dp[i][j][1]%=mod;
        }
        //rep(i,1,n-l) printf("%d/%d ",dp[i][i+l-1][0],dp[i][i+l-1][1]);
        //printf("%d/%d\n",dp[n-l+1][n][0],dp[n-l+1][n][1]);
    }
    printf("%d",(dp[1][n][0]+dp[1][n][1])%mod);    
}//by fjlyyz-ljy
```

---

## 作者：清风霁月 (赞：6)

     给定一个理想数列，例如：1701,1702,1703,1704，求一共有多少种原队列
     通过排队方式很显然可以看出原队列的最后一位应该从1701和1704中选取
     如果选择的是1701，那么原问题就产生一个子问题：
     给定一个理想数列，1702,1703,1704求一共有多少种原队列
     如果选择的是1704，那么原问题就产生另一个子问题：
     给定一个理想序列，1701,1702,1703求一共有多少种原序列

     由此，任何一个大于二的理想序列都可以分成两个子理想序列
     一次选择可以选择队首元素，或者队尾元素
     于是我想到了vijos-P1037搭建双塔
     本题也同样需要用两个二维数组，来回推导
     数组f是当本次选择队首元素时一共有多少种原序列
     数组g是当本次选择队尾元素时一共有多少种原序列
     状态转移方程为：
            if(a[i]<=a[i+1])
                f[i][j]=(f[i][j]+f[i+1][j])%MOD;
            if(a[i]<a[j])
                f[i][j]=(f[i][j]+g[i][j-1])%MOD;
            if(a[i]<a[j])
                g[i][j]=(g[i][j]+f[i-1][j])%MOD;
            if(a[j]>a[j-1])
                g[i][j]=(g[i][j]+g[i][j-1])%MOD;

CODE


     #include<cstdio>
     #include<cstring>
     #include<algorithm>
     #define N 1010
     #define MOD 19650827
     using namespace std;
     int n;
     int a[N];
     int f[N][N];
     int g[N][N];

     int main()
     {
         scanf("%d",&n);
         for(int i=1;i<=n;i++)
         scanf("%d",&a[i]);
         for(int i=1;i<=n;i++)
         f[i][i]=1;
         for(int i=n-1;i>=1;i--)
         {
             for(int j=i+1;j<=n;j++)
             {
                 if(a[i]<a[i+1])
                 f[i][j]=(f[i][j]+f[i+1][j])%MOD;
                 if(a[i]<a[j])
                 f[i][j]=(f[i][j]+g[i+1][j])%MOD;
                 if(a[i]<a[j])
                 g[i][j]=(g[i][j]+f[i][j-1])%MOD;
                 if(a[j]>a[j-1])
                 g[i][j]=(g[i][j]+g[i][j-1])%MOD;
             }
         }
         printf("%d\n",(f[1][n]+g[1][n])%MOD);
         return 0;
     }

---

## 作者：ShuYuMo (赞：5)

# 这是一道DP题T_T


[https://www.luogu.org/problem/P3205](https://www.luogu.org/problem/P3205)

# 方程

 - $f[i][j]$表示可以排成理想队形中的$[i, j]$, 且最后一个加进去的人被放在最左边。
 - $g[i][j]$表示可以排成理想队形中的$[i, j]$, 且最后一个加进去的人被放在最右边。

 - 对于$f[i][j]$，最后一个人被放在了$i$所以转移应在区间$[i + 1, j]$处。
 - 对于$g[i][j]$，最后一个人被放在了$j$所以转移应在区间$[i, j - 1]$处。

所以:
 - $f[i][j]$要在$f[i + 1][j]$和$g[i + 1][j]$转移过来
 - $g[i][j]$要在$f[i][j - 1]$和$g[i][j - 1]$转移过来

考虑当什么时候f[i][j]会在f[i + 1][j]转移过来，  
$f[i][j]$表示最后一个人放在了最左边，根据题目，最后一个人要比前面那个人矮才能放在最左边。   

对于$f[i + 1][j]$来说，上一个人是$i + 1$，所以第$i$个人要矮于第$i + 1$个人，$f[i][j]$才能从$f[i + 1][j]$转移。  

同理，当所以第$i$个人要矮于第$j$个人,$f[i][j]$才能从$g[i + 1][j]$转移过来。

$$f[L][R] = (f[L + 1][R] * (A[L + 1] > A[L]) + g[L + 1][R] * (A[R] > A[L]))$$

下面对于$g[i][j]$的转移同理，唯一的不同就是最后一个人被放在了最右边。

$$g[L][R] = (f[L][R - 1] * (A[L] < A[R]) + g[L][R - 1] * (A[R - 1] < A[R]))$$

区间`DP`，每个状态在转移时依赖于小区间的值，所以要保证短区间要早于长区间的处理时间。


我觉得这个题的意义还没有完成，我们从头思考，为什么要设计两个不同且相似的数组存储不同的状态。
>对从第二个人开始的每个人，如果他比前面那个人高(H较大)，那么将他插入当前队形的最右边。如果他比前面那个人矮(H较小)，那么将他插入当前队形的最左边

每次决策和最后一次放进去人和当前人的高度关系有关，所以，我们在存储和转移状态时，必须知道最后一次是那个人被放进去了。所以我们就需要两个数组`g`,`f`来记录。

哦对了~借鉴了上一篇题解才写出来，谢谢上一位同学QAQ，我再记录一下自己的心路历程
```cpp
/*!
 * Copyright(c) 2019 Shu_Yu_Mo
 * MIT Licensed
 * Luogu: https://www.luogu.org/space/show?uid=44615
 * Github: https://github.com/oldsuold/
 * Gitee: https://gitee.com/Shu_Yu_Mo/
 * These words were created by an amazing tool written by Shu_Yu_Mo.
 */
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
#include<queue>
#include<algorithm>
#define _R register
#define inf 0x7fffffff
using namespace std;
const int _ = 1100;
const int MOD = 19650827;
inline int read()
{
    char c = getchar(); int sign = 1; int x = 0;
    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); }
    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }
    return x * sign;
}
int n;
int A[_];
int f[_][_];//最后一个人放在最左边边 
int g[_][_];//最后一个人放在最右边边
int main()
{
	n = read();
	for(_R int i = 1;i <= n;i++){
		A[i] = read();
	}
	for(_R int i = 1;i <= n;i++)
		f[i][i] = 1;
	for(_R int len = 2;len <= n;len++){
		for(_R int L = 1;L + len - 1 <= n;L++){
			int R = L + len - 1;
			f[L][R] = (f[L + 1][R] * (A[L + 1] > A[L]) + g[L + 1][R] * (A[R] > A[L])) % MOD;
			g[L][R] = (f[L][R - 1] * (A[L] < A[R]) + g[L][R - 1] * (A[R - 1] < A[R])) % MOD;
		}
	}
	printf("%d", (f[1][n] + g[1][n]) % MOD);
	return 0;
}
```

UDP：@lzzhhh发现一处笔误……

---

## 作者：noall (赞：4)

## 吐槽

这题老师~~（学姐）~~讲的时候，一眼看上去，真的好难啊！

但是仔细一想，好像真的对不起这蓝色的难度了。

~~真是个sb题啊，亏我想了那么久！！！！~~

好了，不bibi了，看题。

我们都知道这是个区间DP，那么我们就直接谈谈思路吧！

## 思路

我们暂且将给出的数据中的数列叫做理想数列。

例如样例中的`1701 1702 1703 1704`便是一个理想数列。

我们用两个数组来处理，

$f_{i,j}$表示在理想数列中的$[i,j]$这个区间，最后一个被加入的数是$i$的情况数。

$g_{i,j}$表示在理想数列中的$[i,j]$这个区间，最后一个被加入的数是$j$的情况数。

因此，可以分别得到两种情况：

### 对于f数组

1. 前一个排进去的人是**i+1**。
2. 前一个排进去的人是**j**。

#### 得到代码：

```cpp
if(a[i]<a[i+1]) (f[i][j]+=f[i+1][j])%=mod;
if(a[i]<a[j]) (f[i][j]+=g[i+1][j])%=mod;
```

### 对于g数组

1. 前一个排进去的人是**i**。
2. 前一个排进去的人是**j-1**。

#### 得到代码

```cpp
if(a[j]>a[i]) (g[i][j]+=f[i][j-1])%=mod;
if(a[j]>a[j-1]) (g[i][j]+=g[i][j-1])%=mod;
```

答案便是`f[1][n]+g[1][n]`

## code

```cpp
#include<cstdio>

const int maxn=1e3+10;
const int mod=19650827;

int n,a[maxn],f[maxn][maxn],g[maxn][maxn];

inline int read(){
	char ch=getchar();int f=1,r=0;
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){r=r*10+ch-'0';ch=getchar();}
	return f*r;
}

int main(){
	n=read();
	for(register int i=1;i<=n;i++){
		a[i]=read();
		f[i][i]=1;//dp: [i,i]区间中只有一个人,情况只有一种
	}
	for(register int i=n;i>=1;i--){
		for(register int j=i+1;j<=n;j++){
			if(a[i]<a[i+1]) (f[i][j]+=f[i+1][j])%=mod;
			if(a[i]<a[j]) (f[i][j]+=g[i+1][j])%=mod;
			if(a[j]>a[i]) (g[i][j]+=f[i][j-1])%=mod;
			if(a[j]>a[j-1]) (g[i][j]+=g[i][j-1])%=mod;
		}
	}
	printf("%d\n",(f[1][n]+g[1][n])%mod);
	return 0;
}
```



---

## 作者：红色OI再临 (赞：3)

与1220有点像，因为转移的时候要考虑子问题的左右端点

设 $f[l][r][0]$ 为目标队形中$ [l, r]$ 区间的方案数，且最后一个人在最左的方案数，$f[l][r][1]$反之同理

得到转移方程：

$f[l][r][0]=(f[l+1][r][0])*(h[l]<h[l+1])+f[l+1][r][1]*(h[l]<h[r])$

表示当前这个人的上一个人可能是`l+1`，也可能是`r`，方案数直接累加。

$f[l][r][1]$同理：

 $f[l][r][1]=f[l][r-1][0]*(h[r]>h[l])+f[l][r-1][1]*(h[r]>h[r-1])$

最后输出$f[1][n][0]+f[1][n][1]$即可

记得取模哦！模数是19650827,而不是~~数据删除~~（巨雾）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define re register int
#define ll long long
#define maxn 2000
#define mod 19650827
using namespace std;
int f[maxn][maxn][3];
int h[maxn];
int main(){
	int n;
	scanf("%d",&n);
	for(re i=1;i<=n;i++)
		scanf("%d",&h[i]);
       //初始状态
	for(re i=1;i<=n;i++)
		f[i][i][0]=1;
		

		for(re len=2;len<=n;len++)
			for(re l=1;l+len-1<=n;l++){
				int r=l+len-1;
				f[l][r][0]=(f[l+1][r][0])*(h[l]<h[l+1])%mod+f[l+1][r][1]*(h[l]<h[r])%mod;
				f[l][r][0]%=mod;
				f[l][r][1]=f[l][r-1][0]*(h[r]>h[l])%mod+f[l][r-1][1]*(h[r]>h[r-1])%mod;				
				f[l][r][1]%=mod;
			}
		printf("%d",(f[1][n][0]%mod+f[1][n][1]%mod)%mod);
	return 0;
	
}
```


---

## 作者：QMQMQM4 (赞：2)

# 提供一个只用开一个数组的题解

思考状态转移方程，维护区间i到j以及最后一个人是在最左还是最右

dp[i][j][0] = dp[i + 1][j][0] · [hi < hi+1] + dp[i + 1][j][1] · [hi < hj
]

dp[i][j][1] = dp[i][j − 1][0] · [hj > hi
] + dp[i + 1][j][1] · [hj > hj−1]

0表示在最左，1表示在最右

而最后更新答案只需把dp[1][n][0]+dp[1][n][1]即可

需要注意的是初始化时只更新dp[i][i][0]的值

避免统计两遍

```
#include<cstdio>
#include<cstring>
using namespace std;

typedef long long ll;
const int mood = 19650827;
const int maxn = 1005;
int a[maxn],dp[maxn][maxn][2];


int main()
{
	int n;
	ll x,y;
	scanf("%d",&n);
	for(int i = 1;i<=n;++i)
		scanf("%d",&a[i]);
	memset(dp,0,sizeof(dp));
	for(int i = 1;i<=n;++i)
		dp[i][i][0] = 1;//这里要注意如果初始化两遍需要除二，就涉及到逆元
	for(int l = 2;l<=n;++l)
	{
		for(int i = 1,j;(j=i+l-1)<=n;++i,++j)
		{
			dp[i][j][0] = dp[i+1][j][0]*(a[i+1]>a[i])%mood+dp[i+1][j][1]*(a[i]<a[j])%mood;
			dp[i][j][1] = dp[i][j-1][0]*(a[j]>a[i])%mood+dp[i][j-1][1]*(a[j]>a[j-1])%mood;
		}
	}
	ll ans = dp[1][n][1]+dp[1][n][0];
	printf("%lld",ans%mood);
	return 0;
}
```
### 贴下初始化dp[i][i][0]与dp[i][i][1]的代码
```
#include<cstdio>
#include<cstring>
using namespace std;

typedef long long ll;
const int mood = 19650827;
const int maxn = 1005;
int a[maxn],dp[maxn][maxn][2],inv[maxn];


int main()
{
	int n;
	ll x,y;
	scanf("%d",&n);
	for(int i = 1;i<=n;++i)
		scanf("%d",&a[i]);
	memset(dp,0,sizeof(dp));
	for(int i = 1;i<=n;++i)
		dp[i][i][0] = dp[i][i][1] = 1;
	inv[1] = 1;
	for(int i = 2;i<=n;++i)
		inv[i] = (ll)(mood-mood/i)*inv[mood%i]%mood;
	for(int l = 2;l<=n;++l)
	{
		for(int i = 1,j;(j=i+l-1)<=n;++i,++j)
		{
			dp[i][j][0] = dp[i+1][j][0]*(a[i+1]>a[i])%mood+dp[i+1][j][1]*(a[i]<a[j])%mood;
			dp[i][j][1] = dp[i][j-1][0]*(a[j]>a[i])%mood+dp[i][j-1][1]*(a[j]>a[j-1])%mood;
		}
	}
	ll ans = dp[1][n][1]+dp[1][n][0];
	ans = ans*inv[2]%mood;
	printf("%lld",ans);
	return 0;
}
```

~~我不会告诉你是上了夏令营我才会的~~

---

## 作者：Guitar_Jasmine (赞：1)

这题~~查看题解以后发现~~是区间$DP$

我们发现这个题要求的序列个数很不好求，所以可以做一个转换：求有多少种不同的插入顺序，使得得到理想队形（好像也不太能算是转换，只是换一种更好$DP$的方式表达）.

然后又发现队形的插入过程只能在最左边和最右边插入，所以想到设$f[i][j][0]$表示$i-j$这段区间（指的是在理想队形里的区间）最后进来的是$i$的不同方案数，$f[i][j][0]$表示$i-j$这段区间最后进来的是$j$的不同方案数。

转移特别好写就直接看代码好了，这里主要讲一下这个题的一个比较容易出错的问题——初始化问题。

可以发现在大多数情况下($i\not=j$)，通过$f[i][j][0]$和$f[i][j][1]$得到的队形的插入顺序是一定不同的（因为$f[i][j][0]$最后插入的是$i$，而$f[i][j][1]$最后插入的是$j$），所以可以保证不会重复计数。那么当$i=j$的时候呢？显然只有直接插$i$这一种方案，所以我们初始化$f[i][j][0]=1,f[i][j][1]=0$

最后的答案就是$f[1][n][1]+f[1][n][0]$（最后一个插进来的一定是$1$或者$n$）

代码如下：

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N=2009,M=19650827;
int n,f[N][N][2],a[N];

void init()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]),f[i][i][0]=1;//初始化
}

void add(int &x,int y)
{
	x=(x+y)%M;
}

void work()
{
	for (int k=2;k<=n;k++)
		for (int i=1;i+k-1<=n;i++)
		{
			int j=i+k-1;
            //各种判断然后转移
			if(a[i]<a[i+1])
				add(f[i][j][0],f[i+1][j][0]);
			if(a[i]<a[j])
				add(f[i][j][0],f[i+1][j][1]);
			if(a[j]>a[j-1])
				add(f[i][j][1],f[i][j-1][1]);
			if(a[j]>a[i])
				add(f[i][j][1],f[i][j-1][0]);
		}
	printf("%d\n",(f[1][n][1]+f[1][n][0])%M);
}

int main()
{
	init();
	work();
	return 0;
}

```


---

## 作者：寒鸽儿 (赞：1)

[博客食用效果更佳](https://www.luogu.org/blog/oldherd/solution-P3205)  
我们思考一下如何搜索。  
设当前搜[i,j]区间的数，并且区间最后一个添加的数字在左端或右端。我们发现这些维度很好表示，于是可以用记忆化搜索或者dp。  
推导的式子如下：  
f(i, j, 1) = f(i, j-1, 0) * (a[i] < a[j]) + f(i, j-1, 1) * (a[j-1] < a[j])  
f(i, j, 0) =  f(i+1, j, 0) * (a[i+1] > a[i]) + f(i+1, j, 1) * (a[j] > a[i])

```cpp
#include <cstdio>
#include <cstring>

using namespace std;

const int maxn = 1010, md = 19650827;
long long f[maxn][maxn][2], a[maxn];

inline long long dp(int i, int j, int pls) {
	if(f[i][j][pls] != -1) return f[i][j][pls];
	long long ans = 0;
	if(pls) {
		if(a[i] < a[j]) ans += dp(i, j-1, 0);
		if(a[j-1] < a[j]) ans += dp(i, j-1, 1);
	} else {
		if(a[i+1] > a[i]) ans += dp(i+1, j, 0);
		if(a[j] > a[i]) ans += dp(i+1, j, 1);
	}
	return f[i][j][pls] = ans % md;
}

int main() {
	int n;
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%lld", a+i);
	memset(f, -1, sizeof(f));
	for(int i = 1; i <= n; i++) f[i][i][0] = 0, f[i][i][1] = 1;
	long long ans =  ( dp(1, n, 0) + dp(1, n, 1) ) % md;
	printf("%lld\n", ans);
	return 0;	
}
```
欢迎互相关注(然而在oi界蒟蒻的圈很小)。  
最后再次安利一下[蒟蒻的洛谷博客](https://www.luogu.org/blog/oldherd/)  

---

## 作者：Jiang_zi_chuan (赞：1)

注意答案对19650827取模。。。

经典的区间DP状态和转移方程

F[l][r]表示当前最后一个添加的人是l的方案数

G[l][r]表示当前最后一个添加的人是r的方案数

f[l][r]=f[l+1][r]   (a[l]<a[l+1])  +g[l+1][r] (a[l]<a[r])

g[l][r]=f[l][r-1]  (a[l]<a[r])  +g[l][r-1] (a[r-1]<a[r]) 

```cpp
// luogu-judger-enable-o2
//#define LOCAL
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <bits/stdc++.h>

#define INF 0x3f
#define ull unsigned long long
#define ll long long
#define FOR(a, b, n) for(int a = b; b >= n ? a >= n : a <= n; b >= n ? a-- : a++)
#define M(a, n) memset(a, n, sizeof(a));
#define S(n) scanf("%d", &n)
#define P(n) printf("%d", n)
#define G(n) getline(cin, n)
#define PI acos(-1.0)

using namespace std;

const int NR = 1006;

inline int read()  {
   	int s = 0, w = 1;
   	char ch = getchar();
   	while(ch <= '0' || ch > '9') {
   		if(ch == '-') {
   			w = -1;
   			ch = getchar();
   		}
   	}
   	while(ch >= '0' && ch <= '9') {
   		s = s * 10 + ch - '0';
   		ch = getchar();
   	}
   	return s * w;
}

const int mod = 19650827; 
ll a[NR], f[NR][NR], g[NR][NR], l, r, n; 
inline ll mx(ll x, ll y) { 
	return x < y ? 1 : 0;
} 
int main() { 
	S(n); 
	FOR(i, 1, n)
		S(a[i]); 
	FOR(i, 1, n) 
		f[i][i] = 1; 
	FOR(i, 1, n - 1) 
		FOR(j, 1, n) { 
			if(i + j > n)
				continue; 
			int l = j, r = j + i; 
			f[l][r] = (f[l + 1][r] * mx(a[l], a[l + 1]) + g[l + 1][r] * mx(a[l], a[r])) % mod; 
			g[l][r] = (f[l][r - 1] * mx(a[l], a[r]) + g[l][r - 1] * mx(a[r - 1], a[r])) % mod; 
		} 
	P((f[1][n] + g[1][n]) % mod);
	return 0; 
}
```

---


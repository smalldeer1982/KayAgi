# 恋爱

## 题目描述

小 A 爱上了小 B！！！可是小 A 相对小 B 太弱，所以她当然不会同意小 A 的请求。小 A 苦苦追求，最终小 B 就提这样的条件：

- 小 B 有 $n$ 个下属（不包括小 B）组成了树状结构，小 B 在顶端，其他人都有一个直属上司。  
- 小 B 编号 $0$，其他人编号 $1 \sim n$。  
- 对于第 $i$ 人，如果这个人没有下属，那么小 A 可以给他 $A_i$ 元钱，则他会向他的直属上司写一封信，表示小 A 向小 B 求爱；  
- 如果他的直属下属有占比不小于 $\dfrac{A_i}{T}$ 的人写信表示小 A 向小 B 求爱，那么他也会向他的直属上司写一封信，表示小 A 向小 B 求爱。    
- 如果小 B 的直属下属有占比不小于 $\dfrac{C}{T}$ 的人写信表示小 A 向小 B 求爱，那么她会同意小 A 的请求。

请问小 A 至少需要给多少钱才会让小 B 同意小 A 的求爱。

## 说明/提示

对于 $20 \%$ 的数据，没有直属下属的人数 $\le 15$。  
对于 $40 \%$ 的数据，$n \le 2000$。  
另有 $10 \%$ 的数据，$B_i = 0$。
另有 $10 \%$ 的数据，$C = 1$ 且对于有直系下属的人 $T / A_i > n$。  
另有 $10 \%$ 的数据，$B_i = i - 1$。

对于 $100 \%$ 的数据，$1 \le n \le 500000$，$1 \le T \le {10}^9$，$B_i < i$，$1 \le A_i \le T$。


## 样例 #1

### 输入

```
14 5 3
0 3
0 3
1 10
1 10
2 3
2 10
2 3
5 10
7 10
5 10
7 10
5 10
7 10
5 10
```

### 输出

```
50
```

# 题解

## 作者：momo5440 (赞：11)

理论上来说这道题根本没有用到一点动态规划的思想，每个节点都取最优最后也是最优，所以这算是一道树上贪心？基本思路呢就是写一个dfs，从根（0）开始遍历对于非叶子节点求出它所有根的值（递归调用dfs）并压入一个优先队列（小根堆），取最上面的大于等于T分之Ai个然后返回它们和的值，对于叶子节点只要返回它的Ai就行了。
详情请见代码，我觉得是挺简短的。
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;//只要空间足够就无脑开long long  
ll a[500005];//题目中每个人的 Ai 
vector<ll> bian[500005];//记录每个人的孩子 
ll n,t,c;//跟题目中一样 
ll dfs(ll x){
	if (bian[x].size()==0) return a[x];//是叶子节点，直接返回 Ai
	priority_queue< ll,vector<ll>, greater<ll> > q;//小根堆 
	for (ll i=0;i<bian[x].size();i++) q.push(dfs(bian[x][i]));//递归调用自己，求出自己孩子的值 
	ll ans=0;
	for (ll i=0;i<1.0*a[x]*bian[x].size()/t;i++){//记得写1.0这样才精确不然会自动取整 
		ans+=q.top();//取前T分之Ai个 
		q.pop();
	}
	return ans;//返回这个节点的值 
}
int main(){
	cin>>n>>t>>c;
	ll tp;
	for (ll i=1;i<=n;i++){
		cin>>tp>>a[i];
		bian[tp].push_back(i);
	}//读入数据并建树 
	a[0]=c;//小B本身的Ai就是c 
	cout<<dfs(0)<<endl;//从根开始遍历 
}
```


---

## 作者：郑朝曦zzx (赞：7)

# 一 题目转述：
由于我不太喜欢这个题目描述，于是用树的术语转述一下：

有一颗有根树，其根节点编号为 $\mathrm{0}$，每个节点有一个权值，对于叶子结点，你花权值的代价使它上传这个权值。对于非叶子结点，如果它的儿子中上传权值的节点数量大于等于儿子数量乘当前节点权值除以 $\textit{T}$，则这个节点也会上传权值，问至少花费多少代价，使得根节点也会上传权值（虽然没地方上传）。

# 二 算法讲解
本题算法：树上动态规划

状态设计：令 $dp_i$ 表示至少需要多少代价这个节点会上传权值。$dp_0$ 即为题目所求。

状态转移：$dp_i$ 应被负值为最小若干个儿子节点的 $\textit{dp}$ 值的总和。

# 三 注意事项：
- 使用数据类型 $\text{long long}$，这一点非常重要，很容易某一部分代码用了，另外一部分忘记使用（我经常出现此类错误)，因没开 $\text{long long}$ 在比赛上丢掉几十分是很吃亏的。
-  递归边界条件，即递归到叶子结点需要特判。

# 四 参考代码：
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
typedef long long ll;
using namespace std;
vector <int> tree[500010];
ll cost[500010];
int n;
ll t, c;
ll f(double x)
{
    if (x > (double)ll(x)) return (ll)x + 1;
    return x;
}
ll Min(ll x, ll y) { return x < y ? x : y; }
ll dp(int x)
{
    int cnt = tree[x].size();
    if (cnt == 0) return cost[x];
    vector <ll> now;
    for (int i = 0; i < cnt; ++i)
        now.push_back(dp(tree[x][i]));
    sort(now.begin(), now.end());
    ll sum = 0;
    sum = f((double)cost[x] * cnt / t);
    ll ans = 0;
    for (int i = 0; i < sum; ++i)
        ans += now[i];
    return ans;
}
int main()
{
    scanf("%d %lld %lld", &n, &t, &cost[0]);
    for (int i = 1; i <= n; ++i)
    {
        int from;
        scanf("%d %lld", &from, &cost[i]);
        tree[from].push_back(i);
    }
    printf("%lld", dp(0));
    return 0;
}
```
管理员，已对照格式要求进行修改，求通过，希望这成为我洛谷主题库中第一篇通过的题解。

---

## 作者：我只能爬 (赞：6)

看到这个题目的名字就忍不住想要做一做。其实这个题目的做法是非常暴力的，感觉撑死也就是个绿题吧。

一个比较裸的树形地痞，老套路$dfs$到最底层然后往上考虑，记录儿子的个数然后往上跑，跑的时候暴力地开一个$vector$记录所有的儿子的值，然后暴力的$sort$一下取前$num$求一下$\sum{a[i]}$（$num$用题目给的方法暴力求就好了）个数加起来，然后暴力的接着往上跑就行了。

总之祝愿所有看到这道题的$dalao$们收获属于自己的爱情（还是不要想题面里那样比较好）

看看我丑陋又暴力的代码吧……

```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <cmath>
#include <numeric>
#include <vector>
#define maxn 10000005
using namespace std;

inline unsigned long long read() {
    unsigned long long x = 0, f = 1;
    char c = '\0';
    while(c > '9' || c < '0') {
        if(c == '-') f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

struct node{
    unsigned long long to, nxt;
}edge[maxn];
unsigned long long f[maxn];
unsigned long long head[maxn], cnt;
unsigned long long res;
vector<unsigned long long> Lily;
unsigned long long n, t, c, a[maxn];

void add(unsigned long long u, unsigned long long v) {
    edge[++cnt].to = v;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
}

void Archmage(unsigned long long x) {
    unsigned long long son = 0;
    for(register unsigned long long i = head[x]; i; i = edge[i].nxt) {
        son++;
        Archmage(edge[i].to);
    }
    if(son == 0) {
        f[x] = a[x];
        return;
    }
    unsigned long long num = ceil((double)((son * a[x] * 1.0) / (t * 1.0)));
    unsigned long long xx = 0;
    Lily.clear();
    for(register unsigned long long i = head[x]; i; i = edge[i].nxt) {
        xx++;
        Lily.push_back(f[i]);
    }
    if(xx <= num) {
    	for(register unsigned long long i = 0; i < xx; ++i) {
    		f[x] += Lily[i];
    	}
    }
    else{
        sort(Lily.begin(), Lily.end());
        for(register unsigned long long i = 0; i < num; ++i)
        	f[x] += Lily[i];
    }
}

int main() {
    n = read(); t = read(); c = read();
    a[0] = c;
    unsigned long long tmpa, tmpb;
    bool flag = false;
    for(register unsigned long long i = 1; i <= n; ++i) {
        tmpb = read();
        tmpa = read();
        add(tmpb, i);
        a[i] = tmpa;
        if(tmpb != 0) flag = true;
    }
    if(flag == false) {
        sort(a + 1, a + 1 + n);
        unsigned long long it = ceil((double)((c * n * 1.0) / (t * 1.0)));
        unsigned long long ans = 0;
        for(register unsigned long long i = 1; i <= it; ++i) {
            ans += a[i];
        }
        cout << ans << endl;
        return 0;
    }
    else {
        Archmage(0);
        cout << f[0] << endl;
        return 0;
    }
    cout << "chen_zhe?" << endl;
    return 0;
}
```

~~也希望我能早日娶到我的白月光~~

---

## 作者：xy0313 (赞：5)

[更优质的阅读体验](https://xy0313.wordpress.com/2020/11/12/%e6%b4%9b%e8%b0%b7p3408-%e6%81%8b%e7%88%b1-%e9%a2%98%e8%a7%a3/)

### 我们姑且称之为树形DP

题目中有一个有一点歧义的地方，就是

“他的直属下属有不小于 T 分之 Ai 的人”

这里指的是所有他的下属总个数的 T 分之 Ai

如果你还不理解，看样例


![](https://ftp.bmp.ovh/imgs/2020/11/731f28e3d02e66bf.png)

这下应该就明白了吧！

========================手动分割线========================

那么怎么写呢？

#### 首先，每个叶子节点上书的代价就是 a[i] 没的说

那么其它节点呢？

#### 对于其它任意一个节点 x ，当前节点上书的最小代价，就是有  son[x] * a[i] / t 个代价最小的子节点上书的代价和

那就好整了，我们只需要用儿子节点里代价最小的那几个，来更新当前节点的代价就好了

那我们来看看代码吧

```cpp
#include <queue>
#include <iostream>
#include <cstring>
#include <cmath>
#define int long long//很方便
using namespace std;

const int N = 5e5 + 5;

int n,t,c;

int son[N];
int a[N];
int f[N];

int tot;
int head[N];
int to[N * 2];
int nxt[N * 2];

void add(int x,int y)
{
	to[++ tot] = y;
	nxt[tot] = head[x];
	head[x] = tot;
}

void dfs(int x)
{
	priority_queue <int,vector <int>,greater <int> > que;//小根堆
 	//我用这个把儿子节点的代价排了序
	for(int i = head[x];i;i = nxt[i])
	{
		int y = to[i];
		dfs(y);
		que.push(f[y]);
	}
	f[x] = a[x];//子节点代价为a[x]
	
	if(que.size())
	{
		f[x] = 0;
		if(x)
		{
			for(int i = 1;i <= ceil(son[x] * a[x] * 1.0 / t);i ++)
            		//ceil向上取整，得乘1.0，有点坑
			{
				int y = que.top();
				que.pop();
				f[x] += y;
			}
		}
		if(!x)//记得0和其它节点是不一样的
		{
			for(int i = 1;i <= ceil(son[x] * c * 1.0 / t);i ++)
			{
				int y = que.top();
				que.pop();
				f[x] += y;
			}
		}
	}
}

signed main()
{
	cin >> n >> t >> c;
	for(int i = 1;i <= n;i ++)
	{
		int x;
		cin >> x >> a[i];
		add(x,i);
		son[x] ++;
	}
	dfs(0);
	cout << f[0];
}
```

最近很多题都交不了题解了，好不容易找到一道，求过qwq

---

## 作者：Digital_Sunrise (赞：2)

## 无关的话

>某些人眼中的真情正在被物质取代，请谨慎恋爱

## 题解部分

[link](https://www.luogu.com.cn/problem/P3408)

[双倍经验](https://www.luogu.com.cn/problem/UVA12186)

首先使用数据建立上级连向下级的单向图。

设节点 $i$ 的儿子数量为 $son_i$ 。

使用 $dfs$ 进行递归。

其中对于任一点 $dfs(i)$ 返回的值表示~~买通~~上奏到 $i$ 点所需要的 RMB，

很显然，对于叶子节点， $dfs(i) = a_i$ ，

而对于中间节点，需要支付 $\left\lceil\dfrac{a_i}{T}\right\rceil\times son_i$ 个子节点所需的RMB（其中 $a_0=C$ ） 。

所以考虑对于每个中间节点建立一个优先队列，选出所需 RMB 最低的 $\left\lceil\dfrac{a_i}{T}\right\rceil\times son_i$ 个子节点，然后将它们的RMB之和作为自己所需的 RMB 并上传 。

显然，答案为 $dfs(0)$ 。

## 

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 5e5 + 5;

int n,T,C,a[maxn],b[maxn];
vector <int> G[maxn];
int root;

int f(double x)
{
    if (x > (double)floor(x))
		return (int)x + 1;
    return x;
}

int dfs(int u)
{
	if(G[u].size() == 0)
		return a[u];
	int threshold;
	threshold = f(a[u] * G[u].size() * 1.0 / T);
	priority_queue <int,vector<int>,greater<int> > q;
	for(int i = 0;i < G[u].size();i++)
		q.push(dfs(G[u][i]));
	int cost = 0;
	for(int i = 1;i <= threshold;i++)
		cost += q.top(),q.pop();
	return cost;
}

signed main()
{
	cin >> n >> T >> C;
	for(int i = 1;i <= n;i++)
	{
		cin >> b[i] >> a[i];
		G[b[i]].push_back(i);
	}
	a[0] = C;
	cout << dfs(0);
	return 0;
}
```

---

## 作者：king_xbz (赞：2)

一道比较基础的树形DP问题

首先，这肯定是个以0为根的树形结构，我们使用邻接表建树，并记录下每个节点儿子的个数。

也就是这样

```cpp
for(fint i=1;i<=n;i++)
cin>>b>>a[i],adds(b,i),adds(i,b),son_num[b]++;
```

然后以0为根进行DFS操作。

此时分类讨论：

- 对于叶子节点，我们一定要给他钱，这样才能满足写信的条件
- 对于非叶结点，由于小B的直属下属有不小于T分之C的人写信表示小A向小B求爱，那么她会同意小A的请求写信。所以我们选择最小的$a[x]*son_num[x]/t+1$给钱。

此时的花费就是最小的。

由此可以得到DP方程式：

$dp[i]+=dp[sons[i]];(i!=leaf)$

$dp[i]+=a[x](i==leaf)$

那么如何选择最小的$a[x]*son_num[x]/t+1$花费呢？

我们可以考虑排序。但是对于邻接表的结构而已，sort起来并不方便，所以我们选择使用小根堆，把亲儿子节点（直属下司）按DP值进行排序，并加入堆，并取出最小的$a[x]*son_num[x]/t+1$个即可。

```cpp
priority_queue <int,vector<int>,greater<int> >q;
for(fint i=head[x];i;i=e[i].nxt)
if(e[i].to!=fa)
q.push(dp[e[i].to]);
```

然后我们按照状态转移方程式更新即可。

对于非叶节点：

```cpp
for(fint i=1;i<=son_num[x]&&i<=(int)((double)a[x]*son_num[x]/t+1)&&q.size();i++)
dp[x]+=q.top(),q.pop();
```

对于叶子节点：

```cpp
if(!son_num[x])
{
	dp[x]+=a[x];
	return ;
}	
```

最后结果就是：

```cpp
cout<<dp[0];
```

完整注释代码：

```cpp
#include<bits/stdc++.h>
#define fint register int
#define H 5001
#define N 4375089
#define int long long
#define _fxxk cout<<"ZGW AK IOI"
using namespace std;
struct node
{
	int to;
	int nxt;
}
e[N];
int cnt;
int head[N];
int n,t,c;
int a[N],son_num[N],dp[N];
inline void adds(int u,int v);
inline void dfs(int x,int fa);
signed main()
{
//	freopen("love.in","r",stdin);
//	freopen("love.out","w",stdout);

	cin>>n>>t>>c;
	int b;
	a[0]=c;
	for(fint i=1;i<=n;i++)
	cin>>b>>a[i],adds(b,i),adds(i,b),son_num[b]++;//存图
//	for(fint i=0;i<=n;i++)
//	cout<<son_num[i]<<" "; 
	dfs(0,n+1);
	cout<<dp[0];
	return 0;
}

inline void adds(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	return ;
}

inline void dfs(int x,int fa)
{
	if(!son_num[x])//叶子节点有爹没儿子 
	{
		dp[x]+=a[x];//那就直接掏钱吧 
		//_fxxk;
		return ;
	}	
	for(fint i=head[x];i;i=e[i].nxt)
	if(e[i].to!=fa)
	dfs(e[i].to,x);
	priority_queue <int,vector<int>,greater<int> >q;//临界表不好排序，那就用堆艹
	for(fint i=head[x];i;i=e[i].nxt)
	if(e[i].to!=fa)
	q.push(dp[e[i].to]);
//	cout<<((double)a[x]*son_num[x]/t)<<" ";
	for(fint i=1;i<=son_num[x]&&i<=(int)((double)a[x]*son_num[x]/t+1)&&q.size();i++)
	dp[x]+=q.top(),q.pop();
//	cout<<dp[x]<<" ";
	return ;
}
```

得分：100

祝大家AC愉快

---

## 作者：CQ_Bab (赞：1)

# 思路
算法：树形动态规划。
这道题我们可以用树形动态规划来做，用 $f_i$ 来表示要让 $i$ 同意向上写信的最小金额。那么输出就为 $f_0$，因为要让 $0$ 点知道。然后我们可以用一个函数来模拟，对于每一个点我们需要先特判这个点是否是叶节点，如果是就直接返回 $a_x$ 否则就要将他的下属都递归一边算出让每一个下属都能向 $x$ 传的最下金额，然后排序，最后将前 $a_i\times son\div t$ 个下属的最小金额加起来并返回即可， $son$ 为这个点的下属个数。
# 代码分析
## 主函数
没什么好讲的
```cpp
	cin >> n >> t >> a[0] ;
	for(int  i = 1 ; i <= n ; i ++ ) {
		int x ;
		cin >> x >> a[i] ;
		add(x , i) ;//存边
	}
	cout << f(0) << endl ;//输出让0知道的最小金额
```
## 函数部分
```cpp
void add (int x, int y) { //建边模板
	edg[++tot].x = y ;
	edg[tot].y = head[x] ;
	head[x] = tot ;
}
int f(int x) {
	if(!head[x]) return a[x] ;//如果这个点为叶节点则返回 a[i]
	vector<int>v ; //用这个动态数组存下让x点的每一个下属往上传的最小金额
	for(int i = head[x] ; i ; i = edg[i].y) {
		int to = edg[i].x ;
		v.push_back(f(to)) ; //算出每一个点往上传的最小金额
	}
	int res = false ;
	sort(v.begin( ) , v.end( ) ) ; //排序
	double sum = 1.0 * a[x] * v.size() / t ; //算出要去除最小的多少个
	for(int i = 0 ; i <= sum ;  i ++ ) res += v[i] ; //求和（算答案）
	return res ; //返回答案
}
```
[UVA12186](https://www.luogu.com.cn/problem/UVA12186)与这道题很像可以做一下。

---

## 作者：快斗游鹿 (赞：1)

## 思路

定义 $dp_i$ 表示第 $i$ 个人写信给其直属上司需要花费的钱数。

当 $i$ 没有下属（即该点为叶子结点）时，$dp_i=a_i$。

否则，考虑如何使钱数花费最少。显然，若要使第 $i$ 个人花费最少，应让他的直接下属中满足其本身人数条件的人数的最小值个人写信，且要使他们的总代价尽量小。由此得出，$dp_i$ 等于其子节点中，所花费代价最小的前 $d\times\frac{a_i}{t}$ 个子节点花费的代价之和，其中 $d$ 表示点 $i$ 的子节点数。

## 代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e5+5;
ll n,t,ans,dp[N],d[N],a[N],w[N],C; 
vector<ll>e[N];
ll dfs(ll root){
	if(!e[root].size()){
		dp[root]=w[root];return dp[root];
	}
	ll cnt=0,a[e[root].size()];
	for(int i=0;i<e[root].size();i++){
		dfs(e[root][i]);
		a[++cnt]=dp[e[root][i]];
	}
	ll c=(d[root]*w[root]-1)/t+1;
	sort(a+1,a+1+cnt);
	for(int i=1;i<=c;i++){
		dp[root]+=a[i];
	}
	return dp[root];
}
int main(){
	cin>>n>>t>>C;
	for(int i=1;i<=n;i++){
		ll x;scanf("%lld%lld",&x,&w[i]);e[x].push_back(i);d[x]++;
	}
	w[0]=C;
	printf("%lld\n",dfs(0));
	return 0;
}
```


---

## 作者：RNTBW (赞：1)

### 序
几年没发 TJ 的我终于回来了！

由于是第一篇树形 DP 的题解，所以讲详细一点儿。
## 题意
给你一棵根为 0 的树和一个序列 $a$ 以及一个数 $t$。

- 对于叶节点 $i$，使它上传权值的代价是 $a_i$。

- 对于其他节点 $j$，使它上传权值的代价是 $a_j \times c_j \div t$ 个儿子上传了权值，$c_j$ 为儿子数目。

- 求使根节点上传权值的代价**最小**是多少。

- $1 \leqslant n \leqslant 5 \times 10^5$，$1 \leqslant t \leqslant 10^9$，$1 \leqslant a_i \leqslant t$。
## 思路
上位黄的树形 DP。

~~不知道为什么是绿~~

显而易见，$i$ 上传权值的代价与它的儿子上传权值的代价有关。

而由于我们求的是根节点上传权值的最小代价，这个代价与根节点的儿子的代价有关。

所以根节点的儿子的代价也要最小。

而根节点的儿子的代价又与它的儿子（就是根节点的孙子）的代价有关....

子子孙孙无穷尽也，所以对于每个节点，我们都需要计算它的最小代价才能使最后根节点的代价最小。

设 $dp_u$ 表示节点 $u$ 的最小代价。

那对于非叶节点，怎么计算 $dp_u$ 呢？

只要有 $a_u \times c_u \div t$ 个儿子上传了权值就行了！

那么 $u$ 的**最小**代价就是它的所有儿子中代价**最小**的那 $a_u \times c_u \div t$ 个。

所以，在爬树的过程中将 $i$ 的儿子上传权值的代价扔进小根堆。

遍历完毕后，堆里的前 $a_j \times c_j \div t$ 个儿子的代价，即 $\sum_{i=1}^{a_j \times c_j \div t} dp_v$，就是 $dp_u$ 了。

至于叶节点，题目里说的很清晰了。~~懒得说~~

其实不用开这个 ``dp`` 数组，直接将最小的几个儿子的代价加起来 ``return`` 就行，但经过实测开数组之后会优化四分之一的时间。

~~有没有大佬算一算时间复杂度啊~~

## 正确代码
如果有萌新不会爬树的话来看一下代码吧。

~~估计没人~~
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mx 500001
int head[mx],dp[mx],a[mx],c[mx];
int n,m,k,x,cnt,q;
struct eve
{
	int u,to,nxt;
} ed[mx*2];
void add(int x,int y)
{
	ed[++cnt].nxt=head[x];
	head[x]=cnt;
	ed[cnt].to=y;
	ed[cnt].u=x;
}//建图
void dfs(int nr)
{
	priority_queue<int,vector<int>,greater<int> >s;
	if(!c[nr])//特判叶结点
	{dp[nr]=a[nr];return;
	}
	for(int i=head[nr];i!=-1;i=ed[i].nxt)//遍历儿子
	{
		int v=ed[i].to;
		dfs(v);//由于需调用dp[v]，所以先搜
		s.push(dp[v]);
	}
	for(int i=0;i<1.0*a[nr]*c[nr]/k;i++) dp[nr]+=s.top(),s.pop();//累加
}
signed main()
{
	memset(head,-1,sizeof(head));
	scanf("%lld%lld%lld",&n,&k,&m);a[0]=m;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&x,&a[i]);
		add(x,i);c[x]++;
	}
	dfs(0);
	printf("%lld",dp[0]);
    	return 0;
}
```


---

## 作者：2020kanade (赞：1)

与其说是 DP，还不如说是树上递推+贪心。

类似的题还有 CSP-S2 2019 D1T2 括号树（树上递推），这一类题我们可以“递归地”思考。

首先只考虑一个结点和其所有子结点之间的关系：
设当前结点 $u$ 的权值为 $dp_u$ （由于笔者习惯，这里按照动态规划命名递推数组），若当前结点的子结点个数为 $child_u$ ，根据题意，当已选子结点数量 $selected_u$  满足  ${\frac{selected_u}{child_u} \ge \frac{a_i}{T}}$  时，该结点可以对其父结点 $w$ 的已选子结点个数 $selected_w$ 做出 $1$ 的贡献；若当前结点是根结点，代表此时有合法解。

接下来考虑计数：对于一个结点 $u$ ，其权值 $dp_u$ 为：若其为叶结点，则有 $dp_u=a_u$ ；否则，设结点 $u$ 的子结点集合为 $childs_u$ ,已选择的子结点集合为 $selects_u$ ，有 $dp_u=\sum_{v\in{childs_u}}^{v\in{selects_u}}{dp_v}$ 。

该题的目的为最小化 $dp_{root}$ ，那么对应地，容易得到两个贪心性质：

一：选择的子结点数应尽量小。

二：每次都尽量选择还未选过的权值最小的子结点。

以上性质可以递推到每个非叶结点上。

那么，我们可以很容易地总结出这道题每个结点上的贪心方法：逐个按照权值从小到大选点，一边选一边计算权值，一旦数量符合规定立刻停止选点。

而对于权值的计算，如果写题比较多的话应该也已经看出来了：先 dfs 到叶结点，之后返回向上递推计算每个结点的权值。

而维护每个结点最小值的方法可以是排序，也可以在每个结点进行 dfs 时开一个小根堆（优先队列），对于每个结点需要排序或进出（至少每个结点进一次，但可能不会每个结点都出一次）优先队列的个数等于其子结点数（若为叶结点则不需要该操作所以为 $0$ ），易得树上所有点的该操作次数为树的结点数。数据范围显然不能使用计数排序，则使用快速排序或堆的时间复杂度总计为 $O({n\log n})$ 。

AC代码：（注意：以上和分数有关的变量需要浮点数，最好都开 long double）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL N=5e5+11;
struct edge
{
    LL to,val,next;
}G[N];
LL head[N],cnt,n,t,c,a[N],dp[N],child[N];
bool vis[N];
long double kai;
struct Node
{
    LL ai;
}node[N];
inline void add_edge(LL u,LL v,LL val)
{
    G[cnt].to=v,G[cnt].val=val,G[cnt].next=head[u];head[u]=cnt++;
}
inline void dfs(LL u)
{
    vis[u]=1;
    if(child[u]==0) {dp[u]=node[u].ai;return;}
    priority_queue<LL,vector<LL>,greater<LL> > q;
    for(auto i=head[u];i!=-1;i=G[i].next)
    {
        LL v=G[i].to;
        if(!vis[v]) dfs(v);q.push(dp[v]);
    }
    long double fuckccf=node[u].ai/(t*1.0);//cout<<"FUCKCCF:"<<fuckccf<<endl;
    LL count=0;
    while((count/(child[u]*1.0))<fuckccf) {dp[u]+=q.top();q.pop();count++;}
}
inline LL read()
{
    LL a=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f*=-1;ch=getchar();}
    while(ch>='0' && ch<='9') {a=a*10+(ch-'0');ch=getchar();}
    return a*f;
}
int main()
{
    memset(head,-1,sizeof(head));
    n=read(),t=read(),c=read();
    node[0].ai=c;
    for(auto i=1;i<=n;i++) {LL u=read();node[i].ai=read();add_edge(u,i,1);child[u]++;}
    dfs(0);
    cout<<dp[0];
    return 0;
}
```


---

## 作者：UltiMadow (赞：1)

本题解写给不会树形dp的萌新，大佬勿喷

题解里满满的vector和邻接表，于是我来补一发~~xon~~兄弟儿子表示数的题解

这是一道极好的树形dp~~或者叫暴力dfs~~的练手题

### 1、建一棵树
题目里说了这些人成一棵树，所以放心大胆地直接建树

这里采用兄弟儿子表示法

兄弟儿子表示法，顾名思义，我们需要存两个东西，一个是这个节点的兄弟，一个存这个节点的儿子
#### 如果这个节点有多个儿子或兄弟怎么办？
我们不需要把这个节点的所有兄弟儿子全部记录下来（那样太费空间了）。我们记录这个节点的最大的儿子和最大的兄弟，并且保证记录的这个节点的兄弟和这个节点父亲的儿子不同。

建立树的代码如下：
```cpp
ll fa;//记录节点的父亲
scanf("%lld%lld",&fa,&a[i]);
bro[i]=son[fa];//把这个节点的兄弟设置为父亲的儿子
son[fa]=i;//把父亲的儿子更新为这个节点
cnt_son[fa]++;//统计父亲的儿子节点个数
```
### 2、树的搜索
建完树了，捜树就简单很多了

树形dp的主要思路就是把儿子的信息往上传给父亲，再统计方案数或者选取最优方案

所以，我们只要搜索一个节点的所有儿子结点就可以了

模板大概长这样：
```cpp
void dp(int u)
{
	if(!son[u])//如果当前节点是叶子节点
	{
		......//做一些设置，比如设置叶子节点的初始值
		return;//返回
	}
	for(int i=son[u];i;i=bro[i])//搜索该节点的所有儿子节点
	{
		dp(i);//搜索儿子结点
		......//把儿子结点的信息传上来并统计方案数或选取最优的方案
	}
}
```
### 3、本题代码
树形dp的基本思路已经在前面讲清楚了，如果有什么疑问直接看本题代码吧
```cpp
#include<bits/stdc++.h>
#define MAXN 500010
#define ll long long//60分的看过来，本题要用long long
using namespace std;
ll n,t,c;
ll son[MAXN],bro[MAXN],cnt_son[MAXN],a[MAXN];
ll f[MAXN];
ll Num(ll u)//看不懂的或看dp函数里的
{
	double ret=1.0*cnt_son[u]*a[u]/t;
	if(ret>(ll)ret)return (ll)ret+1;
	return (ll)ret;
}
void dp(ll u)
{
	if(!son[u])//叶子节点
	{
		f[u]=a[u];
		return;
	}
	priority_queue<ll,vector<ll>,greater<ll> >Q;//设置小根堆，存放儿子信息，选择前Num（u）个累加作为f[u]
	for(ll i=son[u];i;i=bro[i])//搜索给节点的每个儿子
	{
		dp(i);
		Q.push(f[i]);//将儿子信息放入堆中
	}
	for(ll i=1;i<=Num(u);i++)//取前Num(u)个累加
		f[u]+=Q.top(),Q.pop();
}
int main()
{
	scanf("%lld%lld%lld",&n,&t,&c);
	a[0]=c; 
	for(ll i=1;i<=n;i++)//建树
	{
		ll fa;
		scanf("%lld%lld",&fa,&a[i]);
		bro[i]=son[fa];
		son[fa]=i;
		cnt_son[fa]++;
	}
	dp(0);//从根节点开始搜素
	printf("%lld",f[0]);//输出根节点信息
	return 0;
}
```


---

## 作者：UNIDY (赞：1)

~~我是看名字进来做的鸭~~

是个树形dp的好~~(shui)~~题，知识点非常裸。

就是从根节点搜到底然后往上返回，每次计算节点`u`的成本的时候，取的是它的所有子树中成本最小的`T`分之`A[u]`的子树成本之和，然后往上推就行了。

~~我其实并不知道这题为什么是一个蓝题，大概是给我这种蒟蒻刷经验值用的吧（bushi~~

还是看丑陋的代码吧……

```
#include<bits/stdc++.h>
using namespace std;

inline void read(int &x){
  char c;
  while((c=getchar())<'0' || c>'9'); x=c-48;
  while((c=getchar())>='0' && c<='9')x=x*10+c-48;
}

const int N=500010;

int n,t,x,a[N];

long long f[N]={};

vector<int> son[N];               //vector的效率似乎不如链表高，但是对于这一题足够了 
 
bool cmp(int a,int b){return f[a]<f[b];}

void dfs(int u){
  if(son[u].size()){
    for(int i=0; i<son[u].size(); ++i)dfs(son[u][i]);
    sort(son[u].begin(),son[u].end(),cmp);
                                  //因为子树搜索过之后就再也用不到了，所以直接在son[u]中排序 
    int maximum=ceil((double)a[u]*son[u].size()/t);
    for(int i=0; i<maximum && i<son[u].size(); ++i)
      f[u]+=f[son[u][i]];         //选择成本最小的T分之A[u]的子树，得到u子树的成本 
  }else{
    f[u]=a[u];                    //没有下属，成本即为A[u] 
  }
}

int main(){
  read(n),read(t),read(a[0]);     //根据题意，C值也可以理解为A[0]，这样后续处理会方便些 
  for(int i=1; i<=n; ++i)
    read(x),read(a[i]),
    son[x].push_back(i);          //建图，上级向下级建边 
  dfs(0);                         //树形dp 
  cout<<f[0]<<endl;
  return 0;
}

```


---

## 作者：MloVtry (赞：1)

树形dp...状态很好推...

f[i]表示使i这个点反馈的最小花费

岚后对每个点做一个背包（...）可以用sons的状态更新上来

具体的要选it(计算一下)个点，每个儿子体积为1，贡献为f[j]，取Σf最小的it个儿子就好了

最后输出f[0]

（其实这部分可以用sort的方法做吧...但是我怠惰了...）

```cpp
#define ll long long
#define inf 1LL<<50
#include<algorithm>
#include<iostream>
#define N 500010
#include<cstdio>
#include<cmath>
using namespace std;
int n;
ll f[N],k[N],t;
int  head[N],to[N],Next[N],e;
ll a[N];
void buid(int u,int v)
{
    Next[++e]=head[u];head[u]=e;to[e]=v;
}
void dfs(int now)
{
    int sons=0;
    for(int i=head[now];i;i=Next[i]) sons++,dfs(to[i]);
    if(sons==0)
    {
        f[now]=a[now];
        return;
    }
    int it=ceil(double((a[now]*sons*1.0)/(t*1.0)));
    for(int i=1;i<=it;++i) k[i]=inf;
    int js=0;
    for(int i=head[now];i;i=Next[i])
    {
        js++;
        int To=it<js?it:js;
        for(int j=To;j>=1;--j)
        {
            ll zz=k[j-1]+f[to[i]];
            k[j]=k[j]<zz?k[j]:zz;
        }
    }
    f[now]=k[it];
}
ll read()
{
    ll out=0,flag=1;
    char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out*flag;
}
int main()
{
    n=read(),t=read(),a[0]=read();
    int fl=1;
    for(int i=1;i<=n;++i)
    {
        int b=read();
        buid(b,i);a[i]=read();
        if(b!=0) fl=0;
    }
    if(fl)
```
{//对于所有人都联0的情况，sort取前面小的几个就行
//所以说背包部分也可以换成sort（似乎会更快....吧....）

```cpp
        sort(a+1,a+n+1);
        int it=ceil(double((a[0]*n*1.0)/(t*1.0)));
        ll ans=0;
        for(int i=1;i<=it;++i) ans+=a[i];
        printf("%lld\n",ans);
        return 0;
    }
    dfs(0);
    printf("%lld\n",f[0]);
    return 0;
}
//今天也依旧没有捞到岛风47厌战呢
```

---

## 作者：hcl156 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3408)

## Solution:
设 $f(x)$ 表示要使 $x$ 向它的父亲写信需要花的最少的钱，$per(x)$ 为要使 $x$ 向它的父亲写信最少要多少人？

则 $f(x)= \sum_{i=1}^{per(x)}f(son(x))$，此时的f数组是从小到大排过序的。

那我们只需要把每个点的儿子放到 multiset 去维护就好了，最后输出 $f(0)$。

总时间复杂度 $ O(n \log n)$。

## Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+1;
const int inf=2147483647;
int n,m,t,cnt,head[N];
int ans,a[N],per[N],cost[N],num[N];
struct Edge{int nxt,to;}edge[N];
struct cmp{bool operator()(const int& a,const int& b)const{return cost[a]<cost[b];}};
multiset<int,cmp> q[N];
multiset<int,cmp>::iterator it;
void ins(int x,int y){
    edge[++cnt].nxt=head[x];
    edge[cnt].to=y;head[x]=cnt;
}
void dfs(int x){
    int flag=0;
    for(int i=head[x];i;i=edge[i].nxt){
        int y=edge[i].to;
        dfs(y);q[x].insert(y);
        flag=1;
    }
    if(!flag){cost[x]=a[x];return ;}
    if(x){
        int u=per[x];it=q[x].begin();
        for(int i=1;i<=u;i++){
            if(it==q[x].end()){
                cost[x]=inf;
                return ;
            }cost[x]+=cost[*it],++it;
        }
    }else{int w=(m*num[x]+t-1)/t;
        it=q[x].begin();
        for(int i=1;i<=w;i++)
            ans+=cost[*it],++it;
    }
}
int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
signed main(){
    n=read(),t=read(),m=read();
    for(int i=1;i<=n;i++){
        int x=read(),y=read();
        ins(x,i);a[i]=y;num[x]++;
    }
    for(int i=1;i<=n;i++) per[i]=(num[i]*a[i]+t-1)/t;
    dfs(0);printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：AlicX (赞：0)

### 前言
~~看到题目名，写篇题解来纪念一下。~~

首先相信大家对树形动态规划都不陌生，其实就是将线性的转化到树上就可以了。当然有一些题还是比较麻烦的，但是这道题简单，只有一个限制条件，那么我们考虑树形动态规划。

## 思路
$\bullet$ 状态定义：令 $f_i$ 表示让节点 $i$ 同意向上司写信的最小花费，那么答案就是 $f_0$，因为 $0$ 同意了就不用在往上了。

$\bullet$ 状态转移：来看 $f_i$ 的定义：$f_i$ 表示让节点 $i$ 同意向上司写信的最小花费，而要让节点 $i$ 同意，需要有 $a_i \times son \div t$ 个下属同意，其中 $son$ 表示节点 $i$ 的下属数量，所以我们可以先求出每个下属同意的最小代价，排序后用将 $a_i \times son \div t$ 个相加就可以了。

$\bullet$ 边界：当节点 $i$ 没有下属时，就直接返回 $a_i$ 就可以了。

$\bullet$ 注意：再算需要多少个下属同意时，要转为小数类型，因为整数类型会自动取整。

## AC code
```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=5e5+10;
int n,t,c;
int a[N],f[N];
vector<int> v[N];
int dp(int u){
	vector<int> vec;
	if(!v[u].size()) return a[u];
	for(int i=0;i<v[u].size();i++){
		int to=v[u][i];
		vec.push_back(dp(to));
	}
	int ans=0;
	sort(vec.begin(),vec.end());
	int num=1.0*a[u]*v[u].size()/t;
	for(int i=0;i<=num;i++) ans+=vec[i];
	return ans;
}
signed main(){
	cin>>n>>t>>a[0];
	for(int i=1;i<=n;i++){
		int x;
		cin>>x>>a[i];
		v[x].push_back(i);
	}
	cout<<dp(0)<<endl;
	return 0;
}
```
~~献给我的白月光。~~

---

## 作者：EuphoricStar (赞：0)

## 思路

树形 DP。

设 $f_u$ 为以 $u$ 为根的子树中至少需要多少花费才能让 $u$ 向他的上司写信。

- 如果 $u$ 为叶子结点，$f_u = a_u$；

- 否则，将 $u$ 的所有儿子的 $f$ 值从小到大排序，取前 $\left\lceil\dfrac{a_u \times cnt}{T}\right\rceil$ 小的 $f$ 值的和作为 $f_u$（$a_0 = C$），其中 $cnt$ 为 $u$ 的儿子数量。

答案即为 $f_0$。

需要注意的是，在代码中计算分数可能会丢精，因此可以移项，把除法化为乘法处理。

## 代码

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn = 500100;

ll n, t, head[maxn], len, a[maxn];
ll f[maxn];
struct edge {
	ll to, next;
} edges[maxn << 1];

void add_edge(ll u, ll v) {
	edges[++len].to = v;
	edges[len].next = head[u];
	head[u] = len;
}

void dfs(ll u) {
	int cnt = 0;
	vector<ll> tmp;
	for (int i = head[u]; i; i = edges[i].next) {
		ll v = edges[i].to;
		dfs(v);
		++cnt;
		tmp.push_back(f[v]);
	}
	if (!cnt) {
		f[u] = a[u];
		return;
	}
	sort(tmp.begin(), tmp.end());
	for (int i = 0; i * t < a[u] * cnt; ++i) {
		f[u] += tmp[i];
	}
}

int main() {
	scanf("%lld%lld%lld", &n, &t, &a[0]);
	for (int i = 1; i <= n; ++i) {
		ll u;
		scanf("%lld%lld", &u, &a[i]);
		add_edge(u, i);
	}
	dfs(0);
	printf("%lld", f[0]);
	return 0;
}
```


---

## 作者：Link_Space (赞：0)

这道题的思路很简单：先通过每个有下属人的属性算出让他写一封信给他的上司需要的下属人数，因为要使答案最小，那么我们选择的下属肯定是花费更加少的下属，如何做到将下属按照花费多少来排序呢？这里可以使用优先队列，缺点是时间复杂度相对于其他做法会高一些。

对于每一个有下属的人，我们dfs他的所有下属并将花费存储到优先队列中，并选择所需要的人数，代码如下，代码内有注释：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
ll pay[N];
ll head[N], ver[N], nxt[N], cnt;
ll son[N];//下属的个数
ll n, t, c;
void add(ll x,ll y)
{
    nxt[++cnt] = head[x];
    head[x] = cnt;
    ver[cnt] = y;
}
ll dfs(ll now,ll father)
{
    if(son[now]==0)
        return pay[now];//没有下属的人的花费就是让他写信需要的钱
    double needto = (double)son[now] * pay[now] / (double)t;
    ll need;
    if((ll)needto==needto)
        need = (ll)needto;
    else
        need = (ll)needto + 1;
        //计算所需要的下属个数
    priority_queue<ll, vector<ll>, greater<ll> > q;//对于每个人单独开一个优先队列
    for (ll i = head[now]; i;i=nxt[i])
    {
        ll v0 = ver[i];
        if(v0==father)
            continue;
        q.push(dfs(v0, now));//将每个儿子的花费存入
    }
    ll res = 0;
    for (ll i = 1; i <= need;i++)
        res += q.top(), q.pop();//找到至少需要的人数即可
    return res;
}
int main()
{
    scanf("%lld%lld%lld", &n, &t, &c);
    pay[1] = c;
    for (ll i = 2; i <= n + 1;i++)
    {
        ll a;
        scanf("%lld%lld", &a, &pay[i]);
        a++;
        add(i, a);
        add(a, i);
        son[a]++;
    }
    printf("%lld\n", dfs(1, 0));
}
```


---

## 作者：SymphonyOfEuler (赞：0)

一道~~树上DP~~好题。

~~这个题目背景很扯，可以总结为：比 武 招 亲~~

行程一棵树，需要花$t$分之$a_i$的钱买通下属，问最少需要多少钱的亲。

**思路：**

我们定$dp[i]$为$i$点买通上级，需要花费的钱，当$dp[i]$为叶子节点的时候$dp[i]=a[i]$。若$i$是非叶子节点，统计他孩子节点的花费，按从小到大排序，取值道达到目的即可。其实这题算不上完全DP，这段想法极其像是贪心。

代码：

```
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const ll MAXN = 500005;

ll a[MAXN];

ll n, t, c;

vector<ll> sans[MAXN];

ll f(ll r) {
    if (sans[r].empty()) { //leaf
        return a[r];
    }
    vector<ll> p;
    for (ll i = 0; i < sans[r].size(); ++i) {
        p.push_back(f(sans[r][i]));
    }
    sort(p.begin(), p.end());
    ll sum = 0, b;
    if (!r) {
        b = c;
    } else b = a[r];
    for (ll i = 0; i < 1.0 * b * sans[r].size() / t; ++i) {
        sum += p[i];
    }
    return sum;
}

int main() {
    cin >> n >> t >> c;
    for (ll i = 1; i <= n; ++i) {
        ll b;
        cin >> b >> a[i];
        sans[b].push_back(i);
    }
    ll x = f(0);
    cout << x << '\n';
    return 0;
}
```


---

## 作者：DQYdqy (赞：0)


## Solution:

设f[x]表示要使x向它的父亲写信需要花的最少的钱，per[x]为要使x向它的父亲写信最少要多少人

则$f[x]=\sum_{i=1}^{per[x]}f[son[x]]$，此时的f数组是从小到大排过序的

那我们只需要把每个点的儿子放到multiset去维护就好了，最后输出f[0]

总时间复杂度$O(n\,log\,n)$

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+1;
const int inf=2147483647;
int n,m,t,cnt,head[N];
int ans,a[N],per[N],cost[N],num[N];
struct Edge{int nxt,to;}edge[N];
struct cmp{bool operator()(const int& a,const int& b)const{return cost[a]<cost[b];}};
multiset<int,cmp> q[N];
multiset<int,cmp>::iterator it;
void ins(int x,int y){
	edge[++cnt].nxt=head[x];
	edge[cnt].to=y;head[x]=cnt;
}
void dfs(int x){
	int flag=0;
	for(int i=head[x];i;i=edge[i].nxt){
		int y=edge[i].to;
		dfs(y);q[x].insert(y);
		flag=1;
	}
	if(!flag){cost[x]=a[x];return ;}
	if(x){
		int u=per[x];it=q[x].begin();
		for(int i=1;i<=u;i++){
			if(it==q[x].end()){
				cost[x]=inf;
				return ;
			}cost[x]+=cost[*it],++it;
		}
	}else{int w=(m*num[x]+t-1)/t;
		it=q[x].begin();
		for(int i=1;i<=w;i++)
			ans+=cost[*it],++it;
	}
}
int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
signed main(){
	n=read(),t=read(),m=read();
	for(int i=1;i<=n;i++){
		int x=read(),y=read();
		ins(x,i);a[i]=y;num[x]++;
	}
	for(int i=1;i<=n;i++) per[i]=(num[i]*a[i]+t-1)/t;
	dfs(0);printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：ulita (赞：0)

之前图有问题所以改一下

###分析

也是四个状态，但我无法理解标程的写法，但姑且比标程短而且快，所以讲一下我的思路

性质一：首先显然只能向下走或向左走，而且有独立性，考虑DP

但买过的不再买，所以对当前决定有影响的有4个点


8 2 1

3 o 7

4 5 6

o是当前节点（已经买过了），1、2、3、4是我们要记的节点，2、3对当前决定有影响，而如果向右走，1就会有影响，4也一样。但因为性质一，8没有影响，以后不会遇到。至于5、6、7，由于性质一，不可能买过。

那么，状态转移就只需要计算下一个节点的四个要记录节点，实现就很简单了


###代码


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define dd d[x][y][t]
int d[1005][1005][20],p[1005][1005],n,m;
int read(){
    char c=getchar();
    while((c<'0'||c>'9')&&c!='.') c=getchar();
    if(c=='.') return 0;
    return c-'0';
}
int dp(int x,int y,int t){
    if(dd) return dd;
    if(x>n||y>m) return 2147483047;
    int b;
    if(p[x+1][y])
        if(p[x-1][y]&&!(t&2)) 
        dd=min(dp(x,y+1,12+(t&1)*2)+p[x][y+1]+p[x+1][y],
        dp(x,y+1,4+(t&1)*2)+p[x][y+1]+p[x-1][y]);
        else if(p[x][y-1]&&!(t&4)) 
        dd=min(dp(x,y+1,12+(t&1)*2)+p[x][y+1]+p[x+1][y],
        dp(x,y+1,4+(t&1)*2)+p[x][y+1]+p[x][y-1]);
        else dd=dp(x,y+1,4+(t&1)*2)+p[x][y+1];
    else dd=dp(x,y+1,4+(t&1)*2)+p[x][y+1];
    if(p[x][y+1])
        if(p[x-1][y]&&!(t&2)) 
        b=min(dp(x+1,y,3+(t&8)/2)+p[x+1][y]+p[x][y+1],
        dp(x+1,y,2+(t&8)/2)+p[x+1][y]+p[x-1][y]);
        else if(p[x][y-1]&&!(t&4)) 
        b=min(dp(x+1,y,3+(t&8)/2)+p[x+1][y]+p[x][y+1],
        dp(x+1,y,2+(t&8)/2)+p[x+1][y]+p[x][y-1]);
        else b=dp(x+1,y,2+(t&8)/2)+p[x+1][y];
    else b=dp(x+1,y,2+(t&8)/2)+p[x+1][y];
    dd=min(dd,b);
    return dd;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            p[i][j]=read();
    for(int i=0;i<17;i++) d[n][m][i]=1;
    cout<<dp(1,1,0)-1;
    return 0;
}
```
###代码说明：
0. 虽然题目没说，但数据在int范围内

0. 之所以把目标点初始化为1，最后再-1是为了节约时间

0.为简化代码，状态转移进行了特判，比如如果向右走除非下面的点有店铺，否则不用额外买路径以外的小吃，同样如果往下走除非右边的点有店铺，否则不用额外买等等

0. 以上几个优化不加也可以过


---


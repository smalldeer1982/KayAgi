# [POI 2013] BAJ-Bytecomputer

## 题目描述

A sequence of ![](http://main.edu.pl/images/OI20/baj-en-tex.1.png) integers ![](http://main.edu.pl/images/OI20/baj-en-tex.2.png) from the set ![](http://main.edu.pl/images/OI20/baj-en-tex.3.png) is given.

The bytecomputer is a device that allows the following operation on the sequence:

incrementing ![](http://main.edu.pl/images/OI20/baj-en-tex.4.png) by ![](http://main.edu.pl/images/OI20/baj-en-tex.5.png) for any ![](http://main.edu.pl/images/OI20/baj-en-tex.6.png).

There is no limit on the range of integers the bytecomputer can store, i.e.,    each ![](http://main.edu.pl/images/OI20/baj-en-tex.7.png) can (in principle) have arbitrarily small or large value.

Program the bytecomputer so that it transforms the input sequence into a non-decreasing sequence    (i.e., such that ![](http://main.edu.pl/images/OI20/baj-en-tex.8.png)) with the minimum number of operations.



## 样例 #1

### 输入

```
6
-1 1 0 -1 0 1
```

### 输出

```
3
```

# 题解

## 作者：NKU_AI_HMX (赞：89)

这篇题解主要是对其他题解做出补充和优化，解决大家的一些问题，帮助大家理解。
## 目录
1. 思路简述

1. 状态转移方程

1. 如何优化

1. 最终代码

## 正文
#### 1. 思路简述
动态规划或者贪心，记忆搜索都可，其他题解都有说明，这里我主要说动态规划，我们构造函数 $f[j][i]$，其表示前 $j$ 个数以 $i(i=-1,0,1)$ 结尾的最少改变次数。如果大家可以想到这个方程那么已经迈出一大步了，接下来就是怎么转移状态。


------------
#### 2. 状态转移
我先放出两种代码

1.
```cpp
memset(f, 63, sizeof(f));
	f[1][a[1] + 1] = 0;
	for (int i = 2; i <= n; i++)
	{
		if (a[i] == -1)
		{
			f[i][0] = f[i - 1][0];
			f[i][2] = f[i - 1][2] + 2;
		}
		if (a[i] == 0)
		{
			f[i][0] = f[i - 1][0] + 1;
			f[i][1] = min(f[i - 1][0], f[i - 1][1]);
			f[i][2] = f[i - 1][2] + 1;
		}
		if (a[i] == 1)
		{
			f[i][0] = f[i - 1][0] + 2;
			f[i][1] = f[i - 1][0] + 1;
			f[i][2] = min(f[i - 1][0], min(f[i - 1][1], f[i - 1][2]));
		}
	}
	int temp = min(f[n][0], min(f[n][1], f[n][2]));
	if (temp >= inf)cout << "BRAK";
	else cout << temp;
```
2.
```cpp
f[1][0]=INF,f[1][1]=INF,f[1][2]=INF;
	f[1][num[1]+1]=0;
	for(register int i=2;i<=n;i++)
	{
		if(num[i]==-1)
		{
			f[i][0]=f[i-1][0];
			f[i][1]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1])+1:INF;
			f[i][2]=(num[i-1]==1)?min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+2:f[i-1][2]+2;
		}
		if(num[i]==0)
		{
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=(num[i-1]==1)?min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+1:f[i-1][2]+1;
		}
		if(num[i]==1)
		{
			f[i][0]=f[i-1][0]+2;
			f[i][1]=(num[i-1]==-1)?min(f[i-1][0],f[i-1][1])+1:f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}
	}
	int ans=min(f[n][0],min(f[n][1],f[n][2]));
	if(ans>=INF) printf("BRAK\n");
	else printf("%d\n",ans);
```
大家如果看了其他的题解就会发现有两种代码，第一种，转移函数十分简要，而且题解也没说明，没有第二种考虑周全，而第二种的转移函数似乎又显得十分冗长，又有些多余。

接下来我给大家解释一下其中的道理，并指出其他题解没说明白的或者说错误的地方。

**第二种代码**

1. $num[i]==-1$
```cpp
if(num[i]==-1)
		{
			f[i][0]=f[i-1][0];
			f[i][1]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1])+1:INF;
			f[i][2]=(num[i-1]==1)?min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+2:f[i-1][2]+2;
		}
```


$f[i][0]=f[i-1][0]$ 没什么好说的，非常正确，没有争议。$f[i][1]$ 就有点问题了，按上面的代码就有两个转移途径，如果 $num[i-1]==1$，先让自己加上 $num[i-1]$ 是 $1$，自己变成 $0$，然后考虑到数列单调性，再通过前面的加的操作让第 $i-1$ 个数符合单调法则变成 $-1$ 或者 $0$，第二种转移就 $num[i-1]\ne1$ 要让第 $i$ 个数等于 $0$，就需要先让前一个数变成 $1$，然而它变成 $1$ 后数列又不单调，于是乎我目前看到的所有题解（如果说错那我没看到，不好意思）都得出来一个看似显而易见的结论 $f[i][1]=INF$ **但是我在这里要说这个结论是错的。**

大家看这样一个数列 $-1,1,0,-1$ 按照上面的算法$f[4][1]=INF$ 但是呢？看下面（我每次只操作一个数）：

$-1,1,0,-1$ $\to$ $-1,1,1,-1$ $\to$ $-1,1,1,0$ $\to$ $-1,0,1,0$ $\to$ $-1,-1,1,0$ $\to$ $-1,-1,0,0$

啊？转移过去了？奇怪吧？其实不奇怪，上面讲的第一种代码根本没管多次来回操作的问题(就这题而言不需要管)。而第二种代码他管了，甚至它自己都不知道它管了，因为只管了一部分，而上面说的那个 $INF$ 就没管，那它管了哪部分呢？前面那部分。如果 $num[i-1]==1$ 他先让第 $i$ 个数加了第 $i-1$ 个数 之后再通过前面的数去改变了第 $i-1$ 个数，但是后面 $num[i-1]\ne1$ 却忘了这一点，不过还好忘了，不然很难写下去了。接下来我来说一下为什么这两种代码都可以过，以及为什么不用考虑来回多次操作的问题。

如果你需要用前面一个数去改变后面一个数，而这个数本身是具有改变后面数的能力的，增加或者减少，如果是增加，当你用 $1$，去增加后面的数时你把他增加到 $0$ 或者 $1$，目的就是为了让数列递增，如果增加到 $0$，你完全是为了让前面一段递增，因为 $0$ 不会对后面的数的改变有任何作用，反而会提升数列的高度，所以对后面的数是没益处的。然后你又用前面的 $-1$ 让 $1$ 符合递增序列的要求，那么这就脱裤子放屁了，你可以直接用前面的 $-1$ 把 $1$ 降到 $-1$ 而不用让 $1$ 去把后面的 $-1$变成 $0$，而变成 $0$的这个解我们就认为它一定不会是唯一的一个最优解直接给 $INF$ 就好了。这就对应了上面循环的 $f[i][1]$ 的操作，而 $INF$ 并不代表他不可转移，只是一定不是唯一的最优，不取它而已。（不用怕因为我们给可转移的情况赋值 $INF$ 而在最后错误判断情况为不可转移，为什么大家自己思考一下应该可以出来，想出不来欢迎评论区留言）

同样，当我们用 $1$ 把后面一个数变成 $1$ 的时候也没必要回过头去再把 $1$ 给降低，因为它后面都是 $1$ 了它为啥还要变成 $0$ 或者 $-1$ 呢？以上就说明了第二种代码的第一个判断的多余之处。

2. $num[i]==0$ 
```cpp
if(num[i]==0)
		{
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=(num[i-1]==1)?min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+1:f[i-1][2]+1;
		}
```


同理这里面 $f[i][2]$ 的那一行参照上面的说法也比较冗长可以改进为第一种代码。

3. $num[i]==1$ 
```cpp
if(num[i]==1)
		{
			f[i][0]=f[i-1][0]+2;
			f[i][1]=(num[i-1]==-1)?min(f[i-1][0],f[i-1][1])+1:f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}
```


现在我们考虑前面一个数让后面减小的情况,两种选择，减到 $-1$ 或者减到 $0$。

减到 $-1$ 很好理解，这里不叙述了。

如果减到 $0$，那就没必要再把前面的 $-1$ 加到 $0$ 因为你必然是用更前面的 $1$ 把 $-1$ 加到 $0$，而这个 $1$，是不符合递增要求的，你就又得用更更前面的 $-1$ 把他减掉，最后形成前面全是 $-1$ 和 $0$ 的局面，而你如果又是这样往复多次操作的话，参照上面几段，你又脱裤子放屁了。    
用 $-1$ 把后面的数减到 $0$，然后再用前面的数把 $-1$ 加到 $0$。大家仔细想想，是不是多此一举了，你既然要把 $-1$ 加到 $0$是不是说明前面全是 $0$ 或者 $-1$，你为了保证数列递增而这样操作的，对吧。那你用来把 $-1$ 加到 $0$ 的那个 $1$ 哪里来的？哟！我可以先用那个 $1$ 把后面的数加上去再用更前面的 $-1$ 把那个 $1$ 再减回来，这样就只剩 $0,-1$ 了。我们叫这种行为叫脱裤子放屁。大哥，既然前面有 $-1$ 你为啥要让把后面提升到 $0$ 还费那么大的力？直接用 $-1$ 扫过去让他都变成 $-1$不就好了，那我第 $i-1$ 个数还用动吗？他就是 $-1$ 嘛。

以上就说明了第二种代码一些转移的多余，精简代码看第一种。


------------
#### 3. 如何优化
第一，~~我们可以滚~~。我的意思是滚动数组，滚到只用开 $f[3]$ 和一些临时变量，注意滚动的时候要调整每一种情况下函数的递推顺序，不然就会造成历史数据丢失。


------------
#### 4. 最终代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
#define pf putchar(' ')
#define pfn putchar('\n')
using namespace std;
char ch1;
template<class T>
inline void rd(T& x) {
	x = 0; bool w = 0;
	ch1 = getchar();
	while (!isdigit(ch1)) { ch1 == '-' && (w = 1), ch1 = getchar(); }
	while (isdigit(ch1)) { x = (x << 1) + (x << 3) + (ch1 & 15), ch1 = getchar(); }
	w && (x = (~x) + 1);
}
template<class T>
inline void wr(T x)
{
	if (x < 0) x = -x, putchar('-');
	if (x < 10) {
		putchar(x + 48);
		return;
	}
	T L = x / 10;
	wr(L);
	putchar(x - ((L << 1) + (L << 3)) + 48);
}
int n,x,f[3]; 
int inf = 1 << 27;
int main()
{
	rd(n); rd(x);
	memset(f, 63, sizeof(f));
	f[x + 1] = 0;
	for (re int i = 2; i <= n; i++)
	{
		rd(x);
		if (x == -1)
		{
			f[1] = inf;
			f[2] += 2;
		}
		else if (x == 0)
		{
			f[1] = min(f[0], f[1]);
			f[0]++;
			f[2]++;
		}
		else
		{
			f[2] = min(f[0], min(f[1], f[2]));
			f[1] = f[0] + 1;
			f[0] += 2;
		}
	}
	int temp = min(f[0], min(f[1], f[2]));
	if (temp >= inf)printf("BRAK");
	else wr(temp);
	return 0;
}
```
(如果有情况未覆盖，参照上面的思路可自行推理)

---

## 作者：Notshgiook (赞：38)

# 首先，这是一道非常好的$DP$-动态规划
## 前言

update:2019.10.16，修改部分小细节！

把话放在前面，如果无解是输出$BRAK$，本蒟蒻输出了一个$BAKE$调了半天！还是得感谢我校巨佬给出的明确提醒！手动$@$[紫薯布丁](https://www.luogu.org/space/show?uid=124591)！！

这是道比较好的线性$DP$，在看着海绵宝宝的时候，灵光一现，这题似乎可以这么写！！于是顺利由于$BAKE$调了半天。

不妨来明确一下题意：

现在手中有这样一个数组$num$，里面只存在着三种数$\ -1,0,1\ $。对于这个数组，你进行下面的操作：$a[i]+=a[i-1]$。

随后呢，你可以对于每个位置进行若干次操作，最终使得整个数组变成单调不下降的序列！如果无解，便输出和$BRAK$。

**一个很显然的问题**，这个题操作之后，一定全是 $\ -1,0,1\ $，而不会存在其他数字！！这是翻译题面中没有提到的地方！

在看海绵宝宝的时候脑子一瓦特，这题大概是一个区间$DP$，那么这样看来$\ What\ should\ we\ do?$ 

**大胆莽一波不怂直接上：**$\ $ $f[i][j]$，表示第$i$个位置，变成$j\ $的最小变化次数。

然而，数组以负数做下标，极大可能性会$CE$，所以我们应该想个办法不让$ta\ CE$!

那么，不妨用$f[i][0]$表示第$i$个位置，变成$-1$的最小变化次数。

用$f[i][1]$表示第$i$个位置，变成$0$的最小变化次数。

用$f[i][2]$表示第$i$个位置，变成$1$的最小变化次数。

**那么肯定得初始化一些东西：**

$f[1][0]=INF,f[1][1]=INF,f[1][2]=INF$。

与此同时，$f[1][num[1]+1]=0$，因为$num[1]$前面没有数，所以肯定无法通过操作来转换！！

把一切都初始化好，那就准备开始从$num[2]$的地方开始转移吧！！

## 转移

不妨假设现在处于的位置为$i$。

------------

### 若$num[i]==-1$时：

$Situation\ 1$：

假如我们想把当前位置变成$-1$，那么由于$num[i]==-1$，那么如果我们想把它变成$-1$，根据要保证数列有序，那么我们前一个一定是$-1$,又因为该点是$-1$，所以根本不用转移！即：
$$f[i][0]=f[i-1][0]$$

$Situation\ 2$：

假如我们想把当前位置变成$0$，现在的位置是$-1$，众所周知$-1+1=0$，那么如果我们前一位是$1$的话，显然我们可以在某一时刻，进行一次操作，将$-1$转换成$1$。同时，由于最终数组是有序的，所以前一位一定不大于$0$，那么转移一定可以从前一位转换成 $0,-1$来转移。即：
$$if(num[i-1]==1)\ f[i][1]=min(f[i-1][0],f[i-1][1])+1$$

如果前一位原先不是$1$呢。那么我们仔细考虑一下，是否可以在某一时刻前一位转换以后变成$1$,显然这是不可能的，因为我们要保证数组有序，那么这样来看如果上一位都转换成 $1$ 了，显然这一位必须是$1$而不是$0$,那么显然这个转移不成立，这样看来将其赋一个极大值便可以了。即：
$$if(num[i-1]!=1)\ f[i][1]=INF$$

$Situation\ 3$：

假如我们想让当前位置变成$1$，又由于当前位置为$-1$，那么我们必须通过两次$+1$的操作，使得$-1$变成$1$。

那么这个$1$哪里来呢？有两种方法：

第一种情况就是前一位在原先数组里便是$1$，那么，我们可以在某一时刻，进行两次操作，把该位置变成$1$,又由于1是整个数组里最大的数，显然在最终数组中，前面可以是$-1,0,1$任何一个。那么肯定可由前一个的任意情况转移过来，即：
$$if(num[i-1]==1)\ f[i][1]=min(f[i-1][0],f[i-1][1],f[i-1][2])+2$$

第二种情况是，这个$1$是通过某次转移后得到的，并且前一位在原先数组里便不是$1$。那么：

$$if(num[i-1]!=1)\ f[i][2]=f[i-1][2]+2$$

综上所述：当$num[i]=-1$时的转移是：

$f[i][0]=f[i-1][0]$

$f[i][1]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1])+1:INF$

$f[i][2]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1],f[i-1][2])+2:f[i-1][2]+2$

------------

### 若$num[i]==0$时：

既然第一种情况那么详细了，那下面的就简略一点吧！

$Situation\ 1$：

假如我们想让当前位置变为$-1$，那么一定需要前一个数为$-1$，才能转移，那么在根据$num[i]==-1$的$Situation1$，得知：

$$f[i][0]=f[i-1][0]+1$$

$Situation\ 2$:

如果我们想让当前的值变为$0$，又因为本身$num[i]=0$，那么最终数组前面可以是$0,-1$，那么显然:

$$f[i][1]=min(f[i-1][0],f[i-1][1])$$

$Situation\ 3$:

与第一大类情况的$Situation$相似，不过这样变成了操作一次，那么便是：

$$if(num[i-1]==1)\ f[i][1]=min(f[i-1][0],f[i-1][1],f[i-1][2])+1$$

$$if(num[i-1]!=1)\ f[i][2]=f[i-1][2]+1$$

综上所述，当$num[i]==0$时的转移情况为：

$f[i][0]=f[i-1][0]+1$

$f[i][1]=min(f[i-1][0],f[i-1][1])$

$f[i][2]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1],f[i-1][2])+1:f[i-1][2]+1$

------------
### 若$num[i]==1$时：

$Situation\ 1$:

与前面的各种$Situation\ 1$相同：

$$f[i][0]=f[i-1][0]+2$$

$Situation\ 2$:

假如我想把它变成$0$，那么只可能是前一个数是$-1$，再继续上面的思考方法可以知道：

$$f[i][0]=(num[i-1]==-1)?min(f[i-1][0],f[i-1][1])+1:f[i-1][0]+1$$

$Situation\ 3$:

假如我想把它变成$1$，它本来就是$1$，所以一定不受影响。那么：
$$f[i][2]=min(f[i-1][0],f[i-1][1],f[i-1][2])$$

------------
### 所以最终答案为：
$$min(f[n][0],f[n][1],f[n][2])$$

------------

## 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
#define maxn 1000005
const int INF=1e9+7;
int f[maxn][3],num[maxn],n;
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++) scanf("%d",&num[i]);
	f[1][0]=INF,f[1][1]=INF,f[1][2]=INF;
	f[1][num[1]+1]=0;
	for(register int i=2;i<=n;i++)
	{
		if(num[i]==-1)
		{
			f[i][0]=f[i-1][0];
			f[i][1]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1])+1:INF;
			f[i][2]=(num[i-1]==1)?min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+2:f[i-1][2]+2;
		}
		if(num[i]==0)
		{
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=(num[i-1]==1)?min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+1:f[i-1][2]+1;
		}
		if(num[i]==1)
		{
			f[i][0]=f[i-1][0]+2;
			f[i][1]=(num[i-1]==-1)?min(f[i-1][0],f[i-1][1])+1:f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}
	}
	int ans=min(f[n][0],min(f[n][1],f[n][2]));
	if(ans>=INF) printf("BRAK\n");
	else printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Fading (赞：18)

无解输出 BRAK

题解写的有点麻烦啊~然后我决定写一篇~~

这是我的奇葩 dp 算法，$O(n)$的

设$f_{i,j}$表示前$i$个数,$a_i=j-1$的最小操作次数

数组初始化为$∞$，$f_{1,a_i+1}=0$

然后分三种情况讨论

### 若$a_i=1:$

$$f_{i,0}=f_{i-1,0}+2$$

$$f_{i,1}=f_{i-1,0}+1$$

$$f_{i,2}=\min(f_{i-1,0},\min(f_{i-1,1},f_{i-1,2}))$$

最后一条式子是因为$a_i=1$，这已经满足要求了，所以上一个数是$-1,0,1$都无所谓，$f_{i-1,0},f_{i-1,1},f_{i-1,2}$都可以取

### 若$a_i=0:$

$$f_{i,0}=f_{i-1,0}+1$$
			
$$f_{i,1}=\min(f_{i-1,0},f_{i-1,1})$$

$$f_{i,2}=f_{i-1,2}+1$$

第二条式子是因为$a_i=0$，所以上一个数是$-1,0$都无所谓，$f_{i-1,0},f_{i-1,1}$都可以取

### 若$a_i=-1:$

$$f_{i,0}=f_{i-1,0}$$

$$f_{i,2}=f_{i-1,2}+2$$

为什么$f_{i,1}$没有转移呢？因为$-1$只能通过$+1$来变成$0$，这必须满足$a_{i-1}=1$，但这样就不满足题目要求了$(1>0)$ $……$

那么这题就愉快的做完啦！只不过我的思维已经混乱了~

```
#include<bits/stdc++.h>
using namespace std;
int n,a[1000001],f[1000001][4];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
	return x*f;
}
int main(){
	n=read();
	for (int i=1;i<=n;i++){
		a[i]=read();
	}
	memset(f,0x3f,sizeof(f));
	f[1][a[1]+1]=0;
	for (int i=2;i<=n;i++){
		if (a[i]==1){
			f[i][0]=f[i-1][0]+2;
			f[i][1]=f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}else if (a[i]==0){
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=f[i-1][2]+1;
		}else{
			f[i][0]=f[i-1][0];
			f[i][2]=f[i-1][2]+2;
		}
	}
	if (min(min(f[n][0],f[n][1]),f[n][2])==f[0][0]){
		printf("BRAK");
	}else{
		printf("%d",min(min(f[n][0],f[n][1]),f[n][2]));
	}
}
```

---

## 作者：EDqwq (赞：17)

### 题意：

给你一个数组a，每个元素都是-1，0，1中的一个，要求你对任意一个位置的数进行任意次以下操作： $a[i] = a[i] + a[i-1]$，使得操作后的数组变为一个不下降序列，问最少的操作次数。

注意，操作后的数组一定还是只存在-1，0，1三种元素。

***

### 定义状态&初始化：

我们把 $dp[i][j]$ 定义为第i个位置，在前面的元素已经保证不下降的时候，变为j - 1的最少的操作次数。

所以很显然的初始化：

$dp[1][0] = dp[1][1] = dp[1][2] = \inf$

由于第一个元素没法进行操作（前面没有元素），所以把第一个元素变为他本身的最少操作次数置0：$dp[1][a[1] + 1] = 0$。

***

### 转移：

分三种大类，每一种大类分三种小类讨论：

#### 当$a[i] = -1$：

变为-1：由于这个位置本身就是-1，所以$dp[i][0]$只需要满足“前面的数已经是不下降序列”即可，而由于这个位置变成-1，所以前面的只可能是-1，转移方程即为：

$$dp[i][0]=dp[i-1][0]$$

变为0：显然，有且只有一种方式：-1 + 1 = 0。

如果前面一位本身就是1，我们在他没有变为其他数之前直接操作一次就可以变成0了，而他可以变为小于等于0的任意数，也就是：

$$dp[i][1] = \min(dp[i-1][0],dp[i-1][1])+1$$

如果前面一位不为1，那他肯定要变为1，才能使我们这一位变为0，但是前面变成1之后，为了保证不下降，我们这一位只能变成1，所以这是不可能的，也就是：

$$dp[i][1] = \inf$$

变为1：显然，也只有一种方式：-1 + 1 + 1 = 1。

如果前面一位本身就是1，那么可以在任意一刻操作，那前面一位操作后可以变为-1，0，1中任意一个数，也就是：

$$dp[i][2] = \min(dp[i-1][0],dp[i-1][1],dp[i-1][2])+2$$

如果前面一位不是1，那就把它变成1再操作就好了：

$$dp[i][2] = dp[i-1][2]+2$$

### 当$a[i] = 0$：

跟前面一样的思考方式，就讲简便一点了。

变为-1：0 + （-1） = -1。

前面一位必须变为-1，保证不下降，也就是：

$$dp[i][0] = dp[i-1][0]+1$$

变为0，不需要任何操作，只要保证不下降即可了：

$$dp[i][1] = \min(dp[i-1][0],dp[i-1][1])$$

变为1：与$a[i] = -1$的情况一样，不再赘述。

### 当$a[i] = 1$：

变为-1：显然要两次-1：

$$dp[i][0] = dp[i][0] + 2$$

变为0：与前面一样，如果前面已经是-1，直接计算-1，0最小值，否则把前面变为-1。

变为1：本身已经是1，只要保证不下降即可。

由于我们状态是保证前面已经不下降的最少操作次数，所以答案显然是：

$$\min(dp[n][0],dp[n][1],dp[n][2])$$

如果最终答案更新完还为INF，那很显然是无解。

***

### 代码：

```cpp
/*
  Author: EnderDeer
  Online Judge: Luogu
*/

#include<bits/stdc++.h>

#define int long long
#define mem(x) memset(x,0,sizeof(x))

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n;
int a[1000010];
int dp[1000010][5];

signed main(){
	cin>>n;
	for(int i = 1;i <= n;i ++)a[i] = read();
	dp[1][0] = dp[1][1] = dp[1][2] = 2147483647;
	dp[1][a[1] + 1] = 0;
	for(int i = 2;i <= n;i ++){
		if(a[i] == -1){
			dp[i][0] = dp[i - 1][0];
			if(a[i - 1] == 1)dp[i][1] = min(dp[i - 1][0],dp[i - 1][1]) + 1;
			else dp[i][1] = 2147483647;
			if(a[i - 1] == 1)dp[i][2] = min(dp[i - 1][0],min(dp[i - 1][1],dp[i - 1][2])) + 2;
			else dp[i][2] = dp[i - 1][2] + 2;
		}
		if(a[i] == 0){
			dp[i][0] = dp[i - 1][0] + 1;
			dp[i][1] = min(dp[i - 1][0],dp[i - 1][1]);
			if(a[i - 1] == 1)dp[i][2] = min(dp[i - 1][0],min(dp[i - 1][1],dp[i - 1][2])) + 1;
			else dp[i][2] = dp[i - 1][2] + 1;
		}
		if(a[i] == 1){
			dp[i][0] = dp[i - 1][0] + 2;
			if(a[i - 1] == -1)dp[i][1] = min(dp[i - 1][0],dp[i - 1][1]) + 1;
			else dp[i][1] = dp[i - 1][0] + 1;
			dp[i][2] = min(dp[i - 1][0],min(dp[i - 1][1],dp[i - 1][2]));
		}
	}
	if(min(dp[n][0],min(dp[n][1],dp[n][2])) < 2147483647)cout<<min(dp[n][0],min(dp[n][1],dp[n][2]));
	else cout<<"BRAK";
	return 0;
}
```

---

## 作者：ydnhaha (赞：9)

[题面]( https://www.luogu.org/paste/35tpphqd)

看完了题，很容易想到DP，但是怎么设状态呢？我们先来看看最终的序列是怎么来的。显然值为$0$的项对后一项没有影响，那么改变数列的就是值为$1$或$-1$的项了。再回去看题，题目要求最终的序列长什么样子？单调不降，也就是说我们要通过值为$1$或$-1$的项把整个数列变成大概这个样子(出现小于$-1$或大于$1$的项显然不是最优的)
```
q[1] q[2] q[3] ...... q[n-2] q[n-1] q[n]

 -1   -1   0   ......    0     1      1
```

所以状态就好设了— —$dp[i][j]$表示到第$i$个数为止，结尾为$j+1$的最小次数，更准确地说是：**可以**使得前i个数满足单调不降，且结尾为j的最小操作次数。然后我们按数列中的数加加减减来转移......

就错了quq

为啥呢，看看设的状态：结尾为$j$。说明新状态也要参与转移，所以还有一大坨的分类讨论等着呢。

我们从$2$到$n$扫过去，按数列中的数讨论一下，分出三种情况，再进行转移

$1.nums[i]==-1$----这个数为$-1$

  $dp[i][0]=dp[i-1][0]$----试图使这个数变为$-1$：显然直接继承
   
  $dp[i][1]=(nums[i-1]==1)?min(dp[i-1][0],dp[i-1][1])+1:inf$----试图使这个数变为$0$：若前一个数为$1$，通过加$1$，可以从$dp[i-1][0]$或$dp[i-1][1]$转移过来(这样才能保证不降)，否则不能转移
            
  $dp[i][2]=(nums[i-1]==1)?min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+2:dp[i-1][2]+2$----试图使这个数变为1：若前一个数为$1$，通过两次加$1$，可以从$dp[i-1][0]$或$dp[i-1][1]$或$dp[i-1][2]$转移过来，否则只能从$dp[i-1][2]$转移过来
   
——————————————————————————————————————————————————
   
2.$nums[i]==0$----这个数为$0$

$dp[i][0]=dp[i-1][0]+1$----试图使这个数变为$-1$：可以由$dp[i-1][0]$进行一次减法转移过来

$dp[i][1]=min(dp[i-1][0],dp[i-1][1])$----试图使这个数变为$0$：可以直接从$dp[i-1][0]$或$dp[i-1][1]$转移过来
   
$dp[i][2]=
(nums[i-1]==1)?min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+1:dp[i-1][2]+1$----试图使这个数变为$1$：若前一个数为$1$，通过加$1$，可以从$dp[i-1][0]$或$dp[i-1][1]$或$dp[i-1][2]$转移过来，否则只能从$dp[i-1][2]$转移过来
  
——————————————————————————————————————————————————-  
  
3.$nums[i]==1$----这个数为$1$

$dp[i][0]=dp[i-1][0]+2$----试图使这个数变为$-1$：可以由$dp[i-1][0]$进行两次减法转移过来

$dp[i][1]=(nums[i-1]==-1)?min(dp[i-1][0],dp[i-1][1])+1:dp[i-1][0]+1$----试图使这个数变为$0$：若前一个数为$-1$，则可以从$dp[i-1][0]$或$dp[i-1][1])$通过一次减法转移，否则只能从dp[i-1][0]通过一次减法转移
   
$dp[i][2]=dp[i][2]=min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))$----试图使这个数变为1：直接从从$dp[i-1][0]$或$dp[i-1][1]$或$dp[i-1][2]$转移过来

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int nums[1000009],dp[1000009][3];
int inf=23333333;
int main ()
{
	int n,rd,ans;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&nums[i]);
	dp[1][0]=dp[1][1]=dp[1][2]=inf;
	dp[1][nums[1]+1]=0;
	for(int i=2;i<=n;i++)
		if(nums[i]==-1)
		{
			dp[i][0]=dp[i-1][0];
			dp[i][1]=(nums[i-1]==1)?min(dp[i-1][0],dp[i-1][1])+1:inf;
			dp[i][2]=(nums[i-1]==1)?min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+2:dp[i-1][2]+2;
		}
		else if(nums[i]==0)
		{
			dp[i][0]=dp[i-1][0]+1;
			dp[i][1]=min(dp[i-1][0],dp[i-1][1]);
			dp[i][2]=(nums[i-1]==1)?min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+1:dp[i-1][2]+1;
		}
		else if(nums[i]==1)
		{
			dp[i][0]=dp[i-1][0]+2;
			dp[i][1]=(nums[i-1]==-1)?min(dp[i-1][0],dp[i-1][1])+1:dp[i-1][0]+1;
			dp[i][2]=min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]));
		}
	ans=min(dp[n][0],min(dp[n][1],dp[n][2]));
	printf((ans>=inf)?"BRAK":"%d",ans);
	return 0;
}
```

---

## 作者：Jr_Zlw (赞：6)

# 这题贪心也能做呢！

在机房学长&大佬 @[jeffqi](https://www.luogu.com.cn/user/40581) 的指导下，用贪心做出来了！。

## 第一步

首先明确，这个队列只有  $0,-1,1$  ,   并且从始至终最优解都应只有这  $3$  个数。

假设给出这么一个例子： 

```
a[3]={1,1,-1}
```

如果我们要使  $a[2]>a[1]$  , 就需要对  $a[2]$  进行操作。

1.  直接用  $a[1]$  对  $a[2]$  进行操作 , 需要  $2$  次操作使  $a[2]=1\geq a[1]=1$  。

2. 假设我们花费一步对  $a[1]$  进行操作使序列变为  $\{1,2,-1\}$  , 然后再对  $a[2]$ 进行操作  ,  我们发现我们仍然需要  $2$  次操作才能使  $a[2]=3\geq a[1]=2$  ,而再进一步地修改显然也需要更多步数，因此永远保持序列中只存在  $1,0,-1$  才是性价比最高的做法。

## 第二步

其次，我们发现，如果队列中只存在  $1,0,-1$  ,  那么很明显这个队列只存在  $3$  层，即表现为  $\{-1,-1,...0,0,...,1,1\}$  的形式。那么这其中只存在了  $2$  个转折点，正常情况下只要枚举这两个转折点就能做出来了，但是这样的做法是  $O(n^2)$  的，还需要进一步优化。

我们发现，以  $0$  的序列与以  $1$  开头的序列都有一些神奇的性质：

### 对于  $1$  来说：

如果一个序列(或子序列)以  $1$  开头，例如下面的情况：

```
a[6]={1,-1,0,1,-1,0}
```

我们发现我们无法改变  $a[0]=1$  的事实，后面的数只能全部变成  $1$  才能得到正确答案。而此时贪心就排上用场了，我们可以直接把后缀记下来，记录从任意位置开始为  $1$  时所需的步数，以实现  $O(1)$  的查找。而记录后缀也是没有任何难度的一次  $n$  的循环就能搞定的。

### 对于  $0$  来说：

如果一个序列(或子序列)以  $0$  开头，例如下面这  $2$  组数据：

```
a1[6]={0,0,-1,-1,1,-1}
a2[6]={0,0,1,0,-1,1}
```

我们这时已经失去了第一层阶梯，由于第一个数是不允许被改变的，所以我们这时仅允许  $0,1$  存在

如果我们这时在一串  $0$  后直接遇到的第  $1$  个非  $0$  数字是  $-1$  的话，我们发现我们拿它没有任何办法，如  $a_1[1]=0,a_1[2]=-1$  时，无论怎么操作都无法使序列单调不降，这种情况使无解的。

而如果我们遇到的第  $1$  个非  $0$  数字是  $1$  ，此时就可以转化为求以这个  $1$  所在的位置为起点的子序列的答案，正如上面对  $1$  所分析的情况一样就可以求出答案了，譬如上面的  $a_2$  就能转化为一个前面有  $2$  个  $0$  而后面子序列以  $1$  为开头，按后缀查找就可以求出答案了！

所以对于  $0$  的讨论我们就记下以每一位后的第  $1$  个非  $0$  数的位置就可以实现查找了。

### 对于  $-1$  来说：


对于  $-1$  的讨论可以转化为对转折点的讨论。

我们可以直接从前往后扫。如果遇到的是  $1$  就讨论一下这里是否把  $1$  变为  $0$  或  $-1$，然后比较这  $3$  种情况下所需的步数并比较大小，记录答案就好了。

而变为  $0$  和变为  $1$  的情况都可以用前面的步骤去查找。（碰到无解的时候要特判）

然后再考虑把前面的每一个数都变为  $-1$  并记录下这样操作的步数然后继续往后扫就能讨论出那些可能的最优解了。而我们发现只用了  $O(n)$  的时间就查找到了答案！

## 上代码：

```
#include<bits/stdc++.h>
#define rep(a,b,c) for(int c=(a);c<=(b);++c)
#define drep(a,b,c) for(int c=(a);c>=(b);--c)
#define INF 0x3f3f3f3f
#define N 1000005
using namespace std;
inline int read()
{
	long long ans=0;bool f=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}
	while(ch>='0'&&ch<='9'){ans=(ans<<1)+(ans<<3)+(ch^48);ch=getchar();}
	if(f) return -ans; return ans;
}
int n,a[N],suf[N],nxt[N];
int main()
{
	n=read();int las=n+1;
	rep(1,n,i)a[i]=read();
	drep(n,1,i)
	{
		suf[i]=suf[i+1]+(1-a[i]);
		nxt[i]=las;if(a[i])las=i;
	}
	if(a[1]==1){printf("%d\n",suf[1]);return 0;}
	if(!a[1])
	{
		if(a[nxt[1]]==-1){puts("BRAK");return 0;}
		printf("%d\n",suf[nxt[1]]);return 0;
	}
	int mn=INF,cnt=0;
	rep(1,n,i)
	{
		cnt+=a[i]+1;
		if(a[nxt[i]]!=-1)mn=min(mn,cnt+suf[nxt[i]]);
		if(i<n&&a[i+1]==1)mn=min(mn,cnt+1+suf[nxt[i+1]]);
	}
	printf("%d\n",mn);
}
```

用时：  $64ms$

代码长度：  $0.9KB$  ~~非常好写！~~

---

## 作者：loceaner (赞：6)


## 思路

挺神的一道线性 $\text{DP}$ 题。

发现最后的序列也是 $-1,0,1$ 序列，因为改为别的值花费一定会变得更多。

设 $f_{i,j}$ 表示前 $i$ 个数字已经排好，第 $i$ 个数字变为 $j$ 的方案数，但是显然不能用负数下标，所以定义可以有一些修改。设 $f_{i,j}$ 表示前 $i$ 个数字已经排好，第 $i$ 个数字变为 $j-1$ 的方案数，那么能够用的数就是 $f_{i,0},f_{i,1},f_{i,2}$，分别表示当前数为 $-1,0,1$ 时的情况。

初始化整个 $f$ 数组为 $inf$，并且初始化 $f_{1,a_1+1}=0$，因为第一个数为 $a_1$ 的方案数显然为 $0$。

然后分情况讨论：

- 当 $a_i=-1$ 时：
  1. 变为 $-1$ 的方案数：因为当前数已经是 $-1$ 了，所以 $f_{i,0}=f_{i-1,0}$。
  2. 变为 $0$ 的方案数：如果要让 $-1$ 变成 $0$，前一个数必须是 $1$，如果要 $a_{i-1}$ 转化为 $1$，那么当前数也必须是 $1$，这样的话当前数就不能为 $0$ 了，也就是说不能有 $f_{i,1}$ 了，所以$f_{i,1}=inf$。
  3. 变为 $1$ 的方案数：同上，如果要让 $-1$ 变成 $1$，前一个数必须是 $1$，转移次数为 $2$，所以此时的方案数为 $f_{i,2}=f_{i-1,2}+2$。
- 当 $a_i=0$ 时：
  1. 变为 $-1$ 的方案数：只能从上一个数变为 $-1$ 的方案转移过来，转移次数为 $1$，即 $f_{i,0}=f_{i-1,0}+1$。 
  2. 变为 $0$ 的方案数：当前数已经为 $0$ 了，上一个数是 $-1,0$ 都行，所以取上一个数两个方案数中的最小值即可，即 $f_{i,1}=\min(f_{i-1,0},f_{i-1,1})$。
  3. 变为 $1$ 的方案数：同 $a_i=-1$ 时的情况，之不管转移次数变成了 $1$， 如果要让 $0$ 变成 $1$，那么前一个数需要是 $1$，所以 $f_{i,2}=f_{i-1,2}+1$。
-  当 $a_i=1$ 时：
  1. 变为 $-1$ 的方案数：只能从上一个数变为 $-1$ 的方案转移过来，转移次数为 $2$，即 $f_{i,0}=f_{i-1,0}+2$。 
  2. 变为 $0$ 的方案数：前一个数必须是 $-1$ 才能变成 $0$，所以 $f_{i,1}=f_{i-1,0}+1$。
  3. 变为 $1$ 的方案数：当前数已经为 $1$ 了，上一个数是什么都行，所以直接取上一个数三个方案数中的最小值即可，即 $f_{i,2}=\min(f_{i-1,0},f_{i-1,1},f_{i-1,2})$。

综上转移方程汇总：

$$\text{if } a_i=-1\begin{cases}f_{i,0}=f_{i-1,0}\\f_{i,1}=inf\\f_{i,2}=f_{i-1,2}+2\end{cases}$$

$$\text{if }a_{i}=0\begin{cases}f_{i,0}=f_{i-1,0}+1\\f_{i,1}=\min(f_{i-1,0},f_{i-1,1})\\f_{i,2}=f_{i-1,2}+1\end{cases}$$

$$\text{if }a_{i}=1\begin{cases}f_{i,0}=f_{i-1,0}+2\\f_{i,1}=f_{i-1,0}+1\\f_{i,2}=\min(f_{i-1,0},f_{i-1,1},f_{i-1,2})\end{cases}$$

最后的答案显然就是 $f_{n,0},f_{n,1},f_{n,2}$ 中的最小值。

**注意要判断无解情况**。

时间复杂度 $O(n)$。

## 代码

```cpp
//*
  Time: 18/09/20 15:26
  Author: Loceaner
  Description: 线性DP 
*/
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int A = 1e6 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

int n, a[A], f[A][3];

signed main() {
  n = read();
  for (int i = 1; i <= n; i++) a[i] = read();
  memset(f, inf, sizeof(f));
  f[1][a[1] + 1] = 0;
  for (int i = 2; i <= n; i++) {
    if (a[i] == -1) {
      f[i][0] = f[i - 1][0];
      f[i][2] = f[i - 1][2] + 2; 
    }
    if (a[i] == 0) {
      f[i][0] = f[i - 1][0] + 1;
      f[i][1] = min(f[i - 1][0], f[i - 1][1]);
      f[i][2] = f[i - 1][2] + 1;
    }
    if (a[i] == 1) {
      f[i][0] = f[i - 1][0] + 2;
      f[i][1] = f[i - 1][0] + 1;
      f[i][2] = min(min(f[i - 1][0], f[i - 1][1]), f[i - 1][2]);
    }
  }
  int ans = min(min(f[n][0], f[n][1]), f[n][2]);
  if (ans == inf) cout << "BRAK\n";
  else cout << ans << '\n';
  return 0;
}
```



---

## 作者：WJX3078 (赞：3)

# 前言：这是一道非常好的线性DP题，建议大家多理解该题的状态转移方程的推导过程，以便游刃有余的切其他DP题

好了，废话不多说，开始我们的解题之旅吧！

------------
# 1.题意简述

给一个只包含$-1,0,1$的数列，每次操作可以让$a[i]+=a[i-1]$，求最少操作次数使得序列单调不降,**若无解，则输出“BRAK”（不加引号）**。这道题最坑人之处便是翻译中没有说明无解的输出情况，导致可能会在这个点上卡好久。

# 2.解题思路

### 1.首先，我们可以得到一个非常有用的结论--操作完成后的最终序列一定是一个只包含$-1,0,1$的数列。

为了让大家都能理解透此题，我还是在下面先给出一段证明。~~（懂了的大佬可自行跳过）~~

1.如果操作完的序列包含$-2$（或者比$-2$还小），那么该数的$i-1$位一定是$-1$（废话，因为$a[i]+=a[i-1]$,$i-1$位必须是$-1$才可以使第$i$位的数减小到$-2$）,那么此序列一定不满足单调不降（$-1>-2$），所以该情况不成立，舍去

2.如果操作完的序列包含$2$（或者比$2$还大），那么该数的$i-1$位一定是$1$（废话，因为$a[i]+=a[i-1]$,$i-1$位必须是$1$才可以使第$i$位的数增加到$2$）,那我后面的所有数都要$\ge2$（为了满足序列单调不降），还不如我只加到$1$呢。~~这不是多此一举、自找苦吃吗？~~

综上所述，操作完成后的最终序列一定是一个只包含$-1,0,1$的数列。

### 2.我们其实由第一个结论就可以推出无解的情况

1.如果该序列的第一个数是$1$，那么一定可以把序列都变为$1 1......1 1$（一共有$n$个$1$）。即该序列肯定有解。

2.如果该序列的第一个数是$-1$，那么一定可以把序列都变为$-1 -1......-1 -1$（一共有$n$个$-1$）。即该序列肯定有解。

3.如果该序列的第一个数是$0$，我们再看第一个不是$0$的数（假定为$x$）。

若$x=1$，那该序列满足单调不降，接下来按该序列的第一个数是$1$的情况进行处理，该序列也肯定有解。

**若$x=-1$,那么该序列肯定无解。**（因为无论$-1$加多少个$0$都还是$-1$,满足不了序列单调不降的条件）

好了，既然我们已经把握两大结论在手中，就可以直接莽结论（不要怂，就是干）。

## 状态表示及阶段划分

根据解DP题的$6$大法则：**题意简述--状态表示--阶段划分--转移方程--边界条件--DP目标**，我们来想一想我们DP数组的意义及要求什么。

首先，题目要我们求最少操作次数，那我们就跟着题面走，令**DP数组的值为最少操作次数。**

其次，我们再思考一下DP数组要有几个维度，每一个维度分别求什么？我们观察一下我们推出的结论$1$，**最终序列一定是一个只包含$-1,0,1$的数列**，那好办了，直接令第一维表示下标，第二维表示数值。**即$f[i][j]$表示下标为$i$且该下标对应数值为$j$时的最少操作次数**。

自然，阶段划分也很明了，直接令**到达$i$下标的最少操作次数**为一个阶段。

# 状态转移方程

做多了DP题的OIer都知道，DP方程是DP题最大的难点	~~（得之则生，弗得则死）~~，就让我们一举攻破这一难关吧！

我们设当前下标为$i$,以$a[i]$对应的值进行分类。再开一个辅助数组$hav$，记录能否到达下标为$i$且该下标对应数值为$j$的状态。又因为数组下标不能为负数，所以我们令$j=a[i]+2$

### 当$a[i]=-1$时

1.**如果前一下标（$i-1$）可以到达值为-1的状态。** 那$f[i][1]$就直接继承前一状态的值（因为这个点就是$-1$ ，所以不用花费次数进行转移），用代码说话，就是

```cpp
if(hav[i-1][1]) f[i][1]=f[i-1][1],hav[i][1]=1;
```

又因为前一下标（$i-1$）可以到达值为-1的状态消耗次数只会令$a[i]$减小，不会影响$f[i][2]$、$f[i][3]$，所以不改变$f[i][2]$、$f[i][3]$的值。

2.**如果前一下标（$i-1$）可以到达值为0的状态。** 因为$-1+0$还是$-1$,又不满足序列单调不降，所以不改变f数组的值。

3.**如果前一下标（$i-1$）可以到达值为1的状态。** 那就可以通过$-1+1+1=1$得到这一下标（$i$）到达值为1的状态的次数，用代码说话，就是

```cpp
if(hav[i-1][3]) f[i][3]=f[i-1][3]+2,hav[i][3]=1;
```


------------

### 当$a[i]=0$时

1.**如果前一下标（$i-1$）可以到达值为$-1$的状态。** 那就可以通过$0+（-1）=-1$得到这一下标到达值为$-1$的状态的次数，继承前一下标（$i-1$）到达$-1$时状态得到这一下标（$i$）到达值为$0$的状态的次数（显然满足单调不降），用代码说话，就是

```cpp
if(hav[i-1][1]) f[i][1]=f[i-1][1]+1,hav[i][1]=1,f[i][2]=f[i-1][1],hav[i][2]=1;
```

2.**如果前一下标（$i-1$）可以到达值为$0$的状态。** 那就继承前一状态的次数（因为可能被第一条$if$语句改过$f[i][2]$的值，所以取最小值），用代码说话，就是

```cpp
if(hav[i-1][2]) f[i][2]=min(f[i][2],f[i-1][2]),hav[i][2]=1;
```


3.**如果前一下标（$i-1$）可以到达值为$1$的状态。** 那就可以通过$0+1=1$得到这一下标（$i$）到达值为$1$的状态的次数，用代码说话，就是

```cpp
if(hav[i-1][3]) f[i][3]=f[i-1][3]+1,hav[i][3]=1;
```



------------


### 当$a[i]=1$时

1.**如果前一下标（$i-1$）可以到达值为$-1$的状态。** 那就可以通过$1+（-1）+（-1）=-1$得到这一下标到达值为$-1$的状态的次数，通过$1+（-1）=0$得到这一下标到达值为$0$的状态的次数，继承前一下标到达$-1$时状态得到这一下标到达值为$1$的状态的次数（显然满足单调不降），用代码说话，就是

```cpp
if(hav[i-1][1]) f[i][1]=f[i-1][1]+2,hav[i][1]=1,f[i][2]=f[i-1][1]+1,hav[i][2]=1,f[i][3]=f[i-1][1],hav[i][3]=1;
```

2.**如果前一下标（$i-1$）可以到达值为0的状态。** 继承前一下标到达$0$时状态得到这一下标到达值为$1$的状态的次数（显然满足单调不降），用代码说话，就是

```cpp
if(hav[i-1][2]) f[i][3]=min(f[i][3],f[i-1][2]),hav[i][3]=1;
```

3.**如果前一下标（$i-1$）可以到达值为1的状态。** 那就继承前一状态的次数，用代码说话，就是

```cpp
if(hav[i-1][3]) f[i][3]=min(f[i][3],f[i-1][3]),hav[i][3]=1;
```


------------


## 最后，我们确定一下DP的边界条件及DP目标

显然，DP的边界条件是$f[1][a[1]+2]=0;hav[1][a[1]+2]=1;$

```cpp
memset(f,INF,sizeof(f));
	f[1][a[1]+2]=0;hav[1][a[1]+2]=1;
```

而DP目标是$min(f[n][1],min(f[n][2],f[n][3]))$

```cpp
if(!hav[n][1]&&!hav[n][2]&&!hav[n][3]) printf("BRAK");
	//都到不了下标为n的状态，就是无解
	else printf("%d",min(f[n][1],min(f[n][2],f[n][3])));
```

# 3.打了这么久，终于上代码了

1.用$hav$数组的版本（更便于理解）

```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <cstring>
#define il inline
#define ll long long
#define gc getchar
#define R register
using namespace std;
//---------------------初始函数-------------------------------
il int read(){
	R int x=0;R bool f=0;R char ch=gc();
	while(!isdigit(ch)) {f|=ch=='-';ch=gc();}
	while(isdigit(ch)) {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
	return f?-x:x;
}

il int max(int a,int b) {return a>b?a:b;}

il int min(int a,int b) {return a<b?a:b;}

il int abs(int x) {return x>0?x:-x;}


//---------------------初始函数-------------------------------

const int MAXN=1e6+10,INF=0x3f3f3f3f;
int n,a[MAXN],f[MAXN][4];
//a->原数组，f->DP数组，第一维表示下标，第二维表示该下标对应数值+2,f数组记录到下标为i且该下标对应数值+2为j时的最小修改次数
bool hav[MAXN][4];
//hav->能否到达下标为i且该下标对应数值+2为j的状态

signed main(){
	n=read();
	for(R int i=1;i<=n;++i) a[i]=read();
	memset(f,INF,sizeof(f));
	f[1][a[1]+2]=0;hav[1][a[1]+2]=1;//初始化
	for(R int i=2;i<=n;++i){
		if(a[i]==-1){
			if(hav[i-1][1]) f[i][1]=f[i-1][1],hav[i][1]=1;
			//如果前一下标可以到达值为-1的状态，那就继承前一状态的次数
			//如果前一下标可以到达值为0的状态，因为-1+0还是-1,又不满足序列单调不降，所以不改变f数组的值
			if(hav[i-1][3]) f[i][3]=f[i-1][3]+2,hav[i][3]=1;
			//如果前一下标可以到达值为1的状态，那就可以通过-1+2=1得到这一下标到达值为1的状态的次数
		}
		else if(a[i]==0){
			if(hav[i-1][1]) f[i][1]=f[i-1][1]+1,hav[i][1]=1,f[i][2]=f[i-1][1],hav[i][2]=1;
			//如果前一下标可以到达值为-1的状态，那就可以通过0+（-1）=-1得到这一下标到达值为-1的状态的次数，继承前一下标到达-1时状态得到这一下标到达值为0的状态的次数（显然满足单调不降）
			if(hav[i-1][2]) f[i][2]=min(f[i][2],f[i-1][2]),hav[i][2]=1;
			//如果前一下标可以到达值为0的状态，那就继承前一状态的次数（因为可能被第一条if改过f[i][2]，所以取最小值）
			if(hav[i-1][3]) f[i][3]=f[i-1][3]+1,hav[i][3]=1;
			//如果前一下标可以到达值为1的状态，那就可以通过0+1=1得到这一下标到达值为1的状态的次数
		}
		else if(a[i]==1){
			if(hav[i-1][1]) f[i][1]=f[i-1][1]+2,hav[i][1]=1,f[i][2]=f[i-1][1]+1,hav[i][2]=1,f[i][3]=f[i-1][1],hav[i][3]=1;
			//如果前一下标可以到达值为-1的状态，那就可以通过1+（-2）=-1得到这一下标到达值为-1的状态的次数，通过1+（-1）=0得到这一下标到达值为0的状态的次数，继承前一下标到达-1时状态得到这一下标到达值为1的状态的次数（显然满足单调不降）
			if(hav[i-1][2]) f[i][3]=min(f[i][3],f[i-1][2]),hav[i][3]=1;
			//如果前一下标可以到达值为0的状态，继承前一下标到达0时状态得到这一下标到达值为1的状态的次数（显然满足单调不降）
			if(hav[i-1][3]) f[i][3]=min(f[i][3],f[i-1][3]),hav[i][3]=1;
			//如果前一下标可以到达值为1的状态，那就继承前一状态的次数
		}
	}
	if(!hav[n][1]&&!hav[n][2]&&!hav[n][3]) printf("BRAK");
	//都到不了下标为n的状态，就是无解
	else printf("%d",min(f[n][1],min(f[n][2],f[n][3])));
	return 0;
}
```

2.只用$f$ 数组的版本（更省空间）

```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <cstring>
#define il inline
#define ll long long
#define gc getchar
#define R register
using namespace std;
//---------------------初始函数-------------------------------
il int read(){
	R int x=0;R bool f=0;R char ch=gc();
	while(!isdigit(ch)) {f|=ch=='-';ch=gc();}
	while(isdigit(ch)) {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
	return f?-x:x;
}

il int max(int a,int b) {return a>b?a:b;}

il int min(int a,int b) {return a<b?a:b;}

il int abs(int x) {return x>0?x:-x;}


//---------------------初始函数-------------------------------

const int MAXN=1e6+10,INF=0x3f3f3f3f;
int n,a[MAXN],f[MAXN][4];
bool hav[MAXN];

signed main(){
	n=read();
	for(R int i=1;i<=n;++i) a[i]=read();
	memset(f,INF,sizeof(f));
	f[1][a[1]+2]=0;
	for(R int i=2;i<=n;++i){
		if(a[i]==-1){
			if(f[i-1][1]!=INF) f[i][1]=f[i-1][1];
			if(f[i-1][3]!=INF) f[i][3]=f[i-1][3]+2;
		}
		if(a[i]==0){
			if(f[i-1][1]!=INF) f[i][1]=f[i-1][1]+1,f[i][2]=f[i-1][1];
			if(f[i-1][2]!=INF) f[i][2]=min(f[i][2],f[i-1][2]);
			if(f[i-1][3]!=INF) f[i][3]=f[i-1][3]+1;
		}
		if(a[i]==1){
			if(f[i-1][1]!=INF) f[i][1]=f[i-1][1]+2,f[i][2]=f[i-1][1]+1,f[i][3]=f[i-1][1];
			if(f[i-1][2]!=INF) f[i][3]=min(f[i][3],f[i-1][2]);
			if(f[i-1][3]!=INF) f[i][3]=min(f[i][3],f[i-1][3]);
		}
	}
	int ans=min(f[n][1],min(f[n][2],f[n][3]));
	if(ans>=INF) printf("BRAK");
	else printf("%d",ans);
	return 0;
}
```

当然，由于个人码风习惯，我更喜欢用$f[i][1......3]$，也可以用$f[i][0......2]$替代，且更省空间。

# 4.后记

这里还有个小问题，可以帮大家加深对DP的理解。

### Q1:为什么其他题解都要判定$a[i]$的值，而你不判。

例子： 

当$a[i]=-1$时，

$f[i][2]=(a[i-1]==1)?min(f[i-1][1],f[i-1][2])+1:INF;$

### A1:这一步操作是在开始DP前进行的，相当于在DP开始前修改$a[i]$的值，而我的代码是在DP过程中随用随改，并不兼容在DP开始前修改$a[i]$的方式。

如果还有问题欢迎私信，好的问题会挂出来帮助其他OIer进行理解










---

## 作者：Rorschachindark (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3558)
# Description
给一个长度为 $n$ 的且只包含 $-1,0,1$ 的数列，每次操作可以让
$a_i\to a_i+a_{i-1}$，求最少操作次数使得序列单调不降

$n\le 10^6$，无解输出 $\texttt{BARK}$ 。
# Solution
不难看出我们可以 dp，我们可以设 $f_{i,j}$ 表示解决了前面 $i$ 个数之后第 $i$ 个数为 $j$ 的最小操作次数。

不难看出的是，我们序列最后肯定只包含 $-1,0,1$ 。因为如果有超过 $1$ 的数，那么产生的原因肯定是一个数要超过一个数，但是这个题里面一开始只有 $-1,0,1$ ，所以一定只会加到它要超过的数，也就是说，不会超过 $1$。所以就不会存在超过 $1$ 的情况。

有了上面的分析，dp 转移式就不难列出：

$$f_{i,a_i+j\times k}\to f_{i-1,j}+k(-1\le a_i+j\times k,j,k\le 1, a_i+j\times k\ge a_{i-1})$$

时间复杂度 $\Theta(n)$。
# Code
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXN 1000005

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,a[MAXN],f[MAXN][3],val[3] = {-1,0,1};

signed main(){
	read (n);
	for (Int i = 1;i <= n;++ i) read (a[i]);
	memset (f,0x7f,sizeof (f)),f[1][a[1] + 1] = 0;
	for (Int i = 2;i <= n;++ i){
		for (Int j = 0;j < 3;++ j){
			if (a[i] >= val[j]) f[i][a[i] + 1] = min (f[i][a[i] + 1],f[i - 1][j]);
			if (a[i] + val[j] >= -1 && a[i] + val[j] <= 1 && a[i] + val[j] >= val[j]) f[i][a[i] + val[j] + 1] = min (f[i][a[i] + val[j] + 1],f[i - 1][j] + 1);
			if (a[i] + val[j] * 2 >= -1 && a[i] + val[j] * 2 <= 1 && a[i] + val[j] * 2 >= val[j]) f[i][a[i] + val[j] * 2 + 1] = min (f[i][a[i] + val[j] * 2 + 1],f[i - 1][j] + 2);
		}
	}
	int ans = 0x7f7f7f7f;for (Int i = 0;i < 3;++ i) ans = min (ans,f[n][i]);
	if (ans != 0x7f7f7f7f) write (ans),putchar ('\n');
	else puts ("BRAK");
	return 0;
}
```

---

## 作者：mrozhx (赞：1)

显然如果序列原本满足要求，则输出  $0$  步。

我们先想想最优解该长什么样。$a[i]=1$  时，要使序列合法且步数最少，显然  $a[i+1]$  要变成  $1$  ，此时  $-1$  要  $2$  次，  $0$  要搞  $1$  次。这时我们思考，怎么减少步数？如果  $-1$  只需要用  $1$  步，那么就可以剩下不少步数。那么我们继续推理，要让  $-1$  只用  $1$  步，则  $a[i]=2$  ,但是这时就要求  $a[i+1]>=2$  ，使  $a[i+1]$  合法就需要消耗  $2$  步，以及让  $a[i]$  从  $1$  变成  $2$  的第三步，显然不划算。那么也就是说最优解的序列满足  $-1<=a[i]<=1$ 。

我们再想想没有解决方案的情况，显然当序列最左端有一段  $0$  且接了  $-1$  时，不可能解决。因为最左端的一段  $0$  不能转化为其他数，对后面没有影响，因此可以忽略，并转化为  $a[1]!=0$  的情况解决。

下面来思考解决方案，要使队列不降且  $a[i]<=1$  ，则  $1$  后面的所有数都必须是  $1$  。因此我们可以枚举每一个 $1$  ，并使它后面所有数均为  $1$  ，因为每一个  $1$  都需计算后面  $0$  与  $-1$  的个数，所以我们选择反向遍历。

再者，与  $1$  同理，序列中的某个  $-1$  前的所有数必须全部为  $-1$  ，因此我们在输入时记录将某个数左边所有数变成  $-1$  所需的步数。

而对于每个  $1$  ，我们可以遍历最右边的  $-1$  并比较他们的算出他们的最小值。但是我们可以发现，最右边的  $-1$  有三种来源:

（1）如果是原本的  $-1$  ，可以直接使用。

（2）0也可以变成-1，但要消耗1步，无须多此一举。

（3）1也可以变成-1，但是此前1要先变成0，这时转化为（2）。

那么只需枚举每种可能的情况并剪剪枝就愉快的做完了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1001000];
int bianfe[1001000];//变（bian）负（f）一（e）
int pre[1001000][3];
inline int read()
{
	long long ans=0;bool f=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}
	while(ch>='0'&&ch<='9'){ans=(ans<<1)+(ans<<3)+(ch^48);ch=getchar();}
	if(f) return -ans; return ans;
}
int main(){
	bool te=false;
	n=read();
	a[0]=-2;
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(a[i]==1) pre[i][1]=i,pre[i][0]=pre[i-1][0];
		else if(a[i]==-1) pre[i][1]=pre[i-1][1],pre[i][0]=i;
		else pre[i][1]=pre[i-1][1],pre[i][0]=pre[i-1][0];
		bianfe[i]=bianfe[i-1]+a[i]+1;
		te|=a[i-1]>a[i];
	}a[n+1]=1;
	if(!te){
		puts("0");
		return 0;
	}
	if(a[1]==0){
		int i;
		for(i=2;i<=n;i++){
			if(a[i]==-1){
				puts("BRAK");
				return 0;
			}
			if(a[i]==1){
				break;
			}
		}
		for(int j=i;j<=n;j++){
			a[j-i+1]=a[j];
		}
		n-=(i-1);
	}
	if(a[1]==1){
		int ans=0;
		for(int i=2;i<=n;i++){
			ans+=(1-a[i]);
		}
		printf("%d",ans);puts("");
		return 0;
	}
	if(a[1]==-1){
		int ans=9999999;
		int biane=0;
		for(int i=n+1;i>0;i--){
			biane+=(1-a[i]);
			if(biane>=ans) break;
			if(a[i]==1){
				int lit=0;
				int j=i-1;
				if(pre[j][1]>pre[j][0]) lit=bianfe[pre[j][1]-1]+1;
				else lit=bianfe[pre[j][0]];
				ans=min(ans,lit+biane);
			}
		}
		printf("%d",ans);puts("");
		return 0;
	}
}
```


---

## 作者：lgswdn_SA (赞：1)

这题想到状态后转移方程就比较无脑，但需要分类讨论。

貌似完成后结果一定是 $-1,0,1$ 组成的数列？

先设自然状态 $f(i)$ 代表前 $i$ 个组成的数列的最少步数。但是由于其实 $a_i$ 是会变的，所以不能这样设。

所以我们考虑把变化的 $a_i 计入状态。$f(i,j)$ 表示前 $i$ 位且第 $i$ 个是 $j1$ 的情况。考虑转移。

如果 $a_i=0$，那么转移很简单。

$$
f(i,0)=\min(f(i-1,0),f(i-1,-1))
$$
$$
f(i,1)=f(i-1,1)+1
$$
$$
f(i,-1)=f(i-1,-1)+1
$$

如果是 $a_i=1$，要注意 $f(i,-1)$ 需要减两次。

$$
f(i,0)=f(i-1,-1)+1
$$
$$
f(i,1)=\min(f(i-1,0),f(i-1,-1),f(i-1,1))
$$
$$
f(i,-1)=f(i-1,-1)+2
$$

如果是 $a_i=-1$，要注意 $f(i,1)$ 需要加两次，而且 $f(i,0)$ 不能存在。

$$
f(i,1)=f(i-1,1)+2
$$
$$
f(i,-1)=f(i-1,-1)
$$

初始状态：$f(i,j)=\inf, f(1,a_1)=0$

最后一点，实际写的时候，需要注意下标不能是负数，所以需要右移一位。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(register int i=a;i<=b;i++)
using namespace std;
const int N=1e6+9;

int a[N], f[N][3];
int main() {
	int n; scanf("%d",&n);
	memset(f,0x3f,sizeof(f));
	rep(i,1,n) scanf("%d",&a[i]);
	f[1][a[1]+1]=0;
	rep(i,2,n) {
		if(a[i]==0)
			f[i][0]=f[i-1][0]+1,
			f[i][1]=min(f[i-1][0],f[i-1][1]),
			f[i][2]=f[i-1][2]+1;
		else if(a[i]==1)
			f[i][0]=f[i-1][0]+2,
			f[i][1]=f[i-1][0]+1,
			f[i][2]=min(min(f[i-1][0],f[i-1][1]),f[i-1][2]);
		else
			f[i][0]=f[i-1][0],
			f[i][2]=f[i-1][2]+2;
	}
	int ans=min(min(f[n][0],f[n][1]),f[n][2]);
	if(ans<0x3f3f3f3f) printf("%d",ans);
	else puts("BRAK"); 
	return 0;
}
```

---

## 作者：LlLlCc (赞：0)

注意题目，如果$k_1<k_2$，那么不存在先执行$a_{k_2}+=a_{k_2-1}$，再执行$a_{k_1}+=a_{k_1-1}$，所以我们只要从前往后枚举即可

因为序列只存在$-1,0,1$三种情况，同时序列又是呈单调性的，所以每一个$i$只要受到$i-1$的状态影响，即只要分$3\times 3=9$种类别讨论

不妨设：

$\large f_{i,j}:$ 前$i$个数满足单调不减，且第$i$个数变为$j-1$所需的最小操作数（由于数组不能存$-1$所以整体往右移一位）

初始状态即：$\large f_{1,a_1+1}=0$

$\LARGE 1.\;\;a_i=-1$

- $\large f_{i,0}:$因为要满足单调性，所以前一个数必须为$-1$，同时，$-1$变为$-1$也不需要再加上新的操作数，即$\large f_{i,0}=f_{i-1,0}$

- $\large f_{i,1}:$因为从$-1$变成了$0$，所以前一个数一定是$1$，但这就不满足单调性了，所以无法转移，即$\large f_{i,1}=INF$

- $\large f_{i,2}:$因为从$-1$变成了$1$，所以前一个数一定是$1$，而且从$-1$变成$1$要加两次$1$，即$\large f_{i,2}=f_{i-1,2)+2$

$\LARGE 1.\;\;a_i=0$

- $\large f_{i,0}:$因为从$0$变成了$-1$，所以前一个数一定是$-1$，而且从$0$变成了$-1$要加一次$-1$，即$\large f_{i,0}=f_{i-1,0}+1$

- $\large f_{i,1}:$因为要满足单调性，所以前一个数只能为$-1$或$0$，同时，$0$变为$0$也不需要再加上新的操作数，即$\large f_{i,1}=\min (f_{i-1,0},f_{i-1,1})$

- $\large f_{i,2}:$因为从$0$变为了$1$，所以前一个数必为$1$，而且从$0$变为$1$要加一次$1$，即$\large f_{i,2}=f_{i-1,2}+1$

$\LARGE 1.\;\;a_i=1$

- $\large f_{i,0}:$因为从$1$变成了$-1$，所以前一个数一定是$-1$，而且从$1$变成了$-1$要加两次$-1$，即$\large f_{i,0}=f_{i-1,0}+2$

- $\large f_{i,1}:$因为从$1$变成了$0$，所以前一个数一定是$-1$，而且从$1$变成了$0$要加一次$-1$，即$\large f_{i,1}=f_{i-1,0}+1$

- $\large f_{i,2}:$因为前一个数不管怎么取都满足单调性，且$1$变成$1$也不需要再加操作，即$\large f_{i,2}=\min (f_{i-1,0},f_{i-1,1},f_{i-1,2})$

答案就从$\large f_{n,0},f_{n,1},f_{n,2}$三个里挑个最小的

还有，可以发现每一个状态之和前一个状态有关，所以我们还可以滚动数组，进一步优化了空间

## code
```
#include<bits/stdc++.h>
#define maxn 1000005
using namespace std;
const int INF=1<<30;
int n,f[2][3],x,Ans;
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
	n=read();x=read()+1;
	for (int i=0;i<3;i++) f[1][i]=INF;f[1][x]=0;
	for (int i=2;i<=n;i++){
		x=read()+1;
		if (!x){
			f[i&1][0]=f[1-i&1][0];
			f[i&1][1]=INF;
			f[i&1][2]=f[1-i&1][2]+2;
		}
		else if (x==1){
			f[i&1][0]=f[1-i&1][0]+1;
			f[i&1][1]=min(f[1-i&1][0],f[1-i&1][1]);
			f[i&1][2]=f[1-i&1][2]+1;
		}
		else{
			f[i&1][0]=f[1-i&1][0]+2;
			f[i&1][1]=f[1-i&1][0]+1;
			f[i&1][2]=min(f[1-i&1][0],min(f[1-i&1][1],f[1-i&1][2]));
		}
	}
	Ans=INF;
	for (int i=0;i<3;i++) Ans=min(Ans,f[n&1][i]);
	if (Ans==INF) printf("BRAK");
	else printf("%d",Ans);
	return 0;
}
```





---

## 作者：Lates (赞：0)

很好的线性dp，有几个点：

- 无解要判

- 序列操作完只有 0,1,-1


---

设 $f_{i,j}$ 为 $1-i$ 中，填完操作完第 $i$ 位为 $j$ 时的最小步数

分类讨论：

- $a_i=-1$

$$f_{i,-1}=f_{i-1,-1}$$
$$f_{i,0}=\infty$$
$$f_{i,1}=f_{i-1,1}+2$$

填完为 $-1$，当前为了满足单调不降，答案只能是上一个。

填完为 $0$，当前绝对加了 $a_{i-1}=1$，而此时的序列必然不是单调不降的。

填完为 $1$，当前只能加两遍 $a_{i-1}=1$，操作花费 $2$。

为什么 $-1,1$ 的状态只能从前一个对应的转移过来，比如填完为 $1$ 的情况。

由于前一个填完为 $0$ 或 $-1$,答案为 $f_{i-1,0},f_{i-1,-1}$，我们当前要转移的是 $f_{i,1}$，但是我们发现虽然满足了单调不降，但是当
$a_i=-1,a_{i-1}=0 \ or -1$，当前操作多少步 $a_{i}+=a_{i-1}$ 都到不了 $1$，所以不能从别的状态转移。

- $a_i=0$

$$f_{i,-1}=f_{i-1,-1}+1$$
$$f_{i,0}=\min(f_{i-1,0},f_{i-1,1})$$
$$f_{i,1}=f_{i-1,1}+1$$

第一个和第三个类似第一种分类讨论里的转移。

第二个我们发现，此时的策略应该是不做任何操作(答案是求操作完为 $0$ 的最优答案，当前不动 $a_i$ 就是 $0$。)，为了满足单调不降，我们不能使用 $f_{i,1}$ 转移。

- $a_i=1$

$$f_{i,-1}=f_{i-1,-1}+2$$
$$f_{i,0}=f_{i-1,-1}+1$$
$$f_{i,1}=\min(f_{i-1,-1},f_{i-1,0},f_{i-1,1})$$

这些就和前两个分类讨论差不多。

---

程序部分由于 $C++$ 数组不能用负数，我们把 $f$ 第二维全部加 $1$ 即可。


```cpp

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int MAX=1000010; 
int n,a[MAX],ans,f[MAX][3],INF=0x3f3f3f3f;
signed main(){
	n=read();
	for(register int i=1;i<=n;++i)a[i]=read();
	memset(f,INF,sizeof(f));
	f[1][a[1]+1]=0;
	for(register int i=2;i<=n;++i){
		if(a[i]==-1){
			f[i][0]=f[i-1][0];
			f[i][2]=f[i-1][2]+2;
		}else if(a[i]==0){
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=f[i-1][2]+1;
		}else {
			f[i][0]=f[i-1][0]+2;
			f[i][1]=f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}
	}
	ans=min(f[n][0],min(f[n][1],f[n][2]));
	if(ans==INF)printf("BRAK\n");
	else printf("%d\n",ans);
	return 0;
}


```




---

## 作者：Aryper (赞：0)

[POI2013]BAJ-Bytecomputer

最后调的时候那个 BRAK 始终调不出来，然后发现自己的状态转移写成 $i$ 从 1 开始了，我谔谔。

这道 DP 题还是不错的，状态转移需要考虑的细节真的不少，不想清楚的话很难做出来。

定义状态 $f_i,_j$ 表示使前 $i$ 个数保持不降，且第 $i$ 位为 $j$ 的最少变换次数。

其实题目中的这个**不降**很有意思，我们**完全没有必要把其中的数调到 -1~1 之外**，因为允许有数字重叠，那样做是浪费次数的。

**所以 j 的范围就是 -1~1** 。但是 C++ 数组的下标不能是负数，那我们就 +1 **， $f_i,_j$ 表示使前 $i$ 个数保持不降，且第 $i$ 位为 $j-1$ 的最少变换次数。**

解决状态定义这个问题后，我们开始着手**状态转移**，算是这道题目真正难和精髓的地方。

1. 当 $a_i=1$ 时。

$f_i,_0 = f_{i-1},_0+2$

$f_i,_1=f_{i-1},_0+1$

$f_i,_2=\min\{f_{i-1},_0,f_{i-1},_1,f_{i-1},_2\}$

考虑**不降**性，前两种转移都是建立在上一个数是 -1 的情况下，所以**一定能保证不降性**。第三种转移是建立在保持自身不变的情况下，取前面转移时的最小操作次数，显然不会有大于 1 的存在，也**一定能保证不降性**。

2. 当 $a_i=0$ 时。

$f_i,_0=f_{i-1},_0+1$

$f_i,_1=\min\{f_{i-1},_0,f_{i-1},_1\}$

$f_i,_2=f_{i-1},_2+2$

考虑**不降**性，前两种转移时建立在上一个数是 -1 或 0 的情况下，**一定能保证不降性**。第三种转移建立在上一个数是 1 的情况下，而转移后自身也变为 1 ，**也能保证不降性**。

3. 当 $a_i=-1$ 时。

$f_i,_0=f_{i-1},_0$

$f_i,_1=f_{i-1},_2+1$ (舍弃)

$f_i,_2=f_{i-1},_2+2$

考虑**不降**性，第一个和第三个转移都是建立在上一个数 $\le$ 转移后的自己的，**一定保证不降性**。**第二个转移却是在上一个数大于转移后的自己所做的，显然不符题意，所以我们舍弃。**

这样，我们就完成了转移。(细节部分真的值得仔细回味)

**初始化**的话比较简单，所有状态赋值 $\inf$ ，再将 $f_1,_{a_i+1}$ 赋值 0 ，就完事了，**因为第一个数不论如何操作都是无法改变的**。

最后的答案 $ans=\min\{f_n,_0,f_n,_1,f_n,_2\}$ ，如果 $ans\ge\inf$ ，就说明无解，输出 BRAK 。

代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<cstring>
#include<vector>
#include<bitset>
using namespace std;

const long long inf=2147483647;

long long n,ans;

long long f[1000005][3],a[1000005];

inline long long read() {
	long long ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') {ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
	return ret*f;
}

int main() {
	
	n=read();
	for(int i=0;i<=n;i++) f[i][0]=f[i][1]=f[i][2]=inf;
	
	for(int i=1;i<=n;i++) {a[i]=read();}
	
	f[1][a[1]+1]=0;
	
	for(int i=2;i<=n;i++) {
		if(a[i]==1) {
			f[i][0]=f[i-1][0]+2;
			f[i][1]=f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}
		if(a[i]==0) {
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=f[i-1][2]+1;
		}
		if(a[i]==-1) {
			f[i][0]=f[i-1][0];
			f[i][2]=f[i-1][2]+2;
		}
	}
	
	ans=inf;
	
	for(int i=0;i<3;i++) {
		ans=min(ans,f[n][i]);
	}
	
	if(ans>=inf) printf("BRAK");
	else printf("%lld",ans);
	
	return 0;
}
```


---

## 作者：Sata_moto (赞：0)


[$ \large{}\color {#6495ED} \mathcal{MyBlog} $](https://xjx885.coding-pages.com/)

---

$
$

## 前言：

$\quad \quad$ 注意：**无解输出'BRAK'!**

$\quad \quad$ （这就是我花了思考消耗的六倍时间调试代码的原因）

---

$
$

## 题目大意：

$\quad \quad$ 给一个只包含 $-1,0,1$ 的数列，每次操作可以让 $a[i]+=a[i-1]$，求最少操作次数使得序列单调不降。

$\quad \quad$ 数据范围为 $N\le10^6$。

---


$
$
## 思路分析:

$\quad \quad$ 本题显然是一道 DP 题（满足无后效性以及最优子结构性质）。

$\quad \quad$ 观察数据范围，可以看出本题算法大致为线性DP。

$\quad \quad$ 考虑状态的设计，容易想到设立状态 $f(i,j)$ 表示当前处理完了 $i$ 个数，上一个数值为 $j$。

$\quad \quad$ 但是这种状态显然不行，$j$ 没有上下界导致算法的空间&时间复杂度极其爆炸。

$\quad \quad$ 注意到，序列原本仅有 $-1,0,1$ ,我们考虑据此确定较优的 $j$ 的上下界。

$\quad \quad$ 可以猜测：一定至少存在一种最优解使得最后的序列中仅存在 $-1,0,1$。

$\quad \quad$ （大胆猜想，无需证明，随手一交，全部爆零）

$\quad \quad$ 下面给出反证法证明：

$\quad \quad$ 假设最后序列中存在某一个正数 $x (x>1)$。（显然不会出现小于负一的负数，这里略去证明）

$\quad \quad$ 我们考虑 $x$ 前面那个数 $y$ 的情况（话说那个点没办法后移啊QAQ）：

- $\quad \quad$ $y<1$：根本不可能让 $x$ 位置上的数从原始数值变成 $x$。

- $\quad \quad$ $y=1$：显然，没有必要把 $x$ 位置上的数加到 $x$，加到 $1$所需要的操作次数一定更少。 

- $\quad \quad$ $y>1$：考虑 $y$ 的来源，递归直到转移至上面两种情况。

$\quad \quad$ 如果有一个数 $x>1$，那么在 $x$ 的位置之前一定有至少一个数字是 $1$，所以一定可以最终一定可以转移到第二种情况，若要保证决策的最优化，那么 $x$ 就不可能出现，假设得证。

$\quad \quad$ 因此，我们设立状态 $f(i,j)$ 表示当前处理完了 $i$ 个数，上一个数值为 $j$，因为 $j$ 只能取 $-1,0,1$，所以这里第二维大小只需要 $3$ 就可以了，空间&时间复杂度均线性。

$\quad \quad$ 这里有个技巧：因为方程中 $j$ 有可能是负数，所以可以把所有的  $j$ 按照 $j+1$ 处理。

$\quad \quad$ 转移有些复杂，但几乎没有思维难度，这里不详写，看代码即可。

$\quad \quad$ 初状态可以用 $f[1][d[1]+1]=0,others=INF$ 表示，末状态需要取最小值。






---

$
$

## 代码实现：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

int n, d[N], f[N][3];

int main()
{
	scanf("%d", &n);
	for(register int k = 1; k <= n; k++)
		scanf("%d", &d[k]);

	memset(f, 0x3f, sizeof(f));
	f[1][d[1] + 1] = 0;

	for(register int k = 1; k < n; k ++)
	{
		if(f[k][0] != 0x3f3f3f3f)
		{
			if(d[k + 1] == -1) f[k + 1][0] = min(f[k + 1][0], f[k][0]);
			else if(d[k + 1] == 0) f[k + 1][0] = min(f[k + 1][0], f[k][0] + 1), f[k + 1][1] = min(f[k + 1][1], f[k][0]);
			else if(d[k + 1] == 1) f[k + 1][0] = min(f[k + 1][0], f[k][0] + 2), f[k + 1][1] = min(f[k + 1][1], f[k][0] + 1), f[k + 1][2] = min(f[k + 1][2], f[k][0]);
		}
		if(f[k][1] != 0x3f3f3f3f)
			if(d[k + 1] != -1) f[k + 1][d[k + 1] + 1] = min(f[k + 1][d[k + 1] + 1], f[k][1]);
		if(f[k][2] != 0x3f3f3f3f)
		{
			if(d[k + 1] == 1) f[k + 1][2] = min(f[k + 1][2], f[k][2]);
			else if(d[k + 1] == 0) f[k + 1][2] = min(f[k + 1][2], f[k][2] + 1);
			else if(d[k + 1] == -1) f[k + 1][2] = min(f[k + 1][2], f[k][2] + 2);
		}
	}

	int minn = min(min(f[n][0], f[n][1]), f[n][2]);
	if(minn == 0x3f3f3f3f) printf("BRAK");
	else printf("%d", minn);

	return 0;
}
```



---

$
$

## 结语：

$\quad \quad$ 如果本题解有BUG，还请评论或私信作者。

---

$$ \large{END}$$

---

## 作者：jins3599 (赞：0)

很简单的线性dp。

（注意无解输出“BRAK”)

我们发现每个位置上只有三种数值可能$-1,0,1$

那我们不妨设$f(i,j)$代表，前$i$个数已经满足单调不降，第$i$个数为$j-1$时的最小步数（$j-1$是为了方便存数组。）

然后我们大力讨论一下，发现无非有下面几种情况：

### $a_i=1$ 

此时的转移如下：

- $f[i][2] = min\{f[i - 1][0] , f[i - 1][1] , f[i - 1][2]\}$

当前数是最大的，且没有变化，可以从前面三个里面随便转移。
- $f[i][1] = min\{ f[i - 1][0] + 1\}$

当前数变成了$0$，只有可能从前面为$-1$的数转移
- $f[i][0] = min\{ f[i - 1][0] + 2\}$

当前数变成了$-1$，也只可能从前面为$-1$的数转移

### $a_i=0$

此时的转移如下

- $f[i][2] = min\{f[i - 1][2] + 1\}$

当前值变为$1$，只可能是从前面的$1$加过来的。

- $f[i][1] = min\{f[i - 1][1] , f[i - 1][0]\}$

当前值仍是$0$，从前面的$0$和$-1$均可转移

- $f[i][0] = min\{f[i][0] , f[i - 1][0] + 1\}$

当前值为$-1$，只可能从前面的$-1$转移而来

### $a_i=-1$

- $f[i][2] = min\{ f[i - 1][2] + 2\}$

当前值为$1$，只可能从$1$转移而来
- $f[i][0] = min\{ f[i - 1][0]\}$

当前值为$-1$，只可能从$-1$转移而来。

此时不可能值为0，因为当值为0时，只可能从1转移而来，而0<1，因此不成立。

下面就是代码了。

$Code:$
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 1e6 + 10;

int f[N][3] , a[N] , n;

int main () {
	cin >> n;
	for(int i = 1 ; i <= n ;i ++) cin >> a[i];
	memset(f , 0x3f , sizeof(f));
	f[1][a[1] + 1] = 0;
	for(int i = 2 ; i <= n ; i ++) {
		if(a[i] == 1) {
			f[i][2] = min(f[i][2] , min(f[i - 1][0] , min(f[i - 1][1] , f[i - 1][2])));
			f[i][1] = min(f[i][1] , f[i - 1][0] + 1);
			f[i][0] = min(f[i][0] , f[i - 1][0] + 2);
		} else if(a[i] == 0) {
			f[i][2] = min(f[i][2] , f[i - 1][2] + 1);
			f[i][1] = min(f[i][1] , min(f[i - 1][1] , f[i - 1][0]));
			f[i][0] = min(f[i][0] , f[i - 1][0] + 1);
		} else {
			f[i][2] = min(f[i][2] , f[i - 1][2] + 2);
			f[i][0] = min(f[i][1] , f[i - 1][0]);
		}
	}
	int ans = min(f[n][0] , min(f[n][1] , f[n][2]));
	if(ans == 0x3f3f3f3f) puts("BRAK");
	else printf("%d\n" , ans);
	return 0;
}
```

---

## 作者：_ctz (赞：0)

[$My\ blog$](https://ctz45562.github.io/2019/04/13/%E6%B4%9B%E8%B0%B7-P3558-POI2013-BAJ-Bytecomputer/)

[传送门](https://www.luogu.org/problemnew/show/P3558)

其实没必要分类讨论。

很容易想到设$f(i,j)$表示前$i$个数满足单调不降、第$i$个数为$j$的最少操作次数。

再定义一个函数$calc(x,y,state)$表示：把$a[i-1]$可以取到的值压进$state$里（二进制下每一位依次表示能取到$-1,0,1$），$a[i]$从$x$修改为$y$的最小代价。

预处理$calc$，转移方程就能直接写成：

$f(i,j)=\min\{f(i-1,k)+calc(a[i],j,state)\}(k\le j)$（把$\min(a[i-1],k)$到$\max(a[i-1],k)$每个值加入$state$）

解释一下：枚举$a[i-1]$修改为了$k$，那么在$a[i-1]$修改的过程中会取到$\min(a[i-1],k)$到$\max(a[i-1],k)$的每个值，想用哪个值，就在它修改到这个值的时候去更新$a[i]$。

然后就是预处理$calc$了：

- 若$x=y$，$calc(x,y,state)=0$
- 若$x< y$，只要$state$能取到$1$，就有$calc(x,y,state)=y-x$
- 若$x>y$，只要$state$能取到$-1$，就有$calc(x,y,state)=x-y$
- 其他情况均为$inf$

初始状态$f(1,a[1])=0$，答案为$\min\{f(n,-1),f(n,0),f(n,1)\}$，复杂度$O(9n)$。

题面没有给范围，大概是$1e6$，无解还要输出"$BRAK$"

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 1000005

const long long inf = 4557430888798830399ll;

using namespace std;

inline int read(){
    int x=0,y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
const int S = 7;
int a[maxn]={1};
long long f[maxn][3],s[3][3][S+2];
//s是calc函数的值
void init(){
    memset(f,0x3f,sizeof f);
    memset(s,0x3f,sizeof s);
    for(register int s0=0;s0<=S;++s0)
        for(register int i=0;i<3;++i)
            s[i][i][s0]=0;//x=y
    for(register int s0=0;s0<=S;++s0)
        if(s0&1)s[2][1][s0]=s[1][0][s0]=1,s[2][0][s0]=2;//state能取到-1
    for(register int s0=0;s0<=S;++s0)
        if(s0&4)s[0][1][s0]=s[1][2][s0]=1,s[0][2][s0]=2;//state能取到1
    //预处理s
}
int main(){
    int n=read(),state;
    long long ans=inf;
    for(register int i=1;i<=n;++i)
        a[i]=read()+1;
    //防止负数下标全部+1
    init();
    f[1][a[1]]=0;
    for(register int i=2;i<=n;++i)
        for(register int j=0;j<3;++j)
            for(register int k=0;k<=j;++k){
                state=0;
                for(register int p=min(a[i-1],k);p<=max(a[i-1],k);++p)
                    state|=1<<p;
                f[i][j]=min(f[i][j],f[i-1][k]+s[a[i]][j][state]);
            }
    ans=min(f[n][0],min(f[n][1],f[n][2]));
    if(ans==inf)puts("BRAK");
    else printf("%lld\n",ans);
}

```



---

## 作者：zhenglier (赞：0)

# 记忆化搜索

~~记搜真好用~~

本题使用记忆化搜索可以避免复杂的dp过程。

设读入数列为$a$

为了使状态中没有负数，我们把所有读入的数$+1$。(下文为了方便说明省略该步骤)

记一个数组$dp[i][-1/0/1]$表示当前数为-1/0/1时使后面所有串都能符合要求的最小步数。下面进行分类。

1.当前值为$1$时，为了使序列单调不降，接下来的数一定会是$1$,可以用方程
$$dp[i][1]=dp[i+1][1]+1-a[i+1]$$转移。

2.当前值为$0$时，该数无法影响后面的数，转移方程为
$$dp[i][0]=dp[i+1][a[i+1]]$$

3.当前值为$-1$时。这是最麻烦的情况，要继续对$a[i+1]$分类:
- 若$a[i+1]==-1$,为了维护不降，不能继续操作，转移方程为

$$dp[i][-1]=dp[i+1][-1]$$
- 若$a[i+1]==0$，可操作一次或者不操作，转移方程为

$$dp[i][0]=min(dp[i+1][-1]+1,dp[i+1][0])$$
- 若$a[i+1]==1$,可操作一次、两次，或者不操作，转移方程为

$$dp[i][1]=min(dp[i+1][-1]+2,dp[i+1][0]+1,dp[i+1][1])$$

方程推出来后，直接一波记搜就可以过了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1000010];
int dp[1000010][3];
int dfs(int l,int now){
	if(l==n)return 0;
	if(~dp[l][now])return dp[l][now];
	int ans=1e9;
	if(now==2){
		ans=2-a[l+1]+dfs(l+1,2);
	    return dp[l][now]=ans;
	}
	if(now==1){
		if(a[l+1]==0){
			return 1e9;
		}
		ans=dfs(l+1,a[l+1]);
		return dp[l][now]=ans;
	}
	if(now==0){
		if(a[l+1]==2){
			ans=min(ans,2+dfs(l+1,0));
			ans=min(ans,1+dfs(l+1,1));
			ans=min(ans,dfs(l+1,2));
		}
		if(a[l+1]==1){
			ans=min(ans,1+dfs(l+1,0));
			ans=min(ans,dfs(l+1,1));
		}
		if(a[l+1]==0){
			ans=min(ans,dfs(l+1,0));
		}
        return dp[l][now]=ans;
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;++i)scanf("%d",a+i),a[i]++;
	memset(dp,-1,sizeof dp);
	int ot=dfs(1,a[1]);
	if(ot==1e9)puts("BRAK");
	else cout<<ot<<endl;
}
```


---

## 作者：Huami360 (赞：0)

这题交了十几次（到现在还有点懵），来写份题解吧

###DP
##dp [ i ] [ j ] 表示第i位为j的最少次数，或者说前i个数最后一位为j的最少次数

枚举i，和第i-1位的j，再枚举i位的j(用k表示)

这里用a[i]表示读入的第i个数，方便起见，直接将每个数加上2

初始把整个dp数组赋为INF，把dp [ 1 ] [ a [ 1 ] ] 赋为 0

如果a[i]==k，那么dp [ i ] [ k ] = min ( dp [ i ] [ k ] , dp [ i - 1 ] [ j ] )

如果a[i] > k , 那么只有当j==-1时，dp [ i ] [ k ] 这个状态才可能存在 ， dp [ i ] [ k ] = min ( dp [ i ] [ k ] , dp [ i - 1 ] [ j ] + a [ i ] - k )

如果a[i] < k , 那么只有当j==1时，dp [ i ] [ k ] 这个状态才可能存在 ， dp [ i ] [ k ] = min ( dp [ i ] [ k ] , dp [ i - 1 ] [ j ] - a [ i ] + k )

最后对dp [ n ] [ 1~3 ] 取最大值即可

[丑陋的代码](http://blog.csdn.net/u013095699/article/details/78441238)


---


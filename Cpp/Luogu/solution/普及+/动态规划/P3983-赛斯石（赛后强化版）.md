# 赛斯石（赛后强化版）

## 题目背景

```cpp
白露横江，水光接天，纵一苇之所如，凌万顷之茫然。——苏轼
```
真程海洋近来需要进购大批赛斯石，你或许会问，什么是赛斯石？

首先我们来了解一下赛斯，赛斯是一个重量单位，我们用$ si $作为其单位。比如$ 1 $赛斯就是$ 1si $。

而赛斯石有这样一个性质，它本来是一赛斯一赛斯单独存在的，但是用自然枪将其精化之后，它就会与其它经过精化的赛斯石进行合并，合并到合适的重量之后，便将其钝化，使其不再合并其它赛斯石，如果合错了，也可以用金刚刀将其切开（神奇的是你只能切成整数赛斯重量）。赛斯石的重量只能是**整数**赛斯重量，而不同赛斯重量的赛斯石的价格也是不一样的。


## 题目描述

现需上市$ Need $赛斯重量的赛斯石，卖家想算出这些赛斯石经过某种合并方式来获得的最大收益。然而目前有一个问题，市场在真程大殿附近（真程海洋中心位置），卖家需要租船送赛斯石过去（即不考虑卖家自己租船过去的费用），目前有十种船可以租，载重量从$ 1si $到$ 10si $，每艘船的租价也是有所不同的，如下表所示：

 ![](https://cdn.luogu.com.cn/upload/pic/10663.png) 

由于真程大殿附近有强烈的赛斯力，导致**无法对赛斯石进行任何操作**，商家将赛斯石运过来之后就只能按照之前合并好的卖。假设卖家不返回，且这些赛斯石全部能卖出去。现在卖家他要计算总盈利（设总盈利=赛斯石的总收益-租船所需总费用），请你设计一个程序，算出一种最佳方案，以获得**最大总盈利**。


## 说明/提示

### 样例一说明：

将$ 11 $个单位赛斯石合并为一个$ 4si $的赛斯石和一个$ 7si $的赛斯石并且租两个载重分别为$ 4si $和$ 7si $的船，这样做为最佳方案，那么最大总盈利就是$ 32 $元。

### 注意：

对于所有输入数据，均在区间$ (0, 100000) $中，并且为整数；

保证卖家最大总盈利为正；

同一行中，每两个数据之间有一个空格。

赛后强化版于$ 2020 $年$ 10 $月$ 13 $日$ 19 $点$ 18 $分已强化完毕。


## 样例 #1

### 输入

```
11
1 6 11 17 23 27 33 35 38 43```

### 输出

```
32```

## 样例 #2

### 输入

```
7
1 5 14 18 20 28 31 34 39 42```

### 输出

```
21```

# 题解

## 作者：惠存xs (赞：27)

# P3983 赛斯石
# 赛斯石（赛后强化版）


## 题目描述

现需上市$ Need $赛斯重量的赛斯石，卖家想算出这些赛斯石经过某种合并方式来获得的最大收益。然而目前有一个问题，市场在真程大殿附近（真程海洋中心位置），卖家需要租船送赛斯石过去（即不考虑卖家自己租船过去的费用），目前有十种船可以租，载重量从$ 1si $到$ 10si $，每艘船的租价也是有所不同的，如下表所示：

 ![](https://cdn.luogu.com.cn/upload/pic/10663.png) 

由于真程大殿附近有强烈的赛斯力，导致**无法对赛斯石进行任何操作**，商家将赛斯石运过来之后就只能按照之前合并好的卖。假设卖家不返回，且这些赛斯石全部能卖出去。现在卖家他要计算总盈利（设总盈利=赛斯石的总收益-租船所需总费用），请你设计一个程序，算出一种最佳方案，以获得**最大总盈利**。

-------------------
### 思路
* 这题如果从石头出发来考虑，会发现船会很难处理。因此换个角度思考，可以看出每个船的最大收益是容易计算的。所以我们可以先处理出每艘船的最大收益（一个完全背包），最后只需求出怎样租船收益最高即为答案（将船的最大收益看作价值，所载石头的质量即为代价，依旧是一个完全背包）。
* 因为不同质量的石头的价值都为正数，所以要想船的收益最大，那必然要使船装满，因此每艘船的代价即为能承载石头的最大质量。

附上代码
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll f[20],n,m,a[20],v[20]={0,1,3,5,7,9,10,11,14,15,17};//v数组储存租每艘船的费用
ll dp[100010],ans;
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=10;i++) scanf("%lld",&a[i]);
    for(int i=1;i<=10;i++)
    	for(int j=i;j<=10;j++)
    		f[j]=max(f[j-i]+a[i],f[j]);//计算每艘船的最大总收益
    for(int i=1;i<=10;i++) f[i]=f[i]-v[i];//相减即为最大净收益
    for(int i=1;i<=10;i++)
    	for(int j=i;j<=n;j++)
    	dp[j]=max(dp[j-i]+f[i],dp[j]);//计算答案
    for(int i=1;i<=n;i++) ans=max(ans,dp[i]);
    cout<<ans<<endl;
    return 0;
}
```
蒟蒻的第一篇题解，有什么错误还请各位大佬指出

---

## 作者：issue_is_fw (赞：12)

Ⅰ.

物品可以拆开来但船不能拆开来。

如载重7的船，可以装$3si$和$4si$，也可以装$1si$和$6si$。

所以$1$−$10$载重船的最大收益完全可以用背包求出来

Ⅱ.

最后一定是选一些船走，而船的收益已经固定。

所以用完全背包求出质量为n时的最大收益。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n;
ll b[12]={0,1,3,5,7,9,10,11,14,15,17};
ll a[12],f[12],dp[100009];
int main()
{
	cin>>n;
	for(int i=1;i<=10;i++)	cin>>a[i];
	for(int i=1;i<=10;i++)
	{
		for(int j=i;j<=10;j++)
			f[j]=max(f[j],f[j-i]+a[i]);//总重量为j时最大收益 
	}
	for(int i=1;i<=10;i++)	f[i]-=b[i];
	for(int i=1;i<=10;i++)
	{
		for(int j=i;j<=n;j++)
			dp[j]=max(dp[j],dp[j-i]+f[i]);
	}
	cout<<dp[n];
}
```


---

## 作者：fanxingzhi (赞：5)

**思路**

刚学完 $01$ 背包、完全背包的同学，拿到这题肯定是懵的。

进来看题解后，发现更懵，虽然大牛的代码都很短，但好难理解啊。

背包题这么难吗，很受打击。

言归正传，往下看定会豁然开朗。

一看就是背包题，但怎么才能套入背包的模型里去：

前 $i$ 种规格的石头卖出 $j$ 重量，能实现的最大盈利？

很容易想到这个，但费用怎么处理？

这才是本题的关键，搞定这个问题，那就是一道基础背包题。

看船费数据，不同规格的石头找到对应载重的船运走似乎不是最优的选择，似乎有些石头可以选择拼船会更省钱。

于是我们想，如果题目规定石头只能自己一个石头单独乘坐一条船，不能拼船，那就好了。

直接把不同规格的石头的价值减去对应的船费就是盈利了，
然后递推前 $i$ 种规格的石头，卖出 $j$ 重量能实现的最大盈利，轻松搞定。

但是题目并没有这样规定。

不过，我们惊喜地发现，除了少量几个规格的石头存在拼船更便宜，大部分都是自己一块石头一条船就是最省钱的啦。

大胆设想：能否自己新创几个规格出来，题目里只有 $10$ 种规格的石头，重量分别是 $1-10$，价值也各有不同。

那我们把拼船更便宜的那个几个石头进行打包，整出几个新的规格：

$2$ 和 $5$ 搞组合，变成第 $11$ 号规格的石头，重量为 $7$，价值自己去算。

$3$ 和 $4$ 搞组合，变成第 $12$ 号规格的石头，重量为 $7$，价值自己去算。

$4$ 和 $5$ 搞组合，变成第 $13$ 号规格的石头，重量为 $9$，价值自己去算。

$5$ 和 $5$ 搞组合，变成第 $14$ 号规格的石头，重量为 $10$，价值自己去算。
   
看到这里应该会了吧；递推前 $i$ 种规格的石头，卖出 $j$ 重量能实现的最大盈利，记得每个规格的石头的盈利要先减去对应的船费。

以样例 $2$ 为例，人脑运行一下：
   
   当运行到前 $7$ 个规格的时候，$dp[n]$ 等于 $20$ (因为选择 $7$ 号规格就是最大盈利，当然 $3$ 和 $4$ 的组合也是 $20$）。
   
   再运行到前 $11$ 个规格的时候，$dp[n]$ 不会有变化，因为 $2$ 号规格和 $5$ 号规格的石头价值之和减去 $7$ 号船的费用还是不超过 $20$。虽然省了 $1$ 块钱运费，但因为他们本身的价值不够高，省的一块钱没起到作用。
   
   再运行到前 $12$ 个规格的时候，因为 $3$ 号规格和 $4$ 号规格的石头价值之和减去 $7$ 号船的费用是 $21$，超过了原来的最高值，省下的那一块钱起到了决定性作用。
   
   这就是新创几个新规格的作用了。当他们几个单独坐船的盈利之和能跟别人打成平手（从给定的船费看，拼船最多也就剩 $1$ 块钱）的时候，他们就可以通过拼船省下钱，从而可能影响到最终的选择。

看到这里应该没必要再往下看了吧，不过还是整上代码吧，毕竟是第一次写题解：



**代码**

 ```c
#include <iostream>
using namespace std; 
int fy[11]={0,1,3,5,7,9,10,11,14,15,17}; //不同载重量船的费用。
int val[21];  //不同规格的石头的价值。
int w[21];   //不同规格的石头的重量。
int n;
long long dp[100005];
int main()
{
   cin>>n;
   for(int i=1;i<=10;i++)
   {
     cin>>val[i]; //输入 10 种不同规格的石头的价值（没减船费前）
     w[i]=i; //把 10 种不同规格的石头的重量数据存入 w 数组。 
   }
   //手打记录 4 种新规格石头的重量及价值（同时操作减船费，价值变成了盈利）。 
   w[11]=2+5; val[11]=val[2]+val[5]-fy[7];
   w[12]=3+4; val[12]=val[3]+val[4]-fy[7];
   w[13]=4+5; val[13]=val[4]+val[5]-fy[9];
   w[14]=5+5; val[14]=val[5]+val[5]-fy[10];
   
   for(int i=1;i<=10;i++)
      val[i]=val[i]-fy[i];
      //前 10 种规格的石头的价值减去船费，变成盈利。 

   for(int i=1;i<=14;i++)
      for(int j=w[i];j<=n;j++)
         dp[j]=max(dp[j],dp[j-w[i]]+val[i]);

   cout<<dp[n];
   return 0;
}
```



---

## 作者：Exber (赞：4)

## 做法
一道很巧妙的完全背包题。

由于一条船可以装多个塞斯石，而一个塞斯石无法用多条船装，所以每种载重的船的最大收益一定是固定的，可以先把它预处理好。

可以用 $w_i$ 来表示一艘载重为 $i$ 的船的最大收益。那么状态转移方程便是：$w_i=\max(w_{j-i}+a_i|10\ge j\ge i)$（$a_i$ 表示 $i$ $si$ 塞斯石的价值）。

由于这样递推出来的 $w$ 数组并没有考虑租船的费用，所以需要再将 $w_i$ 减去 $v_i$（$v_i$ 表示租一艘载重为 $i$ 的船所需要花费的价值）。

最后由于每种载重的船的最大收益固定，并且一种载重的船可以租很多艘，所以可以把船的载重看成物品的代价，把租船的收益看成价值，整个问题便转化成了对每种载重的船求一次完全背包。

最后注意一定要开 ```long long```。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int need,v[15]={0,1,3,5,7,9,10,11,14,15,17},a[15];
long long w[15],dp[15][100005]; // 记得开 long long 

int main()
{
	scanf("%d",&need);
	for(int i=1;i<=10;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=10;i++)
	{
		for(int j=i;j<=10;j++)
		{
			w[j]=max(w[j],w[j-i]+a[i]); // 求 w_i 
		}
	}
	for(int i=1;i<=10;i++)
	{
		w[i]-=v[i]; // 减去船的租价 
	}
	for(int i=1;i<=10;i++) // 10 种船 
	{
		for(int j=1;j<=need;j++)
		{
			dp[i][j]=dp[i-1][j];
			if(j>=i)
			{
				dp[i][j]=max(dp[i][j],dp[i][j-i]+w[i]); // 完全背包的状态转移，把载重看成代价，把收益看成价值 
			}
		}
	}
	printf("%lld\n",dp[10][need]);
	return 0;
}
```


---

## 作者：Maxliu (赞：2)

实际上这个题可以完全加强到船费也跟着变然后两次DP的啊...

在这里给出一种比较暴力的$DP$做法

直接把价值设成市场价减去船费完全背包的话第二个样例就会$GG$

然后观察到除了$2+5=7,3+4=7,4+5=9,5+5=10$这四种组合会出幺蛾子（两个一块上船比单独上船优）之外，其他的都是选择分开坐船更优

因此把这四种情况作为新物品加到背包里面，就可以通过这道题了

下面是蒟蒻丑到不行的代码QAQ

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
int n,m,f[100005],b[20];//b数组存最终价值 
int cost[15]={0,1,2,3,4,5,6,7,8,9,10,7,7,9,10};//cost存耗费石头数 
int a[15]={0,-1,-3,-5,-7,-9,-10,-11,-14,-15,-17,-11,-11,-15,-17};//a存船费 
signed main(){
	n=14;
	memset(f,-0x3f3f3f,sizeof(f));//初始化 
	f[0]=0;
	scanf("%lld",&m);
	for(int i=1;i<=10;i++){
		scanf("%lld",&b[i]);//输入价格 
	}
	b[11]+=b[3]+b[4];//3+4=7 
	b[12]+=b[5]+b[2];//2+5=7 
	b[13]+=b[4]+b[5];//4+5=9 
	b[14]+=b[5]+b[5];//5+5=10 
	for(int i=1;i<=n;i++) a[i]+=b[i];
	for(int i=1;i<=n;i++){
		for(int j=cost[i];j<=m;j++){
			f[j]=max(f[j],f[j-cost[i]]+a[i]); 
		}
	}
	printf("%lld",f[m]);//答案 
	return 0;
}
```


---

## 作者：XY_ATOE (赞：2)

好了，我把数组开大了一点，现在不越界了ORZ
------------
已AFO蒟蒻回归。偶然发现这个题目加强数据了。试了试之前的代码，果然WA了一片。

很不爽啊，，，，

仔细一看，原来是可以通过石头的合并来获取更高利润的，比如说1赛斯的石头价值为3，2赛斯的石头价值为4，而3赛斯的石头价值为5，所以在卖出三赛斯石头的时候，可以通过卖出一个1赛斯，卖出一个2赛斯获取7，当然更可以通过卖出三个3赛斯获取9。

问题很显然了，还缺一个DP，来组合成最大的价值。

luogu越来越好了，资瓷luogu
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#define re register
using namespace std;
inline long long read()
{
    long long f=1,p=0;
    char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
    return f*p;
}
int n;
long long s[101]={0,1,3,5,7,9,10,11,14,15,17};
long long c[101],a[101],f[200100];
int main()
{
    n=read();
    for(int i=1;i<=10;i++)a[i]=read();
    for(int i=1;i<=10;i++)
        for(int j=1;j<=i;j++)
            a[i+j]=max(a[i+j],a[i]+a[j]);
    for(int i=1;i<=10;i++)a[i]-=s[i];
    memset(f,-0x3f3f,sizeof(f));
    f[0]=0;
    for(int i=0;i<=n;i++)
        for(int j=1;j<=10&&j+i<=n;j++)
            f[i+j]=max(f[i]+a[j],f[i+j]);
    cout<<f[n];
    return 0;
}
```

---

## 作者：I_m_FW (赞：1)

## 完全背包
-------为什么要用完全背包？为什么完全背包可以优化？

我们先看完全背包的模板题：[模板题](https://www.luogu.com.cn/problem/P1616)，更好的阅读体验：[链接](https://xbwsb.blog.luogu.org/solution-p3983)

朴素转移方程

$f[i][j]=\max(..,f [i - 1][j - k \times w [i]] + v [i] \times k);$

为什么可以优化？
我们可以由上述柿子得出：

$f[i-1][j]=\max(....,f [i - 2][j - (k - 1) \times w [i - 1]] + v [i - 1] \times (k - 1));$

#### 发现可以作差？？？
所以：

$f[i][j]=\max(f [i - 1][j],f [i][j - w[i]] + v [i]);$

那么为什么这个题可以完全背包~~不能01背包吗~~？？
注意！！！
### 可能大小为k的赛斯石不如大小和为k的m个赛斯石划算！！！！

同理：一条船可以装多个塞斯石
### 但是

一个塞斯石无法用多条船装
so：完全背包！！！
同时你也需要处理每个船所用的最大利润
```
for(int i=1;i<=10;i++){
		for(int j=i;j<=10;j++){
			w[j]=max(w[j],w[j-i]+v[i]);
		}
	}
	for(int i=1;i<=10;i++)w[i]-=ww[i];
```
代码：


```
#include <bits/stdc++.h>
using namespace std;
const int N=110,M=100010;
int ww[11]={0,1,3,5,7,9,10,11,14,15,17};
long long v[N],n,f[M],w[N];
int main(){
	cin>>n;
	for(int i=1;i<=10;i++){
		scanf("%d",&v[i]);
	}
	for(int i=1;i<=10;i++){
		for(int j=i;j<=10;j++){
			w[j]=max(w[j],w[j-i]+v[i]);
		}
	}
	for(int i=1;i<=10;i++)w[i]-=ww[i];
	for(int i=1;i<=10;i++)
		for(int j=i;j<=n;j++){
			f[j]=max(f[j],(long long)f[j-i]+w[i]);
		}
	int ans=0;
	cout<<f[n];
}

f[i][j]=max(f[i-1][j],f[i][j-w[i]]+v[i]);

```


---

## 作者：苏景曦 (赞：1)


```cpp
#include<bits/stdc++.h>
using namespace std;            //以上不解释
long long solution[100001]={0};      //储存最佳
long long fei[11]={0,1,3,5,7,9,10,11,14,15,17};         //用于存租价
int a[11]={0};                   //用于输入售价
int main()
{
    int t;cin>>t;
    for(int i=1;i<=10;i++)
    {
    cin>>a[i];                                      //以上为输入
    solution[i]=a[i]-fei[i];                  //初始化solution
    }
    for(int i=1;i<=t;i++)
     for(int j=1;j<=10;j++)
       if(i-j>=1)                                           
       {
           solution[i]=max(solution[i],solution[i-j]+solution[j]);                //状态转移方程
       }
    if(t<=10)
    { 
        cout<<solution[t]+1;                 
    }
    else cout<<solution[t];                                     //输出
    return 0;
}
//赛斯石是一个很好理解的动规

//相信大家能看懂



---

## 作者：Acerkaio (赞：0)

- ## 题面
[题面](https://www.luogu.com.cn/problem/P3983)。
- ## 思路
1. 考察要点：**DP**。
1. 我们可以先把所有单位重量赛斯石算出。
1. 然后减去载这其中一个单位的船底的价钱，即算出了各个单位的石头过河的耗费。每种载重的船的最大收益一定是固定的，可以先把它预处理好。
1. 可以通过石头的合并来获取更高利润，所以要搭配，把这些数据跑一下完全背包求出最大的理论。

注意要开 long long 哦。
- ## CODE
```
main() {
	cin>>n;
	for(register int i=1; i<=10; i++) {
		cin>>a[i];
	}
    		/*↓过把所有单位重量赛斯石算出↓*/
	for(register int i=1; i<10; i++) { 
		for(register int j=1; j<=i; j++)
			a[i+j]=max(a[i+j],a[j]+a[i]);
	}
        	/*↓算出了各个单位的石头过河的耗费↓*/
	for(register int i=1; i<=10; i++) {
		a[i]-=b[i];
	}
	memset(dp,-16191,sizeof(dp));
	dp[0]=0;
    		/*↓把这些数据跑一下背包↓*/
	for(register int i=0; i<=n; i++) {
		for(register int j=1; j<=10&&i+j<=n; j++) {
			dp[i+j]=max(dp[i+j],dp[i]+a[j]);
		}
	}
	cout<<dp[n]<<"\n";
}
```
求过 qwq

---

## 作者：CANTORSORT (赞：0)

众所周知，赛斯石是一种 **可分割的** ~~神奇~~玩意儿。

因此，我们可以用 **完全背包** 预处理 $N$ 塞斯的石头 **最多能卖多少钱**。

接着，我们要考虑 **租船费用**。

由于题目中已经给出了 $10$ 种船的费用，所以——

**让我们愉快地打表吧！ ~~(手动滑稽~~**

$$cost=\{1,3,5,7,9,10,11,14,15,17\}$$

于是，我们就可以让 $1\sim 10$ 赛斯的价值总和 **减去** $cost$。

最后，我们 **重新再跑一次 完全背包**，即可得出答案。

~~双重完全背包yyds(bushi~~

## Code:

```
#include<bits/stdc++.h>
#define int long long //不用管这个玩意儿(
using namespace std;
int n,a[11],cost[11]={0,1,3,5,7,9,10,11,14,15,17},val[11],dp1[100005],dp2[100005];
void DEBUG() //调试用的函数
{
	puts("");
	for(int i=1;i<=10;i++)
		printf("%lld ",val[i]);
	puts("");
	for(int i=1;i<=n;i++)
		printf("%lld ",dp1[i]);
	exit(0);
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=10;i++)
		scanf("%lld",a+i);
	for(int i=1;i<=10;i++) //完全背包求钱数
	{
		for(int j=i;j<=n;j++)
			dp1[j]=max(dp1[j],dp1[j-i]+a[i]);
	}
//	DEBUG();
	for(int i=1;i<=10;i++) //减去费用
		dp1[i]-=cost[i];
	for(int i=1;i<=10;i++) //求利润
	{
		for(int j=i;j<=n;j++)
			dp2[j]=max(dp2[j],dp2[j-i]+dp1[i]);
	}
	printf("%lld",dp2[n]);
	return 0;
}
```

---

## 作者：Link_Space (赞：0)

我们可以很快发现题目中一个明显的性质：用一艘船装一样的东西会比一艘船同时装两样东西更优，这个性质你可以通过观察题中租船价目表得出。

然后我就直接开做了，把物品价值减去刚好能载走该物品的船只的运费作为新价值，而该物品的重量则作为花费，跑一遍完全背包就好了。

可是我很快发现样例都过不了，于是我仔细手模了租船价目表，发现如果有两个物品的重量分别为 $(2,5)$ 或 $(3,4)$ 或 $(4,5)$ 或 $(5,5)$ ，那么把这两个物品合成一个物品装在一艘船里是会更优的，所以我们只需要特判一下这四种情况，构造四个新物品然后跑一遍完全背包就可以通过此题了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define int long long
using namespace std;
const int N = 1e5 + 5;//2+5=7,3+4=7,4+5=9,5+5=10
int weight[11] = {0, 1, 3, 5, 7, 9, 10, 11, 14, 15, 17};
int val[N];
int w[N];
int dp[N];
signed main()
{
	int n;
	scanf("%lld", &n);
	for (int i = 1; i <= 10;i++)
		scanf("%lld", &val[i]), val[i] -= weight[i], w[i] = i;
	w[11] = 7, val[11] = val[2] + val[5] + weight[2] + weight[5] - weight[7];
	w[12] = 7, val[12] = val[3] + val[4] + weight[3] + weight[4] - weight[7];
	w[13] = 9, val[13] = val[4] + val[5] + weight[4] + weight[5] - weight[9];
	w[14] = 10, val[14] = val[5] + val[5] + weight[5] + weight[5] - weight[10];
	for (int i = 1; i <= 14;i++)
		for (int j = w[i]; j <= n;j++)
			dp[j] = max(dp[j], dp[j - w[i]] + val[i]);
	printf("%lld\n", dp[n]);
}
```


---

## 作者：管仲 (赞：0)

//以下是我的一点思路，给大佬见笑了
第一种解法dfs,当然只有5分
//顺便问一下哪里有问题
以下是dfs代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100],b[11]={0,1,3,5,7,9,10,11,14,15,17};
void dfs(int );
int sum1=0,maxn=-9999,sum2=0;
int main()
{    
	cin>>n;
	for(int i=1;i<=10;i++)
	cin>>a[i];
	dfs(1);
    cout<<maxn<<endl;
}
void dfs(int t)
{
	if(n==0&&(sum1-sum2)>maxn) maxn=sum1-sum2;
	for(int i=t;i<=10;i++)
	{
	if(n<i) continue;
	n-=i;
	sum1+=a[i];
	sum2+=b[i];
	dfs(t+1);
	sum2-=b[i];
	sum1-=a[i];
	n+=i;
	}
}
```
然后经过我的发现，此题巨坑无比，第二个样例似乎看上去是错的
可实际上是对的
```cpp
#include<bits/stdc++.h>
using namespace std;
int b[11]= {0,1,3,5,7,9,10,11,14,15,17},s[100];
int f[1000];
int main() {
	int n;
	cin>>n;
	for(int i=1; i<=10; i++)
	cin>>s[i];
	for(int i=1; i<=n; i++)
		for(int j=0; j<=n-i; j++) 
		{
		s[i+j]=max(s[i+j],s[i]+s[j]);
		}
	for(int i=1; i<=10; i++)
	s[i]-=b[i];
	memset(f,0,sizeof(f));
	f[0]=0;
	for(int i=0; i<=n; i++)
		for(int j=1; j<=n-i&&j<=10; j++) {
			f[i+j]=max(f[i+j],f[i]+s[j]);
		}
	cout<<f[n];
}
```

---


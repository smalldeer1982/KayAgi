# [JSOI2010] 快递服务

## 题目描述

「飞奔」快递公司成立之后，已经分别与市内许多中小企业公司签订邮件收送服务契约。由于有些公司是在同一栋大楼内，所以「飞奔」公司收件的地点（收件点）最多只有 $m$ 点（$1,2,\dots,m$），因此「飞奔」仅先行采购了三辆货车并聘用了三名司机，每天早上分别从收件地点 $1,2,3$ 出发。而在与客户的服务契约中有明确订约：「飞奔」必须在客户提出邮件寄送要求的隔天派人至该公司（地点）收件。

为了能更有效率的服务客户并节省收件时间，该公司设立了收件服务登记网站，客户如有邮件需要寄送，必须在需要收件的前一天就先上网登记。为了节省油量，「飞奔」就利用晚上先行安排三位司机隔天的收件路线。每位司机至各地点收件的顺序应与各公司上网登记的顺序相符且必须能在最省油的情况下完成当天所有的收件服务。因此每位司机有可能需要在不同时间重复到同一地点收件，或不同的司机有可能需在不同的时间点前往同一地点收件。

如下面范例二（收件公司地点依序为：`4 2 4 1 5 4 3 2 1`）所示，虽然司机 $1$ 一开始就已经在收件地点 $1$ 了，但是他却不能先把后面第四个登记的公司（地点 $1$）邮件先收了再前往第一、第二、或第三个登记收件地点（地点 $4,2,4$）收件。但是如果前三个登记收件的服务是由司机 $2$ 或 $3$ 来负责，则司机 $1$ 就可以在地点 $1$ 收了第四个登记的邮件后再前往后面所登记的地点收件。此外，在某些情况下，不一定每辆车都要收到货，也就是说，最佳收件方式也有可能是只需出动一或两辆车去收货。请写一个程序来帮「飞奔」公司计算每天依预约顺序至各收件地点收件的最少总耗油量。

### 简要题意

给定一个 $m \times m$ 的矩阵 $D$。我们规定一个序列 $a(a_0,a_1,a_2,\dots,a_n)$ 的花费为 $\sum\limits_{i=1}^{n}D_{a_{i-1},a_i}$。

现在给定你一个长度 $\leq 1000$ 的序列 $s$，请你把它分成三个子序列 $a,b,c$，并且规定 $a_0=1,b_0=2,c_0=3$，求出所有划分方案中它们的最小化费和。

特殊地，矩阵 $D$ 满足三角不等式，具体见输入格式中的详细解释。

（By El_destructor）

## 说明/提示

#### 样例解释

到每个请求收件地点的司机分别为 `1 1 1 1 3 3 2 2 2 1`，因此司机 $1$ 只需从起使点 $1$ 移动到地点 $3$，司机 $2$ 只需停留在地点 $2$，司机 $3$ 从起始点 $3$ 移动到地点 $4$。

#### 数据范围

$3 \leq m \leq 200,1 \leq s_i \leq m$。

## 样例 #1

### 输入

```
4 
0 5 0 6 
6 0 5 6 
1 6 0 6 
1 1 1 0 
1 1 1 1 4 4 2 2 2 3 ```

### 输出

```
6```

# 题解

## 作者：Iscream2001 (赞：7)

又是一道没题解的题目。。。

于是补一个题解。。。

首先O(m^3* 任务个数 )的dp很简单。。

只要dp[i][j][k]表示第一个人在i，第二个人在j，第三个人在k的最小费用，外面再按照任务顺序枚举就好。。。

但这样显然是跑不过的。。。

发现完成第x个任务的时候，三个人中至少有一个在p[x]上，p[x]表示第x个任务的位置。。。

所以数组只用开两维，f[i][j]表示第一个人在i，第二个人在j，另一个所在位置就是上一个上一个任务的位置。。。

枚举第x个任务，状态转移方程就显然了，具体可以看程序。。。

最后效率就是O(m^2* 任务个数)，就可以通过了

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define LL long long
using namespace std;
const LL inf=1e18;
int n,m;
int p[1050];
LL mp[210][210],f[210][210],t[210][210];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			scanf("%lld",&mp[i][j]);
	for(int i=1;i<=n;++i) mp[i][i]=0;
	p[0]=3;m=1;
	while(scanf("%d",&p[m])!=EOF)++m;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j) 
			f[i][j]=t[i][j]=inf;
	f[1][2]=0;
	for(int k=1;k<=m;++k){
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j) 
				t[i][j]=inf;
		for(int i=1;i<=n;++i){
			for(int j=1;j<=n;++j){
				if(f[i][j]==inf) continue;
				t[i][j]=min(t[i][j],f[i][j]+mp[p[k-1]][p[k]]);
				t[p[k-1]][j]=min(t[p[k-1]][j],f[i][j]+mp[i][p[k]]);
				t[i][p[k-1]]=min(t[i][p[k-1]],f[i][j]+mp[j][p[k]]);
			}
		}
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j) 
				f[i][j]=t[i][j];
	}
	LL ans=inf;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			ans=min(ans,f[i][j]);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：BzhH (赞：5)

这道题其实和[SP703 SERVICE - Mobile Service](https://www.luogu.com.cn/problem/SP703)一样

看到这到题,很容易想到一种定义状态的方式$f[i][x][y][z]$表示完成前$i$个请求,三个人的位置分别在$x,y,z$,但很明显如果这么定义会超空间,所以想办法减掉一位,因为完成请求必须要有一个人在请求发生的位置,那么,我们就可以用当前完成的第$i$个请求来推出其中一个人的位置,所一这个状态就可变成$f[i][x][y]$,b表示完成前$i$个请求时,其中两个人分别在$x,y$,接下来考虑怎么转移状态,如果我们从前面的状态来推当前的状态,需要考虑许多种情况,所以我们就用当前状态来更新下一个状态


------------
然后是状态转移方程，因为有三个员工,那么我们可以考虑,下面三种情况

在当前请求的位置的人去

$f[i + 1][x][y] = min(f[i + 1][x][y], f[i][x][y] + c[p[i]][p[i+1]])$

在$x$位置的员工去

$f[i + 1][p[i]][y] = min(f[i + 1][p[i]][y], f[i][x][y]+c[x][p[i + 1]])$

在$y$位置的员工去

$f[i + 1][x][p[i]] = min(f[i + 1][x][p[i]], f[i][x][y]+c[y][p[i + 1]])$

得出状态转移方程,这到题就基本解决了,但如果你直接这么定义,对于这到题会超空间,所以考虑滚动数组优化,对于每一个状态,它只和它的前一个状态有关,所以我们可以把数组的第一位压缩为两维

附代码

```
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;

int f[2][205][205];
int c[205][205], p[1005];

int main()
{
    int l;
    scanf("%d", &l);
    for (int i = 1; i <= l;i++)
    {
        for (int j = 1; j <= l;j++)
        {
            int a;
            scanf("%d", &a);
            c[i][j] = a;
        }
    }
    int n = 0;
    while(scanf("%d", &p[++n])!=EOF);
    memset(f, 0x3f, sizeof(f));
    f[0][1][2] = 0;
    p[0] = 3;
    for (int i = 0; i < n;i++)
    {
        memset(f[i + 1 & 1], 0x3f, sizeof(f[i + 1 & 1]));
        for (int x = 1; x <= l;x++)
        {
            for (int y = 1; y <= l;y++)
            {
                if(x==p[i]||x==y||y==p[i])
                    continue;
                f[i + 1 & 1][p[i]][y] = min(f[i + 1 & 1][p[i]][y], f[i & 1][x][y] + c[x][p[i + 1]]);
                f[i + 1 & 1][x][p[i]] = min(f[i + 1 & 1][x][p[i]], f[i & 1][x][y] + c[y][p[i + 1]]);
                f[i + 1 & 1][x][y] = min(f[i + 1 & 1][x][y], f[i & 1][x][y] + c[p[i]][p[i + 1]]);
            }
        }
    }
    int ans = 0x3f3f3f3f;
    for (int i = 1; i <= l;i++)
        for (int j = 1; j <= l;j++)
        {
            if(i==j||i==p[n]||j==p[n])
                continue;
            ans = min(ans, f[n & 1][i][j]);
        }    
    printf("%d", ans);
}
```


---

## 作者：hhhhyq (赞：4)

本题~~一眼看出~~是一道DP题，我们可以~~很容易~~得出状态和方程

* 状态：令$f_{i,j,k,l}$表示当前枚举到了第$i$个地点，三位司机分别在$j,k,l$三处地点

* 转移
$$f_{i,j,k,a_{i}}=min(f_{i,j,k,a_{i}},f_{i-1,j,k,l}+val_{l,a_{i}})$$
$$f_{i,j,a_{i},l}=min(f_{i,j,a_{i},l},f_{i-1,j,k,l}+val_{k,a_{i}})$$
$$f_{i,a_{i},k,l}=min(f_{i,a_{i},k,l},f_{i-1,j,k,l}+val_{j,a_{i}})$$
* 边界条件：$f_{0,1,2,3}=0$


~~好了我们就做完了，散了吧散了吧~~

上面这样显然是不行的，我们来想办法**优化**

~~可以通过大喊老司机带带我触发常数变0.00001特效，水过这个题~~

------------
### ！！！Optimization:

* 我们考虑删除无用状态:对于一个时刻$i$必须**有且仅有**一个司机在上一个位置$pos_{i-1}$（我们记位置为$pos$）因此当我们枚举第几个地点时，其中一个司机的位置已知，可以少枚举一维

* 省掉一维后，内存还是不够，怎么办呢，~~滚！~~当然是开滚动数组啊

* 优化后的边界：$(f_{0,1,2}=0,a_{0}=3)or(f_{0,2,3}=0,a_{0}=1)or(f_{0,1,3}=0,a_{0}=2)$ 
------------

_Code:_
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
#define M(a) memset(a,0,sizeof(a))
#define inf (long long)1e18
using namespace std;

const int maxn=201;

typedef long long ll;

ll read(){
	char ch=getchar();int res=0,f=1;
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();} 
	while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
	return res*f;
}

ll f[2][maxn][maxn];
int m,n,t;
ll ans;
ll c[maxn][maxn];
int pos[maxn*10];

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			c[i][j]=read();
		}
	} 
	
	m=0;int p;
	while(cin>>p){
		pos[++m]=p;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			f[0][i][j]=f[1][i][j]=inf;
		}
	}
	int lst=0,now=1;
	f[lst][1][2]=0;
	pos[0]=3;
	for(int t=1;t<=m;t++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				f[now][i][j]=inf;
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++)if(f[lst][i][j]!=inf&&i!=j&&i!=pos[t-1]&&j!=pos[t-1]){//三车位置：i，j，pos[t-1] 
				if(i!=pos[t]&&j!=pos[t])f[now][i][j]=min(f[now][i][j],f[lst][i][j]+c[pos[t-1]][pos[t]]);
				if(j!=pos[t])f[now][pos[t-1]][j]=min(f[now][pos[t-1]][j],f[lst][i][j]+c[i][pos[t]]);
				if(i!=pos[t])f[now][i][pos[t-1]]=min(f[now][i][pos[t-1]],f[lst][i][j]+c[j][pos[t]]);
			}
		}
		lst=1-lst,now=1-now;
	}
	ans=inf;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			ans=min(ans,f[lst][i][j]);
		}
	}
	printf("%lld\n",ans); 

}
```

---

## 作者：Yang818 (赞：2)

## 题目背景

这是一道 CEOI 2005 年的一道题，被 JS 省抄成了2010年的省选。。。

## 分析

本蒟蒻先用贪心写了一遍，然后自己发现了错，因为前面一步不可能推出这一步的走法，因为它不具备最优子结构的，你不知道下一步会发生什么。然后觉得可以用背包。我们来写一下方程。


## 方程

首先肯定要把三个司机的位置放进去

### 过去时： 
$f(i,x,y,z)$

然后我们发现过去时可能有 $200 \times 3 = 600$  种可能，肯定时间要爆表，来，试试未来时：

### 未来时：   
$f(i,x,y,z)=min(f(i+1,f[i+1],y,z),f(i+1,x,f[i+1],z),f(i+1,x,y,t[i+1]))$

现在只有 $300$ 种可能了，肯定要用未来时但是肯定有冗余，看看程序里是怎样消除的。

## 程序
```cpp
#include<bits/stdc++.h>
using namespace std; 
int k,n,c[205][205],t[2005],f[2][205][205];
int main(){
	cin>>k;
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++){
			cin>>c[i][j];
		}
	}
	int n=0;
	int a=0;
	while(cin>>t[++n]);//Dev-C++按ctrl+z表示接受
	n--;
	t[0]=1;//别忘记初始化，建立虚拟订单 
	for(int i=n-1;i>=0;i--){
		for(int x=1;x<=k;x++){
			for(int y=x+1;y<=k;y++){
				if(x==t[i] || y==t[i]){
					f[i&1][x][y]=1e7;
					continue;
				}
				int tmp1=f[(i+1)&1][x][y]+c[t[i]][t[i+1]];
				int tmp2=(t[i]<y)?f[i+1&1][t[i]][y]+c[x][t[i+1]]:f[i+1&1][y][t[i]]+c[x][t[i+1]];
				int tmp3=(t[i]<x)?f[i+1&1][t[i]][x]+c[y][t[i+1]]:f[i+1&1][x][t[i]]+c[y][t[i+1]];
				f[i&1][x][y]=min(tmp1,min(tmp2,tmp3));
			}
		}
	}
	cout<<f[0][2][3]<<endl;
	return 0;
}
```
望通过，谢谢


---

## 作者：VioletIsMyLove (赞：2)

$F[i][x][y][z]$ 表示序列枚举到第 $i$ 个位置,司机 $1$ 在 $x$ 位置，司机 $2$ 在 $y$ 位置，司机 $3$ 在位置 $z$ ，发现无论时限还是空间都不行；


再静下心来思考，发现 $3$ 人肯定有一个是待在上次拿件的位置(显然要有一个去把这个活干了啊)，故就可以少一维度
 $F[i][x][y]$ 示序列枚举到第 $i$ 个位置,司机 $1$ 在 $x$ 位置，司机 $2$ 在 $y$ 位置，司机 $3$ 在上一个拿件的位置 $z=A[i-1]$ ,最后再滚动数组就OK
 
 Code:
 ```cpp

#include<bits/stdc++.h>
#define maxn 205
#define maxm 1005
using namespace std;
int n,m,c[maxn][maxn],a[maxm];
long long ans=((long long)1<<62);
long long F[2][maxn][maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();}
	while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
    n=read();
    for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++)
       c[i][j]=read();
    int x;
    while(scanf("%d",&x)==1){a[++m]=x;}
    memset(F,127,sizeof F);
    F[0][1][2]=0;a[0]=3;
    for (int i=1;i<=m;i++){
    	int z=a[i-1];
    	memset(F[i&1],127,sizeof F[i&1]);
        for (int x=1;x<=n;x++)
        for (int y=1;y<=n;y++){
            if (x==y||x==z||y==z) continue;
            if (x!=a[i]&&y!=a[i]) F[i&1][x][y]=min(F[i&1][x][y],F[1-i&1][x][y]+c[z][a[i]]);
            if (x!=a[i]&&z!=a[i]) F[i&1][x][z]=min(F[i&1][x][z],F[1-i&1][x][y]+c[y][a[i]]);
            if (y!=a[i]&&z!=a[i]) F[i&1][y][z]=min(F[i&1][y][z],F[1-i&1][x][y]+c[x][a[i]]);
        }
    }
    for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++){
    	if (i==j) continue;
        ans=min(ans,F[m&1][i][j]);
    }
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：红色OI再临 (赞：1)


[双倍经验](https://www.luogu.org/problem/SP703)

先从高维dp开始考虑

`f[i][x][y][z]`表示当前第`i`个任务，第一个员工在`x`，第二个在`y`，第三个在`z`

则有：

$f[i+1][p[i+1]][y][z]=min(f[i][x][y][z]+c[x][p[i+1]]$

$f[i+1][x][p[i+1]][z]=min(f[i][x][y][z]+c[y][p+1])$

$f[i+1][x][y][p[i+1]]=min(f[i][x][y][z]+c[z][p[i+1]])$

思维难度不高，但时间空间复杂度巨大

然后可以发现这个题的一个性质，每次做任务后一定有一个员工停在`p[i]`处，所以就可以优化

设`f[i][x][y]`表示完成`i`个目标，两个人停在x,y位置，另一个人停在`p[i]`

$f[i+1][x][y]=min(f[i][x][y]+c[p[i]][p[i+1]])$

$f[i+1][p[i]][y]=min(f[i][x][y]+c[x][p[i+1]])$

$f[i+1][x][p[i]]=min(f[i][x][y],c[y][p[i+1]])$

考虑`i+1`的状态只会从`i`的状态转移而来，所以可以用滚动数组，上面的式子注意判断条件

初值$f[0][1][2]=0,a[0]=3$

滚动数组优化的话，每次清空(i+1)&1的状态，即把它全部赋为0x3f，以免算出来什么不满足条件的东西

但这样做[常数很大](https://www.luogu.org/discuss/show/141455)
然而能开的下还是开吧
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register int
#define maxn 201
using namespace std;
int f[2][maxn][maxn],n,m,c[1001][1001],a[1001];
int ans;
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		ans=0x3f3f3f3f;
		scanf("%d%d",&n,&m);
		for(re i=1;i<=n;i++)
			for(re j=1;j<=n;j++)
				scanf("%d",&c[i][j]);
		for(re i=1;i<=m;i++)
			scanf("%d",&a[i]);
		memset(f,0x3f,sizeof(f));
		f[0][1][2]=0;a[0]=3;
		for(re i=0;i<m;i++){
			memset(f[(i+1)&1],0x3f,sizeof(f[(i+1)&1]));
			for(re x=1;x<=n;x++)
				for(re y=1;y<=n;y++){
					int z=a[i];
					if(x==y||x==z||y==z)continue;
					if(x!=a[i+1]&&y!=a[i+1])f[(i+1)&1][x][y]=min(f[(i+1)&1][x][y],f[i&1][x][y]+c[z][a[i+1]]);
					if(x!=a[i+1]&&z!=a[i+1])f[(i+1)&1][x][z]=min(f[(i+1)&1][x][z],f[i&1][x][y]+c[y][a[i+1]]);
					if(y!=a[i+1]&&z!=a[i+1])f[(i+1)&1][y][z]=min(f[(i+1)&1][y][z],f[i&1][x][y]+c[x][a[i+1]]);

				}
}
			for(re i=1;i<=n;i++)
				for(re j=1;j<=n;j++){
					if(i==j)continue;
					ans=min(ans,f[m&1][i][j]);
				}
		
			printf("%d\n",ans);
		
	}


	return 0;
}
```


---

## 作者：Jμdge (赞：1)

这题**是什么鬼，多一维数组就成了大常数，少一维就AC了？

头一回听到空间卡时间的。

（萌新求教，访问有这么慢的么？）

---
好的进入正文


>>肉眼观察得出这题是 dp

>>那么我们首先考虑裸的暴力转移

>>暴力转移的话，就是 $O( n \times m^{3}) $ 去枚举当前step， 以及上一次三辆车的位置

>>然后这样大概是 $60\  plus $（常数小的话...）

>>那么我们考虑进一步优化 

>>于是肉眼得出: 其实上一次三辆车的位置有一辆不用枚举，就是上次任务要去的位置，而当前位置同理，只需要管好剩下两辆车不要翻就好了，这样我们就可以把复杂度里面的一个 m 给去掉了，然后复杂度就正确了。（其实不难想啊...）

>>对，时间复杂度。因为我智障般的还是开了三维数组，其中 n 一维滚掉。然后 T 掉了。~~怕不是有毒。~~

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int inf=1e9+7;
const int M=205;
inline void cmin(int& a,int b){if(a>b)a=b;}
int n,m,x,y,ans=inf,d[M][M],f[2][M][M];
int main(){
	freopen("express10.in","r",stdin);
	scanf("%d",&n),
	memset(f,0x3f,sizeof(f));
	#define rint register int
	for(rint i=1;i<=n;++i)
		for(rint j=1;j<=n;++j)
			scanf("%d",&d[i][j]);
	rint w=1,h=0;
	if(~scanf("%d",&y)){
		cmin(f[1][1][2],d[3][y]),
		cmin(f[1][1][3],d[2][y]),
		cmin(f[1][2][3],d[1][y]);
	} else return !puts("0");
	for(;~scanf("%d",&x);y=x){ w^=1,h^=1;
		for(rint i=1;i<=n;++i)
			for(rint j=1;j<=n;++j)
				f[w][i][j]=inf;
		for(rint i=1;i<=n;++i) for(rint j=1;j<=n;++j)
			cmin(f[w][i][j],f[h][i][j]+d[y][x]),
			cmin(f[w][i][y],f[h][i][j]+d[j][x]),
			cmin(f[w][j][y],f[h][i][j]+d[i][x]);
	}
	for(rint i=1;i<=n;++i)
		for(rint j=1;j<=n;++j)
			cmin(ans,f[w][i][j]);
	return !printf("%d\n",ans);
}
```


---

## 作者：Utsuji_risshū (赞：1)

讲讲这题楼上下没有题的卡常技巧，因为这题写不好可能会被卡。

$f[i][j][k]$表示第$i$个命令后一个人在$j$，另一个在$k$，还有一个在哪你懂得。（其实这里是一个状态精简，第三个人的状态没必要留，因为可以知道）。于是每个操作枚举上一次两个人分布位置，排除一下站同一位置的，三个人里面选一个推过来。状转的话看code里面三行好了。

上面是基本解法

## EFFECTIVE SKILLS

比较卡常。~~其实吸氧即可。~~ 细节优化：

- $f[2][N][N]$滚动。基本操作，优化空间。另外，在这题里面（或者说很多题中）可以顺便优化时间，清INF的操作就可以不用了。原理是每次枚举i^1的两个人位置的时候由于这两个人位置状态枚举掉后不会再看了，而下一次再用i^1这一维的时候有要求有初始最大值方便更新，所以我现在推完立即就把i^1这一维设为INF。下次就不清INF了。时间就会极大减少。注意顺带清INF操作放在判断(line 32 in code)外面（其实是因为不想去想重叠的情况什么的了，统统初始化算了）
- 枚举j和k时，可以缩小范围，只枚举j<k的情况，枚举数量少一半。

然后轻松刷榜rank1。~~其实我也吸了氧~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define dbg(x) cerr<<#x<<" = "<<x<<endl
using namespace std;
typedef long long ll;
template<typename T>inline char MIN(T&A,T B){return A>B?A=B,1:0;}
template<typename T>inline char MAX(T&A,T B){return A<B?A=B,1:0;}
template<typename T>inline T _min(T A,T B){return A<B?A:B;}
template<typename T>inline T _max(T A,T B){return A>B?A:B;}
template<typename T>inline T read(T&x){
    x=0;int f=0;char c;while(!isdigit(c=getchar()))if(c=='-')f=1;
    while(isdigit(c))x=x*10+(c&15),c=getchar();return f?x=-x:x;
}
const int N=200+2,M=1000+2,INF=0x3f3f3f3f;
int dis[N][N],p[M],f[2][N][N];
int m=1,n,ans;

int main(){//freopen("test.in","r",stdin);//freopen("test.out","w",stdout);
    read(n);
    for(register int i=1;i<=n;++i)for(register int j=1;j<=n;++j)read(dis[i][j]);
    while(~scanf("%d",&p[m]))++m;--m;
    memset(f,INF,sizeof f);ans=INF;
    f[1][1][2]=dis[3][p[1]],f[1][1][3]=dis[2][p[1]],f[1][2][3]=dis[1][p[1]];
    for(register int i=2,l=0;i<=m;++i,l^=1){
        for(register int j=1;j<n;++j)
            for(register int k=j+1;k<=n;++k){
                if((j^p[i-1])&&(k^p[i-1])){
                    MIN(f[l][j][k],f[l^1][j][k]+dis[p[i-1]][p[i]]);
                    p[i-1]<k?MIN(f[l][p[i-1]][k],f[l^1][j][k]+dis[j][p[i]]):MIN(f[l][k][p[i-1]],f[l^1][j][k]+dis[j][p[i]]);
                    p[i-1]<j?MIN(f[l][p[i-1]][j],f[l^1][j][k]+dis[k][p[i]]):MIN(f[l][j][p[i-1]],f[l^1][j][k]+dis[k][p[i]]);
                }
                f[l^1][j][k]=INF;
            }
    }
    for(register int i=1;i<=n;++i)if(i^p[m])for(register int j=i+1;j<=n;++j)if(j^p[m])MIN(ans,f[m&1][i][j]);
    printf("%d\n",ans);
    return 0;
}
```


---


# [Code+#1] 找爸爸

## 题目描述

小 A 最近一直在找自己的爸爸，用什么办法呢，就是 DNA 比对。

小 A 有一套自己的 DNA 序列比较方法，其最终目标是最大化两个 DNA 序列的相似程度，具体步骤如下：


1. 给出两个 DNA 序列，第一个长度为 $n$，第二个长度为 $m$。

2. 在两个序列的任意位置插入任意多的空格，使得两个字符串长度相同

3. 逐位进行匹配，**如果两个序列相同位置上的字符都不是空格**，假设第一个是 $x$，第二个是 $y$，那么他们的相似程度由 $d(x,y)$ 定义。对于两个序列中任意一段极长的长度为 $k$ 的连续空格，我们定义这段空格的相似程度为 $g(k)=-A-B(k-1)$。


那么最终两个序列的相似程度就是所有的 $d(x,y)$ 加上所有的极长空格段的相似程度之和。

现在小 A 通过某种奥妙重重的方式得到了小 B 的 DNA 序列中的一段，他想请你帮他算一下小 A 的 DNA 序列和小 B 的 DNA 序列的最大相似程度。


## 说明/提示

### 样例解释

首先，将序列补成如下形式（"-"代表空格）

```cpp
ATGG--
AT--CC
```
然后所有 $d(x,y)$ 的和为 $d(A,A)+d(T,T)=10$

所有极长连续空格段的相似程度之和为 $g(2)+g(2)=-6$

总和为 $4$，可以验证，这是相似程度最大的情况。

对于所有测试点，有 $0< B<A \le 1000, -1000\le d(x,y)\le 1000,d(x,y)=d(y,x)$，序列只包含${A,T,G,C}$四种字符。

 ![](https://cdn.luogu.com.cn/upload/pic/12822.png) 

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/卢政荣 命题/卢政荣 验题/何昊天

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
ATGG
ATCC
5 -4 -4 -4 
-4 5 -4 -4 
-4 -4 5 -4 
-4 -4 -4 5 
2 1```

### 输出

```
4```

# 题解

## 作者：Elegia (赞：68)

考虑进行动态规划。


令状态`dp[i][j][k]`表示目前A串已经匹配了前$i$个字符，B串已经匹配了前$j$个字符，$k$代表是否末尾的空格位置。两个都是空格显然不是一个优解，因为把这两个都去掉就必然会使得相似度增加。

故$k$只有代表3种可能：没有空格/在A串/在B串。


如果此状态没有任何空格即$k=0$，就直接从`dp[i - 1][j - 1][]`中最大相似值转移。如果在其中一个位置，那么就要考虑到上一个空格的位置在哪，我们不妨认为每段空格的第一个需要支付$-a$的代价，后面的都需要支付$-b$的代价，就很自然地列出了方程`dp[i][j][1] = max{dp[i][j - 1][1] - b, dp[i][j - 1][0] - a, dp[i][j - 1][2] - a}`。

`dp[i][j][2]`的原理是对称的。


答案在`dp[n][m][]`中取得。


注意一些边界问题。


```cpp
#include <climits>
#include <cstdio>
#include <cstring>

#include <algorithm>

using namespace std;

typedef long long ll;

const int N = 3010;

int n, m, a, b;
int x[N], y[N], mp[256];
int d[4][4];
char s[N];

ll dp[N][N][3];

int main() {
    mp['A'] = 0;
    mp['T'] = 1;
    mp['G'] = 2;
    mp['C'] = 3;
    scanf("%s", s + 1);
    n = strlen(s + 1);
    for (int i = 1; i <= n; ++i)
        x[i] = mp[s[i]];
    scanf("%s", s + 1);
    m = strlen(s + 1);
    for (int i = 1; i <= m; ++i)
        y[i] = mp[s[i]];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            scanf("%d", &d[i][j]);
    scanf("%d%d", &a, &b);
    for (int i = max(n, m); i; --i) {
        dp[0][i][0] = dp[i][0][0] = dp[0][i][2] = dp[i][0][1] = -(1LL << 60);
        dp[0][i][1] = dp[i][0][2] = -a - b * (i - 1);
    }
    dp[0][0][1] = dp[0][0][2] = -(1LL << 60);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) {
            dp[i][j][0] = *max_element(dp[i - 1][j - 1], dp[i - 1][j - 1] + 3) + d[x[i]][y[j]];
            dp[i][j][1] = max(max(dp[i][j - 1][0] - a, dp[i][j - 1][1] - b), dp[i][j - 1][2] - a);
            dp[i][j][2] = max(max(dp[i - 1][j][0] - a, dp[i - 1][j][2] - b), dp[i - 1][j][1] - a);
        }
    printf("%lld\n", *max_element(dp[n][m], dp[n][m] + 3));
    return 0;
}
```

---

## 作者：K2sen (赞：33)

update at 10.27 纠正了一点小错误。
### 思路
我们令 $f_{i,j,k}$ 表示 A 串匹配了 i 个， B 串匹配了 j 个，最后一个空格的位置为 k，所产生的最大价值。

我们可以看出最后一个空格的位置可以取 4 种情况。
- 在 A 串后边加空格
- 在 B 串后边加空格
- 在 A,B 串后边都加
- 在 A,B 串后边都不加

可以发现，因为题目中给出的 a,b 都是非负数，所以如果都加上空格的话价值会减去一个非负数。这种情况下，一定是不加更优，所以我们只考虑另外的三种情况。

我们令 k=0,1,2 分别表示，都不加空格，在 A 后边加空格，在 B 后边加空格。

那么转移方程就很显然了。
- $f_{i,j,0} = max\{f_{i-1,j-1,0},f_{i-1,j-1,1},f_{i-1,j-1,2} \} + d_{x_i,y_j}$ 
- $f_{i,j,1} = max\{f_{i,j-1,1} - b,f_{i,j-1,0}-a,f_{i,j-1,2} - a\}$
- $f_{i,j,2} = max\{f_{i-1,j,2} - b,f_{i-1,j,0}-a,f_{i-1,j,1} - a\}$


$f_{i,j,0}$ 是两边都不加空格，显然是从上次的三个中取最大值，然后加上现在这个位置的价值。

$f_{i,j.1}$ 是在 A 后加空格，他 $f_{i.j-1,1}$ 的时候可以根据转移方程看出是在 A 串上放的空格，所以我们 -b。在 $f_{i,j-1,0}$ 的时候两个都没有放，所以减去 a ，$f_{i,j-1,2}$ 的时候是在 B 上放的空格，所以我们减去 a 就行了。

$f_{i,j,2}$ 的时候与上述类似，不再赘述。

### code
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
#define N 100010
#define M 3010

using namespace std;
const int mod = 1e9+7;
const int inf = 0x3f3f3f3f;
char s1[M], s2[M];
int n, m, a, b, x[M], y[M], d[M][M], f[M][M][3];

int read() {
  int s = 0, f = 0; char ch = getchar();
  while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
  while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
  return f ? -s : s;
}
int pd(char s) {
  if (s == 'A') return 1;
  else if (s == 'T') return 2;
  else if (s == 'G') return 3;
  else return 4;
}
signed main() {
  cin >> s1 >> s2;
  for (int i = 1; i <= 4; i++)
    for (int j = 1; j <= 4; j++)
      d[i][j] = read();
  a = read(), b = read();
  n = strlen(s1), m = strlen(s2);
  for (int i = 1; i <= n; i++) x[i] = pd(s1[i - 1]);
  for (int i = 1; i <= m; i++) y[i] = pd(s2[i - 1]);
  for (int i = max(n, m); i; --i) {
    f[0][i][0] = f[i][0][0] = f[0][i][2] = f[i][0][1] = -(1LL << 60);
    f[0][i][1] = f[i][0][2] = - a - b * (i - 1);
  }
  f[0][0][1] = f[0][0][2] = -(1LL << 60);
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
      f[i][j][0] = max(f[i - 1][j - 1][0], max(f[i - 1][j - 1][1], f[i - 1][j - 1][2])) + d[x[i]][y[j]];
      f[i][j][1] = max(f[i][j - 1][1] - b, max(f[i][j - 1][0] - a, f[i][j - 1][2] - a));
      f[i][j][2] = max(f[i - 1][j][2] - b, max(f[i - 1][j][0] - a, f[i - 1][j][1] - a));
    }
  cout << max(f[n][m][0], max(f[n][m][1], f[n][m][2]));
}
```

---

## 作者：Mark_ZZY (赞：12)

```cpp
#include<cstdio>
#include<cstring>
#define max(x,y) (x)>(y)?(x):(y)
#define MAX(x,y,z) (max(max((x),(y)),(z)))
	char s1[3001],s2[3001];
	int P[5][5];
	int f[3001][3001][4];
	/*
	f[i][0]表示s1,s2串都以字母结尾的最优解
	f[i][1]表示s1以空格结尾,s2以字母结尾的最优解
	f[i][2]表示s1以字母结尾,s2以空格结尾的最优解
	易证,都已空格结尾一定不是最优解,g(k)=-A-B(k-1)(A,B都为正整数),g(k)则为负数,不会增加最优解 
	*/
	int n,m,A,B;
int work(char ch)
{
	switch(ch)
	{
		case 'A':return 1;
		case 'T':return 2;
		case 'G':return 3;
		case 'C':return 4;
	}
}
int main()
{
	freopen("dnaseq.in","r",stdin);
	freopen("dnaseq.out","w",stdout);
	scanf("%s",s1+1);
	n=strlen(s1+1);
	scanf("%s",s2+1);
	m=strlen(s2+1);
	for(int i=1;i<=4;i++)
		for(int j=1;j<=4;j++)
			scanf("%d",&P[i][j]);
	scanf("%d %d",&A,&B);
	memset(f,-63,sizeof(f));
	f[0][0][0]=0;
	for(int i=0;i<=n;i++)
		for(int j=0;j<=m;j++)
		{
			if(i+j==0) continue;
			int t1=work(s1[i]),t2=work(s2[j]);
			if(i!=0&&j!=0) f[i][j][0]=P[t1][t2]+MAX(f[i-1][j-1][0],f[i-1][j-1][1],f[i-1][j-1][2]);
			if(j!=0) f[i][j][1]=MAX(f[i][j-1][0]-A,f[i][j-1][1]-B,f[i][j-1][2]-A);
			if(i!=0) f[i][j][2]=MAX(f[i-1][j][0]-A,f[i-1][j][1]-A,f[i-1][j][2]-B);
		}
	printf("%d",MAX(f[n][m][0],f[n][m][1],f[n][m][2]));
}
```

---

## 作者：风羽跃 (赞：9)

来一波四个维度的 DP 数组。

先化解一个误区：所谓插入若干个空格，就是匹配到相应位置时可以用字母也可以用空格，不要当成插入来做。

DP 有三要素：先确定**阶段**，再确定**状态**，最后根据**决策**写出方程。

分析一下三要素：

1. 阶段：两个数组分别匹配了几位（注意这里是匹配了几个字母，不算空格。因为当前状态我们只关心匹配了几个字母，前面究竟匹配了几个空格并不会对后面的答案产生影响）；

2. 状态：首先想到用 $f(i,j)$ 表示分别匹配了 $i$ 位和 $j$ 位，然后我们分析一下空格相似度 $g(k)=-A-B(k-1)$，发现**在一段连续的空格中，加第一个空格只需要相似度减 $A$，此后连续空格长度每增加 1，相似度就要减 $B$，因此状态需要同时记录一下末尾是否为空格**。用 $f(i,j,0/1,0/1)$ 表示A、B分别匹配了 $i$、$j$ 位，其中当前匹配的 $A$ 末尾是空格/字母，$B$ 末尾是空格/字母时的最大相似度；

3. 决策：
	1. 由原来的 $A$ 末尾是空格，$B$ 末尾字母转移过来；
   2. 由原来的 $A$ 末尾是字母，$B$ 末尾空格转移过来；
   3. 由原来的 $A$、$B$ 末尾都是字母转移过来。
   
状态转移方程分类讨论即可，不再赘述（$d(i,j)$ 表示 $A$ 序列中的第 $i$ 个字母和 $B$ 序列中的第 $j$ 个字母的相似度)：

1. $f[i][j][0][1]=\max(f[i][j-1][0][1]-B,f[i][j-1][1][1]-A,f[i][j-1][1][0]-A)$；

2. $f[i][j][1][0]=\max(f[i-1][j][1][0]-B,f[i-1][j][1][1]-A),f[i-1][j][0][1]-A)$；

3. $f[i][j][1][1]=\max(f[i-1][j-1][1][1],f[i-1][j-1][1][0],f[i-1][j-1][0][1])+d(i,j)$。

AC代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>

#define maxn 3005
#define INF 0x3f3f3f3f

using namespace std;

int n,m,a,b;

string A,B;

int f[maxn][maxn][2][2];
int d[5][5];

inline int num(char ch)
{
	if(ch=='A') return 1;
	if(ch=='T') return 2;
	if(ch=='G') return 3;
	if(ch=='C') return 4;
}

int main()
{
	memset(f,0xcf,sizeof(f));
	cin>>A>>B;
	n=A.length(),m=B.length();
	A=' '+A,B=' '+B;
	for(int i=1;i<=4;i++){
		for(int j=1;j<=4;j++){
			cin>>d[i][j];
		}
	}
	cin>>a>>b;
	f[0][0][1][1]=0;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			if(j) f[i][j][0][1]=max(max(f[i][j-1][0][1]-b,f[i][j-1][1][1]-a),f[i][j-1][1][0]-a);
			if(i) f[i][j][1][0]=max(max(f[i-1][j][1][0]-b,f[i-1][j][1][1]-a),f[i-1][j][0][1]-a);
			if(i&&j) f[i][j][1][1]=max(max(f[i-1][j-1][1][1]+d[num(A[i])][num(B[j])],f[i-1][j-1][1][0]+d[num(A[i])][num(B[j])]),f[i-1][j-1][0][1]+d[num(A[i])][num(B[j])]); 
		}
	}
	cout<<max(f[n][m][0][1],max(f[n][m][1][0],f[n][m][1][1]))<<endl;
	return 0;
}
```


---

## 作者：花园Serena (赞：8)

刚看到题以为是状压 dp ？事实证明我确实是个弱鸡。

首先这道题目我们先把字符串转化成数字，方便以后计算，并设状态 $f_{i,j,k}$ ， i 和 j 表示当前匹配到字符串 A 的第 i 位与字符串 B 的第 j 位，k表示字符串后面是否有空格，因为对于连续的空格的相似度的计算可以看作第一个空格贡献为 -a  而后面的空格贡献为 -b ，所以我们只需要判断上一个即当前已经匹配好的字符串的末尾是否为空格即可， $k = 0$ 表示当前已匹配的字符串的末尾没有空格， $k = 1$ 与 $k = 2$ 分别表示字符串 A 与字符串 B 的末尾有空格，可以很清晰的看到，我们设的状态中是不包括 A 与 B 的末尾同时出现有空格的， 因为 a 与 b 都是非负数而两个同时出现空格我们把他们删去明显要更优。

那么我们考虑如何转移，首先我们枚举 i 和 j ，对于每个 i 和 j 我们有 3 种选择，如下

1.  直接匹配，那么选择 $f_{i - 1, j - 1, k}$ 中的最大值并加上 $d(A_i, B_j)$。

1. 在 B 后加上一个空格，那么选择 $f_{i,j - 1, k}$ 中加上空格的贡献的最大值，因为当 $k = 1$ 时 B 串末尾已经有一个空格，所以我们只需要减去一个 b，而其他情况则需减去 a ，因为此时 B 串末尾并没有空格。

1. 在 A 后加上一个空格，这个情况和上一个是类似的，就不再赘述

初始化  $f_{0, i, 1} = f_{i, 0 ,2} = -a - b \times (i - 1)$ 表示全是空格的情况。$f_{0,i,0}, f_{i, 0, 0}, f_{0,i,2}, f_{i, 0, 1}$ 均赋值为负无穷。

下为代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define R register int
const int MAXN = 3000 + 5;
char A[MAXN], B[MAXN];
int f[MAXN][MAXN][5], d[5][5];
int x[MAXN], y[MAXN], a, b;
void inline pro (char ch[], int w[]) {
    int len = strlen (ch + 1);
    for(R i = 1; i <= len; i ++) {
        if(ch[i] == 'A') w[i] = 1;
        else if(ch[i] == 'T') w[i] = 2;
        else if(ch[i] == 'G') w[i] = 3;
        else w[i] = 4; 
    }
}
signed main()  {
    scanf("%s%s", A + 1, B + 1);
    int n = strlen(A + 1), m = strlen(B + 1);
    for(R i = 1; i <= 4; i ++)
        for(R j = 1; j <= 4; j ++)
            scanf("%lld", &d[i][j]);
    pro(A, x); pro(B, y);
    scanf("%lld%lld", &a, &b);
    for(R i = 1; i <= max(n, m); i ++) {
        f[0][i][0] = f[i][0][0] = f[0][i][2] = f[i][0][1] = -0x7fffffff;
        f[0][i][1] = f[i][0][2] = - a - b * (i - 1);
    }
    f[0][0][1] = f[0][0][2] = -0x7fffffff;
    for(R i = 1; i <= n; i ++)
        for(R j = 1; j <= m; j ++) {
            f[i][j][0] = max(max(f[i - 1][j - 1][0], f[i - 1][j - 1][1]), f[i - 1][j - 1][2]) + d[x[i]][y[j]];
            f[i][j][1] = max(max(f[i][j - 1][1] - b, f[i][j - 1][0] - a), f[i][j - 1][2] - a);
            f[i][j][2] = max(max (f[i - 1][j][2] - b, f[i - 1][j][0] - a), f[i - 1][j][1] - a);
        }
    printf("%lld\n", max(max(f[n][m][0], f[n][m][1]), f[n][m][2]));
    return 0;
}
```
若有疑问或错误，欢迎在评论与私信中指出

---

## 作者：HerikoDeltana (赞：5)

# P4059 [ Code+#1 ] 找爸爸

算是一道比较好想的线性 DP。

## 题意简述

给你两个字符串，求它们的最大相似程度，你可以用**添加空格**的方法去改变这两个字符串的相似程度。

添加空格后要保证两个字符串长度相等。

相似程度的计算方式如下：

1. 若两个字符串的第 $\texttt{i}$ 位都为字母，那么按照题目给出的 $\texttt{d}$ 进行计算。

2. 否则，设空格的长度为 $\texttt{k}$，则有计算公式 $g(k)=-A-B(k-1)$。

## 思路简述

看到数据范围之后实际上就可以放心的开三维数组来进行 $\texttt{DP}$。

我们对结尾空格的存在情况进行分类：

设 $f(i,j,p)$ 代表**当第一个字符串匹配到第 $\texttt{i}$ 位，第二个字符串匹配到第 $\texttt{j}$ 位时**的状态，$\texttt{p}$ 代表结尾空格的归属，有如下几种情况：

1. 两个字符串结尾**都无空格**，$\texttt{k}=0$。

2. 只有第一个字符串结尾有空格，$\texttt{k}=1$。

3. 只有第一个字符串结尾有空格，$\texttt{k}=2$。

4. 两个字符串结尾**都有空格**，$\texttt{k}=3$。

分类之后，先别急着去想转移方程，我们先来看看这四种情况是否都能够给我们带来最优解。

实际上判断依据就是去看这四种情况在转移状态时能不能产生更优的解。

前三种的正确性是显然的，手模一下就可以出来，这里就不再详细阐述，在这里主要来看一下第四种，即两个字符串结尾**都有空格**的情况。

我们考虑到题目要求的是填补完空格之后两个字符串的长度一样。

也就是说，同时去掉这两个空格后同样能够满足题目的要求。

于是相比这种更少空格的情况，两个字符串结尾都有空格的时候我们要多算一个 $g(k)$，由于空格的长度 $\texttt{k}$ 一定是大于 $0$ 的，所以我们只需要考虑 $A$ 和 $B$ 的正负。

注意到，题目数据范围是 $0< B < A \le 1000$，也就是说 $A$ 和 $B$ 恒大于 $0$，于是 $g(k)=-A-B(k-1)$ 就恒小于 $0$。

于是我们可以发现上面所述的第四种情况是不能给我们带来更优的方案的，所以我们可以直接排除掉这种情况。

少了一种情况之后，状态转移方程就变的非常清晰。因为我们设计的是三维的方程，所以我们只需要利用相应情况的方程进行转移即可：

$$
\begin{cases}f(i,j,0)=\max\{f(i-1,j-1,0),f(i-1,j-1,1),f(i-1,j-1,2)\}+d(i,j) \\ f(i,j,1)=\max\{f(i,j-1,0)-A,f(i,j-1,1)-B,f(i,j-1,2)-A\} \\ f(i,j,2)=\max\{f(i-1,j,0)-A,f(i-1,j,1)-A,f(i-1,j,2)-B\}\end{cases}
$$

最后我们的答案显然是 $ans=\max\{f(n,m,0),f(n,m,1),f(n,m,2)\}$

但是先别急着去写，我们还要考虑边界条件，因为两个字符串是等价的，所以我们只需要考虑一个即可，在下面我就以第一个为例。

实际上考虑我们设计的状态的话，比较好得出其中一组边界状态应当是 $f(i,0,p)\ ,i\in[1,n]\ ,p\in\{0,1,2\}$，其中我们把 $p=0$ 和 $p=1$ 两种情况赋值负无穷，$p=2$ 时则将其赋值为 $-A-B(i-1)$。

另一组就是 $f(0,0,1)$ 和 $f(0,0,2)$，它们的初值都是负无穷。

然后我们的思路就讲完了，上代码罢。

## Code

```cpp
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <string.h>
#define Heriko return
#define Deltana 0
#define S signed
#define LL long long
#define R register
#define I inline
#define CI const int
#define mst(a, b) memset(a, b, sizeof(a))
#define ON std::ios::sync_with_stdio(false)
using namespace std;

template<typename T>
I void fr(T &x)
{
    short f=1;
    char c=getchar();
    x=0;
    while(c<'0' or c>'9')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while (c>='0' and c<='9') 
    {
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    x*=f;
}

template<typename T>
I void fw(T x,bool k)
{
    if(x<0) putchar('-'),x=-x;
    static short stak[35];
    short top=0;
    do
    {
        stak[top++]=x%10;
        x/=10;
    }
    while(x);
    while(top) putchar(stak[--top]+'0');
    if(k) putchar('\n');
    else putchar(' ');
}

template<typename T>
I T hmax(T x,T y)
{
    Heriko x>y?x:y;
}

CI MXX=3010,INF=998244353;

int D[5][5],n,m,a1[MXX],a2[MXX],f[MXX][MXX][3],A,B,ans=-INF;

char s1[MXX],s2[MXX];

I void CtI()
{
    for(R int i=1;i<=n;++i)
        if(s1[i]=='A') a1[i]=1;
        else if(s1[i]=='T') a1[i]=2;
        else if(s1[i]=='G') a1[i]=3;
        else if(s1[i]=='C') a1[i]=4;
    for(R int i=1;i<=m;++i)
        if(s2[i]=='A') a2[i]=1;
        else if(s2[i]=='T') a2[i]=2;
        else if(s2[i]=='G') a2[i]=3;
        else if(s2[i]=='C') a2[i]=4;
}

I void Pre()
{
    for(R int i=1;i<=n;++i) f[i][0][1]=f[i][0][0]=-INF,f[i][0][2]=-A-B*(i-1);
    for(R int i=1;i<=m;++i) f[0][i][1]=f[0][i][0]=-INF,f[0][i][2]=-A-B*(i-1);
    f[0][0][1]=f[0][0][2]=-INF;
}

S main()
{
    scanf("%s\n%s",s1+1,s2+1);
    n=strlen(s1+1);m=strlen(s2+1);
    for(R int i=1;i<=4;++i)
        for(R int j=1;j<=4;++j)
            fr(D[i][j]);
    fr(A),fr(B);
    CtI();Pre();
    for(R int i=1;i<=n;++i)
        for(R int j=1;j<=m;++j)
        {
            f[i][j][0]=hmax(f[i-1][j-1][0],hmax(f[i-1][j-1][1],f[i-1][j-1][2]))+D[a1[i]][a2[j]];
            f[i][j][1]=hmax(f[i][j-1][0]-A,hmax(f[i][j-1][1]-B,f[i][j-1][2]-A));
            f[i][j][2]=hmax(f[i-1][j][0]-A,hmax(f[i-1][j][1]-A,f[i-1][j][2]-B));
        }
    ans=hmax(ans,hmax(f[n][m][0],hmax(f[n][m][1],f[n][m][2])));
    fw(ans,1);
    Heriko Deltana;
}
```

## End

审核大大辛苦~

---

## 作者：Su_Zipei (赞：5)


应该算是比较基础的一个$DP$，看到$n,m$的范围都在能开的下数组的范围内，果断开一个$f[i][j]$的数组表示一个串考虑到$i$位另一个串考虑到$j$位，但是发现空格没有办法处理，如果加上末尾连续空格的长度则又要加上一维，时间复杂度有点。。。。。

所以应该将空格的长度转化为贡献，即如果前边有一个空格，那么空格的贡献是$-B$否则为$-A$，所以将定义改为$f[i][j][0/1][0/1]$，后边两维表示放没放空格，转移的时候考虑放字符还是放空格然后分别转移即可，写方程的时候才发现这个定义其实有些冗余，因为两个串的某个位置不可能都同时放空格，但是对时间复杂度影响不大，所以就没改。

不过要注意一下初始化，应该将数组都赋成负无穷，$f[0][0][0][0]=0$，不然某个位置上放空格的贡献转移不了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=3100;
int d[10][10],f[N][N][2][2];
char s1[N],s2[N];
int a[N],b[N];
int main(){
	memset(f,-0x3f,sizeof(f));
	scanf("%s%s",s1+1,s2+1);
	int n=strlen(s1+1),m=strlen(s2+1);
	for(int i=1;i<=n;i++){
		if(s1[i]=='A')a[i]=1;
		if(s1[i]=='T')a[i]=2;
		if(s1[i]=='G')a[i]=3;
		if(s1[i]=='C')a[i]=4;
	}
	for(int i=1;i<=m;i++){
		if(s2[i]=='A')b[i]=1;
		if(s2[i]=='T')b[i]=2;
		if(s2[i]=='G')b[i]=3;
		if(s2[i]=='C')b[i]=4;
	}
	for(int i=1;i<=4;i++)
	for(int j=1;j<=4;j++)
		scanf("%d",&d[i][j]);
	int A,B;
	scanf("%d%d",&A,&B);
	f[0][0][0][0]=0;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			if(i)f[i][j][0][1]=max(f[i-1][j][0][0]-A,max(f[i-1][j][0][1]-B,f[i-1][j][1][0]-A));
			if(j)f[i][j][1][0]=max(f[i][j-1][0][0]-A,max(f[i][j-1][0][1]-A,f[i][j-1][1][0]-B));
			if(i&&j)f[i][j][0][0]=max(f[i-1][j-1][0][0],max(f[i-1][j-1][0][1],f[i-1][j-1][1][0]))+d[a[i]][b[j]];
		}
	}
	printf("%d\n",max(f[n][m][0][0],max(f[n][m][0][1],f[n][m][1][0])));
	return 0;
}

```

---

## 作者：pitiless0514 (赞：3)



## 题目大意：

有两个字符串。你可以往里面任意一个字符串内的任意位置加空格使得两字符串长度相等，然后字符串有相似度，让你求这两个字符串的最大相似程度。

## 题解：
思路都很相似，对于这种 DP ，我们采用主要是要将讨论情况给分类出来。

在字符串上首先确定顺序和倒序，然后考虑用末尾来作为一个状态分类点。

对此题我们的解决方案是按照字符串末尾是空格还是字母来进行分类。

我们可以设立状态 $f[i][j][k]$ 表示当前 $\operatorname{A}$ 串匹配到了第 $\operatorname{i}$ 位， $\operatorname{B}$ 串匹配到了第 $\operatorname{j}$ 位 ，末尾是否为空格，是 $\operatorname{A}$ 的空格，还是 $\operatorname{B}$ 的空格。

发现两个都为空格时一定不是一个优解，所以去掉对两个空格的讨论，有三种情况。

状态转移方程为:

$f[i][j][0]=\max(f[i-1][j-1][0],\max(f[i-1][j-1][1],f[i-1][j-1][2]))+d[x][y]$

$ f[i][j][1]=\max(f[i][j-1][0]-a,\max(f[i][j-1][1]-b,f[i][j-1][2]-a));$

$ f[i][j][2]=\max(f[i-1][j][0]-a,\max(f[i-1][j][1]-a,f[i-1][j][2]-b));$

关于边界处理的问题，当空格与非空格比较时取极小值。当空与空进行比较时，我们要处理成 $g(i)$ 。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
template<typename T> inline void read(T &x){
	T f=1;x=0;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	x*=f;
}
const int N = 3005,INF=1e9;
int l,n,k,m;
char a[N],b[N];
int d[N][5],A,B;
int f[N][N][3];
int check(char x){
	if(x=='A') return 1;
	if(x=='T') return 2;
	if(x=='G') return 3;
	if(x=='C') return 4;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>(a+1)>>(b+1);
	n=strlen(a+1);
	m=strlen(b+1);	
	for(int i=1;i<=4;i++){
		cin>>d[i][1]>>d[i][2]>>d[i][3]>>d[i][4];
	}
	cin>>A>>B;
    for(int i=1;i<=n;i++){
		f[i][0][1]=f[i][0][0]=-INF;
		f[i][0][2]=-A-B*(i-1);
	}
	for(int i=1;i<=m;i++){
		f[0][i][2]=f[0][i][0]=-INF;
		f[0][i][1]=-A-B*(i-1);
	}
	f[0][0][1]=f[0][0][2]=-INF;
	for(int i=1;i<=n;i++){
		
		for(int j=1;j<=m;j++){
			
			int x=check(a[i]);
			int y=check(b[j]);
		//	cout<<d[x][y]<<" ";
			f[i][j][0]=max(f[i-1][j-1][0],max(f[i-1][j-1][1],f[i-1][j-1][2]))+d[x][y];
			f[i][j][1]=max(f[i][j-1][0]-A,max(f[i][j-1][1]-B,f[i][j-1][2]-A));
			f[i][j][2]=max(f[i-1][j][0]-A,max(f[i-1][j][1]-A,f[i-1][j][2]-B));

			//cout<<f[i][j][0]<<" "<<f[i][j][1]<<" "<<f[i][j][2]<<"\n";
		}
		
	}
	cout<<max(f[n][m][0],max(f[n][m][1],f[n][m][2]));
	return 0;
}
```

---

## 作者：Arghariza (赞：3)

一看就知道是 dp 。

- 设计状态：

既然要求两个 DNA 序列相似程度的最大值，就设 dp 数组代表的值为当前状态两个 DNA 序列最大相似程度。

由于不知道空格在哪里，于是我们有一维状态表示当前末尾是否有空格。显然由于两个序列如果都是空格会平白无故地减小相似程度，所以要不这两个序列其中有一个有空格，要不两个都没有空格。

因为有了空格，所以我们又不知道当前状态 $a$ 串和 $b$ 串匹配到了哪里，于是我们的第二和第三维表示当前 $a,b$ 串匹配到的位置。

所以我们的状态就出来了：

**$dp_{i,j,k}$ 表示 $a$ 串匹配到第 $i$ 位、 $b$ 串匹配到第 $j$ 位、末尾没有空格或者 $a$ 串末尾有空格或者 $b$ 串末尾有空格的最大相似程度**

所以 $k$ 有三种可能，这里用 $0$ 表示没有空格， $1$ 表示 $a$ 串末尾的空格， $2$ 表示 $b$ 串末尾的空格。

- 状态转移

1. 如果这个时候没有任何空格 $k=0$， 就直接从 $dp_{i-1,j-1,k'}$ 中最大的值转移。
2. 如果 $k≠0$ ，那么就要考虑到上一个空格的位置在哪，考虑连续空格的代价相当于这段空格的第一个需要支付 $-a$ 的代价，后面的都需要支付 $-b$ 的代价，就很自然地列出了方程：$dp_{i,j,1}=\max\{dp_{i, j-1,1}-b,dp_{i,j-1,0}-a,dp_{i,j-1,2}-a\}$

$k=2$ 同理。

```cpp
#include <bits/stdc++.h>
#define int long long
namespace mystd {
	inline int read() {
		int w = 1, q = 0;
		char ch = ' ';
		while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
		if (ch == '-') w = -1, ch = getchar();
		while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
		return w * q;
	}
	inline void write(int x) {
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace std;
using namespace mystd;

const int inf = (1ll << 60);
const int maxn = 3e3 + 300;
char t1[maxn], t2[maxn];
int n, m, a, b, dp[maxn][maxn][3];
int s[maxn], t[maxn], d[maxn][maxn];

int get(char c) {
	if (c == 'A') return 0;
	else if (c == 'T') return 1;
	else if (c == 'G') return 2;
	else if (c == 'C') return 3;
	else return -1;
}

signed main() {
	scanf("%s%s", t1 + 1, t2 + 1);
	n = strlen(t1 + 1);
	m = strlen(t2 + 1);
	for (int i = 1; i <= n; i++) s[i] = get(t1[i]);
	for (int i = 1; i <= m; i++) t[i] = get(t2[i]);
	for (int i = 0; i <= 3; i++) {
		for (int j = 0; j <= 3; j++) {
			d[i][j] = read();
		}
	}
	a = read();
	b = read();
	for (int i = max(n, m); i >= 1; i--) {
		dp[0][i][0] = dp[i][0][0] = dp[0][i][2] = dp[i][0][1] = -inf;
		dp[0][i][1] = dp[i][0][2] = - a - b * (i - 1);
	}
	dp[0][0][1] = dp[0][0][2] = -inf;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			dp[i][j][0] = max(max(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1]), dp[i - 1][j - 1][2]) + d[s[i]][t[j]];
			dp[i][j][1] = max(max(dp[i][j - 1][0] - a, dp[i][j - 1][1] - b), dp[i][j - 1][2] - a);
			dp[i][j][2] = max(max(dp[i - 1][j][0] - a, dp[i - 1][j][2] - b), dp[i - 1][j][1] - a);
		}
	}
	write(max(max(dp[n][m][0], dp[n][m][1]), dp[n][m][2]));
	return 0;
}
```

---

## 作者：Cocoly1990 (赞：2)

很明显是一道动态规划

首先有个很重要的性质是**最优解不可能存在$A_i,B_i$均为空格的情况**

那么我们可以令$f_{i,j,k}$表示$A$枚举到第$i$位，$B$枚举到第$j$位，空格状态为$k$时的最大相似程度

空格状态$k$有一下三种

$k=0$ 没有空格

$k=1$ 空格在$A_i$上

$k=2$ 空格在$B_j$上


另外还有就是我们可以把一串长空格的第一段空格视为$-A$，之后的视为$-B$

那么易得状态转移方程

$f_{i,j,0}=\max(f_{i-1,j-1,0},f_{i-1,j-1,1},f_{i-1,j-1,2})+d_{A_i,B_j}$

$f_{i,j,1}=\max(f_{i,j-1,0}-A,f_{i,j-1,1}-B,f_{i,j-1,2}-A)$

$f_{i,j,2}=\max(f_{i-1,j,0}-A,f_{i-1,j,1}-A,f_{i-1,j,2}-B)$

然后是初始化

$f_{i,0,0}=f_{i,0,1}=f_{0,i,0}=f_{0,i,2}=-\infty$

$f_{i,0,2}=f_{0,i,1}=g(i)$

核心代码

```cpp
	for(int i = 1 ; i <= lena ; i ++)
	{
		for(int j = 1 ; j <= lenb ; j ++)
		{
			f[i][j][0] = max(f[i - 1][j - 1][0] , max(f[i - 1][j - 1][1] , f[i - 1][j - 1][2])) + d[DA[i]][DB[j]] ;
			f[i][j][1] = max(f[i][j - 1][0] - A , max(f[i][j - 1][1] - B , f[i][j - 1][2] - A));
			f[i][j][2] = max(f[i - 1][j][0] - A , max(f[i - 1][j][1] - A , f[i - 1][j][2] - B));
		}
	}
	cout << max(f[lena][lenb][0] , max(f[lena][lenb][1] , f[lena][lenb][2])) ;

```

---

## 作者：Ame__ (赞：1)

### 简化题面
给出两个基因串（长度不超过1000），你需要在其中插入任意个空格，保证两个串长度相同。如果两个串的某同一位置都是字母则获得某给定价值，对于每个串的每个长度为$k$的连续空格段要付出$a(k-1)+b$的损失（$a$、$b$均为正数）。求最大价值。

### 题目分析
显然的如果两个空格匹配你会亏死，所以在转移的时候我们可以直接忽略两个空格匹配的情况，那么就会有三种情况，空格字母，字母空格，字母字母进行匹配的情况，那么我们就设三个dp数组

$dp1[i][j]$表示$a$匹配到$i$，$b$匹配到$j$末尾是空格和字母的最大价值，

$dp2[i][j]$表示$a$匹配到$i$，$b$匹配到$j$末尾是字母和空格的最大价值，

$dp3[i][j]$表示$a$匹配到$i$，$b$匹配到$j$末尾是字母和字母的最大价值，

对于三种方程我们按题意进行模拟转移即可，最后答案为三个$dp$方程匹配到$n$和$m$的最大价值的$max$

对于初始化，开始时$dp1[0][1] = dp2[1][0] = -A$，对于往后匹配，每匹配一次就有$-B$的价值，但对于其他的初值要考虑例如$dp3[0][4]$转移到$dp3[1][5]$显然是没有意义的因此赋成极小值，（但是不知道为什么$dp1$，$dp2$也要赋值，不赋最小值就$wa$了，$wa$了半天）

### $Code$

```.cpp
#include<bits/stdc++.h>
    
#define LL long long
    
#define _ 0

using namespace std;
    
/*Grievous Lady*/

inline int get_a(char z){
    int res = 0 ;if(z == 'A') res = 1; else if(z == 'T') res = 2;else if(z == 'G') res = 3; else if(z == 'C') res = 4; return res;
}
    
inline int get_b(char z){
    int res = 0 ;if(z == 'A') res = 1; else if(z == 'T') res = 2;else if(z == 'G') res = 3; else if(z == 'C') res = 4; return res;
}

template <typename T> void read(T & t){
    t = 0;int f = 1;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f =- 1;ch = getchar();}
    do{t = t * 10 + ch - '0';ch = getchar();}while(ch >= '0' && ch <= '9');t *= f;
}

const int kato = 3e3 + 1;

char a[kato] , b[kato];

int val[5][5] , A , B , ans;

int dp1[kato][kato] , dp2[kato][kato] , dp3[kato][kato];

inline int Ame_(){
    scanf("%s%s" , a + 1 , b + 1);
    int lena = strlen(a + 1) , lenb = strlen(b + 1);
    for(int i = 1;i <= 4;i ++){
        for(int j = 1;j <= 4;j ++){
            read(val[i][j]);
        }
    }
    read(A);read(B);
    memset(dp1 , 0xc0 , sizeof(dp1));
    memset(dp2 , 0xc0 , sizeof(dp2));
    memset(dp3 , 0xc0 , sizeof(dp3));
    dp1[0][1] = dp2[1][0] = -A , dp1[0][0] = dp2[0][0] = dp3[0][0] = 0;
    for(int i = 2;i <= lenb;i ++){
        dp1[0][i] = dp1[0][i - 1] - B;
    }
    for(int i = 2;i <= lena;i ++){
        dp2[i][0] = dp2[i - 1][0] - B;
    }
    for(int i = 1;i <= lena;i ++){
        for(int j = 1;j <= lenb;j ++){
            dp1[i][j] = max(dp1[i][j - 1] - B , max(dp2[i][j - 1] , dp3[i][j - 1]) - A);
            dp2[i][j] = max(dp2[i - 1][j] - B , max(dp1[i - 1][j] , dp3[i - 1][j]) - A);
            dp3[i][j] = max(dp3[i - 1][j - 1] , max(dp2[i - 1][j - 1] , dp1[i - 1][j - 1])) + val[get_a(a[i])][get_b(b[j])];
        }
    }
    ans = max(dp3[lena][lenb] , max(dp2[lena][lenb] , dp1[lena][lenb]));
    printf("%d\n" , ans);
    return ~~(0^_^0);
}
    
int Ame__ = Ame_();
    
signed main(){;}
```

---

## 作者：SIXIANG32 (赞：0)

一道 dp。  
闲话少说，切入正题——  

---
很容易想到这是一道 dp 题。  
设状态 $f_{i, j, 0/1/2}$ 表示 DNAA 到了第 $i$ 个字符，DNAB 到了第 $j$ 个字符，最后结尾是字符（$0$），DNAA 末尾是空格（$1$），DNAB 末尾是空格（$2$）的最大相似度。  
然后很明显分类讨论：  
- 第三维为 $0$，这个就是直接转移就好了，$f_{i, j, 0} = \max\{f_{i - 1, j - 1, 0},f_{i - 1, j - 1, 1}, f_{ i - 1, j - 1 , 2}\} + d_{DNAA_i, DNAB_j}$。
- 第三维为 $1$，DNAA 末尾是空格，那么就需要一点讨论了。$\operatorname{g}$ 函数要先减去一个 $A$ 再减去 $(k - 1)B$，可以想成对于第一个空格减去 $A$，剩下的空格减去 $B$。这样一来空格的讨论就简单了，对于上个状态 $f_{i, j - 1, 0}$ 没有空格，这是第一个空格，减去 $A$，$f_{i, j - 1, 2}$ 同理减去 $A$。对于 $f_{i, j - 1, 1}$ 的转移是减去 $B$。列出方程：$f_{i, j, 1} = \max\{f_{i , j - 1, 0} - A, f_{i, j - 1, 1} - B, f_{i, j - 1, 2} - A\}$
- 第三维为 $2$，有了上面的式子不难得出这里的状态转移方程：$f_{i, j, 2} = \max\{f_{i - 1, j, 0} - A, f_{i - 1, j, 1} - A, f_{i - 1, j, 2} - B\}$  

代码：  
```cpp
#include <iostream>
#include <string>
#include <cstring>
#define int long long
#define MAXN 3000
#define QWQ cout << "QWQ" << endl;
using namespace std;
int f[MAXN + 10][MAXN + 10][3], a[MAXN + 10], b[MAXN + 10], n, m, d[5][5];
string s1, s2;
int qwq(char ch) {
	if(ch == 'A') return 1;
	else if(ch == 'T') return 2;
	else if(ch == 'G') return 3;
	else if(ch == 'C') return 4;
}
int MAX(int a, int b, int c) {
	return ((((a > b) ? (a) : (b)) > c) ? (((a > b) ? (a) : (b))) : (c));
}
signed main() {
	cin >> s1 >> s2;
	n = s1.size(), m = s2.size();
	for(int p = 1; p <= n; p++) a[p] = qwq(s1[p - 1]);
	for(int p = 1; p <= m; p++) b[p] = qwq(s2[p - 1]);
	for(int p = 1; p <= 4; p++)
		for(int i = 1; i <= 4; i++)
			cin >> d[p][i];
	int A, B; cin >> A >> B;
	memset(f, -0x7f, sizeof(f));
	f[0][0][0] = 0;//初始化
	for(int p = 0; p <= n; p++)//根据上面的内容状态转移
		for(int i = 0; i <= m; i++) {
			if(!(p + i)) continue;
			if(p && i) f[p][i][0] = MAX(f[p - 1][i - 1][0], f[p - 1][i - 1][1], f[p - 1][i - 1][2]) + d[a[p]][b[i]];
			if(i) f[p][i][1] = MAX(f[p][i - 1][0] - A, f[p][i - 1][1] - B, f[p][i - 1][2] - A);
			if(p) f[p][i][2] = MAX(f[p - 1][i][0] - A, f[p - 1][i][1] - A, f[p - 1][i][2] - B);
		}
	cout << MAX(f[n][m][0], f[n][m][1], f[n][m][2]);
}
```

---


# 山区建小学

## 题目描述

政府在某山区修建了一条道路，恰好穿越总共 $n$ 个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为 $d_i$（$d_i$ 为正整数），其中，$0<i<n$。为了提高山区的文化素质，政府又决定从 $n$ 个村中选择 $m$ 个村建小学。请根据给定的 $n$、$m$ 以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。

## 说明/提示

$1 \le m \le n < 500$，$1 \le d_i \le 100$。

## 样例 #1

### 输入

```
10 2
3 1 3 1 1 1 1 1 3```

### 输出

```
18```

# 题解

## 作者：hsfzLZH1 (赞：70)

这明显是一道$DP$题。通过观察$n$，$m$的范围（$500$）可得，题目要求在$O(n^3)$的时间复杂度内完成状态转移。

我们设计$dp[i][j]$表示在前$i$个村庄中建立$j$个小学的最小距离总和。设$f[i][j]$表示在村庄区间$[i,j]$中（从第$i$个村庄到第$j$个村庄，包括两边）**只建$1$座小学**的最小距离总和。那么我们可以得到状态转移方程：

### $dp[i][j]=min\{dp[k][j-1]+f[k+1][i]\}$

这样我们计算出$f$数组，就可以在$O(n^2\times m)$的时间复杂度内完成状态转移了。

那么问题来了：怎样计算$f[i][j]$呢？

（这里需要一点**直觉**）在区间$[i,j]$内建一所小学，当然是要建在正中间，这样可以保证方案最优。所以，我们只需要选择区间的中点，即编号为$mid=\frac{i+j}2$的点，然后计算出所有村庄到该点的距离，即

### $f[i][j]=\sum_{k=i}^j |distance(k,mid)|~~~(mid=\frac{i+j}2)$

$f[i][j]$的计算的时间复杂度为$O(n^3)$

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=510;
const int inf=2e9;
int n,m,a[maxn],f[maxn][maxn],dp[maxn][maxn];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=2;i<=n;i++)scanf("%d",a+i),a[i]+=a[i-1];
	for(int l=1;l<=n;l++)for(int r=l;r<=n;r++)
	{
		int mid=(l+r)>>1;
		for(int k=l;k<=r;k++)f[l][r]+=abs(a[mid]-a[k]);
	}
	for(int i=0;i<=n;i++)for(int j=0;j<=m;j++)dp[i][j]=inf;
	dp[0][0]=0;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
	{
		if(j>i){dp[i][j]=0;continue;}
		for(int k=j-1;k<=i;k++)dp[i][j]=min(dp[i][j],dp[k][j-1]+f[k+1][i]);
	}
	printf("%d\n",dp[n][m]);
	return 0;
}
```

---

## 作者：Adove (赞：60)

我来给一下楼下说的$f[i][j]$数组求解正确性的证明：

首先我们知道对于中间的村庄，左边有$\frac{n}{2}$个村庄，右边也有$\frac{n}{2}$个村庄

那么当我们将小学向左侧村庄移动时，左边有$\frac{n}{2}$个村庄距离减少$l_L$，右边有$\frac{n}{2}+1$个村庄距离增加$l_L$，总距离净增$l_L$。

同理我们将小学向右移动时，左边有$\frac{n}{2}+1$个村庄距离增加$l_R$，右边有$\frac{n}{2}$个村庄距离减少$l_R$，总距离净增$l_R$。

由于$l_L$与$l_R$均为正整数，故选址在中间的村庄为最优方案。

---

## 作者：不存在之人 (赞：14)

根据题意，我们可以把这些村庄间的道路连成了一条长链。想象一下这条链从左到右延伸，上面的某些结点已经建了学校，我们在这些结点的右侧找一个结点$a$，建一个新的学校。

新学校管辖的结点范围有多大呢？

结点$a$右边的村庄全部应该受$a$学校管辖，结点左边的学校则需要枚举判断了。

在决策结点$a$的学校之前，我们应该已经决策了另外一些已建好的学校，它们的决策方式和上面是相同的。

假设我们已经决策过$i-1$个村庄是否建了学校，正在决策第$i$个，之前建好的学校管辖范围是1~k，那么新学校的管辖范围应该是k+1~m，（k的范围是"已有学校数"~m-1）

设f[决策的村庄数][建的小学数]=题目要求的距离，s[管辖区起点][管辖区终点]=这片辖区内建一个学校，区内村庄到学校的距离和。

$f[i][j]=min(f[i][j],f[k][j-1]+s[k+1][i])$

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int inf=99999999;
int f[510][510];
int dis[510][510];//从i到j距离
int d[510];
int s[510][510];
//s[管辖区起点][管辖区终点]=这片辖区内建一个学校，区内村庄到学校的距离和
int n,m;
int dist(int i,int j)
{
	int x=0;
	int mid=(i+j)/2;
	for(int k=i;k<=j;k++)
	  	x+=dis[k][mid];
	return x;
}
int main()
{
	scanf("%d%d",&m,&n);
	int i,j,x;
	for(i=2;i<=m;i++)//从2开始，方便求各村庄间距离
	{
		scanf("%d",&x);
		d[i]=d[i-1]+x;
	}
	for(i=1;i<=m;i++)
	  	for(j=1;j<=m;j++)
	  	{
	  		if(i==j)dis[i][j]=0;
	  		else dis[i][j]=dis[j][i]=abs(d[j]-d[i]);
	  	}//初始化两两距离
	for(i=1;i<=m;i++)
	  	for(j=1;j<=m;j++)
	    	s[i][j]=dist(i,j);
    //计算一个管辖从i到j村庄的学校到这些村庄的距离和
	for(i=1;i<=m;i++)
	  	for(j=1;j<=m;j++)
	    	f[i][j]=inf;
	for(i=1;i<=m;i++) f[i][i]=0;
	for(i=1;i<=m;i++) f[i][1]=s[1][i];//只建一个学校的情况
	for(i=2;i<=m;i++)//村庄
	{
		for(j=2;j<=min(i,n);j++)//学校
		{
			for(int k=j-1;k<=i-1;k++)//枚举已有的学校管辖的范围
			{
				if(i!=j) f[i][j]=min(f[i][j],f[k][j-1]+s[k+1][i]);
			}	
		} 
	}
	printf("%d",f[m][n]);
}
```

---

## 作者：失之_连心 (赞：11)

我用的是递推的思路来做(看注释)
```
#include<bits/stdc++.h>//递推
using namespace std;
const int M=501;
int a[M][M],c[M][M],f[M][M];
int main()
{
	int n,t,m,mid;
	cin>>m>>n;//按题意先输入n个村庄和m个小学
	for(int i=1;i<m;i++)//输入
	    cin>>a[i][i+1];
	for(int i=1;i<=m;i++)
	    for(int j=i+1;j<=m;j++){
	    	a[i][j]=a[j-1][j]+a[i][j-1];//初值
	    	a[j][i]=a[i][j];//a数组表示ij两地之间的距离
	    }
	for(int i=1;i<=m;i++)
	    for(int j=i+1;j<=m;j++){
	    	mid=(i+j)/2;//在山地中间建小学最优
	    	c[i][j]=0;//此时现将c[i][j]变成0
	    	for(int k=i;k<=j;k++)
	    	   c[i][j]+=a[k][mid];//c数组统计ij两地到学校的距离
	    }
	for(int i=1;i<=m;i++)
	    f[i][1]=c[1][i];//将f数组设初值
	for(int i=1;i<=m;i++)
	    for(int j=2;j<=n;j++){
	    	f[i][j]=214748364;//先将f[i][j]设为最大值
	    	for(int k=j-1;k<=i;k++)
	    	    f[i][j]=min(f[i][j],f[k][j-1]+c[k+1][i]);//找出学校位置的最小值并替换
	    }
	cout<<f[m][n];//输出最后答案
	return 0;
}

```
来自<<信息学奥赛一本通>>

---

## 作者：bessie_goes_moo (赞：4)

$step0$

如其他题解一样$n^3$ dp

$step1$

如果$k=1$,答案很显然，把小学建在$a_i$的中位数上

构造前缀和，我们就可以$O1$计算$ij$这一段最优的贡献

$step2$

根据您完美的直接或者无懈可击的证明~~（打表）~~

cost满足四边不等式，考虑决策单调性可以做到$n^2log_2n$

$code:$

```cpp
#include<bits/stdc++.h>
#define re register
#define I inline
#define Open(x) freopen(x".in","r",stdin),freopen(x".out","w",stdout)
using namespace std;
typedef long long LL;
struct IO{
	static const int S=1<<21;
	char buf[S],*p1,*p2;int st[105],Top;
	~IO(){clear();}
	inline void clear(){fwrite(buf,1,Top,stdout);Top=0;}
	inline void pc(const char c){Top==S&&(clear(),0);buf[Top++]=c;}
	inline char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	IO&operator >> (char&x){while(x=gc(),x==' '||x=='\n');return *this;}
	template<typename T> IO&operator >> (T&x){
		x=0;bool f=0;char ch=gc();
		while(ch<'0'||ch>'9'){if(ch=='-') f^=1;ch=gc();}
		while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=gc();
		f?x=-x:0;return *this;
	}
	IO&operator << (const char c){pc(c);return *this;}
	template<typename T> IO&operator << (T x){
		if(x<0) pc('-'),x=-x;
		do{st[++st[0]]=x%10,x/=10;}while(x);
		while(st[0]) pc('0'+st[st[0]--]);return *this;
	}
}fin,fout;
const int maxn=505,maxw=1e6+5;
LL cost[maxn][maxn],S[maxn],a[maxn],n,k,f[maxn][maxn];
LL get(int i,int j){
	int mid=i+j>>1,L=mid-i+1,R=j-mid;
	return (LL)L*a[mid]-S[mid]+S[i-1]+S[j]-S[mid]-a[mid]*R;
}
LL tmp,res;
void solve(int l,int r,int ql,int qr,LL*ans,LL*pre){
	if(l>r||ql>qr) return;
	int mid=(l+r)>>1,Minloc=mid;tmp=1ll<<60,res=0;
	for(int i=ql;i<=qr&&i<mid;i++) 
	if(tmp>=(res=pre[i]+cost[i+1][mid])) tmp=res,Minloc=i;
	ans[mid]=min(ans[mid],tmp);
	solve(mid+1,r,Minloc,qr,ans,pre),solve(l,mid-1,ql,Minloc,ans,pre);
}
int main(){
//	Open("B");
	fin>>n>>k;
	for(re int i=1;i<=n;i++) fin>>a[i],a[i]+=a[i-1];
//	sort(a+1,a+1+n);
	for(re int i=1;i<=n;i++) S[i]=S[i-1]+a[i];
	memset(f,127,sizeof f);
	for(re int i=1;i<=n;i++) 
	for(re int j=i;j<=n;j++) 
	cost[i][j]=get(i,j);f[0][0]=0;
	for(re int i=1;i<=k;i++) solve(1,n,0,n-1,f[i],f[i-1]);
	fout<<f[k][n];
	return 0;
}
```

$step3$

然鹅这个复杂度还不是最优的(可以做到$nlog_2n$)，等菜鸡我会了再说

---

## 作者：_蒟蒻__ (赞：4)

大佬们都是用的找中点建学校的方法建学校， 但是……

### 蒟蒻看不出来啊！！！

于是乎， 采用常规DP思路，把dp数组的意义改了一下。 f[i][j]表示只考虑前i个庄的贡献， 前i个庄有j个学校， 其中第i个庄建了学校。 再用g[i][j]表示i到j之间， 第i, j个庄建了学校，其他庄到分别到其最近学校的距离总和。

算了不说了， 生命苦短， 直接上代码。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=1010;
int n, m, ans=2333333, d[N], s1[N], s2[N], f[N][N], g[N][N];

int main()
{
	ios::sync_with_stdio(false);
	
	cin>>n>>m;
	
	for(int i=2; i<=n; i++) cin>>d[i], d[i]+=d[i-1];
	
	memset(f, 0x3f, sizeof(f));
	
	for(int i=1; i<=n; i++)
	for(int j=i+1; j<=n; j++)
	for(int k=i+1; k<j; k++)
		g[i][j]+=min(d[k]-d[i], d[j]-d[k]); 
		
	for(int i=1; i<=n; i++)
	for(int j=1; j<i; j++)
		s1[i]+=d[i]-d[j]; // d的前缀和 (只在i建校, i前面的贡献)  
		
	for(int i=n; i; i--)
	for(int j=n; j>i; j--)
		s2[i]+=d[j]-d[i]; // d的后缀和 (只在i建校, i后面的贡献)
		
	for(int i=1; i<=n; i++) f[i][1]=s1[i]; 
	
	for(int i=1; i<=n; i++)
	for(int j=2; j<=min(i, m); j++)
	for(int k=1; k<i; k++)
		f[i][j]=min(f[i][j], f[k][j-1]+g[k][i]);
		
	for(int i=1; i<=n; i++)
		ans=min(ans, f[i][m]+s2[i]);
		
	return cout<<ans, 0;
}

```


---

## 作者：abandentsky (赞：4)

刚开始只是想到定义状态dp[i][j]为前i个村子使用j个学校的最小花费，始终写不出状态转移方程，一直在想第i个村子接到后面学校如果更优怎么办，越来越乱。其实我们可以画个图，就发现这种想法是没必要的。只要i编号以前的，包括编号i，都必须有这分配的j个学校解决。这样就好办了。
状态转移方程就是：dp[i][j]=min(dp[i][j],dp[k][j-1]+cost[k+1][i])，也挺好理解的，cost[m][n]的意思：从m到n（包括端点）只修建一所学校。所产生的费用。这里的k要注意，虽然是枚举区间中的点，但你要清楚每个村子最多修一个学校，所以k枚举时应该由j-1开始，（因为前i个村子一共给了j个学校，我们要给后面留一个）。k的结束位置就是i了。其他的看代码吧；
首先我们计算出任意两点之间的距离。
然后计算任意两个点之间（或者理解为任意一个区间只修一个学校的开销）来初始化。至于为啥会选中点，楼下有大佬的证明。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 505
#define INF 0x3f3f3f3f
using namespace std;

int n,m;
int p[MAXN];
int dp[MAXN][MAXN],f[MAXN][MAXN],dis[MAXN][MAXN];

void init()
{
    for(int i=1;i<=n;i++)
    {
        dis[i][i]=0;
        for(int j=i+1;j<=n;j++)
        {
            dis[j][i]=dis[i][j]=abs(p[j]-p[i]);           //计算每个区间的长度
        }
    }
    for(int i=1;i<=n;i++)                //枚举区间左端点
    {
        for(int j=i;j<=n;j++)            //枚举区间右端点
        {
            int mid=(i+j)>>1;             //区间中点
            for(int k=i;k<=j;k++)
            {
                f[i][j]+=dis[k][mid];     //区间和等于区间每个点到中点mid的距离之和(也就是所需要的花费)
            }
        }
    }
}

void solve()
{
    init();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(i==j)                             //前n个村子有n个学校，就是每个村子一个学校，这样距离和就是0
                dp[i][j]=0;
            else
                dp[i][j]=INF;             //其他情况都初始为INF，因为我们求的是最小值
        }
        dp[i][0]=INF;                    //这里很重要，不然就wrong了
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=min(m,i);j++)      //前i个村子，可以分配的学校数是村子数和m的最小值
        {
            for(int k=j-1;k<=i;k++)           //前i个村子我们分配给j个学校，把j-1个学校分出去，所以k（是一个中间值，区间dp一样）至少为j-1
            {                                                      //则从k开始到i（左右端点包括）就是由一个学校来解决，所以是f[k+1][i];
                dp[i][j]=min((dp[k][j-1]+f[k+1][i]),dp[i][j]);
            }
        }
    }
    printf("%d\n",dp[n][m]);
}

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=2;i<=n;i++)
    {
        scanf("%d",&p[i]);
        p[i]+=p[i-1];
    }
    solve();
    return 0;
}

```


---

## 作者：Polaris_Dane (赞：4)

这道题其实主要的问题不在于写状态转移方程

像我这么弱的都很快写出来了

在于如何快速求出一段区间中选一个点是其他点到这个点距离和最小的距离

我的想法应该是O（1）的，因为预处理在读入中

先通过一个前缀和求出每个点的实际距离

然后在用一个前缀和

```cpp
	for (int i=2;i<=n;i++)
	{
		read(a[i]);
		s[i]=s[i-1]+a[i];
		t[i]=t[i-1]+s[i];
	}
```
然后用的时候，这样子
```cpp
inline int getdis(int a,int b)
{
	int h=(a+b)/2,ans=0,pos=b-a+1;
	if (pos%2==1)
	{
		ans+=(pos/2)*s[h]-(t[h-1]-t[a-1]);
		ans+=(t[b]-t[h])-(pos/2)*s[h];
	}
	else
	{
		ans+=(pos/2-1)*s[h]-(t[h-1]-t[a-1]);
		ans+=(t[b]-t[h])-(pos/2)*s[h];
	}
	return ans;
}
```
即可O（1）求出该值

大概跑了200ms，太弱了，没办法

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<queue>
#include<vector> 
#define M 201000
#define inf 0x3f3f3f3f 
#define LL long long
using namespace std;
int n,m,dp[600][600],a[M],s[M],t[M];
inline void read(int &x)
{
	int f=1;x=0;char s=getchar();
	while (!isdigit(s)){
		if(s=='-')f=-1;
		s=getchar();
	}
	while (isdigit(s))
	{
		x=(x<<1)+(x<<3)+(s^48);
		s=getchar();
	}
	x*=f;
}
inline int getdis(int a,int b)
{
	int h=(a+b)/2,ans=0,pos=b-a+1;
	if (pos%2==1)
	{
		ans+=(pos/2)*s[h]-(t[h-1]-t[a-1]);
		ans+=(t[b]-t[h])-(pos/2)*s[h];
	}
	else
	{
		ans+=(pos/2-1)*s[h]-(t[h-1]-t[a-1]);
		ans+=(t[b]-t[h])-(pos/2)*s[h];
	}
	return ans;
}
int main()
{
	read(n);read(m);
	for (int i=2;i<=n;i++)
	{
		read(a[i]);
		s[i]=s[i-1]+a[i];
		t[i]=t[i-1]+s[i];
	}
	memset(dp,0x7f,sizeof(dp));
	dp[0][0]=0;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
		{
			if (j>=i)
			{
				dp[i][j]=0;
				continue;
			}
			for (int k=j-1;k<=i-1;k++)
			{
				dp[i][j]=min(dp[i][j],dp[k][j-1]+getdis(k+1,i));
			}
		}
	}
	printf("%d",dp[n][m]);
    return 0;
}
```


---

## 作者：米奇奇米 (赞：4)

[P4677 山区建小学](https://www.luogu.org/problemnew/show/P4677)
# 一眼区间DP题：
## 时间复杂度：O(n^3),由于题目数据小，显然不会暴
## f[i][j]表示在i—j区间内建立一座学校的最短距离总和
## a[i][j]表示i,j两村庄之间的距离
## pre[i][j]表示两地到最近学校的距离
# 然后就是转移方程：
## f[i][j]=max{f[i][j],f[k][j-1]+pre[k+1][i]
## 先看一下预处理两地之间距离的CODE：
```cpp
for(int i=1;i<m;i++)
		cin>>a[i][i+1];//表示第i个村庄到下一个村庄的距离，用二维数组来记录
	for(int i=1;i<=m;i++)
	    for(int j=i+1;j<=m;j++){
	    	a[i][j]=a[j-1][j]+a[i][j-1];
	    	a[j][i]=a[i][j];//反着也记录下来
	    }
```
## 再看一下如何求距离学校最短路径的CODE：
```cpp
for(int i=1;i<=m;i++)
	    for(int j=i+1;j<=m;j++){
	    	mid=(i+j)/2;//在两地中点建立学校的距离最短
			pre[i][j]=0;
			for(int k=i;k<=j;k++)
			   pre[i][j]+=a[k][mid]; 
		}
```
## 再来看一下对f数组的初始化CODE：
```cpp
for(int i=1;i<=m;i++) 
       f[i][1]=pre[1][i];//赋初值
```
## 最后就是核心部分的CODE：
```cpp
	for(int i=1;i<=m;i++)
	    for(int j=2;j<=n;j++){
	    	f[i][j]=s;//初始化最大0x7fffff是一个很大的数，自己输出看看
	    	
	    	for(int k=j-1;k<=i;k++)
	    	    f[i][j]=min(f[i][j],f[k][j-1]+pre[k+1][i]);//开始已经有解释
	    	}

```
## 最后只要输出  f[m][n]   就结束啦！！
## 以下就是完整的不加注释的代码：不要抖动control键哦？！？
```cpp
#include<bits/stdc++.h>
using namespace std;
int const MAXN=501;
int f[MAXN][MAXN],pre[MAXN][MAXN],a[MAXN][MAXN]={0},x,ans,n,m;
int s=0x7fffff,mid;
int main(){
	cin>>m>>n;
	for(int i=1;i<m;i++)
		cin>>a[i][i+1];
	for(int i=1;i<=m;i++)
	    for(int j=i+1;j<=m;j++){
	    	a[i][j]=a[j-1][j]+a[i][j-1];
	    	a[j][i]=a[i][j];
	    	//cout<<a[i][j]<<" ";
	    }
	for(int i=1;i<=m;i++)
	    for(int j=i+1;j<=m;j++){
	    	mid=(i+j)/2;
	    	//cout<<mid<<" "; 
			pre[i][j]=0;
			for(int k=i;k<=j;k++)
			   pre[i][j]+=a[k][mid]; 
		}
	for(int i=1;i<=m;i++) f[i][1]=pre[1][i];
	for(int i=1;i<=m;i++)
	    for(int j=2;j<=n;j++){
	    	f[i][j]=s;
	    	
	    	for(int k=j-1;k<=i;k++)
	    	    f[i][j]=min(f[i][j],f[k][j-1]+pre[k+1][i]);
				//cout<<f[i][j]<<endl;
	    	}
	cout<<f[m][n]<<endl;
	return 0;
}
```






---

## 作者：Michael_Kong (赞：2)

一道dp题(废话)

这道题数据范围比较小，所以无论是n^2还是n^3都可以过

我们可以定义状态$f[i][j]$,代表了前i个村庄中修建j所小学的距离和最小值，所以大概可以写出一个转移方程：

$f[i][j]=min(f[i][j],f[k][j-1]+dis[k+1][i])$

其中$dis[k+1][i]$代表了在k+1到i之间建立**一所**小学的最小距离和

那么我们该如何处理dis数组呢？这里我们可以凭直觉猜出是在中点处建立，具体的证明在其他题解里面也有，这里就不再赘述了

这道题还有一个坑点，就是输入的那个数列并不是每个村庄的坐标，而是村庄之间的距离，所以要处理出坐标的化需要用前缀和搞一下(估计只有像我这样的蒟蒻才会掉到这种坑里面去吧。。。)

AC代码(具体的细节写在注释里面了)：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f;
const int maxn=1926;
int f[maxn][maxn],a[maxn],dis[maxn][maxn],n,m;
int main(void){
	scanf("%d %d",&n,&m);
	for(int i=2;i<=n;i++){
		scanf("%d",&a[i]);
		a[i]+=a[i-1];//用前缀和处理出具体坐标
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			int mid=(i+j)/2;
			for(int k=i;k<=j;k++){
				dis[i][j]+=abs(a[k]-a[mid]);//这里一定要用abs取绝对值 
			}
		}
	}
	memset(f,inf,sizeof(f));//初始化成inf 
	f[0][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(j>i){
				f[i][j]=0;continue; 
			}else{
				for(int k=j-1;k<=i;k++){ 
					f[i][j]=min(f[i][j],f[k][j-1]+dis[k+1][i]);
				}
			}
		}
	}
	printf("%d",f[n][m]);
}
```


---

## 作者：AkiwaZawa (赞：2)

## 动态规划


（详情分析请见代码及注释）


### 打上代码

```
//f[i][j] 表示前i个村庄建j所学校，到那个村庄最近的路程和。
//f[i][j]=min(f[i][j],f[k][j-1]+s[k+1][i]);
#include<bits/stdc++.h> 
using namespace std;  
const int inf=99999999;  
int f[510][510];  
int dis[510][510];  
int d[510];  
int s[510][510];  
//s[起点][终点]=这片区域内建一个学校，区内村庄到学校的距离和  
int n,m;  
int dist(int i,int j)
{  
    int x=0;  
    int mid=(i+j)/2;  
    for(int k=i;k<=j;k++)  
      x+=dis[k][mid];  
    return x;  
}  
   
int main()
{  
    scanf("%d%d",&m,&n);  
    int x;  
    for(int i=2;i<=m;i++)
    {
        scanf("%d",&x);  
        d[i]=d[i-1]+x;  
    }    
    for(int i=1;i<=m;i++)  
    	for(int j=1;j<=m;j++)
      	{  
        	if(i==j)dis[i][j]=0;  
        	else dis[i][j]=dis[j][i]=abs(d[j]-d[i]);  
      	}//初始化  
    for(int i=1;i<=m;i++)  
      	for(int j=1;j<=m;j++)  
        	s[i][j]=dist(i,j);  
    //计算一个管辖从i到j村庄的学校到这些村庄的距离和    
    for(int i=1;i<=m;i++)  
      	for(int j=1;j<=m;j++)  
        	f[i][j]=inf;  
    for(int i=1;i<=m;i++)f[i][i]=0;  
    for(int i=1;i<=m;i++)f[i][1]=s[1][i];//只建一个学校的情况   
      
    for(int i=2;i<=m;i++){//村庄  
        for(int j=2;j<=min(i,n);j++){//学校   
            for(int k=j-1;k<=i-1;k++){//枚举已有学校管辖范围   
                if(i!=j)f[i][j]=min(f[i][j],f[k][j-1]+s[k+1][i]);  
            }     
        }   
    }  
    printf("%d",f[m][n]);  
    return 0;
}
```



---

## 作者：Stuch (赞：1)

# 看了楼上的几位神犇，大家基本都想到了DP啊，那我就用递推吧。


------------



# 上代码！！！

```cpp
#include<bits/stdc++.h>
#define maxn 501
using namespace std;
int a[maxn][maxn];//初始数据 相邻两个村庄之间的距离
int s[maxn][maxn];//任意两个村庄之间的距离
int d[maxn][maxn];
//在两个村庄之间建立一个小学，这些村庄到这小学的距离之和的最小值 
int f[maxn][maxn];
// f[i][j]总共建立j个小学，题目要求距离
int m,n;//村庄和小学的个数
int main()
{
	cin>>m>>n;
	for(int i=1;i<m;i++) cin>>a[i][i+1];
	for(int i=1;i<m;i++)
	{
		for(int j=i+1;j<=m;j++)
		{
			s[i][j]=s[i][j-1]+a[j-1][j];
			s[j][i]=s[i][j];//一定要赋值，否则后面的循环就加上一堆0
		}
	}
	for(int i=1;i<m;i++)
	{
		for(int j=i+1;j<=m;j++)
		{
			int x=(i+j)/2;
			for(int k=i;k<=j;k++) d[i][j]+=s[x][k];
		}
	}
	for(int i=1;i<=m;i++) f[i][1]=d[1][i];//预处理只建立一个小学的情况
	for(int i=1;i<=m;i++)
	{
		for(int j=2;j<=n;j++) //在 1~k建立j-1个小学 在k+1~i建立最后一个小学 
		{
			f[i][j]=0x7fffffff;
			for(int k=j-1;k<=i;k++) 
				f[i][j]=min(f[i][j],f[k][j-1]+d[k+1][i]);
		}
	 } 
	 cout<<f[m][n]<<endl;
	 return 0;
} 
```


------------

总之，这道题还是可以滴。代码解析请见上。




---

## 作者：封禁用户 (赞：0)

根据题意，我们可以把这些村庄间的道路连成了一条长链。想象一下这条链从左到右延伸，上面的某些结点已经建了学校，我们在这些结点的右侧找一个结点a，建一个新的学校。

新学校管辖的结点范围有多大呢？

结点a右边的村庄全部应该受a学校管辖（想一想，为什么），结点左边的学校则需要枚举判断了。

在决策结点a的学校之前，我们应该已经决策了另外一些已建好的学校，它们的决策方式和上面是相同的。

假设我们已经决策过i-1个村庄是否建了学校，正在决策第i个，之前建好的学校管辖范围是1~k，那么新学校的管辖范围应该是k+1~m，（k的范围是"已有学校数"~m-1）

        设f[决策的村庄数][建的小学数]=题目要求的距离，s[管辖区起点][管辖区终点]=这片辖区内建一个学校，区内村庄到学校的距离和。

f[i][j]=min(f[i][j],f[k][j-1]+s[k+1][i])





下面上代码(伪代码)
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int inf=99999999;
int f[510][510];
int dis[510][510];//从i到j距离 
int d[510];
int s[510][510];
//s[管辖区起点][管辖区终点]=这片辖区内建一个学校，区内村庄到学校的距离和
int n,m;
int dist(int i,int j){
	int x=0;
	int mid=(i+j)/2;
	for(int k=i;k<j;k++)
	  x+=dis[k][mid];
	return x;
}
 
int main(){
	freopen()
	scanf("%d%d",&m,&n);
	int i,j,x;
	for(i=2;i<m;i++){//从2开始，方便求各村庄间距离
		scanf("%d",&x);
		d[i]=d[i-1]+x;
	}
	//
	for(i=1;i<=m;i++)
	  for(j=1;j<m;j++){
	  	if(i==j)dis[i][j]=0;
	  	else dis[i][j]=dis[j][i]=abs(d[j]-d[i]);
	  }//初始化两两距离 
	//
	for(i=1;i<=m;i++)
	  for(j=1;j<=m;j++)
	    s[i][j]=dist(i,j);
	//计算一个管辖从i到j村庄的学校到这些村庄的距离和
	//
	for(i=1;i<=m;i++)
	  for(j=1;j<=m;j++)
	    f[i][j]=inf;
	for(i=1;i<=m;i++)f[i][i]=0;
	for(k=1;k<=m;k++)f[i][1]=s[1][i];//只建一个学校的情况 
	//f初始化 
		
/*	//test
	for(i=1;i<=m;i++)
	  for(j=1;j<=m;j++)
	    printf("%d ",s[i][j]);    
*/  
	for(i=2;i<=m;i++){//村庄
		for(j=2;j<=min(i,n);j++){//学校 
			for(int k=j-1;k<=i-1;k++){//枚举已有的学校管辖的范围 
				if(i!=j)f[i][j]=min(f[i][j],f[k][j-1]+s[k+1][i]);
			}	
		} 
	}
	printf("%d",f[m][n]);
	
}

```


---

## 作者：zhangzhaoke (赞：0)

一道DP题，不是特难的那种，详情看代码

一些思路可以看上楼，他分析的很清楚

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm> 
#include<cstring>
using namespace std;
int n,m,x; 
int dp[501][501],s[501],sum[501][501]; 
int main(){
	cin>>n>>m;
	memset(dp,0x7f,sizeof(dp));//0x7f意为无限大；即16进制的01111111；先将dp都赋值为无穷； 
	s[1]=1;
	for(int i=2;i<=n;i++){
		cin>>s[i];
		s[i]=s[i-1]+s[i];
	}//前缀和
	for(int i=1;i<=n;i++)//14 15行为主要计算程序；
		for(int j=i+1;j<=n;j++)
			sum[i][j]=sum[i][j-1]+s[j]-s[(i+j)/2];//c处理出任意两点间建一所小学所需路程和（中点原理）
	for(int i=1;i<=n;i++)
		dp[1][i]=sum[1][i]; //将sum【1】【i】赋值给dp【1】【i】 
	for(int k=2;k<=m;k++) //将要建m所小学 
		for(int i=k;i<=n;i++)
			for(int j=k-1;j<i;j++)
				dp[k][i]=min(dp[k][i],sum[j+1][i]+dp[k-1][j]);//取最小值；	
	printf("%d\n",dp[m][n]); //最后区间dp
	return 0;
}
```

---


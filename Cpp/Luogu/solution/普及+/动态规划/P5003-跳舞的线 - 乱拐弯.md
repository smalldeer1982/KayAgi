# 跳舞的线 - 乱拐弯

## 题目背景

# 线初始面对方向请自己确定

![您可以写dp](https://cdn.luogu.com.cn/upload/pic/30733.png)

玩过了 $LCA$ 之后，Imakf 觉得甚是无聊，于是便打开了 DL。

Imakf：刺客传奇又死在 $70\%$！突然有一点弃坑的想法鸭……

Imakf 想起自己玩了 $1$ 年的 DL，卡在园林教堂混沌，肝了几个月终于过了的欣喜，却被这个刺客传奇困住，禁不住泪眼朦胧。泪眼中，他突然发现手机变成了一个一个的像素点！Imakf 非常惊喜！这样不就可以写一个程序自动通关了吗？

可是不一会，他又陷入了失望……

Imakf：我不会写啊！！


## 题目描述

线现在在一个地图上，它正在 $(1,1)$ 上（左上角），最终要去到 $(M,N)$ 上。它不但只能往下或往右走，还只能在整数格子上移动。

Imakf 有的时候想要炫技，又有时想偷懒，所以他会告诉你这张地图的全貌，你要告诉他到达终点的最多和最少拐弯次数。


## 说明/提示

样例 $1$ 说明：

![](https://cdn.luogu.com.cn/upload/pic/12623.png)

红色路线代表拐弯次数最多。

蓝色路线代表拐弯次数最少。

--------------

样例 $2$ 说明：

显然过不去。

---

数据范围：

| 测试点 | $N$ | $M$ |
| -----------: | -----------: | -----------: |
| $1\sim 5$ | $\leq100$ | $\leq100$ |
| $6\sim 7$ | $=200$ | 不做约定 |
| $8\sim 10$ | 不做约定 |不做约定|

对于全体数据，保证 $10\le M,N\le 1000$。

感谢 @Iowa\_BattleShip 指出数据错误。

## 样例 #1

### 输入

```
5 5
oooo#
ooooo
#oo#o
o#ooo
oo#oo
```

### 输出

```
7 2
```

## 样例 #2

### 输入

```
5 5
oooo#
ooooo
#oo##
o#o#o
oo#oo
```

### 输出

```
-1```

# 题解

## 作者：Imakf (赞：19)

几万年前出的题目，当时在邀请赛中出的，~~然后因为宣传邀请赛被禁言了~~。

**这里只讲max的求法，因为min与max求法类似！实在不懂可以私信**

## $10 pts$ puts("-1");
没什么好说的吧，这个分给的很良心的，虽然这道题巨水

## $10 pts$ dfs爆搜

```cpp
void dfs(int x,int y,bool fac,int step){
  if(x>n||y>m|| 此处有障碍 )	return ;
  //x,y表示当前位置，step表示步数，fac表示方向 (0为向右，1为向下)
  if(x==n&&y==m){
  	ans=max(ans,step);
      return 0;
  }
  if(fac==0){
      dfs(x,y+1,fac,step);
      dfs(x+1,y,fac^1,step+1);
  }
  else{
      dfs(x+1,y,fac,step);
      dfs(x,y+1,fac^1,step)
  }
  
}

```

不剪枝的搜索必然拿不到高分啦

## $50 pts$ dfs加个记忆化

```cpp
void dfs(int x,int y,bool fac,int step){
  if(x>n||y>m|| 此处有障碍 )	return ;
  if(dis[u][v]>cans)	return;	//jiyihua
  dis[u][v]=max(dis[u][v],cans);	//jiyihua
  if(fac==0){
      dfs(x,y+1,fac,step);
      dfs(x+1,y,fac^1,step+1);
  }
  else{
      dfs(x+1,y,fac,step);
      dfs(x,y+1,fac^1,step)
  }
  
}

```

## $50pts$ bfs

不讲了，写起来很简单

## $100pts~~Dp$

这道题是在$2017NOIP$之前出的，当时我是个小蒟蒻鸭（现在还是），不会dp，然后一年之后我再来做了这道题，然后把数据加强了QAQ

$dp[i][j][k]$表示走到$(i,j)$方向为$k$的最多拐弯次数

### 初始化

把第一行和第一列初始化，第一行肯定不能方向为$1$,第一列方向不能为$0$，如果遇到#那就之后都不能走了

```
bool a=0;//用来记录是否遇到#
    for(int i=1;i<=n;i++){
        if(_map[i][1]=='#')a=1;
        if(a){
            dis[i][1][1]=10000;
            maxn[i][1][1]=-10000;
        }
        dis[i][1][0]=10000;
        maxn[i][1][0]=-10000;
    }
    a=0;
    for(int j=1;j<=m;j++){
        if(_map[1][j]=='#')a=1;
        if(a){
            dis[1][j][0]=10000;
            maxn[1][j][0]=-10000;
        }
        dis[1][j][1]=10000;
        maxn[1][j][1]=-10000;
    }
```

转移很简单鸭，跟上面搜索一样的

```cpp
for(int i=2;i<=n;i++){
       for(int j=2;j<=m;j++){
           if(有障碍)continue;
           maxn[i][j][0]=max(maxn[i][j-1][0],maxn[i][j-1][1]+1);
           maxn[i][j][1]=max(maxn[i-1][j][1],maxn[i-1][j][0]+1);
        }
 }
```

标程不放了，思路会了就不需要$STD$了

---

## 作者：Flying2018 (赞：12)

看到很多题解打了很多代码在一些特判上，其实不用那么复杂。

我们换一种dp，用$f[i][j]$去更新$f[i+1][j],f[i][j+1]$

$f[i+1][j][0]=min(f[i+1][j][0],min(f[i][j][0],f[i][j][1]+1));$
$f[i][j+1][1]=min(f[i][j+1][1],min(f[i][j][1],f[i][j][0]+1));$

假如当前是障碍物则跳过即可。

最后还要注意一个问题，这里默认在(1,1)处也是能拐弯的（但事实是不能的），所以最大值最后要-1。
代码：
```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>

using namespace std;
int f[2][1010][1010][2];//0:上,1:右 
char map[1010][1010];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%s",map[i]+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) f[0][i][j][0]=f[0][i][j][1]=10000000;
	f[0][1][1][0]=f[0][1][1][1]=f[1][1][1][0]=f[1][1][1][1]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(map[i][j]=='#')
			{
				f[1][i][j][0]=f[1][i][j][1]=-1;
				f[0][i][j][0]=f[0][i][j][1]=10000000;
				continue;
			}
			f[0][i+1][j][0]=min(f[0][i+1][j][0],min(f[0][i][j][0],f[0][i][j][1]+1));
			f[0][i][j+1][1]=min(f[0][i][j+1][1],min(f[0][i][j][1],f[0][i][j][0]+1));
			f[1][i+1][j][0]=max(f[1][i+1][j][0],max(f[1][i][j][0],f[1][i][j][1]+1));
			f[1][i][j+1][1]=max(f[1][i][j+1][1],max(f[1][i][j][1],f[1][i][j][0]+1));
		}
	}
	if(f[0][n][m][0]>=1000000) puts("-1");
	else printf("%d %d",max(f[1][n][m][0],f[1][n][m][1])-1,min(f[0][n][m][0],f[0][n][m][1]));
	
	return 0;
}
```

---

## 作者：d3ac (赞：8)

因为最小值和最大值的求法类似，所以我们只讨论最大值

设$f[i][j]$表示到$(i,j)$的最大拐弯数

设$g[i][j]$表示到$(i,j)$的走向（0表示向右，1表示向下，2表示任意）

+ 初始化$f[1][1\to n]=f[1\to n][1]=0$，$f[i][j]=\infty$

+ 初始化$g[i][1]=1$

+ 因为$(i,j)$肯定是从$(i-1,j)$或者$(i,j-1)$转移过来的

+ 所以 $f[i][j]=max(f[i-1]+g[i-1][j]!=1,f[i][j-1]+g[-i1][j]!=0)$

  - 从$(i-1,j)$或者$(i,j-1)$转移过来是一样的 $g[i][j]=2$

  - 从$(i-1,j)$转移过来就是$h[i][j]=1$

  - 从$(i,j-1)$转移过来就是$h[i][j]=0$

部分代码

```cpp
#define fleft  f[i-1][j]+(h[i-1][j]!=1)
#define fright f[i][j-1]+(h[i][j-1]!=0)
#define gleft  g[i-1][j]+(k[i-1][j]==0)
#define gright g[i][j-1]+(k[i][j-1]==1)
for(int i=2;i<=n;i++){
	for(int j=2;j<=m;j++){
		if(!map[i][j]) continue;
		if((fleft>fright) && map[i-1][j]) f[i][j]=fleft,h[i][j]=1;
		else if((fleft==fright)) f[i][j]=fleft,h[i][j]=check(i,j);
		else if(map[i][j-1]) f[i][j]=fright,h[i][j]=0;
		if((gleft<gright) && map[i-1][j]) g[i][j]=gleft,k[i][j]=1;
		else if((gleft==gright)) g[i][j]= gleft,k[i][j]=check(i,j);
		else if(map[i][j-1]) g[i][j]=gright,k[i][j]=0;
	}
}
```


---

## 作者：引领天下 (赞：8)

其实这题完全没有楼下讲的那么难……我就来解释一下我的思路吧

1. 首先，(i,j)这个点的答案肯定由(i-1,j)和(i,j-1)的答案确定（因为只准往下、往右走）

1. 我设到达(i,j)时的最大拐弯数为f[i][j]，则有

   - f[1][1...n]=0
   
   - f[1...n][1]=0
   
1. 我用h[i][j]表示到(i,j)的走向（0表示向右，1表示向下，2表示任意）
   
   则可以得到转移： $f[i][j]=max(f[i-1][j]+(h[i-1][j]!=1),f[i][j-1]+(h[i-1][j]!=0))$
   
   为什么用!=而不用==呢？因为是求最大拐弯数，所以**能拐我一定拐**，!=保证了当上一个点只要不是当前方向就一定拐。
   
   这也是h数组中2的用处。
   
   因为不仅要答案，还要求h数组，所以这个max我是用if分类讨论实现的
   
1. 同理可得，$g[i][j]=min(g[i-1][j]+(k[i-1][j]==0),g[i][j-1]+(k[i][j-1]==1))$，这里的==保证了能不拐我绝对不拐

然后就是一个坑：要先跑一遍，看能不能到。

最后初始化：$f[2...n][2...m]=-(1<<11),g[2...][2...m]=1<<11,h[1...n][1]=1 \text{因为向下走只有1种可能}$

具体细节看代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,f[1005][1005],g[1005][1005],h[1005][1005],k[1005][1005];
char c;
bool v[1005][1005],can[1005][1005];
int check(int i,int j){
    if (can[i-1][j]&&can[i][j-1])return 2;
    else if (can[i-1][j])return 1;
    else return 0;
}//在分类讨论中，判断当从(i-1,j)和(i,j-1)过来且拐弯数相同时哪一种可行
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++)
    for (int j=1;j<=m;j++){
        cin>>c;
        if (c=='#')v[i][j]=1,can[i][j]=0;//标记为不可走
    }
    can[1][1]=!v[1][1];
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        can[i][j]|=can[i-1][j]|can[i][j-1];
        if (v[i][j])can[i][j]=0;
    }
    if (!can[n][m])return !printf ("-1");//看能不能过
    for (int i=2;i<=n;i++)
    for (int j=2;j<=m;j++)f[i][j]=-(1<<11),g[i][j]=1<<11;//初始化
    for (int i=1;i<=n;i++)h[i][1]=k[i][1]=1;
    for (int i=2;i<=n;i++)
    for (int j=2;j<=m;j++)if (can[i][j]){
        if (f[i-1][j]+(h[i-1][j]!=1)>f[i][j-1]+(h[i][j-1]!=0)&&(can[i-1][j]))f[i][j]=f[i-1][j]+(h[i-1][j]!=1),h[i][j]=1;//从(i-1,j)过来可行且更优
        else if (f[i-1][j]+(h[i-1][j]!=1)==f[i][j-1]+(h[i][j-1]!=0))f[i][j]=f[i-1][j]+(h[i-1][j]!=1),h[i][j]=check(i,j);//相同
        else if (can[i][j-1])f[i][j]=f[i][j-1]+(h[i][j-1]!=0),h[i][j]=0;//(i,j-1)更优
        if (g[i-1][j]+(k[i-1][j]==0)<g[i][j-1]+(k[i][j-1]==1)&&(can[i-1][j]))g[i][j]=g[i-1][j]+(k[i-1][j]==0),k[i][j]=1;
        else if (g[i-1][j]+(k[i-1][j]==0)==g[i][j-1]+(k[i][j-1]==1))g[i][j]=g[i-1][j]+(k[i-1][j]==0),k[i][j]=check(i,j);
        else if (can[i][j-1])g[i][j]=g[i][j-1]+(k[i][j-1]==1),k[i][j]=0;//同上
    }
    if (f[n][m]>0)printf ("%d %d\n",f[n][m],g[n][m]);
    else putchar('-'),putchar('1');
}
```

---

## 作者：clamee (赞：6)

为什么大家都写的是DP呢？

在这里提供个双端队列广搜求最短路的思路

我们维护个双端队列，里面放当前位置和上一步方向。

我们记ans[i][j][k]表示在(i,j)，上一步方向为k的的答案。

我们发现，对于一个点，如果它拐弯则在下一个ans数组答案为当前ans+1，放入队末，否则放入队首。

关键代码：

```cpp
void init()
{
	for(int i=0;i<=n+1;i++)
    	mp[i][0]=mp[0][i]=mp[i][n+1]=mp[n+1][i]='#';
}
void bfs()
{
	deque<int> x,y,z;
    x.push_back(1);y.push_back(1);z.push_back(2);
    while(!x.empty())
    {
    	int u=x.front(),v=y.front(),k=z.front();
        x.pop_front();
        y.pop_front();
        z.pop_front();
        if(z==0||z==2)
        {
        	if(mp[x+1][y]!='#')
            {
            	ans[x+1][y]=ans[x][y];
                x.push_front(x+1);
     			y.push_front(y);
                z.push_front(z&1);
            }
            if(mp[x][y+1]!='#')
            {
            	ans[x+1][y]=ans[x][y]+1;
                x.push_back(x);
     			y.push_back(y+1);
                z.push_back((z^1)&1);
            }
        }
        if(z==1||z==2)
        {
        	if(mp[x+1][y]!='#')
            {
            	ans[x+1][y]=ans[x][y]+1;
                x.push_back(x+1);
     			y.push_back(y);
                z.push_back((z^1)&1);
            }
            if(mp[x][y+1]!='#')
            {
            	ans[x+1][y]=ans[x][y];
                x.push_front(x);
     			y.push_front(y+1);
                z.push_front(z&1);
            }
        }
    }
}
```

或者你也可以拆点建图。

建图方式：

将一个点拆成两个点，分别代表走到该点的方向。然后对于一个点向下一个能走到的点，方向相同连边权为0的边，否则连边权为1的边。

现在我们观察到整张图只有0，1两种边权，用双端队列广搜求最短路即可。

由于图建完了就是个板，而且也与前一个算法差不多，就不给代码了。

upd:发现一处语病，增加关键代码，增加算法描述。


---

## 作者：3493441984zz (赞：5)

# 这题很简单的，但是有坑点！！

坑了我一天，搞得我直接放弃，第二天才弄对。。

------------
# 设计状态：

我们设：

$f[i][j][0]$表示到了第$(i,j)$这个格子后，方向向右的最少拐弯数

$f[i][j][1]$表示到了第$(i,j)$这个格子后，方向向下的最少拐弯数

$g[i][j][0]$表示到了第$(i,j)$这个格子后，方向向右的最多拐弯数

$g[i][j][1]$表示到了第$(i,j)$这个格子后，方向向下的最多拐弯数

------------
# 状态转移：

我们开始设计转移方程：

### 对于$f[i][j][0]$:

$1$、它可能是由它左边这个格子向右直走一格来的，这样的话本来方向向右，现在还是向右，所以不拐弯，所以第一个状态转移方程：$$f[i][j][0]=f[i][j-1][0]$$

$2$、它还可能由它上面那个格子向下走一格，再拐一次弯向着右边转移来的，那么这个时候多拐了一次弯，所以第二个状态转移方程：$$f[i][j][0]=f[i-1][j][1]+1$$

**所以对于$f[i][j][0]$的状态转移总方程为:$$f[i][j][0]=min(f[i][j][0],min(f[i][j-1][0],f[i-1][j][1]+1))$$**

那么对于其他的状态转移方程也是这个思路，下面是状态转移代码：
~~~cpp
for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			if(!map[i][j])
			{
				f[i][j][0]=min(f[i][j][0],min(f[i][j-1][0],f[i-1][j][1]+1));
				f[i][j][1]=min(f[i][j][1],min(f[i-1][j][1],f[i][j-1][0]+1));
				g[i][j][0]=max(g[i][j][0],max(g[i][j-1][0],g[i-1][j][1]+1));
				g[i][j][1]=max(g[i][j][1],max(g[i-1][j][1],g[i][j-1][0]+1));
			}
~~~

------------
# 坑点：

要特判起点为#的情况$QAQ$，我为这个调了一天$qwQ$

------------
### 最后是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1007
using namespace std;
int n,m;
int f[N][N][2],g[N][N][2],map[N][N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
		{
			char in;
			scanf(" %c",&in);
			if(in=='#')
				map[i][j]=1;
		}
	if(map[1][1])
	{
		printf("-1");
		return 0;
	}
	memset(f,0x3f,sizeof(f));
	int inf=f[0][0][0];
	memset(g,0xcf,sizeof(g));
	f[1][1][0]=f[1][1][1]=0;
	g[1][1][0]=g[1][1][1]=0;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			if(!map[i][j])
			{
				f[i][j][0]=min(f[i][j][0],min(f[i][j-1][0],f[i-1][j][1]+1));
				f[i][j][1]=min(f[i][j][1],min(f[i-1][j][1],f[i][j-1][0]+1));
				g[i][j][0]=max(g[i][j][0],max(g[i][j-1][0],g[i-1][j][1]+1));
				g[i][j][1]=max(g[i][j][1],max(g[i-1][j][1],g[i][j-1][0]+1));
			}
	if(f[n][m][0]>=inf&&f[n][m][1]>=inf)
	{
		printf("-1");
		return 0;
	}
	printf("%d %d",max(g[n-1][m][1],g[n][m-1][0]),min(f[n-1][m][1],f[n][m-1][0]));
	return 0;
}
~~~

---

## 作者：qwerta (赞：4)

这里是一个$Dancing$ $Line$狂热粉qwq（在读高中失去手机之前每出新关就当天更新刷满钻三皇冠的qwq

对于求$min$，

设$f[i][j][0]$为在$(i,j)$时头对着横向的最小转弯次数，

$f[i][j][1]$为头对着竖向的最小转弯次数。

那么转移方程就是↓

$f[i][j][0]=min(f[i][j-1][0],f[i-1][j][1]+1);$

要么从左一格往右走;要么从上面一格往下走。

从上往下走，到了$(i,j)$要拐弯所以+1

$f[i][j][1]=min(f[i-1][j][1],f[i][j-1][0]+1);$

要么从上面一格往下走;要么从左一格往右走。

****

初始化$f$数组为INF，$f[1][1][0]=f[1][1][1]=0$。

对于求$max$也差不多。

要注意的是到了$f[m][n]$的时候要特殊处理一下，因为在$(m,n)$时头的方向没有意义，所以不用+1。（不然喜提50pts

```
/*
qwerta 
P5003 跳舞的线 - 乱拐弯 Accepted 
100
代码 C++，1.27KB
提交时间 2018-11-07 20:50:52
耗时/内存 174ms, 9496KB
*/
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
using namespace std;
char g[1003][1003];//存图
const int INF=19260817;
int f[1003][1003][2];//用来dp的数组
int main()
{
    //freopen("a.in","r",stdin);
    ios::sync_with_stdio(false);
    int m,n;
    cin>>m>>n;
    for(int i=1;i<=m;++i)
    for(int j=1;j<=n;++j)
    {
        cin>>g[i][j];
    }
    if(g[1][1]=='#'||g[m][n]=='#'){cout<<-1;return 0;}//特判一下，省事儿
    //先算max值
    memset(f,128,sizeof(f));//初始化为-INF
    f[1][1][0]=f[1][1][1]=0;
    for(int i=1;i<=m;++i)
    for(int j=1;j<=n;++j)
    if(g[i][j]=='o')//如果这个格子可以走
    {
        f[i][j][0]=max(f[i][j][0],
                   max(f[i-1][j][1]+1,f[i][j-1][0]));
        f[i][j][1]=max(f[i][j][1],
                   max(f[i-1][j][1],f[i][j-1][0]+1));
    }
    //
    f[m][n][0]=max(f[m-1][n][1],f[m][n-1][0]);//特殊处理qwq
    f[m][n][1]=max(f[m-1][n][1],f[m][n-1][0]);
    int mac=max(f[m][n][0],f[m][n][1]);//存一下
    //再算min值
    memset(f,127,sizeof(f));//初始化为INF
    f[1][1][0]=f[1][1][1]=0;
    for(int i=1;i<=m;++i)
    for(int j=1;j<=n;++j)
    if(g[i][j]=='o')//如果这个格子可以走
    {
        f[i][j][0]=min(f[i][j][0],
                   min(f[i-1][j][1]+1,f[i][j-1][0]));
        f[i][j][1]=min(f[i][j][1],
                   min(f[i-1][j][1],f[i][j-1][0]+1));
    }
    if(f[m][n][0]>INF&&f[m][n][1]>INF){cout<<-1;return 0;}//走不到就输出-1
    f[m][n][0]=min(f[m-1][n][1],f[m][n-1][0]);
    f[m][n][1]=min(f[m-1][n][1],f[m][n-1][0]);
    int mi=min(f[m][n][0],f[m][n][1]);
    //
    cout<<mac<<" "<<mi;//输出
    return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：2)

本题使用 dp。

下面拿最大值举例，最小值类同。

假设 $f_{i,j,k}$ 为走到 $(j,k)$ 位置方向为 $i$（$i=0$ 表示左，反之表示下）最多可以拐几次弯。

状态转移方程：

$$f_{0,i,j}=\max(f_{0,i,j-1},f_{1,i-1,j}+1)$$

$$f_{1,i,j}=\max(f_{1,i-1,j},f_{0,i,j-1}+1)$$

时间复杂度 $\mathcal{O}(n\times m)$。

下面给出算最大值的部分代码

```cpp
for(int i=1;i<=n;i++)
		f[0][0][i]=f[1][0][i]=f[0][i][0]=f[1][i][0]=-1e9;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(i+j==2)
				continue;
			if(!p[i][j]){
				f[0][i][j]=f[1][i][j]=-1e9;
				continue;
			}
			f[0][i][j]=max(f[0][i][j-1],f[1][i-1][j]+1);
			f[1][i][j]=max(f[1][i-1][j],f[0][i][j-1]+1);
		}
	if(max(f[0][n][m],f[1][n][m])<=-1e8){
		cout<<"-1";
		return 0;
	}
	else
		cout<<max(f[0][n][m],f[1][n][m])-1<<" ";
```


---

## 作者：Refined_heart (赞：2)

题目大意：问点$(1,1)$走到$(n,m)$的最多和最少的拐弯次数。

$\text{Solution:}$

显然的$dp$题目。设$dp[i][j][0/1]$表示当前坐标为$(i,j)$方向为$0/1$的最多拐弯次数。

$0$表示向右走，$1$表示向下走。

那么一个向下走的点$(i,j)$只能由$(i-1,j)$转移，向右走的点$(i,j)$只能由$(i,j-1)$转移。

这样的$dp$方程也就很显然了，注意方向不一样的时候需要拐弯。

```cpp
for(int i=0;i<=n;++i)
		for(int j=0;j<=m;++j)
			for(int k=0;k<2;++k)
				dp[i][j][k]=-1;
	dp[1][1][1]=dp[1][1][0]=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[i][j])continue;
			if(i==1&&j==1)continue;
			if(i==1){
				dp[i][j][0]=dp[i][j-1][0];
				continue;
			}
			if(j==1){
				dp[i][j][1]=dp[i-1][j][1];
				continue;
			}
			if(~dp[i-1][j][1])dp[i][j][1]=max(dp[i-1][j][1],dp[i][j][1]);
			if(~dp[i-1][j][0])dp[i][j][1]=max(dp[i][j][1],dp[i-1][j][0]+1);
			if(~dp[i][j-1][0])dp[i][j][0]=max(dp[i][j][0],dp[i][j-1][0]);
			if(~dp[i][j-1][1])dp[i][j][0]=max(dp[i][j][0],dp[i][j-1][1]+1);
		}
	}
```
代码中，第一行的点和第一列的点都是要特判的。因为它们只有一个方向。

求最小值，将$dp$初始值设为极大值转移即可。注意不可以走的点一直都不能走，而且这个$2^{31}-1+1$是会溢出的，所以要有判断。

```cpp
for(int i=0;i<=n;++i)
		for(int j=0;j<=m;++j)
			for(int k=0;k<2;++k)
				dp[i][j][k]=2147483647;
	dp[1][1][1]=dp[1][1][0]=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[i][j])continue;
			if(i==1&&j==1)continue;
			if(i==1){
				dp[i][j][0]=dp[i][j-1][0];
				continue;
			}
			if(j==1){
				dp[i][j][1]=dp[i-1][j][1];
				continue;
			}
			if(dp[i-1][j][0]!=2147483647)dp[i][j][1]=min(dp[i][j][1],dp[i-1][j][0]+1);
			if(dp[i-1][j][1]!=2147483647)dp[i][j][1]=min(dp[i][j][1],dp[i-1][j][1]);
			if(dp[i][j-1][0]!=2147483647)dp[i][j][0]=min(dp[i][j][0],dp[i][j-1][0]);
			if(dp[i][j-1][1]!=2147483647)dp[i][j][0]=min(dp[i][j][0],dp[i][j-1][1]+1); 
		}
	}
```
最后说一下判断无解的坑：代码中由于把$(1,1)$给过掉了，没有$dp$它，而第六个点的点$(1,1)$就是障碍物。所以需要特判掉。

全部代码（有点冗长）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1001][1001][2];
int n,m,a[1001][1001];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			char ch;
			cin>>ch;
			a[i][j]=(ch=='#');
		}
	}
	if(a[n][m]==1||a[1][1]==1){
		puts("-1");
		return 0;
	}
	for(int i=0;i<=n;++i)
		for(int j=0;j<=m;++j)
			for(int k=0;k<2;++k)
				dp[i][j][k]=-1;
	dp[1][1][1]=dp[1][1][0]=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[i][j])continue;
			if(i==1&&j==1)continue;
			if(i==1){
				dp[i][j][0]=dp[i][j-1][0];
				continue;
			}
			if(j==1){
				dp[i][j][1]=dp[i-1][j][1];
				continue;
			}
			if(~dp[i-1][j][1])dp[i][j][1]=max(dp[i-1][j][1],dp[i][j][1]);
			if(~dp[i-1][j][0])dp[i][j][1]=max(dp[i][j][1],dp[i-1][j][0]+1);
			if(~dp[i][j-1][0])dp[i][j][0]=max(dp[i][j][0],dp[i][j-1][0]);
			if(~dp[i][j-1][1])dp[i][j][0]=max(dp[i][j][0],dp[i][j-1][1]+1);
		}
	}
	printf("%d ",max(dp[n][m][0],dp[n][m][1]));
	for(int i=0;i<=n;++i)
		for(int j=0;j<=m;++j)
			for(int k=0;k<2;++k)
				dp[i][j][k]=2147483647;
	dp[1][1][1]=dp[1][1][0]=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[i][j])continue;
			if(i==1&&j==1)continue;
			if(i==1){
				dp[i][j][0]=dp[i][j-1][0];
				continue;
			}
			if(j==1){
				dp[i][j][1]=dp[i-1][j][1];
				continue;
			}
			if(dp[i-1][j][0]!=2147483647)dp[i][j][1]=min(dp[i][j][1],dp[i-1][j][0]+1);
			if(dp[i-1][j][1]!=2147483647)dp[i][j][1]=min(dp[i][j][1],dp[i-1][j][1]);
			if(dp[i][j-1][0]!=2147483647)dp[i][j][0]=min(dp[i][j][0],dp[i][j-1][0]);
			if(dp[i][j-1][1]!=2147483647)dp[i][j][0]=min(dp[i][j][0],dp[i][j-1][1]+1); 
		}
	}
	cout<<min(dp[n][m][1],dp[n][m][0])<<endl;
	return 0;
}
```
代码中犯的错误：转移方向没有确定好导致转移错了，转了两个方向四种可能，这是错误的，因为一个向下走的点不可能由一个向右走的转移过来。

笔者太菜，$dp$极差，有误的地方也烦请各位大佬指出，不胜感激。不懂的地方可以私信我。

---

## 作者：Jansec (赞：2)

#### 这是一篇~~调了很多次才对的~~题解########### 
首先，读题可知：

拐弯次数最多一定就是能拐就拐，次数最少就是能不拐就不拐


------------
好的上面的是废话……

由题意知最好的情况只会向下或向右走

首先定义fmin[i][j][0/1],fmax[i][j][0/1]两个用来dp转移的数组


分别表示

fmin[i][j][0/1]为当坐标为（i,j）时方向向下/向右走的拐弯最小次数

fmax[i][j][0/1]为当坐标为（i,j）时方向向下/向右走的拐弯最大次数


------------


当fmin/fmax[i][j][0]时，要由（i,j）上方的点转移而来，则：

**fmin[i][j][0]=min(fmin[i-1][j][0],fmin[i-1][j][1]+1);**

**fmax[i][j][0]=max(fmax[i-1][j][0],fmax[i-1][j][1]+1);**

当fmin/fmax[i][j][1]时，要由（i,j）上方的点转移而来，则：

**fmin[i][j][1]=min(fmin[i][j-1][1],fmin[i][j-1][0]+1);**

**fmax[i][j][1]=max(fmax[i][j-1][1],fmax[i][j-1][0]+1);**


------------

所以  代码↓

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int m,n;
int fmin[1010][1010][3],fmax[1010][1010][3];//fmin维护最小拐弯次数的路径  fmax维护最大拐弯次数的路径 
char ch[1010][1010];//ch数组存图 
int main()
{
	scanf("%d%d",&m,&n);//读入m,n 
	for(int i=1;i<=m;i++)
	  for(int j=1;j<=n;j++)
	    {
	    	cin>>ch[i][j];
	    	fmin[i][j][0]=fmin[i][j][1]=999999999;
	    	fmax[i][j][0]=fmax[i][j][1]=-1;//对fmin和fmax数组进行初始化 
		}
	for(int i=1;i<=m;i++)//将第一列的fmin和fmax进行单独初始化 
	  if(ch[i][1]!='#')  
	    {
	    	fmin[i][1][1]=fmax[i][1][1]=1;//这里要是1，调了半天
	    	fmin[i][1][0]=fmax[i][1][0]=0;
		}
		else  break;
	for(int i=1;i<=n;i++)//将第一行的fmin和fmax进行单独初始化 
	  if(ch[1][i]!='#')
	    {
	    	fmin[1][i][0]=fmax[1][i][0]=1;
	    	fmin[1][i][1]=fmax[1][i][1]=0;
		}
		else  break;
	for(int i=2;i<=m;i++)
	  for(int j=2;j<=n;j++)
	    {
	    	if(ch[i][j]!='#')
	    	  {
	    	  	fmin[i][j][0]=min(fmin[i-1][j][0],fmin[i-1][j][1]+1);
	    	  	fmin[i][j][1]=min(fmin[i][j-1][1],fmin[i][j-1][0]+1);
	    	  	fmax[i][j][0]=max(fmax[i-1][j][0],fmax[i-1][j][1]+1);
	    	  	fmax[i][j][1]=max(fmax[i][j-1][1],fmax[i][j-1][0]+1);
			  }//如果没有障碍物，则进行状态转移 
			  else
			    {
			    		fmin[i][j][0]=fmin[i][j][1]=999999999;
				    	fmax[i][j][0]=fmax[i][j][1]=-1;
				}//若有障碍物，则再次进行初始化 
		}
	if((fmin[m][n][0]==999999999&&fmin[m][n][1]==999999999)||(fmax[m][n][0]==-1&&fmax[m][n][1]==-1))
	  cout<<"-1";//判断能否到达 
	  else  cout<<max(fmax[m][n][0],fmax[m][n][1])<<" "<<min(fmin[m][n][0],fmin[m][n][1])<<endl;
	return 0;
}
```

借此纪念调了半天的程序

---

## 作者：zhenglier (赞：2)

终于调好这道题了，来一发题解，顺便感谢一下神佬[Imakf](https://www.luogu.org/space/show?uid=47863)的帮助。

# 进入正题

这题我开始想用广搜过了这道题，但马上就发现我的算法是错误的。后来看到线只能向下和向右~~迷宫对此表示不服~~，我就发现这题其实可以用动态规划。

我们用$mx[i][j][0/1]$表示在第$i$,$j$个位置，方向向下/向右（我们设0为下，1为右）时~~最秀的操作~~最多的拐弯次数。

易知，如果当前点有障碍，则当前点的值一定不会更新，直接跳过。

对于其他的点，我们用上面的点更新他的0状态，用左边的点更新他的1状态。

方程也很好得出了：

$mx[i][j][0]=min(mx[i-1][j][0],mx[i-1][j][1]+1)$
$mx[i][j][1]=min(mx[i][j-1][1],mx[i][j-1][0]+1)$

对于mn，我们可以用同样的方法得出。

# 讲一下我被坑了很多次的地方

对于骗分者来说，-1的那10分很好拿，但我挂了很多次，因为那个数据在（1，1）那个点放了一个障碍物，但我在直接初始化了（1，1），所以跳过了这个障碍。对此，我就写了一个dfs判了一下-1，当然也有更好的方法

# 代码

可以尝试copy，但后果自负
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char mp[1010][1010];
long long mx[1010][1010][2],mn[1010][1010][2];
int v[1010][1010];
const int dx[]={0,0,1};
const int dy[]={0,1,0};
void dfs(int x,int y){
	if(mp[x][y]=='#')return;
	v[x][y]=1;
	for(int i=1;i<=2;++i){
		int nx=x+dx[i],ny=y+dy[i];
		if(v[nx][ny]||nx>n||nx<1||ny>m||ny<1)continue;
		dfs(nx,ny);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>mp[i][j];
		}
	}
	dfs(1,1);
	if(!v[n][m]){
		puts("-1");
		return 0;
	}
	memset(mx,0x80,sizeof mx);
	memset(mn,0x3f,sizeof mn);
	mx[1][1][0]=mx[1][1][1]=mn[1][1][0]=mn[1][1][1]=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			if(mp[i][j]=='#')continue;
			if(i>1){
				mx[i][j][0]=max(mx[i][j][0],mx[i-1][j][0]);
				mx[i][j][0]=max(mx[i][j][0],mx[i-1][j][1]+1);
				mn[i][j][0]=min(mn[i][j][0],mn[i-1][j][0]);
				mn[i][j][0]=min(mn[i][j][0],mn[i-1][j][1]+1);
			}
			if(j>1){
				mx[i][j][1]=max(mx[i][j][1],mx[i][j-1][1]);
				mx[i][j][1]=max(mx[i][j][1],mx[i][j-1][0]+1);
				mn[i][j][1]=min(mn[i][j][1],mn[i][j-1][1]);
				mn[i][j][1]=min(mn[i][j][1],mn[i][j-1][0]+1);
			}
		}
	}
//	puts("-1");
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cout<<'{'<<mn[i][j][0]<<','<<mn[i][j][1]<<'}';
		}puts("");
	}
	cout<<max(mx[n][m][0],mx[n][m][1])-1<<' '<<min(mn[n][m][0],mn[n][m][1])<<endl;
}
```

---

## 作者：Adove (赞：1)

这题遇到不能走的位置直接置极大极小值就好了

当然要先判一波能不能到达

这样的技巧在棋盘类型DP里非常常见

至于DP的方式dalao们都说过了

刚刚这题突然变紫题了~~比赛的时候我觉得也顶多就是个绿题啊~~

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1005;

int n,m;
char ch[MAXN];
int f[2][2][MAXN][MAXN];//0 down;1 right
bool ct[MAXN][MAXN],can[MAXN][MAXN];

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i){
        scanf("%s",ch+1);
        for(int j=1;j<=m;++j){
            if(ch[j]=='o') ct[i][j]=1;
        }
    }can[1][1]=ct[1][1];
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            can[i][j]|=can[i-1][j]|can[i][j-1];
            if(!ct[i][j]) can[i][j]=0;
        }
    }if(!can[n][m]){puts("-1");return 0;}
    for(int i=1;i<=m;++i) f[0][0][1][i]=-99999,f[0][1][1][i]=99999,f[1][0][1][i]=can[1][i]?0:-99999,f[1][1][1][i]=can[1][i]?0:99999;
    for(int i=1;i<=n;++i) f[1][0][i][1]=-99999,f[1][1][i][1]=99999,f[0][0][i][1]=can[i][1]?0:-99999,f[0][1][i][1]=can[i][1]?0:99999;
    f[0][0][1][1]=f[0][1][1][1]=f[1][0][1][1]=f[1][1][1][1]=0;
    for(int i=2;i<=n;++i){
        for(int j=2;j<=m;++j){
            if(!ct[i][j]){f[0][0][i][j]=f[1][0][i][j]=-99999,f[0][1][i][j]=f[1][1][i][j]=99999;continue;}
            f[0][0][i][j]=max(f[0][0][i-1][j],f[1][0][i-1][j]+1),f[0][1][i][j]=min(f[0][1][i-1][j],f[1][1][i-1][j]+1);
            f[1][0][i][j]=max(f[0][0][i][j-1]+1,f[1][0][i][j-1]),f[1][1][i][j]=min(f[0][1][i][j-1]+1,f[1][1][i][j-1]);
            
        }
    }printf("%d %d\n",max(f[0][0][n][m],f[1][0][n][m]),min(f[0][1][n][m],f[1][1][n][m]));
    return 0;
}
```

---


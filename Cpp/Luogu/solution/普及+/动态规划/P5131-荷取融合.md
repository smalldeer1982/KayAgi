# 荷取融合

## 题目背景

作为一款Rougelike类游戏，TODR具有丰富的装备系统。每一款装备独特的外观和华丽的特效，上百种各有效果的印记，复杂的炼成调和分解融合系统都塑造了这款游戏极高的游戏性。    

现在你的装备刷到了满级，需要和其他装备融合来继续成长，当然，你需要让河城荷取将你原装备中的印记抽取出来以便和新装备合成。 

## 题目描述

已知原装备有 $n$ 个印记槽，每个印记槽中有无限多的一种印记，第 $i$ 个印记槽中的这种印记价值为 $a_{i}$。     

河城荷取会用机械臂抽取印记槽内的印记，每一次抽取时，机械臂会向下抓取，从正下方的印记槽中抽取出一个印记，之后机械臂会向右移动或停留在原地(如果移动，那么可以移动任意格)，开始时机械臂的位置任意，但是任意时刻机械臂都必须在某个印记槽上。  

河城荷取会进行 $k$ 次抓取，抓取结束后，你获得的总收益等于抓上来的 $k$ 个印记价值的乘积。

假设河城荷取进行的一切操作都是随机的，那么你能获得的收益的平均值是多少呢?  

由于答案可能不是整数，你只需输出答案对 $\text{19260817}$ 取模后的结果。  

## 说明/提示

#### 样例 $1$ 解释:  

机械臂开始可以停在三个槽上方。  

先后抓取的印记槽的位置可以是 $(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)$ 六种,每一种抓取方案的收益分别是 $9,3,6,1,2,4$ ，平均值为 $\frac{25}{6}$，在 $ \text{mod 19260817}$ 的意义下等于 $16050685$   


#### 数据范围:  

$a_{i}<19260817$  

![](https://cdn.luogu.com.cn/upload/pic/42182.png)   

## 样例 #1

### 输入

```
3 2
3 1 2```

### 输出

```
16050685```

## 样例 #2

### 输入

```
6 3
1 1 4 5 1 4```

### 输出

```
16509294```

# 题解

## 作者：离散小波变换° (赞：11)

## 题目大意

$n$个数中选择$k$个（可以重合），求这$k$个数的乘积的期望。

## 题解

很显然，这个问题可以拆分为两部分：**求方案总数**，以及**求所有方案的贡献和**。

### 求方案总数

我们设$F_{i,j}$表示前$i$个数中，选择$j$个数的方案。那么考虑第$i$个数如何处理。

- $1.$不选择第$i$个数。它的方案总数为$F_{i-1,j}$。

- $2.$选择第$i$个数。它的方案总数为$F_{i,j-1}$。

那么有：

$$F_{i,j}=F_{i-1,j}+F_{i,j-1}$$

### 求贡献和

同样地，我们定义$G_{i,j}$表示前$i$个数中，选择$j$个数的贡献总和。与上文类似，考虑第$i$个数的情况。

- $1.$不选择第$i$个数。这一部分的贡献总和为$G_{i-1,j}$。

- $2,$选择第$i$个数。这一部分的贡献总和为$G_{i,j-1}\times A_i$。

也就是说，

$$G_{i,j}=G_{i-1,j}+G_{i,j-1}\times A_i$$


最后的答案为$\frac{G_{n,k}}{F_{n,k}}$。用快速幂求出$F_{n,k}$的逆元即可。

### 空间优化

开$\mathcal O(n\times k)$的空间会爆炸。因此考虑滚动数组优化。

$F_{i,x},G_{i,x}$的值只和$F_{i-1,x}$和$G_{i-1,x}$的值相关。因此我们只需要保留上一个枚举到的$i$即可。具体的实现中，我们只需要用布尔变量$o$表示当前所用的数组，而$\operatorname{not} o$表示上一个枚举到的$i$时所用的数组。每次枚举完$i$，就令$o\gets \operatorname{not} o$即可。

时间复杂度$\mathcal O(n\times k)$，空间复杂度$\mathcal O(k)$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
const int MOD =19260817;
const int MAXN =1e5+3,MAXK=300+3;
int F[2][MAXK],G[2][MAXK],P[MAXN];
int n,k; bool o;
int pwr(int x,int y){
    int ret=1,t=x; while(y){
        if(y&1) ret=(LL)ret*t%MOD; y>>=1,t=(LL)t*t%MOD;
    }
    return ret;
}
int main(){
    n=qread(),k=qread(); up(1,n,i) P[i]=qread();
    F[!o][0]=1;
    up(1,n,i){
        F[o][0]=1; up(1,k,j)F[o][j]=(F[!o][j]+F[o][j-1])%MOD;
        G[o][0]=1; up(1,k,j)G[o][j]=((LL)G[!o][j]+(LL)G[o][j-1]*P[i])%MOD;
        o=!o;
    }
    printf("%d\n",(LL)G[!o][k]*pwr(F[!o][k],MOD-2)%MOD);
    return 0;
}
```

---

## 作者：Leianha (赞：4)

## DP

[博客阅读](https://www.cnblogs.com/wljss/p/12534475.html)

一个值得思考的 $DP$ 题。

设 $f[i][j]$ 为前 $i$ 个中选了 $j$ 次的方案数， $g[i][j]$ 为前 $i$ 个中选了 $j$ 次的所有方案的价值积的和。枚举上一个选取的位置和次数即可.

$O(n^2k^2)$ $20$分 空间也会爆炸

```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n, k;
LL tot, sum;
const int N = 100010, mod = 19260817;
int a[N];
LL f[N][305], g[N][305];
LL ksm(LL a, LL b, LL mod)
{
	LL res = 1;
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1)res = res * a % mod;
	return res;
}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	f[0][0] = 1; g[0][0] = 1;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= k; ++j)
			for (int l = 0; l < i; ++l)
				for (int o = 0; o < j; ++o)(f[i][j] += f[l][o]) %= mod;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= k; ++j)
			for (int l = 0; l < i; ++l)
				for (int o = 0; o < j; ++o)(g[i][j] += g[l][o] * ksm(a[i], j - o, mod)) %= mod;
	for (int i = 1; i <= n; ++i)(tot += f[i][k]) %= mod, (sum += g[i][k]) %= mod;
	cout << sum*ksm(tot, mod - 2, mod) % mod;
	return 0;
}
```
发现枚举上一个位置并没有什么用，记录一下前缀和就行了。

另外空间也只需要一维就行。

$O(nk^2)$ $70$分
```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n, k, now;
LL tot, sum;
const int N = 100010, mod = 19260817;
int a[N];
LL f[305], g[305], F[305], G[305];
LL ksm(LL a, LL b, LL mod)
{
	LL res = 1;
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1)res = res * a % mod;
	return res;
}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	F[0] = G[0] = 1; now = 1;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = k; j >= 1; --j)
		{
			f[j] = g[j] = 0;
			for (int o = 0; o < j; ++o)(f[j] += F[o]) %= mod;
			(F[j] += f[j]) %= mod;
			for (int o = 0; o < j; ++o)(g[j] += G[o] * ksm(a[i], j - o, mod)) %= mod;
			(G[j] += g[j]) %= mod;
		}
		(tot += f[k]) %= mod; (sum += g[k]) %= mod;
	}
	cout << sum*ksm(tot, mod - 2, mod) % mod;
	return 0;
}
```
发现循环$o$的含义就是类似于前缀和，差分一下就行。（$g$ 的差分需要将快速幂拆开）

$O(nk)$ $80$分
```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n, k, now;
LL tot, sum;
const int N = 100010, mod = 19260817;
int a[N];
LL f[305], g[305], F[305], G[305], S[305];
LL ksm(LL a, LL b, LL mod)
{
	LL res = 1;
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1)res = res * a % mod;
	return res;
}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	F[0] = G[0] = S[0] = 1; now = 1;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= k; ++j)f[j] = (f[j - 1] + F[j - 1]) % mod;
		for (int j = 1; j <= k; ++j)(F[j] += f[j]) %= mod;
		for (int j = 1; j <= k; ++j)S[j] = (S[j - 1] + G[j] * ksm(ksm(a[i], mod - 2, mod), j, mod)) % mod;
		for (int j = 1; j <= k; ++j)g[j] = ksm(a[i], j, mod) * S[j - 1] % mod;
		for (int j = 1; j <= k; ++j)(G[j] += g[j]) %= mod;
		(tot += f[k]) %= mod; (sum += g[k]) %= mod;
	}
	cout << sum*ksm(tot, mod - 2, mod) % mod;
	return 0;
}
```
上面的方法虽然时间复杂度对了，但由于快速幂跑的慢，递推省掉快速幂就行了。

$O(nk)$ $100$分
```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n, k;
LL tot, sum;
const int N = 100010, mod = 19260817;
int a[N];
int f[305], g[305], F[305], G[305], S[305];
inline int ksm(int a, LL b)
{
	int res = 1;
	for (; b; b >>= 1, a = (LL)a * a % mod)
		if (b & 1)res = (LL)res * a % mod;
	return res;
}
inline int work(int x) {return x >= mod ? x - mod : x;}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	F[0] = G[0] = S[0] = 1;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= k; ++j)f[j] = work(f[j - 1] + F[j - 1]);
		for (int j = 1; j <= k; ++j)F[j] = work(F[j] + f[j]);
		for (int j = 1, inv = ksm(a[i], mod - 2), now = 1; j <= k; ++j)now = (LL)now * inv % mod, S[j] = work(S[j - 1] + (LL)G[j] * now % mod);
		for (int j = 1, now = 1; j <= k; ++j)now = (LL)now * a[i] % mod, g[j] = (LL)now * S[j - 1] % mod;
		for (int j = 1; j <= k; ++j)G[j] = work(G[j] + g[j]);
		tot = work(tot + f[k]); sum = work(sum + g[k]);
	}
	cout << sum*ksm(tot, mod - 2) % mod;
	return 0;
}
```

---

## 作者：漠寒 (赞：2)

## 分析

首先看数据范围就知道这应该是一个 $O(nk)$ 的题。考虑 dp。

用 $f[i][j]$ 表示抓取了 $i$ 个，最后一个是 $j$ 的答案之和，$g[i][j]$ 表示有多少种不同的抓取方案，最后答案就是所有满足要求的 $f$ 之和除以对应的 $g$。

转移时，因为你可以从上一个抓取往右边跑，所以你只会从比 $j$ 小的地方转移到 $f[i][j]$ 和 $g[i][j]$。所以在循环的同时用两个数分别记录 $f$ 和 $g$ 的前缀和即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod=19260817;
inline int qpow(int ds,int zs){
	int x=1;
	while(zs){
		if(zs&1)x=1ll*x*ds%mod;
		ds=1ll*ds*ds%mod;zs>>=1;
	}
	return x;
}
inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
	res*=f;
}
int n,k;
int ti;
int a[100005],f[2][100005],g[2][100005],b[100005],bb[100005];
//只有128MB，所以要滚动数组 
signed main()
{
	f[0][1]=1;
	g[0][1]=1;
	read(n);read(k);
	for(int i=1;i<=n;i++)read(a[i]);
	for(int i=1;i<=k;i++){
		ti^=1;
		memset(f[ti],0,sizeof(f[ti]));
		memset(g[ti],0,sizeof(g[ti]));
		for(int j=1;j<=n;j++){
			b[j]=(b[j-1]+f[ti^1][j])%mod;//其实一个数就行了，不需要开数组 
			bb[j]=(bb[j-1]+g[ti^1][j])%mod;
			f[ti][j]=b[j]*a[j]%mod;
			g[ti][j]=bb[j];
		}
	}
	int sum=0,cnt=0;
	for(int i=1;i<=n;i++){
		sum=(sum+f[ti][i])%mod;
		cnt=(cnt+g[ti][i])%mod;
	}
	cout<<(sum*qpow(cnt,mod-2)%mod);
	return 0;
}

```


---

## 作者：404Not_Found (赞：1)

比较简单的 dp。

首先这里的期望相当于所有方案的权值总和减去方案数，之后就是简单的 dp 了。

设 $f(i,j)$ 为前 $i$ 个数选了 $j$ 次的方案数，$g(i,j)$ 为权值和，转移很简单：

$$\begin{cases} f(i,j)=f(i-1,j)+f(i,j-1) \\g(i,j)=g(i-1,j)+g(i,j+1) \times a_i\end{cases}$$

最后的答案为 $\dfrac{g(i,j)}{f(i,j)}$，因为要取模，所以还要求个逆元。

注意到 $f(i,j),g(i,j)$ 都是从 $i-1$ 处转移过来，所以可以用滚动数组优化。

时间复杂度：$\mathcal{O}(nk)$，空间复杂度：$\mathcal{O}(n+k)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;
const int MAXK = 305;
const long long P = 19260817;
#define LL long long
int n,k,a[MAXN];
LL f[2][MAXK],g[2][MAXK];
LL power(LL a,LL b)
{
	LL ret=1;
	for(;b;b>>=1,a=(a*a)%P) if(b&1) ret=(ret*a)%P;
	return ret;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	f[1][0]=f[0][0]=g[1][0]=g[0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k;j++)
		{
			f[i&1][j]=(f[i&1^1][j]+f[i&1][j-1])%P;
			g[i&1][j]=(g[i&1^1][j]+g[i&1][j-1]*a[i]%P)%P;
		}
	printf("%lld\n",g[n&1][k]*power(f[n&1][k],P-2)%P);
}
```

---

## 作者：Mars_Dingdang (赞：1)

基础贡献计算动态规划。

## 题目大意
给定 $n$ 个数 $a_i$，每次可重复地随机选出 $k$ 个数，求这 $k$ 个数地乘积的平均值（期望）。

$n\le 10^5, k\le 300$。

## 大体思路
考虑期望计算方式：用总和除以总方案数。故只需计算出乘积的总和以及总的方案数即可。可以利用动态规划。

具体地，令 $F[i, j]$ 表示前 $i$ 个数随机选 $j$ 个的方案数。若第 $i$ 个数不选，则相当于前 $i-1$ 个选 $j$ 个；若第 $i$ 个数选，则相当于前 $i$ 个还要选 $j-1$ 个，故 $F[i, j]=F[i-1, j]+F[i, j-1]$。

同理，令 $G[i, j]$ 表示前 $i$ 个数随机选出 $j$ 个的乘积的总和。利用上述方式对选不选进行讨论可得，$G[i, j]=G[i-1, j]+G[i, j-1]\times a_i$。

边界条件：对于所有 $j=0$，$F[i, 0]=G[i, 0]=1$；特殊地，$F[0, 0]=1$。同时，由于 $i$ 的转移只与 $i-1$ 有关，可以用滚动数组优化空间，即用 `F[i&1][j]` 限制第一维。

最终答案为 $\dfrac {G[n, k]}{F[n, k]}$。由于 $19260817$ 是质数，可以利用费马小定理与快速幂求出逆元。注意动态规划状态转移时及时取模。时间复杂度 $O(nk)$。空间复杂度 $O(n)$，若不储存 $a_i$ 可以降为 $O(k)$。

## 完整代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5;
const ll mod = 19260817;
inline ll Pow(ll a, ll b) {
	ll ans = 1;
	while(b) {
		if(b & 1) ans = (ans * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return ans % mod;
}
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll n, a[maxn], F[2][maxn], k, G[2][maxn];
int main () {
	read(n); read(k);
	rep(i, 1, n) read(a[i]);
	F[0][0] = 1;
	rep(i, 1, n) {
		F[i & 1][0] = 1; // 边界
		rep(j, 1, k) F[i & 1][j] = (F[(i - 1) & 1][j] + F[i & 1][j - 1]) % mod;	// 滚动数组优化
		G[i & 1][0] = 1;
		rep(j, 1, k) G[i & 1][j] = (G[(i - 1) & 1][j] + G[i & 1][j - 1] * a[i]) % mod;
	}
	writeln((G[n & 1][k] * Pow(F[n & 1][k], mod - 2)) % mod); // 逆元
	return 0;
}
```

---

## 作者：koishi_offical (赞：0)

### 题目大意
从 $n$ 个数中随机选 $k$ 个可以重复的数，其权值为 $k$ 个数的乘积，求权值的期望。

### 解法
我们先将要求结果分成两部分:

1 . 所有方案的权值总和。

2 . 方案数。

考虑 dp ，设 $f(i,j)$ 为前 $i$ 个数中选 $j$ 次的方案数，$dp(i,j)$ 为前 $i$ 个数中选 $j$ 次的所有方案的权值总和。

最终答案即为 $\frac{dp(n,k)}{f(n,k)}$ .

#### 状态转移方程

对于 $f$ 来说，每次有两种方式到达 $f(i,j)$ ，从左面过来或者再抓取一个，因此可得状态转移方程为：
   
   $f(i,j)=f(i-1,j)+f(i,j-1)$

对于 $dp$ 来说，从左面过来的不会选取数字，因此直接统计即可，再抓取一个的，需要乘上 $a(i)$ 再统计进去。 综上，状态转移方程为：

  $dp(i,j)=dp(i-1,j)+dp(i,j-1)\times a(i)$
  
#### 优化

可以看到每次状态转移方程第一维只和 $i$ 和 $i-1$ 有关，因此我们可以用滚动数组滚掉第一维。

#### 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=19260817;
const int N=1e5+10,K=310;
int n,k;
int a[N],f[2][K],dp[2][K];
int quickpow(int a,int b)
  {
      int ans=1,x=a;
      while(b)
        {
            if(b&1) ans=ans*x%mod;
            b>>=1;
            x=x*x%mod;
        }
      return ans;
  }
signed main() {
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    f[0][0]=f[1][0]=1;
    dp[0][0]=dp[1][0]=1;
    for(int i=1;i<=n;i++)
     {
      for(int j=1;j<=k;j++)
        {
            f[i&1][j]=(f[i&1][j-1]+f[i&1^1][j])%mod;
            dp[i&1][j]=(dp[i&1^1][j]+dp[i&1][j-1]*a[i])%mod;
        }
     }
   cout<<(dp[n&1][k]*quickpow(f[n&1][k],mod-2))%mod;
}
```


---


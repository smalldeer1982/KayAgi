# 蜈蚣

## 题目背景

一群人在山上遇见了一条蜈蚣。

## 题目描述

在一条山路的转角处，WYH 发现了一条有中指一样粗的有 $N$ 节的蜈蚣。这只蜈蚣马上就吸引了 HKE 的眼球，HKE 深深地爱上了这条魔性的蜈蚣。它的很多对足在前进的时候像波浪一样，颇是有毒。

但是，热爱解剖动物的 MZL 却准备把蜈蚣切了。HKE 很失落，于是 MZL 承诺不会完全肢解它，只把它的 $N$ 节切成 $M$ 段，每一段包含原蜈蚣完整的一节或多节。

HKE 看到他心爱的蜈蚣会切掉是会觉得恶心的。蜈蚣的每一节都有一个权值 $W_i$，切下来的一段 $(W_i, W_{i + 1}, \ldots, W_j)$ 带给 HKE 的恶心值是 $W_i \mathbin{\mathrm{xor}} W_{i + 1} \mathbin{\mathrm{xor}} \cdots \mathbin{\mathrm{xor}} W_j$，这里的 $\mathbin{\mathrm{xor}}$ 代表按位异或操作。邪恶的 LJC 希望 HKE 受到的总恶心值 —— 也就是每一段子蜈蚣带给 HKE 的恶心值的和最大，请你求出 HKE 的最大恶心值。

（注：按位异或，其运算符号在 Pascal 中为 `xor`，在 C++ 中为 `^` 或 `xor`；请注意加法与异或运算的优先级先后顺序）

## 说明/提示

**【样例解释 \#1】**

第一段的恶心值为 $1 \mathbin{\mathrm{xor}} 2 = 3$。

第二段的恶心值为 $3 \mathbin{\mathrm{xor}} 4 = 7$

第三段的恶心值为 $5$

总恶心值为 $3 + 7 + 5 = 15$。此时为最优解。

**【数据范围】**

对于 $30 \%$ 的数据，$1 \le N \le 100$，$1 \le M \le 10$；

对于 $100 \%$ 的数据，$1 \le N \le 1000$，$1 \le M \le 100$，保证结果在 $2^{30} - 1$ 内；


## 样例 #1

### 输入

```
5 3
1 2 3 4 5
```

### 输出

```
15
```

# 题解

## 作者：Del_Your_Heart (赞：8)

[珂能更好的阅读体验(?)](https://62246.blog.luogu.org/solution-p5144)

# 题目大意：
### 给你一段长度为$n$的数组，让你分成$m$段，使其每段的异或和的总和最大。

------------

# 区间$DP$
很明显，这题是一个区间$DP$的题，因为它满足区间DP的性质：
**珂以由小的区间最优解得到更大的区间最优解**（满足区间可合并性）

区间$DP$一般分为三个部分：

### $1^o$ 状态：
对于本题，状态为区间起点，区间终点和分段次数。为了方便起见，我设置的状态为 **$f[i][j]$ 表示从 $1-i$ 这段区间分为 $j$ 段所能得到的最大异或和**。

有的人可能会质疑本蒟蒻：为什么不设置**区间起点**呢？

其实我一开始的状态为 **$f[i][j][k]$ 表示从 $i-j$ 这段区间分为 $k$ 段所能得到的最大异或和**，然鹅最后放弃了。

原因有两点：**1.空间复杂度高，空间效率低下；2.状态转移方程不好写，思维难度大。** 所以说，选择好的状态**珂以提高程序效率，降低思维难度，使代码简洁易懂易调试，不易写挂**。(像我这样的蒟蒻，写稍长一点的代码就调到自闭，心态炸裂)

### $2^o$ 状态转移方程：
既然我们已经确定了状态，就让我们来简单地(~~话说真的十分简单~~)推一下**状态转移方程**。

考虑用靠前的区间去更新靠后的区间，我们有
>$f[j][c+1]=max(f[j][c+1],f[i][c]+(sum[j]$ $xor$ $sum[i]))$

其中
>$sum[i]=a[1]$ $xor$ $a[2]$ $xor$ …… $xor$ $a[i]$，$c$为区间个数

时间复杂度为$O(n^2*m)$，对于$n<=1000,m<=100$的数据珂以完美过掉

### $3^o$ 初始化与边界条件：
显而易见的有$f[i][1]=sum[i]$。

而边界条件也很显然：$i,j \in [1,n],c \in [1,m]$

------------

## 到这里我们已经珂以尝试写出完整代码了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[1005][105],sum[1005];
inline int read(){
    int x=0,f=0;char ch=getchar();
    while(!isdigit(ch)){
        f|=ch=='-';
        ch=getchar();
    }
    while(isdigit(ch)){
        x=x*10+(ch^48);
        ch=getchar();
    }
    return f?-x:x;
}//快读
int main(){
    n=read();m=read();
    for(register int *i=sum+1;i<=sum+n;++i)
        *i=read()^*(i-1);//读入，处理前缀异或
    for(register int i=1;i<=n;++i)
        f[i][1]=sum[i];//初始化
    for(register int c=1;c<=m;++c)
        for(register int i=1;i<=n;++i)
            for(register int j=i;j<=n;++j)
                f[j][c+1]=max(f[j][c+1],f[i][c]+(sum[j]^sum[i]));//更新区间
    cout<<f[n][m];
    return 0;
}//手打一遍过，不用调来调去，真爽
```























---

## 作者：jiangXxin (赞：6)

一道比较简单的DP

考虑我们的DP状态：

**1.我们当前正在处理第i节蜈蚣**

**2.我们已经把蜈蚣分成了j段**

这个状态可以用一个dp数组$dp_{i,j}$来表示.

考虑状态转移，因为我们的状态有把蜈蚣分成j段，所以我们从j-1段开始转移.

那么我们就可以得到转移方程:

$dp[i][j]=max(dp[i][j],dp[k][j-1]+sum[k]$^$sum[i])(k<i)$

**code:**

**c++:**
```cpp
/**
*    author:  a2954898606
*    created: 2019/10/25 09:34:26
**/
#include<bits/stdc++.h>
#define REP(A,B,I) for(int I=(A);I<=(B);I++)
#define PER(A,B,I) for(int I=(A);I>=(B);I--)
#define read(FILENAME) freopen((FILENAME + ".txt"), "r", stdin);
#define write(FILENAME) freopen((FILENAME + ".txt"), "w", stdout);
#define LL long long
#define N 1000010
#define M 100
using namespace std;
const long long mod=1e9+7;
long long quickmul(long long a,long long b){
    a%=mod;b%=mod;
    long long c=(long long)a*b/mod;
    long long ret=a*b-c*mod;
    if(ret<0)ret+=mod;
    else if(ret>=mod)ret-=mod;
    return ret;
}
long long quickpow(long long a,long long b){
    long long ret=1;
    while(b){
        if(b&1)ret=ret*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ret;
}
long long exgcd(long long a,long long b,long long &x,long long &y){
    if(b==0){
        x=1;y=0;return a;
    }
    long long d=exgcd(b,a%b,x,y);
    long long z=x;x=y;y=z-y*(a/b);
    return d;
}
long long dp[1200][1200],sum[N];
int n,m;
int main(){
    //read(1)
    //write(1)
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n>>m;
    REP(1,n,i){
        int x;
        cin>>x;
        sum[i]=sum[i-1]^x;
    }
    REP(1,n,i)dp[i][1]=sum[i];
    REP(2,m,j){
        REP(1,n,k){
            REP(k,n,i){
                dp[i][j]=max(dp[i][j],dp[k][j-1]+(sum[k]^sum[i]));
            }
        }
    }
    cout<<dp[n][m]<<endl;
    return 0;
}

```
**python：**

```python
s=input().split()
n=int(s[0])
m=int(s[1])
dp=[[0 for i in range(1100)] for j in range(1100)]
sum=[0 for i in range(1100)]
s=input().split()
for i in range(n):
    sum[i+1]=sum[i]^int(s[i])
for i in range(1,n+1):
    dp[i][1]=int(sum[i])
for j in range(2,m+1):
    for k in range(1,n+1):
        for i in range(k,n+1):
            dp[i][j]=max(dp[i][j],dp[k][j-1]+(sum[k]^sum[i]))
print(dp[n][m])
```


---

## 作者：Fool_Fish (赞：3)

# 题目
[链接](https://www.luogu.com.cn/problem/P5144)

# 题解
首先，如果我们假设我们可以用O(1)的时间复杂度求得a[i] xor a[i+1] xor ... a[j]（区间xor）,那么这就是一道水题

令dp[i][j]表示前i节，切成j段的最大恶心值

那么我们枚举在哪里切(k)，则dp[i][j]=max(dp[i][j],dp[k][j-1]+...)
其中的...就是我们之前说的区间xor（k xor 到 i）

现在我们来解决这个问题
---

引理1：**a xor a=0**

证明：由xor的定义，比较每一位，相同则为0，反之为1
两个相同的数的每一位肯定也是相同的，即每一位xor后为0，所以最终为0
得证

---

引理2：**a xor 0=a**

证明：考虑a的每一位：

若这一位为1：1 xor 0=1
若这一位为0：0 xor 0=0

也就是每一位异或后都为原数，所以原数经过xor 0 后仍然等于原数

---

现在我们来推一推

假设s[i]=a[1] xor a[2] xor a[3] ... a[i]
       s[j]=a[1] xor a[2] xor a[3] ... a[j] (j<i)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201007195202948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RhbmZ1d2VuXw==,size_16,color_FFFFFF,t_70#pic_center)
我们来看看s[i]^s[j]会发生什么？

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201007195302733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RhbmZ1d2VuXw==,size_16,color_FFFFFF,t_70#pic_center)
首先，红框框住的部分全部xor后为0（引理1）

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020100719542154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RhbmZ1d2VuXw==,size_16,color_FFFFFF,t_70#pic_center)
然后，0和后面剩下的xor后就只剩下后面啦（引理2）

所以最终，s[i]^s[j]就等于a[j] xor a[j+1] xor a[j+2] xor.... xor a[i]

那么我们就可以用类似于前缀和的方式求出任意一段的xor 啦

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int MAXN=1005;
const int MAXM=105;
int dp[MAXN][MAXM];
int a[MAXN];
int s[MAXN];
int main(){
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		s[i]=s[i-1]^a[i];
	}
	for(int i=1;i<=n;i++){
		dp[i][1]=s[i];
	}
	for(int j=2;j<=m;j++){
		for(int k=1;k<=n;k++){
			for(int i=k;i<=n;i++){
				dp[i][j]=max(dp[i][j],dp[k][j-1]+(s[i]^s[k]));
			}
		}
	}
	printf("%d",dp[n][m]);
return 0;
}
```

---

## 作者：UperFicial (赞：2)

# 动态规划

**前言**

~~好水的 $\sout{dp}$，为数不多的能自己做出来的动规。~~

题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P5144)

**题意简述**

给定长度为 $n$ 的数列 $a$，将 $a_l$ 至 $a_r$ 分为一组的花费为 $\bigoplus_{i=l}^ra_i$，要求你划分成 $m$ 段使得每一段的花费总和最大。

**题目分析**

考虑动态规划，题目中涉及位置及段数，则定义状态为 $dp_{i,j}$ 表示到第 $i$ 个位置为止，已经划分了 $j$ 段的最大花费总和。

然后我们发现 $n$ 很小，可以在枚举一个 $k$ 表示第 $j-1$ 段的最后一个元素位置。

所以，我们目前的花费和即为到上一段位置的最小花费和加上这一段到第 $i$ 个花费，即为：

$$dp_{k,j-1}+\bigoplus_{p=k+1}^ia_i$$

如果暴力算异或和铁定超时，则考虑设 $s_i=\bigoplus_{k=1}^ia_k$，表示前 $i$ 个数的异或和。由于异或运算满足交换律和结合律，并且 $a \operatorname{xor} a=0$，则区间 $[l,r]$ 的异或和即为 $s_r\operatorname{xor} s_{l-1}$。

我们对于所有枚举的 $k$ 的贡献取最大值，则可以得到 $dp_{i,j}$ 的答案了，即：

$$dp_{i,j}=\max_{1\le k< i}{\{dp_{k,j-1}+\bigoplus_{p=k+1}^ia_i\}}$$

还要考虑 $dp$ 初始值，显然对于任何一个位置 $i$，到它这里为止只划分一段的贡献就是 $s_i$。即 $dp_{i,1}=s_i$。

不太懂为什么其它题解都是先枚举 $k$ 再枚举 $j$ 最后枚举 $i$，这个东西顺着枚举就好了吧。

时间复杂度：$O(n^2m)$，空间复杂度：$O(nm)$。

$\texttt{AC}$ 链接：[$\texttt{Link}$](https://www.luogu.com.cn/record/55754570)

[$\texttt{code}$](https://paste.ubuntu.com/p/hDCsFCxB2r/)

$$\texttt{The End.by UF}$$

---

## 作者：流逝丶 (赞：2)

区间DP题

是时候补补我的$dp$了，毕竟我太菜了。

首先是区间的异或，应该很容易想到前缀异或和

看到题目，区间转移，最大值，这不区间dp吗

很快想到状态$f[i][j]$，$i$表示已经分成了$i$段，$j$表示砍到了位置$j$

那么如何转移呢，区间DP最大的特点就是$3$层$for$，第二三层枚举的是区间端点，第一层枚举断点。

那么在这道题我们第一层显然是要枚举段数，

那么转移方程就有了$f[k+1][j]=max(f[k+1][j],f[k][i]+(sum[j]~\hat{ }~ sum[i])$

然后最终答案就是$f[m][n]$了

最后还有初始状态，$f[1][j]=sum[j]$因为前$j$个位置只有一段的话就是$1$~$j$的异或和

然后上代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1005,M=105;
int n,m,x;
int sum[N],f[M][N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		sum[i]=sum[i-1]^x;
	}
	for(int i=1;i<=n;++i)
		f[1][i]=sum[i];
	for(int k=1;k<=m;++k)
		for(int i=1;i<=n;++i)
			for(int j=i;j<=n;++j)
				f[k+1][j]=max(f[k+1][j],f[k][i]+(sum[j]^sum[i]));
	printf("%d\n",f[m][n]);
	return 0;
}
```


---

## 作者：ziiidan (赞：2)

一道不错的DP练手题

本篇博客中有说的不准确的地方望谅解，可以在评论区提出。

题目大意：

给您一个长度为 n 的序列，让您把它分成 m 段，每一段的价值定义为将这一段每一个数异或（xor）后得到的值，一种分段的方法的总价值定义为所有分出的段的价值之和，请您求出最大价值是多少。

这道题的动态规划做法很明显，我们的状态 **$f[i][j]$ 定义为把前 $ i $ 个数分成 $ j $ 段所能得到的最大价值** ，在此解释下这样做为什么满足DP的特征：

1、最优子结构：

对于最优解来说，它的每一个“小状态”都是相对最优的，满足最优子结构。

2、无后效性：

对于每一个状态的转移，我们当前的分段方法对我们接下来分段的时候获得的价值没有影响，满足无后效性。


综上所述，这道题满足DP的特征。

那么这道题的转移方程便不难得出：

$f[i][j] = max(f[i][j], f[pos][j - 1] + Xorval(pos + 1,i)$

在其中，$pos$ 是我们枚举的一个=可以进行合法转移的位置，$ Xorval(pos + 1,i)$表示把 $pos + 1$ 到 $i$ 的每一个数异或后得到的价值。

补充小知识：

$a$ $xor$ $b$ $xor$ $b$ $=$ $a$

证明的话自己手动模拟一下 0 和 1 的组合就可以发现。

利用这个小知识，我们可以经过$O(n)$的预处理后在$O(1)$的时间内查询区间的价值。

思路讲解到此告一段落，还有一些有疑问的地方的话可以参考一下本人的代码：

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

const int maxn = 1005;
const int maxm = 105;

int n, m;

int val[maxn];

int f[maxn][maxm];

inline int read(void)
{
	int s = 0, w = 1;
	char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') w = -1;
	for(; ch <= '9' && ch >= '0'; ch = getchar()) s = s * 10 + ch - '0';
	return s * w;
}

inline int XOR(int fr, int to)
{
	return val[to] ^ val[fr - 1];  // O(1)的查询，val维护的是异或前缀的价值，在讲解的小知识中有这样做的原理 
}

int main()
{
	n = read(); m = read();
	for(register int i = 1; i <= n; i++) val[i] = read();
	for(register int i = 2; i <= n; i++) val[i] = val[i - 1] ^ val[i]; // 维护异或前缀的价值 
	for(register int i = 1; i <= n; i++)
	{
		for(register int j = 1; j <= min(m, i); j++) // 在我们枚举的状态中，i 显然不可以分成大于 i 段，所以在两个限制中取一个更有力的限制 
		{
			if(j == 1) f[i][j] = max(f[i][j], XOR(1, i)); // 当分成一段的时候，特判一下，让转移方程更有意义 
			else for(register int pos = 1; pos < i; pos++) if(pos >= j - 1) f[i][j] = max(f[i][j], f[pos][j - 1] + XOR(pos + 1, i));
			// 枚举可以从哪些状态转移过来，当 pos < j - 1 ，即前pos个数分成了 j - 1 段，这种状态显然是不合法的，所以我们不能从这种不合法的状态转移过来 
		}
	}
	cout << f[n][m] << '\n';
	return 0;
}
```

如果有什么疑问的话直接发评论或者洛谷私信均可，本人看到后定会迅速回复。

谢谢阅读。


---

## 作者：Link_Space (赞：1)

很久之前做的 DP 来发一个题解。

很明显可以看出是一个区间 DP ，考虑如何设置状态。

由于此题涉及到分段，所以状态肯定和段数有关。

所以我们想到最直白的状态：$dp[i][j]$ 表示前 i 节总共分成 j 段。

状态设计完了，如何状态转移呢？？也是顺着常规套路走，枚举断点来达到状态转移的目的，状态转移方程即为： 

$dp[i][k + 1] = \max(dp[i][k + 1], dp[j][k] + (a[i] \operatorname{xor} a[j]));$

含义为：判断将 $j-i$ 分为一段会不会比现行答案更优。

代码也很简洁:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 1e3 + 5;
int dp[N][N];
int a[N];
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n;i++)
    {
        scanf("%d", &a[i]);
        a[i] ^= a[i - 1];
        dp[i][1] = a[i];
    }
    for (int i = 1; i <= n;i++)
        for (int j = 1; j < i;j++)
            for (int k = 1; k <= j;k++)
                dp[i][k + 1] = max(dp[i][k + 1], dp[j][k] + (a[i] ^ a[j]));
    printf("%d\n", dp[n][m]);
}
```


---

## 作者：moosssi (赞：1)

一道 $dp$ 水题，这种 $dp$ 题很套路，可以很容易想到思路。

定义 $f[i][k]$ 表示前 $i$ 个数分为 $k$ 段的最大恶心值.

对于每一位 $i$ ，枚举从前面第 $j$ 个位置转移，则 $i$ 到 $j$ 之间为新的一段。

预处理前缀异或可以快速求出 $i$ 到 $j$ 的异或值，这里还要枚举 $1$ 到 $j$ 之间分为几段。

转移方程为：$f[i][k+1]=max(f[i][k+1],f[j][k]+(a[i]$^$a[j]))$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int f[N][N],n,m,a[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[i]^=a[i-1];
		f[i][1]=a[i];
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++){
			for(int k=1;k<=j;k++){
				f[i][k+1]=max(f[i][k+1],f[j][k]+(a[i]^a[j]));
			}
		}
	}
	printf("%d",f[n][m]);
	return 0;
}
```


---

## 作者：MuYC (赞：1)

[$MYCui's$ $blog$](https://www.cnblogs.com/MYCui/p/13947754.html#WUGONG)
#### 水话
这道题确实是套路的$dp$，这里不仅仅讲一下这道题，顺便总结一下此类问题的套路

#### 题意简化

将长度为$n$的序列分为$m$段，得到的每一段计算段内异或和，最后将异或和相加，要求最终得到的值最大。(题目背景太ex了)

#### 做法:

**先介绍$dp$三步法：**

+ 划分子问题$and$设置状态。

+ 确定决策和状态转移方程。

+ 确定边界以及预处理减少时间复杂度。

#### 设立状态：

想到设立状态$dp[i][j]$表示前$i$个数字已经分成了$j$段得到的和。

**为什么这么设立状态?**

虽然这是套路，但是我们不妨思考一下这个问题。首先，我们设立状态的目的是为了划分子问题并且方便转移以及决策。

因为本质上来说，对于你把整个序列分为$m$段和把前$i$个数组成的序列分为$j$段其实是同一个问题。而且将前$i$个数进行后相对于原问题比较容易解决，于是我们把子问题划分成了这个。

**为什么这样设立状态会方便转移？**

因为我们分的段，很显然是连续的，而我们设立的状态，恰好又是前$i$个划分$j$段，按照这样子的状态，我们很好去获得最优解，这样子划分就有利于转移。

#### 状态转移方程

设立好了状态，那么就比较容易写出状态转移方程了：

$dp[i][j] = max$($dp[k][j -1]$ + $sum[i]$ $xor$ $sum[k]$)($k < i$)

$sum[i]$表示的是将序列前$i$个数异或起来得到的结果。$sum[k]$同理。

$sum[i]$ $xor$ $sum[k]$得到的就是$k + 1$个数到第$i$个数的异或起来得到的结果了。

具体为什么，你不妨手玩几组样例或者画图。

#### 边界的设立

$dp[i][1] = sum[i]$这个没什么好说的，很显然的事情。

最后的答案：

$dp[n][m]$：根据我们划分的子问题可知

### 这一类问题的总结:

关于这种分组最值问题，显然是套路的$dp$。

#### 做法：

状态的设置往往是$dp[i][j]$表示前$i$个数已经分成$j$组所获得的最大收益。

往往是三层$for$循环，第一层枚举前$i$个，第二层$j$枚举分$j$组，然后再枚举寻找最优决策即可。

动态转移方程:

$dp[i][j] = max(or$ $min$)($dp[k][j -1]$ + .....)($k < i$)。

省略号即是一个转移需要计算的"贡献"。

#### 这类问题几个坑点：

+ **最后的答案往往需要枚举一下整个序列分成多少组的时候得到最大值。**

+ **边界的设立大多数都是$dp[i][1]$ = ... $or$ $dp[i][0]$ = ...，但是注意特殊情况!**
+ **注意能用前缀和优化的东西尽量用前缀和优化**

大概就是这些了。

### Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int n , m ;
int dp[1005][1205];
int sum[1005];
int main()
{
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i ++)
	{
		int x;
		cin >> x;
		sum[i] = sum[i - 1] ^ x;//前缀和优化
		dp[i][1] = sum[i];//边界
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		for(int j = 2 ; j <= m ; j ++)//起点不能从1开始了！注意!
		{
			for(int k = j - 1 ; k <= i - 1 ; k ++)//注意k的枚举起点是j-1
			dp[i][j] = max(dp[i][j],dp[k][j - 1] + (sum[i] ^ sum[k]));
		}
	}
	cout << dp[n][m];
	return 0;
}
```

---

## 作者：cqbz_luoyiran (赞：1)

[题目描述](https://www.luogu.com.cn/problem/P5144)
# 分析
首先我们得知道什么是异或，这道题的核心就在于看到异或进行转移。

异或xor,^，A xor B就是再A,B两个数的二进制数中相同为0，不同为1。

一些定理：
$$0 xor A = A;$$
$$A xor A = 0;$$
$$A xor (B xor C) = (A xor B) xor C;$$

因为这道题是的蜈蚣是一节一节的，并且是要求蜈蚣分为m段再异或后的最大值，不难想到设Dp[i][j]表示前i节蜈蚣分为j段能获得的最大值。让后我们可以利用xor的交换律对这个进行转移。

$$dp[i][j] = max(dp[i][j],dp[i][k] + SumXor(i,k))$$

其中SumXor表示从i到k所有值异或起来的总和，我们可以设一个前缀和来表示前i个的异或总值，让后面DP时不用再一个一个地去求，以防T掉。dp的初始状态是dp[i][1] = sum[i],因为dp[i][1]就表示了i段分为1组的最大值，显然是他异或起来的本身，因为我们要求n段分为m组的最大值，所以说答案存在是dp[n][m].

十分简洁的的代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 1e3 + 5;
int n,m,w[MAXN],s[MAXN],dp[MAXN][MAXN];
int main() {
	scanf("%d %d",&n,&m);
	for(int i = 1;i <= n;i ++) {
		scanf("%d",&w[i]);
		s[i] = s[i - 1] ^ w[i];
	}
	for(int i = 1;i <= n;i ++) dp[i][1] = s[i];
	for(int j = 2;j <= m;j ++)
	for(int k = 1;k <= n;k ++)
	for(int i = k;i <= n;i ++)
	dp[i][j] = max(dp[i][j],dp[k][j - 1] + (s[i] ^ s[k]));
	printf("%d",dp[n][m]);
	return 0;
}
```
END

---

## 作者：生而为人 (赞：0)

写在前面的话

最近复习DP，想状态转移方程想得头疼，题解又大都语焉不详，非但刷题带来的快感大不如前，而且十分费时，常常导致我熬夜，我自己都几乎要“哀民生之多艰”了。现在好不容易想明白一道题，我打算自己写写题解，看能否讲得更清楚一点，以方便后来者。当然，本人水平有限，还望多多包涵。
众所周知 这是一道水题。。
代码（真心挺短的）
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1005;
int n,m;
int val[N];
int sum[N];
int dp[N][105];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>val[i],sum[i]=sum[i-1]^val[i],dp[i][1]=sum[i];
	for(int i=1;i<=n;i++)
	for(int j=2;j<=min(i,m);j++)
	for(int k=1;k<i;k++)
	dp[i][j]=max(dp[i][j],dp[k][j-1]+(sum[i]^sum[k]));
	int ans=0;
	for(int i=1;i<=m;i++)
	ans=max(ans,dp[n][i]);
	cout<<ans;
}
```


---

## 作者：lx_zjk (赞：0)

这到题目比较easy 普及组难度吧

$f[i][j]$ 表示到了第$i$个数分了$j$个段的最大恶心度

因为异或和具有前缀性即$a[i]$ ^ $a[i + 1]$ ... ^ $a[j]$ = $s[i]$ ^ $s[j]$

$f[i][j] = max(f[k][j - 1] + (s[i]$ ^ $s[k]))$

记得那个$(s[i]$ ^ $s[j])$ 一定要加括号 ~~改了好久~~

计算一下时间复杂度$O(n * n * m)$ 最多为1e8

# Code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 1000 + 50;

const int MAX_M = 100 + 5;

int n, m, a[MAX_N], s[MAX_N], f[MAX_N][MAX_M];

int main() {
	n = read(); m = read();
	for (int i = 1; i <= n; i ++ ) {
		a[i] = read();
		s[i] = s[i - 1] ^ a[i];
		f[i][1] = s[i];
	}
	for (int i = 1; i <= n; i ++ ) {
		for (int j = 0; j < i; j ++ ) {
			for (int k = 2; k <= m; k ++ ){
				f[i][k] = max(f[j][k - 1] + (s[i] ^ s[j]), f[i][k]);
			}
		}
	}
	cout << f[n][m] << endl;
	return 0;
}
```

---

## 作者：QQQfy (赞：0)

## 一眼就是个简单DP！

为什么AC率如此之低啊喂！

咳。。咳咳。。咳咳咳。。。进入正题

## 1.状态与定义

$a[i]$表示原数组

$dp[i][j]$表示前$i$节，被切成了$j$段的最大恶心值。

$p[i]$表示$1$到$n$的异或前缀和，即$p[i]=a[1] xor a[2] xor ···xor a[i]$

## 2.转移

显然，$dp[i][j]$只会来自$dp[k][j-1]$(也就是枚举上一段的断点$k$）$+p[i]xorp[k]$($k$到$i$的贡献)

即：$dp[i][j]=max(dp[k][j-1]+p[i] xor p[k])$


其中$k<i$

然后就可以愉快的AC此题了qwq

~~喜闻乐见的~~ 代码


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1010;

int n,m;

int dp[N][N],p[N],a[N];

int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>a[i];
		p[i]=p[i-1]^a[i];
	}
	for (int i=1;i<=n;i++) dp[i][1]=p[i];
	for (int i=2;i<=m;i++)
		for (int j=i;j<=n;j++)
			for (int k=i-1;k<j;k++)
				dp[j][i]=max(dp[j][i],dp[k][i-1]+(p[j]^p[k]));
	cout<<dp[n][m];
	return 0;
}
```



---


# 【XR-1】分块

## 题目背景

xht37 喜欢分块，以至于对一道**不需要分块**的题也要分块做。

## 题目描述

有一个长度为 $n$ 的序列，xht37 现在想分块维护它。

PinkRabbit 要求他只准将序列分成 $PR$ 种长度的块。

NaCly_Fish 要求他只准将序列分成 $NF$ 种长度的块。

同一个人可能会要求 xht37 多次相同的块长。

xht37 想同时满足 PinkRabbit 和 NaCly_Fish 要求，只好使用两个人都允许的长度分块。

xht37 想知道，有多少种不同的分块方案，答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

【样例 $1$ 说明】

PinkRabbit 和 NaCly_Fish 都允许的块长为 $\{1,2\}$。

长度为 $4$ 的序列分块，每块长度为 $\{1,2\}$ 的方案有：

- $1\ 1\ 1\ 1$
- $1\ 1\ 2$
- $1\ 2\ 1$
- $2\ 1\ 1$
- $2\ 2$

共 $5$ 种。

【数据规模与约定】

设最大块长为 $x$。

对于 $60 \%$ 的数据，$1 \le n \le 10 ^ 6$，$1 \le PR,NF,x \le 10$，保证同一个人不会要求多次相同的块长。

对于 $100 \%$ 的数据，$1 \le n \le 10 ^ {18}$，$1 \le PR,NF,x \le 100$。

## 样例 #1

### 输入

```
4
3
1 2 3
3
1 2 4```

### 输出

```
5```

## 样例 #2

### 输入

```
19260817
7
8 9 6 3 7 2 1
7
4 5 2 9 7 8 3```

### 输出

```
859254329```

# 题解

## 作者：xht (赞：60)

题目地址：[P5343 【XR-1】分块](https://www.luogu.org/problemnew/show/P5343)

~~命题人来水官方题解啦~~

首先显然要求两个不可重集合的交

这个乱搞就行了

然后是显而易见的 dp

时间复杂度 $O(xn)$

~~由于 $x$ 是常数所以实际上是线性的~~

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6 + 6, P = 1e9 + 7;
int n, m = 10, f[N], p;
bitset<N> x, y;

inline void add(int &x, int y) {
	if ((x += y) >= P) x -= P;
}

int main() {
	cin >> n;
	f[0] = 1;
	cin >> p;
	while (p--) {
		int k;
		scanf("%d", &k);
		x[k] = 1;
	}
	cin >> p;
	while (p--) {
		int k;
		scanf("%d", &k);
		y[k] = 1;
	}
	x &= y;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (x[j]) add(f[i], f[i-j]);
	cout << f[n] << endl;
	return 0;
}
```

60分到手了

看一眼这个 dp

哇，可以矩阵快速幂加速递推诶

时间复杂度 $O(x ^ 3\log n)$

~~由于 $x$ 是常数所以实际上是 $\log$ 的~~

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 106, P = 1e9 + 7;
ll n, f[N], a[N][N];
int m = 100, p;
bitset<N> x, y;

void mul() {
	ll c[N];
	memset(c, 0, sizeof(c));
	for (int j = 1; j <= m; j++)
		for (int i = 1; i <= m; i++)
			c[i] = (c[i] + f[j] * a[j][i]) % P;
	for (int i = 1; i <= m; i++) f[i] = c[i];
}

void mulself() {
	ll c[N][N];
	memset(c, 0, sizeof(c));
	for (int i = 1; i <= m; i++)
		for (int k = 1; k <= m; k++)
			for (int j = 1; j <= m; j++)
				c[i][j] = (c[i][j] + a[i][k] * a[k][j]) % P;
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= m; j++)
			a[i][j] = c[i][j];
}

int main() {
	cin >> n;
	f[m] = 1;
	for (int i = 1; i < m; i++) a[i+1][i] = 1;
	cin >> p;
	while (p--) {
		int k;
		scanf("%d", &k);
		x[k] = 1;
	}
	cin >> p;
	while (p--) {
		int k;
		scanf("%d", &k);
		y[k] = 1;
	}
	x &= y;
	for (int i = 1; i <= m; i++)
		if (x[i]) a[m-i+1][m] = 1;
	while (n) {
		if (n & 1) mul();
		mulself();
		n >>= 1;
	}
	cout << f[m] << endl;
	return 0;
}
```

100 分到手了

~~我知道这道题 $x$ 可以开到 $10 ^ 4$！但是这是签到题！况且命题人这么菜也不会鸭 QwQ~~

---

## 作者：Heartlessly (赞：54)

## Description

给定一个长度为 $n\ (1 \leq n \leq 10^{18})$ 的序列和 $2$ 个 **可重** 集合：$PR$ 和 $NF$ 。现在要把它分成若干块，块的大小有限制，允许的块长为 $PR \cap NF$。求有多少种不同的分块方案，答案对 $10^9 + 7$ 取模。（设最大块长为 $x$，$1 \leq |PR|,|NF|,x \leq 100$）。

## Solution

$60 \rm pts$：

考虑 **动态规划** 。

先预处理出所有可能的块长 $a_1 \sim a_m$（注意要去重）。

用 $f_i$ 表示长度为 $i$ 的序列的分块方案数。

初始 $f_0 = 1$ 。（长度为 $0$ 的序列一定有 $1$ 种分块方案）

状态转移方程（考虑分出来最后一块的块长为 $a_j$）：

![EwtYkD.png](https://s2.ax1x.com/2019/05/05/EwtYkD.png)

直接转移是 $O(n)$ 的。

$100\rm pts$：

发现块长最大只有 $100$（$\max\limits_{i = 1}^m \{a_i\} \leq 100$），所以考虑用 **矩阵乘法** 优化上述 **DP** 。

若矩阵的大小为 $size \times size$，则有 $size = \max\limits_{i = 1}^m \{a_i\}$（因为 $f_i$ 不可能由 $f_{i - 100}$ 之前的转移过来）。

先构造初始矩阵。根据 $f_0 = 1$，**DP** 预处理出 $f_1 \sim f_{size - 1}$，然后才能转移。

![EwtNfH.png](https://s2.ax1x.com/2019/05/05/EwtNfH.png)

接下来构造转移矩阵。首先根据 $f_i = \sum\limits_{j = 1}^m f_{i - a_j}$ 得知，矩阵第一行中，第 $a_i$ 个数为 $1$，其余为 $0$ 。剩下的 $f_{i-1} \sim f_{i - size + 1}$ 都可以在上一个矩阵中找到，所以对应的标为 $1$，其它为 $0$ 。

![Ewtapd.png](https://s2.ax1x.com/2019/05/05/Ewtapd.png)

最后是答案矩阵。

![Ewttte.png](https://s2.ax1x.com/2019/05/05/Ewttte.png)

答案矩阵的第 $1$ 行第 $1$ 列即是最终答案。时间复杂度为 $O(size^3\log n)$ 。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 100;
const int MOD = 1e9 + 7;
LL n;
int pr, nf, m, size, f[MAXN + 5];
bool a[MAXN + 5], b[MAXN + 5];

struct Matrix {
    int mat[MAXN + 5][MAXN + 5];

    inline void clear() {
        memset(mat, 0, sizeof (mat));
    }
    inline Matrix friend operator*(Matrix a, Matrix b) {
        Matrix c;
        c.clear();
        for (int i = 1; i <= size; ++i)
            for (int j = 1; j <= size; ++j)
                for (int k = 1; k <= size; ++k)
                    c.mat[i][j] = (c.mat[i][j] + (LL) a.mat[i][k] * b.mat[k][j]) % MOD;
        return c;
    }//矩阵乘法 
} ans, base;

inline Matrix quickPow(Matrix x, LL p) {
    Matrix res;
    res.clear();
    for (int i = 1; i <= size; ++i) res.mat[i][i] = 1;
    for (; p; p >>= 1, x = x * x)
        if (p & 1) res = res * x;  
    return res;
}//矩阵快速幂 

int main() {
    read(n), read(pr);
    for (int x, i = 1; i <= pr; ++i) {
        read(x);
        a[x] = 1;
    }
    read(nf);
    for (int x, i = 1; i <= nf; ++i) {
        read(x);
        b[x] = 1;
    }//用两个桶标记允许的块长 
    for (int i = 1; i <= 100; ++i)
        if (a[i] && b[i]) {//若同时满足 a,b 
            base.mat[1][i] = 1;//转移矩阵第一行 
            size = i;//矩阵大小 
        }
    for (int i = 1; i < size; ++i) base.mat[i + 1][i] = 1;//转移矩阵第 2 ~ size 行 
    f[0] = 1;//初始状态 
    for (int i = 1; i < size; ++i)
        for (int j = 1; j <= i; ++j)
            if (a[j] && b[j])
                f[i] = (f[i] + f[i - j]) % MOD;//DP 预处理 f[1] ~ f[size - 1] 
    for (int i = 1; i <= size; ++i) ans.mat[i][1] = f[size - i];//初始矩阵 
    ans = quickPow(base, n - size + 1) * ans;//得到答案矩阵 
    write(ans.mat[1][1]);
    putchar('\n');
    return 0;
}
```



---

## 作者：mrsrz (赞：17)

首先搞出能用的块大小集合$S$。

然后令$f_n$表示长度为$n$的序列有几种分块方案。

$f_n=\sum\limits_{i\in S}f_{n-i}$。

由于块大小最大只有$100$，这是个线性递推的形式。

所以我们可以用矩阵快速幂对其进行加速。

最初始$100$个状态可以直接递推处理出来。

时间复杂度$O(100^3\log n)$。

## Code：
```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<cstdio>
#include<cstring>
#include<algorithm>
const int md=1e9+7;
typedef long long LL;
int b[105];
inline void upd(int&a){a+=a>>31&md;}
struct mat{
    int a[100][100];
    inline void operator*=(const mat&b){
        int c[100][100];
        memset(c,0,sizeof c);
        for(int i=0;i<100;++i)
        for(int j=0;j<100;++j){
            int&tmp=c[i][j];
            for(int k=0;k<100;k+=4)
            tmp=(tmp+(LL)a[i][k]*b.a[k][j]+(LL)a[i][k+1]*b.a[k+1][j]+(LL)a[i][k+2]*b.a[k+2][j]+(LL)a[i][k+3]*b.a[k+3][j])%md;
        }
        memcpy(a,c,sizeof a);
    }
}a,c;
LL n;
int na,nb,dp[105];
inline void pow(mat a,LL b,mat&ret){
    for(;b;b>>=1,a*=a)if(b&1)ret*=a;
}
int main(){
    scanf("%lld%d",&n,&na);
    for(int x;na--;){
        scanf("%d",&x);
        b[x]=1;
    }
    scanf("%d",&nb);
    for(int x;nb--;){
        scanf("%d",&x);
        if(b[x])a.a[100-x][99]=1;
    }
    for(int i=1;i<100;++i)a.a[i][i-1]=1;
    dp[0]=1;
    for(int i=1;i<=100;++i)
    for(int j=1;j<=i;++j)
    if(a.a[100-j][99])upd(dp[i]+=dp[i-j]-md);
    for(int i=0;i<100;++i)c.a[0][i]=dp[i];
    pow(a,n,c);
    printf("%d\n",c.a[0][0]);
    return 0;
}

```

---

## 作者：ztyqwq (赞：9)

本蒻蒟比赛的时候想不到简单的方法，于是只能死守DP.  
首先是处理读入的两行数据，去重。同样只想到了用unique的很暴力的处理手段：
```cpp
scanf("%lld", &n);
scanf("%lld", &pr);
for(ll i = 1; i <= pr; i++) scanf("%lld", &ava1[i]);
scanf("%lld", &nf);
for(ll i = 1; i <= nf; i++) scanf("%lld", &ava2[i]);
sort(ava1 + 1, ava1 + pr + 1, cmp);
sort(ava2 + 1, ava2 + nf + 1, cmp);
ava1[0] = unique(ava1 + 1, ava1 + pr + 1) - ava1 - 1;
ava2[0] = unique(ava2 + 1, ava2 + nf + 1) - ava2 - 1;
for(int i = 1; i <= ava1[0]; i++) ava[i] = ava1[i];
for(int i = 1; i <= ava2[0]; i++) ava[i + ava1[0]] = ava2[i];
sort(ava + 1, ava + ava1[0] + ava2[0] + 1, cmp);
for(ll i = 1; i <= ava1[0] + ava2[0]; i++)
    if(ava[i] == ava[i - 1] && ava[i + 1] != ava[i])
        ava[++ava[0]] = ava[i];
```
~~但这都不是重点~~,重点是怎么计算左右分块方案，很明显qwq，这道题类似爬楼梯，所以直接暴力转移：   
$$f[i]\text{ 表示到长度 }i\text{ 一共有多少可能的分块数量。}$$
$$f[i] = \sum^{ava[0]}_{i = 1}f[i - ava[i]]$$
~~显然~~。
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= ava[0]; j++)
        f[i] = (f[i] + f[i - ava[j]]) % MOD;
```
但是这只能过[60%的数据](https://www.luogu.org/recordnew/show/18763481)...

一看$100%$的数据规模
$$
1 \leq n \leq 10^{18}
$$
**...**  
**...**  
**...**  

所以我们需要优化qwq   
$ladies \quad and \quad gentlemen$, 隆重介绍矩阵：  

## 矩阵

$$\left[ \begin{array} { c c c c } { a _ { 11 } } & { a _ { 12 } } & { \cdots } & { a _ { 1 n } } \\ { a _ { 21 } } & { a _ { 22 } } & { \cdots } & { a _ { 2 n } } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { a _ { n 1 } } & { a _ { n 2 } } & { \cdots } & { a _ { n n } } \end{array} \right]$$

矩阵满足的运算有加法，减法，乘法和其他一些...  
但是我们关注的是矩阵乘法。矩阵的乘法是有条件的，如果两个矩阵A和B，那么只有当A的列数和B的行数相同时才可以乘法，乘法满足：   
设$A$为$m \times p$的矩阵，$B$为$p \times n$的矩阵，那么称$m \times n$的矩阵C为矩阵A与B的乘积，记作$C=AB$ ，其中矩阵$C$中的第$i$行第$j$列元素可以表示为：

$$( A B ) _ { i j } = \sum _ { k = 1 } ^ { p } a _ { i k } b _ { k j } = a _ { i 1 } b _ { 1 j } + a _ { i 2 } b _ { 2 j } + \cdots + a _ { i p } b _ { p j }$$

举个栗子：

$$C = A B = \left( \begin{array} { l l l } { 1 } & { 2 } & { 3 } \\ { 4 } & { 5 } & { 6 } \end{array} \right) \left( \begin{array} { l l } { 1 } & { 4 } \\ { 2 } & { 5 } \\ { 3 } & { 6 } \end{array} \right) = \left( \begin{array} { c c } { 1 \times 1 + 2 \times 2 + 3 \times 3 } & { 1 \times 4 + 2 \times 5 + 3 \times 6 } \\ { 4 \times 1 + 5 \times 2 + 6 \times 3 } & { 4 \times 4 + 5 \times 5 + 6 \times 6 } \end{array} \right) = \left( \begin{array} { c c } { 14 } & { 32 } \\ { 32 } & { 77 } \end{array} \right)$$

而且重要的是矩阵满足结合律，分配律。  
所以...  
就做出来啦！  

先举个小栗子，菲波那切数列：
$$f(i) = f(i - 1) + f(i - 2)$$
可以用递归或递推$O(n)$求出来，但如果我让你写$O(log n)$的算法，该怎么办呢？  
矩阵就派上用场啦：  
如果我有一个矩阵
$$\left[ \begin{array} { l } { f ( n - 1 ) } \\ { f ( n - 2 ) } \end{array} \right]$$

你能把它变成
$$\left[ \begin{array} { l } { f ( n ) } \\ { f ( n - 1 ) } \end{array} \right]$$
吗？

首先
$$\begin{aligned}
f(n) &= f(n - 1) + f(n - 2)\\
f(n - 1) &= f(n - 1)\\
\end{aligned}$$
所以不难发现，我们只要乘上一个矩阵就可以啦：
$$\left[ \begin{array} { l } { f ( n ) } \\ { f ( n - 1 ) } \end{array} \right] = \left[ \begin{array} { l l } { 1 } & { 1 } \\ { 1 } & { 0 } \end{array} \right] \left[ \begin{array} { l } { f ( n - 1 ) } \\ { f ( n - 2 ) } \end{array} \right]$$
代码实现：
```cpp
struct mat{
    ll r, c;
    ll m[MAXM][MAXM];
    void clear(){memset(m, 0, sizeof(m));}
};
mat matMul(mat m1, mat m2){
    mat ret;
    ret.r = m1.r; ret.c = m2.c;
    for(int i = 1; i <= ret.r; i++)
        for(int j = 1; j <= ret.c; j++){
		    ll t = 0;
		    for(int k = 1; k <= m1.c; k++)
			    t = (t + (m1.m[i][k] * m2.m[k][j]) % MOD) % MOD;
			ret.m[i][j] = t;
		}
	return ret;
}
```

但是一个一个程，复杂度还是$O(n)$的，甚至因为矩阵，复杂度常数变大了，那要这个玩意儿还有什么用？  
嗯，看起来没用，所以...  
等一下！矩阵满足交换结合律，而且$O(\log n)$怎么听起来这么像我们以前学过的一个叫内个什么算法：

$$\Large\text{快速幂}$$

隆重介绍：矩阵快速幂！！！

## 矩阵快速幂
我们乘上$n$个相同的矩阵，相当于$O(\log n)$求出该矩阵的$n$次方，随后再乘上初始值，即：

$$\left[ \begin{array} { l } { f ( n ) } \\ { f ( n - 1 ) } \end{array} \right] = \left[ \begin{array} { c c } { 1 } & { 1 } \\ { 1 } & { 0 } \end{array} \right] \left[ \begin{array} { c c } { f ( n - 1 ) } \\ { f ( n - 2 ) } \end{array} \right] = \left[ \begin{array} { c c } { 1 } & { 1 } \\ { 1 } & { 0 } \end{array} \right] ^ { 2 } \left[ \begin{array} { c c } { f ( n - 2 ) } \\ { f ( n - 3 ) } \end{array} \right] = \cdots = \left[ \begin{array} { c c } { 1 } & { 1 } \\ { 1 } & { 0 } \end{array} \right] ^ { n - 2 } \left[ \begin{array} { c } { f ( 2 ) } \\ { f ( 1 ) } \end{array} \right]$$

模板如下：
```cpp
mat qpow(mat x, ll powers){
    mat ret; ret.clear(); ret.r = x.r; ret.c = x.c;
    for(ll i = 1; i <= ret.r; i++)
        ret.m[i][i] = 1;
    while(powers){
	    if(powers & 1) ret = matMul(ret, x);
	    x = matMul(x, x);
	    powers >>= 1;
	}
	return ret;
}
```

要注意模板中的单位矩阵不是：

$$\left[ \begin{array} { c c c c } { 1 } & { 1 } & { \cdots } & { 1 } \\ { 1 } & { 1 } & { \cdots } & { 1 } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { 1 } & { 1 } & { \cdots } & { 1 } \end{array} \right]$$

单位矩阵应该是：

$$\left[ \begin{array} { c c c c } { 1 } & { 0 } & { \cdots } & { 0 } \\ { 0 } & { 1 } & { \cdots } & { 0 } \\ { \vdots } & { \vdots } & { \ddots } & { \vdots } \\ { 0 } & { 0 } & { \cdots } & { 1 } \end{array} \right]$$

自己乘一乘就知道了qwq。

扩大到最多100阶的“菲波那切数列”而已，也就很容易了。  
矩阵第一行是你要加的位置为1，其余为0。剩余的是对角线为1，偏移1位。

AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MAXM = 110;
const ll MOD = 1e9 + 7;

ll n, pr, nf, ava1[MAXM], ava2[MAXM], ava[MAXM << 1 | 1], ans;
struct mat{
    ll r, c;
    ll m[MAXM][MAXM];
    void clear(){memset(m, 0, sizeof(m));}
};


mat matMul(mat m1, mat m2);
void prt(mat m);
mat qpow(mat x, ll powers);
bool cmp(const ll &x, const ll &y){return x < y;}

int main(){
    scanf("%lld", &n);
    scanf("%lld", &pr);
    for(ll i = 1; i <= pr; i++) scanf("%lld", &ava1[i]);
    scanf("%lld", &nf);
    for(ll i = 1; i <= nf; i++) scanf("%lld", &ava2[i]);
    sort(ava1 + 1, ava1 + pr + 1, cmp);
    sort(ava2 + 1, ava2 + nf + 1, cmp);
    ava1[0] = unique(ava1 + 1, ava1 + pr + 1) - ava1 - 1;
    ava2[0] = unique(ava2 + 1, ava2 + nf + 1) - ava2 - 1;
    for(int i = 1; i <= ava1[0]; i++) ava[i] = ava1[i];
    for(int i = 1; i <= ava2[0]; i++) ava[i + ava1[0]] = ava2[i];
    sort(ava + 1, ava + ava1[0] + ava2[0] + 1, cmp);
    for(ll i = 1; i <= ava1[0] + ava2[0]; i++)
        if(ava[i] == ava[i - 1] && ava[i + 1] != ava[i])
		    ava[++ava[0]] = ava[i];
    if(ava[0] == 0) {printf("0\n"); return 0;}
    
    mat ans; ans.clear(); ans.c = ans.r = ava[ava[0]]; //建立矩阵
    for(ll i = 1; i <= ava[0]; i++) ans.m[1][ava[i]] = 1;
    for(ll i = 2; i <= ava[ava[0]]; i++) ans.m[i][i - 1] = 1;
    ans = qpow(ans, n);//快速幂 
    printf("%lld\n", ans.m[1][1]); //自己手算一下，就发现只要输出左上角就可以了
    return 1;  //抄答案的是坏孩纸哦qwq
}


mat matMul(mat m1, mat m2){
    mat ret;
    ret.r = m1.r; ret.c = m2.c;
    for(int i = 1; i <= ret.r; i++)
        for(int j = 1; j <= ret.c; j++){
		    ll t = 0;
		    for(int k = 1; k <= m1.c; k++)
			    t = (t + (m1.m[i][k] * m2.m[k][j]) % MOD) % MOD;
			ret.m[i][j] = t;
		}
	return ret;
}
void prt(mat m){
    for(ll i = 1; i <= m.c; i++){
        for(ll j = 1; j <= m.r; j++)
            printf("%lld ", m.m[i][j]);
        putchar('\n');
	}
	putchar('\n');
}
mat qpow(mat x, ll powers){
    mat ret; ret.clear(); ret.r = x.r; ret.c = x.c;
    for(ll i = 1; i <= ret.r; i++)
        ret.m[i][i] = 1;
    while(powers){
	    if(powers & 1) ret = matMul(ret, x);
	    x = matMul(x, x);
	    powers >>= 1;
	}
	return ret;
}
```
总复杂度$O(x^3 \log n)$，最慢的点不开$O2$是$764ms$。  
[我的提交](https://www.luogu.org/recordnew/show/18780010)  
谢谢阅读我的第二篇题解  
有疑问或错误请在评论区指出哦qwq

---

## 作者：quest_2 (赞：8)

题是简单题，重在想到矩乘后怎么接着往下写。

题意不须讲了，很清楚而且很有意思。


------------

### 转移方程稍微给一下，推导可以阅读别的题解。

设置状态 $dp_{\ i}$ 指的是：长度为 $i$ 时可行的分块方案。

我们有: （ $x$ 指的是的可能的块长（即**两人公认的其中一种块长**））

$$dp_{\ i}= \sum dp_{\ i-x}$$ 

我们看到块总长是 $\leq 1e18$ 的，连 $N$ 的空间都开不下，就别提更高维的数组了。

因为开不下，所以 $O(N)$ 递推难矣。

### 『递推的优化，显然矩乘。』

我们尽量少算值，整出个**初始状态**就差不多可以了。

要推第 $i$ 项，要保证在所有可能的块长 $x$ 下，第 $i-x$ 项都**已知**。

因为块长不会大于 $100$ ，故我们可以先**预处理到 $dp_{\ 100}$** 。

开 $100 * 100$ 的矩阵，至少可以保证递推时每一项都能推得出来。

### 现在就到了矩阵乘法最重要的一部分————初始化矩阵。

目前这一步的状态需要前面哪几步的状态推出？

我们通过递推式知道了，与 **$x$ 步前的状态**有关系（以下的 $x$ 指代每一种可能的块长）。

我们把 $dp_{\ i}$ 放在原始矩阵的第 $(1,1)$ 位置，那就把 $dp_{\ i-k}$ 放在 $(k,1)$ 位置。

也就是说新的矩阵的 $(1,1)$ 位置，要由**所有的 $(x,1)$ 的总和**转移而来。

那转移矩阵的第一行里必然有：对于每一个可行的 $x$ ， $(1,x)$ 处为 $1$ ，其余位置为 $0$ 。

比如对于样例1， $1$ 和 $2$ 都是可行的 $x$ ，转移矩阵的第一行必如下图：

$$\begin{bmatrix}1&1&0&0&\cdots &0\end{bmatrix}$$

### 我们解决了第一行，那其他行如何处理？

我们此刻的 $dp_{\ i}$ ，在下一次（第 $i-1$ 次）转移后就将成为 $dp_{\ (i+1)-1}$ ，所以应**向后推一位**，从原来的 $(1,1)$ 位置后推到 $(2,1)$ 位置。

这一过程在做其他矩乘题里必然也经常用到，对于第 $i(i\neq 1)$ 行，我们在 $(i,i-1)$ 位置设为 $1$ ，其余位置设为 $0$ 。

这样可以做到原来在 $(1,1)$ 的第 $dp_{\ i}$ 位在转移后移至 $(1,2)$ 。

对于后面几位亦如此。

最终成品转移矩阵如下（中间省略了一部分数值）：

$$\begin{bmatrix}1&1&\cdots&0&0\\1&0&\cdots&0&0\\0&1&\cdots&0&0\\\vdots&\vdots&\ddots&\vdots&\vdots\\0&0&\cdots&1&0\end{bmatrix}$$

### 所以 $AC$ 此题，流程如下：

1. 预处理 $dp_{\ 100} $ ，填入原始矩阵。

1. 初始化转移矩阵。

1. 矩阵快速幂。

1. 输出最终答案矩阵的 $(1,1)$ 。

以下是代码～

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MOD = 1e9 + 7;
int LEN, PR, NF;
map<int, int> m1, m2;
int N;
int dp[107];

/*矩阵组件*/
struct matrix
{
	int num[107][107];
	matrix operator*(const matrix a) const
	{
		matrix c;
		memset(c.num, 0, sizeof(c.num));
		for (int i = 1; i <= N; i++)
		{
			for (int j = 1; j <= N; j++)
			{
				for (int k = 1; k <= N; k++)
				{
					c.num[i][j] = (c.num[i][j] + (num[i][k] * a.num[k][j]) % MOD) % MOD;
				}
			}
		}
		return c;
	}
} ORZ, RBQ;//ORZ----原始矩阵 RBQ----转移矩阵

/*快速幂组件*/
matrix quick_pow(matrix a, int p)
{
	if (p == 1)
	{
		return a;
	}
	matrix tmp = quick_pow(a, p / 2);
	if (p % 2 == 0)
	{
		return tmp * tmp;
	}
	else
	{
		return tmp * tmp * a;
	}
}


signed main()
{
	memset(ORZ.num, 0, sizeof(ORZ.num));
	memset(RBQ.num, 0, sizeof(RBQ.num));
	cin >> LEN;
	cin >> PR;
	for (int i = 1; i <= PR; i++)
	{
		int num;
		cin >> num;
		m1[num] = 1;
	}
	cin >> NF;
	for (int i = 1; i <= NF; i++)
	{
		int num;
		cin >> num;
		if (m1[num])
		{
			m2[num] = 1;//指这个块长两人是否都公认
		}
	}
    
    /*初始化转移矩阵*/
	for (int i = 1; i <= 100; i++)
	{
		if (m2[i] == 1)
		{
			RBQ.num[1][i] = 1;
			N = i;
		}
	}
	for (int i = 1; i < N; i++)
	{
		RBQ.num[i + 1][i] = 1;
	}
    
    /*预处理dp[100]*/
	dp[0] = 1;
	for (int i = 1; i < N; i++)
	{
		for (int j = 1; j <= i; j++)
		{
			if (m2[j] == 1)
			{
				dp[i] = (dp[i] + dp[i - j]) % MOD;
			}
		}
		ORZ.num[N - i][1] = dp[i];
	}
    
    
	ORZ.num[N][1] = 1;
	matrix ans = quick_pow(RBQ, LEN - N + 1) * ORZ;
	cout << ans.num[1][1];
}
```


---

## 作者：StudyingFather (赞：8)

首先找出可用的块长集合 $S$。

设 $f_i$ 为长度为 $i$ 时的分块方案数，边界是 $f_0=1$。

容易得到下列转移方程：

$$
f_i=\sum_{k \in S} f_{i-k}
$$

时间复杂度 $O(n)$，可以拿到 $60$ 分。

考虑用矩阵乘法来优化递推过程。

块长只有 $100$，我们先预处理出 $f_0 \sim f_{100}$ 的值，剩下的可以通过矩阵快速幂递推。

时间复杂度 $O(k^3 \log n)$。

```cpp
// Problem : P5343 【XR-1】分块
// Contest : Luogu Online Judge
// URL : https://www.luogu.com.cn/problem/P5343
// Author : StudyingFather
// Site : https://studyingfather.com
// Memory Limit : 125 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cp-editor)

#include <cstring>
#include <iostream>
#define MOD 1000000007
using namespace std;
struct mat
{
 long long a[105][105];
 mat()
 {
  memset(a,0,sizeof(a));
 }
 mat operator*(const mat&b)const
 {
  mat ans;
  for(int k=0;k<=100;k++)
   for(int i=0;i<=100;i++)
    for(int j=0;j<=100;j++)
     ans.a[i][j]=(ans.a[i][j]+a[i][k]*b.a[k][j])%MOD;
  return ans;
 }
}f,g;
long long n;
int vis[105];
mat fpow(mat x,long long y)
{
 mat ans;
 for(int i=0;i<=100;i++)
  ans.a[i][i]=1;
 while(y)
 {
  if(y&1)ans=ans*x;
  x=x*x;
  y>>=1;
 }
 return ans;
}
int main()
{
 memset(vis,-1,sizeof(vis));
 cin>>n;
 int p;
 cin>>p;
 while(p--)
 {
  int x;
  cin>>x;
  if(vis[x]==-1)vis[x]++;
 }
 cin>>p;
 while(p--)
 {
  int x;
  cin>>x;
  if(vis[x]==0)vis[x]++;
 }
 f.a[0][0]=1;
 for(int i=1;i<=100;i++)
  for(int j=1;j<=i;j++)
   if(vis[j]==1)
    f.a[0][i]=(f.a[0][i]+f.a[0][i-j])%MOD;
 for(int i=1;i<=100;i++)
  g.a[i][i-1]=1;
 for(int i=1;i<=100;i++)
  if(vis[i]==1)
   g.a[101-i][100]=1;
 if(n<=100)cout<<f.a[0][n]<<endl;
 else cout<<(f*fpow(g,n-100)).a[0][100]<<endl;
 return 0;
}
```

---

## 作者：Jayun (赞：6)

# 题目链接：

[题目](https://www.luogu.com.cn/problem/P5343)

# 题目大意：

给定两个数组 $A,B$，现在要给 $n$ 分组，每块的长度必须在两个数组的交集里（即 $\sum_{i=1}a_i=n\quad(a_i\in A\cap B)$），求方案数。

# 正文：

很明显的一个 DP，设 $f_i$ 表示长度为 $i$ 的分组的方案数，那么这么转移：

$$f_i=\sum_{j=1}^{m}f_{i-a_j}$$

$m$ 表示最长的可能的块长。

时间复杂度：$O(nm)$，$n\leq10^{18}$，这玩意过不去。

考虑用矩阵乘法加速递推。

按照矩乘加速递推的尿性，我们可以用一个 $m\times 1$ 的矩阵来表示状态：

$$\begin{bmatrix}
f_{m}\\ 
f_{m-1}\\ 
\vdots\\ 
f_1
\end{bmatrix}$$

要想办法转移到 $\begin{bmatrix}
f_{m+1}\\ 
f_{m}\\ 
\vdots\\ 
f_3\\
f_2
\end{bmatrix}$，必须再构造一个 $m\times m$ 的转移矩阵。

如果要转移到 $f_{m+1}$，根据转移方程 $f_i=\sum_{j=1}^{m}f_{i-a_j}$ 和矩阵乘法的运算可以推断转移矩阵的第一行（转移到 $f_{m+1}$）肯定和 $A\cap B$ 相关。

拿样例为例。

样例中 $A\cap B = \{1,2\}$，转移矩阵第一行相应的位置就是 $1$，比如样例的转移矩阵的第一行就是 $\begin{bmatrix}1&1&0&0&\cdots&0\end{bmatrix}$。因为这样，$f_{m+1}$ 就能被转移得到：

$$\begin{bmatrix}
f_{m}\\ 
f_{m-1}\\ 
\vdots\\ 
f_1
\end{bmatrix} \times\begin{bmatrix}1&1&0&0&\cdots&0\end{bmatrix}=\begin{bmatrix}f_{m+1-1}\times 1+f_{m+1-2}\times 1+f_{m+1-2}\times0+\cdots+f_{1+1-1}\times0\end{bmatrix}=\begin{bmatrix}f_{m+1}\end{bmatrix}$$

接下来 $m-1$ 行就更好办了，由于目标矩阵第 $2$ 到第 $m$ 行就是初始矩阵的第 $1$ 到第 $m-1$ 行，那转移矩阵就是：

$$\begin{bmatrix}1&1&\cdots&0&0\\
1&0&\cdots&0&0\\
0&1&\cdots&0&0\\
\vdots&\vdots&\ddots&\vdots&\vdots\\
0&0&\cdots&1&0\end{bmatrix}$$

再套个矩阵快速幂就A了。

# 代码:

```cpp

int f[N];
ll n;
bool PR[N], NF[N];

struct matrix
{
	ll mat[N][N];
	int n, m;
	matrix(){memset(mat, 0, sizeof mat);}
	inline ll* operator [] (int b) { return mat[b];}
}F, stp;

inline matrix operator*(matrix &a, matrix &b)
{
	matrix c; c.n = a.n, c.m = b.m;
	for (int i = 1; i <= a.n; i++)
		for (int j = 1; j <= b.m; j++)
			for (int k = 1; k <= a.m; k++)
				c[i][j] = (c[i][j] + (a[i][k] * b[k][j]) % mod) % mod;
	return c;
}

matrix qpow(matrix stp, ll b)
{
	matrix ans; ans.n = ans.m = stp.n;
	for (int i = 1; i <= ans.n; i++)
			ans[i][i] = 1;
	for (; b; b >>= 1)
	{
		if(b & 1) ans = ans * stp; 
		stp = stp * stp;
	}
	return ans;
}

int m;

int main()
{
	scanf ("%lld", &n);
	int pr;scanf ("%d", &pr);
	for (int i = 1, x; i <= pr; i++)
		scanf ("%d", &x), PR[x] = 1;
	int nf;scanf ("%d", &nf);
	for (int i = 1, x; i <= nf; i++)
		scanf ("%d", &x), NF[x] = (1 & PR[x]), m = (NF[x] == 1? max(x, m): m);
	stp.n = stp.m = F.n = m, F.m = 1;


	f[0] = 1;
	for (int i = 1; i < m; i++)
	{
		for (int j = 1; j <= i; j++)
			if(NF[j]) f[i] = (f[i] + f[i - j]) % mod;
		F[m - i][1] = f[i];
	}
	F[m][1] = 1;


	for (int i = 1; i <= m; i++)
		stp[1][i] = NF[i], 
		stp[i + 1][i] = 1;
	stp[m + 1][m] = 0;


	F = qpow(stp, n - m + 1ll) * F;
	printf("%lld", F[1][1]);
	return 0;
}
```


---

## 作者：zzy2333 (赞：1)

~~比赛时忘记去重没AC。。。~~

60分:根据题意分析，先把两人要求的分块大小公共部分处理出来。
对于当前长度，枚举它可以是由哪些长度转移过来即可。

比如说样例1，公共部分是1,2，序列长度为4。长度为4的序列可以由长度为2的序列再填一个长度为2的块，或者长度为3的序列填一个长度为1的块组成。如果设长度为i的方案数为f[i]，那么f[4]=f[2]+f[3]。显然是个递推，边界f[0]=1(长度为0只能啥块都不用)，对于每个长度i，枚举块长j，f[i]+=f[i-j]。复杂度O(nx);

100分：发现上边的式子是一个线性齐次递推式（~~放弃解释概念~~），说白了就是跟斐波那契数列有点像，所以可以矩阵快速幂。
复杂度O(x^3logn)。

最后奉上代码。。。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int mod=1e9+7;
long long n;
int pr,nf,tot=0;
int a[150],b[150];
int solve[150],vis[150];
long long f[150];
struct node{
	long long sq[105][105];
}power,ans;
//a[i]=sum(a[i]-solve[j])
node add(node x,node y){
	node c;
	memset(c.sq,0,sizeof(c.sq));
	for(int i=1;i<=solve[tot];i++){
		for(int j=1;j<=solve[tot];j++){
			for(int k=1;k<=solve[tot];k++){
				c.sq[i][j]=(c.sq[i][j]+(x.sq[i][k]*y.sq[k][j])%mod)%mod;
			}
		}
	}
	return c;
}
int main(){
	memset(f,0,sizeof(f));
	scanf("%lld",&n);
	scanf("%d",&pr);
	for(int i=1;i<=pr;i++){
		scanf("%d",&a[i]);
	}
	scanf("%d",&nf);
	for(int i=1;i<=nf;i++){
		scanf("%d",&b[i]);
	}
	sort(a+1,a+pr+1);
	sort(b+1,b+nf+1);
	int cnta=1,cntb=1;
	memset(vis,0,sizeof(vis));
	while(cnta<=pr&&cntb<=nf){
		if(a[cnta]==b[cntb]){
			if(!vis[a[cnta]])solve[++tot]=a[cnta];
			vis[a[cnta]]=1;
			cnta++;
			cntb++;
		}
		else if(a[cnta]<b[cntb]){
			cnta++;
		}
		else cntb++;
	}
	f[0]=1;
	for(int i=1;i<=solve[tot];i++){
		for(int j=1;j<=tot;j++){
			if(i-solve[j]>=0)f[i]=(f[i]+f[i-solve[j]])%mod;
		}
	}
	memset(ans.sq,0,sizeof(ans.sq));
	for(int i=1;i<=solve[tot];i++){
		ans.sq[i][i]=1;
	}
	memset(power.sq,0,sizeof(power.sq));
	for(int i=2;i<=solve[tot];i++){
		power.sq[i][i-1]=1;
	}
	for(int i=1;i<=tot;i++){
		power.sq[solve[tot]+1-solve[i]][solve[tot]]=1;
	}
	long long p=n-solve[tot];
	while(p){
		if(p&1){
			ans=add(ans,power);
		}
		power=add(power,power);
		p>>=1;
	}
	long long cnt=0;
	for(int i=1;i<=solve[tot];i++){
		cnt=(cnt+f[i]*(ans.sq[i][solve[tot]])%mod)%mod;
	}
	printf("%lld\n",cnt);
	return 0;
}
```
~~常数写的有点大，最大的一个点跑了900+ms。。。~~

---

## 作者：CR_Raphael (赞：0)

第一发交忘记去重+1

要是大考上这样就太冤了QAQ

所以童鞋们写完记得重新读一遍题哈！（当然写之前更要认真看）

windows下谜之爆栈了，不过交一发过了就没管。

这是一道模版型的矩阵加速DP：

即把状态转移方程变化为矩阵乘除，转移矩阵的大小一般只与转移至该状态涉及的其他状态的数量有关，而与总状态数无关，如本题数据，矩阵只需要100，而总状态多达1e18（当然啦，您肯定会推DP对吧）

然后由于矩阵乘除满足结合律，用快速幂加速即可。

复杂度O(n^3\*log n)


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define llint long long int 
using namespace std;

const llint maxn = 105;
const llint modd = 1000000007;

struct kuai {
	llint wn, wm;
	llint a[maxn][maxn];
} c;

kuai t, td;
kuai cheng(kuai aa, kuai bb) {
	llint i, j, l;
	t.wn=aa.wn; t.wm=bb.wm;
	memset(t.a, 0, sizeof(t.a));
	for(i=1; i <= aa.wn; i++) {
		for(j=1; j <= bb.wm; j++) {
			t.a[i][j]=0;
			for(l=1; l <= aa.wm; l++) {
				t.a[i][j]=(t.a[i][j]+(aa.a[i][l]*bb.a[l][j])%modd)%modd;
			}
		}
	}
	return t;
}

llint tt[maxn], n, m, k[maxn];

kuai count(llint l) {
	kuai ts;
	if(l == 1) return c;
	//cout<<l<<endl;
	ts=count(l/2);
	if(l%2 == 0) {
		return cheng(ts, ts);
	}
	else {
		return cheng(cheng(ts, ts), c);
	}
}

int main() {
	llint i, n1, n2, tl;
	scanf("%lld", &n);
	memset(tt, 0, sizeof(tt));
	scanf("%lld", &n1);
	for(i=1; i <= n1; i++) {
		scanf("%lld", &tl);
		tt[tl]=1;
	}
	scanf("%lld", &n2);
	for(i=1; i <= n2; i++) {
		scanf("%lld", &tl);
		if(tt[tl] == 1) tt[tl]=2;
	}
	
	m=0;
	for(i=1; i <= 100; i++) {
		if(tt[i] == 2) {
			m++; k[m]=i;
		}
	}
	
	c.wn=100; c.wm=100;
	memset(c.a, 0, sizeof(c.a));
	for(i=1; i <= 99; i++) {
		c.a[i][i+1]=1;
	}
	for(i=1; i <= m; i++) {
		c.a[100][100-k[i]+1]=1;
	}
	
	kuai d;
	d.wn=1; d.wm=100;
	memset(d.a, 0, sizeof(d.a));
	d.a[1][100]=1;
	td=count(n);
	d=cheng(d, td);
	printf("%lld\n", d.a[1][100]);
	return 0;
}
```


---


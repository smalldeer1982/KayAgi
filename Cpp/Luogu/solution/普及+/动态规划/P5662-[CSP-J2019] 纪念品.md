# [CSP-J2019] 纪念品

## 题目描述

小伟突然获得一种超能力，他知道未来 $T$ 天 $N$ 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。

每天，小伟可以进行以下两种交易**无限次**：
1. 任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；
2. 卖出持有的任意一个纪念品，以当日价格换回金币。

每天卖出纪念品换回的金币可以**立即**用于购买纪念品，当日购买的纪念品也可以**当日卖出**换回金币。当然，一直持有纪念品也是可以的。

$T$ 天之后，小伟的超能力消失。因此他一定会在第 $T$ 天卖出**所有**纪念品换回金币。

小伟现在有 $M$ 枚金币，他想要在超能力消失后拥有尽可能多的金币。 
 

## 说明/提示

**样例 1 说明**

最佳策略是：

第二天花光所有 $100$ 枚金币买入 $5$ 个纪念品 $1$；

第三天卖出 $5$ 个纪念品 $1$，获得金币 $125$ 枚；

第四天买入 $6$ 个纪念品 $1$，剩余 $5$ 枚金币；

第六天必须卖出所有纪念品换回 $300$ 枚金币，第四天剩余 $5$ 枚金币，共 $305$ 枚金币。

超能力消失后，小伟最多拥有 $305$ 枚金币。

**样例 2 说明**

最佳策略是：

第一天花光所有金币买入 $10$ 个纪念品 $1$；

第二天卖出全部纪念品 $1$ 得到 $150$ 枚金币并买入 $8$ 个纪念品 $2$ 和 $1$ 个纪念品 $3$，剩余 $1$ 枚金币；

第三天必须卖出所有纪念品换回 $216$ 枚金币，第二天剩余 $1$ 枚金币，共 $217$ 枚金币。

超能力消失后，小伟最多拥有 $217$ 枚金币。


**数据规模与约定**

对于 $10\%$ 的数据，$T = 1$。

对于 $30\%$ 的数据，$T \leq 4, N \leq 4, M \leq 100$，所有价格 $10 \leq P_{i,j} \leq 100$。

另有 $15\%$ 的数据，$T \leq 100, N = 1$。

另有 $15\%$ 的数据，$T = 2, N \leq 100$。

对于 $100\%$ 的数据，$T \leq 100, N \leq 100, M \leq 10^3$，所有价格 $1 \leq P_{i,j} \leq 10^4$，数据保证任意时刻，小伟手上的金币数不可能超过 $10^4$。

## 样例 #1

### 输入

```
6 1 100
50
20
25
20
25
50```

### 输出

```
305```

## 样例 #2

### 输入

```
3 3 100
10 20 15
15 17 13
15 25 16```

### 输出

```
217```

# 题解

## 作者：泥土笨笨 (赞：572)

看到题目就感觉到一定是动态规划了，但是怎么定义状态呢？到每一天的时候，手里不同纪念品的数量有很多，要是每种情况都存下来，状态爆炸多，必死无疑啊。

这题感觉跟买卖股票很像啊，回忆一下我平时怎么炒(pei)股(qian)的呢？就是频繁交易嘛，今天买了，明天看到涨就卖，看到跌了也忍不住要卖。可惜我没有小伟的超能力啊，这里实名羡慕。

这题题面有一句关键的话，“当日购买的纪念品也可以当日卖出换回金币”！这句话可以帮我们简化状态，因为如果一个纪念品，你想连续持有若干天，可以看做第一天买，第二天早上立刻卖掉，然后第二天买回来，第三天早上立刻卖掉，然后第三天买回来……所以我们就不需要记录每天手里持有多少纪念品了，统一认为我们今天买的纪念品，明天早上就立刻卖掉。明天又是新的一天，用所有的现金，进行新的决策就好了。

我们定义一个三维的数组,$dp[i][j][k]$表示第i天，我们考虑到第j个物品的时候，手里现金还有k元的时候，明天早上全卖掉能拿到的金币数。类似完全背包的思路，就可以写递推了。我们用$price[i][j]$表示第i天第j个物品的价格，外层循环i，里层循环每个物品j，手里留k元现金，则
$$dp[i][j][k]=max(dp[i][j-1][k],dp[i][j-1][k+price[i][j]]+price[i+1][j]-price[i][j])$$
表示第j个物品如果要了，手里现金少了$price[i][j]$，但是期望明天早上的收益多了$price[i+1][j]-price[i][j])$

j循环完一遍以后，在收益里面取最大值，变成下一天的开始金币数。

但是这样开三维数组会炸空间，没关系，见过世面的我根本不慌。因为从第i天传递到第i+1天，只需要传递一个数字，即最大收益。如果第二题早上都卖掉有多重选择，为啥不选最赚钱的呢，是吧？所以第一个维度可以压掉。第二个维度，多重背包可以循环的时候控制循环方向压一维，相信学过完全背包的同学都会。所以其实数组只有一维就够了，表示手里现金数，按照题目说明，不会超过10000

其余细节见代码注释：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;
const int MAXN = 105;

//dp[k]表示手里剩k元现金的时候，明天早上都卖了以后的钱数
//price[i][j]表示第i天第j件物品的价格
int dp[10005], price[MAXN][MAXN];

int main() {
    int t, n, m, ans;
    scanf("%d%d%d", &t, &n, &m);
    //先输入
    for (int i = 1; i <= t; ++i) {
        for (int j = 1; j <= n; ++j) {
            scanf("%d", &price[i][j]);
        }
    }
    //第一天早上手里有m元
    ans = m;
    for (int i = 1; i < t; ++i) {
        //先把数组赋值为负无穷
        memset(dp, ~0x3f, sizeof(dp));
        //什么都不买，今天早上有ans元，明天早上也是ans元
        dp[ans] = ans;
        //枚举第j个物品
        for (int j = 1; j <= n; ++j) {
            //手里有k元的时候，去推明天早上的钱
            for (int k = ans; k >= price[i][j]; --k) {
                //买一件物品，现金减少，赚一份差价，完全背包倒着循环
                dp[k - price[i][j]] = max(dp[k - price[i][j]], dp[k] + price[i + 1][j] - price[i][j]);
            }
        }
        //找一下明天早上收益最大
        int ma = 0;
        for (int j = 0; j <= ans; ++j) {
            ma = max(ma, dp[j]);
        }
        //明天早上就有这么多钱了，继续赚钱
        ans = ma;
    }
    cout << ans << endl;
    return 0;
}
```


---

## 作者：邓布利多6 (赞：454)

一眼就能看出来是动规(~~可是考场想了很长时间仍只是 10% 的数据~~)，后来看了老师的代码简单的难以置信。

这是一道完全背包的题，我们进行 $t-1$ 轮完全背包:

  把今天**手里的钱**当做背包的**容量**，
  
  把商品**今天的价格**当成它的**消耗**,
  
  把商品**明天的价格**当做它的**价值**，
  
每一天结束后把**总钱数加上今天赚的钱**，直接写背包模板即可。

另：
在这道题中，我们可以把商品和钱看成同样的东西，因为题目中说了：可以**当天买当天卖**，所以不必考虑跨天的买卖，**只需考虑当天**的即可，这满足动态规划对于最优化原理和无后效性的要求，可以大胆地购买。



定义：

$f[i]$为用 $i$ 元钱去购买商品所能盈利的最大值（**不含成本**）

转移方程：
$f[j] = max(f[j], f[j - price[i][k]] + price[i][k + 1] - price[i][k]);$


代码：
```CPP
#include <iostream>
#include <memory.h>
using namespace std;
const int N = 101;
const int M = 10001;
int n, m, t, price[N][N], f[M];
int main()
{
	cin >> t >> n >> m;
	for(int i = 1; i <= t; i++)
		for(int j = 1; j <= n; j++)
			cin >> price[j][i];
          //读入每种商品每天的价格
	for(int k = 1; k < t; k++)
	{
		memset(f, 0, sizeof f);//每轮开始前都要制零
		for(int i = 1; i <= n; i++)
			for(int j = price[i][k]; j <= m; j++)//完全背包,正着循环
				f[j] = max(f[j], f[j - price[i][k]] + price[i][k + 1] - price[i][k]);
      
		m += f[m];//加上盈利的钱，进入下一轮买卖
	}
	cout << m;
	return 0;
}

```


---

## 作者：Wenoide (赞：205)

# CSP2019-J T3 纪念品(souvenir)题解

**温馨提示：请在仔细阅读题目后食用**

## 前言

看到题目时，直觉告诉我这一定是 *DP*。

--> 自闭 --> 看 *T4* --> 再次自闭 --> 回来骗分

然后在做 $T=2$ 的部分分时顿悟……

_没有思路时，为什么不试试上厕所和拿部分分呢？_

又：结合 [_P2938_](https://www.luogu.com.cn/problem/P2938) 食用体验更佳

## 正文

### _I)_ $T=1(10\%)$

_一点想法也没有……就骗骗分吧。_

此时，小伟购买纪念品后须在当天卖出，总金币数不变。直接输出 $M$ 。

参考代码略。

------------

### _II)_ $T≤100,N=1(15\%)$

 _更贪心地骗分。_ 

只有一件纪念品时，容易想到贪心。

用 $P_i$ 表示第 $i$ 天该纪念品的价值。

当 $P_i<P_{i+1}$ 时，选择在第 $i$ 天尽可能地购入纪念品并在第 $i+1$ 天全部售出。反之，选择不购入。

当 $P_i<P_{i+1}<...<P_{i+k}$ 时，发现第 $i+1$ 天至第 $i+k-1$ 天的“售出-重新购入”的过程是多余的。可以将整个过程合并为在第 $i$ 天购入并在 $i+k$ 天售出。

那么，我们可将 $P_i(1\le i\le T)$ 划分为若干个连续上升子序列，在每一个子序列的首端尽可能地购入纪念品并在其末端全部售出。

参考代码：

```
#include<stdio.h>
const int MAXN=105;
int p[MAXN];
int main(){
	int T,N,M;
	scanf("%d%d%d",&T,&N,&M);
	for(int i=1;i<=T;++i){
		scanf("%d",p+i);
	}
	for(int i=1;i<T;++i){
		if(p[i]<p[i+1]){
			int tot=M/p[i];
			//储存购入的纪念品数
			M%=p[i];
			while(i<T&&p[i]<p[i+1]){
				++i;
			}
			M+=tot*p[i];
			//售出纪念品
		}
	}
	printf("%d\n",M);
	return 0;
}
```

时间复杂度为 $O(T)$

------------

### _III)_ $T=2,N≤100(15\%)$

 _简单的 15 分，启发了我们。_ 

看到 $T=2$ ，容易想到将每件纪念品的价格增量求出。

但是，每件纪念品的购入价格怎么处理？

——欸，这不是背包问题吗？

将 **每件纪念品的价格增量** 作为其价值，**每件纪念品在第一天购入的价格** 作为其质量， $M$ 作为背包容量，这个问题就转化为了一个完全背包问题。

参考代码：

```
#include<stdio.h>
#include<string.h>
const int MAXN=105;
const int MAXM=10005;
//注意范围
int v[MAXN],w[MAXN],f[MAXM];
int main(){
	memset(f,0,sizeof(f));
	int T,N,M,tmp;
	scanf("%d%d%d",&T,&N,&M);
	for(int i=1;i<=N;++i){
		scanf("%d",w+i);
	}
	for(int i=1;i<=N;++i){
		scanf("%d",&tmp);
		v[i]=tmp-w[MAXN];
	}
	//计算价格增量
	for(int i=1;i<=N;++i){
		if(v[j]<0){		
			continue;
		}
		//略去价格增量为负的纪念品
		for(int j=w[i];j<=M;++j){
			if(f[j]<f[j-w[i]]+v[i]){
				f[j]=f[j-w[i]]+v[i];
			}
		}
	}
	//完全背包
	printf("%d\n",f[M]);
	return 0;
}
```

时间复杂度为 $O(N\times M)$

------------

### _IV)_ $T≤100,N≤100,M≤10^3(100\%)$

在 _III)_ 之后，就容易想到进行 $T-1$ 次完全背包来求出答案了。

在敲正解前，请看下面这组数据：

```
3 3 80
12 20 15
10 17 13
15 25 16
```

“第二天的收益值应取负数还是取0？如果取0，跳过‘第二天’，第三天又如何计算？”

事实上，“跳过第二天”的说法并不准确。

**除第一天只有购入过程、最后一天只有售出过程外，每天都有售出与购入两个过程。两个过程互不干扰。**

**为获得更多的“资金”，不妨令每日的售出过程先于购入过程。**

**每天的购入过程与次日的售出过程（差价）构成一次完全背包。或者说，完全背包是在“第 _X.5_ 天”进行的。**

也就是：

```
Day(1).购入
Day(2).售出
//完全背包
Day(2).购入
Day(3).售出
//完全背包
......
Day(T-1).购入
Day(T).售出
//完全背包
```

而我们跳过的是第一天的购入过程与第二天的售出过程，第二天的购入过程与第三天的售出过程并不受影响。

以此来建立完全背包模型，是最关键、最难理解的地方。

参考代码：

```
#include<stdio.h>
#include<string.h>
const int MAXN=105;
const int MAXM=10005;	
//背包的最大容量应为10^4，不同于M的10^3
inline int in(){
	char ch=getchar();
	int s=0;
	while(ch<'0'||ch>'9'){
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=(s<<3)+(s<<1)+(ch^48);
		ch=getchar();
	}
	return s;
}
//快读
int w[MAXN],t[MAXN],v[MAXN],f[MAXM];
//t临时储存次日的购入价格
int main(){
	int T=in(),N=in(),M=in();
	if(T==1){
		printf("%d\n",M);
		return 0;
	}
    //特判T=1的情况（可略去）
	for(int i=0;i<N;++i){		
		w[i]=in();
	}
	//第一天无售出过程，直接储存其购入价格
	for(int i=1;i<T;++i){
		for(int j=0;j<N;++j){		
			t[j]=in();
			v[j]=t[j]-w[j];
		}
		//输入次日纪念品的价格，计算当日购入该纪念品的净收益
		memset(f,0,sizeof(f));
		//清零
		for(int j=0;j<N;++j){
        	if(v[j]<0){		
				continue;
			}
			//略去当日净收益为负的纪念品
			for(int k=w[j];k<=M;++k){
				if(f[k]<f[k-w[j]]+v[j]){
					f[k]=f[k-w[j]]+v[j];
				}
			}
		}
		//完全背包
		M+=f[M];	
		//金币数增加，同时背包容量（即次日可使用的金币数）增加
		for(int j=0;j<N;++j){
			w[j]=t[j];
		}
		//“购入-售出”过程结束后将当前的“售出”价格转为次日的“购入”价格
	}
	printf("%d\n",M);
}
```

时间复杂度为 $O(T\times N\times MAXM)$


## 后记

第一篇题解，如有不足请指出。

考试时误认为 $MAXM$ 的最大值等于 $M$ 的最大值……

~~Failed to AK.~~

最后，迟到的……

**_CSP2019 RP++_**

------------

### 更新日志

2019.11.17 初稿；

2019.11.18 修订部分错误，完善并调整部分描述，完善排版，补充时间复杂度；

2019.11.24 修订部分错误，简化并调整部分描述，完善排版；

2020.1.2 调整部分描述，调整排版，补充 $L_AT^EX$ ；

未完待续……

------------

---

## 作者：tianxuan (赞：37)

这题我太有发言权了

在考试的时候想了很久

首先这个题目有两个很明显的量

时间t和价钱p

我就想，能不能列一个方程

f[t][p]=max(f[t][p]，f[t][p-商品当前价格]+商品未来最高价)

很明显，不对

因为这样就会出现透支的现象，

可能第三天才是最高价，我第二天就把钱花了

所以不行

接下来，上了个厕所的我有了奇思

这题的内涵在于：

贪心

你不要不信，就是我只看能不能在第二天得到最高的收入

但又有了个问题，假如我原本第二天不能卖的，我要第三天再卖的呢？

没事，在第二天买回来就行了

(考试时我都不知道我怎么过的)

接下来，用key[t][i]表示第i个物品t天的价格，f[t][m]表示t天m元可得钱最大值，

得方程f[t][m]=max(f[t][m]，f[t][m-key[t][i]]+ket[t+1][i])


---

## 作者：RenaMoe (赞：31)

# 题解 P5662 【纪念品】

[题面]( https://www.luogu.org/problem/P5662 )

最后一次考pj了，居然炸了

s组day1把我心态考崩了，下午j组写了200分就开始颓废，~~估计要被学弟们嘲笑了QAQ~~

-----

好了，开始*事后诸葛*

n个物品，t天价格，数据范围不大，但是直接推转移方程不太可行

想到**背包**（考场上脑子里“背包”两字都没出现）

----

先考虑$n=1$的情况：

可以把t天的价格中，相邻两天的价格差当作一个物品（$price=a[i],value=a[i+1]-a[i]$）

`f[i]`表示花费i金币的最大收益（不包括本金）

可以自己手玩一下，同时选物品$i$和$i+1$收益就是$a[i+2]-a[i]$，可以连续起来

每一天可以买卖多个，所以是完全背包

注意每天结束之后更新m，毕竟收益也可以用

----

现在拓展到多个纪念品：

每一天都有n个物品，每个物品的价格还是本身，收益是下一天的减这一天的价格

每一天把n个物品做完全背包，之后更新m

最后得到的m就是答案

坑点是每天背包之前清空f数组

-----

### code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

template<typename T>
inline void read(T &x) {/*...*/}

const int N = 105;
const int M = 1e4 + 5;

int t, n, m;
int a[N][N], f[M];

int main() {
    read(t), read(n), read(m);
    for (int i = 1; i <= t; ++i)
        for (int j = 1; j <= n; ++j)
            read(a[i][j]);
    for (int i = 1; i <= t; ++i) {
        memset(f, 0, sizeof f);
        for (int j = 1; j <= n; ++j)
            for (int k = a[i][j]; k <= m; ++k)
                f[k] = max(f[k], f[k - a[i][j]] + a[i+1][j] - a[i][j]);
        m = max(m, f[m] + m);
    }
    printf("%d\n", m);
    return 0;
}
```

----

话说今年pj比去年水的多，比tg良心

---

## 作者：_LHF_ (赞：23)

# 题解
不错，这一题就是一道背包问题（就是我在考场上想出来的方法），也恭喜我$CSP-J$第三题$AC$了。

行吧，说说这一题吧。我们可以这样想一下：

假如你今天买了一个纪念品，第二天先卖出去再买回来，是不是第二天就相当于什么没做？对，就是利用这个原理，我们可以把它想成一道完全背包问题（不会背包问题的可以走了）。

这一个背包的容量就是现有的钱数，物品的价值就是第i+1天和第i天的价值的差，物品的重量就是第i天购买某物品需要的钱数。好的，最后求出背包所能装载的物品的最大值（肯定是一个非负数），然后在加上现有的钱数，形成新的背包的容量，再这样做下去。

其实我们可以这么想：假如我们要求所有物品在第二天卖完，那么就是一个多重背包，第二天买完后，由于价格不变，所以我们还可以以同样的价格买回来，这样就相当于什么也没做。所以，我们可以再把第二天看成第一天，第三天看成第二天，再这样操作下去......最后输出背包最后的总容量就可以AC了(〃'▽'〃)。

行了，别的话就不多说了，直接上代码：
```cpp
#include<cstdio>
#define max(a,b) (a>b?a:b)
using namespace std;
int n,m,f[10010],a[110],s[110],v,t,k[110];
//背包部分
void beibao()
{
	for(int i=1;i<=m;i++) f[i]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m-k[i];j++) if(j+k[i]>=0&&f[j])
			f[j+k[i]]=max(f[j+k[i]],f[j]+s[i]);
	}
	v=0;
	//寻找最大的价值
	for(int i=0;i<=m;i++) if(f[i]>v) v=f[i];
	//更新钱数
	m+=v-1;
}
int main()
{
	f[0]=1;
	scanf("%d%d%d",&t,&n,&m);
	for(int i=1;i<=t;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a[j]);
			k[j]=s[j];
			s[j]=a[j]-s[j];
		}
		//只有i>1时才能做背包
		if(i>1) beibao();
		for(int j=1;j<=n;j++) s[j]=a[j];
	}
	//输出背包最后的总容量
	printf("%d",m);
	return 0;
}
```
祝大家AK CSP！

update 2020.1.29 纠正了一个小错误

---

## 作者：ycy1124 (赞：7)

### 题意
有 $t$ 天，每一天都有 $n$ 种商品，他们每天的售价为 $w_{i,j}$（$i$ 表示那一天，$j$ 表示哪一件商品），初始有 $m$ 元钱，每天你都可以**无限**次买入和卖出某一种商品。求在 $t$ 天后你最多有多少钱。
### 思路
首先发现，你今天买入一件，明天卖出这一件再买入这一件，后天再卖出这一件，它的利润等于今天买入后天卖出的。因此我们可以假定他今天买入的所有东西都会在明天卖出。这样子 dp 就会更好推。此时我们发现，在每天将纪念品全部卖出之后，他手上的钱肯定是不会变少的，因此我们只需要考虑利润就行了。设 $dp_{i,j}$ 表示在第 $j$ 天花 $i$ 元买入在第二天卖出所能获得的利润最多是多少。此时很容易就将 $j$ 那一维给消掉。$dp$ 的初值一定为 $0$，即不买也不卖。列出转移方程为：
$$
dp_i=\max(dp_i,dp_{i-w_{j,k}}-w_{j,k}+w_{j+1,k})
$$
表示你花 $i-w_{j,k}$ 的钱的最大利润在加上你买入这件商品明天卖出的利润。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int w[105][105],dp[10005];
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int t,n,m;
    cin>>t>>n>>m;
    for(int i=1;i<=t;i++){
        for(int j=1;j<=n;j++){
            cin>>w[i][j];
        }
    }
    int ans=m;
    for(int i=1;i<t;i++){
        for(int j=0;j<=ans;j++){
            dp[j]=0;
        }
        for(int j=1;j<=n;j++){
            for(int k=w[i][j];k<=ans;++k){
                dp[k]=max(dp[k],dp[k-w[i][j]]+w[i+1][j]-w[i][j]);
            }
        }
        ans+=dp[ans];
    }
    cout<<ans;
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/196307626)

---

## 作者：Coding_JuRuo (赞：3)

## 题目大意
已知 $N$ 个商品未来 $T$ 天的价格，现在手上有 $M$ 元钱，求 $T$ 天后最多能获得多少钱。
## 思路分析
首先，持有一个物品等同于每天买下这个物品，第二天卖出后再迅速买入，第三天卖出后再迅速买入……

所以我们可以从第 $1$ 天遍历至第 $T-1$ 天，每天对 $N$ 个商品进行一次完全背包，对钱数 $M$ 进行更新。

我们以物品当日的价格 $p_{i,j}$ 作为重量，赚到的钱 $p_{i+1,j}-p_{i,j}$ 为价值，所以状态转移方程为
$$dp(k)=\max(dp(k),dp(k-p_{i,j})+p_{i+1,j}-p_{i,j})$$
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=105,M=1e4+10;
int t,n,m;
int p[N][N],dp[M];

int main(){
    scanf("%d%d%d",&t,&n,&m);
    for (int i=1;i<=t;++i){
        for (int j=1;j<=n;++j) scanf("%d",&p[i][j]);
    }
    for (int i=1;i<t;++i){
        memset(dp,0,sizeof dp);
        for (int j=1;j<=n;++j){
            for (int k=p[i][j];k<=m;++k) dp[k]=max(dp[k],dp[k-p[i][j]]+p[i+1][j]-p[i][j]);
            //完全背包模板，买入一个商品此日能赚到 p[i+1][j]-p[i][j]
        }
        m+=dp[m];//因为获得的钱可以再用于交易，所以每天要更新 m
    }
    printf("%d",m);
    return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 前言
距离第一次做这题已经过去四年了，前几个月一边对着题解一边问天波，艰难地通过了这道题。昨天看到题解补充计划，于是晚上花了半小时仔细思考，豁然开朗。  
这篇题解不求简略，只希望能让所有的读者能清晰地看懂每一个步骤，不像我一样留下遗憾。  

**如果有不懂的地方，欢迎大家私信问我。**

---
### 思路
要解决的问题是：第 $1$ 天有 $m$ 枚金币，通过买入和卖出纪念品，第 $T$ 天最多能有多少金币？  
每个纪念品买入和卖出的时间都可能不同，非常麻烦，考虑简化这个问题。题面中提到可以无限次进行买入和卖出，也就是说在同一天，我可以既买入某种纪念品，同时也卖出那种纪念品。  
可以发现，在第 $x$ 天买入某个纪念品并在第 $y$ 天卖出，等价于在第 $x$ 天买入，在第 $x+1$ 天卖出；又在第 $x+1$ 天买入，在 $x+2$ 天卖出，以此类推到第 $y$ 天。  
所以，可以每天一开始卖出拥有的所有纪念品，再去考虑当天怎样买入。这样操作可以等价覆盖所有其他的买卖情况。  

这样操作，想让第 $T$ 天金币尽可能多，就一定得让第 $T-1$ 天金币尽可能多；想让第 $T-1$ 天金币尽可能多，就一定得让第 $T-2$ 天金币尽可能多，以此类推。  
实际上就是问：第 $1$ 天有 $m_{1}$ 枚金币，通过买入和卖出纪念品，第 $2$ 天最多有多少枚金币？第 $2$ 天有 $m_{2}$ 枚金币，通过买入和卖出纪念品，第 $3$ 天最多有多少枚金币？以此类推到第 $T$ 天。  

于是我们就把一个复杂的问题，拆成了 $T-1$ 个相似的小问题，每个小问题都是：现在有 $m_i$ 枚金币，通过买入和卖出纪念品，明天最多有多少枚金币？  

接下来考虑如何解决这个小问题。  
首先来想：对于纪念品 $j$，今天价格为 $P_{1,j}$，明天价格为 $P_{2,j}$，这意味着什么？  
容易想到，这意味着一种选择：今天可以花费 $P_{1,j}$ 枚金币，并在明天获得 $P_{2,j}$ 枚金币。  
同理，每种纪念品都意味着一种选择，每个选择都是：今天可以花费 $P_{1,j}$ 枚金币，并在明天获得 $P_{2,j}$ 枚金币。注意，这里花费的金币是**今天的金币**，获得的金币是**明天的金币**，两者是完全独立的。  
问题变成了：今天有 $m_{i}$ 枚金币，通过这些选择，明天最多能获得多少金币？  

如果你熟悉完全背包，你会发现这个问题和完全背包是几乎一样的。如果你不熟悉完全背包，请先做[P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)。  

在这道题中，要解决的问题是：今天有 $m_{i}$ 枚金币，通过选择，明天最多能获得多少金币？  
在完全背包中，要解决的问题是：有容量为 $M$ 的背包，通过选择，最多能获得多少价值？  
在这道题中，选择为：今天可以花费 $P_{1,j}$ 枚金币，并在明天获得 $P_{2,j}$ 枚金币。  
在完全背包中，选择为：可以花费 $P$ 的空间，并获得 $val$ 的价值。  
很容易类比，于是可以用完全背包的模板解决问题。  

本题和完全背包还有一处不同，就是今天没用的金币可以留到明天，但完全背包没用的空间就废了。依然类比来思考。  
今天没用的金币可以留到明天，相当于有一个今天价值为 $1$ 枚金币，明天价值也为 $1$ 枚金币的纪念品，买卖这个纪念品就相当于把金币留到了下一天。  
但在完全背包中，没用的空间就废了，相当于有一个花费为 $1$ 且价值为 $0$ 的物品“空气”。  

所以先用今天价值为 $1$ 枚金币，明天价值也为 $1$ 枚金币的纪念品进行一次转移即可。  
容易发现，用今天价值为 $1$ 枚金币，明天价值也为 $1$ 枚金币的纪念品先进行一次转移，等价于初始化 $dp_{i}\gets i$。  


---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
typedef unsigned long long ull;
int T,n,m;
int dp[10003];
int p[2][103];
bool f;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>T>>n>>m;
	for(int i=1;i<=n;i++)cin>>p[f][i];
	while(--T){//p[f]表示今天纪念品的价格，p[!f]表示明天纪念品的价格
		for(int i=1;i<=m;i++)dp[i]=i;
		for(int i=1;i<=n;i++){
			cin>>p[!f][i];
			for(int j=p[f][i];j<=m;j++){
				dp[j]=max(dp[j],dp[j-p[f][i]]+p[!f][i]);
			}
		}
		m=dp[m];
		f^=1;
	}
	cout<<m;
	return 0;
}
```

---
### 后记
常常感叹于自己以前为什么没想到这没想到那，当现在回顾曾经的 OI 生涯，只想跟之后的同路人说一句话。  
时刻准备，不要在发觉错失机会后徒徒遗憾。

---

## 作者：dear_deer_land (赞：2)

## 思路
首先，我们观察题目，发现题目有部分字加粗了。经过观察发现以下要点：“每天可以进行以下两种交易无限次”“每天卖出纪念品换回的金币可以立即用于购买纪念品”“可以当日卖出”。那么我们发现，如果一个纪念品在小伟手中长期持有就等同于他在第二天卖出后马上买回来，并且题目是允许这种操作的。这样我们就可以得到一个结论：每天的操作可以概括成以下情况：每天早上卖出昨天所有的纪念品并选择今天买什么。所以说每天就相当于什么纪念品都没有，所剩的金钱余额是昨天可以挣到的最大值。   
那么我们很好得出，前一天的收益为前一天所购入（手中持有）的纪念品在明天时的差价（即为前一天该纪念品的价格与第二天纪念品的价格的差值）。这样便很容易推出转移方程：
$$f_k=\max(f_k,f_{k-w_{i,j}}+w_{i+1,j}-w_{i,j})$$
在推出转移方程后，代码还是很简单的，剩下的部分细节请看代码注释。
## 代码
```
#include <bits/stdc++.h>
//#define  int long long
#define  INF 0x3f3f3f3f
#define  LINF 0x3f3f3f3f3f3f3f3f
using namespace std;
int t,n,m,w[110][110],f[10010];
signed main(){
	cin>>t>>n>>m;
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			cin>>w[i][j];//每天每件纪念品的价格 
		}
	}
	for(int i=1;i<=t;i++){
		memset(f,0,sizeof(f));//每一天从零开始 
		for(int j=1;j<=n;j++){
			for(int k=w[i][j];k<=m;k++){
				f[k]=max(f[k],f[k-w[i][j]]+w[i+1][j]-w[i][j]);//今天和明天的差价 
			} 
		}
		m=m+f[m];//当天拥有的最大钱数 
	}
	cout<<m;
    return 0;
}
```

---

## 作者：Yxy7952 (赞：2)

## 思路
考虑使用背包 dp。

由于题目允许卖出的物品当天再买回来，比如今天买，第二天卖出，第二天再买回准备第三天的决策，第三天买回再卖出准备第四天的决策。那我们可以看成今天买的纪念品明天就卖掉，所以考虑跨天的买卖是没有意义的，每天的决策都是单独的，相当于贪心中套了个背包。

考虑完全背包，我们将金币数量当作容量，买入时的价格即今天的价格是背包的消耗，卖出时的价格即明天的价格减去今天的价格是价值。我们设 $f_i$ 表示 $i$ 个金币购买纪念品的最大盈利，这里不含本金。容易得到转移，在第 $k$ 天，考虑到第 $i$ 个纪念品，当前有 $j$ 个金币，则 $f_j=\max(f_{j-price_{k,i}}-a_{k,i}+a_{k+1,i},f_j)$。

还有一点，第二天的本金就是第一天的本金加上第一天的最大盈利。

## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,t,p[105][105],f[100005];
int main(){
	cin>>t>>n>>m;
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			cin>>p[i][j];
		}
	}
	for(int i=1;i<t;i++){
		for(int j=1;j<=n;j++){
			for(int k=p[i][j];k<=m;k++){
				f[k]=max(f[k-p[i][j]]-p[i][j]+p[i+1][j],f[k]);
			}
		}
		m+=f[m];
		for(int j=1;j<=m;j++) f[j]=0;
	}
	cout<<m;
	return 0;
}
```

---

## 作者：LiJunze0501 (赞：1)

# 思路：完全背包
* 容量：今天手里的钱。  
* 重量：今天的价格。  
* 价值：今天与明天的差价。  
* 物品：有 $n$ 种，$n-1$ 轮循环。
# 转移方程
`f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);`  
- $f_{j}$ 是花费 $j$ 元钱时的盈利。
- $p_{k,i}$ 是第 $k$ 天时第 $i$ 种物品的价格，可以理解为背包模板中的重量 。 
- $p_{k+1,i}-p_{k,i}$ 是第 $i$ 件物品第 $k+1$ 天与第 $k$ 天的差价，可以理解为背包模板中的价值 。 

完全背包部分代码：
```cpp
for(int i=1;i<=n;i++)
    for(int j=p[k][i];j<=m;j++)
		f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);
```
# 代码
完全背包模板。  
算出每天的盈利 $f_{m}$，再加到手里的钱 $m$ 中，最后输出。
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int t,n,m;
	cin>>t>>n>>m;
	int p[t+5][n+5];
	for(int i=1;i<=t;i++)
		for(int j=1;j<=n;j++)
			cin>>p[i][j];
	int f[10000];
	for(int k=1;k<t;k++){
		memset(f,0,sizeof(f));
		for(int i=1;i<=n;i++)
			for(int j=p[k][i];j<=m;j++)
				f[j]=max(f[j],f[j-p[k][i]]+p[k+1][i]-p[k][i]);
		m+=f[m];
	}
	cout<<m<<endl;
}
```

---

## 作者：lijingshu_304775 (赞：1)

原题链接：<https://www.luogu.com.cn/problem/P5662>。

更好的使用方式：<https://www.luogu.com.cn/article/sxhfnpo8>。

**警告：严禁抄袭**。

___

## 分析

这道题已知 $N$ 件物品未来 $T$ 天的价格，需要通过交易来让手中的 $M$ 没金币尽可能变多，并且交易不限次数且没有手续费。

先看数据范围：

对于 $T = 1$ 的 $10$ 分，因为只有一天，所以每件物品只有一件价格，无论进行多少次买卖，钱都不会变多。因此 $T = 1$ 时直接输出 $M$ 即可。

对于 $N = 1$ 的 $15$ 分，只有一件商品，那么只要明天比今天贵，今天应该能买多上就买多少。因为明天可以直接全部卖掉，这样就实现了赚钱最大化，然后再考虑明天是否重新买回。

由 $N = 1$ 的结论进一步总结得出，对于每一天的每件物品，就是使用当前的价格赚取今明两天的差价。之实际上是一个完全背包问题的模型，每天都是一轮完全背包问题。每一天手中的金币为背包的体积，每件物品的体积就是物品当天的价格，每件物品的价值就是当天与次日的价格差，这样做一次完全背包就能计算出来每天最多能赚多少钱。程序的时间复杂度是 $O(NMT)$。

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, m;
int a[105][105];//a[i][j]：第i天，j号物品的价格
int f[10005];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> t >> n >> m;
	for (int i = 0; i < t; i++) {
		for (int j = 0; j < n; j++) {
			cin >> a[i][j];
		}
	}
	//一天一天做，比较今天与明天
	for (int i = 0; i < t - 1; i++) {
		memset(f, 0, sizeof(f));
		for (int j = 0; j < n; j++) {
			if (a[i + 1][j] > a[i][j]) {
				//体积：a[i][j],价值：a[i + 1][j] - a[i][j]
				for (int k = a[i][j]; k <= m; k++) {
					f[k] = max(f[k], f[k - a[i][j]] + a[i + 1][j] - a[i][j]);
				}
			}
		}
		//每一件物品考虑完后，f[m]即m元最多赚的钱
		m += f[m];
	}
	cout << m;
	return 0;
}
```

AC记录：<https://www.luogu.com.cn/record/196364812>。

---

## 作者：stringdp100005 (赞：1)

# 解题思路
其实这题就是一道简单完全背包问题。可以使用完全背包的思想解决。  
首先定义状态，$dp_i$ 为花 $i$ 元能赚取到的最大值。这题的难点主要在于状态转移方程（与完全背包的对应）。  
完全背包中的容量在此题中相当于当天第 $i$ 件物品的钱数。而消耗相当于卖出的钱数减去买进的钱数，即 $-p_{i,j}+p_{i+1,j}$。  
所以状态转移方程为：
$$
dp_k=\max(dp_k,dp_{k-p_{i,j}}-p_{i,j}+p_{i+1,j})
$$
而每一轮最终状态显然是 $dp_m$。  
接下来考虑贪心，每天赚尽量多的钱，后续赚的钱数不会因此而减少，反而会因为钱数的增多而增加赚到的钱数。故每天赚尽量多的钱，最后的钱数一定最多。
# AC代码
套用状态转移方程结果即可，注意每次计算时都要清空。
```cpp
#define Code using
#define by namespace
#define stringdp100005 std
#include<bits/stdc++.h>
#define int long long
Code by stringdp100005
int t,n,m,p[1005][1005],dp[10005];
signed main(){
	cin>>t>>n>>m;
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			cin>>p[i][j];
		}
	}
	for(int i=1;i<t;i++){
		memset(dp,0,sizeof dp);//清空dp数组 
		for(int j=1;j<=n;j++){//完全背包 
			for(int k=p[i][j];k<=m;k++){
				dp[k]=max(dp[k],dp[k-p[i][j]]-p[i][j]+p[i+1][j]);//套用状态转移方程 
			}
		}
		m+=dp[m];//贪心选取最大价格 
	}
	cout<<m;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 纪念品题解

---
### 思路
这题是蔡老师（我的编程老师）讲的一道题，一眼就能看出来是动态规划中的完全背包问题。

大家想想，做生意该怎么样？肯定是低价买，高价卖。而价格有涨有跌，我们就应该在价高的时候卖掉，但是背包问题考虑不了这样。其实我们可以以明天与今天的差价为背包的价值，今天的价格为消耗，我们所拥有的钱为容量，这样的话如果收益最大的话，他会一直拿在手里。

（一些来自别人的想法）
把今天手里的钱当做背包的容量，把商品今天的价格当成它的消耗，把商品明天的价格当做它的价值，

每一天结束后把总钱数加上今天赚的钱，直接写完全背包模板即可。

---
那么根据我自己加上别人的思路来看，我们就已经可以推出一个完全背包的主程序了。

```cpp
for (int i = 1; i < t; i++) {
		for (int j = 1; j <= n; j++) {
			w[j] = a[i][j];
			c[j] = a[i + 1][j] - a[i][j];
		}
		memset(dp, 0, sizeof(dp));
		for (int j = 1; j <= n; j++) {
			for (int k = w[j]; k <= m; k++) dp[k] = max(dp[k], dp[k - w[j]] + c[j]);
		}
		m += dp[m];
	}
// 排版不整，请原谅
```

那么再根据蔡老师讲的，我们就可以写出整个程序了。

---
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 10001;
int a[MAXN][MAXN], w[MAXN], c[MAXN], dp[MAXN], t, n, m;

int main () {
	cin >> t >> n >> m;
	for (int i = 1; i <= t; i++) {
		for (int j = 1; j <= n; j++) cin >> a[i][j];
	}
	for (int i = 1; i < t; i++) {
		for (int j = 1; j <= n; j++) {
			w[j] = a[i][j];
			c[j] = a[i + 1][j] - a[i][j];
		}
		memset(dp, 0, sizeof(dp));
		for (int j = 1; j <= n; j++) {
			for (int k = w[j]; k <= m; k++) dp[k] = max(dp[k], dp[k - w[j]] + c[j]);
		}
		m += dp[m];
	}
	cout << m << endl;
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

容易想到背包，本题难点在于想明白下面这个点。

由于题目允许当天买当天卖，比如今天买，第二天卖出，第二天再买回准备第三天的决策，第三天买回再卖出准备第四天的决策。那我们可以看成今天买的纪念品明天就卖掉，所以考虑跨天的买卖是没有意义的，每天的决策都是单独的。

考虑完全背包，我们将**金币数量**当作容量，买入时的价格即**今天的价格**是背包的消耗，卖出时的价格即**明天的价格减去今天的价格**是价值。我们设 $f_i$ 表示 $i$ 个金币购买纪念品的最大盈利，这里不含本金。容易得到转移，在第 $k$ 天，考虑到第 $i$ 个纪念品，当前有 $j$ 个金币，则 $f_j = \max (f_j, f_{j-price_{k, i}}+price_{k, i+1}-price_{k, i})$。

还有一点，第二天的本金就是第一天的本金加上第一天的最大盈利。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int t, n, m, p[105][105], f[10005], ans;
int main () {
	cin >> t >> n >> m;
	for (int i=1; i<=t; ++i)
		for (int j=1; j<=n; ++j)
			cin >> p[i][j];
	for (int k=1; k<t; m+=f[m], memset(f, 0, sizeof f), ++k) 
		for (int i=1; i<=n; ++i)	
			for (int j=p[k][i]; j<=m; ++j)
				f[j]=max(f[j], f[j-p[k][i]]+p[k+1][i]-p[k][i]);
	cout << m;
	return 0;
}
```

---

## 作者：ClV_Csy (赞：1)

# P5662 [CSP-J2019] 纪念品
## 题意
有 $T$ 天 $N$ 个纪念品，每个纪念品在每一天都有一个价值 $P$。第一天有 $M$ 元，要求 $T$ 天后最多可以获得多少元（包括成本）。
## 思路
题面中的一句话非常关键：
> 当日购买的纪念品也可以当日卖出换回金币。

根据这句话，我们就可以把“连续持有 $n$ 天”看作是：  
在第 $1$ 天购买，  
第 $2$ 天卖出后又买回，  
第 $3$ 天卖出后又买回，  
……  
第 $n - 1$ 天卖出后又买回，  
第 $n$ 天卖出。

有了这个前提，我们就可以认为，对于我们购买的每一个纪念品，都在第二天卖出。  
利用这个性质，我们简化了模型，便于进行后续操作。

容易发现对于每一天的购买，都是一个完全背包。
对于每一天 $i$（$1 \le i < T$)，都有：
- 背包的容量是**当天的钱数** $M$。
- 背包可选物品的质量是**当天该纪念品的价格** $P_{i, j}$。
- 背包可选物品的价值是**下一天该纪念品的价格** $P_{i + 1, j}$。

这样完全背包得到的结果为当天的最大盈利（**不含成本**），将它加到当天的钱数 $M$ 中即是下一天所能使用的钱数了。

根据完全背包板子可以写出：

```cpp
int f[10010] = {}; //f[j]表示用j元能盈利的钱数（不含成本）
for (int j = 1; j <= n; j++) {
	for (int k = p[i][j]; k <= m; k++) {
		//把p[i][j]看作物品质量，p[i + 1][j] - p[i][j]这个整体看作物品价值。
		f[k] = max(f[k], f[k - p[i][j]] + (p[i + 1][j] - p[i][j]));
	}
}
m += f[m]; //下一天能用的钱数
```
这是每一天购买的过程。  
共有 $T$ 天，但是第 $T$ 天购买不了，所以我们只需要循环第 $1...T-1$ 天。

```cpp
for (int i = 1; i < t; i++) { //从第1天到t-1天
	int f[10010] = {};
	for (int j = 1; j <= n; j++) {
		for (int k = p[i][j]; k <= m; k++) {
			f[k] = max(f[k], f[k - p[i][j]] + (p[i + 1][j] - p[i][j]));
		}
	} 
	m += f[m];
}
```
循环完成过后 $m$ 的值即为 $T$ 天后能拥有的最多的钱数（题目所求）。

这样就愉快地 AC 了。
## 代码

```cpp
#include <iostream>
using namespace std;
int p[110][1010];
int main() {
	int t, n, m;
	cin >> t >> n >> m;
	for (int i = 1; i <= t; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> p[i][j];
		}
	}
	for (int i = 1; i < t; i++) {
		int f[10010] = {};
		for (int j = 1; j <= n; j++) {
			for (int k = p[i][j]; k <= m; k++) {
				f[k] = max(f[k], f[k - p[i][j]] + (p[i + 1][j] - p[i][j]));
			}
		} 
		m += f[m];
	}
	cout << m;
	return 0;
}
```

---

## 作者：dmc0702 (赞：1)

# P5662
## 分析
把这道题当作一个完全背包来做。那么在第 $x$ 天时，把第 $x$ 天的钱当做背包的容量，把商品第 $x$ 天的价格当成它的质量，把商品第 $x+1$ 天的价格当做它的价值，再套完全背包板子即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[1005][1005],d[10005];
int main(){
    int t,n,m;
    cin>>t>>n>>m;
    for(int i=1;i<=t;i++)
        for(int j=1;j<=n;j++)
            cin>>p[i][j];
    for(int i=1;i<t;i++){
        for(int j=1;j<=n;j++)
            for(int k=p[i][j];k<=m;k++)
                d[k]=max(d[k],d[k-p[i][j]]+p[i+1][j]-p[i][j]);
        m+=d[m];
        memset(d,0,sizeof(d));
    }
    cout<<m;
    return 0;
}
```

---

## 作者：PengDave (赞：0)

# Solution
这道题目给人的第一反应就是背包。直觉很容易想到在最便宜的一天买最贵的那天卖，但关键在于，如果按这样的思路来，实现起来过于麻烦了。因此，我们要进行一定的转化，如果我们要长期持有某件商品，我其实可以不断地把一个商品当天卖出去再买回来。这样，我们就可以每次只处理两天之间的交易。后面的事情就好处理了，我们每两天之间跑一个完全背包算这两天之间最多能赚的钱，代价是前一天的价钱，价值是差价，背包承载量就是当时持有的钱，然后记录答案就行了。
# Code
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[110][1100],dp[1100];
int main(){
    cin.tie(0);
    ios::sync_with_stdio(false);
    int t,n,m;
    cin>>t>>n>>m;
    for(int i=1;i<=t;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
        }
    }
    for(int i=1;i<t;i++){
        for(int j=0;j<=m;j++){//别忘了清空
            dp[j]=0;
        }
        for(int j=1;j<=n;j++){
            for(int k=a[i][j];k<=m;k++){
                dp[k]=max(dp[k],dp[k-a[i][j]]+a[i+1][j]-a[i][j]);
            }
        }
        m+=max(0,dp[m]);// 要是最好的情况下还是会亏，保持原状就行了
    }
    cout<<m<<endl;
    return 0;
}
```

---

## 作者：AK_400 (赞：0)

注意到卖了还能买回来，于是我们强制每一天都将前一天买的纪念品都卖掉。

这样在每一天中，变成了一个当日价格为重量，次日价格为价值的完全背包。

复杂度 $O(Tnm)$，可以通过。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,m,p[105][105],dp[10005],h[105],v[105];
signed main(){
	cin>>t>>n>>m;
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			cin>>p[i][j];
		}
	}
	for(int i=1;i<t;i++){
		m=max(dp[m]+m,m);
		for(int j=1;j<=m;j++)dp[j]=0;
		for(int j=1;j<=n;j++){
			h[j]=p[i][j],v[j]=p[i+1][j]-p[i][j];
			for(int k=h[j];k<=m;k++){
				dp[k]=max(dp[k-h[j]]+v[j],dp[k]);
			}
		}
	}
	cout<<max(dp[m]+m,m);
    return 0;
}
```

---

## 作者：fyn1234 (赞：0)

### 思路

> 一道动态规划题。

可以用完全背包来解决。我们进行 $T-1$ 次完全背包。

然后：

把今天手里的钱当做容量。

把商品今天的价格当做消耗。

把商品明天的价格当做价值。

每一天结束后把总钱数加上今天赚的钱，直接写模板即可。

注：可以当天买当天卖，所以没有必要考虑跨天的买卖，只考虑当天的就行。

### 实现

设 $f_{i}$ 为用 $i$ 元钱去购买商品所获得的最大利润（不含成本）。

那么转移方程为：$f_j = \max(f_j,f_{j-price(i,k)}+price(i,k+1)-price(i,k))$。

### solution

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 114;
const int M = 11451;
int n, m, t, price[N][N], f[M];
int main()
{
	cin>>t>>n>>m;
	for(int i = 1; i <= t; i++){
	    for(int j = 1; j <= n; j++){
		    cin >> price[j][i];
		}
	}
	for(int k = 1; k < t; k++){
		memset(f, 0, sizeof(f));//初始化
		for(int i = 1; i <= n; i++)
			for(int j = price[i][k]; j <= m; j++)//完全背包
				f[j] = max(f[j], f[j - price[i][k]] + price[i][k + 1] - price[i][k]);
      
		m += f[m];//进行下一轮买卖
	}
	cout<<m;
	return 0;
}

```

---

## 作者：zwz6666 (赞：0)

## 解题思路
这道题显然是一道动态规划的题目，但是为什么呢？
首先，动规求解的一般问题（尤其是线性和背包问题）大多要具备以下几个特征：
1. **最优子结构**：原问题的最优解包含子问题的最优解。
2. **子问题重叠**：有大量的子问题被重复求解。
3. **无后效性**。在动态规划中会把原问题分解为若干个子问题，将每个阶段的子问题的求解过程都作为一个阶段，在完成前一阶段后，根据前一阶段的结果求解后一阶段。

对于这个问题，因为**交易间隔和次数不做限制**，也就是相当于每次交易只与钱够不够有关，与之前怎么做的无关。

所以我们只要每天收益最大化就可以做到总收益最大化了，不需要关心买了什么、买了几次，因为这不会影响到后面的求解。

确定了是动态规划，接下来就是动态转移方程。

还是因为交易间隔和次数不做限制，所以我们完全可以买东西一天就脱手卖了，需要时再买回来。  
于是第 $i$ 天买第 $j$ 件物品并且第二天就买掉的收益就是：
$$
P[i+1][j]-P[i][j]
$$
之后就是一个背包模版题了，重量就是买时的价格。  

由此得到转移方程（其中 $k$ 是当前手上有的钱）：
$$
dp[i][j][k]=\max(dp[i][j-1][k],dp[i][j-1][k-P[i][j]]+P[i+1][j]-P[i][j])
$$

当然，这里数据范围不小，空间可能不够用，不过我们就可以从小到大枚举，转移方程就可以优化为：
$$
dp[k]=\max(dp[k],dp[k-P[i][j]]+P[i+1][j]-P[i][j])
$$

注意第 $T$ 天不需要再枚举（而且这时也没有下一天的价格了）。
## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 105;
int v[maxn],w[maxn],dp[10005];
int p[maxn][maxn];
int t,n,m;
int main() {
	cin>>t>>n>>m;
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			cin>>p[i][j];
		}
	}
	for(int i=1;i<t;i++){
		for(int j=1;j<=n;j++){
			w[j]=p[i+1][j]-p[i][j];//处理收益
			v[j]=p[i][j];
		}
    //接下来就是板子了
		memset(dp,0,sizeof dp);
		for(int j=1;j<=n;j++){
			for(int k=0;k<=m;k++){
				if(v[j]<=k){
					dp[k]=max(dp[k],dp[k-v[j]]+w[j]);
				}
			}
		}
		//m+=max(0,dp[m]);
		//可以选择不卖，此时收益为0。
		//但这里的取最大其实是多此一举,因为计算时已经和初始值0比较过了。
		m+=dp[m];
	}
	cout<<m;
	return 0;
} 
```

---

## 作者：flying_bluecat (赞：0)

~~这么水的题居然还能写题解~~
就是一个动态规划，重点在于推断出状态表达式。

看题目描述，及其地像拿着外挂买股票啊，直接预测哪天挣最多。我们只需要考虑每一天小伟手上拥有不.金币数量时能获得的最大收益情况就完美 AC。

对于每一天的每一种纪念品，我们都要考虑如果手上有足够金币去购买它，然后在后续某一天卖出是否能获得收益。这里通过判断当前手上的金币数 `k` 是否大于等于当天纪念品 `j` 的价格 `p[i][j]` 来决定是否可以进行“购买 - 后续卖出”这一操作。如果可以购买，那么就尝试更新 `f[k]` 的值，更新的依据是购买该纪念品后在后续（下一天这里用 `i + 1` 表示）卖出所能获得的收益情况。

此时我们就有了状态表达式`f[k - p[i][j]] + (p[i + 1][j] - p[i][j])`，取这个值和原来 `f[k]` 中的较大值来更新 `f[k]`，表示以手上有 `k` 枚金币的状态下能获得的最大收益差值。

有了状态表达式那还不能写出代码？

```cpp
# include <iostream>
# include <cstring>
using namespace std;
int t, n, m;
int f[10086], p[210][210];
int main() {
    cin >> t >> n >> m;
    for (int i = 1; i <= t; ++i) {
        for (int j = 1; j <= n; ++j) {
            cin >> p[i][j];
        }
    }
    for (int i = 1; i <= t; ++i) {
        memset(f, 0, sizeof(f));
        for (int j = 1; j <= n; ++j) {
            for (int k = 1; k <= m; ++k) {
                if (k >= p[i][j]) {
                    f[k] = max(f[k], f[k - p[i][j]] + (p[i + 1][j] - p[i][j]));
                }
            }
        }
        m += f[m];
    }
    cout << m;
    return 0;
}
```

---

## 作者：ChenZQ (赞：0)

首先看到题目，dp 没得说。

那么接下来就要开始分析状态的表示和状态的转移了。

首先，因为题目有三个参数，**天数**，**纪念品的数量以及所花的钱数**。那么考虑三维状态 $f[i][j][k]$，表示第 $i$ 天前 $j$ 件纪念品使用  $k$ 个金币进行操作能得到的最大金币数。

但是~~这是绿题~~看数据范围便可以知道肯定会 MLE。所以我们应该想办法优化。学过背包问题的同学可以知道，这道题完全可以优化到一维数组，也就是使用完全背包来做。背包问题的思路以及状态转移方程在这里不讲。

但是，这道题就完了吗？

当然不是，一件物品可以跨多天卖，这跟背包问题有很大的差异，所以我们还得解决关于跨天卖的问题。

大家想想，我们做生意该怎么样？肯定是低价买，高价卖。而价格有涨有跌，我们就应该在价高的时候卖掉，但是背包问题考虑不了这样。其实我们可以以**明天与今天的差价为背包的价值**，今天的价格为消耗，我们所拥有的钱为容量，这样的话如果收益最大的话，他会一直拿在手里，在动态规划的过程中他会这样：

第一天：买。

第二天：卖，买。

第三天：卖，买。

直到他明天的价格与今天的差价不再是最大收益。

而因为“买的东西可以当天卖”的特性，我们可以只考虑今天和明天的东西。

为什么呢？

根据上面我所说的动态规划的过程，他其实是可以考虑到跨很多天买卖的。

举个例子：

假设第一天价格为 $10$，第二天为 $13$，第三天为 $15$。

第一天：买，花费 $10$ 元。

第二天：卖，赚的 $13$ 元， 买，花费 $13$ 元。

第三天：卖，赚的 $15$ 元。

那么我们来总结一下：

花费的钱数为 $23$ 元。

赚得的钱数为 $28$ 元。

刚好赚了 $5$ 元，和直接在第一天买第三天卖赚的钱数是一样的。

那么我们可以直接按照背包问题跑一遍，每次只考虑今天的和明天的，就可以得出正确答案。

### AC CODE
```
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;

int p[101][N];
int f[10010];

int main()
{
	int n,m,t;
	scanf("%d%d%d",&t,&n,&m);
	for(int i=1;i<=t;i++)
	{
		for(int j=1;j<=n;j++) scanf("%d",&p[i][j]);
	}
	for(int i=1;i<t;i++)
	{
		memset(f,0,sizeof f);//注意，每次背包要更新。
		for(int j=1;j<=n;j++)
		{
			for(int k=p[i][j];k<=m;k++) f[k]=max(f[k],f[k-p[i][j]]+p[i+1][j]-p[i][j]);//状态转移，不理解的可以再看一遍上面的思路。
		}//因为只有m元钱，所以只能以m为花费钱的上限。
		m+=f[m];
	}
	printf("%d",m);
}
```

---

## 作者：zhangzirui66 (赞：0)

DP 题。

容易发现一个物品如果持有多天，可以转换为每拿一天，就卖掉，如果明天还持有，再买回来即可。

为了方便，我们不妨叫它：长期持有定理。

定义 $i$ 为购买第 $i$ 件物品，$j$ 为提供预算，$k$ 表示第 $k$ 天，$a_{i,j}$ 代表物品 $i$，第 $j$ 天的价格，$f_i$ 表示提供 $i$ 元预算能赚的钱，状态转移方程如下：
$$
f_j = \max(f_j, f_{j - a_{i,k}} - a_{i,k} + a_{i,k + 1})
$$
答案即为 $f_m$。

解释一下原因。

$\max$ 前一项即今日不购买第 $i$ 件物品，后一项我们拆开看：

- $f_{j - a_{i,k}}$，购买后剩的钱能买到的最大金额。
- $- a_{i,k}$，购买它花费的钱。
- $a_{i,k + 1}$，根据长期持有定理，我们在第二天卖出，不会影响答案。

输入时颠倒下标，使第 $i$ 天第 $j$ 种纪念品的价格变为第 $j$ 种第 $i$ 天纪念品的价格。

直接转移即可，时间复杂度 $O(tnm)$：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t, m, n, a[105][105], f[10005];
int main(){
    cin >> t >> n >> m;
    for(int i = 1; i <= t; i ++)
        for(int j = 1; j <= n; j ++)
        cin >> a[j][i];
    for(int k = 1; k < t; k ++){//第 t 天做的事情没有用
        for(int i = 0; i <= m; i ++) f[i] = 0;//清空
        for(int i = 1; i <= n; i ++)
			for(int j = a[i][k]; j <= m; j ++)//从 1 开始下标可能为负
			f[j] = max(f[j], f[j - a[i][k]]- a[i][k] + a[i][k + 1] );//状态转移方程
        m += f[m];//赚的钱拿走
    }
    cout << m;
    return 0;
} 
```

---

## 作者：beigongbaishan (赞：0)

## 思路
这题一眼动规，仔细观察后可以发现这是完全背包，那么我们来推状态转移方程式。

01 背包是要考虑换与不换，而完全背包还要考虑换多少。所以我们还要多一重循环，来枚举换几个时受益最大，一维数组即可解决，很容易推出方程：

$dp_k=\max(dp_k,dp_{k-a_{i,j}}-a_{i,j}+a_{i+1,j})$

## Code
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int t,n,m,a[10005][10005],dp[20010];
signed main(){ 
	cin>>t>>n>>m;
	for(int i=1;i<=t;i++)for(int j=1;j<=n;j++)cin>>a[i][j];
	for(int i=1;i<t;i++){
		memset(dp,0,sizeof(dp));
		for(int j=1;j<=n;j++)                                  
			for(int k=a[i][j];k<=m;k++)//枚举换几个时受益最大
				dp[k]=max(dp[k],dp[k-a[i][j]]-a[i][j]+a[i+1][j]);//动态转移方程式
		m+=dp[m];
	}
	cout<<m;
}
```

---


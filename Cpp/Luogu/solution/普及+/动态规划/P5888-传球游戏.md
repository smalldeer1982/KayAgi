# 传球游戏

## 题目背景

羊城有善蹴鞠者。会足协之杯，于校园之东北角，施两球场，蹴鞠者站球场中，$n$ 人，一球，二门，三裁判而已。观众团坐。少倾，但闻球场中哨声一响，满坐寂然，无敢哗者。

当是时，传球声，微微风声，队员疾跑声，教练呼喊声，拉拉队助威声，一时齐发，众妙毕备。满场观众无不伸颈，侧目，微笑，默叹，以为妙绝。

未几，我球员施一长传，彼球员截之，望我龙门冲来。

但见守门员 oql 立于门，若有所思——

## 题目描述

**原来他在想这么一个问题：**

场上的 $n$ 个球员围成一圈，编号从 $1$ 到 $n$ ，刚开始球在 $1$ 号球员手中。一共 $m$ 次传球，每次传球必须传给一个人，但不能传到自己手中。求第 $m$ 次传球以后传回 $1$ 号球员的方案数。

但他觉得这个问题太简单了，于是加了 $k$ 条限制，每条限制形如 $a,b$，表示 $a$ 号球员不能将球传给 $b$ 号球员。

为了使得 oql 的注意力转移回球场上，你需要在最短的时间内告诉他这个方案数是多少。

你只需要告诉他答案对 $998244353$ 取模后的结果。

## 说明/提示

对于 $10\%$ 的数据，$k=0$。

对于另外 $15\%$ 的数据，$n\leq 500$。

对于另外 $20\%$ 的数据，$n\leq 5\times 10^4$。

对于另外 $20\%$ 的数据，$k\leq 300$。

对于 $100\%$ 的数据，$1\leq n\leq 10^9$，$0\leq m\leq 200$，$0\leq k \leq \min(n\times(n-1),5\times 10^4)$，$1\leq a_i,b_i\leq n$，**不保证 $a_i,b_i$ 不相等**。

## 样例 #1

### 输入

```
2 1 0```

### 输出

```
0```

## 样例 #2

### 输入

```
3 3 0```

### 输出

```
2```

## 样例 #3

### 输入

```
7 13 5
1 3
4 5
5 4
6 1
2 2```

### 输出

```
443723615```

# 题解

## 作者：破忆 (赞：32)

### 【题目大意】

有n个人，球1一开始在1号手中，每次持球者可以传递给其它人，但是有限制条件，某些传球方式是不可行的，求经过m次传球后，球回到1号手中的方案数


------------
### 【分析】

这道题是由部分分到AC的典范

不妨从部分分入手，想正解

#### 签到分：10分

k=0,也就是所有人都能互相传球

我们把除1号外的人统称为“其它人”

那么场上只有2类人，1号和其它人，除了1号，其它人都是相同的


开几个变量记录一下当前传到1号和其它人的方案数即可

```cpp
LL lst1=1,lst2=0,now1,now2;
	//lst表示上一次分别在两类人手中的方案数
   //now表示当前在两类人手中的方案数
   //now2单指1个人
	while(m--){
		now1=lst2*(n-1)%TT;
     //其它n-1个其它人都可以传给1号
		now2=(lst2*(n-2)+lst1)%TT;
     //除1号和自己的n-2个人可以传给其它人，1号也可以给其它人
		lst1=now1,lst2=now2;
      //传递
	}
	printf("%lld\n",now1);
	return 0;
```
#### 第一部分：15分
很明显这是一个经典DP

f[i][j]表示第i轮传给j号的方案数

转移方程：f[i][j]+=f[i-1][k]，前提k可以传给j

复杂度O（n* n* m）

#### 第二部分：35分
之前的DP是枚举所有能传给自己的人

可以换个思路，统计上一轮所有传递方案，减去不能传给自己的人的方案

```cpp
f[0][1]=1;
for(int i=1;i<=m;i++){
	int sum=0;
    //sum是上一轮总方案
	for(int j=1;j<=n;j++) sum=(sum+f[i-1][j])%TT;
	for(int j=1;j<=n;j++){
		f[i][j]=(sum-f[i-1][j]+TT)%TT;
        //自己不能传给自己，先减掉自己
		for(int k=lnk[j];k;k=e[k].nxt){
			int y=e[k].to;
			if(y==j) continue;
            //避免重复减自己
			f[i][j]=(f[i][j]-f[i-1][y]+TT)%TT;
            //枚举不能传的，再从总方案中减去
		}
	}
}
```
复杂度O（n* m）
#### 第三部分：55分
k的限制暂时还没有什么想法...
#### 第四部分：100分
n规模庞大，然而k却相对较小

联系签到分的思路，就能发现解题关键

k最大5e+4，也就是说有传递限制的至多只有1e+5个人

那么剩下的999900000个人呢？

只需要计算一次就够了

我们依旧称这999900000个人为“其它人”

同样可以借助几个变量表示，转移方程与第二部分差不多

```cpp
f[0][1]=1;
RE LL el=0;
for(RE int i=1;i<=m;i++){
	RE bool A=i&1,B=1-A;
    //数据比较大，滚动一下，A是当前，B是之前
	RE LL sum=0,now=el*(n-num-1)%TT;
//el和now是其它人的信息，sum是牵扯到的人的信息
	for(RE  int j=1;j<=num;j++){
    //此处num是限制条件牵扯到的人
		sum+=f[B][j];
		f[A][j]=0;
	}
	sum%=TT;
	(now+=sum)%=TT;
	(sum+=el*(n-num)%TT)%=TT;
	for(RE int j=1;j<=num;j++){
		f[A][j]=(sum-f[B][j]+TT)%TT;
		for(RE  int k=lnk[j];k;k=e[k].nxt){
			RE  int y=e[k].to;
			if(y==j) continue;
			f[A][j]+=-f[B][y]+TT;
		}
		f[A][j]%=TT;
	}
	el=now;
}
```

复杂度 O（k* m）

~~所以AC=签到分+35分部分分~~

------------
### 【代码】
```cpp
#include<bits/stdc++.h>
#define LL long long
#define IN inline
#define RE register 
using namespace std;
const int maxn=1e5+5,maxm=205,TT=998244353;
int n,m,k;
int tot,lnk[maxn];
LL f[2][maxn];
int c[maxn],cnt,d[maxn],num;
struct edge{
	int to,nxt;
}e[maxn];
struct why{
	int x,y;
}a[maxn];
IN int read(){
	RE int t=0,f=1;RE char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9')  t= t*10+ch-'0',ch=getchar();
	return t*f;
}
IN void add_e(RE int x,RE int y){
	e[++tot]=(edge){y,lnk[x]};
	lnk[x]=tot;
}
IN int find(RE int x){
	RE int L=1,R=num,mid;
	while(L<=R){
		mid=L+R>>1;
		if(d[mid]==x) return mid;
		if(x<d[mid]) R=mid-1;
		else L=mid+1;
	}
}
int main(){
	freopen("P5888.in","r",stdin);
	freopen("P5888.out","w",stdout);
	n=read(),m=read(),k=read();
	c[++cnt]=1;
	for(RE int i=1;i<=k;i++){
		RE int x=read(),y=read();
		a[i].x=x,a[i].y=y;
		c[++cnt]=x,c[++cnt]=y;
	}
	sort(c+1,c+1+cnt);
	d[num=1]=1;
	for(RE  int i=2;i<=cnt;i++){
		if(c[i]!=c[i-1]) d[++num]=c[i];
	}
	for(RE  int i=1;i<=k;i++){
		RE  int x=find(a[i].x),y=find(a[i].y);
		add_e(y,x);
	}
    //离散操作，把杂乱的编号看成1~num
	f[0][1]=1;
	RE LL el=0;
	for(RE int i=1;i<=m;i++){
		RE bool A=i&1,B=1-A;
		RE LL sum=0,now=el*(n-num-1)%TT;
		for(RE int j=1;j<=num;j++){
			sum+=f[B][j];
			f[A][j]=0;
		}
		sum%=TT;
		(now+=sum)%=TT;
		(sum+=el*(n-num)%TT)%=TT;
		for(RE int j=1;j<=num;j++){
			f[A][j]=(sum-f[B][j]+TT)%TT;
			for(RE int k=lnk[j];k;k=e[k].nxt){
				RE int y=e[k].to;
				if(y==j) continue;
				f[A][j]+=-f[B][y]+TT;
			}
			f[A][j]%=TT;
		}
		el=now;
	}
	printf("%lld\n",f[m&1][1]);
	return 0;
}
```
------------
### 【总结】
从局部到整体，循序渐进

---

## 作者：VinstaG173 (赞：15)

### 题外话（前言）

在小卖部见到了oql。
```
我：Div2C的数据范围好奇怪啊。
oql：那你想要多少呢？
我：n,m换一下多好。
oql：你想矩乘？
我：（是的）
oql：不行，矩乘被毙了。
我：故意卡矩乘的吗。
oql：这题本来出的就是矩乘。
我：（那为什么这样了）
oql：他们不让我出矩乘，说太难了。
我：怎么感觉现在这个更难呢。。。
oql：（同意）
```
毒瘤的脑回路真是清奇。

%o!

### 题解

首先看看部分分。

~~卡矩乘就算了连个部分分都没有是几个意思，能用矩乘做的部分傻子都不用矩乘做~~

根据我拿分顺序讲。

考场上是45分的。我就是不会那个什么$k\le 300$的玄学~~怕不是给打挂的选手的，还真有考场65分的老哥，怎么做到的，神仙吧~~

Part 1、15pts（$n \le 500$）

直接邻接矩阵暴力记录所有限制条件，遇到不能传球时就`continue;`然后就完了。时间复杂度$O(mn^2)$。

Code:
```cpp
#include<cstdio>
int o=998244353;//%o
int N,M,K,x,y;
int num[203][503];
int to[503][503];
int main()
{
	scanf(" %d %d %d",&N,&M,&K);
	for(int i=1;i<=N;++i)
	{
		to[i][i]=1;
	}
	for(int i=1;i<=K;++i)
	{
		scanf(" %d %d",&x,&y);
		to[x][y]=1;
	}
	num[0][1]=1;
	for(int i=1;i<=M;++i)
	{
		for(int j=1;j<=N;++j)
		{
			for(int k=1;k<=N;++k)
			{
				if(to[k][j])continue;//考虑限制
				num[i][j]=(num[i][j]+num[i-1][k])%o;
			}
		}
	}
	printf("%d\n",num[M][1]);
}
```

Part 2、35pts（$n \le 5 \times 10^4$）

我们发现其实$k$在此时和$n$已经是同级。

然后我们可以把邻接矩阵改成邻接表，然后在每层里扫邻接表预处理每个人在这一层中不能转移给下一层的方案数。

时间复杂度$O(mk)$。

Code:
```cpp
#pragma GCC optimize(3)
#include<cstdio>
#include<vector>
#include<cstring>
int o=998244353;
int N,M,K,x,y;
int num[203][50003],sum[203][50003],sz[50003];
int vis[50003];
std::vector<int>ed[50003];
int main()
{
	scanf(" %d %d %d",&N,&M,&K);
	for(int i=1;i<=N;++i)
	{
		ed[i].push_back(i);
	}
	for(int i=1;i<=K;++i)
	{
		memset(vis,0,sizeof(vis));
		scanf(" %d %d",&x,&y);
		if(x!=y&&!vis[y])ed[x].push_back(y),vis[y]=1;//改邻接表
	}
	for(int i=1;i<=N;++i)sz[i]=ed[i].size();
	num[0][1]=1;sum[0][0]=1;
	for(int i=0;i<sz[1];++i)sum[0][ed[1][i]]=1;
	for(int i=1;i<=M;++i)
	{
		sum[i][0]=0;
		for(int j=1;j<=N;++j)
		{
			sum[i][j]=0;
			num[i][j]=(0ll+sum[i-1][0]-sum[i-1][j]+o)%o;
		}
		for(int j=1;j<=N;++j)
		{
			sum[i][0]=(0ll+sum[i][0]+num[i][j])%o;
			for(int k=0;k<sz[j];++k)
			{
				sum[i][ed[j][k]]=(0ll+sum[i][ed[j][k]]+num[i][j])%o;//就是这个地方把这层不能转移的存下来
			}
		}
	}
	printf("%d\n",num[M][1]);
	return 0;
}
```

Part 3、10pts（$k=0$）

这个东西是一个小学奥数然后我想了好久……~~小学MOer身败名裂~~

其实是小奥忘太多了。

我们发现此时第$i$步传到$2$至$n$的时候，他们都可以传给$1$，然后相当于第$i+1$步传到了$1$。

此时我们发现第$i$步所有可能结果有$(n-1)^i$种（每步持球人可以传给除自己以外$n-1$人中任意一人）。

然后第$i$步传到$1$是传$i$次的答案，其他是传$i+1$次的答案。用$f_n(i)$表示$n$个人传$i$次回到$1$的答案。

所以$f_n(i)+f_n(i+1)=(n-1)^i$，$O(m)$递推即可。

结合上面做法有45分。

Code:
```cpp
#include<cstdio>
#include<vector>
#include<cstring>
int o=998244353;
int N,M,K,x,y;
int num[203][50003],sum[203][50003],sz[50003];
int ans[203];
int vis[50003];
std::vector<int>ed[50003];
inline int qpw(int x,int v)
{
	int res=1;
	while(v)
	{
		(v&1)&&(res=1ll*res*x%o),x=1ll*x*x%o,v>>=1;
	}
	return res;
}
int main()
{
	scanf(" %d %d %d",&N,&M,&K);
	if(!K)//特判处理
	{
		ans[0]=1;
		for(int i=1;i<=M;++i)
		{
			ans[i]=(qpw(N-1,i-1)-ans[i-1]+o)%o;
		}
		printf("%d\n",ans[M]);
		return 0;
	}
	for(int i=1;i<=N;++i)
	{
		ed[i].push_back(i);
	}
	for(int i=1;i<=K;++i)
	{
		memset(vis,0,sizeof(vis));
		scanf(" %d %d",&x,&y);
		if(x!=y&&!vis[y])ed[x].push_back(y),vis[y]=1;
	}
	for(int i=1;i<=N;++i)sz[i]=ed[i].size();
	num[0][1]=1;sum[0][0]=1;
	for(int i=0;i<sz[1];++i)sum[0][ed[1][i]]=1;
	for(int i=1;i<=M;++i)
	{
		sum[i][0]=0;
		for(int j=1;j<=N;++j)
		{
			sum[i][j]=0;
			num[i][j]=(0ll+sum[i-1][0]-sum[i-1][j]+o)%o;
		}
		for(int j=1;j<=N;++j)
		{
			sum[i][0]=(0ll+sum[i][0]+num[i][j])%o;
			for(int k=0;k<sz[j];++k)
			{
				sum[i][ed[j][k]]=(0ll+sum[i][ed[j][k]]+num[i][j])%o;
			}
		}
	}
	printf("%d\n",num[M][1]);
	return 0;
}
```

Part 4、65pts

并不会。。。

Part 5、100pts

其实35pts改改就出来了呀。

分出「自由人」太妙了。

我们知道$k$条限制最多就影响到$2k$个人，再除掉$1$，其他人的情况都是一样的，他们不会被任何人限制，所以直接将他们的方案总数统一表示就完了。

我们将受限制的人离散化，然后把「自由人」看作一个顶「自由人个数」个人的「大人」，如上转移就行了。

注意要去重边自环（什么都考虑上才好）。

时间复杂度$O(km)$。

在这里我用了滚动数组，实测不用滚动数组T了三个点，不知是因为位运算快还是空间大消耗时间大~~或者是我人弱常数大~~

Code:
```cpp
#include<map>
#include<cstdio>
#include<vector>
#include<cstring>
#include<utility>
using std::map;
using std::pair;
using std::vector;
const int o=998244353;
int N,M,K;
int x,y;
map<int,int>id;
map<pair<int,int>,bool>apr;
vector<int>pre[100007];
int siz[100007];
int pr[100007],cnt,fcnt;
int dp[2][100007];
int main()
{
	scanf(" %d %d %d",&N,&M,&K);
	id[1]=++cnt,pr[cnt]=1;
	pre[1].clear(),siz[1]=0;
	for(int i=0;i<K;++i)
	{
		scanf(" %d %d",&x,&y);
		if(x==y)continue;
		if(apr.count(std::make_pair(x,y)))continue;
		if(!id.count(x))id[x]=++cnt,pr[cnt]=x;
		if(!id.count(y))id[y]=++cnt,pr[cnt]=y,pre[cnt].clear(),siz[cnt]=0;
		pre[id[y]].push_back(id[x]),++siz[id[y]];
		apr[std::make_pair(x,y)]=true;
	}
	fcnt=N-cnt;
	dp[0][1]=dp[0][0]=1;
	for(int i=1;i<=M;++i)
	{
		int lev=i&1;
		memset(dp[lev],0,sizeof(dp[lev]));
		for(int j=1;j<=cnt;++j)
		{
			dp[lev][j]=(dp[lev^1][0]-dp[lev^1][j]+o)%o;
			for(int k=0;k<siz[j];++k)
			{
				dp[lev][j]=(dp[lev][j]-dp[lev^1][pre[j][k]]+o)%o;
			}
			dp[lev][0]=(dp[lev][0]+dp[lev][j])%o;
		}
		dp[lev][cnt+1]=1ll*fcnt*dp[lev^1][0]%o;
		dp[lev][cnt+1]=(dp[lev][cnt+1]-dp[lev^1][cnt+1]+o)%o;
		dp[lev][0]=(dp[lev][0]+dp[lev][cnt+1])%o;
	}
	printf("%d\n",dp[M&1][1]);
	return 0;
}
```

%o!

---

## 作者：Rainybunny (赞：14)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[$luogu$](https://www.luogu.com.cn/problem/P5888).
# 题解
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没打月赛~~跑去看bilibili跨年会回顾~~的我被强行拉来做这道题$qwq$.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完题面, 第一反应是矩阵加速, 不过这$n=10^9$...  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想$DP$吧.
## $DP$状态及转移
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们令状态$f(i,j)$表示**传了$i$次球后, 球在$j$手中的方案数**. 那么转移当然就是所有能传到$j$的球员的$f(i-1)$之和咯. 所以:
$$
f(i,j)=\sum_{k->j}f(i-1,k)
$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中$k->j$表示$k$能传球给$j$, 下同.
## 优化一
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然嘛, 滚动数组.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过这是空间和时间都和$n$有关, 完全跑不了. 所以重点在优化二.
## 优化二
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设**任何结点可以给$u$提供转移** ( 即能传球给$u$ ), 观察$u$的转移:
$$
f(i,u)=\sum_{v\not=u}f(i-1,v)
$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护上一层所有$f$的和, 就可以$O(1)$求了.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时再联系$k_{max}=5\times10^4$, 我们可以发现**有传球限制的结点** ( 不能接某人的球或不能传给某人 ) 的数量为$t_{max}=2k_{max}=10^5$, 而$n_{max}=10^9$, 也就是说极大部分的结点都满足$u$的性质! 我们把这些点全部聚集在一起, 缩成一个"$free$点". 可见$free$点具有如下性质:  
- 任何点可以传给$free$点.  

- $free$点可以传给任何点.  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而$free$点的内部, 是一个**有向完全图**. 也就是说, **$free$结点能"自传球"**. 设$free$点内部有$cnt$个点, 其转移的贡献为:
$$
f(i,free)=(cnt-1)\times f(i-1,free)
$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以, 点最多只需要$t_{max}=10^5$个就够了.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来, 想一想加速转移.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合刚才$u$结点的转移, 我们尝试用所有可能贡献减去不合法的贡献来计算任意的$f(i,j)$. 设$s$为$f(i-1)$中不包括$free$点的方案总数, 那么转移变成:
$$
f(i,j)=s+f(i-1,free)-\sum_{k\not->j}f(i-1,k)
$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$free$点, 我们单独转移:
$$
f(i,free)=(cnt-1)\times f(i-1,free)+s\times cnt
$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现$\sum$每层是均摊$O(k)$的, 所以空间$O(k)$, 时间$O(mk)$, 大功告成!  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意, 为避免最后答案混淆, 结点$1$不能算进$free$点.
## 代码
```cpp
#include <map>
#include <cstdio>
#include <vector>

#define Int register int

using namespace std;

const int MAXM = 200, MAXK = 5e4, MOD = 998244353;
int n, m, k, Cnte, Head[MAXK * 2 + 5], F[2][MAXK * 2 + 5];
vector<int> Player; // 非free点的编号 ( hash值 ).
map<int, int> Dict; // 非free点的hash.

struct Edge { int To, _nxt; } Graph[MAXK + 5]; // u->v表示v不能给u贡献.

inline void Link ( const int From, const int To ) {
	Graph[++ Cnte] = { To, Head[From] };
	Head[From] = Cnte;
}

inline void Work () {
	scanf ( "%d %d %d", &n, &m, &k );
	for ( Int i = 1, a, b, ida, idb; i <= k; ++ i ) {
		scanf ( "%d %d", &a, &b );
		if ( ! ( ida = Dict[a] ) ) Player.push_back ( Dict[a] = ida = Dict.size () );
		if ( ! ( idb = Dict[b] ) ) Player.push_back ( Dict[b] = idb = Dict.size () );
		if ( ida ^ idb ) Link ( idb, ida ); // 注意数据不保证a!=b.
	}
	if ( ! Dict[1] ) Player.push_back ( Dict[1] = Dict.size () ); // 单独处理1.
	int Free = n - Dict.size (), idf = Dict.size () + 1; // Free即文中cnt, 为free内部的结点个数; idf是free结点的编号.
	F[0][Dict[1]] = 1;
	int Outs[2] = { 1, 0 }; // 记录上层和当前层f的和, 随f滚动.
	for ( Int i = 1, t = 1; i <= m; ++ i, t ^= 1 ) {
		Outs[t] = 0;
		for ( int p: Player ) {
			int& now = F[t][p];
			now = ( ( F[t ^ 1][idf] + Outs[t ^ 1] - F[t ^ 1][p] ) % MOD + MOD ) % MOD; // 总方案. 
			for ( Int j = Head[p]; j; j = Graph[j]._nxt ) now = ( now - F[t ^ 1][Graph[j].To] + MOD ) % MOD;
			// 减去不合法方案.
			Outs[t] = ( Outs[t] + now ) % MOD; // 累加.
		}
		F[t][idf] = ( 1LL * F[t ^ 1][idf] * ( Free - 1 ) % MOD + 1LL * Outs[t ^ 1] * Free % MOD ) % MOD; // free单独转移.
	}
	printf ( "%d\n", F[m & 1][Dict[1]] ); // 答案即f(m,1的编号).
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：Weakest_Konjac (赞：11)

对于 $35\% \left( n\leq 5\times 10^{4}\right) $的数据：

不难想出$ O\left( nm+km\right) $的$ dp $

设$ f\left[ i\right]\left[ j\right] $为经过$ i $轮球传给$ j $号球员的方案数，所以

$ f\left[ i\right]\left[ j\right]=\sum f\left[ i-1\right] \left[ k\right] (k$可传给$j)$

但是这样实现是$ O\left( n^{2}m\right) $的，我们发现有很多转移都是重复的，我们可以先把上一轮的传到所有球员的方案数求出来，即求出$ sum=\sum ^{n}_{k=1}f\left[ i-1\right] \left[ k\right] $，然后减去$ \sum f\left[ i-1\right] \left[ k\right] (k$不可传给$j)$，即$f\left[ i\right]\left[ j\right]=sum-\sum f\left[ i-1\right] \left[ k\right] (k$不可传给$j)$

代码如下$($滚动数组实现$)$：
```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
using namespace std;
const int N=1e6+5,M=5e4+5,MOD=998244353;
struct node{
	int x,y;
}edge[M];
int n,m,k,cur,sum,cnt,dp[2][N];
inline int read(){int x=0;char ch=getchar();while(!isdigit(ch))ch=getchar();while(isdigit(ch))x=x*10+(ch^48),ch=getchar();return x;}
inline int mod(int x){return x<0?x+MOD:(x>=MOD?x-MOD:x);}
int main(){
	n=read(),m=read(),k=read();dp[0][1]=1;
	for (register int i=1;i<=k;++i) edge[i].x=read(),edge[i].y=read();
	while (m--){
		sum=0;
		for (register int i=1;i<=n;++i) sum=mod(sum+dp[cur][i]);//统计上一轮结束的所有球员持球方案数
		for (register int i=1;i<=n;++i)
			dp[cur^1][i]=mod(sum-dp[cur][i]);//自己不可以传给自己
		for (register int i=1;i<=k;++i)
			if (edge[i].x!=edge[i].y)
				dp[cur^1][edge[i].y]=mod(dp[cur^1][edge[i].y]-dp[cur][edge[i].x]);//处理限制条件
		cur^=1;
	}
	printf("%d",dp[cur][1]);
	return 0;
}
```

对于$100\% $的数据：

时间复杂度$ O\left( k\log k+km\right) $

我们发现，上面的$ dp $中有很多转移没必要特殊判断，未出现在限制条件中的球员$ ($称之为普通球员$)$的转移结果总是一样的，都为$\sum f\left[ i-1\right] \left[ k\right] -f\left[ i-1\right]\left[j\right]$，所以这些球员没必要特殊记录。因此转移中涉及的特殊球员$($在限制条件中出现过的球员$)$不到$ 10^{5}$个，可以$AC$

实现方法要点：

将限制条件中出现过的球员保存下来，重新编号。

$ sum $转移：先默认所有都是普通球员，那么$ sum=last \times (n-1) $,然后在特殊球员的转移过程中把无法实现的转移减去

代码如下$($滚动数组实现$)$：
```
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<map>
using namespace std;
const int N=1e5+5,M=5e4+5,MOD=998244353;
struct node{
	int x,y;
}edge[M];
int n,m,k,cur,last,sum=1,cnt,num[N],dp[2][N];//last为上一轮的sum
map<int,int>mp;//记录特殊球员的新编号
inline int read(){int x=0;char ch=getchar();while(!isdigit(ch))ch=getchar();while(isdigit(ch))x=x*10+(ch^48),ch=getchar();return x;}
inline int mod(int x){return x<0?x+MOD:(x>=MOD?x-MOD:x);}
int main(){
	n=read(),m=read(),k=read(),mp[1]=1,num[++cnt]=1,dp[0][1]=1;
	for (register int i=1,x,y;i<=k;++i){
		x=read(),y=read();
		if (!mp.count(x)) mp[x]=++cnt,edge[i].x=cnt;
		else edge[i].x=mp[x];
		if (!mp.count(y)) mp[y]=++cnt,edge[i].y=cnt;
		else edge[i].y=mp[y];
	}
	while (m--){
		last=sum,sum=1ll*last*(n-1)%MOD;
		for (register int i=1;i<=cnt;++i) dp[cur^1][i]=mod(last-dp[cur][i]);
		for (register int i=1;i<=k;++i)
			if (edge[i].x!=edge[i].y)
				dp[cur^1][edge[i].y]=mod(dp[cur^1][edge[i].y]-dp[cur][edge[i].x]),sum=mod(sum-dp[cur][edge[i].x]);
		cur^=1;
	}
	printf("%d",dp[cur][1]);
	return 0;
}
```


---

## 作者：cdcq (赞：5)

性质：

人数虽然有1e9，但是每条边只限制两个人，被限制的人最多有1e5个，剩下的都是自由人，他们的方案数都完全相同，可以用一个数统一表示

转化问题：

正难则反，直接建完全图模拟传球复杂度太高，那就考虑由总方案减去不合法的

需要注意到每次传球，假设总方案数容易求出，那么需要减去的不合法传球方法等于边的个数，而边的个数只有5e4

接下来考虑求总方案数

每一个人接到球的总方案数就是剩余所有人上一轮的方案数之和，因为在上一轮的每个方案的基础上把求传给这个人就可以得到新的方案

这个可以由上一轮每个人的方案数之和减去上一轮自己的方案数快速求出

至此问题解决

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define LL long long
const int mo=998244353;
struct edg{int y,nxt;}e[51000];  int lk[110000],ltp=0;
void ist(int x,int y){  e[++ltp]=(edg){y,lk[x]};  lk[x]=ltp;}
struct nds{int x,y;}a[51000];
int n,m,o;
int q[110000],hd=0;
int c[110000],ctp=0;
LL f[2][110000];
int bnrsch(int x){
	int l=1,r=ctp,md;
	while(l+1<r){
		md=(l+r)>>1;
		(c[md]<x ? l : r)=md;
	}
	return c[l]==x ? l : r;
}
int main(){
	cin>>n>>m>>o;
	for(int i=1;i<=o;++i){
		scanf("%d%d",&a[i].x,&a[i].y);
		q[++hd]=a[i].x,q[++hd]=a[i].y;
	}
	sort(q+1,q+hd+1);
	for(int i=1;i<=hd;++i)if(q[i]!=q[i-1])
		c[++ctp]=q[i];
	for(int i=1;i<=o;++i)if(a[i].y!=a[i].x)
		ist(bnrsch(a[i].y),bnrsch(a[i].x));
	if(c[1]!=1){
		c[++ctp]=1;
		f[0][ctp]=1;
	}
	else  f[0][1]=1;
	for(int i=1;i<=m;++i){
		LL bwl=0;
		for(int j=1;j<=ctp;++j)  bwl=(bwl+f[(i-1)&1][j])%mo;
		bwl=(bwl+f[(i-1)&1][0]*(n-ctp))%mo;
		for(int j=0;j<=ctp;++j){
			f[i&1][j]=(bwl-f[(i-1)&1][j])%mo;
			for(int k=lk[j];k;k=e[k].nxt)  f[i&1][j]=(f[i&1][j]-f[(i-1)&1][e[k].y])%mo;
		}
	}
	printf("%lld\n",(f[m&1][(c[1]==1 ? 1 : ctp)]%mo+mo)%mo);
	return 0;
}


```


---

## 作者：zzy2333 (赞：3)

~~题目背景好评~~

容易发现这是一道DP题

考虑暴力的做法，设 $ f_{i,j} $ 表示进行了 $i$ 轮传球后球到了 $j$ 号球员手里的方案数

这样做显然爆炸，因为球员实在太多了

但是我们发现限制条件相比球员数很少，所以我们可以单独保留 1 号和出现在限制条件里的球员，把其他球员统一作为 0 号处理

有个很显然的方程

$ f_{i,j}=\sum\limits_{t->j} f_{i-1,t} $

其中 $ t->j $ 表示 $t$ 可以传球给 $j$ 

这个转移是 $O(k^2) $的

考虑进一步优化：我们发现总方案数可以用一个变量记一下，而不合法方案数由于限制条件只有 $k$ 条可以 $O(k)$ 从方案中去掉

设一共有 $cnt$ 个球员出现在了限制条件中

设 $sum_i=\sum\limits_{j\neq0} f_{i,j}$

那么$ f_{i,j}=sum_{i-1}+(n-cnt)\times f_{i-1,0}-\sum\limits_{t->j}f_{i-1,t} $

这里用$t->j$表示 $t$ **不能**传给 $j$

当然，别忘了自己也不能传给自己

把读入的限制条件反过来以边的形式存储，转移的时候会很方便

这样做的时空复杂度都是 $O(mk)$ 的，会爆空间，由于每次转移 $i$ 只用到了 $i-1$ 的 DP 值，所以用滚动数组优化一下就行了，时间复杂度 $O(mk)$ ,空间复杂度 $O(k)$

最后上代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int mod=998244353;
int n,m,k;
int a[50010],b[50010];
int read[100010],cnt=0,s[100010];//离散化 
long long f[2][100010];//进行了i轮传球，停在j手上，方案数 
int num=1;
struct node{
	int to;
	int next;
}road[50010];
int head[100010];
void build(int from,int to){
	road[++num].next=head[from];
	road[num].to=to;
	head[from]=num;
}
/*long long power(long long x,int p){
	long long ret=1;
	while(p){
		if(p&1){
			ret=(ret*x)%mod;
		}
		x=(x*x)%mod;
		p>>=1;
	}
	return ret;
}*/
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++){
		scanf("%d%d",&a[i],&b[i]);
		if(a[i]==b[i])continue;
		read[++cnt]=a[i];
		read[++cnt]=b[i];
	}
	read[++cnt]=1;
	sort(read+1,read+cnt+1);
	int cnt2=0;
	for(int i=1;i<=cnt;i++){
		if(i==1||read[i]!=read[i-1]){
			s[++cnt2]=read[i];
		}
	}
	for(int i=1;i<=k;i++){
		a[i]=lower_bound(s+1,s+cnt2+1,a[i])-s;
		b[i]=lower_bound(s+1,s+cnt2+1,b[i])-s;
		if(a[i]==b[i])continue;
		build(b[i],a[i]);//注意这里边是反着建的，方便DP
	}//以上是离散化
	k=cnt2;
	f[0][1]=1;
	long long presum=1;
	for(int i=1;i<=m;i++){
		for(int j=0;j<=k;j++){
			f[1][j]=(presum+1ll*(n-k)*f[0][0]%mod)%mod;//总方案数
		}
		presum=0;
		for(int j=0;j<=k;j++){
			for(int t=head[j];t;t=road[t].next){
				int y=road[t].to;
				f[1][j]=(f[1][j]-f[0][y]+mod)%mod;//不合法方案
			}
			f[1][j]=(f[1][j]-f[0][j]+mod)%mod;//自己不能传给自己
			if(j)presum=(presum+f[1][j])%mod;
		}
		for(int j=0;j<=k;j++){
			f[0][j]=f[1][j];
			f[1][j]=0;
		}
	}
	printf("%lld\n",f[0][1]);
	return 0;
}
```

---

## 作者：万万没想到 (赞：3)

[题目传送门：P5888 传球游戏](https://www.luogu.com.cn/problem/P5888)

题目大意：n个人传球，从1号开始，共传球m次，每个人可以传给除自己外的人，还有k个条件，第a[ i ]个人不能传给第b[ i ]个人。

## 35pts

对于k=0的情况，我们来画一个图，是我们探索规律的起点。

![](https://cdn.luogu.com.cn/upload/image_hosting/4k27ocqm.png)

如图，第i行的第j个答案，我们称其为dp[ i ][ j ]，是由上一行除了自身以外的所有答案之和组成的。

由于没有传球时1号有球，所以dp[ 0 ][ 1 ]=1，按照这个样子递推下来，得到第一阶段的答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/wo3ma926.png)
如图，如果a[ i ]不可以传球给b[ i ]，那么b[ i ]的就会缺少上一行的答案。用总的减去这一部分，就有了35pts的部分分，就是n<=50000的部分分，时间复杂度O（nm）。

## 45pts

这一个部分分就是用35部分分的程序跑一下k=0的小数据，会很容易发现规律，即可线性递推，时间复杂度O（m）。

## 100pts

对于k<=300和k<=50000是一个道理，就放在一起说。
![](https://cdn.luogu.com.cn/upload/image_hosting/6crm5mrs.png)
经过观察我们发现，如果对于一个人来说，他不是某一个b[ i ]，那么他就同其他不属于b[ i ]的递推原理相同，由于初始值相同，所以值相同，可以并成一个点来算，算总和时再乘个数即可，对于1号和其他b[ i ]由于初始值不同，所以我们将其看做不同的点来算。

由于n<=1000000000，而k<=500000，所以我们将分开的点聚拢，这样才不会超空间，我这里用的是map，有的人用lower_bound，各人不同，再用滚动数组优化空间，即可满分，时间复杂度O（mk），注意常数，尽量避免取模，顺便说一下C++负数取模还是负数，应该将其变成正数。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[50005],b[50005],que[100005],cnt,temp,step;
long long dp[2][100005],MOD=998244353,sum;
map<int,int>vis;
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(register int i=1;i<=k;++i){
		scanf("%d%d",&a[i],&b[i]);
		if(a[i]!=b[i])que[++cnt]=a[i],que[++cnt]=b[i];
		else --i,--k;
	}
	que[++cnt]=1;
	sort(que+1,que+cnt+1);
	for(register int i=1;i<=cnt;++i){
		if(que[i]!=que[i-1])vis[que[i]]=++temp;
	}
	for(register int i=1;i<=k;++i){
		a[i]=vis[a[i]],b[i]=vis[b[i]];
	}
	temp=n-temp,dp[0][1]=1;
	for(register int i=1;i<=m;++i){
		step=1-step,sum=dp[1-step][0]*temp%MOD;
		for(register int j=1;j<=n-temp;++j){
			sum=sum+dp[1-step][j];
			if(sum>=MOD)sum-=MOD;
		}
		for(register int j=0;j<=n-temp;++j){
			dp[step][j]=sum-dp[1-step][j];
			if(dp[step][j]<0)dp[step][j]=MOD+dp[step][j];
		}
		for(register int j=1;j<=k;++j){
			dp[step][b[j]]=dp[step][b[j]]-dp[1-step][a[j]];
			if(dp[step][b[j]]<0)dp[step][b[j]]=MOD+dp[step][b[j]];
		}
	}
	printf("%lld\n",dp[step][1]);
	return 0;
}
```


---

## 作者：gyh20 (赞：2)

对于$10$%的数据：

令$f[i]$表示传$i$次在1号手上的方案。

$g[i]$表示传$i$次不在1号手上的方案。

由于没有其他限制，所以：

$f[i]=g[i-1]*(n-1)+f[i-1]*(n-2)$
//可选择的个数

$g[i]=f[i-1]$//显而易见

最后输出$g[m]$即可

虽然分不多，但这为我们提供了一种很重要的思想。

对于另外 $15$% 的数据	$n≤500$:

令$f[i][j]$表示第$i$次传到第$j$个人手上的方案数，枚举上一个位置，并判断是否可行。

时间复杂度$O(n^2m)$

对于另外 $20$% 的数据：$n≤5×10^4$

还是上一个方法，每次枚举太浪费时间，用链表存储每一个点$x$不能传到的点$y$，并且令$f[i+1][y]-=f[i][x]$，就不需要浪费枚举的时间。

时间复杂度$O(nm+mk)$

对于$100$%的数据,$1<=n<=10^9,0<=k<=min(n*(n-1),5*10^4),1<=m<=200$

n虽然很大，但$k$很小，我们可以从$k$入手

$k$如此小，说明很多的点根本没有出现在限制条件中，可以按最开始的方法将所有没出现的化为一个点。

将所有的限制条件离散化，再按照上述方法即可。

时间复杂度:~~常数极大的~~$O(nk)$

可以尝试一下手动开$O(3)$，会有惊人的发现(我直接快了$3$s+)

注意事项：

1.离散化后最多有$2k$个点，数组要开够。

2.空间很卡，需要用滚动数组。

3.$1$是一个特殊的点，离散化中一定要给$1$留一个位置。

4.滚动数组注意初值。

代码（不要管卡常的东西，建议第一遍不要加）：

```
#pragma GCC optimize(2,3)
#include<cstdio>
#include<algorithm>
using namespace std;
#define re register
#define M 998244353
const int Mxdt=50000;
inline char gc(){
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
	int res=0;char ch=gc();
	while(ch<'0'||ch>'9')ch=gc();
	while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=gc();
	return res;
}
struct edge{
	int to,next;
}e[200002];
int tot,head[100005];
inline void add(re int x,re int y){
	e[++tot].to=y;
	e[tot].next=head[x];
	head[x]=tot;
}
int n,m,f[100002],f1[100002],f2[100002],p,b,ans,cd[100002],cd1,rd1,x[100002],y[100002],r[100002],cnt,sum,w[100002];
signed main(){
	n=read();
	m=read(); 
	p=read();
	if(m==0){
		puts("1");
		return 0;
	}
	r[++cnt]=1;
	for(re int i=1;i<=p;++i){
		x[i]=read();
		y[i]=read();
		if(x[i]==y[i]){
		--p,--i;continue;}
		r[++cnt]=x[i];
		r[++cnt]=y[i];
	}
	sort(r+1,r+cnt+1);
	int l=unique(r+1,r+cnt+1)-r-1;
	for(re int i=1;i<=p;++i){
		x[i]=lower_bound(r,r+l,x[i])-r;
		y[i]=lower_bound(r,r+l,y[i])-r;
		add(x[i],y[i]);
	}
	f[1]=1;
	sum=1;
	for(re int i=head[1];i;i=e[i].next)--f1[e[i].to];
	for(re int i=1;i<=m;i++){
		for(re int j=1;j<=l;++j){
			f1[j]+=sum-f[j];
			if(f1[j]>0)f1[j]-=M;
			if(f1[j]<0)f1[j]+=M;
			for(re int k=head[j];k;k=e[k].next){
				f2[e[k].to]-=f1[j];
				f2[e[k].to]%=M;
			}w[i]=(w[i]+1ll*f[j]*(n-l))%M;
		}
		sum=w[i]=(w[i]+1ll*w[i-1]*(n-l-1))%M;
		for(re int j=1;j<=l;++j){
		sum+=f1[j];sum%=M,f[j]=f1[j],f[j]%=M;if(f[j]<0)f[j]+=M;f1[j]=f2[j],f1[j]%=M;if(f1[j]<0)f1[j]+=M;f2[j]=0;}
	//	printf("%lld %lld\n",f[i][1],sum);
	}
	printf("%lld",f[1]%M);
}
```



---

## 作者：cscy (赞：2)

这题感觉和今年csp-s组的day2 t1 思路很像。

首先朴素算法很好想，
dp[i][j] += dp[i-1][k]
其中
j!=k

但是你一看数据就发现两个问题：

1，状态存不下
 2，转移太多，时间不够
 
 于是考虑压缩状态.
 
 首先我们知道不受任何限制的人之间互相传是与序号无关的，只与数量有关，因此考虑直接把不受限的人压成一个状态dp[i][0],表示所有不受限制的人在第i次传球的方案数，取余受限制的人单独开2*k个状态
 
 那么压缩后的转移还剩四种：
 
 1.不受限制的人传给不受限制的人
 
 2.不受限制的人传给受限制的人
 
 3.受限制的人传给不受限制的人
 
 4.受限制的人传给受限制的人
 

这样只存受限制的人因此需要1e5的空间

 其中第四种可能出现非法方案，那么考虑一个一个减去即可。
 
 定义free为不受限制人数，nonf为受限人数
 
 定义s = sigma dp[i][j] (0<=j<=nonf)
 
 然后大力转移，再减去所有非法方案，就完成一层转移，其中需要转移m层
 
 时间复杂度O（m*k） 开滚动数组的话空间复杂度是k的
 
 注意事项：
 
 1需要离散化（然而我的离散化非常丑陋）
 
 2取余的话因为有减法，要小心出现负数！
 
 3 dp[i][0]因为压缩了free个人所以要乘free
 
 4一号人无论是否受限都要单独开状态
 
 最后贴上丑陋的代码
 
 ```
#include <cstdio>
#include <iostream>
#include <algorithm>
#define rep(i,a,b) for(int i=a; i<=b; i++)
#define ll long long
#define free Free

using namespace std;

int n,m,k;
struct Dual{
	int num;
	int pos;
};
ll dp[2][100010];
ll p = 998244353;
int a[50010];
int b[50010];
int free;
int nonf;

bool cmp(Dual a, Dual b){
	return a.num < b.num;
}

bool cmp2(Dual a, Dual b){
	return a.pos < b.pos;
}

void Display(){
	rep(i,1,k){
		printf("%d %d\n",a[i], b[i]);
	}
}

void ParseIn(){
	scanf("%d %d %d",&n,&m,&k);
	Dual tmp[100010];
	rep(i,1,k){
		scanf("%d %d",&tmp[i*2-1].num, &tmp[i*2].num);
		tmp[i*2-1].pos = i*2-1;
		tmp[i*2].pos = i*2;
	}
	sort(tmp+1,tmp+1+2*k,cmp);
	int pre=0;
	int cnt= tmp[1].num==1?0:1;
	rep(i,1,2*k){
		if(pre==tmp[i].num)tmp[i].num=cnt;
		else{
			pre=tmp[i].num;
			tmp[i].num = ++cnt;
		}
	}
	sort(tmp+1,tmp+1+k*2,cmp2);
	rep(i,1,k){
		int from = tmp[i*2-1].num;
		int to   = tmp[i*2].num;
		a[i] = from;
		b[i] = to;
	}
	free = n - cnt;
	nonf = cnt;
	//printf("free=%d nonf=%d\n",free,nonf);
}

void Display2(int k){
		rep(i,0,nonf){
			printf("%d ",dp[k%2][i]);
		}
		printf("\n");
}

void Core(){
	dp[1][1] = 1;
	
	rep(i,1,m){
		ll s=0;
		rep(j,0,nonf){          //全传 
			s += dp[i%2][j];
			s %= p;
		}
		dp[(i+1)%2][0] = s*free;
		dp[(i+1)%2][0] -= dp[i%2][0];
		dp[(i+1)%2][0] %= p;
		
		rep(j,1,nonf){          //去掉自己 
			dp[(i+1)%2][j] =  s;
			dp[(i+1)%2][j] += p;
			dp[(i+1)%2][j] -= dp[i%2][j];
		}
		rep(j,1,k){
			if(a[j]==b[j])continue;
			dp[(i+1)%2][b[j]] += p;
			dp[(i+1)%2][b[j]] -= dp[i%2][a[j]];
		}
		rep(j,1,nonf){
			dp[(i+1)%2][j] %= p;
		}
	}
	//Display2();
}

int main(){
	ParseIn();
	//Display();
	if(m<2){
		printf("%d\n",0);
		return 0;
	}
	Core();
	//Display2();
	printf("%lld\n",dp[(m+1)%2][1]);
	return 0;
}


```


---

## 作者：Otomachi_Una_ (赞：1)

## 题目简述

$n$ 人传球，球一开始在 $1$ 号上，传 $m$ 次。有 $k$ 条限制条件，$a_i$ 不能传给 $b_i$，求球最终回到 $1$ 号的方案数。

## 解题思路

观察数据范围，$n\leq10^9,m\leq200$ 所以有很多人是没有限制的。

于是，我们可以把这些人视为同一人，其他人给一个新的从 $1$ 开始的编号。就变成一个简单的 dp。

假设 $f_{i,j}$ 为球在第 $i$ 轮传到 $j$ 上的方案数，得到转移方程：

$$f_{i,j}=s_{i-1}-\sum_{\{j,k\}=\{a_t,b_t\}}f_{i-1,k}$$

显然，我们可以压掉一维，变成滚动数组。

余下的快速找 $k$ 可以用类似向前星的方法。

## 代码实现

虽然思想上很简单，可真正实现起来缺很繁杂。

```cpp
#include<iostream>
#include<map>
using namespace std;
#define ll long long
const int MAXN=1e5+5;
const ll MOD=998244353;
int n,m,k,a,b,cnt=0;
ll ot,pe;
ll f[2][MAXN];//滚动数组 
ll s;
map<int,int> bh;//顾名思义，编号为 i 的二次编号为 BH[i] 
struct node{
	int from,to,last;
}p[MAXN];
int nex[MAXN];
int End=0;
void add(int u,int v){
	if(u==v)
		return;
	for(int i=nex[u];i;i=p[i].last)
		if(p[i].to==v)
			return;
	End++;
	p[End].from=u,p[End].to=v;
	p[End].last=nex[u];
	nex[u]=End;
	return;
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++){
		cin>>a>>b;
		if(!bh[a]) bh[a]=++cnt;
		if(!bh[b]) bh[b]=++cnt;
		add(bh[a],bh[b]);
		add(bh[a],bh[b]);
	}
	if(!bh[1]) bh[1]=++cnt; 
	f[0][bh[1]]=1,s=1;
	pe=n-cnt;
	for(int i=1;i<=m;i++){
		int x=i%2,y=(i+1)%2;//现编号,前编号 
		for(int j=1;j<=cnt;j++)
			f[x][j]=s;
		for(int j=1;j<=cnt;j++){
			for(int t=nex[j];t;t=p[t].last)
				f[x][j]=(f[x][j]-f[y][p[t].to]+MOD)%MOD;
			f[x][j]=(f[x][j]-f[y][j]+MOD)%MOD;
		}
		ot=(s-ot+MOD*MOD)%MOD;
		s=ot*pe;
		for(int j=1;j<=cnt;j++)
			s=(s+f[x][j])%MOD;
	}
	cout<<f[m%2][bh[1]];
	return 0;
}
```


---

## 作者：caidzh (赞：1)

由于$k$比较小，正难则反可能会比较方便，于是我们考虑算全部方案和不合法方案

全部方案很好算，如果你像我一样提前打出一个暴力的话就会很容易发现：我们把点分成$1$号点和非$1$号点，对于状态$f_{i,j}$表示$j$时刻传到$i$手里的方案数

若$i=1$，存在递推公式：

$$\begin{cases}f_{i,j}=(n-1)f_{i,j-1}-(n-1)[j\text{为奇数}]\\f_{i,j}=(n-1)f_{i,j-1}+(n+1)[j\text{为偶数}]\end{cases}$$

若$i\ne1$，存在递推公式：

$$\begin{cases}f_{i,j}=(n-1)f_{i,j-1}+1[j\text{为奇数}]\\f_{i,j}=(n-1)f_{i,j-1}-1[j\text{为偶数}]\end{cases}$$

然后我们来算不合法方案，设$g_{i,j}$表示$j$时刻传到$i$的不合法方案数

如果当前的转移是由点$x$转移过来的，且$(x,i)$为一条非法边，那么我们要继承的是$f_{x,j-1}$，如果是由一条合法边转移过来的，我们要继承的是$g_{x,j-1}$

至此思考$dp$的过程已经结束，接下来我们考虑优化这个$dp$

注意到本质上相同的点非常多，也就是不带任何约束的点是非常多的，所以我们仅仅只需要记录一下带约束点的$g$值，对于其他点用一个变量统计他们的值即可

可是这样我们还是要枚举转移过来的点，这很不舒服，注意到我们仅仅只是用少数的$f$去替换了$g$，因此我们定义$S_x=\sum_{i=1}^ng_{i,x}$，改写一下转移方程就做完了

记录带约束点的$g$值需要先进行一次离散化，但是我不知道为什么一定要把$1$加进去，也就是就算$1$没有约束也要把它当成有约束的点
```cpp
#include<bits/stdc++.h>
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
const int maxn=210,mod=998244353;
int n,m,k,f[maxn][2],S,tmp[100010],a[50010],b[50010],cnt,g[100010][2],G;vector<int>vec[100010];
void Pre(){sort(tmp+1,tmp+cnt+1);cnt=unique(tmp+1,tmp+cnt+1)-tmp-1;}
int main()
{
	n=read();m=read();k=read();
	if(m==1){cout<<0;return 0;}f[1][0]=0;f[1][1]=1;f[0][0]=1;
	for(int i=2;i<=m;i++)
		if(i&1){
			f[i][0]=((1ll*f[i-1][0]*(n-1)%mod-(n-1))%mod+mod)%mod;
			f[i][1]=((1ll*f[i-1][1]*(n-1)%mod+1)%mod+mod)%mod;
		}
		else{
			f[i][0]=((1ll*f[i-1][0]*(n-1)%mod+(n-1))%mod+mod)%mod;
			f[i][1]=((1ll*f[i-1][1]*(n-1)%mod-1)%mod+mod)%mod;
		}int flag=0;tmp[++cnt]=1;
	for(int i=1;i<=k;i++){
		a[i]=read();b[i]=read();if(a[i]==b[i])continue;tmp[++cnt]=a[i];tmp[++cnt]=b[i];
		if(a[i]==1||b[i]==1)flag=1;
	}Pre();
	for(int i=1;i<=k;i++){
		if(a[i]==b[i])continue;
		a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;
		b[i]=lower_bound(tmp+1,tmp+cnt+1,b[i])-tmp;
		vec[b[i]].push_back(a[i]);
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=cnt;j++){
			g[j][i&1]=((S-g[j][(i&1)^1])%mod+mod)%mod;
			for(int l=0;l<vec[j].size();l++){
				int x=vec[j][l];
				if(x==1)g[j][i&1]=((g[j][i&1]-g[x][(i&1)^1]+f[i-1][0])%mod+mod)%mod;
				else g[j][i&1]=((g[j][i&1]-g[x][(i&1)^1]+f[i-1][1])%mod+mod)%mod;
			}
		}G=((S-G)%mod+mod)%mod;S=1ll*(n-cnt)*G%mod;
		for(int j=1;j<=cnt;j++)S=(S+g[j][i&1])%mod;
	}printf("%d",((f[m][0]-g[1][m&1])%mod+mod)%mod);return 0;
}
```


---

## 作者：LJ07 (赞：0)

考虑普通传球 $dp$，有 $dp_{i,j}=\sum dp_{i-1,v}[\texttt{v可以传球给j}]$。

发现大多数人的转移方程大同小异，发现**只有 $1$ 和题目限制的那些球员比较特殊**。

那么就把那些平凡的球员压成一个虚拟球员，那么球员数就降为了 $O(K)$ 级别的。

然后就运用普通传球 $dp$ 求解就结束了。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int K(5e4),P(998244353);
int n,m,k,a[K+5],b[K+5];
int d[K*2+5],les;
LL dp[2][K*2+5];
vector<int>g[K*2+5];
int main()
{
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>m>>k;
	d[++*d]=1;
	for(int i(1);i<=k;++i)cin>>a[i]>>b[i],d[++*d]=a[i],d[++*d]=b[i];
	sort(d+1,d+1+*d),*d=unique(d+1,d+1+*d)-(d+1);
	les=n-*d;
	#define ask(x) (lower_bound(d+1,d+1+*d,x)-d)
	for(int i(1);i<=k;++i)
		if(a[i]!=b[i])
			g[ask(b[i])].push_back(ask(a[i]));
	dp[0][ask(1)]=1;
	for(int i(1);i<=m;++i)
	{
		LL sum(0),nw(i&1),pr(!nw);
		for(int j(0);j<=*d;++j)(sum+=dp[pr][j]*(!j?les:1))%=P;
		dp[nw][0]=(sum-dp[pr][0]+P)%P;
		for(int j(1);j<=*d;++j)
		{
			dp[nw][j]=(sum-dp[pr][j]+P)%P;
			for(int v:g[j]) (dp[nw][j]+=P-dp[pr][v])%=P;
		}
	}
	cout<<dp[m&1][ask(1)];
	return 0;
}

```

---


# 樱花，还有你

## 题目背景

Dear Ling,   
&emsp;&emsp;呐，你知道吗？听说樱花飘落的速度是秒速五厘米哦。    
&emsp;&emsp;……所以，再等等吧！三月，武汉大学，樱花就快来了呢。  
&emsp;&emsp;你一定会陪我一起看吧，在酥软的阳光下，我会悄悄牵起你的手，感受你熟悉的温度，糟糕，脸儿也不小心被粉嫩嫩的樱花映红的呢。  
&emsp;&emsp;对了，一定记得带口罩！你那时还是有些虚弱吧。但天依会保护你的！  
&emsp;&emsp;还有啊，樱花还可以做好多好多的点心呢！收集一些飘落樱花吧，我想喝樱花茶，还想吃樱饼，你一定要亲手给我做嗷！

## 题目描述

**与题意有关的句子已加粗。**

但别急，我们就这样彳亍而行吧，**需不着停留或回头**，前面不是**还有 $k$ 棵樱花树么**？我算了算，你可要收集**恰好 $n$ 朵樱花**。我还发现，在第 $i$ 棵树下**最多**能收集到 $s_i$ 朵樱花（收集了 $0$ 朵樱花也算收集了樱花）。  

呐，考考你吧！你有多少种方案能够收集到**恰好 $n$ 朵樱花**呢？

**特殊地，如果你收集不到 $n$ 朵樱花，请告诉我 `impossible`。**   

注意：如果你早早地收集到了 $n$ 朵樱花，你可以立刻告诉我，也可以陪我继续向前走，一直到第 $k$ 棵樱花树下收集了樱花后就必须交差啦！期间你在任何一棵树收集完樱花后就告诉我，形成的方案都是不同的哦！

## 说明/提示

#### 样例解释 #1
我们以下列方式表示一种方案：$(a_1,a_2,\cdots,a_{len})$，其中 $\sum_{i=1}^{len} a_i =n$，$len$ 表示在第 $len$ 棵樱花树下收集完樱花后就交差了，$a_i$ 表示在第 $i$ 棵树下收集了 $a_i$ 朵樱花。

那么有下列 $5$ 种方案：$(1,1,1)$，$(1,1,1,0)$，$(0,1,1,1)$，$(1,0,1,1)$，$(1,1,0,1)$。

---

#### 样例解释 #3
最多能收集到 $9$ 朵樱花，所以不能收集到 $10$ 朵樱花，输出 `impossible`。

---

#### 数据范围
**本题采用捆绑测试。**
- Subtask 1（5 Points），$\sum s_i < n$。
- Subtask 2（20 Points），$n,k \leq 20$。
- Subtask 3（55 Points），$n,k \leq 5\times 10^2$。
- Subtask 4（20 Points），$n,k \leq 5\times 10^3$。

对于 $100\%$ 的数据，$1 \leq n,k \leq 5\times 10^3$，$0 \leq s_i \leq n$。

---

#### 题目背景 ( 续 )
&emsp;&emsp;何等聪明的你一定会站在某棵树下，捧着 $n$ 朵可爱的樱花，像孩子似的向我邀功吧。  
&emsp;&emsp;那就别怪我成全你哦，我会轻跳起来，环住你的脖子，揭起你的口罩，尝一尝你的嘴唇。  
&emsp;&emsp;你会不会说，“像樱花一样甜”呢？  
&emsp;&emsp;反正，我的脸一定已经像樱花一样红了吧。  
&emsp;&emsp;……  
&emsp;&emsp;当你看到这封信，别哭呀……  
&emsp;&emsp;冬天从这座城市夺走的，春天会补偿我们的。  
&emsp;&emsp;待你好了，陪我去看樱花，可好？  

Yours,   
Yi

## 样例 #1

### 输入

```
3 4
1 1 1 1```

### 输出

```
5```

## 样例 #2

### 输入

```
10 9
9 6 8 7 9 6 5 4 3```

### 输出

```
68345```

## 样例 #3

### 输入

```
10 5
2 2 2 2 1```

### 输出

```
impossible```

# 题解

## 作者：淸梣ling (赞：14)

# porblem
[P6394](https://www.luogu.com.cn/problem/P6394)

与[摆花](https://www.luogu.com.cn/problem/P1077)很相似。~~（其实就是摆花加强版）~~

#### 大意：
有 $k$ 棵树，每棵树下有 $s_i$ 朵樱花，求收集樱花数量总和为 $n$ 的方案数。**可以在任意一棵树下结束**。

------------

此题 $DP$ 与递推的思路其实是差不多的，严格来说还是个 $DP$ 题。详细思路可以看其他大佬题解。

细读题目，这不就是一道多重背包吗？此时我们将背包容量看成樱花数，那么 $f_{p}$ 为摘 $p$ 朵樱花的方案数，~~那么就可以直接做了~~。

```cpp
for(i=1;i<=k;i++)//前i棵树
 for(p=n;p>=0;p--)//多重背包转换为01背包
  for(j=1;j<=min(s[i],p);j++)
   f[p]=(f[p]+f[p-j])%10086001;
```


然而此时看一眼数据 $1\le n,k\le5\times10^{3}$,显然多重背包 $O(kn^2)$ 的时间还是太耗时了，此时观察第三层循环，
每次的 $f_p$ 都是加上一个区间，所以可以直接用一个前缀和来计算，那么第三层循环就可以省掉了。

最后附上 $AC$ 代码，时间复杂度 $O(nk)$

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int M=10086001;
int f[5001];
long long s[5001];//前缀和
int num,ans;

int main()
{
	int n,t,i,j,p,k;
	cin>>n>>k;
	
	s[0]=f[0]=1;

	for(i=1;i<=k;i++)
	{
		cin>>t;
		
		for(j=1;j<=n;j++)//更新前缀和
		s[j]=s[j-1]+f[j];
		
		for(p=n;p>=0;p--)//多重背包
		f[p]=(f[p]+s[p-1]-s[p-min(t,p)-1])%M;//利用前缀和
		
		num+=t;//判断是否有解
		ans=(ans+f[n])%M;//累加第i棵树下收集n朵花的方案
		
	}
	
	if(num<n)
	cout<<"impossible";
	else
	cout<<ans;
	return 0;
}
```


---

## 作者：AlicX (赞：7)

### 前言
此题的题目背景很浪漫呢，本人略微补充了一下：[樱花，还有你](https://www.luogu.com.cn/blog/706523/ying-hua-huan-you-ni)。双倍经验：[摆花](https://www.luogu.com.cn/problem/P1077)。前置知识：动态规划、前缀和。

## 思路
- 暴力：首先你应该能看出这是一道动态规划题吧，那我们直接设计暴力状态：令 $f(i,j)$ 表示在第 $i$ 棵树下，已经搜集了 $j$ 朵樱花的方案数。考虑转移：首先需要枚举一个 $i$，然后枚举一个 $j$，最后枚举一个 $l$，表示在第 $i$ 棵樱花树下搜集了 $l$ 朵樱花，那么状态转移方程很明显了吧：$f(i,j) \leftarrow f(i, j) + f(i-1,j-l)$。但是分析时间复杂度可以得出时间复杂度是 $O(n^2k)$ 的，显然会超时，所以我们要优化。

- 优化一：观察我们最后一层循环枚举的 $l$，发现 $l$ 是一段连续的和，所以我们可以用前缀和将它优化掉。令 $g_i$ 表示前 $i$ 个 $f$ 数组的和，那么 $g_j=g_{j-1}+f(i,j)$，特别的，$g_0=f(i,0)$。算出了 $g_i$，那么里面的循环就可以优化掉，分两种情况：当 $j>a_i$ 时，因为我们只需要 $f(i,j-a_i)$ 到 $f(i,j)$ 的和，所以这时状态转移方程为 $f(i,j)=g_j-g_{j-a_i-1}$。否则直接 $f(i,j)=g_j$ 就可以了。但是出题人卡了空间，我们开二维数组是过不了的，所以我们还要将 $f$ 数组优化为一维数组。

- 优化二：我们发现：$f$ 数组的转移全是由 $g$ 数组来转移的，而 $g$ 数组也只靠上一次的 $f$ 数组来转移，所以我们可以将 $f$ 数组滚动为一维数组。看到题解里很多大佬都滚动为两种状态，其实一种状态就足够了。那么我们现在的代码就可以通过本题了。


- 细节：判断是否能搜集到 $n$ 朵樱花的时候，只需要将 $a$ 数组求和就可以了，当 $k=1$ 时可以直接求出来，转移时从 $k=2$ 开始转移就可以了。注意取模。

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define I_LOVE_JY return
#define I_LOVE_JJY 0
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=5e3+10,mod=10086001;
int n,k;
int a[N];
int f[N],g[N];
signed main(){
	cin>>n>>k;
	int sum=0;
	for(int i=1;i<=k;i++) cin>>a[i],sum+=a[i];
	if(sum<n){
		cout<<"impossible"<<endl;
		return 0;
	}
	int ans=0;
	g[0]=f[0]=1;
	for(int i=1;i<=a[1];i++) f[i]=1; 
	for(int i=1;i<=n;i++) g[i]=g[i-1]+f[i];
	if(a[1]>=n) ans++;
	for(int i=2;i<=k;i++){
		for(int j=0;j<=n;j++){
			if(j>a[i]) f[j]=(g[j]-g[j-a[i]-1])%mod;
			else f[j]=g[j];
		}
		ans=(ans+f[n])%mod,g[0]=f[0];
		for(int j=1;j<=n;j++) g[j]=(g[j-1]+f[j])%mod;
	}
	cout<<(ans+mod)%mod<<endl;
	I_LOVE_JY I_LOVE_JJY;
}
```
献给 $JY$。

---

## 作者：人间温柔 (赞：4)

~~好浪漫的一道题啊~~

一道 $dp$ 的题。我们记 $f[i][j]$ 表示我和她在第 $i$ 棵树前，目标是收集到 $j$ 朵樱花。

状态转移方程就是：
$$
f[i][j]= \sum_{x=0}^{\min(j,s[i])}f[i-1][j-x]
$$
最后$answer=\sum_{i=1}^kf[i][n]$

则 $dp$ 部分的代码如下：
```cpp
for(int i=2;i<=k;i++)
  for(int j=1;j<=n;j++)
    for(int k=0;k<=min(j,s[i]);k++)
    {
        f[i][j]+=f[i-1][j-k];
        f[i][j]%=mod;
    }
```
很显然，这种方式的时间复杂度太大，为 $O(n^2k)$，对于本题，$n_{max}=k_{max}=3 \times 10^5$，明显太大，$TLE$ 了。

所以我们要对现有的方法进行改进。

第一步前缀和优化。记$sum\_f[s]=\sum_{x=0}^sf[x][s]$。于是原来的状态转移方程就转化为$f[i][j]=sum\_f[j]-sum\_f[j-s[i]-1]$

第二步，$j-s[i]-1<0$ 的情况不是不可能，所以我们要分类讨论：
$$
f[i][j]=
\begin{cases}
sum\_f[j]-sum\_f[j-s[i]-1]&(j>s[i])\\
sum\_f[j]&(j\leq s[i])
\end{cases}
$$
有些人可能会问，$f[i][j]$ 在转移的时候，$i$ 貌似没有用呀。

是的。

所以，第三步就是把 $i$ 这一维可以压掉（去掉）：
$$
f[j]=
\begin{cases}
sum\_f[j]-sum\_f[j-s[i]-1]&(j>s[i])\\
sum\_f[j]&(j\leq s[i])
\end{cases}
$$
以上就是最终的方程。下面给出 $AC$ 代码：
```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;
const int mod=10086001;
const int N=5005;
int n,k,all_flower,ans;
int a[N];
int f[N],sum_f[N];
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>a[i];
		if(i==1)
		{
			sum_f[0]=1;
			for(int j=1;j<=a[i];j++)
			{
				sum_f[j]=sum_f[j-1]+1;
			}
			for(int j=a[i]+1;j<=n;j++)
			{
				sum_f[j]=sum_f[j-1];
			}
			if(a[i]>=n)
			{
				ans++;
			}
		}
		all_flower+=a[i];
	}
	if(all_flower<n)//如果总共都没有n多樱花，那就别想了
	{
		cout<<"impossible";
		return 0;
	}
	for(int i=2;i<=k;i++)//dp
	{
		for(int j=0;j<=n;j++)
		{
			if(j>a[i]) f[j]=(sum_f[j]-sum_f[j-a[i]-1])%mod;
			else f[j]=sum_f[j];
		}
		sum_f[0]=f[0];
		for(int pos=1;pos<=n;pos++) sum_f[pos]=(sum_f[pos-1]+f[pos])%mod;//前缀和
		ans=(ans+f[n])%mod;
	}
	cout<<(ans+mod)%mod;
	return 0;
}
```

---

## 作者：苏黎世 (赞：3)

怎么说呢，这题的背景实在是浪漫，看得我都想恋爱的QWQ。

~~于是我果断```Ctrl + C，Ctrl + V```发到了朋友圈里，瞬间收获无数少女的青睐，大家都在惊叹，好浪漫，好暖男啊~~~

咳咳，现在步入正题。

### 题目概括：
有已知棵树，每棵树上有已知量的樱花，求恰好摘取一定量樱花的总方案数量。

~~别看了别看了，一点都不浪漫。~~

乍一看，我还以为是个完全背包，只是价值和重量都相同。不过当我信誓旦旦地打完后，发现样例都过不去。

于是点开标签，发现是个前缀和。

所以说，这题思路：
#### 用01背包优化的完全背包（不是二进制拆分和单调队列）再加上前缀和。

虽然说这题中说了恰好，但是不能初始化成```-INT_MAX```，因为要求的是方案总数，所以我们并没有用到max，而是直接相加。

做dp题的话，如果一开始没有思路，就用多维，把所有的量都表示一下，亿维的方程还是比一维好推一点的，然后再一点点优化掉，这样是基本的过程。~~（注意亿字）~~

#### 第一种思路：二维。
设f(i,j) 表示在前 i 棵樱花树一共收集到了 j 朵樱花。

然后定义一个变量k（0 <= k <= min(j, s[i]）)，用来枚举。

然后递推式子就是：```f(i,j) += f(i-1,j-k)。```

最后把结果累加即可。

#### 第二种思路：一维。
我们令f[i]表示恰好收集i朵樱花的方案数量。

首先我们想到了完全背包的暴力写法：
```cpp
for(i = 1;i <= k; ++i)//前i棵树
 for(p = n;p >= 0; --p)//多重背包转换为01背包
  for(j = 1;j <= min(s[i], p); ++j)
   f[p]=(f[p]+f[p-j])%10086001;
```
但是会发现，这样会T掉。

于是我们用上前缀和，成功解决这个问题。

个人觉得这个代码还算是比较简洁了吧。

## Code：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long ll;//前缀和注意
const int maxn = 5e3 + 5;
const int K = 10086001;
int n, k, s;
ll sum[maxn], sm;
int f[maxn], ans;
int main()
{
	int i, j, v;
	scanf("%d%d", &n, &k);
	sum[0] = f[0] = 1;
	for(i = 1;i <= k; ++i)
	{
		scanf("%d", &s);
		
		for(j = 1;j <= n; ++j)
		  sum[j] = sum[j-1] + f[j];//更新前缀和
		 
		for(v = n;v >= 0; --v)//01背包跑一遍
		  f[v] = (f[v] + sum[v - 1] - sum[v - min(s, v) - 1])%K;
		  
		sm += s;//判断有没有n朵樱花
		
		ans = (ans + f[n]) % K;
	}
	
	if(sm < n)
	  puts("impossible");
	else
	  printf("%d", ans);
	return 0;
}
```
浪漫的题，代码也要很浪漫啊。

---

## 作者：紊莫 (赞：1)

主要分析动态规划的优化过程。

## Step 1

首先想一个朴素做法，由于此类题较为典型，这里直接给出状态，``dp[i][j]`` 表示前 $i$ 棵樱花树摘到 $j$ 朵樱花的方案数，方程为：  

$dp_{i,j}=\sum_{q=0}^{\min \{j,s_i\}}dp_{i-1,j-q}  $  

那么可以写出一个 $O(n^3)$ 的朴素动规。  
代码：略。  

## Step 2

重新审视方程，发现后面的一堆完全可以前缀和带走，这样时间复杂度就降到了 $O(n^2)$。  

代码：  
```cpp
for(int i=1;i<=k;i++)
{
	for(int j=1;j<=n;j++)
		dp[i-1][j]=(dp[i-1][j]+dp[i-1][j-1])%mod;
	for(int j=0;j<=n;j++) 
	{
		int l=j-min(j,s[i]),r=j;
		dp[i][j]=(dp[i-1][r]-dp[i-1][l-1])%mod;
	}
	ans=(ans+dp[i][n]+mod)%mod;
}
```  

## Step 3

如果你交上刚刚的代码，也许会获得 $\text{80 pts}$ 至 $\text{100 pts}$ 的好成绩，原因是内存超限，观察题目发现：  
>内存限制 64.00MB

这很简单，因为 $dp_{i}$ 只会由 $dp_{i-1}$ 转移而来，那么可以加上滚动数组，就能通过本题。  

代码：略。  

## Step 4

进一步想到 $dp$ 只和题中的 $s$ 数组有关，那么完全可以直接省掉第一维，参考多重背包的方法即可。  

代码：略，详见其他题解。

## 后记

至此，本题已经被优雅的解决，其中写动态规划的优化过程也是在提示我们：不需要每道题一上来就写正解，通过稍劣的解法逐步推出正解也是值得提倡的写法。  

UPD 10月15日：修改格式和笔误。

---

## 作者：HappyJaPhy (赞：1)

# P6394 题解
## 前言
- [超浪漫的原题](https://www.luogu.com.cn/problem/P6394)
- [博客看文更佳](https://www.luogu.com.cn/blog/ImDustSans/solution-p6394)

## 题意
- 在 $n$ 种物品中，每种最多选择 $s_i$ 个，问恰巧选出 $m$ 个物品的方案数（一模一样的题目：[摆花](https://www.luogu.com.cn/problem/P1077)）。

## 分析
### 状态及转移的设计
- 这是一道很~~浪漫且~~经典的 DP 题。设 $f_{i,j}$ 表示在第 $i$ 颗树下正好收集到 $j$ 朵樱花，初始状态 $f_{0,0}=1$。写出基本的转移方程：
$$f_{i,j}=\sum_{l=j-s_i}^jf_{i-1,l}$$
- 就是这么简单（吗）！分析一下时间复杂度就能发现，这个做法是 $O(nm^2)$ 的，只能通过 $80\text{pts}$ 的分数。那该怎么办呢？
- 通过观察转移方程式可以发现，我们要求的 $\sum$ 中的 $f$ 是在**连续区间内**的！因此我们可以**加入前缀和来优化转移**，设 $pre_{i,j}$ 表示 $\sum_{k=1}^jf_{i,k}$，于是就能将转移方程改为：
$$f_{i,j}=pre_{i-1,j}-pre_{i-1,k-1}$$
- 这里 $k=\max(0, j-s_i)$。如果 $k=0$，那么就不用减去 $pre_{i-1,k-1}$ 一项了（毕竟在某种程度上说，$pre_{i-1,-1}=0$）。并且，我们在计算 $f$ 的同时就可以计算 $pre$（小卡常）。
- **注意：取模时两个 $pre$ 相减可能出现负数，注意要判负！**~~（别问我怎么知道）~~

#### 上代码！

```cpp
#include <bits/stdc++.h>
#define N 5003
#define mod 10086001
using namespace std;
int n, m, s[N], f[N][N], pre[N][N], ans;

inline void read(int &x) {
	char ch = x = 0;
	while (ch < '0' || ch > '9') {
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + ch - 48;
		ch = getchar();
	}
	return ;
}

int main() {
	read(m), read(n);
	int sum = 0;
	for (int i = 1; i <= n; i++) {
		read(s[i]);
		sum += s[i];
	}
	if (sum < m) { //判断 IMP
	    printf("impossible");
	    return 0;
	}
	f[0][0] = 1; //初始状态 
	for (int i = 0; i <= m; i++) { //注意要提前赋值 
		pre[0][i] = 1;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= m; j++) {
			int minn = max(j - s[i], 0);
			f[i][j] = pre[i - 1][j];
			if (minn) f[i][j] -= pre[i - 1][minn - 1]; //计算转移 
			while (f[i][j] < 0) f[i][j] += mod; //解决出现负数的情况 
			pre[i][j] = f[i][j];
			if (j) pre[i][j] = (pre[i][j] + pre[i][j - 1]) % mod;
		}
	}
	for (int i = 1; i <= n; i++) { //统计答案 
		ans = (ans + f[i][m]) % mod;
	}
	printf("%d", ans);
	return 0;
}
```

- [但是嘛……](https://www.luogu.com.cn/record/123283968)

### 空间优化
- 经过两次提交后我才发现（~~好吧我眼睛确实有点问题~~）——这题他只给了 $64.00\text{MiB}$ 的空间！（~~卡不了时间就狂卡空间是吧？~~）
- 接下来就该考虑空间上的优化了。让我们再次看看 $f$ 的转移方程还有 $pre$ 的计算方程：
$$\begin{array}{c}
f_{i,j}=pre_{i-1,j}-pre_{i-1,k-1}\\
pre_{i,j}=pre_{i,j-1}+f_{i,j}
\end{array}$$
- 可以发现，所有的方程都只与 $i$ 和 $i-1$ 上的变量有关！因此我们就可以**压缩掉第一维**（注意：$f$ 在计算时是要用到之前的 $pre$ 的，因此我们需要**把 $f$ 和 $pre$ 分开计算，避免覆盖**）。
- 这时就有人要问了：“那你最后统计答案怎么办？这道题**在每棵树下都能结束**啊？”那就每个 $f_m$ 算完就统计答案啊！（摇头叹气状）~~（这不废话嘛）~~

#### AC code

```cpp
#include <bits/stdc++.h>
#define N 5003
#define mod 10086001
using namespace std;
int n, m, s[N], f[N], pre[N], ans;

inline void read(int &x) {
	char ch = x = 0;
	while (ch < '0' || ch > '9') {
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + ch - 48;
		ch = getchar();
	}
	return ;
}

int main() {
	read(m), read(n);
	int sum = 0;
	for (int i = 1; i <= n; i++) {
		read(s[i]);
		sum += s[i];
	}
	if (sum < m) { //判断 IMP
		printf("impossible");
		return 0;
	}
	f[0] = 1;
	for (int i = 0; i <= m; i++) {
		pre[i] = 1;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= m; j++) {
			int minn = max(j - s[i], 0);
			f[j] = pre[j];
			if (minn) f[j] -= pre[minn - 1];
			while (f[j] < 0) f[j] += mod; //计算转移并判负 
		}
		pre[0] = f[0];
		for (int j = 1; j <= m; j++) {
			pre[j] = (f[j] + pre[j - 1]) % mod; //先计算 f 后计算 pre
		}
		ans = (ans + f[m]) % mod; //直接统计答案 
	}
	printf("%d", ans);
	return 0;
}
```

- 感谢能阅读到这里的各位！如有错误，欢迎指出！

---

## 作者：cwfxlh (赞：0)

# P6394
### [题面传送门](https://www.luogu.com.cn/problem/P6394)
____
题意很简洁，很明显可以看出来是一个 dp，以我们丰富的经验，很简单就能搞出来一个 dp 式子:  
令 $dp_{i,j}$ 表示走到前 i 棵树为止，摘掉 j 朵樱花的方案总和，则有：  
$$dp_{i,j}=\sum_{p=0}^{\min(j,s[i])}dp_{i-1,j-p}$$   
$$ans=\sum_{i=1}^{n}dp_{i,k}$$
把代码写出来，大概是这样子的。   
```cpp
scanf("%lld%lld",&k,&n);
for(int i=1;i<=n;i++)
{
	dp[i][0]=1;
	scanf("%lld",&s[i]);
	pre[i]=pre[i-1]+s[i];
}
if(pre[n]<k)
{
	printf("impossible");
	return 0;
}
dp[0][0]=1;
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=k;j++)
	{
		for(int o=0;o<=s[i]&&o<=j;o++)
		{
			dp[i][j]+=dp[i-1][j-o];
			dp[i][j]%=MOD;
		}
	}
}
for(int i=1;i<=n;i++)
{
	ans+=dp[i][k];
	ans%=MOD;
}
```
很遗憾，只有 80pts，最后一组数据时间空间都要爆，那么先来优化时间。  
注意到我们的 dp 是用了三层循环的，而最后一层循环的累加下标是连续的。那么我们可以想到用前缀和维护一下这个和，在每一层循环的时候都记一下这一层循环 dp 数组的前缀和，下一层调用上一层的前缀和即可。   
而空间问题很好解决，dp 和 pre 数组都用滚动数组优化一下就可以了。   
附上代码。   
```cpp
#include<bits/stdc++.h>
#define MOD 10086001
using namespace std;
long long n,k,s[6003],dp[5003],ans,pre[10003],pre2[4][5003];
int main()
{
	scanf("%lld%lld",&k,&n);
	for(int i=1;i<=n;i++)
	{
		pre2[i%2][0]=1;
		scanf("%lld",&s[i]);
		pre[i]=pre[i-1]+s[i];
	}
	dp[0]=1;
	if(pre[n]<k)
	{
		printf("impossible");
		return 0;
	}
	pre2[0][0]=1;
	for(int i=0;i<=1;i++)
	{
		for(int j=1;j<=k;j++)
		{
			pre2[i%2][j]=pre2[i%2][j-1];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=k;j++)
		{
			dp[j]=pre2[(i-1)%2][j];
			if(j-s[i]>0)dp[j]-=pre2[(i-1)%2][j-s[i]-1];
			dp[j]%=MOD;
			pre2[i%2][j]=pre2[i%2][j-1]+dp[j];
		}
		ans+=dp[k];
		ans%=MOD;
	}
	printf("%lld",ans);
	return 0;
} 
```
祝各位早日 AC。

---

## 作者：Cure_Wing (赞：0)

### 题目
* [P6394 樱花，还有你](https://www.luogu.com.cn/problem/P6394)。

### 解析
* 很明显是一道背包问题。
* 定义 $f_{i,j}$ 表示在前 $i$ 棵樱花树中收集了 $j$ 朵樱花的方案数。
* 状态转移方程为 $f_{i,j}=\sum\limits^j_{k=\max\{j-s_i,0\}}f_{i-1,k}$。
* 但这样的时间复杂度是 $\mathcal{O}(kn^2)$ 的，直接起飞。
* 考虑前缀和优化，定义 $t_i=\sum\limits^i_{j=0}f_{l,j}\left(1\le l\le k\right)$，这样就可以 $O(1)$ 计算 $f_{i,j}=\begin{cases}t_j-t_{j-s_i-1}&(j>s_i)\\t_j&(j\le s_i)\end{cases}$。
* 考虑状态转移的过程，$f$ 数组只与 $t$ 数组有关，可以直接舍去 $f$ 的第一维。
* 答案由原来的的 $f_{k,n}$ 转变为 $\sum f_n$。
* 由于计算第一棵树时没有任何的准备，所以第一棵树考虑单独计算。
* 时间复杂度 $\mathcal{O}(kn)$，空间复杂度 $\mathcal{O}(k)$。

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define int long long
using std::cin;using std::cout;
constexpr int N=5003,mod=10086001;
int n,k,s[N],f[N],t[N],ans;
signed main(){
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
    cin>>n>>k;
    for(int i=1;i<=k;++i) cin>>s[i],s[0]+=s[i];
    if(s[0]<n){
    	cout<<"impossible";
    	return 0;
	} 
    for(int i=0;i<=n;++i) t[i]=std::min(i+1,s[1]+1),f[i]=1*(i<=s[1]);
    ans+=(s[1]>=n);
    for(int i=2;i<=k;++i){
        for(int j=0;j<=n;++j){
            if(j>s[i]) f[j]=(t[j]-t[j-s[i]-1]+mod)%mod;
            else f[j]=t[j];
        }
        t[0]=f[0];
        for(int j=1;j<=n;++j) t[j]=(t[j-1]+f[j])%mod;
        ans=(ans+f[n]+mod)%mod;
    }
    if(ans) cout<<ans;
    else cout<<"impossible";
    return 0;
}
```

---

## 作者：新手7889456 (赞：0)

## 首先，第一个点很显然

$\sum s < n$的话直接就输出`"impossible"`

## 然后就是朴素的[摆花](https://www.luogu.com.cn/problem/P1077)能拿到80分的好成绩

**注意**：很坑的一个地方就是，如果半道捡满了，也要另算方案

其中$dp[i][j]$表示dp到第$i$棵树，已经捡了$j$朵樱花的方案数

然后显然的转移方程就出现了：
$$
dp[i][j] += dp[i-1][j-k]
$$

其中$k$表示这棵树捡$k$朵樱花

当然，我们发现$i$这个状态是能用滚动数组滚掉的，于是**代码**如下：

```
#include<iostream>
#include<cstdio>
#define p 10086001
using namespace std;
int n,m,sum;
int a[5001];
long long dp[5001],ans;//开成long long以防万一


int main()
{
	scanf("%d%d",&n,&m);
	for(register int i(1);i<=m;++i) {
		scanf("%d",&a[i]);
		sum += a[i];
	}
	if(sum <= n) return printf("impossible"),0;
	for(register int i(0);i<=a[1];++i) dp[i]=1;//然后要注意的小地方就是这里的初始化要从0开始
	for(register int i(2);i<=m;++i)
	{
		ans+=dp[n];
		ans %= p;
		for(register int j(n);j>=0;--j)
		for(register int k(1);k<=min(a[i],j);++k)
		{
			dp[j] += dp[j-k];
			dp[j] %= p;
		}
	}
	printf("%lld",(dp[n]+ans)%p);
	return 0;
}
```

## 正解

~~这时我惊奇地发现我没有思路了，于是我机智的打开了标签~~

然后这时我发现我们可以用前缀和优化掉最里层的一层循环

上代码：

```
#include<iostream>
#include<cstdio>
#define max(a,b) (a) < (b) ? (b) : (a)
#define p 10086001
using namespace std;
int n,m,sum;
int a[5001];
long long dp[5001],ans,az[5001];//开成long long以防万一


int main()
{
	scanf("%d%d",&n,&m);
	for(register int i(1);i<=m;++i) {
		scanf("%d",&a[i]);
		sum += a[i];
	}
	if(sum <= n) return printf("impossible"),0;
	for(register int i(0);i<=a[1];++i) az[i]=i+1;//然后要注意的小地方就是这里的初始化要从0开始
	for(register int i(a[1]+1);i<=n;++i) az[i]=az[i-1];
	ans += (a[1]>=n);
	for(register int i(2);i<=m;++i)
	{
		for(register int j(1);j<=n;++j)
		{
			dp[j] = az[j] - (j-a[i]-1 < 0 ? 0 : az[j-a[i]-1]);
			dp[j]%=p;
		}
		for(register int j(1);j<=n;++j){
			az[j] = az[j-1] + dp[j];
			az[j] %= p;
		}
		ans+=dp[n];
		ans %= p;
	}
	printf("%lld",(ans+p)%p);
	return 0;
}
```



---

## 作者：Little09 (赞：0)

直接考虑 dp。令 $dp[i][j]$ 表示到第 $i$ 棵樱花树，摘了 $j$ 片樱花的可能方案数。转移方程很显然，就是枚举在每个树下摘的几片樱花：

$$dp[i][j]=\sum_{k=0}^{min(a[i],j)}dp[i-1][j-k]$$

发现只有上一次会产生影响，所以把 $i$ 滚动掉可以得到 80pts。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s;
const int mod=10086001;
int a[5003],dp[5003][2],ans;
int main()
{
    cin >> m >> n;
    for (int i=1;i<=n;i++) 
	{
		cin >> a[i];
		s+=a[i];
	}
	if (s<m) 
	{
		printf("impossible");
		return 0;
	}
    dp[0][0]=1;
    for (int i=1;i<=n;i++)
    {
    	for (int k=0;k<=m;k++)
    	{
    		dp[k][i%2]=0;
    		for (int j=0;j<=a[i];j++) if (k-j>=0) dp[k][i%2]=(dp[k][i%2]+dp[k-j][(i-1)%2]%mod);
		}
		ans+=dp[m][i%2];
		ans%=mod;
	}
	cout << ans;
	return 0;
}

```

在此基础上考虑优化。很显然，转移方程里有求和的形式，可以想到前缀和。

先把 $dp$ 改成一维的，令 $s$ 是 $dp$ 的前缀和，每次的 $dp$ 可以由 $s$ 推到过来。只要每次求一下 $s$ 就好了。复杂度是 $O(nk)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum;
const int mod=10086001;
int a[5003],dp[5003],s[5003],ans;
inline int read()
{
	char C=getchar();
	int F=1,ANS=0;
	while (C<'0'||C>'9')
	{
		if (C=='-') F=-1;
		C=getchar();
	}
	while (C>='0'&&C<='9')
	{
		ANS=ANS*10+C-'0';
		C=getchar();
	}
	return F*ANS;
} 
int main()
{
    m=read(),n=read();
    for (int i=1;i<=n;i++) 
	{
		a[i]=read();
		sum+=a[i];
	}
	if (sum<m) 
	{
		printf("impossible");
		return 0;
	}
    dp[0]=1;
    for (int i=1;i<=n;i++)
    {
    	s[0]=dp[0];
    	for (int k=1;k<=m;k++) s[k]=(dp[k]+s[k-1])%mod;
    	for (int k=0;k<=m;k++)
    	{
    		if (k-a[i]-1<0) dp[k]=s[k];
    		else dp[k]=(s[k]-s[k-a[i]-1]+mod)%mod;
		}
		ans+=dp[m];
		ans%=mod;
	}
	cout << ans;
	return 0;
}

```

---


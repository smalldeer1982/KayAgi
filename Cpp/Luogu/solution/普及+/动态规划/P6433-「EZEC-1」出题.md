# 「EZEC-1」出题

## 题目背景

你是一个毒瘤出题人。

## 题目描述

已知你有 $n$ 道毒瘤题，已经出好了题面，但数据还没出好。你还剩下 $m$ 的时间，每道题的毒瘤程度为 $a_{i}$，出数据的时间是 $x_{i}$，你有 $k$ 个老师，每个老师可以把一道题的毒瘤程度翻倍（每道题目最多被翻倍一次）。你的父母由于坚决反对你出公开赛，抢走了你的一道题，现在老师和父母的行动你都可以控制，但每位老师和父母的行为必须执行，请问你要怎么做，才能使出的题毒瘤程度之和最大？

## 说明/提示

【样例解释】

样例 $1$ ：

你控制你的父母拿走 $T1$ ，然后配 $T2$ 和 $T3$ 的数据，同时将 $T2$ 的毒瘤值翻倍，所以毒瘤值最大是 $15$

------------

【数据范围】

对于 $30\%$ 的数据，$ 0 \le x_{i} \le m $，$0 \le m \le 100 $，$2 \le n \le 10$，$ k<n$。

对于另外 $20\%$ 的数据，保证 $k=0$。

对于 $100\%$ 的数据，$0 \le a_{i} \le 1000$，$ 0 \le x_{i} \le m $，$0 \le m \le 1000 $，$0 \le n \le 100$，$ k<n$。

upd in 2020.7.6：添加一组 hack 数据。

## 样例 #1

### 输入

```
3 10 1
6 9
7 2
1 8```

### 输出

```
15```

## 样例 #2

### 输入

```
5 20 2
5 3 
9 7
2 6
7 8
1 2```

### 输出

```
38```

## 样例 #3

### 输入

```
3 6 2
5 4
3 3
3 3```

### 输出

```
12```

# 题解

## 作者：pigstd (赞：38)

**update on 7.7**:出题人谢罪，修改了一些锅，~~原来的数据太水了~~，希望管理员重新通过一下

此题是一道简单的背包$dp$。

先特判一遍，如果所有 $x_{i}$ 的和小于等于 $m$ ，那么就是一个贪心（因为父母会偷掉一道题），否则的话就不用管父母（因为不能全部出完数据，让父母偷掉一道没有出数据的题就可以了）。

然后用 $dp_{i,j}$ 表示用 $i$ 时间，使用 $j$ 次翻倍后可以得到的最大毒瘤值。

对于每一对 $a_{i}$ 和 $x_{i}$ ，都有 $dp_{i,j} = \max(dp_{i,j} , dp_{i-x_i , j} + a_i , dp_{i-x_i , j-1} + 2 \times a_i )$

同时，老师可能没有用完，所以取 $dp$ 数组中的最大值即可。

c++代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,k,f[1005][105];
int a[1005],x[1005],sum,ans=0;

int cmp(int a,int b)
{
	return a>b;
}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for (int i=1;i<=n;i++)
		scanf("%d%d",&a[i],&x[i]),sum+=x[i];
	if (sum<=m)//特判
	{
		int ans=0;
		sort(a+1,a+1+n,cmp);
		for (int i=1;i<=k;i++)
			ans+=a[i]*2;
		for (int i=k+1;i<n;i++)
			ans+=a[i];
		cout<<ans;
		return 0;
	}
	for (int e=1;e<=n;e++)
		for (int i=m;i>=x[e];i--)
		{
			for (int j=min(k,e);j>=1;j--)//注意，这里要倒叙枚举
				f[i][j]=max(f[i][j],max(f[i-x[e]][j]+a[e],f[i-x[e]][j-1]+a[e]*2)),ans=max(ans,f[i][j]);
			f[i][0]=max(f[i][0],f[i-x[e]][0]+a[e]);ans=max(ans,f[i][0]);
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：xiaozeyu (赞：6)

**很多题解其实是错的！**（已经与出题人交流过了）

看一下这篇题解，不要被错误解法误了(出题人的是对的)!

这道题目的出题人![](https://cdn.luogu.com.cn/upload/image_hosting/7b4107yf.png)

在“面对背”讯问后，亲口说ta~~是用jiao造的数据~~

但是![](https://cdn.luogu.com.cn/upload/image_hosting/d7xbcj4o.png)

看下范围：

![](https://cdn.luogu.com.cn/upload/image_hosting/ovltnt47.png)

这一下子hack了除出题人的之外所有题解（~2020.7.11）

------------

## 1.1 做法

有$k$个老师与$1$对父母

$ k < n \to k+1\le n $

时间 $x_i $ 价值$a_i$

$\sum\limits_{i=1}^nx_i$ 不一定比$ m$大

分类讨论

$sum= \sum\limits_{i=1}^nx_i$

$\begin{cases} tanxin &sum\le m \\ dp & sum>m \end{cases}$

## 1.2 具体

贪心部分：

因为时间足够，父母取走一个，可以从大到小排个序，把前$k$ 大的都$\times 2$ , 把 $ k<num<n$的加上去

背包dp部分：

当来不及时，用背包

父母取走一个，给他们没有做（超出时候舍弃的）的，也就是不用管父母了

$dp_{i,j}$ 表示用 $i$时间，操作 $j$次后可以得到的最大值

$\begin{cases} dp_{i,j}=\max(dp_{i,j},dp_{i-x_i,j}+a_i,dp_{i-x_i,j}+2 \cdot a_i) & \\ dp_{i,0}=\max(dp_{i,0},dp_{i-x_i,0}+a_i) & j=0 \end{cases}$


$ans=\max(max,dp_{i,j})$

$ans=\max(max,dp_{i,0})$

## 2.1 hack

一组hack数据：让别人无路可走

```cpp
3 1 2
0 1
1 0
0 1

```

在背包的循环中：

第三层循环应该用倒叙循环已经操作的次数，为什呢？

如果正序的话，就有可能重复对一个数字操作两次

比如

```cpp

for(re int i=1;i<=n;i++)
{
   for(re int j=m;j>=b[i];--j)
   {
     for(re int l=0;l<=k;++l)
     {
        f[j][l]=max(f[j][l],f[j-b[i]][l]+a[i]);
        if(l)f[j][l]=max(f[j][l],f[j-b[i]][l-1]+a[i]*2);
     }
   }
}
```

这一种会有操作同一个数据两次的可能，但是以前数据太水了，以至于其他人AC并且写了题解误了人

[这种也是错的](https://www.luogu.com.cn/blog/Amateur-threshold/solution-p6433)

正确的应该是：

```cpp
#define For(i,a,b) for(register int i=a;i<=b;i++)
#define Rep(i,a,b) for(register int i=a;i>=b;i--)
```

```cpp
For(num,1,n)
	Rep(i,m,b[num])
	{
		Rep(j,min(k,num),1)
		{
			f[i][j]=max(f[i][j],max(f[i-b[num]][j]+a[num],f[i-b[num]][j-1]+a[num]*2));
			ans=max(ans,f[i][j]);
		}	
		f[i][0]=max(f[i][0],f[i-b[num]][0]+a[num]);
		ans=max(ans,f[i][0]);
	}	
```
希望看到的人不要进入这个误区，那样写只会害了你



------------

## 3.1 完整

完整的代码

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=a;i<=b;i++)
#define Rep(i,a,b) for(register int i=a;i>=b;i--)
using namespace std;
inline int read()
{
	char c=getchar();int x=0;bool f=0;
	while(!isdigit(c))f^=!(c^45),c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f)x=-x;return x;
}
int n,m,k,ans,sum;
int f[1005][1005];
int a[1005],b[1005];
bool cmp(int a,int b)
{
	return a>b;
}
void run1()// sum<=m 贪心 
{
	sort(a+1,a+n+1,cmp);
	For(i,1,k)
		ans+=a[i]*2;
	For(i,k+1,n-1)
		ans+=a[i];
}
void run2()//sum>m 背包 
{
	For(num,1,n)
		Rep(i,m,b[num])
		{
			Rep(j,min(k,num),1)
			{
				f[i][j]=max(f[i][j],max(f[i-b[num]][j]+a[num],f[i-b[num]][j-1]+a[num]*2));
				ans=max(ans,f[i][j]);
			}	
			f[i][0]=max(f[i][0],f[i-b[num]][0]+a[num]);
			ans=max(ans,f[i][0]);
		}	
			
}
int main()
{
	n=read();m=read();k=read();
	For(i,1,n)
	{
		a[i]=read();b[i]=read();
		sum+=b[i];
	}
	if(sum<=m) run1();
	else run2();
	cout<<ans;
}

```

---

## 作者：钓鱼王子 (赞：4)

一道背包 DP。

设 $f_{x,i,j}$ 表示前 $x$ 道题，花费 $i$ 的时间，使用 $j$ 次翻倍的最大价值。可以类似背包转移，同时也可以用滚动数组。

记得特判 $j=0$ 的情况。

然后，如果选择了全部，就要删去价值最小的（不能选全部）。

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#include<bits/stdc++.h>
#define re register
using namespace std;
const int Mxdt=5000;	//单次大小
inline char gc() {
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
#define gc getchar
inline int read() {
	re int t=0;
	re char v=gc();
	while(v<'0')v=gc();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=gc();
	return t;
}
int n,m,f[1002][1002],a[1002],b[1002],k,sum,mn;
int main() {
	n=read();m=read();k=read();mn=1e9;
	for(re int i=1;i<=n;++i)a[i]=read(),b[i]=read(),sum+=b[i],mn=min(mn,a[i]);
	for(re int i=1;i<=n;++i){
		for(re int j=m;j>=b[i];--j){
			for(re int l=0;l<=k;++l){
				f[j][l]=max(f[j][l],f[j-b[i]][l]+a[i]);
				if(l)f[j][l]=max(f[j][l],f[j-b[i]][l-1]+a[i]*2);
			}
		}
	}
	if(sum<=m)f[m][k]-=mn;
	printf("%d",f[m][k]);
}
```


---

## 作者：auroral (赞：3)

题意：有$n$个物品，每个物品价值为$w_i$，所占空间为$t_i$，背包容量为$m$，有$k$次物品价值翻倍的机会（每件物品价值只能翻倍一次），必须从中取走一件，问背包所装物品的最大价值

其实前半部分就是01背包，我们要处理的是后面两个操作。

### 操作1：取走一件

这个放在第一个讲是因为比较好推，容易发现，当背包容量足够全部取完时，扔掉最小价值的物品即可；当背包容量不够取不完的时候，直接扔掉没有取的物品，对结果没有影响。

### 操作2：$k$次翻倍

还是分成两种情况。当背包容量足够全部取完时，让最大价值的几个物品翻倍即可；当背包容量不够全部取完时，我们在01背包的基础上加一维，用$f[j][c]$表示背包空间使用$j$，还剩$c$次翻倍机会所能获得的最大价值，在01背包的基础上增加对翻倍机会$c$的枚举，如果物品翻倍，则从$f[j-t[i]][c+1]$递推；如果物品不翻倍，则从$f[j-t[i]][c]$递推。

递推核心代码：
```cpp
for(R ll c=0;c<k;c++){//枚举剩下的翻倍次数 
    f[j][c]=max(f[j][c],f[j-t[i]][c+1]+w[i]*2);
    //如果该物品翻倍，则从f[j-t[i]][c+1]递推 
    f[j][c]=max(f[j][c],f[j-t[i]][c]+w[i]);
    //如果该物品不翻倍，则从f[j-t[i]][c]递推 
}
f[j][k]=max(f[j][k],f[j-t[i]][k]+w[i]);
//c=k时特殊判断，因为此时不能翻倍 
```


AC代码：
```cpp
#include<bits/stdc++.h>
#define ll int
#define R register
using namespace std;
inline ll read(){//快读 
    ll pa=1,f=0;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')pa=-1;ch=getchar();}
    while(ch<='9'&&ch>='0'){f=(f<<3)+(f<<1)+(ch^48);ch=getchar();}
    return f*pa;
}
inline void write(ll x){//快写 
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
};
ll n,m,k,sum,minn=10005,maxx;
ll w[105],t[105],f[1005][105];
int main(){
    n=read();m=read();k=read();
    for(R ll i=1;i<=n;i++){
        w[i]=read(),t[i]=read();
        minn=min(minn,t[i]);//记录最小的物品所占空间
        sum+=t[i];//累加物品空间
    }
    if(sum<=m){//背包够装全部物品 
        sum=0;sort(w+1,w+n+1);//那么不考虑空间，直接按物品价值排序  
        for(R ll i=n;i>=n-k+1;i--)
        sum+=w[i]*2;//物品价值最大的几件价值翻倍 
        for(R ll i=n-k;i>=2;i--)//除了最小价值的物品扔掉，全部累加 
        sum+=w[i];
        write(sum);return 0;
    }
    for(R ll i=1;i<=n;i++){//背包不够装所有物品，这是01背包第一维，枚举物品 
        for(R ll j=m;j>=minn;j--)
        //这是01背包第二维，枚举所占空间，直接从最小的物品所占空间枚举，缩小枚举范围 
        if(j>=t[i]){//如果装得下该物品 
            for(R ll c=0;c<k;c++){//枚举剩下的翻倍次数 
                f[j][c]=max(f[j][c],f[j-t[i]][c+1]+w[i]*2);
                //如果该物品翻倍，则从f[j-t[i]][c+1]递推 
                f[j][c]=max(f[j][c],f[j-t[i]][c]+w[i]);
                //如果该物品不翻倍，则从f[j-t[i]][c]递推 
            }
            f[j][k]=max(f[j][k],f[j-t[i]][k]+w[i]);
            //c=k时特殊判断，因为此时不能翻倍
        }
    }
    write(f[m][0]);//肯定是全部翻倍次数用完的情况总价值最大 
    return 0;
}
```
我总感觉自己的写法太暴力了，有更优的解法欢迎留言，有问题的也可以在评论区问我。

#### p.s. 感谢_Freedom_大佬指出错误，改代码的时候脑残把一行删掉了。

---

## 作者：RedLycoris (赞：3)

首先，我们可以先选择题目，再把剩下不要的让家长拿走。这一定是最优的。

然后就是个基础的背包。dp[i][j]表示考虑带第i个题目时，花费了j个时间的最大毒瘤值。
为了最后的计算，还要记录一下路径。

最后通过记录的路径求出选了那些题目，然后贪心的从大到小排序，选前k个*2即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[101][1001],par[101][1001],k;
int a[101],b[101],n,m;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;++i)cin>>a[i]>>b[i];
	for(int i=1;i<=n;++i){
		for(int j=0;j<=m;++j){
			dp[i][j]=dp[i-1][j],par[i][j]=j;
			if(j>=b[i]){
				if(dp[i][j]<dp[i-1][j-b[i]]+a[i]){
					dp[i][j]=dp[i-1][j-b[i]]+a[i];
					par[i][j]=j-b[i];  //记录路径
				}
			}
		}
	}
	vector<int>v;v.clear();
	int mx=-1,wz,ans=0;
	for(int i=0;i<=m;++i){
		if(dp[n][i]>mx){
			mx=dp[n][i];
			wz=i;
		}
	}
	for(int i=n;i;--i){
		int T=par[i][wz];
		if(T==wz);
		else{
			v.push_back(a[i]);
			wz=T;
		}
	}
	sort(v.rbegin(),v.rend());
	if(!v.size()){  //一个特判
		cout<<0<<'\n';
		return 0;
	}
	if(v.size()==n)v.pop_back();
	for(int i=0;i<v.size();++i){
		if(i<k)ans+=v[i]*2;
		else ans+=v[i];
	}
	cout<<ans<<'\n';
}
```

---

## 作者：一只书虫仔 (赞：0)

#### Description

> 有 $n$ 个物品，第 $i$ 个物品的容量为 $w_i$，价值为 $v_i$，背包的容量为 $W$，出题人会偷走一个物品，你有 $k$ 个机会可以让 $k$ 个物品的价值翻倍，求得到的最大价值和（你可以控制出题人的行为）。

#### Solution

我们先把出题人处理掉 [魔鬼笑]，分两种情况讨论：

- $\sum w_i \le W$，那么让出题人偷走 $v_i$ 最小的物品即可；
- $\sum w_i > W$，我们就不需要管出题人了 [魔鬼笑]，因为肯定不能放入所有物品。

接下来再看翻倍，我们可以升维到状态里，设 $f_{j,k}$ 为当前容量为 $j$ 翻倍了 $k$ 个物品得到的最大价值和，改一下 01 背包板子的转移方程则有：

$$f_{j,k}=\max\{f_{j,k},f_{j-w_i,k}+v_i,f_{j-w_i,k-1}+2 \times v_i\}$$

简单解释：$f_{j,k}$ 可以从三种情况转移过来：

- 不选择第 $i$ 个物品；
- 选择第 $i$ 个物品，不翻倍；
- 选择第 $i$ 个物品，翻倍。

总之，这题是早期 EZEC 良心签到题，再次批判现在 EZEC 的大毒瘤题。

#### Code

有一些细节需要注意：

- 枚举 $k$ 时要倒序，与 01 背包中倒序枚举 $j$ 同理；
- $f_{j,0}$ 需要单独特判一下。

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, k;
struct fjrakioi {
	int w;
	int v;
} a[105];
int f[1005][105];
bool cmp (fjrakioi x, fjrakioi y) {return x.v > y.v;}

int main () {
	scanf("%d%d%d", &n, &m, &k);
	int sum = 0;
	for (int i = 1; i <= n; i++) scanf("%d%d", &a[i].v, &a[i].w), sum += a[i].w;
	sort(a + 1, a + n + 1, cmp);
	if (sum <= m) {
		int ans = 0;
		for (int i = 1; i <= k; i++) ans += (2 * a[i].v);
		for (int i = k + 1; i < n; i++) ans += a[i].v;
		printf("%d\n", ans);
		return 0;
	}
	for (int i = 1; i <= n; i++)
		for (int j = m; j >= a[i].w; j--) {
			for (int k1 = min(k, i); k1 >= 1; k1--)
				f[j][k1] = max(f[j][k1], max(f[j - a[i].w][k1] + a[i].v, f[j - a[i].w][k1 - 1] + 2 * a[i].v));
			f[j][0] = max(f[j][0], f[j - a[i].w][0] + a[i].v);
		}
	int ans = 0;
	for (int k1 = 0; k1 <= k; k1++)
		ans = max(ans, f[m][k1]);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：TulipeNoire (赞：0)

### 思路

看到题背包dp没说了，但是这道题有两个特殊的操作——删题和翻倍。

跟大部分题相似地，把这两种操作塞进dp的第三维和第四维。那么 $dp_{i,j,k,l}$ 表示前 $i$ 道题中选若干题，时间限制为 $j$，翻倍了 $k$ 道题，删了 $l$ 道题的情况下最大的毒瘤值。（这样开是卡得过内存限制的，可能确实是数据太弱，建议可以滚动）

那么枚举 $i,j,k$（不枚举 $l$ 的原因是只有两种情况，手打就行了），暴力转移。

**还有一个值得注意的细节**，就是 $dp_{0,j,k,1}$ 的情况是不存在的（你还没有题怎么删，不就忽悠过去了吗），应当赋值为极小值。

### 代码

```cpp
#include<bits/stdc++.h>
#define N 105
#define M 1005
using namespace std;
int n,m,s,d[N],t[N],dp[N][M][N][2];//s为原题目k 
int main() {
    scanf("%d %d %d",&n,&m,&s);
    for (int i=1;i<=n;i++) {
        scanf("%d %d",&d[i],&t[i]);
    }
    for (int i=0;i<=m;i++) {
        for (int j=0;j<=s;j++) {
            dp[0][i][j][1]=-1e8;
            //将不存在的情况赋为极小值。
        }
    }
    for (int i=1;i<=n;i++) {
        for (int j=0;j<=m;j++) {
            for (int k=0;k<=s;k++) {
                if (j>=t[i]) {
                    if (k) {
                        dp[i][j][k][0]=max(dp[i-1][j][k][0],max(dp[i-1][j-t[i]][k][0]+d[i],dp[i-1][j-t[i]][k-1][0]+2*d[i]));
                        //三种选择：不选此题，选此题但不翻倍，选此题且翻倍。
                        dp[i][j][k][1]=max(dp[i-1][j][k][0],max(dp[i-1][j-t[i]][k][1]+d[i],dp[i-1][j-t[i]][k-1][1]+2*d[i]));
                        //三种选择：不选此题（相当于删掉此题），选此题但不翻倍，选此题且翻倍。
                    } else {
                        dp[i][j][k][0]=max(dp[i-1][j][k][0],dp[i-1][j-t[i]][k][0]+d[i]);
                        //无法翻倍的情况。
                        dp[i][j][k][1]=max(dp[i-1][j][k][0],dp[i-1][j-t[i]][k][1]+d[i]);
                        //无法翻倍的情况。
                    }
                } else {
                    dp[i][j][k][0]=dp[i-1][j][k][0];
                    //无法选择此题。
                    dp[i][j][k][1]=dp[i-1][j][k][0];
                    //无法选择此题（相当于删除此题）。
                }
            }
        }
    }
    printf("%d",dp[n][m][s][1]);
    return 0;
}
```

---

## 作者：Mars_Dingdang (赞：0)

本题是一道背包 dp 的好题，可以对某些物品的权值进行增益操作。

## 题目大意
已知你有 $n$ 道毒瘤题，已经出好了题面，但数据还没出好。你还剩下 $m$ 的时间，每道题的毒瘤程度为 $a_{i}$，出数据的时间是 $x_{i}$，你有 $k$ 个老师，每个老师可以把一道题的毒瘤程度翻倍（每道题目最多被翻倍一次）。你的父母由于坚决反对你出公开赛，抢走了你的一道题，现在老师和父母的行动你都可以控制，但每位老师和父母的行为必须执行，请问你要怎么做，才能使出的题毒瘤程度之和最大。

简化：有 $n$ 个物品，每个物品价值为 $w_i$，所占空间为 $t_i$，背包容量为 $m$，有 $k$ 次物品价值翻倍的机会（每件物品价值只能翻倍一次），必须从中取走一件，问背包所装物品的最大价值。

## 大体思路
### 【贪心】
本题的贪心策略是：如果背包无论如何都装不满，即 $\sum_{i=1}^n v_i\le m$，则只需要放弃权值最小的一道题，然后从大到小排序，保证权值较大的 $k$ 道题翻倍。这样所得的权值总和是 $\sum_{i=1}^n w_i+\max\sum_{i=1}^k w_i$ 显然最大。代码如下：

```cpp
	n=read(),m=read(),k=read();//顶上还有一些快读函数
	for(re int i=1;i<=n;i++){
		w[i]=read();
		v[i]=read();
		sum+=v[i];
	}//输入
	if(sum<=m){//装不满
		sort(w+1,w+n+1,greater<int>());//从大到小排序
		for(re int i=1;i<=k;i++){
			ans+=(w[i]<<1);
		}//翻倍
		for(re int i=k+1;i<=n-1;i++){
			ans+=w[i];
		}
		cout<<ans;//输出
		return 0;
	}
```

### 【背包 DP】
用 $f(i,j)$ 表示体积为 $i$，权值翻倍 $j$ 次后的最大权值和。注意坑：放弃的题目可以不用出数据，因此不用管父母的操作。

状态转移方程：$f(i,j)=\max\left\{f(i,j),f(i-v_i,j)+w_i,f(i-v_i,j-1)+2w_i\right\},ans=\max(ans,f(i,j)$。

把 $j=0$ 拎出来单独弄即可。代码如下：

```cpp
	for(re int l=1;l<=n;l++){
		for(re int i=m;i>=v[l];i--){
			for(re int j=min(l,k);j>=1;j--){
				f[i][j]=max(f[i][j],max(f[i-v[l]][j]+w[l],f[i-v[l]][j-1]+(w[l]<<1)));
				ans=max(ans,f[i][j]);
			}
			f[i][0]=max(f[i][0],f[i-v[l]][0]+w[l]);
			ans=max(ans,f[i][0]);
		}
	}
	cout<<ans;
```

---


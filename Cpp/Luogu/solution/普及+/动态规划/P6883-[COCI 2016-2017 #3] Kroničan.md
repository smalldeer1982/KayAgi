# [COCI 2016/2017 #3] Kroničan

## 题目描述

Mislav 有 $N$ 个玻璃杯，从 $1\sim N$  编号，每个玻璃杯中都有一定的水。你需要通过倒水（将某个杯子中的水倒入另一个杯子），使这些杯子中只有 $K$ 个有水。

已知将第 $i$ 号玻璃杯中的水倒入第 $j$ 号，需要消耗 $C_{i,j}$ 的代价。Mislav 想知道，经过倒水后满足只有 $K$ 个（或更少）玻璃杯中有水时，消耗的代价总和的最小值。

## 说明/提示

#### 样例 1 解释

Mislav 不需要倒水。代价和是 $0$。

#### 样例 2 解释

Mislav 需要将任意一个玻璃杯中的水倒入任何其他玻璃杯中，使其满足只有两个玻璃杯中有水。代价和为 $1$。

#### 样例 3 解释

Mislav 可以将水从玻璃杯 $4$ 倒入玻璃杯 $3$，然后将玻璃杯 $3$ 中的水倒入玻璃杯 $5$，最后将玻璃杯 $1$ 中的水倒入玻璃杯 $5$。总共付出代价和为 $1+2+2=5$。

### 数据规模与约定

对于 $40\%$ 的数据，满足 $N\le 10$。

对于 $100\%$ 的数据，满足 $1\le K\le N\le 20,C_{i,j}\le10^5$



### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T3 Kroničan_**。

## 样例 #1

### 输入

```
3 3
0 1 1
1 0 1
1 1 0 ```

### 输出

```
0```

## 样例 #2

### 输入

```
3 2
0 1 1
1 0 1
1 1 0 ```

### 输出

```
1```

## 样例 #3

### 输入

```
5 2
0 5 4 3 2
7 0 4 4 4
3 3 0 1 2
4 3 1 0 5
4 5 5 5 0 ```

### 输出

```
5```

# 题解

## 作者：y0y68 (赞：35)

~~我又来刷水题水贡献了~~

状压DP入门题。。。

先看数据范围 $1 \le m \le n \le 20$（这里及以下所说的 $m$ 都是题目中的 $k$） 心生疑惑，再看题显然DP。于是就一定是状压DP。

### 前置知识：位运算

### 一、设状态

设 $dp[i]$ 为将初始状态（即杯子全都有水）变为状态 $i$ 所需最小代价。

其中若将 $i$ 表示成二进制（如 $5$ 表示为 $101$），第 $i$ 位（这里及以下所说的第几位皆为从右往左）为 $1$，就表示第 $i$ 个杯子没水，$0$ 就表示第 $i$ 个杯子有水。

### 二、初始化

初始化 $dp$ 无穷大，$dp[0]=0$。

### 三、转移方程

$dp[i]=\min(dp[i],dp[i \oplus (1<<j)]+c[j+1][k+1])$

其中 $i$ 转成二进制后第 $j+1$ 位是 $1$，第 $k+1$ 位是 $0$。

$\oplus$ 表示按位异或，$i \oplus (1<<j)$ 表示 将 $i$ 的二进制形式中第 $j+1$ 位变成 $0$ 后的数，即第 $j+1$ 个杯子变得有水。当然有水就得倒，倒就要有花费（必须往原来就有水的杯子即第 $k+1$ 个杯子里面倒，不然无法减少有水的杯子数量），于是加上水从第 $j+1$ 倒往第 $k+1$ 个杯子的所需花费。

### 四、计算答案

枚举出所有二进制位是 $0$ 的个数小于等于 $m$ 的状态，从中取最小值，便是答案。

代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=21;
int n,m,a[N][N],dp[1<<N];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	memset(dp,0x3f,sizeof dp);
	dp[0]=0;
	for(register int i=1;i<(1<<n);i++)
		for(register int j=0;j<n;j++)
			if(i&(1<<j))//判断第j+1位是不是1
				for(register int k=0;k<n;k++)
					if(!(i&(1<<k)))//判断第k+1位是不是0
                    				dp[i]=min(dp[i],dp[i^(1<<j)]+a[j+1][k+1]);
	int ans=-1u/2;//即2的31次方-1
	for(register int i=0;i<(1<<n);i++){
		int cnt=0;
		for(register int j=0;j<n;j++)
			if(!(i&(1<<j)))cnt++;//统计有几位是0
		if(cnt<=m)ans=min(ans,dp[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```

点个赞再走吧o(￣▽￣)o

---

## 作者：Lucky_Cloud (赞：4)

一眼丁真：一道**简单的入门的小清新状压好题**。

## 分析

根据题意，每一个杯子只有有水或没水这两种状态。很容易想到用二进制去表示。有水为 $0$，没水为 $1$。

举个例子，有两个杯子所有杯子都没有水，那么状态为 $11$。

设 $dp[i]$ 表示从初始状态到状态 $i$ 所需的最小代价。

另外我们可以想到一个性质，例如说 $x$ 倒入 $y$ 中，$z$ 再倒往 $y$ 中，$y$ 倒入 $k$ 中与 $x$ 倒入 $y$ 中，$y$ 再倒往 $k$ 中，$z$ 倒往 $y$ 中，$y$ 有再一次倒入 $k$ 中是等价的。也就是倒入一个空杯子中与倒往这个杯子没空的时候可能是一样的。所以对于每一个状态 $i$，若当前有一个水杯没有水并且在上一步有水，则肯定是倒给了当前所有有水的杯子中的其中一个，而不是倒入没水的杯中。就不用算重复的情况了。

那么我们很容易想出转移方程：

$$dp[i] = \min(dp[i \oplus (1 << j)] + c[j][k], dp[i])$$

其中 $j$ 表示当前没有水的水杯，$k$ 表示当前有水的水杯，当然 $0 \le j, k < n$。下标从 $0$ 开始。而 $i \oplus (1 << j)$ 表示能转移到 $i$ 这个状态的状态。

初始化。

根据题意和定义 $dp[0] = 0$，其余则为正无穷。

答案就是在合法的状态中取最小值。

$0$ 的个数小于等于 $k$ 的状态即为合法。

当然，有一个小地方要注意，从 $x$ 杯倒入 $y$ 杯的价值可能不等于从 $y$ 杯 倒入 $x$ 杯的价值。

时间复杂度 $O(2^nn^2)$。对于这题够用了。

## Code

下面的 `__builtin_popcount(i)` 是求出 $i$ 在二进制下有多少个 $1$。

顺便告诉你，吸个氧就逼近最优解了。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k, dp[(1 << 20) + 5], c[25][25];

int main() {
	cin >> n >> k;
	memset(dp, 0x3f, sizeof dp);
	for (int i = 0; i < n; i++)//下标从 0 开始。
		for (int j = 0; j < n; j++)
			cin >> c[i][j];
	dp[0] = 0;
	for (int i = 1; i < (1 << n); i++) {
		for (int j = 0; j < n; j++) {
			if (i & (1 << j))//如果 j 这一杯没水。
				for (int k = 0; k < n; k++)
					if (!(i & (1 << k)))//找到当前有水的杯子，可能在上一步 j 的水倒入了 $k$。
						dp[i] = min(dp[i], dp[(i - (1 << j))] + c[j][k]);//一定是 c[j][k]
		}
	}
	int ans = 1e9;
	for (int i = 0; i < (1 << n); i++)
		if (__builtin_popcount(i) >= n - k)//也可以写成 n - __builtin_popcount(i) <= k，就是需要 0 的个数小于等于 k，或 1 的个数大于等于 k。
			ans = min(ans, dp[i]);
	cout << ans;
	return 0;
}
```

## 后记

CSP2023 后的第一篇题解~~还是随机跳题来的~~捏。

若蒟蒻有空，会解答评论区的问题的。QwQ。

蒟蒻可能有笔误，欢迎大佬们来纠正。

---

## 作者：a326820068122c (赞：3)

### 分析

发现多数题解时间复杂度为 $O(2^nn^2)$~~，想不到竟然能过~~。

这里提供一个优化的写法,时间复杂度为 $O(2^nn)$

dp 方程什么的其他题解已经说的很清楚了，这里便不再赘述

发现 dp 枚举状态后有一个枚举取 min 的地方，直接循环一遍取 min 复杂度较高。

考虑这实质就是把一个位置到一个状态中所有位置的代价取 min ，这只有 $O(2^nn)$ 种可能性，且可以
$O(2^nn)$ 预处理出 （每次加进来状态中最后一个位置）。

但是发现其需要 $O(2^nn)$ 的空间

然后发现：

>内存限制 32.00MB

这时可以把原来储存最大的数改为最大数所在的位置，然后用 unsigned char 来存储，就可以避免 MLE 了

### 代码

```cpp
#include <bits/stdc++.h>
#define for0(i,n) for(i=0;i<(n);i++)
#define for1(i,n) for(i=1;i<=(n);i++)
using namespace std;
const int N=25,M=(1<<20)+5;
int n,m,t,a[N][N],ans=1e9,dp[M];
unsigned char s[N][M],c[M];
int main(){
	int i,j,k;
	scanf("%d%d",&n,&m);
	for0(i,n) for0(j,n) scanf("%d",&a[i][j]);
	t=(1<<n)-1;
	for1(i,t) c[i]=c[i>>1]+(i&1);
	for0(i,n) for0(j,t) for0(k,n){
		if((1<<k)&j) break;
		if(j&&a[i][s[i][j]]<a[i][k]) s[i][j|(1<<k)]=s[i][j];
		else s[i][j|(1<<k)]=k;
	}
	memset(dp,0x1f,sizeof(dp));
	dp[t]=0;
	for(i=t-1;i>0;i--){
		for0(j,n) if(!(i&(1<<j)))
			dp[i]=min(dp[i],dp[i|(1<<j)]+a[j][s[j][i]]);
	}
	for1(i,t) if(c[i]<=m) ans=min(ans,dp[i]);
	printf("%d\n",ans);
	return 0;
}

```

稀里糊涂的跑成了当前的最优解（）

---

## 作者：ykzzldz (赞：2)

[题面](https://www.luogu.com.cn/problem/P6883)

观察数据范围~~和标签~~，发现这是一道状压题。首先设计状态 $dp[s]$ 表示无水集合为 $s$ 时的最小代价。初始化将 $dp[0]=0$，其他情况设为正无穷。

转移：$dp[s]=dp[s']+w$，其中 $s'$ 为比 $s$ 二进制下少一个 $1$ 的集合（此处不是指 $s=s'+1$，而是指 $s$ 中一个数位上的一在 $s'$ 中为 $0$）。

那么，剩下的就是一些细节问题了，下面给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
}ok[1<<21];
bool cmp(node a,node b){
	if(a.y==b.y)return a.x<b.x;
	return a.y<b.y;
}
int n,k,a[30][30],ans=1e9,dp[1<<21];
signed main(){
	cin>>n>>k;
	k=n-k;
	if(k==0){
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<(1<<n);i++){
		ok[i].x=i;
		ok[i].y=(long long)__builtin_popcountll(i);//这个函数可以返回 i 中二进制下一的个数
	}
	memset(dp,127,sizeof dp);
	dp[0]=0;
	sort(ok+1,ok+(1<<n),cmp);
	for(int i=1;i<(1<<n);i++){
		for(int j=1;j<=n;j++){
			if((ok[i].x|ok[j].x)==ok[i].x){
				int s=ok[i].x-ok[j].x;
				for(int k=1;k<=n;k++){
					if((ok[i].x|ok[k].x)!=ok[i].x){
						dp[ok[i].x]=min(dp[ok[i].x],dp[s]+a[j][k]);
					}
				}
			}
		}
	}
	for(int i=1;i<(1<<n);i++){
		if((long long)__builtin_popcountll(ok[i].x)==k)ans=min(ans,dp[ok[i].x]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：technopolis_2085 (赞：2)

P6883 [COCI2016-2017#3] Kroničan 题解


------------
Analysis：

首先观察这题的数据范围：

$n≤20$

数据范围很小，考虑状态压缩。

状态压缩，即把一个状态压缩成一个 $01$ 串，每一位代表这一个状态的一个信息。

对于这题，我们可以设这样一个 $n$ 位的 $01$ 状态，即当这一位是 $0$ 时，这个杯子里没有水；当这一位是 $1$ 时，这个杯子里有水。

不难发现可以用这个方法进行动态规划。

方法如下：

第一重循环枚举状态，范围为 $0$ 到 $2^n-1$。

第二、三重循环分别枚举 $pre$ 和 $nxt$ 两个变量，表示将 $pre$ 杯子中的水倒入 $nxt$ 杯子中。

转移的前继状态需要满足两个条件：$01$ 串的第 $pre$ 位不为 $0$ 和第 $nxt$ 位为 $0$。

转移的时候加上 $C_{pre,nxt}$ 即可。

总复杂度可以接受，为 $O(2^nn^2)$。


------------
Code：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=21;
int a[maxn][maxn];
int dp[1<<maxn],vis[1<<maxn];
int n,k;

int main(){
	scanf("%d%d",&n,&k);
	
	for (int i=0;i<n;i++){
		for (int j=0;j<n;j++){
			scanf("%d",&a[i][j]);
		}
	}
	
	memset(dp,0x7f,sizeof(dp));
	dp[0]=0;
	
	for (int mask=0;mask<(1<<n);mask++){
		for (int pre=0;pre<n;pre++){
			if ((mask&(1<<pre))==0) continue;
			for (int nxt=0;nxt<n;nxt++){
				if (pre==nxt) continue;
				if ((mask&(1<<nxt))) continue;
				
				dp[mask]=min(dp[mask],dp[mask^(1<<pre)]+a[pre][nxt]);
			}
		}
	}
	int ans=1e9+7;
	for (int i=0;i<(1<<n);i++){
		int cnt=0;
		for (int j=0;j<n;j++){
			if ((i&(1<<j))==0) cnt++;
		}
		
		if (cnt<=k) ans=min(ans,dp[i]);
	}
	
	printf("%d",ans);
	return 0;
}
```


---

## 作者：fls233666 (赞：2)

我们注意到 $1 \le N \le 20$，这个范围很小，于是我们可以考虑**记忆化搜索。**

首先，我们要记录下每个杯子是否有水的状态。把有水的状态记为 $1$，无水的状态记为 $0$，我们就可以用一个 $20$ 位的二进制数来表示全部的 $N$ 个杯子是否有水的状态了。

记 $f(m)$ 表示当这 $N$ 个杯子状态为 $m$ 的时，将这些杯子倒水至只有 $K$ 个杯子有水的最小代价。我们进一步考虑如何倒水。

把 $O(n^2)$ 种倒水操作都试一遍显然是错的。因为可能存在杯子 $i$ 把水倒给杯子 $j$ 后，在下一次更新状态时杯子 $j$ 又把水倒回给了杯子 $i$。我们需要减少要更新的状态，去除重复的状态。

首先要去除的就是把杯子中的水倒给自身的状态，因为 $C_{i,i}=0$，显然不会影响答案，搜了也只是浪费时间。

其次我们来考虑倒水过程中是否需要借助已经倒空的杯子。假设在一次更新中，我们用了 $C_{i,k}$ 的代价把杯子 $i$ 的水倒空，然后让杯子 $j$ 借助空的杯子 $i$ 将水也倒入杯子 $k$ 中，那么代价是 $C_{j,i}+C_{i,k}$ 总代价为 $C_{j,i}+2 \times C_{i,k}$。考虑到代价是不变的，我们为什么不先把杯子 $j$ 中的水先导入杯子 $i$ 中，再与杯子 $i$ 中原本有的水一起导入杯子 $k$ 中呢？这样需要的代价是 $C_{j,i}+ C_{i,k}$，显然更优秀。于是我们得出结论：**将杯子中的水往有水的杯子中倒，比把水往空杯子中倒更优。**

经过上述两步减少状态后，记忆化搜索就能够通过此题了。代码实现如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define rgt register int
#define qmn(a,b) a<b?a:b
using namespace std;

const int buf = (1<<22);
const int inf = 1e9+7;

int nk,n;
int f[buf],ans;
int c[22][22];

int dfs(int st,int cnt){
    if(cnt==nk)  //仅有 k 个杯子有水，达到目标状态，返回
        return 0;
    if(f[st])  //当前状态被搜过了，返回
        return f[st];
        
    f[st]=inf;
    int cost;
    for(rgt i=0;i<n;i++){
        for(rgt j=0;j<n;j++){
            if(i==j)  //倒水给自身，对答案无贡献，跳过
                continue;
            if(((1<<i)&st)&&((1<<j)&st)){  //找两个有水的杯子 i 和 j
                cost=dfs(st^(1<<i),cnt-1)+c[i][j];  //计算把杯子 i 的水倒入杯子 j 后达到目标状态需要的代价
                f[st]=qmn(f[st],cost);  //取最小代价
            }
        }
    }
    return f[st];
}

int main(){
    scanf("%d%d",&n,&nk);
    for(rgt i=0;i<n;i++)
        for(rgt j=0;j<n;j++)
            scanf("%d",&c[i][j]);
            
    ans=dfs((1<<n)-1,n);  //2^n-1 在二进制下的每一位都是1，对应每个杯子初始都是有水的状态。
    printf("%d",ans);
    return 0;
}
```


---

## 作者：ZhongYuLin (赞：1)

注意到 $n \leqslant 20$ 的数据范围，考虑状压。

具体地，设：$f_i$ 表示在状态 $i$ 下的最小代价，其中 $i$ 的第 $j$ 位为 $1$，当且仅当第 $j$ 杯有水。

考虑倒序枚举每一种状态，同时枚举每一种状态能从哪一些状态转移得来。

初始状态：$f_{2^n-1}=0$，其余设为无穷大。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20,INF=0x3f3f3f3f;
int f[1<<N],c[N][N];
int n,k,ans=INF;
int main(){
	ios::sync_with_stdio(cin.tie(cout.tie(0)));
	cin>>n>>k;for(int i=0;i<n;++i)for(int j=0;j<n;++j)cin>>c[i][j];
	memset(f,0x3f,sizeof(f));f[(1<<n)-1]=0;//初始状态 
	for(int i=(1<<n)-2;~i;--i)//倒序枚举 
		for(int j=0;j<n;++j)if(!((i>>j)&1)) 
			for(int k=0;k<n;++k)if((i>>k)&1)//枚举上一层状态 
				f[i]=min(f[i],f[i|(1<<j)]+c[j][k]);
	for(int i=0;i<1<<n;++i)
		if(__builtin_popcount(i)<=k)
			ans=min(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：SUNCHAOYI (赞：1)

看到 $1 \le N,K \le 20$ 的数据范围，不难想到状态压缩 $\texttt{dp}$。设 `dp[i]` 表示所有玻璃杯的状态为 $i$ 时的最小花费。

由于是最小花费，初始化时会将所有的 `dp[i]` 默认为 `INF`，然后再特殊处理 `dp[0]` 的值。那么会有一个问题--对于状态 $i$ 的第 $j$ 位，什么时候表示有水呢？根据布尔变量的思想，容易先入为主的将有水时的状态设为 $1$。但是需要思考的是，倘若此时将 `dp[0] = 0`，那么就表示所有的水杯（再加上引入的编号为 $0$ 的水杯）均无水时最小花费为 $0$。这样既与题面中的所有的水杯初始均装有一定的水矛盾，在计算时又无法通过 `dp[0]` 的值去转移。因此，我们便将状态 $i$ 的第 $j$ 位有水时设为 $0$。

状态转移还是比较显然的，倘若 $j$ 杯中有水，那么可以将杯中的水倒入 $k$ 中。这里又有一个小问题，枚举状态的 $i$ 去表示转移前还是转移后呢？我们再将问题的本质聚焦到状态的含义的设置上，由于 $0$ 表示有水，所以当 $i$ 表示转移前时，比较难去处理转移后的状态（原来某一位的 $1$ 将标记为 $0$，而若是 $0$ 则不需要改变），因此本题解选择比较容易的表示转移后的状态的方法。总结一下，也就是说，当满足 `i & (1 << j) == 0` 且 `i & (1 << k) == 0` 时，进行如下转移：`dp[i] = min (dp[i],dp[i ^ (1 << j)] + a[j][k])`。

最后在统计答案时，由于状态设置的特殊性，需要统计每一状态下 $0$ 的个数，若小于等于 $k$，则进行答案的更新。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#define init(x) memset (x,INF,sizeof (x))
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
using namespace std;
const int MAX = 20;
const int MOD = 1e9 + 7;
inline int read ();
int n,k,ans = INF,a[MAX][MAX],dp[1 << 20]; 
int count (int x);
int main ()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	n = read ();k = read ();
	for (int i = 0;i < n;++i)
		for (int j = 0;j < n;++j) a[i][j] = read ();
	init (dp); 
	dp[0] = 0;//初始化
	for (int i = 1;i < (1 << n);++i)
	{
		for (int j = 0;j < n;++j)
		{		
			if (!(i & (1 << j))) continue;
			for (int k = 0;k < n;++k)
				if (!(i & (1 << k)))//符合条件即进行转移
					dp[i] = min (dp[i],dp[i ^ (1 << j)] + a[j][k]);
		}
	}
	for (int i = 1;i < (1 << n);++i)
		if (count (i) <= k) ans = min (ans,dp[i]);
	printf ("%d\n",ans);
	return 0;
}
inline int read ()
{
    int s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}
int count (int x)
{
	int cnt = 0;
	while (x)
	{
		x &= (x - 1);
		++cnt;
	}
	return n - cnt;//总位数减去 0 的个数
}
```

---

后记：由于笔者还是个蒟蒻，倘若有大佬可以写出状态 $i$ 的第 $j$ 位有水时设为 $1$ 时且十分简洁的代码（我尝试了好久，但是一直没调出来 $\texttt{qwq}$），欢迎私信！

---

## 作者：Mars_Dingdang (赞：1)

状压 DP 好题。同步发表于 [博客园](https://www.cnblogs.com/Mars-LG/p/P6883.html)。

## 题目描述
Mislav 有 $N$ 个玻璃杯，从 $1\sim N$ 编号，每个玻璃杯中都有一定的水。你需要通过倒水（将某个杯子中的水倒入另一个杯子），使这些杯子中只有 $K$ 个有水。

已知将第 $i$ 号玻璃杯中的水倒入第 $j$ 号，需要消耗 $C_{i,j}$ 的代价。Mislav 想知道，经过倒水后满足只有 $K$ 个（或更少）玻璃杯中有水时，消耗的代价总和的最小值。

$1\le K\le N\le 20$。

## 大体思路
由于每个水杯只有有水和没水两个状态，并且可以证明，由于一开始所有杯子都有水，操作过程中有水的杯子 $i$ 不会把水倒到没水的杯子 $j$。这是因为如果 $j$ 不倒出，$i\to j$ 不会使得有水的杯子数减少；如果 $j$ 最终倒出，应该在 $j$ 变成空杯子前进行操作。

所以，本题可以使用状压 DP 进行计算。将 $N$ 个杯子有无水的状态用 $N$ 位二进制数 $S$ 表示，$f_S$ 表示状态为 $S$ 时的最小代价。初始 $f_{111...1}=0$，其余 $f=\infty$。

转移时，从大到小枚举 $S$，每次取 $S$ 的二进制为 $1$ 的位置 $p,k$，满足 $p\neq k$，则 $p$ 号杯子为空的状态可能是由 $S$ 转移过去，将 $p$ 倒入 $k$ 中。由此可得状态转移方程为 `f[S-(1<<p)]=min{f[S]+c[p][k]}`。

统计的答案为所有 $1$ 的个数不超过 $K$ 的状态 $S$ 中 $\min\{f_S\}$。时间复杂度 $O(2^NN^2)$，$N=20$ 时约为 $O(419430400)$。然而，事实上时间复杂度小于此。

对于二进制中有 $t$ 个 $1$，枚举 $p,k$ 的复杂度为 $O(t^2)$，而这样的状态有 $\binom N t$ 个。由恒等变换 $t\binom N t=N\binom{N-1}{t-1}$ 可得总的计算次数是为 
$$\sum_{t=0}^N \binom N t (N-t)^2 =\sum_{t=0}^N \binom N t t^2=\sum_{t=0}^N \binom N t [t(t-1)+t]$$
$$=\sum_{t=1}^N \binom N t t+\sum_{t=2}^N \binom N t t(t-1)$$
$$=\sum_{t=1}^N N\binom {N-1}{t-1}+\sum_{t=2}^N N\binom{N-1}{t-1}(t-1)$$
$$=N\times 2^{N-1}+N\sum_{t=2}^N (N-1)\binom{N-2}{t-2}$$
$$=N\times 2^{N-1}+N(N-1)\times 2^{N-2}=N(N+1)2^{N-2}$$

所以时间复杂度为 $O(N(N+1)2^{N-2})$，当 $N=20$ 时约为 $O(10^8)$ 刚好可过。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 5 + (1 << 20);
const ll inf = 0x3f3f3f3f;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll pop_cnt[maxn], c[21][21], f[maxn], N, K;
ll ans;
int main () {
	ans = inf;
	memset(f, inf, sizeof f);
	read(N); read(K);
	f[(1ll << N) - 1] = 0;
	rep(i, 0, N - 1)
		rep(j, 0, N - 1) 
			read(c[i][j]);
	for(ll p = 1; p < (1ll << N); p ++) 
		pop_cnt[p] = pop_cnt[p >> 1] + (p & 1);
	for(ll S = (1ll << N) - 1; S >= 1; S --) {
		rep(p, 0, N - 1) if((S >> p) & 1) {
			rep(k, 0, N - 1) if(((S >> k) & 1) && p != k) 
				f[S - (1ll << p)] = min(f[S - (1ll << p)], f[S] + c[p][k]);
		}
		if(pop_cnt[S] <= K) ans = min(ans, f[S]);
	}
	writeln(ans);
	return 0;
}
```

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6883)

#### 思路

记录每一个杯子是否有水，有水的状态表示 $1$，没有水的状态表示 $0$。

记 $F_i$ 为倒水至状态 $i$ 的最小代价。

初始化 $F$ 无限大，$F_0=0$。

枚举每一个二进制位，得转移方程为：

$$F_i=\min(F_i,F_{i\oplus(2^j)}+A_{j,u})$$

解释一下，当 $j$ 号杯子有水时，我们要将水倒到 $u$ 号杯子（$u$ 号杯子没有水）的花费是 $A_{j,u}$，答案就是所有二进制位中 $1$ 的个数为 $k$ 的 $i$ 中 $f_i$ 的最小值。

#### 贴贴代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
const ll Maxn=21;
ll F[1<<Maxn],n,k,a[Maxn][Maxn],ans=1e10;
int main(){
	memset(F,0x3f,sizeof F);
	scanf("%lld%lld",&n,&k);
	for(ll i=0;i<n;i++)
		for(ll j=0;j<n;j++)
			scanf("%lld",&a[i][j]);
	F[0]=0;
	for(ll i=1;i<1<<n;i++)
		for(ll j=0;j<n;j++)
			if(i&(1<<j))
				for(ll u=0;u<n;u++)
					if(!(i&(1<<u)))
						F[i]=min(F[i],F[i^(1<<j)]+a[j][u]);
	for(ll i=0;i<(1<<n);i++)
		if(n-__builtin_popcount(i)<=k) ans=min(ans,F[i]);
	printf("%lld",ans);
}
```

---

## 作者：Autream (赞：0)

#### 题意简述
有 $N$ 个装有水的杯子，你需要通过从一个杯子向另一个杯子倒水，使这些杯子里面至多有 $K$ 个有水，从杯子 $i$ 往杯子 $j$ 倒水的代价是 $C_{i,j}$。

---
#### 题目分析
数据范围：$1 \leq N \leq 20$，一眼状压。

设 $dp_S$ 表示当前装有水的杯子集合为 $S$，每次枚举从杯子 $k \in [1,n]$ 向杯子 $j \in [1,n]$倒水。因为一开始所有杯子都有水，越到后面水越少，所以考虑倒序转移，即从 $2^n-1$ 向 $1$ 转移。

状态转移方程：
$$
 dp_{S \bigoplus {j}} \gets \min \limits _{k=1}^{n}dp_{S}+C_{j,k}
$$
对于最后统计答案，我们可以用 `__builtin_popcount()` 函数（我这里是手写的），对于二进制中 $1$ 的个数小于等于 $K$ 的更新。

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=25;
int n,K,ans=LLONG_MAX,c[N][N],dp[(1<<N-5)+5];
int calc(int x){
    int cnt=0;
    rep(i,0,20){
        if((x>>i)&1){
            cnt++;
        }
    }
    return cnt;
}
signed main() {
    std::cin>>n>>K;
    rep(i,1,n) {
        rep(j,1,n) {
            std::cin>>c[i][j];
        }
    }
    mem(dp,0x3f);
    dp[(1<<n)-1]=0;
    dep(i,(1<<n)-1,1) {
        rep(j,1,n) {
            if((i>>j-1)&1){
                continue;
            }
            rep(k,1,n) {
                if(!((i>>k-1)&1)) {
                    continue;
                }
                dp[i]=std::min(dp[i],dp[i|(1<<j-1)]+c[j][k]);
            }
        }
    }
    rep(i,1,(1<<n)-1) {
        if(calc(i)<=K) {
            ans=std::min(ans,dp[i]);
        }
    }
    std::cout<<ans;
    return 0;
}
```

---


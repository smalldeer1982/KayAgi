# [CSP-J2020] 方格取数

## 题目描述

设有 $n \times m$ 的方格图，每个方格中都有一个整数。现有一只小熊，想从图的左上角走到右下角，每一步只能向上、向下或向右走一格，并且不能重复经过已经走过的方格，也不能走出边界。小熊会取走所有经过的方格中的整数，求它能取到的整数之和的最大值。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/sq4638pa.png)
---

### 样例 2 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7tfdyabk.png)
---

### 数据规模与约定
- 对于 $20\%$ 的数据，$n, m \le 5$。
- 对于 $40\%$ 的数据，$n, m \le 50$。
- 对于 $70\%$ 的数据，$n, m \le 300$。
- 对于 $100\%$ 的数据，$1 \le n,m \le 10^3$。方格中整数的绝对值不超过 $10^4$。



------------
2024/2/4 添加一组 hack 数据。

## 样例 #1

### 输入

```
3 4
1 -1 3 2
2 -1 4 -1
-2 2 -3 -1
```

### 输出

```
9```

## 样例 #2

### 输入

```
2 5
-1 -1 -3 -2 -7
-2 -1 -4 -1 -2
```

### 输出

```
-10```

# 题解

## 作者：Dry_ice (赞：795)

upd 2022.08.08：修正方向，感谢@[Zlc晨鑫](https://www.luogu.com.cn/user/297555)、@[wzkdh](https://www.luogu.com.cn/user/235121)、@[hyt666](https://www.luogu.com.cn/user/280999) 三位同学的贡献。

## Description
给定一个 $n\cdot m$ 矩阵，找一条从 $(1,1)$ 到 $(n,m)$ 权值和最大的路径，每次只准向上、下、右三个方向走。

## $\text{Solution\ 1}$：暴力$\text{dfs}$
概述：这种算法比较简单，不需要动头脑，直接三方向深搜即可。

时间复杂度：$\mathcal{O}(3^{nm})$

期望得分：$20$ 分

## $\text{Solution\ 2}$：最优性剪枝
概述：考场上我只想到了这种方法（~~太菜了~~。我们设 $F_{i,j,0}$ 表示从一个格子上方走到该格子的路径最大和，$F_{i,j,1}$ 表示从一个格子右方走到该格子的路径最大和，$F_{i,j,2}$ 表示从一个格子下方走到该格子的路径最大和。如果搜到相同的状态则判断是否比原 $F$ 值更大，如果更优则更新答案，否则退出该状态。

时间复杂度：视具体数据而定，当格子权值差值较大时能拿到较多分数。

期望得分：$40$ 分

### 考场 $\text{code}$
```cpp
#include <stdio.h>
const int dx[] = {1, 0, -1}, dy[] = {0, 1, 0};
typedef long long LL;
int n, m; bool vis[1005][1005];
LL w[1005][1005], f[1005][1005][3], ans = -20000000000;
inline LL mx(LL p, LL q) {return p > q ? p : q;}
inline void dfs(int x, int y, int from, LL now) {
	if (x == n && y == m) {
		ans = mx(now, ans);
		return;
	}
	if (f[x][y][from] > now) return;
	else f[x][y][from] = now;
	for (int i = 0, xx, yy; i < 3; ++i) {
		xx = x + dx[i]; yy = y + dy[i];
		if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && !vis[xx][yy]) {
			vis[xx][yy] = true;
			dfs(xx, yy, i, now + w[xx][yy]);
			vis[xx][yy] = false;
		}
	}
}
int main(void) {
//	freopen("number.in", "r", stdin); freopen("number.out", "w", stdout);
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			scanf("%lld", &w[i][j]);
			f[i][j][0] = f[i][j][1] = f[i][j][2] = -20000000000;
		}
	vis[1][1] = true;
	dfs(1, 1, 0, w[1][1]);
	printf("%lld\n", ans);
	return 0;
}
```

## $\text{Solution\ 3}$：记忆化搜索
概述：这才是正解。我们设 $F_{i,j,0}$ 表示从一个格子**下方**走到该格子的路径最大和，$F_{i,j,1}$ 表示从一个格子**上方**走到该格子的路径最大和。如果搜到以前搜过的状态则直接返回搜过的最大和（也就是 $F$ 中的值），否则继续搜索到达该格时的最大和。

时间复杂度：$\mathcal{O}(nm)$

期望得分：$100$ 分

### $\text{ac\ code}$
```cpp
#include <stdio.h>
typedef long long LL;
const LL min_ll = -1e18;
int n, m; LL w[1005][1005], f[1005][1005][2];
inline LL mx(LL p, LL q, LL r) {return p > q ? (p > r ? p : r) : (q > r ? q : r);}
inline LL dfs(int x, int y, int from) {
    if (x < 1 || x > n || y < 1 || y > m) return min_ll;
    if (f[x][y][from] != min_ll) return f[x][y][from];
    if (from == 0) f[x][y][from] = mx(dfs(x + 1, y, 0), dfs(x, y - 1, 0), dfs(x, y - 1, 1)) + w[x][y];
    else f[x][y][from] = mx(dfs(x - 1, y, 1), dfs(x, y - 1, 0), dfs(x, y - 1, 1)) + w[x][y];
    return f[x][y][from];
}
int main(void) {
//	freopen("number.in", "r", stdin); freopen("number.out", "w", stdout);
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			scanf("%lld", &w[i][j]);
			f[i][j][0] = f[i][j][1] = min_ll;
		}
    f[1][1][0] = f[1][1][1] = w[1][1];
	printf("%lld\n", dfs(n, m, 1));
	return 0;
}
```

## The end. Thanks.
记得点赞（qwq

---

## 作者：vectorwyx (赞：36)

在这里提供一个比较清奇的dp思路，如果有和我写法相同的请务必在评论区里留言（


------------
这题最大的难点就在于小熊既能向上走，也能向下走，这个时候传统的dp已经没法胜任了，那么怎么办呢？

大部分巨佬都选择了修改状态，也就是再开一维记录来时的方向。但是蒟蒻并没有他们那么强，因此选择了另一种方式：修改转移方程。

还是传统的状态定义，令 $dp_{i,j}$ 表示走到了第 $i$ 行第 $j$ 列所能获得的最大整数和。但是在转移的时候，我们**按列来转移**，枚举 $dp_{i,j}$ 是从上一列的哪个位置**直直地**跑来的，即：
$$
dp_{i,j}=a_{i,j}+\max_{k=1\ to \ n} dp_{k,j-1}+
\begin{cases}
\sum_{w=i}^{k-1}a_{w,j-1}&(i\le k)\\
\sum_{w=k+1}^{i}a_{w,j-1}&(i>k)\\
\end{cases}
$$

这个式子首先可以用前缀和优化，令$S_{k}=\sum_{w=1}^{k} a_{w,j-1}$，你会发现这样太别扭了，因此咱们**把行列颠倒过来**处理，令 $dp_{i,j}$ 表示走到第 $i$ 列第 $j$ 行所能获得的最大整数和，则有：

$$
dp_{i,j}=a_{j,i}+\max_{k=1\ to \ n} dp_{i-1,k}+
\begin{cases}
S_{k-1}-S_{j-1}&(j\le k)\\
S_{j}-S_{k}&(j>k)\\
\end{cases}
$$

展开得：
$$
dp_{i,j}=a_{j,i}+\max(\max_{k=1\ to\ j}dp_{i-1,k}+S_{k-1}-S_{j-1},\max_{k=j\ to \ n}dp_{i-1,k}-S_{k}+S_{j})
$$

观察发现$a_{j,i},-S_{j-1},S_{j}$在转移时均为定值，因此我们的任务就变成了求这两项：
$$
\max_{k=1\ to\ j}dp_{i-1,k}+S_{k-1},\max_{k=j\ to \ n}dp_{i-1,k}-S_{k}
$$

而这两项的值只跟 $k$ 有关，因此我们又可以把它们预处理出来，令
$$
pre_{j}=\max_{k=1\ to\ j}dp_{i-1,k}+S_{k-1},suf_{j}=\max_{k=j\ to \ n}dp_{i-1,k}-S_{k}
$$
那么显然有：
$$
pre_{j}=\max(pre_{j-1},dp_{i-1,j}+S_{j-1})
$$

$suf_{j}$ 的预处理方法同上，因此对于每一列，我们用 $O(n)$ 的时间预处理出 $pre$ 和 $suf$ 数组，再用 $O(n)$ 的时间求出这一列的 $dp$ 值，总时间复杂度为 $O(nm)$，稳过。

事实上，如果你学过单调队列优化 $dp$，你会发现优化转移的推导过程与单调队列优化 $dp$ 的推导过程极其相似（。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int N=1005;
int a[N][N],n,m,S[N][N];
ll dp[N][N],pre[N],suf[N];

int main(){
	n=read(),m=read();
	fo(i,1,n)
		fo(j,1,m) a[i][j]=read();
	fo(j,1,m)
		fo(i,1,n) S[j][i]=S[j][i-1]+a[i][j];//每一列的前缀和 
	pre[0]=suf[n+1]=-1e17;
	//由于转移的方式是从前一列直接到后一列
	//因此第一列中除了第一行的元素其余的dp值均应赋为-inf，意为无法到达 
	fill(dp[1]+2,dp[1]+1+n,-1e17);
	dp[1][1]=a[1][1];
	fo(i,2,m+1){//按列进行转移 
		//预处理pre和suf数组 
		fo(j,1,n) pre[j]=max(pre[j-1],dp[i-1][j]-S[i-1][j]);
		go(j,n,1) suf[j]=max(suf[j+1],dp[i-1][j]+S[i-1][j-1]); 
		fo(j,1,n) dp[i][j]=max(pre[j]+S[i-1][j],suf[j]-S[i-1][j-1])+a[j][i];
	}
	cout<<dp[m+1][n];
	return 0;
}

```


---

## 作者：CrTsIr400 (赞：34)

# 前言

比赛时我写了一个爆搜，还写挂了。当时还没推DP。

我当时没弄懂这个DP没有后效性，，，

# 主要思路

DAG上的DP。可以转化成这种形式：

![image.png](https://i.loli.net/2020/11/08/28YxHmRdJQq1Iuc.png)

很明显，不存在以下形式，即这个DP没有后效性：

![image.png](https://i.loli.net/2020/11/08/YNPBpIz5WQ6FKin.png)

所以，得出结论：

**每一个最优解，都不会被它左边的最优决策所影响。最优决策在转移的过程中并不会产生冲突。**

# 证明无后效性与最优子结构不互冲突性质

~~废话这么多干嘛（~~

证明这个是能用DP不是别的什么东西做的。

说得简单通俗又形象一点，就是这样：

![image.png](https://i.loli.net/2020/11/08/y2OxDbTQiJNwLzU.png)

我们要从5这里转移图中的红圈，那么如何证明从它左边转移而来是可行的呢？

![image.png](https://i.loli.net/2020/11/08/gcoby9rHXwzNQ1P.png)

这是一种可行转移方案。

但是根据题意可知，不可能这么转移：

![image.png](https://i.loli.net/2020/11/08/qDbpLtUuskhdanw.png)

不满足“不能往回走”的性质。

有着这个性质，我们就可以放心地从前一个状态转移过来了，就不需担心上图的情况了。

接下来处理棘手的上下转移了。

很明显，对于一个点 $(x,y)$ ，要么从它的上面转移过来，要么从它的下面转移过来，不可能存在这种路径：

![image.png](https://i.loli.net/2020/11/08/pqeXbF3HohuiC4d.png)

这样就违反“一个节点只能走一次”的规则了。

于是，这里的DP也没有后效性了。

# DP的状态与转移方程

开始放心设状态：

$f[x][y][dir]$ 代表到了 $(x,y)$ 点，是 $dir$ 方向（$dir=0$ 时为从上至下转移过来的，$1$ 时为从下至上转移过来的）时所构成的最优解。

放心转移：

* $f[x][y][0..1]=\max(f[x][y-1][0..1])+a[x][y]$ 代表从左边转移；

* $f[x][y][0]=\max(f[x-1][y][0]+a[x][y])$ 代表从上至下转移；

* $f[x][y][1]=\max(f[x+1][y][0]+a[x][y])$ 代表从下至上转移；

注意边界条件与初始值。

# 代码

```cpp

#include<bits/stdc++.h>
#define RI register int
typedef long long LL;const int inf=0x3fffffff;char Ch;int Fl;template<typename T>int in(T&x){Fl=1,Ch=getchar(),x=0;while(!(Ch>='0'&&Ch<='9')&&Ch!=EOF)Fl=(Ch=='-')?-1:1,Ch=getchar();if(Ch==EOF)return 0;while(Ch>='0'&&Ch<='9')x=x*10+Ch-'0',Ch=getchar();return x*=Fl,1;}template<typename T,typename...Args>int in(T&x,Args&...args){return in(x)+in(args...);}using namespace std;
int a[1002][1002],n,m;
LL f[1002][1002][2]; 
int main()
{
	in(n,m);
	for(RI i=1;i<=n;++i)for(RI j=1;j<=m;++j)in(a[i][j]);
	for(RI i=0;i<=n+1;++i)for(RI j=0;j<=m+1;++j)f[i][j][0]=f[i][j][1]=-1e18ll;
	f[1][1][0]=f[1][1][1]=a[1][1];
	for(RI i=2;i<=n;++i)f[i][1][0]=f[i-1][1][0]+a[i][1];
	for(RI j=2;j<=m;++j)
	{
		for(RI i=1;i<=n;++i)f[i][j][0]=f[i][j][1]=max(f[i][j-1][0],f[i][j-1][1])+a[i][j];
		for(RI i=2;i<=n;++i)f[i][j][0]=max(f[i][j][0],f[i-1][j][0]+a[i][j]);
		for(RI i=n-1;i>=1;--i)f[i][j][1]=max(f[i][j][1],f[i+1][j][1]+a[i][j]);
	}
	cout<<max(f[n][m][0],f[n][m][1]);
	return 0;
}
//BY SegmentTreeJuruo

```

---

## 作者：WanderingTrader (赞：29)

好不容易有了一次给CSP写题解的机会，当然不能放过了。（滑稽）

比赛的时候先写了个 $O(n^2m)$ 的朴素dp，然后用10min优化到了 $O(nm).$
### 题目分析
我们先把状态定义出来：

令 $f(i,j)$ 为截止到第 $(i,j)$ 格时取到的整数之和最大值。

然而，小熊既可以往上走又可以往下走。如果直接按照状态转移的顺序进行连边，最终所得的图将不是一个DAG，直接求最长路会TLE或者WA.

突破口在于：虽然在上下方向可以随意走，但在左右方向只能向右。最终走到终点的时候，上下方向可能已经走了许多次，但左右方向一定只走了 $m-1$ 次。

于是我们把状态稍作修改：

令 $f(i,j)$ 为截止到第 $(i,j)$ 格，**而且走到此格后立刻向右走一步** 时取到的整数之和最大值。

那么转移路径就会由本来的这样：

![](https://s3.ax1x.com/2020/11/15/DFcsgg.png)

变成这样（为了画面整洁只画出部分）：

![](https://s3.ax1x.com/2020/11/15/DFhOVH.png)

很显然，这是一个DAG，可以直接做。

那么状态转移方程即为：

$f(i,j)=\max\{f(k,j-1)+s(i,k,j)|k\in[1,n]\}$

其中 $s(i,j,k)=\begin{cases}\sum\limits_{x=i}^{j-i+1}a(x,k)&(i<j)\\a(i,k)&(i=j)\\\sum\limits_{x=j}^{i-j+1}a(x,k)&(i>j)\end{cases}$，也就是第 $k$ 列上从 $i$ 到 $j$ 的连续和。

那么如果用前缀和优化，这个方程直接算用 $O(n^2m)$ 就可以了。

```cpp
void NsquareM()
{
	for(int j=2;j<=m;++j)
	{
		for(int i=1;i<=n;++i)
		{
			f[i][j]=-inf;
			for(int k=1;k<=i;++k)
				f[i][j]=max(f[i][j],f[k][j-1]+s[i][j]-s[k-1][j]);
			for(int k=i+1;k<=n;++k)
				f[i][j]=max(f[i][j],f[k][j-1]+s[k][j]-s[i-1][j]);
		}
	}
	printf("%lld\n",f[n][m]);
}
```
注意计算之前别忘了先设定成 $-\inf.$

那么如何优化呢？我们从代码入手：
```cpp
f[k][j-1]+s[i][j]-s[k-1][j]
f[k][j-1]+s[k][j]-s[i-1][j]
```
我们发现代码中一个很重要的特点：$i$ 和 $k$ 从不同时出现。那么我们可以分别把含 $i$ 的式子和含 $k$ 的式子整理出来：

```
f[k][j-1]+s[i][j]-s[k-1][j]
--- s[i][j] + (f[k][j-1]-s[k-1][j])
f[k][j-1]+s[k][j]-s[i-1][j]
--- -s[i-1][j] + (f[k][j-1]+s[k][j])
```
那么当 $j$ 确定时，括号里式子的最大值应该是定值，不随 $i$ 的变化而变化，因此可以预处理。
```cpp
void NM()
{
	rMAX[n+1]=-inf;
	for(int j=2;j<=m;++j)
	{
		LL MAX=-inf;
		for(int i=n;i;--i) rMAX[i]=max(rMAX[i+1],f[i][j-1]+s[i][j]);
		for(int i=1;i<=n;++i)
		{
			f[i][j]=-inf;
			MAX=max(MAX,f[i][j-1]-s[i-1][j]);
			f[i][j]=max(MAX+s[i][j],rMAX[i+1]-s[i-1][j]);
		}
	}
	printf("%lld\n",f[n][m]);
}
```
（话说直接用时间复杂度做函数名的应该就我一个了吧）

这里MAX由于是顺推，所以直接一个变量

而 rMAX由于是逆推需要数组。

两重循环内部就这么变成了 $O(1)$ 。

比赛时担心优化写挂，于是主函数这样写了（freopen已注释）：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=1e3+5;
const LL inf=1e12;
int n,m;
LL a[maxn][maxn],f[maxn][maxn],s[maxn][maxn],rMAX[maxn];
int main()
{
	//freopen("number.in","r",stdin);
	//freopen("number.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j)
	{
		scanf("%lld",&a[i][j]);
		s[i][j]=s[i-1][j]+a[i][j];
	}
	for(int i=1;i<=n;++i) f[i][1]=s[i][1];
	if(n*n*m<=1e7) NsquareM();
	else NM();
	return 0;
}
```
根据数据大小用不同的算法，这也是比赛时的一个小技巧。万一正解写挂了还能拿一点暴力分。

另外注意由于数据最多有 $10^6\times10^4=10^{10}$，需开long long。

此题最大的难点其实是写出转移方程，相较而言优化反而没有那么难了。

$$\texttt{The End.}$$

---

## 作者：Plozia (赞：12)

宣传一波博客：[传送门](https://blog.csdn.net/BWzhuzehao/article/details/109555746)

~~为什么大家都是dp啊，我只会写记忆化搜索。。。~~

题目简洁明了，考场上看完这道题后我想到了这道题： $n * m$ 的网格中，小熊从左上角走到右下角，只能向右或向下走，每个格子有权值 $a_{i,j}$，求出一条路径使路上权值和最大。（大家应该都做过）

转移方程 ~~（我竟然用了dp）~~ ：$f_{i,j}=\max{(f_{i-1,j},f_{i,j-1})+a_{i,j}}$

这道题只是多加了一个向上的方向，但是二维就不能计算了。

怎么办？直接加一维方向！

由于我用的是记忆化搜索，这里写一下思路：

首先， dfs 内设 3 个参数 $x$,$y$,$dis$~~（我为什么会用 dis ???）~~，表示走到 $(x,y)$ （注意是第 $x$ 行 $y$ 列 而不是坐标系中的 $(x,y)$）时怎么走过来的。 $dis=0$ 表示向下走， $dis=1$ 表示向上走， $dis=2$ 表示这个点是这一列第一个被走到的点，想走哪里就走哪里。

由于每一个方格只能经过一次，因此一旦这一列的路径方向定了就不能改变。

搜索时：

令 $ans$ 表答案：

1. $dis=2$ 时，$ans=\max (dfs(x,y-1,2),dfs(x+1,y,0),dfs(x-1,y,1))+a_{x,y}$。
2. $dis=0$ 时，$ans=\max (dfs(x,y-1,2),dfs(x+1,y,0))+a_{x,y}$，注意不能向下走
3. $dis=1$ 时，$ans=\max (dfs(x,y-1,2),dfs(x-1,y,1))+a_{x,y}$。

这种程度的搜索相信各位都想的出来，接下来加上记忆化数组 $f$ 就可以完美 AC 了！

当然，友情提醒一句：

```cpp
int 一时爽，溢出火葬场!
```

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=1000+10;
const long long Min=-1e18,Minn=-1e17;
int n,m,a[MAXN][MAXN];
long long f[MAXN][MAXN][5];

long long Max(long long fir,long long sec)
{
	if(fir>sec) return fir;
	return sec;
}//最好手打max

long long dfs(int x,int y,int dis)
{
	long long ans=Min;//初始化成为-1e18(注意，答案也有可能是负数，样例2中有详细说明)
	if(x==1&&y==1) return a[1][1];//边界条件的处理
	if(x<1||y<1||x>n||y>m) return Min;
	if(f[x][y][dis]>Minn) return f[x][y][dis];
	if(dis==2)
	{
		ans=Max(ans,Max(dfs(x,y-1,2),Max(dfs(x+1,y,0),dfs(x-1,y,1)))+(long long)a[x][y]);
		//万一f[x][y][dis]>Min但是实际上并不是答案我们不就被坑了？所以以-1e17作为参照标准
	}
	else
	{
		ans=Max(ans,dfs(x,y-1,2)+(long long)a[x][y]);
		if(dis==0)
		{
			ans=Max(ans,dfs(x+1,y,0)+(long long)a[x][y]);
		}
		else
		{
			ans=Max(ans,dfs(x-1,y,1)+(long long)a[x][y]);
		}
	}
	return f[x][y][dis]=ans;
}

int main()
{
	freopen("number.in","r",stdin);
	freopen("number.out","w",stdout);
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			f[i][j][0]=f[i][j][1]=f[i][j][2]=Min;//初始化
	cout<<dfs(n,m,2)<<"\n";//采取倒着搜的模式
	return 0;
}
```

总结：

 CSP-J 的 dp 题都能用记忆化搜索写，既然我们会爆搜，加记忆化又很简单，所以我们为什么不写记忆化搜索呢？

如果想写 dp 转移方程的，可以参照其他大佬的题解。（其实上面代码改一下就出来了qwq）


---

## 作者：qhr2023 (赞：8)

## solution

方格取数，经典的动态规划问题，但有所不同。这里可以向上走，也要求不能重复取数。对于这个不同也很好处理，只需要多开一维记录当前格子从哪个方向转移，就可以避免类似刚从上面过来又往上走的问题。

所以，我们设 $f_{i, j, k}$ 表示取数到 $(i, j)$ 时的最大值，$k=0$ 表示从左转过来的，$k=1$ 表示从上转过来的，$k=2$ 表示从下转过来的。

绿色是当前格子，绿色根据 $k$ 是由黄色转移到的，黄色是由红色转移得到，下面是对应的三种情况。

* $k=0$ 时，$f_{i, j, 0} = \max(f_{i, j-1, 0}, f_{i, j-1, 1}, f_{i, j-1, 2})$。

```cpp
for (int i=1; i<=n; i++)
      for (int j=1; j<=m; j++)
			f[i][j][0]=max({f[i][j-1][0], f[i][j-1][1], f[i][j-1][2]})+a[i][j];
```

![](https://cdn.luogu.com.cn/upload/image_hosting/wrb38px6.png)

* $k=1$ 时，$f_{i, j, 1} = \max(f_{i, j-1, 0}, f_{i, j-1, 1})$。

```cpp
for (int i=2; i<=n; i++)
      for (int j=1; j<=m; j++)
			f[i][j][1]=max(f[i-1][j][0], f[i-1][j][1])+a[i][j];
```

![](https://cdn.luogu.com.cn/upload/image_hosting/qhg8zaz0.png)

* $k=2$ 时，$f_{i, j, 2} = \max(f_{i, j-1, 0}, f_{i, j-1, 2})$。

```cpp
for (int i=n-1; i>=1; i--)
      for (int j=1; j<=m; j++)
			f[i][j][2]=max(f[i+1][j][0], f[i+1][j][2])+a[i][j];
```

![](https://cdn.luogu.com.cn/upload/image_hosting/2cieyyxk.png)

因为有负数，所以实现的时候要注意初值设极小值。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, m, a[1005][1005], f[1005][1005][3];
int main () {
	cin >> n >> m;
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++)
			cin >> a[i][j];
	memset(f, -0x3f, sizeof f);
	f[1][1][0]=f[1][1][1]=f[1][1][2]=a[1][1];
	for (int j=1; j<=m; j++) {
		for (int i=1; i<=n; i++)
			f[i][j][0]=max({f[i][j-1][0], f[i][j-1][1], f[i][j-1][2]})+a[i][j];
		for (int i=2; i<=n; i++)
			f[i][j][1]=max(f[i-1][j][0], f[i-1][j][1])+a[i][j];
		for (int i=n-1; i>=1; i--)
			f[i][j][2]=max(f[i+1][j][0], f[i+1][j][2])+a[i][j];
	}
	cout << max({f[n][m][0], f[n][m][1], f[n][m][2]});
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：7)

upd 2024.12.14：重新排版。

一看就是一道 DP 题目，从 $(1,1)$ 走到 $(n,m)$ 的最大价值，可以向右向下向上走。

先来看向右向下，这两个很好处理，状态转移方程如下：

$$dp_{i,j} = \max (dp_{i,j - 1},dp_{i - 1,j}) + a_{i,j}$$

但是对于向上，如果在按之前的顺序转移，那么 $dp_{i + 1,j}$ 的值就无法在得到 $dp_{i,j}$ 之前得到了。改变一下策略先搜索列再搜索行，这样就能完美解决这个问题。然后把二维改成三维，一个从上开始，另一个从下开始。

需要注意的几点有：

1. 初始化的问题，注意有负数存在。最边上的行与列可能需要特判去进行求解。

2. 边界需要着重考虑。

3. 全部加在一起有可能会爆 `int`，因此要开 `long long`。

4. 搜索的顺序与求解的顺序是相关的，一定要注意有无后效性。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define ll long long
using namespace std;
const int MAX = 1005;
int a[MAX][MAX],n,m;
ll dp[MAX][MAX][2];
int main ()
{
	freopen ("number.in","r",stdin);
	freopen ("number.out","w",stdout);
	//dp[i][j][0] means from (1,1) to (n,m);
	//dp[i][j][1] means from (n,m) to (1,1). 
	memset (dp,0x80,sizeof (dp));
	scanf ("%d%d",&n,&m);
	for (int i = 1;i <= n;++i)
		for (int j = 1;j <= m;++j) scanf ("%d",&a[i][j]); 
	dp[1][1][1] = dp[1][1][0] = a[1][1];
	dp[n][m][1] = dp[n][m][0] = a[n][m];
	for (int i = 2;i <= n;++i) dp[i][1][0] = dp[i - 1][1][0] + a[i][1];
	for (int i = n - 1;i >= 1;--i) dp[i][m][1] = dp[i + 1][m][1] + a[i][m];
	for (int i = 2;i <= m;++i)
	{
		for (int j = 1;j <= n;++j)//left 
			dp[j][i][0] = dp[j][i][1] = max (dp[j][i - 1][0],dp[j][i - 1][1]) + a[j][i];
		for (int j = 2;j <= n;++j)//down
			dp[j][i][0] = max (dp[j][i][0],dp[j - 1][i][0] + a[j][i]);
		for (int j = n - 1;j >= 1;--j)//up
			dp[j][i][1] = max (dp[j][i][1],dp[j + 1][i][1] + a[j][i]);
	}
	printf ("%lld\n",max (dp[n][m][0],dp[n][m][1]));
	return 0;
}
```

---

## 作者：言琢დ (赞：4)

观察题意，不难发现是个 dp。

我们一列一列地处理，这样每一列上小熊就不能走“回头路”。

设 $dp_{i,j}$ 表示走到格子 $(i,j)$ 时的最优解。

- $dp_{i,j,0}$ 表示上一步方向向右；
- $dp_{i,j,1}$ 表示上一步方向向下；
- $dp_{i,j,2}$ 表示上一步方向向上；

自然写出方程：

$$
dp_{i,j,0}=a_{i,j}+\max\{dp_{i,j-1,0},dp_{i,j-1,1},dp_{i,j-1,2}\}
$$

注意上一步方向对该步方向的影响，即上一步如果向上，这一步不能向下，反之亦然。

所以有极为类似的两个方程：

$$
dp_{i,j,1}=a_{i,j}+\max\{dp_{i,j-1,0},dp_{i,j-1,1}\}
$$

$$
dp_{i,j,2}=a_{i,j}+\max\{dp_{i,j-1,0},dp_{i,j-1,2}\}
$$

---

下面梳理一下循环结构：

如上文所说，第一重循环应当循环每一列，按行处理会导致“回头路”的出现。

第二重循环，就是按行号从上到下扫一遍，再从下到上扫一遍，每扫一次“无脑”地跑一下上面三个方程就行。

---

代码部分：

```cpp
inline void relax(int i, int j){ //更新 (i,j) 位置的答案
	if(j>1){
		if(dp[i][j-1][0]!=-inf)dp[i][j][0]=mx(dp[i][j][0],dp[i][j-1][0]+a[i][j]);
		if(dp[i][j-1][1]!=-inf)dp[i][j][0]=mx(dp[i][j][0],dp[i][j-1][1]+a[i][j]);
		if(dp[i][j-1][2]!=-inf)dp[i][j][0]=mx(dp[i][j][0],dp[i][j-1][2]+a[i][j]);
	}
	if(i>1){
		if(dp[i-1][j][0]!=-inf)dp[i][j][1]=mx(dp[i][j][1],dp[i-1][j][0]+a[i][j]);
		if(dp[i-1][j][1]!=-inf)dp[i][j][1]=mx(dp[i][j][1],dp[i-1][j][1]+a[i][j]);
	}
	if(i<n){
		if(dp[i+1][j][0]!=-inf)dp[i][j][2]=mx(dp[i][j][2],dp[i+1][j][0]+a[i][j]);
		if(dp[i+1][j][2]!=-inf)dp[i][j][2]=mx(dp[i][j][2],dp[i+1][j][2]+a[i][j]);
	}
}
```

其他的不展示了，边界位置注意判断好就好了。

---

## 作者：Walrus (赞：3)

## P7074

对于这种路径问题我们不难想到一个套路即定义 $dp_{i,j}$ 表示从 $(1,1)$ 走到 $(i,j)$ 的最大值，如果不能向上走，那么转移显然是这样的：
$$dp_{i,j}=\max(dp_{i-1,j},dp_{i,j-1})+a_{i,j}$$

加上向上后，我们显然不能从左上直接向右下转移，怎么办呢？考虑再加一维。

直接改成 $dp_{i,j,0/1/2}$ 表示从 $(1,1)$ 到 $(i,j)$ 上一步走右、下、上到达了 $(i,j)$ 这个点。

考虑怎么转移 $dp_{i,j,2}$，由于是往上走，所以倒序转移是容易想到的，式子也很显然，只要上一步不是从上面走下来的都能转移。

$$dp_{i,j,2}=\max(dp_{i+1,j,0},dp_{i+1,j,2})+a_{i,j}$$

另外两个就正常转移就可以了，注意转移 $dp_{i,j,1}$ 的时候不是从下面走上去的就行。

实现应该比定义从某一列走过来的更好写。

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define dout(i, x) cout << fixed << setprecision(i) << x << '\n'
#define PII pair<int, int>
#define fi first
#define se second
#define pb push_back
#define int long long
#define inf 0x3fffffff

using namespace std;
const int N = 1e3 + 5;
int a[N][N], dp[N][N][4];
int n, m, ans = INT_MIN;

signed main() {
	FASTIO
    memset(dp, 0xcf, sizeof dp);
    cin >> n >> m;
    rep(i, 1, n)
        rep(j, 1, m) cin >> a[i][j];
    dp[0][1][0] = dp[1][0][0] = dp[0][1][1] = dp[1][0][1] = dp[0][1][2] = dp[1][0][2] = 0;
    rep(j, 1, m) {
        rep(i, 1, n) {
            dp[i][j][0] = max(dp[i][j - 1][2], max(dp[i][j - 1][0], dp[i][j - 1][1])) + a[i][j];
            dp[i][j][1] = max(dp[i - 1][j][0], dp[i - 1][j][1]) + a[i][j];
        }
        pre(i, n, 1) 
            dp[i][j][2] = max(dp[i + 1][j][0], dp[i + 1][j][2]) + a[i][j];
    }
    cout << max(dp[n][m][0], dp[n][m][1]);
    return 0;
}
```

---

## 作者：zlqwq (赞：2)

一道好 dp 题。

## 方法一：

我们可以用记忆化搜索来解决。

数组状态 $dp_{i,j,0/1}$ 表示从上方或者下方走到坐标 ${i,j}$ 的点的最大答案。

然后就是判断当前 dfs 到的点有没有被记过答案，如果记过就继续往下搜，如果没搜过就更新一下答案。

代码就不给了，因为没这么写。

## 方法二：

题解这里提供一个滚动数组方法，我们的 dp 数组这开到 $dp_{i,j}$，把后面的一个 bool 变量用两个新数组 $up_{i,j}$ 和 $down_{i,j}$ 作为代替。

转移方程：

$up_{i,j}=\max(up_{i+1,j},dp_{i-1,j})+a_{i,j}$。

$down_{i,j}=\max(down_{i-1,j},dp_{i,j-1})+a_{i,j}$。

$dp_{i,j}=\max(up_{i,j},down_{i,j})$。

其实就是看看是向上走答案大还是向下走答案大然后直接更新就行了。

代码：


```cpp
#include<iostream>
#include<cstring>
#define int long long
#define PII pair<int,int>

using namespace std;
const int N=1005;
int a[N][N],dp[N][N];
int up[N][N],down[N][N];
int n,m;
signed main() {
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j) cin>>a[i][j];
	memset(down,128,sizeof(down));
	memset(up,128,sizeof(up));
	memset(dp,128,sizeof(dp));
	dp[1][1]=a[1][1];
	for(int i=2;i<=n;++i) {
		dp[i][1]=dp[i-1][1]+a[i][1];
	}
	for(int j=2;j<=m;++j) {
		for(int i=1;i<=n;++i){
			down[i][j]=max(down[i-1][j],dp[i][j-1])+a[i][j];
		}
		for(int i=n;i>=1;--i){
			up[i][j]=max(up[i+1][j],dp[i][j-1])+a[i][j];
		}
		for(int i=1;i<=n;++i){
			dp[i][j]=max(up[i][j],down[i][j]);
		}
	}
	cout<<dp[n][m];
	return 0;
}
```

---

## 作者：ty_mxzhn (赞：2)

考虑动态规划。我们发现你只要向下走就无法回头，这启示我们一层层考虑。满足无后效性。

假设我们知道上一层每一层的答案了。首先想要转移到这一层，第一步是下来，第二步是左右走。

由题目可知，小熊无法经过相同的格子。所以一层的决策要么是一直向左要么一直向右。

本题的一个难点在于如何维护向左转移和向右转移之间的冲突。

其实很简单。我们只需要使用两个辅助数组维护一个点从左边过来（向右）和从右边过来（向左）的答案，它的实际答案就是两者最大值。

在我们确定了是要向左还是向右以后，目标变得明确，转移的思路就浮现了。

---

## 作者：_Imaginary_ (赞：2)

## 花絮
我在比赛时其实是30分钟就切掉这道题了。不过其中我用了考场的Excel表格画了好久样例才过……
## Solution

首先，让我们看一眼数据范围：$n,m\le 10^3$.

所以我们可以想到复杂度 $O(nm)$ 。

还是那句老话：遇到不会的题就用DP。

另外，就需要读题仔细了：**只能向上，向下，向右**。

所以，我们令 `dp[i][j][dir]` 为在 `i` **列** `j` **行**，前一个方格走到这里的方向是dir的。

让我们画一张图。紫色的是当前的格子，黄色的是上一个格子，红色的是能走到上一个格子的状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/x7h58sfa.png)


所以，我们可以推导出这个dp式子。

## 代码实现

首先，有这些部分的`dp`值要变成`inf`：

`dp[所有格子][第一行][up]，dp[所有格子][最后一行][down]，dp[第一行][除了左上角外的所有第一列格子]`。

其次，**不开 long  long 见祖宗**。

个人感觉细节不是很多。

给大家亮一亮我比赛时的丑陋代码
```c++
//CSP 2020 RP++
#include<bits/stdc++.h>
using namespace std;
const long long inf=-4485090715960753727;
long long n,m,a[1005][1005],dp[1005][1005][3];
long long mx3(long long a,long long b,long long c)
{
	return max(max(a,b),c);
}
int main()
{
	freopen("number.in","r",stdin);
	freopen("number.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%lld",&a[j][i]);
	memset(dp,-0x3f,sizeof(dp));
	dp[1][1][2]=dp[1][1][0]=a[1][1];
	for(int i=2;i<=n;i++) dp[1][i][0]=dp[1][i-1][0]+a[1][i];
	dp[1][1][0]=inf;
	for(int i=2;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			dp[i][j][2]=mx3(dp[i-1][j][0],dp[i-1][j][1],dp[i-1][j][2])+a[i][j];
		}
		for(int j=2;j<=n;j++)
		{
			dp[i][j][0]=max(dp[i][j-1][0],dp[i][j-1][2])+a[i][j];
		}
		for(int j=n-1;j>=1;j--)
		{
			dp[i][j][1]=max(dp[i][j+1][1],dp[i][j+1][2])+a[i][j];
		}
	}
	/*debug
	for(int j=1;j<=n;j++)
	{
		for(int i=1;i<=m;i++)
			printf("%11d",dp[i][j][0]);	
		printf("\n");
	}
	printf("\n");
	for(int j=1;j<=n;j++)
	{
		for(int i=1;i<=m;i++)
			printf("%11d",dp[i][j][1]);	
		printf("\n");
	}
	printf("\n");
	for(int j=1;j<=n;j++)
	{
		for(int i=1;i<=m;i++)
			printf("%11d",dp[i][j][2]);	
		printf("\n");
	}
	printf("\n");*/	
	printf("%lld",max(dp[m][n][0],dp[m][n][2]));
	return 0;
}

```



---

## 作者：CaiZi (赞：1)

看到这种东西，很容易的可以想到 DP，设 $f_{i,j}$ 表示到 $(i,j)$ 的得分最大值，发现有后效性，无法转移。注意到题目中有这么一句话：**“不能重复经过已经走过的方格”**。所以在每一列上，只能一直向上或向下行走。

基于这个，我们可以设 $f_{i,j,0}$ 表示到 $(i,j)$ 且方向是**从上往下**的得分最大值，$f_{i,j,1}$ 表示到 $(i,j)$ 且方向是**从下往上**的得分最大值。那么我们在每一列可以把 $f_{i,j,0}$ 和 $f_{i,j,1}$ 分开来进行转移。$f_{i,j,0}$ 可以由 $f_{i-1,j,0}$ 转移而来，$f_{i,j,1}$ 可以由 $f_{i+1,j,1}$ 转移而来。除此之外，$f_{i,j,0}$ 和 $f_{i,j,1}$ **都可以**由 $f_{i,j-1,0}$ 和 $f_{i,j-1,1}$ 转移而来。

注意 $10^3\times10^3\times10^4=10^{10}>2^{31}-1$，所以要开 `long long`。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[1501][1501],f[1501][1501][2];
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	for(int i=0;i<=n+1;i++){
		for(int j=0;j<=m+1;j++){
			f[i][j][0]=f[i][j][1]=-11451419198;
		}
	}
	f[1][1][0]=f[1][1][1]=a[1][1];
	for(int j=1;j<=m;j++){
		for(int i=1;i<=n;i++){
			if(i!=1||j!=1){
				f[i][j][0]=max({f[i][j-1][0],f[i][j-1][1],f[i-1][j][0]})+a[i][j];
			}
		}
		if(j!=1){
			for(int i=n;i>=1;i--){
				f[i][j][1]=max({f[i][j-1][0],f[i][j-1][1],f[i+1][j][1]})+a[i][j];
			}
		}
	}
	cout<<max(f[n][m][0],f[n][m][1]);
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

考虑动态规划算法，定义 $dp_{i, j}$ 表示恰好走到第 $i$ 列的第 $j$ 个位置（即之前没有在第 $i$ 列走过，是由 $i - 1$ 列直接走过来的）的最大方案数。

然后转移，枚举是由 $i - 1$ 列的第 $k$ 个走过来的：

$$dp_{i, j} = \max\Big( \max_{k = 1}^j dp_{i -1, k} + s_{i - 1, j} - s_{i - 1, k - 1}, \max_{k = j}^n dp_{i - 1, k} + s_{i - 1, k} - s_{i - 1, j - 1} \Big)$$

其中 $s_{i, j}$ 表示第 $i$ 列前 $j$ 个数的和。

朴素转移是 $O(N^3)$ 的（但是好像可以直接过）。

考虑优化，注意到我们要查询一个前缀 $dp_{i - 1, k} - s_{i - 1, k - 1}$ 与一个后缀 $dp_{i - 1, k} + s_{i - 1, k}$ 的最大值。

直接开一个 $f_{i ,j}, g_{i, j}$ 维护即可。

时间复杂度优化至 $O(N^2)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 1010; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
ll ans = -1e18;
int n, m;
int a[N][N];
ll s[N][N], dp[N][N], f[N][N], g[N][N];
bool End;
int main(){
	memset(dp, -0x7f, sizeof(dp));
	memset(f, -0x7f, sizeof(f));
	memset(g, -0x7f, sizeof(g));
	n = read(), m = read();
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= m; ++j){
			a[i][j] = read();
			s[j][i] = s[j][i - 1] + a[i][j];
		}
	}
	dp[1][1] = 0, g[1][1] = a[1][1];
	for(int i = 1; i <= n; ++i)
	  f[1][i] = 0;
	for(int i = 2; i <= m; ++i){
		for(int j = 1; j <= n; ++j)
		  dp[i][j] = max(f[i - 1][j] + s[i - 1][j], g[i - 1][j + 1] - s[i - 1][j - 1]);
		for(int j = 1; j <= n; ++j)
		  f[i][j] = max(f[i][j - 1], dp[i][j] - s[i][j - 1]);
		for(int j = n; j >= 1; --j)
		  g[i][j] = max(g[i][j + 1], dp[i][j] + s[i][j]);
	}
	for(int i = 1; i <= n; ++i)
	  ans = max(ans, dp[m][i] + s[m][n] - s[m][i - 1]);
	write(ans);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：Eason0324 (赞：0)

## 思路
看到这道题，第一反应是 **dfs**，但是暴力只能拿 $20$ 分。$\\$
观察之后你会发现他有最优子结构，所以我用了 **动态规划**。
我们定义 $dp_{i,j,k}$ 为从第 $k$ 个方向 走到 $a_{i,j}$ 的最大利益。

则我们可以列出转移方程：
$$ dp_{i,j,k}\gets \max{dp_{i-1,j,0},dp_{i-1,j,1}}+a_{i,j}$$
$$ dp_{i,j,0}\gets \max dp_{i,j,0},dp_{i,j-1,0}+a_{i,j} $$
$$ dp_{i,j,1}\gets \max dp_{i,j,1},dp_{i,j+1,1}+a_{i,j} $$

## 代码

```cpp
#include<bits/stdc++.h>
#define in long long
using namespace std;
int f[1009][1009][2],a[1009][1009],n,m;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        cin>>a[j][i];
  	swap(n,m);
	for(int i=0;i<=n+1;i++)
      for(int j=0;j<=m+1;j++)
      	f[i][j][0]=f[i][j][1]=-1000000009;
    f[1][1][0]=f[1][1][1]=a[1][1];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i!=1){
				f[i][j][0]=max(f[i][j][0],max(f[i-1][j][0],f[i-1][j][1])+a[i][j]);
				f[i][j][1]=max(f[i][j][1],max(f[i-1][j][0],f[i-1][j][1])+a[i][j]);
			}
			if(j!=1){
				f[i][j][0]=max(f[i][j][0],f[i][j-1][0]+a[i][j]);
			}
		}
		for(int j=m;j>=1;j--){
			if(j!=m)
			f[i][j][1]=max(f[i][j][1],f[i][j+1][1]+a[i][j]);
		}
	}
	cout<<max(f[n][m][0],f[n][m][1]);
	return 0;
}
```

---

## 作者：GXZJQ (赞：0)

# P7074 [CSP-J2020] 方格取数 题解

[题目链接](https://www.luogu.com.cn/problem/P7074)

## 思路分析

考虑线性 DP，可尝试使用类数字三角形模型解决。

令 $f[i][j][k]$ 表示走到 $(i,j)$ 且上一步是从 $k$ 方向转移过来时所可以取得的最大值，此时 $k$ 有 $3$ 中情况：

- $k = 0$：从左边转移过来；
- $k = 1$：从上边转移过来；
- $k = 2$：从下边转移过来（**倒序枚举**）。

但这里要注意到对边界问题的考虑，即某些特殊位置可能只有两种方向。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long INF = -1e17;
const int maxn = 1e3 + 10;
int n, m;
long long a[maxn][maxn];
long long f[maxn][maxn][3];
int main() {
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j], f[i][j][0] = f[i][j][1] = f[i][j][2] = INF;
	f[1][1][0] = f[1][1][1] = f[1][1][2] = a[1][1];
	for (int i = 2; i <= n; i++) {
		f[i][1][1] = f[i - 1][1][1] + a[i][1];
	}
	for (int j = 2; j <= m; j++) {
		for (int i = 1; i <= n; i++) {
			f[i][j][0] = max(f[i][j - 1][1], max(f[i][j - 1][0], f[i][j - 1][2])) + a[i][j]; //从左边转移过来
			if (i > 1) f[i][j][1] = max(f[i - 1][j][0], f[i - 1][j][1]) + a[i][j]; //从上边转移过来
		}
		for (int i = n - 1; i >= 1; i--) {
			f[i][j][2] = max(f[i + 1][j][0], f[i + 1][j][2]) + a[i][j]; //从下边转移过来
		}
	}
	cout << max(f[n][m][0], f[n][m][1]);
	return 0;
}
```

---

## 作者：gavinliu266 (赞：0)

# 思路
这题每一列既可以向上，也可以向下，所以不能直接做。

但是注意到每一列只能向上或向下，这启发我们把向上和向下拆开，这样单独转移，就没有后效性了。

转移很好想，向下的可以从左边或者上面转移，向上的可以从左边或者下面转移。

时间复杂度 $O(nm)$。

# 代码实现
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1005;
int n, m;
int a[N][N];
ll up[N][N], dn[N][N];
ll gt(int x, int y) { return max(up[x][y], dn[x][y]); }
int main() {
    memset(up, 0x80, sizeof(up));
    memset(dn, 0x80, sizeof(dn));
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i) 
        for(int j = 1; j <= m; ++j)
            scanf("%d", &a[i][j]);
    dn[1][1] = a[1][1];
    for(int i = 2; i <= n; ++i)
        dn[i][1] = dn[i - 1][1] + 1ll * a[i][1];
    up[1][1] = a[1][1];
    for(int i = 2; i <= m; ++i) {
        for(int j = 1; j <= n; ++j) {
            dn[j][i] = up[j][i] = gt(j, i - 1) + 1ll * a[j][i];
            if(j > 1) dn[j][i] = max(dn[j][i], dn[j - 1][i] + 1ll * a[j][i]);
        }  // 向下的转移
        for(int j = n - 1; j >= 1; --j)
            up[j][i] = max(up[j][i], up[j + 1][i] + 1ll * a[j][i]);
        // 向上的转移
    }
    printf("%lld\n", gt(n, m));
}
```

---


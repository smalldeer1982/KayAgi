# [COCI 2018/2019 #6] Sličice

## 题目描述

Nikola 喜欢收集足球队员的照片，并将其保存在相册中。他计划收集 $N$ 支球队的队员照片，其中每支球队都有 $M$ 张。

对于 Nikola 所收集的每支球队，该球队的照片数量 $x$ 能给他增加分数 $B_x$。他目前拥有球队 $i$ 的照片数量为 $P_i$。

Nikola 的好朋友 Ivan 有两套完整的相册。Ivan 决定送 $K$ 张照片给 Nikola。Nikola 想要知道，在得到这 $K$ 张照片之后，它的相册所能得到的分数的最大值。

## 说明/提示

#### 样例 1 解释

Nikola 一开始拥有球队 $1,2,3,4$ 照片数量分别为 $4,2,3,1$。最优的方案是获得球队 $2,3$ 照片各 $1$ 张。此时分数最大，为 $10+10+10+1=31$。

#### 数据规模与约定

对于 $20\%$ 的数据，$K=2$。

对于 $100\%$ 的数据，$1 \le N,M \le 500$，$1 \le K \le \min(N \times M,500)$，$0 \le P_i \le M$，$0 \le B_i \le 10^5$。

#### 说明

**本题分值按 COCI 原题设置，满分 $90$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #6](https://hsin.hr/coci/archive/2018_2019/contest6_tasks.pdf)  _T3 Sličice_。**

## 样例 #1

### 输入

```
4 4 3
4 2 3 1
0 1 3 6 10```

### 输出

```
31```

## 样例 #2

### 输入

```
4 3 5
1 1 2 3
0 1 2 3```

### 输出

```
12```

## 样例 #3

### 输入

```
3 6 2
2 4 1
31 38 48 60 75 91 120```

### 输出

```
206```

# 题解

## 作者：_ouhsnaijgnat_ (赞：6)

一道动规题，我第一次一遍过绿题。

## 思路

我们定义一个数组 $\mathit{dp}_{i,j}$，表示在第 $i$ 支球队已经用了 $j$ 张照片，它分数的一个最大值。

那么 $i$ 就从 $1\backsim n$，$j$ 要从 $0\backsim K$，因为前 $i$ 支球队可以都不用送的照片，所以有 $0$。

那么状态转移方程是什么呢？$\mathit{dp}_{i,j}=\operatorname{max}(\mathit{dp}_{i,j},\mathit{dp}_{i-1,p_{i}+j-k})$

那么为什么呢？$k$ 表示第 $i-1$ 支球队可能已经用了多少张照片，而 $j$ 表示前 $i$ 支球队会用多少张照片。

由于我们已经加过这个 $k$ 了，而这个 $k$ 包含在 $j$ 里，所以要减去 $k$。

说了这么多，上代码！

## 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int n,m,k,p[505],b[505],dp[505][505];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		cin>>p[i];
	for(int i=0;i<=m;i++)
		cin>>b[i];
	for(int i=1;i<=n;i++){
		for(int j=0;j<=k;j++){
			for(int kk=0;kk<=j;kk++){
				dp[i][j]=max(dp[i-1][kk]+b[p[i]+j-kk],dp[i][j]);
			}
		}
	}
	cout<<dp[n][k];//毋庸置疑，dp[n][k]肯定是最优方案 
	return 0;
}
```


---

## 作者：Marshall001 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7381)

## 题目大意

Nikola 有 $n$ 个球队的照片，每支球队最多可以有 $m$ 张照片。Nikola 现在每支球队有 $P_i$ 找那个照片，一个球队如果有 $i$ 张照片，那么他就可以获得 $B_i$ 分。现在 Nikola 要新增 $k$ 张照片，他最多可以的多少分。

## 思路

因该可以看出来，这是一道动态规划的题。

$dp_{i,j}$ 表示前 $i$ 支球队，一共增加了 $j$ 张照片，Nikola 最多可以得多少分。

动态转移方程：

$dp_{i,j}=\max( dp_{i,j},dp_{i-1,j-l}+B_{P_i+l})$。

其中 $l=$ 第 $i$ 支球队增加 $l$ 张照片。

## 代码

思路都有了，上代码！
```cpp
#include <iostream>
using namespace std;
const int MAXN=500+5; 
long long p[MAXN],b[MAXN],n,m,k,sum,dp[MAXN][MAXN];//dp[i][j]代表前i个球队，一共送出j张照片，得分最高是多少 
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		cin>>p[i];
	}
	for(int i=0;i<=m;i++){
		cin>>b[i];
	}
	for(int i=1;i<=n;i++){//前i个球队 
		for(int j=0;j<=k;j++){//一共用去j张照片 
			for(int l=0;l<=j;l++){//第i个球队用l张照片 
				if(p[i]+l>m){//如果超出范围 
					break;//跳出 
				}
				dp[i][j]=max(dp[i][j],dp[i-1][j-l]+b[p[i]+l]);//取最大值 
			}
		}
	}
	cout<<dp[n][k];//输出 
	return 0;
}
```
## THE END

---

## 作者：happybob (赞：3)

传送门：[P7381 [COCI2018-2019#6] Sličice](https://www.luogu.com.cn/problem/P7381)

其实是一道类似多重背包的题目，定义 ${dp_i}_ j$ 表示代表前 $i$ 个球队共收集 $j$ 张时最大分数。可以求出状态转移方程 ${dp_i}_ j = \max \{ {{dp_i}_ j, {dp_{i - 1}}_ {j - g} + b_{{p_i}+g}} \}$。

代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

#define int long long
const int N = 505;
int p[N], B[N], dp[N][N]; // dp[i][j] 代表前 i 个球队共收集 j 张时最大分数

signed main()
{
	int n, m, k;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) cin >> p[i];
	for (int i = 0; i <= m; i++) cin >> B[i];
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j <= k; j++)
		{
			for (int g = 0; p[i] + g <= m && g <= k && g <= j; g++) // 当前已选加上多选的小于等于 m 
			{
				dp[i][j] = max(dp[i][j], dp[i - 1][j - g] + B[p[i] + g]);
			}
		}
	}
	int ans = 0;
	for (int i = 0; i <= k; i++)
	{
		ans = max(ans, dp[n][i]);
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：huangrenheluogu (赞：2)

首先我们看题目，题目需要合理地选 $[0,k]$ 张照片让自己地得分最大，我们可以考虑用动态规划来解决这个问题，我们首先需要看一下这道题目是否符合动态规划的标准。

- 没有后效性  √

- 后面与前面有一定的关系（**而且很好推出来**）√

好了，那我们可以考虑 $ f_{i,j} $ 表示选到第 $i$ 支球队用了 $j$ 张优惠券得到的最大值（像背包一样）。

接下来我们来推 `dp` 方程，很明显是从前一个状态进来。

首先是循环：

我们可以枚举一个 $i$ 和一个 $j$ , 表示选到第 $i$ 支球队用了 $j$ 张优惠券得到的最大值，接下来我们要枚举一个 $l$,来枚举我们这一个球队需要用多少 $l$ 张优惠券。注意枚举 $l$ 的时候需要有两个界限，一个是需要让这支球队没有满人，即 $l \leq m-p_i $。而且照片需要小于 $j$  张，所以需要 $l<=j$，所以我们枚举出原来的循环。需要注意的是我们这里是从 $0$ 开始枚举 $l$，而不是从 $1$ 开始（因为这支球队可以选 $0$ 张照片）
循环代码如下：

```cpp
for(int i=1;i<=n;i++){
	for(int j=0;j<=k;j++){
		for(int l=0;l<=m-p[i]&&l<=j;l++){
			f[i][j]=max(f[i][j],？？？);
		}
		ans=max(ans,f[i][j]);
	}
}
```
好了，我们接下来来推 `dp` 方程式：

首先，我们要从 $i-1$ 个状态转移过来，然后我们前面就只能选 $j-l$ 张照片而这支球队就有 $p_i + l$ 张照片了，所以相较于 $f_{i-1,j-l}$ ,我们需要加上 $b_{p_i+1}$，所以我们可以推出 `dp` 方程 $ f_{i,j}=\max(f_{i,j},f_{i-1,j-l}+b_{p_i+1})$。

所以最后为大家贴上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,p[505],b[505],f[505][505],ans; 
inline void read(int &res){
	char ch=getchar();int f=1;res=0;
	while('0'>ch||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^48);
		ch=getchar();
	}
	res*=f;
}
int main(){
	read(n),read(m);read(k);
	for(int i=1;i<=n;i++) read(p[i]);
	for(int i=0;i<=m;i++) read(b[i]);
	for(int i=1;i<=n;i++){
		for(int j=0;j<=k;j++){
			for(int l=0;l<=m-p[i]&&l<=j;l++){
				f[i][j]=max(f[i][j],f[i-1][j-l]+b[p[i]+l]);
			}
			ans=max(ans,f[i][j]);
		}
	}
	printf("%d",ans);
	return 0;
}
```
大家可以加上读优，可以更快。

---

## 作者：千秋星辰 (赞：2)

**首先，这是一道动态规划题。**

~~然而题目中的 $M$ 在 dp 中没什么用~~

### 思路

1. 观察题目，题目的意思是将 $k$ 个物品分配到不同的背包中，使得得分最大。通过**不同种的物品有多个**可以看出，这是一个分组背包问题。
2. 设 $dp_{i,j}$ 表示**收到前 $i$ 支球队的共 $j$ 张照片所得分**。显然得出初始状态 $dp_{i,j}=dp_{i-1,j}+b_{p_i}$，这是第 $i$ 支球队不分配照片的情况；很容易发现最终的答案就是 $dp_{n,k}$，也就是收到前 $n$ 支球队的共 $k$ 张照片所得分。
3. 如果收到第 $i$ 支球队的照片，需要枚举收到照片的数目进行 dp。可得：$dp_{i,j}=\max\limits_{k=0}^{k<j}dp_{i-1,k}+b_{p_i+j-k}$。

### code

```cpp
#include<bits/stdc++.h>
#include<algorithm>
#define uint unsigned int
#define forever() while(true)

namespace IO
{
	#define gc getchar
	#define pc putchar
	template<typename T,typename ...E>
	void read(T &num)
	{
		T x=0,y=1;char c=gc();
		for(;!isdigit(c);c=gc()) c=='-'?y=-y:0;
		for(;isdigit(c);c=gc()) x=x*10+c-'0';
		num=x*y;
	}
	template<typename T,typename ...E>
	void read(T &x,E &...etc)
	{
		read(x);
		read(etc...); 
	}
	template<typename T,typename ...E>
	void write(T x)
	{
		if(x<0) x=-x,pc('-');
		if(x>9) write(x/10);
		pc(x%10+'0');
	}
	void out(){}
	void writen(){pc('\n');}
	template<typename T,typename ...E>
	void out(T x,E ...etc)
	{
		write(x);
		pc(' ');
		out(etc...);
	}
	template<typename T,typename ...E>
	void writen(T x,E ...etc)
	{
		write(x);
		pc(' ');
		writen(etc...);
	}
	#undef gc
	#undef pc
}

using namespace std;
using namespace IO;
int n,m,K,p[505],b[505],dp[505][505];

signed main()
{
	#ifdef file
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
	#endif
	read(n,m,K);
	for(int i=1;i<=n;++i) read(p[i]);
	for(int i=0;i<=m;++i) read(b[i]);
	for(int i=1;i<=n;++i)
		for(int j=0;j<=K;++j)
		{
			dp[i][j]=dp[i-1][j]+b[p[i]];
			for(int k=0;k<j;++k)
				dp[i][j]=max(dp[i][j],dp[i-1][k]+b[p[i]+j-k]);
		}
	write(dp[n][K]);
	#ifdef file
	fclose(stdin);
	fclose(stdout);
	#endif
	return (0^0);
}
```

---

## 作者：Back_Stuff (赞：2)

## 题目大意

他有 $n$ 个球队的照片，每个球队有 $p_{i}$ 张照片，他有多余的 $k$ 张胶卷，可以加给不同的球队。

如果这支球队有 $i$ 张照片，就可以加分值为 $b_{i}$ 的分数。

让你求出最后可以得到的最大分值。

## 思路

一看就是动态规划，我们定义一个二维数组，表示的是前 $i$ 支球队拍了 $j$ 张后的一个最大分值。

毋庸置疑，$i$ 从 $1\backsim n$，$j$ 从 $0\backsim K$，之所以 $j$ 从 $0$ 开始，是因为前 $i$ 支球队可能拥有的照片太少了，所以不给他们额外的胶卷。

动态规划都有状态转移方程，这道题的状态转移方程就是这样：$\mathit{dp}_{i,j}=\operatorname{max}(\mathit{dp}_{i,j},\mathit{dp}_{i-1,p_{i}+j-k})$。

不断去取最大值，枚举第 $i$ 支球队放多少张照片是最优解的。

这道题就做完了。

## 代码

核心部分：

```cpp

    for(int i=1;i<=n;i++){
        for(int j=0;j<=k;j++){
            for(int kk=0;kk<=j;kk++){
                dp[i][j]=max(dp[i-1][kk]+b[p[i]+j-kk],dp[i][j]);
            }
        }
    }
```


---

## 作者：so_find_skind (赞：1)

~~[水题](https://www.luogu.com.cn/problem/P7381)~~。

动态规划经典。

我们设定 $\mathit{dp}_{i,j}$ 表示收到前 $i$ 支球队共 $j$ 张照片最大得分。

那么 $i$ 的范围为 $1 \sim n$，$j$ 则为 $0\sim k$，因为前 $i$ 支球队可以出现一张照片都不用送的情况，所以有 0。

状态转移方程也不难得出，我们用 $x$ 来表示 $beibao i,j$ 本身，用 $y$ 来表示 $beibao_{i-1,p_i+j-k}$：

$f(a) = \begin{cases}
x>y ,& x\\
x<y ,& y\\
\end{cases}$

之所以，是因为 $k$ 表示第 $i-1$ 支球队**可能**已经用了多少照片，$j$ 则是表示前 $i$ 支球队**会**用多少张照片。

只是因为在之前加上过这个 $k$ 了，而这个 $k$ 又会被 $j$ 遍历，所以要减去 $k$。

那么代码也就不难写出。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,p[505],b[505],dp[505][505];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		cin>>p[i];
	for(int i=0;i<=m;i++)
		cin>>b[i];
	for(int i=1;i<=n;i++)
		for(int j=0;j<=k;j++)
			for(int k=0;k<=j;k++)
				dp[i][j]=max(dp[i-1][k]+b[p[i]+j-k],dp[i][j]);
	cout<<dp[n][k];
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：0)

动态规划题目。

## 题目大意
Nikola 喜欢收集足球队员的照片，并将其保存在相册中。他计划收集 $N$ 支球队的队员照片，其中每支球队都有 $M$ 张。

对于 Nikola 所收集的每支球队，该球队的照片数量 $x$ 能给他增加分数 $B_x$。他目前拥有球队 $i$ 的照片数量为 $P_i$。Nikola 的好朋友 Ivan 有两套完整的相册。Ivan 决定送 $K$ 张照片给 Nikola。Nikola 想要知道，在得到这 $K$ 张照片之后，它的相册所能得到的分数的最大值。

## 大体思路
由数据范围可得，每支球队照片增加量没有限制，而总的照片增加量为 $K$。所以，可以定义状态 $f[i, k]$ 表示前 $i$ 支球队增加 $k$ 张的最大分数。

然后，对第 $i$ 支球队进行讨论。如果这支球队的照片数不增加，则前 $i-1$ 支球队的照片需要增加 $k$ 张，即 $f[i, k]=f[i-1,k]+B_{P_i}$。若这支球队的照片数增加 $d$ 张，则 $f[i, k]=f[i-1, k-d]+B_{P_i+d}$，条件为 $d\le k$ 且 $P_i+d\le M$。

这样，可以在复杂度 $O(NK)$ 计算出答案，输出 $f[N, K]$ 即可。
## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 505, inf = 0x3f3f3f3f;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int f[maxn][maxn], n, m, k, b[maxn], p[maxn];
int main () {
	read(n); read(m); read(k);
	rep(i, 1, n) read(p[i]);
	rep(i, 0, m) read(b[i]);
	rep(i, 1, n) {
		rep(j, 0, k) {
			f[i][j] = max(f[i][j], f[i - 1][j] + b[p[i]]);
			for(int d = 1; p[i] + d <= m && d <= j; d ++)
				f[i][j] = max(f[i][j], f[i - 1][j - d] + b[p[i] + d]);
		}
	}
	writeln(f[n][k]);
	return 0;
}
```

---

## 作者：chu_K (赞：0)

## Sol
这题一眼就是 $dp$ 啊。
我们定义 $f[i,j]$ 表示在前 $i$ 支球队中获取 $j$ 个张照片所获得的最大分数，状态转移方程也很容易推：

$f[i][j]=max(f[i][j],f[i-1][j-kk]+b[p[i]+kk])$

当然，因为有边界所以可以进行转换的条件是 $j>=kk$ 且 $p[i]+kk<=m$

## Code
```c++
#include <cstdio>
#include <iostream>
#include <algorithm>
#define int long long 
using namespace std;//不开longlong应该也没事
const int N = 1001;
int n,m,k,i,j,kk,p[N],b[N],f[N][N],ans;
signed main()
{
        cin >> n >> m >> k;
        for (i=1; i<=n; i++) cin >> p[i];
        for (i=0; i<=m; i++) cin >> b[i];
        for (i=1; i<=n; i++)
                for (j=0; j<=k; j++)
                        for (kk=0; kk<=k; kk++)
                                if (p[i]+kk<=m&&j>=kk) f[i][j]=max(f[i][j],f[i-1][j-kk]+b[p[i]+kk]);//转移
        for (i=0; i<=k; i++) ans=max(ans,f[n][i]);
        cout << ans;
}

```

---


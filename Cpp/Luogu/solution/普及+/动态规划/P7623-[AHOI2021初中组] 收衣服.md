# [AHOI2021初中组] 收衣服

## 题目背景

AHOI2021 初中组 T3

**你可以选择跳过背景部分。**

沉迷于虐待跳蚤游戏的小雪没有发觉时间过了多久，一抬头发现竟然天色大变！天空一片昏黄，一股怪味扑鼻而来。没想到在如此发达的 2077 年，城市中还能碰到沙尘暴，这超现实的场景让小雪怀疑是跳蚤国王显灵。

“别愣着了，快去收衣服呀！”小可可突然想到。

## 题目描述

看着这么多蒙灰的衣服，他们俩欲哭无泪；而且，有的衣服是没法一起洗的，为了分门别类，小可可给了每件衣服一个 $1 \sim n$ 的两两不同的标号，其中 $n$ 是衣服的件数，把衣服排成 $1,2,\ldots,n$ 的顺序再洗会比较方便。

小可可还想到，我们可以把一段连续的晾衣架拿出来，在手上翻转顺序，再放回去。作为 OI 选手的你，马上抽象出了小可可排序衣服的算法：我们设初始时从左往右第 $i$ 件衣服的标号为 $p_i$，按 $1,2,\ldots,n-1$ 的顺序枚举 $i$，设 $p_i,p_{i+1},\ldots,p_n$ 中标号最小的是 $p_j$，那么将 $p_i,p_{i+1},\ldots,p_{j-1},p_j$ 左右翻转变成 $p_j,p_{j-1},\ldots,p_{i+1},p_i$。

小雪很快发现，小可可的算法看似厉害，实际上很傻——在天色的影响下，大家都分不出衣服的标号了。于是他们只能回到房间进行理性愉悦：我们假设左右翻转区间 $[i,j]$ 的操作代价是 $w_{i,j}$，一次排序的代价是每次翻转的操作代价之和。现在小可可想知道，当 $p$ 取遍 $n!$ 种排列时，所有情况的排序代价之和。

只用输出答案对 $998244353$（$=7 \times 17 \times 2^{23} + 1$，一个质数）取模后的值。

## 说明/提示

【样例 1 解释】

我们举一个例子，当 $p=[3,2,5,1,4]$ 时，算法的执行步骤如下：

- 执行到 $i=1$，$p_1,p_2,p_3,p_4,p_5$ 即 $3,2,5,1,4$ 中的最小值为 $p_4=1$，我们翻转区间 $[1,4]$，$p$ 变为 $[1,5,2,3,4]$，代价为 $w_{1,4}=4$；
- 执行到 $i=2$，$p_2,p_3,p_4,p_5$ 即 $5,2,3,4$ 中的最小值为 $p_3=2$，我们翻转区间 $[2,3]$，$p$ 变为 $[1,2,5,3,4]$，代价为 $w_{2,3}=2$；
- 执行到 $i=3$，$p_3,p_4,p_5$ 即 $5,3,4$ 中的最小值为 $p_4=3$，我们翻转区间 $[3,4]$，$p$ 变为 $[1,2,3,5,4]$，代价为 $w_{3,4}=2$；
- 执行到 $i=4$，$p_4,p_5$ 即 $5,4$ 中的最小值为 $p_5=4$，我们翻转区间 $[4,5]$，$p$ 变为 $[1,2,3,4,5]$，代价为 $w_{4,5}=2$。

可以看到，算法执行到第 $i$ 步结束时，序列的 $[1,i]$ 位置上恰好是 $[1,i]$ 号衣服，算法结束后 $p$ 被排好了序。这次排序总共付出了 $4+2+2+2=10$ 的代价。

**注意：算法一定会执行 $n-1$ 步，即使中间就排好了序也不会提前退出。**

【数据范围与提示】

**提示：本题输入规模较大，请避免使用过慢的输入方式。**

- 对于 $25\%$ 的数据，保证 $1 \le n \le 9$；
- 对于 $50\%$ 的数据，保证 $1 \le n \le 16$；
- 对于 $70\%$ 的数据，保证 $1 \le n \le 50$；
- 对于另外 $15\%$ 的数据，保证 $w_{i,j}=1$；
- 对于 $100\%$ 的数据，保证 $1 \le n \le 500$，$0 \le w_{i,j} < 998244353$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
1 2 3 4
1 2 3
1 2```

### 输出

```
1080```

## 样例 #2

### 输入

```
见附加文件的 sort2.in。 ```

### 输出

```
见附加文件的 sort2.ans。```

# 题解

## 作者：Akoasm_X (赞：12)

推不出规律就暴力枚举看一看，枚举全排列，然后按照题意模拟，记录每组交换的次数，输入5发现是这样的，规律就比较明显了


```cpp
24 24 24 24 24
30 30 30 30
40 40 40
60 60
```

和题目所给的每个系数相乘，答案刚好是1080。

规律就是 ： 每一行的和是 $ n! $ ，并且第$i$行会和$\left[{i},{n}\right]$范围内的数交换，交换次数是相等的。接下来可以借助这个，把每一行的权值求了个平均值，逆元处理，然后再乘$n!$即可，这样做等价于先求$ \frac{n!}{n-i+1}$,然后与每个权值相乘。

给出了一个比较感性的证明，全排是 $ n!$，对于第1小元素，在每个位置的可能性是相等的，所以每个交换次数就是 $ \frac{n!}{n}$。然后考虑第i个元素，每次交换并不影响出现位置的可能性，并且对于第i小的元素，$\left[{1},{i-1}\right]$ 都在前面排好的，所以只会和 $\left[{i},{n}\right]$ 范围内的数交换，具体到每个位置交换次数就是$ \frac{n!}{n-i+1}$。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL mod  = 998244353;
int n;
LL Ans;

inline LL read() 
{
    LL x = 0 , f = 1 ; char c = getchar() ;
    while( c < '0' || c > '9' ) { if( c == '-' ) f = -1 ; c = getchar() ; } 
    while( c >= '0' && c <= '9' ) { x = x * 10 + c - '0' ; c = getchar() ; } 
    return x * f ;
}

LL qu_pow(LL a,LL k)
{//借助快速幂处理逆元 
	LL ans = 1,base = a;
	while(k)
	{
		if(k&1) ans = (ans * base) % mod;
		base = base * base % mod;
		k >>= 1;
	}
	return ans;
}

int main()
{
	n = read();
	LL fact = 1;for(int i=2;i<=n;i++) fact = fact * i % mod;
	for(int i=1;i<n;i++)
	{
		LL sum = 0;
		for(int j=1;j<=n-i+1;j++)
			sum = (sum + read()) % mod;
		sum = sum * qu_pow(n-i+1,mod-2) % mod;//求解每一行的平均值 
		Ans = (Ans + sum) % mod;
	}
	Ans = Ans * fact % mod;//最后乘排列数 
	printf("%lld\n",Ans);
	return 0;
}
```


---

## 作者：meyi (赞：10)

注：本题解搬运自出题人在 GitHub 上公布的[官方题解](https://github.com/rushcheyo/AHOI-2021-junior)，数据及标程均可从此链接中下载。

考虑 DP。注意到第 $i-1$ 轮结束后，$[1,i-1]$ 位置上恰好是 $[1,i-1]$ 号衣服。于是我们设 $f_i$ 表示，第 $i$ 轮开始，$[i,n]$ 中取遍 $i,i+1,\ldots,n$ 的 $(n-i+1)!$ 种排列时的排序代价。

我们考虑枚举 $i$ 号衣服的位置为 $j$，那么需要付出 $w_{i,j}$ 的代价翻转 $[i,j]$。

那么从 $i+1$ 轮往后的代价是多少呢？其实就是 $f_{i+1}$。这是因为，考虑所有 $i,i+1,\ldots,n$ 的排列组成的集合，将其中每个元素翻转 $[i,j]$ 后集合并不变。

于是有 $f_i=\sum_{j=i}^n (w_{i,j}(n-i)!+f_{i+1})$。复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 505, P = 998244353;
int n, w[N][N], fact[N], dp[N];

int main() {
  scanf("%d", &n);
  for (int i = 1; i < n; ++i) {
    for (int j = i; j <= n; ++j) {
      scanf("%d", w[i] + j);
    }
  }
  fact[0] = 1;
  for (int i = 1; i <= n; ++i) {
    fact[i] = 1ll * fact[i - 1] * i % P;
  }
  for (int i = n - 1; i; --i) {
    for (int j = i; j <= n; ++j) {
      dp[i] = (dp[i] + dp[i + 1] + 1ll * w[i][j] * fact[n - i]) % P;
    }
  }
  printf("%d\n", dp[1]);
}
```

---

## 作者：yaoyuchen2021 (赞：4)

# 题目大意
现在有一个排列 $p$，你会从小到大枚举 $i(i\in[1,n])$，假设 $p_j$ 的值为 $i$，那么你会将 $[i,j]$ 中的值左右翻转，代价为 $w_{i,j}$，也就是将排列 $p$ 进行排序。问你，当 $p$ 取 $n!$ 种排列时，所有排序代价之和。

# 解题思路
先来分析操作。

开始时，由于题目将每种 $p$ 都取到了，所以每一个数字出现在任意一个位置的概率是相等的，都是 $\frac{n!}{n}$。

现在要进行操作了。假设当前待处理部分数组为 $i-1,a_i,a_{i+1},\dots,i,\dots,a_n$，进行操作时，首先会交换两数的位置，得到 $i-1,i,a_{i+1},\dots,a_i,\dots,a_n$，若所有数字出现的位置均等概率随机，则 $a_i$ 会等概率的被换在数组的任意位置，于是对于未排序部分数组，仍能保持“每一个数字出现在任意一个位置的概率是相等”这一性质。又因为最开始数组满足该性质，所以上述情况会出现。

于是我们可以得到，第一行的所有代价都被取到了 $\frac{n!}{n}$ 次，第二行的被取到了 $\frac{n!}{n-1}$ 次，以此类推，总代价为 $\sum_{i=1}^n \frac{n!}{n-i+1}$。

# AC Code
```cpp
//记得取模qaq
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int p=998244353;
int n,x,w,sum,ans;
signed main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++)
	{
		w=0;for(int j=1;j<=n-i+1;j++)cin>>x,w=(w+x)%p;
		sum=1;for(int j=1;j<=n;j++)if(i+j-1!=n)sum=(sum*j)%p;
        //蒟蒻不会求逆元，那就用不乘那个数代替取模完用逆元除
		ans=(ans+w*sum)%p;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：xhhhh36 (赞：3)

[传送门](https://www.luogu.com.cn/problem/P7623)

这题可以找规律。可以发现第 $i$ 步要将编号为 $i$ 的衣服通过翻转后变到位置 $i$，无论是否已经排列正确。

### 先讨论 $i$ 为 $1$ 时的情况
因为要求 $n$ 的全排列的代价之和，所以可以一开始 $1$ 可以位于 $1$ 到 $n$ 的之间的任意一个位置，其他的数任意放进空为中。$1$ 共有 $n$ 种位置，对于 $1$ 的每一个位置，其他的数都共有 $(n-1)!$ 种放置情况。所以第 $1$ 步时答案的总和为 $w_{1,j}$ 的总和。

### 规律
那么同理，当 $i>1$ 时，因为左边已经排好的数和答案无关，可以将剩下的右边那 $n-i$ 个数看成 $i$ 为 $1$ 时的子问题来解决。

当完成第 $1$ 步后，会发现共有 $n$ 个不同的数列经过翻转变换后变成了相同的数列。例如，翻转后的数列为 $1,2,3,4,5$。那么它可以由：
- $1,2,3,4,5$
- $2,1,3,4,5$
- $3,2,1,4,5$
- $4,3,2,1,5$
- $5,4,3,2,1$

这 $5$ 个数列翻转得到。所以在计算第 $2$ 步的时候要将答案乘上 $n$，后面的同理累乘。
# AC code
```cpp
#include <bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
int n,sum,ans,tmp=1;
int ch[505];
signed main()
{
	cin>>n;
	ch[0]=1;
	for (int i=1;i<=n;i++)
	{
		ch[i]=ch[i-1]*i%mod;
	}
	for (int i=1;i<n;i++)
	{
		sum=0;
		for (int j=1;j<=n-i+1;j++)
		{
			int w;
			scanf("%lld",&w);
			sum+=w;
			sum%=mod;
		}
		ans+=((ch[n-i]*tmp)%mod*sum)%mod;
		ans%=mod;
		tmp*=n-i+1;
		tmp%=mod;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：chengyixuan123 (赞：3)

# **P7623题解**

## 数据分析
对于 $25\%$ 的数据暴力全排列——计算。

对于另外 $15\%$ 的数据，$W_{i,j}=1$，这样只需要计算出全排列的值即可。

~~相信各位大佬应该都会吧~~

对于 $100\%$ 的数据……

## 正解
可以考虑以 $1$ 在第一个位置共有 $(n-1)!$ 类， 以 $\{1,2,3,\cdots,n\}$ 这一类来看，在所有的全排列中共用 $n$ 种不同的排列进行第一次交换后变成这一类，如：$\{2,1,3,\cdots,n\}$ 或 $\{3,2,1,\cdots,n\}$ 当前也包括 $\{1,2,3,\cdots,n\}$ 这个排列本身，显然这样就可以通过 $n$ 次把全排列中这样的排列归为一类，这样的代价为 $\sum w_{1,i}$。由于总共有 $(n-1)!$ 类，其它类也是如同上面一样，要经过一次交换把 $1$ 换到第一个位置，所以代价也为 $\sum w_{1,i}$，把所有的全排列 $1$ 的位置排在第 $1$ 位的总代价即为：$(n-1)! \times \sum w_{1,i}$。

同样的道理再把剩下的 $n-1$ 个数的全排列分成以 $2$ 为开始的排列，共有 $(n-2)!$ 类，注意此时每一类共有 $n$ 个（上面传下来的），按上述的分析可以出把 $2$ 调整到第二个位置的总代价即为 $n \times (n-2)! \times \sum w_{2,i}$。

……

把 $k$ 为放在第 $k$ 位置的总代价为：

$n \times (n-1) \times (n-k+2) \times (n-k)! \times \sum w_{k,i}$ 。

~~应该没推错……，请各位巨佬指正~~

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=510,maxn=998244353;
ll a[N],n,ans=0,w[N][N],b[N];
int main()
{
	//freopen("sort.in","r",stdin);
	//freopen("sort.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n-1;i++)
		for(int j=1;j<=n-i+1;j++) cin>>w[i][j];
	
	ll cnt=0,t=n;
	for(int i=1;i<=n-1;i++)
	{
	    ll num=0;
		ll ans=1;
		for(int j=1;j<=n-i;j++) ans=(ans%maxn*j%maxn)%maxn;
		if(i>=2)
		{
			for(int j=n;j>=n-i+2;j--) ans=(ans%maxn*j%maxn)%maxn; 
		}
		for(int j=1;j<=n-i+1;j++) num=(num%maxn+w[i][j]%maxn)%maxn;
		cnt=(cnt%maxn+num*ans%maxn)%maxn;
	}
	cout<<cnt<<endl;
	return 0;
}
```


写题解不易还请诸位点赞！

---

## 作者：roy2009 (赞：2)

# P7263题解

本蒟蒻第一次发题解，求管理员大大通过。

首先先看一下样例

Input
```
5
1 2 3 4 5
1 2 3 4
1 2 3
1 2
```

Output
```
1080
```

不难发现 $1080=15\times24+10\times30+6\times40+3\times60$

其中 $15$，$10$，$6$，$3$ 分别是每行之和

而

$24=1\times2\times3\times4=\dfrac{5!}
{5}$

$30=1\times2\times3\times5=\dfrac{5!}{4}$

$40=1\times2\times4\times5=\dfrac{5!}{3}$

$60=1\times3\times4\times5=\dfrac{5!}{2}$

所以答案 $ans=\sum\limits_{i=n}^1\sum\limits_{j=1}^ia_i\dfrac{n!}{i}$

$\sum\limits_{j=1}^i$ 表示第$i$行数据之和

注：由于取模涉及到乘法逆元，所以我们用  $f(i)$ 来预处理 $\dfrac{n!}{i}$。

上代码（注释见代码）

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int P=998244353,N=510;
int n,f[N];//f[i]用来统计阶乘
signed main(){
	//freopen("sort.in","r",stdin);
	//freopen("sort.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) f[i]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(i!=j) f[i]=f[i]*j%P;
       //预处理
	int ans=0;
	for(int i=n;i>1;i--)
		for(int j=1;j<=i;j++){
			int x;cin>>x;
			ans=(ans+x*f[i]%P)%P;
		}
	cout<<ans;
	return 0;
}
```

完结撒花

---

## 作者：sldsld (赞：2)

#### 本题我们后推前，设推到位置 $i$ ，那么 $[1,i-1]$ 已经排列好了，由于是全排列，我们每次寻找的数字就是 $ n-i$ 种，我们枚举 $ n-i+1 $ 种位置。

对于每一个位置剩下的数字也是全排列就是 $ f[n-i]$ 种情况。
 
#### 我们排序的代价之和就是 $w[i][j]\times f[n-i]$ 。
 
 
这只是一个位置的代价，每个位置排序后还要对 $n-i$ 个数进行排序，所有对于每一个 $i$ 。

#### 每一个位置确定后，还必须加上 $dp[i+1]$ 的代价。




------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
const int mod=998244353;
long long w[1005][1005];
long long f[1005];
long long dp[1005];
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
inline void pre()//预处理一下 
{
	f[1]=1;
	for(int i=2;i<=500;i++)
	{
		f[i]=(i*f[i-1])%mod;
	}
}
int main()
{
	n=read();
	pre();
	for(int i=1;i<=n-1;i++)
	{
		for(int j=i;j<=n;j++)
		{
			w[i][j]=read();
		}	
	} 
	for(int i=n-1;i>=1;i--)
	{
		for(int j=i;j<=n;j++)
		{
			dp[i]=(dp[i]+dp[i+1]+w[i][j]*f[n-i])%mod;
		}
	}
	printf("%lld",dp[1]);
	return 0;
}
```
蒟蒻第一次交题解，希望管理大大通过。

---

## 作者：2021changqing52 (赞：1)

# 思路：
~~看到翻转操作首先想到暴力 dfs 加平衡树维护翻转来暴力统计。（肯定不行而且我**知道但不会**平衡树）~~

规律可以暴力枚举每种情况（不是提交上去的代码），照题目模拟，最后把每种翻转都统计一遍，样例会得出
```cpp
24 24 24 24 24
30 30 30 30
40 40 40
60 60
```
我们会发现：每一行的和是 $n!$，并且第 $i$ 行会和 $[i,n]$ 范围内的数交换，交换次数是相等的。

接下来可以借助这个，对每一行的权值求平均值，然后再乘 $n!$ 即可。
# Code:
```cpp
#include<bits/stdc++.h>
#define mod 998244353//模数
using namespace std;
typedef long long ll;
int n;ll s,f=1;
inline ll read(){//快读
    ll x=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-' )f=-1;c=getchar();} 
    while(isdigit(c)){x=x*10+c-48;c=getchar();} 
    return x*f;
}
ll qpow(ll a,ll k){//快速幂
	ll ans=1;
	while(k){
		if(k&1)ans=(ans*a)%mod;
		a=a*a%mod;
		k>>=1;
	}
	return ans;
}
int main(){
	n=read();
	for(int i=2;i<=n;i++)f=f*i%mod;//阶乘
	for(int i=1;i<n;i++){
		ll su=0;
		for(int j=1;j<=n-i+1;j++)
		su=(su+read())%mod;//求和
		su=su*qpow(n-i+1,mod-2)%mod;//qpow(n-i+1,mod-2):n-i+1的逆元(除法取模求平均值)
		s=(s+su)%mod;
	}
	s=s*f%mod;//再乘上n!
	printf("%lld\n",s);
	return 0;
}
```

---

## 作者：Coros_Trusds (赞：1)

# 题目大意

看着这么多蒙灰的衣服，他们俩欲哭无泪；而且，有的衣服是没法一起洗的，为了分门别类，小可可给了每件衣服一个 $1 \sim n$ 的两两不同的标号，其中 $n$ 是衣服的件数，把衣服排成 $1,2,\ldots,n$ 的顺序再洗会比较方便。

小可可还想到，我们可以把一段连续的晾衣架拿出来，在手上翻转顺序，再放回去。作为 $\rm OI$ 选手的你，马上抽象出了小可可排序衣服的算法：我们设初始时从左往右第 $i$ 件衣服的标号为 $p_i$，按 $1,2,\ldots,n-1$ 的顺序枚举 $i$，设 $p_i,p_{i+1},\ldots,p_n$ 中标号最小的是 $p_j$，那么将 $p_i,p_{i+1},\ldots,p_{j-1},p_j$ 左右翻转变成 $p_j,p_{j-1},\ldots,p_{i+1},p_i$。

小雪很快发现，小可可的算法看似厉害，实际上很傻——在天色的影响下，大家都分不出衣服的标号了。于是他们只能回到房间进行理性愉悦：我们假设左右翻转区间 $[i,j]$ 的操作代价是 $w_{i,j}$，一次排序的代价是每次翻转的操作代价之和。现在小可可想知道，当 $p$ 取遍 $n!$ 种排列时，所有情况的排序代价之和。

只用输出答案对 $998244353$（$=7 \times 17 \times 2^{23} + 1$，一个质数）取模后的值。

# 题目分析

~~看到翻转操作首先想到暴力 $\verb!dfs!$ 加平衡树维护翻转来暴力统计。~~

考虑**动态规划**

题目中提到了一定会进行 $n$ 次翻转操作，所以假设当前正在进行第 $i$ 轮，那么前 $[1,i-1]$ 一定放好了的。所以还剩下 $n-i+1$ 个位置，令数字 $i$ 的位置在 $j$，那么一定有 $j\in[i,n]$。此时的方案数为 $(n-i+1)!$，翻转的代价为 $w[i,j]$。

令 $dp[i]$ 表示第 $i$ 轮开始，$[i,n]$ 中取遍 $i,i+1,\cdots,n$ 的 $(n-i+1)!$ 种排列时的代价。

因此，状态转移方程为：

$$dp[i]=\sum\limits_{j=i}^n(w[i,j]\cdot (n-i)!+dp[i+1])$$

$(n-i)!$ 就是 $[1,i-1]$ 的代价。

# 代码

```cpp
//2022/5/2
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define int long long
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : -(x))
#define stop return(0)
const int mod = 998244353;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 505;
int fact[N],dp[N],a[N][N];
int n;
inline void init(int R) {
	fact[0] = 1;
	for (register int i = 1;i <= R; ++ i) fact[i] = MOD(fact[i - 1] * i);
}
#undef int
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	#define int long long
	n = read();
	init(n);
	for (register int i = 1;i < n; ++ i) {
		for (register int j = i;j <= n; ++ j) {
			a[i][j] = read();
		}
	}
	for (register int i = n - 1;i >= 1; -- i) {
		for (register int j = i;j <= n; ++ j) {
			dp[i] = MOD(dp[i] + dp[i + 1] + MOD(a[i][j] * fact[n - i]));
		}
	}
	printf("%lld\n",dp[1]);

	return 0;
}
```

---

## 作者：toolong114514 (赞：1)

# P7623 [AHOI2021初中组] 收衣服 题解
## 题目大意
[传送门](https://www.luogu.com.cn/problem/P7623)
## 解题思路
先写一个暴力，枚举所有排列，对于每一个排列，都按题意去排一次序，最后把所有的代价加起来。

时间复杂度约为 $O(n!n^2)$，可以通过 $1 \le n \le 9$ 的数据，获得 25 分。

```cpp
#include<algorithm>
#include<iostream>
using namespace std;
#define int long long
const int mod=998244353;
int n;
int w[505][505],cnt[505][505];
bool vst[505];
int xh[505],zyh[505];
void sol(){
	for(int i=1;i<=n;i++){
		zyh[i]=xh[i];
	}
	for(int i=1;i<=n;i++){
		int t1,t2=n+1;
		for(int j=i;j<=n;j++){
			if(t2>zyh[j]){
				t2=zyh[j];
				t1=j;
			}
		}
		cnt[i][t1]++;
		cnt[i][t1]%=mod;
		int k1=i,k2=t1;
		while(k1<=k2){
			swap(zyh[k1],zyh[k2]);
			k1++;
			k2--;
		}
	}
}
void dfs(int pos){
	if(pos==n){
		sol();
		return;
	}
	for(int i=1;i<=n;i++){
		if(!vst[i]){
			vst[i]=true;
			xh[pos+1]=i;
			dfs(pos+1);
			vst[i]=false;
		}
	}
}
int ans;
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<n;i++){
		for(int j=i;j<=n;j++){
			cin>>w[i][j];
		}
	}
	dfs(0);
	cout<<ans;
	return 0;
}
```
接下来毫无头绪？

我们先不管 $w_{i,j}$ 的值，直接输出每一个 $w_{i,j}$ 的访问次数看一下。

当 $n=2$ 时：
```
1 1
```
当 $n=3$ 时：
```
2 2 2 
0 3 3
```
当 $n=4$ 时：
```
6 6 6 6
0 8 8 8
0 0 12 12
```
当 $n=5$ 时：
```cpp
24 24 24 24 24
0 30 30 30 30
0 0 40 40 40
0 0 0 60 60
```
我们可以总结出一些规律：

1. 每行的数都是相同的。

2. 对于所有的 $n$，第一行所有的数都是 $(n-1)!$。

3. 记有 $n$ 个数时，$w_{i,j}$ 的访问次数为 $T_{n,i,j}$，那么 $T_{n,i,j}=nT_{n-1,i-1,j}$（$i,j$只有在输入了 $w_{i,j}$ 的值时才会有此规律，且 $i\neq1
$）。

下面给出 $n=6$ 的情况，请读者自行检验此规律是否得到验证。
```
120 120 120 120 120 120
0 144 144 144 144 144
0 0 180 180 180 180
0 0 0 240 240 240
0 0 0 0 360 360
```
根据上述规律，直接编写代码即可。

时间复杂度约为 $O(n^2)$。
## 参考代码
```cpp
#include<iostream>
using namespace std;
#define int long long
const int mod=998244353;
int n,ans;
int w[505][505];
int f[505][505];
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<n;i++){
		for(int j=i;j<=n;j++){
			cin>>w[i][j];
		}
	}
	f[0][0]=1;
	for(int i=1;i<=n;i++){
		f[i][0]=f[i-1][0]*i;
		f[i][0]%=mod;
	}
	for(int i=2;i<=n;i++){
		f[i][1]=f[i-1][0];
		for(int j=2;j<i;j++){
			f[i][j]=f[i-1][j-1]*i;
			f[i][j]%=mod;
		}
	}
	for(int i=1;i<n;i++){
		for(int j=i;j<=n;j++){
			ans+=w[i][j]*f[n][i];
			ans%=mod;
		}
	}
	cout<<ans;
	return 0;
}
```
[本代码可以通过评测。](https://www.luogu.com.cn/record/151855188)
## 后记

事实上本题正解是 DP，本质上我们打表找的规律和状态转移方程并没有区别。

我猜测赛时没有太多人直接推 DP 做出来。

~~话说出题人是故意设计成这样，还是不小心让找规律的选手过掉了呢?~~

Written by [toolong114514](www.luogu.com.cn/user/477821) on 2024/3/21.

---


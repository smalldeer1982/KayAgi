# [蓝桥杯 2015 省 AB] 垒骰子

## 题目描述

赌圣 atm 晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。

经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！

我们先来规范一下骰子：$1$ 的对面是 $4$，$2$ 的对面是 $5$，$3$ 的对面是 $6$。

假设有 $m$ 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。

atm 想计算一下有多少种不同的可能的垒骰子方式。

两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。

由于方案数可能过多，请输出模 $10^9+7$ 的结果。

不要小看了 atm 的骰子数量哦～。

## 说明/提示

对于 $30\%$ 的数据：$n \le 5$。

对于 $60\%$ 的数据：$n \le 100$。

对于 $100\%$ 的数据：$0<n \le 10^9,m \le 36$。

时限 2 秒, 256M

蓝桥杯 2015 年省赛 AB 组 I 题。

## 样例 #1

### 输入

```
2 1
1 2
```

### 输出

```
544```

# 题解

## 作者：Meickol (赞：8)

**思路分析：**



> 一、思考整体思路及状态表示式，以便后续根据递推关系建立状态转移方程。

​	$f[i][j]$ 表示自上往下第 $i$ 个骰子且该骰子朝上的一面为数字 $j$ 的所有可能性。

​	又因为每个骰子侧面可以旋转，即每个骰子可能性 $\times$ $4$

​	因而当不考虑互斥情况时，状态转移方程应为 $f[i][j]=\sum_{k=1}^{6} f[i-1][k]\times4$。

​	同时最终答案应为 $ans=\sum_{k=1}^{6} f[n][k]$。




> 二、考虑互斥情况以及 $oppo$ 的处理方式。

​	但这题需要考虑互斥情况，接下来考虑互斥的处理。

​	利用 $st$ 数组记录互斥信息，输入 $a,b$ 后将 $st[a][b]$ 进行标记表示 $a$ 和 $b$ 间存在互斥关系。

​	因为是考虑紧挨之间是否存在互斥关系。

​	如考虑第 $i$ 个骰子与第 $i-1$ 个骰子之间是否存在互斥情况，即第 $i$ 个骰子底部与第 $i-1$ 个骰子顶部数字是否互斥。

​	因而引入 $oppo[j]$ 表示一个以数字 $j$ 朝上的骰子中在数字 $j$ 对面的数字。

​	不考虑互斥情况时状态转移方程：$f[i][j]=\sum_{k=1}^{6} f[i-1][k] \times 4$

​	**考虑互斥情况后状态转移方程：**$f[i][j]=\sum_{k=1}^{6} f[i-1][k] \times 4 \times st[k][oppo[j]]$

​	通过图像理解也很直观：

![1](https://cdn.luogu.com.cn/upload/image_hosting/xtpuhwe0.png)

​	

​	另外对于 $oppo$ 的处理有两种方式，其中我们采用了第一种方式

​	Ⅰ、数组保存：利用 $oppo$ 数组来保存骰子数字的对立面数字。

```C++
int oppo[7]={0,4,5,6,1,2,3};
```

​	Ⅱ、函数计算：

```c++
int get_oppo(int x){
	if(x>3) return x-3;
	else return x+3;
}
```



> 三、进一步思考



​	对于答案，$ans=F_n,F_n=f[n][1]+f[n][2]+f[n][3]+f[n][4]+f[n][5]+f[n][6]$

​	即 $ans=\sum_{k=1}^{6} f[n][k]$


​	以及每一个 $f[i][j]$ 的计算：$f[i][j]=\sum_{k=1}^{6}f[i-1][k] \times 4 \times st[k][oppo[j]]$


​	转化成伪代码：

```C++
for(int i=1;i<=6;i++) f[1][i]=4;
for(int i=2;i<=n;i++)
    for(int j=1;j<=6;j++)
        if(非互斥) f[i][j] = (f[i][j] + f[i - 1][j] * 4)
```

​	易知时间复杂度为 $O(n)$

​	考虑到数据范围：$1≤n≤10^9$，以及题目所给的 $1s$ 时间上限。

​	显然会超时，需要进行优化！



> 四、矩阵加速（矩阵快速幂）

​	考虑到数据范围：$1≤n≤10^9$，于是想到利用矩阵乘法进行优化以降低时间复杂度。

​	使用矩阵快速幂的方式，复杂度 $O(\log n)$，可以解决问题。

​	
$$
例:当存在\begin{bmatrix}
 1&2 \\
 1&5 \\
 2&6 \\
 3&4 \\
 5&5
\end{bmatrix}的互斥关系时,

F(n) \ \begin{bmatrix}
  4&  0&  4&  4&  0& 4\\
  4&  4&  0&  0&  4& 4\\
  0&  4&  4&  4&  4& 4\\
  4&  4&  4&  4&  4& 4\\
  4&  0&  4&  0&  4& 4\\
  4&  4&  4&  4&  0& 4
\end{bmatrix}
=F(n+1)
$$
​	观察可发现，$F_n=F_1 \times A^{n-1}$



​	将 $res$ 矩阵的值初始化为 $F_1$

```C++
for(int i=1;i<=6;i++)res.c[1][i]=4;
```

​	对于常数矩阵 $A$ 的设置：

```C++
for(int i=1;i<=6;i++){
    for(int j=1;j<=6;j++){
        if(st[i][oppo[j]]) A.c[i][j]=0;
        else A.c[i][j]=4;
    }
}
```



> 最终代码：

```C++
#include<bits/stdc++.h>
using namespace std;
#define rep(x,y,z) for(int x=y;x<=z;x++)
typedef long long LL;
const int mod=1e9+7;
int n,m,a,b,oppo[7]={0,4,5,6,1,2,3};
bool st[7][7];
struct matrix{
    LL c[7][7];
    matrix(){memset(c,0,sizeof c);}
}A,res;
matrix operator * (matrix &x,matrix &y){
    matrix t;
    rep(i,1,6){
        rep(j,1,6){
            rep(k,1,6){
                t.c[i][j]=(t.c[i][j]+x.c[i][k]*y.c[k][j])%mod;
            }
        }
    }
    return t;
}
void fastpow(LL k){
    rep(i,1,6) res.c[1][i]=4;
    rep(i,1,6){
        rep(j,1,6){
            if(st[i][oppo[j]]) A.c[i][j]=0;
            else A.c[i][j]=4;
        }
    }
    while(k){
        if(k&1) res=res*A;
        A=A*A;
        k>>=1;
    }
}
int main(){
    cin>>n>>m;
    while(m--){
        cin>>a>>b;
        st[a][b]=st[b][a]=1;
    }
    fastpow(n-1);
    LL ans=0;
    rep(i,1,6) ans=(ans%mod+res.c[1][i]%mod)%mod;
    cout<<ans;
    return 0;
}
```

---

## 作者：行吟啸九州 (赞：6)

考虑用 dp 解决这个问题。

由于固定骰子朝上的面时，朝下的面也被固定了，其余面一共有4种情况，而除了朝上的面和朝下的面，其余面的情况对转移没有影响。故令 $c_{i, j} = 0 / 4$ 表示上一个骰子的朝上的面是 $i$ 时，当前放的骰子朝上的面是 $j$ 有多少种组合方案。


$\mathit{dp}_{i,k}$ 表示已经垒了 $i$ 个骰子，最上面的那个面的数字是 $k$ 的方案数，$\mathit{dp}_{i,k}= \sum\limits_{j=1} ^ 6\mathit{dp}_{i - 1,j} * c_{j, k}$，这个 dp 显然可以解决这个问题。但不过复杂度是 $O(36n)$ 的，这显然不可接受。

考虑 dp 转移与 $i$ 无关，不过是将同一种转移反复做了 $O(n)$ 次，故可以使用矩阵快速幂。令转移矩阵为 $(cij)$，$(cij)$ 的定义如同 $c$ 数组的定义即可。

由于第一步咋放都行，故初始矩阵设定成第一行为4，其余行为0的矩阵即可，答案将所得矩阵第一行加起来即可。

复杂度 $O(6^3logn)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 7
#define int long long
#define mod 1000000007
#define For(i, j, n) for(int i = j ; i <= n ; ++i)
int a, b, n, m, ans;

struct matrix{
	int c[N][N];
	matrix(){ memset(c, 0, sizeof(c)); }
	friend matrix operator * (matrix x, matrix y){
		matrix z;
		For(i, 1, 6) For(j, 1, 6) For(k, 1, 6) z.c[i][j] = (z.c[i][j] + x.c[i][k] * y.c[k][j]) % mod;	
		return z;
	}
}t, st;

inline matrix quickpow(matrix x, int y){
	matrix sum;
	For(i, 1, 6) sum.c[i][i] = 1;
	for( ; y ; x = x * x, y >>= 1) if(y & 1) sum = sum * x;
	return sum;
}

inline int opposite(int x){ return x == 3 ? 6 : (x + 3) % 6; }

signed main(){
	scanf("%lld %lld", &n, &m);
	For(i, 1, 6) For(j, 1, 6) t.c[i][j] = 4;
	For(i, 1, m) scanf("%lld %lld", &a, &b), t.c[a][opposite(b)] = 0, t.c[b][opposite(a)] = 0;
	For(i, 1, 6) st.c[1][i] = 4;
	st = st * quickpow(t, n - 1);
	For(i, 1, 6) ans += st.c[1][i];
	printf("%lld", ans % mod);
	return 0;
}

---

## 作者：Chenaknoip (赞：3)

一道 DP 好题。   

令 $f _{i,j}$ 表示垒完前 $i$ 个骰子后，第 $j$ 面朝上的方案数。令 $can _{i,j}$ 表示数字 $i$ 和 $j$ 能否贴在一起（$0$ 表示不可以，$1$ 表示可以）。

易得 $f _{i,j} = 4 \times \sum _{k=1} ^6 {(f _{i-1,k} \times can _{7-j,k})}$。

因为 $n \le 10^9$，所以考虑矩阵快速幂优化。

令 $F_i = [f_{i,1}, f_{i,2}, f_{i,3}, f_{i,4}, f_{i,5}, f_{i,6}]$，$A=(a_{i,j})=[can _{7-i,j}]$，则有$F_n = A^{n-1} \times F_1$。


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
int vis[7][7];
void mul(ll ans[][7], ll a[][7], ll b[][7]) {
	ll t[7][7] = {
		0
	};
	for (int i = 1; i <= 6; i++) {
		for (int j = 1; j <= 6; j++) {
			for (int k = 1; k <= 6; k++)
				t[i][j] = (t[i][j] + a[i][k] * b[k][j]) % mod;
		}
	}
	memcpy(ans, t, sizeof t);
}
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= 6; i++) {
		for (int j = 1; j <= 6; j++)
			vis[i][j] = 4;
	}
	while (m--) {
		int u, v;
		scanf("%d%d", & u, & v);
		vis[u][v] = vis[v][u] = 0;
	}
	ll t[7][7] = {
		{0, 0, 0, 0, 0, 0, 0},
		{0, vis[1][4], vis[1][5], vis[1][6], vis[1][1], vis[1][2], vis[1][3]},
		{0, vis[2][4], vis[2][5], vis[2][6], vis[2][1], vis[2][2], vis[2][3]},
		{0, vis[3][4], vis[3][5], vis[3][6], vis[3][1], vis[3][2], vis[3][3]},
		{0, vis[4][4], vis[4][5], vis[4][6], vis[4][1], vis[4][2], vis[4][3]},
		{0, vis[5][4], vis[5][5], vis[5][6], vis[5][1], vis[5][2], vis[5][3]},
		{0, vis[6][4], vis[6][5], vis[6][6], vis[6][1], vis[6][2], vis[6][3]},
	};
	ll ans[7][7] = {
		{0, 0, 0, 0, 0, 0, 0},
		{0, 1, 0, 0, 0, 0, 0},
		{0, 0, 1, 0, 0, 0, 0},
		{0, 0, 0, 1, 0, 0, 0},
		{0, 0, 0, 0, 1, 0, 0},
		{0, 0, 0, 0, 0, 1, 0},
		{0, 0, 0, 0, 0, 0, 1},
	};
	n--;
	while (n) {
		if (n & 1)
			mul(ans, ans, t);
		n >>= 1;
		mul(t, t, t);
	}
	ll sum = 0;
	for (int i = 1; i <= 6; i++) {
		for (int j = 1; j <= 6; j++)
			sum = (sum + ans[i][j] * 4) % mod;
	}
	printf("%lld", sum);
	return 0;
}
```


---

## 作者：naroto2022 (赞：2)

# P8624 题解

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P8624)

### 思路

首先看完题目很自然的想到可以设 $dp_{i,j}$ 表示第 $i$ 个骰子以 $j$ 面朝上的方案数。

首先对立关系由于总共才 $6$ 种情况，所以可以直接用一个二维数组 $mp_{i,j}$ 来存，$i,j$ 排斥为 $0$，否则为 $1$。

初始化就是 $dp_1$ 的所有方案数为 $1$。

考虑转移，$\begin{aligned}dp_{i,j}=\sum_{k=1}^6 dp_{i-1,opp_k}\times mp_{j,opp_k}\end{aligned}$。

其中，$opp_i$ 表示 $i$ 的对面。

```opp[10]={0,4,5,6,1,2,3}```

但是 $n\leq10^9$，这么做显然是不行的，考虑矩阵加速。

对于样例，我们有如下式子。

$\begin{bmatrix}dp_{n,1}\\dp_{n,2}\\dp_{n,3}\\dp_{n,4}\\dp_{n,5}\\dp_{n,6}\end{bmatrix}=\begin{bmatrix}1&1&1&1&0&1\\1&1&1&0&1&1\\1&1&1&1&1&1\\1&1&1&1&1&1\\1&1&1&1&1&1\\1&1&1&1&1&1\end{bmatrix}^{n-1}\times\begin{bmatrix}dp_{n-1,1}\\dp_{n-1,2}\\dp_{n-1,3}\\dp_{n-1,4}\\dp_{n-1,5}\\dp_{n-1,6}\end{bmatrix}$。

统计答案 $ans$ 非常简单，就直接将最终得到的矩阵的值全部加起来即可。

当然这样子是不行的，因为每一个筛子因为侧边是可以旋转的，都有 $4$ 种摆法，所以最终得到的 $ans$ 还得乘上 $4^n$，快速幂解决即可（记得取模。。。）。

### 代码


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int MN=40;
const int mod=1e9+7;
ll n,m,u,v,mp[MN][MN],ans,opp[MN]={0,4,5,6,1,2,3};
void write(ll n){if(n<0){putchar('-');write(-n);return;}if(n>9)write(n/10);putchar(n%10+'0');}
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
struct matrix{
    ll g[7][7];
    void clear(){memset(g,0,sizeof(g));}
}f1,f2;
inline matrix operator * (matrix a, matrix b){
	matrix c;c.clear();
	for(int i=1; i<=6; i++) for(int j=1; j<=6; j++) for(int k=1; k<=6; k++) c.g[i][j]=(c.g[i][j]+(a.g[i][k]*b.g[k][j])%mod)%mod;
	return c;
}
inline matrix operator ^ (matrix a, ll b){
	matrix ans;ans.clear();
    for(int i=1; i<=6; i++) ans.g[i][i]=1;
	while(b){
		if(b&1) ans=ans*a;
		a=a*a;
		b>>=1;
	}
	return ans;
}
ll ksm(ll a, ll b){
    ll res=1;
    while(b){
        if(b&1) res=(res*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return res;
}
void init(){
    for(int i=1; i<=6; i++) f2.g[i][1]=1;
    for(int i=1; i<=6; i++) for(int j=1; j<=6; j++) f1.g[i][j]=mp[i][opp[j]]^1;
}
int main(){
    // freopen("1.in","r",stdin);
    n=read();m=read();
    for(int i=1; i<=m; i++){
        u=read();v=read();
        mp[u][v]=mp[v][u]=1;
    }
    init();
    matrix res=(f1^(n-1))*f2;
    for(int i=1; i<=6; i++) ans=(ans+res.g[i][1])%mod;
    ans=(ans*ksm(4,n))%mod;
    write(ans);
	return 0;
}
```

---

## 作者：ReturnXI (赞：1)

~~这个题目题解较少，过来水一篇题解~~
### 思路分析
   当涉及骰子堆叠时，我们可以考虑使用动态规划来解决这个问题。我们将定义一个动态规划数组 $dp[i][j][k]$，表示在堆叠前 $i$ 个骰子时，第 $i$ 个骰子的朝向为 $j$，且共有 $k$ 种排列方式。由于题目中要求的是堆叠骰子的方式总数，因此我们只需要考虑每个骰子的朝向即可。

   接下来，我们定义状态转移方程来更新 $dp$ 数组。假设当前处理的是第 $i$ 个骰子，其朝向为 $j$，我们需要计算在前 $i$ 个骰子堆叠完成后，朝向为 $j$ 的方案数 $dp[i][j][k]$。考虑到每个骰子有六个面，我们可以遍历上一个骰子的朝向 $l$，来更新当前骰子的状态。如果上一个骰子的朝向为 $l$,那么当前骰子的朝向只能为$1-6$中与 $l$ 不相邻的数。在更新状态时，需要考虑题目中的排斥关系。

根据上述思路，我们可以得到状态转移方程如下：
$$
dp[i][j][k] = \sum_{l=1, l \neq j \, \text{and} \, l \, \text{and} \, j \, \text{are not conflict}}^{6} dp[i-1][l][k-1]

$$
其中，状态转移方程中的求和操作表示在上一个骰子的朝向为 $l$ 的情况下，当前骰子的朝向为 $j$ 的排列方式总数。在求解 $dp$ 数组时，我们需要考虑排斥关系，即不能将相互排斥的数字紧贴在一起。因此，在更新状态时，需要检查上一个骰子的朝向 $l$ 和当前骰子的朝向 $j$ 是否满足排斥关系。

然后，我们可以通过填充 $dp$ 数组来计算堆叠所有骰子的方式总数。当堆叠完成后，我们将得到 $dp[n][j][k]$ 中所有朝向和为 $k$ 的排列方式总数之和即为最终的答案。

最后，我们需要对最终的答案取模。

综上所述，我们可以使用动态规划的方法来解决这个问题。具体实现细节如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MOD = 1e9+7;
int opposite[7] = {0, 4, 5, 6, 1, 2, 3}; // 确定骰子的对立面
int n, m;

// 构造一个矩阵类
struct Matrix { 
    ll data[6][6];
    Matrix() { 
        for(int i = 0; i < 6; i++) {
            for(int j = 0; j < 6; j++) {
                data[i][j] = 1;
            }
        }
    }
};

// 矩阵乘法
Matrix multiply(Matrix m1, Matrix m2) { 
    Matrix result;
    for(int i = 0; i < 6; i++) {
        for(int j = 0; j < 6; j++) {
            result.data[i][j] = 0;
            for(int k = 0; k < 6; k++) {
                result.data[i][j] = (result.data[i][j] + m1.data[i][k] * m2.data[k][j]) % MOD;
            }
        }
    }
    return result;
}

// 用快速幂求矩阵
Matrix power(Matrix m, int k) { 
    Matrix result;
    for(int i = 0; i < 6; i++) {
        for(int j = 0; j < 6; j++) {
            if(i == j) {
                result.data[i][j] = 1;
            } else {
                result.data[i][j] = 0;
            }
        }
    }
    while(k) {
        if(k & 1) {
            result = multiply(result, m);
        }
        m = multiply(m, m);
        k >>= 1;
    }
    return result;
}

ll quick_power(ll a, ll b) {
    ll result = 1;
    while(b) {
        if(b & 1) {
            result = (result * a) % MOD;
        }
        a = (a * a) % MOD;
        b >>= 1;
    }
    return result;
}

int main() {
    cin >> n >> m;
    Matrix conflict_matrix; // 冲突矩阵
    for(int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        conflict_matrix.data[opposite[a] - 1][b - 1] = 0; // 若1，2冲突，那冲突矩阵的4，2和5，1这两个位置就应该是0，因为矩阵的行代表朝上的数字，所以如果4朝上，1就朝下，会和2冲突.
        conflict_matrix.data[opposite[b] - 1][a - 1] = 0; 
    }
    Matrix conflict_n_minus_1 = power(conflict_matrix, n - 1); // 求冲突矩阵的n-1次方
    ll sum = 0;
    for(int i = 0; i < 6; i++) { // 求出所有的方案数，求出冲突矩阵的n-1次方后，再乘一个元素全为1的1行6列的矩阵，这个矩阵是最开始数字1~6朝上的方案数，都为1，又因为每个都是乘1，所以只要算最后冲突矩阵的每个元素总和
        for(int j = 0; j < 6; j++) {
            sum = (sum + conflict_n_minus_1.data[i][j]) % MOD;
        }
    }
  
    ll ans = (sum * quick_power(4, n)) % MOD; // 快速幂
    cout << ans << endl;
    return 0;
}
```
如果后续发现有问题会及时更改的。

---

## 作者：末然Ender (赞：0)

# 题解：P8624 [蓝桥杯 2015 省 AB] 垒骰子

矩阵快速幂加速递推好题。

## 思路

首先读题：我们要垒骰子，有些面不能相对，求方案数。

首先很容易考虑到，骰子的两个面不能相对，假设这两个面点数是 $a,b$，那么就意味着**相邻的两个骰子 $a$ 的面与 $b$ 所对应骰子另一边的面不能同时朝上，反之亦然**，我们记作 $vis_{a,dui_b}=1$，其中 $dui_b$ 指的是点数 $b$ 所对的面的点数。

考虑进行 dp，我们用 $f_{i,j}$ 表示第 $i$ 个骰子点数为 $j+1$ 的面朝上的方案数（注意，个人习惯，表示的是 $j+1$ 点数的面）。

再观察一下样例，我们又能注意到一个性质，就是两个面矛盾仅与骰子上下两个面有关，剩下四个面可以任意旋转，我们就可以得到状态转移方程：

$$
f_{i,j}=\sum_{j=0}^5(4\times f_{i-1,j}\times [vis_{i,j}\ne 1])
$$

~~然后我们就可以拿到不知道多少分的好成绩。~~

时间复杂度 $O(n)$ ，还带一个骰子面数的常数，很明显无法通过本题。

很容易考虑到矩阵快速幂加速递推，我们设初始矩阵为：
$$
\left[
\begin{matrix}
1 & 1 & 1 & 1 & 1 & 1\\
0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 0\\
\end{matrix}
\right]
$$
，然后转移矩阵全部填 $4$ ，如果 $vis_{i,j}=0$ 就把第 $i$ 行第 $j$ 列改为 $0$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define getchar getchar_unlocked
#define putchar putchar_unlocked
template<typename T>
inline void read(T& x){x=0;char ch=getchar();long long f=1;while(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}x*=f;}
template<typename T,typename... Args>
inline void read(T& first,Args&... args){read(first);read(args...);}
template<typename T>
inline void write(T arg){T x=arg;if (x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
template<typename T,typename... Args>
inline void write(T arg,Args... args){write(arg);if(sizeof...(args) !=0){putchar(' ');write(args...);}}
typedef long long ll;
const ll N=1e6+5,mod=1e9+7;
struct matrix{
	ll a[6][6];
	matrix(){memset(a,0,sizeof a);}
}ans,T;
ll n,m;
matrix operator *(const matrix &a,const matrix &b){
	matrix c;
	for(int i=0;i<6;i++){
		for(int j=0;j<6;j++){
			for(int k=0;k<6;k++){
				c.a[i][j]+=a.a[i][k]*b.a[k][j]%mod;
				c.a[i][j]%=mod;
			}
		}
	}
	return c;
}
matrix ksm(matrix a,ll b){
	matrix res;
	res.a[0][0]=res.a[1][1]=res.a[2][2]=res.a[3][3]=res.a[4][4]=res.a[5][5]=1;
	while(b){
		if(b&1)res=res*a;
		a=a*a;
		b>>=1;
	}
	return res; 
}
void init(){
	ans.a[0][1]=ans.a[0][2]=ans.a[0][3]=ans.a[0][4]=ans.a[0][5]=ans.a[0][0]=4;
	for(int i=0;i<6;i++){
		for(int j=0;j<6;j++){
			T.a[i][j]=4;
		}
	}
}
void print(matrix t){
	for(int i=0;i<6;i++){
		for(int j=0;j<6;j++){
			write(t.a[i][j]);
			putchar(' ');
		}
		putchar('\n');
	}
}
ll dui[7]={0,4,5,6,1,2,3};
int main(){
	read(n,m);
	init();
	for(int i=1;i<=m;i++){
		ll a,b;
		read(a,b);
		T.a[a-1][dui[b]-1]=T.a[b-1][dui[a]-1]=0;
	}
	ans=ans*ksm(T,n-1);
	write((ans.a[0][1]+ans.a[0][2]+ans.a[0][3]+ans.a[0][4]+ans.a[0][5]+ans.a[0][0])%mod);
	return 0;
} 
```

---

## 作者：_O_v_O_ (赞：0)

设 $dp_{i,j}$ 为第 $i$ 个骰子向上的面为 $j$ 的方案数。

那么 $dp_{i,j}=\sum_{k=1}^6 dp_{k,j}[k\not= i\bmod3\land k\not= i\bmod 3+3]$。

这是 $O(n)$ 的，考虑矩阵优化。

我们只用注意转移矩阵 $base$，很明显是：

$$\begin{bmatrix}0&4&4&0&4&4 \\ 4&0&4&4&0&4 \\ 4&4&0&4&4&0\\ 0&4&4&0&4&4 \\ 4&0&4&4&0&4 \\ 4&4&0&4&4&0\\\end{bmatrix}$$

然后这题就可以解了。

---


# [蓝桥杯 2019 国 B] 排列数

## 题目描述

在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。

对于一个 $1 ∼ n$ 的排列，如果可以将这个排列中包含 $t$ 个折点，则它称为一个 $t + 1$ 单调排列。

例如，排列 $(1, 4, 2, 3)$ 是一个 $3$ 单调排列，其中 $4$ 和 $2$ 都是折点。

给定 $n$ 和 $k$，请问 $1 ∼ n$ 的所有排列中有多少个 $k$ 单调排列？


## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq k \leq n \leq 10$;

对于 $40 \%$ 的评测用例, $1 \leq k \leq n \leq 20$; 对于 $60 \%$ 的评测用例, $1 \leq k \leq n \leq 100$;

对于所有评测用例， $1 \leq k \leq n \leq 500$ 。 


蓝桥杯 2019 年国赛 B 组 G 题。

## 样例 #1

### 输入

```
4 2
```

### 输出

```
12
```

# 题解

## 作者：DreamLand_zcb (赞：17)

## 题意

[题目传送门](https://www.luogu.com.cn/problem/P8699)

## 思路

设状态 $dp[i][j]$ 其中 $i$ 表示前 $i$ 个数中，有 $j$ 个**折点**的方案数。

考虑状态转移，显然 $dp[i][j]$ 只能影响到 $dp[i+1][j]$、$dp[i+1][j+1]$、$dp[i+1][j+2]$，证明如下：

首先需要确定，在原序列中插入第 $i + 1$ 个数，这个 $i + 1$ 是所有数中最大的，所以只要**在非头/尾部**插入这个点，这个点一定就是新的折点。

1. $dp[i+1][j]$ 表示插入第 $i + 1$ 个点后没有新增折点：

	例：![](https://huatu.98youxi.com/markdown/work/uploads/upload_16b4e7b0d43cdeb644b4cabd34dd15d0.png)
    
    情况一如图，当 $i + 1$ 插入波峰 $x$ 左右侧时，$x$ 不再是折点，折点变成了 $i + 1$，此时折点数不变。
    
    ![](https://huatu.98youxi.com/markdown/work/uploads/upload_3d9a88cca324cab932e0d8f535543686.png)
    
    情况二如图，当 $i + 1$ 插入序列头尾 $x$ 左右时，$x$ 依然不是折点，序列没有新增折点，此时折点数不变（如果头或尾的点是向下走的那么插入后新增了一个点，不属于该范围，此时只有在其中一边插入 $i + 1$ 才能满足不增加新折点）。
    
    
    总结一下，当 $j$ 为奇数，总共 $\dfrac {j-1}2 \times 2 + 2 = j + 1$ 种可能。当 $j$ 为偶数，总共 $\dfrac {j}2 \times 2 + 1 = j + 1$ 中可能，所以转移方程：
    
    $$dp[i+1][j] = dp[i][j] \times (j + 1)$$
    
    
2. $dp[i+1][j+1]$ 表示插入第 $i + 1$ 个点后新增了一个转折点。

	只有一种情况，即当在序列头和尾向下走时在头和尾前后插入 $i + 1$ 只增加一个转折点，如图，$x$ 为新增的一个转折点。
    
    ![](https://huatu.98youxi.com/markdown/work/uploads/upload_040e678fb67293b57c25d32629a103e7.png)
    
    所以转移方程：
    
    $$dp[i+1][j+1] = dp[i][j] \times 2$$
    
3. $dp[i+1][j+2]$ 表示插入第 $i + 1$ 个点后新增了两个转折点。

	显然在除了以上所有情况，其他地方插入 $i + 1$ 都会新增两个折点，转移方程：
    
    $$dp[i+1][j+2] = dp[i][j] \times (i + 1 - (j + 1) - 2)$$
    
    $$ = dp[i][j] \times (i - j - 2)$$
    
初始值：$dp[1][0] = 1$、$dp[i][0] = 2 (1 < i < n)$。

答案：$dp[n][k-1]$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a))
using namespace std;

const int MOD = 123456;
int n, k;
int dp[505][505];
int mod(int a)
{
	return a % MOD;
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> k;
	dp[1][0] = 1;
	for(int i=2;i<n;i++)
	{
		dp[i][0] = 2;
		for(int j=0;j<=i;j++)
		{
			dp[i+1][j] += mod(dp[i][j] * (j + 1));
			dp[i+1][j+1] += mod(dp[i][j] * 2);
			dp[i+1][j+2] += mod(dp[i][j] * (i - j - 2));
		}
	}
	cout << dp[n][k-1] % MOD;
	return 0;
}

```

---

## 作者：Fantasy_Segment_Tree (赞：7)

考虑在 $1$ 至 $i$ 中插入 $i + 1$，则有以下几种情况：

1. 不新增折点。

![](https://cdn.luogu.com.cn/upload/image_hosting/j594d715.png?x-oss-process=image/resize,m_lfit,h_1020,w_1350)

当 $j$ 为奇数时，两头都可以插入 $i + 1$，同时波峰共有 $\frac{j - 1}{2} \times 2$（波峰两端都可以插入）种情况，共 $\frac{j - 1}{2} \times 2 + 2 = j + 1$ 种情况。

当 $j$ 为偶数时，必定两头一上一下，所以只有一端可以插入 $i + 1$，共有 $\frac{j}{2} \times 2 + 1 = j + 1$ 种情况。

综上所述，不新增折点的共有 $j + 1$ 种情况。

2. 新增一个折点

![](https://cdn.luogu.com.cn/upload/image_hosting/7p30ke5w.png?x-oss-process=image/resize,m_lfit,h_1020,w_1350)

这种情况只有当两头均向下的时候在两头插入才会出现。所以共有 $2$ 种。

3. 新增两个折点

对于 $1$ 至 $i$ 的数列，每两个数之间或者数列前后都可以插入，共 $(i - 1) + 2 = i + 1$ 种情况。

除去另外两种情况，共有 $(i + 1) - (j + 1) - 2 = i - j - 2$ 种情况。

所以状态转移方程就是：

1. $f_{i + 1, j} \gets f_{i + 1, j} + (j + 1) \times f_{i, j}$

1. $f_{i + 1, j + 1} \gets f_{i + 1, j + 1} + 2 \times f_{i, j}$

1. $f_{i + 1, j + 2} \gets f_{i + 1, j + 2} + (i - j - 2) \times f_{i, j}$



代码：

```cpp
#include <iostream>
using namespace std;

int dp[505][505], mod = 123456;

int main() {
	int n, k;
	cin >> n >> k;
	dp[1][0] = 1;
	for(int i = 2; i <= n; i++) {
		dp[i][0] = 2;
		for(int j = 0; j <= i; j++) {
			dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * 2 % mod) % mod;
			dp[i + 1][j + 2] = (dp[i + 1][j + 2] + dp[i][j] * (i - j - 2) % mod) % mod;
			dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * (j + 1) % mod) % mod;
		}
	}
	cout << dp[n][k - 1];
}
```

注：状态转移部分是由 $f_{i, j}$ 进行推导，而不是推出 $f_{i, j}$。

---

## 作者：Dovuq (赞：6)

## 前言

~~时隔 $3$ 年，蒟蒻又来发题解啦~~

## 题目概要

[题目传送门](https://www.luogu.com.cn/problem/P8699)

题目大意：

> 给定正整数 $n$ 和 $k$，问 $1 ∼ n$ 的所有排列中有多少个 $k$ 单调排列。
>
> 其中 $k$ 单调排列我是这么理解的：以 $3,5,2,1,4,6$ 为例：
>
> ![图炸了](https://cdn.luogu.com.cn/upload/image_hosting/dbe0hems.png)
>
> 图中数字经历上升、下降、上升三个过程，称为 $3$ 单调排列。
>
> 数据范围：$1\leq k\leq n\leq 500$

## 思路

这道题需要用 dp 做。为什么用 dp 呢？当然是因为 ~~算法标签里写着“动态规划, dp”咯~~ 此题的数据范围 $n\leq500$，用暴力的话显然是要 T 飞的。既然暴力做不了，那么 ~~自然~~ 就想到 dp 了。

不难想到，可以使用 $dp[i][j]$ 表示 $1∼i$ 的排列中 $j$ 单调序列的个数，则答案即为 $dp[n][m]$。

接下来考虑转移，即在 $1∼i$ 的排列中插入数 $i+1$ 后（显然一共有 $i+1$ 种插入方法），对单调序列的影响。而对于一个 $j$ 单调序列，序列的开始（即第一、二个数）是上升还是下降可能会对转移有一定的影响，于是 $dp$ 数组不妨多开一维，令 $dp[i][j][0]$ 表示序列开始处上升的方案数，$dp[i][j][1]$ 表示序列开始处下降的方案数。

接下来考虑 $dp[i][j][k=0/1]$ 对 $dp[i+1][?][?]$ 的贡献

### 1. $j$ 是偶数，$k=0$

抽象的 Example:

![图炸了](https://cdn.luogu.com.cn/upload/image_hosting/ptdmtu0i.png)

1. 考虑将 $i+1$ 插入到哪里，$j$ 的值不变？答案为两个“峰”的前后，共 $4$ 处位置。一般地，$j$ 单调序列有 $\frac j2$ 个“峰”，每个“峰”前后插入 $i+1$ 都不会使 $j$ 变化，且序列开始处仍保持上升，共 $j$ 处位置，故
$$dp[i+1][j][0]\leftarrow dp[i+1][j][0]+dp[i][j][0]\times j$$

2. 考虑将 $i+1$ 插入到哪里，$j$ 的值会增加 $1$？答案为开头和结尾两处，其中开头处会将序列开始处的上升变为下降，而结尾处的不会。一般地，任意 $j$ 单调序列都会有开头和结尾两处使 $j$ 增加 $1$，且开头处改变序列开始的状态，故
$$dp[i+1][j+1][0]\leftarrow dp[i+1][j+1][0]+dp[i][j][0]\\dp[i+1][j+1][1]\leftarrow dp[i+1][j+1][1]+dp[i][j][0]$$

3. 考虑将 $i+1$ 插入到哪里，$j$ 的值会增加 $2$？显然，将 $i+1$ 插入任意位置，$j$ 的值不可能减少，也不可能增加量 $\geq3$，故除去以上两种，剩下的 $(i+1)-j-2=i-j-1$ 个位置都使 $j$ 增加 $2$，且不会改变序列开始处的上升状态，故
$$dp[i+1][j+2][0]\leftarrow dp[i+1][j+2][0]+dp[i][j][0]\times(i-j-1)$$

### 2. $j$ 是偶数，$k=1$

Yet another 抽象的 Example:

![图炸了](https://cdn.luogu.com.cn/upload/image_hosting/yfmk6hoo.png)

1. 考虑将 $i+1$ 插入到哪里，$j$ 的值不变？答案为“峰”的前后，以及整个序列的头尾，共 $4$ 处位置。一般地，$j$ 单调序列有 $\frac j2-1$ 个“峰”，每个“峰”前后及序列头尾插入 $i+1$ 都不会使 $j$ 变化，且序列开始处仍保持下降，共 $j$ 处位置，故
$$dp[i+1][j][1]\leftarrow dp[i+1][j][1]+dp[i][j][1]\times j$$

2. 考虑将 $i+1$ 插入到哪里，$j$ 的值会增加 $1$？答案为第二个位置和倒数第二个位置，共两处，其中第二个位置会将序列开始处的下降变为上升，而结尾处的不会。一般地，任意 $j$ 单调序列都会有这两处使 $j$ 增加 $1$，且位于开头的一处改变序列开始的状态，故
$$dp[i+1][j+1][0]\leftarrow dp[i+1][j+1][0]+dp[i][j][1]\\dp[i+1][j+1][1]\leftarrow dp[i+1][j+1][1]+dp[i][j][1]$$

3. 考虑将 $i+1$ 插入到哪里，$j$ 的值会增加 $2$？同样地，将 $i+1$ 插入任意位置，$j$ 的值不可能减少，也不可能增加量 $\geq3$，故除去以上两种，剩下的 $(i+1)-j-2=i-j-1$ 个位置都使 $j$ 增加 $2$，且不会改变序列开始处的下降状态，故
$$dp[i+1][j+2][1]\leftarrow dp[i+1][j+2][1]+dp[i][j][1]\times(i-j-1)$$

### 3. $j$ 是奇数，$k=0$

### 4. $j$ 是奇数，$k=1$

类似上面的方法，同样可以得出这两种情况下的转移方程，结果与上面的完全相同。

### 小优化

而此时可以发现，$k=0$ 与 $k=1$ 的转移也完全相同，完全可以合并，不需要第三维状态了，省了一半时间/空间。

好啦，写到这里，该分析的也都分析完了，可以~~快乐地~~写代码啦 \\(^O^)/ 还有，不要忘记模 $123456$ 哦！

## Code (超短！)

```cpp
#include <bits/stdc++.h>
#define mod 123456 // 模数
using namespace std;
int n,m,dp[505][505]; // dp 数组
int main ()
{
    scanf ("%d%d",&n,&m); // 输入
    if (n==1) // 因为 dp 是从 2 开始的，所以 n=1 的情况特判一下
    {
        if (m==1) puts ("1");
        else puts ("0");
        return 0;
    }
    dp[2][1]=2; // 初始值，n=2 时不管是 1,2 还是 2,1 都是 1 单调排列
    for (int i=2;i<n;i++)
        for (int j=1;j<=m;j++)
        {
//            printf ("dp[%d][%d]=%d\n",i,j,dp[i][j]); // 调试用
            dp[i+1][j]=(dp[i+1][j]+dp[i][j]*j)%mod; // 转移
            dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j]*2)%mod;
            dp[i+1][j+2]=(dp[i+1][j+2]+dp[i][j]*(i-j-1))%mod;
        }
    printf ("%d\n",dp[n][m]%mod); // 输出
    return 0;
}
```

---


# [蓝桥杯 2022 省 A] 爬树的甲壳虫

## 题目描述

有一只甲壳虫想要爬上一颗高度为 $n$ 的树，它一开始位于树根, 高度为 $0$，当它尝试从高度 $i-1$ 爬到高度为 $i$ 的位置时有 $P_{i}$ 的概率会掉回树根, 求它从树根爬到树顶时, 经过的时间的期望值是多少。


## 说明/提示

对于 $20 \%$ 的评测用例, $n \leq 2,1 \leq x_{i}<y_{i} \leq 20$;

对于 $50 \%$ 的评测用例, $n \leq 500,1 \leq x_{i}<y_{i} \leq 200$;

对于所有评测用例, $1 \leq n \leq 10^5,1 \leq x_{i}<y_{i} \leq 10^{9}$ 。 

蓝桥杯 2022 省赛 A 组 E 题。

## 样例 #1

### 输入

```
1
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
3
1 2
3 5
7 11```

### 输出

```
623902744```

# 题解

## 作者：Keroshi (赞：25)

# 分析
题目给出了每一层掉回树根和爬高的概率，需求出爬到树顶的期望时间，很明显是一道概率 dp 题。   
首先由于任何情况下甲壳虫都有可能掉回树根，所以正推较难，考虑逆推。   
首先令 $f_i$ 为甲壳虫从 $i$ 到 $n$ 的期望时间，所以边界 $f_n=0$。   
那么就可以推出状态转移方程 $f_i=p_{i+1} f_0+(1-p_{i+1})f_{i+1}+1$。   
但是这个式子里有需要求的答案 $f_0$，所以考虑类似解方程的方法来推出 $f_0$。  
$f_0=(1-p_1)f_1+p_1f_0+1$   
$f_0=(1-p_1)[(1-p_2)f_2+p_2f_0+1]+p_1f_0+1$    
$f_0=(1-p_1)(1-p_2)f_2+(1-p_2)p_1f_0+(1-p_1)+p_1f_0+1$    
$f_0=(1-p_1)(1-p_2)f_2+f_0[(1-p_1)p_2+p_1]+[(1-p_1)+1]$     
依次类推，可以把式子分成三项，那么最后变成这样。    
$f_0=\prod_{i=1}^{n}(1-p_i) f_n+f_0p_i\sum_{i=1}^{n}\prod_{j=1}^{i-1}(1-p_j)+\sum_{i=1}^{n}\prod_{j=1}^{i}(1-p_j)$   
设这三个系数为 $s1$,$s2$,$s3$。   
$f_0=s1f_n+s2f_0+s3$    
这三个系数都能 $O(n)$ 求出。   
因为 $f_n=0$，所以就可以求出答案 $f_0=\frac{s3}{1-s2}$。 
# 代码
代码部分需要注意的是有理数取模的问题，因为模数是质数，所以使用费马小定理求解。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
const int P=998244353;
int n,a[N],b[N];
int fp(int x,int y){ // 快速幂
    int res=1;
    for(;y;y>>=1){
        if(y&1) res=(1ll*res*x)%P;
        x=(1ll*x*x)%P;
    }
    return res;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&a[i],&b[i]);
    int s1=1,s2=0,s3=0;
    for(int i=1;i<=n;i++){ 
        int p1=(1ll*a[i]*fp(b[i],P-2))%P; //费马小定理求出概率
        int p2=(1ll*(b[i]-a[i])*fp(b[i],P-2))%P;
        s3=(s3+s1)%P; // 计算系数
        s2=(s2+1ll*s1*p1)%P;
        s1=(1ll*s1*p2)%P;
    }
    printf("%d",(1ll*s3*fp(1-s2+P,P-2))%P);
    return 0;
}
```

---

## 作者：XAuen1 (赞：15)

先放个[原题链接](https://www.luogu.com.cn/problem/P8774)

# 题目分析

首先，题目主要是考察的是：

- 期望
- 动态规划
- 对分数取余

这个题我做对之后一直没有看到正序求解的题解，所以本人给出正序求解的解法。

------------

先注意，题目中的 $P_i$ 指的是在第 $i$ 格高的时候**摔下去的概率**，而不是成功向上走的概率！

------------

![](https://cdn.luogu.com.cn/upload/image_hosting/n9ch7znw.png)

如图，我们先通过从 $0$ 到 $1$ 开始入手这道题目。我们令 $dp[i]$ 为从 $0$ 开始到达 $i$ 的期望值。

首先我们的初始位置是在 $(0,0)$，目标是 $1$。我们第一次走的时候成功到 $1$ 的概率是 $1-P_1$，到 $(0,1)$ 的概率是 $P_1$，这时再到 $1$ 的概率还是 $1-P_1$，到 $(0,2)$ 的概率还是 $P_1$，以此类推。

我们都知道，初始的期望值为 $0$，也就是（$dp[0]=0$）。然后我们就可以得到如下这些式子。

$$\begin{aligned}dp[1]&=(1-P_1)+P_1\times (2(1-P_1)+P_1\times (3\times (1-P_1)+P_1\times (...)))\\&=(1-P_1)+2\times P_1\times (1-P_1)+3\times {P_1}^2\times (1-P_1)+4\times {P_1}^3\times (1-P_1)+...\end{aligned}$$

接下来错位相减：

$$dp[1]\times P_1=(1-P_1)\times P_1+2\times {P_1}^2\times (1-{P_1})+3\times {P_1}^3\times (1-P_1)+...$$

$$dp[1]-dp[1]\times P_1=(1-P_1)+P_1\times (1-P_1)+{P_1}^2\times (1-P_1)+{P_1}^3\times (1-P_1)+...$$

$$dp[1]\times (1-P_1)=(1-P_1)\times (1+P_1+{P_1}^2+{P_1}^3+...)$$

$$dp[1]=1+P_1+{P_1}^2+{P_1}^3+{P_1}^4+...$$

由等比数列求和公式 $1+x+x^2+x^3+...+x^n=  \frac{x^{n+1}-1}{x-1}  $ 得出 $dp[1]=\frac{P_1^{n+1}-1}{P_1-1}$。

因为 $n$ 无限趋近于 $+ \infty $，所以 ${P_1}^{n+1}$ 无限趋近于 $0$。由此可知 $dp[1]=\frac{1}{1-P_1}$。

这其实是一个结论，就是失败后没有回退的这种期望在该路径上的大小为 $\frac{1}{P}$（$P$ 为成功的概率）。

------------

其实上面主要是铺垫，接下来进入正题。

$$dp[i]=?$$

这里再插入一张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/76m6s3ki.png)

先解释一下，start 位置就是这个运算开始的位置，一开始我们的概率为  $1$，其中成功向上的概率为 $(1-P_i)$，摔落的概率为 $P_i$ 。因为摔落的步数为 $1$，所以每摔落一次都要 $+1$。而我们从 $0$ 重新回到 $i$ 的期望为多少呢？也就是 $dp[i-1]$ 了！再将摔落概率乘以 $dp[i-1]$ ，就得到了以下这些式子。

$$\begin{aligned}dp[i]&=dp[i-1]+(1-P_i)+P_i\times (1+dp[i-1]+(1-P_i)+P_i\times (1+dp[i-1]+(1-P_i)+P_i\times (1+dp[i-1]+(1-P_i)+P_i\times (...))))\\&=dp[i-1]+(1-P_i)+P_i\times (1+dp[i-1]+(1-P_i))+{P_i}^2\times (1+dp[i-1]+(1-P_i))+{P_i}^3\times (1+dp[i-1]+(1-P_i))+{P_i}^4\times (...)\\&=dp[i-1]+(1-P_i)+P_i\times (1+dp[i-1]+(1-P_i))\times (1+{P_i}+{P_i}^2+{P_i}^3+...)\end{aligned}$$

再由上文提到的等比数列求和公式 $1+x+x^2+x^3+...+x^n=  \frac{x^{n+1}-1}{x-1}$，得出：

$$dp[i]=dp[i-1]+(1-P_i)+P_i\times (1+dp[i-1]+(1-P_i))\times \frac{{P_i}^{n+1}-1}{P_i-1}$$

同理，当 $n$ 无限趋近于 $+ \infty $，所以 ${P_i}^{n+1}$ 无限趋近于 $0$。所以：

$$\begin{aligned}dp[i]&=dp[i-1]+(1-P_i)+\frac{P_i(1+dp[i-1]+(1-P_i))}{1-P_i}\\&=dp[i-1]+(1-P_i)+\frac{P_i+P_i\times dp[i-1] + P_i - {P_i}^2}{1-P_i}\\&=dp[i-1]+(1-P_i)+\frac{P_i\times dp[i-1] + 2\times P_i - {P_i}^2}{1-P_i}\\&=\frac{(1-P_i)\times dp[i-1] + (1-P_i)^2+P_i\times dp[i-1] + 2\times P_i - {P_i}^2}{1-P_i}\\&=\frac{dp[i-1] - P_i\times dp[i-1] +1 - 2\times P_i + {P_i}^2+ P_i\times dp[i-1] + 2\times P_i - {P_i}^2}{1-P_i}\\&=\frac{1+dp[i-1]}{1-P_i} \end{aligned}$$

将 $P_i$ 替换成 $\frac{x_i}{y_i}$，得到：

$$\begin{aligned}dp[i]&=\frac{1+dp[i-1]}{1-\frac{x_i}{y_i}}\\&=\frac{1+dp[i-1]}{\frac{y_i-x_i}{y_i}}\\&=\frac{y_i\times (1+dp[i-1])}{y_i-x_i}\end{aligned}$$

终于，我们求出了转移方程。

剩下的问题主要是对分数取余。由于 $Mod=998244353$，是个素数，所以直接使用费马小定理和快速幂解决就行了，这里不再赘述。

# Code Time

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=100010,M=998244353;
int n;
ll dp[N];
ll ksm(ll x,ll y){//快速幂
	ll _ans=1;
	while(y){
		if(y&1){
			_ans*=x;
			_ans%=M;
		}
		x*=x;
		x%=M;
		y>>=1;
	}
	return _ans;
}
ll qy(ll x,ll y){//分数取余
	return x%M*ksm(y,M-2)%M;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		ll x,y;
		cin>>x>>y;
		dp[i]=qy((y*(1+dp[i-1]))%M,y-x);//转移方程
	}
	printf("%lld",dp[n]);
	return 0;
}
```

---

## 作者：0xFF (赞：9)

#### 题目大意


------------
有一只甲壳虫爬一棵高为 $n$ 的树，在 $i$ 层尝试爬到第 $i+1$ 层时，有 $P_i$ 的概率掉回树根，求从树根到顶部的时间的期望。

#### 思路分析


------------
$f_i$ 表示以第 $i$ 层为起点爬到第 $n$ 层的期望。

状态转移方程即为：

$$f_i = (1-p_i)\times f_{i+1} + p_i\times f_0 + 1$$

发现 $f_0$ 其实就是题目要求的答案，从答案推出答案显然是不可行的。

$$f_{i+1} = (1-p_{i+1})\times f_{i+2} + p_{i+1}\times f_0 + 1$$
$$f_i = (1-p_i)\times [(1-p_{i+1})\times f_{i+2} + p_{i+1}\times f_0 + 1] + p_i \times f_0 + 1$$

$$f_i =(1-p_i)\times(1-p_{i+1})f_{i+2} + [(1-p_i)\times p_{i+1}+p_i]\times f_0 + 2 - p_i$$

发现状态转移方程本质上是

$$f_i = p\times f_n + q\times f_0 + t$$

由于 $f_n = 0$，令 $i=0$，上式即为 $f_0 = q\times f_0 + t$

故答案 $f_0 = \dfrac{t}{1-q}$

只需递推求出 $t,q$ 即可。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<climits>
#include<queue>
#include<vector>
#define int long long
using namespace std;
const int INF = 0x3f3f3f3f;
const int mod = 998244353;
const int N = 2e5 + 10;
const int M = 1e5 + 10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
int f[N],g[N],k[N];
int x[N],y[N],p[N];
int qpow(int n,int k){
	int res = 1;
	while(k > 0){
		if(k & 1) res = (res * n) % mod;
		n = (n * n) % mod;
		k >>= 1;
	}
	return res;
}
signed main(){
	int n = read();
	for(int i=0;i<n;i++){
		x[i] = read() , y[i] = read();
		p[i] = (x[i] * qpow(y[i],mod-2)) % mod;
	}
	for(int i=n-1;i>=0;i--){
		f[i] = (f[i+1] * (y[i]-x[i]) % mod * qpow(y[i],mod-2) % mod) % mod;
		k[i] = (k[i+1] * (y[i]-x[i]) % mod * qpow(y[i],mod-2) % mod + 1) % mod;
		f[i] = (f[i] + p[i]) % mod;
	}
	f[0] = (k[0] * qpow(1 - f[0] + mod,mod-2) % mod) % mod;
	cout<<f[0]<<"\n";
	return 0;
}
```


---

## 作者：01bit (赞：7)

假设 $f_i$ 指从 $i$ 到 $n$ 的期望时间，则可以推出：

$f_i=(1-p_{i+1})f_{i+1}+p_{i+1}f_0+1$

从 $i=0$ 考虑，即 $f_0=(1-p_1)f_1+p_1f_0+1$

将 $f_1=(1-p_2)f_2+p_2f_0+1$ 代入到上式，可得 $f_0=(1-p_1)[(1-p_2)f_2+p_2f_0+1]+p_1f_0+1=1+(1-p_1)+(1-p_1)(1-p_2)f_2+[(1-p_1)p_2+p_1]f_0$

以此类推，可得 $f_0=1+(1-p_1)+(1-p_1)(1-p_2)+\cdots+(1-p_1)(1-p_2)(1-p_3)\cdots f_n+[p_1+(1-p_1)p_2+(1-p_1)(1-p_2)p_3+\cdots]f_0$

设 $A=1+(1-p_1)+(1-p_1)(1-p_2)+\cdots,C=p_1+(1-p_1)p_2+(1-p_1)(1-p_2)p_3+\cdots$

由题意得 $f_n=0$

代入可得 $f_0=Cf_0+A$

即 $f_0=\dfrac{A}{1-C}$，直接计算即可

```cpp
#include<cstdio>
using namespace std;
typedef long long ll;
const ll mod=998244353;
ll n;
ll inv(ll x){
	ll z=1,y=mod-2;
	while(y){
		if(y&1)z=z*x%mod;
		x=x*x%mod;
		y=y>>1; 
	}
	return z;
}
ll p[100005];
// A=1+(1-P1)+(1-P1)(1-P2)...
// C=P1+(1-P1)P2+(1-P1)(1-P2)P3...
ll A=0,C=0;
int main(){
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++){
		ll x,y;
		scanf("%lld%lld",&x,&y);
		p[i]=x*inv(y)%mod;
	}
	ll tmp=1;
	for(ll i=1;i<=n;i++){
		A=(A+tmp)%mod;
		C=(C+tmp*p[i]%mod)%mod;
		tmp=tmp*((1+mod-p[i])%mod)%mod;
	}
	printf("%lld\n",A*inv(1+mod-C)%mod);
	return 0;
}
```


---

## 作者：MYJ_aiie (赞：6)

[题目](https://www.luogu.com.cn/problem/P8774)


------------

概率为 $p_i$,那么到达 $i+1$ 的概率为 $1-p_{i+1}$,掉到 $0$ 的概率是 $p_{i+1}$。    
设 $f_i$ 为 $i$ 到 $n$ 的期望,那么 $f_n=0$。  
$f_i$ 的状态转移方程就是：
$f_i=1+(1-p_{i+1})f_{i+1}+p_{i+1}f_0$  
表示 $f_i$ 到 $n$ 期望为：时间 $+$ 到 $i+
1$ 的期望 $+$ 掉到 $0$ 后$f_0$的期望。  

难道代码就是这样吗？并不是。我们观察式子发现求 $f_i$ 时,未知数有 $f_{i+1}$ 和 $f_0$,其中可以通过倒着求得出 $f_{i+1}$,但无法得出 $f_0$。  
所以我们以 $n=3$ 为例,展开前面的式子：  
$f_0=1+(1-p_{1})f_{1}+p_{1}f_0$  
$f_1=1+(1-p_{2})f_{2}+p_{2}f_0$  
$f_2=1+(1-p_{3})f_{3}+p_{3}f_0$    
然后把 $f_1$ 代入 $f_0$：
$f_0=1+(1-p_{1})[1+(1-p_{2})f_{2}+p_{2}f_0]+p_{1}f_0$    
$f_0=1+(1-p_{1})+(1-p_{1})(1-p_{2})f_{2}+[p_{1}+(1-p_1)p_2]f_0$    
这个时候可以找到一个规律：  
$f_0=A+B+C$  
$A=1+(1-p_1)+(1-p1)(1-p_2)+\ldots+(1-p1)(1-p2)\ldots(1-p_{n-1})$  
$C=p_1+(1-p_1)p_2+\ldots+(1-p1)(1-p_2)\ldots(1-p_{n-1})p_n$  
因为 $B$ 乘了 $f_n$ ,而 $f_n$ 为 $0$,所以 $B$ 可以不算。

还需要注意一点,因为题目要求一个分数除以一个素数,所以要用到逆元。

code
---

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int mod=998244353;
const int N=100005;
int n;
long long a[N],b[N],A,C,p[N],p_1[N];
long long ksm(long long x,long long p)
{
	long long res=1;
	while(p)
	{
		if(p&1)
		{
			res=res*x%mod;
		}
		x=x*x%mod;
		p>>=1;
	}
	return res;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&a[i],&b[i]);
		p[i]=a[i]*ksm(b[i],mod-2)%mod;
		p_1[i]=(b[i]-a[i])*ksm(b[i],mod-2)%mod;
	}
	A=1;
	long long k=1;
	for(int i=1;i<n;i++)
	{
		A=(A+p_1[i]*k%mod)%mod;
		k=(p_1[i]*k)%mod;
	}
	k=1;
	for(int i=1;i<=n;i++)
	{
		C=(C+p[i]*k%mod)%mod;
		k=(k*p_1[i])%mod;
	}
	C=(1-C+mod)%mod;
	long long ans=A*ksm(C,mod-2)%mod;
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：kkksc03wzl (赞：5)

设置状态 $f_{i}$ 表示从高度 $i$ 到高度 $n$ 的期望时间，考虑如何转移：
首先从 $i$ 到 $i+1$ 一定需要1的时间，然后如果甲壳虫成功爬上去，其期望为 $(1-P_{i+1})f_{i+1}$  如果掉下来了，其期望为 $P_{i+1}f_{0}$
显然可以得到：  
$f_{i}=1+(1-P_{i+1})f_{i+1}+P_{i+1}f_{0}$  

但是，但是，但是，其中出现了一个我们还不知道的状态：$f_{0}$  
不着急，先枚举一下 $n=3$ 的情况:  
$f_{0}=1+(1-P_{1})f_{1}+P_{1}f_{0}$  
$f_{1}=1+(1-P_{2})f_{2}+P_{2}f_{0}$  
$f_{2}=1+(1-P_{3})f_{3}+P_{3}f_{0}$  
考虑去解决一下它，可以把 $f_{1}$ 带入到$f_{0}$ 中，把 $f_{2}$带入到 $f_{1}$中去又因为 $n=3$ , 所以 $f_{3}=0$
于是，我们得到了一个关于 $f_{0}$的方程：  
$f_{0}=1+(1-P_{1})+(1-P_{1})(1-P_{2})+(P_{1}+(1-P_{1})P_{2}+(1-P_{1})(1-P_{2})P_{3}f_{0}$

然后，就很容易发现规律：
如果  
$f_{0}=A+Cf_{0}$

那么  
$A=1+(1-P_{1})+(1-P_{1})(1- P_{2})+...+(1-P_{1})(1-P_{2})...(1-P_{n-1})$  

$C=P_{1} + P_{2} (1 - P_{1} )+P_{3} (1-P_{2})(1-P_{1})+...+P_{n}(1-P_{n-1})$
于是这道题就很快乐地解决掉了，唯一还要注意的是要求逆元，因为模数是质数，可以直接用费马小定理。

# CODE

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long x[100005],y[100005];
long long mod=998244353;
long long ksm(int x,int y){
	long long ans=1,base=x;
	while(y){
		if(y&1)ans=(ans*base)%mod;
		base=(base*base)%mod;
		y>>=1;
	}return ans;
}long long fs(long long x,long long y){
	return x%mod*ksm(y,mod-2)%mod;
}
int main(){
	int n;
	scanf("%d",&n);
	long long A=0,C=0;
	for(int i=1; i<=n; i++){
		scanf("%d %d",&x[i],&y[i]);
	}long long now=1;
	for(int i=1; i<=n; i++){
		A=(A+now)%mod;
		C=(C+now*fs(x[i],y[i])%mod)%mod;
		now=now*fs(y[i]-x[i],y[i])%mod;
	}
	C=(1-C+mod)%mod;
	printf("%d",fs(A,C));
	return 0;
}
```


---

## 作者：Lord_Sky2048 (赞：5)

题意： 甲壳虫想要爬上高度为 $n$ 的树，开始位于树根，高度为 $0$，当它尝试从高度 $i - 1$ 爬到高度为 $i$ 的位置时有 $Pi$ 的概率会掉回树根，求它从树根爬到树顶时，经过的时间的期望值是多少。

用 $dp_{i - 1}$ 表示从高度 $i - 1$ 出发到顶部花费的期望时间。可以得到如下的状态转移方程：

$dp_{i - 1} = P_i \times dp_{0} + ( 1 - P_i ) \times dp_i + 1$

$dp_n = 0$

展开并维护其系数得：（设 $dp_0$ 系数为 $x$，常数为 $y$ ）

$dp_0=x \times dp_0 + y$

所以求解 $dp_0$ 就相当于求解:

$(x - 1) \times dp_0 + y \equiv 0 \pmod M$

### 总结：主要用到的方法有：高斯逆元与期望DP

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
const int MOD = 998244353;
typedef long long ll;
ll x[maxn], y[maxn];
ll inv(ll x)
{
    return ksm(x, MOD - 2, MOD);
}
ll extgcd(ll a, ll b, ll&x, ll&y)
{
    ll d = a;
    if(b)
    {
       d = extgcd(b, a % b, y, x);
       y -= (a / b) * x;
    }
    else x = 1, y = 0;
    return d;
}
ll ksm(ll a, ll b, ll m)
{
    ll ans = 1;
    while(b)
    {
        if(b & 1)ans = ans * a % m;
        b >>= 1;
        a = a * a % m;
    }
    return ans;
}


int main()
{
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> x[i] >> y[i];
        ll g = __gcd(x[i], y[i]);
        x[i] = x[i] / g;
        y[i] = y[i] / g;
    }
    ll a = 0, b = 0;
    for(int i = n; i >= 1; i--)
    {
        ll p = x[i] * inv(y[i]) % MOD, p_1 = (y[i] - x[i]) * inv(y[i]) % MOD;
        a = (p + p_1 * a) % MOD;
        b = (1 + p_1 * b) % MOD;
    }
    ll c = a - 1, d = MOD, x, y;
    ll g = extgcd(c, d, x, y);
    ll x1 = x * (MOD - b) / g;
    ll y1 = y * (MOD - b) / g;
    cout<<(x1 % MOD + MOD ) % MOD<<endl;
    return 0;
}
```


---

## 作者：makerlife (赞：4)

[更好的阅读体验](https://blog.makerlife.top/post/math-expectation/#P8774-%E7%88%AC%E6%A0%91%E7%9A%84%E7%94%B2%E5%A3%B3%E8%99%AB) | [Problem Link](https://www.luogu.com.cn/problem/P8774)

upd 2024/10/16: 在同机房大佬 @[xixisuper](https://www.luogu.com.cn/user/580107) 的讲解下，更新了更简单的正推做法。

## P8774 爬树的甲壳虫

[Problem Link](https://www.luogu.com.cn/problem/P8774)

### Statement

有一只甲壳虫想要爬上一颗高度为 $n$ 的树，它一开始位于树根，高度为 $0$，当它尝试从高度 $i-1$ 爬到高度为 $i$ 的位置时有 $P_{i}$ 的概率会掉回树根，求它从树根爬到树顶时，每次尝试花费 $1$ 个单位时间，求经过的时间的期望值是多少。

### Solution

正推方法。

设 $f_i$ 表示从根爬到 $i$ 花费时间的期望。

考虑转移，如果尝试成功，可以直接花费 $1$ 单位时间从 $i - 1$ 跳到 $i$，期望为 $(1 - p_{i})\times 1$；如果尝试失败，需要花费 $1$ 单位时间回到根，然后再花 $f_i$ 的时间回到 $i$，期望为 $p_i\times (f_i + 1)$。

容易得到 $f_i = f_{i - 1} + (1 - p_i) + (f_i + 1)\times p_i$。化简后，可以得到下面的方程：

$$
f_i = \frac{f_{i-1} + 1}{1 - p_i} = (f_{i - 1} + 1)\times\frac{y_i}{y_i - x_i}
$$

比倒推简单许多。

---

以下为原倒推做法，不建议阅读。

设 $f_i$ 表示从 $i$ 到树顶 $n$ 所花费时间的期望值。

接下来考虑转移，如果这次尝试成功，其期望为 $(1-p_{i+1})f_{i+1}$。如果这次尝试失败，回到树根，则其期望为 $p_{i+1}f_0$。

转移方程为：

$$
f_i=1+(i-p_{i+1}f_{i+1})+p_{i+1}f_0
$$

观察转移方程，发现其中 $f_0$ 和 $f_{i+1}$ 项是未知的。考虑倒推，可以求出 $f_{i+1}$，但无论如何都无法求 $f_0$，故多写几项寻找规律：

$$
f_0=1+(i-p_1f_1)+p_1f_0\\
f_1=1+(i-p_2f_2)+p_2f_0\\
f_2=1+(i-p_3f_3)+p_3f_0
$$

此时即可直接解方程，进行带入，展开后为：

$$
f_0=1+(1-p_1)+(1-p_1)(1-p_2)f_2+[p_1+(1-p_1)p_2]f_0
$$

因为题意中 $f_n=0$，所以原式化简为：

$$
f_0=1+(1-p_1)+[p_1+(1-p_1)p_2]f_0
$$

将其表示为 $f_0=A+B$ 形式，则可以进行对应：

$$
A=1+(1-p_1)+(1-p_1)(1-p_2)+\cdots+(1-p_1)(1-p_2)\cdots(1-p_{n-1})\\
B=p_1+p_2(1-p_1)+p_3(1-p_1)(1-p_2)+\cdots+p_n(1-p_n)\cdots(1-p_{n-1})
$$

$A, B$ 都可以直接计算，则本题解决。

另外注意到数据要求输出 $\frac{a}{b}\bmod P$ 的结果，需要用到乘法逆元，由于 $P$ 为质数，可以直接通过费马小定理求出。

### Core Code

这是倒推的代码。

```cpp
ll ksm(ll x,ll y) {//快速幂
    ll res=1;
    while(y) {
        if(y&1) res=res*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return res;
}
int main() {
    n=read();
    for(int i=1;i<=n;i++) {
        int a=read(),b=read();
        p1[i]=a*ksm(b,mod-2)%mod;//失败概率
        p2[i]=(b-a)*ksm(b,mod-2)%mod;//成功概率
    }
    A=1;
    ll t=1;
    for(int i=1;i<=n;i++) {
        if(i!=n) A=(A+p2[i]*t%mod)%mod;
        B=(B+p1[i]*t%mod)%mod;
        t=(p2[i]*t)%mod;
    }
    write(A*ksm((1-B+mod)%mod,mod-2)%mod);
    return 0;
}
```

---


# [蓝桥杯 2022 国 B] 搬砖

## 题目描述

这天，小明在搬砖。

他一共有 $n$ 块砖，他发现第 $i$ 砖的重量为 $w_{i}$，价值为 $v_{i}$。他突然想从这些砖中选一些出来从下到上堆成一座塔，并且对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值。

他想知道这样堆成的塔的总价值（即塔中所有砖块的价值和）最大是多少。


## 说明/提示

**【样例说明】**

选择第 $1$、$2$、$4$ 块砖，从上到下按照 $2$、$1$、$4$ 的顺序堆成一座塔，总价值为 $4+1+5=10$。

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，保证 $n \leq 10$;

对于 $100 \%$ 的数据，保证 $n \leq 1000 ; w_{i} \leq 20 ; v_{i} \leq 20000$ 。

蓝桥杯 2022 国赛 B 组 J 题。

## 样例 #1

### 输入

```
5
4 4
1 1
5 2
5 5
4 3```

### 输出

```
10```

# 题解

## 作者：lottle1212 (赞：23)

# [原题传送门](https://www.luogu.com.cn/problem/P8806)
## Part 0
首先浏览题面，当看到数据范围 $n \leq 1000, w_i \leq 20, v_i \leq 20000$ 时，就容易想到 $\text{01}$ 背包做法。但是，为了让砖块的价值总和最大，我们不能直接对其进行 $\text{01}$ 背包，必须先将砖块排序。否则，如果让一块很大的砖先做，较小的砖就无法在此基础上进行转移（原本价值可以直接累加），从而完美避开最优解。

按照什么样的顺序进行排序呢（这一部分本人看了 @王熙文 大佬的题解才明白，但对其中的一些小错误进行更正）？

首先，我们有两块砖 $i, j$，使得 $w_i + v_i \leq w_j + v_j$，我们假设 $i$ 一定排在 $j$ 前，即 $j$ 可以排在前的情况，$i$ 必定能排在前。

设 $W$ 表示排在 $i, j$ 前砖块的质量和。若 $j$ 能排在前，则必须满足：

$$v_j \geq W, v_i \geq W + w_j$$

此时，若将 $i$ 排在前，则必须满足：

$$v_i \geq W, v_j \geq W + w_i$$

由于 $w_j \geq 0$，所以 $v_i \geq W$ 满足。接着，我们将 $v_i \geq W + w_j$ 移项，得：

$$v_i - w_j \geq W$$

然后，将表示 $i, j$ 关系的不等式 $w_i + v_i \leq w_j + v_j$ 也移项，得：

$$v_j - w_i \geq v_i - w_j$$

二者结合，得 $v_j - w_i \geq W$，即 $v_j \geq W + w_i$。由此，便证明了最初的假设。

## Part 1
代码写起来就很容易了。需要注意的是，为方便转移，$\text{01}$ 背包中 $dp_i$ 表示前几块砖重量和为 $i$ 的最大价值。

**AC Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ans, dp[20030];
struct node { int w, v; } a[1010]; //砖块
bool cmp(node pre, node nxt) { return pre.w + pre.v <= nxt.w + nxt.v; } //排序 
int main() {
	cin >> n;
	for (int i = 1; i <= n; ++ i) cin >> a[i].w >> a[i].v;
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; ++ i)
		for (int j = a[i].w + a[i].v; j >= a[i].w; -- j)
			dp[j] = max(dp[j], dp[j - a[i].w] + a[i].v), //01背包 
			ans = max(ans, dp[j]); //求最大 
	cout << ans;
	return 0;
}
```

~~自认为马蜂比较清晰简短，希望大家看得懂，并祝大家 Codeing 愉快。~~

---

## 作者：王熙文 (赞：11)

## 思路

大体思路是用一种方式排序，使得最优解是排序后的序列的一个子序列。然后直接 dp。

先说结论，排序方式：按 $w_i+v_i$ 从小到大排序。

证明：

显然，我们只需要证明，若 $w_x+v_x \le w_y+v_y$，则对于任意 $y$ 可以放在 $x$ 前面的情况，$x$ 都可以放在 $y$ 前面。

设最前的一个前面的重量总和为 $W_1$，$x,y$ 之间的总和为 $W_2$，则我们需要证明的是：

若 $v_y \ge W_1,v_x\ge W_1+w_y+W_2$，则一定有 $v_x\ge W_1,v_y\ge W_1+w_x+W_2$。

首先，因为 $v_x\ge W_1+w_y+W_2$ 且 $w_y+W_2 \ge 0$，所以 $v_x \ge W_1$。

第二个需要证明的就必须用 $w_x+v_x \le w_y+v_y$ 的条件了。因为 $v_x\ge W_1+w_y+W_2$，所以 $W_1+W_2 \le v_x-w_y$。从 $w_x+v_x \le w_y+v_y$ 可以得到 $v_x-w_y \le v_y-w_x$。结合这两个不等式就得到了 $W_1+W_2 \le v_y-w_x$，转化一下即为 $v_y \ge W_1+w_x+W_2$ 了。这样就证明了第二个不等式。

所以这样排序是对的。

dp 部分就比较简单了，设 $dp_{i,j}$ 表示前面 $i$ 个选择重量总和为 $j$ 的情况下，价值的最大值。这样对于每一个 $w_i \le j,j-w_i \le v_i$ 的 $j$ 都更新一下 dp 值即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; int a[1010],b[1010];
int p[1010];
bool cmp(int x,int y)
{
	return a[x]+b[x]<a[y]+b[y];
}
int dp[20010];
int main()
{
	cin>>n;
	for(int i=1; i<=n; ++i) cin>>a[i]>>b[i];
	for(int i=1; i<=n; ++i) p[i]=i;
	sort(p+1,p+n+1,cmp);
	memset(dp,-0x3f,sizeof(dp));
	dp[0]=0;
	for(int j=1; j<=n; ++j)
	{
		for(int k=a[p[j]]+b[p[j]]; k>=a[p[j]]; --k) dp[k]=max(dp[k],dp[k-a[p[j]]]+b[p[j]]);
	}
	int ans=0;
	for(int j=1; j<=2e4; ++j) ans=max(ans,dp[j]);
	cout<<ans;
	return 0;
}
```

---

## 作者：gesong (赞：7)

# 题目意思
有 n 个物品，每个物品两个属性：重量 $w_i$，价值 $v_i$。现在把他堆成一个塔，堆在上面的箱子的重量和一定得小于下面的价值，求这个塔的最大价值。

# 思路
一看到都会想到跑 $n$ 次 01 背包，结果时间复杂度为 $O(n^2v)$，会 TLE。

因此，我们想出更好的方法，我们发现一个性质：$v_i - w_j > v_j - w_i=v_i+w_i>v_j+w_j$ 
  第 $i$ 个箱子放在第 $j$ 个箱子下面就显然更优。所以我们按照这个排序，再跑一次01背包就行了。

时间复杂度：$O(n\log n+n(v+w))$。

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct nord{
	int w,v;
}a[1234567];
int f[1234567];
bool cmp(nord x,nord y){
	return x.w+x.v<y.w+y.v;
}
main(){
	int n;
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i].w>>a[i].v;
	sort(a+1,a+n+1,cmp);
	for (int i=1;i<=n;i++)
		for (int j=min(a[i].w+a[i].v,(int)40000);j>=a[i].w;j--)//这里要注意，不能超过重量+价值的和。
			f[j]=max(f[j],f[j-a[i].w]+a[i].v);
	int ans=0;
	for (int i=0;i<=40000;i++) ans=max(ans,f[i]);
	cout <<ans;	
    return 0;
}
```


---

## 作者：__sunshao321__ (赞：4)

这题其实并不是很难，几乎是裸的背包。

### 题意：
给定 $n$ 块砖块，以及每块砖块的重量 $w$ 和价值 $v$ ，现在要求出堆成塔（题目中有解释）中的总价值，即塔中所有砖块的价值和最大是多少。

### 解法：
按照dp中背包的方法，跑 $n$ 遍 01 背包，但很显然会超时。

这时我们可以发现，如果按照砖块的价值进行排序，只要跑一遍 01 背包就可以了。

### 代码：

```cpp
//本人码风有点丑，勿喷
#include<bits/stdc++.h>
using namespace std;
struct node{
	int w,c;
}a[20005]; 
int f[20005],s,n,c;
bool cmp(node a,node b){
	return a.w+a.c<b.w+b.c;
}
void zop(int wi,int ci){
    for(int i=wi+ci;i>=wi;i--)
        f[i]=max(f[i-wi]+ci,f[i]),c=max(f[i],c);
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i].w>>a[i].c;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        zop(a[i].w,a[i].c);
    }
    cout<<c;
    return 0;
}
```

---

## 作者：0x282e202e2029 (赞：3)

# P8806 [蓝桥杯 2022 国 B] 搬砖 题解

[题目传送门](https://www.luogu.com.cn/problem/P8806)

## 前言

由于同学 [SunnyLi](790285) 在一天之内卷了 $3$ 篇题解，所以干脆也来写几篇。

## 题意

有 $n$ 块砖，第 $i$ 块砖的重量为 $w_i$，价值为 $v_i$。

为讲解需要，下将前 $i$ 块砖的重量和简记为 $W_i$。

从这些砖中选一些出来从下到上堆成一座塔，并且对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值，即 $W_{i - 1} ≤ v_i$。

求堆成的塔中所有砖块的价值和的最大值。

## 思路

显然，$v_i - W_{i - 1}$ 越小，第 $i$ 块砖利用得越充分。

如何使这个值变小呢？

设现有满足条件的一些砖，考虑将第 $i$ 块与第 $i + 1$ 块砖互换。

|  | 交换前 | 交换后 |
| ---- | ---- | ---- |
| 第 $i$ 块砖 | $v_i - W_{i - 1}$ | $v_i - W_{i - 1} - w_{i + 1} ^{\dagger}$ |
| 第 $i + 1$ 块砖 | $v_{i + 1} - W_i ^{\dagger}$ | $v_{i + 1} - W_{i - 1}$ |

注意：标 $^{\dagger}$ 的是同一块砖哦！

因此，最值得的构造是使 $\forall 1 ≤ i ≤ n - 1,w_i + v_i < w_{i + 1} + v_{i + 1}$。在这种情况下，$v_i - w_{i + 1} < v_{i + 1} - w_i$，$v_i - W_{i - 1} - w_{i + 1} < v_{i + 1} - W_i$。

**即：按 $w_i + v_i$ 从小到大排序。**

剩余部分为 0-1 背包，不必多言，但需注意约束条件为 $W_{i - 1} ≤ v_i$。

## AC 代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 1e3 + 5, MAXV = 2e4 + 5;
struct Brick
{
	int w, v;
}b[MAXN];//使用结构体方便排序
int n, dp[MAXV], ans; 
bool cmp(Brick x, Brick y)
{
	return x.w + x.v < y.w + y.v; 
}//排序函数
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) 
	{
		scanf("%d %d", &b[i].w, &b[i].v);
	}
	sort(b + 1, b + n + 1, cmp);
	for (int i = 1; i <= n; i++)
	{
		for (int j = b[i].w + b[i].v; j >= b[i].w; j--)
		{
			dp[j] = max(dp[j], dp[j - b[i].w] + b[i].v);
			ans = max(ans, dp[j]);
		}
	}
	printf("%d", ans);
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/112756511)

---

## 作者：__Ginka__ (赞：2)

### 题目大意

该问题是一个背包问题的变种，给定 $n$ 个砖块，每个砖块有重量 $w$ 和价值 $v$。

目标是通过选择一些砖块填充背包，使得背包中的总价值最大化。砖块的选择是有重量限制的，因此我们需要请出 $dp$ 来求解。

#### 具体思路：
1. $f_i$ 表示当背包容量为 $i$ 时，能够获得的最大价值。
2. 每次选择砖块时，我们需要从背包容量的最大值开始，更新当前容量下的最大价值。
3. 对于每个砖块，假设砖块的重量为 $w$，价值为 $v$，那么状态转移公式为当前 $f_i$ 和当前背包容量减去当前砖块重量后的最优解再加上当前砖块的价值 $v_i$ 两值中取最大，得到更新后的最优解。

我们从背包的最大容量开始更新，这样可以确保每个砖块只被选择一次。

最后只需要遍历 $f$ 数组，找到背包中所有可能重量下的最大价值然后输出即可。


**时间复杂度：**
整个算法的时间复杂度是 $O(n \log n + nV)$。

我认为思路已经解释的很清晰了，代码就不放注释了。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=22333;
int n,c,f[N];
struct node
{
    int w,v;
}a[N];
bool cmp(node x,node y)
{
    return x.w+x.v<y.w+y.v;
}
int main() 
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i].w>>a[i].v;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
        for(int j=a[i].v+a[i].w;j>=a[i].w;j--)
		{
            f[j]=max(f[j],f[j-a[i].w]+a[i].v);
            c=max(c,f[j]);
        }
    cout<<c;
    return 0;
}

```

---

## 作者：small_lemon_qwq (赞：1)

这个题目很容易让人想到 $01$ 背包，但是由于题目的额外条件，直接 $01$ 背包肯定不行。那么我们可以先对数据进行排序然后再进行 $01$ 背包。那么怎么排序呢？

我们假设有两个砖块，编号分别为 $i,j$，如果 $v_j-w_i<v_i-w_j(w_j+v_j>w_i+v_i)$，那么将砖块 $i$ 放在下面肯定比将砖块 $j$ 放在下面要好，因为如果将砖块 $j$ 放在下面，砖块 $j$ 的上面只能再承受 $v_j-w_i$ 的重量（除了砖头 $i$），但是将 $i$ 放在下面，可再承受的重量 $v_i-w_j>v_j-w_i$（除了砖头 $j$），所以将砖头 $i$ 放在下面要更优一些。因此就可以按 $w_i+v_i$ 从小到大排序。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct str{
	int w,v;
}a[1005];
int n,dp[20005],ans;
bool cmp(str x,str y){
	return x.w+x.v<y.w+y.v;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].w>>a[i].v;
	}
	sort(a+1,a+n+1,cmp);
	for (int i=1;i<=n;i++){
		for (int j=a[i].w+a[i].v;j>=a[i].w;j--){
			dp[j]=max(dp[j],dp[j-a[i].w]+a[i].v);
			ans=max(ans,dp[j]);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ainivolAGEM (赞：1)

**前情提要：**[更好的阅读体验。](https://www.luogu.com.cn/blog/tomby-gz-2011/solution-p8806)

## 题目大意

[题目](https://www.luogu.com.cn/problem/P8806)给出 $N$ 个数 $v_i$，它有一个重量 $w_i$，现在要在这 $N$ 个数中选出若干个数从下到上堆起来，每个数上面的所有数的重量加起来不能超过自己本身的 $v_i$，请问堆起来所有数的和最大是多少？

## 题目分析

这个题目很容易让人想到 01 背包，但是由于题目的附加条件，直接 01 背包肯定不行。那么我们可以先对数进行排序然后再进行 01 背包。那么怎么排序呢？

首先我们设两个数的下标为 $i$ 和 $j$ 而且 $i < j$，因为我们得出结论后可以直接使用 `sort`，所以就没必要考虑 $i > j$ 的情况了。

在 $v_i - w_j > v_j - w_i$ 时，明显可得 $v_i + w_i > v_j + w_j$，在这个情况下很明显把第 $i$ 个数放在第 $j$ 个数时方案会更优，所以排序方式其实就是：

$$v_i + w_i < v_j + w_j$$

然后直接 01 背包就行了最后答案就是取最大值。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e3+4;
const int V=2e4+4;
const int inf=0x3f3f3f3f;
ll n,a[N],b[N],id[N];
ll maxn,dp[V];
bool cmp(ll x,ll y){
	return a[x]+b[x]<a[y]+b[y];
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	memset(dp,-inf,sizeof(dp));
	dp[0]=0;
	for(int i=1;i<=n;i++){
		for(int j=a[id[i]]+b[id[i]];j>=a[id[i]];j--){
			dp[j]=max(dp[j],dp[j-a[id[i]]]+b[id[i]]);
		}
	}
	for(int j=1;j<=2e4;j++){
		maxn=max(maxn,dp[j]);
	}
	cout<<maxn;
}
```

---

## 作者：cute_overmind (赞：0)

### 前言
咕值没了来写一下题解。

### 思路
看到数据 $n \leq 1000, w_{i} \leq 20, v_{i} \leq 20000$ 可以想到 $01$ 背包。

但是直接跑的话时间复杂度在 $O(n^2\cdot v)$ 肯定会超时，而且也不满足[题意](https://www.luogu.com.cn/problem/P8806)，所以我们应该按照砖块的价值进行排序。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
const int N = 1e5 + 10;
const int INF = 2147483647;
struct node{
	int w , v;
	void read(){
		cin >> w >> v;
	}
}a[N];
int n , dp[N] , ans;
bool cmp(node x , node y){
	return x.w + x.v < y.w + y.v;
}
signed main()
{
	cin >> n;
	for(int i = 1;i <= n;i++)
		a[i].read();
	sort(a + 1 , a + n + 1 , cmp);
	for(int i = 1;i <= n;i++)
		for(int j = a[i].w + a[i].v;j >= a[i].w;j--){
			dp[j] = max(dp[j] , dp[j - a[i].w] + a[i].v);
			ans = max(ans , dp[j]);
		}
	cout << ans;
	return 0;
}
```

---

## 作者：PartiallyCorrect (赞：0)

第一眼看去，这题好像是和 $01$ 背包类似，所以先写出 $01$ 背包的模版:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 20005;
int f[N];
struct node
{
	int w, v;
	void input()
	{
		cin >> w >> v;
	}
}a[N];
int main()
{
	int n, m;
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i ++)a[i].input();
	for(int i = 1 ; i <= n ; i ++)
		for(int j = m ; j >= a[i].w ; j --)
		{
			f[j] = max(f[j], f[j - a[i].w] + a[i].v);
		}
	cout << f[j];
    return 0;
}
```

然后我们会发现，代码中的 $m$ 题目中没有告诉我们，因为上面所以物品的质量不能超过当前这一块的价值，每一次的 $m$ 就是 $w_{i}$ ，但是因为在递推的过程中有  $j-w_{i}$，所以 $m=v_{i}+w_{i}$ ,因为我们从小到大递推，所以我们将 $v_{i}$ 和 $w_{i}$ 放到一个结构体中，按 $w_{i}+v_{i}$ 从小到大排序。完整代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 20005;
int f[N];
struct node
{
	int w, v;
	void input()
	{
		cin >> w >> v;
	}
}a[N];
bool cmp(node x, node y)
{
	return x.w + x.v < y.w + y.v;
}
int main()
{
	int n;
	cin >> n;
	int ans = 0;
	for(int i = 1 ; i <= n ; i ++)a[i].input();
	sort(a + 1, a + n + 1, cmp);
	for(int i = 1 ; i <= n ; i ++)
		for(int j = a[i].v + a[i].w ; j >= a[i].w ; j --)
		{
			f[j] = max(f[j], f[j - a[i].w] + a[i].v);
			ans = max(ans, f[j]);
		}
	cout << ans;
    return 0;
}
```

---

## 作者：hyl_____ (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P8806)

一道非常~~简单~~难做的绿题。


---


### 一、思路
首先就是审题，一看到价值和重量，我第一时间就想到 01 背包问题，脑袋一热，直接交了个模版代码。

```cpp
#include<bits/stdc++.h>  
using namespace std;  
int f[1000];
int w[1000],v[1000];
int main()  
{  
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>w[i]>>v[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=w[i];j--)
		{
			f[j]=max(f[j],f[j-w[i]]+v[i]); 
		}
	}
	cout<<f[n];
        return 0;  
}  
```
然后听取 WA 声一片。

再次审题，发现
> 并且对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值。

咕，当场石化。

原本想要跑 $N$ 次 01 背包，但 TLE 了，~~就无语~~。

既然如此，那么我们可以将其排个序，使小明先放一些后放一些不就完美解决了吗？

按照什么顺序来排呢？

设两砖头名称为 $A$，$B$，重量为 $weight$，
价值为 $value$。

那么可得

$$weight_A-value_B\leq weight_B-value_A$$

移项得

$$weight_A+value_A\leq weight_B+value_B$$

所以按照以上顺序排序即可。

### AC CODE

```cpp
#include<bits/stdc++.h>  
using namespace std;  
int f[100010];
struct brick//结构体 
{
	int weight;// 重量 
	int value;// 价值 
}brick_[100010];//开大点，好习惯 
bool cmp(brick a,brick b)
{
	if(a.weight+a.value<=b.weight+b.value) return true;
	return false;
}//排序 
int main()  
{  
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>brick_[i].weight>>brick_[i].value;
	}
	int maxn=-1;//最大值 
	sort(brick_,brick_+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		for(int j=brick_[i].value+brick_[i].weight;j>=brick_[i].weight;j--)
		{
			f[j]=max(f[j],f[j-brick_[i].weight]+brick_[i].value);
			maxn=max(f[j],maxn); 
		}
	}
	cout<<maxn;
    return 0;//华丽结束 
}  
```

---

## 作者：JXkcy (赞：0)

## 看题意，明确思路

[题目传送门](https://www.luogu.com.cn/problem/P8806)

~~说实话刚开始没读懂题~~

有 $ n $ 块砖，每一块有两个值 $ w_i $ 和 $ v_i $，分别表示其重量和价值。

看到质量和价值两个名词，当然要想到背包问题了。

但是这个题目的难点在于：咱不知道怎么排序。

不过咱可以从 DP 部分讲起。

DP 不会的话写不出来这道题的，贴个 01 背包的板子吧：
```cpp
    cin >> n >> W;//数据个数和背包容量
    for (int i = 1; i <= n; i++) cin >> w[i] >> v[i];
    for (int i = 1; i <= n; i++)
        for (int l = W; l >= w[i]; l--)
            if (f[l - w[i]] + v[i] > f[l]) f[l] = f[l - w[i]] + v[i];  // 状态方程
    cout << f[W];
    return 0;
}
```
然而这道题没有背包容量，即 $ W_{max} $，但我们可以将 $ W_{max} $ 看作当前背包的最大容量，也就是这个变量独属于这个状态。

什么意思呢？

我们的背包这样写：
```cpp
for(int i = 1;i <= n;i ++)
    for(int j = /*?当前背包的最大容量?*/;j >= a[i].weight;j --){
        dp[j] = max(dp[j],dp[j - a[i].weight] + a[i].value);
    }
```
## 怎么排序？

似乎模拟一遍样例你就会了这道题。

~~因为我就是这么来的，还明白了题目是什么意思~~

我是对着题目这句话看了好几分钟啊：

对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值。

于是顿悟：我们设上面 $ i $ 块砖的重量和为 $ W_{i} $。

#### 提醒：注意区分 $ W $ 和 $ w $！

第 $ i $ 块砖上面所有砖的重量和不能超过它自身的价值，即：$ W _ {i-1} \le v_{i} $。

不难发现 $ v _ {i} -  W _ {i-1} $ 越小越好。

然后得知：我们需要满足：
$$ v _ {i} - W _ {i-1} - w _ {i+1} < v _ {i+1} - W _ {i} $$

还需要：
$$ v _ {i} - w _ {i-1} < v _ {i+1} - W _ {i} $$

最终是得到了排序的方法：

即 $ v _ {i} + w _ {i} < v _ {i+1} + w _ {i+1} $。
## 完整的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,dp[20001],ans=0;
struct zhuan{//结构体适合排序
	int value,weight;
}a[1001];
bool cmp(zhuan x,zhuan y){//核心cmp
	return ((x.value + x.weight) < (y.value + y.weight));
}
int main(){
	ios::sync_with_stdio(false);//快读可省略
	cin.tie(0);cout.tie(0);//同上
	cin >> n;
	for(int i = 1;i <= n;i ++)
		cin >> a[i].weight >> a[i].value;
	sort(a + 1,a + n + 1,cmp);
	for(int i = 1;i <= n;i ++)
		for(int j = a[i].weight + a[i].value;j >= a[i].weight;j --){
			dp[j] = max(dp[j],dp[j - a[i].weight] + a[i].value);//01背包 
			ans = max(ans,dp[j]); //注意这个存最大值的ans
		}
	cout << ans;
	return 0;
}
```

---

## 作者：Laisira (赞：0)

### 题面
一堆砖，每个有重 $w_i$、美观值 $v_i$，选一些叠起来使对于砖 $i$ 都有上面的总重不大于 $v_i$，最大化总美观值。

### 思路
显然，当我们知道要哪些数先选，哪些后选就可以直接 $dp$。于是按 $w_i+v_i$ 的顺序排（有两位大佬已经证了，我就不再赘述了），设 $f_{i,j}$ 为搜到 $i$ 时得出的（可能包括 $i$）的总重是 $j$，转移是：
- 先将 $f_{i,j}$ 全部赋值成 $f_{i-1,j}$。

- 然后 $f_{i,j+w_i}=\max(f_{i,j+w_i},f_{i-1,j}+v_i)$。

转移很简单，再加个滚动数组优化空间就没了。

### 代码
```cpp
#include<bits/stdc++.h>
#define Maxn 1005 
using namespace std;
int w[Maxn],v[Maxn],res[Maxn];
int f[2][Maxn*20];
bool cmp(int it,int is) {
    return w[it]+v[it]<w[is]+v[is];
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n;
    cin>>n;
    for(int i=0;i<2;i++) {
        f[i][0]=0;
        for(int j=1;j<=20000;j++)
            f[i][j]=-INT_MAX;
    }
    for(int i=1;i<=n;i++)
        cin>>w[i]>>v[i],res[i]=i;
    sort(res+1,res+1+n,cmp);
    for(int i=1;i<=n;i++) {
        for(int j=0;j<=20000;j++)
            f[(i&1)][j]=f[(!(i&1))][j];
        for(int j=0;j<=v[res[i]];j++)
            f[(i&1)][j+w[res[i]]]=max(f[(i&1)][j+w[res[i]]],f[(!(i&1))][j]+v[res[i]]);
    }
    int maxn = 0;
    for(int i=0;i<=20000;i++)
        maxn = max(maxn,f[n&1][i]);
    cout<<maxn;
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# P8806 [蓝桥杯 2022 国 B] 搬砖 题解

[题面](https://www.luogu.com.cn/problem/P8806)

## 思路

1. 看到题目当中的重量和价值就可以想到这道题要用 dp。
2. 但是因为题目中说 “对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值。”所以我们没有办法直接对砖转移。
3. 所以我们需要对砖进行排序，对于两块砖 $i,j (i<j)$ 如果 $w_i+v_i \le w_j+v_j$。
4. 然后我们就可以通过背包求解。

## code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
//#define double long double
#define il inline
#define endl '\n'
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
#define abs(x) (x<0?-x:x)
#define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

const int maxn=20001;
int n,dp[maxn];
struct Node
{
	int w,v;
}a[maxn];

bool cmp(Node _a,Node _b)
{
	return _a.w+_a.v<_b.w+_b.v;
}

signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].w>>a[i].v;
		dp[i]=-1e18;
	}
	sort(a+1,a+n+1,cmp);
	dp[0]=0;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=a[i].v+a[i].w;j>=a[i].w;j--)
		{
			dp[j]=max(dp[j],dp[j-a[i].w]+a[i].v);
			ans=max(ans,dp[j]);
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---


# [蓝桥杯 2022 国 C] 数组个数

## 题目描述

  小蓝有一个长度为 $n$ 的数组 $B = (b_0,b_1,\cdots,b_{n−1})$，数组 $B$ 是由另一个长度为 $n$ 的环形数组 $A = (a_0,a_1,\cdots,a_{n−1})$ 经过一次相邻最大化操作得到的，其中 $a_i$ 与 $a_{i+1}$ 相邻，$a_0$ 与 $a_{n−1}$ 相邻。

形式化描述为：

$$
b_i=
\begin{cases}
\max\{a_{n-1},a_0,a_1\}& i=0\\
\max\{a_{i-1},a_i,a_{i+1}\}& 0<i<n-1\\
\max\{a_{n-2},a_{n-1},a_0\}& i=n-1\\
\end{cases}
$$

小蓝想知道，可能有多少个满足条件的数组 $A$，经过一次相邻最大化操作后能得到数组 $B$，注意 $A$ 中的每个元素都要求为非负整数。

## 说明/提示

**【样例说明】**

可能的 $A$ 数组有 $7$ 个 ：$(6,0,0,1,8)$、$(6,0,1,0,8)$、$(6,0,1,1,8)$、$(6,1,0,0,8)$、$(6,1,0,1,8)$、$(6,1,1,0,8)$、$(6,1,1,1,8)$。

【评测用例规模与约定】

对于 $30\%$ 的评测用例，$3≤n≤10$；

对于 $60\%$ 的评测用例，$3≤n≤100$；

对于所有评测用例，$3 ≤ n ≤ 1000$，$0 ≤ b_i ≤ 10$。

蓝桥杯 2022 国赛 C 组 G 题。

## 样例 #1

### 输入

```
5
8 6 1 8 8```

### 输出

```
7```

# 题解

## 作者：zxh_mc (赞：12)

思路比较简单的一道题。

用的五维 dp，看到二维和三维的 dp 直接膜了 orz。

正文开始。

## 分析

不难看出 dp。

因为 $b_i$ 的值只与 $a_{i-1},a_i,a_{i+1}$ 有关，所以我们定义 **$b_i$ 被 $a_{c_1},a_{c_2},...a_{c_p}$ 满足为在这些 $a$ 中最大的一项恰好为 $b_i$。**

用 $dp_{i,j,0/1,0/1,z}$ 来表示此状态下的方案数。

其中：

- $i$ 表示当前处于第 $i$ 项。
- $j$ 表示当前这一项选择 $j$。
- $1/0$ 表示 $b_i$ 是否被 $a_{i-1},a_i$ 满足。
- $1/0$ 表示 $b_0$ 是否被 $a_0,a_1$ 满足。
- $z$ 表示 $a_0$ 选择 $z$。

显然，$a_i$ 的最大值就是 $\min(b_{i-1},b_i,b_{i+1})$，又因为 $b_i\le10$，所以 $a_i$ 的最大值也是 $10$。

状态转移方程比较复杂。

如果 $i>1$，那么我们需要枚举 $a_i$ 和 $a_{i-1}$。

这时候存在两种情况：

1. $b_i$ 被 $a_i,a_{i-1}$ 满足，此时应该更新 $dp_{..,..,1,..,..}$ 的值。
2. $b_i$ 不被 $a_i,a_{i-1}$ 满足，此时应该更新 $dp_{..,..,0,..,..}$ 的值。

注意：在选择 $a_i$ 的时候，$b_{i-1}$ 必须被 $a_{i-2},a_{i-1},a_i$ 满足，原因显然。

但当 $i=1$ 时，应该单独讨论，因为 $a_1$ 的选择会影响到 dp 数组的第 $4$  项，而 $i\ge2$ 则不会。思路跟 $i\ge2$ 的情况类似，不再赘述。

最后统计答案时，我们有几种情况：

- $dp_{n-1,x,1,1,y}$，因为此时 $b_{n-1}$ 和 $b_0$ 已经被满足，而其它的 $b$ 也都被满足，直接加上即可。
- $dp_{n-1,x,0,1,y}$ 当 $b_{n-1}\le y$ 时可以相加，因为 $a$ 数组是环形的。
- $dp_{n-1,x,1,0,y}$ 当 $b_0\le x$ 时可以相加，原因同上。

最后，记得取模。

## AC Code

~~臭长臭长的代码 qwq。~~

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
const int MOD = 1e9 + 7;

int n;
int dp[N][11][2][2][11], b[N], am[N];
int st;

inline int nxt (int idx) {
	return ((idx + 1) % n);
}

inline int pre (int idx) {
	return ((idx - 1 + n) % n);
}

int m (int x) {
	if (x < MOD) return x;
	return x - MOD;
}

int main () {
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
	cin >> n;
	for (int i = 0;i < n;i++) cin >> b[i];
	for (int i = 0;i < n;i++) am[i] = min(b[pre(i)], min(b[i], b[nxt(i)]));
	for (int i = 0;i <= am[0];i++) if (i < b[0]) dp[0][i][0][0][i] = 1; else dp[0][i][1][1][i] = 1;
	for (int x = 0;x <= am[0];x++) for (int st = 0;st <= 1;st++) for (int j = 0;j <= am[1];j++) {
		if (j < b[1] && x < b[1]) {
			if (j < b[0]) dp[1][j][0][st][x] += m(dp[0][x][0][st][x] + dp[0][x][1][st][x]), dp[1][j][0][st][x] = m(dp[1][j][0][st][x]);
			else dp[1][j][0][1][x] += m(dp[0][x][0][st][x] + dp[0][x][1][st][x]), dp[1][j][0][1][x] = m(dp[1][j][0][1][x]);
		}
		else {
			if (j < b[0]) dp[1][j][1][st][x] += m(dp[0][x][0][st][x] + dp[0][x][1][st][x]), dp[1][j][1][st][x] = m(dp[1][j][1][st][x]);
			else dp[1][j][1][1][x] += m(dp[0][x][0][st][x] + dp[0][x][1][st][x]), dp[1][j][1][1][x] = m(dp[1][j][1][1][x]);
		}
	}
	for (int i = 2;i < n;i++) {
		int p = i - 1;
		for (int x = 0;x <= am[0];x++) for (int st = 0;st <= 1;st++) {
			for (int j = 0;j <= am[i];j++) {
				for (int z = 0;z <= am[p];z++) {
					if (j < b[i] && z < b[i]) {
						if (j < b[p]) dp[i][j][0][st][x] += dp[p][z][1][st][x];else dp[i][j][0][st][x] += m(dp[p][z][0][st][x] + dp[p][z][1][st][x]);
						dp[i][j][0][st][x] = m(dp[i][j][0][st][x]);
					}
					else {
						if (j < b[p]) dp[i][j][1][st][x] += dp[p][z][1][st][x];
						else dp[i][j][1][st][x] += m(dp[p][z][0][st][x] + dp[p][z][1][st][x]);
						dp[i][j][1][st][x] = m(dp[i][j][1][st][x]);
					}
				}
			}
		}
	}
	int ans = 0;
	for (int x = 0;x <= am[0];x++) for (int i = 0;i <= am[n - 1];i++) {
		ans += dp[n - 1][i][1][1][x]; ans = m(ans);
		if (i >= b[0]) ans += dp[n - 1][i][1][0][x];
		if (x >= b[n - 1]) ans += dp[n - 1][i][0][1][x];
		ans = m(ans);
	}
	cout << ans << endl;
	return 0;
} 
```


---

## 作者：xxseven (赞：2)

提供一篇非常暴力，但非常好想的 $O(nV^5)$ 三维 DP 题解。

发现环这种情况很难搞，考虑如何去掉环的影响。

发现序列尾最多只会用到序列头的两个元素，那么枚举这两个元素，做 $V^2$ 次 DP 即可。

然后，我们设 $dp_{i,j,k}$ 为考虑序列的前 $i$ 个数，最后两个数为 $j,k$，满足 $b_2$ 到 $b_{i-1}$ 限制的方案数。

转移十分简单，三重循环枚举 $a_{i-2},a_{i-1},a_i$ 这三个元素，如果满足了 $b_{i-1}$ 的限制那么即可转移。

最后，在 $dp_{n,i,j}$ 里面找答案，如果 $i,j$ 能与我们枚举的前两个数一起，满足 $b_1$ 和 $b_n$ 的限制，那么即可统计入答案。

枚举前两个数复杂度 $O(V^2)$，单次 DP 复杂度 $O(nV^3)$，总复杂度为 $O(n V^5)$。由于全都是简单的循环枚举，常数较小，可以通过此题。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005,M=12,P=1e9+7;
int n,ans,b[N],dp[N][M][M];
void DP(int x,int y){
	memset(dp,0,sizeof(dp));
	dp[2][x][y]=1; 
	for(int i=3;i<=n;++i){
		int lim=b[i-1];
		for(int j=0;j<=lim;++j){
			for(int k=0;k<=lim;++k){
				for(int f=0;f<=lim;++f){
					if(max(max(j,k),f)!=lim) continue;//枚举三个数，满足限制时可转移
					dp[i][j][k]+=dp[i-1][f][j];
					dp[i][j][k]%=P;
				}
			}
		}
	}
	for(int i=0;i<=10;++i){
		for(int j=0;j<=10;++j){
			if(max(max(i,j),x)==b[n]&&max(max(j,x),y)==b[1])
				ans=(ans+dp[n][i][j])%P;//如果满足头尾限制，更新答案
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;++i) cin>>b[i];
	for(int i=0;i<=10;++i) {
		for(int j=0;j<=10;++j){
			DP(i,j); //枚举前两个数DP
		}	
	}
	cout<<ans;
	return 0;
}

```

希望这篇题解能够帮到你！

---


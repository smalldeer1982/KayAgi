# [蓝桥杯 2018 国 B] 搭积木

## 题目描述

小明对搭积木非常感兴趣。他的积木都是同样大小的正立方体。

在搭积木时，小明选取 $m$ 块积木作为地基，将他们在桌子上一字排开，中间不留空隙，并称其为第 $0$ 层。

随后，小明可以在上面摆放第 $1$ 层，第 $2$ 层，……，最多摆放至第 $n$ 层。摆放积木必须遵循三条规则：

规则 $1$：每块积木必须紧挨着放置在某一块积木的正上方，与其下一层的积木对齐；

规则 $2$：同一层中的积木必须连续摆放，中间不能留有空隙；

规则 $3$：小明不喜欢的位置不能放置积木。

其中，小明不喜欢的位置都被标在了图纸上。图纸共有 $n$ 行，从下至上的每一行分别对应积木的第 $1$ 层至第 $n$ 层。每一行都有 $m$ 个字符，字符可能是 `.` 或 `X`，其中 `X` 表示这个位置是小明不喜欢的。

现在，小明想要知道，共有多少种放置积木的方案。他找到了参加蓝桥杯的你来帮他计算这个答案。

由于这个答案可能很大，你只需要回答这个答案对 $1000000007(10^9+7)$ 取模后的结果。

注意：地基上什么都不放，也算作是方案之一种。

## 说明/提示

**【样例解释】**

成功的摆放有（其中O表示放置积木）：

```
 1       2       3       4
..X     ..X     O.X     ..X
.X.     OX.     OX.     .XO
```

**【数据约定】**

对于 $10\%$ 的数据，$n=1$，$m \le 30$；

对于 $40\%$ 的数据，$n \le 10$，$m \le 30$；

对于 $100\%$ 的数据，$n \le 100$，$m \le 100$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
2 3
..X
.X.```

### 输出

```
4```

# 题解

## 作者：zhlzt (赞：22)

### 题目
- 有一个 $n\times m$ 的图纸，从下往上搭积木。
- 每块积木必须紧挨着放置在某一块积木的正上方，最底层除外。
- 同一层中的积木必须连续摆放，标有 `X` 的位置不能放置积木。
- $1\le n,m\le 100$。

### 二维前缀和+区间 DP 做法
设 $dp_{i,l,r}$ 表示从上往下数的第 $i$ 层在区间 $[l,r]$ 内放置积木且以这一层为搭的积木的顶端的方案数，只要满足区间 $[l,r]$ 内没有 `X` ，就不难得出以下状态转移方程（代码中要用二维前缀和优化）：
$$dp_{i,l,r}=\sum_{j=1}^{l}\sum_{k=r}^{m}dp_{i+1,j,k}$$
设答案为 $ans$。先枚举搭的积木的顶端是哪一层，再枚举这一层在哪个区间内放置积木，对 $dp$ 数组进行求和，加上一个积木都不摆放的方案数 $1$，得出：
$$ans=1+\sum_{i=1}^{n}\sum_{l=1}^{m}\sum_{r=l}^{m}dp_{i,l,r}$$
初始化就是给从上往下数的第 $n$ 层即最底层所有内部没有 `X` 的区间 $[l,r]$ 对应的 $dp_{n,l,r}$ 赋初始值 $1$。

代码时间复杂度为 $O(nm^2)$，不会时间超限。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int num[110][110];char s[110];
long long dp[110][110][110],sum[110][110];
int main(){
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		for(int j=1;j<=m;j++)
			num[i][j]=num[i][j-1]+(s[j]=='X');//用前缀和来记录区间内是否有 X
	}
	long long ans=1;//一个积木都不摆放的方案数
	for(int l=1;l<=m;l++)
		for(int r=l;r<=m;r++){
			dp[n][l][r]=(num[n][r]-num[n][l-1]==0);
			ans=(ans+dp[n][l][r])%mod;//注意初始值也要加到 ans 上
		}
	for(int i=n-1;i>=1;i--){
		for(int l=1;l<=m;l++)
			for(int r=1;r<=m;r++)
				sum[l][r]=(dp[i+1][l][r]+sum[l][r-1]+sum[l-1][r]-sum[l-1][r-1])%mod;//用前缀和预处理来优化时间复杂度
		for(int l=1;l<=m;l++)
			for(int r=l;r<=m;r++) if(num[i][r]-num[i][l-1]==0){
				dp[i][l][r]=(sum[l][m]-sum[0][m]-sum[l][r-1]+sum[0][r-1])%mod;
				ans=(ans+dp[i][l][r])%mod;
			}
	}
	printf("%lld",(ans+mod)%mod);//由于上面加加减减又要取余，可能出现负数，所以是 (ans+mod)%mod 而不是 ans
	return 0;
}
```

---

## 作者：DreamLand_zcb (赞：20)

## 简要题意

给定 $n \times m$ 的地图，从下往上搭积木，搭的积木要满足以下几个条件：

1. 对于任意一层非顶层的积木，它一定包含它上面的一层，也就是这一层一定会完全托住上一层；

2. 同一层中的积木必须连续摆放；

3. 标有 `X` 的地方不能摆积木。

求出一共有几种摆法合法。

## 思路

设动规数组 $dp[i][j][k]$ 表示在在摆第 $i$ 层时在区间 $[j, k]$ 摆放积木有几种情况。

**判断合法：** 考虑输入时可以不直接使二维数组来存 `.` 和 `X`，而是用前缀和储存**当前这一层**的 `X` 个数：

```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=m;j++)
	{
		char c;
		cin >> c;
		a[i][j] = a[i][j-1] + (c == 'X');
	}
}
```

判断的时候直接判断 $a[i][k] - a[i][j-1]$ 是否为零，如果不是就 `continue` 可以实现 $\Theta(1)$ 查询。

**初始化：** 最下面一层所有合法的区间都是 $1$。

**答案：** 所有 $dp[i][j][k]$ 之和，也就是 $\sum dp[i][j][k]$。

**状态转移：** 把第 $i + 1$ 层的所有合法的 $dp[i+1][j][k]$ 都加到 $dp[i][j][k]$ 上，也就是：

$$f[i][j][k] = \sum _{1 \le x \le j \le k \le y \le m} dp[i+1][x][y]$$

什么意思呢？就是吧所有能托住第 $i$ 层这几个积木的第 $i + 1$ 层的所有情况加起来。

暴力枚举后时间复杂度 $\Theta(nm^4)$ 显然会超时。

**优化：** 考虑使用前缀和优化，可以发现：

$$\sum _{1 \le x \le j \le k \le y \le m} dp[i+1][x][y]$$

$$ = \sum _{x = 1} ^{j} \sum_{y = k} ^{m} dp[i+1][x][y]$$

怎么样，是不是很熟悉，这个就是求以 $(1, k)$ 为左上角 $(j, m)$ 为右上角的矩阵前缀和！

也就是我们可以在每次对 $i$ 的枚举过程中，用 $\Theta(m^2)$ 的代价预处理前缀和，然后就可以用 $\Theta(1)$ 的复杂度赋值。

最终时间复杂度 $\Theta(nm^2)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

const int MOD = 1e9 + 7;
int n, m;
ll a[105][105];
ll s[105][105];
ll dp[105][105][105];
ll ans = 1;
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char c;
			cin >> c;
			a[i][j] = a[i][j-1] + (c == 'X');
		}
	}
    for(int i=1;i<=m;i++)//初始化
    {
    	for(int j=i;j<=m;j++)
    	{
    		if(a[n][j] - a[n][i-1] != 0)	continue;
    		dp[n][i][j] = 1;
		}
	}
	for(int i=n;i>=1;i--)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=j;k<=m;k++)
			{
				if(a[i][k] - a[i][j-1] != 0)	continue;
				dp[i][j][k] += (s[j][m] - s[0][m] - s[j][k-1] + s[0][k-1]) % MOD;
				dp[i][j][k] %= MOD;
				ans += (dp[i][j][k]) % MOD;
				ans %= MOD;
			}
		}
		for(int j=1;j<=m;j++)//预处理前缀和
		{
			for(int k=1;k<=m;k++)
			{
				s[j][k] = (s[j-1][k] + s[j][k-1] - s[j-1][k-1] + dp[i][j][k]) % MOD;
				s[j][k] %= MOD;
			}
		}
	}
	cout << (ans + MOD) % MOD;
	return 0;
}
```

# $\color{red}\text{PS：一定要开 long long 而且能取模的一定要取模！！！！}$

别问我怎么知道的

---

## 作者：wuhan1234 (赞：16)

## 1. 编程思路。

采用 DP 进行求解。

设 $dp_{i,a,b}$ 表示第 $i$ 层中从位置 $a$ 至位置 $b$ 连续放置积木的方案数。

由于第 $i$ 层的积木是放在第 $i-1$ 层的上面，因此在第 $i$ 层的位置区间 $[a,b]$ 上放置连续的积木，可以采用第 $i-1$ 层下列区间作为地基：$[1,b]$、$[1,b+1]$、……、$[1,m]$、$[2,b]$、……、$[2,m]$、……、$[a-1,b]$、……、$[a-1,m]$、$[a,b]$、$[a,b+1]$、……、$[a,m]$。

因此，$dp_{i,a,b}=dp_{i-1,1,b}+...+dp_{i-1,1,m}+...+dp_{i-1,a-1,b}+...+dp_{i-1,a-1,m}+dp_{i-1,a,b}+dp_{i-1,a,b+1}+...+dp_{i-1,a,m}$

$$
dp_{i,a,b}=\sum_{l=1}^a \sum_{r=b}^m dp_{i-1,l,r} $$

同理，

$$
dp_{i,a,b+1}=\sum_{l=1}^a \sum_{r=b+1}^m dp_{i-1,l,r} $$
$$
dp_{i,a-1,b}=\sum_{l=1}^{a-1} \sum_{r=b}^m dp_{i-1,l,r} $$
$$
dp_{i,a-1,b+1}=\sum_{l=1}^{a-1} \sum_{r=b+1}^m dp_{i-1,l,r} $$

由此可得，$dp_{i,a,b}=dp_{i-1,a,b}+dp_{i,a,b+1}+dp_{i,a-1,b}-dp_{i,a-1,b+1}$。

特别注意，上式的右边，除了 $dp_{i-1,a,b}$ 是采用上一层的值外，其余的 $3$ 项是采用当前层的值。也就是说，计算当前层区间 $[a,b]$ 的方案数时，先计算出当前层区间 $[a-1,b]$、$[a,b+1]$ 和 $[a-1,b+1]$ 的方案数，再用它们的值来计算当前层区间 $[a,b]$ 的方案数。

从一般的角度来看上面这个式子，有点难以置信。一般都是大区间包含其内小区间的，也就是说大区间的方案数是比其内的小区间的方案数多。但在这个式子中，小区间包括大区间，其方案数可能比大区间多。为什么这样呢？其实也好理解。

因为本题中，上层的位置区间是以下层的区间作为地基的。上层的区间越小，下层可以作为其地基的区间会越多。

例如，设 $m=5$，且暂不考虑不喜欢的位置。则上层的区间 $[1,5]$，在下层只有一个区间 $[1,5]$ 可以作为其地基；而上层的区间 $[1,3]$，在下层有 $[1,3]$、$[1,4]$ 和 $[1,5]$ 这 $3$ 个区间作为其地基；而 $[2,2]$ 则可以有 $[1,2]$、$[1,3]$、$[1,4]$、$[1,5]$、$[2,2]$、$[2,3]$、$[2,4]$ 和 $[2,5]$ 这样的 $8$ 个区间作为其地基。显然，区间越小，其地基向两边延伸的可能性越多，方案数也就越多。

由于第 $i$ 层只与作为其直接地基的第 $i-1$ 层相关，因此，上式中表示层的维度可以去掉。

定义 $dp_{a,b}$ 表示在当前层的位置区间 $[a,b]$ 上放置连续的积木块的方案数。状态转移方程为：

$dp_{a,b}=dp_{a,b}+dp_{a,b+1}+dp_{a-1,b}-dp_{a-1,b+1}$。

在这里要注意，每次答案中加上当前层的 $dp_{a,b}$ 后，需要按上面的转移方程对 $dp_{a,b}$ 进行更新，以表示当前层有多少区间可以作为下一层位置区间 $[a,b]$ 的地基，每一地基上可以放置积木，也就是下一层区间 $[a,b]$ 的方案数。

每层在更新时，按 $dp_{1,m}$、 $dp_{1,m-1}$、……、 $dp_{1,1}$、 $dp_{2,m}$、 $dp_{2,m-1}$、……、 $dp_{2,2}$、 ……、$dp_{m-1,m}$、 $dp_{m-1,m-1}$、 $dp_{m,m}$ 这样的顺序来进行，以保证更新时除了 $dp_{a,b}$ 本身是上层的旧值外，其余的 $3$ 项一定是用更新后的新值。

另外，题目中存在不喜欢的位置，不能放置积木。这可以采用前缀和的思想。

定义 $S_{i,j}$ 表示的 $i$ 层的前 $j(1\le j \le m)$ 个位置中不喜欢位置的个数。这样，后面在考察第 $i$ 层的每个位置区间 $[a,b]$ 时，若 $S_{i,b}-S_{i,a-1}=0$，则表示在位置区间 $[a,b]$ 中没有一个不喜欢的位置，可以放置一段连续的积木块，累加方案数并按转移方程更新 $dp_{a,b}$；若  $S_{i,b}-S_{i,a-1} \ne 0$，则在 $[a,b]$ 区间中肯定存在不喜欢的位置，没法放置一段连续的积木块，直接置 $dp_{a,b}$ 的值为 $0$，它也没法作为更上层积木块的地基了。

## 2. 源程序。

```c
#include <stdio.h>
# define MOD 1000000007
int s[105][105]={0};
long long dp[105][105]={0};
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	char ch[105];
	int i,j;
	for (i=n;i>=1;i--)
    {
        scanf("%s",ch+1);
 		for (j=1;j<=m;j++)
		{
			s[i][j]=s[i][j-1];
			if (ch[j]=='X') s[i][j]++;
		}
    }
	long long ans=1;      // 1块积木都不放，肯定是一种方案
	int l,r;
	for (l=1;l<=m;l++)    // 先看最底下（第1层）的积木放置情况
		for (r=m;r>=l;r--)
			if (s[1][r]-s[1][l-1]==0)  // 区间[l,r]之间不存在‘X'
            {
                dp[l][r]=1+dp[l][r+1]+dp[l-1][r]-dp[l-1][r+1];
                ans++;
            }
	for (i=2;i<=n;++i)    // 再从第2层放置到第n层
    {
		for (l=1;l<=m;l++)
			for (r=m;r>=l;r--)
				if (s[i][r]-s[i][l-1]==0)   //  区间[l,r]之间不存在‘X'
                {
					ans=(ans+dp[l][r])%MOD;
					dp[l][r]=(dp[l][r]+dp[l][r+1]+dp[l-1][r]-dp[l-1][r+1])%MOD;
				}
				else
                    dp[l][r]=0;
    }
	printf("%lld\n",ans);
	return 0;
}

```





---

## 作者：HarunluoON (赞：7)

## 题意简述

- 》[题面传送门](https://www.luogu.com.cn/problem/P8675)《
- 有一张高度 $n$ 层，宽度 $m$ 列的图纸，表示竖直平面，图纸上有若干为`X`的位置不能放积木；
- 积木都是棱长为 $1$ 的正方体，必须在图纸上的**整数**坐标处放置，下端**不能悬空**；
- 同一层的积木必须**连续放置**，不能被分隔；
- 求放置方案的数量。

![](https://cdn.luogu.com.cn/upload/image_hosting/1tos0xhk.png)

上图为样例的 $4$ 种解。_**以下均以顶层为第 $1$ 层，底层为第 $n$ 层**，与题面中相反，望周知。_

## 分析

我们可以考虑**区间dp**。

设 $f_{layer,l,r}$ 表示使得 第 $layer$ 层第 $[l,r]$ 列处可以搭积木（即 第 $(layer+1)$ 层第 $[l,r]$ 列全部有积木）的方案数。

第 $(layer+1)$ 层第 $[l,r]$ 列全部有积木的情况数，也就等于：

$$

\begin{matrix}

f_{layer+1,1,r}&+&f_{layer+1,1,r+1}&+&\cdots&+&f_{layer+1,1,m}&+\\

f_{layer+1,2,r}&+&f_{layer+1,2,r+1}&+&\cdots&+&f_{layer+1,2,m}&+\\

\vdots&&\vdots&&\ddots&&\vdots\\

f_{layer+1,l,r}&+&f_{layer+1,l,r+1}&+&\cdots&+&f_{layer+1,l,m}&&=\sum_{i=1}^{l}\sum_{j=r}^{m} f_{layer+1,i,j}\\

\end{matrix}

$$

此题的答案也就等于每个 $f_{layer,l,r}$ 之和。

我们可以对于每层的每个 $[l,r]$ 都枚举下一层的每个 $i$ 和 $j$。但是这种做法的时间复杂度不能通过本题。

### 优化 1

如果我们在开始枚举 $[l,r]$ 前，用 $O(m^2)$ 的复杂度维护一个二维 $sum$ 前缀数组（二维前缀和），其中：
$$

sum_{l,r}=\sum_{i=1}^{l}\sum_{j=1}^{r} f_{layer+1,l,r}

$$

则可以以单次 $O(1)$ 的复杂度更新 $f_{layer,l,r}$：

$$

f_{layer,l,r}=\sum_{i=1}^{l}\sum_{j=r}^{m} f_{layer+1,i,j}=\sum_{i=1}^{l}\sum_{j=1}^{m}f_{layer+1,i,j}-\sum_{i=1}^{l}\sum_{j=1}^{r-1}f_{layer+1,i,j}=sum_{l,m}-sum_{l,r-1}

$$

### 优化 2

枚举每一个 $[l,r]$ 时，需要判断该层第 $[l,r]$ 列是否全都可以搭积木。朴素的遍历，单次判断时间复杂度为 $O(m)$。

如果在输入图纸后对每一层建立前缀数组 $xsum$，使得 $xsum_{layer,x}$ 等于第 $layer$ 层第 $[1,x]$ 列中`X`的数量，则能通过判断 $xsum_{layer,r}-xsum_{layer,l-1}$ 是否等于 $0$ 从而 $O(1)$ 得出该层第 $[l,r]$ 列是否全都可以搭积木。

---

维护 $sum$ 数组复杂度为 $O(m^2)$，枚举 $[l,r]$ 复杂度也为 $O(m^2)$，故对于 $n$ 层中的每层，时间复杂度为 $O(m^2)$，总时间复杂度为 $O(nm^2)$，可以通过。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;

int n,m;
char b[114][114];
ll f[114][114][114];//下方注①
ll xsum[114][114];
ll sum[114][114];
ll ans;

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>b[i][j];
			xsum[i][j]=xsum[i][j-1]+(b[i][j]=='X');//优化2 
		}
	}
	
	f[n+1][1][m]=1,ans++;//第n+1层即为地基 
	                     //地基上什么都不放，也算作是方案之一种
	for(int layer=n;layer>=1;layer--)//从下往上枚举层数 
	{
		for(int l=1;l<=m;l++)//优化1 
		{
			for(int r=1;r<=m;r++)
			sum[l][r]=(f[layer+1][l][r]+sum[l-1][r]+sum[l][r-1]-sum[l-1][r-1])%MOD;
		}
		
		for(int l=1;l<=m;l++)
		{
			for(int r=1;r<=m;r++)
			{
				if(l>r) continue;
				if(xsum[layer][r]-xsum[layer][l-1]==0)//本层[1,r]列X数等于[1,l-1]列 
				{                                     //即本层[l,r]列没有X 
					f[layer][l][r]=(sum[l][m]-sum[l][r-1])%MOD;//下方注②
					ans=(ans+f[layer][l][r])%MOD;     //更新答案 
				}
			}
		}
	}
	
	printf("%d",(ans+MOD)%MOD);
	return 0;
}
/*
①
f[layer][l][r]
使得第layer层第[l,r]列处可以搭积木
（第(layer+1)层第[l,r]列全部有积木）的方案数。

②
f[layer][l][r]=
f[layer][1][r]  +f[layer][2][r]  +...+f[layer][l][r]+       | 本行=sum[l][r]-sum[l][r-1]
f[layer][1][r+1]+f[layer][2][r+1]+...+f[layer][l][r+1]+     | 本行=sum[l][r+1]-sum[l][r]
...+                                                        | ...
f[layer][1][m]  +f[layer][2][m]  +...+f[layer][l][m]        | 本行=sum[l][m]-sum[l][m-1]

                                                             总=sum[l][m]-sum[l][r-1]
*/
```

---

## 作者：Scorilon (赞：7)

### 总述

此题用区间 dp 解决，二维前缀和优化。

### 朴素做法

**阶段**：自上而下数每一层。

**状态**：$dp_{i,l,r}$ 表示自上而下数第 $i$ 行中在 $[l,r]$ 摆积木的方案数。

**状态转移方程**：根据题意可知，若要在 $[l,r]$ 中摆积木，那么 $[l,r]$ 中不允许有 $\tt{X}$，而第 $i$ 层的 $[l,r]$ 要摆积木，就需要第 $i+1$ 层的来托住。因此方程为：
$$dp_{i,l,r}=\sum_{x=1}^l \sum_{y=r}^m dp_{i+1,x,y}$$

**初始化**：很明显，若第 $n$ 层的 $[l,r]$ 中没有 $\tt{X}$，那么 $dp_{n,l,r}=1$，否则为 $0$，而对于判断是否合法，可将每一行做一个一维前缀和，这样可以 $O(1)$ 判断。

**答案**：所有 $dp_{i,l,r}$ 之和，即：
$$1+ \sum_{i=1}^n \sum_{l=1}^{m} \sum_{r=l}^m dp_{i,l,r}$$

**时间复杂度**：这样的时间复杂度为 $O(nm^4)$，无法承受，考虑优化。

### 二维前缀和优化

观察状态转移方程，可用二维前缀和优化，将所有的 $dp_{i+1,l,r}$ 视作一个点，因为都在第 $i+1$ 层，因此可以用滚动数组优化掉一维。那么 $\sum_{x=1}^l \sum_{y=r}^m dp_{i+1,x,y}$ 就是矩阵 $(1,r) \sim (l,m)$ 的和。

时间复杂度二维前缀和是 $O(m^2)$，而转移可以 $O(1)$，因此时间复杂度为 $O(nm^2)$，足矣通过本题。

```cpp
#include <cstdio>

#define ll long long

const int N=105;
const int M=105;
const int mod=1e9+7;

int n,m;
ll ans=1;
char mp[N][M];
int c[N][M];
ll dp[N][M][M];
ll sum[M][M];

int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) {
		scanf(" %s",mp[i]);
		for(int j=0;j<m;j++) c[i][j+1]=c[i][j]+(mp[i][j]=='X');//一维前缀和优化
	}
	for(int l=1;l<=m;l++) {
		for(int r=l;r<=m;r++) {
			if(!(c[n][r]-c[n][l-1])) dp[n][l][r]=1;//初始化
			ans+=dp[n][l][r];
			ans%=mod;
		}
	}
	for(int i=n-1;i>=1;i--) {//阶段
		for(int l=1;l<=m;l++) {//二维前缀和优化
			for(int r=1;r<=m;r++) sum[l][r]=(dp[i+1][l][r]+sum[l][r-1]+sum[l-1][r]-sum[l-1][r-1])%mod;
		}
		for(int len=1;len<=m;len++) {//状态
			for(int l=1;l+len-1<=m;l++) {
				int r=l+len-1;
				if(c[i][r]-c[i][l-1]) continue;
				dp[i][l][r]=(sum[l][m]-sum[l][r-1]-sum[0][m]+sum[0][r-1])%mod;//决策
				ans+=dp[i][l][r];
				ans%=mod;
			}
		}
	}
	printf("%lld\n",(ans+mod)%mod);//答案可能会出现负数，前面加减乘除取模过多
	return 0;
}
```

---

## 作者：Rosick (赞：5)

## 区间DP的另外一种优化方法
### 思路
1. 定义 $dp[k][i][j]$（以下确定了 $K$ 后简称 $(i,j)$）在把值赋给 $ans$ 前为 $k$ 行只在 $(i,j)$ 区间搭了积木且该行是最高行的方案数，赋值后为 $k$ 行所有在 $(i,j)$ 区间搭了积木且该行是最高行的方案数。
2. 赋值后找到该行每一块可以直通（即其中没有 $X$）的最大小区间。
3. 按长度从大到小遍历该区间所有区间。
4. 将当前区间 $(i, j)$ 的值转移给 $(i + 1,j)$ 和 $(i,j - 1)$。
5. 可知一个区间 $(i,j)$ 的值由 $(i,j + 1)$ 和 $(i - 1,j)$ 相加而来，因此要用容斥定理去重，即减去这两个区间方案数的相同部分。易得 $(i, j + 1)$ 和 $(i - 1, j)$ 的相同部分为 $(i - 1, j + 1)$，每次遍历到 $(i,j)$ 时减去即可。
6. 该优化复杂度为均摊 $O(m^2)$，因为跳过了 $X$，常数要比二维前缀和优化小一点。

### 代码
```c
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e2 + 10;
const int mod = 1e9 + 7;

int n, m, ans = 1;
bool vis[maxn][maxn];
int dp[maxn][maxn][maxn];

char read() {
	char c = getchar();
	while(c != 'X' && c != '.') c = getchar();
	return c;
}

void sol() {
	char c;
	scanf("%d%d", &n, &m);
	for(int i = n; i; --i) {
		c = read();
		if(c == 'X') vis[i][1] = 1;
		for(int j = 2; j <= m; ++j) {
			c = getchar();
			if(c == 'X') vis[i][j] = 1;
		}
	}
	for(int i = 1; i <= m; ++i)
		for(int j = i; j <= m; ++j)
			dp[0][i][j] = 1;
	for(int k = 1; k <= n; ++k) {
		//转移并赋值
		for(int i = 1; i <= m; ++i) {
			if(vis[k][i]) continue;
			for(int j = i; j <= m && !vis[k][j]; ++j) {
				dp[k][i][j] = dp[k - 1][i][j];
				ans = (ans + dp[k][i][j]) % mod;
			}
		}
		//优化
		int s = 0;
		for(int t = 1; t <= m; ++t) {
			if(!vis[k][t]) {
				if(!s) s = t;
				continue;
			}
			if(!s) continue;
			for(int len = t - s; len > 1; --len) {
				for(int i = s, j = s + len - 1; j < t; ++i, ++j) {
					dp[k][i][j] = (dp[k][i][j] - dp[k][i - 1][j + 1] + mod) % mod;
					dp[k][i + 1][j] = (dp[k][i + 1][j] + dp[k][i][j]) % mod;
					dp[k][i][j - 1] = (dp[k][i][j - 1] + dp[k][i][j]) % mod;
				}
			}
			for(int i = s; i < t; ++i)
				dp[k][i][i] = (dp[k][i][i] - dp[k][i - 1][i + 1] + mod) % mod;
			s = 0;
		}
		//判断最后后边还有没有没处理到的
		if(!s || s >= m) continue;
		for(int len = m - s + 1; len > 1; --len) {
			for(int i = s, j = s + len - 1; j <= m; ++i, ++j) {
				dp[k][i][j] = (dp[k][i][j] - dp[k][i - 1][j + 1] + mod) % mod;
				dp[k][i + 1][j] = (dp[k][i + 1][j] + dp[k][i][j]) % mod;
				dp[k][i][j - 1] = (dp[k][i][j - 1] + dp[k][i][j]) % mod;
			}
		}
		for(int i = s; i <= m; ++i)
			dp[k][i][i] = (dp[k][i][i] - dp[k][i - 1][i + 1] + mod) % mod;
	}
	printf("%d", ans);
}

int main() {
	sol();
	return 0;
}
```

---

## 作者：BeeAC (赞：3)

## 思路
### 区间 DP + 二维前缀和优化

首先容易想到朴素的区间 DP 做法。

  设 $f_{i,l,r}$ 表示以从下至上第 $i$ 层为积木顶端，第 $i$ 层在 $\lbrack l,r \rbrack$ 区间放积木的方案数。因为第 $i$ 层的积木只能放在第 $i-1$ 层积木的上方，只要满足区间 $\lbrack l,r \rbrack$ 内没有 `X` 就能得到一个很朴素的转移：
$$
f_{i,l,r}=\sum_{l' = 1}^{l} \sum_{r' = r}^{m} f_{i-1,l',r'}
$$

以任意一层为积木的顶端都是合法的方案，加上一个积木都不放的情况，答案即为：
$$
ans=\sum_{i = 1}^{n} \sum_{l = 1}^{m} \sum_{r = l}^{m} f_{i,l,r}+1
$$
朴素 DP 的核心代码如下：
```cpp
	for(int len=1;len<=m;++len)
		for(int l=1;l+len-1<=m;++l)
		{
			int r=l+len-1;
			if(ok[1][l][r])
				f[1][l][r]=1,++ans;
		}//先特殊处理第1层
	for(int i=2;i<=n;++i)//枚举层数
		for(int len=1;len<=m;++len)//枚举区间长度
			for(int l=1;l+len-1<=m;++l)//枚举左端点
			{
				int r=l+len-1;
				if(ok[i][l][r])//如果l~r区间内没有'X'
				{
					for(int ll=l;ll>=1;--ll)
						for(int rr=r;rr<=m;++rr)
							f[i][l][r]=(f[i][l][r]+f[i-1][ll][rr])%mod;
					ans=(ans+f[i][l][r])%mod;//累加以第i层为积木顶端的方案数
				}
			}
```
时间复杂度 $O(nm^4)$，实际远达不到。虽然开 O2 可以通过（不开 O2 最后一个点会超时），但显然不够优秀。

考虑如何优化。

设 $sum_{i,j}$ 表示以 $(1,1)$ 为左上角，$(i,j)$ 为右下角的矩阵[前缀和](https://blog.csdn.net/to_mountain/article/details/136778362)。我们发现 $\sum_{l' = 1}^{l} \sum_{r' = r}^{m} f_{i-1,l',r'}$ 其实可以抽象为以 $(1,r)$ 为左上角，$(l,m)$ 为右下角的矩阵前缀和（即 $sum_{l,m}-sum_{l,r-1}$，如下图）。
![以 $(1,r)$ 为左上角，$(l,m)$ 为右下角的矩阵前缀和](https://cdn.luogu.com.cn/upload/image_hosting/k1ejldk9.png)

显然可以在每次枚举层数 $i$ 时用 $O(m^2)$ 的复杂度预处理前缀和，然后就可以用 $O(1)$ 的复杂度求每个 $f_{i,l,r}$ 了。总时间复杂度优化至 $O(nm^2)$。
## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=101,mod=1e9+7;
int n,m,mk[N][N];
ll f[N][N][N],sum[N][N],ans=1;//不开long long见祖宗
bool ok[N][N][N];
char s[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=n;i>=1;--i)
	{
		scanf("%s",s+1);
		for(int j=1;j<=m;++j)
			mk[i][j]=mk[i][j-1]+(s[j]=='X');//计算第i层第j列'X'数量的前缀和
	}
	for(int len=1;len<=m;++len)
		for(int l=1;l+len-1<=m;++l)
			{
				int r=l+len-1;
				ok[0][l][r]=1;
			}
	for(int i=1;i<=n;++i)
		for(int len=1;len<=m;++len)
			for(int l=1;l+len-1<=m;++l)
			{
				int r=l+len-1;
				if(mk[i][r]-mk[i][l-1]>0||!ok[i-1][l][r])
					continue;
				ok[i][l][r]=1;//表示第i层l~r列没有'X'
			}
	for(int len=1;len<=m;++len)
		for(int l=1;l+len-1<=m;++l)
		{
			int r=l+len-1;
			if(ok[1][l][r])
				f[1][l][r]=1,++ans;
		}//先特殊处理第1层
	for(int i=2;i<=n;++i)
	{
		for(int l=1;l<=m;++l)
			for(int r=1;r<=m;++r)
				sum[l][r]=(f[i-1][l][r]+sum[l-1][r]+sum[l][r-1]-sum[l-1][r-1])%mod;//计算以(1,1)为左上角，(l,r)为右下角的矩阵前缀和
		for(int len=1;len<=m;++len)
			for(int l=1;l+len-1<=m;++l)
			{
				int r=l+len-1;
				if(ok[i][l][r])
				{
					f[i][l][r]=(sum[l][m]/*-sum[0][m]*/-sum[l][r-1]/*+sum[0][r-1]*/)%mod;//计算以(1,r)为左上角，(l,m)为右下角的矩阵前缀和，由于以第0行实际不存在，所以-sum[0][m]和+sum[0][r-1]可以省略
					ans=(ans+f[i][l][r])%mod;//累加以第i层为积木顶端的方案数
				}
			}
	}
	if(ans<0)
		ans+=mod;//取模后的数进行减法运算可能出现负数，注意特判
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：saikrilll (赞：2)

## dp初始做法
定义 $dp_{1,i,j}$ 表示第 $i$ 行，以 $j$ 为左端点的城堡满足第 $j$ 列以左不搭木块的搭建方案数。$dp_{2,i,j}$ 表示第 $i$ 行，以 $j$ 为右端点的城堡满足第 $j$ 列以右不搭木块的搭建方案数。现在为了在新一行更新答案，我们看下面一段代码：
```c
for(int i=2;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int h=j;h<=m;h++){
				if(!sum[i][h]){
					ans=(ans+dp2[i-1][j]*dp1[i-1][h]%mod)%mod;
					dp1[i][j]=(dp1[i][j]+dp1[i-1][h]%mod)%mod;
				}
				else break;
			}
		}
		for(int j=m;j>=1;j--){
			for(int h=j;h>=1;h--){
				if(!sum[i][h]){
					dp2[i][j]=(dp2[i][j]+dp2[i-1][h]%mod)%mod;
				}
				else break;
			}
		}
	}
```

其中先枚举行，再枚举列，其分为 $dp_1$ 的转移和 $dp_2$ 的转移。由于图是具有对称性的，所以我们只要成功写出 $dp_1$ 的转移就可以推 $dp_2$ 了。

------------
咱们就说 $dp_1$，看代码，先枚举第 $i$ 行左端点 $j$，再枚举右端点 $h$，可以发现**第 $i$ 行的贡献是所有上述枚举单个 $j_1$，$h_1$ 所造成的贡献和**，因为 $j$，$h$ 具有独一性。再看如何求出单个 $j$，$h$ 的贡献：发现一旦第 $i$ 行 $j$ 到 $h$ 都要搭木块，则意味着 $1$ 到 $i$ 中所有 $j$ 到 $h$ 都必须选（因为重力原则，上面选而下面不选就要塌），也就是要满足其位置都不为 ``` X ```，那么只需要考虑前 $i-1$ 行中 $[1,j-1]$ 和 $[h+1,m]$ 区间的所有枚举情况。又因为 $dp_{2,i-1,j}$，$dp_{1,i-1,h+1}$ 存的就分别是上述区间的全枚举，根据乘法原则，对答案 $ans$ 的贡献就是 $dp_{1,i-1,h+1}\times dp_{2,i-1,j}$。对答案贡献处理完了，就差 dp 转移。 dp 转移其实就藏于无形之间，在我们上述代码枚举 $j$，$h$ 的时候，会发现 $dp_{1,i,j}$ 就等于枚举的 $h$ 端点时的 $dp_{1,i-1,h}$ 之和（题意要模 $10^9+7$）所以枚举加就行了。$dp_2$ 也是对称的，所以，dp 初始做法 Ok 了。

## dp优化做法
不难发现，上述 dp 转移思路时间复杂度为 $n\times m^2$ ，稳不超。又有什么更好的做法呢？

------------
观察转移，dp 的转移都只与其原位置的下面一行有关（$ans$ 也相同且满足都选取了一段相对连续的子区间）。而刚才转移时又遍历了一遍，所以可以用前缀 dp 解决问题。

考虑 $sum_1dp_{i,j}$，$sum_2dp_{i,j}$ 表示第 $i$ 行分别从左到右的 $dp_1$ 的前缀和和从右往左的 $dp_2$ 的前缀和，看 $dp_1$：$dp_{1.i,j}$ 就等于 $(i-1,j)$ 往右的满足 $sum_{i,j}$ 等于 $0$ 的 $dp_{1,i-1,j}$ 之和。为了在 $O(1)$ 的时间复杂度内查询最大联通数再建个 $sum_1$ 数组就可以了。所以转移就是下述代码。

```c
ans=(ans+(dp2[i-1][j]*(sum1dp[i-1][j+sum1[i][j]-1]-sum1dp[i-1][j-1])%mod))%mod;
dp1[i][j]=(sum1dp[i-1][j+sum1[i][j]-1]-sum1dp[i-1][j-1])%mod;
sum1dp[i][j]=(sum1dp[i][j-1]+dp1[i][j])%mod;
```

时间复杂度就变为了 $O(n\times m)$ 了。
## 浅谈状态设计优化
本题为何能够写成二维，而区间 dp 为何无法优化状态？本质上是因为一旦选择了某行的一段区间，那么其选择区域以下的所有区域的状态都已被确定，即都需要选择，也就是只有两侧的状态未被确定，计数 dp 的本质是不断确定未知的状态和，所以只需要 dp 两侧，建立两个对称的 dp 数组即可。而区间算法未关注到本题的特殊性质，所以状态无法真正地降下来。状态一旦优化，则减少了浪费的枚举的时间复杂度，从而实现了时空上的优化。这就启示我们：**学会注意到每道题的特点，它将是你决定解决问题的方式的关键。**
## 代码：
```c
#include<bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;
int n,m,f[110][110],sum[110][110],sum1[110][110],sum2[110][110]; 
long long dp1[110][110],dp2[110][110],ans,sum1dp[110][110],sum2dp[110][110]; 
char s[110];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=n;i>=1;i--){
		scanf("%s",s);
		for(int j=0;j<m;j++){
			if(s[j]=='X')f[i][j+1]=1;
		}
	}
	for(int j=1;j<=m;j++){
		for(int i=1;i<=n;i++){
			sum[i][j]=sum[i-1][j]+f[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=m;j>=1;j--){
			if(!sum[i][j]){
				sum1[i][j]=sum1[i][j+1]+1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!sum[i][j])sum2[i][j]=sum2[i][j-1]+1;
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=i;j<=m&&f[1][j]!=1;j++){
			dp1[1][i]++; ans++;
		}
		sum1dp[1][i]=sum1dp[1][i-1]+dp1[1][i];
	}
	for(int i=m;i>=1;i--){
		for(int j=i;j>=1&&f[1][j]!=1;j--){
			dp2[1][i]++; 
		}
		sum2dp[1][i]=sum2dp[1][i+1]+dp2[1][i];
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<=m;j++){
		    if(!sum[i][j]){
				ans=(ans+(dp2[i-1][j]*(sum1dp[i-1][j+sum1[i][j]-1]-sum1dp[i-1][j-1])%mod))%mod;
				dp1[i][j]=(sum1dp[i-1][j+sum1[i][j]-1]-sum1dp[i-1][j-1])%mod;
				sum1dp[i][j]=(sum1dp[i][j-1]+dp1[i][j])%mod;
			}
			else{
				sum1dp[i][j]=0;
			}
		}
		for(int j=m;j>=1;j--){
			if(!sum[i][j]){
				dp2[i][j]=(sum2dp[i-1][j-sum2[i][j]+1]-sum2dp[i-1][j+1])%mod;
				sum2dp[i][j]=(sum2dp[i][j+1]+dp2[i][j])%mod;
			}
			else{
				sum2dp[i][j]=0;
			}
		}
	}
	ans=((ans+1)%mod+mod)%mod;
	printf("%lld",ans);
	return 0;
}   
```
## 优化一维
聪明的大家会发现：这题其实是可以都将 $2$ 维 dp 数组和求前缀和的数组改为 $1$ 维，这个转移问题方式也是同上的。只不过输入从上往下输入，无法用 $1$ 维存。如果这题改为相反方向的读入，就能再卡卡空间了（写法也更麻烦）。

## 注意事项
另外，本题转移时可能会爆 int。记得答案取模时加个 $mod$。 
还有就是读入输出建议用 scanf 和 printf。答案加一后取模。

### 附录：
我在武汉集训的时候出了这道题的改版，可以理解为输入反着读，数据开成小于等于 $3000$。互测出这道改编题为了考 dp 优化能力。

---

## 作者：ykzzldz (赞：2)

[题面](https://www.luogu.com.cn/problem/P8675)

一个显然的想法：设 $f[i][l][r]$ 表示从上到下数第 $i$ 行，区间 $[l,r]$ 之间的方案数。那么 $f[i][l][r]$ 有值的前提是 $[l,r]$ 之间没有 $X$，这里可以用一个前缀和计算。

那么，因为需要满足规则 $1$，所以不难得出转移式：$f[i][l][r]=\sum_{j=1}^{l}\sum_{k=r}^{m}f[i+1][j][k]$，答案就是每个 $f$ 之和加一（因为什么都不放也是一种方案）。我们可以先将第 $n$ 行预处理出来，然后从下往上转移。但是，这样做复杂度是 $O(nm^4)$ 的，显然无法通过，考虑优化。

这里可以使用前缀和先处理出区间 $[l,r]$ 的方案数，那么转移时就可以直接用，下面给出代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,sum[110][110],f[110][110][110],ans=1,sum2[110][110],mod=1e9+7;
char a;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a;
			sum[i][j]=sum[i][j-1];
			if(a=='X')sum[i][j]++;//第一个前缀和处理出区间[i,j]内的X数量 
		}
	}
	for(int i=1;i<=m;i++){//预处理第n行 
		for(int j=i;j<=m;j++){
			if(sum[n][j]-sum[n][i-1]==0){
				f[n][i][j]=1;
				ans++;
			}
		}
	}
	for(int i=n-1;i>=1;i--){
		for(int l=1;l<=m;l++){
			for(int r=l;r<=m;r++){
				sum2[l][r]=(f[i+1][l][r]+sum2[l][r-1]+sum2[l-1][r]-sum2[l-1][r-1])%mod;//前缀和处理出[l,r]区间内的方案数
			}
		}
		for(int l=1;l<=m;l++){
			for(int r=l;r<=m;r++){
				if(sum[i][r]-sum[i][l-1]==0){//如果区间内没有X，转移
					f[i][l][r]=(sum2[l][m]-sum2[l][r-1])%mod;
					ans=(ans+f[i][l][r])%mod;
				}
			}
		}
	}
	cout<<(ans+mod)%mod;//这里直接输出ans会被卡，原因是因为前面的计算可能导致ans为负数
	return 0;
}
```

---

## 作者：Maysoul (赞：2)

看题解区大佬全都是用的区间 DP + 二维前缀和优化。

那我就来一发数位 DP 的题解吧，应该比区间 DP 快一点。

## 简化题意：

我们需要求出满足以下条件的方案数：

1. 每一层上的积木下方必须有积木，不能浮在空中（牛顿开心的合上了棺材板）。

1. 同一层中的积木必须要连续摆放。

1. 标 $ X $ 的位置不可以放置积木。

## 思路转化：

（注：默认读到这里的诸位已经掌握数位 DP，至少对数位 DP有一定了解）

直接拿着这个图肯定是没办法做的，我们考虑将它转化成能进行数位 DP的模样。

于是我们想到，因为每一层积木下方必须有积木，所以不能放置的位置上层也不能放置，于是对于每一列，我们都可以得到一个放置积木的最大高度 $ h_{i} $。

因为题目约定必须同一层中积木必须连续摆放，所以在每一列转换时都只会变为两种状态，要么递增，要么递减，而且不能先减后增。

可以这样理解：先减后增就像“凹”，它的积木摆放必然时不连贯的。

我们将这种状态用一个 $ bool $ 类型 $ leed $ 表示。

那么我们再思考什么会导致状态的变化，当$ leed $是递增状态的时候，需要它的上一个 $ leed $ 也是递增状态，同时它的高度必须要比它的上一个节点高度要高。

于是我们就需要枚举每一个节点的每一个高度，同样也是需要分类讨论，如果当前 $ leed $ 为递增状态，那么它的最大高度显然就是我们所求得的 $ h_{i} $，当它是递减状态的时候，则最大高度应该是上一个节点的高度与 $ h_{i} $ 的最小值。

根据以上的推导，我们可以创立一个三维 DP 数组 $ dp_{p,pre,leed} $，$ p $ 表示当前的节点，$ pre $为当前节点的前驱（也就是上一个节点的高度），$ leed $ 表示当前状态。

## CODE：

```cpp
//2023/7/11
//别着急，先通读一遍题目
//别忘了开long long
//写完先看一遍怎么降复杂度
//要么开全局变量要么给定初值
//想想看，有什么情况需要特判
//看看数组开的够不够大
//std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
#include<iostream>
#include<math.h>
using namespace std;
const int MAXN=100+10;
const int MOD=1e9+7;
int n,m;
int h[MAXN];
bool c[MAXN][MAXN];
int dp[MAXN][MAXN][2];
int dfs(int p,int pre,bool leed)
{
	if(dp[p][pre][leed]) return dp[p][pre][leed];
	if(p>m) return 1;//不能超出约定区间
	int ans=0,mx;
	if(leed) mx=h[p];//求得最大高度
	else mx=min(h[p],pre);
	for (int i=0;i<=mx;i++){
		bool nextleed=leed&&(i>=pre);//推导出是否变化
		ans+=dfs(p+1,i,nextleed);//枚举当前高度，进入下一层
		ans%=MOD;
	}
	return dp[p][pre][leed]=ans;//存储当前位置
}
int main()
{
	std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	char a;
	cin>>n>>m;
	for (int i=n;i>=1;i--){
		for (int j=1;j<=m;j++){
			cin>>a;
			if(a=='X') c[i][j]=1;
			else c[i][j]=0;
		}
	}
	for (int j=1;j<=m;j++){//处理出最大高度
		for (int i=1;i<=n;i++){
			if(c[i][j]) break;
			h[j]++;
		}
	}
	printf("%d",dfs(1,0,1));
	return 0;
}
```


---

## 作者：kind_Ygg (赞：1)

~~弱智的我竟然想写贪心~~
## 前置知识
前缀和，是一种可以再计数类题目中预处理，使得时间复杂度从 $O(n)$ 降低到 $O(1)$。  

本题使用的是二维前缀和（具体资料请查看 [OI-WIKI](https://oi.wiki/basic/prefix-sum/#%E4%BA%8C%E7%BB%B4%E5%A4%9A%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C)），可以将 $O(n^2)$ 变为 $O(1)$。  
预处理：

```
sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]
```
调用矩阵 $(x_1,y_1)(x_2,y_2)$ 的值：
```
sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];
```
~~应该不会有人连前缀和都没学就来写区间 dp 吧。~~

## 题目大意
小铭现在要地图中搭积木，给出 $n \times m$ 的地图，其中要满足这几个条件：  
1. 从最下面一行开始搭（第 $n$ 行）。
2. 一层的块必须连续不断。
3. 小铭不喜欢的位置不能搭（在输入中用 $X$ 来表示）。

求有多少种搭积木的方案（不搭也算一种）。
## 思路
这题不难想到，用二维区间 dp 完成，设 $dp_{k,i,j}$ 表示第 $k$ 层，只有 $[i,j]$ 全部搭上，并且第 $k$ 层为顶层的**方案数**。  
那么答案就为 $ans=1+\sum_{k=1}^{n}\sum_{i=1}^{m}\sum_{r=i}^{m}dp_{k,i,j}$，其中 $1$ 就为不搭的方案。

那么如何向 $dp_{k,i,j}$ 转移呢？~~根据地心引力~~，我们一定要将第 $i+1$ 层摆好（层数从上向下递增），并且第 $i+1$ 层的 $[i,j]$ 已经摆好，~~又不像 MC 可以浮空~~，所以得 $dp_{k,i,j}=\sum_{l=1}^{i}\sum_{r=j}^{m}dp_{k+1,l,r}$。

转移的时间复杂度是 $O(n^2)$，求每个状态的时间复杂度是 $O(n^3)$，综合就是 $O(n^5)$，在 $1 \le n,m\le100$ 的情况下是不允许的，但在转移会用到不少重复的状态，可以用 $O(n^2)$ 预处理，$O(1)$ 调用，就可以完美 AC 这题啦！
## Code

```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e2+5;
const long long mod=1e9+7;
int n,m;
char s[N][N];
int X[N][N],sum[N][N];
int dp[N][N][N];
int ans=1;
int Mod(int x)
{
	return ((x+mod)%mod+mod)%mod;
}
void init()
{
	for(int i=1;i<=m;i++)
		for(int j=i;j<=m;j++)
		{
			if(X[n][j]-X[n][i-1]){dp[n][i][j]=0;continue;}
			dp[n][i][j]=1;
			ans++;
		}
	return;
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>s[i][j];
			X[i][j]=X[i][j-1];
			if(s[i][j]=='X')
				X[i][j]++;
		}
	init();
	for(int k=n-1;k>=1;k--)
	{
		//前缀和
		for(int i=1;i<=m;i++)
			for(int j=i;j<=m;j++)
				sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+dp[k+1][i][j],sum[i][j]=Mod(sum[i][j]);
		for(int i=1;i<=n;i++)
			for(int j=i;j<=m;j++)
			{
				if(X[k][j]-X[k][i-1]) {dp[k][i][j]=0;continue;}
				dp[k][i][j]=sum[i][m]-sum[i][j-1];
				dp[k][i][j]=Mod(dp[k][i][j]);
				ans+=dp[k][i][j];
				ans=Mod(ans);
			}
	}
	cout<<ans<<'\n';
	return 0;
}
```
## 结语
这题的状态虽说不难想到，但综合来说，这已经是蓝的存在了，所以建议评蓝。

没几天就 CSP-J/S 初赛了，最后祝所有参加 CSP 的OIer 们了旗开得胜，再复赛中超常发挥。

---

## 作者：封禁用户 (赞：1)

总述
-
此题用区间 dp 解决，二维前缀和优化。

**阶段**：自上而下数每一层。

**状态**：$dp_{i,l,r}$ 表示自上而下数第 $i$ 行中在 $[l,r]$ 摆积木的方案数。

**状态转移**：易推方程式：

$$dp_{i,l,r}=\sum _{x=1}^{l}\sum _{y=r}^{m}dp_{i+1,x,y}$$

**初始化**：很明显，若第 $n$ 层的 $[l,r]$ 中没有 $\text X$，那么 $dp_{i,l,r}=1$ 否则为 $0$。

**答案**：所有 $dp_{i,l,r}$ 之和，即：
$$1+\sum_{i=1}^{n}\sum_{l=1}^{m}\sum_{r=1}^{m}dp_{i,l,r}$$

**时间复杂度**：$\mathcal{O}(nm^4)$，考虑优化。

**考虑二维前缀和优化**：观察状态转移方程，可用二维前缀和优化，将所有的 $dp_{i+1,l,r}$ 视作一个点，因为都在第 $n+1$ 层，因此可以用滚动数组优化掉一维。那么 $\sum_{x=1}^l\sum_{y=r}^mdp_{i+1,l,r}$ 就是矩阵 $(1,r)\sim(l,m)$ 的和。

时间复杂度二维前缀和是 $\mathcal {O}(m^2)$，而转移可以是 $\mathcal{O}(1)$，因此时间复杂度为 $\mathcal{O}(nm^2)$。

代码：


```cpp
#include <cstdio>

#define ll long long

const int N=105;
const int M=105;
const int mod=1e9+7;

int n,m;
ll ans=1;
char mp[N][M];
int c[N][M];
ll dp[N][M][M];
ll sum[M][M];

int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) {
		scanf(" %s",mp[i]);
		for(int j=0;j<m;j++) c[i][j+1]=c[i][j]+(mp[i][j]=='X');//一维前缀和优化
	}
	for(int l=1;l<=m;l++) {
		for(int r=l;r<=m;r++) {
			if(!(c[n][r]-c[n][l-1])) dp[n][l][r]=1;//初始化
			ans+=dp[n][l][r];
			ans%=mod;
		}
	}
	for(int i=n-1;i>=1;i--) {//阶段
		for(int l=1;l<=m;l++) {//二维前缀和优化
			for(int r=1;r<=m;r++) sum[l][r]=(dp[i+1][l][r]+sum[l][r-1]+sum[l-1][r]-sum[l-1][r-1])%mod;
		}
		for(int len=1;len<=m;len++) {//状态
			for(int l=1;l+len-1<=m;l++) {
				int r=l+len-1;
				if(c[i][r]-c[i][l-1]) continue;
				dp[i][l][r]=(sum[l][m]-sum[l][r-1]-sum[0][m]+sum[0][r-1])%mod;//决策
				ans+=dp[i][l][r];
				ans%=mod;
			}
		}
	}
	printf("%lld\n",(ans+mod)%mod);//答案可能会出现负数，前面加减乘除取模过多
	return 0;
}

```

---

## 作者：wei2013 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8675)

## 思路：
区间 dp，因为可以看到题目中说：

**同一层中的积木必须连续摆放，中间不能留有空隙；**，说明一定得是连续区间。
### 暴力 dp:
状态定义：$dp_{i,l,r}$ 表示以第 $i$ 层为顶并在第 $l-r$ 区间**全放满**积木的方案数。

初始化：第 $n$ 层如果在区间内没有 `X`，则设为 $1$。

状态转移方程：第 $i$ 层的方案数显然是上一层的全部与此时扫到区间长度相等方案数之和，也就是：
$$dp_{i,l,r} = \sum_{x=1}^{l} \sum_{y=r}^{m}dp_{i+1,x,y}$$
**注意：是 $i+1$**。

答案统计：显然各个位置与层数之间都是互不干扰的，因为它们的顶都不同。所以：
$$ans=1+ \sum dp_{i,l,r}$$
这个 $1$ 是哪来的，这是唯一一种一个积木都不放的方案，在先前也是没有统计到的。

时间复杂度：$\mathcal{O(n m^4)}$，无法接受。
### 优化 dp:
既然是求和符号那么自然是用前缀和啦。

$$dp_{i,l,r} = \sum_{x=1}^{l} \sum_{y=r}^{m}dp_{i+1,x,y}
$$

观察以上公式，其实也可以抽象为 
$(x,y)-(l,m)$ 的矩阵啦，所以：

$$dp_{i,l,r} = \sum_{x=1}^{l} \sum_{y=r}^{m}dp_{i+1,x,y}
=p_{l,m}-p_{l,r-1}$$
设 $p_{i,j}$ 是 $(1,1)-(i,j)$ 的矩阵之和。

时间复杂度：$\mathcal{O(n m^3)}$，依旧不足以通过本题

上面的优化其实已经很到位了，剩下的初始化部分的 `X` 个数也同样可以前缀和处理，很好推，具体见下面的代码。

时间复杂度：$\mathcal{O(n m^2)}$，足以通过本题。
## code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mod 1000000007
int dp[105][105][105],n,m,cnt[105][105],p[105][105],ans=1;
char a[105][105];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			cnt[i][j]=(cnt[i][j-1]+mod)%mod;
			if(a[i][j]=='X'){
				cnt[i][j]=(cnt[i][j]+1+mod)%mod;
			}
		}
	}
	for(int len=1;len<=m;len++){
		for(int l=1;l+len-1<=m;l++){
			int r=l+len-1;
			if(cnt[n][r]-cnt[n][l-1]==0){
				ans=(ans+1+mod)%mod;
				dp[n][l][r]=1;
			}
		}
	}
	for(int i=n-1;i>=1;i--){
		for(int l=1;l<=m;l++){
			for(int r=1;r<=m;r++){
				p[l][r]=(p[l-1][r]+p[l][r-1]-p[l-1][r-1]+dp[i+1][l][r]+mod)%mod;
			}
		}
		for(int len=1;len<=m;len++){
			for(int l=1;l+len-1<=m;l++){
				int r=l+len-1;
				if(cnt[i][r]-cnt[i][l-1]==0){
					dp[i][l][r]=(p[l][m]-p[l][r-1]+mod)%mod;
				}
				ans=(ans+dp[i][l][r]+mod)%mod;
			}
		}
	}
	cout<<(ans+mod)%mod;//注意取模
	return 0;
}
```

---

## 作者：lqsy002 (赞：1)

## 题目大意

[题目链接](https://www.luogu.com.cn/problem/P8675)。

## 解题思路

**dp**

- $check_{i,j}$ 表示第 $i$ 层前 $j$ 个中有多少个 $X$。
- $dp_{l,r}$ 表示当前层中的方法数。

$check$ 其实就是前缀和操作，对每一层进行前缀和运算。

我们规定积木从下到上分别是第 $n$ 层，第 $n-1$ 层，最上面是第一层。

1. 用 $check$ 来更新最低层 $dp$ 的值。
2. 从最低层开始向上传递，即从大区间枚举到小区间后得出的方法数。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[105][105];
int n,m,check[105][105],ans=1;
char str[105];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%s",str+1);
        for(int j=1;j<=m;j++){
            check[i][j]=check[i][j-1];
            if(str[j]=='X')
                check[i][j]++;
        }
    }
    for(int i=1;i<=m;i++)
        for(int j=m;j>=i;j--)
            if(check[n][j]-check[n][i-1]==0){
                ans++;
                dp[i][j]=dp[i][j+1]+dp[i-1][j]-dp[i-1][j+1]+1;
            }
    for(int t=n-1;t>0;t--)
        for(int i=1;i<=m;i++)
            for(int j=m;j>=i;j--)
                if(check[t][j]-check[t][i-1]==0){
                    ans=(ans+dp[i][j])%1000000007;
                    dp[i][j]=(dp[i][j]+dp[i-1][j]+dp[i][j+1]-dp[i-1][j+1])%1000000007;
                }else
                    dp[i][j]=0;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：__YSC__ (赞：1)

# 题目描述

你可以在一个 $N \times M$ 的区域中搭积木，每一层必须连续摆放积木，且每个积木下必须是积木或地面，你也不能在不喜欢的地方搭积木，求搭积木的方案数。

# 思路

首先考虑比较暴力的 DP。定义 $dp_{i,l,r}$ 表示在第 $i$ 层，积木区间的左右端点为 $l,r$ 时的方案数。

则我们可以得到：$dp_{i,l,r} = \sum \limits_{l'=1}^l \sum \limits_{r'=r}^M dp_{i+1,l',r'}$。这时你就可以发现这就是一个二维前缀和，使用前缀和优化即可。

时空复杂度均为 $O(NM^2)$。

## 细节

注意取模，以及这个 DP 的拓扑序是区间长度从小到大，需按拓扑序进行转移。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 105, MAXM = 105, MOD = 1e9 + 7;

int n, m, s[MAXN][MAXM], ans = 1;
long long dp[MAXN][MAXM][MAXM], sum[MAXN][MAXM][MAXM];

bool check(int i, int l, int r) {
  return s[i][r] == s[i][l - 1];
}

long long Calc(int i, int lx, int rx, int ly, int ry) {
  return ((sum[i][rx][ry] - sum[i][lx - 1][ry] - sum[i][rx][ly - 1] + sum[i][lx - 1][ly - 1]) % MOD + MOD) % MOD;
}

int main() {
  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for(int i = 1; i <= n; ++i) {
    for(int j = 1; j <= m; ++j) {
      char c;
      cin >> c;
      s[i][j] = s[i][j - 1] + (c == 'X');
    }
  }
  for(int len = 1; len <= m; ++len) {
    for(int l = 1; l + len - 1 <= m; ++l) {
      int r = l + len - 1;
      if(check(n, l, r)) {
        dp[n][l][r] = 1;
      }
      ans = (ans + dp[n][l][r]) % MOD;
    }
  }
  for(int i = n - 1; i >= 1; --i) {
    for(int l = 1; l <= m; ++l) {
      for(int r = l; r <= m; ++r) {
        sum[i + 1][l][r] = ((sum[i + 1][l][r - 1] + sum[i + 1][l - 1][r] - sum[i + 1][l - 1][r - 1] + dp[i + 1][l][r]) % MOD + MOD) % MOD;
      }
    }
    for(int len = 1; len <= m; ++len) {
      for(int l = 1; l + len - 1 <= m; ++l) {
        int r = l + len - 1;
        if(check(i, l, r)) {
          dp[i][l][r] = Calc(i + 1, 1, l, r, m);
        }
        ans = (ans + dp[i][l][r]) % MOD;
      }
    }
  }
  cout << ans;
  return 0;
}
```

---

## 作者：紊莫 (赞：1)

区间 DP 题。


------------


首先，显然我们要按层从下往上转移。对于每一层，我们进行区间 DP。具体的，我们设 $f_{i,l,r}$ 表示到第 $i$ 层，这个区间内都放东西的方案数。

显然要能转移，必须没有叉，那么为了方便，可以记录叉的前缀和，方便判断区间是否合法。

现在我们想一下怎么到达 $f_{i,l,r}$ 这个状态，显然要从下一行转移上来，并且我这一行总不能放空中楼阁吧，所以下一行放的那个区间一定要包含这一行。

至此，我们可以写出一份朴素的代码： 

```cpp
const int N = 105, M = (N << 1), inf = 0x3f3f3f3f, mod = 1e9 + 7;
int n, m, ans = 1, a[N][N], s[N][N], f[N][N][N], g[N][N];
inline int ck(int i, int l, int r) { return s[i][r] - s[i][l - 1] == 0; }
inline void A(int &x, int y) {
  x += y;
  if (x > mod) x -= mod;
}
void solve() {
  cin >> n >> m;
  F(i, 1, n) F(j, 1, m) {
    char c;
    cin >> c;
    a[i][j] = c == 'X';
    s[i][j] = s[i][j - 1] + a[i][j];  // calc the num of X
  }
  F(l, 1, m) F(r, l, m) if (ck(n, l, r)) f[n][l][r] = 1, ans++;
  dF(i, n - 1, 1) {
    F(l, 1, m) F(r, l, m) {
      if (!ck(i, l, r)) break;
      F(ll, 1, l) F(rr, r, m) { A(f[i][l][r], f[i + 1][ll][rr]); }
      A(ans, f[i][l][r]);
    }
  }
  cout << ans << '\n';
}
```

时间复杂度 $\mathcal{O(nm^4)}$。如果你实现的和上文代码一样好甚至更好，那么是能稳定 AC 的，但是我们显然想要更优的代码。

考虑我们在转移啥，把转移代码拿出来看。

```cpp
F(ll, 1, l) F(rr, r, m) { A(f[i][l][r], f[i + 1][ll][rr]); }
```

这不是在求一个矩形的和吗？那么我们使用二维前缀和，把这个过程变成 $\mathcal{O}(1)$ 的。

```cpp
void solve() {
  cin >> n >> m;
  F(i, 1, n) F(j, 1, m) {
    char c;
    cin >> c;
    a[i][j] = c == 'X';
    s[i][j] = s[i][j - 1] + a[i][j];  // calc the num of X
  }
  F(l, 1, m) F(r, l, m) if (ck(n, l, r)) f[n][l][r] = 1, ans++;
  dF(i, n - 1, 1) {
    memset(g, 0, sizeof g);
    F(l, 1, m) F(r, 1, m) {
      g[l][r] = g[l - 1][r] + g[l][r - 1] - g[l - 1][r - 1] + f[i + 1][l][r];
      g[l][r] = (g[l][r] % mod + mod) % mod;
    }
    F(l, 1, m) F(r, l, m) {
      if (!ck(i, l, r)) break;
      f[i][l][r] = (g[l][m] - g[l][r - 1] + mod) % mod;
      A(ans, f[i][l][r]);
    }
  }
  cout << ans << '\n';
}
```

改成这样就可以了，不知道为什么题解区的其他人都要把求和变得很复杂，明明这题是个特殊情况。

---

## 作者：AZYDLL (赞：0)

看了一圈，发现各位 Dalao 都用自下而上的做法，于是来发一篇题解讲一下自上而下的做法

# 思路：区间DP+二维前缀和优化

## 朴素做法

定义 $dp_{i,l,r}$ 为以**自上而下**第 $i$ 层的积木块区间 $[l,r]$ 为**塔底**，能摆的方案数（若 $[l,r]$ 中有 `X`，则 $dp_{i,l,r}=0$）。显然转移方程为：

$$
dp_{i,l,r}=\sum^r_{l'=l} \sum^r_{r'=l'} dp_{i-1,l',r'}
$$

再加上一个积木块都不放的情况，答案就是：

$$
ans=\sum^m_{l=1} \sum^m_{r=l} dp_{n,l,r}+1
$$

枚举转移方程中的 $i,l,r,l',r'$，时间复杂度为 $O(nm^4)$。这在本题中是不可接受的，于是考虑优化。

## 优化1

定义二维前缀和数组 $sum_{i,l,r}$ 为：

$$
sum_{i,l,r}=\sum^l_{l'=1} \sum^r_{r'=l'} dp_{i,l',r'}
$$

在枚举每一层的 $[l,r]$ 前，用 $O(m^2)$ 的时间复杂度维护 $sum$ 数组，就可以以 $O(1)$ 的时间复杂度更新 $dp_{i,l,r}$。于是原转移方程可变为：

$$
dp_{i,l,r}=sum_{i-1,r,r}-sum_{i-1,r,l-1}-sum_{i-1,l-1,r}+sum_{i-1,l-1,l-1}
$$

上述操作可将时间复杂度优化至 $O(nm^2)$。

## 优化2

题目中，对于任意的 $1 \le l \le r \le m$，无法保证区间 $[l,r]$ 中没有 `X` 。于是可以提取**两段 `X` 间的**区间 $[l_1,r_1]$，显然，$[l_1,r_1]$ 中没有 `X` 。

此时，在 $[l_1,r_1]$ 中枚举 $[l,r]$，就无需判断 $[l,r]$ 中是否有 `X` ，效率会更高。

上述操作可在某些测试点中小幅度地优化常数。

# 代码

注意事项：

* 不开 long long 见祖宗
* 记得取模
* 由于答案需要取模，在用二维前缀和计算方案数时可能会减出负数，解决方法是在取模前先将答案加上 $2 \times 10^9+14$


```cpp
#include<iostream>
#include<cstring>
#define MAXN 105
#define MOD 1000000007

using namespace std;

long long n,m,sum[MAXN][MAXN][MAXN],dp[MAXN][MAXN][MAXN];// 不开 long long 见祖宗 
string in,map[MAXN];

int main()
{	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>in;
		map[i]="X"+in+"X";// 预处理图纸，便于提取纯 '.' 区间 [l1,r1] 
	}
	
	int fst=-1,lst;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m+1;j++){
			if(map[i][j]=='.'){
				if(fst==-1) fst=j;
				lst=j;
				continue;
			}// 提取纯 '.' 区间 [l1,r1] 
			if(fst!=-1){
				for(int l=fst;l<=lst;l++){
					for(int r=l;r<=lst;r++){
						dp[i][l][r]=sum[i-1][r][r]-sum[i-1][l-1][r]-sum[i-1][r][l-1]+sum[i-1][l-1][l-1]+1;
						dp[i][l][r]=(dp[i][l][r]+MOD*2)%MOD;// 注意对于负数结果的处理 
					}
				}
				fst=-1;
			}// 在 [l1,r1] 中枚举 [l,r] ，更新答案 
		}
		
		for(int j=1;j<=m;j++){
			for(int k=1;k<=m;k++){
				sum[i][j][k]=sum[i][j-1][k]+sum[i][j][k-1]-sum[i][j-1][k-1]+dp[i][j][k];
				sum[i][j][k]=(sum[i][j][k]+MOD)%MOD;
			}
		}// 为第 i+1 层预处理第 i 层的 sum 前缀和数组 
	}
	cout<<sum[n][m][m]+1<<endl;
	
	return 0;
}
```

---

## 作者：XiaoQuQu (赞：0)

提供一个玄学复杂度的解法。

考虑直接设 $f_{i,j,k}$ 表示考虑后 $i$ 行，第 $i$ 行在 $[j,k]$ 位置放积木的方案数。

于是这样我们就可以写出来一个朴素的转移，也就是 $f_{i,j,k}=\sum\limits_{l=1}^j\sum\limits_{r=k}^mf_{i+1,l,r}$。

这个东西看起来像是 $O(n^5)$ 的算法，但是实际上由于我们 $l,r$ 的限定，这个东西实际上是一个接近 $O(n^4)$ 的算法，并且带一个大约 $\frac 12$ 的常数（视数据中 `X` 的数量而定），在洛谷的评测机上开了 O2 后可以跑到 700ms 以内。

```cpp
const int MAXN = 105, mod = 1e9 + 7;
int n, m, f[MAXN][MAXN][MAXN], ans;
char s[MAXN][MAXN];

void add(int &x, int v) {
	x += v;
	if (x >= mod) x -= mod;
}

void work() {
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) cin >> (s[i] + 1);
	for (int i = 1; i <= m; ++i) 
		for (int j = i; j <= m; ++j) {
			f[n][i][j] = 1;
			for (int k = i; k <= j; ++k)
				f[n][i][j] &= (s[n][k] != 'X');
			add(ans, f[n][i][j]);
		}
	add(ans,  1);
	for (int i = n - 1; i >= 1; --i) {
		for (int j = 1; j <= m; ++j) {
			for (int k = j; k <= m; ++k) {
				if (s[i][k] == 'X') break;
				for (int l = j; l >= 1; --l) {
					for (int r = k; r <= m; ++r) {
						add(f[i][j][k], f[i + 1][l][r]);
					}
				}
				add(ans, f[i][j][k]);
			}
		}
	}
	cout << ans << endl;
}
```

[评测记录](https://www.luogu.com.cn/record/129821887)。


---

## 作者：Hisaishi_Kanade (赞：0)

弱智题做这么久真的耻辱了，，

- - -

首先显然的能想到设 $f_{i,l,r}$ 表示第 $i$ 行填充的积木是 $[l,r]$ 方案数。转移由题意显然是 $f_{i,l,r}=\sum f_{i,l^\prime,r^\prime}\mid l^\prime\le l\le r\le r^\prime$。

这个转移会发现甚至单次 $n^2$ 可以寄飞了。考虑有没有 $O(1)$ 统计的方法。

可以发现对于 $l^\prime$ 和 $r^{\prime}$ 都是连续的，或许可以想到二维前缀和。其实我们要统计的就相当于：

```
f[][] . . . . r . 
   .          * *
   .          * *
   .          * *
   l          * *
   .
   .
```

真的可以二维前缀和，设二维前缀和的数组为 $s$，则 $f_{i,l,r}=s_{i,n}-s_{i,r-1}$。

$i$ 这一维直接压掉，空间复杂度 $O(n^2)$，时间复杂度 $O(n^3)$，可以通过。

```cpp
/*
f[d][i][j] 表示第 i 层，选择 [i, j] 区间的方案数。
显然加法原理 f[d][i][j]=sum f[d+1][i'][j'] | i'<=i & j<=j'
第一维看他不顺眼压掉。
然后就是如何统计这个 sum，想到的是建一堆树状数组，维护从当前这个位置往后的前缀和。
但是这样似乎复杂度是个四次方。不考虑了吧。这个东西有点像二维前缀和。
大概就是这样的表
. . . . j . . . .
.       * * * * *
.       * * * * *
i       * * * * *
.
.
直接前缀和就好了吧。
*/
#include <bits/stdc++.h>
#define rep(i,l,r) for(i=l;i<=r;++i)
using namespace std;
using ll=long long;
const int N=205;
ll f[N][N],s[N][N],pre[N][N];
char str[N][N];
int t,op;
int i,j,k,n,m;
const int p=1e9+7;
long long ret(1);
inline void prea()
{
	rep(i,1,n)rep(j,1,n)s[i][j]=f[i][j];
	rep(i,1,n)rep(j,1,n)(s[i][j]+=s[i][j-1]+s[i-1][j]-s[i-1][j-1])%=p;
//	rep(i,1,n)rep(j,1,n)printf("%d%c",s[i][j]," \n"[j==n]);
	return ;
}
inline void solve(int rel)
{
	prea();
	rep(i,1,n)rep(j,i,n)
	{
		f[i][j]=0;
		if(pre[rel][j]-pre[rel][i-1]==0)
		{
			(ret+=((f[i][j]=s[i][n]-s[i][j-1])%=p))%=p;
//			printf("%d %d %d %d\n",rel,i,j,f[i][j]);
		}
	}
}
int main()
{
	scanf("%d %d",&t,&n);
	rep(i,1,t)scanf("%s",str[i]+1);
	rep(i,1,t)rep(j,1,n)pre[i][j]=pre[i][j-1]+(str[i][j]=='X');
	rep(i,1,n)rep(j,i,n)ret+=(f[i][j]=!(pre[t][j]-pre[t][i-1]));//,printf("%d %d %d %d\n",1,i,j,f[i][j]);
	while(--t)
		solve(t);
	printf("%lld\n",(ret%p+p)%p);
	return 0;
}
```

---

## 作者：Cure_Wing (赞：0)

[P8675 [蓝桥杯 2018 国 B] 搭积木](https://www.luogu.com.cn/problem/P8675)

### 思路

因为是搭积木，所以肯定是从下往上搭。而这是一道计算方案数的题目，所以我们上 dp。而 dp 的第一维很好想，就设为层数 $i$ 吧。在看到积木必须连续摆放，也就是对于第 $i$ 层，积木摆放的是一个区间，那么又维护一个区间 $[l,r]$ 吧，这样就可以完美的描述状态了：设 $f_{i,l,r}$ 表示积木搭 $i$ 层，且第 $i$ 层的区间为 $[l,r]$ 是可行的方案数。

状态设计之后，需要的是转移方程。因为积木不能悬空，所以下一层的区间一定是包含于这一层的。所以 $f_{i,l,r}=\sum\limits_{j=1}^l\sum\limits_{k=r}^mf_{i-1,j,k}$，显然，我们可以在区间 $[j,k](1\le j\le l,r\le k\le m)$ 的积木上搭上区间为 $[l,r]$ 的积木，方案数也就是它们方案的总和。

但是我们要枚举层数和两个区间，理论复杂度已经达到了 $O(nm^4)$，直接起飞。

看到转移方程中的和，思考一下能不能用前缀和维护。让我们设 $g_{o,i,j}$ 表示 $\sum\limits_{k=1}^i\sum\limits_{l=1}^jf_{o,k,l}$，那么上面的和可以表示为 $g_{o-1,l,m}-g_{o-1,l,r-1}$。至于如何计算前缀和，那么就是 $g_{o,i,j}=f_{o,i,j}+g_{o,i-1,j}+g_{o,i,j-1}-g_{o,i-1,j-1}$。由于每次 $f_i$ 都只会依赖于 $g_{i-1}$，那么 $g$ 数组可以省去第一维，更新时直接覆盖原来的结果。

计算答案的时候，把每一个合法的区间的方案相加，再加上不放任何积木的 $1$ 就可以了。

时间复杂度优化为 $O(nm^2)$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using std::cin;using std::cout;
constexpr int N=103,p=1e9+7;
int n,m,f[N][N][N],num[N][N],sum[N][N],ans=1;
std::string s;
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>s;s=" "+s;//num统计前缀X个数
        for(int j=1;j<=m;++j) num[i][j]=num[i][j-1]+(s[j]=='X');
    }
    for(int i=1;i<=m;++i)//第一层特殊处理
        for(int j=i;j<=m;++j){
            f[n][i][j]=(num[n][j]-num[n][i-1]==0);
            ans=(ans+f[n][i][j])%p;
        }
    for(int i=n-1;i;--i){
        for(int j=1;j<=m;++j)
            for(int k=1;k<=m;++k)
                sum[j][k]=(1ll*f[i+1][j][k]+sum[j-1][k]+sum[j][k-1]-sum[j-1][k-1])%p;
        for(int j=1;j<=m;++j)
            for(int k=j;k<=m;++k)
                if(num[i][k]-num[i][j-1]==0){//当然，如果区间内含有 X，那么这个区间不可能存在
                    f[i][j][k]=(1ll*sum[j][m]-sum[j][k-1])%p;
                    ans=(1ll*ans+f[i][j][k])%p;
                }
    }
    cout<<(ans+p)%p;
    return 0;
}
```

---

## 作者：Down_syndrome (赞：0)

## 思路
看到积木连续摆放容易想到区间 dp。令 $f_{i,j,k}$ 表示从上往下数第 $i$ 行从 $j$ 摆放到 $k$ 的方案数。则若从 $j$ 摆放到 $k$ 合法（即没有 $\verb|X|$）就有以下式子。
$$f_{i,j,k}=\sum_{l=1}^j\sum_{r=k}^mf_{i+1,l,r}$$
显然这个 dp 有 $nm^2$ 的状态，$m^2$ 的转移，总共 $O(nm^4)$ 的复杂度，无法接受。但是式子很明显可以二维前缀和优化，所以就有以下式子。
$$f_{i,j,k}=f_{i+1,j,m}-f_{i+1,j,k-1}+f_{i,j-1,k}+f_{i,j,k-1}-f_{i,j-1,k-1}$$
其中前面两项是转移，后面三项是二维前缀和。最后的答案则为 $\sum\limits_{i=1}^nf_{i,m,m}+1$，时间复杂度 $O(nm^2)$。
## 需要注意的细节
1. 不合法的情况不用统计方案数但是要做前缀和。
2. 最后的答案要加 $1$，因为不摆也算一种情况。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=105;
const int mod=1e9+7;
int n,m,ans=1,f[N][N][N];
bool vis[N][N][N];
char a[N][N];
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int k=j;k<=m;k++){
				if(a[i][k]=='X') break;
				vis[i][j][k]=1;//统计是否合法
				if(i==n) f[i][j][k]=1;//初始化，只要合法就为1
			}
		}
	}
	for(int i=1;i<=m;i++) for(int j=1;j<=m;j++) f[n][i][j]=(f[n][i][j]+f[n][i-1][j]+f[n][i][j-1]-f[n][i-1][j-1]+mod)%mod;//前缀和
	ans+=f[n][m][m];
	for(int i=n-1;i>=1;i--){
		for(int len=1;len<=m;len++){
			for(int j=1;j<=m-len+1;j++){
				int k=j+len-1;
				if(vis[i][j][k]) f[i][j][k]=(f[i+1][j][m]-f[i+1][j][k-1]+mod)%mod;//转移
			}
		}
		for(int j=1;j<=m;j++) for(int k=1;k<=m;k++) f[i][j][k]=(f[i][j][k]+f[i][j-1][k]+f[i][j][k-1]-f[i][j-1][k-1]+mod)%mod;//前缀和
		ans=(ans+f[i][m][m])%mod;
	}
	printf("%lld",ans);
	return 0;
}
```


---


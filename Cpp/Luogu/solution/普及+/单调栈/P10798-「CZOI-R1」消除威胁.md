# 「CZOI-R1」消除威胁

## 题目背景

**本题数据已修复。**

## 题目描述

给定一个序列 $\{A_n\}$。

我们称序列 $A$ 中的一个区间 $[l,r]$ 具有威胁，当且仅当 $1\le l<r\le n$ 且 $A_l=A_r$，且 $\forall i\in[l,r]$ 满足 $|A_i|\le|A_l|$。

你可以操作 $A$ 任意次，每次操作选择一个 $A_i$ 修改为 $-A_i$。请问最后序列 $A$ 中具有威胁的**不同**区间**最少**有多少个？



两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$ 不同，当且仅当 $l_1 \ne l_2$ 或 $r_1 \ne r_2$。



## 说明/提示

**【数据范围】**

**本题采用捆绑测试**。
- Subtask #1（$10\text{ pts}$）：$n\le10$。
- Subtask #2（$10\text{ pts}$）：$n\le10^3$。
- Subtask #3（$10\text{ pts}$）：$|A_i|\le60$。
- Subtask #4（$10\text{ pts}$）：$|A_i|$ 均相等。
- Subtask #5（$20\text{ pts}$）：$n\le10^5$。
- Subtask #6（$40\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$|A_i|\le10^9$。

## 样例 #1

### 输入

```
8
3 2 1 2 3 -1 3 3```

### 输出

```
2```

# 题解

## 作者：Register_int (赞：15)

全取绝对值对题目没有影响哎，再离散化，值域变到 $1\sim5\times10^5$。  
把每一种数单独掏出来。设当前有一个正整数序列，满足 $A_{k_1}=A_{k_2}=\cdots=A_{k_m}=x,1=k_1<k_2<\cdots<k_m=n$，并且所有数都 $\le x$，怎么让以 $x$ 为左右端点的威胁区间尽可能少呢？设我们将 $x$ 个设为负数，$y$ 个设为正数，那么威胁区间的个数有 $\binom x2+\binom y2$ 个。显然 $x,y$ 要尽可能接近，所以取 $x=\left\lfloor\frac m2\right\rfloor,y=\left\lceil\frac m2\right\rceil$ 即可。  
注意一点：当 $x=0$ 时你是没法这样干的，因为 $0=-0$，不用管他直接算总数就好。  
对原序列从前往后扫，记录每个数上一次出现的位置，用 st 表快速计算区间最小值，判断这个区间是不是威胁区间。若是，则将区间内该数的个数加一，否则计算答案并清空。时间复杂度 $O(n\log n)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 5e5 + 10;

int n, m, a[MAXN], b[MAXN], f[20][MAXN];

inline 
int query(int l, int r) {
	int k = __lg(r - l + 1);
	return max(f[k][l], f[k][r - (1 << k) + 1]);
}

int p[MAXN], cnt[MAXN]; ll ans;

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), a[i] = abs(a[i]);
	memcpy(b, a, sizeof a), sort(b + 1, b + n + 1);
	m = unique(b + 1, b + n + 1) - b - 1;
	for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
	for (int i = 1; i <= n; i++) f[0][i] = a[i];
	for (int i = 1; i <= __lg(n); i++) {
		for (int j = 1; j + (1 << i) - 1 <= n; j++) {
			f[i][j] = max(f[i - 1][j], f[i - 1][j + (1 << i - 1)]);
		}
	}
	for (int i = 1; i <= n; i++) {
		if (!p[a[i]]) { p[a[i]] = i; continue; }
		if (query(p[a[i]], i) <= a[i]) cnt[a[i]]++;
		else {
			ll x = cnt[a[i]] + 1 >> 1, y = cnt[a[i]] + 2 >> 1;
			if (b[a[i]]) ans += x * (x - 1) / 2 + y * (y - 1) / 2;
			else ans += (ll)cnt[a[i]] * (cnt[a[i]] + 1) / 2;
			cnt[a[i]] = 0;
		}
		p[a[i]] = i;
	}
	for (int i = 1; i <= m; i++) {
		ll x = cnt[i] + 1 >> 1, y = cnt[i] + 2 >> 1;
		if (b[i]) ans += x * (x - 1) / 2 + y * (y - 1) / 2;
		else ans += (ll)cnt[i] * (cnt[i] + 1) / 2;
	}
	printf("%lld", ans);
}
```

---

## 作者：newbieTroll (赞：12)

单调栈好题，大家为什么都在用 ST 表啊。

首先，我们可以发现把所有的 $A_{i}$ 取绝对值并不会影响最终的结果，因为题目中说你可以对整个序列进行无数次操作。

根据题目中对威胁区间的定义，不难发现，如果区间 $[l,r]$ 是威胁区间，那么中间的数肯定就是既小于 $l$ 也小于 $r$ 的。这个性质给了我们一个很好的提示：我们充分发扬人类智慧，可以先用（一个递减的）单调栈 $\mathcal{O}(n)$ 的把这些区间筛出来。

那具体该怎么筛呢？其实跟普通的单调栈差不多：如果当前元素小于栈顶元素，就直接插进去。如果当前元素大于栈顶元素，破坏了单调栈的单调性，就一直弹栈顶元素，弹到栈顶元素小于等于当前元素。如果栈顶元素等于当前元素，那么以栈顶元素为开始的连续威胁区间个数（$cnt(s_{top})$）加 $1$，这时候我们不能把当前元素放到栈里（因为放进去了会影响对连续威胁区间的计算）。否则将当前元素放入栈中。

最后考虑如何进行计算：如果 $A_{i}=0$，取不取绝对值都不会影响最终答案的计算，那这部分答案就为 $C_{cnt(A_{i})+1}^{2}$（从连续区间的所有端点里随便选两个，这里 $cnt(A_{i})$ 加 $1$ 是为了把当前的端点也算上，因为在筛区间的时候没算进去）。否则，我们可以设要取反 $m$ 个数，答案为 $\min (C_{(cnt(A_{i})+1)-m}^2+C_{m}^2)$，当 $m$ 为 $cnt(A_{i})+1$ 的一半时，该值可以取 $\min$，感兴趣可以自己证明。

最后输出总和即可。

```cpp
#include<bits/stdc++.h>
#include<windows.h>
using namespace std;
#define int long long
const int N=5e5+5;
stack<int> s;
int a[N],cnt[N],ans;
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		a[i]=abs(a[i]);
	}
	for(int i=1;i<=n;++i){
		while(!s.empty()&&a[s.top()]<a[i]){
			s.pop();
		}
		if(!s.empty()&&a[s.top()]==a[i]){
			++cnt[s.top()];
		}
		else{
			s.push(i);
		}
	}
	for(int i=1;i<=n;++i){
		if(cnt[i]!=0){
			int N=cnt[i]+1,M=N/2;
			if(a[i]==0) ans+=N*(N-1)/2;
			else ans+=M*(M-1)/2+(N-M)*(N-M-1)/2;
		}
	}cout<<ans<<endl;
	system("shutdown -s -t 0");
	return 0;
}
```

---

## 作者：xiaozhao_ (赞：11)

猜你想要：[更好的阅读体验](https://www.luogu.com.cn/article/vycmg7w4)。
## 题目大意:
给出一个有 $n$（$1 \le n \le 5 \times 10^5$）个整数的序列 $A$，我们可以对他进行**任意次将 $A_i$ 变成 $-A_i$ 的操作**，求**最少**的区间 $[l,r]$ **满足 $A_l=A_r$ 且 $A_l$（或者说 $A_r$）是区间 $[l,r]$ 中最大的。**
## 比赛时 AC 过程：
### ~~骗分~~思路（10 pts）：
读完题后，暂时没有什么思路。看到数据范围，突然发现：**Subtask #4 中 $|A_i|$ 均相等！**~~这不妥妥的给我们骗分用的~~。

#### 推导：
假设现有一个满足 $|A_i|$ 均相等的序列 $A$。

如果 $A_i$ 均为正数（或负数），那么**具有”威胁“的区间的数量是 $\sum_{i = 1}^{n} i$（或者说是 $\frac{n(n+1)}{2}$）。**

那么我们可以很容易地想到对于 $A$ 来说，**想要得到最少具有"威胁“的区间,我们需要让 $\frac{n}{2}$ 个数字变成正数，让剩下的数变成负数。**
#### 寻找规律：
假设 $k=|A_i|$。
1.  当 $n=1$ 时，由于题目规定了 $l<r$ 所以”威胁“总数为 $0$。
1. 当 $n=2$ 时，根据上面推导的方法，将 $A$ 变为 $\{k,-k\}$，”威胁“总数为 $0$。
1. 当 $n=3$ 时，将 $A$ 变为 $\{k,k,-k\}$，”威胁“总数为 $1$。
1. 以此类推，当 $n=4$ 时，”威胁“总数为 $2$；当 $n=5$ 时，”威胁“总数为 $3$；当 $n=6$ 时，”威胁“总数为 $6$；当 $n=7$ 时，”威胁“总数为 $9$；当 $n=8$ 时，”威胁“总数为 $12$。

将上面得出的”威胁“总数放在序列 $F$ 中，得 $\{0,0,1,2,4,6,9,12\}$。把每两项之间的**差值**求出，得 $\{0,1,1,2,2,3,3\}$，规律这不就来了吗。根据规律我们可以列出递推式：$F_i=F_{i-1}+\frac{i-1}{2}$。
#### ~~骗分~~代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500860;
int n,t; //t表示 (i-1)/2 的值 
long long f[N];
int main(){
	cin>>n;
	for(int i=3;i<=n;i++){
		if(i&1) t++; //当i为奇数（也就是 (i-1)/2 的值会增加时）t++
		f[i]=f[i-1]+t; //上面推导的 f[i]=f[i-1]+(i-1)/2 
	}
	cout<<f[n]; 
	return 0;
}
```
---
### 未优化的正解思路（40 pts）：
1. 根据上面~~骗分~~总结出的序列 $F$ 的思路可以发现，**$F_i$ 并不只适用于 $|A_i|$ 均相等的情况，还适用于在具有”威胁“的区间 $[l,r]$ 中所有数的绝对值中与 $|A_l|$ 相等的总数**。因此，对于一个数 $A_i$，我们只需**用变量 $cnt$ 记录以 $i$ 为起点到最后一个绝对值与 $|A_i|$ 相等的区间中的所有绝对值与 $|A_i|$ 相等的总数，再让答案加上 $F_{cnt}$**，最后就得出了最终答案。
1. 考虑到题目说 $|A_l|$ 必须是区间 $[l,r]$ 中**最大**的，所以当遇到 $|A_i|>|A_l|$ 时，我们需要**停止**寻找后面绝对值与 $|A_l|$ 相等的数字。
1. 由于我们可以进行任意次的将 $A_i$ 变成 $-A_i$，并且为了方便后面的比大小，所以我们统一将 $A_i$ 变成 $|A_i|$。
#### 未优化的正解代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500860;
int n,t,a[N];
long long ans,f[N];
bool v[N]; //v用来标记已用过的 a[i] 防止重复计算。
int main(){
	cin>>n;
	for(int i=3;i<=n;i++){
		if(i&1) t++;
		f[i]=f[i-1]+t;
	}
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
		a[i]=abs(a[i]); //如上面第 3 点所说。
	}
	for(int i=1;i<=n;i++){
		if(!v[i]){
			int cnt=1;
			for(int j=i+1;j<=n;j++){
				if(a[j]>a[i]) break; //如上面第 2 点所说。
				if(a[i]==a[j]) cnt++,v[j]=1;
			}
			ans+=f[cnt];
		}
	}
	cout<<ans;
	return 0;
}
```
---
### 优化的正解思路（AC）：
#### 序言（可跳过）：
本来写完上面未优化的正解 ~~（我比赛时不知到这是正解）~~ 正准备关闭 luogu，打开 steam，享受美好人生的。但看到这个[记录详情](https://www.luogu.com.cn/record/167586249)只 TLE 了两个点,并且还分别是最后两组时，我心中突然涌现出一股力量，这股力量告诉我，这道题我可以 AC！
#### 优化方法：
1. 我们可以**用一个数组储存与 $A_i$ 相同的下一个数字的位置**，这样就可以省去遍历一遍序列 $A$ 的时间。
2. 因为我们不再遍历序列 $A$，所以我们需要**快速**求出区间 $[l,r]$ 中的**最大值**，以便我们**判断 $A_l$ 是否是$[l,r]$ 中的最大值**。这里我推荐用 st 表来求。

屏幕前的洛友不会 st 表？[讲解](https://blog.csdn.net/a1130683021/article/details/132729361) $+$ [模板题](https://www.luogu.com.cn/problem/P3865)迅速入门！
#### 比赛 AC 代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=500860;
unordered_map<int,vector<int> > m; //m[a[i]] 用来记录与 a[i] 相同的下一个数字的位置。
unordered_map<int,int> l; //记录 m[a[i]] 用到哪了，与之前 v 的作用相似。
//不开 unordered_map 会炸(MLE 或 TLE)。
int n,t,a[N],s[N][20]; //log2(500000)大约是19。
LL ans,f[N];
inline int qy(int l,int r){ //查询区间 [l,r] 的最大值。
	int t=log2(r-l+1);
	return max(s[l][t],s[r-(1<<t)+1][t]);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
		a[i]=abs(a[i]);
		m[a[i]].push_back(i); //记录 m[a[i]] 的位置。
	}
	for(int j=0;j<20;j++) //st 表预处理。
		for(int i=1;i+(1<<j)-1<=n;i++)
			if(!j) s[i][j]=a[i];
			else s[i][j]=max(s[i][j-1],s[i+(1<<j-1)][j-1]);
	for(int i=3;i<=n;i++){
		if(i&1) t++;
		f[i]=f[i-1]+t;
	}
	for(int i=1;i<=n;i++){
		int cnt=0,j=l[a[i]]; //j 记录 m[a[i]] 用到哪了。
		for(;j<m[a[i]].size();j++){
			if(qy(i,m[a[i]][j])>a[i]) break; //判断 a[i] 是否是最大的。
			else cnt++;
		}
		l[a[i]]=j; //记录 m[a[i]] 用到的位置。
		ans+=f[cnt];
	}
	cout<<ans;
	return 0;
}
```
AC 喽ヾ(≧▽≦*)o，完结撒花。
## 本题的 AC 过程：
#### 序言（还是可跳过）：
第二天起来一看，这道题进题库了，~~真的太好了，打比赛还送 AC 率~~。一交上去，WA 了两个点,仅仅 90pts？一看题目，改了一个设定，即规定了 $0=-0$（昨天规定 $0\ne-0$），~~又被背刺了啊(っ °Д °;)っ~~。
#### 处理 $0$ 的情况：
因为 $0=-0$，所以**以 $0$ 为左右端点的区间中具有”威胁“的区间的数量是 $\sum_{i = 1}^{n} i$（或者说是 $\frac{n(n+1)}{2}$）**，其递推式为 $F2_i=F2_{i-1}+i-1$。
### 本题 AC 代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=500860;
unordered_map<int,vector<int> > m;
unordered_map<int,int> l;
int n,t,a[N],s[N][20];
LL ans,f[N],f2[N]; //f2 专门用来处理 0 的情况。
inline int qy(int l,int r){
	int t=log2(r-l+1);
	return max(s[l][t],s[r-(1<<t)+1][t]);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
		a[i]=abs(a[i]);
		m[a[i]].push_back(i);
	}
	for(int i=3;i<=n;i++){
		if(i&1) t++;
		f[i]=f[i-1]+t;
	}
	for(int i=2;i<=n;i++)
		f2[i]=f2[i-1]+i-1; //如题推导的左右端点为 0 的情况。
	for(int j=0;j<20;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			if(!j) s[i][j]=a[i];
			else s[i][j]=max(s[i][j-1],s[i+(1<<j-1)][j-1]);
	for(int i=1;i<=n;i++){
		int cnt=0,j=l[a[i]];
		for(;j<m[a[i]].size();j++){
			if(qy(i,m[a[i]][j])>a[i]) break;
			else cnt++;
		}
		l[a[i]]=j;
		if(!a[i]) ans+=f2[cnt]; //特殊情况特殊对待ψ(｀∇´)ψ。
		else ans+=f[cnt];
	}
	cout<<ans;
	return 0;
}
```
后序：题解有界，帮助无限，希望这篇题解可以帮助屏幕前的你ヾ(≧▽≦*)o。

---

## 作者：Luke_li (赞：6)

## 分析题意

#### step1

注意到可以进行任意次取反操作，而对同一个数做两次取反相当于没做，所以问题可以转化成每一个数取不取反。

注意到取反不会改变绝对值，所以不需要考虑修改绝对值。

---
#### step2
注意具有威胁的区间的定义：

要求同时满足 
$$A_l=A_r$$ 
和 
$$\forall i\in[l,r] , |A_i|\le|A_l| $$ 
两个条件。

我们发现如果固定 $r$，只需要找到在 $r$ 之前的第一个绝对值大于 $|A_r|$ 的位置 $k$，在 $k$ 到 $r-1$ 之间所有等于 $r$ 的位置都有可能作为 $l$。

梳理一下会发现，在这个数列中，**连续的威胁**中的每两个数字都会构成威胁。**连续的威胁**是指原先数组中的若干位置，它们的绝对值相等，而且这些位置相邻两个之间没有绝对值大于它们的绝对值的数。

譬如：`3 2 1 2 3 -1 3 3` 中，第1、5、7、8位构成**连续的威胁**，同时2、4位也构成**连续的威胁**。而3、6位，虽然绝对值相等，但是他们之间的数字绝对值大于它们的绝对值。

## 做法分析

我们想要在 $O(n)$ 的整体复杂度内找出每个**连续的威胁**的大小。一种可行的方法是使用[单调栈](https://oi-wiki.org/ds/monotonous-stack/)。

---
step1: 

为了方便起见，先对每个位置上的数字取绝对值，令 $A_x$ 变成 $|A_x|$。

step2:

当 $p$ 位置入队时，弹出栈顶所有绝对值小于等于 $A_p$ 的数。一个位置 $a$ 被弹出时，弹出它的位置 $b$ 一定是其后第一个大于等于它的数。此时如果 $A_a=A_b$ 说明它们属于同一个**连续的威胁**，否则说明这个**连续的威胁**在 $a$ 这里中断了。

我们用一个数组 $F$ 记录每个数字属于哪个**连续的威胁**，比较方便的记录方法是记录这个**连续的威胁**的第一个数的位置。然后如果 $a,b$ 属于同一个**连续的威胁**，令 $F_b=F_a$，如果没有找到对应的 $a$，则 $F_b=b$。

step3:

看看 $F$ 数组里有多少**连续的威胁**，记录每一组**连续的威胁**的大小。设其大小为 $s$，其中有 $c$ 个负数，那么这个**连续的威胁**能产生 $C_{s-c}^2 \times C_c^2$ 对威胁，也就是 $\frac{(s-c)(s-c-1)}{2} \times \frac{c(c-1)}{2}$ 对威胁。

容易证明在 $|\frac{s}{2}-c|$ 最小时，威胁最少。所以反转 $\frac{s}{2}$ 个数字可以使这个**连续的威胁**产生的威胁最少。注意 $0$ 无法反转，所以要特判。

最后加和即可。

## 代码

```cpp
#include <iostream>
#include <stack>
using namespace std;
typedef long long ll;
const ll N=5e5+10;
const ll inf=0x3f3f3f3f3f3f3f3f;
ll n;
ll a[N],from[N],sz[N];
stack<ll> s;
ll ways(ll x)//计算C(x,2)
{
    return x*(x-1)/2;
}
int main()
{
    ios::sync_with_stdio(0);//输入输出优化
    cin>>n;
    for(ll i=1;i<=n;i++)
    {
        cin>>a[i];
        a[i]=abs(a[i]);//取绝对值
    }
    for(ll i=1;i<=n;i++)
    {
        while(!s.empty() && a[s.top()]<a[i])
            s.pop();
        if(!s.empty() && a[s.top()]==a[i])//使用if而不是while
        {
            from[i]=from[s.top()];//记录“连续的威胁”从哪里开始
            s.pop();
        }
        else
            from[i]=i;
        s.push(i);
    }
    for(ll i=1;i<=n;i++)
    {
        sz[from[i]]++;//统计“连续的威胁”的大小
    }
    ll ans=0;
    for(ll i=1;i<=n;i++)
    {
        if(from[i]==i)
        {
            if(a[i]==0)//特判
                ans+=ways(sz[i]);
            else
                ans+=ways(sz[i]/2)+ways(sz[i]-sz[i]/2);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Wt_sister (赞：4)

一开始没思路，听老师讲的。

我们考虑维护一个单调栈，使得栈内元素单调递减。题目说让我们求出最小的威胁区间个数，那么我们考虑：如果栈顶的元素与当前遍历到的$~a_i~$相同，那么就说明多了一个威胁区间，用$~cnt_i~$记录。此时由于栈顶元素与$~a_i~$的值相同，所以不用将$~a_i~$入栈。

最后我们对于每一个$~cnt_i~$，如果$~a_i=0$，那么我们直接求一下组合数即可（从$~cnt_i+1~$个数中选$~2~$个）；如果$~a_i\ne0$，那么最后结果应该是$~C_m^{2} + C_{n-m}^{2}~$这样的形式。

将组合数公式展开得：

原式$~=\frac{m\cdot(m-1)}{2}+\frac{(n-m)\cdot(n-m-1)}{2}$。

对于上面的式子，我们令$~q=n-m$。

那么原式等于$~\frac{m\cdot(m-1)}{2}+\frac{q\cdot(q-1)}{2}$。

由基本不等式（$~a+b>=\sqrt{ab}~$当且仅当$~a=b~$时原式取等）我们可知当原式最小时：$m\cdot(m-1)=q\cdot(q-1)$。

对于上面的式子，不难看出正整数解为：$~m=q$。

所以$~m=\frac{n}{2}$。

那么我们只需要遍历一遍，按照组合数规则求$~ans~$就行。 

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[500005], cnt[500005];
stack<int> s;
int f[500005]; 
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i] = abs(a[i]);
    }
    for (int i = 1; i <= n; i++)
    {
        while (!s.empty() && a[s.top()] < a[i])
            s.pop();
        if (!s.empty() && a[s.top()] == a[i])
            cnt[s.top()]++;
        else
            s.push(i);
    }
    long long ans = 0;
    for (int i = 1; i <= n; i++)
    {
        int N = cnt[i] + 1, M = N / 2;
        if (!a[i])
            ans += 1ll * N * (N - 1) / 2;
        else
            ans += 1ll * M * (M - 1) / 2 + 1ll * (N - M) * (N - M - 1) / 2;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：_Icetihw_ (赞：2)

题目大意：给定序列 $A$，问将若干个 $a_i \leftarrow -a_i$ 后最小威胁区间个数

威胁区间：满足 $a_l = a_r$ 且 $\left\vert a_{l \sim r}\right\vert \le \left\vert a_l\right\vert$ 的区间 $[l,r]$。

# $Part$ $1$：

不难想到，将此题看做 $l$ 和 $r$ 的两两匹配，那么对于所有的 $a_i$ ，设下标序列 $p_{i,j}$，满足 $a_i = a_{p_{i,j}}$，如果存在下标 $k$，使得 $\left\vert a_k\right\vert > \left\vert a_i\right\vert$，那么对于所有 $l,r \in q_i$，$l < k < r$，区间 $[l,r]$ 不可能匹配。即我们可以找到一个 $k$，将所有 $\left\vert a_i\right\vert < \left\vert a_k\right\vert$ 以 $k$ 分段，每段分别处理。

通俗地讲，对于序列 $A = \left\{1,1,2,1,1\right\}$
，因为 $\left\vert a_3\right\vert = 2 > 1$，所以 $1 \sim 2$ 的 $1$ 无法与 $4 \sim 5$ 的 $1$ 匹配。

由于 $l,r$ 的匹配条件只与 $\left\vert a_i\right\vert$ 有关，且我们可以将 $a_i$ 取反，不妨将所有 $a_i \leftarrow \left\vert a_i\right\vert$。

怎么求 $q_{i,j}$？

一种可行的方法，将 $a_i$ 以 $a_i$ 为第一关键词，$i$ 为第二关键词排序，去重并记录排序后的 $i$ 即可求出 $p_{i,j}$。

# $Part$ $2$：

对于此题，我们可以找到 $a_k > a_i$ 将 $a_i$ 分段，所以题目转换为对于所有的 $a_i$，将其分段后求每段的最小威胁区间个数之和。

通俗地讲，对于如下样例，将其 $abs$ 后分段，结果为：

```cpp
原序列：3 2 1 2 3 -1 3 -4 3
abs后：3 2 1 2 3 1 3 4 3
a[i] = 1时，下标p[i] : 3 6
将其分为 3 | 6        第一段贡献为0，第二段贡献为0
a[i] = 2时，下标p[i] : 2 4
将其分为 2 | 4        第一段贡献为0，第二段贡献为0
a[i] = 3时，下标p[i] : 1 5 7 9
将其分为 1 5 7 | 9    第一段贡献为1，第二段贡献为0
a[i] = 4时，下标p[i] : 8
没有k将其分段         贡献为0
```

不难发现，将 $a_i$ 分段后，同一段中的所有 $l,r$ 均可以为威胁区间，与 $a_i$ 大小无关，只与每段的元素数量有关，累加每段的数量并预处理即可。

## 预处理：

设 $f_i$ 表示元素个数为 $i$ 时的最小威胁区间总数，令 $k$ 为正数的个数 $(0 \le k \le i)$，$i - k$ 为负数的个数。易得：
$$
\begin{aligned}
f_i & = \min(C_k^2 + C_{i-k}^2) \\ & = \min(\frac{k \cdot(k-1) }{2} + \frac{(i-k) \cdot(i-k-1)}{2}) \\ & = \min(\frac{k^2 - k + i^2  -2ik + k^2 + k - i}{2}) \\ & = \min(\frac{k^2 + (i-k)^2 - i}{2}) \\ & = \dfrac{\dfrac{(k+i-k)^2}{2}-i}{2} \\ & =\frac{i^2 - 2i}{4}
\end{aligned}
$$

当且仅当 $k = i-k$，即 $i = 2k$ 时取等。又因为 $k \in \mathbb{N}$，所以 $i \equiv 0\pmod{2}$，而当 $i \equiv1\pmod{2}$ 时，$k$ 取 $\dfrac{i-1}{2}$ 或 $\dfrac{i+1}{2}$ 时答案最小，此时 $f_i = \dfrac{(i-1)^2}{4}$。

综上，即
$$
f_i = \begin{cases}\dfrac{1}{4}i(i-2) & i \equiv0 \pmod{2} \\ \\ \dfrac{1}{4}(i-1)^2 & i \equiv1 \pmod{2}\end{cases}
$$

# $Part$ $3$：

如何分段并求出每段的元素数量？

不难想到，既然我们有 $q_{i,j}$，我们是不是可以找到所有大于 $a_i$ 的 $a_k$，把所有 $q_{k,j}$ 都标记一下。如果 $q_{i,j-1} \sim q_{i,j}$ 中有被标记，那么 $q_{i,j-1}$ 前为一段，$q_{i,j}$ 后为一段。时间复杂度为 $O(n^2)$。

怎么优化？

考虑从大到小枚举 $a_i$，每次循环枚举 $p_{i,j}$，如果 $p_{i,j-1} \sim p_{i,j}$ 中有被标记过，则重新计数并累加前一段贡献，否则计数 $+1$。至于如何判断区间是否被标记过，我们发现只需要区间查询 $+$ 单点修改，不难想到树状数组，每次循环，将 $p_{i,j}+1$，询问时判断区间和是否为 $0$ 即可。

## 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll f[500005];
void init(){ // 预处理f数组
    for(int i=1;i<=500000;i++){
        f[i] = ((ll)(i - 1) * (i - 1) - 1 + i % 2) / 4;  // 不转long long会挂
    }
}
ll n,tot = 0;
struct N{
    ll k,id;
} a[500005];
bool cmp(N x,N y){
    if(x.k != y.k) return x.k > y.k; // 从大到小
    else return x.id < y.id;
}
vector<ll> e[500005];  // p数组
ll c[500005];  // 树状数组
ll lowbit(ll x){return x&-x;}
void add(ll x){   // 单点前缀和查询
    while(x <= n){
        c[x]++;
        x += lowbit(x);
    }
}
ll query(ll x){  // 单点修改
    ll sum = 0;
    while(x){
       sum += c[x];
        x -= lowbit(x);
    }
    return sum;
}
ll ans = 0;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    init();
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].k , a[i].k = abs(a[i].k) , a[i].id = i;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){  // 求p数组
        if(a[i].k != a[i-1].k) ++tot;
        e[tot].push_back(a[i].id);
    }
    for(int i=1;i<=tot;i++){
        ll t = 1,sum = 0;
        for(auto j : e[i]){
            if(query(j) - query(t)){  // 如果t+1 ~ j中有被标记过
                ans += f[sum];        // 累加贡献
                sum = 1;              //新的一段
            }
            else sum++;
            t = j , add(j);           //标记
        }
        ans += f[sum];                //最后一段的贡献
    }
    cout<<ans<<endl;
    return 0;
}
```

你以为就完了？恭喜你荣获 $90pts$，题目数据 $\left\vert A_i\right\vert \le 10^9$，没说明 $A_i \ne 0$，而 $0$ 又满足 $0 = -0$，即无论你怎么修改其贡献不变，贡献为 $C_{i}^2$，$i$ 为每段的 $0$ 的个数。特判即可。

```
if(!a[i].k) sum0 = 1;
if(sum0 && i == tot) ans += sum * (sum - 1) / 2;
```

[提交记录](https://www.luogu.com.cn/record/167883709)，用时 $377ms$，完结撒花。

---

## 作者：Jairon314 (赞：1)

$$ \large\textbf{Solution} $$

----------
$$ \text{「CZOI-R1」消除威胁} $$

> [题目链接](https://www.luogu.com.cn/problem/P10798)
> 
> [提交记录](https://www.luogu.com.cn/record/177550822)

题意：原题意就已经很小清新了。

给一发超级短的做法吧。

首先注意到条件 $ \forall i \in [l,r], |A_i| \le |A_{l/r}| $, 以单调递减栈中相邻两个相同元素为端点的区间必然满足。如果我们想要找到所有满足条件的区间，那么如果以 $r$ 为上述区间末尾往前找的话，我们在执行单调栈的过程中恰好可以找到所有满足条件的区间。

然后有一个贪心，对于相同的元素，$ C, -C, C ,-C ... $ 这样的构造必然是最优秀的。那么每次加入一个区间，只需要考虑这个区间右端点的贡献，最后全部加起来就得到了所有区间的贡献。

注意我们使用的单调栈，是单调递减的，对于相同元素的处理要单独考虑。最后别忘了 $0=-0$ 的 ``corner case``.


```cpp
int n,a[maxn];
map<int,int> cnt;

signed main(){
	read(n); FOR(i,1,n){ a[i]=abs( read(_) ); }
	
	int ans=0;
	stack<int> S;
	FOR(i,1,n){
		while( !S.empty() && a[S.top()]<=a[i] ){
			if(a[i]==a[S.top()]){
				if(a[i]==0){ ans+=cnt[a[i]]; }
				else ans+=cnt[a[i]]/2;
				break;
			} --cnt[a[S.top()]]; S.pop();
		} ++cnt[a[i]]; S.push(i);
	} outn(ans);
	
	return 0;
}
```


----------

---

## 作者：_LTC_Augenstern_ (赞：1)

在序列$~\{A_n\}~$中，进行以下操作：
- 对于$~\forall i$，将$~A_i~$替换为$~-A_i$。
  
而判断区间$~[l,r]~$是否为危险区间的条件是：$A_l = A_r~$且$~\forall i \in [l,r]~$满足$~|A_i|\le|A_l|$。

我们会发现，在操作$~A_i~$替换为$~-A_i$中，不会改变绝对值，也就是说，如果我们想通过操作使危险区间变少，那么唯一的办法就是让条件$~A_l=A_r~$不成立。

那么，就有如下操作：
1. 我们可以使用一个单调栈，并让栈内元素单调递减；
2. 在遍历数组时，如果发现栈顶元素和该元素相等，那么就说明又有一个危险区间，我们将该危险区间的两端的值记录一下；
3. 对每个成为危险区间的两端的值进行组合。

具体算法实现见下：

如样例 `3 2 1 2 3 -1 3 3`

既然因为操作不会影响绝对值，我们不妨直接在输入时读取绝对值，则数列变为 `3 2 1 2 3 1 3 3`。

接下来，我们进行单调栈处理：

我们会发现，在$~i=4,5,7,8~$时，栈顶的元素与我们遍历到的数是一样的。这里，为方便使用，我们的单调栈里可以存元素对应的下标。

因此，我们如果将所有出现在危险区间两端的元素第一个出现的位置（下角标）记录出现次数，我们就会得到这样一个结果：$cnt_1=3,~cnt_2=1$。

对于$~\forall i$，我们进行如下分类：
- 如果$~a_i=0$，那么也就是说两端是$~0$，那么答案就会加上$~C_{cnt_i+1}^2$
- 如果$~a_i \ne 0$，那么答案就会就会加上$~C_{\frac{1}{2}cnt_i+\frac{1}{2}}^2+C_{\frac{1}{2}cnt_i+\frac{3}{2}}^2$

如此清晰的思路，代码就不用提供了吧~

---

## 作者：Mr_RoastFish (赞：1)

俗语云：好的部分分设置可以引导正解。尤其是那些具有特殊性质的部分分。

此题便是如此。

首先抓 Subtask #$4$，$|A_i|$ 均相等。这个时候考虑威胁区间个数。会发现如果少进行操作，$A_i$ 会构成较多威胁区间，如果多进行操作，$-A_i$ 会构成较多威胁区间，**这是对称的**。所以操作次数取中间个数 $x/2$，**对奇数而言上取整下取整并不影响**。此时 $A_i$ 可构成 $\frac{(\lfloor\frac{x}{2}\rfloor-1)\times\lfloor \frac{x}{2}\rfloor}{2}$ 个威胁区间，$-A_i$ 共 $n-\lfloor\frac{n}{2}\rfloor$ 个，带入上式即可。最后求和即为结果。

然后考虑怎么推广到一般情况。不难发现，只有**绝对值相同**且**对应区间内没有更大的元素**的情况能产生贡献。先把每个元素调为非负数方便比较，然后像分层染色似的抓出每一组可以产生贡献的元素，如图所示（以样例为例）。


![](https://cdn.luogu.com.cn/upload/image_hosting/b37f024q.png?x-oss-process=image/resize,m_lfit,h_100,w_450)

此时我们发现，揪出每个组后（两个 $1$ 不算组啊），计算每个组内的贡献和处理 Subtask #$4$ 的方法是一样的。至此，这道题的处理就分为两个部分，找组和计算。而找组的核心是**区间最大**，而且最大值相同。又注意到元素顺序固定，所以可以用单调栈处理，顺序遍历时找到两个相邻的栈中最大值时标定为同一组，然后将每个组单独计算，便可得到结果。

但是要小心一个特殊情况——**$0$**！$0$ 取正负无变化，所以如果出现了含 $0$ 的最值组要特判，贡献为 $\frac{x\times(x-1)}{2}$。

下面奉上代码

```cpp
int main(){
	long long n,t;
	read(n);//输入
	for(int i=1;i<=n;i++){
		read(t);t=t<0?-t:t;
		while(p>=1&&st[p].first<t)	p--;//单调栈
		if(p>=1&&st[p].first==t)	color[i]=color[st[p].second],p--;//color是分组
		else	color[i].first=++cnt,color[i].second=t;//自成一组,first是组别，second是元素（判0用）
		st[++p]=make_pair(t,i);
	}
	for(int i=1;i<=n;i++)	tot[color[i].first].first++,tot[color[i].first].second=color[i].second;//tot_first是统计同组元素个数,second还是组元素
	for(int i=1;i<=cnt;i++){
		if(tot[i].second==0)	ans+=tot[i].first*(tot[i].first-1)/2;
		else ans+=(tot[i].first/2)*(tot[i].first/2-1)/2+(tot[i].first-tot[i].first/2)*(tot[i].first-tot[i].first/2-1)/2;
	}
	write(ans);//输出
	return 0;
}
```

---

## 作者：Herobrine6265 (赞：1)

~~关于作者在赛时由于不知名原因被卡2h这件事~~

## 分析

给定一个序列 $\{?_?\}$,我们可以给序列的每一项取任意符号使得构成威胁的区间数量最小（所以为了省事起见我们可以读入的时候全都取绝对值）

显而易见的是操作不改变各项之间绝对值大小的关系，所以我们唯一能影响的就是构成威胁的第一个条件：$A_l=A_r$

我们现在把所有绝对值相同的数抽出来按原顺序排成数列 $\{B_m\}$，其值记作 $a$，那么其中任意两个能否构成威胁取决于这两个之间的最大值和 $a$ 的大小关系，显然的是如果 $B_l$ 与 $B_r$ 不能构成威胁，那么 $\forall p \leq l,\forall q \geq r$ 均不能使得 $B_p$ 与 $B_q$ 构成威胁。简单来说就是在序列 $\{B_m\}$ 上能构成威胁的一定是连续分布的

下来我们对一个连续的威胁进行分析(假设有 $k$ 项)

若值为 $0$, 则构成 $C^2_k$ 个威胁

否则设其中 $s$ 项为正（或者为负随便），则构成 $C^2_s+C^2_{k-s}$ 个威胁，容易观察出来在 $s=\lfloor \frac{k}{2} \rfloor$ (或者 $s=\lceil \frac{k}{2} \rceil$ )的时候威胁数量最少。~~拿Subtask 4试一下就知道了~~

## 算法设计
首先我们需要一个可以离线的区间最大值用来判断能不能构成威胁，ST表解决问题 ~~因为作者不会更高级的东西了~~

然后的话如果直接对着每一项咔咔穷举一定超时，所以我们考虑离散化，把所有相同的数的位置放到一起，作者用vector解决

最后按照上述公式一算完事

大概的复杂度应该在 $\Omicron (n\log n)$ 左右，反正能过就行（

## AC Code
```cpp
#include <vector>
#include <iostream>
#include <algorithm>
#define int unsigned long long

using namespace std;

struct SameNum
{
    long long num;
    vector<signed> pos;
    bool operator<(SameNum b) { return this->num < b.num; }
    bool operator<(long long b) { return this->num < b; }
    bool operator==(SameNum b) { return this->num == b.num; }
    bool operator==(long long b) { return this->num == b; }
    SameNum(long long n, signed p)
    {
        this->num = n;
        this->pos.push_back(p);
    }
};

bool vis[500005];
int n, logn = 22ULL, Log2[500005] = {0ULL, 0ULL}, ans = 0ULL;
long long a[500005][25];
vector<SameNum> v;

signed main()
{
    ios::sync_with_stdio(false);
    cin >> n >> a[1][0];
    a[1][0] = abs(a[1][0]);
    v.push_back(SameNum(a[1][0], 1));
    for (int i = 2; i <= n; i++)
    {
        cin >> a[i][0];
        a[i][0] = abs(a[i][0]);
        Log2[i] = Log2[i / 2] + 1;
        int t = lower_bound(v.begin(), v.end(), a[i][0]) - v.begin();
        if (v[t].num == a[i][0] && t != v.end() - v.begin())
            v[t].pos.push_back(i);
        else
              v.insert(v.begin() + t, SameNum(a[i][0], i));  // 这地方直接加入然后sort会炸时间
    }
    // ST表预处理
    for (int j = 1; j <= logn; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            a[i][j] = max(a[i][j - 1], a[i + (1 << (j - 1))][j - 1]);
    // 算ans
    for (SameNum i : v)
    {
        signed s = i.pos.size();
        int count = 1;  // 不是从0开始因为你至少要有1个才会进到这来啊（没有的话0和1其实没啥区别算出来都是个0）
        for (signed j = 1; j < s; j++)
        {
            int k = Log2[i.pos[j] - i.pos[j - 1] + 1];
            if (max(a[i.pos[j - 1]][k], a[i.pos[j] + 1 - (1 << k)][k]) <= i.num)
                count++;
            else
            {
                if (i.num != 0)
                    ans += (count / 2) * (count / 2 - 1) + (count / 2) * (count % 2);
                else
                    ans += count * (count - 1) / 2;
                count = 1;
            }
        }
        if (i.num != 0)
            ans += (count / 2) * (count / 2 - 1) + (count / 2) * (count % 2);
        else
            ans += count * (count - 1) / 2;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Supor__Shoep (赞：1)

我们知道不管 $a_i$ 进行了多少次操作，$|a_i|$ 都是不会改变的。因此每次修改操作只会影响到 $a_l=a_r$ 这个条件的成立。

我们先在初始数组中拎出所有绝对值最大的数，设绝对值最大值为 $m$，数的个数为 $x$，我们思考如果安排它们的正负性才能使得 $|a_l|=|a_r|=m$ 的具有威胁的区间最少。不难想到把它们砍半，将 $\lceil\frac{x}{2}\rceil$ 个数规定为正数，剩下的 $x-\lceil\frac{x}{2}\rceil$ 个数规定为负数，这样就能使得答案尽可能少。但是有一种特殊情况，就是若 $m=0$，那么它们怎么操作都不改变自身的值，此时特判一下最小区间数为 $\frac{x(x-1)}{2}$ 就行了。

考虑到若 $a_i,a_j$ 相等且 $\max_{i\leq k\leq j}\{a_k\}>a_i$ 时，$[i,j]$ 就不可能产生贡献，我们就从序列的最大值开始处理答案，处理完之后就把这些数看作分割线，于是整个序列就会变成若干个子段，我们用分治思想，递归到每个子段继续处理就行了。

由于值域较大，我们离散化一下，把每个数按照它的值储存到对应的 vector 里面，当分治到 $[l,r]$ 处理答案时，我们就二分出左右端点 $L,R$，表示储存与当前区间最大值相等的所有数的下标的 vector 中 $[L,R]$ 这一段的下标都属于 $[l,r]$。那么我们这一轮选出的最大值就有 $R-L+1$ 个数。此外，如果要求区间的最大值，我们可以提前预处理一个 st 表，每次 $O(1)$ 查询就好了。

整体复杂度的话，对于每个大小的 $s$ 的 vector，我们最多会有 $s$ 次二分，单个 vector 就是 $O(s\log s)$ 的时间，又考虑到将每个数转换为分割线只会被执行一次，是均摊的，所以总时间复杂度最劣会达到 $O(n\log n)$。不知道分析的正不正确，反正它过了（逃

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e5+5;
int n,a[MAXN];
int b[MAXN];
vector<int> vec[MAXN];
long long find(int x){ return 1ll*x*(x-1)/2; }
int asdf[MAXN];
int st[MAXN][20];
int lg[MAXN];
int query(int l,int r)
{
	if(l>r)	return 0;
	int k=lg[r-l+1];
	return max(st[l][k],st[r-(1<<k)+1][k]);
}
long long solve(int x,int l,int r)
{
	if(l>r)	return 0;
	if(!x)	return 0;
	if(!b[x])	return find(r-l+1);
	int ll=0,rr=asdf[x]-1,L=-1,R=-1;
	while(ll<=rr)
	{
		int mid=(ll+rr)/2;
		if(vec[x][mid]>=l)	L=mid,rr=mid-1;
		else	ll=mid+1;
	}
	ll=0,rr=asdf[x]-1;
	while(ll<=rr)
	{
		int mid=(ll+rr)/2;
		if(vec[x][mid]<=r)	R=mid,ll=mid+1;
		else	rr=mid-1;
	}
	if(L==-1||R==-1||vec[x][L]>r||vec[x][R]<l)	return solve(x-1,l,r);
	long long sum=find((R-L+1)/2)+find((R-L+1)-(R-L+1)/2);
	int lst=l-1;
	for(int i=L;i<=R;i++)	sum+=solve(query(lst+1,vec[x][i]-1),lst+1,vec[x][i]-1),lst=vec[x][i];
	sum+=solve(query(vec[x][R]+1,r),vec[x][R]+1,r);
	return sum;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)	cin>>a[i],a[i]=abs(a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	int len=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)	a[i]=lower_bound(b+1,b+len+1,a[i])-b;
	for(int i=1;i<=n;i++)	vec[a[i]].push_back(i);
	for(int i=1;i<=n;i++)	st[i][0]=a[i];
	for(int i=2;i<=n;i++)	lg[i]=lg[i>>1]+1;
	for(int j=1;j<=lg[n];j++)
	{
		for(int i=1;i<=n-(1<<j)+1;i++)	st[i][j]=max(st[i][j-1],st[i+(1<<j-1)][j-1]);
	}
	for(int i=1;i<=len;i++)	asdf[i]=vec[i].size();
	cout<<solve(len,1,n);
	return 0;
}
```

---

## 作者：Bamboo_Day (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10798)

# 分析
首先将题意进行一种抽象的描述，简单来说就是两个一样的值中间夹了一堆绝对值比它们小的值，这样算一个具有威胁的区间，然后通过更改两个端点的值可以消除这个区间的威胁。

嗯上面这段话其实看不懂也没关系，但是**对题目进行一个自我语言的表述可以辅助形成思路**。

初步思考发现，题目所谓的更改操作并不会改变绝对值的相对大小关系。再进一步思考，可以发现，一开始序列中每个值的正负性是跟最后结果没有关系的。也就是说可以在一开始就把**所有的值都取绝对值**。

现考虑有 $n$ 个**值相同**的点已被统计出来可以当做威胁区间的**连续**端点。Like this: （这是一个 $n=5$ 的例子）
[![pk7w0P0.png](https://s21.ax1x.com/2024/07/22/pk7w0P0.png)](https://imgse.com/i/pk7w0P0)

那么显然这段区间能通过操作变成的最小值是：
$$\frac{p\cdot (p-1)}{2}+\frac{q\cdot (q-1)}{2}\ (p=\lceil \frac{n}{2} \rceil,q=n-p)$$

## 坑点
显然在值为 $0$ 的时候不论怎么变换都不会改变区间个数，所以要进行特判处理。否则会在 Sub#3 上挂掉。

下面考虑如何统计此类区间。

假设已经找到了两个相同的值，那么只要以这两个值为端点的区间内最大值不大于这两个值，则此为一个威胁区间。这一步可以使用**线段树**解决。

那么可以对序列以值为第一关键字，位置为第二关键字进行排序，扫一遍进行处理。

这里描述的有点难懂，辅助代码理解。

# Code
```cpp
#include <bits/stdc++.h>
#define int long long
const int N = 5e5+10;
#define ls (pos<<1)
#define rs (pos<<1|1)
#define mid ((l+r)>>1)
using namespace std;
int Node[N<<2];
struct A{
	int val, pos;
}a[N];
bool cmp(A x, A y){
	return (x.val == y.val) ? x.pos < y.pos : x.val < y.val;
}
void push_up(int pos){
	Node[pos] = max(Node[ls],Node[rs]);
}
void build(int pos, int l, int r){
	if(l == r){
		Node[pos] = a[l].val;
		return;
	}	
	build(ls,l,mid);
	build(rs,mid+1,r);
	push_up(pos);
}
int query(int pos , int l, int r, int x, int y){
	if(x <= l && r <= y){
		return Node[pos];
	}
	int ans = -1;
	if(mid >= x) ans = max(ans,query(ls,l,mid,x,y));
	if(mid < y) ans = max(ans,query(rs,mid+1,r,x,y));
	return ans;
}
int n;
int calc(int cnt,int x){
	if(cnt == 1) return 0;
	if(x == 0) return cnt*(cnt-1)/2;
	int p = cnt/2,q = cnt-p;
	return p*(p-1)/2 + q*(q-1)/2;
}
signed main(){
	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> a[i].val;
		if(a[i].val < 0) a[i].val = -a[i].val;
		a[i].pos = i;
	}	
	build(1,1,n);
	sort(a+1,a+1+n,cmp);
	int cnt = 1;
	int ans = 0;
	for(int i = 1;i < n; i++){
		if(a[i].val != a[i+1].val){
			ans += calc(cnt,a[i].val);
			cnt = 1;			
			continue;
		} 
		if(query(1,1,n,a[i].pos,a[i+1].pos) <= a[i].val) cnt++;
		else{
			ans += calc(cnt,a[i].val);
			cnt = 1;
		}
	}
	ans += calc(cnt,a[n-1].val);
	cnt = 1;
	cout << ans;
	return 0;
}
```

---


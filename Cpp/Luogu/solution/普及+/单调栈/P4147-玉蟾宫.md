# 玉蟾宫

## 题目背景

有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。


## 题目描述

这片土地被分成 $N\times M$ 个格子，每个格子里写着 'R' 或者 'F'，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。

现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 'F' 并且面积最大。

但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 $S$，它们每人给你 $S$ 两银子。


## 说明/提示

对于 $50\%$ 的数据，$1 \leq N, M \leq 200$。  
对于 $100\%$ 的数据，$1 \leq N, M \leq 1000$。

## 样例 #1

### 输入

```
5 6 
R F F F F F 
F F F F F F 
R R R F F F 
F F F F F F 
F F F F F F```

### 输出

```
45```

# 题解

## 作者：假假 (赞：137)

 Solution(单调栈做法)
 
 请不要依靠名字颜色来臆断水平，谢谢！
 
 1.我们按行去划分，O(n)枚举行，对该行即以上的部分做最大矩阵处理；
 
 2.那么我们用pos数组记录每行向上可延伸的最大距离，预处理的方式即为：
 
 (1)读到一个‘F’，该处pos=上一行该列pos的值+1；
 
 (2)读到一个‘R’，该处pos=0（因为该处不可向上伸展）；
 
```
memset(pos,0,sizeof(pos));
for(i=1;i<=n;++i)
	for(j=1;j<=m;++j){
		x=getc();
		if(x=='F')pos[i][j]=pos[i-1][j]+1;
	}
```
 3.那么对于每次枚举:对该行及以上的部分从左往右或从右往左进行一次单增栈，每次弹栈时更新最大面积;
 
 (1)栈内每个单位存入两个元素：该单位高度height和对应可控宽度length，对于每个大于栈顶直接入栈的元素，stack[i].length=1；
 
 (2)对于需要先弹栈再入栈的元素，其length=弹栈所有元素length之和+1，因为被弹栈的元素的高度均≥当前元素，所以其可控范围应加上被其弹栈元素的length；
 (3)在弹栈过程中，记录一个temp为本次弹栈到当前为止弹出的宽度，因为为单增栈，所以每个高度均可控其后被弹栈元素的宽度，所以其对应的面积为s=temp*h[i]，取max更新该行的maxs；
 
 4.对每次枚举的maxs取max即为最终答案；
 
```
include<iostream>
include<cstdio>
include<cmath>
include<cstring>
include<algorithm>
using namespace std;

struct node{
	int height,length;
}stack[1010]; 
int n,m,i,j,k,pos[1010][1010],ans=0,maxs=0;
char x;

inline int read(){
	int x=0;
	bool f=true;
	char c;
	c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=false;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return f?x:-x;
} 

char getc()
{
	char c=getchar();
	while(c!='R'&&c!='F')c=getchar();
	return c;
}

void calc(int x){
	int top=1,temp=0;
	maxs=0;
	stack[1].height=pos[x][1];
	stack[1].length=1;
	for(i=2;i<=m;++i){
		temp=0;
		while(stack[top].height>=pos[x][i]&&top>0){
			temp+=stack[top].length;
			maxs=max(maxs,stack[top--].height*temp);
		}
		stack[++top].height=pos[x][i];
		stack[top].length=temp+1;
	}
	temp=0;
	while(top>0){
		temp+=stack[top].length;
		maxs=max(maxs,stack[top--].height*temp);
	}
	ans=max(ans,maxs);
}

int main(){
	memset(pos,0,sizeof(pos));
	n=read();
	m=read();
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j){
			x=getc();
			if(x=='F')pos[i][j]=pos[i-1][j]+1;
		}
	for(k=1;k<=n;++k) calc(k);
	ans*=3;
	printf("%lld\n",ans);
	return 0;
}
```
 关于单调栈可以参考我的博客：http://www.cnblogs.com/COLIN-LIGHTNING/p/8474668.html
 
 有什么问题欢迎各位大佬指出

---

## 作者：Plus_Ultra (赞：95)

前言：

- 这道题是别人推荐的一道单调栈好题，看到这道题时，看到很多题解都看不懂，于是回去复习lyd大佬的书，弄明白之后就A了这道题，想借题解加深一下记忆，同时也想帮助一下和我一样的萌新.

基础：

- 什么是单调栈？单调栈其实是栈的一个“骚操作”，可以通过维护单调递减或单调递增的元素来及时排除不可能的选项，保证策略集合的有效性，同时也便于维护.

问题转化：

- n行m列土地，求最大矩形面积，我们把问题拆分成n个子问题来解决.
- 对于每一行,依次记录每行向上一直是F土地的可延伸的最大距离，记为f(i,j).

  1. 当前元素(i,j)为F,则f(i,j)=f(i-1,j)+1.
  2. 当前元素(i,j)为R,则f(i,j)=0.

- 我们记录这个数组有什么用呢？这就可以转化为单调栈维护的问题了.

具体思路：

- 对于每一个子问题，我们维护一个单调递增的单调栈.我们定义一个结构体(其中记录的两个元素分别是当前行第j个矩形的f值，以及它在当前已加入栈中矩形高度的排名).

- 我们考虑当前加入第k个矩形的情况.

  1. 当前矩形高度大于栈顶，直接加入即可，因为没有比它大的元素，那么他的排名为1.
  
  2. 当前矩形高度小于栈顶，则不断取出栈顶，直到栈为空或者栈顶矩形的高度比当前矩形小.在出栈过程中，我们累计被弹出的矩形的宽度之和，并且每弹出一个矩形，就用它的高度乘上累计的排名（是累计，因为在它入栈后还有比它大的元素入栈）来更新答案.
  
  3. 这样为什么是对的呢？这是因为：如果当前要加入矩形的f值（即当前矩形的高度比上一个小），那么该矩形想利用前面的矩形一起构成一个大矩形是，这块矩形的高度不可能超过该矩形自己的高度，则记录前面元素的高度就没有用处了.而宽度还有用处（因为当前矩形高度较小，与比它高的矩形的宽度总和相乘，在此矩形出栈时，要用它来更新答案）.所以我们要记一个当前已加矩形的高度排名（无论是在栈里还是已经出栈）.而又因为每个元素只被弹栈一次，所以不会有重复情况.
  
  4. 在所有矩形（m个）都考虑过后，我们再用还没有弹栈的元素再来个新一波答案，直到栈空.
  
下面上代码（我相信各位大佬也不需要代码）：

```
#include<iostream>
#include<stack>
#include<cstring>

#define N 1010

using namespace std;

int n,m,f[N][N],maxx;
char c;
struct node
{
	int len,h;
}a[N];
stack<node> S;

void ask(int x)
{
	memset(a,0,sizeof(a));
	a[1].h=f[x][1],a[1].len=1;
	while(S.size())  S.pop();
	S.push(a[1]);//初始化
	for(int i=2;i<=m;i++)
	{
		int w=0;
		while(S.size()&&f[x][i]<=S.top().h)//需要弹栈
		{
			w+=S.top().len;
			maxx=max(maxx,w*S.top().h);
			S.pop();//更新答案并弹栈
		}
		a[i].h=f[x][i],a[i].len=w+1;//已入栈的比他高的矩形个数加1
		S.push(a[i]);
	}
	int w=0;
	while(S.size())//用剩余矩形更新答案
	{
		w+=S.top().len;
		maxx=max(maxx,S.top().h*w);
		S.pop();
	}
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			if(c=='F')  f[i][j]=f[i-1][j]+1;
		}
		
	for(int i=1;i<=n;i++)  ask(i);//解决子问题
	
	cout<<maxx*3<<endl;//别忘了要乘3哦
	
	return 0;
}
```


---

## 作者：XG_Zepto (赞：59)

## 思路


很容易发现，这是**最大子矩形问题**的板子题。


对于该类问题，王知昆dalao早已撰写过一篇论文讨论了通用的解决方案，我们可以阅读这篇论文：[浅谈用极大化思想解决最大子矩形问题](http://blog.csdn.net/twtsa/article/details/8120269)。


对于这道题，由于障碍点密集，我们使用**悬线法**解决。//障碍点：在选取子矩形时不允许包含的点，本题中为“R”。


## 代码解释


设$h(i,j)$表示以$(i,j)$为下端点的悬线的最长长度。预处理$l(i,j)$和$r(i,j)$，它们分别表示点(i,j)能扩展到的左边和右边的最近的障碍。


$L(i,j)$和$R(i,j)$分别表示使悬线有此长度的左边最近的障碍和右边最近的障碍。


答案即为$max(h(i,j)*(R(i,j)-L(i,j)+1)$。


对于本题，要求输出答案乘3后的值。


## C++代码


```cpp
#include<bits/stdc++.h>  
using namespace std;  
const int maxn=1e3+10;  
int a[maxn][maxn],n,m,h[maxn][maxn],ans,t;char c;  
int l[maxn][maxn],r[maxn][maxn],L[maxn][maxn],R[maxn][maxn];  
int main(){ 
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++)  
    for(int j=1;j<=m;j++)
    {cin>>c;if(c=='F') a[i][j]=1;} 
    for(int i=1;i<=n;i++){
        t=0;
        for(int j=1;j<=m;j++)//枚举左边的障碍
            if(a[i][j])l[i][j]=t;
            else L[i][j]=0,t=j;
        t=m+1;
        for(int j=m;j>=1;j--)//枚举右边的障碍
            if(a[i][j])r[i][j]=t;  
            else R[i][j]=m+1,t=j;      
    }
    for(int i=1;i<=m+1;i++) R[0][i]=m+1;
    for(int i=1;i<=n;i++)  
    for(int j=1;j<=m;j++){
        if(a[i][j]){
            h[i][j]=h[i-1][j]+1;//如果这个点是合法的，对应的悬线长度应当比它下面的点对应的悬线长大1  
            L[i][j]=max(l[i][j]+1, L[i-1][j]);
            R[i][j]=min(r[i][j]-1, R[i-1][j]);
            ans=max((R[i][j]-L[i][j]+1)*h[i][j], ans); //求出最大的面积          
        }
    }
    cout<<3*ans<<endl;
    return 0;
}  
```

---

## 作者：lemonfor (赞：37)

# 来一篇不一样的题解QAQ

------------
看到这一道题的第一反应是悬线法，但是突然想另辟蹊径来试试水，于是就去暴力了。。。

~~刚好和一个人赌气，他不相信一维数组能过，所以我用一维数组n^3大暴力，，，结果还真过了@鬼墨无忧~~


------------
我的思路是这样的：

1. 三重循环不用说，i表示行数，j表示列数，k用来找该行前面的矩阵

1. 开一个一维数组  _map_  来存当前到第一行的高度，如果读入为 _F_ ，则  _++ map[j]_  ，如果为 _R_ ，则清零；

1. 开一个变量  _num_  来维护当前的最小高度；
1. 开一个变量  _ans_  来存现在找到的最大矩形面积，即矩形高乘上矩形长度，就是代码中的 _num * (j - k + 1)_ 

好了，现在我们的暴力完成了，但是直接交肯定会TLE，所以我们可以加一个优化：

$$map[j]!=0$$
原因：整个输入只有 _R_ 和 _F_ 构成 , 而 _R_  又不用考虑，所以我们找的时候直接跳过 _R_ 就行了；

代码时间：

```
#include<cstdio>
#include<algorithm>
#define _ 0
using namespace std;
int map[1050] ,n ,m ,num ,ans = 1;
char op;
int main()
{
    scanf("%d%d" ,&n ,&m);
    for(int i = 1 ; i <= n ; ++ i)
    {
        for(int j  = 1 ; j <= m ; ++ j)
        {
            scanf("%s" ,&op);
            if(op == 'R') map[j] = 0;//如果为R则直接清零
            else ++ map[j];//存现在到第一行的高度
            num = map[j];
            for(int k = j - 1 ; k && map[k] ; -- k)
            {
                num = min(num , map[k]);
                ans = max(ans , num * (j - k + 1));//算出答案
            }
        }
    }
    ans *= 3;
    printf("%d" ,ans);
    return ~~(0^_^0);
}
```

防伪标记已加，抄代码的盆友注意啦~~~

---

## 作者：qwerta (赞：32)

这是来自我校学长~~(祖传)~~的**并查集**做法

首先从上到下枚举每一行（分割线）。

在当前行，把它以上的F染色，那么F会构成这样的图案↓

![](https://i.loli.net/2018/10/15/5bc3df4eb30cd.png)

每一列在这条分割线以上有多少连续的F，可以在每次下移分割线时顺便用O(m)扫一遍维护。（如果这一格为F，那么连续F为之前这列的连续F加1;否则为0）

然后我们按照每一列的F高度排序，每次把F最高的取出来。

如果它**左边一列**被取过了，我们就把当前列和它左边一列并起来;如果**右边一列**被取过，就把这一列和右边一列并起来。

最后询问一下这一列的祖先有多少个子节点，也就是这一列**以它的高度**往左右最多能扩展的宽度。

原理：在当前列之前被并入这个祖先的列的长度一定大于等于当前列的长度，并且这些列互相相邻。

然后当前列的高度，乘上它往左右最多能扩展的宽度，就是取这一列，且高度等于这一列的最大矩形面积了。(就算还有相同高度的没有处理，之后做那一列的时候也会得到最优解)

实现的时候只需要把两个需要合并的列的祖先节点$fa[v]=u,siz[u]+=siz[v]$就可以了，因为只有祖先节点的siz是有意义的。

因为懒所以直接用了优先队列，并查集只路径压缩也是$O(mlogm)$的时间，总复杂度$O(nmlogm)$

```
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
int s[1003];//记录每列往上F的高度
int fa[1003],siz[1003];//并查集
bool sf[1003];//标记每一列是否被用过
struct emm{
    int nod,v;
};
struct cmp{
    bool operator()(emm qaq,emm qwq){
        return qaq.v<qwq.v;
    }
};//重载()运算符（用来给优先队列排序
priority_queue<emm,vector<emm>,cmp>q;
int fifa(int x)
{
    if(fa[x]==x)return x;
    return fa[x]=fifa(fa[x]);
}
void con(int x,int y)//把x列和y列并起来
{
    int u=fifa(x),v=fifa(y);
    fa[v]=u;
    siz[u]+=siz[v];
    return;
}
int main()
{
    //freopen("a.in","r",stdin);
    ios::sync_with_stdio(false);
    cin.tie(false),cout.tie(false);//关闭同步流（让cin变快
    int n,m;
    cin>>n>>m;
    int ans=0;
    for(int c=1;c<=n;++c)//从上往下移分割线
    {
        for(int i=1;i<=m;++i)
        {
            char ch;
            cin>>ch;
            if(ch=='F'){s[i]++;q.push((emm){i,s[i]});}
            else s[i]=0;
        }
        for(int i=1;i<=m;++i)
        fa[i]=i,siz[i]=1,sf[i]=0;//初始化
        while(!q.empty())
        {
            int i=q.top().nod,x=q.top().v;q.pop();
            sf[i]=1;//标记这一列取过了
            if(sf[i-1])con(i-1,i);//如果左边取过了就并起来
            if(sf[i+1])con(i,i+1);//如果右边取过了就并起来
            int fi=fifa(i);//找祖先节点
            ans=max(ans,siz[fi]*x);
        }
    }
    cout<<ans*3;//输出最大矩形面积*3
    return 0;
}
```

---

## 作者：huiwang17 (赞：28)

新学的悬线法。。

本题的题意就是，在一个有障碍的矩形中寻找一个最大的不包含障碍的矩形。

直接枚举四条边界判断合法肯定是不行的，这样做起码是$O(n^5$)的复杂度。
悬线法运用了**贪心**的思想，那就是对于每一个点，考虑他**以某种方式**所能形成的一个**极大**的矩形。

## 显然，一个极大矩形应该是上下左右都不能再向外扩充的矩形。
悬线法利用了这个结论，考虑的是以**每一个障碍物**或**上边界**为上边界的极大矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/bg3rl5a5.png)

如图所示，$1$号矩形的上边界是本题的上边界，$2$号矩形的上边界由向上方走遇到的第一个障碍决定，$3$号矩形也是如此。

可以**枚举下边界上的一个点**来确定这个矩形的最大高度，也就是图中的1️⃣2️⃣3️⃣。当这个点向上没有碰到障碍或边界时矩形高度$+1$。高度确定了之后就可以由中间的行确定他的宽度。

对于每一个点，我们记录ta向上、向左、向右最多能扩充的长度。每个点所生成的极大矩形由**包含它的最高的矩形**决定【事实上和单调栈的思路有点类似】。

为什么这样能枚举到所有的极大矩形呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/qy64odsu.png)

当枚举到1️⃣号点时，他对答案的贡献只有红色的矩形，但他其实同时也包含在绿色的矩形里面啊？

但是，很容易就会发现其实绿色的矩形在枚举2️⃣号点的时候就已经枚举到了。
## **这里极大矩形的高度和宽度是互相制约的，确定一个，再让另外一个尽量大就好了。**


$~~~~$

#### 代码部分，首先需要预处理出每个点向上向左向右的最长距离：

```cpp
const int MAXN = 1017;
int n, m;
int G[MAXN][MAXN];
int up[MAXN][MAXN];
int l[MAXN][MAXN];
int r[MAXN][MAXN];

for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            if(!G[i][j]) continue;
            l[i][j] = l[i][j-1] + 1;
        }
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= 1; j--){
            if(!G[i][j]) continue;
            r[i][j] = r[i][j+1] + 1;
        }
```

### 然后需要优先满足从本点向上最高的矩形所能达到的宽度：

```cpp
for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(i > 1 && G[i][j] && G[i-1][j]){
                up[i][j] = up[i-1][j] + 1;
                l[i][j] = min(l[i][j], l[i-1][j]);
                r[i][j] = min(r[i][j], r[i-1][j]);
            }
            maxs = max(maxs, (up[i][j] + 1) * (l[i][j] + r[i][j] - 1)); //高度应该+1，宽度应该-1，小细节要注意
        }
    }
```

### AC代码

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 1017;
int n, m;
int G[MAXN][MAXN];
int up[MAXN][MAXN];
int l[MAXN][MAXN];
int r[MAXN][MAXN];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            char ch;
            cin >> ch;
            if(ch == 'F')
                G[i][j] = 1;
        }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            if(!G[i][j]) continue;
            l[i][j] = l[i][j-1] + 1;
        }
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= 1; j--){
            if(!G[i][j]) continue;
            r[i][j] = r[i][j+1] + 1;
        }
    int maxs = 0;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(i > 1 && G[i][j] && G[i-1][j]){
                up[i][j] = up[i-1][j] + 1;
                l[i][j] = min(l[i][j], l[i-1][j]);
                r[i][j] = min(r[i][j], r[i-1][j]);
            //printf("## (%d, %d) %d %d %d\n", i, j, l[i][j], r[i][j], up[i][j]);
            }
            maxs = max(maxs, (up[i][j] + 1) * (l[i][j] + r[i][j] - 1));
        }
    }
    cout << 3 * maxs << endl;
}


```


---

## 作者：zjinze (赞：13)

#### 前言：

蒟蒻刚学笛卡尔树，突然发现前些天用单调栈做的这道题可以用笛卡尔树来写。

#### 前置知识： 笛卡尔树。

#### 思路：

我们这道题按照正常思路一行行考虑。我们可以先预处理出 $dp_{ij}$ 表示第 $i$ 行，第 $j$ 列的元素，算上本身，往上走最多有几个标号为 $F$ 的土地。本题中的笛卡尔树默认为满足小根堆性质。了解笛卡尔树的同学应该知道，在笛卡尔树中，$x$ 子树内的下标是一段连续的区间，且 $x$ 的子树内的权值都大于 $x$。于是，我们将每一列的下标当作笛卡尔树的键值 $k$，$dp_{ij}$ 当作笛卡尔树的权值。由上文讲述的笛卡尔树的性质可知，当前子树的大小就等于我们用单调栈求得的向左和向右能拓展到的最远的位置。最后，我们只要将当前节点的权值乘上子树的大小再去最大值即可。

#### 注意事项：

每次遍历到新的一行时，一定要将每个节点的左儿子和右儿子清空，不然就会炸空间，具体原因我也不清楚，有知道的欢迎在评论区留言，或私信轰炸我。

#### code:

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
const int N=2010;
int t,l[N],r[N],dp[N][N],n,m,a[N][N],ans=0,stk[N],root=0,vis[N],siz[N];
char x;
void dfs(int i,int x){
	if(x==0)return ;
	if(l[x]!=0)dfs(i,l[x]);
	if(r[x]!=0)dfs(i,r[x]);
	siz[x]+=siz[l[x]]+siz[r[x]];
	ans=max(ans,(siz[x])*dp[i][x]);
	return ;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>x;
			if(x=='F'){
				a[i][j]=1;
			}
			else{
				a[i][j]=0;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]==0){
				dp[i][j]=0;
			}
			else{
				dp[i][j]=dp[i-1][j]+1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		int top=0;
		memset(l,0,sizeof(l));
		memset(r,0,sizeof(r));
		for(int j=1;j<=m;j++){
			siz[j]=1; 
			int k=top;
			while(k>0 && dp[i][stk[k]]>dp[i][j]){
				k--;
			}
			if(k!=0){
				r[stk[k]]=j;
			}
			if(k<top){
				l[j]=stk[k+1];
			}
			stk[++k]=j;
			top=k;	
		}
		for(int j=1;j<=m;j++)vis[j]=0;
		for(int j=1;j<=m;j++){
			vis[l[j]]=1;
			vis[r[j]]=1;
		}
		dfs(i,stk[1]);
	}	
	cout<<ans*3<<"\n"; 
	return 0;
}
/*
4 6
RRRFRR
RRFFRR
FRFFRF
FFFFFF
*/
```

---

## 作者：LevenKoko (赞：11)

## 明显的悬线法求最大子矩阵，不过也有巨佬用的单调栈

不会悬线法的可以看下面这篇博客，很详细哦！
[悬线法](https://www.cnblogs.com/zhenglw/p/10102833.html)

悬线法，很好理解，就是悬一根线晃来晃去求最大子矩阵嘛！
思路和转移方程也很简单：
```
if(满足^&%$!@#^%){
    right[i][j]=min(right[i][j],right[i-1][j]);
    left[i][j]=max(left[i][j],left[i-1][j]);
    up[i][j]=up[i-1][j]+1;
}
 ```

下面解释一下：

right表示从(i,j)这个点出发向右能到达最远的距离

left和up差不多，一个向左，一个向上

关于初始化

```
for(int i=1;i<=n;i++) 
    for(int j=1;j<=m;j++)
        right[i][j]=left[i][j]=j,up[i][j]=1;
for(int i=1;i<=n;i++)
    for(int j=2;j<=m;j++)
        if(满足条件)
            right[i][j]=right[i][j-1];
for(int i=1;i<=n;i++)
    for(int j=m-1;j>=1;j--)
        if(满足条件)
            left[i][j]=left[i][j+1];
```

其实这个东西跟模板一样套就好了

对于该题，条件显然是相等且为‘F’
代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read(){
	char chr=getchar();	int f=1,ans=0;
	while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr))  {ans=(ans<<3)+(ans<<1);ans+=chr-'0';chr=getchar();}
	return ans*f;
}
void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n,m;
char a[4005][4005];
int l[4005][4005],r[4005][4005],up[4005][4005],ans1,ans2;
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			l[i][j]=r[i][j]=j,up[i][j]=1;
		}
	for(int i=1;i<=n;i++)
		for(int j=2;j<=m;j++)
			if(a[i][j]==a[i][j-1]&&a[i][j]=='F')	l[i][j]=l[i][j-1];
	for(int i=1;i<=n;i++)
		for(int j=m-1;j>=1;j--)
			if(a[i][j]==a[i][j+1]&&a[i][j]=='F')	r[i][j]=r[i][j+1];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(i>1)
				if(a[i][j]==a[i-1][j]&&a[i-1][j]=='F'){
					l[i][j]=max(l[i][j],l[i-1][j]);
					r[i][j]=min(r[i][j],r[i-1][j]);
					up[i][j]=up[i-1][j]+1;
				}
			int a=r[i][j]-l[i][j]+1;
			int b=min(a,up[i][j]);
			ans2=max(a*up[i][j],ans2);
		}
	cout<<ans2*3;
	return 0;
}

```




---

## 作者：岸芷汀兰 (赞：11)

###作者：岸芷汀兰

#一、题目：

[题目链接](https://www.luogu.org/problemnew/show/P4147)

#二、思路：

单调栈裸题。

预处理：s[i][j]表示(i,j)向上有几个连续的"F"。

需要用单调栈统计两个数组：l[i][j]表示s[i][j]的左边第一个比s[i][j]小的位置，r[i][j]表示s[i][j]的右边第一个比s[i][j]小的位置。

那么此时矩形的面积就是(r[i][j]-1-l[i][j])*s[i][j]。

具体细节看代码。

~~写得太丑。~~

#三、代码：

```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<algorithm>

using namespace std;
inline int read(void) {
	int x = 0, f = 1; char ch = getchar();
	while (ch<'0' || ch>'9') {
		if (ch == '-')f = -1;
		ch = getchar();
	}
	while (ch >= '0'&&ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return f * x;
}

const int maxn = 1005;

int n, m, map[maxn][maxn], s[maxn][maxn], l[maxn][maxn], r[maxn][maxn], ans;

stack<int>monotonous;

inline void clear(void) {
	while (monotonous.size())monotonous.pop(); return;
}

int main()
{
	n = read(); m = read();
	for (register int i = 1; i <= n; i++) {
		for (register int j = 1; j <= m; j++) {
			char ch; cin >> ch;
			map[i][j] = (ch == 'F' ? 1 : 0);
		}
	}
	for (register int i = 1; i <= n; i++) {
		for (register int j = 1; j <= m; j++) {
			if (map[i][j]) {
				s[i][j] = s[i - 1][j] + 1;
			}
		}
	}
	for (register int i = 1; i <= n; i++) {
		clear();
		for (register int j = 1; j <= m; j++) {
			if (monotonous.empty()) {
				monotonous.push(j); l[i][j] = 0;
			}
			else {
				while (monotonous.size() && s[i][j] <= s[i][monotonous.top()])monotonous.pop();
				if (monotonous.size())l[i][j] = monotonous.top();
				else l[i][j] = 0;
				monotonous.push(j);
			}
		}
		clear();
		for (register int j = m; j >= 1; j--) {
			if (monotonous.empty()) {
				monotonous.push(j); r[i][j] = m + 1;
			}
			else {
				while (monotonous.size() && s[i][j] <= s[i][monotonous.top()])monotonous.pop();
				if (monotonous.size())r[i][j] = monotonous.top();
				else r[i][j] = m + 1;
				monotonous.push(j);
			}
		}
	}
	for (register int i = 1; i <= n; i++) {
		for (register int j = 1; j <= m; j++) {
			if (!s[i][j])continue;
			int area = ((r[i][j] - 1) - l[i][j])*s[i][j];
			ans = max(ans, area);
		}
	}
	printf("%d\n", ans * 3);
    return 0;
}


```


---

## 作者：kradcigam (赞：10)

$\text{UPD}$：更新了下代码。

这道题，我们可以想一下，矩形的面积跟 $2$ 条边有关。

对于每个点，我们算出 $3$ 个数，`lft`、`rgt`、`up`。

> `lft`：即此点最多能向左延伸到哪一列。(初值为`j`)
>
> ```cpp
> for(int i=1;i<=n;i++)
> 	for(int j=1;j<=m;j++)
> 		if(a[i][j]&&a[i][j-1])lft[i][j]=lft[i][j-1];
> ```

> `rgt`：即此点最多能向右延伸多少哪一列。(初值为`j`)
>
> ```cpp
> for(int i=1;i<=n;i++)
> 		for(int j=m;j>=1;j--)
> 			if(a[i][j]&&a[i][j+1])rgt[i][j]=rgt[i][j+1];
> ```

> `up`：即此点最多能向上延伸多少个格子数。(初值为`1`)
>
> 边 $dp$ 边求。

现在我们就说说 $dp$ 吧。

```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		if(a[i][j]&&a[i-1][j]){
			lft[i][j]=max(lft[i-1][j],lft[i][j]);//在up最优的情况下，左端点的距离要更新
			rgt[i][j]=min(rgt[i-1][j],rgt[i][j]);//在up最优的情况下，右端点的距离要更新
			up[i][j]=up[i-1][j]+1;
		}
		int x=rgt[i][j]-lft[i][j]+1;
		ans=max(ans,x*up[i][j]);
	}
```

其实就是找高度最高的矩形，为什么这样是正确的呢。

我们可以这样想一下。我们的算法本质就是，**以 $i,j$  最多往上的长度做矩阵一条边**，这个就是 $up_{i,j}$ 干的事情，然后 $lft_{i,j}$ 和 $rgt_{i,j}$ 则是要在 $up_{i,j}$ 最优的情况下，让另一条边也最优。

你可以再想一下，下面这张图，最大子矩阵是橙色方框圈起来的。我们可以发现，最大子矩阵的四条边，每条边要么是靠到边界，要么是靠到障碍物。也就是说，最大子矩阵的上边界一定会靠到障碍物或边界。我们的算法就相当于确定了下边界，然后用 $up$ 数组又确定了上边界。然后用 $lft$ 和 $rgt$ 确定左边界和右边界。
![在这里插入图片描述](https://p.ipic.vip/u72t8b.png)

如果还是不懂的话，可以再想一下，我来模拟一下。

这就是我们 $up$ 做的事。

![213.png](https://p.ipic.vip/rv3lvv.png)

然后呢，对于每条线，我们要让他们的上边界尽可能的长。

![](https://p.ipic.vip/db4lgj.png)

再回来看看代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &FF){
	T RR=1;FF=0;char CH=getchar();
	for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
	for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
	FF*=RR;
}
template<typename T>void write(T x){
	if(x<0)putchar('-'),x*=-1;
	if(x>9)write(x/10);
	putchar(x%10+48);
}
int a[2010][2010],lft[2010][2010],rgt[2010][2010],up[2010][2010],ans;
int main(){
	int n,m;
	read(n);read(m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			char ch;
			cin>>ch;
			if(ch=='F')a[i][j]=1;
			lft[i][j]=j;
			rgt[i][j]=j;
			up[i][j]=1;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]&&a[i][j-1])lft[i][j]=lft[i][j-1];
	for(int i=1;i<=n;i++)
		for(int j=m;j>=1;j--)
			if(a[i][j]&&a[i][j+1])rgt[i][j]=rgt[i][j+1];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(a[i][j]&&a[i-1][j]){
				lft[i][j]=max(lft[i-1][j],lft[i][j]);
				rgt[i][j]=min(rgt[i-1][j],rgt[i][j]);
				up[i][j]=up[i-1][j]+1;
			}
			if(a[i][j]){
				int x=rgt[i][j]-lft[i][j]+1;
				ans=max(ans,x*up[i][j]);
			}
		}
	write(ans*3);
	return 0;
}
```

是不是就懂了$qwq$。。。

~~我才不告诉你，这个其实就是单调队列~~

---

## 作者：qiianr (赞：10)

# 两种方法

## 1）类比于[poj2559](http://poj.org/problem?id=2559)

![](http://www.yzoj.fun/upload/image/20180723/20180723084740_51973.jpg)

关于poj2559以及单调栈 在我另一篇Blog有详细解释及代码[戳戳戳*](https://qiianr-lulala.blog.luogu.org/dan-diao-zhan)

### 手动演练给你看~
样例
5 6 

R F F F F F 

F F F F F F

R R R F F F 

F F F F F F 

F F F F F F

先化为

1 0 0 0 0 0 

0 0 0 0 0 0

1 1 1 0 0 0

0 0 0 0 0 0

0 0 0 0 0 0

然后就是寻找由0构成的最大矩阵然后乘3

处理一番（每一列最大连续0的个数）

0 1 1 1 1 1

1 2 2 2 2 2

0 0 0 3 3 3

1 1 1 4 4 4

2 2 2 5 5 5

所以泥萌看出玄机了么

我们来单独看每一行 不就是poj2559那道单调栈的板子题嘛

处理的数字看作矩阵的高

奉上STL栈以及手写栈

STL
 
```cpp
#include <cstdio>
#include <iostream>
#include <stack> 
#define maxn 1005
using namespace std;
char b;
int n,m,a[maxn][maxn],f[maxn][maxn],ma;
struct node{
	int len,val;
};

void work(int x){
	stack<node> s;
	node q;
	int width=0;
	for(int i=1;i<=m;i++){
		q.len=1;
		q.val=f[x][i];
		width=0;
		if(s.empty()){
			s.push(q);
		}else{
			if(s.top().val<q.val){//进栈
				s.push(q);
			}else{
				while(!s.empty()&&s.top().val>=q.val){//栈不为空
					s.top().len+=width;
					ma=max(ma,s.top().val*s.top().len);
					width=s.top().len;
					s.pop();//退栈 
				}
				q.len+=width;
				s.push(q);
			}
		}
	}
	width=0;
	while(!s.empty()){//记得清空栈哦，避免有剩余矩形未被考虑到
		s.top().len+=width;
		ma=max(ma,s.top().val*s.top().len);
		width=s.top().len;
		s.pop(); 
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>b;//虽然scanf比cin快很多 但是输入字符及字符串时建议用cin不容易出错
			if(b=='R') a[i][j]=1;//转化成0 1 数组方便处理 
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			if(a[j][i]==0){//处理每一列 
				f[j][i]=f[j-1][i]+1;//累计这一列中的0的个数
			}
		}
	}
    for(int i=1;i<=n;i++){
    	work(i);//单调栈 这里与poj2559几乎是一毛一样
    }
    printf("%d",ma*3);
	return 0;
}
```

手写栈（思路与上代码同）也是直接改的poj2559的代码

```cpp
#include <cstdio>
#include <iostream>
#define maxn 1505
using namespace std;
int H,W,a[maxn][maxn],f[maxn][maxn],s[maxn],w[maxn],ma=0;
void work(int x){
    int p=0;
    f[x][W+1]=0;
    for(int i=1;i<=W+1;i++){
        if(f[x][i]>s[p]){
            s[++p]=f[x][i],w[p]=1;
        }else{
            int width=0;
            while(s[p]>f[x][i]){
                width+=w[p];
                ma=max(ma,width*s[p]);
                p--;
            }
            s[++p]=f[x][i],w[p]=width+1;
        }
    }
}
int main(){
    scanf("%d%d",&H,&W);
    char b;
    for(int i=1;i<=H;i++){
        for(int j=1;j<=W;j++){
            cin>>b;
            if(b=='R') a[i][j]=1;
            else a[i][j]=0;
        }
    }
    int cnt;
    for(int j=1;j<=W;j++){
        cnt=0;
        for(int i=1;i<=H;i++){
            if(a[i][j]==0){
                f[i][j]=f[i-1][j]+1;
            }
        }
    }
    /*
    for(int i=1;i<=H;i++){
        for(int j=1;j<=W;j++){
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }*/	
    for(int i=1;i<=H;i++){
        work(i);
    }
    printf("%d",ma*3);
    return 0;
}
```

## 2）悬线法

推荐一篇究极详细附上证明超级厉害的文章《浅谈用极大化思想解决最大子矩阵问题》
[只有dalao才戳得动](https://blog.csdn.net/clover_hxy/article/details/50532289?locationNum=1&fps=1)

### ~~马虎版~~

#### 作用：

O（n^2）用来解决最大矩阵和问题

#### 思路：

对于 m*n 矩阵中的任意一点，覆盖这个点的最大矩形的面积为，该点向左右最大能延伸的长度之和与向上最大能延伸的长度的乘积。

#### 描述：

首先 O(n^2) 预处理，对于矩阵上的每一个点，我们可以：

1.从它向上引一条悬线，遇到边界或障碍点停止，h[i][j] 数组记录从点 (i,j) 向上的悬线长度。

2.向左延伸，遇到边界或障碍点停止，l[i][j] 数组记录从点 (i,j) 向左最大能延伸的长度。

3.向右延伸，遇到边界或障碍点停止，r[i][j] 数组记录从点 (i,j) 向右最大能延伸的长度。

然后，我们发现，仅仅做出预处理是不够的，

因为，l[i][j] 和 r[i][j] 的值都各自取决于 l[i-1][j] 和 r[i-1][j]。（因为为保证成为一个矩形，l[i][j] 不能超过 l[i-1][j]，r 同理）

所以枚举点对 l 和 r 进行更新，对 l[i][j] 与 l[i-1][j] 取 min，r 同理。

这里可以合并求解与更新，每个点更新完之后顺便算出这个点悬线的矩形面积即可。

#### 递推公式：

S：S[i][j] = S[i-1][j] + 1//由上一个点求出的面积

Right：max(Right[i][j]，RIght[i-1],[j])

Left:：min(Left[i][j]，Left[i-1][j])

~~有没有很好写~~

喏~

```cpp
#include <cstdio>
#include <iostream>
#define maxn 1005
using namespace std;
int n,m,a[maxn][maxn],l[maxn][maxn],r[maxn][maxn],s[maxn][maxn],ans=0;
char b;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>b;
			if(b=='R') a[i][j]=1;
		}
	}
	for(int i=1;i<=m;i++) r[0][i]=m;
	for(int i=1;i<=n;i++){
		int maxr=m,maxl=1;
		for(int j=1;j<=m;j++){
			if(a[i][j]){
				maxl=j+1;
				s[i][j]=l[i][j]=0;
			}else{
				s[i][j]=s[i-1][j]+1;
				l[i][j]=max(maxl,l[i-1][j]);
			}
		}
		for(int j=m;j>0;j--){
			if(a[i][j]){
				maxr=j-1;
				r[i][j]=m;
			}else{
				r[i][j]=min(maxr,r[i-1][j]);
				ans=max(ans,(r[i][j]-l[i][j]+1)*s[i][j]);
			}
		}
	}
	cout<<ans*3;
	return 0;
}
```

---

## 作者：无意识躺枪人 (赞：5)

博客观看体验更佳：[点我](https://www.cnblogs.com/tqr06/p/11635676.html)

（如果图炸了请进[博客](https://www.cnblogs.com/tqr06/p/11635676.html)观看）

```
一片土地被分成N*M个格子，每个格子里写着R'或者"'F'
R代表这块土地被赐予了rainbow , F代表这块土地被赐予了freda
现在freda要找一块矩形土地,要求这片土地都标着'F'并且面积最大
输出最大的符合要求的土地的面积*3
（原题面中是指有三个人每个人给你S两银子，其实就是乘三……）
```

考场现学“悬线法”……
说实话，这种方法很难想到，但是十分巧妙

先讲一下另一种可以通过此题的不优算法：

我们把此题抽象为一个01矩阵，要求找到最大的全1子矩阵

由于答案具有某种意义上的单调性（如果有面积为S的矩阵符合，那么其约数大小的矩阵也符合）

那么我们二分面积，每次check是否存在这么大的矩阵

首先使用二维前缀和，统计出任意矩阵中1的个数，以及预处理约数

然后对于每个我们需要check的mid，$n^2$枚举它的位置

如果它所在的位置正好有面积那么多1，就说明存在

前缀和和check是$\Theta{(n^2)}$的
预处理约数个数，以及二分面积都是$\Theta{(\log^{2} m)}$的（m是最大的面积）

所以总复杂度是$\Theta{(n^2\log^2 m)}$，显然会T
在随机数据下，我们把m设小一点即可过……



------------


这里介绍一下玄学的悬线法——（如果图炸了请进[博客](https://www.cnblogs.com/tqr06/p/11635676.html)观看）

如下图，它是一个01矩阵（灰色为0，白色为1）

![](https://cdn.luogu.com.cn/upload/image_hosting/86nweh2t.png)
$$\text{tqr又乱画了一个图}$$

我们在这张图上模拟实现一下这个算法：

这个算法的朴素思路是什么呢？选取一列连续的1，定为所要扩展的矩形的高

![](https://cdn.luogu.com.cn/upload/image_hosting/m2zurinj.png)
$$\text{如图，这个粉色块即将扩展}$$

然后我们保持这个高度不变，让这个矩形向两边扩展！

![](https://cdn.luogu.com.cn/upload/image_hosting/jrd68spe.png)

就这样，我们得到了一个面积为5的符合条件的矩形！

然后我们把它的高度增加一点点……
![](https://cdn.luogu.com.cn/upload/image_hosting/1egehbyz.png)

继续扩展
![](https://cdn.luogu.com.cn/upload/image_hosting/0ya6x6i8.png)

现在得到的是一个面积为4的矩形……

同理，继续进行操作，我们得到的就是面积为6的矩形
![](https://cdn.luogu.com.cn/upload/image_hosting/0pdfsegc.png)

简单地看一下图，可知这个矩形已经是最优的了（虽然不是唯一最优的）

那么我们就得到了它的朴素思路：
1. 确定一个连续的高
2. 将其向左右扩展，更新答案

但是这样的时间复杂度是$\Theta{(n^3)}$的，我们考虑下怎么用dp的思路优化它……

首先，我们需要以下的值：
1. 一个点往上能扩展到哪里（u数组），定为高
2. 一个点往左能扩展到哪里（l数组）
3. 一个点往右能扩展到哪里（r数组）

很显然的，l和r不需要对于每个点$\Theta{(n)}$地求，它可以由同一行的左（右）一个格子转移过来

```cpp
for(register int i=1;i<=n;++i)
	for(register int j=2;j<=m;++j)
		if(a[i][j-1]&&a[i][j]) l[i][j]=l[i][j-1];
for(register int i=1;i<=n;++i)
	for(register int j=m-1;j>=1;--j)
		if(a[i][j+1]&&a[i][j]) r[i][j]=r[i][j+1];
```

这样，我们就$\Theta{(n^2)}$地预处理出了每个点的l和r

等等，但这样转移的话，不会出问题吗？？？
![](https://cdn.luogu.com.cn/upload/image_hosting/jrd68spe.png)

这样的一个矩形，如果它的高被更新之后，l和r怎么更新？
![](https://cdn.luogu.com.cn/upload/image_hosting/j4ab9lay.png)

看到，棕色的部分阻挡了下面扩展的路径，而且**大矩形的l和r正好是之前的l和r与这一行的l和r的最大值和最小值**！（拒绝感性理解）

所以当u有转移的时候，l和r也会跟着转移（压缩范围）

其中l会往右靠（如果有障碍的话），r会往左靠（同理），于是l取max，r取min
```cpp
for(register int i=1;i<=n;++i)
{
	for(register int j=1;j<=m;++j)
	{
		if(i-1&&a[i-1][j]&&a[i][j])
		{
			u[i][j]=u[i-1][j]+1;
			l[i][j]=max(l[i][j],l[i-1][j]);
			r[i][j]=min(r[i][j],r[i-1][j]);
		}
		ans=max(ans,(r[i][j]-l[i][j]+1)*u[i][j]);
	}
}
```

其实到这里，这个算法就结束了……
时间复杂度非常优秀，自己速速理解一下？

最后放上本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,ans;
bool a[1005][1005];
char c[2];
int u[1005][1005],l[1005][1005],r[1005][1005];

template<class T>inline void read(T &res)
{
	char c;T flag=1;
	while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
	while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}

int main()
{
	read(n);read(m);
	for(register int i=1;i<=n;++i)
	{
		for(register int j=1;j<=m;++j)
		{
            scanf("%s",c);
			if(c[0]=='F') a[i][j]=1;
			else a[i][j]=0;
			if(a[i][j]) u[i][j]=1,l[i][j]=r[i][j]=j;
		}
	}
	for(register int i=1;i<=n;++i)
		for(register int j=2;j<=m;++j)
			if(a[i][j-1]&&a[i][j]) l[i][j]=l[i][j-1];
	for(register int i=1;i<=n;++i)
		for(register int j=m-1;j>=1;--j)
			if(a[i][j+1]&&a[i][j]) r[i][j]=r[i][j+1];
	for(register int i=1;i<=n;++i)
	{
		for(register int j=1;j<=m;++j)
		{
			if(i-1&&a[i-1][j]&&a[i][j])
			{
				u[i][j]=u[i-1][j]+1;
				l[i][j]=max(l[i][j],l[i-1][j]);
				r[i][j]=min(r[i][j],r[i-1][j]);
			}
			ans=max(ans,(r[i][j]-l[i][j]+1)*u[i][j]);
		}
	}
	printf("%d\n",ans*3);
	return 0;
}
```

---

## 作者：ysy666 (赞：5)

这道题类似于1169棋盘制作的第二问~~~~（这不就是双倍经验嘛）~~~~

首先要进行一步预处理,在一个a数组中将F存为1,R存为0
我们还需要另外三个数组：

h:记录h为向上扩展，最高能到哪里

l:记l为向左拓展最左去到哪里;其中要保证,这些列向上h格均无障碍

r:同理,记r为向左拓展最右去到哪里;其中要保证,这些列向上h格均无障碍

所以最后的面积max(s[i,j]=(r[i,j]-j[i,j]-1)*h[i,j])         （注意这里的-1非常关键）

最后根据题意将最大面积乘三后输出

但是这种方法还有一个小问题，就是在寻找答案的过程中，不能保证一定会找到局部最优解，但一定能保证找到全局最优解

------------
附上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define N 1010
using namespace std;
int n,m,a[N][N],l[N][N],r[N][N],h[N][N],ans;
char c;
inline void solve()
{
	for(int i=1;i<=m;i++)  r[0][i]=m+1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)  h[i][j]=a[i][j]?h[i-1][j]+1:0;//h,代表这个位置向上的最高高度
		int t=0;
		for(int j=1;j<=m;j++)//l,代表向左的最长宽度
			if(a[i][j])  l[i][j]=max(l[i-1][j],t);
			else  l[i][j]=0,t=j;
		t=m+1;
		for(int j=m;j;j--)//r,代表向右的最长宽度
			if(a[i][j])  r[i][j]=min(r[i-1][j],t);
			else  r[i][j]=m+1,t=j;
		for(int j=1;j<=m;j++)  ans=max(ans,(r[i][j]-l[i][j]-1)*h[i][j]);//找最大面积
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			a[i][j]=(c=='F') ? 1:0;
		}
	solve();
	cout<<ans*3;
	return 0;
}
```

---

## 作者：溜肾污主xyt (赞：4)

### 不知道怎么没人用滚动数组优化空间？

今天刚学，教练讲了，便顺便A掉此题

本蒟蒻看了下题解，没人用**滚动数组优化空间**，便发一个来补充

使用方法也不难，因为数组更新至于i与i-1有关，所以**i&1表示i，1-(i&1)表示i-1** _(自行将i代入理解，此处不多赘述)_ 


------------


题目方法前面的大佬都讲了，略有出入，但无大不同，思路都是找出矩阵的左端点、右端点与高度，算出最大值
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int ri[2][1005],le[2][1005],up[2][1005],lo,ro,ans;
char mapp[1005];//二维数组可以省一维，因为解法只与当前行的字符有关
int main() {
	scanf("%d%d",&n,&m);
	memset(ri,63,sizeof ri);
	for(int i=1; i<=n; i++) { //i&1代表i，1-（i&1）代表i-1
		memset(up[i&1],0,sizeof up[i&1]);
		memset(le[i&1],0,sizeof le[i&1]);
		memset(ri[i&1],63,sizeof ri[i&1]);
		//滚动数组一定要初始化
		lo=0,ro=m+1;
		for(int j=1; j<=m; j++) { //更新左障碍位置
                        mapp[j]=getchar();
			while(mapp[j]!='F'&&mapp[j]!='R')mapp[j]=getchar();//输入
			if(mapp[j]=='R')lo=j;
			else {
				up[i&1][j]=up[1-(i&1)][j]+1;//更新高度
				le[i&1][j]=max(le[1-(i&1)][j],lo+1);//更新左端点位置
			}
		}
		for(int j=m; j>=1; j--) {
			if(mapp[j]=='R')ro=j;//更新右障碍位置
			else {
				ri[i&1][j]=min(ri[1-(i&1)][j],ro-1);//更新右端点位置
				ans=max(ans,(ri[i&1][j]-le[i&1][j]+1)*up[i&1][j]);//更新答案，式子意为矩阵大小
			}
		}
	}
	printf("%d",3*ans);
}
```
![评测记录](https://cdn.luogu.com.cn/upload/image_hosting/dr1t92pc.png)

如此优化，**800KB**，翻了下记录，**算我的代码内存最低**

希望大家点个赞支持一下orz


------------
2020.1.14 mapp一维数组空间优化



---

## 作者：Tony_Peter (赞：3)

[欢迎来博客看完整版(单调栈学习笔记)](https://th19960601tspp.blog.luogu.org/dan-diao-dui-lie-xue-xi-bi-ji)

蒟蒻的第二篇题解……QAQ请dalao们不要怼我。

讲一讲~~我自己的思路~~(其实是同学教的)吧，似乎不是很好的解？但我感觉比较好理解……

首先把输入的字符矩阵转移为数字，即s[i][j]代表第i行第j列这一格上面连续的F的个数(如果这一格是S的话就是0)，所以预处理之后就把样例变成了这样：

0 1 1 1 1 1

1 2 2 2 2 2

0 0 0 3 3 3

1 1 1 4 4 4

2 2 2 5 5 5

代码实现：
```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        char ch;
        cin>>ch;
        if(ch=='F') s[i][j]=s[i-1][j]+1;
    }
```

然后就有点类似于上面那道题了，每一行分开分析，找到每一个位置可以向左右扩展的最长的长度，这是矩形的长，而组成的矩形的宽就是这一格中对应的数字，所以向左右两边扩展的条件就是要扩展的那一格中的数字一定大于等于当前扫描到的这一格的数字。(似乎没太讲清楚啊QAQ)每一行处理出一个可以组成的矩形的最大面积，用一个maxn取最大值就可以找到最后的答案了。

代码实现：
```cpp
for(int i=1;i<=n;i++){
    int ans=0;//用于记录当前这一行的矩形最大面积
    for(int j=1;j<=m;j++){
        int l=j,r=j;//l代表左边能扩展到的最远位置，r代表右边能扩展到的最远位置
        while(l>=1&&s[i][l]>=s[i][j]) l--;
        l++;
        while(r<=m&&s[i][r]>=s[i][j]) r++;
        r--;
        ans=max(ans,s[i][j]*(r-l+1));//当前这一行的最大矩形面积
    }
    maxn=max(ans,maxn);//每一行的最大矩形面积比较取最大值
}
```

以下完整代码(没开O2的时候T了两个点)
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int N=1002;
int K,n,m;
int s[N][N];
int maxn=0;
int max(int x,int y){
    return x>y?x:y;
}
int main(){
    //scanf("%d",&K);
    //while(K--){
        memset(s,0,sizeof(s));
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++){
                char ch;
                cin>>ch;
                if(ch=='F') s[i][j]=s[i-1][j]+1;
            }
        for(int i=1;i<=n;i++){
            int ans=0;//用于记录当前这一行的矩形最大面积
            for(int j=1;j<=m;j++){
                int l=j,r=j;//l代表左边能扩展到的最远位置，r代表右边能扩展到的最远位置
                while(l>=1&&s[i][l]>=s[i][j]) l--;
                l++;
                while(r<=m&&s[i][r]>=s[i][j]) r++;
                r--;
                ans=max(ans,s[i][j]*(r-l+1));//当前这一行的最大矩形面积
            }
            maxn=max(ans,maxn);//每一行的最大矩形面积比较取最大值
        }
        printf("%d\n",maxn*3);//最后别忘了乘3
    //}
    return 0;
}

```
**最后感激一下教我思路的同学，大家可以去看一下她的标程QWQ**

[喏就是这个人](https://www.luogu.org/space/show?uid=113981)

---

## 作者：BreakPlus (赞：1)



这是一道**悬线法**的题。

悬线法一般用来求符合要求的最大子矩阵问题。我们定义：

$up_{i,j}$ 表示 $i,j$ 点向上悬线的长度。

$left_{i,j}$ 表示 $i,j$ 点向左扩展的最大长度。

$right_{i,j}$ 表示 $i,j$ 点向右扩展的最大长度。

但是这些并不能找出最大子矩阵。看这个子矩阵是否满足要求还要看下图的蓝色区域：

![](https://cdn.luogu.com.cn/upload/image_hosting/gegxjm34.png)

所以我们需要对三个数组更新，并且让 $left_{i,j}=\max\{left_{i,j},left_{i-1,j}\},right_{i,j}=\min\{right_{i,j},right_{i-1,j}\}$，答案为 $\max \{ up_{i,j} \times (right_{i,j}-left_{i,j}+1)\}$


注意这道题答案要 $\times 3$ ！~~（我开始就很好奇为什么样例没过掉后来才发现）~~

为了避免读入回车我就用 ``cin`` 读入了。

**[Code](https://www.luogu.com.cn/paste/ouw2ktav)**

---

## 作者：kaiyuan (赞：1)

在OI Wiki上发现一种方法——悬线法。

### 适用问题
给定一个m*n 的 01 矩阵a，求其面积最大的子矩阵，使得这个子矩阵中的每一位的值都为0 。

悬线法可以在O(n*m)的时间复杂度内解决以上问题。

### 悬线的定义
在讲解中，我们将值为1 的点称为“障碍点”。

悬线，就是一条竖线，这条竖线要满足其上端点在矩形的上边界或其上端点的上面是障碍点。

我们枚举每个点的悬线，求出其最多能向左和向右扩展到何处，取最大值，就能求出最大子矩阵了。


按照OI Wiki上的说法：

### 一些定义
	定义up[ i ][ j ] 为矩阵上的点(i,j)向上的悬线长度；
	定义left[ i ][ j ] 为点(i,j)向左最多扩展而不会碰到障碍点的长度；
	对应的，定义right[ i ][ j ]为点(i,j)向右最多扩展而不会碰到障碍点的长度。

### 用悬线法解决最大子矩阵问题
我们可以在O(nm)的时间复杂度内预处理出up,left,right数组的值。

但是，仅仅做出预处理是不够的。我们发现，一条悬线向左扩展的最长距离还取决于left[ i-up[ i ][ j ]+1][ j ],left[ i-up[ i ][ j ]+2][ j ],……，left[ i-1][ j ]向右同理。所以，我们在枚举时对left[ i ][ j ]和right[ i ][ j ]进行更新，使 
	
    left[ i ][ j ]=max{left[ i ][ j ],left[ i-1][ j]} ,
	right[ i ][ j ]=min{right[ i ][ j ],right[ i-1][ j]} 。

注意，我们在遇到障碍点的时候，不对left和right值进行更新，因为障碍点使悬线的起点有所不同。left记录的是向左最多能延伸到哪个点。所以应该是处理最接近j的那个，因此是max。

给个模板：
```cpp
for(int i=1;i<=n;i++)
  for (int j=1;j<=m;j++)
    scanf(" %c",s[i]+j), l[i][j]=r[i][j]=j,up[i][j]=1;
for(int i=1;i<=n;i++){
  for(int j=1;j<=m;j++)
    if(s[i][j]=='0'&&s[i][j-1]=='0') l[i][j]=l[i][j-1];
  for(int j=m;j>=1;j--)
    if(s[i][j]=='0'&&s[i][j+1] == '0')r[i][j]=r[i][j+1];
}
for(int i=1;i<=n;i++)
  for(int j=1;j<=m;j++) {
    if(i>1&& s[i][j]=='0'&&s[i-1][j]=='0') {
      l[i][j]=max(l[i][j],l[i-1][j]);
      r[i][j]=min(r[i][j],r[i-1][j]);
      up[i][j]=up[i-1][j]+1;
    }
    ans=max(ans,(r[i][j]-l[i][j]+1)*up[i][j]);
  }
```
最后，ans即为最大子矩阵的面积。

****以上文字来自[OI Wiki](https://oi-wiki.org/misc/largest-matrix/)
，有删改。

时间复杂度O(NM) 空间复杂度O(NM)

	优点： 复杂度与障碍点个数没有直接关系。
	缺点：障碍点少时处理较复杂,。
	当障碍点较多，n*m较小时，可以用悬线法。

分析该题为何能用悬线法：

#### 	1.可以转换为01矩阵；（重点！！！）
	2.n*m较小。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,m,a[N][N];
int l[N][N],r[N][N],h[N][N],ans=0;
char ch;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>ch;
            if(ch=='R') a[i][j]=1;
            else a[i][j]=0;
        }
    }
    for(int i=1;i<=m;i++) r[0][i]=m;
    
	for(int i=1;i<=n;i++){
        int maxr=m,maxl=1;
        
		for(int j=1;j<=m;j++){
            if(a[i][j]){
                maxl=j+1;
                h[i][j]=0;
                l[i][j]=0;
            }
			else{
                h[i][j]=h[i-1][j]+1;
                l[i][j]=max(maxl,l[i-1][j]);
            }
        }
        
		for(int j=m;j>0;j--){
            if(a[i][j]){
                maxr=j-1;
                r[i][j]=m;
            }
			else{
                r[i][j]=min(maxr,r[i-1][j]);
                ans=max(ans,(r[i][j]-l[i][j]+1)*h[i][j]);
            }
        }
    }
    
	cout<<ans*3;
    return 0;
}
```
**珍爱账号，远离棕名**。

P.S.注意：悬线法的限制条件（01矩阵）。因为不可能所有问题都会那么的美好，所以悬线法还是作为一种技巧来了解，顺便提一句：本题正解：单调栈。

~~去复习单调栈了（逃。qwq。~~




---

## 作者：太阳骑士 (赞：1)

显然可以用 0 和 1 来分别表示 R 和 F 的权值。

一开始想到用 $sum_{i,j}$ 表示从 (1, 1) 到 (i, j) 的矩形权值和，然后预处理出所有的 $sum_{i,j}$ ，因为最大的矩形一定可以由它的子矩形拓展得来，所以枚举矩形的左上角，然后二分长和宽， O(1) 计算出枚举的矩形的权值和，判断是否等于其面积，如果相等，即这个矩形是由 F 组成的，那么令 l = mid + 1，ans 取 max 即可，于是便完成了一个~~优秀~~的 $O(nm\log nm)$ 算法。但写完代码测样例不对......

接着感觉这题和 [Largest Rectangle in a Histogram](http://poj.org/problem?id=2559) 有点像，但是这题找出的由 F 组成的连通块的底部可能是凹凸不平的，而 Largest Rectangle in a Histogram 给出的直方图的底部一定是平整的，于是又想到枚举每一行，不考虑连通块中这一行以下的部分，然后用 Largest Rectangle in a Histogram 的单调栈算法取 max 即可。

复杂度： $O(nm)$ 

```cpp
//=========================
//  author:tyqs
//  date:2019.12.14
//  website:http://tyqs.kim
//=========================
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 1003
#define il inline
#define re register
#define tie0 cin.tie(0),cout.tie(0)
#define fastio ios::sync_with_stdio(false)
#define File(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout)
using namespace std;
typedef long long ll;

template <typename T> inline void read(T &x) {
	T f = 1; x = 0; char c;
    for (c = getchar(); !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x *= f;
}

int n, m, tp, ans;
int g[N][N], s[N][N], st[N], w[N];

void pre() {
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			if (!g[i-1][j]) s[i][j] = g[i][j];
			else if (g[i][j]) s[i][j] = s[i-1][j] + g[i][j];
		}
	}
}

void solve(int k) {
	memset(w, 0, sizeof w);
	int tot, tmp;
	tp = 0;
	for (int i = 1; i <= m; ++i) {
		if (s[k][i] > st[tp]) st[++tp] = s[k][i], w[tp] = 1;
		else {
			tot = 0;
			while (st[tp] > s[k][i]) {
				tot += w[tp];
				tmp = tot * st[tp--];
				ans = max(ans, tmp);
			}
			st[++tp] = s[k][i], w[tp] = tot + 1;
		}
	}
	tot = 0;
	while (tp) {
		tot += w[tp];
		tmp = tot * st[tp--];
		ans = max(ans, tmp);
	}
}

int main() {
	char c[10];
	read(n), read(m);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			scanf("%s", c + 1);
			if (c[1] == 'F') g[i][j] = 1;
			else g[i][j] = 0;
		}
	pre();
	for (int i = 1; i <= n; ++i) solve(i);
	printf("%d", ans * 3);
	return 0;
}
```

---

## 作者：Forever_Lin (赞：0)

    L[i][j]表示第i行第j个格子能向左延伸到第l[i][j]个格子，且在这一段区间内每个格子均为’F’，同理r[i][j]表示它能向右延伸到哪，up[i][j]表示它从第i行开始，能向上扩展多少行（包括第i行）

    初始化：
    L[i][j]=r[i][j]=j，up[i][j]=1
    
    
    读入后（读入字符时候要判断读的是字符还是换行符，这坑了我好长时间）
    If(a[i][j]==a[i][j-1]) l[i][j]=l[i][j-1]
    If(a[i][j]==a[i][j+1]) l[i][j]=l[i][j+1]
    If(a[i][j]==a[i-1][j]) up[i][j]=up[i-1][j]+1
    
    开始用悬线法
    For循环每一个点(i,j)
    如果a[i][j]==a[i-1][j]且i>1(这一点害我找了好长时间错)L[i][j]=max(l[i][j],l[i-1][j])，r[i][j]=min(r[i][j],r[i-1][j]),up[i][j]=up[i-1][j]+1
    
    然后计算答案ans=max(ans,(r[i][j]-l[i][j]+1)*up[i][j])

```
#include <bits/stdc++.h>
using namespace std;
int n,m,l[1100][1100],a[1100][1100],r[1100][1100],up[1100][1100],ans;
char ch;
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++) 
      {
          scanf("%c",&ch);
          while (ch!='R'&&ch!='F') scanf("%c",&ch);//cout<<ch<<endl;
          if (ch=='R') a[i][j]=1;
          else a[i][j]=0;
      }
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++) 
      if (a[i][j]==0)
      {
      	l[i][j]=r[i][j]=j;
      	up[i][j]=1;
      }
    for (int i=1;i<=n;i++)
      for (int j=2;j<=m;j++) 
        if (a[i][j]==a[i][j-1]&&a[i][j]==0) 
          l[i][j]=l[i][j-1];
    for (int i=1;i<=n;i++)
      for (int j=m-1;j;j--)
        if (a[i][j]==a[i][j+1]&&a[i][j]==0)
          r[i][j]=r[i][j+1];
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
      {
      	if (a[i][j]==1) continue;
      	if (i>1&&a[i][j]==a[i-1][j])
      	{
      		l[i][j]=max(l[i][j],l[i-1][j]);
      		r[i][j]=min(r[i][j],r[i-1][j]);
      		up[i][j]=up[i-1][j]+1;
      	}
      	//cout<<up[i][j]*(r[i][j]-l[i][j]+1)<<endl;
      	ans=max(ans,up[i][j]*(r[i][j]-l[i][j]+1));
      }
    printf("%d",3*ans);
    return 0;
}
```

---


# [蓝桥杯 2023 国 Java B] 游戏

## 题目描述

熊大和熊二在玩游戏。他们将 $n$ 个正整数 $a_1, a_2, \dots, a_n$ 排成一行，然后各用一个长度为 $k$ 的框在这个数组中各自随机框选出一段长度为 $k$ 的连续子序列（随机框选指在合法的 $n - k + 1$ 个连续子序列中均匀随机）。熊大记录了他框出的 $k$ 个数中的最大值 $P$，熊二记录了他框出的 $k$ 个数的最小值 $Q$，他们突然有个疑问：$P - Q$ 的期望是多少？

## 说明/提示

### 样例说明

一共有四种情况：

- 熊大框出 $[1, 2]$，$P = 2$；熊二框出 $[1, 2]$，$Q = 1$，$P - Q = 1$。
- 熊大框出 $[1, 2]$，$P = 2$；熊二框出 $[2, 3]$，$Q = 2$，$P - Q = 0$。
- 熊大框出 $[2, 3]$，$P = 3$；熊二框出 $[1, 2]$，$Q = 1$，$P - Q = 2$。
- 熊大框出 $[2, 3]$，$P = 3$；熊二框出 $[2, 3]$，$Q = 2$，$P - Q = 1$。

所以 $P - Q$ 的期望为 $(1 + 0 + 2 + 1) / 4 = 1.00$。

### 评测用例规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^2$。
- 对于 $40\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $n \leq 10^5$，$0 < a_i \leq 10^9$，$0 < k \leq n$。

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
1.00```

# 题解

## 作者：yihang2011 (赞：0)

### [P12225 [蓝桥杯 2023 国 Java B] 游戏](https://www.luogu.com.cn/problem/P12225)

看没有 ST 表的，写一个。

首先，是 ST 表板子求区间最大最小值，然后对于每个长度为 $k$ 的区间，最大值记为 $P_i$, 最小值记为 $Q_i$，题目要求的期望就是这玩意：

$$
\sum_{i = 1}^{n - k + 1} \sum_{j = 1}^{n - k + 1} \frac{1}{(n - k + 1) ^ 2}(P_i - Q_j)
$$

然后就稍微化简一下就好了：

$$
\begin{aligned}

& \sum_{i = 1}^{n - k + 1} \sum_{j = 1}^{n - k + 1} \frac{1}{(n - k + 1) ^ 2}(P_i - Q_j)

\\

= & \frac{1}{(n - k + 1) ^ 2} \sum_{i = 1}^{n - k + 1} \sum_{j = 1}^{n - k + 1} (P_i - Q_j)

\\

= & \frac{1}{(n - k + 1) ^ 2}[(n - k + 1)\sum_{i = 1}^{n - k + 1}P_i - (n - k + 1)\sum_{i = 1}^{n - k + 1}Q_i]

\\

= & \frac{1}{n - k + 1}(\sum_{i = 1}^{n - k + 1}P_i - \sum_{i = 1}^{n - k + 1}Q_i)

\end{aligned}
$$

所以最后只需要记录 $\sum_{i = 1}^{n - k + 1}P_i$ 和 $\sum_{i = 1}^{n - k + 1}Q_i$ 即最大值和以及最小值和就行了。

时间复杂度 $\mathcal{O}(n \log n)$，能过的。

当然，不开那个什么还是会见祖宗的。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i, l, r) for (int i = l; i <= r; i++) 
#define rrep(i, r, l) for (int i = r; i >= l; i--)
#define lrep(i, from, nxt) for (int i = from; i; i = nxt)
#define arep(x, s) for (auto &x : s)
#define pb(x) push_back(x)
#define mp(x, y) make_pair(x, y)
#define pqueue priority_queue
#define umap unordered_map
using ll = long long;

int rd() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0', ch = getchar();
    }
    return x * f;
}

constexpr int N = 1e5 + 10;
ll n, k, mx[N][25], mn[N][25], lg[N], sp, sq;

int main() {
    n = rd(), k = rd();
    lg[0] = -1;
    rep(i, 1, n) {
        mx[i][0] = mn[i][0] = rd();
        lg[i] = lg[i / 2] + 1;
    }
    rep(j, 1, 20) {
        rep(i, 1, n - (1 << j) + 1) {
            mx[i][j] = max(mx[i][j - 1], mx[i + (1 << (j - 1))][j - 1]);
            mn[i][j] = min(mn[i][j - 1], mn[i + (1 << (j - 1))][j - 1]);
        }
    }
    rep(i, 1, n - k + 1) {
        int l = i, r = i + k - 1, s = lg[k];
        sp += max(mx[l][s], mx[r - (1 << s) + 1][s]);
        sq += min(mn[l][s], mn[r - (1 << s) + 1][s]);
    }
    printf("%.2lf\n", 1.0 * (sp - sq) / (n - k + 1));
    return 0;
}
```

Java 的：

```java
import java.util.*;
import java.io.*;

public class Main {
    static final int N = 100010;
    static long n, k, sp, sq;
    static long[][] mx = new long[N][25];
    static long[][] mn = new long[N][25];
    static int[] lg = new int[N];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        k = scanner.nextInt();
        lg[0] = -1;
        for (int i = 1; i <= n; i++) {
            mx[i][0] = mn[i][0] = scanner.nextInt();
            lg[i] = lg[i / 2] + 1;
        }
        for (int j = 1; j <= 20; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                mx[i][j] = Math.max(mx[i][j - 1], mx[i + (1 << (j - 1))][j - 1]);
                mn[i][j] = Math.min(mn[i][j - 1], mn[i + (1 << (j - 1))][j - 1]);
            }
        }
        for (int i = 1; i <= n - k + 1; i++) {
            int l = i, r = i + (int) k - 1, s = lg[(int) k];
            sp += Math.max(mx[l][s], mx[r - (1 << s) + 1][s]);
            sq += Math.min(mn[l][s], mn[r - (1 << s) + 1][s]);
        }
        System.out.printf("%.2f\n", 1.0 * (sp - sq) / (n - k + 1));
        scanner.close();
    }
}
```

~~对了，一开始我写单调队列不小心卡了一个最优解。~~

---

## 作者：MonKeySort_ZYczc (赞：0)

说句闲话：不至于绿吧，毕竟板子是黄加个期望真不至于绿。
## 思路流程
连续 $k$ 个数最大值最小值？一眼[单调队列](https://www.luogu.com.cn/problem/P1886)啦。  
单调队列求出所有的 $P$ 与 $Q$ 后考虑期望如何求。  
期望嘛，本质就是个平均数啦。  
所有的 $P-Q$ 的和除以总数 $(n-k+1)^2$ 即可。  
给个柿子罢：  
$$
\frac{\sum_{n-k+1}^{i=1}\sum_{n-k+1}^{j=1}P_i-Q_j}{(n-k+1)^2}
$$  
但很明显，如果硬求所有 $P-Q$ 复杂度并不是很好，考虑优化。  
设 $s_p=\sum P_i$ 以及 $s_q=\sum Q_i$。  
容易发现（恕我说出这四个字），$s_p$ 与 $s_q$ 各被算了 $n-k+1$ 次，那么这一大坨：  
$$
\sum_{n-k+1}^{i=1}\sum_{n-k+1}^{j=1}P_i-Q_j
$$
实际上就是 $(n-k+1)s_p-(n-k+1)s_q$ 也就是 $(n-k+1)(s_p-s_q)$ 啦。  
所以原式本质上只要算 $\frac{(n-k+1)(s_p-s_q)}{(n-k+1)^2}$ 约分后就是 $\frac{s_p-s_q}{n-k+1}$ 喽。  
至于精度问题，只保留两位似乎问题不大，就恕我偷个懒罢。  
总时间复杂度：$O(n)$，很好看的一个复杂度！  
当然，不开那啥还是会见祖宗的。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=4e5+10;
int n,k,a[N],s1,s2;
int q1[N][2],h1=1,t1,q2[N][2],h2=1,t2;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) 
	{
		cin>>a[i];
		while(h1<=t1&&q1[h1][0]<=i-k) h1++;
		while(h2<=t2&&q2[h2][0]<=i-k) h2++;
		while(h1<=t1&&q1[t1][1]<=a[i]) t1--;
		while(h2<=t2&&q2[t2][1]>=a[i]) t2--;
		q1[++t1][0]=i;q1[t1][1]=a[i];q2[++t2][0]=i;q2[t2][1]=a[i];
		if(i>=k) s1+=(h1<=t1?q1[h1][1]:0),s2+=(h2<=t2?q2[h2][1]:0);
	}
	//cout<<s1<<' '<<s2<<'\n';
	cout<<fixed<<setprecision(2)<<double(s1-s2)/(n-k+1);
}

```

---

## 作者：W_C_B_H (赞：0)

[题目传送门](/problem/P12225)。

前置知识：单调队列、概率论初步。

Update 2025.04.19 18:46：本来写了篇 C++ 题解, 但是由于某些原因被打回了, 故写了 Java 的代码。

## 题意简述

给定正整数 $n,k$ 和 $n$ 个正整数 $a_1,a_2,\dots,a_n$，并均匀随机地抽取 $a$ 的两个长度为 $k$ 的连续子序列（两个子序列可以相同），求第一个子序列的最大值减去第二个子序列的最小值的期望。

## 题目分析

由概率论相关知识可得，答案等于第一个子序列的最大值的期望减去第二个子序列的最小值的期望。所以我们可以用单调队列分别维护最大值和最小值，求出期望后相减即可。

时间复杂度 $O(n)$，可以通过本题。

## 代码实现

代码如下：

```java
import java.util.Scanner;
public class Main {
    static final int N = 100005;
    static int n, k;
    static int[] a = new int[N];
    static int[] deque = new int[N]; // 用数组实现的双端队列
    static int head, tail;
    static double mn = 0, mx = 0;
    static void pop(int x) {
        while (head < tail && deque[head] < x) {
            head++;
        }
    }
    static void push1(int x) {  // 用于维护最小值
        while (head < tail && a[deque[tail - 1]] > a[x]) {
            tail--;
        }
        deque[tail++] = x;
    }
    static void push2(int x) {  // 用于维护最大值
        while (head < tail && a[deque[tail - 1]] < a[x]) {
            tail--;
        }
        deque[tail++] = x;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        k = scanner.nextInt();
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }
        head = tail = 0;
        for (int i = 1; i <= n; i++) {
            pop(i - k + 1);
            push1(i);
            if (i >= k) {
                mn += a[deque[head]];
            }
        }
        mn /= (n - k + 1); // 此时 mn 等于最小值的期望
        head = tail = 0;
        for (int i = 1; i <= n; i++) {
            pop(i - k + 1);
            push2(i);
            if (i >= k) {
                mx += a[deque[head]];
            }
        }
        mx /= (n - k + 1); // 此时 mx 等于最大值的期望
        System.out.printf("%.2f", mx - mn);
        scanner.close();
    }
}
```

---


# 琪露诺

## 题目描述

在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。

某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。

小河可以看作一列格子依次编号为 $0$ 到 $N$，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子 $i$ 时，她只移动到区间 $[i+L,i+R]$ 中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。

每一个格子都有一个冰冻指数 $A_i$，编号为 $0$ 的格子冰冻指数为 $0$。当琪露诺停留在那一格时就可以得到那一格的冰冻指数 $A_i$。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。

但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。

开始时，琪露诺在编号 $0$ 的格子上，只要她下一步的位置编号大于 $N$ 就算到达对岸。


## 说明/提示

对于 $60\%$ 的数据，$N \le 10^4$。

对于 $100\%$ 的数据，$N \le 2\times 10^5$，$-10^3 \le  A_i\le 10^3 $，$1 \le L \le R \le N $。数据保证最终答案不超过 $2^{31}-1$。


## 样例 #1

### 输入

```
5 2 3
0 12 3 11 7 -2
```

### 输出

```
11

```

# 题解

## 作者：灵乌路空 (赞：240)




先无良宣传一下博客 $wwwwww$    
[文章列表 - 地灵殿 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

$\text{Updata on 2019.11.10}$ : 全部重构   
感谢 胖虎x 与 Grass2_Ofalen  提出问题 $\sim$   
删除了之前由于数据水卡过去的 优先队列做法   

---

## 知识点 : $DP$ , 单调队列优化   

### [原题面](https://www.luogu.org/problem/P1725)   

### 题目要求 :   
  
  给定一长度为 $N + 1$ 的数列 $A$ , 第 $1$ 项为 $0$    
  以第一项为起点 ,  对于当前的位置 $i$    
  可以转移到: $(i + L, i + R)$ 中任意一位置       
  并且获得当前位置上 数的价值  .    
  
  求 : 当位置 $\ge N + 1$ 时可以取得的 最大价值和   
  
---

### 分析题意:   

  很显然的 $DP$ .   
  设 $f[i]$ 为: 到达位置 $i$ 时最大的价值和 , 则状态转移方程如下 :    
  $f[i] = \max(f[j]) + A[i]\ \ (i -R \le j \le i - L)$    
  
- 我会暴力 $!$     
  枚举每一位置 , 枚举每一可转移到该位置的 位置, 暴力进行转移   
  复杂度 $O(n ^ 2)$ , 取得了 $60$ 分的好成绩 (大雾)   
 
考虑优化 :   
 
   1. 转移到 位置 $i$ 的位置 ,  为区间 $\underline{[i-R,i+L]}$ 中 , $f[]$ 最大的位置   
  
   2. 转移到 位置 $i + 1$ 的位置 ,  为区间 $\underline{[i-R + 1,i-L + 1]}$ 中 , $f[]$ 最大的位置   
  
   3. 转移到 位置 $i + 2$ 的位置 ,  为区间 $\underline{[i - R + 2,i - L + 2]}$ 中 , $f[]$ 最大的位置   
  
后两个区间 ,  都可以通过 上一个区间 **右移一个单位** 得到    
这不禁让我们想到了另一道题 :    [P1886 滑动窗口](https://www.luogu.org/problemnew/show/P1886)  
如果您还未学习过单调队列 , 推荐这篇文章:     
[【洛谷日报﻿#9】 [Sweetlemon] 朝花中学OI队的奋斗历程——浅谈单调队列](https://sweetlemon.blog.luogu.org/dan-diao-dui-lie)    
  
这种 **滑动窗口型** 最值问题 ,  显然 , 可以通过 单调队列 来进行维护  .   
由上 ,  我们便找到了一种合适 $DP$ 优化方法 : 单调队列优化 .   

---

### 算法实现 :

顺序枚举 $[L, N]$ 的每一个位置 $i$.   
1. 将能够转移到 $i$ 的最靠右的位置 插入单调队列中   
2. 删除 单调队列首 不能转移到 $i$ 的位置   
3. 查询当前单调队列首的位置 , 即为能够转移到 $i$ 的价值最大的位置   
4. 若 $i + R > N$ , 说明位置 $i$ 能够跳到对岸 , 对此类位置的权值和取最大值, 即为答案   

---

附 $AC$ 代码 : 

```cpp
//By:Luckyblock
//バカって言うなぁ
#include <cstdio>
#include <cstring>
#include <ctype.h>
#define max(a, b) (a > b ? a : b)
const int MARX = 2e5 + 10;
const int INF = 2e9;
//=============================================================
int N, L, R, A[MARX], ans, f[MARX];//设 f[i]: 到达位置 i 时最大的价值和
int que[MARX], head = 1, tail = 1;//单调队列, 内部元素为位置 
//=============================================================
inline int read()
{
    int s = 1, w = 0; char ch = getchar();
    for(; !isdigit(ch); ch = getchar()) if(ch == '-') s = -1;
    for(; isdigit(ch); ch = getchar()) w = (w << 1) + (w << 3) + (ch ^ '0');
    return s * w;
}
void Insert(int i)//插入操作 
{
	for(; f[i] >= f[que[tail]] && tail >= head; ) tail --;//弹出权值和较小的 队尾元素 
	que[++ tail] = i;//入队 
}
int query(int x)
{
	for(; que[head] + R < x; ) head ++;//弹出队首 不可到达x位置的 不合法元素 
	return que[head];//回答询问 
}
//=============================================================
int main()
{
	memset(f, 128, sizeof(f));//初始化极小值 (每个字节赋128会导致自然溢出 
	f[0] = 0, ans = - INF; //初始化, 将0位置权值和 赋为0  
	N = read(), L = read(), R = read();
	for(int i = 0; i <= N; i ++) A[i] = read();
	
	for(int i = L; i <= N; i ++)
	{
	  Insert(i - L); //将最后一个 能够转移到i的位置 加入单调队列 
	  int from = query(i);//找到队首 权值和最大的位置 
	  f[i] = f[from] + A[i];//进行转移 
	  if(i + R > N) ans = max(ans, f[i]);//判断i能够跳到对岸, 计算答案 
	}
	printf("%d", ans);
	return 0;
}
```

---

附评论区的 $\text{Hack}$ 数据 , 重构题解后已过  


testdata1.in:   
```
5 3 4 0 1 2 3 4 5
```

testdata1.out   
```
4
```

testdata2.in:   
```
7 4 4 0 1 -4 -2 2 -5 3 2
```
testdata2.out:   
``` 
2
```

---

完成了这篇题解 , 东方众信仰 $++$  

---

## 作者：巨型方块 (赞：130)

首先么，一个dp，对不对，这个很简单。

f[i]=max{f[k](i-R<=k<=i-L)}+a[i];

但是纯dp肯定会超时，那么就要优化咯；

楼下的同学们已经指明了优化方法

1.单调队列

2.优先队列（大根堆）

个人更喜欢单调队列，不过嘛，优先队列也是值得学习的。

我这里给出用优先队列的程序，思想嘛，就是一个堆记录从1~i-L的max；另一个记录从1~i-R-1的max；

是不是把两个堆重复的部分删掉，就是i-L~i-R了，这一部分就是纯dp时需要枚举的k啊；

当然咯，我们只需要判断两个堆的max是否相同，相同了说明出现重复，把堆顶弹出就好了；

但是，如果出现所有的数据都一样怎么办呢，只要再用结构体把下标也放进去就好了；

当然，洛谷数据没有相同。。。。。那就怎么简单怎么来吧

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
priority_queue<int>q1,q2;
int n,R,L,ans;
int a[200010],f[200010];
int main()
{
    scanf("%d%d%d",&n,&L,&R);
    for(int i=0;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<L;i++)q2.push(a[i]);
    for(int i=L;i<=n;i++){
        q1.push(f[i-L]);
        if(i-R-1>=L)q2.push(f[i-R-1]);
        while(!q2.empty()&&q1.top()==q2.top()){
            q1.pop();q2.pop();
        }
        f[i]=q1.top()+a[i];            
    }
    for(int i=n-R+1;i<=n;i++)ans=max(ans,f[i]);
    printf("%d",ans);
}
```
话说stl真方便

---

## 作者：封禁用户 (赞：102)

PS：本篇题解适用于别的题解看不懂的萌新们，如有错误请指出。

看完题面不少同学，一下子没了思路，这篇题解将会把我的思考过程讲述给你们听，让你们~~恍然大悟、豁然开朗（此处省略10086字）~~

不太懂如何解题的同学们试着将题面中的区间 $[i+l,i+r]$ 更换成 $[i+x]$ 那么这道题就只有普及-的难度了，一道比较基础的 DP 了。我们可以得到状态转移方程：

$dp_i=dp_{i-x}+v_i$

（其中 $v_i$ 代表的是第 i 个数的权值）

这样我们就可以写出简化版的关键循环代码：
```cpp
for(int i=x;i<=n;i++)//从x开始,前面的格子跳不到
{
	dp[i]=dp[i-x]+v[i];
	if(i+x>n) //判断下一步是否直接跳到岸上
		ans=max(dp[i],ans);//记录最优答案
}
```
当然这里有一个“坑”（至少我这么认为），那就是编号小于 x 的  dp 值全部为零因为是从零开始跳，零跳不到的永远不可能被跳到或从这跳出去。

我们现在再回到原问题上，原问题仅仅是将第 i 个格子下一步可以跳到第 $[x+i]$ 个格子上改成了可以跳到区间 $[i+l,i+r]$ 的任意格子上，为了求出最优解，转移方程也就变成了：

$dp_i=max(dp_{i-r},dp_{i-r+1},dp_{i-r+2}\ldots dp_{i-l})+v_i$

这里再解释一下：因为当前节点的 dp 值是由之前节点的 dp 值决定的，所以第 i 个格子可以跳到 区间 $[i+l,i+r]$ 的任意格子上也就变成了第 i 个格子可以有 区间 $[i-r,i-l]$ 的任意格子跳到。

现在解决方案就非常明了了，我们只需要在每次循环中求出一个**定长区间最值**，这里方法有很多，推荐选择的是[单调队列](https://www.luogu.com.cn/problem/P1886)。

我们来看样例数据：

5 2 3

0 12 3 11 7 -2

队列里一开始为空，我们模拟一下队列：

$i=l=2$ 时 [ $\color{red}\text{0}$ ] 0 0 0 0 0

$i=3$ 时 [ $\color{red}\text{0}$ 0 ] 3 0 0 0 

$i=4$ 时 0 [ 0 $\color{red}\text{3}$ ] 11 0 0，但 0 比 3  老还比 3 弱所以 0 被弹出，队列应为 0 [ $\color{yellow}\text{0}$ $\color{red}\text{3}$ ] 11 0 0

$i=5$ 时 同理为 0 0 [ $\color{yellow}\text{3}$ $\color{red}\text{11}$ ] 11 0 0 

$i=6$ 时 同理为 0 0 3 [ $\color{red}\text{11}$ 11 ] 9

最后的 dp 数组为 0 0 3 11 11 9 很显然最大值是 11 。

PS：这里队列里存的是 dp 数组中对应的值，但实际为了判别是否在当前区间内，队列中存的应是编号。

关键代码：
```cpp
for(int i=l;i<=n;i++)//从l开始，前面的格子跳不到
{
	while(h<=t&&dq[h]<i-r) h++;//删去队首不在区间内的数
	while(h<=t&&dp[dq[t]]<dp[i-l]) t--;//删去队尾比新数小的数
	dq[++t]=i-l;//推入编号为 i-l 的数
	dp[i]=dp[dq[h]]+v[i];当前的 dp 值为区间最大值加上自己的权值
	if(i+r>n) 
		ans=max(dp[i],ans);//如果这个数下一步可以跳出的话，记录最优值
}
```

大家明白了吗？接下来就是完整的代码：（不要 copy 哟~~~）
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;

const int N=2e5+86;

int n,dp[N],l,r,ans=-0x3f3f3f3f,v[N],dq[N],h=1,t=0;
//有负数所以 ans 初始化为负无穷
int main()
{
	scanf("%d%d%d",&n,&l,&r);
	if(l>r) swap(l,r); //鲁棒性
	for(int i=0;i<=n;i++)
		scanf("%d",&v[i]);
	for(int i=l;i<=n;i++)
	{
		while(h<=t&&dq[h]<i-r) h++;
		while(h<=t&&dp[dq[t]]<dp[i-l]) t--;
		dq[++t]=i-l;
		dp[i]=dp[dq[h]]+v[i];
		if(i+r>n) 
			ans=max(dp[i],ans);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：_skyline (赞：81)

关于这题，我必须要发一篇题解了，主要是练习单调队列优化dp，然而看看其他题解有很多思路错了，比如当R>=2*L时f【R】就不一定为a【R】了，然而很多题解的初始赋值就是如此，下面讲一下我个人思路。

首先，必须要从L开始，对吧，这个时候我们用一个p来维护当前所能达到x的最末尾的，然后就是滑动窗口了，在此不赘述了。

以下是代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,l,r;
int a[3000000];
int q[3000000];//手写队列
int f[3000000];
int ans;
int main(){
	scanf("%d%d%d",&n,&l,&r);
	for(int x=0;x<=n;x++){
		scanf("%d",&a[x]);
	}
	int hed=1;//队首。
	int tal=1;//队尾
	memset(f,0xcf,sizeof(f));//赋值为无穷小
	ans=f[0];//同上
	f[0]=0;
	int p=0;
	for(int x=l;x<=n;x++){
		while(hed<=tal&&f[q[tal]]<=f[p]){
			tal--;//显然当不了max，于是可以弹出了
		}
		q[++tal]=p;//何时入队
		while(q[hed]+r<x){
			hed++;
		}//到不了x，出队
		f[x]=f[q[hed]]+a[x];
		p++;
	}
	for(int x=n+1-r;x<=n;x++){
		ans=max(ans,f[x]);//从n+1-r到n都可以跳出
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Tardis (赞：23)

首先这是一道动态规划的题目

如果不优化的话 只能得到部分分 要优化 必须用单调队列，线段树等等。（看到楼下写单调队列的挺少的，那我就来一个单调队列优化dp的）

首先明确 精灵只能从[i+l,i+r]转移过来 那么状态转移方程 ：

dp[i]=max(dp[k]) (k∈[i+l,i+r]) +a[i]; 因为题意说可以由大于n的数转移 那么就新增一个点 dp[n+1]=0；(主要还是避免负数)

明确一下 q为单调队列 维护的是从[i+l,i+r] dp[k]的最大值 （递减的）

首先dp[n-l+1]~dp[n]只能等于a[i] 先预处理一下

然后枚举i从n+1到l每次用dp[i]来更新dp[i-l] 然后把dp[i-l]打入单调队列 同时进行判断 如果i-1中右端点发生改变 那么就在i这个循环的末尾进行单调队列弹出队首元素


具体我们看一下代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define N 200001
int dp[N],a[N],n,l,r;
int q[N][2],head=1,tail=0;
int main()
{
    scanf("%d%d%d",&n,&l,&r);
    if(l>r) swap(l,r);//防止l比r大
    for(int i=0;i<=n;i++) scanf("%d",&a[i]);
    for(int i=n;i>=n-l+1;i--)
    {
        dp[i]=a[i];
    }
    for(int i=n+1;i>=l;i--)
    {
        while(tail>=head&&dp[i]>q[tail][0]) tail--;
        tail++;
        q[tail][0]=dp[i];
        q[tail][1]=i;
                //以上为将dp[i]打入单调队列
        dp[i-l]=q[head][0]+a[i-l];//更新
        if(i+r==q[head][1]) head++;//弹出
    }
    cout<<dp[0];
}

```

---

## 作者：chuzhitairan (赞：21)

这题显然是动态规划，如果设$a_i$为第i格的冰冻指数，$f_i$为跳到第$i$格所能获取的最大冰冻指数，那么有状态转移方程 
$$
f_i=max(f_j)+a_i(i-r \le j \le i-l)
$$
我们不妨先把标准动归写出来：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e5+1;
int n,l,r,a[maxn],f[maxn],ans=-1<<30;
int main()
{
	scanf("%d%d%d",&n,&l,&r);
	for(int i=0;i<=n;i++) scanf("%d",&a[i]);
	memset(f,0xcf,sizeof(f));f[0]=0;//由于冰冻指数可能是负数，所以一定要记得初始化
	for(int i=l;i<=n+r-1;i++)//第一步至少跳到第l格，最后一步至多跳到第n+r-1格 
	{
		for(int j=max(0,i-r);j<=i-l;j++) f[i]=max(f[i],f[j]+a[i]);
		if(i>=n) ans=max(ans,f[i]);//已经跳到对岸了再更新答案 
	}
	printf("%d",ans);
	return 0;
}
```
然而这样提交后，我惊喜地发现T了四个点  QwQ   
于是看了大佬们的题解后，决定去学习单调队列。其实单调队列很好理解，我就不在赘述，主要是想说一说本题中的运用：
* 首先，要一个一个进入队列的是$a$数组中的元素，所以外层循环为
```cpp
	for(int i=0;i<=n-l;i++)//只到n-l就结束了，因为接下来的再有一步就跳出去了，也就是数组越界
	{
	    	……
	}
```
* 然后，我们用k表示区间大小，则
$$
k=(i-l)-(i-r)+1=r-l+1
$$
* 于是套上单调队列的板子
```cpp
	for(int i=0;i<=n;i++)
	{
		while(s<=t && q[t]<f[i]) t--;
		q[++t]=f[i],p[t]=i;
		while(s<=t && p[s]<=i-k) s++;
		……
	}
```
* 最后，也是最关键的一步，我们一定要弄清楚每次要获取区间最大值的是谁，可不是$f_i$ ! 回想一下我们的状态转移方程，我们发现，**当区间右端点为i时，获取最大值的应该是$f_{i+l}$ !!!** 于是我们的最终代码就出来了
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,l,r,a[200001],f[200001],ans=-1<<30,p[200001],q[200001],s,t,k;
int main()
{
	scanf("%d%d%d",&n,&l,&r);
	for(int i=0;i<=n;i++) scanf("%d",&a[i]);
	s=1,t=0,k=r-l+1;
	memset(f,0xcf,sizeof(f));f[0]=0;
	for(int i=0;i<=n-l;i++)
	{
		while(s<=t && q[t]<f[i]) t--;
		q[++t]=f[i],p[t]=i;
		while(s<=t && p[s]<i-k+1) s++;
		f[i+l]=q[s]+a[i+l];
	}
	for(int i=n-r+1;i<=n;i++) ans=max(ans,f[i]);//当i已经等于n或下一步就大于n时更新答案
	printf("%d",ans);
	return 0;
}
```

短短二十行代码，蒟蒻我调了整整一上午……





---

## 作者：smilke (赞：21)

## Update 6.8
原来的做法已更新，并且更新了单调队列做法。

最后两组数据会WA，主要是因为没有判断DP状态的转移是否合法，如果该点是不能到达的，那么就不能用它更新后面的状态。

用一个数组$use[i]$标记一下$f[i]$的合法性就可以了。


------------


这是一道DP优化入门的好题。

读懂题意后，我们很容易想到这道题的状态以及转移。

设$f[i]$表示跳到第$i$个格子的最优值。

初始状态：$f[0]=0$，表示在原点的价值为0.

状态转移：$f[i]=max${$f[j]+a[i]$} $(j\in[i-r,i-l])$.

最终状态：$max(f[n+1]....f[n+l])$.(因为琪露诺最终跳到的区间范围是$[n+1,n+l]$).

于是我们就能拿到暴力的部分分。

考虑优化，我们发现，$f[i]$的取值只能由决策区间$[i-r,i-l]$转移而来，而$a[i]$是定值，所以我们只用考虑$f[i-r].... f[i-l]$的最优决策.

由DP的转移方程告诉我们，我们需要求的是决策的最大值。

那么我们自然地可以想到，用一种数据结构去维护决策的最优。

结合题目的情况，即：

$[i-l,i-r]$的决策影响状态$f[i]$的最大值。

$[i-l+1,i-r+1]$的决策影响状态$f[i+1]$的最大值。

每个$f[i]$相对应的是一个决策区间，而区间移动的长度是固定的，这不禁让人想到滑动窗口这道题，我们可以通过动态维护区间的最大值，从而节省一维枚举决策的时间。

维护区间最值可以用优先队列或者单调队列。

上面两种方式都能过，我们可以比较一下两种做法。

首先说优先队列的做法，对于堆里的元素我们需要用一个$vis[i]$数组来表示是否在队列里，然后看看堆里维护的区间是否超出了决策区间，删除堆顶元素直到符合条件为止。


每次移动的操作时间复杂度为$O(logn)$，所以总时间复杂度为$O(nlogn)$.

以下为代码：

```cpp
#include<bits/stdc++.h>
#define mp make_pair 
#define ll long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int N=1e6+50;
int n,l,r,a[N],f[N],vis[N],ans=-1e9,use[N];//use[i]标记f[i]是否合法
priority_queue< pair<int,int> > q;
int main(){
	scanf("%d%d%d",&n,&l,&r);
	rep(i,1,2*n) f[i]=-1e9;
	rep(i,0,n) scanf("%d",&a[i]);
	rep(i,l,r) use[i]=1;
	rep(i,0,n){
		if(i<l) {q.push(mp(-1e9,0));f[i+l]=a[i+l];continue;}
		int y=q.top().second; 
		if(i-r+l-1>=0) vis[i-r+l-1]=1;
		while(vis[y]||!use[y]) { q.pop(); if(q.empty()) break; y=q.top().second;} //删除堆顶不合法的决策
		q.push(mp(f[i],i));
		f[i+l]=q.top().first+a[i+l];
		if(use[i]) use[i+l]=1;
	}
	rep(i,n+1,n+l) if(use[i]) ans=max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```
类似的，我们也可以只维护一个单调递减的队列，每次决策的时候取出队头即为最优决策，省去了之前入堆的$log$（STL自带的$log$）。

由于每个状态只进出队一次，故总时间复杂度为$O(n)$.

以下为代码：
```cpp
#include<bits/stdc++.h>
#define mp make_pair 
#define ll long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int N=1e6+50;
int n,l,r,a[N],f[N],vis[N],ans=-1e9,use[N],q[N],L,R;
int main(){
	scanf("%d%d%d",&n,&l,&r);
	rep(i,1,2*n) f[i]=-1e9;
	rep(i,0,n) scanf("%d",&a[i]);
	rep(i,l,r) use[i]=1;
	rep(i,0,n){
		while(L<=R&&f[i]>f[q[R]]) R--;//维护的是单调递减的队列
		q[++R]=i;
		while(L<=R&&q[L]<i-r+l) L++;//合法的区间转移范围
		f[i+l]=f[q[L]]+a[i+l];
		if(use[i]) use[i+l]=1;
	}
	rep(i,n+1,n+l) if(use[i]) ans=max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```
可以发现，对于区间移动的最值，单调队列明显比优先队列好写，并且好维护，时间复杂度少一个$log$。

所以对于区间移动的最值问题，单调队列是一个非常好的解法。

（~~比STL的优先队列维护不知高到哪里去了~~）

---

## 作者：DEVILK (赞：18)

## 使用$deque$实现的单调队列优化$DP$

~~（看了一眼题解里还没有利用双端队列容器实现的单调队列，求通过）~~

更好的阅读体验点这里：[博客传送门](http://www.cnblogs.com/devilk-sjj/p/9072387.html)

关于单调队列的$deque$实现：[戳](http://www.cnblogs.com/devilk-sjj/p/9071069.html)

一道典型的$DP$题，已知$a[i]$为点i的冰冻指数，设$f[i]$为到达点$i$时获得的最大冰冻指数

则$f[i]$的状态是由$f[i+l, i+r]$转移来的

即$f[r]$的状态是由$f[i-r, i-l]$得到的.

可以求得状态转移方程：

　　$$f[i] = max\{f[i - j]\} + a[i]$$

　　$$l ≤ j ≤ r ≤ i$$

时间复杂度为$O(n^2)$，$n ≤ 200000$ 的范围显然是超时了.

考虑如何优化：

显然对于求$max\{f[i - j]\}$的过程是可以优化的，

用优先队列或者线段树？$O(n log_2 n)$确实是一个很优秀的复杂度，但是还有更优的：

单调队列，时间复杂度为$O(n)$.

每次把一个$f[p]$值放入$deque$中，维护序列的单调性（从大到小），

但如果某一次队头的元素的坐标已经不足以跳到当前点了，就要把队首$pop$出去

所以$deque$中存放的应是一个结构体或者$pair$.

那有没有可能在$pop$队尾的时候把之后的最优解$pop$掉呢？

现在要加入队列的元素坐标一定比队尾元素要大，而其值也比需要被$pop$掉的队尾元素大，

所以最优解不管怎么$pop$都会在队列里。

$[Code:]$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;

const int MAXN = 200000 + 1;

int n, l, r;
int a[MAXN];
int f[MAXN];
struct Node {
	int v, num;
};

deque<Node> q;

inline int read() {
	int x=0, f=1; char ch=getchar();
	while(ch<'0' || ch>'9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch>='0' && ch<='9')
		x=(x<<3)+(x<<1)+ch-48, ch=getchar();
	return x * f;
}

int main() {
	n = read(), l = read(), r = read();
	for(int i=0; i<=n; ++i)
		a[i] = read();
	int p = 0;
	for(int i=l; i<=n; ++i) {
// 求max{f[i-r, i-l]}
//		int maxn = 1 << 31;
//		int s = i-r<0 ? 0 : i-r;
//		for(int j=s; j<=i-l; ++j)
//			maxn = max(maxn, f[j]);
		while(!q.empty() && q.back().v < f[p])
			q.pop_back();
		q.push_back((Node){f[p], p});
		while(q.front().num + r < i) q.pop_front();
		f[i] = q.front().v + a[i];
		++p;
	}
	int ans = 1 << 31;
	for(int i=n-r+1; i<=n; ++i)
		ans = max(ans, f[i]);
	printf("%d\n", ans);
}
```

---

## 作者：田阙西 (赞：12)

費了九牛二虎之力終於a掉了這題。。。

首先我們要找到dp方程：

F[i]=max{f[k]}+a[i] , i-r<=k<=i-l, k>=0

千萬記住左邊是i-r，右邊是i-l！！！

我爲了這個wa了無數次。。。

由於只和f[k]的值以及編號有關，我們可以用單調隊列維護。

stl大法好！！
（不過不太建議noip選手使用。。。
我是因爲不會手寫才勉强用stl的）

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<map>
#include<vector>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
int n,l,r,ans=-2000000000;
int f[200001*2],a[200010*2];
struct mmm{int v,num;};
deque <mmm> q;
mmm x;
int fastRead()
{
	int f=1,re=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){re=re*10+c-'0';c=getchar();}
	return f*re;
}
int main()
{
	n=fastRead(),l=fastRead(),r=fastRead();
	for(int i=0;i<=n;i++)
	{
		a[i]=fastRead();
	} 
	memset(f,128,sizeof(f));
	f[0]=0;x.num=0;x.v=0;q.push_back(x);
	for(int i=l;i<=n+r;i++)
	{
		while(!q.empty()&&q.front().num<(i-r))q.pop_front();
		if(f[i-l]>-2000000)
		{
			x.v=f[i-l];x.num=i-l;
	    	while(!q.empty()&&q.back().v<=x.v)q.pop_back();
		    q.push_back(x);
		}	
		if(!q.empty())f[i]=q.front().v+a[i];
	}
	for(int i=n+1;i<=n+r;i++)
	ans=max(ans,f[i]);
	printf("%d",ans);
	return 0;
} 
```

---

## 作者：will5438 (赞：11)

## 优秀的唯一手写deque请看这里
### 首先第一个想法一定是DP
如果用f[i]表示到i位置的最大冰冻值
那么
### f[i]=max(f[i],a[i]+f[j]) (i-l<=j<=i-r)
我表示这种dp纯属套路，如果不会的话就去多做题ba

然后好看一点就是
### f[i]=max(f[j])+a[i] (i-l<=j<=i-r)
然后看到

说明
对于60%的数据：N <= 10,000 说明这样一定会T
### 考虑到Dp状态转移方程的单调性就知道只需求f[j]最值
#### 所以参考单调队列 不会的请  ☞☞☞ [P1886 滑动窗口](https://www.luogu.org/problemnew/show/P1886)
然后讲一下有几个小细节讲一下（由于~~数据水~~我被卡在10,80调了一会儿）
### 1.暴力把f[i]压入单调队列(emmm)
### 2.在head+r（即极限右端）小于i时 队头弹掉
### 3.在i位置把a[i+1-l]压入队列（个人写法比较好写)
### 4.在head+l>i最开始时不转移
### 5.在head+l>i单调队列不更新
细节好多啊（雾)
实测55ms
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=200010;
int a[Maxn],dp[Maxn],n,l,r,head=1,tail=0,ans;
struct data{
	int pos,val;
};
data deq[Maxn];
inline int read(){
	int e=0,f=1;
	char c;
	while(!isdigit(c=getchar())){ if(c=='-') f=-1;}
	do{ e=(e<<1)+(e<<3)+c-48; }
	while(isdigit(c=getchar()));
	return e*f;
}
int main(){
	n=read();n++;
	l=read();
	r=read();
	ans=-1e9;
	memset(dp,0xf3,sizeof(dp));
	dp[1]=0;
	deq[head]=data{1,dp[1]};
	for(register int i=1;i<=n;++i){ a[i]=read(); }
	for(register int i=2;i<=n;++i){
		if(deq[head].pos+r<i) head++;
		if(deq[head].pos+l<=i) dp[i]=deq[head].val+a[i];
		if(i-l<0) continue;
		while(dp[i-l+1]>=deq[tail].val&&head<=tail) tail--;
		deq[++tail]=data{i-l+1,dp[i-l+1]};
	}
	for(register int i=n-r;i<=n;++i) ans=max(ans,dp[i]);
	cout<<ans;
}
```


---

## 作者：B_1168 (赞：8)

读完题目，各位的第一反应想来都是dp吧

设 dp[i] 表达在第 i 个点能获得的最高冰冻值，可以写出

$dp[i]=\max(dp[j])+a[i] (\max(0,i-l)≤j≤i-r)$

留意到数据范围，$O(n^2)$显然不可承受，考虑优化

考虑从压缩查询$\max(dp[j])$ 的复杂度上入手:作为一个RMQ问题，这种问题显然有多种多样的解法；本题固然有单调队列、线段树等几种正解，在此本蒟蒻提供一个分块的写法吧：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=400010; //因为需要遍历从0到n+r的所有数据，且1≤r≤n,必须开设r+n的空间，保险起见，开双倍

int n,l,r,a[maxn],dp[maxn],ans=-1<<30,add[maxn],val[maxn],be[maxn],len;

void modify(int pt,int ad){//单点更新：留意到这里的ad直接替换dp[pt]的数值
	dp[pt]=ad;
	val[be[pt]]=max(val[be[pt]],dp[pt]);
}

int query(int from,int to){//样板查询，甚至可以直接复制
    int cnt=-(1<<30);//鉴于可能的负数数值，所有初始化数值必须为极小负数
    for(int i=from;i<=min(to,be[from]*len);i++) cnt=max(cnt,dp[i]);
    if(be[from]!=be[to]){
        for(int i=(be[to]-1)*len+1;i<=to;i++) cnt=max(cnt,dp[i]);
    }
    for(int i=be[from]+1;i<=be[to]-1;i++) cnt=max(cnt,val[i]);
    return cnt;
}


int main(){
	scanf("%d%d%d",&n,&l,&r);
	len=sqrt(n);
	for(int i=1;i<=n+r;i++)be[i]=(i-1)/len+1;
	for(int i=1;i<=n+r;i++){//运用HACK的数据，可知此初始化必须持续到n+r，否则正确答案为负时会输出0而不是正确的负数
		val[i]=-(1<<30);
		dp[i]=-(1<<30);
	}
	for(int i=0;i<=n;i++){
		scanf("%d",&a[i]);
		val[be[i]]=max(dp[i],val[be[i]]);//初始化，更新每一块的最小值
	}
	for(int i=l;i<=n+r-1;i++){
		dp[i]=max(dp[i],query(max(i-r,0),i-l)+a[i]); //此处就是转移方程的查询形式
//		printf("%d ",dp[i]);
		modify(i,dp[i]);//更新刚求出来的dp[i]
		if(i>=n) ans=max(ans,dp[i]); //如果i>=n，说明已经跳完，可以更新答案
	}
	printf("%d\n",ans);
}
```

很有趣的一点：吸氧与不吸氧之间的运行速度可谓天差地别。以下是评测记录：

![吸氧前：](https://cdn.luogu.com.cn/upload/image_hosting/mdt0mv48.png)

![吸氧后](https://cdn.luogu.com.cn/upload/image_hosting/ww1pvvla.png)

感谢审核的管理们！祝各位RP++！

---

## 作者：le_星辰 (赞：6)

看到很多人用单调队列来写，我发一个线段树的题解。
读题可以发现，每一个格子都是从编号为a-r到a-l之间的状态转移过来的，很容易想到动态规划，因为要让冰雪指数尽量大，不难写出转移方程：
```
f[i]=max(f[i],max(f[j]{j∈[i-R,i-L]})+num[i]);
```
知道了转移方程，在来看看数据范围，n<=200000,如果直接循环来扫一遍的话，时间复杂度为小常熟的n^2，绝对会超时，所以要用数据结构来维护，这个数据结构需要支持区间查询最值，那么就是一个RMQ问题，可以用倍增预处理，这里写一个线段树的。
```cpp
#include<bits/stdc++.h>
#define size 300000+10
using namespace std;
struct segment_tree{
	int l,r,data;
}t[4*size];//线段树要开4倍空间
int n,L,R;
int ans=-(1<<30);
int num[size],f[size];
void build(int p,int l,int r){//建树
	t[p].l=l,t[p].r=r;
	int mid=(l+r)/2;
	if(l==r){
		t[p].data=f[l];
		return;
	}
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	t[p].data=max(t[p*2].data,t[p*2+1].data);//递归向上传递最值
}
int ask(int p,int l,int r){//区间询问最值
	if(l<=t[p].l&&r>=t[p].r) return t[p].data;
	int mid=(t[p].l+t[p].r)/2;
	int val=-(1<<30);
	if(l<=mid) val=max(val,ask(p*2,l,r));
	if(r>mid) val=max(val,ask(p*2+1,l,r));
	return val;
}
void change(int p,int x,int v){
	if(t[p].l==t[p].r){
		t[p].data=v;
		return;
	}
	int mid=(t[p].l+t[p].r)/2;
	if(x<=mid) change(p*2,x,v);
	else change(p*2+1,x,v);
	t[p].data=max(t[p*2].data,t[p*2+1].data);
}
int main(){
	cin>>n>>L>>R;
	for(int i=1;i<=n;i++) f[i]=-(1<<30);
	for(int i=0;i<=n;i++) cin>>num[i];
	build(1,0,n);
	for(int i=1;i<=R;i++){
		if(i>=L){
			f[i]=max(ask(1,0,i-L)+num[i],f[i]);
			change(1,i,f[i]);
		}
	}
	for(int i=R+1;i<=n+L;i++){
		f[i]=max(f[i],ask(1,i-R,i-L)+num[i]);//上述转移方程
		change(1,i,f[i]);
	}
	for(int i=n+1;i<=n+L;i++){
		ans=max(ans,f[i]);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：redegg (赞：5)

哇，我又写了个线段树！

明显对于任何一个点i，它只有从(i-r~i-l)的点跳过来，那么转移就是这一段区间，快速查出区间最大值转移用线段树进行维护，很像dp，但是毕竟主要部分是快速查询和更新，这个不多讲了。

难看的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,ll,rr;

int a[400000];
int t[4000000];

void update(int v,int l,int r,int x,int id)
{
    if(l==r&&l==x)
    {
        t[id]=max(t[id],v);
        return ;
    }
    int mid=(l+r)/2;
    if(mid>=x)update(v,l,mid,x,id*2);
    if(mid<x)update(v,mid+1,r,x,id*2+1);
    t[id]=max(t[id*2],t[id*2+1]);
}

int cck(int l,int r,int z,int y,int id)
{
    //cout<<l<<" "<<r<<" "<<z<<" "<<y<<endl;
    //system("pause");
    if(l==z&&r==y)
    {
        return t[id];
    }
    int mid=(l+r)/2;
    //cout<<" "<<mid<<endl;
    if(mid>=y)return cck(l,mid,z,y,id*2);
    else if(mid<z)return cck(mid+1,r,z,y,id*2+1);
    else return max(cck(l,mid,z,mid,id*2),cck(mid+1,r,mid+1,y,id*2+1));
}

int main()
{
    scanf("%d%d%d",&n,&ll,&rr);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    update(a[1],1,n,1,1);
    for(int i=ll+1;i<=n+ll;i++)
    {
        //cout<<i<<" "<<max(i-rr,1)<<" "<<i-ll<<endl;
        int k=cck(1,n+ll,max(i-rr,1),i-ll,1)+a[i];
        //cout<<a[i]<<"   "<<k<<endl;
        update(k,1,n+ll,i,1);
    }
    int ans=cck(1,n+ll,n,n+ll,1);
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：Forever丶CIL (赞：5)

这个题朴素的dp思想很好想，大体可以应用一下数字三角形的思想

从后往前推，对于每个点i，它可以跳到i+L到i+R中的任意一格

假设我们在跳往i的路上走的是最优路，那么我们下一步一定要跳到

价值最大的那个格子上，即A[i]=max{A[i+L]...A[i+R]}+dt[i];

而这样的话我们的时间复杂度就是O(n\*(R-L))的，看一眼数据范围发现只能拿60分

那么我们就可以想了，怎么快速的找到A[i+L]到A[i+R]中最大的那一个呢？

单调队列，优先队列，线段树均可

以下给出线段树的做法



------------

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int dt[200001];
int A[2000001];
int n,L,R,ans=0;
int maxx=-10101000,from;
struct Tree
{
    int l;
    int r;
    int v;
    int add;
};
struct Tree T[200001*4];
void buildtree(int f,int ne,int poi)//建树 
{
    T[poi].l=f;
    T[poi].r=ne;
    if(f==ne)
    {
        T[poi].v=0;
        T[poi].add=f;  //用来存该区间最大数在原序列的位置 
        return ;
    }
    buildtree(f,(f+ne)/2,poi*2);
    buildtree((f+ne)/2+1,ne,poi*2+1);
    if(T[poi*2].v>T[poi*2+1].v)
    {
        T[poi].v=T[poi*2].v;
        T[poi].add=T[poi*2].add;
    }
    else
    {
        T[poi].v=T[poi*2+1].v;
        T[poi].add=T[poi*2+1].add;
    }
}
void insert(int go,int val,int poi)  //修改值（单点修改） 
{
    //printf("%d %d %d\n",go,val,poi);
    if(T[poi].l==go&&T[poi].r==go)
    {
        T[poi].v=val;
        return ;
    }
    int mid=(T[poi].l+T[poi].r)/2;
    if(go>mid) insert(go,val,poi*2+1);
    else insert(go,val,poi*2);
    if(T[poi*2].v>T[poi*2+1].v)
    {
        T[poi].v=T[poi*2].v;
        T[poi].add=T[poi*2].add;
    }
    else
    {
        T[poi].v=T[poi*2+1].v;
        T[poi].add=T[poi*2+1].add;
    }
}
void search(int f,int ne,int poi)  //查询区间最大值 
{
    if(T[poi].l==f&&T[poi].r==ne)
    {
        if(T[poi].v>maxx)
        {
            maxx=T[poi].v;    //区间最大值 
            from=T[poi].add;  //区间最大值的位置 
        }
        return ;
    }
    int mid=(T[poi].l+T[poi].r)/2;
    if(f>mid) search(f,ne,poi*2+1);
    else if(ne<=mid) search(f,ne,poi*2);
    else
    {
        search(f,mid,poi*2);
        search(mid+1,ne,poi*2+1);
    }
}
void dp()
{
    for(int i=n;i>=0;i--)
    {
        from=-1;
        maxx=-10101001;
        search(i+L,i+R,1);   //去找i+L到i+R中的最大值 
        A[i]=A[from]+dt[i];
        insert(i,A[i],1);  //用更新后的值去修改原来的值 
    }
}
void print()
{
    for(int i=0;i<=n+R;i++)
    {
        printf("%d ",A[i]);
    }
}
int main()
{
    scanf("%d%d%d",&n,&L,&R);
    for(int i=0;i<=n;i++)
    {
        scanf("%d",&dt[i]);
    }
    for(int i=n+1;i<=n+R;i++)
    {
        dt[i]=0;
    }
    buildtree(0,n+R,1);
    dp();
    //print();
    printf("%d",A[0]);  //因为起点是0号点 A[0]就表示从0号点出发的最大价值 
    return 0;
}
/*void dp()  //朴素dp（60分） 
{
    for(int i=n;i>=0;i--)
    {
        for(int j=L;j<=R;j++)
        {
            A[i]=max(A[i+j]+dt[i],A[i]);
        }
    }
}*/
```


------------

RP++

---

## 作者：AubRain (赞：4)

本题的做法很多，~~但作为一个蒟蒻，只会线段树瞎搞~~

做法：每次找j∈[i-r,i-l]区间里最大的f[j]来更新f[i]

先建树，每个节点的值都是0，每次用线段树查询区间最大值，再单点修改，把i点的值修改为f[i]

值得注意的地方：

i要从L开始循环，但查询的时候如果左端点是L-R就会越界，所以左端点要和0取个最大值

因为可以跳出去，所以最后找最大值的时候要往后找找

（线段树常数很大，但好像比STL优先队列要快一点）

代码:

```cpp
#include<bits/stdc++.h>
#define N 400005

using namespace std;

inline int read()
{
    int X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}

int n,f[N],a[N],L,R,ans;

struct tree
{
    int l,r;
    int sum,add;
    #define l(x) t[x].l
    #define r(x) t[x].r
    #define sum(x) t[x].sum
}t[N<<2];

void change(int p ,int x,int d)
{
    if(l(p)==r(p)){sum(p)=d; return ;}

    int mid=l(p)+r(p)>>1;

    int r1=p<<1;
    int r2=(p<<1)+1;

    if(x<=mid) change(r1,x,d);
    else change(r2,x,d);

    sum(p)=max(sum(r1),sum(r2));

}

int  ask(int p,int l,int r)
{
    if(l<=l(p)&&r>=r(p))
        return sum(p);

    int mid=l(p)+r(p)>>1;

    int v=0;

    int r1=p<<1;
    int r2=(p<<1)+1;

    if(l<=mid) v=max(v,ask(r1,l,r));
    if(r >mid) v=max(v,ask(r2,l,r));

    return v;

}

void build(int p,int l,int r)
{
    l(p)=l,r(p)=r;

    if(l==r){sum(p)=f[l]; return ;}

    int mid=l+r>>1;

    int r1=p<<1;
    int r2=(p<<1)+1;

    build(r1,l,mid);
    build(r2,mid+1,r);

    sum(p)=sum(r1)+sum(r2);

}

signed main()
{
    scanf("%d%d%d",&n,&L,&R);
	for(int i=0;i<=n;i++)
		scanf("%d",&a[i]);
	
	build(1,0,n+R+1);

	for(int i=L;i<=n+R;i++)
	{
		f[i]=ask(1,max(0,i-R),i-L)+a[i];
		change(1,i,f[i]);
	}
	for(int i=n;i<=n+R;i++)
		ans=max(ans,f[i]);
	printf("%d",ans);
    return 0;
}
```

---

## 作者：YZhe (赞：3)

相信读完题就能看出这是一道简单的dp题

状态转移方程也很容易想到

即：**dp[i] = max{区间内的最大dp值}+该点的权值**

这种算法的最坏复杂度为**O(n^2)**，而本题的数据是1e5级别的，这样的复杂度显然不正确，必须优化


### 优化


哪一步可以优化呢？

我们又发现每次跳的区间都是一个固定长度，自然而然地想到了一个经典的问题：[滑动窗口问题](https://www.luogu.org/problemnew/show/P1886)，即单调队列，可以让我们做到**O(n)预处理**，**O(1)找到任意固定长度区间内的最值**~~不要尝试在没有学会单调队列的情况下做这道题~~

有了单调队列，我们的dp过程可以省去枚举区间内的每个元素的过程，总复杂度也由O(n^2)降到**O(n)**，完全没有压力

### 如何实现

在代码中由注释进行讲解
```cpp
#include<cstdio>
using namespace std;
#define oo 0x3f3f3f3f 
#define ri register int
const int N = 200005;
int n,l,r,head = 1,tail = 0,cur = 0,ans = -oo,a[N],q[N],dp[N];
//head,tail分别是单调队列的首尾指针,cur是指向当前待入队列的元素，a存权值，q为单调队列(手打) 
inline int max( int a , int b ){return a > b ? a : b; }//手打max 
template<class T>
inline void read(T &res){
    static char ch;T flag = 1;
	while( ( ch = getchar() ) < '0' || ch > '9' ) if( ch == '-' ) flag = -1;
	res = ch - 48;
	while( ( ch = getchar() ) >= '0' && ch <= '9' ) res = res * 10 + ch - 48;
	res *= flag;
}//快读 
int main()
{
    read( n );read( l );read( r );
    for( ri i = 0 ; i <= n ; i++ ) read( a[ i ] );
    for( ri i = 1 ; i <= n ; i++ ) dp[ i ] = -oo;//初始化 
    for( ri i = 1 ; i <= n ; i++ ){
    	//由于一个点可到达的区间为[i+l,i+r],因此可以到达一个点的区间为[i-r,i-l],注意不要越界 
    	while( i - cur >= l ){//让能够入队的结点入队 
    		while( head <= tail && dp[ cur ] >= dp[ q[ tail ] ] ) tail--;
			//由于单调队列是单调递减的，所以我们要删除队尾那些dp值小于待入队结点dp值的结点 
			q[ ++tail ] = cur++;//入队 
    	}
    	while( head <= cur && i - q[ head ] > r ) head++;
		//如果队列的头已经不再界限内，则不可能再更新当前 
    	if( head <= tail )//注意，当队列不为空时才可以转移 
		  dp[ i ] = dp[ q[ head ] ] + a[ i ];
    }
    //因为题目说只要下一步的位置编号大于N就算到达对岸 
	//所以最后得出答案，为区间[n-r+1,n]中的dp最大值 
    for( ri i = n ; i >= n - r + 1 ; i-- )
	  ans = max( ans , dp[ i ] );
    printf( "%d\n" , ans );
	return 0;
}
```
如果嫌这道题太简单，可以尝试P[P3957 跳房子](https://www.luogu.org/problemnew/show/P3957)

#### 感谢观看！

---

## 作者：zeromaker (赞：3)

虽然比赛的时候也是用单调队列水过去的，但是作为C党，这题事实上可以用两个优先队列水过去，虽然复杂度变成了O（nlogn），但是对于本题还是可以接受的。

dp方程很简单，dp[i]=max（dp[k]）（k>=i+ll && k<=i+rr）+arr[i]，如果K没有限制的话只需要把所有的数扔到一个优先队列里，每次取最小的就可以了，但是关键是k是在[i+ll,i+rr]范围内，这时候我们只需要维护第二个优先队列，这个多出来的优先队列的意义是：删除，每次把第一个优先队列当中的最大值取出，再把第二个优先队列当中的最大值取出，如果这两个数一样，说明这次取出的最优解事实上是走不到的（即之前已经被删除了），这时候就把两个优先队列往后弹，弹到不一样为止，就取出了范围内的最大值，加上arr[i]即可。然后每次再把超出范围的数加入到删除队列当中，把添加的添加到添加队列中，问题就解决了

```cpp

#include<iostream>
#include<stdio.h>
#include<string.h>
#include<string>
#include<algorithm>
#include<stdlib.h>
#include<math.h>
#include<queue>
using namespace std;

const int Maxn=200010;
priority_queue<int> q1,q2;
int n,ll,rr;
int arr[Maxn],dp[Maxn];

int main()
{
    scanf("%d%d%d",&n,&ll,&rr);
    n++;
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&arr[i]);
        dp[i]=arr[i];
    }
    for (int i=n-ll;i>=1;i--)
    {
        int x1=0,x2=0;
        q1.push(dp[i+ll]);
        if (i<n-rr)
            q2.push(dp[i+rr+1]);
        if (q2.empty())
        {
            x1=q1.top();
        }
        else
        {
            x1=q1.top();
            x2=q2.top();
        }
        while (x1==x2 && !q2.empty())
        {
            x1=q1.top();
            x2=q2.top();
            q2.pop();
            q1.pop();
        }
        if (i>n-rr)
        {
            dp[i]=max(dp[i],dp[i]+x1);
        }
        else
        {
            dp[i]=dp[i]+x1;
        }
    }
    printf("%d\n",dp[1]);
}

```

---

## 作者：courage (赞：3)

很容易看出本题是动态规划，假设到达第i格时获得的冰冻指数为f[i]，则有转移方程：


**f[i]=max{f[i-R],f[i-R+1],……,f[i-L]}+a[i]**

正好满足单调队列的性质，所以可以维护一个单调递减队列，每到一个格子i先将队列中编号小于i-R的元素出列（从队首开始做），然后将队尾不大于f[i-L]的元素出列，最后将f[i-L]压入队尾，则f[i]=a[i]+f[队首]


时间复杂度为**[color=red]O(n)[/color]**


要特别注意边界与初始值

参考代码：

```cpp

#include<cstdio>
int f[200010],a[200010],b[200010],p,q,n,m,ans,l,r;
int main(){
    scanf("%d%d%d",&n,&l,&r);
    for (int i=0;i<=n;i++) scanf("%d",&a[i]);
    for (int i=0;i<l;i++) f[i]=0;
    p=q=1;
    b[p]=0;
    for (int i=l;i<=n;i++){
        while (b[p]<i-r) p++;
        while (p<=q  && f[b[q]]<=f[i-l]) q--;
        q++;
        b[q]=i-l;
        f[i]=f[b[p]]+a[i];
    }
    ans=f[n-r+1];
    for (int i=n-r+2;i<=n;i++) if (ans<f[i]) ans=f[i];
    printf("%d",ans);
}

```

---

## 作者：麻花 (赞：3)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf = -300000000;
int n, l, r;
int a[200001], f[200001];//DP数组
int q[200001], b = 1, e = 0;//定义队列
int main()
{
	cin >> n >> l >> r;
	for (int i = 0; i <= n; i++)
		scanf("%d", &a[i]);	
	for (int i = 1; i <= n; i++) f[i] = inf;//把F数组赋值为最小
	f[0] = 0;
	for (int i = l; i <= n; i++)
	{
		while (b <= e && q[b] + r < i) b++;//判断是不是第一个
		while (b <= e && f[i-l] > f[  q[e] ]) e--; //把e弹出去
		if (f[i-l] != inf)//加新元素
		{	
			e++;
			q[e] = i-l;
		}
		
		f[i] = a[i] + f[q[b]];//找最优秀的答案（队首）
	}
	int ans = inf;
	for (int i = n+1-r; i <= n; i++)
		if (f[i] > ans) ans = f[i];//判断区间
	cout << ans << endl;
	return 0;
}
```


---

## 作者：倔强的咸鱼 (赞：2)

**滚动数组优化**

看了几篇题解，大佬貌似都是用优先队列或者单调队列优化的dp，蒟蒻对单调队列这一块真的特别弱，所以写了一个裸的背包dp。。。

简单可知状态转移方程为：dp[i] = max(dp[i-r,i-l])+dp[i];

简单思考一下dp的原理，我只需要保证到达当前状态的值的最大的，我就能保证保证到达i+r，i+l时的近似最优，在多个近似最优里面挑出最优即可。因为这是一个从前往后跳的过程，前面的状态不会被后面的状态影响，考虑滚动数组优化。

最后就是找答案方面，应该在n到n+r的范围内找出最大即可（即dp数组设置为双倍大小）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e6+5;
const int INF = -0x3f3f3f3f;

int dp[maxn << 1],a[maxn];

int main()
{
    int n,l,r;
    scanf("%d%d%d",&n,&l,&r);
    memset(dp,INF,sizeof(dp));
    memset(a,0,sizeof(a));
    for(int i = 0;i <= n;++i) scanf("%d",&a[i]);

    dp[0] = a[0];
    for(int i = 0;i <= n;++i){
        if(dp[i] != INF){
            for(int j = i+l;j <= i+r;++j){
                dp[j] = max(dp[j],dp[i]+a[j]);
            }
        }
    }

    int ans = INF;
    for(int i = n;i <= n+r;++i) ans = max(ans,dp[i]);
    printf("%d\n",ans);
    return 0;
}
```

也是这题测试数据比较水，这样就能不超时卡过去了，正解应该还是要队列优化的。

可能该想法还有我没想到的漏洞。。。大佬看见了请留言。。。thx

---

## 作者：Eric100911 (赞：2)

首先，这道题目转移方程并不难想:
$dp[i]=max_{j\in[i-l+1,i-r+1]}(dp[j]+A[i])$
#### 然后，数据量高达200000，绝对不可能用传统的$O(n^2)$双重循环
再分析，会发现其中一维的复杂度被用于寻找定长带修区间最值，因而可以对症下药
#### 利用单调队列，维护一个长$r-l+1$的区间最值
本人使用结构体封装好的单调队列实现，结合快读，即可解决，代码附上
```cpp
#include<bits/stdc++.h>
#define MAXN 200005
using namespace std;
struct monoqueue{
    #define data int  //鄙人蒟蒻，不会template  
    int head,tail,pos[MAXN];
    data num[MAXN];
    void clear(){head=1;tail=0;}
    bool empty(){return head>tail;}
    data front(){return num[head];}
    data back(){return num[tail];}
    void push(data x,int p,int len,bool MODE){//MODE为0时设定为升序单调队列 
        if(MODE){
            while(x>=num[tail]&&head<=tail) tail--;
            num[++tail]=x; pos[tail]=p;
            while(pos[head]<=p-len&&head<=tail) head++;
        }
        else{
            while(x<=num[tail]&&head<=tail) tail--;
            num[++tail]=x; pos[tail]=p;
            while(pos[head]<=p-len&&head<=tail) head++;
        }//带分类的push
    }
    void out(){
    	for(int i=head;i<=tail;i++) cout<<num[i]<<' ';
    	cout<<endl;
	}
};
monoqueue Q;
int A[MAXN],dp[MAXN<<1],N,L,R;
inline int read(){
    register int x=0;
    register bool f=1;
    register char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') f=0;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<1)+(x<<3)+(ch-'0');
        ch=getchar();
    }
    return f?x:-x;
}
int main(){
	register int ans=-2147483647;
    N=read(),L=read(),R=read();
    for(int i=0;i<=N;i++) A[i]=read();
    Q.clear();
    for(int i=L;i<N+L;i++){
        dp[i]=Q.front()+A[i];
        Q.push(dp[i-L+1],i-L+1,R-L+1,1);
        //Q.out();cout<<endl;
    }
    for(int i=N;i<N+R;i++) ans=max(ans,dp[i]);
    cout<<ans<<endl;//令人舒心的一行
    return 0;
}
```

---

## 作者：PiCaHor (赞：2)

dp【i】表示i格的最大位置 维护一个不上升的队列， 存i-l——————i-r的最大 O（1） 查询 重载了比较

代码如下：：：：：：  没看懂私信

```
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <cstring> 
#include <queue>  
#define LL long long 
using namespace std;

struct node 
{
    LL id,c; 
 	bool operator < (const node &a) const   
    {
        return a.c > c; 
    } 
}s; 
 

priority_queue <node> q; 
const int N=300020; 
int n,l,r,a[N]; 
LL ans,f[N];  

int main()
{
  scanf("%d%d%d",&n,&l,&r); 
  for(int i=0;i<=n;i++) 
  {
  	scanf("%d",&a[i]); 
  }    	
  s.id=0; s.c=0;  
  q.push(s); 
  for(int i=1;i<l;i++)  f[i]=0;  
  for(int i=l;i<=n+r;i++) 
  { 
    s.id=i-l; s.c=f[i-l]; 
    q.push(s); 
  	while(q.top().id<i-r) q.pop(); 
  	f[i]=q.top().c+a[i]; 
  }   
  for(int i=n+1;i<=n+r;i++) ans=max(ans,f[i]); 
  printf("%d\n",ans); 
  return 0;
}
```

---

## 作者：zhaimingshuzms (赞：2)

#这题有个信仰优化（详见代码最后一行）

虽然自己已经转c++但是偶然翻到了之前自己的一个pascal程序；有一些心得；

首先很容易想到f[i]表示到第i格时最大的冰冻值，j暴扫i-r至i-l，但这样要超时，就不得已要维护一个可以转移的f的最小值。

底下的题解有用线段树，优先队列，堆，维护i之前的最小值的，但实际上这是杀鸡用牛刀（常数太大，运行时间反而慢），手动开一个队列，h是符合条件（j>=i-r）范围的指针，指向符合上述条件的最大f值，t用于不断更新队列。这样写虽然最坏时间复杂度是Ω（N^2）不如用高级数据结构的代码，但只要代码不要自带大常数，由于常数小、没有卡的数据，可以完爆用高级数据结构的。

接下来贴代码，最后一行的玄学优化，可以使运行速度提高4倍（多次实测）

********************************************************************************


```cpp
type rr=record
     x,y:longint;
     end;
var n,l,r,i,t,h,j,max:longint;
    f,a:array[-10..200000] of longint;
    q:array[-10..200000] of rr;
procedure push;
begin
  while (f[i-l+1]>=q[t].x) and (t>=h) do dec(t);
  inc(t);
  q[t].x:=f[i-l+1];
  q[t].y:=i-l+1;
end;
begin
  read(n,l,r);
  for i:=0 to n do
  read(a[i]);
  for i:=l to n do
  begin
    if (q[h].y<i-r) then inc(h);
    f[i]:=q[h].x+a[i];
    push;
  end;
  for i:=n-r to n do
  if f[i]>max then max:=f[i];
  write(max);
end.
end.//传说中的信仰优化，不知为何加了这行没用的话快4倍，删了这行慢4倍，求大神指点（私信zhaimingshuzms）
```

---

## 作者：XUCHENGHUI (赞：1)

由于数据范围很大，所以DP得优化。

这里就想到一个单调队列，维护一个单调递减的队列，在i时，将之前i-min(l,r)+1加入队中。找到打的就将之前小的弹出。

并用place和s1维护位置，就可以一直使用当前最大值。

最后多循环min(l,r)-1次，求出答案

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
int i,j,k,n,m,top,s1,s2,l,r,x1,x2;
int a[200005],f[200005],p[200005];
struct stevenson
{
    int place;
    int num;
}q[200005];
int read(void) {         //读入优化
    char c; while (c=getchar(),(c<'0' || c>'9') && c!='-'); int x=0,y=1;
    if (c=='-') y=-1; else x=c-'0'; 
    while (c=getchar(),c>='0' && c<='9') x=x*10+c-'0'; return x*y;
}
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
int main()
{
    n=read(); l=read(); r=read(); x1=max(l,r); x2=min(l,r); q[0].num=2e9; s1=1; s2=x2-1;
    for(int i=0;i<=n;i++) a[i]=read(); 
    for(int i=x2;i<=n+x2-1;i++)
    {
        s2++;
        if(i-x1>q[s1].place) s1++;
        f[i]=a[i]+q[s1].num; p[i]=s2;
        while(f[i-x2+1]>q[top].num&&top>=s1) 
        top--;
        top++;
        q[top].num=f[i-x2+1]; q[top].place=p[i-x2+1]; 
    }
    printf("%d",f[n+x2-1]);
    return 0;
}

```

---

## 作者：cyn2006 (赞：0)

$dp$模板题。。。


------------

### 思路：

发现可以用$dp_i$表示第$i$格的最大值，转移范围在$(i-R)$~$(i-L)$之间。

所以需要维护某一个固定长度的区间内的最大值。



------------

### 方法$1$：

单调队列：

用$q_i$表示队伍的编号，单调队列模板水一下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 400005
#define rep(i,x,y) for(int i=x;i<=y;i++)
int dp[N],a[N],n,q[N];
template<typename T> inline void read(T&x) {
    char ch=getchar();
    x=0;
    bool f=0;
    for(; ch<'0'||ch>'9'; ch=getchar())if(ch=='-')f=1;
    for(; ch>='0'&&ch<='9'; x=(x<<1)+(x<<3)+(ch&15),ch=getchar());
    if(f)x=-x;
}
template<typename T> inline void write(T x) {
    if(x<0)x=-x,putchar('-');
    if(x>9)write(x/10);
    putchar(x%10|48);
}
template<typename T> inline void writeln(T x) {
    write(x),putchar('\n');
}

int main(){
    int L,R;
    cin>>n>>L>>R;
    for(int i=0;i<=n;i++)read(a[i]);
    memset(dp,128,sizeof(dp));
    int head=1,tail=0,ans=-2e9;
    dp[0]=0;
    for(int i=L;i<=n+n;i++){
        int l=max(0,i-R),r=max(0,i-L);
        while(q[head]<l&&head<=tail)head++;
        while(dp[q[tail]]<=dp[r]&&head<=tail)tail--;
        q[++tail]=r,dp[i]=dp[q[head]]+a[i];
        ans=max(ans,dp[i]);
    }
    cout<<ans;
    return 0;
} 
//BY CYN 
```

复杂度$O(N)$



------------

## 方法$2$：

~~我不会单调队列怎么办？~~

用分块维护区间最大值（带修改），块的大小取$n^{\frac{1}{3}}$较优。

在单点位置上修改，

查询时边角暴力，块内跳着查询。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 400005
#define rep(i,x,y) for(int i=x;i<=y;i++)
int dp[N],pre[N],add[N],a[N];
int bel[N],cnt,n,m;
template<typename T> inline void read(T&x) {
    char ch=getchar();
    x=0;
    bool f=0;
    for(; ch<'0'||ch>'9'; ch=getchar())if(ch=='-')f=1;
    for(; ch>='0'&&ch<='9'; x=(x<<1)+(x<<3)+(ch&15),ch=getchar());
    if(f)x=-x;
}
template<typename T> inline void write(T x) {
    if(x<0)x=-x,putchar('-');
    if(x>9)write(x/10);
    putchar(x%10|48);
}
template<typename T> inline void writeln(T x) {
    write(x),putchar('\n');
}
inline void Res(int x){
    pre[x]=-2e9;
    rep(i,(x-1)*cnt+1,min(cnt*x,n))pre[x]=max(pre[x],dp[i]);
}
inline void update(int p,int val){
    a[p]=val;
    Res(bel[p]);
}
inline int query(int l,int r){
    int ans=-2e9;
    rep(i,l,min(bel[l]*cnt,r))ans=max(ans,dp[i]);
    if(bel[l]!=bel[r]){
        rep(i,(bel[r]-1)*cnt+1,r)ans=max(ans,dp[i]);
    }
    rep(i,bel[l]+1,bel[r]-1)ans=max(ans,pre[i]);
    return ans;
}
int main(){
    int L,R;
    cin>>n>>L>>R;
    cnt=(int)pow(n,0.333);
    for(int i=0;i<=n;i++){
        read(a[i]);
    }
    for(int i=1;i<=n+n;i++)bel[i]=(i-1)/cnt+1;
    int ans=-2e9;
    memset(dp,128,sizeof(dp));
    memset(pre,128,sizeof(pre));
    dp[0]=0;
    update(0,0);
    for(int i=L;i<=n+n;i++){
        int l=max(0,i-R),r=max(0,i-L);
        int mx=query(l,r);
        //cout<<l<<' '<<r<<' '<<mx<<' '<<endl;
        dp[i]=mx+a[i];
        update(i,dp[i]);
        ans=max(ans,dp[i]);
    }//puts("");
    //for(int i=1;i<=n+n;i++)cout<<pre[i]<<' ';cout<<endl;
    cout<<ans;
    return 0;
} 
//BY CYN 
```

耗时$1000+ms$



------------

## 方法$3$：

同样的一个区间，可以用线段树或堆或$Splay$来维护，复杂度$O(N logN)$


------------

## 方法$4$：
据说可以树状数组区间查询最大值？

复杂度$O(Nlog^2N)$

---


# 选择数字

## 题目描述

给定一行 $n$ 个非负整数 $a_1 \cdots a_n$。现在你可以选择其中若干个数，但不能有超过 $k$ 个连续的数字被选择。你的任务是使得选出的数字的和最大。

## 说明/提示

对于 $20\%$ 的数据，$n \le 10$。

对于另外 $20\%$ 的数据，$k=1$。

对于 $60\%$ 的数据，$n \le 1000$。

对于 $100\%$ 的数据，$1 \le n \le 100000$，$1 \le k \le n$，$0 \le $ 数字大小 $ \le 1,000,000,000$。

时间限制 $500$ ms。

## 样例 #1

### 输入

```
5 2
1
2
3
4
5 
```

### 输出

```
12```

# 题解

## 作者：YoungLove (赞：94)

[Youngsc](http://youngscc.github.io/)

既然是选择一些数让其和最大，也就是等价于我删除一些数且这些数的和最小。并且任意两个被删的数之间的距离一定小于k，即任意连续的k个数之中至少有一个数被删。

~~正难则反~~，我们定义$f[i]$ 为前i个数中被删除的数的最小和，那么$f[i]$就可以由从$i-k+1$到$i-1$中的任意一个$f[j]$转移过来，当然根据题意我们要将一个最小的$f[j]$转移给它，且$i-k+1<=j<i$。很显然我们可以用**单调队列**去维护这个东西。做到$O(n)$的复杂度去DP。

转移方程即为$f[i] = min(f[j])+num$用单调队列去维护。

最后的答案我们可以从$f[n-k]$到$f[n]$去找找最小值然后用所有值和减去就可以了。


## 代码在这里

```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>
# include <cmath>
# include <ctime>
# define R register
# define LL long long

using namespace std;

LL tot,d,n,k;
LL p[100010],head = 1,tail = 1;
LL q[100010],f[100010],ans;

inline void in(R LL &a){
    R char c = getchar();R LL x=0,f=1;
    while(!isdigit(c)){if(c == '-') f=-1; c  =getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x*f;
}

inline void maxx(R LL &a,const LL b){a>b? 0:a=b;}

inline LL yg(){
    // freopen("bronlily.in","r",stdin);
    // freopen("bronlily.out","w",stdout);
    in(n),in(k);
    for(R int i=1; i<=n; ++i)
    {
        in(d);
        tot += d;
        f[i] = q[head]+1LL*d;
        while(head<=tail&&q[tail]>=f[i]) tail--;
        q[++tail] = f[i],p[tail] = i;
        while(head<=tail&&p[head]<i-k) head++;
    }
    for(R int i=n-k; i<=n; ++i) maxx(ans,1LL*tot-1LL*f[i]);
    printf("%lld",ans);
    return 0;
}

LL youngsc = yg();
int main(){;}
```
（减少代码复制，共创美好洛谷）


---

## 作者：Star_Wind (赞：62)

萌新刚学单调队列优化 DP ，发一篇题解纪念一下qwq

~~自认为详细的讲解~~

------------

看到题目，是一个纯的选数问题，所以考虑用 DP 解。学过 DP 的都知道 DP 有三要素，所以我们先把这三个填完。

1. 阶段，这个其实一般来说就是循环的东西，比较好填，看题目可知是每个数的位置（编号）
2. 决策，对于每个数，我们当然有两种决策，即取和不取。

接下来是比较难的（虽然这题简单）状态（状态转移方程）了，这个需要根据决策来填，可以容易的写下下面的方程：

设$f_{i,0}$表示不取第$i$个数得到的最大结果，则有方程$f_{i,0}=\max(f_{i-1,0},f_{i-1,1})$

设$f_{i,1}$表示不取第$i$个数得到的最大结果，则有方程$f_{i,1}=\max(f_{x,0}-s_x)+s_i$（前提是$i-k\leq x < i$）

然而时间复杂度是$O(n^2)$，会 T ，所以我们要进行优化。

发现$f_{x,0}-s_x$随着的$x$的变化而变化，和$i$无关。并且因为他们是递增的，所以我们用$f_{x,0}-s_x$构造单调队列，把时间复杂度降到$O(n)$。

接下来就简单了，而且这一题也不用像模板写两头维护，只需要写一边就行，所以在循环内写上方程，敲一个单调队列外加上面的限制条件就行了。

AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,l,r,x,s[100010],f[100010][10],q[100010];//这里要注意开longlong
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) scanf("%lld",&x),s[i]=s[i-1]+x;//求前缀和
	l=r=1;
	for(int i=1;i<=n;i++)
	{
		f[i][0]=max(f[i-1][0],f[i-1][1]);//方程
		while(q[l]<i-m&&l<=r) l++;//维护队首
		f[i][1]=f[q[l]][0]-s[q[l]]+s[i];//方程
		while(f[i][0]-s[i]>f[q[r]][0]-s[q[r]]) r--;//维护队尾
		r++;q[r]=i; 
	}
	cout<<max(f[n][0],f[n][1]); //最后不要忘了再比较
	return 0; 
 } 
```

码字不易，给个赞呗qwq~~

---

## 作者：生而为人 (赞：20)

## 一种特殊的解法
其实 这题可以不用单调队列，洛谷神机跑的快的离谱。。 我是O(n*n) 过的 不过常数小 代码也短。
详细细节 见代码
```c
#include<iostream>
#include<cstdio>
#include<queue>
#define int long long
using namespace std;
const int N=100005;
int sum[N];
int f[N];// 表示第I个不选的最优解
int a[N];
int n,k;
deque<int>va;
signed main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	cin>>a[i],sum[i]=sum[i-1]+a[i];
	for(int i=1;i<=n+1;i++)
	for(int j=max(1ll*0,i-k-1);j<i;j++)
	f[i]=max(f[i],f[j]+sum[i-1]-sum[j]);
	cout<<f[n+1];
}
```


---

## 作者：PurpleWonder (赞：19)

蒟蒻并没有想到dp做法……于是用最短路做的这道题，跑的dp慢许多。

因为本题需要在每隔最多k个数字就要放弃一个，所以对于每一个数字i，向它后面的i+1~i+k+1连边，之后设一个超级起点s连向1~k，再将n-k+1~n的节点连向一个超级终点t，之后以s为起点跑最短路，所有阶段权值的总和sum减去s到t的距离就是最后的答案。

由于需要连得边数是O(nk)级别的，并且是一个点向一个区间的点连一条边，因此可以用线段树优化建图，讲连的边数变成O(nlogk)，总的时间复杂度是O(nlognlogn)，正好可以卡过1e5的数据

代码：
```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#define mk(x,y) (node){x,y}
using namespace std;

long long sum,ju[400010];
int n,k;
int a[100010],wz[100010];
int nxt[2000010],to[2000010],head[2000100],quan[2000100],gs;
int d[400010],l[400010],r[400010];
vector<int> v;

struct node{int v;long long jv;bool operator <(const node d)const{return jv>d.jv;}};

priority_queue<node> q;

inline void lb(int x,int y,int z){
	nxt[++gs]=head[x];
	head[x]=gs;
	to[gs]=y;
	quan[gs]=z;
}

void build(int x,int li,int ri){
	l[x]=li;r[x]=ri;
	if(li==ri){
		wz[li]=x;
		return;
	}
	int mid=(li+ri)>>1;
	build(x<<1,li,mid);
	build(x<<1|1,mid+1,ri);
	lb(x,x<<1,li==mid?a[li]:0);
	lb(x,x<<1|1,mid+1==ri?a[ri]:0);
}

void query(int x,int li,int ri){
	if(l[x]>ri || r[x]<li)return;
	if(l[x]>=li && r[x]<=ri){v.push_back(x);return;}
	query(x<<1,li,ri);query(x<<1|1,li,ri);
}

void dij(){
	memset(ju,0x3f,sizeof(ju));
	ju[0]=0;
	q.push(mk(0,0));
	while(!q.empty()){
		node dq=q.top();q.pop();
		int x=dq.v;
		if(ju[x]!=dq.jv)continue;
		for(int i=head[x];i;i=nxt[i]){
			if(ju[to[i]]>ju[x]+quan[i]){
				ju[to[i]]=ju[x]+quan[i];
				q.push(mk(to[i],ju[to[i]]));
			}
		}
	}
}

int main(){
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),sum+=a[i];
	build(1,1,n+1);
	for(int i=0;i<=n;i++){
		query(1,i+1,min(i+k+1,n+1));
		for(vector<int>::iterator id=v.begin();id!=v.end();id++){
			lb(wz[i],*id,l[*id]==r[*id]?a[l[*id]]:0);
		}
		v.clear();
	}
	dij();
	printf("%lld",sum-ju[wz[n+1]]);
}
```

---

## 作者：Priori_Incantatem (赞：12)

#### 题目大意
给出一个长度为 $n$ 的序列，你可以取若干个数，但要求最多只能连续取 $k$ 个数，求最大能取出的数的总和

#### 解题思路

考虑 $f[i][0]$ 表示前 $i$ 个数，第 $i$ 个数不取时的最优答案
$f[i][1]$ 就为第 $i$ 个数取时的最优答案

上面这个状态，可以很轻松的想到 $O(n^2)$ 的转移：  
$f[i][0]=max(f[i-1][0],f[i-1][1])$，此部分 $O(1)$ 就可以处理完
$f[i][1]=max \{ f[j][0]+\sum_{k=j+1}^{i} a[i] \}$，$(i-k \le j \le i-1)$ 也就是：  
$f[i][1]=max \{ f[j][0]+s[i]-s[j] \}$  
$f[i][1]=max \{ f[j][0]-s[j] \} +s[i]$ （将$s[i]$提出来）

我们上面将 $s[i]$ 提出后，就变成了求 $f[j][0]-s[j]$ 的最大值，最后加上 $s[i]$。用单调队列维护最大值即可

```cpp
#include<cstdio>
#include<iostream>
#include<deque>
using namespace std;
const long long Maxn=100000+20,inf=0x3f3f3f3f;
long long a[Maxn],s[Maxn],f[Maxn][2];
deque <long long> q;
long long n,k;
inline long long read()
{
	long long s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void pop(long long x)
{
	while(1)
	{
		if(q.empty())break;
		if(q.front()>=x-k)break;
		q.pop_front();
	}
}
void push(long long x)
{
	while(1)
	{
		if(q.empty())break;
		long long i=q.back();
		if(f[i][0]-s[i]>=f[x][0]-s[x] && i!=x)break;
		q.pop_back();
	}
	q.push_back(x);
}
int main()
{
//	freopen("in.txt","r",stdin);
	n=read(),k=read();
	for(long long i=1;i<=n;++i)
	a[i]=read(),s[i]=s[i-1]+a[i];
	
	for(long long i=1;i<=n;++i)
	{
		pop(i);
		push(i-1);
		long long j=q.front();
		f[i][1]=s[i]+f[j][0]-s[j];
		f[i][0]=max(f[i-1][1],f[i-1][0]);
	}
	printf("%lld\n",max(f[n][0],f[n][1]));
	
	return 0;
}
```

---

## 作者：Creeper_LKF (赞：7)

跑的最快的程序(43ms)+我也不知道是什么的优化+读入优化

原理：可以很容易的发现，原来的dp方程就是一直加（其实没有方程），然后限制了k个之后一个点a[I]可能会向前连续加j（j<=k）个然后停止，然后累加上前面获取的最大值，并且j的选取对前面dp[x<j]的答案无影响。

所以dp方程应该是dp[I]=max(dp[I-j]+a[j+1]+...+a[I])，其中J<=k，转化为前缀和就是dp[I]=max(dp[I-j]+sum[I]-sum[I-j+1])，为了方便计算，将j定义为第j个数，所以得到dp[I]=max(dp[j-1]+sum[I]-sum[j])，分析方程，发现sum[i]固定，即dp[i]=sum[i]+max(dp[j-1]-sum[j])。

那么我们需要每次都枚举j吗?那样会超时，所以肯定不需要。还记得我们上面说的吗？后面的j的取值对j之前的dp值无影响，而sum[j]固定，所以我们维护一个dp[j-1]+sum[j]的最大值位置pos，可以记录我们遇到的最大值和其位置，然后每次新计算出一个数时直接把新数的dp[I-1]-sum[I]拿给最大值比较、更新，然后当记录的位置“过期“（即pos<I-k时），重新计算pos。这样就可以省去大部分计算。当然还可以维护其它的数据结构来加速选择pos。

代码如下：

```cpp
#include<bits/stdc++.h>
#define INF 4611686018427387904L
using namespace std;
typedef long long LL;
LL n,k,sum[100001],dp[100001];
inline char get_char(){//超级读入优化
    static char buf[2000001],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,2000001,stdin),p1==p2)?EOF:*p1++;
}
inline LL read(){
    LL num=0;
    char c;
    while(isspace(c=get_char()));
    while(isdigit(c)) num=num*10+c-48,c=get_char();//不压代码换速度
    return num;
}
int main(){
    n=read(),k=read();
    LL maxn=-INF,pos,ns;
    for(int i=1;i<=n;++i) sum[i]=sum[i-1]+read();
    for(int i=1;i<=k;++i){//前k个是可以直接选的（n==k时有效）
        dp[i]=sum[i];
        if((ns=dp[i-1]-sum[i])>=maxn) maxn=ns,pos=i;
    }
    for(int i=k+1;i<=n;++i){
        if(pos<i-k){//当过期时
            maxn=-INF;//注意所有数组都要是long long的
            for(int j=pos+1;j<=i;++j){//汇编代码友好
                if((ns=dp[j-1]-sum[j])>=maxn){
                    maxn=ns,pos=j;
                }
            }
        } else {
            if((ns=dp[i-1]-sum[i])>=maxn) maxn=ns,pos=i;//寄存器友好（不开O2）
        }
        dp[i]=dp[pos-1]+sum[i]-sum[pos];
    }
    printf("%lld",dp[n]);
    return 0;
}
```

---

## 作者：火柴神 (赞：7)

动归
设f[i]为取前i件物品的最大价值，因为不能连续取k件，所以f[i]的状态可由j∈[i-k+1,i]转移来。






```cpp
#include<cstdio>
#define M 100500
#define ll long long
using namespace std;
ll sum[M],f[M],d[M],q[M];
int n,k,head=0,tail=1;
void put(int j){
    d[j]=f[j-1]-sum[j];
    if(j>=k+1&&d[j-k-1]==q[head])
        head++;
    while(head<tail&&d[j]>q[tail-1])
        tail--;
    q[tail++]=d[j];
}
int main(){
    scanf("%d%d",&n,&k);
    sum[0]=0;
    f[0]=0;
    d[0]=0;
    q[0]=0;
    for(int i=1;i<=n;i++){
        ll x;
        scanf("%lld",&x);
        sum[i]=sum[i-1]+x;
    }
    for(int i=1;i<=n;i++){
        put(i);
        f[i]=q[head]+sum[i];
    }
    printf("%lld",f[n]);
    return 0;
}
```

---

## 作者：smilke (赞：6)

单调队列模板的题，还是比较好的。

首先观察题意，我们可以想出如下的DP方程：

状态表示：设$f[i]$表示前$i$个点中第$i$个点不取的最优值。

状态转移：$f[i]=max${$f[j]+sum(j+1,i-1)$} $(j\in[i-k-1,i-1])$

最终状态：$f[n+1]$.

这样做时间复杂度$O(nk)$，还需要优化。

我们化简一下式子，假设从$f[a]$转移到$f[c]$优于从$f[b]$转移到$f[c]$.其中$a<b<c$.

则$f[a]+sum[c-1]-sum[a]>=f[b]+sum[c-1]-sum[b]..........(1)$

两边消去$sum[c-1]$,可得$f[a]-sum[a]>=f[b]-sum[b]..........(2)$

发现什么？如果决策$a$优于决策$b$，则对应的$f[a]-sum[a]>=f[b]-sum[b]$

既然发现了这种性质，那么我们就可以用单调队列维护决策区间中{$f[j]-sum[j]$}的最大值，直接转移，于是省去了枚举决策的一维时间。

每个点最多进出队一次，故时间复杂度为$O(n)$.

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int N=1e6+50;
int n,k,a[N],sum[N],f[N],id[N],q[N],l=1,r=0;
signed main(){
	scanf("%lld%lld",&n,&k);
	rep(i,1,n) scanf("%lld",&a[i]),sum[i]=sum[i-1]+a[i];
	q[++r]=0;f[0]=0;
	rep(i,1,n+1){
		while(l<=r&&q[l]<i-k-1) l++;
		f[i]=max(f[i],f[q[l]]+sum[i-1]-sum[q[l]]);
		while(l<=r&&f[q[r]]-sum[q[r]]<=f[i]-sum[i]) r--;
		q[++r]=i;
	}
	printf("%lld\n",f[n+1]);
	return 0;
}
```



---

## 作者：Refined_heart (赞：6)

这题和[P2627修剪草坪](https://www.luogu.org/problemnew/show/P2627)几乎一样吧，一样直接$dp$，设计状态：

这两个题的状态转移方程都一样啊……设$dp[i][0/1]$表示到第$i$个数且不选$/$选第$i$个数的最优答案（即最大值），则有：

$1.dp[i][0]=max(dp[i-1][0],dp[i-1][1])$

$2.dp[i][1]=max(dp[j][0]-sum[j]+sum[i])$,$i-k<=j<i$

就是枚举$j$，取最佳答案$dp$。

然而这样显然会超时，即使我们用了前缀和优化。枚举$j$复杂度太大，我们如何优化？

观察上式发现，$1.$式已经无法优化，必然在$2.$式着手。

观察发现，可以把里面的$sum[i]$提出来，原方程变为：

$dp[i][1]=max(dp[j][0]-sum[j])+sum[i],i-k<=j<i$

继续思考，什么条件下，方程最优？

显然是$MAX$中最大的时候。

维护它我们就想到了——**单调队列!**

我们完全可以维护使得$dp[j][0]-sum[j]$单调递减，保证不会枚举多余的$j$.

由此我们可以大大优化时间复杂度。

本题得解。但是注意，别忘了$long long$.

$Code:$
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
long long a[2000000],n,k,head,tail;
long long s[2000000],q[2000000];
long long dp[2000000][2];
inline long long max(long long a,long long b){return a>b?a:b;}
inline long long read(){
	long long s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){
		s=(s<<1)+(s<<3)+(ch^48);
		ch=getchar();
	}return s;
}
int main(){
	n=read(),k=read();
	for(int i=1;i<=n;++i){
		a[i]=read();
		s[i]=s[i-1]+a[i];
	}
	tail=head=1;
	for(int i=1;i<=n;++i){
		dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
		while(head<=tail&&i-k>q[head])head++;
		dp[i][1]=dp[q[head]][0]-s[q[head]]+s[i];
		while(s[i]-dp[i][0]<s[q[tail]]-dp[q[tail]][0]&&head<=tail)tail--;
		q[++tail]=i;
	}printf("%lld\n",max(dp[n][1],dp[n][0]));
	return 0;
}
```


---

## 作者：Rubyonly (赞：5)

# P2034 【选择数字】

## 数组含义

$a[i]$: 原数组。

$sum[i]$: 前缀和，便于计算。

$dp[i][1/0]$: 前 $i$ 个数字的状态下，第 $i$ 个数字选/不选的和的最大值。

$q[i]$: 在单调数列中第 $i$ 个数字，在原数组的下标。

## 基本思路

当第 $i$ 个数字不选的时候，比较简单，取前 $i-1$ 的状态选或不选的最大值即可。

$dp[i][0]=max(dp[i-1][0],dp[i-1][1])$

当第 $i$ 个数字选的时候，可以枚举前 $j$ 个数字的状态，依次取最大值即可。

$dp[i][1]=max(dp[j][0])-sum[j]+sum[i]$（伪代码，误抄）

但是本题数据很大，暴力枚举 $j$ ，效率堪忧。

因为题中可以对 $a[i]$ 选或不选，在有限制的条件下，$a[i]$ 肯定越大越好，所以可以用到单调队列进行优化。

（在此提一句，刚开始我想到用贪心，从头枚举，每个区间都正好卡 $k$ 的长度，但是很明显可以举出反例）

```un
7 3
1 4 1 10000 1 4 1
```

用到单调队列，就可以把式子改了。

$dp[i][1]=dp[q[head]][0]-sum[q[head]]+sum[i]$

最后记得开 $long long$ 哟。

##代码

```
#include <bits/stdc++.h>
#define ll long long 
using namespace std;

const int maxn=1e6+50;
int n,k;
ll a[maxn];
ll sum[maxn];
ll dp[maxn][2];
ll q[maxn];

int main(){
    int head=1;
    int tail=1;//这个我测试了一下，必须是1，若为0，则需要进行初始化
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        sum[i]=sum[i-1]+a[i];
    }
    dp[1][1]=a[1];//tail=0时必加的初始化
    for(int i=1;i<=n;i++){
        dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
        while(q[head]<i-k&&head<=tail){//去掉最先走出队列，而且值也不大的数字
            head++;
        }
        dp[i][1]=dp[q[head]][0]-sum[q[head]]+sum[i];
        while(sum[i]-dp[i][0]<sum[q[tail]]-dp[q[tail]][0]&&head<=tail){//若尾端加入的数字，去掉的数字总值比i时还大，则直接去掉
            tail--;
        }
        q[++tail]=i;
    }
    printf("%lld\n",max(dp[n][1],dp[n][0]));
    return 0;
}
```

---

## 作者：YLWang (赞：4)

好像各位大佬用的都是单调队列优化？

这里提供一种线段树优化$DP$。

首先我们考虑暴力。

定义$dp[i]$为前$i$个数不取第$i$个的最大值。

显然最后的答案是$dp[n+1]$。

转移方程：$dp[i] = max \{sum(i-1, j) + dp[j-1]\}$，其中$sum(l, r)$表示$a$数组中$[l, r]$的和。

暴力：
```
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, k, j) for(register int i = (k); i <= (j); i++)
#define INF (1 << 30) - 1
#define ll long long
#define reaD() read()
using namespace std;
inline int read()
{
    int num=0,flag=1;char c=' ';
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag = -1;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num*flag;
}
#define MAXN 100005
int a[MAXN], dp[MAXN];
int sum[MAXN];
signed main()
{
    int n = read(), k = read();
    For(i, 1, n)
        a[i] = read();
    n++, a[n] = 0;
    For(i, 1, n)
        sum[i] = sum[i-1] + a[i];
    For(i, 1, n)
        For(j, max(i-k, 1), i)
            dp[i] = max(dp[i], dp[j-1] + sum[i-1] - sum[j-1]);
    cout << dp[n] << endl;
    return 0;
}

```

显然复杂度为$O(nk)$。

转移时因为$sum[i-1]$是不变的，所以只需要用线段树维护$dp[i]-sum[i]$的最大值即可。

复杂度O(能过)

```
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, k, j) for(register int i = (k); i <= (j); i++)
#define INF (1 << 30) - 1
#define ll long long
#define int long long
#define reaD() read()
using namespace std;
inline int read()
{
    int num=0,flag=1;char c=' ';
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag = -1;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num*flag;
}
#define MAXN 100005
int a[MAXN], dp[MAXN];
int sum[MAXN];
int c[MAXN << 2];
#define ls (k << 1) 
#define rs (k << 1 | 1)
inline void update(int k, int l, int r, int pos, int val) {
	if(l == pos && r == pos) {
		c[k] = val; return;
	}
	int mid = (l + r) >> 1;
	if(pos <= mid) update(ls, l, mid, pos, val);
	else update(rs, mid+1, r, pos, val);
	c[k] = max(c[ls], c[rs]);
}
inline int query(int k, int l, int r, int ql, int qr) {
	if(l == ql && r == qr) return c[k];
	int mid = (l + r) >> 1;
	if(qr <= mid) return query(ls, l, mid, ql, qr);
	else if(ql > mid) return query(rs, mid+1, r, ql, qr);
	else return max(query(ls, l, mid, ql, mid), query(rs, mid+1, r, mid+1, qr));
	
}
signed main()
{
	int n = read(), k = read();
	For(i, 1, n) a[i] = read();
	n++, a[n] = 0;
	For(i, 1, n)
		sum[i] = sum[i-1] + a[i];
	dp[1] = 0;
	update(1, 0, n, 1, dp[1] - sum[1]);
	For(i, 2, n) {
		int L = max(i-k, 1ll), R = i;
		dp[i] = sum[i-1] + query(1, 0, n, L-1, R-1);
		update(1, 0, n, i, dp[i] - sum[i]);
	}
	cout << dp[n] << endl;
    return 0;
}

```


---

## 作者：Kendrick_Z (赞：2)

题目非常简洁明了

考虑DP

思考一波可以大概推出来DP方程（最朴素版本）

### f[i]=max(f[i],f[j-1]+Σa[j])(j∈[i-k,i])


还算是比较好理解？

就类似于区间DP的断点 因为不能超过k个

那么一定在i-k到i中存在的一个断点j f[i]由f[i-1]转移而来

暴力就是枚举断点

考虑如何优化？

首先看到求和我们很容易想到用前缀和优化

那么我们的DP方程：

### f[i]=max(f[i],f[j-1]+sum[i]-sum[j])

j为断点所以不会选择j

简单合并一下就可以得到

### g[j]=f[j-1]-sum[j]

这是一个只和j有关的式子 那么我们就可以用单调队列维护一个这个的最大值

然后取队首转移

code:

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			f=-1;
		}
		ch=getchar(); 		 	
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int n,a[N],k,f[N],q[N],sum[N],ans,g[N];
signed  main(){
	n=read();
	k=read();
	for(int i=1;i<=n;i++){
		a[i]=read(); 
		sum[i]=sum[i-1]+a[i];
	}	
	int l=0,r=1;	
	for(int i=1;i<=n;i++){
	    g[i]=f[i-1]-sum[i];	
		while(l<=r&&g[q[r]]<g[i]) r--;
     //如果比你小 还比你厉害 那么你永远打不过他 
		q[++r]=i;
	 	while(l<=r&&q[l]<i-k) l++;//排除不在合法转移范围的 
	  	f[i]=g[q[l]]+sum[i];
	}
	for(int i=1;i<=n;i++){
		ans=max(f[i],ans);
	}
	printf("%lld",ans);
	return 0;
}
```


有个很玄学的就是 ？

l和r的初始值..

一般设的都是1,0

但好像会挂？？？

改了改才过 

求评论区大佬解释一波~

---

## 作者：B_1168 (赞：2)

实测本题暴力能过！

在吸取了浓郁的~~臭氧~~后，本暴力程序得以花费942ms的时间通过数据最大的#8测试点！

评测数据如下：

![](https://i.ibb.co/tpF2knk/P2034.png)

以下放本人极丑陋代码：

```cpp
#pragma GCC optimize(3)

//......省略约40行的优化指令

#include<bits/stdc++.h>
using namespace std;

const int maxn=200001;

long long tot,dp[maxn][2],s[maxn];

//dp[i][0]代表第i个数字不被选择的最大值，dp[i][1]代表第i个数字被选择的最大值

int n,k,temp;

inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}

inline int read(){
    char ch=nc();
    int sum=0; 
    while(!(ch>='0'&&ch <='9'))ch=nc(); 
    while(ch>='0'&&ch<='9') sum=sum*10+ch-48,ch=nc(); 
    return sum; 
} 

//快读
                        
int main(){
   n=read(),k=read();
   for(int i=1;i<=n;i++){
      temp=read();
      s[i]=s[i-1]+temp;//处理前缀和
   }
   for(int i=1;i<=n;i++){
      dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
      for(int j=max(i-k,0);j<i;j++) dp[i][1]=max(dp[i][1],dp[j][0]-s[j]+s[i]);
      //翻译：显然，如果选择第i个数字，此状态可以从选择或不选择第i-1位状态求出
      //如果第i个数字被选中的话，因为不可以有连续k个以上的数字被选择，因此需要从[i-k,i)的范围内选出一个j，使得截至第j个数字，其中第j个数字不选，随后选择[j,i]之间每一个数的和最大，更新到dp[i][1]上
   }
   printf("%lld\n",max(dp[n][0],dp[n][1]));//输出结果
}

```

感谢管理员的审核！祝各位rp++！

---

## 作者：TheShadow (赞：1)

# 闲扯

单调队列优化 $DP$ 的第一题，结果死在了一些很奇怪的操作上。。。

# 题面

[题面](https://www.luogu.org/problem/P2034)

# Solution

定义 $dp_i$ 表示考虑了前 $i$ 个数，能够选取的最大价值。

因为最多只能连续选 $k$ 个，所以我们可以在 $[i-k,i-1]$ 中选取一个断点 $j$ ，表示这个点不选，那么此时 $dp_i=\min(dp_{j-1}-sum_j)+sum[i]$ 。

这时我们找到的 $dp_i$ 时端点 $i$ 必选的情况，不能代表所有的情况，所以对 $dp_i,dp_{i-1}$ 取一个 $\max$ ，这样就可以包含考虑前 $i$ 个的所有情况了。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(res*bas)%mod;
		bas=(bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e5+5;
int n,k,val,q[MAXN],l=1,r;
ll sum[MAXN],dp[MAXN],ans;
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(k);
	for(ri i=1;i<=n;++i) read(val),sum[i]=sum[i-1]+val;
	dp[1]=sum[1],q[++r]=1;
	for(ri i=2;i<=k;++i){
		dp[i]=sum[i];
		while(l<=r&&dp[q[r]-1]-sum[q[r]]<=dp[i-1]-sum[i]) --r;
		q[++r]=i;
	}
	for(ri i=k+1;i<=n;++i){
		while(l<=r&&q[l]<i-k) ++l;
		dp[i]=sum[i]+dp[q[l]-1]-sum[q[l]];
		while(l<=r&&dp[q[r]-1]-sum[q[r]]<=dp[i-1]-sum[i]) --r;
		q[++r]=i;
		dp[i]=max(dp[i],dp[i-1]);
	}
	print(dp[n]);
	return 0;
}
```

# 总结

蒟蒻的第一道用单调队列优化 $DP$ 的题，但绝不是最后一道。

这道题还是请教的机房里的 $Dalao$ $@jklover$ ，但考场上呢？

所以还是要加油强化自己的能力啊！！！

---

## 作者：SkyLiYu (赞：1)

本来我是向来懒得写题解的

但恕我直言

下面的题解实在无法忍受

误导新人

---------------------------------------

进入正题

按照下面几篇题解的想法

把求 **取数最大和** 转化为 求 **删数最小和**


那么 $f_i$ 表示的实际是 删除 $a_i$ 时 前 $i$ 个数的 删数最小和

---------------------------------------------

下面的题解都写成 $f_i$ 表示是前 $i$ 个数的删数最小和

但是代码实际写出来的$f_i$却...可能是借鉴了别人代码吧呵呵

----------------------------------------------

我们对 $f_i$ 的状态更新时 

根据题意有 $[i - k , i]$ 中 必然有一个 $a_j$ 要被删去

而且根据我们定义的状态 $f_i$ 表示 删除 $a_i$ 时 前 $i$ 个数的 删数最小和

那么显然我们可以从$[i - k - 1 , i - 1]$ 的 $f_j$ 中 进行状态转移

那么方程就是 ： $f_i=\min\limits_{i-k-1\le j\le i-1}\{dp_{j}+a_i\}$

-----------------------------------------------

注意状态转移的范围是 $[i - k - 1 , i - 1]$

具体原因不赘述，自己构造个小数据或者直接拿样例手玩就明白了

下面的题解写的都是什么 $[i - k + 1 , i - 1]$ 和 $[i - k , i - 1]$ 

反正我是不知道他们怎么用错误的思想写出正确代码的...

------------------------------------------------

那么这样我们就有了一个 $O(nk)$ 的做法

```
#include <iostream>

using namespace std;

const int inf = 1e9;
int f[10010];

int main()
{
    int n , k , x , ret , sum = 0;
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
    {
        cin >> x;
        f[i] += x , sum += x;
        ret = inf;
        for(int j = max(0 , i - k - 1); j <= i - 1; j++)
            ret = min(ret , f[j]);
        f[i] += ret;
    }
    ret = inf;
    for(int i = n - k; i <= n; i++)
    {
        ret = min(ret , f[i]);
    }
    cout << sum - ret << endl;
    return 0;
}
```
个人认为自己代码的可读性还是很高的


---------------------------------------

$O(nk)$ 肯定是过不了所有数据的 考虑优化

我们需要最小值来进行状态转移

--------------------------
大佬：单调队列优化dp随手切题

我：单调队列食用体验极差 整个小根堆用$log$复杂度就好极了

------------------------------------------

相比 **单调队列** 用 **小根堆优化**  显然更适合新人食用

```
struct Nodes
{
    long long x; int id;
    bool operator < (const Nodes &a) const
    {
        return x > a.x;
    }
};
priority_queue < Nodes > que;
```

结构体和优先队列如上实现

$x$用于记录每个$f_i$ ， $id$用于记录对应的 $i$

当 堆顶元素的 $id < i - k - 1$ 就 弹出 即可 

---

## 作者：Sym_Je (赞：1)

         P2034 选择数字   
   [ P2034 选择数字](https://www.luogu.org/problemnew/show/P2034)   
   这道题然我们输出连续不到k个的最大的值，于是我们发现，其实就是在k个数中，我们至少删掉一个数。   
   因此我们发现我们设一个f[i],表示前i个数，满足上面规则的删掉最小的总和，我们发现这可以由i-1..i-2..i-3..i-k 。    
   转移过来但每次枚举复杂度完全过不了，然后再看，我们不就是要找他前k个中最小的嘛，所以我们直接用单调队列一维护，p存放入的时间，q存其大小，最后找n-k到n中最小的f[i],然后用总和减去就ok咯。    
   ```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

inline long long read()
{
	long long date=0,f=1;
	char c=getchar();
	while('0'>c||c>'9')
	{
		if(c=='-')
		f=-1;
		c=getchar();
	}
	while('0'<=c&&c<='9')
	{
		date=date*10+c-'0';
		c=getchar();
	}
	return date*f;
}

long long n,k;

long long p[500001],q[500001];//qdaxiao pweizhi
long long tot;
long long f[500001];

long long head,tail;

int main()
{
	n=read();
	k=read();
	for(long long i=1;i<=n;i++)
	{
		long long d=read();
		tot+=d;
		f[i]=q[head]+d;
		while(head<=tail&&q[tail]>=f[i])
		{
			tail--;
		}
		q[++tail]=f[i];
		p[tail]=i;
		while(head<=tail&&i-k>p[head])
		{
			head++;
		}
	}
	long long ans=0;
	for(long long i=n-k;i<=n;i++)
	{
		ans=max(ans,tot-f[i]);
	}
	printf("%lld",ans);
	return 0;
}
```

---


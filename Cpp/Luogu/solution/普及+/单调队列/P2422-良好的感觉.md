# 良好的感觉

## 题目描述

kkk 做了一个人体感觉分析器。每一天，人都有一个感受值 $A_i$，$A_i$ 越大，表示人感觉越舒适。在一段时间 $\left[i, j\right]$ 内，人的舒适程度定义为 $\left[i, j\right]$ 中最不舒服的那一天的感受值 $\times$ $\left[i, j\right]$中每一天感受值的和。现在给出 kkk 在连续 $N$ 天中的感受值，请问，在哪一段时间，kkk 感觉最舒适？


## 说明/提示

kkk 最开心的一段时间是第 $3$ 天到第 $5$ 天，开心值：$(6+4+5)\times4=60$。

对于 $30\%$ 的数据，$1\le N\le 100$。

对于 $70\%$ 的数据，$1\le N\le 2000$。

对于 $100\%$ 的数据，$1\le N\le 100000$，$1\le \texttt{感受值}\le 1000000$。

## 样例 #1

### 输入

```
6
3 1 6 4 5 2```

### 输出

```
60```

# 题解

## 作者：xMinh (赞：82)

## [luogu2422 良好的感觉](https://www.luogu.org/problemnew/show/P2422)

####其实我是来推自己的新[博客](https://xminh.github.io/)的

这题说实话想了我差不多一个小时。第一次没看题解用单调队列来优化DP。

这个题的单调队列很明显是一个没有时间限制的，所以只需要考虑队中元素是什么的问题。我们可以注意到，这个题的数据范围规定没有负数，所以前缀和绝对是会越来越大的，所以队中元素应该是那个最不舒服的值。

然后转念想一想，如果这题是一个数据小的普通DP怎么做？那就是找到每个点左边那个比它小的，以及右边那个比它小的。这左右边界之间的，就是这个点最多能管到的范围。对于单调队列来说，我们可以维护一个单调递增的队列，然后往外踢的时候，被踢掉的点就找到了“右边那个比它小的”，维护完队列之后，队列中位于当前元素前一个的那个元素就是“左边那个比它小的”。这样就可以计算某个点能管到的范围了，最后再乘以这个点本身的值，比较出最大值就好了。

当然还有一个问题，如果某个点一直没有被踢掉怎么办？好办，在序列的最后加一个值为0的元素，就可以在最后一次循环踢掉所有队中元素，完成最后的处理。

PS：其实这题的数据结构严格来说叫做单调栈。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define rint register int
using namespace std;
long long n,a[100001],q[100001],sum[100001],f[100001],ans,tail;
int main()
{
    scanf("%lld",&n);
    for (rint i=1;i<=n;i++) scanf("%lld",&a[i]);
    n++;a[n]=0;
    for (rint i=1;i<=n;i++) 
    {
        sum[i]=sum[i-1]+a[i];
        while (a[q[tail]]>a[i])
        {
            f[q[tail]]+=(sum[i-1]-sum[q[tail]]);
            tail--;
        }
        f[i]=sum[i]-sum[q[tail]];
        q[++tail]=i;
    }
    for (rint i=1;i<=n-1;i++) ans=max(ans,f[i]*a[i]);
    printf("%lld",ans);
}
```

---

## 作者：peterwuyihong (赞：22)

单调栈对于悬线法正如白话文对文言文，晦涩难懂

考虑使用悬线法

记 $l_i,r_i$ 分别为从 $i$ 扩展，最小的 $l,r$ 并满足 $[l,r]$ 这段区间里的数都大于等于 $a_i$ 

### 流程
1. 初始化 $l_i←i$

2. 考虑到利用已经算出来的信息，顺序遍历，若当前 $a_i \le a_{l_i-1}$，就 $l_i←l_{l_i-1}$

3. 由于要利用已经算出来的信息，算 $r$ 的时候要倒序遍历，同理

4. 然后就简单取 $\max$ 就行了

```cpp
#define maxn 100010
int n;
int s[maxn];
int l[maxn],r[maxn],a[maxn];
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],s[i]=s[i-1]+a[i],l[i]=r[i]=i;
	for(int i=1;i<=n;i++)
	    while(l[i]>1&&a[i]<=a[l[i]-1])l[i]=l[l[i]-1];
	for(int i=n;i;i--)
	    while(r[i]<n&&a[i]<=a[r[i]+1])r[i]=r[r[i]+1];
	long long ans=0;
	for(int i=1;i<=n;i++)ans=max(ans,(long long)a[i]*(s[r[i]]-s[l[i]-1]));
	cout<<ans<<endl;
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}

```


---

## 作者：Treaker (赞：20)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 单调栈 + 前缀和
搞不懂标签为什么是DP 和 单调队列 -.-

我们发现感受值全是正数，也就是说前缀和是单调递增，当最小值不变时，区间越长越优。

那么我们再考虑，如何求一个区间的最小值呢？

换个角度，我们考虑一个值它能作为什么区间的最小值，即它能向两边扩展多少。

那么问题就很显然了，我们维护一个单调递减的栈，正反分别跑一遍，就能求出左右边界，在统计答案即可。。。

#### 完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 100005;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , top;
int a[N] , st[N] , l[N] , r[N];
long long sum[N];
long long ans;
int main()
{
	n = read();
	for(int i = 1;i <= n;i ++)	sum[i] = sum[i-1] + (a[i] = read());
	for(int i = 1;i <= n;i ++)
	{
		while(top && a[st[top]] >= a[i]) top --;
		l[i] = st[top];
		st[++top] = i;
	}
	top = 0;
	st[0] = n+1;
	for(int i = n;i >= 1;i --)
	{
		while(top && a[st[top]] >= a[i]) top --;
		r[i] = st[top] - 1;
		st[++top] = i;
 	}
 	for(int i = 1;i <= n;i ++)	ans = max(ans,(sum[r[i]] - sum[l[i]]) * a[i]);
 	return printf("%lld\n",ans) , 0;
}

```


---

## 作者：DefFrancis (赞：15)

#### 这题数据暴力即可过。

枚举每一个点作为最小值，然后像manachar那样向左向右扩展，遇到比当前点小的点就停止循环，按照法制乘一下，然后维护一下答案即可。

然而这种暴力...

加入读入优化后比正解还快24ms。

加入O3优化后16ms。

手动滑稽。


···
#prag\
```cpp
ma GCC optimize("O3")
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int X=0,w=1; char ch=0;
    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}
int n,a[100005];
long long int ans;
int main(){
    n=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++){
        long long int sum=a[i],l=i-1,r=i+1;
        while(a[l]>=a[i]&&l>=1){
            sum+=a[l];
            l--;
```
}/\*防越界，要注意\*/
        while(a[r]>=a[i]&&r<=n){

            sum+=a[r];

            r++;

}/\*向左向右拓展\*/

```cpp
        ans=max(ans,sum*a[i]); /*维护答案*/
    }
    cout<<ans;
}
···
```

---

## 作者：zzx0102 (赞：8)

另一种不一样的解法，ST 表套二分。

首先，枚举最小值 $a_i$。

那么最优方案一定是两边一直用比 $a_i$ 大的数。

由于数组是静态的，可以使用 ST 表维护区间最小值。

然后在数组上二分，找到最左边的值和最右边的值，前缀和计算答案即可。

时间复杂度虽然不如单调队列，但是过 $10^5$ 还是没有问题的。

时空复杂度均为 $\mathcal{O(n\log n)}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 100010; int dp[N][20], a[N], lg[N], n, sum[N];
void RMQ() {
	for(int i = 1; i <= n; i++) dp[i][0] = a[i];
	for(int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for(int i = 1; i < 20; i++)
		for(int j = 1; j + (1 << i) <= n + 1; j++)
			dp[j][i] = min(dp[j][i - 1], dp[j + (1 << i - 1)][i - 1]);
}
int ask(int l, int r) {int k = lg[r - l + 1]; return min(dp[l][k], dp[r - (1 << k) + 1][k]);}
signed main() {
	cin >> n; for(int i = 1; i <= n; i++) scanf("%d", &a[i]), sum[i] = sum[i - 1] + a[i]; RMQ(); int mx = 0;
	for(int i = 1; i <= n; i++) {
		int l = 1, r = i - 1, L = i;
		while(l <= r) {
			int mid = l + r >> 1;
			if(ask(mid, i) == a[i]) L = mid, r = mid - 1;
			else l = mid + 1;
		}
		l = i + 1, r = n; int R = i;
		while(l <= r) {
			int mid = l + r >> 1;
			if(ask(i, mid) == a[i]) R = mid, l = mid + 1;
			else r = mid - 1;
		}
		mx = max(mx, a[i] * (sum[R] - sum[L - 1]));
	}
	cout << mx;
	return 0;
}
```

---

## 作者：s1243920330 (赞：8)

	虽然可以O(n)过，由于没想到正解，而且看到数据为100000，我就用st表+一个技巧nlogn过。
    
	考虑 l~r 这个区间，经过前缀和O（n)，st表nlogn的预处理后，可以O（1）求出区间的值，并且在st表预处理的过程中可以记录区间最小值的位置pos。

	那么可以得知在 l~r的子区间中凡是经过pos的区间都没有l~r这段区间算出的答案优，于是可以去做l~pos-1，和pos+1~r两段区间
    
    这样每做一个区间是O（1），每做一个区间会少做一个数，于是要做n次区间。复杂度为O（n);加上预处理的nlogn，总复杂度为nlogn。

```
#include<bits/stdc++.h>
using namespace std;
int n,a[100010],st[100010][19],pos[100010][19];
long long s[100010],ans;
int read()
{
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') {
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x;
}
void pre()
{
	for(int j=1;j<=floor(log(1.0*n)/log(2.0));j++)
	for(int i=1;i<=n-(1<<j)+1;i++)
	{
		st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		if(st[i][j-1]>st[i+(1<<(j-1))][j-1]) {
			pos[i][j]=pos[i+(1<<(j-1))][j-1];
		}
		else pos[i][j]=pos[i][j-1];
	}
}
void work(int l,int r)
{
	if(r<l) return;
	int mid=0;
	int t=floor(log(1.0*r-l+1)/log(2.0));
	if(st[l][t]>=st[r-(1<<t)+1][t]) {
		mid=pos[r-(1<<t)+1][t];
		ans=max(ans,(s[r]-s[l-1])*st[r-(1<<t)+1][t]);
	}
	else{
		mid=pos[l][t];
		ans=max(ans,(s[r]-s[l-1])*st[l][t]);
	}
	work(l,mid-1); 
	work(mid+1,r);
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++) {a[i]=read();s[i]=s[i-1]+a[i];st[i][0]=a[i];pos[i][0]=i;}
	pre();
	work(1,n);
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：BqtMtsZDnlpsT (赞：7)

[传送门](https://www.luogu.com.cn/problem/P2422)

$\text{update:2021/9/15/7:00 a.m.}$ 更新 $O(K+n)$ 的做法（$K$ 为常数）。

用链表做的，本来以为题解区都是链表，结果没想到都是单调栈，好像没有链表。。。。。

不过单调栈是 $O(n)$ 的，链表要加一个排序的复杂度，是 $O(n\log n+n)$。

$\large{\text{Soltion}}$

其实思路都差不多。都是枚举区间最小值，然后向两边拓展。

但是我们发现一个重要性质：若枚举到比它小的值就停下，这就让我想到了链表。

我们考虑每次找到当前最大值，我们记完它的值，就把它删除（先不管怎么记录），然后我们会发现，在这样的操作后，每一次访问访问，链表中就没有数比它大。

然后我们就可以轻松发现，当前值的左指针所指的值即为左侧第一个比它小的值，当前值的右指针所指的值即为右侧第一个比它小的值，而它所能更新到的区间即为它的左指针 $+1\sim$ 右指针 $-1$。

计算的话就是当前值 $\times$ 区间和，你可以用~~各种数据结构~~、前缀和等维护区间和。

因为每次要找最大值，所以排序是本程序的复杂度瓶颈（~~当然你可以用各种数据结构~~），总复杂度为 $O(n\log n+n)$，轻松通过。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#include<map>
#include<algorithm>
#define int long long
using namespace std;
//char cc[1<<21],*uu=cc,*vv=cc;
//#define getchar() (uu==vv&&(vv=(uu=cc)+fread(cc,1,1<<21,stdin),uu==vv)?EOF:*uu++)
inline int read(){
	char ch=getchar();int X=0;bool fl=0;
	while(ch<'0'||ch>'9'){if(ch=='-')fl=1;ch=getchar();}
	while(ch>='0'&&ch<='9'){X=(X<<1)+(X<<3)+ch-'0';ch=getchar();}
	if(fl)return ~(X-1);
	return X;
}
int n,l[100005],r[100005],s[100005],ans;
struct N{
	int s,id;
	bool operator<(const N&U)const{//为了排序重载一下，你也可以写cmp
		return s>U.s;
	}
}a[100005];
signed main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=(N){read(),i},s[i]=s[i-1]+a[i].s;
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)l[i]=i-1,r[i]=i+1;//链表的初始化
	for(int i=1;i<=n;i++){//倒序排序后取出的就是最大值
		int t=s[r[a[i].id]-1]-s[l[a[i].id]];//前缀和当前区间和
		ans=max(ans,t*a[i].s);//取max
		l[r[a[i].id]]=l[a[i].id];//删点
		r[l[a[i].id]]=r[a[i].id];
	}
	cout<<ans<<'\n';
}
```

如果您有什么链表优化到 $O(n)$ 的方法，也可以跟我说哦，谢谢！

然后昨天晚上做梦的时候想到了，你说神不神奇。。。

但是这也足以体现我的 sb。

其实方法比较简单，既然排序是复杂度瓶颈，那么就把快排改成桶排或者各种玄学排序。。。但是为了记录编号，所以要开个 vector。

结果由于 vector 慢的一批，所以还没 sort 快。。复杂度 $O(K+n)$（$K$ 为常数）。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#include<map>
#include<algorithm>
#define int long long
using namespace std;
//char cc[1<<21],*uu=cc,*vv=cc;
//#define getchar() (uu==vv&&(vv=(uu=cc)+fread(cc,1,1<<21,stdin),uu==vv)?EOF:*uu++)
inline int read(){
	char ch=getchar();int X=0;bool fl=0;
	while(ch<'0'||ch>'9'){if(ch=='-')fl=1;ch=getchar();}
	while(ch>='0'&&ch<='9'){X=(X<<1)+(X<<3)+ch-'0';ch=getchar();}
	if(fl)return ~(X-1);
	return X;
}
int n,l[100005],r[100005],s[100005],a[100005],ans;
vector<int>v[1000005];//桶
signed main(){
	n=read();
	int ms=0;
	for(int i=1;i<=n;i++){
		a[i]=read(),s[i]=s[i-1]+a[i];
		v[a[i]].push_back(i);
		ms=max(ms,a[i]);
	}
	for(int i=1;i<=n;i++)l[i]=i-1,r[i]=i+1;
	for(int i=ms;i;i--){
		if(v[i].empty())continue;
		for(int j=0;j<v[i].size();j++){
			int t=s[r[v[i][j]]-1]-s[l[v[i][j]]];
			ans=max(ans,t*i);
			l[r[v[i][j]]]=l[v[i][j]];
			r[l[v[i][j]]]=r[v[i][j]];
		}
	}
	cout<<ans<<'\n';
}
```

---

## 作者：玫葵之蝶 (赞：7)

##这题数据太水了

我看了这个题之后，本来打算投机取巧一下，写个70分的代码，结果就AC了。。。

我的思路：枚举每个点，并双向扩展大于等于它的点，这样就可以找到在它是最小点的情况下的最大区间了，然后计算，答案就是最大值。

时间复杂度：一般情况应该可以过，可是如果卡一个所有数字相同的情况，就退化成O(n²)了，显然过不了，可是居然过了，而且总时间才106ms，简直不可思议。

希望各位julao可以来我的博客看看：[blog](http://blog.csdn.net/stone41123)

下来贴代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1000000000
using namespace std;
int n;
int a[100001];
ll f[100001];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    ll ans=0;
    for(int i=1;i<=n;i++){
        f[i]=a[i];
        for(int j=i-1;j>=1;j--){
            if(a[j]>=a[i]){
                f[i]+=a[j];
            }
            else{
                break;
            }
        }
        for(int j=i+1;j<=n;j++){
            if(a[j]>=a[i]){
                f[i]+=a[j];
            }
            else{
                break;
            }
        }
        f[i]=f[i]*a[i];
        ans=max(ans,f[i]);
    }
    printf("%lld",ans);
    return 0;
}

```

---

## 作者：ziiidan (赞：5)

这道题我的写法是用**数据结构优化枚举**，思路简单，代码简洁。

[洛谷博客（或许更好的阅读体验）](https://www.luogu.org/blog/wangziminghedan/ti-xie-p2422-liang-hao-di-gan-jiao)

简化题意：

给你一个长度为 n 的序列，让你求出一个区间，使其区间最小值与区间和的乘积最大，输出这个最大的价值。

我的代码的时间复杂度为$O(nlog^2n)$，但完全可以优化到$O(nlogn)$， 复杂度与你写的数据结构紧密相关。

我的算法流程简述：

我们从 1 到 n 来枚举，考虑当前枚举的值为最小值的时候，左右两边可以扩展到哪里。

因为向两边扩展时，最小值单调不升，所以我们可以二分出这个位置，用数据结构来维护区间最小值来帮助我们在二分的时候验证答案。

那么我们**单次**枚举求解（二分+区间最小检验）的时间复杂度为：

ST表：$O(logn)$

朴素线段树：$O(log^2n)$

线段树二分：$O(logn)$

而区间和我们可以直接用前缀和的方式来求解，复杂度为$O(1)$

下面是蒟蒻的朴素线段树代码:

~~（至于为什么写复杂度最高的，因为蒟蒻不想用ST表，感觉线段树二分没有朴素线段树好写（虽然好像不差几句话））~~

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

const int maxn = 100005;

struct Segment_Tree{
	int l, r, val;
}a[maxn << 2];

int n;

int val[maxn];

long long ans;
long long s[maxn]; // 十年OI一场空，忘开long long见祖宗 

inline int read(void)
{
	int s = 0, w = 1;
	char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') w = -1;
	for(; ch <= '9' && ch >= '0'; ch = getchar()) s = s * 10 + ch - '0';
	return s * w;
}

void build(int u, int l, int r) //朴素的线段树的建树 
{
	a[u].l = l;
	a[u].r = r;
	if(l == r) 
	{
		a[u].val = val[l];
		return ;
	}
	int mid = (l + r) >> 1;
	build(u << 1, l, mid);
	build(u << 1 | 1, mid + 1, r);
	a[u].val = min(a[u << 1].val, a[u << 1 | 1].val);
}

int query(int u, int l, int r) //朴素的线段树的区间查询最小值 
{
	if(a[u].l == l && a[u].r == r) return a[u].val;
	int mid = (a[u].l + a[u].r) >> 1;
	if(r <= mid) return query(u << 1, l, r);
	else if(l > mid) return query(u << 1 | 1, l, r);
	else return min(query(u << 1, l, mid), query(u << 1 | 1, mid + 1, r));
}

int find_l(int to, int goal) // 二分左边最多可以扩展到哪里 
{
	int l = 1, r = to, mid;
	int pos = to;
	while(l + 1 < r)
	{
		mid = (l + r) >> 1;
		if(query(1, mid, pos) < goal) l = mid + 1; //当前找到的位置过于靠左，使得区间最小值不是当前的枚举的值 
		else r = mid;             //当前的位置可行，再往左看看有没有更优的左端点 
	}
	r = query(1, l, pos) < goal ? r : l; // 防止二分边界出问题而暴毙 
	return r;
}

int find_r(int to, int goal) // 二分右边最多可以扩展到哪里
{
	int l = to, r = n, mid;
	int pos = to;
	while(l + 1 < r)
	{
		mid = (l + r) >> 1;
		if(query(1, pos, mid) < goal) r = mid - 1; //当前找到的位置过于靠右，使得区间最小值不是当前的枚举的值
		else l = mid;            //当前的位置可行，再往右看看有没有更优的右端点 
	}
	l = query(1, pos, r) < goal ? l : r; // 防止二分边界出问题而暴毙
	return l;
}

// 如果对二分的过程有疑问的话，可以自己手动模拟一下 
// 实在不理解的话，可以输出中间的二分过程来理解一下 

int main()
{
	n = read();
	for(register int i = 1; i <= n; i++) {val[i] = read(); s[i] = s[i - 1] + val[i];} // 预处理前缀和 
	build(1, 1, n);
	for(register int i = 1; i <= n; i++)
	{
		int l = find_l(i, val[i]), r = find_r(i, val[i]); //找到可以扩展的左右边界 
		ans = max(ans, val[i] * (s[r] - s[l - 1])); // 看看当前枚举的值是否可以更新答案 
	}
	cout << ans << '\n';
	return 0;
}
```

数据结构优化枚举是很常见的一种优化技巧，希望读者在看完这篇题解后对于数据结构优化枚举能有更加深入的理解。

对于以上有什么疑问的话可以直接在评论区发或者洛谷私信，本人看到后会尽快回复的。

谢谢阅读。



---

## 作者：木木！ (赞：4)

我是来给单调队列dalao们补数学证明的。

首先说一下思路。维护一个单调队列（严谨的说法是单调栈），在元素出栈的时候更新答案。如果`q[head]`出栈，则将答案更新为`max(ans,(si[i-1]-si[q[head-1]])*fi[q[head]])`（详见代码）

对于每一个元素`x`，定义其`极大区间`为包含x的，最小值为x的最大区间。即左右端点都不可再扩展的区间。（注：单调队列出栈条件里面一般不需要考虑是否加等号，这可以作为检验单调队列式的正确性的一个窍门，在本题中，加不加等号影响极大区间的右端点是否最右，可以证明不管是否最右都能取到最优解）

接下来就要证明，该算法枚举到了每一个元素的极大区间。

首先，算法枚举的每一个区间`( si[q[head-1]],si[i-1] ]`必然是以`si[q[head]]`为最小值的。因为如果在`si[q[head-1]]~si[q[head]]`一段有小于`si[q[head]]`的值的话，它就不能将其弹出，与单调栈的性质矛盾。如果在`si[q[head]]~i-1`一段有小于`si[q[head]]`的值的话，它就会被提早弹出，就不会留到`i`的时候被弹出。

很显然，不管扩展左端点还是右端点，都会导致最小值变小，即这个区间是极大的。（如果在弹出条件里面取了等号，右端点不一定是极大的，但是仍旧能取到答案）

由于枚举了所有元素的极大区间，则必然会枚举到答案的区间（显然答案是某个极大区间）。

算法的时间复杂度为$\Theta(n)$。

```cpp
#include <cstdio>
using namespace std;

void chkmax(long long& a,long long b)
{
	if(a<b)
	{
		a = b;
	}
}

int fi[100005];
long long si[100005];
int q[100005];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",fi+i);
	}
	
	for(int i=1; i<=n; ++i)
	{
		si[i] = si[i-1]+fi[i]; //前缀和
	}
	
	long long ans = 0;
	int head = 0;
	for(int i=1; i<=n+1; ++i)
	{
		while(head && fi[q[head]]>fi[i])
		{
			chkmax(ans,(si[i-1]-si[q[head-1]])*fi[q[head]]); //保证所更新区间为极大区间
			--head;
		}
		++head;
		q[head] = i;
	}
	
	printf("%lld",ans);
}
```

---

## 作者：_ztyqwq (赞：3)

题意：求区间最小值 * 区间和的最大值。

首先我们~~打个暴力~~观察一下“区间最小值”，明显发现，有许多区间的区间最小值是一样的。并且区间最小值只有 $ n $ 种可能。

那么我们显然可以枚举这个区间最小值。设这个区间最小值为 $ a_i $，那么这个区间一定是包含 $ i $（位置）的。因为所有的数都是正数，所以要想使区间和最大，就要让区间左端点尽量靠左，右端点尽量靠右，也就是让 $ i $ 往左和往右延伸出去越多。但是延伸不是无条件的，区间里的数都不能小于 $ a_i $（不然最小值就变了）

所以我们可以依次选择每个数为最小值，每次 $ O(n) $ 扫描区间范围。这样的复杂度是 $ O(n^2) $，考虑怎么优化后一个 $ O(n) $。

~~经过漫长的思考~~我们发现，如果按数字大小从大到小选择每个数为最小值，那么可以选择的数字只会变多，不会变少，而且每次会增加一个可选数。

所以可选的数字组成了若干个区间。每次我们需要合并一些区间，然后查询一个区间的大小（里面所有数的总和）。我们发现，这个事情可以用并查集来解决，总和就是维护size大小，将所有集合的初始size设为这个数字的值就可以了（当然还有别的做法，~~但是懒得写了直接并查集不就OK了吗233~~）

代码细节上面，$ vis $ 数组用来记录一个数字可不可以被选择。具体实现是当一个数字可以被选入区间时，将它变成一个独立的集合，然后和旁边（左右）的集合进行合并。（记得先离散化）

Code：
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;;
int a[100001],x[100001],fa[100002],sz[100001];
bool cmp(int a,int b)
{
	return x[a]>x[b];
}
int Root(int x)
{
	return fa[x]==x?x:fa[x]=Root(fa[x]);
}
bool vis[100001];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x[i]);
		a[i]=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		fa[i]=i;
		sz[i]=x[i];
	}
	ll ans=0;
	for(int i=1;i<=n;i++)
	{
		vis[a[i]]=true;
		if(vis[a[i]-1])
		{
			int r=Root(a[i]-1);
			fa[r]=a[i];
			sz[a[i]]+=sz[r];
		}
		if(vis[a[i]+1])
		{
			int r=Root(a[i]+1);
			fa[r]=a[i];
			sz[a[i]]+=sz[r];
		}
		ans=max(ans,ll(x[a[i]])*sz[a[i]]);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Celebrate (赞：1)

详见[MyBlog](https://blog.csdn.net/zsyzClb/article/details/85689385)

我一眼看上去，好像没有什么思路，于是我决定换一种思路来做

因为如果确定了一个点为最小值，那么可以达到的最舒服的天数就显而易见了

这样时间就优化到O(N^2)，想起以前学LCA的时候用了倍增，于是我决定也用倍增

并且先用st表预处理一下时间直接优化到O(NlogN）

 

参考代码


```cpp
#include <iostream>
#include <cstring>
 
using namespace std ;
 
typedef long long LL ;
 
const int N = 1e5 + 10 ;
 
int n , a[N] ;
int st[N][21] , log[N] ;
LL sum[N] ;
 
int solve ( int x , int y ) {
	int z = log[y-x+1] ;
	return min ( st[x][z] , st[y-(1<<z)+1][z] ) ;
}
 
void get ( int pos , int &l , int &r ) {
	l = r = pos ;
	for ( int j = 20 ; j >= 0 ; j -- ) {
		if ( l - (1<<j) >= 1 && solve( l - (1<<j) , pos ) == a[pos] )
			l = l - (1<<j) ;
		if ( r + (1<<j) <= n && solve( pos , r + (1<<j) ) == a[pos] ) 
			r = r + (1<<j) ;
	}
}
 
LL maxx = 0 ;
 
int main() {
	cin >> n ; log[0] = -1 ; int l , r ;
	for ( int i = 1 ; i <= n ; i ++ ) 
		cin >> a[i] , st[i][0] = a[i] , log[i] = log[i>>1] + 1 ;
	for ( int i = 1 ; (1<<i) <= n ; i ++ ) 
		for ( int j = 1 ; j + (1<<i) <= n ; j ++ )
			st[j][i] =  min ( st[j][i-1] , st[j+(1<<(i-1))][i-1] ) ;
	for ( int i = 1 ; i <= n ; i ++ ) sum[i] = sum[i-1] + a[i] ;
	for ( int i = 1 ; i <= n ; i ++ ) {
		get ( i , l , r ) ;
		if ( ( sum[r] - sum[l-1] ) * LL(a[i]) > maxx ) 
			maxx = ( sum[r] - sum[l-1] ) * LL(a[i]) ;
	}
	cout << maxx << endl ; return 0 ;
}

```

---

## 作者：Lance1ot (赞：1)

~~纯暴力能过？~~

~~跑的比优化暴力快，好把是数据弱~~

我相信,$O(N^2)$的暴力大家都能想出来~~并且可能已经切掉了这道题~~

不过应该是数据是随机造的缘故qwq

如果是一个递增或递减的序列，那么足足的能把$O(N^2)$的暴力卡掉

正解又不会写，只好考虑优化暴力。

显然，枚举第几小的时间复杂度不可能更优了，就需要优化求解

然后我们观察一下数据范围$n<=100,000$

wow~ 只要我们能将求解优化到$O(logn)$或者是$O(1)$就可以了

然后我们可以考虑倍增，一种比较高级的枚举(滑稽)

先预处理出来一个st表，然后每次倍增的跳

考虑如果当前所枚举的塾的大小是$val_i$，位置是$i$

如果$i \to i+2^j$中最小值不是$val_i$我们检查$i\to i+2^{j-1}-1$中的最小值，如果是$val_i$的话，我们就可以跳到$i+2^{j-1}$处，如果不是，则继续减少$j$

如此操作，我们就在某个方向上得到了第一个比$val_i$大的数，然后减一就是最大的区间的端点。

上面是向左跳，如果是向右跳的话，就反过来

然后利用倍增，我们成功将时间复杂度优化到了$O(nlogn)$

```cpp
#include<cstdio>
#include<iostream>
#include<iostream>
#include<algorithm>
using std::sort;
using std::max;
using std::min;
const int maxn=101000;
struct node
{
	long long val;
	int pos;
};
node data[maxn];
bool compare(const node &a,const node &b)
{
	return a.val<b.val;
}
long long st[maxn][30];
long long map[maxn];
int main()
{
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&st[i][0]);//st表初始值
		data[i].val=st[i][0];//先将每个数的大小和位置存下来
		data[i].pos=i;//存位置
		map[i]+=map[i-1]+st[i][0];//前缀和
	}
	sort(data+1,data+1+n,compare);//排序
	for(int i=1;i<=20;i++)//处理st表
		for(int j=1;j+(1<<i)-1<=n;j++)
			st[j][i]=min(st[j][i-1],st[j+(1<<(i-1))][i-1]);
	long long ans=0;
	for(int i=1;i<=n;i++)//枚举第几小的数
	{
		int Max=data[i].pos;//Max为最靠右的端点
		int Min=data[i].pos;//最靠左大端点
		long long V=data[i].val;
		for(int j=20;j>=0;j--)
			if(Max+(1<<j)-1<=n&&st[Max][j]>=V)
				Max=Max+(1<<j);//倍增的跳
		Max--;//不要忘了减一
		for(int j=20;j>=0;j--)
			if(Min-(1<<j)+1>=1&&st[Min-(1<<j)+1][j]>=V)
				Min=Min-(1<<j);
		Min++;
		ans=max(ans,V*(map[Max]-map[Min-1]));//比较答案
	}
	printf("%lld",ans);
}

```


---

## 作者：Alcohol_C (赞：1)

这道题显然是维护一个单调递增的单调栈


每次插入进行弹出操作到左面没有比它再小的数即可


答案统计见代码。


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<queue>
using namespace std;
long long n,yz,ans,top,ansf,ansb;
struct stac{
    long long num,id;
    bool operator >= (const stac x) const {return num>=x.num;}
    bool operator == (const stac x) const {return num==x.num;}
    stac & operator = (stac & x) {num=x.num;id=x.id;return *this;}
}sta[100005],ne;
long long s[100005];
int main(){
    while(scanf("%lld",&n)==1){
        memset(s,0,sizeof(s));
        top=0;ans=0;
        for(long long i=1;i<=n;i++){
            scanf("%d",&ne.num); ne.id=i;
            s[i]=s[i-1]+ne.num;
            while(top!=0&&sta[top]>=ne){
                ans=max(ans,(s[i-1]-s[sta[top-1].id])*sta[top].num);
                top--;
            }
            sta[++top]=ne;
        }
        while(top){
            if(ans<(s[n]-s[sta[top-1].id])*sta[top].num)
                ans=max(ans,(s[n]-s[sta[top-1].id])*sta[top].num);
            top--;
        }
        printf("%lld",ans);
    }
    return 0;
}
```

---


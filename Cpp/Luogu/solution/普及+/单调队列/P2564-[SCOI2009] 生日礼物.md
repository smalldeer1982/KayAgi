# [SCOI2009] 生日礼物

## 题目背景

四川2009NOI省选


## 题目描述


小西有一条很长的彩带，彩带上挂着各式各样的彩珠。已知彩珠有 $N$ 个，分为 $K$ 种。简单的说，可以将彩带抽象为一个 x 轴，每一个彩珠有一个对应的坐标（即位置）。某些坐标上可以没有彩珠，但多个彩珠也可以出现在同一个位置上。

小布的生日快到了，于是小西打算剪一段彩带送给小布。为了让礼物彩带足够漂亮，小西希望这一段彩带中能包含所有种类的彩珠。同时，为了方便，小西希望这段彩带尽可能短，你能帮助小西计算这个最短的长度么？

彩带的长度即为彩带开始位置到结束位置的位置差。


## 说明/提示


### 样例说明

有多种方案可选，其中比较短的是 $1 \sim 5$ 和 $5 \sim 8$。后者长度为 $3$，更短，故答案为 $3$。

### 数据范围

对于 $50\%$ 的数据，$N \le 10^4$；

对于 $80\%$ 的数据，$N \le 8 \times 10^5$；

对于 $100\%$ 的数据，$1 \le N \le 10^6, 1 \le K \le 60$，$0 \le$ 珠子位置 $< 2^{31}$，且 $\sum T_i = N$。

## 样例 #1

### 输入

```
6 3
1 5
2 1 7
3 1 3 8
```

### 输出

```
3```

# 题解

## 作者：薇蒻一枚 (赞：37)

## 背景
	7月2*日既是某位兔子/狐狸/巫女/……小姐的生日,7月2*日又是本蒟蒻	
    的生日（洛谷送了我个橙名),樱(嘤)此写了一道叫做生日礼物的题。
## 审题
1.通过审题我们不难想到一道类似的题目——逛画展。由此我们可以基本断定
  这道题应该用单调队列。

2.两道题的唯一区别在于——一个结点上可以有多个彩球。

3.最后看数据规模——n已到达10e6的规模,因此暴力~~说不定能骗点分~~是不   可行的“不可以~”——zjh

## 思路
1.“既然两道题类似，那能不能继承P1638的思路呢”懒惰的jl想到。
	其实两道题是可以互相转换的：我们可以定义一个结构体，结构体内储存
    两个关键词——类型和位置。

2.以位置为关键字排序。

3..我们把同一位置的两个彩球拆开来看，即两个	类型不同，位置相同的小球，这样就可以继承P1638的思路了——因为在执行算法时，两者是没有区别的

## 代码(理论上AC了)
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;
int n,k,t,len=0x3f3f3f3f;
int id[maxn],b;
struct node{
	int pos;
	int val;
}f[maxn];
bool cmp（n0de a,node b）
{
	return a.pos<b.pos;
}
int main()
{
	memset(id,-1,sizeof(id));
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++)
	{
		scanf("%d",&t);
		for(int j=1;j<=t;j++)
		{
			scanf("%d",&f[++b].pos);
			f[b].val=i;
		}
	}
	sort(f+1,f+n+1,cmp);
	int hd=1,cnt=0;
	for(int i=1;i<=n;i++)
	{
		if(id[f[i].val]==-1) cnt++;
		id[f[i].val]=f[i].pos;
		while(hd<=i&&f[hd].pos!=id[f[hd].val]) hd++;
		if(cnt==k&&f[i].pos-f[hd].pos<len) len=f[i].pos-f[hd].pos;
	}
	printf("%d",len）;
	return o;
}

```cpp

---

## 作者：米奇 (赞：21)

## 算法:区间伸缩

### 时间复杂度:$O(n)$

我看了一下题解，发现没有题解是用区间伸缩的方法，决定写一篇题解

这题和P1638 逛画展很像,几乎就是一模一样。唯一的区别就是可能同一个位置上可能都有多个"彩珠"

然而有多个"彩珠"这点有和P2698[USACO12MAR]花盆Flowerpot这题一样

逛画展和花盆两题中有我的题解,有兴趣的可以去看一下

讲一下区间伸缩是怎么做的吧

用两个变量$l$和$r$来枚举区间

如果$l$到$r$的区间不满足要求,$r$++

如果$l$到$r$的区间满足要求,记录答案,$l$++

### 代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int l,r,n,m,k,t,b[105],cnt,ans;
//cnt记录当前区间有几种不同的颜色
struct node{
	int val,id;
}a[N];
bool cmp(node a,node b)
{
	return a.val<b.val;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&k);
		for(int j=1;j<=k;j++)
		{
			scanf("%d",&a[++t].val);
			a[t].id=i;
		}
	}
	ans=1e9;
	sort(a+1,a+t+1,cmp);//排序是为了使位置相同的"彩珠"在一起
	l=r=1;b[a[1].id]=1;cnt=1;
	for(int i=2;i<=n;i++)
		if(a[i].val==a[i-1].val)
		{
			r++;
			b[a[i].id]++;
			if(b[a[i].id]==1)cnt++;
		}
		else break;
    //注意每次要把同一个位置的"彩珠"全部算
	while(l<=n&&r<=n)
	{
		if(cnt==m)//满足条件
		{
			ans=min(ans,a[r].val-a[l].val);
			b[a[l].id]--;if(b[a[l].id]==0)cnt--;
			l++;if(l>n)break;//注意边界
			while(a[l].val==a[l-1].val)
			{
				b[a[l].id]--;if(b[a[l].id]==0)cnt--;
				l++;if(l>n)break;//注意边界
			}
		}
		else{//不满足条件
			r++;if(r>n)break;//注意边界
			b[a[r].id]++;if(b[a[r].id]==1)cnt++;
			while(a[r+1].val==a[r].val)
			{
				r++;if(r>n)break;//注意边界
				b[a[r].id]++;if(b[a[r].id]==1)cnt++;
			}
		}
	}
	cout<<ans;
}
```

---

## 作者：ix35 (赞：16)

### 看了下题解里的讲法感觉没太理解，自己写一篇吧...

题目大意：有n个k种颜色的点，选出一个长度尽量短的区间，使得每种颜色的点都在区间内出现。

用队列实现即可。（说真的不太懂这个算不算单调队列）

首先按照坐标从左到右进行排序，有一件事是显然的：右端点最靠左的可选区间应该是每种颜色坐标的最小值的最大值。也就是$\max \limits _{1<=i<=k}l[i]$，其中$l[i]$指第$i$种彩珠最靠左的位置。

什么意思呢？比如说样例，考虑到如果右端点小于5，则无论如何也不可能在区间里出现第一种彩珠，因此右端点的最小值为5。这里我们可以开一个变量al，表示目前已经出现多少种彩珠，只有当$al=k$时才更新答案。

另外，我们考虑在右端点确定的情况下决定最优的左端点位置（其实就是要尽量靠右），保证每种彩珠都有出现，因此我们可以开变量$cnt[i]$表示第$i$种彩珠目前在区间出现了多少次，另外用一个队列$q$保存当前在区间里的彩珠。

如果队首元素（坐标最小）出现的次数大于1，则可以删去，这是因为删去后依然有这种彩珠存在，如果出现的次数恰好等于1，则不能删去，因为删去后这种彩珠就不再出现再队列中。

因此只要维护$cnt$数组，并在枚举时将当前彩珠加入队列，检查队首是否可以删去，即可解决问题。

时间复杂度为排序的$O(nlogn)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct P {
	int x,u;
}p[1000010];
int cnt[70],al,n,k,t,ans,cnt1;
queue <P> q;
bool cmp (P a,P b) {
	return a.x<b.x;
}
int main () {
	ans=1e9;
	scanf("%d%d",&n,&k);
	for (int i=1;i<=k;i++) {
		scanf("%d",&t);
		for (int j=1;j<=t;j++) {
			scanf("%d",&p[++cnt1].x);
			p[cnt1].u=i;
		}
	}
	sort(p+1,p+n+1,cmp);
	for (int i=1;i<=n;i++) {
		if (cnt[p[i].u]==0) {
			al++;
		}
		cnt[p[i].u]++;
		q.push(p[i]);
		while (!q.empty()&&cnt[q.front().u]>1) {
			cnt[q.front().u]--;
			q.pop();
		}
		if (al==k) {
			ans=min(ans,p[i].x-q.front().x);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：fscbti (赞：15)

老师集训的题，猛然发现自己的解法居然独一无二！

解法就是：$dfs!$再加上2层2分。是不是有点惊人？而且并没有数据卡掉了我这种接近暴力的解法。

分析可得，$k$小的惊人，所以$dfs$也就可以了。而朴素的$dfs$绝对过不了，所以要加上优化。

外层的二分就是来优化的，其实更多的还是让思路更清晰，这个二分是二分答案。这样，$dfs$就成了判断了，可以进行剪枝了。

然而，这个优化仍微不足道，在$dfs$里有一个贪心的优化。

假设现在的范围为$[x,y]$，搜到了第$i$个品种，那么如果有位置在$[x,y]$间的，那么直接返回$dfs(i+1,x,y)$的值，因为这样必定为最优。如果没有，那么就返回$dfs(i+1,t,y)|dfs(i+1,x,l)$，($t$为小于$x$的最大值，$l$为大于$y$的最小值）这样，再加上前面的剪枝，就可以卡过时限了。

然而，还是担心会被卡，那就是里层二分的作用了。因为枚举上面的$t$可能会超时，因为位置都是有序的，可以用二分查找，这样时间效率提高了一些。

剩下的就是一下调试细节了。
下面是集训时交的代码
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
#include <queue>
using namespace std;
#define re register int
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*ff;
} 
int n,k,a[65][1000005],tt[65],opt,mx=0,mn=2147483647;
bool dfs(int i,int x,int y){
    if(i>k)return (y-x)<=opt;
    if(y-x>opt)return 0;
    int j=1,t,ll=1,rr=tt[i],mid;
    //while(a[i][j]<x&&j<=tt[i])j++;
    while(ll<=rr){
        mid=(ll+rr)>>1;
        if(a[i][mid]>=x)rr=mid-1;
        else ll=mid+1;
    }
    j=ll;
    if(a[i][j]==x)return dfs(i+1,x,y);
    if(j>tt[i])return dfs(i+1,a[i][tt[i]],y);
    if(a[i][j]>=x&&a[i][j]<=y)return dfs(i+1,x,y);
    if(j>1){
        t=j-1;
        if(y-a[i][t]<=opt)
        if(dfs(i+1,a[i][t],y))return 1;
    }
    if(a[i][j]-x<=opt)return dfs(i+1,x,a[i][j]);
    return 0;
}
bool ok(int x){
    opt=x;
    for(int i=1;i<=tt[1];i++){
        if(dfs(2,a[1][i],a[1][i]))return 1;
    }
    return 0;
}
signed main(){
    n=read();k=read();int l,r,mid;
    for(int i=1;i<=k;i++){
        tt[i]=read();
        for(int j=1;j<=tt[i];j++){
            a[i][j]=read();
        }
        mx=max(mx,a[i][tt[i]]);mn=min(mn,a[i][1]);
    }
    if(k==1){cout<<0<<endl;return 0;}
    l=0;r=mx-mn;
    while(l<=r){
        mid=(l+r)>>1;
        if(ok(mid))r=mid-1;
        else l=mid+1;
    }
    printf("%d\n",l);
    return 0;
}
```
考试后，听同学说洛谷有原题，于是交了上去，$AC$了。一阵高兴加激动。毕竟解法挺新奇。
然而......老师那儿爆零了！$rank$掉了10位。

原来数组开爆了，洛谷的评测是看运行空间。。。。

于是数组改成$vector$就过了。。。。
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
#include <queue>
using namespace std;
#define re register int
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*ff;
} 
int n,k,tt[65],opt,mx=0,mn=2147483647;
vector<int>a[65];
bool dfs(int i,int x,int y){
    if(i>k)return (y-x)<=opt;
    if(y-x>opt)return 0;
    int j=1,t,ll=0,rr=tt[i]-1,mid;
    //while(a[i][j]<x&&j<=tt[i])j++;
    while(ll<=rr){
        mid=(ll+rr)>>1;
        if(a[i][mid]>=x)rr=mid-1;
        else ll=mid+1;
    }
    j=ll;
    if(a[i][j]==x)return dfs(i+1,x,y);
    if(j>=tt[i])return dfs(i+1,a[i][tt[i]],y);
    if(a[i][j]>=x&&a[i][j]<=y)return dfs(i+1,x,y);
    if(j>0){
        t=j-1;
        if(y-a[i][t]<=opt)
        if(dfs(i+1,a[i][t],y))return 1;
    }
    if(a[i][j]-x<=opt)return dfs(i+1,x,a[i][j]);
    return 0;
}
bool ok(int x){
    opt=x;
    for(int i=0;i<tt[1];i++){
        if(dfs(2,a[1][i],a[1][i]))return 1;
    }
    return 0;
}
signed main(){
    n=read();k=read();int l,r,mid;
    for(int i=1;i<=k;i++){
        tt[i]=read();
        for(int j=1;j<=tt[i];j++){
            //a[i][j]=read();
            a[i].push_back(read());
        }
        mx=max(mx,a[i][tt[i]-1]);mn=min(mn,a[i][0]);
    }
    if(k==1){cout<<0<<endl;return 0;}
    l=0;r=mx-mn;
    while(l<=r){
        mid=(l+r)>>1;
        if(ok(mid))r=mid-1;
        else l=mid+1;
    }
    printf("%d\n",l);
    return 0;
}
```
所以，算紧了时间，不要忘了空间啊！！！


---

## 作者：wjyyy (赞：13)

## 解法一、线段树

   这个题可以先排序，从左到右做，每次更新这个颜色最后一次出现的位置，放入线段树。如果所有颜色都出现过，就去线段树中查询所有颜色最后一次出现时间的最小值。每次更新**当前位置与这个最小值之差**的最小值作为答案，时间复杂度为$O(N(\log n+\log k))$。线段树长度只用开$k$即可。

## 解法二、two-pointer

   正解是类似two-pointer的尺取法，也就是先排序，从左到右找，定义一个左端点初始化为0。每次找到一个新的颜色就把前面的颜色打上**删除标记**，等找到全部颜色以后就从左端点开始枚举，把左端点调整到第一个没有删除标记的位置，这就是到当前位置的最优答案。
   
![](http://www.wjyyy.top/wp-content/uploads/2018/08/201808052008.png)

   当我们第一次发现所有的颜色，是在第7个位置，此时的左端点为1，我们从左边开始检索，找到第一个没有被删除的位置：2。那么我们找到的第一个答案就是7-2=5，更新到最小值中去。再继续遍历，发现2，此时把左边的2删除，这时左端点可以被移到4号位置去，更新最小值就是8-4=4。时间复杂度是$O(N\log N+K)$
   
   不过这个题的数据规模是$10^6$，跑$O(N\log N)$的排序~~有的~~评测机就可能吃不消。我们其实还可以优化。
   
## 解法二之堆优化
 
   注意到题目给出的位置都是**升序**，那联想到归并排序合并的过程，我们只要每次找到$k$列中剩下的最小的元素取出来不就可以了吗。在$k$列中找最小只需要一个$k$大小的堆就可以了。这样排序，对于很小很小的$k$来说，近似$O(N)$。时间复杂度为$O(N\log K+K)$。
   
## Code of two-pointer：
```
cpp
#include<cstdio>
#include<cstring>
#include<vector>
using std::vector;//因为不知道每一种颜色有多少个所以用vector
struct node
{
    int c,v;
    node(int c,int v)
    {
        this->c=c;
        this->v=v;
    }
    node()
    {}
    friend bool operator <(node a,node b)
    {return a.v<b.v;}

    friend bool operator >(node a,node b)
    {return a.v>b.v;}

}h[128],b[1000100];
int l=0;
//手写堆部分，优化常数
void push(node k)
{
    h[++l]=k;
    int i=l;
    while(i>1&&h[i]<h[i>>1])
    {
        node t=h[i];
        h[i]=h[i>>1];
        h[i>>1]=t;
        i>>=1;
    }
    return;
}
void pop()
{
    int i=1;
    h[1]=h[l--];
    while((i<<1)<=l&&(h[i]>h[i<<1]||h[i]>h[i<<1|1]))
        if((i<<1)==l||h[i<<1]<h[i<<1|1])
        {
            node t=h[i];
            h[i]=h[i<<1];
            h[i<<1]=t;
            i<<=1;
        }
        else
        {
            node t=h[i];
            h[i]=h[i<<1|1];
            h[i<<1|1]=t;
            i=i<<1|1;
        }
    return;
}
vector<int> v[66];
int tt[66],now[66];//tt是总共的个数，now是现在的个数，用于堆排序
int lst[66];//某种颜色上一次出现的位置
int used[66];//颜色出现过没有，used[0]表示一共出现了多少种颜色
int del[1000100],st=1;//删除标记和左端点
int main()
{
    memset(lst,0,sizeof(lst));
    int n,k,u;
    scanf("%d%d",&n,&k);
    for(int i=1;i<=k;i++)
        now[i]=1;
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&tt[i]);
        for(int j=1;j<=tt[i];j++)
        {
            scanf("%d",&u);
            v[i].push_back(u);
        }
    }

    for(int i=1;i<=k;i++)
        push(node(i,v[i][0]));
    for(int i=1;i<=n;i++)//排序过程
    {
        b[i]=h[1];
        pop();
        if(now[b[i].c]<tt[b[i].c])
            push(node(b[i].c,v[b[i].c][now[b[i].c]]));
        now[b[i].c]++;
    }
    int ans=0x7fffffff;
    for(int i=1;i<=n;i++)
    {
        if(!used[b[i].c])
        {
            used[b[i].c]=1;
            used[0]++;
        }
        del[lst[b[i].c]]=true;
        lst[b[i].c]=i;
        if(used[0]==k)
        {
            while(del[st])//删除该删除的
                st++;
            ans=ans<(b[i].v-b[st].v)?ans:(b[i].v-b[st].v);//更新答案
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

## Code of Segmentree：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ls (k<<1)
#define rs (k<<1|1)
#define mid (l+r>>1)
#define Mid (t[k].l+t[k].r>>1)
int Min(int x,int y)
{
    return x<y?x:y;
}
struct node
{
    int l,r,v;
    node(int l,int r)
    {
        this->l=l;
        this->r=r;
        v=-1;
    }
    node()
    {
        v=-1;
    }
}t[500];
void build(int k,int l,int r)
{
    t[k]=node(l,r);
    if(l==r)
        return;
    build(ls,l,mid);
    build(rs,mid+1,r);
}
void change(int k,int p,int x)
{
    if(t[k].l==t[k].r)
    {
        t[k].v=x;
        return;
    }
    if(p<=Mid)
        change(ls,p,x);
    else
        change(rs,p,x);
    t[k].v=Min(t[ls].v,t[rs].v);
    return;
}
int ask(int k,int l,int r)
{
    if(t[k].l==l&&t[k].r==r)
        return t[k].v;
    if(r<=Mid)
        return ask(ls,l,r);
    else if(l>Mid)
        return ask(rs,l,r);
    else
        return Min(ask(ls,l,Mid),ask(rs,Mid+1,r));
}

struct ball
{
    int c,p;
    friend bool operator <(ball a,ball b)
    {
        return a.p<b.p;
    }
}a[1000010];
int cnt=0;
int main()
{
    int n,k,t,u;
    scanf("%d%d",&n,&k);
    build(1,1,k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&t);
        for(int j=1;j<=t;j++)
        {
            scanf("%d",&u);
            a[++cnt].c=i;
            a[cnt].p=u;
        }
    }
    std::sort(a+1,a+1+n);
    int ans=0x7fffffff;
    for(int i=1;i<=n;i++)
    {
        change(1,a[i].c,a[i].p);
        int tmp=ask(1,1,k);//更新最晚值
        if(tmp==-1)//为-1说明还有颜色没找到
            continue;
        ans=ans<(a[i].p-tmp)?ans:(a[i].p-tmp);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：风之城0 (赞：11)

**~~今天听老师讲完才恍然大悟~~**
-

**这题的做法叫“双指针”，先是将所有的颜色和它的位置放入到一个数组内，按位置从小到大排序，然后用两个指针指向开头，每次挪动尾指针，用一个数组记录每种颜色的出现次数，若第一次为1，则颜色总数加加，当颜色总数为k时，先更新答案，再一次次挪动头指针，每次更新答案，直到颜色总数不为k时，再跳出循环，继续右指针加加，直到右指针大于n时，此时再挪动左指针就没有意义，因为颜色总数永远不可能达到k了，最后输出答案**

**下面就是代码啦**
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<bits/stdc++.h>
using namespace std;
int n,k,s,b[61],cnt,ans=(1<<31)-1;
struct Node{
	int v,id;
	inline friend bool operator <(const Node &x,const Node &y){
		return x.id<y.id;
	}
}a[1000001];
int main(){
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=k;++i){
		int m;
		scanf("%d",&m);
		for(register int j=1;j<=m;++j){
		    a[++s].v=i;
		    scanf("%d",&a[s].id);
		}
	}
	sort(a+1,a+n+1);
	for(register int l=1,r=1;r<=n;){
		b[a[r].v]++;
		if(b[a[r].v]==1)cnt++;
		if(cnt==k){
			ans=min(ans,a[r].id-a[l].id);
			while(1){
				b[a[l].v]--;
				if(b[a[l].v]==0)cnt--;
				l++;
				if(cnt<k)break;
				else ans=min(ans,a[r].id-a[l].id);
			}
		}
		r++;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：锅钢Carl (赞：10)

笔者一开始在试炼场上的单调队列栏目看到这题，看完题目后，首先想到的做法却没有用到单调队列，这里姑且写一写吧。
	
这里记答案（最短彩带长度）为ans。
	
(1)首先，取每种彩珠中的坐标最小彩珠，存入一个集合（姑且记这个集合为A）。
    
(2)取集合A中的坐标最大值与最小值的差更新ans。
    
(3)接着，把坐标最小值的彩珠从集合A中删除，取与该彩珠同种类的、坐标大于该彩珠坐标的彩珠中，坐标最接近该彩珠坐标的彩珠，放入集合A，如果没有符合要求的彩珠，则执行(4)，否则回到(2)。
    
(4)此时ans为最短彩带长度。
	
因为给出的彩珠已分类，且同种彩珠的坐标已经按升序排好序，所以对于“与该彩珠同种类的、坐标大于该彩珠坐标的彩珠中，坐标最接近该彩珠坐标的彩珠”，其实取下一个彩珠就好了。
    
对于集合A中的坐标最大值与最小值，可分别用**大根堆与小根堆**维护，或者是用**平衡树**来维护也可以。
    
时间复杂度为O(nlogk)，空间复杂度为O(n)。
    
代码如下：
 ```cpp
#include<cstdio>
#define maxn 1000005
#define maxk 66
int T[maxk],head[maxk],pos[maxk];
//head[x]表示为第一个种类x的彩珠（也是种类x中坐标最小的彩珠）在数组a中的位置
//pos[x]表示当前取的种类x的彩珠在数组a中的位置
int heap[2][maxk],location[2][maxk];
//heap[0]为小根堆，heap[1]为大根堆
//location[0][x]为当前取的种类x的彩珠在小根堆中的位置
//location[1][x]为当前取的种类x的彩珠在大根堆中的位置
int a[maxn];//存彩珠的坐标
int n,k,cnt;
int ans=0x3f3f3f3f;
bool cmp(int x,int y,bool flag)
{
	if (flag) return (a[pos[x]]>a[pos[y]]);
	else return (a[pos[x]]<a[pos[y]]);
}
inline void shiftup(int x,bool flag)
{
	while (x>1)
		if (cmp(heap[flag][x],heap[flag][x/2],flag))
		{
			heap[flag][x]^=heap[flag][x/2]^=heap[flag][x]^=heap[flag][x/2];
			location[flag][heap[flag][x]]=x;
			location[flag][heap[flag][x/2]]=x/2;
			x/=2;
		}else break;
}
inline void shiftdown(int x,bool flag)
{
	int i;
	while (x*2<=heap[flag][0])
	{
		i=x*2;
		if (i+1<=heap[flag][0]&&cmp(heap[flag][i+1],heap[flag][i],flag)) i++;
		if (cmp(heap[flag][i],heap[flag][x],flag) )
		{
			heap[flag][i]^=heap[flag][x]^=heap[flag][i]^=heap[flag][x];
			location[flag][heap[flag][x]]=x;
			location[flag][heap[flag][i]]=i;
			x=i;
		}else break;
	}
}
inline void add(int x)
{
	heap[1][++heap[1][0]]=heap[0][++heap[0][0]]=x;
	location[1][x]=location[0][x]=heap[0][0];
	shiftup(heap[0][0],0);
	shiftup(heap[1][0],1);
}
inline void repair(int x)
{
	shiftup(location[0][x],0);
	shiftdown(location[0][x],0);
	shiftup(location[1][x],1);
	shiftdown(location[1][x],1);
}
int main()
{
	int i,j;
	scanf("%d%d",&n,&k);
	for(i=1;i<=k;i++)
	{
		scanf("%d",&T[i]);
		head[i]=cnt+1;
		pos[i]=head[i];
		for(j=1;j<=T[i];j++,cnt++) scanf("%d",&a[cnt+1]);
		add(i);
	}
	while (1<2)
	{
		if (ans>a[pos[heap[1][1]]]-a[pos[heap[0][1]]])
			ans=a[pos[heap[1][1]]]-a[pos[heap[0][1]]];
		i=heap[0][1];
		pos[i]++;//把所取的种类i的彩珠改为种类i的下一个彩珠
		if (pos[i]>=head[i]+T[i]) break;
		//若原本所取的种类i的彩珠坐标为种类i中的最大坐标，则退出循环
		repair(i);//维护大根堆与小根堆
	}
	printf("%d\n",ans);
	return 0;
}
```
	
其实只用一个小根堆维护最小值就好了，因为对于各个种类的彩珠的坐标是单调递增的，最大值也是单调递增的，所以对于最大值，只需要用一个变量维护就好，笔者既用小根堆又用大根堆，未免太麻烦了。
    
感谢qinhaoyun的指导。
    
笔者的语言表达能力有限，可能有些地方表达不清，如有疑问，可与笔者在私下交流。
    

---

## 作者：henry_y (赞：8)

[博客阅读效果更佳哦](http://www.cnblogs.com/henry-1202/p/8666497.html)

题目：

Description

小西有一条很长的彩带，彩带上挂着各式各样的彩珠。已知彩珠有N个，分为K种。简单的说，可以将彩带考虑为x轴，每一个彩珠有一个对应的坐标(即位置)。某些坐标上可以没有彩珠，但多个彩珠也可以出现在同一个位置上。 小布生日快到了，于是小西打算剪一段彩带送给小布。为了让礼物彩带足够漂亮，小西希望这一段彩带中能包含所有种类的彩珠。同时，为了方便，小西希望这段彩带尽可能短，你能帮助小西计算这个最短的长度么？彩带的长度即为彩带开始位置到结束位置的位置差。

Input

第一行包含两个整数N, K，分别表示彩珠的总数以及种类数。接下来K行，每行第一个数为Ti，表示第i种彩珠的数目。接下来按升序给出Ti个非负整数，为这Ti个彩珠分别出现的位置。

Output

应包含一行，为最短彩带长度。

Sample Input

6 3

1 5

2 1 7

3 1 3 8

Sample Output

3

HINT

有多种方案可选，其中比较短的是1~5和5~8。后者长度为3最短。

【数据规模】

对于50%的数据， N≤10000；

对于80%的数据， N≤800000；

对于100%的数据，1≤N≤1000000，1≤K≤60，0≤彩珠位置<2^31。

题解：

写法大意：单调队列

sort一遍保证位置的单调性，开一个pos数组存第i种彩带最后出现的位置，出队的时候判断一下那个元素的位置是否与pos数组相同即可（不同才能出队）

就样例来模拟一波：

6 3
1 5
2 1 7
3 1 3 8

进行排序以后的f数组：

f[i].x	2	3	3	1	2	3

f[i].y	1	1	3	5	7	8

（pos数组要先初始化为-1）

（len要初始化为f[n].y-f[1].y，即最坏的情况（否则会有5个点挂掉(luogu会，bzoj没试过)））

当i=1时

pos[f[i].x]为-1，那么f[i]入队，队列中的珠子多了一个了，cnt++

更新pos[f[i].x]的值为f[i].y

开始出队操作：

当队头head<=队尾i且队头的元素所在位置f[head].y！=该位置珠子最后出现的位置（即pos[f[head].x]）时就可以出队了！

最后更新一下答案：

当cnt（队列内珠子种数）=k（珠子种数）时就可以更新答案了！

len=min(len,f[i].y-f[head].y)

这样从头枚举到尾就好了，时间复杂度（nlogn）（排序需要nlogn的时间复杂度）

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll int
#define min(x,y) x<y?x:y
inline void read(ll &x){
    x=0;ll f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x*=f;
}
using namespace std;
#define N 1000010
struct node{ll x,y;}f[N];
//x表示所属彩珠类型，y表示w位置
ll n,k,len,pos[N];
bool cmp(node x,node y){return x.y<y.y;}
int main(){
    read(n);read(k);ll a,b=0;
    for(ll i=1;i<=k;i++){
        read(a);pos[i]+=a;
        for(ll j=1;j<=a;j++){
            read(f[++b].y);
            f[b].x=i;
        }
    }
    sort(f+1,f+n+1,cmp);
    len=f[n].y-f[1].y;ll head=1,cnt=0;
    memset(pos,-1,sizeof(pos));
    for(ll i=1;i<=n;i++){
        if(pos[f[i].x]==-1)cnt++;
        pos[f[i].x]=f[i].y;
        while(head<=i&&f[head].y!=pos[f[head].x])head++;
        if(cnt==k&&f[i].y-f[head].y<len)len=f[i].y-f[head].y;
    }
    printf("%d",len);
    return 0;
}
```

---

## 作者：巨型方块 (赞：5)

你们想啊，不就是要集齐所有的的种类嘛

我们就先把n个数排个序，让他们的坐标从小到大

然后搞个队列，把数一个一个塞进去，当队列中的种类齐全时更新答案，再把数字先进先出地弹出，

不就好了吗

O（N）AC啊

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
struct xxx{
    int x,y;//x是坐标 y是种类 
}a[1000001],f[1000001];
int b[100];
int n,m,N,l,ans,sum,r;
bool cmp(xxx x,xxx y){
    return x.x<y.x;
}
void in(xxx a){
    r++;
    f[r]=a;
    b[a.y]++;
    if(b[a.y]==1)sum++;
}
void out(){
    b[f[l].y]--;
    if(b[f[l].y]==0)sum--;
    l++;
}
int main()
{
    scanf("%d%d",&n,&N);
    for(int i=1;i<=N;i++){
        scanf("%d",&m);
        for(int j=1;j<=m;j++){
            l++;
            scanf("%d",&a[l].x);
            a[l].y=i;
        }
    }
    sort(a+1,a+n+1,cmp);
    l=1;r=0;ans=1e9;
    for(int i=1;i<=n;i++){
        in(a[i]);
        while(sum==N){//sum就是当前队列里有多少总类 
            ans=min(ans,f[r].x-f[l].x);
            out();
        }
    }
    printf("%d",ans);
}
```

---

## 作者：Edward_Elric (赞：3)

### 思路

我觉得很莫名其妙，为什么这道题是单调队列？还在试炼场。只是具有单调性，希望同学们别想复杂了

就一个**two-pointer**；

先按位置排序，然后直接上双指针即可

标志是:一个指针向一个方向动，另一个指针也只会单向移动。

虽然很显然，还是给个证明：反证法即可

设l1,r1,l2,r2为两个满足条件的最小区间且l1<l2,r2>r1。

那么显然l1与r2可以再组成一个最小区间，矛盾


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000000+100;
int vis[60+5];
struct node{
	int c,p;
	bool operator <(const node &rhs){
		return p<rhs.p;
	}
}a[maxn];
int n,k,t,cnt,ans=INT_MAX;
int main(){
	ios::sync_with_stdio(false);
    cin>>n>>k;
	for(int i=1;i<=k;++i){
		cin>>t;
		for(int j=1;j<=t;++j)
			a[++cnt].c=i,cin>>a[cnt].p;
    }
    sort(a+1,a+1+n);
    int l=1,r=0;
    cnt=0;
    while(r<n){
    	if(!vis[a[++r].c])++cnt;
    	vis[a[r].c]++;
		if(cnt==k){
			while(vis[a[l].c]!=1)vis[a[l++].c]--;
			if(ans>a[r].p-a[l].p)ans=a[r].p-a[l].p;
			vis[a[l++].c]--,cnt--;
		} 
	}
	cout<<ans<<endl;
	return 0;
}



```

---

## 作者：laduiw (赞：3)

此题不需要考虑x轴坐标，只需考虑珠子，思路都差不多，都是枚举最左边的珠子，

然后向右延伸直到珠子种类数达到k，达到k之后再将左端点右移，再达到k种，更新

最小值，大家没有用STL的，我就发一波。


```cpp
#include<bits/stdc++.h>
using namespace std;
struct cc{
    int kind,p;
};
const int maxn=1000010;
cc a[maxn];
int zhong[70],ans=0x7fffffff,m,n,l=0,k,sum=0;
bool cmp(cc x,cc y)
{
    return x.p<y.p;
}
int main()
{
    scanf("%d %d",&n,&k);
    for (int i=1;i<=k;i++) 
        {
            scanf("%d",&m);
            for (int j=1;j<=m;j++)
            {
                int pa;
                scanf("%d",&pa);
                a[++l].p=pa;a[l].kind=i;
            }    
        }
//预处理珠子
    sort(a+1,a+n+1,cmp);//从小到大排序
    queue <cc> q;//开个队列
    for (int i=1;i<=n;i++)//枚举左端点
    {
        q.push(a[i]);//进队
        zhong[a[i].kind]++;
        if (zhong[a[i].kind]==1) sum++;
        while (sum==k)
        {
            cc e=q.back(),s=q.front();
            if (ans>e.p-s.p) ans=e.p-s.p;//更新
            q.pop();
            zhong[s.kind]--;
            if (zhong[s.kind]==0) sum--;
        }
    }
    cout<<ans<<endl;
}
```

---

## 作者：dunko (赞：2)

## 题目

[链接](<https://www.luogu.com.cn/problem/P2564>)

这题虽然是单调队列，但我并没有用它。


## 思路

之前被Akarui抓去做codechef时有一道转换一下后和这题有点像的题，就这样做掉了。

考虑要包含所有种类的珍珠，我们可以将每一种珍珠在哪些位置处理出来。只要每一种珍珠都有至少取一个位置就符合要求了。

这一条彩带的长度就是我们从每一种珍珠中取出的位置中的**最大值与最小值的差**。

考虑将**每一种珍珠看成一行**，这一行的数字就是这种珍珠出现的那些位置。

题目就是要你求出在每一行中取出一个数，这些数中的**最大值与最小值的差**的最小值。

是不是看到这就想明白了呀？ 那继续。

将每一行的数**从小到大排序**，每一行都有一个指针，初始时指着第一个数

找到每一行指针指的数中的最小值、最大值和最小值这一行。

更新一下答案，再将最小值这一行的指针向后移一位。最小值改变。

 正确性显然。

复杂度$O(n log_2 n+n )$?（感觉很少被卡满，还有排序这里应该不到$O(n log_2 n)$）

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+7,maxk=66,inf=(1ll<<31)-1;
inline int read(){
	int x=0,f=1;char C=getchar();
	while(!isdigit(C)) {if(C=='-') f=-1;C=getchar();}
	while(isdigit(C)) x=(x<<1)+(x<<3)+C-'0',C=getchar();
	return x*f;
}
int n,k,len[maxk],p[maxn],ans;
vector<int> a[maxk];
int main(){
	n=read(),k=read();
	for(int i=1;i<=k;i++){
		len[i]=read();
		for(int j=1,x;j<=len[i];j++)
		  x=read(),a[i].push_back(x);
		sort(a[i].begin(),a[i].end());
	} ans=inf;
	while(1){
		int Max=0,Min=inf,k1,k2;
		for(int i=1;i<=k;i++){
			if(a[i][p[i]]>Max) Max=a[i][p[i]],k1=i;
			if(a[i][p[i]]<Min) Min=a[i][p[i]],k2=i;
		}
		ans=min(ans,Max-Min);
		p[k2]++;
		if(p[k2]==len[k2]) break;//这时再往后移最小值不会变，直接结束
	}
	printf("%d\n",ans);
	return 0;
}
```

简单吧！对吧！（著名$Venus$在指导蒟蒻时常说的话）

解释一下我为什么没一遍A，因为我$Min$这里初始化的$inf$不够大。。。（直接2147483647)

---

## 作者：ueettttuj (赞：2)

**单调队列**

[题目](https://www.luogu.org/problem/P2564)

将珠子按位置从小到大排序，依次扫过每一颗珠子。如果该珠子的颜色与单调队列头部的珠子颜色不同，将其塞入单调队列末尾，$tail++$ 。如果颜色相同，则将头部珠子去掉$head++$ 。 如果加入某颗珠子后所有颜色的珠子都有了，则更新答案。**注意细节**

代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k;
struct node{
	long long val,pos;
};
node a[1000010];
struct data{
	long long poss,col;
};
data q[1000010];
long long vis[70];        //统计每种颜色的珠子在单调队列中的数量 
long long head,tail;
bool cmp(const node &qw,const node &we){
	return qw.pos<we.pos;
}
int main(){
	//freopen("data.in","r",stdin);
	//freopen("my.out","w",stdout);
	scanf("%lld %lld",&n,&k);
	long long num;
	long long las=0;
	for(long long i=1;i<=k;i++){
		scanf("%lld",&num);
		for(long long j=1;j<=num;j++){
			scanf("%lld",&a[las+j].pos);
			a[las+j].val=i;
		}
		las+=num;             //读入 
	}
	sort(a+1,a+las+1,cmp);
	head=1;
	tail=0;
	long long ans=10000000000;
	for(long long i=1;i<=las;i++){
		vis[a[i].val]++;
		q[++tail].poss=a[i].pos;
		q[tail].col=a[i].val;
		while(head<=tail && vis[q[head].col]>1) vis[q[head].col]--,head++; //判断单调队列头部珠子是否删去 
		bool s=0;
		for(long long j=1;j<=k;j++)
			if(!vis[j]){
				s=1;
				break;
			}
		if(s==0){
			if(ans>q[tail].poss-q[head].poss) ans=q[tail].poss-q[head].poss;  //更新答案 
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

[双倍经验？？？！！！](https://www.luogu.org/problem/P1638)

---

## 作者：LJB00131 (赞：1)

从试炼场看到这题，点进来一看，哇好清真。

切完题后点进题解，看看有没有其他好思路。看到一个“区间伸缩”，然后看了看他的写法，发现比较神奇，又发现我的思路和他的差不多。就来写一篇题解补充和完善一下他的题解。

首先看到这道题，可以发现一个很好用的性质。对于选定一个区间$(l ,r)$, 当有一个它后面的区间也可以成为答案时，区间右段点单调不降。证明显然。然后就可以用一个双指针切了这题。

输入的时候发现：欸这个位置怎么到$2^{31}$次方啊。淦，离散化吧。

然后完成了这么一份代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define N 1000005
#define K 65

int n, k, a[N][K], pos[K][N], b[N], num = 0, h[K];

bool check()
{
	for(int i = 1; i <= k; i++) if(!h[i]) return 0;
	return 1;
}

int main()
{
	scanf("%d%d", &n, &k);
	for(int i = 1; i <= k; i++)
	{
		scanf("%d", &pos[i][0]);
		for(int j = 1; j <= pos[i][0]; j++)
		{
			scanf("%d", &pos[i][j]);
			b[++num] = pos[i][j];
		}
	}
	sort(b + 1, b + num + 1);
	num = unique(b + 1, b + num + 1) - b - 1;
	for(int i = 1; i <= k; i++)
	{
		for(int j = 1; j <= pos[i][0]; j++)
		{
			int x = lower_bound(b + 1, b + num + 1, pos[i][j]) - b;
			a[x][i] = 1;
		}
	}
	int r = 0, ans = INT_MAX;
	for(int l = 1; l <= num; l++)
	{
		for(int j = 1; j <= k; j++) h[j] -= a[l - 1][j];
		while(!check() && r < num)
		{
			r++;
			for(int j = 1; j <= k; j++) h[j] += a[r][j];
		}
		// cout << l << ' ' << r << endl;
		if(check()) ans = min(ans, b[r] - b[l]);
	}
	cout << ans << endl;
	return 0;
}
```
一交，欸他怎么MLE了。

赶紧改一发vector， 改完一交，欸他怎么TLE了。开个O2，终于过了。

最后附上AC代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define N 1000005
#define K 61

int n, k, b[N], num = 0, h[K], T[K];

vector <int> pos[K];
vector <int> a[N];

bool check()
{
	for(int i = 1; i <= k; i++) if(!h[i]) return 0;
	return 1;
}

int main()
{
	scanf("%d%d", &n, &k);
	for(int i = 1; i <= k; i++)
	{
		scanf("%d", &T[i]);
		for(int j = 1; j <= T[i]; j++)
		{
			int x;
			scanf("%d", &x);
			pos[i].push_back(x);
			b[++num] = x;
		}
	}
	sort(b + 1, b + num + 1);
	num = unique(b + 1, b + num + 1) - b - 1;
	for(int i = 1; i <= k; i++)
	{
		for(int j = 0; j < T[i]; j++)
		{
			// cout << j << endl;
			int x = lower_bound(b + 1, b + num + 1, pos[i][j]) - b;
			a[x].push_back(i);
		}
	}
	int r = 0, ans = INT_MAX;
	for(int l = 1; l <= num; l++)
	{
		for(int j = 0; j < a[l - 1].size(); j++) 
		{
			h[a[l - 1][j]]--;
		}
		while(!check() && r < num)
		{
			r++;
			for(int j = 0; j < a[r].size(); j++) h[a[r][j]]++;
		}
		if(check()) ans = min(ans, b[r] - b[l]);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：LightningUZ (赞：1)

### 题意简述
给定$n$($<=1e6$)个珠子，分为$k$个种类。接下来$k$行每行一个$t_i$（保证$t_i$的和$=n$），表示这种珠子有$t_i$个。然后是$t_i$个非负整数，表示这种珠子出现的位置（位置$<=1e9$）。
请你找一段区间，使得它包含所有类型的珠子并且长度最小。
### 数据
输入：    
6 3    
1 5    
2 1 7    
3 1 3 8    
输出：    
3
##### 解释：
![blog1.png](https://i.loli.net/2019/04/16/5cb596a28b358.png)
红色：第一类
蓝色：第二类
绿色：第三类
有多种方案可选，其中比较短的是1~ 5和5 ~8。后者长度为3最短。

### 思路
woc珠子位置怎么这么大。。。所以这告诉我们要打一个结构体存下所有珠子，然后按位置进行一次排序。
然后才进行暴力。枚举一个$l$，表示我们现在考虑的珠子是排序后的第$l$个。然后我们找一个$r$（$O(n)$暴力找），使得从$l$到$r$之间包含所有类型的珠子，然后取一下最小值保存到$ans$。
这是$O(n^2)$的。但是，我们会发现。。。

每次$l$往右移的时候，珠子是不会更多的，只会少。也就是说我们的$r$不会比上一次的$r$小，即$r$也是单调非降的。这个r好像是单调非降的，不如我们把它。。。~~吃了~~ 记录下来，然后每次不断右移判断是否满足条件。

但现在问题来了，我们如何记录$l++$之后的剩余元素情况以及元素个数呢？
开一个$cnt$数组，$cnt[i]$记录种类$i$**出现了几次**，还有一个$total$记录**有多少元素**。    
然后$l++$的时候，先把$l$这个珠子上的$cnt--$，然后如果$cnt==0$，那么说明这个珠子没了，就要把$total$也$--$。记录完之后再$l++$。
$r++$的时候类似，不过顺序不一样，是先$r++$，然后记录。（想想为什么）。

代码：
```cpp
#include<bits/stdc++.h>
#define N 1001000
#define K 61
using namespace std;

struct node//珠子
{
    int type,pos;
    const bool operator<(const node CompWith) const//按位置排序
    {
        return pos<CompWith.pos;
    }
}pearl[N];
int n,k;
int R;
void Input()
{
    scanf("%d%d",&n,&k);
    int p_pearl=0;//记录是总共多少个，由题意，到最后这个p_pearl应该=n
    for(int i=1;i<=k;i++)
    {
        int t;scanf("%d",&t);
        while(t--)
        {
            int pos;
            scanf("%d",&pos);
            pearl[++p_pearl]=(node){i,pos};
            R=max(R,pos);//一开始想用的，后来发现没用。。。请忽略它。。。
        }
    }


}

int cnt[K],total;
void Solve()
{
    memset(cnt,0,sizeof(cnt));
    total=0;
    sort(pearl+1,pearl+n+1);//不排序见比利了。。。

    int l=1,r=0;//调了好久才发现这个问题。。。
    while(r<=n and total<k)
    {
        ++r;//r先加
        //原因是l++的时候我们是要删除的是l，然后l++。在r++的时候，我们是要加入r+1,然后r++。所以还不如先r++然后处理，否则下面就要写成
        /*
        ++cnt[pearl[r+1].type];
        if (cnt[pearl[r+1].type]==1)
        {
            ++total;
        }
        r++;
        */
        //多麻烦。。。
        ++cnt[pearl[r].type];
        if (cnt[pearl[r].type]==1)//说明r的这个种类是第一次出现，所以total++
        {
            ++total;
        }//再记录
    }

    int ans=pearl[r].pos-pearl[l].pos;
    while(l<=n and r<=n)
    {
        ans=min(ans,pearl[r].pos-pearl[l].pos);//注意:不用+1，因为题目中说5和8的距离是3。。。

        cnt[pearl[l].type]--;
        if (cnt[pearl[l].type]==0)
        {
            total--;
        }//先删除
        l++;//再l++

        while(total<k and r<=n)
        {
            ++r;//先++r(++r和r++虽然有区别，但是在这里是一样的，先写++还是先写r按心情。。。)
            cnt[pearl[r].type]++;
            if (cnt[pearl[r].type]==1)
            {
                total++;
            }//然后记录
        }
        if (r==n+1) break;//防爆
    }
    printf("%d\n",ans);
}
main()
{
    Input();
    Solve();
    return 0;
}
```
格式没爆，完美

---

## 作者：Sino_E (赞：1)

实际上就排了个序...\_(:зゝ∠)_

珠子输入后按位置从小到大排序。然后右端点从左到右枚举，维护一下左端点就行了。

这里的左右端点是指珠子数组里的左右端点，同时也符合实际坐标里的左右端点。

具体来说，维护每种珠子最后出现的位置（一开始是-1）。若左端点的珠子已经在后面出现过，则左端点++。

然后如果所有的珠子都已经出现过了，则左端点更改之后更新答案。

复杂度$O(n\ log\ n)$ \_(:зゝ∠)_ 常数较小

代码如下：

```cpp
// Code by ajcxsu
// Problem: P2564
#include<bits/stdc++.h>
#define rint register int
using namespace std;

const int N=1e6+10;
const int K=61;
int pos[K];
struct Jewel {
    int t,p;
} je[N];
int p;

inline bool cmp(const Jewel &a, const Jewel &b) {
    return a.t<b.t;
}

inline void gn(int &x) {
    x=0;
    register char ch=getchar();
    while(ch<'0' || ch>'9') ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0', ch=getchar();
}

int main() {
    memset(pos,-1,sizeof(pos));
    int n,k;
    int ans=0x3f3f3f3f;
    gn(n), gn(k);
    int ti;
    for(int i=0;i<k;i++) {
        gn(ti);
        for(rint j=0;j<ti;j++)
            gn(je[p].t), je[p++].p=i;
    }
    sort(je,je+p,cmp);
    
    int l,r,cnt=0;
    l=0;
    for(int i=0;i<n;i++) {
        if(pos[je[i].p]==-1) cnt++;
        pos[je[i].p]=je[i].t;
        while(l!=i && je[l].t<pos[je[l].p]) l++;
        if(cnt==k && ans>je[i].t-je[l].t) ans=je[i].t-je[l].t;
    }
    
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Reaepita (赞：1)

此题难度应该为 **普及/提高-**

显然我们观察数据范围可以发现珠子的种类最多只有 $60$ 种，那为什么不能直接暴力枚举

我们用 $pos[i]$ 表示 $i$ 种珠子当前最靠右的出现位置

将每个珠子用结构体存一下直接按照位置排序

暴力扫一遍就行了。

时间复杂度 $O(nk)$ ，稳过

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1e6+10;
const long long inf=1LL<<50;
struct item
{
	int col,pos;
	bool operator < (const item &b)const 
	{
		return pos<b.pos;
	}
}p[maxn];
int top=0;
int pos[61],n,m;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int k;
		scanf("%d",&k);
		for(int j=1;j<=k;j++)++top,scanf("%d",&p[top].pos),p[top].col=i;
	}
	sort(p+1,p+1+n);
	long long ans=inf;
	for(int i=1;i<=n;i++)
	{
		long long Min=inf;
		pos[p[i].col]=p[i].pos;
		for(int j=1;j<=m;j++)Min=min(Min,pos[j]*1LL);
		if(Min==0)continue;
		ans=min(ans,p[i].pos*1LL-Min);
	}
	printf("%lld\n",ans);
}
```



---

## 作者：Polaris_Dane (赞：0)

很明显，对于固定的$l$，$r$越大越可能成立

这符合单调性，对于符合条件的某个$r$，将左端点一直移动到刚好符合条件一定最优

直接双指针，注意一次删除要删除所有位置相同的彩珠

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<set>
#include<queue>
#define M 2000100
#define inf 2e9
#define LL long long
#define ull unsigned long long
const int mod=998244353;
const int base=137;
const int maxval=200000;
using namespace std;
inline int read(){
	int f=1,x=0;char s=getchar();
	while (!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while (isdigit(s)){x=(x<<1)+(x<<3)+(s^48),s=getchar();}
	return x*f;
}
int n,k,tot,cnt[100],ans=inf,cnte;
struct node{
	int pos,val;
	bool operator <(const node&a)const{
		return pos<a.pos;
	}
}st[M];
inline void add(int x){
	if (!cnt[x]) tot++;cnt[x]++;
}
inline void dele(int x){
	if (cnt[x]==1) tot--;cnt[x]--;	
}
signed main(void){
	n=read(),k=read();
	for (int i=1;i<=k;i++){
		int x=read();
		for (int j=1;j<=x;j++) st[++cnte].pos=read(),st[cnte].val=i;
	}int l=1,r=0;sort(st+1,st+n+1);
	while (r<n){
		r++,add(st[r].val);
		while (tot==k){
			ans=min(ans,st[r].pos-st[l].pos);
			dele(st[l].val),l++;
			while (st[l-1].pos==st[l].pos) dele(st[l].val),l++;
		}
	}printf("%d",ans);
	return 0;
}

```


---

## 作者：cultry (赞：0)

发现没有和我的想法相同的题解（主要是我思路僵化想到的方法不太正常）

### 算法流程

Step 1

选择一种个数最少的颜色，枚举其中每一枚珠子，假定方案包含该枚珠子并进行下列算法。 

解释：合法的答案必须包含所有颜色的珠子，所以通过指定一种颜色枚举每一种选择就可以保证包括最优方案。

Step 2

对于剩余的每一种颜色，用二分分别找出坐标位于指定珠子左边和右边离它最近的珠子，计算出距离（当然如果重合的话就是0，不存在的话记为无穷）。

解释：容易验证，对于在指定珠子同侧的同色珠子，选择离它更近的珠子更优。

Step 3

把上一步中的珠子分成左边和右边两组，分别按距离从大到小、从小到大排序，把他们拼在一起。刚开始全部选左边的点，丝带长度为最大距离。然后向右拓展，更新长度（长度即右边最大距离+左边最大距离）每拓展一个点就检查是否可以删除左边的点（即在最左端且已经在右边出现）。

解释：其实这里就相当于大多数题解中的双指针。

### 时间复杂度 O(n log n)

由平均值原理知道，最少的那种颜色不多于n/k种，而二分的复杂度是log n，双指针的复杂度为K。当然常数比正常做法稍微大一些。


### 代码

```
#include<iostream>
#include<algorithm>
using namespace std;
int n,k;
int l[100],r[100];
long long p[1000010];
int mn=9999999,flag;
long long bl[100],ab[100];
long long ans;
long long inf=1;
int vis[100],stack1[200],stack2[200],top1,top2;
bool cmp1(int a,int b)
{
	return bl[a]<bl[b];
}
bool cmp2(int a,int b)
{
	return ab[a]<ab[b];
}
int main()
{
	inf=inf<<33;
	ans=inf;
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	{
		int t;
		cin>>t;
		l[i]=r[i-1]+1;
		r[i]=l[i]+t-1;
		for(int j=l[i];j<=r[i];j++)
			cin>>p[j];
		if(t<mn) {mn=t;flag=i;}//指定珠子
	}
	for(int i=l[flag];i<=r[flag];i++)
	{
		for(int j=1;j<=k;j++)
		{
			if(j==flag) continue;
			int ll,rr,mid;
			ll=l[j];
			rr=r[j]+1;
			while(ll<rr)//二分
			{
				mid=(ll+rr)/2;
				if(p[mid]<=p[i])
					ll=mid+1;
				else rr=mid;
			}
			//cout<<ll<<' '<<rr<<' ';
			if(rr>r[j]) ab[j]=inf;
			else ab[j]=p[rr]-p[i];
			if(rr==l[j]) bl[j]=inf;
			else bl[j]=p[i]-p[rr-1];
			//cout<<bl[j]<<' '<<ab[j]<<endl;
		}
		top1=0;
		for(int j=1;j<=k;j++)
			if(j!=flag) stack1[++top1]=j;
		sort(stack1+1,stack1+top1+1,cmp1);
		top2=0;
		for(int j=1;j<=k;j++)
			if(j!=flag) stack2[++top2]=j;
		sort(stack2+1,stack2+top2+1,cmp2);
		long long tmp=0;
		tmp=bl[stack1[top1]];
		ans=min(ans,tmp);
		for(int j=1;j<=k;j++) vis[j]=0;
		for(int j=1;j<=top2;j++)//双指针，我这里写的比较怪异因为写的时候比较困
		{
			tmp=tmp+ab[stack2[j]]-ab[stack2[j-1]];
			//cout<<ab[stack2[j]]<<' '<<ab[stack2[j-1]]<<endl;
			vis[stack2[j]]=1;
			while(vis[stack1[top1]]&&top1>0)
			{
				tmp=tmp-bl[stack1[top1]]+bl[stack1[top1-1]];
				//cout<<bl[stack1[top1]]<<' '<<bl[stack1[top1-1]]<<endl;
				top1--;
			}
			ans=min(ans,tmp);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Rintaro (赞：0)

在lyd的书看到的习题  
思路和“锅钢Carl”基本一样
细节上有些不一样，所以发篇题解  
	先选上每种珠子的最小值，由于数据已从小到大排序，那么此时让最大值变得更大一定不优，那么我们可以让最小值变得大一些，也就是让最小数变成下一个  
   我们可以用一个小根堆来维护集合中的最小值  
	此时用所选珠子坐标集合中的最大值减最小值更新答案  
	注意到最大值一定单调递增，并且只有每次入堆时才可能更新最大值，所以只要维护一个变量打擂台即可，无需再维护大根堆  
   并且如果最小值无法变得更大了，那么此时让其他值变得更大一定不优，所以直接退出循环输出答案即可  
```cpp
#include <iostream>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <queue>

#define readint(x) scanf("%d",&(x))
#define rint register int
#define putint(x) printf("%d",(x))
#define lol long long

using namespace std;
int n, m;
vector<int> ma[62];
int nmax = 0;
int ans = INT_MAX;

struct num{
	int id , pos, val;
	num(){}
	num(int _id, int _pos): id(_id), pos(_pos) {
		val = ma[id][pos];
	}
	int nxt(){
		if(pos + 1 < ma[id].size()) return (val = ma[id][++pos]);
		else return 0;
	}
	bool operator < (const num& b) const{
		return val > b.val;
	}
};

priority_queue<num> q; 

int main(){
//	freopen("testdata.in","r",stdin);
	int mm , temp;
	readint(n), readint(m);
	for(rint i=1; i<=m; i++){
		readint(mm);
		for(rint j=0; j<mm; j++){
			readint(temp);
			ma[i].push_back(temp);
		}
	}
	for(rint i=1; i<=m; i++){
		q.push(num(i,0));
		nmax = max(nmax,ma[i][0]);
	}
	while(!q.empty()){
		num now = q.top();
		q.pop();
		ans = min(ans,nmax - now.val);
		if(now.nxt()){
			q.push(now);
			nmax = max(nmax,now.val);
		}
		else break;
	}
	putint(ans);
	return 0;
}

```



---

## 作者：Adove (赞：0)

刚做这道题的时候想到了二分答案

没错就是二分答案

复杂度特别高的二分答案+队列

3000ms（我当时还诧异这题数据这么大常数一炸不就完了吗

后来发现是自己傻了

既然优秀的做法dalao们都讲过了

我就把这个扔上去吧

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1e6+5;

int n,k;
int cnt[65];
int q[MAXN];
struct rpg{
	int x,v;
}a[MAXN];

inline int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||'9'<ch) ch=getchar();
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	return x;
}

bool cmp(rpg a,rpg b){return a.x<b.x;}

bool check(int L)
{
	memset(cnt,0,sizeof(cnt));
	int hd=1,tl=0;cnt[0]=k;
	for(int i=1;i<=n;++i){
		q[++tl]=i;
		if(!cnt[a[i].v]) --cnt[0];
		++cnt[a[i].v];
		while(a[i].x-a[q[hd]].x>L){
			--cnt[a[q[hd]].v];
			if(!cnt[a[q[hd]].v]) ++cnt[0];
			++hd;
		}if(!cnt[0]) return 1;
	}return 0;
}

int main()
{
	n=read();k=read();
	for(int i=1;i<=k;++i){
		int T=read();
		while(T--) a[++a[0].x]=(rpg){read(),i};
	}sort(a+1,a+a[0].x+1,cmp);
	int l=1,r=a[a[0].x].x;
	while(l<r){
		int mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}printf("%d\n",l);
	return 0;
}
```

---

## 作者：vgccyaj (赞：0)

需要将所有彩珠的位置从小到大排序；

枚举一个位置x，需要快速知道每种彩珠≤x的位置，这个需要将每种彩珠出现的位置按从大到小的顺序存在链表中；

一个优化：因为从大到小枚举x，所以可以将每种彩珠位置所在的链表中位置>x的节点都删除



附上代码


```cpp
#include <iostream>
using namespace std;
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <memory.h>
#include <cstdlib>
const int N=1000005;
const int oo=2147483647;
typedef long long LL;
inline void get(int &x){char c=getchar();x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return ;
}
int n,k;
struct node{
    LL x;
    int id;
    bool operator < (const node& y) const{
        return x<y.x;
        }
    }p[N];
int len=0;
int a[N];
LL ans=0;
int maxm=0,minm=oo;
int main(){
    get(n);get(k);
    int i,j,x;
    for(i=1;i<=k;i++){
        int t;
        get(t);
        for(j=1;j<=t;j++){
            get(x);
            p[++len].x=x;
            p[len].id=i;
            maxm=max(x,maxm);
            minm=min(x,minm);
            }
        }
    sort(p+1,p+n+1);
    j=x=0; ans=maxm-minm;
    memset(a,0,sizeof(a));
    for(i=1;i<=n;i++){
        while(j<n&&x<k){
            j++;
            if(!a[p[j].id]) x++;
            a[p[j].id]++;
            }
            if(x<k) break;
            ans=min(ans,p[j].x-p[i].x);
            a[p[i].id]--;
            if(!a[p[i].id]) x--;
        }
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：FendtSilence (赞：0)

这道题数据有毒啊，代码时时被卡，不禁让人感到绝望……

题意非常好理解，就是固定一个区间，使区间内的元素种类齐全，找出最小的区间，不禁使人想到题目”uva11572唯一的雪花“使用的滑动窗口法，即使用一个不定长的滑动窗口，左右端点再右移的过程中不断更新ans的最小值。

再来说说数据的存储，看了看这个有毒的读入方式，本来我是想使用$map<int,vector<int> >$这种操作的，但是后来发现珠子只有$1e6$个，所以对于整个题目我们只用存储每个珠子的位置和颜色就可以了，存储完之后按位置排一下序，直接进入算法即可。

这个题的数据卡细节，$if()$和$while()$里的条件要控制好。

献上代码

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
using namespace std;
const int maxn=1000001;
struct zhuzi
{
    long long int pos,color;
}a[maxn];
bool cmp(const zhuzi &a,const zhuzi &b)
{
    return a.pos<b.pos;
}
long long int n,m,k,no,x,cnt,now=1,ans=999999999;
int vis[maxn];
void init()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>no;
        while(no--)
        {
        cin>>x;
        a[++cnt].pos=x;
        a[cnt].color=i;    
        }
    }
    sort(a+1,a+1+n,cmp);
}
void in_solve1()
{
    for(int l=1,r=0;l<=n;l++)
    {
        vis[a[l-1].color]--;
        if(vis[a[l-1].color]<=0) now--;
        while(now<m&&r<=n)
        {
            r++;
            if(!vis[a[r].color]) now++;
            vis[a[r].color]++; 
        }
        if(now==m) ans=min(ans,a[r].pos-a[l].pos);
    }
    cout<<ans;
}
void solve()
{
    init();
    in_solve1();
}
int main()
{
    solve();
    return 0;
}
```

---

## 作者：Tgotp (赞：0)

单调队列


其实就是维护序列的左右端点。


现将所有的珠子按照位置排序，然后考虑每次让左端点后移，右端点也后移直到恰好有k种颜色为止，更新答案。


维护左右端点，对于左端点，一直枚举，对于右端点，直到size == k || cnt == r，因为l向右size只可能减少，所以r一定只会向右移动。解决

c++代码如下：




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rep(i,x,y) for(register int i = x;i <= y;++i)
using namespace std;
inline void read(int& x){
    int sign =1;x = 0;char c;
    for(c=getchar();(c < '0' || c > '9') && c != '-';c = getchar());
    if(c == '-') sign = -1;else x = c - '0';
    for(c=getchar();c <= '9' && c >= '0';x = x*10 + c - '0',c = getchar());
    x = x*sign;
}
const int N = 1e6 + 50;
int n,k,ti,cnt,size,vis[63];
struct str
{
    int pos,color;
}a[N];
const bool cmp(str a,str b){ return a.pos < b.pos; }
void change(int x,int v)
{
    if(v == 1 && !vis[a[x].color]) ++size;
    if(v == -1 && vis[a[x].color] == 1) --size;
    vis[a[x].color] += v;
}
int main()
{
    read(n);read(k);
    rep(i,1,k)
    {
        read(ti);
        rep(j,1,ti)
        {
            int x;read(x);
            a[++cnt].pos = x;a[cnt].color = i;
        }
    }
    sort(a+1,a+1+cnt,cmp);
    int l = 1,r = 1;change(1,1);
    int ans = a[cnt].pos;
    while(l<=r)
    {
        while(size < k && r < cnt)change(++r,1);
        if(size == k) ans = min(ans,a[r].pos - a[l].pos);
        change(l++,-1);
    }
    printf("%d\n",ans);
    return 0;
}
BLOG:Tgotp.science
```

---

## 作者：jzqjzq (赞：0)

区间伸缩大法好！！！

先预处理每个珠子的颜色，坐标，按照坐标从小到大排序，维护一个队列（区间伸缩），记录最小值

这东西速度还一般（1956ms）在bzoj里好像又慢了点

详见代码：

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
struct rppr{
    int a,b;
}a[1000001];int jzq[1000001]={0};//jzq数组记录每种颜色的珠子在队列里有几个
rppr q[1000001];//队列
bool cmp(rppr a,rppr b){
    return a.b<b.b;
}
int main()
{
    int n,m;scanf("%d%d",&n,&m);
    int ans=0x7fffffff,k=0;
    for(int i=1;i<=m;i++){
        int x;scanf("%d",&x);
        for(int j=1;j<=x;j++){
            int y;scanf("%d",&y);
            k++;a[k].a=i;a[k].b=y;//预处理珠子
        }
    }
    sort(a+1,a+n+1,cmp);//按坐标从小到大排序
    int l=1,r=1,sum=1,i=1;q[1]=a[1];jzq[a[1].a]++;//预处理队列，将第一个珠子入队
    while(l<=r){
        if(sum==m&&q[r].b-q[l].b<ans)ans=q[r].b-q[l].b;//队列中颜色已有m种记录最小值
        if(sum==m||sum<m&&i==n){
            jzq[q[l].a]--;if(jzq[q[l].a]==0)sum--;//队列中颜色已有m种时左端点向右收缩（或者珠子取完时）
            l++;//出队
        }else{
            i++;
            if(jzq[a[i].a]==0)sum++;jzq[a[i].a]++;//队列中颜色未到达m种时右端点向右伸展找珠子（这就是区间伸缩）
            r++;q[r]=a[i];//入队
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：lwhllw (赞：0)

因为给的珠子是升序，并且每种都要选到。

只要维护一个选取当前种类的第x的珠子的数组，和最大最小值就行。

答案就是 最大减去最小

代码如下




```cpp
program searc;
const maxn=1000001;
      maxt=61;
var max,min,ans,i,t,j,k,l,m,n:longint;
    a:array[1..maxt,1..5*maxt]of longint;
    tail,tot:array[1..maxn]of longint;
procedure init;
begin
    readln(n,m);min:=maxn;
    for i:=1 to m do
    begin
      read(tot[i]);
      if tot[i]=0 then
      begin
        writeln(0);
        halt;
      end;
      for j:=1 to tot[i] do read(a[i,j]);
      readln;tail[i]:=1;
      if a[i,tail[i]]>max then max:=a[i,tail[i]];
      if a[i,tail[i]]<min then min:=a[i,tail[i]];
    end;
end;
procedure solve;
var i,j,k:longint;
    nmax,nmin:longint;
    toend,toup:longint;
    tf:boolean;
begin
    ans:=max-min;toend:=m;
    while toend<n do
    begin
      nmin:=maxlongint;tf:=false;
      nmax:=max;toup:=0;
      for i:=1 to m do
        if(min=a[i,tail[i]])then
        begin
          if tot[i]=tail[i] then
          begin
            tf:=true;
            break;
          end;
          inc(tail[i]);inc(toup);
          if nmax<a[i,tail[i]] then nmax:=a[i,tail[i]];
          if nmin>a[i,tail[i]] then nmin:=a[i,tail[i]];
        end
        else
        if a[i,tail[i]]<nmin then nmin:=a[i,tail[i]];
      if tf then break;
      if nmin<>maxlongint then min:=nmin;
      max:=nmax;inc(toend,toup);
      if max-min< ans then ans:=max-min;
    end;
    writeln(ans);
end;
begin
    init;
    solve;
end.

```

---

## 作者：Ofnoname (赞：0)

不得不说，此题有蓝题的难度。但是与另一道黄题[**P1638** 逛画展](https://www.luogu.org/problemnew/show/P1638)几乎有一模一样的思想。

[我写的那道题的题解](https://www.luogu.org/blog/ofnoname/solution-p1638)

当然，这道题的难点与新奇的地方就是他用坐标表示位置，坐标范围极大。所以我就用结构体顺序存储每一个珠子的位置和种类。

之后，把珠子按位置排序，从前往后用尺取法扫描，如果左边界的珠子之后出现过就把左边界右移。每次更新答案。判断之后是否出现过的方法有许多种，我使用桶保存每一种珠子的出现次数。

```cpp
#include <bits/stdc++.h>
#define MAX (1000000+50)
using namespace std;

struct node{
    int x,y;
}d[MAX];

int N,K,cnt,C,L=1,ans=0x7fffffff,T[61];
inline bool cmp(node a,node b)
{
    if (a.x!=b.x)
        return a.x<b.x;
    return a.y<b.y;
}

inline void read(int &a)
{
    register char c=getchar(); 
    for (a=0; c<'0'||'9'<c; c=getchar());
    for (; '0'<=c && c<='9'; c=getchar())
        a=(a<<3)+(a<<1)+(c^48);
}

int main()
{
    read(N); read(K);
    for (register int i=1,x=0,y=0; i<=K; i++)
    {
        read(x);//颜色编号为i的珠子
        while (x--)
        {
            read(y);
            d[++cnt]=(node){y,i};//加一个位置为y，种类为i的珠子
        }
    }
    sort(d+1,d+cnt+1,cmp);//排序
    for (register int i=1; i<=cnt; i++)
    {
        T[d[i].y]++;
        if (T[d[i].y]==1) C++;//C统计一共有多少种类的珠子
        while (T[d[L].y]>1)//左边界的珠子在以后出现过
            T[d[L].y]--, L++;//左边界右移
        if (C==K)//已经集满K种珠子
            ans=min(ans,d[i].x-d[L].x);//更新答案
    }
    printf("%d",ans); return 0;
}
```



---


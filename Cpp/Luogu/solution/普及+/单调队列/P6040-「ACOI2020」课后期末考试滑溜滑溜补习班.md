# 「ACOI2020」课后期末考试滑溜滑溜补习班

## 题目背景

![T2](https://s2.ax1x.com/2020/01/12/lopS6f.png)

潮田 渚（Shiota Nagisa）因为理科不大好，自然会被仔细观察学生的杀老师发现，于是渚同学只得加入杀老师举办的课后期末考试滑溜滑溜补习班。至于为什么叫这个名字，额，你不能问我啊。

## 题目描述

在补习班上，因为多个学生会同时有需求，所以杀老师会制造分身用音速移动来回回答问题。

补习班上有 $n$ 个同学，他们每一个人都有一个问题。杀老师为了有序回答学生的问题，把所有学生排成了一列。第 $i$ 个学生的问题有一个困难值 $a_i$，杀老师回答第 $i$ 个学生的问题需要花费 $a_i$ 的精力。杀老师到了哪里，它就要解决那个学生的问题。杀老师最开始会解决序列中第一个同学的问题，他最后会去解决最后一个同学的问题。

杀老师每次解决完一个同学的问题到下一个同学的座位上就要花费 $k$ 点精力值。特殊的，如果杀老师想让自己轻松一点，可以不移动到下一个，可以直接到下两个，下三个，就不用解决跳过的同学的问题了。对应的，它会被学生调侃。受到打击的杀老师自然会花费格外的精力，花费的精力为 $k+(q-p-1) \times d$（当前位置为 $p$，跳到的位置为 $q$）。

当然的，杀老师也是有速度的啊，并且它想解决学生的一些问题，所以说杀老师最多只会跳过 $x-1$ 个学生，去解决下 $x$ 个学生的问题。

## 说明/提示

#### 样例解释 #1

杀老师每次不能跳过学生，因此他必须依次移动并解决所有问题，故答案为解决问题所需的精力 $1+2+3+4+5=15$ 与移动所需的精力 $4 \times 3=12$，所以花费精力之和为 $27$。

------------
#### 数据范围

**本题采用捆绑测试**。

- Subtask 1（20 points），学生们学习认真听话，留下来的同学也会更少：$tp=0$，$n \leq 10^3$。     
- Subtask 2（30 points），杀老师的速度快极了，并且学生们没时间吐槽它：$tp=0$，$n \leq 10^6$。     
- Subtask 3（50 points），$tp=1$，其余无特殊限制。

对于 $100\%$ 的数据，$1 \leq n \leq 10^7$，$0 \leq k,d,a_i \leq 10^9$，$1 \leq x \leq n-1$。

------------
#### 提示

对于 $tp=1$ 的数据，$rnd$ 函数只用于减小输入量，标准算法不依赖该数据生成方式。

## 样例 #1

### 输入

```
5 3 4 1 0
1 2 3 4 5
```

### 输出

```
27```

## 样例 #2

### 输入

```
10 30630 56910 2 0
7484 99194 86969 17540 29184 68691 91892 81564 93999 74280 
```

### 输出

```
717318```

## 样例 #3

### 输入

```
10000000 899999999 923456655 213111 1
1314520```

### 输出

```
9231813656566921```

# 题解

## 作者：FCBM71 (赞：16)

单调队列优化DP的板子题吖，很适合萌新上手     

## $20$ 分做法  

假设 $f[i]$ 表示杀老师**解决完**第 $i$ 个学生累计花费的最小精力。显然对于 $i=1$ 有 $f[1]=a[1]$。

对于其他的 $i$ 号学生，我们假设杀老师是从第 $j$ 号学生直接跳过来的，那么状态转移方程分为三项： $f[j] $ 表示从之前的累计值，$(i-j-1)\times d+k$ 是应对学生调侃和移动花费的精力，$a[i]$ 是解决当前学生问题花费的精力。
$$f[i]=f[j]+(i-j-1)\times d+k+a[i]$$ 
当然 $j$ 是有范围的，$i-x\leq j<i$。当 $j=i-1$ 时，实际情况就是杀老师没有跳过任何学生，是解决了上一个学生问题直接移动过来的的。  

对于每个 $f[i]$，只需要寻找最小的一个 $j$ 使得 $f[j]+(i-j-1)\times d$ 有最小值即可。最后输出 $f[n]$ 即可。时间复杂度 $O(n^2)$。

## $100$ 分做法

只需要做一点点改动就可以拿到满分了（巨大的跨越）。    
  
由状态转移方程知，可以影响 $f[i]$ 大小的只有 $f[j]$ 和他们的距离 $(i-j-1)$，因为 $k+a[i]$ 是个定值。

对于一个学生 $i$，假设最优策略是从 $j$ 号跳转到 $i$ 号，再任取一个不是最优的学生 $t$。那么对于学生 $i+1$，从 $j$ 跳转过来更优还是从 $t$ 跳转过来更优呢？答案一定是 $j$。因为从 $i$ 号位置改跳到 $i+1$ 位置只需要多花精力 $d$，二者都如此。原来 $j$ 更优，现在依然更优。  

这意味着，我们对于每个 $f]i]$ 向前寻找最优的 $j$ 时，不需要遍历整个 $[i-x,i-1]$，只需要取出我们之前记录的最优的 $j$。这里的所有 $j$ 就可以用一个单调队列来维护。  

每次得到 $f[i]$ 的流程就应该是
>1.弹出单调队列的过期元素（$j<i-x$）   
2.取出单调队列的第一个元素，得到 $f[i]$  
3.将 $(f[i],i)$ 打包放入单调队列中，并弹出  

弹出的条件是什么呢？并不是简单的 $f[j]\geq f[i]$ 才弹出。根据我们之前推出的性质，从 $j$ 跳转到某一个点 $x$，和从 $i$ 跳转到某一个点 $x$，从 $j$ 跳转一定会多花一个定值，即 $(i-j)\times d$ （注意这里**一定不要-1**）。所以弹出的条件就是 $f[j]\geq f[i]+(i-j)\times d$  

附上核心代码，仅供参考
```
	deque<pair<LL,int> >q; //不开LL见祖宗
    
	if(x==1){     //杀老师不能跳过时，需特判
		for(int i=1;i<=n;++i)f[n]+=a[i];
		cout<<f[n]+k*(LL)(n-1);
		return 0;
	}
	f[1]=a[1];
	q.push_back(make_pair(f[1],1));  //预处理
	for(int i=2;i<=n;++i){
		while(!q.empty()){
			if(q.front().second<i-x)q.pop_front();
			 else break;    //弹出过期元素
		}
		LL fx=q.front().first;int lx=q.front().second;
		f[i]=fx+k+d*(LL)(i-lx-1)+a[i];  //得到f[i]
		while(!q.empty()){
			LL fx=q.back().first;int lx=q.back().second;
			if(fx+d*(LL)(i-lx)>=f[i])q.pop_back();
			 else break;   //弹出
		}
		q.push_back(make_pair(f[i],i));  //压入当前元素
	}
	cout<<f[n];
```

---

## 作者：zhangyuhan (赞：8)

一道`单调队列+DP`的好题。
顺便让我来写个$STL$的题解。

这道题明显就是动态规划，但是用朴素方法是会$T$的。所以，这道题要分两步来分析。

## $STEP_1$ $DP$

设$f_i$ 为解决完第$i$个学生的问题后所耗费的最小精力。

易得方程：

$f_i = \min\{f_j+k+(i-j-1)*d+a_i\}$ ($i-x\leq j < i$)

初始化：$f_1=a_1$

目标：$f_n$

得到这些方程并不难，让我们来简析一下时间复杂度：

$i$循环要$O(n)$，$j$循环要$O(n)$，总共是$O(n^2)$

可过`subtask1`，得`20pts`

显然，我们需要优化，最少得省掉其中的一个循环。

## $STEP_2$ 单调队列优化

回顾一下上面的方程：

$f_i = \min\{f_j+k+(i-j-1)*d+a_i\}$

观察发现：$k,(i-1)*d,a_i$与求最小值无关。

我们可以将他们提出来：

$f_i=k+(i-1)*d+a_i+\min\{f_j+j*d\}$

发现所求最小值中只与$j$有关。

思路就很明显了：用一个长度为$x$的滑动窗口维护$f_j+j*d$的最小值，而使用的数据结构正是单调队列。

别的题解都是用手动模拟来实现的，那我就来一份$STL$中的$deque$(双端队列)来实现吧。

时间复杂度：$O(n)$，可过。

```cpp
/*
 * @Author: zhangyuhan 
 * @Date: 2020-02-03 22:06:02 
 * @Last Modified by: zhangyuhan
 * @Last Modified time: 2020-02-03 22:25:05
 */
#include <iostream>
#include <deque> //deque的头文件
#include <cstdio>
#define _for(i, a, b) for (int i=(a); i<=(b); i++)
using namespace std;

typedef long long LL;
const int MAXN = 1e7 + 10;

int n, tp, x;
LL a[MAXN], k, d, Seed, f[MAXN];
deque<int> q;

inline int rnd () {
	static const int MOD = 1e9;
	return Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;
}//数据生成函数

int main() {
    cin >> n >> k >> d >> x >> tp;
    if (tp == 0) {
        _for (i, 1, n) scanf("%lld", &a[i]);
    }
    else {
        scanf("%lld", &Seed);
        _for (i, 1, n) a[i] = rnd();
    }
    f[1] = a[1];
    q.push_back(1);//初始化莫忘掉
    _for (i, 2, n) {
        while (!q.empty() && i-q.front() > x) q.pop_front(); //第1步：“过期"的弹出
        f[i] = f[q.front()] + a[i] + k + (i-q.front()-1) * d;//第2步：更新f[i]
        while (!q.empty() && f[i]-i*d <= f[q.back()]-q.back()*d) q.pop_back();//第3步：较大的弹出
        q.push_back(i);//第4步：入队
    }
    printf("%lld\n", f[n]);
    return 0;//完结撒花！
}
```

---

## 作者：panxz2009 (赞：5)

## P6040 「ACOI2020」课后期末考试滑溜滑溜补习班 题解
### 一、题意简述

- 杀老师从第一位到最后一位同学依次回答问题，回答第 $i$ 位同学的问题需付出代价为 $a_i$ 。（注意：不一定要遵守顺序，具体规则如下）
- 杀老师最多可以跳过 $x-1$ 个同学，但同时需付出代价为 $ k+(q-p-1) \times d$ （当前位置为 $p$ ，跳到的位置为  $q$ ）。
- 最终输出杀老师要付出的最少代价。

### 二、题目分析

#### 1. 部分分（20分）

看到题目，第一反应一定是使用动态规划。

因为动态规划具有无后效性，那么容易想到设 $dp_i$ 为杀老师在第 $i$ 位同学时要付出的最小代价。

使用两层循环，$i$ 枚举当前同学的编号，即杀老师当前位于第 $i$ 位同学的位置； $j$ 枚举上一位同学的编号，易知 $i-x \le j<i$ 。

初始状态： $dp_1=a_1$ ；其余的全部赋一个很大的值。

动态转移方程： $dp_i=\min\{dp_i+k+(i-j-1) \times d+a_i\}$

最终状态：输出 $dp_n$ 。

~~如果不出意外的话~~，最多可以获得20分。

#### 2. 正解（100分）

正解的做法就是dp+单调队列优化。

首先，我们把动态转移方程变换一下，可得 $dp_i=k+(i-1) \times d+a_i+\min\{dp_j+j \times d\}$

所以，最终只有 $j$ 的取值才能影响 $dp_i$ 的值。
那么就可以把 $j$ 的这一层循环给消掉，使用类似于滑动窗口的方式取代这一层循环，使用单调队列这种数据结构。（如果你不知道什么是单调队列，建议你去[P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)看看）

想到了这一层，那么基本就是套用单调队列的板子，然后就可以愉快 AC 了。

如果你想知道单调队列的具体实现步骤，请看我的代码注释。

### 三、代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,k,d,x,tp,Seed;
ll a[10000010],dp[10000010];
ll q[10000010],head,tail;
inline int rnd () {
	static const int MOD = 1e9;
	return Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;
}
int main()
{
	cin>>n>>k>>d>>x>>tp;
	if(tp==0) 
	{
		for(ll i=1;i<=n;i++) cin>>a[i];
	}
	else
	{
		cin>>Seed;
		for(ll i=1;i<=n;i++) a[i]=rnd();
	}
	//memset(dp,0x7f,sizeof(dp));
	dp[1]=a[1];
	head=tail=1;
	q[1]=1;
	for(ll i=2;i<=n;i++)
	{
		while(head<=tail&&q[head]<i-x) head++;//如果已经超出了可以跳过的范围，那么弹出这一编号
		dp[i]=dp[q[head]]+k+(i-q[head]-1)*d+a[i];//动态转移方程，之前的j就是如今的q[head]
		while(head<=tail&&dp[q[tail]]-q[tail]*d>=dp[i]-i*d) tail--;//维护单调队列的单调性
		q[++tail]=i;//入队
	}
	cout<<dp[n];
	return 0;
}

```



---

## 作者：奇米 (赞：5)

## 题解-P6040 「ACOI2020」课后期末考试滑溜滑溜补习班

* **题目意思**

题目较长，不便于描述
 
* $Sol$

这道题目就是考察了一道基础的单调队列优化$Dp$，以及化柿子的方法。
    
$20ptc$，暴力$Dp$
    
设$f_{i}$表示到$i$的最小花费精力，转移	$O(n^2)$即可
$f_i=min\{f_j+(i-j-1)*d+k+a_i\},j∈[i-x,i-1)$
    
$Code1$
```cpp
if(n<=1000)
{
	memset(f,127/3,sizeof(f));
	f[1]=a[1];
	for ( int i=2;i<=n;i++ ) 
		for ( int j=max(1ll,i-X);j<i;j++ ) 
			f[i]=min(f[i],f[j]+K+(i-j-1)*D+a[i]);
	printf("%lld\n",f[n]);
	exit(0); 
}
```

$100ptc$，单调队列优化$Dp$

对于上述柿子我们可以进行移项合并得到：
	$f_i=a_i+k+(i-1)*d+min\{f_j-j*d\}$
    
到这里我们很容易想到用单调队列去维护$f_j-j*d$单减即可，于是就是单调队列的基本操作了。

$Code2$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N=1e7+5;

int n,m,K,D,X,type,a[N],f[N],q[N],Seed;

inline int read() 
{
	int sum=0; char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) 
		sum=sum*10+(ch^48),ch=getchar();
	return sum;
}

inline int rnd () 
{
	static const int MOD = 1e9;
	return Seed=(1ll*Seed*0x66CCFF%MOD+20120712)%MOD;
}

inline void Sub()
{
	for ( int i=1;i<=n;i++ ) a[i]=read();
	if(n<=1000)
	{
		memset(f,127/3,sizeof(f));
		f[1]=a[1];
		for ( int i=2;i<=n;i++ ) 
			for ( int j=max(1ll,i-X);j<i;j++ ) 
				f[i]=min(f[i],f[j]+K+(i-j-1)*D+a[i]);
		printf("%lld\n",f[n]);
		exit(0); 
	}
	f[1]=a[1];
	int head=1,tail=1;
	q[1]=1;
	for ( int i=2;i<=n;i++ ) 
	{
		while(head<=tail&&i-q[head]>X) head++;
		f[i]=f[q[head]]+K+(i-q[head]-1)*D+a[i];
		while(head<=tail&&f[q[tail]]-q[tail]*D>=f[i]-i*D) tail--;
		q[++tail]=i;
	}
	printf("%lld\n",f[n]);
	exit(0);
}

inline void Sub1()
{
	Seed=read();
	for ( int i=1;i<=n;i++ ) a[i]=rnd();
	f[1]=a[1];
	int head=1,tail=1;
	q[1]=1;
	for ( int i=2;i<=n;i++ ) 
	{
		while(head<=tail&&i-q[head]>X) head++;
		f[i]=f[q[head]]+K+(i-q[head]-1)*D+a[i];
		while(head<=tail&&f[q[tail]]-q[tail]*D>=f[i]-i*D) tail--;
		q[++tail]=i;
	}
	printf("%lld\n",f[n]);
	exit(0); 
}

signed main() 
{
	n=read();
	K=read();
	D=read();
	X=read();
	type=read();
	if(!type) Sub();
	else Sub1();
	return 0;
}
/*
10 30630 56910 2 0
7484 99194 86969 17540 29184 68691 91892 81564 93999 74280 

717318
*/ 
	
```

	
    

---

## 作者：Syamoe (赞：3)

开始正题

首先，看到`杀老师解决完最后一个同学的问题最少需要花费多少精力。`很容易就能想到 dp，于是我们可以推出来这样的柿子：

$$dp_i=\min(dp_j+(i-j-1)\cdot d+k+a_i)$$

上式中 $(i-x\le j<i)$，所有变量和题目中给的都是一样的；

然后我们再来考虑一下初始的条件，

显然杀老师再辛苦第一位学员是必须辅导的

那么这里的：$dp_1=a_1$

结束条件是所有学生都辅导了，即：$dp_n$

可是交上去发现只有 20 分，因此，考虑优化。

我们先来分析这个柿子的时间复杂度，

在执行循环的时候，$i$ 从 $1$ 到 $n$ 跑了一遍，$j$ 也从 $1$ 到 $n$ 跑了一遍，那么时间复杂度应是：$O(n^2)$

时间复杂度太高了，因此考虑减掉一个**不必要的循环**，

我们来模拟一下这个式子中杀老师讲课的过程吧：

每一次杀老师辅导选择同学的时候都是选择在**一个区间里**的某一个人，然后每一次往后的更新，其实都是往后挪一个范围，

能直接想到[滑动窗口](https://www.luogu.com.cn/problem/P1886)，于是即可想到单调队列优化

那么，如何确定那些数要被排除掉呢，我们需要一个较为明确的条件。

但是和普通的数不同的是，这是一个 dp 式

所以我们只能考虑提取一下这个柿子里面的常数：

下式中，均满足 $(i-x\le j<i)$，

$$dp_i=\min{dp_j+(i-j-1)\cdot d+k+a_i}$$

$$dp_i=(i-1)\cdot da_i+k+\min dp_j-j\cdot d$$

我们知道，决定每一个 $dp_i$ 的大小的只和 $\min$ 里面的函数有关，那么这个呢，只和 $j$ 有关系。

所以简化后我们只需要处理的就是 $j$ 的大小

因此，选用单调队列来维护 $dp_j-j\cdot d$ 的最小值，然后更新 $dp_j$ 就可以了。

核心代码：
```cpp
    deque<int> Q;
    for (int i = 2; i <= n; ++i)
    {
        while (!Q.empty() && i - Q.front() > x) 
        {
            Q.pop_front();
        }
        dp[i] = dp[Q.front()] + a[i] + k + d * (i - Q.front() - 1);
        while (!Q.empty() && dp[i] - i * d <= dp[Q.front()] - Q.back() * d)//单调队列中的退役 
        {
            Q.pop_back();
        }
        Q.push_back(i); // 新生入队
    }
```

这个里面所有的变量名都不改变，

然后呢，其实就是在单调队列的模板上套了转移方程，

淘汰“毕业”的，就是`for`里第一个`while`是不变的；

第二个是被“单调队列”的。

这就是核心代码解读+我所选用的思路

希望对您有帮助。

---

## 作者：HYJ37567 (赞：1)

一眼看过去就是一道 DP 题，
先不考虑优化。
设 $dp_i$ 表示考虑到第 $i$ 个同学的最优方案。
转移方程如下：

$dp_i=dp_j+(i-j+1)×d+k+a_i$ 其中 $i-x≤j<i$。

初始化为：$dp_1=a_1$。输出 $dp_n$。很明显时间复杂度为 $O(n^2)$。

## 开始优化

注意到可以影响 $f_i$ 大小的只有 $f_j$ 和他们的距离 $(i−j−1)$。所以考虑单调队列来维护。
每次得到 $f_i$ 就应该是

1\. 筛选，弹出无效元素 $(j<i-x)$。

2\. 选择队列第一个元素算出 $f_i$。

3\. 将 $f_i$ 存入队列，并继续筛选。

筛选的的条件：从 $j$ 跳转到某一个点 $x$，和从 $i$ 跳转到某一个点 $x$，从 $j$ 跳转一定会多花一个定值，即 $(i−j)×d$。

可得如下代码：

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1e7+10;
ll n,k,d,x,tp,l=1,r,Seed,dp[N],a[N],q[N];
//q数组是模仿单调队列deque
inline int rnd () {
	static const int MOD = 1e9;
	return Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;
}

int main()
{
    scanf("%lld%lld%lld%lld%lld",&n,&k,&d,&x,&tp);
    if(tp==0)
    {
        for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    }
    else
    {
    	scanf("%lld",&Seed);
		for(int i=1;i<=n;i++) a[i]=rnd();
    }//输入
    if(n<=1000)//20分做法
    {
    	memset(dp,0x3f3f3f3f,sizeof(dp));
    	dp[1]=a[1];
    	for(ll i=2;i<=n;i++)
    	{
    		for(int j=max((ll)1,i-x);j<i;j++)
    		{
    			dp[i]=min(dp[i],dp[j]+(i-j-1)*d+k+a[i]);
    		}
    	}
    	printf("%lld\n",dp[n]);
    	return 0;
    }
    dp[1]=a[1];
    q[++r]=1;
    for(int i=2;i<=n;i++)//不做赘述了
    {
        while(r-l>=0&&q[l]<i-x) l++;
        dp[i]=dp[q[l]]+a[i]+(i-q[l]-1)*d+k;
        while(r-l>=0&&dp[q[r]]-q[r]*d>=dp[i]-i*d) r--;
        q[++r]=i;
    }
    printf("%lld\n",dp[n]);
    return 0;
}
```

---

## 作者：Micnation_AFO (赞：1)

## $\texttt{Description}$

有 $n$ 个任务，每件任务需要 $a_i$ 的精力。从第一件任务到第二件任务之间需要花费 $k$ 个精力。可以使得任意多个不超过 $x- 1$ 的 $a_i$ 变为 $0$，但是变化一个数就要耗费 $d$ 的精力。现在希望求出最少需要花费多少精力。

## $\texttt{Brute Force}$

令 $f_i$ 表示处理完第 $i$ 个任务后用到的精力的最小值。

- 首先显然有边界 $f_1 = a_1$。
- 对于每一个 $2 \le i \le n$，$f_i$ 的候选项中一定有 $f_{i - 1} + a_i + k$。
- 接着，可以从枚举 $i - 2$ 到 $i - x$ 枚举 $j$，那么从第 $x$ 个认为开始连续跳到第 $i$ 个任务，显然也是 $f_i$ 的候选项，即 $f_i + (i - j - 1) \times d + k + a_i$。

综上所述，状态转移方差为：
$$
f_i = \min(f_j + (i - j - 1) \times d + k \times a_i)
$$

其中，$\min(1, i - x)\le j \le i - 2$。 

[$\texttt{20 pts}$ 部分分代码](https://www.luogu.com.cn/paste/fhdvrti9)。

## $\texttt{Solution}$
把方程展开一下，可以得到 $f_i = \min((i - 1)\times d + k + a_i + f_j - j \times d)$。

不难发现，与 $j$ 有关的其实只有 $f_j - j\times d$，也就是说，我们需要维护的就是连续 $x - 1$ 个数内 $f_j - j\times d$ 的最小值。

如果您还没有想起什么，请先解决[这道问题](https://www.luogu.com.cn/problem/P1886)。

那么，这道题就被转化为了单调队列优化 DP 的板子题，这里用双端队列 `deque` 来实现。

```cpp
#include <iostream>
#include <cstring>
#include <deque>
using namespace std;

typedef long long LL;
const LL N = 1e7 + 10;

LL n, k, d, x, tp;
LL a[N];
LL f[N];

deque<LL> q;

inline LL rnd (LL &Seed) {
	static const LL MOD = 1e9;
	return Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;
}

int main() {
    scanf("%lld%lld%lld%lld%lld", &n, &k, &d, &x, &tp);
    if (tp == 0)
        for (LL i = 1; i <= n; i++) scanf("%lld", a + i);
    else {
        LL Seed;
        scanf("%lld", &Seed);
        for (LL i = 1; i <= n; i++) a[i] = rnd(Seed);
    }
    f[1] = a[1];
    q.push_back(1);
    for (LL i = 2; i <= n; i++) {
        while (q.size() && i - q.front() > x) q.pop_front();
        f[i] = f[q.front()] - q.front() * d + (i - 1) * d + k + a[i];
        while (q.size() && f[i] - i * d <= f[q.back()] - q.back() * d) q.pop_back();
        q.push_back(i);
    }
    printf("%lld\n", f[n]);
    return 0;
}
```

---

## 作者：Isshiki·Iroha (赞：1)

## 题解

[传送门](https://www.luogu.com.cn/problem/P6040)

[~~在博客里食用效果更佳~~](https://www.luogu.com.cn/blog/yousa22/solution-p6040)

看到这种求最大值最小的问题，一般是 Dp，我们先试着用 Dp 的思路来写。

我们设 $dp_i$ 表示杀老师当前正在辅导第 $i$ 个学生，已经辅导完（可以跳过部分学习）前 $i$ 个学生的时候的最小精力耗费值。

我们看题目，杀老师可以**跳过 $x-1$ 个学生**，就是把连续的 $x-1$ 学生放弃不辅导。

**举个例子**：

当 $n=8,x=5,i=7$ 的时候:

$$a_1,a_2,a_3,a_4,a_5,a_6,a_7(i),a_8$$

他可以最多跳过 $4$ 个学生到学生 $i$。
也就是说，他从学生 $2,3,4,5,6$ 开始都可以直接跳到 $i$，那么 $i$ 的状态也就只能从前面的 $i-x$ 到 $i-1$ 转移过来。题目也告诉你了不同情况花费的精力。就可以上转移方程了：

$$dp_i=\min\{dp_j+(i-j-1)\times d+k+a_i\}\ (j \in [i-x,i-1])$$

这里可能会有人有问题？如果我不跳过怎么办？

很简单，如果不跳过，$j=i-1$，此时 $i-j-1=0$，就和题目里面的式子一样。

当然对于第一个学生，杀老师必须辅导，就是

$dp_1=a_1$

答案就是杀老师辅导完学生 $n$ 的时候，就是 $dp_n$

比较 naive 的思路，暴力枚举 $j$，找最小。

期望得分：$20\  pts$

但是 $n=10^7$，$O(n^2)$ 显然会炸，考虑优化。

来看一张图片，这是 $n=9,x=5$ 时候，Dp 数组 $7,8,9$ 被更新时用到的值:（线段和圆圈颜色一样就是代表他被更新用到的值）

![](https://cdn.luogu.com.cn/upload/image_hosting/m08uelr5.png)

我们发现每一次往后更新，要用到的值的区间就会往后挪一位，这让我们想到了单调队列，但是现在的 Dp 式不方便，我们先把里面的常数提出：

$$dp_i=\min\{dp_j+(i-j-1)\times d+k+a_i\}\ (j \in [i-x,i-1])$$

$$dp_i=\min\{dp_j+i\times d-j\times d-1\times d+k+a_i\}\ (j \in [i-x,i-1])$$

我们发现 $i\times d,1\times d,k,a_i$ 是不变的，考虑提出

$$dp_i=\min\{dp_j-j\times d\}+i\times d-1\times d+k+a_i\ \ \ (j \in [i-x,i-1])$$

这样我们就可以通过比较 $dp_j-j\times d$ 的值来 $O(1)$ 每一次求出最小值了。

总复杂度：$O(n)$

快读快输~~懒得~~贴。

代码:

```cpp
/*
	Name: 课后期末考试滑溜补习班
	Copyright: ACOI2020 P6040
	Author: Isshiki Iroha
	Date: 17/10/21 11:36
	Description: Dp
*/
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e7+10;
const int Mod=1e9;
int n,k,d,x,tp;
ll Seed;
inline ll Rand () {
	Seed=(1LL*Seed*0x66CCFF%Mod+20120712)%Mod;
	return Seed;
}
ll a[maxn];
ll dp[maxn];
int q[maxn];
int main() {
    read(n,k,d,x,tp);
    if(tp==0){
        for(int i(1);i<=n;++i)read(a[i]);
    }
    else {
        read(Seed);
        for(int i(1);i<=n;++i){
            a[i]=Rand();
        }
    }
    for(int i(1);i<=n;++i)dp[i]=1e15;
    dp[1]=a[1]; 
    int head=1,tail=0,now=1;
    for(int i(2);i<=n;++i){
        while(now<i){
        	while(tail>=head&&(dp[q[tail]]-q[tail]*1ll*d)>=(dp[now]-now*1ll*d))--tail;
            ++tail;
            q[tail]=now;
            ++now;
		}
        while(tail>=head&&q[head]<i-x)++head;
        dp[i]=dp[q[head]]-(q[head]*1ll*d)+i*1ll*d-d+k+a[i];
    }
    write(dp[n]);
    return 0;
}

```



---

## 作者：红尘仙 (赞：1)

### 前序
如果这道题更改一下数据，前 20 分朴素暴力可过，前 40 分暴力 DP 可以过，对于 $100\%$ 数据，单调队列优化可过，那么这道题不失为一道区分度好题。

### Solution : 

设 $f_i$ 表示已经解决完第 i 个同学，杀老师消耗的最小精力。

考虑状态从何来，想必是从第 i 个同学开始的，前 x - 1 个同学吧, 那么我们其实就有了状态转移 ： 

$$f_i = \min_{i - x \leq j < i} (f_j + k + (i - j - 1) \times d ) + a_i$$

我们稍微化简一下，提有关 i 个式子，因为有关于 i 的式子中，除了 $f_i$ 需要被 j 去更新以外，其他的都不会跟 j 有关系。同时我们就能够得到 ：

$$f_i = \min_{i - x \leq j < i}(f_j - d \times j) + a_i + (i - 1) \times d + k$$ 

然后我们发现这个有一个限制就很妙，关于 $f_i$ 个更新只能是 [i - x , i) 的，我们发现，这个是一个滑动窗口呀，长度为 x 的滑动窗口。那么我们用单调队列维护一下 $f_{j} - j \times d$ 的最小值，更新 $f_i$ 就好了。 

### Code 

```
//
/*
Author : Zmonarch
Knowledge :
*/
#include <bits/stdc++.h>
#define inf 2147483647
#define qwq register
#define qaq inline
#define int long long
using namespace std ;
const int kmaxn = 1e7 + 10 ;
qaq int read() {
	int x = 0 , f = 1 ; char ch = getchar() ;
	while(!isdigit(ch)) {if(ch == '-') f = - 1 ; ch = getchar() ;}
	while( isdigit(ch)) {x = x * 10 + ch - '0' ; ch = getchar() ;}
	return x * f ;
}
int n , k , d , x , type , seed , h , t ; 
int a[kmaxn] , f[kmaxn] , q[kmaxn]; // 这里 q 数组维护的是下标
qaq int Rnd() {
	static const int mod = 1e9 ; 
	return seed = (seed * 0x66CCFF % mod + 20120712) % mod; 
}
qaq void Init1() {
	for(qwq int i = 1 ; i <= n ; i++) a[i] = read() ; 
}
qaq void Init2() {
	seed = read() ; 
	for(qwq int i = 1 ; i <= n ; i++) a[i] = Rnd() ; 
}
signed main() {
	n = read() , k = read() , d = read() , x = read() , type = read() ; 
	if(!type) Init1() ; 
	else Init2() ; 
	h = 1 ; t = 0 ; q[++t] = 1 ; f[1] = a[1] ; // 这个 f[1] 需要特判一下，杀老师必须从 1 开始
	for(qwq int i = 2 ; i <= n ; i++) 
	{
		// 哈，我们可以这么理解一下单调队列 
		while(h <= t && q[h] < i - x) h++ ; // 年龄太大了，被迫退役
		f[i] = f[q[h]] + a[i] + (i - q[h] - 1) * d + k ; // 状态转移方程 
		while(h <= t && f[q[t]] - q[t] * d >= f[i] - i * d) t-- ; // 比你小还比你强，就可以退役了
		q[++t] = i ;    
	}
	printf("%lld\n" , f[n]) ;  
	return 0 ;
}

```


---

## 作者：yihang2011 (赞：0)

### [P6040 「ACOI2020」课后期末考试滑溜滑溜补习班](https://www.luogu.com.cn/problem/P6040)

---

单调性优化 DP。

首先考虑纯动态规划，设 $f_i$ 为当老师到第 $i$ 名学生时花费的最少精力。初始状态 $f_1 = a_1$。$f_i$ 可以从第 $j(i - x \le j < i)$ 名同学转移过来，那么转移方程为：

$$
f_i = \min_{i - x \le j < i}\{f_j + a_i + k + (i - j - 1) \times d\}
$$

很容易发现，$a_i + k + (i - 1) \times d$ 这部分与 $j$ 没有任何关系，所以将它们提取出来：

$$
f_i = a_i + k + (i - 1) \times d + \min_{i - x \le j < i}\{f_j - j \times d\}
$$

考虑使用单调队列维护 $\min_{i - x \le j < i}\{f_j - j \times d\}$，时间复杂度可以达到 $\mathcal{O}(n)$。

式子里有 $(i - 1) \times d$ 和 $j \times d$，极限是 $n \times d = 10^{16}$，记得开 `long long`。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int Seed, tp;
inline int rnd () {
	static const int MOD = 1e9;
	return Seed = ( 1ll * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;
}

ll n, m, k, d;
ll a[10000010];
ll f[10000010];
deque<ll> q;

ll _f(int x) {
	return f[x] - 1ll * x * d;
}

signed main() {
	cin >> n >> k >> d >> m >> tp;
    if (tp == 0) {
    	for (int i = 1; i <= n; cin >> a[i++]);
    } else {
        cin >> Seed;
        for (int i = 1; i <= n; a[i++] = rnd());
    }
	f[1] = a[1];
	q.push_back(1);
	for (int i = 2; i <= n; i++) {
		while (!q.empty() && i - q.front() > m) {
			q.pop_front();
		}
		f[i] = f[q.front()] + k + (i - q.front() - 1ll) * d + a[i];
		while (!q.empty() && _f(i) <= _f(q.back())) {
			q.pop_back();
		}
		q.push_back(i);
	}
	cout << f[n] << endl;
	return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/216526551)

---

## 作者：Little_duck_GGG (赞：0)

## 题目意思
有一些人站成一排，你看需要帮助每个人解决一些问题，对于第 $i$ 人花费 $a_i$ 时间，你也可以选择跳过至多 $x-1$ 个人，不解决他们的问题，但是这也需要 $k+(q−p−1)\times d$ 其中 $q$ 是跳到的位置 $p$ 是开始跳的位置。求他最后需要多少时间。
## 题目思路
我们不急，先讲解一下暴力。

我们假设此时 $x = 2$ 也就是可以跳过 $x-1 = 2-1 = 1$ 个人。

首先对于 $i=1$ 的情况，$dp[1] = a[1]$，对于 $i = 2$ 时，$dp[2] = dp[1]+a[2]+k$。

但当到了 $i = 3$ 时，就会有两种情况了。

**第一种情况：$dp[3] = dp[2]+k+a[3]$**。

**第二种情况：$dp[3] = dp[1]+a[3]+k+d \times (3-1-1) = dp[1]+a[3]+k+d$**。

所以此时我们便知道，**对于 $i$ 的位置，它的 $dp[i]$ 等于 $dp[i-1]+a[i]+k$ 和 $dp[i-p-1]+a[i]+k+d \times p$ 的最小值，$p$ 指跳了几个人**。

此时我们就可以打出暴力代码了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,d,x,tp,a[10050000],Seed,dp[10000505];
inline int rnd () {
	static const int MOD = 1e9;
	return Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;
}
int main()
{
    cin>>n>>k>>d>>x>>tp;
    if(tp==0)
    {
    	for(int i=1;i<=n;i++) cin>>a[i];
    }
    else
    {
    	cin>>Seed;
    	for(int i=1;i<=n;i++) a[i]=rnd();
    }
    dp[1]=a[1];
    for(int i=2;i<=n;i++)
    {
    	dp[i]=dp[i-1]+k;//也可以选择不跳过 
    	for(int j=1;j<x;j++)
    	{
    		if(i-j-1<1) break;
    		dp[i]=min(dp[i],dp[i-j-1]+d*j+k);//不过多解释，上文有讲，寻找j就是p 
    	}
    	dp[i]+=a[i];
    }
    cout<<dp[n];
	return 0;
}
```
但是这仅仅这能拿到一点分数，我们继续。

我们注意到要取最小值，且时**连续一段**的最小值，这是你想到了什么，单调队列。

**这道题可以用单调队列来维护最小值**。

如果不知道单调队列，可以参考[这道题](https://www.luogu.com.cn/problem/P1886)。

对于单调队列，无非只有三种操作。

**第一，当此时队头的位置超出了给定范围时，弹出**。

**第二，加入元素，并求出当前位置的 $dp$ 值**。

**第三，当此时的值，不再有价值的时候，弹出**。

那么那种值是有价值的，哪种是没有的？这也是这道题的难点。

对于第一，第二点，想必十分简单。我们直接去实现第三点。也就是哪种有价值。

我们在单调队列中存的值就是 $dp[i]$ 的值，那么对于每个 $dp[i]$ 与 $dp[j]$ 容易得出两者的差应该为 $(i-j)\times d$ 也就是说，我们可以把 $dp[i]$ 减去 $i\times d$，把 $dp[j]$ 减去 $j\times d$ 然后再比较大小。大的就是没有价值的。

此操作具体代码给出。

```cpp
dp[i]=dp[q.front()]+d*(i-q.front()-1)+a[i]+k;
//dp[i]=题目给出的公式套上去，队头存的是最小  
while(!q.empty()&&dp[q.back()]-q.back()*d>=dp[i]-i*d)
{
	q.pop_back();
}
//这里就是讲上文所述的j替换成q.back
```
那么这样三部曲就做完了，给出代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,d,x,tp,a[10000005],Seed,dp[10000005];//数组要开大，要long long 
inline int rnd () {
	static const int MOD = 1e9;
	return Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;
}//题目给的别管它 
deque<int> q;
int main()
{
    scanf("%lld%lld%lld%lld%lld",&n,&k,&d,&x,&tp);
    if(tp==0)
    {
    	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    }
    else
    {
    	cin>>Seed;
    	for(int i=1;i<=n;i++) a[i]=rnd();
    }
    q.push_back(1);//切记要初始化！ 
    dp[1]=a[1];
    for(int i=2;i<=n;i++)
    {
    	if(!q.empty()&&i-q.front()>x) q.pop_front();
    	dp[i]=dp[q.front()]+d*(i-q.front()-1)+a[i]+k;
		//dp[i]=题目给出的公式套上去，队头存的是最小  
  	 	while(!q.empty()&&dp[q.back()]-q.back()*d>=dp[i]-i*d)
		{
			q.pop_back();
		}
		//这里就是讲上文所述的j替换成q.back 
    	q.push_back(i);
    }
    cout<<dp[n];
	return 0;
}
```

---

## 作者：ElmPoplar (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6040)

## 解题思路

~~最喜欢写 DP 了~~，很容易想到状态 $f_i$ 表示杀老师解决第 $i$ 个人问题时的最小精力花费值，从第 $j$ 个人移动第 $i$ 个人中很容易想出状态转移方程：
$$
f_i=\min\limits_{i-x\le j\le i-1}\{f_j+a_i+k+(i-j-1)\times d\}
$$
这下子我们的 DP 就写完啦，不过 $n\le 10^7$ 的情况下 $O(n^2)$ 是绝对会炸的，这时我们可以观察到 $j$ 的取值范围随着 $i$ 的增加向正方向移动，而我们就可以很容易地想出一种解决方法——单调队列。

我们把状态变量 $i$ 和决策变量 $j$ 分开，状态转移方程可改写为：
$$
f_i=\min\limits_{i-x\le j\le i-1}\{f_j-j\times d\}+a_i+k+i\times d-d
$$
维护一个决策点 $j$ 单调递增，数值 $f_j-j\times d$ 单调递增的队列。然后就可以解决这道题啦。

## Code

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 10000005;
long long n, k, d, x, tp, Seed, a[N];
long long f[N];
int l, r, q[N];

inline long long rnd () {
	static const int MOD = 1e9;
	return Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;
}

long long calc(int j) {
	return f[j] - j * d;
}

int main() {
	scanf("%lld%lld%lld%lld%lld", &n, &k, &d, &x, &tp);
	if (tp == 0)
		for (int i = 1; i <= n; i ++) scanf("%lld", &a[i]);
	else {
		scanf("%lld", &Seed);
		for (int i = 1; i <= n; i ++) a[i] = rnd();
	}
	
	memset(f, 0x3f, sizeof f);
	f[1] = a[1];
	
	q[l = r = 1] = 0;
	for (int i = 1; i <= n; i ++) {
		while (l <= r && calc(q[r]) > calc(i - 1)) r --;
		q[++ r] = i - 1;
		while (l <= r && q[l] < i - x) l ++;
		f[i] = min(f[i], calc(q[l]) + a[i] + k + i * d - d);
	}
	
	printf("%lld\n", f[n]);
	
	return 0;
}
```

## 后话

这道题不开 long long 见祖宗。

---


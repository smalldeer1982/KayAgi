# [yLOI2020] 不离

## 题目背景

> 乱玄黄时序，探风林实虚。  
> 我要你共我奇谈怪趣。  
> 任日月斑斓，待春秋兴残。  
> 我要我们有聚无散。  

——银临《不离》

## 题目描述

这道题目来自 zxy 哔哔，咕咕让哔哔选一首歌作为题目名，但是哔哔说没有想好，于是咕咕就帮他选了这首歌。

哔哔在玩一款叫做《暗黑破坏神》的游戏，某天哔哔灵光乍现，以游戏为背景出了一道神仙题并告诉了咕咕。咕咕并不会做，于是对题目进行了一定的简化。因此，经过简化后，这道题已经和《暗黑破坏神》没什么关系了。

游戏中人物有两个属性，我们分别称之为「力量」和「精神」，同时哔哔有 $n$ 件装备，穿戴第 $i$ 件装备需要人物在穿戴前的力量值不低于 $a_i$，精神值不低于 $b_i$。在穿戴第 $i$ 件装备后，人物的力量值会增加 $c_i$，精神值会增加 $d_i$。

哔哔可以自由选择穿装备的顺序，只要满足力量和精神不低于对应值，就可以穿戴该装备。

现在，咕咕想知道，如果想让哔哔穿戴上所有的装备，那么人物的初始力量值（即没有穿任何装备之前的力量值）最小应该是多少？在初始力量值最小的前提下，初始精神值（即没有穿任何装备之前的精神值）最小应该是多少？

显然，初始力量和初始精神都应该是非负整数。

## 说明/提示

### 样例 1 解释

当初始力量值为 $1$，精神值为 $2$ 时，可以穿戴第 $2$ 件装备。在穿戴该装备后，增加 $3$ 点力量和 $4$ 点精神，人物的属性变为 $4$ 点力量和 $6$ 点精神，此时可以穿戴第 $1$ 件装备。

### 数据规模与约定

**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$5$ 分）：保证 $n=1$。
- 子任务 $3$（$20$ 分）：保证 $a_i,b_i \le 100$，$n \le 6$。
- 子任务 $4$（$10$ 分）：保证 $a_i,b_i \le 10^5$，$n \le 6$。
- 子任务 $5$（$10$ 分）：保证 $a_i,b_i \le 10$。
- 子任务 $6$（$10$ 分）：保证 $a_i,b_i \le 100$。
- 子任务 $7$（$10$ 分）：保证 $b_i=0$，$n \le 6$。
- 子任务 $8$（$10$ 分）：保证 $b_i=0$。
- 子任务 $9$（$10$ 分）：保证 $n \le 6$。
- 子任务 $10$（$10$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^5$，$0 \le a_i,b_i,c_i,d_i \le 10^9$。

### 提示
有 $4$ 个样例文件，请见附加文件中的 forever.zip。

对于第三个样例，满足 $b_i = 0$。

## 样例 #1

### 输入

```
0
2
1 5 0 2
1 2 3 4```

### 输出

```
1 2```

# 题解

## 作者：一扶苏一 (赞：25)

## B

#### Algorithm 1

考虑枚举初始属性。显然初始属性不会高于需求的最大值，然后用全排列爆搜每种穿装备顺序。时间复杂度 $O(n! \times a \times b )$。可以通过前三个子任务，期望得分 30 分。

#### Algorithm 2

注意到因为要先最小化第一个再最小化第二个，所以两个属性实际上是独立的。也即我们可以不考虑第二个属性，先通过枚举确定第一个属性的最小初始值是多少。然后在此基础上通过枚举确定第二个属性的最小初始值。穿装备的顺序同样可以全排列爆搜。这个算法与第一个算法的区别是，将 $a$ 和 $b$ 分开枚举，而不是乘起来。时间复杂度 $O(n! \times \max(a, b))$。可以通过前四个子任务，期望得分 40 分。

#### Algorithm 3

从算法 1 的基础上扩展，考虑去掉全排列枚举的部分。我们可以把所有的装备按照 $a$ 值排序。人物的第一个属性增加时，把所有的 $a$ 值不大于当前属性的装备用一个小根堆维护。这个小根堆以 $b$ 为关键字。人物的第二个属性增加时，把堆中所有 $b$ 不大于当前属性的装备取出并穿戴。也即堆里维护的是当前第一个属性符合要求但是第二个属性不符合要求的装备。

枚举初始属性后，每次需要 $O(n \log n)$ 的时间 check 是否合法。总时间复杂度 $O(a \times b \times n\log n)$。可以通过子任务 1,2,3,5，期望得分 40 分。

#### Algorithm 4

把算法 2 同样用算法 3 的方式替换掉全排列的部分，时间复杂度 $O(\max(a, b) \times n \log n)$，可以通过前六个子任务，期望得分 60 分。

#### Algorithm 5

$b_i = 0$ 时，问题相当于只有一个属性，最小化初始属性值。明示二分答案。二分答案后爆搜全排列来 check 方案是否合法。时间复杂度 $O(n! \log a)$，可以通过子任务 7，期望得分 10 分。

#### Algorithm 6

把装备按照 $a$ 值排序，check 时扫一遍装备就能确定是否合法了。也就是把算法 3 的前半部分拿过来替换算法五的全排列。时间复杂度 $O(n \log n \log a)$，可以通过子任务 7,8，期望得分 20 分。结合算法 4 可以得到 80 分。

#### Algorithm 7

通过算法 3 的结论，两个属性是独立的。因此可以用算法 5 的方式先二分确定第一个值，然后再二分第二个值，全排列 check 即可。时间复杂度 $O(n! \log\max(a, b))$，可以通过子任务 1,2,3,4,7,9，期望得分 60 分。

#### Algorithm 8

如果选手没有发现两个属性相互独立，但是会使用算法 3 的方式维护装备，写二分套二分内层 check 可以得到一个 $O(n \log n \log a \log b)$ 的算法。可以得到 90 分。如果大力卡常，有可能得到 100 分。

#### Algorithm 9

把算法 7 中的全排列 check 用算法 3 中的堆 check 替换，则得到了一个时间复杂度为 $O(n \log n \log\max(a,b))$ 的算法，可以通过全部的测试点，期望得分 100 分。

#### Algorithm 10

事实上可以发现 $a$ 是不需要二分的。把装备按照 $a$ 排序以后，维护一个数组 $t_i$ 表示穿戴完前 $i$ 件装备以后的 $a$ 值最小达到了多少。再对 $a$ 维护一个前缀和 $s_i$。显然 $t_n - s_n$ 就是初始的第一个属性值。在从 $i$ 转移到 $i + 1$ 的过程中，如果 $t_i \geq a_{i + 1}$，那么 $t_{i + 1} = t_i + c_{i + 1}$，否则 $t_{i + 1} = a_{i + 1} + c_i$。时间复杂度为 $O(n \log n \log b)$。可以通过全部的测试点，期望得分 100 分。std 写的是算法 9。

#### Sunmary

- 本题人口普查分 10 分，暴力分 30 分。
- 选手想到二分答案可以得到 50 分。
- 选手发现两个属性相互独立的性质可以得到 50 分。
- 选手会用堆维护可选装备可以得到 50 分。
- 上述三个主要 idea 相互组合，可以得到 $60 \sim 100$ 不等的分数。
- 本题在代码实现上并不困难，std 在 70 行左右，使用堆维护装备需要一点技巧，可以参考 std。
- 总的来说，本题部分分充足，样例良心，题意清晰，码量友好，可以较好的区分签到选手，暴力选手，基本功扎实的选手，善于发现性质的选手和能灵活运用数据结构的选手。是一道优秀的签到题。

```cpp
#include <cstdio>
#include <queue>
#include <algorithm>

const int maxn = 100005;

int T;
int n, ma, mb, fusu, zxy;
int a[maxn], b[maxn], c[maxn], d[maxn], tmp[maxn];

bool check1(long long x);
bool check2(long long x);

inline bool cmp(const int x, const int y) {
  return a[x] < a[y];
}

int main() {
//  freopen("forever7-1.in", "r", stdin);
//  freopen("forever.out", "w", stdout);
  scanf("%d%d", &T, &n);
  for (int i = 1; i <= n; ++i) {
    scanf("%d%d%d%d", a + i, b + i, c + i, d + i);
    ma = std::max(ma, a[i]);
    mb = std::max(mb, b[i]);
    tmp[i] = i;
  }
  std::sort(tmp + 1, tmp + 1 + n, cmp);
  for (int l = 0, r = ma, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1) if (check1(mid)) {
    fusu = mid;
    r = mid - 1;
  } else {
    l = mid + 1;
  }
  for (int l = 0, r = mb, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1) if (check2(mid)) {
    zxy = mid;
    r = mid - 1;
  } else {
    l = mid + 1;
  }
  printf("%d %d\n", fusu, zxy);
}

struct Cmp {
  inline bool operator()(const int x, const int y) {
    return b[x] > b[y];
  }
};

bool check2(long long x) {
  std::priority_queue<int, std::vector<int>, Cmp> Q;
  int i = 1, j; long long y = fusu;
  while (true) {
    while ((i <= n) && (a[tmp[i]] <= y)) Q.push(tmp[i++]);
    if (Q.empty()) {
      return i > n;
    }
    bool flag = false;
    while ((!Q.empty()) && (b[j = Q.top()] <= x)) {
      flag = true;
      Q.pop();
      y += c[j];
      x += d[j];
    }
    if (flag == false) return false;
  }
}

bool check1(long long x) {
  int i = 1;
  while (x >= a[tmp[i]]) {
    x += c[tmp[i]];
    if (++i > n) return true;
  }
  return false;
}
```


---

## 作者：火车司机 (赞：23)

## 简要分析

听说这题有 $O(n \log n \log v)$ 做法，这里给出一个更为优秀的 $O(n \log n)$ 做法

首先，题目要我们以最小化初始力量为前提，因此可以把精神这一限制暂时放到不管

这时，只有力量这一限制，我们可以发现这是一个十分套路的贪心

考虑将所有装备以力量要求为第一关键字，以力量加成为第二关键字排序，然后从小到大扫一边，不足限制时就增加初始力量，不断模拟穿装备的过程，可以易证这样得到初始力量是最小的

接下来需要在保证不影响初始力量的前提下，最小化初始精神

同样考虑刚才的贪心，但是现在多了一个限制，因此我们可以建一个以精神要求为第一关键字，以精神加成为第二关键字的堆在使得满足前提的情况下贪心

充分利用我们刚才求得的最小初始力量，无需重新排序，我们再一次从小到大扫一边所有装备，模拟穿装备的过程

如果当前装备无需增加力量可以直接穿，那我们就将其扔进刚才建好的堆中

如果现有力量并不足以让我们穿上当前装备，那我们就不断地从堆中取出精神要求最低且精神加成最高的装备穿上，直到力量达到当前装备的要求

不断重复上述过程直到所有装备进过一次堆，我们再对于还剩在堆中的装备进行“不断地从堆中取出精神要求最低且精神加成最高的装备穿上”这一过程

因为这个装备序列并没有重新排序，所以上述过程毫无疑问并不影响初始力量的大小，同时不断取出堆顶的贪心可以易证得到的就是最小初始精神

## 完整代码

赛时代码，可能略显丑陋

```cpp
#include <bits/stdc++.h>
#define int long long
#define ri register int
#define N 100005
using namespace std;
int T, n, ans1, ans2;
struct buff {
	int a, b, c, d;
	inline bool operator<(const buff &x) const {
		return b ^ x.b ? b > x.b : d ^ x.d ? d < x.d : a ^ x.a ? a > x.a : c < x.c;
	}
} p[N];
priority_queue<buff> q;
template <typename T>
inline void read(T &x) {
	register T c = getchar();
	for (; c < 48 || 57 < c; c = getchar())
		;
	for (; 48 <= c && c <= 57; c = getchar())
		x = (x << 3) + (x << 1) + (c & 15);
}
template <typename T>
inline void print(T x) {
	if (x > 9)
		print(x / 10);
	putchar(x % 10 | 48);
}
inline bool cmp(buff x, buff y) {
	return x.a ^ y.a ? x.a < y.a : x.c ^ y.c ? x.c > y.c : x.b ^ y.b ? x.b < y.b : x.d > y.d;
}
signed main() {
	read(T), read(n);
	for (ri i = 1; i <= n; ++i)
		read(p[i].a), read(p[i].b), read(p[i].c), read(p[i].d);
	sort(p + 1, p + 1 + n, cmp);
	for (ri i = 1, a = 0; i <= n; ++i) {
		if (a < p[i].a)
			ans1 += p[i].a - a, a = p[i].a;
		a += p[i].c;
	}
	print(ans1), putchar(' ');
	for (ri i = 1, b = 0; i <= n; ++i) {
		while (p[i].a > ans1) {
			if (b < q.top().b)
				ans2 += q.top().b - b, b = q.top().b;
			b += q.top().d, ans1 += q.top().c, q.pop();
		}
		if (p[i].a <= ans1)
			q.push(p[i]);
		if (i == n)
			while (!q.empty()) {
				if (b < q.top().b)
					ans2 += q.top().b - b, b = q.top().b;
				b += q.top().d, q.pop();
			}
	}
	print(ans2);
	return 0;
}
```


---

## 作者：LAB_Maple (赞：17)

## 前言

机房大佬：yLOI 的题都是好题。于是本蒟蒻挑了一道相对简单的做了。明明暴力可以这么优秀，但是题解区大部分都是二分。由于本蒟蒻做这道题时难得一气呵成，便准备写一篇题解为 NOIP 攒攒 RP。

PS：速度冲到了最优解 rk2，空间是前几页中最小的。
[评测记录](https://www.luogu.com.cn/record/62376980)


## 正文

题目大意略，直接进入思路。

题目有两个部分，第一个是求最小的初始力量值，第二个是求在初始力量值最小的前提下最小的初始精神值。设 $a$ 为力量下限，$b$ 为精神下限，$c$ 为力量增幅，$d$ 为精神增幅。

```cpp
struct node{
	int a,b,c,d;
}x[M];
```



### Part 1

首先我们可以发现**力量**和**精神**是有一定关联的，但是对于第一个部分显然可以忽略**精神**的约束而只求**力量**的最小值。因为最小初始力量值的优先级更大，所以考虑第一部分时可以令精神为 $\infty$，就只需要考虑力量与相关约束了。

于是就联想到[廊桥分配](https://www.luogu.com.cn/problem/P7913)的处理方法。开一个 $add$ 表示最小初始力量值，$str$ 表示当前力量值。读入后考虑按照力量下限排序，遍历每件装备，遍历到的就是目前未穿戴且力量下限最小的装备。如果 $str$ 小于 $a$，不足以穿上装备，$add$ 就要补到 $a$ 并且更新 $str$。之后 $str$ 获得增幅，要加上 $c$。遍历完之后 $add$ 即为初始最小力量值。

```cpp
for(int i=1;i<=n;++i) x[i].a=read(),x[i].b=read(),x[i].c=read(),x[i].d=read();
sort(x+1,x+n+1,cmp);
for(int i=1;i<=n;++i)
{
	if(str<x[i].a) add+=x[i].a-str,str=x[i].a;
	str+=x[i].c;
}
printf("%lld ",add);
```



### Part 2

我们已经处理了相对简单的 Part 1，现在开始考虑相对困难的 Part 2。

用 $ad$ 表示最小初始精神值，$spi$ 表示当前精神值，$add$ 表示当前力量值。

有个显而易见的错误思路是在 Part 1 中排序时顺便按照最小精神下限排序，再进行一遍 Part 1 的操作。

但是因为每次穿上装备后力量值都会更新，导致满足当前力量值的可穿戴装备的最小精神下限发生变化（有点拗口）。例如下面这组数据。

```cpp
0
4
1 1 2 1
1 114 5 3
2 2 2 2
3 2 0 514
```

这符合错误排序。遍历到 $i=2$ 时由于精神下限为 114，$ad$ 需要一个较大的改变。但是当我们依次穿上第一件、第三件和第四件装备后再去考虑第二件时，显然就不用较大的改变 $ad$ 了。

于是正确思路出来了。

维护一个优先队列存储未穿戴装备的编号，以精神下限递增排序。

```cpp
struct ioi{
	inline bool operator()(int s,int q)
	{
		return x[s].b>x[q].b;
	}
};
priority_queue<int,vector<int>,ioi> qq; 
```

有人可能会问：这和错误思路有什么区别呢？

区别在于插入编号的条件。

首先插入满足初始力量值的装备。

每次操作后实时更新 $add$ 与当前满足力量下限小于等于 $add$ 的装备。使每次更新装备后队列 $top$ 的精神下限最小。

操作和 Part 1 一样。

```	cpp
for(j=1;j<=n&&x[j].a<=add;++j) qq.push(j);
while(!qq.empty())
{
	int t=qq.top();
	qq.pop();
	if(spi<x[t].b) ad+=x[t].b-spi,spi=x[t].b;
	spi+=x[t].d,add+=x[t].c;
	for(;j<=n&&x[j].a<=add;++j) qq.push(j);
}
printf("%lld",ad);
```

于是整道题就大功告成了！

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int M=100005;
int n,j;
ll str,spi,add,ad;
struct node{
	int a,b,c,d;
}x[M];
inline bool cmp(node s,node q)
{
	return s.a<q.a;
}
struct sqakioi{
	inline bool operator()(int s,int q)
	{
		return x[s].b>x[q].b;
	}
};
priority_queue<int,vector<int>,sqakioi> qq; 
inline int read()
{
	int w=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))f=ch=='-'?-1:f,ch=getchar();
	while(isdigit(ch)) w=w*10+ch-48,ch=getchar();
	return w*f;
}
int main()
{
	n=read();
	n=read();
	for(int i=1;i<=n;++i)	      x[i].a=read(),x[i].b=read(),x[i].c=read(),x[i].d=read();
	sort(x+1,x+n+1,cmp);
	for(int i=1;i<=n;++i)
	{
		if(str<x[i].a) add+=x[i].a-str,str=x[i].a;
		str+=x[i].c;
	}
	printf("%lld ",add);
	for(j=1;j<=n&&x[j].a<=add;++j) qq.push(j);
	while(!qq.empty())
	{
		int t=qq.top();
		qq.pop();
		if(spi<x[t].b) ad+=x[t].b-spi,spi=x[t].b;
		spi+=x[t].d,add+=x[t].c;
		for(;j<=n&&x[j].a<=add;++j) qq.push(j);
	}
	printf("%lld",ad);
	return 0;
}
```

#### The end.



---

## 作者：梦里调音 (赞：5)

毫无疑问，这道题，我们应该先得出初始最小的力量值，再得出初始最小的智慧值。也就是说，初始力量值是先被考虑的。

考虑贪心，假设初始的智慧值无穷大。（为了使求出初始力量值更加方便）

我们可以考虑使用一个**优先队列**，按照 $a$ 从小到大排序。

然后尝试去穿这个有限队列里的装备。如果力量值不够，就需要增加初始力量值，也就是初始力量值要补上这一段力量值的差。

初始力量值就求出来了。

然后，再使用一个**优先队列**，用来存当前力量能穿的装备，然后再这个优先队列中去穿智慧值需求最小的装备。

如此循环往复，便可求出初始指挥值。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int T,n;
struct Node{
	int a,b,c,d;
	bool operator < (Node it)const
	{
		if(it.a==a)return it.b<b;
		else return it.a<a;
	}
};
struct node{
	int a,b,c,d;
	bool operator < (node it)const
	{
		return it.b<b;
	}
};
priority_queue <Node> q,p;//未装备，已装备，其实只是转移
priority_queue <node> r;//力量值足够穿

signed main(void)
{
	cin>>T>>n;
	if(!n)
	{
		cout<<"0 0\n";
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		int aa,bb,cc,dd;
		cin>>aa>>bb>>cc>>dd;
		q.push((Node){aa,bb,cc,dd});
	}

	int ini=0,now=0;
	while(!q.empty())
	{
		Node cur=q.top();
		q.pop();
		p.push(cur);
		if(now>=cur.a)//能够装备
		{
			now+=cur.c;
			continue;
		}

		else{//无法装备
			ini+=cur.a-now;
			now=cur.a;
			now+=cur.c;
		}
	}

	cout<<ini<<" ";
	now=ini;//求智慧值时要初始化力量值

	int init=0,nowt=0;

	while(!p.empty()||!r.empty())
	{
		int cnt=0;
		while(!p.empty()&&p.top().a<=now)//因为力量值会随着装备的增多而增大，所以需要维护r这个优先队列
		{
			cnt++;
			Node cur=p.top();
			r.push((node){cur.a,cur.b,cur.c,cur.d}),p.pop();
		}
		while(!r.empty()&&r.top().b<=nowt)//可以装备
		{
			node cur=r.top();r.pop();
			nowt+=cur.d;
			now+=cur.c;
		}
		if(cnt==0&&!r.empty())//无法装备，需要增加智慧值
		{
			node cur=r.top();r.pop();
			init+=cur.b-nowt;
			nowt=cur.b+cur.d;
			now+=cur.c;
		}
	}

	cout<<init<<endl;

 	return 0;
}

```


---

## 作者：dead_X (赞：5)

## 思路
~~看到这种求最小值的题目，先二分。~~

$\uparrow$ 暴论，但是这题的确就是二分。

我们先二分力量值，并把精神值设成 $\inf$ 。

确定力量值后，我们再二分精神值。

现在的问题变成了怎么判定。

~~这都多老的套路了~~首先，我们把所有**力量值**符合的装备加入一个按照**精神值**排序的小根堆，然后不断从堆顶取出，循环这一过程直到做不下去或者全部取出。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
struct node
{
	int a,b,c,d;
	bool operator<(const node &irrakioi)const{return a<irrakioi.a;}
}f[1000003];
struct n0de
{
	int a,b,c;
	bool operator>(const n0de &irrakioi)const{return a>irrakioi.a;}
};
signed main()
{
	int T=read(),n=read();
	if(n==0) puts("0 0"),exit(0);
	for(int i=1; i<=n; i++) f[i].a=read(),f[i].b=read(),f[i].c=read(),f[i].d=read();
	if(n==1) printf("%d %d\n",f[1].a,f[1].b),exit(0);
	sort(f+1,f+n+1);
	int l=f[1].a,r=f[n].a-1,ansa=f[n].a,ansb=1000000000;
	//无视y的限制
	while(l<=r)
	{
		int mid=(l+r)>>1,cur=mid;
		bool ff=1;
		for(int i=1; i<=n; i++) if(cur<f[i].a) { ff=0; break; }
		else if(cur>=f[n].a) break;
		else cur+=f[i].c;  
		if(ff) ansa=mid,r=mid-1; else l=mid+1;
	} 
	l=0,r=999999999;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		long long cura=ansa,curb=mid;
		priority_queue<n0de,vector<n0de>,greater<n0de> > q;
		int pos=1,now=0;
		bool ff=1;
		while(1)
		{
			while(pos<=n && cura>=f[pos].a) q.push((n0de){f[pos].b,f[pos].c,f[pos].d}),++pos;
			if(q.empty() || curb<q.top().a) { ff=0; break; }
			while(!q.empty() && curb>=q.top().a) cura+=q.top().b,curb+=q.top().c,q.pop(),++now;
			if(now==n) break;
		}
		if(ff) ansb=mid,r=mid-1; else l=mid+1;
	}
	printf("%d %d\n",ansa,ansb);
	return 0;
}

```

---

## 作者：言琢დ (赞：4)

本文仅在 【upd】处进行了修改，其他地方已经通过审核。

#### 前言

提交一种题解没有提到的解法。

~~该解法可以通过全部的测试数据，但 **可能存在** $\rm Hack$。~~

upd on 2021.10.12：本文中复杂度可以证明出是对的，下面将给出证明。

---

#### 正文

首先考虑按 $a_i$ 排序，对 `属性一` 二分，默认 `属性二` 已经最大化。

随后考虑按 $b_i$ 排序，对 `属性二` 二分：

另外，已经穿上的装备不用再考虑，可以记 $nxt_i$ 表示下一个未被穿上的装备。

多次扫描，类似冒泡排序，当没有 `穿戴装备` 操作时判断装备是否全部穿上。

---

#### 后记

另外，由于考场状态问题，把第二维状态用 $a_i$ 扫描，跑慢了一些，但也 $\rm AC$ 了。

赛后自行构造数据形如 `ai=1 .. n，bi= n .. 1` 把 $\rm Hack$ 掉并改成上文正解。

---

经实测，这样二分复杂度在 $O(nk\log\max\{a,b\})$。

其中 $k$ 是一个 **极小** 的常数，指在随机数据下。

~~如果有同学可以对着上面的做法卡掉 [这份提交](/record/42409784) 请联系管理或我撤下题解。~~

upd on 2021.10.12：经过咨询 @[双管荧光灯](https://www.luogu.com.cn/user/13185) 大佬的意见，该解法中 $k$ 至多取到 $\log\max\{a,b\}$，理由是每次拓展之后值域翻倍，因此复杂度是两个 $\log$ 值域乘一个 $n$。

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
inline int in();
inline void wr(int);
const int N=(int)1e5+5;
struct Node{
	int a,b,c,d;
	friend bool operator<(const Node&p,const Node&q){
		if(p.a!=q.a)return p.a<q.a;
		return p.b<q.b;
	}
}s[N];int n,T,nxt[N];bool vis[N];
typedef long long ll;
inline bool check(ll,ll);
signed main(signed argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen("forever4.in","r",stdin);
#endif
	T=in(),n=in();
	for(register int i=1;i<=n;++i)
		s[i]=(Node){in(),in(),in(),in()};
	std::stable_sort(s+1,s+1+n);
	register int l=0,r=(ll)1e9+7;
	while(l<r-3){
		register int mid=(l+r)>>1;
		if(check(mid,(ll)1e9+7))r=mid;
		else l=mid+1;
	}
	for(register int i=l;i<=r;++i)
		if(check(i,(ll)1e9+7)){
			wr(i),putchar(' ');
			register int l=0,r=(ll)1e9+7;
			while(l<r-3){
				register int mid=(l+r)>>1;
				if(check(i,mid))r=mid;
				else l=mid+1;
			}
			for(register int j=l;j<=r;++j)
				if(check(i,j))
					return wr(j),0;
		}
}
inline bool check(ll mid1,ll mid2){
	for(register int i=0;i<=n;++i)
		nxt[i]=i+1,vis[i]=0;
	register bool flag=1;
	vis[n+1]=0;
	while(flag){
		flag=0;
		for(register int i=nxt[0],j=0;i<=n;){
			if(mid1>=s[i].a&&mid2>=s[i].b&&!vis[i])
				mid1+=s[i].c,mid2+=s[i].d,nxt[j]=nxt[i],flag=1,vis[i]=1;
			j=i;
			i=nxt[i];
		}
	}
	for(register int i=1;i<=n;++i)
		if(!vis[i])return 0;
	return 1;
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
//这样我就可以放心地开出代码了
```

---

## 作者：doctorZ_ (赞：4)

先将所有元素以$a$为关键字从小到大排序      
记$resa$为当前积累的力量值，$ansa$为最小初始力量值，贪心的从前往后扫，如果遇到$a_i>resa$，那么说明$ansa$应该加上$a_i-resa$以弥补差值，通过这种办法即可求出$ansa$       
对于第二个问题，我们可以记$resa$为当前积累的力量值，$resb$为当前积累的精神值，$ansb$为最小初始精神值，由于已经求出最小初始力量值，所以我们可以直接使$resa=ansa$，同样贪心的从前往后扫，将$a_i\le resa$的元素全部以$b_i$为关键字放入一个小根堆里，每次都从堆顶取出最小的$b_i$      
更新$ansb$的方式与更新$ansa$的方式类似，如果遇到$b_i>resb$，那么说明$ansb$应该加上$b_i-resb$以弥补差值      
时间复杂度为$O(n\log n)$
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int N=1e5+1000;
int n,a[N+10];
struct node
{
	int a,b,c,d;
}p[N+10];
bool cmp1(node a,node b){return a.a<b.a||(a.a==b.a&&a.b<b.b);}
struct cmp2{bool operator() (node a,node b){return a.b>b.b;}};
priority_queue<node,vector<node>,cmp2> h;
int main()
{
	int Test;
	scanf("%d",&Test);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d %d %d %d",&p[i].a,&p[i].b,&p[i].c,&p[i].d);
	sort(p+1,p+1+n,cmp1);
	int resa=0,ansa=0;
	for(int i=1;i<=n;i++)
	{
		if(resa<p[i].a)
			ansa+=p[i].a-resa,resa=p[i].a;
		if(resa<=1e9)
			resa+=p[i].c;
	}
	printf("%d ",ansa);
	resa=ansa;
	int resb=0,ansb=0;
	for(int i=1,j=0;i<=n;i++)
	{
		while(p[j+1].a<=resa&&j<n)
			j++,h.push(p[j]);
		if(resb<h.top().b)
			ansb+=h.top().b-resb,resb=h.top().b;
		if(resa<=1e9)
			resa+=h.top().c;
		if(resb<=1e9)
			resb+=h.top().d;
		h.pop();
	}
	printf("%d\n",ansb);
	return 0;
}
```


---

## 作者：AuCloud (赞：3)

首先可以明确一点：初始能力值越大越有可能穿上所有装备

即：**决策具有单调性**

并且要求“满足性质的最小值”

很明显的**二分**提示。

## 第一维力量值

设二分出来的解为`res`，考虑贪心验证是否合法

由于穿上装备并不消耗力量，考虑将力量值排序，每次处理出当前时刻可以穿的然后全都~~一股脑~~穿上，再继续重复直到穿不上某件装备（即不合法）或者穿完所有装备（合法）

就完事了……

```cpp
bool check(int qwq)
{
    for(int i = 1; i <= n; i++)
    {
        if(qwq < a[i].a) return 0;
        qwq += a[i].c;
    }
    return 1;
}
```

## 精髓：第二维精神值

由于题目描述说要保证第一维情况下做第二维，所以可以先第一维后第二维

一开始的做法是直接取，每次把**需要的精神值**取max，作为答案return

其中，“需要的精神值”就是当前装备需要的精神值-之前的装备提供的精神值

```cpp
int get_ans()
{
    int ret = 0, sum = 0;
    for(int i = 1; i <= n; i++)
    {
        ret = max(ret, a[i].b - sum);
        sum += a[i].d;
    }
    return ret;
}
```

提交上去得到了30分的好成绩

然后发现**爆int**

```
#define int long long
```

之后变成50分

不甘心地测了大样例，发现我的答案大得离谱（标准答案的5倍）

然后跟@傅思维666 @岚默笙 讨论了一下，思路被Hack了：

当前可以穿的装备不止一件，按a排序穿出的结果显然不是最优的：也许当前可以穿的装备有两件x,y，其中$a_x<a_y$但$b_x>b_y$，并且y装备可以提供足够的精神值使得**先穿上y时y提供的精神值足够穿上x**

所以对于精神值也要考虑刚刚的贪心：能选则选

动态维护当前能穿的装备（**对于a值，因为a值已经固定**），每次找b最少的装备穿上，并计算答案

至于动态维护，套个堆（优先队列）即可

#### 这里我用的是结构体，所以要重新定义"<"才能用堆

```
int get_ans(int qwq)//qwq是当前找到的初始a值最优解
{
    int ret = 0, sum = 0;
    priority_queue<hehe> q;
    int i = 1;
    while(a[i].a <= qwq && i <= n)
    {
        q.push(a[i]);
        i++;
    }
    while(q.size())
    {
        hehe now = q.top();
        q.pop();
        ret = max(ret, now.b - sum);
        sum += now.d;
        qwq += now.c;
        while(a[i].a <= qwq && i <= n)//动态将可穿的装备加入堆
        {
            q.push(a[i]);
            i++;
        }
    }
    return ret;
}
```

总代码：

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
struct hehe{
    int a, b, c, d;
    bool operator < (hehe y) const
    {
        return b > y.b;
    }
}a[100001];
int n;
bool cmp(hehe x, hehe y)
{
    if(x.a == y.a)
    {
        return x.b < y.b;
    }
    return x.a < y.a;
}
bool check(int qwq)
{
    for(int i = 1; i <= n; i++)
    {
        if(qwq < a[i].a) return 0;
        qwq += a[i].c;
    }
    return 1;
}
int get_ans(int qwq)
{
    int ret = 0, sum = 0;
    priority_queue<hehe> q;
    int i = 1;
    while(a[i].a <= qwq && i <= n)
    {
        q.push(a[i]);
        i++;
    }
    while(q.size())
    {
        hehe now = q.top();
        q.pop();
        ret = max(ret, now.b - sum);
        sum += now.d;
        qwq += now.c;
        while(a[i].a <= qwq && i <= n)
        {
            q.push(a[i]);
            i++;
        }
    }
    return ret;
}
signed main()
{
    // freopen("forever4.in", "r", stdin);
    int qwqwqwq;
    cin >> qwqwqwq;
    cin >> n;
    if(n == 0)
    {
        cout << "0 0" << endl;
        return 0;
    }
    int sum = 0;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i].a >> a[i].b >> a[i].c >> a[i].d;
        sum += a[i].a;
    }
    sort(a + 1, a + n + 1, cmp);
    int l = 0, r = sum * 2;
    int ans = 0;
    while(l <= r)
    {
        int mid = (l + r) >> 1;
        if(check(mid))
        {
            ans = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    cout << ans << ' ' << get_ans(ans);
    return 0;
}

```

---

## 作者：xzhif (赞：2)

### 大致思路
先求出初始力量最小值，再求出初始精神值。
### 做法
先把装备按力量值排一次序，然后从小到大扫一遍，求出初始力量最小值。那么，怎么扫呢？

设 iva 为初始力量值， cva 为当前力量值，在 cva 小于目前装备需要的力量值的时候，就要将 iva加到足以穿上当前装备，就是加上当前装备所需力量值再减去 cva ，然后当 cva 大于等于装备所需力量值，再加上它的力量值增益。

```cpp
sort(f+1,f+n+1,cmp);//先以a值排一遍 
	for(int i=1;i<=n;i++){
		if(cva<f[i].a)iva+=f[i].a-cva,cva=f[i].a;
		cva+=f[i].c;
	}
```

然后我们再来求出初始精神值。可以维护一个优先队列存储未穿戴装备的编号，以精神下限递增排序。

首先在队列里推入满足初始力量值的装备。
每次操作后实时更新 iva 与当前满足力量下限小于等于 iva 的装备。使每次更新装备后队列 top 的精神下限最小,操作与找初始力量值相似。

```cpp
#include<bits/stdc++.h>
#define N 100001
using namespace std;
long long T,n,iva,cva,ivb,cvb,o;
struct xs{long long a,b,c,d;}f[N];
bool cmp(xs x,xs y){return x.a<y.a;}
struct sf{
	inline bool operator()(int s,int q){return f[s].b>f[q].b;}
};
priority_queue<int,vector<int>,sf> q; 
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>T>>n;
	for(int i=1;i<=n;i++)cin>>f[i].a>>f[i].b>>f[i].c>>f[i].d;
	sort(f+1,f+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(cva<f[i].a)iva+=f[i].a-cva,cva=f[i].a;
		cva+=f[i].c;
	}
	cout<<iva<<" ";
	for(o=1;o<=n&&iva>=f[o].a;o++)q.push(o);
	while(!q.empty()){
		int p=q.top();q.pop();
		if(cvb<f[p].b)ivb+=f[p].b-cvb,cvb=f[p].b;
		cvb+=f[p].d;iva+=f[p].c;
		for(;o<=n&&iva>=f[o].a;o++)q.push(o); 
	}
	cout<<ivb;
}
```


---

## 作者：CuSO4_and_5H2O (赞：1)

这个题目通过率低的吓人，今天校内模拟考考了这个题目，贪心挂了，很伤心，之后发现先这个题目坑不少而且这题目在洛谷的通过率这么低心里有了些许安慰。

只能说这个题目是贪心好题目！！！

## 涉及知识点

贪心 + 优先队列。

## 思路

为了方便打字，下文中 $pa$ 就是 初始力量 $sa$ 就是现在的力量的属性 $A$ 就是穿上装备的要求的力量的前提，$ja$ 就是穿上装备后增加的力量，$b$ 就对应着精神力。

首先，如果题目只让求出 $a$ 那么是很简单的，按照 $A$ 排序，然后……。很简单，这里就不展开论述了。

这一部分的代码：

```

	sort(w+1,w+1+n,cmp);
	//cmp 是按照要求力量排序的函数 
	pa=w[1].a; sa=w[1].c+pa;
	for(int i=2;i<=n;i++)
	{
		if(w[i].a<=sa) sa+=w[i].c;
		else {
			pa+=(w[i].a-sa);
			sa=w[i].a;
			sa+=w[i].c;
		}
	}
```

之后就是如何求出精神值了，为了求出精神值，也是把我折腾的够精神的……。

接下来我会按照我考试的时候的思路历程进行说明思路。

一开始我就想直接和力量值一块处理就行了，但是有一个问题，处理力量值的装备顺序是一定的吗？很显然，不一定，为什么？因为处理力量的装备顺序是为了贪心求，所以顺序仅仅能保证力量值最小，但是不能保证精神值最大而且有可能改变装备顺序也不会影响力量值，比如：

```
1 2 9 1
8 8 1 1
10 2 10 10
```

这里按照只求力量值最小的思路的装备顺序是 $1 \to 2 \to 3$ 但是如果 $1 \to 3 \to 2$ 的话精神值会更加小，所以这样贪心是不对的。

那现在出了一个问题：就是有可能改变第一次贪心力量值的时候的贪心顺序可以让力量值保持不变而且让精神值更加的小。那怎么解决这个问题？思考一下什么情况下改变装备顺序能让基础力量值不变？

就是在我装备上这一件之后再不需要再加力量值的情况下去装备另外一件，这样就不会改变基础力量值，那现在的问题是在基础力量值不改变的情况下找到最优的装备顺序，如何找？还是贪心。

上文提到，只要我穿上这一件之后不用增加力量值就能再穿一件装备这样我的基础力量值就可以不改变，所以我们可以记录一下当前可以穿的装备（不增加力量值的条件下），然后选出其中精神值要求最低的，然后就和贪心找力量值一样操作了。

这里要涉及到一个问题，就是在一群数中找到最小的，用优先队列就可以在 $\log  n$ 的时间内查询出最小的，然后就可以了。

这道题目贪心思路坑不少，具体讲的话很麻烦，这里放上几组数据，简洁明了。

```
6
1 6 0 1
2 5 0 1
3 4 0 1
4 3 0 1
5 2 0 1
6 1 0 1

输出：6 1

6
64 53 41 19
71 51 75 17
80 89 54 59
90 87 46 59
24 16 1 76
68 79 5 69

输出 63 16

6
100 65 3 2
57 85 9 3
45 25 6 3
75 47 9 3
5 88 4 2
4 87 4 8

输出：68 82

```

这几个都是有坑的，数据来源于校内模拟考学长数据。

## 代码

然后就是代码了：

~~考试代码，马蜂丑。~~

```
#include<bits/stdc++.h>
#define int long long
#define max(A,B) (A<B?B:A)
#define min(A,B) (A>B?B:A)
#define bug cout<<"I AK IOI"<<endl;
#define gc getchar
using namespace std;
const int N=1e5+1;

inline void print(int x) {if (x < 0) putchar('-'), x = -x; if(x > 9) print(x / 10); putchar(x % 10 + '0');}
inline int read(){int res = 0, f = 0; char ch = gc();for(; !isdigit(ch); ch = gc()) f |= (ch == '-'); for(;isdigit(ch);ch=gc()) res = (res << 1) + (res << 3) + (ch ^ '0');return f ? -res :res;}

int T,n,pa,pb,sa,sb;
struct node{
	int a,b,c,d;
	bool operator <(const node &x) const{return x.b<b;};
}w[N];
int cmp(node q,node p){
	if(q.a==p.a) return q.b<p.b;
	return q.a<p.a;
}
priority_queue<node>que;

inline void dfs(int x,int sa,int &sb)
{
	if(x==n+1) return ;
	int jil=n+1;
	for(int i=x;i<=n;i++)
	{
		if(w[i].a<=sa) que.push(w[i]);
		else { jil=i;break ;}
	}
	if(que.top().b>sb) pb+=(que.top().b-sb),sb=que.top().b;
	sb+=que.top().d; sa+=que.top().c;
	que.pop();
	dfs(jil,sa,sb);
}

signed main(){
	T=read();
		n=read();
		for(int i=1;i<=n;i++) w[i].a=read(),w[i].b=read(),w[i].c=read(),w[i].d=read();
		sb=pb=0;
		
		sort(w+1,w+1+n,cmp);
		pa=w[1].a; sa=w[1].c+pa;
		for(int i=2;i<=n;i++)
		{
			if(w[i].a<=sa) sa+=w[i].c;
			else {
				pa+=(w[i].a-sa);
				sa=w[i].a;
				sa+=w[i].c;
			}
		}
		dfs(1,pa,sb);
		while(!que.empty())
		{
			if(que.top().b>sb) pb+=(que.top().b-sb),sb=que.top().b;
			sb+=que.top().d;
			que.pop();
		}
		cout<<pa<<' '<<pb<<'\n'; 
	return 0;
}
```


---

## 作者：sun_yh (赞：1)

赛场上磕死在这一道题上了，最后调出来没来得及交（大悲）

---

[题目](https://www.luogu.com.cn/problem/P7095)

题意不是很难懂，你有两个属性$x,y$，有$n$个物品，每个物品有四个属性$a_i,b_i,c_i,d_i$，如果某个物品的$a_i\leq x,b_i\leq y$，视为这个物品可以取，并且取之后你的$x$变为$x+c_i$，$y$变为$y+d_i$，求解如果要取完这$n$件物品，你的初始$x,y$值最小为多少（在$x$最小的前提下$y$最小）。

首先有几个很明显的结论：

1. 能取的物品就取，因为反正最后每个都要取，而且$c_i,d_i\ge 0$，所以取完一定不会比取之前更劣。

2. 假设有$i,j$都满足条件，先后顺序不会影响最后结果

3. 单调性（~~就不给证明了吧~~）

然后再考虑，如果知道当前的$x,y$值，怎样用比较高的效率求出所有能拿的物品的$c_i,d_i$值之和。有一个比较暴力的想法是按照$a_i$不降排序，先二分找出最大的满足条件的$a_{mid}$，然后从头到$mid$再扫一遍，找出所有的满足条件的$b_i$并累加它们的$c_i,d_i$值。复杂度爆炸，并不足以通过本题。

考虑分块优化（~~大家都知道这场比赛的出题人是谁~~）。仍然先将$a_i$不降排序，对于每个块，预处理出所有$a_i$的最小值$mina$，并且在块内部按照$b_i$不降排序。查询时仍然先按照$x$二分找出最大的$mina_{mid}$。那么，因为我们最初是按照$a_i$不降排序的，那么在$mid$之前的、所有块中的物品都是满足$a_i\leq x$的，我们只需要判断这中间有多少$i$满足$b_i\leq y$。于是我们枚举每个块，在每个块中二分找出有多少个满足条件的$b_i$（块内为什么要按照$b_i$不降排序）。对于$mid$块，暴力枚举所有元素处理即可。每次复杂度为$O(\sqrt n\cdot \log_2{\sqrt n}+\sqrt n)$，可以接受。

综上，我们有了这样一个（~~二分套二分套二分套二分的~~）思路，二分初始值$x,y$，然后一次性找出所有能取的物品并更新$x,y$，重复上述过程，直到已经不能再更新（没有符合条件的物品）或所有物品已被取出为止。总用时167ms，虽然不是正解，但是效率不低。

AC代码附注释：

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
#define maxn 1000001
#define maxm 10001
#define ll long long
struct tool{
	ll a,b,c,d;
}cmpb[maxn];
int l[maxm],r[maxm],m,n,M;
ll mina[maxm],amax,bmax;
ll ansa,ansb,csum[maxn],dsum[maxn];
bool cmp_a(tool x,tool y){
	return x.a<y.a;
}
bool cmp_b(tool x,tool y){
	return x.b<y.b;
}
int finda(ll L,ll R,ll x){//二分找满足条件的块
	int ans=-1,Mid;
	while(L<=R){
		Mid=(L+R)>>1;
		if(mina[Mid]<=x)ans=Mid,L=Mid+1;
		else R=Mid-1;
	}
	return ans;
}
int findb(ll L,ll R,ll x){//二分找块内满足条件的物品数
	int Mid,ans=-1;
	while(L<=R){
		Mid=(L+R)>>1;
		if(cmpb[Mid].b<=x)ans=Mid,L=Mid+1;
		else R=Mid-1;
	}
	return ans;
}
bool check(ll x,ll y,int mm){
	int tot=0,now=0;
	ll lasx=x,lasy=y,xx=x,yy=y;
	bool flag=1;
	int las=0;
	while(flag&&tot<n){
		lasx=xx,lasy=yy;
		int now=finda(1,mm,lasx);
		if(now==-1){//没有找到符合条件的块
			flag=0;
			continue;
		}
		las=tot,tot=0;
		xx=x,yy=y;
		for(int i=1;i<=now-1;i++){
			int no=findb(l[i],r[i],lasy);
			if(no==-1)continue;//块内没有符合条件的物品
			xx+=csum[no]-csum[l[i]-1];
			yy+=dsum[no]-dsum[l[i]-1];//累加c、d的值
			tot+=no-l[i]+1;
		}
		for(int i=l[now];i<=r[now];i++)if(cmpb[i].a<=lasx&&cmpb[i].b<=lasy)tot++,xx+=cmpb[i].c,yy+=cmpb[i].d;//最后一个块暴力处理
		if(tot==las)flag=0;//即没有取到新的物品，就是说不能再更新了
	}
	return tot==n;//是否找全了所有物品
}
int main(){
	int T;
	scanf("%d%d",&T,&n);
	for(int i=1;i<=n;i++)scanf("%lld%lld%lld%lld",&cmpb[i].a,&cmpb[i].b,&cmpb[i].c,&cmpb[i].d),amax=max(cmpb[i].a,amax),bmax=max(bmax,cmpb[i].b);
	memset(mina,0x7f,sizeof mina);
	if(!n){
		printf("0 0\n");
		return 0;
	}
	int M=sqrt(n),m=n/M;
	for(int i=1;i<=m;i++)l[i]=r[i-1]+1,r[i]=M*i;
	if(r[m]<n)m++,l[m]=r[m-1]+1,r[m]=n;//分块
	sort(cmpb+1,cmpb+1+n,cmp_a);//按照a不降排序
	for(int i=1;i<=m;i++){
		for(int j=l[i];j<=r[i];j++)mina[i]=min(mina[i],cmpb[j].a);//预处理mina
		sort(cmpb+l[i],cmpb+r[i]+1,cmp_b);//块内按照b不降排序
		for(int j=l[i];j<=r[i];j++)csum[j]=csum[j-1]+cmpb[j].c,dsum[j]=dsum[j-1]+cmpb[j].d;//前缀和
	}
	ll la=0,ra=amax,mida;
	while(la<=ra){//二分初始的x值
		mida=(la+ra)>>1;
		ll lb=0,rb=bmax,midb;
		bool flag=0;//判断对于当前的x值，是否存在一个y使之合法
		while(lb<=rb){//二分初始的y值
			midb=(rb+lb)>>1;
			bool now=check(mida,midb,m);
			flag|=now;
			if(now)ansb=midb,ansa=mida,rb=midb-1;
			else lb=midb+1;
		}
		if(flag)ra=mida-1;
		else la=mida+1;
	}
	printf("%lld %lld\n",ansa,ansb);
	return 0;
}
```

---


# [常州市赛 2024] 游戏

## 题目背景

搬运自 <http://czoj.com.cn/p/953>。数据为民间数据。

## 题目描述

小 Y 和小 H 在玩游戏，由小 Y 开始，他们轮流操作一个长度为 $2n$ 的正整数序列，一次删除这个序列中的一个数，直到最后剩下 $2$个数时停止。若小 H 进行某次操作后序列形成一个回文序列或者这个序列初始本身就是回文序列，则小H胜利，否则小 Y 胜利。

小 Y 和小 H 都是极其聪明的（即每一步操作都是对他们自身而言的最优操作），小 Y 想知道最后他可以获胜吗？

回文序列是指一个序列倒过来跟本身一样的序列，如 $\{17,23,23,17\}$ 是一个回文序列，而 $\{1,2,1,2\}$ 则不是回文序列。

## 说明/提示

### 样例 $\textbf 1$ 解释

对于第一组测试数据，这个序列本身就是回文序列。

对于第二组测试数据，无论小 Y 删除 $1$ 还是 $2$，小 H 只要删除和小 Y 一样的数，最后就能剩下两个一样的数，形成回文序列。

### 样例 $\textbf 2$ 解释

小 Y 只要删除 $1$，小 H 无论删除哪个数，最后只能剩下两个不一样的数，无法形成回文序列。

### 数据范围

对于所有数据，$1\le T\le 5,1\le n≤10^5$，序列中正整数的大小不超过 $10^5$。

|测试点编号|特殊性质|
|:-:|:-:|
|$1\sim3$|$\alpha$|
|$4\sim 5$|$\beta$|
|$6\sim10$|无|

- 特殊性质 $\alpha$：$1\le n\le 2$。
- 特殊性质 $\beta$：保证序列中最多只有两种不同的数。


## 样例 #1

### 输入

```
2
3
1 1 2 2 1 1
2
1 1 2 2```

### 输出

```
Lose
Lose```

## 样例 #2

### 输入

```
1
2
1 1 2 3```

### 输出

```
Win```

# 题解

## 作者：Yxa_Sheep (赞：5)

`upd 2025.7.22`：提高了速度，成功达到 $108$ ms。

**[题目传送门](https://www.luogu.com.cn/problem/B4227)**
## 题意
如果小 Y 与小 H 共取完后小 Y 取完了所有重复的数字，输出 `Win`，否则输出 `Lose`。
## 思路
小 Y 取了 $n-1$ 次，每一次都是最优操作的情况下，他肯定会先取走重复的数字，使最后剩下的是两个不重复的数字。如果他取完所有重复数字的次数小于 $n$（小于等于 $n-1$）则输出 `Win`，否则输出 `Lose`。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, x, cnt;
bool a[100010];
int read() //快读
{
    int x = 0;
    char c = getchar_unlocked();
    while (c < '0' || c > '9')
        c = getchar_unlocked();
    while (c >= '0' && c <= '9' )
        x = x * 10 + c - '0', c = getchar_unlocked();
    return x;
} //我也不知道能快多少
int main()
{
	t = read(); //输入 t
	while (t--) //循环 t 次，在 t 为 0 时自动跳出，别问我为什么用，因为它短啊
	{
        memset(a, 0, sizeof(a)); //多测不清空，爆零两行泪
		n = read(), cnt = 0; //输入 n，cnt 初始为 0
		for (register int i = 1; i <= n << 1; i++) //听说 n << 1 比 n * 2 要快
		{
			if (a[x = read()]) //如果这个 a[x] 出现过（偷偷输入了一个 x）
				cnt++; //去掉重复数字的次数增加 1
            else//否则
				a[x] = 1; //把这个数标记出现过
		}
		if (cnt < n) //如果 cnt < n（cnt <= n - 1）
            printf("Win\n"); //输出 Win，记得换行
        else
            printf("Lose\n"); //输出 Lose，记得换行
	}
	return 0; //完美结束
}
```
我的代码是目前最优解，领先第二名 $50$ ms 左右（但是太长了）。
![](https://cdn.luogu.com.cn/upload/image_hosting/rhukq6w3.png)
题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/B4227)**

---

## 作者：sfb1363II (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/B4227)

## Solution

首先我们注意到，只剩下两个数时，如果这两个数相同，那么小 H 就会胜利。而所有超过两个数的胜利情况，每次无论小 Y 取什么数字，小 H 取一样的，就会得到相同的两个数。

因此，小 H 只需要考虑是否最后能够剩下两个相同的数字。

对应的，小 Y 则会尽可能避免最后剩下的两个数字是相同的，因此他会试图去掉那些存在两个及两个以上相同数字的数字。

将两个策略结合，如果存在两个及两个以上相同数字的数字的数量 $x \ge n$，那么小 Y 就没办法全部去掉，小 H 就能胜利。

## Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,cnt;
unordered_set<int> s;
void solve(){
    cin>>n;
    cnt=0;
    s.clear();
    for(int i=1;i<=2*n;i++){
        int x;
        cin>>x;
        if(s.count(x)) cnt++;
        else s.insert(x); 
    }
    if(cnt>=n) cout<<"Lose\n";
    else cout<<"Win\n";
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int T;
    cin>>T;
    while(T--) solve();
    return 0;
}
```

---

## 作者：czxuyang (赞：3)

## 前言
这题感觉只有黄，思路不是很困难。
## 思路
由题意可知，只剩下两个数时，如果这两个数相同，则是回文数，小 H 能取得胜利，否则无论怎么取小 Y 都能胜利。     

小 Y 的**最优选择**：尽量选择重复的数字，让剩余的两个数不为回文数。

小 H 的**最优选择**：让剩余的两个数变成两个相同的数。

经过推算可知：当重复的数 $cnt \ge n$ 则小 Y 无法去掉所有重复的数字，小 H 胜，否则小 Y 胜。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int t;
	cin>>t;
	while(t--){
		int n,x,cnt=0;
		cin>>n;
		memset(a,0,sizeof(a));
		for(int i=1;i<=n*2;i++){
			cin>>x;	
			if(a[x]>=1) cnt++;//记录重复数字的数量
			a[x]++;
		}
		if(cnt>=n) cout<<"Lose\n";
		else cout<<"Win\n";
	} 
	return 0;
}

```

---

## 作者：lizeyuhello (赞：3)

赛时没写出来，挂了。

# 题解 
先考虑只剩两个数的情况，当剩下的两个数相等时，小 H 胜。

小 Y 的最优策略是取重复的数，使最后剩下两个不相同的数。

小 H 的策略是取与小 Y 相同的数，使最后剩下两个相同的数。

当重复的数的种数 $cnt \ge n$ 时，小 Y 取不完重复的数，小 H 胜。否则小 Y 胜。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int T, n;
bool a[100005];

int main()
{
	scanf("%d", &T);
	while (T--)
	{
		scanf("%d", &n);
		memset(a, 0, sizeof(a)); //多测不清空，爆零两行泪
		int cnt = 0;
		for (int i = 1, x; i <= n * 2; ++i)
		{
			scanf("%d", &x);
			if (a[x])
				++cnt;
			a[x] = 1; //标记出现过的 x
		}
		puts(cnt >= n ? "Lose" : "Win");
	}
	return 0;
}
```

---

## 作者：chengjindong (赞：1)

[题目](https://www.luogu.com.cn/problem/B4227)

小 H：使最后两个数相同，要把所有个数 $< 2$ 的数全部去掉，使其他的数个数都 $\ge 2$。

小 Y：使最后两个数不相同，要把所有个数 $\ge 2$ 的数全部去掉，只剩 $1$ 个，使其他的数个数都 $< 2$。

那么，我们把小 Y 需要去掉的数算出来，记为 $ans$。

每个人只能取 $n-1$ 次，那么如果 $ans>n-1$，小 Y 就取不完了，此时输出 `Lose`，否则输出 `Win`。

代码：

```
#include<bits/stdc++.h>
#define int long long
#define double long double
#define debug(x) cout<<#x<<"->"<<x<<endl<<flush
#define endl '\n'
#define inf INT_MAX 
using namespace std;
const int N=1e7+7;
const int M=1e6+7;
const int mod=1e9+7;
const double eps=1e-6;
signed main(){
	ios::sync_with_stdio(0);
	ios_base::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int t;
	cin >>t;
	while(t--){
		int n;
		cin >>n;
		map<int,bool>m;
		int ans=0;
		for(int i=0;i<2*n;i++){
			int x;cin >>x;
			if(m[x])ans++;//之前就有过这个数，数量 >=2，ans 加一
			m[x]=1;//有过这个数了
		}
		if(ans>n-1){//小 Y 取不完，输了
			cout<<"Lose"<<endl;
		}else{//小 H 取不完，赢了
			cout<<"Win"<<endl;
		}
	}
	return 0;
}
```

---

## 作者：__MAMBA__ (赞：0)

如果他们都很聪明，那么他们就会选有重复的只要求出重复的组数,在判断组数是否大于 $$n$$ 。如果大于，就代表无论怎么选都会存在两个及两个以上有相同数字的数，那么小 Y 就没办法全部去掉，小 H 就能胜利。

AC 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int T, n;
int a[1000000];
int sum = 0;
int main(){
	cin >> T;
	while (T--){
		memset(a,0,sizeof(a));
		cin >> n;
		sum = 0;
		for (int i=1;i<=n*2;i++){
			int t;cin >> t;
			if (a[t]++) sum++;
		}
		if(sum >= n) cout << "Lose";
		else cout << "Win";
        cout << endl;
	}
}
```

---

## 作者：redfull66 (赞：0)

先考虑为什么小 H 只需要剩下的两个数相同就能获胜。

注意到当小 H 删除一个数后使序列成为回文序列，则小 Y 无论删除什么数，小 H 都能删除与之对应的数使序列依然为回文序列，最后一定会剩下两个相同的数。

所以，小 H 只需要考虑是否最后能够剩下两个相同的数。则小 Y 会尽量删除重复的数使剩下的两个数不相同。若重复的数 $ans \ge n$ 则小 Y 无法删除所有重复的数字，小 H 获胜，否则小 Y 获胜。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,x,ans,a[1000005];
int main(){
	cin>>T;
	while(T--){
		cin>>n,ans=0,memset(a,0,sizeof(a));
		for(int i=1;i<=2*n;i++)cin>>x,ans+=!!a[x],a[x]++;
		cout<<(ans>=n?"Lose":"Win")<<endl;
	}
	return 0;
}

```

---

## 作者：Yi_chen123 (赞：0)

## 思路

这道题最重要的还是思路，考虑推导小 Y、小 H 的最优策略。

首先看看小 Y，他的目标是要阻止小 H 在若干次操作后，剩下的两个数相同（这很显然是一个回文序列），因此，他一定要优先去掉序列中重复的数，也就是出现次数 $\ge 2$ 的数，而出现次数 $< 2$ 的数可以暂时不管。\
再思考小 H 的策略，他为了确保最后的两个数相同，一定要先去掉只出现 $1$ 次的数，出现次数 $\ge 2$ 的可以暂时不管，毕竟如果不及时去掉前者，~~最后剩下两个不同的数就老实了~~。

而题目问我们小 Y 能否获胜，实际上就是问我们小 Y 能否达成他的目标：把所有重复的数去掉，只剩下 $1$ 个。\
由于小 Y 只能操作 $n-1$ 次，我们记重复的数有 $cnt$ 个，只需要比较 $cnt$ 与 $n-1$ 的大小即可。当 $cnt > n-1$，即 $cnt \ge n$ 时，小 Y 没有足够的操作次数，显然不可能胜利。\
在代码中统计 $cnt$ 即可。

## 正解

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
	map<int, int> m;
	int T, n, p;
	cin >> T;
    while(T--){
    	m.clear(); //多测记得清空
        cin >> n;
        for(int i = 0; i < n * 2; ++i){
        	cin >> p;
        	m[p]++;
		}
        int cnt = 0;
        for(auto it = m.begin(); it != m.end(); ++it) cnt += (it->second - 1); //记得要减 1，因为小 Y 不会删掉不重复的数，即使是重复的数也会留一个
		cout << (cnt >= n ? "Lose" : "Win") << endl; //与 n 比较的是 cnt，不是 m.size()，我就是因为这个卡了很久
	}
	return 0;
}
```

---


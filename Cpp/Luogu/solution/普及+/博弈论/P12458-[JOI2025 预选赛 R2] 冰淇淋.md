# [JOI2025 预选赛 R2] 冰淇淋

## 题目描述

Alice 和 Bob 来到了 JOICE 冰淇淋店。这家店的顾客可以通过选择一种口味、一种蛋筒和一种配料来订购冰淇淋。

- 口味有 $X$ 种，价格分别为 $A_1, A_2, \ldots, A_X$。
- 蛋筒有 $Y$ 种，价格分别为 $B_1, B_2, \ldots, B_Y$。
- 配料有 $Z$ 种，价格分别为 $C_1, C_2, \ldots, C_Z$。

冰淇淋的价格是所选口味、蛋筒和配料价格的总和。给定一个整数 $P$，冰淇淋的**得分**定义为价格与 $P$ 之差的绝对值。

Alice 和 Bob 想要一起订购一个冰淇淋，但他们对冰淇淋的选择目标完全相反。具体来说，Alice 希望最大化得分，而 Bob 希望最小化得分。因此，他们决定按照以下方式选择冰淇淋的口味、蛋筒和配料：

1. 首先，Alice 选择口味。
2. 然后，Bob 选择蛋筒。
3. 最后，Alice 选择配料。

给定口味、蛋筒、配料的信息以及整数 $P$，编写一个程序，计算当双方都采取最佳策略时，最终订购的冰淇淋的得分。

## 说明/提示

### 样例解释
#### 样例 1 解释

- 口味价格为 5。
- 蛋筒价格为 10。
- 配料价格分别为 9、2、3。

Alice 首先选择价格为 5 的口味，Bob 选择价格为 10 的蛋筒。最后，Alice 选择价格为 2 的配料，使得总价格为 17，得分为 $|17-22|=5$。

### 输入例 2 解释

- 口味价格为 11。
- 蛋筒价格分别为 33、44。
- 配料价格分别为 40、60。

Alice 选择价格为 11 的口味，Bob 选择价格为 44 的蛋筒（因为这样可以使 Alice 选择价格为 60 的配料，得分为 $|115 - 100|=15$）。

### 输入例 3 解释

- 口味价格分别为 15、23。
- 蛋筒价格分别为 5、16。
- 配料价格分别为 23、45。

Alice 选择价格为 23 的口味，Bob 选择价格为 5 的蛋筒，Alice 选择价格为 45 的配料，总价格为 73，得分为 $|73-0|=73$。

### 输入例 4 解释

- 口味价格分别为 12、5、5。
- 蛋筒价格分别为 2、19、37。
- 配料价格分别为 10、5、15。

Alice 选择价格为 12 的口味，Bob 选择价格为 2 的蛋筒，Alice 选择价格为 15 的配料，总价格为 29，得分为 $|29 - 50| = 21$。然而，Bob 会选择价格为 19 的蛋筒，使得 Alice 选择价格为 15 的配料，总价格为 46，得分为 $|46-50|=4$。但最终得分为 14，因为 Alice 会选择最优策略。

### 数据范围

- $1 \leq X \leq 200\,000$。
- $1 \leq Y \leq 200\,000$。
- $1 \leq Z \leq 200\,000$。
- $0 \leq P \leq 3 \times 10^8$。
- $0 \leq A_i \leq 10^8$ ($1 \leq i \leq X$)。
- $0 \leq B_j \leq 10^8$ ($1 \leq j \leq Y$)。
- $0 \leq C_k \leq 10^8$ ($1 \leq k \leq Z$)。
- 输入的所有值都是整数。

### 子任务

1. (7 分) $X = 1$，$Y = 1$，$Z \leq 100$。
2. (17 分) $X = 1$，$Y \leq 100$，$Z \leq 100$。
3. (21 分) $X \leq 100$，$Y \leq 100$，$Z \leq 100$。
4. (22 分) $X \leq 4\,000$，$Y \leq 4\,000$，$Z \leq 4\,000$。
5. (33 分) 无额外约束。

## 样例 #1

### 输入

```
1 1 3 22
5
10
9 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
1 2 2 100
11
33 44
40 60```

### 输出

```
15```

## 样例 #3

### 输入

```
2 2 2 0
15 23
5 16
23 45```

### 输出

```
73```

## 样例 #4

### 输入

```
3 3 3 50
12 5 5
2 19 37
10 5 15```

### 输出

```
14```

# 题解

## 作者：TemplateClass (赞：8)

设 Alice、Bob 依次选了口味 $a$、蛋筒 $b$ 和配料 $c$，那么此时得分是 $|a + b + c - P|$。所以对于给定的 $a$ 和 $b$，最终的得分取决于 $c$ 的选择。因为 Alice 最后选，她会选 $c$ 中使得得分最大的那个。那对于 Bob 来说，选 $b$ 的时候要考虑到，不管自己怎么选，Alice 都会在选 $c$ 时最大化得分。所以 Bob 要选一个使得这个最大可能的得分最小的 $b$。

首先我们分析最后选 $c$ 的那一步，显然 Alice 希望总和尽可能地远离 $P$，不难发现只有 $c = \min\{C\}$ 或 $c = \max\{C\}$ 时有可能取到最值，也就是说对于给定的 $a, b$，最终的得分就是

$$\max(|a + b + \min\{C\} - P|, |a + b + \max\{C\} - P|)$$

现在，Bob 在选 $b$ 的时候，面对一个固定的 $a$，他的目标是选择一个 $b$，使得这个式子尽可能小。利用绝对值的几何含义，显然如果希望这两个式子的最大值最小，两边的 $a + b + \min\{C\}$ 和 $a + b + \max\{C\}$ 要尽可能对称地分布在 $P$ 的两侧，也就是说

$$b = -\frac{1}{2}[(a + \min\{C\} - P) + (a + \max\{C\} - P)]$$

也就是

$$b = P - a - \frac{1}{2}(\min\{C\} + \max\{C\})$$

于是我们先对 $B$ 进行排序，然后枚举 $a$，对于每个 $a$，二分得到 $B$ 中离上式最近的值，然后更新一下即可，时间复杂度 $O((X + Y) \log Y)$。

```cpp
#include<iostream>
#include<algorithm>

constexpr int N = 2e5 + 5;
int x, y, z, p, a[N], b[N], c[N], max = -1;

int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);
	
	std::cin >> x >> y >> z >> p;
	for(int i = 1; i <= x; ++i) std::cin >> a[i];
	for(int i = 1; i <= y; ++i) std::cin >> b[i];
	for(int i = 1; i <= z; ++i) std::cin >> c[i];
	int cmin = *std::min_element(c + 1, c + z + 1);
	int cmax = *std::max_element(c + 1, c + z + 1);
	std::sort(b + 1, b + y + 1);
	for(int i = 1; i <= x; ++i) {
		double bp = p - (cmin + cmax) / 2. - a[i]; int c;
		int P = std::lower_bound(b + 1, b + y + 1, bp) - b;
		if(P == 1) c = b[1]; else if(P == y + 1) c = b[y];
        else c = (b[P] - bp < bp - b[P - 1] ? b[P] : b[P - 1]);
		int s1 = std::abs(a[i] + c + cmin - p);
		int s2 = std::abs(a[i] + c + cmax - p);
		max = std::max(max, std::max(s1, s2));
	}
	std::cout << max << "\n";
	
	return 0;
}
```

---

## 作者：Abczzzzz (赞：4)

对于这种博弈的题目，倒着一层一层考虑：

如果口味和蛋筒都已确定，考虑 Alice 的选择。考虑选了价格为 $x$ 的配料，此前已花费 $y$：

- 如果 $x+y<P$ 且 $x$ 不是最小的，那取最小的会使 $P-(x+y)$ 增大，更优；
- 如果 $x+y>P$ 且 $x$ 不是最大的，那取最大的会使 $(x+y)-P$ 增大，更优。

发现最优的只可能在最大的或者最小的中，所以 Alice 直接二选一更优的即可。

如果只确定了口味，考虑 Bob 的选择。形式化地说，Bob 需要取一个蛋筒，使得 Alice 两种选择中的最大值最小。

我们发现代价是两个绝对值函数取 $\max$，我们发现最值取到中点的位置，二分即可。于是我们得到 $\mathcal O(N\log N)$ 的做法。

---

## 作者：Tairitempest (赞：2)

## [JOI2025 预选赛 R2] 冰淇淋

考虑 $A$ 与 $B$ 确定的情况，$C$ 一定选择最小值或者最大值最优。（如果本次选择的不是最小值或者最大值：若最终的 $A+B+C$ 小于 $P$，则 $C$ 选择最小值比本次选择的更优；若最终的 $A+B+C$ 大于 $P$，则 $C$ 选择最大值比本次选择的更优。）

考虑 $A$ 确定的情况：需要选择使 $\max(|A+B+C_{\min}-P|,|A+B+C_{\max}-P|)$ 最小的 $B$。可以证明这个函数可以看做一个关于 $B$ 的单峰函数，峰值在距离 $P-A-\frac{C_{\min}+C_{\max}}{2}$ 最近处，这个位置可以通过二分得到。

因此我们枚举 $A$，二分确定 $B$，然后计算最终结果就可以了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll x,y,z,p,A[200010],B[200010],C[200010],ans;

ll minC,maxC;

ll cal_ans(ll a,ll b){
	return max(abs(A[a]+B[b]+minC-p),abs(A[a]+B[b]+maxC-p));
}

int main(){
	cin>>x>>y>>z>>p;
	for(int i=1;i<=x;i++) cin>>A[i];
	for(int i=1;i<=y;i++) cin>>B[i];
	for(int i=1;i<=z;i++) cin>>C[i];
	sort(B+1,B+y+1);
	sort(C+1,C+z+1);
	minC=C[1];
	maxC=C[z];
	long double mid=((long double)(minC+maxC))/2;
	for(int i=1;i<=x;i++){
		ll id=lower_bound(B+1,B+y+1,p-mid-A[i])-B;
		if(id>1) ans=max(ans,min(cal_ans(i,id),cal_ans(i,id-1)));
		else ans=max(ans,cal_ans(i,id));
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：ycy1124 (赞：1)

### 题意
有三个数组 $A,B,C$ 和一个期望的美味值 $P$。现在有 Alice,Bob 两个人在博弈，首先由 Alice 从 $A$ 里面选择一个值，然后由 Bob 从 $B$ 里面选择一个值，最后再由 Alice 从 $C$ 里面选择一个值。Alice 期望最终选择的三个数的和减去 P 的绝对值最大，而 Bob 期望这三个数的和减去 P 的绝对值最小，试求两个人在最优策略下将会得到的最终值（指这三个值的总和减去 P）。
### 思路
由于在选择 $A$ 时我们并没有什么很好的策略，于是我们选择枚举选哪个 $A$。然后我们考虑如何选择最后一个数 $C$。

我们不难想到 Alice 最终一定会选择 $C$ 的最大值或者是 $C$ 的最小值。证明：我们假定 Alice 最后并没有选择 $C$ 里面的最大或最小值，我们设 $sum$ 表示最终的三个值的和，我们对其与 $P$ 的大小关系进行分类讨论。

1. $sum > P$ 此时显然我们选择最大的 $C$ 会使绝对值变大。
2. $sum = P$ 此时我们选最小或最大的 $C$ 显然都比这个优。
3. $sum < P$ 此时我们选最小的 $C$ 会使绝对值变大。

 因此，我们 $A$ 和 $C$ 的选择都已经考虑完毕。
 
 我们思考最后选择的 $B$，此时的 $A + C$ 已经是确定的了，我们给 $B$ 按从小到大排个序，此时 $b_1$ 为 $B$ 的最小值，$b_n$ 为 $B$ 的最大值，类似的，我们令 $c_1,c_n$ 分别为 $C$ 的最小最大值。我们继续进行分类讨论。
 
 1. $A + c_n + b_n < P$ 此时我们发现，我们无论怎么选一定会小于 $P$，此时我们最终的值将会是 $P - A - c_1 - b_i$。此时我们的 $B$ 选择 $b_n$ 是最优的。
 2. $A + c_1 + b_1 > P$ 此时我们无论怎么选一定大于 $P$ 那么我们的最终值为 $A + c_n + b_i - P$ 此时我们选择 $b_1$ 是最优的。
 3. 对于剩下的这种情况，我们可能选 $c_1$ 可能选 $c_n$ 但是由于之前的分讨我们发现只有在最终值大于 $P$ 时选 $c_n$ 否则选 $c_1$。因此我们只需要二分出一个 $b_i$ 使得 $\max(P - A - c_1 - b_i,A + c_n + b_i - P)$ 最小。

最后答案对所有枚举的 $A$ 的答案取个最大值。
### 代码
```cpp
#include<bits/stdc++.h>
#define flush() fwrite(obuf,1,O-obuf,stdout)
#define putchar(x) ((O==obuf+(1<<21))&&(flush(),O=obuf)),*O++=x
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
__inline__ int read(){
	register int x=0;
	register char ch=getchar();
	while(!(ch>='0'&&ch<='9'))
		ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+(ch^48),ch=getchar();
	return x;
}
__inline__ void write(register int x){
    (x>9)?write(x/10):void();
    putchar((x%10)^48);
}
struct Flush{
    ~Flush(){flush();}
}_;
#define N 200005 
using namespace std;
int a[N], b[N], c[N], x, y, z, p, Ans;
inline int Max(int x, int y)
{
	return x > y ? x : y;
}
inline int Min(int x, int y)
{
	return x < y ? x : y;
}
inline int get_w(int w)
{
	return Max(abs(w + c[1] - p), abs(w + c[z] - p));
}
inline int check(int w, int ww)
{
	if(w + b[1] >= p)
	{
		return 1;
	}
	else if(ww + b[y] <= p)
	{
		return y;
	} 
	else
	{
		int l = 1, r = y, ans = 0;
		while(l <= r)
		{
			int mid = (l + r >> 1);
			if(p - w - b[mid] < ww + b[mid] - p)
			{
				r = mid - 1;
				ans = mid - 1;
			}
			else
			{
				l = mid + 1;
				ans = mid;
			}
		}
		return ans;
	}
}
int main()
{
	x = read(), y = read(), z = read(), p = read();
	for(int i = 1; i <= x; i ++)
	{
		a[i] = read();
	}
	for(int i = 1; i <= y; i ++)
	{
		b[i] = read();
	}
	for(int i = 1; i <= z; i ++)
	{
		c[i] = read();
	}
	sort(b + 1, b + y + 1);
	sort(c + 1, c + z + 1);
	for(int i = 1; i <= x; i ++)
	{
		int w = 1e9;
		int ans = check(a[i] + c[1], a[i] + c[z]);
		for(int j = Max(ans, 1); j <= Min(ans + 1, y); j ++)//这里是因为作者的二分保证了求得最终值得最小值小于P所以要枚举到+1
		{
			w = Min(get_w(a[i] + b[j]), w);
		}
		Ans = Max(Ans, w);
	}
	write(Ans); 
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/231258339)。

---

## 作者：ArisakaMashiro (赞：1)

我们容易发现一个显然的结论：配料的选择实际上只需要考虑最大值与最小值，否则一定不优。证明十分简单，在此略过。

我们假设 $C$ 的最大值与最小值分别为 $C_{max}$ 与 $C_{min}$。

假设已经决定的口味与蛋筒价格之和为 $Q$，那么最后能够得到的冰淇淋价格最大值则为 $C_{max} + Q$，最小值为 $C_{min} + Q$，那么这就构成了一个价格区间。

又因为 Alice 希望得分最大，那么她必定会在这个区间中选择距离 $P$ 最远的那个价格，也即取 $\max(|C_{max} + Q - P|, |C_{min} + Q - P|)$，我们设这个函数为 $f(Q)$。

Bob 希望得分最小，假设口味的价格 $a$ 已经确定，那么对于所有的 $B_i$，我们令 $Q = a + B_i$，计算所有 $f(Q)$ 中的最小值即为对于口味价格 $a$ 能得到的最终得分，对于每个 $A_i$ 进行如上操作得到的最大值即为答案。时间复杂度 $O(XY)$。

考虑优化，我们发现随着 $B_i$ 的增大，价格区间的最小值与最大值不断增大，那么理性理解，可以发现 $f(Q)$ 的图像是一个类似于二次函数，在中间有最小值点且最小值点左单调递减、最小值右单调递增的图像。

那么我们的目的就是取得这个函数的最小值点，由于图像近似于一个二次函数，我们可以使用三分来求解其最小值。由此，我们将求解 $f(Q)$ 的最小值的时间压缩到了 $O(\log Y)$，算法总时间复杂度也变为了 $O(X\log Y)$，可以通过此题。

注意：在三分前需要对 $B$ 数组去重，否则在某些情况下本人的蒟蒻三分可能会炸掉。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int x, y, z, p, min_c = 2145141919, max_c, a[300000], b[300000], c[300000], ans_cmp = -1;
int check(int x){
	int l = 1, r = y;
	int ans_cmp = 2145141919;
	while(l <= r){
		int lmid = l + (r - l) / 3, rmid = r - (r - l) / 3;
		int vall = x + b[lmid], valr = x + b[rmid];
		int lef = min_c + vall, rig = max_c + valr;
		int lef_cnt = abs(lef - p), rig_cnt = abs(rig - p);
		int pre_cnt;
		if(lef_cnt > rig_cnt){
			pre_cnt = lef_cnt;
			l = lmid + 1;
		}
		else{
			pre_cnt = rig_cnt;
			r = rmid - 1;
		}
		if(pre_cnt < ans_cmp){
			ans_cmp = pre_cnt;
		}
	}
	return ans_cmp;
}
signed main(){
	cin >> x >> y >> z >> p;
	for(int i = 1; i <= x; i++){
		cin >> a[i];
	}
	for(int i = 1; i <= y; i++){
		cin >> b[i];
	}
	for(int i = 1; i <= z; i++){
		cin >> c[i];
		min_c = min(min_c, c[i]);
		max_c = max(max_c, c[i]);
	}
	sort(b + 1, b + 1 + y);
	y = unique(b + 1, b + 1 + y) - b;
    y--;
	for(int i = 1; i <= x; i++){
		int tmp_ans = check(a[i]);
		if(ans_cmp < tmp_ans){
			ans_cmp = tmp_ans;
		}
	}
	cout << ans_cmp;
}
``````

---

## 作者：CleverSea (赞：0)

~~此题 $143$ 个测试点？恐怖如斯……~~

### 题意简述

Alice 和 Bob 在定制冰淇淋，规则如下：
1. Alice 先选择一种口味（价格数组 $A$）。
2. Bob 接着选择一种蛋筒（价格数组 $B$）。
3. Alice 最后选择一种配料（价格数组 $C$）。

冰淇淋总价格 $S = A_i + B_j + C_k$，得分定义为 $|S - P|$。Alice 的目标是最大化得分，Bob 的目标是最小化得分。双方均采取最优策略，计算最终得分。

### 思路

#### 一个典型的博弈论题目。

游戏分为三个阶段，采用**逆向分析**可得：

1. 首先，当已知 $A_i$ 和 $B_j$，Alice 会选择 $C_k$ 最大化 $|A_i + B_j + C_k - P|$。
2. 然后，当已知 $A_i$，Bob 会选择 $B_j$ 最小化 Alice 在第 $3$ 步能获得的最大得分。
3. 最后，Alice 会选择 $A_i$ 最大化 Bob 在第二步中最小化的得分。

#### 形式化地，定义：

- $D = \min(C)$，$E = \max(C)$（配料的最小和最大价格）。
- 对于固定 $A_i$ 和 $B_j$，得分为：
  $$
  f(A_i, B_j) = \max\left(|A_i + B_j + D - P|, |A_i + B_j + E - P|\right)
  $$
- Bob 的目标：$g(A_i) = \min_{B_j} f(A_i, B_j)$。
- Alice 的目标：$\text{ans} = \max_{A_i} g(A_i)$。

此时我们注意到，函数 $f(s)$（$s = A_i + B_j$) 在 $s$ 的不同区间有不同行为：
1. **$s \leq P - E$**：$f(s) = P - s - D$（递减）。
2. **$P - E < s < P - D$**：$f(s) = \max(P - s - D, s + E - P)$（先减后增，最小值在 $s_0 = P - \frac{D+E}{2}$）。
3. **$s \geq P - D$**：$f(s) = s + E - P$（递增）。

#### 综上，本题策略为：

对于每个 $A_i$：

1. 计算关键点：
   - $key_1 = P - E - A_i$（区间 $I$ 的上界）。
   - $key_2 = P - D - A_i$（区间 $III$ 的下界）。
   - $s_0 = \frac{2P - D - E}{2} - A_i$（区间 $II$ 的最小值点）。

2. 在排序后的 $B$ 数组中搜索候选 $B_j$：

   - **区间 $\mathrm{I}$**：取 $\leq key_1$ 的最大 $B_j$。
   - **区间 $\mathrm{III}$**：取 $\geq key_2$ 的最小 $B_j$。
   - **区间 $\mathrm{II}$**：取最接近 $s_0$ 的两个 $B_j$（左侧最大和右侧最小且在 $(key_1, key_2)$ 内）。

3. 计算每个候选 $B_j$ 对应的 $f(s)$，取最小值作为 $g(A_i)$。

4. 答案取所有 $g(A_i)$ 的最大值。

### 美汁汁（$\text{zhīr}$）的代码时间~
```cpp
#include <bits/stdc++.h>
#define Code using
#define by namespace
#define CleverSea std
Code by CleverSea;

const int N = 2e5 + 10;

long long A[N], B[N], C[N];

int main() {
    long long X, Y, Z, P;
    scanf("%lld %lld %lld %lld", &X, &Y, &Z, &P);
    for (int i = 0; i < X; i++) {
        scanf("%lld", &A[i]);
    }
    for (int i = 0; i < Y; i++) {
        scanf("%lld", &B[i]);
    }
    for (int i = 0; i < Z; i++) {
        scanf("%lld", &C[i]);
    }
    sort(B, B + Y);
    // 计算配料的最小值D和最大值E
    long long minC = C[0], maxC = C[0];
    for (int i = 1; i < Z; i++) {
        if (C[i] < minC) minC = C[i];
        if (C[i] > maxC) maxC = C[i];
    }
    long long ans = 0;
    // 遍历每种口味
    for (int i = 0; i < X; i++) {
        long long key1 = P - maxC - A[i]; // 区间I上界
        long long key2 = P - minC - A[i]; // 区间III下界
        vector<long long> cf; // 存储候选得分
        // 候选1：区间I中最大的Bj（<=key1）
        int pos1 = upper_bound(B, B + Y, key1) - B;
        if (pos1 > 0) {
            long long Bj = B[pos1 - 1];
            long long s = A[i] + Bj;
            long long fv1 = llabs(s + minC - P);
            long long fv2 = llabs(s + maxC - P);
            long long fv = max(fv1, fv2);
            cf.push_back(fv);
        }
        // 候选2：区间III中最小的Bj（>=key2）
        int pos3 = lower_bound(B, B + Y, key2) - B;
        if (pos3 < Y) {
            long long Bj = B[pos3];
            long long s = A[i] + Bj;
            long long fv1 = llabs(s + minC - P);
            long long fv2 = llabs(s + maxC - P);
            long long fv = max(fv1, fv2);
            cf.push_back(fv);
        }
        // 计算区间II的理想点s0
        double s0v = (2.0 * P - minC - maxC) / 2 - A[i];
        // 候选3：区间II中小于等于s0v的最大Bj
        long long flov = (long long)floor(s0v);
        int posl = upper_bound(B, B + Y, flov) - B;
        if (posl > 0) {
            long long can = B[posl - 1];
            if (can > key1 && can < key2) { // 在开区间内
                long long s = A[i] + can;
                long long fv = max(llabs(s + minC - P), llabs(s + maxC - P));
                cf.push_back(fv);
            }
        }
        // 候选4：区间II中大于等于s0v的最小Bj
        long long ceiv = (long long)ceil(s0v);
        int posh = lower_bound(B, B + Y, ceiv) - B;
        if (posh < Y) {
            long long can = B[posh];
            if (can > key1 && can < key2) { // 在开区间内
                long long s = A[i] + can;
                long long fv = max(llabs(s + minC - P), llabs(s + maxC - P));
                cf.push_back(fv);
            }
        }
        // 确保候选列表非空（理论上不会为空，但还是检查一下）
        if (!cf.empty()) {
            long long minv = *min_element(cf.begin(), cf.end());
            if (minv > ans) {
                ans = minv;
            }
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

其中排序 $B$ 数组 $O(Y \log Y)$，遍历 $A$ 数组，每个元素在 $B$ 上二分查找 $O(\log Y)$，$X$ 个元素 $O(X \log Y)$，总复杂度 $O((X + Y) \log Y)$。

---

## 作者：DFM_O (赞：0)

## [P12458 题目](https://www.luogu.com.cn/problem/P12458)

### 解题思路
首先先将序列 $B$ 和序列 $C$ 从小到大排序，设选择的口味为第 $m$ 种，蛋筒为第 $n$ 种，配料为第 $q$ 种。

不难发现当我们确定了 $m$ 和 $n$ 时由于 Alice 想让 $|A_m+B_n+C_q-P|$ 尽量大，显然 Alice 会选择使得 $q=1$ 或 $q=Z$，即选择序列 $C$ 中的最大值或最小值，那么答案即为 $\max(|A_m+B_n+C_1-P|,|A_m+B_n+C_Z-P|)$，我们可以把这个值看作在数轴上 $A_m+B_n+C_1$ 与 $P$ 的距离和 $A_m+B_n+C_Z$ 与 $P$ 的距离的最大值。

注意到不论 $m$ 和 $n$ 取何值，$A_m+B_n+C_Z$ 与 $A_m+B_n+C_1$ 的差为定值，必为 $C_Z-C_1$，那么显然 $A_m+B_n+C_Z$ 与 $A_m+B_n+C_1$ 中至少有一个数在数轴上与 $P$ 的距离大于等于 $\frac{C_Z-C_1}{2}$，则当 $A_m+B_n+C_Z=P+\frac{C_Z-C_1}{2},A_m+B_n+C_1=P-\frac{C_Z-C_1}{2}$ 时 $\max(|A_m+B_n+C_1-P|,|A_m+B_n+C_Z-P|)$ 取到最小值。

枚举 $m$ 的值，因为 Bob 希望最后的值尽量小，那么他就会使得 $A_m+B_n+C_Z$ 尽量接近 $P+\frac{C_Z-C_1}{2}$，二分即可求出满足 Bob 要求的 $n$ 的值，此时我们就可以求出答案了，将这 $X$ 个答案取最大值即为最后的答案。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[200002],b[200002],c[200002];
signed main()
{
    ios::sync_with_stdio(false);
    int x,y,z,p;
    cin>>x>>y>>z>>p;
    for(int i=1;i<=x;i++)
    	cin>>a[i];
    for(int i=1;i<=y;i++)
    	cin>>b[i];
    for(int i=1;i<=z;i++)
    	cin>>c[i];
    sort(b+1,b+y+1),sort(c+1,c+z+1);
    int minb=b[1],maxb=b[y],minc=c[1],maxc=c[z];
    int maxx=0;
    for(int i=1;i<=x;i++)
    {
		int liy=p-a[i]-(minc+maxc)/2,st3=upper_bound(b+1,b+y+1,liy)-b,g;
		if(liy>=b[y])
			g=b[y];
		else
		{
			if(liy<b[1])
				g=b[1];
			else
			{
				if(b[st3]-liy<=liy-b[st3-1])
					g=b[st3];
				else
					g=b[st3-1];
			}
		}
		int ans=max(p-a[i]-g-minc,a[i]+g+maxc-p);
		maxx=max(maxx,ans);
	}
	cout<<maxx;
    return 0;
}
```

---


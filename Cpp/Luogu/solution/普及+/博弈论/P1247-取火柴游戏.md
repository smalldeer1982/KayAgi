# 取火柴游戏

## 题目描述

输入 $k$ 及 $k$ 个整数 $n_1,n_2,\cdots,n_k$，表示有 $k$ 堆火柴棒，第 $i$ 堆火柴棒的根数为 $n_i$；接着便是你和计算机取火柴棒的对弈游戏。取的规则如下：每次可以从一堆中取走若干根火柴，也可以一堆全部取走，但不允许跨堆取，也不允许不取。

谁取走最后一根火柴为胜利者。

例如：$k=2$，$n_1=n_2=2$，A 代表你，P 代表计算机，若决定 A 先取：

- A：$(2,2) \rightarrow (1,2)$，即从第一堆中取一根。
- P：$(1,2) \rightarrow (1,1)$，即从第二堆中取一根。
- A：$(1,1) \rightarrow (1,0)$。
- P：$(1,0) \rightarrow (0,0)$。P 胜利。

如果决定 $A$ 后取：

- P：$(2,2) \rightarrow (2,0)$。
- A：$(2,0) \rightarrow (0,0)$。A 胜利。

又如 $k=3$，$n_1=1$，$n_2=2$，$n_3=3$，$A$ 决定后取：

- P：$(1,2,3) \rightarrow (0,2,3)$。
- A：$(0,2,3) \rightarrow (0,2,2)$。
- A 已将游戏归结为 $(2,2)$ 的情况，不管 P 如何取 A 都必胜。

编一个程序，在给出初始状态之后，判断是先取必胜还是先取必败，如果是先取必胜，请输出第一次该如何取。如果是先取必败，则输出 `lose`。

## 说明/提示

### 数据范围及约定

对于全部数据，$k \le 500000$，$n_i \le 10^9$。

## 样例 #1

### 输入

```
3
3 6 9
```

### 输出

```
4 3
3 6 5
```

## 样例 #2

### 输入

```
4
15 22 19 10```

### 输出

```
lose```

# 题解

## 作者：kuansoudafahao (赞：138)

感觉题解的证明都不是很详细啊。。。。。。那本蒟蒻来发一下从网上+自己理解的证明吧。

设$(a,b,c)$为三堆石子的个数$(a>=0,b>=0,c>=0)$，先手为 甲；后手为乙。

必败局势，一般称为奇异局势，显然$(0,0,0)$是一个奇异局势（因为谁面对这种局势，都无法做到游戏给出的条件：每次最少取一个）

讨论局势是必败还是必胜，都是相对于首先面对此局势者来说。因此站在甲的角度来讨论。甲面对$(0,0,0)$必输。

当甲面对$(a,a,0)$，甲每次拿$x$，乙随后也跟着拿$x$，因此甲面对的局势始终是$(a-x,a-x,0)$。因此转化为甲最终都会面对$(0,0,0)$，因此甲必输。

因为游戏是两个人交替进行。由此可得，如果局势（a,b,c）是必胜局势，那么甲就有策略，使得拿走某堆中的$x$个物品后，一般地设为$(a-x,b,c)=(a',b,c)$。此时$(a',b,c)$就是一个必败的局面。反之，必败的局面可以变为必胜的局面。

更一般地，考虑$N>=2$堆石子的情况。每堆数量为$(a_1,a_2,...,a_N)$ 

定理：$(a_1,a_2,...,a_N)$为奇异局势当且仅当$a_1\oplus a_2\oplus ...\oplus a_N=0$   

证明：$(a_1,a_2,...,a_N)=(0,0,...0)$时显然成立。

当$(a_1,a_2,...,a_N)$不为$(0,0,...0)$时，若$a_1\oplus a_2\oplus ...\oplus a_N=k\neq0$   ，显然$k$的最高位为$1$。

则一定存在一个$a_i(1<=i<=N)$，它在$k$的最高位的值为$1$。（若$a_1,a_2,...,a_N$在$k$的最高位处都为$0$，那么异或运算规则，不可能得到$k$的最高位为$1$）

因此，$a_i\oplus k<a_i$（因为最高位变为$0$了）

设$a_{i'}=a_i\oplus k$，则$a_1\oplus a_2 \oplus...\oplus a_{i'}...\oplus a_N=a_1\oplus a_2\oplus ...\oplus a_N \oplus k$ (代入$a_{i'}=a_i\oplus k$，并由异或的交换律得到)      $=k\oplus k=0$

因此当$a_1\oplus a_2\oplus ...\oplus a_N=k\neq0$时，存在移动$a_i->a_{i'}$ （即$a_i-a_{i'}>0$）使得$a_1\oplus a_2 \oplus...\oplus a_i...\oplus a_N=0$

若$a_1\oplus a_2 \oplus...\oplus a_i...\oplus a_N=0$，则不存在合法移动，使得$a_1\oplus a_2 \oplus...\oplus a_{i'}...\oplus a_N=0$。

因为若$a_1\oplus a_2 \oplus...\oplus a_{i'}...\oplus a_N=a_1\oplus a_2 \oplus...\oplus a_{i'}...\oplus a_N=0$，则两边同时异或$a_1$,可得$a_2\oplus ...a_i\oplus ...\oplus a_N=a_2\oplus ...a_{i'}\oplus ...\oplus a_N$，
继续两边异或$a_3...a_N$(除了共有的$a_i,a_{i'}$)，由此可推出$a_i=a_{i'}$。显然这不是合法的移动。

由以上证明得出

- $a_1\oplus a_2\oplus ...\oplus a_N=k\neq0$，一定存在一步特定移动使得$a_1\oplus a_2\oplus ...\oplus a_N=0$；

- $a_1\oplus a_2 \oplus...\oplus a_i...\oplus a_N=0$，不存在一步合法移动使得$a_1\oplus a_2 \oplus...\oplus a_{i'}...\oplus a_N$再次为$0$，       
- 当$a_1\oplus a_2 \oplus...\oplus a_i...\oplus a_N=0$时，下一步必然为$a_1\oplus a_2 \oplus...\oplus a_{i'}...\oplus a_N\neq0$，再下一步可以变为$a_1\oplus a_2 \oplus...\oplus a_{i''}...\oplus a_N=0$。

必要性：由$(a_1,a_2,...,a_N)$为奇异局势（必败局势），考虑甲先乙后。

假设$a_1\oplus a_2 \oplus...\oplus a_i...\oplus a_N\neq0$,那么甲通过移动，可使$a_1\oplus a_2 \oplus...\oplus a_{i'}...\oplus a_N=0$。如此一直下去，每次乙都只能面对$a_1\oplus a_2\oplus ... a_i\oplus ...\oplus a_N=0$的局势。

由于游戏的结束点必然为$(0,0,...0)$，因此乙最终将面对$(0,0,0)$。在乙面对$(0,0,0)$的上一步，设为$(b_1,...b_N)$,此时$b_1\oplus ... \oplus b_N\neq0$。

但乙最终先面对了$(0,0,...0)$，显然是甲胜，这与$(a_1,a_2,...,a_N)$为奇异局势（必败局势，甲必败）矛盾。

因此必有$a_1\oplus a_2 \oplus...\oplus a_i...\oplus a_N=0$。

充分性：由$a_1\oplus a_2\oplus ...\oplus a_N=0$ ，由上，乙始终有办法让甲面对的局势始终是$x_1\oplus x_2\oplus ...\oplus x_N=0$。因此甲最终面对的必然是$(0,0,...0)$的局势，而$(0,0,...0)$就是个奇异局势。

证毕。

理解了奇异局势的判定后，这道题就很好做了。代码也超级简单。

```c++
#include <cstdio>

int n;
int a[500005];

int main()
{
    scanf("%d",&n);
    int check=0;
    for(int i=1; i<=n; i++)
    {
        scanf("%d",&a[i]);
        check^=a[i];
    }
    if(!check)
    {
        printf("lose\n");
        return 0;
    }
    for(int i=1; i<=n; i++)
    {
        if((check^a[i])<a[i])
        {
            printf("%d %d\n",a[i]-(check^a[i]),i);
            for(int j=1; j<=n; j++)
                if(j!=i)
                    printf("%d ",a[j]);
                else    printf("%d ",check^a[i]);
            break;
        }
    }
    return 0;
}
```

---

## 作者：revenger (赞：43)

经典Nim游戏模型

这个游戏的SG值就是各堆数量的异或和，当SG为0时先手必败，否则先手就要把SG变为0

先检验SG值，如果是0输出lose，否则我们按照以下原则行动

有n个数的异或值不为0 现在要减少一个数使异或值为0

假设n个数：a1 ,a2,a3...an

a1^a2^a3^..^an=k

那么我们可以对一个数进行操作,假设这个数是a1，设a1^k=a'，a'^a2^a3^...^an=a1^a2^a3^...^an^k=k^k=0;

所以我们只需要从头到尾检验每个数异或k的值是否比它小(因为是要减少)，遇到小的直接输出ai-ai^k即可

代码：

```cpp
#include<cstdio>
int k,n[500002];
int main()
{
    scanf("%d",&k);int x=0;
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&n[i]);
        x^=n[i];
    }
    if(!x){puts("lose");return 0;}
    for(int i=1;i<=k;i++)
    {
        if((n[i]^x)>=n[i]) continue;
        printf("%d %d\n",(n[i]-(n[i]^x)),i);
        n[i]=n[i]^x;
        break;
    }
    for(int i=1;i<=k;i++)
    printf("%d ",n[i]);
}
```

---

## 作者：wyhwyh (赞：37)

# 是时候来一发暴力的题解了！

#### 本人蒟蒻一枚，认为其他大佬的题解中的数学证明过程都太过深奥~~至少我是看不懂~~

# $$so!$$

本着为像我这样的蒟蒻服务的精神，暴力出奇迹的福利重磅来袭！

$($由于我这样的初中蒟蒻不$(bu)$喜$(hui)$欢$(xie)$数学证明，所以题解中的证明全是其他大佬的题解已经多次证明过的，这里就不再啰嗦了。$)$

------逗比与正经的分界线→_→------

### 思路就是先判断是否先手必胜，如果不是，就直接输出$lose$，如果是的话，一根一根的取，就能得到正解啦！注释详见代码。

[**优化前的90分TlE代码：**](https://www.luogu.org/recordnew/show/16132957)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define N 500001
using namespace std;
int n;
int a[N];

int read()
{
    int ans=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        ans=(ans<<1)+(ans<<3)+ch-'0';
        ch=getchar();
    }
    return ans;
}

bool pd()
{
    int ans=0;
    for(int i=1;i<=n;++i)
        ans^=a[i];
    return ans;
}

bool in()
{
    n=read();
    int ans=0;
    for(int i=1;i<=n;++i)
        a[i]=read();
    return pd();
}

void out(int aaa,int bbb)
{
    printf("%d %d\n",aaa,bbb);
    for(int i=1;i<=n;++i)
        printf("%d ",a[i]);
}

void work()
{
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=a[i];++j)
        {
            a[i]-=j;
            if(!pd())
            {
                out(j,i);
                return;
            }
            a[i]+=j;
        }
    }
}

int main()
{
    if(!in())
    {
        printf("lose\n");
        return 0;
    }
    work();
    return 0;
}
```

[**优化后的100分AC代码：**~~其实就是减少了点常数~~](https://www.luogu.org/recordnew/show/16134114)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define N 500001
using namespace std;
int n;
int a[N];

int read()//读入。  
{
	int ans=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		ans=(ans<<1)+(ans<<3)+ch-'0';
		ch=getchar();
	}
	return ans;
}

int xorexptx(int x)//xor except x :求a数组内除第x个之外的异或值。  
{
	int ans=0;
	for(int i=1;i<=n;++i)
		if(i!=x)
			ans^=a[i];
	return ans;
}

void out(int aaa,int bbb)//输出，不多解释。  
{
	printf("%d %d\n",aaa,bbb);
	for(int i=1;i<=n;++i)
		printf("%d ",a[i]);
}

void work()
{
	for(int i=1;i<=n;++i)
	{
		int num=xorexptx(i);//一个小小的优化：把其他n-1个数异或起来，就不用再多算了。  
		for(int j=1;j<=a[i];++j)
		{
			a[i]-=j;
			if(!(num^a[i]))//异或上该数，然后再看能不能先手必败（此时计算机是先手）。  
			{
				out(j,i);//如果能，就输出。  
				return;//返回，结束程序。  
			}
			a[i]+=j;
		}
	}
}

int main()
{
	n=read();
	int ans=0;
	for(int i=1;i<=n;++i)
		a[i]=read(),ans^=a[i];
	if(!ans)//如果他们的异或和=0,那么先手必败，证明略。  
	{
		printf("lose\n");
		return 0;
	}
	work();//否则先手必胜。 
	return 0;
}
```

萌新第一次写题解，还望各位大佬多多支持。【Bye】

---

## 作者：BuXiangJuanLe (赞：19)

大部分题解对于何时必胜何时必败讲得已经很清楚了，这里讲讲取火柴的方案是如何找的

其实用异或结合律就很好懂了

**一、还是啰嗦的上个定理：**

以三堆为例，

如果$a_1\,xor\,a_2\,xor\,a_3\,=\,0 $，则先手必败

如果$a_1\,xor\,a_2\,xor\,a_3\,≠\,0 $，则先手必胜

~~证明见其他题解~~ ~~其实我是感性理解~~

**二、如果先手必胜应该怎么取火柴**

先手必胜，即先手可以拿走一些火柴，使得**后手必败**，而必败态是火柴堆的异或和为零；那么我们求的，就是先手拿走一些火柴后，新的火柴堆异或和为零的方案。设原异或和为$X$，易知

$$a_1\,xor\,a_2\,xor\,a_3\,=\,X$$

$$a_1\,xor\,a_2\,xor\,a_3\,xor\,X\,=\,0$$

运用异或结合律（这里以结合第二个为例）

$$a_1\,xor(a_2\,xor\,X)xor\,a_3\,\,=\,0$$

那么，我们可以把$(a_2\,xor\,X)$视为新的一堆火柴，当$a_2$变为$(a_2\,xor\,X)$时异或和为零，后手便必败。当然，由于这是**取**火柴游戏，所以$(a_2\,xor\,X)$必须小于$a_2$才行。

异或写在后面一定要加括号！ Orz

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[500008], X; // n : k

int main(){
    cin>>n;
    for(int i=1 ; i<=n ; i++){
        cin>>a[i];
        X ^= a[i]; //求异或和
    }

    if(!X){
        cout<<"lose\n";
        return 0;
    }

    for(int i=1 ; i<=n ; i++){
        if((a[i]^X) < a[i]){ //合法
            cout<<a[i] - (a[i]^X)<<' '<<i<<endl; //ai变为ai^X, 则拿走了ai - ai^X
            a[i] = a[i]^X;
            break; //先找到的肯定是字典序最小的，立即退出
        }
    }
    for(int i=1 ; i<=n ; i++) cout<<a[i]<<' ';
    return 0;
}
```

---

## 作者：Mingoal (赞：18)

做法：

$i).$求出$k=a_1$^$a_2$^$...$^$a_n$，若$k>0$，则先取必胜，否则必败。

$ii).$若$k=0$，把其中一个$a_i$变成$a_i$^$k$，但$a_i$^$k$要小于$a_i$


证明：

$i).$数学归纳法

设当$i=0...n$时$sg(i)=i$成立

$1.$当$n=0$时$sg(0)=0$，成立

$2.$当$i=n+1$时，因为可以取小于$n+1$的任意多个火柴，所以后继状态是$0..n$，所以：$sg(i)$

$=mem(sg(0),sg(1),...sg(n))$

$=mem(0,1,2,...,n)$

$=n+1$
所以$sg(i)=i$

$k=sg(a_1)$^$sg(a_2)$^$...$^$sg(a_n)$

$=a_1$^$a_2$^$...$^$a_n$

命题得证


$ii).$因为先手是必胜态，所以要使对手是必败态，则改变了一个ai后k要变成0

因为$k$^$k=0$，所以$a_1$^$a_2$^$...$^$a_n$^$k=0$

所以$a_1$^$a_2$^$...(a_i$^$k)$^$a_{i+1}$^$...$^$a_n=0$

只要把一个$a_i$变成$a_i$^$k$即可，但因为必须要取，所以必须$a_i<a_i$^$k$。

得证

可能我证得不太严谨，如果谁发现了错误请私信一下，我立刻修改

——————————————————————

感谢@popo 的指正，已修改

评论区@多弗桃 指出我没证一定有第$x$堆石子使$a_x$^$k<a_x$

这确实是我的疏忽，但是@学委 已经帮我证了，感谢


---

## 作者：Lance1ot (赞：6)


首先我们来看一个其他的游戏。（以下游戏只有两个人参与，且足够聪明）

两个人在一张圆形的桌子上放等大的盘子，最后一个无法放盘子的人输掉比赛

很显然，先手必胜。

为什么？ 第一个人可以将盘子放在桌子的中心。

然后只要第二个人可以放置盘子，我们就在其中心对称的位置上放盘子。

如此，只要后手可以放，我先手就一定能放

可以看出，有时候如果处于先手必胜的状态时，模仿对手的策略不妨是个好方法。这可以保证如果游戏可以进行下去的话，先手就一定能进行下去。

-----------------------

我们再来看一个nim游戏的弱化版

有两个火柴堆，每堆的火柴数不一定相同，每次一个人只能从一堆中选取若干个火柴并取走。没有火柴可取的人输

~~好像这和上个题没有什么关系qwq~~

我们假设两个火柴堆的数目都相同。那么肯定是先手必输

为什么？因为后手总可以从另一堆中取的和先手上一次取得一样的火柴。

只要先手可以取，后手就可以取。

所有该游戏的判定条件是，若两堆相等，先手必输，否则，先手必胜，先手总可以将两堆取成一样多

--------------------------
>先手必胜时总有一种策略可以转移到后手必败
后手必败总是会转移到先手必胜

好像大佬如此说过

--------------------------

然后我们看van♂整版nim

[P1247 取火柴游戏](https://www.luogu.org/problemnew/show/P1247)

先说结论，若所有火柴堆异或起来的值为0的话，先手必败，否则先手必胜

# 啥？mengbi qwq

(ﾉ｀⊿´)ﾉ为什么和异或结合起来的啊喂

这是得益于~~毒瘤的~~二进制和~~更毒瘤的~~异或

异或有一个特殊的规律，就是一堆数异或时，若在同一个二进制位上1的个数是偶数，那么这一位异或起来以后是0，否则为1

二进制的话就是可以使用0/1表示所有数字


------------------------------

我们来看上一个游戏，我们将这两堆的剩余的火柴数转变成二进制。

发现我们先手取走一个数，就是改变其二进制为上的1的个数（只考虑奇偶性），而后手再去取的话就是将其奇偶性再变回来

-------------------------------

然后我们再回去看为什么异或和是0时先手必输，因为先手拿走了某些火柴时，我们可以根据其拿走火柴的二进制表示，在其他一堆中拿走一些一些数字，使得其异或和重新为0；

怎么搞呢？  我们可以拿走一些数，也就是减某一个数，使得先手拿完后，（啰嗦警告）

所有堆中的每个二进制上的一的个数的和，我们总可以通过加减一个数，达到在某一个二进制位的1的个数进行加一or减一的效果

使得某一位二进制上的1的个数变为偶数。

从而使得游戏又恢复到了一开始的局面

end......

~~sg函数中好像也有这个思想qwq~~

此题代码并没有qwq

看看其他人的吧，code大体都是一样的

---

## 作者：DavidW (赞：6)

这道题是一道很经典的**Nim博弈**裸题

对于这类问题，有一定理存在：

当先手必胜时，**当且仅当**

$A_1\ xor\ A_2\ xor\ \dots\ xor\ A_n≠0$

证明：

设$A_1\ xor\ A_2\ xor\ \dots\ xor\ A_n=x$

所有火柴被取光时为必败局面，此时 $x=0$。

对于任意一个局面，如果x≠0，则设x的最高位（为1）在第k位，那么根据异或的定义，显然至少存在一堆火柴，它的第k位是1. 而这一堆火柴显然有$A_i\ xor\ x<A_i$，那么就从这一堆火柴中取走 $(A_i-A_i\ xor\ x)$ 根火柴，使其变为$A_i\ xor\ x$ 根，将这个数据带入原计算式，得到 $A_1\ xor\ A_2\ xor\ \dots\ xor\ A_n\ xor\ x$，即 $x\ xor\ x$，等于0.

对于任意一个局面，如果$x=0$，则无论如何取火柴，计算式均不等于 $0$ . 用反证法，设 $A_i$ 被取成了$A_{i}\ '$，且$A_1\ xor\ A_2\ xor\ \dots\ xor\ A_{i}\ '\ xor\ \dots\ xor\ A_n=0$
$=A_1\ xor\ A_2\ xor\ \dots\ xor\ A_i\ xor\ \dots\ xor\ A_n$，消去相同项就得到$A_i=A_{i}\ '$，与题设不能不取矛盾，所以原命题成立。

综上，再使用数学归纳法可证明定理。

有了这个定理，那么这道题就很容易做了。

考虑先手必胜的情况，我们只需要找到 $x$ 的最高位，记为 $i$ ，再在 $a$ 中顺序查找第 $i$ 位为$1$的第一堆，就得到了答案。

再证明：当 $A_i\ xor\ x<A_i$ 时，满足 $A_i$ 的第 $i$ 位为$1$

当$Ai<x$时，显然$A_i\ xor\ x>A_i$

当$Ai≥x$时，位数高于 $x$ 的位保留，若第 $i$ 位为$0$，则改为$1$，显然$A_i\ xor\ x>Ai$

所以命题得证。

以下为代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<32> x;
bitset<32> a[500010];
int main(){
	int n,i,j;
	scanf("%d%d",&n,&a[1]);
	x=a[1];
	for(i=2;i<=n;i++){
		int tmp;
		scanf("%d",&tmp);
		a[i]=tmp;x^=a[i];
	}
	if(x==0){
		cout<<"lose"<<endl;//如果异或值为0则必败
		return 0;
	}
	for(i=31;i>=0&&!x.test(i);i--);//找到x的最高位
	for(j=1;j<=n&&!a[j].test(i);j++);//顺序查找a中第一个第i位为1的堆
	int val=a[j].to_ulong()-(a[j]^x).to_ulong();//算出需要减去的值
	a[j]=a[j]^x;
	printf("%d %d\n",val,j);
	for(int i=1;i<n;i++)cout<<a[i].to_ulong()<<" ";
	cout<<a[n].to_ulong()<<endl;
	return 0;
}
```

---

## 作者：mol茶蛋糕 (赞：5)

这道题只要把$SG$函数与$mex()$理解好了就是一道水题  

对于判断胜负，用$SG$函数很简单  

但是输出“路径”，我就有点问题了，想想应该是我对$mex()$理解得不够深刻  
~~~
for(int i=1;i<=k;i++)
{
	if((ans^a[i])<=a[i])
	{
		printf("%lld %lld\n",a[i]-(ans^a[i]),i);
		for(int j=1;j<=k;j++)
			if(i!=j)
				printf("%lld ",a[j]);
			else printf("%lld ",ans^a[i]);
		break;
	}
}
~~~
第三行的那句话因为 $ans$ 本来是先手必胜的情况，而$ans$^$a_i$是因为这道题中$SG(a_i)=a_i$，所以就相当于$ans$^$SG(a_i)$，就是先手对$i$ 这个堆完全取走之后，后手变成先手呈现出的局面，如果这个$ans$^$SG(a_i)<=a_i$，那么就说明先手是可以通过在$i$堆取走少于或等于$a_i$根火柴来使后手变成先手时呈现出$ans=0$的局面的，这就是答案。  

#### 完整代码  

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define int LL
#define N 500005 
int a[N];

signed main()
{
	int k;
	scanf("%lld",&k);
	int ans=0;
	for(int i=1;i<=k;i++)
	{
		scanf("%lld",&a[i]);
		ans^=a[i];
	}
	if(ans==0)
	{
		printf("lose\n");
		return 0;
	}
	for(int i=1;i<=k;i++)
		if((ans^a[i])<=a[i])
		{
			printf("%lld %lld\n",a[i]-(ans^a[i]),i);
			for(int j=1;j<=k;j++)
				if(i!=j)
					printf("%lld ",a[j]);
				else printf("%lld ",ans^a[i]);
			break;
		}
	return 0;
}
```

---

## 作者：说好不哭 (赞：3)

```cpp
// 判断能否赢的算法就是nim游戏
// 下面简略介绍一下方案输出的方法
// 异或有可逆性质，就是说，如果 a[1]^a[2]=ans,那么 ans^a[2]=a[1]，即异或两次，相当于抵消
//  那么，对于所有a[i]的异或值ans来说，如果ans^a[i],得到的值的意义是：除a[i]以外的n-1个数的异或值  以下称这个值为 "这个值" 
// 那么这个时候，如果"这个值"比 a[i]要小，那么a[i]就可以减去某个数，使得a[i]等于"这个值" ，那么这时候，两个"这个值"异或起来，就是0了
//  那就是得到方案了。
// （前提条件: "这个值"比 a[i] 小） 
// 可能会有人觉得为什么 "这个值"不能是 <=a[i]。 
// 如果 "这个值"<=a[i], 那么，不就是除a[i]以外的 n-1个值异或和为 a[i],再异或一个a[i],答案为0了吗？ 
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,ans;
int a[N];
int main(){
	scanf("%d",&n);
	for (register int i=1; i<=n; ++i) scanf("%d",&a[i]),ans^=a[i];
	if (!ans) puts("lose");
	else
	{
		for (register int i=1; i<=n; ++i)		
		if ((ans^a[i])<a[i]) 
		{
			printf("%d %d\n",a[i]-(ans^a[i]),i); a[i]^=ans;
			for (register int j=1; j<=n; ++j) printf("%d ",a[j]);
			return 0;
		}
	}
return 0;
}
```


---

## 作者：喵の耳 (赞：1)

更好的阅读体验请[点击](https://www.cnblogs.com/gengyf/p/10878126.html)

------------

忽然发现博弈论是个很好玩的东西哎

之前假期学长讲课的时候就发现这种必胜的战略可以用来坑人做题

这两天终于做了第一道博弈论的题，写篇博客纪念一下

灵感来源：洛谷P1247

#### Pre-scene
![](https://cdn.luogu.com.cn/upload/pic/58974.png)

众所周知，李明和Jenny都喜欢Danny，为了争夺Danny的所有权，他们决定玩一个游戏。规则是这样的：

有k堆扑克牌（不成套），两人轮流从某一堆中拿出x张牌，不能不拿，也不能跨堆拿牌，拿走最后一张(堆)牌的一方获胜。

命运当然是不公平的，李明来向你请教有没有必胜的方法，你聪明的，能告诉他么


------------

## 0X10  知识

先来了解一下，什么是Nim博弈

------------

通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。                   　　　　　　　　            　　　　  ——百度百科 


------------

了解Nim游戏之后，我们会发现这是一个经典的ICG游戏（不要问我什么是ICG因为我百度百科也不知道）

显然游戏有两种局面，先手必败和先手必胜，我们分别定义他们为P-position和N-position两种，其中P代表Previous，N代表Next，那么我们可以得出，从N-position转移而来的一定是P-position，反之也成立。

## 0X20  简单的证明

我们先来手玩一组小数据，一共有2堆石子，每一堆都有3个，你是先手的话，会怎么拿？由规则我们知道，玩家的目标是拿走最后一个石子，所以先手的你一定不会把某一堆全部拿走，因为如果这样，后手将会拿走另一堆，先手必败；但是如果你先拿1个，后手会跟着你从另一堆也拿一个，你拿2个，后手仍可以做和你一样的操作，先手必败。至此我们发现，（3，3）是一个P-position的局面。

推论：

1.当a1^a2^a3^……a^n=0时，为P-position，即先手必败。

2.当a1^a2^a3^……a^n!=0时，一定存在某个移动，使得局面变成一个P-position，即此局面为N-position。

## 0X30  实现

直接异或运算即可，代码过于简单就不放了。

## 0X40  题解

传送门

了解了上述知识后，这道题几乎就是一个裸的板子了，就是加了一个输出怎么取和取完的状态而已，这也很好实现。

### 0X41  怎么取

由于我们发现异或和不等于0，我们就要考虑怎么取使得其等于0了。

设k=a1^a2^a3^……a^n，因为k!=0，而显然k^k=0，所以要使a1^a2^a3^……a(n-1)^an^k=0，只需要把其中一个ai变成ai^k即可，又因必须要取，可得ai^k<ai

### 0X42  取完的状态

直接更改即可

### 0X43  代码

```cpp
#include <cstdio>
int n;
int a[500005];
int main(){
    scanf("%d",&n);
    int check=0;
    for(int i=1; i<=n; i++){
        scanf("%d",&a[i]);
        check^=a[i];
    }
    if(!check){
        printf("lose\n");
        return 0;
    }
    for(int i=1; i<=n; i++){
        if((check^a[i])<a[i]){
            printf("%d %d\n",a[i]-(check^a[i]),i);
            for(int j=1; j<=n; j++)
                if(j!=i)
                    printf("%d ",a[j]);
                else    printf("%d ",check^a[i]);
            break;
        }
    }
    return 0;
}

```



---

## 作者：maomao9173 (赞：1)

#### [题目链接  $Click$  $Here$](https://www.luogu.org/problemnew/show/P1247)

这个题目其实就是一个$Nim$游戏的简单模型。对于单个的$Nim$游戏（单独一堆的情况），数学归纳可证其$SG$函数值等于其石子个数。所以对于组合起来的整个游戏，其$SG$函数值等于所有子游戏的异或和。如果这个值为$0$那么就是$lose$，反之则有必胜策略。

对于必胜策略的要求：在采取必胜策略后，整个游戏的$SG$变为$0$。为此我们先统计最初状态的$SG$，然后对于每一堆单独考虑：拆掉堆$i$的游戏为$SG$^$w[i]$。要使得游戏$SG$变为$0$，就要异或上一个同样的值，即这一堆的石子要拿到$=SG$^$w[i]$为为止。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 500010;

int read () {
	int s = 0, ch = getchar ();
	while ('9' < ch || ch < '0') {
		ch = getchar ();
	}
	while ('0' <= ch && ch <= '9') {
		s = (s << 1) + (s << 3) + ch - '0';
		ch = getchar ();
	}
	return s;
}

int n, w[N], sg;

int main () {
	n = read ();
	for (int i = 1; i <= n; ++i) {
		w[i] = read ();
		sg ^= w[i];
	}
	if (!sg) puts ("lose");
	else {
		for (int i = 1; i <= n; ++i) {
			if (w[i] >= (sg ^ w[i])) {
				cout << w[i] - (sg ^ w[i]) << " " << i << endl;
				w[i] -= w[i] - (sg ^ w[i]);
				for (int i = 1; i <= n; ++i) cout << w[i] << " ";
				return 0;									
			}
		}
	}
}

```



---

## 作者：ftx456789 (赞：1)

这个题解是在已知nim博弈结论的前提下实现的，也就是说如果异或值为0，则先手必败，反之先手必胜，现在要求的是在先手必胜的条件下输出第一次拿的情况，那么然后先手必胜，也就是先手拿走了一些棋子后，局势变成了后手开始的先一轮，也就是先手要拿走一些棋子后保证剩下的棋子的异或和为0，那就直接暴力就好，从第一堆棋子开始，算拿走多少颗棋子后总的异或值为0，其实直接暴力也是没问题的，如果第一堆的值很大，其实拿不了多少就会出现总的异或值为0的情况，实际上的复杂度应该不高....,或者是这题数据水了一点直接暴力也过了
```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <math.h>
#include <string.h>
using namespace std;
int a[500005];
int main()
{
    int n;
    scanf("%d",&n);
    int ans=0;
    for(int i=0;i<n;i++)
        {
            scanf("%d",&a[i]);
            ans^=a[i];
        }
    if(!ans)
    {
        printf("lose\n");
        return 0;
    }
    int flag=0;
    for(int i=0;i<n;i++)
    {
        for(int j=1;j<=a[i];j++)
        {
            if((ans^a[i]^(a[i]-j))==0)//先去掉自己这一堆再和拿走后剩下的部分异或
            {
                flag=1;
                printf("%d %d\n",j,i+1);
                a[i]-=j;
                break;
            }
        }
        if(flag)
            break;
    }
    for(int i=0;i<n;i++)
        printf("%d%c",a[i]," \n"[i==n-1]);
    return 0;
}

```

---

## 作者：lenaalyth (赞：1)

这是一个nim博弈裸题。。。

nim博弈不详解（水平不够，讲不出来，而且网上一堆资料），奇异局势（应该是这么说吧）是当所有数异或起来，也就是**F=A1^A2^A3^...^AN==0**时，先手必输。

既然知道了奇异局势，只要将对手推到奇异局势就可以了，也就是说在A1^A2^A3^...^AN！=0时，让其中的一个数减掉一些。使其变为A1^A2^A3^...^AN==0就可以了。而异或有一个特点，就是**A^B^B=A**,但是要注意这里得数是不能降到负数的，也就是说要找到一个数AX，使其与F异或后的值要小于AX本身。再将这个数减到F^AX。这样就将对手推到了必输的局势，也就是第一步。（注意不要排序，因为如果其中有两个数同时最大的活，相当于没有异或过，那这个数可能比所有数除了他异或起来要小）

代码如下：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
long long int a,b,c,k[510000],v,n,ans2,ans1;
int main()
{
    scanf("%lld",&a);
    for(int x=0;x<a;x++)
    {
        scanf("%lld",&k[x]);
        c^=k[x];
    }
    if(c==0)
    {
        printf("lose");
    }
    else
    {	int uuu=0;
        for(;uuu<a;uuu++)
        {long long kkk=c^k[uuu];
            if(kkk<=k[uuu])//话说好像加不加这个等号没什么不同？应该是有的吧
            {
                break;
            }
        }
        c^=k[uuu];
        ans1=k[uuu]-c;
        ans2=uuu+1;
        k[uuu]=c;
        printf("%lld %lld\n",ans1,ans2);
        for(int x=0;x<a;x++)
        {
            printf("%lld",k[x]);
            if(x!=a-1)
            {
                printf(" ");
            }
        }
    }
}
```


---

## 作者：aiyougege (赞：1)

## Behind
首先有几个博弈论上的结论:
- 必败态, 必胜态（*相当于是一个有向无环图上的点*）
- 必败态**必定**转移到必胜态, 必胜态**能**转移到必败态
- SG函数, 对游戏局面的估价函数
- 必败态的$SG$值为0.
- 单一游戏的SG函数, $SG(u)=\text{mex}\, \{SG(v):u\rightarrow v\}$
- 多个游戏的SG函数, $SG(u)=SG(v_1)\oplus SG(v_2)\oplus\cdots\oplus SG(v_n)$

1.*其中$u,v$,都表示一个(游戏)状态, $v_1,\cdots,v_n$表示子游戏,,, $\oplus$表示异或*

2.*证明请自己意淫或者查资料(推荐 Game theory)*

## Solution


再来考虑这个游戏的**一堆火柴棒**, 发现当这堆火柴数目为$x$时$SG$值为$x$.(*这是通过考虑上述结论(1. 2. 4. 5.)得到的*).

再结合多个游戏的SG函数就可以得到整个游戏的$SG$值等于石子数异或和.得到结论:
- 若石子数异或和大于0, 先手有必胜策略
- 石子数异或和等于0, 先手没有必胜策略

如果先手有必胜策略(处于必胜态), 那么只要每次都让**状态都转移到必败态**就好了……
也就是让其操作后石子数异或和等于0.

第一步操作自然就是让石子异或和等于0啦!

### 换一种考虑方式
- 从结束往开始考虑, 当石子数全为0时此时操作的人自然是输定了;
- 当有一堆石子数不为0时, 此时操作的人全取光就赢了;
- 当有两堆石子数不为0时, 
	- 最坏的情况: 若此时操作的人$a$取$x$个石子, 另一个人也取$x$个……如此循环往复, 如果两个人始终能进行相同的操作(两堆石子相同), 那么这个人$a$就输了;
	- 否则它就能赢……
- 类比到n堆石子, 当石子数异或和为0时, 两个人始终能进行相同的操作: **即后手有必胜策略**

## Code
```c++
#include<iostream>
#include<cstdio>
#define N 1000005
using namespace std;

int pp[N];

int main(){
    int n,maxl=0,ans=0,t,p;
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&t);pp[i]=t;
        ans^=t;
    }
    if(ans){
        ans^=maxl;
        for(int i=1;i<=n;++i)
            if(pp[i]-(ans^pp[i])>=0){
                ans^=pp[i];
                p=i;printf("%d %d\n",pp[i]-ans,i);
            }
        for(int i=1;i<=n;++i)
            if(i!=p)printf("%d ",pp[i]);
            else printf("%d ",ans);
    }
    else printf("lose\n");
    return 0;

}
```

---

## 作者：ww3113306 (赞：1)

表示这个题解虽然很有道理，，但是并没有看懂2333，后来请教了一个数学组的同学才知道为什么，加上讨论也有人问了，这里就详细的解释一下为什么是a[i]-a[i]^k;

首先 减去a[i]-a[i]^k，就相当于把a[i]变为a[i]^k，然后为了赢得游戏，我们的目的是使操作完后的k变为0，这样就相当于对面先拿的时候k是0；

那么 如果现在k是一个正整数，并且只需要修改数组中的一个即可使k为0，那么可以推出，现在的数组是这么个状况：

a[1]^a[2]^a[3]^.....a[i-1]^a[i+1]...^a[n]^a[i],a[i]即是我们要修改的数，既然将a[i]改掉，k就变为0，那么我们将数组分为2部分:

x=a[1]^a[2]^...^a[n](不包括a[i]）；

y=a[i]
那么现在x^y=k，现在将y变为y^k（也就是a[i]^k）；

那么式子就变为x^y^k 也就是k^k；而根据^的特性，两个相同的数^显然得到的是0；

因此，目的就达到了；


---


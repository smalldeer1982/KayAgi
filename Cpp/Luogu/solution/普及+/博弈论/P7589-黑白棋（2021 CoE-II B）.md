# 黑白棋（2021 CoE-II B）

## 题目描述

$\text{Alice}$ 和 $\text{Bob}$ 正在玩一种称为“黑白棋”的游戏。该游戏的规则如下：

- 游戏在直角坐标系中进行。

- $\text{Alice}$ 执黑棋，$\text{Bob}$ 执白棋。

- 初始时，在直角坐标系中任选 $n$ 条与 $X$ 轴平行的直线，直线在 $Y$ 轴上的截距均为整数，且互不相同。$\text{Alice}$ 在每条直线上都会放置一枚黑棋，$\text{Bob}$ 在每条直线上都会放置一枚白棋，棋子位置的 $X$ 坐标值均为整数。在同一条直线上的两枚棋子位置不会相同。

- $\text{Alice}$ 和 $\text{Bob}$ 轮流走棋，$\text{Alice}$ 总是先走棋。每名玩家在走棋时，先选择一条直线，然后沿着直线移动该条直线上己方颜色的棋子。

- 每个玩家可以将自己的棋子向着靠近对方棋子的方向一次性移动若干整数单位距离，称之为**前进**。每个玩家也可以向着远离对方棋子的方向一次性移动若干整数单位距离，称之为**后退**。只要在前进时不跨过对方的棋子，也不使黑棋和白棋的位置发生重叠，前进的最远距离不限，但是前进的距离至少为 $1$，如果无法满足前述条件，则玩家不能执行前进操作。为了避免玩家反复后退导致游戏无法结束，在一局游戏中，某个玩家执行后退操作的总次数不能超过 $k$ 次。与此同时，为了防止游戏区域太大以致在显示游戏状态上造成不便，每次后退的距离至少为 $1$，但不能超过 $d$。如果无法满足前述条件，玩家不能执行后退操作。

- 玩家在轮到自己走棋时，如果能够执行操作就必须执行一次操作，此操作可以是前进操作，也可以是后退操作（如果未超出后退次数的限制）。

- 如果某个玩家无法执行任何操作来移动自己的棋子，将输掉游戏，游戏结束。

给定游戏的初始状态，假设 $\text{Alice}$ 和 $\text{Bob}$ 在游戏时均采用最佳策略，试确定 $\text{Alice}$ 能否获胜。

## 说明/提示

**样例说明**

下图对应输入 \#1 的第一组数据，如果 $\text{Alice}$ 采用最优策略，无论 $\text{Bob}$ 如何走棋，$\text{Alice}$ 都能够获胜。

![](https://cdn.luogu.com.cn/upload/image_hosting/3y151p4f.png)

以下是 $\text{Alice}$ 的必胜策略。首先，$\text{Alice}$ 选择将 $y=3$ 的直线上的黑棋从 `4` 移动到 `6`，使得两条直线上黑棋和白棋之间的间距均为 $2$，由于 $k$ 为 $0$，相当于不允许执行后退操作，如果 $\text{Bob}$ 选择移动 $y=3$ 直线上的白棋，将使得该直线上的两颗棋子相邻，后续无法再移动。同样的，如果 $\text{Bob}$ 选择移动 $y=7$ 直线上的白棋，也将使得该直线上的两颗棋子相邻，后续无法再移动。因此无论 $\text{Bob}$ 如何操作，总会使得一条直线上的两颗棋子相邻，无法再继续移动，而另外一条直线上的棋子间距为 $2$，还可以再移动一次，$\text{Alice}$ 将剩下可以移动的黑棋再移动一步后，后续 $\text{Bob}$ 无法移动白棋，因此 $\text{Alice}$ 会获胜。

对于输入 \#1 的第二组数据，无论 $\text{Alice}$ 如何走棋，$\text{Bob}$ 总能够获胜。

------------

**数据范围**

对于 $100\%$ 的数据，$1 \le T \le 100$，$1 \le n \le 100$，$0 \le k \le 100$，$1 \le d \le 20$，$-100 \le y_i \le 100$，$-10^3 \le b_i \le 10^3$，$-10^3 \le w_i \le 10^3$。

## 样例 #1

### 输入

```
2

2 0 10
3 4 8
7 7 5

3 5 15
-3 -9 -19
-7 10 21
12 12 16```

### 输出

```
Yes
No```

# 题解

## 作者：metaphysis (赞：13)

[题目链接](https://www.luogu.com.cn/problem/T169952?contestId=41599)

前置知识：[Nim 游戏](https://zhuanlan.zhihu.com/p/52931007)

本题的底层博弈模型为 Nim 游戏。将每条直线上黑棋和白棋之间的间距视为一个石子堆（准确地说，石子堆的石子数目等于黑棋和白棋间的距离减去一，因为棋子不能重叠），在不考虑后退操作的情况下，相当于 Alice 和 Bob 在玩一个 $n$ 个石子堆的 Nim 游戏。

现在考虑后退操作的影响。如果 Alice 具有必胜策略，Bob 仍“负隅顽抗”，不停地执行后退操作，那么 Alice 可以通过“反向操作”（reversible move）将 Bob 造成的影响消除，即 Bob 后退多少距离，Alice 就前进多少距离，这样就能将局面恢复到 Bob 后退之前的状态。由于规则的限制，不能无限执行后退操作，因此局面的胜负状态不会改变。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(int argc, char *argv[])
{
    int cases;
    cin >> cases;
    for (int cs = 1; cs <= cases; cs++)
    {
        int n, k, d, y, b, w, nim = 0;
        cin >> n >> k >> d;
        for (int i = 0; i < n; i++)
        {
            cin >> y >> b >> w;
            nim ^= abs(b - w) - 1;
        }
        cout << (nim ? "Yes" : "No") << '\n';
    }
    return 0;
}

```



---

## 作者：VinstaG173 (赞：4)

一道小清新的博弈论题。~~罔而殆还我 $20$ 块钱！！！!!111~~

首先我们把每行上的黑白棋看作一个子游戏。容易发现向对方移动 $x$ 相当于把两颗棋子间的距离减少 $x$，或者说把两颗棋子间的整点数减少 $x$。把两颗棋子间的点数看作一堆石子的颗数，那么这和取石子游戏中取走 $x$ 颗石子是等价的。

然后我们发现如果一个状态的所有石子数异或和为 $0$，那么无论前进还是后退都会使异或和变化，也就是说在 Nim 游戏中的必败状态在有后退操作时仍然没有必胜策略，而必胜方不需要使用自己的后退能力就能获胜。因此后退操作是没有影响的。所以我们直接套 Nim 的结论就可以了。

这里加上后退操作考察了对 Nim 游戏胜负状态判定的理解。metaphysis 还是强啊！（

代码也非常短，非常好写~~所以罔而殆还我首 A 奖励！!11~~

Code:
```cpp
#include<cstdio>
int t,n,k,d,b,w;
int main()
{
	scanf(" %d",&t);
	while(t--)
	{
		scanf(" %d %d %d",&n,&k,&d);k=0;
		for(int i=0;i<n;++i)scanf(" %d %d %d",&d,&b,&w),k^=((b<w)?(w-b-1):(b-w-1));
		puts((k)?"Yes":"No");
	}
	return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

[原题传送门](https://www.luogu.com.cn/problem/P7589)

~~顺带吐槽一句，这个 $y$ 屁用没有，读进来干嘛（~~

# 1 对题目的思考

我们可以视两个棋子之间的距离为该列的石子数，每一方都可以让自己的棋子前进一定距离，前进了多少，距离就会减多少，相当于拿走了一定数量的石子。

相信聪明的读者已经~~通过看标签~~想到了，这道题的精髓就是：

![Nim游戏](https://cdn.luogu.com.cn/upload/image_hosting/aj9702fc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可是，本题又与传统的 Nim 游戏不甚相同，还添加了一种后退（也就相当于往里面加石子）的情况，变得复杂了许多，如何解决？

其实这种情况对结局并不造成影响。原先的赢家当然不会去后退自找麻烦（~~除非他俩像我一样不太聪明~~），所以只有败者才会试图后退负隅抵抗。但这也是没用的，你后退多少，我就前进多少，所以无论你怎么后退，总会次数用尽，~~原地趋势~~直接失败的。

# 2 美~~味~~妙的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int nim=0;
        int n,k,d;
        cin>>n>>k>>d;
        while(n--){
            int y,b,w;
            cin>>y>>b>>w;
            nim^=abs(b-w)-1;//别忘了-1
        }
        if(nim==0){
            cout<<"No";
        }else{
            cout<<"Yes";
        }
        cout<<endl;
    }
    return 0;
}
```

[Accepted](https://www.luogu.com.cn/record/103781659)

~~再吐槽一句，这和后退有关的东西都屁用没有，真就混淆视听呗（~~

---

## 作者：JiaY19 (赞：2)

## 题意

1. 有若干条直线，直线上双方各摆一个棋子，棋子坐标为整数。

1. 游戏中，规定前进方向为对方棋子的方向，在一玩家的回合中，玩家此时可以选择一条直线上自己的棋子前进或后退整数单位距离一次。

1. 前进最多移到对方棋子面前，除此之外没有距离限制。

1. 后退最多移动 d 距离。整局游戏最多移动 k 次。

1. 若某玩家无法执行任何操作来移动自己的棋子，将输掉游戏，游戏结束。

1. 是否有先手必胜策略。

## 思路

大概一眼就能看出是一个Nim游戏

这题应该把每行上的黑白棋看作一个子游戏。

可以将两颗棋子间的点数看作一堆石子的颗数

就容易发现向对方移动 a的距离 相当于取石子游戏中取走 a 颗石子。

至于后退，可以看出对胜负没有任何作用的

因此，这就是一个裸的Nim游戏板子。

## Code

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t , a , b , c , d , e;

int read()
{
	long long X = 0 , w = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
		w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
		X = X * 10 + c - '0' , c = getchar();
	return X * w;
}

signed main()
{
	t = read();
	while(t--)
	{
		a = read() , b = read() , c = read() , b = 0;		//输入 
		for(int i = 0;i < a;i++) c = read() , d = read() , e = read() , b ^= ((d < e)?(e - d - 1):(d - e - 1));		//因为b，c没有什么用，所以用来重复计算 
		puts((b)?"Yes":"No");			//判断输出 
	}
	return 0;
}
```
至于一些其他的博弈论，这里安利一下自己的博客。

[博弈论（自认为写的比较详细）](https://mfeitveer.blog.luogu.org/post-di-bo-yi-lun-xue-xi-bi-ji)



---

## 作者：aimcf (赞：0)

Nim 神仙题。

+ 后退操作是没有意义的。因为假设 $X$ 后退了 $e$ 步，那么 $Y$ 可以前进 $e$ 步，这样等于是什么也没有干，由于后退操作执行的次数有限，所以不会存在后退扭转局面的情况。
+ 黑棋和白棋一开始的距离是 $\lvert b_i - w_i - 1 \rvert$。也就是说，这一条直线上黑棋和白棋一共最多可以移动 $\lvert b_i - w_i - 1\rvert$ 的距离。

可以将距离转换成石子的个数，容易发现是 $n$ 堆石子先后手都在一堆里拿走任意个石子，谁拿到最后一个谁赢。可以转换成 Nim 博弈问题，时间复杂度 $O(n)$。

---

## 作者：lyhqwq (赞：0)

### 前置知识：

nim 游戏：有 $n$ 堆石子，两个人每次轮流取石子，每次只能从一堆里取，选到最后一堆的人获胜。

我们规定两个状态：

P 状态：先手必败。

N 状态：先手必胜。

nim 游戏只有在 $A_1 \oplus A_2 \oplus \cdots \oplus A_n = 0$ 的时候是 P 状态，下面给出证明。

显然，当 $\lbrace A_n\rbrace = \lbrace 0,0,\cdots,0\rbrace$ 时，是 P 状态。

若当前所有石子的异或和为 $k\:(k \neq 0)$ ，我们找到一堆石子，把 $A_i$ 取成 $A_i \oplus k$ 。因为一定有     $A_i>A_i \oplus k$ 就可以把石子的异或和变成 $0$ ，给对手留下 P 状态。

而当石子异或和为 $0$ 时，显然不能找出一种方案，使的异或和还是 $0$ ，只能给对手留下 N 状态。

### 思路

而我们可以把 $n$ 条线视为 $n$ 堆石子，每堆石子的数量就是黑棋白棋之间的距离 $-1$（因为石子不能重叠）。

现在来考虑后退带来的影响，因为后退是有限次的，而前进是无限次的，所以当一方后退时，另一方只要前进相同的步数，就不会影响最终的结果，所以就转化成为了 nim 游戏问题。

### AC code

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define il inline
using namespace std;
int t,n,k,d,y,b,w;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>t;
	int ans=0;
	while(t--){
		ans=0;
		cin>>n>>k>>d;
		for(int i=1;i<=n;i++){
			cin>>y>>b>>w;
			ans^=((b<w)?(w-b-1):(b-w-1));
		}
		cout<<((ans)?"Yes":"No")<<endl;
	}
	
	return 0;
}

```


---

## 作者：蒟蒻CGZ (赞：0)

### NIM游戏

#### 定理

`NIM` 博弈先手有必胜的方法，当且仅当 $A_1 \ \oplus\  A_2 \ \oplus\  \dots \ \oplus\  A_n \ne 0$。

有：

- 当 $A_1 \ \oplus\  A_2 \ \oplus\  \dots \ \oplus\  A_n = 0$ 时，必败
- $\ne 0$ 时，先手有必胜的方法

##### 证明:

所有物品都被取光是一个必败局面（对手取走最后件物品，已经获得胜利），此时显然有 $A_1 \ \oplus\  A_2 \ \oplus\  \dots \ \oplus\  A_n = 0$ 。
对于任意一个局面， 如果 $A_1 \ \oplus\  A_2 \ \oplus\  \dots \ \oplus\  A_n = x \ne 0$，设 $x$ 的二进制表示下最高位的 $1$ 在第 $k$ 位，那么至少存在一堆石子 $A_i$，它的第 $k$ 位是 $1$。显然 $A_i \ \oplus\ x < A_i$，我们就从 $A_i$ 堆中取走若干石子，使其变为 $A_i \ \oplus\  x$,就得到了一个各堆石子数异或起来等于 $0$ 的局面。

> 为什么 $A_i\ \oplus\ x < A_i$ ？
>
> 异或运算的规则是：对于每一位，相同则为 $0$，不同则为 $1$
>
> 设 $x$ 二进制表示下最高位的 $1$ 在第 $k$ 位。那么显然：不严谨地说，$\oplus\ x$ 能够“影响”到的位置是低于或等于 $k$ 的位
>
> $A_i\ \oplus\ x$ 后第 $k$ 位显然是 $0$，换言之，一定减去了 $2^k$ 的数值，即便因为异或 $x$ ，其他比第 $k$ 位低的位置都由 $0$ 变为了 $1$ ，那么也只是加上了 $2^0 + 2^1 + 2^2 + \dots 2 ^ {k-1}$ 的数值，小于 $2^k$ 。
>
> 因此，加上的数值总小于减去的数值，得证。
>
> (一句话：最高位变为 0 )

对于任意一个局面，如果 $A_1 \ \oplus\  A_2 \ \oplus\  \dots \ \oplus\  A_n = 0$，那么无论如何取石子，得到的局面下各堆石子异或起来都不等于 $0$。

> 可用反证法证明，假设 $A_i$ 被取成了 $A'$,
> 并且 $A1\ \oplus\ A2\ \oplus\ \dots \oplus\ A'\ \oplus\ \dots \ \oplus\ An=0$。由异或运算的消去律得 $Ai=A'$ ，与“**不能不取石子**”的规则矛盾。
>
> 异或运算的消去律：$a\ \oplus\ b = a\ \oplus\ c\ \ \Rightarrow\ \ b = c$ 

综上所述，再由数学归纳法可知：

1. $A_1 \ \oplus\  A_2 \ \oplus\  \dots \ \oplus\  A_n \ne 0$为必胜局面，一定存在一种行动让对手面对“各堆石子异或起来等于 $0$”即 $A_1 \ \oplus\  A_2 \ \oplus\  \dots \ \oplus\  A_n = 0$ 的必败局面。
2.  $A_1 \ \oplus\  A_2 \ \oplus\  \dots \ \oplus\  A_n = 0$ 为必败局面，无论如何行动，都会让对手面临一个”各堆石子异或起来不等于 $0$“的必胜局面。

证毕。

#### 例题

##### [P2197 【模板】nim 游戏](luogu.com.cn/problem/P2197)

如上文

```cpp
/*
Luogu P2197
NIM
*/
#include <bits/stdc++.h>
using namespace std;

int T, n, a, ans = 0;

int main() {
    scanf("%d", &T);
    while (T --) {
        scanf("%d", &n);
        ans = 0;
        while (n --) {
            scanf("%d", &a);
            ans ^= a; // 计算异或和
        } 
        if (ans) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

##### [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)

**Problem**

![image-20220319210926723](C:\Users\陈冠中\AppData\Roaming\Typora\typora-user-images\image-20220319210926723.png)

**Solution**

当题目不止要求输出胜败，还要求输出第一步呢？

显然，我们的目标是要令对手面对必败局面，也就是令异或和为 $0$ 。

设异或和为 $k$，那么只要我们找到一个 $A_i$ ，使得 $A_i\ \oplus\ k < k$ （满足“减少”的条件），对其进行操作。显然，操作后异或和即为 $0$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
int n, a[N], ans;

int main() {
    scanf("%d", &n);
    ans = 0;
    for (int i = 1; i <= n; ++ i) {
        scanf("%d", &a[i]);
        ans ^= a[i];
    }
    if (!ans) puts("lose");
    else {
        int flag;
        for (int i = 1; i <= n; ++ i) 
            if ((ans ^ a[i]) < a[i]) {
                printf("%d %d\n", a[i] - (ans ^ a[i]), i);
                for (int j = 1; j <= n; ++ j)
                    if (j != i) printf("%d ", a[j]);
                    else printf("%d ", ans ^ a[i]);
                puts("");
                break;
            }
    }
    system("pause");
    return 0;
}
```

##### [P7589 黑白棋](https://www.luogu.com.cn/problem/P7589)

**Problem**

![image-20220403152550143](C:\Users\陈冠中\AppData\Roaming\Typora\typora-user-images\image-20220403152550143.png)

**Solution**

显然，题目的核心在于 $n$ 对棋子的间距。

观察后发现，$n$ 对棋子的间距是否能理解成 $n$ 堆石子呢？只是，这题多出了一个操作：添加“石子”，即题述“后退”操作。但是这个操作的规模不大：最多 $k$ 次， 每次最多添加 $d$ 个石子。抛开“后退”操作不谈，这题就是一个NIM游戏模板题。

考虑一下，如果目前的局面是异或和为 $0$ 的 $Alice$ 必胜局面，但是 $Bob$ 执行“后退”操作，$Alice$ 该怎么做？直接前进几步将 $Bob$  的“后退”操作抵消即可，“后退”操作不是无限次的，因此这种做法可行。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;
int T, n, k, d;

int main() {
    scanf("%d", &T);
    while (T --) {
        scanf("%d%d%d", &n, &k, &d);
        int ans = 0;
        for (int c, a, b, i = 1; i <= n; ++ i) {
            scanf("%d%d%d", &c, &a, &b);
            ans = ans ^ (abs(a - b) - 1);
        }
        if (ans != 0) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

#### 总结

NIM游戏是一种**公平组合游戏**（Impartial Game），定义如下：

- 游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息；
- 任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关；
- 游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。

遇到**公平组合游戏**一类问题时，或许可以参照上述思想思考。

---

## 作者：封禁用户 (赞：0)

刷博弈论时刷到的

~~怎么说，这题还是比较水的~~（只要你想清楚）

_Step1 :_ 考虑后退操作；如果 _A_ 后退了，那么 _B_ 一定可以后退使得后退后两颗棋子的相对位置和后退钱的相对位置一样。

_Step2 :_ 考虑前进操作；就相当于（两人距离 - 1）个石子的取石子游戏。（不多累赘）详情参考 [nim 游戏【模板】](https://www.luogu.com.cn/problem/P2197)

想了一想，其实 _k_ 和 _d_ 对答案没有影响诶

参考代码：

```
#include <bits/stdc++.h>
using namespace std;

int main(){
    int t;
    cin >> t;
    while (t--){
        int n, k, d, y, b, w, nim = 0;
        cin >> n >> k >> d;
        for (int i = 1; i <= n; i++){
            cin >> y >> b >> w;
            nim ^= abs(b - w) - 1;
        }
        if (nim){
        	cout << "Yes" << endl;
		}
		else{
			cout << "No" << endl;
		}
    }
    return 0;
}
```


---

## 作者：王大神——A001 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P7589)
### 简化题意

有很多条线，每条线上都有两人的棋，靠近对方的棋叫**前进**，远离叫**后退**，后退有次数的距离限制，而前进没有，先走走不了的一方输。

### 情况分析
后退不需考虑：一方只要后退，对方就可以前进相同的距离。

那么，现在只用考虑前进了，当两人的棋挨在一起的时候，本条线就走不了了。

因为两人足够聪明，所以当他们发现情况不利时，会尽量打破这种可能，举个例子：

---A----B---（A：Alice B：Bob）

如果只有一条线，Alice 的棋会直接对到 Bob 的棋的前面，取得胜利；但是如果还有一条两人的棋没有对到一起的情况，Alice 就不会这么做，但她可以对到 Bob 的棋的前一个格处。

------A-B---（A：Alice B：Bob）

这样另一条线的 Bob 的棋不会直接对上，为了这种解决情况，他也会在另一条线上，对在 Alice 的棋的前面，而这种情况，Alice 会必输。

所以聪明的 Alice 在一开始，为了和面有路可走，可能会如下：

-----A--B---（A：Alice B：Bob）

而 Bob 也会随机应变……

因为两方都非常聪明，就可能会出现每个人的棋就会一步一步向前走。

### 异或处理

我们就可以统计两人的间距和来判断谁先无路可走，我们可以在这里用异或快速处理。

例如：

---A---B---

---A---B---

两人一步一步走，可以想象 Alice 只走上面，Bob 只走下面，会发现两人走的次数相同，异或一下就抵消了。

### 代码
```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<set>
#include<queue>
#include<vector>
#include<bitset>
#include<map>
#include<utility>
using namespace std;
int r_r(){//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
int t;//多测 
int b_b;//判断输赢 
int main(){
	t=r_r();
	while(t--){
		int n=r_r(),k=r_r(),d=r_r();
		b_b=0;//多测清空 
		while(n--){
			int y=r_r(),b=r_r(),w=r_r();
			b_b^=abs(b-w)-1;//异或距离，注意两点距离为 abs（a-b）-1 
		}
		if(!b_b)cout<<"No"<<endl;//结果输出 
		else cout<<"Yes"<<endl;
	}
	return 0;
}
```


---

## 作者：RemiliaScar1et (赞：0)

## P7589 黑白棋（2021 CoE-II B）

水 Nim。

题目稍长，先读清楚题:

- 有若干条直线，直线上双方各摆一个棋子，棋子坐标为整数。
- 游戏过程中，规定前进方向为对方棋子的方向，在某一方的回合中，操作方可以选择一条直线上自己的棋子前进或后退整数单位距离一次。
    - 前进最多移到对方棋子面前，除此之外没有距离限制。
    - 后退最多移动 $d$ 距离。整局游戏最多移动 $k$ 次。
- 若一方合法策略为空时，则判其负。
- 求先手是否必胜。

读完我们可以知道，后退是没有任何的作用的，因为每次执行后退，对方都可以通过前进同样的长度来保持局面。所以我们可以直接不考虑后退。

先只考虑一根直线构成的子游戏，那么当两个棋子之间坐标差 $>1$ 时，先手可以直接把棋子移到对面棋子前面一个单位长度上，使得对方的棋子无法移动，此时先手必胜。

我们设这样一个游戏的 SG 函数值为两个棋子的坐标差 $-1$。由于直线与直线之间没有影响，所以直接对这些单独直线组成子游戏求和。也就是将这些子游戏的 SG 函数求异或和就得到了整个游戏的 SG 函数。

也就是说，这就是一个几乎裸的 Nim 游戏。每个直线的两个棋子之间的距离差 $-1$ 即是石子数量。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e5+10;

int arr[N];

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,k,d;
		scanf("%d%d%d",&n,&k,&d);
		int res=0;
		for(int i=1;i<=n;i++)
		{
			int y,a,b;
			scanf("%d%d%d",&y,&a,&b);
			res^=abs(a-b)-1;
		}
		if(res) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

---


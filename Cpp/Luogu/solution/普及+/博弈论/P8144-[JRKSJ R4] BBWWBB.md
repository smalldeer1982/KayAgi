# [JRKSJ R4] BBWWBB

## 题目描述

数轴上有 $6$ 个棋子。初始，第 $i$ 个棋子摆在 $a_i$，$a$ 单调递增。

其中第 $1,2,5,6$ 个棋子是黑色的，第 $3,4$ 个棋子是白色的。

游戏过程中，同一个位置上可以同时存在任意个同样颜色的棋子。

有两方：黑方和白方。两方轮流进行操作：

* 选择己方颜色的棋子，向左或向右移动一步。
* 若准备移动到的位置上存在另一方的棋子且仅存在 $1$ 个，那么可以移动同时将该棋子移除。
* 若准备移动到的位置上存在多个另一方的棋子，那么不可以移动到这个位置。
* 当一方不存在可以移动的棋子，该方被判输，游戏结束。

两方的目标都是在己方不输的前提下，尽可能的令对方输。两方均采取最优策略。

给定一方作为先手和每个棋子的位置，请判断，游戏是否会无限进行下去。

## 说明/提示

### 数据规模

对于 $15\%$ 的数据，$c=\texttt B$。\
对于 $100\%$ 的数据，$T\le10^5$，$|a_i| \le 10^9$，$c\in\{\texttt B,\texttt W\}$。保证 $a$ 单调递增。

### 样例解释

对于第 $1$ 组数据，其中一种局面变化如下：

```cpp
B:
1 4 6 8 9
B B W B B
W:
1 4 5 8 9
B B W B B
B:
1 5 8 9
B B B B
```
对于第 $2$ 组数据，其中一种局面变化如下：

```cpp
W:
1 3 6 8 9
B W W B B
B:
1 3 6 8 8
B W W B B
W:
1 3 5 8 8
B W W B B
B:
1 3 5 7 8
B W W B B
W:
1 3 4 7 8
B W W B B
B:
1 3 4 7 7
B W W B B
W:
1 3 3 7 7
B W W B B
B:
1 3 3 6 7
B W W B B
W:
1 2 3 6 7
B W W B B
B:
2 3 6 7
B W B B
W:
2 6 7
W B B
```
此后白方每一步均控制 `W` 往左边走一步。无论黑方如何操作，游戏均可以无限进行下去。

## 样例 #1

### 输入

```
2
B 1 3 4 6 8 9
W 1 3 4 6 8 9```

### 输出

```
No
Yes```

# 题解

## 作者：stntn (赞：14)

## 题目链接 
[link](https://www.luogu.com.cn/problem/P8144)

## 题目大意

六个棋子，分布于数轴上六个位置，颜色从左至右依次为 BBWWBB，两名玩家轮流操作己方棋子，左移或右移一个单位长度，直到一方无棋可动，另一方获胜。

## 分析

### 观察&猜测

首先，观察询问，题目只需要回答游戏**是否会无限进行下去**，所以我们无需考虑具体过程。

仔细阅读**样例解释**，出题人分别举了两种结果各一个例子

1. W 被 B 全数消灭，输出 `No`。
2. W 逃脱，输出 `Yes`。

由此我们可以大致猜测，因为 W 棋子少于 B 棋子，所以结果**不是 W 被全数消灭，就是 W 成功逃脱，不存在 B 被 W 消灭的情况**。

### 分情况讨论

是否存在一种情况使得 B 被 W 尽数消灭呢？我们看下图

![](https://cdn.luogu.com.cn/upload/image_hosting/306sr6it.png)

显而易见，对于单颗 W ，**要么主动送死，要么与 B 换子**。

显然，若 W 坐以待毙，左右的 B 迟早会强迫 W 与之换子（如上图第二块），此时 B 获胜。所以，W 必须**主动出击**。

![](https://cdn.luogu.com.cn/upload/image_hosting/r5b9cprb.png)

W 很容易就能形成 WW，此时可以**与黑强制换一子**（如上图），但此后又陷入了图一的情况。

难道 W 就不可能逃脱吗？肯定不是，再次观察样例解释2，出现了以下情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/vdr4c50d.png)

关键：**先手 W 并且有 W 与一个且仅有一个 B 相邻**（与两个 B 相邻，见图2），此时，W 便可以顺利逃脱。

这里可能有读者有疑问：在上图第二步时如果后方 B 追上来怎么办。

因为这里是两个 W 移动，所以移动速度平均为 $1/2$ 格，而后方同样为两个 B，所以**相对静止**（如果只有一个 B 追上来并不能强迫 W 换子）。

另外还有一种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ka1t1q09.png)

不言而喻

### 结论

因为 W 逃脱条件更少，我们判 W 是否能顺利逃脱。

- **W 先手**
- **开局有且仅有一个 B 与 W 相邻**

## Code

```cpp
#include<bits/stdc++.h>
int pos[7],T;char c;
signed main()
{
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);std::cout.tie(0);
	std::cin>>T;
	while(T--)
	{
		std::cin>>c;
		for(int i=1;i<=6;i++) std::cin>>pos[i];
		if ((c=='W')//W 先手
		&& ((pos[3]-pos[2]==1&&pos[2]-pos[1]>1)
		||  (pos[5]-pos[4]==1&&pos[6]-pos[5]>1))//有
		&&(!(pos[3]-pos[2]==1&&pos[5]-pos[4]==1)))//且仅有一侧与W相邻
			 std::cout<<"Yes\n";
		else std::cout<<"No\n";
	}
	return 0;
}
```


---

## 作者：lailai0916 (赞：3)

## 原题链接

- [洛谷 P8144 [JRKSJ R4] BBWWBB](https://www.luogu.com.cn/problem/P8144)

## 解题思路

如果游戏能无限进行下去，需要同时满足三个条件：

1. 白方先手：

- 如果黑方先手，一定能吃掉一个白方棋子，而白方仅剩一个棋子，必输。

2. 白方第一次能吃掉一个黑方棋子：

- 第 $3,4$ 个棋子是白棋，而棋子的位置单调递增。所以当 $a_3-a_2=1$ 或 $a_5-a_4=1$ 时能就吃掉一个黑棋。

3. 白方吃完后，不能被黑方吃掉棋子。考虑白棋不被吃掉的两种情况：
  
- 吃掉一个黑棋后，自己不能被吃掉；
- 另一边不能被吃掉。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[10];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int T;
	cin>>T;
	while(T--)
	{
		char c;
		cin>>c;
		for(int i=1;i<=6;i++)
		{
			cin>>a[i];
		}
		bool b1=c=='W';
		bool b2=a[3]-a[2]==1&&a[2]-a[1]!=1&&a[5]-a[4]!=1;
		bool b3=a[5]-a[4]==1&&a[6]-a[5]!=1&&a[3]-a[2]!=1;
		cout<<(b1&&(b2||b3)?"Yes":"No")<<'\n';
	}
	return 0;
}
```

---

## 作者：critnos (赞：3)

首先，当场面上局势是 `B W B B` 或者 `B B W B` 的时候，若 `W` 不能马上吃掉只有一个 `B` 的一边进行逃脱，白方必败。

这个很显然，就是一边的 `B` 不动，另一边的两个 `B` 轮流压上来，最终就可以用一个 `B` 换掉最后的 `W`。

这就意味着，白方绝对不敢用一个棋子换一个黑方的棋子。把这个称为基础情况。

接下来的推论，就是若黑方先手，那么白方必败。

若初始时存在异色棋子相邻，那么黑直接吃掉一个白，就可以规约到基础情况或者四黑一白的对白更加不利的情况。白方必败。

所以我们只用考虑初始不存在异色棋子相邻的情况。

考虑一种黑方的策略，我们将黑色棋子从左到右编号 $b_{1\dots 4}$：

* 若 $b_2$ 向右一步或 $b_3$ 向左一步不会被白棋攻击，那么就这么做。

* 若两个都不行，那么就将 $b_1$ 或 $b_4$ 随便移动到与中央不相干的位置以消耗步数。

* 显然白色的棋子绝对不能越出 $(b_2+1,b_3-1)$ 的范围，因为白子绝对不能移动到 $b_2$ 或者 $b_3$ 攻击的位置。这样会导致送掉一子或者对子。这都是致命的。

* 所以到最后，一定会形成“B-W*2-B”的局面。此时白方被迫对子。

所以白方必败。

白方先手呢？

有个结论：当且仅当在第一回合内，白子能白吃一个黑子时，白方的一个棋子可以逃脱。

这个结论的证明需要分类讨论。

要证明每一种第一回合内白子不能白吃一个黑子的情况均白方必败。

首先如果白子不吃黑子，那么相当于轮到黑方先手。白方必败。所以第一步必须吃黑子。

1. 两个白子均和黑色棋子相邻。

如果黑色棋子之间不相邻，那么白子吃掉一黑子后，另一白子将被另一黑子吃掉。规约到基础情况。

如果黑色棋子之间相邻，那么白子吃掉一黑子后该白子被反吃。另一白子再吃掉一枚黑子（不吃的话规约到基础情况，白方必败）。若另一白子不立刻被吃，那么现在就是两个 `B` 中间夹一个 `W` 的情况。通过类似上面两边逼近的方法，可以做到 `B-W-B` 的情况。此时如果轮到白方走，那么白子必被吃。如果轮到黑方走，那么就：`B-W--B` $\rightarrow$ `B--W-B` $\rightarrow$ `B-W-B`。这时候轮到白方走，白方必败。

2. 只有一个白子和黑子相邻。

这时候为了要满足“第一回合内白子不能白吃一个黑子”的前提，只能是 `BBW W B B`（空格表示中间隔了若干格）。

第一步只能吃一个黑子然后被反吃，那么规约到基础情况，白方必败。

3. 没有一个白子和黑子相邻。

吃不掉，白方必败。

综上所述，每一种第一回合内白子不能白吃一个黑子的情况均白方必败。

```cpp
#include<bits/stdc++.h>
#define Misaka namespace
#define Mikoto std
using Misaka Mikoto;
int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int main()
{
	int T=read(),i,a[7];
	char s[5];
	while(T--)
	{
		scanf("%s",s);
		for(i=1;i<=6;i++)
			a[i]=read();
		puts(*s=='W'&&(a[3]-a[2]==1)+(a[5]-a[4]==1)==1&&(a[3]-a[2]==1&&a[1]+1!=a[2]||a[5]-a[4]==1&&a[5]+1!=a[6])?"Yes":"No");
	}
}
```


---

## 作者：TLEWA (赞：1)

对于这道题，我们要分情况讨论：

## 情况1

黑先行且有黑子紧贴白子，如：

```
B 1 3 4 6 8 9
```
这种情况，黑可以先手吃掉一个白子，剩下的白子将要面对四个黑子，即使下回合吃掉一个黑子，依然被两面包围，黑子用还剩两个棋子的那边稳步推进即可，故游戏可以结束。


## 情况2

黑先行且无黑子紧贴白子，如：

```
B 1 3 5 6 8 9
```

这种情况，黑可以左右稳步推进，不给白棋不付代价就吃自己子的机会，直到白棋夹在中间，不得不走，如：
```
W 1 2 4 4 6 7
```
这样的场面，白只能出来送死一颗，即使吃掉了那边一颗黑，但还有一颗。剩下一边的黑子稳步推进即可。

## 情况3

白先行且无黑子紧贴白子，如：
```
W 1 3 5 6 8 9
```
显然，白走一步后，要么转化到情况 1，要么转换到情况 2，都是死路一条

## 情况4

难点来了！

白先行且有黑子紧贴白子，这个时候又需要更细分：

### 情况4.1

白有一侧紧贴黑子，如：
```
W 1 3 4 6 8 9
```
这个时候，白可以先手吃掉黑，游戏无法结束。但是又有一个特例：

#### 情况4.1.1

黑在那一侧是紧贴着的两个棋子，这个时候，黑又吃掉白一颗，如：
```
W 2 3 4 6 8 9
```
这个时候，白棋如果吃黑，那么自己也会被吃，于是白子输，游戏结束。

### 情况4.2

白有两侧紧贴黑子，如：
```
W 1 3 4 5 6 7
```
这个时候，白可以先手吃掉黑，但是这个时候，黑又可以吃掉白一颗，游戏结束。如果白棋龟缩，那么黑棋可以稳扎稳打吃掉白旗，游戏还是结束。


**至此，所有情况考虑完全。**

AC 代码：

```cpp
#include<iostream>

using namespace std;

int T,arr[10];
char c;

int main() {
	cin >> T;
	while(T--) {
		cin >> c;
		for(int i=1;i<=6;++i) cin >> arr[i];
		if(c=='W' && ((arr[2]+1==arr[3] && arr[1]+1!=arr[2]) != (arr[4]+1==arr[5] && arr[5]+1!=arr[6]))) cout << "Yes" << endl;
		else cout << "No" << endl;
	}
	
	return 0;
}
```



---

## 作者：President_Guan (赞：0)

很明显，这道题纯属数学推理题（我还小，别跟我谈什么博弈论）

分析题意可得，白方必定不会胜利，只能尽量让游戏无限进行下去。那么我们只考虑黑方能否胜利即可。

## 情况 1：黑方胜利
 
如果结局是黑方胜利，无非就是这种情况：

黑黑白白黑黑

黑方可以一个格叠两个子，逐渐向白方逼近，缩小白方的安全区域。最后逼迫白方一换一，从而消灭所有白方。

## 情况 2：游戏进入循环

想要进入循环，白方就要冲出黑方的包围圈，这就需要开局白方先手，将两个白方叠在一起，从而一起安全地冲出黑方的包围圈，但想用这种办冲出黑方的包围圈，就还要满足一个条件：开局仅有一个白方与黑方相邻，因为两个白方不能同时向一个方向移动，如果开局有两个白方与黑方相邻，走得慢的那个白方就会被前进方向的反方向的黑方吃掉，剩下的白方没了同伴，迟早也会被吃。

## 综上所述：

想让黑方胜利，就要满足以下任意一个条件：

1. 黑方先手

2. 开局有两个白方与黑方相邻。

这道题就做完了。代码这里就不放了，我的思路和题解区的大佬们都差不多，参考他们的代码就行了。

---

## 作者：KDZ22 (赞：0)

# 题面

[P8144 [JRKSJ R4] BBWWBB](https://www.luogu.com.cn/problem/P8144)

# 思考

第一遍读题很容易被带到搜索的坑里，但是读到题目中这样的描述：

> 两方的目标都是在己方不输的前提下，尽可能的令对方输。两方均采取最优策略。

也就是说，如果两方都足够聪明，那么绝对不会白丢任何一个棋子，**一般情况**下都只能是换子。

那么就可以抛开搜索，看看有没有什么规律。

初始局面只有一种：黑黑白白黑黑，显然黑方大优。

胜利的条件是把对方的棋子吃没，但白方少两子，不可能胜利，只能尽量让游戏无限进行下去。

那就要想清楚：什么时候游戏会无限进行下去呢？

（建议结合样例 #1 数据二思考一下）

只要白方能够用一个棋子在一边打出一个“通道”（即这个方向上没有黑子），用另一个棋子无限地往这个方向跑，游戏就会无限进行下去，不然最后一定会被两边的黑子围住，然后所有子都被换掉。

（另：以下的“白吃”皆专指“白白吃掉”，而非“被白方吃掉”）

概括一下，这是白方的策略：用一个棋子的代价消灭一个方向上的两个棋子（也就是要白吃一个黑子，再换掉同一方向的另一个黑子）。

但黑方不一样，人家能赢。

黑方只要保证白方不能用一个棋子在一边打出一个“通道”，那么必赢。

换句话说，只要黑方不被白吃就必赢。

那有人就要说了：按说只要黑方不是**白痴**就一定不会被**白吃**啊？

前面说如果两方都足够聪明，那么绝对不会白丢任何一个棋子，**一般情况**下都只能是换子。

但也有特殊情况，样例解释可以给我们很大的启发。

> 对于第 2 组数据，其中一种局面变化如下：

```
输入：W 1 3 4 6 8 9
W:
1 3 6 8 9
B W W B B
B:
1 3 6 8 8
B W W B B
W:
1 3 5 8 8
B W W B B
B:
1 3 5 7 8
B W W B B
W:
1 3 4 7 8
B W W B B
B:
1 3 4 7 7
B W W B B
W:
1 3 3 7 7
B W W B B
B:
1 3 3 6 7
B W W B B
W:
1 2 3 6 7
B W W B B
B:
2 3 6 7
B W B B
W:
2 6 7
W B B
```

悟了吧？“开局”就是我们说的“特殊情况”，只有这时，白方才有可能白吃一个黑子，以后再换掉一个黑子，从而让游戏无限进行下去。

那么什么时候能够白吃呢？

（建议先自己考虑 5 min ）

（…………）

（~~我也不知道五分钟到了没有，你要看那我也挡不住啊QWQ~~）

首先，白方必须先手，也就是黑方先手，白方必败。（这就是骗到那 15 分的原理）

其次，两个白子一共与且只与一个黑子相邻。（如果与两个黑子相邻，那么白方不管吃哪个，自己的另一个子必死无疑，就做不到白吃）

最后，与白子相邻的那个黑子不能与另一个黑子相邻。（要不然吃掉黑子的白子立马就会被吃掉）

那么实现就不难了。

# 代码实现

emmm…… 是的，就不粘代码了，分支结构应该没人不会吧？

那么，[去愉快地 AC 吧！](https://www.luogu.com.cn/problem/P8144#submit)

（更好的悦读体验请戳[这里](https://www.luogu.com.cn/blog/KDZ22/)）

---

## 作者：Yh0326 (赞：0)

仔细分析一下题意，我们可以发现：白色永远不可能赢！~~除非黑色是傻子~~

我们重新定义“赢”的概念：

黑赢：吃光所有白子

白赢：是游戏进入无限循环

那么题目问的就是白是否能赢

如果黑先，那么白必然会输（后面再解释）

那么我们在白色的角度解题：最优策略即为要么猛攻左面，要么猛攻右面。

定义一场“厮杀”为白方在一段连续时间内杀了对方至少一个子。

白色要想突围，必须在一场厮杀中杀掉黑方两个子或活下两颗子。

那我们就来考虑什么情况可以杀到两个子。

其实只有一种：其中一个白字和一个黑子相邻（当俩白子之间距离不为 $1$  时不能为两个，不然必被吃一子），白先，且被吃黑子旁边没有黑子

为什么呢？因为此时白色可以吃掉黑方一颗子，然后另一颗白子再过来与当前白子重合，此时必有一边只剩一颗黑子，那么想突围就非常的轻松了。

若黑子先，那么它必定会将距离拉近，此时白色若采用最优策略必定会虽小活动范围，最后就会被黑子围攻死。

那么思路说完了，直接上代码！

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10];
int main(){
    int t,y;
    scanf("%d",&t);
    while(t--){
        string s;
        cin>>s;
        if(s=="B"){//B先则W必输 
            for(int i=0;i<6;++i) scanf("%d",&y);//别忘读入！！！ 
            puts("No");
            continue;
        }
        else{
            for(int i=1;i<=6;++i) scanf("%d",a+i);
            if(((a[3]-a[2]==1&&a[2]-a[1]!=1)/*向左突围*/||(a[5]-a[4]==1&&a[6]-a[5]!=1)/*向右突围*/)&&((a[3]-a[2]!=a[5]-a[4]/*两边都相邻*/||a[4]-a[3]==1/*距离为1除外*/))){
                puts("Yes");
            }
            else puts("No");
            continue;
        }
    }
    return 0;
}
```


---

## 作者：IYSY2009I (赞：0)

这道题其实挺水的，但赛时读入字符读错了挂了 85 分/kk

说明：不要看我想那么多字就觉得这道题很难，我只是把易得的部分分析了一下。

分析可得，白方一定是不可能取得胜利的（除非黑方是个傻子），所以我们只需要探究在什么情况下黑可以去的胜利就行了。

再经过进一步分析可得，黑方只要做到白吃白方一个棋子或者与白方一换一就可以取得胜利。

感性理解一下：如果黑方与白方一换一可以取得胜利，那么显然黑方白吃白方一个棋子也可以获得胜利，在黑方白吃白方一个棋子后，局面很显然是这样的：

黑 一些空 白 一些空 黑 一些空 黑

那么这个时候我们只需要保证黑方两侧只要有一侧保持与仅剩余的一个白子中间只有一个空档，就可以迫使白方不断减小自己的活动范围，最终变成 黑 一个空 白 一个空 黑 白方只要动就会被白吃的死局，黑方从而获得胜利。

由此我们延伸：如果开局双方都无法白吃对方或者一换一，黑方也可以运用上面的方法逐渐缩小白方的可移动空间，最后迫使白方被黑方白吃一个或者与黑方一换一，黑方从而获得胜利。

综上所述，我们得出一个结论：白方必须要在开局白吃一个黑子，再和黑方一换一，从而清除一边的屏障，取得平局。

这里我们再回过头看  $15\%$ 的数据，很显然当黑方先手时，白方很显然无法白吃一个黑子（如果开局白子可以吃掉黑子黑子可以抢先白吃白子或者与白子一换一）。当然，我们都推出来正解了，写什么部分分？！

按上述分析模拟即可。

code:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+c-'0';
        c=getchar();
    }
    return x*f;
}
void cf(int x){
    int a[7];
    for(int i=1;i<=6;i++)
        a[i]=0;
    char c=getchar();
    while(c!='W'&&c!='B'){
        c=getchar();
    }
    for(int i=1;i<=6;i++)
        a[i]=read();
    if(c=='W'){
        if(a[3]-a[2]==1&&a[2]-a[1]>0&&((a[2]-a[1]>1&&a[5]-a[4]>1)||a[3]==a[4])){
            printf("Yes\n");
            return;
        }
        if(a[5]-a[4]==1&&a[6]-a[5]>0&&((a[6]-a[5]>1&&a[3]-a[2]>1)||a[3]==a[4])){
            printf("Yes\n");
            return;
        }
    }
    printf("No\n");
    return;
}
int main(){
    int t=read();
    for(int i=1;i<=t;i++)
        cf(i);
    return 0;
}
```


---

## 作者：_Clown_ (赞：0)

$\huge\texttt{Subtask \#1 015pts}$

我们考虑到白方必定不会赢。

那么我们考虑黑方是否必胜。

首先因为黑方先走，所以黑方丢的子一定不会比白方多。
- 当黑方不丢子时，我们考虑把黑方两边都叠子，然后向中间靠拢，黑胜。
- 当黑方与白方开局各丢一子时，黑方必然一边有两个子，另一边黑方有一个子，显然白方被困住，黑方可将两个子的一边向中间靠拢。

因此黑方必胜，输出 $\texttt{No}$ 即可得到 $\texttt{15pts}$。

$\huge\texttt{Subtask \#2 100pts}$

同样地，白方必定不会赢。

我们考虑黑方必胜的条件：
- 首先黑方第一步能够吃掉白方的一个子，
- 然后白方的第一步不能吃掉黑方的任何一个子。

这样黑方必胜，因为白方只剩一个子被困住，黑方可将子向中间靠拢。

其余情况显然白方可以破除一边的防守。

于是我们就通过了此题。
```cpp
#include<bits/stdc++.h>
using namespace std;
int A1,A2,A3,A4,A5,A6;
inline int Read()
{
    register int Return(0),Flag(0);
    register char C(getchar());
    for(;!isdigit(C);C=getchar())Flag^=!(C^45);
    for(;isdigit(C);C=getchar())Return=(Return<<1)+(Return<<3)+(C^'0');
    if(Flag)Return=-Return;
    return Return;
}
int main(void)
{
    register int Case(Read());while(Case--)
    {
        register char C[10];scanf("%s",C);
        register int i;A1=Read(),A2=Read(),A3=Read(),A4=Read(),A5=Read(),A6=Read();
        if(C[0]=='B')puts("No");
        else if(A3-A2==1&&A2-A1!=1&&A5-A4!=1||A5-A4==1&&A6-A5!=1&&A3-A2!=1)puts("Yes");
        else puts("No");
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

### 思路

分析题意可得，白方必定不会胜利，只能尽量让游戏无限进行下去。那么我们只考虑黑方能否胜利。

若想让戏能无限进行下去，必须满足以下条件。

1. 白方先手。

- 若黑方先手必然可以吃掉一个白方，白方仅有一个棋子，必输。

2. 白方第一轮可以吃掉一颗黑方。

- 因为只有 $3,4$ 是白方，所以只要判断 $a_{3}=1+a_{2}$ 或 $a_{4}+1=a_{5}$ 即可。

3. 白方吃完黑方后，不能被黑方吃掉另一个。

### AC Code
```
#include<bits/stdc++.h>
using namespace std;
char c;
int a[7],t;
bool h[1000000000];
int main() {
	cin>>t;
	while(t--) {
		cin>>c;
		for(int i=1; i<=6; i++) {
			cin>>a[i];
		}
		if(c=='B') {
			cout<<"No\n";
			continue;
		}
		if((a[2]+1==a[3] && a[1]+1!=a[2]) != (a[4]+1==a[5] && a[5]+1!=a[6])) {
			cout<<"Yes\n";
		} else {
			cout<<"No\n";
		}
	}
	return 0;
}
```

---


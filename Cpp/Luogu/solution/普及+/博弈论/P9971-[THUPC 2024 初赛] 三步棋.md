# [THUPC 2024 初赛] 三步棋

## 题目背景

昼短夜长冬至近。江冽漆黑，但见东云粉。窗外惺忪鸥鹭阵，室中香漫晨炊奋。

朝肄暮劳催彼盹。宵寂观书，灯烬方安寝。请替君劳分重任，逍遥共舞生辰顺。

## 题目描述

K 家里有一条不成文的规矩。如果家里只有 K 和 H 两个人，那么两个人会通过一种叫作“三步棋”的游戏来决定谁做饭。三步棋的规则与五子棋有一些相似之处。众所周知，五子棋是一种先连出五枚己方棋子者获胜的游戏。与五子棋相同的是，三步棋中双方也轮流在网格状的棋盘上摆放棋子，并根据是否连成指定的图案决定胜负。与五子棋不同的是：

1. 三步棋不区分双方的棋子，即可以认为双方执同色棋子进行游戏；

2. 在判定时，指定的图案不能旋转；

3. 如果连成指定的图案时，棋盘上的棋子数量恰好为 $3$ 的倍数，则连成指定的图案的一方获胜，否则判定该方负（即对方获胜）。

例如，如果指定的图案为

```
.o
oo
```

且当前盘面为

```
o..o.
o.o..
oo...
o.o..
o..o.
```

时，认为没有连成给定的折线形图案，其中 `o` 表示棋子，`.` 表示空格；但若接下来在第二行第二列放一枚棋子，则连成了给定的图案，对应的棋子使用 `@` 表示：

```
o..o.
o@o..
@@...
o.o..
o..o.
```

此时盘面上恰有 $11$ 枚棋子，而 $11$ 不是 $3$ 的倍数，所以判定放这枚棋子的玩家，也即先手输掉本局。

在 K 家，为了节约时间，通常使用 $5\times 5$ 的初始为空的棋盘进行三步棋。同时，每次也只会随机选择一个由不超过 $4$ 枚棋子组成的四连通图案。显然三步棋不存在平局，所以 K 和 H 约定由输的一方负责做饭。K 想知道，如果自己和 H 都足够聪明，那么以选中的图案进行的三步棋游戏是否为**先手必胜**；因为如果她更容易赢，她就要偷偷地给自己的妹妹放水。

## 说明/提示

### 样例 \#1 解释

该样例包含三组数据。

第一组数据输入的图案为 $1$ 行 $2$ 列的 `oo`。显然，无论先手将棋子放在棋盘上的哪个位置，后手都只有两种策略：

- 和先手的棋子连成 `oo`，此时棋盘上只有 $2$ 枚棋子，故后手立即输掉游戏；

- 不和先手的棋子连成 `oo`，但是接下来轮到先手时，先手可以任意连成 `oo`，此时棋盘上恰有 $3$ 枚棋子，故先手取胜。

无论是哪种策略，后手都无法取胜，故对于 `oo` 而言**先手必胜**。

第二组数据输入的图案为 $2$ 行 $1$ 列的图案，与 `oo` 同理，可知为**先手必胜**。

第三组数据输入的图案为 $1$ 行 $3$ 列的 `ooo`，可以证明为先手必败。

### 子任务

保证 $1\le T\le 200$。对于每组数据，保证输入的 $5\times 5$ 的由 `.` 和 `o` 组成的字符矩阵中至少含有一个 `o`，且所有 `o` 组成一个大小不超过 $4$ 的四连通块。

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
3
.....
oo...
.....
.....
.....
.o...
.o...
.....
.....
.....
.....
.....
.....
.ooo.
.....
```

### 输出

```
Far
Far
Away
```

# 题解

## 作者：Junounly (赞：8)

很有意思的一道题，~~使我的手旋转~~赛时手玩出结论，为了~~弥补吃的两发罚时~~造福后人，写的详细一点

题目大意是多组询问，每次给你一个 $5\times5$ 的方格和一个不超过 $4$ 个棋子的连通图案，两个人轮流，每次各放一个棋子，直到一方拼出给定图案。若此时棋盘上棋子个数是 $3$ 的倍数，其获胜；反之另一方获胜。求先手是否必胜。

情况不多，选择分类讨论。~~（事实上 ICPC 赛制可以把所有情况都试一遍）~~

令 $t=$ 给定图案的棋子个数。

* 若 $t=1$，先手必败。（这不用解释吧）
  
* 若 $t=2$，样例已经解释过了，当先手放下棋子，后手只有两种选择：与或者不与先手放下的棋子组成图案。如果与，那么棋盘上有 $2$ 颗棋子，先手就赢了；如果不与，先手只需要下 $1$ 颗棋与刚才的组成图案，棋盘上有 $3$ 颗棋子，先手还是赢，所以先手必胜。
  
* 若 $t=3$，考虑第 $1$ 个赢的机会，此时场上有 $3$ 颗棋子，先手下 $2$ 颗，后手下 $1$ 颗，此时先手刚下完，只能先手赢，若先手想赢，那就必须使 $3$ 颗棋子组成图案，那后手就要尽量避免这种情况，后手只需要在先手下完第 $1$ 颗棋子后，选 $1$ 个不可能与那颗棋组成图案的位置即可，所以第 $1$ 个机会一定用不到；接着考虑第 $2$ 个赢的机会，此时场上有 $6$ 颗棋子，先手下 $3$ 颗，后手下 $3$ 颗，同理只能后手赢，若后手想赢，就可以直接用这 $3$ 颗棋子的机会拼出图案，所以先手必败。
  
* 若 $t=4$，同样考虑第 $1$ 个赢的机会，场上棋子不到 $4$ 颗，不可能赢；考虑第 $2$ 个赢的机会，还是先手下 $3$ 颗，后手下 $3$ 颗，后手显然有一种策略就是利用先手的第 $1$ 颗棋和自己的 $3$ 颗拼出图案，但如果后手无法利用先手的第 $1$ 颗棋呢？（我赛时就因为这个吃了罚时）
  

* ![情况.png](https://cdn.acwing.com/media/article/image/2023/12/23/142100_adf3104fa1-情况.png)
  
* 由于将图案旋转后不会影响结果，所以可以简化成以上 $5$ 种形状，容易发现，对于形状 $1$ 和 $2$，不存在后手无法利用的位置，所以先手必败；对于形状 $3$、$4$ 和 $5$，先手只要下左上角，后手就无法利用这颗棋子，那么后手将失去第 $2$ 次机会，接下来考虑第 $3$ 次机会，此时场上有 $9$ 颗棋子，先手下 $5$ 颗，后手下 $4$ 颗，先手虽然已经浪费掉第 $1$ 次机会来阻止后手利用，但剩下的 $4$ 颗棋子足够组成图案，所以先手必胜。
  

经过上面的分类讨论，最终只需要依次判断并输出结果就可以了。

**Code:**

```c++
#include<bits/stdc++.h>
using namespace std;
int T;
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        char c;int cnt=0;
        int mnx=6,mny=6,mxx=0,mxy=0;
        for(int i=1;i<=5;i++)
            for(int j=1;j<=5;j++)
            {
                cin>>c;
                if(c=='o')
                {
                    cnt++;
                    mnx=min(mnx,i);mny=min(mny,j);
                    mxx=max(mxx,i);mxy=max(mxy,j);
                }
            }
        printf(cnt==2||(cnt==4&&(mxx-mnx>=2||mxy-mny>=2)&&(mxx-mnx<3&&mxy-mny<3))?"Far\n":"Away\n");
    }
    return 0;
}
```

---

## 作者：HyB_Capricornus (赞：2)

赛场切掉的一道题。

首先发现连通块大小只有 $4$。

讨论一下就行了。

**连通块大小为** $1$：

很显然，先手无论第一步下哪里都满足成为指定图案的条件，而这时场上棋子数量为 $1$，不为 $3$ 倍数，所以先手必败。

**连通块大小为** $2$：

根据样例解释，可知先手必胜。

**连通块大小为** $3$：

后手有必胜策略：

首先无论先手第一步下哪里，后手只需与其不相邻：

```
.2...
.....
..1..
.....
.....
```

然后不管对手第三步和第五步下在哪里，后手第第四步与第六步只需与第二步围成指定图形即可。

如指定图形为

```
.....
.....
..oo.
..o..
.....
```

```
.26..
.4...
..1..
.....
3..5.
```

问：为什么 $3$ 和 $5$ 不能和 $2$ 组成指定图形呢？

答：$3$ 的时候组成不了，$5$ 的时候就算组成了也不是 $3$ 的倍数，组成了也是输。

问： 有没有可能 $4$ 和 $6$ 不可以与 $2$ 组成指定图形呢？

答：没有可能，只要 $2$ 的选位足够优秀。

所以先手必败。

**连通块大小为** $4$：

后手的思路与上文一样，但 $2$、$4$、$6$ 肯定无法组成指定图案，需要与 $1$、$3$、$5$ 中的一个一起组成。

这时先手就可以想了，有没有无敌点位把我的 $1$、$3$、$5$ 放进去使得 $2$、$4$、$6$ 与我的 $1$、$3$、$5$ 组不成指定图案？

答案是，对于这几种图形，没有。

```
.....
.....
.oooo
.....
.....
```

```
..o..
..o..
..o..
..o..
.....
```

```
.....
.....
.oo..
.oo..
.....
```

对于这几种图形，先手必败。

而对于以下图形以及其旋转翻转后的图形：

```
.....
.....
..oo.
.oo..
.....
```

```
.....
.....
.ooo.
..o..
.....
```

```
.....
..o..
..o..
.oo..
.....
```

每个都有两个无敌点位，分别为：

```
x....
.....
.....
.....
....x
```

```
.....
.....
.....
.....
x...x
```

```
x....
x....
.....
.....
.....
```

先手可以把 $1$ 与 $3$ 放置在这些点位中，然后把 $5$ 放在与 $4$ 和 $2$ 完全不相邻的位置中，这时 $6$ 的时候，后手肯定不能结束游戏。

这时先手和后手角色就互换了，后手需要竭力保证先手不会在 $9$ 时结束游戏，然而后手没办法，因为没有无敌点位了。

按照后手的策略，先手必将在 $9$ 时结束游戏。

所以，对于这些图形和这些图形旋转翻转得到的图形，先手必胜。

然后就可以写代码了。

```c++
#include <iostream>
#include <cstdio>
#define very_fast ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
int T;
char a[7][7];
signed main(void) {
    very_fast;
    cin >> T;
    while (T--) {
        int cnt=0;
        for (int i=1;i<=5;i++)
            for (int j=1;j<=5;j++) {
                cin >> a[i][j];
                if (a[i][j]=='o') cnt++;
            }
        if (cnt==1) cout << "Away\n";
        if (cnt==2) cout << "Far\n";
        if (cnt==3) cout << "Away\n";
        if (cnt==4) {
            int fx=-1,fy=-1;
            for (int i=1;i<=5;i++) {
                for (int j=1;j<=5;j++) {
                    if (!(fx+1)&&!(fy+1)&&a[i][j]=='o') {
                        fx=i,fy=j;
                    }
                }
            }
            if (a[fx+1][fy]=='o'&&a[fx+2][fy]=='o'&&a[fx+3][fy]=='o') {
                cout << "Away\n";
            } else if (a[fx][fy+1]=='o'&&a[fx][fy+2]=='o'&&a[fx][fy+3]=='o') {
                cout << "Away\n";
            } else if (a[fx][fy+1]=='o'&&a[fx+1][fy]=='o'&&a[fx+1][fy+1]=='o') {
                cout << "Away\n";
            } else {
                cout << "Far\n";
            }
        }
    }
    return 0;
}
```

---

## 作者：__3E24AC7002AD9292__ (赞：1)

无知时诋毁罚时，懂事时诋毁罚时，成熟时诋毁罚时，幻想中诋毁罚时。

但是 $1\leq x\leq4$！自然想到分类讨论，不妨试试看。

- $x=1$。

不必多说，在先手落子的时候就结束了，先手必然是输的。

- $x=2$。

看样例解释吧。

第一组数据输入的图案为 $1$ 行 $2$ 列的 `oo`。

显然，无论先手将棋子放在棋盘上的哪个位置，后手都只有两种策略：

和先手的棋子连成 `oo`，此时棋盘上只有 $2$ 枚棋子，故后手立即输掉游戏；

不和先手的棋子连成 `oo`，但是接下来轮到先手时，先手可以任意连成 `oo`，此时棋盘上恰有 $3$ 枚棋子，故先手取胜。

无论是哪种策略，后手都无法取胜，故对于 `oo` 而言先手必胜。

第二组数据输入的图案为 $2$ 行 $1$ 列的图案，与 `oo` 同理，可知为先手必胜。

然而这就是仅有的 $x=2$ 的两种情况了。

- $x=3$。

如果先手想赢，那么他第一个赢的机会就在前三次落子，包括后方的一次落子。后方显然可以选择一个位置进行第二次落子阻止先手第三次落子就获胜，不必证明。

而后手必然可以在六次落子内完成图案，所以后手有必胜策略。

- $x=4$。

在前三次落子显然无法构成图案。

考虑前六次，后手无需考虑 $x=3$ 时第二次落子躲避第一个棋子。所以只要先手的第一个棋子能被后手利用，后手就是必胜。

考虑如何让先手的第一颗棋子不被利用，假设图案是这样的：

```
.o
.o
oo
```

那么你会发现，如果先手第一次落子在第一行第一列或者第二行第一列，这样这颗棋子是无法被利用的，也就是不能构成图案的。

打表发现除了田字格和 $1\times 4$ 的长条及其翻转 $90$ 度形式都有这种不被利用的格子，特判即可。

---

## 作者：fydj (赞：1)

# P9971 [THUPC 2024 初赛] 三步棋

### 题目大意

给一个五行五列的棋盘，两个人轮流下棋，给定一个大小不超过 $4$ 的四连通块作为判定图案，如果在棋盘中连成了指定图案，当棋盘上棋子数刚好为 $3$ 的倍数，连成图案的一方获胜，否则另一方获胜。

### 思路

首先直接暴力模拟，因为棋盘是五行五列的，只有 $25$ 个格子，可以状压记忆化搜索。

递归返回的值是 $1$ 表示先手必胜，$2$ 表示后手必胜。枚举先手下哪一步棋，如果她无论走哪一步形成的局面都是先手必胜的话，她就输了，因为她走完这一步后就变成了后手；如果她可以走一步使得形成的局面是后手必胜，那么她就走这一步。可以发现，一个局面要么先手有必胜策略，要么后手有。

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define lowbit(x) ((x)&-(x))
using namespace std;
typedef long long ll;
const int N=35554432;
char chart; bool fushu;
template <typename T> void read(T &a) { a=fushu=0; do chart=getchar(); while((chart<48||chart>57)&&chart!='-'); if(chart=='-') fushu=1,chart=getchar(); do a=(a<<1)+(a<<3)+(chart^48),chart=getchar(); while(chart>47&&chart<58); if(fushu) a=-a; return ; }
template <typename T,typename ...Args> void read(T &a,Args &...args) { read(a); read(args...); return ; }
int T,in[15][15]={},d[15][15]={},a[15][15],f[N]={};
int firsthang() { int i,j,f; for(i=1;i<=5;++i) { f=1; for(j=1;j<=5&&f;++j) if(in[i][j]) f=0; if(!f) return i; } }
int firstlie() { int i,j,f; for(i=1;i<=5;++i) { f=1; for(j=1;j<=5&&f;++j) if(in[j][i]) f=0; if(!f) return i; } }
int count(int S) { int rey=0; while(S) ++rey,S-=lowbit(S); return rey; }
bool pipei(int S) {
	int i,j,u=1,mp[15][15]={},ii,jj,f;
	for(i=1;i<=5;++i) for(j=1;j<=5;++j) mp[i][j]=((S&u)!=0),u<<=1;
	for(i=0;i<5;++i)
		for(j=0;j<5;++j) {
			f=1;
			for(ii=1;ii<=5&&f;++ii)
				for(jj=1;jj<=5&&f;++jj)
					if(d[ii][jj]&&!mp[i+ii][j+jj])
						f=0;
			if(f) return true;
		}
	return false;
}
int dfs(int S) {
	if(f[S]!=0) return f[S];
	if(pipei(S)) {
		if(count(S)%3==0) f[S]=2;
		else f[S]=1;
	} else {
		int i,u=1,ff;
		f[S]=2;
		for(i=1;i<=25;++i,u<<=1)
			if((S|u)!=S) {
				ff=dfs(S|u);
				if(ff==2) { f[S]=1; break; }
				else if(ff!=1) f[S]=-1;
			}
	}
	return f[S];
}
int main()
{
	//freopen("chess.in","r",stdin);
	//freopen("chess.out","w",stdout);
	int i,j,fh,fl;
	read(T);
	loop : --T;
    memset(in,false,sizeof(in));
    memset(d,0,sizeof(d));
    memset(a,0,sizeof(a));
    memset(f,0,sizeof(f));
	for(i=1;i<=5;++i) for(j=1;j<=5;++j) { do chart=getchar(); while(chart!='.'&&chart!='o'); in[i][j]=chart=='o'; }
	fh=firsthang(),fl=firstlie();
	for(i=0;i<5;++i) for(j=0;j<5;++j) d[i+1][j+1]=in[fh+i][fl+j];
	dfs(0); printf("%s\n",f[0]==1?"Far":"Away");
	if(T) goto loop;
}
```

发现它跑得不快，又因为有 $200$ 组数据，所以需要优化。

由于连通块大小最多为 $4$，所以打表就好了。

大小为 $1$：只有一种情况，后手必胜。

大小为 $2$：只有一种情况，先手必胜。

大小为 $3$：有两种情况，一种是三个棋子连成一线，另一种是 L 型的，都是后手必胜。

大小为 $4$：五种情况，如下，前三种先手必胜，后两种后手必胜。

```
o...o...o...o..oo...
oo..oo..o...o..oo...
.o..o...oo..o.......
............o.......
```

判定图案旋转后的答案和原来的答案一样。

分类讨论就好了。

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long ll;
char chart; bool fushu;
template <typename T> void read(T &a) { a=fushu=0; do chart=getchar(); while((chart<48||chart>57)&&chart!='-'); if(chart=='-') fushu=1,chart=getchar(); do a=(a<<1)+(a<<3)+(chart^48),chart=getchar(); while(chart>47&&chart<58); if(fushu) a=-a; return ; }
template <typename T,typename ...Args> void read(T &a,Args &...args) { read(a); read(args...); return ; }
int T,in[15][15];
int d[3][15][15]={ { {1,1,1,1} }, { {1},{1},{1},{1} }, { {1,1},{1,1} } };
bool pipei(int u) {
	int i,j,ii,jj,f;
	for(i=1;i<=5;++i)
		for(j=1;j<=5;++j) {
			f=1;
			for(ii=0;ii<5&&f;++ii)
				for(jj=0;jj<5&&f;++jj)
					if(d[u][ii][jj]&&!in[i+ii][j+jj])
						f=0;
			if(f) return true;
		}
	return false;
}
int main()
{
//	freopen("chess.in","r",stdin);
//	freopen("chess.out","w",stdout);
	int i,j,cnt;
	read(T);
	loop : --T;
	cnt=0;
	for(i=1;i<=5;++i) for(j=1;j<=5;++j) { do chart=getchar(); while(chart!='.'&&chart!='o'); in[i][j]=chart=='o'; cnt+=in[i][j]; }
	if(cnt==2||cnt==4&&!pipei(0)&&!pipei(1)&&!pipei(2)) printf("Far\n");
	else printf("Away\n");
	if(T) goto loop;
}
```



---

## 作者：Rainsleep (赞：1)

鸣谢 [cinccout](https://www.luogu.com.cn/user/201748)。赛时两次看出了我的   bug/bx。

闲话：在我看过的所有人的做题过程中，大家都不约而同的把 **棋子数量相同时答案相同** 当作了第一发（。但是很可惜，这个结论是错误的。

---

样例已经给出了当棋子数量为 $2$ 的答案，在此我们略去讨论。

对于棋子数量为 $1$ 答案也很明显是后手必胜。

在进行讨论前，需要声明：**能够通过旋转任意角度重合的两个图形，他们的答案相同。**
>对于证明，考虑虽然形状不能转，但是由于棋盘是正方形，所以我们可以旋转棋盘并且不改变形状，显然同一种形状的不同摆放状态都是相同的答案。

### 棋子数量为 $3$ 时

对于棋子数量为 $3$，我们有两种本质不同的情况。即
```
o
oo ooo
```

第二种样例中已给出答案，故略去讨论。对于第一种形状，这里给出一种必胜策略。

假设目标图形为
```
o    101
oo   010
```
（右侧为先后顺序，并且第三列可以决胜负）

第一步随便下，对于后手的第二步肯定不能帮助先手拼凑图形，否则在下一步先手可以直接获得胜利。那么后手只要不下在先手的图形位置上就可以到下一轮。

我们发现第二轮的先手无法取胜，而在第二轮结束前后手总共有三步棋，可以直接按照自己的节奏胜利。

不过事情并没有这么简单。我们观察发现，角落里的一些格子似乎有着非凡的作用。

当图形如上时，如果我们下在棋盘的右上角那么，我们发现这一格无法作为形状中的任何一颗棋出现。于是相当于把相同的局面交给了后手，不过后手有三步可以操作是确实的，所以在这种情况中，先手无法干扰后手的必胜，故后手必胜。

### 棋子数量为 $4$ 时

总共有如下五种本质不同的形状。

```
     o   ooo oo  oo
oooo ooo  o   oo oo
```

我们不妨从刚刚那种角落的棋子入手，这种存在可以交换先后手。我们发现 **除了长条和方块形状** 的其余形状，棋盘上都有 **两** 个位置，无法充当形状的部分。

这告诉我们，当我们想要 **借先手的某枚棋子** 构造从而在第二轮结束游戏时，先手可以下在这样的位置，从而变为后手。不过由于这样的位置有两个，所以后手可以再下在这样的地方变回先手。

经过这样的过程，我们的先后图变为了
```
xx1
010
101
```

我们发现后手在第二轮无法结束游戏，即使借助先手的一枚棋子构造也也只有 $1 + 2 = 3$ 的操作空间。

而先手可以在第三轮以 $1 + 4 = 5$ 的操作空间差取得胜利。

对于长条和方块形，没有上述类似的无用点，先手无法在第一轮结束，后手可以用 $1 + 3$ 都操作空间结束游戏。

至此，我们结束了所有讨论。抓住会影响先后以及棋子数量的无用点，以及双方的操作空间大小，再细致讨论即可。

[code](https://thupc2024.thusaac.com/contest/2/submission/13397)


---

## 作者：Jsxts_ (赞：1)

这题其实可以直接瞪出来。设图案中棋子数为 $x$。

- $x=1$，显然先手必输。
- $x=2$，显然先手必胜。
- $x=3$，显然先手必输，因为后手显然有办法让先手第 $3$ 步不能完成并且在自己的第 $6$ 步一定完成。注意这里先手无论怎样干扰后手的图案都是无效的，后手只需保证在第 $6$ 步达成目标即可。
- $x=4$。此时若先手第一步就在中间放一个，后手就可以借助先手的这颗棋子加上自己的 $3$ 颗棋在第六步获胜。所以先手需要找到一个位置满足这个棋子不能成为构成目标图案其中一个棋子。若有这样的位置，那么后手的第 $6$ 步则构不成目标，但先手还有第 $3,5,7,9$ 步共 $4$ 步，足够完成图案，所以先手获胜。之后，我们发现除了田字格和 $1\times 4,4\times 1$ 的图案外都可以找到这样的位置。

讨论结束。

---


# [蓝桥杯 2022 省 A] 青蛙过河

## 题目描述

小青蛙住在一条河边，它想到河对岸的学校去学习。小青蛙打算经过河里的石头跳到对岸。

河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。不过，每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就会下降 $1$，当石头的高度下降到 $0$ 时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 $0$ 是允许的)。

小青蛙一共需要去学校上 $x$ 天课，所以它需要往返 $x$ 次，即过河 $2x$ 次。当小青蛙具有一个跳跃能力 $y$ 时，它能跳不超过 $y$ 的距离。

请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。

## 说明/提示

**【样例解释】**

由于只有两块高度为 $1$ 的石头，所以往返只能各用一块。第 $1$ 块石头和对岸的距离为 $4$，如果小青蛙的跳跃能力为 $3$ 则无法满足要求。所以小青蛙最少需要 $4$ 的跳跃能力。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例，$n \leq 100$;

对于 $60 \%$ 的评测用例，$n \leq 1000$;

对于所有评测用例，$1 \leq n \leq 10^{5}, 1 \leq x \leq 10^{9}, 0 \leq H_{i} \leq 10^{4}$ 。 

蓝桥杯 2022 省赛 A 组 F 题。

## 样例 #1

### 输入

```
5 1
1 0 1 0```

### 输出

```
4```

# 题解

## 作者：Y_ATM_K (赞：107)

[题面](https://www.luogu.com.cn/problem/P8775)

## 分析

容易发现，青蛙从左跳到右和从右到左没有区别，因此相当于青蛙从左到右跳 $2x$ 次。

通过几个样例，可以发现这样一个规律：对于一个跳跃能力 $y$，青蛙能跳过河 $2x$ 次，当且仅当对于每个长度为 $y$ 的区间，这个区间内 $h$ 的和都大于等于 $2x$。

证明一下。

先证明必要性。

假设青蛙能跳过 $2x$ 次，对于一个长度为 $y$ 的区间，因为青蛙无论怎么跳，都必须经过这个区间，所以这个区间所有 $h$ 的和必定大于等于 $2x$。

再证明充分性。

我们让 $2x$ 只青蛙一起跳。对于青蛙跳一次能到达的区间 $[1,y]$，这里显然可以跳 $2x$ 只青蛙。那么考虑让 $1$ 位置上的青蛙跳到 $y+1$ 位置上。

若 $h_1 \le h_{y+1}$，则 $1$ 的青蛙全部能跳到 $y+1$ 上；

若 $h_1 > h_{y+1}$，因为 $\sum_{i=2}^{y+1}h_i \ge 2x$，

即 $\sum_{i=2}^{y}h_i \ge 2x - h_{y+1}$，所以区间 $[2,y]$ 能容纳 $2x - h_{y+1}$ 之青蛙，可以让多出来的几只跳到 $[2,y]$ 中。

以此类推，可以让 $2x$ 只青蛙全部跳过河。

于是可以用双指针扫一遍，得到满足条件的最小的 $y$ 即可。

时间复杂度 $O(n)$.

## 代码
```cpp
#include <bits/stdc++.h>
#define N 100005
using namespace std;
int n,T,h[N],ans;
int main() {
	scanf("%d%d",&n,&T);T<<=1;
	for(int i=1;i<n;++i) scanf("%d",&h[i]);
	for(int i=1,j=0,sum=0;i<n;++i) {
		while(j<n&&sum<T) sum+=h[++j];
		ans=max(ans,j-i+1);
		sum-=h[i];
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：xhgua (赞：55)

题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P8775)

$\Large\texttt{Description}$

有 $n-1$ 块石头排成一条直线，第 $i$ 块石头有一个高度 $h_i$，小青蛙打算经过河里的石头跳到对岸。

小青蛙每次跳跃必须落在一块石头或者岸上，每次从一块石头起跳，这块石头的高度就会下降 $1$，当石头的高度下降到 $0$ 时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 $0$ 是允许的)。

小青蛙一共需要去学校上 $x$ 天课，所以它需要往返 $2x$ 次。当小青蛙具有一个跳跃能力 $y$ 时，它能跳不超过 $y$ 的距离。

请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。

$\Large\texttt{Analysis}$

跳回来和跳到对岸是没有区别的，所以题目可以看作有 $2x$ 只青蛙一起从左岸跳到右岸。

不难想到二分 $y$ 的值，通过判断当前 $y$ 是否能够使 $2x$ 只青蛙跳过岸来缩小边界。

难点在于 `check` 函数上，如何判断某个跳跃能力是否能够使 $2x$ 只青蛙跳过岸呢？

---

$\textbf{Key Conclusion :}$ 跳跃能力 $y$ 是合法的 $\iff$ 所有长度为 $y$ 的区间内的石头高度和 $\geq 2x$。

$\textbf{Proof :}$ 

容易发现，任意一个长度为 $y$ 的区间都会被每只青蛙踩至少一次，那么 $2x$ 只青蛙就至少会踩 $2x$ 次，所以每个区间内的高度和都必须要 $\geq 2x$。

在这 $2x$ 只青蛙过河的任意时刻，每个区间的青蛙个数和不会超过 $2x$，所以满足上面的条件后一定可以使所有青蛙过河。

这样描述可能不是很好理解，我们来模拟一下青蛙跳跃的过程：

- 刚开始，所有青蛙都跳出一步，此时 $2x$ 只青蛙均在区间 $[1,y]$ 中。

- 紧接着，处于石头 $1$ 上的所有青蛙跳到区间 $[2,y+1]$ 中，由于每个区间的高度和都 $\geq 2x$，所以区间 $[2,y+1]$ 一定能容下这些青蛙。

- 之后青蛙们就可以以类似的方式跳到 $[3,y+2], [4,y+3],\dots$ 一直到 $[n-y,n-1]$，然后就可以一步到达对岸。

故每个区间高度和 $\geq 2x$ 是 $y$ 合法的充分必要条件。

$\textbf{Q.E.D.}$

---

有了这个性质之后，`check` 函数就很好写了，使用前缀和快速计算出每个区间的高度和即可。

$\Large\texttt{AC Code}$

```cpp
#include <bits/stdc++.h>

#define i64 long long
#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define per(i, a, b) for (int i = (a); i >= (b); i--)

using namespace std;

const int N = 1e5 + 5;

int n, x;
i64 arr[N], sum[N];

bool check(int y) {
	rep(i, y, n - 1) if(sum[i] - sum[i - y] < 2 * x) return false;
	return true;
}

int main() {

    cin >> n >> x;
    rep(i, 1, n - 1) {
    	cin >> arr[i];
    	sum[i] = sum[i - 1] + arr[i];
    }
    
    int l = 1, r = n;
    while(l < r) {
    	int mid = (l + r) / 2;
    	
    	if(check(mid)) r = mid;
    	else l = mid + 1;
    }
    
    cout << r << endl;

    return 0;
}
```

---

## 作者：Moya_Rao (赞：33)

# 题目大意

小青蛙要跳石头过河。河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。每次小青蛙从一块石头起跳，这块石头的高度就会下降 $1$。当某块石头的高度下降到 $0$ 时小青蛙就不能再跳到这块石头上了。

小青蛙需要往返 $2x$ 次。小青蛙有一个跳跃能力。当小青蛙的跳跃能力是 $y$ 时，它能跳不超过 $y$ 的距离。

请问小青蛙的跳跃能力应至少是多少。

# 主要思路

首先得知道，跳过去和跳回来是没有区别的，因此题目可以看作 $2x$ 只青蛙一起跳过去。

接着，我看到“至少”二字，立刻想到了二分，二分小青蛙的跳跃能力。

那么问题来了，`check` 函数该怎么写呢？

仔细观察能够发现，每一个长度为 $y$ 的区间都会被每只青蛙至少踩一遍，一共至少踩 $2x$ 遍。因此每个长度为 $y$ 的区间内的石头高度之和都应该 $\ge 2x$。  
那么 `check` 函数就可以根据这个特征来写了，用一维前缀和记录即可（一维前缀和总不至于还有人不会用吧，不会用的[看这里](https://blog.csdn.net/m0_74087268/article/details/139888958)，顺便也了解下二维的吧）。

时间复杂度 $O(n \log n)$，交上去直接 [AC](https://www.luogu.com.cn/record/164798138)！

# 参考代码
现在上 AC 代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
long long n,x,h[N],s[N],l,r,ans;
bool check(long long y){
    for(int i=y;i<n;i++)
        if(s[i]-s[i-y]<2*x)return 0;
    return 1;
}
int main(){
    cin>>n>>x;
    for(int i=1;i<n;i++){
        cin>>h[i];
        s[i]=s[i-1]+h[i];
    }
    l=1,r=n;
    while(l<=r){
        long long mid=(l+r)/2;
        if(check(mid))ans=mid,r=mid-1;
        else l=mid+1;
    }
    cout<<ans;
    return 0;
}
```
觉得写得还可以就留个赞再走，好吗？

---

## 作者：quanjun (赞：18)

### 题目链接

[https://www.luogu.com.cn/problem/P8775](https://www.luogu.com.cn/problem/P8775)

### 题目大意

小青蛙住在一条河边，它想到河对岸的学校去学习。小青蛙打算经过河里的石头跳到对岸。

河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。不过，每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就会下降 $1$，当石头的高度下降到 $0$ 时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 $0$ 是允许的)。

小青蛙一共需要去学校上 $x$ 天课，所以它需要往返 $2x$ 次。当小青蛙具有一个跳跃能力 $y$ 时，它能跳不超过 $y$ 的距离。

请问小青蛙的跳跃能力至少是多少才能用这些石头上完 $x$ 次课。

### 解题思路

不妨看一下 [CF965D Single-use Stones](https://www.luogu.com.cn/problem/CF965D) 这道题，然后你就会发现两道题目几乎一摸一样。

本题只是在 CF965D 的基础上加了一个二分。

两道题最主要要解决的问题都是一样的，就是：

> 如何计算当跳跃能力为 $k$ 时最多能够上多少次课。

解决这个问题的方法有很多，我使用的是 **贪心**，思路是这样的：

当跳跃能力为 $k$ 时，对于第 $i$ 块石头，能跳到它的石头对应的区间是 $[i-k, i-1]$，此时必然优先选下标小的。为什么呢？因为如果 $i-k$ 和 $i-k+1$ 都可以选择，我选择 $i-k$ 必然更优，因为留下来的 $i-k+1$ 还可以跳到第 $i+1$ 个石头，但是如果留下来 $i-k$，是不能跳到第 $i+1$ 个石头的。所以，对于第 $i$ 块石头，优先选择下标 $i$ 的石头作为其前一步的石头能够导致我的剩余局面最优，符合贪心思想。

那么，同样的道理反过来思考，如果我当前在第 $i$ 个石头，我能够跳到的石头的区间范围是 $[i+1, i+k]$，我也会优先选择下标大的那个石头跳过去。

所以可以设计一个 `cal(k)` 函数，其返回跳跃能力为 $k$ 时最多能够上多少次课。

然后，答案的区间范围是 $[1, n]$，所以在区间 $[1, n]$ 范围内二分判断 `cal(k) >= 2*x` 就能够找到能上至少 $2x$ 次课的最低跳跃能力了。

### 示例程序

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 5;

int n, x, h[maxn], c[maxn];

int cal(int k) {
    memset(c, 0, sizeof(int)*(n+1));
    h[0] = c[0] = h[n] = 2e9;
    stack<int> stk;
    for (int i = 1; i < k; i++) stk.push(i);
    for (int i = 0; i < n; i++) {
        if (i+k <= n && h[i+k]) stk.push(i+k);
        while (c[i] && !stk.empty() && stk.top() > i) {
            int j = stk.top();
            // i --> j
            int t = min(c[i], h[j] - c[j]);
            c[i] -= t;
            c[j] += t;
            if (c[j] == h[j]) stk.pop();
        }
    }
    return c[n];
}

int main() {
    cin >> n >> x;
    for (int i = 1; i < n; i++) cin >> h[i];
    int l = 1, r = n, res;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (cal(mid) >= 2 * x) {
            res = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    cout << res << endl;
    return 0;
}
```

---

## 作者：liaoxingrui (赞：3)

# [题目](https://www.luogu.com.cn/problem/P8775)

### 思路：

小青蛙过 $2 \times x$ 次河，可以看成 $2 \times x$ 只青蛙过一次河。

**注意：在 $y$ 的范围内这 $2 \times x$ 只青蛙必须落脚！**

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,t,sum,y,H[100005];
//n、x、y和H数组皆是题目中的意思，t是记录那2乘x只青蛙最后落脚的下标，sum表示有几只青蛙落脚了。 
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>x;
    for(int i=1;i<n;i++)
	 	cin>>H[i];
    for(int i=1;i<n;i++){
        while(sum<=x*2&&t<n)
			sum+=H[++t];
        y=max(y,t-i+1);
        sum-=H[i];
    }
    cout<<y;
    return 0;
}
```

---

## 作者：_Emperorpenguin_ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8775)
## 题意简述

有一只青蛙要过河，但是它不能直接跳过河。它需要经过一些石头才能到底对岸。青蛙的最大跳跃距离为 $y$，每从一块石头上跳走，这块石头的高度会下降 $1$。求 $y$ 的最小值。 

## 思路

首先，本题 $n$ 的极限值为 $10^5$，若想通过本题则需要使用二分答案和前缀和来优化时间复杂度。

其次，因为每一次去学校，都要过两次河，所以实际上青蛙过河的总次数为 $2\times x$。
 
由题意易得：在长度为 $y$ 的区间里，每一次过河，其中必定有一块石头的高度会下降 $1$。所以，在一共的 $2\times x$ 次过河中，每一个长度为 $y$ 的区间里的所有石块的高度和都会减去 $2\times x$。 

因此，要想使青蛙成功地过 $2\times x$ 次河，就要使每一个长度为 $y$ 的区间里的所有石块的高度和大于等于 $2\times x$。

## Code

```cpp
#include<bits/stdc++.h>
#pragma G++ optimize(2)
using namespace std;

int n,m;
int h;
int s[100005];

bool check(int x){
	for(int i=x;i<n;i++)
		if(s[i]-s[i-x]<2*m)//根据性质判断 
			return 0;
	return 1;
}

signed main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin>>n>>m;
	for(int i=1;i<n;i++){
		cin>>h;
		s[i]=s[i-1]+h;//前缀和 
	}
	int l=1,r=1e9,mid;
	while(l<=r){//二分答案 
		mid=l+r>>1;
		if(check(mid))
			r=mid-1;
		else
			l=mid+1;
	}
	cout<<l;//由于答案区间在左边，所以输出r 
	return 0;
}
```


---

## 作者：Autumn_Rain (赞：2)

### 题目简化

给定一个数列 $h$，找到一个最小的 $y$ 使数列中所有长 $y$ 的区间的和不小于 $2x$。

### 代码

```cpp
#include<iostream>
using namespace std;
const int N=1e5+10;
int n,x,h[N],s,j,ans; 
int main(){
	cin>>n>>x;
	for(int i=1;i<n;i++)cin>>h[i];
	for(int i=1;i<n;i++){
		while(s<2*x&&j<n)s+=h[++j];
		ans=max(ans,j-i+1);s-=h[i];
	}
	cout<<ans;
	return 0;
}
```

备注：有人会问为什么代码里取最大值，因为 $i$ 指数组中某位置，$j$ 指这个位置加 $y$ 的位置。要让长 $y$ 的区间都能跳，取最大才够。

### 分析

往返和直接从左到右走 $2x$ 次没区别。

因为跳过去的方案可以是跳回来的，跳回来的可以跳过去的。直接看成 $2x$ 只青蛙在跳即可。

又由题意设跳跃能力为 $y$，则每个长度为 $y$ 的区间内和都必须大于等于 $2x$。原因如下。

- 有近的石头就不跳远的石头，因为可以步幅更小。反正你不跳别的青蛙也要跳，青蛙们是等价的。

- 长度为 $y$ 的区间经过 $2x$ 次（很多题解并没有解释）。

把青蛙的跳跃近似看作 $y$。实际上它可以跳小碎步，但我们可以把小碎步合并成一个略小于 $y$ 的跳跃，大致的画一下图如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/x59vob1l.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/uz21c0oe.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/n9ea1pea.png)

更严谨的话可以自己改一下画法，~~但我做完图不想改了~~。

多个跳跃等价，所以一个跳跃如此，其它都如此。故得证。

- 因为每个长 $y$ 的区间覆盖 $2x$ 次，所以它们不能跳着跳着石头全沉底了，所以这个区间的和要大于等于 $2x$。

其余请见代码。

---

## 作者：Central_GYM (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8775)
### 解题思路
首先本题解的思路建立在以下基础上：

当用 $y$ 作为跳跃能力的方案可行时区间 $[i+1,i+y]$ 的石头高度总和一定大于 $2x$。
##### 对此的证明
首先用 $y$ 作为跳跃能力的方案可行时最多能跳的距离为 $y$ 然而想要跳过 $[i+1,i+y]$ 的区间用的最小距离为 $(i+y+1)-i=y+1$ 所以 $[i+1,i+y]$ 的区间必然是无法跳过的。小青蛙要来回走 $2x$ 趟，此过程等价于 $2x$ 只青蛙从起点到终点，因为区间不可跳过，所以每只青蛙在 $[i+1,i+y]$ 的区间之中至少会使一个高度减一。
##### 可行解的单调性
若用 $y$ 作为跳跃能力的方案可行时则区间 $[i+1,i+y]$ 的石头高度总和一定大于 $2x$，由于高度 $h_i\ge 0$，所以区间 $\sum_{i+1}^{i+y+1} h_i \ge 2x$ 所以当 $y$ 可行时，其后面的所有解必然可行。

对此可行解具有单调性，故使用二分来实现找最优解，前缀和在判断时使用，时间复杂度 $O(n \log n)$。
### Code
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  long long n,x,a[1000005],sum[1000005],ans,minn;
  bool check(int y){
      for(int i=1;i<=n-y;i++){
          if(sum[i+y]-sum[i]<2*x){
              return 0;
          }
      }
      return 1;
  }
  int main(){
      cin>>n>>x;
      if(n==1){
          cout<<1;
          return 0;
      }
      for(int i=1;i<n;i++){
          cin>>a[i];
          sum[i]=sum[i-1]+a[i];
      }
      sum[n]=sum[n-1]+0;
      for(int i=1;;i++){
          if(sum[i]-sum[0]>=2*x){
              minn=i;
              break;
          }
      }
      int l=1,r=n;
      while(l<r){
          int mid=(l+r)/2;
          if(check(mid)){
              r=mid;
          }else{
              l=mid+1;
          }
      }
      cout<<r;
      return 0;
  }
```

---

## 作者：Melo_DDD (赞：1)

有个坑，应该只有像我这样的傻子才会跳进去。

# 题目大意

略。注意往返 $2x$ 次就行了。

# 题目实现

最大值最小或者最小值最大这种几乎是二分，考虑二分什么。

二分一个跳跃距离 $y$，由于往返了 $2x$ 次，那么每个长度为 $y$ 的区间一定至少经过了 $2x$ 次，所以高度减少量一定 $\ge2x$。那么它可行的充要条件是这个区间的高度和 $\ge2x$（即有足够的高度让它减）。

用前缀和维护，即：
$$
sum_i = \sum_{j =1}^{i}h_j
$$
那么：
$$
\sum_{j = l}^{r}h_j=\sum_{j =1}^{r}h_j-\sum_{j = 1}^{l}h_j=sum_r-sum_l
$$
非常方便地能求出一段区间的高度和。

然后是那个小坑点：

别忘了还有 $sum_0$ 存在，虽然我们不更新它的值（它的值是 $0$），但它是有实际意义的，它表示我们在岸边。

## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 + 7 ;
typedef long long ll ;
ll n ,x ,h[N] ;
ll sum[N] ;
#define rep(i ,m ,n ,x) for (ll i = (m) ;i <= (n) ;i += (x))
namespace shin {
	template <typename T> inline void read (T &x) {
		x = 0 ;
		char ch = getchar () ;
		while (ch < '0' or ch > '9') {
			ch = getchar () ;
		}
		while (ch >= '0' and ch <= '9') {
			x = (x << 1) + (x << 3) + (ch ^ 48) ;
			ch = getchar () ;
		}
	}
	inline bool check (int y) {
		rep (i ,0 ,n - 1 - y ,1) {
			if (sum[i + y] - sum[i] < (ll) 2 * x) return false ;
		}
		return true ;
	}
}
int main () {
	shin :: read (n) ;
	shin :: read (x) ;
	rep (i ,1 ,n - 1 ,1) {
		shin :: read (h[i]) ;
		sum[i] = sum[i - 1] + h[i] ;
	} 
	ll l = 1 ,r = 2 * sum[n - 1] ,ans = 0 ; //我们要保证 mid 的最大值是所有高度和，所以 r 的上界确定为 2 * sum[n - 1]
	while (l <= r) {
		ll mid = l + r >> 1 ;
		if (shin :: check (mid)) {
			ans = mid ;
			r = mid - 1 ;
			goto _shin ;
		}
		l = mid + 1 ;
		_shin : ;
	}
	cout << ans << '\n' ;
	return 0 ;
}
//kafka & かみや
```

---

## 作者：HDZmessi (赞：1)

这道题使用双指针的题解都在最前端，因为双指针代码短，而二分答案在后面因为太千篇一律了，蒟蒻不会双指针，讲讲二分答案。

开始的我想到了一种特别慢的方法，平方对数复杂度的办法，后来看到题解大佬们发现的一个神秘的规律。

clue：我们在写判断函数的时候，设判断的变量数字为 $c$，那么，每跳一次，一段长度为 $c$ 的石头高度和都会至少下降一。所以应该保证整条路的所有长为 $c$ 的所有石头高度和大于或等于 $2\times x$。

蒟蒻一直想不通严谨的证明方法，想了一种伪证。你的灵魂画手上线。

![伪证](https://cdn.luogu.com.cn/upload/image_hosting/dmfo5oui.png)

AC code:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,x,ans,a[1000005],b[1000005];
bool check(int c){
	for(int i=c;i<n;i++){
		if((b[i]-b[i-c])<2*x) return 0; //这里用前缀和减去前缀和来保证每次都能找到一个长度为c的石头高度和 
	}
	return 1;
}
int main(){
	scanf("%d%d",&n,&x);
	for(int i=0;i<n-1;i++){
		cin>>a[i];
	}
	for(int i=1;i<n;i++){
		b[i]=b[i-1]+a[i-1]; //计算前缀和 
	}
	int l=0,r=n,mid;
	while(l<=r){ //二分答案 
		mid=(l+r)/2;
		if(check(mid)) r=mid-1,ans=mid;
		else l=mid+1;
	}
	cout<<ans;
	return 0; //华丽结束 
} 
```


---

## 作者：卷王 (赞：1)

## 题目大意

[传送门](https://www.luogu.com.cn/problem/P8775)

挺好理解的，注意是 $2x$ 天就行了。

## 大体思路

看到这题，你或许会想到二分。这是可以的，但是有一种代码更简短的方式——双指针。

我们可以发现一个规律：如果设青蛙的跳跃能力为 $y$，那么必须满足每个区间 $[a,a+y](a+y < n)$，都必须满足区间和大于等于 $2x$，因为青蛙每次跳到这都得耗费 $1$ 个高度，如果小于 $2x$，那么后面就没有办法再跳到上面了。

于是我们拿 $l$ 记录上方讲解里面的 $a$，$r$ 记录 $a+y$，取 $r-l+1$ 的最大值即可。

代码如下（十分简短）：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read() {
	ll x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}
ll n, x, ans = 0;
ll h[100007];
int main() {
	n = read(), x = read(); x *= 2;
	for(int i = 1; i < n; i++) h[i] = read();
	ll r = 0, sum = 0;
	for(ll l = 1; l < n; l++) {
		while(r < n && sum < x) sum += h[++r]; //累加计算使区间和不小于 x 时的和，以及下标 
		ans = max(ans, r - l + 1);
		sum -= h[l]; //左指针加 1，将左指针的位置 -= h[l] 
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Light_Star_RPmax_AFO (赞：1)

${\huge \mathcal{Revise } } $

感谢[Franz_Liszt](https://www.luogu.com.cn/user/450246)大佬的提醒，已修改从 $i + y$ 变为 $i + y -1$。

# 思路

看样例得出 $\sum^{i+y-1}_i\ge2x$。

证明：

每天我们都必须经过 $[i,i + y - 1]$ 这个区间，也就是说在这个区间中，每天都必须给青蛙一个落脚点，那么这个区间的可落脚次数便为 $\sum^{i+y-1}_i$，需要经过 $2x$ 次，也就说明 $\sum^{i+y-1}_i\ge2x$。

那么就有一下两种解法：

1. 二分查找 $y$ 的最小值。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x; 
int h[100010],sum[100010];
bool check(int mid){
	for(int i = mid;i < n;i++){
		if(sum[i] - sum[i - mid] < 2 * x)return 0;
	} 
	return 1;
}
int main(){
	cin>>n>>x;
	for(int i = 1;i < n;i++)
		cin>>h[i],sum[i] = sum[i - 1] + h[i];
	int l = 1,r = n;
	while(l < r){
		int mid = (l + r) >> 1;
		if(check(mid))r = mid;
		else l = mid + 1;
	}
	cout<<l;
}
```
2. 使用双指针查找过河中满足条件的最小跳跃中的最大值。

```cpp

#include <bits/stdc++.h>
using namespace std;

int n,x; 
int h[100010],ans;

int main(){
	cin>>n>>x;
	for(int i = 1;i < n;i++)
		cin>>h[i];
	int r = 0,cnt = 0;
	for(int l = 1;l < n;l++){
		while(r < n && cnt < 2 * x){
			cnt += h[++r];
		}
		ans = max(ans,r - l + 1);
		cnt -= h[l];
	}
	cout<<ans;
}
```

---

## 作者：Mr_RoastFish (赞：0)

（本题解以记叙思路为主，节奏可能较慢。）

我是从时间复杂度去推解法的。$n \le 10^5$ 提示我们这道题的满解的时间复杂度应该是 $O(n \log n)$，而 $x \le 10^9$ 也在提示我们这道题不会存在有关 $x$ 的循环。但是 $x$ 又是一个左右我们解题的重要考虑因素。由此不难想到一个关键的原则：**一只青蛙跳 $2x$ 次和 $2x$ 只青蛙跳一次是一样的**。

然后对 $n$ 分析，因为跳一次需要的时间复杂度达到 $O(n)$，所以留给判断 $y$ 的只剩下 $O(\log n)$，考虑二分答案再判断。那现在问题就交给了 $check$ 函数。前有分析指出，考虑 $2x$ 只青蛙一起跳一趟。也就是说，一些区间要共下降 $2x$ 次。而所谓“一些区间”就是所有长度为 $y$ 的区间。

想出来其实不难，因为想完整飞跃一个长度为 $y$ 的区间，跳跃能力要达到 $y+1$，这与题设不符。所以**这 $2x$ 只青蛙一定会在所有长度为 $y$ 的区间各踩 $2x$ 次**。到这里解法就出来了，用前缀和记录，判断区间和是否比 $2x$ 小，如果小就直接 $false$。

至此题目解毕，下面奉上代码。
```cpp
bool judge(int y){//O(n)
	for(int i=y;i<n;i++)
      		if(sum[i]-sum[i-y]<2*x）	
         		return false;
	return true;
}

while(l<r){//O(logn)
	if(!judge(mid))	l=mid+1;
	else	r=mid;
}
cout<<r;
```

---

## 作者：Charles_with_wkc (赞：0)

### 分析：
这题不难看出是一个二分的题目。题中强调是 $ 2x $ 次过河，可以理解为一去一返，走 $ x $ 次。最后答案越小越好所以应该输出 $ r $。题目中说 $ x \le 10^9 $，要开 long long。注意是 $  n - 1 $ 个石头，$ n $ 包括起点。

### 核心代码：
```cpp
bool cheak(long long mid){
	for(int i=mid;i<=n;i++){
		if(sum[i]-sum[i-mid]<x){
			return 0;
		}
	}
	return 1;
}
```
[完整代码](https://www.luogu.com.cn/paste/qtpfqbdm)

---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P8775)。

## 解题思路

二分，前缀和。

从起点往终点跳和从终点往起点跳是一样的，所以跳 $2 \times x$ 次，可以看成 $2\times x$ 只青蛙，从起点往终点跳。

把起点和终点看成怎么跳高度都不会为 $0$ 的石头，在 $[1,n]$ 的范围内二分。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 100010
using namespace std;
int n,x,h[maxn];
int l=1,r=maxn,mid,sum[maxn];
bool check(){
    for(int i=mid;i+1<=n;++i)
        if(sum[i]-sum[i-mid]<2*x)
            return false;
    return true;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>x;
    for(int i=1;i<n;++i)
        cin>>h[i];
    h[0]=h[n]=maxn;
    for(int i=1;i<=n;++i)
        sum[i]=sum[i-1]+h[i];
    while(l<r){
        mid=l+((r-l)>>1);
        if(check())
            r=mid;
        else
            l=mid+1;
    }
    cout<<min(l,n);
    return 0;
}
```

---

## 作者：zhanghao233 (赞：0)

# 题目大意

[题面](https://www.luogu.com.cn/problem/P8775)

# 思路

可以用二分，那么 ```check``` 函数的时间复杂度就是 $O(n)$。

其实我这个青蛙从左边能跳过去，那么青蛙从右边也能跳过去，但是这两种是分开跳的。

那么问题转化为判断 $2x$ 个青蛙从左边跳过去合不合法。

由于开始的青蛙在 $[1,y]$，再跳一次青蛙就在 $[2,y+1]$。 也就是每一个长度为 $y$ 的区间至少有一个青蛙跳，那么这 $2x$ 个青蛙分开跳，每个区间都至少有 $2x$ 个能站的地方才合法。用前缀和时间复杂度为 $O(n)$。

```cpp
bool check(int x){
	for(re int i=1;i+x-1<n;i++)
		if(sum[i+x-1]-sum[i-1]<2*m)
			return 0;
	return 1;
}
```

---

## 作者：Smg18 (赞：0)

本题题意就是告诉你有个能力值，让你跳跃距离不超过能力值，每次跳跃会让平台变低一定值，当平台值小于等于零时平台作废，而且要跳往返两次。

问你能力值最小为几？

做法：

本题让我们推敲值，我们可以从特性下手。

- 每个长度为 $y$ 的区间内必然有一个石头会下降，而且我们要跳两次。

- 每个区间高度和必须要大于等于 $2 \cdot x$。

所以我们可以通过这个小特性来写个判读函数，利用前缀和的知识计算高度和。

注意：本题为了拿满，不能循环硬套，要使用二分知识。

代码：

```cpp
#include<bits/stdc++.h>
//#include<windows.h>
//nth_element
//#define int long long
#define ll long long
#define Test ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define C continue
using namespace std;
const int N=1e5+10,NN=1e3+10;//警钟敲烂
ll n,m,k,x,y,cnt,len,T,ans;
ll minn=INT_MAX,maxn=0;
ll arr[N],kzs[N];
bool check(ll z){//特性
    for(int i = z;i<n;i++){
        if(kzs[i]-kzs[i-z]<2*m)return 0;
    }
    return 1;
}
signed main(){
    Test;
    cin>>n>>m;
    for(int i = 1;i<n;i++){
        cin>>arr[i];
        kzs[i]=kzs[i-1]+arr[i];//计算前缀和
    }
    ll l=1,r=n;
    while(l<r){// 二分查找时间更优
        ll mid = (l+r)/2;
        if(check(mid))r=mid;
        else l=mid+1;
    }//闭区间
    cout<<r;
    return 0;
}
```


---


# 折线

## 题目描述

平面直角坐标系的第一象限内有一块左下角为 $(0,0)$ 右上角为 $(10^{100},10^{100})$ 的矩形区域，区域内有**正偶数**个整点，试求出这样一条从 $(0,0)$ 出发，到 $(10^{100},10^{100})$ 的在区域内部的折线：

- 折线的每一部分都平行于 $x$ 轴或 $y$ 轴。
- 折线不能经过给定的整点。
- 折线将整块区域分成包含给定整点个数相等的两块。
- 折线拥有尽可能少的折点。

可以证明一定存在一条满足限制的折线，你只需要输出满足限制的折线的折点数即可。

注意折点的坐标可以不是整数。

## 说明/提示

#### 【样例解释】

对于第一组数据，一条合法的折线为：$(0,0) \to (2.5,0) \to (2.5,10^{100}) \to (10^{100},10^{100})$，它有 $(2.5,0)$ 和 $(2.5,10^{100})$ 两个折点。

#### 【数据范围】

|  测试点编号 | $n \leq$ |      特殊限制      |
|:-----------:|:--------:|:------------------:|
|  $1 \sim 2$ |    $4$   |         无         |
|  $3 \sim 4$ |   $10$   |         无         |
|  $5 \sim 6$ |   $50$  |         无         |
|  $7 \sim 8$ |  $10^5$  | 保证答案不大于 $3$ |
| $9 \sim 10$ | $10^5$   | 无                 |

对于所有数据，$1 \leq T \leq 10^4, 1 \leq \sum n \leq 5 \times 10^5, 1 \leq x_i,y_i \leq n$，保证 $n$ 为正偶数，每组数据中不存在两个坐标相同的整点。

## 样例 #1

### 输入

```
3
4
1 1
1 2
4 1
4 2
6
1 2
1 3
2 1
2 2
2 3
3 2
12
1 3
2 2
2 3
2 4
3 1
3 2
3 4
3 5
4 2
4 3
4 4
5 3
```

### 输出

```
2
3
4```

# 题解

## 作者：bmatrix (赞：7)

[题面](https://www.luogu.com.cn/problem/P8858)

### 初步分析

由于题目有大样例，观察样例发现，答案只能是 $2,3,4$ 之一。如果你不相信肉眼观察法也没有关系，容易证明，任何答案不为 $2$ 或 $3$ 的情况都可以通过以下方法构造出答案为 $4$ 的方案：

1. 寻找两条竖直线 $l_1,l_2$，记 $l_1$ 左侧的点数为 $a$，右侧点数为 $b$，$l_2$ 左侧点数为 $c$，右侧点数为 $d$，使得 $a<b,c>d$ 且 $b-a,c-d$ 的值分别最小。
2. 显然两条直线之间必然有且只有一列点，且一定能找到一条水平线（记这列点中在水平线上面的点数为 $e$，下面的点数为 $f$）使得 $a+e=d+f$。

### 求解

显然答案为 $2$ 的情况，就是**存在一条平行于坐标轴的直线能恰好将所有点平均分为两份**。（两个折点分别从在 $(0,0)$ 折出去时和折到 $(10^{100},10^{100})$ 时出现）

如图所示：

![答案为 2 的情况](https://cdn.luogu.com.cn/upload/image_hosting/0zhntbr4.png)

由于这条直线可能横也可能竖，所以我们只需要把所有点分别按横 / 纵坐标排序，然后看中间两个点的横 / 纵坐标是否相等，不相等就说明答案为 $2$，否则不是。

对于答案为 $3$ 的情况，我们发现它就是在给定的点之间的某个地方多转了一次，分为两种情况：

1. 从原点出发后往右走，然后往上走，再往右走
2. 从原点出发后往上走，然后往右走，再往上走

容易发现第一种走法切割出了**右下角**的一块矩形区域，而第二种走法切割出了**左上角**的一块矩形区域，只要这个矩形区域所包含的点数等于 $\dfrac n2$，就说明答案为 $3$。

样例 2，往右走的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/t90emg5l.png)

接下来考虑如何判断是否存在这样的矩形。

由于两种情况同理，考虑其中一种即可，如果要求右下角的那种，先将点按横坐标排序，从右往左遍历在哪两列点之间向上走，用树状数组记录纵坐标，二分往右转的位置判断能否恰为 $\dfrac n2$ 个点即可。

对于答案为 $4$ 的情况，排除即可：如果答案既不是 $2$ 也不是 $3$，那就是 $4$ 了。

时间复杂度 $O(n\log^2n)$，常数挺小的。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define rep(i, s, e) for(int i = s; i <= e; ++i)
#define per(i, s, e) for(int i = s; i >= e; --i)
#define F first
#define S second
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef __int128_t i128;
typedef __uint128_t u128;
typedef pair<int, int> pii;
constexpr int N = 5e5 + 5;
int tr[N], n, t;
#define lb(x) ((x) & (-(x)))
void add(int i, int v) {
    for(; i <= n; i += lb(i)) tr[i] += v;
}
int sum(int i) {
    int res = 0;
    for(; i; i -= lb(i)) res += tr[i];
    return res;
}
void clear() {
    rep(i, 1, n) tr[i] = 0;
}
void solve() {
    cin >> n;
    vector<pii> a;
    rep(i, 1, n) {
        int x, y; cin >> x >> y;
        a.emplace_back(x, y);
    }
    sort(a.begin(), a.end(), [](pii a, pii b){return a.S == b.S ? a.F < b.F : a.S < b.S;});
    if(a[n / 2].S != a[n / 2 - 1].S) {
        cout << 2 << endl; return;
    }
    sort(a.begin(), a.end());
    if(a[n / 2].F != a[n / 2 - 1].F) {
        cout << 2 << endl; return;
    }
    int i = 0;
    while(i < n) { // 寻找左上角的矩形
        int t = a[i].F;
        while(i < n && a[i].F == t){
            add(a[i].S, 1);
            ++i;
        }
        if(i < n / 2) continue;
        int l = 1, r = n;
        while(l < r) {
            int mid = (l + r) / 2;
            int s = i - sum(mid);
            if(s == n / 2) {
                cout << 3 << endl; return;
            }
            if(s < n / 2) r = mid;
            else l = mid + 1;
        }
    }
    clear(); // 别忘了清空
    i = n - 1;
    while(i >= 0) { // 寻找右下角的矩形
        int t = a[i].F;
        while(i >= 0 && a[i].F == t){
            add(a[i].S, 1);
            --i;
        }
        if(i > n / 2) continue;
        int l = 1, r = n;
        while(l < r) {
            int mid = (l + r) / 2;
            int s = sum(mid);
            if(s == n / 2) {
                cout << 3 << endl; return;
            }
            if(s < n / 2) l = mid + 1;
            else r = mid;
        }
    }
    cout << 4 << endl;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> t;
    while(t--) solve(), clear();
    return 0;
}
```

---

## 作者：spdarkle (赞：6)

# P8858 题解
也许是复杂度最优做法 $O(n)$，此题是一道不错的双指针练习题。

*引理1*： 

折点数量在 $[2,4]$ 之间。

证明：(从 $x$ 轴考虑，$y$ 轴同理。)

考虑找到一个 $a$ 使得 $x$ 坐标小于 $a$ 的和 $x$ 坐标大于 $a$ 的点的数量不超过 $\frac{n}{2}$，(先预处理每个 $x$ 坐标的点的数量,再做一遍前缀和即可求出。)

那么考虑将直线 $x=a$ 划分为两个部分，**自底向上最多折 $3$ 次即可达到划分目的**，最后一次是当折线的坐标到了 $(a,10^{100})$ 的时候再折到终点，故上界是 $4$。

而需要划分点，至少需要折一次，然后还得再折一次到终点，故下界是 $2$。

*引理2*：

折两次的充要条件为存在一个 $a$，使得 $x$ 坐标小于 $a$ 或 $y$ 坐标小于 $a$ 的点的数量为 $\frac{n}{2}$，证明显然。


*引理3*：

折 $3$ 次的充要条件为存在一个矩形 $(1,i,i,n)$ 或 $(i,1,n,j)$ 使得矩形值为 $\frac{n}{2}$。

因为折两次只有两种图形(如下)，证明显然。

![](https://img-blog.csdnimg.cn/af5ab6109f8b40e48deeebca95d114ff.bmp#pic_center)



所以问题就变成了判断是否存在矩形 $(1,i,j,n)$ 或 $(i,1,n,j)$ 使得矩形值为 $\frac{n}{2}$，采用悬线法解决。

可以这样考虑，因为折三次可以分为从 $x$ 折第一次还是从 $y$ 折，下面讨论从 $x$ 折，处理矩形 $(i,1,n,j)$ 的方法。

![](https://img-blog.csdnimg.cn/7fa8f8c7d09a48fc9be80d05cad2b8f0.bmp#pic_center)

代码应该比较好懂，没看懂可以私信我。
```cpp
//fc D:\编程\C++\ex_line2.out D:\编程\C++\ex_line2.ans
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
#define N 5000050
struct node {
	int x, y;
}a[N];
inline int read(void) {
	int x = 0, f = 1; char c = getchar();
	for (; !isdigit(c); c = getchar())
		if (c == '-') f = -1;
	for (; isdigit(c); c = getchar())
		x = x * 10 + c - '0';
	return x * f;
}
int f1[N], f2[N], g1[N], g2[N], n, m, q;
vector<int>s1[N], s2[N];
inline void init() {
	for (int i = 1; i <= n; i++)f1[i] = f2[i] = g1[i] = g2[i] = a[i].x = a[i].y = 0;
	for (int i = 1; i <= n; i++) {
		s1[i].clear();
		s2[i].clear();
	}
	n = read();
	for (int i = 1; i <= n; i++) {
		int x, y;
		x = read(); y = read();
		g1[x]++, g2[y]++;
		a[i].x = x, a[i].y = y;
		s1[x].push_back(i);
		s2[y].push_back(i);
	}
}
inline bool check2() {
	for (int i = 1, j = 0, k = 0; i <= n; i++) {
		j += g1[i];
		k += g2[i];
		if (j == n / 2 || k == n / 2)return true;
	}
	return false;
}
inline bool check3_1() {
	//第一部分，判断矩形(i,1,n,j)
	int l = 1, r = 1, m = 0;
	while (l <= n) {
		while (m < n / 2 && r <= n) {
			m += g2[r] - f2[r];
			//		printf("A %d %d %d\n", l, r, m);
			r++;
		}
		if (m == n / 2)return true;
		int len = s1[l].size();
		for (int i = 0; i < len; i++) {
			f2[a[s1[l][i]].y]++;
			if (a[s1[l][i]].y < r)m--;
		}
		l++;
	}
	if (m == n / 2)return true;
	return false;
}
inline bool check3_2() {
	int l = 1, r = 1, m = 0;
	while (l <= n) {
		while (m < n / 2 && r <= n) {
			m += g1[r] - f1[r];
			//		printf("B %d %d %d\n", l, r, m);
			r++;
		}
		if (m == n / 2)return true;
		int len = s2[l].size();
		for (int i = 0; i < len; i++) {
			f1[a[s2[l][i]].x]++;
			if (a[s2[l][i]].x < r)m--;
		}
		l++;
	}
	if (m == n / 2)return true;
	return false;
}
int main() {
	//	freopen("ex_line2.in","r",stdin);
	//	freopen("ex_line2.ans","w",stdout);
	int t = read();
	while (t--) {
		init();
		if (check2()) {
			puts("2");
			continue;
		}
		if (check3_1() || check3_2()) {
			puts("3");
			continue;
		}
		puts("4");
	}
}
```

感谢管理大大不辞辛劳的审核！

---

## 作者：yohoofu2011 (赞：3)

## 思路分析
通过观察可以发现，答案只会有三种情况，分别是：

1. 当答案为 $2$ 时，那么一定存在一条平行于坐标轴的线能将所有的点分成两部分；![](https://cdn.luogu.com.cn/upload/image_hosting/4mqattes.png)
2. 当答案为 $3$ 时，我们可以先找一条线，当它无法把所有点分成相等的两部分时，那就再找一条垂直于它的线，把分点多了的那一部份区域割一部分点给少的；![](https://cdn.luogu.com.cn/upload/image_hosting/cmw7lfnd.png)
3. 当答案既不是 $2$ 又不是 $3$ 时，那就是 $4$ 了 (证明请看第一篇题解) 。

在枚举 $3$ 的情况时，不难发现，不需要每一次都重置另一条线的坐标，只需往后推即可，这就需要用到双指针来优化时间，可以把 $O(n^2)$ 优化成 $O(n)$，还是很好优化的 。
## AC 代码
看大家基本都不怎么写注释，所以在看代码之前请进行充分的思考。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct z {
	int x, y;
};
int t, n, tj[500007], num, ls;
z zb[500007];
bool cmp(z x, z y) {
	return x.x > y.x;
}
bool pd1() {//判断是否为 2 的情况
	num = 0;
	for (int i = 1; i <= n; i++) {//找是否有一条与 y 轴平行的线可以分
		num += tj[i];
		if (num == n / 2) return true;
		if (num > n / 2) break;//大了就直接跳过
	}
	for (int i = 1; i <= n; i++) tj[i] = 0;//重置
	for (int i = 1; i <= n; i++) tj[zb[i].y]++;//统计每个 y 坐标上的点数
	num = 0;
	for (int i = 1; i <= n; i++) {//找是否有一条与 x 轴平行的线可以分
		num += tj[i];
		if (num == n / 2) return true;
		if (num > n / 2) break;//大了就直接跳过
	}
	return false;
}
bool pd2() {//判断是否为 3 的情况
	sort(zb + 1, zb + n + 1, cmp);//对 x 或 y 坐标进行排序
	for (int i = 1; i <= n; i++) tj[i] = 0;//重置
	for (int i = n, j = n, k = 0, g = 1; i; i--) {//i 为第一条线，j 为另一条线，k 为当前部分里的点数，g 为 zb 的下标
		while (g <= n && zb[g].x == i) {//把所有能用这条线分的点统计起来
			if (zb[g].y > j) {//如果比另一条线的坐标大，就会被分到另一部分，k 就不加
				g++;
				continue;
			}
			k++, tj[zb[g].y]++, g++;//统计比另一条线的坐标小的点数，和当前部分里的点数
		}
		while (j > 0 && k > n / 2) k -= tj[j--];//如果当前部分里的点数比 n/2 大，那就要把另一条线向坐标轴平移，把当前部分里的点补给另一部分
		if (k == n / 2) return true;//如果存在这两条直线，答案就为 3
	}
	return false;
}
int main() {
	cin >> t;
	while (t--) {
		cin >> n;
		for (int i = 1; i <= n; i++) tj[i] = 0;//重置
		for (int i = 1; i <= n; i++) {
			cin >> zb[i].x >> zb[i].y;
			tj[zb[i].x]++;//统计每个 x 坐标上的点数
		}
		if(pd1()) cout<<2<<"\n";
		else if (pd2() ) cout << 3 << "\n";
		else {
			for (int i = 1; i <= n; i++) ls = zb[i].x, zb[i].x = zb[i].y, zb[i].y = ls;//反过来，因为有两种可能的情况，这里可以思考一下
			cout << (pd2() ? 3 : 4) << "\n";
		}
	}
	return 0;
}
```

---

## 作者：Demeanor_Roy (赞：3)

- [原题链接](https://www.luogu.com.cn/problem/P8858)

- 赛时想法，可能较繁。

------------

首先你需要发现结论：答案 $ans$ 的取值为：$2 \leq ans \leq 4$。

下给出证明：

- 若答案为 $1$，折线就必须沿着边缘走，不可能将所有点均分。

- 考虑对任意情况构造折点为 $4$ 的方案：将所有点按 $x$ 为第一关键字，$y$ 为第二关键字从小到大排序，找到第 $\frac{n}{2}$ 个点所在列，从 $(0,0)$ 出发，向右走到这一列与前一列之间，向上走，直到这一列上面的点加上之前列的点恰好 $\frac{n}{2}$ 个，继续向右恰好穿过这一列，然后向上走到边界再向右至终点。不难发现这样构造一定能行。

接下来考虑每种答案各是什么情况：

- 不难发现当答案为 $2$ 时，一定是竖着一条线将点集均分，或者是横着一条线将点集均分，那朴素判断是否存在一行（一列），使得这一行（列）以前的所有行（列）中，恰好有 $\frac{n}{2}$ 个点即可。

- 同样地，考虑答案为 $3$ 时，一定是一条折线将左上角或右下角割去 $\frac{n}{2}$ 个点，那即判断是否存在一对 $X,Y$ ，使得满足 $ X \leq x $ 且 $ y \leq Y$ 的 $(x,y)$ 恰好 $\frac{n}{2}$ 个，或者满足 $ x \leq X $ 且 $ Y \leq y$ 的 $(x,y)$ 恰好 $\frac{n}{2}$ 个。求法也比较简单，以第一种为例，从大到小枚举 $X$，对于每一个 $X$，求出最小的 $Y$ 使得满足条件的点大于 $\frac{n}{2}$，判断是否取等就行了，朴素做 $n^2$，发现当 $X$ 变化时 $Y$ 具有单调性，双指针加树状数组判断即可。

- 剩余的情况答案则为 $4$。

时间复杂度 $O(n \log n)$。

[代码](https://www.luogu.com.cn/paste/x5kje5np)

完结撒花~



---

## 作者：lht1217 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P8858)

------------
本题是一种二维数点题目。

初步分析：
- 根据贪心，尽量使折线拐弯的方向为**向上或向右**，才能使折点更小。再手玩一下，得出答案属于 $[2,4]$ 。

答案为 $2$ 容易判断，求出行和列的前缀和，判断一下即可。

剩下的，答案不是 $3$ 就是 $4$ 。所以我们只要判断这幅图能否用 $3$ 个折点，就能得出最终答案。

至此，应该很容易分析。

下面介绍如何判断答案为 $3$ 是否正确。

我们从 $(0,0)$ 出发，初始方向有 $2$ 个——沿 $x$ 轴和沿 $y$ 轴。

两个方向本质是一摸一样的。这里只介绍沿 $x$ 轴方向的。

- 首先我们很容易想到，因为是沿 $x$ 轴方向，所以**每一步的拐弯方向已经定死——上，右，上。**

![](https://cdn.luogu.com.cn/upload/image_hosting/rgmyo1ab.png)

- 根据图片分析，我们发现，整幅图被分成二块，**一块是十分规则的矩形**。
- 所以我们只要找到一种情况使右下角的矩形中点的数量为 $n/2$。

实际操作：

- 将所有的 $y$ 值放入**树状数组**中。
- 根据**扫描线**的思想，从左往右扫描，对每一列进行分析，分析完后，再将那一列上的点的 $y$ 值从树状数组中删去，再对更后面的列分析。
- 如何对每一列进行分析：我们不难发现，我们的 $y$ 值下边界已经固定。所以 $y$ 越大，**这个矩形包含的点数是单调不降的。**这时，我们就请出**二分**，对每一个 $y$ 进行操作。
- 沿 $y$ 轴，同理。

所以最终时间复杂度为：$O(n\log^2 n)$。

贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
#define il inline
#define ll long long
il int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48; ch=getchar();}
    return x*f;
}
il void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n;
vector<int>f[N],g[N];
struct node{
	int x,y;
}a[N];
#define lowbit(x) (x&-x)
int tr[N];
il void update(int x,int val){
	while(x<=n){
		tr[x]+=val;
		x+=lowbit(x);
	}
}
il int query(int x){
	int res=0;
	while(x){
		res+=tr[x];
		x-=lowbit(x);
	}
	return res;
}

il bool judge(int l,int r,int lim){
	int mid;
	while(l<=r){
		mid=(l+r)>>1;
		int t=query(mid);
		if(t==lim) return 1;
		if(t>lim) r=mid-1;
		else l=mid+1;
	}
	return 0;
}
int main(){
//	freopen("line.in","r",stdin);
//	freopen("line.out","w",stdout);
	int T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;i++)
			f[i].clear(),g[i].clear();
		for(int i=1,x,y;i<=n;i++){
			x=read(); y=read();
			a[i]=node{x,y};
			f[x].push_back(y);
			g[y].push_back(x);
		}
		//特判2
		bool flag;
		int lim=n/2,sum;
		sum=0; flag=0;
		for(int i=1;i<=n;i++){
			sum+=f[i].size();
			if(sum==lim) flag=1;
			if(sum>lim) break;
		}
		if(flag){
			puts("2");
			continue;
		}
		
		sum=0; flag=0;
		for(int i=1;i<=n;i++){
			sum+=g[i].size();
			if(sum==lim) flag=1;
			if(sum>lim) break;
		}
		if(flag){
			puts("2");
			continue;
		}
		
		//特判3 
		flag=0;
		memset(tr,0,sizeof(tr));
		for(int i=1;i<=n;i++) update(a[i].y,1);
		for(int i=1;i<=n;i++){
			if(judge(0,n,lim)){
				flag=1;
				break;
			}
			for(int y:f[i]) update(y,-1);
		}
		if(flag){
			puts("3");
			continue;
		}
		
		flag=0;
		memset(tr,0,sizeof(tr));
		for(int i=1;i<=n;i++) update(a[i].x,1);
		for(int i=1;i<=n;i++){
			if(judge(0,n,lim)){
				flag=1;
				break;
			}
			for(int x:g[i]) update(x,-1);
		}
		if(flag){
			puts("3");
			continue;
		}
		//最后的情况 
		puts("4");
	}
	return 0;
}
```
完结，撒花。

---

## 作者：Tsawke (赞：1)

# [LG-P8858 折线](https://www.luogu.com.cn/problem/P8858) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P8858-Solution)

### 题面

从从 $ (0, 0) $ 到 $ (10^{100}, 10^{100}) $ 的矩形里有正偶数 $ n $ 个整点，需构造一条从 $ (0, 0) $ 到 $ (10^{100}, 10^{100}) $ 的折线，要求其每部分都平行于坐标轴，不能经过给定的整点，需要将整块区域分为包含给定整点数量相等的两块，要最小化其整点。输出合法的折线的整点数，保证一定存在如下直线。

### Solution

提供一个 $ O(T n \log n) $ 的线段树上二分做法。

首先我们可以考虑观察一下样例和大样例，不难发现所有答案均在 $ [2, 4] $ 之间，以此可猜想答案一定在此区间中，可以尝试感性证明一下：

首先一个折点的话一定无法将矩形分为两块，所以不合法。

两个折点的话即为通过一条直线将矩形分为两半，这条直线可以水平也可以竖直，所以对于这种情况，我们只需要对 $ x $ 坐标和 $ y $ 坐标分别做一个前缀和，然后分别遍历一遍，如果存在一个点 $ i $ 使 $ sum_i = \dfrac{n}{2} $ 那么显然合法，答案为 $ 2 $。

三个折点的话随便画一下就会发现，最终的情况一定是隔离起来一个左上角或者右下角，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xnew3bp7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/bert7j5t.png)

考虑如何维护，显然可以把这个东西按照类似二位偏序或者说二维数点来写，先按照 $ x $ 排序，然后把每一段相同的 $ x $ 的所有 $ y $ 都插到权值线段树里，然后在线段树上二分查找是否存在一个前缀刚好等于 $ \dfrac{n}{2} $。然后再把整个顺序反过来插反过来查，找是否存在一个后缀恰好等于 $ \dfrac{n}{2} $，如果能找到那么显然可以通过隔离出来一段左上角或右下角的角落构造合法折线，答案即为 $ 3 $。

如果以上的判断都不合法的话那么显然最终答案即为 $ 4 $，这个通过我们最开始 “面向数据编程” 得到的性质直接得到，也可以考虑画一下，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/u1eifbjc.png)

显然这个时候我们是可以隔离出来任意数量的整点了，比较好理解，考虑一下如果想更多地包含新的点，将中间那块凸起略移动一下 $ x $ 和 $ y $ 即可，感性理解一下即可。

至此我们便以 $ O(T n \log n) $ 的复杂度解决了这道题，还算比较直观，作为 T1 难度挺合理。

### 赛时 Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW(arr) void* Edge::operator new(size_t){static Edge* P = arr; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

#define MAXN (510000)

template< typename T = int >
inline T read(void);

int N;
struct Coord{int x, y;}a[MAXN];
int bucx[MAXN], bucy[MAXN];

class SegTree{
private:
    int tr[MAXN << 2];
    #define LS (p << 1)
    #define RS (LS | 1)
    #define MID ((gl + gr) >> 1)
public:
    void Clear(int p = 1, int gl = 1, int gr = N + 1){
        if(gl == gr)return tr[p] = 0, void();
        Clear(LS, gl, MID);
        Clear(RS, MID + 1, gr);
        tr[p] = 0;
    }
    void Pushup(int p){tr[p] = tr[LS] + tr[RS];}
    void Modify(int idx, int v = 1, int p = 1, int gl = 1, int gr = N + 1){
        if(gl == gr)return tr[p] += v, void();
        if(idx <= MID)Modify(idx, v, LS, gl, MID);
        else Modify(idx, v, RS, MID + 1, gr);
        Pushup(p);
    }
    bool QueryR(int val, int cur = 0, int p = 1, int gl = 1, int gr = N + 1){
        // printf("Querying %d ~ %d, cur = %d\n", gl, gr, cur);
        if(cur + tr[p] == val)return true;
        if(gl == gr)return false;
        if(cur + tr[LS] >= val)return QueryR(val, cur, LS, gl, MID);
        else return QueryR(val, cur + tr[LS], RS, MID + 1, gr);
    }
    bool QueryL(int val, int cur = 0, int p = 1, int gl = 1, int gr = N + 1){
        // printf("Querying %d ~ %d, cur = %d\n", gl, gr, cur);
        if(cur + tr[p] == val)return true;
        if(gl == gr)return false;
        if(cur + tr[RS] >= val)return QueryL(val, cur, RS, MID + 1, gr);
        else return QueryL(val, cur + tr[RS], LS, gl, MID);
    }
}st;

int main(){
    // freopen("ex_line2.in", "r", stdin);
    // freopen("out.txt", "w", stdout);
    int T = read();
    while(T--){
        bool flag(false);
        memset(bucx, 0, sizeof(int) * (N + 10)), memset(bucy, 0, sizeof(int) * (N + 10));
        N = read();
        for(int i = 1; i <= N; ++i)
            a[i].x = read() + 1, a[i].y = read() + 1, bucx[a[i].x]++, bucy[a[i].y]++;
        a[N + 1].x = a[N + 1].y = 0;
        for(int i = 1; i <= N; ++i){
            bucx[i] += bucx[i - 1], bucy[i] += bucy[i - 1];
            if(bucx[i] == N >> 1 || bucy[i] == N >> 1){printf("2\n"), flag = true; break;}
        }if(flag)continue;
        sort(a + 1, a + N + 1, [](const Coord &a, const Coord &b)->bool{return a.x == b.x ? a.y < b.y : a.x < b.x;});
        st.Clear();
        for(int i = N; i >= 1; --i){
            st.Modify(a[i].y);
            while(a[i - 1].x == a[i].x)st.Modify(a[--i].y);
            if(st.QueryR(N / 2)){printf("3\n"), flag = true; break;}
        }if(flag)continue;
        st.Clear();
        for(int i = 1; i <= N; ++i){
            st.Modify(a[i].y);
            while(a[i + 1].x == a[i].x)st.Modify(a[++i].y);
            if(st.QueryL(N / 2)){printf("3\n"), flag = true; break;}
        }if(flag)continue;
        printf("4\n");
    }
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2022_11_22 初稿

update-2022_11_22 修改了一处细节错误

update-2022_11_23 图片被洛谷墙了，换成了洛谷图床

---

## 作者：Dregen_Yor (赞：1)

### [更好的阅读体验](https://dregen-yor.eu.org/2022/11/21/p8858/)。

# 思路

根据题意，我们不难发现题目中要求的折线最多只有 $4$ 个这店，最少只有 $2$ 个折点，至于为什么，我们看下面的几张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/7003ffiy.png)

如图，当点的个数关于某条直线对称的时候，即一条直线即可将点平均分成两组，这时候只需要 $2$ 个折点即可。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/pks7om5w.png)

若出现上图所示情况，即无法用一条边将点的个数平分，我们考虑增加一个折点，在图中划分出一个小矩形来，并判断是否存在这样的一个小矩形即可，这样的小矩形一定位于左上角或右下角。


---

若点的数量再次增加，出现下面这种情况：

![](http://tva1.sinaimg.cn/large/007dZVXcly1h8aefd3ixwj30h30da3zj.jpg)

此时无法用一个小矩形将点分成相对的两部分，我们需要构造一个类似于上图的六边形，将所有点分成相对的两部分。

所有的点都可以通过最多 $4$ 个折点的折线分成相等的两部分，因为这时可以通过任意的调整使其满足条件。

---

对于答案为 $2$ 的情况，我们用前缀和分别维护 X 轴和 Y 轴上的点即可，判断是否存在平分的情况。

对于答案为 $3$ 的情况，我们考虑将问题转化成一个**二维数点**问题，我们直接遍历 X 轴和 Y 轴其中一维，用线段树维护另一维，遍历一维使用一颗值域线段树维护点的位置信息，判断当前是否存在一个区间使点的个数为所有点的个数的一半即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define ls x<<1
#define rs x<<1|1
using namespace std;
struct node{
    int x,y;
}a[100010];
int T,n,pre[100010],ans;
bool cmp1(node A,node B){
    return A.x>B.x;
}
bool cmp2(node A,node B){
    return A.y>B.y;
}
int sum[100010<<3];
vector <int> q[100010];
void bulid(int x,int l,int r){
    if(l==r){
        sum[x]=0;
        return;
    }
    int mid=(l+r)>>1;
    bulid(ls,l,mid);
    bulid(rs,mid+1,r);
    sum[x]=sum[ls]+sum[rs];
}
void update(int x,int l,int r,int st){
    if(l==r&&l==st){
        ++sum[x];
        return;
    }
    int mid=(l+r)>>1;
    if(st<=mid){
        update(ls,l,mid,st);
    }
    else update(rs,mid+1,r,st);

    sum[x]=sum[ls]+sum[rs];
}
bool check(int x,int l,int r,int s){
    if(sum[x]<s){
        return 0;
    }
    if(sum[x]==s){
        return 1;
    }
    if(l==r){
        return 0;
    }
    int mid=(l+r)>>1;
    if(sum[ls]>=s){
        return check(ls,l,mid,s);
    }
    else return check(rs,mid+1,r,s-sum[ls]);
}
void solve(){
    bulid(1,1,n);
    for(int i=1;i<=n;i++){
        q[i].clear();
    }
    for(int i=1;i<=n;i++){
        q[a[i].x].push_back(a[i].y);
    }
    for(int i=n;i;--i){
        for(auto j:q[i]){
            update(1,1,n,j);
        }
        if(check(1,1,n,n>>1)){
            ans=3;
            return;
        }
    }
    bulid(1,1,n);
    for(int i=1;i<=n;i++){
        q[i].clear();
    }
    for(int i=1;i<=n;i++){
        q[a[i].y].push_back(a[i].x);
    }
    for(int i=n;i;--i){
        for(auto j:q[i]){
            update(1,1,n,j);
        }
        if(check(1,1,n,n>>1)){
            ans=3;
            return;
        }
    }
    bulid(1,1,n);
}
signed main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d%d",&a[i].x,&a[i].y);
        }
        ans=0;
        for(int i=1;i<=n;i++){
            pre[i]=0;
        }
        for(int i=1;i<=n;i++){
            pre[a[i].x]++;
        }
        for(int i=1;i<=n;i++){
            pre[i]+=pre[i-1];
            if((pre[i]<<1)==n){
                ans=2;
                break;
            }
        }
        for(int i=1;i<=n;i++){
            pre[i]=0;
        }
        for(int i=1;i<=n;i++){
            pre[a[i].y]++;
        }
        for(int i=1;i<=n;i++){
            pre[i]+=pre[i-1];
            if((pre[i]<<1)==n){
                ans=2;
                break;
            }
        }
        if(!ans){
            solve();
        }
        if(!ans){
            ans=4;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```


---

## 作者：OldDriverTree (赞：0)

大家怎么都写这么复杂啊/jk。

# Solution
首先有一个结论：答案一定为 $2$ 或 $3$ 或 $4$。

证明就看第一篇题解写的吧，这里主要讲解后面的做法。

答案为 $2$ 的情况就是把所有点用一条线分隔开，开个桶记录一下每个 $x$ 或 $y$ 的出现次数，再判断一下是否存在前缀和等于 $\dfrac n2$ 即可。

答案为 $3$ 的情况就是一部分点 $x$ 在 $[0,X]$ 内且 $y$ 在 $[Y,10^{100}]$ 内，或者 $x$ 在 $[X,10^{100}]$ 且 $y$ 在 $[0,Y]$，其中 $X$ 和 $Y$ 是自己选择的两个数，这里建议自己画图理解一下。

前者把每个点的 $x$ 和 $y$ 交换一下就能变为后者，所以这里只考虑后者。

从 $n$ 到 $1$ 枚举 $X$，可以发现 $X$ 缩小后 $Y$ 一定不会变大。

考虑用一个桶记录当前遍历过的点每种 $y$ 坐标的出现次数。

当枚举到一个新的 $X$ 时，就把 $x$ 坐标为 $X$ 的都加入桶中，这时如果这里面的点个数大于了 $\dfrac n2$，就一直把点的个数减去桶中 $y$ 坐标为 $Y$ 的个数并缩小 $Y$，直到点的个数小于等于 $\dfrac n2$。

如果答案为 $2$ 和 $3$ 都不行那么答案就为 $4$。

时间复杂度 $O(n\log n)$，瓶颈在于排序的时间复杂度，随便一卡就卡进了最优解。

如果使用桶排序，可以做到 $O(n)$，但是写完发现反而更慢了（。

# Code
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+1;
int T,n,tax[N];

int read() {
	int x=0; char c=0; while (!isdigit(c) ) c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return x;
}
struct node
{
	int x,y;
	bool operator <(node o)const {
		return x>o.x;
	}
}a[N];

bool judge()
{
	sort(a+1,a+n+1);
	memset(tax,0,sizeof(int)*(n+1) );
	for (int i=n,pos=n,cnt=0,now=1;i;i--)
	{
		while (now<=n&&a[now].x==i) {
			if (a[now].y>pos) { now++; continue; }
			cnt++,tax[a[now].y]++,now++;
		}
		while (pos>0&&cnt>n/2) cnt-=tax[pos--];
		if (cnt==n/2) return true;
	}
	return false;
}
char solve()
{
	n=read(),memset(tax,0,sizeof(int)*(n+1) );
	for (int i=1;i<=n;i++) a[i]={read(),read()},tax[a[i].x]++;
	for (int i=1,sum;i<=n;i++) { sum+=tax[i]; if (sum==n/2) return '2'; }
	memset(tax,0,sizeof(int)*(n+1) ); for (int i=1;i<=n;i++) tax[a[i].y]++;
	for (int i=1,sum;i<=n;i++) { sum+=tax[i]; if (sum==n/2) return '2'; }
	if (judge() ) return '3'; for (int i=1;i<=n;i++) swap(a[i].x,a[i].y);
    	return judge()?'3':'4';
}
int main()
{
	T=read();
	while (T--) putchar(solve() ),putchar('\n');
	return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

# P8858 折线 题解

## 题意回顾

在一个平面直角坐标系的第一象限内有 $ n $ 个横纵坐标都不超过 $ n $ 的位置不同的整点，$ n $ 为偶数。

你需要构造一条从 $ (0,0) $ 到 $ (10^{100},10^{100}) $ 的折线，满足折线的每一部分与坐标轴平行、不经过给定的整点、将区域分割成给定整点个数相等的两块，在此基础上折点数最少，求出折点数。

多测，$ T $ 组数据。

$ T \le 10^4 $，$ \sum n \le 5 \times 10^5 $。

## 分析

树状数组做法。

可以容易发现折线不可能只有 $ 0 $ 或 $ 1 $ 个折点。当折线有 $ 4 $ 个折点时必然可以得出一种构造方案：

* 将给定整点按照 $ x $ 轴升序为第一关键字，$ y $ 轴降序为第二关键字排序，四个折点分别位于 $ (x_{n/2}-0.5,0),(x_{n/2}-0.5,y_{n/2}-0.5),(x_{n/2}+0.5,y_{n/2}-0.5),(x_{n/2}+0.5,10^{100}) $。

因此折线折点数在 $ 2 $ 到 $ 4 $ 之间。

折点数为 $ 2 $ 意味着存在一条与坐标轴垂直的线将整点分为两半，可以将整点按 $ x $ 轴升序和 $ y $ 轴升序分别排序后，检查 $ n/2 $ 和 $ n/2+1 $ 两个整点 $ x $ 坐标（$ y $ 坐标）是否相同，如果不同答案为 $ 2 $。注意只要两次排序中任意一次不同即可满足要求。

折点数为 $ 3 $ 意味着存在一块右下角区域或左上角区域整点数为 $ n/2 $。还是只要一块区域满足要求即可。我们以左上角为例。首先将整点按照 $ x $ 坐标排序，然后我们遍历所有整点，将整点的 $ y $ 坐标加入树状数组。当两个整点的 $ x $ 坐标不同时，意味着我们已经遍历完一条竖线了，我们进行二分查找，找出是否存在 $ y_0 $ 使得在树状数组中 $ y $ 坐标严格高于 $ y_0 $ 的点数正好有 $ n/2 $ 个。因为我们是从左往右加点的，所以如果存在说明一定存在一个左上角区域点数为 $ n/2 $。右下角同理。

否则折点数一定为 $ 4 $。

实现细节较多。

## AC 代码

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 5e5 + 5;
int T;
int n;
struct node {
	int x;
	int y;
} a[N];
bool cmp1(node p1, node p2) {
	if(p1.x != p2.x) {
		return p1.x < p2.x;
	}
	return p1.y < p2.y;
}
bool cmp2(node p1, node p2) {
	if(p1.y != p2.y) {
		return p1.y < p2.y;
	}
	return p1.x < p2.x;
}
int c[N];
int lowbit(int x) {
	return x & (-x);
}
void init() {
	for(int i = 1; i <= n; i++) {
		c[i] = 0;
	}
}
void update(int x, int v) {
	for(int i = x; i <= n; i += lowbit(i)) {
		c[i] += v;
	}
}
int query(int x) {
	int res = 0;
	for(int i = x; i >= 1; i -= lowbit(i)) {
		res += c[i];
	}
	return res;
}
int main() {
	scanf("%d", &T);
	int l, r, mid;
	for(int ti = 1; ti <= T; ti++) {
		scanf("%d", &n);
		for(int i = 1; i <= n; i++) {
			scanf("%d%d", &a[i].x, &a[i].y);
		}
		sort(a + 1, a + n + 1, cmp1);
		if(a[n / 2].x != a[n / 2 + 1].x) {
			printf("2\n");
			continue;
		}
		sort(a + 1, a + n + 1, cmp2);
		if(a[n / 2].y != a[n / 2 + 1].y) {
			printf("2\n");
			continue;
		}
		init();
		sort(a + 1, a + n + 1, cmp1);
		a[0].x = a[1].x;
		for(int i = 1; i <= n; i++) {
			if(a[i].x != a[i - 1].x) {
				l = 0;
				r = n + 1;
				while(l + 1 < r) {
					mid = (l + r) >> 1;
					if(query(n) - query(mid) >= n / 2) {
						l = mid;
					} else {
						r = mid;
					}
				}
				if(query(n) - query(l) == n / 2) {
					printf("3\n");
					a[0].x = -1;
					break;
				}
			}
			update(a[i].y, 1);
		}
		if(a[0].x == -1) {
			continue;
		}
		init();
		sort(a + 1, a + n + 1, cmp2);
		a[0].y = a[1].y;
		for(int i = 1; i <= n; i++) {
			if(a[i].y != a[i - 1].y) {
				l = 0;
				r = n + 1;
				while(l + 1 < r) {
					mid = (l + r) >> 1;
					if(query(n) - query(mid) >= n / 2) {
						l = mid;
					} else {
						r = mid;
					}
				}
				if(query(n) - query(l) == n / 2) {
					printf("3\n");
					a[0].y = -1;
					break;
				}
			}
			update(a[i].x, 1);
		}
		if(a[0].y == -1) {
			continue;
		}
		printf("4\n");
	}
	return 0;
}
```

## 总结与评价

对于树状数组做法，码量较大，思维难度中等。

很适合作为树状数组的基础练手题。

感觉上位绿。

（好像正解不是树状数组？但是我最开始想到的做法就是树状数组）

---

## 作者：xiaoPanda (赞：0)

## Solution
容易发现答案只有可能为 $2,3,4$，证明如下：

很明显答案不可能为 $1$，这里给出一种答案为 $4$ 的满足条件的构造方案：

先找到一个点使得过这个点作一条平行 $y$ 轴的线段，直线把所有点分成两部分（不包括直线上的点），两部分点的数量尽量平均分。

然后考虑把直线上的点分成两部分，容易发现两边点的数量之差最多为中间的点的数量，所以可以做出一条平行 $x$ 轴的线段满足条件，再作一条平行 $y$ 轴的线段，两条平行 $y$ 轴的线段分开了两个部分，一条平行 $x$ 轴的线段进行细微调整，可以看图理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/0u93imyh.png?x-oss-process=image/resize,m_lfit,h_500,w_1000)

$\text{Upd}$：有的时候第一次竖着切时 $4$ 次无法完成，但可以横着切，和上面同理。

所以题目转换成能判断否在 $2$ 或 $3$ 次内得到结果（否则就要四次）。

+ 能否在 $2$ 次得到结果

按照横坐标轴排序，求出对于某一时刻在这个点右侧的点的数量，若存在某一时刻使得答案为 $\frac n 2$ 代表可以，纵坐标的处理相同（既可能时横着切也可能是竖着切）。

+ 能否在 $3$ 次得到结果

注意到只有先向上再向右和先向右再向上两种情况符合条件（先向下或先向左的情况还有多拐一个弯，需要 $4$ 次），先考虑第一种情况：

还是先按照横坐标排序，从右往左枚举横坐标，容易发现纵坐标的选择有单调性（往右的横线越往上，包含的区间内点更多），可以二分纵坐标，接着可以用树状数组求出这个区间内点的个数。

具体的，把当前横坐标的右边的点的纵坐标加到树状数组里（横坐标不断左移，故每个点只加了一次），然后查询小于等于二分的纵坐标的点的数量即可，若存在某一时刻使得答案为 $\frac n 2$ 代表可以，另一种情况同理，可以看图理解：

![https://cdn.luogu.com.cn/upload/image_hosting/125gxfs3.png?x-oss-process=image/resize,m_lfit,h_500,w_1000](https://cdn.luogu.com.cn/upload/image_hosting/125gxfs3.png?x-oss-process=image/resize,m_lfit,h_500,w_1000)

时间复杂度为 $O(n\log^2n)$，可以通过。
## Code
判断能否为 $2$ 的一种情况：
```cpp
sort(a+1,a+n+1,cmp);
FOR(i,1,n)
{
	while(a[i].x==a[i+1].x&&i<n)i++;
	if(i==n/2)
	{
		puts("2");
		return;
	}
}
```

判断能否为 $3$ 的一种情况：
```cpp
sort(a+1,a+n+1,cmp);
ROF(i,n,1)
{
	while(a[i].x==a[i-1].x&&i>1)add(a[i].y),i--;
	add(a[i].y);
	int l=1,r=K;
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(query(mid)==n/2)
		{
			puts("3");
			return;
		}
		if(query(mid)<n/2)
			l=mid+1;
		else r=mid-1;
	}
}
```

---


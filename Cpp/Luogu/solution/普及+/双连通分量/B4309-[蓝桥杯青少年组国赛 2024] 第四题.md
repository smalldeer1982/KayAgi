# [蓝桥杯青少年组国赛 2024] 第四题

## 题目描述

一张棋盘由 $n$ 行 $m$ 列的网格矩阵组成，每个网格中最多放一颗棋子。当前棋盘上已有若干棋子。所有水平方向或竖直方向上相邻的棋子属于同一连通块。

现给定棋盘上所有棋子的位置，如果要使棋盘上出现两个及以上的棋子连通块，请问最少需要移除几颗棋子？如果无论怎么移除棋子都无法满足要求，则输出 $-1$。（注：只能通过移除棋子的操作来使棋盘上出现两个及以上的棋子连通块。）

## 样例 #1

### 输入

```
2
3 3
L G G
L G G
L L L
4 4
L L L L
L G L L
L G L L
L L L L```

### 输出

```
2
-1```

# 题解

## 作者：Bobi2014 (赞：4)

这是一道 ~~可爱~~ 的 Tarjan 题目。

Update 2025.05.17：感谢 @Yezi_damn 提出的问题，将 $< 3$ 写成 $< 2$ 了。

### 前置知识

- [Tarjan](https://oi-wiki.org/graph/scc/)

### 思路

因为题目中的 $T$、$n$、$m$ 都很小，所以我们考虑把棋盘变成图，只需要把相邻 $2$ 个棋子连边即可，接下来我们分类讨论：

- 如果连通块个数已经 $> 1$ 了，那么输出 $0$。（这一步使用 dfs）
- 如果点数已经 $< 3$ 了，那么输出 $-1$。（这一步使用特判）
- 如果存在割点，说明只要 $1$ 步就可以把连通块切开，那么输出 $1$。（这一步使用 Tarjan）
- 否则因为这一步肯定存在大小 $> 2$ 的环，所以输出 $2$。（这一步使用特判）

时间复杂度 $O(T \times n \times m)$。

---

## 作者：sky_cyh (赞：2)

### 思路
首先，将每个点编一个唯一的编号，化面为点。用 $id$ 数组记录每个点的编号，第 $i$ 行第 $j$ 列的编号是 $(i-1)\times m+j$。

然后，将矩阵变为图，将每两个相邻存在棋子的点的连一条边。

有以下几种情况，分类讨论。
1. 若图上的连通块数量大于一，无需任何操作，答案为 $0$。
2. 若图上的点数量小于等于二个，移除一个点之后点数小于二个，无法操作，答案为 $-1$。
3. 若图上有大于等于一个割点，删掉任意一个割点后，图必然不连通，答案为 $1$。
4. 否则，这个图是由许多矩阵组成的环，删掉与某个矩阵的一个角相连的两个点后，这个点就会与其他点不连通，答案为 $2$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char c[1010][1010];
int n,m,cnt,id[1010][1010];
vector<int>G[200010];
void add(int x,int y,int x2,int y2) {
	if(x2>n||x2<1||y2>m||y2<1||c[x2][y2]!='G') return;
	G[id[x][y]].push_back(id[x2][y2]);
}
int times,dfn[200010],low[200010];
bool iscut[200010];
void init() {
    for(int i=1; i<=20000; i++) G[i].clear();
	for(int i=0; i<=200; i++) {
        for(int j=0; j<=200; j++) {
            c[i][j]='L';
        }
    }
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(iscut,0,sizeof(iscut));
	memset(id,0,sizeof id);
	cnt=times=0;
}
void dfs(int u,int fa) {
	dfn[u]=low[u]=++times;
	int child=0;
	for(int i=0; i<G[u].size(); i++) {
		int v=G[u][i];
		if(dfn[v]==0) {//如果目标点v没有访问过则说明这次 (u,v)是树边
			child++;
			dfs(v,u);
			low[u]=min(low[v],low[u]);
			if(low[v]>=dfn[u]) {//如果v这棵子树没有办法返祖到u之上，说明u就是割点
				iscut[u]=true;
			}
		} else if(dfn[v]<dfn[u]&&v!=fa) {//否则如果不是父节点，则这条边是一条返祖边
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(fa==-1&&child==1) {//如果根节点只有一颗子树， 那么它不是割点 
		iscut[u]=false;
	}
} 
int main() {
	int T;
	cin>>T;
	while(T--) {
		init();
		cin>>n>>m;
		int ans2=0;
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				cin>>c[i][j];
				id[i][j]=((i-1)*m+j);
				if(c[i][j]=='G') {
					ans2++;
				}
			}
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
                if(c[i][j]!='G') continue;
				add(i,j,i-1,j);
				add(i,j,i+1,j);
				add(i,j,i,j-1);
				add(i,j,i,j+1);
			}
		}
		int ans=0;
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				if(dfn[id[i][j]]==0&&c[i][j]=='G') {
					dfs(id[i][j],-1);
					ans++;
				}
			}
		}
		for(int i=0; i<=id[n][m]; i++) {
			if(iscut[i]==true) {
				cnt++;
			}
		}
		if(ans>1) {
			printf("0");
		} else if(ans2<3) {
			printf("-1");
		} else if(cnt>0) {
			printf("1");
		} else {
			printf("2"); 
		}		
		printf("\n");
	}
	return 0;
}
```

---

## 作者：weapons (赞：1)

### 题意
  在棋盘上有若干棋子，移走最少棋子使所有棋子分为两个及以上的连通块。
### 思路
  分为 $4$ 种情况：一，棋盘上本来就有大于等于两个连通块，此时需要移动 $0$ 个棋子。二，棋盘上有割点，此时只需要移动 $1$ 个棋子。三，棋盘上的棋子形成了棋子数大于 $3$ 的一个环，此时需要移动 $2$ 个不相邻的棋子。四，如果上述情况都不满足，则输出 $-1$，代表无法完成, 当然移动的棋子越少越好。
  
  所以，这道题就是 Tarjan 割点和无向图缩点的模板的混合体。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5+5;
int m, n, t, head[maxn], a[2005][2005], cnt, len, pan;
char mp[2005][2005];//mp数组存最初始的图
int low[maxn], dfn[maxn], tim, q[maxn], top, ans;
struct Edg {
	int u, v, nst;
} edg[maxn];//邻接表
void tarjian(int u, int prt) {
	low[u] = dfn[u] = ++tim;
	int so = 0, ic = 0;// so 是儿子数，但不包括祖先数，ic 判断是否为割点
	q[++top] = u;
	for (int i = head[u]; i; i = edg[i].nst) {
		int v = edg[i].v;
		if (v == prt)continue;
		if (dfn[v] == 0) {
			tarjian(v, u);
			low[u] = min(low[u], low[v]);
			if ((prt == 0 && ++so > 1) || (prt != 0 && dfn[u] <= low[v]))ic = 1;//如果为根节点，且儿子数>1，或者不为根节点，且至少有一个儿子，都是割点
		} else low[u] = min(low[u], dfn[v]);
	}
	if (ic)ans = 1;//记录是否能通过移动割点做到
	if (dfn[u] == low[u]) {
		int si = 0;//存一个环中的棋子数
		while (q[top + 1] != u) {
			si++;
			top--;
		}
		if (si > 2)pan = 1;//如果有两个及以上，标记可以通过移动两个棋子做到
	}
}
int main() {
	cin >> t;
	for (int kk = 1; kk <= t; kk++) {
		cin >> n >> m;
		ans = 0;
		pan = 0;
		memset(dfn, 0, sizeof(dfn));
		memset(low, 0, sizeof(low));
		memset(a, 0, sizeof(a));
		memset(head, 0, sizeof(head));
		memset(q, 0, sizeof(q));
		cnt = 0;
		len = 0;
		top = 0;
		tim = 0;
		for (int i = 0; i < 63; i++) {
			for (int j = 0; j < 63; j++) {
				mp[i][j] = 'L';
			}
		}//初始化
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				cin >> mp[i][j];
				a[i][j] = ++cnt;//编号
			}
		}

		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (mp[i][j] == 'G') {
					if (i - 1 >= 1 && mp[i - 1][j] == 'G') {//上
						edg[++len] = {a[i][j], a[i - 1][j], head[a[i][j]]};
						head[a[i][j]] = len;
					}
					if (i + 1 <= n && mp[i + 1][j] == 'G') {//下
						edg[++len] = {a[i][j], a[i + 1][j], head[a[i][j]]};
						head[a[i][j]] = len;
					}
					if (j - 1 >= 1 && mp[i][j - 1] == 'G') {//左
						edg[++len] = {a[i][j], a[i][j - 1], head[a[i][j]]};
						head[a[i][j]] = len;
					}
					if (j + 1 <= m && mp[i][j + 1] == 'G') {//右
						edg[++len] = {a[i][j], a[i][j + 1], head[a[i][j]]};
						head[a[i][j]] = len;
					}
				}
			}
		}
		int ju = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (dfn[a[i][j]] == 0 && mp[i][j] == 'G') {
					tarjian(a[i][j], 0);
					ju += 1;//如果一次遍历不完，则为非连通图，不需要移动棋子。
				}
			}
		}
		if (ju > 1) {
			cout << 0 << endl;//非连通图
			continue;
		}
		if (ans == 1) {//有割点
			cout << 1 << endl;
			continue;
		}
		if (pan) {//有>2个棋子的环
			cout << 2 << endl;
			continue;
		}
		cout << -1 << endl;
	}
}
```

---

## 作者：Bill_luogu (赞：1)

割点的变形题。

先把图从二维转成一维，把 `G` 跟相邻的 `G` 连边，用 $sum$ 统计 `G` 的数量，然后跑 Tarjan 找割点。

找完割点后，有 $4$ 种情况：
1. 整个图不连通，即有 $\ge2$ 个连通块，不用删，输出 $0$；
2. 有割点，删其中一个割点即可满足有 $\ge2$ 个连通块，输出 $1$；
3. $sum\le2$（即 `G` 的数量 $\le2$），无解，怎么删都不行，因为 `G` 的数量 $\le2$ 并且连通块数量为 $1$，输出 $-1$；
4. 这个图是一个大环，只要删除环中某个点相连的两个点即可，输出 $2$。

**最后记得清空！！！**
## AC Code：
```cpp
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
int t,n,m;
int dfn[500010],scc,sum;
bool flag;
int cnt,root;
int low[500010];
vector<int> v[500010];
char a[100][100]; 
void tarjan(int x,int fa)
{
	int sum=0;
	dfn[x]=low[x]=++cnt;
	for(int i=0;i<v[x].size();i++)
	{
		int y=v[x][i];
		if(!dfn[y])
		{
			tarjan(y,x);
			sum++;
			low[x]=min(low[x],low[y]);
			if(low[y]>=dfn[x]&&x!=root)
				flag=1;
		}
		else if(y!=fa) low[x]=min(low[x],dfn[y]);
	}
	if(x==root&&sum>=2)
		flag=1;
}
void jb(int x1,int y1,int x2,int y2)
{
	if(x2>n||x2<1||y2>m||y2<1)return;
	if(a[x1][y1]!='G'||a[x2][y2]!='G')return;//两头是 G 才连边
	v[(x1-1)*m+y1].push_back((x2-1)*m+y2);
}
bool check()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]=='G'&&!dfn[(i-1)*m+j])
			{
				cout<<"0\n";
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
        //一定要清空！！！
		memset(dfn,0,sizeof dfn);
		memset(low,0,sizeof low);
		memset(v,NULL,sizeof(v));
		memset(a,NULL,sizeof(a));
		sum=flag=0;
        cnt=0;
        root=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				cin>>a[i][j];
                if(a[i][j]=='G')
                    root=(i-1)*m+j,sum++;//统计 G 的数量
			}
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
                                //加边
				jb(i,j,i-1,j);
				jb(i,j,i+1,j);
				jb(i,j,i,j-1);
				jb(i,j,i,j+1);
			}
		}
		tarjan(root,0);//找割点
        if(check())continue;//图不连通
        if(flag)//有割点
            cout<<"1\n";
        else
        {
            if(sum<=2)cout<<"-1\n";//只有少于 2 个 G ，无解 
            else
            cout<<"2\n";//图是大环
        }
	} 
	return 0;	
} 
```

---

## 作者：Chengqijun2012 (赞：1)

一道求割点的变种题。

我们考虑给每个 `G` 连边，用一个 $sum$ 变量累计 `G` 的数量再跑 Tarjan 找割点，然后就会出现以下几种情况：
- 整个图本身就不连通，一个点都不用删，直接输出 $0$。
- 连完边后 $sum \le 2$，就是一个两点一线的图，这种图无论怎么删点都无法使棋盘上出现两个及以上的棋子连通块，输出 $-1$。
- 有割点，删割点就行，输出 $1$。
- 如果以上情况都不满足，那这个图就是一个环，加上这题建图的方式，容易想到这个图一定是**一个**以矩形为基础的扩展。此时我们考虑最优的情况：割掉四个角中的其中一个。也就是把跟某个角相邻的两个棋子移除，输出 $2$。证明也很简单，这里不过多阐述。

AC Code：
```cpp
#include <iostream>
#include <cstring>
#include <queue>
#include <vector>
#include <climits>
#include <algorithm>
#include <cmath>
#define ll long long
#define P pair<int, int>
#define MP make_pair
#define PU push_back
using namespace std;
const int N = 60 * 60 + 5;
int T, n, m, dfn[N], low[N], tot, root, sum;      //sum变量存棋子数
char mp[N][N];      //mp数组存最初始的图
vector<int> g[N];      //g数组存连边后的图
bool flag = false;      //标记是否有割点

inline void init(){      //初始化函数
	memset(g, NULL, sizeof(g));
	memset(mp, NULL, sizeof(mp));
	memset(dfn, 0, sizeof(dfn));
	memset(low, 0, sizeof(low));
	tot = sum = root = 0;
	flag = false;
}

inline void add(int i, int j){      //连边
	int k = (i - 1) * m + j;
	if(mp[i - 1][j] == 'G') g[k].PU(k - m);
	if(mp[i][j - 1] == 'G') g[k].PU(k - 1);
	if(mp[i + 1][j] == 'G') g[k].PU(k + m);
	if(mp[i][j + 1] == 'G') g[k].PU(k + 1);
}

inline void build_map(){      //建图
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) if(mp[i][j] == 'G') root = (i - 1) * m + j, sum++, add(i, j);
}

inline void Tarjan(int u, int fr){      //Tarjan求割点
	int cnt = 0;
	dfn[u] = low[u] = ++tot;
	for(int v : g[u]){
		if(!dfn[v]){
			cnt++;
			Tarjan(v, u);
			low[u] = min(low[u], low[v]);
			if(u != root && low[v] >= dfn[u]) flag = true;      //找到割点后不能直接输出1，先标记一下。因为这个图可能本身就不连通，一个点都不用删
		}
		else if(v != fr) low[u] = min(low[u], dfn[v]);
	}
	if(u == root && cnt > 1) flag = true;      //同上
}

inline bool check(){
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			if(mp[i][j] == 'G' && !dfn[(i - 1) * m + j]){      //如果这个点有棋子，但是Tarjan时没遍历到，说明整个图并不连通，输出0
				cout << "0\n";
				return true;
			}
	return false;
}

int main(){
//	freopen("water.in.txt", "r", stdin);
//	freopen("water.out.txt", "w", stdout);
	
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> T;
	while(T--){
		init();
		cin >> n >> m;
		for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) cin >> mp[i][j];
		build_map();
		Tarjan(root, 0);
		if(check()) continue;
		if(flag) cout << "1\n";      //有割点的情况
		else if(sum <= 2) cout << "-1\n";      //如果棋子数<=2，那怎么移除都无法使棋盘上出现两个及以上的棋子连通块，输出-1。
		else cout << "2\n";
	}
	return 0;
}
```
个人感觉代码有点慢，可能是因为我太菜了，还请各位神犇们多多指教。

---

## 作者：fairfriendZ (赞：0)

## 警告：非正解，在学会割点前不要看。

### 算法：最短路

### 思路：

通过手推，我们会发现答案显然只有 $-1$，$0$，$1$，$2$ 四种，分别对应无解，无需操作，拿走一个点和拿走两个点。

那么，为什么最多只要拿走两个点呢？可以观看样例，发现对环而言，任意一个为上下左右四点的点最多只要拿去相邻点即可成为单点连通块。

那么，为什么有些时候只用拿走一个点呢？因为在不为环的例子中，显然只要拿走一个点。

### 难点：

对于为 $0$ 情况，可能存在几个点聚集在一起的情况。这个时候我们就可以使用最短路，如果发现原图就存在无法到达的点，那么答案就为 $0$。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read(){
    int k=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-'){
            f=-1;
        }
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        k=k*10+c-'0';
        c=getchar();
    }
    return k*f;
}
int a[609][609];
int g1[609][609];
int v[609][609];//记录当前新图
int flag;
struct fvv{
    int v;
    int w;
    //fvv(){}
    bool operator<(const fvv tmp)const{
        return w>tmp.w;
    }
};
priority_queue<fvv>q;
vector<fvv >g[200900];
int cnt[200900],dis[200900];
bool vis[200900];
void dij(int s){
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    q.push((fvv){s,0});
    // vis[s]=1;
    while(!q.empty()){
        int val=q.top().w,vp=q.top().v;
        q.pop();
        if(vis[vp]==1)continue;
        vis[vp]=1;
        for(int i=0;i<g[vp].size();i++){
            if(dis[g[vp][i].v]>dis[vp]+g[vp][i].w){
                dis[g[vp][i].v]=dis[vp]+g[vp][i].w;
                q.push((fvv){g[vp][i].v,dis[g[vp][i].v]});
            }
        }
    }
}
signed main(){
    freopen("t2.in","r",stdin);
    freopen("t2.out","w",stdout);
    int t=read();
    while(t--){
        int n=read(),m=read();
        int cnt=0;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                char c;
                cin>>c;
                if(c=='G'){
                    a[i][j]=1;
                    cnt++;
                }
            }
        }
            flag=0;
            memset(g1,0x3f,sizeof(g1));
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++){
                    if(a[i][j]==1){
                        g1[i][j]=0;
                        flag++;
                        v[i][j]=flag;
                        if(a[i+1][j]==1){
                            g1[i][j]++;
                        }
                        if(a[i-1][j]==1){
                            g1[i][j]++;
                        }
                        if(a[i][j+1]==1){
                            g1[i][j]++;
                        }
                        if(a[i][j-1]==1){
                            g1[i][j]++;
                        }
                    }
                }
            }
            // memset(g,0x3f,sizeof(g));
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++){
                    if(a[i][j]==1){
                        if(a[i+1][j]==1){
                            g[v[i][j]].push_back({v[i+1][j],1});
                        }
                        if(a[i-1][j]==1){                            
                            g[v[i][j]].push_back({v[i-1][j],1});
                        }
                        if(a[i][j+1]==1){
                            g[v[i][j]].push_back({v[i][j+1],1});
                        }
                        if(a[i][j-1]==1){
                            g[v[i][j]].push_back({v[i][j-1],1});
                        }
                    }
                }
            }
            int kl=111;
            if(cnt<=1){
                kl=-1;
            }
            else{
                dij(flag);
                bool vop=1;
                for(int i=1;i<=flag;i++){
                    if(dis[i]==4557430888798830399){
                        vop=0;
                    }
                }
                if(vop==0){
                    if(kl==111)kl=0;
                }
            }
            if(cnt==2){
                if(kl==111)kl=-1;
            }
            else{
                int ans=2;
                for(int i=1;i<=n;i++){
                    for(int j=1;j<=m;j++){
                        ans=min(ans,g1[i][j]);
                    }
                }
                if(kl==111)kl=ans;
            }
        cout<<kl<<'\n';
        // cout<<"------------------"<<'\n';
        memset(g1,0,sizeof(g1));
        memset(a,0,sizeof(a));
        memset(g,0,sizeof(g));
        memset(vis,0,sizeof(vis));
    }
}
```

---

## 作者：Lian_zy (赞：0)

求割点的入门题。

首先把网格看成一张无向图，然后把这张图中所有相邻的 `G` 连边，`L` 就扔掉不管了，因为 `L` 不会对答案产生影响，然后图中就会有一个或多个连通块，我们分类讨论。

首先多个连通块就直接 $0$ 就好。

然后是只有一个连通块的情况：

有割点：删掉割点就好，输出 $1$。

无割点：这种情况的图应该是一个环，那么删掉图中两个没有直接连边的点就好。当然如果删除掉两个点以后图只剩一个点或者图不足两个点了（也就是节点数量 $\le3$）就输出 $-1$ 然后结束。

[AC 记录](https://www.luogu.com.cn/record/212576726)

---


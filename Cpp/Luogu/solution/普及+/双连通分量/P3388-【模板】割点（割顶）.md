# 【模板】割点（割顶）

## 题目背景

割点

## 题目描述

给出一个 $n$ 个点，$m$ 条边的无向图，求图的割点。

## 说明/提示

对于全部数据，$1\leq n \le 2\times 10^4$，$1\leq m \le 1 \times 10^5$。

点的编号均大于 $0$ 小于等于 $n$。

**Tarjan 图不一定连通。**

## 样例 #1

### 输入

```
6 7
1 2
1 3
1 4
2 5
3 5
4 5
5 6```

### 输出

```
1 
5```

# 题解

## 作者：Alex_Wei (赞：314)

- Update on 2023.6.26：重构题解，原题解见 [剪贴板](https://www.luogu.com.cn/paste/8tek61w5)。
- Update on 2024.8.9：修改题解。

摘自笔记 [图论 I](https://www.luogu.com.cn/article/amxn9li0)。

#### 无向图 DFS 树

给定无向连通图 $G$，从点 $r$ 开始 DFS，取出进入每个点 $i$ 时对应的边 $(fa_i, i)$ 并定向为 $fa_i\to i$，得到一棵以 $r$ 为根的树。称 $(fa_i, i)$ 为 **树边**，其它边为 **非树边**。

给每个点标号为它被访问到的次序，称为 **时间戳**，简称 dfn。DFS 得到的结点序列称为 **DFS 序**，时间戳为 $i$ 的结点在 DFS 序中的位置为 $i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ljfysuq.png)

上图是一个可能的 DFS 树以及对应的时间戳。

无向图 DFS 树的性质（**非常重要**）：

- 祖先后代性：任意非树边两端具有祖先后代关系。
- 子树独立性：结点的每个儿子的子树之间没有边（和上一条性质等价）。
- 时间戳区间性：子树时间戳为一段区间。
- 时间戳单调性：结点的时间戳小于其子树内结点的时间戳。

### Tarjan 求割点

**前置知识**：DFS 树，DFS 序。

注意区分：DFS 序表示对一张图 DFS 得到的结点序列，而时间戳 dfn 表示每个结点在 DFS 序中的位置。

记 $x$ 的子树为 $x$ 在 DFS 树上的子树，包含 $x$ 本身，记作 $T(x)$。记 $T'(x) = V\backslash T(x)$，即整张图除了 $T(x)$ 以外的部分。

不妨认为 $G$ 是无向连通图。对于非连通图，对每个连通分量分别求割点。

笔者希望提出一种新的理解 Tarjan 算法的方式。网上大部分博客讲解 Tarjan 算法时 `low` 数组凭空出现，抽象的定义让很多初学者摸不着头脑，从提出问题到解决问题的逻辑链的不完整性让我们无法感受到究竟是怎样的灵感启发了这一算法的诞生。

#### 非根结点的割点判定

设 $x$ 不为 DFS 树的根，则 $T'(x)$ 非空。

若 $x$ 是割点，则删去 $x$ 之后，对于 $z\in T'(x)$，存在 $y$ 和它不连通。而删去 $x$ 之后 $T'(x)$ 通过树边仍然连通，所以 $y\in T(x)$。而如果 $y$ 和 $z$ 不连通，又因为 $T'(x)$ 连通，那么 $y$ 和所有 $T'(x)$ 的点均不连通。

反之，若删去 $x$ 之后存在 $y\in T(x)$ 和 $T'(x)$ 的点均不连通，那么 $x$ 显然是割点。这说明 $x$ 是割点当且仅当存在 $y\in T(x)$ 不经过 $x$ 能到达的所有点均属于 $T(x)$。

现在要刻画 “不经过 $x$ 能到达的所有点均属于 $T(x)$”。

注意到，如果 $y\in T(x)$ 不经过 $x$ 就和 $T'(x)$ 连通，那么存在 $y$ 到 $v\in T'(x)$ 的路径，满足 $v$ 是路径上第一个属于 $T'(x)$ 的结点。设路径上倒数第二个点为 $u$，则 $u\in T(x)$。如果 $(u, v)$ 是树边，那么 $u = x$，矛盾。因此 $(u, v)$ 是非树边，那么 $v$ 是 $u$ 的祖先（祖先后代性）。又因为 $x$ 是 $u$ 的祖先且 $v$ 在 $x$ 的子树外，所以 $v$ 是 $x$ 的祖先。如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/kolj8ax0.png)

进一步地，因为 $x$ 的不同儿子子树之间没有非树边（子树独立性），设 $x$ 的儿子 $y'$ 的子树包含 $y$，那么 $u\in T(y')$。

因此，如果 $y$ 不经过 $x$ 和 $T'(x)$ 连通，即 $x$ 不是割点，那么存在 $u\in T(y')$ 使得 $u$ 可以通过一条非树边到达 $x$ 的祖先。设 $f_x$ 表示与 $x$ 通过 **非树边** 相连的所有点的时间戳的最小值，则条件可写为 $f_u < d_x$。

- 对于 $T(y')$，如果存在 $u\in T(y')$ 满足 $f_u < d_x$，那么删去 $x$ 后 $T(y')$ 的每个点和 $T'(x)$ 均连通：$T(y')$ 内所有点通过树边连通，且 $u$ 和 $T'(x)$ 某点直接相连。

- 反之，如果 $T(y')$ 内所有点的 $f$ 值均不小于 $d_x$，那么删去 $x$ 后 $T(y')$ 的每个点和 $T'(x)$ 均不连通。因为如果连通，那么总得有一个点能一步连通。

这样，我们得到了非根结点的割点判定法则：

> $x$ 是割点当且仅当存在树边 $x\to y'$，使得 $y'$ 子树 **不存在** 点 $u$ 使得 $f_u < d_x$。
>
> 这等价于存在 $x$ 的儿子 $y'$，满足 $\min_{u\in T(y')} f_u \geq d_x$。

设 $g_x$ 表示 $x$ 的子树内所有点 $u\in T(x)$ 的 $f_u$ 的最小值（`low` 的真正含义），根据树形 DP，有
$$
g_x = \min\left(\min_{y'\in \mathrm{son}(x)} g_{y'}, \min_{(x, y) \in E\land (x, y)\notin T} d_y\right)
$$

对于后半部分，忽略 $(x, y)$ 必须是非树边的条件不会导致错误：如果用儿子更新，显然没有问题。如果用父亲更新，即用 $d_x$ 更新 $g_y$，也不会导致错误，因为判定是 $g_y\geq d_x$，有等号。但注意求解割边时不能忽略，因为判定是 $g_y > d_x$。

**说明**：将 $g_x$ 初始化为 $d_x$ 显然不会导致错误。

**应用**：研究删去 $x$ 后整张图的形态。删去 $x$ 后，每个判定 $x$ 为割点的 $y'$ 的 $T(y')$ 单独形成一个连通块，剩余部分（其它所有 $T(y')$ 和 $T'(x)$）形成一个连通块。因为判定割点的准则就是删去 $x$ 后 $y'$ 是否与 $T'(x)$ 连通。

#### 根的割点判定与代码

设 $x$ 为 DFS 树的根。

若 $x$ 在 DFS 树上有大于一个儿子，根据子树独立性，删去 $x$ 后各儿子子树不连通，所以 $x$ 是割点。反之删去 $x$ 后剩余部分通过树边连通，$x$ 不是割点。

综上，使用 Tarjan 算法求无向图 $G$ 的所有割点的时间复杂度为 $\mathcal{O}(n + m)$。

再次强调，以下代码仅在求解割点时正确。求解割边需要额外的特判。

[模板题](https://www.luogu.com.cn/problem/P3388) 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e5 + 5;
int n, m, R;
int dn, dfn[N], low[N], cnt, buc[N]; // dfn 是时间戳 d, low 是 g
vector<int> e[N];
void dfs(int id) {
  dfn[id] = low[id] = ++dn; // 将 low[id] 初始化为 dn 不会导致错误, 且一般都这么写
  int son = 0;
  for(int it : e[id]) {
    if(!dfn[it]) {
      son++, dfs(it), low[id] = min(low[id], low[it]);
      if(low[it] >= dfn[id] && id != R) cnt += !buc[id], buc[id] = 1;
    }
    else low[id] = min(low[id], dfn[it]);
  }
  if(son >= 2 && id == R) cnt += !buc[id], buc[id] = 1;
}
int main() {
  cin >> n >> m;
  for(int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    e[u].push_back(v), e[v].push_back(u);
  }
  for(int i = 1; i <= n; i++) if(!dfn[i]) R = i, dfs(i);
  cout << cnt << endl;
  for(int i = 1; i <= n; i++) if(buc[i]) cout << i << " ";
  return 0;
}
```

#### [P3469 [POI2008] BLO-Blockade](https://www.luogu.com.cn/problem/P3469)

一道 Tarjan 求割点的练手题。

设删去与结点 $u$ 相连的所有边之后形成的连通块大小分别为 $s_{1\sim k}$，则答案为 $\sum_{i = 1} ^ k s_i (n - s_i)$。注意，不要忘记 $u$ 没有被删去，它本身是一个大小为 $1$ 的连通块。

因为 $v$ 判定 $u$ 为割点当且仅当封锁 $u$ 之后 $v$ 及其子树与整张图剩余部分不连通，所以考虑所有判定 $x$ 为割点的 $y_i$，它们的子树分别单独形成连通块。除去这些结点后，还有一个大小为 $n - 1 - \sum size(y_i)$ 的连通块（可能为空，但不影响答案）。

时间复杂度 $\mathcal{O}(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e5 + 5;
int n, m, dfn[N], low[N], dn;
long long ans[N], sz[N];
vector<int> e[N];
void dfs(int id) {
  dfn[id] = low[id] = ++dn;
  long long r = n - 1;
  ans[id] = r, sz[id] = 1;
  for(int it : e[id]) {
    if(!dfn[it]) {
      dfs(it), low[id] = min(low[id], low[it]), sz[id] += sz[it];
      if(low[it] >= dfn[id]) ans[id] += sz[it] * (n - sz[it]), r -= sz[it];
    }
    else low[id] = min(low[id], dfn[it]);
  }
  ans[id] += r * (n - r);
}
int main() {
  cin >> n >> m;
  for(int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    e[u].push_back(v), e[v].push_back(u);
  }
  dfs(1);
  for(int i = 1; i <= n; i++) cout << ans[i] << endl;
  return 0;
}
```

---

## 作者：伊地知虹夏 (赞：230)

## 0 前言

tarjan 算法并不仅仅是一种算法，其中神秘的思想与逻辑令人惊叹。

由于笔者太弱，在此只展示 tarjan 算法求割点的方式。

## 1 正儿八经的算法简介

Tarjan 算法是基于深度优先搜索的算法，用于求解图的连通性问题。

Tarjan 算法可以在线性时间内求出无向图的割点与桥，进一步地可以求解无向图的双连通分量；同时，也可以求解有向图的强连通分量、必经点与必经边。

## 2 前置知识

### 1 割点

割点的定义是：对于一张联通图 $G = (V,E)$，存在一个点 $x \in V$，删除所有与 $x$ 相关联的边后，图分裂成两个或两个以上的不联通的子图，$x$ 即为图 $G$ 的割点。

听不懂是吧，~~我也不懂~~，对于初学者，我们只需要知道：删掉割点和与其相连的边之后，图不联通了。

### 2 时间戳

时间戳是一种对点进行编号的一种方式，具体是在深度优先搜索时，统计每个点第一次进入的时间。

### 3 搜索树

在图 $G$ 中选择 $n$ 个点，$n-1$ 条边所构成的一颗树，选择方式为深度优先搜索。

## 3 关于追溯值

这是 tarjan 算法中最神奇的东西，也是初学者最难理解的地方，我会尽量以清晰易懂的方式讲解。

在此，先给出 lyd 在《算法竞赛进阶指南》中给出的定义：

设以 $x$ 为根的搜索树的子树为 $\text{subtree}(x)$，$x$ 的追溯值 $\text{low}(x)$ 定义为以下节点的时间戳的最小值:

- $\text{subtree}(x)$ 中的节点

- 通过一条不在搜索树上的边，能到达 $\text{subtree}(x)$ 的节点。

是不是很晕？~~我也晕~~。
我们结合例图来理解一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/2rjhtigs.png)

图中用红色标出的边为树边，对于 $6$ 号节点，它的 $\text{low}$ 就是 $1$，因为它可以通过图中用奇怪颜色标出的**非树边**（我们也称这两条边为**返祖边**） $(2,6),(1,6)$ 到达 $1,2$，而 $1,2$ 中最小的时间戳是 $1$。所以 $\text{low}(6) = 1$。

接下来考虑 $\text{low}$ 的计算方法，自己肯定可达，所以 $\text{low}(x) = \text{dfn}(x)$。

然后考虑与 $x$ 的连边 $(x,y)$

- 若 $y$ 为 $x$ 在搜索树上的子节点，$\text{low}(x) = \min(\text{low}(y),\text{low}(x))$。
	
    - 解释：因为 $y$ 为 $x$ 的子节点，$y$ 可达的 $x$ 经过 $(x,y)$ 肯定也可达，根据定义，取较小值。
    
- 若 $(x,y)$ 为非树边，根据定义，我们只能取 $\text{dfn}(y)$ 来更新 $\text{low}(x)$。就像例图中 $(7,10)$ 这条边，$10$ 可达 $7$ 但不一定能到达比 $7$ 更早的节点。


## 4 如何求割点

tarjan 算法告诉我们：如果 $y$ 是 $x$ 的子节点且 $\text{low}(y) \geq \text{dfn}(x)$，那么 $x$ 就是割点。

由定义，$y$ 在不经过 $(x,y)$ 的情况下只能到达比 $x$ 更晚访问到的节点，所以删去 $(x,y)$ 后，$y$ 必定与比 $x$ 更早访问到的点不相连，就必然会分裂成一张不联通的子图。

**但是**：对于根节点，我们显然发现，这样是行不通的。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/l05nzn13.png)

我们如果钦定 $1$ 为根，显然按照上面的判定方法，$1$ 是割点。但是显然的，$1$ 并不符合割点的定义，所以，我们引出对于根 $s$ 的判定方法：

- 若 $s$ 有两颗及以上的子树，那么 $s$ 即为割点

	- 显然，割掉 $s$ 后，它的所有子树之间互不联通，所以 $s$ 为割点
    
## 5 代码实现

```cpp
void tarjan(int x,bool root){
	int ch = 0;
	low[x] = dfn[x] = ++tot;//初始化
	for(int i = head[x];i;i = e[i].nxt){
		int y = e[i].to;
		if(!dfn[y]){//在搜索树上
			tarjan(y,0);//先递归
			low[x] = min(low[x],low[y]);//求low
			if(low[y] >= dfn[x] && !root) ans[x] = 1;//判定方式1
			if(root) ch ++;//判定方式2
		}
		else low[x] = min(low[x], dfn[y]);//求low
	}
	if(root && ch >= 2){//判定方式2
		ans[x] = 1;
		return ;
	}
	return ;
}
```

本文码字时间共计 $2$h，如果您觉得不错，可以点个赞支持一下。

如果您有任何不懂的地方，欢迎私信询问。谢谢！

---

## 作者：wind_seeker (赞：129)

- 定义
	- 割点：若**删除某点以及其所有连边**后，原本其所在图被分为至少两个图，**这些图互相不能到达**，则该点为割点。
    
   - $dfn$：某点遍历时的时间戳（第几个进入）。
   
   - $low$：某点可通过回溯到达的最早的点的时间戳，回溯即意味着不能走来时的路，也就意味着走**不通过父亲的路**。
   
   - 已遍历点：$u$ 所在图中时间戳小于等于 $u$ 的点。
- 做法：
	- tarjan 基础操作：
    	* 取 $dfn$ 值为 $0$ 的点开始遍历，则对 $dfn$ 和 $low$ 进行赋值。
       
    	* 访问 $u$ 的儿子 $v$ 。
  
    	* 若 $v$ 已经遍历，则 `low[u]=min(low[u],dfn[v])`。
        
      * 若 $v$ 未曾遍历过，继续向 $v$ 遍历，而后取 `low[u]=min(low[u],low[v])`。
      
    如果对于 $v$ 已经遍历的情况不理解的话可以看后面难点。
    
	- 判断割点：
    
    	* 若其为根，有至少两个子树，则其为割点。
        
   		* 若 $u$ 不为根但是 $low_v\ge dfn_u$ 则其为割点。
     
- 证明：
	* 对于第一种割点，显然，两个子树只有根这么一条路。不过对于其儿子个数的判断，要小小讲一下。由于根可能会有几个儿子位于割去根后的同一个团中，而访问其中一个就可以通过遍历使这几个儿子的 $dfn$ 都有值。所以只有当根扫到的儿子未被访问过时，才会有 $child$ 的值加一。
    
  	* 对于第二种割点，我们需要证明一下。我们假设遍历到了 $u$，$low_v \ge dfn_u$ 表示儿子 $v$ 点回溯可到达的最先点的时间戳大于等于 $u$ 的时间戳，证明其不能通过 $u$ 以外的点与已遍历点相连，那么意味着必然可以通过割去 $u$ 而使得已遍历点与儿子 $v$ 位于两个不互相连通的图。

下面即为图示过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/urgrwk17.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/2vqnu3hj.png)

$4$ 经过搜索后，没有回溯到比父亲 $3$ 时间戳更小的点，$low_4\ge dfn_3$，所以 $3$ 为割点。

![](https://cdn.luogu.com.cn/upload/image_hosting/p0t9u7wb.png)

$1$ 为根，扫到 $3$ 和 $7$ 的时候 $3$ 和 $7$ 都没访问过，则 $1$ 有两个子树，所以 $1$ 为割点。  

$7$ 与 $3$ 一样，满足 $low_8\ge dfn_7$，为割点。

#### code
```cpp
void tarjan(int u,int anc){
	dfn[u]=low[u]=++dfncnt;
	int child=0;
	for(auto v:g[u]){
		if(!dfn[v]){
			tarjan(v,anc),low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]&&u!=anc) cut[u]=true;//如果儿子的low值大于等于dfn，则代表其为儿子与其他非子树点相连的唯一途径
			if(u==anc) child++;
		}
		else low[u]=min(low[u],dfn[v]);
	}
	if(child>=2&&u==anc) cut[u]=true;//对根的处理
```
   
- 难点：

	对于割点，很多初学者都会对于 `low[u]=min(low[u],dfn[v])` 感觉奇怪，然而将其改为 `low[u]=min(low[u],low[v])` 后，又会寄，这是因为问题出现在了割点上。
    
下图即为错误例子(取 `low[u]=min(low[u],low[v])`):

![](https://cdn.luogu.com.cn/upload/image_hosting/edvqyblz.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/pc8h3qoj.png)

$3$ 通过回溯 $1$ 而获得了 $low_3=1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oe1l5fs9.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/d7wm0n28.png)

$4$ 通过回溯 $3$ 而获得了 $3$ 的 $low$ 值，变成了 $low_4=1$。那么就不能判断 $3$ 为割点了。


- 难点证明：

   证明前提是其不是一条链，不然没有意义。由于割点同时与割后的两个图相连，它的 $low$ 值必然是两个图中较小的 $low$ 值。假设我们取 `low[u]=min(low[u],low[v])`，若后遍历的图的割点的儿子 $v$ 可回溯至割点，那么就会把割点的 $low$ 值传递回 $v$,那么它的 $low$ 值就不正确了。
   
   证明了 `low[u]=min(low[u],low[v])` 的错误，我们也来证明一下 `low[u]=min(low[u],dfn[v])` 的正确性。由于儿子未遍历情况的取小值的方式，我们知道 $low$ 值是可以传递回去的。那么其实对于 $v$ ，它只要可以搜索到**一个**比 $u$ 时间戳小的点即可，不必通过该点继续往上寻找即可证明 $u$ 为割点，所以这也是具有正确性的。
    


### code
```cpp
/* let life be like summer flowers	*/
/* by wind_seeker					*/
/* 2023-03-07 21:13					*/
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int N=2e4+1e3;

inline int read(){
	int res=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) res=(res<<3)+(res<<1)+(c^48);
	return res*f;
}

int n,m,ans;
vector<int> g[N];
bool cut[N];

int dfn[N],low[N],dfncnt;
int st[N],top;
bool inst[N];
void tarjan(int u,int anc){
	dfn[u]=low[u]=++dfncnt;
	int child=0;
	for(auto v:g[u]){
		if(!dfn[v]){
			tarjan(v,anc),low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]&&u!=anc) cut[u]=true;//如果儿子的low值大于等于dfn，则代表其为儿子与其他非子树点相连的唯一途径
			if(u==anc) child++;
		}
		else low[u]=min(low[u],dfn[v]);
	}
	if(child>=2&&u==anc) cut[u]=true;//对根的处理
}

int main(){
	n=read(),m=read();
	for(int i=1,u,v;i<=m;i++){
		u=read(),v=read();
		g[u].pb(v);g[v].pb(u);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i,i);
	for(int i=1;i<=n;i++)
		if(cut[i]) ans++;
	printf("%d\n",ans);
	for(int i=1;i<=n;i++)
		if(cut[i]) printf("%d ",i);
	return 0;
}
/*
6 7
1 2
1 3
1 4
2 5
3 5
4 5
5 6
*/
/*
1
5
*/
```
   	  

---

## 作者：zhoukangyang (赞：57)

## DFS 树

DFS 树可以通过如下过程建立。

当 DFS 到 $x$ 的时候：

- 把 $x$ 标记为被经过。
- 遍历 $x$ 的所有出边 $x \to v$。如果 $v$ 没有被经过，那么在 DFS 树上加上 $x \to v$ 的边，并执行对 $v$ 的 DFS。执行完之后继续遍历 $x$ 的出边。

这样，我们就可以对于一个连通块求出其 DFS 树。

考虑这样的树有什么性质：**每一条边都是一个点和其祖先的边！** 因为如果不是，那么先被 DFS 到的点一定会遍历到后被 DFS 到的点。

## 割点及其求法

对于一个点，我们称其为割点，当且仅当这个点及和其相邻的边删掉后，他所在的连通块的其他点不再连通。

我们对于每个连通块建立 DFS 树。为了方便理解，可以参考下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/olnh0mmf.png)

其中黑边是 DFS 树边，蓝边则不是树边，我们称其为 “非树边”。

图中的红点是割点，黄点则不是割点。

### 判定根是否为割点

首先，对于根节点的所有儿子 $v$，$v$ 子树内的所有点都是连通的（因为我们已经有了一棵生成树）。

因为 DFS 树上只有连向其祖先的边，所以不同子树内不会有相互连接的边，所以根被割掉后他们互不连通。因此根节点是割点，当且仅当根节点有超过两个个儿子。


### 判定非根节点是否是割点

不妨假设我们要判定的节点为 $x$。

这种情况不同于上一种的就是，$x$ 的父亲 $fa_x$ 也形成了一个连通块，而且 $x$ 的子树内的点也有可能和这个连通块相连接！

我们就考虑 $x$ 有哪些子节点 $v$ 和 $fa_x$ 连通呢？那就是满足 $v$ 的子树内有连到 $x$ 的祖先的边 的 $v$ 了。剩下的 $v$，没有连接到 $fa_x$ 所在连通块，也无法连接到其他子树所在的连通块，因此就只能自己形成一个连通块了。

因此，只要我们能快速知道 $v$ 子树内是否有连向 $x$ 祖先的边就可以的存储答案。

可以发现，$v$ 的子树连到了 $x$ 的祖先，当且仅当 $v$ 的子树连接到了一个深度不超过 $dep_x$ 的点！那么做法就呼之欲出了：我们只要计算出子树内能连向的深度最小的点，然后判断其与 $dep_x$ 的大小关系即可。

网络上流传的很多写法都是把 ``dep`` 换成 ``dfn`` 序，``dfn`` 序记录的是这个点在 DFS 树中是第几次被访问的。这种写法同样是正确的，读者自证不难。

## 代码

代码中，我们可以简单通过 $dep$ 值是否为 $0$ 来表示一个点有没有被经过（根节点 $dep$ 为 $1$）。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 7;
int n, m, ehd[N], ev[N], enx[N], eid;
void eadd(int u, int v) { 
	++eid, enx[eid] = ehd[u], ev[eid] = v, ehd[u] = eid;
}
int dep[N], low[N], ns[N];
void dfs(int x, int isroot) {
	low[x] = dep[x];
	int cnt = 0; // 记录独立的子树数量 
	for(int i = ehd[x]; i; i = enx[i]) {
		if(!dep[ev[i]]) {
			dep[ev[i]] = dep[x] + 1;
			dfs(ev[i], 0);
			low[x] = min(low[x], low[ev[i]]);
			if(low[ev[i]] >= dep[x]) ++cnt;
		}
		else low[x] = min(low[x], dep[ev[i]]);
	}
	if(!isroot && cnt >= 1) ns[x] = 1;
	if(isroot && cnt >= 2) ns[x] = 1;
}
int main () {
	ios :: sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= m; ++i) {
		int u, v;
		cin >> u >> v;
		eadd(u, v);
		eadd(v, u);
	}
	for(int i = 1; i <= n; ++i) if(!dep[i]) dep[i] = 1, dfs(i, 1);
	int count = 0;
	for(int i = 1; i <= n; ++i) count += ns[i];
	cout << count << '\n';
	for(int i = 1; i <= n; ++i) if(ns[i]) cout << i << ' ';
	cout << '\n';
	return 0;
}
```

---

## 作者：xcrr (赞：27)

1. 强连通分量、割点、割边、点双连通分量、边双连通分量的区分。

可能这个很多人搞不清楚。割点、割边（又称桥）、点双连通分量（简称点双）、边双连通分量（简称边双）四个都是无向图中的概念；强连通分量和 “缩点” 操作是有向图中的概念。

割点和点双通常一起出现，割边和边双通常一起出现。

“分量” 一般是定义子图的，比如点双连通分量是无向图的极大双连通子图。“xxx 分量” 和 “xxx 图” 在性质上一般没有区别。

2. tarjan 系列怎么学？先学什么？

先学割点是没问题的，因为这些你学会一个其它的也都会了。从难度角度，本人也认为割点在 tarjan 家族难度不高，至少比强连通分量好理解。

3. 割点、点双的定义？

> 一个无向图如果去掉某个节点和它的所有边就不再连通，那么这个点叫做割点；

> 如果一个无向图去掉任意一个节点都连通，即不存在割点，那么这个图叫做点双连通图；

> 一个无向图中的每个极大点双连通子图称作此无向图的点双连通分量。

说白了，**割点就是删掉后使图从连通变成不连通的点，在点双中不存在割点。**

割边和边双的定义其实可以类比。

4. 点双和边双的关系有什么特殊性？

首先，很显然，点双、边双一定是一个连通块。一个连通块不一定是点双、边双。

其次，除两点一线的特殊情况，点双一定是边双，反之不一定。

5. 怎么求割点？

正片开始。[P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

以下说的是连通图，不连通分别做就行。

我们要接触到 tarjan 家族的老朋友：

* dfs 树：对一个无向连通图 $G=(V,E)$ 做一遍 dfs，经过的点和边构成一个树 $G'=(V,E')$，这棵树叫做 dfs 树。

这样，我们可以对边集 $E$ 进行分类：$\forall e \in E'$ 叫做树边，$\forall e \in \complement_E E'$ 叫做非树边。

因为 dfs 到了一个节点会走完能走的边，我们能注意到，每条非树边两边的节点在 dfs 树中一定连接了祖先和子孙，我们把这种边叫做**返祖边**。不存在没有祖先子孙关系的非树边。也就是说，假设一条边 $e$ 连接了节点 $v_1$ $v_2$，则 $lca_{v_1,v_2}=v_1 或 v_2$。之所以这么强调，是因为在有向图中，存在连接没有祖先子孙关系的非树边，叫做**横叉边**，这是一个不同点。

* $dfn$：是指一个节点被深度优先搜索到（被第一次访问、进入搜索树）的顺序。比如根节点的 $dfn$ 是 $1$。

* $low$：$low_u$ 指从 $u$ 出发，可以经过任意多条树边，最多经过一条非树边，到达的最小的 $dfn$。

那么这两个数组怎么算？首先，第一次搜到 $u$ 时，可知 $dfn_u$ 可以直接知道，$low_u$ 初始先赋为 $dfn_u$（不会更大）。

扫 $u$ 的每条边，设这条边连接的另一个点是 $v$，如果 $v$ 没有被搜过，这条边就是一条树边，那么就先处理 $v$，再将它的 $low_v$ 更新给 $low_u$。 如果 $v$ 被搜过了，这条边就是一条返祖边，那么用它的 $dfn_v$ 更新 $low_u$。 用 $dfn_v$ 更新而不是 $low_v$ 更新的原因在于我们对 $low$ 数组的定义是只允许经过**一条**非树边，如果用 $low_v$ 更新，会出现错误（见下文）。

接下来看割点怎么判断。

对于非根节点 $u$，如果存在一个子结点 $v$ 满足 $low_v\ge dfn_u$，说明 $v$ 无法不经过点 $u$ 到比 $u$ 的 $dfn$ 更小的节点。因此，如果删去 $u$，存在不连通的点。$u$ 就是割点了。如果不存在这样的子节点，意味着 $u$ 两边的节点一定存在不经过 $u$ 相到达的方式，$u$ 一定不是割点。

现在讲为什么返祖边的情况里 $low_u$ 用 $low_{fa}$ 更新会有细节的问题：若一个节点 $u$ 自己有返祖边，第一次搜索到自己时，自己的 $low$ 先被 $low_{fa}$ 更新了；但是接下来访问到的某个子节点 $v$ 又有到 $u$ 的返祖边，$low_u$ 又更新了 $low_v$，导致本来 $u$ 节点是割点，从 $v$ 节点跳不出去的情况，被当作可以，判断有误。

对于根节点，因为它的 $dfn$ 一定最小，所以上述判断方法不适用。它的判断方法：如果有两个以上子节点，它就一定是割点，否则一定不是。

```cpp
void tarjan(int x)
{
	int child=0;
	dfn[x]=low[x]=++cnt;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);

			if(x==root)child++;
			if(dfn[x]<=low[y]&&x!=root)
			IsCut[x]=1;
		}
		else low[x]=min(low[x],dfn[y]);
	}
	if(x==root&&child>=2)
		IsCut[x]=1;
}

int main()
{
	rd(n,m);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		rd(u,v),add(u,v),add(v,u);
	}

	for(int i=1;i<=n;i++)
	if(!dfn[i]) root=i,tarjan(i);

	int ans=0;
	for(int i=1;i<=n;i++)
		if(IsCut[i]) ans++;
	wt(ans,'\n');
	for(int i=1;i<=n;i++)
		if(IsCut[i]) wt(i,' ');
	return 0;
}
```

有问题评论指出，随时解释 or 改正。

---

## 作者：RyexAwl (赞：16)

## 0.前置知识

- 基本图论概念。

- 无向图的 DFS。

- 基本的递推 / DP 思想。

## 1.DFS 树

对于无向连通图 $G=(V,E)$，考虑按如下方式建立一个新的无向图 $G'=(V,E')$。规定其中 $V=\{1,2,3,...,n\}$。

```cpp
void dfs(int x) {
  vis[x] = true;
  for (auto v : G[x]) {
    if (vis[v]) continue;
    ins_edge(x,v); // 将边 (x,v) 加入 E' 中
    dfs(v);
  }
}
```

从 [[Tutorial] The DFS tree and its applications: how I found out I really didn't understand bridges](https://mirror.codeforces.com/blog/entry/68138) 贺的动图。

![](https://mirror.codeforces.com/predownloaded/8d/be/8dbe5d89e58b67f3d8e4d8e0e8eb3358ba921b28.png)

**性质 1.1：** 图 $G'$ 是树。

考虑以下代码：

```cpp
void dfs(int x) {
  vis[x] = true; 
  p[++ cnt] = x; 
  for (auto v : G[x]) {
    if (vis[v]) continue;
    ins_edge(x,v); // 在 dfs 树中加入边 (u,v)
    father[v] = x;
    dfs(v);
  }
}
```

$p_1,p_2,...,p_n$ 可以看成点集 $V$ 在 dfs 过程中访问的顺序，对于 $i>1$，一定有 $\mathrm{father}[p_i]\in \{p_1,p_2,...,p_{i-1}\}$。那么可以将其看成按顺序加点，加入点 $p_i$ 时，在 $\{p_1,p_2,...,p_{i-1}\}$ 中确定父亲并加入 $p_i$ 与父亲的边，特别的将 $p_1$ 看成根。在外部调用 `dfs(rt)` 可以看成建立以 $rt$ 为根的一棵生成树，称其为图 $G$ 以 $rt$ 为根的 DFS 树。并且我们将序列 $p$ 称为从 $rt$ 开始 DFS 的 DFS 序，如果 $p_i=x$，称点 $x$ 的时间戳为 $i$，可以记作 $dfn_x=i$。 

注意，**以固定节点为根建立的 DFS 树形态不唯一**。

**性质 1.2：** 对于所有非树边，在树上都是连接祖先和后代的。

贺来的图，可以结合图片理解该性质表达的意思，其中黑色加粗的边表示以 $1$ 为根建立的某棵 DFS 树上的边，未被加粗的边为 “非树边”：

![](https://mirror.codeforces.com/predownloaded/8b/cc/8bccbec25c8d76a68c34303a58836756225129b1.png)

考虑如果出现了 “横叉边” $(u,v)$（即 $u,v$ 在 DFS 树上并非祖先关系）：

![](https://cdn.luogu.com.cn/upload/image_hosting/c6jhmqzr.png)

设 $dfn_u<dfn_v$：

- 在遍历 $u$ 的出边时一定会遍历到边 $(u,v)$，如果此时 $v$ 未被访问（即 `vis[v] == false`）那么 $v$ 就会变成 $u$ 的儿子，与 $(u,v)$ 是横叉边矛盾。

- 可以推出如果 $(u,v)$ 是横叉边，那么在遍历到边 $(u,v)$ 时，$v$ 已经被访问过。又因为 $dfn_u<dfn_v$，所以在调用 `dfs(u)` 前未调用过 `dfs(v)`，根据 DFS 的过程，在出 $u$ 的子树前，不会访问 $u$ 子树外的点，所以可以推出 $v$ 在 $u$ 子树内，与 $(u,v)$ 是横叉边矛盾。

- 一个感性理解是对于一条边 $(u,v)$，如果 $dfn_u<dfn_v$，那么在遍历到边 $(u,v)$ 时如果 $v$ 未被访问那么 $v$ 是 $u$ 的儿子，否则因为 $u$ 的边还没遍历干净，根据 DFS 的过程，可以观察到此时有 $v$ 在 $u$ 子树内。

## 2.割点判定定理与 tarjan 算法

判断点 $x$ 是否是割点等价于考虑 $x$ 所在的连通块，删掉 $x$ 后连通块内的点是否连通，接下来只考虑一个连通块内的情况，即只考虑在一个无向连通图内判断点 $x$ 是否是割点。

接下来考虑在 DFS 树上确定 **非根** 节点 $x$ 是不是割点。不考虑非树边，删掉点 $x$ 后，树可以裂成若干个部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/96ouwm2v.png)

删掉 $x$ 后，只考虑树边的情况下有三个连通块 $A,B,C$，其中 $B,C$ 是 $x$ 儿子的子树，$A$ 是 $x$ 子树外的部分。

接下来考虑把非树边加进去，考察连通性。注意到，因为我们只在意连通性，所以我们并不在意 $A,B,C$ 内部的非树边，只在意 $A,B,C$ 之间的非树边。

根据 **性质 1.2**，建立 DFS 树后，所有非树边都是返祖边，所以 $A,B,C$ 之间的非树边，一定是 $B,A$ 之间和 $C,A$ 之间的边。

那么对于上面的图来说，在加入非树边后图连通的充要条件即 $B,A$ 之间存在返祖边且 $C,A$ 之间存在返祖边。

比如：

![](https://cdn.luogu.com.cn/upload/image_hosting/yn7jmqgi.png)

那么 $x$ 是割点当且仅当 $B,C$ 中有至少一棵子树与 $A$ 没边。

考虑更一般的情况，非根节点 $x$ 是割点当且仅当在 DFS 树上 $x$ 存在一个儿子 $y$ 满足 $y$ 子树内部的点与 $x$ 子树外的点没有边。

注意，之所以是非根节点，是因为当 $x$ 为根时，$A$ 为空，此时 $x$ 是割点等价于 $x$ 的儿子个数大于 $1$。

那么考虑维护哪些信息能够判定 $x$ 是否存在一个儿子 $y$ 满足 $y$ 子树内不存在连接 $x$ 子树外的边。

将所有非树边按从后代到祖先的方向定向，对于边 $(p,q)$，如果 $p$ 是 $q$ 的祖先称该边为从 $q$ 出发，终点为 $q$ 的返祖边。

注意到，对于 $x$ 的一个儿子 $y$，我们只在意从其子树内部出发终点深度最浅的返祖边。

![](https://cdn.luogu.com.cn/upload/image_hosting/oeg6t3r5.png)

如图，绿色的是起点和终点都在 $y$ 子树内部的返祖边，红色和橙色是从 $y$ 子树内部出发，终点为 $x$ 子树外的两条边（红色是从 $y$ 子树内部出发，终点深度最小的返祖边）。但是实际上对于 $y$ 子树内部的所有返祖边，我们可以只在意红色的那条。

考虑对每个点 $u$ 求出 DFS 树上以 $u$ 为根的子树内部点出发的所有返祖边中终点时间戳最小的时间戳（注意到，这里时间戳最小的点等价于深度最小的点），$low_u$。（当然这里其实可以直接定义为深度最小的点的深度（[定义为最小深度时的写法](https://www.luogu.com.cn/paste/s366knyv)），为了与目前流行的 tarjan 算法写法中的 low 数组定义一致，本文的主要内容使用该定义）

那么，我们不难得到 **性质 2.1（割点判定定理）**：对于 DFS 树上非根节点 $x$，点 $x$ 是割点当且仅当 $x$ 存在一个儿子 $y$ 满足 $low_y\ge dfn_x$，对于根节点 $rt$，$rt$ 是割点当且仅当存在大于 $1$ 个儿子 $y$ 满足 $low_y\ge dfn_x$。

那么接下来考虑如何计算 $low_u$，这里采用类似树形 DP 中自底向上递推的计算方法。如果 $u$ 有 $k$ 个儿子 $v_1,v_2,...,v_k$，那么可以把从 $u$ 子树内部出发的返祖边集合分为 $k+1$ 类，即从 $u$ 出发的和从 $v_1,v_2,...,v_k$ 子树内部出发的。对于前者直接遍历所有从 $u$ 出发的返祖边即可枚举，对于后者可以利用 $low_{v_i}$ 转移。

接下来考虑具体的算法实现。

为了方便实现，我们对代码中的 $\mathrm{low[u]}$ 的定义稍作调整，定义为从 $u$ 子树内出发的所有返祖边能走到的时间戳最小点的时间戳与 $dfn_u$ 和 $dfn_{fa_u}$ 取 $\min$ 的结果，其中 $fa_u$ 表示 $u$ 在 DFS 树上的父亲，特别的如果 $u$ 是根则只与 $dfn_u$ 取 $\min$。而这样的定义下，割点判定定理依然成立。

每个连通块的问题是独立的，找到每个未被访问过的连通块运行 tarjan 算法找割点：

```cpp
for (int i = 1; i <= n; i++) {
  if (dfn[i]) continue;
  tarjan(i,i);
}
```

其中函数 `tarjan(x,root)` 表示考虑以 $root$ 为根建立 $root$ 所在连通块的 DFS 树，当前访问到了点 $x$。

具体实现：

```cpp
void tarjan(int x,int root) {
  dfn[x] = low[x] = ++ cnt; // 初始化时间戳与 low[x]。
  int cnt = 0; // 计算有多少个儿子 v 满足 low[v] >= dfn[x]。
  for (auto v : G[x]) {
    if (!dfn[v]) {
      tarjan(v,root); // 递归，按自底向上的顺序计算 low。
      low[x] = min(low[x],low[v]); // 转移 low。
      if (low[v] >= dfn[x]) ++ cnt; // 如果 low[v] >= dfn[x]，将 v 计入贡献。
    } else {
      low[x] = min(low[x],dfn[v]); 
      /* 转移所有从 x 出发的返祖边，注意这里遍历到的边有三类：
        1. x 到 x DFS 树上父亲的边
        2. 从 x 出发的返祖边
        3. x 子树内部到 x 的返祖边
        第三类边不会对 low[x] 产生贡献。
      */
    }
  }
  // 割点判定定理
  if (x == root) {
    if (cnt > 1) ans.push_back(x);
  } else {
    if (cnt > 0) ans.push_back(x);
  }
}
```

[P3388 【模板】割点（割顶），tarjan 求割点完整代码](https://www.luogu.com.cn/paste/m773icct)

---

## 作者：Atserckcn (赞：8)

## 割点

### 定义：

若一个点在图中被去掉后，图的连通块个数增加，那么这个点就被称为“割点”。如下图所示红点。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ewrbny1.png)

定义说白了就是若去掉一个点，图被“断开”的点称为割点。

### 朴素算法：

+ 枚举每个点 $u$。
+ 遍历图，如果有一个点或多个点遍历不到（遍历期间不能经过点 $u$），那么 $u$ 就是割点。

时间复杂度：$O(N^2)$。

可作为对拍暴力程序。

### 正解：Tarjan

定义一些东西：

1. 时间戳：dfs 时表示每个点被遍历到的“时间”，可用一个不断增加的变量实现。记为 $dfn$。
2. 搜索树：dfs 时由遍历到的边组成的树（由于有打标记，所以不会重复访问）。
3. 追溯值：以 $u$ 为根的子树中，所有不经过 $u$ 能够到达的节点的时间戳的最小值。记为 $low$。

#### 关于追溯值：

结合张图来理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/8i6hm9fg.png)

设红边为搜索树的边，则 $3$ 号点因为有蓝色的边不经过他的父亲 $2$ 号点，直接到达了 $1$ 号点，所以 $low_3=dfn_1$。

#### 回归 Tarjan

有一个重要的概念：

一个点 $u$ 如果是割点，那么它的子树中的一些节点 $v$ 的 $low_v$ 是大等于 $dfn_u$ 的，因为它到不了上面（上面的意思是搜索树中比 $u$ 更早遍历到的点集）。

显然，$low_u$ 表示假设断开点 $u$ 孩子们还能遍历到的最早时间戳。

若 $low_v\ge dfn_u$ （$v$ 是 $u$ 的孩子），即 $v$ 回不到 $u$ 前，那么就表示 $u$ 是割点。

有 $s$ 个这样的 $v$ 就代表断开 $u$ 可以把原先的连通图变成 $s+1$ 个连通块（$u$ 上方也是一个）。

#### 遍历路上

对于每个点 $u$，遍历到的儿子 $v$ 有两种可能：

1. $dfn_v=0$​ 

说明 $v$ 是新加入搜索树中的节点，那么就先递归下去，用 $low_v$ 更新 $low_u$。

即 $low_u=\min(low_u,low_v)$。

2.  $dfn_v\neq 0$

说明 $v$ 曾经被遍历过，是搜索树上 $u$ 的祖先，那么用 $dfn_v$ 更新 $low_u$。

即 $low_u=\min(low_u,dfn_v)$。

然而上述办法还是有 bug。想想在哪呢？

#### 发现 bug

假设我们搜索树从 $1$ 号点开始遍历，给张图你就懂。

![](https://cdn.luogu.com.cn/upload/image_hosting/iiyia1wq.png)

如图。

因为我们是从 $1$ 号点开始遍历的，$1$ 号点是搜索树的根，它哪来的祖先能让孩子们去更新追溯值啊！！！

而图中的 $1$ 号点又显然不是割点。

咋办呢？

#### 解决 bug

特判呗。反正根只有一个。

这时候我们得思考：什么样的情况下根是割点？

反正追溯值做不了了。

那么看看朴素的图吧。

![](https://cdn.luogu.com.cn/upload/image_hosting/8zpvm6ay.png)

图中 $1$ 号点就是割点。

为啥嘞？

答：因为把它删了后有两个连通块。

正解。

我们记录一下，如果它在搜索树上的儿子不止一个，那么它就是割点。

就这么简单？

就这么简单。

这时候不知道有没有同学有个疑惑和我初学时一样的，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vdoj1r24.png)

红色的是搜索树边。

图中 $1$ 不是割点啊，但它在树上还真有两个孩子啊？？

~~如果您一开始没看出来哪儿错了，就点个赞再走吧。~~

注意到边 $3\rightarrow 2$ 和 $1\rightarrow 2$。

当我们遍历到点 $3$ 的时候，它就会顺带把 $2$ 号点先遍历了。先遍历到 $2$ 再遍历 $3$ 同理。

所以说搜索树应该为：

![](https://cdn.luogu.com.cn/upload/image_hosting/hhyyg2br.png)

或：

![](https://cdn.luogu.com.cn/upload/image_hosting/pchtm8rz.png)

OK，下班，看题。

[洛谷 P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)。

题意很简略了。就是看看实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+5,M=1e5+5;
int n,m,ehead[N],cnt_e,low[N],dfn[N],idx,rt,cntans;
bool ans[N];//是否为割点
struct E{
	int to,pre;
}e[M<<1];
void adde(int from,int to)
{
	e[++cnt_e].to=to;
	e[cnt_e].pre=ehead[from];
	ehead[from]=cnt_e;
	return;
}
void dfs(int u)
{
	low[u]=dfn[u]=++idx;
	int chtree=0;//如果是根的话，它的孩子个数
	for(int i=ehead[u];i;i=e[i].pre)
	{
		int v=e[i].to;
		if(!dfn[v])//不在搜索树上
		{
			dfs(v);
			low[u]=min(low[u],low[v]);
			if(rt==u)++chtree;
			if(low[v]>=dfn[u]&&rt!=u&&(!ans[u]))//注意 (!ans[u])。搞不好会重复算 cntans
			{
				++cntans;
				ans[u]=1;
			}
		}
		else//返祖边
			low[u]=min(low[u],dfn[v]);
	}
	if(u==rt&&chtree>1&&(!ans[u]))
	{
		++cntans;
		ans[u]=1;
	}
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1,u,v;i<=m;++i)
	{
		cin>>u>>v;
		adde(u,v);adde(v,u);
	}
	for(int i=1;i<=n;++i)//图不保证联通
	{
		if(!dfn[i])
		{
			rt=i;
			dfs(i);
		}
	}
	cout<<cntans<<'\n';
	for(int i=1;i<=n;++i)
		if(ans[i])
			cout<<i<<' ';
	cout<<'\n';
	return 0;
}
```

### 闲话时间

讲个好玩的，这篇文章是我晚上十一点左右写的，但是：

![](https://cdn.luogu.com.cn/upload/image_hosting/r3z8y5au.png)

我来自报家门了。

正题。

Tarjan 算法不光能解决割点的问题，改一改还能当作强连通分量和割边（又称桥）和双连通分量等等。

说到强连通分量，推销一下我的[学习笔记](https://www.cnblogs.com/Atserckcn/p/18326076)不过分吧 qwq。

完结撒花。

---

## 作者：SrsgPrince_ (赞：6)

# P3388 【模板】割点（割顶） 题解

题目传送门：[P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)。

这道题是 Tarjan 的模板题，Tarjan 的用处很多，能解决强连通分量，双连通分量，割点与桥。在这题里，我们用 Tarjan 来求割点。虽然 Tarjan 的代码看上去比较简短，但是它的思维比较复杂（类似于树状数组的思维难度，甚至还多）。

首先来看题的要求：“给定无向图，求割点”。那么先来讲一下什么是无向图：图中的每条边都是无方向的，则称这个图为 **无向图**，这点非常简单。最重要的是割点。

如果从图中删除这个顶点以及其相关的边之后，图不再连通（即分为两个及以上不相连的子图），那么这个顶点就是图的 **割点**。如果一张图没有割点，那么就称这张图为 **点双连通图**，极大点双连通子图就被称为 **点双连通分量**。

按照 DFS 经过的边生成的树叫做 DFS 树，树上的边称为 **树边**，其余的边称为 **非树边**。

非树边里又有 **前向边**、**后向边** 和 **横叉边**。

1. 前向边：DFS 树上祖先指向子孙的边。
2. 后向边：DFS 树上子孙指向祖先的边。
3. 横叉边：非树边中不是前向和后向的边。即两颗不同子树的没有祖孙关系的点连的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/mpgmsa3c.png)

这个给出一张图，能够从割点的定义看出割点为 $1$ 和 $5$。

那么除了这种方法，还能怎么判定它呢，那么很自然地想到了 DFS（大法师）。首先，假设我们 DFS 从 $u$ 访问到了 $v$，那么 $u$ 就是 $v$ 的父顶点，反过来 $v$ 就是 $u$ 的孩子顶点。在访问 $u$ 前被访问过的，就是 $u$ 的祖先顶点。

如果顶点 $u$ 的所有孩子顶点可以不通过顶点 $u$ 访问到 $u$ 的祖先节点，那么此时去掉 $u$ 就不影响整张图的连通性，那么 $u$ 就不是割点。还是例如上图，用顶点 $2$ 和 $3$ 举例，顶点 $2$ 的祖先顶点是顶点 $1$，从 顶点 $3$ 走，不一定要走 $3-2-1$，也可以是 $3-4-1$，于是去掉顶点 $2$，不影响整张图的连通，便有顶点 $2$ 不是割点。相反的，如果顶点 $u$ 存在一个孩子顶点，必须通过父节点 $u$ 才能访问到 $u$ 的祖先节点，那么去掉点 $u$ 后，整张图不连通，那么 $u$ 是一个割点。这次我们拿顶点 $4$ 和 $1$ 举例，顶点 $1$ 的父顶点是顶点 $5$，从顶点 $4$ 到 $5$，必定要经过顶点 $1$，并且删掉顶点 $1$ 后，整张图不连通，那么顶点 $1$ 是一个割点。

原理搞懂之后，我们来看实现过程，我们需要开两个新数组 $dfn$ 和 $low$。这两个数组分别表示 DFS 访问到的顺序（也叫时间戳）以及经过至多一条非树边能到达的节点中最小的 DFS 序。因为在无向图里没有横叉边，而前向边对 $low$ 值没有影响，所以我们只用判反向边。

那么我们把上面的原理再表示一下。

当对于某个顶点 $u$，如果存在至少一个顶点 $v$（$u$ 的儿子），使得 $low_v \geq dfn_u$，即不能回到祖先，那么 $u$ 点为割点。那么怎么更新这个 $low$ 数组呢。首先在初始化的时候，我们先把每一个节点的 $low$ 值赋为其 $dfn$ 值，在后面的 DFS 中在进行更新。假设从顶点 $u$ 到 $v$。当顶点 $v$ 回溯到顶点 $u$ 的时候，如果发现 $dfn_v < low_u$，那么 $low_u = dfn_v$。那么这样 $low_u$ 就能表示经过至多一条非树边能到达的节点中最小的 DFS 序了。

![](https://cdn.luogu.com.cn/upload/image_hosting/63m0m2rs.png)

换一张图，拿这张举例吧。先 DFS 一遍，节点编号就是 $dfn$ 的值。接下来根据上面的思路来求出 $low$ 值。得到下面这张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/nmj3t76j.png)

根据顶点 $u$，使得 $low_v \geq dfn_u$，那么 $u$ 点为割点。我们能得到顶点 $3$，$4$ 和 $6$ 这三个点是割点，根据定义来看，都没问题。

对于这题来说，统计每一个点属于的点双连通分量的数量，如果一个点属于多个点双连通分量，那么它就是一个割点。

然后介绍一种常用的存图方式：链式前向星。

链式前向星与邻接矩阵和邻接表一样，也是主流的一种存图方式。它的整体结构很像邻接表，但是邻接表是线性结构，链式前向星是链式结构，实现方式不同，但是思想是一致的。

我们要用三个新的数组：

1. $head_b$ 表示以 $b$ 作为起点的第一条边的编号。
2. $nxt_{cnt}$ 表示编号为 $cnt$ 的边的下一条边。
3. $des_{cnt}$ （这个数组大部分人叫做 $to_{cnt}$）表示编号为 $cnt$ 的边的终点。

当新加入一条边 $b-e$ 时：

1. `++cnt` 表示这条边的编号。
2. `nxt[++cnt] = head[b]` 表示原来以 $b$ 作为起点的第一条边，作为该边的后续边。
3. `des[cnt] = e` 表示当前边的终点设置。

代码如下：

```cpp
inline void addEdge(int b, int e) {
    nxt[++cnt] = head[b];
    des[head[b] = cnt] = e; // 这里把 head[b] = cnt 和 des[cnt] = e 放在了一起，底下一样
    nxt[++cnt] = head[e];
    des[head[e] = cnt] = b;
}
```

遍历方法就是从 $head_u$ 开始找，一直找到末尾。

```cpp
for (int i = head[u]; i; i = nxt[i]) {
    int v = des[i];
    // ......
}
```

删除一条边 $u-vv$ 的做法：

```cpp
int last=0;
for (int i = head[u]; i; i = nxt[i]) {
    int v = to[i];
    if (v == vv) {
        if (i == head[u]) head[u] = nxt[i];
        else nxt[last] = nxt[i];
        break;
    }
    last = i;
}
```

那么我们可以通过之前的过程得出以下代码。

```cpp
int head[maxn], nxt[maxn<<1], des[maxn<<1], cnt = 1;
inline void addEdge(int b, int e) {
    nxt[++cnt] = head[b];
    des[head[b] = cnt] = e;
    nxt[++cnt] = head[e];
    des[head[e] = cnt] = b;
}
// 链式前向星加边
int dfn[maxn], low[maxn], st[maxn], top;
int tot, deg[maxn], ind;
vector<int> vdcc[maxn]; // 存储点双连通分量
inline void tarjan(int u, int lst) {
    low[u] = dfn[u] = ++tot;
    st[++top] = u; // 压进栈内
    for (int i = head[u]; i; i = nxt[i]) {
        if (i != (lst ^ 1)) {
            int v = des[i], vv;
            if (!dfn[v]) { // 如果没有被访问过
                tarjan(v, i);
                low[u] = min(low[u], low[v]);
                if (low[v] >= dfn[u]) { // 找到了新的割点
                    ++ind;
                    vdcc[ind].push_back(u);
                    ++deg[u];
                    // 加入深度最浅的点
                    do {
                        vv = st[top--];
                        vdcc[ind].push_back(vv);
                        ++deg[vv];
                    } while (vv != v);
                }
            } else {
                low[u] = min(low[u], dfn[v]);
            }
        }
    }
}
```


---

## 作者：Zpair (赞：5)

不是`tarjan`。

考虑割点的定义：去除当前点后图的连通性没有变化。

于是可以等价为：当前点所连的所有边割一个点也可以互相到达。

先将 dfs 树建出来，然后考虑返祖边带来的影响。

不难发现，一条返祖边可以让整条路径上的边都有了两条路径，

所以他们割一个点后仍然可以互相到达。

于是使用并查集维护即可。

如果你没有看懂，这里有一张 oi-wiki 偷过来的图，我会解释一下。

![](https://oi-wiki.org/graph/images/bcc-2.svg)

对于红色的返祖边，其路径上的黑边都有两条路径相互到达，即可以在割一个点后相互到达。

所以只需将蓝色边用并查集连起来即可，不难发现每条边只会被在合并时遍历一次，以及作为祖先总共遍历 $O(m)$ 次，所以时间复杂度为 $O((n+m) \alpha (n+m))$ 。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+5,M=1e5+5;
int head[N],to[M<<1],nxt[M<<1],op[M<<1],tot;
void add(int x,int y){to[++tot]=y,nxt[tot]=head[x],head[x]=tot;}
int dep[N],fa[N];bool vis[N];
int f[N],siz[N],mn[N];
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
#define top(x) (mn[find(x)])
void merge(int x,int y){
	x=find(x),y=find(y);
	if(siz[x]<siz[y])swap(x,y);
	siz[x]+=siz[y],f[y]=x;
	if(dep[mn[x]]>dep[mn[y]])
		mn[x]=mn[y];
}
void dfs(int p){
	vis[p]=1;
	for(int i=head[p];i;i=nxt[i]){
		int t=to[i];if(t==fa[p])continue;
		if(vis[t])for(int x=top(p);dep[fa[x]]>dep[t];merge(x,fa[x]),x=top(x));
		else dep[t]=dep[p]+1,fa[t]=p,f[t]=t,siz[t]=1,mn[t]=t,op[i]=1,dfs(t);
	}
}
bool check(int p){
	int tf=find(p);
	for(int i=head[p];i;i=nxt[i])
		if(op[i]==1){
			int t=find(to[i]);
			if(!tf)tf=t;
			else if(tf!=t)return true;
		}
	return false;
}
int n,m;
int main(){
	cin>>n>>m;int x,y;
	for(int i=1;i<=m;++i){
		scanf("%d%d",&x,&y);
		if(x!=y)add(x,y),add(y,x);
	}
	for(int i=1;i<=n;++i)
		if(!vis[i])dfs(i);
	int ans=0;
	for(int i=1;i<=n;++i)
		if(check(i))ans++;
	cout<<ans<<endl;
	for(int i=1;i<=n;++i)
		if(check(i))printf("%d ",i);
}
```

以及一些小的拓展。

割边：不难发现返祖边路径上的边都不是割边，于是直接树上差分即可。也可以考虑使用并查集把点连在一起并判断边的端点是否属于同一个并查集，但是这样时间不优。

广义圆方树：考虑在点双时使用的并查集的实际意义，不难发现在同一个点双的点其边形成一个连通块。于是可以将每个连通块的祖先映射成一个方点，然后连边。

因为是割点模板题就不放代码了。

---

## 作者：easy42 (赞：3)

### 算法介绍

Tarjan 算法，这里用来解决割点问题，时间复杂度为 $O(n+m)$。

割点的简要定义是：去掉割点及其所连的边，该图分为两个及以上的连通分量。

接下来讲的是定义与约定。

$dfn_i$：称为“时间戳”标记，使用 dfs 第一次遍历到的次序。

搜索树：$n$ 个点，$n-1$ 条边搜索生成的树。

$low_i$：称为“追溯值”，表示的是第 $i$ 个点不走其父亲的边可以到达的时间戳的最小值。

考虑 $low_i$ 的计算方法：

- 自己肯定可达，即 $low_i=dfn_i$。
- 若 $j$ 为 $i$ 在生成树上的子节点，则取 $low_i=\min(low_i,low_j)$。
- 若 $j$ 到 $i$ 为非树边，则根据定义，$low_i=\min(low_i,dfn_j)$。

更新 $low$ 的伪代码如下：

```
if y is x's son
  low_x=min(low_x,low_y)
else
  low_x=min(low_x,dfn_y)
```

如何求割点？

tarjan 算法：
1. 若 $x$ 不为根节点，且 $dfn_x \le low_y$，则 $x$ 为割点。

由定义知，即不能回到祖先，那么 $x$ 点是割点。

我们发现，此方法无法用于判断根节点，于是有下面的方法。

2. 若 $x$ 为根节点，且 $x$ 有两颗以上的子树，则 $x$ 为割点。

非常明显，删去后，整张图就分裂了。

### 正确性证明

对于第一种割点，我们假设遍历到了 $x$，$dfn_x \le low_y$ 表示着表示儿子 $y$ 点回溯可到达的最先点的时间戳大于等于 $x$ 的时间戳，所以 $y$ 点不能通过 $x$ 点与其他已遍历点相邻，即分裂了。

对于第二种割点，两个儿子必定要通过祖先连接，所以成立。
### 代码实现

这里也应该讲解一下。

1. $dfn$ 和 $low$ 数组初始全为 $0$，这点其实也起到标记的作用。
2. 在遇到没有访问过的节点时，要继续向下搜索。
3. 每个点都有可能是根节点，因为图不连通。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,cnt,p;
vector<int>v[100005];
int dfn[100005],low[100005];
bool ans[100005];
void tarjan(int x,bool root){
	int p=0;
	dfn[x]=low[x]=++cnt;
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i];
		if(!dfn[y]){
			tarjan(y,0);
			low[x]=min(low[x],low[y]);
			if(low[y]>=dfn[x]&&!root) ans[x]=1;
			if(root) p++;
		}
		else{
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(root&&p>=2) ans[x]=1;
	return;	
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,vv;
		cin>>u>>vv;
		v[u].push_back(vv);
		v[vv].push_back(u);
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i]) tarjan(i,i);
	}
	int h=0;
	for(int i=1;i<=n;i++){
		if(ans[i]) h++;
	}
	cout<<h<<endl;
	for(int i=1;i<=n;i++){
		if(ans[i]) cout<<i<<" ";
	}
	return 0;
}
```

---


# [ZJOI2007] 棋盘制作

## 题目描述

国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。

而我们的主人公 `小Q`，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友 `小W` 决定将棋盘扩大以适应他们的新规则。

`小Q` 找到了一张由 $N \times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。`小Q` 想在这种纸中裁剪一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。

不过 `小Q` 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。

于是 `小Q` 找到了即将参加全国信息学竞赛的你，你能帮助他么？

## 说明/提示

对于 $20\%$ 的数据，$N, M ≤ 80$

对于 $40\%$ 的数据，$N, M ≤ 400$

对于 $100\%$ 的数据，$N, M ≤ 2000$

## 样例 #1

### 输入

```
3 3
1 0 1
0 1 0
1 0 0
```

### 输出

```
4
6
```

# 题解

## 作者：顾z (赞：309)


# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述-->[p1169 棋盘制作](https://www.luogu.org/problemnew/show/P1169)

## 题目大意

　给定一个01棋盘,求其中01交错的最大正方形与矩形。

## 解题思路:

　动态规划－－－悬线法

以下内容部分参考[@Clove_unique](https://blog.csdn.net/Clove_unique/article/details/50512624)

## 悬线法

### 用途:

　　解决给定矩阵中满足条件的最大子矩阵
   
### 做法:

　　用一条线(横竖貌似都行)左右移动直到不满足约束条件或者到达边界
  
### 定义几个东西:

　　$left[i][j]$:代表从$(i,j)$能到达的**最左位置**
   
　　$right[i][j]$:代表从$(i,j)$能到达的**最右位置**
   
　　$up[i][j]$:代表从$(i,j)$向上扩展最长长度.
   
### 递推公式：
    
   $$left[i][j]=max(left[i][j],left[i-1][j]$$
   
   $$right[i][j]=min(right[i][j],right[i-1][j]$$
   
### 至于为什么递推公式中考虑上一层的情况？

　　是因为up数组的定义,up数组代表**向上扩展**最长长度,
所以需要考虑上一层的情况.

### 解决

　　求解正方形&&长方形的情况即可。

**题目要求01交错,所以"!="即可**

-------------------代码-------------------

```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
#define maxn 2001
using namespace std;
IL void read(int &x){
	int f=1;x=0;char s=getchar();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int res[maxn][maxn],left[maxn][maxn],right[maxn][maxn],up[maxn][maxn];
int n,m,ans1,ans2;
int main()
{
	read(n),read(m);
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=m;j++)
			{
				read(res[i][j]);
				left[i][j]=right[i][j]=j;
				up[i][j]=1;
			}
	for(RI i=1;i<=n;i++)
		for(RI j=2;j<=m;j++)
			if(res[i][j]!=res[i][j-1])
				left[i][j]=left[i][j-1];//预处理左边界
	for(RI i=1;i<=n;i++)
		for(RI j=m-1;j>0;j--)
			if(res[i][j]!=res[i][j+1])
				right[i][j]=right[i][j+1];//预处理右边界
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=m;j++)
			{
				if(i>1&&res[i][j]!=res[i-1][j])
				{
					left[i][j]=max(left[i][j],left[i-1][j]);
					right[i][j]=min(right[i][j],right[i-1][j]);
					up[i][j]=up[i-1][j]+1;
				}
				int a=right[i][j]-left[i][j]+1;	//横向长度
				int b=min(a,up[i][j]);//竖向长度
				//printf("a:%d b:%d\n",a,b);
				ans1=max(ans1,b*b);//正方形
				ans2=max(ans2,a*up[i][j]);//长方形
			}
	printf("%d\n%d",ans1,ans2);
}
```

悬线法题目:[P1169 棋盘制作](https://www.luogu.org/problemnew/show/P1169)   [p4147 玉蟾宫](https://www.luogu.org/problemnew/show/P4147)   [p2701 巨大的牛棚](https://www.luogu.org/problemnew/show/P2701)   [p1387 最大正方形](https://www.luogu.org/problemnew/show/P1387)

## UPD

2018.09.26

### Q ：如图这种情况下,我们根据状态转移方程求出的是黑色部分的面积.而实际上我们更大的面积为红色部分,这样的话,悬线法不就错了?

(如果你也有这方面的疑惑,请细读下面的话)

![](https://i.loli.net/2018/09/26/5bab89cbcd43c.png)

### A：红色部分会被考虑到.

考虑我们代码中的这一部分

```cpp
if(i>1&&res[i][j]!=res[i-1][j])
{
	left[i][j]=max(left[i][j],left[i-1][j]);
	right[i][j]=min(right[i][j],right[i-1][j]);
	up[i][j]=up[i-1][j]+1;
}
```

**if语句执行的条件是$res[i][j]!=res[i-1][j]$**,即**只有满足条件的情况下我们才能更改当前位置$(i,j)$的$left$数组与$right$数组.**

而**不满足条件时,我们当前位置$(i,j)$的$left,right,up$数组并不会改变.**

所以说当再次进行状态转移的时候,我们又能根据图中这些未被更新的点(即蓝色部分)的数组去求解出红色部分的面积.

![](https://i.loli.net/2018/09/26/5bab8b760377f.png)

还有一点需要注意的是,**在某一行的一段的合法序列中,他们的$left$数组与$right$数组所指位置相同**.(这个根据状态转移方程应该不难理解.

例如这样,这**一段合法序列中位置的$left[i][j]$所指位置皆为红色部分,$right[i][j]$所指位置皆为蓝色部分**.

![](https://i.loli.net/2018/09/26/5bab8cf948b2b.png)

如果不能理解的话可以私信问我的 qwq.

~~已经尽力写的很详细啦~~

---

## 作者：Felis (赞：76)

## 0.我为什么要写这个题解
因为其他人的题解我看不懂
## 1.正文
### 1.1 选择方法
这道题是求一个符合条件的最大子矩阵，并且限制条件比较毒瘤。所以我们选择悬线法。**悬线法适合解决求一个限制条件较多的最大子矩阵问题。**

### 1.2 讲（xia）解（che）
#### 1.2.1 何为悬线法
悬线的定义是这样的：

**从每一个点向上走，知道遇到障碍点或顶边界。**

那么我们可以轻松地得到悬线的一些性质：
1. 每一个点对应一根悬线
1. 每一根悬线都对应了一个高度等于悬线高度，宽度大于0的矩形

所以悬线法的步骤就是：**找出每一个点对应的悬线的高度，然后向左右分别找出该悬线能拓展出的矩形的宽度。**

#### 1.2.2
悬线法的步骤：

1.定义一个up[i][j]数组,up[i][j]表示（i，j）**对应的悬线**的长度，那么很明显：
```cpp
	if(check()==true)
            up[i][j]=up[i-1][j]+1;
        else
   	    up[i][j]=1;//可能是0，根据具体题目，本题因为如果上下两个点相同时也可以取（i，j）一个点作为悬线，所以初值为1
```
2.

定义一个left[i][j]数组，表示（i,j)**对应的悬线**向左的最大宽度，同理，定义一个right数组。可以得到
```
	if(check()==true)
            left[i][j]=max(left[i-1][j],left[i][j]),
            right[i][j]=min(right[i-1][j],right[i][j]);
```
那么，left，right的初值就应该是（i，j）这个**点**向左的最大宽度。

#### 1.2.3 为什么悬线法是正确的

木桶原理：一个木桶装水的体积是由它最短木板的长度决定的。那么同理，从一个图形中国找矩形也一定是由它的最短悬线确定。那么那个最大的矩形也应该是有一根悬线确定的，所以我们找到了这根悬线，我们就可以求出最大面积。而悬线与点一一对应，所以只要我们枚举了所有的点，就可以保证找到确定最大矩形的悬线。

### 1.3 代码实现
```cpp
#include<cstdio>
#define N 2005
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
using namespace std;
int up[N][N],left[N][N],right[N][N],ansa,ansb,a[N][N],m,n;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            up[i][j]=1,left[i][j]=j,right[i][j]=j,scanf("%d",&a[i][j]);// up 初值，读入，left/right 最初值
            
    for(int i=1;i<=n;i++)
        for(int j=2;j<=m;j++)
            if(a[i][j]^a[i][j-1])
                left[i][j]=left[i][j-1];
    for(int i=1;i<=n;i++)
        for(int j=m;j>1;j--)
            if(a[i][j]^a[i][j-1])
                right[i][j-1]=right[i][j];//left/right初值，即（i，j）点向左/右的最大宽度
                
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(i>1&&a[i][j]^a[i-1][j])
                up[i][j]=up[i-1][j]+1,left[i][j]=max(left[i][j],left[i-1][j]),right[i][j]=min(right[i][j],right[i-1][j]);
            int a=right[i][j]-left[i][j]+1;
            int b=min(a,up[i][j]);
            ansa=max(ansa,b*b);
            ansb=max(ansb,a*up[i][j]);
        }
    printf("%d\n%d",ansa,ansb);
} 
```
 代码中有几点值得注意
 1. c++iostream中有一个left函数，所以请不要引用bits/stdc++.h或iostream
 1. 求正方形的面积就是长方形较短边长的平方
 ## 2.结语
 没有结语（逃

---

## 作者：lzoi_lhy (赞：54)

我是一个既没想到dp又没想到根据坐标奇偶性取反的脑回路有些奇怪的蒟蒻

个人脑洞：

从第一行到第n行扫一遍，维护h数组表示从当前格子往上能延伸到的黑白相间的线段（有一条边长为1的矩形）的最长长度

我们可将当前行分为若干条线段，满足每条线段是最长的黑白相间的线段（不能再向左右延伸）

对于每条线段，结合h数组，我们不难发现我们得到了一排高矮不一的长条状的矩形

是不是很熟悉？用单调栈扫一遍即可

如果遇到颜色与上一个相同的格子，就把整个栈弹出来

注意正方形可以在数矩形的时候顺便数出来

```
#include<cstdio>
#include<iostream>
#include<cstring>
#define X (h[stack[top]])//矩形的宽 
#define Y (cur-stack[top-1]-1)//矩形的长 
#define Z (min(X,Y))//正方形的边长 
using namespace std;
int n,m,top,cur,ans1,ans2,stack[2010],map[2010][2010],h[2010];
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;++i)
		for (int j=1;j<=m;++j) scanf("%d",&map[i][j]);
	for (int j=1;j<=n;++j){
		for (int i=1;i<=m;++i)
			if (j>1&&map[j][i]!=map[j-1][i]) ++h[i];
			else h[i]=1;
		cur=1;
		while (cur<=m){
			stack[0]=cur-1;stack[top=1]=cur++;
			while (cur<=m&&(map[j][cur]!=map[j][cur-1])){
				while (top&&h[stack[top]]>h[cur])
					ans1=max(ans1,Z*Z),ans2=max(ans2,X*Y),--top;
				stack[++top]=cur++;
			}
			while (top) ans1=max(ans1,Z*Z),ans2=max(ans2,X*Y),--top;
		}
	}
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
```

---

## 作者：过往梦魇之殇 (赞：35)

# Luogu P1169 ZJOI2007 棋盘制作 题解

↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

~~（上面为废话，勿喷$QwQ$,下面为正文）~~


解题思路：

　　这道题目主要是运用了一个叫做悬线法的方法来求极大矩阵的。

　　所谓悬线法：就是维护三个数组：$up[ ][ ], left_[ ][ ], right_[ ][ ].$ 分别表示点（$i$，$j$） 向上方，左方，右方走能走的最远距离。

　　维护方法运用了一些$dp$思维：

	up[i][j] = up[i - 1][j] + 1;
	left_[i][j] = min(left_[i - 1][j], j - lz);    //lz表示左边最近的障碍
	right_[i][j] = min(right_[i - 1][j], rz - j);  //rz表示右边最近的障碍
　　还要注意初始化要让第0行的元素为正无穷，防止其对答案造成干扰。

　　当遇到障碍点时，应先更新最近障碍位置，然后将该点的$left$_, $right$_值赋成正无穷。原因同上。

　　为了方便维护$lz$,$rz$的值，我跑了两边双重循环。。。 （复杂度依然$O(nm)$ )

　　然后可以分别将$0$，$1$当作障碍各求一个解，输出最大值。
  
  
~~(粗略讲一讲，不清楚の去看看其他神犇的题解)~~

# 下面放一下我的丑陋的代码$QAQ$.

几点提醒：

$1$:勿喷。。。

$2$: 勿抄袭。。。

$3$:。。。


$AC$  $Code:$
------------

```cpp
#include<bits/stdc++.h>
/*#include<抄者WA，通过（题解）者AC！>*/
#define re register
#define pi acos(-1.0)
#define inf 99999999
using namespace std;
const int MAXN = 2010;
short ma[MAXN][MAXN];
int n,m,lz,rz,ans,bns,up[MAXN][MAXN],left_[MAXN][MAXN],right_[MAXN][MAXN];
inline int read()//快读
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
inline void write(int X)//快输出
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
void color_(int c)
{
    memset(up,0,sizeof(up));
    memset(left_,0,sizeof(left_));
    memset(right_,0,sizeof(right_));
    for(re int i=1;i<=m;i++){
    	left_[0][i]=inf,
        right_[0][i]=inf;
	}
    for(re int i=1;i<=n;i++){
        lz=0;
        for (re int j=1;j<=m;j++){
        	if(ma[i][j]!=c) 
            {
                lz=j;
                left_[i][j]=inf;
                continue;
            }
            else
            {
                up[i][j]=up[i-1][j]+1;
                left_[i][j]=min(left_[i-1][j],j-lz);
            }  
		}     
    }
    for(re int i=1;i<=n;i++){
        rz=m+1;
        for(re int j=m;j>=1;j--){
        	if(ma[i][j]!=c){
                rz=j;    
                right_[i][j]=inf;
                continue;
            }
            else{
            	right_[i][j]=min(right_[i-1][j],rz-j);
			}
		} 
    } 
    for(re int i=1;i<=n;i++){
        for(re int j=1;j<=m;j++){
            ans=max(ans,up[i][j]*(left_[i][j]+right_[i][j]-1));
            bns=max(bns,min(up[i][j],(left_[i][j]+right_[i][j]-1))*min(up[i][j],(left_[i][j]+right_[i][j]-1)));
        }
    }
}
int main()//不懂的，看看就懂了T_T
{
    n=read();
    m=read();
    for(re int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){
            ma[i][j]=read();
            if((i+j)&1){
            	ma[i][j]=abs(ma[i][j]-1);
			}
        }
	}  
    ans=bns=-1;
    color_(1);
    color_(0);
    write(bns);
    printf("\n");
    write(ans);
    printf("\n");
    return 0;
}
```

~~求通过加赞呀$awa$~~

通过的管理员爆切猪国杀！！！

点赞的$Oier$们早日上紫名！！！

# $End.$

######   ~~总算水完了~~

---

## 作者：George1123 (赞：19)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P1169 【\[ZJOI2007\]棋盘制作】](https://www.luogu.org/problem/P1169)

### 此题算法:纯粹のdp

大致思路(★个人独创，方法很难，不懂勿喷):

>1.$dp[i][j]$是$(point)$类型的数组(如下)，$dp[i][j]$表示以$(i,j)$为右下角的最大棋盘的长度和宽度($x$和$y$)。

```cpp
struct point{
	int x,y;
	int siz(){//大小
		return x*y;
	} bool squre(){//是否为正方形
		return (x==y);
	}
}dp[N][N];
```
>2.$ $边界初始化。其中$getmax()$函数可随时更新答案(最大长方形、正方形棋盘的大小)。

```cpp
dp[1][1]=(point){1,1};
	getmax(1,1);
	for(int i=2;i<=n;i++){
		if(g[i][1]==g[i-1][1])
			dp[i][1]=(point){1,1};
		else dp[i][1]=(point){
			dp[i-1][1].x+1,1
		}; getmax(i,1);
	} for(int i=2;i<=m;i++){
		if(g[1][i]==g[1][i-1])
			dp[1][i]=(point){1,1};
		else dp[1][i]=(point){
			1,dp[1][i-1].y+1
		}; getmax(1,i);
	}
```

![](https://s2.ax1x.com/2019/10/14/KSSUBV.jpg)


>3.$ $若$(i,j)$颜色与上面左边都不同，分以下四类情况讨论:

![](https://s2.ax1x.com/2019/10/14/KSP9vd.jpg)

>①、②、③:

```cpp
dp[i][j]=(point){dp[i-1][j].x+1,dp[i][j-1].y+1};
```


>④:

```cpp
point tmp1,tmp2;
tmp1=(point)
{dp[i-1][j].x+1,dp[i-1][j].y};
tmp2=(point)
{dp[i][j-1].x,dp[i][j-1].y+1};
if(tmp1.siz()>tmp2.siz())
	dp[i][j]=tmp1;
else dp[i][j]=tmp2;

```
>说简单点，就是与之前的棋盘融为一体并最大




>4.$ $若$(i,j)$的颜色与上面和左边都相同，$dp[i][j]=(1,1)$。若颜色与上面相同，$dp[i][j]=(1,$左边棋盘宽度度$+1)$，颜色与左边相同同理。

## 以下是代码+注释


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2010;
struct point{
	int x,y;
	int siz(){//大小
		return x*y;
	} bool squre(){//是否为正方形
		return (x==y);
	}
}dp[N][N];
int n,m,ans1,ans2; //ans1为最大正方形面积，ans2为最大长方形面积
bool g[N][N];
void getmax(int i,int j){ //随时更新答案
	ans2=max(ans2,dp[i][j].siz());
	if(dp[i][j].squre())
		ans1=max(ans1,dp[i][j].siz());
} int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&g[i][j]); //g[][]数组存颜色
	dp[1][1]=(point){1,1}; //左上角初始化
	getmax(1,1);
	for(int i=2;i<=n;i++){
		if(g[i][1]==g[i-1][1])
			dp[i][1]=(point){1,1};
		else dp[i][1]=(point){
			dp[i-1][1].x+1,1
		}; getmax(i,1); //左边初始化
	} for(int i=2;i<=m;i++){
		if(g[1][i]==g[1][i-1])
			dp[1][i]=(point){1,1};
		else dp[1][i]=(point){
			1,dp[1][i-1].y+1
		}; getmax(1,i); //上面初始化
	} for(int i=2;i<=n;i++){
		for(int j=2;j<=m;j++){
			if(g[i][j]==g[i-1][j]){
				if(g[i][j]==g[i][j-1])
					dp[i][j]=(point){1,1}; //如果与上面左边颜色相同
				else dp[i][j]=(point) //如果只与上面颜色相同
					{1,dp[i][j-1].y+1};
			} else {
				if(g[i][j]==g[i][j-1])
					dp[i][j]=(point)
					{dp[i-1][j].x+1,1}; //如果只与左边颜色相同
				else if(dp[i][j-1].x<dp[i-1][j].x+1  //如果与上面左边颜色都不同
				&&dp[i-1][j].y<dp[i][j-1].y+1){
					point tmp1,tmp2;  //如果是④情况
					tmp1=(point)
					{dp[i-1][j].x+1,dp[i-1][j].y};
					tmp2=(point)
					{dp[i][j-1].x,dp[i][j-1].y+1};
					if(tmp1.siz()>tmp2.siz())
						dp[i][j]=tmp1;
					else dp[i][j]=tmp2;
				} else { //如果是①②③情况
					dp[i][j]=(point){dp[i-1]
					[j].x+1,dp[i][j-1].y+1};
				}
			} getmax(i,j); //随时更新答案
		}
	} printf("%d\n%d\n",ans1,ans2); //AC了，没必要怀疑算法正确性
	return 0;
}

```

调了半个上午，这么难的思路不是一下子想出来的，要循序渐进。

大分类中小分类的递归思想帮助你慢慢做出更Van♂的题

谢谢大家! !


---

## 作者：ｃｈｉｌｌ (赞：17)

这道题目其实就是P2701巨大的牛棚与P4147玉蟾宫的合并。

P2701求的是可以覆盖的最大正方形，

而P4171求的则是可以覆盖的最大矩形。

首先考虑把黑白相间的棋盘转换成同一个颜色，方便之后的操作。可以通过行标与列标之和的奇偶判断是否应该染上相反的颜色。需要注意的是染完色后应该再将整个矩形都染上相反的颜色，重新进行后面的操作。

### 求最大正方形: 

_f[i][j]_ 表示右下角坐标为 _(i,j)_ 的正方形的最大边长。不难发现 _f[i][j]_ 与它周围的 _f[i-1][j-1],f[i-1][j],f[i][j-1]_ 有关系。于是得出

#### f[i][j]=max{f[i-1][j-1],f[i-1][j],f[i][j-1]}+1

### 求最大矩形：（借鉴了P4147题解中XG_Zepto的思路）

建立 _l[i][j],r[i][j]_ 储存坐标 _(i,j)_ 左右最近的障碍位置

建立 _L[i][j],R[i][j]_ 储存坐标 _(i,j)_ 在矩形内左右最远可以取到的位置

建立 _H[i][j]_ 储存坐标 _(i,j)_ 所在矩形的高度

坐标 _(i,j)_ 所在矩形面积为 _h[i][j]*(R[i][j]-L[i][j]-1)
_ 

### 附上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,tmp,ans1,ans2;
int f[1001][1001],a[1001][1001],l[1001][1001],r[1001][1001],L[1001][1001],R[1001][1001],h[1001][1001];
char ch;

void work()
{
    for (int i=1;i<=n;i++) 
        for (int j=1;j<=m;j++)
            f[i][j]=l[i][j]=r[i][j]=L[i][j]=R[i][j]=h[i][j]=0;//初始化
    for (int i=1;i<=n;i++)
        {
            tmp=0;
            for (int j=1;j<=m;j++)//计算左边最近障碍位置
                if (a[i][j]) l[i][j]=tmp;
                	    else tmp=j,L[i][j]=0;
            tmp=m+1;
            for (int j=m;j>=1;j--)//计算右边最近障碍位置
                if (a[i][j]) r[i][j]=tmp;
                   		else tmp=j,R[i][j]=m+1;
        }
    for (int i=1;i<=m;i++) R[0][i]=m+1;//细节需留意
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            if (a[i][j])
                {
                    f[i][j]=min(f[i-1][j-1],min(f[i-1][j],f[i][j-1]))+1;//计算当前正方形边长
                    h[i][j]=h[i-1][j]+1;//当前矩形高度+1
                    L[i][j]=max(L[i-1][j],l[i][j]);//计算当前矩形最左遇到的障碍
                    R[i][j]=min(R[i-1][j],r[i][j]);//计算当前矩形最右遇到的障碍
                    ans1=max(ans1,f[i][j]*f[i][j]);//求正方形面积最大值
                    ans2=max(ans2,h[i][j]*(R[i][j]-L[i][j]-1));//求矩形面积最大值
                }
}

int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            {
                cin>>a[i][j];
                if ((i+j)%2!=1) a[i][j]=1-a[i][j];//在相应位置染上相反色
            }
    work();
    for (int i=1;i<=n;i++)//重新染色
        for (int j=1;j<=m;j++)
            a[i][j]=1-a[i][j];
    work();
    cout<<ans1<<endl<<ans2<<endl;
    return 0;
}
```



---

## 作者：Seg_Tree (赞：12)

# 单调栈题解

本题解主要讲述**在这道题中较少出现的**,并且是**易于理解的**单调栈原理,以及该板子在该题中的适配情况,~~以及压行技巧~~.

**1. 有关单调栈求最大子矩阵**

注:

a[ ]表示输入的矩阵,用了滚动数组

h[ ]表示该点能向上延伸多少

t[ ]是h[ ]的备份数组,因为我们需要在处理时改变数组

优点:空间要求小,在很多时候你甚至不用存下这个矩阵,因为我们是一行一行处理的.

单调栈求最大子矩阵主要分为两个阶段:预处理,求解. ~~怎么感觉跟没说一样~~

I.预处理:

这个阶段还是较好理解的.对于读入的一行数据,我们对每个数据进行分析,如果它符合要求,那么**该点能向上延伸的点数就是(上一行的这个数据+1)**,若不符合则为0.

预处理完成的一行大概长这个样子:
| 1 | 3 | 0 | 2 | 4 | 2 | 3 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |

它表示了这个意思:

![(红色的为可选区域)](https://cdn.luogu.com.cn/upload/image_hosting/hpn9rbhg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

代码实现大概是这样:

```cpp
for(j=0; j<m; j++){
	cin>>a[j];
	if(a[j]满足条件)t[j]=h[j]=h[j]+1;
	else t[j]=h[j]=0;
}
```


现在看着这一行的数据基本能轻易地看出以该行为底的最大矩形面积为8.接下来我们所有的努力都是让计算机也能看出这一点.

II.求解:

先上极丑的,已压过行的代码:

```cpp
for(j=0; j<=m; j++){
	int tmp=j;
	while(top && t[sta[top]]>t[j])
		ans=max(ans,(j-(tmp=sta[top]))*t[sta[top]]),top--;
	t[sta[++top]=tmp]=t[j];
}
```
(t[ ]为h[ ]的备份数组)

我们在飞快地转动我们的小脑筋之后,发现对于任意一个**可能是最大矩阵的矩阵**,他一定满足其**左右两边一定无法以原有的高度继续延伸.**

因此,我们的**可能是最大矩阵的矩阵**一定满足这样的结构:

![](https://cdn.luogu.com.cn/upload/image_hosting/76gdlo6o.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

即**矩阵外左端第一个元素**小于**左端元素**,**矩阵外右端第一个元素**小于**右端元素**.


于是,我们可以开辟一个储存元素下标的,并且储存的下标对应的元素的值**单调递增**的单调栈,对于每一个想要入栈的元素,如果它能入栈,那就入栈.如果不能入栈,那说明我们已经找到了一个"矩阵外右端第一个元素"

接下来,我们就计算一下我们已找到的这个矩阵的面积大小.计算方法是:

$$(j-(sta[top]))*h[sta[top]]$$

还是拿原来那个例子解释一下这个式子

![(红色的为可选区域)](https://cdn.luogu.com.cn/upload/image_hosting/hpn9rbhg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

假设我们现在已经跑完了第五列,正在跑第六列,当前栈内元素为3,4,5,栈内元素对应的值为0,2,4.我们根据这个式子,计算的是只有第五列的矩阵的面积,得到的答案为4.

然后,我们再将元素'5'退栈,接下来发现我们剩下的元素'4'是不用退栈的.

于是我们跳出循环,将最后一次退栈的数据(5)入栈,并把它对应的值改为这次我们跑到的值.因为只有使用了这个值,作为当前的栈顶,它才能在我们当前的栈中畅通无阻.

建议将这张图剩下的点在自己的脑海中跑一遍,以理清思路.~~才不是我懒~~

此外,j多遍历一位是因为我将t[m]设置为了-1,以便在最后使所有元素出栈.

**2.有关压行**

只关注OI的同志们可以绕过这一段,毕竟这玩意儿真的没用,只能满足一些特殊人群的奇怪需求.

先上代码:
```cpp
for(j=0; j<=m; j++){
	int tmp=j;
	while(top && t[sta[top]]>t[j])
		ans=max(ans,(j-(tmp=sta[top]))*t[sta[top]]),top--;
	t[sta[++top]=tmp]=t[j];
}
```
我们先定义一个tmp变量储存当前跑到的点.如果当前点可以直接入栈,那么在sta[++top]=tmp这一语句中tmp可被忽略.如果不可以,那么tmp也可以被当成最后一次退栈的元素来入栈.

**3.有关单调栈在此题的适配**

我们可以发现,在此题中,一个点是否能取取决于该点与相邻点情况,因此我们可以这么写:
```cpp
for(j=0; j<m; j++){
	cin>>a[i][j];
	if(!i || a[i][j]^a[i-1][j])t1[j]=t[j]=h[j]=h[j]+1;
	else t1[j]=t[j]=h[j]=1;
}
t[m]=-1;top=0;
for(j=0; j<=m; j++){
	int tmp=j;flg=0;
	if(j && !(a[i][j]^a[i][j-1]))flg=1;
	while(top && ((t[sta[top]]>t[j]) || flg))
		ans=max(ans,(j-(tmp=sta[top]))*t[sta[top]]),top--;
	t[sta[++top]=(flg?j:tmp)]=t[j];
}
```
竖向预处理时以是否不同作为判断,横向判断时加一个是否相同的判断即可.

然后...有关正方形,我们可以这么判断:
```cpp
t1[m]=-1;top=0;
	for(j=0; j<=m; j++){
	int tmp=j;flg=0;
	if(j && !(a[i][j]^a[i][j-1]))flg=1;
	while(top && ((t[sta[top]]>t[j]) || flg))
		ans1=max(ans1,p2(min((j-(tmp=sta[top])),t[sta[top]]))),top--;
	t[sta[++top]=(flg?j:tmp)]=t[j];
}
```
即,在横向判断时再判断一下正方形

具体自己理解一下吧.

附AC代码:
```cpp
#include<iostream>
using namespace std;
bool a[2000][2000];
int h[2000],t[2000],t1[2000];
int sta[2000],top;
inline int p2(int in){return in*in;}
int main(){
	int n,m,i,j,ans=0,ans1=0;
	bool flg;
	cin>>n>>m;
	for(i=0; i<n; i++){
		for(j=0; j<m; j++){
			cin>>a[i][j];
			if(!i || a[i][j]^a[i-1][j])t1[j]=t[j]=h[j]=h[j]+1;
			else t1[j]=t[j]=h[j]=1;
		}
		t[m]=-1;top=0;
		for(j=0; j<=m; j++){
			int tmp=j;flg=0;
			if(j && !(a[i][j]^a[i][j-1]))flg=1;
			while(top && ((t[sta[top]]>t[j]) || flg))
				ans=max(ans,(j-(tmp=sta[top]))*t[sta[top]]),top--;
			t[sta[++top]=(flg?j:tmp)]=t[j];
		}
		t1[m]=-1;top=0;
		for(j=0; j<=m; j++){
			int tmp=j;flg=0;
			if(j && !(a[i][j]^a[i][j-1]))flg=1;
			while(top && ((t[sta[top]]>t[j]) || flg))
				ans1=max(ans1,p2(min((j-(tmp=sta[top])),t[sta[top]]))),top--;
			t[sta[++top]=(flg?j:tmp)]=t[j];
		}
	}
	cout<<ans1<<endl<<ans;
	return 0;
}
```


---

## 作者：plane (赞：11)

首先把矩阵转化一下，把横纵坐标和为偶数点的值取反，这样就转化成求最大的'0'或'1'矩阵。


我们只讨论对于0的求法，对1类似。


首先是最大正方形问题，这是一个经典的DP问题，f[i,j]表示以i,j为右下角的最大正方形的边长，那么a[i,j]=0时，f[i,j]=min(f[i-1,j-1],f[i-1,j],f[i,j-1])+1，a[i,j]=1时，f[i,j]=0，f数组中的最大值即为第一问的答案。


对于第二问，我们用一个单调栈来解决。


首先枚举最大矩形的下边界，对于每一个下边界维护两个（也可以说是两次）单调栈，一次正向，一次反向，用s[i,j]表示从a[i,j]开始向上最多能扩展出几个0，如果a[i,j]=1，那么s[i,j]=0，这样维护栈中元素的s值递增，每次元素出栈时就可以确定这个元素可以向左或向右扩展多少长度了，即找到了第一个s值小于该元素的位置，然后用每个元素的s值乘以向左向右扩展的长度和去更新第二问的答案就可以了。


由于每个元素最多进栈或出栈一次，每次的复杂度为O(n)，这样总的时间复杂度就是O(n^2);


参考代码


```delphi


var s,f:array[0..2001,0..2001]of longint;
    a:array[0..2001,0..2001]of 0..1;
    z,l,r,p:array[0..2001]of longint;
    ans1,ans2,i,j,m,n,k,t:longint;
function max(a,b:longint):longint;
begin if a>b then exit(a) else exit(b); end;
function min(a,b:longint):longint;
begin if a<b then exit(a) else exit(b); end;
procedure dp(o:longint);
var i,j:longint;
begin
  for i:=1 to n do if a[1,i]=o then s[1,i]:=1;
  for i:=2 to m do
    for j:=1 to n do
      if a[i,j]=o
      then s[i,j]:=s[i-1,j]+1 else s[i,j]:=0;
  for i:=1 to m do
    for j:=1 to n do
      begin
        if a[i,j]=o
        then f[i,j]:=min(f[i-1,j-1],min(f[i-1,j],f[i,j-1]))+1
        else f[i,j]:=0;
        ans1:=max(ans1,f[i,j]);
      end;
  for i:=1 to m do
    begin
      fillchar(l,sizeof(l),0);
      fillchar(r,sizeof(r),0);
      t:=0;
      for j:=1 to n do
        begin
          while (t>0)and(s[i,j]<s[i,z[t]]) do
            begin
              r[z[t]]:=j-z[t];
              dec(t);
            end;
          if a[i,j]=o
          then
            begin
              inc(t);
              z[t]:=j;
            end;
        end;
      for j:=t downto 1 do r[z[j]]:=n-z[j]+1;
      t:=0;
      for j:=n downto 1 do
        begin
          while (t>0)and(s[i,j]<s[i,z[t]]) do
            begin
              l[z[t]]:=z[t]-j;
              dec(t);
            end;
          if a[i,j]=o
          then
            begin
              inc(t);
              z[t]:=j;
            end;
        end;
      for j:=t downto 1 do l[z[j]]:=z[j];
      for j:=1 to n do
        if a[i,j]=o
        then
          begin
            p[j]:=l[j]+r[j]-1;
            ans2:=max(ans2,p[j]*s[i,j]);
          end;
    end;
end;
begin
  readln(m,n);
  for i:=1 to m do
    for j:=1 to n do
      begin
        read(a[i,j]); if (i+j) mod 2=0 then a[i,j]:=1-a[i,j];
      end;
  dp(0); dp(1);
  writeln(ans1*ans1); writeln(ans2);
end.



```

---

## 作者：Christopher_Yan (赞：7)

解题思路：

　　这道题目主要是运用了一个叫做悬线法的方法来求极大矩阵的。

　　所谓悬线法：就是维护三个数组：up[][], left_[][], right_[][]. 分别表示点（i，j） 向上方，左方，右方走能走的最远距离。

　　维护方法运用了一些DP思维：
```

    up[i][j] = up[i - 1][j] + 1;
    left_[i][j] = min(left_[i - 1][j], j - lz);    //lz表示左边最近的障碍
    right_[i][j] = min(right_[i - 1][j], rz - j);  //rz表示右边最近的障碍
```

　　还要注意初始化要让第0行的元素为正无穷，防止其对答案造成干扰。

　　当遇到障碍点时，应先更新最近障碍位置，然后将该点的left_, right_值赋成正无穷。原因同上。

　　为了方便维护lz, rz 的值，我跑了两边双重循环。。。 （复杂度依然O(nm) )

　　然后可以分别将0，1当作障碍各求一个解，输出最大值。

AC代码：
```

#include <iostream>
#include <cstdio> 
#include <cstring>
#include <cmath>

using namespace std;

const int MAXN = 2010;

short ma[MAXN][MAXN];

int n,m,lz,rz,ans,bns;
int up[MAXN][MAXN];
int left_[MAXN][MAXN];
int right_[MAXN][MAXN];

int read() //读入优化
{
    int x = 0;
    char c = getchar();
    
    while(c>'9' || c<'0')  c = getchar();
    while(c>='0' && c<='9')
        x = x*10 + c - '0',
        c = getchar();
        
    return x;
}

void color_(int c)
{
    memset(up, 0, sizeof(up));    //不忘初始化
    memset(left_, 0, sizeof(left_));
    memset(right_, 0, sizeof(right_));
    
    for (int i = 1; i <= m; ++i) //防止默认值0干扰答案
        left_[0][i] = 999999999,
        right_[0][i] = 999999999;
    
    for (int i = 1; i <= n; ++i) //维护left,up数组
    {
        lz = 0;
        for (int j = 1; j <= m; ++j)
            if (ma[i][j] != c) 
            {
                lz = j;
                left_[i][j] = 99999999;
                continue;
            }
            else
            {
                up[i][j] = up[i - 1][j] + 1;
                left_[i][j] = min(left_[i - 1][j], j - lz);
            }
                
    }
        
    for (int i = 1; i <= n; ++i) //维护right数组
    {
        rz = m + 1;
        for (int j = m; j >= 1; --j)
            if (ma[i][j] != c) 
            {
                rz = j;    
                right_[i][j] = 99999999;
                continue;
            }
            else
                right_[i][j] = min(right_[i - 1][j], rz - j);
    }
        
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= m; ++j)
        {
            ans = max(ans, up[i][j] * (left_[i][j] + right_[i][j] - 1));
            bns = max(bns, min(up[i][j], (left_[i][j] + right_[i][j] - 1))*min(up[i][j], (left_[i][j] + right_[i][j] - 1)));
            //正方形的话给横向，纵向长度取个minimum再平方就可以了
        }
    }
}

int main()
{
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
        {
            scanf("%d", &ma[i][j]);
            if ((i + j) & 1) ma[i][j] = abs(ma[i][j] - 1);
        }
    ans = -1;
    bns = -1;
    color_(1); //跑两边，分别把1，0当作障碍
    color_(0);
    cout << bns << endl << ans;
}
```

---

## 作者：7KByte (赞：7)

一只脑洞非常大的蒟蒻的题解

用第一问的答案解第二问的答案！

对于第一问，我们进行动态规划

首先预处理$R,C$数组,$R[i][j]$表示从位置$(i,j)$向左最多能扩展多少格，$C[i][j]$表示从$(i,j)$向上最多能扩展多少格。

一遍$O(MN)$递推即可

定义状态$f[i][j]$,表示已$(i,j)$为右下角的最大正方形边长

$f[i][j]=\begin{cases}min\{f[i-1][j-1]+1,R[i][j],C[i][j]\}&A_{i-1,j-1}=A_{i,j}\\1&A_{i-1,j-1}\ne A_{i,j}\end{cases}$

一遍$O(MN)$动态规划即可，$Ans=max^2\{f[i][j]\}$


对于第二问，我们可以借助已经求得的$f[][]$数组，求一段连续的$f[p\sim q][j]$的连续长度
乘以这一段中$f$数组的最小值$/$的最大值（手动断句

令$T=min\{f[p\sim q][j]\}$

就是$Ans=max\{(q-p+T)*T\}$

同理横着的一段也是答案

令$T=min\{f[i][p\sim q]\}$

就是$Ans=max\{(q-p+T)*T\}$

如何求这最大值，我们只需要用单调栈统计每一行$/$每一列

最后输出两个答案


$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[2005][2005],f[2005][2005];
int r[2005][2005],c[2005][2005];
int main()
{
	memset(a,-1,sizeof(a));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++){
	    scanf("%d",&a[i][j]);
	    if(a[i][j]^a[i][j-1])r[i][j]=r[i][j-1]+1;
	    else r[i][j]=1;
	    if(a[i][j]^a[i-1][j])c[i][j]=c[i-1][j]+1;
	    else c[i][j]=1;
      }
    int ans=0;
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	    {
	    	if(a[i][j]^a[i-1][j-1])f[i][j]=1;
	    	else f[i][j]=min(f[i-1][j-1]+1,min(r[i][j],c[i][j]));
	    	ans=max(ans,f[i][j]);
		}
	printf("%d\n",ans*ans);
	ans=0;
	stack<pair<int,int> >s;
	for(int i=1;i<=n;i++){
		while(!s.empty())s.pop();
		for(int j=1;j<=m+1;j++){
			int w=0;
			while(!s.empty()&&s.top().first>=f[i][j]){
			  int p=s.top().first,q=s.top().second;s.pop();
			  w+=q;ans=max(ans,p*(w+p-1));
			}
			s.push(make_pair(f[i][j],w+1));
		}
	}
	for(int j=1;j<=m;j++){
		while(!s.empty())s.pop();
		for(int i=1;i<=n+1;i++){
			int w=0;
			while(!s.empty()&&s.top().first>=f[i][j]){
			  int p=s.top().first,q=s.top().second;s.pop();
			  w+=q;ans=max(ans,p*(w+p-1));
			}
			s.push(make_pair(f[i][j],w+1));
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：shadow__ (赞：7)

###同样感谢楼下大佬的“如果横坐标加纵坐标为偶数那么取反”的思想，这样就把复杂的棋盘相间问题转化为求最大子矩形（这点比较不好想的，我当时做就是当着定理做，现在也不是完全清楚，大家可以画个图看一下）。


与楼下思想大同小异，利用悬线法（大家可以参考网上资料）求出所有极大子矩形，枚举找出最大子矩形（Ps：最大正方形要么就是最大子矩形，要么就包含在最大子矩形里面，我们只需在找出的最大子矩形中找出小边即可）。


#正文


其实楼下还可以进一步优化，我们发现hight[][]，left[][]，right[][]数组在循环中只需要利用到上一层的数据，即f[i-1][j]，这样每个数组利用率很低（每个数组在递推式中只用到一次）那么我们可不可以每次只记上一层的状态呢？


##当然是可以的。


当我们把数组压成一维的，显然发现当循环到下一行时，我的数组所存数据自然是上一层这个坐标的数据，即当未更新这一层f值时，f[j]与f[i-1][j]等效


那么我们得到递推式:

f[j]=max(f[j],障碍点所带来的限制条件)；（想想，right数组也是max吗？）


那么现在的问题就是，障碍点所带来的限制条件是什么。

PS：手里没图，大家将就着想象一下23333333

对于每一行，当从左往右遇到一个障碍点，那么这个障碍点的右边自然只能延伸到这个点的右边，从右往左也是一样。

这样我们就巧妙的避开了用单调栈实现的悬线延伸的操作；

我们设向左延伸的限制条件为l，向右延伸为r

对于每一个非障碍点，于是就有：

```cpp
left[j]=max(left[j],l+1);
right[j]=min(right[j],r-1);
```
下面的工作就很简单了，我就直接上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    char ch;int f=1,x=0;
    ch=getchar();
    while(ch<'0'||ch>'9'){if(ch == '-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
int n,m;
int hight[2111],L[2111],R[2111];
int l,r;
int ans1,ans2;
bool a[2111][2111];
inline void work(int x){//以x作为障碍点求最大子矩形
    memset(hight,0,sizeof(hight));//这里不要忘。
    for(int i=1;i<=m;i++)L[i]=1,R[i]=m;
    for(int i=1;i<=n;i++){
        l=0,r=m+1;
        for(int j=1;j<=m;j++){
            if(a[i][j] == x){
                L[j]=1;
                l=j;
                hight[j]=0;
            }
            else{
                hight[j]++;
                L[j]=max(L[j],l+1);
            }
        }
        for(int j=m;j>=1;j--){
            if(a[i][j] == x){
                R[j]=m;
                r=j;
            }//对于障碍点，我们记下它的坐标，然后将状态记为初状态即可
            else R[j]=min(R[j],r-1);
            int lc=min(hight[j],(R[j]-L[j]+1));
            ans1=max(ans1,lc*lc);
            ans2=max(ans2,(R[j]-L[j]+1)*hight[j]);
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        scanf("%d",&a[i][j]);
        if((i+j)%2==0)a[i][j]=!a[i][j];
    }
    work(0);
    work(1);//以黑白棋子作为障碍点都跑一遍。
    printf("%d\n%d\n",ans1,ans2);
    return 0;
}
```

---

## 作者：maomao9173 (赞：6)


如图所示，我们把棋盘的能使用和不能使用抽象成了√和×的形式，对于题目中的0/1棋盘，具体的判断稍作修改即可。

![](https://cdn.luogu.com.cn/upload/pic/32075.png)

#### 悬线法的操作就是对每一个点，预处理它在左右方向上延伸的最大长度，把初始高度设为1（本行的长条矩形也要计算），接下来线动成面，扩大高度，遇见障碍就缩小区间范围。即为常见的公式：
   
```cpp
if(mp[now(i)][j]!=mp[las(i)][j]&&i>1){//【0/1】可以使用
                up[now(i)][j]=up[las(i)][j]+1;//因为可以继承下来，所以高度+1
                l[now(i)][j]=max(l[now(i)][j],l[las(i)][j]);//区间收束
                r[now(i)][j]=min(r[now(i)][j],r[las(i)][j]);//同理 
            }

```
那么怎么得到我们想要的矩形和正方形大小的答案呢？矩形的计算很好办，那么正方形的大小不就是收束的矩形大小嘛？
```cpp
            int len=r[now(i)][j]-l[now(i)][j]+1;//x轴上长度
            int hei=min(len,up[now(i)][j]);//因为是正方形所以必须保证长宽相等 
            ans_1=max(ans_1,hei*hei);
            ans_2=max(ans_2,len*up[now(i)][j]);
```
#### 只要上下矩形长度大小不一样，就不会出现对一个有效矩形的计算覆盖另一个有效矩形的情况（比如图中左边2x3的矩形并没有覆盖对第三行最左3x1矩形的计算，所以通过这种方法得到的就是答案啦qwq）
Code:
```cpp
#include<cstdio>
#include<iostream>
#define now(x) x%2
#define las(x) x%2==0?1:0
using namespace std;
int n,m,ans_1,ans_2,up[2][2010],mp[2][2010],l[2][2010],r[2][2010];
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&mp[now(i)][j]);
            l[now(i)][j]=r[now(i)][j]=j;//先都处理成右边 
            up[now(i)][j]=1;//高度为1 
        }
        for(int j=2;j<=m;j++)if(mp[now(i)][j]!=mp[now(i)][j-1])l[now(i)][j]=l[now(i)][j-1];//左边的处理成左边 
        for(int j=m-1;j>=1;j--)if(mp[now(i)][j]!=mp[now(i)][j+1])r[now(i)][j]=r[now(i)][j+1]; //右边的处理成右边 
        for(int j=1;j<=m;j++){
            if(mp[now(i)][j]!=mp[las(i)][j]&&i>1){
                up[now(i)][j]=up[las(i)][j]+1;//因为可以继承下来，所以高度+1
                l[now(i)][j]=max(l[now(i)][j],l[las(i)][j]);//区间收束
                r[now(i)][j]=min(r[now(i)][j],r[las(i)][j]);//同理 
            }
            int len=r[now(i)][j]-l[now(i)][j]+1;//x轴上长度
            int hei=min(len,up[now(i)][j]);//因为是正方形所以必须保证长宽相等 
            ans_1=max(ans_1,hei*hei);
            ans_2=max(ans_2,len*up[now(i)][j]);
        }
    }
    printf("%d\n%d",ans_1,ans_2);
    return 0; 
}
```

---

## 作者：洛谷Onlinejudge (赞：5)

# 总体思路：悬线DP

[洛谷链接](https://www.luogu.org/problemnew/show/P1169)

题意的化简：
题目中要我们求最大的01相间的矩阵（四边形）和正方形。
对于处理矩阵，只需：(Map[i][j]!=Map[i][j-1])/*证明相邻两个颜色不同，符合题意 */

对于正方形和长方形，在代码中会继续讲解；

题目的核心：

# 悬线DP

我们需要**枚举第i行第j列往上（<i）的最大合法合法矩阵（01相间）**，

于是我们设三个二维数组：

Left[i][j]:**表示第i行第j列可以到达的最左边的位置**；

Right[i][j]:**表示第i行第j列可以到达的最右边的位置**；

Up[i][j]:**表示第i行第j列可以到达最上方的长度**；

在输入数据时，顺便对着三个数组进行初始化，Left和Right的初始化为j，因为这时我们还不知道左右延伸的长度，所以都为原点；Up则为1，因为我们也不知道每个矩阵最上面能到达哪个位置。

我们对Left和Right分别进行二维的初始化，求出上述中我们想得到的量，代码：
```cpp
for(register int i=1;i<=N;i++)
	for(register int j=2;j<=M;j++)//注意这里的循环：从最左边往右边扫
		if(Map[i][j]!=Map[i][j-1])//如果相邻两个符合条件，连接
			Left[i][j]=Left[i][j-1];
	
for(register int i=1;i<=N;i++)
	for(register int j=M-1;j>0;j--)//注意这里的循环：从最右边往左边扫
		if(Map[i][j]!=Map[i][j+1])//如果相邻两个符合条件，连接
			Right[i][j]=Right[i][j+1];
```
Up、Left和Right的递推公式：

**Up[i][j]=Up[i-1][j]+1;**

**Left[i][j]=max(Left[i][j],Left[i−1][j];**

**Right[i][j]=min(Right[i][j],Right[i-1][j];**

（前提是他们**都是合法相邻**）

Q：为什么Left要用max，而Right要用min？

A：因为你想，这个枚举出来的图形的**左右肯定是参差不齐**的，要想使它变成四边形，肯定要**找到左边和右边线段的最小值**，右边的最小值用min（**靠近中轴**），左边的最小值要用max（**靠近中轴**）：

Q：为什么Up数组要从上一行加一?

A：因为Up数组是用来统计从**第i行第j列可以到达最上方的长度**，**所记录的不是一个坐标**（像Right和Left）,**而是一个最远距离的值**。

Q：为什么Up数组不像Left和Right数组一样统计向上延伸的最短值？

A；因为Up数组记录的是中轴的长度，而**中轴只有一条**，所以无需做此操作。

而对于Up数组，我们可以边DP边初始化。

# **代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;

int Left[2020][2020],Right[2020][2020];
int Up[9999][2020],DP[2020][2020];
int Map[2020][2020],N,M;
int ACanswer1,ACanswer2;

int main(void){
	scanf("%d%d",&N,&M);
	for(register int i=1;i<=N;i++){
		for(register int j=1;j<=M;j++){
			scanf("%d",&Map[i][j]);
			Right[i][j]=j;
			Left[i][j]=j;
			Up[i][j]=1;
		}
	}//输入数据并进行初始化
	
	for(register int i=1;i<=N;i++)
		for(register int j=2;j<=M;j++)
			if(Map[i][j]!=Map[i][j-1])
				Left[i][j]=Left[i][j-1];
	
	for(register int i=1;i<=N;i++)
		for(register int j=M-1;j>0;j--)
			if(Map[i][j]!=Map[i][j+1])
				Right[i][j]=Right[i][j+1];
	//对每个点的左右进行延伸
	ACanswer1=ACanswer2=1;//长方形和正方形的初始值都为1
	for(register int i=1;i<=N;i++){
		for(register int j=1;j<=M;j++){
			if((i>1)&&(Map[i][j]!=Map[i-1][j])){//如果此位置上方还有位置，并且与上方合法（上方为0我为1，上方为1我为0）
				Left[i][j]=max(Left[i][j],Left[i-1][j]);
				Right[i][j]=min(Right[i][j],Right[i-1][j]);//对左右两边进行截取（取最小值）
				Up[i][j]=Up[i-1][j]+1;//初始化（中轴++）
			}
			int Num1=Right[i][j]-Left[i][j]+1;//细节，左右间隔是还要减一的
			int Num2=min(Num1,Up[i][j]);//找到长和宽谁短（用于计算正方形面积）
			ACanswer1=max(ACanswer1,Num2*Num2);//正方形面积打类
			ACanswer2=max(ACanswer2,Num1*Up[i][j]);//长方形面积打类
		}
	}
	cout<<ACanswer1<<endl;
	cout<<ACanswer2<<endl;
	return 0;//输出并结束
}
```

# **结语：**
祝大家在NOIP2019中RP++！！！

---

## 作者：messuarez (赞：4)

同样是悬线法，处于代码简单，不需要按照行列和的奇偶性进行转化。这里h[i][j]表示从i,j位置向上01相间的走最远能走的长度；l[i][j].r[i][j]表示向左（右）最远能走的长度；L[i][j].R[i][j]表示以h[i][j]为高，矩形向左（右）能扩展到的最大长度。
转移和统计答案见代码。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=2003;
int a[maxn][maxn],n,m,h[maxn][maxn],l[maxn][maxn],r[maxn][maxn],L[maxn][maxn],R[maxn][maxn],ans1,ans2;
inline int pf(int x) {return x*x;}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) scanf("%d",&a[i][j]);
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=m;++j) {
			h[i][j]=a[i][j]!=a[i-1][j]?h[i-1][j]+1:1;
			l[i][j]=a[i][j]!=a[i][j-1]?l[i][j-1]+1:1;
			L[i][j]=a[i][j]!=a[i-1][j]?min(L[i-1][j],l[i][j]):l[i][j];
		}
		for(int j=m;j>=1;--j) {
			r[i][j]=a[i][j]!=a[i][j+1]?r[i][j+1]+1:1;
			R[i][j]=a[i][j]!=a[i-1][j]?min(R[i-1][j],r[i][j]):r[i][j];
		}
	}
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) {
		ans1=max(ans1,pf(min(R[i][j]+L[i][j]-1,h[i][j])));
		ans2=max(ans2,(R[i][j]+L[i][j]-1)*h[i][j]);
	}
	printf("%d\n%d",ans1,ans2);
	return 0;
}

```

---

## 作者：lemonfor (赞：4)

# 如果想要认真做这道题，请移步别的题解蟹蟹

~~做了[P4147](https://www.luogu.org/problem/P4147)后又看到了这一道题，发现就是其变种，按位取反之后几乎一模一样。。。~~

关于按位取反是这样的：
1. 正常的棋盘只有0 ，1构成，且交错分布

这里：![棋盘](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3347141751,2894100907&fm=26&gp=0.jpg)

于是我们把格子行数和列数相加起来为偶数的变成白色，在我们脑中它就会变成一个0-1矩阵，然后就是[P4147](https://www.luogu.org/problem/P4147)了

关于其解法可以悬线法，DP也行，~~但我为了图省事写了个n^3大暴力，也能过QAQ~~
```
#include<cstdio>
#include<algorithm>
#define _ 0
using namespace std;
int n ,m ,tmp ,num1[2050] ,num2[2050] ,h1 ,h2;
int ans = 1 ,ans_ = 1;
int main()
{
    scanf("%d%d" ,&n ,&m);
    for(int i = 1 ; i <= n ; ++ i)
    {
        for(int j = 1 ; j <= m ; ++ j)
        {
            scanf("%d" ,&tmp);
            if((i + j) & 1) tmp = 1 - tmp;//将其变色
            if(tmp) ++num1[j];//接下来是找最大的全由0或1组成的矩阵
            else num1[j] = 0;
            if(!tmp) ++ num2[j];
            else num2[j] = 0;
            h1 = num1[j];
            h2 = num2[j];
            for(int k = j - 1 ; k ; -- k)
            {
            	if(num1[j])
            	{
	            	h1 = min(h1 , num1[k]);
	                ans = max(ans , min(h1 , (j - k + 1)));//关于最大正方形是可以直接在途中解决的
	                ans_ = max(ans_ , h1 * (j - k + 1));
				}
                else {
                	h2 = min(h2 , num2[k]);
	                ans = max(ans , min(h2 , (j - k + 1)));
	                ans_ = max(ans_ , h2 * (j - k + 1));
				}
            }
        }
    }
    printf("%d\n%d" ,ans * ans ,ans_);
    return ~~(0^_^0);
}
```

建议可以用DP或别的练练手，毕竟暴力并不是万能的嘛QAQ

---

## 作者：zhenghaishu (赞：2)



# 一、题目
https://www.luogu.com.cn/problem/P1169

# 二、分析
以样例中的数据为例，格子共有三行三列。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200220205145305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhaXNodV96aGVuZw==,size_16,color_FFFFFF,t_70) 

咱们可以按顺序枚举每个格子。求长方形的时候，可以枚举整行。求正方形的时候，要以当前的格子作为正方形右下角的格子。
i = 1, j = 1时，矩形的宽度是3，高度是1，则矩形的面积是3，如图A的整个图形所示。以第一行第一列作为右下角格子的最大正方形的边长是1，则最大正方形的面积是1，如图B中的绿色部分所示。 
i = 1, j = 2时，矩形的宽度是3，高度是1，则矩形的面积是3，如图B的整个图形所示。以第一行第二列作为右下角格子的最大正方形的边长是1，则最大正方形的面积是1，如图B中的绿色部分所示。 
i = 1, j = 3时，矩形的宽度是3，高度是1，则矩形的面积是3，如图C的整个图形所示。以第一行第三列作为右下角格子的最大正方形的边长是1，则最大正方形的面积是1，如图C中的绿色部分所示。 
i = 2, j = 1时，矩形的宽度是3，高度是2，则矩形的面积是6，如图D的整个图形所示。以第二行第一列作为右下角格子的最大正方形的边长是1，则最大正方形的面积是1，如图D中的绿色部分所示。 
i = 2, j = 2时，矩形的宽度是3，高度是2，则矩形的面积是6，如图E的整个图形所示。以第二行第二列作为右下角格子的最大正方形的边长是2，则最大正方形的面积是4，如图E中的绿色部分所示。 
……

具体编程时，咱们可设三个二维数组：left[i][j]，right[i][j]和up[i][j]。用来表示第i行第j列格子可向左、向右、向上延伸的极限值。根据棋盘规则，只有相邻的两个格子颜色不同才能延伸过去。
## （一）计算left值
left值	|意义
----------|---
left[1][1]=1	|第一行第一列的格子，因为是左边界格子，不能往左延伸，只能停留在本格子上。
left[1][2]=1	|第一行第二列的格子，因为颜色与第一行第一列的格子不同，所以最左侧可延伸到第一列。
left[1][3]=1	|因为第一行第三列格子相邻的颜色两两不相同，所以第一行第三列格子向左可延伸到第一列。
left[2][1]=1	|第二行第一列的格子，因为是左边界格子，不能往左延伸，只能停留在本格子上。
left[2][2]=1	|第二行第二列的格子，因为颜色与第二行第一列的格子不同，所以向左可延伸到第一列。
left[2][3]=1	|因为第二行三列格子相邻的颜色两两不相同，所以第二行三列格子向左可延伸到第一列。
left[3][1]=1	|第三行第一列的格子，因为是左边界格子，不能往左延伸，只能停留在本格子上。
left[3][2]=1	|第三行第二列的格子，因为颜色与第三行第一列的格子不同，所以向左可延伸到第一列。
left[3][3]=3	|第三行第三列的格子与第三行第二列的格子颜色相同，所以第三行第三列格子不能往左延伸，只能停留在本格子上。

## （二）计算right值
right值	|意义
-|-
right[1][1]=3	|第一行的三个格子颜色两两不同，所以第一行第一列的格子可以向右延伸到第一行第三列。
right[1][2]=3	|第一行第二列的格子，因为颜色与第一行第三列的格子不同，所以可以向右延伸到第一行第三列。
right[1][3]=3	|第一行第三列的格子处于右边界，不能再向右延伸。
right[2][1]=3	|第二行的三个格子颜色两两不同，所以第二行第一列的格子可以向右延伸到第二行第三列。
right[2][2]=3	|第二行第二列的格子，因为颜色与第二行第三列的格子不同，所以可以向右延伸到第二行第三列。
right[2][3]=3	|第二行第三列的格子处于右边界，不能再向右延伸。
right[3][1]=2	|第三行第一列格子颜色与第二列格子颜色不同，所以可延伸到第二列；第二列颜色与第三列相同，所以不能延伸到第三列。
right[3][2]=2	|第三行第二列的格子，因为颜色与第三行第三列的格子不同，所以不能延伸到第三列。
right[3][3]=3	|第三行第三列的格子处于右边界，不能再向右延伸。

## （三）计算up值
up值	|意义
----------|-------
up[1][1]=1	|第一行第一列处于上边界，则此格子的高度为1
up[1][2]=1	|第一行第二列处于上边界，则此格子的高度为1
up[1][3]=1	|第一行第三列处于上边界，则此格子的高度为1
up[2][1]=2	|第二行第一列的颜色与第一行第一列不同，则竖直方向两个格子的累积高度为2
up[2][2]=2	|第二行第二列的颜色与第一行第二列不同，则竖直方向两个格子的累积高度为2
up[2][3]=2	|第二行第三列的颜色与第一行第三列不同，则竖直方向两个格子的累积高度为2
up[3][1]=3	|第一列的三个格子相邻颜色都不同，所以枚举到第三行第一列时，竖直方向三个格子的累积高度为3
up[3][2]=3	|第二列的三个格子相邻颜色都不同，所以枚举到第三行第二列时，竖直方向三个格子的累积高度为3
up[3][3]=1	|第三行第三列格子的颜色与第二行第三列相同，不能向上延伸。所以枚举到第三行第三列时，竖直方向格子的高度为1。

# 三、AC代码
```
#include <iostream>
#include <cstdio>
using namespace std;

const int maxn = 2005;

int a[maxn][maxn], lef[maxn][maxn], righ[maxn][maxn], up[maxn][maxn];
int n, m, area1, area2;

int main()
{
    //freopen("P1169.in", "r", stdin);

    scanf("%d%d", &n, &m);

    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            scanf("%d", &a[i][j]);
            //初始化
            lef[i][j] = righ[i][j] = j;
            up[i][j] = 1;
        }
    }

    //格子(i,j)往左最多能达到哪一列
    for(int i = 1; i <= n; i++)
    {
        for(int j = 2; j <= m; j++)
        {
            if(a[i][j] != a[i][j-1])
            {
                lef[i][j] = lef[i][j-1];
            }
        }
    }

    //格子(i,j)往右最多能达到哪一列
    for(int i = 1; i <= n; i++)
    {
        for(int j = m - 1; j > 0;j--)
        {
            if(a[i][j] != a[i][j+1])
                {
                    righ[i][j] = righ[i][j+1];
                }
        }
    }

    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            if(i > 1 && a[i][j] != a[i-1][j])//相同列上下行格子颜色不同
            {
                lef[i][j] = max(lef[i][j], lef[i-1][j]);    //取本行和上一行的交集，用max
                righ[i][j] = min(righ[i][j], righ[i-1][j]); //取本行和上一行的交集，用min
                up[i][j] = up[i-1][j] + 1;
            }

            int width = righ[i][j] - lef[i][j] + 1; //求宽度，左右端点都要算进去，所以要加1
            int side = min(width, up[i][j]);        //在宽度和高度之间取最小值作为边长
            area1 = max(area1, side * side);        //正方形面积
            area2 = max(area2, width * up[i][j]);   //长方形面积
        }
    }

    cout << area1 << endl << area2;

    return 0;
}
```






---

## 作者：FjswYuzu (赞：2)

$\ \ \ \ \ \ \ $[luogu](https://www.luogu.com.cn/problem/P1169)

$\ \ \ \ \ \ \ $我们要找到一个黑白相间的棋盘（可以参考国际象棋棋盘），第一个小问题是找到最大的正方形，第二个是找到最大的矩形。

$\ \ \ \ \ \ \ $我们注意到棋盘跟题 1 一样只有两种格子，能用状压吗？答案是否。因为 $n,m \leq 2000$，所以不能状压。

$\ \ \ \ \ \ \ $同时，找到最大的合法正方形和矩形，恰好是我们的找纯色最大正方形和矩形的经典模型（分别用 dp 和单调栈求解），我们能够在此间转换吗？

$\ \ \ \ \ \ \ $答案是可以的。我们将 $a_{i,j} \otimes 1 (i + j \mod 2 = 0)$，其中 $\otimes$ 为异或符号。

$\ \ \ \ \ \ \ $我们发现随机取上一个矩阵，我们翻转了之后，发现其实就是可以互相转换的。现在我们反转之后只需要求纯色最大正方形和矩形的经典模型了。

$\ \ \ \ \ \ \ $对于第一个问题，定义 $dp_{0,i,j}$ 为 $a_{i,j}=0$，以 $(i,j)$ 为右下角的正方形最大边长。$dp_1$ 同理。对于 dp 方程，有：

$$\begin{cases}
dp_{0,i,j}=\min \{ dp_{0,i-1,j},dp_{0,i-1,j-1},dp_{0,i,j-1}+1\} (a_{i,j}=0) \\ dp_{1,i,j}=\min \{ dp_{1,i-1,j},dp_{1,i-1,j-1},dp_{1,i,j-1}+1\} (a_{i,j}=1)
\end{cases}$$

$\ \ \ \ \ \ \ $如果这一段 Markdown 爆了可以看[blog](https://www.luogu.com.cn/blog/blog10086001/solution-p1169)。这里还有[动态规划一百题](https://www.luogu.com.cn/blog/blog10086001/dong-tai-gui-hua-100-ti)qwq，参见 3题。

$\ \ \ \ \ \ \ $易得答案为 $\max \{ dp \}$，时间复杂度 $O(nm)$。

$\ \ \ \ \ \ \ $对于第二个问题，用单调栈求解。我们首先储存一段连续的高，也就是对于一个数最多能往上延伸多少相同的连续的数。枚举每一行作为矩形底边，这道题就变成了直方图最大矩形问题。枚举下边时间复杂度 $O(n)$，单调栈 $O(m)$。

$\ \ \ \ \ \ \ $得到这些，总时间复杂度 $O(nm)$，可以通过题目。

$\ \ \ \ \ \ \ $代码如下。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,a[2005][2005];
namespace DynamicProgramming
{
	int dp1[2005][2005],dp2[2005][2005];
	void Dp()
	{
		int ans=0;
		for(int i=1;i<=n;++i)
		{
			for(int j=1;j<=m;++j)
			{
				if(a[i][j])	dp1[i][j]=min(min(dp1[i-1][j],dp1[i][j-1]),dp1[i-1][j-1])+1;
				else	dp2[i][j]=min(min(dp2[i-1][j],dp2[i][j-1]),dp2[i-1][j-1])+1;
				ans=max(ans,max(dp1[i][j],dp2[i][j]));
			}
		}
		printf("%d\n",ans*ans);
	}
}
namespace MonotonicStack
{
	int cnt[2005][2005],ans,s[2005],l[2005];
	void Monotonic(int sp[])
	{
		int top=0,len=0;
		s[top]=l[top]=0;
		for(int i=1;i<=m;++i)
		{
			if(sp[i]>=s[top])	s[++top]=sp[i],l[top]=1;
			else
			{
				len=0;
				while(top && s[top]>sp[i])
				{
					len+=l[top];
					ans=max(ans,len*s[top]);
					--top;
				}
				s[++top]=sp[i];
				l[top]=len+1;
			}
		}
		len=0;
		while(top)
		{
			len+=l[top];
			ans=max(ans,len*s[top]);
			--top;
		}
	}
	void Stack(){for(int i=1;i<=n;++i)	Monotonic(cnt[i]);}
	void Ans(){printf("%d",ans);}
}
using namespace MonotonicStack;
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			scanf("%d",&a[i][j]);
			if(!((i+j)&1))	a[i][j]^=1;
			if(a[i][j])	cnt[i][j]=cnt[i-1][j]+1;
		}
	}
	DynamicProgramming::Dp();
	MonotonicStack::Stack();
	memset(cnt,0,sizeof cnt);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			if(!a[i][j])	cnt[i][j]=cnt[i-1][j]+1;
		}
	}
	MonotonicStack::Stack();
	MonotonicStack::Ans();
	return 0;
}
```

---

## 作者：_wkjzyc (赞：2)

### 题意

给定一个n*m的01矩阵，寻找最大的，相邻值不相同的子矩阵与子方阵。

$n,m\leq 2,000$



### 分析

朴素的做法是枚举两个点来确定矩阵，再暴力判断能不能满足条件。

复杂度$O(n^4)$爆炸。考虑优化：判断能不能满足条件时，存在很多重复判断，可以预处理。

但是，怎样进行预处理呢？这就需要我们改变枚举方式，简化预处理的步骤。

### 悬线法

~~今年应该不考~~

是一种DP(?)算法，常用于求满足条件的矩阵。

![](https://cdn.luogu.com.cn/upload/pic/75921.png)

如果将一条线当做1*k的矩阵看待，则我们枚举每一条满足条件的线，并尝试将其向左右拓展构造矩阵。

![](https://cdn.luogu.com.cn/upload/pic/75922.png)

那么只要在左右拓展长度中分别取min，就是所求答案。这种方法的复杂度是多少？

每个点如果和上方不同，就可以接到上面的线中。所以枚举每个点，就可以递推求出悬线up

$$up_{i,j}=up_{i-1,j}+(b_{i,j}\not= b_{i,j})$$

其中b是原始矩阵，初始值是1。复杂度$O(n^2)$



左右端拓展的对象是单个点，所以对于每个点都预处理出能向左右拓展到的位置。用递推求出。

$$\begin{cases}b_{i,j}\not=b_{i,j-1}\quad left_{i,j}=j\\b_{i,j}=b_{i,j-1}\quad left_{i,j}=left_{i,j-1}\end{cases}$$

$$\begin{cases}b_{i,j}\not=b_{i,j+1}\quad right_{i,j}=j\\b_{i,j}=b_{i,j+1}\quad right_{i,j}=right_{i,j+1}\end{cases}$$

复杂度仍然$O(n^2)$



2k可过。

### 正确性

我们需要证明的是，悬线法可以枚举到所有矩形。

![](https://cdn.luogu.com.cn/upload/pic/75924.png)


假设我们要在这一团满足条件的联通块中找矩形。（丑，真TM丑）

![](https://cdn.luogu.com.cn/upload/pic/75925.png)

那么它会不会取蓝色呢？不会，很明显绿色比他更优。有一个性质：**矩形边缘必然紧贴联通块边缘**。

所以对于每条悬线，它取到的矩阵是尽量大的。

~~（其实绿色也不满足，因为左右端没有取完整。）~~

![](https://cdn.luogu.com.cn/upload/pic/75926.png)

~~画图宝才，luogu捡到鬼了~~

由刚才的性质得出，这个矩形所在的联通块即便边缘再粗糙，总是会有一条悬线的上端和矩形的上端重合。

所以，只要每条悬线都枚举到，每个可能是答案的矩形就会枚举到，而且会让它们尽量大。这题就解决了。

### 代码

~~别看了 抄的~~

```cpp
#include<cstdio>//iostream库有left函数，会冲突
#include<algorithm>
using namespace std;

const int MAXN=2005;
int n,m;
bool b[MAXN][MAXN];
int left[MAXN][MAXN],right[MAXN][MAXN],up[MAXN][MAXN];
int sq,rect,temp;

int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			left[i][j]=right[i][j]=j,up[i][j]=1,scanf("%d",&b[i][j]);
			//输入、初始化 
	for(int i=1;i<=n;i++)
		for(int j=2;j<=m;j++)
			if(b[i][j]!=b[i][j-1])
				left[i][j]=left[i][j-1];
	for(int i=1;i<=n;i++)
		for(int j=m-1;j>=1;j--)
			if(b[i][j]!=b[i][j+1])
				right[i][j]=right[i][j+1];
			//递推预处理，注意范围和顺序 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(i>1&&b[i-1][j]!=b[i][j])
			{
				up[i][j]=up[i-1][j]+1;
				left[i][j]=max(left[i][j],left[i-1][j]);
				right[i][j]=min(right[i][j],right[i-1][j]);
				//由于是矩形，left和right不能越界，要取一遍最小值
				//另外看清楚存储的是位置不是距离，所以左端取距离更短相当于位置更靠后，下标更大。 
			}
			temp=(right[i][j]-left[i][j]+1);
			rect=max(rect,up[i][j]*temp);
			sq=max(sq,min(up[i][j],temp)*min(up[i][j],temp));
			//正方形同理。 
		}
	printf("%d\n%d\n",sq,rect);
	return 0;
}
```

最后，祝大家身体健康，再见。

---

## 作者：Polaris_Dane (赞：2)

这是一道用来总结非常好的题目

解决这种有某种特殊限制条件的最大矩形的问题，有一种被称为悬线法的算法

我们定义$l[i][j]$,$r[i][j]$,$up[i][j]$表示从某个点开始

向左，向右，向上满足条件的**线段**的最长长度，或是结束地点

然后从上往下扫描，每次与为了扩大矩形我们要同时满足上一排的左右限制和这一排的左右限制

以及题目所给定的限制，然后更新$up[i][j]$

最后扫描的时候取最大的值就可以了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cctype>
#include<set>
#define LL long long
#define M 2001000
#define N 50010
#define int long long
using namespace std;
const int inf=0x3f3f3f3f;
const int mod=1e9+7;
const double eps=1e-6;
inline int read(){
	int f=1,x=0;char s=getchar();
	while(!isdigit(s)){if (s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=(x<<1)+(x<<3)+(s^48);s=getchar();}
	return x*f;
}
int n,m,up[2100][2100],l[2100][2100],r[2100][2100],a[2100][2100],ans1,ans2; 
signed main(void){
	n=read(),m=read();
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) a[i][j]=read(),l[i][j]=r[i][j]=j,up[i][j]=1;
	for (int i=1;i<=n;i++)
		for (int j=2;j<=m;j++)
			if (a[i][j]!=a[i][j-1])
				l[i][j]=l[i][j-1];
	for (int i=1;i<=n;i++)
		for (int j=m-1;j>=1;j--)
			if (a[i][j]!=a[i][j+1])
				r[i][j]=r[i][j+1];
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++){
			if (i!=1&&a[i][j]!=a[i-1][j]){
				l[i][j]=max(l[i][j],l[i-1][j]);
				r[i][j]=min(r[i][j],r[i-1][j]);
				up[i][j]=up[i-1][j]+1;
			}
			ans1=max(ans1,up[i][j]*(r[i][j]-l[i][j]+1));
			ans2=max(ans2,min(up[i][j],r[i][j]-l[i][j]+1)*min(up[i][j],r[i][j]-l[i][j]+1));
		}
		printf("%lld\n%lld",ans2,ans1);
	return 0;
}
```


---

## 作者：huiwang17 (赞：1)

依然是悬线法，不过要注意这里棋盘向外扩张的时候需要满足条件
$$G[i][j] \oplus G[i-1][j] != 0 $$

最大正方形可以由过程中求出的每一个极大棋盘得到。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 1017;
int n, m;
int G[MAXN][MAXN];
int up[MAXN][MAXN];
int l[MAXN][MAXN];
int r[MAXN][MAXN];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> G[i][j];
    for(int i = 1; i <= n; i++)
        for(int j = 2; j <= m; j++)
            if(G[i][j] ^ G[i][j-1])
                l[i][j] = l[i][j-1] + 1;

    for(int i = 1; i <= n; i++)
        for(int j = m - 1; j >= 1; j--)
            if(G[i][j] ^ G[i][j+1])
                r[i][j] = r[i][j+1] + 1;

    int maxs = 0;
    int k = 0;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(i > 1 && G[i][j] ^ G[i-1][j])
                up[i][j] = up[i-1][j] + 1;
            if(up[i][j]){
                l[i][j] = min(l[i-1][j], l[i][j]);
                r[i][j] = min(r[i-1][j], r[i][j]);
            }
            //printf("## (%d, %d) %d %d %d\n", i, j, l[i][j], r[i][j], up[i][j]);
            maxs = max(maxs, (up[i][j] + 1) * (l[i][j] + r[i][j] + 1));
            k = max(k, min(up[i][j] + 1, l[i][j] + r[i][j] + 1));
        }
    }
    cout << k * k << endl;
    cout << maxs << endl;
}



```


---

## 作者：_Atyou (赞：1)

## $ \it\bf UPD 2019.7.26 $

### 本来只写了暴力的方法，但之后学了一下悬线法，两种方法都写在下方。

------------
# Part 1 : 玄学暴力

------------

大佬都用悬线法，我只会暴力awa

这种题型见过不少了，这题只是要求0， 1相间而已

一行一行处理

每次处理当前行时预处理出当前行的各列向上延伸的最长高度

然后在当前行时枚举矩形(正方形)的左下角，然后不断向右拓展，矩形的高度是拓展过程中的最小高度。显而易见的， _**面积=当前拓展宽度 × 最小高度**_ 

正方形特殊处理即可， _**面积=( min(当前拓展宽度，最小高度) )^2**_

PS： 对于正方形有个优化，选定左下角向右拓展过程中，最小高度只会更小不会更大，所以如果(最小高度^2)比答案小了，便不必再向右拓展了

时间复杂度  _**O（n^3）**_ 

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register
const int N = 2000 + 5;

int n, m, a[N][N], h[N];

void solve_sqr() { //正方形，矩形更有代表性，注释详见矩形，正方形仅有几处不同
    int ans=0;
    for (reg int i=1; i<=n; ++i) {
        if (i==1) for (reg int j=1; j<=m; ++j) h[j]=1;
        else for (reg int j=1; j<=m; ++j) if (a[i][j]!=a[i-1][j]) ++h[j]; else h[j]=1; 
        for (reg int st=1; st<=m; ++st) {
            int nh=h[st]; ans=max(ans, 1); 
            for (reg int j=st+1; j<=m; ++j) {
                if (a[i][j]==a[i][j-1]) break;
                nh=min(nh, h[j]);
                ans=max(ans, min(nh, j-st+1)*min(nh, j-st+1));
                if (ans >= nh*nh) break; //上面提到的优化
            }
        }
    }
    printf("%d\n", ans);  
}

void solve_rec() { //矩形
    int ans=0;
    for (reg int i=1; i<=n; ++i) {
        if (i==1) for (reg int j=1; j<=m; ++j) h[j]=1;
        else for (reg int j=1; j<=m; ++j) if (a[i][j]!=a[i-1][j]) ++h[j]; else h[j]=1;  //预处理向上的高度
        for (reg int st=1; st<=m; ++st) { //枚举起点
            int nh=h[st]; ans=max(ans, h[st]); 
            for (reg int j=st+1; j<=m; ++j) { //向右拓展
                if (a[i][j]==a[i][j-1]) break; //无法向右拓展，跳出
                nh=min(nh, h[j]);
                ans=max(ans, (j-st+1)*nh);
            }
        }
    }
    printf("%d\n", ans);  
}

int main() {
    scanf("%d%d", &n, &m);
    for (reg int i=1; i<=n; ++i)
        for (reg int j=1; j<=m; ++j) scanf("%d", &a[i][j]);
    solve_sqr();
    solve_rec();
    return 0;
}

```

暴力还是弱太多， 这里只是给想打暴力但是没有思路的同学提供思路。~~还是建议各位同学去学习一下悬线法~~ 下面提供悬线法

------------
# Part 2 : 悬线法

------------

PS：写这一部分主要是加深自己的理解，其他大佬可能写的比我更清楚些。

暴力的第三重循环是能预处理掉的。

用$l[i][j]$表示向左能拓展的最远点。

用$r[i][j]$表示向右能拓展的最远点。

用$up[i][j]$表示向上能拓展的最远点。

先预处理出$l[i][j]$和$r[i][j]$。在求解时求$up[i][j]$。

求解时，如果能向上拓展， 更新$up[i][j]$, 也要把$l[i][j]$和$r[i][j]$更新了。

更新的公式：

$ l[i][j]=max(l[i][j], l[i-1][j]); $
$ r[i][j]=min(r[i][j], r[i-1][j]); $

这样就能求出每个点尽量向上拓展的最大矩形/正方形。

通过枚举每个点就能保证一定会找到最大的那个矩形/正方形。

时间复杂度  _**O（n^2）**_ 

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register
const int N = 2000 + 5;

int n, m, a[N][N], l[N][N], r[N][N], up[N][N], ans1, ans2;

int main() {
    scanf("%d%d", &n, &m);
    for (reg int i=1; i<=n; ++i)
        for (reg int j=1; j<=m; ++j) {
            scanf("%d", &a[i][j]);
            l[i][j]=r[i][j]=j; up[i][j]=1; 
        }
    for (reg int i=1; i<=n; ++i)
        for (reg int j=2; j<=m; ++j)
            if (a[i][j]!=a[i][j-1]) l[i][j]=l[i][j-1];
    for (reg int i=1; i<=n; ++i)
        for (reg int j=m-1; j; --j)
            if (a[i][j]!=a[i][j+1]) r[i][j]=r[i][j+1];
    for (reg int i=1; i<=n; ++i)
        for (reg int j=1; j<=m; ++j) {
            if (i>1 && a[i][j]!=a[i-1][j]) {
                l[i][j]=max(l[i][j], l[i-1][j]);
                r[i][j]=min(r[i][j], r[i-1][j]);
                up[i][j]=up[i-1][j]+1; 
            }
            int a=r[i][j]-l[i][j]+1, b=min(a, up[i][j]);
            ans1=max(ans1, b*b);
            ans2=max(ans2, a*up[i][j]);
        }
    printf("%d\n%d\n", ans1, ans2);
    return 0;
}

```



---

## 作者：EricWay1024 (赞：1)

动态规划。

定义状态dp(i, j): 以(i, j)为右下角的最大矩形宽高。（结构体实现）

状态转移：

- 初值：dp(1,1)=(1,1)

- 对于最上一行的点来说, 矩形的高只能是1. 考虑宽: 如果它和左边的那个点同色, 宽只能是1; 否则, 是左边的那个点的宽+1.

- 最左一列的点同理.

- 考虑剩下的点. 

 1. 如果它和上面的点同色, 又和左边的点同色, 最大矩形的宽高是(1,1).
 
 1. 如果它和上面的点同色, 却和左边的点异色, 它就相当于最上一行的点.
 
 1. 如果它和上面的点异色, 却和左边的点同色, 它就相当于最左一列的点.
 
 1. 如果它和上面的点异色, 又和左边的点异色, 它面临两种选择:
 
 	1. "尽力地"并入**以自己左边的点为右下角的最大矩形**(简称为左边矩形). 所谓"尽力地", 是指采用左边矩形的宽+1作为自己的宽; 但是, 因为要考虑自己上面的那些点是否黑白相间, 自己的高可能比左边矩形的高要小. 自己上面的点是否黑白相间, 就要看**以自己上面的点为右下角的最大矩形**(上面矩形)的高度如何. 自己的高度应该是上面矩形的高度+1和左边矩形的高度取最小值.
    
    1. 尽力地并入上面矩形. 和上一种情况类似. 采用上面矩形的高+1作为自己的高; 自己的宽, 是左边矩形的宽+1和上面矩形的宽取最小值.
    
    	选择面积较大的那一种进行转移.

最后把整个dp表格遍历, 找到最大矩形面积和最大方形面积.

```cpp
#include<cstdio>
#include<iostream>
#include<ctime>
#define For(i,a,b) for(int i=a; i<=b; i++)
#define INF 0x3f3f3f3f
#define w(i,j) dp[i][j].w
#define h(i,j) dp[i][j].h
#define area(i,j)  (w(i,j)*h(i,j))
#define square(i,j) (w(i,j)==h(i,j))
#define N 2018
using namespace std;

inline int read(){
	int x=0; int sign=1; char c=getchar();
	while(c>'9' || c<'0') {if (c=='-') sign=-1;c=getchar();}
	while(c>='0' && c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
	return x*sign;
}

struct REC{
	int w; int h;

};

REC dp[N][N];
int n,m;
int map[N][N];

int main(){
#ifdef ERIC
    freopen("1169.in","r",stdin);
#endif
	n=read(), m=read();
	For(i, 1, n) For(j, 1, m) map[i][j]=read();

	w(1, 1)=1, h(1, 1)=1;
	
	For(i, 2, n){
		w(i, 1)=1;
		h(i, 1)=(map[i][1]!=map[i-1][1]? h(i-1, 1)+1: 1);
	}
	For(i, 2, m){
		h(1, i)=1;
		w(1, i)=(map[1][i]!=map[1][i-1]? w(1, i-1)+1: 1);
	}

	For(i, 2, n){
		For(j, 2, m){
			if (map[i][j]==map[i-1][j] && map[i][j]==map[i][j-1]){
				w(i, j)=h(i, j)=1;
			} else if (map[i][j]==map[i-1][j]){
				h(i, j)=1;
				w(i, j)=w(i, j-1)+1;
			} else if (map[i][j]==map[i][j-1]){
				w(i, j)=1;
				h(i, j)=h(i-1, j)+1;
			} else {
				int s1=(w(i, j-1)+1)*min(h(i, j-1), h(i-1, j)+1);
				int s2=(h(i-1, j)+1)*min(w(i-1, j), w(i, j-1)+1);
				if(s1>s2){
					w(i, j)=w(i, j-1)+1;
					h(i, j)=min(h(i, j-1), h(i-1, j)+1);
				} else {
					h(i, j)=h(i-1, j)+1;
					w(i, j)=min(w(i-1, j), w(i, j-1)+1);
				}
			}
		}
	}
	int ansa=1, ansb=1;
	For(i, 1, n){
		For(j, 1, m){
			if(square(i, j)) ansa=max(ansa, area(i, j));
			ansb=max(ansb, area(i, j));
		}
	}
	cout<<ansa<<endl<<ansb<<endl; 

    return 0;
}



```

---

## 作者：a41881147 (赞：1)

这里给出单调栈的做法



f[i][j]表示点(i,j)向左 最多能延伸多少 

首先dp(递推?.?)一下求出f[i][j]

f[i][j]=1+f[i][j-1]\*(a[i][j]^1==a[i][j-1]) 当前是0,前一个一定是1;当前是1,前一个是0


然后按照列i来算,对于每一列

从上到下扫一遍该列的每一行j,并且用一个单调栈维护

上一张原创的图:

图片（wok传不上去...T.T）

单调栈中要维护 每个元素的f[][] 自栈底到栈顶递增

stack[i]表示栈中第i个元素 在原序列中的 行数

(如图,斜线表示 因为蓝色或绿色元素的压入 而弹出栈的元素)

同时还要维护一个量up[],表示对于栈中的元素i,up[i]到stack[i]之间的元素(原序列)都<=i元    素的长度

如图中 蓝色和绿色元素的up

若当前点(j,i)和点(j-1,i)颜色不同,

若 f[j][i]>f[ stack[top] ][i]

栈顶向下能延伸到j-1,向上能延伸到up[top](因为栈中元素的长度f[][]是自底到顶递增的)

栈顶能构成的最大矩形就是 栈顶元素的长度\*(j-1-up[top]+1)

矩形和正方形,更新一下就行了.正方形的边长显然就是 栈顶元素的长度和j-up[top]的min

弹出栈顶,继续循环...


若当前点(j,i)和点(j-1,i)颜色相同,说明 j行无法 和j-1及其上面的行 构成符合要求的矩形

把栈弹空,然后 stack[top=1]=j...


每当处理完一列,栈都要弹空... 弹空不(tou)讲(lan)了吧(有代码~)


时间复杂度 O(n^2)


 
 
 


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define N 2009
using namespace std;
int n,m,a[N][N],f[N][N],ans1,ans2,stack[N],top,up[N];
void clear(int i)//弹空stack
{
    int max_down=stack[top];
    while (top)
        {
            ans1=max(ans1,(max_down-up[top]+1)*f[ stack[top] ][i]);
            ans2=max(ans2,min( max_down-up[top]+1,f[ stack[top] ][i] ));
            top--;
        }
}
int main()
{
    int i,j,k;
    cin>>n>>m;
    for (i=1;i<=n;i++)
        for (j=1;j<=m;j++)
            {
                scanf("%d",&a[i][j]);
                f[i][j]=1+f[i][j-1]*( a[i][j]^1==a[i][j-1] );
            }
    for (i=1;i<=m;i++)
        {
            top=0;
            for (j=1;j<=n;j++)
                if(j==1||a[j][i]^1==a[j-1][i])
                    {
                        int max_up=j;
                        while (top&&f[ stack[top] ][i]>f[j][i])
                            {
                                max_up=min(max_up,up[top]);//其实求up[]有点像递推...
                                ans1=max(ans1,f[ stack[top] ][i]*(j-up[top]) );
                                ans2=max(ans2, min( f[ stack[top] ][i],j-up[top] ) );
                                top--;       //这里ans2只记录了正方形de边长...
                            }
                        stack[++top]=j;
                        up[top]=max_up;
                    }
                else
                    {
                        clear(i);
                        stack[top=1]=j;//当前j无法和j-1构成矩形了,重新维护一个栈...
                        up[top]=j;
                    }
            clear(i);
        }
    cout<<ans2*ans2<<endl<<ans1<<endl;
}

```

---

## 作者：曹老师 (赞：0)

**~~暴力解法  点个赞再走呗~~**

## Sol ##

[blog食用](http://www.caolaoshi.men/index.php/archives/zjoi2007-qpzz.html)

暴力过ZJOI？ 不存在的。

好吧，的确是打的暴力，过了洛谷的水数据。对于每一个坐标(x,y)我们维护三个值：从该点开始向上和向左能达到的最远的点的坐标以及该点是黑是白。这样我们就能在枚举坐标的基础上只枚举行的范围，也就是从这个点开始，一直到最远的那个点，在枚举的过程中不断地更新最高点，不断地更新答案，值得注意的有：一定要在找每一列的时候更新答案，而不是求出最低的高度再更新答案，因为有反例，这里不列举了。还要注意的一点是：我们存的都是坐标而不是长度，因此我们在求解的时候需要把坐标相减求得长度，然后求答案就好了。

**时间复杂度：O(n^3)**

## Code ##

```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

struct Node {
	int h , l , b;
};
Node map[2005][2005];
int n , m , ans1 = 0 , ans2 = 0;

int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=m; i++)
		map[1][i].h = 1;
	for(int i=1; i<=n; i++)
		map[i][1].l = 1; 
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++) {
			scanf("%d",&map[i][j].b);
			map[i][j].b++;
			if(!map[i][j].l) {
				if(map[i][j - 1].b != map[i][j].b)
					map[i][j].l = map[i][j - 1].l;
				else
					map[i][j].l = j;
			}
			if(!map[i][j].h) {
				if(map[i - 1][j].b != map[i][j].b)
					map[i][j].h = map[i - 1][j].h;
				else
					map[i][j].h = i;
			}
		}
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++) {
			int mh = 0;
			for(int k=j; k>=map[i][j].l; k--) {
				if(map[i][k].h > mh)
					mh = map[i][k].h;
			int len1 = j - k + 1 , len2 = i - mh + 1 , s1 = len1 * len2 , s2 = min(len1 * len1 , len2 * len2);
			ans2 = max(ans2 , s2);
			ans1 = max(ans1 , s1);
			}
		}
	printf("%d\n%d",ans2,ans1);
	return 0;
}
```


  [1]: https://www.luogu.org/problemnew/show/P1169
  [2]: https://www.lydsy.com/JudgeOnline/problem.php?id=1057

---

## 作者：LittlePrincess (赞：0)

这道题标签是DP（我也是抱着刷dp的心态刷的这题），但是我看完题面之后却想不出dp咋写，反倒是骚操作O（n^2logn）卡过了。。。。。

首先对于一个可行的子矩阵，有两种可能性，第一个是行数加列数加1/0为奇数的棋盘 另一种则是偶数。

那么我们就可以对着两种情况合理枚举，我们枚举子矩阵的左边界，然后对于这个边界寻找最大矩形以及正方形。具体的方案是先用二维并查集维护每一列连续的区间（如图上横向的矩形就是一个个集合），然后我们如果知道对于一个矩形的长度，上下可以延伸几个格，也就是说如果i上方2格之后，该格子的长度小于了i的长度，那么如以i长度为矩形一边长往上可扩展的距离就是2 即l[i]=2，同理可得r[i]。如何O(n)枚举参照物i，更新答案。那么最关键的部分来了——如何求l r数组呢？我们可以先考虑，如果x是最长的，且无和x同长的矩形（a[i].w），那么l[i]=i-1,r[i]=i+1。所以我们就可以先排序，然后通过双向链表的删除操作维护该序列，这样每次删掉最大的，就能依次处理出所有l r。但是如果相邻两个元素相等呢（此处相邻是指链表中相邻）？队列。把相等的入队列，直到不等，全部弹出，时间复杂度O(2n)所以完全没问题。这个样子就可以O(n^2\*大常数\*logn）卡过了（^.^）!

![](http://img.blog.csdn.net/20170926232822598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUnVzdFN3b3JkX1JXWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

另附蒟蒻的题解链接：http://blog.csdn.net/rustsword\_rwz/article/details/78108234

上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MN 2050
int n,m,b[MN],fa[MN][MN],ha[MN][MN],lk1[MN],lk2[MN],l[MN],r[MN],ans=-2100000000,ans2=-2100000000;
struct lll{
    int w,pos;
}a[MN];
bool cmp(lll a,lll b)
{
    return a.w>b.w;
}
int find(int x,int y)
{
    return fa[x][y]==y?y:fa[x][y]=find(x,fa[x][y]);
}
void work(int _)
{
    for(int i=1;i<=n;i++) for(int j=1;j<=m+1;j++) fa[i][j]=j;
    for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
     {
         if((ha[i][j]+i+j)%2==_    ) 
        fa[i][find(i,j)]=find(i,j+1);
     }
    for(int j=1;j<=m;j++)
    {
        for(int i=1;i<=n;i++)
        {
            b[i]=a[i].w=find(i,j)-j;
            a[i].pos=i;lk1[i]=i+1;lk2[i]=i-1;
        }
        sort(a+1,a+1+n,cmp);
        for(int k=1;k<=n;k++)
        {
            int i=a[k].pos;
            l[i]=lk2[i];r[i]=lk1[i];
            lk1[lk2[i]]=lk1[i];
            lk2[lk1[i]]=lk2[i];
        }
        for(int i=1;i<=n;i++)
        {
            ans=max(ans,b[i]*(r[i]-l[i]-1));
            ans2=max(ans2,min(b[i]*b[i],(r[i]-l[i]-1)*(r[i]-l[i]-1)));
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
     cin>>ha[i][j];
    work(1);work(0);
    cout<<ans2<<endl<<ans;
    return 0;
}
```

---

## 作者：fy0123 (赞：0)

本题介绍一种神奇的做法。


首先按照下面各位大佬的做法，将横纵坐标和为偶数的点取反，a[i][j] ^= (i ^ j) & 1;。

于是问题就变为最大同色的正方形和矩形。

这个问题显然是用单调栈做。然而我写的是类似并查集的写法。

大致做法如下：

1.预处理出h[i][j]表示i,j这个点向右最大能扩展到的长度。这个O(n^2)就可以预处理出来。

2.我们枚举每一列作为矩形的底边，l[i]表示当前列第i个点向上能扩展到的父亲，r[i]同理表示向下能扩展到的父亲。

（这里为什么说是父亲呢，因为我们要用到并查集路径压缩的思想，先记录每个点的父亲，查询的时候顺便路径压缩）

3.第j列的n个点，我们按照h[i][j]的大小从大到小将点插入，原因是如果这个h[i][j]要作为矩形的一条边长的话，我们要保证它两边的h都大于等于它，如果小于则无法扩展。插入一个点之后，我们看一看它两边的点有没有已经插入，如果已经插入了就更新l[]和r[]。

这段代码长这样。k是当前的横坐标，vis[]就是记录当前点有没有插入。

```cpp
if (k > 1 && vis[k - 1] && a[k][j] == a[k - 1][j]){
    l[k] = k - 1; r[k - 1] = k;
}
if (k < n && vis[k + 1] && a[k][j] == a[k + 1][j]){
    l[k + 1] = k; r[k] = k + 1;
}
```
4.最后只要计算一下每个矩形的面积 = (getright(k) - getleft(k) + 1) \* h[k][j]。

这里的getleft和getright就用到了并查集里的找父亲的做法。

这就是找最大同色矩形的做法。

最大正方形其实只要对于每个矩形都算一下这个矩形里的最大正方形的面积就可以了，因为如果有一个正方形比原来的面积大，它肯定会被以上找矩形的过程中找到，这个很容易想通。


上面有些没看懂的可以看下完整代码再理解下~：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 2010;
int h[N][N], l[N], r[N], a[N][N];
bool vis[N];
int n, m;

struct Node{
    int len, id;
    bool operator < (const Node &other) const {
        return len > other.len;
    }
}tmp[N];

inline int getleft(int v)
{
    return l[v] == v ? v : l[v] = getleft(l[v]);
}

inline int getright(int v)
{
    return r[v] == v ? v : r[v] = getright(r[v]);
}

void solve()
{
    int ans1 = 0, ans2 = 0;
    for (int i = 1; i <= n; i ++){
        h[i][m] = 1;
        for (int j = m - 1; j >= 1; j --)
            if (a[i][j] == a[i][j + 1]) h[i][j] = h[i][j + 1] + 1;
            else h[i][j] = 1;
    }
    for (int j = 1; j <= m; j ++){
        for (int i = 1; i <= n; i ++){
            tmp[i].len = h[i][j];
            tmp[i].id = i;
            vis[i] = 0;
            l[i] = r[i] = i;
        }
        sort(tmp + 1, tmp + n + 1);
        for (int i = 1; i <= n; i ++){
            int k = tmp[i].id;
            vis[k] = 1;
            if (k > 1 && vis[k - 1] && a[k][j] == a[k - 1][j]){
                l[k] = k - 1; r[k - 1] = k;
            }
            if (k < n && vis[k + 1] && a[k][j] == a[k + 1][j]){
                l[k + 1] = k; r[k] = k + 1;
            }
            int a = getright(k) - getleft(k) + 1;
            int b = tmp[i].len;
            ans1 = max(ans1, min(a, b) * min(a, b));
            ans2 = max(ans2, a * b);
        }
    }
    printf("%d\n%d\n", ans1, ans2);
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++){
            scanf("%d", &a[i][j]);
            a[i][j] ^= (i ^ j) & 1;
        }
    solve();
    return 0;
}
```

---

## 作者：Tgotp (赞：0)

思路： dp （做了好久，还是太弱了）

做法：求出每个点开始的最大高度及向左向右扩展的最大长度，然后从每个点开始枚举求出ans1，ans2；

注意：求得l，r包含了该点，所以操作时要 -1；


c++代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 2e3 + 2;
int map[N][N],l[N][N],r[N][N],h[N][N],n,m,ans1,ans2;
inline void read(int&x)
{
    x = 0;int sign = 1;char c;
    do{ c = getchar();if(c == '-')sign = -1; } while(c < '0' || c >'9');
    do{ x = x*10 + c - '0';c = getchar();}     while(c <= '9' && c >='0');
    x *= sign;
}
int main()
{
    read(n);read(m);
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= m;j++)
            read(map[i][j]);
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++)
            if(map[i][j] != map[i][j-1]) l[i][j] = l[i][j-1] + 1;
            else  l[i][j] = 1;
        for(int j = m;j ;j--)
            if(map[i][j] != map[i][j+1]) r[i][j] = r[i][j+1] + 1;
            else  r[i][j] = 1;
    }
    for(int i = 2;i <= n;i++)
        for(int j = 1;j <= m;j++)
            if(map[i][j] != map[i-1][j])
            {
                h[i][j] += h[i-1][j] + 1;
                l[i][j] = min(l[i][j],l[i-1][j]);
                r[i][j] = min(r[i][j],r[i-1][j]);
            }
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= m;j++)
        {
            int tmp = min(h[i][j]+1,l[i][j] + r[i][j] - 1);
            ans1 = max(ans1,tmp * tmp);
            ans2 = max(ans2,(h[i][j] + 1) * (l[i][j] + r[i][j] - 1));
        }
    cout<<ans1<<endl<<ans2<<endl;
    return 0;
}
推广blog：<http://tgotp.science>
```

---

## 作者：attack (赞：0)

我的做法参考了底部某位大神，并且补全了他给出的不完整的代码


这道题目有两问，第一问的难度大约是普及


第二问大约是省选-


首先我们考虑读入，我们让a[i][j]^=(i^j)&1;


这样我们就把题目转换成了求最大相同值的正方形&&矩形问题


1.对于正方形

我们只需要判断他的上，左，左上三个方向即可

方程:

```cpp
1 dps[i][j]=min
2      (
3          min(dps[i-1][j-1],dps[i][j-1]),
4     　 min(dps[i-1][j-1],dps[i-1][j])    
5      )+1;
```
前提条件：
1 a[i][j]==a[i][j-1]&&a[i][j]==a[i-1][j-1]&&a[i][j]==a[i-1][j]


2.对于矩形

我们用dpr1表示在每一个点处，向上枚举相同的值所能到达的最长长度

dpr2表示在每一个点处，向下枚举相同的值所能到达的最长长度

（悬线算法）


然后我们可以暴力枚举行和列，

对于每一列，dpr1和dpr2必须每次都取最小值（保证相同颜色）


答案的更新：

 1 ans2=max(ans2,(j-maxlong+1)\*(maxup+maxdown-1)); 

用当前的列减去在它之前的‘最后一个不同的值+1’（也就是maxlong）\* 最大的上下边界


顺便提醒一句，这道题数据比较水，在洛谷上能AC不代表能在比赛中AC


    
    
    
    
        
    
    
    
    
        
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int MAXN=2001;
int a[MAXN][MAXN];
int read(int & n)
{
    int flag=0,x=0;char c='/';
    while(c<'0'||c>'9'){c=getchar();if(c=='-')flag=1;}
    while(c>='0'&&c<='9')x=x*10+(c-48),c=getchar();
    if(flag)n=-x;else n=x;
}
int n,m;
int dps[MAXN][MAXN];
int dpr1[MAXN][MAXN];
int dpr2[MAXN][MAXN];
int ans1,ans2;
void square()
{
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            dps[i][j]=1;        
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
        {
            if(a[i][j]==a[i][j-1]&&a[i][j]==a[i-1][j-1]&&a[i][j]==a[i-1][j])
            {
                dps[i][j]=min
                         (
                          min(dps[i-1][j-1],dps[i][j-1]),
                          min(dps[i-1][j-1],dps[i-1][j])    
                         )+1;          
                ans1=max(dps[i][j],ans1);
            }
        }
    printf("%d\n",ans1*ans1);
}
void rectangle()
{
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            dpr1[i][j]=dpr2[i][j]=1;
    for(int i=1;i<n;i++)
        for(int j=0;j<m;j++)
        if(a[i][j]==a[i-1][j])
            dpr1[i][j]=max(dpr1[i][j],dpr1[i-1][j]+1);
    for(int i=n-2;i>=0;i--)
        for(int j=0;j<m;j++)
        if(a[i][j]==a[i+1][j])
            dpr2[i][j]=max(dpr2[i][j],dpr2[i+1][j]+1);
    ans2=1;
    //print();
    for(int i=0;i<n;i++)
    {
        int maxup=dpr1[i][0];
        int maxdown=dpr2[i][0];
        int maxlong=0;
        for(int j=0;j<m;j++)
        {
            ans2=max(ans2,(j-maxlong+1)*(maxup+maxdown-1));
            if(j==m-1)
            break;
            if(a[i][j]!=a[i][j+1])
            {
                maxlong=j+1;
                maxup=dpr1[i][j+1];
                maxdown=dpr2[i][j+1];
            }
            else
            {
                maxup=min(maxup,dpr1[i][j+1]);
                maxdown=min(maxdown,dpr2[i][j+1]);
            }
        }
    }
    printf("%d",ans2);
}
int main()
{
    //freopen("makechess.in","r",stdin);
    //freopen("makechess.out","w",stdout);
    read(n);read(m);
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
        {
            read(a[i][j]);
            a[i][j]^=(i^j)&1;
        }
    square();
    rectangle();
    return 0;
}

```

---

## 作者：QWsin (赞：0)

很感谢楼下的题解= =瞬间秒懂

当然楼下的楼下的单调栈我只能%%%

预处理这个东西很蛋疼 = =想不到就只有n^6暴力了

正方形还是比较好求

我也来说说长方形= =

预处理出向上和向下的延伸个数

然后每一行枚举

上下延伸长度取min再乘以连续个数就是面积了

我只是觉得我的枚举以及算最大值的过程比较简洁一些= =

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=2000+10;
const int INF=(1<<30);

int map[maxn][maxn];
int dp1[maxn][maxn],dp0[maxn][maxn];
int n,m;

void read(int &x)
{
    x=0; char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar());
    for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
}

void init_data()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
      {
          read(map[i][j]);
          if((i+j)%2==0) map[i][j]=!map[i][j];
      }
}

int z()
{
    int ret=0;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;ret=max(ret,dp1[i][j]),j++)
        if(i>1&&j>1&&map[i][j]==map[i][j-1]&&map[i][j-1]==map[i-1][j]&&map[i-1][j]==map[i-1][j-1])
          dp1[i][j]=min(dp1[i-1][j-1],min(dp1[i-1][j],dp1[i][j-1]))+1;
        else dp1[i][j]=1;
    return  ret*ret;
}

int up[maxn][maxn],down[maxn][maxn];
int c()
{
    int ret=0,upmax,downmax;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        if(i>1&&map[i][j]==map[i-1][j])
          up[i][j]=up[i-1][j]+1;
        else up[i][j]=0;
    for(int i=n;i>=1;i--)
      for(int j=1;j<=m;j++)
        if(i<n&&map[i][j]==map[i+1][j])
          down[i][j]=down[i+1][j]+1;
        else down[i][j]=0;
    int cnt=0;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
      {
          if(j>1&&map[i][j]==map[i][j-1]) cnt++;
          else 
        {
              cnt=1;upmax=INF;downmax=INF;
        }
          upmax=min(upmax,up[i][j]);
          downmax=min(downmax,down[i][j]);
          ret=max(ret,cnt*(upmax+downmax+1));
      }
    return ret;
}

int main()
{
    init_data();
    printf("%d\n",z());
    printf("%d\n",c());
    return 0;    
}

```(c/c++)


---

## 作者：HOOCCOOH (赞：0)

先O(n^2)预处理，变成寻找最大同色正方形、矩形。只用对每个点进行arr[i][j]^=(i^j)&1就行了。

第一问DP比较裸，令f[i][j]表示(0,0)-(i,j)的最大正方形边长

若arr[i][j]=arr[i-1][j]=arr[i][j-1]=arr[i-1][j-1]

则f[i][j]=1+min{f[i-1][j],f[i][j-1],f[i-1][j-1]}

否则f[i][j]=1

边界f[0][j]=f[i][0]=1

答案就是最大f[i][j]的平方

第二问有点麻烦，楼下的二维单调队列特别厉害，然而本蒟蒻并没有听懂。我是先dp预处理，令f1[i][j]是(i,j)向上找连续的相同颜色数量，则f1[i][j]=(arr[i][j]==arr[i-1][j]?f1[i-1][j]+1:1)，还是比较显然的，f2是向下找连续的相同颜色数量，计算方法和f1一样。

然后枚举行，对于每行中的一段同色区间，计算它上下延展的最大矩形，这个矩形的高显然就是这段区间中f1最小值+f2最小值-1，然后问题就解决了。

我们只用维护当前枚举到的f1、f2的最小值，在每行末尾或arr[i][j]!=arr[i][j-1]时更新ans即可

因为代码比较长，所以只贴上求第二问的代码

```cpp

/*
const int N = 2003;
int n, m, ans;
bool arr[N][N];
int f1[N][N], f2[N][N];
*/
    for(int i = 0; i < n; ++i)
        for(int j = 0; j < m; ++j)
            f1[i][j] = f2[i][j] = 1;
    
    for(int i = 1; i < n; ++i)
        for(int j = 0; j < m; ++j)
            if(arr[i][j] == arr[i - 1][j])
                f1[i][j] = max(f1[i][j], f1[i - 1][j] + 1);
    for(int i = n - 2; i >= 0; --i)
        for(int j = 0; j < m; ++j)
            if(arr[i][j] == arr[i + 1][j])
                f2[i][j] = max(f2[i][j], f2[i + 1][j] + 1);
    ans = 1;
    for(int i = 0; i < n; ++i)
    {
        int c1 = f1[i][0], c2 = f2[i][0];
        int ibeg = 0;
        for(int j = 0; j < m; ++j)
        {
            ans = max(ans, (j - ibeg + 1) * (c1 + c2 - 1));
            if(j == m - 1)
                break;
            if(arr[i][j] != arr[i][j + 1])
            {
                c1 = f1[i][j + 1];
                c2 = f2[i][j + 1];
                ibeg = j + 1;
            }
            else
            {
                c1 = min(c1, f1[i][j + 1]);
                c2 = min(c2, f2[i][j + 1]);
            }
        }
    }
    printf("%d\n", ans);

```

---

## 作者：kiddingme12138 (赞：0)

这题正解单调栈，但是我太弱了，没想到。。。脑补了一个新的做法，好像这类题都可以这么做，感觉很暴力啊

先是标准的悬线法，记录到第j列时，1~n行分别最多可以往左延伸多少，记为height[i]（这步对于每列可以O(n)更新）

然后，正解是用单调栈维护对于每个第i行，最小的j并满足height[j~i-1]都>=height[i]，即都可以和第i行一起选，实时维护ans即可

我用的是带权并查集，按height[i]从大到小加入，维护每个连通段的信息。考虑每次加入一条边，只有它连起来的两端信息会改变，所以实时维护ans是n*O(1)，（这类题）一定可以用基数排序，总共就是O(n^2)

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
inline int readin()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}
inline int getmin(int n1,int n2){return n1<n2?n1:n2;}
inline int getmax(int n1,int n2){return n1>n2?n1:n2;}
const int maxn=2005,inf=0x3f3f3f3f;
int n,m,a[maxn][maxn],f[maxn][maxn],ans1=1,ans2=1;
int height[maxn],sum[maxn],x[maxn],sa[maxn],fa[maxn],l[maxn],mark[maxn];
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int main()
{
	n=readin(),m=readin();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=readin();
	for(int i=1;i<=n;i++) f[i][1]=1;
	for(int i=1;i<=m;i++) f[1][i]=1;
	for(int i=2;i<=n;i++)
		for(int j=2;j<=m;j++)
		{
			if(a[i][j]==a[i-1][j]||a[i][j]==a[i][j-1]||a[i][j]!=a[i-1][j-1]) 
				f[i][j]=1;
			else f[i][j]=getmin(f[i-1][j-1],getmin(f[i-1][j],f[i][j-1]))+1;
			ans1=getmax(f[i][j],ans1);
		}
	printf("%d\n",ans1*ans1);
	for(int j=1;j<=m;j++)
	{
		for(int i=1;i<=m;i++) sum[i]=0;
		for(int i=1;i<=n;i++) sum[height[i]=(a[i][j]^a[i][j-1])?height[i]+1:1]++;
		for(int i=1;i<=m;i++) sum[i]+=sum[i-1];
		for(int i=n;i>=1;i--) sum[height[i]]--,sa[n-sum[height[i]]]=i;
		for(int i=1;i<=n+1;i++) fa[i]=l[i]=i,mark[i]=0;
//		for(int i=1;i<=n;i++) cout<<height[sa[i]]<<" ";
//		cout<<endl;
		for(int i=1;i<=n;i++)
		{
			
			if(a[sa[i]][j]==a[sa[i]+1][j])
			{
				mark[sa[i]]=1;
				ans2=getmax(ans2,height[sa[i]]*(sa[i]+1-l[sa[i]]));
			}
			else
			{
				int f1=find(sa[i]),f2=find(sa[i]+1);
				fa[f1]=f2,l[f2]=l[f1];
				ans2=getmax(ans2,height[sa[i]]*(f2+mark[f2]-l[f2]));
			}
		}
	}
	printf("%d\n",ans2);
}
```

---


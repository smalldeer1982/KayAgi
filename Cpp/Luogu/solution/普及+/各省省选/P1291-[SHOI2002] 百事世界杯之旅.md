# [SHOI2002] 百事世界杯之旅

## 题目背景

“……在 2002 年 6 月之前购买的百事任何饮料的瓶盖上都会有一个百事球星的名字。只要凑齐所有百事球星的名字，就可参加百事世界杯之旅的抽奖活动，获得球星背包，随声听，更可赴日韩观看世界杯。还不赶快行动！”

## 题目描述

你关上电视，心想：假设有 $n$ 个不同的球星名字，每个名字出现的概率相同，平均需要买几瓶饮料才能凑齐所有的名字呢？

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 33$。

## 样例 #1

### 输入

```
2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
17```

### 输出

```
  340463
58------
  720720```

# 题解

## 作者：ButterflyDew (赞：149)

我确信洛谷和网上的题解大部分都是错的，少部分是对的的也并没有说清楚。

比如说这个题极限的思想，我没有看到一个提出来的。

**首先得明白一点，当已经买到所有的名字以后，是不需要再买的。针对于子问题也这样想。**

从两个方面分别具体说说这个题目。

[欢迎来博客阅读~](https://www.cnblogs.com/ppprseter/p/9376392.html)

一、对每一步暴力极限求解。

令$f[i]$表示已经买到$i$个球星的期望购买次数。

我们由$f[i]$推$f[i+1]$

下一次购买可以买到不同球星的概率是$\frac{n-i}{n}$

下两次购买可以买到不同球星的概率是$\frac{i}{n} \times \frac{n-i}{n}$ 注意到这时第一次买到的情况已经忽略了

...

下$k$次购买可以买到不同球星的概率是$(\frac{i}{n})^{k-1} \times \frac{n-i}{n}$

假设第$k$次就是正无穷次

则此步的期望即为

## $E=1 \times \frac{n-i}{n}+2 \times \frac{i}{n} \times \frac{n-i}{n}+3 \times (\frac{i}{n})^2 \times \frac{n-i}{n}+...+k \times (\frac{i}{n})^{k-1} \times \frac{n-i}{n}$

则有

## $\frac{i}{n} \times E=1 \times \frac{i}{n} \times \frac{n-i}{n}+2 \times (\frac{i}{n})^2 \times \frac{n-i}{n}+3 \times (\frac{i}{n})^3 \times \frac{n-i}{n}+...+k \times (\frac{i}{n})^k \times \frac{n-i}{n}$
 
错位相减

## $E\approx 1+\frac{i}{n}+(\frac{i}{n})^2+...(\frac{i}{n})^{k-1}$
 
此步中采用极限的思想丢了一些$0$的项,用“$\approx$”表示采用极限思想，实际上极限是准确值，不需要“$\approx$”，此处只是为了标示，下同。

由等比数列公式

## $E=1+\frac{\frac{i}{n}-(\frac{i}{n})^k}{\frac{n-i}{n}}$

## $\approx \frac{n}{n-i}$

所以我们得出
## $f[i+1]=f[i]+\frac{n}{n-i}$

则

## $f[n]=n \times (\frac{1}{1}+\frac{1}{2}+...+\frac{1}{n})$


二、神奇的自己推自己的方法

同样令$f[i]$表示已经买到$i$个球星的期望购买次数。

如果从上一个推过来，为

## $f[i]+=(f[i-1]+1)\times \frac{n-(i-1)}{n}$

如果从当前推过来，为

## $f[i]+=(f[i]+1)\times \frac{i}{n}$

发现概率之和并不等于1，也就是说，这样写是有问题的。

从上一个推过来肯定没问题，我们考虑从当前推当前的意义。

“买了一个，买的是自己有的的概率”

然而我们考虑最开始说的一句话

“当已经买到所有的名字以后，是不需要再买的。”

也就是说，我们这样写可能把自己买了很多遍，而事实上是并不需要再买的。

于是我们修改一下意义

为“买了一个，买的是自己有的且不是自己的概率”

则推过来就是

## $f[i]+=(f[i]+1)\times \frac{i-1}{n}$

那我们这个什么时候买呢？

极限的思想，在最后买时，对期望的影响是微乎其微的

把这两项加起来并化简

就得到了

## $f[i]=f[i-1]+\frac{n}{n-i+1}$

和上一个方法的结果是一样的

关于合并两个值并不是一样的$f[i]$，用的也是极限的思想

---

## 作者：Hydra_ (赞：49)

### 分析 ###

这道题目用期望的语言来说就是：“我们期望买多少饮料能够搞到所有的奖品”。


这道题目我们可以采用递推求数学期望的方法。我们设$f(n,k)$是一共有n个球星，而且现在还剩下k个球星没有收集到，还需要购买饮料的期望次数。所以我们最后要求取的答案是$f(n,0)$。


假设我们现在推到了$f(n,k)$，我们再买一瓶饮料，有两种可能性，一种是：我们买到了我们没有拥有的球员，那么剩下的子问题就是$f(n,k-1)$；如果买到了我们拥有的球员，那么剩下的子问题就是$f(n,k)$。然而我们任意买一个瓶盖，有$\frac k n$的可能性买到我们没有的，有$\frac {n-k} n$的可能性买到我们已经有的。所以这道题目的递推是就是：

$$f(n,k)=\frac {(n-k)f(n,k)}n+ \frac{kf(n,k-1)}n+1$$然后呢，经过移项，会有$$f(n,k)=f(n,k-1)+\frac nk$$这就是一个递推式了。


###代码###


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long p,q=1,r;
inline int cc(long long x)//cc函数用来统计数x的位数
{
    int p=0;//p用来记录最后的答案
    while(x>0)
    {
        x/=10;
        p++;
    }//非常小儿科的求位数
    return p;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        p=p*i+q*n;
        q*=i;
        //递推
        r=__gcd(p,q);
        /*__gcd函数。这是一个库函数，是用来求
        两个数的最大公约数的。但是由于功能过于
        强大，ccf已经规定了：所有下划线开头的
        库函数都不能在oi中使用。*/
        p/=r;
        q/=r;//分数的约分。
    }//这部分是用来求最后结果的，p放分子，q放分母
    r=p/q;
    p%=q;
    /*把这个分数化成带分数的形式，r存放整数部分，
    p和q放分子和分母。*/
    if(p==0)
    {
        printf("%lld\n",r);
        return 0;
    }//如果分子为0，就说明答案是整数，直接输出整数部分
    for(int i=1;i<=cc(r);i++)
    printf(" ");
    //为了对齐补充的空格。

    if(r>0)
    printf("%lld",r);
    //这里要慎重：如果p==0，则不用输出
    
    for(int i=1;i<=cc(q);i++)
    printf("-");
    //分数线长度是分母的长度
    printf("\n");
    
    for(int i=1;i<=cc(r);i++)
    //为了对齐补充的空格。
    printf("%lld\n",q);
    return 0;
}
```

---

## 作者：Zenith_Yeh (赞：28)

这是一道很考验数学的题。

首先得会数学期望([传送门](https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/5362790))

下面开始证明:

我们假设我们手中已有了x个球星的瓶盖，则要想拿到这x个之外的瓶盖的概率为 $\frac{1}{n-x}$，就需要买n*$\frac{1}{n-x}$次。

将所有的加起来就是n* $\sum_{x=1}^n\frac{1}{n-x} $ 。化简之后n*($\frac{1}{1}$+$\frac{1}{2}$+$\frac{1}{3}$+...+$\frac{1}{n}$) 。

下面是AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,anszheng,ansmother=1,ansson;	
long long gcd(long long a,long long b)//最大公约数，用于通分
{	if(a==0)return b;
	return gcd(b%a,a);
}
long long ws(long long x)//由于题目的毒瘤输出，带分数后面的分数要控制位数
{	long long ans=0;
	while(x!=0)
	{	ans++;
		x/=10;
	}
	return ans;
}
int main()
{	cin>>n;
	for(register long long i=1;i<=n;++i)
	{	ansson=ansson*i+ansmother;//将分数加上
		ansmother=i*ansmother;
		long long gcdd=gcd(min(ansmother,ansson),max(ansmother,ansson));//求出最大公约数
		ansmother/=gcdd;//约分
		ansson/=gcdd;
	}
	ansson*=n;
	anszheng=ansson/ansmother;
	ansson%=ansmother;
	long long gcdd=gcd(min(ansmother,ansson),max(ansmother,ansson));//由于分子乘上n之后可能又可以与分母约分，所以在进行一次约分
	ansmother/=gcdd;
	ansson/=gcdd;
	if(ansson==0)//如果分子为0，则直接输出带分数的整数部分
	{	printf("%lld",anszheng);
		return 0;
	}
	//输出分三行，分别为：分子，整数部分与分数线，分母
	for(int i=1;i<=ws(anszheng);++i)printf(" ");//分子前面的空格，空格长度为整数部分的位数
	printf("%lld\n",ansson);
	printf("%lld",anszheng);
	for(int i=1;i<=ws(ansmother);++i)printf("-");//分数线长度为分母的位数
	printf("\n");
	for(int i=1;i<=ws(anszheng);++i)printf(" ");//分母前面的空格，空格长度为整数部分的位数
	printf("%lld",ansmother);
	return 0;
}
```


---

## 作者：ASC_8384 (赞：27)

更容易理解：

如果现在已经有了x个名字，那么使名字达到x+ 1平均需要n / (n - x)瓶。

所以从没有名字开始，直到凑齐，共需要n \* (1/1 + 1/2 + ··· + 1/n)——求调和级数


---

## 作者：COUPDETAT (赞：10)

这道题是一道期望题 十分巧妙

下面是我蒟蒻的思路

如果手里已经有了k种 那么买到另外一种的概率就是1/(n-k)

就需要买n(1/n-k)次

所以一共就要买n(1/1+1/2+...+1/(n-1)+1/n)次

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n;
long long p=1,q=1,r;
long long gcd(long long a,long long b)
{
    if(b==0)
        return a;
    gcd(b,a%b);
}
int cal(long long x)
{
    int p=0;
    while(x>0)
    {
        x/=10;
        p++;
    }
    return p;
}
int main()
{
    cin>>n;
    p=n;
    for(int i=2;i<=n;i++)
    {//处理分子分母 及时约分
        long long fm=q*i;
        long long  fz1=p*i,fz2=n*q;
       //cout<<fz1<<endl<<fz2;
        long long  fz=fz1+fz2;
        long long  k=gcd(fz,fm);
        fz/=k;fm/=k;
        q=fm;
        p=fz;
    }
    //cout<<p<<q;
    r=p/q;
    if(q==1)
        printf("%d\n",p);
    else
    {
        for(int i=cal(r);i>0;i--)
            cout<<" ";
        printf("%lld\n",p%q);

        if(r>0)
            printf("%lld",r);
        for(int i=cal(q);i>0;i--)
            cout<<"-";
        putchar('\n');

        for(int i=cal(r);i>0;i--)
            cout<<" ";;
        printf("%lld\n",q);
    }
    return 0;
}
```


---

## 作者：公主殿下MIKU (赞：10)

数学期望模板题，不知道数学期望的[点这里](https://baike.baidu.com/item/数学期望/5362790?fr=aladdin)

得到第一个不同的名字需要1次，

得到第二个不同的名字需要N/（N-1）次 ，

因为只需与第一个名字不同即可， 
概率是（N-1）/N，需要N/（N-1）次，

得到第三个不同名字需要N/（N-2）次，

······

得到第N个不同名字需要N/1次，

最后需要次数期望=1+N/（N-1）+N/（N-2）+···N/3+N/2+N/1 次。

直接求分数和就行，最后处理一下输出就行

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define int long long
using namespace std;
int read() {
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0') {
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
void write(int x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
void w(int x)
{
	write(x);
	putchar('\n');
}
int n;
int ans,a=0,b=1,u;
int num(int x)//求整数位数
{
	int sum=0;
	while(x)
	{
		sum++;
		x/=10;
	}
	return sum;
}
signed main() {
	n=read();
	for(int i=n; i; i--) {//模拟分数通分相加过程，将其转换为带分数，a为分子，b为分母，ans为整数部分
		b=b*i;
		a=a*i+n*b/i;
		u=__gcd(a,b);
		a/=u;
		b/=u;
		ans+=a/b;
		a%=b;
	}
	if(a==0)
	{
		write(ans);//分子为零，结果为整数
	}
	else 
	{
		if(ans==0) //真分数，整数部分为零（这部分好像不用要，因为一个名字就需要1次，整数部分一定不为零）
		{
			int wi=num(b);
			w(a);
			for(int i=1;i<=wi;i++)
			putchar('-');
			putchar('\n');
			write(b);
		}
		else 
		{
			int wi1=num(ans),wi2=num(b);
			for(int i=1;i<=wi1;i++)
			putchar(' ');//将整数部分空出来，保证分子与分数线左端对齐
			w(a);
			write(ans);
			for(int i=1;i<=wi2;i++)
			putchar('-');
			putchar('\n');
			for(int i=1;i<=wi1;i++)//保证分母与分数线左端对齐
			putchar(' ');
			write(b);
		}
	}
	return 0;
}
```
### 华丽的结束

----

---

## 作者：Immortal_Bird (赞：7)

- [P1291 [SHOI2002]百事世界杯之旅](https://www.luogu.com.cn/problem/P1291)

---
$$SOL1->$$

经典的伯努利试验的几何分布

![](https://cdn.luogu.com.cn/upload/image_hosting/nganr4c9.png)



假设我们已经买到了$i$瓶，考虑买下一瓶

则下一次买到不同的概率是$\frac{n-i}{n}$

则下两次买到不同的概率$\frac{i}{n}\times \frac{n-i}{n}$


......

则下$inf$次买到不同的概率是$(\frac{i}{n})^{inf-1}\times \frac{n-i}{n}$

则买进$i+1$的期望就是

$$E[i+1] = \sum_{k=1}^{inf}k\times (\frac{i}{n})^{k-1}\times \frac{n-i}{n}$$


然后根据高中的求数列的方法，化成通项
两边同乘$\frac{i}{n}$
$$\frac{i}{n} \times E[i+1] = \sum_{k=1}^{inf}k\times (\frac{i}{n})^{k}\times \frac{n-i}{n}$$


上述两式错位相减

$$E[i+1]=\sum_{k=1}^{inf}({\frac{i}{n}})^{k-1}$$

这是一个等比数列，我们考虑化简，得到

$$E[i+1]=\frac{n}{n-i}$$
即
$$E[i]=\frac{n}{n-(i-1)}$$

根据期望的公式$E=\sum E[i]$，
所以设$f[i]$是取完$1->i$所有瓶的期望，

$f[i]=f[i-1]+\frac{n}{n-(i-1)}$

即整个期望式子就是

$$E=n\times \sum_{i=1}^{n}\frac{1}{n-i+1}$$


---
$$SOL->2$$

推式子

假设我们剩下$i$个**没取**，取完所需要的希望，则

$$f[i]=\frac{(n-i)f[i]}{n}+\frac{i\times f[i-1]}{n}+1$$

化简，

$$f[i] = f[i-1]+\frac{n}{i}$$

最终答案为$f[n]$，即准备买$n$个的期望。

注意$SOL1$求的是已经买了$n$个的情况。


----
---

$$SOL->3$$

推式子

假设我们取完$0->i$瓶子，再**全部取完**剩下的期望

显然$f[n]=0$

考虑$f[i]$

有两种可能：$P=\frac{i}{n}$的概率取当前数($f[i]$)，或$P=\frac{n-i}{n}$取到没有的($f[i+1]$)。

根据期望的可加性，我们有以下式子

$$f[i]=\frac{i}{n}\times f[i]+\frac{n-i}{n}\times f[i+1]+1$$

化简

$$f[i]=f[i+1]+\frac{n}{n-i}$$

最终答案是$f[0]$

---

update: 补充了一点内容

---

## 作者：龙神哈迪斯 (赞：7)

题解
===

貌似之前楼上的题解的公式虽然推的大概是对的，但是讲解是错的而且就连$i$ 的范围也是错的(~~真是尴尬~~)

我考虑的是以$f[i]$表示已经得到其中$i$个物品，还需得到$n-i$然后所期望的平均次数，最后答案在$f[0]$中

那么，你可能会列出如下两种转移方程式
一:由$f[i-1]$推到$f[i]$
$$f[i]=\frac{i}{n}*f[i]+\frac{n-i+1}{n}*f[i-1]+1$$
二:由$f[i+1]$推到$f[i]$
$$f[i]=\frac{i}{n}*f[i]+\frac{n-i}{n}*f[i+1]+1$$
所以大家应该发现你考虑**正着推**和**倒着推**是不一样的，那么

Q:哪种方式才是对的呢

A:显然方式二啊

Q:qwq，大佬说说为什么吧

A:首先方案二中的`+1`才有道理，其本质是$\frac{i}{n}$+$\frac{n-i}{n}$=1
这才是正确的期望=贡献*概率，然而方案一中的$+1$毫无道理，你究竟是在计算$f[i]$ 还是$f[i-1]$时加的呢?

Q:好像还是不太懂啊

A:好吧，在终止状态唯一确定时，你会发现倒着推才能表示出全部方案，即并不是我一旦收集到$n$ 个瓶子就停下，而是还可能可有由它自己推到或者经过一番环之后再推到

Q:好啊(我最喜欢记结论了)，但是环是什么意思？大佬

A:你没发现具有递推关系的期望dp就是一个图吗?边有边权，上个状态与本步状态之前存在连边，可能一些特殊的图还有环等其他的性质

Q:哦！好像yy出来了，谢谢大佬

A:#@(U)#@E

由上文发现，
$$f[i]=\frac{i}{n}*f[i]+\frac{n-i}{n}*f[i+1]+1$$
经过一波合并同类项并约分后
$$f[i]=\frac{n}{n-i}+f[i+1]$$
再将i=i-1代入
$$f[i-1]=\frac{n}{n-i+1}+f[i]$$
由于是倒着推的，现在已知$f[i]$，推的$f[i-1]$，那么答案不就是
$$\sum_{i=1}^{n}\frac{1}{n-i+1}$$

这就是答案，真简单

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define ll long long 
inline int read()
{
	char ch='!';int z=1,num=0;
	while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
	if(ch=='-')z=-1,ch=getchar();
	while(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return z*num;
}
ll n;
ll gcd(ll a,ll b)
{
	if(!b)return a;
	else return gcd(b,a%b);
}
ll js(ll x)
{
	ll cnt=0;
	while(x)
	{
		x/=10;
		cnt++;
	}
	return cnt;
}
int main()
{
	n=read();
	if(n==1){puts("1");return 0;}
	if(n==2){puts("3");return 0;}
	ll f1=3,f2=2;
	for(int i=3;i<=n;++i)
	{
		ll c=gcd(f2,i);
		ll lcm=f2*i/c;
		ll d1=lcm/f2,d2=lcm/i;
		f1=f1*d1+d2;
		c=gcd(f1,lcm);
		f1/=c;f2=lcm/c;
	}
	f1*=n;
	ll c=gcd(f1,f2);
	f1/=c;f2/=c;
	ll k=f1/f2;
	ll a1=js(k);
	if(!f1)
	{
		cout<<k<<endl;
	}
	else
	{
		ll a2=js(f2);
		for(int i=1;i<=a1;++i)
			cout<<' ';
		cout<<f1%f2<<endl;
		if(k>=1)cout<<k;
		for(int i=1;i<=a2;++i)
			cout<<'-';
		cout<<endl;
		for(int i=1;i<=a1;++i)
			cout<<' ';
		cout<<f2<<endl;
	}
	return 0;
}

```


---

## 作者：wanghanjun (赞：5)

考虑到每个名字都是对称的，可以直接设f[i]为出现i个名字时期望买的瓶数。

如果已经出现了i个名字，那么再出现一个不同的名字的期望开瓶数是1 * 下一次出现的概率 + 2 * 下一次没出现但接下来一次出现的概率 + 3 * 下两次没有出现的接下来一次出现的可能性1……

写出来就是这个样子：

$$f_{i+1}=f_{i}+1*\frac{(n-i)}{n}+2*\frac{i}{n}*\frac{(n-i)}{n}+3*(\frac{i}{n})^2*\frac{(n-i)}{n}+...$$

将分子展开，得

$$f_{i+1}=f_{i}+1-1*\frac{i}{n}+2*\frac{i}{n}-2*(\frac{i}{n})^2+3*(\frac{i}{n})^2-3*(\frac{i}{n})^3+...$$

整理，得

$$f_{i+1}=f_{i}+1+\frac{i}{n}+(\frac{i}{n})^2+(\frac{i}{n})^3+...=f_{i}+S$$

注意到S是无限等比数列求和，可以这样（或者使用公式）

$$\frac{n}{i}*S=\frac{n}{i}+1+\frac{i}{n}+(\frac{i}{n})^2+(\frac{i}{n})^3+...=S+\frac{n}{i}$$

移项，得

$$(\frac{n}{i}-1)*S=\frac{n}{i}$$

$$S=\frac{n}{n-i}$$

$$f_{i+1}=f_{i}+\frac{n}{n-i}$$

然后就可以求出

$$f_{n}=\sum_{i=1}^{n}{\frac{n}{n-i}}$$

题中要求用分数输出，用分数加法就可以了，建议先把分数约分掉，开long long就能存下。

接下来就是代码了：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;
ll f[37],a[37],b[37],n,ans1=0,ans2=1,ans3;

ll gcd(ll x,ll y){
	if(x==0){
		return y;
	}
	return gcd(y%x,x);
}

ll lcm(ll x,ll y){
	return x/gcd(x,y)*y;
}

ll duliu(ll x){
	ll res=0;
	while(x){
		x=x/10;
		res++;
	}
	return res;
}

int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		ll g=gcd(i,n);
		a[i]=n/g;
		b[i]=i/g;
	}
	for(ll i=1;i<=n;i++){
		ans2=lcm(ans2,b[i]);
	}
	for(ll i=1;i<=n;i++){
		ans1=ans1+ans2/b[i]*a[i];
	}
	ll g=gcd(ans1,ans2);
	ans1=ans1/g;
	ans2=ans2/g;
	if(ans1%ans2==0){
		cout<<ans1/ans2<<endl;
		return 0;
	}
	ans3=ans1/ans2;
	ans1=ans1%ans2;
	ll duliu3=duliu(ans3);
	ll duliu1=duliu(ans2);
	for(ll i=1;i<=duliu3;i++){
		cout<<" ";
	}
	cout<<ans1<<endl;
	cout<<ans3;
	for(ll i=1;i<=duliu1;i++){
		cout<<"-";
	}
	cout<<endl;
	for(ll i=1;i<=duliu3;i++){
		cout<<" ";
	}
	cout<<ans2<<endl;
	return 0;
}
```
不要在意一些奇怪的变量名。。

---

## 作者：hanker_AFO (赞：4)

# 知识点:数学期望

这是一道非常基础的数学期望的题目,我们考虑用最简单的方式去理解

定义状态$f[i]$表示总共有$n$名球星,买到$i$名的期望次数

考虑$f[i]$到$f[i+1]$的转移

(下面我们利用图来理解)

![Ksctaj.png](https://s2.ax1x.com/2019/10/27/Ksctaj.png)

$f[i],f[i+1]$定义同上,$x$表示从状态$f[i]$转移到$f[i+1]$的期望次数

即$f[i+1]=f[i]+x$

然后我们将$f[i]$的转移具体到操作上

![Ksg5hn.png](https://s2.ax1x.com/2019/10/27/Ksg5hn.png)

从$f[i]$状态进行一次转移,也就是新买一瓶饮料,可能产生两种情况

1. 获得了已经有的球星 (从$f[i]$转移到$f[i]$,红色路径)

2. 获得了没有的球星 (从$f[i]$转移到$f[i+1]$,黑色路径)

(至于最上方为什么有一条红色路径,我们接下来会讲,现在请忽略)

两种情况的概率也分别写在上面

接下来我们要计算$x$

第一种方法,按照期望的定义 $x= 1* \frac{n-i}{n} + 1* \frac{i}{n} * \frac{n-i}{n} + ... + 1 * \frac{i}{n}^\infty*\frac{n-i}{n}$

即$x=\frac{n-i}{n} *\sum_{k=0}^\infty  \frac{i}{n}^k$

这个大家随便求一下等比数列即可

第二种方法,把$x$同时当做未知数和已知数

我们不再考虑$f[i]$具体是如何转移到$f[i+1]$的,我们只考虑两种情况下,$f[i]$怎么转移到$f[i+1]$

1. 获得了已有的球星,转移次数为$1+x$,概率$P_1=\frac{i}{n}$

2. 获得了没有的球星,转移次数为$1$,概率$P_2=\frac{n-i}{n}$

$x=P_1*(1+x)+P_2 * 1=\frac{i}{n} * (1+x) + \frac{n-i}{n} $

$x= \frac{n}{n-i} $

解释一下情况$1$,它表示先$f[i]$通过$1$次转移到$f[i]$,再通过$x$次转移到$f[i+1]$

这样我们同样解决了问题 

通项公式$f[i+1] = f[i] + \frac{n}{n-i} $

输出自己注意即可



---

## 作者：高木木 (赞：2)

**做这道题之前首先了解一下数学期望是要求概率的，根据[大数定律](https://baike.baidu.com/item/大数定律/410082)这个值并不是一个准确定值，而是无限接近于事情发生概率的最接近值。**

对于本题来说，两次就取遍所有球星的概率为 1/n，三次取遍所有球星的概率为 1/n^2...
以此类推，k次取遍所有球星的概率为 1/n^k-1。

则**E（n）=2/n+3/n^2+4/n^3+...。**这个的趋近规律可以总结为：

# E（n）=n/n+n/n-1+...+n/1。

规律已总结出，接下来这个题就变成了一个简单的分数相加大模拟。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define  ll long long
using namespace std;
void read(ll &x)
{
	x=0;int p=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') p=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	x*=p;
}// 读入优化自动忽略。
ll gcd(ll x,ll y)
{
	if(y>x)
	{
		int tmp;
		tmp=x;
		x=y;
		y=tmp;
	}
	if(x%y==0)
	{
		return y;
	}
	else gcd(y,x%y);
}// 分数化简要用的最大公因数。
ll n,sum=1,p;// sum记录分母，p记录分子。
int main()
{
	read(n);
	p=n;
	for(int i=2;i<=n;i++)
	{
		ll fm=sum*i;
		ll fz1=p*i,fz2=n*sum;// 分子分母通分才能相加。
		ll fz=fz1+fz2;
		ll k=gcd(fz,fm);
		fz/=k;fm/=k;// 分数化简。
		sum=fm;
		p=fz;
	}// 根据规律公式模拟分数相加。
	if(p%sum==0) cout<<p/sum;// 整数判断，如果为整数输出整数。
	else
	{
		ll num=0,k=p/sum,o=p,num1=0,u=sum;
		while(k>0)
		{
			num++;
			k/=10;
		}// 求整数的位数。
		while(u>0)
		{
			num1++;
			u/=10;
		}// 求分母的位数，最终要使分子、分母与分数线对其输出。
		for(int i=1;i<=num;i++)
		 cout<<' ';
		cout<<o%sum<<endl<<o/sum;// 空格的位数等于整数部分的位数。
		for(int i=1;i<=num1;i++)
		 cout<<'-';// 减号的个数等于分母的位数。
		cout<<endl;
		for(int i=1;i<=num;i++)
		 cout<<' ';
		cout<<sum<<endl;
	}
	return 0;
}// AC！！

```

---

## 作者：upcchenbaorui (赞：1)

# 概率DP基础题
   对于一个状态x（已经有x种名字）;
   他可以消耗1的花费，
   
   有 x/n的概率保持原状态
	
    （n-x）/n的概率进入x+1
 
   对此可以列状态方程 dp[x]+1=dp[x]* (x/n) + dp[x+1] * (n-x)/n
   
   整理可以得到 dp[x+1] = dp[x] + n/(n-x)
   
   递推式 o（n) 循环一次可以得到 dp[n]  默认  dp[1]=1;
   
###    坑点 long long   和 输出格式
   ```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
struct node
{
    ll fz;
    ll fm;
};
const int maxn=35;
node e[maxn];
int n;
ll lcm(ll a,ll b)
{
    return a/__gcd(a,b)*b;
}
void solve(int x)
{
    ll t=lcm(e[x].fm,e[x-1].fm);
    ll bei1=t/e[x-1].fm;
    ll bei2=t/e[x].fm;
    ll t1=e[x-1].fz*bei1;
    ll t2=e[x].fz*bei2;
    e[x].fm=t;
    e[x].fz=t1+t2;
    int gcd=__gcd(e[x].fm,e[x].fz);
    e[x].fm/=gcd;
    e[x].fz/=gcd;
}
int main()
{
    cin>>n;
    e[1].fz=1;
    e[1].fm=1;
    for(int i=2; i<=n; ++i)
    {
        e[i].fz=n;
        e[i].fm=n-(i-1);
        solve(i);
    }

    if(e[n].fz%e[n].fm==0) printf("%lld\n",e[n].fz/e[n].fm);
    else
    {
        ll l=e[n].fz/e[n].fm;
        int len=0;
        while(l)
        {
            len++;
            l/=10;
        }
        for(int i=1; i<=len; ++i) printf(" ");
        printf("%lld\n",e[n].fz%e[n].fm);
        printf("%lld",e[n].fz/e[n].fm);
        ll t=e[n].fm;
        int cnt=0;
        while(t)
        {
            cnt++;
            t/=10;
        }
        for(int i=1; i<=cnt; ++i) printf("-");
        printf("\n");
        for(int i=1; i<=len; ++i) printf(" ");

        printf("%lld",e[n].fm);
    }
    return 0;
}

```


---

## 作者：moqizhu2005 (赞：1)

### 思考一下可以发现，如果现在已经有了$k$个名字，那么使名字达到$k+1$平均需要$n/(n-k)$瓶，什么意思呢，就是在买$n$瓶的情况下，每瓶都买到不同的种类。

#### 如果看不懂的话，见代码。

```
#include<iostream>
#include<algorithm>
using namespace std;
struct doubles
{
    long long son,mother;
};//用来储存分数，mother是分母，son是分子
typedef doubles dd;
dd x[50];
long long n;
long long __lcm(long long a,long long b)
{
    return a*b/__gcd(a,b);
}//求最小公倍数，分数的加减要用
dd t(dd ai,long long bii,long long bij)
{
    long long lcm=__lcm(ai.mother,bij);
    dd ax=ai,bx;
    bx.mother=lcm,bx.son=bii,ax.mother=lcm;
    bx.son*=lcm/bij,ax.son*=lcm/ai.mother;
    dd ans;
    ans.mother=lcm,ans.son=bx.son+ax.son;
    long long gcd=__gcd(ans.mother,ans.son);
    ans.mother/=gcd,ans.son/=gcd;
    return ans;
}//本函数是先把两个数的分母的最小公倍数求出来，
//再将分子乘上LCM/分母（及对方分母乘上的数）再相加，
//最后用GCD化简,可以求到n=42
dd w(dd ai,long long bii,long long bij)
{
    dd ans;
    ans.mother=ai.mother*bij;
    ans.son=ai.son*bij+bii*ai.mother;
    long long gcd=__gcd(ans.mother,ans.son);
    ans.mother/=gcd,ans.son/=gcd;
    return ans;
}//本函数是直接相乘两个数的分母，并相乘相加再化简得出，可以求到n=42
int main()
{
    cin>>n;
    x[0].mother=1,x[0].son=1;
    for(int k=1;k<=n-1;k++)
        x[k]=w(x[k-1],n,n-k);//或者x[k]=t(x[k-1],n,n-k);
    if(x[n-1].son%x[n-1].mother==0)
        cout<<x[n-1].son;
    else
    {
        long long p=x[n-1].son/x[n-1].mother,l=p,g=x[n-1].son-l*x[n-1].mother,gg=x[n-1].mother;
        long long j=0,qq=gg,u=0,o=0;
        while(p) j++,p/=10;
        while(gg) o++,gg/=10;
        for(int i=1;i<=j;i++)
            cout<<" ";
        cout<<g<<endl;
        cout<<l;
        for(int i=1;i<=o;i++)
            cout<<"-";
        cout<<endl;
        for(int i=1;i<=j;i++)
            cout<<" ";
        cout<<qq<<endl;
    }//输出求位数得答案
    return 0;
}
```
# 所以说数论题还是思想重要，实现并不难

---

## 作者：KingBenQi (赞：1)

这里的代码都太丑了特来发一波题解挽救一下颜值
期望概率的模板题~~但是输入那里有点麻烦~~
就是
(1/1+1/2+1/3+...+1/n)*n
```
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define LL long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
#define File(S) freopen(S".in","r",stdin);freopen(S".out","w",stdout);
//const int maxN = ;
inline LL gi(){
	char ch=getchar();LL x=0,q=0;
	while(ch<'0' || ch>'9') ch=='-'?(q=1):0,ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return q?(-x):x;
}
LL gcd(LL a,LL b){
	if(!b) return a;
	else return gcd(b,a%b);
}   
LL N,nowfz,nowfm;
int main(){
	//File("football");
	N=gi();
	nowfz=N;nowfm=1;
	LL fm,fz;
	for(int i=2;i<=N;i++){
		fz=N;fm=i;
		LL rep=gcd(fm,nowfm);
		nowfz=nowfz*(fm/rep)+fz*(nowfm/rep);
		nowfm*=(fm/rep);
		rep=gcd(nowfz,nowfm);
		nowfz/=rep;nowfm/=rep;
	}
	if(nowfm==1){cout<<nowfz<<endl;return 0;}
	LL x=nowfz/nowfm;nowfz%=nowfm;
	LL tmp=x,num=0;
	while(tmp)num++,tmp/=10;
	for(int i=1;i<=num;i++)cout<<" ";
	cout<<nowfz<<endl;
	if(x)cout<<x;
	tmp=nowfm;
	while(tmp)cout<<"-",tmp/=10;
	cout<<endl;
	for(int i=1;i<=num;i++)cout<<" ";
	cout<<nowfm<<endl;
	return 0;
}

```

---


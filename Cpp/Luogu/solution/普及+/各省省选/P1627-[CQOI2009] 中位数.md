# [CQOI2009] 中位数

## 题目描述

给出 $1,2,...,n$ 的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是 $b$。中位数是指把所有元素从小到大排列后，位于中间的数。

## 说明/提示

#### 数据规模与约定

对于 $30\%$ 的数据中，满足 $n \le 100$；

对于 $60\%$ 的数据中，满足 $n \le 1000$；

对于 $100\%$ 的数据中，满足 $n \le 100000,1 \le b \le n$。

## 样例 #1

### 输入

```
7 4
5 7 2 4 3 1 6 ```

### 输出

```
4```

# 题解

## 作者：zhutier (赞：84)

以该数为中心，向右for一遍有多少个大于/小于该数的数

大于就sumr++ 小于就--（因为是中位数，大于他的和小于他的数的数量一样）

然后每次以sumr为下标的数++

因为sumr可能小于零

并且我比较懒 

所以就开了一个map

万能的map！

所以就直接mp[sumr]++;


```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <map>
using namespace std;
map<int,int> mp;
int n,b,a[100005],q,suml,sumr;
long long ans;
int main(){
    scanf("%d%d",&n,&b);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i]==b) q=i;
    }
    for(int j=q;j<=n;j++){
        if(a[j]>b) sumr++;
        if(a[j]<b) sumr--;
        mp[sumr]++;
    }
    for(int i=q;i>=1;i--){
        if(a[i]>b) suml++;
        if(a[i]<b) suml--;
        ans+=mp[0-suml];
    }
    printf("%lld",ans);
} 
```
与其他题解的区别大概在于比较懒

---

## 作者：distantlight (赞：77)

思路楼下都说了，简单总结下

1.只关心相对大小，所以数字可以转为1，-1，0。要求覆盖b位置的总和为0的连续子序列数量

2.用部分和，只要求左右部分和相等的对数

3.由于部分和的范围是有界的，使用计数排序即可，复杂度O(n)


下面是比较短的代码实现


```cpp
#include <iostream>
#define N 100005
using namespace std;
long long n,b,ans,c[2][2*N];
int main () {
    cin>>n>>b; c[0][n]=1;
    for (long long i=0,a,s=n,isRight=0;i<n;i++){
        cin>>a;
        if (a!=b) s+=a>b?1:-1;
        c[isRight|=a==b][s]++;
    }
    for (long long i=0;i<2*n;i++,ans+=c[0][i]*c[1][i]);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Heartlessly (赞：41)

## Description:

给定长度为 $n$ 的序列，求有多少奇数长度的序列中位数为 $b$ 。

------------

## Solution:

因为所求的是中位数，所以考虑改变原序列。把大于 $b$ 的数全部变为 $1$，小于 $b$ 的数变为 $-1$，等于 $b$ 则为 $0$。问题就变为求存在几个包含 $b$ 的区间和为 $0$ 。我们假设 $tmp$ 为 $b$ 的下标，原数组为 $x$，新数组为 $a$ 。

### Sample Input:
```
7 4
5 7 2 4 3 1 6 
```
### Example:

![](https://cdn.luogu.com.cn/upload/pic/51589.png)

能使结果成立的区间分别为 $[1,5]$ , $[1,7]$ , $[2,4]$ , $[4,4]$。

接下来我们建造两个桶，分别计数 $tmp$ 左边的后缀和与右边的前缀和，假设左边的后缀和为 $l$，右边的前缀和为 $r$ 。$l[i]/r[i]$ 表示从点 $i$ **向右/向左** 到点 $tmp$ 为止 (比 $b$ 大的数的数量 - 比 $b$ 小的数的数量) 出现的次数。还是拿样例来说：

![](https://cdn.luogu.com.cn/upload/pic/51610.png)

通过观察上图，我们能够发现，左边的数 $x$ 可以与右边的每一个 $-x$ 进行匹配。通过乘法原理，该值即为 $l[x] \times r[-x]$，由题意可知 $-10^5 \le x \le 10^5$，遍历所有的 $x$ 即可，最终答案为 $\sum_{i=min}^{max}l[i] \times r[-i]$ 。

值得注意的是，$l[0]$ 和 $r[0]$ 的初始值为 $1$，因为 $b$ 是需要被算入的。当然，桶的下标不能是负数，所以我在每次操作时都加上了一个很大的数，即数据最大值 —— $10^5$，也可以用 $STL$ 中的 $map$ 解决问题，时间复杂度为 $O(n)$ 。

------------

## Code
```cpp
/*
Language:C++
Author:xuxing
*/
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template < class T > inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
    x = f ? -x : x;
}

const int maxN = 1e5;

LL n, b, x, tmp, sum, ans, a[maxN + 10], l[maxN << 2], r[maxN << 2];

int main() {
    read(n), read(b);
    for (LL i = 1; i <= n; i++) { read(x); if (x == b) tmp = i; else a[i] = x > b ? 1 : -1; }//初始化
    l[maxN] = 1, r[maxN] = 1;
    for (LL i = tmp - 1; i >= 1; i--) { sum += a[i]; l[sum + maxN]++; }//后缀和统计
    sum = 0;
    for (LL i = tmp + 1; i <= n; i++) { sum += a[i]; r[sum + maxN]++; }//前缀和统计
    for (LL i = 0; i <= (maxN << 1); i++) { if (l[i] && r[(maxN << 1) - i]) ans += l[i] * r[(maxN << 1) - i]; }//累加答案
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：诗乃 (赞：35)

搞个清新脱俗的算法

把中位数出现的位置设为pos，比中位数大的设为1，小的设为-1.

lsum[i]表示i到pos的和，即1的个数和-1的个数差

rsum[i]表示pos到i的和，同理。

l[sum[i]]表示pos左边和为sum出现的次数

r[sum[i]]表示pos右边和为sum出现的次数

由于c++数组不能开负下标，所以需要向右偏移n

如果l[i]=r[-i]就可以将ans+=l[i]\*r[-i].

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int b,n,a[400001],pos,x,sum[200001],ans=0;
int l[400001],r[400001];
int main()
{
    //freopen("median.in","r",stdin);
    //freopen("median.out","w",stdout);
    scanf("%d%d",&n,&b);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        if(x==b){pos=i;a[i]=0;}
        else
        if(x>b)a[i]=1;
        else a[i]=-1;
    }
    l[n]=1;r[n]=1;//l[0+n]=1;r[0+n]=1;0出现1次 
    for(int i=pos-1;i>=1;i--)
        {sum[i]=sum[i+1]+a[i];l[sum[i]+n]++;}
    for(int i=pos+1;i<=n;i++)
        {sum[i]=sum[i-1]+a[i];r[sum[i]+n]++;}
    for(int i=-n+n;i<=n-1+n;i++)
        ans+=l[i]*r[n-i+n];
    printf("%d",ans);
}
```

---

## 作者：eros1on (赞：20)

##### [题目传送门](https://www.luogu.org/problem/show?pid=1627)

## 思路


### 标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。


### 首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：


1 -> 比中位数大


-1 -> 比中位数小


0 -> 找到中位数！标记pos


还是举个实例吧……


数组：1 1 -1 -1 -1 pos 1 -1 1

### 然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 "KEY" 。妈妈再也不用担心下标的值为负啦！


这时的 sum 数组：-1 -2 -3 -2 -1


这时的 f 数组：f [ -1 + KEY ] = 2 ;  f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ;


### 做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。


从 pos 向右




1. sum=1 -> 左边 sum=-1 -> 两次 ∴ ans+=2;

2. sum=0 -> 左边 sum=0 -> 无

3. sum=1 -> 左边 sum=-1 -> 两次 ∴ ans+=2;

### 最后输出 ans 即可。


C++ 代码如下：

```cpp
#include <cstdio>//头文件
#include <cstdlib>//头文件
using namespace std;//命名空间
#define KEY 100001//定义一个足够大的数
int n,b,pos,a[100010],flag[100010],f[200010],s,ans;
int main(){
    scanf("%d%d",&n,&b);//输入
    for(int i=1;i<=n;i++){//第一次循环
        scanf("%d",&a[i]);
        if(a[i]==b) pos=i;//就是中位数
        else if(a[i]>b) flag[i]=1;//大的标1
        else flag[i]=-1;//小的标-1
    }
    for(int i=pos-1;i>=1;i--){//第二次循环
        s+=flag[i];//计算此次sum值
        f[s+KEY]++;
        if(s==0) ans++;//找到满足题意只在 pos 左侧的连续子序列！
    }
    s=0;//为第三次循环的累加做准备
    for(int i=pos+1;i<=n;i++){//第三次循环
        s+=flag[i];//计算此次sum值
        if(s==0) ans++;//找到满足题意只在 pos 右侧的连续子序列！
        ans+=f[-s+KEY];
    }
    printf("%d\n",++ans);//还少一次只由 pos 自己组成的连续子序列（也满足条件！）
    return 0;
}
```

---

## 作者：Fading (赞：11)

随机跳了一题（省选前做做水题搞好心态）

想了$10min$切了

我的思路和大家有些不同？

想法和$P4889$很像

首先问题转化成$01$问题，大于$b$的数的变成$1$，等于的成$0$，否则为$-1$

问题就成了求$01$序列中有多少个序列和为$0$且包含$0$

然后怎么办呢？？？

不会了？？？

注意到这个序列是一个奇数序列（否则无法和为$0$且包含$0$）

然后怎么办呢？？？

开一个前缀和数组$sum$

等价于求有多少个数差为$0$且位置差为奇数

然后开两个数组记录奇偶位置出现的数就好了

注意特判左端点为$1$的情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,mm,ans,sum,ji[220001],ou[220001];
int main(){
	cin>>n>>m;
	ou[0+n]=1;
	for (int i=1;i<=n;i++){
		scanf("%d",&mm);
		if (mm>m) sum++;
		else if (mm<m) sum--;
		if (i%2==0) ans+=ji[n+sum],ou[sum+n]++;
		else ans+=ou[sum+n],ji[sum+n]++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：「QQ红包」 (赞：7)

//相对数量：在一个区间内，比中位数大的数的个数和比中位数小的数的个数的差的绝对值

先找到中位数的位置kk，让后将中位数的左边分成一部分，中位数的右边分成一部分。

分别求出i~kk，kk~i段的相对数量，

然后找一段区间相对数量为0.

开始看错题还打算排序来着。

其它东西在程序里面说明清楚了。

```cpp

//由于窝不会访问负数下标，于是访问f数组时下标统一加上一个常数100001 
#include<set>
#include<map>
#include<list>
#include<queue>
#include<stack>
#include<string>
#include<math.h>
#include<time.h>
#include<vector>
#include<bitset>
#include<memory>
#include<utility>
#include<stdio.h>
#include<sstream>
#include<iostream>
#include<stdlib.h>
#include<string.h>
#include<algorithm>
#define LL unsigned long long
using namespace std;  
int a[100010];//排列 
int f[800010];//f[i+100001]存的是相对数量为i的区间的个数 
int main()
{
    /*根据题目“统计该排列有多少个长度为奇数的连续子序列的中位数是b”可知
    b一定是a数组中的一个数*/ 
    int n,k,kk=1;//n:数的个数，k:中位数,kk:中位数的位置 
    scanf("%d%d",&n,&k);//读入
    int i,j;//i,j:循环控制变量 
    for (i=1;i<=n;i++) 
    {
        scanf("%d",&a[i]);//读入
        if (a[i]==k) kk=i;//找到中位数在数组中的位置 
    }
    for (i=-n+100001;i<=n+100001;i++) f[i]=0;//初始化 
    int s=0,sum=0; //s存的是相对数量 
    for (i=kk;i>=1;i--) //找相对数量 
    {
        if (a[i]>k)s++;//如果a[i]比中位数大，s就+1 
        if (a[i]<k)s--;//如果a[i]比中位数小，s就-1 
        if (s==0) sum++;//如果两边比k大的比k小的数数量一样，那么kk就是 
        f[s+100001]++;//相对数量为s的区间的个数 
    } 
    s=0;//s初始化 
    for (i=kk+1;i<=n;i++)
    {
        if (a[i]>k)s++;//如果a[i]比中位数大，s就+1 
        if (a[i]<k)s--;//如果a[i]比中位数小，s就-1 
        sum+=f[-s+100001]; //统计结果
        //这样整个区间，比中位数大的数的个数和比中位数小的数的个数
        //对于x右边的区间A[x..i]，只要满足比中位数大的数的个数比比中位数小的数的个数多了-s个
    } 
//最后统计结果其实可以再搜一次，f[s]*f[-s]。
    cout<<sum;//输出
    return 0;
}


```

---

## 作者：B_1168 (赞：6)

十万$O(n^2)$，暴力出奇迹！

原本抱着“试试看”的心态，写了一份$O(n^2)$复杂度的前缀和算法代码，加了快读和优化指令，竟得以强行通过本题！

![](https://cdn.luogu.com.cn/upload/image_hosting/5k6wh58x.png)

~~#2离TLE的距离真的好近~~

本算法本质上是直接利用其他题解里的“60分算法”(~~其实不加氧气都能拿到80~~)，因此算法相关的建议参见其他题解，在此提供暴力代码：

```cpp
//优化指令请参见文章末尾的链接，单纯吸氧的话#2会T（就是不想让你抄）
#include<bits/stdc++.h>
#define maxn 100005
using namespace std;

int n,k,loc,ans,a[maxn],s[maxn];
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}

inline int read(){
	int x=0,f=1;char ch=nc();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=nc();}
	while (isdigit(ch)){x=x*10+ch-48;ch=nc();}
	return x*f;
}

int main(){
	n=read(),k=read();
	for(int i=1;i<=n;i++) {
		a[i]=read();
		if(a[i]<k) a[i]=-1;
		else if(a[i]==k) a[i]=0,loc=i;
		else a[i]=1;
	}
	for(int i=loc;i;i--){
		s[i]+=a[i]+s[i+1];
	}
	for(int i=loc+1;i<=n;i++) s[i]+=a[i]+s[i-1];
//	for(int i=1;i<=n;i++) printf("%d ",s[i]);
	for(int i=1;i<=loc;i++){
		for(int j=loc;j<=n;j++){
			if(!(s[i]+s[j])) ans++;
		}
	}
	printf("%d\n",ans);
} 
```

P.S.:
- [优化指令在此](https://www.luogu.com.cn/paste/fhiymawc)
- 感谢管理审核，如果觉得有用的话，欢迎点赞！

---

## 作者：rilegoule (赞：5)

# O(n logn)做法
中位数
```
是按顺序排列的一组数据中居于中间位置的数
```
所有我们只要找到一串包含b的数列，使得其中比b大的数的数量 和 比b小的数的数量 相等即可

O(n^2)做法是开两个数组big和small（含义应该不用解释了吧），分别记录整个数列中比b大和比b小的数的数量
```cpp
for(i=b左边的数的序号)
	for(j=b右边的数的序号)
		if(big[i]+big[j]==small[i]+small[j])
			++cnt；
```


------------
### 如何优化
通过~~玄学瞎猜~~分析n^2做法，我发选可以另外用两个数组，记录两边big数组和small数组的差值

如样例:
```

       5  7  2 |4| 3  1  6 
big    2  1  0 |0| 0  0  1
small  1  1  1 |0| 1  2  2
delta  1  0 -1 |0|-1 -2 -1
```
这时，我们只要找到左右两边某两位delta的值之和为0就行了，所以可以求出delta后两边分别排序，再用二分找出对应的值的个数就行

代码
```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
#define re register int
using namespace std;

const int SIZE=1<<20;
inline char getcha()
{
    static char buf[SIZE],*p1(buf),*p2(buf);
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,SIZE,stdin),p1==p2)?EOF:*p1++;
}
inline void read(int &x)
{
    x=0;int f(0);char ch(getcha());
    while(!isdigit(ch))f|=(ch=='-'),ch=getcha();
    while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getcha();
    x=f?-x:x;
}

const int MAXN=1e5+5;

int n,b,pos,a[MAXN],ans,ql[MAXN],qr[MAXN];

inline int findl(int data)
{
	int l(pos),r(n),mid;
	while(l<r)mid=(l+r)>>1,qr[mid]>=data?r=mid:l=mid+1;
	return qr[l]==data?l:n;
}
inline int findr(int data)
{
	int l(pos),r(n+1),mid;
	while(l<r)mid=(l+r)>>1,qr[mid]>data?r=mid:l=mid+1;
	return qr[l-1]==data?l:n;
}

int main()
{
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
//	freopen("median.in","r",stdin);
//	freopen("median.out","w",stdout);
	read(n),read(b);
	for(re i(1);i<=n;++i)read(a[i]),a[i]==b?pos=i:1;
	for(re i(pos-1);i>=1;--i)a[i]>b?ql[i]=ql[i+1]+1:ql[i]=ql[i+1]-1;
	for(re i(pos+1);i<=n;++i)a[i]<b?qr[i]=qr[i-1]+1:qr[i]=qr[i-1]-1;//将b右边的delta值乘上-1，这样就只用找左右两边相同的数了
	sort(ql+1,ql+pos+1);sort(qr+pos,qr+n+1);
	for(re i(1);i<=pos;++i)ans+=findr(ql[i])-findl(ql[i]);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：珈乐唯毒 (赞：4)

题目思路：一个数成为中位数的条件为序列中比它大以及比它小的数个数要一样

实现方法：使用两个map数组，一个用于记录左边前k个数中比b大的数的个数与比b小的数的个数的差；另一个用于记录右边前k个数中比b大的数的个数与比b小的数的个数的差。

那么我们只要找出两个map中相为相反数的情况个数，将他们相乘即可~

下见代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
map<int,int> l,r;
int n,b,a[100005],s,ans,d,x;
signed main(){
	cin>>n>>b;
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		if(a[i]==b)
			s=i;
	}
	for(int i=s+1;i<=n;i++){
		if(a[i]>a[s]) d++;
		else x++;
		l[d-x]++;
	}
	d=0;
	x=0;
	for(int i=s-1;i>=1;i--){
		if(a[i]>a[s]) d++;
		else x++;
		r[d-x]++;
	}
	for(int i=-n+1;i<n;i++){
		ans+=l[i]*r[-i];
//		cout<<ld[i]<<' '<<lx[i]<<' '<<rd[i]<<' '<<rx[i]<<endl;
	}
	ans+=l[0]+r[0];
	cout<<ans+1;
	return 0;
}
```


---

## 作者：WB_TS_欧寒 (赞：3)

## 1. 解析：
    由于这n个数是互不相同的，那么把位于B数两边的数分成左右
    两部分，显然要构成B是中位数可能的数要么全部来自于左或
    右两部分，要么一部分来自于左边另一部分来自于右边，假定
    B所在的位置为k。
    
	(1) 对于全部来自于左边或右边，那必须是从B这个数位置开
    始，且大于和小于B的数的个数一定相等，我们记i位置到k大
    于B和小于B的个数差，显然全部来自某一边则必然要求这个差为0。
	(2) 对于一部分来自于左边，另一部分来自右边，如果想让B成
    为中位数，那么些时来自于左边的那些大于B和小于B的个数差
    与来自于右边那些小于B和大于B个数差要相等，即两边所有大
    于B和所有小于B的个数正好抵消！
    
	于是我们在读入的时候开始记录，从找到B的位置之后（即右边
    部分）统计每一个位置小于B和大于B的个数差，即用数组记录
    t+= (a[i] > B) - (a[i] < B)（即若a[i]>B即+1，a[i]<B
    即-1），s[t]++。
    
	但这里要注意：t有可能是负数，一种方法就是把所有的t都平移
    一个值（常用的方法），这样数组就所扩大一倍，另外考虑t
    的正负值个数不可能超过n，所以当t为负的时候就+n，正的时
    候就不变，如同把正负放在一个数组的两端，这样就不用扩大
    数组了。然后把s[0]++（因为单个B也是差为0的方案），显然
    此时的ans = s[0]。
    
    最后在从k-1位置向前（即左边部分）扫描，如同刚才的处理
    一样，当然这里只需要计算t，而不需要用数组保存了，t += 
    (a[i] < B) - (a[i] > B)（与右边部分相反记录），此时只
    要把答案 ans+=s[t]即可。注意t的负数处理也要同上。而ans
    却不需要再单独加上左边t为0的方案了，因为这边所有为0的方案已
    经与单个B组合成方案了。


------------

2. 参考代码，请自行完善（防作弊）
```cpp
for(int i = 1; i <= n; i++)
{
  cin >> a[i];
  if(k)
  { //找到B后开始记录
    t+=______;
    s[______]++;
  }
  if(a[i] == B) k = i; //记录B所在的位置
} 
  t= 0;
  long long ans = ++s[0];
  for(int i = k - 1; i > 0; i--)
  {
    t +=______;
    ans += s[______];
  }
```


---

## 作者：Yldar (赞：3)

  ~~考试上最后10分钟想出来发现调试错误~~  
  因为是中位数，在这个序列中一个性质就是比k大的数等于比k小的数。所以我们弄一个数组，分别在k的左边与右边记录比k大的数减去比k小的数。0是等于k的数
  如下
  ```
for(int i=1;i<=n;i++){
        x=read();
        if(x==b){pos=i;a[i]=0;}
        if(x>b)a[i]=1;
        else a[i]=-1;
    }
```
  因为单独一个k就是一个字串，所以ans初值为1   
  然后我们分三种情况--第一种：k与k左边的一段组成中位数为k的子串
  ```
for(int i=pos-1;i>=1;i--){
sum[i]=sum[i+1]+a[i];
if (sum[i]==0) ans++;
}
```
  同理,k与k右边的一段组成中位数为k的子串
  ```
for(int i=pos+1;i<=n;i++){
sum[i]=sum[i-1]+a[i];
if (sum[i]==0) ans++;
}
```
  我们考虑左边一段与右边一段和为0，暴力就是对于在k右边的sum[i]，在k左边找一个sum[i]相加等于0.因为我们不需要知道每个在左边的相加等于0的sum[i]的位置，我们只需要知道个数。所以我们可以hash。对于每个左边的sum，用hash保存每个数字有多少个。然后对于右边的sum，我们查找就行，对于右边的sum 找它的相反数。（想想为什么），ans+=hash的值。
  最后贴代码
  ```
#include<bits/stdc++.h>

using namespace std;

inline int read(){
   int w=1,s=0;
   char ch=getchar();
   while(ch<'0'||ch>'9') {if (ch=='-') w=-1;ch=getchar();} 
   while(ch>='0'&&ch<='9')  s=s*10+ch-'0',ch=getchar();
   return s*w;
}

using namespace std;

int b,n,a[400001],pos,x,sum[200001],ans=0;
int l[400001],r[400001],f[1000001];

int hhash(int num){
    f[num+100000]++;
}

int hhhash(int num){
  return   f[num+100000];
}

int main(){
    n=read(),b=read();
    for(int i=1;i<=n;i++){
        x=read();
        if(x==b){pos=i;a[i]=0;}
        if(x>b)a[i]=1;
        else a[i]=-1;
    }
    ans=1;
    for(int i=pos-1;i>=1;i--){
        sum[i]=sum[i+1]+a[i];
        hhash(sum[i]);
        if (sum[i]==0) ans++;
    }
        for(int i=pos+1;i<=n;i++){
            sum[i]=sum[i-1]+a[i];
            ans+=hhhash(-sum[i]);
            if (sum[i]==0) ans++;
            
        }
    printf("%d",ans);
}
```

---

## 作者：Dragon_hao (赞：2)

首先对于所求的子序列一定包含b。~~（这句是废话）~~

那么我们人为地将b左右两侧划分为两个区间。

对于左侧区间，令比b大的数的个数为x1，比b小的个数为y1.

对于右侧区间，令比b大的数的个数为x2，比b小的个数为y2.

那么对于所求的满足题意的子序列，一定满足**** _x1+x2=y1+y2._ ****


 _**注**：这里的（x1+x2）和（y1+y2）都不等于0_ 

可以推出：**x1-y1=x2-y2**。


等式左边表示b左侧区间中比b大的数的净个数。

等式右边表示b右侧区间中比b小的数的净个数。

所以我们可以先枚举b右边的区间，统计x2-y2的个数，并用数组记录。

然后枚举b左边的区间，每找到一个x1-y1的值，寻找对应的右区间x2-y2的方案数，并统计。

因为x1-y1和x2-y2都有可能出现负值，所以我们对于记录右侧区间的方案数时，用两个数组pos[i],neg[i]分别记录x2-y2为正和负的情况。

在枚举左侧区间时，调用对应的pos[i],neg[i]数组，将答案统计到ans中。

而上述思路对于子序列只在右区间或只在左区间的情况，不能判断。

而这种情况如何判断呢？

sum1记录若子序列只位于右区间是b为中位数的情况数。

sum2记录若子序列只位于左区间是b为中位数的情况数。

根据乘法原理和加法原理，可得到对于此两种情况的方案数为：

**sum1*sum2+sum1+sum2.**

最后将其统计入答案即可。

因为没有考虑单独中位数b作为子序列的情况没有判断，所以输出时不要忘记ans+1即可。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define N 100001
using namespace std;
int n,b,st,num,ans;
int a[N],pos[N],neg[N],sum1,sum2;
int main(){
	scanf("%d%d",&n,&b);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i]==b) st=i;
	}
	for(int i=st+1;i<=n;i++){
		if(a[i]>b) num++;
		else num--;
		if(num>0) pos[num]++;
		else if(num<0) neg[-num]++;
		else sum1++;
	}
	num=0;
	for(int i=st-1;i>=1;i--){
		if(a[i]>b) num++;
		else num--;
		if(num>0) ans+=neg[num];
		else if(num<0) ans+=pos[-num];
		else sum2++;
	}
	ans+=(sum1+sum2+sum1*sum2);
	printf("%d",ans+1);
	return 0;
}

```



---

## 作者：xh39 (赞：1)

输入一个数组,然后对于a[i],i是不是>,i是不是<b。求前缀和。

拿样例来说
```cpp
n,b:7 4
a:5 7 2 4 3 1  6 
>:1 2 2 2 2 2  3
<:0 0 1 1 2 3  3
-:1 2 1 1 0 -1 0
```
上图中,>表示i>b的前缀和,<表示i<b的前缀和,-表示它们的差。

前缀和的用处:可以求任意一段区间的数量。从l到r的数量就是a[r]-a[l-1]

---

然后,我们要求中位数,就是在一段区间里,比i大的跟比i小的数量一样多。

这样,我们就可以把下标为奇数和下标为偶数的差(上图的 - 数组)分别放入两个桶里,结果就是sum{桶1×桶2},因为可以选任意一个桶1的元素作为起点。桶2的任意一个元素作为终点。

为什么要放奇数和偶数呢?因为长度必须是奇数。

ac代码
```cpp
#include<iostream>
using namespace std;
int mark1[200005]={0},mark2[200005]={0},cz[100005],zyl1[100005],zyl2[100005]; //zyl1:< zyl2:> cz:-
int main(){
	int n,i,a,b,sum=0;
	cin>>n>>b;
	cin>>a;
	zyl1[0]=(a<b);
	zyl2[0]=(a>b);
	cz[0]=zyl1[0]-zyl2[0];
	for(i=1;i<n;i++){
		cin>>a;
		zyl1[i]=zyl1[i-1]+(a<b);
		zyl2[i]=zyl2[i-1]+(a>b);
		cz[i]=zyl1[i]-zyl2[i];
	}
	mark1[100000]=1;
	for(i=0;i<n;i++){
		if(i&1){ //i&1是判断i是否是奇数的一种更快的方法。
			mark1[cz[i]+100000]++; //解决桶里有负数的情况,可以加上一个数。
		}else{
			mark2[cz[i]+100000]++;
		}
	}
	for(i=0;i<=200000;i++){
		sum+=mark1[i]*mark2[i];
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：qwerta (赞：1)

[更详细的版本~~其实是安利博客~~](https://blog.csdn.net/qq_41007369/article/details/81045979)

因为这道题不关心数据具体为多少，只关心每个数比b大或小，

所以首先在读入的时候就忽视数据绝对大小，只存相对b的大小

（小于b存-1 等于b存0 大于b存1


#### O(n^2)： 

枚举区间长度L和左端点i 利用前缀和可以O(1)得到区间和 易知区间和为0的话在这个区间内b为中位数

（证明：因为区间和为0 所以在这个区间内的-1数量和1的数量相等 也就是比b小的和比b大的数一样多）

期望60，却因为数据巨水搞到90(喵喵喵？)

~~本来打算卡一波常A掉然后发n方题解哈哈哈哈~~

核心片段：

```cpp
for(int l=1;l<=n;l+=2)
for(int i=max(1,p-l+1);i<=min(p,n-l+1);++i)
{
    int j=i+l-1;
    if(s[j]-s[i-1]==0)ans++;
}
```

#### O( n )（先懵着脑袋看 相信我）

读入的同时记录b出现的坐标为p。

然后从p-1到1扫一遍，从p+1到n扫一遍，用类计数排序的方式记录 ↓

```
int s=0;
for(int i=p-1;i;--i){
    s+=a[i];
    L[s+c]++;//c=100001 避免负坐标
}
s=0;
for(int i=p+1;i<=n;++i){
    s+=a[i];
    R[s+c]++;
}
```
L[ s + c ]表所有左端点为1到p-1，右端点为p-1的区间中，区间和为s的情况数

同理R[ s + c ]表所有左端点为p+1，右端点为p+1到n的区间中，区间和为s的情况数

而对于一个区间< l , r >，如果< l , p-1 >的区间和 + < p+1 , r >的区间和==0的话，就是一个符合条件的区间。

所以根据乘法原理，L[ s + c ] × R[ ( - s ) + c ] == p左边的区间和为s时的所有可能情况.（此时右边区间和为-s）  所以

```
ans+=L[ s + c ] × R[ ( - s ) + c ] ( s = - n to n ) ;

```

最后因为以上只计算了 l < p 且 r > p 的区间，所以还要

```
ans+=L[ 0 + c ]  (l<p r==p) +R[0+c] (l==p r>p) +1(l==p r==p);
```

AC代码：

```
#include<iostream>
#include<cstdio>
using namespace std;
#define R register
inline int read()
{
    char ch=getchar();
    int x=0;bool s=1;
    while(ch<'0'||ch>'9'){if(ch=='-')s=0;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return s?x:-x;
}
int a[100007],l[200007],r[200007];
int main()
{
    //scan
    int n=read(),b=read(),p;
    for(R int i=1;i<=n;++i)
    {
        int x=read();
        if(x<b)a[i]=-1;
        else if(x>b)a[i]=1;
        else p=i;
    }
    //predo
    int s=0,c=100001;
    for(R int i=p-1;i;--i)
    {
        s+=a[i];
        l[s+c]++;
    }
    s=0;
    for(R int i=p+1;i<=n;++i)
    {
        s+=a[i];
        r[s+c]++;
    }
    //run
    int ans=0;
    for(R int i=-n;i<=n;++i)
    {
        ans+=l[i+c]*r[-i+c];
    }
    ans+=l[0+c]+r[0+c]+1;
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：太阳骑士 (赞：0)

>中位数是指把所有元素从小到大排列后，位于中间的数。

由于题目要求的是长度为奇数的子序列，又由中位数的定义，我们可以知道，一段满足要求的序列中，比$b$大的数一定和比$b$小的数一样多，我们只关心每个数与$b$的大小关系，而不是它的具体值，所以我们可以将每个数标记为$1$和$-1$，如果它大于$b$，则标为$1$，否则标为$-1$。

于是我们可以利用差分的思想。记下$b$的位置为$pos$，将$pos$两端分别开始扫，记录前缀和。

如果$pos$一端的某段前缀和值为$3$，则说明这一段还需要$3$个小于$b$的数，于是在$pos$的另一端找到前缀和为$-3$的即可，这两段合起来再加上$b$本身即为一段满足要求的序列。

优化：利用桶记录$pos$一段的前缀和的值。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define il inline
#define re register
#define tie0 cin.tie(0),cout.tie(0)
#define fastio ios::sync_with_stdio(false)
#define File(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout)
using namespace std;
typedef long long ll;

template <typename T> inline void read(T &x) {
	T f = 1; x = 0; char c;
    for (c = getchar(); !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x *= f;
}
/*-------------------分界线-------------------*/
int n, b, pos, cnt;
int a[100005], pre[100005], last[100005],ton[100005];

int main() {
	read(n), read(b);
	for (int i = 1; i <= n; ++i) {
		read(a[i]);
		if (a[i] < b) a[i] = -1;
		else if (a[i] > b) a[i] = 1;
		else if (a[i] == b) pos = i;
	}
	for (int i = pos - 1; i; --i) {
		pre[i] = pre[i + 1] + a[i];
		if (!pre[i]) cnt++;
		ton[-pre[i]]++;
	}
	for (int i = pos + 1; i <= n; ++i) {
		last[i] = last[i - 1] + a[i];
		if (!last[i]) cnt++;
	}
	/*for (int i = pos - 1; i; --i)//这样会T两个点
		for (int j = pos + 1; j <= n; ++j)
			if (pre[i] + last[j] == 0)
			cnt++;*/
	for (int i = pos + 1; i <= n; ++i) cnt += ton[last[i]];
	printf("%d", cnt + 1);//还要加上b本身
	return 0;
}

```


---

## 作者：RocketTurtle (赞：0)

首先在@Heartlessly大佬的基础上，写了一个map的做法。

大佬已经讲了大致的思路。**https://www.luogu.org/blog/xuxing/solution-p1627**
以上链接就是大佬的思路，大佬没有用STL大法而是加长了数组,那我就写一篇大佬在结尾说的map大法。

1：首先map的好处是：这玩意键值可以为负数，所以就不用开一个更大的数组去维护整个序列。

2：那么用map优化后，在比较后缀和前缀时，只需要从最小的那个后缀开始枚举到最大的那个后缀（不开map的话，那么他的最小的差值必定为正（这不是废话嘛，因为普通数组的下标值不能为负数，所以用数组只能去加上一个MAXN））

3:还有我认为最重要的一点，就是俺一直在思考为啥区间和为0，那么区间长度就为奇数呢。然后，被自己的这个问题菜哭了。（这不是都转换成相对值了吗？那么前面有一个1的话那么0后面肯定有个-1，那么区间长度不就为3是奇数了吗）

**以下是将序列转换为相对值的代码**
~~~
for(int i=1;i<=n;i++){
    ll x;cin>>x;
    if(x==b) pos=i;
    else a[i]=x>b?1:-1;
}
~~~

**l数组维护后缀，r数组维护前缀，原点值初始化为1.（比较好理解）**
~~~
l[0]=r[0]=1;
ll sum=0;
for(int i=pos-1;i>=1;i--){
    sum+=a[i];l[sum]++;
}
sum=0;
for(int i=pos+1;i<=n;i++){
    sum+=a[i];r[sum]++;
}
~~~
**以下是AC代码**
~~~
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=1e5;
int n,b,pos;
ll a[MAXN+1];
map<int,int> l;
map<int,int> r;
int main(){
	cin>>n>>b;
	for(int i=1;i<=n;i++){
		ll x;cin>>x;
		if(x==b) pos=i;
		else a[i]=x>b?1:-1;
	}
	l[0]=r[0]=1;
	ll sum=0;
	for(int i=pos-1;i>=1;i--){
		sum+=a[i];l[sum]++;
	}
	sum=0;
	for(int i=pos+1;i<=n;i++){
		sum+=a[i];r[sum]++;
    }
    ll ans=0;
	for(int i=-MAXN;i<=MAXN;i++) if(l[i]&&r[-i]) ans+=l[i]*r[-i];
	cout<<ans<<endl;
	return 0; 
}
~~~

---

## 作者：A_Cute_757 (赞：0)

个人感觉这是一个比较快又好理解的算法。
代码还有一定的优化空间，欢迎开喷...
```cpp
#include<bits/stdc++.h>
using namespace std;
int b,n;                     //中间数和输入的数量
int s[100001];               //输入时所用的标记，用于标记是否比中间数大
int temp,mid;                //输入和中间数的位置
int p[1000001];              //总和表
int l[1000001]={0},r[1000001]={0};   //左侧的桶，右侧的桶
int ans=0;
int main()
{
    cin>>n>>b;               //输入中间数和输入的数量
    for(int i=1;i<=n;i++)    //按照题意输入并进行处理
    {
        cin>>temp;
        if(temp==b)          //如果这个数与‘中间数’的值是相等的，那么就把这个数设为中心
        {
            mid=i;           //找中间数
            s[i]=0;          //将该数的位于统计表中的位置设为0
        }
        else
        {
            s[i]=temp>b?1:-1;//大于‘中间数’的值为1，小于‘中间数’的值为-1
        }
    } 
    for(int i=mid-1;i>=1;i--)//扫左边的表
    {
        p[i]=p[i+1]+s[i];    //更新总和表中的数据
        l[p[i]+n]++;         //将该数据的桶的相应位置坐标记
    }
    for(int i=mid+1;i<=n;i++)//扫右边的表
    {
        p[i]=p[i-1]+s[i];    //更新总和表中的数据
        r[p[i]+n]++;         //将该数据的桶的相应位置坐标记
    }
    for(int i=-n;i<=n;i++)
    {
        ans+=l[i+n]*r[-i+n]; //正i与负i可构成中位b,个数相乘。 
	} 
    cout<<ans+1+l[n]+r[n];   //0单独算1个，左0和右0与中位也构成中位b，因此加入
    return 0;
}
```

---

## 作者：望眼浮云 (赞：0)

今天我们考了这道题，~~就我AC了~~

先找到mid的位置，记为pos。

符合条件的子序列必定包含mid，mid为中位数，即在序列中比mid小的数字的个数等于比mid大的数字的个数。

所以我们可以从mid向两边延展，记录这些数字的个数

定义l1,l2,r1,r2四个数组，l1记录从i到pos中比mid小的个数，l2记录从i到pos比mid大的个数，r1,r2同理。

我们可以得到:  l1[i]+r1[i]=l2[i]+r2[i];

移项得： l1[i]-l2[i]=-(r1[i]-r2[i])

若mid左边一段区间l1[i]-l2[i]=k,右边一段区间r1[j]-r2[j]=-k，则区间[i，j]为一个符合条件的子序列。

计算l1[i]-l2[i]=k的个数和r1[j]-r2[j]=-k的个数，相乘，将所有这样的值相加即为答案

如果还有不理解没关系，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005],pos,ans;
int l1[1000005],l2[1000005],r1[1000005],r2[1000005];
int f1[1000005],f2[1000005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]==m) pos=i;   //找到m的位置
	}
	for(int i=pos-1;i>=1;i--)  //计算左边从i到pos的区间中大于m和小于m的数字个数
	{
		if(a[i]>m) l2[i]=l2[i+1]+1,l1[i]=l1[i+1];
		else l1[i]=l1[i+1]+1,l2[i]=l2[i+1];
		if(l1[i]==l2[i]) ans++;  //这种情况[i,pos]刚好为一个符合条件的子序列
	}
	for(int i=pos+1;i<=n;i++)  //计算右边从pos到i的区间中大于m和小于m的数字个数
	{
		if(a[i]>m) r2[i]=r2[i-1]+1,r1[i]=r1[i-1];
		else r1[i]=r1[i-1]+1,r2[i]=r2[i-1];
		if(r1[i]==r2[i]) ans++;
	}
	for(int i=1;i<pos;i++)     //统计l1[i]-l2[i]=k的数字个数，k作为f1数组的下标，k有可能小于0，所以加n
		f1[l1[i]-l2[i]+n]++;
	for(int i=pos+1;i<=n;i++)  //同上
		f2[r1[i]-r2[i]+n]++;
	for(int i=-n;i<=n;i++)
		ans+=f1[i+n]*f2[-i+n];  //计算答案
	printf("%d",ans+1);		//m本身也要算上，ans+1	
}
```
			
最后讲一个有意思的解法，同学想出来的，不是满分算法

把大于等于m的记为1,小于m的记为0,若区间[i,j]的和为（j-i）/2,则[i,j]为一个符合条件的区间，用线段树维护区间和。如果哪位大佬有优化的方法，可以私信我
            

---

## 作者：荣一鸣 (赞：0)

很容易想到的是，统计在m的左边比他大的有几个，比他小的有几个，右边同样统计，然后找位置使得左右比m大的个数与比m小的个数相等，这就是一个满足条件的序列，然而这样的时间复杂度很高

在仔细的思考后，发现可以用比m大的个数减去比m小的个数来表示状态，扫右边，把右边的每个状态放进vector里，然后做左边，若左边的k（即比m大的数的个数减去比m小的数的个数）加上右边的k等于0则满足序列条件。因此，把右边的vector排序，然后在vector里二分找比-m大的第一个和比他小的最后一个，把这两个数的位置减一下再减一就是符合的个数，在求和就行了。

不想手打二分的可以用lower bound和upper bound。

下面上代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int a[100010];
int n,m,tmp,pos;
int l[100010];
vector<int> r[2];
int sum;

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==m) pos=i;
	}
	for(int i=pos-1;i>=1;i--){
		l[i]=l[i+1];
		if(a[i]<m){
			l[i]++;
		}
		else{
			l[i]--;
		}
	}
	int rt=0;
	for(int i=pos+1;i<=n;i++){
		int l=i-pos; 
		if(a[i]<m){
			rt++;
		}
		else{
			rt--;
		}
		if(l%2==0){
			r[0].push_back(rt);
		}
		else{
			r[1].push_back(rt);
		}
	}
	sort(r[0].begin(),r[0].end());
	sort(r[1].begin(),r[1].end());
	for(int i=1;i<=pos;i++){
		int lenl=pos-i;
		int k;
		if(lenl%2==0){
			k=0;
			if(l[i]==0) sum++;
		}
		else{
			k=1;
		}
		sum+=upper_bound(r[k].begin(),r[k].end(),-l[i])-lower_bound(r[k].begin(),r[k].end(),-l[i]);
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：fanhaotian (赞：0)

思路前面两位基本上讲清了，就是对前后分别进行统计，然后扫描

C++选手可以用map使程序更加容易理解，就不需要开两倍加常数了，而且也省空间

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<map>
using namespace std;
const int N=100002;
map<int,int>f;
int a[N],n,b,i,p,ans=0,s=0;
void in()
{
scanf("%d%d",&n,&b);
for(i=1;i<=n;i++)
scanf("%d",&a[i]);
for(i=1;i<=n;i++)
if(a[i]==b)
{p=i;break;}}
void work()
{for(i=p;i>=1;i--)
{if(a[i]>b)s++;if(a[i]<b)s--;
if(s==0)ans++;f[s]++;}
s=0;
for(i=p+1;i<=n;i++)
{if(a[i]>b)s++;if(a[i]<b)s--;
ans+=f[-s];}}
void out()
{cout<<ans;}
int main()
{in();work();out();return 0;}
```

---

## 作者：封禁用户 (赞：0)

没有pascal题解看的我好心塞啊。我来写一个

这道题如果有思路了，就是个水题了，思路呢，不是很难。

读入时预处理一下，比b大的记为1，比b小的记为-1，这样能简化统计。p是b位置，即a[p]:=b;

数组s记录的是从p向两边倒i处的和

```cpp
for i:=p-1 downto 1 do
s[i]:=s+a[i];
for i:=p+1 to n do
s[i]:=s+a[i];
```
这样就剩下最后一步了，求出s数组中p左右两边和为0的个数，这个就不说了，大家都有自己的做法，但一定要是O(n)的复杂度。这样全题的复杂度是O(n)仔细点就是
```cpp
O(3n)
var i,n,b,xx,yy,j,x,w:longint;
a:array[0..100003]of longint;
f1,f2:array[-100002..100002]of longint;
begin
readln(n,b);
for i:=1 to n do read(a[i]);
for i:=1 to n do
if a[i]=b then
begin
x:=0;
xx:=0;
yy:=0;
for j:=i-1 downto 1 do
begin
if a[j]<b then dec(x) else inc(x);
inc(f1[x]);
if x=0 then inc(xx);
end;
x:=0;
for j:=i+1 to n do
begin
if a[j]<b then dec(x) else inc(x);
inc(f2[x]);
if x=0 then inc(yy);
end;
w:=0;
for j:=1 to 100000 do
w:=w+f1[j]*f2[-j]+f1[-j]*f2[j];
writeln(w+xx+yy+xx*yy+1);
halt;
end;
end.
```

---


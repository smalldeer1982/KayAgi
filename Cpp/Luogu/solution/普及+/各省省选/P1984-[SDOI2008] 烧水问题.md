# [SDOI2008] 烧水问题

## 题目描述

把总质量为 $1\ \rm kg$ 的水分装在 $n$ 个杯子里，每杯水的质量均为 $(1/n)\ \rm kg$，初始温度均为 $0$ 度。现需要把每一杯水都烧开。我们可以对任意一杯水进行加热。把一杯水的温度升高 $t$ 度所需的能量为 $(4200\times t/n)\rm J$，其中，$\rm J$ 是能量单位“焦耳”。如果一旦某杯水的温度达到 $100$ 度，那么这杯水的温度就不能再继续升高，此时我们认为这杯水已经被烧开。显然地，如果直接把水一杯一杯地烧开，所需的总能量为 $(4200\times 100)\rm J$。

在烧水的过程中，我们随时可以在两杯温度不同的水之间进行热传递操作。热量只能从温度较高的那杯水传递到温度较低的那杯水。由于两杯水的质量相同，所以进行热传递操作之后，原来温度较高的那杯水所降低的温度总是等于原来温度较低的那杯水所升高的温度。

一旦两杯水的温度相同，热传递立刻停止。

为了把问题简化，我们假设：

1. 没有进行加热或热传递操作时，水的温度不会变化。
2. 加热时所花费的能量全部被水吸收，杯子不吸收能量。
3. 热传递总是隔着杯子进行，$n$ 杯水永远不会互相混合。
4. 热传递符合能量守恒，而且没有任何的热量损耗。

在这个问题里，只要求把每杯水都至少烧开一遍就可以了，而不要求最终每杯水的温度都是 $100$ 度。我们可以用如下操作把两杯水烧开：先把一杯水加热到 $100$ 度，花费能量 $(4200\times 100/2)\rm J$，然后两杯水进行热传递，直到它们的温度都变成 $50$ 度为止，最后把原来没有加热到 $100$ 度的那杯水加热到 $100$ 度，花费能量 $(4200\times 50/2)\rm J$，此时两杯水都被烧开过了，当前温度一杯 $100$ 度，一杯 $50$ 度，花费的总能量为 $(4200\times 75)\rm J$，比直接烧开所需的 $(4200\times 100)\rm J$ 少花费了 $25\%$ 的能量。

你的任务是设计一个最佳的操作方案使得 $n$ 杯水都至少被烧开一遍所需的总能量最少。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le n \le 3000000$。

## 样例 #1

### 输入

```
2```

### 输出

```
315000.00```

# 题解

## 作者：p878567 (赞：49)

话说这么多人怎么只找规律却不证明？
加热方法很简单，加热第一杯，并**依次**传递到每一杯，然后加热第二杯并依次传递，直到加热最后一杯。这其实是个贪心，证明从略。

下面解决怎么算的问题。

方法一：时间$O(n^2)$,空间$O(n^2)$

令$f[i][j]$表示第$i$杯水加热并传给第$j$杯后，第$j$杯的热量，（$f[i][i]=\frac{420000}{n}$，否则后面的递推式不能用）答案为$\displaystyle\sum_{i=1}^{n}(f[i-1][i]+f[i][i])$。

由定义可知：

$f[i][j]=\begin{cases}\frac{420000}{n}&\quad(i=j)\\0&\quad(i=0)\\\frac{f[i-1][j]+f[i][j-1]}{2}&\quad\text{其它情况}  \end{cases}$

第三种情况是因为：
$f[i][j]=f[i-1][j]+\frac{f[i][j-1]-f[i-1][j]}{2}=\frac{f[i-1][j]+f[i][j-1]}{2}$

计算递推式即可。



方法二：时间$O(n)$,空间$O(1)$

由前面的分析，我们有：

$f[i-1][i]=\frac{f[i-1][i-1]}{2}+\frac{f[i-2][i]}{2}=\frac{f[i-1][i-1]}{2}+\frac{f[i-2][i-1]}{4}+\frac{f[i-3][i]}{4}$

$\quad=\frac{f[i-1][i-1]}{2}+\frac{f[i-2][i-2]}{8}+\frac{2(f[i-3][i-1])}{8}+\frac{f[i-4][i]}{8}$

$\quad=\dots$

$\quad=\frac{k_1\cdot f[i-1][i-1]}{2}+\frac{k_2\cdot f[i-2][j-2]}{8}+\dots+\frac{k_j\cdot f[i-j][i-j]}{2^{2j-1}}+\dots+\frac{k_{n-1}\cdot f[1][1]}{2^{2n-3}}$

$\quad=\displaystyle\sum^{i-1}_{j=1}(\frac{k_j}{2^{2j-1}}\cdot \frac{420000}{n})$

由数学归纳法，我们得到$k_i$在意义上为：

边长为n的方阵中，除起点和终点外，其余各点都在左上——右下的对角线以下的一半（**不含对角线上**）的，从$(n,n)$到$(n-i,n-i)$的且只往上或右走的路径的数量，即：

$k_i=C_{i-1}\text{（这里的C是卡特兰数！）}$

卡特兰数？自己查！

于是：

$f[i-1][i]=\displaystyle\sum^{i-1}_{j=1}(\frac{C_{j-1}}{2^{2j-1}}\cdot \frac{420000}{n})$

$\quad=\displaystyle\sum^{i-1}_{j=1}(\frac{\frac{\binom{j-1}{2(j-1)}}{j}}{2^{2j-1}}\cdot \frac{420000}{n})$

$\quad=\displaystyle\sum^{i-1}_{j=1}(\frac{[2(j-1)]!}{2^{2j-1}\cdot j!\cdot (j-1)!}\cdot \frac{420000}{n})$

$\therefore f[i][i+1]-f[i-1][i]=\frac{(2i-2)!}{2^{2i-1}\cdot i!\cdot (i-1)!}\cdot \frac{420000}{n}$

令上式为$g[i]$，则：

$\frac{g[i+1]}{g[i]}=\frac{\frac{(2i)!}{2^{2i+1}\cdot (i+1)!\cdot i!}}{\frac{(2i-2)!}{2^{2i-1}\cdot i!\cdot (i-1)!}}=\frac{2^{2i-1}(2i)!i!(i-1)!}{2^{2i+1}(2i-2)!(i+1)!i!}=\frac{2i-1}{2i+2}$

而$g[1]=\frac{210000}{n}$， 于是可依次求出$g$的值，从而求出$420000-\displaystyle\sum^{n}_{i=1}f[i-1][i]$的值，此值即为答案。

~~做省选题的人不至于还要代码吧~~

```cpp

#include<bits/stdc++.h>
using namespace std;
int main() {
	int n;
	cin >> n;
	double ans = 0, f = 420000.00/n, g = 210000.00/n;
	for (int i = 1; i <= n; i++) {
    	ans += f;
		f += g;
		g = g*(2*i-1)/(2*i+2);
	}
	cout << fixed << setprecision(2) << 420000 - ans << endl;
}
```

---

## 作者：jimi1999 (赞：46)

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
double t[50001];
//推导：设沸腾温度为a
//则第一杯温度为a,需要加热t1=a 
//第二杯可以中和的最高温度为a/2,需要加热t2=a/2 
//第三杯可以中和的最高温度为t3=(a/4+a)/2=5a/8,需要加热t3=3a/8 
//第四杯可以中和的最高温度为t4=((a/8+5a/8)/2+a)/2=11a/16,需要加热t4=5/16 
//则t3/t2=3/4=1-1/4,  t4/t3=5/6=1-1/6
//继续推导得t(n+1)/t(n)=1-1/2n

int main(){
    int n;
    double res,now;
    cin>>n;
    now = 420000.00/n;
    for(int i=1;i<=n;i++){
        res+=now;
        now*=(1-0.5/i);
    }    
    printf("%.2lf\n", res);
    return 0;
} 
```

---

## 作者：夜刀神十香ღ (赞：21)

分析找规律：

一个很容易想到的思路就是把每杯水能传递的热量都给传递,考虑第i杯水，如果想要到100℃，那么从第1杯到第i-1杯水能给它热传递就热传递，这样可以发现从1到i-1杯水的温度是递增的，所以结果一定是最优的，然后把这个暴力打上去后TLE......证明这题并没有我想的这么简单。


那么就要用一些特殊的方法了，注意到题目只给出了一个数n,而要求输出一堆东西，那么很显然，不是递推就是数学公式，加上数据有那么大，可以确定为数学公式~~,然后发现这个公式我推不出来，~~那么这个时候就要找规律了，手动模拟一下。


为了方便起见，每杯水升1℃需要消耗1J，假设有4杯水，

第一杯水需要消耗100J的能量

第二杯水需要消耗50J的能量

第三杯水需要消耗37.5J的能量

第四杯水需要消耗31.25J的能量

……
设第i杯水花费的能量为costi

那么cost2=(1/2)cost1

cost3=(3/4)cost2

cost4=(5/6)cost3

**∴对于第i杯水而言，消耗的能量=costi-1 \* (2\*i-1)/(2\*i)**

数学规律有时候也要靠找规律找到啊！

奉劝各位一句：

\_自己动手，丰衣足食！\_


==========================我叫分割线==================================


代码：

```cpp
#include<cstdio>
#include<cstring>
int n; double ans;
int main()
{
    scanf("%d",&n);double cost=420000.00/n;
    for(int i=1;i<n;i++)
    {
        ans+=cost;
        cost*=(double)(2*i-1)/(double)(2*i);
    }
    printf("%.2lf",ans+cost);
       //记得加上最后一个
    //在这被坑惨了……
    return 0;
}
```

---

## 作者：cold_cold (赞：5)

**尽量加热温度最高的，在与次高的热传递**

![](https://cdn.luogu.com.cn/upload/pic/17839.png)

![](https://cdn.luogu.com.cn/upload/pic/17841.png)

![](https://cdn.luogu.com.cn/upload/pic/17842.png)

# 最后得出公式t(n+1)=t(n)*（1-1/2n）

**实现如下**

```
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
int n;
double ans,c;
int main()
{
    scanf("%d",&n);
    c=420000.00/n;
    for(int i=1;i<=n;i++)
    {
        ans+=c;
        c*=(double)(2*i-1)/(double)(2*i);
    }
    printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：傅思维666 (赞：4)

## 题解：

贪心，发现肯定不能逐一加热，而是一杯一杯热。那么就是先热第一杯，然后开始传递热量。传递热量的话，一定要都传递完毕，也就是第二杯传50，第三杯传25，一直到第n杯都有的传。

然后再热第二杯，这时就只需要加热50度了，同理，继续传递热量到n个杯子。

那么我们稍微推一下，假设第i杯还需要加热的热量为$tot[i]$，那么有：
$$
tot[i]=100-(\frac{\sum_{j=2}^{j=i-1}\frac{100}{2^j}+100}{2})
$$
非常兴奋，发现这个等比数列求和可以O(n)递推。但是最后就错了。因为这个递推在i特别大的时候会丢太多的精度。所以就挂了。

那么怎么办呢？到手的分没有了QAQ。

由于tot[i]的形式非常相似，我们看看可不可以在相邻两项直接递推tot[i]？经过手推样例，可以发现：
$$
tot[i+1]/tot[i]=\frac{2i-1}{2i}
$$
然后就可以无精度损失地递推了。

代码：

```cpp
#include<cstdio>
using namespace std;
const int maxn=3e6+6;
double t[maxn];
int n;
int main()
{
	// freopen("water.in","r",stdin);
	// freopen("water.out","w",stdout);
	scanf("%d",&n);
	double tot=100.0;
	t[1]=100.0;
	for(int i=2;i<=n;i++)
	{
		t[i]=t[i-1]*(2*(i-1)-1)/(2*(i-1));
		tot+=t[i];
	}
	double ans=4200*tot/n;
	printf("%.2lf\n",ans);
	return 0;
}
```





---

## 作者：ttt_TTT (赞：3)


只要每次最大限度地利用热能就行了，因此先加热第一杯，然后与第二杯平均，再与第三杯平均。。。。

然后烧开第二杯，与第三杯平均，再与第四杯平均。。。。

可以证明：1温度是递减的，因此每次一定能放热。2如果每次不按照顺序平均，那么平均第i杯后的温度就会高于原顺序时的，那么这是在到回去平均，温度一定高于理论的温度，于是如果继续往后，温度也一定更高，不划算

然而这样时n^2的， 所以要剪，当放热小于一个对精度没有影响的值时，break掉，这样差不多是nlog的

```
#include <cstdio>  

  

int main()  

{  

    int n; scanf("%d", &n);  

    double cur = 420000.00 / n, tot = 0;  

    for (int i = 1; i < n; i++) tot += cur, cur *= (double)(2 * i - 1) / (double)(2 * i);  

    printf("%.2lf\n", tot + cur);  

    return 0;  

}  
```

---

## 作者：gaodechen (赞：1)

是SDOI的题目吗? 网上没有查到相关信息...


首先可以肯定有一杯必须加热到100. 然后考虑剩下的, 尽量最大化热量的重复利用, 能分就分. 比如三杯, 最有策略是第一杯100, 分50, 此时50, 50, 然后加热第二杯, 变成50, 100. 如果最优的话就是先50分它25, 然后100和他分. 就是62.5. 就是先分热量小的. 让之后的大的有尽量多的机会, 就是最有策略.


---

## 作者：HRLYB (赞：0)

[P1984 [SDOI2008]烧水问题](https://www.luogu.org/problem/P1984)

贪心：

1.```一杯杯地烧开比几杯一起烧开要优```.

解释：如果每次只烧开一杯，那么烧开之后可以用热传递**给其他所有杯都加热一些**；而如果同时烧开几杯，那么相当于本来可以用热传递先加热再烧开的那些水直接烧开了，增加了总的加热温度，所以不优.

2.``每次烧水时都贪心地选择此时温度最高的那一杯烧开``.

解释：如果我们当前选择的不是温度最高的一杯，那么它实际上本来是可以先被热传递加热一些的，现在选择它会导致总的加热温度增加.


------------

通过以上的分析，我们不难得出具体做法：**每次依次选择温度最高的一杯加热，直到所有杯的水都烧开过为止.**

也就是枚举每一杯水，然后对其他还没有烧开的水进行热传递.

暴力的做法是$O(n^2)$的，无法通过该题. 所以我们不妨列出几项找找规律.

~~果然数论题还是应该推式子找各项之间加减乘除乘方的递推关系吗~~

>第一杯，加热到沸点$p$，温度增量为$p$
>
>第二杯，热传递后温度为$p/2$，温度增量为$p/2$
>
>第三杯，热传递后温度为$(p/4+p)/2=5p/8$，温度增量为$3p/8$
>
>第四杯，热传递后温度为$((p/8+5p/8)/2+p)/2=11p/16$，温度增量为$5p/16$

观察发现，每两杯之间的温度增量之比：

>第二杯：第一杯=$1/2$
>
>第三杯：第二杯=$3/4$
>
>第四杯：第三杯=$5/6$
>
>第$n$杯：第$n-1$杯=$(2(n-1)-1)/2(n-1)$

通过归纳法（已有大佬论证，不加以赘述）可以得证.

又因为**能量增量的比等于温度增量之比**，最小总能量等于能量增量之和，所以我们就可以在$O(n)$之内算出最小的总能量了.

注意初始化第一杯水所需的能量为$(4200*100)/n$.

```cpp
#include<bits/stdc++.h>
#define ldb long double
#define maxn 3000010
using namespace std;
ldb sum(ldb x){
	return ((x-1)*2-1)/((x-1)*2);
}
int n;
ldb eng[maxn],ans;
int main(){
	scanf("%d",&n);
	eng[1]=((ldb)420000/(ldb)n);ans=eng[1];
	for(int i=2;i<=n;i++){
		eng[i]=sum(i)*eng[i-1];//能量增量之间的比例关系
		ans+=eng[i];//总能量增量等于答案
	}
	printf("%.2Lf\n",ans);
	return 0;
} 
```


---

## 作者：不存在之人 (赞：0)

### 分析找规律：

**一个很容易想到的思路就是把每杯水能传递的热量都给传递,考虑第i杯水，如果想要到100℃，那么从第1杯到第i-1杯水能给它热传递就热传递，这样可以发现从1到i-1杯水的温度是递增的，所以结果一定是最优的，然后把这个暴力打上去后TLE……证明这题并没有我想的这么简单。**

**那么就要用一些特殊的方法了，注意到题目只给出了一个数n,而要求输出一堆东西，那么很显然，不是递推就是数学公式，加上数据有那么大，可以确定为数学公式,然后发现这个公式我推不出来，那么这个时候就要找规律了，手动模拟一下。**

**为了方便起见，每杯水升1℃需要消耗1J，假设有4杯水。**

- 第一杯水需要消耗100J的能量
- 第二杯水需要消耗50J的能量
- 第三杯水需要消耗37.5J的能量
- 第四杯水需要消耗31.25J的能量
- …… 设第i杯水花费的能量为costi

那么$cost2=(1/2)cost1$ $cost3=(3/4)cost2$ $cost4=(5/6)cost3$

∴对于第i杯水而言，消耗的能量=$costi-1*(2*i-1)/(2*i)$数学规律有时候也要靠找规律找到啊！
```cpp
#include<cstdio>
#include<cstring>
int n;
double ans;
int main()
{
    scanf("%d",&n);
    double s=420000.00/n;
    for(int i=1;i<n;i++)
    {
        ans+=s;
        s*=(double)(2*i-1)/(double)(2*i);
    }
    printf("%.2lf",ans+s);
    return 0;
}
```

---


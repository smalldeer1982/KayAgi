# [HAOI2007] 理想的正方形

## 题目描述

有一个 $a \times b$ 的整数组成的矩阵，现请你从中找出一个 $n \times n$ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。

## 说明/提示

矩阵中的所有数都不超过 $1,000,000,000$。

$20\%$ 的数据 $2 \le a,b \le 100,n \le a,n \le b,n \le 10$。

$100\%$ 的数据 $2 \le a,b \le 1000,n \le a,n \le b,n \le 100$。

## 样例 #1

### 输入

```
5 4 2
1 2 5 6
0 17 16 0
16 17 2 1
2 10 2 1
1 2 2 2
```

### 输出

```
1```

# 题解

## 作者：ｃｈｉｌｌ (赞：335)

我的思路是...**用单调队列分别维护行与列。**

具体实现方法:是先用单调队列对每一行的值维护，并将**a[][]**每个区间的最大值，最小值分别存在**X[][]**和**x[][]**中。

那么**X[][]**与**x[][]**所存储的分别是**1×n**的长方形内的最大值，最小值。**X[i][j]**存储第**i**行第**j~j+n-1**列的长方形中的最大值。同理，**x[i][j]**存储第**i**行第**j~j+n-1**列的长方形中的最小值。  

这时再对这两个数组的每一列上的值进行维护，将**X[][]**中每个区间的的最大值用**Y[][]**维护，将**x[][]**中的每个区间的最小值用**y[][]**维护。那么**Y[i][j]**存储**X[][]**中第**i~i+n-1**行第**j**列的长方形的最大值。同理**y[i][j]**存储**x[][]**中第**i~i+n-1**行第**j**列的长方形的最小值。

故**Y[i][j]**存储的实为以**a[i~i+n-1][j~j+n-1]**中的最大，即以**i,j**为左上角，边长为**n**的正方形中的最大值。同理，**y[i][j]**存储的即以**i,j**为左上角，边长为**n**的正方形中的最小值。

模拟过程见下图：

![](https://cdn.luogu.com.cn/upload/pic/15313.png)

附上代码（由于一些习惯，有些变量和题目规定的不太一样。。。）

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,k,front,FRONT,back,BACK,ans;
int a[1001][1001],q[1001],Q[1001];
int x[1001][1001],X[1001][1001];
int y[1001][1001],Y[1001][1001];

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for (int I=1;I<=n;I++)
		for (int i=1;i<=m;i++)
			scanf("%d",&a[I][i]);
	for (int I=1;I<=n;I++)
		{
			FRONT=BACK=front=back=Q[1]=q[1]=1;
			for (int i=2;i<=m;i++)
				{
					while (a[I][i]>=a[I][Q[BACK]]&&FRONT<=BACK) BACK--;
					while (a[I][i]<=a[I][q[back]]&&front<=back) back--;
					BACK++;back++;Q[BACK]=i;q[back]=i;
					while (i-Q[FRONT]>=k) FRONT++;
					while (i-q[front]>=k) front++;
					if (i>=k) X[I][i-k+1]=a[I][Q[FRONT]],x[I][i-k+1]=a[I][q[front]];
				}
		}
	for (int I=1;I<=m-k+1;I++)
		{
			FRONT=BACK=front=back=Q[1]=q[1]=1;
			for (int i=2;i<=n;i++)
				{
					while (X[i][I]>=X[Q[BACK]][I]&&FRONT<=BACK) BACK--;
					while (x[i][I]<=x[q[back]][I]&&front<=back) back--;
					BACK++;back++;Q[BACK]=i;q[back]=i;
					while (i-Q[FRONT]>=k) FRONT++;
					while (i-q[front]>=k) front++;
					if (i>=k) Y[i-k+1][I]=X[Q[FRONT]][I],y[i-k+1][I]=x[q[front]][I];
				}
		}
    ans=0x3f3f3f3f;
	for (int I=1;I<=n-k+1;I++)
		for (int i=1;i<=m-k+1;i++)
			ans=min(ans,Y[I][i]-y[I][i]);
	printf("%d\n",ans);
	return 0;
}

 
```



---

## 作者：Aisaka1436 (赞：115)

楼下几位的单调队列很巧妙，但代码比较复杂，不是很好调，这里介绍一种稍微简单一点的做法。

首先看一下朴素做法：直接O(a\*b)枚举矩形，再O(n\*n)统计矩形中的最大值和最小值，总时间复杂度O(a\*b\*n\*n)，显然会超时。

其中O(a\*b)是理论下限，肯定是没法优化的，所以我们想办法优化O(n\*n)的部分，也就是快速求出矩形中的最大值和最小值。

我最开始想的办法是预处理递推出矩形中的最大值和最小值，即：用**maxv(i,j,k)**表示以点**(i,j)**为左上角的边长为k的矩形中的最大值，然后用递推公式

**maxv(i,j,k)=max{maxv(i,j,k-1), maxv(i+1,j+1,k-1), maxv(i+1,j,k-1), maxv(i,j+1,k-1)}**

用O(a\*b\*n)的时间递推出所有边长为n的矩形中的最大值（最小值），再O(a\*b)求最小的差值，总时间复杂度O(a\*b\*n)。代码如下：

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

const int INF = 1000000000;
const int maxm = 1000 + 10;
const int maxn = 100 + 10;

int a, b, n;
int grid[maxm][maxm];
int maxv[maxm][maxm], minv[maxm][maxm];

int main ()
{
//    freopen("in.txt", "r", stdin);
    cin >> a >> b >> n;
    for (int i = 0; i < a; i++)
        for (int j = 0; j < b; j++) {
            scanf("%d", &grid[i][j]);
            maxv[i][j] = minv[i][j] = grid[i][j];
        }
    
    for (int k = 2; k <= n; k++)
        for (int i = 0; i+1 < a; i++)
            for (int j = 0; j+1 < b; j++) {
                maxv[i][j] = max(grid[i][j], max(maxv[i+1][j+1], max(maxv[i+1][j], maxv[i][j+1])));
                minv[i][j] = min(grid[i][j], min(minv[i+1][j+1], min(minv[i+1][j], minv[i][j+1])));
            }
    
    int ans = INF;
    for (int i = 0; i <= a-n; i++)
        for (int j = 0; j <= b-n; j++)
            ans = min(ans, maxv[i][j]-minv[i][j]);
    
    cout << ans;
    fclose(stdin);
    return 0;
}
```
因为程序的常数很小，我本来以为可以过，但是很可惜只得了50分。

那么也就是说即使用O(n)的时间统计最大值（最小值）也不行，那我们就向O(logn)优化。

再看一下上面的递推公式，我们发现其实这个公式很像RMQ问题的预处理代码。那么这样以来问题就清晰了，这其实就是一道二维RMQ问题：用**maxv(i,j,k)**表示以点**(i,j)**为左上角边长为2^k的矩形中的最大值，递推公式为

**maxv(i,j,k)=max{maxv(i,j,k), maxv(i+2^(k-1),j+2^(k-1),k-1),maxv(i,j+2^(k-1),k-1), maxv(i+2^(k-1),j,k-1) }**

查询边长为n的矩形的最大值也是类似的公式，详见代码。

这样以来，我们就得到了一个复杂度为O(a\*b\*logn)的算法，因为n只有100，所以logn可以忽略不计。代码如下

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

const int INF = 1000000000;
const int maxm = 1000 + 100;
const int maxn = 100 + 10;
const int maxlog = 10;

int a, b, n;
int logn;
int grid[maxm][maxm];
int maxv[maxm][maxm], minv[maxm][maxm];

int query (int x, int y){
    int _max = 0, _min = 0;
    _max = max(maxv[x][y], max(maxv[x+n-(1<<logn)][y+n-(1<<logn)], max(maxv[x+n-(1<<logn)][y], maxv[x][y+n-(1<<logn)])));
    _min = min(minv[x][y], min(minv[x+n-(1<<logn)][y+n-(1<<logn)], min(minv[x+n-(1<<logn)][y], minv[x][y+n-(1<<logn)])));
    return _max - _min;
}

int main ()
{
//    freopen("in.txt", "r", stdin);
    cin >> a >> b >> n;
    for (int i = 0; i < a; i++)
        for (int j = 0; j < b; j++) {
            scanf("%d", &grid[i][j]);
            maxv[i][j] = minv[i][j] = grid[i][j];
        }
    
    for (logn = 0; ((1<<(logn+1)) <= n); logn++);
    for (int k = 0; k < logn; k++)
        for (int i = 0; i+(1<<k) < a; i++)
            for (int j = 0; j+(1<<k) < b; j++) {
                maxv[i][j] = max(maxv[i][j], max(maxv[i+(1<<k)][j+(1<<k)], max(maxv[i+(1<<k)][j], maxv[i][j+(1<<k)])));
                minv[i][j] = min(minv[i][j], min(minv[i+(1<<k)][j+(1<<k)], min(minv[i+(1<<k)][j], minv[i][j+(1<<k)])));
            }
    
    int ans = INF;
    for (int i = 0; i <= a-n; i++)
        for (int j = 0; j <= b-n; j++)
            ans = min(ans, query(i, j));
    
    cout << ans;
    fclose(stdin);
    return 0;
}
```

---

## 作者：maomao9173 (赞：102)

### 相比做法而言，这个题的思路更有意思。这里本蒟蒻提供几种做法供大家参考（没有单调队列写法qwq因为我太蒻了+懒）
#### 首先值得注意的是，本题数据卡的非常紧，从20分到100分只是100到1000的差距，但是依然会卡掉大多数不优秀的写法。

### 1. 首先来讲最直观的想法：递推（70pts）
	
很显然我们可以用DP水掉这道题的大多数分。设f_max[i][j][k]表示以坐标[i,j]为右下角，边长为k的正方形的最大值,最小值同理再设一个。然后你会发现自己优雅地爆了空间QWQ
   
那么怎么办呢？因为每次处理的时候正方形边长+1，我们考虑压缩掉边长这个维度。也就是说，先预处理上边长为1的正方形（蛤蛤蛤就是输入啦），然后进行k-1次矩阵递推，得到的数据就一定是以k为边长的正方形的大小啦~
    
随手一水就有70分，是不是很开心呐QWQ
    
下面放代码，比较好理解，可以自己看一下
    
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define INF 2147483647
#define Anti_copy() printf("我永远喜欢CYDqwq\n")
using namespace std;
int n,m,k,ans=INF,mp[1010][1010],f_max[1010][1010],f_min[1010][1010];
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(register int i=1;i<=n;++i){
        for(register int j=1;j<=m;++j){
            scanf("%d",&mp[i][j]);
            f_max[i][j]=mp[i][j];//init 
            f_min[i][j]=mp[i][j];
        }
    }
    for(register int l=2;l<=k;++l){
        for(register int i=n;i>=l;i--){
            for(register int j=m;j>=l;j--){
                f_max[i][j]=max(mp[i][j],max(f_max[i-1][j],max(f_max[i][j-1],f_max[i-1][j-1])));
                f_min[i][j]=min(mp[i][j],min(f_min[i-1][j],min(f_min[i][j-1],f_min[i-1][j-1])));
            }
        }		
    }/**
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            printf("%2d ",f_max[i][j]);
        }
        printf("\n");
    }
    printf("\n");
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            printf("%2d ",f_min[i][j]);
        }
        printf("\n");
    }*/
    for(register int i=k;i<=n;++i){
        for(register int j=k;j<=m;++j){
            ans=min(ans,f_max[i][j]-f_min[i][j]);
        }
    }
    printf("%d\n",ans);
    Anti_copy();
    return 0;
} 
```

### 2. 优先队列写法（80pts）

原理和单调队列是一致的，都是预处理每一行的情况，存到一个数组里。我这里放的是一个max_m和min_m,i和j表示在第i行从[j-k+1,j]部分的最大值和最小值，就得到了好多好多长条的情况。查询的时候只需要O(n^2)把之前搞的长条拼在一块就可以了。
    
不过复杂度稍高于单调队列，所以并不能通过所有的点，但是却卡出来了一个非常鬼畜的分数。
    
思路简单，直接码就可以。
    
非常喜欢或者擅长写单调队列的同学请无视这里。
    
```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define INF 2147483647
#define Anti_copy() printf("我永远喜欢CYDqwq\n")
using namespace std;
struct node{
	int pos,val;
	bool operator>(const node &tmp)const{return val>tmp.val;};
	bool operator<(const node &tmp)const{return val<tmp.val;};
};
int n,m,k,mp[1010][1010];
int max_m[1010][1010],min_m[1010][1010];//max_n[1010][1010],min_n[1010][1010],

int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&mp[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		priority_queue<node,vector<node>,less<node> >que_max;
		priority_queue<node,vector<node>,greater<node> >que_min;
		for(int j=1;j<=k-1;j++){//预处理前面的部分 
			que_max.push((node){j,mp[i][j]});
			que_min.push((node){j,mp[i][j]});//把...push入队 
		}
		for(int j=k;j<=m;j++){
			que_max.push((node){j,mp[i][j]});
			que_min.push((node){j,mp[i][j]});
			while(que_max.top().pos<=j-k)que_max.pop();
			while(que_min.top().pos<=j-k)que_min.pop();
			max_m[i][j]=que_max.top().val;//max_m[i][j]表示第i行[j-k+1,j]这部分的最大值
			min_m[i][j]=que_min.top().val;//同理 
		}
	}/*
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%2d ",min_m[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%2d ",min_n[j][i]);
		}
		printf("\n");
	}*/
	int ans=INF;
	for(int i=1;i<=n-k+1;i++){
		for(int j=k;j<=m;j++){
			int maxx=0,minx=INF;
			for(int l=i;l<=i+k-1;l++){
				maxx=max(maxx,max_m[l][j]);
				minx=min(minx,min_m[l][j]);
			}
			ans=min(ans,maxx-minx);
		}
	}
	printf("%d\n",ans);
	Anti_copy(); 
	return 0;
} 
```

### 3.二维ST表/倍增写法（100pts但是卡的略紧）
	
不了解ST表的同学请移步这里: 
[https://www.luogu.org/problemnew/show/P3865](P3865【模板】ST表)
    
怎么写呢？在纸上仔细思考一下推一推就会发现写法很显然:倍增处理正方形边长，方法和转移都是基于DP的，只是复杂度从O（a*b*n）降低到了O（a*b*logn），虽然n不大，但是因为题目卡的紧，所以这种方法就成功地通过了这个题，而DP就被卡掉了。
    
其中有很多需要注意的细节，比如说logn设置成log2(n)向下取整，预处理只需要处理到logn-1(仔细想一想，为什么)，其他的就是直接处理直接DP直接查询就可以了。
    
因为我实在太蒻了，所以最开始写的时候也写不出来，借鉴了一下@caesar 的代码，并不是抄袭哦~
    
另外由于个人习惯，本人在这几份代码中都将a,b,n这些变量改成了n,m,k,不适应的话可以自行修改~
    
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define Anti_copy() printf("我永远喜欢CYD\n") 
using namespace std;
const int INF=2147483647;
int n,m,k,logk,grid[1010][1010],maxv[1010][1010],minv[1010][1010];

int query(int x, int y){
    int _max=0,_min=0;
    _max=max(maxv[x][y],max(maxv[x+k-(1<<logk)][y+k-(1<<logk)],max(maxv[x+k-(1<<logk)][y],maxv[x][y+k-(1<<logk)])));
    _min=min(minv[x][y],min(minv[x+k-(1<<logk)][y+k-(1<<logk)],min(minv[x+k-(1<<logk)][y],minv[x][y+k-(1<<logk)])));
    return _max-_min;
}

int main (){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&grid[i][j]);
            maxv[i][j]=minv[i][j]=grid[i][j];
        }    	
	}
	logk=floor(log2(k));
//	printf("logk=%d\n",logk);
    for(int s=0;s<=logk-1;s++){
        for(int i=1;i+(1<<s)<=n;i++){
            for(int j=1;j+(1<<s)<=m;j++){
                maxv[i][j]=max(maxv[i][j],max(maxv[i+(1<<s)][j+(1<<s)],max(maxv[i+(1<<s)][j],maxv[i][j+(1<<s)])));
                minv[i][j]=min(minv[i][j],min(minv[i+(1<<s)][j+(1<<s)],min(minv[i+(1<<s)][j],minv[i][j+(1<<s)])));
        	}        	
		}    	
	}
	/*
		此处应该注意：为什么是处理成logk呢？因为这个数组里面每一次都会扩张1倍，还要包括原来已经处理的大小，所以处理到logk-1就可以啦 
		*/
    int ans=INF;
    for(int i=1;i<=n-k+1;i++){//到n-k+1的原因是还要包括后面k面积为k的，需要+1 
        for(int j=1;j<=m-k+1;j++){
        	
            ans=min(ans,query(i,j));            	
		} 	
	}
	printf("%d",ans);
	Anti_copy();
    return 0;
}
```
### 4. 单调队列写法

#### 因为这个人实在太蒻了所以不会写，请移步其他题解qwq（逃


#### 如果对你有帮助的话就点个赞吧qwq

---

## 作者：Social_Zhao (赞：38)

# 前言

乱搞了一上午，那么让我来乱搞一篇题解吧

这题我本来是用单调队列过的，但是随手翻了翻题解，看见一个大佬拿随机乱搞过了，于是猛然想起这是一个多峰的函数：

> $f(x, y) = max\{w[i][j]\} - min\{w[i][j]\}$
> 
> 其中$x∈[n,a], y∈[n,b], i∈[x-n+1,x], j∈[y-n+1]$

可不可以退他一火呢？

所以我们来用玄学算法做一做。

# 严正声明

本题解非正解，而且很慢，甚至可以说仅供观赏。所以如果您把这个代码交了上去A不了，emm。

但是为了避免这篇题解过于无意义，我把我写的单调队列优化DP的思路也写在这里吧。

# 单调队列做法

### 思路

如果不会单调队列，请移步[P1886 滑动窗口](https://www.luogu.org/problem/P1886)。

这道题就相当于是一个二维的滑动窗口。我们首先设$fmax[i][j]$表示第$i$**行**，这一**行**到$j$，关键字是原矩阵的最大值，最小值同理。

然后我们设$gmax[i][j]$为第$i$**列**到第$j$个数，关键字是$fmax$数组的最大值，最小值同理。

用OI队列维护。

### 注意

第二次的循环变量要反着写。

### 代码

说了这么多有点抽象，来看一下代码。（那一天和同桌比谁的马蜂毒瘤，于是写了一个~~NOIP初赛~~CSP第一轮的代码）

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"

const int N = 1005;
int a, b, n;
int w[N][N];
int fmax[N][N], fmin[N][N];
int gmax[N][N], gmin[N][N];
int minn[10005], h1 = 0, t1 = 0;
int maxn[10005], h2 = 0, t2 = 0;

int main()
{
	std::ios::sync_with_stdio(0);
	std::cin.tie(NULL);
	std::cout.tie(NULL);
	std::cin >> a >> b >> n;
	for (int _ = 1; _ <= a; _++) {
		for (int __ = 1; __ <= b; __++) {
			std::cin >> w[_][__];
		}
	} 
	for (int _ = 1; _ <= a; _++) { //横着DP
		memset(minn, 0, sizeof(minn)); h1 = 1; t1 = 0; //注意每次都要清空
		memset(maxn, 0, sizeof(maxn)); h2 = 1; t2 = 0;
		for (int __ = 1; __ <= b; __++) {
			while (minn[h1] < __ - n + 1 && h1 <= t1) h1++;
			while (maxn[h2] < __ - n + 1 && h2 <= t2) h2++; //老年选手退役
			while (w[_][minn[t1]] >= w[_][__] && h1 <= t1) t1--; 
			while (w[_][maxn[t2]] <= w[_][__] && h2 <= t2) t2--; //如果一个人比你小还比你强，那你就打不过他了
			minn[++t1] = __;
			maxn[++t2] = __; //新选手加入OI队列
			fmin[_][__] = w[_][minn[h1]];
			fmax[_][__] = w[_][maxn[h2]]; //最强选手进省队
		}
	}
	for (int _ = 1; _ <= b; _++) { //竖着DP
		memset(minn, 0, sizeof(minn)); h1 = 1; t1 = 0;
		memset(maxn, 0, sizeof(maxn)); h2 = 1; t2 = 0; //注意每次都要清空
		for (int __ = 1; __ <= a; __++) {
			while (minn[h1] < __ - n + 1 && h1 <= t1) h1++;
			while (maxn[h2] < __ - n + 1 && h2 <= t2) h2++; //老年选手退役
			while (fmin[minn[t1]][_] >= fmin[__][_] && h1 <= t1) t1--;
			while (fmax[maxn[t2]][_] <= fmax[__][_] && h2 <= t2) t2--; //如果一个人比你小还比你强，那你就打不过他了
			minn[++t1] = __;
			maxn[++t2] = __; //新选手加入OI队列
			gmin[__][_] = fmin[minn[h1]][_];
			gmax[__][_] = fmax[maxn[h2]][_]; //最强选手进省队
		}
	}
	int ZnS = 0x3f3f3f3f; //纪念一个大佬
	for(int _ = n; _ <= a; _++) {
		for(int __ = n; __ <= b; __++) {
			ZnS = std::min(ZnS, gmax[_][__] - gmin[_][__]);
		}
	}
	std::cout << ZnS << std::endl;
}
```

下面进入正题。

# 模拟退火做法

## 思路

如果不会模拟退火，请移步[1337 \[JSOI2004\]平衡点 / 吊打XXX](https://www.luogu.org/problem/P1337)

我们这里每次生成一个向量，这个向量的长度和温度有关，即

```cpp
int X = (x + ((rand() << 1) - RAND_MAX) % (int)round(T * 10)) % a + 1;
int Y = (y + ((rand() << 1) - RAND_MAX) % (int)round(T * 10)) % b + 1;
if(X < n || X > a || Y < n || Y > b) {T *= delta; continue;} 
//这步一定要乘上delta，不然会由于脸黑陷入黑洞出不来。
//（这个随机数并不是完全随机，而是取决于它的种子的伪随机数）
```

然后用这两个新的点进行模拟计算，求出增量

```cpp
double now = calc(X, Y);
double Delta = now - ans;
```

如果$Delta$小于0，那么说明这是一个更优解，接受，其他情况以一个和温度、增量大小有关的概率接受它，温度越小、增量越大概率越小

```cpp
if(Delta < 0) {
	ans = now;
	x = X;
	y = Y;
	ansx = x;
	ansy = Y;
}
else if(exp(-Delta / T) * RAND_MAX > rand()) {
	x = X;
	y = Y;
}
T *= delta;
```

然后再时间允许的范围内尽可能多的跑模拟退火。

## 注意

下面的这份代码使用的随机种子是$time(NULL)$，然后它在二〇一九年九月十三日九时三十九分二十二秒不知道多少毫秒产生了可以AC此题的种子。此外平均得分为$90$左右。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1005;
int a, b, n;
int w[N][N];

const double MAX_TIME = 0.9;
const double delta = 0.996;
int ans = INT_MAX;
int ansx, ansy;

int calc(int x, int y)
{
	int minn = INT_MAX;
	int maxn = -INT_MAX;
	for(int i = x - n + 1; i <= x; i++) {
		for(int j = y - n + 1; j <= y; j++) {
			minn = min(minn, w[i][j]);
			maxn = max(maxn, w[i][j]);
		}
	}
	return maxn - minn;
}

void Simulate_Anneal()
{
	double T = max(a, b);
	int x = ansx, y = ansy;
	while(T > 0.1) {
		int X = (x + ((rand() << 1) - RAND_MAX) % (int)round(T * 10)) % a + 1;
		int Y = (y + ((rand() << 1) - RAND_MAX) % (int)round(T * 10)) % b + 1;
		//cout << T << " " << X << " " << Y << " : " << endl;
		//system("pause");
		if(X < n || X > a || Y < n || Y > b) {T *= delta; continue;}
		double now = calc(X, Y);
		double Delta = now - ans;
		//cout << T << " " << now << endl;
		if(Delta < 0) {
			ans = now;
			x = X;
			y = Y;
			ansx = x;
			ansy = Y;
		}
		else if(exp(-Delta / T) * RAND_MAX > rand()) {
			x = X;
			y = Y;
		}
		T *= delta;
	}
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	srand(time(NULL));
	cin >> a >> b >> n;
	for(int i = 1; i <= a; i++) 
		for(int j = 1; j <= b; j++) 
			cin >> w[i][j];
	ansx = ansy = n;	
	while ((double)clock() / CLOCKS_PER_SEC * 1.0 < MAX_TIME) Simulate_Anneal();
	cout << ans << endl;
}
```

# 总结

在这种题，如果不会正解，可以考虑随机算法，骗到分就跑。

我也该跑了。

---

## 作者：离散小波变换° (赞：29)

存在 $\mathcal O(ab)$ 的简单分块做法。

## 题解

为了叙述方便，下文中用 $n,m$ 表示大矩阵的行数与列数，$k$ 表示需要求出的正方形矩阵的边长。并且下标从 $0$ 开始，用 $(i, j)$ 表示第 $i+1$ 行第 $j+1$ 列的元素。

将大矩阵按照边长为 $k$ 分块，位置为 $(i, j)$ 的格子被分在了编号为 $(\lfloor i/k\rfloor, \lfloor j/k\rfloor)$ 的块内。这样做的好处是，每一个查询大小为 $k\times k$ 的子矩阵范围最大值/最小值的询问，要么恰好为某一整块，要么被分成了四个部分，分别是四个块的右下、左下、右上、左上。

计算一个矩阵的二维前缀 $\min/\max$ 是容易的。以计算一个矩阵左上前缀 $\min$ 为例，设 $f_{x,y}$ 表示 $\min_{0\le i\le x,0\le j\le y}\{a_{i,j}\}$，容易有 $f_{x,y} = \min(f_{x-1,y},f_{x,y-1},a_{x,y})$，不过需要特殊处理一下 $(x,y)$ 位置恰好落在边界的情况。

做完一个块的左上/左下/右上/右下的二维前缀 $\min/\max$ 只需要 $\mathcal O(k^2)$ 的复杂度。一共有 $\mathcal O(nm/k^2)$ 块。于是总复杂度为 $\mathcal O(nm)$。

不过因为每个块都要做四次前缀 $\min/\max$，常数还是比较大的，并且代码实现上需要一些技巧，否则可能代码会很长。

## 参考实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1e3 + 3;
int A[MAXN][MAXN];
int B[MAXN][MAXN];
int C[MAXN][MAXN];
int M[MAXN][MAXN], N[MAXN][MAXN];

int main(){
    int n, m, k;
    cin >> n >> m >> k;

    for(int i = 0;i < n;++ i){
        for(int j = 0;j < m;++ j){
            cin >> A[i][j];
            M[i][j] =  1e9;
            N[i][j] = -1e9;
        }
    }
    for(int i = 0;i <= (n - 1) / k;++ i){
        for(int j = 0;j <= (m - 1) / k;++ j){
            int u = i * k, v = min(n - 1, u + k - 1);
            int l = j * k, r = min(m - 1, l + k - 1);

            vector <tuple<int, int, int, int, int, int> > T = {
                { u, v, l, r, - k + 1, - k + 1 },
                { u, v, r, l, - k + 1, 0 },
                { v, u, l, r, 0, - k + 1 },
                { v, u, r, l, 0, 0 }
            };

            for(auto [l1, r1, l2, r2, d1, d2]: T){
                int t1 = 0, t2 = 0;

                t1 = r1 > l1 ? 1 : -1;
                t2 = r2 > l2 ? 1 : -1;
                for(int a = l1;a != r1 + t1;a += t1){
                    for(int b = l2;b != r2 + t2;b += t2){
                        B[a][b] = C[a][b] = A[a][b];
                        if(a != l1)
                            B[a][b] = min(B[a][b], B[a - t1][b]),
                            C[a][b] = max(C[a][b], C[a - t1][b]);
                        if(b != l2)
                            B[a][b] = min(B[a][b], B[a][b - t2]),
                            C[a][b] = max(C[a][b], C[a][b - t2]);
                        if(a + d1 >= 0 && b + d2 >= 0)
                            M[a + d1][b + d2] = min(M[a + d1][b + d2], B[a][b]),
                            N[a + d1][b + d2] = max(N[a + d1][b + d2], C[a][b]);
                    }
                }
            }
        }
    }

    int ans = 1e9;
    for(int i = 0;i < n - k + 1;++ i){
        for(int j = 0;j < m - k + 1;++ j){
            ans = min(ans, N[i][j] - M[i][j]);
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：夏色祭 (赞：21)

简单的st+单调队列

因为n，m不大，我们可以用:

ma[i][j][k]和mi[i][j][k]分别表示从(i,j)开始往右的$2^k$的数中的最大值和最小值。

算了下内存大概是2000w个int，并不会Mle。。

方程的话可以自己去baidu下st表。。。

然后我们怎么运用预处理出来的ma和mi数组来求最终的答案？

显然如果枚举这个n\*n的矩阵的右上角，然后再一行一行的找max和min，这样是会TLE的。

怎么办呢。。。

我们可以用两个单调队列来优化，先枚举这个矩阵的左边界，那么右边界我们也可以得到，然后一行一行往下，最大值和最小值用着这两个单调队列维护就行了。

代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#define For(i,x,y) for (int i=x;i<=y;i++)
#define N 1010
#define inf 1<<30
using namespace std;
int a[N][N],ma[N][N][11],mi[N][N][11],qmi[N][2],qma[N][2];
int n,m,t,h1,t1,h2,t2,ans,x;
inline int read(){
    int x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
} //读优
int queryma(int k,int x,int y){
    int l=log2(y-x+1);
    return max(ma[k][x][l],ma[k][y-(1<<l)+1][l]);
} //查询第k行的第x列到第y列的最大值
int querymi(int k,int x,int y){
    int l=log2(y-x+1);
    return min(mi[k][x][l],mi[k][y-(1<<l)+1][l]);
} //查询第k行的第x列到第y列的最小值
int main(){
    n=read(),m=read(),t=read();
    int l=log2(max(n,m));
    For(i,1,n)
      For(j,1,m){
          a[i][j]=read();
          ma[i][j][0]=mi[i][j][0]=a[i][j];
          For(k,1,10) 
            mi[i][j][k]=inf;
      }
    For(i,1,n)
      For(k,1,l){
          x=1<<(k-1);
          For(j,1,m-x){
                ma[i][j][k]=max(ma[i][j][k-1],ma[i][j+x][k-1]);
                mi[i][j][k]=min(mi[i][j][k-1],mi[i][j+x][k-1]);
          }
      } //求ma和mi数组
    ans=inf;
    For(i,1,m){
        if (i+t-1>m) break;
        h1=h2=1,t1=t2=0;
        For(j,1,n){
            x=queryma(j,i,i+t-1);
            while (x>=qma[t1][1]&&h1<=t1) t1--;
            qma[++t1][1]=x;
            qma[t1][0]=j;
            x=querymi(j,i,i+t-1);
            while (x<=qmi[t2][1]&&h2<=t2) t2--;
            qmi[++t2][1]=x;
            qmi[t2][0]=j;//两个单调队列维护最大值和最小值
            if (j>=t){
                while (j-t>=qma[h1][0]) h1++;
                while (j-t>=qmi[h2][0]) h2++;
                if (qma[h1][1]-qmi[h2][1]<ans) ans=qma[h1][1]-qmi[h2][1];
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：我没有名称 (赞：20)

忽然想随机乱搞了 于是就开始随机乱搞 然后试了几次就过了

每次随机枚举方阵的左上角 如果发现当前的差比以找到最小差大 直接跳出循环

其中有9个点很稳 第4个点有点坑
~~~cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<ctime>
using namespace std;
int a,b,s[1010][1010],n,t1,t2,mx,mn,ans=1999999999,check[1010][1010];
int main()
{
    int i,j,k;
    srand( (unsigned)(time) (NULL));
    cin>>a>>b>>n;
    for(i=1;i<=a;i++)
     for(j=1;j<=b;j++)
      scanf("%d",&s[i][j]);
    for(i=1;i<=300000;i++)//没错就是30w 不会超时
    {
        t1=rand()%(a-n+1)+1;
        t2=rand()%(b-n+1)+1;
        if(check[t1][t2]==1) continue;//一些剪枝
        check[t1][t2]=1;
        mn=1999999999;
        mx=0;
        for(j=t1;j<t1+n;j++)
        {
         for(k=t2;k<t2+n;k++)
         {
             if(s[j][k]>mx) mx=s[j][k];
             if(s[j][k]<mn) mn=s[j][k];
             if(mx-mn>ans) break;//一些剪枝
         }
         if(mx-mn>ans) break;
        }
        //cout<<t1<<" "<<t2<<" "<<mx<<" "<<mn<<endl;
        //system("pause");
        ans=min(ans,mx-mn);
    }
    cout<<ans; 
    return 0;
}
~~~

---

## 作者：Night_Aurora (赞：17)

作为Level 3的DP题我竟然强行线段树过了

通过多个线段树来维护每个方形区域里最大值和最小值，但是只能得80分，T了两个点

懒的写SBT BST什么的，于是用了个小优化：每次保存每行每N个数最大最小值时检测加入那个数和删去那个数是否影响上次的结果，否则直接拷贝

代码在最下面，简单优化了一下轻易过了，于是教会了我两件事

1.1e6的读入优化丝毫没用（除非卡980ms）

2.理想复杂度能过，但线段树的复杂度系数太大














    

        



```cpp
#include <stdio.h>
#include <stdlib.h>
#define INFINITE    0x7FFFFFFFFF
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)>(b)?(b):(a))
typedef struct LTREE
{
    int Mm;
    short F,T,M;
    LTREE*L,*R;
    int MakeTree(int Fr,int To,bool Ts,int*Dat);
    int Search(int Fr,int To,bool Ts);
}LTR,*LPLTR;
LTR Pool[3000];
int TP;
int LTR::MakeTree(int Fr,int To,bool Ts,int*Dat)
{
    if(Fr==To)
    {
        F=T=Fr;
        L=R=0;
        Mm=Dat[F];
        return Mm;
    }
    F=Fr,T=To;
    M=(F+T)>>1;
    L=Pool+TP++;
    R=Pool+TP++;
    int ma,mb;
    ma=L->MakeTree(Fr,M,Ts,Dat);
    mb=R->MakeTree(M+1,To,Ts,Dat);
    Mm= Ts?(min(ma,mb)):(max(ma,mb));
}
int LTR::Search(int Fr,int To,bool Ts)
{
    if(Fr==F&&To==T)
        return Mm;
    if(M>=To)
        return L->Search(Fr,To,Ts);
    if(Fr>M)
        return R->Search(Fr,To,Ts);
    int ma,mb;
    ma=L->Search(Fr,M,Ts);
    mb=R->Search(M+1,To,Ts);
    return Ts?(min(ma,mb)):(max(ma,mb));
}              //线段树内部代码死活没法再优化了，inline不支持递归函数貌似
LTR ML;
int Map[1010][1010];
int LMMap[1010][1010],HMMap[1010][1010];      //分别保存处理好的以坐标(a,b)为开头的n个数和n*n个数的最大值
int LmMap[1010][1010],HmMap[1010][1010];     //同理是最小值
int A,B,N,AA,AB;
void Input()
{
    scanf("%d %d %d",&A,&B,&N);
    int wia,wib,b;
    char c;
    AA=A-N+1;
    AB=B-N+1;
    for(wia=1;wia<=A;++wia)
        for(wib=1;wib<=B;++wib)
        {
            c=getchar();
            while(c<'0'||c>'9')c=getchar();
            b=0;
            while(c>='0'&&c<='9')
            {
                b=b*10+c-'0';
                c=getchar();
            }
            Map[wia][wib]=b;
        }
}
void DPA()
{
    int wia,wib,b;
    for(wia=1;wia<=A;++wia)
    {
        ML.MakeTree(1,B,0,Map[wia]);
        LMMap[1][wia]=ML.Search(1,1+N-1,0);
        for(wib=2;wib<=AB;++wib)
            if(Map[wia][wib+N-1]<=LMMap[wib-1][wia]&&Map[wia][wib-1]!=LMMap[wib-1][wia])
                LMMap[wib][wia]=LMMap[wib-1][wia];
            else    LMMap[wib][wia]=ML.Search(wib,wib+N-1,0);
        TP=0;
    }
    for(wib=1;wib<=AB;++wib)
    {
        ML.MakeTree(1,A,0,LMMap[wib]);
        for(wia=1;wia<=AA;++wia)
            HMMap[wia][wib]=ML.Search(wia,wia+N-1,0);
        TP=0;
    }
    for(wia=1;wia<=A;++wia)
    {
        ML.MakeTree(1,B,1,Map[wia]);
        LmMap[1][wia]=ML.Search(1,N,1);
        for(wib=2;wib<=AB;++wib)
            if(Map[wia][wib+N-1]>=LmMap[wib-1][wia]&&Map[wia][wib-1]!=LmMap[wib-1][wia])
                LmMap[wib][wia]=LmMap[wib-1][wia];
            else    LmMap[wib][wia]=ML.Search(wib,wib+N-1,1);
        TP=0;
    }
    for(wib=1;wib<=AB;++wib)
    {
        ML.MakeTree(1,A,1,LmMap[wib]);
        for(wia=1;wia<=AA;++wia)
            HmMap[wia][wib]=ML.Search(wia,wia+N-1,1);
        TP=0;
    }
}
int main()
{
    Input();
    DPA();
    int wia,wib,m=0x7FFFFFFF;
    for(wia=1;wia<=AA;++wia)
        for(wib=1;wib<=AB;++wib)
            m=min(m,HMMap[wia][wib]-HmMap[wia][wib]);
    printf("%d\n",m);
    return 0;
}
```

---

## 作者：ωαηg (赞：16)

作为一名蒟蒻，我表示我不会用大佬们的单调队列做这道题

所以我使用以下方法：
### ST表算两遍
具体是这么操作的：

我们设ma[i][j][k]为第i行第j列的格子，往右的$2^k$个数中的最大值

设mi[i][j][k]为往右$2^k$个数中的最小值

第一遍ST表：

很模板，想必大家都会

```cpp
for(int i=1;i<=a;i++)
  for(int j=1;j<=b;j++)
    ma[i][j][0]=mi[i][j][0]=data[i][j];//data是读进来的a*b的矩阵
for(int i=1;i<=a;i++)
  for(int k=1;k<=logmaxx;k++)//logmaxx是常量，即log(max(a,b))
	for(int j=1;j+(1<<k)-1<=b;j++){
	    ma[i][j][k]=max(ma[i][j][k-1],ma[i][j+(1<<k-1)][k-1]);
	    mi[i][j][k]=min(mi[i][j][k-1],mi[i][j+(1<<k-1)][k-1]);
	}
```

随后，我们把算好的ma[i][j][k]和mi[i][j][k]中所有区间长度为n的数值存入f[i][j]与z[i][j]，即：

f[i][j]表示第i行第j列的格子，往右的n个数的最大值

z[i][j]表示往右的n个数的最小值

如果第i行第j列的格子往右边不到n个数，那f[i][j]和z[i][j]就存右边b-j+1个数的最大值和最小值（否则后面要出锅）

```cpp
for(int i=1;i<=a;i++)
  for(int j=1;j<=b;j++){//相信大家应该已经掌握ST表的区间查询
    int x=j,y=min(j+n-1,b);
    int s=Log[y-x+1];
    f[i][j]=max(ma[i][x][s],ma[i][y-(1<<s)+1][s]);
    z[i][j]=min(mi[i][x][s],mi[i][y-(1<<s)+1][s]);
}
```

嗯，然后我们就要再弄两个数组：

ma2[i][j][k]表示第i行第j个数**往下**的$2^k$区间中，**f[i][j]**的最大值

mi2[i][j][k]表示第i行第j个数**往下**的$2^k$区间中，**z[i][j]**的最小值

### 我们知道，刚刚的f[i][j]和z[i][j]表示的是往右的最大值和最小值，而我们现在在这些最大值和最小值上往下再求一次最大值和最小值，就可以得到整个往右下方的矩阵的最大值与最小值

所以我们就开始第二遍ST表：
```cpp
 for(int i=1;i<=a;i++)
   for(int j=1;j<=b;j++){
     ma2[i][j][0]=f[i][j];
     mi2[i][j][0]=z[i][j];
   }
 for(int j=1;j<=b;j++)
   for(int k=1;k<=logmaxx;k++)
     for(int i=1;i+(1<<k)-1<=a;i++){
        ma2[i][j][k]=max(ma2[i][j][k-1],ma2[i+(1<<k-1)][j][k-1]);
        mi2[i][j][k]=min(mi2[i][j][k-1],mi2[i+(1<<k-1)][j][k-1]);
     }
```
最后，我们的答案就是所有区间长度为n（因为f[i][j]与z[i][j]也是长度为n的区间，所以这恰好是一个n*n的矩阵）的ma2[i][j]与mi2[i][j]的差的最小值

完美解决！

然而我们就遇到了一个神奇的问题

Memory Limit Exceeded

是的，刚刚我们开了四个三维int数组，外加三个二维int数组，内存肯定炸

所以我们再回过去看：

1.有没有发现f数组和z数组都很多余？它们都只是临时记录答案的中转站，其实都可以不要，我们只要把ma[i][j]和mi[i][j]在区间长度为n的时候的答案，直接赋给ma2[i][j][0]与mi2[i][j][0]即可。同理，我们可以把data数组也省掉

2.有没有发现ma2[i][j][k]与mi2[i][j][k]其实也很多余？我们直接把ma[i][j][k]与mi[i][j][k]循环利用就可以了

嗯，现在我们成功地简化成了两个三维的int数组，这样就不会MLE了（~~虽然依旧有79036KB的可怕内存~~）

废话不多说，上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int const maxx=1001;
int const logmaxx=10;
int ma[maxx][maxx][logmaxx];
int mi[maxx][maxx][logmaxx];
int Log[maxx],a,b,n;
inline int read(){//读入优化
	int sum=0;
	bool fushu=false;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') fushu=true;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		sum=(sum<<1)+(sum<<3)+(c^48);
		c=getchar();
    }
    if(fushu) sum=-sum;
    return sum;
}
signed main(){
	a=read(),b=read(),n=read();
	for(int i=1;i<=a;i++)
	  for(int j=1;j<=b;j++){
	  	int data=read();
	  	ma[i][j][0]=mi[i][j][0]=data;
	  }
    //C++自带的log2效率不高，我们直接O(n)预处理
	Log[0]=-1;//只有这样才能保证Log[1]=0
	for(int i=1;i<=max(a,b);i++) Log[i]=Log[i>>1]+1;
	for(int i=1;i<=a;i++)
	  for(int k=1;k<=logmaxx;k++)
	    for(int j=1;j+(1<<k)-1<=b;j++){
	    	ma[i][j][k]=max(ma[i][j][k-1],ma[i][j+(1<<k-1)][k-1]);
	    	mi[i][j][k]=min(mi[i][j][k-1],mi[i][j+(1<<k-1)][k-1]);
	    }
    for(int i=1;i<=a;i++)
      for(int j=1;j<=b;j++){
      	int x=j,y=min(j+n-1,b);//注意,是j+n-1，不是j+n
      	int s=Log[y-x+1];
      	ma[i][j][0]=max(ma[i][x][s],ma[i][y-(1<<s)+1][s]);//循环利用
      	mi[i][j][0]=min(mi[i][x][s],mi[i][y-(1<<s)+1][s]);
      }
    for(int j=1;j<=b;j++)
      for(int k=1;k<=logmaxx;k++)
        for(int i=1;i+(1<<k)-1<=a;i++){
        	ma[i][j][k]=max(ma[i][j][k-1],ma[i+(1<<k-1)][j][k-1]);
        	mi[i][j][k]=min(mi[i][j][k-1],mi[i+(1<<k-1)][j][k-1]);
        }
    int ans=2147483647;
    for(int i=1;i+n-1<=a;i++)
      for(int j=1;j+n-1<=b;j++){
      	int x=i,y=i+n-1;
      	int s=Log[y-x+1];
      	ans=min(ans,max(ma[x][j][s],ma[y-(1<<s)+1][j][s])-min(mi[x][j][s],mi[y-(1<<s)+1][j][s]));
      }
    printf("%d\n",ans);
    return 0;
}
```

本程序的时间复杂度是O(a*b log n)，还是可以接受的~~（就是空间复杂度大了一点）~~

看不懂可以私信我

---

## 作者：灼眼的夏娜 (赞：13)

本蒟蒻又来发题解了

这题是要求解一个最大值和一个最小值，并使他们的差最小

如果只有一行的话，问题就变成：

一个序列，有一个长度为k的区间，求从1到n区间最大（小）值

滑动窗口，单调队列

问题是现在是一个平面

然而我们看到，n和m都只有1000

那么我们是否可以做n遍单调队列呢？

显然是可以的

我们横向做n遍单调队列，就可以得到横向上的最大（小）值

将m，n反过来纵向做m遍单调队列，就可以得到纵向上的最大（小）值

最终会得到两个所求矩阵，在他们的差值中取min就好啦


代码如下

## code

```cpp
#include<bits/stdc++.h>
#define R register

using namespace std;
int n,m,k,s[1005][1005];
int head,tail,ans = 2147483647;
int f[1005][1005],g[1005][1005];
int x[1005][1005],y[1005][1005];
int q[1005];	

int main() {
	scanf("%d%d%d",&n,&m,&k);
	for(R int i = 1;i <= n;++ i)
		for(R int j = 1;j <= m;++ j)
			scanf("%d",&s[i][j]);
	for(R int i = 1;i <= n;++ i) {
		head = tail = q[1] = 1;
		for(R int j = 2;j <= m;++ j) {
			while(head <= tail && s[i][q[tail]] <= s[i][j]) tail --;
			q[++tail] = j;
			while(head <= tail && q[head] <= j - k) head ++;
			if(j >= k) f[i][j - k + 1] = s[i][q[head]];
		}
	}
	memset(q,0,sizeof(q));
	for(R int i = 1;i <= m - k + 1;++ i) {
		head = tail = q[1] = 1;
		for(R int j = 1;j <= n;++ j) {
			while(head <= tail && f[q[tail]][i] <= f[j][i]) tail --;
			q[++tail] = j;
			while(head <= tail && q[head] <= j - k) head ++;
			if(j >= k) x[j - k + 1][i] = f[q[head]][i];
		}
	}
	memset(q,0,sizeof(q));
	for(R int i = 1;i <= n;++ i) {
		head = tail = q[1] = 1;
		for(R int j = 2;j <= m;++ j) {
			while(head <= tail && s[i][q[tail]] >= s[i][j]) tail --;
			q[++tail] = j;
			while(head <= tail && q[head] <= j - k) head ++;
			if(j >= k) g[i][j - k + 1] = s[i][q[head]];
		}
	}
	memset(q,0,sizeof(q));
	for(R int i = 1;i <= m - k + 1;++ i) {
		head = tail = q[1] = 1;
		for(R int j = 1;j <= n;++ j) {
			while(head <= tail && g[q[tail]][i] >= g[j][i]) tail --;
			q[++tail] = j;
			while(head <= tail && q[head] <= j - k) head ++;
			if(j >= k) y[j - k + 1][i] = g[q[head]][i];
		}
	}
	for(R int i = 1;i <= n - k + 1;++ i)
		for(R int j = 1;j <= m - k + 1;++ j) 
			ans = min(ans,x[i][j] - y[i][j]);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：DefFrancis (赞：8)

蒟蒻不会用单调队列，于是就拿基于dp的st表做

首先，由于n是固定的，所以我们可以少一维或者两维

因此开2维数组dp[i][k]

表示i k这个点,面积为2的k次方，2的j次方内最大(最小值)初始k=0，运算完之后，2的j次方<n<2的j+1次方

然后就是运用倍增的思想啦

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int X=0,w=1; char ch=0;
    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}
int dp1[1005][1005],dp2[1005][1005],a,b,n,ans=INT_MAX;
int maxx(int a,int b,int c,int d){
    int e=max(a,b);
    int f=max(c,d);
    return max(e,f);
}
int minn(int a,int b,int c,int d){
    int e=min(a,b);
    int f=min(c,d);
    return min(e,f);
}/*algorithm里max,min函数不好用..不支持n个数返回最大最小值，所以自己定义一个*/
int query(int x,int y){
    int mmax,mmin;
    int k=0;
        for(;;){
            if((x+(1<<k))>(x+n-1-(1<<k)))break;
            k++;
```
}/\*当然，因为是正方形，所以看一个方向上有没有覆盖查询的正方形就行了，如果x到x+2的j次方覆盖了x+n-1到x+n-1-2的j次方，此时以下四个点可以全部覆盖被查询的正方形\*/
mmax=maxx(dp1[x][y],dp1[x+n-(1<<k)][y],dp1[x][y+n-(1<<k)],dp1[x+n-(1<<k)][y+n-(1<<k)]);

mmin=minn(dp2[x][y],dp2[x+n-(1<<k)][y],dp2[x][y+n-(1<<k)],dp2[x+n-(1<<k)][y+n-(1<<k)]);

```cpp
    return mmax-mmin;
}
int main(){
    a=read(),b=read(),n=read();
    for(int i=1;i<=a;i++){
        for(int j=1;j<=b;j++){
            dp1[i][j]=read();
            dp2[i][j]=dp1[i][j];
        }
```
}/\*初始dp[i][k]表示以当前点起点，2的0次方内最大最小值\*/
```cpp
    int j;
    for(j=1;(j<<1)<=n;j=(j<<1)){
        for(int i=1;i+j<=a;i++){
            for(int k=1;k+j<=b;k++){
                dp1[i][k]=maxx(dp1[i][k],dp1[i+j][k],dp1[i][k+j],dp1[i+j][k+j]);/*每次一个大循环之后，dp[i][j]的值就更新成原来四倍大小面积的最大最小值*/
                dp2[i][k]=minn(dp2[i][k],dp2[i+j][k],dp2[i][k+j],dp2[i+j][k+j]);/*至于为什么，手动模拟一下很容易的...*/
            }
        }
```
}/\*尤其注意不要越界，j<<1表示j\*2.\*/
```cpp
    for(int i=1;i+n-1<=a;i++){
        for(int j=1;j+n-1<=b;j++){
            ans=min(ans,query(i,j));
        }
```
}/\*因为n不一定是2的几次方数，所以要查询，否则就10分...\*/
```cpp
    cout<<ans;
}
//Handan No.1 high school
//by DefFrancis
/*速度还是可以，开启臭氧优化(O3)可以1000ms左右，比三维快一点点*/
```

---

## 作者：Vsinger_洛天依 (赞：6)

发现没有人和我用同一个做法，遂发题解。

考虑暴力，首先枚举 $n\times n$ 矩形的位置，发现已经 $O(ab)$ 了，而处理内部是 $O(n^2)$ 的肯定会 TLE。

发现 $n\times n$ 矩形每次就是往右移一位，那么减去矩形左边那一列的贡献，再加上新的这一列的贡献即可。

复杂度 $O(abn)$ 可以通过。

```cpp
inline void Init(){
	memset(maxn,-0x3f,sizeof(maxn));
	memset(minn, 0x7f,sizeof(minn)); 
	for_(i,1,a-n+1){
		for_(j,1,b){
			for_(k,1,n){
				maxn[i][j] = max(maxn[i][j] ,mapp[i+k-1][j]); // maxn_{i,j} 为以 (i,j) 为起点向右延申 n 格的矩阵内最大值 
				minn[i][j] = min(minn[i][j] ,mapp[i+k-1][j]);
			}
		}
	}
}

inline void solve(){
	for_(i,1,a-n+1){
		for_(j,1,b-n+1){
			int MAX=-inf,MIN=inf;
			for_(k,1,n){
				MAX=max(MAX,maxn[i][j+k-1]);
				MIN=min(MIN,minn[i][j+k-1]);
			}
			ANS=min(ANS,MAX-MIN);
		}
	}
	cout << ANS << endl;
}

inline void In(){
	cin >> a >> b >> n;
	for_(i,1,a){
		for_(j,1,b){
			cin >> mapp[i][j] ;
		}
	}
	Init();
	solve();
}
```

---

## 作者：_Qer (赞：6)

#### 简单来说我的做法就是用单调队列来维护单调队列

首先很容易想到暴力（$O(n^2ab)$）的做法。  

然后我们发现可以将暴力找最大最小值的过程进行优化，每行的最大最小值用单调队列维护，每次枚举列，在每连续$n$行的最大最小值中找最大和最小，这样我们就找到了一个 $O(nab)$ 的做法，可以靠吸氧过。  
不吸氧 = 50pts （本人代码）  
吸氧 = 100pts （1.85s）

继续在上一个方法的基础上优化，发现在找每连续 $n$ 行时耗费了不小的时间复杂度，仔细看看，这也是一个单调队列，于是我们可以再用一次单调队列来维护之前的单调队列的最值，这样就能优化到 $O(ab)$ ，可以不吸氧过这题。  
不吸氧 =100pts （3.11s）

最后总结一句， $O2$ 还是很给力的

```cpp
#include <bits/stdc++.h> 
using namespace std;
int a, b, n, p[1010][1010], ans = 0x7fffffff;
deque<int> que1[1010], que2[1010];//存每行的最大、最小值的单调队列
//que1[i]和que2[i]存第i行某元素的下标
deque<pair<int, int> > que3, que4;//存单调队列的单调队列
//first存行号，second存值
int main() {
	scanf("%d%d%d", &a, &b, &n);
	for (int i = 1; i <= a; ++i) {
		for (int j = 1; j <= b; ++j) {
			scanf("%d", &p[i][j]);
		}
	}
	for (int j = 1; j <= b; ++j) {
		for (int i = 1; i <= a; ++i) {
			if (!que1[i].empty() && j - que1[i].front() >= n)  que1[i].pop_front();
			if (!que2[i].empty() && j - que2[i].front() >= n)  que2[i].pop_front();
			while (!que1[i].empty() && p[i][j] >= p[i][que1[i].back()])  que1[i].pop_back();
			while (!que2[i].empty() && p[i][j] <= p[i][que2[i].back()])  que2[i].pop_back();
			que1[i].push_back(j);  que2[i].push_back(j);
		}
		if (j >= n) {
			while (!que3.empty())  que3.pop_back();
			while (!que4.empty())  que4.pop_back();
			for (int i = 1; i <= a; ++i) {//处理连续n行的最值
				if (!que3.empty() && i - que3.front().first >= n)  que3.pop_front();
				if (!que4.empty() && i - que4.front().first >= n)  que4.pop_front();
				while (!que3.empty() && p[i][que1[i].front()] >= que3.back().second)  que3.pop_back();
				while (!que4.empty() && p[i][que2[i].front()] <= que4.back().second)  que4.pop_back();
				que3.push_back(make_pair(i, p[i][que1[i].front()]));
				que4.push_back(make_pair(i, p[i][que2[i].front()]));
				if (i >= n)  ans = min(ans, que3.front().second - que4.front().second);
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：Arcturus1350 (赞：6)

纪念又双叒叕的一道暴力碾标算的题

我们考虑纯暴力

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a,b,n;
int map[1010][1010];
int ans=0x3f3f3f3f;
int main()
{
	scanf("%d%d%d",&a,&b,&n);
	for(int i=1;i<=a;i++)
	  for(int j=1;j<=b;j++)
		scanf("%d",&map[i][j]);
    for(int i=1;i+n-1<=a;i++)
      for(int j=1;j+n-1<=b;j++){
		int maxx=0,minn=0x3f3f3f3f;
    	for(int l=i;l<=n+i-1;l++)
          for(int r=j;r<=n+j-1;r++)
            maxx=max(maxx,map[l][r]),
            minn=min(minn,map[l][r]);
		ans=min(ans,maxx-minn);
    }
    printf("%d",ans);
    return 20020902;
}
```

然后显然，果断$TLE$

[呵呵呵](https://www.luogu.org/recordnew/show/9227593)

那么我们考虑怎么优化暴力

~~别跟我提什么数据结构啊，单调队列~~

~~本小可爱一个也不会~~

我们回头看看这两道题[P2038](https://www.luogu.org/problemnew/show/P2038)
[P2280](https://www.luogu.org/problemnew/show/P2280)

这两道题也是矩阵，然后我们是用的维护二维前缀和来找的在一个矩形内的某些数值

那么，这道题是不是也可以类似的做呢?

由于询问的都是正方形，

我们可以预处理出来

所有正方形的最大最小值

($ps:$从$(1,1)$开始计数)

定义$maxx[i][j][k]$表示以$(i,j)$为左上端点，然后边长为$k$的正方形最大值，$minn[i][j][k]$表示最小。

通过类比上两道题，还有画图，得出

$$maxx[i][j][k]=max(max(maxx[i][j][k-1],maxx[i+1][j+1][k-1]),max(maxx[i][j+1][k-1],maxx[i+1][j][k-1]))$$

$$minn[i][j][k]=min(min(minn[i][j][k-1],minn[i+1][j+1][k-1]),min(minn[i][j+1][k-1],minn[i+1][j][k-1]))$$

所以，我们可以求出来$maxx[][][n],minn[][][n]$

然后枚举左上角端点然后更新答案就行

---

别以为这样就好了

您写完了之后本地编译了么？

是不是编译未成功？

因为$maxx,minn$这样要开$1001*1001*1001=1e9$辣么大的数组

显然开不下啊$qwq$

那怎么办？

凉拌啊！

发现我们推$maxx,minn$的时候，每次只涉及到$k,k-1$，并且只涉及到$i+1,j+1,i,j$这几个东东，所以可以类似滚动数组优化，滚掉$k$这一维

然后又是省选题

开个$O2$也没什么大不了的

~~其实是本宝宝懒得写优化了~~

上代码:

看，连$1kb$都不到

真是暴力碾标算的好题啊$qwq$

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a,b,n;
int map[1010][1010];
int maxx[1010][1010];
int minn[1010][1010];
int ans=0x3f3f3f3f;
int main()
{
    scanf("%d%d%d",&a,&b,&n);
    for(int i=1;i<=a;i++)
      for(int j=1;j<=b;j++)
        scanf("%d",&map[i][j]),
        maxx[i][j]=minn[i][j]=map[i][j];

    for(int k=2;k<=n;k++)
      for(int i=1;i+k<=a+1;i++)
        for(int j=1;j+k<=b+1;j++)
          maxx[i][j]=max(max(maxx[i][j],maxx[i+1][j+1]),max(maxx[i][j+1],maxx[i+1][j])),
          minn[i][j]=min(min(minn[i][j],minn[i+1][j+1]),min(minn[i][j+1],minn[i+1][j])),
          ans=k==n?min(ans,maxx[i][j]-minn[i][j]):0x3f3f3f3f;

    printf("%d",ans);
    return 20020209;//防抄，挂上cp的生日
}
/*
5   4   2
1   2   5   6
0   17  16  0
16  17  2   1
2   10  2   1
1   2   2   2

*/
```

---

## 作者：_Sein (赞：5)

## 思路
这是一道二维单调队列题啊（~~其实就是两次单调队列~~）

根据题意要求$([i-n+1,i],[j-n+1,j])$的最大值和最小值做差。

先处理$(i,[j-n+1,j])$的最大值或最小值，因此需要一个一维数组$C$，去存储值。


维护最大值用一个下降序列$q1$，维护最小值用一个上升序列$q2$.

$cmax[i][j]=\max(c[i][j-n+1,j])$

$cmin[i][j]=\min(c[i][j-n+1,j])$

这时用单调队列优化就可以了。

对于最大值，如果$c[q1[tail]]\le c[i]$，说明当前位置比队尾更后，且对于后面状态更优，因此，队尾就没有存在的必要，可以踢出。

```cpp
while(l1<=r1&&j-q1[l1]>=n)++l1;//过远的踢掉
while(l2<=r2&&j-q2[l2]>=n)++l2;
while(l1<=r1&&c[j]>=c[q1[r1]])--r1;
while(l2<=r2&&c[j]<=c[q2[r2]])--r2;
q1[++r1]=j;q2[++r2]=j;
cmax[i][j]=c[q1[l1]];cmin[i][j]=c[q2[l2]];
```

接下来，处理$([i-n+1,i])$

因为$cmax[i][j],cmin[i][j]$已经记录了$c[i][j-n+1,j]$之间的最大值与最小值，

再用单调队列求$\max(cmax[i-n+1,i][j])-\min(cmin[i-n+1,i][j])$，更新答案。

```cpp
if(i>=n)ans=min(ans,cmax[q1[l1]][j]-cmin[q2[l2]][j]);
```

## AC code
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<cmath>
#define gc getchar()
using namespace std;
const int N=1e3+10;
inline void qr(int &x)
{
    x=0;int f=1;char c=gc;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
    while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
    x*=f;
}
void qw(int x)
{
    if(x<0)x=-x,putchar('-');
    if(x/10)qw(x/10);
    putchar(x%10+48);
}
int c[N],cmax[N][N],cmin[N][N];
int q1[N],q2[N],l1,l2,r1,r2;
int main()
{
	int a,b,n;qr(a),qr(b),qr(n);
	for(int i=1;i<=a;i++)
	{
		l1=l2=1;r1=r2=0;
		for(int j=1;j<=b;j++)
		{
			qr(c[j]);
			while(l1<=r1&&j-q1[l1]>=n)++l1;
			while(l2<=r2&&j-q2[l2]>=n)++l2;
			while(l1<=r1&&c[j]>=c[q1[r1]])--r1;
			while(l2<=r2&&c[j]<=c[q2[r2]])--r2;
			q1[++r1]=j;q2[++r2]=j;
			cmax[i][j]=c[q1[l1]];cmin[i][j]=c[q2[l2]];
		}
	}
	int ans=1e9;
	for(int j=n;j<=b;j++)
	{
		l1=l2=1;r1=r2=0;
		for(int i=1;i<=a;i++)
		{
			while(l1<=r1&&i-q1[l1]>=n)++l1;
			while(l2<=r2&&i-q2[l2]>=n)++l2;
			while(l1<=r1&&cmax[i][j]>=cmax[q1[r1]][j])--r1;
			while(l2<=r2&&cmin[i][j]<=cmin[q2[r2]][j])--r2;
			q1[++r1]=i;q2[++r2]=i;
			if(i>=n)ans=min(ans,cmax[q1[l1]][j]-cmin[q2[l2]][j]);
		}
	}
	qw(ans);puts("");
	return 0;
}
```



---

## 作者：RPChe_ (赞：4)

看了一下题解，发现没几个人用线段树做这道题，于是决定补一发。

------------


首先一看完这道题，就发现这是一道非常明显的区间极值问题，那么就自然而然想到了线段树，ST表和分块 ~~（不知道为什么没人用分块试试）~~ 但是我太弱了，ST表和分块都不会，~~（根本没想到dp）~~ 于是就只能用二维线段树。

刚开始，我脑袋短路了，打了一个套循环的一维线段树——

```cpp
#include<iostream>
using namespace std;
int a,b,n,maxx[1010][1010],c[10001],minn[1010][1010];
void build(int x,int k,int l,int r)
{
	if(l==r)
	{
		maxx[x][k]=c[l];
		minn[x][k]=c[l];
		return;
	}
	int mid=(l+r)/2;
	build(x,k*2,l,mid);
	build(x,k*2+1,mid+1,r);
	maxx[x][k]=max(maxx[x][k*2],maxx[x][k*2+1]);
	minn[x][k]=min(minn[x][k*2],minn[x][k*2+1]);
}
int query(int i,int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		return maxx[i][k];
	}
	int mid=(l+r)/2,ma=0;
	if(x<=mid) ma=max(ma,query(i,k*2,l,mid,x,y));
	if(mid<y) ma=max(ma,query(i,k*2+1,mid+1,r,x,y));
	return ma;
}
int query1(int i,int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		return minn[i][k];
	}
	int mid=(l+r)/2,mi=0x7FFFFFFF;
	if(x<=mid) mi=min(mi,query1(i,k*2,l,mid,x,y));
	if(mid<y) mi=min(mi,query1(i,k*2+1,mid+1,r,x,y));
	return mi;
}
int main()
{
	cin>>a>>b>>n;
	for(int i=1;i<=a;i++)
	{
		for(int j=1;j<=b;j++)
		{
			cin>>c[j];
		}
		build(i,1,1,b);
	}
	int ans=0x7FFFFFFF;
	for(int i=1;i<=a-n+1;i++)
	{
		for(int j=1;j<=b-n+1;j++)
		{
			int maxx1=0,minn1=0x7FFFFFFF;
			for(int k=i;k<=i+n-1;k++)
			{
				maxx1=max(maxx1,query(k,1,1,b,j,j+n-1));
				minn1=min(minn1,query1(k,1,1,b,j,j+n-1));
			}
			ans=min(ans,maxx1-minn1);
		}
	}
	cout<<ans<<endl;
	return 0;
} 
```

它的理论时间复杂度是O(abnlogn)，仅优于最朴素的暴力算法O(abn^2)，但是由于它巨大的常数，它连暴力都不如。代码比暴力长了两倍多，开了02还比暴力多T了两个点。

然后观察代码，我们可以发现首先区间询问操作可以挪出循环，这样理论时间复杂度降为了O(ab(n+logb))，但是它肯定还是会T得很惨。优化版的暴力时间复杂度是O(abn)，比它的小，但是仍然会T掉1到3个点（看具体代码情况），线段树还要算上它巨大的常数，估计这样能过一半数据就顶天了。

再观察代码，然后可以发现第三重循环不就是在第一轮区间询问的基础上在线性数据中找极值嘛，那就还可以使用线段树实现，代码如下——

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a,b,n,maxx[1010][4010],c[1010],minn[1010][4010];
int maxx1[1010][4010],minn1[1010][4010],maxx2[1010][4010],minn2[1010][4010];
inline int read(void) {
    int x=0,f=1; char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=-1;
    for(;ch>='0'&&ch<='9';x=(x<<3)+(x<<1)+(ch^48),ch=getchar());
    return x*f;
}
void build(int x,int k,int l,int r)
{
	if(l==r)
	{
		maxx[x][k]=c[l];
		minn[x][k]=c[l];
		return;
	}
	int mid=(l+r)/2;
	build(x,k*2,l,mid);
	build(x,k*2+1,mid+1,r);
	maxx[x][k]=max(maxx[x][k*2],maxx[x][k*2+1]);
	minn[x][k]=min(minn[x][k*2],minn[x][k*2+1]);
}
void build1(int x,int k,int l,int r)
{
	if(l==r)
	{
		maxx2[x][k]=maxx1[x][l];
		minn2[x][k]=minn1[x][l];
		return;
	}
	int mid=(l+r)/2;
	build1(x,k*2,l,mid);
	build1(x,k*2+1,mid+1,r);
	maxx2[x][k]=max(maxx2[x][k*2],maxx2[x][k*2+1]);
	minn2[x][k]=min(minn2[x][k*2],minn2[x][k*2+1]);
}
int query(int i,int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		return maxx[i][k];
	}
	int mid=(l+r)/2,ma=0;
	if(x<=mid) ma=max(ma,query(i,k*2,l,mid,x,y));
	if(mid<y) ma=max(ma,query(i,k*2+1,mid+1,r,x,y));
	return ma;
}
int query1(int i,int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		return minn[i][k];
	}
	int mid=(l+r)/2,mi=1000000010;
	if(x<=mid) mi=min(mi,query1(i,k*2,l,mid,x,y));
	if(mid<y) mi=min(mi,query1(i,k*2+1,mid+1,r,x,y));
	return mi;
}
int query2(int i,int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		return maxx2[i][k];
	}
	int mid=(l+r)/2,ma=0;
	if(x<=mid) ma=max(ma,query2(i,k*2,l,mid,x,y));
	if(mid<y) ma=max(ma,query2(i,k*2+1,mid+1,r,x,y));
	return ma;
}
int query3(int i,int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		return minn2[i][k];
	}
	int mid=(l+r)/2,mi=1000000010;
	if(x<=mid) mi=min(mi,query3(i,k*2,l,mid,x,y));
	if(mid<y) mi=min(mi,query3(i,k*2+1,mid+1,r,x,y));
	return mi;
}
int main()
{
	a=read(),b=read(),n=read();
	for(register int i=1;i<=a;i++)
	{
		for(register int j=1;j<=b;j++)
		c[j]=read();
		build(i,1,1,b);
	}
	for(register int j=1;j<=b-n+1;j++)
	{
		for(register int i=1;i<=a;i++)
		{
			maxx1[j][i]=query(i,1,1,b,j,j+n-1);
			minn1[j][i]=query1(i,1,1,b,j,j+n-1);
		}
		build1(j,1,1,a);
	}
	int ans=1000000010;
	for(register int j=1;j<=b-n+1;j++)
	{
		for(register int i=1;i<=a-n+1;i++)
		{
			int t;
			t=query2(j,1,1,a,i,i+n-1)-query3(j,1,1,a,i,i+n-1);
			ans=min(ans,t);
		}
	}
	printf("%d",ans);
	return 0;
} 
```

这样，代码就从~~垃圾般的~~循环套线段树优化成了树套树，一个真正的二维线段树。理论时间复杂度也有了巨大改观，是O(ab(loga+logb))，由于数据范围是2<=a,b<=1000，所以loga+logb的值非常小，几乎可以忽略不计，~~所以理论时间复杂度是O(ab)，~~ 但是，它的常数仍然非常巨大，加上快读后，有几个测试点离超时只有几十毫秒。总用时是4.98秒，比正解单调队列(1.12秒)慢了3.86秒左右，比隔壁的二维ST表(3.56秒)慢了1.42秒左右，但比不开O2的O(abn)版暴力快了不少。~~我不知道为什么暴力开了优化跟正解一样快。~~

顺便说一句，这代码确实很冗长，如果想缩的话可以把几个query函数弄到一起，或者用不同query函数相互调用，再记忆化。(还可以顺便缩一个循环)

---

## 作者：Viston (赞：4)

无脑暴力~~是绝对会T的~~   
然而我们却反其道而行之！    
（就是喜欢暴力）   
我们可以暴力存一个最大最小的位置，如果~~枚举~~超出位置了就暴力遍历一遍。   
也许是数据比较水吧，不开O2都过了。   
这个方法构造数据是可以很轻松的卡掉的，所以这种方法最好不要使用。   
```
#include<bits/stdc++.h>
#define rint register int 
#define maxn 2147483644
using namespace std;
inline int read(){
	int X=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))X=X*10+ch-'0',ch=getchar();
	return X;
}
int a,b,c,d[1002][1002],ans=maxn,maxx=-maxn,minn=maxn;
int zd[2],zx[2];
inline void find(int a,int b){
	maxx=-maxn,minn=maxn;
	for(rint qq=a;qq<=a+c-1;++qq)
		for(rint ww=b;ww<=b+c-1;++ww){
			if(maxx<d[qq][ww]){
				zd[0]=qq,zd[1]=ww;
				maxx=d[qq][ww];
			}
			if(minn>d[qq][ww]){
				zx[0]=qq,zx[1]=ww;
				minn=d[qq][ww];
			}
		}
	ans=min(ans,maxx-minn);
}//暴力寻找
int main(){
	a=read(),b=read(),c=read();
	for(rint i=1;i<=a;++i)
		for(rint j=1;j<=b;++j)
			d[i][j]=read();
	find(1,1);
	for(rint i=1;i<=a-c+1;++i){
		if(zd[0]<=i&&zd[0]>=i+c-1&&zx[0]<=i&&zx[0]>=i+c-1)//判断是否超出位置
			find(i,1);
		for(rint j=1;j<=b-c+1;++j)
			if(zd[1]>=j&&zd[1]<j+c&&zx[1]>=j&&zx[1]<j+c){//同样判断是否超出位置
				continue;
			}
			else find(i,j);
	}
	cout<<ans;
}
```
也许这种方法过这道题还是需要一些如registerint之类的小的卡常技巧和快速读入

---

## 作者：huanzi (赞：3)

    你永远也到达不了AC的真实，这就是TLE体验镇魂曲的能力！  ——做题后的感想

看到这一题时我们首先扫一下题目；求AXB矩阵中，NXN区域中最大值和最小值差的最小值。

我们第一个想到的思路很可能是这样；将一个点作为正方形的端点，然后以此点为基点进行延伸，同时定义两个值记录下当前这个点，最后再定义一个全局变量用于储存最大值和最小值的差的最小值。

想法很好，而且这么做绝对很省内存，但是你要注意一个问题；2<=a,b<=1000，n<=100，假设你真的这么做的话，那么假如数据中有（好像真有）a=b=1000,n=100的值，按照这个方法去做的话，~~文明6都能再开一局了~~TLE是必定的。

那么对付TLE体验我们该怎么办呢？当然是用无敌的~~白金~~优化之星对付啊。

我们有以下几点可以优化；

1.读入优化，
    由于我们要可能读入1000X1000次，因此读入优化是一个很好的选择，即使不会，他也足够帮你省下不少时间；
    
```
    inline int read(){
    int x=0; bool f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=0;
    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
    if(f) return x;
    return 0-x;}   //简单的读入优化
```

~~2.输出优化，因为用处不大所以去他的吧~~

3.本题目的核心；**单调队列**

在此我要感谢SWEETLEMON大佬以一种通俗易懂的方式让我明白了单调队列（鞠躬）

单调队列的思路；在一个队列内，求出每个一定区间内的最大/最小值。 诶~这不就和我们要的NXN有点相似了吗？

单调队列基本操作（这里我引用了SWEETLEMON的内容，此时情景为选拔队员）；

    入队/滑动窗口右滑。每年选拔新队员时，淘汰比这名新队员弱的老队员。对于单调队列，就是插入新元素时，把先前存在的比当前元素小的元素弹出（从队尾退队）。
    退役/滑动窗口右滑。只需判断最老的队员是否需要退队。对于单调队列，只需判断队头是否已经超出滑动窗口范围，若超出，则从队头退队。
    参赛/查询滑动窗口最大值。直接派最老的队员参赛/直接返回队头元素。
    
再回到我们的题目，就算我们同时要最大和最小值，也不过是在某些方面微调而已，因此我们不妨开两个数组分别储存最大值和最小值不就可以了——

诶诶诶停一下！这一题不是二维的吗？但单调队列只是在一维上进行筛选啊！

很好你发现了问题，但是这也不要紧，我们只需进行两次单调队列，一次横向一次纵向，后面一次在前面一次的基础上进行就可以了。（好好想想为什么）

最后是总代码；
```
#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
long long t[1001][1001];  //储存图 
long long zd[1001][1001],zx[1001][1001];   //储存一个点作为左上角时nxn内正方形的最大与最小值，即纵向单调队列 
long long d[1001][1001],x[1001][1001];    // 储存以该点为左端点，1XN的长方形中的最大和最小值 ，即横向单调队列 
int a,b,n;   //  行数，列数以及所需正方形的边长
int front,back,quin,hou,qd[1001],qx[1001];    //用于储存一个队列中搜寻到的最大值和最小值的坐标，虽然这个最小值的坐标带着丢人的气息  
inline int read(){
    int x=0; bool f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=0;
    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
    if(f) return x;
    return 0-x;
}   //简单的读入优化
int main()
{
	a=read(),b=read(),n=read();
	for (int i=1;i<=a;i++)
	{
		for (int j=1;j<=b;j++)
		{
			t[i][j]=read();
		}
	}
	for (int i=1;i<=a;i++)    //单调队列横向搜索 
	{
		front=quin=back=hou=qd[1]=qx[1]=1;
		for (int j=2;j<=b;j++)
		{
			while (t[i][j]>=t[i][qd[back]]&&front<=back) back--;      //确认该横向队列中的最大值 
			while (t[i][j]<=t[i][qx[hou]]&&quin<=hou) hou--;         //确认该横向队列中的最小值 
			qd[++back]=j,qx[++hou]=j;
			while (j-qd[front]>=n) front++;    //头超出了范围，往右边移 
			while (j-qx[quin]>=n) quin++;
			if (j>=n) 
			{
				d[i][j-n+1]=t[i][qd[front]];
				x[i][j-n+1]=t[i][qx[quin]];
			}
		}
	}
	
	for (int i=1;i<=b-n+1;i++)    //单调队列纵向搜索，由于进行过一次横向搜索，此时如果沿用上一次所获得的图就可以等价于进行正方形的确认 
	{   //同时，也可以不去搜索部分用不了的点节约了时间,即右边多出的那几块  
		front=quin=back=hou=qd[1]=qx[1]=1;
		for (int j=2;j<=a;j++)
		{
			while (d[j][i]>=d[qd[back]][i]&&front<=back) back--;      //确认该竖向队列中的最大值 
			while (x[j][i]<=x[qx[hou]][i]&&quin<=hou) hou--;         //确认该竖向队列中的最小值 
			qd[++back]=j,qx[++hou]=j;
			while (j-qd[front]>=n) front++;   
			while (j-qx[quin]>=n) quin++;
			if (j>=n) 
			{
				zd[j-n+1][i]=d[qd[front]][i];
				zx[j-n+1][i]=x[qx[quin]][i];
			}
		}
	}
	long long ans=0x3f3f3f3f;
	for (int i=1;i<=a-n+1;i++)
	{
		for (int j=1;j<=b-n+1;j++)
		{
			ans=min(ans,zd[i][j]-zx[i][j]);
		}    //对每一格进行筛选 
	}
	cout<<ans;
	return 0;
} 
```

    老东西。你的TLE体验最没用啦！

---

## 作者：马峰 (赞：3)

这是一天模拟考的题。。。考场只想出来了一维st表很gg。。。旁边的dalao疯狂用单调队列复杂度吊打我。。。最后因为数据差距并且老爷机跑的贼慢和暴力拿了一个分数（雾

考场后依然不放弃st表的做法，学习了一下二维st表。。。终于水过了。。。发一篇题解纪念。


st[i][j][k]表示以(i,j)节点为左上角，边长为k的正方形的最大值    
st1同理

复杂度n2logn？好像比考场撸出来n2的做法的dalao们还要慢不少呢。。。

不过因为这道题的k是固定的，那么我们可以减少枚举k的次数。。。但是这种优化我不会啊。。。dalao们为什么这么强啊。。。

```
#include<iostream>
#include<cstdio>
#include<cmath>

using namespace std;

long long n,m,c;
int st[1010][1010][11],st1[1010][1010][11];
int mina=0x3f3f3f3f;

void init(){
    for(int k=1;k<=log2(min(n,m));k++)
        for(int i=1;i+(1<<k)-1<=n;i++)
            for(int j=1;j+(1<<k)-1<=m;j++)
                st[i][j][k]=max(max(max(st[i][j][k-1],st[i+(1<<(k-1))][j][k-1]),st[i][j+(1<<(k-1))][k-1]),st[i+(1<<(k-1))][j+(1<<(k-1))][k-1]);
    for(int k=1;k<=log2(min(n,m));k++)
        for(int i=1;i+(1<<k)-1<=n;i++)
            for(int j=1;j+(1<<k)-1<=m;j++)
                st1[i][j][k]=min(min(min(st1[i][j][k-1],st1[i+(1<<(k-1))][j][k-1]),st1[i][j+(1<<(k-1))][k-1]),st1[i+(1<<(k-1))][j+(1<<(k-1))][k-1]);        
}

int ans(int x1,int y1,int x2,int y2){
    int k=log2(c);
    return max(max(max(st[x1][y1][k],st[x2-(1<<k)+1][y1][k]),st[x1][y2-(1<<k)+1][k]),st[x2-(1<<k)+1][y2-(1<<k)+1][k]);
}

int ans1(int x1,int y1,int x2,int y2){
    int k=log2(c);
    return min(min(min(st1[x1][y1][k],st1[x2-(1<<k)+1][y1][k]),st1[x1][y2-(1<<k)+1][k]),st1[x2-(1<<k)+1][y2-(1<<k)+1][k]);
}

inline int read(){
    int x=0,gf=1;char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') gf=-1;c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-48;c=getchar();
    }
    return x*gf;
}

int main(){	
    n=read(),m=read(),c=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            int x=read();st[i][j][0]=x;st1[i][j][0]=x;
        }
    init();
    for(int i=1;i<=n;i++){
        if(i+c-1>n) break;
        for(int j=1;j<=m;j++){
            if(j+c-1>m) break;
            int maxa=0;
            maxa=max(maxa,ans(i,j,i+c-1,j+c-1));
            mina=min(mina,maxa-ans1(i,j,i+c-1,j+c-1));
        }
    }
    cout<<mina;
    return 0;
}
```

---

## 作者：nothingness (赞：3)

最近做树状数组上瘾了，来一篇**树状数组+单调队列**的题解，~~顺便纪念一下自己半小时不看题解A掉一道省选题的经历。~~

$~$
 
由于作者习惯，本文中的变量可能和题目中的有所不同。
**在此定义一下变量**：

题目中的 $a,b,n$ 在文中分别为 $n,m,k$ ； $a[i][j]$ 表示矩阵； $c[i][j]$ 为树状数组，维护的是第 $i$ 行的最值； $num[i],val[i]$ 分别是单调队列的编号和值； $h,t$ 分别为头指针和尾指针。

$~$

首先，让我们来看一下题目，让我们求区间内的最值。

$~$

第一思路：暴力，枚举所有 $k^2$ 矩阵。复杂度： $O(nmk^2)$ 。算了吧 . . . . . .（至少我觉得不行）
### ~~（不过后面有彩蛋，教你如何用暴力AC省选题）~~

$~$

第二思路： $DP$ ，优化后这是可行的，但蒟蒻我不会 . . . . . .

既然不会 $DP$ ，又有点像 $RMQ$（二维的），那我们考虑一下单调队列。不过我太蒻了，二维的单调队列不会啊！算了，先试试一维单调队列。思路是这样的：将总矩阵划分成数个 $k*n$ 的矩阵，滑块每移动一次，将新的一行的 $k$ 个数压入队列，最后求最值。复杂度：$O(nmk)$ 。好像可以，但是极限是 $1000*1000*100=1e8$ ，还是 $TLE$ ，经过实测，只有 $50$ 分（评测机如果不忙的话有 $60$ 分） 。

$~$

第三思路：接着优化。显然， $n,m$ 优化不了，那么尝试着优化 $k$ 。我们发现，每次更新我们的单调队列时，都会更新 $k$ 个数，这样的话在 $O(nm)$ 的循环中复杂度太高了，能不能尝试着预处理出这 $k$ 个数的最值？显然，可以令 $f[i][l][r]$ 表示第 $i$ 行第 $l$ 个数到第 $r$ 个数的最值，这样看上去好像可以 $O(1)$ 出解！
~~不过你这么想的话，你得先去问问编译器同不同意。~~ $f[1001][1001][1001]$ 的巨型数组显然会 $CE$ ，要知道， $MLE$ 可是 $0$ 分。这种思路肯定不行。

$~$

第四思路：既然如此，能不能用 $O(nm)$ 的空间开销，在 $O(log_2k)$ 或 $O(\sqrt k)$ 的时间开销内出解？答案是肯定的：

-  $1.$  线段树（常数太大）

-  $2.$  $ST$ 表（ $1e7$ 可以过，不过这里不讲，和方案 $3$ 基本等效，会方案 $3$ 的一定会 $ST$ 表）

- $3.$ 树状数组

对于树状数组，设 $c[i][j]$ 表示第 $i$ 行的树状数组，预处理出最值。在查询时采用分治思想，即：

$~~~~~~~~~~query(l,r)=\max(query(l,r-lowbit(r)-1),c[r]),r-lowbit(r)>l$

$~~~~~~~~~~query(l,r)=\max(query(l,r-1),a[r]),r-lowbit(r)≤l$

接下来就能愉快的 $AC$ 啦！

平均时间复杂度： $O(nmlog_2k)$ ，可以在不吸氧的时候 $AC$ ，约 $2000ms$ ，因为这是省选题，可以吸氧优化，优化以后约 $800ms$ ~~（鬼知道为什么时间少了这么多）~~。此外，若采用读入优化，可以减少 $200ms$ 。

$~$

## Code
```
#include "bits/stdc++.h"
#define lowbit(x) ((x)&(-(x)))
#define N 1001
using namespace std;

int n,m,k,a[N][N],ans=INT_MAX;
struct str
{
	int max,min;
}c[N][N],num[N],val[N],h,t;

inline void read(int &x)//读入优化
{
	int s=1;
	char ch=0;
	x=0;
	while(ch^'-'&&!isdigit(ch))
		ch=getchar();
	if(ch=='-')
	{
		s=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=s;
}

void update_min(int i,int j,int x)//树状数组更新
{
	while(j<=m)
		if(c[i][j].min>x)
			c[i][j].min=x,j+=lowbit(j);
		else
			break;
}

void update_max(int i,int j,int x)
{
	while(j<=m)
		if(c[i][j].max<x)
			c[i][j].max=x,j+=lowbit(j);
		else
			break;
}

int query_min(int i,int l,int r)//树状数组求最值
{
	int t=INT_MAX;
	while(l<=r)
		if(r-lowbit(r)>l)
			t=min(t,c[i][r].min),r-=lowbit(r);
		else
			t=min(t,a[i][r]),r--;
	return t;
}

int query_max(int i,int l,int r)
{
	int t=INT_MIN;
	while(l<=r)
		if(r-lowbit(r)>l)
			t=max(t,c[i][r].max),r-=lowbit(r);
		else
			t=max(t,a[i][r]),r--;
	return t;
}

void push(int i,int l,int r)//入队
{
	int x;
	x=query_max(i,l,r);
	while(val[t.max].max<=x&&h.max<=t.max)
		t.max--;
	t.max++;
	num[t.max].max=i;
	val[t.max].max=x;
	x=query_min(i,l,r);
	while(val[t.min].min>=x&&h.min<=t.min)
		t.min--;
	t.min++;
	num[t.min].min=i;
	val[t.min].min=x;
}

void pop(int i)//出队
{
	if(i-k>=num[h.max].max)
		h.max++;
	if(i-k>=num[h.min].min)
		h.min++;
}

int main()
{
	read(n),read(m),read(k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)//初始化
		{
			c[i][j].max=INT_MIN;
			c[i][j].min=INT_MAX;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			read(a[i][j]);
			update_min(i,j,a[i][j]);
			update_max(i,j,a[i][j]);
		}
	for(int T=k;T<=m;T++)
	{
		h.max=h.min=1,t.max=t.min=0;
		for(int i=1;i<k;i++)
			push(i,T-k+1,T);//避免三重循环,大幅降低时间复杂度
		for(int i=k;i<=n;i++)
		{
			push(i,T-k+1,T);
			pop(i);
			ans=min(ans,val[h.max].max-val[h.min].min);
		}
	}
	printf("%d",ans);
	return 0;
}
```

$~$


## 彩蛋
如果我们在考试中遇到难题不会怎么办？肯定不能善罢甘休，最起码也要拿到暴力分。但是$O(nmk^2) $ 的做法只有 $20$ 分,那么我们有没有更好的办法骗分？

有的，只要你会这一行代码：
```
               srand(time(0));
```
对于 $1000*1000*100$ 的极限数据，我们如果真的不会做，打暴力的话，肯定没有时间枚举所有的矩阵。我们可以考虑随机选取一些矩阵（在不 $TLE$ 的情况下越多越好），求出选取的矩阵的最值，直接出结果。

不过这样可以吗？点开下面的链接，这个 $AC$ 记录的代码就在下面：

[暴力出奇迹$~~$骗分过样例$~~$爆搜挂着机$~~$打表出省一](https://www.luogu.org/recordnew/show/11339591)

```
//这只是一个随机模板,并不是最优的随机化策略
#include "bits/stdc++.h"
#define N 1001
using namespace std;

int MIN,MAX,x,y,n,m,k,a[N][N],ans=INT_MAX;

inline void read(int &x)//读入优化
{
    int s=1;
    char ch=0;
    x=0;
    while(ch^'-'&&!isdigit(ch))
        ch=getchar();
    if(ch=='-')
    {
        s=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    x*=s;
}

int main()
{
    srand(time(0));//重点
    read(n),read(m),read(k);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            read(a[i][j]);
    for(int T=1;T<=50000;T++)//循环次数自己看着办
    {
        x=rand()%(n-k+1)+1;//随机数大法好
        y=rand()%(m-k+1)+1;//随机数大法好
        MIN=INT_MAX;
        MAX=INT_MIN;
        for(int i=0;i<k;i++)
            for(int j=0;j<k;j++)
            {
                MIN=min(MIN,a[x+i][y+j]);
                MAX=max(MAX,a[x+i][y+j]);
            }
        ans=min(ans,MAX-MIN);
    }
    printf("%d",ans);
    return 0;
}
```

$~$

其中另外 $9$ 个点很稳，第 $4$ 个点要看运气，我试了 $10$ 次左右才 $AC$ 。

**一个 $5min$ 打出的代码能骗到近 $90$ 分（欧皇 $5min~~AC$），这虽然不是一般人的最优解（但是是欧皇的最优解），但在极短的时间内拿到足够的分数倒是可以借鉴的。毕竟大部分人水平有限（蒟蒻我的水平更差），无法达到 $AK~~IOI$ 的成就，所以，如果万不得已这样做，也是我们可以接受的结果。**换个角度思考，你随机化骗分， $5min$就有 $90$ 分,平均 $18pts/min$ ，即使机房大佬 $30min~~AC$ 了这道题，他的得分效率才 $3.333pts/min$ ，怎么算都是你赚~~（手动滑稽）~~~~~

此外，我们还可以考虑优化我们的随机算法。虽然随机数不是你掌控的（显然），但是你可以通过玄学取模（ $998244353~,~10000019~,~$ 以及某个 $8$ 位质数）来骗分。当然这都不正经。正经的话，你可以随机一些矩阵，使得这些矩阵的重叠部分尽量小，在选择趋向于容易找到答案的地方继续细节化的随机，在看似不易得到答案的地方有一定概率随机搜索，距离想要的目标答案越远的话搜索几率越低~~（怎么有点像模拟退火 . . . . . .）~~。或者你也可以考虑在矩阵的极大值极小值附近细节随机化，尽可能求出正解。具体代码我就不发了~~（才不是我懒得打）~~，但是从应试的角度讲，这是一种值得借鉴的思路。

$~$

最后，感谢大家的耐心阅读，也在此感谢$~~$ @我没有名称 $~~$之前写的题解给我的彩蛋提供一定的思路，谢谢！

---

## 作者：cocovigour (赞：3)

根据题目描述 能看出来就是求n^2区域内的RMQ
可是本蒟蒻没有学过二维的RMQ
于是写了一维RMQ
非常轻松的T掉了5个点
代码如下
```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<utility>
#include<queue>
#include<map>
#include<set>
#define N 1001
#define M 101
using namespace std;
int n,b,a;
int ma[N][N];
int fa[N][N][10];
int fi[N][N][10];
int Log[M];
int main()
{
    scanf("%d%d%d",&a,&b,&n);
    memset(fi,0x3f,sizeof fi);
    for(int i=1;i<=a;i++)
    {
        for(int j=1;j<=b;j++)
        {
            scanf("%d",&ma[i][j]);
            fa[i][j][0]=ma[i][j];
            fi[i][j][0]=ma[i][j];
        }
    }
    for(int i=2;i<=n;i++)
    {
        Log[i]=Log[i/2]+1;
    }
    
    for(int k=1;k<=a;k++)
    {
        for(int j=1;(1<<j)<=n;j++)
        {
            for(int i=1;i+(1<<j)-1<=b;i++)
            {
                fa[k][i][j]=max(fa[k][i+(1<<(j-1))][j-1],fa[k][i][j-1]);
                fi[k][i][j]=min(fi[k][i+(1<<(j-1))][j-1],fi[k][i][j-1]);
            }
        }
    }
    int t=Log[n];
    int ans=1000000010;
    for(int i=1;i<=a;i++)
    {
        if(i+n-1>a) continue;
        for(int j=1;j<=b;j++)
        {
            if(j+n-1>b) continue;
            int ansm=0;
            int ansmin=1000000010;
            for(int k=0;k<n;k++)
            {
                ansm=max(max(fa[i+k][j][t],fa[i+k][j+n-(1<<t)][t]),ansm);
                ansmin=min(min(fi[i+k][j][t],fi[i+k][j+n-(1<<t)][t]),ansmin);
            }
            ans=min(ans,ansm-ansmin);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
后来参考了题解区各位大佬的思路（%%%）
可以得知二维的RMQ即把一个正方形分解为四个小正方形
（一维的分成两份 那二维的不就分成四份吗（本蒟蒻自己没有想出来orz））
所以可得到这个转换方程（最大值同理）
```cpp
 fi[i][j][k]=min(min(fi[i+(1<<(k-1))][j+(1<<(k-1))][k-1],fi[i][j][k-1]),min(fi[i][j+(1<<(k-1))][k-1],fi[i+(1<<(k-1))][j][k-1]));
```
AC代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<utility>
#include<queue>
#include<map>
#include<set>
#define N 1001
#define M 101
using namespace std;
int n,b,a;
int ma[N][N];
int fa[N][N][10];
int fi[N][N][10];
int Log[M];
int main()
{
	scanf("%d%d%d",&a,&b,&n);
	memset(fi,0x3f,sizeof fi);
	for(int i=1;i<=a;i++)
	{
		for(int j=1;j<=b;j++)
		{
			scanf("%d",&ma[i][j]);
			fa[i][j][0]=ma[i][j];
			fi[i][j][0]=ma[i][j];
		}
	}
	for(int i=2;i<=n;i++)
	{
		Log[i]=Log[i/2]+1;
	}
	for(int k=1;(1<<k)<=n;k++)
	{
		for(int i=1;i+(1<<k)-1<=a;i++)
		{
			for(int j=1;j+(1<<k)-1<=b;j++)
			{
				fi[i][j][k]=min(min(fi[i+(1<<(k-1))][j+(1<<(k-1))][k-1],fi[i][j][k-1]),min(fi[i][j+(1<<(k-1))][k-1],fi[i+(1<<(k-1))][j][k-1]));
				fa[i][j][k]=max(max(fa[i+(1<<(k-1))][j+(1<<(k-1))][k-1],fa[i][j][k-1]),max(fa[i][j+(1<<(k-1))][k-1],fa[i+(1<<(k-1))][j][k-1]));
			}
		}
	}
	int t=Log[n];
	int ans=1000000001;
	for(int i=1;i+n<=a+1;i++)
	{
		for(int j=1;j+n<=b+1;j++)
		{
			int minn=min(min(fi[i][j][t],fi[i+n-(1<<t)][j][t]),min(fi[i][j+n-(1<<t)][t],fi[i+n-(1<<t)][j+n-(1<<t)][t]));
			int maxn=max(max(fa[i][j][t],fa[i+n-(1<<t)][j][t]),max(fa[i][j+n-(1<<t)][t],fa[i+n-(1<<t)][j+n-(1<<t)][t]));
			ans=min(maxn-minn,ans);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：LightningUZ (赞：2)

### 题意简述
二维滑动窗口。给定一个$a\times b$的矩阵，和一个大小为$k\times k$的滑动窗口，求这个窗口在滑动过程中所看到的（最大值-最小值）最小能到多少。
### 数据
输入   
5 4 2   
1 2 5 6   
0 17 16 0   
16 17 2 1   
2 10 2 1   
1 2 2 2   
输出   
1   
### 思路
理论上是珂以跑两维单调队列的，当然也珂以跑二维$ST$表。由于我不会二维，所以我只能$ST$表套单调队列来写（群众：wdnmd您是沙雕么？？？）   
好的我们来看看我的瞎搞做法。。。   
设身处地的想一下，如果你不会二维的单调队列或$ST$表，你会怎么办？   
首先要先枚举区间左端点$i$，然后把所有行上从$i$到$i+x-1$之间的最大/最小求出来（所以这告诉我们，我们对每一行都要写一个$ST$表）。如下图：   
![blog1.png](https://i.loli.net/2019/04/16/5cb5c078346c0.png)
蓝色部分就是我们按行处理的最大/最小值。我们把每一行的最大/最小值放到数组里面，然后就变成一维的问题了。如下图：   
![blog2.png](https://i.loli.net/2019/04/16/5cb5c2f8e4717.png)
对保存行最大值那个数组（设为$tmpx$），我们跑一遍维护最大值的单调队列。对保存行最小值的那个数组（设为$tmpn$），我们跑一遍维护最小值的单调队列，取两个队首相减的最小值即可求出答案。   
代码（有很多注释）：
```cpp
#include<bits/stdc++.h>
#define N 1010
#define LogN 11
#define K 110
using namespace std;
int mp[N][N];
int n,m,x;
void Input()//读入没什么好说的。。。
{
    scanf("%d%d%d",&n,&m,&x);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&mp[i][j]);
        }
    }
}

//以下变量名中，以x结尾的是求最大用的，以n结尾的是求最小用的
//比如stx就是最大值的st表，stn就是最小值的st表
int stx[N][N][LogN],stn[N][N][LogN],lg[N];
int tmpx[N],tmpn[N];
void BuildST()
{
    for(int i=1;i<=n;i++)//预处理每个数的log2值，常数小一点
    {
        lg[i]=lg[i-1]+((1<<(lg[i-1]+1))==i);
    }

    for(int i=1;i<=n;i++)//ST表的边界（这个少了药丸啊。。。）
    {
        for(int j=1;j<=m;j++)
        {
            stn[i][j][0]=stx[i][j][0]=mp[i][j];
        }
    }
    for(int i=1;i<=n;i++)//转移
    {
        for(int k=1;(1<<k)<=m;k++)
        {
            for(int j=1;j+(1<<(k-1))<=m;j++)
            {
                stx[i][j][k]=max(stx[i][j][k-1],stx[i][j+(1<<(k-1))][k-1]);
                stn[i][j][k]=min(stn[i][j][k-1],stn[i][j+(1<<(k-1))][k-1]);
            }
        }
    }
}
int Query(int st[][N][LogN],int i,int l,int r)//求最大/最小
//第一个参数是一个指针，是stn就表示询问最小，是stx就表示询问最大
{
    int lc=lg[x];//r-l+1==x
    if (st==stx)//询问最大
    {
        return max(st[i][l][lc],st[i][r-(1<<lc)+1][lc]);
    }
    else//询问最小
    {
        return min(st[i][l][lc],st[i][r-(1<<lc)+1][lc]);
    }
}
int Qx[N],hx,tx;int Qn[N],hn,tn;
void Solve()
{
    int totans=0x3f3f3f3f;//总共的答案
    for(int i=1;i+x-1<=m;i++)
    {
        memset(tmpn,0,sizeof(tmpn));
        memset(tmpx,0,sizeof(tmpx));
        for(int j=1;j<=n;j++)//上图的蓝色部分（降维打击）
        {
            tmpx[j]=Query(stx,j,i,i+x-1);
            tmpn[j]=Query(stn,j,i,i+x-1);
        }

		//以下是洛谷1886滑动窗口的代码
        hx=tx=hn=tn=1;
        for(int j=1;j<=x;j++)
        {
            while(hx<tx and tmpx[Qx[tx-1]]<=tmpx[j]) tx--;
            Qx[tx]=j,tx++;
            while(hn<tn and tmpn[Qn[tn-1]]>=tmpn[j]) tn--;
            Qn[tn]=j,tn++;
        }

        int ans=tmpx[Qx[hx]]-tmpn[Qn[hn]];
        for(int j=x+1;j<=n;j++)
        {
            while(hx<tx and tmpx[Qx[tx-1]]<=tmpx[j]) tx--;
            Qx[tx]=j,tx++;
            while(hn<tn and tmpn[Qn[tn-1]]>=tmpn[j]) tn--;
            Qn[tn]=j,tn++;

            if (j-Qx[hx]+1>x)
            {
                ++hx;
            }
            if (j-Qn[hn]+1>x)
            {
                ++hn;
            }
            //ans记录以i为左端点的蓝色部分最大-最小的最小值
            ans=min(ans,tmpx[Qx[hx]]-tmpn[Qn[hn]]);
        }
        totans=min(totans,ans);//计算到总答案
    }
    printf("%d\n",totans);
}

main()
{
    Input();
    BuildST();
    Solve();
    return 0;
}

```



---

## 作者：elijahqi (赞：2)

顺便安利下蒟蒻的blog(http://www.elijahqi.win/2017/10/30/luogu2216-haoi2007%e7%90%86%e6%83%b3%e7%9a%84%e6%ad%a3%e6%96%b9%e5%bd%a2/)


单调队列搞 对于每一行建立两个单调队列 维护最大和最小

对于每一列建立两个单调队列 维护最大和最小

对于每一个矩形的前n列均暴力重建 列和行的单调队列

我针对每一列都建立单调队列 q3[j]q4[j] 表示第j列的递增和递减单调队列

q1 q2表示这一行的递增和递减单调队列 注意:要将竖着的一列的值和map[i][j]做比较 然后再做q1和q2 这两个单调队列

蒟蒻实在是太弱了deque写的 代码冗长  而且慢qwq 欢迎加qq交流（在blog里有

```cpp
#include<cstdio>
#define N 1100
#define inf 0x7f7f7f7f
#include<deque>
#include<algorithm>
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=gc();}
    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}
    return x*f;
}
struct node{
    int x,y,v;
};//q1->max  q2->min q3->max q4->min
int map[N][N],a,b,n;
deque<node> q1,q2,q3[N],q4[N]; 
int main(){
    freopen("2216.in","r",stdin);
    a=read();b=read();n=read();int ans=inf;
    for (int i=1;i<=a;++i)
        for (int j=1;j<=b;++j) map[i][j]=read();
    int op1=1,cl1=0,op2=1,cl2=0;
    for (int k=1;k<=b-n+1;++k){
        int min1=inf,max1=0;
        for (int j=k;j<=k+n-1;++j){
            for (int i=1;i<=n;++i){
                while (!q3[j].empty()&&q3[j].back().v<map[i][j]) q3[j].pop_back();
                while (!q4[j].empty()&&q4[j].back().v>map[i][j]) q4[j].pop_back();
                max1=max(max1,map[i][j]);min1=min(min1,map[i][j]);
                node tmp;tmp.v=map[i][j];tmp.x=i;tmp.y=j;q3[j].push_back(tmp);q4[j].push_back(tmp);
            }
        }ans=min(ans,max1-min1);
    }
    for (int i=n+1;i<=a;++i){
        q1.clear();q2.clear();
        for (int j=1;j<=n;++j){
            while (!q3[j].empty()&&q3[j].front().x<=i-n) q3[j].pop_front();
            while (!q4[j].empty()&&q4[j].front().x<=i-n) q4[j].pop_front();
            while (!q3[j].empty()&&q3[j].back().v<map[i][j]) q3[j].pop_back();
            while (!q4[j].empty()&&q4[j].back().v>map[i][j]) q4[j].pop_back();
            node tmp;tmp.v=map[i][j];tmp.x=i;tmp.y=j;node max2,min2;max2.v=0;min2.v=inf;
            q3[j].push_back(tmp);q4[j].push_back(tmp);max2.x=i;max2.y=j;min2.x=i;min2.y=j;max2.v=min2.v=map[i][j];
            if (q4[j].front().v<min2.v) {min2.v=q4[j].front().v;min2.x=q4[j].front().x;min2.y=q4[j].front().y;}
            if (q3[j].front().v>max2.v) {max2.v=q3[j].front().v;max2.x=q3[j].front().x;max2.y=q3[j].front().y;}
            while (!q1.empty()&&q1.back().v<max2.v) q1.pop_back();
            while (!q2.empty()&&q2.back().v>min2.v) q2.pop_back();
            q1.push_back(max2);q2.push_back(min2);
        }
        for (int j=1;j<=n;++j)
            ans=min(ans,max(q1.front().v,q3[j].front().v)-min(q2.front().v,q4[j].front().v));
        for (int j=n+1;j<=b;++j){
            while (!q3[j].empty()&&q3[j].front().x<=i-n) q3[j].pop_front();
            while (!q4[j].empty()&&q4[j].front().x<=i-n) q4[j].pop_front();
            while (!q3[j].empty()&&q3[j].back().v<map[i][j]) q3[j].pop_back();
            while (!q4[j].empty()&&q4[j].back().v>map[i][j]) q4[j].pop_back();
            node tmp;tmp.v=map[i][j];tmp.x=i;tmp.y=j;node max2,min2;max2.v=0;min2.v=inf;
            q3[j].push_back(tmp);q4[j].push_back(tmp);max2.x=i;max2.y=j;min2.x=i;min2.y=j;max2.v=min2.v=map[i][j];
            if (q4[j].front().v<min2.v) {min2.v=q4[j].front().v;min2.x=q4[j].front().x;min2.y=q4[j].front().y;}
            if (q3[j].front().v>max2.v) {max2.v=q3[j].front().v;max2.x=q3[j].front().x;max2.y=q3[j].front().y;}
            while (!q1.empty()&&q1.front().y<=j-n) q1.pop_front();
            while (!q2.empty()&&q2.front().y<=j-n) q2.pop_front();
            while (!q1.empty()&&q1.back().v<max2.v) q1.pop_back();
            while (!q2.empty()&&q2.back().v>min2.v) q2.pop_back();
            q1.push_back(max2);q2.push_back(min2);
            ans=min(ans,max(q1.front().v,q3[j].front().v)-min(q2.front().v,q4[j].front().v));
        }
    }printf("%d",ans);
    return 0;
} 
```

---

## 作者：yangzechenc (赞：2)

跟着标签的单调队列进来，结果看完题目不想写单调队列 :D 

首先，这题可以写st表。然而这个st表二维的，于是我就想：每行都开一个st表不就变成一维了吗XD。开始担心MLE，结果是TTTTTT…… QAQ

别无他法，我只好又yy了一个二维st表=v=

以最大值为例,f1[i][j][k]表示从左上角为（i,j）右下角为（i+2^k,j+2^k）的矩阵中元素的最大值。将这个矩阵拆分成四块，于是可以得到：

f1[i][j][k]=max{f1[i][j][k-1],f1[i+2^(k-1)][j][k-1],f1[i][j+2^(k-1)][k-1],f1[i+2^(k-1)][j+2^(k-1)][k-1]};

最小值不在赘述，查询详见代码，一维st不会的右转百度XD

code(有彩蛋XD)：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int a,b,n;
int f1[1010][1010][15],f2[1010][1010][15],log[1010];
inline int MAX(int x1,int x2,int x3,int x4){
	return max(x1,max(x2,max(x3,x4)));
}
inline int MIN(int x1,int x2,int x3,int x4){
	return min(x1,min(x2,min(x3,x4)));
}
void make_st(){
	int N=min(a,b);
	for (int k=1;k<=log[N];k++)
		for (int i=1;i+(1<<k)-1<=a;i++)
			for (int j=1;j+(1<<k)-1<=b;j++){
				f1[i][j][k]=MAX(f1[i][j][k-1],f1[i][j+(1<<k-1)][k-1],f1[i+(1<<k-1)][j][k-1],f1[i+(1<<k-1)][j+(1<<k-1)][k-1]);
				f2[i][j][k]=MIN(f2[i][j][k-1],f2[i][j+(1<<k-1)][k-1],f2[i+(1<<k-1)][j][k-1],f2[i+(1<<k-1)][j+(1<<k-1)][k-1]);
			}
	return;
}
int qmax(int x,int y,int x1,int y1){//查询最大值
	int k=log[n];
	int t1=f1[x][y][k],
		t2=f1[x][y1-(1<<k)+1][k],
		t3=f1[x1-(1<<k)+1][y][k],
		t4=f1[x1-(1<<k)+1][y1-(1<<k)+1][k];
	return MAX(t1,t2,t3,t4);
}
int qmin(int x,int y,int x1,int y1){//查询最小值
	int k=log[n];
	int t1=f2[x][y][k],
		t2=f2[x][y1-(1<<k)+1][k],
		t3=f2[x1-(1<<k)+1][y][k],
		t4=f2[x1-(1<<k)+1][y1-(1<<k)+1][k];
	return MIN(t1,t2,t3,t4);
}
int main(){
	log[0]=-1;
	for (int i=1;i<=1000;i++)	log[i]=log[i>>1]+1;
	scanf("%d%d%d",&a,&b,&n);
	for (int i=1;i<=a;i++)
		for (int j=1;j<=b;j++){
			int in;
			scanf("%d",&in);
			f1[i][j][0]=f2[i][j][0]=in;
		}
	make_st();
	int ans=1e9+7;
	for (int i=1;i+n-1<=a;i++)
		for (int j=1;j+n-1<=b;j++)
			ans=min(ans,qmax(i,j,i+n-1,j+n-1)-qmin(i,j,i+n-1,j+n-1));
	cout<<ans<<endl;
    cout<<"防复制黏贴语句："<<endl;
    cout<<"-Like you,Linkiki.   ——yzcc"<<endl;
	return 0;
}
```

---

## 作者：king_more (赞：1)

这道题一看就和poj的滑动窗口很像，不过是二维的滑动窗口，我们在维护每行单调队列的基础上，再维护一个二维的单调队列，就可以达到我们的目的

稍微解释一下

假设n 为 3

把每行前三个的最大值和最小值求出

再竖着来一次单调队列，求出每三行，每三列的最大值和最小值了

最后全部找一遍即可

上代码
```cpp
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;
const int M = 1000;
int f[M + 5][M + 5];
int dmax[M + 5][M + 5];
int dmin[M + 5][M + 5];
int dmax_1[M + 5][M + 5];
int dmin_1[M + 5][M + 5];
signed main(){
	int a,b,n;
	scanf("%d%d%d",&a,&b,&n);
	for(int i = 1;i <= a;i ++){
		for(int j = 1;j <= b;j ++){
			scanf("%d",&f[i][j]);
		}
	}
	for(int i = 1;i <= a;i ++){
		deque<int> que;
		deque<int> que_1;
		for(int j = 1;j <= b;j ++){
			if(que.empty()){
				que.push_back(j);
			}
			else{
				while(! que.empty() && j - que.front() >= n){
					que.pop_front();
				}
				while(! que.empty() && f[i][j] > f[i][que.back()]){
					que.pop_back();
				}
				que.push_back(j);
			}
			dmax[i][j] = f[i][que.front()];
			if(que_1.empty()){
				que_1.push_back(j);
			}
			else{
				while(! que_1.empty() && j - que_1.front() >= n){
					que_1.pop_front();
				}
				while(! que_1.empty() && f[i][j] < f[i][que_1.back()]){
					que_1.pop_back();
				}
				que_1.push_back(j);
			}
			dmin[i][j] = f[i][que_1.front()];
		}
	}
	/*for(int i = 1;i <= a;i ++){
		for(int j = 1;j <= b;j ++){
			printf("%lld %lld|",dmax[i][j],dmin[i][j]);
		}
		printf("\n");
	}*/
	for(int i = 1;i <= b;i ++){
		deque<int> que;
		deque<int> que_1;
		for(int j = 1;j <= a;j ++){
			if(que.empty()){
				que.push_back(j);
			}
			else{
				while(! que.empty() && j - que.front() >= n){
					que.pop_front();
				}
				while(! que.empty() && dmax[j][i] > dmax[que.back()][i]){
					que.pop_back();
				}
				que.push_back(j);
			}
			dmax_1[j][i] = dmax[que.front()][i];
			if(que_1.empty()){
				que_1.push_back(j);
			}
			else{
				while(! que_1.empty() && j - que_1.front() >= n){
					que_1.pop_front();
				}
				while(! que_1.empty() && dmin[j][i] < dmin[que_1.back()][i]){
					que_1.pop_back();
				}
				que_1.push_back(j);
			}
			dmin_1[j][i] = dmin[que_1.front()][i];
		}
	}
	/*for(int i = 1;i <= a;i ++){
		for(int j = 1;j <= b;j ++){
			printf("%lld %lld|",dmax_1[i][j],dmin_1[i][j]);
		}
		printf("\n");
	}*/
	long long minn = 1000000000;
	for(int i = n;i <= a;i ++)
		for(int j = n;j <= b;j ++){
			minn = min(1ll * minn,1ll * dmax_1[i][j] - dmin_1[i][j]);
		}
	printf("%lld",minn);
	return 0;
}
```


---

## 作者：sshwy (赞：1)

# 题意

有一个$a\times b​$的整数组成的矩阵，现请你从中找出一个$n\times n​$的正方形区域，使得该区域所有数中的最大值和最小值的差最小。

# 分析

好多人用什么倍增的算法，还有用线段树的。。。

我们考虑一下，要求以$(i,j)$为右下角的$n\times n$的正方形中的最大值和最小值（以最大值为例）

## 暴力

$n^2$暴力，总复杂度$O(abn^2)$.

## 暴力DP

$f[i][j][k]$表示$(i,j)$为右下角，$k\times k$的正方形中的最大值。

$$
f[i][j][k]=max(f[i][j-1][k-1],f[i-1][j][k-1],f[i-1][j-1][k-1])
$$
复杂度$O(abn)$.

## 倍增DP

$f[i][j][k]$表示$(i,j)$为右下角，$2^k\times2^k$的正方形中的最大值
$$
f[i][j][k]=max(f[i][j][k-1],f[i-2^{k-1}][j][k-1],f[i][j-2^{k-1}][k-1],f[i-2^{k-1}][j-2^{k-1}][k-1])
$$
复杂度$O(ablog_2n)$.

## 单调队列

没错，这就是我要讲的算法

受到暴力DP的启发，我们发现暴力DP用了三个边长小1的正方形来更新当前的正方形

而这有点浪费，因为三个正方形有重复部分（即$(i-k+2,j-k+2)$为左上角，$(i-1,j-1)$为右下角的部分）

那么如何优化呢。。。其实我们可以用互不重叠的一组矩形在凑出正方形啊

考虑$d[i,j]$表示以$(i,j)$为右下角，宽度为$n$，高度为$1$的条状矩形中的最大值

显然对于$d[i,1]\cdots d[i,b]$，可以单调队列一起求啊，也就是维护一个从队首到队尾单调递减队列，保证队首下标与当前下标距离不超过n，然后维护一下

那么有了$d[i][j]$，我们再用$d[i][j]$来一次纵向的宽度为$1$，高度为$n$的条状矩形中的最大值不就完了吗

复杂度$O(ab)$呢

最后，本座为了避免写太多代码，求了$d[i][j]$之后，横竖交换，再求一次横向的即可

# 代码

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
#define FOR(i,j,k) for(int i=j;i<=k;i++)
#define swap(x,y) (x^=y^=x^=y)
using namespace std;
const int N=1003;
int a,b,n,ans=0x3f3f3f3f;
int c[N][N],d[N][N],g[N][N],h[N][N],f[N][N];
//快读
char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
int rd(){
	int res=0;char c=nc();
	while(!isdigit(c))c=nc();
	while(isdigit(c))res=res*10+c-'0',c=nc();
	return res;
}
int calc1(int * v,int * ans){//单调队列计算v[i-n+1..i]的最大值，保存在ans[i]中
	int q[N*2][2],l=1,r=0;
	FOR(i,1,b){
		while(l<=r&&q[r][0]<=v[i])r--;
		while(l<=r&&q[l][1]+n<=i)l++;
		q[++r][0]=v[i],q[r][1]=i;
		ans[i]=q[l][0];
	}
}
int calc2(int * v,int * ans){//单调队列计算v[i-n+1..i]的最小值，保存在ans[i]中
	int q[N*2][2],l=1,r=0;
	FOR(i,1,b){
		while(l<=r&&q[r][0]>=v[i])r--;
		while(l<=r&&q[l][1]+n<=i)l++;
		q[++r][0]=v[i],q[r][1]=i;
		ans[i]=q[l][0];
	}
}
int main(){
	a=rd(),b=rd(),n=rd();
	FOR(i,1,a)FOR(j,1,b)c[i][j]=rd();//读入
	FOR(i,1,a)calc1(c[i],d[i]),calc2(c[i],h[i]);//横向计算最大最小
	FOR(i,1,a)FOR(j,i+1,b)swap(d[i][j],d[j][i]),swap(h[i][j],h[j][i]);//横竖交换
	swap(a,b);//横竖交换，之前的横向的最大最小变成了纵向的最大最小
	FOR(i,1,a)calc1(d[i],g[i]),calc2(h[i],f[i]);//在之前算出的结果上再次横向计算，得到正方形的最大最小
	FOR(i,n,a)FOR(j,n,b)ans=min(ans,g[i][j]-f[i][j]);//统计答案
	printf("%d",ans);
	return 0;
}
```



---

## 作者：wanzzhehe (赞：1)

让我们令Min\[i\]\[j\]\[k\]为以(i,j)为左上角的边长为$2^k$的正方形的最小值，Max\[i\]\[j\]\[k\]同理。

那么就是一个显然的二维ST表了。。（逃

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cmath>
using namespace std;

inline char getc(void) { 
	static char buf[1 << 18], *fs, *ft;
	return (fs == ft && (ft = (fs = buf) + fread(buf, 1, 1 << 18, stdin)), fs == ft) ? EOF : *fs++;
}

inline int read(void) { 
	char tmp = getc();
	int res = 0;
	for(; !isdigit(tmp); tmp = getc());
	for(; isdigit(tmp); tmp = getc())
		res = ((res + (res << 2)) << 1) + (tmp ^ 0x30);
	return res;
}

const int MAXN = 1010, INF = 0x7fffffff;

int Work(int x, int y);

int Min[MAXN][MAXN][11], Max[MAXN][MAXN][11];
int N, M, K, L, P;

int main() { 
	memset(Min, 0x3f, sizeof(Min));
	memset(Max, 0x00, sizeof(Max));
	N = read(), M = read(), K = read();
	for(int i = 1; i <= N; ++i)
		for(int j = 1; j <= M; ++j)
			Min[i][j][0] = Max[i][j][0] = read();
	L = log2(min(N, M)), P = log2(K);
	for(int k = 1; k <= L; ++k) { 
		int x = 1 << (k - 1);
		for(int i = 1; i <= N - x; ++i)
			for(int j = 1; j <= M - x; ++j) { 
				Min[i][j][k] = min( min(Min[i][j][k-1], Min[i+x][j+x][k-1]), min(Min[i+x][j][k-1], Min[i][j+x][k-1]));
				Max[i][j][k] = max( max(Max[i][j][k-1], Max[i+x][j+x][k-1]), max(Max[i+x][j][k-1], Max[i][j+x][k-1]));
			}
	}
	int ans = INF;
	for(int i = 1; i <= N - K + 1; ++i)
		for(int j = 1; j <= M - K + 1; ++j) { 
			ans = min(ans, Work(i, j));
		}
	printf("%d\n", ans);
	return 0;
}

int Work(int x, int y) { 
	int x1 = x + K - 1, y1 = y + K - 1;
	int mi = min(
		min(Min[x][y][P], Min[x1-(1<<P)+1][y1-(1<<P)+1][P]),
		min(Min[x1-(1<<P)+1][y][P], Min[x][y1-(1<<P)+1][P]));
	int mx = max(
		max(Max[x][y][P], Max[x1-(1<<P)+1][y1-(1<<P)+1][P]),
		max(Max[x1-(1<<P)+1][y][P], Max[x][y1-(1<<P)+1][P]));
	return mx - mi;
}
```



---

## 作者：fy0123 (赞：1)

单调队列（不知为什么试炼场里把它放在DP任务里）


对于每一行，我们维护定长区间内的最大值和最小值，maxv[i][j]表示第i行第j列，从j-k+1~j这些数的最大值，minv[i][j]同理。这里的k是题目中的n，也就是正方形的长。然后我们已经知道每一行定长区间内的最值，对于每一列，我们也同样维护这一列定长区间的最值，就能得到一个“定正方形”内的最值。

至于定长区间的最值怎么求，那就是用到我们的单调队列了，这道题其实是个模板。这里我是开两个双端队列，maxq和minq，分别维护。（当然开一个也可以，那样代码就比较长了）


代码如下（请勿复制QAQ）：

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;

const int N = 1010;
const int INF = 1e9;
int n, m, k, a[N][N], maxv[N][N], minv[N][N];

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++) scanf("%d", &a[i][j]);
    //以下对于每一行用单调队列求出maxv[i][j]和minv[i][j]
    for (int i=1; i<=n; i++){
        deque<int> maxq, minq;
        maxv[i][0] = 0;
        minv[i][0] = INF;
        for (int j=1; j<=m; j++){
            while (!maxq.empty() && maxq.front() < j-k+1) maxq.pop_front();  //如果范围超过k就弹出队列
            while (!maxq.empty() && a[i][maxq.back()] <= a[i][j]) maxq.pop_back();   //维护单调递减的队列使得队首为最大值
            maxq.push_back(j);
            maxv[i][j] = a[i][maxq.front()];
            while (!minq.empty() && minq.front() < j-k+1) minq.pop_front();
            while (!minq.empty() && a[i][minq.back()] >= a[i][j]) minq.pop_back();  //维护单调递增的队列使得队首为最小值
            minq.push_back(j);
            minv[i][j] = a[i][minq.front()];
        }
    }
    //以下对于每一列用单调队列求出“定正方形”内最值，并直接计算答案
    int ans = INF;
    for (int j=k; j<=m; j++){  //注意枚举范围从k开始
        deque<int> maxq, minq;
        int MaxV = 0;
        int MinV = INF;
        for (int i=1; i<=n; i++){
            //单调队列用法同上
            while (!maxq.empty() && maxq.front() < i-k+1) maxq.pop_front();
            while (!maxq.empty() && maxv[maxq.back()][j] <= maxv[i][j]) maxq.pop_back();
            maxq.push_back(i);
            MaxV = maxv[maxq.front()][j];
            while (!minq.empty() && minq.front() < i-k+1) minq.pop_front();
            while (!minq.empty() && minv[minq.back()][j] >= minv[i][j]) minq.pop_back();
            minq.push_back(i);
            MinV = minv[minq.front()][j];
            if (i >= k) ans = min(ans, MaxV - MinV);  //注意i >= k时才能更新答案
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：VCVCVCFop_zz (赞：1)

我说真的。。楼下的题解我看的代码恐惧症都要出来了。。。

思路与下面的一位有些相似：

第一步：预处理ma[i][j],mi[i][j]表示以（i,j）位置结尾的长度为正方形边长的  **此行最大值**  即max(f[i][j-边长]...f[i][j]);

考虑到时间问题，直接暴力O（n^3）会TLE，因此用单调队列维护。

第二步：直接枚举列，再次用单调队列维护每一列的答案，对于每一列的最小值与答案作比较记录即可。


CODE：

         
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int q[1001],d[1001],ma[1001][1001],a[1001][1001],mi[1001][1001],n,m,nee;
inline void fir_do()
{
    int l=0,r=0;
    for (int i=1;i<=n;i++)
    {
        l=1;r=1;
        for (int j=1;j<=m;j++)//单调队列得到行最大值
        {
            while (l<r&&q[r-1]<=a[i][j]) r--;//不符合单调队列性质的元素出队
            q[r]=a[i][j];d[r]=j;r++;//进队
            if (d[l]==j-nee) l++;//若与当前的距离超过了正方形边长，则q[l]出队
            if (j>=nee) ma[i][j]=q[l];
        }
        l=1;r=1;
        for (int j=1;j<=m;j++)//单调队列得到行最小值
        {
            while (l<r&&q[r-1]>=a[i][j]) r--;
            q[r]=a[i][j];d[r]=j;r++;
            if (d[l]==j-nee) l++;
            if (j>=nee) mi[i][j]=q[l];
        }
    }
}
inline void doit()
{
    int ans=1e9,ta[1001]={0},ti[1001]={0},l,r;
    for (int i=nee;i<=m;i++)
    {
        l=1;r=1;
        for (int j=1;j<=n;j++)
        {
            while (l<r&&q[r-1]<=ma[j][i]) r--;//由于i枚举的是列，因此去ma[j][i];
            q[r]=ma[j][i];d[r]=j;r++;
            if (d[l]==j-nee) l++;
            if (j>=nee)  ta[j]=q[l];
        }
        l=1;r=1;
        for (int j=1;j<=n;j++)
        {
            while (l<r&&q[r-1]>=mi[j][i]) r--;
            q[r]=mi[j][i];d[r]=j;r++;
            if (d[l]==j-nee) l++;
            if (j>=nee) ti[j]=q[l];
        }
        for (int j=nee;j<=n;j++) ans=min(ans,ta[j]-ti[j]);//记录最小值
    }
    cout<<ans;
}
int main()
{
    cin>>n>>m>>nee;//nee为所求正方形的边长
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            cin>>a[i][j];
    fir_do();//预处理
    doit();//得出答案
}
```

---

## 作者：__stdcall (赞：1)

肯定要预处理，直接dp应该是不能满足复杂度需求的

复杂度大概在O(n^2)或者是O(n^2logn)

下面全部使用单调队列，一个维护最大值，一个维护最小值

求出每横着n个连续数中的最大和最小值，O(n^2)

然后开始计算矩阵

首先求出最左上角的n\*n矩阵中的两个单调队列，O(n)，并O(1)算出取左上角的解

然后每往下移动一列，就执行一次单调队列，每次是O(1)，每行是O(n)，总共是O(n^2)

完
本人没有用stl的队列，所以代码可能会有点长。。。因为自己实现了deque







```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int INF = 1e9+1;
struct dequeue
{
    static const int MAXSIZE = 110;
    int front,rear;
    int elem[MAXSIZE];
    dequeue()
    {
        clear();
    }
    void clear()
    {
        front = rear = 0;
    }
    bool empty()
    {
        return front == rear;
    }
    int iter_next( int idx )
    {
        return (idx+1)%MAXSIZE;
    }
    int iter_prior( int idx )
    {
        return (idx-1+MAXSIZE)%MAXSIZE;
    }
    void push_back( int num )
    {
        elem[rear] = num;
        rear = iter_next(rear);
    }
    void pop_back()
    {
        rear = iter_prior(rear);
    }
    int& get_back()
    {
        return elem[iter_prior(rear)];
    }
    void push_front( int num )
    {
        front = iter_prior(front);
        elem[front] = num;
    }
    void pop_front()
    {
        front = iter_next(front);
    }
    int &get_front()
    {
        return elem[front];
    }
};
struct simpleq
{
    dequeue smallq;
    dequeue largeq;
    simpleq()
    {
        clear();
    }
    void clear()
    {
        smallq.clear();
        largeq.clear();
    }
    void push( int num )
    {
        while( !smallq.empty() && smallq.get_back() > num )
        {
            smallq.pop_back();
        }
        smallq.push_back(num);
        while( !largeq.empty() && largeq.get_back() < num )
        {
            largeq.pop_back();
        }
        largeq.push_back(num);
    }
    void pop( int num )
    {
        if( smallq.get_front() == num )
        {
            smallq.pop_front();
        }
        if( largeq.get_front() == num )
        {
            largeq.pop_front();
        }
    }
    int get_small()
    {
        return smallq.get_front();
    }
    int get_large()
    {
        return largeq.get_front();
    }
};
int a,b,n;
int m[1010][1010];
int large[1010][1010]; // 从(i,j)开始的横着n个数中的最大值 
int small[1010][1010]; 
simpleq tmpq;
simpleq tmpq2;
void debug_print_small_and_large()
{
    printf( "small: \n" );
    for( int i = 0 ; i < a ; ++i )
    {
        for( int j = 0 ; j+n <= b ; ++j )
        {
            printf( "%d " , small[i][j] );
        }
        putchar( '\n' );
    }
    printf( "large: \n" );
    for( int i = 0 ; i < a ; ++i )
    {
        for( int j = 0 ; j+n <= b ; ++j )
        {
            printf( "%d " , large[i][j] );
        }
        putchar( '\n' );
    }
}
int main()
{
    scanf( "%d%d%d" , &a , &b , &n );
    if( n == 1 )
    {
        putchar( '0' );
        return 0;
    }
    for( int i = 0 ; i < a ; ++i )
    {
        for( int j = 0 ; j < b ; ++j )
        {
            scanf( "%d" , &m[i][j] );
        }
    }
    for( int i = 0 ; i < a ; ++i )
    {
        tmpq.clear();
        for( int j = 0 ; j < n ; ++j )
        {
            tmpq.push( m[i][j] );
        }
        small[i][0] = tmpq.get_small();
        large[i][0] = tmpq.get_large();
        for( int j = 1 ; j+n <= b ; ++j )
        {
            tmpq.pop( m[i][j-1] );
            tmpq.push( m[i][j+n-1] );
            small[i][j] = tmpq.get_small();
            large[i][j] = tmpq.get_large();
        }
    }
    //debug_print_small_and_large();
    int rst = INF;
    for( int j = 0 ; j+n <= b ; ++j )
    {
        tmpq.clear(); // 维护最小 
        tmpq2.clear(); // 维护最大 
        for( int i = 0 ; i < n ; ++i )
        {
            tmpq.push( small[i][j] );
            tmpq2.push( large[i][j] );
        }
        rst = min( rst , tmpq2.get_large() - tmpq.get_small() );
        for( int i = 1 ; i+n <= a ; ++i )
        {
            tmpq.pop( small[i-1][j] );
            tmpq.push( small[i+n-1][j] );
            tmpq2.pop( large[i-1][j] );
            tmpq2.push( large[i+n-1][j] );
            rst = min( rst , tmpq2.get_large() - tmpq.get_small() );
        }
    }
    printf( "%d\n" , rst );
    return 0;
}
```

---

## 作者：Rapiz (赞：1)

很多次单调队列即可。

可以用cmp函数简化代码。


mn[I][j]代表包括(I,j)向右n个数的min.。mx[I][j]类似地取max。

单调队列维护。

sn[I][j]代表以(I,j)为左上角的n\*n矩形的min。sx[I][j]类似。

显然有$sn[I][j]=min{mn[I+k][j]}|0\leq k \le n$

单调队列维护。


其中mn,mx的计算可以合并,sn,sx的计算可以合并。

```cpp
#include<cstdio>
#include<algorithm>
//#define DBG
using std::min;
using std::max;
const int MAXN=1010,INF=1<<30;
struct NODE{int i,a;
NODE(int x=0,int y=0):i(x),a(y){}
}q[MAXN];
int n,a,b,dg[MAXN][MAXN],ans=INF,mx[MAXN][MAXN],mn[MAXN][MAXN],sx[MAXN][MAXN],sn[MAXN][MAXN],front=0,rear=0;
int cmp1(int a,int b){
    return a>=b;
}
int cmp2(int a,int b){
    return a<=b;
} 
void dp(int t[MAXN][MAXN],int (*cmp)(int,int)){
    for(int i=1;i<=a;i++) {
        for(int j=1;j<=n;j++){
            //while(front!=rear&&cmp(q[front].a,dg[i][j])) front=(front+1)%MAXN;
            while(front!=rear&&cmp(q[rear-1].a,dg[i][j])) rear=(rear-1+MAXN)%MAXN;
            q[rear]=NODE(j,dg[i][j]);
            rear++;
            rear%=MAXN;
        }
        t[i][1]=q[front].a;
        for(int j=2;j<=b-n+1;j++){
            while(front!=rear&&q[front].i<j) front=(front+1)%MAXN;
            //while(front!=rear&&cmp(q[front].a,dg[i][j+n-1])) front=(front+1)%MAXN;
            while(front!=rear&&cmp(q[rear-1].a,dg[i][j+n-1])) rear=(rear-1+MAXN)%MAXN;
            q[rear]=NODE(j+n-1,dg[i][j+n-1]);
            rear++;
            rear%=MAXN;
            t[i][j]=q[front].a;
        }
        front=rear=0;
    }
}
void dp2(int s[MAXN][MAXN],int t[MAXN][MAXN],int (*cmp)(int,int)){
    for(int j=1;j<=b-n+1;j++){
        for(int i=1;i<=n;i++){
            //while(front!=rear&&cmp(q[front].a,s[i][j])) front=(front+1)%MAXN;
            while(front!=rear&&cmp(q[rear-1].a,s[i][j])) rear=(rear-1+MAXN)%MAXN;
            q[rear]=NODE(i,s[i][j]);
            rear++;
            rear%=MAXN;
        }
        t[1][j]=q[front].a;
        for(int i=2;i<=a-n+1;i++){
            while(front!=rear&&q[front].i<i) front=(front+1)%MAXN;
            //while(front!=rear&&cmp(q[front].a,s[i+n-1][j])) front=(front+1)%MAXN;
            while(front!=rear&&cmp(q[rear-1].a,s[i+n-1][j])) rear=(rear-1+MAXN)%MAXN;
            q[rear]=NODE(i+n-1,s[i+n-1][j]);
            rear++;
            rear%=MAXN;
            t[i][j]=q[front].a;
        }
        front=rear=0;
    }
} 
void show(int t[MAXN][MAXN]){
    for(int i=1;i<=a;i++,printf("\n")) for(int j=1;j<=b;j++) printf("%d ",t[i][j]);
    printf("\n");
}
int main(){
    scanf("%d%d%d",&a,&b,&n);
    for(int i=1;i<=a;i++) for(int j=1;j<=b;j++) scanf("%d",&dg[i][j]);
    dp(mn,cmp1),dp(mx,cmp2);
    #ifdef DBG
    show(mn),show(mx);
    #endif
    dp2(mn,sn,cmp1),dp2(mx,sx,cmp2);
    for(int i=1;i<=a-n+1;i++) for(int j=1;j<=b-n+1;j++) {
        if(sx[i][j]-sn[i][j]<ans) ans=sx[i][j]-sn[i][j];
    }
    printf("%d",ans);
}
```

---

## 作者：slothfulxtx (赞：1)

这道题的思路主要就是维护一个优先队列，如果写过斜率优化的题这道题就能很快地ac，其实写法差不多，这里f1[i,j]表示第i行第j个格子开始连续n个格子的值的最大值

f2[i,j]是最小值，ff1[i,j]表示以（i,j）为左上角的n\*n中的最大值，ff2为最小值

```delphi
program p2216;
var
  f1,f2,ff1,ff2,map:array[1..1000,1..1000]of longint;
    i,j,a,b,n,op1,op2,cl1,cl2,ans,maxk,mink:longint;
    q1,q2:array[1..1000]of longint;
function min(x,y:longint):longint;
begin
  if x<y then exit(x) else exit(y);
end;
begin
 
    readln(a,b,n);
    for i:=1 to a do begin
      for j:=1 to b do read(map[i,j]);
        readln;
    end;
    for i:=1 to a do begin
        q1[1]:=1;q2[1]:=1;
    cl1:=1;cl2:=1;
    for j:=2 to n do begin
      while (cl1>=1)and(map[i,q1[cl1]]<=map[i,j])do dec(cl1);
      inc(cl1);q1[cl1]:=j;
      while (cl2>=1)and(map[i,q2[cl2]]>=map[i,j])do dec(cl2);
      inc(cl2);q2[cl2]:=j;
    end;
        f1[i,1]:=map[i,q1[1]];f2[i,1]:=map[i,q2[1]];
        op1:=1;op2:=1;
        for j:=2 to b-n+1 do begin
          while (op1<=cl1)and(map[i,q1[cl1]]<=map[i,j+n-1])do dec(cl1);
          inc(cl1);q1[cl1]:=j+n-1;
            if q1[op1]<j then inc(op1);
          f1[i,j]:=map[i,q1[op1]];
            while (op2<=cl2)and(map[i,q2[cl2]]>=map[i,j+n-1])do dec(cl2);
            inc(cl2);q2[cl2]:=j+n-1;
            if q2[op2]<j then inc(op2);
            f2[i,j]:=map[i,q2[op2]];
        end;
    end;
    for j:=1 to b-n+1 do begin
      q1[1]:=1;q2[1]:=1;
    cl1:=1;cl2:=1;
    for i:=2 to n do begin
      while (cl1>=1)and(f1[q1[cl1],j]<=f1[i,j])do dec(cl1);
      inc(cl1);q1[cl1]:=i;
      while (cl2>=1)and(f2[q2[cl2],j]>=f2[i,j])do dec(cl2);
      inc(cl2);q2[cl2]:=i;
    end;
        ff1[1,j]:=f1[q1[1],j];ff2[1,j]:=f2[q2[1],j];
    op1:=1;op2:=1;
        for i:=2 to a-n+1 do begin
          while (op1<=cl1)and(f1[i+n-1,j]>=f1[q1[cl1],j]) do dec(cl1);
          inc(cl1);q1[cl1]:=i+n-1;
          if q1[op1]<i then inc(op1);
            ff1[i,j]:=f1[q1[op1],j];
            while (op2<=cl2)and(f2[i+n-1,j]<=f2[q2[cl2],j])do dec(cl2);
            inc(cl2);q2[cl2]:=i+n-1;
            if q2[op2]<i then inc(op2);
            ff2[i,j]:=f2[q2[op2],j];
        end;
    end;
    ans:=maxlongint;
    for i:=1 to  a-n+1 do
      for j:=1 to b-n+1 do
          ans:=min(ans,ff1[i,j]-ff2[i,j]);
    writeln(ans);
end.

```

---

## 作者：sqc1999 (赞：1)

先用滑动窗口+单调队列求出每一行长度为n的连续序列中的最大值、最小值，存到rmin[i][j],rmax[i][j]两个数组里，再用相同的方法求这两个数组中每一列长度为n的连续序列的最大值、最小值存到gmin[i][j],gmax[i][j]中（后来发现直接覆盖到rmin,rmax中也没关系）。最后O(ab)遍历gmin,gmax得出答案。

单调队列我用系统的deque，巨慢。。

具体看代码吧，看起来有点长啊，不过都是复制粘贴啦。

```cpp

#include<iostream>  
#include<algorithm>  
#include<queue>  
#define mk(a,b) make_pair(a,b)  
using namespace std;  
int m[1001][1001], rmin[1001][1001], rmax[1001][1001], gmin[1001][1001], gmax[1001][1001];  
deque<pair<int, int> > qmin, qmax;  
int main()  
{  
    ios::sync_with_stdio(false);  
    int a, b, n;  
    cin >> a >> b >> n;  
    for (int i = 1; i <= a; i++)  
    {  
        for (int j = 1; j <= b; j++)  
        {  
            cin >> m[i][j];  
        }  
    }  
    for (int i = 1; i <= a; i++)  
    {  
        for (int j = 1; j < n; j++)  
        {  
            while (!qmin.empty() && qmin.back().second > m[i][j]) qmin.pop_back();  
            qmin.push_back(mk(j, m[i][j]));  
            while (!qmax.empty() && qmax.back().second < m[i][j]) qmax.pop_back();  
            qmax.push_back(mk(j, m[i][j]));  
        }  
        for (int j = 1; j + n - 1 <= b; j++)  
        {  
            while (!qmin.empty() && qmin.back().second > m[i][j + n - 1]) qmin.pop_back();  
            qmin.push_back(mk(j + n - 1, m[i][j + n - 1]));  
            while (!qmax.empty() && qmax.back().second < m[i][j + n - 1]) qmax.pop_back();  
            qmax.push_back(mk(j + n - 1, m[i][j + n - 1]));  
            while (qmin.front().first < j) qmin.pop_front();  
            while (qmax.front().first < j) qmax.pop_front();  
            rmin[i][j] = qmin.front().second;  
            rmax[i][j] = qmax.front().second;  
        }  
        qmin.clear();  
        qmax.clear();  
    }  
    for (int j = 1; j <= b; j++)  
    {  
        for (int i = 1; i < n; i++)  
        {  
            while (!qmin.empty() && qmin.back().second > rmin[i][j]) qmin.pop_back();  
            qmin.push_back(mk(i, rmin[i][j]));  
            while (!qmax.empty() && qmax.back().second < rmax[i][j]) qmax.pop_back();  
            qmax.push_back(mk(i, rmax[i][j]));  
        }  
        for (int i = 1; i + n - 1 <= a; i++)  
        {  
            while (!qmin.empty() && qmin.back().second > rmin[i + n - 1][j]) qmin.pop_back();  
            qmin.push_back(mk(i + n - 1, rmin[i + n - 1][j]));  
            while (!qmax.empty() && qmax.back().second < rmax[i + n - 1][j]) qmax.pop_back();  
            qmax.push_back(mk(i + n - 1, rmax[i + n - 1][j]));  
            while (qmin.front().first < i) qmin.pop_front();  
            while (qmax.front().first < i) qmax.pop_front();  
            gmin[i][j] = qmin.front().second;  
            gmax[i][j] = qmax.front().second;  
        }  
        qmin.clear();  
        qmax.clear();  
    }  
    int ans = 1000000000;  
    for (int i = 1; i + n - 1 <= a; i++)  
    {  
        for (int j = 1; j + n - 1 <= b; j++)  
        {  
            ans = min(ans, gmax[i][j] - gmin[i][j]);  
        }  
    }  
    cout << ans;  
}

```

---

## 作者：Barcelona_Messi (赞：1)

这道题让求n*n的正方形最大值与最小值差最大
我们想对于每个正方形 分别记录它的最大值和最小值 然后相减找差的最大值就可以了

但怎么维护一个二维平面内的最大值和最小值呢？一个很好的思路就是将二维转化为一维 
 比如求二维前缀和时 一种方法就是令b[i][j]=sigma(a[i][k]) （k<=j） 然后sum[i][j]=sum[i-1][j]+b[i][j] 

对于这道题来说 我们可以求出一个n*n的正方形中每一行的最大（小）值 然后区间的最大（小）值就是每一行的最大（小）值的最大（小）值 显然 对于一个一维序列 要求长度为n的数中最大（小）值可以用滑动窗口O(N)地解决 我们设数组minn[i][j]和maxn[i][j] 表示第i行从j开始的n个数中的最小值和最大值

处理完后再枚举每个n正方形的左上角 算出向下n行的min(minn[i][j])和max(maxn[i][j]) 再把差求一个最大值即可 时间复杂度为O(a*b *n）

代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int INF=1000000000;
int a,b,w[1010][1010],minn[1010][1010],maxn[1010][1010];
int fp,rp,exp=INF,xmin=INF,xmax=INF;
struct node
{ int val,pos;}q[1000001];
int main()
{ int i,j,k,n;
  scanf("%d%d%d",&a,&b,&n);
  for(i=1;i<=a;i++)
   for(j=1;j<=b;j++) scanf("%d",&w[i][j]);
  for(i=1;i<=a;i++)
  { fp=rp=1;q[fp].val=w[i][1];q[fp].pos=1; 
    for(j=2;j<n;j++)
    { while(fp<=rp&&q[rp].val>w[i][j]) rp--;
      q[++rp].val=w[i][j];q[rp].pos=j;}
    for(j=n;j<=b;j++)
    { while(fp<=rp&&q[rp].val>w[i][j]) rp--;
      q[++rp].val=w[i][j];q[rp].pos=j;
      while(fp<=rp&&q[fp].pos<j-n+1) fp++;
      minn[i][j-n+1]=q[fp].val;}}
  for(i=1;i<=a;i++)
  { fp=rp=1;q[fp].val=w[i][1];q[fp].pos=1;
    for(j=2;j<n;j++)
    { while(fp<=rp&&q[rp].val<w[i][j]) rp--;
      q[++rp].val=w[i][j];q[rp].pos=j;}
    for(j=n;j<=b;j++)
    { while(fp<=rp&&q[rp].val<w[i][j]) rp--;
      q[++rp].val=w[i][j];q[rp].pos=j;
      while(fp<=rp&&q[fp].pos<j-n+1) fp++;
      maxn[i][j-n+1]=q[fp].val;}} 
  for(i=1;i<=a-n+1;i++)
   for(j=1;j<=b-n+1;j++)
  { xmin=INF;xmax=0;
    for(k=0;k<=n-1;k++)
    { xmin=min(xmin,minn[i+k][j]);
      xmax=max(xmax,maxn[i+k][j]);}
    exp=min(exp,xmax-xmin);}
  printf("%d",exp);
  return 0;
}
```


---

## 作者：Kisaragi_77 (赞：1)

卡常神题中 & 整数退火板子题

由于我菜到不会打任何一种二维数据结构

一开始就打了个线段树套st，发现开心的TLE3

怒而退火

本题中子正方形会有不少重叠，所以退火显然比直接随机化珂学

另外，本题的定义域不连续，所以温度的选取不能直接开的巨大，每次都要保证坐标是整数

退火代码都差不多吧，发不发意义不大

开优化基本AC是稳的
```cpp
#pragma GCC optimize(3)
#include<cstdio>
#include<ctime>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<cmath>
#define double double
#define RAND_INT (rand() << 1) -RAND_MAX
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
int a[1001][1001],n,m,k,ans=1e9,ans_x,ans_y;
inline int read() {
	char x =getchar();	int a =0;
	while(!isdigit(x))	x =getchar();
	while(isdigit(x))	a =a*10+x-48,x =getchar();
	return a;	
}
inline int calc(int rx,int ry){
	int mx =-1e9,mn =1e9;
	for(int x=rx;x<=rx+k-1;++x)
		for(int y=ry;y<=ry+k-1;++y)
			mx =max(a[x][y],mx),
			mn =min(a[x][y],mn);
	return mx-mn;
}
inline void SA(){
	int x =ans_x,y =ans_y;
	for(double T =max(n,m);T>=0.1;T *=0.997){
		int X =(x+RAND_INT %(int)(T*10)) %(n-k+1)+1,
			Y =(y+RAND_INT %(int)(T*10)) %(m-k+1)+1;
		if(X<1 || Y<1 || X>n-k+1 || Y>m-k+1)	continue;
		int now =calc(X,Y);
		double delta =now -ans;
		if(delta < 0){
			ans =now;
			ans_x =x =X;
			ans_y =y =Y;
		}
		else if(exp(-delta/T)*RAND_MAX > rand()) x =X,y =Y;
	}
}
int main(){
	n =read();	m =read();	k =read();
	for(int i=1;i<=n;++i)	for(int j=1;j<=m;++j)	a[i][j] =read();
	ans_x =(n+1)>>1;
	ans_y =(m+1)>>1;
	while ((double)clock() / CLOCKS_PER_SEC < 0.9) SA();
	printf("%d",ans);
}
```



---

## 作者：小黑AWM (赞：0)

做掉这题挺不容易的，是从试练场的单调队列关点进来的，但是看到题目第一秒想到的是二维St表……阅读时建议直接跳转至思路。仔细地翻了一下题解单调队列里基本都是把预处理和计算分开的，我这种写法好像没有，自己觉得我的逻辑比较清晰一些。

虽然之后看到很多巨佬都成功的使用改进后的二维st表切了这题，但是直接yy板子的我因MLE只拿了20分。
##### 二维st表模板/不能AC
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
#define reg register
#define type int//看情况修改返回类型
inline char nc()
{
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline type read()
{
    bool minus=false;
    char ch=nc();type sum=0;
    while(!(ch>='0'&&ch<='9')&&ch!='-')ch=nc();
    if(ch=='-')minus=true,ch=nc();//判负没必要的时候记得删，影响效率
    while(ch>='0'&&ch<='9')sum=(sum<<1)+(sum<<3)+ch-48,ch=nc();
    return sum;
}
const int maxn = 1e3 + 10;
const int maxlog = 10 + 1;
const int INF = 0x7fffffff;
int n, m, k;
int a[maxn][maxn];
int st1[maxn][maxn][maxlog][maxlog], st2[maxn][maxn][maxlog][maxlog];
int Log2[maxn];
inline int query1(int x1, int y1, int x2, int y2)
{
    int k1 = Log2[x2 - x1 + 1], k2 = Log2[y2 - y1 + 1];
    return max(st1[x1][y1][k1][k2], max(st1[x2-(1<<k1)+1][y1][k1][k2], max(st1[x1][y2-(1<<k2)+1][k1][k2], st1[x2-(1<<k1)+1][y2-(1<<k2)+1][k1][k2])));
}
inline int query2(int x1, int y1, int x2, int y2)
{
    int k1 = Log2[x2 - x1 + 1], k2 = Log2[y2 - y1 + 1];
    return min(st2[x1][y1][k1][k2], min(st2[x2-(1<<k1)+1][y1][k1][k2], min(st2[x1][y2-(1<<k2)+1][k1][k2], st2[x2-(1<<k1)+1][y2-(1<<k2)+1][k1][k2])));
}
int main()
{
    n = read(), m = read(), k = read();
    for(int i = 2; i <= max(n, m); i++){
        if((1 << (Log2[i-1]+1)) > i)
            Log2[i] = Log2[i-1];
        else
            Log2[i] = Log2[i-1]+1;
    }

    for (reg int i = 1 ; i <= n ; ++i)
        for (reg int j = 1 ; j <= m ; ++j)
            st2[i][j][0][0] = st1[i][j][0][0] = a[i][j] = read();

    for (reg int p = 0 ; p <= 10 ; p ++)
        for (reg int q = 0 ; q <= 10 ; q ++)
            if (p != 0 || q != 0){
                for (reg int i = 1 ; i + (1<<p) - 1 <= n ; i ++)
                    for (reg int j = 1 ; j + (1<<q) - 1 <= m ; j ++)
                        if (!p) st1[i][j][p][q] = max(st1[i][j][p][q - 1], st1[i][j+(1<<(q-1))][p][q - 1]);
                        else st1[i][j][p][q] = max(st1[i][j][p-1][q], st1[i+(1<<(p-1))][j][p-1][q]);
            }//i走p次方，q走j次方for (reg int p = 0 ; p <= 10 ; p ++)
    for (reg int p = 0 ; p <= 10 ; p ++)
        for (reg int q = 0 ; q <= 10 ; q ++)
            if (p != 0 || q != 0)
                for (reg int i = 1 ; i + (1<<p) - 1 <= n ; i ++)
                    for (reg int j = 1 ; j + (1<<q) - 1 <= m ; j ++)
                        if (!p) st2[i][j][p][q] = min(st2[i][j][p][q - 1], st2[i][j+(1<<(q-1))][p][q - 1]);
                        else st2[i][j][p][q] = min(st2[i][j][p-1][q], st2[i+(1<<(p-1))][j][p-1][q]);

    int ans = INF;
    for(int i = 1; i <= n - k + 1; i++){
        for(int j = 1; j <= m - k + 1; j++){
            int temp = query1(i, j, i + k - 1, j + k - 1) - query2(i, j, i + k - 1, j + k - 1);
            ans = min(temp, ans);
        }
    }

    cout << ans << endl;
    return 0;
}

```
上述算法时间复杂度$O(N*M*logN*logM)$空间复杂度与时间复杂度相同，不过由于空间复杂度略大，该算法MLE，改进后可以利用正方形边长相等的性质省去一维$O(LogN)$达到极大的节约空间的目的从而AC本题，以上代码的存在价值仅为读者提供可直接套用的二维st表模板，不作冗余讲解，如需讲解可转阅他人题解。

惫懒的我虽然知道正方形的性质但是自然是不愿意继续想这个卡满的劣质算法的。于是回到单调队列，对于单调队列的讲解，可以参考我的另一篇题解[单调队列-最大子段和](https://andrewwayne.blog.luogu.org/solution-p1115)，个人认为讲的还是不错的，欢迎各位指正。

B克曾经告诉过我，单调队列可以解决询问没有重复区间的RMQ问题。引入思考，本问题实际也不过是一种变相的二维RMQ问题，再枚举$N*M$个点罢了。对于一个正方形我们可以轻松地用单调队列处理出每一行的最大值最小值，然后再对于每一行的值在列上处理出最大值与最小值即可。

规定$Aque1[i]$为一个单调队列维护了第i行中的最小值，$Aque2[i]$为最大值，$Bque1$表示维护到第i列$min(Aque1[1 \dots n])$$Bque2$为$max(  Aque2[1 \dots n])$

然后我们枚举正方向的右下角标$(j,i)$枚举的时候可以同时处理出最大值和最小值，最终每个点在Aque中最多进一次出一次，所以总复杂度$O(N*M)$仔细地翻了一下题解发现都是把预处理和计算分开的，但其实并没有这个必要，为了节约空间我们可以直接在枚举点的时候更新，实现中的思路在代码中有注释。
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
const int MAXN = 1e3 + 10;
int N, M, L, A[MAXN][MAXN];
deque<pair<int,int> > Aque1[MAXN], Aque2[MAXN], Bque1, Bque2;//定义如上文所述
int ANS = 0x7fffffff;
int main(){
    cin >> N >> M >> L;
    for(int i = 1; i <= N; i++)
        for(int j = 1; j <= M; j++)
            cin >> A[i][j];
    int val = 0;
    
    for(int i = 1; i <= M; i++){
        Bque1.clear();
        Bque2.clear();//清空是很有必要的，由于每进入新的一列都是一个新的Bque，与上一列的值无关，而每一轮结束后并不一定能够使所有元素出队。
        for(int j = 1; j <= N; j++){//我的扫描方式类似于一个矩阵一列一列的竖着推进过去
            while(!Aque1[j].empty() && Aque1[j].front().first <= i - L)
                Aque1[j].pop_front();//抛弃过期决策
            while(!Aque2[j].empty() && Aque2[j].front().first <= i - L)
                Aque2[j].pop_front();
            while(!Bque1.empty() && Bque1.front().first <= j - L)
                Bque1.pop_front();
            while(!Bque2.empty() && Bque2.front().first <= j - L)
                Bque2.pop_front();
            
            while(!Aque1[j].empty() && Aque1[j].back().second > A[j][i])
                Aque1[j].pop_back();
            Aque1[j].push_back(make_pair(i, A[j][i]));
            while(!Aque2[j].empty() && Aque2[j].back().second < A[j][i])
                Aque2[j].pop_back();
            Aque2[j].push_back(make_pair(i, A[j][i]));//抛弃不优决策，保证维护出A[j][i-L+1] ～ A[j]i]中的最优决策点
            
            while(!Bque1.empty() && Bque1.back().second > Aque1[j].front().second)
                Bque1.pop_back();
            Bque1.push_back(make_pair(j, Aque1[j].front().second));
            while(!Bque2.empty() && Bque2.back().second < Aque2[j].front().second)
                Bque2.pop_back();
            Bque2.push_back(make_pair(j, Aque2[j].front().second));//维护出Aque[j-L+1] ～ Aque[j]之间的最优决策
            
            if(i >= L && j >= L)//若是右下角表过小不成正方形则不记录
                ANS = min(ANS, Bque2.front().second - Bque1.front().second);
        }
    }
    cout << ANS << endl;
    return 0;
}

```
思路应该是属于较容易想到的，唯独利用一个维护列上的单调队列来维护行队列的有一丝妙处。时间复杂度严格$O(N*M)$不过因为我滥用STL和cin所以常数大到飞起所以总时间并不是很快。OI之乐便是在于经过一番苦思之后想到最优解和多解吧。


---

## 作者：Tiffany_Tendering (赞：0)

有备于初赛，好久没发题解了。
单调队列是个很神奇的东西 凭个人理解 把这个体的思路说一遍 （借鉴于题解大佬！）

**这个题的思路应该是对每一行都开两个队列，一个存最大值，一个存最小值。 本人的习惯是用qmax [i][j]表示第i行 从第j列开始 往后n列的最大值 qmin[i][j]就是存最小值。最后将每一行里每一列的最大最小值用一个二维结构体存起来（比如说是row[i][j]）**

之后 这个应该才是关键
**对于每一列 和行一样，也是开两个队列，也用一个结构体存起来（比如说是col[i][j]）。
但是 这个col[i][j]存的是从第i行第j列这个格子开始 往后n列 往下n行的最大值和最小值。**
**可能有那么一点抽象，其实就是用我们的row[i][j]结构体去更新col[i][j],因为在每一行里从某个格子开始往后n列的最大最小值已经求出来了，所以我们主要用单调队列维护一下就好。**

单调队列里存的应该是下标（横坐标或纵坐标） ！！


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std ;
const int maxn = 1005;
int n,m,k,qmax[maxn],qmin[maxn],a[maxn][maxn];
struct ROW {int maxx,minn;} row[maxn][maxn];
struct COL {int maxx,minn;} col[maxn][maxn];
int main() {
	scanf("%d%d%d",&n,&m,&k) ;
	for(int i = 1; i <= n ;++i)
	  for(int j = 1;j <= m ;++j) scanf("%d",&a[i][j]) ; 
	for(int h = 1;h <= n ;++h) {
		memset(qmax,0,sizeof(qmax)) ;
		memset(qmin,0,sizeof(qmin)) ;
		int headmax = 1,headmin = 1,tailmax = 0,tailmin = 0;
		for(int i = 1;i <= m ;++i) {
			while(headmax <= tailmax && a[h][qmax[tailmax]] <= a[h][i]) tailmax-- ;
			qmax[++tailmax] = i ;
			while(headmin <= tailmin && a[h][qmin[tailmin]] >= a[h][i]) tailmin-- ;
			qmin[++tailmin] = i ;
			while(qmax[headmax] < i - k + 1) headmax++ ;
		    while(qmin[headmin] < i - k + 1) headmin++ ;
		    if(i >= k) 
		        row[h][i - k + 1].maxx = a[h][qmax[headmax]] ,
		        row[h][i - k + 1].minn = a[h][qmin[headmin]] ;
		}
    }
	for(int c = 1;c <= m - k + 1; ++c) {
		memset(qmax,0,sizeof(qmax)) ;
		memset(qmin,0,sizeof(qmin)) ;		
	    int headmax = 1,headmin = 1,tailmax = 0,tailmin = 0;
	    for(int i = 1;i <= n ;++i) {
	    	while(headmax <= tailmax && row[qmax[tailmax]][c].maxx <= row[i][c].maxx) tailmax-- ;
	    	qmax[++tailmax] = i;
	    	while(headmin <= tailmin && row[qmin[tailmin]][c].minn >= row[i][c].minn) tailmin-- ;
	    	qmin[++tailmin] = i;
	    	while(qmax[headmax] < i - k + 1) headmax++ ;
	    	while(qmin[headmin] < i - k + 1) headmin++ ;
	    	if(i >= k)
	    	  col[i - k + 1][c].maxx = row[qmax[headmax]][c].maxx ,
	    	  col[i - k + 1][c].minn = row[qmin[headmin]][c].minn ;
		}
	}
	int ans = 1e9;
	for(int i = 1;i <= n - k + 1;++i)
	  for(int j = 1;j <= m - k + 1;++j)
	    ans = min(ans,col[i][j].maxx - col[i][j].minn) ;
	printf("%d",ans) ;
	return 0;
}
```

---

## 作者：清风我已逝 (赞：0)

有点弱，居然评测速度没跑过61级学弟

	思路：单调队列维护每一行每连续的n个数的最大值和最小值
    
    	之后再跑一边单调队列，从第一行前n个开始，从上向下，从左向右跑单调队列即可


```
#include<bits/stdc++.h>
#define N 2010050
using namespace std;

void in(int &x){
    register char c=getchar();x=0;int f=1;
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    x*=f;
}

int a,b,n,ma[1005][1005],mx[1005][1005],mi[1005][1005];
int qa[N],qb[N],ans;//dandiaoduilie
int main()
{
	in(a);in(b);in(n);
	for(int i=1;i<=a;i++)
		for(int j=1;j<=b;j++)
			in(ma[i][j]);
	for(int i=1;i<=a;i++){
		int head=1,tail=0,hhead=1,ttail=0;
		for(int j=1;j<=b;j++){
			while(head<=tail&&ma[i][qa[tail]]<=ma[i][j]) --tail;//max 单调递减序列 
			qa[++tail]=j;
			while(qa[head]<=j-n) ++head;
			
			while(hhead<=ttail&&ma[i][qb[ttail]]>=ma[i][j]) --ttail;//min 单调递增序列 
			qb[++ttail]=j;
			while(qb[hhead]<=j-n) ++hhead;
			
			if(j>=n) mx[i][j]=ma[i][qa[head]],mi[i][j]=ma[i][qb[hhead]];
		}
	}ans=0x7fffffff;
	/*
	puts("");
	for(int i=1;i<=a;i++){
		for(int j=1;j<=b;j++){
			cout<<mx[i][j]<<" ";
		}puts("");
	}puts("");
	for(int i=1;i<=a;i++){
		for(int j=1;j<=b;j++){
			cout<<mi[i][j]<<" ";
		}puts("");
	}
	*/
	for(int j=n;j<=b;j++){
		int head=1,tail=0,hhead=1,ttail=0;
		for(int i=1;i<=a;i++){
			while(head<=tail&&mx[qa[tail]][j]<=mx[i][j]) --tail;
			qa[++tail]=i;
			while(qa[head]<=i-n) ++head;
			
			while(hhead<=ttail&&mi[qb[ttail]][j]>=mi[i][j]) --ttail;
			qb[++ttail]=i;
			while(qb[hhead]<=i-n) ++hhead;
			if(i>=n) ans=min(ans,mx[qa[head]][j]-mi[qb[hhead]][j]);
		}
	}printf("%d\n",ans);
	return 0;
}
```

---

## 作者：XZYQvQ (赞：0)

//安利一发自己的博客QvQ：[传送门=￣ω￣=](http://www.k-xzy.xyz/archives/4113)
# 题解
听说正解是动态规划QvQ，但我的是暴力堆+哈希表。。。

害怕.jpg

但是我沉迷暴力的数据结构，于是先写了个kd-tree版的，然后毫无疑问地TLE了

代码如下（会T不用试了）
```cpp
#include <bits/stdc++.h>

#define DS (2)
#define NS (1005)
#define INF (1000000005)
#define FIR first
#define SEC second

using namespace std;

typedef pair<int, int> PII;


template <typename _Tp> inline void IN(_Tp& dig)
{
	char c; bool flag = 0; dig = 0;
	while (c = getchar(), !isdigit(c));
	while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
}

int A, B, n, root, sz, D, ans = INT_MAX;

struct N
{
	int d[DS], mnd, mxd, data, mn[DS], mx[DS], l, r;
	int& operator [] (const int a){return d[a];}
}arr[NS * NS], e[NS * NS];

bool cmp(N a, N b){return a[D] < b[D];}

void pup(int a)
{
	int l = e[a].l, r = e[a].r;
	if (l)
	{
		e[a].mnd = min(e[a].mnd, e[l].mnd);
		e[a].mxd = max(e[a].mxd, e[l].mxd);
	}
	if (r)
	{
		e[a].mnd = min(e[a].mnd, e[r].mnd);
		e[a].mxd = max(e[a].mxd, e[r].mxd);
	}
	for (int i = 0; i < DS; i += 1)
	{
		e[a].mn[i] = e[a].mx[i] = e[a][i];
		if (l)
		{
			e[a].mn[i] = min(e[a].mn[i], e[l].mn[i]);
			e[a].mx[i] = max(e[a].mx[i], e[l].mx[i]);
		}
		if (r)
		{
			e[a].mn[i] = min(e[a].mn[i], e[r].mn[i]);
			e[a].mx[i] = max(e[a].mx[i], e[r].mx[i]);
		}
	}
}

int Build(int l, int r, int d = 0)
{
	if (l > r) return 0;
	D = d;
	int mid = ((l + r) >> 1), a = ++sz;
	nth_element(arr + l, arr + mid, arr + r + 1, cmp);
	e[a] = arr[mid];
	e[a].l = Build(l, mid - 1, d ^ 1);
	e[a].r = Build(mid + 1, r, d ^ 1);
	pup(a); return a;
}

bool jud_in(int x1, int y1, int x2, int y2, int a)
{
	return x1 <= e[a].mn[0] && y1 <= e[a].mn[1] \
		&& x2 >= e[a].mx[0] && y2 >= e[a].mx[1];
}

bool jud_out(int x1, int y1, int x2, int y2, int a)
{
	return x1 > e[a].mx[0] || y1 > e[a].mx[1] \
	 || x2 < e[a].mn[0] || y2 < e[a].mn[1];
}

bool jud_point(int x1, int y1, int x2, int y2, int a)
{
	return x1 <= e[a][0] && y1 <= e[a][1] \
		&& x2 >= e[a][0] && y2 >= e[a][1];
}

void jud_res(PII& res, PII a)
{
	res.FIR = min(res.FIR, a.FIR), res.SEC = max(res.SEC, a.SEC);
}

PII query(int x1, int y1, int x2, int y2, int a = root)
{
	if (!a) return PII(INF, -INF);
	if (jud_in(x1, y1, x2, y2, a)) return PII(e[a].mnd, e[a].mxd);
	if (jud_out(x1, y1, x2, y2, a)) return PII(INF, -INF);
	PII res(INF, -INF);
	if (jud_point(x1, y1, x2, y2, a))
		jud_res(res, PII(e[a].data, e[a].data));
	jud_res(res, query(x1, y1, x2, y2, e[a].l));
	jud_res(res, query(x1, y1, x2, y2, e[a].r));
	return res;
}

int main (int argc, char const* argv[])
{
	IN(A), IN(B), IN(n);
	for (int i = 1, k, tot = 1; i <= A; i += 1)
		for (int j = 1; j <= B; j += 1)
			IN(k), arr[tot++] = (N){i, j, k, k, k};
	root = Build(1, A * B);
	for (int i = 1; i <= A - n + 1; i += 1)
		for (int j = 1; j <= B - n + 1; j += 1)
		{
			PII tmp = query(i, j, i + n - 1, j + n - 1);
			ans = min(ans, tmp.SEC - tmp.FIR);
		}
	printf("%d\n", ans);
	return 0;
}
```

不甘心的我继续研究暴力方法。

于是想到了这个思路：

首先设$mx[i,j]$表示第$i$行的区间$[j,j+n-1]$内的最大值。

而$mn[i,j]$表示第$i$行的区间$[j,j+n-1]$内的最小值。

即：
$$mx[i,j]=MAX(a[i,k]|k\in [j,j+n-1])$$
$$mn[i,j]=MIN(a[i,k]|k\in [j,j+n-1])$$

怎么求$mx,mn$呢？

不难想到用一颗平衡树维护

首先枚举行数$i$，然后把第$i$行的区间$[1,n]$内的元素丢到平衡树里，这样$mx[i,1]$就是平衡树中最大的元素，$mn[i,1]$就是平衡树中最小的元素。

接着枚举$j$，每次将第$i$行第$j-1$个元素从平衡树中删除，再向平衡树中添加第$i$行地$j+n-1$个元素。然后依然是平衡树中最小的元素是$mn[i,j]$，最大的是$mx[i,j]$

求出了$mn,mx$又有什么用呢？

我们再设$min[i,j]$为矩形$(i,j)(i+n,j+n)$（这里给出的两个坐标表示矩形的左上角和右下角）内的最小值，$max[i,j]$表示矩形$(i,j)(i+n,j+n)$内的最大值

很明显：
$$max[i,j]=MAX(mx[k,j]|k\in [i,i+n-1])$$
$$min[i,j]=MIN(mn[k,j]|k\in [i,i+n-1])$$

所以求法和求$mx,mn$是相同的！

用平衡树维护即可

复杂度是$O(ABlog_2n)$的。

但是我，，，很懒，就不想手打平衡树

然后发现multiset很慢（map也很慢），因为它插入、删除、取最大最小都是很慢的。最大的点开O2还要3s+

所以我们用堆来替换它

搞两个堆，一个大根堆一个小根堆。

至于删除，就搞两个哈系表分别对应两个堆，分别储存某个数字被删除了多少次。如果某次取出的堆顶，发现它被删除次数大于0,就直接把它弹掉，并且哈系表中它对应的映射值减一。

就这样可以快很多。

堆我用的是stl的优先队列，哈希表用的是pbds的gp_hash_table。

我试了试发现pbds里也有优先队列，跑的快一些。但是，，，没有本质上快很多，所以就懒得改了。。。

BZOJ上可以直接过，6s

luogu上的话时间严格些，需要开O2才能过

谁叫我写的暴力呢QvQ

代码：
```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>

#define NS (1005)

using namespace std;
using namespace __gnu_pbds;

template <typename _Tp> inline void IN(_Tp& dig)
{
	char c; bool flag = 0; dig = 0;
	while (c = getchar(), !isdigit(c));
	while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
}

int A, B, n, mp[NS][NS], ans = INT_MAX, mx[NS][NS], mn[NS][NS];

cc_hash_table<int,int> hmx, hmn;

priority_queue<int> qmx;

priority_queue<int, vector<int>, greater<int> > qmn;

int main (int argc, char const* argv[])
{
	IN(A), IN(B), IN(n);
	for (int i = 1; i <= A; i += 1)
		for (int j = 1; j <= B; j += 1)
			IN(mp[i][j]);
	for (int i = 1; i <= A; i += 1)
	{
		while (!qmx.empty()) qmx.pop();
		while (!qmn.empty()) qmn.pop();
		hmx.clear(), hmn.clear();
		for (int j = 1; j <= n; j += 1) qmx.push(mp[i][j]), qmn.push(mp[i][j]);
		for (int j = 1; j + n - 1 <= B; j += 1)
		{
			while (hmx[qmx.top()] > 0) hmx[qmx.top()]--, qmx.pop();
			while (hmn[qmn.top()] > 0) hmn[qmn.top()]--, qmn.pop();
			mx[i][j] = qmx.top(), mn[i][j] = qmn.top();
			qmx.push(mp[i][j + n]), hmx[mp[i][j]]++;
			qmn.push(mp[i][j + n]), hmn[mp[i][j]]++;
		}
	}
	for (int i = 1; i + n - 1 <= B; i += 1)
	{
		while (!qmx.empty()) qmx.pop();
		while (!qmn.empty()) qmn.pop();
		hmx.clear(), hmn.clear();
		for (int j = 1; j <= n; j += 1) qmx.push(mx[j][i]), qmn.push(mn[j][i]);
		for (int j = 1; j + n - 1 <= A; j += 1)
		{
			while (hmx[qmx.top()] > 0) hmx[qmx.top()]--, qmx.pop();
			while (hmn[qmn.top()] > 0) hmn[qmn.top()]--, qmn.pop();
			ans = min(ans, qmx.top() - qmn.top());
			qmx.push(mx[j + n][i]), hmx[mx[j][i]]++;
			qmn.push(mn[j + n][i]), hmn[mn[j][i]]++;
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

# Update
突然发现自己制杖了

明明可以用单调队列替换掉优先队列的

QvQ

这样复杂度就是$O(AB)$的了

代码：
```cpp
#include <bits/stdc++.h>

#define NS (1005)

using namespace std;

template <typename _Tp> inline void IN(_Tp& dig)
{
	char c; bool flag = 0; dig = 0;
	while (c = getchar(), !isdigit(c));
	while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
}

int A, B, n, mp[NS][NS], ans = INT_MAX, mx[NS][NS], mn[NS][NS];

struct N
{
	int d, t;
	bool operator < (N a) const {return d < a.d;}
	bool operator > (N a) const {return d > a.d;}
};

template <typename _Tp, typename _Cmp = less<_Tp> > struct que
{
	_Tp d[NS]; int head, tail; _Cmp cmp;
	void init(){head = tail = 1;}
	void push(_Tp a)
	{
		while (head < tail && cmp(a, d[tail - 1])) tail--;
		d[tail++] = a;
	}
	_Tp top(){return d[head];}
	void pop(){head++;}
};

que <N, greater<N> > qmx;
que <N, less<N> > qmn;

int main (int argc, char const* argv[])
{
	IN(A), IN(B), IN(n);
	for (int i = 1; i <= A; i += 1)
		for (int j = 1; j <= B; j += 1)
			IN(mp[i][j]);
	for (int i = 1; i <= A; i += 1)
	{
		qmx.init(), qmn.init();
		for (int j = 1; j <= n; j += 1)
			qmx.push((N){mp[i][j], j}), qmn.push((N){mp[i][j], j});
		for (int j = 1; j + n -1 <= B; j += 1)
		{
			while (qmx.top().t < j) qmx.pop();
			while (qmn.top().t < j) qmn.pop();
			mx[i][j] = qmx.top().d, mn[i][j] = qmn.top().d;
			qmx.push((N){mp[i][j + n], j + n});
			qmn.push((N){mp[i][j + n], j + n});
		}
	}
	for (int i = 1; i + n - 1 <= B; i += 1)
	{
		qmx.init(), qmn.init();
		for (int j = 1; j <= n; j += 1)
			qmx.push((N){mx[j][i], j}), qmn.push((N){mn[j][i], j});
		for (int j = 1; j + n - 1 <= A; j += 1)
		{
			while (qmx.top().t < j) qmx.pop();
			while (qmn.top().t < j) qmn.pop();
			ans = min(ans, qmx.top().d - qmn.top().d);
			qmx.push((N){mx[j + n][i], j + n});
			qmn.push((N){mn[j + n][i], j + n});
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：破壁人 (赞：0)

这道题目其实就是一道用ST表解RMQ问题的模板。

对每一行都求解一次RMQ存在三位数组a[i][j][k]中，其中a[i]表示第i行的ST表。

然后我们枚举起始列j,我们把每一行j~j+n-1的最大最小值都存起来。

然后我们对这a个数做一次RMQ，接着枚举起始行i，利用刚才的ST表就可以求出答案了。

时间复杂度O(N^2\*log2(n))。

附上ST表的解法：f[i][j]表示第i个数开始（包括第i个数）2^j个数中的最大值（最小值）。

然后用动态规划的方法求出每一个f[i][j]，转移方程如下：

f[i][j]=max(min)(f[i][j-1],f[i+(1<<(j-1))][j-1]))

求[x,y]区间的最大值（最小值）的时候，直接max(f[x][k],f[y-k+1][k])(k=ceil(log(y-x+1)/log(2)))

当然了pascal跑的比c++快，Pascal选手可以直接用这个方法AC，c++还要优化一下。

注意到n只有100,我们在求ST表的时候不用覆盖到最后，只覆盖到n就够了。

还有发现每次求log函数的时候出现了很多次重复，所以先预处理出来，然后直接调用就可以了。

其实呢，c++加了这两个优化还是会TLE（笑哭），大牛分站比普通的洛谷快，我卡了四次才卡过。










```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
using namespace std;
int a[1001][1001][11],b[1001][1001][11],c[1001][11],d[1001][11],s[1001][1001],two[11];
double xxx;
int fd1(int o,int p,int q)
{
    int yu=(int)(log(q-p+1)/xxx);
    return max(a[o][p][yu],a[o][q-two[yu]+1][yu]);
}
int fd2(int o,int p,int q)
{
    int yu=(int)(log(q-p+1)/xxx);
    return min(b[o][p][yu],b[o][q-two[yu]+1][yu]);
}
int fd3(int p,int q)
{
    int yu=(int)(log(q-p+1)/xxx);
    return max(c[p][yu],c[q-two[yu]+1][yu]);
}
int fd4(int p,int q)
{
    int yu=(int)(log(q-p+1)/xxx);
    return min(d[p][yu],d[q-two[yu]+1][yu]);
}
int main()
{
    xxx=log(2);
    two[0]=1;
    for(int i=1;i<=11;i++) two[i]=two[i-1]*2;
    int n,m,k1;
    cin>>n>>m>>k1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            s[i][j]=read();
    for(int i=1;i<=n;i++)//枚举每一行
    {
        for(int j=1;j<=m;j++) {a[i][j][0]=s[i][j];b[i][j][0]=s[i][j];}
        for(int j=m;j>=1;j--)
            for(int k=1;k<=(int)(ceil(log(min(m-j+1,k1))/xxx));k++)
            {
                a[i][j][k]=max(a[i][j][k-1],a[i][j+two[k-1]][k-1]);//最大值ST表
                b[i][j][k]=min(b[i][j][k-1],b[i][j+two[k-1]][k-1]);//最小值ST表
            }
    }
    int ans=1000000000;
    for(int i=1;i<=m-k1+1;i++)//枚举起始列
    {
        for(int j=1;j<=n;j++) {c[j][0]=fd1(j,i,i+k1-1);d[j][0]=fd2(j,i,i+k1-1);}
        for(int j=n;j>=1;j--)
            for(int k=1;k<=(int)(ceil(log(min(n-j+1,k1))/xxx));k++)
            {
                c[j][k]=max(c[j][k-1],c[j+two[k-1]][k-1]);
                d[j][k]=min(d[j][k-1],d[j+two[k-1]][k-1]);
```
}//新的ST表
```cpp
        for(int j=1;j<=n-k1+1;j++)
            ans=min(ans,fd3(j,j+k1-1)-fd4(j,j+k1-1));//求值
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：重回巅峰！ (赞：0)

我给个与楼下不同的解题方法

二维RMQ。枚举矩阵的左上点的坐标I，J，于是可以得到矩阵右下点坐标为（I+LEN-1， J+LEN-1） 。

将矩阵分为四份，取四份的最大值与最小值，由于子问题的重叠性，可以得出解，时间复杂度为O（N\*N）；


```cpp
var
  f1,f2:array[0..1005,0..1005,0..11]of longint;
  n,m,len,i,j,ans,x,k,tot:longint;
  l,r:longint;
  p1,p2,p3,p4:longint;
function max(a,b,c,d:longint):longint;
var o:longint;
begin
  o:=-maxlongint;
  if a>o then o:=a;
  if b>o then o:=b;
  if c>o then o:=c;
  if d>o then o:=d;
  exit(o);
end;
function min(a,b,c,d:longint):longint;
var o:longint;
begin
  o:=maxlongint;
  if a<o then o:=a;
  if b<o then o:=b;
  if c<o then o:=c;
  if d<o then o:=d;
  exit(o);
end;
begin
  readln(n,m,len);
  for i:=1 to n do
    for j:=1 to m do
    begin
      read(f1[i,j][0]);
      f2[i,j][0]:=f1[i,j][0];
    end;
  if n>m then x:=n else x:=m;
  for k:=1 to trunc(ln(x)/ln(2)) do
  for i:=1 to n-1 shl k+1 do
    for j:=1 to m-1 shl k+1 do
    begin
      f1[i,j][k]:=max(f1[i,j][k-1],
                      f1[i+1 shl (k-1),j][k-1],
                      f1[i,j+1 shl (k-1)][k-1],
                      f1[i+1 shl (k-1),j+1 shl (k-1)][k-1]);
      f2[i,j][k]:=min(f2[i,j][k-1],
                      f2[i+1 shl (k-1),j][k-1],
                      f2[i,j+1 shl (k-1)][k-1],
                      f2[i+1 shl (k-1),j+1 shl (k-1)][k-1]);
    end;
  tot:=maxlongint;
  for i:=1 to n-len+1 do
   for j:=1 to m-len+1 do
   begin
     l:=i+len-1; r:=j+len-1;
     k:=trunc(ln(len)/ln(2));
     p1:=f1[i,j][k];
     p2:=f1[L-1 shl k+1,j][k];
     p3:=f1[L-1 shl k+1,R-1 shl k+1][k];
     p4:=f1[i,R-1 shl k+1][k];
     ans:=max(p1,p2,p3,p4);
     p1:=f2[i,j][k];
     p2:=f2[L-1 shl k+1,j][k];
     p3:=f2[L-1 shl k+1,R-1 shl k+1][k];
     p4:=f2[i,R-1 shl k+1][k];
     ans:=ans-min(p1,p2,p3,p4);
     if ans<tot then tot:=ans;
   end;
   writeln(tot);
end.

```

---


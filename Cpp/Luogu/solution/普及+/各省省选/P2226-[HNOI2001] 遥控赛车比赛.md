# [HNOI2001] 遥控赛车比赛

## 题目描述

全国遥控赛车大赛近日在星沙举行。竞赛选用一块大小为 $N\times M$ 的场地作为竞赛场地，要求选手的赛车在最短的时间内从起点移动到终点。虽然赛场地形高低有少许的起伏，但并不存在无法到达的地点。但是在赛场上增加了许多无法穿越的障碍物，若赛车在到达终点前撞上障碍物，就视为任务失败。

在赛车的马力和灵活性等性能相差较小的情况下，要控制速度极快的赛车绕开障碍物移动到终点，关键是提高选手的反应灵敏度，即两次改变赛车运动方向所间隔的最短时间，也可称为选手的反应时间。使自己能够更快地控制赛车改变前进的方向。

当然，由于选手反应灵敏度的不同，可选择的路径就会大不相同。如图 $1$ 和图 $2$ 所示，对于同一个赛场，两位选手的反应时间分别为 $2$ 秒和 $1$ 秒，而其到达终点所需的时间分别为 $18$ 秒和 $16$ 秒（赛车每秒可沿当前方向移动一格，从起点出发时算改变一次方向）。

由图 $1$ 和图 $2$ 可知，赛车的最短路线长度是由选手的反应灵敏度所决定的，当选手的反应很慢时，可能就不会存在可行的路径。你的任务是：在能够完成赛程（即存在从起点到终点的路径）的条件下，求出选手每个可能的反应时间所对应的最短路线长度。

![](https://cdn.luogu.com.cn/upload/pic/1294.png)


## 样例 #1

### 输入

```
10 10                                   
1 4 10 7                                 
0 0 0 1 0 0 0 0 0 0
0 0 0 1 1 1 0 0 0 0
0 0 0 1 0 1 0 0 0 0
1 1 1 1 0 1 1 1 1 0
1 0 0 0 0 0 0 0 1 0
1 0 1 1 1 0 1 1 1 0
1 1 1 0 1 1 1 0 1 0
0 0 1 0 0 0 0 0 1 0
0 0 1 1 1 1 1 1 1 0
0 0 0 0 0 0 1 0 0 0
```

### 输出

```
1 16
2 18
```

# 题解

## 作者：CYJian (赞：15)

(哇一道~~大水题~~没有人发题解)

这道题。。。

怎么说呢

实际上很简单，就和直接看上去一样，相信大家都会认为这是一道爆搜题。。

所以我索性就打了一个DFS。。

(代码略丑，不喜勿喷)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int fx[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
const int N = 100;

int n;
int m;
int Fx;
int Fy;
int Tx;
int Ty;
int res;
int s[N + 1][N + 1];
int rem[2][N + 1][N + 1];

bool remem(int x, int y, int tot, int k) {
    if(tot > rem[0][x][y]) return 1;
    else if(tot < rem[0][x][y]) return 0;
    else return k <= rem[1][x][y];
}

void dfs(int x, int y, int k, int maxn, int tot, int la) {
    if(!s[x][y] || x < 1 || y < 1 || x > n || y > m || remem(x, y, tot, k)) return;
    rem[0][x][y] = tot;
    rem[1][x][y] = k;
    if(x == Tx && y == Ty) {
        if(res < 0) res = tot;
        else res = min(res, tot);
        return;
    }
    for(int i = 0; i < 4; i++)
        if(i != la) {
            if(k == maxn)
                dfs(x + fx[i][0], y + fx[i][1], 1, maxn, tot + 1, i);
        }
        else dfs(x + fx[i][0], y + fx[i][1], min(k + 1, maxn), maxn, tot + 1, i);
}

int main() {
    scanf("%d%d%d%d%d%d", &n, &m, &Fx, &Fy, &Tx, &Ty);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            scanf("%d", &s[i][j]);
    for(int i = 1; i <= 10; i++) {
        res = -1;
        memset(rem[0], 127, sizeof(rem[0]));
        memset(rem[1], 0, sizeof(rem[1]));
        dfs(Fx, Fy, i, i, 0, -1);
        if(res == -1) break;
        printf("%d %d\n", i, res);
    }
    return 0;
}
```

就像这样。。

然后30分，WA与TLE并存。。。

不明所以的我认为是DFS的锅，然后改了一个BFS。。

再贴一波：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int fx[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
const int N = 100;

int n;
int m;
int Fx;
int Fy;
int Tx;
int Ty;
int res;
int s[N + 1][N + 1];
int f[N + 1][N + 1][4];
int dis[N + 1][N + 1][4];

struct Node {
    int x;
    int y;
    int z;
};

void print() {/*
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++)
            printf("%-3d ", dis[i][j]);
        puts("");
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++)
            printf("%-3d ", f[i][j]);
        puts("");
    }*/
}

void BFS(int k) {
    queue<Node>q;
    while(!q.empty()) q.pop();
    q.push((Node){Fx, Fy, 0});
    q.push((Node){Fx, Fy, 1});
    q.push((Node){Fx, Fy, 2});
    q.push((Node){Fx, Fy, 3});
    f[Fx][Fy][0] = 0;
    f[Fx][Fy][1] = 0;
    f[Fx][Fy][2] = 0;
    f[Fx][Fy][3] = 0;
    while(!q.empty()) {
        Node now = q.front();
        q.pop();
        for(int i = 0; i < 4; i++) {
            int x = now.x + fx[i][0];
            int y = now.y + fx[i][1];
            if(x > n || y > m || x < 1 || y < 1) continue;
            if(dis[x][y][i] || !s[x][y] || (x == Fx && y == Fy)) continue;
            if(i == now.z)
                f[x][y][i] = min(k, f[now.x][now.y][now.z] + 1);
            else {
                if(f[now.x][now.y][now.z] != k) continue;
                f[x][y][i] = 1;
            }
            q.push((Node){x, y, i});
            dis[x][y][i] = dis[now.x][now.y][now.z] + 1;
            if(x == Tx && y == Ty) {
                res = dis[x][y][i];
                return ;
            }
        }
    }
}

int main() {
    scanf("%d%d%d%d%d%d", &n, &m, &Fx, &Fy, &Tx, &Ty);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            scanf("%d", &s[i][j]);
    for(int i = 1; i <= 10; i++) {
        res = -1;
        memset(f, 0, sizeof(f));
        memset(dis, 0, sizeof(dis));
        BFS(i);
        print();
        if(res == -1) break;
        printf("%d %d\n", i, res);
    }
    return 0;
}
```

结果还是40分。。。

真是可怕。。。

但是至少没有TLE了。。

然后我就一直找啊找，发现了一个灵异事件：

之前你可能有一个弯绕不过去，

但是有可能你从别的地方绕一下再来这个点的时候就可以过了

上样例：
```
input：
10 5
4 2 10 3
1 1 1 1 1
0 1 0 0 1
0 1 0 1 1
1 1 0 1 1 
0 1 1 1 1
1 1 1 1 0
1 1 1 1 1
0 0 1 0 1
0 0 1 0 1
0 0 1 0 1

output：
7
11
```

你的代码是不是输出：
```
7
17
```

这就是我要说的了

实际上它是这么搞的：

![图解](https://cdn.luogu.com.cn/upload/pic/16778.png)

来回走很骚对吧。。

但是并不需要担心复杂度

中间只需要加上一个判断就好

代码中会有提到：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int fx[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
const int N = 100;

int n;
int m;
int Fx;
int Fy;
int Tx;
int Ty;
int res;
int s[N + 1][N + 1];
int f[N + 1][N + 1][4];
int dis[N + 1][N + 1][4];

struct Node {
	int x;
	int y;
	int z;
};

void print() {/*
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++)
			printf("%-3d ", dis[i][j]);
		puts("");
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++)
			printf("%-3d ", f[i][j]);
		puts("");
	}*/
}

void BFS(int k) {
	queue<Node>q;
	while(!q.empty()) q.pop();
	q.push((Node){Fx, Fy, 0});
	q.push((Node){Fx, Fy, 1});
	q.push((Node){Fx, Fy, 2});
	q.push((Node){Fx, Fy, 3});
	f[Fx][Fy][0] = 0;
	f[Fx][Fy][1] = 0;
	f[Fx][Fy][2] = 0;
	f[Fx][Fy][3] = 0;//0、1、2、3表示从哪个方向来的，f记录连续走了多少步
	while(!q.empty()) {
		Node now = q.front();
		q.pop();
		for(int i = 0; i < 4; i++) {
			int x = now.x + fx[i][0];
			int y = now.y + fx[i][1];
			if(x > n || y > m || x < 1 || y < 1) continue;
			if(!s[x][y] || (x == Fx && y == Fy)) continue;
			int a;
			if(i == now.z)
				a = min(k, f[now.x][now.y][now.z] + 1);
			else {
				if(f[now.x][now.y][now.z] != k) continue;
				a = 1;
			}
			if(dis[x][y][i] && a <= f[x][y][i]) continue;
            //之前提到的就是这里了
            //这里是说如果之前到过并且连续走的步数比之前记录的少就放弃
			f[x][y][i] = a;
			q.push((Node){x, y, i});
			dis[x][y][i] = dis[now.x][now.y][now.z] + 1;
			if(x == Tx && y == Ty) {
				res = dis[x][y][i];
				return ;
			}
		}
	}
}

int main() {
	scanf("%d%d%d%d%d%d", &n, &m, &Fx, &Fy, &Tx, &Ty);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			scanf("%d", &s[i][j]);
	for(int i = 1; i <= 10; i++) {
		res = -1;
		memset(f, 0, sizeof(f));
		memset(dis, 0, sizeof(dis));
		BFS(i);
		print();
		if(res == -1) break;
		printf("%d %d\n", i, res);
	}
	return 0;
}
```

嗯，这样就可以AC了

---

## 作者：Huami360 (赞：6)

~~博客食用效果更佳~~

[Blog](https://www.cnblogs.com/Qihoo360/p/11019262.html)

现有题解都是$dfs$或$bfs$。其实这题正解应该是最短路。

首先拆点，把每个点拆成4个点，表示到达这个点的时候赛车的朝向。

然后考虑连边。

相邻同向并且都是可以走的点直接连边权1的边。

至于怎么转向，只需在每个点$i$向每个方向一直拓展直到不能走为止，如果当前点的深度大于灵敏度，从$i$向这个点的其它3个方向都连一条边权为这个点的深度的边。

然后跑$SPFA$（至于为什么是$SPFA$，~~我才不会告诉你是博主懒~~），这样你可以获得$90pts$。

为什么？因为我们最多要跑$10$次，而每次连边的时间复杂度都是$O(n^3)$级别的，加上要跑$SPFA$，很容易超时。

所以考虑一个优化，显然每次连边有很多重复的地方，因为灵敏度为$2$的情况肯定也把灵敏度为$3$的情况的所有边都连了。

所以我们不妨反过来跑，灵敏度从$10$到$1$，每次只连长度刚好为灵敏度的转向边，用栈记录一下答案就行了。

其实代码还有很多可以优化的地方，但效率已经足够吊打多数搜索了。

$90pts$：
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <iostream>
#define Open(s) freopen(s".in","r",stdin); freopen(s".out","w",stdout);
#define Close fclose(stdin); fclose(stdout);
#define O(x) cout << #x << "=" << x << endl;
using namespace std;
const int MAXN = 10010 << 2;
const int MAXM = 5000000;
struct Edge{
    int next, to, dis;
}e[MAXM << 1];
int head[MAXN], num, dis[MAXN], vis[MAXN], a[110][110];
inline void Add(int u, int v, int dis){
    e[++num] = (Edge){ head[u], v, dis }; head[u] = num;
}
int n, m, N, l[] = { -1, 1, 0, 0 }, r[] = { 0, 0, -1, 1 }, sx, sy, px, py;
inline int id(int x, int y, int direct){
    return direct * N + (x - 1) * m + y;
}
queue <int> q;
int work(int check){
    num = 0; memset(head, 0, sizeof head);
    memset(dis, 127, sizeof dis);
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j){
            if(!a[i][j]) continue;
            for(int k = 0; k < 4; ++k){
                int x = i + l[k], y = j + r[k];
                if(!a[x][y]) continue;
                Add(id(i, j, k), id(x, y, k), 1);
                for(int o = 1; a[x][y]; x += l[k], y += r[k], ++o) //向这个方向不断拓展
                    if(o >= check)  //灵敏度足够的话
                        for(int l = 0; l < 4; ++l)  //向其他3个方向连边
                            if(l != k)
                                Add(id(i, j, k), id(x, y, l), o);
            }
        }
    dis[id(sx, sy, 0)] = dis[id(sx, sy, 1)] = dis[id(sx, sy, 2)] = dis[id(sx, sy, 3)] = 0;
    vis[id(sx, sy, 0)] = vis[id(sx, sy, 1)] = vis[id(sx, sy, 2)] = vis[id(sx, sy, 3)] = 1;
    q.push(id(sx, sy, 0)); q.push(id(sx, sy, 1)); q.push(id(sx, sy, 2)); q.push(id(sx, sy, 3));
    while(q.size()){
        int u = q.front(); q.pop();
        vis[u] = 0;
        for(int i = head[u]; i; i = e[i].next)
            if(dis[e[i].to] > dis[u] + e[i].dis){
                dis[e[i].to] = dis[u] + e[i].dis;
                if(!vis[e[i].to]){
                    vis[e[i].to] = 1;
                    q.push(e[i].to);
                }
            }
    }
    int ans = min(min(dis[id(px, py, 0)], dis[id(px, py, 1)]), min(dis[id(px, py, 2)], dis[id(px, py, 3)]));
    if(ans < 10000000) return printf("%d %d\n", check, ans), 0;
    else return 1;
}
int main(){
    scanf("%d%d%d%d%d%d", &n, &m, &sx, &sy, &px, &py); N = n * m;
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j)
            scanf("%d", &a[i][j]);
    for(int i = 1; i <= 10; ++i)
        if(work(i))
            break;
    return 0;
}
```

$100pts$
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <iostream>
#define Open(s) freopen(s".in","r",stdin); freopen(s".out","w",stdout);
#define Close fclose(stdin); fclose(stdout);
#define O(x) cout << #x << "=" << x << endl;
using namespace std;
const int MAXN = 10010 << 2;
const int MAXM = 5000000;
struct Edge{
    int next, to, dis;
}e[MAXM << 1];
int head[MAXN], num, dis[MAXN], vis[MAXN], a[110][110], s[12], top;
inline void Add(int u, int v, int dis){
    e[++num] = (Edge){ head[u], v, dis }; head[u] = num;
}
int n, m, N, l[] = { -1, 1, 0, 0 }, r[] = { 0, 0, -1, 1 }, sx, sy, px, py;
inline int id(int x, int y, int direct){
    return direct * N + (x - 1) * m + y;
}
queue <int> q;
void work(int check){
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j){
            if(!a[i][j]) continue;
            for(int k = 0; k < 4; ++k){
                for(int p = 1, x = i + l[k], y = j + r[k]; a[x][y]; ++p, x += l[k], y += r[k])
                    if(p == check){
                        for(int l = 0; l < 4; ++l)
                            if(l != k)
                                Add(id(i, j, k), id(x, y, l), check);
                        break;
                    }
            }
        }
    memset(dis, 127, sizeof dis);
    dis[id(sx, sy, 0)] = dis[id(sx, sy, 1)] = dis[id(sx, sy, 2)] = dis[id(sx, sy, 3)] = 0;
    vis[id(sx, sy, 0)] = vis[id(sx, sy, 1)] = vis[id(sx, sy, 2)] = vis[id(sx, sy, 3)] = 1;
    q.push(id(sx, sy, 0)); q.push(id(sx, sy, 1)); q.push(id(sx, sy, 2)); q.push(id(sx, sy, 3));
    while(q.size()){
        int u = q.front(); q.pop();
        vis[u] = 0;
        for(int i = head[u]; i; i = e[i].next)
            if(dis[e[i].to] > dis[u] + e[i].dis){
                dis[e[i].to] = dis[u] + e[i].dis;
                if(!vis[e[i].to]){
                    vis[e[i].to] = 1;
                    q.push(e[i].to);
                }
            }
    }
    int ans = min(min(dis[id(px, py, 0)], dis[id(px, py, 1)]), min(dis[id(px, py, 2)], dis[id(px, py, 3)]));
    if(ans < 10000000) s[++top] = ans;
}
int main(){
    scanf("%d%d%d%d%d%d", &n, &m, &sx, &sy, &px, &py); N = n * m;
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j)
            scanf("%d", &a[i][j]);
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j){
            if(!a[i][j]) continue;
            for(int k = 0; k < 4; ++k){
                int x = i + l[k], y = j + r[k];
                if(!a[x][y]) continue;
                Add(id(i, j, k), id(x, y, k), 1);
            }
        }
    for(int i = 10; i; --i)
        work(i);
    for(int Top = top, i = 1; i <= Top; ++i)
        printf("%d %d\n", i, s[top--]);
    return 0;
}

```

---

## 作者：George1123 (赞：5)

# 题解-[HNOI2001]遥控赛车比赛

前置知识：记忆化搜索、$\texttt{Bfs}$。

**参考资料**
> https://www.luogu.com.cn/blog/CYJian/solution-p2226

**[博客中阅读(这是我博客园第一篇题解)](https://www.cnblogs.com/Wendigo/p/12438906.html)**

---

## $\texttt{Introduction}$
蒟蒻练习历年省选题时遇见此题，$\texttt{WA}$ 了好多发才 $\texttt{AC}$，感到这题的巧妙足以记成题解。

---
## $\texttt{Description}$
> [\[HNOI2001\]遥控赛车比赛](https://www.luogu.com.cn/problem/P2226)

> 给你一个由 $0$ 和 $1$ 组成的 $N\times M$ 地图，$1$ 可走，$0$ 是障碍。如果你反应力为 $z$，那么你每次至少直走 $z$ 步后才能转弯。起点为 $(sx,sy)$，终点为 $(tx,ty)$。求反应力为 $1\sim 10$ 时的最短路（如果到不了终点不输出，具体看题目链接）。

> 数据范围：$1\le N,M\le 100$。

---
## $\texttt{Solution}$

这题是什么意思呢？如下图：

![](https://cdn.luogu.com.cn/upload/pic/1294.png)

起点为 $(1,4)$，终点为 $(10,7)$。

如果反应力为 $1$，即走一步可以转个方向，那么最短路方案如图 $2$，长度为 $16$。

如果反应力为 $2$，即每直走两步可以换个方向，那么最短路方案如图 $1$，长度为 $18$。

---

貌似很简单，做法很直接：$\texttt{Bfs}$，记忆化搜索。

因为方向在这题中很重要，所以**记录数组 $dep_{i,j,k}$ 和 $f_{i,j,k}$ 表示走到 $(i,j)$ 这个格子方向为 $k$ 时在最短路条件下的路程和当前方向上直走了的距离（四个方向用 $0,1,2,3$ 表示）**。

然后每次 $\texttt{Bfs}$ 拓展下一步路径的时候，特判一下，如果方向与 $k$ 不同，那么必须满足 $f_{i,j,k}\ge z$。

**看起来这题就只有普及的复杂度，但是如果你把代码敲出来一交，最多得个 $50$ 分**。

---

你会自闭很久直到找到反例——一个更令你自闭的东西：

**路重复走，转 $180^{\circ}$ 反而可能更优**。

如下图：

![2226.jpg](https://i.loli.net/2020/03/07/cldLbNzDZOiYEIC.jpg)

图 $1$ 中的地图如果用你的代码只能跑反应力为 $1$。但是这种路径反应力为 $2$ 可以跑！

同理，图 $2$ 中如果走这种路重复走，转 $180^{\circ}$ 的路径，长度可以减至 $10$（虚线路径为原计划路径，长度远大于 $10$）。

那么题目貌似会变得很混乱：**走过的地方也可以走，同一个位置更长的路径可能更优**。

然而仔细思考后会发现，只有两种情况同一个位置的路径会更优：

1. 更短。

2. 当前方向上直走得更长。

**其中第二种更优只能在继续直走中体现**（如果转弯之前直走了多长没关系）。

然后敲个带个特判的记忆化广搜即可（普及知识不多说，特判会在代码中标识）。

---
## $\texttt{Code}$


```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
#define lit long double
#define kk(i,n) "\n "[i<n]
const int inf=0x3f3f3f3f;
const lng Inf=1e17;

//&Debug
int open(0);
#define Debug if(open)

//&Data
const int N=110;
int n,m,maze[N][N],fx[4]={0,0,-1,1},fy[4]={-1,1,0,0};
struct Marco{int x,y,k;}s,t; //Bfs 状态

//&Bfs
const int Q=5e6+10;
int dep[N][N][4],f[N][N][4],ql,qr;
Marco q[Q];
int ok(int x,int y){return x>=1&&x<=n&&y>=1&&y<=m&&maze[x][y];}
int bfs(int z){
	Debug printf("---%d---\n",z);//###
	if(!ok(s.x,s.y)||!ok(t.x,t.y)) return -1;
	memset(dep,0x3f,sizeof dep),memset(f,0,sizeof f);
	int *D=dep[s.x][s.y],*F=f[s.x][s.y]; Marco tp;
	D[0]=D[1]=D[2]=D[3]=F[0]=F[1]=F[2]=F[3]=0;//初始化起点
	ql=1,qr=0,q[++qr]=(s.k=0,s),q[++qr]=(s.k=1,s),q[++qr]=(s.k=2,s),q[++qr]=(s.k=3,s);//起点可以是任意方向
	while(qr>=ql){ //手模队列
		tp=q[ql++];
		Debug printf("%d %d %d\n",tp.x,tp.y,tp.k);//###
		D=dep[tp.x][tp.y],F=f[tp.x][tp.y];
		if(tp.x==t.x&&tp.y==t.y) return D[tp.k];//找到出口了！
		for(int k=0;k<4;k++){
			int xt=tp.x+fx[k],yt=tp.y+fy[k];
			if(ok(xt,yt)&&(D[tp.k]+1<dep[xt][yt][k]||F[tp.k]>=f[xt][yt][k])){//特判：两种更优
				if(k==tp.k){
					dep[xt][yt][k]=D[tp.k]+1;//普通Bfs拓展
					f[xt][yt][k]=F[tp.k]+1;
					q[++qr]=(Marco){xt,yt,k};
				} else if(F[tp.k]>=z&&D[tp.k]+1<dep[xt][yt][k]){//特判：要转弯即使直走得更长也没用
					dep[xt][yt][k]=D[tp.k]+1;
					f[xt][yt][k]=1;
					q[++qr]=(Marco){xt,yt,k};
				}
			}
		}
	}
	return -1;//被困住了，到不了出口
}


//&Main
int main(){
	scanf("%d%d",&n,&m);
	scanf("%d%d%d%d",&s.x,&s.y,&t.x,&t.y);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",maze[i]+j);
	for(int i=1,tp;i<=10;i++)
		if((tp=bfs(i))!=-1) printf("%d %d\n",i,tp);
		else break; 
	return 0;
}
```
---

我还是太蒻了。**祝大家学习愉快！**


---

## 作者：ECEG (赞：4)

# P2226 [HNOI2001]遥控赛车比赛题解

## 分析

因为 $1\le N,M\le100$，所以可以用 bfs。

## 思路

这道题和其他 bfs 题不一样的是多了一个**反应值**，所以我们可以用一个 $f_{i,j,k}$，表示在 $(i,j)$ 面向 $k$ **距上次转弯的时间**，如果**比反应值大**，那么可以转弯。

但是，有一种情况，一个点**走两次**，但第二次的距上次转弯的时间**要长一些**，刚好可以转弯，如：

![](https://cdn.luogu.com.cn/upload/pic/16778.png)

（图片来自第一篇题解）

所以一个点**可以走多次**，但距上次转弯的时间**要短一些**，否则不行。

## AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int x,y,val,jk;
};
int n,m,x,y,xjk,yjk,mp[104][104],ans,vis[104][104][5],f[104][104][5];
/*
1:下
2:右
3:上
4:左 
*/
int dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};
void bfs(int gh){
	queue<node> q;
	q.push((node){x,y,0,0});
	while(q.size()){
		node u=q.front();q.pop();
		if(u.x==xjk&&u.y==yjk){
			ans=u.val;
			return ;
		}
		for(int i=1;i<=4;++i){
			int xx=u.x+dx[i],yy=u.y+dy[i];
			if(mp[xx][yy]){
				int a;//距上次转弯的时间 
				if((i==u.jk||u.jk==0))//不转弯 
					a=f[u.x][u.y][u.jk]+1;
				else if(f[u.x][u.y][u.jk]>=gh)//转弯 
					a=1;
				else continue;
				if(vis[xx][yy][i]&&a<=f[xx][yy][i])continue;//距上次转弯的时间要短一些
				f[xx][yy][i]=a;vis[xx][yy][i]=1;
				q.push((node){xx,yy,u.val+1,i});
			}
		}
	}
}
int main(){
	cin>>n>>m>>x>>y>>xjk>>yjk;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			cin>>mp[i][j];
	for(int i=1;i<=10;++i){
		memset(vis,0,sizeof(vis));//记得初始
		ans=-1;
		bfs(i);
		if(ans==-1)break;
		else cout<<i<<" "<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：AubRain (赞：3)

$bfs$ 模板题，适合接触过 $bfs$ 并且有一定功底的同学。与网络流没有任何关系（至少这篇题解没用）。

**设计状态:**

1、要知道当前在哪个位置，所以要把坐标记录下来。

2、要知道能不能拐弯，所以要把拐弯的冷却时间记下来。

3、要知道当前车的朝向，以便确定拐弯的代价，所以要把朝向记录下来。

然后开始 $bfs$ 就行了。细节不多，很好写。

可以跑最短路(SPFA)，本质相同。

代码也很短很简洁。

时空复杂度：$O(nm*10*4*10)=O(nm)$

```cpp
#include<bits/stdc++.h>
#define N 105
using namespace std;

int n,m,ok=1;
int fx,fy,ex,ey;
int mx[]={1,-1,0,0};
int my[]={0,0,1,-1};
int a[N][N],f[N][N][11][4];

void work(int lim){
	memset(f,0,sizeof f);ok=0;
	queue<int> qx,qy,qt,q;f[fx][fy][lim-1][0]=1;
	qx.push(fx);qy.push(fy);qt.push(lim-1);q.push(-1);
	while(!qx.empty()){
		int x=qx.front();qx.pop();
		int y=qy.front();qy.pop();
		int t=qt.front();qt.pop();
		int now=q.front();q.pop();
		if(x==ex and y==ey)
			return printf("%d %d\n",lim,f[x][y][t][now]),ok=1,void();		
		for(int i=0;i<4;i++) if(((x==fx and y==fy) or i==now) or !t){
			int tx=x+mx[i],ty=y+my[i];
			int nt=i==now ? max(0,t-1) : lim-1;
			if(!a[tx][ty]||tx>n||ty>m||tx<1||ty<1||f[tx][ty][nt][i]) continue;
			f[tx][ty][nt][i]=f[x][y][t][now]+1;qx.push(tx);qy.push(ty);qt.push(nt);q.push(i);
		}
	}
} 
signed main(){
	cin>>n>>m>>fx>>fy>>ex>>ey;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) cin>>a[i][j];
	for(int i=1;i<=10 and ok;i++) work(i);
}
```

---

## 作者：船酱魔王 (赞：2)

# P2226 [HNOI2001] 遥控赛车比赛 题解

## 题意回顾

$ N \times M $ 带障碍地图，你的赛车可以由一个格子走到四个相邻位置消耗 $ 1 $ 秒，每时每刻不能不走，两次改变方向（从起点出发视为改变方向）的时间点至少相差 $ dt $ 秒，请对于 $ 1 \le dt \le 10 $ 求出所有 $ dt $ 的由给定起点走到给定终点的最短时间。

$ 1 \le N,M \le 100 $。

## 分析

对于每个 $ dt $ 分别求解，$ dt=1 $ 时朴素走迷宫问题容易解决，考虑刻画 $ dt>1 $ 时的搜索状态：坐标用于判断赛车目前位置，需要记录目前方向以判断这次转移是否进行了转弯，需要记录离上次转弯的时间。

状态是 $ O(n^3) $ 量级的，模拟赛给了 0.2s 的时间且评测机很慢，怎么办？考虑离上次转弯 $ 10 $ 秒以上和 $ 10 $ 秒毫无区别，因为都是可以自由转弯的，故时间一维大小压到 $ 10 $，状态大概是 $ O(n^2dt) $ 量级的，大概有 $ 4 \times 10^5 $ 的状态总数。

考虑沿这个方向往前走一格消耗 $ 1 $ 秒时间或转向消耗 $ 0 $ 秒时间，一个套路是使用双端队列进行 0-1 BFS，这样保证队列从前到后时间越来越靠后，时间复杂度与状态数同阶。

注意不要打反 $ n,m $，还有如果使用朴素 BFS 而非 0-1 BFS 可以通过样例并通过本题（在代码中体现为所有 `deque` 写成 `queue`，所有 `push_front` 操作写成 `push`，即所有状态入队均从队尾进入）。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
const int N = 105;
const int inf = (int)1e9 + 5;
int n, m;
int a[N][N];
int dt = 1;
struct node {
    int x, y;
    int dr, ti;
};
int dis[N][N][4][11];
node make(int xx, int yy, int dd, int tt) {
    node res;
    res.x = xx, res.y = yy, res.dr = dd, res.ti = tt;
    return res;
}
int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
bool judge(int xx, int yy) {
    return 1 <= xx && xx <= n && 1 <= yy && yy <= m && a[xx][yy] == 1;
}
deque<node> que;
int main() {
    scanf("%d%d", &n, &m);
    int xa, ya, xb, yb;
    scanf("%d%d%d%d", &xa, &ya, &xb, &yb);
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) scanf("%d", &a[i][j]);
    }
    for(; dt <= 10; dt++) {
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                for(int k = 0; k < 4; k++) {
                    for(int tt = 0; tt <= dt; tt++) dis[i][j][k][tt] = inf;
                }
            }
        }
        while(!que.empty()) que.pop_back();
        for(int k = 0; k < 4; k++) que.push_back(make(xa, ya, k, 0)), dis[xa][ya][k][0] = 0;
        while(!que.empty()) {
            node now = que.front();
            que.pop_front();
            int tx, ty;
            tx = now.x + dir[now.dr][0];
            ty = now.y + dir[now.dr][1];
            if(judge(tx, ty)) {
                int nd = min(now.ti + 1, dt);
                if(dis[now.x][now.y][now.dr][now.ti] + 1 < dis[tx][ty][now.dr][min(now.ti + 1, dt)]) {
                    dis[tx][ty][now.dr][nd] = dis[now.x][now.y][now.dr][now.ti] + 1;
                    que.push_back(make(tx, ty, now.dr, nd));
                }
            }
            if(now.ti < dt) continue;
            for(int k = 0; k < 4; k++) {
                if(k == now.dr) continue;
                tx = now.x, ty = now.y;
                if(dis[tx][ty][now.dr][dt] < dis[tx][ty][k][0]) {
                    dis[tx][ty][k][0] = dis[tx][ty][now.dr][dt];
                    que.push_front(make(tx, ty, k, 0));
                }
            }
        }
        int ans = inf;
        for(int k = 0; k < 4; k++) {
            for(int tt = 0; tt <= dt; tt++) ans = min(ans, dis[xb][yb][k][tt]);
        }
        if(ans > (int)1e9) break;
        printf("%d %d\n", dt, ans);
    }
    return 0;
}
```

---

## 作者：_EternalRegrets_ (赞：0)

## P2226 题解

### 题意描述
>给定一个赛道，每个人的反映时间 $t$ 定义为其可以在进入一个直行道路之后 $t$ 秒可以改变方向。求对于 $1 \leq t \leq 10$ 的所有整数 $t$，从起点到终点的最短时间。

### Solution:
可见，$n$ 和 $m$ 都非常小。

因此，我们可以考虑~~暴搜大法~~记忆化搜索。

搜索方式类似迪杰，具体见代码。

### Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

struct node{
	int x;
	int y;
	int cnt;
	int face;
};

int n,m,x,y,xx,yy;
int ans;
int a[104][104];
int vis[104][104][5];
int f[104][104][5];

const int dx[]={0,1,-1,0,0};
const int dy[]={0,0,0,1,-1};

void bfs(int react){
	queue <node> q; q.push((node){x,y,0,0});
	
	while(q.size()){
		node p=q.front(); q.pop();
		
		if(p.x==xx && p.y==yy){
			ans=p.cnt;
			return;
		}
		
		for(int i=1;i<=4;i++){
			int nx; nx=p.x+dx[i];
			int ny; ny=p.y+dy[i];
			
			if(a[nx][ny]){
				int t;
				if((i==p.face || p.face==0)){
					t=f[p.x][p.y][p.face]+1;
				}
				else if(f[p.x][p.y][p.face]>=react){
					t=1;
				}
				else{
					continue;
				}
				
				if(vis[nx][ny][i] && t<=f[nx][ny][i]){
					continue;
				}
				
				f[nx][ny][i]=t;
				vis[nx][ny][i]=1;
				
				q.push((node){nx,ny,p.cnt+1,i});
			}
		}
	}
	
	return;
}

signed main(){
	cin>>n>>m>>x>>y>>xx>>yy;
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
			
	for(int i=1;i<=10;i++){
		memset(vis,0,sizeof(vis));
		
		ans=0x3f3f3f3f;
		bfs(i);
		
		if(ans==0x3f3f3f3f){
			break;
		}
		
		cout<<i<<" "<<ans<<endl;
	}
	return 0;
}
```

---


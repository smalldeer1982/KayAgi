# [SCOI2005] 栅栏

## 题目描述


农夫约翰打算建立一个栅栏将他的牧场给围起来，因此他需要一些特定规格的木材。于是农夫约翰到木材店购买木材。可是木材店老板说他这里只剩下少部分大规格的木板了。不过约翰可以购买这些木板，然后切割成他所需要的规格。而且约翰有一把神奇的锯子，用它来锯木板，不会产生任何损失，也就是说长度为 $10$ 的木板可以切成长度为 $8$ 和 $2$ 的两个木板。

你的任务：给你约翰所需要的木板的规格，还有木材店老板能够给出的木材的规格，求约翰最多能够得到多少他所需要的木板。

## 样例 #1

### 输入

```
4
30
40
50
25
10
15
16
17
18
19
20
21
25
24
30
```

### 输出

```
7```

## 样例 #2

### 输入

```
3
20
10
10
9
3
3
3
5
5
7
8
8
9
```

### 输出

```
7```

# 题解

## 作者：Mine_King (赞：152)

在[这里](https://www.luogu.org/blog/yhdhg1395754790/)观看更佳

这题的总体思路是：**二分答案+贪心+dfs验证**
首先，二分答案是不用说的，就看贪心和dfs验证。
如果要使得$John$得到至少$m$个木材，那么当然是选择最短的啦。所以可以提前把$John$需要的木材按规格从小到大排序，这就是贪心。  
然后dfs就是如果能提供的木材有比$John$需要的第$x$根木材的规格大的（或相等的），那么就试试把这根木材中$John$需要的部分卖给他。不过……  
`第一行为整数m(m<= 50)表示木材店老板可以提供多少块木材给约翰。`  
这么大的数，不超时才怪勒！所以我们需要剪枝。有两个剪枝：

1. 可行性剪枝，如果剩余的木材都不够$John$的需要，则return，所以这里需要用到前缀和，还要一个变量存储浪费的木材（即连最短的一根木材都不够）
2. 去重，如果两根木材的规格相同，则可以去重。

有了这两个剪枝，就可以**玄学**地过了这题了！  
上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[55],b[1100];
int w,l,r,mid,tot,sum[1100];//w是多余的木材，tot是总共能提供的木材的量，sum是John需要的木材的前缀和
bool dfs(int x,int l)
{
	if(tot-w<sum[mid]) return 0;//第一个剪枝
	if(x==0) return 1;//x=0表示还需要0根，也就是可以满足条件了，那么返回true
	bool f=0;
	for(int i=l;i<=n;i++)
	 if(a[i]>=b[x])//如果第i根木材可以满足John需要的第x根木材，dfs
	 {
	 	a[i]-=b[x];
	 	if(a[i]<b[1]) w+=a[i];
	 	if(b[x-1]==b[x]) f=dfs(x-1,i);//去重
	 	else f=dfs(x-1,1);
	 	if(a[i]<b[1]) w-=a[i];
	 	a[i]+=b[x];
	 	if(f) return 1;
	 }
	 return 0;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		tot+=a[i];
	}
	cin>>m;
	for(int i=1;i<=m;i++) cin>>b[i];
	sort(b+1,b+m+1);//排序
	for(int i=1;i<=m;i++) sum[i]=sum[i-1]+b[i];//计算前缀和，注意一定要在排序后计算哦！
	while(sum[m]>tot&&m) m--;//如果选最短的m根都超出了能提供的木材的范围，则一定不可行
	l=0,r=m;
	while(l<=r)//二分
	{
		mid=(l+r)/2;
		if(dfs(mid,1)) l=mid+1;
		else r=mid-1;
	}
	cout<<l-1;
	return 0;
}
```
谢谢您看到这里，如果觉得这篇题解能帮到您，请您给我一个赞，谢谢！

---

## 作者：D_14134 (赞：43)

题目大意：现有M根木板，要裁成N个，问最多能裁成几根

### 思路

二分，然后取排序后前mid块进行验证。~~随机能骗不少分。~~(

正解是搜索+剪枝…… 

然后是yy出的一堆优化：



优化1：求前缀去掉无用的木板 

优化2：有序化，从大到小搜索（大的满足条件的少，这样可以减少搜索树上层结点） 

优化3：对于相邻的两块所需要的木板，如果长度相等，那么强制从上一次放的那一块开始枚举，显然这样对答案是没有影响的，可以避免重复运算 

优化4：可行性：对于一块已有的木板，如果其裁掉一部分后剩余部分小于目前需要的最小木板，则剩下的部分浪费。若waste+所需要的木板总长度>提供的木板总长度，方案不可行 

优化5：缩小二分范围卡常。

有用的应该就这些了，还有一个贪心的想法没实现。

# code
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 1010
using namespace std;
int n,m,a[N],b[N],ta[N],s[N],ans,sum,mid,t;
bool check(int last,int x)
{
    if(x<=0)return 1;
    if(sum-t<s[mid])return 0;
    for(int i=last;i<=n;i++)
    {
        if(ta[i]>=b[x])
        {
            ta[i]-=b[x];
            if(ta[i]<b[1])t+=ta[i];
            if(b[x-1]==b[x])
            {
                if(check(i,x-1))return 1;
            }
            else if(check(1,x-1))return 1;
            if(ta[i]<b[1])t-=ta[i];
            ta[i]+=b[x];
        }
    }
    return 0;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),sum+=a[i];
    scanf("%d",&m);
    for(int i=1;i<=m;i++)scanf("%d",&b[i]);
    sort(a+1,a+1+n);
    sort(b+1,b+1+m);
    for(int i=1;i<=m;i++)s[i]=s[i-1]+b[i];
    while(sum<s[m])m--;
    int L=1,R=m;
    while(L<=R)
    {
        for(int i=1;i<=n;i++)ta[i]=a[i];
        t=0;
        mid=(L+R)/2;
        if(check(1,mid))L=mid+1,ans=mid;
        else R=mid-1;
    }
    printf("%d\n",ans);
    return 0;
}
```




---

## 作者：nowayout (赞：33)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int ans,w,a[2000]={0},c[2000]={0},b[2000]={0},m,n,tot,mid,lef,righ;
bool check(int x,int last)//x指现在还需多少木板，last用于第二个剪枝，下面再讲。
{
  int i;
  bool fg;
  if (w>tot-c[mid]) return false;//剪枝一：如果多出的废料木板的总量大于理想中提供的木板减去现在枚举需要的木板（即理想中能够多出的木板）
//，那么接下来肯定没法提供所需木料了，所以返回false。w在下面有写。
  if (x==0) return true;//
  for (i=last;i<=m;++i)//枚举能提供的木板
  if (a[i]>=b[x])//如果这块提供的木板能切出所需的木板，那么就试着切！
  {
    a[i]-=b[x];//切完后剩下的多少木料。
    if (a[i]<b[1]) w+=a[i];//如果剩下的长度小于最小的所需木板，那么它肯定不能再被利用，算作废料。 w记录废料的总长度。
    if (b[x-1]==b[x]) fg=check(x-1,i);
    // 如果下块需要的木板，和现在这块切出的木板一样，那么它提供的木板至少要大于等于目前提供的木板，last即用于记录这个位置，如果两块木板长度一样
//，last就为i，即下次只能从i以后能提供的木板开始枚举。
    else fg=check(x-1,1);
   //否则就从第一块枚举。
    if (a[i]<b[1]) w-=a[i];
    a[i]+=b[x];//回溯，避免对下次造成影响。
    if (fg==true) return true;//如果剩下的都切的出来，那么就成立啦！
  }
  return false;
}
int  main()
{
  cin>>m;
  tot=0;
  for (int i=1;i<=m;++i) {
  cin>>a[i];
  tot+=a[i];
}
  cin>>n;
  c[0]=0;
  for (int i=1;i<=n;++i) cin>>b[i];
  w=0;
  sort(a+1,a+m+1); sort(b+1,b+n+1);
  for (int i=1;i<=n;++i) c[i]=c[i-1]+b[i];//为了以后的剪枝，后面会写。
  while (c[n]>tot) n--;
  lef=0;
  righ=n;
  ans=0;
  while (lef<=righ)//二分枚举是否能切出前m块。
  {
      w=0;
    mid=(lef+righ)/2;
    if (check(mid,1)==true)
    {
      ans=mid;
      lef=mid+1;
     } 
    else righ=mid-1;
  }
  cout<<ans<<endl;
  return 0;
}
```

---

## 作者：星爵 (赞：27)

##  贪心思想+二分答案+dfs判断

- 贪心地想，如果一块**木材**能满足较大的木板，那么较小的**木板**一定能满足，并且能满足的**木板**可能会更多，所以先满足较小的**木板**

- 二分可以满足的最多的**木板**有多少

- dfs判断是否前mid块**木板**是否可行

但是，麻烦来了，TLE怎么办？

何以解T？唯有~~血小板~~剪枝

## 剪枝

1. 把**木板**按长度的大小排序，并记录前缀和与**木材**总数，显然，前缀和是递增的，那么这样，我们可以通过缩小二分范围来达到加速的目的。若所有的**木材**都不能满足某一个**木板**，那么可以将其删去

2. t为浪费，sum为总长度，对于一块**木材**，将其切断一部分满足一些**木板**后，倘若剩余部分连最短的**木板**都无法满足，那么剩余部分一定不能满足任何**木板**，就属于浪费的部分。若**木材**有用的部分（总数-浪费）不能满足前mid个**木板**，那么当前二分的答案不可行

1. 由于是递增的，在dfs过程中，可能会遇到这么一种情况，第i个**木板**与第i-1个**木板**的长度相同，那么考虑，若不能满足第i-1**木板**，那么一定不能满足第i个**木板**，进行剪枝
代码也不长

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int  rd(){
    int x=0,fl=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')fl=-fl;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*fl;
}//快速读
int a[60],fa[60],b[1030],s[1030];
int n,m,sum,t;
bool dfs(int k,int x,int mid){
    if(k<=0)return 1;
    if(sum-t<s[mid])return 0;//剪枝2
    for(int i=x;i<=n;i++)
        if(fa[i]>=b[k]){
            fa[i]-=b[k];
            if(fa[i]<b[1])t+=fa[i];
            if(b[k]==b[k-1]){//剪枝3
                if(dfs(k-1,i,mid))
                    return 1;
            }
            else   
                if(dfs(k-1,1,mid))
                    return 1;
            if(fa[i]<b[1])t-=fa[i];
            fa[i]+=b[k];
        }
    return 0;
}

int main(){
    n=rd();
    for(int i=1;i<=n;i++){
        a[i]=rd();
        sum+=a[i];
    }
    m=rd();
    for(int i=1;i<=m;i++)b[i]=rd();
    sort(b+1,b+m+1);
    for(int i=1;i<=m;i++)
        s[i]=s[i-1]+b[i];
    while(sum<s[m])m--;//二分范围
    int l=1,r=m;
    while(l<=r){
        t=0;
        for(int i=1;i<=n;i++)fa[i]=a[i];
        int mid=(l+r)>>1;
        if(dfs(mid,1,mid))
            l=mid+1;
        else
            r=mid-1;
    }
    printf("%d",l-1);
    return 0;
}
```

---

## 作者：dunko (赞：10)

## **题目**

[点这里](https://www.luogu.org/problemnew/show/P2329)

## **思路**

看完题目之后就有着一种打爆搜的冲动，当然是我们喜欢的DFS啦。m<=50为什么不打DFS呢？

注意题目中要的答案并不是直接爆搜就可以快速的找到。我们还需要加一些“特技”！
没错，就是**二分答案**！！！ 再用爆搜判断这个答案是否可以要（就是二分中的check）。

当然还要**剪枝**，不然TLE会让你十分难受。

下面说一下这题要用到的剪枝方法：
1. 将提供的木材和需要的木材**排序**
2. 记录**浪费**的长度，先前我们已经排好序了，二分时答案就应该是可行的mid，它的意思就是满足前mid块小的需要木板。有一种理想情况是**最浪费**的一种。比这种情况**还浪费的直接剪枝！**
3. ......(还有好的剪枝方法，但蒟蒻直说到这里，如果还会TLE，请大家在想想，排完序后可能还可以做一些事情 ~~我也不知道，别找我~~ )
4. 哦，还有等效的剪枝，大家看看代码领悟一下。

还有一些我没说的细节，比如为什么b数组要从大到小开始搜索？ last是干什么的？
最浪费的理想情况是什么？ 希望大家可以想一想。

下面给出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,n,m,a[2000],b[2000],tot,sum[2000],mid,w;
int read(){//快读不解释
    int X=0;bool w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
bool dfs(int h,int last){
    bool ff=false;
    if(tot-w<sum[mid]) return 0;//剪枝2
    if(h==0) return 1; //如果尝试的木板都成功解决，就返回true
    for(int i=last;i<=m;i++)
    if(a[i]-b[h]>=0){//如果可以要，那就试试
        a[i]-=b[h];
        if(a[i]<b[1]) w+=a[i];//记录浪费的值
        if(b[h]==b[h-1]) ff=dfs(h-1,i);
        else ff=dfs(h-1,1);
        if(a[i]<b[1]) w-=a[i];//作为DFS，回溯是要的
        a[i]+=b[h];
        if(ff==true) return 1;//如果之后的尝试中返回可行，那就返回true
    }
    return 0;//如果尝试的一切都未能成功，只好返回false
}
int main(){
    n=read();//输入不解释
    for(int i=1;i<=n;i++)
    a[i]=read(),tot+=a[i];//tot指的是提供的木板总长，用于剪枝。
    m=read();
    for(int i=1;i<=m;i++)
    b[i]=read();
    sort(a+1,a+n+1);
    sort(b+1,b+m+1);//排序使DFS时可以更方便的剪枝
    for(int i=1;i<=m;i++)
    sum[i]=sum[i-1]+b[i];//这是需要的木板长度的前缀和，用于剪枝。
    while(sum[m]>tot)m--;
    int l=0,r=m;//二分，当答案为m时是最理想情况，故r=m。
    while(l<=r){
        w=0,mid=l+r>>1;
        if(dfs(mid,1)==1)//DFS判断是否可行
        ans=mid,l=mid+1;//可行的话保存答案并且l变大尝试更大
        else r=mid-1;//r变小尝试更小的是否可行
    }
    cout<<ans<<endl;//输出不解释
    return 0;
}
```
蒟蒻的小小分析到这里结束了，谢谢观看！

---

## 作者：dead_X (赞：8)

## 1 前言
一道不错的剪枝优化(((

就是难度评高了，个人认为PJ~PJ+吧
## 2 思路
### Solution 1:
* 暴力选择放哪些，不放哪些

* 使用没有优化的dfs

部分代码:
```
inline void dfs(int step,int t)
{
	if(step==0)
    {
    	ans=max(ans,t);
    	return ;
	}
	for(int i=n; i>=1; i--) 
	{
		if(A[i]>=b[step]) 
		{
			A[i]-=b[step];
			dfs(step-1,t+1);
			A[i]+=b[step];
		 } 
		dfs(step-1,t);
	} 
	return 0;
}
```
显然，这个算法完全没有一点剪枝，需要遍历每一种情况，显然T飞。

所以我们先考虑直接进行复杂度上的优化~~就是先不考虑卡卡常~~。
### Solution 2:
经过30s的简单思考，我们可以得到一个显而易见的结论:

注意到如果我们构造了一种剪木板的方案，我们将其中一块木板的长度需求减少 $k(k\ge0)$ ，也就是 $a_i=a_i-k$ 之后，这种方案还是可行的。

为什么呢?

拿原来那块木板裁一下就行了。

所以……如果其中 $x$ 块木板能做得到，那么**长度最小**的 $x$ 块也**一定**能做到！换句话说，最优解**之一**一定是选长度最小的 $x$ 块。

这是一个很有用的性质，即证明答案的单调性。

证明单调性之后，排列又可以帮我们减少负担，优化见下。

* 我们可以二分搜索。

* **优化1:二分的dfs只需判断是否能做到即可。**

* **优化2:先排列两个木材长度的序列，二分可以直接进行dfs**

* **优化3:为了减少判断，可以从大往小判断，让每次搜到下一层的数量竟可能少**

部分代码:
```
inline bool dfs(int step)
{
	if(step==1)
	{
		for(int i=1; i<=n; i++) if(A[i]>=b[1]) return 1;
		return 0;
	} 
	for(int i=n; i>=1; i--) if(A[i]>=b[step]) 
	{
		A[i]-=b[step];
		if(A[i]<b[1]) if(dfs(step-1)) return 1;
		A[i]+=b[step];
	} 
	return 0;
}
```

```
	while(l<=r)
	{
		for(int i=1; i<=n; i++) A[i]=a[i];
		mid=(l+r)>>1,now=0;
		for(int i=1; i<=mid; i++) now+=b[i];
		if(dfs(mid)) ans=mid,l=++mid; else r=--mid;
	}
```
那么我们只需要搜 $log_2n$ 次，每次搜不一定搜完，从大往小搜，平均复杂度已经小了很多(因为策略很好，不用搜几次就能到正确答案)，但是还是T的飞起。
### Solution 3:
考虑一个很玄学的数据。

```
2
100 198
3
99 99 100
```
当前尝试的为 $x=3$ ，即全部塞进去。

首先，$100$ 会分给 $198$ ，然后发现 $99$ 放不进去，然后得出不可行。

然后，$100$ 会分给 $100$ ，发现 $99$ 都能塞到 $198$ 里，然后得出可行。

在这个例子里，时间相差不大，但是如果这种 $198$ 和 $99$ 有很多很多呢?

所以，数据卡了一下，很多人又T飞了。

那么，这个数据能告诉我们什么呢?

**在把 $100$ 放入 $198$ 的时候，这个 $198$ 产生了大量无法利用的浪费长度。**

浪费长度……

等等，如果浪费的太多，从而剩下的空间已经不足以放进去另外所有的了(即使剩下的全是 $1$ )，怎么办?

``return 0;``

* **优化4:当剩下最大有效利用空间小于剩下所有需要的空间之和时，必定不可行，跳出。**

上面这句话等价于 $\Sigma_{i=1}^{n}a_i-waste<\Sigma_{i=1}^{step}b_i$ 时 ``return 0;`` ，其中的 $a_i$ 是当前剩下的，就是 dfs 中需要先减掉然后搜完加回来的 $a_i$ 。

那么其实还有一个优化也可以想到(但是用处不大)

* **优化5:起始枚举的右端点保证需要的空间之和小于最大有效的可利用空间。**

上面这句话等价于 $\Sigma_{i=1}^{n}a_i\geq\Sigma_{i=1}^{r}b_i$ 时 ``return 0;``

部分代码:
```
inline bool dfs(int step)
{
	if(step==1)
	{
		for(int i=1; i<=n; i++) if(A[i]>=b[1]) return 1;
		return 0;
	 } 
	if(now>sum) return 0;
	for(int i=n; i>=1; i--) if(A[i]>=b[step]) 
	{
		A[i]-=b[step];
		if(A[i]<b[1]) 
		{
			now+=A[i];
			if(dfs(step-1)) return 1;
			now-=A[i];
		}
		else 
		{
			if(dfs(step-1)) return 1;
		}
		A[i]+=b[step];
	 } 
	return 0;
}
```

```
	sort(b+1,b+m+1);
	for(int i=1; i<=n; i++) if(a[i]<b[1]) a[i]=1145141919810,++k;
	sort(a+1,a+n+1),n-=k;
	for(int i=1; i<=n; i++) sum+=a[i];
	int tmp=0,l=1,r=0,ans=0;
	for(int i=1; i<=m; i++) 
	{
		tmp+=b[i];
		if(tmp>sum) break; else ++r;
	}
}
```
到这里其实你已经 A 了这道题了，但是这道题还有一个小小的优化……
### Solution 4:
我们可以发现，在正在尝试放入的数量 $x$ 很小的时候，几乎可以一次成功，而 $x$ 接近答案的时候总要枚举很多次。

因此我们还可以化二分为倍增，在数据很小的时候进一步优化。

* **优化6:化二分为倍增，进一步减少枚举时的计算量**

这里不给出代码，因为~~懒得写~~上一个方法已经稳过了。
### Code:
```
#include<bits/stdc++.h>
#define int long long
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int a[53],A[53],n;
int b[1003],m;
int mid,sum,now;
using namespace std;
inline bool dfs(int step)
{
	if(step==1)
	{
		for(int i=1; i<=n; i++) if(A[i]>=b[1]) return 1;
		return 0;
	 } 
	if(now>sum) return 0;
	for(int i=n; i>=1; i--) if(A[i]>=b[step]) 
	{
		A[i]-=b[step];
		if(A[i]<b[1]) 
		{
			now+=A[i];
			if(dfs(step-1)) return 1;
			now-=A[i];
		}
		else 
		{
			if(dfs(step-1)) return 1;
		}
		A[i]+=b[step];
	 } 
	return 0;
}
signed main()
{
	n=read();
	for(int i=1; i<=n; i++) a[i]=read();
	m=read();
	for(int i=1; i<=m; i++) b[i]=read();
	int k=0;
	sort(b+1,b+m+1);
	for(int i=1; i<=n; i++) if(a[i]<b[1]) a[i]=1145141919810,++k;
	sort(a+1,a+n+1),n-=k;
	for(int i=1; i<=n; i++) sum+=a[i];
	int tmp=0,l=1,r=0,ans=0;
	for(int i=1; i<=m; i++) 
	{
		tmp+=b[i];
		if(tmp>sum) break; else ++r;
	}
	while(l<=r)
	{
		for(int i=1; i<=n; i++) A[i]=a[i];
		mid=(l+r)>>1,now=0;
		for(int i=1; i<=mid; i++) now+=b[i];
		if(dfs(mid)) ans=mid,l=++mid; else r=--mid;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Supor__Shoep (赞：5)

这是一道比较水的紫题。

首先是排序内容，我们将提供的木板从大到小排序，优先选择大的，然后将需要的木板从小到大排序，优先解决最小的，这样可以实现最优解。

据我了解到很多人喜欢用简单的数组做，但其实用前缀和统计计算才是比较好的方式，因为这样才能减小耗时，也就是避免超时风险。

对于这种题目呢，我们直接来一个二分答案，相信只要读了题的人都会。但是要注意二分左区间必须为 $0$ ，因为有可能一个符合条件的木板都切不出来。

上述内容均为橙题难度，下面才是重头戏。

我们肯定需要用到一个函数来判断第 $i$ 个木板能否将剩下的木板做出来。

如果剩下没有木板了，那就返回 $1$ 。为了达到剪枝的效果，如果能提供的总木板量减已经扔掉的木板总量小于当前的前缀数组里的值,那么就返回 $0$ 。

接下来我们从第 $i$ 个木板开始遍历，如果这个木板足够，就切下来，此时有可能会剩下一点木板，由于已经排好了序，所以如果剩下的连当前最小的木板都切不出来，就把它记为扔掉的木板。假如这个需要得到的木板和它之前一个需要得到的木板相等，在没找到解的情况下，就只从现在节点开始搜索，达到了回溯的效果。

在没有特殊情况时还是没找到解，那我们就从提供的第1个木板重新搜索，并且让剩余的木板数量减一，即 $flag=check(1,num-1)$ 。

完成了函数之后，我们代入进二分当中，如果中间节点可以被切割，就更改左区间，否则更改右区间。如果两端点重合，输出左端点。如果两端点只相差了一个单位，我们就根据 $check(1,r)$ 判断是输出右端点还是左端点。

上述内容均为蓝题难度，蓝色加橙色等于紫色，没毛病。

参考代码内容：

函数：

    bool check(int x,int num)
    {
        if(num==0)	return true;
        if(sum-out<h[num])	return false;
        if(x>m)		return false;
        bool flag=false;
        for(int i=x;i<=m;i++)
        {
            if(a[i]-b[num]>=0)
            {
                a[i]-=b[num];
                if(a[i]<b[1])	out+=a[i];
                if(b[num-1]==b[num]&&!flag)	flag=check(i,num-1);
                else
                {
                    if(!flag)	flag=check(1,num-1);
                }
                if(a[i]<b[1])	out-=a[i];
                a[i]+=b[num];
            }
        }
        return flag;
    }
    
重点代码：

      while(l<=r)
      {
          if(l==r)
          { 
              cout<<l;
              break;
          }
          if(l+1==r)
          {
              if(check(1,r))	cout<<r;
              else cout<<l;
              break;
          }
          int mid=(l+r)/2;
          if(check(1,mid))	l=mid;
          else r=mid-1;
      }
      
请看完解析之后完善全部代码，抄袭者请根据文章拼接代码。

看完了就不能给这个初一党点个赞吗？

---

## 作者：letitdown (赞：4)

#### 题目描述
有 $ n $ 块 大小分别为 $ a_i $ 的木材，分给 $ m $ 个大小分别为 $ b_i $ 的木板，但是木材只能以整块的形式给人，求最多给多少人。
（下面用"木材"表示第一批给的数，用"木板"表示询问）
#### 思路
很明显，答案在排序之后具有单调性，所以可以二分能够分给多少木板，但二分并没有一个明确的套路切木材，所以需要进行深搜；

于是来考虑最优贪心策略：

1. 首先将所有木材和木板的大小排序，优先分给木板小的；

2. 排完序后，考虑缩小二分范围，我们从小到大求得木板大小的前缀和，如果到第 $ i $ 个人的木板大小总和 $ pre_i $ 超过了上面求出的木材大小总和 $ tot $，或者 $ b_i > a[ n ] $，那么到这里无论如何切都无法满足条件，二分的最大边界就是 $ i - 1 $ 了。另外，如果木材总和都比最小的木板小，那么一个也不能满足。

我们开始二分+深搜：

1. 在深搜过程中，枚举能够切下够这个木板的木材，切掉后木材总大小要减去木板的大小。如果这块木材切剩下的不够最小木板的，那么就相当于这块木材没有用了，木材总大小要再减去没有用的这部分。

2. 显然，当剩下几张木板的总大小比剩下几块木材的总大小还要大时，方案是不符合的。

3. 当当前搜索到的这个木板与下一个要搜索的木板大小相同时，既然已经枚举到了第   $ i $ 块木材，说明第 $ i $ 块木材之前的木材对于这个大小的木板都是没有正确方案的，于是搜索下一个木板时就可以直接从第 $ i $ 块木材枚举。

最后无论有没有正确方案都要记得回溯啊！

到最后如果枚举完所有的木材都没有正确方案，就可以直接返回了。

于是本题就可以愉快的结束了～
## CODE
```cpp
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
namespace EMT{
	#define pf printf
	#define F(i,a,b) for(register int i=a;i<=b;i++)
	#define D(i,a,b) for(register int i=a;i>=b;i--)
	inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline void pi(int x){pf("%d",x);}inline void pn(){pf("\n");}inline void ps(int a[],int size){F(i,1,size)pi(a[i]);pn();}
	int n,m,a[55],b[1100],ans,cnt,ws,tot,pre[1100];
	inline bool check(int x,int st){
		if(!x)return 1;
		if(pre[x]>tot)return 0;
		bool fl=0;
		F(i,st,n){
			if(a[i]>=b[x]){
				a[i]-=b[x];tot-=b[x];
				if(a[i]<b[1])tot-=a[i];
				if(b[x]==b[x-1])fl=check(x-1,i);else fl=check(x-1,1);
				if(a[i]<b[1])tot+=a[i];
				a[i]+=b[x];tot+=b[x];
				if(fl)return 1;
			}
		}return 0;
	}
	inline short main(){
		n=read();F(i,1,n)a[i]=read(),tot+=a[i];std::sort(a+1,a+n+1);
		m=read();F(i,1,m)b[i]=read();std::sort(b+1,b+m+1);;;;;;
		if(tot<b[1]){pi(0);return 0;}
		F(i,1,m){pre[i]=pre[i-1]+b[i];if(pre[i]>tot||b[i]>a[n]){cnt=i-1;break;}}
		if(!cnt)cnt=m;
		int l=1,r=cnt,ans=0;
		while(l<=r){
			int mid=(l+r)>>1;
			if(check(mid,1))l=mid+1,ans=mid;
			else r=mid-1;
		}
		pi(ans);
		return 0;
	}
}
signed main(){return EMT::main();}
```


---

## 作者：fanypcd (赞：4)

P2329[SCOI2005]栅栏 题解
------------
### 题目思路：

考虑二分答案，即二分枚举所有可能的符合条件的木板的个数。然后加以判断是否能够达成（ dfs +剪枝）。

假设二分范围为 $[l,r]$ ，易知初值 $l \geq 0$ （无解），而 $r\leq m$ （全部可以），取中间值 $mid=(l + r) / 2$ ，每次检验目前能否满足做出 $mid$ 块木板。

```cpp
int l = 0, r = m;
while(l < r)
{
	t = 0;
	for(int i = 1; i <= n; i++)
	{
		f[i] = a[i];
	}
	int mid = (l + r + 1) / 2;
	if(dfs(mid, 1, mid))
	{
		l = mid;
	}
	else
	{
		r = mid - 1;
	}
}
cout << l;
```


------------

至于检验的函数，其实就是个暴力尝试后回溯。枚举每个木料，令 $dfs(k, x, mid)$ 表示目前需要完成的木板有 $k$ 个，木材遍历到 $x$ 个。

如果目前第 $x$ 个木材长度大于等于第 $k$ 个木板，则尝试用这根木材，这根木材的剩余长度减等于木板长度，并调用 $dfs(k - 1, 1, mid)$ （再次从1号木料尝试）。


------------

边界条件：
```cpp
if(k == 0)
{
	return 1;
}
```


------------

**直接暴搜肯定 WA ，所以考虑优化：**

二分答案可以做二分范围 $[l, r]$ 的优化：

即考虑对木材求总和，木板排序后求前缀和，如果前 $m$ 块木木板需要的木材总长度大于木材长度总和， $m\to m-1$ 。

即


```cpp
while(sum < s[m])
{
	m--;
}
```


------------

#### 然后考虑对 dfs 开刀

**1.** 因为木板是排好序了的，如果目前这个木材连长度最小的木板都做不了，就不能再用了。累加这种木材的长度在 $t$ 中。

如果某时刻

$(sum-t) < $ (前 $mid$ 块木块的长度和)

，则方案不合法。

即

```cpp
if(sum - t < s[mid])
{
	return 0;
}

if(f[i] < b[1])
{
	t += f[i];
}
```


------------

**2.** 如果连续两块木板要求的长度相同，则只用判断其中一个即可。

即

```cpp
if(b[k] == b[k - 1])
{
	if(dfs(k - 1, i, mid))
	{
		return 1;
	}
}
```


------------

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005], b[10005], f[10005], n, m, t, sum, s[10005];
int dfs(int k, int x, int mid)
{
	if(k == 0)
	{
		return 1;
	}
	if(sum - t < s[mid])
	{
		return 0;
	}
	for(int i = x; i <= n; i++)
	{
		if(f[i] >= b[k])
		{
			f[i] -= b[k];
			if(f[i] < b[1])
			{
				t += f[i];
			}
			if(b[k] == b[k - 1])
			{
				if(dfs(k - 1, i, mid))
				{
					return 1;
				}
			}
			else if(dfs(k - 1, 1, mid))
			{
				return 1;
			}
			if(f[i] < b[1])
			{
				t -= f[i];
			}
			f[i] += b[k];
		}
	}
	return 0;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
		sum += a[i];
	}
	cin >> m;
	for(int i = 1; i <= m; i++)
	{
		cin >> b[i];
	}
	sort(b + 1, b + m + 1);
	for(int i = 1; i <= m; i++)
	{
		s[i] = s[i - 1] + b[i];
	}
	while(sum < s[m])
	{
		m--;
	}
	int l = 0, r = m;
	while(l < r)
	{
		t = 0;
		for(int i = 1; i <= n; i++)
		{
			f[i] = a[i];
		}
		int mid = (l + r + 1) / 2;
		if(dfs(mid, 1, mid))
		{
			l = mid;
		}
		else
		{
			r = mid - 1;
		}
	}
	cout << l;
	return 0;
}
```

---

## 作者：Unordered_OIer (赞：3)

# P2329 题解

## 题意
求约翰最多能够得到多少他所需要的木板

## 解答
贪心思想很容易想到，~~不讲了~~。但有一个比较麻烦的问题就是check。

我们先假设check的函数已经写好了，那么我们怎么解出最优答案呢？想必各位已经想到了，$\large{二分答案}$。

那么我们先打一遍板子：
```cpp
	void binary_search(){
		int leftbound=0,rightbound=n,ans=0;
		while(leftbound<=rightbound){
			int mid=leftbound+(rightbound-leftbound)/2;
			if(valid_next_status(mid)) leftbound=mid+1,ans=mid;
			else rightbound=mid-1;
		}
	}
```

好的那么我们来~~硬淦~~写check函数，不难看出一定是$dfs$判断的吧。（你自己模拟几下找找感觉不就行了

好的，一个$dfs$写好了，然后快乐地交上去，发现$\huge{\text{TLE}}$
![](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2986019800,1056897466&fm=26&gp=0.jpg)

然后避免不了的优化来了。。。  
1. 排序是肯定的
2. 前缀和是肯定的
3. **我们要缩小二分答案的范围**  
如果所有的老板提供的木板长度加起来都不能满足约翰的所有要求，那么我们不用苦苦枚举所有的情况了，直接缩小范围，代码就是:
```cpp
while(prefix[n]>tot)--n;
```
4. $dfs$剪枝显然  
我们设想：如果第$i$个约翰所需木板和$i-1$个约翰所需木板一样长，那么不能满足$i-1$当然也不能满足$i$，这样就可以剪掉一大部分计算，以至于$\huge{\color{lightgreen}AC}$


总代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace scoi{
	const int N=2009;
	int m,n,a[N],b[N],c[N],prefix[N],rest,tot;
	bool judge_valid(int d,int last){
		if(d<=0) return 1;
		if(rest+prefix[d]>tot) return 0;
		for(int i=last;i<=m;++i)
		    if(c[i]>=b[d]){
		    	c[i]-=b[d];
		    	if(c[i]<b[1]) rest+=c[i];
		    	if(judge_valid(d-1,b[d]==b[d-1]?i:1)) return 1;
		    	if(c[i]<b[1]) rest-=c[i];
		    	c[i]+=b[d];
			}
		return 0;
	}
	bool valid_next_status(int mid){
		for(int i=1;i<=n;++i) c[i]=a[i];
		rest=0;
		return judge_valid(mid,1);
	}
	void binary_search(){
		int leftbound=0,rightbound=n,ans=0;
		while(leftbound<=rightbound){
			int mid=leftbound+(rightbound-leftbound)/2;
			if(valid_next_status(mid)) leftbound=mid+1,ans=mid;
			else rightbound=mid-1;
		}
	}
	void init_all(){
		cin>>m;
		for(int i=1;i<=m;i++)cin>>a[i],tot+=a[i];
		cin>>n;
		for(int i=1;i<=n;i++)cin>>b[i];
	}
	void sort_ab(){
		sort(a+1,a+1+m);
		sort(b+1,b+1+n);
	}
	void solve_first(){
		for(int i=1;i<=n;++i)prefix[i]=prefix[i-1]+b[i];
		while(prefix[n]>tot)--n;
	}
	void solve_second(){
		binary_search();
		cout<<ans<<endl;
	}
	int _main(){
		init_all();
		sort_ab();
		solve_first();
		solve_second();
		return 0;
	}
}
int main(){scoi::_main();}
```

---

## 作者：AzusaShirasu (赞：3)

本题可以用二分加搜索剪枝解决。鉴于这样的题解已经有很多了，本篇题解主要是介绍**随机化算法**的应用。

经过仔细思考或者参考题解很容易就能做出这道题。然而，如果在比赛 / 模拟赛的时候没思路，又或者是写了没有调试正确导致出锅呢？在这样的情况下没有题解能够参考，而时间又紧迫，此时一种带有投机取巧成分的算法便应运而生：**随机化算法**。

高级的随机化算法有好几种，包括[**蒙特卡洛法**](http://www.baidu.com/link?url=kUEenctRNFwcIh-Kw9oXv8TXWjyXxT7Vvrn1p8nqOcLsRxICSSqlN9FLH6ImwAJUaRwWpHFgx-eaYqAyp8x6czxcgseUjhkLaSrfmasE9LUHTenMMN1qBgTEoUKTZeGDOYNB-1-HyTHtNkeXCk052q&wd=&eqid=eb68e3f600018b490000000662300446)、[**模拟退火**](http://www.baidu.com/link?url=g8qToGKg-Cc9HBRrZjTV6wDCacpsZO4XN17AGqXxeL9YwfDbLxmwZwA3h_TcX6HYEfF04mfBWldSIx0MXDYk3cs0sM_C7ranq0T5h2omEBR2qvWVa4Z8AJg1mHb8jJp1TyAMhoWofYMpR2M-l4qFQExuGQ8RFukBdDmk5qkW7mH2eYiFBz01CcfkhCmsdE-VUA1kX8b55BGcmGlfYC-OQhPHANL9ncXZWtFcP0utQjq&wd=&eqid=d664385b0000a896000000066230046f)等。这里给出最简单的随机化算法中的一种：**随机贪心**。

根据题意，要求能切出的木板数量**最多**，很容易就能想到，切长木板肯定不如切短木板优，所以一定是**从最短的需求开始**按长度顺序依次满足各个需求。直接搜索比较困难，可以使用**二分**。二分最多能切出的木板的数量，然后再判断现有的木板是否能满足对应需求。

重点放在 `check` 函数上。假设现在有 $4$ 个需求，分别是 $1$、$2$、$2$、$5$，直接从最长的木板开始，按需求长短升序切可以吗？很明显是不行的，如下图左边就是错误的切法。

![](http://39.106.8.172:4080/get_image?pic=452d0cf3156d3ae296660eee47d86bfb)

也就是说，处理需求应当按照降序。一句话概括就是：**选取需求时应当尽量选短的，但是处理需求时应优先处理长的**。因为小的需求可以挤在大的需求剩下的空间里。

然而还有一个问题：假设多块木板可以满足当前的最长需求，怎么知道选择哪一块木板呢？此时，随机化算法就派上了用场。每次随机打乱木板，然后按上面的贪心算法依次满足需求。只要有一次满足了所有的需求，那么就判定当前需求是可满足的。当然，只随机一次的结果可信度不高，那就随机多次。当然，仍然可能存在误解的情况，但是概率可以说是微乎其微的。要想卡掉这样的算法也比较困难。

为什么呢？其实，对于这样的问题，**如果一组数据能卡掉某个算法，那么这组数据也就几乎只能卡掉这个算法**（这里的“卡掉”指的是使算法得到错误的结果，和效率无关）。这和字符串双 $\texttt{Hash}$ 的原理是一样的：几乎不可能造出同时卡掉两组模数的数据。基于此，随机化算法在大部分时候都是能得到正确答案的。

代码见下：

```
#include <bits/stdc++.h>

const int TIMES = 2333;
// 随机检验的次数，本题其实只要 TIMES=1 就能过，
// 但是保险起见，建议还是随机多次
const unsigned long long MD5 = 0x46de8bd13d5e4657949eecb23e7043b9L;
// 随机生成的种子
using namespace std;

const int maxn = 50 + 5;

int n, m;
int planks[maxn];
int ask[1025];

int planks2[maxn];
bool random_check(int lim) { // 单次检测
	memcpy(planks2, planks, sizeof(planks)); // 赋值
	random_shuffle(planks2 + 1, planks2 + 1 + n); // 随机打乱
	for(int i = lim; i >= 1; i--) { // 贪心：从高往低处理需求 
		bool ok = false;
		for(int j = 1; j <= n; j++) {
			if(planks2[j] >= ask[i]) {
				ok = true, planks2[j] -= ask[i];
				break;
			}
		}
		if(!ok) return false;
	}
	return true;
}

bool check(int lim) { // 多次检验
	for(int i = 1; i <= TIMES; i++) if(random_check(lim)) return true;
	return false; // 大量检验仍然找不到，可以判定为 false
}

int main() {
	srand(MD5); // 设定随机种子
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%d", &planks[i]);
	scanf("%d", &m);
	for(int i = 1; i <= m; i++) scanf("%d", &ask[i]);
	sort(ask + 1, ask + 1 + m);
	int L = 0, R = m, ans = 0;
	while(L <= R) {
		int mid = (L + R) / 2;
		if(check(mid)) ans = max(ans, mid), L = mid + 1; // 二分
		else R = mid - 1;
	}
	cout << ans;
	return 0;
}
```

时间复杂度是 $O(T \times nm \log m)$，其中 $T$ 是设定的循环次数 `TIMES` 的值，通过本题已经绰绰有余了。

在非 $\texttt{Subtask}$ 制的题目中，如果不会做，随机化算法是一个很好的选择。可以接着用随机化尝试解决 [$\texttt{P4380}$](https://www.luogu.com.cn/problem/P4380)、[$\texttt{P3212}$](https://www.luogu.com.cn/problem/P3212) 等题目。

---

## 作者：SoyTony (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2329)

[广告](https://www.luogu.com.cn/blog/Tony-ZhuJialiang/#)
# 解题分析
看到这个题面，自然会想到一个[二分模板题](https://www.luogu.com.cn/problem/P2440)，其思路是对于答案进行二分，回过头判断当前的答案是否可以被满足。那么本题和上一题的区别在于，需求的木板长度也是不一样的，对应的解决措施是把循环实现的判断函数改为搜索。
# 实现
## 基本操作
首先进行升序排序以保证木材被最大化的利用，然后进行二分。二分的区间为 $[0,n]$ 意义是能否满足前 $mid$ 个木块的需要，区间的缩减是：

```cpp
if(check()) ans=mid,l=mid+1;
else r=mid-1;
```
这里用 $ans$ 记录答案，不需要缩小边界时不需要包括 $mid$。同时注意每次搜索判断时都要把木材数组初始化，建议开一个 $tmp$ 数组。
## 优化
这样的搜索显然是会 $TLE$ 的，考虑两方面的优化。
### 关于二分区间
可以发现，如果木材总长度小于需求木板总长度，一定是无法实现的，并且会占用时间，所以可以通过该判断缩小右边界 $n$。

```cpp
while(suma<sumq[n]) n--;
```
### 关于搜索剪枝
先来看初始版本的搜索：
```cpp
inline bool check(int pos){
    if(!pos) return 1;
    for(int i=1;i<=m;i++){
        if(tmp[i]>=q[pos]){
            tmp[i]-=q[pos];
            if(check(pos-1) return 1;
            tmp[i]+=q[pos];
        }
    }
    return 0;
}
```
大致思路是：倒序搜索木材正序枚举木料，如果能够满足全部就返回值为真。

先考虑可行性剪枝，和对二分区间的优化相同，如果目前的剩余木材小于木板总长度，那么一定不可行。需要更新变量 $waste$，**注意回溯顺序**。

其次是比较玄学的剪枝，如果下一块木板和这一块木板长度相同，那么下次枚举从当前木材开始即可，原因是前面的木材都无法满足当前木板长度。

# 代码
```cpp
int n,m;
int a[1005],q[1005],tmp[1005];
int suma,sumq[1005];
int l,r,mid;
inline bool check(int pos,int last,int waste=0){
    if(waste>suma-sumq[mid]) return 0;
    if(!pos) return 1;
    for(int i=last;i<=m;i++){
        if(tmp[i]>=q[pos]){
            tmp[i]-=q[pos];
            if(tmp[i]<q[1]){
                waste+=tmp[i];
            }
            if(q[pos]==q[pos-1]){
                if(check(pos-1,i,waste)) return 1;
            }
            else{
                if(check(pos-1,1,waste)) return 1;
            }
            if(tmp[i]<q[1]){
                waste-=tmp[i];
            }
            tmp[i]+=q[pos];
        }
    }
    return 0;
}
int ans;
int main(){
    m=read();
    for(int i=1;i<=m;i++){
        a[i]=read();
        suma+=a[i];
    }
    n=read();
    for(int i=1;i<=n;i++){
        q[i]=read();
    }
    sort(a+1,a+1+m);
    sort(q+1,q+1+n);
    for(int i=1;i<=n;i++){
        sumq[i]=sumq[i-1]+q[i];
    }
    while(suma<sumq[n]) n--;
    l=0,r=n;
    while(l<=r){
        int mid=(l+r)>>1;
        for(int i=1;i<=n;i++){
            tmp[i]=a[i];
        }
        if(check(mid,1)){
            ans=mid;
            l=mid+1;
        }
        else{
            r=mid-1;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：_Imaginary_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2329)

## Solution

先看一眼：$m\le 50$？

似乎是搜索。

于是：

### 1. 爆搜

首先，将木材排序，然后二分能造出的数量。

对于木材，从大到小枚举，每枚举一个然后看用哪个木板来裁。

随后，记得裁完后恢复。

### 2. 剪枝1

在搜索时，统计浪费的木头，如果就算把剩下的木头都用完了也不够，那就可以直接 `return false`。

这个剪枝挺简单的，但实测有用。

### 3. 剪枝2

在初始时，如果木板零浪费也无法做出所有木材，我们可以将 $n$ 减少。

### 4. 剪枝3

如果搜索到两个长度相同的木材，那下一次搜索时不用从 $1$ 开始，可以从上一次枚举到的木板开始。

这样就不会挂了。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int mod=1000000007;
const int M=55,N=1005;
int m,n;
ll a[M],b[N],sum[N],tot,waste,mid;
bool dfs(int x,int lst)
{
	if(tot-waste<sum[mid]) return false;
	if(x==0) return 1;
	bool ok=0;
	for(int i=lst;i<=n;i++)
	{
		if(a[i]>=b[x])
		{
			a[i]-=b[x];
			if(a[i]<b[1]) waste+=a[i];
			if(b[x-1]==b[x]) ok=dfs(x-1,i);
			else ok=dfs(x-1,1);
			if(a[i]<b[1]) waste-=a[i];
			a[i]+=b[x];
			if(ok) return true;
		}
	}
	return false;
}
int main()
{
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%lld",&a[i]);
		tot+=a[i];
	}
//	sort(a+1,a+m+1);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&b[i]);
	}
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+b[i];
	while(n&&sum[n]>tot) n--;
	ll L=0,R=n;
	while(L<=R)
	{
		waste=0;
		mid=(L+R)>>1;
		if(dfs(mid,1)) L=mid+1;
		else R=mid-1;
	}
	printf("%lld",R);
	return 0;
}
```



---


# [SDOI2005] 阶梯教室设备利用

## 题目描述

我们现有许多演讲要在阶梯教室中举行。每一个演讲都可以用唯一的起始和终止时间来确定，如果两个演讲时间有部分或全部重复，那么它们是无法同时在阶级教室中举行的。现在我们想要尽最大可能的利用这个教室，也就是说，我们需要在这些演讲中选择一些不重复的演讲来举行使得他们用的总时间尽可能的长。我们假设在某一演讲结束的瞬间我们就可以立即开始另一个演讲。

请写一个程序：

读入所有演讲的起始和终止时间，计算最大的可能演讲总时间。

## 说明/提示

### 样例解释

可以选择第 $3$ 个、第 $5$ 个、第 $6$ 个、第 $11$ 个、第 $12$ 个演讲，此时有最长的演讲总时间 $16$。

### 数据范围

$1\le n\le 10^4$，$0\le p<k\le 3\times 10^4$。

## 样例 #1

### 输入

```
12
1 2
3 5
0 4
6 8
7 13
4 6
9 10
9 12
11 14
15 19
14 16
18 20
```

### 输出

```
16```

# 题解

## 作者：sigland (赞：29)

蒟蒻写了个O(n+k)算法,简单粗暴.jpg.思路就是开30000个vector作为起始时间(就是不用排序),对于读入的东西(st,ed)将ed扔到st的那个vector里,然后就是一个很假的dp了,dp[i]表示在i时间结束的最大演讲时间,转移也很简单,就是要注意下dp[i]的初值是dp[i-1],因为可以某段时间不排演出...代码17行,0ms,还算可以...具体看代码吧...
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[30010]={0},st,ed;
vector<int>mp[30010];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&st,&ed),mp[st].push_back(ed);
    for(int i=0;i<=30000;i++)
    {
        if(i>1)dp[i]=max(dp[i],dp[i-1]);
        for(int j=0;j<mp[i].size();j++)
        dp[mp[i][j]]=max(dp[mp[i][j]],dp[i]+mp[i][j]-i);//转移 
    }
    cout<<dp[30000];//最大就30000结束 
}
```

---

## 作者：zhangyuhan (赞：19)

大佬们的$DP$有点复杂，让我来讲些易懂的。

想必大家都会写“最长不下降子序列问题”（$LIS$），我们也可以将这道题转化为$LIS$呀！

**怎么转化呢？**

我们知道，$LIS$中不下降指的是数字大小，而在这道题中，我们可以用不下降来指代演讲的时间，及后面的演讲开始时间不低于前面演讲的结束时间。

而$LIS$中，$f_i$指代的是最长不下降子序列的长度，这里可以指代最长的演讲时间；而$LIS$中$f_i$更新是因为在比它更小的数中，有比$f_i$更长的序列，这里可以认为，当前面的某个演讲加上之前的演讲，比$f_i$更大时，可以更新。

简而言之，原$LIS$的方程为：

$f_i=\max(f_i,f_j+1)\ (1<=j<i,a_j<=a_i)$

类比，这里的方程可以写为

$f_i=\max(f_i,f_j+a_i.len)\ (1<=j<i,a_j.ed<=a_i.st)$

（其中$len$表示演讲时间长度，$st$表示演讲开始时间，$ed$表示演讲结束时间）

**转化成功了！**

最后讲一下细节：

我们为了保持时间最长，一定要**排序**,按开始时间大小排序。

没了。

$AC$ $Code$

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct speak{
	int st, ed, len;
};//结构体更方便推算和排序
speak a[10010];
bool cmp(speak x, speak y) {
	return x.st < y.st;
}//自定义cmp函数，用来排序。如果想要更快可重载运算符

int n, f[10010], ans;

int main() {
	cin >> n;
	for (int i=1; i<=n; i++) {
		cin >> a[i].st >> a[i].ed;
		a[i].len = a[i].ed-a[i].st;//时间计算式
	}
	sort(a+1, a+1+n, cmp);
	for (int i=1; i<=n; i++) {
		f[i] = a[i].len;//初始化：假设在它前面没有演讲，最短时间也是这个演讲的时间
		for (int j=1; j<i; j++) {
			if (a[j].ed <= a[i].st && f[i] < f[j]+a[i].len)
				f[i] = f[j]+a[i].len;
		}
		ans = max(ans, f[i]);//更新答案
	}
	cout << ans << endl;
	return 0;//完结撒花！
}
```


---

## 作者：zhenglier (赞：7)

看到大多数大佬都用dp，也有大佬用spfa跑最长路~~结果代码很长~~，小蒟蒻直接建图跑bfs~~（什么，spfa也用的是bfs）~~。主要原因是这个图没有环，可以写的简单很多。

### 建图

建图其实比较简单，把每个点向下一个点连长度为0的边，对于每一个演讲，从开始时间向结束时间连一条长为时间差的边。然后就可以愉快的跑bfs了。

### 核心代码
```cpp
	q.push(0);//插入起始点
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=head[x];i;i=nxt[i]){//枚举出边
			if(d[x]+zhi[i]<d[bian[i]])continue;//判断目标点是否为最优解。
			d[bian[i]]=d[x]+zhi[i];
			q.push(bian[i]);
		}
	}

```
非常短，而且不用担心被卡。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,V;
int tot,bian[60010],nxt[60010],head[30010],zhi[60010];
int d[30010];
inline void add(int x,int y,int z){
	tot++;
	bian[tot]=y;
	zhi[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot;
}
struct data{
	int b,e;
}a[10010];
bool operator <(data a,data b){
	return a.b<b.b;
}
queue<int>q;
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i){
		scanf("%d%d",&a[i].b,&a[i].e);
		add(a[i].b,a[i].e,a[i].e-a[i].b);
		V=max(V,a[i].e);
	}
	for(int i=0;i<=V;++i){
		add(i,i+1,0);
	}
	q.push(0);
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=head[x];i;i=nxt[i]){
			if(d[x]+zhi[i]<d[bian[i]])continue;
			d[bian[i]]=d[x]+zhi[i];
			q.push(bian[i]);
		}
	}
	cout<<d[V]<<endl;
}
```

---

## 作者：_byta (赞：6)

考虑 dp ，我们设 $f(i)$ 表示到 i 时间点，最长的演讲时间，那 $f(i)$

肯定由 $f(i)$ , i 之前的演讲的时间中最大的那个转移过来，我们可以用

动态数组 vector 存 i 之前的讲课时间，转移时遍历 vector 寻找答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>v[3000002];
int n,mx,f[3000002];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		v[y].push_back(x);
		mx=max(mx,y);
	}
	for(int i=1;i<=mx;i++)
	{
		f[i]=f[i-1];
		for(int j=0;j<v[i].size();j++)
		{
			int b=v[i][j];
			f[i]=max(f[i],f[b]+i-b);
		}
	}
	printf("%d\n",f[mx]);
	return 0;
}

```



---

## 作者：梦回还 (赞：5)

DP方程显而易见：对于一对数 a, b

dp[b] = max(dp[b], max(dp[i])  + b - a);(i = 1 to a);

怎么就没有用线段树维护 max(dp[i]) 的呢？我来贡献一个吧 qwq~（真相是本人没想到二分）

本人语文差，所以开始理解错了题意，有两个要点：

1、立即开始指：如果前一个人在 t 秒结束演讲，那么从 t 秒开始演讲的人可以立刻开始；

2、时间间隔指：比如从 1s 到 3s ，那么经过的时间是 3-1=2s。

有了这个，要搞定这题就不难啦~上代码ing（全程log效率）





```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 30005, M = 10005;
struct data {
    int x, y;
}a[M];
int dp[N], n, ma, sum[N << 2];
bool cmp(data a, data b) {
    return a.y < b.y;
}
void updata(int l, int r, int d, int c) {
    if(l == r) {
        sum[d] = max(dp[c], sum[d]);
        return ;
    }
    int mid = (l + r) >> 1;
    if(c <= mid) updata(l, mid, d << 1, c);
    if(mid < c) updata(mid + 1, r, d << 1 | 1, c);
    sum[d] = max(sum[d << 1], sum[d << 1 | 1]);
    return ;
}
//线段树单点更新最大值
int query(int l, int r, int d, int L, int R) {
    if(L <= l && r <= R) return sum[d];
    int mid = (l + r) >> 1, ans = 0;
    if(L <= mid) ans = max(ans, query(l, mid, d << 1, L, R));
    if(mid < R) ans = max(ans, query(mid + 1, r, d << 1 | 1, L, R));
    return ans;
}
//线段树区间查询最大值
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d%d", &a[i].x, &a[i].y);
    sort(a + 1, a + n + 1, cmp);
    for(int i = 1; i <= n; i++) {
        dp[a[i].y] = max(dp[a[i].y], query(0, a[n].y, 1, 0, a[i].x) + a[i].y - a[i].x);//dp方程
        updata(0, a[n].y, 1, a[i].y);
    }
    printf("%d", query(1, a[n].y, 1, 1, a[n].y));
    return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：4)

~~这个题被左闭右开坑了好几次······~~

~~宣传[blog](https://www.luogu.com.cn/blog/2007100723874wxz/)~~

首先，这题上手想到贪心(如果不是多少分钟而是多少场就好了)

但然后一想就会发现：贪心不行！

于是考虑DP

$\operatorname{dp}(\text{i})$表示$\text{i}$时刻结尾最多滔滔不绝多少时间

考虑到演讲的问题，直接DP并不是很好转移（dalao请无视）

个人是先把每个演讲按结束时间排序，然后在每个演讲的结束时间DP一下

感觉方便一点

记$\text{i}$为当前演讲的结束时间，$\text{j}$为开始时间

方程：

$\operatorname{dp}(\text{i})=\operatorname{max}\{\operatorname{max}\{\operatorname{dp}(\text{k})|0\le{k}\le{j}\}+i-j,\operatorname{dp}(\text{i})\}$

如果直接暴力求上述式子中的$\text{max}$似乎是$\operatorname{O}(\text{n}^2)$

于是考虑用数据结构来维护

要支持什么？

单点修改区间查询$({\text{RMQ}})$

线段树可以

但是~~本蒟蒻不太熟练线段树~~观察到特殊性，这并不是一个普通的${\text{RMQ}}$

它其实是一个前缀最值查询$({\text{PMQ}})$！

前缀查询的话树状数组就可以用了~

常数比线段树小很多，代码也好写

综上，这题就没了！

最后上代码
```
#include<bits/stdc++.h>
using namespace std;
int n;
int bit[30009];
inline void update(register int pos,const int&x){
	while(pos<=30000){
		if(x<=bit[pos])return;
		bit[pos]=x;
		pos+=pos&-pos;
	}
}
inline int query(register int pos){
	register int x=0;
	while(pos){
		x=max(x,bit[pos]);
		pos&=pos-1;
	}
	return x;
}
struct node{
	int u,v;
}p[10009];
bool cmp(const node&x,const node&y){
	return x.v<y.v;
}
int dp[10009];
int main(){
	cin>>n;
	for(register int i=1;i<=n;++i)cin>>p[i].u>>p[i].v,p[i].u+=2,p[i].v+=2;
	sort(p+1,p+n+1,cmp);
	for(register int i=1;i<=n;++i){
		int u=query(p[i].u)+p[i].v-p[i].u;
		if(u<=query(p[i].v))
			continue;
		update(p[i].v,dp[p[i].v]=u);
	}
	cout<<query(30005);
    return 0;
}
```

---

## 作者：田大坑 (赞：4)

#### 如何用图论~~乱搞~~dp的区间背包



------------

对于每一个区间，可以枚举这个区间取和不取，取就加上这一区间的价值，但是有时用背包是比较难写的，而且有的人不会背包什么的~~（也许没有吧）~~

对于每一个区间，从区间的开始到结束建一条边，边的权值就是区间的权值

```
for(int i=1;i<=n;i++)
    {
        int u,v,w;
        scanf("%d%d",&u,&v);
        w=v-u;
        add(u,v,w);
        m=max(v,m);//终点是区间右端点的最大
        x[u]=1,x[v]=1;
    }
    //连上边之后如下
    ———— ————— ——————
       ————
```

然后我们就可以得到一个不~~太~~联通的图，对于这样一个不联通的图，我们就可以强行联通，对于两个较近的区间，连上一条权值为0的边

```
————--————--——————

```
```
	while(1)
    {
        while(!x[hd]&&hd<m) hd++;
        add(tl,hd,0);//这样建边可以有效减少边的数量
        if(hd>=m)
        break;
        tl=hd++;
    }
```
之后用spfa||dij跑最长路就可以了
~~一般这种正解是dp的题目，不可能卡这个的~~
 
我们有幸请到了bfs-spfa 和 dfs-spfa 和 变种-dij

bfs-spfa 时间 14ms
```
void spfa(int st)
{
    q.push(st);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=1;
        for(int i=head[u];i;i=e[i].next)
        {
            int to=e[i].to;
            if(dis[to]<=dis[u]+e[i].w)//最长路，一定要这个‘=’，不然有的区间就无法被选上
            {
                dis[to]=dis[u]+e[i].w;
                if(!vis[to])
                {
                    q.push(to);
                    vis[to]=1;
                }
            }
        }
    }
}
```
dfs-spfa 时间 27ms

~~优秀的体现的spfa-dfs判断负环的优越性~~
```
void spfa(int u)
{
    vis[u]=1;
    for(int i=head[u];i;i=e[i].next)
    {
        int to=e[i].to;
         if(dis[to]<=dis[u]+e[i].w)
            {
                dis[to]=dis[u]+e[i].w;
                if(vis[to])
                return;
                spfa(to);
            }
    }
    vis[u]=0;
}
```
变种-dij

tip：由于这种题目存在负环，和0权等等…………所以每一个点要多次拓展，其实和spfa是差不多的，就是多了一个堆优化

然而

时间 22ms

~~优秀的体现的spfa-dfs判断负环的优越性~~
```
void dij(int st)//其实这大部分就是spfa
{
    pq.push((node){st,0});
	dis[st]=0;
    while(!pq.empty())
    {
        int u=pq.top().id;
        pq.pop();
        vis[u]=0;
        for(int i=head[u];i;i=e[i].next)
        {
            int to=e[i].to;
            if(dis[to]<=dis[u]+e[i].w)
            {
                dis[to]=dis[u]+e[i].w;
                if(!vis[to])
                pq.push((node){to,dis[to]}),vis[to]=1;
            }
        }
    }
}
```
最后附上冠军代码
```
#include<bits/stdc++.h>
using namespace std;
struct edge{
    int next,to,w;
}e[10100];
int dis[31000];
int n,m,cnt,head[31001],hd=1,tl;
bool vis[31000],x[31000];
void add(int from,int to,int l)
{
    cnt++;
    e[cnt].to=to;
    e[cnt].next=head[from];
    e[cnt].w=l;
    head[from]=cnt;
}
queue<int> q;
void spfa(int st)
{
    q.push(st);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=1;
        for(int i=head[u];i;i=e[i].next)
        {
            int to=e[i].to;
            if(dis[to]<=dis[u]+e[i].w)
            {
                dis[to]=dis[u]+e[i].w;
                if(!vis[to])
                {
                    q.push(to);
                    vis[to]=1;
                }
            }
        }
    }
}
int main()
{
    //freopen("in.txt","r",stdin);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int u,v,w;
        scanf("%d%d",&u,&v);
        w=v-u;
        add(u,v,w);
        m=max(v,m);
        x[u]=1,x[v]=1;
    }
    while(1)
    {
        while(!x[hd]&&hd<m) hd++;
        add(tl,hd,0);
        if(hd>=m)
        break;
        tl=hd++;
    }
    spfa(0);
    printf("%d",dis[m]);
}
```

遇到不会的题目，不要慌张，认真~~乱搞~~总是有分的

暴力赛标算之类的不是不可能

祝NOIP2018 rp++！

```
while(666)
++rp
```
同类题目
[p2889](https://www.luogu.org/problemnew/show/P2889)
[p1280](https://www.luogu.org/problemnew/show/P1280)

---

## 作者：aiyougege (赞：4)

#### Solution
这是一道显而易见的dp.

令$f(i)$表示前i分钟最长演讲长度, 那么可以有以下转移方程
![](https://cdn.luogu.com.cn/upload/pic/21847.png )

所以我们就可以枚举每个时间$t$用演讲的终点时间在这个时间的所有时间来更新$f(t)$.因为每个演讲只有一个时间, 因此总复杂度就是$O(m+n)$, 其中$m$表示最大可能出现的时间,$n$表示演讲个数.
#### code
我比较淡腾所以强行指针写了一波, 原因是可以不用写数组下标比较好写……
```c++
#include<algorithm>
#include<iostream>
#include<cstdio>
#define N 40006
using namespace std;

int me;
struct TED{
    int st,en;
    bool operator<(const TED& o)const{return en<o.en;}
    void input(){scanf("%d%d",&st,&en);me=max(me,en);}
}t[N];

int f[N];

int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;++i)
        t[i].input();
    sort(t,t+n);
    TED *pos=t;
    int *g=f+1;
    int i=1;
    while(i<=me){
        while(pos->en<(g-f))++pos;
        while(pos->en==(g-f))*g=max(*g,*(f+pos->st)+pos->en-pos->st),++pos;
        *g=max(*g,*(g-1));
        g+=1,++i;
    }
    printf("%d",*max_element(f+1,f+me+1));
    return 0;
}
```

---

## 作者：雨季 (赞：3)

# 题解
发现大佬们写的都是DP，为什么蒟蒻想到的是最长路？   
其实复杂度还是靠谱的，最多也就40000条边。。。  
对于所有的演讲  **加边 起始时间 $\to$ 终止时间，边权为 时间差 。**  
然后，~~为了让最长路能够跑起来，~~由每个时刻向下一个时刻连边权为0的边。  
开开心心的跑最长路就好啦。
***
题外话：其实蒟蒻第一反应是网络流，想跑一个最大费用最大流，然后加完边后发现容量全都是1（什么鬼）。。。默默的鄙视了一下自己，**容量都是1还跑什么网络流**！！ 
# 代码
###### 作为一个图论，代码比DP长也是很正常的吧。。。（逃）
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
#define N 40005
#define M 1000005

int n,S,T,ans;

inline int read() {
    int tmp=0,w=1;
    char ch=0;
    while(!isdigit(ch)) {if(ch=='-') w=-1;ch=getchar();}
    while(isdigit(ch)) tmp=(tmp<<1)+(tmp<<3)+ch-'0',ch=getchar();
    return tmp*w;
}

struct node {
    int v,f,nex;
}e[M];
int tot,h[N];
void add(int u,int v,int f) {
    e[++tot].v=v,e[tot].f=f,e[tot].nex=h[u],h[u]=tot;
}

int dis[N];
bool vis[N];
deque<int>q;
void spfa() {  // 最长路
    for(int i=S;i<=T;++i) dis[i]=-1e9,vis[i]=0;
    q.push_back(S);
    dis[S]=0;
    int x,xx;
    while(!q.empty()) {
        x=q.front();
        q.pop_front();
        vis[x]=0;
        for(int i=h[x];i;i=e[i].nex) {
            xx=e[i].v;
            if(dis[xx]<dis[x]+e[i].f) {
                dis[xx]=dis[x]+e[i].f;
                if(!vis[xx]) {
                    vis[xx]=1;
                    if(q.empty()||dis[xx]<dis[q.front()]) q.push_back(xx);
                    else q.push_front(xx);
                }
            }
        }
    }
}

int main()
{
    n=read();
    int u,v;
    for(int i=1;i<=n;++i) {
        u=read(),v=read();
        add(u,v,v-u); // 由演讲开始时间向结束时间加边
        S=min(S,u),T=max(T,v);
    }
    for(int i=S;i<T;++i) add(i,i+1,0); // 每个时刻向下一个时刻加边
    spfa();
    printf("%d\n",dis[T]);
    return 0;
} 
```

---

## 作者：brealid (赞：2)

大致翻了一下题解，没有找到 $DAG(dp)$ 做法，贡献一发

--- 

首先很容易想到，若把每个时间作为一个节点，那么有如下的连边：

1. $s_i\ \rightarrow\ \  t_i$ $\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!^{t_i-s_i}$
1. $i\ \rightarrow i+1$ $\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!^{0}$

然后有人会用 $spfa/dij$ 跑最长路。

然而这是个 $DAG(Directed\ Acyclic\ Graph, \texttt{有向无环图})$, 所以没必要。

可以用 $O(n+m)$($n$ 为节点数, $m$ 为边数)完成 $DAG$ 的最长路/最短路计算。

其 $dfs$ 伪代码如下：

```cpp
DAG_dfs(node)
	for each edge in {start_node = node}
    	longest[end_node] = max(longest[end_node], longest[start_node] + edge_value)
        if (updated longest[end_node]) 
        	DAG_dfs(end_node)
```

可能是我写法不优秀的原因，这个 $dfs$ 版的复杂度看着不太对。(好像不应该枚举出边，应该枚举入边)

给出正确复杂度的 $dp$ 伪代码(保证结点 $i$ 在结点 $i + 1$ 之前)：
```cpp
for node from 1 to n
	for each edge in {start_node = node}
    	longest[end_node] = max(longest[end_node], longest[start_node] + edge_value)
```

给出全部代码（$32$ 行）

(另说明：因为 $i\ \rightarrow i+1$ $\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!^{0}$ 这条边对于每个节点都一定存在，所以不需要建实边，建立虚边即可，即在 ``for node from 1 to n`` 后先进行 ``f[i + 1] = max(f[i + 1], f[i])`` 操作)
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MaxN = 10000 + 7, MaxK = 30000 + 7;
int n, MaxEnd = -1;
int head[MaxK], to[MaxN], nxt[MaxN], edges_count = 0;
int f[MaxK];

void add(int u, int v)
{
    to[++edges_count] = v;
    nxt[edges_count] = head[u];
    head[u] = edges_count;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1, s, t; i <= n; i++) {
        scanf("%d%d", &s, &t);
        add(s, t);
        MaxEnd = max(MaxEnd, t);
    }
    for (int i = 0; i <= MaxEnd; i++) {
        f[i + 1] = max(f[i + 1], f[i]);
        for (int e = head[i]; e; e = nxt[e]) {
            f[to[e]] = max(f[to[e]], f[i] + to[e] - i);
        }
    }
    printf("%d", f[MaxEnd]);
    return 0;
}
```

---

## 作者：unsigned_XB (赞：2)



一定要注意这道题求的是最长时长，不是最多活动数，不能用贪心

### 本题分析思路：

这是一道序列DP，不确定的因素是时间

所以我们以f[i]表示在第0~第i个时刻举办演讲的最长时间

假设有一场演讲，时间为2~5.

我们现在有两种选择：

1.不举办这场演讲，f[5]的状态从f[4]转移，即f[i]=f[i-1];

2.举办这场演讲，f[5]的状态从这场演讲的开始f[2]转移，即f[i]=f[l[j].s]+len[j];

综上，这道题的转移方程就是：

## f[i]=max(f[i],max(f[i-1],f[l[j].s]+len[j]))

注意事项：

1.要转移的演讲的结束时刻必须与当前枚举的i相同

2.如果没有演讲可以转移，记得把状态从上一个时刻转移过来（f[i]=f[i-1]）

3.可能有多个演讲的结束时间相同，所以f[i]在转移时，一定要与原本的值比较一下

4.时长的计算是l[j].e-l[j].s

上代码~ ~~写的丑，不要喷我~~

（代码中的l[j].t就是演讲时长len[j]）

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[30005];
int n;
struct speech
{
    int s,e,t;
}l[10005];
inline int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=0; c=getchar();}
    while(c>='0'&&c<='9') {x=x*10+c-'0'; c=getchar();}
    return f?x:-x;
}
inline void write(int x)
{
    if(x<0) {putchar('-'); x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+'0'); 
}
int main()
{
    n=read();
    int maxn=0;
    for(int i=1;i<=n;i++)
    {
        l[i].s=read();
        l[i].e=read();
        l[i].t=l[i].e-l[i].s;
        maxn=max(maxn,l[i].e);
    }
    for(int i=1;i<=maxn;i++)
    {
        int flag=0;
        for(int j=1;j<=n;j++)
            if(l[j].e==i)
            {
                f[i]=max(f[i], max(f[i-1],f[l[j].s]+l[j].t));
                flag=1;
            }
        if(flag==0) f[i]=f[i-1];
    }
    write(f[maxn]);
    return 0;
}
```
听说有dalao用dij堆优化最长边大力艹过去的%%%，蒟蒻不会，就不放代码了

---

## 作者：Twinkle3110 (赞：1)

本蒟蒻学习了DP后总算过了这题qwq

首先要明确的是 本题求最长时间 所以**不能贪心**（求最多场次）

那么最优解问题 一下就想到动态规划~~明明是正好学到~~

#### 写DP首先明确四个要素:

1.状态：f[i]表示以第i场演讲结尾的 最长演讲总时间

2.状态转移:考虑前j场演讲中(1<=j<i) 若有第j场演讲与第i场演讲不冲突

	即t[j].ed<=t[i].st就是说第j场在第i场演讲开始前结束
    
   （至于为什么可以取等——题目原话：“我们假设在某一演讲结束的瞬间我们就可以立即开始另一个演讲”）
   
   那么我们就可以在f[j]后面加上本场演讲的长度 再与f[i]取最大值即可
   
   方程:f[i]=max(f[i],f[j]+t[i].len);//1<=j<i && t[j].ed<=t[i].st
   
3.边界:对于f[i]来说 以t[i]结尾的最长演讲总时间 至少是它自己的时长

	即t[i].len
    
4.解:我们并不能确定以哪一场结束是最优的，所以要在所有的f[i]中取最大的：max{f[i]}


最后附上代码qwq
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=10003;
struct tim{
    int st,ed,len;
};//结构体 表示每一场演讲的起始时间、结束时间、持续时长
tim t[MAXN];
int n,f[MAXN];
int ans;
bool cmp(tim x,tim y){//按起点为第一关键字，终点为第二关键字，升序排序
    if(x.st==y.st) return x.ed<y.ed;
    return x.st<y.st;
}
int main(){
    cin>>n;
    ans=INT_MIN;//赋初值（好习惯）
    for(int i=1;i<=n;i++){
        cin>>t[i].st>>t[i].ed;
        t[i].len=t[i].ed-t[i].st;//将每场演讲时长预处理出来 注意这里不需要+1（分析样例可得）
    }
    sort(t+1,t+n+1,cmp);//排序
    for(int i=1;i<=n;i++){
        f[i]=t[i].len;//边界（初始化）
        for(int j=1;j<i;j++){//枚举每一个可能转移过来的状态
            if(t[j].ed<=t[i].st && f[j]+t[i].len>f[i]){//第j场在第i场前结束 并且加上第i场后总时长比之前的要长
                f[i]=f[j]+t[i].len;//更新状态
        		}
        	} 
        ans=max(ans,f[i]);//上文提到的 如何寻找最优解
    }
    cout<<ans;
    return 0;
}
```



---

## 作者：Minclxc (赞：1)

打个O(tlogn)的方法，应该是正解吧

原理是用二分+单调栈优化dp

由dp方程f[i]=max(f[i-1],f[j]+i-j)(有一场j到i的演讲)(i,j枚举时间)

其中如果有f[j]=f[k]且j<k(实践上这种情况很多)，f[k]是不可能用到的

将能用到的f装入一个栈中，这个栈是单调递增的，可以二分查找

下面是代码实现，算上读入优化才30行还是比较短的

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}//读入优化
int max(int a,int b){return a>b?a:b;}
const int maxn=1e4+1,maxt=3e4+1,t=3e4;
int head[maxt],pre[maxn],beg[maxn],st[maxt],ft[maxt],top;
//head，pre，beg是后向星，st是时间（就是开头的j），ft是演讲时间（dp值）
int main(){
    //freopen("in.txt","r",stdin);
    int n=read();
    fo(i,1,n){
        beg[i]=read();int end=read();
        pre[i]=head[end];head[end]=i;
    }//后向星，记录end结束的演讲的开始时间
    fo(i,1,t){
        int f=ft[top];
        for(int x=head[i];x;x=pre[x])
            f=max(f,ft[upper_bound(st+1,st+top+1,beg[x])-st-1]+i-beg[x]);
//upper_bound是STL中的二分代码，意思是查找st中大于beg[x]的最小的地址
        if(f>ft[top])ft[++top]=f,st[top]=i;
    }
    printf("%d",ft[top]);
    return 0;
}
```

---

## 作者：East_Wind (赞：0)


这道题乍一看是dp,我们不难想到 _N*K_ 的暴力算法：
首先要先对每一场演讲按结束时间
枚举结束时间i，所选择的演讲j
得到状态转移方程：
  $f[i]=max(f[i-1],f[a[j].s]+a[j].e-a[j].s) (a[j].e<=i)$ 



------------

这样我们可以发现要选择的$f[a[j].s]+a[j].e-a[j].s$与$i$的值是无关的。同时要想满足值最大，就可以想到用大根堆来维护



------------


------------
```cpp

priority_queue<int> Q;
---------------------------
struct node{
  int s,e;  //s为起始时间，e为结束时间。
}a[N];
---------------------------
bool cmp(node a,node b){
  if(a.e!=b.e) return a.e<b.e;
  return a.s<b.s;
}
   sort(a+1,a+1+n,cmp);
---------------------------
  t=a[n].e;  int pos=0;   //t为最大时间
  for(int i=1;i<=t;i++){
  	f[i]=f[i-1];
    while(pos<=n&&pos>=0){
	  pos++;
	  if(a[pos].e<=i) Q.push(f[a[pos].s]+a[pos].e-a[pos].s);
	  else { --pos; break; }
	}
	if(!Q.empty()) f[i]=max(f[i],Q.top());
  }
  cout<<f[t]<<endl;
}
```

---

## 作者：doby (赞：0)

类似于凌乱的yyy……

方法一：

以演讲任务为阶段。

对演讲结束时间进行升序排列，使之有序。

F[i]:第i个演讲举行后教室最长的使用时间。

方法二：

以时间为阶段。([0..30000])

对演讲结束时间进行升序排列，使之有序。

F[i]:到i分钟为止教室的最长使用时间。

这里用的是方法二……

状态转移方程:f[k[i]]=maxx(f[k[i]],f[j]+k[i]-p[i]);

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
int n,p[10009],k[10009],f[10009],ans=0,out,fh;
char cc;
int read()
{
    out=0,fh=1,cc=getchar();
    if(cc=='-'){fh=-1;}
    while(cc>'9'||cc<'0'){cc=getchar();}
    while(cc>='0'&&cc<='9')
    {
        out=out*10+cc-'0',
        cc=getchar();
    }
    return out*fh;
}
void sort(int a[],int b[],int l,int r)
{
    int i,j,mid,p;
    i=l,j=r,mid=b[(l+r)/2];
    while(i<=j)
    {
        while(b[i]<mid){i++;}
        while(b[j]>mid){j--;}
        if(i<=j)
        {
            p=a[i],a[i]=a[j],a[j]=p,
            p=b[i],b[i]=b[j],b[j]=p,
            i++,j--;
        }
    }
    if(i<r){sort(a,b,i,r);}
    if(l<j){sort(a,b,l,j);}
}
int maxx(int a,int b)
{
    if(a>b){return a;}
    else{return b;}
}
```
/\*
其实上面的都不用看……

都是一些好懂的东西……

读入优化，快排，手写max……

据说机智的人都喜欢从主程序开始看……

23333333……

\*/
```cpp
int main()
{
    n=read();
    for(int i=1;i<=n;i++){p[i]=read(),k[i]=read();}
    sort(p,k,1,n);//排序
    for(int i=1;i<=n;i++)
    {
        for(int j=p[i];j>0;j--)
        {
            f[k[i]]=maxx(f[k[i]],f[j]+k[i]-p[i]);//状态转移，从开始时间往前推
        }
    }
    for(int i=0;i<=k[n];i++){ans=maxx(ans,f[i]);}//找最优解
    printf("%d",ans);//输出
    return 0;
}
```

---

## 作者：infinityedge (赞：0)

可以在dp内部进行优化，通过二分查找一个当前最优的演讲，然后转移这个演讲，这样可以通过n=10^5，p，k=10^9的大数据。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct t{
    int st,ed;
}a[100005];
int n,ans,f[100005];
int cmp(t a,t b){
    return a.ed<b.ed;
}
int main(){
    //freopen("rez.in","r",stdin);
    //freopen("rez.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&a[i].st,&a[i].ed);
    }
    sort(a+1,a+n+1,cmp);//按结束时间排序
    for (int i=1;i<=n;i++){
        f[i]=f[i-1]; 
        int l=0,r=i-1;
        while(l<r){//二分查找
            int m=(l+r+1) >> 1;
          if (a[m].ed>a[i].st)r=m-1; else l=m;//判断该演讲是否可行
        }
        
        if (f[l]+a[i].ed-a[i].st>f[i])f[i]=f[l]+a[i].ed-a[i].st;//转移
    }  
    printf("%d",f[n]);
    return 0;
}
```

---

## 作者：woshiyzr (赞：0)

这题只要看懂题目就很容易了，

先按结束时间排序，

再按照每个区间从开始时间往前扫描，

找之前的最大利用时间再加上这一段时间（注意直接用**结束时间-开始时间**），

总之还是先贪心，再暴力就行了

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;
const int maxn=10005;
struct node{
    int p,k;
}a[maxn];
int f[maxn*3];
bool cmp(node x,node y){
    return x.k<y.k;
}
int main(){
    int i,n,ans=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++){
        scanf("%d %d",&a[i].p,&a[i].k);
    }
    sort(a+1,a+1+n,cmp);//按结束时间排序
    for(i=1;i<=n;i++){
        if(a[i].p==0)f[a[i].k]=max(a[i].k,f[a[i].k]);
        else {//f[a[i].k]=max(max(f[a[i].k],f[a[i].p]+a[i].k-a[i].p),f[a[i].p-1]+a[i].k-a[i].p);
             for(int j=a[i].p;j>=0;j--){//寻找开始时间之前的最大利用时间
                f[a[i].k]=max(f[a[i].k],f[j]+a[i].k-a[i].p);
             }
        }
    }
    for(i=0;i<=a[n].k;i++){
        ans=max(ans,f[i]);
```
}//最后再扫一遍找最大利用时间
    printf("%d",ans);

    return 0;

}


---


# [SHOI2001] 排序工作量之新任务

## 题目描述

假设我们将序列中第 $i$ 件物品的参数定义为 $A_i$，那么排序就是指将 $A_1, \cdots ,A_n$ 从小到大排序。若 $i<j$ 且 $A_i>A_j$ ，则 $(i,j)$ 就为一个“逆序对”。SORT 公司是一个专门为用户提供排序服务的公司，他们的收费标准就是被要求排序物品的“逆序对”的个数，简称“逆序数”。

Grant 是这家公司的排序员，他想知道对于 $n$ 个参数都不同的物品组成的序列集合中，逆序对数为 $t$ 的物品有多少个，并试给出其中一个最小的物品序列。所谓最小，即若有两个物品序列 $(A_1,A_2,\cdots ,A_n)$，$(B_1,B_2,\cdots ,B_n)$，存在 $1 \le i \le n$，使得 $(A_1,A_2,\cdots ,A_{i-1})=(B_1,B_2,\cdots,B_{i-1})$ 且$A_i<B_i$。


## 样例 #1

### 输入

```
4 3```

### 输出

```
6
1 4 3 2```

# 题解

## 作者：QQQfy (赞：28)

## 简单的DP+~~毒瘤的~~简单的贪心

#### 0. 闲聊

秒出方程，然后输出方案懵比了。。。以为是一般套路在dp里记录方案。。。然而~~居然~~是个贪心（逃

#### 1.dp状态

$dp[i][j]$表示前$i$个数，已经出现了$j$个逆序对

#### 2.转移方程

$dp[i][j]=\sum_{k<=j}{dp[i-1][j-k]}$

~~很好理解啊~~

这里要注意$k$的取值范围是$0$至$i-1$,然后再判断$j>=k$

因为只确定了前$i-1$个的总数，加上一个新数最多使逆序对数增多$i-1$个。

#### 3.边界

$dp[1][0]=1$,就是第一个数，没有逆序对（废话人家一个数当然是单身狗

第一问答案就在$dp[n][t]$中

#### 4.贪心

从后往前列举，找第一个比当前数小的数，交换，这样可以使得每次交换只增多一个逆序对，由于是从后往前列举，就使得字典序最小了

~~我在口胡些什么~~

大家结合代码手动~~膜~~模拟一遍就知道了

#### 5.喜闻乐见的代码

```cpp
#include<bits/stdc++.h>
using namespace std;

long long a[30],dp[30][300],n,t;

int main()
{
	cin>>n>>t;
	for (int i=1;i<=n;i++) a[i]=i;
	if (t==0)
	{//特判
		cout<<1<<endl;
		for (int i=1;i<=n;i++) cout<<i<<" ";
		return 0;
	}
    //dp
	dp[1][0]=1;
	for (int i=2;i<=n;i++)
		for (int j=0;j<=i*(i-1)/2;j++)
			for (int k=0;k<i;k++)
				if (j>=k) dp[i][j]+=dp[i-1][j-k];
	cout<<dp[n][t]<<endl;
	//贪心
    for (int i=n-1;i>=1;i--)
		for (int j=n;j>i;j--)
		{
			t--;
			swap(a[i],a[j]);
			if (t==0) 
			{
				for (int k=1;k<=n;k++) cout<<a[k]<<" ";
				return 0;
			}
		}
	return 0;
}
```



### 6.我要赞qwq

---

## 作者：0xFF (赞：2)

#### 题目大意


------------
给定一个 $n$ 和一个 $t$，表示一个长度为 $n$ 的无重复元素的序列中逆序对的个数为 $t$。输出一共有多少种满足题设的序列，输出个数以及其中字典序最小的序列。

#### 思路分析


------------
很容易就能想到是一道动态规划题目，因为显然无后效性且满足最优化原则。

##### 状态设计
$f(i,j)$ 表示前 $i$ 个数中总共有 $j$ 个逆序对。

##### 状态转移
考虑每一步都是由前一步推得的，第 $i$ 个数字最多能与前面 $i-1$ 个数字形成新逆序对故可以推得状态转移方程

$ f(i,j) = \sum f(i-1,j-k) $  

$k$ 的范围是 $(0,i)$ 并且 $(k \le j)$。

##### 边界条件
显然 $f(1,0) = 1, f(2,0) = 1,f(2,1) = 1$

所以第一行答案就是 $f(n,t)$。

构造一种可行的方案可以考虑贪心构造。

从后往前枚举，找到第一个比当前数小的数就交换，这样每次只会增加一个逆序对且由于是从后往前操作，可以保证字典序最小。

最后，不要忘记特判 $t = 0$ 的情况（直接顺序输出 $1-n$ 即可）。

#### 代码实现

------------

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#define int long long

using namespace std;
const int N = 550;

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
    return x*f;
}
int ans[N],f[N][N];
signed main(){
	int n = read() , t = read();
	if(t == 0){
		printf("1\n");
		for(int i=1;i<=n;i++){
			printf("%lld ",i);
		}
		return 0;
	}
	f[1][0] = 1;
	f[2][0] = 1 , f[2][1] = 1;
	for(int i=3;i<=n;i++){
		for(int j=0;j<=i*(i-1)/2;j++){
			for(int k=0;k<=i-1;k++){
				if(j >= k)
					f[i][j] += f[i-1][j-k];
			}
		}
	}
	printf("%lld\n",f[n][t]);
	for(int i=1;i<=n;i++){
		ans[i] = i;
	}
	int cnt = 0;
	for(int i=n-1;i>=1;i--){
		for(int j=n;j>i;j--){
			cnt++;
			swap(ans[i],ans[j]);
			if(cnt == t){
				for(int i=1;i<=n;i++){
					printf("%lld ",ans[i]);
				}					
				return 0;
			}
		}
	}
	return 0;
}
```


---

## 作者：wangqianyu (赞：2)

       
     
           
   
             
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
long long f[30][300];  //动态规划求第一问
int ans[30]; //全排列
int main()
{  int n,t;
     cin>>n>>t;
       if (t==0) {cout<<'1'<<endl; for (int i=1;i<=n;i++) cout<<i<<' '; return 0;}//特殊情况（无逆序列）
     f[1][0]=1; f[2][0]=1; f[2][1]=1; 
      for(int i=3;i<=n;i++)
        for (int j=0;j<=i*(i-1)/2;j++)
          for (int k=0;k<i;k++)
           if (j>=k) f[i][j]+=f[i-1][j-k];
           cout<<f[n][t]<<endl;
      int p=0;    
         for (int i=1;i<=n;i++) ans[i]=i;
    for (int i=n-1;i>=1;i--)    //从后往前每个位子上找当前位子上数大一的数交换（保证逆序对加1且最小）
      for (int j=n;j>i;j--)    
        {  p++;
           swap(ans[i],ans[j]);
           if (p==t) {for (int i=1;i<=n;i++) cout<<ans[i]<<' '; return 0;} 
        }    
    return 0;
}
```

---

## 作者：functionendless (赞：2)

第一小问动归解决；

第二小问只交换相邻两数达到使逆序对只加一的目的。

时间复杂度O（tn）

    
    
```cpp
#include<cstdio>
#include<cstring>
int i,j,k,n,t,p;
long long f[21][211];
int ans[21];
short rec[21];
int swap(int &a, int &b)
{
    int t=ans[a];
    ans[a]=ans[b];
    ans[b]=t;
}
int main()
{
    memset(f,0,sizeof(f));
    scanf("%d%d",&n,&t);
    if (n==1)
    {
        printf("1\n1");
        return 0;
    }
    f[2][1]=1; f[2][0]=1;
    for (i=3; i<=n; i++)
        for (j=0; j<=i*(i-1)/2; j++)
            for (k=0; k<i; k++)
                if (j>=k) 
                   f[i][j]+=f[i-1][j-k];                        
    printf("%lld\n",f[n][t]);
    for (i=1; i<=n; i++)
      ans[i]=i;
    for (i=1; i<=t; i++)
    {
        memset(rec,0,sizeof(rec));
        p=n;
        rec[ans[p]]=p;
        while (rec[ans[p-1]+1] == 0) {p--; rec[ans[p]]=p;}
        int a=p-1,b=rec[ans[p-1]+1];
        swap(a,b);
    }
    for (i=1; i<=n; i++)
      printf("%d ",ans[i]);
    return 0;
}

```

---

## 作者：_std_O2 (赞：1)

## 分析
注意到 $n\le20$ 我的第一个反应是搜索，打出暴力发现第一问的答案有规律:

$
1\\
1~1\\
1~ 2~ 2~ 1\\
1~ 3~ 5 ~6~ 5~ 3 ~1\\
1~ 4~ 9~ 15~ 20~ 22~ 20~ 15~ 9~ 4 \\
$

瞪眼大法注意到有 $\Large f_{i,j}=f_{i,j-1}+f_{i-1,j}-f_{i-1,j-i}$ 这样的关系，其中 $f_{i,j}$ 表示有 $n$ 个数，$j$ 个逆序对的序列数量。

不难发现这就是个容斥原理，所以方程的正确性也是显而易见的了。

对于第二问，硬控了我整整二十分钟，其实这就是个贪心，要求字典序最小的那个序列，所以我们反向对 $a_i=i$ 这个序列进行``swap``操作，使得它有 $t$ 个逆序对就行了，具体部分看代码。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=30;int n,t;
int f[N][500];
int a[N],vis[N];
int flag=0,ans2,b[N],num;
signed main(){
	cin>>n>>t;
	for(int i=1;i<=n;i++) a[i]=i;
	f[1][0]=1;
	for(register int i=1;i<=n;i++){
		for(register int k=0;k<=i*(i-1)/2;k++){
			if(k>0 && k-i>=0 )f[i][k]=f[i][k-1]+f[i-1][k]-f[i-1][k-i];
			else if(k>0 && k-i<0) f[i][k]=f[i][k-1]+f[i-1][k];
			else f[i][k]=1;
		}
	}
	cout<<f[n][t]<<endl;
	for(int i=n-1;i>=1;i--){
		for(int j=n;j>i;j--){
            if(num==t){
				for(int i=1;i<=n;i++) cout<<a[i]<<" ";
				return 0; 
			}
            num++;
			swap(a[i],a[j]);
            if(num==t){
				for(int i=1;i<=n;i++) cout<<a[i]<<" ";
				return 0; 
			}
		}
	}
}

```

---

## 作者：yutong_Seafloor (赞：1)

# [题目在这里 · P2528 排序工作量之新任务 ](https://www.luogu.com.cn/problem/P2528) 

### 题目简要：
给你一个长度为 $n$ 的无重复元素的序列，序列中逆序对的个数为 $t$。问你一共有多少种满足以上条件设的序列，输出序列个数以及字典序最小的序列。

------------
### 题意分析
题一共两问我们逐一分析：

第一问：

虽然本题目并没有打上 dp 的标签，但是这题比较明显是一个 dp，我们现在只需要 $t$ 个逆序对，那么我们可以想到我们需要插入数字以便得到逆序对。

接下来是重点（敲黑板）：

假如我们现在已经有 $i-1$ 个数字和 $k$ 个逆序对，现在我们要加入 $i$ 这个数字，加入以后有两种情况：

1. 不产生逆序对，例如 $1$，$2$，$3$，$4$，$6$ 中要插入 $5$，这时候把 $5$ 插入在 $4$ 和 $6$ 中间，不产生逆序对。
2. 产生逆序对，最多产生 $i-1$ 个，例如 $5$，$4$，$3$，$2$，$1$ 要插入 $6$，把 $6$ 放在第一个，即可产生逆序对 $(6,5)$，$(6,4)$，$(6,3)$，$(6,2)$，$(6,1)$ 共 $5$ 个逆序对。

由此我们得到转移方程：

$$dp_{i,j}=\sum_{k=0}^{i-1}dp_{i-1,j-k}$$

即 $dp_{n,t}$。

第二问：

出于某些缘故，我现在一看到构建方案就想贪心，当然，此题也支持用贪心做题。

我们直接从后往前找，找到第一个比这个数小的数然后互换，直到满足要求即可。

因为要满足字典序最小，所以我们需要从后边开始找，要不然你的字典序是最大的。



------------


但是此题有一个坑，~~因为这个 WA 好几次~~。

假如 $t$ 为 $0$，那就是没有逆序对，所以数量是 $1$，序列是一个从 $1$ 到 $n$ 的序列即可。

------------
## 代码 
```cpp 
#include <bits/stdc++.h>
using namespace std;
long long n,t,a[200],cnt,dp[200][200],i,j,l;
int main()
{
	cin>>n>>t;
	if(t==0)//特判注意
	{
		cout<<"1\n";
		for(i=1;i<=n;i++)
		cout<<i<<" ";
		return 0;
	}
	dp[1][0]=1;
    //第一问
	for(i=2;i<=n;i++)
	for(j=0;j<=i*(i-1)/2;j++)
	for(l=0;l<i;l++)
	if(j>=l)
	dp[i][j]+=dp[i-1][j-l]; 
	cout<<dp[n][t]<<endl;
    //第二问
	for(i=1;i<=n;i++)
	a[i]=i;
	for(i=n-1;i>=1;i--)
	for(j=n;j>i;j--)
	{
		cnt++;
		swap(a[i],a[j]);
		if(cnt==t)
		{
			for(l=1;l<=n;l++)
			cout<<a[l]<<" ";
			return 0;
		}
	}
	return 0;
}//by·yutong_Seafloor
```
此题提醒：记得开 `long long`。

---

## 作者：xz001 (赞：0)

- 第一问经典的动态规划，设立 $f_{i,j}$ 表示前 $i$ 个元素，逆序对数为 $j$ 的方案数，我们需要考虑增加第 $i$ 个元素后增加的逆序对数，显然是在 $[0,i)$ 之间的，因此转移为 $f_{i,j}=\sum_{k=0}^{\min(i-1,j)}f_{i-1,j-k} $。
- 第二问的话为了让字典序最小，我们优先在序列后面交换，交换 $t$ 次即可。
- 时间复杂度 $O(nt+n^2)$，代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

// define
#define re register
#define fi first
#define se second
#define il inline
#define co const
#define ls (u << 1)
#define rs (u << 1 | 1)
#define fup(x, l, r) for (re int x = (l), eNd = (r); x <= eNd; ++ x )
#define fdw(x, r, l) for (re int x = (r), eNd = (l); x >= eNd; -- x )
#define int long long

// typedef
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

// const
const int N = 1e6 + 10, M = 2e6 + 10;
const int INF = 2e9, P = 998244353;
const double eps = 1e-6;

int f[105][10005], n, t, a[105]; 

signed main() {
    scanf("%lld%lld", &n, &t);
    f[1][0] = 1;
    for (int i = 1; i <= n; ++ i) a[i] = i;
    for (int i = 2; i <= n; ++ i) {
    	for (int j = 0; j <= i * (i - 1) / 2; ++ j) {
    		for (int k = 0; k <= min(i - 1, j); ++ k) {
    			f[i][j] = (f[i][j] + f[i - 1][j - k]);
			} 
		}
	}
	printf("%lld\n", f[n][t]);
	if (!t) {
		for (int k = 1; k <= n; ++ k) printf("%lld ", a[k]);
		return 0;
	}
	for (int i = n - 1; i >= 1; -- i) {
		for (int j = n; j > i; -- j) {
			-- t;
			swap(a[i], a[j]);
			if (!t) {
				for (int k = 1; k <= n; ++ k) printf("%lld ", a[k]);
				return 0;
			}
		}
	}
	return 0;
}


```

---

## 作者：Forg1weN (赞：0)

## 题面
在 $1$ 到 $n$ 的排列中，求出逆序对为 $t$ 的方案数并输出最小字典序的方案。

$n\le 20$。

## Solution

记 $f_{i,j}$ 表示前 $i$ 个数字有 $j$ 对逆序对的方案数。

由于只需要有 $j$ 个逆序对，但是怎么产生逆序对我们不考虑。

所以要考虑怎么样增加逆序对，记当前数字为 $i-1$ 且有 $k$ 个逆序对。

那么当 $i$ 这个数字加进来的时候，我们一定能将其放在一定的位置上，产生一定的逆序对。

则最少就是不产生逆序对，最多可以产生 $i-1$ 对逆序对。

可得转移： $f_{i,j}=\sum\limits_{k=0}^{i-1} f_{i-1,j-k}$。

关于正确性，如果每次都产生最大的贡献，那显然序列就是 $n,n-1,\dots 1$。

如果每次都没有贡献，那么显然序列就是 $1,2,\dots n$。

进一步的，现在已经得到一个排列 $a_1,a_2,\dots a_{i-1}$，想要得到一个逆序对，就插入 $a_{i-2}$ 和 $a_{i-1}$ 中间，两个则插入位置左移一位，以此类推。

最后要求一个字典序最小的排序，考虑固定前 $i$ 个位置，让 $i+1\dots n$ 内部循环产生逆序对，从后往前暴力枚举。

关于正确性，产生两个逆序对显然为 $a_{n-1},a_{n},a_{n-2}$，产生三个逆序对显然为 $a_{n},a_{n-1},a_{n-2}$。每一次交换会且仅会产生一个逆序对，即最后一个数相较于队头的数字小一，逆序对多一，而这样子字典序易得是该逆序对最小的

## code
易得，略去。





---

## 作者：__Allen_123__ (赞：0)

### 题意简述

给定一个长度为 $n$ 的无重复数字序列，其逆序对个数为 $t$。求出：

（1）有多少个序列满足条件；

（2）若序列是 $1\sim n$ 的全排列，请输出满足条件的字典序最小的序列。

### 题目分析

#### 第一问：DP

我们设数组 $dp_{i, j}$ 代表考虑了前 $i$ 个数，有 $j$ 个逆序对的满足条件的序列总数。

由于只有一个数时无法构成逆序对，所以 $dp_{1,0}=1$。

设我们在一个原来长度为 $n$ 的序列中在最后插入一个数，那么就可以多形成 $0\sim n$ 个逆序对（原因显而易见，当插入的是序列中最小值时可以和前面任何一个数形成逆序对，是最大值时无法形成任何逆序对）。

那么，当我们已经考虑了前 $i$ 个数，逆序对的个数为 $j$ 时，如果去除最后一个数，序列可能减少的逆序对个数就为 $0\sim j-i$。我们只需要把这一部分内的 $dp$ 数组的值加起来就可以了。

所以，这道题的状态转移方程就是：

$$dp_{i,j}=\sum_{k=0}^{k<i, k\le j}dp_{i-1, j-k}$$

显而易见地，最终答案即为 $dp_{n,t}$。

#### 第二问：贪心

由于我们要输出字典序最小的那一个序列，所以我们初始就要让序列的字典序尽量小。在 $1\sim n$ 的全排列中，字典序最小的那一个就是 $1,2,3,\cdots,n$，此时逆序对的数量为 $0$。将其设为初始的序列。

为了构造出 $t$ 个逆序对，我们可以从后往前遍历序列，找到第一个比当前数小的数就交换，这样每次只会增加一个逆序对。由于是从后往前遍历，可以保证字典序最小。当逆序对的数量到达 $t$ 的时候立即停止遍历，输出此时序列即可。

注意：答案可能会超出 `int` 范围，且 $t=0$ 时需要特判（此时无逆序对，仅有一种情况，即为 $1,2,3,\cdots,n$）。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 205; 
long long n, t, a[MAXN], cnt = 0, dp[MAXN][MAXN];
int main(){
	scanf("%lld%lld", &n, &t);
	if(t == 0){ // 特判 t = 0 情况
		printf("1\n");
		for(int i = 1;i <= n;i++){
			printf("%d ", i);
		}
		return 0;
	}
    // 第一问
	dp[1][0] = 1; // 设置边界条件
	for(int i = 2;i <= n;i++){ // 开始 DP
		for(int j = 0;j <= i * (i - 1) / 2;j++){
			for(int k = 0;k < i && k <= j;k++){
				dp[i][j] += dp[i - 1][j - k]; 
			}
		}
	}
	printf("%lld\n", dp[n][t]);
	// 第二问，cnt 代表已构造出的逆序对个数
	for(int i = 1;i <= n;i++){ // 初始序列即为 1~n
		a[i] = i;
	}
	for(int i = n - 1;i >= 1;i--){
		for(int j = n;j > i;j--){
			cnt++;
			swap(a[i], a[j]);
			if(cnt == t){
				for(int i = 1;i <= n;i++){
					printf("%lld ", a[i]);
				}
				return 0;
			}
		}
	}
	return 0;
}
```

---

## 作者：DennyQi (赞：0)

关于第二问，有一种比较好理解的做法。题目要求字典序最小，所以从前往后对于每一个位置放置的数越小越好。由于已知哪些数已经用过哪些数没用过，所以利用之前的DP数组可以计算出当前放某一个数是否可行。

例如，就样例来说。先考虑第一个位置放1.此时后面的n-1个数需要有t个逆序对——判定dp[n-1][t]是否大于零即可。然后考虑第二个位置，如果放2，则dp[n-2][t]必须大于零，不可行，因此考虑放3，此时除了后面的n-2个数，3的放置还会产生1个逆序对，因为2还没有放。

对于一般情况，对于一个位置$i$，从小到大找出还没有用过的数备选。计算还没有使用过的并且比$i$小的数字的个数$cnt$，判断dp[n-i][t-cnt]是否大于0即可。

是一个类似于贪心+DP的东西……

复杂度是$O(n^2)$

```cpp
/*By DennyQi 2019*/
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;
const int INF = 0x3f3f3f3f;
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' && (c < '0' || c > '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x<<3) + (x<<1) + c - '0'; return x * w;
}
int n,t,cnt;
int dp[25][400],ans[25],used[25];
signed main(){
//	freopen(".in","r",stdin);
	n = read(), t = read();
	dp[0][0] = 1;
	dp[1][0] = 1;
	for(int i = 2; i <= n; ++i){
		for(int j = 0; j <= min(t,i*(i-1)/2); ++j){
			for(int k = 0; k <= min(i-1,j); ++k){
				dp[i][j] += dp[i-1][j-k];
			}
		}
	}
	printf("%lld\n",dp[n][t]);
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= n; ++j){
			if(!used[j]){
				cnt = 0;
				for(int k = 1; k < j; ++k){
					if(!used[k]) ++cnt;
				}
				if(dp[n-i][t-cnt] > 0){
					ans[i] = j;
					used[j] = 1;
					t -= cnt;
					break;
				}
			}
		}
	}
	for(int i = 1; i <= n; ++i){
		printf("%lld ",ans[i]);
	}
	return 0;
}
```


---

## 作者：依依 (赞：0)

正解：

第一问DP：

f[i][j]表示前i个物品有j个逆序对的排列方案数

转移:f[i][j]+=f[i-1][j-k] (j>=k)   

第二问贪心：

要求的是字典序最小的序列，那么我们从后往前不断地交换序列，

当出现t个逆序对时，即为解。   
[你点开看看就知道了](http://www.cnblogs.com/adelalove/p/8630775.html)

---


# [AHOI2002] 网络传输

## 题目描述

在计算机网络中所有数据都是以二进制形式来传输的。但是在进行较大数据的传输时，直接使用该数的二进制形式加以传输则往往传输的位数过多。譬如要传输 $1024$ 就需要 $11$ 位二进制数。于是小可可提出了一种数据优化传输的设想，并打算对这一设想进行试验。

该设想是：正整数的所有方幂以及任意多个互不相等的 $k$ 的方幂之和排成一个递增数列 $\{a(k)n\}$，例如当 $k=3$ 时，$\{a(k)n\}$ 的前 $7$ 项为 $1(=3^0)$ 、 $3(=3^1)$ 、 $4(=3^0+3^1)$ 、 $9(=3^2)$ 、 $10(=3^0+3^2)$ 、 $12(=3^1+3^2)$ 、 $13(=3^0+3^1+3^2)$。

如果数 $d$ 是数列 $\{a(k)n\}$ 中的第 $p$ 项，则可以通过传送 $k$ 和 $p$ 这两个数来表示数 $d$。由于 $k$ 和 $p$ 这两个相对很小的数就可以表达出很大的数，因而理论上可以减少网络传输的位数。

小可可现在请你编写程序把接收到的数 $k$ 和 $p$ 所代表的数 $d$ 计算出来。

## 样例 #1

### 输入

```
3 2```

### 输出

```
3```

## 样例 #2

### 输入

```
3 7```

### 输出

```
13```

# 题解

## 作者：八重樱飞 (赞：17)

这道题其实可以~~找规律~~用动态规划来做哒！

我们以样例为基础，看看规律吧！

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: |
| 3^0 | 3^1 | 3^0+3^1 | 3^2 | 3^0+3^2 | 3^1+3^2 | 3^0+3^1+3^2 | 3^3 | 3^0+3^3 | 3^1+3^3 | 3^0+3^1+3^3 | 3^2+3^3 | 3^0+3^2+3^3 | 3^1+3^2+3^3 | 3^0+3^1+3^2+3^3 | 3^4 |



相信一定有冰雪聪明的孩纸发现了规律，我们再用已知编号（<=当前编号）填一个表，~~我相信~~你一定会发现其中的奥妙滴！


| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: |
| 1 | 2 |  1+2  | 4 | 1+4 | 2+4 | 3+4 | 8 | 1+8 | 2+8 | 3+8 | 4+8 | 5+8 | 6+8 | 7+8 | 16 |


发现规律了吧！

单个编号（无+）的都是2^n次方，然后就又开始了一个新轮回。

我们设当前编号为i（2^n<i<2^n+1）,当前的数为a[i]。

那么a[i]=a[n]+a[i%n]
(或a[i]=a[n]+a[i-n] )

找到规律就很好办了，接下来就是各位孩纸们最爱的---代码上场了！！


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int k,p;
long long a[10000]={0};
long long pow(int a,int b)//快速幂（毕竟是算幂） 
{
    long long re=1,base=a;
    while(b)
    {
        if(b&1)re=re*base;
        base=base*base;
        b>>=1;
    }
    return re;
}
int log2(int x)//高中孩纸都知道的（log2x=i就是 2^i=x） 
{
    int i,s=1;
    for(i=1;i<=x;i++)
    {
        s=s*2;
        if(s==x)break;
    }
    return i;
}
int main()
{
    int n=0,i,c;
    scanf("%d%d",&k,&p);
	a[1]=1;//初始化 
    for(i=2;i<=p;i=i*2)//预处理，把每个单独的编号（2^i)算出来 
    {
        c=log2(i);
        a[i]=pow(k,c);
    }
    for(i=2;i<=p;i++)
    {
        if(a[i]!=0)//如果不为0，一定开始了一个新轮回 
        {
            n=i;
            continue;
        }
        a[i]=a[i%n]+a[n];//动态规划方程式搬出来
    } 
    printf("%lld",a[p]);
    return 0; 
}
```

当然，看这数据规模一定是要用高精度的滴！

所以劳烦各位打个高精度。

然后便可以看见一片绿色，再加一朵大红花。

蒟蒻第一次写题解···

若有不懂或有问题，尽情指正，蒟蒻愿洗耳恭听 大佬们的指正。

---

## 作者：partychicken (赞：11)

## python秒A，发篇题解庆祝一下
其实不nan，简单大力递推即可，但要写高精就很气，于是果断py
```python
a,b=map(int,input().split())
f=[]
last=1
now=0
num=0
while 1:
    f.append(last)
    num+=1
    now=num
    last*=a
    for i in range(0,now-1):
        f.append(f[now-1]+f[i])
        num+=1
    if num>=b:
        print(f[b-1])
        break
```


---

## 作者：kkxhh (赞：11)

分析题目后可以得知，将 **p** 分解成二进制后如果第 **i** 位是1答案就加 **k**的 **i-1** 次方，于是直接用两个数组模拟就行了

代码如下

```cpp
#include <cstdio>
using namespace std;

int k,p,ans[60]={0},x[60]={0,1};

int main(){
    scanf("%d %d",&k,&p);
    while(p){
        if(p&1){
            for(int i=1;i<=50;i++) ans[i]+=x[i];
            for(int i=1;i<=49;i++) ans[i+1]+=ans[i]/10,ans[i]=ans[i]%10;
        }
        for(int i=1;i<=50;i++) x[i]*=k;
        for(int i=1;i<=49;i++) x[i+1]+=x[i]/10,x[i]=x[i]%10;
        p=p>>1;
    }
    for(int i=50,t=0;i>=1;i--) {if(ans[i]) t=1; if(t) printf("%d",ans[i]);}
    return 0;
}

```

---

## 作者：xh2010 (赞：3)

很好奇这道题为什么没人解答（这似乎是一道水题）。

如果仔细看一下题，会发现这题似乎与栈和DP毫无关联。

首先，我们将数列中所有数转化为k进制，发现第一项为1，第二项为10，第三项为11，因此第p项所代表的是p的二进制表达式。

我们先将p的二进制求出，然后用高精度，答案就出来了。

下面献上丑陋的代码：



    
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<stack>
#include<queue>
#include<map>
#include<list>
#include<functional>
#include<vector>
#include<set>
#include<cctype>
#include<ctime>
#include<cstdlib>
#include<algorithm>
using namespace std;
int k,p;
int a[20];
int c[20][55];
void init()
{
    memset(c,0,sizeof(c));
    c[0][1]=1;
    int l=1;
    for (int i=1;i<=11;i++)
    {
        for (int j=1;j<=l;j++)
            c[i][j]=c[i-1][j];
        for (int j=1;j<=l;j++)
            c[i][j]*=k;
        for (int j=1;j<=l;j++)
        {
            c[i][j+1]+=c[i][j]/10;
            c[i][j]%=10;
        }
        while (l<=53)
        {
            c[i][l+1]+=c[i][l]/10;
            c[i][l]%=10;
            l++;
        }
        l--;
    } 
}
int main()
{
    scanf("%d%d",&k,&p);
    memset(a,0,sizeof(a));
    int x=0;
    while (p>0)
    {
        a[x]=p%2;
        p>>=1;
        x++;
    }
    x--;
    init();
    int ans[55];
    memset(ans,0,sizeof(ans));
    for (int i=0;i<=x;i++)
        if (a[i])
            for (int j=1;j<=54;j++)
            {
                ans[j]+=c[i][j];
                ans[j+1]+=ans[j]/10;
                ans[j]%=10;
            }
    int l=54;
    while (!ans[l])
          l--;
    for (int i=l;i>=1;i--)
        printf("%d",ans[i]);
}
```

---

## 作者：Ginger_he (赞：2)

本文同步更新于[博客园](https://www.cnblogs.com/Gingerhe/p/15924894.html)
# 题目描述
求由多个互不相等的 $k$ 的方幂之和构成的第 $p$ 小的数。
# 题解
因为题目要求选择互不相等的 $k$ 的方幂之和，所以每种方幂只有选或不选两种情况。我们用 $a_i$ 表示是否选 $k^i$，则 $\sum 2^{a_i}=p$。因此我们在二进制下枚举 $p$ 的每一位即可，记得用 `__int128` 或 `高精度`。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
void write(int x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
int k,p,res,ans;
signed main()
{
	k=read(),p=read();
	for(int i=0;i<=11;i++)
	{
		if(!i) res=1;
		else res*=k;
		if(p&(1<<i))
			ans+=res;
	}
	write(ans);
	return 0;
}
```

---

## 作者：hanzhongtlx (赞：2)

## [更好的阅读体验点这里](https://www.cnblogs.com/tlx-blog/p/12709407.html)
题目链接：[P2558 [AHOI2002]网络传输](https://www.luogu.com.cn/problem/P2558)   
$dp$ 入门题，结果调了一晚上，枯了。   
很显然 $x^{n+1}>\sum\limits_{i=0}^n x^n$，那么我们对于每个次方数，加上他前面的任意数的组合一定小于下一个次方数。  
容易得到：
$$f_{i}=f_{2^{\left\lfloor\log_{2}i\right\rfloor}}+f_{i-2^{\left\lfloor\log_{2}i\right\rfloor}}$$   
可以递推实现。   
然而我们发现最后的结果小于 $2^{50}$ ，高精好麻烦啊！  
鉴于 $50$ 比较小，我们尝试压位。  
把一个数定义成结构体形式：
```
struct num
{
	ll a,b,c,d;
};
```   
考虑到  $\left\lceil\dfrac{50}{4}\right\rceil=13$ 在`long long`范围完全可以接受，于是把一个数分成四块。  
然后定义运算就好了：  
加法：
```
num add(num x,num y)
{
	num z;
	z.a=z.b=z.c=0;
	z.a=y.a+x.a;
	z.b=y.b+x.b;
	z.c=y.c+x.c;
	z.d=y.d+x.d;
	return arrg(z);
}
```  
这里的`arrg`函数是把不符合一块内最多 $13$ 位的数整理成符合条件的数。  
可以这样写：
```
#define MOD 10000000000000
num arrg(num x)
{
	num z=x;
	if(z.a>=MOD) z.b+=z.a/MOD,z.a%=MOD;
	if(z.b>=MOD) z.c+=z.b/MOD,z.b%=MOD;
	if(z.c>=MOD) z.d+=z.c/MOD,z.c%=MOD;
	return z;
}
```  
然后还有普通数乘分块数：
```
num mul(num x,ll k)
{
	num z;
	z.a=z.b=z.c=0;
	z.a=x.a*k;
	z.b=x.b*k;
	z.c=x.c*k;
	z.d=x.d*k;
	return arrg(z);
}
```
这样，我们就减少了原要写高精的码量（~~bushi,输出打的我焦头烂额~~。   
时间复杂度为 $\mathcal O(p)$，可以通过本题。   
完整代码如下：
```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
using namespace std;

#define ll long long  
#define MOD 10000000000000

struct num
{
	ll a,b,c,d;
	//压13位 
}ans[1030],mi[20];
int n,p,cnt=0;

num arrg(num x)
{
	num z=x;
	if(z.a>=MOD) z.b+=z.a/MOD,z.a%=MOD;
	if(z.b>=MOD) z.c+=z.b/MOD,z.b%=MOD;
	if(z.c>=MOD) z.d+=z.c/MOD,z.c%=MOD;
	return z;
}

num add(num x,num y)
{
	num z;
	z.a=z.b=z.c=0;
	z.a=y.a+x.a;
	z.b=y.b+x.b;
	z.c=y.c+x.c;
	z.d=y.d+x.d;
	return arrg(z);
}

num mul(num x,ll k)
{
	num z;
	z.a=z.b=z.c=0;
	z.a=x.a*k;
	z.b=x.b*k;
	z.c=x.c*k;
	z.d=x.d*k;
	return arrg(z);
}

int logx(int a,int b){return ceil(log(b)/log(a));}
ll _pow(ll a,ll b){ll ans=1;for(int i=1;i<=b;i++) ans*=a;return ans;}


int main()
{
	scanf("%d%d",&n,&p);
	mi[0].a=1ll,mi[0].b=0,mi[0].c=0,mi[0].d=0;
	ans[++cnt]=mi[0];
	for(int i=1;i<=logx(2,p)+1;i++) mi[i]=mul(mi[i-1],(ll)n);
	if(p==1){printf("1\n");return 0;}
	int k=1;
	for(;;)
	{
		ans[++cnt]=mi[k++];
		if(cnt>=p) break;
		int now=cnt-1;
		for(int j=1;j<=now&&cnt<=p;j++) ans[++cnt]=add(ans[now+1],ans[j]);
		if(cnt>=p) break;
	}
	ans[p]=arrg(ans[p]);
	if(ans[p].d!=0)
	{
		printf("%lld",ans[p].d);
		for(int i=12;i>=0;i--)
		{
			ll g=_pow((ll)10,i);
			printf("%d",(int)(ans[p].c/g));
			ans[p].c%=g;
		}
		for(int i=12;i>=0;i--)
		{
			ll g=_pow((ll)10,i);
			printf("%d",(int)(ans[p].b/g));
			ans[p].b%=g;
		}
		for(int i=12;i>=0;i--)
		{
			ll g=_pow((ll)10,i);
			printf("%d",(int)(ans[p].a/g));
			ans[cnt].a%=g;
		}
	} 
	else if(ans[p].c!=0)
	{
		printf("%lld",ans[p].c);
		for(int i=12;i>=0;i--)
		{
			ll g=_pow((ll)10,i);
			printf("%d",(int)(ans[p].b/g));
			ans[p].b%=g;
		}
		for(int i=12;i>=0;i--)
		{
			ll g=_pow((ll)10,i);
			printf("%d",(int)(ans[p].a/g));
			ans[p].a%=g;
		} 
	}
	else if(ans[p].b!=0)
	{
		printf("%lld",ans[p].b);
		for(int i=12;i>=0;i--)
		{
			ll g=_pow((ll)10,i);
			printf("%d",(int)(ans[p].a/g));
			ans[p].a%=g;
		}
	}
	else printf("%lld",ans[p].a);
	putchar('\n');
	return 0;
}
```  
开始我尝试把一个数分成 $3$ 块，然而爆`long long`了，只好分成 $4$ 块。

---

## 作者：Hisaishi_Kanade (赞：1)

由题意，发现这种表示就相当于相当于在幂上二进制。

以 $k=3,p=7$ 为例，$(7)_{10}=(111)_{2}$，那么结果是 $k^2+k^1+k^0=9+3+1=13$。

然后我们通过 `python` 实现即可。

复杂度 $O(\log p)$。

```cpp
k,p=map(int,input().split()) 
pre=1
y=0
ret=0
while p>0:
	if p%2==1:
		 ret+=pre 
	pre*=k
	p//=2
#	print(ret)
print(ret)
```

---

## 作者：nenugdi (赞：1)

可以观察到递增序列实际上就是二进制位的递增，从0,10,11,100....。只不过这个二进制的每一位需要乘以k的对应次幂。当我们需要求出序列的第p项时，先将p进行二进制转换得到二进制形式，再根据二进制中的值乘以k的对应位次幂可解。

例如k=4,p=9，先求出9的二进制1001，然后转换成1×4^3+0×4^2+0×4^1+1×4^0。由于明确告知答案50位，所以必须高精。下面是非高精算法，用于理解算法的处理过程。
```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
int main()
{
    ll i,j,k,p,s=1,ans=0;
    cin>>k>>p;
    while(p)
    {
        ans+=p%2*s;
        p/=2;
        s*=k;
    }
    cout<<ans;
    return 0;
}
```
高精算法，将上算法中的加法和乘法操作用函数实现。
```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
int s[105],ans[105];
void add(int a[],int b[])
{
    for(int i=0; i<=55; i++)
        a[i]+=b[i];
    for(int i=0; i<=55; i++)
        a[i+1]+=a[i]/10,a[i]%=10;
}
void mul(int a[],int k)
{
    for(int i=0; i<=55; i++)
        a[i]*=k;
    for(int i=0; i<=55; i++)
        a[i+1]+=a[i]/10,a[i]%=10;
}
int main()
{
    ll i,j,k,p,l=100;
    cin>>k>>p;
    s[0]=1;
    while(p)
    {
        if(p%2==1)
            add(ans,s);
        p/=2;
        mul(s,k);
    }
    while(ans[l]==0)l--;
    for(i=l; i>=0; i--)
        cout<<ans[i];
    return 0;
}

```


---

## 作者：issue_is_fw (赞：1)

观察当$k=3$时的数列

1，3，4，9，12，13

因为每一项都是$k^{n}$累加

所以一定可以由数列前面的某些项乘k来构造。

比如$9=3*3,12=4*3$

但是拿第2项3来说，它不仅可以构造出9，还可以构造4.

为什么呢?因为特殊的$3^{0}=1$

**所以我们得出结论**

Ⅰ.当某$a[i]$是k的倍数，那它可以构造出$a[i]*k$和$a[i]+1$

Ⅱ.当某项$a[i]$不为$k$的倍数，说明它是由前面的某一项$+1$得来的，不能再次$+1$。所以只能构造出$a[i]*k$

那就简单了。$p1$指针指向当前$*k$的构造方式

$p2$指针指向上次$+1$的构造方式

那个小就选哪个，并且指针往后挪一位

```cpp
/*不加高精度70分*/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a[1025];
int main()
{
	ll k,p;
	cin>>k>>p;
	a[1]=1,a[2]=k;
	int p1=2,p2=2,cnt=2;
	while(cnt<p)
	{
		ll q=a[p2]*k,flag=0;
		while(p1<=cnt)//寻找是否有不是k倍数的项 
		{
			if(a[p1]%k==0)
			{
				flag=1;
				break;
			}
			p1++;
		}
		if(flag)//找到k倍数的项,那就比较选哪一项 
		{
			ll w=a[p1]+1;
			if(q<w)	a[++cnt]=q,p2++;
			else	a[++cnt]=w,p1++;
		}
		else	a[++cnt]=q,p2++;
	}
	cout<<a[cnt];
}
```

高精度版本
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct bignum{
	int num[56],len;
	bignum(){memset(num,0,sizeof(num));};
}a[1029];
void init(bignum &a,string s)
{
	int len=s.length();
	for(int i=0;i<len;i++)	a.num[i]=s[len-i-1]-'0';
	a.len=len;
}
bool compare(bignum a,bignum b)
{
	if(a.len!=b.len)	return (a.len>b.len?1:0);
	for(int i=a.len-1;i>=0;i--)
	{
		if(a.num[i]==b.num[i])	continue;
		return a.num[i]>b.num[i]?1:0;
	}
	return 0;
}
bignum add(bignum a,bignum b)
{
	bignum c;
	int len=max(a.len,b.len);
	for(int i=0;i<=len;i++)
	{
		c.num[i]+=(a.num[i]+b.num[i]);
		c.num[i+1]+=c.num[i]/10;
		c.num[i]%=10;
	}
	if(c.num[len])	len++;
	c.len=len;
	return c;
}
bignum dmull(bignum a,int s)
{
	for(int i=0;i<a.len;i++)	a.num[i]*=s;
	for(int i=0;i<a.len;i++)
	{
		if(a.num[i]>=10)
		{
			a.num[i+1]+=a.num[i]/10;
			a.num[i]%=10;
			if(i==a.len-1)	a.len++;
		}
	}
	return a;
}
string zhuan(int s)
{
	string t,ans;
	while(s){
		t+=(s%10+'0');
		s/=10;
	}
	for(int i=t.length()-1;i>=0;i--)	ans+=t[i];
	return ans;
}
bool mo(bignum a,int k)
{
	ll ans=0;
	for(int i=a.len-1;i>=0;i--)
	{
		ans=ans*10+a.num[i];
		ans%=k;
	}
	if(!ans)	return true;
	return false;
}
int main()
{
	ll k,p;
	cin>>k>>p;
	init(a[1],"1");init(a[2],zhuan(k));
	int p1=2,p2=2,cnt=2;
	while(cnt<p)
	{
		bignum q=dmull(a[p2],k);
		bool flag=0;
		while(p1<=cnt)
		{
			if(mo(a[p1],k))
			{
				flag=1;
				break;
			}
			p1++;
		}
		if(flag)
		{
			bignum w=add(a[p1],a[1]);//a[1]就是1 
			if(!compare(q,w))	a[++cnt]=q,p2++;
			else	a[++cnt]=w,p1++;
		}
		else	a[++cnt]=q,p2++;
	}
	for(int i=a[cnt].len-1;i>=0;i--) 	cout<<a[cnt].num[i];
}
```


---

## 作者：hukk (赞：0)

题目： [P2558 \[AHOI2002\] 网络传输](https://www.luogu.com.cn/problem/P2558)

------

*update on 2021.12.18：修整了（英文、数字或 LaTeX 公式）与中文之间的空格的问题。*

------

题意应该比较清楚，这里就不再赘述。

## 思路

我们打这样一个表：

| 序号 $p$ | 各指数 |
| :----------: | :----------: |
| $1$ | $0$ |
| $2$ | $1$ |
| $3$ | $0,1$ |
| $4$ | $2$ |
| $5$ | $0,2$ |
| $6$ | $1,2$ |
| $7$ | $0,1,2$ |
| $8$ | $3$ |

可以发现以下几点：

- 第 $2$ 的整数次幂个的指数只有一个，是 $\log_2 p$
- 其它的可以通过二进制拆分转换成第 $2$ 的整数次幂个答案

比如：

- $6 = 2 + 4$，对应的指数是 $1,2$，分别是 $2$ 和 $4$ 的。
- $7 = 1 + 2 + 4$，对应的指数是 $0,1,2$，分别是 $1$，$2$ 和 $4$ 的。

那么，做法其实就出来了：

先对 $p$ 进行二进制拆分，再分别计算后相加。

## 代码

下面给出的是不带高精的代码，只需将代码中的 `bignum` 改成真正的高精即可 AC 。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long bignum; //此处用 unsigned long long 代替高精
int k,p;
int a[15],tot;
bignum ans;
inline int lowbit(int x){return x&(-x);} //lowbit，负责拆分
bignum qpow(bignum a,bignum p){ //快速幂
	bignum ans=1;
	while(p){
		if(p&1)ans*=a;
		p>>=1;
		a*=a;
	}
	return ans;
}
bignum mlog2(bignum x){ //log2
	int ans=0;
	while(x){
		ans++;
		x/=2;
	}
	return ans-1;
}
int main(){
	cin>>k>>p;
	while(p){
		ans+=qpow(k,mlog2(lowbit(p)));//每次加单个拆分的答案
		p-=lowbit(p); //加下一个
	}
	cout<<ans;
	return 0;
}

```

---


# [ZJOI2012] 旅游

## 题目描述

到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~

经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。

![](https://cdn.luogu.com.cn/upload/pic/1409.png) 

为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？

## 说明/提示

对于 $20\%$ 的数据，$n\le 2000$。

对于 $100\%$ 的数据，$4\le n \le 200000$。

## 样例 #1

### 输入

```
6
1 2 4
2 3 4
1 4 5
1 5 6```

### 输出

```
4```

# 题解

## 作者：Dr_Gears (赞：21)

### 先上结论
这道题仔细想想会发现，如果把每个三角形看作一个节点，领边看作一条边，那么最后生成的图一定是一个二叉树。
当然，其实二不二叉都不影响。
关键是如何证明这个结论。
### 然后上证明
嗯哼，这个道理其实很简单，但是我还是说一下。
首先，整个图是肯定联通的，毕竟本来就是一个多边形，它转换成图后肯定不存在独立的部分。
而且注意到一个特点，一个n边形能且只能分成n-2个三角形，且无论怎么分都只用连接n-3条对角线。
而在这道题中，每一条被连接起来的对角线，都等于生成图中的一条连边。
所以一共n-2个点，n-3条边。
再加上树上是不可能出现环的，而这道题中，如果形成了环，那肯定是一圈的三角形把一个点围了起来，然而节点都必须在边上，所以不可能形成环。
**呐呐，由上可知证毕。**
之后，我们知道了这是一个什么图，该思考怎样去算出答案。
### 注意到
我们的路线必须与一个城市至少有两个交点，才算是经过了这个城市，因此只经过一个顶点是没用的。
而且，我们的路线是一条线段，也就是说无法折返。由于这是一个凸多边形，至少不用担心走不过去的问题，那么问题就在于什么样的路线才是最优的。
### 又上结论
如果我们走生成图上的树的直径，那么一定是最优的。（你肯定知道树的直径是啥吧）
为什么？
因为我们无法折返，就相当于在树上走一条简单路径，因此最长的路肯定就是直径辣。
### 如何实现
我们注意到n的范围是20万，有点大，显然用数组记录三角形的邻边是肯定会炸的。但是我们有STL啊！
于是乎，pair套map映射就呼之欲出了。
至于如何找树的直径，那啥，直接O(n)dfs两遍就完事儿辣。如果不明白为什么。。。请百度（or谷歌）！。
### 最后上代码
```
#include<bits/stdc++.h>
#define fr(i,a,b) for(int i=a;i<=b;++i)
#define pr(i,a,b) for(int i=a;i>=b;--i)
#define fh(i,a,b) for(int i=head[a],b=e[i].to;i;i=e[i].last,b=e[i].to)
#define pp puts("")
#define xiu return
using namespace std;
typedef double lf;
typedef long long ll;
const int N = 2e5+10,M = 110,inf = 1e9+7;
const lf eps = 1e-5;
template <class T> void read(T &w){
	w=0;int f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){(w*=10)+=ch-'0';ch=getchar();}
	w*=f;
}

template <class T> void write(T w){
	if(w<0){putchar('-');w*=-1;}
	if(w/10) write(w/10);
	putchar(w%10+'0');
}
map <pair<int,int>,int> ys;
struct edg{int last,to;}e[N<<1];
int n,m,cur=1,head[N],deep[N],root,ans;
void add(int x,int y){
	e[++cur]=(edg){head[x],y};head[x]=cur;
	e[++cur]=(edg){head[y],x};head[y]=cur;
}
void dfs(int x,int y){
	deep[x]=deep[y]+1;
	fh(i,x,u){
		if(u==y) continue;
		dfs(u,x);
	}
}
int main(){
	read(n);
	fr(i,1,n-2){
		int p,q,r;
		read(p);read(q);read(r);
		if(q>p) swap(p,q);
		if(r>p) swap(p,r);
		if(r>q) swap(q,r);//那啥，排个序去重....少写了3个if+else，而且还省时间空间....
		if(!ys[pair<int,int>(p,q)]){
			ys[pair<int,int>(p,q)]=i;
		}
		else
			add(i,ys[pair<int,int>(p,q)]);
		if(!ys[pair<int,int>(p,r)]){
			ys[pair<int,int>(p,r)]=i;
		}
		else
			add(i,ys[pair<int,int>(p,r)]);
		if(!ys[pair<int,int>(q,r)]){
			ys[pair<int,int>(q,r)]=i;
		}
		else
			add(i,ys[pair<int,int>(q,r)]);
	}
	root=1;
	dfs(1,0);
	fr(i,2,n-2)
	if(deep[i]>deep[root])
		root=i;
	dfs(root,0);
	fr(i,1,n-2)
		if(deep[i]>ans)
		ans=deep[i];
	write(ans);pp;
	xiu 0;
}
```
~~哈哈一遍A无调试~~~

---

## 作者：Only_My_Whisper (赞：12)

#### 线段树暴力做法

眼看着楼上大佬讲的都是树直径做法，于是蒟蒻来介绍一种不需要思维的暴力。。。

这题可以转化为，多边形内的一条直线最多与多少条给定对角线相交。我们先枚举路线的一个端点i，设一条给定对角线两个顶点分别为u,v(u < v)，即将选取的另一个路线端点为j。经过观察可以得出：

1.若i < u或i > v, 且u < j < v,则路线**i->j**将经过该对角线

2.若u < i < v，且v < j <= n 或j < u,则路线**i->j**将经过该对角线

因此，可以用线段树维护区间修改，枚举**i**的同时将经过**i**的对角线转化为与顶点范围对应的类型。利用线段树区间查询最大值，选取最优的**j**。时间复杂度**O(n log n)**。开O2卡过。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lc x<<1
#define rc x<<1|1
#define max(a,b) (a) > (b) ? (a) : (b)
const int N = 2e5+1;
const int SIZ = 1e6+1;

int n;
map<int,int> m1[N];
vector<int> v1[N];
struct Segment_tree{
   int maxv[SIZ],tag[SIZ];
   inline void push_up(int x){
      maxv[x] = max(maxv[lc],maxv[rc]);
   }
   inline void push_down(int x,int l,int r){
      if(tag[x]){
         tag[lc] += tag[x]; tag[rc] += tag[x];
         maxv[lc] += tag[x]; maxv[rc] += tag[x];
         tag[x] = 0;
      }
   }
   void update(int x,int l,int r,int ql,int qr,int val){
      if(ql > qr)return ;
      if(qr < l || ql > r)return ;
      if(l >= ql && r <= qr){
         maxv[x] += val; tag[x] += val;
         return ;
      }
      push_down(x,l,r);
      update(lc,l,(l+r)/2,ql,qr,val); update(rc,(l+r)/2+1,r,ql,qr,val);
      push_up(x);
   }
   int query(int x,int l,int r,int ql,int qr){
      if(ql > qr)return 0;
      if(qr < l || ql > r)return 0;
      if(l >= ql && r <= qr)return maxv[x];
      push_down(x,l,r);
      return max(query(lc,l,(l+r)/2,ql,qr),query(rc,(l+r)/2+1,r,ql,qr));
   }
}S;

int main(){
   scanf("%d",&n);
   for(int i = 1;i <= n-2; ++i){
      int p,q,r;
      scanf("%d%d%d",&p,&q,&r);
      if(m1[p][q] == 0){
         v1[p].push_back(q); v1[q].push_back(p);
         m1[p][q] = m1[q][p] = 1;
         S.update(1,1,n,min(p,q)+1,max(p,q)-1,1);
      }
      if(!m1[p][r]){
         v1[p].push_back(r); v1[r].push_back(p);
         m1[p][r] = m1[r][p] = 1;
         S.update(1,1,n,min(p,r)+1,max(p,r)-1,1);
      }
      if(!m1[q][r]){
         v1[q].push_back(r); v1[r].push_back(q);
         m1[q][r] = m1[r][q] = 1;
         S.update(1,1,n,min(q,r)+1,max(q,r)-1,1);
      }
   }
   int ans = 2;
   for(int i = 1;i <= n; ++i){
      for(int j = 0;j < (int)v1[i].size(); ++j){
         int y = v1[i][j];
         if(y > i)S.update(1,1,n,i+1,y-1,-1);
         else {
            S.update(1,1,n,i+1,n,-1); S.update(1,1,n,1,y-1,-1);
         }
      } // 删去经过当前节点的对角线
      ans = max(ans,1+S.query(1,1,n,1,n));
      for(int j = 0;j < (int)v1[i].size(); ++j){
         int y = v1[i][j];
         if(y > i){
            S.update(1,1,n,y+1,n,1); S.update(1,1,n,1,i-1,1);
         }
         else S.update(1,1,n,y+1,i-1,1);
      }//加入经过当前节点的对角线
   }
   cout << ans << endl;
}
```



---

## 作者：Equfix (赞：8)

~~小蓝真多事~~

首先，这个题肯定不是 $n-2$。

（例如：$ans=3$,但 $n=6$）

![](https://cdn.luogu.com.cn/upload/image_hosting/5cni7ueb.png?x-oss-process=image/resize,m_lfit,h_170,w_225)


------------

那到底是多少呢？

实际上，我们发现，对于任意一条直线，它只能经过一个三角形的两条边。

所以，当有一个三角形的三边外都有三角形时，答案显然不是 $n-2$。

另外，我们看看图。

看不出来？那就看这个：

![](https://cdn.luogu.com.cn/upload/image_hosting/s4b9jwq2.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

原来是一颗二叉树！

而且，一条直线经过两条边，不刚好是这棵树上的一条链吗？

又让求最大值……直径！

现在我们有一个明确的思路了。


------------

# 关于直径
直径的求法很简单，先任意找一个点bfs出离它最远的点 $A$,再以 $A$ 开始bfs出最远点 $B$,那么 $A$,$B$ 之间的路径就是直径啦~

简单来说，如果直径的两端点不被第一次bfs出来，很显然，将该点到直径一端的路径换为该点到最长点的路径，路径只会更长，就与之前的假设矛盾。

于是，我们就很轻易地处理出一棵树的直径了。

# 关于树
首先，我们来解决一个问题：为什么这是一棵树呢？

很简单，对于任意一条对角线，都有左右（或上下）两个三角形，这样 $n-3$ 条边连接起 $n-2$ 个三角形，就是一颗树了。
### 但这棵树又要怎么存呢？
我们可以存下三角形的三个顶点，每次枚举每个三角形，判断是否相连。

**可是，单枚举，时间复杂度就是 $ O(n^{2})$ 了，肯定不行**

我们应该要预处理出边，用vector或前向星存下，之后复杂度才正确。

因每条边最多属于两个三角形，我们可以拿map记录下三角形的三条边，之后每遇到一个三角形，判断它的三边：

如果map中此边为空，记录下该三角形编号；

如果map中此边不为空，将这两三角形连出一条边。

这样，这个题就结束了。
## code：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<pair<int,int>,int>mapt;//边对三角形编号
int a[200001][4];//存三角形顶点
vector<int>e[200001];
bool mem[200001];
int len=0;
int bfs(int st){
	memset(mem,0,sizeof(mem));
	queue<int>qy;
	queue<int>qt;
	qy.push(st);
	qt.push(1);
	mem[st]=1;
	int lastx,lastt;
	while(!qy.empty()){
		int x=qy.front(),t=qt.front();
		lastx=x,lastt=t;
		qy.pop(),qt.pop();
		int _size=e[x].size();
		for(int i=0;i<_size;i++)
			if(!mem[e[x][i]]){
				mem[e[x][i]]=1;
				qy.push(e[x][i]),qt.push(t+1);
			}
	}
	len=lastt;
	return lastx;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n-2;i++){
		scanf("%d%d%d",a[i]+1,a[i]+2,a[i]+3);
		sort(a[i]+1,a[i]+4);
		if(mapt[make_pair(a[i][1],a[i][2])]){
			e[i].push_back(mapt[make_pair(a[i][1],a[i][2])]);
			e[mapt[make_pair(a[i][1],a[i][2])]].push_back(i);
		}
		else mapt[make_pair(a[i][1],a[i][2])]=i;

		if(mapt[make_pair(a[i][2],a[i][3])]){
			e[i].push_back(mapt[make_pair(a[i][2],a[i][3])]);
			e[mapt[make_pair(a[i][2],a[i][3])]].push_back(i);
		}
		else mapt[make_pair(a[i][2],a[i][3])]=i;

		if(mapt[make_pair(a[i][1],a[i][3])]){
			e[i].push_back(mapt[make_pair(a[i][1],a[i][3])]);
			e[mapt[make_pair(a[i][1],a[i][3])]].push_back(i);
		}
		else mapt[make_pair(a[i][1],a[i][3])]=i;
	}
	int a=bfs(1);
	bfs(a);
	cout<<len;
	return 0;
}
```



------------

# 一些细节
一、注意边的存法，不能一会 $(5,3)$ 一会 $(3,5)$。建议排序。

二、两次bfs,mem数组要清空！！

---

## 作者：Daniel_7216 (赞：4)

虽然题目给了三个标签，然而我们只用勉强用一个，嘿嘿嘿……

拿到题之后我一脸懵：这是神马走法？然后~~看了同校大佬的题解~~经过认真思考，我发现了这道紫题外表下其实很水！为什么？稍微画下图，你就可以发现：

- 所谓合法路线，就是下图中的红线部分：

![合法路线](https://cdn.luogu.com.cn/upload/image_hosting/8xtd1p4n.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

- 最长路径就是这一条：

![最长路径](https://cdn.luogu.com.cn/upload/image_hosting/wa2p8s5r.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

在讨论区看到有人问怎么算经过一座城市，观察第一幅图你就会发现：其实就是走到城市的一个顶点，第二个交点就在它的对边上。也就是从另一个三角形经过三角形的任意一个顶点就是合法的。根据这幅图，我们又可以进一步推出：一个三角形可以走到和它相邻的三个三角形。

![相邻](https://cdn.luogu.com.cn/upload/image_hosting/ovws2mlu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

看懂了吗？就是用 map 存一下每一条边，如果这条边被记录过了，这两个三角形之间就连一条边。因为三角形是通过连对角线连出来的，所以就不会存在环。接下来就是求直径了。

树上直径可以先找出离任意一点最远的点，再找出距这一点最远的点，两点之间的距离就是直径。

这是我丑陋的 AC 代码：

```cpp
#include <cstdio>
#include <iostream>
#include <map>
#include <queue>
#include <cstring>
using namespace std;
int n, a, b, c, dis[200001], ans = 0, ans_i, i;
vector <int> tree[200001];
bool vis[200001];
map <pair<int, int>, int> edge;
void map_pair(int y, int z){
	if (y > z) swap(y, z);
	if (edge[make_pair(y, z)]){
		tree[i].push_back(edge[make_pair(y, z)]);
		tree[edge[make_pair(y, z)]].push_back(i);
	}
	else edge[make_pair(y, z)] = i;
}
void add_edge(int x, int y, int z){
	map_pair(y, z);
	map_pair(x, z);
	map_pair(x, y); 
}
void search(int x, int fa){
	vis[x] = true;
	dis[x] = dis[fa] + 1;
	if (dis[x] > ans){
		ans_i = x;
		ans = dis[x];
	}
	for (int j = 0; j < tree[x].size(); j++){
		if (vis[tree[x][j]]) continue;
		search(tree[x][j], x);
	}
}
int main(){
	scanf("%d", &n);
	for (i = 1; i <= n - 2; i++){
		scanf("%d%d%d", &a, &b, &c);
		add_edge(a, b, c);
	}
	search(1, 0);
	ans = 0;
	memset(dis, 0, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	search(ans_i, 0);
	printf("%d", ans);
	return 0;
}
```

竟然过了浙江省选题，蒟蒻我留下了激动的眼泪！

---

## 作者：FrankLi0324 (赞：4)

不太想粘代码。。因为是道spfa水题。。。（真的ZJ？Orz）

思路是这样：

由于这样的图一定有：连了两条边的点有且仅有两个，这两个点之间的路径能够通过所有的城市

所以就是要找到任意一个连了两条边的点

对于任意的点，最短路径最长的那个节点总是如上所述的点。

所以对任意节点SPFA，然后找到max{dis[i]},再从这里重新SPFA，output(max{dis[i]})


---

## 作者：PanH (赞：3)

别的题解写的都很详细，那我就来概括一下树直径做法的思路吧。

**对相邻的城市连边，得到一棵树，再找树的直径。**

总结起来就这一句话。

对于连边，可以用个 map 记录每座城市的边，因为题目告诉我们最终的图是一个凸多边形的三角剖分，所以边最多有 $2n-3$ 条（内 $n-3$ 条，外 $n$ 条）。

对于为什么最终的图是树，可以想一下如果有环，那一定是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/n47ph6qk.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然有个节点在中间，不符合题意，所以肯定无环。

对于如何求直径，也就是两次 dfs ，第一次求出任意一点的最远点，第二次求出上次的最远点的最远点。这两个最远点之间的路径就是树的直径。

**但 map 常数略大，可能要开 O2 才能 AC**

code：

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define int long long
#define mp(x,y) make_pair(x,y)
using namespace std;
template<class T>inline void read(T &x)
{
	x=0;int f=0;char ch=getchar();
	while(!isdigit(ch))	f=ch=='-',ch=getchar();
	while(isdigit(ch))	x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=f?-x:x;
}
map<pair<int,int>,int> p;
const int N=2e5+5;
struct edge{
	int next,to;
}e[N<<1];
int head[N],cnt,n,dis[N],ans;
inline void add(int u,int v)
{
	e[++cnt]={head[u],v};
	head[u]=cnt;
}
void dfs(int x,int fa,int &k)
{
	if(dis[x]>ans)	ans=dis[x],k=x;
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(y==fa)	continue;
		dis[y]=dis[x]+1,dfs(y,x,k);
	}
	return;
}
main()
{
	read(n);
	for(int i=1;i<n-1;i++)
	{
		int a[3],now;
		read(a[0]),read(a[1]),read(a[2]),sort(a,a+3);
		if(now=p[mp(a[0],a[1])])	add(now,i),add(i,now);
		else	p[mp(a[0],a[1])]=i;
		if(now=p[mp(a[0],a[2])])	add(now,i),add(i,now);
		else	p[mp(a[0],a[2])]=i;
		if(now=p[mp(a[1],a[2])])	add(now,i),add(i,now);
		else	p[mp(a[1],a[2])]=i;
	}
	int s,t;
	dfs(1,0,s);
	memset(dis,0,sizeof(dis));
	dfs(s,0,t);
	printf("%lld",ans+1);
	return 0;
}
```


---

## 作者：Nero_Claudius (赞：3)

今天模拟赛考了这道题，那就来水一篇题解吧。。。（话说提高组模拟赛考什么省选题啊？？）

------------

这道题要我们求一条线段最多能经过的三角形数量。

回想小学学过的奥数，老师告诉过我们这样一件事：`点无大小 线无粗细`。

既然如此，为什么不能~~把这条线段看成一条巨大的~~把三角形看成点呢？

那么本题的思路就出来了：我们把三角形看成点，然后建立一颗二叉树，在树上跑两边BFS求直径就可以了。

可是为什么我们一定能建成二叉树呢？

其实很好证明。

三角形只有三条边，那么最多能有一个父亲和两个儿子，所以是二叉树。

当然，这个东西不是特别重要。

重点是，我们接下来怎么建图？

这里我是这样解决的：

先把每一条边都存进一个map里面，然后map手写结构体统计边出现的次数。

然后遍历一遍map，把所有出现不止一次的边两端的三角形连在一起。

这个办法唯一的问题是常数比较大，写的丑就容易TLE（然而机房的lemon竟然可以AC！）。

------------

AC代码如下：

`955ms 38272kb`

```cpp
#include<bits/stdc++.h>

using namespace std;

namespace StandardIO{

    template<typename T>inline void read(T &x){
        x=0;T f=1;char c=getchar();
        for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
        for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
        x*=f;
    }

    template<typename T>inline void write(T x){
        if(x<0)putchar('-'),x*=-1;
        if(x>=10)write(x/10);
        putchar(x%10+'0');
    }

}

using namespace StandardIO;

namespace Solve{

    const int N=200001;

    int n;
    struct __normal_pair{   
        int first,second;
        inline bool operator < (const __normal_pair &x)const{
            if(first==x.first)return second<x.second;
            return first<x.first;
        }
    };  
    struct __store_pair{
        int first,second,size;
        inline void push_back(int id){
            if(size++)second=id;
            else first=id;
        }
    };
    map<__normal_pair,__store_pair>edge;
    vector<int>graph[N];
    int dis[N],vis[N];

    inline __normal_pair make_pair(int f,int s){
        return (__normal_pair){f,s};
    }
    inline void sor(int &a,int &b,int &c){
        if(a>b)swap(a,b);
        if(a>c)swap(a,c);
        if(b>c)swap(b,c);
    }
    inline int bfs(int s,int time){
        queue<int>q;
        dis[s]=0,vis[s]=time;
        q.push(s);
        int final;
        while(!q.empty()){
            final=q.front();q.pop();
            for(register vector<int>::iterator i=graph[final].begin();i!=graph[final].end();++i){
                if(vis[*i]==time)continue;
                vis[*i]=time,dis[*i]=dis[final]+1;
                q.push(*i);
            }
        }
        return final;
    }

    inline void solve(){
        read(n);
        for(register int i=1;i<=n-2;++i){
            int p,q,r;
            read(p),read(q),read(r);
            sor(p,q,r);
            edge[make_pair(p,q)].push_back(i);
            edge[make_pair(q,r)].push_back(i);
            edge[make_pair(p,r)].push_back(i);
        }
        for(register map<__normal_pair,__store_pair>::iterator i=edge.begin();i!=edge.end();++i){
            if(i->second.size>1){
                graph[i->second.first].push_back(i->second.second);
                graph[i->second.second].push_back(i->second.first);
            }
        }
        write(dis[bfs(bfs(1,1),2)]+1);
    }

}

using namespace Solve;

int main(){
//    freopen("triangulation9.in","r",stdin);
//    freopen("triangulation.out","w",stdout);
    solve();
}
```

---

## 作者：劉子颺 (赞：1)

STL在开O2后自然是大水题。

考点：树的直径。

第一二次构图。

把每一个三角块相邻的建边。

怎么建？STL-你都做到这个题了MAP hash两个值铁定会吧。

但是ZJOI没有那么好心，不过你也有70分了。

于是这样：把两点建边。排个序。

相同的时候连起来。

树的直径。

很多人求复杂了。

树的直径一遍DFS就可以，不需要两遍BFS。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N= 500000;
struct Triangle{
	int p,q,r;
}a[N];
map<pair<int,int>,int > hash;
int n;
struct Node{
	int u,v,nxt;
}e[N*4];
int cnt=0;
int first[N]={0};
void add(int u,int v){
	cnt++;
	e[cnt].u=u;
	e[cnt].v=v;
	e[cnt].nxt=first[u];
	first[u]=cnt;
}
//
queue<int> q;
int dis[N]={0};
int rd[N]={0};
void SPFA(){
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=first[x];i;i=e[i].nxt){
			int v=e[i].v;
			if(rd[v]==0)
				continue;
			if(dis[v]<dis[x]+1){
				dis[v]=dis[x]+1;
			}
			rd[v]--;
			if(rd[v]==0){
				q.push(v);
			}
		}
	}
}
int ans=0;
int sum[N]={0};
void dfs(int u,int fat){
	sum[u]=1;
	for(int i=first[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fat)
			continue;
		dfs(v,u);
		ans=max(ans,sum[u]+sum[v]);
		sum[u]=max(sum[u],sum[v]+1);
	}
}
int main(){
	scanf("%d",&n);
	n-=2;
	for(int i=1;i<=n;i++){
		int p,q,r;
		scanf("%d%d%d",&p,&q,&r);
		pair<int,int> A;
		A.first=p;
		A.second=q;
		if(p>q){
			swap(A.first,A.second);
		}
		if(hash.count(A)){
			add(i,hash[A]);
			add(hash[A],i);
//			cout<<i<<" "<<hash[A]<<endl;
		}
		else{
			hash[A]=i;
		}
		A.first=q;
		A.second=r;
		if(q>r){
			swap(A.first,A.second);
		}
		if(hash.count(A)){
			add(i,hash[A]);
			add(hash[A],i);
//			cout<<i<<" "<<hash[A]<<endl;
		}
		else{
			hash[A]=i;
		}
		A.first=p;
		A.second=r;
		if(p>r){
			swap(A.first,A.second);
		}		
		if(hash.count(A)){
			add(i,hash[A]);
			add(hash[A],i);
//			cout<<i<<" "<<hash[A]<<endl;
		}
		else{
			hash[A]=i;
		}		
	}
//	cout<<cnt<<endl;
//	SPFA();
	dfs(1,0);
	cout<<ans<<endl; 
} 
```

---

## 作者：ddwqwq (赞：1)

我主要讲解一下如何建图。  
应该说，至少在代码实现方面，建图是本题最难的部分。我们需要以每个三角形为结点，连接有公共边的三角形，最终形成一棵树。为了实现这一点，我们需要一种可以快速检索符合要求的三角形的数据结构。具体建图流程是这样的：每当输入一个三角形，分配它一个结点编号，检索已经加入的三角形中与之相邻的三角形，并连接它们所对应的结点。每次只加入一条边，最终形成一棵树。  
本人蒟蒻，对于STL一窍不通，所以只能给一个手写实现方法。  
对于我们的需求，散列表可以很好地满足。我们以边为关键字储存三角形，把每个三角形按照三条边储存三遍。因为两个三角形间最多有一条临边，所以这并不会导致重复加边。  
检索时，分别以三条边作为关键字查找即可。  
需要注意的是，设计针对边的散列函数时，最好令两个结点的输入顺序对结果没有影响。  
以下是代码，使用了乘法散列法和链接法的散列表。
```
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>
#include <utility>

#pragma warning(disable:4996)
#define INF 2000000005//2 * 10^9
#define lowbit(a) ((a)&-(a))
inline long long max(long long a, long long b)
{
	return a>b ? a : b;
}
inline long long min(long long a, long long b)
{
	return a<b ? a : b;
}

struct Node {
	int key1;
	int key2;
	int key3;
	int data;
	Node *next;
};

void add(Node *&head, int k1, int k2, int k3, int data)
{
	Node *p = new Node;
	p->key1 = k1;
	p->key2 = k2;
	p->key3 = k3;
	p->data = data;
	p->next = head;
	head = p;
}

const double A = (sqrt(5) - 1) / 2;
const int SIZE = 100000;

double mod1(double x)
{
	return x - (long long)x;
}

int hash(int k1, int k2)
{
	return mod1(((long long)k1*k2)*A)*SIZE;
}

Node *head[SIZE];

void insert(int k1, int k2, int k3, int id)
{
	int p = hash(k1, k2);
	add(head[p], k1, k2, k3, id);
}

struct node {
	int to;
	node *next;
};

void add(node *&head, int to)
{
	node *p = new node;
	p->to = to;
	p->next = head;
	head = p;
}

const int MAXN = 200005;
node *edge[MAXN];
int N;

void work(int k1, int k2, int k3, int id)
{
	int h = hash(k1, k2);
	for (Node *p = head[h]; p; p = p->next)
		if (p->key1==k1&&p->key2==k2|| p->key2 == k1&&p->key1 == k2)
		{
			add(edge[id], p->data);
			add(edge[p->data], id);
		}
	insert(k1, k2, k3, id);
}

void addtriangle(int k1, int k2, int k3, int id)
{
	work(k1, k2, k3, id);
	work(k1, k3, k2, id);
	work(k2, k3, k1, id);
}

int dis[MAXN] = { -1 };
void dfs(int v, int fa)
{
	dis[v] = dis[fa] + 1;
	for (node *p = edge[v]; p; p = p->next)
		if (p->to != fa)
			dfs(p->to, v);
}
int getd()
{
	int mx = 0;
	dfs(1, 0);
	for (int i = 1; i <= N - 2; i++)
		if (dis[i] > dis[mx])
			mx = i;

	dfs(mx, 0);
	mx = 0;
	for (int i = 1; i <= N - 2; i++)
		if (dis[i] > dis[mx])
			mx = i;
	return dis[mx];
}

int main()
{
	int i, a, b, c;

	scanf("%d", &N);

	for (i = 1; i <= N - 2; i++)
	{
		scanf("%d %d %d", &a, &b, &c);
		addtriangle(a, b, c, i);
	}

	printf("%d", getd() + 1);

	system("pause");
	return 0;
}
```

---

## 作者：Victorique (赞：1)

楼下那篇题解说实话就是什么都没说，所以我再发一篇正常一点的。

楼下思路大体是正确的，但是之所以是说什么都没说，是因为他有两个比较致命的遗漏。首先是点，这里的点不是平时我们认为的点，如果多少接触过对偶图很容易看出来，这个题实际上要把每个三角形当作点，而把有临边的三角形连边，这样我们就可以大体上得到一棵树，至于怎么连这个边，使用map和pair进行操作，具体说来很麻烦，可以上网某度以下。

建完图了之后，不难看出，我们要的结果就是建出来的这个树的最长链，然后就是找到一个最长链的端点的问题。由于这是一棵树，所以我们可以通过dfs或bfs求出其中的一个端点，然后从这个端点再来一次，求出的最大深度就是我们要的答案。由于这个题的数据限制，所以虽然这么建完图之后spfa绝对不慢，可是还是会T2~3个点，虽然你想A掉可以开O2优化，但是还是希望用搜索搜索出来。还有一个，不要cin，这个必T无疑，除非你开O2.。。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<iomanip>
#include<map>
#define re register
#define ll long long
using namespace std;
struct po
{
    int nxt,to,dis;
};
map<pair<int,int>,int> m;
po edge[4000001];
int q[1000001],head[1000001],dis[300001],b[300001],temp[400001][3];
int n,s,t,r,st,to,ans,maxx,num;
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    while(ch=='-')c*=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
inline void add_edge(int from,int to,int dis)
{
    edge[++num].nxt=head[from];
    edge[num].to=to;
    edge[num].dis=dis;
    head[from]=num;
}
inline void finish(int id,int x,int y)
{
    int s=m[make_pair(x,y)];
    if(s)
    {
        add_edge(s,id,1);
        add_edge(id,s,1);
        m.erase(m.find(make_pair(x,y)));
    }else
    m[make_pair(x,y)]=id;
}
inline void spfa(int x)
{
    memset(dis,127,sizeof(dis));
    memset(b,0,sizeof(b));
    int front=0,tail=1;
    dis[x]=0;
    q[tail]=x;
    b[x]=1;
    while(front<tail)
    {
        int now=q[++front];
        b[now]=0;
        for(re int i=head[now];i;i=edge[i].nxt)
        {
            int u=edge[i].to;
            if(dis[u]>edge[i].dis+dis[now])
            {
                dis[u]=edge[i].dis+dis[now];
                if(!b[u])
                {
                    b[u]=1;
                    q[++tail]=u;
                }
            }
        }
    }
}
inline void bfs(int x)
{
    memset(b,0,sizeof(b));
    int front=0,tail=1;
    temp[tail][1]=x;
    temp[tail][2]=1;
    b[x]=1;
    while(front<tail)
    {
        int now=temp[++front][1];
        int dep=temp[front][2];
        if(dep>maxx)
        {
            st=now;
            maxx=dep;
        }
        for(re int i=head[now];i;i=edge[i].nxt)
        {
            int u=edge[i].to;
            if(!b[u])
            {
                b[u]=1;
                temp[++tail][1]=u;
                temp[tail][2]=dep+1;
            }
        }
    }
}
int main()
{
    n=read();
    for(re int i=1;i<=n-2;i++)
    {
        s=read();t=read();r=read();
        if(s>t)
        swap(s,t);
        if(s>r)
        swap(s,r);
        if(t>r)
        swap(t,r);
        finish(i,s,t);
        finish(i,s,r);
        finish(i,t,r);
    }

    bfs(1);
    maxx=0;
    bfs(st);
    cout<<maxx;
}
```

---

## 作者：Yingluosanqian (赞：0)

# 一个小优化

看完题解好多存图都是$pair+map$，用
```cpp
map<pair<in,int>,int>
```
这样一个方式存图。提出一个小优化，
用$hash+unordered\_map$存图，这样就不用开$O_2$了 ~~（也许是我写太丑了所以不吸氧过不去）~~

如下（大概这意思，实际上当然不是这样写）：
```cpp
unordered_map<long long,int> M;
tmp=ip[0]*1000000+ip[1];
M[tmp]=i;
tmp=ip[0]*1000000+ip[2];
M[tmp]=i;
tmp=ip[1]*1000000+ip[2];
M[tmp]=i;
```
也就是说用一个$long~long$变量的前六位存一个点，七到十二位存另一个点，这也是很常用的一个方法 ~~（可能只有我觉得吧）~~

然后不吸氧过了，上完整代码：
```cpp
#include <iostream>
#include <cstdio>
#include <unordered_map>
#include <algorithm>
#include <cstring>
#define ll long long

using namespace std;

const int MAXN=300050;

int n,head[MAXN],mark[MAXN],dep[MAXN],par[MAXN],cnt=1,ans=1e9;
int dm,topdm,md;
ll ip[3],tmp;

struct EDGE{
	int to,w,nxt;
}edge[MAXN<<1];

void add_edge(int iu,int iv,int iw){
	edge[++cnt]=((EDGE){iv,iw,head[iu]});
	head[iu]=cnt;
}

void dfs(int now,int fa){
	for(int i=head[now];~i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa||mark[v]) continue;
		dep[v]=dep[now]+edge[i].w;
		if(dep[v]>dep[dm]){
			dm=v;
			md=dep[v];
		}
		par[v]=now;
		dfs(v,now);
	}
}

int main(){
	memset(head,-1,sizeof head);
	scanf("%d",&n);
	unordered_map<ll,int> M;
	for(int i=1;i<n-1;i++){
		scanf("%lld%lld%lld",&ip[0],&ip[1],&ip[2]);
		sort(ip,ip+3);
		tmp=ip[0]*1000000+ip[1];
		if(M.count(tmp)){
			add_edge(i,M[tmp],1);
			add_edge(M[tmp],i,1);
		}
		else{
			M[tmp]=i;
		}
		
		tmp=ip[0]*1000000+ip[2];
		if(M.count(tmp)){
			add_edge(i,M[tmp],1);
			add_edge(M[tmp],i,1);
		}
		else{
			M[tmp]=i;
		}
		
		tmp=ip[1]*1000000+ip[2];
		if(M.count(tmp)){
			add_edge(i,M[tmp],1);
			add_edge(M[tmp],i,1);
		}
		else{
			M[tmp]=i;
		}
	}
	
	dfs(1,0);
	dep[dm]=0;
	dfs(dm,0);
	
	printf("%d",md+1);
	
	return 0;
}
```


---


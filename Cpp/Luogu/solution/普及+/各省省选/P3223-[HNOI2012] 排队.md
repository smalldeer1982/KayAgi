# [HNOI2012] 排队

## 题目描述

某中学有 $n$ 名男同学，$m$ 名女同学和两名老师要排队参加体检。他们排成一条直线，并且任意两名女同学不能相邻，两名老师也不能相邻，那么一共有多少种排法呢？（注意：任意两个人都是不同的）


## 说明/提示

对于 $30\%$ 的数据 $n\leq 100$，$m\leq 100$。

对于 $100\%$ 的数据 $n\leq 2000$，$m\leq 2000$。


## 样例 #1

### 输入

```
1  1```

### 输出

```
12```

# 题解

## 作者：Youngore (赞：165)

他们写的都好复杂

什么谁隔开谁的。。。

麻烦！

老师不相邻=不考虑老师相邻-老师相邻

-  不考虑老师相邻

显然老师与男同学等价，用插空法解决
$$A_{n+2}^{n+2}\times A_{m}^{m}\times C_{n+3}^{m}$$

其中C中的$n+3$是因为有$n+2$个人，故有$n+3$个空

-  老师相邻

用捆绑法，两名老师**整体**与男同学等价，同样用插空法答案显然为
$$A_2^2\times A_{n+1}^{n+1}\times A_m^m\times C_{n+2}^m$$

二者做差就是答案

End...



---

## 作者：萝卜 (赞：39)

一个普通的高中排列组合问题。

考虑两种情况：

1：老师中间是男生

运用插空法，先排男生有 n！种排法；

在男生中插入两只老师：2 p （n+1）种排法，换句话说A（ （n+1） ， 2 ）；

最后在男生和老师中插入女生：m p （n+3）种排法，换句话说A（ （n+3） ， m ）；


2.老师中间是女生

同上，男生 n！；

将两位老师打包（n+1），老师之间排列方式 2 种；

挑一个女生在老师之间 m 种，剩下的女生（m-1 )  p （n+2）种排法，换句话说A（ （n+2） ， （ m-1 ） ）；


综合两种情况，整理得{ n !  ( n+1 )( n+2 ) ! ( n\*n+3\*n+2\*m )  } / ( n-m+3 ) ! ;


代码如下。





```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
long long fj,ans[10000];
int n,m,len(1);
const long long p=10000000000ll;
void mul(int x)
{
    long long pre(0),tem;
    for(int i=1;i<=len;i++)
    {
        tem=ans[i]*x;
        ans[i]=tem%p+pre;
        pre=tem/p;
    }
    if(pre){len++;ans[len]=pre;};
}
int main(){
    scanf("%d%d",&n,&m);
    ans[1]=1;
    mul(n+1);mul(n*(n+3)+2*m);
    for(int i=1;i<=n;i++)mul(i);
    for(int i=n-m+4;i<=n+2;i++)mul(i);
    printf("%lld",ans[len]);
    while(--len)printf("%010lld",ans[len]);
    //cout<<ans[len];
    //while(--len)cout<<ans[len];
    return 0;
}
————————————北镇中学OI队（犯罪团伙）
```

---

## 作者：支羽 (赞：19)

这道题放到月考我都信。

分类讨论一下：

1.两个老师中间只站着一个女生。这是两老师+一女生应该看做一个整体。

$A(n,n)\cdot A(n+1,1)\cdot A(2,2)\cdot A(n+2,m-1)$

2.两个老师中间不止站一个女生，这时中间一定有男生，于是随便插空就好了。

$A(n,n)\cdot A(n+1,2)\cdot A(n+3,m)$

用个高精度什么的暴力算一下排列就可以了。

```cpp
#include    <iostream>
#include    <cstdio>
#include    <cstdlib>
#include    <algorithm>
#include    <vector>
#include    <cstring>
#include    <queue>
#include    <complex>
#include    <stack>
#define LL long long int
#define dob double
#define FILE "排队"
using namespace std;

const int N = 10010;
const LL P = 100000;
int n,m;
struct BigInt{
  LL f[N],len;
  inline void clear(){memset(f,0,sizeof(f));len=0;}
  inline void give(int x){f[len=1]=x;}
  BigInt operator *(const BigInt &g)const{
    BigInt h;h.clear();h.len=len+g.len+10;
    for(int i=1;i<=len;++i)
      for(int j=1;j<=g.len;++j){
        h.f[i+j-1]+=f[i]*g.f[j];
        h.f[i+j]+=h.f[i+j-1]/P;
        h.f[i+j-1]%=P;
      }
    for(int i=1;i<=h.len;++i)
      h.f[i+1]+=h.f[i]/P,h.f[i]%=P;
    while(h.len && !h.f[h.len])h.len--;
    return h;
  }
  BigInt operator +(const BigInt &g)const{
    BigInt h;h.clear();h.len=max(len,g.len)+10;
    for(int i=1;i<=h.len;++i){
      h.f[i]+=f[i]+g.f[i];
      h.f[i+1]+=h.f[i]/P;
      h.f[i]%=P;
    }
    for(int i=1;i<=h.len;++i)
      h.f[i+1]+=h.f[i]/P,h.f[i]%=P;
    while(h.len && !h.f[h.len])h.len--;
    return h;
  }
  inline void print(){
    printf("%lld",f[len]);
    for(int i=len-1;i>=1;--i)
      printf("%05lld",f[i]);
  }
}Ans;

inline int gi(){
  int x=0,res=1;char ch=getchar();
  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}
  while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
  return x*res;
}

inline BigInt A(int n,int m){
  BigInt ans,x;ans.clear();ans.give(1);
  if(!m)return ans;
  if(m>n){ans.clear();return ans;}
  for(LL i=n-m+1;i<=n;++i){x.give(i);ans=ans*x;}
  return ans;
}

int main()
{
  /*freopen(FILE".in","r",stdin);
    freopen(FILE".out","w",stdout);*/
  n=gi();m=gi();
  Ans=A(n,n)*A(n+1,2)*A(n+3,m)+A(n,n)*A(n+1,1)*A(2,2)*A(m,1)*A(n+2,m-1);
  Ans.print();
  /*fclose(stdin);
    fclose(stdout);*/
  return 0;
}
```

---

## 作者：牛瓜瓜 (赞：14)

似乎和大家的做法不太一样，我的似乎比较简洁一些

因为两个女同学既可以一个男同学两边，也可以在一的老师的两侧，所以我们可以先把老师看成男同学，女同学再插到间隔中，那就有$A_{n+3}^m\times A_{n+2}^{n+2}$种方法

但是老师还有一个要求就是两个老师不能相邻，因此要减去两个老师在一起的情况，用捆绑法，把两个老师看作一个人，和上面相似的，容易求出有$2\times A_{n+2}^m\times A_{n+1}^{n+1}$，那个2是因为两个老师之间的位置可以调换。

由于用py3的代码比较清楚~~我才不会告诉你们其实是因为我不想写高精度~~，就用py3水过去了。

```python
import sys
import math
ans=0
n,m=map(int,input().split())
def f(x):
    return math.factorial(x)
def A(x,y):
    return f(x)//f(x-y)
if(n+3>=m):
    ans+=A(n+3,m)*A(n+2,n+2)
if(n+2>=m):
    ans-=2*A(n+2,m)*A(n+1,n+1)
print(ans)
```





---

## 作者：Porsche (赞：11)

首先一看就知道是组合数学，推两个自己的博客：

1.[组合数学入门](https://www.cnblogs.com/wzc521/p/11096302.html)

2.[[BZOJ2729]:[HNOI2012]排队（组合数学）](https://www.cnblogs.com/wzc521/p/11102906.html)

这两篇博客我都还是很认真的去写的，感觉还是不错，第一篇就是对于组合数学入门的讲解，第二篇是这道题的题解。

其实，提并不难，跑得快不快主要是看高精打的好不好，而作为“最优解”榜首，再次我就跟大家谈一下这道题里用到的一些卡长。

首先，这道题显然是一个高精乘低精，所以不用一位一位的乘，我们可以将好几位压到一个long long里，然后在看数据范围，2000。

long long显然是10^18，那么我可以压15位，这样显然就快了很多。

上代码：
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#pragma GCC optimize(4)
using namespace std;
int n,m;
int l=1;
long long ans[1000],flag1,flag2;
void wzc(int x)
{
    flag2=0;
    for(register int i=1;i<=l;i++)
    {
        flag1=ans[i]*x;
        ans[i]=flag1%1000000000000000+flag2;
        flag2=flag1/1000000000000000;
    }
    if(flag2)ans[++l]=flag2;
}
int main()
{
    ans[1]=1;
    scanf("%d%d",&n,&m);
    wzc(n*n+n*3+2*m);
    for(register int i=1;i<=n+1;i++)
        wzc(i);
    for(register int i=n-m+4;i<=n+2;i++)
        wzc(i);
    printf("%lld",ans[l]);
    while(--l)printf("%.15lld",ans[l]);
    return 0;
}
```

[没错，我就是最快的男人～](https://www.luogu.org/recordnew/show/20210758)

---

## 作者：King丨帝御威 (赞：9)

考虑将老师和女生放到男生中间(注意这道题每个人不一样)
男生排列方案：A(n,n)
现在有n+1个间隔，要将2个老师放入：A(n+1,2)
现在产生了n+3个间隔，将m个女生放入：A(n+3，m)

但是我们忽略了一种方案
我们算的是将老师分别放到男生中间，也就是说，隔开老师的必有一个男生
实际上可以只放一个女生
把2个老师和1个女生和为一块，放入男生中方案:n+1
放剩下的女生：A(n+2,m-1)
选出1个女生：C(m,1)
老师排列方案：A(2,2)=2
男生排列方案：A(n,n)
所以ans=A(n,n)*A(n+1,2)*A(n+3,m)+(n+1)*A(n+2,m-1)*C(m,1)*A(n,n)*2
因为不取模，所以必须要高精度
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int ans1[100001],ans2[100001],ans[100001],len1,len2,len;
int n,m;
void calc1(int x)                     //高精板子。
{
  	for(int i=1;i<=len1;i++)
    	ans1[i]*=x;
  	for(int i=1;i<=len1;i++)
    if(ans1[i]>=10)
    {
    	ans1[i+1]+=ans1[i]/10;
    	ans1[i]%=10;
    }
  	while(ans1[len1+1]) 
    {
    	len1++;
      	if(ans1[len1]>=10)
    	{
      		ans1[len1+1]+=ans1[len1]/10;
      		ans1[len1]%=10;
    	}
    }
}
void calc2(int x)               //改改变量就行。
{	
	for(int i=1;i<=len2;i++)
	ans2[i]*=x;
	for(int i=1;i<=len2;i++)
	if(ans2[i]>=10)
	{
		ans2[i+1]+=ans2[i]/10;
		ans2[i]%=10;
	}
	while(ans2[len2+1]) 
	{
		len2++;
		if(ans2[len2]>=10)
		{
			ans2[len2+1]+=ans2[len2]/10;
			ans2[len2]%=10;
		}
	}
}
void add()                 //将结果合并。
{
  	len=max(len1,len2);
  	for(int i=1;i<=len;i++)
    ans[i]=ans1[i]+ans2[i];
  	for(int i=1;i<=len;i++)
    if(ans[i]>=10)
    {
    	ans[i+1]+=ans[i]/10;
    	ans[i]%=10;
    }
  	while(ans[len+1]) 
    {
		len++;
    	if(ans[len]>=10)
    	{
      		ans[len+1]+=ans[len]/10;
      		ans[len]%=10;
    	}
    } 
}
int main()
{
//	freopen("queue.in","r",stdin);
//	freopen("queue.out","w",stdout);
  	cin>>n>>m;
  	ans1[1]=1;len1=1;                  //重置，用于高精。
  	for(int i=1;i<=n;i++)
    calc1(i);
	calc1(n);
	calc1(n+1);
  	for(int i=n+3;i>=n+4-m;i--)  
    calc1(i);                     //疯狂递归下去。
  	ans2[1]=1;
	len2=1;
  	calc2(n+1);
  	for(int i=n+2;i>=n+4-m;i--)
    calc2(i);
  	calc2(m);
  	for(int i=1;i<=n;i++)
    calc2(i);
  	calc2(2);
  	add();
  	for(int i=len;i>=1;i--)
    printf("%d",ans[i]);
    return 0;
}
```

---

## 作者：ylsoi (赞：4)

不难发现男生可以分开女生和老师，女生和老师也可以互相分开。

于是我们先把男生给全部排好，先放两个老师，讨论一下她们是被男生分开还是暂时相邻后面再被女生分开。

于是可以得到最终的答案的式子：
$$n!\times A_{n+1}^2 \times A_{n+3}^m+n!\times (n+1)\times 2 \times m\times A_{n+2}^{m-1}$$

然后发现要高精度

高精度可以直接用python3来实现

```python
import sys
import math
#sys.stdin=open("luogu3223.in","r")
#sys.stdout=open("luogu3223.out","w")
ans=0
n,m=map(int,input().split())
def f(x):
    return math.factorial(x)
def A(x,y):
    return f(x)//f(x-y)
if(n+1>=2 and n+3>=m):
    ans+=f(n)*A(n+1,2)*A(n+3,m)
if(n+2>=m-1 and m>=1):
    ans+=f(n)*(n+1)*2*m*A(n+2,m-1)
print(ans)
```

---

## 作者：Ofnoname (赞：3)

这是真正可以放进高考的数学题啊， 有高二数学能力的同学应该都可以推出来。注意男生女生和老师都是不同的。

因为老师只有2个，男的可以乱排，所以从这里入手。

### 1. 两个老师由男生隔开

那么男生和老师一共`N+2`个，不考虑老师的顺序就有$A_{N+2}^{N+2}$种方案。

把两个老师A,B捆在一起当做一个人(排列有`AB`和`BA`两种)，这样还剩`N+1`人的方案数就是$A_{N+1}^{N+1}$，相减就是$A_{N+2}^{N+2}-2A_{N+1}^{N+1}$。

此时有`N+3`个空隙，可以随意插入`M`个女生，所以总的答案为

$$(A_{N+2}^{N+2}-2A_{N+1}^{N+1})*A_{N+3}^{M}$$

### 2. 两个老师由女生隔开

容易发现在情况一时，即使第一步放置男生和老师时，即使把老师放在一起，也有可能被后面的女生又分开，这种情况没有考虑到。

我们可以直接把两个老师和中间的女生看做一个整体，任选一个女生和一种老师的排列(`AB`|`BA`)，有$2*M$种方案。

此时将三人与`N`个男生一同放置，显然方案数为$A_{N+1}^{N+1}$。

此时有`N+2`个空隙，可以随意插入剩余`M-1`个女生，所以总的答案为

$$2M*A_{N+1}^{N+1}*A_{N+2}^{M-1}$$

最终答案为
$$(A_{N+2}^{N+2}-2A_{N+1}^{N+1})*A_{N+3}^{M}+2M*A_{N+1}^{N+1}*A_{N+2}^{M-1}$$

计算时很多地方是可以合并化简的。

其中涉及高精乘低精，高精乘高精，高精加减高精。

代码太丑，就不贴了。

---

## 作者：山水一程_ (赞：3)

数学题0.0
最后答案：A(n,n)*A(n+1,2)*A(n+3,m)+A(n,n)*C(m,1)*A(2,2)*C(n+1,1)*A(n+2,m-1);

简单解释一下 

+之前的很显然 先排男生 然后老师插空 然后女生插空 显然符合条件
但仔细一想会发现少算了一部分 就是 老师 女生 老师 的情况

在单独考虑着一种 先选夹在中间的女生（C(m,1)） 然后老师换位置 A(2,2) 

然后安排这个(C(n+1,1)) 然后剩下的女生插空 

注意不能把  老师 女生 老师  和其他女生看成一样的 因为这个具有特殊性 

然后就是高精了 最简单的 连压位都不用  压位的话可以更快 
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
int n,m,a[1000010],b[1000010],c[1000010],ans[10000010],l1,l2,l;
void get_na() {
	for(int i=2; i<=n; i++) {
		for(int j=1; j<=l1; j++)
			a[j]=a[j]*i;
		for(int j=1; j<=l1; j++)
			if(a[j]>=10) {
				a[j+1]+=a[j]/10;
				a[j]=a[j]%10;
			}
		while(a[l1+1]) {
			l1++;
			a[l1+1]+=a[l1]/10;
			a[l1]=a[l1]%10;
		}
	}
}
void get_nb() {
	for(int i=1; i<=l1; i++)
		b[i]=a[i];
	l2=l1;
}
void Mul1(int x) {
	for(int i=1; i<=l1; i++)
		a[i]=a[i]*x;
	for(int i=1; i<=l1; i++)
		if(a[i]>=10) {
			a[i+1]+=a[i]/10;
			a[i]=a[i]%10;
		}
	while(a[l1+1]) {
		l1++;
		a[l1+1]+=a[l1]/10;
		a[l1]=a[l1]%10;
	}
}
void Mul2(int x) {
	for(int i=1; i<=l2; i++)
		b[i]=b[i]*x;
	for(int i=1; i<=l2; i++)
		if(b[i]>=10) {
			b[i+1]+=b[i]/10;
			b[i]=b[i]%10;
		}
	while(b[l2+1]) {
		l2++;
		b[l2+1]+=b[l2]/10;
		b[l2]=b[l2]%10;
	}
}
void Add() {
	l=max(l1,l2);
	for(int i=1; i<=l; i++)
		c[i]=a[i]+b[i];
	for(int i=1; i<=l; i++)
		if(c[i]>9) {
			c[i+1]++;
			c[i]=c[i]%10;
		}
	while(c[l+1])l++;
}
int main() {
	scanf("%d%d",&n,&m);
	a[1]=1;
	l1=1;
	b[1]=1;
	l2=1;
	get_na();
	get_nb();
	Mul1(n);
	Mul1(n+1);
	for(int i=n+3; i>=n+3-m+1; i--)
		Mul1(i);
	Mul2(2*m);
	Mul2(n+1);
	for(int i=n+2; i>=n+2-m+1+1; i--)
		Mul2(i);
	Add();
	for(int i=l; i>=1; i--)
		printf("%d",c[i]);
	return 0;
}

```


---

## 作者：12mango (赞：3)

这里**插空法+高精度重载**

思路楼下说的很清楚啦，我的公式就是**ans=A(n,n)\*A(n+1,2)\*A(n+3,m)+A(n,n)\*C(m,1)\*A(2,2)\*C(n+1,1)\*A(n+2,m-1)**

先让n个男生站好，让两个老师插n+1个空，再让女生插n+3个空，但是忽略了老师和女生站在一起的情况——两个老师中间夹着一个女生。再让n个男生站好，在女生里选出一个来站在老师中间，老师的位置可以互换。这三个人可以在n+1个空里选一个去站。现在还剩m-1个女生，n+2个空，再让她们去随便站就好啦。


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<vector>
#define mod 100000000
#define ll long long
using namespace std;
struct NUM
{
    vector<ll>val;    
    NUM(){val.clear();val.resize(1,0);}
    void clear(){while(!val.back()&&val.size()>1) val.pop_back();}
    NUM operator+(NUM b)
    {
        NUM a=*this,c;
        int len1=a.val.size();
        int len2=b.val.size();
        int len3=max(len1,len2)+1;
        c.val.resize(len3,0);
        for(int i=0;i<len3;++i){
            if(i<len1) c.val[i]+=a.val[i];
            if(i<len2) c.val[i]+=b.val[i];
            if(i<len3-1){
                c.val[i+1]+=c.val[i]/mod;
                c.val[i]%=mod;
            }
        }
        c.clear();
        return c;
    }
    NUM operator*(const int x){
        NUM a=*this;
        int ret=0;
        for(int i=0;i<a.val.size();++i){
            a.val[i]*=x;
            a.val[i]+=ret;
            ret=a.val[i]/mod;
            a.val[i]%=mod;
        }
        a.val.push_back(ret);
        a.clear();
        return a;
    }
    NUM operator*(NUM b)
    {
        NUM a=*this,c;
        int len1=a.val.size();
        int len2=b.val.size();
        int len3=len1+len2;
        c.val.resize(len3,0);
        for(int i=0;i<len1;++i)
            for(int j=0;j<len2;++j)
                c.val[i+j]+=a.val[i]*b.val[j];
        for(int i=0;i<len3-1;++i){
            c.val[i+1]+=c.val[i]/mod;
            c.val[i]%=mod;
        }
        c.clear();
        return c;
    }
    NUM operator/(const int x){
        NUM a=*this,b;
        int len=a.val.size();
        b.val.resize(len,0);
        for(int i=len-1;i>=1;--i){
            b.val[i]=a.val[i]/x;
            a.val[i-1]+=a.val[i]%x*mod;
        }
        b.val[0]=a.val[0]/x;
        b.clear();
        return b;
    }
    NUM operator*=(const int x){return *this=*this*x;}
    NUM operator/=(const int x){return *this=*this/x;}
    void output(){
        int len=val.size();
        if(val[len-1]) printf("%d",val[len-1]);
        for(int i=len-2;i>=0;--i) printf("%08d",val[i]);
    }
}; 
NUM A(int n,int m)
{
    NUM zero;
    if(m>n) return zero;
    NUM ret;
    ret.val[0]=1;
    for(int i=n-m+1;i<=n;++i) ret*=i;
    return ret;
}
NUM C(int n,int m)
{
    NUM zero;
    if(m>n) return zero;
    NUM ret;
    ret.val[0]=1;
    for(int i=n-m+1;i<=n;++i) ret*=i;
    for(int i=1;i<=m;++i) ret/=i;
    return ret;
}
int main()
{
    int n,m;
     scanf("%d%d",&n,&m);
     if(!n&&!m){
         printf("0");
         return 0;
     }
    NUM ans=A(n,n)*A(n+1,2)*A(n+3,m)+A(n,n)*C(m,1)*A(2,2)*C(n+1,1)*A(n+2,m-1);
    ans.output();
    return 0;
}
```

---

## 作者：mrclr (赞：2)

这题放在高二的期末好像也没什么问题……

刚开始我的想法是用男生分割老师，再用男生分割女生。但这样是错的，因为可以用女生分割老师。

所以我们分两种情况：

1.男生先把老师分开了：那么排列数就是$A_{n + 1} ^ {2} * A_{n + 3} ^ m * n!$。因为每一个人都不同，所以是排列，不是组合。思想就是插板法。

2.男生没有把老师分开，而是由女生分开：$(n + 1) * 2! * A_{n + 2} ^ {m - 1} * m * n!$。就是我们强制让一个女生站在老师中间，然后剩下的女生随便站。

把上面的式子化简化简就变成高精乘低精了，代码就比较短。
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
#include<assert.h>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 1e6 + 5;
In ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
In void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}
In void MYFILE()
{
#ifndef mrclr
  freopen("1.in", "r", stdin);
  freopen("ac.out", "w", stdout);
#endif
}

int n, m;

int a[maxn], len = 1;
In void mul(int x)
{
  len += 10; int der = 0;
  for(int i = 0; i < len; ++i)
    {
      a[i] = a[i] * x + der;
      der = a[i] / 10, a[i] %= 10;
    }
  while(len > 1 && !a[len - 1]) --len;
}

int main()
{
  //MYFILE();
  n = read(), m = read();
  if(m > n + 3) {puts("0"); return 0;}
  a[0] = 1, len = 1;
  for(int i = 1; i <= n; ++i) mul(i);
  for(int i = n + 3 - m + 1; i <= n + 2; ++i) mul(i);
  mul(n + 1), mul(n * (n + 3) + 2 * m);
  for(int i = len - 1; i >= 0; --i) write(a[i]); enter;
  return 0;
}
```

---

## 作者：ww3113306 (赞：1)

自认写的高精还是比较清晰，因为是高精乘低精，所以低精直接用k存下即可
表示看楼上几个重载运算符的并不能看懂
可能我太蒟蒻了吧
跑了五百多ms，但是卡常空间很大，所以应该不是很慢
	#include<bits/stdc++.h>
	using namespace std;
	#define AC 10000
	#define R register int
	#define D printf("the k is %d\n",k);
	/*A(n,n)*A(n+1,2)*A(n+3,m) + 	A(n,n)*C(m,1)*A(2,2)*C(n+1,1)*A(n+2,m-1)
	分情况讨论推出公式
	前者为无论何时都合法的，后者为先不合法，然后再合法的（两个老师先站在一	起，然后一个女生
	插进来，所以要把这3个人看成一个整体，然后老师可以左右换，所以乘2,女生	就是m选1,然后整体再插入队伍
	最后得到上面的式子
	*/
	int sum2[AC],a[AC],sum1[AC],k,n,m,tot,tot1,tot2,ans[AC];//每次计	算前将memset a，将高精sum*低精k存入a，然后计算完毕后将a导入sum
	
	void ADD()//加法
	{
		for(R i=1;i<=max(tot1,tot2);i++)//error!!!注意这里要加到max(tot1,tot2)!!!
		{
			ans[i+1]=ans[i+1]+(sum1[i]+sum2[i]+ans[i])/10000;
			ans[i]=(ans[i]+sum1[i]+sum2[i])%10000;
		}
		tot=(tot1+tot2)%10000;
		while(!ans[tot] && tot>1)--tot;//注意边界！！！
	}

	void add1()//乘法1,计算前一部分
	{
		memset(a,0,sizeof(a));
		for(R i=1;i<=tot1;i++)
		{
			a[i+1]=a[i+1]+(a[i]+sum1[i]*k)/10000;
			a[i]=(a[i]+sum1[i]*k)%10000;
		}
		tot1+=1;//因为n和m最大就是2000，所以最多也就加这么多位了，又因为压了位，，，所以
		while(!a[tot1] && tot1>1)--tot1;
		if(!a[tot1])memset(sum1,0,sizeof(sum1));//如果女生太多了会导致没有合法情况！！
		else	for(R i=1;i<=tot1;i++)	sum1[i]=a[i];//导入sum
	}

	void add2()//乘法2，计算后一部分
	{
		memset(a,0,sizeof(a));
		for(R i=1;i<=tot2;i++)
		{
			a[i+1]=a[i+1]+(a[i]+sum2[i]*k)/10000;
			a[i]=(a[i]+sum2[i]*k)%10000;
		}
		tot2+=1;//因为n和m最大就是2000，所以最多也就加这么多位了，又因为压了位，，，所以
		while(!a[tot2] && tot2>1)--tot2;
		if(!a[tot2])memset(sum2,0,sizeof(sum2));
		else for(R i=1;i<=tot2;i++)	sum2[i]=a[i];//导入sum
	}
	
	void work()
	{
		sum1[1]=1;//初始值
		tot1=1;
		for(R i=2;i<=n;i++)//计算A(n,n),即n！
		{
			k=i;
			add1();
		}
		k=n;
		add1();
		k=n+1;//分开乘，不然k太大会爆
		add1();
		k=n+3;
		for(R i=1;i<=m;i++)//计算A(n+3,m)
		{
			add1();
			--k;
		}
		//一二部分分割线~~~~~~~~~~~~~~~
		sum2[1]=2*(n+1);//不会破万，所以直接放在第一个即可
		tot2=1;
		k=m;
		add2();
		for(R i=2;i<=n;i++)
		{
			k=i;
			add2();
		}
		k=n+2;
		for(R i=1;i<=m-1;i++)
		{
			add2();
			--k;
		}
		ADD();//最后把sum1和sum2相加得到ans
		printf("%d",ans[tot--]);
		for(R i=tot;i>=1;i--)printf("%04d",ans[i]);
		/*printf("\n");
		while(!sum1[tot1])tot1--;
		printf("%d",sum1[tot1]);
		for(R i=tot1-1;i>=1;i--)printf("%04d",sum1[i]);*/
	}
	
	int main()
	{
		freopen("in.in","r",stdin);
		scanf("%d%d",&n,&m);
		work();
		fclose(stdin);
		return 0;
	}

---


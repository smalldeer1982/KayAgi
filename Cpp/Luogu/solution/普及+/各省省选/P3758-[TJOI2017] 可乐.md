# [TJOI2017] 可乐

## 题目描述

加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市，问经过了 $t$ 秒，可乐机器人的行为方案数是多少？


## 说明/提示

#### 样例输入输出 1 解释


- $1$ ->爆炸。
- $1$ -> $1$ ->爆炸。
- $1$ -> $2$ ->爆炸。
- $1$ -> $1$ -> $1$。
- $1$ -> $1$ -> $2$。
- $1$ -> $2$ -> $1$。
- $1$ -> $2$ -> $2$。
- $1$ -> $2$ -> $3$。

---

#### 数据范围与约定

- 对于 $20\%$ 的数据，保证 $t \leq 1000$。
- 对于$100\%$的数据，保证 $1 < t \leq 10^6$，$1 \leq N \leq30$，$0 < M < 100$，$1 \leq u, v \leq N$。

## 样例 #1

### 输入

```
3 2
1 2
2 3
2```

### 输出

```
8```

# 题解

## 作者：Zhang_RQ (赞：138)

这道题我们可以从**邻接矩阵**的**幂**的意义考虑。

设现在有一个邻接矩阵$A$。

那么$A^k$的意义是什么？（两个点之间若有边则$A[u][v]=1$）

从$floyd$算法的角度考虑，不难发现$A^k$的第$i$行第$j$列的数字含义是从$i$到$j$经过$k$步的路径方案总数。

从这个角度考虑，这个点就有了一种做法。

首先将这个图的邻接矩阵建出来，然后直接算这个矩阵的$k$次方。

最后统计$\sum\limits_{i=1}^{n}A[1][i]$就是答案。

那么在原地停留和自爆怎么处理？

在原地停留很简单，我们只要认为每个点都有一个从自己到自己的自环即可。

那自爆呢？

我们可以将自爆这个**状态**也看成一个**城市**，就设它为编号$0$。

我们在邻接矩阵上从每个点都向这个点连一条边，这个点除了自己外不连其他出边。

这样就满足了任何一个点随时可以自爆，且无法恢复到其他状态。

最后，统计答案。$Ans=\sum\limits_{i=0}^{n}A[1][i]$

代码如下

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<stack>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
const int P=2017;
struct Matrix{
    int a[31][31];
    inline Matrix operator * (const Matrix &rhs)
    {
        Matrix ret;
        memset(&ret,0,sizeof ret);
        for(int i=0;i<=30;i++)
            for(int j=0;j<=30;j++)
                for(int k=0;k<=30;k++)
                    (ret.a[i][j]+=a[i][k]*rhs.a[k][j]%P)%=P;
        return ret;
    }
}mp;
Matrix ksm(Matrix &a,int b)
{
    Matrix ret;
    memset(&ret,0,sizeof ret);
    for(int i=0;i<=30;i++) ret.a[i][i]=1;
    while(b)
    {
        if(b&1) ret=ret*a;
        a=a*a;b>>=1;
    }
    return ret;
}
int u,v,n,m,t;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&u,&v);
        mp.a[u][v]=1;mp.a[v][u]=1;
    }
    for(int i=0;i<=n;i++)
        mp.a[i][i]=1;
    for(int i=1;i<=n;i++) mp.a[i][0]=1;
    int ans=0;
    scanf("%d",&t);
    Matrix anss=ksm(mp,t);
    for(int i=0;i<=n;i++) (ans+=anss.a[1][i])%=P;
    printf("%d\n",ans);
}
```

---

## 作者：lgswdn_SA (赞：42)

## 分层图DP

我做这题本来是冲着它那个“倍增”标签来的，结果进来一看，哟，不是标准的**分层图DP**嘛，愉快地敲起了代码，20分种，感谢我们可爱的氧气同志和评测机同志，痛快地AC了这题

分层图大家应该都知道（这其实就是DP），通常状态是：

$f[j][u][...]$代表在第$j$时刻，在节点$u$,然后状态为$...$的最优化/计数等

这道题就是个朴素的分层图DP，  

$f[j][u]$表示第$j$时刻，在节点$u$的情况数

然后是处理爆炸。当然我们可以加入状态，但是为了后面更好地做矩阵乘法，我们决定把他搬到生活中来

> 一个机器人，如果它选择了死亡，那么这将是它一个有去无回的路，一个不可逆转的路，它将永远呆在里面……

对就是这样！这是个有去无回的单向边！爆炸的死亡节点的路是无法逆转的！

好的，我们**创建一个死亡节点**$n+1$，所有点连向它，然而它不能连向别人

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=39,M=109; 
struct edge{int to,nxt;}e[(M+N)<<1]; int hd[N],tot;
void add(int u,int v){
	e[++tot]=(edge){v,hd[u]}; hd[u]=tot;
}
int n,m,t,ans,f[1000002][32];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++) scanf("%d%d",&u,&v),add(u,v),add(v,u);
	scanf("%d",&t);
	for(int i=1;i<=n;i++) add(i,n+1),add(i,i); f[0][1]=1; add(n+1,n+1);
	for(int j=0;j<=t;j++){
		for(int u=1;u<=n+1;u++){
			for(int i=hd[u];i;i=e[i].nxt){
				f[j+1][e[i].to]=(f[j+1][e[i].to]+f[j][u])%2017; 
			}
		}
	}
	for(int i=1;i<=n+1;i++) ans=(ans+f[t][i])%2017;
	printf("%d",ans);
	return 0;
}
```
（注：如果$f$数组再开大一点就会MLE，所以嘛。。。）

## 精益求精--矩阵乘法

经过氧气同志和评测机同志的不懈努力下，我们AC了这个题目

可是我们要有职业精神，取得更好的成绩，而不是依赖于我们的好朋友氧气和评测机

我们再看一眼转移方程：
```cpp
f[j+1][e[i].to]=(f[j+1][e[i].to]+f[j][u])%2017;
```

你看到了什么？**常系数线性变换**！而且$n\le 30$ ！这是**矩阵乘法**的标志!

推一下就知道，转移矩阵其实就是我们的邻接矩阵，于是，修改过的邻接矩阵做一个矩阵快速幂就好了

其实，我们可以看到，这道题就是传球游戏的一个变种，我们只需要加入死亡节点之后，一切就变得简单无比了

然后我们为了简化一下矩阵（其实也没多少），死亡节点变成$0$号节点

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,ans;
struct mat{ //朴素矩阵 
	int a[33][33];
	mat(){memset(a,0,sizeof(a));}
	mat operator *(const mat b)const{
		mat c;
		for(int i=0;i<=n;i++)
			for(int j=0;j<=n;j++)
				for(int k=0;k<=n;k++)
					c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j])%2017;
		return c;
	}
}I,E,ansm;
mat pow(mat a,int p){ //朴素快速幂 
	if(p==0) return I;
	if(p==1) return a;
	mat tmp=pow(a*a,p/2);
	if(p%2) return tmp*a;
	else return tmp;
}
int main(){
	scanf("%d%d",&n,&m,&t);
	for(int i=1,u,v;i<=m;i++) scanf("%d%d",&u,&v),E.a[u][v]=E.a[v][u]=1; //朴素邻接矩阵 
	for(int i=0;i<=n;i++) I.a[i][i]=E.a[i][i]=1,E.a[i][0]=1; //新边和单位矩阵 
	scanf("%d",&t); ansm=pow(E,t); //矩阵快速幂 
	for(int i=0;i<=n;i++) ans+=ansm.a[1][i]; //统计答案 
	printf("%d",ans%2017);
	return 0;
}
```

其实这份代码除了两行添加新边和统计答案，全部都是邻接矩阵快速幂的模板，所以其实这种题型需要更加熟练才行，说不定下次氧气和评测机就拯救不了你了呢

---

## 作者：Asuka二号机 (赞：13)

看了一圈下面的题解，关于邻接矩阵的k次方的解释基本上都是直接给结论的。

这题的连边已经有大佬解释了，爆炸相当于连一个虚拟点，停留相当于自环。

那么接下来我来解释一下那个神秘的结论。

先不考虑题设里的诡异操作。我们来思考一张简单图

![](https://cdn.luogu.com.cn/upload/pic/50067.png )

为了稍微复杂一点点，我们假定这里每个点都有个自环。

可以知道，邻接矩阵里长这样：

![](https://cdn.luogu.com.cn/upload/pic/50070.png)


思路是这样，我们举个例子，对于从1到1走两步的方案：
三种方案：

在1休息—在1休息。

去2—回1

去3—回1

对应到矩阵里，这些方案分别是：

1 1 *1 1     休息一次的方案数*休息一次的方案数

2 1*1 2      1->2的方案数*2->1的方案数

3 1*1 3      1->3的方案数*3->1的方案数

加起来，3种。

以及不成立的4 1*1 4=0      1->4——不通。

我们可以看出，这一步操作实际上做了一部分的矩阵乘法。

搞完整个表格，它就长成这样子：

![](https://cdn.luogu.com.cn/upload/pic/50069.png)

类似的，对于矩阵a的k次方，它的i行j列实际上就是跑k步，i恰好走到j的对应方案数。

跑板子，没了。

代码奉上。
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,j,k,t,y,x,anss,m,f[1001],mo=2017;
struct mat
{
    ll a[101][101];
    mat(){memset(a,0,sizeof(a));}
    void beg(){for(int i=1;i<=n;i++)a[i][i]=1;
    }
    
}a,ans;
mat operator *(const mat &x,const mat &y)
    {
    mat z;
    for(int k=1;k<=n;++k)
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j]%mo)%mo;
    return z;
    }
int main() 
{
    cin>>n>>m;
    n++;
    for(int i=1;i<=m;i++)
    {cin>>x>>y;a.a[x][y]=1;a.a[y][x]=1;}
    for(int i=1;i<=n;i++)a.a[i][n]=1,a.a[i][i]=1;
    ans.beg();
    cin>>k;
    do
    {
        if(k&1)ans=ans*a;
        a=a*a;k>>=1;
    }while(k);
    for(int i=1;i<=n;i++)(anss+=ans.a[1][i])%=mo;
    cout<<anss;
    return 0;
}
```

---

## 作者：Isonan (赞：8)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3758)

这道题另外两个操作有点棘手，如果只有第二个操作的话可以就用矩阵快速幂。

考虑把另外两个操作转化成连边的操作：

1可以看做向自己连了一条边；

3可以看做是它~~被发配边疆（雾）~~走到了一个点然后再也不回来了。

这样就可以建图快速幂了。

代码：

```cpp
#include <cstdio>
#include <cstring>

int matrix[31][31],tem[31][31],ans[31][31],n,m,T,s,t;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&s,&t);
		matrix[s][t]=matrix[t][s]=1;
	}
	scanf("%d",&T);
	for(int i=0;i<=n;i++)matrix[i][0]=matrix[i][i]=1,ans[i][i]=1;
	while(T){
		if(T&1){
			for(int i=0;i<=n;i++)
				for(int j=0;j<=n;j++)
					for(int k=0;k<=n;k++)
						tem[i][j]=(tem[i][j]+ans[i][k]*matrix[k][j])%2017;
			for(int i=0;i<=n;i++)
				for(int j=0;j<=n;j++)
					ans[i][j]=tem[i][j],tem[i][j]=0;
		}
		for(int i=0;i<=n;i++)
			for(int j=0;j<=n;j++)
				for(int k=0;k<=n;k++)
					tem[i][j]=(tem[i][j]+matrix[i][k]*matrix[k][j])%2017;
		for(int i=0;i<=n;i++)
			for(int j=0;j<=n;j++)
				matrix[i][j]=tem[i][j],tem[i][j]=0;
		T>>=1;
	}
	int fin=0;
	for(int i=0;i<=n;i++)fin=(fin+ans[1][i])%2017;
	printf("%d\n",fin);
}
```

---

## 作者：PrincessQi (赞：7)

首先看到这个题，感觉非常不可做……

然后尝试写了个暴力。

由于这个题的$n$不是很大，所以我们采用邻接矩阵来存储图的关系。

而且对于停在原地可以将它看成自环；对于自爆可以虚拟出一个节点$0$，使每个节点都向它连有边，而它只向自己连有边。

对于第$i$秒之后到达$j$节点的方案数$dp[i][j]$，有状态转移方程$dp[i][j]=\sum\limits_{k=0}^ndp[i-1][k]*mp[k][j]$。

然鹅这样复杂度为$O(t*n^2)$，理论上来讲可能会被卡掉，那我们想想有没有更优的做法呢？

其实这题的主要卡点在于，$t$太大了，只要复杂度里带上了$t$，就有可能被卡掉。

那有没有比$O(t)$更快的复杂度呢？

$O(\log t)$！

于是我们来想想带$\log$的算法。

树状数组？线段树？平衡树？~~显然不是~~

二分查找？二分答案？堆？~~那更不可能了~~

于是我们想到了分治！

然后我们可以令$mdp[i][j][k]$为经过$i$秒从$j$走到$k$的方案数。

则$mdp[i][j][k]=\sum\limits_{l=0}^nmdp[i-x][j][l]*mdp[x][l][k]$（其中$x$为任意常数）。

且$mdp[1][i][j]=mp[i][j]$。

所求结果就是$\sum\limits_{i=0}^nmdp[t][1][i]$。

然后我们就可以利用分治求解了。

具体代码我就不上了，毕竟这题不难实现，而且这里主要讲思想。

---

## 作者：DennyQi (赞：6)

# 关于自爆的处理

众多题解的做法都是创建一个虚拟点0让他走过去，确实非常巧妙，但是像我这样的蒟蒻是想不到这样巧妙的方法的……

考虑自爆意味着停止行动。所以题目让我们求的其实等价于时间为0,1,2,3...t的所有方案。

假设邻接矩阵为$G$，则对于时间为$t$的情况，答案应该是$G^t$的第一行之和。因此所有情况的答案就是$1+G+G^1+G^2+...+G^t$的第一行之和

考虑使用分块矩阵，构建一个如下矩阵：$$\begin{bmatrix}G & G\\ 0 & 1\end{bmatrix}$$容易发现，这样的矩阵自乘$t$次以后右上角就是我们所要求的$1+G+G^1+G^2+...+G^t$。因此统计一下第一行就可以了

```cpp
/*By DennyQi 2018*/
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 10010;
const int MAXM = 20010;
const int INF = 1061109567;
inline int Max(const int a, const int b){ return (a > b) ? a : b; }
inline int Min(const int a, const int b){ return (a < b) ? a : b; }
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' && (c < '0' || c > '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x<<3) + (x<<1) + c - '0'; return x * w;
}
int N,M,x,y,t;
int a[35][35],g[100][100],ans[100][100],b[100][100];
inline void Matrix_ksm(int y){
	while(y > 0){
		if(y & 1){
			for(int i = 1; i <= 2*N; ++i){
				for(int j = 1; j <= 2*N; ++j){
					b[i][j] = 0;
					for(int k = 1; k <= 2*N; ++k){
						b[i][j] = (b[i][j] + ans[i][k] * g[k][j]) % 2017;
					}
				}
			}
			for(int i = 1; i <= 2*N; ++i){
				for(int j = 1; j <= 2*N; ++j){
					ans[i][j] = b[i][j];
				}
			}
		}
		y /= 2;
		for(int i = 1; i <= 2*N; ++i){
			for(int j = 1; j <= 2*N; ++j){
				b[i][j] = 0;
				for(int k = 1; k <= 2*N; ++k){
					b[i][j] = (b[i][j] + g[i][k] * g[k][j]) % 2017;
				}
			}
		}
		for(int i = 1; i <= 2*N; ++i){
			for(int j = 1; j <= 2*N; ++j){
				g[i][j] = b[i][j];
			}
		}
	}
}
int main(){
//	freopen(".in","r",stdin);
	N = read(), M = read();
	for(int i = 1; i <= M; ++i){
		x = read(), y = read();
		a[x][y] = 1;
		a[y][x] = 1;
	}
	t = read();
	for(int i = 1; i <= N; ++i){
		a[i][i] = 1;
	}
	for(int i = 1; i <= N; ++i){
		for(int j = 1; j <= N; ++j){
			g[i][j] = a[i][j];
			g[i][j+N] = a[i][j];
		}
	}
	for(int i = N+1; i <= 2*N; ++i){
		g[i][i] = 1;
	}
	for(int i = 1; i <= 2*N; ++i){
		ans[i][i] = 1;
	}
	Matrix_ksm(t);
	int Ans = 1;
	for(int i = N+1; i <= N*2; ++i){
		Ans = (Ans + ans[1][i]) % 2017;
	}
	printf("%d", Ans);
	return 0;
}
```

---

## 作者：Caro23333 (赞：5)

#### 这道题的正解真是太妙辣！
然而蒟蒻先写了个暴力企图数据有梯度试试能得多少分
~~（然后AC了~~

选择递推

f[i][j][0]:当前为第i秒末，位于节点j，没有爆炸过的方案数

f[i][j][1]:当前为第i秒末，位于节点j，在第i秒末之前已经爆炸过的方案数

于是有:
f[i][j][0] = sigma(f[i-1][k][0] | k与j相连)+f[i-1][j][0]

f[i][j][1] = f[i-1][j][0]+f[i-1][j][1]

时间复杂度O(t*n)
##### ~~（可能需要一个O2~~
另外观察到这道题目的空间限制为128mb，而对于存下整个状态数组是显然不够的；但因为每个f[i]仅仅从f[i-1]转移而来，所以使用**滚动数组**，只需要存储f[i]和f[i-1]的状态就可以了

#### 代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>

using namespace std;
int f[3][31][3];
int n,m;
int map[31][33];
inline int add(int x, int y)
{
    register int res = x+y;
    res -= (res>=2017)*2017;
    return res;
}
int main()
{
    cin >> n >> m;
    int u,v;
    for(int i = 1; i<=m; i++)
    {
        scanf("%d%d",&u,&v);
        map[u][++map[u][0]] = v;
        map[v][++map[v][0]] = u;
    }
    register int t,ans = 0,tmp1,tmp2;
    cin >> t;
    f[0][1][0] = 1;
    for(register int i = 1; i<=t; i++)
    {
        tmp1 = i&1, tmp2 = i&1^1;
        for(register int j = 1; j<=30; j++)
        {
        	f[tmp1][j][0] = f[tmp2][j][0];
            for(register int *k = map[j]+1; k<=map[j]+map[j][0]; k++)
                f[tmp1][j][0] = add(f[tmp1][j][0],f[tmp2][*k][0]);
            f[tmp1][j][1] = add(f[tmp2][j][0],f[tmp2][j][1]);
            ans = add(ans,(i==t)*add(f[tmp1][j][0],f[tmp1][j][1]));
        }
    }
    cout << ans << endl;
 	return 0;
}
```




---

## 作者：elijahqi (赞：3)

对于100%的pn，有1 < t ≤ 10^6。

这需要一些巧妙的思想 看到题的第一眼大概就是记忆话搜索或者直接递推式进行计算

鉴于时间卡的非常紧 剩余80%的数据直接10^6啊 只好用矩阵加速一下

【数据范围】 对于20%的pn，有1 < t ≤ 1000

对于100%的pn，有1 < t ≤ 10^6。

可以看出总方案数＝t 秒后处于各个位置的可能加上所有已经爆炸了的可能

所以我们可以根据此构造矩阵    设矩阵为P

P(ij) 表示i与j 之间有边相连 填1 这里我们矩阵都是从(0,0)开始的因为我们需要计算爆炸的数目

样例：

0 1 0 0              1 0 0 0                                   1 1 1 0

0 0 0 0     \*        1 1 1 0  ----------------------->  0 0 0 0

1 1 1 1

1 0 1 1


由于我们不停乘相同矩阵 所以我们可以使用快速幂优化下我们矩阵的倍增

下面代码也有注释

```cpp
#include<cstdio>
#include<cstring>
#define N 2017
struct matrix{
    int f[33][33],l,c;
}base1,base,base2,p;
int x[110],y[110],n,m,ans,t;
inline matrix multiply(matrix a,matrix b){
    matrix c;memset(c.f,0,sizeof(c));
    c.l=a.l;c.c=b.c;
    for (int i=0;i<=c.l;++i)
        for (int j=0;j<=c.c;++j){
            for (int z=0;z<=a.c;++z){
                (c.f[i][j]+=a.f[i][z]*b.f[z][j]%N)%=N;
            }
        }    
    return c;
}
void build(){
    memset(base1.f,0,sizeof(base1.f));
    base1.l=base1.c=n;
    for (int i=1;i<=n;++i)
        for (int j=1;j<=n;++j) if (i==j) base1.f[i][j]=1;
    memset(base.f,0,sizeof(base.f));
    base.l=base.c=n;
    base.f[0][0]=1;
    for (int i=1;i<=m;++i){
        base.f[x[i]][y[i]]=1;
        base.f[y[i]][x[i]]=1;
    }
    for (int i=1;i<=n;++i) base.f[i][i]=1,base.f[i][0]=1;
    memset(base2.f,0,sizeof(base2.f));
    base2.l=1;base2.c=n;base2.f[0][1]=1;
}
int main(){
    //freopen("3758.in","r",stdin);
    //freopen("3758.out","w",stdout);
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;++i) scanf("%d%d",&x[i],&y[i]);scanf("%d",&t);
    build();//构造初始矩阵
    for (;t!=0;t>>=1,base=multiply(base,base))    //矩阵快速幂（矩阵倍增）
        if (t&1) base2=multiply(base2,base);
    for (int i=0;i<=n;++i) (ans+=base2.f[0][i]%N)%=N; //最后的答案全部位于矩阵的第0行 第0列是所有爆炸的数量 剩下1~n是那个点的数量
    printf("%d ",ans);
    return 0;
} 
```

---

## 作者：IceFox (赞：2)

f[0][i][t]表示第t秒到i的全部方案（含之前已经在i炸掉的）f[1][i][t]表示第t秒到i而且还在i没炸的方案数，则

f[0][i][t]=f[0][i][t-1]+f[1][j][t-1]+f[1][j][t-1]|i,j之间有边

f[1][i][t]=f[1][j][t-1]+f[1][i][t-1]|i,j之间有边 

t=10^9，需要矩阵倍增加速。

欢迎到[我的blog](http://blog.csdn.net/icefox\_zhx/article/details/77327525)查看更详细题解

```cpp
#include <cstdio>
#include <cstring>
#define mod 2017
#define ll long long
int const N=31;
int n,m,tt,h[N],num=0,ans=0;
struct edge{int to,next;}data[101<<1];
struct matrix{
    int f[N<<1][N<<1];
    //f[i]到i全部方案，f[n+i]到i没炸的方案。 
    matrix(){memset(f,0,sizeof(f));}
    matrix operator*(const matrix b){
        matrix res;
        for(int i=1;i<=n<<1;++i)
            for(int j=1;j<=n<<1;++j)
                for(int k=1;k<=n<<1;++k)
                    res.f[i][j]=(res.f[i][j]+(ll)f[i][k]*b.f[k][j])%mod;
        return res;
    }
}a,base;
inline int read(){
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}
int main(){
//  freopen("cola.in","r",stdin);
//  freopen("cola.out","w",stdout);
    n=read();m=read();
    for(int i=1;i<=m;i++){
        int x=read(),y=read();
        data[++num].to=y;data[num].next=h[x];h[x]=num;
        data[++num].to=x;data[num].next=h[y];h[y]=num;
    }
    tt=read();
    a.f[1][1]=a.f[1][n+1]=1;
    for(int i=1;i<=n;i++){
        base.f[i][i]=base.f[n+i][i]=base.f[n+i][n+i]=1;
        for(int j=h[i];j;j=data[j].next){
            int y=data[j].to;
            base.f[n+y][i]=base.f[n+y][n+i]=1;
        }
    }
    for(;tt;tt>>=1,base=base*base)
        if(tt&1) a=a*base;
    for(int i=1;i<=n;++i) ans=(ans+a.f[1][i])%mod;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：huangwenlong (赞：0)

没用矩阵加速，不知怎的我就用普通DP水过去了……

[推销自己博客](http://ssttkkl.top/posts/ShengXuan/2018/03/%E3%80%90TJOI2017%E3%80%91%E5%8F%AF%E4%B9%90/)

-----

每一秒的决策有三种：走到相邻的节点，停留在原地，自爆。令$f(i,j)$表示第$i$秒在$j$点的方案数，容易得DP状转方程：

$$f(i,j)=\sum_{k\ \mathrm{is\ adjacent\ to}\ i} f(i+1,k)+f(i+1,j)+1$$

最终答案就是$f(0,1)$

```cpp
#include <iostream>
#define maxn 35
#define maxm 105
#define maxt 1000005
using namespace std;
int add(int x, int y)
{
    int ans = x + y;
    if (ans >= 2017)
        ans -= 2017;
    return ans;
}
struct edge
{
    int to, next;
} edges[maxm * 2];
int head[maxn], ecnt;
void addedge(int u, int v)
{
    ecnt++;
    edges[ecnt].to = v;
    edges[ecnt].next = head[u];
    head[u] = ecnt;
}
int n, m, t, dp[2][maxn];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int a, b;
        cin >> a >> b;
        addedge(a, b);
        addedge(b, a);
    }
    cin >> t;
    for (int i = t; i >= 0; i--)
    {
        for (int v = 1; v <= n; v++)
        {
            dp[i & 1][v] = add(1, dp[(i + 1) & 1][v]);
            for (int j = head[v]; j; j = edges[j].next)
            {
                int w = edges[j].to;
                dp[i & 1][v] = add(dp[i & 1][v], dp[(i + 1) & 1][w]);
            }
        }
    }
    cout << dp[0][1];
    return 0;
}
```



---


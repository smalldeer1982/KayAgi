# [TJOI2009] 宝藏

## 题目描述

为了寻找传说中的宝藏，小明走进了一个迷宫，我们用一个 $r$ 行 $c$ 列的矩阵来描述这个迷宫，矩阵的每个位置表示一个方块区域：

- 字符 `.` 表示可以通过的方格。
- 字符 `#` 表示不能通过的方格。
- 在迷宫中有 $k$ 个机关，第 $i$ 个机关工作方式为：  
  - 每当小明走上第 $r_i$ 行，$c_i$ 列的格子时，位于第 $R_i$ 行，$C_i$ 列的格子改变状态（如果这个格子此时可以通过，此后就变为不能通过；如果此时不能通过，此后可以通过。最左上角的格子是第 $1$ 行第 $1$ 列）。

现给出当前小明的位置，宝藏的位置，迷宫中每个格子的状态，以及所有机关的描述，问小明至少还要走多少步才能拿到宝藏（不能走出迷宫的边界，在开始时刻，小明和宝藏所在的位置都是可以通过的，机关不会出现在起点和终点，也不会影响这两个格子）。


## 说明/提示

### 数据范围及约定

对于全部数据，$5 \le r, c \le 30$，$0 \le k \le 10$，$1 \le r_i,R_i\le r$，$1 \le c_i,C_i \le c$。


## 样例 #1

### 输入

```
5 5
S.#..
#####
..#..
##.#.
...#T
6
1 5 4 2
1 4 3 3
5 1 3 3
1 4 4 5
1 2 1 3
1 5 2 1
```

### 输出

```
22```

# 题解

## 作者：lenlen (赞：31)

### Problem

题目大意：给你一张地图，其中有 $N$ 个机关，每个机关踩一次可以使对应的地方的格子内让能走变成不能走，或者是不能走变成能走，问从 $S$ 到 $T$ 的最少步数。

数据范围： $n,m \leq 30,N \leq 10$。

### Solution

看到 $N \leq 10$，可以想到肯定是运用状态压缩来记录每个状态已经触发了哪些机关奇数次（偶数次等于每触发）。

再因为是棋盘问题，还是最优步数，可以想到是搜索。而查找最优步数那必然是广搜好很多。所以我们可以定义一个状态为 $\{x,y,dep,k\}$，表示当前在 $x,y$ 处，已走了 $dep$ 步，且当前机关触发奇数次状态为 $k$，进行广搜即可。

每要到一个地方时，可以看看所有机关中有没有影响这个地方的，若影响了奇数次，那么就不能走（若本身为 # ，那么也要记一次，用异或可以快速解决）；同时判断一下走了这一步之后会不会触发什么机关，记得更新状态（异或解决）。

两个注意点：

1. 是从 $S$ 到 $T$ 而不要想当然的以为是 $1,1$ 到 $n,n$ （可能只有我会犯这么低级的错误吧 qwq）；

2. 要记忆化搜索，不然会 MLE（队列里面空间会炸），若 $x,y,k$ 已被访问过，那么就不再访问。

### Code

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,N,stx,sty;
struct hl{
    int a,b,x,y;
}t[11];
char mp[32][32];
string s;
struct len{
    int x,y,dep,k;
}tmp;
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
bool vis[32][32][1<<12];
queue<len> q;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        cin>>s;s='?'+s;
        for(int j=1;j<=m;j++) 
        {
            mp[i][j]=s[j];
            if(mp[i][j]=='S') stx=i,sty=j;
        }
    }
    scanf("%d",&N);
    for(int i=1;i<=N;i++) scanf("%d%d%d%d",&t[i].a,&t[i].b,&t[i].x,&t[i].y);
    q.push((len){stx,sty,0,0});
    vis[stx][sty][0]=true;
    while (!q.empty())
    {
        tmp=q.front();q.pop();
        if(mp[tmp.x][tmp.y]=='T')
        {
            printf("%d\n",tmp.dep);
            return 0;
        }
        for(int i=0;i<4;i++)
        {
            int xx=tmp.x+dx[i],yy=tmp.y+dy[i];
            if(xx<1||xx>n||yy<1||yy>m) continue;
            int flag,kk=tmp.k;
            if(mp[xx][yy]=='#') flag=0;
            else flag=1;
            for(int j=1;j<=N;j++)
            {
                if(xx==t[j].x&&yy==t[j].y&&((tmp.k>>j-1)&1)) flag^=1;
                if(xx==t[j].a&&yy==t[j].b) kk^=(1<<j-1);
            }
            if(flag&&!vis[xx][yy][kk]) 
            {
                vis[xx][yy][kk]=true;
                q.push((len){xx,yy,tmp.dep+1,kk});
            }
        }
    }
    
}

```


---

## 作者：iyaang (赞：9)

# 【TJOI2009】宝藏

[题目链接](https://www.luogu.com.cn/problem/P3869)

感谢 @My_Youth 的错误纠正。

看到走地图问题，自然联想到广搜，这个题前两篇题解讲的很清楚了，要带着机关状态走。最多只有十个机关，考虑状压。但是大佬们的装压我都看不懂捏，特意来补一下基础二进制知识。

我们将每个机关状态压成一个二进制数的每一位，第 $i$ 个机关在这个数中就是第 $i$ 位，那么检查和修改就只要用到下面两个操作。

` (n>>k)&1   //取出n在二进制下的第k位`

` n^(1<<k)   //将n在二进制下的第k位取反`

由于奇妙的题意，所以这个题有很多小坑，一个格子可能既操控机关，又被机关影响。一个操控机关的格子可以反复横跳去踩。等等。

剩下的详见代码吧，写了注释的捏。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MAX 50
using namespace std;

inline int read()
{
    int s=0,w=1;
    char c=getchar();
    while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
    while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
    return s*w;
}

int r,c,n,ans;
char m[MAX][MAX];
int br,bc,er,ec;
bool cause[MAX][MAX],so[MAX][MAX];   //cause是操控机关的  so是被机关影响的 
struct op
{
    int r1,c1,r2,c2;
}o[20];
bool vis[MAX][MAX][3000];            //二进制下十个机关最多 1<<10=2048 三维分别是坐标和机关状态，这样可以防止无意义的横跳 
struct node
{
    int x,y;
    int mac,dis;                     //dis是步数   mac是机关状态 
};
queue<node> q;

int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};

void check(int x,int y,node &a)                   //把每个这个格子操控的机关都打开或者关上 
{
    for(int i=1;i<=n;i++)
        if(x==o[i].r1&&y==o[i].c1)
            a.mac=a.mac^(1<<i);  
    return;
}
int cheeck(int x,int y,int state)                 //可能多个机关操控一个格子，所以要把每个与其相关的操控机关都检查一遍 
{
    int k=0;
    for(int i=1;i<=n;i++)
        if(x==o[i].r2&&y==o[i].c2&&((state>>i)&1))
        	k^=1;
    return k;
}

int main()
{
    r=read(),c=read();
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
        {
            cin>>m[i][j];
            if(m[i][j]=='S') br=i,bc=j,m[i][j]='.';
            if(m[i][j]=='T') er=i,ec=j,m[i][j]='.';
        }
    n=read();
    for(int i=1;i<=n;i++)
    {
        o[i].r1=read(),o[i].c1=read(),o[i].r2=read(),o[i].c2=read();
        cause[o[i].r1][o[i].c1]=1,so[o[i].r2][o[i].c2]=1;
    }   
    node t;
    t.x=br,t.y=bc,t.dis=0,t.mac=0;
    vis[t.x][t.y][t.mac]=1;
    q.push(t);
    while(!q.empty())
    {
        t=q.front(); q.pop();
        if(t.x==er&&t.y==ec) 
        {
            ans=t.dis;
            break;
        }
        for(int i=0;i<4;i++)
        {
            int tx=dx[i]+t.x,ty=dy[i]+t.y;
            if(tx>=1&&ty>=1&&tx<=r&&ty<=c)
            {
                if(!cause[tx][ty]&&!so[tx][ty]&&m[tx][ty]=='.') 
                {//都不是
                    node tt;
                    tt.x=tx,tt.y=ty,tt.dis=t.dis+1,tt.mac=t.mac;
                    if(!vis[tt.x][tt.y][tt.mac])
                    {
                        vis[tt.x][tt.y][tt.mac]=1;
                        q.push(tt);
                    }
                }
                if(cause[tx][ty] && !so[tx][ty])
                {//cause
                	if(m[tx][ty]!='.') continue;
                    node tt;
                    tt.x=tx,tt.y=ty,tt.dis=t.dis+1,tt.mac=t.mac;
                    check(tx,ty,tt);
                    if(!vis[tt.x][tt.y][tt.mac])
                    {
                        vis[tt.x][tt.y][tt.mac]=1;
                        q.push(tt);
                    }      
                }
                if(so[tx][ty])
                {//so+cause || so    这个地方要注意，可能是so套着cause，因为这个第一发拿了60 
                    int state=cheeck(tx,ty,t.mac);
                    if((state&&m[tx][ty]=='#')||(!state&&m[tx][ty]=='.'))
                    {//能走
                    	if(cause[tx][ty])
		                {
		                	//cause+so
		                    node tt;
		                    tt.x=tx,tt.y=ty,tt.dis=t.dis+1,tt.mac=t.mac;
		                    check(tx,ty,tt);
		                    if(!vis[tt.x][tt.y][tt.mac])
		                    {
		                        vis[tt.x][tt.y][tt.mac]=1;
		                        q.push(tt);
		                    }
		                    continue;
		                }
                    	//只so
                        node tt;
                        tt.x=tx,tt.y=ty,tt.dis=t.dis+1,tt.mac=t.mac;
                        if(!vis[tt.x][tt.y][tt.mac])
                        {
                            vis[tt.x][tt.y][tt.mac]=1;
                            q.push(tt);
                        }
                    }
                }
            }
        }
    }
    cout<<ans;
    return (0-0);
}
```


---

## 作者：我是逍逍 (赞：9)

#### 前言

我做这道题的原因，是另一篇题解的作者 **unsigned_short_int** 强烈要求我做，并对我的 **Unaccepted** 悲惨命运做了预言。为了打压 **unsigned_short_int** 旺盛的气焰，证明自己的实力，提升自己的代码编写能力，顺便补充一种时间复杂度更小的解法，特来发题解。

#### 题意

在一个 $R \times C$ 的地图里，有一些点可以通过，用 `.` 表示，有一些点不能通过，用 `#` 表示。小明从起点 $S(x_s,y_s)$ 出发，用最少的步数到达终点 $T(x_t,y_t)$ 。地图中有 $k$ 个机关，记为 $f(x_1,x_2, y_1, y_2)$ ，表示当小明到达 $(x_1, y_1)$ 时， $(x_2, y_2)$ 的状态改变，即可达变为不可达，不可达变为可达。

#### 算法

由数据量 $0 < R,C \leq 30$ 可以想到用广搜模拟过程， 由 $0 \leq k \leq 10$ 可以想到用状态压缩的方式记录机关状态。用 $f_p \in \{0, 1\}$ 表示某一时刻编号为 $p$ 的机关能否通过，则 $k$ 个机关的总体状态可以表示为 $(f_1, f_2, \cdots, f_n)$ ，参照 **unsigned_short_int** 的做法，总体状态可以表示为 $status = f_1 \times 2^1 + f_2 \times 2^2 + \cdots + f_k \times 2^k$ 。

搜索时，记录四元组 $(x,y,status,step)$  表示用 $step$ 步，在机关状态为 $status$ 时到达点 $(x,y)$ 。当 **第一次** 到达 $T(x_t, y_t)$ 时，此时的 $step$ 即为最优解，因为在广搜的队列中， $step$ 具有 **单调不降性**（请 **unsigned_short_int** 注意这点）。搜索过程中，我们维持地图状态不变，只通过 $status$ 的值反映当前所有机关的状态 （灵活使用异或、与运算~）。

#### 代码

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int Max = 35;
const int d[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};

struct Pos {
    int x, y;

    bool operator==(const Pos &cmp) const {
        return x == cmp.x && y == cmp.y;
    }
};

struct Bfs {
    Pos pos;
    int status, step;
};

Pos s, t, f[Max];
vector<int> b[Max][Max];
queue<Bfs> q;
int r, c, k, tmp, n[Max][Max];
bool a[Max][Max], vis[Max][Max][1 << 12];

int main() {
    cin >> r >> c;
    for (int i = 1; i <= r; i++) {
        for (int j = 1; j <= c; j++) {
            char chr;
            cin >> chr;
            if (chr != '#') {
                a[i][j] = true;
                if (chr == 'S')
                    s = {i, j};
                else if (chr == 'T')
                    t = {i, j};
            }
        }
    }
    cin >> k;
    for (int i = 1, x, y; i <= k; i++) {
        cin >> x >> y >> f[i].x >> f[i].y;
        n[f[i].x][f[i].y] = i; // 给机关编号
        b[x][y].push_back(i); // 将机关的关系添加到对应点
        tmp += (1 << n[f[i].x][f[i].y]) * a[f[i].x][f[i].y]; // 记录机关初始状态
    }

    q.push((Bfs) {s, tmp, 0});
    vis[s.x][s.y][tmp] = true;

    while (!q.empty()) {
        auto x = q.front();
        q.pop();
        if (x.pos == t) {
            cout << x.step << endl;
            return 0;
        }

        for (auto i: d) {
            Pos p = {x.pos.x + i[0], x.pos.y + i[1]}; 

            if (p.x && p.y && p.x <= r && p.y <= c && // 不越界
                ((!n[p.x][p.y] && a[p.x][p.y]) || // 不是机关 从地图判断能否通过
                 (x.status & (1 << n[p.x][p.y])))) { // 是机关 从 status 判断是否能通过

                Bfs y = {p, x.status, x.step + 1};
                for (auto j: b[p.x][p.y]) // 更新机关状态
                    y.status ^= 1 << n[f[j].x][f[j].y];

                if (!vis[p.x][p.y][y.status]) {
                    vis[p.x][p.y][y.status] = true;
                    q.push(y);
                }
            }
        }
    }
    return 0;
}
```



---

## 作者：unsigned_short_int (赞：6)

20220930 Update: 优化题解内容以及代码时间复杂度

### 蒟蒻的第一篇题解  

[题目传送门](https://www.luogu.com.cn/problem/P3869)  
注意：数据中**不存在**机关影响点和机关重合的情况！  

------------

首先，观察数据量可知，这是一道单纯的广搜。  
1. 一个点可能访问多次。
1. 广搜时机关的状态会实时改变，所以考虑使用状态压缩，将其表示为一个 $01$ 串再压成一个整数。实际操作中，可以用位运算实现。

综上，可以维护一个数组 $f(x, y, stat)$ ，初始为无穷大，表示走到点 $(x, y)$ 且机关状态是 $stat$ 时所花费的最少步数。广搜入队判断为：这次产生 $f(x, y, stat)$ 的状态是否优于此前该状态最优解；如果是，就更新 $f(x, y, stat)$ 并将该点入队。  

上代码：
```cpp
#include <iostream>
#include<queue>
#include<cstring>
using namespace std;

const int N=35,dir[5][2]={{0,0},{1,0},{-1,0},{0,1},{0,-1}},Inf=0x3f3f3f3f;
int n,m,r[N],c[N],R[N],C[N],k,f[N][N][2048];
bool a[N][N]; //记录地图 
struct node
{
	int stat,x,y; //分别是机关状态，x坐标，y坐标 
	node(int _stat=0,int _x=0,int _y=0):stat(_stat),x(_x),y(_y){}//结构体初始化构造函数
};
queue<node>q;

inline bool check(int x,int y,int st) //判断机关状态为st时点(x, y)是不是墙 
{
	bool ret=a[x][y];
	for(int i=1;i<=k;i++)
	{
		if(R[i]==x&&C[i]==y)
			ret ^= bool(st & (1<<i-1));
	}
	return ret;
}

inline int newStat(int x,int y,int st) //求出机关状态为st时走到了点(x, y)后机关的新状态 
{
	int ret = st;
	for(int i=1;i<=k;i++)
	{
		if(r[i]==x&&c[i]==y)
			ret ^= 1<<i-1;
	}
	return ret;
}

int main()
{
	int sx,sy,ex,ey;
	memset(f,0x3f,sizeof f);
	
	//输入 
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char c;
			cin>>c;
			if(c=='#')
				a[i][j]=true; //记录初始地图 
			if(c=='S')
				sx=i,sy=j; //记录起点 
			if(c=='T')
				ex=i,ey=j; //记录终点 
		}
	}
	cin>>k;
	for(int i=1;i<=k;i++)
		cin>>r[i]>>c[i]>>R[i]>>C[i];

	//广搜 
	f[sx][sy][0]=0;
	q.push(node(0,sx,sy));
	while(!q.empty())
	{
		node h=q.front();
		q.pop();
		for(int i=1;i<=4;i++)
		{
			int nx=h.x+dir[i][0],ny=h.y+dir[i][1];
			if(nx<1||ny<1||nx>n||ny>m||check(nx,ny,h.stat)) //判断是否合法
				continue;
			int ns=newStat(nx,ny,h.stat);
			if(f[nx][ny][ns]>f[h.x][h.y][h.stat]+1) //比原最优解更优才能入队并更新最优解 
			{
				q.push(node(ns,nx,ny));
				f[nx][ny][ns]=f[h.x][h.y][h.stat]+1;
			}
		}
	}

	//输出 
	int ans=Inf;
	for(int i=0;i<1<<k;i++)
		ans=min(ans,f[ex][ey][i]); //取终点上的最优解 
	cout<<ans;
	return 0;
}
```


---

## 作者：WaterM (赞：3)

[传送门](https://www.luogu.com.cn/problem/P3869)  
这道题首先一眼瞟……应该是 BFS 吧……  
再一眼瞟……诶有机关……说明是不是要存一下**机关的状态**哦……  
——由此，便可以想到**状态压缩**存机关的状态。  
  
我们可以先写一个暴力的 BFS（用数组存**走到每一步时之前机关的状态**），然后来尝试优化（每道难题不都是这个思路）。暴力的 BFS 代码在此不再赘述。  
  
然后写状态压缩：  
状态压缩的就是**用一个变量存一个集合**，这样可以省下暴力的许多空间~  
用一个变量的**二进制位**存所有的机关状态：触发 or 未触发（代码中触发为 $1$，未触发为 $0$）。要改变每一位的状态，只需使用**位运算**取出每一位进行操作即可。  
具体来说，定义 $s$ 为一个状态变量，修改或查询每一位的状态如下（位运算都清楚吧，不会的百度一下~）：
```cpp
s^=1<<i;//修改第i（i从0开始）个机关的状态，触发变为未触发，未触发变为触发
s>>i&1;//查询第i个机关的状态，用于判断某位置机关是否能走
```
于是，我们就可以把这个状态塞进队列的结构体中，方便查询。  
代码见下：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f
#define Linf 0x3f3f3f3f3f3f3f3f
const int N=32;
ll n,m,sx,sy,ex,ey;
char g[N][N];
ll k,r[N],c[N],R[N],C[N];

const ll dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
struct node{ll x,y,dis,s;};
std::queue<node> q;
bool vis[N][N][1<<11];//vis[x][y][s]：(x,y)位置，之前触发了s（集合）的机关的最短路径是否被计算来
ll BFS(node st){
	q.push(st),vis[st.x][st.y][0]=true;//在起点，之前触发机关的集合为空集标记为真
	while(!q.empty()){
		node u=q.front();q.pop();
		if(u.x==ex&&u.y==ey) return u.dis;
		for(ll i=0;i<4;++i){//四个方向
			ll nx=u.x+dir[i][0],ny=u.y+dir[i][1];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m){//不越界
				ll ok=g[nx][ny]=='#'?0:1,s=u.s;
				for(ll j=0;j<k;++j){//枚举每个机关
					if(nx==r[j]&&ny==c[j]) s^=1<<j;//第j个机关在之前的集合中
					if(nx==R[j]&&ny==C[j]&&(u.s>>j&1)) ok^=1;//在第j个机关的目标点上，因为ok只有一位，所以异或1相当于取反
				}
				if(ok&&!vis[nx][ny][s]){//该位置可以走且未被访问过
					q.push((node){nx,ny,u.dis+1,s});
					vis[nx][ny][s]=true;
				}
			}
		}
	}
	return -1;
}
int main(){
	std::cin>>n>>m;
	for(ll i=1;i<=n;++i)
		for(ll j=1;j<=m;++j){
			std::cin>>g[i][j];
			if(g[i][j]=='S') sx=i,sy=j;
			if(g[i][j]=='T') ex=i,ey=j;
		}
	std::cin>>k;
	for(ll i=0;i<k;++i) std::cin>>r[i]>>c[i]>>R[i]>>C[i];//从0开始，更方便写状态的查询修改
	
	std::cout<<BFS((node){sx,sy,0,0});
    return 0;
}
```

---

## 作者：lupengheyyds (赞：2)

# 一、题目描述：
[原题链接](https://www.luogu.com.cn/problem/P3869) 请大家在原题查看，这里不再赘述。

# 二、思路：
### 一、朴素版
既然这是一道“走地图：类型的题目，则自然就可以想到 BFS 。

与普通的 BFS 不同的是，这道题有“机关”，也就是会对原有的地图进行修改，且对于不同的顺序，不同的走法，所得到的地图。

既然地图随着过程改变，那我们把地图与位置、步数等信息封装成一个状态，当作一个整体操作，不就好了吗？于是：
```
const int szl=35;
struct node{
	int x,y,step;//x,y表示位置，step表示当前步数
	bool mp[szl][szl];//true为可以走，false为不能走
};
queue<node> que;
```
因为对于任意的地图，我们将起点与重点确定后，就只有能走与不能走之分，所以可以用 bool 进行存储

接着对于每一个状态，就着各自的地图往上下左右四个方向进行枚举：
```
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
bool check_err(node f){
	if(f.x<1||f.y<1||f.x>n||f.y>m)return true;
	return !f.mp[f.x][f.y];
}
void deal_danger(node &f){//注意取地址符
	for(int i=0;i<vv[f.x][f.y].size();i++){//枚举当前状态所触发的机关
		int x=vv[f.x][f.y][i].x,y=vv[f.x][f.y][i].y;
		f.mp[x][y]^=1;//将其改变取反
	}
	return;
}
int bfs(){
	node f={bex,bey,0};
	memcpy(f.mp,vst,sizeof(vst));
	que.push(f);
	while(!que.empty()){
		node f=que.front();que.pop();
		if(f.x==endx&&f.y==endy)return f.step;//找到宝藏
		for(int i=0;i<4;i++){
			node nf={f.x+dx[i],f.y+dy[i],f.step+1};//四个方向，用方向数组可以减少码量
			memcpy(nf.mp,f.mp,sizeof(f.mp));//传递地图
			if(check_err(nf))continue;
			deal_danger(nf);//处理机关
			que.push(nf);
		}
	}
	return -1;//虽然题目保证有解，但返回特殊的无解答案可以更好的进行调试
}
```
最后再将 bfs 返回值输出即可。

可是 $\color{red}10$ 分，超出空间限制了，是数组过多（队列中每个元素都有一个）和重复入队导致队列溢出。接下来我们会就着这两个点进行优化

### 二、状态压缩版：
构造一个整数 $k$ ， 
使其在二进制下的每一位都刚好对应着地图的每一个状态，即
$k_i \gets mp_{a,b}$

其中 $k_i$ 表示 $k$ 在二进制表示下的第 $i$ 位， $mp_{a,b}$表示地图第 $a$ 行，第 $b$ 列的状态。

为了一一对应，我们可以设计：

$k_{(a-1)\times c+b} \gets mp_{a,b}$

这就是二进制压缩。
使用二进制压缩，可以将空间压缩至八分之一。

由于 $5\le r,c \le 30$ ，总共最多有 $900$ 个位置，如果只用整数，一定超范围。这里就可以使用 STL bitset

可还是 $\color{orange}40$ 分，超出空间限制，这只能是重复入队。

一看 $1\le K\le 10$，最多只有 $10$个机关。
那还不把所有状态都存下来，加上“记忆化”？

```
#include<bits/stdc++.h>
using namespace std;
const int szl=35;
int n,m;
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
struct node{
	int x,y;
	long long step;
	bitset<955> bit;
};
struct Danger{
	int x,y;
};
vector<Danger> vv[szl][szl];
bool mp[szl][szl];
bitset<955> bt[szl][szl][50],bit;
int cnt[szl][szl];
queue<node> que;
int bex,bey,edx,edy;
void init(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char mpp;cin>>mpp;
			if(mpp!='#'){
				bit[(i-1)*m+j]=1;
			}
			if(mpp=='S')
				bex=i,bey=j;
			else if(mpp=='T')
				edx=i,edy=j;
		}
	}
	int k;cin>>k;
	for(int i=1;i<=k;i++){
		int r,c,R,C;scanf("%d%d%d%d",&r,&c,&R,&C);
		vv[r][c].push_back((Danger){R,C});
	}
	return;
}
bool check_err(node f){
	if(f.x<1||f.y<1||f.x>n||f.y>m)return true;
	if(!f.bit[(f.x-1)*m+f.y])return true;
	for(int i=1;i<=cnt[f.x][f.y];i++)
		if(f.bit==bt[f.x][f.y][i])
			return true;//之前被更新过，这次就一定不是最有，不再入队
	bt[f.x][f.y][++cnt[f.x][f.y]]=f.bit;//否则标记
	return false;
}
void deal_danger(node &f){
	for(int i=0;i<vv[f.x][f.y].size();i++){
		int x=vv[f.x][f.y][i].x,y=vv[f.x][f.y][i].y;
		f.bit[(x-1)*m+y]=~f.bit[(x-1)*m+y];//另一种取反方式
	}
	return;
}
long long bfs(){
	node f={bex,bey,0,bit};
	que.push(f);
	while(!que.empty()){
		node f=que.front();que.pop();
		if(f.x==edx&&f.y==edy)return f.step;
		for(int i=0;i<4;i++){
			node nf={f.x+dx[i],f.y+dy[i],f.step+1,f.bit};
			if(check_err(nf))continue;
//			bt[nf.x][nf.y]=f.bit;
			if(nf.x==edx&&nf.y==edy)return f.step+1;
			deal_danger(nf);
			que.push(nf);
		}
	}
}
int main(){
	init();
	cout<<bfs();
	return 0;
}
```
# END

---

## 作者：KidA (赞：2)

没有机关时，直接 bfs 即可。

考虑到直接处理机关并不好做且 $0 \le k \le 10$，于是将机关的开关状态压缩为一个二进制数 $st$，这样 bfs 的每个点就包含 $(x,y,step,st)$ 这 $4$ 个信息（$x,y$ 为坐标，$step$ 为步数）。

在 bfs 中，若邻接点为机关，则改变其对应点的二进制位；若为被机关影响的点，则若其对应的机关是开的，则改变其状态（能走或不能走），同时该点本身是 `#` 也会改变其状态。这些都用异或运算解决即可。

注意第一次遇到终点就得停下，不然继续走会增加额外的步数。[实现](https://www.luogu.com.cn/paste/7xuiq03w)。

---

## 作者：harmis_yz (赞：1)

## 分析

考虑记忆化搜索。

$1 \le k \le 10$，可以记录每个机关被打开的情况。用棋盘最短路，如果枚举走到的这个点在当前机关的状态中是障碍，则不能走；否则更新走到这个点会触发的机关的状态即可。注意，两次经过同一个机关时等价于不经过该机关。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define PII pair<int,int>
#define x first
#define y second

const int N=35,M=15;
int n,m,k;
PII s,t;
char c[N][N];
struct node{
	int r,c,R,C;
}a[N];
struct st{
	int x,y,ste,stk;
};
int dx[5]={0,0,1,-1},dy[5]={1,-1,0,0};
bool vis[N][N][1<<M];

il void bfs(){
	queue<st> qu;
	qu.push({s.x,s.y,0,0});
	while(!qu.empty()){
		st now=qu.front();qu.pop();
		if(vis[now.x][now.y][now.stk]) continue;
		vis[now.x][now.y][now.stk]=1;
		if(now.x==t.x&&now.y==t.y){cout<<now.ste;return ;}
		for(re int i=0;i<4;++i){
			int nowx=now.x+dx[i],nowy=now.y+dy[i];
			if(nowx<1||nowy<1||nowx>n||nowy>m) continue;
			int stk=(c[nowx][nowy]=='#');
			for(re int j=1;j<=k;++j)
				if(a[j].R==nowx&&a[j].C==nowy&&((now.stk>>(j-1))&1)) stk^=1;
			if(stk) continue;
			stk=now.stk;
			for(re int j=1;j<=k;++j)
				if(a[j].r==nowx&&a[j].c==nowy) stk^=(1<<(j-1));
			qu.push({nowx,nowy,now.ste+1,stk});
		}
	}
	return ;
}

il void solve(){
	cin>>n>>m;
	for(re int i=1;i<=n;++i)
	for(re int j=1;j<=m;++j){
		cin>>c[i][j];
		if(c[i][j]=='S') s={i,j};
		if(c[i][j]=='T') t={i,j};
	}
	cin>>k;
	for(re int i=1;i<=k;++i) cin>>a[i].r>>a[i].c>>a[i].R>>a[i].C;
	bfs();
	return ;
}

signed main(){
	solve();
	return 0;
}

```


---

## 作者：him的自我修养 (赞：1)

# 题意
就是一个正常的迷宫问题，但是——有 $k$ 个机关，每个机关是在走上 $c_i,r_i$ 时触发，把 $C_i,R_i$ 翻转，问最少走几次。

# 解法
看这个数据范围 $k\le10$，所以想到了可以直接把所有机关触发状态写进一个数组里，总共 $1024$ 种，不会爆空间。

让后就是一个正常的广搜了，但在队列中，还有一个数值 $val$，在二进制下 $1$ 代表着我触发了这个机关，反之就是没触发。让后在每次走到另外一格的时候看一看会不会触发机关，让后更新就行了。具体代码就是 `val^=(1<<(j-1))`。

让后就是一些细节问题了，比如说在判断是否走过的时候要在**更新完成后**在进行判断，还有就是位运算一定要加括号！

# code
```
#include <bits/stdc++.h>
using namespace std;
int n,m,k;
struct node{
	int r,c,R,C;
}s[15];
struct point{
	int x,y,dis,val;
};
queue<point> q; 
char c[35][35][1030];
int sx,sy,ex,ey;
int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
bool vis[35][35][1035];
int bfs(){
	q.push((point){sx,sy,0,0});vis[sx][sy][0]=1;
	while(!q.empty()){
		point t=q.front();q.pop();
		if(t.x==ex && t.y==ey){
			return t.dis;
		}
		for(int i=0;i<4;i++){
			int nx=t.x+dx[i],ny=t.y+dy[i];
			if(nx<1 || ny<1 || nx>n || ny>m) continue;
			if(c[nx][ny][t.val]=='#') continue;
			int val=t.val;
			for(int j=1;j<=k;j++){
				if(s[j].r==nx && s[j].c==ny){
					val^=(1<<(j-1));
				}
			}
			if(vis[nx][ny][val]) continue;
			vis[nx][ny][val]=1;
			q.push((point){nx,ny,t.dis+1,val});		
		}
	}
} 
int main(){
	cin >>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin >>c[i][j][0];
			if(c[i][j][0]=='S'){
				sx=i,sy=j;
			}
			if(c[i][j][0]=='T'){
				ex=i,ey=j;
			}
		}
	}
	cin >>k;
	for(int i=1;i<=k;i++){
		cin >>s[i].r>>s[i].c>>s[i].R>>s[i].C;
	}
	for(int i=1;i<(1<<k);i++){
		for(int _i=1;_i<=n;_i++){
			for(int _j=1;_j<=m;_j++){
				c[_i][_j][i]=c[_i][_j][0];
			}
		}
		for(int j=1;j<=k;j++){
			if(((1<<(j-1))&i)==0) continue;
			c[s[j].R][s[j].C][i]=(c[s[j].R][s[j].C][i]=='.'?'#':'.');
		}
	}
	cout <<bfs();
	return 0;
}
```



---

## 作者：Weekoder (赞：1)

### 思路

求最短距离，考虑 BFS。有机关，但是最多只有十个，所以可以考虑直接暴力状压 BFS。对于某一个点，如果能触发机关，就改变对应状态，如果是一个能被触发的机关，就将答案异或上触发此点的机关数量个 $1$。那么最后如果答案是 $1$，就代表这个点能通过，入队即可。

代码展示：


```cpp
#include <bits/stdc++.h>

#define int long long

#define debug(x) (cout << #x  << " " << x << "\n")

using namespace std;

const int N = 35;

const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};

struct node {
    int x, y, step, s;
};

int n, m, k, sx, sy, ex, ey, r[N], c[N], R[N], C[N];

bool vis[N][N][1 << 11];

char a[N][N];

int bfs() {
    queue<node> q;
    q.push((node){sx, sy, 0, 0});
    memset(vis, 0, sizeof vis);
    vis[sx][sy][0] = 1;
    while (!q.empty()) {
        node cur = q.front(); q.pop();
        if (cur.x == ex && cur.y == ey) return cur.step;
        for (int i = 0; i < 4; i++) {
            int nx = cur.x + dx[i], ny = cur.y + dy[i];
            if (nx >= 1 && nx <= n && ny >= 1 && ny <= m) {
                int tmp = a[nx][ny] != '#', s = cur.s;
                for (int j = 1; j <= k; j++) {
                    if (nx == r[j] && ny == c[j]) s ^= (1 << (j - 1));
                    if (nx == R[j] && ny == C[j] && (cur.s >> (j - 1) & 1)) tmp ^= 1; 
                }
                if (tmp && !vis[nx][ny][s]) {
                    vis[nx][ny][s] = 1;
                    q.push((node){nx, ny, cur.step + 1, s});
                }
            }
        }
    }
    return -1;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j], a[i][j] == 'S' && (sx = i, sy = j), a[i][j] == 'T' && (ex = i, ey = j);  
    cin >> k;
    for (int i = 1; i <= k; i++) cin >> r[i] >> c[i] >> R[i] >> C[i];
    cout << bfs();
    return 0;
}
```

---

## 作者：lfxxx_ (赞：1)

- 我们给普通广搜加上一个状态 $state$，表示机关的状态。

- 在判断重复的时候也要 $state$ 相等才算重复。

- 在判断这个地方是否可以走的时候就要用这个 $state$ 判断这个点是否被翻转。

- 然后就能愉快的 AC 了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=31,M=10;
int dx[]={1,0,-1,0},dy[]={0,1,0,-1};
int n,m,K;
char s[N][N];
bool vis[N][N][1<<M];
struct _{
	int tx,ty,ux,uy;
}a[M];
struct node{
	int x,y,state,stp;
	node(int _x,int _y,int __s,int _s){x=_x,y=_y,state=__s,stp=_s;}
};
void update(int x,int y,int &state)
{
	for(int i=0;i<K;++i)
		if(a[i].tx==x&&a[i].ty==y)
			state^=(1<<i);
}
bool check(int x,int y,int state)
{
	int res=(s[x][y]!='#');
	for(int i=0;i<K;++i)
		if(a[i].ux==x&&a[i].uy==y&&(state&(1<<i)))
			res^=1;
	return res;
}
string bin(int x)
{
	string res;
	while(x)
	{
		res+=(char)((x&1)+48);
		x>>=1;
	}
	while(res.size()<K)
		res+='0';
	return res;
}
signed main()
{
	int sx=-1,sy=-1;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
		{
			cin>>s[i][j];
			if(s[i][j]=='S')
				sx=i,sy=j;
		}
	cin>>K;
	for(int i=0;i<K;++i)
		cin>>a[i].tx>>a[i].ty>>a[i].ux>>a[i].uy;
	queue<node>q;
	int tmp=0;
	update(sx,sy,tmp);
	q.emplace(sx,sy,tmp,0);
	vis[sx][sy][tmp]=1;
	while(!q.empty())
	{
		int x=q.front().x,y=q.front().y,state=q.front().state,stp=q.front().stp;
		q.pop();
		update(x,y,state);
		if(s[x][y]=='T')
		{
			cout<<stp;
			return 0;
		}
		for(int i=0;i<4;++i)
		{
			int tx=x+dx[i],ty=y+dy[i];
			if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&check(tx,ty,state)&&!vis[tx][ty][state])
			{
				vis[tx][ty][state]=1;
				q.emplace(tx,ty,state,stp+1);
			}
		}
	}
	cout<<"I AK IOI";
}
```

---

## 作者：THM200000000 (赞：0)

# 题解：[P3869 宝藏](https://www.luogu.com.cn/problem/P3869)
## 题意
给个地图，有机关（可以**重复**踩），碰到会改变地图上的单个格子，问从起点到终点的最短路径。
## 思路
~~看到最短步数直接**广搜。**~~

由于地上有机关，那么搜的时候未免要将机关考虑上，此时可以记录机关的开关，本来想用 `bool` 数组的，但由于需要将机关的状态一并计入 $vis$ 数组，所以考虑**状压**。

此时可以定义一个变量 $k$，$k$ 的二进制的第 $i$ 位（从右往左）表示第 $i$ 个机关是否被打开。同样地，可以用一个 $vis(i,j,k)$ 来**防止重复搜索**。知道这点之后，我们可以定义一个状态来入队：$\left\{x,y,k\right\}$，但由于要在此基础上输出**最小步数**，所以还应加入一个 $stp$ 来记录起点到当前位置（以及机关的状态）的步数：$\left \{x,y,stp,k\right \}$。

这样就可以~~愉快地~~写代码啦。
## 代码
```cpp
#include<bits/stdc++.h>
#define max(x, y) (x > y? x : y)
#define min(x, y) (x < y? x : y)
#define lowbit(x) (x & -x)
#define IAK return
#define IOI 0
using namespace std;
int n, m, k_, Sx, Sy;
struct jiguan {
	int a, b;
	int x, y;
} jg[11];
struct members {
	int x, y, stp, k;
} now;
char sq[32][32];
int dx[4] {1, -1, 0, 0}, dy[4] {0, 0, 1, -1}, bx, by, bk, flag;
bool vis[32][32][1050];
queue<members> q;
void BFS() { //广搜（废话）
	q.push((members) {
		Sx, Sy, 0, 0
	});
	vis[Sx][Sy][0] = true;
	while(!q.empty()) {
		now = q.front();
		q.pop();
		if(sq[now.x][now.y] == 'T') {
			printf("%d\n", now.stp);
			return ;
		}
		for(int i = 0; i < 4; i++) {
			bx = now.x + dx[i];
			by = now.y + dy[i];
			if(bx < 1 || bx > n || by < 1 || by > m)
				continue;
			flag, bk = now.k;
			if(sq[bx][by] == '#') flag = 0;
			else flag = 1;
			for(int j = 1; j <= k_; j++) {
				if(bx == jg[j].x && by == jg[j].y && ((now.k >> j - 1) & 1))
					flag ^= 1;
				if(bx == jg[j].a && by == jg[j].b)
					bk ^= (1 << j - 1);
			}
			if(flag && !vis[bx][by][bk]) {
				vis[bx][by][bk] = true;
				q.push((members) {
					bx, by, now.stp + 1, bk
				});
			}
		}
	}
}
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			cin >> sq[i][j];
			if(sq[i][j] == 'S')
				Sx = i, Sy = j;
		}
	scanf("%d", &k_);
	for(int i = 1; i <= k_; i++)
		scanf("%d%d%d%d", &jg[i].a, &jg[i].b, &jg[i].x, &jg[i].y);
	BFS();
	IAK IOI; //完美收场
}
```
## 结果
结果：[$\textrm{\huge完美无瑕}$\
![](https://cdn.luogu.com.cn/upload/image_hosting/nbxfi4cf.png)](https://www.luogu.com.cn/record/176122226)

---

## 作者：Z7y0h0_1 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3869)
## 前言
之前在书上看到一道题，叫[拯救大兵瑞恩](https://www.acwing.com/solution/content/14900/)，里面也有机关，与这道题非常类似。看到那道题用的是状态压缩加最短路的做法，于是我心血来潮，也试了试，可是结果很不理想。因此换成同样时间复杂度的记忆化广度优先搜索来实现。

## 基础知识
### 状态压缩
状态压缩是将复杂的状态压缩成一个整数的方法，可以节省空间。

常用的压缩方法有：

1. 二进制压缩

	如果整体状态由一系列“是”与“否”的状态组成，则可以把整个状态看成一个二进制数。如题目中机关的状态，若 $1$,$3$,$5$ 号机关打开，$2$,$4$,$6$ 号机关关闭，则整个状态可表示为 $010101$，并转化为整数 $21$。

2. 其他进制的压缩

	如果一个状态由 $k$ 个状态组成，并且第 $i$ 个状态有 $m_{i-1}$ 种变化，取第 $t_{i-1}$ 个状态，则总状态可压缩为 
	$$
	t_{0}\cdot m_{1}\cdot m_{2}\cdot...\cdot m_{k-1}+t_{1}\cdot m_{2}\cdot m_{3}\cdot...\cdot m_{k-1}+...+t_{k-2}\cdot m_{k-1}+t_{k-1}$$
	这相当于一个“进制混杂的数”，其中第 $i$ 位表示第 $i$ 个状态，为 $m_{i-1}$ 进制。

### 记忆化广搜

在普通广搜的基础上，增加一个布尔型记忆化数组，记录已经遍历过的状态，防止重复遍历，这种带有防重复的广搜叫记忆化广搜。由于每个状态只遍历一次，所以复杂度与状态的数量同级，效率较高。

在本题的搜索中，将会运用这一技巧。

## 实现方法
用一个整数来表示所有的状态：设 $t$ 为所有机关状态压缩成的二进制数，$x$ 和 $y$ 分别为小明所在的行数和列数，则所有的三个状态可按照类似二进制的方法压缩成 $t\cdot r\cdot c+x\cdot c+y$。

开一个队列，存储上述所有状态，用记忆化搜索的方法更新状态。具体可参考如下思路：

1. 对于每一个位置，先判断这个位置是否可通行。如果此位置不受机关影响，就判断它是否为 "#" ；若受影响，还需计算被影响的次数。
2. 枚举上下左右 4 个方向，对那个位置做类似的判断，并且还要注意它有可能是机关的情况。
3. 若两个条件都满足，则将此状态入队，扩展 4 个方向的状态。

### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6;
struct node{                                               //结构体存储当前状态和步数 
	int cul;int time;
};
int r,c,k,st,ed,g[10][4];char m[30][30];
bool vis[maxn],ised[maxn],g1[1000],g2[1000];
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};                     //四个方向的位移常量 
queue<node> q;                                             //bfs队列数据结构 
bool valid(int x,int y){
	return -1<x&&x<r&&-1<y&&y<c;                           //是否越界 
}
int main(){
	memset(ised,false,sizeof(ised));
	memset(g1,false,sizeof(g1));
	memset(g2,false,sizeof(g2));
	memset(vis,false,sizeof(vis));
	cin>>r>>c;                                             //读入数据 
	for(int i=0;i<r;i++){
		for(int j=0;j<c;j++){
			cin>>m[i][j];
			if(m[i][j]=='S') st=i*c+j; 
			if(m[i][j]=='T') ed=i*c+j;
		}
	}
	cin>>k;
	for(int i=0;i<k;i++){
		cin>>g[i][0]>>g[i][1]>>g[i][2]>>g[i][3];
		for(int j=0;j<4;j++) g[i][j]--;
		g1[g[i][0]*c+g[i][1]]=true;                        //标记机关，稍后进行特殊处理 
		g2[g[i][2]*c+g[i][3]]=true;
	}
	for(int i=0;i<(1<<k);i++) ised[r*c*i+ed]=true;
	q.push((node){st,0});
	while(q.size()){                                       //bfs框架 
		node f=q.front();
		int nt=f.cul/(r*c),nr=f.cul%(r*c)/c,nc=f.cul%c;
		bool bj=true;
		if(ised[f.cul]){                                   //已到达终点 
			cout<<f.time<<endl;
			return 0;
		}
		int cnt=(m[nr][nc]=='#'? 0:1);                     //若被机关影响，计算被影响的次数 
		for(int j=0;j<k;j++){
			if(g[j][2]==nr&&g[j][3]==nc){
				cnt+=((nt>>j)&1)? 1:0;
			}
		}
		if(!(cnt%2)) bj=false;
		for(int i=0;i<4;i++){                              //枚举4个方向 
			int gt=nt;
			int ns=(nr+dx[i])*c+(nc+dy[i]);
			if(!valid(nr+dx[i],nc+dy[i])) continue;
			if(g1[ns]){                                    //是机关 
				for(int j=0;j<k;j++){
					if((g[j][0]==nr+dx[i])&&(g[j][1]==nc+dy[i])){
						gt+=(((nt>>j)&1)? (-(1<<j)):(1<<j));
					}
				}
				if(bj&&!vis[gt*r*c+ns]){
					q.push((node){gt*r*c+ns,f.time+1});
					vis[gt*r*c+ns]=true;
				}
			}
			else if(g2[ns]){                               //受机关影响 
				int cnt=(m[nr+dx[i]][nc+dy[i]]=='#'? 0:1);
				for(int j=0;j<k;j++){
					if(g[j][2]==nr+dx[i]&&g[j][3]==nc+dy[i]){
						cnt+=((nt>>j)&1)? 1:0;
					}
				}
				if(!(cnt%2)) continue;
				if(bj&&!vis[nt*r*c+ns]){
					q.push((node){nt*r*c+ns,f.time+1});
					vis[nt*r*c+ns]=true;
				}
			}
			else{                                          //普通方格 
				if(m[nr+dx[i]][nc+dy[i]]=='#') continue;
				if(bj&&!vis[nt*r*c+ns]){
					q.push((node){nt*r*c+ns,f.time+1});
					vis[nt*r*c+ns]=true;
				}
			}
		}
		q.pop();
	}
	return 0;
}
```
谢谢支持！

---


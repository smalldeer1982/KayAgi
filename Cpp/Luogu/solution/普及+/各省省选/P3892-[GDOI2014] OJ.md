# [GDOI2014] OJ

## 题目描述

小 M 是一个勤奋的 ACMer，他利用课余时间刷了很多题目。但他是个很健忘的孩子，经常会忘记自己刷过一些什么题目，所以他想写一个 OJ 来管理自己做过的题目。

经过一个星期的努力，小 M 的 OJ 基本成型，只是还差一个 Contest 的模块没有实现。小 M 觉得这个模块很难实现，所以他希望找你来帮忙。

小 M 告诉你，一个 OJ 的基础元素包括：

1. 题目，可以用 pid 唯一标识，pid 为正整数；
2. 比赛，可以用 cid 唯一标识，cid 为正整数；
3. 用户，可以用 uid 唯一标识，uid 为正整数；
4. 提交状态，可以由 sid 唯一标识，sid 为正整数。

一个提交状态是由 sid、cid、pid、uid 和 result 组成的，分别表示本条状态的提交 ID，所属比赛 ID，题目 ID，用户 ID 以及评测结果。

简单起见，这里的 result 只有 AC、UNAC 和 WAIT 三种状态，分别表示通过、不通过和等待评测。

同时小 M 提出一个比赛模块需要实现以下请求：

1. `createContest cid t pid_1 pid_2 … pid_t`

表示要创建一个比赛，cid 是一个正整数，是这场比赛的唯一标识。

$t$ 表示这场比赛有 $t$（($1\le t\le1000$)）道题目，接下来 $t$ 个不同的整数，表示这场比赛的题目编号。

2. `submission sid cid pid uid result`

该条状态的 sid 要么之前没出现过，要么以前出现过，但是被 rejudge 了。

result 为 AC 或者 UNAC。

3. `getRank cid uid`

在一场比赛中，所有有提交的用户都应该算在排名内（包括被 rejudge 的提交），用户的排名按照通过的题目数从大到小排序，如果题目数相同，则按随机顺序排序。

该指令需要统计用户 uid 在 cid 这场比赛中的通过目数，最高排名以及最低排名。

值得注意的是，用户 uid 在 cid 这场比赛中同一道题目的多个通过记录只算一次。

输出格式为：`uid solved highest lowest`。

分别代表用户 ID，通过题目数量，最高排名以及最低排名，其中 $\mathit{highest}\le\mathit{lowest}$。

4. `rejudge sid`

重测以 sid 标识的提交记录，即将该记录的 result 改成 WAIT。


## 说明/提示

对于 $20\%$ 的数据，$1\le\mathit{pcnt},\mathit{ucnt},m\le100$；

对于 $50\%$ 的数据，$1\le\mathit{pcnt},\mathit{ucnt}\le2000,1\le m\le50000$；

对于 $100\%$ 的数据，$1\le\mathit{pcnt},\mathit{ucnt}\le5000,1\le m\le3\times10^5,1\le\mathit{cid}\le50$。


## 样例 #1

### 输入

```
7 5 17
createContest 1 5 1001 1004 1002 1005 1006
submission 1 1 1001 1 AC
submission 2 1 1001 1 AC
submission 3 1 1001 2 UNAC
submission 4 1 1003 3 UNAC
getRank 1 1
getRank 1 2
getRank 1 3
rejudge 3
submission 3 1 1001 2 AC
getRank 1 2
submission 5 1 1006 2 AC
getRank 1 1
submission 6 1 1006 2 UNAC
getRank 1 2
rejudge 5
getRank 1 2
```

### 输出

```
1 1 1 1
2 0 2 3
3 0 2 3
2 1 1 2
1 1 2 2
2 2 1 1
2 1 1 2
```

# 题解

## 作者：Thunder_S (赞：9)

## Solution

题目很长，简单来说就是维护一个比赛系统。

先给出要维护的东西：

每场比赛每个用户对应的 AC 数量，每场比赛对应 AC 数量的人数，每个提交对应的编号、用户、比赛、和结果。

下面分操作讲述。

---

新建比赛。

其实新建比赛是没有用的，因为之后其他的操作中都会给出对应的比赛编号和题目编号（或者提交编号),所以并不需要记录比赛中有哪些题目。

---

提交。

对于一个 UNAC 的提交，记录每场比赛有哪些人是交过题了，如果当前这个提交对应的用户之前交过题，那么这个提交是不用管的，否则需要将 AC 数量为 0 的人数 +1（在对应的比赛中)。

如果是 AC 的提交，则将对应用户在对应比赛中的 AC 数量 +1。注意我们要先判断这个人是否曾经 AC 过这道题目，但如果直接开数组会爆空间，所以要用链式前向星，将对于这个用户和这道题对应比赛的 AC 数量打在连向对应比赛的边上（这里可能有点难懂，可以结合下面的代码理解）。

---

查询排名。

相当于给出一个过题数，在对应比赛中查找有多少人的过题数大于，多少人过题数等于。这里可以用数据结构或者前缀/后缀和。

---

重测。

跟提交差不多，如果原本的状态是 UNAC 的话，不需要管。

如果是 AC，则只需要将对应用户的 AC 数量 -1。

## Code

```cpp
#include<cstdio>
#define N 5005
#define M 350005
using namespace std;
struct sub
{
    int pid,cid,uid;
    bool res;
}sub[M];
struct contest
{
    int num[N],solve[N];
}con[55];
struct node
{
    int to,next;
}a[M];
int n,m,q,id,sid,cid,pid,uid,tot,cnt[M],head[N][N];
bool b[55][N];
char ch[20];
int read()
{
    int res=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch-'0'),ch=getchar();
    return res;
}
void add(int uid,int pid,int cid)
{
    a[++tot].to=cid;
    a[tot].next=head[uid][pid];
    head[uid][pid]=tot;
}
int find(int uid,int pid,int cid)
{
    for (int i=head[uid][pid];i;i=a[i].next)
    {
        int v=a[i].to;
        if (v==cid) return i;
    }
    return 0;
}
int main()
{
    n=read();m=read();q=read();
    while (q--)
    {
        scanf("%s",ch);
        if (ch[0]=='c')
        {
            int num,x;
            cid=read();num=read();
            for (int i=1;i<=num;++i)
                x=read();
        }
        else if (ch[0]=='s')
        {
            int sid,cid,pid,uid;
            sid=read();cid=read();pid=read();uid=read();scanf("%s",ch);
            sub[sid].cid=cid;sub[sid].pid=pid;sub[sid].uid=uid;sub[sid].res=(ch[0]=='A');
            if (!b[cid][uid])
            {
                b[cid][uid]=true;
                con[cid].num[0]++;
            }
            if (ch[0]=='A')
            {
                id=find(uid,pid,cid);
                if (!id) add(uid,pid,cid),id=tot;
                ++cnt[id];
                if (cnt[id]==1) con[cid].num[++con[cid].solve[uid]]++;
            }
        }
        else if (ch[0]=='g')
        {
            cid=read();uid=read();
            int pnum=con[cid].solve[uid];
            printf("%d %d %d %d\n",uid,pnum,con[cid].num[pnum+1]+1,con[cid].num[pnum]);
        }
        else if (ch[0]=='r')
        {
            sid=read();
            uid=sub[sid].uid;cid=sub[sid].cid;pid=sub[sid].pid;
            if (sub[sid].res)
            {
                int id=find(uid,pid,cid);
                --cnt[id];
                if (cnt[id]==0) con[cid].num[con[cid].solve[uid]--]--;
            }
        }
    }
    return 0;
}
```

---

## 作者：Wang1006 (赞：2)

# P3892 [GDOI2014] OJ 题解
## 0.1. 开始前：说句闲话

**暴力能过。**

是的，请不要怀疑，暴力能过。复杂度 $O(m\times ucnt)$ 的暴力轻松 1.77 秒爆草过去。

后面附上了暴力代码，有需要的到下面自取。

## 0.2. 开始前：再说句闲话

煮啵一开始写的分块，内外块按照不同关键字排序。码了三百多行，调了一下午。本以为这个做法很优秀，结果交上去接近一秒。算了时间复杂度后发现，这个做法非常劣。

## 1.1. 题意
模拟一个 OJ 的比赛模块，可以新建比赛，可以提交，可以查排名（这里排名说要求某用户最好、最坏排名，意思是分别将同分用户列于该用户下面、上面可获得的排名），可以重测。

## 1.2. 思路
观察发现 $m\le3\times10^5$。~~暴力是行不通了。~~

如果用户数组的得分具有单调性，我们就可以二分找到该用户，并且排名也可以二分求得。

那么问题来了：怎么维持该数组的单调性呢？

如果使用插入排序，每新增一个用户就类似于冒泡一样往上一个一个比较，复杂度与暴力无异。

如果二分找到一个位置将其安排进去，似乎可行，但仔细想想发现：数组与链表不同，不能快速插入一个元素。还是需要很大的时间代价。

但是我们发现一个有趣的点：加入时，用户的通过题目数量一定为 $0$ 或 $1$。执行提交操作时，用户的过题数量的变化量也是 $1$。也就是说，他在单调数组中的位置只会移动到与他同分的人的首或尾。

这么说，**二分后只要交换此人和与此人同分的排名最靠前的那个人就可以维护数组单调性！**

这么说可能很难懂，画个图：
![图片](https://cdn.luogu.com.cn/upload/image_hosting/4r3e8kin.png)

AC 数量变化时，只需要二分目标位置，再执行交换操作即可。

这道题就解决了。时间复杂度 $O(m \log_2(ucnt) )$。

煮啵为了防止爆空间，额外使用了一个 `map` 来存题目，导致时间开销增大，复杂度大于上面的理论值，巨佬们实现的话可以免掉。

## 1.3. 代码
### 1.3.1. 正解：100pts
```cpp
#include<iostream>
#include<vector>
#include<utility>
#include<map>
using namespace std;

#define swap Q

template<typename T>inline void swap(T&a,T&b){
	T t=a;a=b;b=t;
}

int pcnt,ucnt,m;

struct Contest{//一个 struct 就是一个世界，下面的函数就是一个世界的天道，数组便是所有生灵 
	vector<int>u;//修士 
	int ac[5010],from[5010];bool vis[5010];//快速查询修士修为、位置、是否出现过 
	map<int,int>acnum[5010];//直接开空间会爆的。用 map 存一下。 
	inline void swapu(int uid1,int uid2){//交换两人天榜排名 
		swap(u[from[uid1]],u[from[uid2]]);
		swap(from[uid1],from[uid2]);
	}
	inline void addac(int uid,int acnum){
		if(vis[uid]==0){//没有在本场比赛中修炼过
			u.push_back(uid);
			from[uid]=u.size()-1;
			vis[uid]=1;
		}
		if(acnum==1){//经过修炼，修为升高 
			int l=0,r=u.size()-1,mid;
			while(l<=r){//找到第一个修为和他之前相等的修士 
				mid=(l+r)>>1;
				if(ac[u[mid]]<=ac[uid]){
					r=mid-1;
				}
				else{
					l=mid+1;
				}
			}
			swapu(u[l],uid);
			ac[uid]++;
		}
		else if(acnum==-1){//颓废了500年，修为不进则退。 
			int l=from[uid]+1,r=u.size()-1,mid;
			while(l<=r){//找到最后一个修为和他之前相等的修士
				mid=(l+r)>>1;
				if(ac[u[mid]]>=ac[uid]){
					l=mid+1;
				}
				else{
					r=mid-1;
				}
			}
			swapu(u[r],uid);
			ac[uid]--;
		}
	}
	inline int getrank1(int uid){
		int fret;
		int l=0,r=from[uid]-1,mid;
		while(l<=r){//找到最后一个修为比他高的修士
			mid=(l+r)>>1;
			if(ac[u[mid]]>ac[uid]){
				l=mid+1;
			}
			else{
				r=mid-1;
			}
		}
		fret=r+2;//下标从0开始，r 的修为正好比他高，需要加2才是排名
		return fret;
	}
	inline int getrank2(int uid){
		int l=0,r=u.size()-1,mid,sret;
		while(l<=r){//找到第一个修为不高于他的修士 
			mid=(l+r)>>1;
			if(ac[u[mid]]<ac[uid]){
				r=mid-1;
			}
			else{
				l=mid+1;
			}
		}
		sret=r+1;//从 r+2-1 化简而来。减一是因为他算上了自己。需要把自己减掉。 
		return sret;
	}
}c[60];
bool ac[300010];
int owner[300010],cont[300010],prob[300010];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>pcnt>>ucnt>>m;
	string opt,rst;
	int cid,t,sid,pid,uid;
	while(m--){
		cin>>opt;
		if(opt[0]=='c'){
			cin>>cid>>t;
			for(int i=1,x;i<=t;++i){
				cin>>x;
			}
		}
		else if(opt[0]=='s'){
			cin>>sid>>cid>>pid>>uid>>rst;
			if(!c[cid].acnum[uid][pid]&&rst[0]=='A'){
				c[cid].addac(uid,1);
			}
			else if(!c[cid].vis[uid]){
				c[cid].addac(uid,0);//可能会查询这个人，必须加入，不加也得意思意思。 
			}
			ac[sid]=(rst[0]=='A');owner[sid]=uid;cont[sid]=cid;prob[sid]=pid;
			c[cid].acnum[uid][pid]+=ac[sid]?1:0;
		}
		else if(opt[0]=='g'){
			cin>>cid>>uid;
			cout<<uid<<' '<<c[cid].ac[uid]<<' '<<c[cid].getrank1(uid)<<' '<<c[cid].getrank2(uid)<<"\n";
		}
		else{
			cin>>sid;
			if(c[cont[sid]].acnum[owner[sid]][prob[sid]]==1&&ac[sid]){
				c[cont[sid]].addac(owner[sid],-1);
			}
			if(c[cont[sid]].acnum[owner[sid]][prob[sid]]>0&&ac[sid]){
				c[cont[sid]].acnum[owner[sid]][prob[sid]]--;
			}
			ac[sid]=0;
		}
	}
}
```
### 1.3.2. 暴力：100pts
```cpp
#include<iostream>
#include<vector>
#include<utility>
#include<map>
using namespace std;

int pcnt,ucnt,m;

struct Contest{
	int cid;
	struct User{
		int uid,ac;
	};
	vector<User>u;
	int ac[5010];bool vis[5010];
	map<int,int>acnum[5010];
	int getpos(int uid){
		for(int i=0;i<u.size();++i){
			if(u[i].uid==uid){
				return i;
			}
		}
	}
	void addac(int uid,int acnum){
		if(vis[uid]==0){
			u.push_back({uid,acnum});
			vis[uid]=1;
		}
		else{
			int add=getpos(uid);
			u[add].ac+=acnum;
		}
		ac[uid]+=acnum;
	}
	pair<int,pair<int,int> >getrank(int uid){
		int fret=0,sret=0; 
		for(int i=0;i<u.size();++i){
			if(u[i].ac>=ac[uid]){
				sret++;
				if(u[i].ac>ac[uid]){
					fret++;
				}
			}
		}
		fret++;
		return make_pair(ac[uid],make_pair(fret,sret));
	}
}c[60];
bool ac[300010];
int owner[300010],cont[300010],prob[300010];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>pcnt>>ucnt>>m;
	while(m--){
		string opt;
		cin>>opt;
		if(opt=="createContest"){
			int cid,t;
			cin>>cid>>t;
			for(int i=1,x;i<=t;++i){
				cin>>x;
			}
			c[cid].cid=cid;
		}
		else if(opt=="submission"){
			int sid,cid,pid,uid;string rst;
			cin>>sid>>cid>>pid>>uid>>rst;
			if(c[cid].acnum[uid][pid]==0&&rst=="AC"){
				c[cid].addac(uid,1);
			}
			else if(c[cid].vis[uid]==0){
				c[cid].addac(uid,0); 
			}
			ac[sid]=(rst=="AC");owner[sid]=uid;cont[sid]=cid;prob[sid]=pid;
			c[cid].acnum[uid][pid]+=ac[sid]?1:0;
		}
		else if(opt=="getRank"){
			int cid,uid;
			cin>>cid>>uid;
			pair<int,pair<int,int> >tmp=c[cid].getrank(uid);
			cout<<uid<<' '<<tmp.first<<' '<<tmp.second.first<<' '<<tmp.second.second<<"\n";
		}
		else{
			int sid;
			cin>>sid;
			if(c[cont[sid]].acnum[owner[sid]][prob[sid]]==1&&ac[sid]){
				c[cont[sid]].addac(owner[sid],-1);
			}
			if(c[cont[sid]].acnum[owner[sid]][prob[sid]]>0&&ac[sid]){
				c[cont[sid]].acnum[owner[sid]][prob[sid]]--;
			}
			ac[sid]=0;
		}
	}
}
```

## 2. 结尾
这种解法并不是最优的，思路仅供参考，巨佬们可以去学习最优解法，对自己的水平提升比学这种解法来的多、快。

完结！感谢各路巨佬的观看！

---


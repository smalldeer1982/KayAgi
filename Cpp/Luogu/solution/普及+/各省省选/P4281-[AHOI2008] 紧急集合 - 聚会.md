# [AHOI2008] 紧急集合 / 聚会

## 题目描述

欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有 $n$ 个等待点，有 $n-1$ 条道路连接着它们，每一条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一个点到另一个点要花费一个游戏币。

参加游戏的人三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对话机（用于和同组的成员联系）。当集合号吹响后，每组成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在 $n$ 个等待点中确定一个集结点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。

小可可和他的朋友邀请你一起参加这个游戏，由你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？


## 说明/提示

对于 $40\%$ 的数据，$n\leq2\times10^3$，$m\leq2\times 10^3$。

对于 $100\%$ 的数据，$1\leq x,y,z\leq n\leq 5\times10^5$，$1\leq m\leq 5\times 10^5$。

## 样例 #1

### 输入

```
6 4  
1 2  
2 3  
2 4 
4 5
5 6
4 5 6
6 3 1
2 4 4 
6 6 6```

### 输出

```
5 2
2 5
4 1
6 0


```

# 题解

## 作者：高天昊 (赞：130)

# 关于这道题倍增求LCA的做法
## 看到大佬们都用树链剖分做，可我太菜了不会树链剖分......
不过这道题如果用RMQ做的话只有80分
~~好像是因为我不会卡常~~
####  所以步入正题
关于这道题为什么求LCA其他题解已经解释得很明确了，所以我只是概述一下。

题目要求得出三个点走到同一个点所要求的最小花费，经过我们的分析可以得出这个公共的点**较其他点优**的情况可以通过 **求三个点两两之间的LCA**得出，然后我们发现**这三个LCA中有二者重合**即它存在两种情况:最后三者所走到的最优公共点只可能为这二者之一。

然后经过分析可以得到**不重合的公共点才是最优解**，大家可以拿笔模拟一下或者感性理解（**不重合的公共点情况下  一个单独的点移动比另两个点移动距离要多，较另外一种情况花费当然更低**）。

既然是几个人走到一起最小花费，显然是求LCA的同时维护一下深度，~~当然这是倍增所必需的

然后运用差分的思想（假设两点 一点深度为d1,另一点深度为d2,它们LCA深度为d3,这二者之间的距离即为d1+d1-2*d3,只要将这两点推广成三点即可）计算一下最小花费(这个第一篇题解已经非常详细，不会的同学可以去看一看)
```
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
long long ans=0;
int fa[500010][25],lg[500010],deep[500010],t;
struct node
{
	int from;
	int to;
	int next;
}ed[2*500001];
int v[2*500001],tot=0;
void add(int x,int y)
{
	ed[++tot].from=x;
	ed[tot].to=y;
	ed[tot].next=v[x];
	v[x]=tot;
}
int lca(int x,int y)
{
	if(deep[x]<deep[y])			//假设x深度大于y
		swap(x,y);
	while(deep[x]>deep[y])		//x,y调整到同一深度	
	{
		x=fa[x][lg[deep[x]-deep[y]]-1];
	}
	if(x==y)
		return x;
	for(int k=lg[deep[x]];k>=0;k--)		//x,y一起向上跳
	{
	    if(fa[x][k]!=fa[y][k])
	    {
	    	x=fa[x][k];
			y=fa[y][k];
	    }
	}
    return fa[x][0];
	
}
void dfs(int x,int fath)				
{
	deep[x]=deep[fath]+1;					//处理深度
	fa[x][0]=fath;
	for(int i=1;(1<<i)<=deep[x];i++)
	{
		fa[x][i]=fa[fa[x][i-1]][i-1];
	}
	for(int i=v[x];i;i=ed[i].next)
		if(ed[i].to!=fath)
			dfs(ed[i].to,x);
}
int n,m;
int a,b,c;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n-1;i++)
	{
		scanf("%d%d",&a,&b);
		add(a,b);
		add(b,a);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)								//常数优化 
		lg[i]=lg[i-1]+(1<<lg[i-1]==i);
	for(int i=1;i<=m;i++)
	{
		ans=0;
		scanf("%d%d%d",&a,&b,&c);
		int t1=lca(a,b);					//三者分别求LCA
		int t2=lca(a,c);
		int t3=lca(b,c);
		if(t1==t2)
			t=t3;
		else if(t1==t3)
			t=t2;
		else if(t2==t3)
			t=t1;
        //差分
		ans=deep[a]+deep[b]+deep[c]-deep[t1]-deep[t2]-deep[t3];		
		printf("%d %lld\n",t,ans);
	}
	return 0;
} 
```
这份题解可能会有瑕疵，敬请各位大佬斧正。

---

## 作者：command_block (赞：96)

蒟蒻最近刚学会树链剖分，想找些模板题来~~水积分~~练习下。

然后我就找到了这一题。

作为一个无脑数据结构选手，拿到题的第一件事就是看~~题解~~数据范围。

##  N<=500000，M<=500000

GG...莫非还有O(NlogN)的树剖？

树剖常熟小,跑不满！

怀着一种常数的信仰，我们开始解题：

------------

首先看到题中给的图是一棵树~~废话~~

然后看到多次给出树上的三个点

把一个点移动经过一条边需要花费1~~节操~~游戏币

求把三个点移动到一起最少需要多少游戏币

~~易~~发现这个最优的集合点一定在这三个点互相通达的简单路径上

可能有点难理解(能感性理解的请跳过分界线)

比如这图,e是简单路径外一点

简单路径:
```
    .
   /
  /
 /  
.     
```
简单路径外一点e:
```
    .
   /
  /\
 /  \
.     e
```

这三个点想要到达e点，必须先要来到a点。因为这是一棵树，这三个点到e只分别存在一条道路，三个点能到达a，通过a就能分别到达e，如果~~破壁者~~有另一条道路的话，这就不是树了

a:
```
     .
    /
   a
  / \
 /   \
.     e
```

想要到达e点，必须先要来到a点。

很明显，e点比a点劣(既然已经来到a点不如就在a点集合算了)。

这就证明了最优的集合点一定在这三个点互相通达的简单路径上。

------------

上图

a,b,c分别表示三个点

简单路径如图

```
     .
    / \
   /   \
  / \   \
 /   \   c
a     b
```

通过~~大眼观察法~~，很容易发现$LCA(a,c)==LCA(b,c)$

在树上任选三点t1,t2,t3

$LCA(t1,t2),LCA(t1,t3),LCA(t2,t3)$中一定有两个是相等的。

相信大家都能理解，不能理解的手动模拟一下

上面的图拉直，大概长这样

```
   c  
   |
   |
   |
   |
  / \   
 /   \   
a     b
```

很明显了,这三条线段的唯一公共点w就是最优集合地！！！

```
   c  
   |
   |
   |
   |
   w
  / \   
 /   \   
a     b
```

证明的话还是用反证法(同上，能感性理解的请跳过分界线)

设有一点h不在w处，却比w优(暂且让他待在CW边上，其他的情况把图转一转就好了)

```
   c  
   |
   |
   h
   |
   w
  / \   
 /   \   
a     b
```
拿出初一几何的架势来(~~其他的不会，我才新初二~~)！！

$Cost_h=CH+(AW+WH)+(BW+WH)=(CH+WH)+AW+BW+WH=CW+AW+BW+WH$

原先选择w点的花费$Cost_w=CW+AW+BW$

很明显$Cost_h-Cost_w=WH$

而$WH>0$，所以取点h一定比点w劣

------------

看回原图：
```
     .
    / \
   /   \
  / \   \
 /   \   c
a     b
```

w点在这里：
```
      .
     / \
    /   \
   w     \
  / \     \
 /   \     c
a     b
```

很明显，w是$LCA(a,b),LCA(a,c),LCA(b,c)$中深度最大的那一个。

相信大家都能理解(~~真的很明显~~)

然后就可以愉快地套板子了~~哈哈哈哈哈哈~~...

------------

$LCA$：已经写了链剖了，就没倍增什么事了

统计$CW+AW+BW$：链剖中的两点间路径统计

完美，接下来就是~~码码码码农~~

## NO,Stop！！！

这题不带修！

题不带修！

不带修！

带修！

修！

## 根据套路，不带修的树剖都能用倍增解决

这题也是如此

倍增求某个点深度，某两个点的$LCA$,简单的一匹。

.

下面是~~愉快的~~分类讨论时间

设三个点为$t1,t2,t3;$三个点的深度为$d1,d2,d3$。

如果$w=LCA(a,b)$最深

```
      .
     / \
    /   \
   w     \
  / \     \
 /   \     c
a     b
```

答案为$deep(a)-deep(w)+deep(b)-deep(w)+deep(c)-deep(.)+deep(w)-deep(.)$

整理得$deep(a)+deep(b)+deep(c)-deep(w)-deep(.)-deep(.)$

如果$w=LCA(a,c)$最深(我不推那么细了)

```
      .
     / \
    /   \
   w     \
  / \     \
 /   \     b
a     c
```

答案还是为$deep(a)+deep(b)+deep(c)-deep(w)-deep(.)-deep(.)$

如果$w=LCA(c,b)$最深(我不推那么细了)

```
      .
     / \
    /   \
   w     \
  / \     \
 /   \     a
c     b
```

答案依旧为$deep(a)+deep(b)+deep(c)-deep(w)-deep(.)-deep(.)$

综上所述，答案为

$deep(a)+deep(b)+deep(c)-$最**深**$LCA$的深度$-$最**浅**$LCA$的深度$*2$

此题完结

代码：
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<vector>
#include<cctype>
using namespace std;
int n,t1,t2,t3,q,len,d1,d2,d3,u1,u2,u3,
    f[520500][20],t[520500];
vector<int> g[520500];
bool e[520500];
inline int read()
{
  int X=0; char ch=0,w=0;
  while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
  return w?-X:X;
}//快速读入
int getdeep(int num)
{
  int k=18,ans=0;
  while(k>=0){
    while(f[num][k])
     {num=f[num][k];ans+=1<<k;}
    k--;
  }return ans;
}//求某个点的深度
int lca(int x,int y)
{
  int k,dx,dy;
  dx=getdeep(x);dy=getdeep(y);
  if (dx>dy){swap(dx,dy);swap(x,y);}
  k=18;
  while(k>=0){
    while(dy-dx>=(1<<k))
     {y=f[y][k];dy-=1<<k;}
    k--;
  }k=18;
  while(k>=0){
    while(f[x][k]!=f[y][k])
     {x=f[x][k];y=f[y][k];}
    k--;
  }
  if (x!=y)x=f[x][0];
  return x;
}//求某两个点的LCA
void dfs(int num)
{
  e[num]=1;
  for (int i=0;i<g[num].size();i++)
   if (e[g[num][i]])
    f[num][0]=g[num][i];
   else dfs(g[num][i]);
}//化无向为有向
int main()
{
  n=read();q=read();
  for (int i=1;i<n;i++){
    t1=read();t2=read();
    g[t1].push_back(t2);
    g[t2].push_back(t1);
  }dfs(1);
  //--------建图--------
  for (register int j=1;j<=18;j++)
   for (register int i=1;i<=n;i++)
    f[i][j]=f[f[i][j-1]][j-1];
  //--------倍增预处理--------
  for (int i=1;i<=q;i++){
    t1=read();t2=read();t3=read();
    u1=lca(t1,t2);
    u2=lca(t2,t3);
    u3=lca(t1,t3);
    d1=getdeep(u1);
    d2=getdeep(u2);
    d3=getdeep(u3);
    if (d1==d2)
      printf("%d ",u3);
    else if (d3==d2)
      printf("%d ",u1);
    else printf("%d ",u2);
    printf("%d\n",getdeep(t1)+getdeep(t2)+getdeep(t3)
	              -min(d1,min(d2,d3))*2-max(d1,max(d2,d3)));
  }
  return 0;
}
```

代码略丑，各位dalao请见谅

---

## 作者：唔啊唔 (赞：19)

**这是我第一道紫题，心情莫名的激动呢。**

![](https://cdn.luogu.com.cn/upload/pic/55375.png)

这是本题样例的图，由这四个样例很容易使人误以为集结点是两个较深的点的坐标，因此我便~~义无反顾~~的跳进了这个坑，额

这是我手动造的一幅图：

![](https://cdn.luogu.com.cn/upload/pic/55376.png)

如图，若三个小伙伴在6,9,8三个点。

按照我先前的思路，会先取6,9两点，然后使他们集结在1点，
很明显这是错误的，应该集结在3,8的最近公共祖先15点上。

这时我便恍然大悟，集结点应该在三个点的三个最近公共祖先中深度最深的那个点上。

然后，这便是正确思路了，接下来只差完成代码了。

贴上AC代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,s,head[500010],num,t,dep[500010],f[500010][30],xa,xb,x,y,z;
struct Node{
    int to,next;
}a[500000*2+10];
inline void add(int from,int to){	//加边 
    num++;
    a[num].to=to;
    a[num].next=head[from];
    head[from]=num;
}
inline void dfs(int son,int fa){ //LCA模板 
    dep[son]=dep[fa]+1;
    f[son][0]=fa;
    for(register int i=1;i<=t;i++)
        f[son][i]=f[f[son][i-1]][i-1];
    for(register int i=head[son];i;i=a[i].next){
        int k=a[i].to;
        if(k!=fa)dfs(k,son);
    }
}
inline int lca(int x,int y){	//LCA模板 
    if(dep[x]>dep[y])
        swap(x,y);
    for(register int i=t;i>=0;i--){
        if(dep[f[y][i]]>=dep[x]){
            y=f[y][i];
        }
    }
    if(x==y){
        return x;
    }
    for(register int i=t;i>=0;i--){
        if(f[x][i]!=f[y][i]){
            x=f[x][i];
            y=f[y][i];
        }
    }
    return f[x][0];
}
int main(){
    scanf("%d%d",&n,&m);
    t=log2(n);
    for(int i=1;i<=n-1;i++){
        scanf("%d%d",&xa,&xb);
        add(xa,xb);
        add(xb,xa);
    }
    dfs(1,0);
    int q,w,e,zx;
	//q,w:深度最深的那个最近公共祖先的两个点,e:另外一个小伙伴,zx:那个最近公共祖先
    for(register int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        int l1=lca(x,y),l2=lca(x,z),l3=lca(y,z);	//找三个点的三个最近公共祖先 
        if(dep[l1]>=dep[l2]&&dep[l1]>=dep[l3])q=x,w=y,e=z,zx=l1;//找深度最深的那个点 
        else if(dep[l2]>=dep[l1]&&dep[l2]>=dep[l3])q=x,w=z,e=y,zx=l2;
        else if(dep[l3]>=dep[l2]&&dep[l3]>=dep[l1])q=z,w=y,e=x,zx=l3;
        int wdt=lca(q,e);//看图可得除了最深的那个点外，其余两个最近公共祖先会重合 
        //那另外一个小伙伴会在另一个最近公共祖先（wdt）拐弯，剩下的就用深度来减 
		int ans=dep[q]+dep[w]-2*dep[zx]+dep[e]+dep[zx]-2*dep[wdt];
   		printf("%d",zx);
   		cout<<" ";	//蒟蒻不会用printf输空格 
   		printf("%d",ans);
   		puts("");
    }
    return 0;//谢谢观看 
}//绝对原创 
```

做的有点糙，多多包涵！

---

## 作者：fsq0726 (赞：11)

**题意简述**

有一棵$n$个节点的树$,$和$q$组询问。

有三个人分别在点$x,y,z$现在希望你找到一个节点，使得三个人到这个点的距离和最小。
 **** 

**解题思路**

这很显然是一道$LCA$ $,$但是有$3$个节点，那该怎么做呢？

我们来画张图：

![](https://cdn.luogu.com.cn/upload/pic/50959.png)

如果$x,y,z$分别为$3,4,6$那么他们到节点$4$最优。

然后，我们发现一个规律：

要使总路程最少$,$重复走的路程就要最少。

如果他们在节点$2$集合$,$ $4$通向$2$与$6$通向$2$都经过了路程$4-2$ $,$ 也就是说$4-2$这段路程被走了$2$次。

继续观察$,$我们发现：

$1.$ 三个点两两之间的$LCA$一定有两个点相同$($大家画几个图就知道了$,$在这里我就不加解释了$)$。

$2.$ 如果只有$2$个点相同$,$那么聚集点就一定是剩下一个$LCA$。

$3.$ 如果$3$个点的$LCA$都相同$,$那么聚集点就是这个$LCA$。

要选的点求出来了那么就只剩下计算花费了。

比较简单的方法就是对这$3$个点和所选的集合点的深度做差再取绝对值最后加起来$,$这样是很麻烦的。

所以$,$我们再画一张图：

![](https://cdn.luogu.com.cn/upload/pic/50960.png)

假设给出的点分别是$x,y,z$。

$LCA_1$是$LCA(a,b)$和$LCA(a,c)$。

$LCA_2$是$LCA(b,c)$。

我们记录了每个点的深度$Dep[i]$。

根据上面的分析，我们所选的集合点为$P$。

三个点到$P$的距离为$dep[x]+dep[y]+dep[z]-3*dep[P]+2*dep[P]-dep[LCA_1]-dep[LCA_2]$

化简一下就是

$dep[x]+dep[y]+dep[z]-dep[P]-dep[LCA_1]-dep[LCA_2]$


------------
**代码**
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=5*1e5+9;
int n,m,x,y,z,head[MAXN],dep[MAXN],f[MAXN][21],cnt,LCA1,LCA2,LCA3,p;
struct record {
    int u,v;
} edge[MAXN*2];

void add(int x,int y) {
    edge[cnt].u=head[x];
    edge[cnt].v=y;
    head[x]=cnt++;
}
void dfs(int u,int fa) {
    dep[u]=dep[fa]+1,f[u][0]=fa;
    for (int i=1; (1<<i)<=dep[u]; i++) f[u][i]=f[f[u][i-1]][i-1];
    for (int i=head[u]; i!=-1; i=edge[i].u)
        if (edge[i].v!=fa) dfs(edge[i].v,u);
}
int LCA(int x,int y) {
    if(dep[x]>dep[y]) swap(x,y);
    for(int i=19; i>=0; i--)
        if (dep[x]<=dep[y]-(1<<i)) y=f[y][i];
    if (x==y) return x;
    for(int i=19; i>=0; i--)
        if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    return f[x][0];
}
int main() {
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    for (int i=1; i<n; i++) {
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    dfs(1,0);
    while (m--) {
        scanf("%d%d%d",&x,&y,&z);
        LCA1=LCA(x,y),LCA2=LCA(y,z),LCA3=LCA(z,x);
        if (LCA1==LCA2) p=LCA3;
        if (LCA1==LCA3) p=LCA2;
        if (LCA2==LCA3) p=LCA1;
        printf("%d %d\n",p,dep[x]+dep[y]+dep[z]-dep[LCA1]-dep[LCA2]-dep[LCA3]);
    }
    return 0;
}
```








---

## 作者：2018heyuyang (赞：10)

### Tarjan多好用啊，虽然我不知道为什么有的Tarjan会被卡掉

但是我交了一发就A了，$(O2$ $ $ $ $ $954ms)$

去掉 $O2$ 跑了$1.09s$，最慢的点$400$多$ms$

快读，$inline$，$register$ 都没加，难道你谷评测机变快了？

好了，我们回到正题

本人刷《算法进阶》碰到这题，下面内容或许会和书里的差不多

但是模版不是，因为比较容易~~觉悟~~，所以听同学讲几下就懂了，

自己打了个板子，常数好像比模版更优秀，因为我先预处理出欧拉序

所以我对于询问$LCA(x,y)$我可以直接判断哪个点的访问顺序在后面

### 前置芝士（不看请跳过）

首先来了解下**向上标记法**

我们要求 $x$，$y$ 的$LCA$

我们从$x$向上走到根节点，把沿途的点标一下

再从$y$向上走到根节点，碰到的第一个标记点就是$lca(x,y)$

这样一看就是暴力对吧

然后我们用并查集对这样的暴力优化

$Tarjan$是一种**离线**求$LCA$的算法，因为$Tarjan$ ~~only~~ 会**缩点**

我们按一种后序遍历的方式来记录点的顺序（其实是**欧拉序**啦）

然后把所有的询问读进来，再按照后序遍历的顺序枚举$n$个点

每个点扫一遍相关询问，$O($常数$)$出答案

至于怎么出，这里要用点数学小知识

我们先作规定，让后序遍历顺序后面的点去找与前面点的$LCA$

也就是说，访问到右孩子的时候去求与左孩子的$LCA$（这里指相对位置）

好的我们来画颗树

![](https://cdn.luogu.com.cn/upload/image_hosting/str3pb5x.png)

如果我们按照后序遍历的顺序敲代码，是不是红$-$绿$-$白的顺序啊

是不是对于绿的相关询问，另一个点在红里面啊（当然和自己重叠也行）

还记得我们规定了 "让后序遍历顺序后面的点去找与前面点的$LCA$"

你会发现，对于根的最左边的子树，和剩下的白绿点求$LCA$，$LCA$绝不在那个全 $red$ 的子树里

那么是不是剩下的点和那个子树求$LCA$都等价与那个子树最上面的红点求$LCA$啊

$why?$

要是有两个点的$LCA$在"全红树里"，那这两个点就一定是在红树里面，（但这棵树的询问已经处理完了，所以成立咯）

我们可以再跳一下，跳到红树的$fa$，即：绿白点和那颗红树求$LCA$等价于和红树最高点的父亲求$LCA$

那么**整颗红树都**可以**缩成一个点**，我们就用**并查集缩点**，所以说$Tarjan$ ~~only~~ 会缩点

再稍加思索就得到结论，扫完自己的所有孩子后，求自己与自己相关的点的$LCA$

再把自己的整颗树用并查集并到父亲

因为孩子并到了自己，所以不用扫自己的孩子一个一个并向父亲，并查集会解决路径压缩的

那怎么具体求$LCA?$ 发现绿点往上是一条链了吗，把白点和红点分成了两个集合

所有的红点都并到了绿点的父亲，所以$findfa$那个红点就是$LCA$（注意绿点往上是一条类似白色的链）

复杂度是$O($并查集$)$，代码很好打的，记住几个重点就行

1.~~后序遍历~~(欧拉序)

2.绿点到根，左孩子都是红的，红点和不红点的$LCA$ 等价 红点最高点的父亲与不红点的$LCA$

3.整颗子树包括自己求完了，把自己并到父亲，因为递归甩锅，所以整颗树会并上去

~~似乎到这里和 向上标记法 好像看不出来有什么关联了~~

### 搞定了求$LCA$就来看题吧

我们根据经验来想，**两个人汇合了，剩下那个就要自己跑过来**

然后设三个点$x$，$y$，$z$

则$x$到$y$最短总和在他们之间的路径上

则$x$到$z$最短总和在他们之间的路径上

则$y$到$z$最短总和在他们之间的路径上

三个路径交一点嘛！（~~真精彩~~）

至于为什么交一点，我们还是$x$，$y$，$z$三点，设$d(x,y)$为路径集合

把$x$看作树根

$d(y,x)=d(y,LCA(y,z))+d(LCA(y,z),x)$

$d(z,x)=d(z,LCA(y,z))+d(LCA(y,z),x)$

由两条式子得两条路径的交集为 $d(LCA(y,z),x)$

$LCA(y,z)$是$d(LCA(y,z),x)$中深度最大的点，

$LCA(y,z)$是$d(y,z)$中深度最小的点，

所以不看$LCA(y,z)$，$maxdep-d(LCA(y,z),x)<mindep-d(y,z)$

所以三条路径交一点

然后$x$，$y$，$z$到这点的距离和为$\dfrac{dis(x,y)+dis(x,z)+dis(y,z)}{2}$

用类似上面的方法即可证明（把$x$看作树根）

现在来证明到这点最短

我们知道，一但两个人汇合，那么剩下那个人就要自己过来，因为再改变汇合点，这两人就要一起走，就会浪费

还是$x$，$y$，$z$

**如果汇合点不在$d(x,y)$上，那么$x$，$y$就会一起走上一段路程**

**如果汇合点不在$d(x,z)$上，那么$x$，$z$就会一起走上一段路程**

**如果汇合点不在$d(y,z)$上，那么$y$，$z$就会一起走上一段路程**

**所以汇合点要在$d(x,y)$上，也要在$d(x,z)$上，也要在$d(y,z)$上**

这个汇合点是**唯一**的，就是三条路径交的那一点

我们用$Tarjan$求$LCA$从而得到点的距离（$dis(x,y)=dep[x]+dep[y]-2\times dep[LCA(x,y)]$）

三个点两两之间的距离和再除以$2$就是第二部分答案

$Then$我们来求这个交汇点

我直接告诉你答案是$LCA(x,y)$，$LCA(x,z)$，$LCA(y,z)$三个点中深度最大的点

~~完结撒花~~

### $why?$

首先解释下为什么是$LCA($某个点，某个点$)$

一句话解释，两个人汇合，剩下那个要自己过来，那么两个人的汇合点就是他们的$LCA$

我们又双叒叕设$x$，$y$，$z$

$x$和$y$有$LCA(x,y)$，$y$和$z$有$LCA(y,z)$

设$dep[LCA(x,y)]<dep[LCA(y,z)]$

那么$LCA(y,z)$是$LCA(x,y)$的某个孩子

如果选$LCA(x,y)$作为汇合点，那么$y$和$z$要先在$LCA(y,z)$汇合，再向上走

这显然违反了**汇合后不能再行进**的规定

所以深度大的$LCA$更优，我们就珂以愉快地敲代码了

### 下面代码和《算法进阶》里面的模版不同，慎抄

```cpp
#include<cstdio>
using namespace std;
int _;void swap(int &x,int &y){_=x;x=y;y=_;}
const int N=500005;
struct edge
{
	int x,y,next;
}a[N<<1],b[N*3];
int len=0,last[N];
int cnt=0,less[N],d[N],dep[N],ans[N],pos[N];
void ins(int x,int y){a[++len]=(edge){x,y,last[x]};last[x]=len;}
void ins2(int x,int y){b[++cnt]=(edge){x,y,less[x]};less[x]=cnt;}
void dfs(int x,int fa)
{
	for(int k=last[x];k;k=a[k].next)
	{
		int y=a[k].y;
		if(y!=fa)
		{
			dep[y]=dep[x]+1;
			dfs(y,x);
		}
	}
	d[x]=++cnt;//欧拉序(类似后序遍历) 
}
int ma[N];//变量名不够用了... 
int findfa(int x){return x==ma[x]?x:ma[x]=findfa(ma[x]);}
void dfs2(int x,int fa)
{
	for(int k=last[x];k;k=a[k].next)//先遍历孩子 
	{
		int y=a[k].y;
		if(y!=fa)dfs2(y,x);
	}
	for(int k=less[x];k;k=b[k].next)//扫描相关询问 
	{
		int y=b[k].y,ty=findfa(y),p=(k+2)/3;
		ans[p]+=dep[x]+dep[y]-dep[ty]*2;
		if(dep[pos[p]]<dep[ty])pos[p]=ty;
	}
	ma[x]=fa;
}
int main()
{
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		ins(x,y);ins(y,x);
	}
	dep[1]=1;dfs(1,0);cnt=0;//求欧拉序 
	for(int i=1,x,y,z;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(d[x]>d[y])swap(x,y);
		if(d[x]>d[z])swap(x,z);
		if(d[y]>d[z])swap(y,z);
		ins2(y,x);ins2(z,x);ins2(z,y);
	}
	for(int i=1;i<=n;i++)ma[i]=i;//并查集 
	dfs2(1,0);//solve
	for(int i=1;i<=m;i++)printf("%d %d\n",pos[i],ans[i]>>1);
	return 0;
}
```
下面来口胡一下为什么$Tarjan$会被卡

$Tarjan$的复杂度建立在并查集上

很多人认为并查集是$O(N)$的

其实并查集分很多种，比如$CSP-S(2019)$初赛那个并查集是$O(N^2)$的

那个并查集就没有加路径压缩

目前并查集有两个优化，一个就是**路径压缩**，另一个是**按秩合并**

一般我们是不用**按秩合并**的，只有做**可持久化并查集**那题才用到

为什么一般不用呢，因为我们认为**路径压缩**的优化已经足够

且**路径压缩**更易拓展，像$(USACO)$城市的地平线就可以用并查集做

我们可以用路径压缩的并查集加基数排序乱搞，那道题就$O(N)$了

当然，在数据随机的情况下，**路径压缩**并查集才能达到$O(N)$的复杂度

只加**路径压缩**优化的并查集可以卡到$O(NlogN)$，这也可能是$Tarjan$被卡的原因之一

再加上**按秩合并**，可以使并查集优化到最坏$O($反阿克曼函数$\times N)$，这点在一篇大佬的博客里有写

但是这样返回的父亲就不是原来那样了

我们在别的地方优化好了

《算法进阶》里的模版是一次递归，但是每次询问要拆成两次，因为你不知道欧拉序是怎样的

这题里套那啥板子会变成$6\times M$个询问，可能空间爆炸，带着TLE

所以我就先跑欧拉序咯，空间砍一半多好啊

~~话说一道$LCA$怎么就变成并查集了~~

---

## 作者：Krystallos (赞：10)

# 本蒟蒻的第一篇紫题题解，大佬勿喷！
### 首先介绍介绍一下这道题的算法：LCA$\colorbox{white}{\color{white}{\text{不会LCA的先去把P3379暴切了再来！}}}$
LCA只能求两个点的最近公共祖先，而这道题是三个点的LCA（函数名为$big\_lca$）。其实也没什么难的$\colorbox{white}{\color{white}{\text{<--FaKe}}}$，两两跑一跑LCA就差不多了。这里两两跑LCA会跑出3个结果，下面将这三个结果记在$root$数组里。下面是$big\_lca$的代码（$get\_lca$求两个节点的最近公共祖先，$deep$记录每个节点到根节点的距离，$ans$记录答案节点编号，函数返回值是最小花费）：
```cpp
inline int big_lca(int x, int y, int z, int &ans) {
	int root[3];
	root[0] = get_lca(x, y);
	root[1] = get_lca(y, z);
	root[2] = get_lca(x, z);
	if (root[0] == root[1] && root[1] == root[2]) {//情况一
		ans = root[0];
		return (deep[x] - deep[root[0]]) + (deep[y] - deep[root[0]]) + (deep[z] - deep[root[0]]);
	}
	if (root[0] == root[1] && root[1] != root[2]) {//情况二
		ans = root[2];
		return (deep[x] - deep[root[2]]) + (deep[y] - deep[root[0]]) + (deep[z] - deep[root[2]]) + (deep[root[2]] - deep[root[0]]);
	}
	if (root[0] != root[1] && root[1] == root[2]) {//情况二
		ans = root[0];
		return (deep[x] - deep[root[0]]) + (deep[y] - deep[root[0]]) + (deep[z] - deep[root[2]]) + (deep[root[0]] - deep[root[1]]);
	}
	if (root[0] == root[2] && root[1] != root[2]) {//情况二
		ans = root[1];
		return (deep[x] - deep[root[2]]) + (deep[y] - deep[root[1]]) + (deep[z] - deep[root[1]]) + (deep[root[1]] - deep[root[2]]);
	}
}
```
### 代码解释：
情况一：这是最理想的一种方式，三个节点的两两LCA均相同，这时答案节点就是任意两个节点的LCA，答案距离是三个点到答案节点的距离之和。

情况二：在这种情况下，两个LCA相同，一个LCA不同。经过本人的仔细推算，不同的那个LCA一定离根节点更远$\colorbox{white}{\color{white}{\text{什么仔细推算，明明是瞎胡乱搞}}}$，这时集合地点就要选在不同的那个LCA处了。而且经过严密推算$\colorbox{white}{\color{white}{\text{又来了，明明就是瞎胡乱搞}}}$，这是对的。答案距离是三个点到答案节点的距离之和。

情况三：三个LCA均不相等。这个情况胎死腹中了，因为这个情况**压根就不存在**！这个结论也是得到了证明的$\colorbox{white}{\color{white}{\text{明明就是瞎胡乱搞，要我说几次？}}}$。

好的这就是所有情况，正巧这个题核心函数就是$big\_lca$。其余的函数都是LCA基本操作。

P.S. 本人因为太蒟，LCA只会倍增。

好的下面是总代码~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int nn = 5e5 + 5;
const int dep = 20;
int deep[nn], n, m, father[nn][dep], s;
int Last[nn], prev[nn << 1], Begin[nn << 1], End[nn << 1];
int cnt;
inline void make_line(int x, int y) {
    cnt++;
    prev[cnt] = Last[x];
    Last[x] = cnt;
    Begin[cnt] = x;
    End[cnt] = y;
}
inline void cheshu(int k, int fa) {
	father[k][0] = fa;
	for (int i = Last[k]; i; i = prev[i]) {
		if (End[i] != fa) {
			cheshu(End[i], k);
		}
	}
}
inline void build() {
	for (int j = 1; j < s; j++)
		for (int i = 1; i <= n; i++)
			father[i][j] = father[father[i][j - 1]][j - 1];
}
inline void init_deep(int k) {
	if (father[k][0] == 0){
		deep[k] = 0;
	} else {
		deep[k] = deep[father[k][0]] + 1;
	}
	for (int i = Last[k]; i; i = prev[i]) {
		if (End[i] != father[k][0])
			init_deep(End[i]);
	}
	return;
}
inline int up(int v, int p) {
	for (int i = 0; i < s; i++)
		if (p & (1 << i))
			v = father[v][i];
	return v;
}
inline int get_lca(int x, int y) {
	if (deep[x] < deep[y])
		swap(x, y);
	x = up(x, deep[x] - deep[y]);
	if (x == y)
		return y;
	for (int i = s; i >= 0; i--)
		if (father[x][i] != father[y][i] && father[x][i] != 0 && father[y][i] != 0) {
			x = father[x][i];
			y = father[y][i];
		}
	return father[x][0];
}
inline int big_lca(int x, int y, int z, int &ans) {//本程序核心函数
	int root[3];
	root[0] = get_lca(x, y);
	root[1] = get_lca(y, z);
	root[2] = get_lca(x, z);
	if (root[0] == root[1] && root[1] == root[2]) {
		ans = root[0];
		return (deep[x] - deep[root[0]]) + (deep[y] - deep[root[0]]) + (deep[z] - deep[root[0]]);
	}
	if (root[0] == root[1] && root[1] != root[2]) {
		ans = root[2];
		return (deep[x] - deep[root[2]]) + (deep[y] - deep[root[0]]) + (deep[z] - deep[root[2]]) + (deep[root[2]] - deep[root[0]]);
	}
	if (root[0] != root[1] && root[1] == root[2]) {
		ans = root[0];
		return (deep[x] - deep[root[0]]) + (deep[y] - deep[root[0]]) + (deep[z] - deep[root[2]]) + (deep[root[0]] - deep[root[1]]);
	}
	if (root[0] == root[2] && root[1] != root[2]) {
		ans = root[1];
		return (deep[x] - deep[root[2]]) + (deep[y] - deep[root[1]]) + (deep[z] - deep[root[1]]) + (deep[root[1]] - deep[root[2]]);
	}
}
int main() {
	scanf("%d %d", &n, &m);
	for (int i = 0; (1 << i) <= n; i++)
		s++;
	for (int i = 1; i < n; i++) {
		int x, y;
		scanf("%d %d",&x, &y);
		make_line(x, y);
		make_line(y, x);
	}
	cheshu(1, 0);
	build();
	init_deep(1);
	for (int i = 1; i <= m; i++) {
		int x, y, z, ans, d;
		scanf("%d %d %d", &x, &y, &z);
		d = biglca(x, y, z, ans);
		printf("%d %d\n", ans, d);
	}
	return 0;
}
```

---

## 作者：bztMinamoto (赞：7)

这道题本质上还是一道lca的问题，但问题就在于一共有san个点（特别降san值啊……），不能用一般的lca做

以样例为例，如果按lca(lca(x,y),z)求解，第一个输入会输出4,3，与答案不符。这是因为lca只能求出比某一节点深度更浅的节点，如果集合点在比某一节点深度更深的点,用单纯的lca是无法求出答案的

于是我们可以这样考虑：设只有两个点x,y，a=lca(x,y)，很明显，x和y都到a时即为最少的花费，此时，z点到a的花费可以用lca(a,z)来求出。我们将a换为lca(x,z)和lca(y,z)并依次计算，三者的最小值即为所求答案

证明：当x,y到达lca时，z从自己到达点a，每走一步需要花费1，而x和y每走一步需要花费2，所以当x和y都到达lca时，z从自己走向a是最少的花费。枚举三个lca，即可求出答案

设d为树的深度，a为x，y的lca，b为a与z的lca。从x到a，y到a分别花费d[x]-d[a],d[y]-d[a],从z到a花费d[z]+d[a]-2*d[b]。则答案为
```
ans=max(d[x]+d[y]+d[z]-d[a]-2*d[b]);
k=a;//此a为使ans最大的a值
```
可知，a不论为哪两个点的lca，此等式不变。所以，只需枚举a为三个点中任意两个的lca，即可求出答案

顺带一提，我的代码用的是树剖。如果不明白可以看看我的blog
https://www.luogu.org/blog/user41781/solution-p2912

当然这道题的lca用倍增求也是没有问题的

上代码，具体看注解
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define fu(a,b,c) for(int a=b;a<=c;a++)
#define fd(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
const int INF=0x3f3f3f3f,N=500050;
int ver[N*2],head[N],Next[N*2],size[N],top[N],fa[N],d[N];
int n,t,tot;
int a,b,ans=INF,k,x,y,z;
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
void dfs(int x)
{
	size[x]=1,d[x]=d[fa[x]]+1;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(y!=fa[x])
		fa[y]=x,dfs(y),size[x]+=size[y];
	}
}
void dfs_(int x)
{
	if(!top[x]) top[x]=x;
	int t=0;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(y!=fa[x]&&size[y]>size[t])
		t=y;
	}
	if(t) top[t]=top[x],dfs_(t);
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(y!=fa[x]&&y!=t)
		dfs_(y);
	}
}
int lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	if(d[x]>d[y]) swap(x,y);
	return x;
}
void check()
{
	int s=d[x]+d[y]+d[z]-d[a]-2*d[b];
    //此式子不变
	if(s<ans) ans=s,k=a;
}
void answer()
{
	scanf("%d%d%d",&x,&y,&z);
	ans=INF;
    //枚举a为三个lca，并检查，更新答案
	a=lca(x,y),b=lca(a,z);
	check();
	a=lca(x,z),b=lca(a,y);
	check();
	a=lca(y,z),b=lca(a,x);
	check();
	printf("%d %d\n",k,ans);
	return;
}
int main()
{
	scanf("%d%d",&n,&t);
	fu(i,1,n-1)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1);
	dfs_(1);
	while(t--) answer();
	return 0;
}
```

---

## 作者：Sangber (赞：6)

同步发布于我的博客园：
[小蒟蒻$\mathtt{zsb}$的博客园](https://www.cnblogs.com/zsbzsb/p/11112926.html)
### 题目描述
这次也是很长的题面啊$qwq$  
题目大意如下：  
给定一棵$N$个节点的树以及$M$次询问，每次询问给出$x,\ y,\ z$三个节点，程序需要在树上找一个点$p$  
使得$c = dist(x,p)+dist(y,p)+dist(z,p)$取最小值，每一次询问输出满足条件的$p$和此时的最小的$c$

----
### 基本思路
看到树上距离的题，很容易想到$LCA$，但是此处有三个点，不能直接用$LCA$，所以我们得绕一点弯...  

考虑求出三个点两两之间的$LCA,\ $那么我们可以马上想到：
$$p \in \{ LCA(x,y),LCA(x,z),LCA(y,z)\}$$
#### 证明：
对于一条树上路径$(x, y)$，显然对于
$$\forall\ p \in (x,y), dist(x,p)+dist(p,y)=dist(x,y)$$
所以该$\ p\ $点并不会影响$x,y$的费用，所以我们应该尽可能使$\ p\ $点靠近$\ z\ $点  

此时需要分类讨论 ：   
1.  $z \in (x,y) ,$那么$p=z$
1.  $z \notin (x,y),$那么
	1. $z \in SubTree(x)($或 $z \in SubTre(y)),p=x($或$p=y)$
    1. $z \notin SubTree(x)$且$z \notin SubTree(y), z=LCA(x,y)$  

是不是感觉好麻烦？其实我们完全没必要做这么多。$qwq$  
因为$x,y,z$是有轮换性的，所以只需要用某两个点之间的$LCA$试着更新$p$点就好了,结论也就是这么出来的  
(具体过程可以根据上面的分类讨论，自己yy一下，最好画一张图~~我才不会告诉你我不会用几何画板~~)  

----
### 细节注意事项
计算树上路径时，一定不要直接用$dep$去减，跑得过样例但是会WA

----
### 参考代码
```cpp
#include <cstdio>
#include <cstring>
#define rg register
const int MAXN = 500010;
inline int abs(int a) { return a < 0 ? -a : a; }
inline void swap(int& a, int& b) { int t = a; a = b; b = t; }
inline int read() {
    int s = 0; bool f = false; char c = getchar();
    while (c < '0' || c > '9') f |= (c == '-'), c = getchar();
    while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();
    return f ? -s : s;
}
int tot, head[MAXN], nxt[MAXN << 1], ver[MAXN << 1];
inline void Add_edge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, ver[tot] = v; }
int dep[MAXN], f[MAXN][22];
inline void dfs(int u, int fa) {
    dep[u] = dep[fa] + 1, f[u][0] = fa;
    for (rg int i = 1; i <= 20; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (rg int v, i = head[u]; i; i = nxt[i])
        if(!dep[v = ver[i]]) dfs(v, u);
}
inline int LCA(int x, int y) {
    if (dep[x] < dep[y]) swap(x, y);
    for (rg int i = 20; ~i; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i];
    if (x == y) return x;
    for (rg int i = 20; ~i; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
    return f[x][0];
}
int main() {
    int n = read(), q = read();
    for (rg int i = 1; i < n; i++) {
        int u = read(), v = read();
        Add_edge(u, v), Add_edge(v, u);
	}
    dfs(1, 0);
    for (rg int i = 1; i <= q; i++) {
        int x = read(), y = read(), z = read();
        int pos, minn = 2147483647, c;
        //根据轮换性(所以这三段都长得差不多...)
        int lca1 = LCA(x, y);
        c = dep[x] + dep[y] - 2 * dep[lca1];
        int lcaz = LCA(lca1, z);
        c += dep[lca1] + dep[z] - 2 * dep[lcaz];
        if (minn > c) pos = lca1, minn = c;
        
        int lca2 = LCA(x, z);
        c = dep[x] + dep[z] - 2 * dep[lca2];
        int lcay = LCA(lca2, y);
        c += dep[lca2] + dep[y] - 2 * dep[lcay];
        if (minn > c) pos = lca2, minn = c;
		
        int lca3 = LCA(y, z);
        c = dep[y] + dep[z] - 2 * dep[lca3];
        int lcax = LCA(lca3, x);
        c += dep[x] + dep[lca3] - 2 * dep[lcax];
        if (minn > c) pos = lca3, minn = c;
        
        printf("%d %d\n", pos, minn);
    }
    return 0;
}

```
**完结撒花$qwq$**

---

## 作者：Elma_ (赞：5)

## Description

[题目链接](https://www.luogu.com.cn/problem/P4281)

欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有 $n$ 个等待点，有 $n-1$ 条道路连接着它们，每一条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一个点到另一个点要花费一个游戏币。

参加游戏的人三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对话机（用于和同组的成员联系）。当集合号吹响后，每组成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在	$n$ 个等待点中确定一个集结点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。

小可可和他的朋友邀请你一起参加这个游戏，由你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？

## Solution

大概类似于三个点的$LCA$？（

首先考虑每两个点的$LCA$，这个很容易求出，不然你也不会来做这题。

然后考虑这几个点之间有什么关系。假设这棵树上有三个节点$x$、$y$、$z$，记两两的$LCA$分别为$xy$、$yz$、$xz$。

可以发现有这样的性质，显然树上存在某一个节点，把整颗树分割为两颗子树，把其中的两个$LCA$放在一侧，另一个放在另一侧。所以其中一定有两个$LCA$是相等的，显然这个不相等的$LCA$就是最佳集合点，这个不难证。

考虑如何求距离。记节点$x$的深度为$dep_x$，做一个边差分则有：
$$dis(x, y) = dep_x + dep_y - dep_{xy} \times 2$$
$$dis(z, y) = dep_z + dep_y - dep_{zy} \times 2$$
$$dis(x, z) = dep_x + dep_z - dep_{xz} \times 2$$

相加得到
$$dep_x + dep_y - dep_{xy} \times 2 +dep_z + dep_y - dep_{zy} \times 2 + dep_x + dep_z - dep_{xz} \times 2$$

化简得
$$dep_x + dep_y + dep_z - dep_xy - dep_xz - dep_yz$$

这个东西可以$O(1)$求出。

然后这题就做完了。

## Code

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define maxn 500005
#define maxm 500005
using namespace std;

struct node
{
	int to, nxt;
}edge[maxn << 2];
int n, m, tot;
int head[maxn], fa[maxn][30], dep[maxn];

inline int read()
{
	char v = getchar();int x = 0, f = 1;
	while (!isdigit(v)) { if (v == '-')f = -1;v = getchar(); }
	while (isdigit(v)) { x = x * 10 + v - 48;v = getchar(); }
	return x * f;
}

inline void add(int u, int v)
{
	edge[++tot].nxt = head[u];
	edge[tot].to = v;
	head[u] = tot;
}

inline void addedge(int u, int v)
{
	add(u, v), add(v, u);
}

void dfs(int u, int fath)
{
	dep[u] = dep[fath] + 1, fa[u][0] = fath;
	for(int i = 0;fa[u][i];i++)
		fa[u][i + 1] = fa[fa[u][i]][i];
	for(int i = head[u];i;i = edge[i].nxt)
	{
		int v = edge[i].to;
		if(v != fath) dfs(v, u);
	} 
}

int lca(int u, int v)
{
	if(dep[u] > dep[v]) swap(u, v);
	for(int i = 20;i >= 0;i--)
		if(dep[u] <= dep[v] - (1 << i)) v = fa[v][i];
	if(u == v) return u;
	for(int i = 20;i >= 0;i--)
		if(fa[u][i] != fa[v][i])
			u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

int main(void)
{
	n = read(), m = read();
	for(int i = 1;i < n;i++)
	{
		int u = read(), v = read();
		addedge(u, v);
	}
	dfs(1, 0);
	for(int i = 1;i <= m;i++)
	{
		int ans, x = read(), y = read(), z = read(), xyz;
		int xy = lca(x, y);
		int yz = lca(y, z);
		int xz = lca(x, z);
		if(xy == yz) xyz = xz;
		else if(xy == xz) xyz = yz;
		else if(yz == xz) xyz = xy;
		ans = dep[x] + dep[y] + dep[z] - dep[xy] - dep[xz] - dep[yz];
		printf("%d %d\n", xyz, ans);
	}
	return 0;
}
```


---

## 作者：renhr2002 (赞：5)

发现没有欧拉序求lca的题解，这样，我就给大家Li2O一发。

对于三点的最短距离，我们可以两两求lca，结果发现，其中必有两个lca重合，而剩下的一个就是最优解。

不过，相比某些算法，欧拉序还是比较耗时的（**尤其是树很大，而提问很少的 时候**），我为此改了半天，改小常数，还开了O2优化，才卡进时限。敬请见谅。

### 请慎重参考本题解！

O2优化代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 505555
int n,m;
struct node
{
    int to;
    int nxt;
}nd[2*maxn];
int head[maxn],dfn[maxn],dep[maxn],cnt,tot;
//dfn:每个节点在欧拉序中第一次出现的位置
int f[2*maxn][21];
int lg[2*maxn];
void init()
{
    memset(head,-1,sizeof(head));
    lg[1]=0;
    for(int i=2;i<=2*n-1;i++)
    {
        lg[i]=lg[i>>1]+1;
    }
    cnt=1;
    return;
}
void add(int x,int y)
{
    nd[cnt].to=y;
    nd[cnt].nxt=head[x];
    head[x]=cnt++;
    return;
}
void dfs(int rt,int x)
{
    tot++;
    dfn[x]=tot;
    f[tot][0]=x;
    for(int i=head[x];i!=-1;i=nd[i].nxt)
    {
        int t=nd[i].to;
        if(t!=rt)
        {
            dep[t]=dep[x]+1;
            dfs(x,t);
            tot++;
            f[tot][0]=x;
        }
    }
    return;
}
void rmq()
{
    for(int i=1;i<=lg[tot];i++)
    {
        for(int x=1;(x+(1<<i)-1)<=tot;x++)
        {
            int r=x+(1<<(i-1));
            f[x][i]=dep[f[x][i-1]]<dep[f[r][i-1]]?f[x][i-1]:f[r][i-1];
        }
    }
    return;
}
int lca(int x,int y)
{
    if(x>y)
    {
        swap(x,y);
    }
    int k=lg[y-x+1];
    return dep[f[x][k]]<dep[f[y-(1<<k)+1][k]]?f[x][k]:f[y-(1<<k)+1][k];
}
int dist(int a,int b)
{
    return dep[a]+dep[b]-2*dep[lca(dfn[a],dfn[b])];
}
int main()
{
    scanf("%d%d",&n,&m);
    init();
    for(int i=1;i<n;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);
    }
    dfs(0,1);
    rmq();
    while(m--)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        int d=lca(dfn[a],dfn[b]);
        int e=lca(dfn[a],dfn[c]);
        int g=lca(dfn[b],dfn[c]);
        if(d==e)
        {
        	printf("%d %d\n",g,dist(b,c)+dist(g,a));
        }else if(d==g)
        {
        	printf("%d %d\n",e,dist(a,c)+dist(e,b));
        }else
        {
        	printf("%d %d\n",d,dist(a,b)+dist(d,c));
        }
    }
    return 0;
}
```

---

## 作者：Vemn_Noob (赞：3)

# 这里只是对为什么要选不重复的LCA节点进行解释
# [题面](https://www.luogu.org/problem/P4281)
## 以样例的一个询问为例
![text1](  https://cdn.luogu.com.cn/upload/pic/71137.png)
![text2](  https://cdn.luogu.com.cn/upload/pic/71139.png)
![text3](  https://cdn.luogu.com.cn/upload/pic/71141.png)
## 由此可知，如果选重复的LCA，会导致重复路径（花费）；
贴代码：
```cpp
#include<bits/stdc++.h>
#define MAXN 500500
using namespace std;
struct edge{
	int from,to,next;
}e[MAXN<<1];
int n,m,now;
int p[MAXN][22],logn[MAXN],head[MAXN<<1],depth[MAXN];
inline void add(int u,int v)
{
	e[++now].to=v;
	e[now].from=u;
	e[now].next=head[u];
	head[u]=now;
}
inline void build(int child,int fath)
{
	if(child==1)depth[child]=0;
	else depth[child]=depth[fath]+1;
	p[child][0]=fath;
	for(int i=1;(1<<i)<=depth[child];i++)
		p[child][i]=p[p[child][i-1]][i-1];
	for(int i=head[child];i;i=e[i].next)
		if(e[i].to!=fath)build(e[i].to,child);
	return;
}
inline int query(int a,int b)
{
	if(depth[a]<depth[b])swap(a,b);
	while(depth[a]>depth[b])
		a=p[a][logn[depth[a]-depth[b]]];
	if(a==b)return a;
	for(int i=logn[depth[a]];i>=0;i--)
		if(p[a][i]!=p[b][i])a=p[a][i],b=p[b][i];
	return p[a][0];
}
inline void get_res()
{
	for(int i=1;i<=m;i++)
	{
		int a,b,c,minn,load,t;
		bool flag=true;
		scanf("%d%d%d",&a,&b,&c);
		int aa=query(a,b);
		int bb=query(c,b);
		int cc=query(a,c);
		if(aa==bb)
			t=cc;
		else if(aa==cc)
				t=bb;
		else if(bb==cc)
				t=aa;
		int ans=depth[a]+depth[b]+depth[c]-depth[aa]-depth[bb]-depth[cc];
		printf("%d %d\n",t,ans);
	}
}
int main()
{
	//freopen("in.txt","r",stdin);
	cin>>n>>m;
	logn[1]=0;
	for(int i=2;i<=n;i++)
		logn[i]=logn[i>>1]+1;
	for(int i=1;i<=n-1;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	build(1,0);
	get_res();
	return 0;
}
```
#### 另外给80分的朋友们提个醒
# 十年OI一场空，数组开小见祖宗
### 祝大家2019noipNP++

---

## 作者：vines (赞：3)

本题思路楼上dalao已经写得挺清楚了，据我自己的理解在求出两两的最近公共祖先之后，在其三点构成的那条链上不管在链上哪个点集合代价都是一样的，所以我们求的实际上是这三条链的交点，实际上就是与其他两个不同那个点，画图可以很清楚的看到此关系。
本文主要提供用倍增思想来解lca问题，下面贴代码；
```cpp
#include<stdio.h>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int f[500005][19],ed[500005],lst[500005],dep[500005],nxt[500005],s,cnt=0;
void add(int x,int y){
     ed[++cnt]=y;
     nxt[cnt]=lst[x];
     lst[x]=cnt;
}
void dfs(int x){
     dep[x]=dep[f[x][0]]+1;
     for(int i=1;i<=s;i++)f[x][i]=f[f[x][i-1]][i-1];
     int y=lst[x];
     while(y){
     	if(ed[y]!=f[x][0]){
     	   f[ed[y]][0]=x;
	       dfs(ed[y]);
		}
	    y=nxt[y];
	}
}
int lca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    int k=dep[x]-dep[y];
    for(int i=s;i>=0;i--)if(k&(1<<i)){x=f[x][i];}
    if(x==y)return x;
    for(int i=s;i>=0;i--)if(f[x][i]!=f[y][i]){x=f[x][i];y=f[y][i];}
    return f[y][0];
}
int main(){
    int n,m,x,y,z;
    cin>>n>>m;
    s=ceil(log2(n));
    for(int i=1;i<n;i++){
	    cin>>x>>y; 
	    add(x,y);
	    add(y,x);
	}
    dfs(1);
    for(int i=1;i<=m;i++){
	    cin>>x>>y>>z;
	    int t1,t2,t3,ans;
	    t1=lca(x,y);
        t2=lca(x,z);
        t3=lca(y,z);
        if(t1==t2)ans=t3;
        else if(t1==t3)ans=t2;
        else if(t2==t3)ans=t1;
	    cout<<ans<<" "<<dep[x]+dep[y]+dep[z]-dep[t1]-dep[t2]-dep[t3]<<endl;
	}
}
```

---

## 作者：顾z (赞：3)


# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述-->[p4281 [AHOI2008]紧急集合 / 聚会](https://www.luogu.org/problemnew/show/P4281)

我天,这题恶心坏了.

话说没出样例就敢交题的我实在是tql。 ～ｗ～

明显到$LCA$处就能取到最小的值。

会需要求到$6$种(貌似可以求的更少.

首先这六种情况怎么算出来的.

$$C_{3}^{2} \times 2 =6$$

> 其中$C_3^2$代表在三个点中,随便选两个点求$LCA$记作$X$。
>
> 然后再求第三个点与$X$的$LCA$记作$Y$

注意,这里要选择$X$作为集合点.这样会更优.

因为走到$Y$的话就会是两个点对花费的贡献.这样明显更大啊.

而走到$X$，这两个点对花费的贡献就会比较小了,另一个人多走就好了.

但是感觉不太对.但又的确是对的 emmm

比如这样：

　　![](https://i.loli.net/2018/10/11/5bbf4d2d82cfc.png)

简单来看的话,我们求出了$b$和$c$的$LCA=X$ 

$a$和$X$的$LCA=Y$

此时$a,b,c$走到$X$的价值为$4$,走到$Y$的价值为$5$

(这只是一个小栗子啦 qwq)

``代码``

```c++
#include<cstdio>
#include<cctype>
#include<algorithm>
#define R register
#define N 500008
using namespace std;
inline void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int head[N],tot,depth[N],dis[N];
int n,m,gw[N][21],f[N][21];
struct cod{int u,v;}edge[N<<2];
inline void add(int x,int y,int z)
{
	edge[++tot].u=head[x];
	edge[tot].v=y;
	head[x]=tot;
}
void dfs(int u,int fa)
{
	f[u][0]=fa;depth[u]=depth[fa]+1;
	dis[u]=dis[fa]+1;
	for(R int i=1;(1<<i)<=depth[u];i++)
		f[u][i]=f[f[u][i-1]][i-1];
	for(R int i=head[u];i;i=edge[i].u)
	{
		if(edge[i].v==fa)continue;
		dfs(edge[i].v,u);
	}
}
inline int lca(int x,int y)
{
	if(depth[x]>depth[y])swap(x,y);
	for(R int i=17;i>=0;i--)
		if(depth[x]+(1<<i)<=depth[y])
			y=f[y][i];
	if(x==y)return y;
	for(R int i=17;i>=0;i--)
	{
		if(f[x][i]==f[y][i])continue;
		x=f[x][i],y=f[y][i];
	}
	return f[x][0];
}
int main()
{
	in(n),in(m);
	for(R int i=1,x,y;i<n;i++)
		in(x),in(y),add(x,y,1),add(y,x,1);
	dfs(1,0);
	for(R int i=1,x,y,z;i<=m;i++)
	{
		in(x),in(y),in(z);
		R int a=lca(x,y),b=lca(x,z),c=lca(y,z);
		R int aa=lca(a,z),bb=lca(y,b),cc=lca(x,c);
		R int father,res=214748364;
		int ansa=dis[x]+dis[y]-2*dis[a]+dis[a]-2*dis[aa]+dis[z];
		int ansb=dis[x]+dis[z]-2*dis[b]+dis[b]-2*dis[bb]+dis[y];
		int ansc=dis[y]+dis[z]-2*dis[c]+dis[c]-2*dis[cc]+dis[x];
		if(res>ansa)res=ansa,father=a;
		if(res>ansb)res=ansb,father=b;
		if(res>ansc)res=ansc,father=c;
		printf("%d %d\n",father,res);
	}
}
```





---

## 作者：LightningUZ (赞：2)

### 题意简述

给定一个 $n$ 个点的树，还有 $m$ 个询问，每个询问给定树上三个点 $A,B,C$，请你找到一个点 $K$ 使得这个点到三个点距离和最小。

$n,m<=5\times 10^5$

### 思路

很显然（？），对于点 $A,B,C$，我们考虑 $K=LCA(A,B),LCA(B,C)$ 或者 $LCA(C,A)$ 的情况即可

倍增维护一下就好了。 $O((n+m)logn)$ 的

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
	#define N 1666666
	#define F(i,l,r) for(int i=l;i<=r;++i)
	#define D(i,r,l) for(int i=r;i>=l;--i)
	#define Fs(i,l,r,c) for(int i=l;i<=r;c)
	#define Ds(i,r,l,c) for(int i=r;i>=l;c)
	#define MEM(x,a) memset(x,a,sizeof(x))
	#define FK(x) MEM(x,0)
	#define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))
	#define p_b push_back
	#define sz(a) ((int)a.size())
	#define iter(a,p) (a.begin()+p)
	void R1(int &x)
	{
	    x=0;char c=getchar();int f=1;
	    while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();
	    while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	    x=(f==1)?x:-x;
	}
	void Rd(int cnt,...)
	{
	    va_list args;
	    va_start(args,cnt);
	    F(i,1,cnt) 
	    {
	        int* x=va_arg(args,int*);R1(*x);
	    }
	    va_end(args);
	}
	class Graph //链式前向星存图，直接跳过即可
	{
	    public:
	        int head[N];
	        int EdgeCount;
	        struct Edge
	        {
	            int To,Label,Next;
	        }Ed[N<<1];
	        void clear(int _V=N,int _E=N<<1) 
	        {
	            memset(Ed,-1,sizeof(Edge)*(_E));
	            memset(head,-1,sizeof(int)*(_V));
	            EdgeCount=-1;
	        }
	        void AddEdge(int u,int v,int w=1)
	        {
	            Ed[++EdgeCount]=(Edge){v,w,head[u]};
	            head[u]=EdgeCount;
	        }
	        void Add2(int u,int v,int w=1) {AddEdge(u,v,w);AddEdge(v,u,w);}
	        int Start(int u) {return head[u];}
	        int To(int u){return Ed[u].To;}
	        int Label(int u){return Ed[u].Label;}
	        int Next(int u){return Ed[u].Next;}
	}G;

	int n,m;
	void Input()
	{
		Rd(2,&n,&m); G.clear();
		F(i,1,n-1) {int u,v;Rd(2,&u,&v); G.Add2(u,v);}
	}

	int fa[N][22],deep[N]; //预处理LCA
	void DFS(int u,int f=1)
	{
		fa[u][0]=f; F(i,1,20) fa[u][i]=fa[fa[u][i-1]][i-1];
		deep[u]=(u==f)?0:deep[f]+1;
		Tra(i,u) if (v!=f)
		{
			DFS(v,u);
		}
	}
	int LCA(int u,int v) //求u,v的LCA
	{
		if (deep[u]<deep[v]) swap(u,v);
		D(i,20,0) if (deep[fa[u][i]]>=deep[v]) u=fa[u][i];
		if (u==v) return u;
		D(i,20,0) if (fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
		return fa[u][0];
	}
	int Path(int u,int v){return deep[u]+deep[v]-2*deep[LCA(u,v)];}
    //求u,v路径长度
	void Soviet()
	{
		DFS(1);
		F(i,1,m)
		{
			int a,b,c; Rd(3,&a,&b,&c);
			int ans=0x3f3f3f3f,ansk;
			int lab=LCA(a,b),lac=LCA(a,c),lbc=LCA(b,c);
			if (Path(a,b)+Path(lab,c)<ans) ans=Path(a,b)+Path(lab,c),ansk=lab;
            //K=LCA(a,b)
			if (Path(a,c)+Path(lac,b)<ans) ans=Path(a,c)+Path(lac,b),ansk=lac;
			//K=LCA(a,c)
            if (Path(b,c)+Path(lbc,a)<ans) ans=Path(b,c)+Path(lbc,a),ansk=lbc;
			//K=LCA(b,c)
            printf("%d %d\n",ansk,ans);
		}
	}

	#define Flan void
	Flan IsMyWife()
	{
		Input();
		Soviet();
	}
}
int main()
{
	Flandre_Scarlet::IsMyWife();
	getchar();getchar();
	return 0;
}
```

### 证明：为什么这个算法是对的

（不想看跳过）

~~上面已经说了，显然是对的~~

如果你觉得不显然，可以先考虑只有 $A,B$ 的情况。显然，只要 $K$ 在 $A$ 到 $B$ 的路径上，总长度都是最小的，为 $A,B$之间的距离。

现在加入了 $C$ 。相当于我们要让 $K$ 离 $C$ 尽量的近。

首先考虑 $K=LCA(A,B)$ 的情况。如果 $C$ 不在 $LCA(A,B)$ 的子树内，那 $K=LCA(A,B)$ 显然是离 $C$ 最近的。

如果 $C$ 在 $LCA(A,B)$ 的子树内，那就相当于要找 $A,B$ 路径上的一个点，使得它离 $C$ 最近。

显然，这个节点只可能是 $K=LCA(A,C)$ 或者 $K=LCA(B,C)$。

综上，我们只要判断 $LCA(A,B),LCA(A,C)$ 或者 $LCA(B,C)$ 的情况，就能考虑到所有情况并求出最优解。

---

## 作者：JasonZRY (赞：1)

## [博客食用效果更佳](https://www.cnblogs.com/gzezzry/p/12190196.html)

# LCA秒切

不会LCA的看我博客：[浅谈LCA](https://www.luogu.com.cn/blog/666Jason/qian-tan-lca)

这题不就是改成三个点的LCA吗？

首先求出三个点中两两的LCA，如果有两个LCA相等，那么三个点的LCA就是另外那对点的LCA

```
int fa1=lca(u,v),fa2=lca(v,w),fa3=lca(w,u);
if(fa1==fa2)printf("%d ",fa3);
if(fa2==fa3)printf("%d ",fa1);
if(fa3==fa1)printf("%d ",fa2);
```
最后三个点深度和减去三个LCA的深度和就是金币数

看着他这么水就马上把代码~~从我博客里弄下来改一改~~交上去

```
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int to,next;
}ed[100005];
int n,m,u,v,w,cnt,head[50005],dep[50005],f[50005][20];
void add(int u,int v){
	cnt++;
	ed[cnt].to=v;
	ed[cnt].next=head[u];
	head[u]=cnt;
}
void dfs(int u,int fa){
    f[u][0]=fa;
    dep[u]=dep[fa]+1;
    for(int i=1;i<20;i++)f[u][i]=f[f[u][i-1]][i-1];
    for(int i=head[u];i;i=ed[i].next){
    	int v=ed[i].to;
    	if(v!=fa)dfs(v,u);
	}
}
int lca(int u,int v){
    if(dep[u]<dep[v])swap(u,v);
    for(int i=19;i>=0;i--)if(dep[u]-(1<<i)>=dep[v])u=f[u][i];
    if(u==v)return u;
    for(int i=19;i>=0;i--)if(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i];
    return f[u][0];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++){
        scanf("%d%d",&u,&v);
        add(u,v),add(v,u);
    }
    dfs(1,0);
    for(int i=1;i<=m;i++){
    	scanf("%d%d%d",&u,&v,&w);
        int fa1=lca(u,v),fa2=lca(v,w),fa3=lca(w,u);
        if(fa1==fa2)printf("%d ",fa3);
        if(fa2==fa3)printf("%d ",fa1);
        if(fa3==fa1)printf("%d ",fa2);
        printf("%d\n",dep[u]+dep[v]+dep[w]-dep[fa1]-dep[fa2]-dep[fa3]);
	}
}
```
结果RE两个点

![](https://cdn.luogu.com.cn/upload/image_hosting/0uoxwfno.png)

忘改数组了

数组调大后就A了

---

## 作者：水库中的水库 (赞：1)

### 题目大意

给定一棵树，有三个点，求解一个点$u$令这三个点到$u$的距离最小

### 分析

首先我们已知对于任意两个点的最短距离肯定经过这两个点的$LCA$

那么对于三个点(假设这三个点为$x,y,z$，求解的答案为$u$)来说，有两种情况

- $x,y$在一个子树并且$x,y$的最近公共祖先$Anc$为这个子树的根，$z$与$Anc$不在一个子树上
  那么最后的答案肯定是$u=Anc$，因为此时保证了$x,y$距离最小，而如果$u!=Anc$答案肯定会比这个大
- $z$与$Anc$在一个子树上，但这种情况其实相当于$x,y,z$的顺序不同

所以算法可以很容易的得到:

- 首先求解$x,y$的$Anc$
- 计算$z$到$Anc$的距离统计答案
- 改变$x,y,z$的顺序重新计算

最后可能常数比较大因为这种方法最差有$6$个$log_2 n$，所以实际时间复杂度为$6nlog_2 n$

```cpp
/***************************************************************
	File name: G.cpp
	Author: ljfcnyali
	Create time: 2019年06月03日 星期一 12时05分45秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( register int i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 

const int maxn = 1100010;

int Begin[maxn], Next[maxn], To[maxn], e, p[20];
int dis[maxn], anc[maxn][20], n, m, ans, Anc, ans1;

inline void add(int u, int v)
{
	To[++ e] = v;
	Next[e] = Begin[u];
	Begin[u] = e;
}

inline void DFS(int u, int x)
{
	dis[u] = ++ x;
	for ( int i = Begin[u]; i; i = Next[i] )
	{
		int v = To[i]; if ( dis[v] ) continue ;
		anc[v][0] = u; DFS(v, x);
	}
}

inline int get_len(int x, int y)
{
	int sum = 0;
	if ( dis[x] < dis[y] ) swap(x, y);
	for ( int j = 19; j >= 0; -- j ) if ( dis[anc[x][j]] >= dis[y] ) { x = anc[x][j]; sum += p[j]; }
	if ( x == y ) { Anc = x; return sum; }
	for ( int j = 19; j >= 0; -- j )
		if ( anc[x][j] != anc[y][j] )
		{
			x = anc[x][j]; y = anc[y][j];
			sum += p[j + 1];
		}
	Anc = anc[x][0];
	return sum + 2;
}

inline void read(int &x)
{
	x = 0;
	char c = getchar(); 
	while ( c < '0' || c > '9' ) c = getchar();
	while ( c >= '0' && c <= '9' ) { x = x * 10 + c - '0'; c = getchar(); }
}

inline void print(int x)
{
	if ( x > 9 ) print(x / 10);
	putchar(x % 10 + '0');
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
	read(n); read(m);
	int u, v, a, b, c, sum, k;
	REP(i, 1, n - 1) { read(u); read(v); add(u, v); add(v, u); }
	DFS(1, 0);
	REP(j, 1, 19) REP(i, 1, n) anc[i][j] = anc[anc[i][j - 1]][j - 1];
	p[0] = 1; REP(i, 1, 19) p[i] = p[i - 1] * 2;
	REP(i, 1, m)
	{
		ans = 2147483647;
		read(a); read(b); read(c);

		sum = get_len(a, b); k = Anc; sum += get_len(k, c); 
		if ( sum < ans ) { ans = sum; ans1 = k; }

		sum = get_len(a, c); 
		if ( sum >= ans ) goto p1;
		k = Anc; sum += get_len(k, b); 
		if ( sum < ans ) { ans = sum; ans1 = k; }
p1: ;
		sum = get_len(b, c); 
		if ( sum >= ans ) goto p2;
		k = Anc; sum += get_len(k, a); 
		if ( sum < ans ) { ans = sum; ans1 = k; }
p2:;
   		print(ans1); putchar(' '); print(ans); putchar('\n');
//		printf("%d %d\n", ans1, ans);
	}
    return 0;
}
```



---

## 作者：zybnxy (赞：1)

简化版题目：

有一棵$N$个节点的树，和$Q$组询问

有三个人分别在点$x,y,z$现在希望你找到一个点，使得
三个人到这个点的距离和最小。

## 题目分析

首先，本题最大的难度就是求的是三条路径的最小值，而不是两个，如果是两个的话我们直接求书的路径上的点就行，即为求两点之间的$LCA$，但是如果问题为$3$的点就不同了，我们类比之前，可能会想到求出$3$个点的$LCA$，可是这样，明显是不对的，比如下边这幅图就是一个反例。

```
         ·A
        /  \
  	   /    \
      /      \
     .C        .B
    / \
   /   \
  .D    .E
```

若在此图中寻找一个点，使其到$B,E,F$之和最小，显然不是求三者$LCA-A$点,而是应当选$C$点，这样他们的值才能最小。

为什么这么说呢？可以把$B$翻转过来，然后就可以发现应该在他们的交点$C$上可以取到最小值。

这道题还有一个情况如下
```
         .A
        /
       /
      C.
     / \
    /   \
   .B    \
           D.
```

现在我们要求$B,C,D$的最短距离，我们怎么走。

这其实是最简单的一种模型。肯定是走在$B$时最短。

然后我们发现，无论这棵树有多么复杂，一共就这两种雏形的情况。


然后开始我们~~找规律~~时间

* $1$：我们发现，三个点两两之间的$LCA$一定有两个点相同

* $2$:如果只有两个点相同，那么聚集点就一定是剩下一个$LCA$

* $3$:如果$3$个点的$LCA$都相同，那么聚集点就是这个$LCA$

其实上述的推理得到的结论就是：找两两之间$LCA$深度最深的一个

于是这个问题就这样解决了，时间复杂度为$O(N$ $log$ $N)$

关于$LCA$,~~因为我太菜了~~，我用的是倍增求$LCA$。当然也可以用别的方法

参考代码如下
```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cctype>
#define N 500001
using namespace std;
int n,m,id[N],cnt,fa[N][21],p,deep[N],tmp;
int front[N],next[N*2],to[N*2],tot;
int lca1,lca2,lca3;
template<class T> inline void read(T &x)
{
    x=0;
    register char c=getchar();
    register bool f=0;
    while (!isdigit(c)) f ^=c=='-',c=getchar();
 	while (isdigit(c)) x=x*10+c-'0',c=getchar();
    if(f)x=-x;
}
template <class T> inline void print(T x)
{
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar('0'+x%10);
}
void add(int x,int y)
{
    to[++tot]=y; next[tot]=front[x]; front[x]=tot;
    to[++tot]=x; next[tot]=front[y]; front[y]=tot;
}
void dfs(int x)
{
    id[x]=++cnt;
    for(int i=front[x];i;i=next[i])
     if(to[i]!=fa[x][0]) 
     {
          fa[to[i]][0]=x;
          deep[to[i]]=deep[x]+1;
          dfs(to[i]);
     }
}
int lca(int x,int y)
{
    if(x==y) return x;
    if(id[x]<id[y]) swap(x,y);
    for(int i=p;i>=0;i--)
     if(id[fa[x][i]]>id[y])
      x=fa[x][i];
    return fa[x][0];
}
int dis(int x,int y)
{
    int lc=lca(x,y);
    return deep[x]+deep[y]-2*deep[lc];
}
int main()
{
    read(n);read(m);
    int x,y,z;
    for(int i=1;i<n;i++)
    {
        read(x);read(y);
        add(x,y);
    }
    dfs(1);
    p=log(n)/log(2)+1;
    for(int j=1;j<=p;j++)
     for(int i=1;i<=n;i++)
      fa[i][j]=fa[fa[i][j-1]][j-1];
    int ans1,ans2,tmp;
    while(m--)
    {
      	read(x);read(y);read(z);
        lca1=lca(x,y); lca2=lca(x,z); lca3=lca(y,z);
        ans1=lca1; ans2=dis(x,lca1)+dis(y,lca1)+dis(z,lca1);
        tmp=dis(x,lca2)+dis(y,lca2)+dis(z,lca2);
        if(tmp<ans2) 
        {
            ans2=tmp;
            ans1=lca2;
        }
        tmp=dis(x,lca3)+dis(y,lca3)+dis(z,lca3);
        if(tmp<ans2)
        {
            ans2=tmp;
            ans1=lca3;
        }
        printf("%d %d\n",ans1,ans2);
    }
}
```

---

## 作者：xiaolou (赞：1)

2325131433448687~

闲来无事水一发。。。

蒟蒻不会树剖，因为不是太监所以不想写太监。。。

所以只能写。。。

# 倍增！

处理最后的游戏币时有些恶心，卡了我一次。。。

code：
```cpp
#include <bits/stdc++.h>

using namespace std;
int n,m,k;
int d[500005];//depth数组，记录深度
int b[500005][25];//b[i][j]表示第i个点跳j次所到的点
int vis[500005];
struct Node
{
    int u,v;
    Node *next;
}*h[500005],pool[1000005];
int tot=0;
void adde(int u,int v)
{
    Node *p=&pool[++tot];
    p->v=v;
    p->next=h[u];
    h[u]=p;
}//建边，习惯建两次，省代码。。。
inline int read()
{
    int sum=0,fg=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-') 
            fg=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        sum=(sum*10)+c-'0';
        c=getchar();
    }
    return sum*fg;
}//同学的优秀快读，亲测LCA模板快了800ms
void dfs(int u)//dfs处理深度
{
    vis[u]=1;//u到过了，标记
    int v;
    for(int i=1;(1<<i)<=d[u];i++)
    {
    	b[u][i]=b[b[u][i-1]][i-1];
    }//对于所有的2^i<=d[u]，处理b[u][i]
    for(Node *p=h[u];p;p=p->next)
    {
        if(vis[v=p->v]==0)//如果还没到过v，即v不是u的父节点，很重要，否则死循环
        {
            d[v]=d[u]+1;//处理v的深度
            b[v][0]=u;//v向上跳2^0到u
            dfs(v);//搜索v 
        }
    }
}
int query_LCA(int u,int v)
{
    if(d[u]<d[v])
    {
        swap(u,v);//交换，使u比v深（好写。。。）
    }
    if(d[u]!=d[v])
    {
    	for(int i=19;i>=0;i--)
    	{
    	    if(d[b[u][i]]>=d[v])
    	    {
    	        u=b[u][i];//先让它们调到同一层
    	    }
    	}
    }
    if(u==v)
        return u;
    for(int i=19;i>=0;i--)
    {
        if(b[u][i]!=b[v][i])        {

            u=b[u][i];
            v=b[v][i];//如果还不一样，一起向上跳
        }
    }
    return b[u][0];//最后返回它们的LCA
}
int cal(int u,int v)
{
    int lca=query_LCA(u,v);
    return d[u]+d[v]-2*d[lca];//用于求距离
}

int main()
{
    n=read();
    m=read();
    for(int i=1;i<n;i++)
    {
        int x,y;
        x=read();
        y=read();
        adde(x,y);
        adde(y,x);
    }
    dfs(1);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        int p;
        scanf("%d%d%d",&x,&y,&z);
        int la=query_LCA(x,y);
        int lb=query_LCA(y,z);
        int lc=query_LCA(z,x);//求出三个LCA
        if(la==lb)
        {
            p=lc;
        }
        if(lb==lc)
        {
            p=la;
        }
        if(lc==la)
        {
            p=lb;//不同的那个LCA一定是最优的，不要问为什么。。。
        }
        int ans=d[x]+d[y]+d[z]-d[la]-d[lb]-d[lc];//用一个类似查分的东西计算答案
        printf("%d %d\n",p,ans);
    }
    return 0;
}
```
232513143344~

---

## 作者：Unordered_OIer (赞：1)

# P4281 题解
## 题目大意
求三个点的$lca$与三个点到$lca$的距离之和。
> $lca\ :\ lowest\ common\ ancestor$，中文名：最近公共祖先。

## 解题
这个问题的核心就是求两点之间的$lca$，距离其实很好解决，用深度的加减法就可以求出。

这里给出$lca$的两种求法：  
### $1.$朴素求法  
就是两个点不停的爬树，爬到同一高度然后一起找爸爸。代码很好写：
```cpp
int lca(int u,int v) {
// lowest common ancestor 
    while (d[u]>d[v]) u=fa[u];
    // 当深度不相同时，让深度深的先爬树
    while (d[u]<d[v]) v=fa[v];
    // 当深度不相同时，让深度深的先爬树
    while (u!=v) u=fa[u],v=fa[v];
    // 深度相同时，同步爬树，寻找公共点
    return u;
    // 这里无论return u 还是 return v 都可以
}
```
### $2.$高级一些的求法
第一种方法，每次只爬一层，但是如果树很高并且问题很多，这种方法就会超时。那么我们可以用**倍增**的思想优化一下。原先的$fa$数组只记录向上一级父亲，那么我们新开一维：  

$fa_{u,k}$表示节点$u$的$\color{red}{2^k}$级父亲。  

那么我们爬树的复杂度就可以从$O(n)$优化到$O(\log n)$啦！

代码：
```cpp
ll lca(ll x,ll y){
    if (dep[x]<dep[y]) swap(x,y); // 先后不影响答案
    ll dt=dep[x]-dep[y];
    for (ll i=0;i<=H;i++)
        if ((1<<i)&dt) x=fa[x][i]; // 深的爬树
    for (ll i=H;i>=0;i--)
        if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; // 共同爬树
    return x==y?x:fa[x][0];
}
```
###### PS：据说还有一种线性的$tarjan$求$lca$的，蒟蒻不会orz

好的，会求$lca$了，那么我们怎么使用才能解决这题呢？

题意：求三个点的$lca$和距离总和。  
距离总和就是$d_a+d_b+d_c-d_{lca(x,y)}-d_{lca(y,z)}-d_{lca(x,z)}$

**那么问题来了，三个点的$lca$怎么求？**  
首先，三个点之间肯定要两两算$lca$，这点显然。  
其次，**有两个$lca$一样的话，那么另一个$lca$就是最优解**（ 一个远，两个近 / 一个进，两个远 ；很好看出来一定是 一个远，两个近 比较划算吧）

那么代码就很好写了：
```cpp
int room1=lca(x,y),room2=lca(y,z),room3=lca(x,z);
if(room1==room2)room=room3;
else if(room2==room3)room=room1;
else room=room2;
ans=dep[x]+dep[y]+dep[z]-dep[room1]-dep[room2]-dep[room3];
printf...
```
over~

---

## 作者：xukuan (赞：1)

LCA+倍增

这题与普通的LCA相比，难度不在怎么求LCA，而在于如何判断

这题对三个点中的两个求LCA，集合点肯定是三个最大公共祖先中的一个，但是，哪个是？

想了很久都没有想法，最后————

穷举不就行了？

分别计算到每一个公共祖先的距离，再比较

代码：
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define INF 214748364
using namespace std;

const int TOP=500010,LOG=20;

int n,m,d[TOP],p[TOP][LOG+5];
vector<int> q[TOP];

void dfs(int m,int before){//算出每一个点的深度和祖先
    d[m]=d[before]+1;
    p[m][0]=before;
    for(int i=1; (1<<i)<=d[m]; i++) p[m][i]=p[p[m][i-1]][i-1];
    
    for(int i=0; i<q[m].size(); i++){
        int Next=q[m][i];
        if(Next!=before) dfs(Next,m);
    }
}

inline int LCA(int x,int y){//求两个点的LCA
    if(d[x]>d[y]) swap(x,y);
    for(int i=LOG; i>=0; i--){
        if(d[x]<=d[y]-(1<<i)) y=p[y][i];
    }
    
    if(x!=y){
        for(int i=LOG; i>=0; i--){
            if(p[x][i]==p[y][i]) continue;
            else{
                x=p[x][i];
                y=p[y][i];
            }
        }
        return p[x][0];
    }
    return x;
}

inline int juli(int a,int x){//求两个点之间的距离
	int b=LCA(a,x);
	return d[a]+d[x]-2*d[b];
}

inline int work(int a,int x,int y,int z){//求x,y,z三个点到a点的长度之和
	return juli(a,x)+juli(a,y)+juli(a,z);
}

int main(){
    scanf("%d %d",&n,&m);
    for(int i=1; i<n; i++){
        int x,y,z;
        scanf("%d %d",&x,&y);
        q[x].push_back(y);
        q[y].push_back(x);
    }
    dfs(1,0);
    
    while(m--){
        int x,y,z;
        scanf("%d %d %d",&x,&y,&z);
        int a=LCA(x,y),b=LCA(x,z),c=LCA(y,z);
        int Minn=INF,Mins;
        if(work(a,x,y,z)<Minn){//假设a是集合点
        	Minn=work(a,x,y,z);
        	Mins=a;
		}
        if(work(b,x,y,z)<Minn){//假设b是集合点
        	Minn=work(b,x,y,z);
        	Mins=b;
		}
        if(work(c,x,y,z)<Minn){//假设c是集合点
        	Minn=work(c,x,y,z);
        	Mins=c;
		}
		printf("%d %d\n",Mins,Minn);
    }
    return 0;
}
```

---

## 作者：king_xbz (赞：0)

看到题解里面的大佬都用树链剖分做这道题，而萌新蒟蒻并不会使用树剖。于是我便用倍增水过了这道题。

先来简单介绍了解倍增
-
- 何为倍增

倍增，意思是成倍的增加增长；成倍地增长————《百度百科》

倍增，其实就是按2的倍数来往上跳，也就是跳 1,2,4,8,16,32……

试想一下，假如我们模拟求最近公共祖先，在树中一层一层的跳，那么最终的结果只会惨烈的TLE

而我们按照2的倍数往上增来取代每次增1，这样时间空间上都有非常显著的优化。

相信大家可以理解。

- 如何实现倍增

那么就拿最基础的模板题来举例子[链接点我](https://www.luogu.com.cn/problem/P3379)

1）我们需要先进行预处理。

我们用二位数组f[][]来表示倍增级，其中第一维无需太大，只要20即可(2^20已经足够大了)；

用一维数组dis[]表示深度。

记得用链式前向星存图。（邻接矩阵会T到没边）
```cpp
inline void adds(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
//链式前向星存图
inline void dfs(int u,int dep)
{
	f[0][u]=dep;
	dis[u]=dis[dep]+1;
    //更新dis与f数组
	for(int i=1;i<20;i++)
	f[i][u]=f[i-1][f[i-1][u]];
   //继续更新
	for(fint i=head[u];i;i=e[i].next)
	if(e[i].to!=dep)
	dfs(e[i].to,u);//接着搜，此时u变为深度，搜下一个节点
	return ;
}
//用dfs处理深度
```
2）接下来我们开始求最近公共祖先！

首先我们要让两点到同一高度，然后一起跳（比翼齐飞）
```cpp
inline int lca(int x,int y)
{
	if(dis[x]<dis[y])
	swap(x,y);
    //保证x的深度 >= y的深度
	for(fint i=20;i>=0;i--)
	if(dis[y]<=dis[x]-(1<<i))//常数优化，(1<<i)=>2^i;
	x=f[i][x];
   //往同一深度跳
	if(x==y)
	return x;
    //如果x是y的祖先，那他们的最近公共祖先肯定就是x了
	for(fint i=20;i>=0;i--)
	if(f[i][x]!=f[i][y])
	x=f[i][x],y=f[i][y];
    //如果不相等就往下跳
	return f[0][x];
}
```
3）那么倍增的模板就结束了。

言归正传，回到这道题
-
我们已经掌握了这道题的算法了，那么接下来就可以做题了。

这题需要求三个节点的LCA，我们只要两两求出然后判断即可
```cpp
   int a=lca(x,y);
	int b=lca(y,z);
	int c=lca(z,x);两两求出
	if(a==b)
	printf("%d ",c);
	else
	if(b==c)
	printf("%d ",a);
	else
	if(c==a)
	printf("%d ",b);//求异存同
    //ps：用cout有超时的风险
 ```
 然后计算花费我们只需要简单的树上差分即可。
 ```cpp
 printf("%d\n",dis[x]+dis[y]+dis[z]-dis[a]-dis[b]-dis[c]);
 ```
 - 最后友情提示一下数据范围，别把数组开小了（70分），也别把二维数组开炸了（0分）
 
 那么这道题就差不多了，最后上完整无注释代码：
[[云剪切板]AHOI2008紧急集合](https://www.luogu.com.cn/paste/gi1286tw)

祝大家AC愉快，这次优化了排版布局，显得不那么冗杂，希望管理大大给过（看在人家这么用心的份上）！

---

## 作者：Mr_Leceue (赞：0)

这道题它数据500000，还毒瘤的三点查询，可以说是真的卡数据；



------------


但是呢，刚学lca的我正好get到了
# 倍增

和 
# Tarjan离线查询
的强~~（du）~~势~~（liu）~~，所以先用了Tarjan，然后被卡了（不能用O2）（之后再分析为什么会卡），用了倍增才过，根据题目，我们可以很容易地想到用lca来解决这个树上两点之间距离。然后我看了一下各位大佬的题解，树的剖分应该是正解吧（可惜我今天刚学，不太熟练 QAQ ）；

我们先看一下题目，是三个点到一个点的距离之和最小，图大家可以手模一下，其他各位大佬也讲过，我们设题中给的三个点为x,y,z,每两个点的lca是a,b,c.
距离前缀和数组设为dep[i];

那么开始推导：肯定有两个lca是相同的，这个可以手动证明一下，这里就不再证明了，所以暂设  _a==c=true_  ,那么， _dep[x]+dep[y]-2*dep[a]+dep[z]-dep[b]+dep[a]-dep[b]==_dep[x]+dep[y]+dep[z]-2*dep[a]-dep[b]_ _  ，然后大家应该就能懂了QAQ，之后还有通用公式  _dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]_ ,只要再找到a,b,c中谁与其它两个不同即可；

然后附上AC Code

# Code
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int n,m,head[500007],cent,dep[500007],fa[500007][30],len[500007];
struct node{
	int next,to,w;
}edge[1000007];

void add(int u,int v,int w){
	edge[++cent]=(node){head[u],v,w};head[u]=cent;
}

void dfs(int x,int dy){
	dep[x]=dy;
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].to;
		if(y==fa[x][0]) continue;
		fa[y][0]=x;
		len[y]=len[x]+edge[i].w;
		dfs(y,dy+1);
	}
	return ;
}

void Init(){
	fa[1][0]=-1;
	dfs(1,0);
	for(int i=1;1<<i<n;i++){
		for(int j=1;j<=n;j++){
			if(fa[j][i-1]<0) fa[j][i]=-1;
			else fa[j][i]=fa[fa[j][i-1]][i-1];
		}
	}
	return ;
}

int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=0,d=dep[x]-dep[y];d;d>>=1,i++){
		if(d&1) x=fa[x][i];
	}
	if(x==y) return x;
	for(int i=log(n)+1;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}

void work(int a,int b,int c){
	int x=lca(a,b),y=lca(b,c),z=lca(a,c),exit;
	if(x==y) exit=z;
	else if(y==z) exit=x;
	else if(x==z) exit=y;
	printf("%d %d\n",exit,dep[a]+dep[b]+dep[c]-dep[x]-dep[y]-dep[z]);
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,a,b;i<=n-1;i++){
		scanf("%d%d",&a,&b);
		add(a,b,1),add(b,a,1);
	}
	Init();
	for(int i=1,a,b,c;i<=m;i++){
		scanf("%d%d%d",&a,&b,&c);
		work(a,b,c);
	}
	return 0;
}
```

这里面将len改为了前缀和而dep为深度。

然后蒟蒻的附上Tarjan代码（T了两个QWQ）（不要开O2）

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int n,m,head[500007],cent,cnt,h[500007],dep[500007],vis[500007];
int fa[500007],f[2000007],see[500007][3],num[500007];
struct node{
	int next,to,w;
}edge[1000007];
struct node1{
	int next,to,id;
}e[3000007];

template<typename type_of_scan>
inline void scan(type_of_scan &x){
	type_of_scan f=1;x=0;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}

inline void add(int u,int v,int w){
	edge[++cent]=(node){head[u],v,w};head[u]=cent;
}

inline void add1(int u,int v,int name){
	e[++cnt]=(node1){h[u],v,name};h[u]=cnt;
}

inline int get(int x){
	if(fa[x]==x) return x;
	return fa[x]=get(fa[x]);
}

inline void Tarjan(int u){
	vis[u]=1;
	for(register int i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(vis[v]) continue;
		dep[v]=dep[u]+edge[i].w;
		Tarjan(v);
		fa[v]=u;
	}
	for(register int i=h[u];i;i=e[i].next){
		int v=e[i].to;
		if(vis[v]&&!f[e[i].id]){
			int zz=get(v),x=e[i].id;
			f[x]=zz;
		}
	}
}

inline void work(){
	for(register int i=1;i<=3*m;i+=3){
		int x=see[i][0],y=see[i][1],z=see[i][2];
		int a=f[i],b=f[i+1],c=f[i+2];
		if(a==b){
			printf("%d %d\n",c,dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]);
		}else if(b==c) {
			printf("%d %d\n",a,dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]);
		}else if(a==c) {
			printf("%d %d\n",b,dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]);
		}
		
	}
}

int main(){
	scan(n),scan(m);
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1,a,b;i<=n-1;i++){
		scan(a),scan(b);
		add(a,b,1),add(b,a,1);
	}
	for(register int i=1;i<=3*m;i+=3){
		int a,b,c;
		scan(a),scan(b),scan(c);
		see[i][0]=a,see[i][1]=b,see[i][2]=c;
		add1(a,b,i),add1(b,a,i),add1(a,c,i+1);
		add1(c,a,i+1),add1(c,b,i+2),add1(b,c,i+2);
	}
	Tarjan(1);
	work();
	return 0;
}
```

至于为什么Tarjan没过而倍增过了，是因为我们统计倍增O（nlongn+mlongn），而实际上，大部分数据查询是不需要logn的，所以就将倍增算法捧上了天，而作为O（n+m）算法的Tarjan却栽了是因为并查集维护时，时间复杂度最坏达到了近O（n2+m），但是O(1)查询的Tarjan在一些数据确实比倍增算法快，但是，在一些非常诡异的数据中，还是用倍增比较妥当，（听说有人倍增凉凉，可能有点玄学的味道吧~~（可以看看还能优化吗QAQ）~~）

这道题真的卡我很久，所以特写这篇题解记录一下（还是我太弱了）；

恳请各位dalao提出建议

---

## 作者：远山淡影 (赞：0)

## 每两个点的lca取最高那个，用层数代替距离，三点层数和-三lca层数和(因为两人同时走一条路只花一人的钱)
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
int root;
struct node
{
	int x,y,next;
}a[2100000];int len,last[2100000];
struct trnode
{
	int dep,par[20];
}t[2100000];
void ins(int x,int y)
{
	len++;a[len].x=x;a[len].y=y;
	a[len].next=last[x];last[x]=len;
}
void dfs(int x,int fa)
{
	t[x].dep=t[fa].dep+1;
	t[x].par[0]=fa;
	for(int i=1;(1<<i)<=t[x].dep;i++)
		t[x].par[i]=t[t[x].par[i-1]].par[i-1];
	for(int k=last[x];k;k=a[k].next)
	{
		int y=a[k].y;
		if(y!=fa)
		{
			dfs(y,x);
		}
	}
}
int lca(int x,int y)
{
	if(t[x].dep<t[y].dep) swap(x,y);
	for(int i=18;i>=0;i--)
		if(t[x].dep-t[y].dep>=(1<<i))
			x=t[x].par[i];
	if(x==y) return x;
	for(int i=18;i>=0;i--)
	{
		if(t[x].dep>=(1<<i) && t[x].par[i]!=t[y].par[i])
		{
			x=t[x].par[i];
			y=t[y].par[i];
		}
	}
	return t[x].par[0];
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	len=0;memset(last,0,sizeof(last));
	for(int i=1;i<n;i++)
	{
		int x,y;scanf("%d%d",&x,&y);
		ins(x,y);
		ins(y,x);
	}
	dfs(1,0);
	int ans;
	while(m--)
	{
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		int k1=lca(x,y),k2=lca(x,z),k3=lca(y,z);
		if(t[k1].dep>t[k2].dep) ans=k1;
		else ans=k2;
		if(t[k3].dep>t[ans].dep) ans=k3;
		printf("%d %d\n",ans,t[x].dep+t[y].dep+t[z].dep-t[k1].dep-t[k2].dep-t[k3].dep);
	}
	return 0;
}
```

---


# [HAOI2008] 玩具取名

## 题目描述

某人有一套玩具，并想法给玩具命名。首先他选择 `W, I, N, G` 四个字母中的任意一个字母作为玩具的基本名字。然后他会根据自己的喜好，将名字中任意一个字母用 `W, I, N, G` 中任意两个字母代替，使得自己的名字能够扩充得很长。

现在，他想请你猜猜某一个很长的名字，最初可能是由哪几个字母变形过来的。

## 说明/提示

### 数据规模与约定

- $30\%$ 数据满足 $L \leq 20$，$W, I, N, G \leq 6$；
- $100\%$ 数据满足 $L \leq 200$，$W, I, N, G \leq 16$。

## 样例 #1

### 输入

```
1 1 1 1
II
WW
WW
IG
IIII
```

### 输出

```
IN
```

# 题解

## 作者：狄凡人 (赞：91)

## 第一篇题解，望各位大佬支持，谢谢
首先面对这道题，我的第一个困难是怎么读入数据QWQ
首先说明一下变量的含义：
```cpp
bool dp[maxn][maxn][5],can[5][5][5];//f[i j k]表示区间 i,j由 k转化.can[ i j k]表示i可以由j、k转化
int q[5],len=0;//q是每个字母转化成几对字母
char s[maxn];//原名字
int change(char i)//把字母转化成数字
{  
    if(i=='W') return 1; 
    if(i=='I') return 2;
    if(i=='N') return 3; 
    if(i=='G') return 4; 
} 
```

再同学们的帮助下，历经了两天晚自习，我成功的读入了数据
```cpp
int main() {
    for(int i=1;i<=4;i++) scanf("%d",&q[i]);//有几对字母可以转化
    for(int i=1;i<=4;i++) 
	{
        for(int j=1;j<=q[i];j++) 
		{
            scanf("%s",&c);//直接读到空格或者回车结束
            can[i][change(c[0])][change(c[1])]=true;//第一个字母可以由二、三个转化过来
        }
    }
    
    scanf("%s",s+1); //从s+1开始读入
    for(len=1;s[len];len++);//只要没结束，就继续读
    len--;//会多一个，所以--
```
接下来才是解读：
这是一道标准的区间DP，原因很简单，要把它分区间求解，并且之前处理的结果会对之后产生影响，具体问题见注释
```cpp
for(int i=1;i<=len;i++) dp[i][i][change(s[i])]=true;//从i到i可以由他自己转化
    
    for(int led=1;led<len;led++)//列举长度的可能性
        for(int l=1;l<=len-led;l++)//列举左界的可能性 
		{
            int r=l+led;//右界可以算出来
            for(int k=l;k<r;k++) //在左右之间列举可能的断点 
                for(int z=1;z<=4;z++)  //列举l到r（需要的区间）可能转化成的字母
                    for(int z1=1;z1<=4;z1++) // 列举l到k（借助的左区间）
                        for(int z2=1;z2<=4;z2++)  //列举k + 1到r（借助的右区间）
                            if(can[z][z1][z2] && dp[l][k][z1] && dp[k+1][r][z2]) 
//如果z1、z2可以转化成z 并且 l到k可以变成z1 并且k+1到r可以变成z2
                                dp[l][r][z]=true;
//那么l到r就可以转化成z
        }
```
整个dp过程大概可以理解为
| 121...233 | + | 232...343 |
| :----------: | :----------: | :----------: |
| 可以由1转化 |  | 可以由2转化 |
并且1 2 可以转化成2
那么
| 121....233232...343 |
| :----------: |
| 可以由2转化 |

输出也很简单，只需要查询1~len可不可以被四个字母取代
```cpp
bool f=false;
    if(dp[1][len][1]) {f=true;printf("W");}
    if(dp[1][len][2]) {f=true;printf("I");}
    if(dp[1][len][3]) {f=true;printf("N");}
    if(dp[1][len][4]) {f=true;printf("G");}
    if(!f) printf("The name is wrong!");
```


那么... 附AC代码，如有意见欢迎私信本蒟蒻
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn =210;
bool dp[maxn][maxn][5],can[5][5][5];//f[i j k]表示区间 i,j由 k转化.
int q[5],len=0;
char s[maxn];
int change(char i){  
    if(i=='W') return 1; 
    if(i=='I') return 2;
    if(i=='N') return 3; 
    if(i=='G') return 4; 
} 
int main() {
    for(int i=1;i<=4;i++) scanf("%d",&q[i]);
    for(int i=1;i<=4;i++) 
	{
        for(int j=1;j<=q[i];j++) 
		{
            scanf("%s",&c);
            can[i][change(c[0])][change(c[1])]=true;
        }
    }
    
    scanf("%s",s+1); 
    for(len=1;s[len];len++);
    len--;
    for(int i=1;i<=len;i++) dp[i][i][change(s[i])]=true;
    
    for(int led=1;led<len;led++)//列举长度 
        for(int l=1;l<=len-led;l++)//列举左界 
		{
            int r=l+led;
            for(int k=l;k<r;k++) //列举断点 
                for(int z=1;z<=4;z++)  //列举l到r
                    for(int z1=1;z1<=4;z1++) // 列举l到k
                        for(int z2=1;z2<=4;z2++)  //列举k + 1到r
                            if(can[z][z1][z2] && dp[l][k][z1] && dp[k+1][r][z2]) 
                                dp[l][r][z]=true;
        }
    bool f=false;
    if(dp[1][len][1]) {f=true;printf("W");}
    if(dp[1][len][2]) {f=true;printf("I");}
    if(dp[1][len][3]) {f=true;printf("N");}
    if(dp[1][len][4]) {f=true;printf("G");}
    if(!f) printf("The name is wrong!");
    return 0;
}
```


---

## 作者：yu__xuan (赞：66)

### 题目
[P4290 [HAOI2008]玩具取名](https://www.luogu.com.cn/problem/P4290)

### 思路
区间 $dp$。首先分别用 $1,2,3,4$ 表示 $W,I,N,G$。

$ok[i][j][k]$ 表示 $(i,j)$ 能不能用来代替 $k$（这个数组可以根据给的输入处理出来）。

$dp[i][j][k]$ 表示 $[i,j]$这一段区间能不能用来代替 $k$。大的区间可以用小的区间转移，状态转移方程如下：

`dp[i][j][k] = (dp[i][k][x] && dp[k + 1][j][y] && ok[x][y][k])`

意思是当 $[i,k]$ 这个区间可以用 $x$ 来代替并且 $[k + 1, j]$ 这个区间可以用 $y$ 来代替，那么 $[i,j]$ 这个区间就可以看成是 $xy$ 如果 $xy$ 可以用 $k$ 代替，那么 $[i,j]$就可以用 $k$ 来代替。

### Code
```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <algorithm>

char sss[201];
int m[618], s[5];
bool ok[5][5][5], f[201][201][5], flag;

int main() {
    m['W'] = 1, m['I'] = 2, m['N'] = 3, m['G'] = 4; 
    for (int i = 1; i <= 4; ++i) scanf("%d", &s[i]);
    for (int i = 1; i <= 4; ++i) {
        for (int j = 1; j <= s[i]; ++j) {
            char a, b;
            std::cin >> a >> b;
            ok[m[a]][m[b]][i] = 1;
        }
    }
    std::cin >> sss;
    int n = strlen(sss);
    for (int i = 1; i <= n; ++i) {
        f[i][i][m[sss[i - 1]]] = 1;
    }
    for (int l = 2; l <= n; ++l) {
        for (int i = 1; i <= n - l + 1; ++i) {
            int j = i + l - 1;
            for (int k = i; k < j; ++k) {
                for (int x = 1; x <= 4; ++x) {
                    for (int y = 1; y <= 4; ++y) {
                        for (int z = 1; z <= 4; ++z) {
                            if (f[i][k][y] && f[k + 1][j][z] && ok[y][z][x]) {
                                f[i][j][x] = 1;
                            }
                        }
                    }
                }
            }
        }
    }
    if (f[1][n][1]) flag = 1, printf("%c", 'W');
    if (f[1][n][2]) flag = 1, printf("%c", 'I');
    if (f[1][n][3]) flag = 1, printf("%c", 'N');
    if (f[1][n][4]) flag = 1, printf("%c", 'G');
    if (!flag) puts("The name is wrong!");
    return 0;
}
```

---

## 作者：Akoasm (赞：40)

题目大意：某人有一套玩具，并想法给玩具命名。首先他选择WING四个字母中的任意一个字母作为玩具的基本名字。然后他会根据自己的喜好，将名字中任意一个字母用“WING”中任意两个字母代替，使得自己的名字能够扩充得很长。

现在，他想请你猜猜某一个很长的名字，最初可能是由哪几个字母变形过来的。

对于这个题，发现你要是想维护到所有的情况，就必须每次以两个字符为一个块来统计，那样就会发现十分的麻烦，于是我们就可以想出做法：DP。

这个题并不是一般的dp，一般来说都只会让你统计最优结构，但这个题只需要通过状态转移来将一个大长串变成一个字符即可。

题目小技巧：可以将“WING”这四个字母转成数字计算，要不处理太麻烦。

定义数组：
rp[l][r][i],表示能否将数字l和数字r压缩成数字i（实际上是字符）

res[l][r][i] 表示对于区间l,r,能否转成数字i。

Code:（丑）
```cpp
#include<bits/stdc++.h>
using namespace std;

inline int rep(char ch){
	if(ch=='W') return 1;
	if(ch=='I') return 2;
	if(ch=='N') return 3;
	if(ch=='G') return 4;
}
int rp[5][5][5];
int a[340];
bool res[300][300][5];
inline void do_something(int l,int r,int li,int ri){
	for(int i=1;i<=4;i++){
		if(rp[li][ri][i]) res[l][r][i]=1;
	}
}

inline void do_rf_search(int l,int r){
	if(res[l][r][0]) return;res[l][r][0]=1;
	if(l==r){
		res[l][r][a[l]]=1;
		return;
	} 
	bool lii,rii;
	for(int i=l;i<r;i++){
		do_rf_search(l,i);
		do_rf_search(i+1,r);
		for(int li=1,bl=res[l][i][li];li<=4;li++,bl=res[l][i][li]){
			for(int ri=1,fl=res[i+1][r][ri];ri<=4;ri++,fl=res[i+1][r][ri]){
				if(bl&&fl)
				{
					do_something(l,r,li,ri);
				}
			}
		}
	}
}

int main()
{
	char p,b;
	int a1,a2;
	int num[5];
	cin>>num[1]>>num[2]>>num[3]>>num[4];
	for(int i=1;i<=4;i++){
		for(int j=1;j<=num[i];j++){
		//	p=getchar(),b=getchar();
		cin>>p>>b;
			a1=rep(p);a2=rep(b);
			//cout<<p<<' '<<b<<endl; 
			rp[a1][a2][i]=1;
		}
	}
	string str;
	//cout<<"OPPPP"<<endl;
	cin>>str;
	int n=str.length();
	//cout<<n<<endl;
	for(int i=0;i<n;i++){
		a[i]=rep(str[i]);
	}
	bool fg=false;
	string str2=" WING";
	do_rf_search(0,n-1);
	//cout<<res[0][n-1][1]<<endl;
	for(int i=1;i<=4;i++){
		if(res[0][n-1][i]) fg=1,cout<<str2[i];
	}
	if(!fg) cout<<"The name is wrong!"<<endl;
	return 0;
	
}
```

---

## 作者：览遍千秋 (赞：22)

### Update Log

- 2025-02-10：修改题解格式与代码，使得其符合现行题解标准，并自己审核通过。

---

这是一道区间动规题。

考虑将字母抽象为数值，即 ``WING`` 分别对应 $1,2,3,4$。

用 $ok[a][b][c]$ 表示第 $c$ 个字母是否可以变成第 $a$ 个字母和第 $b$ 个字母的组合。

设 $dp[l][r][c]$ 表示区间 $[l,r]$ 能否最终变成第 $c$ 个字母。

在区间动态规划中，通常将区间长度作为动态规划的阶段。即，通常先完成小区间答案的计算，再以此来计算大区间的答案。

字符串的当度为 $L$，从小到大枚举区间长度 $len$ 与区间左端点 $l$，可以计算出区间右端点 $r=l+len-1$。

区间 $[l,r]$ 可以由其中的两个子区间转化而来。枚举 $k(l \le k < r)$，将区间 $[l,r]$ 切分为区间 $[l,k],[k+1,r]$。

当存在一个 $k$ 满足 $\begin{cases}dp[l][k][a] \text{ is true}\\ dp[k+1][r][b] \text{ is true} \\ ok[a][b][c] \text{ is true}\end{cases}$ 时，$dp[l][r][c]$ 为 `true`。其中，$1 \le a,b,c \le 4$，需要枚举。


```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 200 + 7;

bool dp[MAXN][MAXN][5], ok[5][5][5];
int W, I, N, G, L;
int num[MAXN];
string S;

int char2int(char c) {
    switch(c) {
        case 'W': return 1;
        case 'I': return 2;
        case 'N': return 3;
        case 'G': return 4;
    }
    return 0;
}

void record(char a, char b, int type) {
    int aid = char2int(a), bid = char2int(b);
    ok[aid][bid][type]=1;
}

int main() {
    cin >> W >> I >> N >> G;
    for(int i = 1; i <= W; i++) {
        char a, b;
        cin >> a >> b;
        record(a, b, 1);
    }
    for(int i = 1; i <= I; i++) {
        char a, b;
        cin >> a >> b;
        record(a, b, 2);
    }
    for(int i = 1; i <= N; i++) {
        char a, b;
        cin >> a >> b;
        record(a, b, 3);
    }
    for(int i = 1; i <= G; i++) {
        char a, b;
        cin >> a >> b;
        record(a, b, 4);
    }
    cin >> S; L = (int)S.size();
    for(int i = 0; i < L; i++) {
        num[i + 1] = char2int(S[i]);
    }
    for(int i = 1; i <= L; i++) {
        dp[i][i][num[i]] = 1;
    }

    for(int len = 2; len <= L; len++) {
        for(int l = 1; l + len - 1 <= L; l++) {
            int r = l + len - 1;
            for(int k = l; k < r; k++) {
                for(int a = 1; a <= 4; a++) {
                    if(!dp[l][k][a]) continue;
                    for(int b = 1; b <= 4; b++) {
                        if(!dp[k + 1][r][b]) continue;
                        for(int c = 1; c <= 4; c++) {
                            if(ok[a][b][c] && dp[l][k][a] && dp[k + 1][r][b]) {
                                dp[l][r][c] = true;
                            }
                        }
                    }
                }
            }
        }
    }

    bool flag = false;

    if(dp[1][L][1]) printf("W"), flag = true;
    if(dp[1][L][2]) printf("I"), flag = true;
    if(dp[1][L][3]) printf("N"), flag = true;
    if(dp[1][L][4]) printf("G"), flag = true;
    if(flag)
        printf("\n");
    else
        printf("The name is wrong!\n");
    return 0;
}
```

---

## 作者：IRipple (赞：7)

贴一发记忆化搜索

和dp一样我们需要把WING映射为数字，同理把数字映射成WING。

数组d表示区间$i-j$的可以合成为k。

~~和dp思路其实差不多,可以参考楼上上~~

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define N 205
using namespace std;
int num[5],map[300],len;
char a[5][20][3],s[220],anti_map[5]={' ','W','I','N','G'};
int d[N][N][27];
int dfs(int l,int r,int k){
    int &ans=d[l][r][k];
    if(ans!=-1) return ans;
    if(l==r) return s[l]==anti_map[k];
    ans=0;
    for(int i=l;i<=r-1;i++){
        for(int j=1;j<=num[k];j++){
            if(dfs(l,i,map[a[k][j][1]]) && dfs(i+1,r,map[a[k][j][2]])) return ans=1;
        }
    }
    return 0;
}
int main(){
    for(int i=1;i<=4;i++) cin>>num[i];
    for(int i=1;i<=4;i++){
        for(int j=1;j<=num[i];j++){
            scanf("%s",a[i][j]+1);
        }
    }
    scanf("%s",s+1);
    len=strlen(s+1);
    memset(d,-1,sizeof(d));
    map['W']=1;
    map['I']=2;
    map['N']=3;
    map['G']=4;
    bool kkk=0;
    for(int i=1;i<=4;i++){
        if(dfs(1,len,i)) cout<<anti_map[i],kkk=1;
    }
    if(!kkk) cout<<"The name is wrong!";
    return 0;
}
```

---

## 作者：Fairicle (赞：5)

好像是套路题诶...

显然不能枚举每两个字母那样会爆炸，看到数据范围于是考虑区间 DP。

不妨设 $f_{i,j,k}$ 表示区间 $[i,j]$ 是否能通过字母 $k$ 转化而来。

那么对于一组条件 $(a,b,c)$（$a$ 表示原字母， $b,c$ 表示转化后的两个字母），有 

$f_{i,j,a}=(f_{i,j,a}\ or \ (f_{i,k,b} \ and \ f_{k+1,j,c}))(k\in[i,j))$

就可以区间 DP 解决了。

```cpp
#include"bits/stdc++.h"
using namespace std;
#define ri register int
#define ll long long
#define N 210
int W,X,Y,Z,f[210][210][80],l[80][3],tot;
char ch[210];
inline int chk(char s){
    if(s=='W') return 1;
    if(s=='I') return 2;
    if(s=='N') return 3;
    if(s=='G') return 4;
}
int main(){
    scanf("%d%d%d%d",&W,&X,&Y,&Z);
    for(ri i=1;i<=W;++i){
        scanf("%s",ch+1);
        l[++tot][0]=1;
        l[tot][1]=chk(ch[1]);
        l[tot][2]=chk(ch[2]);
    }
    for(ri i=1;i<=X;++i){
        scanf("%s",ch+1);
        l[++tot][0]=2;
        l[tot][1]=chk(ch[1]);
        l[tot][2]=chk(ch[2]);
    }
    for(ri i=1;i<=Y;++i){
        scanf("%s",ch+1);
        l[++tot][0]=3;
        l[tot][1]=chk(ch[1]);
        l[tot][2]=chk(ch[2]);
    }
    for(ri i=1;i<=Z;++i){
        scanf("%s",ch+1);
        l[++tot][0]=4;
        l[tot][1]=chk(ch[1]);
        l[tot][2]=chk(ch[2]);
    }
    scanf("%s",ch+1);
    int L=strlen(ch+1);
    for(ri i=1;i<=L;++i) f[i][i][chk(ch[i])]=1;
    for(ri len=2;len<=L;++len)
    for(ri i=1;i<=L-len+1;++i){
        int j=i+len-1;
        for(ri k=i;k<j;++k)
        for(ri p=1;p<=tot;++p)
        f[i][j][l[p][0]]|=f[i][k][l[p][1]]&f[k+1][j][l[p][2]];
    }
    int flg=0;
    for(ri i=1;i<=4;++i){
        if(f[1][L][i]){
            flg=1;
            if(i==1) cout<<'W';
            if(i==2) cout<<'I';
            if(i==3) cout<<'N';
            if(i==4) cout<<'G';
        }
    }
    if(!flg) cout<<"The name is wrong!";
    return 0;
}
```


---

## 作者：米奇奇米 (赞：5)

## 题解- $P4290 [HAOI2008]$玩具取名
* 在复习区间$DP$的时候做到题目觉得挺好的就做了下，差点做不出来。

### 题目意思
[$lg\ 4290$](https://www.luogu.com.cn/problem/P4290)

### $Sol$
这道题目我们先设两个数组$f_{i,j,k}$表示$[i,j]$能否用$W,I,N,G$得到。再设$g_{i,j,k}$表示$k$是否能用$i,j$得到（这在读入就可以预处理出来）。

那么$f_{i,j,k}$怎么处理出来呢？

$f_{i,j,k}=1$ $\ (f_{i,p,o}=f_{p+1,j,p}=1$且$\ g_{o,p,k})$
$f_{i,j,k}=1$ $\ (i=j,s_i=k)$

于是就$O(n{^3} \times 64)$ ，其中$64$就是枚举$o,p,k$即可。

### $Code$

```c
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}

const int M=205;

int n,W,I,N,G,f[M][M][5],g[5][5][5];
char c[M];

inline int C(char c)
{
	if(c=='W') return 1;
	if(c=='I') return 2;
	if(c=='N') return 3;
	if(c=='G') return 4;
}

inline char S(int c)
{
	if(c==1) return 'W';
	if(c==2) return 'I';
	if(c==3) return 'N';
	if(c==4) return 'G';
}

int main()
{
	W=read();
	I=read();
	N=read();
	G=read();
	for ( int i=1;i<=W;i++ )
	{
		char ch[5];
		scanf("%s",ch+1);
		g[C(ch[1])][C(ch[2])][1]=1;
	}
	for ( int i=1;i<=I;i++ )
	{
		char ch[5];
		scanf("%s",ch+1);
		g[C(ch[1])][C(ch[2])][2]=1;
	}
	for ( int i=1;i<=N;i++ )
	{
		char ch[5];
		scanf("%s",ch+1);
		g[C(ch[1])][C(ch[2])][3]=1;
	}
	for ( int i=1;i<=G;i++ )
	{
		char ch[5];
		scanf("%s",ch+1);
		g[C(ch[1])][C(ch[2])][4]=1;
	}
	scanf("%s",c+1);
	n=strlen(c+1);
	for ( int i=1;i<=n;i++ ) f[i][i][C(c[i])]=1;
	for ( int l=2;l<=n;l++ ) 
		for ( int i=1;i+l-1<=n;i++ )
		{
			int j=i+l-1;
			for ( int k=i;k<j;k++ ) 
				for ( int o=1;o<=4;o++ ) 
					if(f[i][k][o])
						for ( int p=1;p<=4;p++ ) 
							if(f[k+1][j][p])
								for ( int q=1;q<=4;q++ ) 
									if(g[o][p][q]) 
										f[i][j][q]=1;
		}
	int ff=1;	
	for ( int i=1;i<=4;i++ ) 
		if(f[1][n][i]) 
		{
			putchar(S(i));
			ff=0;
		}
	if(!ff) return 0;
	printf("The name is wrong!\n");
	return 0;
}
			
		 
		
```


---

## 作者：这谁顶得住啊 (赞：5)

# [HAOI2008]玩具取名

​	**听说~~退役~~考~~NOIp~~CSP-S之前发题解能加RP**

​	一道区间型DP的好题

​	一开始看到这个题是懵逼的，完全没思路

​	后来打开标签：**区间DP**，~~继续懵逼~~，好吧，其实我们仔细想想，如果强行暴力地把最后题目给出的这个最长的字符串转回去，的确是很麻烦(我反正现在都不知道怎么打这种代码)，但是，如果我们**从小的字符串能否转回去开始考虑，到最后一步一步转化成题目给出的字符串能否转化回去**，问题是不是就解决了？从小区间到大区间，是不是感觉眼熟？

​	思路：先将$W\  I\  N \ G $这四个字母转化一下，转化成１，２，３，４(因为直接做字符实在麻烦，而且空间是个大问题)(下面$W\  I\  N \ G $将直接用$W\rightarrow G$表示)

​	然后新建一个数组$jud[i][x][y]$，该数组表示**单个字符**$i$能够由$x,y$这两个字符转化而来(题意变形，既然顺着来$i$能转化成$x,y$(**x,y的顺序不能调换**)，那么反着来(从大的字符串转回去)$x,y$就能转化成$i$)

​	定义本题的状态：$f[l][r][j]$，区间$l\rightarrow r$内的字符能否转化成$j$这一个字符

​	状态转移：区间DP的板子，
$$
f[l][r][j]|=f[l][k][x]\ \&\ f[k+1][r][y]\ \&\ jud[j][x][y],k\in[l,r-1],1\leq x,y,j\leq4
$$
​	**看清楚了，$f[l][r][j]$后面有一个或(|)符号，不写这个会WA掉**

​	稍微解释一下：$f$以及$jud$的定义上面有，$x,y$都是枚举的从$W\rightarrow G$的字符，$k$是断点，$l$和$r$是目前所枚举的区间(这里照着区间DP的板子整就是)，$j$是$W\rightarrow G$中的一个字符($l\rightarrow r$中的字符能不能转化成$j$)

​	最后注意一下初始化，当区间长度为一时，$f[i][i][1\to 4]=1$，这个……~~显而易见应该这样做~~，单独一个字符肯定能转化成自己啊

​	最后一句：和一般的区间DP不同，这道题的特别之处在于它是一个**存在型**问题，而一般的区间DP是求最值之类的，一开始看到题可能会懵，我学过这个吗？但是~~看了题解~~仔细想想之后，发现其实可能并不会有想象中那么难

$Code$：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[300][300][6];
int jud[10][10][10];
inline int p(char x){//转化WING 
	if(x=='W') return 1;
	if(x=='I') return 2;
	if(x=='N') return 3;
	if(x=='G') return 4;
}
char s[300];
int n1,n2,n3,n4;//每个字符可以由多少组两个字符转化而来 
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n1>>n2>>n3>>n4;
	for(int i=1;i<=n1;i++){
		cin>>s+1;
		jud[1][p(s[1])][p(s[2])]=1;
	}
	for(int i=1;i<=n2;i++){
		cin>>s+1;
		jud[2][p(s[1])][p(s[2])]=1;
	}
	for(int i=1;i<=n3;i++){
		cin>>s+1;
		jud[3][p(s[1])][p(s[2])]=1;
	}
	for(int i=1;i<=n4;i++){
		cin>>s+1;
		jud[4][p(s[1])][p(s[2])]=1;
	}
	cin>>s+1;//以上为读入 
	int n=strlen(s+1);
	for(int i=1;i<=n;i++){
		f[i][i][p(s[i])]=1;//初始化 
	}
	for(int len=2;len<=n;len++){//区间DP板子 
		for(int l=1;l<=n-len+1;l++){
			int r=l+len-1;
			for(int k=l;k<r;k++){
				for(int x=1;x<=4;x++){
					for(int y=1;y<=4;y++){
						for(int j=1;j<=4;j++){
							f[l][r][j]|=f[l][k][x]&f[k+1][r][y]&jud[j][x][y];
						}
					} 
				}
			}
		}
	}
	int flag=0;
	if(f[1][n][1]) flag=1,cout<<"W";
	if(f[1][n][2]) flag=1,cout<<"I";
	if(f[1][n][3]) flag=1,cout<<"N";
	if(f[1][n][4]) flag=1,cout<<"G";
	if(flag==0){
		cout<<"The name is wrong!";
	}
	return 0;
}
```

​	但是感觉有点慢，最大的点跑了$675ms$

​	那稍微加点优化吧，一些本来就没什么用的状态就直接跳过(没优化的代码为什么要写个或？就是因为这些无用状态，不写或的话它们会把当前已经推出来的状态又置为0)

​	上优化版$Code$:

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[300][300][6];
int jud[10][10][10];
inline int p(char x){//转化WING 
	if(x=='W') return 1;
	if(x=='I') return 2;
	if(x=='N') return 3;
	if(x=='G') return 4;
}
char s[300];
int n1,n2,n3,n4;//每个字符可以由多少组两个字符转化而来 
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n1>>n2>>n3>>n4;
	for(int i=1;i<=n1;i++){
		cin>>s+1;
		jud[1][p(s[1])][p(s[2])]=1;
	}
	for(int i=1;i<=n2;i++){
		cin>>s+1;
		jud[2][p(s[1])][p(s[2])]=1;
	}
	for(int i=1;i<=n3;i++){
		cin>>s+1;
		jud[3][p(s[1])][p(s[2])]=1;
	}
	for(int i=1;i<=n4;i++){
		cin>>s+1;
		jud[4][p(s[1])][p(s[2])]=1;
	}
	cin>>s+1;//以上为读入 
	int n=strlen(s+1);
	for(int i=1;i<=n;i++){
		f[i][i][p(s[i])]=1;//初始化 
	}
	for(int len=2;len<=n;len++){//区间DP板子 
		for(int l=1;l<=n-len+1;l++){
			int r=l+len-1;
			for(int k=l;k<r;k++){
				for(int x=1;x<=4;x++){
					if(f[l][k][x]!=0){//如果不是无用状态才继续 
						for(int y=1;y<=4;y++){
							if(f[k+1][r][y]!=0){//同上
								for(int j=1;j<=4;j++){
									if(jud[j][x][y]==1)//效果同之前公式
									f[l][r][j]=1;
								}
							}
						}
					}
				}
			}
		}
	}
	int flag=0;
	if(f[1][n][1]) flag=1,cout<<"W";
	if(f[1][n][2]) flag=1,cout<<"I";
	if(f[1][n][3]) flag=1,cout<<"N";
	if(f[1][n][4]) flag=1,cout<<"G";
	if(flag==0){
		cout<<"The name is wrong!";
	}
	return 0;
}
```
​	最大的点跑了$285ms$，舒服

​	**完结撒花花~**

​	**祝大家AK CSP-S/J2019**

​	~~至于码风丑得吓人+小学生式语文表达就不要吐槽了嘛~~



---

## 作者：蒟蒻zExNocs (赞：4)

介绍一下这个题我自己的思路。

------------

## 一、暴力

看完这个题，第一感觉就是把所有WING字母可以变形的形式枚举出来，然后直到目标序列出来或者枚举完全部的变形形式（结束条件是目前枚举的序列长度比目标序列长度大的时候）。那么可以用bfs做。经计算，如果每个字母只变成一种双字符的时候，每一层枚举长度大约为 $\frac{i(i+1)}{2}$ 种（i为第i层）那么总共需要枚举:

## $\sum_{i=1}^{n}\frac{i(i+1)}{2}$ 
那么时间复杂程度大约为O(n^3)，但是这个只是每个字母变成一种序列，如果每个字母变成m个序列的话大约为O(mn^3)，优化的话应该还是可以得到几分的。（多少分我就不知道了，有兴趣的可以自己打一遍试试）


------------

## 二、动态规划
再重新看这一道题，如果按着上面暴力解法反着想的话，那么久可以把这一道题理解为：给你一个字母序，按规定可以将特定的两个连续字母合并成一个字母，问最后可以合并成哪一个单字母。

这里想后，我第一感觉就是可能类似于石子合并的题了。于是我便用区间dp试做了一下。

首先，区间dp先定义dp[l][r]，即再区间[l,r]的dp值(l，r可能可以滚动数组）。但是这一题单只有l，r是不够的，因为每一个字母都可能会合并成区间[l，r]，那么就可以添加一维，dp[l][r]['c']，即在区间[l，r]中是否可以合并成c这一个字母。

### 那么可以得出状态转移方程：

### $dp[i][j]['c']=dp[i][k]['cl']$  &  $dp[k+1][j]['cr']$

#### 其中[i，k]与[k+1，j]为[i，j]的子集，[i，k]∪[k+1，j]=[i,j]~~（废话）~~，‘cl’与‘cr’分别为字符‘c’可以变成的某一个双字符的左右字符。

### 数组的初始化为：

### $dp[i][i][s[i]]=1$

#### 其中s[i]为读入字符串的第i个字符。（即自己可以变成自己）

这个状态方程的意思就是如果在[i，k],[k+1，j]区间中可以分别转化为cl与cr的话，那么[i，j]就可以由c转化成，其中k可以在[i,j]中枚举。

举个例子，如样例中，初始化为dp[1~4][1~4]['I']=1,在区间i=1,j=2中，dp[1][2]['W']=dp[1][1]['I']=1,同理，在区间dp[3][4]['W']=1,那么i=1,j=4的中，dp[1][4]['N']=dp[1][2]['W']&dp[3][4]['W']=1，因此N为可行解。

### 算法维护：

1. 由于字母转化成数组维度有点麻烦（可以用map或者直接用字母的ASCII来当数组下标）每个字母可以分别映射的数字，即字符W,I,N,G可以分别对应1,2,3,4

2. 每个字符变形的双字符可以用邻接表储存

3. 另外要强调，在读入字符时，要小心读入到' ' '\n'（即空格与回车换行）


### 代码（未剪枝50分）：

```c
//n为字符串长度
for(int i=0;i<n;i++)
	for(int j=i-1;j>=0;j--)//枚举区间
    		for(int g=1;g<=4;g++)//枚举字母
    		{
            //****标记点****
        		for(int m=head[g];m;m=que[m].nx)
        		{
            			l=que[m].a;r=que[m].b;//a,b分别为左字母右字母
            			for(int k=j;k<i;k++)//枚举子集
            			dp[j][i][g]|=(dp[j][k][l]&dp[k+1][i][r]);
        		}
    		}
```

tips：由于我写的是j>i,所以是区间[j，i]，如果觉得难看可以让i从n-1枚举到0，j=i+1,j<n，那么就是i>j，是区间[i,j]了;

很明显时间复杂大约也为O(mn^3)，还是可能会超时的，但比起暴力枚举好了很多。我们可以进行剪枝，如果g已经可以变成区间[i][j]字符串了，那么针对g就不用继续枚举这个区间了。

**即在本代码标记点处加入 if(dp[j][i][g]) continue;**

------------
### AC总代码（仅供参考）：

```
#include <bits/stdc++.h>
using namespace std;
#define ll int
#define pc(a) putchar(a)
#define rg register
const ll maxn=1100;
void gc(char &a)
{
    a=getchar();
    while(a==' '||a=='\n') a=getchar();
}
ll read(){
    char c;ll x=0;bool flag=0;gc(c);
    while(c<'0'||c>'9'){if(c=='-') flag=1;gc(c);}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48),c=getchar();}
    return flag?-x:x;
}
void pr(ll x){
    if(x<0){x=-x;pc('-');}
    if(x>9) pr(x/10);
    pc(x%10+48);
}
//----快读区域-----
struct edge
{
    char a,b;
    ll nx;
    edge(char a,char b,ll nx):a(a),b(b),nx(nx){}
    edge(){}
}que[80000];//邻接表
ll head[5],en;
map<char,ll> p;//用来更改WING的值
void edgepush(int i,char a,char b)//建边
{
    que[++en]=edge(p[a],p[b],head[i]);
    head[i]=en;
}
bool dp[maxn][maxn][5];//精髓
ll n,a[5],l,r;
string s;//读入字符
char u,v;
bool flag;//用来判断是否有字符输出
int main()
{
    p['W']=1;p['I']=2;p['N']=3;p['G']=4;
    for(int i=1;i<=4;i++)
    a[i]=read();
    for(int i=1;i<=4;i++)
    for(int j=1;j<=a[i];j++)
    {
        gc(u);gc(v);
        edgepush(i,u,v);
    }
    cin>>s;n=s.size();
    for(int i=0;i<n;i++)
    dp[i][i][p[s[i]]]=1;
    for(int i=0;i<n;i++)
    for(int j=i-1;j>=0;j--)
    for(int g=1;g<=4;g++)
    {
        if(dp[j][i][g]) continue;
        for(int m=head[g];m;m=que[m].nx)
        {
            l=que[m].a;r=que[m].b;
            for(int k=j;k<i&&!dp[j][i][g];k++)
            dp[j][i][g]|=(dp[j][k][l]&dp[k+1][i][r]);
        }
    }
    if(dp[0][n-1][1]){pc('W');flag=1;}
    if(dp[0][n-1][2]){pc('I');flag=1;}
    if(dp[0][n-1][3]){pc('N');flag=1;}
    if(dp[0][n-1][4]){pc('G');flag=1;}
    if(!flag) puts("The name is wrong!");
    return 0;
}
```


---

## 作者：Sober_Clever (赞：3)

来一遍记忆化搜索的题解

思路与各位大佬类似，都是区间dp

但我们改用搜索的形式做

码量有点大~~（多层循环真的不会写）~~

其中dp[ i ][ j ][ k ]记录区间[ i , j ]能否由k转变过来

用vis[ i ][ j ][ k ]记录（i , j , k ）这一状态是否被搜过

其他具体的见代码
```cpp
#include<cstdio>
#include<map>
#include<string>
using namespace std;
char s1[5],s2[210],s[]="WING";
int n=0,f[5][5][5]={0},dp[210][210][5]={0},name[210];//f[i][j][k]记录数字i，数字j能否转成数字k
bool vis[210][210][5]={0};
map<char,int> m;
void dfs(int l,int r,int x)//计算区间[l,r]能否由x变过来
{
    if(l==r)
    {
        if(x==name[l]) dp[l][r][x]=1;
        else dp[l][r][x]=0;
        return ;
    }
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
            if(f[i][j][x])
            {
                for(int k=l;k<r;k++)
                {
                    if(!vis[l][k][i]) {dfs(l,k,i);vis[l][k][i]=true;}
                    if(!vis[k+1][r][j]) {dfs(k+1,r,j);vis[k+1][r][j]=true;}
                    if(dp[l][k][i]&&dp[k+1][r][j])
                    {
                        dp[l][r][x]=1;
                        return ;
                    }
                }

            }

}
int main()
{
    m['W']=1,m['I']=2,m['N']=3,m['G']=4;
    int a,b,c,d,flag=0;
    scanf("%d%d%d%d",&a,&b,&c,&d);
    for(int i=1;i<=a;i++) scanf("%s",s1),f[m[s1[0]]][m[s1[1]]][1]=1;
    for(int i=1;i<=b;i++) scanf("%s",s1),f[m[s1[0]]][m[s1[1]]][2]=1;
    for(int i=1;i<=c;i++) scanf("%s",s1),f[m[s1[0]]][m[s1[1]]][3]=1;
    for(int i=1;i<=d;i++) scanf("%s",s1),f[m[s1[0]]][m[s1[1]]][4]=1;
    scanf("%s",s2);
    for(int i=0;s2[i];i++) name[i+1]=m[s2[i]],++n;
    for(int i=1;i<=4;i++)
    {
        dfs(1,n,i);
        if(dp[1][n][i])
            printf("%c",s[i-1]),flag=1;
    }
    if(!flag) printf("The name is wrong!");
    printf("\n");
    return 0;
}

```


---

## 作者：jins3599 (赞：2)

一道非常妙的区间$dp$，其实还是比较有套路的。

看到拆分，合并，第一个想到的就是区间$dp$了。

我们因为需要求整个区间可不可以合并成一个数，于是就可以设计方程如下：

$f[i][j][p]$代表，区间$[i,j]$是否可以合并成数字$p$.

转移方程是这样的:

$f[i][j][p]=f[i][k][l]\ \&\ f[k+1][j][r] \ \ (p$可以转化为$l,r)$

于是我们需要预处理这样几样东西：

数组`check[i][j][k]`代表：$i$是否可以转化为$jk$

函数$hash()$代表字母所映射的数字（这样映射一下会比较好写）

然后$f$数组的预处理就是，每个长度为$1$的区间可以转化成它本身。

然后进行转移即可。

时间复杂度$O(n^3*4^3)$大概$8*10^7$？需要卡卡常？

其实没必要，我们发现$O(n^3)$跑不满，大概少一半的样子。（反正我最坏的点是跑了400ms)

$code:$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 300;

int sta[5];
char c[5];
char rname[N]; 
int name[N] , n;

int hash(char x) {
	if(x == 'W') return 1;
	if(x == 'I') return 2;
	if(x == 'N') return 3;
	return 4;
}

int check[5][5][5];

int f[N][N][5];
void Work() {
	for(int i = 1 ; i <= n ; ++ i) f[i][i][name[i]] = 1;
	for(int len = 2 ; len <= n ; ++ len) {
		for(int i = 1 ; i <= n - len + 1 ; ++ i) {
			int j = i + len - 1;
			for(int k = i ; k < j ; ++ k) {
				for(int p = 1 ; p <= 4 ; ++ p)
					for(int l = 1 ; l <= 4 ; ++ l)
						for(int r = 1 ; r <= 4 ; ++ r) {
							if(f[i][k][l] && f[k + 1][j][r] && check[p][l][r])
								f[i][j][p] = 1;
						}
			}
		}
	}
	bool flag = 0;
	if(f[1][n][1] == 1) flag = 1 , putchar('W');
	if(f[1][n][2] == 1) flag = 1 , putchar('I');
	if(f[1][n][3] == 1) flag = 1 , putchar('N');
	if(f[1][n][4] == 1) flag = 1 , putchar('G');
	if(!flag) puts("The name is wrong!");
}

int main () {
	for(int i = 1 ; i <= 4 ; ++ i) scanf("%d" , sta + i);
	for(int i = 1 ; i <= 4 ; ++ i) {
		for(int j = 1 ; j <= sta[i] ; ++ j) {
			scanf("%s" , c);
			check[i][hash(c[0])][hash(c[1])] = 1;
		}
	}
	scanf("%s" , rname); n = strlen(rname);
	for(int i = 1 ; i <= n ; ++ i)  name[i] = hash(rname[i - 1]);	
	Work();
	return 0;
} 
```

---

## 作者：EarthGiao (赞：1)

## 【思路】
区间DP   
从一串很长的字符串变为一个字母    
从两个字母变回一个字母可以用一个映射来表示  
先预处理一下每一次字符对应的映射  
W = 1，I = 2，N = 3，G = 4    
在代码中，就是你每一个数能够被替代的方式里面   
第i个数到他的第j中 替代方法的映射，方便之后的转移   
可以用f(i,j,k)    
i表示是第i个数，j表示第i个数的第j中替代方法   
然后k只有两个数1和2表示能够替代那一个字符的两个字符分别是什么   
 
这样完成之后就可以开始DP了   
dp(i,j,k)   
i表示区间的左端点，j表示区间的右端点,k表示从i到j这一串字符串可以合并成的那一个字符    
先初始化一下，将每一个从自己到自己能够合成的字符串初始化为自己所在位置上的字符    
然后5重循环，枚举的内容在代码里面   

最后检验从1到字符串最后，上面那四个数是不是又可以合并出来的    
从第一个枚举到第四个一旦可以就输出   
保证顺序是按照WING的     
 
## 【完整代码】

```cpp
#include<iostream>
#include<cstdio>
#include<map> 
#include<cstring>
using namespace std;
int num[5];
map<char,int> w;
int f[5][20][3];
bool dp[205][205][5];
char a,b;
char s[205] = "0";
int len;
char ans[10] = {"0WING"};
int main()
{
	w['W'] = 1,w['I'] = 2,w['N'] = 3,w['G'] = 4;
	for(int i = 1;i <= 4;++ i)scanf("%d",&num[i]);
	for(int i = 1;i <= 4;++ i)
		for(int j = 1;j <= num[i];++ j)
		{
			cin >> a >> b;
			f[i][j][1] = w[a];
			f[i][j][2] = w[b];
		}
	scanf("%s",s + 1);
	len = strlen(s) - 1;
//	cout << len << endl;
	for(int i = 1;i <= len;++ i)dp[i][i][w[s[i]]] = 1;
	
	for(int i = 2;i <= len;++ i)//枚举区间长度
		for(int l = 1,r = l + i - 1;l <= len - i + 1;l ++,r ++)//枚举区间的左端点和区间的右端点 
			for(int j = 1;j < i;++ j)//总的区间拼出来的数是由哪两个分区间组合出来的，也就是两个区间的交界处 
				for(int k = 1;k <= 4;++ k)//枚举WING 
					for(int z = 1;z <= num[k];++ z)//WING能够被组合出来的方案 
						if(dp[l][l + j - 1][f[k][z][1]] && dp[l + j][r][f[k][z][2]])//可行
							dp[l][r][k] = 1;//标记 
	int fg = 0;
	for(int i = 1;i <= 4;++ i)
	{
		if(dp[1][len][i] == true)
		{
			fg = 1;
			cout << ans[i];
		}
	}
	if(fg == 0)
		cout << "The name is wrong!" << endl;
	return 0;
}
```

---

## 作者：lizh (赞：0)

## P4290 [HAOI2008]玩具取名

[P4290 [HAOI2008]玩具取名](https://www.luogu.org/problemnew/show/P4290)

区间dp，f[i][j][k]表示[i,j]这个区间可以由k字母转化而来，也就可以反着转录回去，而它与相邻的一个字母也可以在转换，前提是满足条件。

f[i][j][k]表示[i,j]这个区间可以由k字母代替

can[s][s1][s2]表示s可以由s1和s2转化而来

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int q[100000],can[6][6][6],f[300][300][5];
string name;
int change(char x)
{
	if(x=='W') return 1; 
    if(x=='I') return 2;
    if(x=='N') return 3; 
    if(x=='G') return 4; 
}
int main()
{
	for(int i=1;i<=4;i++)
	{
		scanf("%d",&q[i]);
	}
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=q[i];j++)
		{
			string c;
			cin>>c;
			can[i][change(c[0])][change(c[1])]=1;;
		}
	}
	cin>>name;
	int length=name.length();
	for(int i=0;i<length;i++)
	{
		f[i][i][change(name[i])]=1;
	}
	for(int len=1;len<length;len++)
	{
		for(int l=0;l<length-len;l++)
		{
			int r=len+l;
			for(int k=l;k<r;k++)
			{
				for(int s=1;s<=4;s++)
				{
					for(int s1=1;s1<=4;s1++)
					{
						for(int s2=1;s2<=4;s2++)
						{
							if(f[l][k][s1]&&f[k+1][r][s2]&&can[s][s1][s2])
							{
								f[l][r][s]=1;
							}
						}
					}
				}
			}
		}
	}
	int ans=0;
	if(f[0][length-1][1]) {ans=true;printf("W");}
    if(f[0][length-1][2]) {ans=true;printf("I");}
    if(f[0][length-1][3]) {ans=true;printf("N");}
    if(f[0][length-1][4]) {ans=true;printf("G");}
    if(!ans) printf("The name is wrong!");
	
	return 0;
}
```


---

## 作者：xsI666 (赞：0)

这道题很明显是区间DP。

为了方便表示，我们可以将‘W’、‘I’、‘N’、‘G’分别设为1、2、3、4。

另外，DP可能有点丑，记忆化搜索可能写起来更容易理解。

AC代码：
```cpp
#include <bits/stdc++.h>//万能头文件

using namespace std;//使用标准名字空间

inline int read()//快速读入
{
	int f=1,x=0;
	char c=getchar();

	while(c<'0' || c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}

	while(c>='0' && c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}

	return f*x;
}

string s;
int b[5][5][5],dp[210][210][5],p[130],d[5],len,fl;//定义变量

int main()
{
	p['W']=1,p['I']=2,p['N']=3,p['G']=4;//将字母表示成数字

	for(register int i=1; i<=4; i++)//输入
	{
		d[i]=read();
	}

	for(register int i=1; i<=4; i++)
	{
		for(register int j=1; j<=d[i]; j++)
		{
			cin>>s;//输入每个字母可以代表的子字符串
            
			b[p[s[0]]][p[s[1]]][i]=1;//标记这个字符串由i演变而来
		}
	}

	cin>>s;//输入玩具名称

	len=s.size();//记录名称长度

	for(register int i=0; i<len; i++)
	{
		dp[i][i][p[s[i]]]=1;//标记第i个位置
	}
	//开始DP主过程
	for(register int i=len-1; i>=0; i--)
	{
		for(register int j=i+1; j<len; j++)//枚举区间（i，j）
		{
			for(register int k=1; k<5; k++)//枚举字母
			{
				for(register int l=1; l<5 && dp[i][j][k]==0; l++)//如果（i，j）不含有字母k，就枚举字母l
				{
					for(register int o=1; o<5 && dp[i][j][k]==0; o++)//同理
					{
						if(b[l][o][k]==0)//如果字母组合（l，o）不能由字母k演变来
						{
							continue;//就继续循环
						}

						for(register int w=i; w<j && dp[i][j][k]==0; w++)
						{
							dp[i][j][k]|=(dp[i][w][l] & dp[w+1][j][o]);//主要DP步骤，要仔细体会
						}
					}
				}
			}
		}
	}
	//输出
	if(dp[0][len-1][1])
	{
		cout<<'W';
		fl=1;
	}

	if(dp[0][len-1][2])
	{
		cout<<'I';
		fl=1;
	}

	if(dp[0][len-1][3])
	{
		cout<<'N';
		fl=1;
	}

	if(dp[0][len-1][4])
	{
		cout<<'G';
		fl=1;
	}
	//无解输出
	if(fl==0)
	{
		cout<<"The name is wrong!";
	}

	return 0;//完美结束
}
```


---


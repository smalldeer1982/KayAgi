# [SHOI2015] 自动刷题机

## 题目背景

曾经发明了信号增幅仪的发明家 SHTSC 又公开了他的新发明：自动刷题机——一种可以自动 AC 题目的神秘装置。

## 题目描述

自动刷题机刷题的方式非常简单：首先会瞬间得出题目的正确做法，然后开始写程序。每秒，自动刷题机的代码生成模块会有两种可能的结果：

1. 写了 $x$ 行代码。
2. 心情不好，删掉了之前写的 $y$ 行代码。（如果 $y$ 大于当前代码长度则相当于全部删除。）

对于一个 OJ，存在某个固定的正整数长度 $n$，一旦自动刷题机在某秒结束时积累了大于等于 $n$ 行的代码，它就会自动提交并 AC 此题，然后新建一个文件（即弃置之前的所有代码）并开始写下一题。SHTSC 在某个 OJ 上跑了一天的自动刷题机，得到了很多条关于写代码的日志信息。他突然发现自己没有记录这个 OJ 的 $n$ 究竟是多少。所幸他通过自己在 OJ 上的 Rank 知道了自动刷题机一共切了 $k$ 道题，希望你计算 $n$ 可能的最小值和最大值。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $1 \le l \le 10$；
- 对于 $40\%$ 的数据，保证 $1 \le l \le 100$ ；
- 对于 $60\%$ 的数据，保证 $1 \le l \le 2 \times 10^3$；
- 对于 $100\%$ 的数据，保证 $1 \leq l \le 10^5$，$-10^9 \le x_i \le 10^9$，$k$ 在 ```int``` 存储范围内。

## 样例 #1

### 输入

```
4 2
2
5
-3
9```

### 输出

```
3 7```

# 题解

## 作者：Ofnoname (赞：44)

肺都给气炸了，二分答案对来说实在是太难缠了。

容易发现，对于给定的序列，`n`越大能过的题是越少的，所以可以二分来求刚好过`k`道题的左右边界。

若`mid`大于`k`,即做得太多了，就将`l`右移。

若`mid`小于`k`,即做得太少了，就将`r`左移。

求左边界，需要在`mid`等于`k`时将`r`左移，求右边界时则需将`l`右移。这个很好理解。

印象里二分写法极多，但现在普遍应用`l<=r,  l=mid+1, r=mid-1`这个版本了，虽然要多记录一个`ans`，但是却在单调增单调减时都能工作，并且可以轻松应对无解的情况。

注意这种写法`l`应设为1，`r`设为无穷大即可。

```cpp
#include <bits/stdc++.h>
#define MAX (100000 + 7)
#define long long long
using namespace std;

int N, k, a[MAX];
long l, r, ans1 = -1, ans2 = -1;

long work(long im)
{
    int ans = 0; long sum = 0;
    for (int i = 1; i <= N; i++)
    {
        sum = max(sum + a[i], 0ll);
        if (sum >= im) sum = 0, ans++;
    }return ans;
}

int main()
{
    scanf("%d%d", &N, &k);
    for (int i = 1; i <= N; i++)
        scanf("%d", a + i);
    l = 1, r = 1e18;//注意l应设为1 
    while (l <= r)
    {
        long mid = (l + r) >> 1;
        if (work(mid) <= k)
        {
        	r = mid - 1;
        	if (work(mid) == k) ans1 = mid;//注意符合条件才更新答案 
		}
		else l = mid + 1;
    }
    
    l = 1, r = 1e18;//注意l应设为1 
    while (l <= r)
    {
        long mid = (l + r) >> 1;
        if (work(mid) >= k)
        {
        	l = mid + 1;
        	if (work(mid) == k) ans2 = mid;//注意符合条件才更新答案 
		}
		else r = mid - 1;
    }
    if (ans1 == -1) puts("-1");
    else printf("%lld %lld\n", ans1, ans2);
}
```

---

## 作者：Drinkkk (赞：21)

【题目描述】

曾经发明了信号增幅仪的发明家 SHTSC 又公开了他的新发明：自动刷题机——一种可以自动 AC 题目的神秘装置。

自动刷题机刷题的方式非常简单：首先会瞬间得出题目的正确做法，然后开始写程序。每秒，自动刷题机的代码生成模块会有两种可能的结果：

1.写了$x$行代码。

2.心情不好，删掉了之前写的$y$行代码（如果$y$大于当前代码长度则相当于全部删除）。

对于一个 OJ，存在某个固定的长度$n>0$ ，一旦自动刷题机在某秒结束时积累了大于等于$n$行的代码，它就会自动提交并 AC 此题，然后新建一个文件（即弃置之前的所有代码）并开始写下一题。SHTSC 在某个 OJ 上跑了一天的自动刷题机，得到了很多条关于写代码的日志信息。他突然发现自己没有记录这个 OJ 的$n$究竟是多少。所幸他通过自己在 OJ 上的 Rank 知道了自动刷题机一共切了$k$道题，希望你计算$n$可能的最小值和最大值。

【输入输出格式】

- 输入格式
第一行两个整数$l,k$，表示刷题机的日志一共有$l$行，一共了切了$k$题。

第二行ll 个整数$x_1,...,x_l$。$x_i > -1$表示写了$x_i$行代码，$x_i<0$代表删除了这道题的$x_i$行代码。

- 输出格式

输出两个数$a,b$，分别代表$n$可能的最小值和最大值。如果不存在这样的$n$则输出$-1$。

【输入输出样例】

- 输入样例
```
4 2
2
5
-3
9
```

- 输出样例
```
3 7
```

【数据范围和说明】

样例1：如果$n=2$那么刷题机就会切掉$3$题。但如果$n>7$刷题机最多只能切$1$题。考虑$n=4$发生了什么。

第一秒：刷题机写了$2$行。

第二秒：刷题机又写了$5$行，共有$7$行，提交，自信AC。

第三秒：刷题机删掉了$3$行，共有$0$行。

第四秒：刷题机写了$9$行，共有$9$行，提交，自信AC。

一共AC了两题。

对于$20$%的数据，$n \leq 10$。

对于$40$%的数据，$n \leq 100$。

对于$60$%的数据，$n \leq 2000$。

对于$100$%的数据，$n \leq 100000,-10^9 \leq x_i  \leq 10^9$。

$100$分（满分）思路：

我会暴力！

- 枚举$n$可能的最小值和最大值？显然会超时，时间复杂度约为$O((\sum_{i=1}^{n}x_i) \times n)$。显然会超时。

我会二分！

- 我们考虑使用二分来解决这道题。时间复杂度约为$O(n\;log_2\;n)$。是可以在规定的时间内完成本题的。

那么怎么二分呢？

我们可以用两次二分来完成这道题，一次求最小值，一次求最大值。下面我拿求最小值的那次二分做举例，我们设$mid$为可能的最小值且$mid=(l+r) \div 2$，在这里我用了一个$su$以及一个$t$来分别表示当前写的代码的行数以及现在已经A掉了多少题目，若$t \leq m$（我在这里题目中的$k$）则让$r'=mid-1$，且如果$t=m$，就让$ans=mid$（即$n$可能的最小值）否则让$l'=mid+1$。直到$l>r$时就跳出循环。下面上二分部分的代码：

```cpp
long long l=1,r=inf;
while(l<=r)
{
	long long mid=(l+r)/2;
	long long su=0,t=0;
	for(long long i=1;i<=n;i++)
	{
		su+=a[i];
		if(su>=mid)
		{
			t++;
			su=0;
		}
		if(su<0)
		{
			su=0;
		}
	}
	if(t<=m)
	{
		r=mid-1;
		if(t==m)
		{
			ans=mid;
		}
	}
	else
	{
		l=mid+1;
	}
}
if(ans!=-1)
{
	printf("%lld ",ans);
	ans=-1,l=1,r=inf;
	while(l<=r)
	{
		long long mid=(l+r)/2;
		long long su=0,t=0;
		for(long long i=1;i<=n;i++)
		{
			su+=a[i];
			if(su>=mid)
			{
				t++;
				su=0;
			}
			if(su<0)
			{
				su=0;
			}
		}
		if(t<=m-1)
		{
			r=mid-1;

		}
		else
		{
			l=mid+1;
			if(t==m)
			{
				ans=mid;
			}
		}
	}
	printf("%lld",ans);
}
else
{
	printf("-1");
}
```

- 一些坑点以及注意事项

1. 二分的边界要设好，记住``while(l<=r)``不要写成``while(l+1<=r)``或者是``while(l<=r-1)``哦。

2. $r$要设得足够大（例如999999999999999）。

3. 记得要开$long\;long$哦。

下面上AC代码~

```cpp
#include <cstdio>
long long a[1000001];
int main()
{
	long long inf=999999999999999,ans=-1,n=0,m=0;
	scanf("%lld %lld",&n,&m);
	for(long long i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	long long l=1,r=inf;
	while(l<=r)
	{
		long long mid=(l+r)/2;
		long long su=0,t=0;
		for(long long i=1;i<=n;i++)
		{
			su+=a[i];
			if(su>=mid)
			{
				t++;
				su=0;
			}
			if(su<0)
			{
				su=0;
			}
		}
		if(t<=m)
		{
			r=mid-1;
			if(t==m)
			{
				ans=mid;
			}
		}
		else
		{
			l=mid+1;
		}
	}
	if(ans!=-1)
	{
		printf("%lld ",ans);
		ans=-1,l=1,r=inf;
		while(l<=r)
		{
			long long mid=(l+r)/2;
			long long su=0,t=0;
			for(long long i=1;i<=n;i++)
			{
				su+=a[i];
				if(su>=mid)
				{
					t++;
					su=0;
				}
				if(su<0)
				{
					su=0;
				}
			}
			if(t<=m-1)
			{
				r=mid-1;

			}
			else
			{
				l=mid+1;
				if(t==m)
				{
					ans=mid;
				}
			}
		}
		printf("%lld",ans);
	}
	else
	{
		printf("-1");
	}
	return 0;
}
```

---

## 作者：Mine_King (赞：18)

对于这题，如果直接枚举必定 TLE，那么我们考虑能否二分答案。发现如果$check(x)$表示若$n=x$是否满足条件，这个序列并不满足单调性，他是前后一堆$0$，中间一段$1$的情况，那么肯定不能这么处理。  
那么再考虑：如果$check(x)$表示若$n=x$能做几道题呢？发现$x$越小能做的题越多，反之亦然，满足单调性。  

二分的版本很多，我们如何二分这个区间的左右边界呢，我们可以用`l<=r mid=(l+r)/2 l=mid+1 r=mid-1`的版本。并在`check(x)==k`时做记录。若要二分左边界则在`check(x)==k`时`r=mid-1`，二分右边界则`l=mid+1`。

**code:**
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[100005];
int l,r,ans;
int check(int x)//这里直接模拟即可
{
	int num=0,len=0;
	for(int i=1;i<=n;i++)
	{
		num+=a[i];
		if(num<0) num=0;
		if(num>=x) num=0,len++;
	}
	return len;
}
signed main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	l=1,r=1e15;
	ans=1e15+1;
	while(l<=r)//二分左边界
	{
		int mid=(l+r)/2;
		if(check(mid)>k) l=mid+1;
		else if(check(mid)<k) r=mid-1;
		else ans=mid,r=mid-1;
	}
	if(ans!=1e15+1) printf("%lld ",ans);//判断是否存在这样的区间
	else
	{
		printf("-1 ");
		return 0;
	}
	l=1,r=1e15;
	ans=1e15+1;
	while(l<=r)//二分右边界
	{
		int mid=(l+r)/2;
		if(check(mid)>k) l=mid+1;
		else if(check(mid)<k) r=mid-1;
		else ans=mid,l=mid+1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：STPGUY (赞：8)

# ~~其实这道题挺裸的~~

就是 **二分答案 + 无脑Check**，没有什么特别的技巧吧

emmmm Check就是按照题目描述来搞：
```cpp
inline ll Check(ll X)
{
    ll Sum(0), Count(0);//Sum是截止到i时有几行代码，Count截止到i时水了几道题
    for (int i = 1; i <= L; ++i)
    {
        Sum += Pro[i];//无脑加
        if (Sum >= X)Sum = 0, ++Count;//无脑判断
        else if (Sum < 0)Sum = 0;//无脑*&……%¥%……&*&……%
    }
    return Count;
}
```
**然后就套一个二分的版子~~这道题就水过了~~**

## CodeTime：
```cpp
#include <cstdio>

typedef long long ll;
const ll Maxn = 1e6 + 5, INF = 0x7fffffffffff;
ll L, K, l(1), r(INF);//右边界要设大一点,Max_int都要WA
ll Pro[Maxn], Min(1), Max(-1);

inline ll Check(ll X)
{
    ll Sum(0), Count(0);
    for (int i = 1; i <= L; ++i)
    {
        Sum += Pro[i];
        if (Sum >= X)Sum = 0, ++Count;
        else if (Sum < 0)Sum = 0;
    }
    return Count;
}

int main()
{
    scanf("%lld %lld", &L, &K);
    for (int i = 1; i <= L; ++i)scanf("%lld", Pro + i);
    while (l <= r)
    {
        ll Mid = (l + r) >> 1, CC = Check(Mid);
        if (CC < K)r = Mid - 1;
        else l = Mid + 1, Max = (CC == K ? Mid : Max);//先求MAX, 可以缩小下一次二分的范围
    }
    if (Max == -1)return puts("-1") & 0;//Max的初值为-1, 如果Max还是-1那肯定无解喽(^.^) 
    l = Min, r = Max;//现在范围就变成了[1, Max], 可能会快一点点
    while (l <= r)
    {
        ll Mid = (l + r) >> 1, CC = Check(Mid);
        if (CC > K)l = Mid + 1;
        else r = Mid - 1, Min = (CC == K ? Mid : Min);//求左边界
    }
    printf("%lld %lld\n", Min, Max);//&……%¥#@……%@¥&（……%！#输出
}

```

**~~然后这道题就水过了......~~**

有什么不妥的就私信联系吧

emmmmmm

---

## 作者：HoshiuZ (赞：6)

## 题目大意
刷题机写了l次代码，每次写了x行，如果x是负的即为删了-x行代码。每写一次代码结束后如果行数大于等于n，切的题量++，代码行数清零。给定l和切的题量k,以及l次写的代码行数，求n的最大值和最小值
## 具体实现
本题具有明显的单调性。针对不同的n，当n越小的话，切的题应该会尽可能的大。因此可以二分来查找n的最大值和最小值。

先找最小值。左节点明显是1，右节点初始值我赋了l次写的代码行数中正整数的和。定完左右节点，就可以~~愉快的~~二分查找了。判断解是否可行，只需要求出在该解的情形下能切掉的题数。如果能切掉的题大于了k，则说明解仍可以大，那么解就在右区间内。小于则反之。等于的话，由于此次求的是最小值，所以先把这此的解记录下来，然后再二分左区间。

找最大值得话，唯一与最小值不同的就是等于的话，记录解后二分右区间。但要注意的是，如果最小值没有找到（也就是答案一致是初值），那么最大值也就没有必要找了，直接输出-1即可。

本题另需注意的是**开longlong**，我改了七遍才过，最后才发现居然是check函数中的变量没开longlong..**~~不开longlong见祖宗~~**
## 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

long long l,k,c[100010];
long long check(long long x) {   //判断解是否可行（就是这个括号里没开longlong）
	long long w=0,s=0;
	for(int i=1;i<=l;i++) {
		w+=c[i];   //代码总行数加上c[i]
		if(w>=x) {   //如果大于等于了，切掉的题数++，行数清零
			s++;
			w=0;
		}
		if(w<0) w=0;   //行数小于c[i]相当于清空
	}
	return s;
}
	
int main() {
	cin>>l>>k;
	long long maxn=0;
	for(int i=1;i<=l;i++) {
		cin>>c[i];
		if(c[i]>0) maxn+=c[i];   //求右节点值
	}
	
	long long l=1,r=maxn,ans=-1;
	while(l<=r) {
		long long mid=l+r>>1;
		long long s=check(mid);
		if(s>k) l=mid+1;
		if(s==k) ans=mid;
		if(s<=k) r=mid-1;
			
	}
	cout<<ans<<" ";
	if(ans==-1) return 0;   //如果ans没有改变则说明没有解，直接输出-1（ans此时就是-1）后return 0
	
	l=1,r=maxn,ans=-1;
	while(l<=r) {
		long long mid=l+r>>1;
		long long s=check(mid);
		if(s>=k) l=mid+1;
		if(s==k) ans=mid;
		if(s<k) r=mid-1;
			
	}
	cout<<ans<<endl;
	
	return 0;
}
```


---

## 作者：By_Ha (赞：5)

- 这一题赤裸裸的二分由于我太水了,整整交了8次才过(LOJ),然后发现自己连二分答案都写不对,真是令人自闭
- 考虑二分的两种基本形式(From 算法竞赛进阶指南)

> 在单调递增序列$a$中查找$\geq x$的数中最小的一个(即$x$或$x$的后继)
```cpp
while(l < r){
    int mid = (l + r) >> 1;
    if(a[mid] >= x) r = mid;
    else l = mid + 1;
}
```

> 在单调递增序列$a$中查找$\leq x$的数中最大的一个(即$x$或$x$的前驱)
```cpp
while(l < r){
    int mid = (l + r + 1) >> 1;
    if(a[mid] <= x) l = mid;
    else r = mid - 1;
}
```

- 我们考虑随着需要代码行数n的增加,通过的题目肯定单调不升,稍微改变一下上面的模板就可以找到n的最大最小值,从而通过题目.
- 注意开long long

- 什么,你怎么又回来了,我没告诉你怎么判断无解么??
- 好吧,无解有三种情况,做不了,做太多或者做不到准确的k个,我们只需要在二分时将l设置为0,r设置为最大值+1即可.
- 如果求解后答案为0或者最大值+1,那么就是无解了,如果我们再次check答案后得到的通过数字不是k,那么也是无解.

- 我由于太久没写二分可能写的比较奇怪,建议看完上面后自己写.

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

#define Rint register int
typedef long long ll;

int qr(){int ret=0,f=1;char ch=getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}

ll N,l,k;
ll log[100005];

int check(ll n){
    Rint cnt = 0;N = 0;
    for(Rint i = 1;i<=l;++i){
        N += log[i];N=N<0?0:N;
        if(N>=n) N=0,cnt++;
        if(cnt > k)
            return 1;
    }
    if(cnt == k) return 0;
    return -1;
}

int main(){
    ll ans ;
    l=qr(),k =qr();
    for(Rint i = 1;i<=l;i++)
        log[i] = qr();
    register ll l = 0,r = 100000000001;
    //check(9633844663);
    while(l!=r){
        ll mid = (l+r+1) >> 1;
        if(mid <= 0){l=0;break;}
        int t = check(mid);
        if(t == 1) l = mid + 1;
        else if(t == -1) r = mid - 1;
        else l = mid;
    }
    if(l == 0 || l == 100000000001 || check(l)!=0) {cout << -1;return 0;}
    ans = l;
    r = l, l = 1;
    while(l!=r){
        ll mid = (l+r) >> 1;
        int t = check(mid);
        if(t == 1) l = mid + 1;
        else if(t == -1) r = mid - 1;
        else r = mid;
    }
    cout << l << ' ' << ans;
    return 0;
}
```

---

## 作者：Limit (赞：4)

题面很玄学，~~要是我也有这么一台机器就好了QAQ~~
如果知道了一题几行，判断合不合法应该是很简单的，就是一个简单的模拟QAQ
```cpp
long long check(long long middle/*传进来的值，就是一题几行*/)
{
  long long i,sum=0,pd=0;
  for(i=1;i<=l;i++)
  {
  	sum+=a[i];
  	if(sum>=middle){pd++;sum=0;}//刷了一题
  	sum=MAX(sum,0);//党sum<0时要为0
  }
  //如果刷的题数和要求一样就返回true
  return k==pd;
}
```
然后只要套上两个二分QAQ

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cmath>
#include<string.h>
#include<algorithm>
#define INF 0x7f7f7f7f7f7f7f//最大值要稍微定大一点，感觉在OJ上提交几百亿行代码好玄学QAQ
using namespace std;
long long MAX(long long a,long long b)
{
  if(a>b)return a;else return b;
}
long long i,j,k,l;
long long a[200000];
long long check(long long middle)
{
  long long i,sum=0,pd=0;
  for(i=1;i<=l;i++)
  {
  	sum+=a[i];
  	if(sum>=middle){pd++;sum=0;}
  	sum=MAX(sum,0);
  }
  return pd;//返回刷的题数比较方便判断
}

long long Logn_max(long long left,long long right)//二分最大值
{
  long long middle,answer=-1,Check;
  while(right>=left)
  {
    middle=(left+right)/2;
    Check=check(middle);
    if(Check>k){left=middle+1;}else {right=middle-1;if(Check==k)answer=middle;/*这里要注意，必须要是等于k才能更新ans，下同*/}
  }
  return answer;
}
long long Logn_min(long long left,long long right)//二分最小值
{
  long long middle,answer=-1,Check;
  while(right>=left)
  {
    middle=(left+right)/2;
    Check=check(middle);
    if(Check>=k/*注意这里和最小值是不一样的QAQ*/){left=middle+1;if(Check==k)answer=middle;}else right=middle-1;
  }
  return answer;
}

int main()
{
  cin>>l>>k;
  for(i=1;i<=l;i++)
  cin>>a[i];
  long long Max=Logn_max(1,INF),Min=Logn_min(1,INF);//二分一下ans
  if(Min!=-1/*如果没有解就输出-1*/)cout<<Max<<" "<<Min;/*有解就输出解*/else cout<<-1;
  return 0;
}
```


---

## 作者：pidan (赞：3)

纪念自己的第一道SHOI题目QAQ

[题目传送门](https://www.luogu.com.cn/problem/P4343)

我们来看题，题意大概是：让你求出正整数n，使得将给定数列分成k段，按照题目所述方法计算后每一段的和都大于等于n的最大值和最小值。

如果我们只要计算最大值，这题就可以转化为一个与[P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)相似的二分模型。

需要注意的是，当用mid得出的答案大于等于m时，我们应该吧l移至mid以得到最大值，并用ans记录。因为check(mid)>m时答案一定是偏小的，而=时不一定是最大值。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){
	int w=0,h=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')h=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){w=w*10+ch-'0';ch=getchar();}
	return w*h;
}
int n,m,x[100010],l,r,ans;
int check(int mid){
	int cnt=0,sum=0;
	for(int i=1;i<=n+1;i++){
		sum+=x[i];
		if(sum<0)sum=0;
		if(sum>=mid)cnt++,sum=0;
	}
	return cnt;
}
signed main(){
	n=read();m=read();
	for(int i=1;i<=n;i++)x[i]=read(),r+=abs(x[i]);
	r++;
	while(l+1<r){
		int mid=l+r>>1;
		if(check(mid)>=m)l=mid,ans=l;
		else r=mid;
	}
	printf("%lld",ans);
	return 0;
}
```
接下来考虑最小值：由于我们已经求出了最大值，所以最小值一定在0~ans之间(ans是之前求出的最大值)，可以继续使用二分求解.特别的，我们仅当check(mid)=m时才把r移至mid，因为刚开始r必定是在答案区间内的，所以check(r)无论如何都不会>m,最后输出r即可。

对于无解情况：如果在第一次求解最大值时记录的ans为0，必定无解。如果第二次求解后最小值r大于最大值ans，同样无解

部分细节会在代码中说明。

AC代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){
	int w=0,h=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')h=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){w=w*10+ch-'0';ch=getchar();}
	return w*h;
}
int n,m,x[100010],l,r,ans;
int check(int mid){//check函数使用int方便两次二分的判断
	int cnt=0,sum=0;
	for(int i=1;i<=n+1;i++){
		sum+=x[i];
		if(sum<0)sum=0;//题目中说明了若已写代码行数小于删除的行数则视为全部删除
		if(sum>=mid)cnt++,sum=0;//写完一题则舍弃之前的代码。
	}
	return cnt;
}
signed main(){
	n=read();m=read();
	for(int i=1;i<=n;i++)x[i]=read(),r+=abs(x[i]);//因为k可能=1，此时n可能为总代码长度。
    r++;//由于个人习惯l+1<r，所以二分之前r必须加1(具体可百度各种二分写法，一些博客中会有说明)
	while(l+1<r){//个人习惯写法
		int mid=l+r>>1;
		if(check(mid)>=m)l=mid,ans=l;
		else r=mid;
	}
	if(ans==0){
		puts("-1");
		return 0;
	}//第一种无解情况
	l=0;//由于最后输出的是r，所以如果l=1，而答案n正好是1，会得不到正确答案
	while(l+1<r){
		int mid=l+r>>1;
		if(check(mid)==m)r=mid;
		else l=mid;
	}
	if(r>ans){
		puts("-1");
		return 0;
	}//第二种无解情况
	printf("%lld %lld",r,ans);
	return 0;
}
```
[blog推销](https://www.luogu.com.cn/blog/pidan12321/)

---

## 作者：jins3599 (赞：3)

挺显然的一道二分答案。

因为题目中给定的$k$关于$n$的函数不是严格单调的，而是类似于阶梯分布的不严格单调递减关系。

因此传统的二分写法在这里失效了。

并且题目用已经给了提示，让分别求出最大值和最小值，那么我们只需要写两个二分答案即可。

第一个二分求最小值，具体是这样的：

我们设函数`calc(x)`为计算当$n=x$时的$k$值。

若此时计算出的$k'\le k$，我们就让这个$x$往小了找。（因为是单调减的）,此时若$k'=k$，我们就可以统计一下答案。

这样为什么可以求到最小值？我们考虑我们每一次可以贡献的答案，他贡献了之后都是向小的方向继续二分，也就是说最后二分的终点就是最小值。

最大值同理。

$Code:$

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ll long long
#define inf 1e15

using namespace std;

const int N = 100000 + 5;
ll n , k , a[N];
ll l , r;

ll calc(ll x) {
	ll sum = 0 , tot = 0;
	for(int i = 1; i <= n ; i ++) {
		sum += a[i];
		sum = max(0ll , sum);
		if(sum >= x) {tot ++; sum = 0;}
	}
	return tot;
}

int main () {
	scanf("%lld %lld" , &n ,&k);
	for(int i = 1 ; i <= n ; i ++) scanf("%lld" , a + i);
	l = 1 , r = inf;
	ll maxx = -inf , minn = inf;
	while(l <= r) {
		ll mid = (l + r) >> 1;
		ll tmp = calc(mid);
		if(tmp >= k) {
			l = mid + 1;
			if(tmp == k) maxx = max(mid , maxx);
		} else r = mid - 1;
	}
	l = 1 ; r = inf;
	while(l <= r) {
		ll mid = (l + r) >> 1;
		ll tmp = calc(mid);
		if(tmp > k) l = mid + 1;
		else {
			if(tmp == k) minn = min(mid, minn);
			r = mid - 1;
		}
	}
	if(maxx == -inf || minn == inf) {puts("-1");return 0;}
	printf("%lld %lld" , minn , maxx);
	return 0;
}
```

---

## 作者：KagurazakaLorna (赞：2)

其实个人觉得没有蓝题的难度，~~虽然我写挂了很多次~~...

笔者在阅读题解的时候，看见了许多对于最大值和最小值分别进行二分的写法。

但是笔者身为一个juruo，当然有juruo的做法，虽然也是二分...

首先我们可以二分答案求出最大值...dalao们都讲得十分详细了，这里就不多赘述了，至于Check的话，O(n)模拟一遍就可以了。

在求解最小值的时候，我们可以求解切掉k+1道题目的时候n的最大值，那么将这个结果加上1，就是我们需要的最小值。

需要注意的有以下~~几点~~：

1. 一般的二分答案，我们可以是一开一闭，将答案存储在闭的那一侧，但是这一题需要注意的是，切掉的题目必须恰好为k道。但是当n改变了1 (n+1或n-1) 时，切掉的题目k的改变量可能大于1。(也就是说，k的改变不是连续的，~~虽然不连续的情况似乎很少~~)，所以我们需要进行判断仅在mid==m的时候记录答案。

1. 在求解最小值（即切掉k+1道题目的最大值）的时候，如果返回-1，则说明我们需要的答案是n可能的最小值，也就是1 (n>0)

1. 当最大值返回-1的时候，即问题无解，不要忘记输出-1并且结束程序哦~（卖萌）

juruo丑陋的代码：
```cpp
#include <bits/stdc++.h>
#define MAXN 100010
using namespace std;
int n,m,num[MAXN];
int Check(long long limit) {
    long long sum=0; int cnt=0;
    for (int i=1;i<=n;++i) {
    	sum+=num[i];
    	if (sum<0) {sum=0; continue;}
    	if (sum>=limit) ++cnt,sum=0;
    }
    return cnt;
}
long long BinarySearch() {
    long long head=0,tail=LLONG_MAX;
    long long ans=-1;
    while (head+1<tail) {
        long long mid=(head+tail)>>1;
        int cnt=Check(mid);
        if (cnt==m) ans=mid;
        if (cnt>=m) head=mid; else tail=mid;
    }
    return ans;
}
int main() {
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;++i) scanf("%d",&num[i]);
    long long maxans=BinarySearch();
    if (maxans==-1) {puts("-1"); return 0;}
    ++m;
    long long minans=BinarySearch()+1;
    if (minans==0) ++minans;
    cout<<minans<<' '<<maxans<<endl;
    return 0;
}
```

---

## 作者：jinhaoxian (赞：1)

又做了一道~~很水的~~蓝题，写篇题解    
本题其实就是一道基本的二分查找，用两次二分，一次求最小值，一次求最大值，就能AC了    
注意：变量要用long long，不用会一堆点WA~~（我第一次提交就这么被坑了，60分)~~    
上代码：
```
#include<bits/stdc++.h>
using namespace std;
long long l,r,mid,m,k,ans,x[1000000],i,s,t;
long long max(long long a,long long b)//为了程序方便，后面会用到max(0,变量)，但是因为变量类型是long long会出错，所以自己编了一个
{
    if (a>b) return a;
    else return b;
}
int main()
{
    cin>>m>>k;
    for (i=1;i<=m;i++)
    {
        cin>>x[i];
        r+=max(0,x[i]);
     } 
    l=1;//答案区间内最小值和最大值（左右边界）
    mid=(l+r)/2;ans=-1;//ans赋初值-1
    while (l<=r)//二分查找确定n是否存在并得到最小值
    {
        mid=(l+r)/2;
        s=0;t=0;
        for (i=1;i<=m;i++)//模拟确定n是否可以等于mid并且确定要往左或往右搜索
        {
            t=max(0,t+x[i]);
            if (t>=mid)
            {
                s++;
                t=0;
            }
        }
        if (s>k) l=mid+1;
        if (s==k) ans=mid;
        if (s<=k) r=mid-1;
    }
    cout<<ans<<' ';
    if (ans==-1) return 0;
    l=1;
    for (i=1;i<=m;i++)  r+=max(0,x[i]);
    mid=(l+r)/2;ans=-1;
    while (l<=r)//第二次二分查找寻找最大值
    {
        mid=(l+r)/2;
        s=0;t=0;
        for (i=1;i<=m;i++)
        {
            t=max(0,t+x[i]);
            if (t>=mid)
            {
                s++;
                t=0;
            }
        }
        if (s>=k) l=mid+1;
        if (s==k) ans=mid;
        if (s<k) r=mid-1;
    }
    cout<<ans;//输出
    return 0;
}
```

---


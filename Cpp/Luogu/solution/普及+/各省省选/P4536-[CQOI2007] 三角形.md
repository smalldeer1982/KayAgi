# [CQOI2007] 三角形

## 题目描述

画一个等边三角形，把三边的中点连接起来，得到四个三角形，把它们称为 $T_1,T_2,T_3,T_4$，如图1。

把前三个三角形也这样划分，得到 $12$ 个更小的三角形，$T_{11},T_{12},T_{13},T_{14},T_{21},T_{22},T_{23},T_{24},T_{31},T_{32},T_{33},T_{34}$，如图2。

把编号以 $1,2,3$ 结尾的三角形又继续划分……最后得到的分形称为 Sierpinski 三角形。

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

如果三角形 $B$ 不包含三角形 $A$，且 $A$ 的某一条完整的边是 $B$ 的某条边的一部分，则我们说 $A$ 靠在 $B$ 的边上。例如 $T_{12}$ 靠在 $T_{14}$ 和 $T_4$ 上，但不靠在 $T_{32}$ 上。

给出 Spierpinski 三角形中的一个三角形，找出它靠着的所有三角形。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 50$。

## 样例 #1

### 输入

```
T312```

### 输出

```
T314
T34
T4```

# 题解

## 作者：RedreamMer (赞：12)

### P4536题解

思路：模拟

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

### Solution

因为三角形只有三边，所以与它相邻的三角形的个数不会大于3，那或许有人会问，图2中"T4"不是靠在周围的6个三角形上吗？

>题目中说：如果B不包含A，且A的某一条完整的边是B的某条边的一部分，则我们说A靠在B的边上。

也就是说，三角形只能靠在比自己大的三角形上。

然后我们可以这样来考虑：

如果是以三角形编号为"T...4"，那与他相邻的一定是"T...1"、"T...2"、"T...3"。

否则，我们首先可以保证这个三角形的编号里不会出现"4"，我们可以从编号的第一位（不是"T"）开始：

1. 如果这一位上的数字为"1"，则它靠**下面**的三角形就是"T...4";

2. 如果这一位上的数字为"2"，则它靠**右边**的三角形就是"T...4"；

3. 如果这一位上的数字为"3"，则它靠**左边**的三角形就是"T...4"；

如果没有更新靠在某一边上的三角形，那原靠在那条边上的三角形就一直靠在边上。

不断一位一位更新靠在这个三角形边上的三角形，最后即为答案。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s,ss[3];
int len;
int main() {
	cin>>s;
	len=s.size()-1;
	if(s[len]=='4') {//特判末尾是不是特殊的三角形 
		cout<<s.substr(0,len)<<1<<endl<<s.substr(0,len)<<2<<endl<<s.substr(0,len)<<3;
		return 0;
	}
	for(int i=1; i<=len; i++) {
		if(s[i]=='1')
			ss[0]=s.substr(0,i)+"4";//更新靠在下面的三角形 
		else if(s[i]=='2')
			ss[1]=s.substr(0,i)+"4";//更新靠在左边的三角形 
		else if(s[i]=='3')
			ss[2]=s.substr(0,i)+"4";//更新靠在右边的三角形 
	}
	sort(ss,ss+3); 
	for(int i=0; i<=2; i++)
		if(ss[i][0]=='T')//判断这条边上有没有三角形靠着 
			cout<<ss[i]<<endl;
	return 0;
}
```
#### [$\color{blue}\text{My Blog}$](https://www.luogu.com.cn/blog/184549/)

---

## 作者：xiaozeyu (赞：8)

这道题目就是找规律

首先当最后一位为4时，就是在当前层与其余三个相邻，要特判

```cpp

if(s[x-1]=='4')
	{
		for(i=1;i<=3;i++)
		{
			for(j=0;j<x-1;j++)
			{
				printf("%c",s[j]);
			}
			printf("%d\n",i);
		}
		return 0;
	}
```
其他的要继续处理

找规律：

发现在最后一位都可以与当前层中间的4相邻，直接输出

倒着搜，根据画图找规律，发现有两位是相同时，一定是在某一个角落里面，这时也要特判，于是就有了基础的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int x,i,j;
char s[55];
int main()
{
	gets(s);
	x=strlen(s);
	if(s[x-1]=='4')
	{
		for(i=1;i<=3;i++)
		{
			for(j=0;j<x-1;j++)
			{
				printf("%c",s[j]);
			}
			printf("%d\n",i);
		}
		return 0;
	}
	else
	{
		for(i=0;i<x-1;i++)
		{
			printf("%c",s[i]);
		}
		printf("4\n");
		for(i=x-2;i>=1;i--)
		{
			bool f=true;
			for(j=i+1;j<=x-1;j++)
			{
				if(s[i]==s[j])
				{
					f=false;
					break;
				}
			}
			if(f)
			{
				for(j=0;j<i;j++)
			    {
				    printf("%c",s[j]);
			    }
			    printf("4\n");
			}
		}
	}
	return 0;
}

```
虽然能AC

但如果你愿意好好寻找，你会发现更优的一种方法

你会发现，一个三角形最多与三个符合的三角形相邻（有三条边，相邻边是大于等于自己的）

你还可以发现，**一个三角形相邻的三角形中，最后的数字永远不会重复**，这是重点，最后只会是1,2,3,4，且每个最多一次，当每个数第一次遇到时，都是与当前层的4相邻的，将该层换成4输出

只要倒着便利，如果都碰到了直接退出，进阶代码如下
```cpp
for(int j=len-1;j>0;j--)
	{
		if(!flag[a[j]-'0'])
		{
			for(int i=0;i<j;i++)
			{
				cout<<a[i];
			}
			cout<<"4"<<endl;
			flag[a[j]-'0']=true;
		}
		if(flag[1]&&flag[2]&&flag[3])
			break;
	}

```
完全代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[11000];
bool flag[5];
int main()
{
	memset(flag,false,sizeof(flag));
	cin>>a;
	int len=strlen(a);
	if(a[len-1]=='4')
	{
		for(int i=1;i<=3;i++)
		{
			for(int j=0;j<len-1;j++)
				cout<<a[j];
			cout<<i<<endl;
		}
		return 0;
	}
	for(int j=len-1;j>0;j--)
	{
		if(!flag[a[j]-'0'])
		{
			for(int i=0;i<j;i++)
			{
				cout<<a[i];
			}
			cout<<"4"<<endl;
			flag[a[j]-'0']=true;
		}
		if(flag[1]&&flag[2]&&flag[3])
			break;
	}
	return 0;
}

```
还有一种更高深的写法：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
char s[105],a[4][105],ch;
int l,x,fl,u,v,l1,l2;
void get(int p,int l)
{
	if (!l) return;
	if (s[l]=='4'){
		x++;
		for (int i=0;i<l;i++) a[x][i]=s[i];
		a[x][l]=p+'0';
		return;
	}
	if (s[l]-'0'==p){
		x++;
		for (int i=0;i<l;i++) a[x][i]=s[i];
		a[x][l]='4';
		return;
	}
	get(p,l-1);
}
int main(){
	scanf("%s",&s);
	x=0;
	l=strlen(s)-1;
	get(1,l);
	get(2,l);
	get(3,l);
	for (int i=1;i<=x;i++)
		for (int j=i+1;j<=x;j++)
		{
			l1=strlen(a[i]);
			l2=strlen(a[j]);
			u=v=0;
			fl=0;
			for (;u<l1&&v<l2;u++,v++)
			{
				if (a[i][u]>a[j][v]){fl=1; break;}
				if (a[i][u]<a[j][v]){fl=0; break;}
			}
			if (fl)
			{
				u=0;
				for(;u<l1||u<l2;u++){
					ch=a[i][u]; a[i][u]=a[j][u]; a[j][u]=ch;
				}
			}
		}
	for (int i=1;i<=x;i++) printf("%s\n",a[i]);
	return 0;
}
```

---

## 作者：AE酱 (赞：7)

### 本题题目描述有误，“例如T12靠在T24和T4上”应改为“例如T12靠在T14和T4上”，T12和T24根本不相邻。

## Solution
因为三角形只有3条边，通过观察图象，易得一个三角形最多只会靠着3个三角形。
设 DFS(ID,A,B,C) 表示编号为ID的三角形三条边分别靠着A,B,C。
A表示该三角形左边靠着的三角形。
B表示该三角形右边靠着的三角形。
若该三角形为正三角，则C表示该三角形下边靠着的三角形。
若该三角形为倒三角，则C表示该三角形上边靠着的三角形。
若该边没有靠着三角形，则表示为0，对于ID、A、B、C，我们均用字符串保存。

假设当前已经找到三角形编号为ID，
若下一次递归的编号为1，则A、B不变，C改变，即
```cpp
ID+="1"，C=ID,C[C.size()-1]='4';
```
若下一次递归的编号为2，则A、C不变，B改变，即
```cpp
ID+="2"，B=ID,B[B.size()-1]='4';
```
若下一次递归的编号为3，则B、C不变，B改变，即
```cpp
ID+="3"，A=ID,A[A.size()-1]='4';
```
若下一次递归的编号为4，则ABC均改变。
递归地找即可。

## Code
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <vector>
using namespace std;
string ID,A,B,C,S;
int Len;
vector<string> Ans;
void DFS(int pos){
	if(pos>Len) return;
	if(S[pos]=='4'){
		ID+="4";
		int IDS=ID.size()-1;
		A=ID;A[IDS]='2';
		B=ID;B[IDS]='3';
		C=ID;C[IDS]='1';
		DFS(pos+1);
	}
	else if(S[pos]=='1'){
		ID+="1";
		C=ID;C[C.size()-1]='4';
		DFS(pos+1);
	}
	else if(S[pos]=='2'){
		ID+="2";
		B=ID;B[B.size()-1]='4';
		DFS(pos+1);
	}
	else if(S[pos]=='3'){
		ID+="3";
		A=ID;A[A.size()-1]='4';
		DFS(pos+1);
	}
	return;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>S;
	Len=S.size();
	ID=S[1];
	if(S[1]=='1'){A='0';B='0';C='4';}
	else if(S[1]=='2'){A='0';B='4';C='0';}
	else if(S[1]=='3'){A='4';B='0';C='0';}
	else if(S[1]=='4'){A='2';B='3';C='1';}
	DFS(2);
	if(A!="0"){string mid="T"+A;Ans.push_back(mid);}
	if(B!="0"){string mid="T"+B;Ans.push_back(mid);}
	if(C!="0"){string mid="T"+C;Ans.push_back(mid);}
	sort(Ans.begin(),Ans.end());
	for(int i=0;i<Ans.size();i++)
		cout<<Ans[i]<<endl;
	
	return 0;
}
```

---

## 作者：Fire_flame (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P4536)

# 分析

首先当末位为 $4$ 时，与其相邻的四个三角形分别就是把末尾分别改成 $1,2,3$ 即可。

```cpp
if(s[s.length()-1]=='4'){
	for(int i=0;i<s.length()-1;i++)cout<<s[i];
	cout<<1<<endl;
	for(int i=0;i<s.length()-1;i++)cout<<s[i];
	cout<<2<<endl;
	for(int i=0;i<s.length()-1;i++)cout<<s[i];
	cout<<3<<endl;
}
```

如果末尾不是 $4$ 考虑以下情况：

$1.$ 如果这个串里只有 $1$ 种数字，那么它一定在某个角上，只和自己这层的 $4$ 相邻。

$2.$ 如果这个串里有 $2$ 种数字，那么他在某条边上，和某层的 $4$ 相邻，和自己的中心相邻。

$3.$ 如果这个串里有 $3$ 种数字，那么它在大三角形里面，和这层的 $4$，某层的 $4$，另一层的 $4$ 都相邻。

更进一步我们发现：这个串内有几种不同的数字，就和几个三角形相邻，并且一定以 $4$ 结尾。

最后只要从后往前扫，在第一次出现的数字时，数字前的子串后面 $+4$ 即是个答案

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int k;
int a[5];
string ans[4];
int main(){
	cin>>s;
	if(s[s.length()-1]=='4'){
		for(int i=0;i<s.length()-1;i++)cout<<s[i];
		cout<<1<<endl;
		for(int i=0;i<s.length()-1;i++)cout<<s[i];
		cout<<2<<endl;
		for(int i=0;i<s.length()-1;i++)cout<<s[i];
		cout<<3<<endl;
	}
	else{
		for(int i=0;i<s.length();i++){
			if(s[i]=='1')ans[1]=s.substr(0,i)+"4";
			if(s[i]=='2')ans[2]=s.substr(0,i)+"4";
			if(s[i]=='3')ans[3]=s.substr(0,i)+"4";
		}
	}
	sort(ans+1,ans+4);
	for(int i=1;i<=3;i++){
		if(ans[i].length())cout<<ans[i]<<endl;
	}
	return 0;
}
```


---

## 作者：Light_Knight (赞：4)

# 思路
显然，末尾是 $4$ 的三角形在图中都是倒立的，它们只会靠在和自己前缀相同且末尾数字为 $1, 2, 3$ 的三角形上。

剩下的三角形，最多只会靠在它**左、右、下**方各一个大于等于它的三角形上（可能某一侧没有三角形，因此数量 $\leq 3$）。

以题目中的 $T_{12}$ 为例，我们思考一下：

因为 $T_{12}$ 在 $T_1$ 的**左下角**，我们能得到两条信息：

1. $T_{12}$ 左靠和下靠的三角形就是 $T_1$ 左靠和下靠的三角形。
2. $T_{12}$ 包含在 $T_1$ 里，所以 $T_{12}$ 右靠的三角形只能是比 $T_1$ 小、和 $T_{12}$ 同一等级的、位于 $T_1$ 中央的 $T_{14}$。

发现了吗？一个三角形可以由比它高一级的三角形（即编号少了它的最后一位的三角形）获得，用三角形的编号来说，就是

$$T_{abc} = T_{ab} + T_{ab4}$$

递归代码也就呼之欲出啦！

### Tips. 一个小优化
如果一个三角形一直在某个大三角形的左下角的左下角的左下角...... 那么，只需要由最大的那个三角形获得即可，也就是把末尾连续的相同编号都省略。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string str,ans[3];  int len;
void find(string s,int l){
	if(!ans[3+'0'-s[l]].length()) //只有未被更新过的才更新
		ans[3+'0'-s[l]] = s.substr(0,l)+"4"; //这里是由编号1、2、3->答案下标（左0、右1、下2）
	int t = l;
	while(s[t] == s[l]) t--;
	if(t == 0){  //边界
		sort(ans,ans+3);
		for(int i = 0;i < 3;i++){
			if(ans[i].length()) cout << ans[i] << '\n';
		}
		exit(0);
	}
	find(s.substr(0,t+1),t); 
}
int main(){
	cin >> str;  len = str.length()-1;
	if(str[len] == '4'){
		for(int i = 1;i <= 3;i++){
			cout << str.substr(0,len) << i << '\n';
		}
		return 0;
	}
	find(str,len);
	return 0;
}
```


---

## 作者：Engulf (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4536)

[更好的阅读体验](https://www.luogu.com.cn/blog/t-m-j-y-h-0-9/solution-p4536)

## 分析

这是道典型的分类讨论找规律题。

第一个比较明显的规律就是：若输入的字符串的最后一个字符是 $4$，那么它一定跟同一层的 $1$、$2$、$3$ 这几个三角形接壤。

接下来分类讨论三角形的位置。

### I. 三角形在角上

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

上图的 $T_{11}$、$T_{22}$、$T_{33}$ 就是在角上的三角形，可以看到它仅和同层的 $4$ 接壤。

### II. 三角形在边上

上图的 $T_{12}$ 就是在边上的三角形。

可以看出，它接壤 $2$ 个三角形，一个是同层的 $4$，还有一个是什么呢？

可以发现，在边上的三角形的编号只有 $2$ 个不同的数字，除去第一个，后面的数字是不断重复的，无论重复多少个，都**不会**影响和它接壤的 $4$，这个 $4$ 就是第一个数字编号那层的 $4$ 号三角形。

### III. 三角形在内部

及不在边上的三角形，例如 $T_{132}$。

可以看出，在内部的三角形和 $3$ 个三角形接壤，包括同层的和其他层的 $2$ 个 $4$ 号三角形。

在内部的三角形编号只有 $3$ 个不同的数字。

显然的，重复的数字是不会影响结果，所以我们可以筛掉重复的数字，然后每个数字的那层 $4$ 号三角形都会接壤。

---

## 作者：PanH (赞：2)

蒟蒻的第一篇题解，求过

这道题是本机房模拟赛的最后一题，当时只做了第一题，~~第二三题都好复杂，看不懂~~，于是就来到了这题...

~~其实这道题并不难~~，手玩一下，找找规律，多动动脑子就出来了。

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

从图上看，T1与T4相邻，这是显而易见的。再看小一点的，拿T12来说，它与T4和
T14相邻。我们把T1的边标记一下，记下面的边为a1，,右边的边为b1，左边的边
为c1，同理，标记T12的边为a12，b12，c12，则a1与a12重合，c1与c12重合，只有b12有点不同，也就是说我们只需要更新T12在右侧的边相邻的三角形，其他的直接可以从上一个大的继承过来，其他三角形也是一样的道理。

对于最后一位是4的三角形（如T1234），只须一个特判就能搞定了。

下面是代码：
```
#include<bits/stdc++.h>
using namespace std;
string s,ss,ans[4];
int P[100];
int main()
{
	cin>>s;
	P['1']=1,P['2']=2,P['3']=3;
	for(int i=1;i<s.size();i++)
	{
		ss+=s[i-1];
		ans[P[s[i]]]=ss+"4";
		if(s[i]=='4')
			ans[1]=ss+"1",ans[2]=ss+"2",ans[3]=ss+"3";
	}
	sort(ans+1,ans+4);
	for(int i=1;i<=3;i++)
		if(ans[i]!="\0")
			cout<<ans[i]<<endl;
	return 0;
}
```
（码风略丑，见谅）

最后，在机房某位大佬的启示下，发现这道题还可以反着看，这样也很好懂，大家可以思考一下。

---

## 作者：_jimmywang_ (赞：2)

### $2020.2.28$ 题解 $P4536$【$[CQOI2007]$三角形】

这题……真的是省选吗？

------------


首先，有一个很重要的性质！！！

观察这幅图（题目里的）：
![](https://cdn.luogu.com.cn/upload/pic/18501.png)

每个三角形最多与$3$个三角形相邻！！！

#### 理论解释：

首先我们知道，
```
如果B不包含A，且A的某一条完整的边是B的某条边的一部分，则我们说A靠在B的边上
     ---P4536 [CQOI2007]三角形

```
解读这句话：$A$的某一条完整的边是B的某条边的一部分

对于三角形$A$：
### $1:$
有三条边（废话）
### $2:$
每条边都（可能）有一个三角形$B$与$A$相邻，根据定义，B的边长≥A的边长。所以A的这条边上不可能再有别的与$A$相邻的三角形（重要！！）

$===>$那么就是说每条边上最多只有1个三角形与它相邻
### $3:$
那么最多只有$3$个三角形与它相邻啊！！！

这样一分析，哇！水题！！


------------


再分析第二步：

还是这张图：
![](https://cdn.luogu.com.cn/upload/pic/18501.png)

$Txxx4$与$Txxx1,Txxx2,Txxx3$相邻，然后没了（有$3$个了，$return$掉结束）

$Txxx1/Txxx2/Txxx3$与$Txxx4$相邻。

还有一种特殊情况：有的三角形一条或两条边在边界上（像$T12$与$T11$）就会少于三个。

于是乎如果有一个数字出现多次，就$continue$掉了

$Code:$
```
#include<algorithm>
#include<bitset>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<map>
#include<iostream>
#include<queue>
#include<set>
#include<stack>
#include<string>
#include<vector>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
inline ll rr() {
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	if(c=='-')f=-1,c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return x*f;
}
#define d rr()
ll cmp;
bool fl[5]; 
string s[100010],k;
char opt;
int main() {
	char c;
	cin>>c>>k;
	while(k.size()){
		if(cmp==3){
			break;
		}
		string qqq;
		if(k[k.size()-1]!='4'){
			if(!fl[k[k.size()-1]-'0']){
				cmp++;
				s[cmp]+='T';
				s[cmp]+=k;
				s[cmp][s[cmp].size()-1]='4';
			}
		}
		else{
			cmp++;
			s[cmp]+='T';
			s[cmp]+=k;
			s[cmp][s[cmp].size()-1]='1';
			cmp++;
			s[cmp]+='T';
			s[cmp]+=k;
			s[cmp][s[cmp].size()-1]='2';
			cmp++;
			s[cmp]+='T';
			s[cmp]+=k;
			s[cmp][s[cmp].size()-1]='3';
			sort(s+1,s+cmp+1);
			cout<<s[1];
			for(int i=2;i<=cmp;i++)cout<<endl<<s[i];
			return 0;
		}
		fl[k[k.size()-1]-'0']=1;
		for(int i=0;i<k.size()-1;i++)qqq+=k[i];
		k=qqq;
	}
	sort(s+1,s+cmp+1);
	cout<<s[1];
	for(int i=2;i<=cmp;i++)cout<<endl<<s[i];
    return 0;
}
```
谢谢！！

---

## 作者：happybob (赞：1)

## 题意

Sierpinski 三角形按照如题意所述分裂，问与某个三角形有共边的所有三角形。

![https://cdn.luogu.com.cn/upload/pic/18501.png](https://cdn.luogu.com.cn/upload/pic/18501.png)

## 解法

我们不难观察出这题只需分类讨论。

1. 当末尾是 $4$ 时，例如 `Taaaaa4`，那么与之有共边的有 `Taaaaa1`、`Taaaaa2`、`Taaaaa3`。

1. 当这个字符串中只有一种不同的从 $1$ 到 $4$ 的数字，例如 `T111` 和 `T112`、`T113`，那么与之有共边的有只有 `T114`。

1. 对于其他，我们只需要遍历整个字符串，找到 $1$、$2$、$3$ 一个最后出现的位置，并将这个位置改成 $4$ 即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 15;

string s, ans[N];
unordered_map<char, bool> mp;

int main()
{
	cin >> s;
	s.erase(s.begin());
	int len = s.size();
	for (int i = 0; i < s.size(); i++) mp[s[i]] = true;
	int tot = mp['1'] + mp['2'] + mp['3'] + mp['4'];
	if (s == "1")
	{
		printf("T4\n");
	}
	else if (s == "2")
	{
		printf("T4\n");
	}
	else if (s == "3")
	{
		printf("T4\n");
	}
	else if (s.back() == '4')
	{
		s.erase(--s.end());
		cout << "T" << s;
		cout << "1\n";
		cout << "T" << s;
		cout << "2\n";
		cout << "T" << s;
		cout << "3\n";
	}
	else
	{
		if (tot == 1)
		{
			s.erase(--s.end());
			cout << "T" << s << "4\n";
			return 0;
		}
		for (int i = 0; i < len; i++)
		{
			if (s[i] == '1') ans[1] = s.substr(0, i);
			else if (s[i] == '2') ans[2] = s.substr(0, i);
			else if (s[i] == '3') ans[3] = s.substr(0, i);
		}
		sort(ans + 1, ans + 4, greater<string>());
		for (int i = 1; i <= 3; i++)
		{
			cout << "T" << ans[i] + "4\n";
		}
	}
	return 0;
}
```


---

## 作者：LlLlCc (赞：1)

今天考试的T4，手玩了快一个小时才推出来，觉得很有意思

首先，手玩几个数据，有一个显而易见的结论，对于每一个三角形，如果这个三角形的末尾字符是$4$,那么与它相邻的三角形一定满足$s[1]$ ~ $s[n-1]$与这个三角形相等，末尾字符为$1,2,3$。而如果末尾字符不是$4$，那么，与它相邻的三角形末尾定是$4$,且前缀$s[1]~s[n-1]$与这个三角形相等

因此，对于末尾字符为$4$的三角形，我们可以直接特判，$\dfrac{1}{4}$的分就拿到手了

现在我们考虑其他三种情况，末尾字符为$1,2,3$的三角形。因为这三个三角形性质一样，所以我们只要考虑其中一个就行

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

PS：直接盗图

以末尾是$2$的为例，易得，$T21,T22,T23$与$T24$相邻，同样的，$T11,T12,T13$也与$T14$相邻，$T31,T32,T33$也与$T34$相邻，即$TXXX1$，$TXXX2$ , $TXXX3$与$TXXX4$相邻

继续以末尾是$2$的为例，易得，$T21,T23$与$T4$相邻，而$T22$不与$T4$相邻。

为什么呢？

抽象的理解一下，如果是$2$，就等于向左下方向走了一步，所以距离是$1$，也就是相邻，而如果再走一步，那么距离就变成了$2$，那么就不是相邻的了。也就是说如果目前位置，之后序列同一个数出现了大于一次，就是与这个三角形不相邻的

思维题，很妙，详见代码：
```
#include<bits/stdc++.h>
#define maxn 105
using namespace std;
char s[maxn];
int n,a[maxn];
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	if (s[n]=='4'){
		for (int i=1;i<n;i++) printf("%c",s[i]);printf("1\n");
		for (int i=1;i<n;i++) printf("%c",s[i]);printf("2\n");
		for (int i=1;i<n;i++) printf("%c",s[i]);printf("3\n");
		return 0;
	}
	for (int i=1;i<n;i++) printf("%c",s[i]);printf("4\n");
	a[s[n]-'0']++,a[s[n-1]-'0']++;
	for (int i=n-2;i;i--){
		if (a[s[i+1]-'0']<=1){for (int j=1;j<=i;j++) printf("%c",s[j]);printf("4\n");}
		if (i>1) a[s[i]-'0']++;
	}
	return 0;
}
```


---

## 作者：Wuyanru (赞：1)

~~本人第一道二十分钟做出来的紫题。~~

题目链接：[点击查看](https://www.luogu.com.cn/problem/P4536)

这道题我在做的时候第一眼没有什么思路，但是稍微分析一下就可以知道本题使用递归做的。

我在做的时候用到了两个条件：当前进行扫描的三角形和寻找的方向。

其中方向为 $ 3 $ 表示左边，方向为 $ 2 $ 表示右边，方向为 $ 1 $ 表示下边（如果是倒三角表示上边）。

放出函数：
```
string find(string in,int c) {
	char ch=in[1];
	int flag=1;
	for(unsigned i=2; i<in.size(); i++)
		if(ch!=in[i]) {
			flag=0;
			break;
		}
	if(flag==1&&ch-'0'!=c&&ch!='4') {
		string ans;
		return ans;
	}
	if(in[in.size()-1]=='4') {
		in[in.size()-1]=c+'0';
		return in;
	}
	if(in[in.size()-1]==c+'0') {
		in[in.size()-1]='4';
		return in;
	}
	in.resize(in.size()-1);
	return find(in,c);
}
```
下面我们一步一步从最简单的开始分析。

首先是函数的返回，使用string类型来记录答案，不用多说什么，因为你不管用什么整数类型来存都会溢出，使用string不仅不会溢出，输出也十分方便。

然后是第一个部分：
```
	char ch=in[1];
	int flag=1;
	for(unsigned i=2; i<in.size(); i++)
		if(ch!=in[i]) {
			flag=0;
			break;
		}
	if(flag==1&&ch-'0'!=c&&ch!='4') {
		string ans;
		return ans;
	}
```
这个部分用来判断三角形编号所有位是否为同一个数字，如果是这样的话这个三角形一定是在大三角的某一个角上，这时如果寻找的答案很可能不存在，这时返回一个空串。

其中特判 $ num $ 不等于 $ 4 $ 是因为会有寻找的三角形编号为 T4 的情况。

再来看第二个部分：
```	
	if(in[in.size()-1]=='4') {
		in[in.size()-1]=c+'0';
		return in;
	}
```
这一个部分表示判断这个三角形是否在所在三角形的中央（即判断这个三角形是不是倒着的），如果是这样的话所需要的答案就只需要将编号最后一位更改即可。

然后看第三个部分：
```
	if(in[in.size()-1]==c+'0') {
		in[in.size()-1]='4';
		return in;
	}
```
这个地方也是相当好理解，也就是特判寻找的三角形是不是每个三角形中间的倒三角形，如果是这样的话把最后一位修改即可。

最后来看最后一个部分：
```
	in.resize(in.size()-1);
	return find(in,c);
```
我们已经把所有特殊情况排除了，剩下的就是最普通的情况了，这个普通的情况就是三角形的旁边是一个比自己要打的三角形。

第一行代码的意思就是把编号最后一位扣掉，得到这个三角形的父三角形（我实在不知道应该叫什么了），这之后寻找的方向不变，就可以递归得到答案。

本题中最不好想的递归程序已经写完了，最后就剩排序与输出了。

函数用库中写好的快排就可以了，不过还要写一个函数。

排序判断函数：
```
bool cmp(string a,string b) {
	for(unsigned i=0;; i++) {
		if(a.size()<=i)
			return false;
		if(b.size()<=i)
			return true;
		if(a[i]<b[i])
			return true;
		if(a[i]>b[i])
			return false;
	}
}
```
这样子就可以将其按照字典序排序，按我的做法不排序能拿 $ 80 $ 分。

最后愉快地进行输出，这一道题就做完了。

AC代码：

```
#include<algorithm>
#include<iostream>
#include<string>
#include<cstdio>
using namespace std;
string ans[3];
string in;
bool cmp(string a,string b) {
	for(unsigned i=0;; i++) {
		if(a.size()<=i)
			return false;
		if(b.size()<=i)
			return true;
		if(a[i]<b[i])
			return true;
		if(a[i]>b[i])
			return false;
	}
}
string find(string in,int c) {//愉快地递归
	char ch=in[1];
	int flag=1;
	for(unsigned i=2; i<in.size(); i++)
		if(ch!=in[i]) {
			flag=0;
			break;
		}
	if(flag==1&&ch-'0'!=c&&ch!='4') {
		string ans;
		return ans;
	}
	if(in[in.size()-1]=='4') {
		in[in.size()-1]=c+'0';
		return in;
	}
	if(in[in.size()-1]==c+'0') {
		in[in.size()-1]='4';
		return in;
	}
	in.resize(in.size()-1);
	return find(in,c);
}
int main() {
	cin>>in;
	ans[0]=find(in,1);
	ans[1]=find(in,2);
	ans[2]=find(in,3);
	sort(ans,ans+3,cmp);//排个序
	for(int i=0; i<3; i++)
		cout<<ans[i]<<endl;//记得换行
	return 0;
}
```
感谢观看！

---

## 作者：iorit (赞：1)

[原题](https://www.luogu.com.cn/problem/P4536)

这是我们学校%你赛上的一道题。然而赛时只有70pts qwq。

首先显然可以得到当给出的三角形编号尾号为 $4$ 时，仅有三个三角形与其相邻。

例如 $\texttt{T4}$ 仅与 $\texttt{T1,T2,T3}$ 相邻， $\texttt{T24}$ 仅与 $\texttt{T21,T22,T23}$ 相邻。

如果给出的三角形编号尾号不为 $4$，以 $\texttt{T313}$为例：

（这里为了方便说明，我们把尾号为 $4$ 的三角形称为中央三角形；把同样大小且仅有尾号不同的三角形称为同级三角形。）

![a](https://cdn.luogu.com.cn/upload/image_hosting/nwc84aoa.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

1. 首先 $\texttt{T313}$ 必定与同级的中央三角形 $T314$ 相邻。

2. 接着我们把 $\texttt{T313}$ 放在大一点的三角形 $\texttt{T31}$ 中看。可以得到 $\texttt{T31}$ 必定与同级的中央三角形 $\texttt{T34}$ 相邻，但是我们把 $\texttt{T31}$ 进一步细分，就只有 $\texttt{T312}$ 和 $\texttt{T313}$ 两个三角形与 $\texttt{T34}$ 相邻。所以 $\texttt{T313}$ 与 $\texttt{T34}$ 相邻。

3. 我们再把 $\texttt{T313}$ 放在更大的三角形 $\texttt{T3}$ 中看，虽然 $\texttt{T3}$ 与 同级的中央三角形 $\texttt{T4}$ 相邻，$\texttt{T31}$ 也与 $\texttt{T4}$ 相邻，但因为 $\texttt{T313}$ 在 $\texttt{T31}$ 的右下角，所以 $\texttt{T313}$ 不会与 $\texttt{T4}$ 相邻。

综上所述，我们可以得到结论：设$|A|$ 表示三角形 $A$ 的编号长度，$A_i$ 表示 $A$ 的第 $i$ 位编号，则有：

**原三角形 $S$ 与一个中央三角形 $T$ 相邻，当且仅当 $S$ 所在的与 $T$ 同级的中央三角形 $N$ 满足 $S_{|N|+1}$ 到 $S_{|S|}$ 均不等于 $N_{|N|}$。**

这个看起来挺绕的，但其实好好理解一下就可以发现这个结论很显然。

希望题解能帮助到大家。

### 代码

```cpp
const int N = 1e2 + 10;
string s;
string ans[N];
int cnt,len;
int check(int k , char ch) // k -> |S| + 1,ch -> N|N|.
{
	for(int i = len - 1;i > k;i--) // 验证S|N| 到 S|S| 均不等于 N|N|
		if(s[i] == ch)
			return false;
	return true;
}
int main()
{
	cin >> s;
	len = s.size();
	if(s[len - 1] == '4')
	{
		ans[++cnt] = s; // 与原三角形仅有最后一位编号不同 
		ans[cnt][len - 1] = '1';
		ans[++cnt] = s;
		ans[cnt][len - 1] = '2';
		ans[++cnt] = s;
		ans[cnt][len - 1] = '3';
	}
	else
		for(int i = len - 1;i >= 1;i--) // 小三角形到大三角形地枚举，当然也可以正着枚举
			if( check( i , s[i] ) )
			{
				ans[++cnt] = s.substr(0 , i + 1); // T1 ~ Ti-1的编号是与原三角形相同的 
				ans[cnt][i] = '4'; // 同级的中央三角形 T. 
			}
	sort(ans + 1 , ans + cnt + 1); // string默认按字典序排序 
	for(int i = 1;i <= cnt;i++)
		cout << ans[i] << endl;
    return 0;
}
```

---

## 作者：Terac (赞：0)

[**_原题_**](https://www.luogu.com.cn/problem/P4536)  

本题是一道找规律模拟的题目，做法有很多，找到规律后就不难。  

看到很多题解都是反着推的，这里写一篇正推的题解。

## 题意  

首先题面就有点晦涩难懂，题目建立在一个三角形的不断分割之中，这个看了图后是比较好理解的，题目中定义三角形所靠着的三角形为：  

+ 如果 B 不包含 A，且 A 的某一条完整的边是 B 的某条边的一部分，则我们说 A 靠在 B 的边上。  

配合这张图就比较好理解了。  

![](https://cdn.luogu.com.cn/upload/image_hosting/j1t4b30p.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)  

如图，对于 $\triangle\texttt{T122}$，它与 $\triangle\texttt{T124}$ 和 $\triangle\texttt{T4}$ 相邻，但它不与 $\triangle\texttt{T123}$ 和 $\triangle\texttt{T21}$ 相邻。  

对于 $\triangle\texttt{T31}$，虽然它有边是 $\triangle\texttt{T3}$ 的边的一部分，但因为 $\triangle\texttt{T3}$ 包含 $\triangle\texttt{T31}$，所以 $\triangle\texttt{T31}$ 不与 $\triangle\texttt{T3}$ 相邻。  

至于每个三角形的编号，大概是递归式的，每一个字符代表着四个部分中的一个，**其中4表示中间的三角形，显然只可能出现在末位**，然后下一个字符就继续分四个部分。

到这里，题意已经很明确了。  

## 思路  

$S$ 表示三角形编号的字符串，$len$ 表示字符串 $S$ 的长度，观察后我们发现该分形有以下性质：  

1. 若 $\triangle S$ 与 $\triangle S'$ 不相邻，$t$ 表示该三角形编号的一段后缀字符串，则 $\triangle S+t$ 和 $\triangle S'$ 不相邻。  
2. 若 $S_{len}=4$，则该三角形相邻的三角形仅为 $S_{len} \in \{1,2,3\}$ 时的 $\triangle S$。
3. 若 $S_{len}\neq4$，则该三角形必有一个三角形为 $S_{len}=4$ 时的 $\triangle S$ 与之相邻，且所有与该三角形相邻的三角形序号最后一个字符都为 $4$。  
4. 若 $\triangle S_{len}\in\{1,2,3\}$ 且 $S_{len-i} = S_{len}\ (i \in \left[1,len-1\right])$，令 $S'$ 为 $S_1$ 至 $S_{len-i-1}$ 组成的字符串且 $S'_{len-i}= 4$，则 $\triangle S$ 与 $\triangle S'$ 不相邻。  

有了以上性质，我们可以得出以下结论：  
+ 若给定的三角形编号末位字符为 $4$，根据性质 $2$，显然能求出与该三角形相邻的所有三角形。  
+ 若给定的三角形编号末位字符不为 $4$，循环遍历每一个字符，根据性质 $3$，每次均插入同级的中央三角形，再根据性质 $4$，还需要把已不相邻的三角形删除，其正确性可以通过性质 $1$ 证明。  

上述思路貌似很复杂，但只要多画图，多找规律，其实也是很容易理解的。  

接下来顺着结论模拟即可，我们扫了一遍字符串，每一个字符还要往回扫一遍删除，加上最后的排序，时间复杂度为 $O(n^2+n\log n)$。  

奉上代码。  

```cpp
#include <bits/stdc++.h>
using namespace std;
string s , t;
int n;
vector <string> ans;
void solve() {
	if(s[n] == '4') {//特判末位为4 
		t = s.substr(0 , n + 1); 
		t[n] = '1';
		ans.push_back(t);
		t[n] = '2';
		ans.push_back(t);
		t[n] = '3';
		ans.push_back(t);
		cout << ans[0] << "\n" << ans[1] << "\n" << ans[2] << "\n";
		return;
	}
	if(n == 1) {//因为后面从2开始循环，所以要特判1 
		cout << "T4" << "\n";
		return;
	}
	ans.push_back("T4");//初始时T4是相邻的，要先插入 
	for(int i = 2; i <= n; i ++) {
		for(int j = 1; j <= i - 1; j ++) 	
			if(s[i - j] == s[i])//如上述性质4，删除已不相邻的三角形 
				for(int k = 0; k < ans.size(); k ++) 
					if(ans[k][i - j] == '4') //末位为4即为该级的中央三角形 
						ans.erase(ans.begin() + k);
		t = s.substr(0 , i + 1);
		t[i] = '4'; 
		ans.push_back(t);
		t[i] = s[i];
	}
	sort(ans.begin() , ans.end());//按字典序排序 
	for(int i = 0; i < ans.size(); i ++) 
		cout << ans[i] << "\n";
}
int main() {
	ios::sync_with_stdio(false);
	cin >> s;
	n = s.size() - 1;
	solve();
	return 0;
}
```

---


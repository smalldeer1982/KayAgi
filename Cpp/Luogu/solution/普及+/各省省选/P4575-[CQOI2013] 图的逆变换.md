# [CQOI2013] 图的逆变换

## 题目描述

给一个 $n$ 结点 $m$ 条边的有向图 $D$，可以这样构造图 $E$：给 $D$ 的每条边 $(u,v)$，在 $E$ 中建立一个点 $uv$，然后对于 $D$ 中的两条边 $(u,v)$ 和 $(v,w)$，在 $E$ 中从 $uv$ 向 $vw$ 连一条有向边。$E$ 中不含有其他点和边。

输入 $E$，你的任务是判断是否存在相应的 $D$。

注意，$D$ 可以有重边和自环。

## 样例 #1

### 输入

```
4
2
1
0 1
5
0
4
3
0 1
2 1
2 3
3
9
0 1
0 2
1 2
1 0
2 0
2 1
0 0
1 1
2 2```

### 输出

```
Yes
Yes
No
Yes```

# 题解

## 作者：ix35 (赞：8)

大致思路就是：如果在图 D 中：$u\to v\to w$，又有 $x\to v\to w$，那么在 E 中，$uv$，$xv$ 都向  $vw$ 连边。此时如果存在另一个 $y$ 使得 $v\to y$ 有边，则在 E 中 $uv$，$xv$ 都应该向 $vy$ 有边。

也就是说，两个点指向一个公共的点，那么它们所有出边指向的点集必然相同，事实上这是存在 D 的充要条件，证明不难。

之前几篇题解要么用了并查集，要么用了数组暴力判断，这里提供一种不难想且速度不慢的方法：Bitset。

用 Bitset 记录邻接矩阵，枚举两行，算一下两行的与和异或，如果与不为 $0$，则说明指向公共点，此时再看异或，如果异或不为 $0$，说明出边不重合，答案为 No.

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=310;
int t,n,m,x,y;
bitset <MAXN> b[MAXN],tmp1,tmp2;
int main () {
	scanf("%d",&t);
	for (int ii=1;ii<=t;ii++) {
		scanf("%d%d",&n,&m);
		for (int i=1;i<=n;i++) {b[i].reset();}
		for (int i=1;i<=m;i++) {
			scanf("%d%d",&x,&y);
			x++,y++;
			b[x].set(y);
		}
		int flg=0;
		for (int i=1;i<=n;i++) {
			if (flg) {break;}
			for (int j=1;j<=n;j++) {
				tmp1=b[i]&b[j],tmp2=b[i]^b[j];
				if (tmp1.count()!=0&&tmp2.count()!=0) {flg=1;break;}
			}
		}
		printf("%s\n",flg?"No":"Yes");
	}
	return 0;
}
```


---

## 作者：快斗游鹿 (赞：3)

## 思路

如果新的图里存在一条从 $u$ 到 $v$ 的边，则说明原图中 $u$ 的终点和 $v$ 的起点一样。容易想到使用并查集。

可以用 $u$ 表示 $u$ 在原图中的起点，用 $u+m+1$ 表示 $u$ 在原图中的终点。每次连边，只要将 $u+m+1$ 和 $v$ 连起来即可。

如何判断原图是否存在呢？如果 $u,v$ 两点中间没有连边，但 $u+m+1$ 和 $v$ 在一个集合里，那就一定不存在，否则就存在。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
int T,fa[1000],e[1000][1000];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
int main(){
	T=read();
	while(T--){
		int m,k;m=read();k=read();
		for(int i=1;i<=2*m+2;i++)fa[i]=i;
		memset(e,0,sizeof(e));
		for(int i=1;i<=k;i++){
			int x,y;x=read()+1;y=read()+1;e[x][y]=1;
			fa[find(x+m+1)]=find(y);
		}
		bool flag=0;
		for(int i=1;i<=m;i++){
			for(int j=1;j<=m;j++){
				if(!e[i][j]&&find(i+m+1)==find(j))flag=1;
			}
		}
		puts(flag?"No":"Yes");
	}
	return 0;
}


```


---

## 作者：bztMinamoto (赞：3)

[传送门](https://www.luogu.org/problemnew/show/P4575)

如果新的图里存在边$(u,v)$，那么说明原图中$u$的终点和$v$的起点是同一个点

于是可以对新图中的每个点维护它的起点和终点，如果有一条边就把对应两个应该相等的点用并查集连起来

最后扫一遍，如果两个点没有边但他们的起点和终点在同一个集合那么说明gg了，否则就是可行的
```
//minamoto
#include<bits/stdc++.h>
#define R register
#define GG return (void)(puts("No"))
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
const int N=1005;
int fa[N],mp[305][305],n,m,u,v;
int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void solve(){
	memset(mp,0,sizeof(mp)),n=read(),m=read();
	fp(i,1,n<<1)fa[i]=i;fp(i,1,m)u=read()+1,v=read()+1,mp[u][v]=1,fa[find(u+n)]=find(v);
	fp(i,1,n)fp(j,1,n)if(!mp[i][j]&&find(i+n)==find(j))GG;
	puts("Yes");
}
int main(){
//	freopen("testdata.in","r",stdin);
	int T=read();
	while(T--)solve();
	return 0;
}
```

---

## 作者：Infinity_Fantasy (赞：2)

~~一道并查集的水题？~~ 

------------
省流：暴力。
------------
可以采用邻接矩阵来存边，对于每次输入的两个整数，我们可以把它们用并查集连起来。然后最后操作完了，可以暴力枚举每条边，两两判断是否存在冲突。好写，好理解，还跑的嘎嘎快。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,m,k,f[1000];
bool e[1000][1000];
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
int main(){
	cin>>t;
	while(t--){
		cin>>m>>k;
		for(int i=1;i<=m+1<<1;i++) f[i]=i;
		memset(e,0,sizeof e);
		for(int x,y,i=1;i<=k;i++){
			cin>>x>>y;
			e[++x][++y]=1;
			f[find(x+m)]=find(y);
		}
		bool flag=0;
		for(int i=1;i<=m;i++)
			for(int j=1;j<=m;j++)
				if(!e[i][j] && find(i+m)==find(j)) flag=1;
		puts(flag?"No":"Yes");
	}
	return 0;
}
```


---

## 作者：quantum11 (赞：2)

听说有人被$m$的范围写在$k$后面坑了...

$E$中如果存在两条边$ac->cd$和$bc->cd$

那么$ac$能连出的点和$bc$能连出的点应该是相同的

因为在$D$中都表示从$c$连向另一个相同的点

```
#include<bits/stdc++.h>
using namespace std;
int T,n,m,e[305][305];
bool check(){
	int f1=0,f2=0;
	for(int i=1;i<n;++i) for(int j=i+1;j<=n;f1=f2=0,++j) for(int k=1;k<=n;++k){
		f1|=e[i][k]&&e[j][k],f2|=e[i][k]^e[j][k];
		if(f1&&f2) return 0;
	}
	return 1;
}
int main(){
	scanf("%d",&T);
	while(T--){
		memset(e,0,sizeof(e));
		scanf("%d%d",&n,&m);
		for(int i=1,x,y;i<=m;++i) scanf("%d%d",&x,&y),e[x+1][y+1]=1;
		puts(check()?"Yes":"No");
	}
	return 0;
}
```

---

## 作者：JRhdj (赞：2)

###### ~~这黑题黑的有点假啊~~

### 其实就是对任意边u->v 和 u->w, 存在t, 使得t和v,w两点中一点存在边相连,暴力判断就好了。

 ~~还是不理解为什么m的范围要写在k后面~~

###### 代码很短
```c
#include <cstdio>  
#include <algorithm>  
#include <cstring>  
#include <iostream>  
using namespace std;
const int M = 305;
int map[M][M], n, m;
bool f1, f2;
bool pd()
{
    bool Have_inter, un;
    for(int i=1; i<=n; ++i)
        for(int j=i+1; j<=n; ++j) 
        {
            f1 = f2 = 0;
            for(int k=1; k<=n; ++k) 
            {
                if(map[i][k] && map[j][k]) f1 = 1;
                if(map[i][k] != map[j][k]) f2 = 1;
                if(f1 && f2) return 0;
            }
        }
    return 1;
}
void init()
{
    memset(map, 0, sizeof(map));
    scanf("%d%d", &n, &m);
    int u, v;
    for(int i=1; i<=m; ++i) scanf("%d%d", &u, &v), map[++u][++v] = 1;
}
int main()
{
    int T;
    scanf("%d", &T);
    while(T--) 
    {
        init();
        if(pd()) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

---

## 作者：luxiaomao (赞：1)

AFO 前再写最后一篇题解罢。

## Problem


给一个 $n$ 结点 $m$ 条边的有向图 $D$，可以这样构造图 $E$：给 $D$ 的每条边 $(u,v)$，在 $E$ 中建立一个点 $uv$，然后对于 $D$ 中的两条边 $(u,v)$ 和 $(v,w)$，在 $E$ 中从 $uv$ 向 $vw$ 连一条有向边。$E$ 中不含有其他点和边。

输入 $E$，判断是否存在相应的 $D$。

## Solution

题意有点绕，手玩一下样例可以发现，如果输入的图 $E$ 中出现了这样的形式：

$$1 \rightarrow 2$$

$$1 \rightarrow 4$$

$$3 \rightarrow 2$$

那么还原成图 $D$ 就只能是：

![](https://cdn.luogu.com.cn/upload/image_hosting/2q7a41ot.png)

我们注意到，这时必须再在图 $E$ 中补上一条：

$$3 \rightarrow 4$$

那么说白了就是：只要有 $1\rightarrow 2$，$1\rightarrow 4$，$3\rightarrow 2$，就必须要有 $3\rightarrow 4$。

核心思路就是这样，数据很小，实现方法上很开放，笔者这里用了并查集来维护。

## Code

```cpp
#include<bits/stdc++.h>
#define N 305
using namespace std;

int T,n,m;
bool edge[N][N];
vector<int> las[N];

int fa[N];
int find(int u){return u == fa[u]?u:fa[u] = find(fa[u]);} 

signed main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i = 0;i < n;i++)
			for(int j = 0;j < n;j++)
				edge[i][j] = 0;
		for(int i = 0;i < n;i++)las[i].clear();
		scanf("%d",&m);
		while(m--)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			edge[u][v] = 1;
			las[v].push_back(u);
		}
		
		for(int i = 0;i < n;i++)fa[i] = i;
		for(int i = 0;i < n-1;i++)
			for(int j = i+1;j < n;j++)
			{
				if(find(i) == find(j))continue;
				bool flag = 0;
				for(int k = 0;k < n;k++)
					if(edge[i][k] != edge[j][k])
					{
						flag = 1;
						break;
					}
				if(!flag)fa[find(i)] = find(j);
			}
		
		bool flag = 0;
		for(int v = 0;v < n;v++)
		{
			if(las[v].size() < 2)continue;
			int u = las[v][0];
			for(int i = 1;i < las[v].size();i++)
			{
				int u2 = las[v][i];
				if(find(u) != find(u2))
				{
					flag = 1;
					break;
				}
			}
			if(flag)break;
		}
		if(flag)printf("No\n");
		else printf("Yes\n");
	}
	return 0;
}
```

---

## 作者：Swirl (赞：1)

全真模拟！

不知道为什么反正就是挑到了 CQOI2013。

---

文中用 $n$ 代替 $m$，$m$ 代替 $k$，并编号从 $1$ 开始。

在 $E$ 中有一条边 $u \to v$ 意味着 $D$ 图中 $u$ 边的终点与 $v$ 边的起点是同一个点。

反之终点与起点是同一个点的两条边 $u$ 和 $v$ 都应该在 $E$ 上连线。

对于每一个 $E$ 中的结点 $i$，令其在图 $D$ 中代表的边的起点终点分别为 $i$ 和 $i + n$。

那么 $E$ 的一条边 $i \to j$ 就代表 $i + n$ 与 $j$ 是**等价的**。

如果有 $i,j$ 满足 $i + n$ 与 $j$ 是等价的但是在 $E$ 图上并没有 $i \to j$ 的边就说明不存在一个合法的 $D$。

否则就有。

构造方法也很简单，在 $D$ 中，把所有的 $i$ 都连上 $i \to i + n$，并把所有等价的点缩成一个即可。

而**等价**的维护方法可以用并查集。

---

```cpp
#include <bits/stdc++.h>
// #define int long long
#define pii pair<int, int>
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

inline void cmax(int &x, int c) {
	x = max(x, c);
}
inline void cmin(int &x, int c) {
	x = min(x, c);
}

int _test_ = 1;

const int N = 605;

int n, m, fa[N];
int g[N][N];

int fd(int x) {
	return x == fa[x] ? x : fa[x] = fd(fa[x]);
}

void init() {}

void clear() {}

void solve() {
	memset(g, 0, sizeof(g));
	cin >> n >> m;
	for (int i = 1; i <= 2 * n; i++)
		fa[i] = i;
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		x++, y++;
		g[x][y] = 1;
		x = fd(x + n), y = fd(y);
		if (x == y) continue;
		fa[x] = y;
	}
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= n; j++) {
			if (g[i][j]) continue;
			if (fd(i + n) == fd(j)) 
				return cout << "No\n", void();
		}
	cout << "Yes\n";
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> _test_;
	init();
	while (_test_--) {
		clear();
		solve();
	}
	return 0;
}
```

---

## 作者：Limitless_lmw (赞：0)

萌萌简单题。

不难发现两个点 $A$ 和 $B$ 如果拥有一个相同的后继点 $C$（也就是 $C$ 作为终点与 $A$ 和 $B$ 直接相连），那么 $A\rightarrow C,B\rightarrow C$ 这两条边在 $\mathbb{E}$ 中拥有相同的后继点。

这是因为 $C$ 这个点所连的所有边肯定都满足题中所述的条件，故与 $A\rightarrow C,B\rightarrow C$ 这两条边有连接

那么就可以愉快地判断了。

如果两个 $\mathbb{E}$ 中的点 $x,y$ 拥有相同的后继点，那么判断他们的后继点的集合相不相同即可，注意到 $m\le 300$，所以直接 $\Theta(Tm^3)$ 暴力使用邻接矩阵判断即可。

---

## 作者：ningago (赞：0)

~~听说这题原来是黑的~~

### 思路

这题是个做法比较暴力的思维题。

（大写字母为 $\mathbb{E}$ 中的点与 $\mathbb{D}$ 中的边，小写为 $\mathbb{D}$ 中的点。）

假设 $\mathbb{E}$ 中有边 $A \to C$ 和 $B \to C$，且用 $\mathbb{D}$ 中的节点表示为 $A=a \to x$，则 $C$ 起点为 $x$ 即 $C=x \to c$，
显然 $B$ 的终点也为 $x$ 即 $B=b \to x$。

此时，如果 $A$ 还对 $D$ 有连边，显然 $D$ 起点也为 $x$， $D=x \to d$，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9f9ly4k5.png)

此时我们惊奇地发现，因为有了 $x$ 的存在，在 $\mathbb{E}$ 中 $B \to D$ 这条边也随之存在。

因此，当两个点 $U_1$ 与 $U_2$ 有相同的终点 $V$ 时，那么 $U_1$ 的其他终点也是 $U_2$ 的终点。

如果输入数据中发现 $U_1$ 的一个终点 $V_i$ 与 $U_2$ 没有连边（但必须在有一个共同终点的情况下判断），那么判为没有相应的 $\mathbb{D}$。

由于数据规模和需判断两点有无连边，邻接矩阵是一个不错的选择。

### Code：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int T,M,K;
bool g[310][310];

int main()
{
    scanf("%d",&T);
    while(T--)
    {
        memset(g,0,sizeof(g));
        scanf("%d%d",&M,&K);
        for(int i = 1,f,t;i <= K;i++)
        {
            scanf("%d%d",&f,&t);
            g[f + 1][t + 1] = 1;//注意
        }
        bool x,y,flag = 0;
        for(int i = 1;i <= M;i++)
        {
            for(int j = i + 1;j <= M;j++)
            {
                x = y = 0;
                for(int k = 1;k <= M;k++)
                {
                    if(g[i][k] && g[j][k])
                        x = 1;
                    if(g[i][k] != g[j][k])
                        y = 1;
                    if(x && y)
                    {
                        flag = 1;
                        break;
                    }
                }
                if(flag)
                    break;
            }
            if(flag)
                break;
        }
        printf("%s\n",flag ? "No" : "Yes");
    }
    return 0;
}
```

End.

---

## 作者：Link_Space (赞：0)

图 E 中的每一条边，这个边的起点 uv 和终点 vk ，其中 v 是相同的，所以对于 E 中的一个点 ab ,这个点对应 D 中的 a->b 这一条边，所以考虑直接在 E 中建一个新点，将 ab 这个点和 E 中的这个新点分别对应 D 中的 a b 两点，再对 E 中的每一条边所连的两点（即 D 中的两条边）进行并查集判断,如果出现了矛盾的话就说明不存在 D 图，否则存在。

实现如下

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 1e3 + 5;
int father[N];
int find(int x)
{
    if(x!=father[x])
        father[x] = find(father[x]);
    return father[x];
}
int edge[N][N];
int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
    {
        memset(edge, 0, sizeof edge);
        int m, k;
        scanf("%d%d", &m, &k);
        for (int i = 1; i <= 2 * m;i++)
            father[i] = i;
        for (int i = 1; i <= k; i++)
        {
            int x, y;
            scanf("%d%d", &x, &y);
            x++, y++;
            edge[x][y] = 1;
            father[find(x + m)] = find(y);
        }
        bool flag = false;
        for (int i = 1; i <= m;i++)
        {
            for (int j = 1; j <= m;j++)
            {
                if(!edge[i][j]&&find(i+m)==find(j))
                {
                    flag = 1;
                    break;
                }
            }
            if(flag)
                break;
        }
        if(!flag)
            puts("Yes");
        else
            puts("No");
    }
}
```


---

## 作者：Yaha (赞：0)

### Hash

---

这题考试做的时候，写了个看起来就比较危险的暴力枚举来判断集合相等，为了安全搞了个边数太大就 Hash 的特判。

事实证明用 Hash 直接 95 变 100。并且下来测不用暴力全用 Hash 也是 100。

---

思路不难想。先思考，什么时候会推出图的矛盾呢？

假设三个点 $ab$，$bc$，$xb$，有边 $(ab,bc)$，$(xb,bc)$，且 $ab$ 还能到除 $bc$ 外的其它点，而 $xb$ 不能到。这就会矛盾，因为 $a$ 和 $x$ 都能到 $b$ ，所有 $ab$ 的所有出边指向的点， $xb$ 也必须都能到。

这就启发我们，对于每个点 $i$（指的是给出的图 $E$，而不是 $D$ ），对于所有的 $(j,i)\in E$，$j$ 能到的点的集合都相同。

对于每个点能到的点，可以用 set 来存，去重。

按照上面的思路无脑枚举可以获得 95 的好成绩。

---
优化：

具体实现中，我们枚举点 $i$，然后枚举入点 $j$，然后判断所有 $j$ 的可到点集是否相等。

考虑到每个点的可到点集是不变的，但是可能会多次枚举浪费大量时间，我们可以用特征函数来代表一个点集。

用一个值来表示一个集合，判断集合是否相等直接判断值是否相等就可以了。

事实证明，这个题完全没卡 Hash，特征函数随便乱设都可以过。我用了一个非常不容易被卡的函数：

$f(S_i)= \sin(\sum _{p\in S_i}p^2)\times |S_i|$，其中 $S_i$ 为 $i$ 的可到点的集合。

（爽得一批）

---

```cpp
#include<bits/stdc++.h>
#define IT set<int>::iterator

using namespace std;

const int N=310;

int n,m;
vector<int> V[N];
set<int> S[N];
double Hash[N];

bool work(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		a++,b++;
		V[a].push_back(b);
		S[b].insert(a);
	}
	for(int i=1;i<=n;i++)
	{
		for(IT it=S[i].begin();it!=S[i].end();it++)
		{
			int p=*it;
			Hash[i]+=p*p;
		}
		Hash[i]=sin(Hash[i])*S[i].size();
	}
	for(int i=1;i<=n;i++)
	{
		if(!V[i].size()) continue;
		int st=V[i][0];
		for(int j=1;j<V[i].size();j++)
		{
			int v=V[i][j];
			if(Hash[v]!=Hash[st]) return false;
		}
	}
	return true;
}

void init(){
	for(int i=1;i<=n;i++) 
		V[i].clear(),S[i].clear(),Hash[i]=0;
}

int main(){
	int t;
	scanf("%d",&t);
	while(t--)
		printf("%s\n",work()?"Yes":"No"),init();
	
	return 0;
}
```



---


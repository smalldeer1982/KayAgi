# [CQOI2013] 棋盘游戏

## 题目描述

一个n*n（n>=2）棋盘上有黑白棋子各一枚。游戏者A和B轮流移动棋子，A先走。

 * A的移动规则：只能移动白棋子。可以往上下左右四个方向之一移动一格。
 
 * B的移动规则：只能移动黑棋子。可以往上下左右四个方向之一移动一格或者两格。
 
和通常的“吃子”规则一样，当某游戏者把自己的棋子移动到对方棋子所在的格子时，他就赢了。

两个游戏者都很聪明，当可以获胜时会尽快获胜，只能输掉的时候会尽量拖延时间。你的任务是判断谁会赢，需要多少回合。


比如$n=2$，白棋子在$(1,1)$，黑棋子在$(2,2)$，那么虽然A有两种走法，第二个回合B总能取胜。

## 说明/提示

$n<=20$

## 样例 #1

### 输入

```
2 1 1 2 2```

### 输出

```
BLACK 2```

# 题解

## 作者：JRhdj (赞：14)

### ~~据说这叫对抗搜索，本质上就是博弈论嘛~~

### 只是博弈论是在某一步直接作出决策

### 由题意除非黑棋是在白棋1步范围以内，否则白棋不可能获胜。那么我们需要做的就是让黑棋尽量快的获胜，白棋尽量多苟一会，那么就可以转移了。

### 状态用f(x,y,r1,c1,r2,c2)表示，x=(0/1)表示黑白棋，y是步数，(r1,c1)是白棋坐标，（r2,c2）是黑棋坐标

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cmath> 
#include <iostream>
#include <algorithm>
using namespace std;
const int inf = 1e9+7;
const int M = 25;
int n, r1, c1, r2, c2, ans;
int f[2][60][M][M][M][M]; 
int dfs(int x, int y, int r1, int c1, int r2, int c2)
{
    int ans;
    if(y>3*n) return inf;
    if(f[x][y][r1][c1][r2][c2]) return f[x][y][r1][c1][r2][c2];
    if(r1 == r2 && c1 == c2) return x?inf:0;
    if(!x)
    { 	
        ans = 0;
        if(r1>1) ans = max(ans, dfs(1, y+1, r1-1, c1, r2, c2));
        if(r1<n) ans = max(ans, dfs(1, y+1, r1+1, c1, r2, c2));
        if(c1>1) ans = max(ans, dfs(1, y+1, r1, c1-1, r2, c2));
        if(c1<n) ans = max(ans, dfs(1, y+1, r1, c1+1, r2, c2));
    }
    else
    {
       	ans = inf;
        if(r2>1) ans = min(ans, dfs(0, y+1, r1, c1, r2-1, c2));
        if(r2>2) ans = min(ans, dfs(0, y+1, r1,c1, r2-2, c2));
        if(r2<n) ans = min(ans, dfs(0, y+1, r1, c1, r2+1, c2));
        if(r2<n-1) ans = min(ans, dfs(0, y+1, r1, c1, r2+2, c2));
        if(c2>1) ans = min(ans, dfs(0, y+1, r1, c1, r2, c2-1));
        if(c2>2) ans = min(ans, dfs(0, y+1, r1, c1, r2, c2-2));
        if(c2<n) ans = min(ans, dfs(0, y+1, r1, c1, r2, c2+1));
        if(c2<n-1) ans = min(ans, dfs(0, y+1, r1, c1, r2, c2+2));
    }
    f[x][y][r1][c1][r2][c2] = ++ans;//cout<<x<<y<<r1<<c1<<r2<<c2<<"  "<<f[x][y][r1][c1][r2][c2]<<"Ans="<<ans<<endl;;
    return ans;
}
int main()
{
    scanf("%d%d%d%d%d", &n, &r1, &c1, &r2, &c2);
    //cout<<abs(r1-r2)+abs(c1-c2)<<endl;
    if(abs(r1-r2)+abs(c1-c2) <= 1) printf("WHITE 1\n");
    else printf("BLACK %d\n", dfs(0, 0, r1, c1, r2, c2));
    return 0;
}
```

---

## 作者：Tenshi (赞：11)

学习**对抗搜索**的第一篇题解记录。

## 对抗搜索
### 定义
竞争环境中多个玩家之间的目标是有冲突的，称为对抗搜索问题。

### 特点
1. 确定的、完全可查的环境。

2. 智能体轮流行动。

3. 零和博弈。

4. 每一步行动的结果确定。

## 分析
结合本题进行讲解。

分析可以发现，当一开始如果双方是相邻的，自然是先手获胜。否则，后手一定获胜，感性的理解是：后手总能将先手逼到一个角落使先手必败。

于是我们的做法是：

一开始如果双方是相邻的直接输出先手胜。

否则，先手的目标是尽量**拖延**自己的生存时间，后手的目标是**尽快**击败对手。

由上述特征，可知这是一个对抗搜索问题。

具体来讲，就是在搜索的过程中，如果轮到先手决策，那就尽可能地转移到生存时间最长的状态。而轮到后手决策时则尽可能地转移到最快击败对手的状态。

结合代码理解（很短的hh）

```cpp
#include<bits/stdc++.h>
using namespace std;

// 因为 luogu 的 y1 会导致 CE，因此可以 #define 一个其他名字。 
#define y1 Tenshi

const int N=21, INF=0x3f3f3f3f;
int n, x1, y1, x2, y2;
int f[2][65][N][N][N][N]; // 记录状态

// 控制四个方向
int dx[]={-1, 1, 0, 0};
int dy[]={0, 0, -1, 1};

int dfs(bool ok, int cnt, int x1, int y1, int x2, int y2){
	if(~f[ok][cnt][x1][y1][x2][y2]) return f[ok][cnt][x1][y1][x2][y2];
	if(cnt>3*n) return f[ok][cnt][x1][y1][x2][y2]=INF; 
	if(x1==x2 && y1==y2) return f[ok][cnt][x1][y1][x2][y2]=(ok? 0: INF);
	
	int res;
	if(ok){ // 先手
		res=-1;
		for(int i=0; i<4; i++){
			int kx=x1+dx[i], ky=y1+dy[i];
			if(kx<1 || kx>n || ky<1 || ky>n) continue;
			res=max(res, dfs(0, cnt+1, kx, ky, x2, y2));
		}
	}
	else{ // 后手
		res=INF;
		for(int i=0; i<4; i++){
			for(int j=1; j<=2; j++){
				int kx=x2+j*dx[i], ky=y2+j*dy[i];
				if(kx<1 || kx>n || ky<1 || ky>n) continue;
				res=min(res, dfs(1, cnt+1, x1, y1, kx, ky));
			}
		}
	}
	return f[ok][cnt][x1][y1][x2][y2]=res+1;
}

int main(){
	memset(f, -1, sizeof f);
	cin>>n>>x1>>y1>>x2>>y2;
	if(abs(x1-x2)+abs(y1-y2)==1) puts("WHITE 1");
	else cout<<"BLACK "<<dfs(1, 0, x1, y1, x2, y2)<<endl;
	return 0;
}
```

---

## 作者：C3H5ClO (赞：6)

发个循环版本的题解。。。

思路与另外一位dalao基本相同，先特判白棋赢的情况（开局一步吃掉）

令$f[i][x1][y1][x2][y2]$表示当前走到第$i$步，白棋在$(x1,y1)$，黑棋在$(x2,y2)$时按两人最优策略结束游戏所需步数（若无法结束则值为INF）

由于白棋要尽量拖延，黑棋要尽快结束，因此白棋走时总是从后继状态的最大值转移而来，黑棋走时总是从后继状态的最小值转移而来。

注意一点，只有当前是白棋走并且黑白棋重合时把当前$f$值赋为0，因为这样相当于黑棋走完吃掉白棋。

另外，如果游戏可以在有限步内结束，那么走的步数肯定不超过$3n$，因此将$f[3n+1][x1][y1][x2][y2]$全部赋初值为INF

具体实现看代码，代码中我使用了滚动数组。
```cpp
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;
#define ri register int
const int INF=987654321;
int n,r1,c1,r2,c2,f[2][20][20][20][20],ff;
int main()
{
	scanf("%d%d%d%d%d",&n,&r1,&c1,&r2,&c2);
	r1--; c1--; r2--; c2--;
	if(abs(r1-r2)+abs(c1-c2)==1)
	{
		printf("WHITE 1");
		return 0;
	}
	for(ri x1=0;x1<n;x1++)
		for(ri y1=0;y1<n;y1++)
			for(ri x2=0;x2<n;x2++)
				for(ri y2=0;y2<n;y2++)
					f[n*3+1&1][x1][y1][x2][y2]=INF;
	for(ri i=3*n;i>=0;i--)
		for(ri x1=0;x1<n;x1++)
			for(ri y1=0;y1<n;y1++)
				for(ri x2=0;x2<n;x2++)
					for(ri y2=0;y2<n;y2++)
					{
						
						if(x1==x2&&y1==y2&&i+1&1)f[0][x1][y1][x2][y2]=0;
						else if(i&1)
						{
							ff=INF;
							if(x2)ff=min(ff,f[0][x1][y1][x2-1][y2]);
							if(x2>1)ff=min(ff,f[0][x1][y1][x2-2][y2]);
							if(x2+1<n)ff=min(ff,f[0][x1][y1][x2+1][y2]);
							if(x2+2<n)ff=min(ff,f[0][x1][y1][x2+2][y2]);
							if(y2)ff=min(ff,f[0][x1][y1][x2][y2-1]);
							if(y2>1)ff=min(ff,f[0][x1][y1][x2][y2-2]);
							if(y2+1<n)ff=min(ff,f[0][x1][y1][x2][y2+1]);
							if(y2+2<n)ff=min(ff,f[0][x1][y1][x2][y2+2]);
							f[1][x1][y1][x2][y2]=ff+1;
						}
						else
						{
							ff=0;
							if(x1)ff=max(ff,f[1][x1-1][y1][x2][y2]);
							if(x1+1<n)ff=max(ff,f[1][x1+1][y1][x2][y2]);
							if(y1)ff=max(ff,f[1][x1][y1-1][x2][y2]);
							if(y1+1<n)ff=max(ff,f[1][x1][y1+1][x2][y2]);
							f[0][x1][y1][x2][y2]=ff+1;
						}
					}
	if(f[0][r1][c1][r2][c2]<INF)printf("BLACK %d",f[0][r1][c1][r2][c2]);
	else printf("DRAW");
}
```

---

## 作者：Daniel_7216 (赞：3)

今天上午艾教讲了这道题，下午想明白了结论，~~过了之后来水一发题解~~

首先我们要得出一个结论：除非开局两枚棋子挨在一起，否则黑子必胜。为什么？

注：以下推导不包括开局。

白子吃掉黑子，必须在轮到白子时有这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/un0ogkz5.png)

在游戏过程中，是否存在黑子不得不走到白子旁边的情况呢？

当出现这种情况时，黑子直接获胜：

![](https://cdn.luogu.com.cn/upload/image_hosting/un0ogkz5.png)

同理，白子也不能在黑子上下左右四个方向之一的两格以内。

鉴于这个结论，如果白子想要把黑子逼到墙角并且使两人曼哈顿距离最小，应有如下站位：

![](https://cdn.luogu.com.cn/upload/image_hosting/mqxgvqzx.png)

黑子只需要“瞬步”两格即可。所以当黑子采用最佳策略时，白子永远吃不到它。

我们知道，黑子的攻击范围如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/wx10zlut.png)

因为白子一次只能走一格，所以不仅它永远无法近身，而且也不能直接穿过黑子的攻击范围，因此，黑子总可以不断与白子在同一直线且距离为二，来不断缩小白子的可移动范围，故，至多 $3N$ 步（~~不知道怎么证~~），黑子必胜，不存在平局。

知道黑子必胜之后，我们可以从两个角度考虑：对于白子来说，它的目标是让步数尽可能多，黑子的目标是让步数尽可能少，所以用 $dp0_{x1, x2, y1, y2}$ 和 $dp1_{x1,x2,y1, y2}$ 两个数组来分别表示当轮到白子或黑子时，如果黑白子的坐标分别是 $(x1,y1)$ 和 $(x2, y2)$ 时，还需要追多少步。

但是这里有一个问题，原则上一个格子可以经过任意多次，但是如果这样转移的话，可能会出现两人“转圈圈”的情况，而且无法判断（因为不能禁止重复走一个方格）。所以我们不妨在 DP 数组里加一个维度 $step$，表示当前的状态是在游戏开始多少步之后出现的，显然有：

$dp0_{step,x1,x2,y1, y2}=\begin{cases}\max(dp0_{step+1,newx,x2,newy, y2})+1&step\leqslant3N\\\infty&step>3N\\\infty&newx=x2,newy=y2\\\end{cases}$

$dp1_{step,x1,x2,y1, y2}=\begin{cases}\min(dp1_{step+1,x1,newx,y1, newy})+1&step\leqslant3N\\  0&step>3N\\0 &x1=newx,y1=newy\\\end{cases}$

$newx$ 与 $newy$ 分别表示转移到的新位置的坐标。由于可以由四个方向转移，循环的形式不是很好写，所以用记忆化即可。

代码：

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n, x0, y0, x1, y1, xx0, yy0, xx1, yy1;
int dx[10] = {0, 0, 1, -1, 0, 0, 2, -2};
int dy[10] = {1, -1, 0, 0, 2, -2, 0, 0};
int dp0[61][21][21][21][21], dp1[61][21][21][21][21];
int dfs(int player, int step, int r0, int c0, int r1, int c1){
	int best;
	if (step > 3 * n) return 114514;
	if (player == 0 && dp0[step][r0][c0][r1][c1]) return dp0[step][r0][c0][r1][c1];
	if (player == 1 && dp1[step][r0][c0][r1][c1]) return dp1[step][r0][c0][r1][c1];
	if (r0 == r1 && c0 == c1){
		if (player == 1) return 114514;
		else return 0;
	}
	if (player == 0){ //白 
		best = 0;
		for (int i = 0; i < 4; i++){
			xx0 = r0 + dx[i];
			yy0 = c0 + dy[i];
			if (xx0 > n || xx0 < 1) continue;
			if (yy0 > n || yy0 < 1) continue;
			best = max(dfs(1, step + 1, xx0, yy0, r1, c1), best);
		}
		dp0[step][r0][c0][r1][c1] = best + 1;
		return dp0[step][r0][c0][r1][c1];
	}else{
		best = 114514;
		for (int i = 0; i < 8; i++){
			xx1 = r1 + dx[i];
			yy1 = c1 + dy[i];
			if (xx1 > n || xx1 < 1) continue;
			if (yy1 > n || yy1 < 1) continue;
			best = min(dfs(0, step + 1, r0, c0, xx1, yy1), best);
		}
		dp1[step][r0][c0][r1][c1] = best + 1; 
		return dp1[step][r0][c0][r1][c1]; 
	}
}
int main(){
	scanf("%d%d%d%d%d", &n, &x0, &y0, &x1, &y1);
	if ((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) == 1){
		printf("WHITE 1");
		return 0;
	}
	printf("BLACK %d", dfs(0, 0, x0, y0, x1, y1));
	return 0;
}
```

注：不要忘了特判白子开局就在黑子旁边的情况！

---

## 作者：Ave_1_Oblivionis (赞：2)

## 原题

[P4576 [CQOI2013]棋盘游戏](https://www.luogu.com.cn/problem/P4576)

---

## 思路概述

### 题意分析

给定一个大小为 $n×n$ 的棋盘和白子与黑子坐标 $(x_1,y_1),(x_2,y_2)$。定义白子与黑子的移动操作：白子每回合可以向四个方向移动一格；黑子每回合可以向四个方向移动一或两格。规定白子先出棋。要求求解必胜方并且输出操作步数（满足必胜方尽快取胜，必败方尽量拖延的策略）。

### 思路分析

一道有点难想并且难写的博弈论+记搜题。

胜负态乍一看不好想，但是玩过类似游戏的读者应该不难想到：在双方拥有相同操作机会的前提下，移动速度快的一方总不会输。当速度慢的一方有机会移动到能吃掉快方的时候，快方必然能靠速度优势甩开一定距离，除了一种特例：快方一开始就在慢方的移动范围内并且慢方先手。

本题在胜负态判断上就应用了类似思路。显而易见地，白子移动速度慢于黑子，但是有先手机会。根据上述结论不难得到本题胜负判断函数。

至于步数统计则采用 $\text{ DFS }$，但由于状态过多，需要采用记忆化搜索进行一定剪枝，在搜索到游戏结束状态后再回溯求解步数。

---

## 算法实现

### 胜负态判断

引入一个概念（其实跟本题关系并不大）：曼哈顿距离。曼哈顿距离指在 $n$ 维空间中，两个点在所有轴方向上的距离和。例如：在平面上，两个点的曼哈顿距离表示为 $|x_1-x_2|+|y_1-y_2|$。

当黑子白子初始坐标相邻时，白子可以一步吃掉黑子，此时白方必胜，步数为 $1$。

即（此处用 $(x_1,y_1),(x_2,y_2)$ 分别表示白子与黑子坐标，函数值为 $1$ 表示白方必胜，反之必败）：

$$F(x_1,y_1,x_2,y_2)=\begin{cases}1,|x_1-x_2|+|y_1-y_2|≤1 \\0,\text{otherwise}\end{cases}$$

### 关于步数统计之前的一些预处理

由于是棋盘上的$\text{ DFS }$，所以需要预处理移动数组。处理方式跟入门的地图搜索题没区别，此处不再冗述。

### 状态定义与计数思路

一个地图上博弈游戏的状态，首先必须包含点坐标，在本题中即为必须包含白子与黑子坐标 $x_1,y_1,x_2,y_2$；其次，由于轮流出棋，所以状态同样包含当前的出棋方 $opt$ ；最后，由于需要统计操作步数，所以搜索函数参数传递也需要将当前搜索状态的步数向下传递以及向上回溯。因此，本题的状态即可定义为：

$$f(opt,s,x_1,y_1,x_2,y_2)$$

其中，$opt$ 为当前出棋方，$s$ 为从初始状态到当前状态的转移步数。

为方便表述，笔者在此处定义操作 $move(x_1,x_2,dir,dis)$ 表示坐标在 $(x_1,y_2)$ 的棋子向方向 $dir(dir∈[0,3])$ 移动 $dis$ 格后得到的新坐标。

因为已经判定了白方必胜的情况，所以此处只需要用$\text{ DFS }$统计黑方胜利的步数。

先从初始状态开始搜索，当搜索到其中两个棋子坐标重合结束该方向的搜索并统计一次答案，再在回溯过程中累加得到黑方获胜所需要的最小步数。

### 游戏结束的情况判断

特别地，当出现坐标重合时，若当前操作方为黑方，则黑子被吃，即黑方不可能以当前状态获胜，返回一个极大值为步数；反之，若当前操作方为白方，则说明黑方在此状态获胜，那么返回步数 $0$，表示在当前状态下只需要 $0$ 步即可达到黑方获胜的状态。

### 其他状态的转移

对于当前的一个状态 $f(opt,s,x_1,y_1,x_2,y_2)$，若 $opt=white$ 则需要尽量拖延步数，则取所有后继状态步数的最大值，即 $f(white,s,x_1,y_1,x_2,y_2)=\max\{f(black,s+1,move(x_1,y_1,dir,1)_x,move(x_1,y_1,dir,1)_y,x_2,y_2)\}$；反之，就需要尽快获胜，取所有后继状态步数的最小值，即 $f(black,s,x_1,y_1,x_2,y_2)=\min\{f(white,s+1,x_1,y_1,move(x_2,y_2,dir,dis)_x,move(x_2,y_2,dir,dis)_y)\}(dis∈[1,2])$。

### 关于记忆化剪枝

分析上述算法不难知道，本题的大部分状态会被调用不止一次，所以开一个与状态相对应的数组存储每个状态的步数，若在搜索过程中发现过已经被调用过的状态就直接取值。

### 关于步数上界

由于是$\text{ DFS }$，时间复杂度呈指数增长，所以对于那种两个棋子在秦王绕柱的状态，必然将其舍弃。这个舍弃的标准可以具体为 $s>3n$。关于这个标准，笔者并未找出严格满足 $ans=3n$ 的情况，但是当两个棋子分别占棋盘对角且 $n$ 较大时，就会出现 $ans>2.5n$ 的情况（例如 $n=19,x_1=1,y_1=1,x_2=19,y_2=19$ 的数据）。

$n>2.5n$ 情况的具体步骤（笔者手推 $n=19$ 棋盘）大概是黑子以最优方案靠近白子所在的角，白子原地反复走棋拖延时间，当两者曼哈顿距离小等于 $2$ 时白子开始沿棋盘较安全的一边逃逸，黑子尝试用速度优势堵截但与白子陷入了短时间的绕圈，最后当 $s≈50$ 时白子被吃，游戏结束。

---

## AC code

因为个人编码习惯，写了结构体和一大堆申必封装函数，实际运行有点慢，凑合看看罢。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<set>
#include<ctime>
#define RI register int
using namespace std;
typedef struct
{
	int x,y;
	inline void read(void){cin >> x >> y;return;}/*封装读入*/
	inline bool judge(int lim){return (x>=1 && x<=lim && y>=1 && y<=lim);}/*判定出界*/
}point;
const point dir[4]={(point){1,0},(point){0,1},(point){-1,0},(point){0,-1}};
const int maxn=2e1+10,inf=0x3f3f3f3f; 
point w,b;
int n;
int rec[2][(maxn<<1)+maxn][maxn][maxn][maxn][maxn];
inline int getdis(point x,point y);/*求两点曼哈顿距离*/
inline point move(point x,int dr,int ds);/*移动函数 dr为方向 ds为距离*/
inline int dfs(bool isw,int s,point p,point h);/*深度优先搜索函数*/
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin >> n;
	w.read();b.read();
	if(getdis(w,b)<=1) puts("WHITE 1");/*两点距离为1时 白子只需要一步即可吃掉黑子*/
	else cout << "BLACK " << dfs(1,1,w,b);/*两点距离大于1时 白子不可能获胜*/
	return 0;
}
inline int getdis(point x,point y){return abs(x.x-y.x)+abs(x.y-y.y);}
inline point move(point x,int dr,int ds){return (point){x.x+dir[dr].x*ds,x.y+dir[dr].y*ds};}
inline int dfs(bool isw,int s,point p,point h)
{
	if(s>(n<<1)+n) rec[isw][s][p.x][p.y][h.x][h.y]=inf;/*步数最多为3n（构造方法详见题解） 超过3n表示无解*/
	else if(!getdis(p,h)) rec[isw][s][p.x][p.y][h.x][h.y]=(isw)?0:inf;/*黑/白子被吃 判定游戏结束 开始回溯计算步数*/
	else if(!rec[isw][s][p.x][p.y][h.x][h.y])/*记忆化剪枝*/
	{
		RI ret;
		if(isw)/*白子出棋则尽量拖延步数 取步数最大值*/
		{
			ret=0;
			for(RI i=0;i<4;++i)
				if(move(p,i,1).judge(n))
					ret=max(ret,dfs(isw^1,s+1,move(p,i,1),h));		
		}
		else/*黑子出棋则尽量快速取胜 取步数最小值*/
		{
			ret=inf;
			for(RI i=0;i<4;++i)
				for(RI j=1;j<=2;++j)/*黑子可以选择移动1或2格*/
					if(move(h,i,j).judge(n))
						ret=min(ret,dfs(isw^1,s+1,p,move(h,i,j)));
		}
		rec[isw][s][p.x][p.y][h.x][h.y]=ret+1;/*当前的操作也算一步 所以返回ret+1*/
	}
	return rec[isw][s][p.x][p.y][h.x][h.y];
}

```

---

## 作者：yzh_Error404 (赞：1)

在学博弈论的时候看到了这道题，~~然后发现是搜索？~~

### 题意

$n\times n$ 的棋盘上有一个坐标为 $(r1,c1)$ 的白棋和一个坐标为 $(r2,c2)$ 的黑棋，白棋一次走一格，黑棋一次走两格，问在第几回合时谁可以吃掉对方。

### 题解

因为白棋一次只能走一格（手短），所以他能吃掉黑棋的情况只有两种。

  1. 黑棋主动送到白棋嘴边（但走黑棋的人没有傻到这种程度）
  
  2. 一开始黑棋就在白棋旁边（走一步吃掉即可）
  
若不满足这两种情况，白棋就没有吃黑棋的机会了，只能尽量拖延时间，而黑棋一次可以走两步，所以必定没有平局的情况。

下面是 $n=4,r1=2,c1=1,r2=4,c2=4$的一种情况

![](https://blog-static.cnblogs.com/files/yzh-Error404/1626923435087.gif)

代码用递归实现，思路可能借鉴了第一篇题解：
```cpp
#include<bits/stdc++.h>
#define INF 1e9+5
using namespace std;
int n,r1,c1,r2,c2;
int fx[10]={0,-1,1,0,0};
int fy[10]={0,0,0,-1,1};//白棋移动数组
int fx1[20]={0,-1,1,0,0,-2,2,0,0};
int fy1[20]={0,0,0,-1,1,0,0,-2,2};//黑棋移动数组
int f[2][60][21][21][21][21];
inline int dfs(int bw,int round,int r1,int c1,int r2,int c2)//bw为当前动子的一方，round为回合数
{
	int ans;
	if(round>=3*n)return INF;//如果重复了3n次，那么一定是不行的
	if(f[bw][round][r1][c1][r2][c2])return f[bw][round][r1][c1][r2][c2];//判重
	if(r1==r2&&c1==c2)//某一方被吃了
	{
		if(bw==0)return 0;
		else return INF;
	}
	if(bw==0)//白棋动
	{
		ans=0;
		for(register int i=1;i<=4;i++)
			if(r1+fx[i]>=1&&r1+fx[i]<=n&&c1+fy[i]>=1&&c1+fy[i]<=n)ans=max(ans,dfs(1,round+1,r1+fx[i],c1+fy[i],r2,c2));//白棋想要尽可能的活的久，取最大的可能性
	}
	else//黑棋动
	{
		ans=INF;
		for(register int i=1;i<=8;i++)
			if(r2+fx1[i]>=1&&r2+fx1[i]<=n&&c2+fy1[i]>=1&&c2+fy1[i]<=n)ans=min(ans,dfs(0,round+1,r1,c1,r2+fx1[i],c2+fy1[i]));//黑棋想尽快的吃掉白棋，取最小的可能性
	}
	f[bw][round][r1][c1][r2][c2]=++ans;//记录当前状态的答案
	return ans;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&r1,&c1,&r2,&c2);
	for(register int i=1;i<=4;i++)
		if(r1+fx[i]==r2&&c1+fy[i]==c2)//特判黑棋在白棋旁边
		{
			puts("WHITE 1");
			return 0;
		}
	printf("BLACK %d",dfs(0,0,r1,c1,r2,c2));
	return 0;
}
```

---


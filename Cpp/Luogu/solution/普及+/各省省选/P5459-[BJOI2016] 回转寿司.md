# [BJOI2016] 回转寿司

## 题目描述

酷爱日料的小Z经常光顾学校东门外的回转寿司店。在这里，一盘盘寿司通过传送带依次呈现在小Z眼前。  

不同的寿司带给小Z的味觉感受是不一样的，我们定义小Z对每盘寿司都有一个满意度。  

例如小Z酷爱三文鱼，他对一盘三文鱼寿司的满意度为 $10$；小Z觉得金枪鱼没有什么味道，他对一盘金枪鱼寿司的满意度只有 $5$；小Z最近看了电影《美人鱼》，被里面的八爪鱼恶心到了，所以他对一盘八爪鱼刺身的满意度是 $-100$。   

特别地，小Z是个著名的吃货，他吃回转寿司有一个习惯，我们称之为“狂吃不止”。具体地讲，当他吃掉传送带上的一盘寿司后，他会毫不犹豫地吃掉它后面的寿司，直到他不想再吃寿司了为止。  

今天，小Z再次来到了这家回转寿司店，$N$ 盘寿司将依次经过他的面前。其中，小Z对第 $i$ 盘寿司的满意度为$a_i$。  

小Z可以选择从哪盘寿司开始吃，也可以选择吃到哪盘寿司为止。他想知道共有多少种不同的选择，使得他的满意度之和不低于 $L$，且不高于 $R$。

注意，虽然这是回转寿司，但是我们不认为这是一个环上的问题，而是一条线上的问题。即，小Z能吃到的是输入序列的一个连续子序列；最后一盘转走之后，第一盘并不会再出现一次。

## 说明/提示

【数据范围】  

$1\le N \le 10^5$  
$|a_i| \le 10^5$   
$0\le L,R \le 10^9$

## 样例 #1

### 输入

```
5 5 9
1 2 3 4 5```

### 输出

```
6```

# 题解

## 作者：shentao1 (赞：42)

## ~~这道题为什么是紫题？~~

这道题很明显一开始要先求个前缀和，这个问题就转换成求i< j，s[j]-s[i]>=L且s[j]-s[i]<=R的对数（0<=i< n)。感觉这个形式跟逆序对有点像，于是便想到了归并排序。但有点区别，那就是答案的统计方式就没有那么简单了。 


但其实我们化一下式子，变成s[i]-s[j]>=L,s[i]-s[j]<=R（看代码就能理解了），发现就可以用队列来维护，那这题就解决了，注意开long long。

[cdq分治](https://www.luogu.org/blog/Owencodeisking/post-xue-xi-bi-ji-cdq-fen-zhi-hu-zheng-ti-er-fen)水题

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long L,R,ans,s[110000];
void cdq(int l,int r)
{
    if(l==r)return ;
    int mid=(l+r)/2;
    cdq(l,mid),cdq(mid+1,r);
    int head=l,tail=l-1;
    for(int i=mid+1;i<=r;i++)
    {
        while(tail+1<=mid && s[i]>=s[tail+1]+L)tail++;
        while(head<=mid && s[i]>s[head]+R)head++;
        ans+=tail-head+1;
    }
    sort(s+l,s+r+1);
}//cdq分治
int main()
{
    int n;
    scanf("%d%lld%lld",&n,&L,&R);
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        s[i]=s[i-1]+x;//前缀和
    }
    cdq(0,n);
    printf("%lld\n",ans);
    return 0;
}

```



---

## 作者：神眷之樱花 (赞：28)

# 线段树做法
# 题意
对于数列 $a_i(1<= i <= n)$ 求其中满足和在 $L$ 到 $R$ 区间的子段数量为多少。
# 解析
区间和我们可以用前缀和来优化。

那区间 $a_j$ 到 $a_i$ 的和我们可以表示为 $pre[i] - pre[j]$ 。

其中满足条件的区间为:

```cpp
L <= pre[i] - pre[j] <= R

L - pre[i] <= -pre[j] <= R - pre[i]

pre[i] - R <= pre[j] <= pre[i] - L
```


于是我们不难发现，这不就是一个区间求和的问题吗，所以我们只需要对于每一个 $pre[i]$ 求出满足条件的 $pre[j]$ 的数量求个和就行了。

于是我们可以对 $pre$ 数组建一个线段树，枚举 $i$ 再区间查询满足条件的 $j$ 的个数就行了。注意寿司是有出现的时间先后的，所以我们不能一开始就全部插入线段树，应该在枚举完 $i$ 之后再把 $i$ 插入线段树。注意我们还要先将 $pre[0]$插入线段树中。
# 感谢
感谢Nerovix大佬的及时回复，帮我找出了我爆零代码的问题。我会在代码中标出。

```cpp
#include<cstdio>
#define LL long long
const int N = 3.4e6 + 5;//空间要足够大
const LL MAXN = 1e10;
struct SegmentTree {
	int lc,rc,dat;
}tr[4 * N];//空间要足够大
int n,root,tot = 0,le,ri;
long long pre[N],res = 0;
int build() {
	tot++;//千万不要写成tr[++tot],会写假
	tr[tot].lc = tr[tot].rc = tr[tot].dat = 0;
	return tot;
}
void insert(int p,LL val,int add,LL L = -MAXN,LL R = MAXN) {
	if(L == R) {
		tr[p].dat += add;
		return;
	}
	LL mid = (L + R) >> 1;
	if(val <= mid) {
		if(!tr[p].lc) tr[p].lc = build();
		insert(tr[p].lc,val,add,L,mid);
	}
	else {
		if(!tr[p].rc) tr[p].rc = build();
		insert(tr[p].rc,val,add,mid + 1,R);
	}
	tr[p].dat = tr[tr[p].lc].dat + tr[tr[p].rc].dat;
}
int query(int p,LL lf,LL rg,LL L = -MAXN,LL R = MAXN) {
	if(lf <= L && R <= rg) return tr[p].dat;
	LL mid = (L + R) >> 1; int ans = 0;
	if(lf <= mid) {
		if(!tr[p].lc) tr[p].lc = build();
		ans += query(tr[p].lc,lf,rg,L,mid);
	}
	if(rg >  mid) {
		if(!tr[p].rc) tr[p].rc = build();
		ans += query(tr[p].rc,lf,rg,mid + 1,R);
	}
	return ans;
}
inline int read() {
	int x = 0,flag = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')flag = -1;ch = getchar();}
	while(ch >='0' && ch <='9'){x = (x << 3) + (x << 1) + ch - 48;ch = getchar();}
	return x * flag;
}
int main() {
	n = read(),le = read(),ri = read();
	for(int i = 1,x; i <= n; i++) {
		x = read();
		pre[i] = pre[i - 1] + x;
	}
	root = build();
	insert(root,pre[0],1);
	for(int i = 1; i <= n; i++) {
		res += query(root,pre[i] - ri,pre[i] - le);
		insert(root,pre[i],1);
	}
	printf("%lld",res);
	return 0;
}
/*
5 5 9
1 2 3 4 5
*/
```


---

## 作者：Heartlessly (赞：24)

## Description

给定一个长度为 $n$ 的序列 $\{a\}$，现在要从中选出一段连续子序列 $[l,r]$，使得 $L \leq \sum\limits_{i=l}^r a_i \leq R$，求方案数。

$(1 \leq n \leq 10^5, | a_i | \leq 10^5, 1 \leq L,R \leq 10^9)$

## Solution

我们可以枚举 $r = 1 \sim n$，求出对于每个 $r$ 有多少 $l$ 符合条件，累加即是答案。

先预处理出前缀和数组 $pre$，那么 $\sum\limits_{i=l}^r a_i$ 的值为 $pre_r - pre_{l - 1}$，当且仅当 $L \leq pre_r - pre_{l - 1} \leq R$ 时 $l$ 符合条件。

变形一下这个式子，可得 $pre_r - R \leq pre_{l - 1} \leq pre_r -L$ 。

所以我们只需要找到有多少个 $pre_{l - 1} \left(l \in [1,r] \right)$ 在 $[pre_r - R,pre_r - L]$ 区间内。单点修改，区间查询，可以离散化后用树状数组维护，这里我使用了动态开点线段树，原理相同（不要忘记初始时插入 $pre_0 = 0$）。时间复杂度为 $O(n \log n)$ 。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 1e5, LOG = 34;
const LL MAXM = 1e10;
int n, l, r;
LL ans, pre[MAXN + 5];
struct SegmentTree {//动态开点线段树
    int root, tot, sum[MAXN * LOG * 4 + 5], lson[MAXN * LOG * 4 + 5], 
    rson[MAXN * LOG * 4 + 5];
    
    inline void pushUp(int x) {
        sum[x] = sum[lson[x]] + sum[rson[x]];
    }
    void update(int &x, LL q, LL p, LL l = -MAXM, LL r = MAXM) {
        if (!x) x = ++tot;
        if (l == r) {
            sum[x] += p;
            return;
        }
        LL mid = (l + r) >> 1;
        if (q <= mid) update(lson[x], q, p, l, mid);
        else update(rson[x], q, p, mid + 1, r);
        pushUp(x);
    }
    int query(int &x, LL ql, LL qr, LL l = -MAXM, LL r = MAXM) {
        if (!x) x = ++tot;
        if (ql <= l && qr >= r) return sum[x];
        LL res = 0, mid = (l + r) >> 1;
        if (ql <= mid) res += query(lson[x], ql, qr, l, mid);
        if (qr > mid) res += query(rson[x], ql, qr, mid + 1, r);
        return res;
    }
} tr;

int main() {
    read(n), read(l), read(r);
    for (int x, i = 1; i <= n; ++i) {
        read(x);
        pre[i] = pre[i - 1] + x;//预处理前缀和
    }
    tr.update(tr.root, pre[0], 1);//插入 pre[0]
    for (int i = 1; i <= n; ++i) {//枚举右端点
        ans += tr.query(tr.root, pre[i] - r, pre[i] - l);
        //l - 1 在区间 [0,r) 内
        tr.update(tr.root, pre[i], 1);//插入 pre[i]
    }
    write(ans);
    putchar('\n');
    return 0;
}
```

---

## 作者：Cylete (赞：11)

1A

我的做法是对于每一个位置pos，用树状数组统计$x \in [1, pos]$内有多少个$x$使得$\sum\limits_{i = x}^{pos}a[i]$在$L$到$R$之间

先求出前缀和$sum[i]$

对于一个位置$pos$要找的数字

$L \le sum[i] - val \le R$

即得

$val \in [sum[i] - R, sum[i] - L]$

对这个前缀和离散化，方便树状数组操作

```cpp
const int N = 1e5 + 10;

int n, ql, qr, ans;
int a[N], s[N];
int lsh[N], qaq;
int tree[N];

inline void add(int x, int k)
{
	for(; x <= n; x += x & -x) tree[x] += k;
}

inline int ask(int x)
{
	int res = 0;
	for(; x; x -= x & -x) res += tree[x];
	return res;
}

signed main()
{
	into();
	read(n); read(ql); read(qr);
	for(R int i = 1; i <= n; i++) read(a[i]), s[i] = s[i - 1] + a[i], lsh[i] = s[i];
	lsh[n + 1] = 0;
	sort(lsh + 1, lsh + n + 2);
	qaq = unique(lsh + 1, lsh + n + 2) - lsh - 1;
	add(lower_bound(lsh + 1, lsh + qaq + 1, 0) - lsh, 1);
	for(R int i = 1; i <= n; i++)
	{
		R int lim_l = lower_bound(lsh + 1, lsh + qaq + 1, s[i] - qr) - lsh - 1, lim_r = upper_bound(lsh + 1, lsh + qaq + 1, s[i] - ql) - lsh - 1;
		ans += ask(lim_r) - ask(lim_l);
		add(lower_bound(lsh + 1, lsh + qaq + 1, s[i]) - lsh, 1);
	}
	writeln(ans);
	return 0;
}
```

---

## 作者：Ryo_Yamada (赞：9)

题意：求有多少个 $[l,\,r]$ 使 $L \leq \sum_{i=l}^r a_i \leq R$。

可以使用前缀和的思想，将题目转化为：

$$L \leq \sum_{i=1}^r a_i - \sum_{i=1}^{l-1} a_i \leq R$$

$$\sum_{i=1}^r a_i - R \leq \sum_{i=1}^{l-1} a_i \leq \sum_{i=1}^r a_i - L$$

用数据结构维护一下，我用的是 fhq Treap，先插入一个 $0$（否则无法计算 $[1,\,r$] 的情况），然后每次插入 $pre_i$，并查询。

数据范围实际应为 $0 \leq L,\,R \leq 10^9$。需要注意，因为插入了 $0$，当 $L=0$ 时每次查询会多 $+1$（当取出的是空子段时）。所以当 $L=0$ 使答案需要减去 $n$。

$\text{Code}$：

```cpp
def(N, int, 1e5 + 5)

struct FHQ {
	int ls, rs, sze, rnd;
	ll val;
} t[N];

int n, x, y, root;
int w[N];
ll pre[N], ans;

int New(ll x) {
	static int r = 0;
	++r;
	
	t[r].ls = t[r].rs = 0;
	t[r].sze = 1;
	t[r].rnd = rand();
	t[r].val = x;
	
	return r;	
}

void pushup(int x) { t[x].sze = t[t[x].ls].sze + t[t[x].rs].sze + 1; }

int merge(int x, int y) {
	if(!x || !y) return x + y;
	if(t[x].rnd < t[y].rnd) {
		t[x].rs = merge(t[x].rs, y);
		pushup(x);
		return x;
	}
	else {
		t[y].ls = merge(x, t[y].ls);
		pushup(y);
		return y;
	}
}

void split(int rt, int &x, int &y, ll k) {
	if(!rt) return x = y = 0, void();
	if(t[rt].val <= k) {
		x = rt;
		split(t[rt].rs, t[rt].rs, y, k);
	}
	else {
		y = rt;
		split(t[rt].ls, x, t[rt].ls, k);
	}
	pushup(rt);
}

void insert(ll x) {
	int l, r;
	split(root, l, r, x - 1);
	root = merge(l, merge(New(x), r));	
}

int query(ll x) {
	int l, mid, r;
	split(root, l, r, x - ::x);
	split(l, l, mid, x - y - 1);
	int ret = t[mid].sze;
	root = merge(l, merge(mid, r));
	return ret;	
}

int main() {
	srand(19260817);
	qread(n, x, y);
	rep(i, 1, n) qread(w[i]), pre[i] = pre[i - 1] + w[i];
	insert(0);
	rep(i, 1, n) {
		insert(pre[i]);
		int x = query(pre[i]);
		ans += x;
		//printf("%d\n", x);
	}
	printf("%lld\n", ans - (x == 0 ? n : 0));
 	return 0;
}
```


---

## 作者：山田リョウ (赞：6)

问题可以简化成有多少个 $l,r$ 满足 $L \leq \sum\limits_{i=l}^r a_i \leq R$。

我们可以把 $\sum\limits_{i=l}^r a_i$ 表示成前缀和相减，即 $\sum\limits_{i=1}^r a_i - \sum\limits_{i=1}^{l-1} a_i$。

然后我们从左往右依次枚举每个右端点，来考虑有多少个满足要求的左端点。

我们可以推得：

$\sum\limits_{i=1}^r a_i - R \leq \sum\limits_{i=1}^{l-1}a_i \leq \sum\limits_{i=1}^ra_i - L$

用某个神奇数据结构维护就行了，就比如平衡树、值域线段树、值域树状数组。

菜鸡用的值域树状数组，代码如下：
```cpp
#include<stdio.h>
#include<algorithm>
const int maxn=100001;long long qwq[maxn];int a[maxn],C[maxn+1],n,m,l,r;
inline int lowbit(int x){return x&-x;}
inline void ins(int x){for(;x<=m;x+=lowbit(x))++C[x];}
inline int rank(int x){int ans=0;for(;x;x-=lowbit(x))ans+=C[x];return ans;}
inline int key(long long x){return std::lower_bound(qwq,qwq+m,x)-qwq;}
int main(){
    scanf("%d%d%d",&n,&l,&r);
    for(int i=1;i<=n;++i)scanf("%d",a+i),qwq[i]=qwq[i-1]+a[i];
    std::sort(qwq,qwq+n+1);m=std::unique(qwq,qwq+n+1)-qwq;
    long long sum=1,ans=0;ins(key(1));
    for(int i=1;i<=n;++i){
        sum+=a[i];
        ans+=rank(key(sum-l))-rank(key(sum-r-1));
        ins(key(sum));
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Piwry (赞：6)

这题推式子的题解好像都有一个细节问题没提到...~~（可能只有我太菜觉得需要提...）~~ 就是查询区间应该和插入**同步进行**，因为区间前缀和不保证递增。

## 解析

首先题目是要求我们求所有满足区间和在 $[L, R]$ 范围内的区间。如果直接做的话会非常麻烦 ~~（当然不排除大佬直接各种方法暴草QAQ）~~ ，可以考虑试着推下式子。

首先区间和可以用前缀和（$sum[.]$）表示，题目就是要求求所有 $l, r$ 满足 $L\leqslant sum[r]-sum[l-1] \leqslant R$。

可以想到如果只统计一个点的数量维护会比较方便，于是就可以化成 $sum[r]-R\leqslant sum[l-1]\leqslant sum[r]-L$，这显然只需用权值线段树动态开点（或者离散化），枚举 $r$ 就可以了。

---

但在实现时有一个细节尤其值得注意：

因为满意度是有可能为负数的，这代表区间和不是递增的：具体的来说，假设有 $l \leqslant r$ 满足条件，又有 $l' > r$ 不满足条件，它们的前缀和 $sum$ 是有可能相等的。

因此我们需要边插入边查询，当插入到 $r$ 的时候同时询问 $sum[r]-R\leqslant sum[l-1]\leqslant sum[r]-L$ 的个数，就能保证 $l$ 合法。

## CODE

这里维护用的是权值线段树动态开点。

```cpp
#include <cstdio>
#define ll long long

const ll N =((1ll)<<35), MAXN =1e5+50;

int cnt[MAXN<<10], ls[MAXN<<10], rs[MAXN<<10], top, CNT;

inline int pushup(int s){ return cnt[s] =cnt[ls[s]]+cnt[rs[s]], s; }

int modify(ll x, int s, ll nl =1, ll nr =N){
	if(!s) s =++CNT;
	if(nl == nr) return ++cnt[s], s;
	ll mid =(nl+nr)>>1;
	if(x <= mid) ls[s] =modify(x, ls[s], nl, mid);
	else rs[s] =modify(x, rs[s], mid+1, nr);
	return pushup(s);
}

int query(ll l, ll r, int s, ll nl =1, ll nr =N){
	if(l <= 0 || r <= 0) return 0;
	if(!s) return 0;
	if(l == nl && r == nr) return cnt[s];
	ll mid =(nl+nr)>>1;
	if(r <= mid) return query(l, r, ls[s], nl, mid);
	else if(l > mid) return query(l, r, rs[s], mid+1, nr);
	else return query(l, mid, ls[s], nl, mid)+query(mid+1, r, rs[s], mid+1, nr);
}

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(c^48), c =getchar();
	return (f) ? -x : x;
}

int n, L, R;
ll sum[MAXN];

int main(){
	n =read(), L =read(), R =read();
	for(int i =1; i <= n; ++i) sum[i] =sum[i-1]+read();
	ll ans =0;
	/*注意 l-1 可取 0，且不可取 n*/
	for(int r =1; r <= n; ++r) top =modify(sum[r-1]+1e10+1, top), ans +=query(sum[r]-R+1e10+1, sum[r]-L+1e10+1, top);
	printf("%lld", ans);
}
```


---

## 作者：JJA_ (赞：6)

题目链接[link](https://www.luogu.com.cn/problem/P5459)

## 题目大意


给出一个有 $n$ 个数的序列 ${a}$ 和边界 $L,R$，求问有多少连续子序列使 $L\le \sum\limits_{i=l}^r a_i \le R $

## 思路

可以将整个序列转化为前缀和序列 ${sum}$，之后对这个序列进行插入和查询操作，很容易想到 `CDQ分治`。依据题意，我们只需要维护一下和在 $L$ 和 $R$ 之间的子序列。同时， `CDQ分治` 是可行的，因为在维护后左右区间的值和 $L,R$ 之间的下表都变为递增的，答案统计也是没有问题的。因此，只需要归并排序并维护即可。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<sstream>
#include<queue>
//#include<map>
#include<vector>
#include<math.h>
using namespace std;
#define int long long
#define forr(i,a,b) for(int i=a;i<=b;i++)
#define repp(i,a,b) for(int i=a;i>=b;i--)
#define INF 1e9
#define ll long long
#define MAXN 2000005
const int _x[]={0,1,0,-1,0},_y[]={0,0,1,0,-1};
#define mem(a,n) memset(a,n,sizeof(a));
#define chkmax(a,b) a=a>b?a:b;
#define chkmin(a,b) a=a<b?a:b;
#include<set>
#include<stack>
#define DE puts("check");
#define inr int
inr a[MAXN];
inr N,L,R;
int ans;
void cdq(int pl,int pr);
signed main(){
	scanf("%lld%lld%lld",&N,&L,&R);
	forr(i,1,N){
		int tmp;
		scanf("%lld",&tmp);
		a[i]=a[i-1]+tmp;
	}
	cdq(0,N);
	printf("%lld",ans);
}
void cdq(inr pl,int pr){
	if(pl==pr){
		return;
	}
	int mid=pl+pr>>1;
	cdq(pl,mid),cdq(mid+1,pr);
	int l=pl;
	inr r=pl-1;
	forr(i,mid+1,pr){
		for(r;r+1<=mid and a[i]>=a[r+1]+L;r++){
			;
		}
		for(l;l<=mid and a[i]>a[l]+R;l++){
			;
		}
		ans+=r-l+1;
	}
	sort(a+pl,a+pr+1);
}
```

---

## 作者：Robert2259960864 (赞：6)

# CDQ分治+队列维护 #

暂时看本题还没什么题解，就发一篇。发现正解应该是树套树？不过本题是我看同机房大佬[青葱](https://www.luogu.org/space/show?uid=139717)在做的一道题，他说可以用CDQ分治做，正好我最近练习CDQ分治，就看了一眼，并受青葱大佬的指点，本蒟蒻终于做出了这道题。



------------
本题解会加入一些笔者对CDQ分治的理解，好了，废话不多说

题意：有$n$个点组成的序列，对于第$k$个点（$1<=k<=n$），询问从第$k$个点到第$j$个点的和大于等于$L$,小于等于$R$（$j<=k$），求所有$k$满足要求的$j$的数量之和。

**如果学过CDQ分治的dalao们可以跳到第二板块**

## 1、浅谈CDQ分治 ##
最基本的CDQ分治：拥有插入和查询的功能，可以完成序列上的数量查询。

### CDQ分治总结：
左区间修改（插入），右区间记录左区间对右区间的影响

### CDQ分治的理解：
看了很多讲解，一直对左区间和右区间没什么直观感受，这要慢慢自行yy。在此多说一些自己的理解：在序列上，**一个查询是由之前就存在（插入）的值来影响的**。

比如$1$ ,$3$ ,$7$ ,$2$ ,$5$ ,$4$ ,$8$这个序列，求值为$5$的数之前有多少数比他小，显然有$1$, $3$, $2$, 三个数，而排在$5$后面的$4$没有影响到$5$的统计。

明白这一点之后，CDQ分治的核心基本已经讲清楚了。

接着，我们将CDQ分治 ，分为**CDQ**和**分治**（自己强行分开）

**分治**：在此不多说，可以看[p1908 逆序对](https://www.luogu.org/problemnew/show/P1908)的题解，并自己做一做。分治就是将序列递归到最低层，并返回的时候，根据大小归并排序。

**CDQ**:将插入和查询根据时间放入序列，所以我们分为四个部分：

左区间中插入：由于左区间可以对右区间影响（因为左区间在前面）

左区间的查询：由于左区间的查询已经结束，右区间不能对左区间影响，所以左区间的查询可以不用管

右区间的插入:由于右区间的插入不能对左区间的查询造成影响，所以可以不用管

右区间的查询：由于右区间的查询可以被左区间的插入值所影响，故将左区间的合法影响统计下来（可以用树状数组维护）

**对于左区间的统计，已经在上一层序列统计完了，而右区间的统计，上一层序列值统计了一部分，在这一层还有比它更前面的数没有统计**

在此，CDQ分治的基本已经讲完了。

我推荐几道题：
[p3374树状数组1](（https://www.luogu.org/problemnew/show/p3374）)  [p3810三维偏序](https://www.luogu.org/problemnew/show/p3810)  [p2163园丁的烦恼](https://www.luogu.org/problemnew/show/p2163)  [p3157动态逆序对](https://www.luogu.org/problemnew/show/p2163)

## 2、本题讲解
我们先来分析一下为什么能用CDQ分治：1）一个序列 2）有插入有查询（只不过这道题查询和插入在一起） 

满足要求，那么就可以上CDQ分治了。因为是连续的子序列，所以我们很容易想到用前缀和，用两点的差代表序列。接着根据序列的顺序进行CDQ分治，在CDQ分治里面，我们可以用队列维护序列和大于等于$L$和小于等于$R$的位置，因为CDQ分治后，左区间和右区间内的值都是有序递增的，那么$L$和$R$的满足的下标也是递增的，所以可以用队列维护边界。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100010
int n,vl,vr,sum[MAXN],tmp[MAXN],q[MAXN],ans;

void CDQ(int l, int r){
	if(l == r) return;
	int mid = l+r>>1;
	CDQ(l,mid); CDQ(mid+1,r);
	int p1 = l, p2 = mid+1, t = l-1, cur = l-1, cl = l, cr = l;
	while(p1 <= mid && p2 <= r){
		if(sum[p1] <= sum[p2]){//归并排序，比较值
			q[++cur] = sum[p1];
			tmp[++t] = sum[p1++];
		}else{
			while(cl<=cur && sum[p2]-q[cl] >= vl) cl++;
			while(cr<=cur && sum[p2]-q[cr] > vr) cr++;
			ans += cl-cr;
			tmp[++t] = sum[p2++];
		}
	}
	while(p1 <= mid){
		tmp[++t] = sum[p1++];
	}
	while(p2 <= r){
		while(cl<=cur && sum[p2]-q[cl] >= vl) cl++;
		while(cr<=cur && sum[p2]-q[cr] > vr) cr++;
		ans += cl-cr;
		tmp[++t] = sum[p2++];
	}
	for(int i=l; i<=r; i++){
		sum[i] = tmp[i];
	}
}

int main(){
	scanf("%d%d%d",&n,&vl,&vr);
	for(int i=1; i<=n; i++){
		scanf("%d",&sum[i]);
		sum[i] += sum[i-1];
	}
	CDQ(0,n);//注意要从0开始，因为是记录前缀和，不然1的值没法表示
	printf("%d",ans);
	return 0;
}

```
自己的代码实在有点丑，可能是最初学的CDQ分治模板不一样，导致自己的版本的CDQ分治太长了。还有有人用sort在CDQ分治里面排序，很简洁美观，不过不是稳定的$O(logn)$复杂度。

---

## 作者：GKxx (赞：6)

首先对$a_i$求前缀和$s_i$

我们要求有多少对$(l,r)$，满足$L\leq s_r-s_{l-1}\leq R$

变形一下就是$s_r-R\leq s_{l-1}\leq s_r-L$

那么枚举右端点$r$，查询在这个值域范围内的数有多少个，用一个树状数组即可，查完把$s_r$加进树状数组。

一开始将所有的$s_i,s_i-L,s_i-R$混在一起离散化。

时间复杂度$O(n\log n)$

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> inline void writeln(T x) { write(x); puts(""); }
template <typename T> inline bool chkmin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkmax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

typedef long long LL;

const int maxn = 1e5 + 307, maxsize = 3e5 + 207;

LL bit[maxsize], a[maxn], s[maxn], tmp[maxsize];
int n, L, R, all;

inline int query(int l, int r) {
    int ans = 0;
    for (; r; r -= r & -r) ans += bit[r];
    for (--l; l; l -= l & -l) ans -= bit[l];
    return ans;
}
inline void insert(int x) {
    for (; x <= all; x += x & -x) ++bit[x];
}

int main() {
    read(n, L, R);
    tmp[++all] = 0;
    for (int i = 1; i <= n; ++i) {
        read(a[i]);
        s[i] = s[i - 1] + a[i];
        tmp[++all] = s[i];
        tmp[++all] = s[i] - L;
        tmp[++all] = s[i] - R;
    }
    std::sort(tmp + 1, tmp + all + 1);
    all = std::unique(tmp + 1, tmp + all + 1) - (tmp + 1);
    LL ans = 0;
    insert(std::lower_bound(tmp + 1, tmp + all + 1, 0) - tmp);
    for (int r = 1; r <= n; ++r) {
        int x = std::lower_bound(tmp + 1, tmp + all + 1, s[r] - R) - tmp;
        int y = std::lower_bound(tmp + 1, tmp + all + 1, s[r] - L) - tmp;
        ans += query(x, y);
        int z = std::lower_bound(tmp + 1, tmp + all + 1, s[r]) - tmp;
        insert(z);
    }
    writeln(ans);
    return 0;
}
```


---

## 作者：Link_Space (赞：3)

首先拿到这道题时我先想的是 $N^2$ 的暴力做法，只需要处理一个前缀和后枚举左右端点判断是否满足题目所给条件然后累加答案即可，但是数据范围 $N\leqslant10^5$ 直接灭杀了我们的这个念头，于是思考如何对这个思路进行优化。

众所周知的是，主席树即可以看作一个前缀和，时间复杂度又恰好是 $O(N\log N)$ 所以我们这道题就可以使用主席树来优化前缀和。

由于要满足 $L \leqslant sum[r]-sum[l-1] \leqslant R$

移项可得,对于每一个右端点 $r$ ，只需要找出满足 $sum[r]-R\leqslant sum[l-1] \leqslant sum[r]-L$ 的左端点即可。

所以我们只需要枚举每一个右端点，找出满足条件的左端点个数并累加答案，然后将这个右端点的前缀和加入主席树继续下一个枚举，最后就可以得到答案。

知道了这个之后，代码实现就很简单。


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
const ll MAXN = 1e10 + 1e5 + 5;
int n, L, R;
int tot;
struct Node{
    int ls, rs;
    int cnt;
} Tree[N * 100];
ll sum[N];
void insert(int now,ll l,ll r,ll x)
{
    if(l==r)
    {
        Tree[now].cnt++;
        return;
    }
    ll mid = l + r >> 1;
    if(x<=mid)
    {
        if(!Tree[now].ls)
            Tree[now].ls = ++tot;
        insert(Tree[now].ls, l, mid, x);
    }
    else 
    {
        if(!Tree[now].rs)
            Tree[now].rs = ++tot;
        insert(Tree[now].rs, mid + 1, r, x);
    }
    Tree[now].cnt = Tree[Tree[now].ls].cnt + Tree[Tree[now].rs].cnt;
}
int query(int now, ll l, ll r, ll ql, ll qr) 
{
    if(!Tree[now].cnt||!now)
        return 0;
    if(ql<=l&&r<=qr)
        return Tree[now].cnt;
    ll mid = l + r >> 1;
    int res = 0;
    if(ql<=mid)
        res += query(Tree[now].ls, l, mid, ql, qr);
    if(qr>mid)
        res += query(Tree[now].rs, mid + 1, r, ql, qr);
    return res;
}
int main()
{
    scanf("%d%d%d", &n, &L, &R);
    for (int i = 1; i <= n;i++)
    {
        int a;
        scanf("%d", &a);
        sum[i] = sum[i - 1] + a;
    }
    ll ans = 0;
    tot = 1;
    insert(1, 1, MAXN << 1, MAXN);
    for (int r = 1; r <= n;r++)
    {
        ans += query(1, 1, MAXN << 1, sum[r] - R + MAXN, sum[r] - L + MAXN);
        insert(1, 1, MAXN << 1, sum[r] + MAXN);
    }
    printf("%lld\n", ans);
}
```


---

## 作者：xcxc82 (赞：3)

# P5459 [BJOI2016]回转寿司 题解


## [间隙](https://www.luogu.com.cn/problem/P5459)

## 前置知识

- ## 前缀和,权值线段树,动态开点

如果您还不会权值线段树跟动态开点的话,推荐去看一下[**这个教程**](https://www.bilibili.com/video/BV1Zg4y1q7aY?t=1726)

## 大致题意

给一个序列,现从中取出一段连续子序列,使其子序列内数值总和$a$满足$L\le a\le R$

求总方案数。

## 分析

区间求和,很容易先联想到前缀和

不妨先设$sum[i]$为前$i$个数的前缀和

易得式子:

$L \le sum[r] - sum[l-1] \le R$

移项一下

$sum[r]-L \le sum[l-1]  \le sum[r]-R $



这样原问题就转化为了**在区间$[sum[r]-L,sum[r]-R]$中有多少个$sum[l-1]$($l \in[1,r]$ )**

**每一个$r$也就相当于是查询区间$[sum[r]-L,sum[r]-R]$中$sum[l-1]$的总和**($l \in[1,r]$ )

可以使用权值线段树$+$动态开点来维护。

## 代码实现

从$1$~$n$枚举$r$的值,把每一个$r$当作一次"查询"

同时不要忘记在进行下一次"查询" 前把 $l$ 的值 "更新"(指插入新的值)

具体的注释里有讲

```cpp
#include<bits/stdc++.h>
using namespace std;
long long MAXN = 1e10;
const int N = 1e5+5;
long long sum[N];//前缀和 
int n,l,r;
long long ans = 0;
int tot = 0;
struct st{
	int l,r,sum;//左儿子,右儿子,总方案数 
}tree[N<<10];

void pushup(int node){//上传操作 
	tree[node].sum = tree[tree[node].l].sum+tree[tree[node].r].sum;
}
void insert(int &node,long long x,long long l = -MAXN , long long r = MAXN){//更新 注意,l的初始值要设成负数,一开始在这里卡了好久\kk 
	
	if(!node) node = ++tot;//动态开点 
	if(l==r){//如果为根节点 
		tree[node].sum++;
		return;
	}
	long long mid = (l + r)>>1;
	if(x<=mid) update(tree[node].l,x,l,mid);
	else update(tree[node].r,x,mid+1,r);
	pushup(node);//更新父节点的值 
	
}

long long query(int &node,long long x,long long y,long long l =-MAXN,long long r = MAXN){//查询操作 
	if(!node) node = ++tot;//动态开点 
	if(x<=l&&y>=r){//包含在查询范围内 
		return tree[node].sum;
	}
	long long res = 0;
	long long mid = (l+r)>>1;
	if(x<=mid) res+=query(tree[node].l,x,y,l,mid); 
	if(y>mid) res+=query(tree[node].r,x,y,mid+1,r); 
	return res;
}
int main(){
	int root = 0;
	scanf("%d%d%d",&n,&l,&r);
	for(int i=1;i<=n;i++){
		int a;
		scanf("%d",&a);
		sum[i] = sum[i-1] + a;//前缀和 
	}
	insert(root,0);//不要忘记插入0,也就是说一个都不吃的情况 
	for(int i=1;i<=n;i++){
		ans+=query(root,sum[i] - r,sum[i] - l);//加方案数 
		insert(root,sum[i]);//"更新"l的值 
	}
	cout<<ans;
} 
```







---

## 作者：Remake_ (赞：3)

真实难度黄题。

令 $b_i=\sum\limits_{k=1}^ia_k$，$b_0=0$ 。

则题意可转化为对于每一个 $b_i$ ，在 $0\sim i-1$ 中有多少个 $j$ 满足 $b_j\in[b_i-R,b_i-L]$ 。

显然可以用平衡树维护。

不过本题数据 $\texttt{1e5}$ ，歪解随便过，使用 $\texttt{vector}$ 维护一下插排数组，每次询问时 $\texttt{vector}$ 上二分一下就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 0x7fffffff
#define timeused() (double)clock()/CLOCKS_PER_SEC
#define rep(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define repp(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define mp make_pair
#define pb push_back
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x){
   T f=1;x=0;char c=getchar();
   for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
   for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
   x*=f;
   return x;
}
ll n,l,r,a[100005],sum;
vector<ll> v;
int main(){
   rd(n);
   rd(l);
   rd(r);
   v.pb(0);
   rep(i,1,n){
      rd(a[i]);
      a[i]+=a[i-1];
      sum+=v.size()-(lower_bound(v.begin(),v.end(),a[i]-r)-v.begin());
      sum-=v.size()-(upper_bound(v.begin(),v.end(),a[i]-l)-v.begin());
      v.insert(lower_bound(v.begin(),v.end(),a[i]),a[i]);
   }
   printf("%lld",sum);
}
```


---

## 作者：胡尔克HULK (赞：2)

抛开那些复杂的数据结构（我经常写不出的那种），来看一看这题的数据

首先处理前缀和，s[0]=0,s[n]=s[n-1]+a[n];

然后我们可以把这些前缀和的**数据点**放到一个图中，从1到n排好

要求的也就是对于每一个**数据点**n，在他前面的前缀和s[n]-l<=s[i]<=s[n]-r的个数

那么我们就可以在这个**数据点**的位置上增加两个**询问点**，值分别为s[n]-(l-1)和s[n]-r,**询问点**可以记录n之前有多少个前缀和的**数据点**小于等于询问值

那么我们把这些点画在一个图上（**询问点**画在**数据点**后面），就发现这些点构成一个序列，我们把**数据点**的权值定为1，**询问点**的权值定为0，那么对于每个**询问点**，求出其之前所有数值不大于他的点的权值和，就是吃到n为止满足条件的个数

### 最简单的做法就是将整个数列归并排序求逆序权值和

不会求逆序对的看这个
[逆序对模板](https://www.luogu.com.cn/problem/P1908)

模板里面就是每个数权值为1的特殊情形，把他一般化，累加的时候加权值而不是简单+1就ok了
# 代码如下
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
ll a0=0;
struct vs{
	ll p, n, val, d;
}vc[400001];
bool operator<(vs a,vs b)
{
	return a.n<b.n||(a.n==b.n&&a.d>b.d);
}
ll a[400001],ans[400001],rq[400001];
vs s0[400001];
void mgsort(ll l,ll r)
{
	if (l==r) return;
	ll mid=(l+r)/2;
	mgsort(l,mid);
	mgsort(mid+1,r);
	ll a=l,b=mid+1;
	ll m=0,r0=0;
	while (1)
	{
		if (a>mid&&b>r) break;
		if (a>mid)
		{
			s0[++m]=vc[b];
			ans[vc[b].d]+=r0;
			b++;
			continue;
		}
		if (b>r)
		{
			s0[++m]=vc[a];
			r0+=vc[a].val;
			a++;
			continue;
		}
		if (vc[a].p>=vc[b].p)
		{
			s0[++m]=vc[a];
			r0+=vc[a].val;
			a++;
		}
		else {
			s0[++m]=vc[b];
			ans[vc[b].d]+=r0;
			b++;
		}
	}
	for (ll i=l;i<=r;i++)
		vc[i]=s0[i-l+1];
}
int main()
{
	ll n,l,r;
	cin>>n>>l>>r;
	vc[0].p=0;
	vc[0].n=0;
	vc[0].d=0;
	vc[0].val=1;
	for (ll i=1;i<=n;i++){
		cin>>a[i];
		vc[i].p=vc[i-1].p+a[i];
		vc[i].n=vc[i].d=i;
		vc[i].val=1;
	}
	for (ll i=1;i<=n;i++)
	{
		vc[i+n].p=vc[i].p-r;
		vc[i+n].n=i;
		vc[i+n].d=i+n;
		vc[i+n].val=0;
	}
	for (ll i=1;i<=n;i++)
	{
		vc[i+2*n].p=vc[i].p-l+1;
		vc[i+2*n].n=i;
		vc[i+2*n].d=i+2*n;
		vc[i+2*n].val=0;
	}
	sort(vc+1,vc+3*n+1);
	ll sum=0;
	for (ll i=1;i<=n;i++)
		sum+=ans[i+n]-ans[i+2*n];
	cout<<sum<<endl;
}
```


---

## 作者：Reanap (赞：2)

似乎没有人打平衡树的题解，那我就来水一发~

我们将题目做一个简单的转化：

设$sum_i = \sum_{j=1}^{i} a_j$

那么答案就是$\sum_{i=1}^{n}\sum_{j=1}^{i} (L \leq (sum_i - sum_{j-1}) \leq R)$

我们可以利用容斥的思想进行简单是转化：

$\sum_{i=1}^{n}\sum_{j=1}^{i} (L \leq (sum_i - sum_{j-1})) - \sum_{i=1}^{n}\sum_{j=1}^{i} (R < (sum_i - sum_{j-1}))$

因此，我们只用枚举$sum_i$，并在一个可以接受的时间复杂度内分别找到相对应的$j$的数目，即$sum_{j - 1} \leq sum_i - L$的$j$的个数和$sum_{j - 1} \leq sum_i - R - 1$的$j$的数量，并把他们相减。

而查找这些数目完全可以用平衡树来实现，下面的代码打的是$treap$，仅供参考。

注：题目的数据范围似乎有问题，似乎是$0 \leq L , R\leq 10^9$

```cpp
#include <cstdio>
#include <ctime>
#include <algorithm>
using namespace std;
typedef long long LL;
const int MAXN = 1e5 + 5;

struct node {
	LL lc , rc , data , pri , si , cnt;
}t[MAXN];

void Zig(LL &k) {
	LL y = t[k].lc;
	t[k].lc = t[y].rc;
	t[y].rc = k;
	t[y].si = t[k].si;
	t[k].si = t[t[k].lc].si + t[t[k].rc].si + t[k].cnt;
	k = y;
}

void Zag(LL &k) {
	LL y = t[k].rc;
	t[k].rc = t[y].lc;
	t[y].lc = k;
	t[y].si = t[k].si;
	t[k].si = t[t[k].lc].si + t[t[k].rc].si + t[k].cnt;
	k = y;
}

LL num = 0;
void Insert(LL &k , LL key) {
	if(!k) {
		k = ++num;
		t[k].data = key;t[k].pri = rand();
		t[k].si = 1;t[k].cnt = 1;
		return;
	} 
	t[k].si ++;
	if(t[k].data == key) t[k].cnt ++;
	else if(t[k].data < key) {
		Insert(t[k].rc , key);
		if(t[t[k].rc].pri < t[k].pri) Zag(k);
	}
	else {
		Insert(t[k].lc , key);
		if(t[t[k].lc].pri < t[k].pri) Zig(k);
	}
}

LL n , rt;

LL x_rank(LL x) {
	LL k = rt , ans = 0;
	while(k) {
		if(x == t[k].data) return ans + t[t[k].lc].si + t[k].cnt;
		if(x > t[k].data) ans += t[t[k].lc].si + t[k].cnt , k = t[k].rc;
		else k = t[k].lc;
	}
	return ans;
}

LL L , R , a[MAXN];
int main() {
	srand(19491001);
	scanf("%lld %lld %lld" , &n , &L , &R);
	for (int i = 1; i <= n; ++i) {
		scanf("%lld" , &a[i]);
		a[i] += a[i - 1];
	}
	LL ans = 0;
	Insert(rt , 0);
	for (int i = 1; i <= n; ++i) {
		ans += x_rank(a[i] - L);
		ans -= x_rank(a[i] - R - 1); 
		Insert(rt , a[i]);
	}
	printf("%lld" , ans);
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 题目描述

求一个子序列，使子序列的和大于等于 $L$ 小于等于 $R$ 的方案数。

## 线段树解法

考虑用前缀和优化。

将问题转化为求 $L\leq sum_{r} - sum_{l} \leq R$。 直接 $\Theta(n^2)$ 暴力求解，显然会挂。

将式子变形为 $sum_{r} - R\leq sum_{l}\leq sum_{r} - L$。 每次插入一个值之前，查询它之前满足条件的方案数，再插入。**注意一开始要插入 $sum_{0}$。**

考虑到空间问题，采用动态开点。

## 代码展示

```cpp
#include<cstdio>
#define LL long long
using namespace std;

const int MAXN = 1e5 + 5;
const LL INF = 1e10;

int n, l, r, root, tot;
LL sum[MAXN];

struct node {
	int l, r;
	LL val;
}tr[MAXN * 20];

void updata(int &now, LL lf, LL rg, LL val) {
	if(now == 0) {
		now = ++tot;
		tr[now].l = tr[now].r = tr[now].val = 0;
	}
	++tr[now].val;
	if(lf == rg) return ;
	LL mid = (lf + rg) >> 1ll;
	if(val <= mid) updata(tr[now].l, lf, mid, val);
	else updata(tr[now].r, mid + 1, rg, val);
}

LL query(int &now, LL lf, LL rg, LL L, LL R) {
	if(!now || lf > R || rg < L) return 0;
	if(L <= lf && rg <= R) return tr[now].val;
	LL mid = (lf + rg) >> 1ll;
	LL res = 0ll;
	if(L <= mid) res = query(tr[now].l, lf, mid, L, R);
	if(R > mid) res += query(tr[now].r, mid + 1, rg, L, R);
	return res;
}

int main() {
	scanf("%d%d%d",&n, &l, &r);
	for(int i = 1; i <= n; i++) {
		scanf("%lld",&sum[i]);
		sum[i] += sum[i - 1];
	}
	updata(root, -INF, INF, 0ll);
	LL res = 0ll;
	for(int i = 1; i <= n; i++) {
		res += query(root, -INF, INF, sum[i] - r, sum[i] - l);
		updata(root, -INF, INF, sum[i]);
	}
	printf("%lld\n",res);
	return 0;
}
```


---

## 作者：Martian148 (赞：1)

# Link
[P5459 [BJOI2016]回转寿司](https://www.luogu.com.cn/problem/P5459)

# Solve
这道题的题面描述可能有点问题，这道题题面上说是子序列，实际上选的是一个连续的子序列。

由于每次只能选连续的一段，我们就求一个前缀和$S[i]= \sum_{j=1}^ia[i]$

题目问的是连续一段的总代价在$[L,R]$，所以

$L≤ \sum_{k=i}^{j} a[i]≤R$ $\Rightarrow L≤S[i]-S[j-1]≤R$

$\Rightarrow S[i]-R≤S[j-1]≤S[i]-L,(j≤i)$

题目就转化成，枚举到一个$S[i]$求之前的，在$[S[i]-R,S[i]-L]$上$S[j]$的个数

用树状数组或者线段树就可以处理了

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=100005;
const LL maxR=1e10;
int N,tot,root;
LL L,R,S[maxn],ans;
struct node{
	int lson,rson,sum;
}Tree[13600005];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}

inline void push_up(int x){
	Tree[x].sum=Tree[Tree[x].lson].sum+Tree[Tree[x].rson].sum;
	return ;
}

inline int build(){
	++tot;Tree[tot].lson=Tree[tot].rson=Tree[tot].sum=0;
	return tot;
}

int update(int x,LL l,LL r,LL pos,int val){
	if(!x)x=build();
	if(l==r){Tree[x].sum+=val;return x;}
	LL mid=r+l>>1;
	if(pos<=mid)Tree[x].lson=update(Tree[x].lson,l,mid,pos,val);
	else Tree[x].rson=update(Tree[x].rson,mid+1,r,pos,val);
	push_up(x);
	return x;
}

int query(int x,LL l,LL r,LL ql,LL qr){
	if(!x)x=build();
	if(ql<=l&&r<=qr)return Tree[x].sum;
	LL ret=0,mid=l+r>>1;
	if(ql<=mid)  ret+=query(Tree[x].lson,l,mid,ql,qr);
	if(qr> mid)ret+=query(Tree[x].rson,mid+1,r,ql,qr);
	return ret;
}

int main(){
	freopen("P5459.in","r",stdin);
	freopen("P5459.out","w",stdout);
	N=read();L=read();R=read();
	for(int i=1;i<=N;i++)S[i]=S[i-1]+read();
	root=update(root,-maxR,maxR,S[0],1);
	for(int i=1;i<=N;i++){
		ans+=query(root,-maxR,maxR,S[i]-R,S[i]-L);
		update(root,-maxR,maxR,S[i],1);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Yuno (赞：1)

首先，枚举每个 $r = 1 \sim n$，  
统计对于每个 $r$，有多少个 $l$ 满足条件。  
考虑如何统计：  
把序列 $\{a\}$的前缀和记为 $sum[i]$。  
问题转化为:  
对于每个 $r$，有多少 $l$ 满足  
$L \leq sum_r - sum_{l - 1} \leq R$  
移项，得  
$sum_r - R \leq pre_{l - 1} \leq sum_r -L$  
发现只要统计   
区间$[sum_r - R,sum_r - L]$ 里 $sum_{l - 1}$的出现次数。   
然后统计完了插入 $sum_r$ 即可。  
题解区里有很多dalao用树状数组，cdq分治等解法。  
我使用的是平衡树，个人认为更加简单易懂。  
~~其实是我这些都不会~~  
code：
```
#include <bits/stdc++.h>
#define N 100031
#define int long long
using namespace std;

int n, L, R, cnt, root;
int sum[N];
int size[N], ch[N][2], val[N], rd[N];

inline int read() {
	int x = 0, flag = 1;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-') flag = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * flag;
}

void update(int x) {size[x] = size[ch[x][0]] + size[ch[x][1]] + 1;}

int new_node(int v) {
	size[++cnt] = 1;
	val[cnt] = v;
	rd[cnt] = rand();
	return cnt;
}

void split(int now, int k, int &x, int &y) {
	if (!now) x = y = 0;
	else {
		if (val[now] <= k) {
			split(ch[now][1], k, ch[now][1], y);
			update(x = now);
		} else {
			split(ch[now][0], k, x, ch[now][0]);
			update(y = now);
		}
	}
} 

int merge(int x, int y) {
	if (!x || !y) {
		return x | y;
	}
	if (rd[x] > rd[y]) {
		ch[x][1] = merge(ch[x][1], y);
		update(x);
		return x;
	}
	else {
		ch[y][0] = merge(x, ch[y][0]);
		update(y);
		return y;
	}
}

void ins(int v) {
    int x, y;
	split(root, v, x, y);
	root = merge(merge(x, new_node(v)), y);
}

int rk(int v) {
    int x, y, res;
	split(root, v - 1, x, y);
	res = size[x];
	root = merge(x, y);
	return res;
}

signed main() {
    srand(time(0));
	n = read(), L = read(), R = read();
	long long ans = 0;
	for (int i = 1; i <= n; ++i) {
		int x = read();
		sum[i] = sum[i - 1] + x;
	}
	for (int i = 0; i <= n; ++i) {
		ans += (rk(sum[i] - L + 1) - rk(sum[i] - R));
		ins(sum[i]);
	}
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：Erina (赞：0)

其它的全部是cdq和树状数组的......

所以写一个主席树的.

就是在一个树右边有多少在一个范围内的什么鬼......

然后就可以直接用一个主席树写了......

如果不懂直接看代码就行了......

```cpp
#include<iostream>
#define mid ((l+r)>>1)
using namespace std;
namespace fio{
	streambuf*in=cin.rdbuf();
	char bb[1000000],*s=bb,*t=bb;
	#define gc() (s==t&&(t=(s=bb)+in->sgetn(bb,1000000),s==t)?EOF:*s++)
	inline int read(){
		int x=0,w=1;
		char ch=gc();
		while(ch<48)w=(ch=='-')?-1:1,ch=gc();
		while(ch>=48)x=x*10+ch-48,ch=gc();
		return x*w;
	}
}using fio::read;
int n,l,r;long long arr[100005];
int siz[10000005],ls[10000005],rs[10000005],cnt;
int root[100005];
void insert(int &root,int x,long long l,long long r,long long v){
	siz[root=++cnt]=siz[x]+1;
	if(l!=r)
		if(v<=mid)rs[root]=rs[x],insert(ls[root],ls[x],l,mid,v);
		else ls[root]=ls[x],insert(rs[root],rs[x],mid+1,r,v);else;
}
int query(int x,int y,long long l,long long r,long long s,long long t){// 主席树板子
	if(r<s||l>t)return 0;
	if(s<=l&&r<=t)return siz[x]-siz[y];
	return query(ls[x],ls[y],l,mid,s,t)+query(rs[x],rs[y],mid+1,r,s,t);
}
long long ans;
int main(){
	n=read(),l=read(),r=read();
	for(int i=1;i<=n;i++)arr[i]=arr[i-1]+read(),insert(root[i],root[i-1],-10000000000,10000000000,arr[i]);
	for(int i=1;i<=n;i++)ans+=query(root[n],root[i-1],-10000000000,10000000000,l+arr[i-1],r+arr[i-1]);
	cout<<ans;
}
```


---


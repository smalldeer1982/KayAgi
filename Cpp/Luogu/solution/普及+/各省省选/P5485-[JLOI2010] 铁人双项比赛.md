# [JLOI2010] 铁人双项比赛

## 题目描述

铁人双项比赛是吉林教育学院的一项传统体育项目。该项目比赛由长跑和骑自行车组成，参赛选手必须先完成$k$公里的长跑，然后完成r公里的骑车，才能到达终点。每个参赛选手所擅长的项目不同，有的擅长长跑，有的擅长骑车。如果总赛程$s=k+r$一定，那么K越大，对擅长长跑的选手越有利；$k$越小，对擅长骑车的选手越有利。
 
现在给定总赛程$s$，以及每个选手长跑和骑车的平均速度，请你求出对于某个指定的选手最有利的k和r。所谓最有利，是指选择了这个$k$和$r$后，该选手可以获得冠军，且领先第$2$名尽量地多。

## 样例 #1

### 输入

```
100 3
10.0 40.0
20.0 30.0
15.0 35.0```

### 输出

```
14.29 85.71 612```

# 题解

## 作者：81179332_ (赞：8)

并不会半平面交。

考虑二分答案ans,即第一名领先第二名的时间。

首先将速度的单位从$km/h$转换为$km/s$,然后我们可以处理出每跑$1$千米$n$号选手领先$i$号选手的时间为$t1_i$,每骑$1$千米$n$号选手领先$i$号选手的时间为$t2_i$($t1_i$和$t2_i$均可为负,负值表示$n$号选手落后于$i$号选手)。

对于二分的答案$ans$，对于所有的$i(1\le i<n)$要求$n$号选手领先$i$号选手不少于$ans$秒，则可以得出$n-1$个关于$k$的不等式:
$$k\times t1_i + (s - k) \times t2_i \ge ans$$
$$k \times (t1_i - t2_i) \ge ans - s \times t2_i$$
只有$k$是未知数，可以对于$t1_i - t2_i$的正负分情况讨论解出k的范围:

当$t1_i - t2_i < 0$时，$k \le \frac{ans - s \times t2_i}{t1_i - t2_i}$

当$t1_i - t2_i = 0$时，$ans - s \times t2_i \le 0$若不成立，则此$ans$不合法。

当$t1_i - t2_i > 0$时，$k \ge \frac{ans - s \times t2_i}{t1_i - t2_i}$

若k有解，则此$ans$合法，否则此$ans$不合法。

题面并没有说，但是应该是在有多种方案时输出$k$最小的方案，所以最后利用二分出的答案解出$k$的范围，输出的时候用**k的下界**输出。

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
int read()
{
	int x = 0;
	int f = 1;
	char ch = getchar();
	for(;!isdigit(ch);ch = getchar())
		if(ch == '-')
			f = -1;
	for(;isdigit(ch);ch = getchar())
		x = x * 10 + (ch ^ 48);
	return x * f;
}
void print(int x)
{
	if(x < 0)
		putchar('-'),x = -x;
	char ch = x % 10 + '0';
	if(x > 9)
		print(x / 10);
	putchar(ch);
}
const int N = 150;
double t1[N],t2[N],s;
int n;
bool check(double ans)
{
	double maxx = s,minn = 0;
	for(int i = 1;i < n;i++)
	{
		double l = t1[i] - t2[i],r = ans - s * t2[i];
		if(t1[i] == t2[i])
			if(r > 0)
				return false;
		if(t1[i]  > t2[i])
			minn = max(minn,r / l);
		if(t1[i] < t2[i])
			maxx = min(maxx,r / l);
	}
	return maxx > minn;
}
void P(double ans)
{
	double minn = 0;
	for(int i = 1;i < n;i++)
	{
		double l = t1[i] - t2[i],r = ans - s * t2[i];
		if(t1[i]  > t2[i])
			minn = max(minn,r / l);
	}
	printf("%.2lf %.2lf %.0lf\n",minn,s - minn,ans);
}
int main()
{
	freopen("1.in","r",stdin);
	s = read(),n = read();
	for(int i = 1;i <= n;i++)
	{
		scanf("%lf %lf",&t1[i],&t2[i]);
		t1[i] = 3600 / t1[i],t2[i] = 3600 / t2[i];
	}
	for(int i = 1;i < n;i++)
		t1[i] -= t1[n],t2[i] -= t2[n];
	double l = -1,r = 1e50;
	while(r - l >= 0.01)
	{
		double mid = (l + r) / 2;
		if(check(mid))
			l = mid;
		else
			r = mid;
	}
	if(r < 0)
		puts("NO");
	else
		P(r);
}

```


---

## 作者：_HMZ_ (赞：5)

竟然没有模拟退火的？！就由本蒟蒻来水一发。

## 题目大意：

这道题就是有一个比赛，有 $k$ 公里的长跑和 $r$ 公里的骑车。

如果 $k+r=s$，确定一个值使得第 $n$ 名选手最快而且领先第二名最多。

~~这比赛怎么还有黑幕呢？~~


## 解题思路：

标签：计算几何。

我：一脸懵逼。

再看数据范围，$n$ 才 $100$，退火就行了。

退火套路不用说了吧？每次找 $k$ 的值，知道 $k$ 了 $r$ 也很好算了。

然后暴力求每个人比赛的时间，看谁是除了最后一个人最快的。

最后拿这个最快的减去第 $n$ 个人的时间就行了。

这里介绍一个函数，`fmod`（~~百度找来的~~）。

主要作用就是对小数取模，大致用法这样：`fmod(double x,double y)`，表示 $x$ 对 $y$ 取模。

因为 $k$ 可能是个小数，但是又不能超过 $s$，手动取模会 TLE，只能用这个了。

## AC代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int n;
double S, ans, x, dis[10005], ax;
struct node
{
	double x, y;
}s[100005];
double check(double x, double y)//确定k和r之后看会领先多少。
{
	for (int i = 1; i < n; i++)
		dis[i] = x / s[i].x * 3600 + y / s[i].y * 3600;
        //注意，题目里说超了多少秒，得换算一下。
	sort(dis + 1, dis + n);//排个序，看谁是除去最后一个人最快的。
	return dis[1] - (x / s[n].x * 3600 + y / s[n].y * 3600);
}
void HMZ()//此函数是模拟退火。
{
	//我习惯用人名写函数名，hmz是谁不用多说了吧（
	double t = 500;
	while (t > 1e-15)
	{
		if (clock() >= 980000)//一直跑退火直到快TLE了停止。
		{
        //这里的ans就是最多超过多少秒，如果是负数代表无论如何也拿不了第一名。
			if (ans < 0)
				cout << "NO" << endl;
			else
				printf("%.2lf %.2lf %.0lf", ax, S - ax, ans);
			exit(0);
		}
		double nx = fmod(fabs(x + (rand() * 2 - RAND_MAX) * t), S);
		double tmp = check(nx, S - nx), delta = ans - tmp;
		if (delta < 0)//退火过程
			x = nx, ans = tmp, ax = nx;//ax表示在最优解情况下的k。
		else if (exp(-delta / t) * RAND_MAX > rand())
			x = nx;
		t *= 0.9991;
	}
}
int main()
{
	srand(114514);//奇怪的时间种子。
	cin >> S >> n;
	for (int i = 1; i <= n; i++)
		cin >> s[i].x >> s[i].y;
	ans = check(0, S);
	while (1)	HMZ();
	return 0;
}
```


---

## 作者：mlvx (赞：2)

~~还是随机跳题摇到的。~~

本题的领先数值只有一个最值，考虑三分 $k$ 的值。

$\operatorname{check}$ 函数的内容即为计算 $n$ 号选手能领先除他外最快的选手多少小时。

记得最后输出的是秒，要转化单位。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;double s,v1[101],v2[101];
double check(double k){
	double minn=1e9;
	for(int i=1;i<n;i++)minn=min(minn,k/v1[i]+(s-k)/v2[i]);
	return minn-(k/v1[n]+(s-k)/v2[n]);
}int main(){
	cin>>s>>n;
	for(int i=1;i<=n;i++)cin>>v1[i]>>v2[i];
	double l=0,r=s;//上界与下界
	while(r-l>1e-6){//三分
		double mid1=l+(r-l)/3,mid2=r-(r-l)/3;
		if(check(mid1)<check(mid2))l=mid1;
		else r=mid2;
	}if(check(l)<0)puts("NO");//永远无法领先其他人
	else printf("%.2lf %.2lf %.0lf",l,s-l,check(l)*3600);
	return 0;
}
```

---

## 作者：MerlinLee (赞：1)

在 s 确定后，选手完成比赛的时间是关于 $k$ 的一次函数，图像为直线。

问题为求 $k$ 使 $f(k)$ 等于选手 1 到选手 $n-1$ 的最高成绩减去选手 n 成绩，然后取得最大值。

所以 $f(k)$ 的图像为上凸的折线，最大值在折点或两端取得。

枚举每个可能为折点的直线交点求 $f(k)$ 的最大值。

若数据范围更大可以求半平面交直接处理出折点。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double s;
double v1,v2;
double a[105],b[105];
double km=0;
double ans=-1.0e50;
void calc(double x)
{
	if(x<0 or x>s)
	  return;
	double y=1.0e50;
	double c;
	for(int i=1;i<n;i++)
	{
		c=a[i]*x+b[i];
		if(c<y)
		  y=c;
	}
	y-=a[n]*x+b[n];
	if(y>ans)
	  ans=y,km=x;
}
int main()
{
	scanf("%lf%d",&s,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf",&v1,&v2);
		a[i]=1.0/v1-1.0/v2;
		b[i]=s/v2;
	}
	for(int i=1;i<n;i++)
	{
		for(int j=i+1;j<n;j++)
		{
			calc((b[j]-b[i])/(a[i]-a[j]));
		}
	}
	calc(0);
	calc(s);
	if(ans>=0)
	  printf("%.2lf %.2lf %.0lf",km,s-km,ans*3600.0);
	else
	  cout<<"NO";
	return 0;
}
```

---

## 作者：yshpdyt (赞：1)

## 题意
比赛由 $k$ **千米**长跑部分和 $r$ **千米**骑车部分组成，总长度 $s=k+r$ **千米**，有 $n$ 名选手，第 $i$ 名选手的长跑速度为 $v_{i_1}$ **千米每时**，骑车速度为 $v_{i_2}$ **千米每时**。选择一个合适的 $k$ 和 $r$，让第 $n$ 名选手位于第一，并且让他与第二名用时相差尽可能的大，输出合适的 $k$ 和 $r$ 以及先第二名完成比赛的**秒数**，或报告无解。

## Sol
小清新计算几何。

我们不妨设长跑部分长度为 $k$ 千米时，第 $i$ 名选手完成比赛用时 $t_i$ 时，注意除非特别说明，这里单位都是千米，时，以及千米每时。

考虑对于每一名选手的普遍性，不难得到关系（简单运动学公式）：

$$t=\frac{k}{v_1}+\frac{r}{v_2}$$

由 $s=k+r$ ：

$$t=\frac{k}{v_1}+\frac{s-k}{v_2}$$

通分：

$$t=\frac{v_2\times k+v_1\times (s-k)}{v_1\times v_2}=\frac{(v_2-v_1)\times k+v_1\times s}{v_1\times v_2}$$

也就是：
$$t=\frac{(v_2-v_1)}{v_1\times v_2}\times k +\frac{s}{v_2}$$

注意到  $v_2,v_1,s$ 均为定值，发现 $t$ 是关于 $k$ 的**一次函数**，定义这种函数为：
$$t_i=f_i(k)=\frac{(v_{i_2}-v_{i_1})}{v_{i_1}\times v_{i_2}}\times k +\frac{s}{v_{i_2}}$$

然后我们处理出所有一次方程的交点，交点前后最终名次发生了变化。

然后按交点横坐标进行排序，对于相邻的两个交点之间，排名不会发现变化，我们枚举所有相邻交点，设相邻两交点横坐标为$t_1$，$t_2$，取两交点横坐标中间值 $mid=\frac{t_1+t_2}{2}$，带入所有一次函数比大小，只取用时最短的两名选手，用时最短的只能为 $n$，不是 $n$ 跳过即可，设用时次短的为 $m$。

只需要比较已有答案，$f_m(t_1)-f_n(t_1)$，$f_m(t_2)-f_n(t_2)$ 取最大即可。

为什么只需要比较端点？

对于两条不平行一次函数 :
$f(x)=k_1 x+b_1 $ 与 $g(x)=k_2 x+b_2$，有 
$h(x)=f(x)-g(x)=(k_1-k_2)x+(b_1-b_2)$，$h(x)$ 一定是 $\mathbb{R}$ 上的增函数或减函数，区间最值一定在端点处取得。

实在理解不了画几个图就会了。

最后输出即可，注意题目中的时间单位是**秒**，我们算出来单位是**时**，要乘 $3600$ 。

然后是一些细节问题，本题有些卡精度。


1. 对于无解情况，初始化答案为 `-inf` ，最后特判就好。
2. $k$ 有最大值为 $s$，最小值为 $0$，算交点记得注意范围。
3. 交点数组要把最大值和最小值也给塞进去。
4. `eps` 取小点。

时间复杂度 $O(n^3)$，轻松跳过本题。

## Code
闲话：一开始读错题了以为要求所有选手的答案，实际上只需要特别关注最后一名选手就可以了。
```cpp
#include<bits/stdc++.h>
#define ll double
#define N 200005
#define endl "\n" 
#define fi first
#define se second
using namespace std;
const ll mod=1e9+7;
const ll inf=1e9;
const double eps=1e-16;
ll s;
int n;
struct line{
    ll k,b;
}f[N];
struct res{
    ll k,t;
}g[N];
vector<ll>v;
ll c(int i,ll x){
    return f[i].k*x+f[i].b;
}
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin>>s>>n;
    double mxx=s+eps;
    for(int i=1;i<=n;i++){
        g[i]={inf,-inf};
        ll v1,v2;
        cin>>v1>>v2;
        f[i].k=(v2-v1)/(v1*v2);
        f[i].b=(s)/(v2);
    }
    v.push_back(eps);
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            if(fabs(f[i].k-f[j].k)<eps)continue;
            ll x=(f[i].b-f[j].b)/(f[j].k-f[i].k);
            if(mxx-x>eps&&x>0)v.push_back(x);
        }
    }
    f[0]={0,inf};
    v.push_back(mxx);
    sort(v.begin(),v.end());
    for(int i=0;i<v.size()-1;i++){
        ll t1=v[i],t2=v[i+1];
        ll mid=(t1+t2)/2;
        int k=0,k2=0;
        for(int j=n;j>=1;j--){
            if(k==0||eps<c(k,mid)-c(j,mid)){
                k2=k;
                k=j;
                continue;
            }
            if(k2==0||eps<c(k2,mid)-c(j,mid))k2=j;
        }
        
        if(eps<c(k2,t1)-c(k,t1)-g[k].t||g[k].t==-inf)g[k]={t1,c(k2,t1)-c(k,t1)};
        if(eps<c(k2,t2)-c(k,t2)-g[k].t||g[k].t==-inf)g[k]={t2,c(k2,t2)-c(k,t2)};
    }
    for(int i=n;i<=n;i++){
        if(g[i].t==-inf)cout<<"NO\n";
        else printf("%.2lf %.2lf %.0lf\n",g[i].k,s-g[i].k,g[i].t*3600);
    }
    return 0;
}
```



---

## 作者：_edge_ (赞：0)

提一句，当两个人并列的时候有可能有多个答案但是它没有 spj，数据里应该也没有这种情况。

以及这题数据比较水，也比较抽象。

不妨考虑确定 $x$ 为第一段路程，对于第 $i$ 个选手而言则为 $\dfrac{x}{a_i}+\dfrac{s-x}{b_i}$，简单整理过后得到 $x\times (\dfrac 1 {a_i} - \dfrac 1 {b_i}) + \dfrac{s}{b_i}$，容易发现它是个一次函数，我们需要求的是去掉第 $n$ 个选手的最小值并，所以我们直接求出其上凸壳，然后暴力枚举凸壳上的每条边算贡献就可以，贡献也是一次函数所以取两个端点即可。

```cpp
#include <bits/stdc++.h>
#define int long long 
#define double long double
using namespace std;
const int INF=1e6+5;
int s,n,q[INF],tot,r;
double a[INF],b[INF],L[INF],Max[INF];
struct P3{
	double k,b;
}aa[INF];
double calc(int x,int y) {
	/*
	aa[x].k*x+aa[x].b=aa[y].k*x+aa[y].b
	(aa[x].k-aa[y].k)*x=(aa[y].b-aa[x].b)
	*/
	return (double)(aa[y].b-aa[x].b)/(aa[x].k-aa[y].k);	
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>s>>n;
	for (int i=1;i<=n;i++) {
		cin>>a[i]>>b[i];
		if (fabs(a[i])<=1e-8 || fabs(b[i])<=1e-8) {
			if (i==n) {
				cout<<"NO\n";
				return 0;
			}
			continue;
		}
		++tot;
		aa[tot].k=1./a[i]-1./b[i];
		aa[tot].b=1.*s/b[i];
	}
	sort(aa+1,aa+tot,[](P3 x,P3 y){return x.k!=y.k?x.k>y.k:x.b>y.b;});
	Max[tot-1]=aa[tot-1].b;
	for (int i=tot-2;i>=1;i--) Max[i]=min(Max[i+1],aa[i].b);
	
	for (int i=1;i<tot;i++) {
		if (i+1<tot && aa[i].b>=Max[i+1]) continue;
		while (r>1 && calc(q[r-1],q[r])>=calc(q[r],i)) r--;
		q[++r]=i;
	}
//	for (int i=1;i<=r;i++)
//		cerr<<aa[q[i]].b<<" ";
//	cerr<<" endl\n";
	for (int i=2;i<=r;i++) 
		L[i]=calc(q[i-1],q[i]);
	L[1]=0;L[r+1]=s;
	double f1=0;double Max=1;
	for (int i=1;i<=r;i++) {
		// (aa[tot].k-aa[i].k)*x+aa[tot].b-aa[i].b
		if (aa[tot].k>aa[q[i]].k && aa[tot].b>aa[q[i]].b) continue;
		double x=0;
		if (aa[tot].k-aa[q[i]].k<0) x=L[i+1];
		else x=L[i];
		x=max((double)0.0,x);x=min((double)1.0*s,x);
		if (x>=L[i] && x<=L[i+1]) {
			if (Max>x*(aa[tot].k-aa[q[i]].k)+aa[tot].b-aa[q[i]].b) 
				Max=x*(aa[tot].k-aa[q[i]].k)+aa[tot].b-aa[q[i]].b,f1=x;
		}
	}
//	cerr<<Max<<" awioejr\n";
	if (Max>1e-8) cout<<"NO\n";
	else {
		cout<<fixed<<setprecision(2)<<f1<<" "<<s-f1<<" ";
		cout<<fixed<<setprecision(0)<<fabs(-(Max*3600))<<"\n";
	}
	return 0;
}
```

---


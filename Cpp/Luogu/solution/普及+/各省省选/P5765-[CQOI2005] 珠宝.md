# [CQOI2005] 珠宝

## 题目描述

有一棵 $n$ 个结点的树，给每个点安排一个正整数编号，使得相邻点具有不同的编号，编号的总和尽量小。

## 说明/提示

对于 $20\%$ 的数据，$n\le 10$；

对于 $40\%$ 的数据，$n\le 1000$；

对于 $100\%$ 的数据，$1\le n\le 50000$。

## 样例 #1

### 输入

```
8  
1 2 
1 3
1 4
1 5
5 6
5 7
5 8```

### 输出

```
11```

# 题解

## 作者：CNCAGN (赞：10)

感觉 P5765 和 P4395 都没有对于最大点权太认真的证明，故写了此题解。第一次自己证明这种结论如有纰漏或错误欢迎指出。

## 题目描述
题目给出一个树的边，要求自选正整数点权值（即填色），使得点权和最小，同时要求相邻的两个点的点权不等。
## Solution
树形动规的绿题一般比较相似，这个题就和上司的舞会很像。

动规方程也很好推，令 $f_{u,i}$ 代表 $u$ 为根的树，点权为 $i$ 的情况下权值和的最小值。

则 $f_{u,i}=i+\sum\min(f_{v,j}) \ (j{\neq}i,v{\in}son_u)$。

考虑用 $1$ 和 $2$ 来填色，思路很快就假，如下图所示，$1,2,3$ 填色明显比 $1,2$ 填色更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/y8ctt1ik.png)

讨论区也有说最大用 $1,2,3,4$ 即可满足最小填色，也可通过上图规模的扩大进行否定。

考虑正解，**对于本题任意一颗树的填色方案，总有一个最大的点权**。那么 dp 的前置问题转化为：**一个 $n$ 个点的树按本题规则填色，最大点权为何**。

我比较菜直接想不出来，但是可以把这个问题转化：**已经填好树上点权且最优，若这个点的点权为 $x_i$，那么求这个点的子树最小有多少个点（设为 $num_i$）**。据此，若有一点权为 $x$ 的点，使得 $num_i{\ge}n$，则这颗 $n$ 点的子树一定可以用 $1,2,3,\cdots,x_{i-1},x_i$ 来获得总权值最小的填色。

若最优答案树上一个点的点权为 $x$，那么显然这个点一定连接点权为 $1$ 到 $x-1$ 的所有的点，那么简单的打个表找规律（下图带颜色的数字代表点的个数）：

![](https://cdn.luogu.com.cn/upload/image_hosting/gyvlsyp0.png)

发现最大点权 $x_i$ 的最优最小子树的 $num_i$ 为 $2^{x_i-1}$。所以题目 $n$ 个点的树最大用 $\log_2n+1$ 即可最优填色，对于此题为 $16$ 左右，完全可过。至此，这个题最关键的步骤结束了。代码可能是最简单的部分了。简单 dfs 和 dp 即可。
## code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<string>
#include<vector>
#include<queue>
#include<stack>
#include<deque>
#include<map>
using namespace std;
inline int red() {
    int op = 1, x = 0;
    char ch = getchar();
    while(!isdigit(ch)) {
        if(ch == '-')   op = -1; 
        ch = getchar();
    }
    while(isdigit(ch)) {
        x = (x << 3) + (x << 1) + ch - '0';
        ch = getchar();
    }
    return op * x;
}
const int maxn = 1e5 + 10, maxm = 1e5 + 10, maxx = 16;
const int inf = 0x3f3f3f3f;
int n, x;
int root;
int deg[maxn];
int f[maxn][maxx];
int head[maxn], to[maxm], nxt[maxm];
int num;
void add(int a, int b) {
	to[++num] = b;
	nxt[num] = head[a];
	head[a] = num;
}
void dfs(int u, int fa) {
	for(int i = 1; i <= x; ++i) {
		f[u][i] = i;
	}
	for(int i = head[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == fa)	continue;
		dfs(v, u);
		for(int j = 1; j <= x; ++j) {
			int minn = inf;
			for(int k = 1; k <= x; ++k) {
				if(k == j)	continue;
				minn = min(minn, f[v][k]);
			}
			f[u][j] += minn;
		}
	}
}
int main() {
	n = red();
	x = log(n) / log(2);
	++x;
	for(int i = 1; i < n; ++i) {
		int a = red(), b = red();
		add(a, b);
		add(b, a);
		++deg[a], ++deg[b];
	}
	root = 1;
	dfs(root, -1);
	int ans = inf;
	for(int i = 1; i <= x; ++i) {
		ans = min(ans, f[1][i]);
	}
	printf("%d\n", ans);
    return 0;
}

```


---

## 作者：One_JuRuo (赞：2)

## 思路

应该很容易想到使用树形 dp。

令 $f_{u,i}$ 代表，只考虑 $u$ 为根的子树，$u$ 的编号为 $i$ 的情况下，最小的编号总和。

那么我们可以用 $u$ 的儿子 $v$ 来更新 $f_{u,i}$。

转移方程 $f_{u,i}=\sum_{v\in son_u}\min f_{v,k}[i\neq k]+i$。

那么可能染色的种数有多少种呢？

我们可以观察一下样例，发现，如果使用最小的 $1$ 和 $2$ 作为编号的话，至少也是 $12$，而正确答案呢，则是把一个有 $3$ 个儿子的节点的编号定为 $3$，让儿子的编号从 $2$ 变成 $1$。

不妨假设某个节点，可以填入的最小编号是 $1$，那么如果他有 $2$ 个儿子时，就应该填 $2$，让儿子更小，以获得更小的答案。

那么再继续假设，它的儿子里也有类似的情况，导致它的儿子必须填 $2$ 才能让答案更小，所以这个节点必须填 $3$。

那么，假设这个节点最后要填 $x$，就必然存在要填 $x-1$，$x-2$，$x-3$ 等等的节点，可以发现如果 $x$ 比较大，整个树的总结点数就非常大，如下图 $x=4$ 的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/eqf7upao.png)

P.S.蒟蒻不清楚是不是节点最少的情况，如有错误欢迎指出。

首先观察编号为 $3$ 的节点，他不止需要一个编号必须为 $2$ 的儿子，还需要另外的 $3$ 个儿子，不然的话，可以让编号为 $3$ 的节点变为编号 $1$，然后让儿子为 $2$ 来获得更小答案，并且让它的父节点编号也可能变小。

所以编号为 $4$ 的节点需要两个编号为 $2$ 的节点和 $5$ 个编号为 $1$ 的节点。

可以发现总结点数增长很快，差不多是 $2^n$ 的样子，所以编号最大不超过 $\log n$。

差不多是 $5$ 的样子，但是做的时候没细想，直接开了 $20$ 绝对不会错。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
int n,e[100005],ne[100005],h[50005],idx=1,a,b,col[50005],dp[50005][20],ans=inf;
inline void add(int a,int b){e[idx]=b,ne[idx]=h[a],h[a]=idx++;}
void dfs(int u,int fa)
{
	for(int i=h[u];i;i=ne[i])
		if(e[i]!=fa)
		{
			dfs(e[i],u);
			for(int j=1;j<20;++j)
			{
				int res=inf;
				for(int k=1;k<20;++k) if(j!=k) res=min(res,dp[e[i]][k]);
				dp[u][j]+=res;
			}
		}
	for(int i=1;i<20;++i) dp[u][i]+=i;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;++i) scanf("%d%d",&a,&b),add(a,b),add(b,a);
	dfs(1,0);
	for(int i=1;i<20;++i) ans=min(ans,dp[1][i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：stntn (赞：2)

## 简要题意

给你一颗有 $N$ 个节点的树，让你为每个节点赋值，相邻节点权值不能相同，求最少权值总和。

## 分析

首先想到要想给一个树的各个节点染上与其相邻节点不同的颜色所需颜色数量最多为 $\log n$ 种，因此我们可以设出状态 $f_{u,i}$ 表示节点 $u$ 染上颜色 $i$ 时及其子树的权值总和。

考虑状态转移，当当前节点的颜色为 $i$ 时，其儿子 $v$ 只要颜色不与其相同即可，要想最小化总权值，故儿子对其的贡献为 $\min_{j=1}^{\log n} f_{v,j}[i \ne j]$，再加上本身权值 $i$，转移方程为：

$$
f_{u,i}= i+ \sum_{v \in son_u} \min_{j=1}^{\log n} f_{v,j}[i \ne j]
$$

复杂度 $O(n \log^2 n)$。

## CODE

```cpp
int n,head[N],cc,f[N][17];
struct EDGE{int v,nxt;}e[N<<1];
inline void add_edge(int u,int v)
{
	e[++cc]={v,	head[u]};head[u]=cc;
	e[++cc]={u,head[v]};head[v]=cc;
}
inline void dfs(int u,int fa)
{
	tep(i,u)
	{
		int v=e[i].v;if(v==fa) continue;dfs(v,u);
		rep(j,1,16)
		{
			int minn=INF;
			rep(k,1,16) if(j^k) minn=min(minn,f[v][k]);
			f[u][j]+=minn;
		}
	}
	rep(i,1,16) f[u][i]+=i;
}
signed main()
{
	memset(head,-1,sizeof(head));
	read(n);
	rep(i,1,n-1)
	{
		int u,v;read(u,v);
		add_edge(u,v);
	}
	dfs(1,0);
	int ans=INF;
	rep(i,1,16) ans=min(ans,f[1][i]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：KSToki (赞：2)

正解：树形 DP。

先令 $1$ 为根节点（当然你开心用啥就用啥），用 $f[i][j]$ 表示节点 $i$ 编号为 $j$ 的情况下以 $i$ 为根节点的子树的最小编号和。确定的是，子树之间是互不影响的，所以对于当前节点确定 $j$ 的情况下，使每个子树最小即可，即转移方程式为 $f[i][j]=j+\sum(min(f[to[i]][k](k\not=j)))$，答案为 $min(f[1][i])$。

这里有个~~玄学~~的问题，关于第二维的范围。开始我以为 $3$ 就可以了，但交上去发现 WA 了。经过~~查看题解~~尝试，设为 $10$ 即可，复杂度 $O(10^2\times n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,head[50001],to[100001],nxt[100001],tot,f[50001][11],ans=0x7fffffff;
inline void add(int x,int y)
{
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
void dfs(int x,int fa)
{
	for(register int i=1;i<11;++i)
		f[x][i]=i;
	for(register int i=head[x];i;i=nxt[i])
		if(to[i]!=fa)
		{
			dfs(to[i],x);
			for(register int j=1;j<11;++j)
			{
				int minn=0x7fffffff;
				for(register int k=1;k<11;++k)
					if(k!=j)
						minn=min(minn,f[to[i]][k]);
				f[x][j]+=minn;
			}
		}
}
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<n;++i)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	for(register int i=1;i<11;++i)
		ans=min(ans,f[1][i]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：feecle6418 (赞：2)

显然是树形DP。

设 $f_{i,j}$ 表示在 $i$ 的子树中，第 $i$ 个节点编号为 $j$ 的最小花费，则 $f_{i,j}=j+\sum \min{f_{l,k}}(k\ne j,p_l=i)$，$p_l$ 表示 $l$ 的父亲。

编号不会很大，数据也很弱，因此数组开到 $10$ 就够了。

代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cstdlib>
using namespace std;
int dis[100005],n,h[100005],cnt,f[100005][12];
struct Edge{
	int to,next;
}e[200005];
void Add_Edge(int x,int y){
	e[++cnt].to=y;
	e[cnt].next=h[x];
	h[x]=cnt;
}
void DFS(int now,int fa){
	for(int i=1;i<=10;i++)f[now][i]=i;
	for(int i=h[now];i;i=e[i].next){
		int y=e[i].to;
		if(y==fa)continue;
		DFS(y,now);
		for(int j=1;j<=10;j++){
			int minn=1000000;
			for(int k=1;k<=10;k++)if(j!=k)minn=min(minn,f[y][k]);
			f[now][j]+=minn;
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1,x,y;i<n;i++)scanf("%d%d",&x,&y),Add_Edge(x,y),Add_Edge(y,x);
	DFS(1,0);
	int ans=1000000;
	for(int i=1;i<=10;i++)ans=min(ans,f[1][i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：luckyyunji (赞：1)

有一棵树，每个点有一个正整数编号，相邻点编号不同，求最小总和。~~（已改，望通过）~~

思考树形 DP，设 $dp_{i,j}$ 是以 $i$ 为根，颜色为 $j$ 的情况下的最优解。

容易得到当前节点的答案是各孩子节点（和当前节点颜色不同）的答案之和。即：

$$
dp_{u,i} = \sum_{v \in son_{u}} \min_{j \ne i} dp_{v,j}
$$

考虑编号的最大范围。

如果编号只有 $1$ 和 $2$，通过画图发现是错的。~~(不可能这么简单)~~

经过了尝试，编号最大应为 $16$。~~（貌似数据弱？）~~

代码如下，详见注释。

```cpp
// luckyyunji luogu.com.cn c++11 2025-6-30

#include <iostream>
#include <vector>

using namespace std;

const int MAXN = 50008;
const int MAXK = 16;
const int INF = 0x3f3f3f3f;

int n;
vector<vector<int> > T;
int dp[MAXN][MAXK + 8];	 // f[u][i] 以 u 为根，颜色为 i

void dfs(int u, int fa) {
	for (int i = 1; i <= MAXK; i++) {
		dp[u][i] = i;  // 算上根节点的颜色
	}
	for (auto v : T[u]) {
		if (v == fa) {
			continue;  // 无向边的处理
		}
		dfs(v, u);
		for (int j = 1; j <= MAXK; j++) {  // u 的颜色是 j
			int anss = INF;
			for (int k = 1; k <= MAXK; k++) {  // v 的颜色是 k
				if (j == k) {				   // 不能同色
					continue;
				}
				anss = min(anss, dp[v][k]);
			}
			dp[u][j] += anss;  // 更新
		}
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int u, v;

	cin >> n;
	T.resize(n + 1);

	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		T[u].push_back(v);
		T[v].push_back(u);
	}

	dfs(1, 0);	// 无根树设 1 为根

	int ans = INF;
	for (int i = 1; i <= MAXK; i++) {
		ans = min(ans, dp[1][i]);
	}
	cout << ans;

	return 0;
}
```

---

## 作者：Thomas0218 (赞：1)

## 分析
题意：给定一棵树，给每个结点安排一个点权（正整数），使得相邻点点权不同，求最小化的点权。

首先肯定考虑树形 dp。设 $f_{u,i}$ 表示以 $u$ 为根的树，$u$ 的编号为 $i$ 时的最小点权和。

那么 $f_{u,i}=\sum\limits_{v\in son(u)} \min\limits_{j\neq i} f_{v,j}$ 。这么直接转移是 $O(n^3)$ 的，肯定不行。

我们发现主要问题在于编号数量太多，有没有办法约束编号数量？

我们试图找出编号和结点个数之间的一些关系。考虑 $F_i$ 表示一棵根节点编号为 $i$ 的树所含的结点数。因此，为了使根节点为 $i$，至少需要让子树内占满了 $1\dots i-1$ 的所有编号，因为如果没有占满那么编号大的结点都可以集体编号往前挪一个。

那么 $F_i\geq \sum\limits_{j=1}^{i-1}F_j +1$ 。因此 $F_i\geq 2^{i-1}$。由于 $F_i$ 增长速度极快，我们的编号就会非常的少，为 $O(\log n)$ 级别。

所以我们就可以每次只枚举 $1$ 到 $\log n$ 的编号并用它们转移。复杂度 $O(n\log^2 n)$。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e4 + 5, M = 20, inf = 1e9;
vector <int> e[N]; int f[N][M+5], n;
void dp(int u, int fa) {
	for(auto v : e[u]) {
		if(v == fa) continue ; dp(v, u);
		for(int i = 1; i <= M; i++) {
			int mn = inf;
			for(int j = 1; j <= M; j++)
				if(j != i) mn = min(mn, f[v][j]);
			f[u][i] += mn;
		}
	}
	for(int i = 1; i <= M; i++) f[u][i] += i;
}
int main() {
	scanf("%d", &n);
	for(int i = 1; i < n; i++) {
		int u, v; scanf("%d%d", &u, &v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dp(1, 0);
	int mn = inf;
	for(int i = 1; i <= M; i++) mn = min(mn, f[1][i]);
	printf("%d\n", mn);
	return 0;
}
```

---

## 作者：orz_z (赞：1)

[本题传送门](https://www.luogu.com.cn/problem/P5765)


## 题目大意
给出一棵树，要求你为树上的结点标上权值，权值可以是任意的正整数。

唯一的限制条件是相临的两个结点不能标上相同的权值，要求一种方案，使得整棵树的总价值最小。

## 解题思路

本题相当于一个染色问题。

本蒟蒻开始以为是 $12$ 染色。~~（危~~ 

其实可以有一组 `Hack` 数据。

[数据1](https://www.luogu.com.cn/paste/zvwnusp3)

将数据构造成一棵树：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706100913642.png#pic_center)

如果是 $12$ 染色，则总价值最小的染色情况为：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706100800592.png#pic_center)

如图可知，总价值为 $2+1+1+1+1+2+2+2=12$，与输出不符，故不能用 $12$ 染色。

再根据图进行分析，可以发现，对总价值贡献最多的是节点 $5$ 的 $3$ 个子节点，贡献为 $2 \times 3=6$。

那能不能修改通过修改图的一个节点，使得这 $3$ 个节点的贡献减少呢？

答案是，可以。

怎么做？

将节点 $5$ 的权值修改为 $3$ 就行了，若如此做，其 $3$ 个子节点的权值都可修改为 $1$，故权值之和为 $1 \times 3=3$。

则正确的染色方法为：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210706100714776.png#pic_center)

再来一组数据。 ~~（还有完没完~~ 

[数据2](https://www.luogu.com.cn/paste/2vo5hj98)


根据两种情况：

 1. 一个节点的权值只受到他的父节点和子节点的影响。
 2. 这是一棵树，一定存在 dfs 序。

可以想到这道题正解其实是 `树形dp`。

定义 $f_{i,j}$ 为 节点 $i$ 的权值为 $j$ 时以 $i$ 为根节点的子树的点权总和的最小值。

现在要找一个最大可以填的数，为 $\log(n)$。

我们可以出于最坏的情况来进行考虑，当周围的点呈现出 $1、2、4、8、……$ 这样的倍增的情况的时候，我们可以发现，中间的点按照升序排列，而周围的点变成都是 $1$ 的会更好一些，所以，最大可以填的数为 $\log(n)$。

为了不 `WA` ，$f$ 数组的第二维应取到 $20$。

所以转移方程为： 
$$f_{i,j} = j+ \sum_{x\in sons_i}\sum_{y=1}^{\log(n)} \min(y\neq i:f_{x,y})$$

## AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 2e5 + 5;

int n, f[_][5], ans = INT_MAX;
int tot, head[_], to[_], nxt[_];

void add(int a, int b)
{
    nxt[++tot] = head[a];
    head[a] = tot;
    to[tot] = b;
}

void dfs(int x, int fa)
{
    for (int i = 1; i <= 4; i++)
        f[x][i] = i;
    for (int i = head[x]; i; i = nxt[i])
    {
        int v = to[i];
        if (v == fa)
            continue;
        dfs(v, x);
        for (int j = 1; j <= 4; j++)
        {
            int minn = INT_MAX;
            for (int k = 1; k <= 4; k++)
                if (j != k)
                    minn = min(minn, f[v][k]);
            f[x][j] += minn;
        }
    }
}

signed main()
{
    scanf("%d", &n);
    for (int i = 1, a, b; i < n; ++i)
    {
        scanf("%d%d", &a, &b);
        add(a, b);
        add(b, a);
    }
    dfs(1, 0);
    for (int i = 1; i <= 4; i++)
        ans = min(ans, f[1][i]);
    printf("%d", ans);
    return 0;
}
```

---

## 作者：Super_Cube (赞：1)

# Solution

设 $dp_{i,j}$ 表示节点 $i$ 点权为 $j$ 时点 $i$ 及其子树点权和的最小值。转移为：$dp_{i,j}=j+\displaystyle\sum_{x\in\operatorname{son}_i}\min_{k\ne j}{dp}_{x,k}$。问题是 $j$ 的上界为多少？在 [P7393](/problem/P7393) 中给出了较优的构造方式，有兴趣的可以去看看。这里直接给出结论：当 $n=50000$ 时最大点权为 $10$ 即可满足点权和最小。

# Code
```cpp
#include<bits/stdc++.h>
std::vector<int>v[50001];
int dp[50001][11];
void dfs(int p,int dad){
	for(int i=1;i<=10;++i)dp[p][i]=i;
	for(int i:v[p]){
		if(i==dad)continue;
		dfs(i,p);
		for(int j=1,val;j<=10;++j){
			val=0x3f3f3f3f;
			for(int k=1;k<=10;++k)
				if(k!=j)val=std::min(val,dp[i][k]);
			dp[p][j]+=val;
		}
	}
}
int n;
int main(){
	scanf("%d",&n);
	for(int i=1,x,y;i<n;++i)
		scanf("%d%d",&x,&y),
		v[x].push_back(y),v[y].push_back(x);
	dfs(1,0);
	printf("%d",*std::min_element(dp[1]+1,dp[1]+11));
	return 0;
}
```

---

## 作者：xkcdjerry (赞：1)

因为 ~~我菜~~ 便于理解这里先说一下我怎么想到用树 DP :  
* 最优子结构：如果从下向上填的话，对于一个节点来说除了它的直接儿子之外，子树中的其它内容对其无用
* 次序：由于问题在树上，所以天然存在 dfs 序  

那么树 DP 理论可行，由于父节点仍然需要记录子节点的数值以免重复，所以转移表应该长这个样子： `f[x][y]=节点x填y时子树的最小和`  

转移方程就是这个：
$$f_{x,y}=\sum_{i \in sons[x]} \min(j \neq x:f_{i,j})$$

（其它题解给的第二维的都是 1~10 ，但是因为数据太水可以压缩到 1~4 ）  

代码（记住，树 DP 必须要用 dfs ）：
```cpp
#include <cstdio>
#include <vector>
using std::vector;
//代码里没有对索引 -1 所以虽然只有 1~4 也要开五个位置
#define MX 5 
#define N 50010
int f[N][MX];
bool vis[N];
vector<int> e[N];
int n;
void dfs(int o)
{
	//处理出 o 节点所有填的值的最小值
	vis[o]=true;
	for(int i=1;i<MX;i++) f[o][i]=i;
	for(vector<int>::iterator i=e[o].begin();i!=e[o].end();i++)
	{
		if(!vis[*i])
		{
			dfs(*i);
			for(int j=1;j<MX;j++)
			{
				int mn=0x3f3f3f3f;
				for(int k=1;k<MX;k++)
					if(k!=j&&f[*i][k]<mn)
						mn=f[*i][k];
				f[o][j]+=mn;
			}
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1);
	int mn=0x3f3f3f3f;
	for(int i=1;i<MX;i++) if(f[1][i]<mn) mn=f[1][i];
	printf("%d",mn);
	return 0;
}
```

[开了 O2 之后排到最优解前三名](https://www.luogu.com.cn/record/50536743) （在文章提交时）

---

## 作者：Cuiyi_SAI (赞：0)

[双倍经验](https://www.luogu.com.cn/problem/P4395)。

## $\large{\text{Solution}}$

根据 [P7393](https://www.luogu.com.cn/problem/P7393) 的 [结论](https://www.luogu.com.cn/blog/488775/solution-p7393)，我们可以构造出 符合题意且最大点权为 $k$ 的 **节点最少**的树。

发现当 $k=11$ 的时候节点数最小的树的规模就远大于 $5\cdot 10^4$ 了。因此这题只会出现点权为 $[1,10]$ 的树（但是数据过水貌似只有到 $4$ 的情况，显然可以构造出一组数据叉掉），于是可以直接写出 DP。

设 $f_{u,i}$ 表示节点 $u$ 取值为 $i$ 的最小权值和，那么转移为
$$
f_{u,i}=i+\min\limits_{v\in \operatorname{son}_u~,~j\ne i}\left(~f_{v,j}~\right)
$$

## $\large{\text{Code}}$


```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
vector<int> g[10010];
int f[10010][10];
void dp(int u,int fa){
    for(int i=1;i<=9;i++) f[u][i]=i;
    for(auto v:g[u]){
        if(v==fa) continue;
        dp(v,u);
        for(int i=1;i<=9;i++){
            int minn=1e9;
            for(int j=1;j<=9;j++){
                if(i==j) continue;
                minn=min(minn,f[v][j]);
            }
            f[u][i]+=minn;
        }
    }
    return ;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<n;i++){
        int aa,bb;
        cin>>aa>>bb;
        g[aa].push_back(bb);
        g[bb].push_back(aa);
    }
    dp(1,0);
    int ans=1e9;
    for(int i=1;i<=9;i++) ans=min(ans,f[1][i]);
    cout<<ans;
    return 0;
}
```

似乎很多人都觉得最大点权的上界是 $\log_2n+1$（甚至还有人证明了？），但其实做过 P7393 就会知道这个上界并非以那么简单的函数增长（貌似有人 oeis 都找不到那个序列），所以我们只能将其近似看做 $\log_n$。

---

## 作者：一只书虫仔 (赞：0)

#### Description

> 给定一棵 $n$ 个点的树，求给每一个点 $i$ 分配一个正整数点权 $w_i$ 使得任意相邻的两个点 $i,j$ 都满足 $w_i \ne w_j$ 且总和最小，输出最小总和。

#### Solution

设 $S_i$ 为 $i$ 的儿子的集合，$f_{i,j}$ 为 $w_i=j$ 时以 $i$ 为根节点的子树的点权总和的最小值，转移方程如下：

$$f_{i,j}=j+\sum\limits_{k \in S_i} \min \limits_{p=1,p \ne j}^{\infty}\{f_{k,p}\}$$

下面对上面这个转移方程进行简要解释，上面这个转移方程也就是说第 $i$ 个点的点权 $w_i=j$，然后枚举所有 $k \in S_i$，然后找到最小的 $f_{k,p}$，但是因为相邻的两个点要满足 $w_i \ne w_j$，因此要保证 $w_i \ne w_k$，即 $p \ne j$。

---


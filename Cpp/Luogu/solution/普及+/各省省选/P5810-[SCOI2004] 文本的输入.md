# [SCOI2004] 文本的输入

## 题目描述

人们在输入文本时，除了逐个输入这种方式外，还可以利用剪贴板进行复制，如果打入一个字母需要 $1$ 的时间，将已输入的部分复制进剪贴板需要 $5$ 的时间（`Ctrl`+`A`，`Ctrl`+`C`，再取消全选状态），将剪贴板的内容粘贴出来需要 $2$ 的时间（`Ctrl`+`V`）。

如果我们不关心输入文本的内容，而只关心输入文本的长度，要输入一个长度**不低于** $n$ 的文本最少需要多少时间？

**请注意，数据范围与原题略有不同。**
　　

## 说明/提示

样例解释：先用 $7$ 时间打出 $7$ 个字符，再复制（用去 $5$ 时间），粘贴两次（用去 $4$ 时间），即可用 $16$ 时间打出 $21$ 个字符。

对于 $20\%$ 的数据，$n\le 10$；

对于 $60\%$ 的数据，$n\le 10^4$；

对于 $100\%$ 的数据，$n\le 4\times 10^4$。

## 样例 #1

### 输入

```
20```

### 输出

```
16```

# 题解

## 作者：Alex_Wei (赞：8)

看题知 $\mathrm{DP}$。

容易想到一种 $\mathrm{DP}$ 算法： $f_i$ 表示打出 $i$ 个字符最少要多长时间，根据题意推出的转移方程如下：

$$f_i=\min_{j\in S}f_j+5+2\times\frac{i-j}{j}$$

化简一下

$$f_i=\min_{j\in S}f_j+3+2\times\frac{i}{j}$$

其中 $S$ 为 $i$ 的约数集合。

所以我们只需要每次 $\sqrt{i}$ 枚举约数转移即可。

由样例可知，$f_i$ 不一定是打出**至少** $i$ 个字符的最优解。

我们只需要在 $\mathrm{DP}$ 时一直求到 $f_{2n}$，再对 $f_n,f_{n+1},\dots,f_{2n}$ 求最小值即可。

- $Q:$ 为什么求到 $f_{2n}$ 就行了？

- $A:$ 我不会证明，但这样可以过。

时间复杂度：$\mathcal O(n\sqrt n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[80005],s=1e9;
int main(){
	cin>>n;
	for(int i=1,j;i<=n*2;i++){
		dp[i]=dp[i-1]+1;
		for(j=1;j<=sqrt(i);j++)if(i%j==0)dp[i]=min(dp[i],min(dp[j]+2*i/j,dp[i/j]+2*j)+3);//i的两个约数为j和i/j,i/(i/j)=j
		if(i>=n)s=min(s,dp[i]);
	}
	cout<<s;
    return 0;
}
```


---

## 作者：5ab_juruo (赞：7)

本文同步发布于我的 [博客园](https://www.cnblogs.com/5ab-juruo)。

---

介绍一种比较优秀的 DP 做法。

一般的思路会用 $f_i$ 表示当目标为 $i$ 时的最小代价。这种做法经过优化后可以达到 $O(n\sqrt{n})$ 的复杂度。

但是如果定义 $f_i$ 为 **代价** 为 $i$ 时的最大字符数呢？（即下标和值互换）

考虑几种操作：

### 添加字符

直接从 $f_{i-1}$ 转移即可。

### 复制、粘贴

直接遍历之前的 $f_{i-k}$（$k=2u+5$，$u\in \mathbb{N^{*}}$）：

$f_i=\max_{u=1}^{k=2u+5\le i} {(u+1)f_{i-k}}$

将这两步取最大值即可。

---

最后，可以证明 $f_i$ 是单调的，直接二分搜索即可。

## 复杂度？

首先，可以证明答案 $\le 7\left\lceil\log_2n\right\rceil+1$（加入一个字符后不停复制粘贴即可），也就是说答案上限是 $\mathcal{O}(\log n)$ 的。

所以，DP 数组只需要开 $\mathcal{O}(\log n)$ 大小。

同时，单步转移复杂度是 $\mathcal{O}(\text{DP 数组大小})=\mathcal{O}(\log n)$，整体复杂度就是 $\mathcal{O}(\log^2 n)$，可以轻松通过。

## Code
DP 数组别忘记开大 $7$ 倍哦！
```cpp
#include <cstdio>
using namespace std;

const int max_n = 120;
int dp[max_n] = {};

int main()
{
	int n, ans;

	scanf("%d", &n);

	if (n == 0)
	{
		puts("0");
		return 0;
	}

	for (ans = 1; dp[ans-1] < n; ans++)
	{
		dp[ans] = dp[ans-1] + 1;

		for (int i = ans - 7, j = 2; i > 0; i -= 2, j++)
			if (dp[ans] < dp[i] * j)
				dp[ans] = dp[i] * j;
	}

	printf("%d\n", ans-1);

	return 0;
}
```

---

## 作者：FjswYuzu (赞：5)

$\ \ \ \ \ \ \ $对于这道题，我们定义 $dp_i$ 为打 $i$ 个字符所需要的最小时间。

$\ \ \ \ \ \ \ $我们很容易得到 dp 方程：

![](https://cdn.luogu.com.cn/upload/image_hosting/vc5d15mk.png)

$\ \ \ \ \ \ \ $但是我们的 dp 是 $O(n^2)$ 的。于是我们考虑优化。

$\ \ \ \ \ \ \ $由于我没有找到优化的点，于是考虑打表。我们的暴力 dp 就派上用上了。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int dp[40005];
int main(){
	freopen("Output.txt","w",stdout);
	printf("1 ");
	dp[1]=1;
	for(int i=2;i<=40000;++i)
	{
		dp[i]=dp[i-1]+1;
		for(int j=1;j<=i-1;++j)
		{
			if(i%j)	dp[i]=min(dp[i],dp[j]+(i/j)*2+5);
			else	dp[i]=min(dp[i],dp[j]+(i/j-1)*2+5);
		}
		printf("%d ",dp[i]);
	}
	return 0;
}
```

$\ \ \ \ \ \ \ $可以看见这是我们初始的表。但是表的长度是 120000，代码过长。[表在这里](https://www.luogu.com.cn/paste/4wyie471)。

$\ \ \ \ \ \ \ $考虑压缩表的长度。发现有很长一段都是相等的，并且 $n=40000$ 时，答案为 76，答案随着 $n$ 增大而增大。

$\ \ \ \ \ \ \ $我们现在把答案相等的一段集在一起，打一个表。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int a[40005];
int main(){
	freopen("Output.txt","r",stdin); 
	int n=40000;
	for(int i=1;i<=n;++i)	scanf("%d",&a[i]);
	freopen("watch.txt","w",stdout);
	printf("int ans[][2]={{0,0}");
	for(int i=1;i<=76;++i)
	{
		printf(",{");
		int l=0,r=0;
		for(int j=1;j<=n;++j)
		{
			if(l && a[j]!=i)
			{
				r=j-1;
				break;
			}
			if(a[j]==i && !l)	l=j;
		}
		if(r==0)	r=40000;
		printf("%d,%d",l,r);
		putchar('}');
	}
	puts("};");
	return 0;
}
```

$\ \ \ \ \ \ \ $我们现在得到了这样的一个表。现在我们可以通过这个表，找到 $n$ 所在的区间，输出答案了。

```cpp
#include<cstdio>
int ans[][2]={{0,0},{1,1},{2,2},{3,3},{4,4},{5,5},{6,6},{7,7},{8,8},{9,9},{10,10},{11,11},{12,12},{13,13},{14,15},{16,18},{19,21},{22,24},{25,28},{29,32},{33,36},{37,40},{41,45},{46,50},{51,55},{56,63},{64,72},{73,84},{85,96},{97,112},{113,128},{129,144},{145,160},{161,180},{181,200},{201,225},{226,252},{253,288},{289,336},{337,384},{385,448},{449,512},{513,576},{577,640},{641,720},{721,800},{801,900},{901,1008},{1009,1152},{1153,1344},{1345,1536},{1537,1792},{1793,2048},{2049,2304},{2305,2560},{2561,2880},{2881,3200},{3201,3600},{3601,4032},{4033,4608},{4609,5376},{5377,6144},{6145,7168},{7169,8192},{8193,9216},{9217,10240},{10241,11520},{11521,12800},{12801,14400},{14401,16128},{16129,18432},{18433,21504},{21505,24576},{24577,28672},{28673,32768},{32769,36864},{36865,40000}};
int main(){
	int n;
	scanf("%d",&n);
	if(n==0)	return puts("0")&0;
	for(int i=1;i<=76;++i)
	{
		if(ans[i][0]<=n && n<=ans[i][1])
		{
			printf("%d",i);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：5)

两个输入难道不像数学题吗······

数学题怎么办？

颓柿子！

不会颓怎么办？

打表！

打表思路楼下dalao已经曰的很清楚了，不再赘述。

然后，找规律！

对于每一个答案，计算能使答案是它的最小$\text{n}$

然后每一项减去它的前一项得到一个新数列。

如下：

```
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 2
16 3
17 3
18 3
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 8
27 9
28 12
29 12
30 16
31 16
32 16
33 16
34 20
35 20
36 25
37 27
38 36
39 48
40 48
41 64
42 64
43 64
44 64
45 80
46 80
47 100
48 108
49 144
50 192
51 192
52 256
53 256
54 256
55 256
56 320
57 320
58 400
```
谔，这个有什么规律吗？

乍一看没有。

但如果这么写呢？

```
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 2
16 3
17 3
18 3
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 8
=========
27 9
28 12
29 12
30 16
31 16
32 16
33 16
34 20
35 20
36 25
37 27
=========
38 36
39 48
40 48
41 64
42 64
43 64
44 64
45 80
46 80
47 100
48 108
=========
49 144
50 192
51 192
52 256
53 256
54 256
55 256
56 320
57 320
58 400
```
1到26依然杂乱无章（不管了老老实实打表输出），但27以后出现了规律！

把两个“=========”称为一段。

一段之间的有点乱，但相邻两段对比，每一项都乘以了4而已！

然后就可以$\operatorname{O}(1)$递推计算这个数列的每一项了！

然后就一个个枚举累加就好了。

至此这题就没了。

复杂度：$\operatorname{O}(\operatorname{lg}n)$（口胡）

应该是除直接打表外复杂度最低的了。

上代码：
```
#include<bits/stdc++.h>
using namespace std;
const int ret[]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,14,15,15,15,16,16,16,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,22,23,23,23,23,23,24,24,24,24,24,25,25,25,25,25,25,25,25,26};
int mv[]={9,12,12,16,16,16,16,20,20,25,27};
int n;
int main(){
	cin>>n;
	if(n<=64)return cout<<ret[n]<<endl,0;
	int beg=64;
	int start=3,grp=26;
	while(1){
		for(int i=0;i<11;++i){
			beg+=mv[i];mv[i]*=4;
			if(beg>n)return cout<<grp<<endl,0;
			++grp;
		}
	}
	return 0;
}
```
话说：其实还可以通过二分+位运算进一步优化到$\operatorname{O}(\operatorname{lg}\operatorname{lg}n)$

但这题已经不需要了。

---

## 作者：L2_sheep (赞：4)

DP的想法非常的显然。可以用类似数论筛法的思想优化，时间复杂度O(nlogn)。具体代码如下：
```cpp
#include <stdio.h>
#define N 40004

int min(int x, int y)
{
	return x < y ? x : y;
}

int main()
{			
	int n, a[N], i, t, j, ans, x;
		
	scanf("%d", &n);
	for(i = 0; i <= n; i++) a[i] = i;
	for(i = 2; i < n; i++){
		a[i] = min(a[i], a[i - 1] + 1);
		for(j = i << 1, t = a[i] + 7; j < n; j += i, t += 2){
			a[j] = min(a[j], t);
		}
	}
	ans = min(a[n], a[x = n - 1] + 1);
	for(i = 1; i < n; i++){
		t = a[i] + 5 + x / i * 2;
		ans = min(t, ans);  
	}
	printf("%d\n", ans);	
	
	return 0;
}
```


---

## 作者：wind_seeker (赞：2)

惊奇的发现没有人暴力，那我小小讲一下。

首先可以判断，如果从 $7$ 开始一直复制粘贴的话，显然，第 $7n$ 次将会达到 $7\times2^n$，观察数据，只有 $4e4$，所以不会超过 $76$ 次，那我们直接暴力搜索，随便剪枝一下即可。

### code
```cpp
/* let life be like summer flowers	*/
/* by wind_seeker					*/
/* 2023-05-03 08:28					*/
#include<bits/stdc++.h>
using namespace std;
const int N=110;

inline int read(){
	int res=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) res=(res<<3)+(res<<1)+(c^48);
	return res*f;
}

int n,sum[N],_res[N];

void dfs(int pos,int num,int res){
	if(pos>77) return;
	//sum[pos-1]=max(sum[pos-1],num);
	if(num>sum[pos-1]) sum[pos-1]=num,_res[pos-1]=res;
	if(num<sum[pos-1]&&res<_res[pos-1]) return;
	dfs(pos+5,num,num);
	dfs(pos+2,num+res,res);
	dfs(pos+1,num+1,res);
}

int main(){
	//4e4,其实可以打表，你别说，还真可以，6，bbl是个内鬼，bnt回血太拉了，我要qq
	//freopen("B.in","r",stdin);
	//freopen("B.out","w",stdout);
	dfs(1,0,0);
	//for(int i=1;i<=100;i++) printf("%d ",sum[i]);
	//puts("");
	n=read();
	for(int i=1;i<=100;i++)
		if(sum[i]>=n){
			printf("%d\n",i);
			return 0;
		}
	return 0;
}

```

---

## 作者：sipu6174 (赞：2)

 1. 这里提供记忆化搜索做法。
 
 2. 转移方程为$dp[i]=\mathop{min}\limits_{j|i}(dp[j]+3+2*\frac{i}{j})$. 每一次转移使用试除法复杂度为$O(\sqrt{n})$.

 3. 关于答案位置的离散性，本人亲测最大到 $n+n/4$ 即可通过本题，不需要开到$2*n$.
 
 4. 总复杂度为$O(n\sqrt{n})$.
 
 ```cpp
#include <bits/stdc++.h>
using namespace std;
int mem[50100];
int n;
int dfs(int now){
   if(!now) return 0;
   if(mem[now]) return mem[now];
   int minn=1e9;
   minn=min(minn,dfs(now-1)+1);
   for(int i=2;i*i<=now;i++)
      if(now%i==0){
         minn=min(minn,dfs(i)+3+2*(now/i));
         minn=min(minn,dfs(now/i)+3+2*i);
      }
   return mem[now]=minn;
}
int main(){
   cin>>n;
   dfs(n+n/4);
   int ans=1e9;
   for(int i=n;i<=n+n/4;i++) ans=min(ans,dfs(i));
   cout<<ans;
   return 0;
}
```


---

## 作者：feecle6418 (赞：2)

@[C20211711刘君实1](https://www.luogu.com.cn/user/184977) 已经把方程说的很清楚了，这里说怎么优化。

把每个 $i$ 的决策点输出来，可以发现，决策几乎呈单峰函数。因此可以事先确定枚举的范围。根据测试，对于任意的 $i\ge 10000$，决策点 $f_i\in [n\div 6,n\div 3.5]$。

因此我们就成功把时间复杂度优化到了 $O(n^2\times 5\div 42)$。可以通过 $n\le 40000$ 的数据。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<cmath>
using namespace std;
int ans[40005];
int Calc(int n){
	if(ans[n])return ans[n];
	if(n<7)return n;
	ans[n]=Calc(n-1)+1;
	for(int i=(n>10000?n/6:1);i<(n>10000?n/3.5:n);i++){
		ans[n]=min(ans[n],Calc(i)+((n%i?n/i:n/i-1))*2+5);
	}
	return ans[n];
}
int main() {
	int n;
	cin>>n;
	cout<<Calc(n);
}
```

---

## 作者：wallcrack (赞：2)

很容易想到的一个贪心的结论：输入总是会在第一阶段完成，不能复制粘贴后再输入。如果先输入后复制粘贴再输入，显然，若将后面的输入放到复制之前结果会更优。所以操作的顺序只会是：输入若干字符 $\to$ 复制+粘贴若干次 $\to$ 复制+粘贴若干次……

因此，可以设 $f[i]$​ 为输入 $i$​ 个字符最少需要的时间，初始化为 $f[i]=i$​ 。当 $f[i]$​ 取到最小值时，它就能向后转移。$f[i*(j+1)]=\min(f[i*(j+1)],f[i]+2*j+5)$​​  。当 $i*(j+1)\ge n$​ 时，就尝试更新 $ans$​ 。最后输出 $\min(f[n],ans)$ 即可。总的时间复杂度为 $O(n\log n)$​​ 。
  
### 代码：

```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N=4e4+10;
int n,ans,f[N];
int main()
{
	memset(f,0x3f,sizeof(f));
	ans=f[0];
	cin>>n;
	f[1]=1;
	for(int i=1;i<=n;i++)
	{
		f[i]=min(i,f[i]);
		for(int j=1;;j++)
		{
			if(i*(j+1)>=n)
			{
				ans=min(ans,f[i]+2*j+5);
				break;
			}
			else f[i*(j+1)]=min(f[i*(j+1)],f[i]+2*j+5);
		}
	}
	cout<<min(f[n],ans);
	return 0;
}
```

---

## 作者：xAlec (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5810)
# 1.题目大意
给你输入文本长度 $ n $，同时给了几种不同的输入方法。问最短要花多久能够输入完成。

# 2.解题思路
因为题目给了我们不同的输入方法，所以可以分情况考虑每种情况的最小时间，最后选择最优方案。所以我们考虑使用 $ dp $ 解决该题。

# 3.状态转移方程
首先是用 ```1``` 的时间来输入一个作为基础的文本 $ f_k = f_{k-1}+1 $

然后用一个多重循环（注意:一个循环里定义两个变量），循环内 $ dp $ 方程：

$ f_k = \max (f_k,f_i \times j) $ 

其中 $ f_k $ 表示继续输入单个字符的文本数量，$ f_i \times  j $ 表示粘贴复制的文本数量。两者取 $ \max $。最后输出 $ k-1 $（注意要减个 ```1``` ），本人第一次就栽在这里。

# 4.代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[1005];//dp数组要开大一点
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	if(n==0){
		cout<<0<<endl;
		return 0;
	}
	int i,j,k;
	for(k=1;f[k-1]<n;k++){//判断字文本是否输入完了
		f[k]=f[k-1]+1;//输入单个字符
		for(i=k-7,j=2;i>0;i-=2,j++){//Ctrl C + Ctrl V 的文本
			f[k]=max(f[k],f[i]*j);
		}
	}
	cout<<k-1<<endl;//输出最短时间
	return 0;
}
```


---


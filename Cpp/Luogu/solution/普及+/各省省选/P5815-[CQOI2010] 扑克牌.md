# [CQOI2010] 扑克牌

## 题目描述

你有 $n$ 种牌，第 $i$ 种牌的数目为 $c_i$。另外有一种特殊的牌：joker，它的数目是 $m$。你可以用每种牌各一张来组成一套牌，也可以用一张 joker 和除了某一种牌以外的其他牌各一张组成 $1$ 套牌。比如，当 $n=3$ 时，一共有 $4$ 种合法的套牌：$\{1,2,3\}$，$\{J,2,3\}$，$\{1,J,3\}$，$\{1,2,J\}$。

给出 $n$，$m$ 和 $c_i$，你的任务是组成尽量多的套牌。每张牌最多只能用在一副套牌里（可以有牌不使用）。

## 说明/提示

**样例说明**

输入数据表明：一共有 $1$ 个 $1$，$2$ 个 $2$，$3$ 个 $3$，$4$ 个 joker。最多可以组成三副套牌：$\{1,J,3\}$，$\{J,2,3\}$，$\{J,2,3\}$，joker 还剩一个，其余牌全部用完。

**数据范围**

对于 $50\%$ 的数据，$2 \le n \le 5$，$0 \le m \le 10^6$，$0 \le c_i \le 200$。

对于 $100\%$ 的数据，$2 \le n \le 50$，$0 \le m,c_i \le 5 \times 10^8$。

## 样例 #1

### 输入

```
3 4
1 2 3
```

### 输出

```
3
```

# 题解

## 作者：WYXkk (赞：15)

首先，我们可以发现，$J$ 和 $1,2,\cdots,n$ 其实没什么区别，假如我们把 $J$ 看成 $0$ 号牌，那么，相当于这 $n+1$ 种牌中任意 $n$ 种各一张可以组成一套牌。

然后，$n$ 种各一张可以转化为 $n+1$ 种各拿一张再取回去一张。

于是我们发现 `check` 非常好写：

```cpp
bool check(ll x)
{
	ll t=0;
	F(i,0,n) t+=max(x-a[i],0);
	return t<=x;
}
```

就是，判断 $n+1$ 种牌各拿 $x$ 张后，需要拿回去多少张，假如这个数不超过 $x$ 则可以，否则不行。

同时，答案显然具有单调性，二分即可。注意一下二分的写法。

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

ll a[55];
int n;
bool check(ll x)
{
	ll t=0;
	F(i,0,n) t+=max(x-a[i],0);
	return t<=x;
}
int main()
{
	rd(n);rd(a[0]);
	F(i,1,n) rd(a[i]);
	ll l=0,r=600000000;
	while(l<r)
	{
		ll mid=(l+r+1)>>1;//注意这里，我们要让中点偏右，否则 r=l+1 会死循环
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l<<endl;
	return 0;
}
```



---

## 作者：C锥 (赞：14)



显然二分 + 贪心；

每次二分一个套牌数目，设它为 $ std $ 。贪心的使用 $ joker $ 。对于每种牌，如果它的数目 $ c_{i} $ 大于等于 $ std $ ，那么不用管它，这种牌的数目是足够的。如果小于 $ std $ ，那我们就要使用 $ joker $ 了（能放则放，贪心思想）。

我们用一个 $ tmp $ 容器记录一下 $ joker $ 使用的次数，然后考虑 $ tmp $ 等于多少时，这个 $ std $ 不符合条件，也就是求一下 $ tmp $ 的限制条件。

1. $tmp <= m$；

2. $tmp<=std$。

第一个是因为最多只有 $ m $ 张 $ joker $ ，第二个是因为每套牌中只能出现一张 $ joker $ 。

那为什么这么贪心的放牌是对的呢？因为我们有一个限制条件 $ tmp <= std $ ，我们不管 $ joker $  到底出现在哪，只管用了几张，只要这套牌用了 $joker $ ，这套牌别的位置就用给出的牌填上去。那如果别的牌不够呢，填不上去咋办？

![](https://cdn.luogu.com.cn/upload/image_hosting/czhwgc44.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

假设我们现在紫色的牌只有四张，黑牌代表 $ joker $ ，如果要填满就得用两张 $ joker $ ，我们发现第三套牌（第三行）出现了两张 $ joker $ ，不符合题意了，但是这时候 $ tmp > std $ ，我们就可以直接判断不合法了。
    

下面是代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#define mid ((l + r + 1) >> 1)

using namespace std;

inline long long read() { //快读
	long long s = 0, f = 1; char ch;
	while(!isdigit(ch = getchar())) (ch == '-') && (f = -f);
	for(s = ch ^ 48;isdigit(ch = getchar()); s = (s << 1) + (s << 3) + (ch ^ 48));
	return s * f;
}

const int N = 55, inf = 7e8 + 5e7 + 1; //自己瞎试了试 
int n, m, l, r;
int c[N];

bool judge(int std) {
	int tmp = 0, rest = std;
	for(int i = 1;i <= n; i++) {
		if(c[i] >= std) continue;
		tmp += (std - c[i]); rest -= (std - c[i]); //两个判断条件
		if(tmp > m || rest < 0) return 0;
	}
	return 1;
}

int main() {
	
	n = read(); m = read();
	for(int i = 1;i <= n; i++) c[i] = read(); 
	l = 1, r = inf;
	while(l < r) { //二分套牌数目
		if(judge(mid)) l = mid;
		else r = mid - 1;
	}
	printf("%d", l);

	return 0;
}
```
个人感觉挺好理解的，如果有不对的地方还希望dalao纠正QWQ


---

## 作者：A_zjzj (赞：11)

## 思路
首先，这是一道不容易被别人看出来的二分答案，我们将这些牌看成一堆（以样例为例），如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2icu0dpv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们可以发现，$joker$可以充当一种牌

$\{1,J,3\}\{J,2,3\}\{J,2,3\}$中，$joker$就分别充当了$2,1,1$。

那么，我们就二分可以打出几组牌，这些牌堆起来，就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/tepbbabn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

就有$a*n$ 张牌，我们就二分$a$，在判断是否合法。

## 重点来了
如何判断是否合法呢？

因为每组最多只有一张（$1,2,3……$），所以每张牌（包括$joker$）的使用数量要≤总组数，否则就不合法。

所以，我们只需要把$每种牌还差多少张$加起来，再看有没有那么多$joker$，判断是否合法就可以了。
## 代码实现
```cpp
#include<bits/stdc++.h>
#define maxn 55
using namespace std;
inline int read()//我喜欢快读
{
    register int x=0,f=1;register char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
    return x*f;
}
int n,t,a[maxn];
int zj(int x) {
    long long k=0;
    for(int i=1;i<=n;i++)//枚举牌的种类
        k+=max(0,x-a[i]);//不能直接加上x-a[i],如果当前牌的数量已经够了，就不用加上x-a[i]了
    if(k<=min(t,x))return 1;//判断合法
    return 0;//不合法
}
int main() {
    n=read();t=read();
    for(int i=1;i<=n;i++)a[i]=read();
    int l=0,r=1e10,m;//r附一个很大的值，来找到最大值
    while(l+1<r) 
    {
	m=(l+r)>>1;//位运算快一点
	if(zj(m))l=m;//合法
	else r=m;//不合法
    }
    printf("%d",l);
    return 0;
}
```
# 谢谢----zhengjun


---

## 作者：Karry5307 (赞：6)

### 题意

有 $n$ 种普通牌和王牌，其中王牌有 $m$ 张，第 $i$ 种普通牌有 $c_i$ 张。一套牌可以由 $n$ 种普通牌各一张来组成，也可以由 $n-1$ 种普通牌各一张再加上一张王牌组成，问最多能组成多少套牌。

$\texttt{Data Range:}1\leq n\leq 50,1\leq m,c_i\leq 5\times 10^8$

### 题解

先扯几句题外话。

神 WYXkk 的题解由于二分上界的问题会在某些毒瘤数据上直接返回二分上界，比如如下数据：

```plain
3 500000000
500000000 500000000 500000000
```

该组数据正确答案为 $666666666$，而神 WYXkk 的代码输出了 $600000000$，构造方案如下：

$166666666$ 组 $\{1,2,3\}$，$166666666$ 组 $\{1,2,J\}$，$166666666$ 组 $\{1,J,3\}$，$166666666$ 组 $\{J,2,3\}$。

这个时候 $1,2,3,J$ 四种牌每种都剩下两张能凑出最后两组，所以答案为 $666666666$。

注意到这个题的话可以二分答案。考虑转化一下组一套牌的过程，相当于每种牌都先拿一张出来，再丢一张回去。于是 check 的过程可以考虑每种牌都拿 $x$ 张出来丢多少张回去，然后没了。

一个注意的点是二分的右端点应该至少为 $750000000$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51;
ll n,l,r,mid,res;
ll c[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll check(ll mid)
{
	li res=0;
	for(register int i=0;i<=n;i++)
	{
		res+=max(mid-c[i],0);
	}
	return res<=mid;
}
int main()
{
	n=read(),c[0]=read(),r=8e8;
	for(register int i=1;i<=n;i++)
	{
		c[i]=read();
	}
	while(l<=r)
	{
		mid=(l+r)>>1;
		check(mid)?l=mid+1,res=mid:r=mid-1;
	}
	printf("%d\n",res);
}
```

---

## 作者：AlanSP (赞：3)

# 二分
> 简化题意：有m个万能数，加上所本有的数，能凑成几套完整序列（长度为n）。

有个很显然的性质：如果能够凑出k套，那么能凑出（k-1）套。

满足单调性，所以采用二分。

二分边界：l=0。

记录maxn为这套牌中数量最大值，那么最好情况下可以凑出maxn+m对，不有多余查找。

所以r=maxn+m。

二分的check只需检查当前的k是否合法。

注意到每套牌只能有一个JOKER，所以当所缺牌数之和大于x，就一定是非法的。

下面是代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+9;

int num[N],maxn,l,ans,r,mid;
int n,m;

inline bool check(int x)
{
	int tem=0;
	bool y=true;
	for(int i=1;i<=n;i++)
	{
		if(num[i]<x)
		{
			tem+=x-num[i];
			if(tem>x) return false;
		}
	}
	if(tem>m) return false;
	return true;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&num[i]),maxn=max(num[i],maxn);
	l=0;r=m+maxn;
	while(l<r)
	{
		int mid=(l+r+1)>>1;
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	printf("%d",l);
	return 0;
}
```

---

## 作者：_Andy_Lin_ (赞：2)

[博客传送门](https://www.luogu.com.cn/blog/linguosheng/)

------------
我们可以将特殊牌也看成一种牌，这样就有n+1种牌了。每次都选n种，将它们的张数都减1，问最多减多少次。再将它转化：n+1种，每次选一种，将它的张数加1，每一种的张数都不能少于加的次数。显然，我们可以二分答案，每次验证mid副凑不凑的出来。思路就清晰了。

------------
AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b,a[1000001],ans;
long long sum;
bool cheak(int x){
	int now=0;
	for(int i=1;i<=n;i++){
		if(a[i]<x)
		now+=x-a[i];
	}
	if(b<x)now+=x-b;
	return (now<=x);
}
int main(){
	scanf("%d%d",&n,&b);
	sum=b;
	for(int i=1;i<=n;i++){
		scanf("%d",(a+i));
		sum+=a[i];
	}
	int l=1,r=sum/n;
	while(l<=r){
		int mid=(l+r)/2;
		if(cheak(mid)){
			l=mid+1;
			ans=mid;
		}
		else r=mid-1;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Tethys (赞：1)

[题面](https://www.luogu.com.cn/problem/P5815)

### 题意：

有$m$张万能牌，其他每种牌有$C_i$种，求能够最多能组成的套牌（用每种牌各一张来组成一套牌）

### 思路：

答案是具有单调性的，假设这些牌能够凑出$x$套牌，同样的，也可以凑出$x-1,\cdots,x-k(1 \leq k \leq x)$套牌

显然，二分答案是可做的， 然后我们考虑$judge$函数

我们要将这些牌凑成$x$套，所以我们只需要考虑每种牌的数量（加上万能牌转换之后的）$\geq x$，就说明这$x$套牌是可以凑出来的

所以$judge$函数如下：
```cpp
bool judge(int x){
	int res = 0;
	for(int i = 1; i <= n; i ++){
		if(c[i] < x) res += (x - c[i]);
	}
	return (res <= min(x, m));
}
```
所以就二分答案直接查找就好了

右边界要设的足够大才可以

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, m, c[55], maxn;
bool judge(int x){
	int sum = 0;
	for(int i = 1; i <= n; i ++){
		if(c[i] < x) sum += (x - c[i]);
	}
	return (sum <= min(x, m));
}
signed main(){
	scanf("%lld %lld", &n, &m);
	for(int i = 1; i <= n; i ++){
		scanf("%lld", &c[i]);
		maxn = max(maxn, c[i]);
	}
	int l = 0, r = maxn + m;
	while(l < r){
		int mid = (l + r + 1) >> 1;
		if(judge(mid)){
			l = mid;
		}else{
			r = mid - 1;
		}
	}
	printf("%lld\n", l);
	return 0;
}
```
完美撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：Purslane (赞：0)

## Solution

首先我们发现 , 这个所谓的 $\text{joker}$ 和普通牌没有什么区别 , 所以把它和普通牌一样处理 .

然后怎么求最大值呢 ?

我们发现 , 按照直接贪心的方法很难求出答案 , 而且如果可以凑出 $i$ 副牌 , 那么必定可以凑出 $i-1$ 副牌 , 满足单调性 . 二分答案即可 .

那么关键在于设计 $\text{check}$ 函数了 . 假设我们要凑成 $x$ 副牌 .

因为每种牌在同一副中至多出现 1 次 , 所以每种牌至多产生 $x$ 个贡献 .

对于产生 $x$ 个贡献的牌 , 我们先把用上 , 那么还要用剩下的去补满其他的 .

这时我们可以理解成一个 $n \times x$ 的格子阵 , 要用不同颜色的 $1 \times 1$ 的小格子填满 . 那么已经用产生 $x$ 个贡献的 "长条" 填充了几列后 , 就剩下一些数量小于 $x$ 的牌作为 "边角料" 了 .

由于是边角料 , 我们可以任意拆分 , 也就是说 , 可以没有一行重复的填满 $\sum c_i ( c_i < x) $ 个格子 . 判断这么多格子的数量和已经产生 $x$ 贡献的长条能否有 $n \times s$ 个格子就行了 .

注意 , 二分的上界高于 $c$ 的上界 , 因为每次有一种牌可以不用 .

code :

```cpp
const int MAXN=50+10;
int n,m,c[MAXN],pre[MAXN]; 
inline int check(const int s) {
	int k=lower_bound(c+1,c+n+1,s)-c;
	if(k<=n) return (n-k+1)*s+pre[k-1]>=(n-1)*s;
	else return pre[n]>=(n-1)*s;
}
inline int bfind(int l,int r) {
	int ans=0,mid;
	while(l<=r) {
		mid=l+r>>1;
		if(check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans;
}
signed main() {
	n=read(),m=read();
	for(int i=1;i<=n;i++) c[i]=read();
	c[++n]=m,sort(c+1,c+n+1);
	for(int i=1;i<=n;i++) pre[i]=pre[i-1]+c[i];
	printf("%d\n",bfind(0,500000000));
	return 0;
}
```

---

## 作者：cqbzhyf (赞：0)

观察题目，发现 $c_i$ 极大，决定使用二分枚举（否则会 TLE），代码量在蓝题中算较小的，但是却有许多细节。
### 思路正确性证明
首先，我们因为要求最优解，如果已经求出的解为 $ans$，那么答案一定大于等于 $ans$，不存在小于 $ans$ 的情况（$ans$ 是一组成立解）。

### 二分范围
左端点为 $0$，右端点 $8×10^8$ 左右，开大些无伤大雅（反正都是二分）。

### 关于 check 函数
设当前判断的是 $x$ 套是否成立，那么我们可以得到数量较多的牌在凑套时不必使用 joker 牌（没有必要），所以需要 joker 牌数量加上的就是 $\max(x-c_i,0)$，如果需要的 joker 牌数量大于 joker 牌总数（无法提供），或大于 $x$（每轮只能使用一张 joker 牌）

### The end
#### code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[55],m,l,r=8e8;
inline bool check(int x){
    int t=0;
    for(int i=1;i<=n;i++){
        t+=max(x-a[i],0ll);
        if(t>min(x,m))return false;
    }
    return true;
}
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    while(l<r){
        int mid=(l+r)>>1;
        if(l==r-1)++mid;
        if(check(mid))l=mid;
        else r=mid-1;
    }
    cout<<r;
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

首先，我是从一本通那儿过来的，但因为数据范围不同，所以正解代码就不同，那里 $n$ 极其大，但这里确是 $c_i$ 极其大，所以我们必须二分答案。代码不难，但是细节比较多。作为一名 CQ OIer，感触较深。
### 正确性证明
首先，我们因为要求最优解，所以说我们可以来证明一下，如果已经求出的解为 $ans$，那么答案一定大于等于它，因为这个解已经成立了，不可能取比它小的了，所以满足了单调性。
### 二分方法
首先，左端点为 0，表示一个都不能成套，最大区间为 $7.5\times 10^8$。最坏数据如下：
```
2 500000000
500000000 500000000 500000000
```
此时答案为 $5\times 10^8$，如果不会算，设成 $10^9$ 也无妨。

二分的 `check` 函数可以这样来分析：

首先，设当前判断的是 $x$，那么我们就可以这样想：如果它的牌本来就够，那么就用它自己的，把 joker 给其他牌，这样一定能满足，如果给了它，冗余的也没用，所以我们加上的就是 $c_i-x$，但是我们不能让它变为负数，所以说还要与就求不够的牌数，但是它肯定是自然数，所以还要和 0 取最大值，这就是它缺少的。一共进行 x 轮，每次最多补一个，在保证足够的情况下，一共只能补 $k=\min{m,x}$ 次，所以记录 $t$ 为缺少牌的数量，然后如果 $t\le k$，那么可以取 $x$ 次，返回 1，否则返回 0。

有了详细的二分，我们只需要套个二分模板，但要注意的是，区间终点必须偏右，否则只有 40 分，原因如下：

首先，但判断到最后一次时，$l=r-1$，此时 $mid=(l+r)/2=l$，如果成立，那么 $l=mid$ 一直执行下去，即一直满足 $l<r$，等式恒成立，二分不会退出，就会变成死循环，所以说我们在最后一次时区间终点必须偏右。
### AC Code:
```cpp
#include<bits/stdc++.h>
#define int long long //t有可能爆 int
using namespace std;
int n,a[55],m,l,r=7.5e8;//l 左端点，r 右端点
bool check(int x){
	int t=0;
	for(int i=1;i<=n;i++){
		t+=max(x-a[i],0ll);//累加缺少的牌数
		if(t>min(x,m))
			return 0;//如果不够就不行
	}
	return 1;//判断到最后都可以就是可行的
}
signed main(){
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	while(l<r){
		int mid=l+r>>1;
        if(l==r-1)
        	mid++;//向上取整，否则40分
		if(check(mid))
			l=mid;
		else
			r=mid-1;//左边可以取，右边不能取
	}//二分模板
	printf("%lld\n",r);//取当前的右端点
	return 0;
}
```

---

## 作者：Coros_Trusds (赞：0)

$\rm upd:$ 添加了部分说明。

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15519684.html)

# 题目大意

你有 $n$ 种牌，第i种牌的数目为 $c_i$。另外有一种特殊的牌：$\rm joker$，它的数目是 $m$。你可以用每种牌各一张来组成一套牌，也可以用一张 $\rm joker$ 和除了某一种牌以外的其他牌各一张组成 $1$ 套牌。

给出 $n$，$m$ 和 $c_i$，你的任务是组成尽量多的套牌。每张牌最多只能用在一副套牌里（可以有牌不使用）。

# 题目分析

发现 $\rm Joker$ 牌的作用只是合法的代替其它类型的卡牌而已，所以我们称 $\rm Joker$ 为 $0$ 号卡牌。

稍微想想：能够拼出 $k$ 组卡牌，一定也能拼出 $k-1,k-2,\cdots,2,1$ 组卡牌。**故答案具有单调性。**

于是考虑二分答案，二分能够拼出的套牌数量。

答案为所有

$\rm Judge$ 函数：

```cpp
inline bool Judge(int now)
{
	int tp=0;
	
	for(register int i=0;i<=n;i++)
	{
		if(now>a[i])//如果当前牌的数量仍不足够
		{
			tp+=now-a[i];
		}
	}
	
	return tp<=now;//表示可以拼出 now 组
} 
```

随后照常二分即可。

注意这里二分参考《算法竞赛入门经典》 $\rm lyd$ 的模板。

# 代码

```cpp
//2021/11/7

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>

#include <cstdio>

#include <climits>//need "INT_MAX","INT_MIN"

#define int long long 

#define enter() putchar(10)

#define debug(c,que) cerr<<#c<<" = "<<c<<que

#define cek(c) puts(c)

#define blow(arr,st,ed,w) for(register int i=(st);i<=(ed);i++)cout<<arr[i]<<w;

#define speed_up() std::ios::sync_with_stdio(false)

namespace Newstd
{
	inline int read()
	{
		char c;
		bool flag=false;
		while((c=getchar())<'0' || c>'9')
		{
		    if(c=='-') flag=true;
		}
		int res=c-'0';
		while((c=getchar())>='0' && c<='9')
		{
		    res=(res<<3)+(res<<1)+c-'0';
		}
		return flag?-res:res;
	}
	inline void print(int x)
	{
		if(x<0)
		{
			putchar('-');x=-x;
		}
		if(x>9)
		{
			print(x/10);
		}
		putchar(x%10+'0');
	}
}

using namespace Newstd;

using namespace std;

const int ma=55;

int a[ma];

int n,m;

inline int Abs(int x)
{
	return x>0?x:-x;
}

inline bool Judge(int now)
{
	int tp=0;
	
	for(register int i=0;i<=n;i++)
	{
		if(now>a[i])
		{
			tp+=now-a[i];
		}
	}
	
	return tp<=now;
} 

#undef int

int main(void)
{
	#define int long long
	
	n=read(),m=read();
	
	a[0]=m;
	
	for(register int i=1;i<=n;i++)
	{
		a[i]=read();
	}
	
	int l=0,r=6e8,ans;
	
	while(l<r)
	{
		int mid=(l+r+1)>>1;
		
		if(Judge(mid)==true)
		{
			l=mid;
			
			ans=l;
		}
		
		else
		{
			r=mid-1;
		}
	}
	
	printf("%lld\n",ans);
	
	return 0;
}
```

---

## 作者：dying (赞：0)

似乎能A的题解全是二分？

在此，我要讲一种截然不同的方法，似乎是贪心？

~~我曾经也这么干过，在一道二分的题用[yy算法](https://dying.blog.luogu.org/solution-p4058)写了我第一篇题解~~

引入思维：

>首先，如果可以用任意张 joker，这道题将会非常简单，每次枚举非零最小值 $min$，再判断能不能用 joker 把它补到这个最小值套牌，如果可以就继续枚举，如果不行就说明答案在 $[ans,ans+min)$ 区间内，且可以 $O(1)$ 算出答案。

>其次，如果一开始没有整套的牌，每次只能用一张 joker，这也会很简单，一直枚举什么时候只要一套牌会差 2 张及以上，就可以算出答案了。

>现在我们引入一张新的牌，把它叫做 JOKER，它不会和 joker 冲突，每套牌使用数量也没有限制，如果告诉你一开始有 $n$ 张 JOKER，$m$ 张 joker，且没有成套的牌，该怎么办？

>如果 joker 和 JOKER 不为零就无限循环。每次枚举非零最小值，容易证明尽量先用 joker 是最优的，每次判断能不能补至此最小值，若不能就可以直接算出最终答案，若可以就继续循环。

>怎么判断能否补上？首先算出要凑一套牌缺少的数量 $q$ ，和非零最小值 $min$，需要补齐至最小值的话一定满足 $tot_{joker}+tot_{JOKER}\geqslant min\times q$，因为至多用 $min$ 张 joker，所以还要满足 $tot_{JOKER}\geqslant min\times (q-1)$。

回到本题
>一开始有可能有整套牌，只有 joker，该怎么办？
>
>其实很简单，一开始每有一套完整的牌，就可以用一张 joker 换成一张 JOKER，且这套牌的价值就被用完了（想一想，为什么？）
>
>之后没有整套牌，有 JOKER，不就是我们刚刚分析的吗？

时间复杂度 $O(n^2)$，如果用线段树优化（每个节点维护0的数量和加和，每有一个0，区间修改就少减v）可以达到 $O(n\log_2 n)$，不过这道题不需要，甚至因为答案区间 $size$ 极大，导致 $\log_2 size \approx 30$ 而 $ n\leqslant 50$，所以这个算法复杂度已经和二分答案差不多，就到此结束吧。

code：
```cpp
#include<bits/stdc++.h>
#define int long long//好习惯
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void print(int a){
	if(a<0)putchar('-'),a=-a;
	if(a>=10)print(a/10);
	putchar(a%10+48);
}

int n=read(),m=read();
int p[60],ans;

signed main(){
	for(int i=1;i<=n;i++)p[i]=read();
	int val=0x3f3f3f3f;
	for(int i=1;i<=n;i++)val=min(val,p[i]);//找出一开始成套的牌数
	for(int i=1;i<=n;i++)p[i]-=val;//先减掉
	ans+=val;
    //注意这行开始val代表的含义就变成了JOKER的数量
	if(m>val)m-=val;
	else val=m,m=0;//尽量吧joker换成JOKER
	while(m||val){
		int q=0,_min=0;
		for(int i=1;i<=n;i++)
			if(p[i]&&(p[i]<_min||!_min))_min=p[i];
			else if(!p[i])q++;
		if(!_min)_min=INT_MAX;
        //此时_min是非零最小值，q是一套牌缺少的数量
        //算法成立条件：在到达_min套牌之前都缺且仅缺q张牌
		if(_min*q<=m+val&&_min*(q-1)<=val){//能补齐成立条件
			for(int i=1;i<=n;i++)
				if(p[i])p[i]-=_min;//能用的牌用掉
			m-=_min,val-=_min*(q-1),ans+=_min;
            //尽量先用joker，用_min张
			if(m<0)val+=m,m=0;
            //特判joker不够_min张时用JOKER补齐，此时JOKER一定大于0，因为之前满足_min*q<=m+val
		}
		else {//不能补齐
			if(q==1)ans+=(m+val)/q;//为了防止除以0，需要特判
			else ans+=min((m+val)/q,val/(q-1));
            //含义：每一层要补q张，补一层(joker+JOKER)至少要减少q张，JOKER至少减少(q-1)张
			break;
		}
	}
	print(ans);
	return~EOF;
}
```
完结撒花！！！

---

## 作者：Okimoto (赞：0)

第一反应是**贪心**，然而尽力却发现最优仅能 $70pts$ ,然后观察数据范围，注意到 $n \le 50$ ，可以暴力二分。将 $joker$ 视作第 $n + 1$ 张牌，我们则仅需每次取 $n$ 张牌，暴力二分答案即可。

下面给出贪心和二分（正解）代码。
## 贪心
```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
int n;
int c;
int a[64];
std::priority_queue<int, std::vector<int>, std::greater<int> > heap;
int main()
{
    scanf("%d%d", &n, &c);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        heap.push(a[i]);
    }
    int cnt = 0;
    while(c != 0 || heap.top() - cnt != 0)
    {
        int first = heap.top();
        heap.pop();
        int second = heap.top();
        if(second - cnt == 0)
        {
            break;
        }
        int add = std::min(first - cnt + 1, second - first + 1);
        cnt += add;
        if(add > c)
        {
            first += c;
            c = 0;
        }
        else
        {
            c -= add;
            first += add;
        }
        //printf("%d", add);
        heap.push(first);
    }
    printf("%d", cnt);
    return 0;
}

```
## 二分
```cpp
#include <cstdio>
#include <algorithm>
int a[60];
int n;
bool check(int x)
{
    long long cnt = 0; // Attention! **cnt** must be declared as a **long long** integer variable
    for(int i = 1; i <= n + 1; i++) cnt += std::max(x - a[i], 0);
    return cnt <= x;
}
int main()
{
    scanf("%d", &n);
    scanf("%d", &a[n + 1]);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    int l = 0, r = 1e9;
    while(l + 1 < r)
    {
        int mid = (l + r) >> 1;
        if(check(mid)) l = mid;
        else r = mid;
    }
    printf("%d", l);
    return 0;
}

```


---

## 作者：Lumos壹玖贰壹 (赞：0)

#### ~~好裸的~~二分
##### Problem
你有$n$种牌，第$i$种牌的数目为 $c_i$。另外有一种特殊的牌：$j$，它的数目是 $m$。你可以用每种牌各一张来组成一套牌，也可以用一张 $j$替换一张牌组成1套牌。

给出 $n$，$m$和 $c_i$，组成尽量多的套牌。每张牌最多只能用在一副套牌里（可以有牌不使用）。
##### Solution
换直观一点，$n$棵树，每棵树$c_i$米高，总共能加高$m$米问最矮的树最高是多少。

多裸的二分，~~我开开心心的想一遍切了~~结果$40pts$

为啥不对？因为你在 **同一副牌里不能用多张j** ， 也就是说在 **同一高度你只能给一棵树加高1米** (然后这棵树上面的部分都上移1米)。所以假定我们**从第一米开始加**，记录一下从下到上已经加到了第几米，如果**超过了这棵树的高度**就返回假。当然如果最矮的也补不了这么高也返回假。显然，你**先要对这n棵树按高度排序**

思路真的超裸，但不要冲动要考虑清楚，很容易就过了~~不敢相信这也是曾是省选题~~

##### Code
代码中还有一点注释~~虽然我觉得真的简单到不需要注释了~~
```cpp
#include<bits/stdc++.h>
#define ri register int
#define ll long long
using namespace std;
int c[55],n,m,minc=0x3f3f3f3f;
inline bool check(ll x){
	ll last=0;
	for(ri i=1;i<=n;i++){
		if(c[i]>=x) continue;//不用补
		if(last>c[i]) return 0;//要补的位置已经比这棵树高了
		last+=x-c[i];
		if(last>m) return 0;//补不了那么高了
	}
	return 1;
}
int main(){
	scanf("%d%d",&n,&m);
	for(ri i=1;i<=n;i++) scanf("%d",&c[i]);
	sort(c+1,c+n+1);
	minc=c[1];
	ll l=minc,r=minc+m,ans=l;
	while(l<=r){
		ll mid=(l+r)>>1;
		if(check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%lld\n",ans);
	return 0;
}

```

---


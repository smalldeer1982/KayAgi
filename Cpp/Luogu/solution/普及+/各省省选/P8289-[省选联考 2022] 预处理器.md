# [省选联考 2022] 预处理器

## 题目描述

宏是 C/C++ 语言的一项特性，它根据预先定义的规则进行文本替换（也被称为 “宏展开”），能够实现定义常量、简化代码重复输入等功能。例如：

```cpp
#define PI 3.14159
double area = PI * r * r;
```

以上代码经过宏展开后变为：

```cpp

double area = 3.14159 * r * r;
```

其中，宏定义命令变成了空行，而其他行中的宏被展开成了规则定义的文本。

C/C++ 语言代码在编译时对宏的处理由**预处理器**完成。你的任务是实现一个简化版的预处理器，要求如下：

- 代码由**行**组成，每行除行末的换行符外，均由可打印 ASCII 字符（ASCII 码范围 $32\sim 126$）组成。每行要么是**预处理命令**（以 `#` 开头），要么是**普通文本**（其他情况）。

- 预处理器逐行处理代码，
	- 如果是预处理命令，执行该命令，并输出一个空行。
    - 如果是普通文本，对其进行宏展开并输出结果。
- 预处理命令有两种，分别是宏定义命令 `#define` 和取消宏定义命令 `#undef`。
	- 宏定义命令的格式为 `#define <name> <content>`，其中第一部分 `#define` 是命令名，第二部分 `<name>` 是要定义的宏的名字，第三部分 `<content>` 是要定义的宏的展开内容。
    - 取消宏定义命令的格式为 `#undef <name>`，其中第一部分 `#undef` 是命令名，第二部分 `<name>` 是要取消的宏的名字。
    
    以上两种预处理命令中，相邻两部分之间都严格用一个空格分隔。`<name>` 是由大小写字母和数字以及下划线组成的**标识符**（一个或多个字符），`<content>` 可以包含任意可打印 ASCII 字符（零个或多个字符）。一个宏定义的**有效范围**是从它定义所在行开始到后续最近的宏名匹配的取消定义所在行为止（如果没有对应的取消定义，则有效范围一直覆盖到文件结束）。
    
对普通文本进行宏展开时，将一行文本中每段**连续极长**的大小写字母和数字以及下划线视为标识符（而不是其中一部分），其余为**其他字符**。从左到右依次对文本中的标识符进行宏展开：
    
1. 如果该标识符是有效的宏名，则用对应的展开内容替换它，此时该宏名进入正在展开的状态，直到本流程结束；否则原样保留宏名。例如，若宏 `A` 定义为 `b`，则文本 `A` 展开结果为 `b`（发生替换），文本 `B` 展开结果仍然为 `B`（未定义，不替换），文本 `AA` 展开结果仍然为 `AA`（`AA` 是不同于 `A` 的另一个标识符，未定义），而文本 `A*B` 展开结果为 `b*B`。
    
2. 替换发生后，如果展开内容中包含标识符，重复应用以上的展开操作，称为 “多次展开”。例如，若宏 `A` 定义为 `B`，宏 `B` 定义为 `c`，则文本 `A` 的展开结果为 `c`。
    
3. 如果待展开的宏名与正在进行展开的某个宏名相同，称为 “递归展开”，此时该宏名不再展开。本规则用来防止无限递归展开。例如，若宏 `A` 定义为 `B+a`，宏 `B` 定义为 `A+b`，则文本 `A` 展开结果为 `A+b+a`，由于最初的 `A` 处于正在展开状态，因此 `A+b+a` 里的 `A` 不再展开。

4. 其他字符原样保留。

注意：出于简化的目的，本题的要求与 C/C++ 语言标准里的描述不完全一致，请以上面的要求为准。最明显的区别是本题只有标识符和其他字符两类词法单元，没有数值、字符串、注释等。

## 说明/提示

**【数据范围】**

对 $20\%$ 的数据，不会出现宏定义命令 `#define` 和宏取消定义命令 `#undef`。

对另外 $20\%$ 的数据，不会出现多次展开的情况，且不会出现宏取消定义命令 `#undef`。

对另外 $20\%$ 的数据，不会出现多次展开的情况。

对另外 $20\%$ 的数据，不会出现递归展开的情况。

对其余数据，无特殊限制。

对 $100\%$ 的数据，$n \leq 100$，输入的每行字符数都不超过 $100$，且保证输出的每行字符数都不超过 $1000$（字符数均不计行末换行符）。保证输入数据中的预处理命令都是合法的，包含但不限于：

- `#` 字符只会出现在预处理命令所在行的第一个字符的位置，其他任何位置（包括预处理命令和普通文本）都不会出现 `#` 字符。
- 宏定义和取消定义命令的格式是正确的，严格遵循题面所描述的格式。
- 同一个宏在取消定义之前不会被再次定义。
- 要取消定义的宏在之前被定义过且还没有被取消过。

也就是说，**你不需要做任何语法和语义的错误检查**。

**【提示】**

本题进行输入时建议使用 C++ 语言的按行读入字符串功能，示例如下：

```cpp
#include <iostream>
#include <string>
using namespace std;
string line;
// 从 cin 读入一行，放入 line 中（换行符被舍弃）
getline(cin, line);
```

也可以使用 C 语言提供的 `fgets` 函数，示例如下：

```cpp
#include <stdio.h>
#define MAX_LEN 200
char line[MAX_LEN];
// 从 stdin 读入一行，放入 line 中（包含换行符）
fgets(line, MAX_LEN, stdin);
```

**注意**：在读取行数 $n$ 之后可能需要额外读取一行以忽略其后的换行符。

## 样例 #1

### 输入

```
5
#define BEGIN {
#define END }
#define INTEGER int
class C BEGIN INTEGER x; END;
INTEGER main() BEGIN C c; END
```

### 输出

```



class C { int x; };
int main() { C c; }
```

## 样例 #2

### 输入

```
见附件中的 preprocessor/preprocessor2.in```

### 输出

```
见附件中的 preprocessor/preprocessor2.ans```

## 样例 #3

### 输入

```
见附件中的 preprocessor/preprocessor3.in```

### 输出

```
见附件中的 preprocessor/preprocessor3.ans```

# 题解

## 作者：宝硕 (赞：62)

更好的阅读体验：<https://oi.baoshuo.ren/solutions/luogu-p8289/>

## 思路

这是一道不大不小的模拟题，有一些注意事项：

1. 判断有效的宏名比判断分隔符要容易实现。
2. 题目有要求不能展开无限递归的宏，需要打标记记录一下。
3. STL 是个好东西。

详细实现可以看代码注释。

我的代码官方数据跑了 36ms ~~，卡卡常应该能卡到最优解的位置~~ 。

### STL 相关

一个非常好用的 C++ 参考手册（中文）：[zh.cppreference.com](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)。

在考场上如果不知道怎么用 STL 可以去翻头文件中的注释（英文），里面有简单的说明。

#### `std::string` 入门

声明一个 `std::string` 类型的变量 `s`：

```cpp
std::string s = "abcdef";
```

获取字符串长度：

```cpp
s.size();
// 6
```

判空：

```cpp
s.empty();
// false
```

截取子串：

```cpp
s.substr(1, 3);  // s 中从 1 开始长度为 3 的子串
// "bcd"
```

查找字串：

```cpp
s.find("cde", 1);  // s 中从下标为 1 的位置开始查找字串 "cde"
// 2
```

同样地，也可以查找某个字符出现的位置：

```cpp
s.find('c');  // s 中第一次出现的 'c'
// 2
```

STL 也提供了其他查找函数：

- `find_first_of`：查找字符串中第一个包含指定字符（串）的位置。
- `find_last_of`：查找字符串中最后一个包含指定字符（串）的位置。
- `find_first_not_of`：查找字符串中第一个不包含指定字符（串）的位置。
- `find_last_not_of`：查找字符串中最后一个不包含指定字符（串）的位置。

使用方法与上面的 `find` 函数类似，不再过多赘述。

清空字符串：

```cpp
s.clear();
```

#### `std::unordered_map` 入门

`std::unordered_map` 在 C++11 中被引入，由于其基于哈希的实现导致了在大多数情况下 `std::unordered_map` 比 `std::map` 要快。

声明一个 `std::unordered_map<std::string, int>` 类型的变量 `map`：

```cpp
std::unordered_map<std::string, int> map;
```

插入元素：

```cpp
map["a"] = 1;
map.insert(std::make_pair("b", 2));  // pair 的 first 键值为 key，second 键值为 value
map["c"] = -1;
```

查找元素：

```cpp
map.find("c");  // 返回迭代器
map.count("c"); // 返回元素个数（1 或 0）
```

删除迭代器 `it` 指向的元素：

```cpp
auto it = map.find("c");
map.erase(it);
```

删除键为 `c` 的元素：

```cpp
map.erase("c");
```

获取元素个数：

```cpp
map.size();
// 2
```

判空：

```cpp
map.empty();
// false
```

访问元素：

```cpp
map["a"];
// 1
```

使用下标访问时如果元素不存在会自动新建，所以建议访问前先使用 `map.count()` 判断是否存在该元素。

清空整个容器：

```cpp
map.clear();
```

## 代码

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

using std::cin;
using std::cout;
const char endl = '\n';

// 题目限制
const int N = 105;

// 代码行数
int n;
// 原始字符串
std::string s[N];
// 宏列表：        <宏名,                 <内容,     正在展开>>
std::unordered_map<std::string, std::pair<std::string, bool>> def;

/**
 * 递归展开
 * @param s 原始字符串
 * @return 展开后的字符串
 */
std::string dfs(std::string s) {
    std::string r;

    for (int i = 0, j; i < s.size(); i += j) {
        for (j = 0; i + j < s.size() &&                     // 防止越界
                    ('0' <= s[i + j] && s[i + j] <= '9' ||  // 数字
                     'a' <= s[i + j] && s[i + j] <= 'z' ||  // 小写字母
                     'A' <= s[i + j] && s[i + j] <= 'Z' ||  // 大写字母
                     s[i + j] == '_');                      // 下划线
             j++);  // 匹配合法宏名

        if (j) {
            std::string tmp = s.substr(i, j);  // 截取从 i 开始的 j 个字符
            if (def.count(tmp) && !def[tmp].second) {  // 该宏存在且未处在展开状态
                def[tmp].second = true;                // 将该宏标记为正在展开
                r += dfs(def[tmp].first);              // 递归展开
                def[tmp].second = false;               // 取消标记
            } else {
                r += tmp;  // 不存在直接按原样加入到结果中
            }
        } else {
            r += s[i++];  // 不合法，直接略过，加入到结果中
        }
    }

    return r;
}

int main() {
    std::ios::sync_with_stdio(false);

    cin >> n;

    // 第 0 行读入 n 后尾随的换行符
    for (int i = 0; i <= n; i++) {
        std::getline(cin, s[i]);
    }

    for (int i = 1; i <= n; i++) {
        if (s[i][0] == '#') {  // 预处理命令
            if (s[i].substr(1, 6) == "define") {
                int p = s[i].find_first_of(' ', 8);  // 宏名后的空格位置
                std::string name = s[i].substr(8, p - 8),
                            content = s[i].substr(p + 1);
                // 插入内容
                def[name] = std::make_pair(content, false);
            } else {  // s[i].substr(1, 6) == "undef"
                std::string name = s[i].substr(7);
                def.erase(name);
            }
            cout << endl;
        } else {  // 普通文本
            cout << dfs(s[i]) << endl;
        }
    }

    return 0;
}
```

---

本文最后更新于 2022/04/26。


---

## 作者：anideahe (赞：10)

### ~~那一天,人类终于回想起了,曾经被儒略历所支配的恐惧......~~  
---
### 题意：
题目的意思还是很清楚的，~~如果你会用 define 的话~~。大概就是定义替换和取消定义两种操作，并且允许递归替换，**但不可以在同一递归中使用相同的替换规则**，所以说写个递归就好了，看代码可能会好理解一些......

### 注意事项：
1.题目定义每段连续极长的大小写字母和数字以及下划线视为标识符，其余为其他字符，这为解题提供了极大的方便。

2.你只需注意按照题目给定的方式读入即可，第一行最后的换行符需要额外读入一行。  

### 代码 and 注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
static const int N=105;
char a[N][N];
int n;
map<string,string> Map;
map<string,bool> Maap;
inline int check(char a){
	if(a>=' '&&a<='/'||a>=':'&&a<='@'||a>='['&&a<='`'||a>='{'&&a<='~')
		return 1;
	return 0;
}//标识符 or 其他字符
void print(string s){
	string f,g;
	for(int i=0;i<s.size();i=-~i){
		if(check(s[i])){
			if(!Maap[f]&&Map[f]!=g){//此标识符存在替换规则
				Maap[f]=1;
				print(Map[f]);
				Maap[f]=0;
			}//标记此替换规则在此次递归中使用过 and 回溯
			else
				cout<<f;
			f=g;
			printf("%c",s[i]);
			continue;
		}
		else f+=s[i];
	}
	if(!Maap[f]&&Map[f]!=g){
		Maap[f]=1;
		print(Map[f]);
		Maap[f]=0;
	}
	else
		cout<<f;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i=-~i)
		fgets(a[i],N,stdin);
	fgets(a[n+1],N,stdin);//额外读入一行
	for(int i=2;i<=n+1;i=-~i){
		if(a[i][0]=='#'){
			if(a[i][1]=='d'){
				int now=8;
				string f,g;
				while(a[i][now]!=' ')
					f+=a[i][now++];
				now++;
				while(a[i][now]!='\n')
					g+=a[i][now++];
				Map[f]=g;
			}//定义替换
			if(a[i][1]=='u'){
				int now=7;
				string f;
				while(a[i][now]!='\n')
					f+=a[i][now++];
				Map[f]=f;
			}//取消定义
			puts("");
			continue;
		}
		int now=0;
		string f,g;
		while(a[i][now]!='\n'){
			if(check(a[i][now])){
				print(f);
				f=g;
				printf("%c",a[i][now]);
			}//读取到一个标识符，进行递归替换
			else
				f+=a[i][now];
			now++;
		}
		print(f);//剩余的标识符
		f=g;
		printf("\n");
	}
	return 0;
}
```
---
### Ps:

1.多次替换就是递归替换的简化版。  

2.民间数据卡哈希表，所以我改成了 map。

3.此代码可过官方数据，无法通过部分民间数据（貌似与空格有关？至今未解决，发现请指出，也许会补锅 QAQ。


---

## 作者：Aiopr_2378 (赞：5)

## 解题思路

一道模拟题，模拟方法题目中已给出，不需要任何优化。

我们可以用 `map` 记录添加的宏和删去的宏。下面是应用到的变量：

- `int n`：需要处理的代码行数。

- `map<string,string> mp`：用来记录添加的宏的内容。

- `map<string,int> id`：用来记录添加的宏的编号（第几个加入的）。

- `int cnt`：用来记录已经添加过几个宏（注意是**添加过**，而不是现有）。

- `bool del[MAXN]`：用来记录“对于每一个删去的宏，它所对应的 `id` 是多少”，即这个“删去的宏”原来的编号。

- `bool vis[MAXN]`：用来在“递归展开”时记录每一个宏是否已经被展开过（是否用过了），注意回溯。

下面进行模拟。

### Part 1

对于 `#define <name> <content>` 操作，我们需要分析出 `name` 和 `content`，然后记录 `mp` 和 `id`。

```cpp
void define(string str){
    int i;
    string a="",b="";
    for(i=8;i<=str.length();i++){//从name的第一个字符开始分解，直到找到空格
        if(str[i]==' ') break;
        a+=str[i];
        aa[i-8]=str[i];
    }
    for(++i;i<=str.length();i++){//空格后面的都是content
        b+=str[i];
    }
    mp[a]=b;//记录mp
    id[a]=++cnt;//记录id
}
```

对于 `#undef <name>` 操作，我们只需要分析出 `name`，标记 `del`。

```cpp
void undef(string str){
    int i;
    string a="";
    for(i=7;i<str.length();i++){//从name的第一个字符开始分解，直至末尾
        a+=str[i];
    }
    del[id[a]]=1;//标记del
}
```

对于普通文本操作，我们需要从前到后分解出每一个**标识符**。并对于每一个标识符，检查它是否为合法存在的宏名。如果是，对其进行**递归操作**，进行“多次展开”和“递归展开”；如果不是，直接输出，并向后查找。

```cpp
bool check(char c){//检查该位是否是标识符的某一位，是就返回1，不是返回0
    if(c>='a'&&c<='z'||c>='A'&&c<='Z') return 1;
    if(c>='0'&&c<='9') return 1;
    if(c=='_') return 1;
    return 0;
}
void work(string str){//展开文本
    string a="";
    str+=" ";//在文本末尾加一位空格，用来检查最后一组标识符（如果有的话）
    for(int i=0;i<str.length();i++){
        if(check(str[i])) a+=str[i];//如果该位是标识符的合法位
        else{//如果不是
            if(mp.find(a)==mp.end()) cout<<a;//a不是定义过的宏
            else{//a是宏
                if(del[id[a]]||vis[id[a]]){//a已经被删除或在递归展开中访问过
                    cout<<a;
                }
                else{//符合递归展开条件，进行递归
                    vis[id[a]]=1;//标记以访问
                    work(mp[a]);//递归
                    vis[id[a]]=0;//回溯，至于为什么可以看一下样例3
                }
                
            }
            a="";
            if(i!=str.length()-1&&str[i]!=0) cout<<str[i];
            //如果i不是加上去的哪一位，并且不是空位（这个程序可能出现空位字符的情况），输出该位非标识符
        }
    }
}
```

然后综合一下就好啦~~

## 参考代码

这里就不再多解释啦，上文已经说明啦~

有困惑可以独立思考一下

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<map>
#define MAXN 105
using namespace std;
int n,cnt;
map <string,string> mp;
map <string,int> id;
bool vis[MAXN],del[MAXN];
void define(string str){
    string a="",b="";
    char aa[100];
    if(str[1]=='d'){
        int i;
        for(i=8;i<=str.length();i++){
            if(str[i]==' ') break;
            a+=str[i];
            aa[i-8]=str[i];
        }
        for(++i;i<=str.length();i++){
            b+=str[i];
        }
        mp[a]=b;
        id[a]=++cnt;
    }
    else{
        int i;
        a="";
        for(i=7;i<str.length();i++){
            a+=str[i];
        }
        del[id[a]]=1;
    }
}
bool check(char c){
    if(c>='a'&&c<='z'||c>='A'&&c<='Z') return 1;
    if(c>='0'&&c<='9') return 1;
    if(c=='_') return 1;
    return 0;
}
void work(string str){
    string a="";
    str+=" ";
    for(int i=0;i<str.length();i++){
        if(check(str[i])) a+=str[i];
        else{
            if(mp.find(a)==mp.end()) cout<<a;
            else{
                if(del[id[a]]||vis[id[a]]){
                    cout<<a;
                }
                else{
                    vis[id[a]]=1;
                    work(mp[a]);
                    vis[id[a]]=0;
                }
                
            }
            a="";
            if(i!=str.length()-1&&str[i]!=0) cout<<str[i];
        }
    }
}
int main(){
    scanf("%d\n",&n);
    for(int i=1;i<=n;i++){
        string str;
        getline(cin,str);
        if(str[0]=='#'){
            define(str);//合二为一（
            printf("\n");
        }
        else{
            work(str);
            printf("\n");
        }
    }
    return 0;
}
```

## Thanks

---

## 作者：AzusaShirasu (赞：5)

本题就是一道模拟题，大模拟并不是没有思路可言的。对于要求繁杂的题目，如果想要一蹴而就地写，代码常常会变得冗长而且易错，另外还有许多细节性的问题容易出漏洞。所以，大模拟需要采取**自顶向下**的开发方式。

所谓自顶向下，可以理解成先对代码的整体流程有一个基本的逻辑思路。想象一下平常写算法题：先理出基本算法，列出 `main` 函数内要做的事（比如用到了 $\texttt{SPFA}$ 等），然后再去完善相关函数。形象的说，开发过程是**递归**进行的。

本题要求计算宏的扩展。对于每一行代码，第一步判断这行代码的类型：宏定义、解除定义或者是普通的文本。如果只考虑细节，可以先写出如下的逻辑：

```
void execute(string & text) {
	string result = "";
	if ( /*是宏定义*/ ) {
		def_macro(name, declaration);
	}
	else if ( /*是解除宏定义*/ ) {
		undef_macro(tokens[3]);
	}
	else {
		result = <拓展宏内容>;
	}
	puts(result.c_str());
}
```
本题宏的名字一定是合法的标识符。所以需要分离出文本中的标识符。直接从空格处分割串显然不行，反例形如 `A+B + C`，将会分离出 `{"A+B","+","C"}`；同样的，直接替换也是不行的，假设有一个宏叫做 `A`，那么 `A + Abc` 中只有一个 `A` 应当被替换。这说明必须对文本串进行**词法分析**。

词法分析（$\texttt{Tokenize}$），简而言之就是把输入代码分割成各个词（正确名字是单元 $\texttt{Token}$），比如 `A+B + C` 分离成 `{"A","+","B","+","C"}`。本题只出现标识符和特殊符号，因此分割思路是显然的：当遇到字母 / 数字 / 下划线时，不断读入直到出现非标识符字符。注意，**空白字符也必须原样输出**，所以在词法分析时不能简单的跳过空白符。

```
bool is_csyn(char c) { // 判断是否是标识符字符，is_csym 函数不一定能用
	return isdigit(c) || isalpha(c) || c == '_';
}
typedef vector<string> Vector;
Vector tokenize(string & text) {
	Vector result; // 保存结果
	string cur = "";
	int len = text.length();
	int pos = 0;
	while (pos < len) {
		if (is_csyn(text[pos])) {
			while (is_csyn(text[pos])) cur += text[pos], pos++; // 不断读入
			result.push_back(cur), cur = "";
		}
		else if (!isspace(text[pos])) result.push_back((string)("") + text[pos]), pos++; // 符号，并且不是字符
		else {
			while (isspace(text[pos])) cur += text[pos], pos++; // 不断读入空格
			result.push_back(cur), cur = "";
		}
	}
	return result;
}
```

**宏的定义与解除定义**。一个宏对应一个展开方式，很容易就能想到用 `map` 来保存。代码中，使用 `Vector` 而非原文本串来保存代码，是为了避免重复进行词法分析。下文就可以看到它的优点。

```
map<string, Vector> macros;
inline void def_macro(string & macro, Vector & expansion) {
	macros[macro] = expansion;
}

inline void undef_macro(string & macro) {
	macros.erase(macro);
}
```

**宏的展开**。展开是递归进行的，所以代码实现也需要使用递归。正在展开的宏不应当被再次展开，可以使用一个 `set` 来保存“正在展开中的宏”的列表。在这里代码实现就非常简洁了：

```
set<string> expanding;
string expand(string & macro) {
	if(macros.find(macro) == macros.end() || expanding.find(macro) != expanding.end()) return macro; // 不是宏或者正在展开
	expanding.insert(macro); // 正在展开
	
	stringstream result("");
	Vector expansion = macros[macro];
	
	int size = expansion.size();
	for (int i = 0; i < size; i++) result << expand(expansion[i]); // 对宏的内容的每个词进行展开
	expanding.erase(macro);
	return result.str(); // 返回结果串
}
```

有了这些函数的实现，最后完善 `execute` 函数。判断当前文本串的类型就很容易了：

- 如果第一个词是 `#`，第二个词是 `define`，那么这是一个宏定义；
- 否则，如果第一个词是 `#`，第二个词是 `undef`，那么这是一个解除宏定义；
- 否则，这是一个文本串。

需要注意下标，因为有空格的存在，宏定义和解除宏定义的名字都是在第四个词，而宏内容是从第六个词开始的。举例来说，代码 `#define A B+C + D` 的词法分析结果是（下划线用来标识空格）：

$$\texttt{\color{red}\#\color{green}define\color{red}\_\color{green}A\color{red}\_\color{green}B\color{red}+\color{green}C\color{red}\_\color{green}+\color{red}\_\color{green}D}$$

可以看出从第六个词开始才是真正的宏内容。还有一些细节，可看代码：


```
void execute(string & text) {
	Vector tokens = tokenize(text);
	string result = "";
	if (tokens[0] == "#" && tokens[1] == "define") { // 宏定义
		string name = tokens[3]; // 宏名是第 4 个词
		Vector declaration;
		for (int i = 5; i < tokens.size(); i++) declaration.push_back(tokens[i]); // 宏内容从第 6 个开始
		def_macro(name, declaration);
	}
	else if (tokens[0] == "#" && tokens[1] == "undef") { // 解除宏定义
		undef_macro(tokens[3]);
	}
	else {
		for (int i = 0; i < tokens.size(); i++) result += expand(tokens[i]); // 文本串，直接展开
	}
	puts(result.c_str());
}
```

`main` 函数代码很简单，就不放了。按照自顶向下的方法做来，一切代码都是清晰易懂的，细节也不会混乱。本人以为，选手不仅要有看出问题解法的能力，还需要有真正解决问题的代码能力。本题其实是一个弱化版的词法分析器，想要尝试真正完整的词法分析器可以前往 [**$\texttt{UVA12421}$**](https://www.luogu.com.cn/problem/UVA12421)。

省选的模拟题出的很好，下次不要再出了。



---

## 作者：XenonWZH (赞：4)

[更好的阅读体验请点这！](https://xenonwzh.github.io/pro2022-preprocessor/)

# 题意描述

对于该题，你需要展开 `#define` 宏定义。本题中的宏定义与 C++ 中的宏定义大致相同，不过有下列特点：

- 可以用 `#undef` 取消宏定义；
- 可以进行多次展开。如 `#define a b+e`，`#define b c+d`，对于 `a` 最终展开结果为 `c+d+e`；
- 可以进行递归展开，但若待展开的宏名与正在进行展开的某个宏名相同，为了防止无限递归，此时宏名就不再展开。如 `#define a b+c`，`#define b a+a`，对于 `b` 的展开结果即为 `b+c+b+c`。

其他细节详见题面。

# 解题思路

~~一道让 OI 倒退 15 年的题~~

本题是一道细节超多的模拟题。

首先我们需要解决这道题的输入。以分隔符为界，分段读入即可。每个分隔符（包括空格）可以看成单独一个字符串读入即可。

然后我们可以用 `std::map<std::string, std::string>` 存储 `#define` 的对应关系。对于 `#undef`，我们仅需在 `map` 中删除该项即可。

最后我们需要解决的是字符串展开问题，也是本题中细节最多的部分。

由于本题中涉及了递归展开，我们可以考虑使用递归来编写处理函数 `solve`。首先考虑在 `map` 中是否有已经定义的字符串或者是否被打标记，若 `map` 中没有或被打了标记则直接输出。若有，则进行以下操作：

1. 进行标记（在本代码中使用 `vis` 进行）；
2. 展开当前的字符串；
3. 将字符串分段读入（读入方式见上）；
4. 对于每段字符串分别递归求解；
5. 取消标记。

注意 4 步很重要，若直接展开后递归，则无法处理两将要展开的字符串并列的情况。接下来为该情况 Hack 数据：

```
3
#define a b+c
#define b a+a
b
```
结果应为 `b+c+b+c`，但是直接展开后递归的结果会是 `b+c+a`。

# 代码演示

```cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <tuple>
#include <map>
#include <vector>

std::map<std::string, std::string> def;
std::map<std::string, bool> vis;

inline bool isID(char ch) {
    if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch == '_') return true;
    else return false;
}

// tuple 中第一项代表读到的字符串，第二项表示是否为分隔符，第三项表示结束位置对应 src 的下标
// 建议可以学一下 tuple 的用法
inline std::tuple<std::string, bool, int> reads(std::string src, int pos) {
    if (isID(src[pos])) {
        std::string str = "";
        int len = src.length();
        while (pos < len && isID(src[pos])) {
            str += src.substr(pos, 1);
            pos++;
        }
        return std::make_tuple(str, true, pos);
    } else {
        std::string str = "";
        str += src.substr(pos, 1);
        return std::make_tuple(str, false, pos + 1);
    }
}

// 这个函数专门读 #define
inline std::pair<std::string, int> readDef(std::string src, int pos) {
    int len = src.length();
    while (pos < len && isspace(src[pos])) pos++;
    std::string str = "";
    while (pos < len && !isspace(src[pos])) str += src[pos++];
    return std::make_pair(str, pos);
}

void solve(std::string str) {
    if (def.count(str) != 0 && !vis[str]) {
        vis[str] = true;
        std::string src = str;  // 注意要存原先字符串以在取消标记时使用
        str = def[str];
        std::tuple<std::string, bool, int> getReads = std::make_tuple("", true, 0);
        int len = str.length();
        std::vector<std::string> vec;
        while (std::get<2>(getReads) < len) {
            getReads = reads(str, std::get<2>(getReads));
            vec.push_back(std::get<0>(getReads));
        }
        for (std::string each : vec) solve(each);
        vis[src] = false;
    } else std::cout << str;
}

int main() {
    std::cin.tie(0);
    std::cout.tie(0);

#ifndef XEDEBUG
    freopen("preprocessor.in", "r", stdin);
    freopen("preprocessor.out", "w", stdout);
#endif

    int n;

    std::cin >> n;
    std::cin.ignore();

    for (int i = 1; i <= n; i++) {
        std::string str;
        std::getline(std::cin, str);
        std::tuple<std::string, bool, int> getReads = std::make_tuple("", true, 0);
        int len = str.length();

        while (std::get<2>(getReads) < len) {
            getReads = reads(str, std::get<2>(getReads));

            if (std::get<1>(getReads)) {
                vis.clear();
                for (auto each : def) vis[each.first] = false;
                solve(std::get<0>(getReads));
            } else if (std::get<0>(getReads) == "#") {
                getReads = reads(str, std::get<2>(getReads));
                if (std::get<0>(getReads) == "define") {
                    std::pair<std::string, int> from = readDef(str, std::get<2>(getReads));
                    std::string to = str.substr(from.second + 1);
                    def[from.first] = to;
                    getReads = std::make_tuple(to, true, len);
                } else if (std::get<0>(getReads) == "undef") {
                    std::string from = str.substr(std::get<2>(getReads) + 1);
                    def.erase(from);
                    getReads = std::make_tuple(from, true, len);
                } else {
                    std::cout << "#";
                    getReads = std::make_tuple("#", false, std::get<2>(getReads) + 1);
                }
            } else std::cout << std::get<0>(getReads);
        }

        std::cout << "\n";
    }

#ifndef XEDEBUG
    fclose(stdin);
    fclose(stdout);
#endif

    return 0;
}
```

---

## 作者：__vector__ (赞：4)

## 前言：  
这道题是省选的签到题，然而我交了很多遍才 AC  
## 题目注意事项：  
1. ```#define <name> <content>``` 中的 ```content``` 可以为空  

2. 连续在一起的大小写字母和**数字以及下划线**应该视作同一个标识符  

## 题目做法：  
### 读入：  
这里的读入有亿些坑，在此说一下
读入 $n$ 之后，应该使用 ```getchar``` 来吸收换行符，不然会挂。  
读入每一行的字符串时，可以这样读入：  
```cpp
fgets(line, maxn, stdin);
//line是临时存储每一行字符串的char数组
//maxn是数组大小
```  
至于如何读入宏，首先可以使用 ```sscanf``` 从 ```line``` 数组将开头的 ```#define``` 或 ```#undef```，以及宏名读入，具体如下：  
```cpp
sscanf(line,"%s%s",define.tmp,define.name);
//define.tmp 是 "#define" 或 "#undef"
//define.name 是宏名
```  

最后的宏的内容，也就是 ```content```，应该从预处理指令的前两个单词的末尾的向后两个位置开始依次一个一个的读入每个字符。具体如下：  
```cpp
for(int i=ttmp,cnt=0;i<size_line;i++,cnt++)
{
	if(line[i]=='\n')break;
	define.val[cnt]=line[i];
   	//define.val 是宏的内容(content)
   	//ttmp 是预处理命令的前两个单词的末尾的向后两个位置
   	//也就是预处理命令第三个单词开始的位置
   	//size_line 是 line数组的大小
}
```  
之所以不能直接读入是因为**宏的内容 content 可以为空**。  
### 宏的存储  
因为 ```map``` 的复杂度是 $O(logn)$，容易被卡，最好用 ```unordered_map```，这样复杂度是 $O(1)$ 的，因为 ```map``` 用的是红黑树，```unordered_map``` 用的是哈希表。  
定义一个 ```unordered_map``` 来存储每个宏名替换之后的内容：  
```
unordered_map<string,string> def;
```  
然后 ```def[name]=content``` 就行了  
### 宏的展开  
注：```line``` 数组是临时存储每一行字符串的。此时 ```string ans``` 用来存储答案。  
遍历 ```line``` 数组，按照题目要求找标识符。找到一个标识符，首先判断它是不是一个有效的宏名，如果不是，那么 ```ans``` 直接加上这个标识符即可，如果它是一个有效的宏名，那么对其进行展开之后 ```ans``` 再加上它，下面来说一下如何进行展开。  

因为一个宏展开之后可能还需要继续展开，这样就很麻烦，使用 dfs 可以方便的进行递归展开。来说一下怎么 dfs：  

定义：```string dfs(string hong)```  

其中 dfs 的返回值是宏展开之后的字符串，```hong``` 是待展开的宏名。  

递归到某个宏，首先把这个宏变成这个宏第一次展开之后的字符串，也就是 ```hong = def[hong]```，并定义一个临时数组 ```string str``` 来存储当前宏完全展开之后的最终字符串，遍历 ```hong``` 数组，查找每一个标识符，如果这个标识符 ```name``` 是一个有效的宏名，那么对其 dfs 递归展开：```str+=dfs(name)```，否则直接加入 ```str``` 数组。  
最后返回 ```str``` 数组。

那么如何处理无线递归展开呢？  
可以定义一个 ```unordered_map<string,bool> vis``` 来记录当前递归正在展开的宏名，每递归到一个宏名 ```name```，就将这个宏名记录下来：```vis[name]=1```，如果发现当前宏名与某个正在展开的宏名相同，也就是 ```if(vis[name]==1)```，那么当前宏名不作展开，直接把宏名返回即可。  
### AC 代码：  
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <vector>
using namespace std;
namespace Main
{
	const int maxn=105;
	int n;
	char line[maxn];
	unordered_map<string,string> def;
	int size_line;
	struct Define
	{//用来临时存储正在读入宏的信息
		char tmp[10];
		char name[maxn];
		char val[maxn];
	}define;
	string ans_line;//存储每个蒲通文本宏展开后的样子
	string temp;
	unordered_map<string,bool> vis;
	bool isletter(char s)
	{
		if(isdigit(s))return 1;
		if(s=='_')return 1;//注意数字和下划线与字母一起组成标识符
		if(s-'a'>=0&&s-'a'<26)return 1;
		if(s-'A'>=0&&s-'A'<26)return 1;
		return 0;
	}
	string dfs(string hong)
	{
		string ttttmp=hong;//临时存储原来的宏名
		hong=def[hong];//把hong 变成其一次展开后的样子
		if(vis[ttttmp])return ttttmp;
		//如果与正在进行展开的某个宏名相同，返回
		vis[ttttmp]=1;
		string str="";
		string temp="";//存标识符
		for(int i=0;i<hong.size();i++)
		{
			if(hong[i]=='\n')break;
			//	cout<<"temp: "<<temp<<endl;
			if(isletter(hong[i]))
			{
				temp+=hong[i];
			}
			else
			{
				if(def.count(temp))
				{//连续字母结束，处理一下宏
					//不要忘记读入完整个字符串之后还要展开一下temp
					str+=dfs(temp);
				}
				else
				{
					str+=temp;
				}
				temp=hong[i];
				if(def.count(temp))
				{//如果当前文本是一个宏，替换一下
					str+=dfs(temp);
				}
				else
				{//不是宏，不做处理
					str+=temp;
				}
				temp="";
			}
		}
		if(def.count(temp))
		{
			str+=dfs(temp);
		}
		else
		{
			str+=temp;
		}
		vis[ttttmp]=0;
		return str;
	}
	void main()
	{
		cin>>n;
		getchar();
		while(n--)
		{
			fgets(line, maxn, stdin);
			size_line=strlen(line);
			if(line[0]=='#')
			{//预处理指令
				sscanf(line,"%s%s",define.tmp,define.name);
				int ttmp=strlen(define.tmp)+strlen(define.name)+2;
				memset(define.val,0,sizeof(define.val));
				for(int i=ttmp,cnt=0;i<size_line;i++,cnt++)
				{
					if(line[i]=='\n')break;
					define.val[cnt]=line[i];
				}
				if(define.tmp[1]=='d')
				{
					def[define.name]=define.val;
				}
				if(define.tmp[1]=='u')
					def.erase(define.name);//#undef
				putchar('\n');
				continue;
			}
			else
			{//蒲通文本
				ans_line="";
				temp="";
				for(int i=0;i<size_line;i++)
				{
					if(line[i]=='\n')break;
					//	cout<<"temp: "<<temp<<endl;
					if(isletter(line[i]))
					{
						temp+=line[i];
					}
					else
					{
						if(def.count(temp))
						{//连续字母结束，处理一下宏
							//不要忘记读入完整个字符串之后还要展开一下temp
							ans_line+=dfs(temp);
						}
						else
						{
							ans_line+=temp;
						}
						temp=line[i];
						if(def.count(temp))
						{//如果当前文本是一个宏，替换一下
							ans_line+=dfs(temp);
						}
						else
						{//不是宏，不做处理
							ans_line+=temp;
						}
						temp="";
					}
				}
				if(def.count(temp))
				{
					ans_line+=dfs(temp);
				}
				else
				{
					ans_line+=temp;
				}
				cout<<ans_line<<endl;
			}
		}
	}

}
int main()
{
	Main::main();
	return 0;
}
```


---

## 作者：孤芒星河233 (赞：3)

这是蒟蒻的第一篇题解 qwq，希望能帮到大家

~~虽然大模拟似乎帮不到什么忙~~

[洛谷链接](https://www.luogu.com.cn/problem/P8289)
# 题解
读入 **n** 行字符串，每行除行末的换行符外，均由 **可打印** ASCII 字符（ASCII 码范围 32 ~ 126 ）组成。每行要么是预处理命令（以 # 开头），要么是普通文本（其他情况）

读入可以这样写
```cpp
scanf("%d",&n);
getchar();//去掉第一行末尾的换行符
for(int i=1;i<=n;i++){
	getline(cin,s[i]);
}
```
我们将输入的字符串分为以下 **三种情况**

### 1. 宏定义命令
```
#define <name> <content>
```
  题面说的很清楚，所以只说一下重点
  - `<name>` 由 **标识符** 组成（标识符只包括由 **大小写字母** 和 **数字** 以及 **下划线** 组成的单个字符或字符串）
  
  - `<content>` 可以包含 **任意可打印** ASCII 字符（零个或多个字符）
  
  - 最后还要输出换行符！
  
  我们可以通过 **前两个字符** 是否为 **'#'和'd'** 来判断是否为宏定义命令
  ```cpp
hd="";
hd+=s[i][0];
hd+=s[i][1];//前两个字符
//宏定义
if(hd=="#d"){
    p=8;tol++;//直接从第9个字符读起
    while(s[i][p]!=' '){//全是标识符，读到空格就停
        part+=s[i][p];
        p++;
    }
    ex[tol]=part;//宏名
    p++;
    part="";//清除 part
    while(p<len){//替换字符串
        part+=s[i][p];
        p++;
    }
    bef[tol]=part;//替换内容
    putchar('\n');//别忘了换行符
  ```
### 2.取消宏定义
```
#undef <name>
```
  删除的时候可以直接把`ex[]`中的字符替换为"##"，这样就无法对应了，之后的展开中就不需要管它了  ~~懒人删除法~~
```cpp
else if(hd=="#u"){
    p=7;//从第8个字符读起
    while(p<len){//直接读完
        part+=s[i][p];
        p++;
    }
    for(int j=1;j<=tol;j++){
        if(ex[j]==part){
            ex[j]="##";//删除操作
            break;
        }
    }
 	putchar('\n');
}
```
### 3.替换字符串
我们来看一个比较简单的样例（没有无限递归展开）
```
3
#define a bc+c
#define c b
a
```
我们读入了第四行的 **a** ，然后发现它被宏定义过，替换为 **bc+c**。这时，我们发现有 **bc** 和 **c** 两个标识符，**c** 可再次被替换为 **b**
于是我们得到了最后的结果: **bc+b**

![2DGY4.png](https://s1.328888.xyz/2022/04/22/2DGY4.png)

所以我们可以利用**函数的递归**来替换每个被宏定义了的标识符。

那么如何判断无限递归展开呢？由于递归是一级一级的，我们只需要将当前要被替换的部分于前几级已经被换掉的部分作对比即可，之前被替换过的部分便不再替换。

代码分为以下部分
- 判断标识符
 ```cpp
bool check(char c){
    return (c>='a'&&c<='z')||(c>='A'&&c<='Z')||(c>='0'&&c<='9')||(c=='_');
}
```
- 判断该字符串是否被替换过
```cpp
bool check_det(string s,int num){//num 表示递归的层数
    for(int i=1;i<num;i++){
        if(s==fold[i]) return false;//fold[]是之前展开过的标识符
    }
    return true;
}
```
- 递归替换字符串
```cpp
string unfold(string s,int num){//num 是递归层数
    int p=0,len=s.size();string part,all;
    while(p<len){
        while(check(s[p])){//标识符部分
            part+=s[p];
            p++;
        }
        if(part!=""){
            if(check_det(part,num)){//没被替换过
                for(int i=1;i<=tol;i++){
                    if(part==ex[i]){
                        fold[num]=part;
                        part=unfold(bef[i],num+1);
                        break;
                    }
                }
            }
            all+=part;
            part="";
        }
        if(p<len) all+=s[p];//不是标识符不用处理，直接加进来
        p++;
    }
    return all;
}
```
最后直接调用函数即可
```cpp
cout<<unfold(s[i],1)<<endl;
```
## END

---

## 作者：yizhiming (赞：2)

# 关于签到题是大模拟这件事

## 题目链接 

[$\texttt{Link}$](https://www.luogu.com.cn/problem/P8289)。

## 题面描述
给定 $n$ 行操作，对于每一行，有两种情况：

- 当前行开头为 `#` 表示该行为需要执行的命令，形式分为

`# define <name> <content>` 表示将 `<name>` 所表示的内容改为 `<content>`，即 `c++` 中的宏定义。
  
`#undef <name>` 表示将 `<name>` 的上一个宏定义撤销。
  
两种情况的各部分都严格用一个空格隔开，都要在最后输出回车。
  
- 当前行开头没有 `#` 的普通文本。操作为将其根据宏定义改变后输出。

## 特殊限制及坑点

数据保证宏定义合法，也就是说不会删除一个未定义的宏。不需要我们特意去进行判错（良心耶）。
  
对于 `<name>`，它仅会包含大小写字母、数字和下划线，但是  `<content>` 包含所有字符，也就是说还包含空格。
  
对于普通文本，能够识别标识符是一段连续的大小写字母、数字或下划线，比如说，对于 `A+B` 而言，能够进行宏展开的仅有 `A` 和 `B`。
  
关于宏展开，是可以嵌套下去的，比如：

```pascal
#define a b
#define b c
```
  
则对于输入的 `a` 代码块，会输出 `c`，这样自然而然就会出现无限嵌套的情况，所以钦定，若一个宏正在展开，则后续再次遇见便不会展开。例如：
  
```pascal
#define a b
#define b a
```
  
输入 `a` 则会输出 `b` 。
  
## 大体思路
  
对于每个 `<name>` 有其对应的 `<content>`，所以我们可以用 $\texttt{map}$ 来实现这一对应。
  
## 具体实现

我们可以定义 `map<string,string>words;`。表示每个字符串串换成了什么字符串，这样字符串的对应就轻松解决了，当然本体难点不在这里。

首先考虑输出，题面非常的良心，给了输入提示：
 
 ```cpp
string line;
// 从 cin 读入一行，放入 line 中（换行符被舍弃）
getline(cin, line);
```
这样我们就将每行的输入（包括空格）存到了 $\texttt{line}$ 这个变量里。
  
题面的温馨提示也一定要注意，读入完  $n$ 后不要忘记再 $\texttt{getline}$ 一次。 
  
考虑怎么处理，首先对于 `#` 情况，我们要想办法将 `<name>` 和 `<content>` 取出，我这里用的方法是写一个返回值为 $\texttt{string}$ 的函数：
  
```cpp
string find1(int x){//表示从x位置开始到第一个空格为止所表示的字符串,用来读第一种<name>
	char ch[N];
	memset(ch,0,sizeof(ch));//注意这里如果不清零初值会出问题
	int tot=0;
	while(line[x+tot]!=' '){
		ch[tot] = line[x+tot];
		tot++;
	}
	string s(ch);//string的赋值方式的一种，不知道为啥直接用string会锅
	return s;
}
string find2(int x){//表示从x位置到该行最后，用来读第二种<name>和<content>
	char ch[N];
	memset(ch,0,sizeof(ch));
	int tot=0;
	if(line[x+tot]==32){//32是空格，要越过去
		x++;
	}
	int z = line.length();
	while(x+tot<=z){//注意<content>要读到最后
		ch[tot] = line[x+tot];
		tot++;
	}
	string s(ch);
	return s;
}
```
那么我们现在就完成了对 `#` 的存储，那具体操作直接放代码相信大家都看得懂:
  
 ```cpp
if(line[0]=='#'){
		if(line[1]=='d'){
			string s = find1(8);//#define 占8个字符(包括空格）,所以从第8个(字符串索引值从0开始)往后找
			string x = find2(8+s.length());//要从<name>后面开始找
			words[s] = x;//一一对应
			vis1[s]=1;//该数组用来记录s是否有对应的宏展开
		}else{
			string s = find2(7);//#undef 同上
			vis1[s]=0;
		}
	}
```
终于到了最关（e）键（xin）的一步输出。
  
老规矩还是写成函数（工整.jpg）
  
我们考虑对于一个字符，当什么条件下才可以直接被输出，是没有对应的宏展开吗？并不对，举个例子:
  
```pascal
#define A a
#define B b
```
显然 `A+B` 这玩意没有与之对应的宏定义，但是根据之前所说，该字符串中的代码块应该是 `A`和 `B` 所以，我们对于每一个字符串，要先将它拆成几段连续的由大小写字母、数字或下划线组成的字符串，中间由其它字符连接，若这几段都不能再展开，才说明可以直接输出。

再考虑一个字符串什么时候应该展开，根据题面我们可以注意到，即便当它有对应的宏定义时，如果之前有相同的宏正在展开，就不能继续展开防止无限循环，这种东西可以通过递归写法，每次递归下一层前，将使用的宏定义打上标记。所以可以再开个 $\texttt{map}$ 来记录当前正在展开的宏。
  
这一部分的代码：
  
### Part1

```cpp
map<string,bool>vis2;//vis2数组用来表示当前s表示的宏是否在展开
void chu(string s){ 
	if(pan(s)){//见下一部分代码
		cout<<s;
		return;
	}
	if(vis1[s]&&!vis2[s]){
		vis2[s] = 1;
		chu(words[s]);
		vis2[s] = 0;//递归写法当s展开完以后要将其标为可展开
	}else{
		int tot=0;char ch[N];int z = s.length();
		memset(ch,0,sizeof(ch));//跟find同理
		for(int i=0;i<z;i++){
			if((s[i]>='a'&&s[i]<='z')||(s[i]>='A'&&s[i]<='Z')||(s[i]=='_')){
				ch[tot] = s[i];
				tot++;
			}else{
				if(tot>0){
					string ss(ch);
					memset(ch,0,sizeof(ch));
					chu(ss);//递归下去直至能输出。
					tot = 0;
				}
				cout<<s[i];
			}
		}
		if(tot>0){//注意有可能字符串的后缀都由大小写字母、数字、下划线构成，所以要特判一下。
			string ss(ch);
			chu(ss);
		}
	}
}
```
### Part2
  
```cpp
bool pan(string s){//检查该字符串是否能够直接输出
	if(vis1[s]&&!vis2[s]){//注意如果当前s已经展开了即使有对应宏定义也不意味着不能够直接输出
		return false;
	}
	int z = s.length();
	for(int i=0;i<z;i++){
		if((s[i]>='a'&&s[i]<='z')||(s[i]>='A'&&s[i]<='Z')||(s[i]=='_')){
			//这里偷个懒不改成否定的形式
		}else{
			return false;
		}
	}
	return true;
}
```
                                                             
一切准备就绪，就差最后完整的代码了：
                                    
## Code:
                                             
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cmath>
#include <map>
using namespace std;
const int N = 110;
string line;
map<string,string>words;
map<string,bool>vis1;
map<string,bool>vis2;//vis2数组用来表示当前s表示的宏是否在展开
string find1(int x){//表示从x位置开始到第一个空格为止所表示的字符串
	char ch[N];
	memset(ch,0,sizeof(ch));//注意这里如果不清零初值会出问题
	int tot=0;
	while(line[x+tot]!=' '){
		ch[tot] = line[x+tot];
		tot++;
	}
	string s(ch);//string的赋值方式的一种，不知道为啥直接用string会锅
	return s;
}
string find2(int x){//表示从x位置到该行最后
	char ch[N];
	memset(ch,0,sizeof(ch));
	int tot=0;
	if(line[x+tot]==32){//32是空格，要越过去
		x++;
	}
	int z = line.length();
	while(x+tot<=z){//注意<content>要读到最后
		ch[tot] = line[x+tot];
		tot++;
	}
	string s(ch);
	return s;
}
bool pan(string s){//检查该字符串是否能够直接输出
	if(vis1[s]&&!vis2[s]){//注意如果当前s已经展开了即使有对应宏定义也不意味着不能够直接输出
		return false;
	}
	int z = s.length();
	for(int i=0;i<z;i++){
		if((s[i]>='a'&&s[i]<='z')||(s[i]>='A'&&s[i]<='Z')||(s[i]=='_')){
			//这里偷个懒不改成否定的形式。
		}else{
			return false;
		}
	}
	return true;
}

void chu(string s){ 
	if(pan(s)){//见下一部分代码
		cout<<s;
		return;
	}
	if(vis1[s]&&!vis2[s]){
		vis2[s] = 1;
		chu(words[s]);
		vis2[s] = 0;//递归写法当s展开完以后要将其标为可展开
	}else{
		int tot=0;char ch[N];int z = s.length();
		memset(ch,0,sizeof(ch));//跟find同理
		for(int i=0;i<z;i++){
			if((s[i]>='a'&&s[i]<='z')||(s[i]>='A'&&s[i]<='Z')||(s[i]=='_')){
				ch[tot] = s[i];
				tot++;
			}else{
				if(tot>0){
					string ss(ch);
					memset(ch,0,sizeof(ch));
					chu(ss);//递归下去直至能输出。
					tot = 0;
				}
				cout<<s[i];
			}
		}
		if(tot>0){//注意有可能字符串的后缀都由大小写字母、数字、下划线构成，所以要特判一下。
			string ss(ch);
			chu(ss);
		}
	}
}


void init(){
	if(line[0]=='#'){
		if(line[1]=='d'){
			string s = find1(8);//#define 占8个字符(包括空格）,所以从第8个(字符串索引值从0开始)往后找
			string x = find2(8+s.length());//要从<name>后面开始找
			words[s] = x;//一一对应
			vis1[s]=1;//该数组用来记录s是否有对应的宏展开
		}else{
			string s = find2(7);//#undef 同上
			vis1[s]=0;
		}
	}
    else{
		chu(line);
	}
}
int n;
int main(){
	cin>>n;
	getline(cin,line);
	for(int i=1;i<=n;i++){
		getline(cin,line);
		init();
		if(i<n){
			cout<<"\n";
		}
	}
	return 0;
}

```
说句闲话，我没参加联合省选，SD的跪求SDOI别寄——
  
$The$ $end$

---

## 作者：WeLikeStudying (赞：2)

- 对自身的问题有了新的体会。
- 同志们加油，光明的未来等着你们。

**题意**
- [题目](https://www.luogu.com.cn/problem/P8289)。
- 对文本提供字符串替换工作。
- 注意真实的预处理器比这复杂许多。

**分析**
- 面对这样的数据，我们通常分两步，第一步是打出一个正确的代码，第二步是优化。
- 那么可以将方便用的函数全都封装起来。
```cpp
// 一些常用的已有函数比如 isalpha isdigit 和 x.substr 这里不再实现。
bool istxt(char x)
{
	return isalpha(x)||isdigit(x)||x=='_';
}
bool ismrc(const string &x)
{
	return x[0]=='#';
}
int txtpos(const string &x,int id)
{
	while(id<x.size()&&istxt(id))++id;
	return id;
}
```
- 然后，我们需要存储所有的宏来查询，而且还需要存储之前所有已经有过的宏来避免死循环，这里可以简单地用 $\text{map}$。
```cpp
map<string,string>mrc;
set<string>hav; 
```
- 有了这些东西，代码的实现就简洁了。
- 下面是处理宏的代码，也就是判断宏是定义还是取消，加入宏库内：
```cpp
void solvemrc(const string &x)
{
	if(x[1]=='d')
	{
		int l=8,r=txtpos(x,l);
		mrc.insert(make_pair(x.substr(l,r-l),x.substr(r+1,x.size()-r-1)));
	}
	else mrc.erase(x.substr(7,x.size()-7));
}
```
- 下面是处理字符串的代码，通过递归，保存以前用过的宏来防止无限递归。
```cpp
void solvetxt(const string &x)
{
	for(int l=0,r=0;l<x.size();l=r)
	{
		while(r<x.size()&&!istxt(x[r]))++r;
		cout<<x.substr(l,r-l);l=r;
		r=txtpos(x,l);
		string nam=x.substr(l,r-l);
		if(mrc.count(nam)&&!hav.count(nam))
		{
			hav.insert(nam);
			solvetxt(mrc[nam]);
			hav.erase(nam);
		}
		else cout<<nam;
	}
}
```
- 最终代码非常简短非常好写，但是它无情地[超时](https://www.luogu.com.cn/record/74178856)了，因为我们在对字符串处理的时候非常地暴力，可能达到 $100\times 1000^2$ 级别，然后带个 $\text{log}$ 就被卡常了。

**优化**
- 可以尝试如下方法来卡常：
- 字符串可以用 $\text{Trie}$ 来或者哈希表存储，这样暴力基本可以过。
- 将非常没用的函数展开或者变成宏，[最终代码](https://www.luogu.com.cn/record/74179185)，它说明暴力复杂度是可过的，[哈希表的实现](https://www.luogu.com.cn/record/74179365)。
- 但是本题的题目叫优化不叫卡常，所以存在一个引自[这位](https://www.luogu.com.cn/user/52881)和[这位](https://www.luogu.com.cn/user/69288)大佬的实现（**已经证明是错误的，大家不要学**）：
- 我们发现除了一开始的字符串处理，后续的字符串处理都是重复地对已有的宏替换进行更改，它完全可以记忆化以避免大量不必要的查询，最坏复杂度会有一个质的飞越。
- [实现](https://www.luogu.com.cn/record/74182141)，总用时 $33$ 毫秒，甚至是目前最优解，比 $\text{hack}$ 数据添加之前的提交都跑得快，这令人疑惑。
- 当然，现在官方数据添加后就不是这样了，那个朴素的记忆化会出现问题，[hack 数据](https://www.luogu.com.cn/paste/asy8zfd7)，作者感到抱歉却无可奈何，显然的原因是作者没有实现完整的记忆化，导致出错。

---

## 作者：FjswYuzu (赞：2)

不妨仍然按讲大模拟的思路来，实际上这个题在码的难度上比儒略历不知道低到哪里去了。

首先输入问题题目已经帮我们解决了。接下来对于一个宏，我们先求出这个宏的名字。这个宏的名字只包含**数字，大小写字母，下划线**。这样先摆出一个函数 `isName(char)` 来确定一个字母是否属于一个宏的名字。

```cpp
inline bool isName(char c)
{
	if(c=='_')	return true;
	if(c>='A' && c<='Z')	return true;
	if(c>='a' && c<='z')	return true;
	if(c>='0' && c<='9')	return true;
	return false;
}
```

然后考虑 `#define` 命令。我们先判断是否是一个 `#define` 操作，具体是看命令第一个字符是不是 `#`，然后第二个字符是不是 `d`（因为标识符不含 `#`，出现 `#` 一定是 `#define` 或者 `#undef`）。然后知道 `#define <name> <content>` 命令间一定有一个空格，我们可以找到这个空格的位置，下一个就是 `<name>` 的第一个字符。求出以这个字符开头的连续极长的大小写字母和数字以及下划线构成的字符串就是 `<name>`。然后给每个宏分配一个编号，用 `map` 存下这个 `<name>` 对应的编号。剩下还没有处理的部分就是这个宏对应的内容，用一个字符串数组存下。

接下来是 `#undef`。一样的方法求出 `<name>`，然后在 `map` 里面找到并且删掉就好了。注意到这样的话我们确定一个标识符是否是宏就要用 `map` 去判断这个字符串是否对应一个宏编号了。

最后就是输出部分。将整行看做一个命令，一个宏也就对应的一个命令。考虑递归处理，用数组记录处理当前的命令时，是否也是在处理某一个宏的过程（为了防止一直递归，同时满足题意）。记 `void Print(string S,int i)` 表示我们处理到字符串 $S$ 的第 $i$ 个字符。流程如下：

- 如果 $i$ 已经达到或超过了 $S$ 的长度，返回即可；   
- 否则：
  - 判断 $S$ 的第 $i$ 个字符是否是一个标识符字符，如果不是直接输出即可；   
  - 否则找到这个极长标识符，判断其是否是一个没有正在处理的宏。是则递归处理，否则直接输出。

处理完当前这个标识符之后，我们移动 $i$ 到这个标识符的下一个字符，递归处理。

写出一份逻辑清晰的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
map<string,int> M;
string s[105];
int n;
inline bool isName(char c)
{
	if(c=='_')	return true;
	if(c>='A' && c<='Z')	return true;
	if(c>='a' && c<='z')	return true;
	if(c>='0' && c<='9')	return true;
	return false;
}
string def[105];
int cnt;
void Define(string S)
{
	int i=0;
	while(S[i]!=' ')	++i;
	++i;
	string str;
	while(isName(S[i]))	str.push_back(S[i]),++i;
	M[str]=++cnt;
	++i;
	int len=S.length();
	for(;i<len;++i)	def[cnt].push_back(S[i]);
}
void Undef(string S)
{
	int i=0;
	while(S[i]!=' ')	++i;
	++i;
	string str;
	int len=S.length();
	for(;i<len;++i)	str.push_back(S[i]);
	M.erase(M.find(str));
}
bool ins[105];
void Print(string S,int i)
{
	if(i==int(S.length()))	return ;
	if(!isName(S[i]))
	{
		cout<<S[i];
		Print(S,i+1);
		return ;
	}
	string str;
	while(isName(S[i]))	str.push_back(S[i++]); // 这里 在 C++98 标准下会 RE，但是在 C++14 的时候，i==S.length() 会返回 npos，所以不会挂。
	if(M.find(str)!=M.end())
	{
		int d=M[str];
		if(!ins[d])	ins[d]=true,Print(def[d],0),ins[d]=false;
		else	cout<<str;
	}
	else	cout<<str;
	Print(S,i);
}
int main(){
	cin>>n;
	getline(cin,s[0]);
	for(int i=1;i<=n;++i)	getline(cin,s[i]);
	for(int i=1;i<=n;++i)
	{
		if(s[i][0]=='#')
		{
			cout<<endl;
			if(s[i][1]=='d')	Define(s[i]);
			else	Undef(s[i]);
		}
		else	Print(s[i],0),cout<<endl;
	}
	return 0;
}
```

---

## 作者：hukk (赞：1)

这是一道模拟题，如果用 C++ 的 STL 写还是比较简单的，具体实现看代码及注释即可。

代码中用到了 `stringstream` 和 STL 中的一些模板，大家可以自行查阅其用法。

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,string> macros; //存储宏定义
string line;
int n;
void init(){ //吃掉第一行
    getline(cin,line);
    stringstream ss(line);
    ss>>n;
}
string work(const string &line,map<string,bool> &used){ //递归实现多次展开
    //line：将进行展开的串；used：记录已经展开的宏
    string ans;
    unsigned int i=0; //标记位置
    while(1){
        string labal; //用来找标识符
        for(;i<line.size();i++){
            if(isalpha(tolower(line[i]))||line[i]=='_'||isdigit(line[i])){ //判断：是否可组成标识符
                labal+=line[i];
            }
            else{ //空字符
                if(!macros.count(labal)){ //不是宏
                    ans+=labal;
                }
                else if(!used[labal]){ //是宏且未展开
                    used[labal]=1; //标记为展开状态
                    ans+=work(macros[labal],used); //多次展开
                    used[labal]=0; //回溯，取消标记 
                }
                else{ //已经展开
                    ans+=labal;
                }
                ans+=line[i]; //加上当前字符（空字符）
                i++;
                labal=""; //标识符清空 
                break; //每处理一个标识符或遇到空字符就退出循环
            }
        }
        if(labal!=""&&i>=line.size()){ //扫尾，代码同上
		    //此时情况：有未处理的标识符
            if(!macros.count(labal)){
                ans+=labal;
            }
            else if(!used[labal]){
                used[labal]=1;
                ans+=work(macros[labal],used);
                used[labal]=0;
            }
            else{
                ans+=labal;
            }
        }
        if(i>=line.size()) break; //处理完毕
    }
    return ans; //已经展开的串
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    init();
    for(int i=1;i<=n;i++){
        getline(cin,line);
        if(line[0]=='#'){ //预处理指令
            stringstream ss(line);
            if(line[1]=='d'){ //define
                pair<string,string> smc;
                char c;
                ss>>smc.first>>smc.first>>smc.second;
                while(ss.get(c)){ //读取每一个字符
                    smc.second+=c;
                }
                macros[smc.first]=smc.second;
            }
            else{ //undef
                string ud;
                ss>>ud>>ud;
                macros[ud]=ud; //直接将已删除的宏定义为自身
            }
            cout<<'\n';
        }
        else{ //不是预处理指令
            map<string,bool> used;
            cout<<work(line,used)<<'\n'; //执行展开
        }
    }
    return 0;
}
```

---


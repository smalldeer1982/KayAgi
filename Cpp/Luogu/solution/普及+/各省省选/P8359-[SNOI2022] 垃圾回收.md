# [SNOI2022] 垃圾回收

## 题目描述

通常的情况下，编程语言在管理内存时进行如下的选择：

- 让用户进行手动内存管理（C、C++、Rust 等），这会收获很好的性能，但是给用户提供了很大的编程负担。
- 使用垃圾回收系统（Java、Go 等），这需要维护一个运行时系统，并且在内存使用和程序性能方面造成了许多不可预测的负担。

尽管存在许多的问题，目前最通用的自动化内存管理手段始终为 Tracing Garbage Collector。这种做法的最基础的思路是维护对象间的引用关系，形成一张图，每次回收时通过扫描引用关系推导出已经无法被访问到的对象，释放它们占用的内存。而这种传统的做法最大的问题在于维护引用链需要造成很大的开销，并且随着维护的对象越多，扫描的代价也会越大。

小 L 是一个喜欢思考的女孩子，她发现维护 Garbage Collector 是一件非常复杂的事情，于是她决定考虑一个更简单的模型（注意它与任何现实中的 GC 规则可能是完全不同的！）。


对于一个 $n$ 个点 $m$ 条边的无向图，没有重边自环，点和边均从 $1$ 开始标号。其中每个节点代表一个占用了一定内存的对象，每条边对应一个引用关系（注意这里的引用关系是**无向**的），程序从第 $0$ 秒开始运行，在第 $q + 1$ 秒结束运行。对于 $i = 1, 2, 3, \dots, q$ 的每个时刻 $i$ 发生以下两种操作之一：

- DELETE $i$，删除边 $(x_i,y_i)$，保证不会删除已经被删除的边。
- GC， 进行一次内存回收，即杀死所有从起点出发不能访问到的点，释放它们占用的内存。（注意这里对节点的删除不会删除与这些点相连的边）

你可以认为这些操作是被瞬间执行完成的，在所有操作执行后，也就是第 $q + 1$ 秒，程序结束，删除所有剩余的节点（包括 $1$ 号点）。

第 $i$ 个点占用的内存为 $a_i$，现在请你求出 $\sum_{i = 1}^{n} a_i \cdot \mathit{alive}_i$，这里 $\mathit{alive}_i$ 表示第 $i$ 个点存活的时间，在第 $0$ 秒，所有节点都是存活的。

## 说明/提示

**【样例 1 解释】**

在第 $4$ 秒时，节点 $5$ 被删除。

在第 $6$ 秒时，节点 $2, 3$ 被删除。

在第 $9$ 秒时，节点 $1, 4, 6$ 被删除。

答案即 $5 \times 4 + (2 + 3) \times 6 + (1 + 4 + 6) \times 9 = 20 + 30 + 99 = 149$。

**【数据规模与约定】**

对于全部数据，$1 \leq n, m, q \leq 4 \times 10^5$，$1 \leq a_i \leq 10^8$。

具体的数据规模与约定见下表。

| 测试点编号 | $n$ | $m$ | $q$ | 特殊限制 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1 \sim 2$ | $\leq 500$ | $\leq 500$ | $\leq 500$ |   |
| $3 \sim 5$ | $\leq 3000$ | $\leq 3000$ | $\leq 3000$ |  |
| $6 \sim 10$ | $\leq 5000$ | $\leq 5000$ | $\leq 5000$ |  |
| $11 \sim 14$ | $\leq 2 \times 10^5$ | $n-1$ | $\leq 2 \times 10^5$ | 保证一开始图是一棵树 |
| $15 \sim 16$ | $\leq 2 \times 10^5$ | $\leq 2 \times 10^5$ | $\leq 2 \times 10^5$ |  |
| $17 \sim 20$ | $\leq 4 \times 10^5$ | $\leq 4 \times 10^5$ | $\leq 4 \times 10^5$ |  |

## 样例 #1

### 输入

```
6 6 8
1 2
2 3
2 4
1 4
2 5
1 6
GC
DELETE 5
DELETE 3
GC
DELETE 1
GC
DELETE 2
GC
1 2 3 4 5 6
```

### 输出

```
149
```

## 样例 #2

### 输入

```
样例 2 见附件 garbage2.in
本组数据满足测试点 6 的限制。```

### 输出

```
样例 2 见附件 garbage2.ans```

## 样例 #3

### 输入

```
样例 3 见附件 garbage3.in
本组数据满足测试点 11 的限制。```

### 输出

```
样例 3 见附件 garbage3.ans```

# 题解

## 作者：LXYYDS (赞：13)

# 题意：

-----

给定一个~~五香~~无向图。

每个节点  $i$  有两种属性  $a_i$  以及  $alive_i$。

其中  $a_i$  题目中给出，  $alive_i$  初始值为  $0$。

对五香图进行以下两种操作：

1. 删除一条边。

2. 对于每个  $^{1.}$ 与起点（编号为  $1$  的节点）不连通，  $ ^{2.} alive$ 值为 $0$ 的点  $i$  ，将  $alive_i$ 的值改为当前时间戳（当前操作的编号）

共  $q$  种操作，编号为  $1 \to q$。

所有操作执行完后，将剩余的  $ alive $  值为  $0$  的点的  $alive$  改为  $q + 1$。
求：
$$\sum_{i=1}^na_i \cdot alive_i$$

-----


# 暴力

-----

显然我们有暴力做法：

对于每条边额外记录一个类型为  bool 的值，表示这条边的状态（ $0$ 表示未删除， $1$ 表示已删除）。

经过上述变换后，可以拿一半的分数。~~物美价廉，岂不美哉！~~

# 正解 
-----

对于暴力做法，我们将删边时间变为  $O(1)$ ，改值时间则为  $O(n)$。

由此可见，改值操作时间过长，所以，我们希望优化。

观察数据范围可知，本题时间复杂度应为  $O(n \cdot \log_2n)$ 或 $O(n)$。

感性理解，应为数据结构。

此时我们要有 **逆向思维** 。

删边 等价于 加边。

于是就有思路了：

我们将操作 $1$（删边）反向，改为加边。

那么处理加边的数据结构有哪些呢？**并查集**！

### 我们将上面的零散的思路组合一下，这道题的解法就出来了！

~~简略~~完整思路如下：

1. 将所有没有删去的边保留下来，建立初始并查集。

2. 倒序处理所有操作，对于删边操作，改为加边（用并查集维护），额外记录每个点所在并查集的  $a_i$  的总和 $s_i$ ，对于一次合并，若两个集合有且仅有一个集合包含起点，则 $ans+=s_i \cdot time$ 其中， $time$ 表示时间戳，初值为 $q + 1$。

3. 对于改值操作，修改时间戳。

一些细节：
1. 图有可能本来就不连通（如样例  $2$ )操作之后还需要将剩下的点再做处理。

2. $ans$ 需要  **unsigned long long**  ！！！

-----

# 代码
-----

```cpp



#include <iostream>
#include <fstream>
#include <vector>

using namespace std;



struct Edge {
	long long x, y, d;
	bool b;
};
string S[400009];
Edge e[400009]; 
long long n, m, q, dele[400009], father[400009], cnt;
bool visit[400009];
unsigned long long ans, tim, ln, siz[400009], yua[400009];

long long get_father(long long x) {
	return x == father[x] ? x : father[x] = get_father(father[x]);
}




int main () {
	scanf("%lld%lld%lld", &n, &m, &q);
	for (register long long i = 1; i <= m; i ++) {
		scanf("%lld%lld", &e[i].x, &e[i].y);
		e[i].d = i;
		e[i].b = true;
	}
	
	for (register long long i = 1; i <= n; i ++) {
		if (visit[i])
			continue;
		ln += siz[i];
	}
	for (register long long i = 1; i <= q; i ++) {
		cin >> S[i];
		if (S[i] == "DELETE") {
			cin >> dele[i];
			e[dele[i]].b = false;
		}	
	}
	for (register long long i = 1; i <= n; i ++) {
		cin >> siz[i];
		yua[i] = siz[i];
	}
		
	for (register long long i = 1; i <= n; i ++) {
		father[i] = i;
	}
	for (register long long i = 1; i <= m; i ++) {
		if (e[i].b) {
			long long x = get_father(e[i].x), y = get_father(e[i].y);
			if (x == y)
				continue;
			if (x == 1) {
				siz[x] += siz[y];
				father[y] = x;
			}
			else {
				siz[y] += siz[x];
				father[x] = y;
			}
		}
	}
	tim = q + 1;
	ans = tim * siz[1];
	for (register long long i = q; i >= 1; i --) {
		if (S[i] == "GC") {
			tim = i;
		}
		else {
			long long x = get_father(e[dele[i]].x), y = get_father(e[dele[i]].y);
			if (x == y)
				continue;
			if (x == 1) {
				siz[x] += siz[y];
				ans += tim * siz[y];
				father[y] = x;
			}
			else if (y == 1) {
				siz[y] += siz[x];
				ans += tim * siz[x];
				father[x] = y;
			}
			else {
				siz[y] += siz[x];
				father[x] = y;
			}
			
		}
	}
	for (register long long i = 1; i <= n; i ++)
		if (get_father(i) != 1)
			ln += yua[i];
	printf("%llu\n", ans + tim * ln);
	return 0;
}



```



---

## 作者：Troubadour (赞：5)

#### 前置知识：并查集。

考场上灵光一现想出了正解，遂 $40$ 分钟敲完并通过大样例。于是心满意足的开 T2 了。

结果没注意到这题藏了一个坑，导致没有过掉。

### 思路：

如果我们直接考虑这个过程，对于这些点，需要计算出它被哪一次 GC 操作删掉，然后把它们的贡献加起来。但是我们发现，这是一张不断删边的无向图，不容易维护其连通性。所以我们换一种思路，从后往前去考虑这个操作序列，每次往上面加边，这样连通性就很好维护了。

首先考虑所有操作之后（不包括删掉所有点的那次），剩下了一个连通块，这个连通块的权值和里面点存活的时间是很容易求出来的。

然后从后往前，每一次 GC 操作都会删掉一批点，很显然它们是且仅是上一次 GC 到这次之间的删边操作导致和 $1$ 号点不连通而被删掉的，每一次删边都有可能导致一个连通块断开。我们要做的就是求出这些块的权值和。

反着考虑，把删边看作加边，在这个过程中维护所有点的连通性和它们所在连通块的权值，并计算出两次 GC 操作之间加上的边导致新增了多少点和 $1$ 号点连通，然后把它们的权值乘上存活时间加到答案里去。重复这个过程，一段一段的考虑，就算出了所有点的贡献。

具体实现中，我们设一个连通块的权值为块内所有点的权值之和，利用并查集进行合并。为了得到正确的结果，我们钦定每次把祖宗编号大的连通块合并到小的上面。然后这道题就做完了，时间复杂度非常优秀。

然后你敲完之后发现，怎么第二个大样例过不去呢？

因为在这个过程中，我们默认在 $0$ 时刻有一个隐藏的 GC 操作，换句话说就是那些一开始就没和 $1$ 号节点联通的点，它们明明活到了第一次 GC 操作，但是我们根本没去算。因此要找出这些点，再加上它们的贡献。

（感谢良心出题人。）

恭喜你，你已经过了所有样例。如果你细心一些的话，会发现这数据范围很显然爆 int 了，遂开 long long。

接下来如果你交到 luogu 上，会得到 $95$ 分的好成绩，报错信息显示：

~~~~
Wrong Answer.wrong answer On line 1 column 1, read -, expected 1.
~~~~

溢出了。我们再回头来看一眼这个数据范围，把极限数据拉满代进去，会发现爆了 LLONG_MAX，要开 unsigned long long 才能过。

upd：感谢讨论区 @[王熙文](https://www.luogu.com.cn/user/353688)的 hack，需要特判没有 GC 的情况，此时答案为 $(q+1)\times\sum\limits_{i=1}^{n}a_i$。

### Code（赛时代码，加了 unsigned，修了一点小瑕疵）:

```cpp
/*
	Copyright (C) 2022 Troubadour_Ggmz

	This library is freesoftware; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 3,
	or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; see the files license.txt respectively.
	If not, see <http://www.gnu.org/licenses/>.
*/
#include<bits/stdc++.h>
#define int long long
namespace GGMZ
{
	const int N = 4e5 + 5;
	struct edge
	{
		int u, v;
		edge(int _u = 0, int _v = 0)
		{
			u = _u, v = _v;
		}
	} e[N];
	int n, m, q, fa[N], val[N], a[N], ans, lst, first;
	bool vis[N], NO_GC;
	struct __ask
	{
		int opt, k, id;
	} ask[N];
	inline int find(int x)
	{
		return fa[x] == x ? x : fa[x] = find(fa[x]);
	}
	void work()
	{
		scanf("%llu %llu %llu", &n, &m, &q);
		for (int i = 1; i <= m; i++)
		{
			scanf("%llu %llu", &e[i].u, &e[i].v);
			if (e[i].u > e[i].v)std::swap(e[i].u, e[i].v);
		}
		for (int i = 1; i <= q; i++)
		{
			char opt[15];
			scanf("%s ", opt);
			ask[i].id = i;
			if (opt[0] == 'D')
			{
				ask[i].opt = 2;
				scanf("%llu", &ask[i].k);
			}
			else
			{
				NO_GC = 1;
				ask[i].opt = 1;
				if (first == 0)first = i;
				lst = i;
			}
		}
		for (int i = 1; i <= lst; i++)
		{
			if (ask[i].opt == 2)
			{
				vis[ask[i].k] = 1;
			}
		}
		for (int i = 1; i <= n; i++)
		{
			scanf("%llu", &val[i]);
			fa[i] = i;
		}
		if (NO_GC == 0)//特判没有 GC 的情况
		{
			int ans = 0;
			for (int i = 1;i <= n;i++)
			{
				ans += val[i] * (q + 1);
			}
			printf("%llu\n", ans);
			return;
		}
		//init
		for (int i = 1;i <= m;i++)
		{
			int fx = find(e[i].u), fy = find(e[i].v);
			if (fy != fx)
			{
				fa[fy] = fx;
			}
		}
		for (int i = 1;i <= n;i++)
		{
			if (find(i) != find(1))ans += first * val[i];
		}
		for (int i = 1;i <= n;i++)
		{
			fa[i] = i;
		}
		for (int i = 1; i <= m; i++)
		{
			if (!vis[i])
			{
				//merge
				int fx = find(e[i].u), fy = find(e[i].v);
				if (fy != fx)
				{
					val[fx] += val[fy];
					fa[fy] = fx;
				}
			}
		}
		ans += val[find(1)] * (q + 1 - lst);
		for (int i = lst; i > 0;)
		{
			std::vector<int>g;
			g.clear();
			if (ask[i].opt == 1)
			{
				int ls = i;
				i--;
				while (ask[i].opt == 2 && i != 0)
				{
					g.push_back(ask[i].k);
					i--;
				}
				for (int a : g)
				{
					int fx = find(e[a].u), fy = find(e[a].v);
					if (fx != fy)
					{
						val[fx] += val[fy];
						fa[fy] = fx;
					}
				}
				ans += (ls - i) * val[find(1)];
			}
		}
		printf("%llu\n", ans);
	}
}
#undef int
int main()
{
	return GGMZ::work(), 0;
}
```

感觉这是这次省选唯一阳间的题了。

---

## 作者：王熙文 (赞：4)

## 题解

首先，可以套路地倒序加边，有利于维护两点间的连通性。

对于每个删边操作，考虑需要考虑它带来的贡献：如果当前删边（设边为 $(u,v)$）将 $u,v$ 中原来在 $1$ 的连通块的点变成不在了，则这个操作后面的 GC 操作便会把那些点删掉。

因为倒序进行操作，所以连通块的改变会呈现出：一个点 $v$ 原来不在 $1$ 的连通块，连接 $(u,v)$ 之后在 $1$ 的连通块了。可以在 $1$ 的连通块的条件是 $u$ 原来在 $1$ 的连通块。这时候相当于 $v$ 所在的连通块和 $1$ 所在的连通块合并成一个了。

那么我们再回归到断边上：如果倒序连边是这样的情况，则断边恰好满足上面说的 $v$ 的连通块在这一次不与 $1$ 连通了。此时这个连通块将会在后面的 GC 操作被删掉，它们的 $alive$ 值应当为后面的第一个 GC 的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/mvon8kcl.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

我们使用并查集来加边并维护连通性，这样就可以很快判断出是否 $u$ 与 $1$ 连通且 $v$ 不与 $1$ 连通了。对于不与 $1$ 连通的 $v$，找到它的连通块并标记 alive 可使用一个 dfs。

但到这里还不够。我们上述考虑的是原来在 $1$ 的连通块删边后不在了的点。原来（删边之前的图）就不在 $1$ 的连通块的点会被第一次 GC 操作删除，最终（删完边后的图）还在 $1$ 的连通块的点的 $alive$ 值为 $q+1$。特判一下即可。

注意，如果没有任何 GC 操作，就不会有“第一次 GC 操作”，此时每个点的 $alive$ 值都是 $q+1$，也可以特判解决。

时间复杂度：找到一个点所在的连通块是 $\mathcal O(size)$ 的，而总共最多会有 $\mathcal O(n)$ 个点会被找连通块（因为每一次找连通块后会加边），所以找连通块的复杂度为 $\mathcal O(n)$。并查集的复杂度很小，接近 $\mathcal O(n)$，所以总复杂度接近 $\mathcal O(n)$。

具体参见代码。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,q;

struct edge
{
	int u,v;
} e[400010];

struct query
{
	int op,x;
} qq[400010];

int qz[400010];

bool vis_edge[400010];

int alive[400010];

int cnt,ltk[400010];

bool vis[400010];

int tot=0,var[800010],nxt[800010],head[400010];

void add_edge(int u,int v)
{
	var[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}

void dfs(int u)
{
	if(vis[u]) return;
	vis[u]=1;
	ltk[++cnt]=u;
	for(int i=head[u]; i; i=nxt[i]) dfs(var[i]);
}

void find_ltk(int x) // 找到 x 的连通块（复杂度 O(size)）
{
	cnt=0;
	dfs(x);
	for(int i=1; i<=cnt; ++i) vis[ltk[i]]=0;
}

int fa[400010];

int find(int x)
{
	while(x!=fa[x]) x=fa[x]=fa[fa[x]];
	return x;
}

void add(int u,int v)
{
	add_edge(u,v),add_edge(v,u);
	int fu=find(u),fv=find(v);
	fa[fu]=fv;
}

int main()
{
	ios::sync_with_stdio(false),cin.tie(0);
	string s;
	bool flag=0;
	cin>>n>>m>>q;
	for(int i=1; i<=m; ++i)
	{
		cin>>e[i].u>>e[i].v;
	}
	for(int i=1; i<=q; ++i)
	{
		cin>>s;
		if(s=="GC") qq[i].op=1,flag=1;
		else qq[i].op=2,cin>>qq[i].x,vis_edge[qq[i].x]=1;
	}
	for(int i=1; i<=n; ++i) cin>>qz[i];
	if(!flag)
	{
		long long ans=0;
		for(int i=1; i<=n; ++i) ans+=1ll*qz[i]*(q+1);
		cout<<ans;
		return 0;
	}
	// 把删边看成倒着连边
	// 删完的边后的图 1 的连通块里都是 q+1
	// 倒着连边，对于每个连边，如果其中一个点属于 1 的连通块，另一个不属于，则不属于的点的连通块都为下一次 GC 操作的位置（如果没有就是 q+1）
	// 找到第一个 GC，原图不属于 1 的连通块的点的答案都是 第一个 GC 的位置
	for(int i=1; i<=n; ++i) fa[i]=i;
	for(int i=1; i<=m; ++i)
	{
		if(!vis_edge[i]) add(e[i].u,e[i].v);
	}
	find_ltk(1);
	for(int i=1; i<=cnt; ++i) alive[ltk[i]]=q+1;
	int nowlast=q+1;
	for(int i=q; i>=1; --i)
	{
		if(qq[i].op==1) nowlast=i;
		else
		{
			int u=e[qq[i].x].u,v=e[qq[i].x].v;
			if(find(1)!=find(u)) swap(u,v);
			if(find(1)==find(u) && find(1)!=find(v))
			{
				find_ltk(v);
				for(int j=1; j<=cnt; ++j) alive[ltk[j]]=nowlast;
			}
			add(u,v);
		}
	}
	int first_gc;
	for(int i=1; i<=q; ++i)
	{
		if(qq[i].op==1)
		{
			first_gc=i;
			break;
		}
	}
	for(int i=1; i<=n; ++i)
	{
		if(find(1)!=find(i))
		{
			alive[i]=first_gc;
		}
	}
	unsigned long long ans=0;
	for(int i=1; i<=n; ++i) ans+=1ll*qz[i]*alive[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：CruiseY (赞：3)

## 前言
在考场上写了一个最长路算法，出了考场大家都说写的倒序加边，毕竟是在考场写出来的，写题解纪念一下。


## 核心思路
每个点删除的时间应为它与根节点的所有路径中边权最小值的最大值，将每条边被删除的时间初始化为$Q+1$，接下来从根节点跑一遍最长路即可。

$dis[u]$ 表示第$u$个点被删除的时间 。
 $w[(u，v)]$表示$u$点到$v$点这条边被删除的时间。

若$dis[u] < min(dis[v], w[(u, v)])$ 则 $dis[v] = min(dis[u], w[(u, v)])$。

解释：若$dis[u] < min(dis[v], w[(u, v)])$意为有一条根节点从$v$点到$u$点的路径中边权的最小值大于$u$号点被删除的时间，则用这条路径更新$u$号点被删除的时间。


#### 提示：本题最后一个点答案过大需要采用__int128

## 附上代码

```cpp
#include <cstdio>
#include <queue>
#include <vector>
#include <cstring>
#include <algorithm>
#define ll __int128
using namespace std;

ll read() {
	ll x = 0, f = 1; char ch =  getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}

void write(ll x) {
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

ll head[400010], cnt;
struct edge {
	ll to, nxt, id;
}e[800010];
void add(ll u, ll v, ll id) {
	e[++cnt].to = v; e[cnt].nxt = head[u]; 
	e[cnt].id = id; head[u] = cnt;
}

queue<int> q;
ll n, m, Q, w[400010], ti[400010];
ll dis[400010], num, a[400010], ans;
bool flag[400010];
char s[40];

void spfa() {
	q.push(1); dis[1] = Q + 1;//将1号点的删除时间设为Q+1
	while(!q.empty()) {
		ll u = q.front(); q.pop();
		for(int i = head[u]; i; i = e[i].nxt) {
			ll v = e[i].to;
			if(dis[v] >= min(w[e[i].id], dis[u])) continue;
			dis[v] = min(w[e[i].id], dis[u]);
			if(!flag[v]) q.push(v), flag[v] = 1;
		} flag[u] = 0;
	}
}//spfa更新dis[v]如核心思路所示

int main() {
	//freopen("garbage18.in", "r", stdin);
	//freopen("garbage.out", "w", stdout);
	n = read(); m = read(); Q = read();
	for(int i = 1; i <= m; i++) {
		ll u = read(), v = read();
		add(u, v, i); add(v, u, i);
	}
	for(int i = 1; i <= Q; i++) {
		scanf("%s", s + 1);
		if(s[1] == 'D') w[read()] = i;
		else ti[++num] = i;//记录每次清除的时间
	} ti[++num] = Q + 1;//最后一次清除时间可以当做Q+1
	for(int i = 1; i <= n; i++) a[i] = read();
	for(int i = 1; i <= m; i++) if(!w[i]) w[i] = Q + 1; 
	//若本条边未被删除，则可设置删除时间为Q+1
	spfa();
	for(int i = 1; i <= n; i++) ans += *lower_bound(ti + 1, ti + 1 + num, dis[i]) * a[i];
	//dis[u]为u节点被删除的时间
	//题目要求为存在时间，所以需要用lower_bound查询u节点的存在时间
	write(ans);
	return 0;
}
```

 至于时间复杂度，虽然**spfa**会导致~~Au变Ag~~，但在本题时间实测并不大，与倒序加边几乎相同


---

## 作者：_HMZ_ (赞：2)

## 解题思路

首先这题有个很明显的套路，全是删除操作，而且可以离线，于是我们就倒序处理，将删边变成加边。

加边之后，用并查集可以很方便的处理连通性，那么，如何处理答案呢？

我们考虑一次加边的贡献，如果一次加边后将某一连通块与 $1$ 号点连起来了，那么在正序考虑的时候，它前面的 GC 操作都没用了。

为什么呢？我们现在是倒序考虑，现在的加边就是原来的删边，如果有一条边使得某一连通块与 $1$ 联通，那么在删除这条边之前，所有 GC 操作都对这个连通块无效。

那么如果连接上了，何时这个连通块被删除呢？其实就是加这条边前最近的一个 GC 操作，如果连通块与 $1$ 不连通，只要来一个 GC 操作这个连通块就没了。

注意有可能某些点一开始就与 $1$ 不连通，这些点在第一个 GC 操作就被删除了，这种情况要单独处理。

因为每个点只会被删除一次，所以我们可以暴力 dfs 删除，而并查集复杂度很小，所以复杂度近似 $O(n)$。

## AC代码

虽然思路比较简单，但是代码却有点复杂。

```cpp
#include<iostream>
using namespace std;
#define int unsigned long long
int n, m, q, U[1000005], tot, V[1000005], fa[1000005], head[1000005], last, tim[1000005], sum;
bool vis[1000005];
struct node
{
	string op;
	int num;
}t[1000005];
struct edge
{
	int y, nex;
}s[1000005];
void add(int i, int j)
{
	s[++tot].y = j, s[tot].nex = head[i];
	head[i] = tot;
}
int getfa(int now)
{
	if (fa[now] == now)
		return now;
	else
	{
		fa[now] = getfa(fa[now]);
		return fa[now];
	}
}
void dfs(int now)//dfs暴力统计每一个点何时删除
{
	if (!last)	return;
	tim[now] = last;
	for (int i = head[now]; i; i = s[i].nex)
	{
		int y = s[i].y;
		if (!tim[y])
			dfs(y);
	}
}
signed main()
{
	cin >> n >> m >> q;
	for (int i = 1; i <= m; i++)
		cin >> U[i] >> V[i];
	for (int i = 1; i <= q; i++)
	{
		cin >> t[i].op;
		if (t[i].op == "DELETE")
			cin >> t[i].num, vis[t[i].num] = true;
	}
	for (int i = 1; i <= n; i++)
		fa[i] = i;
	for (int i = 1; i <= m; i++)
	{
		if (!vis[i])//先将从未被删除的边连上
		{
			int t1 = getfa(U[i]), t2 = getfa(V[i]);
			if (t1 == t2)	continue;
			add(U[i], V[i]);
			add(V[i], U[i]);
			fa[t1] = t2;
		}
	}
	for (int i = q; i >= 1; i--)
	{
		if (t[i].op == "DELETE")
		{
			int t1 = getfa(U[t[i].num]), t2 = getfa(V[t[i].num]);
			if (t1 == t2)	continue;
			if (t1 == getfa(1) && t2 != getfa(1))//如果一条边使得一个连通块与1联通了，暴力统计并删除
				dfs(t2), fa[t2] = t1;
			else if (t2 == getfa(1) && t1 != getfa(1))
				dfs(t1), fa[t1] = t2;
			else
				fa[t1] = t2;
			add(U[t[i].num], V[t[i].num]);
			add(V[t[i].num], U[t[i].num]);
		}
		else
			last = i;//记录最近的GC操作
	}
	for (int i = 1; i <= n; i++)
		fa[i] = i;
	for (int i = 1; i <= m; i++)
		fa[getfa(U[i])] = getfa(V[i]);
	for (int i = 1; i <= n; i++)
		if (getfa(i) != getfa(1))
			tim[i] = last;//注意有些点一开始就与1不连通，第一次GC操作就将这些删除了
	for (int i = 1; i <= n; i++)
	{
		int u;
		cin >> u;
		if (!tim[i])//如果最后还没被删除
			tim[i] = q + 1;
		sum += u * tim[i];
	}
	cout << sum;
	return 0;
}
```


---

## 作者：Cocoly1990 (赞：1)

题意
---
维护一张无向图，支持删边，删除和节点 1 不连通的点，询问每个点的被删除时间，**不要求强制在线。**

思路
---
我们称节点 1 为根节点。

一个简单的想法是可撤销并查集，但显然没有必要，我们做这么样的考虑：

询问每个点被删除的时间，并不太好处理，对于两次删除 $q_i,q_{i+1}$，凡是和根节点断连时间 $t_i\in \left(q_i,q_{i+1}\right]$ 的点都会在第 $i+1$ 此被删除，因此我们只需要记录下每个点和根断连的时间，就可以很好的处理每个点被删除的时间。

我们考虑分裂集合显然不如合并集合简单，所以很自然能想到倒序处理操作，**如果倒序加上某条边的时候，某些点和根联通了，那么这些点就是在这个时候（正序）和根节点断连的。**

我相信传统的并查集大家都会写，但这题不只需要维护连通块间的合并，还需要维护连通块的具体信息。

我们用 `vector` 来维护每个连通块的点集，每次加边相当于合并点集，这部分暴力合并显然是不行的，但众所周知，合并集合使用**启发式合并**（即每次把小的集合合并到大的里）可以做到均摊 $\log n$，具体证明不是此文的重点，不过多阐述。

思路其实并不难，代码可能会有一些比较多的细节（？），当然了也可能是我比较菜（这是第一次尝试启发式合并，此前都是停留在理论阶段）。

一些你可能需要注意的细节：
1. 图最开始不一定联通，需要把不连通的节点提前处理掉
2. 答案需要 `unsigned long long`

考虑到代码可能并不怎么好写，提供一份参考代码，谨慎食用。

Code
---
```cpp
#include<bits/stdc++.h>
#define int long long
#define Maxn 400007
using namespace std;
map<pair<int, int>,bool> m1;
int u, v;

int n, m, Q;
pair<int, int> tim[Maxn];
int f[Maxn], a[Maxn];
vector<int> qt;
int find(int x){
	return f[x] == x ? x : f[x] = find(f[x]);
}
vector<pair<int, int> > vv, q;
vector<int> siz[Maxn], t;
void hb(int x, int y){
	if(find(x) == find(y)) return;
	int xx = find(x); int yy = find(y);
	if(siz[xx].size() >= siz[yy].size()) swap(siz[xx], siz[yy]);
	for(int i = 0; i < siz[xx].size(); i ++){
		siz[yy].push_back(siz[xx][i]);
	}
	siz[xx].clear();
	f[xx] = yy;
}
signed main(){
	cin >> n >> m >> Q;
	//time.resize(n + 7);
	for(int i = 1; i <= n; i ++){
		f[i] = i;
		siz[i].push_back(i);
	}
	for(int i = 1; i <= m; i ++){
		cin >> u >> v;
		if(u > v) swap(u, v);
		vv.push_back(make_pair(u, v));
	}
	string opt;
	for(int i = 1; i <= Q; i ++){
		cin >> opt;
		if(opt == "GC") t.push_back(i);
		else {
			int qwq;
			cin >> qwq;
			u = vv[qwq - 1].first; 
			v = vv[qwq - 1].second; 
			
			if(u > v) swap(u, v);
			q.push_back(make_pair(u, v));
			qt.push_back(i);
			m1[make_pair(u, v)] = 1;
		}
	}
	for(int i = 0; i <= m - 1; i ++){
		u = vv[i].first; v = vv[i].second;
		if(m1.find(make_pair(u, v)) == m1.end()){
			hb(u, v);
		}
	}
	for(int i = 1; i <= n; i ++){
		tim[i] = make_pair(0, i);
	}
	for(int i = 1; i <= n; i ++){
		if(find(i) == find(1)) tim[i] =  make_pair(Q + 1, i);
	}
	//cout << q.size();
	for(int i = q.size() - 1; i >= 0;i --){
		u = q[i].first;
		v = q[i].second;
		//cout << u << " " << v << " " << i << "!\n";
		int uu = find(u), _v = find(v);
		//cout << uu << " " << _v << "!!\n";
		//cout << siz[uu].size() << " " << siz[_v].size() << "!!!\n";
		if(uu == _v) continue;
		if(uu == find(1)){
			for(int j = 0; j < siz[_v].size(); j ++){
				tim[siz[_v][j]] = make_pair(qt[i], siz[_v][j]);
			}
			hb(u, v);
		}else if(_v == find(1)){
			for(int j = 0; j < siz[uu].size(); j ++){
				tim[siz[uu][j]] = make_pair(qt[i], siz[uu][j]);
			}
			hb(u, v);
		}else hb(u, v);
		//cout << i << endl;
	}
	//puts("qwq");
//	for(int i = 1; i <= n; i ++){
//		cout << tim[i].first << endl;
//	}
	for(int i = 1; i <= n; i ++) cin >> a[i];
	sort(tim + 1, tim + n + 1);
	int l = 1;
	unsigned int ans = 0;
	for(int i = 0; i < t.size(); i ++){
		while(tim[l].first < t[i]){
			ans += t[i] * a[tim[l].second];
			l ++;
		}
	}
	for(int i = l; i <= n; i ++){
		ans += a[tim[i].second] * (Q + 1);
	}
	cout << ans;
}
/*
6 6 8
1 2
2 3
2 4
1 4
2 5
1 6
GC
DELETE 5
DELETE 3
GC
DELETE 1
GC
DELETE 2
GC
1 2 3 4 5 6
*/
```

The end
--
> 我于白昼见证苍穹沦落
于白夜见证明暗的苟合
于避难所见证信仰沉没

---


# [BJWC2010] 外星联络

## 题目描述

小 P 在看过电影《超时空接触》(Contact)之后被深深的打动，决心致力于寻找外星人的事业。于是，他每天晚上都爬在屋顶上试图用自己的收音机收听外星人发来的信息。

虽然他收听到的仅仅是一些噪声，但是他还是按照这些噪声的高低电平将接收到的信号改写为由 `0` 和 `1` 构成的串， 并坚信外星人的信息就隐藏在其中。他认为，外星人发来的信息一定会在他接受到的 01 串中重复出现，所以他希望找到他接受到的 01 串中所有重复出现次数大于 $1$ 的子串。

但是他收到的信号串实在是太长了，于是，他希望你能编一个程序来帮助他。

## 说明/提示

对于 100%的数据，满足 $0 \le N \le 3000$

## 样例 #1

### 输入

```
7
1010101```

### 输出

```
3
3
2
2
4
3
3
2
2```

# 题解

## 作者：EternalAlexander (赞：15)

写完看了下其他人代码，正解似乎是SA。

但是既然n^2的Trie树简单应用可以过那还写啥后缀数组是吧。

直接暴力枚举子串，将trie树上对应位置的cnt值+1，最后先序遍历一遍就完了。因为子串只有n^2个，字符集大小为2，因此时空复杂度均为n^2。

n<=3000 n^2是肯定可以过的。

估计是最简单，代码最短的做法了。



```cpp
#include <cstdio>

int ch[9000000][2]={0}; 
int cnt[9000000]={0};
int tail=0;
char s[4000];

int dfs(int root) {
    if (cnt[root]>1) printf("%d\n",cnt[root]);
    if (ch[root][0]) dfs(ch[root][0]);
    if (ch[root][1]) dfs(ch[root][1]);
    return 0;
}

int main() {
    int n;
    scanf("%d %s", &n, &s);
    for (int i=n;i>=1;--i) s[i]=s[i-1];
    for (int i=1;i<=n;++i) {
        int p=0;
        for (int j=i;j<=n;++j) {
            if (!ch[p][s[j]-'0']) ch[p][s[j]-'0']=++tail;
            p=ch[p][s[j]-'0']; cnt[p]++;
        }
    }dfs(0);
    return 0;
}
```

---

## 作者：ywy_c_asm (赞：7)

思路：后缀自动机。

我们把这个串的后缀自动机建出来，然后在$Parent$树上$dfs$出$size$即这个点的字符串的出现次数，然后按照字典序对后缀自动机进行$dfs$即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
namespace ywy
{
	char str[3002];
	int sam[10001][2],fa[10001],len[10001],size[10001],heads[10001];
	typedef struct _b
	{
		int dest;
		int nxt;
	} bian;
	bian memchi[1000001];
	int gnn=1;
	inline void add(int s,int t)
	{
		memchi[gnn].dest=t;
		memchi[gnn].nxt=heads[s];
		heads[s]=gnn;
		gnn++;
	} int gn=2;
	inline int zhuanyi(int p,int x)
	{
		int me=gn;
		gn++;
		len[me]=len[p]+1;
		size[me]=1;
		while(p&&!sam[p][x])sam[p][x]=me,p=fa[p];
		if(!p)
		{
			fa[me]=1;
			return(me);
		}
		int q=sam[p][x];
		if(len[q]==len[p]+1)
		{
			fa[me]=q;
			return(me);
		}
		int nq=gn;
		gn++;
		len[nq]=len[p]+1;
		sam[nq][0]=sam[q][0];
		sam[nq][1]=sam[q][1];
		fa[nq]=fa[q];
		fa[q]=fa[me]=nq;
		while(p&&sam[p][x]==q)sam[p][x]=nq,p=fa[p];
		return(me);
	}
	void print(int num)
	{
		if(num>=10)print(num/10);
		putchar(num%10+'0');
	}
	void dfs(int pt)
	{
		for(register int i=heads[pt]; i; i=memchi[i].nxt)
		{
			dfs(memchi[i].dest);
			size[pt]+=size[memchi[i].dest];
		}
	}
	void efs(int pt)
	{
		if(!pt)return;
		if(size[pt]>1&&pt!=1)print(size[pt]),putchar('\n');
		efs(sam[pt][0]);
		efs(sam[pt][1]);
	}
	void ywymain()
	{
		int eee;
		cin>>eee;
		scanf("%s",str+1);
		int n=strlen(str+1);
		int p=1;
		for(register int i=1; i<=n; i++)p=zhuanyi(p,str[i]-'0');
		for(register int i=2; i<gn; i++)add(fa[i],i);
		dfs(1);
		efs(1);
	}
}
int main()
{
	ywy::ywymain();
	return(0);
}
```

---

## 作者：bztMinamoto (赞：5)

刚学几天后缀数组，有些生搬硬套。经过此题之后，对其有了一个比较深刻的认识

关于什么是后缀数组，可以看看此blog，讲得十分详细，相信大家看完都能懂。这里主要讲解关于本题的思路[](https://www.cnblogs.com/victorique/p/8480093.html)https://www.cnblogs.com/victorique/p/8480093.html

一开始，我的想法是用map记录每一个子串出现的次数，然后枚举，再排序。但考虑到map那每次操作都是O（log n）的时间复杂度，这题难免会爆掉

我们仔细想想，对于每一个后缀数组，如果子串中没有数组的首字母，那子串一定会在其他的数组计算时被累加。于是我们可以对于每一个后缀数组，只考虑包含它的首字母的子串

我们可以先预处理出sa数组和height数组。枚举i从1到n。可以证明，如果一个子串在排名靠前的后缀数组中求出的出现次数，必定大于在其之后的数组中出现的次数（因为数组是按照字典序排列的，所以子串必然是按字典序递增的）

如何求出一个数组中所有子串的出现次数呢？我们可以设子串长度为j，按排名枚举在他之后的每一个数组，如果height[k]>=j，说明lct（i，k）>=j，即该子串也在数组k中出现。而且我们可以发现，对于每一个长度j，如果比它更大的可行，那么它一定可行。所以我们可以从大到小枚举j，倒序输出答案，可以避免重复搜索（算是个小优化吧）

最后需要注意的是，因为i数组前面长度为height[i]的子串必然已经被计算，所以我们枚举j时应注意j>height[i]

具体细节看注解，上代码

```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=3050;
char s[N];
int y[N],x[N],c[N],sa[N],rk[N],height[N],wt[30];
int ans[N];
int n,m;
void read(int &res){
    char ch;bool flag=0;
    while(!isdigit(ch=getchar()))
        (ch=='-')&&(flag=true);
    for(res=ch-'0';isdigit(ch=getchar());res=res*10+ch-'0');
    (flag)&&(res=-res);
}
void print(int x) {
    if(!x) {
        putchar(48);
        return;
    }
    int l=0;
    while(x) wt[++l]=x%10,x/=10;
    while(l) putchar(wt[l--]+48);
}
void get_SA(){
    for(int i=1;i<=n;i++) ++c[x[i]=s[i]];
    for(int i=2;i<=m;i++) c[i]+=c[i-1];
    for(int i=n;i>=1;i--) sa[c[x[i]]--]=i;
    for(int k=1;k<=n;k<<=1){
        int num=0;
        for(int i=n-k+1;i<=n;i++) y[++num]=i;
        for(int i=1;i<=n;i++) if(sa[i]>k) y[++num]=sa[i]-k;
        for(int i=1;i<=m;i++) c[i]=0;
        for(int i=1;i<=n;i++) ++c[x[i]];
        for(int i=2;i<=m;i++) c[i]+=c[i-1];
        for(int i=n;i>=1;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;
        swap(x,y);
        x[sa[1]]=1;
        num=1;
        for(int i=2;i<=n;i++)
        x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?num:++num;
        if(num==n) break;
        m=num;
    }
}
void get_height(){
    int k=0;
    for(int i=1;i<=n;i++) rk[sa[i]]=i;
    for(int i=1;i<=n;i++){
        if(rk[i]==1) continue;
        if(k) k--;
        int j=sa[rk[i]-1];
        while(j+k<=n&&i+k<=n&&s[i+k]==s[j+k]) k++;
        height[rk[i]]=k;
    }
}
void solve(){
	for(int i=1;i<n;i++){
		int k=i+1,l=0;
		for(int j=n-sa[i]+1;j>height[i];j--){
			while(height[k]>=j) k++;
			if(k>i+1) ans[++l]=k-i;
            //为了避免重复枚举，将j从大到小枚举
		}
		for(int j=l;j>=1;j--)
		print(ans[j]),putchar(10);
        //注意倒序输出答案
	}
}
int main(){
	read(n);
    gets(s+1);
    m='1';
    get_SA();
    get_height();
    solve();
    return 0;
}
```

---

## 作者：览遍千秋 (赞：4)

## 问题描述

 [LG4341](https://www.luogu.org/problem/P4341)

[BZOJ2251](https://www.lydsy.com/JudgeOnline/problem.php?id=2251)

BZOJ需要权限号

---

## 题解

字符串的性质：一个字符串$s$所有的字串，等于$s$所有后缀的前缀。

枚举这个字符串的每一个后缀，将其插入一个$\mathrm{Trie}$

在插入$\mathrm{Trie}$的过程中可以非常方便的维护这个后缀的每个前缀。

最后从$root$开始对整棵$\mathrm{Trie}$进行一次遍历即可。

---

## $\mathrm{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

void read(int &x){
	x=0;char ch=1;int fh;
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-') fh=-1,ch=getchar();
	else fh=1;
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=fh;
}

char s[3007];
int ch[10000000][2],tot,root;//错误笔记：一开始数组开小十倍
int n,cnt[10000000];
void build(){
	root=++tot;
}

int chk(char s){
	return s-'0';
}

void insert(int pla){
	int p=root;
	for(register int i=pla;i<=n;i++){
		int k=chk(s[i]);
		if(!ch[p][k]) ch[p][k]=++tot;
		p=ch[p][k];++cnt[p];
	}
}

void dfs(int x){
	if(cnt[x]>1&&x!=root) cout<<cnt[x]<<endl;
	if(ch[x][0]) dfs(ch[x][0]);
	if(ch[x][1]) dfs(ch[x][1]);
}

int main(){
	ios::sync_with_stdio(0);
	build();
	cin>>n;cin>>(s+1);
	for(register int i=n;i>=1;i--){
		insert(i);
	}
	dfs(root);
	return 0;
}
```

---

## 作者：Jμdge (赞：4)

## 多久没写题解了...


这道题其实大体框架就是build_sa 然后build_height.

最后用height求解。

另外解释一下最后的操作：
1. 按照排名用i枚举后缀子串(排名为1的子串可以不枚举)
2. 用j枚举出现新子串的长度,从h[i-1]+1 到 h[i]
3. 用k向下记录长度超过j的子串,直至碰到了h[k]小于j的情况,此时k-i+1就是当前长度为j的子串在原串中出现的次数


基本思路和楼下的bzt大佬一样,但是我的code有一点小优化可以让80ms的时间减成0ms。其实这个思路很朴素.


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<vector>
#include<cstdio>
#include<cmath>
#include<queue>
#define ll long long
using namespace std;
const int M=31000;
const int inf=1e9;
inline int cread() { //日常字符读优
	char c=getchar();
	while(!isdigit(c))
		c=getchar();
	return c;
}
char s[M];
int n,m,k,p,mx;
int a[M],b[M],c[M];
int sa[M],rk[M],hi[M],f[M];
inline int cmpe(int i,int j) { //get sa 子模板
	int aa=i+k>n ? -1 : b[i+k],
	    bb=j+k>n ? -1 : b[j+k];
	return (b[i]!=b[j] || aa!=bb);
}
inline void build_sa() { //get sa 模板
	for(int i=1; i<=m; ++i) c[i]=0;
	for(int i=1; i<=n; ++i) ++c[a[i]=s[i]];
	for(int i=2; i<=m; ++i) c[i]+=c[i-1];
	for(int i=n; i; --i) sa[c[a[i]]--]=i;
	for(k=1,p=0; k<=n; k<<=1,m=p,p=0) {
		for(int i=n-k+1; i<=n; ++i) b[++p]=i;
		for(int i=1; i<=n; ++i) if(sa[i]>k)
				b[++p]=sa[i]-k;
		for(int i=1; i<=m; ++i) c[i]=0;
		for(int i=1; i<=n; ++i) ++c[a[i]];
		for(int i=2; i<=m; ++i) c[i]+=c[i-1];
		for(int i=n; i; --i) sa[c[a[b[i]]]--]=b[i];
		swap(a , b), a[sa[1]]=1, p=1;
		for(int i=2; i<=n; ++i)
			a[sa[i]]=cmpe(sa[i-1],sa[i])? ++p : p;
		if(p==n) break;
	}
	for(int i=1; i<=n; ++i)
		rk[sa[i]]=i;
}
inline void build_hi() { //get height 模板
	k=0, hi[1]=0;
	for(int i=1; i<=n; ++i)if(rk[i]>1) {
			int j=sa[rk[i]-1];
			if(k) --k;
			while(i+k<=n && j+k<=n && s[i+k]==s[j+k])
				++k;
			hi[rk[i]]=k;
		}
}

int main() {
	scanf("%d",&n), m=127;
	for(int i=1; i<=n; ++i)
		s[i]=cread();
	build_sa(), build_hi();
	for(int i=2; i<=n; ++i) {
		//按排名枚举子串(第一个舍去) 
		for(int j=hi[i-1]+1; j<=hi[i]; ++j) {
			//j初始值为hi[i-1]+1,即排名为i-1的子串lcp,避免重复计算,
			//然后j要<=hi[i],即当前子串串长 
			int k=i;
			while(hi[k]>=j) ++k;
			//寻找lcp值>=j的子串最后一次出现的位置
			printf("%d\n",k-i+1);
		}
	}
	return 0;
}
```

---

## 作者：SunsetSamsara (赞：4)

### 前言

这篇题解讲的是暴力做法，想看正解的请看其它题解

#### 题意

给一个字符串求所以出现次数大于 $1$ 的子串所出现的次数。输出的顺序按对应的子串的字典序排列。

#### 暴力前置知识

- Trie 树

#### 分析

首先这道紫题看起来很难，~~实际上的确很难~~

看标签，似乎是后缀数组。不过，再看一下数据范围，$n\le 3000$，这么明显的 $O(n^2)$ 暴力都可以过？！

既然 $n\le 3000$，那么我们就可以在 Trie 树上暴力插入所有的后缀。因为 $[l,r]$ 区间的子串都是从第 $l$ 个位置开始的后缀的长度为 $r-l+1$ 前缀，所以只要查询后缀的前缀的重复次数即可。

接下来看插入过程，遍历所有后缀，把 Trie 树上遍历到的节点的 `cnt` 值全都无脑加上 $1$ 就珂以了

最后看查询，直接中序 Dfs 遍历整棵 Trie 树就能按照字典序排序了

#### 代码

```cpp
#include<stdio.h>
struct node{
	int sons[2],cnt;
}nodes[9000001];//开 n^2 个 
int top;
char s[3001];
int n;
void dfs(int root){
    if(nodes[root].cnt>1)printf("%d\n",nodes[root].cnt);
    if(nodes[root].sons[0])dfs(nodes[root].sons[0]);
    if(nodes[root].sons[1])dfs(nodes[root].sons[1]);
}
void insert(int i){//插入第i个位置开始的后缀 
	int p=0;
    for(int j=i;j<=n;++j){
        if(!nodes[p].sons[s[j-1]-'0'])
			nodes[p].sons[s[j-1]-'0']=++top;
        p=nodes[p].sons[s[j-1]-'0'];
		++nodes[p].cnt;//无论是不是结束节点都加上1 
    }
}
int main(){
    scanf("%d%s",&n,s);
    for(int i=1;i<=n;++i)
		insert(i);
	dfs(0);
}
```

---

## 作者：Alioth_ (赞：2)

这是蒟蒻第一次写题解

这道题题目很明显 就是让求所有出现次数>1的子串出现的次数 子串按照字典序排序

先求出height数组 然后我们按照出现次数枚举 每次在height中找>=次数的连续的几段 对于每一段 段的长度+1就是这个子串出现的次数 **同时 每一个子串被且仅被一段height数组包含**

由于这个段中代表的子串（在当前枚举长度下）是一样的 如两个子串abc abcd 如果枚举长度=2 就是ab 等于3 就是abc 这个字串就是sa[i]到sa[i]+mid-1 （mid为当前枚举长度） 把这个子串加上出现次数(段的长度)即可

至于字典序 我们用一个map维护一堆string即可 map会自动按照字典序排序

下面是我丑陋的代码

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<map>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;

const int maxn=20021;
 
char s[maxn];
int sa[maxn],top,rk[maxn],height[maxn],tp[maxn],tax[maxn],N,M;
map<string,int>a;
 
void Qsort()
{
 	for(int i=0;i<=M;i++)tax[i]=0;
 	for(int i=1;i<=N;i++)tax[rk[i]]++; 
 	for(int i=1;i<=M;i++)tax[i]+=tax[i-1];
 	for(int i=N;i>=1;i--)sa[tax[rk[tp[i]]]--]=tp[i];
}

void get_height()
{
	int k=0;
	for(int i=1;i<=N;i++)rk[sa[i]]=i;
	for(int i=1;i<=N;i++)
	{
		if(rk[i]==1)continue;
		if(k)k--;
		int j=sa[rk[i]-1];
		while(j+k<=N&&i+k<=N&&s[i+k]==s[j+k])k++;
		height[rk[i]]=k;
		top=max(top,k);
	}
}

void suffixsort()
{
 	M=75;
 	for(int i=1;i<=N;i++)
 		rk[i]=s[i]-'0'+1,tp[i]=i;
 	Qsort(); 
 	for(int w=1,p=0;p<N;M=p,w<<=1)
 	{
 		p=0;
 		for(int i=1;i<=w;i++)tp[++p]=N-w+i;
 		for(int i=1;i<=N;i++)if(sa[i]>w)tp[++p]=sa[i]-w;
 		Qsort();
 		std::swap(tp,rk);
 		rk[sa[1]]=p=1;
 		for(int i=2;i<=N;i++)
 			rk[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w])?p:++p; 
 	}
}

string change(int l,int r)
{
	string ret;
	int p=0;
	char str[maxn];
	for(int i=l;i<=r;i++)
	{
		str[p]=s[i];
		p++;
	}
	return ret=str;
}

void work(int mid)
{
	for(int i=1;i<=N;i++)
		if(height[i]>=mid)
		{
			int j=i;
			while(j<=N&&height[j]>=mid)
			j++;
			j--;
			string num=change(sa[i],sa[i]+mid-1);
			a[num]+=j-i+2;
			i=j+1;
		}
}


int main()
{
	scanf("%d",&N);
	scanf("%s",s+1);
 	suffixsort();
 	get_height();
 	for(int i=1;i<=N;i++)
 		work(i);
 	for(map<string,int>::iterator it=a.begin();it!=a.end();it++)
	
		if(it->second>0)cout<<it->second<<endl;
	}
} 
```


---

## 作者：LEE114514 (赞：1)

## 思路
考虑怎么统计一个子串的出现次数。

子串可以写成后缀的前缀，所以我们把每个原串的后缀插入 `trie` 树。每次插入是 $O(len)$ 的，其中 $len$ 是被插入的后缀的长度。总复杂度是 $O(\frac{n \times (n-1)}{2})=O(n^2)$ 的。最后中序遍历一遍能在保证字典序的情况下找到所有出现次数 $>1$ 的子串。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=3005;
char str[maxn];
int nxt[2][maxn*maxn];
int cnt[maxn*maxn];
int tot;
void ins(char *str){
	int p=0;
	for(int i=0;str[i];++i){
		if(!nxt[str[i]&1][p]) nxt[str[i]&1][p]=++tot;
		p=nxt[str[i]&1][p];
		++cnt[p];
	}
}
void dfs(int u){
	if(cnt[u]>1) printf("%d\n",cnt[u]);
	if(nxt[0][u]) dfs(nxt[0][u]);
	if(nxt[1][u]) dfs(nxt[1][u]);
}
int n;
int main(){
	scanf("%d%s",&n,str);
	for(int i=0;i<n;++i) ins(str+i);
	dfs(0);
}
```

---

## 作者：Xiphi (赞：1)

考虑暴力，用 trie 记录所有子串，然后在每个子串结尾处的节点的 $cnt+1$。最后 dfs 贪心的输出即可。因为先 $0$ 后 $1$ 一定是满足字典序的。 

```cpp
//求所有出现次数>1的子串出现的次数 子串按照字典序排序
#include<bits/stdc++.h>
using namespace std;
int n;string s;
int trie[9000005][4],tot=0;
void dfs(int x){
	if(trie[x][2]>1) cout<<trie[x][2]<<'\n';
	if(trie[x][0]) dfs(trie[x][0]);
	if(trie[x][1]) dfs(trie[x][1]);
}
int main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);
	cin>>n>>s;
	s=" "+s;
	for(int i=1;i<=n;++i){
		int x=0;
		for(int j=i;j<=n;++j){
			if(!trie[x][s[j]-'0']){
				trie[x][s[j]-'0']=++tot;
			}
			x=trie[x][s[j]-'0'];
			trie[x][2]++;
		}
	}
	dfs(0);
	return 0;
}




```

---

## 作者：XenonWZH (赞：1)

[更好的阅读体验点这里](https://xenonwzh.github.io/luogu-4341/)

## 解题思路

这个数据范围就限制了最高复杂度为 $O(n^2)$。

对于所有子串，我们可以建立一颗 Trie。设字符串开头为 $1$，插入开头为 $1$、$2$、$3$、$\cdots$、$n$，结尾均为 $n$ 的子串。然后从根遍历就可得到所有的子串。然后从根 DFS 统计即可得到答案。

对于字典序，我们可以先 DFS $0$ 节点，再 DFS $1$ 节点。

## 代码演示

```cpp
#include <cstdio>

const int MAXN = 3000;

int trie[MAXN * MAXN + 2][2], tot = 1;
int end[MAXN * MAXN + 2];

inline void insert(char *str, int len) {
    int p = 1;
    for (int i = 0; i < len; i++) {
        int ch = str[i] - '0';
        if (trie[p][ch] == 0) trie[p][ch] = ++tot;
        p = trie[p][ch];
        end[p]++;
    }
}

void dfs(int p) {
    if (end[p] > 1) printf("%d\n", end[p]);
    if (trie[p][0]) dfs(trie[p][0]);
    if (trie[p][1]) dfs(trie[p][1]);
}

int main() {
    int n;
    static char str[MAXN + 1];

    scanf("%d", &n);
    scanf("%s", str);

    for (int i = 0; i < n; i++) {
        insert(str + i, n - i);
    }

    dfs(1);

    return 0;
}
```


---

## 作者：zplqwq (赞：1)

能用后缀树草过的题为什么要用后缀数组呢对吧。

我们在插入后缀的时候，对于每一个位置记录一下他的出现次数即可。

也就是说，我们在维护 trie 的同时维护一个 cnt，其作用就是对于每一个节点，如果我遍历了（即出现过了）就加 $1$ 。最后我们 dfs 遍历整棵树（保证字典序）时判断当前节点的 cnt 值是否大于 $1$ 即可。

```cpp
void insert(int k)
{
	int p=0;
	for(int i=k;i<=n;i++)
	{
		if(!trie[p].soon[s[i-1]-'0']) trie[p].soon[s[i-1]-'0']=++tot;
		p=trie[p].soon[s[i-1]-'0'];
		trie[p].cnt++;
	}
}
void search(int qwq)
{
	if(trie[qwq].cnt>1) cout<<trie[qwq].cnt<<"\n";
	if(trie[qwq].soon[0]) search(trie[qwq].soon[0]);
	if(trie[qwq].soon[1]) search(trie[qwq].soon[1]);
}
```

---

## 作者：Saliеri (赞：1)

既然后缀数组、后缀自动机都能做，后缀树也来试试？

___

一个重复多次的子串作为一个后缀的前缀，必然被包括在后缀树的一个非叶子的节点上。

然后它重复的次数就是其子树内部叶节点的个数。

然后有一个需要注意的是：后缀树一条边上包含了多个字符，以每个字符为结尾都表示一个串，多输出几次即可。

~~就这就这？没了，真的没了~~

___

代码：

后缀数的构建是臭名昭著的 $\operatorname{Ukkonen}$ 算法，不会右转 BFS。

```cpp
#include <cstdio>
#include <cstring>
const int maxn = 6e3+5,INF = 0x3f3f3f3f;
inline int max(int a,int b){return a>b?a:b;}
int rem,last;
int ch[maxn][3],len[maxn],beg[maxn],link[maxn],str[maxn],siz[maxn],tot,m;
int New(int bg,int l){return len[++tot]=l,beg[tot]=bg,link[tot]=1,tot;}
void append(int x){
	for(int q=(str[++m]=x,++rem,1),nq;rem;last>1?last=link[last]:--rem){
		for(;rem>len[ch[last][str[m-rem+1]]];rem-=len[last=ch[last][str[m-rem+1]]]);
		int &p = ch[last][str[m-rem+1]];
		if(!p)p=New(m-rem+1,INF),q=link[q]=last;
		else if(x==str[beg[p]+rem-1])return q=link[q]=last,void();
		else nq=New(beg[p],rem-1),ch[nq][x]=New(m,INF),ch[nq][str[beg[p]+=rem-1]]=p,len[p]-=(rem-1),(q=link[q]=p=nq); 
	}
}
char s[maxn];
int l,ans;
void dfs(int u){
	if(len[u] > l)return siz[u] = 1,void();
	for(int i=0;i<=2;++i)
		if(ch[u][i] && (u^1||i^2))
			dfs(ch[u][i]),siz[u] += siz[ch[u][i]];
}
void getans(int u){
	if(len[u] > l)return ;
	if(siz[u] > 1)
		for(int i=1;i<=len[u];++i)
			printf("%d\n",siz[u]);
	for(int i=0;i<=2;++i)
		if(ch[u][i]&&(u^1||i^2))getans(ch[u][i]);
}
int main(){
	scanf("%d",&l);
	scanf("%s",s);
	last = tot = 1,len[0] = INF;
	for(int i=0;i<l;++i)append(s[i]-'0');
	append(2),dfs(1),getans(1);
	return 0;
}
```

---

## 作者：ChenJr (赞：1)

对于这个题目，我们显然可以用两种处理后缀的数据结构进行处理。

## 1：后缀自动机：

个人觉得在这个题中，用后缀自动机去解决会相对来说比较好理解。

我们知道，在后缀自动机上的结点状态$st$，若前一个状态通过字符$c$与$st$相连，那么结点$st$表示的是$endpos$相同的子串的集合。而该点的$endpos$则代表的是以$c$为结尾的串的出现的位置集合。因此我们发现，对于一个结点$st$，它的$endpos$集合的大小即是当前结点对应的子串的出现次数。那么显然，我们只需要把每一个状态$st$的$|endpos|$求出即可。

而要求$|endpos|$，我们只需要把$parent$树反向建出来，自底向上去更新子树的大小即是$|endpos|$。

最后我们只需要在后缀自动机上贪心的根据字典序对每一个子串进行搜索即可。总的时间复杂度为$\mathcal{O}(n^2)$

## 2：后缀数组：

首先大概有这样的一个性质：对于两个不相同的后缀$u$,$v$，如果$lcp(u,v)$不为$0$，那么字符串$u$中长度在$[1,lcp(u,v)]$范围内的前缀必定在$v$中出现过至少一次。（因为每一个后缀都各不相同，而如果出现相同的前缀，那么这个前缀必定在原串出现至少$2$次）

那么我们考虑将所有的后缀按照字典序进行排序。因为所有的后缀都按照字典序进行排序了，那么如果存在一个串，满足：$lcp(i,i-1)\le lcp(i+1,1)$，那么$ Str[rk[i]] $ 这个串的前缀必定也在串 $ Str[rk[i+1]] $ 出现过。因此，我可以按照字典序枚举每一个后缀 $ rk[i] $ ，并分别枚举长度为 $ 1 \le j \le height[i] $ 的子串，我们发现，如果在后面的位置 $ k (i+1 \le k \le n) $ 中出现 $ height[k] \ge j $ 那么说明长度为 $j$ 的子串也会在第 $k$ 个后缀中出现，因此我们只需要记录第一个不满足 $ height[k] \ge j $ 的位置 $k$ ，那么最后的答案即为 $ k-i+1 $ 。

这样的整体时间复杂度为$\mathcal{O}(n^2)$

# 代码：

## SAM:

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define maxn 10005
using namespace std;
char str[maxn];
vector<int>res;
struct SAM{
    int next[maxn*2][2],fa[maxn*2],len[maxn*2];
    int last,cnt;
    int cntA[maxn*2],A[maxn*2];
    int num[maxn*2];
    void clear(){
        last=cnt=1;
        fa[1]=len[1]=0;
        memset(next[1],0,sizeof(next[1]));
    }
    void init(char *s){
        while(*s){
            Insert(*s-'0');
            s++;
        }
    }
    void Insert(int c){
        int p=last;
        int np=++cnt;
        memset(next[cnt],0,sizeof(next[cnt]));
        len[np]=len[p]+1;
        last=np;
        while(p&&!next[p][c]) next[p][c]=np, p=fa[p];
        if(!p) fa[np]=1;
        else{
            int q=next[p][c];
            if(len[q]==len[p]+1) fa[np]=q;
            else{
                int nq=++cnt;
                len[nq]=len[p]+1;
                memcpy(next[nq],next[q],sizeof(next[q]));
                fa[nq]=fa[q];
                fa[np]=fa[q]=nq;
                while(next[p][c]==q) next[p][c]=nq, p=fa[p];
            }
        }
    }
    void build(){
        memset(cntA,0,sizeof(cntA));
        memset(num,0,sizeof(num));
        int n=strlen(str);
        for(int i=1;i<=cnt;i++) cntA[len[i]]++;
        for(int i=1;i<=n;i++) cntA[i]+=cntA[i-1];
        for(int i=cnt;i>=1;i--) A[cntA[len[i]]--]=i;
        int tmp=1;
        for(int i=0;i<n;i++){
            num[tmp=next[tmp][str[i]-'0']]=1;
        }
        for(int i=cnt;i>=1;i--){
            int x=A[i];
            num[fa[x]]+=num[x];
        }
    }
    void dfs(int x){
        if(num[x]>1&&x!=1) res.push_back(num[x]);
        for(int i=0;i<2;i++){
            if(next[x][i]!=0)
                dfs(next[x][i]);
        }
    }
}sam;
int main()
{
    int n;
    scanf("%d%s",&n,str);
    sam.clear();
    sam.init(str);
    sam.build();
    sam.dfs(1);
    for(auto it:res){
        printf("%d\n",it);
    }
    return 0;
}
```

## SA：

```cpp
#include <bits/stdc++.h>
#define maxn 10010
using namespace std;
int n,rk[maxn],sa[maxn],height[maxn],tmp[maxn],cnt[maxn];
char str[maxn];
void SA(int n,int m){
    int i,j,k;
    n++;
    for(i=0;i<n+5;i++) rk[i]=sa[i]=height[i]=tmp[i]=0;
    for(i=0;i<m;i++) cnt[i]=0;
    for(i=0;i<n;i++) cnt[rk[i]=str[i]]++;
    for(i=1;i<m;i++) cnt[i]+=cnt[i-1];
    for(i=0;i<n;i++) sa[--cnt[rk[i]]]=i;
    for(k=1;k<=n;k<<=1){
        for(i=0;i<n;i++){
            j=sa[i]-k;
            if(j<0) j+=n;
            tmp[cnt[rk[j]]++]=j;
        }
        sa[tmp[cnt[0]=0]]=j=0;
        for(i=1;i<n;i++){
            if(rk[tmp[i]]!=rk[tmp[i-1]]||rk[tmp[i]+k]!=rk[tmp[i-1]+k])
                cnt[++j]=i;
            sa[tmp[i]]=j;
        }
        memcpy(rk,sa,n*sizeof(int));
        memcpy(sa,tmp,n*sizeof(int));
        if(j>=n-1) break;
    }
    //get height[]
    i=0,k=0,height[0]=0;
    for(j=rk[0];i<n-1;i++,k++){
        while(~k&&str[i]!=str[sa[j-1]+k]){
            height[j]=k--;
            j=rk[sa[j]+1];
        }
    }
}
int main()
{
    int n;
    scanf("%d%s",&n,str);
    int len=strlen(str);
    SA(len,200);
    for(int i=2;i<=n;i++){
        for(int j=height[i-1]+1;j<=height[i];j++){
            int k=i;
            while(height[k]>=j) k++;
            if(k-i+1<=0) continue;
            printf("%d\n",k-i+1);
        }
    }
    return 0;
}
```

---

## 作者：ez_lcw (赞：1)

# 后缀自动机做法

看到很多巨佬用$SA$或$Trie$，我这里介绍一下后缀自动机的做法。我觉得用后缀自动机的话**码量更小、更易理解**。

这道题其实用后缀自动机挺暴力的，其主要思路如下：

1. **首先先对原串构建后缀自动机。**

1. **然后把每个串的出现次数在$parent$树上统计出来，这一段将会涉及到基数排序**

1. **最后用$dfs$按$0\to1$的顺序在$parent$树上遍历，输出答案。**

具体代码和详细注释如下：

```
#include<bits/stdc++.h>

#define N 3010

using namespace std;

struct Tree
{
	int ch[2],len,fa,size;//size指当前节点对应串的出现次数
}t[N<<1];

int n,last=1,tot=1,buckets[N],a[N<<1];
char s[N];

void insert(int c)//后缀自动机模板
{
	int p=last,np=last=++tot;
	t[np].len=t[p].len+1,t[np].size=1;//这里把这个串的出现次数设为1
	for(;p&&!t[p].ch[c];p=t[p].fa)t[p].ch[c]=np;
	if(!p)t[np].fa=1;
	else
	{
		int q=t[p].ch[c];
		if(t[q].len==t[p].len+1)t[np].fa=q;
		else
		{
			int nq=++tot;
			t[nq]=t[q];
			t[nq].len=t[p].len+1;
			t[nq].size=0;//因为这个新节点不计入size统计内（因为它是被别人复制的节点），所以要把size设为0
			t[np].fa=t[q].fa=nq;
			for(;p&&t[p].ch[c]==q;p=t[p].fa)t[p].ch[c]=nq;
		}
	}
}

void count()
{
	for(int i=1;i<=tot;i++)buckets[t[i].len]++;//按串的长度排序，这样能保证统计size时是按从parent树的底部到根部的
	for(int i=1;i<=n;i++)buckets[i]+=buckets[i-1];
	for(int i=1;i<=tot;i++)a[buckets[t[i].len]--]=i;
	for(int i=tot;i>=1;i--)t[t[a[i]].fa].size+=t[a[i]].size;//统计size
}

void dfs(int u)
{
	if(!u)return;//如果是空节点就return
	if(u!=1&&t[u].size>1)printf("%d\n",t[u].size);//注意，当这个点不是根节点且它的出现次数大于1时才输出
	dfs(t[u].ch[0]);//遍历左儿子
	dfs(t[u].ch[1]);//遍历右儿子
}

int main()
{
	scanf("%d%s",&n,s+1);
	for(int i=1;i<=n;i++)insert(s[i]-'0');//对原串构造后缀自动机
	count();//统计size
	dfs(1);//遍历parent树并输出答案
	return 0;
}
```


---


# 单词背诵

## 题目描述

灵梦有 $n$ 个单词想要背，但她想通过一篇文章中的一段来记住这些单词。

文章由 $m$ 个单词构成，她想在文章中找出连续的一段，其中包含最多的她想要背的单词（重复的只算一个）。并且在背诵的单词量尽量多的情况下，还要使选出的文章段落尽量短，这样她就可以用尽量短的时间学习尽可能多的单词了。

## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的数据，$n \le 50$，$m \le 500$；
- 对于 $60\%$ 的数据，$n \le 300$，$m \le 5000$；
- 对于 $100\%$ 的数据，$n \le 1000$，$m \le 10^5$。

## 样例 #1

### 输入

```
3
hot
dog
milk
5
hot
dog
dog
milk
hot
```

### 输出

```
3
3
```

# 题解

## 作者：louhao088 (赞：282)

## 思路

很明显，这就是一道 HASH，在这里我们使用 map + string，代码难度就大大下降了。

我们每次记录此时有多少个单词，若比之前多，则直接更新长度与数量。

然后在更新左边 $l$，若最左边的单词不想背，或后文已出现就更新，把长度去最短即可。

## 时间

$O(m \log m)$，非常优秀。

## 最短代码

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>sum;
map<string,bool>flag;
int ans1,ans2,n,m,l;
string s[100005],s1; 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>s1,flag[s1]=1;//标记单词想不想背
	cin>>m;l=1;
	for(int i=1;i<=m;i++)
	{
		cin>>s[i];
		if(flag[s[i]])sum[s[i]]++;//记录单词出现次数
		if(sum[s[i]]==1)ans1++,ans2=i-l+1;//更新
		while(l<=i)
		{
			if(!flag[s[l]]){l++;continue;}//判断要不要背
			if(sum[s[l]]>=2){sum[s[l]]--,l++;continue;}//有没有重复出现
			break;
		}
		ans2=min(ans2,i-l+1);//更新
	}
	cout<<ans1<<endl<<ans2<<endl;
	return 0;
}
```

如果有帮到你，请点赞支持，谢谢。

---

## 作者：kkksc03 (赞：214)

这道题如果直接模拟只能够过四个数据，所以我用了二分查找的方法，然后找出相连的包含最多要背的单词并且单词长度最短。（注意，文段中的单词可能是多余的，也就是不用背的。）

代码如下

```delphi

var a:array[1..1000] of string[10];
    b:array[1..100000] of string[10];
    len,f:array[0..1000] of longint;
    s:array[0..100000] of longint;
    i,j,m,n,t:longint;
procedure qsort(l,r:longint);
var i,j:longint;
    mid,st:string[10];
begin
  i:=l;j:=r;
  mid:=a[(l+j) div 2];
  while i<=j do
   begin
     while a[i]<mid do inc(i);
     while a[j]>mid do dec(j);
     if i<=j then
      begin
        st:=a[i];a[i]:=a[j];a[j]:=st;
        inc(i);dec(j);
      end;
   end;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
procedure half(st:string[10];l,r:longint);
var mid:longint;
begin
  if l+1<r then
   begin
     mid:=(l+r) div 2;
     if a[mid]<=st then half(st,mid,r) else half(st,l,mid);
   end
  else
   begin
     if a[l]<>st then exit;
     if f[l]=0 then inc(t);
     inc(f[l]);
     s[i]:=l;
   end
end;

begin
  readln(n);
  for i:=1 to n do readln(a[i]);
  qsort(1,n);
  readln(m);
  for i:=1 to m do readln(b[i]);
  for i:=1 to n do len[i]:=maxint;
  i:=0;
  while i<m do
   begin
     inc(i);
     half(b[i],1,n+1);
     while (j<i)and((f[s[j]]>1)or(s[j]=0)) do
      begin
        if s[j]<>0 then dec(f[s[j]]);
        inc(j);
      end;
     if i-j+1<len[t] then len[t]:=i-j+1;
   end;
  writeln(t);
  writeln(len[t]);
end.

```

---

## 作者：Merak (赞：45)

Ps. QAQ细节啊细节啊细节啊细节很重要！！！！


因此WA了n多次还挂在一个最简单的情况上……sad


————————————————————————————————————————————————————————————


**题目要求**


给定n个单词和一个长为m的段落，要求在该段落内找出包含给定单词种类数最多且最短的最优段落，求该段落包含给定单词的种类数和段落长度。


**思路分析**


为了方便叙述，我们约定用数组a[ ]来存储给定的n个单词（将其称为目标单词），用数组b[ ]来按照顺序存储给定的m段内的m个单词。


初步思路：


大致思路应该是很好想的，差不多就是对段落整体扫描一遍来求最优段落。首先用Hash来记录n个给定单词和m个段落内单词，然后对比得出给定段落内包含了多少种目标单词，最后对段落整体扫描一遍来寻得最优段落。


那么重点是，如何对段落整体扫描呢？


我们在Hash时首先对段落扫描做好预先处理：对a[ ]内单词Hash时记录a[ ]的Hash值，为了方便与b[ ]比较，我们将其用bool数组存储（这样就相当于用数组来表示该Hash值是否出现过）。如果这个地方没看懂的话，去看一下下面的代码应该就理解了。对b[ ]内单词Hash时，我们用vis[]数组来对其是否为目标单词做标记，如果该单词的Hash值在a[ ]中已经出现过，说明该单词是目标单词之一，则将其对应的vis[ ]标记为1，同时用cnt记录出现的目标单词的种类数。


完成了预先处理，接下来我们来讨论如何对段落进行扫描求解最优段落。


我们采用枚举区间左右端点的方法来对段落进行扫描。这里我是从最右端向左开始枚举区间。如果觉得从左开始枚举更好理解的话，翻到我的题解底部~


我们首先对左端点进行移动。移动左端点的同时，我们使用appear[]记录一下目标单词在当前l,r包含的段落内出现的次数。如果该单词是初次出现，那么cnt--（或者再重新定义一个变量，出现一种++一下，最后比较是否和cnt相等也可），同时appear[ ]++（不是初次出现也要加，键见代码）。如果cnt=0了，那么说明当前我们枚举的段落已经包含了所有种类的b[ ]内目标单词。这时首先我们更新ans值来存储当前的最优解，然后对右端点进行操作。然后如果当前我们的右端点上的单词不是目标单词，那么我们就把它舍去，即r--；如果右端点上的单词在当前枚举段落内已经重复出现过，那么我们也可将其舍去。如果右端点上的单词是目标单词且仅出现一次，那么我们把它舍去的时候就再将cnt++，然后进行下一次扫描。这个地方是最难理解的，如果想不明白的话手动模拟一下。


最后附上代码（已包含注解）：

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long ll;
const int p=909043; 
int base=313;
int n,m,cnt,ans=1<<30,l,r;
char s[33];
int a[100003],b[100003];
int appear[5000003],vis[5000003],pre[5000003];
//pre[]记录灵梦要背的单词
//vis[]记录灵梦要背的单词在给出的段落中是否出现
//appear[]记录要背的单词在目前搜索到的段落中出现的次数 
int hashs(char qwq[])
{
    int len=strlen(qwq);
    int sum=0;
    for(int i=0;i<len;i++)
    {
        sum=(sum*base+qwq[i])%p;
    }
    return sum;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        a[i]=hashs(s);
        pre[a[i]]=1;
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        cin>>s;
        b[i]=hashs(s);
        if(pre[b[i]]&&!vis[b[i]])
        {
            vis[b[i]]=1;
            cnt++;
        }
    }
    if(cnt==0)
    {
        printf("0\n0");//一定要记得讨论这种情况QAQQ 
        return 0;
    }
    else printf("%d\n",cnt);
    l=m;//从右向左扫 
    r=m;
    while(true)
    {
        if(!cnt)//cnt==0时对答案进行更新 
        {
            while(!vis[b[r]]) r--;
            //如果区间右端点不是灵梦要背的单词就将段落长度缩小 
            ans=min(ans,r-l);//想想为什么不是(r-l+1)呀qwq    
            if(appear[b[r]]>=1) 
            {
                if(appear[b[r]]==1)
                {
                    cnt++;
                }
                appear[b[r]]--;
                r--;
            }
            //如果右端点的单词已经在段落里出现过了，就可以缩小段落长度
            //如果右端点的单词只出现了一次，那么我们将右端点向左移的同时要cnt++(因为这种单词在当前枚举段落内已经不再出现啦) 
        }
        else
        {
            if(l==0) break; 
            if(vis[b[l]])
            {
                if(!appear[b[l]])//如果这种单词在当前枚举的段落里初次出现，那么就说明当前段落内的种类数加一 
                {
                    cnt--;
                }
                appear[b[l]]++;//该种单词出现的次数增加 
            }
            l--;
        }
    }
    printf("%d",ans);
    return 0;
}
```
唔，最后推荐一份和我思路差不多的代码：Uid为35527，可以在提交记录里找到。个人认为TA的代码比我的更易理解，写起来也比我的简单，某些细节优化做的也比我到位，觉得从右端点枚举不如从左端点方便理解一些的话就去看一下TA的吧。


---

## 作者：早右昕 (赞：28)

# 标题：优(~~c~~)美(~~n~~)的(~~m~~)的“尺取法”


显然，这是一道“尺取法”的模版题。话说尺取法，简单地说，其作用就是对给定的一个序列，在序列中寻找包含全部需求的，长度最小的一段子序列的O(n)的优秀算法。事实上，它的作用远不止这些。


其过程通常可以这样描述：

- 初始化左右下标l,r到适当位置;

- 不停的向右移动r，直到r出界或者[l,r]自区间已经满足要求

- 接下来```ans=min(ans,r-l+1)```，注意程序中往往区间是指[l,r+1]，所以```ans=min(ans,r-l)```;
- 移动l到适当位置。重复第一个过程。

算法的正确性是显然的（这样一定能扫描到最优解，~~不信你在草稿纸上画一画？~~）下面给出代码，注意特判：

```cpp

#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int P=10000019;
int str_hash(char* a) {
    int ln=strlen(a);
    long long res=0;
    for(int i=0;i<ln;i++) {
        res*=31,res+=a[i]-'a';
        res%=P;
    }
    return res%P;
}
int n,m,p1,p2=1<<30;
int a[1001],b[100010];
int vis[P];
bool need[P];
int main() {
    char in[101];
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
        scanf("%s",in);
        a[i]=str_hash(in);
        need[a[i]]=1;
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++) {
        scanf("%s",in);
        b[i]=str_hash(in);
        if(need[b[i]]&&!vis[b[i]]) {
            p1++,vis[b[i]]=1;  
        }
    }
    if(p1==0) {
        printf(0\n0\n);
        return 0;
    }
    memset(vis,0,sizeof vis);
    int l=1,r=1,cnt=p1;
    while(1) {
        if(!cnt) {
            while(!need[b[l]]) l++;
            if(l==m+1) break;
            p2=min(p2,r-l);
            if(vis[b[l]]==1) cnt++;
            if(vis[b[l]]>=1) vis[b[l]]--,l++; 
        } else {
            if(r==m+1) break;
            if(need[b[r]]) {
                if(!vis[b[r]]) cnt--;
                vis[b[r]]++;
            }
            r++;
        }
    }
    printf("%d\n%d\n",p1,p2);
    return 0;
}

```

---

05/11 排版更新

---

## 作者：pengyule (赞：18)

**这是一篇**
- 简洁易懂
- 解法详细
- 代码优质

**的题解**

希望能够帮到您。
- - -
## 题意
首先输入 $m$ 个要背的单词，要你从接下来输入的 $n$ 个单词中找到一个连续的区间，使得这个区间是所有区间中包含最多的要背的单词，且是满足以上条件的区间中长度最短的一个，输出长度。同时，在输出长度之前你还要输出这所有 $n$ 个单词中包含了多少个要背的单词。

## 解决第一问

当然这是一个中间的过程，比较简单的问题，只需要在发现一个要背的单词的时候判断是不是已经统计过了他，如果没有，就把他统计一下，并且标记他为统计过了。代码如下。

```cpp
    ios::sync_with_stdio(false);
    string str;
    cin>>m;
    for(int i=1;i<=m;i++) cin>>str,book[str]=1;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) if(book[a[i]] && !flag[a[i]]) val++,flag[a[i]]=1;
    cout<<val<<'\n';  //val即为第一问答案
```

## 解决第二问

可以知道我们要找的这个区间中所包含的要背的单词数即为 $val$。我们发现区间的长度的枚举是具有单调性的，就是说，我们区间越长，就越有可能包含更多要背的单词，区间越短，包含的要背的单词数就越少。

所以我们自然想到了二分答案，要二分的，是区间的长度。我们需要 $check$ 的文章中每一个长度为 $mid$ 的区间最多能够包含多少个要背的单词。

针对 $check$，如果我们枚举每一个区间，像下面那样子：
```cpp
for(int i=1;i<=n-mid+1;i++,flag.clear(),ans=max(ans,cnt))
	for(int j=i;j<=i+mid-1;j++)
    	if(book[a[j]] && flag[a[j]]==0) cnt++;
return ans;
```
显然是非常低效的，复杂度 $O(n^2)$。

更高效的算法是滑动窗口。我们想，像下图，从黑色框（前一次枚举的区间）到红色框（当前正要枚举的区间），如果我们已经知道了黑色框有多少个要背的单词，那么我们该如何推导出红色框中有多少要背的单词呢？（为了方便，记之前区间的答案为 $cnt$。）

![](https://cdn.luogu.com.cn/upload/image_hosting/petspwmi.png)

1. 如果 $a_{c0}$ 舍掉之后区间中会少一种单词，那么就把 $cnt$ 减一。否则（舍掉 $a_{c0}$ 之后实则区间中还有其他的 $a_{c0}$，他出现了多次），那么舍掉就舍掉吧，没影响，$cnt$ 不变。
2. 如果 $a_i$ 加上之后区间中会多一种单词，那么就把 $cnt$ 加一。否则（区间中本来就有 $a_i$ 这个单词），那加上了这个 $a_i$ 没影响，$cnt$ 不变【这里需要注意，如果“区间中本来就有的 $a_i$”其实是 $a_{c0}$ 呢？那是不是说我们就白白的让 $cnt$ 减一了？其实我们不必多虑——这种情况或许对答案有影响，可是事实证明不会影响最终的答案，当然，如果你推翻了此结论，你可以私信我 $\color{silver}{\tiny{也可以私信出题人--划掉}}$】。

这一段的代码如下：
```cpp
int check(int x){
    int c0=1,cnt=0,ans=0;
    vis.clear();
    for(int i=1;i<=x;i++) {
        if(book[a[i]] && !vis[a[i]]) cnt++;
        if(book[a[i]]) vis[a[i]]++;
    }
    for(int i=x+1;i<=n;i++){
        ans=max(cnt,ans);
        if(book[a[i]] && !vis[a[i]])
            cnt++;
        if(book[a[c0]] && vis[a[c0]]-1==0) 
            cnt--;
        vis[a[i]]++,vis[a[c0]]--;
        c0++;
    } 
    return max(cnt,ans);
}
int search(){
    int L=-1,R=n,mid;
    while(L<R-1){
        mid=(L+R)/2;
        if(check(mid)==val) R=mid;
        else L=mid;
    }
    return R;
}
```

到此，主要部分都说完了。

## 完整代码

```cpp
#include <iostream>
#include <cmath>
#include <string>
#include <unordered_map>
using namespace std;
int m,n,val;
string a[100005];
unordered_map<string,int> book,flag,vis;
int check(int x){
    int c0=1,cnt=0,ans=0;
    vis.clear();
    for(int i=1;i<=x;i++) {
        if(book[a[i]] && !vis[a[i]]) cnt++;
        if(book[a[i]]) vis[a[i]]++;
    }
    for(int i=x+1;i<=n;i++){
        ans=max(cnt,ans);
        if(book[a[i]] && !vis[a[i]])
            cnt++;
        if(book[a[c0]] && vis[a[c0]]-1==0) 
            cnt--;
        vis[a[i]]++,vis[a[c0]]--;
        c0++;
    } 
    return max(cnt,ans);
}
int search(){
    int L=-1,R=n,mid;
    while(L<R-1){
        mid=(L+R)/2;
        if(check(mid)==val) R=mid;
        else L=mid;
    }
    return R;
}
int main()
{
    ios::sync_with_stdio(false);
    string str;
    cin>>m;
    for(int i=1;i<=m;i++) cin>>str,book[str]=1;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) if(book[a[i]] && !flag[a[i]]) val++,flag[a[i]]=1;
    cout<<val<<'\n'<<search()<<endl;
    return 0;
}  //p.s.由于卡常，请用 c++17(luogu c++ 不支持 unordered_map)外加O2优化提交
```

---

## 作者：zhouenji (赞：14)

这道题感觉有点单调队列的影子

考虑这题的时候，我们可以先固定右端点，队列里存的是左端点，每次更新答案时，

只需看左端这个元素在左端和右端之间有没有出现过，出现了那么左端点向右移动，然后更新答案

代码如下：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<map>
using namespace std;
const int maxn=100000+10;
int n,m,h,t;
int tot,num,ans=0x7f7f7f7f;
map<string,int>mapp;
char s[maxn];
int a[maxn],b[maxn],q[maxn];
bool vis[maxn];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",s);
        mapp[s]=i;
    }scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%s",s);a[i]=mapp[s];//printf("%d ",a[i]);
        if(a[i]==0)continue;
        if(!vis[a[i]])tot++,vis[a[i]]=true;
    }h=1;t=0;
    for(int i=1;i<=m;i++)
    {
        if(b[a[i]]==0 && a[i]!=0)
        {
            num++;
        }b[a[i]]=i;q[++t]=i;
        while(h<=t && q[h]<b[a[q[h]]])h++;
        if(num==tot)ans=min(ans,i-q[h]+1);
    }
    if(num==0)printf("0\n0\n");
    else printf("%d\n%d\n",tot,ans);
}
```

---

## 作者：傅思维666 (赞：7)


## 题解：

#### 字符串哈希加尺取法枚举区间。

~~我不会告诉你这俩知识点我都是现学的~~。

一开始的思路约等于没有思路：挨个枚举，逐字符匹配（憨批），区间枚举。后来发现恶心的要命，根本连打的勇气都没有。

于是字符串哈希上场了。我对哈希的理解就是把一个字符串变成一个数，简化字符串匹配的过程。

关于哈希，如有不会请移步本蒟蒻的总结博客：

[浅谈字符串Hash](https://www.cnblogs.com/fusiwei/p/11736860.html)

这样的话，我们把要背的字符串的哈希值存到a数组中，并打上标记。把文章字符串的哈希值存到b数组中。然后核对标记，就可以求出第一问了。

第二问是本题的难点。

如何求出一个最短的符合要求的序列长度呢？

暴力的思路是区间枚举左右端点，核对是否符合条件。但是这样做显然不行，于是我们想到用尺取法优化区间枚举。

关于尺取法，如有不太了解的请移步本蒟蒻的总结博客：

[尺取法讲解](https://www.cnblogs.com/fusiwei/p/11313817.html)

了解了尺取法的基本内涵。针对于这道题，我们利用尺取的实现过程是这样的：

因为我们已经求得了第一问的答案，那么我们需要用这个已知答案来确定这个区间是否是可行的解。具体操作方法是：建立一个$appear[]$数组，存每个单词（当然是他们的哈希值）出现的次数。如果这个词是第一次出现，那么显然目前区间中的单词数量应该加一。同时，如果这个词出现的次数要是大于等于1的话，那么就尝试进行舍去，看一下有没有更优的选择。

这个地方会比较难理解：我把它叫做**”不能偏安一隅“**，我们不能只是在$appear[]$大于1的时候舍去这个点，等于1的时候一样要舍，为什么呢？就是因为，假如你选择了这个单词作为区间中唯一出现的目标单词，但是它和区间中距离它最近的另一个目标单词非常远，但是区间外面还有一个单词，和距离它最近的目标单词超级近。这个时候你应该选哪一种呢？显而易见，那个更近的对答案的贡献是更优的。所以，我们要在$appear[]$等于1的时候也进行舍去，然后继续扫描。因为这个时候的$ans$已经被更新了，所以我们不愁答案错误。

然后就求得了第二问的答案。

总的来说，这道题的思路还是比较清晰的，并没有什么太大的难点。主要是尺取法部分的代码实现。以及，提醒大家，数组的大小要开的和模数一样大，否则就会有几率RE...

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int maxn=1010;
const int maxm=1e5+10;
const int mod=1e6;
const int p=31;
const int INF=1e9;
int n,m,cnt,ans=INF,l,r;
int a[maxn],b[maxm],appear[mod];
char input[110];
bool need[mod],v[mod];
int hash(char s[])
{
    int len=strlen(s);
    ll ret=0;
    for(int i=0;i<=len;i++)
    {
        ret*=p,ret+=s[i]-'a';
        ret%=mod;
    }
    return ret%=mod;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",input);
        a[i]=hash(input);
        need[a[i]]=1;
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%s",input);
        b[i]=hash(input);
        if(need[b[i]] && !v[b[i]])
            cnt++,v[b[i]]=1;
    }
    if(!cnt)
    {
        puts("0");
        puts("0");
        return 0;
    }
    else
        printf("%d\n",cnt);
    l=1,r=1;
    while(1)
    {
        if(cnt)
        {
            if(r>m)
                break;
            if(need[b[r]])
            {
                if(!appear[b[r]])
                    cnt--;
                appear[b[r]]++;
            }
            r++;
        }
        else
        {
            while(!need[b[l]])
                l++;
            if(l>m)
                break;
            ans=min(ans,r-l);
            if(appear[b[l]]==1)
                cnt++;
            if(appear[b[l]]>=1)
                appear[b[l]]--,l++;
        }
    }
    printf("%d",ans);
    return 0;
}
```



---

## 作者：XyzL (赞：6)

详细代码与注释如下：

```cpp
//#pragma GCC optimize(3)

#include<bits/stdc++.h>

using namespace std;

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') {
		if(c == '-') {
			f = -1;
		}
		c = getchar();
	}
	while (c <= '9' && c >= '0') {
		x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
	}
	return x * f;
}

#define Mem(a, x) memset(a, x, sizeof(a))
#define Binary l + r >> 1
#define Inf 2147483647
#define Maxn 1001
#define Maxm 100001

const int kM = 1000007;  // 质数

int h[kM], a[Maxm], b[Maxn];

string s[Maxn];

int n, m, ans, ansl;

inline int Hash(int x) {  // 计算第x个字符串的哈希值
	int v = 0;
	for (register int i = 0; i < s[x].size(); ++i) {  // 枚举每个字符
		v = ((v << 8) + s[x][i]) % kM;  // 移位，与当前字符相加，取模
	}
	return v;
}

inline int Find(int x) {  // 查找第x个字符串
	int p = Hash(x);
	while (h[p]) {            // 位置有字符串
		if (s[h[p]] == s[x]) {  // 找到相等的字符串
			return p;
		}
		p = (p + 1) % kM;  // 线性探测
	}
	return p;  // 找到空位置
}

inline void Calc() {
	int r = 0; // 从第一个单词开始需要背诵的右边界
	b[0] = -1; // 不考虑不需要背的单词
	for (register int i = 1; i <= m; ++i) {  // 按顺序检查单词
		if (!b[a[i]]) {               // 第一次出现
			ans++;                      // 累加答案
			r = i;         // 更新需要背的有边界
			b[a[i]] = -1;  // 标记出现
		}
	}
	if (!ans) {  // 没有答案则无需继续计算
		return;
	}
	for (register int i = m, t; i >= 1; --i) {  // 求出每个数下一个相同数的位置
		t = a[i];
		if (t) {        // 当前位置有数
			a[i] = b[t];  // 记录下一个相同数的位置
			b[t] = i;     // 记录当前数的位置
		}
	}
	ansl = r;                           // 初始化答案
	for (register int i = 1; a[i] != -1; ++i) {  // 依次从 i + 1开始背诵
		r = max(r, a[i]);                 // 至少要背到下一个相同数
		ansl = min(ansl, r - i);          // 更新答案
	}
	return;
}

int main() {
	n = read();
	for (register int i = 1; i <= n; ++i) {
		cin >> s[i];
		int p = Find(i);  // 查找位置
		h[p] = i;         // 插入
	}
	m = read();
	for (register int i = 1; i <= m; ++i) {
		cin >> s[0];
		int p = Find(0);  // 查找位置
		a[i] = h[p];      // 记录编号
	}
	Calc();
	printf("%d\n", ans);
	printf("%d\n", ansl);
	return 0;
}
```


---

## 作者：Tyher (赞：4)

## 对于第二问，提供一种二分的想法

```

    Hash每个字符串，这里就不细讲了
    
    显然，选择的文章段落尽可能的长，就越有可能更优秀
    
    即m个数全部选一定满足，只选n个数不太可能满足
    
    是具有单调性的
    
    二分区间长度，le=n,ri=m，时间复杂度O(logn)
    
    现在的问题是，怎么在O(n)的复杂度里判断当前的区间长度是否可行
    
    这里类似于莫队的思想
    
    假设二分出来的长度是len
    一个单词s被学习过的次数是cs[s]
    第一问的答案是ans
    当前学习过的单词个数为res
    
    左端点l，右端点r,间隔为len
    那么我们考虑向左移动
    删去左端点对res的贡献是什么?
    
    如果当前单词s是应当要学习的
    并且cs[s]==1
    那么这个单词的贡献就没有了 res--
    cs[s]--;
    
    右端点贡献？
    如果当前单词s是应当要学习的
    并且cs[s]==0
    那么这个单词的贡献就产生 res++
    cs[s]++;
    
    res==ans即合法
    
    总时间复杂度O(nlogn)
    
    附代码
    
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#define il inline
#define rg register
#define ll long long
#define ld long double
#define N 100001
#define M 1500000
#define inf 2147483647
#define mod 1226959
#define base 27
using namespace std;
int n,m,S[N],T[N];
int ans,jud,vis[M],Std[M];
string p[N],q[N];
il void re(rg int &x);
il int f(string x);
il int check(rg int len);
int main(){
	freopen("s.in","r",stdin);
	re(n);
	for(rg int i=1;i<=n;++i){
		cin>>p[i],S[i]=f(p[i]);
		vis[S[i]]++,Std[S[i]]=vis[S[i]];
	}
	re(m);
	for(rg int i=1;i<=m;++i){
		cin>>q[i],T[i]=f(q[i]);
		if(vis[T[i]])ans++,vis[T[i]]=0;
	}
	printf("%d\n",ans),jud=ans;
	if(ans==0){
		puts("0");
		return 0;
	}
	rg int le=n,ri=m;
	while(le<=ri){
		rg int mid=((le+ri)>>1);
		if(check(mid))ans=mid,ri=mid-1;
		else le=mid+1;
	}
	printf("%d",ans);
    return 0;
}
int cs[M];
il int check(rg int len){
	memset(cs,0,sizeof(cs));
	rg int cnt=0;
	for(rg int i=1;i<=len;++i)
		if(Std[T[i]]){
			if(!cs[T[i]])cnt++;
			cs[T[i]]++;
		}
	if(cnt==jud)return 1;
	for(rg int p=len+1;p<=m;++p){
		if(Std[T[p]]){
			if(!cs[T[p]])cnt++;
			cs[T[p]]++;
		}
		if(Std[T[p-len]]){
			if(cs[T[p-len]]==1)cnt--;
			cs[T[p-len]]--;
		}
		if(cnt==jud)return 1;
	}
	return 0;
}
il int f(string x){
	rg int now=0,i=0;
	while(x[i])
		now=(now*base+x[i])%mod,i++;
	return now;
}
il void re(rg int &x){
    x=0;rg int w=1;char c=getchar();
    while((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')w=-1,c=getchar();
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
    x*=w;
}

```

---

## 作者：_Atyou (赞：3)

## 算法： 单调队列？

~~吹爆平板电视！~~ 能用黑科技的话，何乐而不为呢

大致思路就是标记每个单词最后一次在文章中出现的位置， 然后可以维护一个含最多单词的区间， 并且左端点尽可能的靠右

每次遇到一个单词就压到队尾， 并且不断弹出队头的单词，直到队头的单词在队列中出现的位置是他最后一次在文章中出现的位置

然后不断更新答案

### 细节：

1） 要把字符串编号，两种方式:一种就是手写hash，一种就用map吧

听说map是O(logn) 貌似平板电视里的是O(1) 用了一下感觉飞快


2） 文章里出现的不一定是要背的单词，感觉这个都想的到吧，也就我蒟蒻到一开始因为这个WA。。。

3） 要背的单词不一定会在文章里出现，所以更新答案的时候就要注意点，多背单词比文章短的优先级更高，每出现一个从未在之前文章中出现的单词就把单词数+1， 长度其实就是当前位置到队头的位置那么长，我为了方便，直接设成无穷大，反正下面要更新。。。

代码：

```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;

#define reg register
const int N = 1000 + 5;

struct node { int pos, val; }; //pos就是压进队列时的位置， val就是编号
gp_hash_table<string, int> id;
int n, m, ans1, ans2; string str;
int v[N]; queue<node> q;

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin>>n;
    for (reg int i=1; i<=n; ++i) cin>>str, id[str]=i;
    ans1=ans2=0;
    cin>>m;
    for (reg int i=1; i<=m; ++i) {
        cin>>str; if (id.find(str)==id.end()) continue;
        int k=id[str];
        if (!v[k]) ++ans1, ans2=INT_MAX; //之前未出现单词这样处理
        v[k]=i; q.push((node){i, k});
        while (q.front().pos!=v[q.front().val]) q.pop(); //核心部分
        ans2=min(ans2, i-q.front().pos+1);
    }
    cout<<ans1<<endl<<ans2<<endl;
    return 0;
}

```

---

## 作者：梧桐灯 (赞：3)

map相信大家都知道，今天给大家~~隆重~~推荐一个时间快于map的东西——unordered_map。

### - 什么是unordered_map？

无序的map~~说了跟没说一样~~

~~可以理解为下标可以是任何奇奇怪怪的东西，理论访问时间为O(1)的吊打map的C++11用户才能用的福利~~

### - 如何使用unordered_map?

```
#include <unordered_map>
//其实万能头也行
```

当然首先得用C++11编译。

### - unordered_map的作用

~~是否，你曾因为桶的下标过大而不得不使用离散化？~~

~~是否，你曾因为字符串而放弃使用桶？~~

有了unordered_map，一切都不是问题，而且由于内容的无序性，它的时间要远远优于map（）

至于它的用法，基本等同于map，有兴趣的同学可以自行百度

贴代码：
```cpp
#pragma GCC optimize("Ofast")
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <string>
#include <unordered_map> //不加它编译过不了
using namespace std;

const int N = 1003, M = 100003;
unordered_map <string, int> w, k; //定义方法等同于map
int n, m;
string a[N], b[M];

int main () {
	scanf ("%d", &n);
	int i, j; for (i = 1; i <= n; ++i) {
		cin >> a[i];
		++w[a[i]];
	}
	scanf ("%d", &m);
	for (i = 1; i <= m; ++i) cin >> b[i];
	i = j = 1;
	int now = 0;
	int ans = 0, minlen = (1 << 30);
	while (j <= m) {
		if (w[b[j]] && !k[b[j]]) {
			++now;
			k[b[j]] = 1;
		} //如果该单词是要背的且在当前区间是第一次出现
		else ++k[b[j]]; 
		while (i <= j && (!w[b[i]] || k[b[i]] > 1)) {
			--k[b[i]];
			++i;
		} //如果左端点的单词在当前区间出现次数大于1则可以抛弃掉
		if (now > ans) {
			ans = now;
			minlen = j - i + 1;
		}
		else if (now == ans) minlen = min (minlen, j - i + 1);
		++j;
	}
	printf ("%d\n%d\n", ans, minlen);
	return 0;
}

```


---

## 作者：zzr8178541919 (赞：2)

做法1：Hash乱搞，判断一下

做法2：暴力map，用map求出第一个答案，然后用指针往后一扫过去，同时更新答案。

做法3：将字符串转成数字然后进行操作；

我用的是第二种做法，map可以直接在string上面操作，很快很方便。简单又自然。。。

```cpp
#include<cmath>
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
string a[200005];
map<string,int> v;
map<string,bool> v1,v2;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		string s1;
		cin>>s1;
		v1[s1]=1;
	}
	int ans1=0;
	int m;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		string ch;
		cin>>ch;
		a[i]=ch;
		if(v1[ch])
		{
			if(v2[ch])
			{
				ans1++;
				v2[ch]=1;
			}
		}
	}
	printf("%d\n",ans1);
	int head=1;
	int cnt=0;
	int ans2=1e9;
	for(int i=1;i<=m;i++)
	{
		if(v1[a[i]]==0)
		continue;
		string s=a[i];
		if(v[s]==0)
		cnt++;
		v[s]++;
		while((v1[a[head]]==0) || (v[a[head]]==0 && head<i))
		{
			v[a[head]]--;
			head++;
		}
		if(cnt==ans1)
		{
			ans2=min(ans2,i-head+1);
		}
	}
	if(ans2>=1e9)
	printf("0\n");
	else
	printf("%d\n",ans2);
	return 0;
}
```


---

## 作者：RyexAwl (赞：1)

# 第一问（哈希）
要使得包含单词最多，那么就需将文章中所有在单词表中出现过的单词全部统计。

而一个字符一个字符的比对复杂度过高，因此我们需要求出单词表与文章的字符串哈希，这样我们就可以$O(1)$比较了。而哈希之后的值是一个整数，那么我们目前的问题就转化为有两个数组$A[]$和$B[]$，$A[]$数组中有多少个不同的数在$B[]$中出现过。那么对于这个问题很显然我们可以建立一个$bool$数组$C[]$与$bool$数组$used[]$,扫 一遍$A[]$，以$A[]$中的每个元素为下标，赋值为$true$。扫一遍$B[]$，如果$C[B[i]]==true$且$used[B[i]]=false$那么$cnt++$，$used[B[i]]$赋值为$true$。

那么很显然我们就可以用哈希值作为$C[]$数组的下标（要保证在求哈希之模的数能作为数组下标）愉快的解决第一个问。
```cpp
    cin >> n;
    for (int i = 0; i < n; i++){
        cin >> s;
        have[hsh(s)] = true;
    }
    cin >> m;
    for (int i = 1; i <= m; i++){
        cin >> s;
        val[i] = hsh(s);
        if (have[val[i]] && !used[val[i]]){
            cnt++;
            used[val[i]] = true;
        }
    }
```


此步复杂度为$O(m)$

# 第二问
## 第二问暴力部分分
### $O(m^3)$暴力枚举
我们可以枚举长度$len$并分别判断从第$i$个单词开始为第一个单词的长度为$len$子串是否合法（即在$B[]$中存在连续的长度为$k$的一段，包含$cnt$个单词）。其中$1≤len≤m$，判断的复杂度为$O(m^2)$

因此总复杂度为$O(m^3)$

### $O(m^2\ log\ m)$暴力二分
在上面所描述的暴力中，我们将第二问转化为了一个判定问题。

而在我们所枚举的集合很显然是具有单调性的：

如果答案为$k$

那么如果长度大于$k$必然合法

而长度要是小于$k$则必然不合法

因此我们可以二分长度$len$，$check$的复杂度为$O(m^2)$，二分的复杂度为$O(log\ m)$因此总复杂度为$O(m^2\ log\ m)$。

## $O(m)$正解
设$f_{l,r}$为从$B[l]$到$B[r]$这段区间内，包含$A[]$中的数的个数。

当$f_{l,r}=cnt$且$C[B[r]]=true$并满足于$C[B[r+1]]=false$时


设其中包含$cnt$个$A[]$中元素个数的最短区间为$[a,b]$（等价于$[a,r]$）

那么显然$f_{a,b}=f_{l,r}=f_{a,r}$

那么我们则可以用$r - a + 1$更新元素



我们维护一个集合$S$与$S'$，$S$包括$B[l] \sim B[r]$，$S'$包括$B[a] \sim B[r]$

那么$(r-l+1)=|S|$，$(r-a+1)=|S'|$

我们已知$l,r$与集合$S$，接下来即求出$a$与$S'$

因为$f_{l,r}=f_{a,r}=cnt$且$[a,r]$为包含$cnt$个$A[]$中元素个数的最短区间

那么$f_{a+1,r}$必然小于$cnt$

且$f_{l,r-1}$必然小于$cnt$

且$[a,r]$为连续的一段

因此我们得到$S'$最朴素的做法即从$l$开始依次删除$B[i]$所对应的集合的元素。对应的区间为$[c,r]$当$f_{c,r}<cnt$时$r-c+2$即为$r - a + 1$。

因此我们可以枚举$r$，计算$f_{1,r}$并维护集合$S$，每次枚举插入$B[r]$。

当$f_{1,r}=cnt$时依次删除前$i$个元素，直到$f_{1,r}<cnt$

并用$|S'|+1$更新答案。

而对于集合$S$，因为我们只在一端插入，一端删除，因此可以用队列维护。

而对于每个元素最多进队$1$次出队$1$次。

因此复杂度为$O(m)$。
```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
const int mod = 1000007;
const int base = 131;
bool have[mod], used[mod];
int val[100005],sum[mod];
char s[15];
queue<int> q;

int hsh(char* s){
    int ret = 0, len = strlen(s);
    for (int i = 0; i < len; i++){
        ret = (ret * base + s[i]) % mod;
    }
    return ret;
}

int main() {
    int n, m, cnt = 0, len, now;
	cin >> n;
    for (int i = 0; i < n; i++){
        cin >> s;
        have[hsh(s)] = true;
    }
    cin >> m;
    for (int i = 1; i <= m; i++){
        cin >> s;
        val[i] = hsh(s);
        if (have[val[i]] && !used[val[i]]){
            cnt++;
            used[val[i]] = true;
        }
    }
    if (cnt == 0){
        cout << 0 << endl;
        cout << 0 << endl;
    }else{
        len = m;
        now = 0;
        for (int i = 1; i <= m; i++){
            int queuelen = q.size();
            q.push(i);
            sum[val[i]]++;
            if (have[val[i]] && sum[val[i]] == 1) now++;
            if (now == cnt){
                while (now == cnt){
                    int v = q.front();
                    q.pop();
                    sum[val[v]]--;
                    if (sum[val[v]] == 0 && have[val[v]]) now--;
                }
                queuelen = q.size() + 1;
                len = min(len,queuelen);
            } 
        }
        cout << cnt << endl << len;
    }
    return 0;
}
```




---

## 作者：Derpy (赞：1)

~~来自一名离csp二轮只有半周时间了才学会哈希的蒟蒻的题解~~

翻了下题解，看到大佬们都是差不多都是单哈希加map（当然也有很多用别的骚方法的大佬ORZ），还没有一个用双哈希的。

个人不是很熟悉map（都要二轮了等会儿还是去学一学），而且多单哈希总有一种觉得不稳的感觉，喜欢用双哈希。而双哈希配合Map的话对我这个不熟悉map的蒟蒻更是难上加难（话说真的有二维map这种东西吗。。）。

所以就自己写了一个:

### 双哈希，排序+lowerbound实现map的效果，最后尺取法解决第二问。

都开始做这道题的应该都已经熟悉hash操作了吧,本蒟蒻在这里就不再赘述了，想学的可以去[哈希模板](https://www.luogu.org/problem/P3370)

具体细节实现看代码吧。

附上巨丑代码一份：
```cpp
#include<bits/stdc++.h>
#define base 131
#define int unsigned long long		//懒鬼写法(搭配signed main使用) 
using namespace std;
struct node
{
	int x,y;//两个不同的哈希值 
	friend bool operator < (node x,node y)//以x为第一关键字排序 
	{
		return x.x<y.x;
	}
}a[1005];//储存单词表 
int cnt[1005];//尺取法当前区间内每个单词(以下标表示)出现的次数 
int b[100005];//储存1文章中对应单词的位置 
bool vis[1005];
int HSH(string s,int mod)//标准的哈希 
{
	int ans=0;
	int sz=s.size();
	for(int i=0;i<sz;i++)
	{
		ans=(ans*base+s[i])%mod;
	}
	return ans;
}
signed main()
{
	int n,ans1=0,ans2=1000000;
	cin>>n;
	string tmp;
	for(int i=1;i<=n;i++)
	{
		cin>>tmp;
		a[i].x=HSH(tmp,1e9+7);
		a[i].y=HSH(tmp,1e9+9);//哈希处理 
	}
	sort(a+1,a+n+1);//排序以便lowerbound对照下标 
	int m;
	cin>>m;
	for(int i=1;i<=m;i++) 
	{
		cin>>tmp;
		node tsh=node{HSH(tmp,1e9+7),HSH(tmp,1e9+9)};
		int p=lower_bound(a+1,a+n+1,tsh)-a;//p表示文章中该单词在单词表中的位置（但有可能单词表中没有)
		bool flag=0;//记录到底有没有这个单词 
		for(;;p++)
		{
			if(a[p].x==tsh.x)//如果第一维相同 
			{	
				if(a[p].y==tsh.y)//第二维也相同，那就差不多是一个了（这都能撞到两个就真是见鬼了。。。） 
				{
					b[i]=p;//记录位置 
					if(!vis[p])
					{
						vis[p]=1;
						ans1++;
					}
					flag=1;
					break;
				}
				//可能存在第一位相同第二维不同的情况，这个时候我们找下一个位置 
			}
			else//第一维都不同 
				break;//那就肯定不行了 
		}
		if(!flag)
		{
			b[i]=n+1;//没找到的话就把他的对应下标放到n+1 
		}
	}
	cnt[n+1]=10000000;//不存在的东西无论是进了尺取法范围还是出了尺取法范围都不应该影响计数 
	for(int i=1,cntn=0/*统计当前有几种单词*/,l=1/*左指针*/;i<=m;i++)
	{
		if(!cnt[b[i]])//如果这个单词未出现过 
		{
			cntn++;//单词种类数+1 
		}
		cnt[b[i]]++;//这种单词的数量+1 
		while(cnt[b[l]]>1)//如果区间开头那个单词是多余的（也就是在后面还会出现） 
		{
			cnt[b[l]]--;//就删去它 
			l++;//并移动左指针 
		}
		if(cntn==ans1)//已经出现了全部单词 
		{
			ans2=min(ans2,i-l+1);//计算答案 
		}
	}
	cout<<ans1<<endl<<(ans2==1000000?0:ans2);//如果ans2无法更新，再特别输出一下 
	return 0;
}
```


---

## 作者：清尘 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/whx666/p/11409650.html)

其实这题跟hash没什么关系,直接用队列做就可以了（[时间复杂度还过得去](https://www.luogu.org/record/23319072)）。

需要预处理的信息：文章中每个单词对应相同的要背的单词（下标）

这里先将要背的单词排序，然后二分(lower_bound)查找提高效率（打乱顺序不影响结果）

然后从1到m遍历文章中的单词

要做的事情如下：

1、将当前的下标加入队列，并更新最优解（最多单词数）

2、不难看出：如果队首的元素在队列中已经出现多次(>1)，将队首删除答案更优（多余的数）

3、更新最小长度（如果这个单词之前未出现，直接赋值为队列长度，否则与自身取min值）

代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ans, minl, now, p[100005], vis[1005]; 
//vis记录出现次数，p表示文章中每个词对应的要背的词 
string s, str[1005];
int main() {
	scanf ("%d", &n);
	for (register int i = 1; i <= n; ++i)  cin >> str[i];
	sort (str + 1, str + n + 1);
	scanf ("%d", &m);
	for (register int i = 1; i <= m; ++i) {
		cin >> s;
		int t = lower_bound (str + 1, str + n + 1, s) - str;   //二分查找对应的词 
		if (str[t] == s)  p[i] = t; 
	}
	queue <int> q;  vis[0] = 1e9;   //0表示没有对应的词，方便处理赋为极大值 
	for (register int i = 1; i <= m; ++i) {
		int k(0);     //k标记当前答案是否有更新 
		if (!vis[p[i]]) k = 1, ans++;
		q.push(i), vis[p[i]]++;
		int t = q.front();
		while (vis[p[t]] > 1 and q.size()) --vis[p[t]], q.pop(), t = q.front();   //删除队首多余的数 
		int tmp = q.size();
		if (k)  minl = tmp;
		else minl = min (minl, tmp);   //如果答案有更新，直接赋值为队列长度，否则与自身取min值 
	}
	printf ("%d\n%d", ans, minl);
	return 0;
}
```


---

## 作者：Dirt、 (赞：1)

首先记录在文章中出现了多少个要背的单词

我们可以用map方便地记录某个单词是否是要背的单词/是否被记录过

用vis记录某个单词是否是要背的单词，vi记录这个单词是否已经被记录过，从而求出文章中要背的单词个数num

然后枚举文章中出现的每一个单词，用cnt记录段落中有多少个要背的单词，用v记录每个单词在段落中出现了多少次，用head记录段落开头的位置

如果在head位置的单词不需要背/在段落中出现过两次以上，就让head前移一位

如果段落中要背的单词数目等于num，就每次取最小长度作为答案

蒟蒻语文不好，请结合代码理解~

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
string a[100003];
map<string,int> v;
map<string,bool> vis,vi;
int n,m,head=1,cnt,num;
int ans=2147483647;
int main()
{
	scanf("%d",&n);
	string s;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		vis[s]=true;
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		cin>>s;
		a[i]=s;
		if(vis[s]&&!vi[s])
        //要背且之前没有记录
		{
			vi[s]=true;
			num++;
		}
	}
	printf("%d\n",num);
	for(int i=1;i<=m;i++)
	{
		s=a[i];
		if(!vis[s]) continue;
        //不需要背就continue
		if(!v[s]) cnt++;
        //之前没出现过cnt就+1
		v[s]++;//出现次数+1
		while(!vis[a[head]]||(head<i&&v[a[head]]>1))
        //不需要背或者出现过一次以上
		{
			v[a[head]]--;
			head++;
		}
		if(cnt==num) ans=min(ans,i-head+1);
	}
	if(ans!=2147483647) printf("%d",ans);
	else printf("0");
    //一定要特判！不然会WA掉一个点
	return 0;
}
```
如果有更好的做法，欢迎提出~

---

## 作者：Zn_Hua (赞：1)

这道题先用hash将每个字符串转化为整数(即关键字)读进数组,处理起来就方便多了(但是你下一次11连会一个UR都没有)

然后我的做法比较神奇。。

**第一问**

- 我用了一个超大的桶记录要背的单词，再用变量 tot 统计文中出现的单词

**第二问**

- 将第一问中得到的tot赋值给p,p是还需寻找的单词数

- 然后进行队列操作，若还未找到全部单词则**尾指针++**

- 若找到一个要背的单词就用另一个桶记录到目前为止该单词出现的次数

- 若该单词是第一次找到则p--;

- 若找到了所有的单词则判断当前头尾指针间的距离是否小于ans

**处理头指针**

- 若找到一个要背的单词则判断该单词是否是目前找到的最后一个

- if(不是)头指针++;桶中该单词次数--；

- else 头指针++；桶中该单词次数--；p++;

- 反复处理头指针尾指针并在每次找到所有单词时记录ans直到尾指针到达m

- 最后就找到答案了

- 哈希函数基本上就是个抽奖器 。。疯狂冲突

- 以下贴出代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
void stri();
int hash_func(const char*);
int pu[10]={3,13,31,131,313,1313,3131,13131,31313,131313},m,n,tot;
ll a[1005],b[100005],hi[3000000],c[3000000];
int main()
{
    int k=n;
    stri();
    if(tot==0){cout<<0<<"\n"<<0<<endl;return 0;}
    cout<<tot<<endl;
    sort(a,a+n);
    int p=tot,l=0,r=0,ans=999999;
    while(1)
    {
        if(p==0)
        {
            while(b[l]==0)l++;
            if(ans>r-l){ans=r-l;}
            if(c[b[l]]>1){c[b[l]]--;l++;}
            else{c[b[l]]--;l++;p++;}
        }
        else
        {
            if(r==m)break;
            if(hi[b[r]]!=0){c[b[r]]++;if(c[b[r]]==1)p--;}
            r++;
        }
    }
    cout<<ans<<endl;
    return 0;
}
void stri()
{
    cin>>n;
    char si[15];
    ll t;
    for(int i=0;i<n;++i)
    {
        cin>>si;
        a[i]=hash_func(si);
        hi[a[i]]=2;
    }
    cin>>m;
    for(int i=0;i<m;++i)
    {
        cin>>si;
        t=hash_func(si);
        if(hi[t]==0)b[i]=0;
        else b[i]=t;
        if(hi[t]==2){hi[t]=1;tot++;}
    }
}
int hash_func(const char *str)//key值
{
    int to=0;
    for(int i=0;i<strlen(str);++i)
    {
        to+=(str[i]-13)*pu[i];
    }
    return to%1313131+1;
}
```

---

## 作者：awipppp (赞：1)

需要考虑没有符合的单词的情况，此时输出0 0

代码长且不规范，但思路简单易理解

（哈希+单调性）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,e,wo;
char x[13];
int b[10003];
unsigned long long y[100005];
unsigned long long q[15];
unsigned long long g[1006],t[100005];
inline unsigned long long has(char ss[13])
{
    unsigned long long tot=0;
    for(int i=strlen(ss)-1;i>=0;i--)
    {
        tot+=(ss[i]-'a'+1)*q[i];
    }
    return tot;
}
bool ef(int l,int r,unsigned long long k)
{
    e=(l+r)>>1;
    if(k==t[e]) return 1;
    if(l==r) return 0;
    if(k<t[e]) return ef(l,e,k);
    else return ef(e+1,r,k);
}
int ff(int l,int r,unsigned long long k)
{
    e=(l+r)>>1;
    if(k==g[e]) return e;
    if(l==r) return 0;
    if(k<g[e]) return ff(l,e,k);
    else return ff(e+1,r,k);
}
void init()
{
    q[1]=1;
    for(int i=2;i<=13;i++)
    q[i]=q[i-1]*27;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",&x);
        g[i]=has(x);
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%s",&x);
        t[i]=has(x);
        y[i]=t[i];
    }
}
int main()
{
    int tot=0,z;
    init();
    sort(t,t+m+1);
    for(int i=1;i<=n;i++) if(ef(1,m,g[i])) tot++;
    printf("%d\n",tot);wo=tot;
    int l=0,r=0;int mi=m;
    sort(g,g+n+1);
    if(tot==0) mi=0;
    else
    while(1)
    {
        if(wo==0)
        {
            if(mi>r-l) mi=r-l;
            l++;
            z=ff(1,n,y[l]);
            if(z!=0) {b[z]--;if(b[z]==0) wo++;}
        }
        else 
        {
            if(r==m) break;
            r++;
            z=ff(1,n,y[r]);
            if(z!=0) {b[z]++;if(b[z]==1) wo--;}
        }
    }
    printf("%d\n",mi);
    return 0;
}
```

---

## 作者：龙·海流 (赞：1)

提高+的题解好激动啊；

这个题据说是道哈希的模板题，不过我用字典树做的把这题AC了，而且效率也不低；

人生第一道字典树的题，权当刷模板了；

（废话有点多）言归正传

#具体思路

首先明确一点，你得在要背单词最多的情况下输出最短长度，即你不能因为最短长度而放弃更多要背的单词。

##字典树预处理

首先，把要背的单词生成一棵字典树，其次，对要读入的每个单词进行查询，如果在树上，就把a[i]赋值为这个单词最后一个字母在树上的指针，为什么这样做呢，学过字典树的同学应该都知道，每个单词的最后一个字母在字典树中的位置是独一无二的，所以可以记录单词的后缀字母来表明这个单词是否要背以及这个单词具体是哪一个，以备下一次查询之用。这些预处理都做完以后，就可以开始尺取法了；

##尺取法
先解释一下几个变量的含义，bo[]数组用来标明某个单词是否是要背的单词，这个的预处理我已经在生成树的时候把每个单词的后缀字母都做好标记了，num[]数组表示在当前长度中某个单词的具体数量，sum表示这段区间内要背单词的最多数量，ans[i]则表示在区间内目标单词数量为i时，区间的最短长度（其实这个说法并不准确，只有ans[sum]是符合这个定义的，但是这并不影响正确性（因为我A了所以肯定是正确的（手动划掉））比如当i为4时，i=1,2,3时的结果就与正确答案毫无关系了），head和tail则是这个尺子的头和尾

尺取法的思路：
遍历a[i]数组，如果这个单词是目标单词（对应if(bo[a[i]]==1)），且这个单词是第一次出现（对应if(num[a[i]]==0)），那么sum就要+1表示尺子里又多一个要背的单词，接着这个单词在尺子里的数量也要+1（对应num[a[i]]++;）。

那么什么时候缩小尺子长度呢？其实只要开头的单词不是要背的（a[head]==0）或是尺子里多次出现的目标单词（num[a[head]]>1），那么这些单词都可以删去（head++），即在保证sum不会--的情况下，开头单词都可以被删掉，注意你删掉这个单词以后别忘了把num--。对于上面的解释，有的同学就有疑问了，开头没用的单词可以删，那末尾的单词怎么办呢，比如5123000005，后面的00005完全可以不要，但是单纯head++是不可能把后面的单词删掉的，这时候我采用ans记录最小值的办法（对应ans[sum]=min(i-head+1,ans[sum])），即当ans[4]遍历到5123000005的3时，就已经把最优解赋值了，之后只要没有比它小的答案就绝对不会被更新，注意一定要有这一步："if(ans[sum]==0) ans[sum]=i-head+1;"否则你输出的结果全是零；

以上就是我的思路了

接下来上代码(60多行代码很简洁)
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char bo[10010],s[15];
int tr[10010][30],num[10010],l,n,m,tot,a[100010],sum,head,tail,ans[1010];
void cr()//字典树插入 
{
	int u=0,c;
	for(int i=0;i<l;++i)
	{
		c=s[i]-'a';
		if(tr[u][c]==0)tr[u][c]=++tot;
		u=tr[u][c];
	}
	bo[u]=1;
}
int cx()//字典树查询 
{
	int u=0,c;
	for(int i=0;i<l;++i)
	{
		c=s[i]-'a';
		if(tr[u][c]==0) return 0;
		u=tr[u][c];
	}
	if(bo[u]==0) return 0;
	return u; 
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%s",s);
		l=strlen(s);
		cr();
	}
	scanf("%d",&m);
	for(int i=1;i<=m;++i)
	{
		scanf("%s",s);
		l=strlen(s);
		a[i]=cx();
	}
	for(int i=1;i<=m;++i)
	{
		if(bo[a[i]]==1)
		{
			if(num[a[i]]==0) sum++;
			num[a[i]]++;
			if(head!=i)
			while(num[a[head]]>1||a[head]==0) 
			{
				num[a[head]]--;
				++head;
			}
			if(ans[sum]==0) ans[sum]=i-head+1;
			ans[sum]=min(i-head+1,ans[sum]);
		}
	}
	printf("%d\n%d",sum,ans[sum]);
	return 0;
}
```

---


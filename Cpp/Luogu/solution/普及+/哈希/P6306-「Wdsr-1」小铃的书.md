# 「Wdsr-1」小铃的书

## 题目背景

本居小铃在人间之里经营着一家名为“铃奈庵”的书店。店里井井有条地堆放着很多很多书。  

一天，魔理沙来铃奈庵借书，搞得店里十分混乱，魔理沙随身携带的魔导书与铃奈庵的书籍全都混在了一起。

## 题目描述

小铃一共有 $n-1$ 本书，每本书有一个编号 $a_i$，两本书属于同一种类当且仅当两本书的编号相同。  

由于小铃平时将这些书整理得井井有条，因此在小铃的 $n-1$ 本书中，每个种类的书的数量都恰好是 $k$ 的倍数，其中 $k$ 是一给出的常数。
 
现在，魔理沙的一本编号未知的魔导书与小铃的 $n-1$ 本书混在了一起，而魔理沙只有知道魔导书的编号才能将其找回。  

由于书的数量实在太多，魔理沙找到了你来帮忙，希望聪明的你能帮她求出混入的魔导书的编号。

**注意：魔理沙的魔导书可能与小铃的某本书有着相同的编号。**

## 说明/提示

#### 样例说明

样例 $1$ 中，小铃的书的编号为 $1,2,3$，分别有 $3$ 本。因此魔导书的编号为 $5$。

样例 $2$ 中，小铃的书的编号为 $1,4,5$，分别有 $4$ 本。因此魔导书的编号为 $1$。

------------------------

#### 数据范围及约定

**本题采取捆绑测试。**

$$
\def\arraystretch{1.5}
\def\cuteran{https://www.luogu.com.cn/paste/iyzwht7l}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{分值} \cr\hline
1 & 10^5 & 50 \cr\hline
2 & 10^6 & 25 \cr\hline
3 & 10^7 & 25 \cr\hline
\end{array}
$$

对于全部数据，保证 $1 \le n \le 10^7$  ，$2 \le k \le 10^3$  ，$1 \le a_i \le 10^{18}$。保证数据合法，即有且只有一本混入的魔导书。   

-----------------

#### 提示

**请注意时空限制。**

**使用 $\texttt{cin}$ / $\texttt{cout}$ 可能超时，这里给出一个快速读入模板：**

```cpp
long long qread(){
    long long w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
```

**或者使用这份模板：**

```cpp
typedef long long LL;
#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++
static char buf[100000],*pa(buf),*pb(buf);
inline LL readint() {
	LL x=0;char c=gc;
	while(c<'0'||c>'9')c=gc;
	for(;c>='0'&&c<='9';c=gc)x=x*10+(c&15);
	return x;
}
```

**其中，在开启 O2 开关的前提下，前者在极限数据下的读入要 $500\texttt{ms}$，而后者需要 $300\texttt{ms}$。也就是说，你的程序至少有 $500\sim 700\texttt{ms}$ 的时间执行主要算法。**

## 样例 #1

### 输入

```
10 3
1 1 2 2 3 5 3 2 1 3```

### 输出

```
5```

## 样例 #2

### 输入

```
13 4
1 1 4 5 1 4 1 4 4 5 5 5 1```

### 输出

```
1```

# 题解

## 作者：yurzhang (赞：42)

更好的阅读体验 -> [推销博客](https://nikaidou-shinku.github.io/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu6306-%E5%B0%8F%E9%93%83%E7%9A%84%E4%B9%A6/)

---

# 前言

这是一篇暴力乱搞题解，我不保证它在任何时候都能通过本题（事实上现在就不能了），但这并不意味着你无法从这篇题解中学到一些有用的东西，请在知悉这些的前提下往后阅读。

---

# 正文

首先有一个众所周知显而易见的结论：如果 $k=2$ 的话答案就是所有数异或起来。

我们可以类比这个推广到对任意 $k$ 的结论，也就是把 $a$ 转化为 $k$ 进制数做不进位加法，答案就是最终得到的数。

据此可以写出代码：

```cpp
int n,k; u64 SPRB[64],x,ans;
while(n--) {
    x=read_ull(); int now(0);
    while(x) { SPRB[now++]+=x%k; x/=k; }
} for(int i=0;i!=64;++i) SPRB[i]%=k;
for(int i=63;~i;--i) ans=ans*k+SPRB[i];
```

显然这个做法的复杂度是 $O(n\log A)$ 的，$A$ 为值域，看上去无法通过此题，于是我们选择~~思考正解~~开始乱搞。

---

# 真正的正文

我们看到这段代码充斥着取模和除法运算，并且除数固定。

众所周知取模和除法特别慢，我们考虑优化掉它们。

这里介绍一下 Barrett Reduction 算法：

假设 $b$ 为字长，对于一个除数 $M(2\le M<2^b)$，令 $s=\left\lfloor\log_2(M-1)\right\rfloor$，$X=\left\lceil\frac{2^{b+s}}{M}\right\rceil$，我们有 $X<2^b$，并且对于任意的 $N\in[0,2^{b-1})$，有：
$$
\left\lfloor\frac{N}{M}\right\rfloor=\left\lfloor\frac{NX}{2^{b+s}}\right\rfloor
$$
这意味着我们将一次除法运算转化为了一次乘法运算和一次按位右移运算，而众所周知
$$
N\bmod{M}=N-M\cdot\left\lfloor\frac{N}{M}\right\rfloor
$$
于是取模也被优化到了两次乘法、一次按位右移、一次减法。

使用这个技巧优化一下上面进制转换的部分就可以通过**考试时**的数据了。

## 证明

这里搬运了 Min_25 给出的证明，原文[在此](https://min-25.hatenablog.com/entry/2017/08/20/171214)（全日文警告）。

$X<2^b$ 是比较显然的：首先必然存在一个 $r\in[0,M)$ 使得 $X=\frac{2^{b+s}+r}{M}$。

又由于：
$$
2^s<M\le2^{s+1}\Rightarrow2^s\le M-1<2^{s+1}
$$
我们有：
$$
X=\frac{2^b2^s+r}{M}\le\frac{2^b(M-1)+r}{M}<\frac{2^bM}{M}=2^b
$$
由此 $X<2^b$ 得证。

接下来我们考虑证明下面这个式子：
$$
0\le\frac{NX}{2^{b+s}}-\frac{N}{M}<\frac{1}{M}
$$
可以发现，这个式子得证则原式得证。

首先由 $X$ 的定义我们可以发现大于等于 $0$ 是显然的，接下来我们证明右边的小于。
$$
\left(\frac{NX}{2^{b+s}}-\frac{N}{M}\right)-\frac{1}{M}=\left(\frac{N\frac{2^{b+s}+r}{M}}{2^{b+s}}-\frac{N}{M}\right)-\frac{1}{M}
$$

$$
=\frac{Nr}{M2^{b+s}}-\frac{1}{M}
$$

$$
=\frac{Nr-2^{b+s}}{M2^{b+s}}
$$

又因为：
$$
Nr<NM<2^{b+s}(M\le2^{s+1},N<2^{b-1})
$$
原式得证。

---

# 最后

是否提交这篇题解我是斟酌过的，毕竟它已经无法通过这道题了。但是最后我还是决定提交，因为我认为对一道题目的研究不应该仅仅是通过这道题，更重要的是从这道题中学到些什么。如果你认为你从这篇题解里学到了东西，欢迎点赞让更多的人看见它。

---

## 作者：wyd_forever (赞：12)

~~水题解来了~~  
  
---  
开始讲题  
  
一步一步来吧，先是$50pt$  
  
### $first--50pt$  
  
~~话说这个部分应该都会吧~~  
  
其实这个部分就是把所有能想到的做法都拿出来爆搞就是了，比如存储后排序再扫描处理，或者直接用桶存  
  
而我们现在关心的是后一种做法。为什么？~~我也不知道~~，因为这与我们之后的$75pt$以及正解的思路都密切相关。而$50pt$部分的桶做法应该都能想到吧，就是用个$map$暴力存储，再看最后的出现次数是否$mod~k$为零  
  
### $second--75pt$  
  
可是$map$到了第二个部分$75pt$时，$8mb$会卡得你不要不要的，所以就只能考虑其它的~~奇~~技~~淫~~巧了  
  
依旧考虑桶的思路，而目标是优化空间，那么就考虑将一个数拆成其$k$进制的若干部分，比如$k=3$时，将$(5)_ {10}$变成$(12)_ {3}$，而将$(12)_ {3}$的个位$2$存入专门存个位的桶中，十位$1$存入专门存十位的桶中，这个存其实就是将数加入桶中。而将桶取模$k$，若有剩余那么剩下的必然是可以计入答案中的，关于这个我们假设混入的魔导书为$t$，其存入的某一位设为第$p$位，则其存入的数值是$ans_p=\frac{t\% k^{p+1}}{k^p}$，而显然$k^p<t\%k^{p+1}<k^{p+1}$，所以$0<ans_p<\frac{k^{p+1}}{k^p}=k$（以上除号均是下取整），所以膜$k$后剩下的值一定是答案中的，可以加入  
  
也就是以下代码：
```cpp  
fac[0]=1;
for(register int i=1;fac[i-1]<=lim;up=i++)
	fac[i]=fac[i-1]*k;
for(register ll x;n;--n)
{
	x=read();
	for(register int i=up;x;--i)
		if(x>=fac[i])
		{
			ans[i]+=x/fac[i];
			if(ans[i]>=k)
				ans[i]-=k;
			x%=fac[i];
		}
}
for(register int i=up;~i;--i)
	res+=ans[i]*fac[i];
```  
  
只给出了一部分，其中$fac_i=k^i$，而$res$就是最后答案  
  
### $third--100pt$  
  
而第二部分的空间$O(log_2a_{max})$是合格了，但显然时间$O(nlog_ka_{max})$被卡掉了，所以考虑进一步优化  
  
继续考虑桶与拆分的思路，可以想到把$second$中的空间稍微开大一点以达到节约时间的目的  
  
将一个数分成若干个部分，但这次不是统计那个部分的代数和了，而是统计某个数的该部分的出现次数，这样就可以成功解决问题了  
  
比如将一个数$a$分为$a_{1-8}$的$8$个部分，其中$2^{8* (i-1)}<=a_i<2^{8* i}$，那么再建立$8$个数组$ans_{i,j}$，其中$ans_{i,a_i}$自加，那么这些数组就跟一个个小桶一样了，时间也节约了很多，只是$O(n)$套了一个$8$的常数，而能顺利解决问题  
  
至于开$8$个数组只是怕$MLE$，其实应该可以开更小的，但$8$个已经够了，不会$T$  
  
短小精悍的代码：  
```cpp  
#include<bits/stdc++.h>
using namespace std;

#define ll long long

inline ll read()
{
	ll x=0,ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar());
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
	return x;
}

const int digit=1<<8,p=8;

int a[p][digit];
ll ans,n,k;

int main()
{
	n=read(),k=read();
	for(register ll x;n;--n)
	{
		x=read();
		for(register int i=0;i<p;++i)
			++a[i][(x>>(i*p))&(digit-1)];
	}
	for(register ll i=1;i<digit;++i)
		for(register int j=0;j<p;++j)
			if(a[j][i]%k)
				ans+=(i<<(j*p));
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：4526_ (赞：5)

[题目链接](https://www.luogu.com.cn/problem/P6306)

验题人报道~

这题本来是平凡签到，由于[比赛](https://www.luogu.com.cn/contest/28578)提交审核的时候被神 [$\text{mrsrz}$](https://www.luogu.com.cn/user/6813) 爆踩标算就加强成了毒瘤劝退（大概），作为T1赛时AC人数不到30......

先放个各种解法时空复杂度分析：

![](https://cdn.luogu.com.cn/upload/image_hosting/6sssz9zg.png)

可以看出为了卡掉其他做法时限和空限都压得很严，sto 出题人

原题的数据是这样的：

对于 $10\%$ 的数据，$n ≤ 10^5$ 

对于另外 $20\%$ 的数据，$k = 2$ 

对于 $100\%$ 的数据，$n ≤ 10^6$ 

刚拿到题第一反应就是直接 $sort$ 统计每个数的出现次数，交上去发现 $\text{MLE}$，再看一遍空限只有 $1 M$，显然需要其他~~奇技淫巧~~方法

注意到比较特殊的 $k = 2$，立即想到位运算，对于小玲的书，每个编号所对应的二进制数都出现了 $k$ 的倍数次，在这部分数据中就是 $2$ 的倍数，那么把所有书的编号异或，最后得到的就是魔理沙的书的编号

据此想到，对于 $k$ 不为 $2$ 的情况，只要把每个数拆分成 $k$ 进制，空间就可以压缩到 $log_{k}\ a_i$，本题解决

...了吗？上述做法现在只能得到 $75pt$，看来并没有......公开赛提交审核时因为空限太小被打回来了，理由是卡语言，某些语言不开变量也会超过 $1M$，出题组成员连夜开大空间重造数据，终于在 $16M$下卡掉了 $\text{map}$，再次提交审核......然后被 $\text{mrsrz}$ 踩标算了qaq于是加强到现在的数据范围

使用 $k$ 进制拆分会 $\text{TLE}$ 最后一个点，由于取模常数较大且拆分时运算次数较多，想到采用更大的进制，$10^{18}$ 的数用 $2^{16}$ 进制只需分成 $4$ 部分，进一步优化时间

其实 $a_i$ 还可以继续放大用高精度存储，不过没有必要~~还有可能被喷~~，大家可以自行尝试

实现不难，这里就不贴代码了

欢迎来[我的blog](https://www.luogu.com.cn/blog/138812/#)看看

---

## 作者：朱屹帆 (赞：4)

这一题是一道训练思维的好题。

首先，除了魔导书以外，所有的书的数量都是 $k$ 的倍数，那么我们就可以**用一个桶或者用 $map$ 来存各种 $a_i$ 的书的个数**：

```cpp
map<long long,long long>s;
```
这种方式的得分为 $50 pts$ 。

但是看到这一题，内存限制有 $8.00MB$ ，是专门卡 $map$ 的，所以很显然， $map$ 是无法再拿更多的分了。

于是，我们又会想到既然除了魔导书以外，所有的书的数量是 $k$ 的倍数，那么**排完序后不是魔导书的书自然会 $k$ 个的连接在一起**，我们就可以用排序来找出多余的那一本书：

```cpp
sort(s+1,s+n+1,cmp);
```
这种方式的得分为 $75 pts$ 。

不过，排序的时间复杂度为 $O(n*log n)$ ，我们只能另寻它法了。

看到这一题，相信也有许多人会想到 $k$ 进制，将每个数进行 $k$ 进制拆分，**因为所有的书的数量都是 $k$ 的倍数，所以将每一位的数量都模上一个 $k$** ，再将所有数位组成在一起，便可以找出魔导书：

```cpp
for(LL j=0;a!=0;j++){
	if(a%k!=0)s[j]+=(a%k);
	a=(a/k);base=max(base,j);
}
...
for(LL i=0;i<=base;i++){
	s[i]=(s[i]%k);
	if(s[i]==0)continue;
	cnt+=(pow(k,i)*(s[i]));
}
```
这种方式的得分为 $75 pts$ 。

以这种方式来做，还是会超时，我们都知道 $10^{18} <= 2^{63} $ ，但一共有 $10^7$ 个数，时间复杂度最坏情况下可达 $O(63*10^7)$ ，所以这个方法会超时。

那怎么办呢？

既然魔导书只有一本，也就是说在所有数中，魔导书所在的书的种类里有 $xk+1$ 本书，那我们就可以**直接按百进制来存**书的本数：

```cpp
const long long K = 100;
...
for(LL j=0;a!=0;j++){
	if(a%K!=0)s[j][a%K]++;
	a=(a/K);base=max(base,j);
}
...
for(LL i=0;i<=base;i++){
	for(LL j=0;j<=99;j++){
		s[i][j]=(s[i][j]%k);
		if(s[i][j]!=1)continue;
		cnt+=(pow(K,i)*j);
	}
}
```
这种方式的得分为 $100 pts$ 。

因为 $10$ 的 $18$ 次方 $<=$ $ 100 $ 的 $9$ 次方，也就是说，我们处理一个数只需要循环最多 $9$ 次，就可以记录下这个数。

我看了一下其他的题解，本质思想都差不多，讲一个数分成多个部分来存。大多数都是分成 $4$ 个部分 $2$ 的 $8$ 次方为一个部分来处理，程序也比我快一些，但分成 $9$ 个部分也同样可以解决这道题，而且代码较为直观，了解了这种方式，分成 $4$ 个部分的方法也便不难了解了。

时间复杂度：$O(9*10^7)$

### Code：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define INF 0x3f3f3f3f
#define endl '\n'
using namespace std;
long long read(){
	long long q=0,w=1;
	char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')q=q*10+(ch-'0'),ch=getchar();
	return q*w;
} //快读加速
long long pow(LL a,LL b){
	LL ans=1,base=a;
	if(b==0)return 1;
	while(b){
		if(b&1)ans=(ans*base);
		b=(b>>1);base=(base*base);
	}
	return ans;
} //求100的b次方
const long long N = 50+5;
const long long K = 100;
long long n,k,a;
long long s[N][K],cnt;
long long base;
int main(){
	n=read(),k=read();
	for(LL i=1;i<=n;i++){
		a=read();
		for(LL j=0;a!=0;j++){ //拆分为百进制
			if(a%K!=0)s[j][a%K]++;
			a=(a/K);base=max(base,j);
		}
	}
	for(LL i=0;i<=base;i++){
		for(LL j=0;j<=99;j++){
			s[i][j]=(s[i][j]%k); //筛选出魔导书
			if(s[i][j]!=1)continue;
			cnt+=(pow(K,i)*j); //累加
		}
	}
	cout<<cnt<<endl; //结果
	return 0;
}
```


---

## 作者：minstdfx (赞：3)

水一发题解。

考虑如果我们把每个数按某种方式分进一些集合中，这些集合存储了关于原数的一些信息。那么，最终集合中多出那么一个的那个就是多余的魔导书所在的集合。

举个例子，如果我们按照二进制表示的一部分来划分集合，那么我们就可以通过最后多余一个的集合编号知道多余的魔导书编号的那一段二进制位。

随便分个四段就好了。
```cpp
#include <bits/stdc++.h>
typedef unsigned uint32;
typedef unsigned long long uint64;
using namespace std;
const int Base=65536;//65536
int geshu[4][Base];
uint64 s[4];
uint64 ans,g;
int n,k;
int main()
{
	cin>>n>>k;
	for(int i=0;i<n;++i)
	{
		cin>>g;
		for(int i=0;i<4;++i)
			geshu[i][65535&g]++,g>>=16;
	}
	for(uint64 i=0;i<4;++i)
		for(uint64 j=0;j<Base;++j)
		{
			if(geshu[i][j]%k==1) ans|=j<<(i*16ull);
		}
	cout<<ans<<endl;
}
```

---

## 作者：XL4453 (赞：1)

### 解题思路：

首先考虑两种朴素的做法。一种是直接统计每一个数出现的个数，每一个数对于 $k$ 取模，剩下的就是要的那一本书。另一种是统计每一个位置上每一个数出现的次数，同样对于 $k$ 取模，这样剩下的每一位上的数拼起来就是要的那一本书。

但是前一种方法超过了空间限制，后一种方法超过了时间限制，都不能解决这个问题。

就能很快发现这两个解法的本质是相同的，也就是将一个数拆成若干个部分，分别进行统计。前者是“拆分”成了一段，后者则是全都拆下来。受到某位魔女的“折个中吧”思想的启发，考虑折个中，随便拆个几位就好了。

---
### 代码（好像要吸氧）：

```cpp
#include<cstdio>
using namespace std;
#define int long long
long long qread(){
    long long w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
int n,k,len,x,ans,tot[257][9],z,X=(1<<8)-1;
signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		x=qread();
		for(int j=0;j<=7;j++){
			tot[x&X][j]++;
			x>>=8;
		}
	}
	for(int i=0;i<=7;i++)
	for(int j=1;j<256;j++)
	if(tot[j][i]%k)ans+=j<<(8*i);
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：就皮这一下 (赞：1)

注：出于某种原因，此题解的做法被卡掉了几个数据点。若有人发现bug所在，请联系鄙人，我将第一时间修改。

## 题意概括
给出$n$个数字，让你找到一个数，出现的次数模k为1。

## 做法：
1. 相信很多同学刚看到时会想到类似“桶排序”的算法

然而，当看到$a_i$的范围时，明显此做法不可行。

2. 没关系，用关联数组$map$

map的确可以省下宝贵的空间，然而，面对$10^7$的庞大数据，map注定会TLE

3. 接下来，请出~~可以水过此题~~的搞法

## 哈希表

>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
	——百度百科

人话：哈希表就是一本字典，你可以将数字存在里面，并且依靠索引快速找到它。

所谓的索引，在实战中经常选择取模法，认真揣摩下面代码，相信大家都能明白。

**实现：（圈重点）**

- 存储数据

可以使用STL大法，但本人为了~~卡空间~~加速使用了longlong数组。
```
    static const int HashMod = 10009;
    long long hash[100002];
    short counter[100002];
    int next[100002];
    int head[HashMod];
    int _size;
```
##### $10^5$的数组你想过$10^7$的数据？

让我们分析一下。$k \leq 10^3$，计数器开short没有问题；由于魔导书只有一本，**每种没混入魔导书的书至少有k本，理论上$10^4$的数组已经足够。**~~奇怪的是：开1e4不会RE，开1e7也不会炸，但是开1e7比开1e4分数要高，令人困惑~~
- 函数

接下来就是老套路啦，两个函数，一个累加函数，一个寻找魔导书~
``` cpp
public:
    void add (long long key,int mod) {
        int hashval = key%HashMod;
        for (int i = head[hashval]; i!=0; i=next[i]) {
            if(hash[i] == key) counter[i] = (counter[i]+1)%mod;//累加时取模运算，最后counter为1的就是魔导书
            return;
        }
        //not found:Add it
        _size++;
        next[_size] = head[hashval];
        head[hashval] = _size;
        hash[_size] = key;
        counter[_size]++;
        return;
    }
    long long search () {
        for (int i = 0; i<HashMod; ++i)
            for (int j = head[i]; j!=0; j=next[j])
                if (counter[j])
                    return hash[j];
    }
```
最后，主程序中采用暴力的计算就好~
```
int main () {
#ifdef LOCAL
    freopen("testdata.in","r",stdin);
    freopen("testdata.out","w",stdout);
#endif
    int n,k;
    read(n,k);
    cout << n << ' ' << k << endl;
    for (int i = 1; i<=n; ++i) {
        long long a;
        read(a);
        S.add(a,k);//暴力统计
    }
    //S.debug();
    cout << S.search() << endl;
    return 0;
}
```
时间复杂度，哈希表理想状态是O(1)的，那么理想的时间复杂度应该是O(n)。

#### 后记：笔者的确在比赛时解决了本题，大概数据有所加强卡掉了我的哈希表，如果有人能指出问题，鄙人不胜感激涕零。

---


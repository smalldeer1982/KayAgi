# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# 题解

## 作者：Lucaster_ (赞：784)

[题目传送门](https://www.luogu.org/problemnew/show/P1038)

# 首先奉上AC代码：

##### ~~我知道你们就是来看这个的咳咳~~

```cpp
#include<queue>
#include<cstdio>
#include<algorithm>
#define N 102
#define M N*N
using namespace std;
queue<int> q;
struct edge{
	int to,val,from,next;
} e[M];
struct answ{
	int num,val;
} ans[N];
int h,i,m,n,t,u,v,w,x,c[N],hd[N];
bool out[N],vis[N];
int cnt=0,tot=0;
 bool cmp(answ aa,answ bb)
 {return aa.num<bb.num;}
 void build(int u,int v,int w)
 {
 	cnt++;
 	e[cnt].to=v;
 	e[cnt].val=w;
 	e[cnt].from=u;
 	e[cnt].next=hd[u];
 	hd[u]=cnt;
 }
int main()
{
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)
	{
		hd[i]=0;out[i]=false;
		scanf("%d%d",&c[i],&x);
		if(c[i])
		 {q.push(i);vis[i]=true;}
		else
		 {c[i]-=x;vis[i]=false;}
	}
	for(i=1;i<=m;++i)
	{
		scanf("%d%d%d",&u,&v,&w);
		build(u,v,w);
		out[u]=true;
	}
	while(!q.empty())
	{
		h=q.front();q.pop();
		for(i=hd[h];i;i=e[i].next)
		{
			if(c[e[i].from]<=0) continue;
			t=e[i].to;
			c[t]+=(e[i].val*c[h]);
			if(!vis[t])
			{
				q.push(t);
				vis[t]=true;
			}
		}
	}
	for(i=1;i<=n;++i)
	 if(c[i]&&!out[i])
	 {
	 	tot++;
	 	ans[tot].num=i;
	 	ans[tot].val=c[i];
	 }
	if(tot==0) {printf("NULL");return 0;}
	sort(ans+1,ans+tot+1,cmp);
	for(i=1;i<=tot;++i)
	printf("%d %d\n",ans[i].num,ans[i].val);
	return 0;
}
```
（先别急着抄，这份代码有很多冗余部分，下面有更新版代码）


OK，切入正题

~~如果你不想听我bb想听干货请到下面的讲解区~~

其实这道题为什么用拓扑和具体思路楼上的几位大佬已经讲的很清楚了

~~所以说我这篇题解毫无用处~~

不不不，一定是有用处的

这道题是我练习拓扑的第一道题

本来想找个标程比着学习一下的

但是大佬们的码风都好清奇……

蒟蒻我直接看不懂……

于是我发誓要写一份简单易懂的拓扑代码

调了一天终于调出来了

![一点一点的AC了](https://cdn.luogu.com.cn/upload/pic/57796.png)


不得不说坑点还真不少


# 讲解区

下面分几部分再详解一下这道题

## 1.读入+处理

```latex
注意，因为这是一个拓扑的题
所以我们拓展点的时候要借助队列
那如何发挥队列的用处呢？

由题意，只有最初状态为1的点才会往后传递
我们完全可以在读入的时候就把上述点push进队列中

楼上大佬也证明过了，阈值u（我的代码中是x）可以一开始直接减掉，我就不再赘述了。
```
```
scanf("%d%d",&n,&m);
for(i=1;i<=n;++i)
{
	hd[i]=0;out[i]=false;
	scanf("%d%d",&c[i],&x);
	if(c[i])
	 {q.push(i);vis[i]=true;}
	else
	 {c[i]-=x;vis[i]=false;}
}
```
```latex
注：hd数组即邻接表中的head；out表示这个点是否有出边，没有的话就是最后一层，这里后面会用到

vis数组表示点是否入过队，防止重复
```

## 2.建图（有向图）

```
for(i=1;i<=m;++i)
{
	scanf("%d%d%d",&u,&v,&w);
	build(u,v,w);
	out[u]=true;
}
```
out数组上面提到过了

这个build多了一点小东西

```
 void build(int u,int v,int w)
 {
 	cnt++;
 	e[cnt].to=v;
 	e[cnt].val=w;
 	e[cnt].from=u;//没错就是这里
 	e[cnt].next=hd[u];
 	hd[u]=cnt;
 }
```
from是干啥用的呢？

每个点（神经）传递信息的时候，我们要判断这条边的起点是否能传递

于是我用了个from来存这个起点的状态

upd on 2020.02.02:from其实不用哒，我们在队列中取出的front就是每次前向星遍历的from！

## 3.拓扑处理（核心部分）
```latex
上面我已经说过了，用队列来维护拓扑序列。
这个地方我写的比较明白，具体注释放代码里了，往下看吧
```
```
while(!q.empty())
{
	h=q.front();q.pop();
	for(i=hd[h];i;i=e[i].next)
	{
		if(c[e[i].from]<=0) continue;
      t=e[i].to;//t记录该边终点
		c[t]+=(e[i].val*c[h]);//题目里的求和公式就是这个意思，终点值+=起点值*边权
		if(!vis[t])
		{
			q.push(t);
			vis[t]=true;
		}
	}
}
```
```latex
到这里有大佬已经看出来了，我好像没用“入度”这个数组来进行拓扑排序啊
没错，这个题确实没用……
因为我们只需要统计输出层
也就是没有出边的点
```
upd on 2020.02.02，这一部分也有更新，具体看最下方新版代码

## 4.记录答案

```
for(i=1;i<=n;i++)
 if(!out[i]&&c[i]>0)
  {printf("%d %d\n",i,c[i]);flag=1;}
if(!flag) {puts("NULL");return 0;}

我突然发现，我当时好菜啊……
几位大佬用的优先队列，按照编号重载运算符之后输出
受启发我用了结构体+排序输出的最后ans，but in fact……完全没必要啊……
我们只需要for循环从小到大找，越靠前找到的合法输出层就是编号越小的啊……符合题意。直接输出就好了……
```
## 5.return 0;完结撒花❀
```latex
最后再bb一句
啊不是
总结一下
1.关于拓扑排序输入的时候可以干很多事，比如说预处理vis，元素入队等等，这道题还直接减去了阈值
2.build的时候不要太死板打板子，这道题中加一个from有助于后续操作
3.拓扑排序不一定都要用入度的，某些特定情况下可以用一些别的方法实现拓扑
4.（这好像是句废话）存某些信息的时候不一定要用高级数据结构，数组大法好！

```

看在我写了这么多~~而且代码和这么好懂的份上~~求管理大大通过吧QAQ

补充：楼上几位大佬的程序真的很难懂（现在我是二楼了hhhh），也没有讲解核心代码，希望管理员能通过这篇题解谢谢啦



------------


------------

分割线

------------

------------

## update on 2020.02.02.20:20 （千年难遇的大回文日期）

当时写这篇题解的时候算是初学者，对图论，拓扑理解都不是很深，题目中一些概念也没太弄明白。一年以后的现在，通过这一年的磨练，以及评论区大佬们的指导，更新一份新的AC代码，更简洁明了。思路和上面讲解一样。


~~所以我上面说了吗，不要急着抄代码嘛，下面有更短的咳咳~~

下面奉上AC代码plus:

```cpp
#include<queue>
#include<cstdio>
#include<algorithm>
#define N 101
using namespace std;
struct edge{
	int to,val,nxt;
} e[N*N];
struct answer{
	int id,val;
} ans[N];
int h,i,m,n,t,u,v,w,U,c[N],hd[N],out[N],vis[N];
queue <int> q;
int cnt=0,flag=0;
 inline bool cmp(answer aa,answer bb)
  {return aa.id<bb.id;}
 inline void build(int u,int v,int w)
 {
 	cnt++;
 	e[cnt].to=v;
 	e[cnt].val=w;
 	e[cnt].nxt=hd[u];
 	hd[u]=cnt;
 }
int main()
{
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		vis[i]=out[i]=0;
		scanf("%d%d",&c[i],&U);
		//这里不可以直接减，初始层也有可能有阈值，但不能减去.(题目要求)
		if(c[i]>0)
		 {q.push(i);vis[i]=1;}//vis表示是否已入过队
		else c[i]-=U;
	}
	for(i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		build(u,v,w);
		out[u]=1;//out表示有无出边，用于最后找输出层
	}
	while(!q.empty())
	{
		h=q.front();q.pop();
		if(c[h]<=0) continue;
		for(i=hd[h];i;i=e[i].nxt)
		{
			t=e[i].to;
			c[t]+=e[i].val*c[h];
			if(!vis[t])
			{
				q.push(t);
				vis[t]=1;
			}
		}
	}
	for(i=1;i<=n;i++)
	 if(!out[i]&&c[i]>0)
	  {printf("%d %d\n",i,c[i]);flag=1;}
	if(!flag) {puts("NULL");return 0;}
	return 0;
}
```
修改的地方:

1. （修改了一点点码风）
2. 拓扑排序时把continue的判断放到了前向星遍历之前，理论上讲（至少我现在是这么理解的）更科学一点
3. 好吧看来看自己一年前的代码~~翻看自己三年前的空间一样~~果然惊喜不断，最后我们成功又缩短了不少，思路也更清晰了一点。
4. 所以，既然我又加强了一下题解，何不
## 觉得有帮助的点个赞给个支持再走呗QwQ

---

## 作者：zzlzk (赞：125)

- ####  这道题并不是很难，就是细(keng)节(dian)有点多


- 如果一个神经元的 $ C[i] <=0 $，那他就不会exciting，不会继续传递。


- $C[i]$ 有可能是负数，所以输出的时候要判断 $C[i] >0$ 而不是 $C[i]!=0$。


- $U[i]$ 其实没必要存储下来，输入层的 $U[i]$ 其实没什么用。具体看下面的分析。


- #### 分析题目中的公式


- 由 $C[i]=\sum\limits_{(j,i)\in E}{W_{(j,i)}}*C[j]-U[i]$ 移项可得

-     $C[i]+U[i]=\sum\limits_{(j,i)\in E}{W_{(j,i)}}*C[j]$

-   $U[i]$是要输入进去的，可以视为一个常数 $k$


-  也就是说$\sum$ 算出来的是 $C[i]+k$ 的值


-   想得到$C[i]$ 就迟早要减去那个常数 $k$


- 所以我们可以在输入的时候就减去这个常数不就行了吗，何必要在后面减去呢？QAQ


-   输入层的 $U$ 是没用的，$U$ 只在公式里有用，输入层的 $C[i]$ 又不用计算，所以$U$ 没用。

   
- #### 为什么要用拓扑排序

- 再看上面的公式：$C[i]+U[i]=\sum\limits_{(j,i)\in E}{W_{(j,i)}}*C[j]$


- 发现要想求出 $C[i]$ 就要求出所有 $ C[j] (i,j\in E)$ 的值。

 
- 举个栗子:


![QQ浏览器截屏未命名.png](https://i.loli.net/2017/08/21/599a8bd4bf68c.png)

   
-  对于上面这个图，想要算出 $ F$ 的 $C$ 值，就要先算出$D$ 和 $E$ 的 $C$ 值，哇，这不就是赤裸裸的[拓扑排序](https://www.baidu.com/s?ie=utf8&oe=utf8&wd=%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&tn=98012088\_5\_dg&ch=1)吗？qwq


- 从上面那个图还可以看出，输入层是入度为 $0$ 的点（$A、B、C$），输出层是出度为 $0$ 的点（$F$），如果你用的是邻接表存图你可以只记录入度不记录出度，因为一个点 $u$ 出度为 $0$ 相当于 $head[u]==0$ ，所以输出的时候判断每个点的 $head$ 和 $C$ 就好了。

 
---
代码最好不要抄我的呀，我这个拓扑排序是用栈实现的（鬼知道我怎么YY出来的），貌似别人都是用的队列？


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 110
struct Edge {
    int u,v,w,next;
    Edge(int u=0,int v=0,int w=0,int next=0):
        u(u),v(v),w(w),next(next) {}
}edge[20010];
int head[maxn],cnt;
int C[maxn];
int st[maxn],top;
int indeg[maxn];//入度;
inline int input() {
    int x=0,a=1;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())
        if(c=='-') a=-1;
    for(;c>='0'&&c<='9';c=getchar())
        x=x*10+c-'0';
    return x*a;
}
inline void addedge(int u,int v,int w) {
    edge[++cnt]=Edge(u,v,w,head[u]);
    head[u]=cnt;
    return;
}
void topo() {
    while(top!=0) {
        int u=st[top--];
        if(C[u]<=0) {
            for(int i=head[u];i;i=edge[i].next) {
                int v=edge[i].v;
                indeg[v]--;
                if(indeg[v]==0) st[++top]=v;
            }
            continue;
        }
        for(int i=head[u];i;i=edge[i].next) {
            int v=edge[i].v;
            C[v]+=C[u]*edge[i].w;
            indeg[v]--;
            if(indeg[v]==0) st[++top]=v;
        }
    }
    return;
}
int main() {
    int n=input(),p=input();
    for(int i=1,U;i<=n;i++) {
        C[i]=input();
        U=input();
        if(C[i]!=0) st[++top]=i;
        else C[i]-=U;
    }
    for(int i=1;i<=p;i++) {
        int u=input(),v=input(),w=input();
        addedge(u,v,w);
        indeg[v]++;
    }
    topo();
    bool flag=false;
    for(int i=1;i<=n;i++)
        if(!head[i]&&C[i]>0) {
            printf("%d %d\n",i,C[i]);
            flag=true;
        }
    if(flag==false) printf("NULL");
    return 0;
}
```

或许我应该宣传一下自己的[博客](https://git.oschina.net/xjjppm/CodeMaker)？


---

## 作者：ghj1222 (赞：47)

> 在兰兰的模型中，神经网络就是一张有向图。（这个物理模型建立的很棒啊。）

拓扑排序~

这题为什么用toposort做呢？  
首先这个图是一个DAG。。考虑DAG上的算法  
他告诉你了公式了，所有的节点的权值是从他的上一个节点推过来的，所以这是DAG上的递推关系，我们一般用拓扑排序做。

首先，输入层的U是没用的（你可以发现他们的U是永远是0）（然而我特判了一下，变成了-1因为题里面没好像没说啊QAQ），而中间层和输出层的U可以在初始直接减到$C_i$中（然而我比较诚实，下面的程序里我没有一开始就减）

我没有开一个栈或者是一个队列，因为n比较小，我直接暴力找入度为0的节点。出度不需要更新（因为最后出度是为了判断输出层的）

注意几个坑点：只输出**大于0**的**输出层**（要同时满足这两个条件），输出层的判定可以直接记录出度，出度为0的一定是输出层。在NULL的判定中，我们只判定**输出层**的C是否大于0。如果输出层的C都$\le$0，那么就输出NULL。

还有就是如果一个神经元的状态是负的，那么他不会往后传递神经信号。`//（闰绍细胞？）`

代码见下

```cpp
#include<iostream>
#include<cstdio>

#define _ 0

using namespace std;

struct edge
{
	int v,w,ne;
}a[5000];

int n,p,tmp;
int c[110],u[110],h[110],in[110],out[110];
bool v[110];

int main()
{
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&c[i],&u[i]);
		if(c[i]>0)u[i]=-1;
	}
	for(int s,d,w,i=1;i<=p;i++)
	{
		scanf("%d%d%d",&s,&d,&w);
		a[++tmp]=(edge){d,w,h[s]};
		h[s]=tmp;
		in[d]++;
		out[s]++;
	}
	for(int tmp=1;tmp<=n;tmp++)
	{
		for(int i=1;i<=n;i++)
		{
			if(in[i]==0&&v[i]==0)
			{
				v[i]=1;
				if(u[i]!=-1)c[i]-=u[i];
				for(int j=h[i];j>0;j=a[j].ne)
				{
					if(c[i]>0)
					{
						c[a[j].v]+=c[i]*a[j].w;
					}
					in[a[j].v]--;
				}
				break;
			}
		}
	}
	bool flag=0;
	for(int tmp=1;tmp<=n;tmp++)
	{
		if(out[tmp]==0&&c[tmp]>0)flag=1;
	}
	if(flag)
	{
		for(int tmp=1;tmp<=n;tmp++)
		{
			if(out[tmp]==0&&c[tmp]>0)
			{
				printf("%d %d\n",tmp,c[tmp]);
				
			}
		}
	}
	else
	{
		printf("NULL");
	}
	return ~~(0^_^0);
}
```


---

## 作者：faker121 (赞：37)

这道题我在去年9月就开始做 一直到noip2017都没能A   
当时总是试图在原来的代码里挑错 一直都没调试出来  
过几天清明节省选 虽然已经退役了还是决定去凑个热闹 所以这几天又回到机房刷刷水题   
于是又来尝试了一下这道题。。结果一下A了。。历时7个月终于。。    

 
    
大致的思路下面的各位大佬都已经讲得很清楚了，我用的是裸拓扑排序，裸建图，直接过了。。    
这道题坑点挺多的，但实现起来比较容易。    
首先输入时确定是否为输入层，直接从c【i】判断就行了，楼下大佬得出u无用的结论，所以非输入层可以直接在这里减去u。    
然后建边时统计出度（我这里习惯写了个入度没用上）    
接下来拓扑排序了，既然一个点的c值可能被多次加上，又有负权值，判断c>0再进队显然不现实。     
所以我们干脆直接全都进队，出队时判断权值是否>0，是就继续遍历，否则直接跳过。     
这样做好处就是无需在负权值上费力处理，直接就可以使用。    
输出我比较懒。。优先队列弄了一下      
另外注意null别忘写了。。我提交的时候就忘了 80分
```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
int n,p;
struct fuck
{
    int y;
    int val;
    int next;
}a[30010];
int c[110],u[110],in[110],out[110],cnt,head[30010];
bool v[110];
queue <int> q;
struct gay
{
    int x;
    friend bool operator < (gay a,gay b)
    {
        return a.x>b.x;
    }
}g;
priority_queue <gay> print;
void add(int x,int y,int val)
{
    cnt++;
    a[cnt].y=y;
    a[cnt].val=val;
    a[cnt].next=head[x];
    head[x]=cnt;
}
int main()
{
    scanf("%d%d",&n,&p);
    for (int i=1;i<=n;i++)
    {
        scanf("%d%d",&c[i],&u[i]);
        if (c[i]!=0) q.push(i),v[i]=1;
        else c[i]-=u[i];
    }
    for (int i=1;i<=p;i++)
    {
        int x,y,val;
        scanf("%d%d%d",&x,&y,&val);
        add(x,y,val);
        in[y]++;
        out[x]++;
    }
    while (!q.empty())
    {
        int x=q.front();
        q.pop();
        v[x]=0;
        if (c[x]<0) continue;
        for (int i=head[x];i;i=a[i].next)
        {
            int y=a[i].y;
            if (v[y]==0)
            {
                c[y]+=a[i].val*c[x];
                q.push(y),v[y]=1;
            }
            else
            {
                c[y]+=a[i].val*c[x];
            }
        }
    }
    for (int i=1;i<=n;i++)
    {
        if (out[i]==0&&c[i]>0)
        {
            gay gg;
            gg.x=i;
            print.push(gg);
        }
    }
    if (print.empty())
    {
        printf("NULL");
        return 0;
    }
    while (!print.empty())
    {
        gay t=print.top();
        print.pop();
        printf("%d %d\n",t.x,c[t.x]);
    }
    return 0;
}
/*input:
5 6
1 0
0 -1
0 1
0 0
0 0
1 2 -1
1 3 1
1 4 -1
2 5 100
3 5 1000
4 5 10000
out:
NULL
*/
```

---

## 作者：dingcx (赞：36)

~~我感觉我的思路并没有那么好，不过适合刚学图论的新手。~~
# 分析
## 1.变量
1.结构体vertex(顶点)：邻接表的head,rhead；拓扑排序的ind(入度)；还有state(状态),value(阈值),depth(层数)。

2.结构体edge(边)：u(起点),v(终点),w(权值)；邻接表的next。

3.dv和ldv：dv[i][j]表示第i层的第j个点编号是多少；ldv[i]表示第i层有多少个点。
## 2.函数
1.addEdge(u,v,w)：邻接表中的建边。

2.readIn()：就是读入。

3.toposort()：拓扑排序，具体参见后面代码。

4.Changestate()：改变状态，需要一层一层遍历。

5.writeOut()：就是输出。
## 3.坑
本题中坑还挺多。

1.只有当某个点兴奋时才能往后传递信号。

2.第一层不需要减去阈值。

3.如果输出层没有兴奋细胞，要输出NULL。
# 代码
~~我认为没多少人喜欢上面的一通分析吧~~，那么，你们喜欢的代码来了——
```cpp
#include<queue>
#include<cstdio>
using namespace std;
const int MAXN=110;
int n,m;
int tot=0;//建边要用
int sdepth,dv[MAXN][MAXN],ldv[MAXN];//sdepth表示总层数
queue<int> q;
struct Vertex{
	int head,rhead;
	int ind;
	int state,value;
	int depth;
}vt[MAXN];
struct Edge{
	int u,v,w;
	int next;
}e[MAXN*MAXN];
void addEdge(int u,int v,int w){//邻接表建边
	e[++tot].u=u,e[tot].v=v,e[tot].w=w;
	e[vt[u].rhead].next=tot;
	if(!vt[u].head) vt[u].head=tot;
	vt[u].rhead=tot;
	vt[v].ind++;//加入度
}
void readIn(){//读入
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%d",&vt[i].state,&vt[i].value);
	while(m--){
		int aa,bb,cc;//瞎起的变量名
		scanf("%d%d%d",&aa,&bb,&cc);
		addEdge(aa,bb,cc);
	}
}
void toposort(){//拓扑排序
	int u,v;
	for(int i=1;i<=n;i++){
		if(vt[i].ind==0){//如果入度为0
			vt[i].depth=1;//在第一层
			dv[1][ldv[1]++]=i;//第一层加上
			q.push(i);//进入队列
		}
	}
	while(!q.empty()){//队列不为空
		u=q.front();q.pop();
		for(int k=vt[u].head;k;k=e[k].next){//邻接表
			v=e[k].v;
			vt[v].ind--;//减入度
			if(vt[v].ind==0){//同上，1改为vt[v].depth
				vt[v].depth=vt[u].depth+1;
				dv[vt[v].depth][ldv[vt[v].depth]++]=v;
				q.push(v);
			}
		}
	}
	sdepth=vt[u].depth;//总深度就是最后一个点的深度
}
void Changestate(){//改变状态
	for(int i=1;i<=sdepth;i++){//一层一层遍历
		for(int j=0;j<ldv[i];j++){
			int id=dv[i][j];//编号
			if(i>1) vt[id].state-=vt[id].value;//非第一层的减去阈值
			if(vt[id].state<=0) continue;//没有兴奋
			for(int k=vt[id].head;k;k=e[k].next){//邻接表便利
			    int v=e[k].v;
			    vt[v].state+=e[k].w*vt[id].state;//公式
		    }
		}
	}
}
void writeOut(){//输出
	bool flag=1;//记录是否有输出
	for(int i=0;i<ldv[sdepth];i++){
		int id=dv[sdepth][i];
		if(vt[id].state>0){//满足条件
			printf("%d %d\n",id,vt[id].state);
			flag=0;//标记
		}
	}
	if(flag) printf("NULL");//没有输出就输出NULL
}
int main(){
	readIn();
	toposort();
	Changestate();
	writeOut();
	return 0;//华丽结束
}
```
不管写的好还是不好，我毕竟花了这些时间来写这篇题解，所以别忘了点个赞！

---

## 作者：teafrogsf (赞：25)

[日常宣传博客。](http://teafrog26.lofter.com/)

题目已经~~显然地~~告诉我们，我们需要从入度为0的点开始遍历，直到出度为0的点，从这里我们就可以~~显然地~~看出来这是一个拓扑排序。

但题目的细节给出**在输入层神经元被激发之后**，说明如果是输入层，那么u[i]为1或0都没有关系。

## 它一定会被激活。

于是我们需要预处理这种情况，并预处理出度为0的点来方便输出。

（给予新人）拓扑排序可以把一个DAG（有向五环图）里所有的点排成一个线性序列，这个序列保证一条边的from点在to点之前输出。

我的代码长度只有50行，编程复杂度应该是比较低的，非常友好XD

```cpp
#include<cstdio>
#include<queue>
#define neko 110
#define meko 10010
#define f(i,a,b) for(register int i=a;i<=b;++i)
struct node
{
    int u,v,w,next;
}e[meko];
int c[neko],u[neko],head[neko],dgr[neko],dgp[neko],n,m,t;
void add(int x,int y,int z)
{
    e[++t].u=x;
    e[t].v=y;
    e[t].w=z;
    e[t].next=head[x];
    head[x]=t;
    ++dgr[y],++dgp[x];
}
void topsort()
{
    std::queue<int>q;int x,v;
    f(i,1,n)if(!dgr[i])q.push(i);
    while(!q.empty())
    {
        x=q.front();
        q.pop();
        for(register int i=head[x];i;i=e[i].next)
        {
            v=e[i].v;
            --dgr[v];
            if(c[x]>0)c[v]+=c[x]*e[i].w;
            if(!dgr[v])q.push(v);
        }
    }
}
int main()
{
    int x,y,z;bool flag=0;
    scanf("%d%d",&n,&m);
    f(i,1,n)
    {
        scanf("%d%d",&c[i],&u[i]);
        if(c[i]==0)c[i]-=u[i];
    }
    f(i,1,m)scanf("%d%d%d",&x,&y,&z),add(x,y,z);
    topsort();
    f(i,1,n)if(c[i]>0&&dgp[i]==0)printf("%d %d\n",i,c[i]),flag=1;//dgp is about output
    if(!flag)printf("NULL\n");return 0;
}
```

---

## 作者：MakotoTSK (赞：15)

算法：广度优先搜索&&拓扑排序

思路：因为图是一层一层的，所以把入度为0的点都入队列，判断状态是不是可以传递信号，可以传的话就按公式传到下一个再把被传的入队，直到传到最后一层。因为不会传给同层的和下层的节点，所以可以按顺序一遍搜就过了。

注意：这题面不知道坑了多少人。第一层不用减阙值，最后一层不能清掉信号。

```cpp
#include <iostream>
#define maxn 110
using namespace std;
int n,p;
int c[110],u[110],rd[110],cd[110];
int g[110][110];
int q[2000010];
int main()
{
	cin>>n>>p;
	for(int i=1;i<=n;i++){
		cin>>c[i]>>u[i];
		c[i]-=u[i];
	}
	for(int i=1;i<=p;i++)
	{
		int s,t;
		cin>>s>>t;
		cin>>g[s][t];
		rd[t]++;
		cd[s]++;
	}
	int head=0,tail=1;
	for(int i=1;i<=n;i++)
	{
		if(rd[i]==0)
		{
			q[++tail]=i;
			c[i]+=u[i];
		}
	}
	while(head<tail)
	{
		head++;
		if(c[q[head]]>0)
		{
			for(int i=1;i<=n;i++)
			{
				if(g[q[head]][i]!=0)
				{
					c[i]+=g[q[head]][i]*c[q[head]];
					q[++tail]=i;
				}
			}
			if(cd[q[head]]!=0)
			c[q[head]]=0;
		}
	}
	int flag=0;
	for(int i=1;i<=n;i++)
	{
		if(c[i]>0)
		{
			flag=1;cout<<i<<" "<<c[i]<<endl;
		}
	}
	if(flag==0)
	cout<<"NULL"<<endl;
	return 0;
}
```

---

## 作者：封禁用户 (赞：10)

## 个人认为这题数据可加强

//当神经元处于兴奋状态时,下一秒它会向其他神经元传送信号

也就是说如果小于0，就不会向下传值（像#3）

多出几个像#3这样的点应该会卡死很多人吧

~~反正我是入坑了（逃）~~

废话不多说，开讲：

像这种子工程之间先后关系非常明显的题一般都是拓扑排序

拓扑排序便于我们处理每一层向下的结果

```cpp
#include<bits/stdc++.h>
using namespace std;
int st[10001],head[10001],n,p,last[10001];
int top,in_du[10001],out_du[10001],num_edge,c[10001],u[10001];
struct Edge
{
	int next,to,d;
}edge[10010];//热爱前向星的我
inline void add_edge(int from,int to,int dis)
{
	edge[++num_edge].next=head[from];
	edge[num_edge].to=to;
	edge[num_edge].d=dis;
	head[from]=num_edge;
}
int main(){
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	{
		cin>>c[i]>>u[i];
		if(c[i]>0) st[++top]=i;
	}
	for(int i=1;i<=p;i++)
	{
		int x,y,d;
		cin>>x>>y>>d;
		add_edge(x,y,d);
		in_du[y]++;
		out_du[x]++;//判断是否为输出层
	}
	int l=0;
	while(top>0)
	{
		int x=st[top--];
		for(int i=head[x];i;i=edge[i].next)
		{
			in_du[edge[i].to]--;
			if(c[x]>0) c[edge[i].to]+=edge[i].d*c[x];//避免#3这样的坑点
			if(in_du[edge[i].to]==0)
			{
				st[++top]=edge[i].to;
				c[edge[i].to]-=u[edge[i].to];
			}
		}
	}
	bool bj=false;//判断输出NULL
	for(int i=1;i<=n;i++)
	  if(out_du[i]==0&&c[i]>0) cout<<i<<' '<<c[i]<<endl,bj=true;
	if(bj==false) cout<<"NULL";
}
```

---

## 作者：hibiki (赞：10)

先吐槽一下题意不清。。

第一层不适用公式好歹也明确说一下吧。。第3和第5个点卡了很久很久啊qwq

然后写做法，既然图是分层的，显然可以用BFS遍历整张图，因为这样可以保证搜索一个点时，它上一层的所有点已经被全部遍历，这个点的值也就不会再改变。只要一个点的C值在某次更新后大于0就直接入队

每次扫描点的时候要额外检查一下该点的C是否大于0，因为可能在入队以后有某次更新导致改点的C值变为小于0

最后扫描所有的点记录答案，排序以后输出。

如果发现答案的数量等于0，就输出NULL

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<set>
#define MAXN 100
using namespace std;
int u[MAXN+10],c[MAXN+10];
int cnt=0;
struct road{
    int next,v,tv;
}roads[MAXN\*MAXN+10]; //邻接表
int list[MAXN+10];
int queue[MAXN\*MAXN\*MAXN+10];
int ind[MAXN+10],outd[MAXN+10];
bool flag[MAXN+10];
int h=1,t=0,n,p;
int ans[MAXN+10];
void add(int u,int v,int w){
    cnt++;
    roads[cnt].v=w;
    roads[cnt].tv=v;
    roads[cnt].next=list[u];
    list[u]=cnt;
}
int main(){
    scanf("%d%d",&n,&p);
    memset(ind,0,sizeof(ind));
    memset(outd,0,sizeof(outd));
    memset(flag,0,sizeof(flag));
    for (int i=1;i<=n;i++){
        scanf("%d%d",&c[i],&u[i]);
        if (c[i]) u[i]=0; //题目最大的坑。。如果c的初始值大于0代表这个点是第一层，第一层的u没有用。。
        c[i]-=u[i]; //直接默认为c就是-u
    }
    for (int i=1;i<=p;i++){
        int x,y,w;
        scanf("%d%d%d",&x,&y,&w);
        ind[y]++; //计算入度和出度
        outd[x]++;
        add(x,y,w);
    }
    for (int i=1;i<=n;i++){ //将所有第一层的节点入队
        if (ind[i]==0&&(c[i]>0)){
            t++;
            queue[t]=i;
        }
    }
    while (h<=t){ //邻接表遍历整张图
        if (c[queue[h]]<0) { //重复检查队列元素有效性
            h++;
            continue;
        }
        int w=list[queue[h]];
        while (w){
            c[roads[w].tv]+=roads[w].v\*c[queue[h]]; //更新值
            if (c[roads[w].tv]>0&&!flag[roads[w].tv]){ //一旦c大于0直接入队
                t++;
                queue[t]=roads[w].tv;
                flag[roads[w].tv]=1;
            }
            w=roads[w].next;
        }
        h++;
    }
    int tot=0;
    for (int i=1;i<=n;i++){ //统计答案
        if (outd[i]==0&&c[i]>0){
            tot++;ans[tot]=i;
        }
    }
    sort(ans+1,ans+tot+1); //排序后输出
    for (int i=1;i<=tot;i++){
        printf("%d %d\n",ans[i],c[ans[i]]);
    }
    if (tot==0) printf("NULL");
}

---

## 作者：2233颗GoldenEgg (赞：10)

**太真实了，这道题做了我一年**

其实这道题的思路还是很简单的，相信各位大佬肯定轻轻松松就把这道题给切了

首先这道题第一眼看上去就应该能想到用的是BFS的思想，再看题目中C[i]的计算方式，显然是有传递性的，那么就能够确定要用**拓扑排序**

先贴代码在说细节。。

```cpp
#include<bits/stdc++.h>
#define R register int
#define debug cout<<"debug"<<endl;
using namespace std;
const int N=105;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
} 
int tot,n,p,sum[N];
int head[N],next[N<<1],to[N<<1],val[N<<1],U[N],C[N],chu[N],ru[N],Ru[N];
inline void add(int x,int y,int z)
{
	next[++tot]=head[x];
	head[x]=tot;
	to[tot]=y;
	val[tot]=z;
}
inline void toposort()
{
	queue<int> q;
	for(R i=1;i<=n;i++) if(ru[i]==0) q.push(i);
	while(!q.empty())
	{
		//if(ru[i]!=
		int x=q.front();q.pop();
		if(Ru[x]>0)
	 	 C[x]=sum[x]-U[x];
		for(R i=head[x];i;i=next[i])
		{
			int t=to[i];
			if(C[x]>0)sum[t]+=val[i]*C[x];
			ru[t]--;
			if(ru[t]==0) q.push(t);
		}
	}
}
int main()
{
	n=read();p=read();
	for(R i=1;i<=n;i++)
	{
		C[i]=read();
		U[i]=read();
	}
	for(R i=1;i<=p;i++)
	{
		int x=read(),y=read(),z=read();
		add(x,y,z);
		chu[x]++;
		ru[y]++;
		Ru[y]++;
	}
	//for(R i=1;i<=n;i++) cout<<"出度 "<<chu[i]<<" "<<"入度 "<<ru[i]<<endl;
	//memcpy(Ru,ru,sizeof(ru));
	//for(R i=1;i<=n;i++) cout<<ru[i]<<' '<<Ru[i]<<endl;
	toposort();
	bool flag=false;
	for(R i=1;i<=n;i++)
	{
		if(chu[i]==0&&C[i]>0)
		printf("%d %d\n",i,C[i]),flag=true;
	}
	if(!flag) cout<<"NULL";
	return 0;
}
```
可能各位大佬会觉得我的数组开的多很麻烦但是我觉得这样的实现应该算得上是挺方便的了

因为输入层的C的值，也就是节点的状态在一开始就已经给出，即**初始状态**，所以在执行topo的过程中不可以随意更新它们的值。而显然，它们的共同特点是**入度为0**，所以就需要在更新C[i]之前进行判定：i的入度是否大于0，大于0则更新。可是如果我们单单加入这个判定，就会导致每一个点的C都得不到更新（显而易见），那怎么办呢？

我们可以新建一个数组，记录所有点的入度，**并且永远不进行更新**，这样的话上述问题就得到了解决。

然后就是很坑第一点。。我明明一开始就注意到了，但是一直认为这个条件对最终答案没有影响，害我WA了同一个点无数次。。

在更新改节点对sum数组的影响时，我们还需要加上一个判定：C[i]是否大于零，因为**只有活跃的节点才会向后传递信号**。

至此本题完美解决，但是别忘了无解输出的NULL.

---

## 作者：无言独上机房 (赞：5)

看了许多dalao选择一开始都减掉阈值，个人感觉处理起来比较麻烦。（尝试的时候出各种各样的问题，比如一个神经元没有入边但阈值为负，它的c值理应没有变化，但却会变成正的输出。）

因此新开一个变量来存每个神经元是否减过阈值，在每次传输的时候进行判断。

考虑每一个神经元只会进队一次，因此用一个bool数组来存入队情况，避免反复进队。

最后，可以考虑把每个传输完毕的神经元c值都重置为0,便于输出。

以下附AC代码（用向量写的，如有问题请各位dalao指正）
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int to;
	int v;
	node(int a,int b)
	{
		to=a;
		v=b;
	}
};
struct S{
	int u;
	int num;
	int c;
	int pd;
}s[105];
vector<node>v[110];//用向量来存图
queue<int>q;
int n,a,b,C,p,sum=0;
bool inque[105];
int main()
{
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	   {
	   	s[i].num=i;
	   	cin>>s[i].c>>s[i].u;
	  // 	if(s[i].c<=0) s[i].c-=s[i].u;
      //    本来考虑减掉阈值的，后来放弃了233333333
	   }
	for(int i=1;i<=p;i++)
	{
		cin>>a>>b>>C;
		v[a].push_back(node(b,C));
	}
	for(int i=1;i<=n;i++)
	   if(s[i].c>0) q.push(i);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
        //下面这一段比较复杂，因为不会写邻接表（大雾
		for(int i=0;i<v[s[x].num].size();i++)
		   {
		   s[v[s[x].num[i].to].c=s[v[s[x].num[i].to].c+v[s[x].num][i].v*s[x].c;
		   	if(!s[v[s[x].num][i].to].pd) s[v[s[x].num][i].to].c-=s[v[s[x].num][i].to].u;
			s[v[s[x].num][i].to].pd=1;
		   	if(s[v[s[x].num][i].to].c>0&&!inque[s[v[s[x].num][i].to].num])
			 { 
			   //s[v[s[x].num][i].to].c=s[v[s[x].num][i].to].c-s[v[s[x].num][i].to].u; 
			   inque[s[v[s[x].num][i].to].num]=1;
			   q.push(v[s[x].num][i].to);
			 }
		}
		if(!v[x].empty()) //有出边，说明不是输出层
		{
		s[x].c=0; //将传输完成的神经元重置为0
		}	
	}
	for(int i=1;i<=n;i++)
	{
		if(s[i].c<=0) sum++;
	}
		//cout<<sum<<endl;
       
	if(sum==n) cout<<"NULL"<<endl;
	else for(int i=1;i<=n;i++)
	{
		if(s[i].c>0)
		{
				cout<<s[i].num<<" "<<s[i].c<<endl;
		}
	}
}

```

---

## 作者：奶油青豆烧鱼 (赞：4)

本来是想写[P1083 借教室](https://www.luogu.org/problemnew/show/P1083) 的，结果题号打错了 。刚好想水几道图论的题，顺手A了。
题面即是一个简化版的神经网络模型：给出输入层以及各神经元参数，求输出层状态。

分析一下。由题意可得，同一层内神经元互不影响，并且每个神经元状态只由上一层神经元状态与边权影响，且只影响下一层神经元。

看了一下其他的题解，似乎（基本上）都是拓扑排序+递推，实现起来有点麻烦（因为我比较蠢，拓扑排序经常打爆）。

其实可以反向建图，从每个输出层节点开始跑一遍记忆化搜索就好啦~

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct tEdge{int v,w,pre;}E[10001];int head[101],tot;
void AddEdge(int u,int v,int w){E[++tot].v=v,E[tot].w=w,E[tot].pre=head[u],head[u]=tot;}
int n,p,c[101],u[101],w[10001],cnt[101],vis[101];
int DFS(int p){
	if(vis[p])return c[p];
	vis[p]=true;
	for(int i=head[p];i;i=E[i].pre)
		c[p]+=DFS(E[i].v)*E[i].w;
	if(c[p]>0)return c[p];
	else return 0;
}
int main(){
	cin>>n>>p;
	for(int i=1,u;i<=n;i++){
		cin>>c[i]>>u;
		if(!c[i])c[i]-=u;
	}
	for(int i=1,u,v,w;i<=p;i++){
		cin>>u>>v>>w;
		AddEdge(v,u,w);
		cnt[u]++;
	}
	bool flag=false;
	for(int i=1;i<=n;i++)
		if(cnt[i]==0)
			if(DFS(i)>0)cout<<i<<" "<<DFS(i)<<endl,flag=true;
	if(!flag)cout<<"NULL"<<endl;
	return 0;
}
```

注1：本题坑点较多。

1.只输出非0状态的输出层节点。

2.如果所有输出层节点状态为0，输出“NULL”（即没有其他输出）。

3.输入层状态不受阈值影响。


注2：貌似重新发明了一遍拓扑排序……不过是递归写法的。

---

## 作者：AuCloud (赞：2)

[题目链接](https://www.luogu.org/problem/P1038)

# 题意理解/分析

首先读题，我们发现，它是分层的图，每一层只能由上一层激活，向下一层传递，并且每个点可能被多个点更新

~~所以，dfsgg~~

那就考虑bfs（~~baidu~~ breadth first search）

正确性显然，因为队列先进先出，而先放入的节点层数一定$\ge$后放入的节点层数，所以当一个节点被拿出来更新其他节点时，一定是被更新完了的，也就正确了。

# 注意
- 宽搜前所有入度为0的点都要加入队列
- 宽搜时判断c是否$\le$0，若成立则q.pop()然后continue
- 输出时注意判断是否活跃
- 注意NULL
- 注意把输出的序号升序排列

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int mapp[101][101];
int fi[101], en[101];
int totf, tote;
bool used[101];
struct hehe{
	int num;
	int c;
	int u;
	int in;
	int out;
}a[101];
signed main()
{
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i].c >> a[i].u;
		a[i].num = i;
		if(!a[i].c) a[i].c -= a[i].u;
	}
	for(int i = 1; i <= m; i++)
	{
		int x, y, w;
		cin >> x >> y >> w;
		mapp[x][y] = w;
		a[x].out++;
		a[y].in++;
	}
	for(int i = 1;i <= n; i++)
	{
		if(!a[i].out) en[++tote] = i;
		if(!a[i].in) fi[++totf] = i;
	}
	queue < int > q;
	for(int i = 1; i <= totf; i++)
	{
		q.push(a[fi[i]].num);
	}
	while(q.size())
	{
		int now = q.front();
		q.pop();
		if(a[now].c <= 0) continue;
		for(int i = 1; i <= n; i++)
		{
			if(mapp[now][i])
			{
				a[i].c += mapp[now][i] * a[now].c;
			}
			if(!used[i])
			{
				q.push(a[i].num);
				used[i] = 1;
			}
		}
		if(a[now].out) a[now].c = 0;
	}
	bool f = 0;
	sort(en + 1, en + tote + 1);
	for(int i = 1; i <= tote; i++)
	{
		if(a[en[i]].c > 0)
		{
			cout << en[i] << ' ' << a[en[i]].c << endl;
			f = 1;
		}
	}
	if(!f) cout << "NULL" << endl;
	return 0;
}

```
完结撒花~~~

~~（强烈谴责出题人用脚造数据，我把输出的c打成u了还有40分）~~

---

## 作者：利刃随人 (赞：2)

## 瞎扯部分
并不理解为什么你们的代码都这么长。。。。本蒟蒻从没听说过拓扑排序，这是个我们模拟赛的题（~~虽然当时只得到了40pts~~),考试后觉得自己代码很没毛病啊！！然后不服气回来看了一下，发现两个憨批错误，改了后直接AC（~~改代码当时周围同学在机房开Party，条件艰苦的AC~~）。

首先当时拿到这道题就是艰难的读题（然而还是没读懂，导致了上面的两个错误）。这道题也许是数据水，我没有怎么费脑细胞就改出来了，以下说我的思路。
## 正文
首先存边，存边的时候要记得弄一个bool数组，将每次的起点的值设置为true。因为只是需要输出神经元的值，也就是没有出边的神经元的值。然后我就开始主体算法，枚举每个点，然后枚举每个终点为当前枚举的点的边（因为数据范围比较小，我才有勇气这样做）。然后判断，如果此边起点的c值大于0，才可以传递（见题目），然后跑公式，这题就做完了。

### PS：输出可能也要费点脑子，这里就不讲了

## AC代码
```cpp
#include<cstdio>
#include<cmath>
#define maxn 101
using namespace std;
int c[maxn],u[maxn];
int cnt,n,p;
bool flag[maxn];
struct Edge{
	int from,to,worth;
}e[maxn*4];
int main()
{
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++)
	scanf("%d%d",&c[i],&u[i]);
	for(int i=1;i<=p;i++)
	{
	scanf("%d%d%d",&e[i].from,&e[i].to,&e[i].worth);
	flag[e[i].from]=true;
	}
	for(int i=1;i<=n;i++)
	{
	int sum=0;
	bool pan=false;
	for(int bian=1;bian<=p;bian++)
	if(e[bian].to==i&&c[e[bian].from]>0)
	{
		pan=true;
		int j=e[bian].from;
		sum+=e[bian].worth*c[j];
	}
	if(pan)
	c[i]=sum-u[i];
	}
	bool pnl=false;
	for(int i=1;i<=n;i++)
	{
	if(!flag[i]&&c[i]!=0)
	pnl=true;
	}
	if(!pnl)
	{
		printf("NULL\n");
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		if(!flag[i]&&c[i]>0)
		printf("%d %d\n",i,c[i]);
	}
	return 0;
}
```


---

## 作者：AnChun999 (赞：2)

- 可以从一开始就把Ui减掉，虽然没什么差，只是前面减和后面减的区别而已。

- 但是要记住，不能修改输入点的Ci！！！

- 累加能量小于等于0就都以0论处

- 没有输出就要输出NULL


------------

本蒟蒻的做法是先找到【输入点】，往上层寻找【能♂量】来源。

一层一层往上找，直到找到【输入点】，然后再把【能♂量】传递下来。

当然，算过【能♂量】的【神经元】就打个标记。

------------
代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int c[110],flag[110],ans[110],rudu[110];
//  ↑点的值 ↑标记   ↑出度   ↑入度 
struct asd
{
    int back[10100],value[10100];
    //  ↑指向这点的点  ↑路径长度 
}father[110];

int back(int now)//向上找点 
{
    if(rudu[now]==0||flag[now]==1)//是输入点或已被计算过 
    {
        flag[now]=1;//标记计算过了 
        if(c[now]<0)//不活跃就不传值了 
        c[now]=0;
        return c[now];
    }

    for(int i=1;i<=rudu[now];i++)//向上的每点 
    {
        //累加 
        c[now]+=back(father[now].back[i])*father[now].value[i];
    }
    if(c[now]<0)//算完发现不活跃 
    c[now]=0;

    flag[now]=1;//标记计算过了  
    return c[now];
}

int main()
{
    int n,p;
    scanf("%d%d",&n,&p);

    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d%d",&c[i],&x);
        if(!c[i])//输入点不用减！！！！！！！！ 
        c[i]-=x;
    }

    for(int i=1;i<=p;i++)
    {
        int a,b,d;
        scanf("%d%d%d",&a,&b,&d); 
        ans[a]++;//出度 
        rudu[b]++;//入度 
        father[ b ].back[rudu[b]]=a;//a点链接b点，记录边长value 
        father[ b ].value[rudu[b]]=d;
    }

    int total=0;//活跃输出点数量 
    for(int i=1;i<=n;i++)
    {
        if(!ans[i])//判断是输出点 
        {
            c[i]=back(i);//向上找有关的点计算c 
            if(c[i]>0)//不活跃不输出，活跃就输出 
            printf("%d %d\n",i,c[i]),total++;
        }
    }

    if(!total)//没答案就输出NULL 
    printf("NULL");

    return 0;
}
```

---

## 作者：OIer991215 (赞：2)

/\*
其实我没打算发题解的，但是看看题解里各位dalao的题解都太长了。

于是我发现我的代码比较简短，也没有用到那么多写法知识点，所以发个题解，供大家瞧瞧

\*/
/\*
本题注意：

1.求和公式不包括减掉的阀值

2.如果某点有入度，则不减去阀值；只有Ci大于0时才会继续计算

3.多读几遍题再做

\*/


                
```cpp
#include <iostream>
using namespace std;
int INF=2333;
int n,m,x,y,z,cnt1,cnt2;
int W[110][110];
int I[110],U[110];
bool f[110],g[110]; 
int main()
{
    //数据范围很小，怎么写都会过的。 
    cin>>n>>m;
    for(int i=1; i<=n; i++)
        cin>>I[i]>>U[i];
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
            W[i][j]=INF;//边权全部初始化 
    for(int i=1; i<=m; i++)
    {
        cin>>x>>y>>z;
        W[x][y]=z;
        f[x]=1;// 标记 x有出度  ， 在第45--56行 会用到，目的是为了判断该点是否需要输出。 
        g[y]=1;// 标记 y有入度  ， 在第37行会用到 ，因为有入度的点 需要减阀值。 
    }
    for(int i=1; i<=n; i++)
        if(g[i]==1) 
            I[i]-=U[i]; 
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
            if(W[i][j]!=INF&&I[i]>0)
                I[j]+=W[i][j]*I[i];       // 39--42行为模拟 查找 ， 看看应该就能秒懂
    //第45--56行为 判断NULL的情况，很麻烦，希望各位大佬能想办法简化一下 
    for(int i=1; i<=n; i++)
    {
        if(f[i]==0)
            cnt1++;
        if(f[i]==0&&I[i]<=0)
            cnt2++;
    }
    if(cnt1==cnt2)
    {
        cout<<"NULL";
        return 0;
    }
    //非NULL情况下的输出 , 如 58--60行 
    for(int i=1; i<=n ;i++)
        if(f[i]==0&&I[i]>0)
            cout<<i<<" "<<I[i]<<endl;
    return 0;
}
```

---

## 作者：QwQ2000 (赞：2)

我比较蠢。。居然没想到这个题是拓扑排序 不过反正这道题很水 我就直接模拟过去啦

这个题有几个点需要注意

1.如果是输入层的点C不要减去U

2.不要减去多次U U只减一次

3.输出层的神经元状态小于等于零就不要输出了

```cpp

#include <cstdio>
#include <vector>
#include <set>
#include <queue>

using namespace std;

struct node {
    int c,u;    
    node() { }
    node(int a,int b):c(a),u(b) { }
};

struct edge {
    int u,v,w;
    edge() { }
    edge(int a,int b,int c):u(a),v(b),w(c) { }
};

int n=0,p=0;
node a[101];
vector<edge> e;
vector<int> g[101];
set<int> ans;
bool vis[101],input[101];

void bfs() {
    for (int i=1;i<=n;++i)
        vis[i]=input[i]=false;
    queue<int> q;
    for    (int i=1;i<=n;++i)
        if (a[i].c!=0) {
            q.push(i);
            vis[i]=true;
            input[i]=true;
        }
    while (!q.empty()) {
        int cur=q.front();
        q.pop();
        if (!input[cur])
            a[cur].c-=a[cur].u;
        if (g[cur].size()==0 && a[cur].c>0)
            ans.insert(cur);
        else {
            for (int i=0;i<g[cur].size();++i) {
                edge ce=e[g[cur][i]];
                if (!vis[ce.v]) {
                    q.push(ce.v);
                    vis[ce.v]=true;
                }
            }    
            if (a[cur].c>0) {
                for (int i=0;i<g[cur].size();++i) {
                    edge ce=e[g[cur][i]];
                    a[ce.v].c+=ce.w*a[cur].c;
                }
            }
        }
    }
    if (!ans.size())
        printf("NULL\n");
    else
        for (set<int>::iterator it=ans.begin();it!=ans.end();++it)
            printf("%d %d\n",*it,a[*it].c);
}

int main(void) {
    scanf("%d %d",&n,&p);
    for (int i=1;i<=n;++i) {
        int c=0,u=0;
        scanf("%d %d",&c,&u);
        a[i]=node(c,u);
    }
    for (int i=0;i<p;++i) {
        int u=0,v=0,w=0;
        scanf("%d %d %d",&u,&v,&w);
        e.push_back(edge(u,v,w));
        g[u].push_back(e.size()-1);
    }
    bfs();
    return 0;
}


```

---

## 作者：empty_zhm (赞：1)

# 拓扑排序（拓扑序dp）
>	遇到 `DAG` 就要想到 `拓扑dp` 是 OIer 必须掌握的直觉  
>	——本人机房某大佬

![](https://cdn.luogu.com.cn/upload/pic/58252.png)

其中点 $1$、$2$ 为信息形成点。  
加上一个重要条件：**神经元间是没有回路的。**  
发现像什么？—— **DAG(AOE网)** 啊！  
所以让我们愉快拓扑。
### 怎么拓扑dp？
可以把每个点的状态的计算公式转化为下式：（没有看计算的小朋友可以回去再看看）  
有一个已确定状态的点 $j$ ，如果有任意点 $i$ 为其子任务点，就有$C_i=\sum\limits_{\{j|(j,i) \in E\}} W^i_j  C_j$。  
所以每去掉一个点，就对其所有相连的点加上 $W^i_j  C_j$ 即可。
## 阀值
**对于阀值我们知道：**  

1.  阀值对于每个信息形成节点没有什么用！因为形成节点已经确定了状态。    

2.  别看原来题目的计算公式有求和函数，但 `ta` 没有加括号，也就是说每个节点状态的阀值只会损失一次（而不是入边的条数）。     

**所以我们得知：阀值是可以预处理的，方式见代码**  
**最后输出的时候只需要把输出层的状态输出就好了（记得特判）**
# 代码
```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 100010
using namespace std;
int C[N],_in[N],n,m;
struct edge//链式前向星 || updata 2020/12/3:那时本人独爱指针
{
	int to,price;
	road *next;
	road(){to=0;price=0;next=NULL;}
}*A[N];
queue<int> W;
void add(int a,int b,int c)//加入一条由a到b的代价为c的边
{
	if(A[a]==NULL)//记得特判啊（因为是指针）
	{
		A[a]=new(road);
		A[a]->to=b;
		A[a]->price=c;
		return;
	}
	edge *p=new(road);
	p->price=c;
	p->to=b;
	p->next=A[a]->next;
	A[a]->next=p;
}
void C_up()//处理所有节点的状态（拓扑序传递状态）
{
	while(!W.empty())
	{
		int a=W.front();
		for(road *i=A[a];i!=NULL;i=i->next)
		{
			_in[i->to]--;//拓扑的基本操作（删点减入度）
			C[i->to]+=(i->price)*C[a];//相连节点传递状态
			if(_in[i->to]==0&&C[i->to]>0) W.push(i->to);
			//如果已经处于传递层且有正状态
		}
		W.pop();
	}
}
int main()
{
	cin >> n >> m;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin >> C[i] >> a;
		if(C[i]>0) W.push(i);//阀值处理，如果是信息形成层，就把它压入队列（后面再集中处理）
		else C[i]-=a;//反正始终都要减去，不如先减了？在拓扑里减多麻烦
	}
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin >> a >> b >> c;
		add(a,b,c);//详情见上
		_in[b]++;//记得统计入度
	}
	C_up();//处理
	bool flag=0;//记录有没有答案
	for(int i=1;i<=n;i++) 
		if(A[i]==NULL) //没有出度——输出层
			{
				if(C[i]>0) //看看是不是负状态
				{
					flag=1;
					cout << i << ' ' << C[i] << '\n';//输出咯
				}
			}
	if(!flag) cout << "NULL";//没有一个输出层有信号
	return 0;
}

```
$updata\ 2020/12/3 :$ 好久以前的题解了，可能说法不够严谨，修改了一下 


---

## 作者：LetMyself (赞：1)

emmmmmm大致看了一下大家的题解，似乎都是拓扑排序。emmmmm原谅我，在这道题之前我还没咋接触过拓扑排序，所以直接按照bfs来做的，其实代码原理都差不多。

bfs的起点显然是输入层，而输入层也很好判断——c > 0的点即为输入层。正如前面的大佬们提到的，u这个量是没必要开一个数组的，输入时如果这个点c > 0（即为输入层的点)，那么u直接扔掉，否则就直接令c = c - u。

每个点我们只想加入队列一次，于是引入inque[i]来表示第[i]点是否已经加入过队列了。在bfs过程中，如果一个点的c[i] > 0 并且 inque[i] == false,就把它加到队列尾。

对于输出层的点如何判断，我们引入一个量"maxdep"来表示神经网络的层数，再引入一个数组dep[i]表示第i个点所在的层数，显然dep[i]==maxdep的点即为输出层的点。

bfs即可。

代码如下：
```cpp
#include<iostream>
#include<queue>
using namespace std;
const int MAXN = 105;
queue<int> q;
int n, p, maxdep, cnt;
int head[MAXN], c[MAXN], dep[MAXN];
bool inque[MAXN];//inque[i]表示第[i]个点是否已经加入过队列了 

struct Edge{
	int to, w, nxt;
	Edge(int a = 0, int b = 0, int c = 0):to(a),w(b),nxt(c){}
}edge[MAXN * MAXN];

inline void addedge(int u, int v, int w){
	edge[++cnt] = Edge(v, w, head[u]);
	head[u] = cnt;
}

inline void bfs(){
	while(!q.empty()){
		int f = q.front();q.pop();
		for(int i = head[f];i;i = edge[i].nxt){
			int to = edge[i].to;
			dep[to] = dep[f] + 1;
			maxdep = max(maxdep, dep[to]);
			c[to] += c[f] * edge[i].w;
			if(c[to] > 0 && !inque[to]){
				inque[to] = true;
				q.push(to);
			}
		}
	}
}

int main(){
	cin>>n>>p;
	for(int i = 1, u;i <= n;i++){
		cin>>c[i]>>u;
		if(c[i]> 0)
			q.push(i), inque[i] = true;//压进输入层的点 
		else c[i] = c[i] - u;
	}
	for(int i = 1, u, v, w;i <= p;i++){
		cin>>u>>v>>w;
		addedge(u, v ,w);
	}
	bfs();
	bool ok = false;
	for(int i = 1;i <= n;i++)
		if(c[i] > 0 && dep[i] == maxdep){
			ok = true;
			cout<<i<<" "<<c[i]<<endl;
		}
	if(!ok) cout<<"NULL";
	return 0;
}
```


---

## 作者：万万没想到 (赞：1)

原题传送门：[P1038 神经网络](https://www.luogu.org/problemnew/show/P1038)

这道题目~~显然是拓扑排序的~~图论，但在这里笔者给予大家一种较为特殊的方法。

题目中已经给出了每一层的神经元的信息只会传给下一层，那么也就说明，一层神经元不可能越过一层进行传递，这样的话我们可以通过递归预处理来进行递推暴力的求解方法。

dag数组表示的是每一个神经元，dag[i].son数组是表示dag[i]的下一层，dag[i].w数组是表示边的数据。fa[i][j]=1表示j是i的上一层可传递者,vis[i][j]=1表示第i层存在j号神经元。预处理层数vis数组和fa数组，再循环神经元层数，所在层数与上一层可传递节点的边暴力求解。

因为每个神经元只会在某一层出现一次，所以即便三层循环，剪枝过后时间复杂度只有O(n²)

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int maxdeep=1,n,p,c[101],u[101],a,b,vis[121][121],fa[121][121];
struct node{
	int son[121],w[121];
}dag[121];
void dfs(int num,int step){
	for(register int i=1;i<=dag[num].son[0];++i){
		vis[step+1][dag[num].son[i]]=1;
		fa[dag[num].son[i]][num]=1;
		dfs(dag[num].son[i],step+1);
	}
	if(dag[num].son[0])maxdeep=max(maxdeep,step+1);
}
int main(){
	scanf("%d%d",&n,&p);
	for(register int i=1;i<=n;++i){
		scanf("%d%d",&c[i],&u[i]);
	}
	for(register int i=1;i<=p;++i){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		dag[x].son[++dag[x].son[0]]=y;
		dag[x].w[y]=z;
	}
	for(register int i=1;i<=n;++i){
		if(c[i]>0){
			vis[1][i]=1;
			dfs(i,1);
		}
	}
	for(register int i=2;i<=maxdeep;++i){
		for(register int j=1;j<=n;++j){
			if(vis[i][j]){
				for(register int k=1;k<=n;++k){
					if(fa[j][k]&&c[k]>0){
						c[j]=c[j]+dag[k].w[j]*c[k];
					}
				}
				c[j]-=u[j];
			}
		}
	}
	int cnt=0;
	for(register int i=1;i<=n;++i){
		if(vis[maxdeep][i]&&c[i]>0){
			cnt++;
			printf("%d %d\n",i,c[i]);
		}
	}
	if(!cnt)printf("NULL\n");
	return 0;
}
```


---

## 作者：liuxu (赞：1)

自创的分层入队法。真是不知道怎么想的。。。
读入时将状态不为0的点加入队列。
每次在BFS更新u节点所连的点v的时候，将v加入一个数组needinq顾名思义需要将他放入队列，为何不直接放入队列呢，因为可能该层还有其他节点能更新v节点。在队列为空也就是该层遍历完后将needinq中的节点放入队列。
okk了
上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<queue>
#include<vector>
#define LL long long
#include<algorithm>
using namespace std;
int n,m,vis[110],needinq[110];
struct Edge{
	int to,l;
};vector<Edge> E[110];
struct Node{
	int no,data,value;
}N[110];
queue<Node> q;
void BFS(){
	while(1){
		Node x=q.front(); q.pop();
		for(int i=0;i<E[x.no].size();i++){
			N[E[x.no][i].to].data+=E[x.no][i].l*x.data;
			needinq[E[x.no][i].to]=1;
		}
		if(q.empty()) for(int i=1;i<=n;i++) if(needinq[i]&&N[i].data>0) q.push((Node){N[i].no,N[i].data,N[i].value});
		memset(needinq,0,sizeof(needinq));
		if(q.empty()) return;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&N[i].data,&N[i].value);
		N[i].no=i;
		if(N[i].data){q.push(N[i]); vis[i]=1;}
		else N[i].data-=N[i].value;
	}
	for(int i=1;i<=m;i++){
		int u,v,w; scanf("%d%d%d",&u,&v,&w);
		E[u].push_back((Edge){v,w}); 
	}
	BFS();
	int flag=0;
	for(int i=1;i<=n;i++){
		if(E[i].empty()&&N[i].data>0){
			printf("%d %d\n",N[i].no,N[i].data);
			flag=1;
		}
	}
	if(!flag) printf("NULL\n");
	return 0;
} 
```

---

## 作者：森海塞尔 (赞：1)

/\*什么，拓扑排序？不存在的

觉得自己写的对小白应该挺友好的

其实自己就是小白

思路其实和bfs很像

都是按层次搜索

需要用一个数组记录第i个点是不是在队列中

因为每个点要修改多次\*/

        
    
            
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
int map[101][101];//存图 
int c[101];//状态 
int u[101];//阈值 
int r[101];//入度 
int cc[101];//出度 
bool flag[101];//判断 
int n,m;
int q[100001];//手写队列 
//c[i] = w[i][j] * c[j] - u[i].
int main()
{    freopen("123.txt","r",stdin);//防抄袭 
    memset(map,0,sizeof(map));
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>c[i]>>u[i];
        if(c[i]!=0)
        u[i]=0;//////特判很重要呀！60分和100分的差别也是看了楼下才知道 
    }
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        map[x][y]=z;
        //cout<<x<<y<<map[x][y]<<endl;
        r[y]++; 
        cc[x]++;
    }
    memset(flag,0,sizeof(flag));//初始化flag 
    int head=1;
    int tail=1;
    for(int i=1;i<=n;i++)
    {
        if(r[i]==0)
        {    
            q[tail]=i;
            flag[i]=1;
            tail++;
```
}//入度为0的点就是起点，起点入队
```cpp
    }
    //cout<<endl<<q[head]<<endl;
    while(head<=tail)
    {
        for(int i=1;i<=n;i++)
        {
            if(map[q[head]][i]!=0)//有边相连 
            {
                if(flag[i]==0)//没有在队列里 
            {
                q[tail]=i;//入队 
                //flag[i]=tail;
                flag[i]=1;//标记 
                if(c[q[head]]-u[q[head]]>=0)//判断 
                c[i]+=map[q[head]][i]*(c[q[head]]-u[q[head]]);//在计算c[]的时候要等到计算他的子节点的时候再减去u[i]避免重复 
                //cout<<i<<' '<<c[i]<<endl;
                tail++;
                //flag[q[head]]=0;
            }
            else {//如果已经在队里 
                if(c[q[head]]-u[q[head]]>=0)
                c[i]+=(map[q[head]][i])*(c[q[head]]-u[q[head]]);
            }
        }    
     } 
    head++;
 }   //bfs思路 
 bool ff=0;
     for(int i=1;i<=n;i++)
     {
         if(cc[i]==0&&c[i]-u[i]>0)//出度为0的边是终点 
         cout<<i<<" "<<c[i]-u[i]<<endl,ff=1;//标记 
     }
  if(ff==0)cout<<"NULL";
  return 0;
//完成！！
}
```

---

## 作者：封癫 (赞：1)

这道题我才不会承认我用的思想其实是**搜索**233

其实不需要使用正规的有向图存储方法，也就是那个t[i][j]=1

可以使用结构体存储一个神经元的所有输入和输出，输出边统计是0的神经元自然是输出层，输入边统计是0的也就是输入层

随后扫描一遍数组，遇到输出层神经元就上一发递归搜索，即递归搜索它的前驱，碰到状态不为零或已经回到输入层就返回当前神经元的状态

最后累加

有一个坑点一开始坑了我六十分，那就是当c[i]<0时按c[i]=0来算

最后上代码


        
```cpp
#inlude<iostream>
#inlude<cstdio>
struct data{
    int h[105][2];
    int t[105][2];
    int tot,sum;
    int u,k;
    data(){tot=sum=0;}
}f[105];
int search(int i)
{
    if(f[i].k||f[i].tot==0)    return f[i].k;
    int ans=0;
    for(int j=1;j<=f[i].tot;++j)
        ans+=(    search(f[i].h[j][0]) * f[i].h[j][1]    );
    ans-=f[i].u;
    if(ans<0)    ans=0;
    return ans;
}
int main()
{
    int n,p;
    scanf("%d%d",&n,&p);
    for(int i=1;i<=n;++i)
        scanf("%d%d",&f[i].k,&f[i].u);
    int a,b,c;
    for(int i=1;i<=p;++i)
    {
        scanf("%d%d%d",&a,&b,&c);
        f[b].h[++f[b].tot][0]=a;
        //cout<<b<<" "<<f[b].tot<<endl;
        f[b].h[f[b].tot][1]=c;
        f[a].t[++f[a].sum][0]=b;
        f[a].t[f[a].sum][1]=c;
    }
    bool flag=0;
    for(int i=1;i<=n;++i)
    {
        if(f[i].sum==0)
        {
            f[i].k=search(i);
            if(f[i].k)
            {
                cout<<i<<" "<<f[i].k<<endl;
                flag=1;
            }
        }
    }
    if(!flag)
        cout<<"NULL"<<endl;
    //cout<<endl<<endl<<endl;
    /*for(int i=1;i<=n;++i)
        cout<<f[i].sum<<" "<<f[i].tot<<" "<<f[i].k<<endl;*/
    return 0;
}
```
细心的同学会发现防抄袭的修改
就这样


---

## 作者：YZ亮晶晶 (赞：1)

难得碰到这么坑的题目，来凑一发题解：

##坑点：

坑一：Σ后面的Ui算是算在Σ外面的，即阈值只用减一遍，希望不会有小伙伴跟我一样数学不好

坑二：输入层的阈值是不用减的

坑三：**输入层可能就是输出层**

坑四：只有在**Ci>0**即兴奋状态下才会向下一个神经元传递信号

坑五：只用输出**大于0**的输出层神经元状态，**从小到大输出**，如果都为0输出**NULL**


##思路：

其实坑点出来了之后这道题差不多就做完了……不过还是讲一讲吧：

将输入层的点进队列，然后操作所有与队首i相连的点j：

①i已经处理过了--统计vis i\*w i,j

②i还没处理且不在队列中，将i入队

最后处理完所有与队首相连的点后再将c[i]←c[i]-u[i]**【此处需要特判输入层】**

如果队首相连的所有点都处理过，说明该点在输出层，标记

所有点做完之后枚举一遍，将标记了的且c[i]>0的点输出


##代码如下(pascal):







```cpp
const MAXN=205;MAXM=MAXN*MAXN;
var n,p,i,h,t,x,y,z:longint;flag:boolean;
    c,u,he,q:Array[0..MAXN]of longint;
    inq,vis,f:Array[0..MAXN]of boolean;//inq:在队列中;vis:已经操作过;f:输出层标记
    v,w,next:Array[0..MAXM]of longint; //静态链接边集数组的邻接表
begin
    //读入部分
    readln(n,p);
    for i:=1 to n do
    begin
        read(c[i],u[i]);
        if c[i]>0 then                //输入层的点
        begin
            inc(t);q[t]:=i;           //入队，为了将输入层与其他点分开,inq没有赋true
        end;
    end;
    for i:=1 to p do
    begin
        read(x,y,z);                  
        //由于读入没有说清楚是否是给出的是单向边,防错就建成双向边了,但看↓题解好像有用单向边
        v[2*i-1]:=y;w[2*i-1]:=z;next[2*i-1]:=he[x];he[x]:=2*i-1;
        v[2*i]:=x;w[2*i]:=z;next[2*i]:=he[y];he[y]:=2*i;
    end;
    //操作部分
    while h<>t do
    begin
        inc(h);
        vis[q[h]]:=true;               //该点已操作
        flag:=false;
        x:=he[q[h]];                   //枚举所有与该点有关的边
        while x<>0 do
        begin
            if vis[v[x]] then          //v[x]是邻接的点
            begin
                if c[v[x]]>0 then inc(c[q[h]],w[x]*c[v[x]])//注意要兴奋才能传递哟
            end
            else begin
                flag:=true;            //有 没有操作过的点,说明队首不是输出层
                if not inq[v[x]] then
                begin                  //入队
                    inc(t);q[t]:=v[x];inq[v[x]]:=true;
                end;
            end;
            x:=next[x];
        end;
        if inq[q[h]] then dec(c[q[h]],u[q[h]]);//除了输入层之外,所有已入队的点inq为true
        if not flag then f[q[h]]:=true;//输出层标记
    end;
    //输出部分
    flag:=false;
    for i:=1 to n do
        if f[i] and (c[i]>0) then
        begin
            writeln(i,' ',c[i]);
            flag:=true;
        end;
    if not flag then writeln('NULL');
end.

```

---

## 作者：ShawnZhou (赞：1)

安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

\*上一个题解有错别字，已更正

其实这道题比较难看的是那个公式，有同学可能上来没能看明白（包括我也是

c[i] = w[i][j] \* c[j] - u[i].

如果是邻接表存图，把w[i][j]换成edge[i].dis就好。

注意到每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息，看图也能看明白，这是一个很显然的DAG，那么可以考虑拓扑排序。

对于那个u数组，这个玩意用处不大，而且除了公式也不参与计算，输入后可以直接把那个数减掉。

使用拓扑排序的原因也很简单，如果你要算一个c[i]，你需要先把之前那个c[j]算出来。题目要我们算终点（出度为0的点）的c值，那么就得先计算上一层，要计算上一层还得先计算上一层的上一层……最终，我们应该从第二层从上往下开始计算（第一层已经给出）。而这个计算的层次正好和拓扑排序方式相对应，所以考虑使用拓扑排序。

我喜欢用邻接表，读入的时候记录每个点的入度和出度，然后跑一次拓扑排序，排序的时候如果出现传递过程则更新c[i]，直到排序完毕，我们就可以把最后面一层的c值算出来。

输出的时候判断，题目要输出c[i]>0的终点，照做就好了。输出的时候再加一个无输出标记，判断是不是输出NULL，就好了。

参考代码:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#define maxn 205
#define INF 2147483647
#define check cout << "ok" << endl;
using namespace std;
struct Edge{
    int from,to,dis;
};
Edge edge[maxn];
int head[maxn];
int tot = 0;
int du_in[maxn];
int du_out[maxn];
int n,p;
int c[maxn],U[maxn];
int from,to,dis;
bool flag = false;

void add_edge(int from,int to,int dis){
    edge[++tot].from = head[from];
    edge[tot].to = to;
    edge[tot].dis = dis;
    head[from] = tot;
}

void toposort(void){
    queue<int> q;
    for (int i=1;i<=n;i++)
        if (du_in[i] == 0)
            q.push(i);

    while (!q.empty()){
        int u = q.front();
        q.pop();
        if (c[u] <= 0){
            for (int i = head[u];i!=0;i = edge[i].from){
            int v = edge[i].to;
            du_in[v]--;
            if (du_in[v] = 0)
                q.push(i);    
            }    
            continue;
        }
        for (int i=head[u];i!=0;i = edge[i].from){
            int v = edge[i].to;
            c[v] += c[u] * edge[i].dis;
            du_in[v]--;
            if (du_in[v] == 0)
                q.push(v);
        }

    }

}

int main(){
    cin >> n >> p;
    for (int i=1;i<=n;i++)
        cin >> c[i] >> U[i];
    for (int i=1;i<=n;i++)
        if (c[i] == 0)
            c[i] -=U[i];

    for (int i=1;i<=p;i++){
        cin >> from >> to >> dis;
        add_edge(from,to,dis);
        du_in[to]++;
        du_out[from]++;
    }

    toposort();

    for(int i=1;i<=n;i++)
        if(du_out[i]==0 && c[i]>0) {
            cout << i << " " << c[i] << endl;
            flag=true;
        }
    if(!flag) 
        cout << "NULL";
    return 0;
}
```

---

## 作者：maorui_cow (赞：0)

这道题坑真的特别多

# ****用邻接矩阵的请注意！！！****

有多个数据有权值为0的边，用邻接矩阵的话初始化建议小一点

接下来是思路

这道题是拓扑排序，而为什么呢？关键在于这个式子

C 
i
​	 =∑ 
(j,i)∈E
​	 W 
ji
​	 C 
j
​	 −U 
i
​	

这个的大概意思就是，如果j通向i相连，ci要加上cj*w[i][j]

所以要先处理出所有通向i的点

所以要用拓扑排序，具体原因先看代码

```
#include<bits/stdc++.h>
using namespace std;
int c[105],u[105];
int g[105][105];
int dp[105];
int rd[105];
int cd[105];
queue<int>q;
int main()
{
	int n,p;
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&c[i],&u[i]);
	}
	for(int i=1;i<=100;i++)//先前提到的注意事项
	{
		for(int j=1;j<=100;j++)
		{
			g[i][j]=-1e6;
		}
	}
	for(int i=1;i<=p;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		g[x][y]=z;
		rd[y]++;//入度
		cd[x]++;//出度
	}
	for(int i=1;i<=n;i++)
	{
		if(rd[i]==0)
		{
			q.push(i);
		}
	}
	while(!q.empty())
	{
		int j=q.front();
		q.pop();
		if(c[j])
		{
			dp[j]=c[j];
		}
		else
		{
			int flag=0;
			for(int i=1;i<=n;i++)
			{
				if(g[i][j]!=-1e6&&dp[i]>0)//注意，只有大于0的状态才会传信号
				{
					dp[j]+=(g[i][j]*dp[i]);
				}
			}
			dp[j]-=u[j];
		}
		for(int i=1;i<=n;i++)
		{
			if(g[j][i]!=-1e6)
			{
				rd[i]--;
				if(rd[i]==0)//这就是原因，只有与i相连的点全处理过，才会处理i
				{
					q.push(i);
				}
			}
		}
	}
	int flag=0;
	for(int i=1;i<=n;i++)
	{
		if(cd[i]==0&&dp[i]>0)
		{
			printf("%d %d\n",i,dp[i]);
			flag=1;
		}
	}
	if(flag==0)
	{
		printf("NULL\n");
	}
	return 0;
}

```

祝我提高rp++


---

## 作者：【天朝】MILK (赞：0)

------------

**分析**
------------


------------

**1. 一个神经节点的值只受它的父节点的影响**

**2. 入度为零为输入层，出度为零为输出层**

**3. 更新先后顺序不影响点权**

------------
**思路**
------------


------------
**1.开头处理-U[ i ]的问题**

**2. 找入度为零的点并更新其他点**

**3.使用双端队列维护出度为零的点列**

------------


**代码**
------------

------------

~~**运行时间可能稍慢**~~

------------


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int INF=0x7fffffff;
int map[205][205]={0},rd[205]={0},cd[205],c[205]={0},u[205]={0};
int n,m,num=0;
int f[205],l[205],tf=0,tl=0;
int main()
{
    int x,y,z,left,right;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            map[i][j]=INF;
        }
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&c[i],&u[i]);
        if(c[i]==0)c[i]-=u[i];
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        map[x][y]=z;
        cd[x]++;
        rd[y]++;
    }
    for(int i=1;i<=n;i++)
    {
        if(rd[i]==0)f[++tf]=i;//输入层
        if(cd[i]==0)l[++tl]=i;//输出层
    }
    left=1,right=tf;
    while(left<=right)//双端队列维护
    {
        x=f[left++];
        if(c[x]<=0)//勿忘
        {
            for(int i=n;i>=1;i--)
            {
                if(map[x][i]!=INF)
                {
                    rd[i]--;
                    if(rd[i]==0)f[++right]=i;
                }
            }
            continue;
        }
        for(int i=n;i>=1;i--)
        {
            if(map[x][i]!=INF)
            {
                c[i]+=map[x][i]*c[x];
                rd[i]--;
                if(rd[i]==0)f[++right]=i;
            }
        }
    }
    for(int i=1;i<=tl;i++)
    {
        if(c[l[i]]>0)num++,printf("%d %d\n",l[i],c[l[i]]);
    }
    if(num==0)printf("NULL\n");
    return 0;
}
```


------------


---

## 作者：jrxc (赞：0)

这题拓扑加……加啥，蒟蒻不懂，大概就是把图走一遍
处理到一个点u的时候，假设它有一条边连向点v，那么就把Cv加上Cu乘该边边权，拓扑保证一个点在处理时它上一层的点已经全部处理完毕，也就是公式中的求和步骤已经完成
至于U，因为只是一个常数，所以可以直接在输入Ci的时候直接在Ci里面减掉就好了，注意输入层不用减去，可以通过Ci是否为零来判断这个点是不是输入层（我之前想过会不会有输入层的Ci值为零的情况，因为题目没有说输入层必然非零，然而实践证明数据并没有，如果有强迫症的话还是存一下U数组，然后当判断一个点入度非零的时候再减去）
按拓扑后的顺序走完全图后再判断出度为0的点的状态，大于0就输出，按照输入顺序扫一遍数组就可以满足题目要求的按编号顺序输出
（若有不足请大佬指教
上代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int n,p,tot,c[110],head[110],s[110],in[110],top,out[110],sum;
struct AA{
	int to,v,next;
}edge[5500];
void add(int a,int b,int k){
	edge[++tot].to=b;
	edge[tot].v=k;
	edge[tot].next=head[a];
	head[a]=tot;
}
void tuopu(){
	for (int i=1;i<=n;i++){//寻找入度为0的点放进数组 
		if (in[i]==0) s[++top]=i;//上文说的强迫症可以在这个地方加个else 减去U 
	}
	for (int i=1;i<=top;i++){
		int x=s[i];// 从数组中取点，断去这个点所有连出去的边，边连过去的点的入度减一 
		for (int j=head[x];j;j=edge[j].next){ 
			in[edge[j].to]--;
			if (in[edge[j].to]==0) s[++top]=edge[j].to;//当该点入度减为0，说明前面该处理的已经处理了，近队列 
		}
	}
}
int main(){
	int a,b,k;
	scanf("%d %d",&n,&p);
	for (int i=1;i<=n;i++){
		scanf("%d %d",&c[i],&a);
		if (c[i]==0) c[i]-=a;
	} 
	for (int i=1;i<=p;i++){
		scanf("%d %d %d",&a,&b,&k);
		add(a,b,k);
		in[b]++;
		out[a]++;
	}
	tuopu();
	for (int i=1;i<=top;i++){//按拓扑排序后的顺序推一遍 
		if (c[i]<=0) continue;
		for (int j=head[i];j;j=edge[j].next){
			c[edge[j].to]+=edge[j].v*c[i];
		}
	}
	for (int i=1;i<=n;i++){
		if (out[i]==0&&c[i]>0){
			printf("%d %d\n",i,c[i]);
			sum++;
		}
	}
	if (sum==0) printf("NULL");
	return 0;
}
```

---

## 作者：ghmgjf (赞：0)

这道题也可以用队列来做，但比较麻烦。。。。没办法，蒟蒻一枚。

首先，将起点（ci==1的点）放入队列之中。当head< tail时，

++head，将队首的点（team【head】）展开去找他的儿子节点。

如果儿子节点没放入队列则放入。l代表本层最后一个点在team【】中的序号，l2用于记录修改前的l，便于输出。当head==l时，则这一层的节点扫描毕。此时l+1到tail间的节点即是下一层的节点。对下一层的节点施行减ui【】操作，如果减完后的ci【】大于0，则这个节点处于兴奋状态，可以向下传递。若不能，则用ex【】（因为exst【】已经用来记录别的了。。。）打个标记阻止继续下传。循环完成后，l2+1到l（也就是tail）之间的便是解（注意只用输出大于0的，所以输出时加一个判定），至于co【】，只是为了按顺序输出用的。

解释写得够详细得了吧。。。

代码如下：


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
#include<queue>
using namespace std;
int n,p,ta,ci[1000001],ui[1000001];
int head,l2,tail,team[1000001],exist[100010];
int ex[1000001],co[1000001],lx;
struct ac
{
    int t,s,next,head,w;
}e[100001*4];
void build(int x,int y,int z)
{
    e[++ta].t=y;
    e[ta].w=z;
    e[ta].s=x;
    e[ta].next=e[x].head;
    e[x].head=ta;
```
}//建图。
```cpp
bool cmp(int a,int b)
{
    return a<b;
}
int main()
{
    cin>>n>>p;
    for(int i=1;i<=n;++i)
    {
        cin>>ci[i]>>ui[i];
    }
    for(int i=1;i<=p;++i)
    {
        int a,b,c;
        cin>>a>>b>>c;
        build(a,b,c);
    }
    for(int i=1;i<=n;++i)
    {
        if(ci[i]!=0)
        {
            team[++tail]=i;
        }
```
}//起点入队。
int l=tail;//此时l为第一层最后一个节点在team【】中的序号。

        
        
```cpp
    while(head<tail)
    {
        if(head==l)//当某一层循环完毕时，执行减ui【】操作。
        {
            for(int i=l+1;i<=tail;++i)
            {
                ci[team[i]]=ci[team[i]]-ui[team[i]];
                if(ci[team[i]]<=0)//如果细胞不兴奋则标记。
                {
                    ex[team[i]]=1;
                }
            }
            l2=l;
            l=tail;//更新l，l2.
        }
        head++; int u=team[head];
       if(ex[u]!=1)//如果节点兴奋，则修改他的子节点。
        {
            for(int i=e[u].head;i;i=e[i].next)
            {
                int go=e[i].t;
                ci[go]+=ci[e[i].s]*e[i].w;
                if(exist[go]!=1)
                {    //如果子节点未入队则入队。
                    exist[go]=1;
                    team[++tail]=go;
                }
            }
        }
    }
    for(int i=l2+1;i<=tail;++i)
    {
        co[++lx]=team[i];
    }
    sort(co+1,co+1+lx,cmp);//从下到大输出。
    if((ci[co[lx]]==0&&ci[co[1]]==0)||tail<n)
    {
        cout<<"NULL";//如果首尾都是0（因为sort过了，所以如果首尾都是0则全是0）或未遍历到输出层，则输出NULL。
    }
    else
    {
        for(int i=1;i<=lx;++i)
        {
            if(ci[co[i]]>0)
            cout<<co[i]<<" "<<ci[co[i]]<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：Yorathgz (赞：0)

按照拓扑序一个一个计算，当进入某个点i的边全部用完时就减去Ui，然后判断Ci，大于0则入队。


## 注意几个点：


1. 输入层不用减去U

2. 有负边

3. 没有则输出NULL（因为这个wa了几次


```cpp
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
typedef long long ll;
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
    if(ch=='-') f=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}

int n,P;
const int maxn=205;
struct edge{int v,w,p;}e[maxn*maxn];
int tot,last[maxn];
struct node{
    int c,u,ine,ote;
    bool in,ot;
}p[maxn];

inline void insert(int u,int v,int w){
    e[++tot]=(edge){v,w,last[u]};last[u]=tot;
}

int main(){
    n=read(); P=read();
    for(int i=1;i<=n;i++)
        p[i].c=read(), p[i].u=read();
    for(int i=1,u,v;i<=P;i++)
        u=read(), v=read(), insert(u,v,read()),
        p[u].ote++, p[v].ine++;
    queue<int> q;
    for(int i=1;i<=n;i++){
        if(!p[i].ine) p[i].in=1, q.push(i);
        if(!p[i].ote) p[i].ot=1;
    }
    while(!q.empty()){
        int u=q.front(); q.pop();
        for(int i=last[u],v;i;i=e[i].p){
            v=e[i].v;
            p[v].c+=e[i].w*p[u].c;
            p[v].ine--;
            if(!p[v].ine){
                p[v].c-=p[v].u;
                if(p[v].c>0)
                    q.push(v);
            }
        }
    }
    bool flag=1; 
    for(int i=1;i<=n;i++)
        if(p[i].ot&&p[i].c>0)
            flag=0, printf("%d %d\n",i,p[i].c);
    if(flag) printf("NULL\n");
    return 0;
}
```

---

## 作者：shadowice1984 (赞：0)

这里着重讲一下审题。

第三，第五个点卡了很久。。。

一直不知怎么回事。

后来发现题目里有一句话叫“在输入层神经元被激发之后”

所以题目中的ui并不是完全无用的！

题目的意思是，第一层神经元的ci是钦定的，不由公式计算；

并且在开始时手动激活所有输入神经元！

但是为了这个开个数组似乎不值~

所以我们在输入是加一个判断，如果ci！=0，则ui=0；

*************************************************

然后拓扑排个序，裸做就行了。

上代码~

        
```cpp
#include<stdio.h>
#include<queue>
using namespace std;
int n;int p;
queue <int> q;int now;
int c[10000];
int map[10000][10000];//邻接矩阵存图
bool wap[10000][10000];bool book[10000];
int tp[10000];int cnt=0;
int res[10000];int cot=0;
const int inf=9999999;
int main()
{
    scanf("%d%d",&n,&p);
    for(int i=0;i<n;i++)//手动memset
    {
        for(int j=0;j<n;j++)
        {
            map[i][j]=inf;
        }
    }
    for(int i=0;i<n;i++)
    {
        int set;int u;
        scanf("%d%d",&set,&u);
        if(set!=0)u=0;//灵魂特判，40分的区别
        c[i]=set-u;
    }
    for(int i=0;i<p;i++)
    {
        int u;int v;int val;
        scanf("%d%d%d",&u,&v,&val);
        map[u-1][v-1]=val;wap[u-1][v-1]=true;//从零开始的数组
    }
    for(int i=0;i<n;i++)//tuopu排序
    {
        q.push(i);
    }   
    while(!q.empty())
    {
        now=q.front();
        for(int i=0;i<n;i++)
        {
            if(wap[i][now])goto skip;//goto语句实现检测入边
        }
        q.pop();
        for(int i=0;i<n;i++)
        {
            wap[now][i]=false;
        }
        tp[cnt++]=now;continue;
        skip:;
        q.push(now);q.pop();
    }
    for(int i=0;i<n;i++)
    {
        if(c[tp[i]]<=0)continue;
        for(int j=0;j<n;j++)
        {
            if(map[tp[i]][j]==inf)continue;
            c[j]+=c[tp[i]]*map[tp[i]][j];    //处理权值    
        }
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(map[i][j]!=inf)goto skipii;//找出度为0的点
        }
        res[cot++]=i;
        skipii:;
    }
    bool flag=true;
    for(int i=0;i<cot;i++)//输出
    {
        if(c[res[i]]<=0)continue;flag=false;
        printf("%d %d\n",res[i]+1,c[res[i]]);
    }
    if(flag)
    {
        printf("NULL");
    }
    return 0;//拜拜程序~
}
```

---

## 作者：Dispwnl (赞：0)

终于过了。。

20->60->100的我很无奈。。

题不太难，就是拓扑排序，但有几点要注意：

1，先把公式看懂。。这个神（la）奇（ji）公式在我的电脑上显示的比较抽象。。是我眼神不好吗。。

一个点的状态=与它相连的点（上一层）与它相连的边的权值和\*与它相连的点的状态-它的u；

2，u没什么用。。就是个数，求状态时减掉就行了；

3，记得存一下出度，出度为0的点当然就是输出点（我开始还用一个变量存层，谁在最后一层就输出。。）

然后就是拓扑排序了

代码：

include<iostream>

include<cstring>

define ll 0x7f

```cpp
using namespace std;
int n,p;
int a[201][201];//邻接矩阵
int du[201];//入度
int c[201],u[201];
int sum[201];
int st[100001];//栈
int du2[201];//出度
bool use[201];//判断此点用过没有
int main()
{    
    cin>>n>>p;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
        a[i][j]=ll;//初始化
    for(int i=1;i<=n;i++)
      cin>>c[i]>>u[i];
    for(int i=1;i<=p;i++)
      {
          int x,y,w;
          cin>>x>>y>>w;
          a[x][y]=w;
        du[y]++;
        du2[x]++;
      }
    int top=0,num=0;
    for(int i=1;i<=n;i++)
      if(!du[i])
      {
          st[++top]=i;
          use[i]=1;
      }
    while(num!=n)//拓扑排序
    {
        for(int i=1;i<=n;i++)
          if(!du[i]&&!use[i])
          {
              c[i]=sum[i]-u[i];
              if(c[i]>0)
              {
                  st[++top]=i;
                  use[i]=1;
            }
          }
        for(int i=1;i<=n;i++)
          if(a[st[top]][i]!=ll&&!use[i])
          {
              sum[i]+=a[st[top]][i]*c[st[top]];//公式
              du[i]--;//入度--
          }
        top--;
        num++;
    }
    int t=0;
    for(int i=1;i<=n;i++)
      if(!du2[i]&&c[i]>0)//输出出度为0&&最后状态大于0的点
      {
          cout<<i<<" "<<c[i]<<endl; 
          t++;
      }
    if(!t) cout<<"NULL";//没有就输出null
    return 0;
}
```

---

## 作者：xun薰 (赞：0)

你们说数据坑..可是我这样做一遍就过.不知道是做法正确（都发题解了能不正确嘛）还是....其他神

马的？？？？？

做法：我先正着建边，然后dfs求出每一次有哪些结点。然后我再反向建边，目的是为了求每一个结点的

进行dfs那样就能求出每个结点的状态，最后我再将输出的结点状态输出就可以啦。

上代码

```cpp
#include<iostream>
#include<cstdio>
#define N 101
using namespace std;
int n,p,x,cc,y,zz,cnt,flag,zsumedge,fsumedge;
int c[N],u[N],rd[N],cd[N],ceng[N],z[N][N],fa[N],zhead[N],fhead[N];
struct E1{
    int x,y,z,nxt;
    E1(int x=0,int y=0,int z=0,int nxt=0):
        x(x),y(y),z(z),nxt(nxt){}
}zedge[N<<1];
struct E2{
    int x,y,z,nxt;
    E2(int x=0,int y=0,int z=0,int nxt=0):
        x(x),y(y),z(z),nxt(nxt){}
}fedge[N<<1];
void zadd(int x,int y,int z){
    zedge[++zsumedge]=E1(x,y,z,zhead[x]);
    zhead[x]=zsumedge;
}
void fadd(int x,int y,int z){
    fedge[++fsumedge]=E2(x,y,z,fhead[x]);
    fhead[x]=fsumedge;
}
void dfs(int k){
    ceng[k]=ceng[fa[k]]+1;
    z[ceng[k]][++z[ceng[k]][0]]=k;
    cc=max(cc,ceng[k]);
    for(int i=zhead[k];i;i=zedge[i].nxt){
        int v=zedge[i].y;
        if(fa[k]!=v){
            fa[v]=k;
            dfs(v);
        }
    }
}
int main(){
    scanf("%d%d",&n,&p);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&c[i],&u[i]);
    }
    for(int i=1;i<=p;i++){
        scanf("%d%d%d",&x,&y,&zz);
        cd[x]++;rd[y]++;
        zadd(x,y,zz);fadd(y,x,zz);
    }
    for(int i=1;i<=n;i++)
    if(!rd[i])dfs(i);
    for(int s=2;s<=cc;s++){
        for(int i=1;i<=z[s][0];i++){
        int v=z[s][i];cnt=0;
        for(int j=fhead[v];j;j=fedge[j].nxt){
            int vv=fedge[j].y;
            if(c[vv]>0)cnt+=(fedge[j].z*c[vv]);
        }
        c[v]=cnt-u[v];
        }
    }
    for(int i=1;i<=n;i++){
        if(cd[i]==0&&c[i]>0){
            flag=1;printf("%d %d\n",i,c[i]);
        }
    }
    if(flag==0)printf("NULL\n");
    return 0;
}
```

---

## 作者：attack (赞：0)

这道题的难度一般，但是测试数据我给打满分！！真的是什么坑数据都有

先简单说一下这道题的思路

读入之后拓扑排序，在排序的过程中按照他给的公式进行计算

说一下这道题的坑点：

1.最后输出结果的时候只有>0的才输出

2.入度为0的点不需要减阈值（会导致第五个测试点WA）

3.阈值最好一开始就减去

4.可以通过记录出度来判断输出区

        
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<cstdlib>
using namespace std;
void read(int & n)
{
    char c='+';int x=0;int flag=0;
    while(c<'0'||c>'9')
    {
        c=getchar();
        if(c=='-')
        flag=1;
    }
    while(c>='0'&&c<='9')
    x=x*10+(c-48),c=getchar();
    flag==1?n=-x:n=x;
}
const int MAXN=201;
struct node
{
    int u,v,w,nxt;
}edge[MAXN*40];
int head[MAXN];
int num=1;
int now[MAXN],yu[MAXN],rudu[MAXN],vis[MAXN],chudu[MAXN];
int n,m;
void add_edge(int x,int y,int z)
{
    edge[num].u=x;
    edge[num].v=y;
    edge[num].w=z;
    edge[num].nxt=head[x];
    head[x]=num++;
}
void Topsort()
{
    queue<int>q;
    for(int i=1;i<=n;i++)
    {
        if(rudu[i]==0)
            vis[i]=1,q.push(i);
        else
            now[i]-=yu[i];
    }
    while(q.size()!=0)
    {
        int p=q.front();
        q.pop();
        for(int i=head[p];i!=-1;i=edge[i].nxt)
        {
            rudu[edge[i].v]--;
            if(rudu[edge[i].v]==0)
            {
                q.push(edge[i].v);
                vis[edge[i].v]=1;
            }
            if(now[edge[i].u]>0)
            now[edge[i].v]+=edge[i].w*now[edge[i].u];
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(chudu[i]==0&&now[i]!=0)
        {
            for(int i=1;i<=n;i++)
            {
                if(chudu[i]==0)
                {
                    if(now[i]>0)
                    printf("%d %d\n",i,now[i]);
                }
            }
            exit(0);
        }
    }
    printf("NULL");
}
int main()
{
    ///freopen("sjwl.in","r",stdin);
    //freopen("sjwl.out","w",stdout);
    read(n);read(m);
    for(int i=1;i<=n;i++)
        head[i]=-1;
    for(int i=1;i<=n;i++)
    {
        read(now[i]);read(yu[i]);
    }
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        read(x);read(y);read(z);
        add_edge(x,y,z);
        rudu[y]++;
        chudu[x]++;
    }
    Topsort();
    return 0;
}
```

---

## 作者：理想气体 (赞：0)

嗯，看完了诸多dalao的代码，发现自己虽然写得长而丑，但思路不太一样。姑且把代码发出来。

这题如下面dalao所言，坑的难度大于题目。其中最坑的是。。。输入神经元有可能成为输出层！！！

如果不加这一条判断，80妥妥的；还有就是看清题，Wij的意义不太容易理解。

其他诸如U在sigma符号外啦，状态小于0不输出信号啦都比较容易看见了。

然后谈谈我的思路。

我才不会说我一开始看错题想用广搜呢

非常暴力的做法，首先当然把输入层扔队列，往下检查，开visited数组记录某个点状态是否已经算过。对于每个节点，若算过直接继续遍历，没算过开始检查所有有向它的边的神经元（就是俗话说的它的爸爸们）是否被算过或是输入层。如果满足条件自然是顺水推舟把它的状态算出来然后标记为算过，否则将|广搜中搜到它的那个节点|（好拗口）重新扔入队列。因为有记录某点是否被算过，因此这种鬼畜的做法并不会耽误时间。最后在如此水的数据下，这种方法顺利通过咯。
下面粘上我那冗长且极不美观的代码仅供参考。






```cpp
#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
struct Neu
{
    int name;
    int c;
    int u;
}ns[101];
bool isvised[101] = {false};
int ways[101][101];
queue<int> q;
vector<int> inum[101];
vector<int> onum[101];
bool isout[101] = {false};
bool isin[101] = {false};
void work()
{
    while(!q.empty())
    {
        int a = q.front();
        bool isok = true;
        for(vector<int>::iterator ite = onum[a].begin() ; ite != onum[a].end() ; ite++)
        {
            if(isvised[*ite])
                continue;
            q.push(*ite);
            int adi = 0;
            bool ok = true;
            for(vector<int>::iterator it = inum[*ite].begin() ; it != inum[*ite].end() ; it++)
            {
                if(!isvised[*it] && (!isout[*it]))
                 ok = isok = false;
            }
            if(!ok)
            {
                ok = true;
                continue;
            }
            for(vector<int>::iterator it = inum[*ite].begin() ; it != inum[*ite].end() ; it++)
            {
                if(ns[*it].c <= 0)
                    continue;
                else
                {
                    adi += ways[*it][*ite]*ns[*it].c;
                }
            }
            ns[*ite].c = adi - ns[*ite].u;
            isvised[*ite] = true;
        }
        if(isok)
            q.pop();
        else
        {
            q.pop();
            q.push(a);
        }
    }
}
int main()
{
    int n , p;
    cin>>n>>p;
    for(int i = 1 ; i <= n ; i++)
    {
        int a , b;
        cin>>a>>b;
        if(a > 0)
        {
            q.push(i);
            isout[i] = true;
        }
        ns[i].c = a;
        ns[i].u = b;
    }
    for(int i = 0 ; i < p ; i++)
    {
        int a , b , c;
        cin>>a>>b>>c;
        ways[a][b] = c;
        inum[b].push_back(a);
        onum[a].push_back(b);
    }
    work();
    vector<int> ans;
    for(int i = 1 ; i <= n ; i++)
    {
        if((onum[i].empty() || (isout[i] && isvised[i])) && ns[i].c > 0)
            ans.push_back(i);
    }
    if(ans.empty())
    {
        cout<<"NULL";
        return 0;
    }
    for(vector<int>::iterator ite = ans.begin() ; ite!= ans.end() ; ite++)
        cout<<*ite<<" "<<ns[*ite].c<<endl;
    return 0;
}
```

---

## 作者：翠竹叶飞 (赞：0)

由于此题每一层中的神经元不会互相影响，所以我们可以用队列实现，保证前面层的神经元先进队。这样当处理到某个结点，我们可以保证此时该结点已经更新完毕。

预处理：输入层就直接判断， 否则先减去阈值。（不必先入队，迟早会被更新掉）

还有注意审题：对序号升序排序！

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define INF 0x7f7f7f7f
using namespace std;
int i,n,m,a,b;
int c[101],u[101];
int w[101][101];
int size=0;
int q[101],f=1,r=0,v;
struct rec
{
    int num, value; 
} ans[101];
bool exist[101];
int comp(rec a, rec b)
{
    return a.num<b.num;
}
int main()
{
    memset(w,INF,sizeof(w));
    memset(exist,0,sizeof(0));
    scanf("%d%d",&n,&m);
    for (i=1; i<=n; i++)
    {
      scanf("%d%d",&c[i],&u[i]);
      if (c[i]!=0) { q[++r]=i; exist[i]=1; }
      else c[i]-=u[i];
    }
    for (i=1; i<=m; i++)
    {
        scanf("%d%d",&a,&b);
        scanf("%d",&w[a][b]);
    }
    while (f<=r)
    {
        v=q[f++];
        exist[v]=0;
        if (c[v]<=0) continue;
        for (i=1; i<=n; i++)
          if (w[v][i]!=INF)
          {
              c[i]+=w[v][i]*c[v];
              if (c[i]>0 && exist[i]==0) //i & v
              {
                  q[++r]=i;
                  exist[i]=1;
              }
          }
        bool flag=1;
        for (i=1; i<=n; i++)
          if (w[v][i]!=INF)
          {
              flag=0;
              break;
          }
        if (flag)   
        {
            size++;
            ans[size].num=v;
            ans[size].value=c[v];
        }
    }  
    if (size==0) printf("NULL");
    else 
    {
      sort(ans+1,ans+size+1,comp);
      for (i=1; i<=size; i++)
        printf("%d %d\n",ans[i].num,ans[i].value);
    }
    return 0;
}
```

---

## 作者：Kwork (赞：0)

这一题坑的难度大于题目本身。

根据题意，我们将图拓扑排序后，从所有的输入点开始向中间层的点输送信息，注意输入点一开始不用减去U[i]，所以要特判断是否为输出点。

然后我们每次去除topo序中的一个点就把他的兴奋值减去U[i],若大于0就继续传递。一直递推。

最后我们吧所有出度为0的点输出即可。

最后一个点非常坑，如果没有边，输入点就不存在，直接输出不用减去U[i]。

---------------------------------------------------------------------------------------------------------------------------------------

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
```
-------------------------------------------------------------------------------------------------------------------------------------
using namespace std;

-------------------------------------------------------------------------------------------------------------------------------------

const int maxn=100+20;

-------------------------------------------------------------------------------------------------------------------------------------

struct edge{int to,w;};

-------------------------------------------------------------------------------------------------------------------------------------

```cpp
int n,p,in[maxn],limit[maxn],ans[maxn],out[maxn];
vector<edge>G[maxn];
queue<int>que;
bool tool[maxn];
queue<int>topo;
```
--------------------------------------------------------------------------------------------------------------------------------------
```cpp
void read(int &n){
    n=0;int f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    n=n*f;
    return;
}
void write(int n){
    if(n<0){
        putchar('-');
        n=0-n;
    }
    if(n>=10) write(n/10);
    putchar((n % 10)+'0');
    return;
}
int main(){
    memset(in,0,sizeof(in));
    memset(out,0,sizeof(out));
    memset(tool,false,sizeof(tool));
    read(n);read(p);
    for(int i=1;i<=n;i++){
        read(ans[i]);read(limit[i]);
    }
    if(p==0){
        for(int i=1;i<=n;i++){
            if(ans[i]>0){
                write(i);
                putchar(' ');
                write(ans[i]);
                putchar('\n');
            }
        }
        return 0;
    }
    for(int i=1;i<=p;i++){
        int u,v,w;
        read(u);read(v);read(w);
        edge e;e.to=v,e.w=w;
        G[u].push_back(e);
        in[v]++;
        out[u]++;
    }
    for(int i=1;i<=n;i++){
        if(in[i]==0){
            que.push(i);
            tool[i]=true;
        }
    }
    while(!que.empty()){
        int u=que.front();
        que.pop();
        topo.push(u);
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].to;
            in[v]--;
            if(in[v]==0){
                que.push(v);
            }
        }
    }
    for(int i=1;i<=n;i++){
        int u=topo.front();
        topo.pop();
        if(!tool[u])
            ans[u]-=limit[u];
        if(ans[u]>0)
            for(int i=0;i<G[u].size();i++){
                int v=G[u][i].to,w=G[u][i].w;
                ans[v]+=w*ans[u];
            }
    }
    bool flag=true;
    for(int i=1;i<=n;i++){
        if(out[i]==0){
            if(ans[i]>0){
                flag=false;
                write(i);
                putchar(' ');
                write(ans[i]);
                putchar('\n');
            }
        }
    }
    if(flag){
        printf("NULL");
    }
    return 0;
}
```

---


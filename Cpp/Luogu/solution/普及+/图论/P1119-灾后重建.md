# 灾后重建

## 题目背景

B 地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。


## 题目描述

给出 B 地区的村庄数 $N$，村庄编号从 $0$ 到 $N-1$，和所有 $M$ 条公路的长度，公路是双向的。并给出第 $i$ 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第 $t_i$ 天重建完成，并且在当天即可通车。若 $t_i$ 为 $0$ 则说明地震未对此地区造成损坏，一开始就可以通车。之后有 $Q$ 个询问 $(x,y,t)$，对于每个询问你要回答在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未重建完成，则需要输出 $-1$。

## 说明/提示

- 对于 $30\%$ 的数据，有 $N\le 50$；
- 对于 $30\%$ 的数据，有 $t_i=0$，其中有 $20\%$ 的数据有 $t_i=0$ 且 $N>50$；
- 对于 $50\%$ 的数据，有 $Q\le 100$；
- 对于 $100\%$ 的数据，有 $1\le N\le 200$，$0\le M\le \dfrac{N\times(N-1)}{2}$，$1\le Q\le 50000$，所有输入数据涉及整数均不超过 $10^5$。

## 样例 #1

### 输入

```
4 5
1 2 3 4
0 2 1
2 3 1
3 1 2
2 1 4
0 3 5
4
2 0 2
0 1 2
0 1 3
0 1 4```

### 输出

```
-1
-1
5
4```

# 题解

## 作者：Time_Rune (赞：1356)

## P1119 【灾后重建】

### 一道非常好的Floyd最短路练习题，从算法本质上出的题目，对于初学Floyd算法的人来说是绝佳的练习题

### 解题难度：普及+/提高

### 重要程度：提高+/省选-


------------

首先我们从Floyd算法谈起，这是一个看上去很简单的算法-事实上也的确很简单，整个算法一共只有五行，三重循环＋一个判断就能求出图中任意两点之间的最短路径。

很多人都是直接把这个算法背了下来，然后要求最短路时直接默写，没有考虑到这个算法的本质意义，而这个题目，正好考了这个算法的本质，如果只会背的话，遇见这题直接就GG。

这个算法的主要思路，就是通过其他的点进行中转来求的两点之间的最短路。因为我们知道，两点之间有多条路，如果换一条路可以缩短距离的话，就更新最短距离。而它最本质的思想，就是用其他的点进行中转，从而达到求出最短路的目的。



------------

那么，如何进行中转呢？两点之间可以由一个点作为中转点更新最短路径，也可以通过多个点更新最短路径。

结合代码：
```cpp
for(k=1;k<=n;k++)

    for(i=1;i<=n;i++)

        for(j=1;j<=n;j++)

            if(e[i][j]>e[i][k]+e[k][j])

                 e[i][j]=e[i][k]+e[k][j];
//核心代码，仅仅只有5行
                 
```

**这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。**

（仔细理解这段话，它揭露了这个算法的本质并为本题提供了很好的方法）

到这里我们已经知道，Floyd算法就是一个利用其它点进行中转来求最短路的步骤。

而我们再回头看题意：

所有的边全部给出，**按照时间顺序更新每一个可用的点**（即修建好村庄），对于每个时间点进行两点之间询问，求**对于目前建设的所有村庄**来说**任意两点之间的最短路**

**不正好就是Floyd算法中使用前k个节点更新最短路的思维吗？**



------------

于是到了这里，我们差不多也就知道这题如何写了。

出题人还是很良心的，保证所有的数据都是用时间顺序给出的，所以我们只用读取+操作就可以了，不用再储存＋排序。

先给出总体思路：

```
int main(){
	读入，存下每个村庄修复的时间
    读入所有的边并使用邻接矩阵存图
    初始化
    对于每次询问，将在当前时间前的所有点全部用Floyd更新。
    特殊判断并输出
}
```
具体实现：（仍然按我写题解的风格分开给出）

首先是初始化部分，相信大家都会写

（特别注意一下这里的点编号是从0开始的，如果像我一样习惯从1开始的标下标的话要特别注意这一点）

~~不过这点写错了样例都过不了还是能很快改过来的吧~~

```cpp
//a数组存各个村庄的建立时间
//f数组用于存两点之间的最短路径

cin>>n>>m;
	for(int i=0;i<n;i++)
	scanf("%d",a+i);//依次输入每一个村庄建立完成时需要的时间
 /*******************初始化*************************/
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	f[i][j]=1e9;//初始化为一个很大的值
	for(int i=0;i<n;i++)
	f[i][i]=0;//一个点到自己的距离为0
 /*******************读入边长*************************/
	int s1,s2,s3;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&s1,&s2,&s3);
		f[s1][s2]=f[s2][s1]=s3;//无向边，存两次
	}
```



然后是处理各询问：



```
	//s1,s2,s3为临时变量，表示两村庄和时间
    int q;cin>>q;//一共q个询问
	int now=0;//用于记录当前时间对应的编号，从第一个村庄开始
	for(int i=1;i<=q;i++){//处理各询问 
		scanf("%d%d%d",&s1,&s2,&s3);
		while(a[now]<=s3&&now<n){//如果目前更新的点的时间在询问点之前
			updata(now);
			now++;
		}//处理在它之前建立的村庄
		if(a[s1]>s3||a[s2]>s3)cout<<-1<<endl;//村庄未建好
		else {
			if(f[s1][s2]==1e9)cout<<-1<<endl;//两点不连通
			else cout<<f[s1][s2]<<endl;//输出路径长
		}
	}
```
**(本题核心) updata函数：**
```cpp
inline void updata(int k){
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	if(f[i][j]>f[i][k]+f[j][k])
	f[i][j]=f[j][i]=f[i][k]+f[j][k];//用这个新的更新所有前面的 
	return;
}
```
标准的Floyd思想，内层循环不变，外层循环按照k的顺序给出

```cpp
	return 0
    //没错，完了，没了，就两个步骤加一个函数.
```

希望各位能通过这个题目更深一层地了解Floyd算法，这真的是一个很优秀的题目。同时它也提醒我们，学习算法时要弄懂各个细节，把整个算法的思想掌握，而不是仅仅把代码背下来.



------------


### 参考资料：[GumpYan在博客中对Floyd算法的讲解](https://www.cnblogs.com/GumpYan/p/5540549.html)

（侵删）

(这篇文章对Floyd算法进行了图文并茂的很详细的讲解，如果想更详细地了解此算法可以去看看）



------------


最后放上完整的AC代码。
```
#include<iostream>
#include<cstdio>
#define N 205
using namespace std;
int n,m;
int a[N];
int f[N][N];//邻接矩阵存边
inline void updata(int k){
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	if(f[i][j]>f[i][k]+f[j][k])
	f[i][j]=f[j][i]=f[i][k]+f[j][k];//用这个新的更新所有前面的 
	return;
}
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++)
	scanf("%d",a+i);//依次输入每一个村庄建立完成时需要的时间
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++){
		f[i][j]=1e9;//初始化为保证它不爆炸范围内的最大值 
	}
	for(int i=0;i<n;i++)
	f[i][i]=0;
	int s1,s2,s3;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&s1,&s2,&s3);
		f[s1][s2]=f[s2][s1]=s3;//初始化边长 
	}
	int q;
	cin>>q;
	int now=0;
	for(int i=1;i<=q;i++){//处理各询问 
		scanf("%d%d%d",&s1,&s2,&s3);
		while(a[now]<=s3&&now<n){
			updata(now);//依次更新点，使它可以被用来更新其他的点 
			now++;
		}
		if(a[s1]>s3||a[s2]>s3)cout<<-1<<endl;
		else {
			if(f[s1][s2]==1e9)cout<<-1<<endl;
			else cout<<f[s1][s2]<<endl;
		}
	}
	return 0;
} 
```

---

## 作者：秋日私语 (赞：69)

这道题加深了我对Floyed算法的理解。

首先谈谈Floyed算法：Floyd算法的本质是动态规划，其转移方程
为：f[k][i][j] = min( f[k-1][i][j], f([k-1][i]
[k])+f[k-1][k][j] )。 

f[k][i][j]表示路径除开起点i与终点j，只经过前k个点中的某些
点，从i到j的最小值。计算这个值只需要考虑两种情况：最短路经
过k，和最短路不经过k（那么就经过前k-1个点中的某些点）。由于
k要从k-1转移而来，自然k为最外层的循环。而经过滚动（类似于背
包问题）后，就变成了我们熟悉的f[i][j]=min(f[i][j],f[i]
[k]+f[k][j])了。


思路一（30分，TLE七个点）： 
对于每一次询问，都把小于当钱时间的点和边加入到图中，然后每一次询问都跑一边Floyed，这样做肯定会超时啊

```
//如果输入数据没有将时间排序，需要先排序，这点很重要 
//每次询问都跑Floyed肯定会超时 
#include<cstdio>
#include<cstring>
using namespace std;
bool b[201];//某村庄是否修好 
int n,m,x,y,z,q,u,v,time,t[201],t1[201],f[201][201],matrix[201][201];//t1存不大于当前时间的点的编号,作为中转站,matrix只用来存原图 
int main()
{
    memset(f,0x7f,sizeof(f));
    memset(matrix,0x7f,sizeof(matrix));
    scanf("%d%d",&n,&m);
    for (int i=0; i<n; i++)//注意从0开始 
        scanf("%d",&t[i]);
    for (int i=1; i<=m; i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        matrix[x][y]=matrix[y][x]=z;
    }
    scanf("%d",&q);
    for (int l=1; l<=q; l++)
    {
        int num=0;
        scanf("%d%d%d",&u,&v,&time);
        for (int i=0; i<n; i++)
            if (t[i]<=time){ t1[++num]=i; b[i]=true; }//找到在当前时间之内可以修好的村庄，可以作为中转站 
        for (int i=0; i<n; i++)//如果两个村庄都修建好了,就把它们之间的最短距离初始化为两点间的距离 
            for(int j=0; j<n; j++)
                if (b[i]&&b[j]) f[i][j]=f[j][i]=matrix[i][j];
        for (int k=1; k<=num; k++)
        {
            for (int i=0; i<n; i++)
                for (int j=0; j<n; j++)
                {
                    if (f[i][j]>f[i][t1[k]]+f[t1[k]][j]&&i!=j&&i!=t1[k]&&t1[k]!=j&&f[i][t1[k]]<0x7f7f7f7f&&f[t1[k]][j]<0x7f7f7f7f)//需要加那些限制条件？
                        f[i][j]=f[i][t1[k]]+f[t1[k]][j];
                }
        }
        if (f[u][v]==0x7f7f7f7f) printf("-1\n");
        else printf("%d\n",f[u][v]);
    }
    return 0;
}
```

思路二（100分）：
改变思路：看中转点k每一次自增能解决什么问题，能回答问题就输出。还要开一个bool数组b[201],标记某村庄是否已经作为中转点,可以从n^3q的复杂度变为 n^3+q的复杂度，这样还是可以接受的。 

代码如下：


```
//改变思路：看k每一次自增能解决什么问题 
//所以要将提出的问题存到一个数组里 
#include<cstdio>
#include<cstring>
using namespace std;
bool b[201];
int n,m,x,y,z,q,t[201],f[201][201];
int from[50001],to[50001],day[50001];//questions;
int main()
{
    memset(f,0x7f,sizeof(f));
    scanf("%d%d",&n,&m);
    for (int i=0; i<n; i++)
        f[i][i]=0;//初始化 
    for (int i=0; i<n; i++)//注意从0开始 
        scanf("%d",&t[i]);
    for (int i=1; i<=m; i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        f[x][y]=f[y][x]=z;
    }
    scanf("%d",&q);
    int tot=0;
    for (int i=1; i<=q; i++)
    {
        scanf("%d%d%d",&from[i],&to[i],&day[i]);
    }
    for (int l=1; l<=q; l++)
    {
        for (int k=0; k<n; k++)
            if (t[k]<=day[l]&&!b[k])
            {
                b[k]=1;
                for (int i=0; i<n; i++)
                    for (int j=0; j<n; j++)
                        if (f[i][j]>f[i][k]+f[k][j]&&i!=j&&i!=k&&k!=j&&f[i][k]<0x7f7f7f7f&&f[k][j]<0x7f7f7f7f)
                            f[i][j]=f[i][k]+f[k][j];
            }
        if (t[from[l]]<=day[l]&&t[to[l]]<=day[l]&&f[from[l]][to[l]]!=0x7f7f7f7f)
            printf("%d\n",f[from[l]][to[l]]);
        else printf("-1\n");
    }
    return 0;
}
```

---

## 作者：cwjfighting (赞：59)

我怕是第一个用dijstra艹过去的吧，虽然需要o2优化下，但是A了不容易啊，激动的立马写一篇题解来打破floyd的天下，啊哈哈，写的不好勿喷呀，下面我讲一下我的优化过程吧

每次询问都更新村庄是否修好，然后进行dijstra，这样的复杂度大概是Q*M*log(n)

在这个过程中进行各种xjb优化剪枝降低复杂度就AC了。。。

下面给出代码，优化剪枝就在代码中解释啦！若有不足还请大神指点！

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define bug printf("*********\n");
#define mem0(a) memset(a, 0, sizeof(a));
#define mem1(a) memset(a, -1, sizeof(a));
#define finf(a, n) fill(a, a+n, INF);
#define fuck(x) cout<<#x<<" = "<<x<<endl
#define ios ios::sync_with_stdio(false);
#pragma comment(linker, "/STACK:102400000,102400000")
using namespace std;
typedef long long LL;
typedef unsigned long long uLL;
typedef pair<LL, pair<int, LL> > LLppar;
typedef pair<int, int> par;
typedef pair<LL, int> LLpar;
const LL mod = 1e8;
const LL INF = 1e9+7;
const int base = 131;
const double r = 0.57721566490153286060651209;
const double eps = 0.000001;
const double pi = 3.1415926;

int n, m;
int t[200], dist[200], vis[200], ok[200], now[200][200], good[200][200];

//good存全修好的最短路，now不断更新当前得到的最短路
//ok数组表示当前的村庄是否修好

int read() { ///普通读入挂
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

int Min(int a, int b) {return a < b ? a : b;}

struct node {
    int first ,second;
    node(int first_,int second_) {
        second=second_;
        first=first_;
    }
    bool operator < (const node & a) const {
        return a.first < first;
    }
};

//用前向星建图跑的慢点
vector<node> G[200]; //用vector存图好像快一点，主要是我排了个序，嘻嘻

void dijstra(int s) {
    mem0(vis);
    priority_queue<node> q;
    for(int i = 0; i < n; ++ i) {
        dist[i] = INF;
    }
    q.push(node(0, s));
    dist[s] = 0;
    while(!q.empty()) {
        node cur = q.top();q.pop();
        int u = cur.second;
        if(vis[u]) continue;
        vis[u] = 1;
        for(int i = G[u].size()-1; i >= 0; i --) {
            int en = G[u][i].second;
            if(!ok[en]) continue; //不能走
            int len = G[u][i].first+cur.first;
            if(dist[en] > len) {
                dist[en] = len;
                now[s][en] = now[en][s] = Min(now[s][en], len); //不断更新当前的最优解
                q.push(node(len, en));
            }
        }
    }
}

void Out(int a) {    //输出外挂
    if(a < 0) { putchar('-'); a = -a; }
    if(a >= 10) Out(a / 10);
    putchar(a % 10 + '0');
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    //freopen("out.txt", "w", stdout);
#endif
    int x, y, z, q;
    n = read();
    m = read();
    for(int i = 0; i < n; ++ i) {
        t[i] = read();
        ok[i] = 1;
    }
    for(int i = 0; i < m; ++ i) {
        x = read();
        y = read();
        z = read();
        G[x].push_back(node(z, y));
        G[y].push_back(node(z, x));
    }
    for(int i = 0; i < n; i ++) {
        sort(G[i].begin(), G[i].end());
    }
    for(int i = 0; i < n; ++ i) {
        dijstra(i);
        for(int j = 0; j < n; ++ j) {
            good[i][j] = dist[j]; //求解全修好时的最优解，也可以floyd
        }
    }
    mem0(ok);
    for(int i = 0; i < n; ++ i) {
        if(!t[i]) ok[i] = 1;
        for(int j = 0; j < n; ++ j) if(i != j) now[i][j] = INF; //初始化
    }
    q = read();
    int idx = 0;
    while(q --) {
        x = read();
        y = read();
        z = read();
        for(int i = idx; i < n; ++ i) {
            if(t[i] > z) break;
            if(!ok[i]) ok[i] = 1;
            idx = i;
        }
        //在两个点都联通且当前解不是最优解才进行dij
        if(ok[x] && ok[y] && now[x][y] != good[x][y]) dijstra(y);
        if(now[x][y] == INF || !ok[x] || !ok[y]) Out(-1);
        else Out(now[x][y]);
        putchar('\n');
    }
#ifndef ONLINE_JUDGE
    cout <<"It costs " <<clock() <<" ms\n";
#endif
    return 0;
}


```


---

## 作者：Dog_Two (赞：46)

## 核心算法

先前的题解已经过讲解得很清楚了：对于**原始**的floyd算法，f[k][i][j]的含义是：以i,j为起点和终点，路径上的中间点编号**不超过**k的最短距离。

## 预处理

由于0~n-1号节点的修复时间都是**单调不下降**的，天然符合**原始floyd**的更新过程，我们就可以用原始floyd来预处理f[k][i][j]。

## 回答

对于询问的时间为ti的节点，显然，途径（和起终点）的节点u应当满足fix_time[u]<=ti，也就恰好是某一个ki作为第一维的f[k][i][j]。

## 本代码的优势

在确定了如上思路之后，本人在回答询问的时候，使用
```cpp
_t=--upper_bound(fix_time+0,fix_time+n,ti)-fix_time;
ans=dis[_t][x][y];
```
来大幅度简化代码，几乎做到了O(1)回答，再加上本人自诩风格简洁清晰的代码，应当可以对查看题解的同学们有较大帮助。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200+10;
int n,m,q;
int fix[maxn];
int dis[maxn][maxn][maxn];

void read(){
	cin>>n>>m;
	for(int i=0;i<n;++i) scanf("%d",&fix[i]);
	memset(dis,0x3f,sizeof(dis));
	for(int i=1;i<=m;++i){
		int u,v,w; scanf("%d%d%d",&u,&v,&w);
		dis[0][u][v]=dis[0][v][u]=w;
	}
}

void prework(){
	for(int i=0;i<n;++i) dis[0][i][i]=0;
	for(int i=0;i<n;++i)
		for(int j=0;j<n;++j)
			dis[0][i][j]=min(dis[0][i][j],dis[0][i][0]+dis[0][0][j]);
	for(int k=1;k<n;++k)
		for(int i=0;i<n;++i)
			for(int j=0;j<n;++j)
				dis[k][i][j]=min(dis[k-1][i][j],dis[k-1][i][k]+dis[k-1][k][j]);
}

void solve(){
	cin>>q;
	for(int i=1;i<=q;++i){
		int u,v,t; scanf("%d%d%d",&u,&v,&t);
		int _t=upper_bound(fix,fix+n,t)-fix-1;
		printf("%d\n",t<fix[u] or t<fix[v] or dis[_t][u][v]==0x3f3f3f3f?-1:dis[_t][u][v]);
	}
}

int main(){
	read();
	prework();
	solve();
	return 0;
}
```

---

## 作者：睿屿青衫 (赞：46)

初始化数组用0x3f（7f会炸成负数），注意时间数组也要初始化（要退出循环），双向边跑Floyd，判断（特判输出结果）那里我一开始写的dis>9999结果挂掉好几个点，最后看了看题解改成==0x3f3f3f3f就AC了（问了问别人，数组就这样操作，如果初始化0x7f，那就判断==0x四个7f）。如果这道题时间顺序乱的话，还要加一次排序。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define maxn 210
#define maxm 50010
using namespace std;
int n,m,dis[maxn][maxn],t[maxm],q,k;
int main()
{
    scanf("%d%d",&n,&m);
    memset(dis,0x3f,sizeof(dis));
    memset(t,0x3f,sizeof(t));
    for(int i=0;i<n;i++)
     scanf("%d",&t[i]),
      dis[i][i]=0;
    for(int i=1;i<=m;i++)
     {
         int a,b,c;
         scanf("%d%d%d",&a,&b,&c);
         dis[a][b]=dis[b][a]=c;
     }
    scanf("%d",&q);
    for(int o=1;o<=q;o++)
     {
         int a,b,c;
         scanf("%d%d%d",&a,&b,&c);
         while(t[k]<=c)
          {
              for(int i=0;i<n;i++)
               for(int j=0;j<n;j++)
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
              k++;
          }
        if(dis[a][b]==0x3f3f3f3f||t[a]>c||t[b]>c) printf("-1\n");
         else printf("%d\n",dis[a][b]);
     }
    return 0;
}
```

---

## 作者：智子 (赞：25)

本题基本上是Floyd的模版题，适合初学Floyd的OIer练习。

本题的重点在于并非在每一个时刻，每一个节点都可以到达，所以应枚举目前所有可以到达的节点k，并以k为中转点进行更新。

同时，因为出题人已经给数据排好了顺序，发现未建成时直接中断即可。

闲话少说，主要看代码注释。

```cpp
#include<cstdio> 
#include<algorithm>
using namespace std;

const int MAXN = 200 + 5;
const int INF = 1e9;

int edge[MAXN][MAXN], times[MAXN];
int n, m, q;

/*
init()函数：
Floyd初始化
*/
void init() {
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			edge[i][j] = (i == j ? 0 : INF);//节点到自身的距离为0
		}
	}
}

/*
addEdge()函数：
在邻接矩阵中添加一条（双向）边
*/
void addEdge(int i, int j, int v) {
	edge[i][j] = edge[j][i] = v;//双向边处理
}

/*
input()函数：
输入数据
*/
void input() {
	scanf("%d%d", &n, &m);
	init(); //读入n, m后进行初始化
	for(int i = 0; i < n; i++) {
		scanf("%d", &times[i]);
	}
	for(int i = 0; i < m; i++) {
		int x, y, v;
		
		scanf("%d%d%d", &x, &y, &v);
		addEdge(x, y, v);
	}
}

/*
update()函数：
以k为中转点更新最短路
*/
void update(int k) {
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);
		}
	}
}

void work() {
	int cur = 0;
	
	scanf("%d", &q);
	for(int i = 0; i < q; i++) {
		int x, y, t;
		
		scanf("%d%d%d", &x, &y, &t);
        
		//这里是重点
		while(times[cur] <= t && cur < n) {
			update(cur);//若当前可以经过村庄cur，以cur为中转点更新最短路径
                        cur++;
		}
		if(times[x] > t || times[y] > t || edge[x][y] == INF) {
			printf("-1\n");//村庄x尚未建成,村庄x尚未建成或村庄x与村庄y在t时并不连通
		} else {
			printf("%d\n", edge[x][y]);
		}
	}
}

int main() { //简洁的main()函数
	input();
	work();
    
	return 0;
}
```

---

## 作者：KagurazakaLorna (赞：16)

**其实，我是开O2优化AC的，不开只有50分，所以可以直接跳过这篇。**

**并且方法非常暴力，基本不动脑子。**

因为 n<=200 且 数据保证了t[0] ≤ t[1] ≤ … ≤ t[n – 1]

所以这个图其实只有200种状态：包含前1个点，包含前2个点，包含前3个点......

于是对于每种情况都做一遍Floyd......

程序：
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
#define inf 1000000000

int n,m,q,pos=0;
int t[203];
int g[203][203],dis[203][203];

void print(int u,int v) {
    if (dis[u][v]==inf) cout<<-1<<endl;
    else cout<<dis[u][v]<<endl;
    return;
}

int main() {
    ios::sync_with_stdio(0);
    cin>>n>>m; 
    for (int i=1;i<=n;i++) cin>>t[i];
    t[0]=-1; t[n+1]=inf;
    for (int i=1;i<n;i++)
        for (int j=i+1;j<=n;j++) g[i][j]=g[j][i]=dis[i][j]=dis[j][i]=inf;
    for (int i=1;i<=n;i++) g[i][i]=0;
    for (int i=1;i<=m;i++) {
        int u,v,w; cin>>u>>v>>w;
        u++; v++;
        g[u][v]=g[v][u]=w;
    }
    cin>>q;
    while (q--) {
        int u,v,time; cin>>u>>v>>time;
        int temp=pos;
        while (time>=t[pos]) pos++; pos--;
        if (temp==pos) {
            print(u+1,v+1); continue;
        }
        for (int i=1;i<pos;i++) 
            for (int j=i+1;j<=pos;j++) dis[i][j]=dis[j][i]=g[i][j];
        for (int k=1;k<=pos;k++)
            for (int i=1;i<=pos;i++)
                for (int j=1;j<=pos;j++)
                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
        print(u+1,v+1);
    }
    return 0;
}
```

---

## 作者：president (赞：12)

这道题有点小坑，我最开始用dij+堆优化写的，但只有50分，看了题解区的大佬才知道这题用floyd优化写。



------------
正~~片~~篇开始

为什么不能用dij+堆优化

dij+堆优化的时间复杂度始O(Q * m * logn),所以到后面是会爆的，所以要始用floyd。但常规的floyd时间复杂度始O(Q*n^3)，更慢，所以，考虑优化；


------------
每次枚举k时都要判定在w时可不可以到这个点，并且看是否标记了k。

```cpp
for(int k=0;k<n;k++)
		{
			if(t[k]<=w&&!vis[k])
			{
				vis[k]=1;
				for(int i=0;i<n;i++)
					for(int j=0;j<n;j++)
						if(f[i][j]>f[i][k]+f[k][j])
							f[i][j]=f[i][k]+f[k][j];
			}
		}
```


------------

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=210;
const int M=20010;
int f[N][N],vis[N];
int n,m,Q,t[N];
int main()
{
//	freopen("testdata.in","r",stdin);
//	freopen("test.out","w",stdout);
	memset(f,inf,sizeof(f));
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++) scanf("%d",&t[i]),f[i][i]=0;;
	int u,v,w;
	for(int i=1;i<=m;i++) scanf("%d%d%d",&u,&v,&w),f[u][v]=f[v][u]=w;
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%d%d%d",&u,&v,&w);
		for(int k=0;k<n;k++)
		{
			if(t[k]<=w&&!vis[k])
			{
				vis[k]=1;
				for(int i=0;i<n;i++)
					for(int j=0;j<n;j++)
						if(f[i][j]>f[i][k]+f[k][j])
							f[i][j]=f[i][k]+f[k][j];
			}
		}
		if (t[u]<=w&&t[v]<=w&&f[u][v]<inf) printf("%d\n",f[u][v]);
        else printf("-1\n");
	}
	return 0;
}
```


---

## 作者：JayYee (赞：12)

废话挺多，代码还是蛮短的。





```cpp
/*在线spfa(T了四个点，60分） 
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
int read()
{
    int x=0,f=1;
    char ch;
    while(ch<'0'||ch>'9')  {if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return f*x;
}
const int N=209,M=(N-1)*N,oo=0x5fffffff;
int n,m,t[N],q,head[N],dis[N],cnt,vis[N];
struct node{
    int to,next,d;
}a[M];
void add(int x,int y,int z){
    a[cnt].to=y;
    a[cnt].next=head[x];
    a[cnt].d=z;
    head[x]=cnt++;
}
void spfa(int s,int e,int w){
    if(t[e]>w || t[s]>w){
        printf("-1\n");
        return;
    }
    fill(dis,dis+N,oo);
    dis[s]=0;
    queue<int> q;
    q.push(s);
    vis[s]=1;
    while(!q.empty()){
        int k=q.front();
        q.pop();
        vis[k]=0;
        for(int i=head[k];i!=-1;i=a[i].next){
            int u=a[i].to;
            if(t[u]<=w && dis[k]+a[i].d<dis[u]){
                dis[u]=dis[k]+a[i].d;
                if(!vis[u]){
                    q.push(u);
                    vis[u]=1;
                }
            }
        }
    }
    if(dis[e]==oo) printf("-1\n");
    else printf("%d\n",dis[e]);
}
int main(){
    fill(head,head+N,-1);
    n=read();m=read();
    for(int i=0;i<n;i++){
        t[i]=read();
    }
    for(int i=1;i<=m;i++){
        int x1,y1,z1;
        x1=read();y1=read();z1=read();
        add(x1,y1,z1);
        add(y1,x1,z1);
    }
    q=read();
    for(int i=1;i<=q;i++){
        int x1,y1,t1;
        x1=read();y1=read();t1=read();
        spfa(x1,y1,t1);
    }
    return 0;
}
```
然而正解是floyd(惊了)
由于题目给出了无论是每个点的t[i]还是询问(x,y,t)中的t都是上升的，所以

可以从第一个点0开始找，知道t[cnt]>这次询问的t，就相当于把这之前的都搞好了，

然后再后面的询问因为给出的(x,y,t)中的t肯定是比前一个大的,你就可以继续

找刚才那个cnt之后的点来继续更新每个点的最短路，详解看代码吧。。

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<cstring> 
#include<algorithm>
#include<fstream>
#include<cmath>
using namespace std;
const int N=209,oo=0x3fffffff;//一开始把oo定义的0x7fffffff完美地超了。。 
int n,m,q,dis[N][N],t[N],cnt(0);//cnt就是你的第cnt个点 
void init(){
    for(int i=0;i<n;i++)
    for(int j=0;j<n;j++){
        if(i==j) continue;
        dis[i][j]=oo;
    }
    //初始化，dis[i][i]为0; 
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)
    scanf("%d",&t[i]);
    init();
    for(int i=1,a,b,c;i<=m;i++){
        scanf("%d%d%d",&a,&b,&c);
        dis[a][b]=dis[b][a]=c;
    }
    scanf("%d",&q);
    for(int cnm=1,x,y,z;cnm<=q;cnm++){
        //↑一开始把这个设置的i,结果下面也是i,后果。。 
        scanf("%d%d%d",&x,&y,&z);
        while(t[cnt]<=z && cnt<n){
            //因为题目自带升序，那就从0开始慢慢往后找，慢慢更新
            //不过注意下这个cnt要特判<n，因为我没有对t数组初始化，
            //所以当cnt>=n的时候 t[cnt]必定是0<=z，所以就无脑循环了 
            for(int i=0;i<n;i++)
            for(int j=0;j<n;j++){
                dis[i][j]=min(dis[i][j],dis[i][cnt]+dis[cnt][j]); 
            }
            cnt++;//继续往后面找点 
        }
        if(dis[x][y]==oo || t[x]>z || t[y]>z){
            printf("-1\n");
            continue;
        }
        printf("%d\n",dis[x][y]);
    }
    return 0;
}
```

---

## 作者：凌幽 (赞：8)

这道题可以用Floyd解决

首先,联想Floyd

```cpp
for(int k=1;k<=n;++k)
    for(int i=1;i<=n;++i)
        for(R int j=1;j<=n;++j)
            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
```
我们用k这个结点,对(i,j)进行松弛操作,更新最短路

那么看这道题,我们可以根据每个村庄重建的时间作为上面的k来更新最短路

假如当前村庄没有重建,那么一定是-1

否则判断是否联通

AC代码

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define R register
#define N 505
#define inf 707406378
inline void in(int &x) {
    static int ch; static bool flag;
    for(flag = false,ch = getchar();ch < '0'||ch > '9';ch = getchar()) flag |= ch == '-';
    for(x = 0;isdigit(ch);ch = getchar()) x = (x<<1) + (x<<3) + ch - '0';
    x = flag ? -x : x;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int n,m,p; 
int Ti[N];
int dis[N][N];
inline void up(int k){
    for(R int i=0;i<n;++i)
        for(R int j=0;j<n;++j)
            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
}
inline int dy(){
    in(n),in(m);
    for(R int i=0;i<n;++i)in(Ti[i]);
    for(R int i=0;i<n;++i){
        for(R int j=0;j<n;++j)dis[i][j]=inf;
        dis[i][i]=0;
    }
    for(R int i=1;i<=m;++i){
        R int a,b,c;in(a),in(b),in(c);
        dis[a][b]=dis[b][a]=c;
    }
    in(m);
    while(m--){
        R int x,y,t;in(x),in(y),in(t);
        while(Ti[p]<=t && p<n)up(p),p++;
        if(Ti[x]>t || Ti[y]>t || dis[x][y]>=inf)write(-1);
        else write(dis[x][y]);
        putchar('\n');
    }
    exit(0);
}
int QAQ = dy();
int main(){;}
```

---

## 作者：bobxie (赞：4)

刚看完题目，一点思路都没有，一脸懵逼。然后默默点开了题解去，看完了才知道，原来题目里面还有这么多条件已经提供给我们了。。。。         
#### 划重点ing                
- 图论题。。。。
- 数据范围：点数不多于200（**公认的Floyd暗示符**）    
- 村庄的重建时间是从左到右不递增的。。。。
- 要我们求的东西也是按时间顺序给出的。。。。       
- 村庄标号从0开始

OK,now,here is the solution--Floyd obviously.          
考虑Floyd，首先我们都知道Floyd是按照动态规划的思想来实现的，在最外层的k循环是状态转移的阶段，每次k循环里面就处理了标号不超过k-1的点之间的最短路，这刚好是符合题目的要求的，因为村庄的重建时间是从左到右不递增的（~~其实我觉得，就算不符合，也可以排个序，就是想Floyd有点难~~）。 

在这个条件的基础上还有（询问也是按时间顺序给出的）。因此，我们在读入每个询问的时候把k向右走到满足time[k]<=now_time&&k<n的最右端，并且在移动是对最短路进行更新，最后看一下最短路是不是inf就好咯

### 记得把inf设的大一点（不要爆int，或者加的时候爆int），否则就会像我一样“稻花香里说丰年，听取WA声一片”
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define inf 0x3fffffff//看了某些dalao的写法后才知道
using namespace std;
const int maxn=205;
int f[maxn][maxn],n,m,k,q;
int tim[maxn];
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<n;++i){
		for (int j=0;j<n;++j){
			f[i][j]=0x3fffffff;
		}
		f[i][i]=0;
	}
	for (int i=0;i<n;++i) scanf("%d",&tim[i]);
	for (int i=1;i<=m;++i)
	{
		int u,v,val;
		scanf("%d%d%d",&u,&v,&val);
		f[u][v]=f[v][u]=min(f[u][v],val);
	}
	scanf("%d",&q);
	for (int w=1;w<=q;++w)
	{
		int u,v,t;
		scanf("%d%d%d",&u,&v,&t);
		while (tim[k]<=t&&k<n)//重点部分，端点右移，Floyd更新最短路
		{
			for (int i=0;i<n;++i)
			{
				for (int j=0;j<n;++j)
				{
					f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
				}
			}
			++k;
		}
		if (f[u][v]>=inf||tim[u]>t||tim[v]>t) printf("-1\n");
		else 
		printf("%d\n",f[u][v]);
	}
	return 0;
}
```
### 无耻宣扬博客[bobxie](https://www.luogu.org/blog/UnacceptedBlog/)

---

## 作者：AKB48 (赞：4)

题目大意：有一些村庄与它们之间的通路（即是图中的顶点和边），每条通路都有一个修复时间，要求何时所有村庄都可以连通。

其实就是一个无向带权图，要求最小瓶颈生成树（这棵树的边的最大值为这棵树的值）。可以用prim算法与kruskal算法。也可以用dijkstra算法。

为什么可以用dijkstra算法？首先，所有边权值非负。然后可以发现，当两个村庄相通时，它们的最短路（指的是瓶颈最短路）即为它们相通的最短时间，因为它们相通的条件是存在某几条修好的公路将它们连接，于是时间就取决于这几条公路中最迟建好的那条，于是把时间看成权，任意取一个顶点，使用DJ算法，求得他到其他所有公路的最短瓶颈路（最短时间内两村庄通车），因为是无向图，所以A到B的最短路即为B到A的最短路。于是源与其他所有顶点最短路的最大值即为所求。


---

## 作者：George1123 (赞：3)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1119 【灾后重建】传送门](https://www.luogu.org/problem/P1119)

### 此题算法:Floyd

快捷方便思路简单

1.输入节点修复时间并将其与节点本身变化包装成结构体$node$

```cpp
struct node{
	int t,D;
}p[N];

for(int i=0;i<n;i++){
	scanf("%d",&p[i].t);
	p[i].D=i;
}

sort(p,p+n,cmn);
```
以便之后按时间排序并顺序修复

2.对于每个询问(询问已经按时间排序

先用它的时间$t$更新$p$数组时间指针$tp$

将该修好的点$T$的$M$数组值置为$true$

并用别的点来对与$T$相连的边作松弛操作

最后用$T$来对别的边作松弛操作 

### 以下是代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=210;
const int Q=50010;
const int T=1000010;
struct query{
	int l,r,t,D;
}q[Q];
struct node{
	int t,D;
}p[N];
int n,m,qu,a,b,c;
int ans[Q],e[N][N];
bool M[N];
bool cmp(query x,query y){
	if(x.t!=y.t)
		return x.t<y.t;
	if(x.l!=y.l)
		return x.l<y.l;
	return x.r<y.r;
} //为了让询问有序到满足自己的强迫症
bool cmn(node x,node y){
	return x.t<y.t;
} int main(){
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++){
		scanf("%d",&p[i].t);
		p[i].D=i;
	} for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			e[i][j]=INT_MAX;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&a,&b,&c);
		e[a][b]=e[b][a]=c;
	} scanf("%d",&qu);
	for(int i=1;i<=qu;i++){
		scanf("%d%d%d",
		&q[i].l,&q[i].r,
		&q[i].t);
		q[i].D=i;
	} sort(p,p+n,cmn);
	sort(q+1,q+qu+1,cmp);
	int tp=0;
	for(int i=1;i<=qu;i++){
		while(tp<n&&p
		[tp].t<=q[i].t){
			int J,K,T=p[tp].D;
			M[T]=1;
			for(int j=0;j<tp;j++){
				J=p[j].D;
				for(int k=0;k<tp;k++){
					K=p[k].D;
					if(e[J][K]==INT_MAX
					||e[J][T]==INT_MAX)
						continue;
					e[T][K]=e[K][T]=min(e[K][T],
					e[J][K]+e[J][T]);
				}
			} for(int j=0;j<tp;j++){
				J=p[j].D;
				for(int k=0;k<tp;k++){
					K=p[k].D;
					if(e[J][T]==INT_MAX
					||e[T][K]==INT_MAX)
						continue;
					e[J][K]=min(e[J][K],
					e[J][T]+e[T][K]);
				}
			} tp++;
		} if(!M[q[i].l]||!M[q[i].r]
		||e[q[i].l][q[i].r]==INT_MAX){
			ans[q[i].D]=-1;
		} else ans[q[i].D]=e[q[i].l][q[i].r];
	} for(int i=1;i<=qu;i++){
		printf("%d\n",ans[i]);
	} return 0;
}
```
其实上面对询问的排序是不必要的

谢谢大家 ! !


---

## 作者：henry_y (赞：3)

[推荐博客阅读](https://www.cnblogs.com/henry-1202/p/9362507.html)

# 毒瘤题

## 卡spfa

## 可能dij也卡，没试过

## 然后放floyd过了

但其实spfa很好打，虽然只有60

让我们来分析一下spfa的效率，假设这个出题人极其毒瘤，出网格图

又因为是在线询问，所以对于每次询问都得跑一次spfa

所以效率上界为$O(n*m*Q)$

代入一下最坏情况，$200*19900*50000=199000000000$

嗯，**1.99*(10^11)**，成功炸飞

但是spfa特别好想也特别好打

在松弛的时候多判一下$if(t[u]>T||t[v]>T)continue$就好

其他都是标准spfa操作

题目中给的t是有序的，如果是无序的需要离线处理排序一下

### Code(spfa):

```
#include <cstdio>
#include <cstring>
using namespace std;
#define N 80000
#define inf (1<<30)
int n,m,t[N];
int cnt,head[N];
int d[N],q[N];
bool vis[N];
struct edge{int to,next,v;}e[N<<1];
void ins(int u,int v,int w){
	e[++cnt].to=v;e[cnt].next=head[u];e[cnt].v=w;head[u]=cnt;
	e[++cnt].to=u;e[cnt].next=head[v];e[cnt].v=w;head[v]=cnt;
}
bool spfa(int s,int ttt,int tt){
	for(int i=1;i<=n;i++)d[i]=inf;
	memset(vis,0,sizeof(vis));
	int l=0,r=1;
	d[s]=0;q[0]=s;vis[s]=1;
	while(l<r){
		int u=q[l++];
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(t[u]>tt||t[v]>tt)continue;
			if(d[v]>d[u]+e[i].v){
				d[v]=d[u]+e[i].v;
				if(!vis[v])vis[v]=1,q[r++]=v;
			}
		}
		vis[u]=0;
	}
	if(d[ttt]==inf)return 0;
	return 1;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&t[i]);
	for(int i=1;i<=m;i++){
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		x++;y++;
		ins(x,y,w);
	}
	int Q;
	scanf("%d",&Q);
	while(Q--){
		int x,y,T;
		scanf("%d%d%d",&x,&y,&T);
		if(spfa(x+1,y+1,T))printf("%d\n",d[y+1]);
		else printf("-1\n");
	}
	return 0;
}
```
好了接下来上正解

观察到t和每个询问里面的T是有序的

所以对于每个询问的T我们只要松弛已经修好的村庄就好了

然后如果出发点/终点还没修好那么肯定也没法到，特判一下

注意要建无向边

其实floyd比spfa还好打（雾）

### Code(floyd):

```
#include <cstdio>
#include <cstring>
using namespace std;
#define inf 0x3f3f3f3f
int f[210][210],t[40010],n,m,k;
int min(int x,int y){return x<y?x:y;}
int main(){
	scanf("%d%d",&n,&m);
	memset(f,0x3f,sizeof(f));
	for(int i=0;i<n;i++)
		scanf("%d",&t[i]),f[i][i]=0;
	for(int i=0;i<m;i++){
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		f[x][y]=f[y][x]=w;
	}
	int Q;
	scanf("%d",&Q);
	while(Q--){
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		while(t[k]<=w&&k<=n){
			for(int i=0;i<n;i++)
				for(int j=0;j<n;j++)
					f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
			k++;
		}
		if(f[x][y]==inf||t[x]>w||t[y]>w)printf("-1\n");
		else printf("%d\n",f[x][y]);
	}
	return 0;
}
```

---

## 作者：TsReaper (赞：3)

帮助理解Floyd算法的好题！初学Floyd算法时，相信很多人和我一样，只是把几行代码背下来，并没有了解Floyd算法到底是什么原理。以下介绍Floyd算法的原理：

Floyd算法的本质是动态规划，其转移方程为：f(k,i,j) = min( f(k-1,i,j), f(k-1,i,k)+f(k-1,k,j) )。

f(k,i,j)表示路径除开起点i与终点j，只经过前k个点中的某些点，从i到j的最小值。计算这个值只需要考虑两种情况：最短路经过k，和最短路不经过k（那么就经过前k-1个点中的某些点）。由于k要从k-1转移而来，自然k为最外层的循环。而经过状态压缩（类似于背包问题）后，就变成了我们熟悉的f(i,j) = min( f(i,j), f(i,k)+f(k,j) )了。

本题同理，只是k表示的是最先修好的前k个村庄。不过由于出题人非常良心地帮我们把修理时间和询问时间都排序了，所以就没什么关系了- -用Floyd枚举k时，枚举到下一个询问的时间点就停止。回答询问之后，再继续枚举。


---

## 作者：yummy (赞：3)

一道经典的Floyed题目，让学生了解Floyed的本质，体现Floyed的优势。

而且，很巧的是，我在两个月前刚刚出过一道[类似的题目](https://www.luogu.org/problemnew/show/U62165)!!!

于是我心里十分激动，很快地AC了本题。

---
Floyed的本质是，每次选择一个点，枚举所有点对是否能经过这个点缩短距离。这个算法有个好处就是它可以是动态的。

本题中，你可以从头开始，即所有距离都是inf

每修复一个村庄，就用这个村庄尝试更新所有村庄的距离。

查询O(1),修改O(N^2),本题里有N次修改，Q次查询，时间复杂度O(N^3+Q),轻松AC

```cpp
#include<bits/stdc++.h>
using namespace std;
int dis[205][205],n,m,q;
//dis[i][j]=目前i到j的最短距离
bool vis[205];
//vis[i]表示i号村庄是否被修复
struct node
{
    int id,done;
}a[205];//结构体方便村庄排序
bool operator < (node x,node y)
{
    return x.done<y.done;
}
void upd(int st)
{
    dis[st][st]=0;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            dis[i][j]=min(dis[i][j],dis[i][st]+dis[st][j]);
}//重点，我们如果只对1个点进行更新，那么是N^2的
int main()
{
    cin>>n>>m;
    memset(dis,63,sizeof(dis));
    for(int i=0;i<n;i++)
    //0起下标好猥琐啊
    {
        scanf("%d",&a[i].done);
        a[i].id=i;
    }
    sort(a,a+n);
    a[n].done=0x7fffffff;
    //作为结束标识符
    int x,y,w;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&w);
        dis[x][y]=dis[y][x]=w;
    }
    int ok=0;
    cin>>q;
    for(int i=0;i<q;i++)
    {
        scanf("%d%d%d",&x,&y,&w);
        while(a[ok].done<=w)
        {
            upd(a[ok].id);
            vis[a[ok].id]=1;
            ok++;
        }
        if(dis[x][y]>1e8 || vis[x]==0 || vis[y]==0)
        //这里解释一下，如果起点和终点都被修复，且最短路不为inf，则这条路一定正确，因为这条路一定被所有途中的村庄更新过，不然一定是断开的
            puts("-1");
        else
            printf("%d\n",dis[x][y]);
    }
    return 0;
}
```
---
接下来我们再讲讲我出的那道题。

那道题用的也是Floyed，但是稍微变了个形，由中转点变成了中转边。

即每次添加一条边时，枚举两个点之间的距离能否通过这条边变的更短。
```
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
初始状态先Floyed
    for(int i=1;i<=p;i++)
    {
        cin>>f>>a>>b;
        if(f=='Q')
            if(dis[a][b]<(1<<29))
                printf("%d\n",dis[a][b]);
            else
                printf("inf\n");
        else
        {
            scanf("%d",&c);
            if(c<dis[a][b])
            {
                dis[a][b]=c;
                for(int i=1;i<=n;i++)
                    for(int j=1;j<=n;j++)
                        dis[i][j]=min(dis[i][j],dis[i][a]+dis[a][b]+dis[b][j]);//枚举点对进行更新
            }
        }
    }
```

---

## 作者：聆雨泣 (赞：3)

#Floyd+二分查找
##思路：跑一遍弗洛伊德，用f[k][i][j]表示在利用到k这个点时i，j之间的最短路是多少，然后由于每个点的重建时间是单调的，利用二分查找时间，找出最大时间内跑的最短路即可，最短路就是一遍跑出来的，在每个讯问中先判断每个村庄的时间是否小于重建时间，符合条件的才根据最短路判断。
###核心构造：
```
for(int k=0;k<n;k++)
  for(int i=0;i<n;i++)
    for(int j=0;j<n;j++){
    	if(f[k][i][j]>f[k][i][k]+f[k][k][j])
    	  f[k][i][j]=f[k][i][k]+f[k][k][j];
    	f[k+1][i][j]=f[k][i][j];
}
```
f[k][i][j]意义如上，每次暴力更新最短路，用k来表示最新更新的时间即可（因为t数组是单调的）
##解释一下二分：
```
inline int find(int x){
int l=0,r=n+1,ans,mid;
while(l+1<r){
mid=(l+r)/2;
if(t[mid]<=x) ans=l=mid;
else r=mid;
}
return ans+1;
}
```
这个二分代码查找的是t数组中大于等于时间x的下标最小的值，即满足t[ans]<=x,找到的ans最小，但它有个漏洞，在下面会提到
##完整代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int inf=1000000010;
const int maxn=205;
const int maxm=maxn*(maxn-1)/2;
int n,m,t[maxn],Q,f[maxn][maxn][maxn];
int x,y,z;
inline int find(int x){
int l=0,r=n+1,ans,mid;
while(l+1<r){
mid=(l+r)/2;
if(t[mid]<=x) ans=l=mid;
else r=mid;
}
return ans+1;
}
int main(){
scanf("%d%d",&n,&m);
for(int i=0;i<n;i++)
  for(int j=0;j<n;j++){
  	if(i==j) continue;
  	f[0][i][j]=inf;
  }
for(int i=0;i<n;i++) scanf("%d",&t[i]);
for(int i=0;i<m;i++){
scanf("%d%d%d",&x,&y,&z);
f[0][x][y]=f[0][y][x]=z;
}
for(int k=0;k<n;k++)
  for(int i=0;i<n;i++)
    for(int j=0;j<n;j++){
    	if(f[k][i][j]>f[k][i][k]+f[k][k][j])
    	  f[k][i][j]=f[k][i][k]+f[k][k][j];
    	f[k+1][i][j]=f[k][i][j];
}
scanf("%d",&Q);
while(Q--){
scanf("%d%d%d",&x,&y,&z);
if(t[x]>z||t[y]>z) printf("-1\n");
else {
int tt=find(z);
if(tt>n-1) tt=n-1;//漏洞1，若最后找到的下标超出范围，就设为范围的最大值n-1
while(t[tt]>z&&tt) --tt;//漏洞2，在这里调整，调整到满足二分的目的：即满足t[tt]<=z且找到的tt最小
if(f[tt][x][y]==inf) printf("-1\n");
else printf("%d\n",f[tt][x][y]);
}
}
return 0;
}
//有点慢，但是不用开o2就能过，还算可以吧（主要是常数有点大）
```
不足之处，还望提出。


---

## 作者：于丰林 (赞：2)

题目大意：题目信息量太大，请自行浏览：https://www.luogu.org/problemnew/show/P1119

多组询问，数据范围小，还是floyd。。。

不过这一次还出现了有一些不能走的点，不能走也就罢了，过两天居然又能走了？！

这都是些啥啊。。。

好了，不扯别的，还是看题：

注意题目中的条件限制！这是莫大的提示！

第二行包含N个非负整数t0,t1,…,tN−1，表示了每个村庄重建完成的时间，数据保证了t0≤t1≤…≤tN−1

接下来Q行，每行3个非负整数x,y,t，询问在第t天，从村庄x到村庄y的最短路径长度为多少，数据保证了t是不下降的。

根据这个，我们取消了可持久化（炸空间）的可能！也就是说，我们可以边操作边输出！我们考虑一下枚举天数：

首先，对于不能到达的情况，我们判断给出的两个点是否有到目前没有修好的就行

那么对于最短距离呢？

还是继续挖掘floyd的价值，我们枚举的k代表中间接口，如果我们不把不能走的点作为k，那么在目前这一天就对于其他能走的点没有影响

你可能会说：不对啊，那他的最短路被更新了啊

但是，能不能到达已经判断完毕，那么我们只要保证它不影响别人就行了

时间复杂度：O(n^3)

最后，附上本题代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<iostream>
using namespace std;
//Debug Yufenglin
#define dej printf("Running\n");
#define dep1(x) cout<<#x<<"="<<x<<endl;
#define dep2(x,y) cout<<#x<<"="<<x<<' '<<#y<<"="<<y<<endl;
#define dep3(x,y,z) cout<<#x<<"="<<x<<' '<<#y<<"="<<y<<' '<<#z<<"="<<z<<endl;

//Standfor Yufenglin
#define LL long long
#define LB long double
#define reg register
#define il inline
#define maxn 200
#define maxm 1005

int n,m,q,k;
int f[maxn+5][maxn+5],t[maxn+5];

int main()
{
    scanf("%d%d",&n,&m);
    memset(f,0x3f,sizeof(f));
    for(int i=0; i<n; i++)
    {
        scanf("%d",&t[i]);
        f[i][i]=0;
    }
    for(int i=1; i<=m; i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        f[x][y]=z,f[y][x]=z;
    }
    scanf("%d",&q);
    for(int i=1; i<=q; i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        while(t[k]<=z&&k<n)
        {
            for(int i=0; i<n; i++)
            {
                for(int j=0; j<n; j++)
                {
                    f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
                }
            }
            k++;
        }
        if(x>=k||y>=k) printf("-1\n");
        else printf("%d\n",f[x][y]);
    }
    return 0;
}
```


---

## 作者：人殇物已非 (赞：2)

（本毒瘤又一次深刻讨论了一下假如我们是死活想不出来正解的蒟蒻，如何在考场上用暴力得到更多的分...）

蛮有意思一道题，思想很经典，卡人的点也很少。就一个难度大概在**普及+/提高**的思维难点，想明白之后就可以秒题了。

大眼睛一看$n<=200$，哦豁，老弟，$Floyd$在微笑着向你招手呢！

但是怎么做呢，由于$Floyd$算法是直接在询问前处理出任意两点之前的最短路，所以很容易让人想歪，想去把每个时刻的当前状态下的整张图的最短路处理出来。

如果这么做，很显然，我们需要一个$dis[i][j][t]$，表示在$t$时刻，$(i,j)$的最短路，如果路没修好，就是$inf$（无穷大），然后维护$t$遍$Floyd$就可以了。但是虽然空间上好像没啥问题，时间上瞬间变成了$n^3*t_n$，而$t_n$虽然没告诉你范围但是也是$>=n$的，这个复杂度炸了。

考虑优化？$n^3$的$Floyd$可以用$n^2*logm$的$dijkstra$代替，那么我们的复杂度就在$O(t_n*n^2*logm)$，而$t$可以离散化变成$n$，那么就可以变成$O(n^3*logm)$了，$n<=200$的话，是$1e8+2e7$多...超过了$1e8$，感觉。。。。

~~（**虽然过不去但是我们水个大半的分还是极好的**）~~

#### 但是
这个离散化不好写，因为在$Q$次询问里，每次的时间也必须跟着$t$进行一个离散化，比如，$t_i=1,4,6,7$，$Q_i=1,3,5,8$（只指每次询问的时间），那么，把$t$离散化之后变成$1,2,3,4$，$Qi$就必须跟着变成$1,1,2,4$才能保证像原来一样严格遵守了只看当前查询的时间之前的那些$t_i$，比如这个3，原来的话是$3>1$，1号修好了，但是$3<4$，2号没修好，那么现在离散化之后就是，$1$表示，1号修好了，没到2，2号没修好。

~~**这个离散化好麻烦啊....**~~ 这个离散化很显然复杂度可以用时间的单调性$O(Q)$处理完。

所以，当我们在考场上对正解绝望时，我们就可以用码力去弥补了。。。

### 来来来我们来说说正解。。。。。
不要离线了，在线多好，我们可以在每次查询的时候，把到当前时间修好的城市都选出来去更新$Floyd$，然后，就可以得到当前答案了。

而由于每次询问的时间单调递增，所以，之前维护的$Floyd$的$dis$数组直接拿来接着用就好了。

**~~正解怎么这么简单。。。~~**

### $code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
inline void update(int k);
int dis[210][210],rep[210];
int n,m,q;
int main(){
    memset(dis,0x3f,sizeof(dis));
    cin>>n>>m;
    for(int i=0;i<=n-1;i++){
        cin>>rep[i];
    }
    for(int i=1,u,v,w;i<=m;i++){
        cin>>u>>v>>w;
        dis[u][v]=w,dis[v][u]=w;
    }
    cin>>q;
    int poi=0;
    while(q--){
        int u,v,t;
        cin>>u>>v>>t;
        while(poi<n && rep[poi]<=t){
            update(poi);
            poi++;
        }
        if(dis[u][v]>=0x3f3f3f3f || rep[u]>t || rep[v]>t){
            printf("-1\n");
        }
        else printf("%d\n",dis[u][v]);
    }
    return 0;
}
inline void update(int k){
    for(int i=0;i<n;i++){
        if(i==k) continue;
        for(int j=0;j<n;j++){
            if(j==i || j==k) continue;
            if(dis[i][j]>dis[i][k]+dis[k][j]){
                dis[i][j]=dis[i][k]+dis[k][j];
            }
        }
    }
}
```

---

## 作者：L_M_ (赞：2)

题意不多说，本质就是floyd

我们将在当前时间重建完成的村庄（本质是点）称作合法的点

1.一开始可以想到一个可行的暴力，对于每次q，扫描一遍合法的点和边，跑floyd
复杂度O（n^3q)（显然过不去qwq）

2.我们考虑到，由于q是递增的，因此每次q都有一些新的点合法，其实只要更新这些新的合法点的边，然后再floyd就行了
复杂度O（n^3+q)

3.第二个算法的复杂度已经很不错了，但是代码的简易程度可以进一步优化。我们考虑到，其实对于合法的点，不需要更新合法的点的边，只用直接跑一边floyd，此时对于要查询的点a,b，如果a,b合法，那么可以直接输出d[a][b]

这是为什么吶？~~（当然是玄学）~~因为在用当前合法的点k在更新最短路时，所有不不合法的点都没有被用于更新最短路，因此除非a,b不合法，不然d[a][b]中，a->b的路径上的所有点，都不包括不合法的点（因为它们都没有被用于做中转点）

以下是臃肿的代码（~~蒟蒻不会写读入优化）~~


```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int inf=0x3f3f3f3f;
int n,m,q,k=0,d[201][201],t[201];//t代表每个点重建完成的时间
void floyd(int k)
{
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			if(d[i][k]!=inf&&d[k][j]!=inf)
			d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
		}
}
int main()
{
	memset(d,0x3f,sizeof(d));
	memset(t,0x3f,sizeof(t));//t要初始化为极大，不然在下面的while中会出问题
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++)	{ d[i][i]=0; scanf("%d", &t[i]); } 
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		d[u][v]=d[v][u]=w;
	}
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		int from,to,time;
		scanf("%d%d%d",&from,&to,&time);
		while(t[k]<=time)
		{
			floyd(k);
			k++; 
		}
		if(d[from][to]==0x3f3f3f3f||t[from]>time||t[to]>time) printf("-1\n");//判断起点与终点是否合法，以及是否可达
		else printf("%d\n",d[from][to]);
	}
}
		
		 

						
						 
```
		
		 

						
						 





---

## 作者：Roviky (赞：2)

## 本题需要较深刻的理解Floyd算法的具体过程

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/phb46fql.png)

可以发现，随着新的村庄被修好，新点到其他点的最短路未被求出，原来图中点与点之间的最短路也可能发生变化。

~~刚开始我认为无法更新，好难~~

但我们不难发现，每个新加入的点(以及它所连的边)只会影响新图中最短路会经过它的点的最短路。

（**即：当u->v的最短路会受x(新加入的点)影响时，u->v的最短路必然经过x**）

而Floyd算法正好就是根据“**i->j的最短路会经过k**"来更新答案的。

常规的Floyd代码如下:
```cpp
int mp[N][N];
void floyd(int n){
    for(int k=1;k<=n;++k){
        for(int i=1;i<=n;++i){
            for(int j=1;j<=n;++j){
                mp[i][j]=min(mp[i][j],mp[i][k] + mp[k][j]);
            }
        }
    }
}
```
所以，当一个新修好的村庄x加入图中时，我们无需O($n^3$)的Floyd更新最短路，只需要O($n^2$)的去更新x会影响到的u->v的最短路。
![更新最短路 ](https://cdn.luogu.com.cn/upload/image_hosting/7tl4crop.png)
#### 暴力代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,t[211],mp[211][211];
vector<int> edge[211];
int uu[22222],vv[22222],ww[22222];
int main(){
	memset(mp,0x3f3f3f3f,sizeof mp);
	for(int i=0;i<=202;i++)mp[i][i]=0;
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>t[i];
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		uu[i]=u;vv[i]=v;ww[i]=w;    //标记这条边该从何时加入图
		if(t[u]>t[v])edge[u].push_back(i);
		else edge[v].push_back(i);
	}
	t[n]=99999999;  //大数压轴 qwq
	int q;
	cin>>q;
	int now=-1;
	while(q--){
		int tt,x,y;
		cin>>x>>y>>tt;
		while(tt>=t[now+1]){   //询问时间小于当前图的时间
			now++;
			for(int i=0;i<edge[now].size();i++){
				int j=edge[now][i];
				mp[uu[j]][vv[j]]=mp[vv[j]][uu[j]]=ww[j];
			}
			//O(n^3)暴力更新当前图中最短路
			for(int k=0;k<=now;k++){ 
				for(int i=0;i<=now;i++){
					if(i==k)continue;
					for(int j=0;j<=now;j++){
						if(i==j||k==j)continue;
						mp[i][j]=min(mp[i][j],mp[i][k]+mp[k][j]);
					}
				}
			}
		}
		if(x>now||y>now)cout<<-1<<endl;  //如果该村庄未修好
		else if(mp[x][y]<233333)cout<<mp[x][y]<<endl;
		else cout<<-1<<endl; //如果两点目前未联通
	}
	return 0;
} 
```

**值得一提的是，考虑新加入的点now应从原Floyd的内部到外部来更新（即上述Floyd模板中，先更新j再更新i最后更新k）**
#### AC代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,t[211],mp[211][211];
vector<int> edge[211];
int uu[22222],vv[22222],ww[22222];
int main(){
	memset(mp,0x3f3f3f3f,sizeof mp);
	for(int i=0;i<=202;i++)mp[i][i]=0;
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>t[i];
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		uu[i]=u;vv[i]=v;ww[i]=w;
		if(t[u]>t[v])edge[u].push_back(i);
		else edge[v].push_back(i);  //第i条边应随着u,v中较晚点一起出现 
	}
	t[n]=99999999;  //依然大数压轴 
	int q;
	cin>>q;
	int now=-1;
	while(q--){
		int tt,x,y;
		cin>>x>>y>>tt;
		while(tt>=t[now+1]){
			now++;
			for(int i=0;i<edge[now].size();i++){
				int j=edge[now][i];
				int u=uu[j],v=vv[j],w=ww[j];
				//mp[u][v]=mp[v][u]=w; 
				mp[u][v]=min(mp[u][v],w);   //最好取min 
				mp[v][u]=min(mp[v][u],w);  //可能原来的边要比新加入的小 
			}
			for(int k=0;k<=now;k++){         
				for(int i=0;i<=now;i++){
					if(i==k)continue;
					int j=now;    //若j为now(新加入的点) 
					if(i==j||k==j)continue;
					mp[i][j]=min(mp[i][j],mp[i][k]+mp[k][j]);
				}
			}
			for(int k=0;k<=now;k++){         
				int i=now;  //若i为now(新加入的点) 
				if(i==k)continue;
				for(int j=0;j<=now;j++){
					if(i==j||k==j)continue;
					mp[i][j]=min(mp[i][j],mp[i][k]+mp[k][j]);
				}
			}    
			int k=now;    //若k为now(新加入的点) 
			for(int i=0;i<=now;i++){
				if(i==k)continue;
				for(int j=0;j<=now;j++){
					if(i==j||k==j)continue;
					mp[i][j]=min(mp[i][j],mp[i][k]+mp[k][j]);
				}
			}
		}
		if(x>now||y>now)cout<<-1<<endl;
		else if(mp[x][y]<0x3f3f3f3f)cout<<mp[x][y]<<endl;
		else cout<<-1<<endl;
	}
	return 0;
} 
```


---

## 作者：Y_B_Y (赞：1)

好像没有$O(Q\times N)$的写法,个人感觉这种写法还是非常简单的 ~~(学过Floyd就会)~~

如果你不会floyd,请看[这里](https://www.cnblogs.com/wangyuliang/p/9216365.html)

首先我们设$dis[i][j]$为i村庄到j村庄的距离,初始化为$inf(inf=0x3f3f3f3f$)输入时直接双向存,输出时再判断是否两下标所指村庄是否修好

首先我们可以想到$O(Q\times N^2)$的解法,就是每输入两个村庄x,y和一个时间t,看看在t时间有没有新的村庄修好了,如果有就**加入**(操作1),直到所有该加入的都加入,**再跑一次Floyd**(操作2)(这里不是普通的Floyd,这里的循环时要忽略没修好的村庄),然后输出$dis[x][y]$(当然如果x和y中有到t时刻没修好的输出-1,或者是dis[x][y]=inf,也输出-1)

我们观察前面的操作(1)和(2),我们发现并不需要跑一次完全的Floyd,假设我们加入的为村庄now,那么Floyd再枚举$i,j,k$时有时候$i,j,k$都不是now,那么这些操作一定是无意义的,因为他们没有使用最新更新的now的数据,用的是旧数据,旧数据肯定在过去已经被用来更新dis指过了,所以这里是重复操作可以省去.于是我们可以使$i,j,k$分别为now,来进行三次$O(N^2)$的Floyd,当然是在每次加入时进行,而不是在加入后进行

代码如下,由于最多只会加入N个村庄,$O(N^3)$

```cpp
fixed[now]=1;//加入
for(int i=1;i<=n;i++)//作为k
for(int j=1;j<=n;j++)
{
   if(fixed[i]&&fixed[j]) dis[i][j]=min(dis[i][j],dis[i][now]+dis[now][j]);
}
for(int k=1;k<=n;k++)//作为i
for(int j=1;j<=n;j++)
{
   if(fixed[k]&&fixed[j]) dis[now][j]=min(dis[now][j],dis[now][k]+dis[k][j]);
}
for(int k=1;k<=n;k++)//作为j
for(int j=1;j<=n;j++)
{
   if(fixed[k]&&fixed[j]) dis[j][now]=min(dis[j][now],dis[j][k]+dis[k][now]);
}
```

开开心心跑个样例,轻松...................?,最后一个点怎么输出成5了.我们再次观察发现我们虽然更新了新加入的now,但忽略了要查询的x和y,因为我们要查询的是他们的距离,所以只要将x,y分别作为i,j和j,i(因为k是为了更新别的点的)来跑一次$O(N)$的Floyd(枚举k)

代码,$O(Q \times N)$

```cpp
if(!fixed[x]||!fixed[y]||dis[x][y]>=10000000) printf("-1\n");//如果x和y中有到t时刻没修好的输出-1,或者是dis[x][y]=inf,也输出-1
else
{
   for(int k=1;k<=n;k++)//跑Floyd
   {
      if(fixed[k]) dis[x][y]=min(dis[x][y],min(dis[x][k]+dis[k][y],dis[k][x]+dis[y][k]));
   }
   printf("%d\n",dis[x][y]);
}
```

完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
int n,m,dis[201][201],fix[203];//dis为距离,fix记录村庄被修好的时间
bool f[203];//记录村庄是否修好
inline int read()
{
    char c=getchar();int sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
int main()
{
	memset(dis,0x3f,sizeof(dis));//初始化为dis[][]为inf
	n=read();m=read();
	for(int i=1;i<=n;i++)  fix[i]=read();
	for(int i=1;i<=m;i++)
	{
		int x=read()+1,y=read()+1,w=read();//我这里使用1-n记录村庄,所以要全加一
		dis[x][y]=w;dis[y][x]=w;//双向
	}
	fix[n+1]=inf;//因为下面while需要
	int Q=read();
	int now=0;//now为已经加入了第几个村庄
	while(Q--)
	{
		int x=read()+1,y=read()+1,t=read();
		while(fix[now+1]<=t)//如果下一个可以加入就加入,前面fix[n+1]=inf就是为了这里防止n+1号加入
		{
			now++;
			f[now]=1;//已修好
                        /*N^2Floyd*/
			for(int i=1;i<=n;i++)  for(int j=1;j<=n;j++)  if(f[i]&&f[j]) dis[i][j]=min(dis[i][j],dis[i][now]+dis[now][j]);
			for(int k=1;k<=n;k++)  for(int j=1;j<=n;j++)  if(f[k]&&f[j]) dis[now][j]=min(dis[now][j],dis[now][k]+dis[k][j]);
			for(int k=1;k<=n;k++)  for(int j=1;j<=n;j++)  if(f[k]&&f[j]) dis[j][now]=min(dis[j][now],dis[j][k]+dis[k][now]);
		}
		if(!f[x]||!f[y]||dis[x][y]>=10000000) printf("-1\n");//如果x和y中有到t时刻没修好的输出-1,或者是dis[x][y]=inf,也输出-1
		else
		{
			for(int k=1;k<=n;k++)  if(f[k]) dis[x][y]=min(dis[x][y],min(dis[x][k]+dis[k][y],dis[k][x]+dis[y][k]));//Floyd
			printf("%d\n",dis[x][y]);//输出
		}
	}
	return 0;
}
```


---

## 作者：紫薯布丁 (赞：1)

## 我 永 远 喜 欢 floyd

Tle无数的蒟蒻，对这种思想理解后默默回来写题解


### 60分做法：二分查找+堆优化dijkstra

我在刚拿到这个题目的时候，~~直接跳过看数据范围~~，先用邻接表存图，然后根据时间判断二分查找确认某条路的连通性，然后开始疯狂跑dijkstra


后来我加了手写的臭氧优化，跑了spfa，dijkstra，甚至堆优化的spfa，然后发现无论我咋改他都是这些分

这是60分的最终代码


```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define  SIZE 20050
using namespace std;
inline int read(){
    int x=0,f=1;char 
    c=getchar();
    for(;!isdigit(c);c=getchar())if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    return x*f;
}
int head[SIZE*4],dis[SIZE*4];
bool b[SIZE];
struct oo{
    int next,to,v;
}e[SIZE*4];
int x1[SIZE*4],y1[SIZE*4],z1[SIZE*4],tt,l,r;
int n,m,sum,cnt=0;
void add(int x,int y,int z){
    e[++cnt].to=y;
    e[cnt].v=z;
    e[cnt].next=head[x];
    head[x]=cnt;
}
int cun[260];
void disa(int s){
    priority_queue<pair<int,int> >q;
    memset(dis,0x3f3f3f3f,sizeof(dis));
    memset(b,0,sizeof(b));
    dis[s]=0;
    q.push(make_pair(0,s));
    while(!q.empty()){
        int u=q.top().second;
        q.pop();
        if(b[u]) continue;
        b[u]=1;
        for(int i=head[u];i;i=e[i].next){
        	
			
            int y=e[i].to,z=e[i].v;
            if(dis[y]>dis[u]+z&&cun[u]<=tt) {
                dis[y]=dis[u]+z;
                q.push(make_pair(-dis[y],y));
            
        }
    }
    }
    
}
void clean(){
     
     memset(e,0,sizeof(e));
     memset(head,0,sizeof(head));
     cnt=0;
}
int main(){
    n=read();m=read();
    for(int i=0;i<n;i++)
    cun[i]=read();
    for(register int i=1;i<=m;i++){
        x1[i]=read();y1[i]=read();z1[i]=read();
    	add(x1[i],y1[i],z1[i]);
    	add(y1[i],x1[i],z1[i]);
    }
    int q=read();
    for(register int j=1;j<=q;j++){
        int x=read(),y=read(),t=read();tt=t;
        if(t<cun[x]||t<cun[y]) {
            
        printf("-1\n");continue;
         }
          l=0,r=n;
         while(r>l){
           int mid=l+r>>1;
         	if(t>=cun[mid]){
         		l=mid+1;
             }
         	else r=mid;
         }
         disa(x);
    printf("%d\n",dis[y]==0x3f3f3f3f?-1:dis[y]);
      }
    
}
```




于是几个月后终于养成了看数据范围的好习惯，Q<=50000

我跑了50000遍nlogn的最短路。
GG

我们开始思考正解


### 100分做法，floyd

用邻接矩阵存图，初始化f[i][j]=inf；

根据时间长短枚举依次重建的村庄k，根据弗洛伊德的思想

f[i][j]=min(f[i][k]+f[k][j])

对于已经重建的村庄，我们没有必要再次枚举，因此我们开一个bool数组记录一下重建的村庄缩短时间。

注意，如果询问的两个村庄之中有至少一个尚未重建的，此时也是无解的

依次输出每次更新后询问的最短路径即可

 ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

#define ss 303
using namespace std;

inline int read(){
	int x(0),f(1);char c(getchar());
	for(;!isdigit(c);c=getchar()) c=='-'?f=-1:1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	return x*f;
}

int f[ss][ss],n,m,tim[ss];
bool b[ss];

inline void adaa(int k){
	if(b[k]) return ;b[k]=1;
	for(int i=0;i<n;i++)
	 for(int j=0;j<n;j++)
	  f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
}
main(){
     n=read();m=read();
     for(register int i=0;i<n;i++) tim[i]=read();
     memset(f,0x3f,sizeof(f));
     for(register int i=1;i<=m;i++){
     	int x(read()),y(read()),z(read());
     	f[x][y]=f[y][x]=z;
	 }
     int Q(read());
     while(Q--){
     	int x(read()),y(read()),ti(read());
     	int k;
     	for(k=n-1;k>=0;k--) if(tim[k]<=ti) break;
     	for(register int i=0;i<=k;i++) adaa(i);
     	if(f[x][y]==1061109567||x>k||y>k){
     		printf("-1\n");continue;
		 }
		 printf("%d\n",f[x][y]);
	
	 }
}
```


---

## 作者：dunko (赞：1)

## **题目**
[点这里](https://www.luogu.org/problemnew/show/P1119)
## **思路**
看到了**N≤200**，心中一个声音不断传出——**Floyed**！！！   
说到了Floyed那大家心中应该有一点想法了吧。Floyed的原理是动态规划，它有3重循环，最外面的是枚举中间点。这个中间点是Floyed算法用来更新最短路的重要点！！！说这个有什么用呢？ 别急

在题目中说了查询时**数据保证了t是不下降的**，就是说这一次查询一定是上一次查询的之后几天或就是当天。那上一次时所发生的改变一定不会对这一次查询的答案有错误影响！说到了这里答案就有一点出现了。

我们用一个数组t来保存第i个村庄在ti天时重建完成，并且这个数组中的数的值是不下降的。就是说当我们查询的时间大于等于ti是i这个村庄就已经被修好可以拿来用了，用它更新两点之间的最短路。

因为有t数组单调性，所以我们可以用一个变量不断记录**当前最近修好的村庄的下标**，这个村庄之前的村庄都已经修好了，这样就不要担心了。

说了上面这些就清楚了吧。如果还不清楚，下面给出AC代码（~~没有注释~~）。

## **代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1001],mapp[2001][2001],q,tot;
int main(){
    cin>>n>>m;
    memset(a,127,sizeof(a));
    for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
    if(i!=j) mapp[i][j]=999999999;
    for(int i=1;i<=n;i++) scanf("%d",&a[i-1]);
    for(int i=1;i<=m;i++){
        int x,y,z;scanf("%d%d%d",&x,&y,&z);
        mapp[x][y]=mapp[y][x]=z;
    } cin>>q;
    while(q--){
        int x,y,z;scanf("%d%d%d",&x,&y,&z);
        while(a[tot]<=z){
            for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
            mapp[i][j]=min(mapp[i][j],mapp[i][tot]+mapp[tot][j]);
            tot++;
        }
        if(max(x,y)>tot-1) cout<<-1<<endl;
        else if(mapp[x][y]==999999999) cout<<-1<<endl;
        else cout<<mapp[x][y]<<endl;
    }
    return 0;
}
```

---

## 作者：feilongz (赞：1)

一开始想到许多玄学的思路。

最早的思路——30数据可以不考虑修理，一遍floyd就行。

然后我的思路是，记一下每条边，每次加响应时间的边，跑最短路。

大概可行吧。。不过马力不够，状态表示不出来，而且显然效率不够吧。

还有个更严肃的问题是，并不是边修理的时间，而是点。

最后还是靠理解floyd。

首先N很小，一般来说N小的时候我都随便跑循环。可以想到floyd就算稍微加点循环也不会有问题。

考虑一下floyd的实现，其实就是DP。枚举一个断点k，用k去更新其他最短路，最后得出最优解。这个k就是关键——正常的算法k只是单纯枚举，这次只要稍加考虑就行了。考虑k点的时间是否符合当前要求。

显然时间和要求需要排序，不过出题人和善的都排好了。

于是我枚举每个问题，在问题里枚举k，看k点重建时间是否小于当前问题，是的话就用k去更新其他点。这里要注意任何一个k都只更新一遍，我用一个vis数组记录，这样才能保证效率不会退化为（n^3q），因为只执行一遍floyd，剩下的问题只要用处理好的图即可，可知效率应当是（n^3+q)，这完全可以接受了。

如果不记录，我T了7个点。

不过这个算法就算A了效率还是奇低。。

P.S.：更新的时候不要下意识的把i，j的时间考虑上，完全没关系。输出-1 -1 5 5的可能是这个问题。

最后上代码。

    
    

      



    
       
    
      
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,m;
int map[201][201];
int time[201];
int qa[50001];
int qb[50001];
int qt[50001];
int vis[50001];
struct node
{
    int x,y;
    int val;
}t[201][201];
int num[201];
int min(int a,int b)
{
    if(a<b)
      return a;
    return b;
}
int main()
{
    scanf("%d %d",&n,&m);
    int maxt;
    for(int i=0;i<n;++i)
    {
      scanf("%d",&time[i]);
    }
    memset(map,0x3f,sizeof map);
    for(int i=1;i<=m;++i)
      {
          int a1,a2,a3;
          scanf("%d %d %d",&a1,&a2,&a3);
          map[a1][a2]=a3;
          map[a2][a1]=a3;
      }
    int qn;
    scanf("%d",&qn);
    int tot=0;
    for(int i=1;i<=qn;++i)
    { 
      int a1,a2,a3;
      scanf("%d %d %d",&a1,&a2,&a3);
      if(a3<time[1])
        printf("-1\n");
    else
      {
          qa[++tot]=a1;
          qb[tot]=a2;
          qt[tot]=a3;
      }
   }
  for(int to=1;to<=tot;++to)
  {
    for(int k=0;k<n;++k)
      if(time[k]<=qt[to]&&!vis[k])
      {
          vis[k]=1;
        for(int i=0;i<n;++i)
          for(int j=0;j<n;++j)
            if(i!=j&&i!=k&&j!=k)
            map[i][j]=min(map[i][j],map[i][k]+map[k][j]);
      }
      if(time[qa[to]]<=qt[to]&&time[qb[to]]<=qt[to]&&map[qa[to]][qb[to]]!=1061109567)
         printf("%d\n",map[qa[to]][qb[to]]);
      else
         printf("-1\n");
   }
      //AC by fz.
}

```

---

## 作者：Rapiz (赞：1)

floyd n3+q

对询问的处理比较不好实现。

点的建立时间可以是 1 2 3 3 3 5

这样需要在4号点处理完之后再处理询问。

如果在每次floyd后处理询问就需要考虑同一时间建立的点是否全部考虑完了。

这样带来不少细节。

如果在循环开始时处理就简单多了

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using std::min;
const int MAXV=210,Q=50010;
int n,m,q,dis[MAXV][MAXV],t[MAXV],qu[Q],qv[Q],qt[Q];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&t[i]);
    memset(dis,0x3f,sizeof(dis));
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        dis[u][v]=dis[v][u]=w;
    }
    scanf("%d",&q);
    for(int i=1;i<=q;i++) scanf("%d%d%d",&qu[i],&qv[i],&qt[i]);
    int now=1;
    t[n]=t[n-1]+1;
    for(int k=0;k<n;k++){
        while(now<=q&&qt[now]<t[k]){
            int qans=dis[qu[now]][qv[now]];
            if(t[qu[now]]>=t[k]||t[qv[now]]>=t[k]) qans=-1;
            printf("%d\n",qans==dis[n][n]?-1:qans);
            now++;
        }
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]);
    }
    while(now<=q){
            int qans=dis[qu[now]][qv[now]];
            printf("%d\n",qans==dis[n][n]?-1:qans);
            now++;
        }
}
```

---

## 作者：小黑 (赞：1)

数据规模比较小，所以用矩阵+离线floyd（在线spfa貌似要超时）

floyd算法中枚举的k是中转点，在这道题中就可以按时间顺序把点当作中转点，挨个儿加入图中，并且同时将‘时间恰当的询问’求出来（是指询问的时间<=t[k]的询问）

﹡注意题中所给的数据已经排好了序

```delphi
const
  inf=100010;
var
  e:array[0..200,0..200] of longint;
  t:array[0..200] of longint;
  qs,qt,tq:array[1..50000] of longint;
  n,m,x,y,z,q:longint;
  l,i,j,k:longint;
procedure print(l:longint);
  begin
    if (tq[l]<t[qs[l]]) or (tq[l]<t[qt[l]]) then
      writeln(-1)
    else
      if e[qs[l],qt[l]]=inf then
        writeln(-1)
      else
        writeln(e[qs[l],qt[l]]);
  end;
begin
  read(n,m);
  for i:=0 to n-1 do
    for j:=0 to n-1 do
      e[i,j]:=inf;
  for i:=0 to n-1 do read(t[i]);
  for i:=1 to m do
    begin
      read(x,y,z);
      e[x,y]:=z;
      e[y,x]:=z;
    end;
  for i:=0 to n-1 do e[i,i]:=0;

  read(q);
  for i:=1 to q do read(qs[i],qt[i],tq[i]);
//读入完毕，floyd开始
  l:=1;
  for k:=0 to n-1 do
    begin
      while (tq[l]<t[k]) and (l<=q) do  //询问的时间小于当前时间则输出
        begin
          print(l);
          inc(l);
        end;
      for i:=0 to n-1 do
        for j:=0 to n-1 do
          if e[i,j]>e[i,k]+e[k,j] then
            e[i,j]:=e[i,k]+e[k,j];   //将k点加入图中并更新最短路径
    end;

  while l<=q do
    begin
      print(l);
      inc(l);
    end;
end.
```

---

## 作者：huangwenlong (赞：1)

补充一下，既然出题人都良心的帮你把询问按时间顺序排序了，那就不需要visited数组记录每个点是否已经做过Floyd，只要每次读入的时候把之前的时间没处理过的全部处理一遍就可以了。

另外为什么这题是提高+/省选……

```cpp
#include <iostream>
#include <algorithm>
#include <cstring> 
#define maxn 205
#define maxq 50005
using namespace std;
int n, m, q, t[maxn];
int dist[maxn][maxn];
int main()
{
    ios::sync_with_stdio(false);
    memset(t, 0x3f, sizeof(t));
    memset(dist, 0x3f, sizeof(dist));
    
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> t[i];
    int a, b, c;
    for (int i = 1; i <= m; i++)
    {
        cin >> a >> b >> c;
        dist[a][b] = dist[b][a] = c;
    }
    for (int i = 0; i < n; i++)
        dist[i][i] = 0;
    
    int k = 0; // 意为当前的最短路是仅通过前k-1个点的最短路
    cin >> q;
    for (int i = 1; i <= q; i++)
    {
        cin >> a >> b >> c;
        while (t[k] <= c)
        {
            for (int x = 0; x < n; x++)
                for (int y = 0; y < n; y++)
                   dist[x][y] = min(dist[x][y], dist[x][k] + dist[k][y]);
            k++;
        }
        if (dist[a][b] == 0x3f3f3f3f || t[a] > c || t[b] > c)
            cout << -1 << endl;
        else
            cout << dist[a][b] << endl;
    }
    return 0;
}
```

---

## 作者：盧鋅 (赞：0)

### 我怕是又一个没有用某单元最短路的算法草过去的（功力不够，优化不够），但是我还想写题解。
```cpp
in int read(){
	int x=0;bool y=0;char ch;
	while(!isdigit(ch))if(ch=='-')y=1,ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return y?-x:x;
}
```
##### 快读优化一下。
```cpp
in void Out(int a) {  
    if(a>=10) Out(a/10);
    putchar(a%10+'0');
}
```
##### 快写优化一下。
```cpp
if(!can[x]||!can[y]){printf("-1\n");return;}
```
##### 提前判定优化下。
```
if(u==y){Out(dis[y]);puts("");return;}
```
##### 根据dijstra的性质优化下。
```cpp
while(Time[point]<=t&&point<=n){can[point]=1;point++;}
```
##### 根据题目的性质，线性判定下。
```
#define in inline
#define re register
```
##### 小优化下。

------------
### 很明显还是会TEL！

看大佬的题解，用链式前向星会慢一点，原因是无法排序（这点因为题目的原因优化很大），emmm，功力不够解决不了。

然后假如手写堆的话还会有些常数优化。

最优解的优化，也会有用。


最后放下不开O2，60分的代码。
```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<cstdio> 
#define maxn 220
#define maxm 45678
#define inf 0x3f3f3f3f 
#define in inline
#define re register
#define M(x,y) make_pair(x,y) 
using namespace std;
int dis[maxn],first[maxn],Min[maxn],Time[maxn];
bool vis[maxn],can[maxn];
struct edge{
	int v,w,n;
}e[maxm<<1];
int n,m,p,x,y,num_edge=0,point=0;
in int read(){
	int x=0;bool y=0;char ch;
	while(!isdigit(ch))if(ch=='-')y=1,ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return y?-x:x;
}
in void Out(int a) {  
    if(a>=10) Out(a/10);
    putchar(a%10+'0');
}
 in void add(int u,int v,int w)
 {
 	int k=++num_edge;
	e[k].n=first[u];
	first[u]=k;
	e[k].w=w;
	e[k].v=v;
 }
 in void clear()
 {
// 	for(re int i=0;i<n;i++)dis[i]=inf;
 	memset(vis,0,sizeof(vis));
	memset(dis,0x3f,sizeof(dis)); 
 }
 in void pd(int x,int y,int t)
 {
 	priority_queue<pair <int,int> >q;
 	clear();
 	while(Time[point]<=t&&point<=n){can[point]=1;point++;}
 	if(!can[x]||!can[y]){printf("-1\n");return;}
	dis[x]=0;q.push(M(0,x));
	while(!q.empty())
	{
		int u=q.top().second;q.pop();
		if(u==y){Out(dis[y]);puts("");return;}
		if(vis[u]&&!can[u])continue;vis[u]=1;
		for(re int i=first[u];i;i=e[i].n)
		{
			int v=e[i].v;
			if(dis[v]>dis[u]+e[i].w&&can[v]&&!vis[v])
			{
				dis[v]=dis[u]+e[i].w;
				q.push(M(-dis[v],v));
			}
		}
	}
	if(dis[y]==inf)printf("-1\n");
	else {Out(dis[y]);puts("");}
	return;
 }
 signed main()
 {
 	n=read();m=read();
 	for(re int i=0;i<n;i++)Time[i]=read();
	for(re int i=1;i<=m;i++)
	{
		int x=read(),y=read(),z=read();
		add(x,y,z);add(y,x,z); 
	}
	p=read();
	for(re int i=1;i<=p;i++)
	{
	 	int x=read(),y=read(),z=read();
	 	pd(x,y,z);
	}
	return 0;
 }
```
望大佬指教

---

## 作者：zhaowangji (赞：0)

这道题前前后后做了一周~~虽然不是每天都想~~，但也算是做得最久的一道题了



------------

先是暴力版代码，可以直接看正解

cjsj指重建时间，xw是询问，czjl指村庄距离，dd记录村庄是否重建完毕，ts是当前天数，jl指当前到了第几次询问

```cpp
#include<iostream>
#include<string.h>
using namespace std;
int m,n,q;
int cjsj[207];
int xw[50007][4];
int czjl[207][207];
bool dd[207];
int jl;
int ts;
int main()
{
	cin>>n>>m;
	for(int i=0;i<n;i++)
	cin>>cjsj[i];
	memset(czjl,0x3f,sizeof(czjl));//先初始化为一个很大的值
	for(int i=0;i<m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		czjl[x][y]=z;
		czjl[y][x]=z;
	}
	cin>>q;
	for(int i=0;i<q;i++)
	cin>>xw[i][1]>>xw[i][2]>>xw[i][3];
	while(jl<q)
	{
		memset(dd,false,sizeof(dd));//假设全部没有重建完
		for(int i=0;i<n;i++)
		if(cjsj[i]<=ts)dd[i]=true;//重建好了
		while(xw[jl][3]==ts)//到了这一天
		{
			if(!dd[xw[jl][1]]||!dd[xw[jl][2]])cout<<-1<<endl;//如果起点或终点没有重建好，之间输出-1
			else//否则就跑最短路
			{
				for(int k=0;k<n;k++)
				for(int i=0;i<n;i++)
				for(int j=0;j<n;j++)
				if(dd[i]&&dd[j]&&dd[k])
				czjl[i][j]=min(czjl[i][j],czjl[i][k]+czjl[k][j]);
				if(czjl[xw[jl][1]][xw[jl][2]]==0x3f3f3f3f)cout<<-1<<endl;//距离还是初值，证明无法到达
				else cout<<czjl[xw[jl][1]][xw[jl][2]]<<endl;//否则可以到达
			}
			jl++;//进行下一次询问
		}
		ts++;//下一天
	}
	return 0;    
}
```
朴素算法，可以拿**20**分

没错只有20分

吸氧+关闭同步（就是优化cin/cout的时间）可以拿50分



------------
下面是正解

在此还要谢谢 @生而为人

cjsj指重建时间，xw是询问，czjl指村庄距离，dd记录村庄是否重建完毕，cz是当前到了第几个村庄

每次询问时就判断，当前村庄是否已经重建完毕？如果是，就用它跑一次Floyd（把它作为中转点），且切换到下一个村庄继续判断；如果不是，就跳过最短路部分

这可以满足，这样情况下，每次输出的一定是最优情况

```cpp
#include<iostream>
#include<string.h>
using namespace std;
int m,n,q;
int cjsj[207];
int xw[50007][4];
int czjl[207][207];
int cz;
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    cin>>cjsj[i];
    memset(czjl,0x3f,sizeof(czjl));
    for(int i=0;i<m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        czjl[x][y]=z;
        czjl[y][x]=z;
    }
    cin>>q;
    for(int i=1;i<=q;i++)
    {
    	cin>>xw[i][1]>>xw[i][2]>>xw[i][3];//到这里为止都是一样的
    	while(cjsj[cz]<=xw[i][3]&&cz<n)//记住要<n,不然会卡死
    	{
    		for(int i=0;i<n;i++)
    		for(int j=0;j<n;j++)
    		czjl[i][j]=min(czjl[i][j],czjl[i][cz]+czjl[cz][j]);//最短路部分
    		cz++;//下一个村庄
		}
    	if(cjsj[xw[i][1]]>xw[i][3]||cjsj[xw[i][2]]>xw[i][3])cout<<-1<<endl;
    	else if(czjl[xw[i][1]][xw[i][2]]==0x3f3f3f3f)cout<<-1<<endl;
    	else cout<<czjl[xw[i][1]][xw[i][2]]<<endl;
	} //这部分与上面是一样的
    return 0;    
}
```


---

## 作者：wwwsy (赞：0)

[点我看题目 O(∩_∩)O](https://www.luogu.org/problemnew/show/P1119)

这道题是 Floyd ；

题目中要求了时间的先后顺序，刚好floyd有一个枚举中转点的操作，那么，就先读入所有询问，然后在每一次枚举时处理相应的询问。

核心代码
------------
```
  for(int k=0;k<n;k++){
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
            	if(k==i||k==j||i==j) continue;
                if(rod[i][k]!=-1) f[i][k]=min(f[i][k],rod[i][k]);
                if(rod[k][j]!=-1) f[k][j]=min(f[k][j],rod[k][j]);
                if(rod[i][j]!=-1) f[i][j]=min(f[i][j],rod[i][j]);
                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
            }
        }
        while(qy[it].t<t[k+1]&&it<=Q){
            if(f[qy[it].x][qy[it].y]<f[n][n]&&t[qy[it].x]<=qy[it].t&&t[qy[it].y]<=qy[it].t) printf("%d\n",f[qy[it].x][qy[it].y]);
            else printf("-1\n");
            it++;
        }
    }
    while(it<=Q){
        if(f[qy[it].x][qy[it].y]<f[n][n]) printf("%d\n",f[qy[it].x][qy[it].y]);
        else printf("-1\n");
        it++;
    }
```

在这段代码中，我先进行更新，在枚举第 k 个点时 （表示开通到第 k 个点），更新k点之后、k+1点之前的询问；
最后处理全部开通后的询问

$\color{red}\text{错误思路}$ 我之前将 i 和 j 从 0 枚举到 k ，但这样会导致更新不完全-----------
后来发现就算 i , j 没有开通，也不会有影响，因为 i / j 不会在开通前去更新其他距离。

$\color{red}\text{注意：最后一个数据点 有权值为 0 的边}$



---

## 作者：StephenC (赞：0)

# **最短路算法——Floyd**
# 理解原理
## 一点到另一点的最短距离等于它本身或存在一中继点使得距离更短
# 一些例子
[P1119 灾后重建](https://www.luogu.org/problemnew/show/P1119)
## 将符合条件的点不断更新
```cpp
#include<bits/stdc++.h>
using namespace std;

#define ufreopen freopen("zqf.in", "r", stdin)
#define ufor(i, a, b) for(int i = a; i < b; i++)
#define umemset(a, b) memset(a, b, sizeof(a))

const int N = 2e2 + 50, inf = 1e9;
int n, m, q, now = 0, a, b, c, t[N], G[N][N];

int main() {
//	ufreopen;
	scanf("%d%d", &n, &m);
	ufor(i, 0, n) scanf("%d", &t[i]);
	ufor(i, 0, n) {
		ufor(j, 0, n) G[i][j] = inf;
		G[i][i] = 0;
	}
	ufor(i, 0, m) scanf("%d%d%d", &a, &b, &c), G[a][b] = G[b][a] = c;
	
	scanf("%d", &q);
	while(q--) {
		scanf("%d%d%d", &a, &b, &c);
		while(t[now] <= c && now < n) {
			ufor(i, 0, n) ufor(j, 0, n) if(G[i][j] > G[i][now] + G[now][j])
				G[i][j] = G[j][i] = G[i][now] + G[now][j];
			now++;
		}
		if(t[a] > c || t[b] > c) puts("-1");
		else {
			if(G[a][b] == inf) puts("-1");
			else printf("%d\n", G[a][b]);
		}
	}
	
	return 0;
}
```
# 特殊用法
## 将状态装换为一些特定的值
# 一些例子
[P1346 电车](https://www.luogu.org/problemnew/show/P1346)
## 不需转向为0，转向为1
```cpp
#include<bits/stdc++.h>
using namespace std;

#define ufreopen freopen("zqf.in", "r", stdin)
#define ufor(i, a, b) for(int i = a; i <= b; i++)
#define umemset(a, b) memset(a, b, sizeof(a))

const int N = 1e2 + 50, inf = 1e+8;
int n, a, b, k, g[N][N];

int main() {
//	ufreopen;
    scanf("%d%d%d", &n, &a, &b);
    ufor(i, 1, n) ufor(j, 1, n) g[i][j] = inf, g[i][i] = 0;
    ufor(i, 1, n) {
        scanf("%d", &k);
        ufor(j, 1, k) {
            int rail; scanf("%d", &rail);
            if(j == 1) g[i][rail] = 0;
            else g[i][rail] = 1;
        }
    }
    
    ufor(k, 1, n) ufor(i, 1, n) ufor(j, 1, n)
        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
    if(g[a][b] == inf) puts("-1");
    else printf("%d", g[a][b]);
    
    return 0;	
}
```
[P1135奇怪的电梯](https://www.luogu.org/problemnew/show/P1135)
## 判断可否到达，可到达为1，不可到达为无穷大
```cpp
#include<bits/stdc++.h>
using namespace std;

#define ufreopen freopen("zqf.in", "r", stdin)
#define ufor(i, a, b) for(int i = a; i <= b; i++)
#define umemset(a, b) memset(a, b, sizeof(a))

const int N = 2e2 + 50, inf = 1e+8;
int n, a, b, k, g[N][N];

int main() {
//	ufreopen;
    scanf("%d%d%d", &n, &a, &b);
    ufor(i, 1, n) ufor(j, 1, n) g[i][j] = inf, g[i][i] = 0;
    ufor(i, 1, n) {
        scanf("%d", &k);
        if(i+k <= n) g[i][i+k] = 1;
        if(i-k > 0) g[i][i-k] = 1; 
    }
    ufor(k, 1, n) ufor(i, 1, n) ufor(j, 1, n)
        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
        
    if(g[a][b] == inf) printf("-1");
    else printf("%d", g[a][b]);
    
    return 0;
} 
```


---

## 作者：op_z (赞：0)

```cpp
用floyd 更新最短路径时 可以顺便 特判 
询问给出的时间递增 
则每一次询问
满足条件的村庄才更新
一个思路是从村庄0开始更新 
但是若村庄0不满足条件 最短路径就一直不会更新
虽然交上去也能过 但还是改进一下好
提供一组数据
4 4
100 1 1 1
0 1 6
0 2 6
1 2 6
2 3 6
1
1 3 2
第二种思路是寻找第一个满足条件的村庄 更新
记录下已更新的村庄 一直往后更新
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<set>
#include<string>
using namespace std;
const int INF=0x3f3f3f3f;
typedef pair<int, int> pr;
typedef long long ll;
#define fi first
#define se second
#define me(x) memset(x, -1, sizeof(x))
#define mem(x) memset(x, 0, sizeof(x))
#define N 20000+5
#define NIL -1
int n, m;
int a[505][505], t[505];
int main()
{
    int i, j, k, l;
    int u, v, w;
    int x, y, z;
    while(cin>>n>>m)
    {
        int cnt=0, h=0;
        for(i=0; i<n; i++)
            for(j=0; j<n; j++)
            a[i][j]=INF; //记得初始化
        for(i=0; i<n; i++)
            cin>>t[i];
        for(i=0; i<m; i++)
            cin>>u>>v>>w, a[u][v]=w, a[v][u]=w; //双向
        cin>>m;
        for(l=0; l<m; l++)
        {
            cin>>x>>y>>z;            //z递增 满足条件才更新最短路径
            for(cnt=h; cnt<n; cnt++) //循环 直到出现满足条件的村庄 更新
            {
                if(t[cnt]>z) break;//按顺序当前村庄不满足条件则退出 继续查找下一村庄
                for(i=0; i<n; i++)
                    for(j=0; j<n; j++)
                    if(a[i][j]>a[i][cnt]+a[cnt][j])
                    a[i][j]=a[i][cnt]+a[cnt][j];
            }
            h=cnt++;  //h继续往后更新 cnt==n时 所有村庄更新完毕
            if(a[x][y]!=INF && t[x]<=z && t[y]<=z)
                cout<<a[x][y]<<endl;
            else cout<<-1<<endl;
        }
    }
}

```

---

## 作者：公元某年的猫 (赞：0)

练习Floyed的好题，一开始由于理解的不深，所以出了些小错误。
写篇博客加深一下记忆。

------------
看到题目，首先dijkstra+heap和spfa是不行了，再来就是n特别小，似乎可以跑Floyed，但如果对于q次询问跑Floyed的话，O(qn^3)，绝对会炸，但其实深入思考之后不难发现，我们可以在最后一次询问时间允许走的点上跑一次Floyed就能解决最短路的问题，但还有就是对于不能到达的情况(两端点不符合时间的话特判就可以解决)，这就要求要动态的处理问题，而不是死板的跑上一次Floyed。具体就是我们可以一边跑Floyed，一边对当前询问时间进行处理，即要求过渡点要符合当前时间，因为既然两端点符合，那么过渡点再符合的话就可以成功松弛了，相反如果在当前规定时间内，过渡点不符合，那么就无法到达(因为松弛的缘故，在Floyed中只涉及三点),然后记录下最后过渡点的值，以便下次询问接着跑。

------------
可以说在跑的过程中，我们只是额外关心了一下某个时间(或者是过渡点增加的某一时刻)的两点间最短路的情况，其他正常按照板子来。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int N = 210, M = N*(N-1)/2, INF = 100010;
int n, m, q, x[50010], y[50010], z[50010], t[N], map[N][N];
void init() {
    int i, j;
    for (i = 0; i < 210; i++)
        t[i] = INF;
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            if (i == j) continue;
            map[i][j] = INF;
        }
    }
    return ;
}

int main() {
    scanf("%d%d", &n, &m);
    int i, j, k;
    init();
    for (i = 0; i < n; i++)
        scanf("%d", &t[i]);
    int a, b, c;
    for (i = 1; i <= m; i++) {
        scanf("%d%d%d", &a, &b, &c);
        map[a][b] = min(map[a][b], c);
        map[b][a] = min(map[a][b], c);
    }
    scanf("%d", &q);
    for (i = 1; i <= q; i++)
        scanf("%d%d%d", &x[i], &y[i], &z[i]);
    int p = 0;
    for (i = 1; i <= q; i++) {
        int h, j, k;
        if (t[x[i]] > z[i] || t[y[i]] > z[i]) {
            printf("-1\n");
            continue;
        }
        for (h = p; t[h] <= z[i]; h++) {
            if (t[h+1] > z[i]) p = h+1;
            for (j = 0; t[j] <= z[q]; j++) {
                for (k = 0; t[k] <= z[q]; k++) {
                    if (map[j][k] > map[j][h] + map[h][k]) {
						map[j][k] = map[j][h] + map[h][k];
                    }
                }
            }
        }
        if (map[x[i]][y[i]] == INF) printf("-1\n");
        else printf("%d\n", map[x[i]][y[i]]);
    }
    return 0;
}
```

---

## 作者：御坂御坂 (赞：0)

发一下pas的

这道题很明显就是分时间的**多源最短路径**

一般都采用Floyd算法，，

解释一下代码里的数组

\* e[][]用来存边

\* hash[]表示该村庄在当前时间段是否重建完成

\* vis[] 来表示k有没有被访问过，是用来优化Floyd的时间复杂度的

\* t[]与题面意义相符

函数：

```cpp
const INF=99999999;
var e:array[0..500,0..500] of longint;
    hash,vis:array[0..500] of boolean;
    t:array[0..500] of longint;
    N,M,Q,i,j,nowt,time,x,y,u,v,w:longint;
    Upd:boolean;
procedure Floyd();
var i,j,k:longint;
begin
    for k:=0 to N-1 do
    if (hash[k])and(vis[k]) then //如果k已经重建完成
    begin
        vis[k]:=false; //优化：每个k都只访问一次
        for i:=0 to N-1 do 
            for j:=0 to N-1 do  
                if (e[i][j]>e[i][k]+e[k][j]) then 
                    e[i][j]:=e[i][k]+e[k][j];
    end;                
end;
function Solve(x,y:longint):longint;
begin
    if not(hash[x] and hash[y]) then exit(-1);//如果有一个没重建完 返回-1
    if Upd then begin Floyd();Upd:=false;end;//如果时间更新了，就要重新求一次最短路径。
    if e[x][y]<>INF then exit(e[x][y]) else exit(-1);//如果两点之间不能到达 返回-1 否则返回最短路径
end;
procedure Update(time:longint);
var i:longint;
begin
    if time=nowt then exit;//如果现在时间和要更新的时间一样，就不用更新了
    for i:=0 to N-1 do 
        if time>=t[i] then hash[i]:=true;
    nowt:=time;Upd:=true;//更新时间
end;
begin
    readln(N,M);
    for i:=0 to N-1 do read(t[i]);
    for i:=0 to N-1 do 
        for j:=0 to N-1 do 
            if i=j then e[i][j]:=0
                else e[i][j]:=INF;
    fillchar(hash,sizeof(hash),0);
    fillchar(vis,sizeof(vis),1);
    for i:=1 to M do 
    begin
        readln(u,v,w);
        e[u][v]:=w;e[v][u]:=w;//邻接矩阵
    end;
    readln(Q);Upd:=false;
    nowt:=-1;Update(0);
    for i:=1 to Q do 
    begin
        readln(x,y,time);
        Update(time);//更新时间
        writeln(Solve(x,y));//求最短路径
    end;
end.
* Floyd() 求多源最短路径

* Solve(x,y) 求在当前时间x到y的最短距离

* Update(time) 更新时间

```

---

## 作者：Hank (赞：0)

本蒟蒻什么都不会,只会打暴力,没想到居然过了.....

我们考虑实质上最多做n次floyed 因为只会有n次加点 所以在floyed时枚举时刻

如果该时刻没有新加入点我们就不管,有就重做floyed,注意,因为dis数组是递减的,所有不要清空


```cpp
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <cmath>
#define RG register
#define il inline
using namespace std;
const int N=202,M=50005,LIM=100005;
int n,m,Q,re[N],dis[N][N];
int gi(){
    RG int str=0;RG char ch=getchar();
    while(ch>'9' || ch<'0')ch=getchar();
    while(ch>='0' && ch<='9')str=(str<<1)+(str<<3)+ch-48,ch=getchar();
    return str;
}
struct node{
    int next,x,y,id;
}a[M];
int tot,ans[M],head[M],num=0,id[N];bool d[LIM];
void init(int t,int x,int y,int id){
    a[++num].next=head[t];a[num].x=x;a[num].id=id;a[num].y=y;head[t]=num;
}
void work()
{
    RG int x,y,z;
    n=gi();m=gi();
    for(RG int i=1;i<=n;i++)re[i]=gi(),d[re[i]]=true;
    memset(dis,127/3,sizeof(dis));
    int inf=dis[0][0];
    for(RG int i=1;i<=m;i++){
        x=gi()+1;y=gi()+1;z=gi();
        dis[x][y]=dis[y][x]=z;
    }
    Q=gi();
    int lim=0;
    for(RG int i=1;i<=Q;i++){
        x=gi()+1;y=gi()+1;z=gi();
        if(re[x]>z || re[y]>z){
            ans[i]=-1;
            continue;
        }
        if(z>lim)lim=z;
        init(z,x,y,i);
    }
    for(RG int t=0;t<=lim;t++){
        if(!d[t]){
                    for(RG int i=head[t];i;i=a[i].next){
                x=a[i].x;y=a[i].y;
                if(dis[x][y]==inf)ans[a[i].id]=-1;
                else ans[a[i].id]=dis[x][y];
            }
            continue;
        }
        for(RG int k=1;k<=n;k++){
            if(re[k]>t)continue;
            for(RG int i=1;i<=n;i++){
                if(re[i]>t || i==k)continue;
                for(RG int j=1;j<=n;j++){
                    if(re[j]>t || i==j || j==k)continue;
                    if(dis[i][j]>dis[i][k]+dis[k][j])
                        dis[i][j]=dis[i][k]+dis[k][j];
                }
            }
        }
         for(RG int i=head[t];i;i=a[i].next){
            x=a[i].x;y=a[i].y;
            if(dis[x][y]==inf)ans[a[i].id]=-1;
            else ans[a[i].id]=dis[x][y];
        }
    }
    for(RG int i=1;i<=Q;i++)
        printf("%d\n",ans[i]);
}
int main()
{
    work();
    return 0;
}

```

---

## 作者：Treeloveswater (赞：0)

我来解答一些人的疑惑：

问题：

楼下博一的题解中说：

P.S.：更新的时候不要下意识的把i，j的时间考虑上，完全没关系。输出-1 -1 5 5的可能是这个问题。

有人疑惑：为什么不要考虑i和j的时间呢？城市i和j那时不是还没修好呢吗？

然而实际上不用判，也不能判。

可以这样证明：

我们假设X点在当前还没出现，断点K已经出现。

仔细观察后发现：

X是属于i，j这两层循环的，所以X只会以起点或者终点的身份出现。而这对当前的答案是没有影响的(并且我们也可以通过时间O（1）特判掉X是起点或者终点的询问）。很明显，X对 i 到 j 的最短路有贡献当且仅当 X成为i j中的断点对F[i][j]有过min的取值——即X作为K，做过这个语句 F[i][j]=min(F[i][j],F[i][X]+F[X][j])。而我们知道，当时间轴没有运动到T[X]的时候，X是不会作为断点出现的！所以不用判断，证明完毕。

而如果判断了，就会出现有一些以X为起点或终点的路径最短路没有算出来！具体为什么，画画图就知道了。所以不能判断，证毕。



---


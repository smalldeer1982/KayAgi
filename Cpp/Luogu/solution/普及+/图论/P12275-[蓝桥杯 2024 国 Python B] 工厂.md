# [蓝桥杯 2024 国 Python B] 工厂

## 题目描述

H 市是一座制造业十分发达的城市。在 H 市中，工厂可以生产 $n$ 种不同的物品，部分物品都可以以特定的价格 $a_i$ 在市场上售出而带来收益。生产方式分为两类，使用第一类生产方式每个工人可以在一天时间内生产若干件物品 $y$。使用第二类生产方式，每个工人可以在一天时间内使用若干件物品 $x$ 生产若干件物品 $y$，其中 $x \leq y$，即只能将编号较小的物品加工成编号较大的物品。

小蓝作为 H 市的市长自然希望能够最大化收益，由于 H 市的人口非常多，你只需要帮她计算出平均一天内每个工人能够获得的最大收益即可。

## 说明/提示

### 样例说明

$1$ 个工人可以在一天时间内生产 $6$ 份小麦，或者将 $5$ 份小麦加工成 $10$ 份面粉，或者将 $6$ 份面粉加工成 $10$ 份饼干。

那么最理想的情况是 $5$ 个工人生产小麦，$6$ 个工人将小麦加工成面粉，$10$ 个工人将面粉加工成饼干后在市场上以 $2$ 的价格出售。

此时需要 $21$ 个工人生产，共能获得 $200$ 的收益。平均每个工人一天时间内获得的收益约为 $9.52$。

### 评测用例规模与约定

- 对于 $50\%$ 的评测用例，$1 \leq n, m \leq 300$，$w_i = 1$，$0 \leq k_i \leq 1$；
- 另存在 $20\%$ 的评测用例，$x_i = y_i$；
- 对于所有评测用例，$1 \leq n, m \leq 300000$，$0 \leq a_i \leq 10^6$，$1 \leq w_i \leq 10$，$0 \leq k_i \leq 10$，$1 \leq x_i \leq y_i \leq n$。保证数据中至少存在一个 $k_i = 0$。

## 样例 #1

### 输入

```
3 3
1 0 2
1 1 0 6
1 2 5 10
2 3 6 10```

### 输出

```
9.52```

# 题解

## 作者：LargeRice16pro (赞：2)

拓扑排序做法。

注意到：$x\le y$，若不考虑 $x=y$，则建边 $(x,y,k,w)$ 的图一定是一个 DAG（有向无环图）。

考虑最后售卖的物品，容易发现：最终卖出去的一定只是某**一个**物品，不会卖出多个物品。简单理解就是因为要求性价比最大，那么多个物品的性价比加起来一定不会超过这些物品中性价比最大的那个（糖水不等式）。

且工人的生产决策只与数量相关，与物品价格无关，所以只需要考虑数量和工人数之比。

所以，在 DAG 上 dp 即可：$dp[x]$ 表示只售卖 $x$ 这个物品的最大性价比：$\frac{p}{q}$，实际意义为：$q$ 个工人生产 $p$ 个物品 $x$。

那么转移边 $(x,y,k,w)$ 时，易得：$dp[x]=\dfrac{p}{q},\dfrac{\frac{\text{lcm}(p,k)}{k}\times w}{q\times\frac{\text{lcm}(p,k)}{p}+\frac{\text{lcm}(p,k)}{k}}\rightarrow dp[y]$。

注意：此处分数不能约分，因为分母表示的是工人数量，具有实际意义。因为题目限制了 $k\le 10$，所以此处反复取 $\text{lcm}$ 并不会爆炸。

最后再考虑 $x=y$ 的情况，事实上，因为 $x=y$ 时生成的物品是自己，所以可以先保留 $\dfrac{w}{k}$ 最大的那一组，然后在 dp 过程中，$dp[x]$ 的值更新完后，对自己进行一次 $(x,x,k,w)$ 的转移即可。

因为具体实现中的 $\text{lcm}$ 只和 $k\le 10$ 进行，所以这一步时间复杂度可以近似看成 $O(1)$（或是进行一次辗转相除后，预处理 $10$ 范围内的所有 $\gcd$ 即可）。

DAG 上 dp 采用拓扑排序实现，时间复杂度：$O(n)$。

```python
from collections import deque
from math import *


n, m = map(int, input().split())

a = list(map(int, input().split()))

x = [0 for _ in range(m)]
y = [0 for _ in range(m)]
k = [0 for _ in range(m)]
w = [0 for _ in range(m)]

p = [[] for _ in range(n)]
deg = [0 for _ in range(n)]

def add(x, y, k, w):
    p[x].append([y, k, w])
    deg[y] += 1

dp = [[0,1] for _ in range(n)]

def max(x, y):
    if x[0] * y[1] > y[0] * x[1]:
        return x
    return y

b = [[0, 1] for _ in range(n)]

for i in range(m):
    x[i], y[i], k[i], w[i] = map(int, input().split())
    x[i] -= 1
    y[i] -= 1
    if k[i] == 0:
        dp[y[i]] = max(dp[y[i]], [w[i], 1])
    else: 
        if x[i] == y[i]:
            b[x[i]] = max(b[x[i]], [w[i], k[i]])
        else:
            add(x[i], y[i], k[i], w[i])


q = deque()

for i in range(n):
    if not deg[i]:
        q.append(i)


while q:
    now = q.popleft()
    if b[now][0] and dp[now][0]:
        b[now][0], b[now][1] = b[now][1], b[now][0]

        fz = b[now][1] * lcm(dp[now][0], b[now][0]) // b[now][0]
        fm = dp[now][1] * lcm(dp[now][0], b[now][0]) // dp[now][0]
        fm = fm + lcm(dp[now][0], b[now][0]) // b[now][0]

        dp[now] = max(dp[now], [fz, fm])
    for v in p[now]:
        fz, fm = 0, 1
        if dp[now][0] != 0:
            fz = v[2] * lcm(dp[now][0], v[1]) // v[1]
            fm = dp[now][1] * lcm(dp[now][0], v[1]) // dp[now][0]
            fm = fm + lcm(dp[now][0], v[1]) // v[1]
        dp[v[0]] = max(dp[v[0]], [fz, fm])
        deg[v[0]] -= 1
        if not deg[v[0]]:
            q.append(v[0])

ans = [0, 1]
for i in range(n):
    dp[i][0] *= a[i]
    ans = max(ans, dp[i])

res = ans[0] / ans[1]
print(f"{res:.2f}")
```

---

## 作者：Ag2WO4 (赞：1)

由于产物序号一定高于原料，可以根据产物序号排序分析每种产物最高人均产量，这样保证后面要调取前面最高人均产量时是正确的。

如果产物可以白嫖那么它的人均产量就是 $w_i$，否则考虑消耗单位人产生的所有底物 $w_s$ 需要的（包括生成底物的单位人）总人数 $n_i=\frac{w_s}{k_i}+1$ 以及这些底物带来的产量 $w=w_i\times\frac{w_s}{k_i}$，最终得到单位人产量 $w_p=\frac w{n_i}=\frac{w_i}{\frac{k_i}{w_s}+1}$ 和单位人销售额 $p_i=w_p\times a_i$，取单位人销售额的最大值即可。

注意特判虚空合成（即无法得到底物）的情况，复杂度 $O(m\log m)$，有趣的是可以只用三行代码写完。
```python
a,b=map(int,input().split());a=list(map(int,input().split()));c=[0]*len(a)
for d,e,f,g in sorted([list(map(int,input().split()))for i in range(b)],key=lambda i:i[1]):c[e-1]=max(c[e-1],(g/(f/c[d-1]+1)if c[d-1]else 0)if f else g)
print('%.2f'%max(a[i]*c[i]for i in range(len(a))))
```

---

## 作者：A7F3jK9pR0xf_ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P12275)

注意到 $x\leq y$，那么我们按关系建完图后一定是一个 DAG，所以考虑在 DAG 上 DP 得到答案。

状态定义：设 $f_i$ 表示一个人一天平均生产多少个物品 $i$。不难发现，答案肯定是生产一个固定的物品（性价比最高），所以答案是 $\max_{i=1}^nf_i\cdot a_i$。

转移分两种情况讨论（假定我们从点 $(x,k)$ 转移到 $(y,w)$）：
1. $k=0$：直接生产，显然令 $f_y=w$。
2. $k>0$：生产 $k$ 个 $x$ 需要 $\frac{k}{f_x}$ 个人，算上将 $x$ 生产到 $y$ 的人是 $\frac{k}{f_x}+1$ 个人，那么每人平均生产 $\frac{w}{\frac{k}{f_x}+1}$ 个物品 $i$。

然后在所有情况中打最大值即可，时间复杂度 $O(n)$。

代码很好写，注意到 $x\leq y$，所以我们直接按 $y$ 从小到大排序然后模拟转移即可，根本无需建图。

---


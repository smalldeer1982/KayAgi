# [ICPC 2022/2023 WF] 变成红灯

## 题目描述

Mei 的父母去年一年都在重新设计如何装修房子，但是他们的照明系统十分复杂！房子中每个房间都有一盏 LED 灯，灯可以设成红色，绿色或蓝色，如图 G.1 所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/wjoki4ab.png)

图 G.1. 样例 1 中灯的初始状态。按钮和导线没有画出。

房子里到处都有各种按钮，每个按钮都与一盏或多盏灯相连。按下一个按钮后，与该按钮相连的红灯会变成绿灯，绿灯会变成蓝灯，蓝灯会变成红灯。每个按钮都可以多次按下。由于房屋建造于多路开关布线发明之前，每盏灯最多只由两个按钮控制。

Mei 最喜欢的颜色是红色，所以她想把所有的灯都变成红色。她的父母担心按钮会磨损，要求她尽量减少按下按钮的次数。

## 样例 #1

### 输入

```
8 6
GBRBRRRG
2 1 4
1 2
4 4 5 6 7
3 5 6 7
1 8
1 8
```

### 输出

```
8
```

## 样例 #2

### 输入

```
4 3
RGBR
2 1 2
2 2 3
2 3 4
```

### 输出

```
impossible
```

## 样例 #3

### 输入

```
4 4
GBRG
2 1 2
2 2 3
2 3 4
1 4
```

### 输出

```
6
```

## 样例 #4

### 输入

```
3 3
RGB
1 1
1 2
1 3
```

### 输出

```
3
```

# 题解

## 作者：yingkeqian9217 (赞：1)

注意到每个位置是独立的，考虑覆盖它的所有操作，设第 $i$ 个操作执行了 $a_i$ 次，每个限制形如 $a_i+a_j=k$（可以通过建虚点补全限制）。

考虑建图，对于每个限制连接无向边 $i,j$ 边权为 $k$，显然每个连通块独立，而且每个连通块只要确定了其中一个数其他数就唯一确定，直接枚举其中一个，取最小和即可。

时间复杂度 $O(l+b)$。

```cpp
#include<bits/stdc++.h>
#define maxn 1050005
#define fi first
#define se second
using namespace std;
int n,m,ans,sum,vis[maxn],a[maxn];
char c[maxn];
vector<int>t[maxn],vec;
vector<pair<int,int> >e[maxn];
void dfs1(int x){
	vec.push_back(x);vis[x]=1;
	for(auto i:e[x]) if(!vis[i.fi]) dfs1(i.fi);
}
int dfs2(int x){
	sum+=a[x];
	for(auto i:e[x]){
		int v=i.fi,w=i.se;
		if(a[v]!=-1&&(a[v]+a[x])%3!=w) return 0;
		if(a[v]!=-1) continue;
		a[v]=(w+3-a[x])%3;
		if(!dfs2(v)) return 0;
	}
	return 1;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>c;
	for(int i=1,len,x;i<=m;i++){
		cin>>len;
		while(len--){
			cin>>x;
			t[x].push_back(i);
		}
	}
	for(int i=1;i<=n;i++){
		if(t[i].empty()&&c[i-1]!='R') return puts("impossible"),0;
		if(t[i].empty()) continue;
		int cur=(c[i-1]=='R'?0:(c[i-1]=='B'?1:2));
		if(t[i].size()==1) t[i].push_back(0);
		e[t[i][0]].emplace_back(t[i][1],cur);
		e[t[i][1]].emplace_back(t[i][0],cur);
	}
	for(int i=0;i<=m;i++){
		if(ans>2*m) break;
		if(vis[i]) continue;
		vec.clear(),dfs1(i);
		for(int i:vec) a[i]=-1;
		a[i]=sum=0;
		int minn=3*m;
		for(int j=0;j<3;j++){
			for(int i:vec) a[i]=-1;
			a[i]=j,sum=(dfs2(i)?sum:3*m);
			minn=min(minn,sum),sum=0;
			if(!i) break;
		}
		ans+=minn;
	}
	if(ans>2*m) puts("impossible");
	else cout<<ans<<'\n';
	return 0;
}
```

---


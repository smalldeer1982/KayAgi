# 公路修建

## 题目描述

某国有 $n$ 个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。

修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。

政府审批的规则如下：

1. 如果两个或以上城市申请修建同一条公路，则让它们共同修建；
2. 如果三个或以上的城市申请修建的公路成环。如下图，A 申请修建公路 AB，B 申请修建公路 BC，C 申请修建公路 CA。则政府将否决其中最短的一条公路的修建申请； 
3. 其他情况的申请一律同意。

![](https://cdn.luogu.com.cn/upload/image_hosting/apng39qc.png)

一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。

当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。

你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。

## 说明/提示

修建的公路如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)

## 样例 #1

### 输入

```
4
0 0
1 2
-1 2
0 4```

### 输出

```
6.47```

# 题解

## 作者：MY（一名蒟蒻） (赞：375)

今天CSP刚报好名，刚好$\color{green}AC$ 这题。听说比赛前写题解可以＋rp，于是就有了这篇题解。

[**原题传送门**](https://www.luogu.com.cn/problem/P1265)

[**博客食用~~不知道会不会~~更佳**](https://www.luogu.com.cn/blog/nizhuan/solution-p1265)

---
## 0.审题
题面前面一大堆有的没的，蛋是

`当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。`

一语道破目的：最小生成树。

~~其实你不分析题面的话也不知道。~~

**最小生成树是什么呢，实际上就是给您一个图，要求把图变成一个由n-1（n为点数）条边组成的图，使得总边权最小。**

~~该不会真的有人不知道最小生成树是什么就来做这题吧，不会吧不会吧（大雾~~
## 1.思路
第一反应Kruskal，于是写完一提交直接爆炸。

### $\color{black}TLE+MLE$

[血的教训](https://www.luogu.com.cn/record/list?user=240191&pid=P1265&page=1)

$\color{black}MLE$：存边数组爆炸

$\color{black}TLE$：$O(mlogm)$爆炸

---
于是Prim大法好啊！！！

**Prim算法流程：**
1. 开始将起点（本题随意）标记为蓝点；
2. 找一条连接**蓝点集合中一点**和白点集合中一点最短的边；
3. 将该边连接的白点加入蓝点；
4. 将该新加入的蓝点所有连接的白点最短边更新；
5. 返回第二步，直到n个点都被选入最小生成树为止。

**注：蓝点为已加入最小生成树的点，白点反之。**
## 2.代码实现
相信大家可以发现，这个算法流程跟`Dijkstra`差不多，于是代码实现也很相似。

因为算法流程已经给出，代码注释将不再赘述。

### code:
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>

using namespace std;
int n;
typedef double dou;
dou x[5010],y[5010],dis[5010],book[5010],ans;

dou get_e(dou x1,dou y1,dou x2,dou y2)
{//求两点间距离函数
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

void init()//初始化
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf",&x[i],&y[i]);
		dis[i]=1e12*1.0;//double类很大，炸不了
	}
	return ;
}

void Prim()
{
	dis[1]=0.0;
	book[1]=true;
	int curr;
	double minn;
	for(int i=1;i<=n;i++)
	{
		curr=1;
		minn=1e9*1.0;
		for(int j=1;j<=n;j++)//找最短边
			if(!book[j] && dis[j] < minn)
				minn=dis[j],curr=j;
		book[curr]=true;
		ans+=dis[curr];
		for(int j=1;j<=n;j++)//现用现算
			dis[j]=min(dis[j],get_e(x[curr],y[curr],x[j],y[j]));
	}
	printf("%.2lf",ans);
	return ;
}

int main()
{
//	freopen("work.in","r",stdin);freopen("work.out","w",stdout);
	init();
	Prim();
//	fclose(stdin);fclose(stdout);
	return 0;
}
```

## Thank you for your reading!

~~拒绝白嫖，从我做起。点个赞再走嘛。~~

---

## 作者：EricWay1024 (赞：111)

既然这题本质上就是Prim算法, 我就在这里写一写我对Prim算法的理解.

两个最小生成树算法, 都有一个共同的思想: 这棵树是一点一点长大的; 并且每次生长, 都是贪心的.

不同之处是: Kruscal算法是以边为中心的, 每次找最小的并且有用的边添加到树上;

Prim算法是以点为中心的, 每次找离树最近的点添加到树上.

我们可以把一棵树理解成一个有智能的生命, 可以感知它附近的点到它的距离. 每次生长枝条, 它都选择离它最近的那个点.

点到树的距离, 是指树外一个点到树上的任意点的最小距离.

所以,在代码实现的时候, 需要维护这样一个数组: 树外的点到树的距离. 所以, 还需要区分一下点究竟在树上还在树外.

维护数组就是要做两件事: 更改数组和调用数组.

何时更改: 树外的点到树的距离发生变化. 这种事只能在树生长了新的枝条的时候发生, 因为新加入的那个点可能更新了树到树外的某个点的距离. 同时, 新加入的那个点变成了树上的点.

何时调用: 想扩张的时候, 找最近的树外点.

一开始, 我们认为1号结点在树上, 把它到树的距离设为0; 其它结点的距离是INF.


在调用完整个算法之后, 因为当一个节点变成树上节点后, 我们就不再更新它到树的距离, 所以, 原来的数组记录的就是它加入到树上时的连边长度. 对之求和, 就是树上所有边权之和.

Prim算法的优势: 稠密图, 尤其是完全图. 因为在Kurscal算法中, 必须事先求出所有边的长度才能对之排序. 但是一个有5000节点的完全图, 这样做的空间开销是巨大的. Prim算法只在更新点到树的距离时需要用到边长, 因此对于这种给坐标的完全图, 可以现用现算. 

```cpp
#include<bits/stdc++.h>
#define For(i, m) for(register int i=1; i<=m; i++)
#define INF 0x3f
#define N 5123
#define M
using namespace std;
struct POINT{
	long long x;
	long long y;
	
	long long operator* (const POINT &b) const {
		return (x-b.x)*(x-b.x)+(y-b.y)*(y-b.y);
	}
}city[N];

inline long long read(){
    long long x=0, sign=1; char c=getchar();
    while(c>'9' || c<'0') {if (c=='-') sign=-1;c=getchar();}
    while(c>='0' && c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x*sign;
}
int n, m;
bool v[N]; long long d[N];

void prim(){
	memset(d, INF, sizeof(d));
	memset(v, 0, sizeof(v));
	d[1]=0;
	For(i, n-1){
		int x=0;
		For(j, n){
			if (!v[j] && (x==0 || d[j]<d[x])) x=j;
		}
		v[x]=1;
		For(y, n){
			if (!v[y]) d[y]=min(d[y], city[x]*city[y]);
		}
	}
}
int main(){
#ifdef ERIC
	freopen("city.cpp", "r", stdin);
#endif
	n=read();
	For(i, n){
		city[i].x=read();
		city[i].y=read();
	}
	prim();
	double ans=0;
	For(i, n) ans+=sqrt((double)d[i]);
	printf("%.2f\n", ans);
	return 0;
}


```

---

## 作者：Sci_M3 (赞：58)

首先考虑最小生成树的模型，唯一不同的是第二种情形。

即**“三个或三个以上的城市申请修建的公路成环”**

考虑该情形，因为修路的申请是申请离它最近的城市，所以上述条件实质上为

**“存在三个或三个以上的城市，他们两两间的最近城市连起来成环”**

显然这样的情形是不存在的。

剩下就是简单的最小生成树问题。

本题另外一个问题在于空间的限制上， 5000 \* 5000的空间大小会MLE

那么我们发现题目给的是坐标，所以我们想到可以不直接存储距离，而是在Prim的运行流程中把距离即时计算出来即可。


···cpp






```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
const int MAXN = 5000 + 10;
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}
struct node { int x, y; }point[MAXN];
double ans, dis[MAXN];
bool vis[MAXN];
int n;
double calc(int a, int b) {
    return sqrt((double)(point[a].x - point[b].x) * (point[a].x - point[b].x) + (double)(point[a].y - point[b].y) * (point[a].y - point[b].y));
}
int main() {
    n = read();
    for(int i = 1; i <= n; ++i) {
        point[i].x = read(), point[i].y = read();
        dis[i] = 1e8;
    }
    int pos; dis[1] = 0;
    for(int i = 1; i <= n; ++i) {
        double minn = 1e8;
        for(int j = 1; j <= n; ++j) if(!vis[j] && dis[j] < minn) {
            minn = dis[j]; pos = j;
        }
        ans += minn; vis[pos] = true;
        for(int j = 1; j <= n; ++j) {
            double d = calc(pos, j);
            if(d < dis[j])  dis[j] = d;
        }
    }
    printf("%.2lf\n", ans);
    return 0;
}
```
```cpp

---

## 作者：Radiata (赞：49)

EMST: Delaunay Triangulation + Kruskal
--------------------------------------

很容易得出这道题本质就是考察最小生成树。  
在此之上可以注意到这道题所有点都是二维平面上的，因此该题实际上考察的是[平面欧几里得最小生成树（EMST）](https://en.wikipedia.org/wiki/Euclidean_minimum_spanning_tree)。  
Wiki中提到：求EMST可以先求出
[Delaunay三角剖分（Delaunay Triangulation，DT）](https://en.wikipedia.org/wiki/Delaunay_triangulation)
，然后在DT结果上直接跑一般的MST算法就可以了。  
下面的代码使用了分治法来求DT，Kruskal算法来求MST，时间复杂度O(NlogN)，C++11 85ms，O2 42ms。  
（代码是从之前已经写好的DT模板里改的，所以稍微有点丑，求轻喷。。  
```cpp
// LGOJ1265

#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdint>
#include <utility>

using namespace std;

using Coord = int32_t;
using SqrCoord = int64_t;

struct Vec {
    Coord x, y;
    inline Vec() noexcept = default;
    constexpr Vec(Coord x_, Coord y_) noexcept : x(x_), y(y_) {}
    constexpr bool operator <(const Vec& rhs) const noexcept {
        return x < rhs.x ? true : x > rhs.x ? false : y < rhs.y;
    }
    constexpr Vec operator +(const Vec& rhs) const noexcept {
        return {x + rhs.x, y + rhs.y};
    }
    constexpr Vec operator -(const Vec& rhs) const noexcept {
        return {x - rhs.x, y - rhs.y};
    }
    constexpr SqrCoord operator *(const Vec& rhs) const noexcept {
        return (SqrCoord) x * rhs.x + (SqrCoord) y * rhs.y;
    }
    constexpr SqrCoord operator %(const Vec& rhs) const noexcept {
        return (SqrCoord) x * rhs.y - (SqrCoord) y * rhs.x;
    }
    constexpr SqrCoord Len2() const noexcept {
        return *this * *this;
    }
    inline bool IsInCircumCircle(const Vec& A, const Vec& B, const Vec& C) const noexcept {
        auto AP = *this - A;
        auto BP = *this - B;
        auto CP = *this - C;
        return double(AP % BP) * CP.Len2() + double(BP % CP) * AP.Len2() + double(CP % AP) * BP.Len2() > 0;
    }
    inline bool IsLeftOfVector(const Vec& A, const Vec& B) const noexcept {
        auto AB = B - A;
        auto AP = *this - A;
        return AB % AP > 0;
    }
};

constexpr size_t DtMaxV = 5000;
constexpr size_t DtMaxE = DtMaxV * 400;
constexpr size_t DtMaxF = DtMaxV * 3;

using DtVertex = Vec;
using DtVPtr = DtVertex*;
struct DtEdge;
using DtEPtr = DtEdge*;

DtVertex DtVtcs[DtMaxV];

struct DtEdge {
    DtVPtr orig;
    DtEPtr twin;
    DtEPtr prev;
    DtEPtr next;
    inline DtEdge& operator >>(DtEPtr rhs) noexcept {
        next = rhs;
        rhs->prev = this;
        return *rhs;
    }
} DtEBuf[DtMaxE];
size_t DtECnt;

inline DtEPtr DtENew(DtVPtr A, DtVPtr B) noexcept {
    auto AB = &DtEBuf[DtECnt + 0];
    auto BA = &DtEBuf[DtECnt + 1];
    DtECnt += 2;
    AB->orig = A;
    BA->orig = B;
    AB->twin = BA;
    BA->twin = AB;
    return AB;
}

inline void DtEDel(DtEPtr AB) noexcept {
    AB->twin->twin = nullptr;
    AB->twin = nullptr;
}

inline DtEPtr DtConnect(DtEPtr le, DtEPtr re) noexcept {
    auto LR = DtENew(le->orig, re->orig), RL = LR->twin;
    *le->prev >> LR;
    *re->prev >> RL;
    *LR >> re;
    *RL >> le;
    return LR;
}

inline DtEPtr DtTangent(DtEPtr le, DtEPtr re) noexcept {
    for (auto e = le->next; e != le; e = e->next)
        if (*le->orig < *e->orig)
            le = e;
    for (auto e = re->next; e != re; e = e->next)
        if (*e->orig < *re->orig)
            re = e;
    DtEPtr xle, xre;
    do {
        xle = le;
        xre = re;
        while (le->next->orig->IsLeftOfVector(*re->orig, *le->orig))
            le = le->next;
        while (re->prev->orig->IsLeftOfVector(*re->orig, *le->orig))
            re = re->prev;
    } while (le != xle || re != xre);
    return DtConnect(le, re);
}

inline bool DtFindLeft(DtEPtr base) noexcept {
    auto L = base->orig;
    auto R = base->twin->orig;
    auto fst = base->prev;
    if (!fst->orig->IsLeftOfVector(*L, *R))
        return false;
    auto snd = fst->twin->prev;
    while (snd != base->twin && snd->orig->IsInCircumCircle(*L, *R, *fst->orig)) {
        *fst->prev >> fst->twin->next;
        *snd >> base;
        DtEDel(fst);
        fst = snd;
        snd = fst->twin->prev;
    }
    return true;
}

inline bool DtFindRight(DtEPtr base) noexcept {
    auto L = base->orig;
    auto R = base->twin->orig;
    auto fst = base->next->twin;
    if (!fst->orig->IsLeftOfVector(*L, *R))
        return false;
    auto snd = fst->next->twin;
    while (snd != base && snd->orig->IsInCircumCircle(*L, *R, *fst->orig)) {
        *fst->prev >> fst->twin->next;
        *base >> snd->twin;
        DtEDel(fst);
        fst = snd;
        snd = fst->next->twin;
    }
    return true;
}

// Divide and Conquer
DtEPtr DtWork(size_t beg, size_t end) noexcept {
    auto size = end - beg;
    // size >= 2
    if (size == 2) {
        auto A = &DtVtcs[beg + 0];
        auto B = &DtVtcs[beg + 1];
        auto AB = DtENew(A, B), BA = AB->twin;
        *AB >> BA >> AB;
        return AB;
    }
    if (size == 3) {
        auto A = &DtVtcs[beg + 0];
        auto B = &DtVtcs[beg + 1];
        auto C = &DtVtcs[beg + 2];
        auto AB = DtENew(A, B), BA = AB->twin;
        auto BC = DtENew(B, C), CB = BC->twin;
        auto det = (*B - *A) % (*C - *A);
        if (!det) {
            // Collinear
            *AB >> BC >> CB >> BA >> AB;
            return AB;
        }
        auto CA = DtENew(C, A), AC = CA->twin;
        *AB >> BC >> CA >> AB;
        *AC >> CB >> BA >> AC;
        return det > 0 ? AC : CA;
    }
    auto mid = beg + size / 2;
    auto base = DtTangent(DtWork(beg, mid), DtWork(mid, end));
    auto flag = (int) DtFindLeft(base) << 1 | (int) DtFindRight(base);
    while (flag) {
        auto L = base->orig;
        auto R = base->twin->orig;
        auto le = base->prev;
        auto re = base->next->next;
        if (flag == 3)
            flag = le->orig->IsInCircumCircle(*L, *R, *re->orig) ? 2 : 1;
        base = flag == 2 ? DtConnect(le, base->next) : DtConnect(base, re);
        flag = (int) DtFindLeft(base) << 1 | (int) DtFindRight(base);
    }
    return base;
}

struct GVertex;
struct GEdge;
using GVPtr = GVertex*;
using GEPtr = GEdge*;

struct GVertex {
    GVPtr ufsParent = nullptr;
    size_t ufsSize = 1;
    GVPtr UfsRoot() noexcept {
        return ufsParent ? ufsParent = ufsParent->UfsRoot() : this;
    }
    friend inline void UfsUnion(GVPtr lhs, GVPtr rhs) noexcept {
        if (lhs->ufsSize < rhs->ufsSize)
            swap(lhs, rhs);
        rhs->ufsParent = lhs;
        lhs->ufsSize += rhs->ufsSize;
    }
} GVtcs[DtMaxV];

struct GEdge {
    GVPtr U, V;
    double weight;
    constexpr bool operator <(const GEdge& rhs) const noexcept {
        return weight < rhs.weight;
    }
} GEBuf[DtMaxE];
size_t GECnt;

inline void GENew(DtEPtr e) noexcept {
    auto c = GEBuf + GECnt++;
    auto U = e->orig;
    auto V = e->twin->orig;
    c->U = &GVtcs[U - DtVtcs];
    c->V = &GVtcs[V - DtVtcs];
    c->weight = sqrt((*V - *U).Len2());
}

inline int ReadVoid() noexcept {
    auto ch = getchar();
    while (ch < '-')
        ch = getchar();
    return ch;
}

template<class Integral>
inline Integral ReadDigits(int ch) noexcept {
    auto res = (Integral) (ch & 0x0f);
    for (ch = getchar(); ch >= '0'; ch = getchar())
        res = res * 10 + (Integral) (ch & 0x0f);
    return res;
}

template<class Unsigned>
inline Unsigned ReadUnsigned() noexcept {
    return ReadDigits<Unsigned>(ReadVoid());
}

template<class Signed>
inline Signed ReadSigned() noexcept {
    auto ch = ReadVoid();
    if (ch == '-')
        return -ReadDigits<Signed>(getchar());
    return ReadDigits<Signed>(ch);
}

int main() {
    auto N = ReadUnsigned<size_t>();
    for (size_t i = 0; i < N; ++i) {
        DtVtcs[i].x = ReadSigned<int32_t>();
        DtVtcs[i].y = ReadSigned<int32_t>();
    }
    if (N < 2) {
        puts("0.00");
        return 0;
    }
    sort(DtVtcs, DtVtcs + N);
    DtWork(0, N);
    for (size_t i = 0; i < DtECnt; i += 2)
        if (DtEBuf[i].twin)
            GENew(&DtEBuf[i]);
    sort(GEBuf, GEBuf + GECnt);
    double res = 0;
    for (size_t i = 0; i < GECnt; ++i) {
        auto e = &GEBuf[i];
        auto U = e->U->UfsRoot();
        auto V = e->V->UfsRoot();
        if (U != V) {
            res += e->weight;
            UfsUnion(U, V);
        }
    }
    printf("%.2f\n", res);
    return 0;
}

```  
（稍微有点长，感谢大家的耐心。。  
P. S. 1. 其实是因为自己最近在看DT，然后知道DT可以用来解EMST，所以找了这个题来当模板题练手。。  
P. S. 2. 然而A了之后发现没人发三角剖分的题解，于是来水一篇。。  

---

## 作者：无意识躺枪人 (赞：27)

## 本题重点是对于第二条规则的理解：

如图，对于任意一点A，因为它申请修建AB道路，因此离A最近的点一定是B

![](https://cdn.luogu.com.cn/upload/pic/48906.png)

同理，B申请修建BC道路，因此C一定比A离B更近（即C在圆B内，不包含边界）

![](https://cdn.luogu.com.cn/upload/pic/48907.png)

同时，C申请修建CA道路，即A离C比A离B更近

![](https://cdn.luogu.com.cn/upload/pic/48908.png)

满足题意的话，ABC只能组成正三角形，因此排除最短边有三种情况

因为题目有：

```
一个实数，四舍五入保留两位小数，表示公路总长。（保证有惟一解）
```

因此我们可以得出结论：

### 规则2是没有用的

于是，题目的第一条规则

```
如果两个或以上城市申请修建同一条公路，则让它们共同修建
```

明显是最小生成树，裸的板子

```c
for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++) if(!vis[j]&&dis[j]<MIN) MIN=dis[j],pos=j;
		ans+=MIN; vis[pos]=1;MIN=oo;
		for (int j=1;j<=n;j++) dis[j]=min(dis[j],Distance(pos,j));
	}
```

再有，由于坐标范围很大，因此直接用函数求出距离即可

```c
double Distance(int a,int b)
{return sqrt((double)(point[a].x-point[b].x)*(point[a].x-point[b].x)+
			 (double)(point[a].y-point[b].y)*(point[a].y-point[b].y));
}

```

于是就可以得出代码= =
```c
#include<bits/stdc++.h>
#define oo 99999999
using namespace std;

int n,pos;
bool vis[5005];
double ans,MIN=oo,dis[5005];
struct tqr{int x,y;}point[5005];

double Distance(int a,int b){return sqrt((double)(point[a].x-point[b].x)*(point[a].x-point[b].x)+(double)(point[a].y-point[b].y)*(point[a].y-point[b].y));}

template<class T> inline void read(T &re){re=0;T sign=1;char tmp;while((tmp=getchar())&&(tmp<'0'||tmp>'9')) if(tmp=='-') sign=-1;re=tmp-'0';while((tmp=getchar())&&(tmp>='0'&&tmp<='9')) re=re*10+(tmp-'0');re*=sign;}

int main()
{
	// freopen("road.in","r",stdin);
	// freopen("road.out","w",stdout);
	read(n);
	for (int i=1;i<=n;i++){read(point[i].x);read(point[i].y);dis[i]=oo;}//读入和初始化
	dis[1]=0;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++) if(!vis[j]&&dis[j]<MIN) MIN=dis[j],pos=j;
		ans+=MIN; vis[pos]=1;MIN=oo;
		for (int j=1;j<=n;j++) dis[j]=min(dis[j],Distance(pos,j));
	}
	printf("%.2lf\n",ans);
	return 0;
}

```


------------

# $$\text{over}$$

---

## 作者：xizeroplus (赞：24)

首先可以证明，规则（2）是毫无用处的，因为三个以上城市成环的情况是不可能出现的（反证法）。接下来可以证明，按“轮”进行处理也是没有必要的，因此只需直接求出最小生成树即可。平方阶的Prim在时间上是可以通过的，但如果开5000\*5000邻接矩阵的话会MLE，因此没有必要把边权预处理出来保存在矩阵里，每次需要用到的时候直接计算即可。


```cpp

#include<cstdio>
#include<cmath>
#include<algorithm>
#define INF 1e9
#define MN 5001
using namespace std;

int p[MN][2];
double dis[MN];
bool vis[MN];

double dist(int x1,int y1,int x2,int y2)
{
    return sqrt((double)(x1-x2)*(x1-x2)+(double)(y1-y2)*(y1-y2));
}

int main()
{
    int n,i,j;
    scanf("%d",&n);
    for (i=1;i<=n;i++)
        scanf("%d%d",&p[i][0],&p[i][1]);
    for (i=2;i<=n;i++)
        dis[i]=INF;
    int mj;
    double mi;
    double ans=0;
    for (i=1;i<=n;i++)
    {
        mi=INF;
        for (j=1;j<=n;j++)
            if (!vis[j]&&dis[j]<mi)
            {
                mj=j;
                mi=dis[j];
            }
        ans+=mi;
        vis[mj]=true;
        for (j=1;j<=n;j++)
        {
            double t=dist(p[mj][0],p[mj][1],p[j][0],p[j][1]);
            if (t<dis[j])
                dis[j]=t;
        }
    }
    printf("%.2lf\n",ans);
    return 0;
}

```

代码写的很丑……


---

## 作者：逆时针的记忆 (赞：20)

## 最小生成树模板题

我一开始开了5000*5000的邻接矩阵，MLE是必须的

因此没有必要把边权预处理出来保存在矩阵里，每次需要用到的时候直接计算即可。//借用，我这题受到了 xizeroplus  dalao的启发

而sqrt很慢，可以在计算答案时再开方，这样可以节省一定时间

时间复杂度求解，我自己也搞不明白

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
using namespace std;
double x[5005],y[5005],d[5005],ans;
int n;
bool v[5005];
double qq(double x,double x1,double y,double y1)
{
	return (x-x1)*(x-x1)+(y-y1)*(y-y1);
}

int main()
{
	int i,j,k;
	scanf ("%d",&n);
	for (i=1; i<=n; i++) scanf ("%lf%lf",&x[i],&y[i]);
	memset(d,0x7f,sizeof(d)); d[1]=0;
	for (i=1; i<=n; i++)
	{
		k=0;
		for (j=1; j<=n; j++)
			if (!v[j]&&d[j]<d[k]) k=j;
		v[k]=true;
		for (j=1; j<=n; j++)
			if (!v[j]&&qq(x[k],x[j],y[k],y[j])<d[j]) d[j]=qq(x[k],x[j],y[k],y[j]);
	}
	for (i=1; i<=n; i++) ans+=sqrt(d[i]);
	printf ("%.2lf\n",ans);
	return 0;
}
```


---

## 作者：loaky (赞：9)

我，water and vegetable的不要不要的，
看见题解大佬们没有讲解prim代码，蒟蒻这里刚学习，顺便自己讲解一波
管理大大可别给驳回，QVQ
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const long long maxn=1e4+5;
const long long inf=1e9+5;
long long n,x[maxn],y[maxn],vis[maxn];
double d[maxn],ans;
double get(long long i,long long j){
	return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); 
}
void prim(){
	for(long long i=1;i<=n;i++) d[i]=get(1,i);//在prim中，	我们d数组表示的是第i个点到图中已经有的所有的点的最短距离，因为用二维存距离的话会直接炸空间，所以我们用的时候在去处理；
	d[0]=inf;
	for(long long i=1;i<n;i++){//我们图中的第一个点是1，已经求得了所有和1相连 的点的距离，我们求出这个点具体是哪个点，和这条最短的边是多少，将当前这个点加入我们最小生成树的点集中去，此时树上就已经有2个点了，下一步，我们要求的是与这两个点相邻的所有的点到这两个点距离最短的一个点，因为的d[i]之前表示的是到1的距离，此时在与到这个新的点的距离作比较，决定更不更新这个点，更新完之后，d[i]表示的是i这个点到目前已经构成的最小生成树的最短距离，也就是我们prim所需要的东西，然后就依次找点就行了
		long long xi=0;
		for(long long j=1;j<=n;j++){
			if(!vis[j]&&(xi==0||d[j]<d[xi])) xi=j;//找到距离最近的那个点
		}
		vis[xi]=1;//往树上加一个点
		ans+=d[xi];
		for(long long j=1;j<=n;j++){
			if(!vis[j]) d[j]=min(d[j],get(xi,j));//更新点距离部分
		}
	}
}
int main(){
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++){
		scanf("%lld%lld",&x[i],&y[i]);
	} 
	vis[1]=1;
	prim();
	printf("%.2lf",ans);//输出答案
	return 0;
}
```

---

## 作者：杰森的伯恩 (赞：8)

#堆优化prime+拓扑关系判断

其实就是求最小生成树，注意规则（2）是不会有影响的，证明如下：


因为A申请修建公路AB，所以AB<=AC,B申请修建公路BC,所以BC<=AB,C申请修建公路CA,所以AC<=BC,而这三个条件同时成立当且仅当AB=BC=AC，既然这样，去掉那条边都是一样的，这与求解最小生成树不冲突。


因为这是一个完全图，边数较多，所以我用了堆优化的prime算法，速度非常快，600ms。

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<iomanip>
#define f(i,l,r) for(i=(l);i<=(r);i++)
using namespace std;
const int MAXN=5005;
struct Node{
    int x,y;
}a[MAXN];
int n,vis[MAXN],num;
double d[MAXN],ans=0,heap0[10000000];
int heap1[10000000],sz;
inline double cal(int u,int v)
{
    return sqrt((double)(a[u].x-a[v].x)*(a[u].x-a[v].x)+(double)(a[u].y-a[v].y)*(a[u].y-a[v].y));
}
inline void pushup(int p)
{
    int fa=p>>1,id=heap1[p];
    double a=heap0[p];
    while(fa&&a<heap0[fa]){
        heap0[p]=heap0[fa];
        heap1[p]=heap1[fa];
        p=fa;
        fa>>=1;
    }
    heap0[p]=a;
    heap1[p]=id;
}
inline void pushdown(int p)
{
    int son=p<<1,id=heap1[p];
    double a=heap0[p];
    while(son<=sz){
        if(son<sz&&heap0[son]>heap0[son+1]) son++;
        if(heap0[son]>=a) break;
        heap0[p]=heap0[son];
        heap1[p]=heap1[son];
        p=son;
        son<<=1;
    }
    heap0[p]=a;
    heap1[p]=id;
}
inline void insert(double a,int id)
{
    heap0[++sz]=a;
    heap1[sz]=id;
    pushup(sz);
}
inline void Pop()
{
    heap0[1]=heap0[sz];
    heap1[1]=heap1[sz--];
    pushdown(1);
}
inline void Prime()
{
    int i;
    d[1]=0;
    insert(0.0,1);
    while(sz){
        int u=heap1[1];
        double w=heap0[1];
        Pop();
        if(vis[u]) continue;
        vis[u]=1;
        ans+=w;
        num++;
        if(num==n) break;
        f(i,1,n){
            if(vis[i]||i==u) continue;
            double tmp=cal(i,u);
            if(d[i]>tmp){
                d[i]=tmp;
                insert(d[i],i);
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    memset(d,127,sizeof(d));
    int i,j;
    cin>>n;
    f(i,1,n){
        cin>>a[i].x>>a[i].y;
    }
    Prime();
    cout<<fixed<<setprecision(2)<<ans<<endl;
    return 0;
}
```

---

## 作者：Suzt_ilymtics (赞：7)

 
 
 上午刚听学~~长~~姐=讲完最小生成树，于是跑来刷道绿题

#### 这道题有点卡空间和时间，所以耗了我2h，绕了很多弯，（~~其实是我菜~~），因此来发一手题解


------------


# [题目传送门](https://www.luogu.com.cn/problem/P1265)


------------

好，现在开始

看一下题面，题目中说每个城市选道路要从最近的开始选，并且给出了政府对于修路的三条措施：

```cpp
1、如果两个或以上城市申请修建同一条公路，
则让它们共同修建；

2、如果三个或以上的城市申请修建的公路成环。
如下图，A申请修建公路AB，B申请修建公路BC，
C申请修建公路CA。
则政府将否决其中最短的一条公路的修建申请；

3、其他情况的申请一律同意。
```


------------

1简化一下理解就是连接两个点

2感觉挺麻烦，但稍微过一下脑子咱就能发现，这种情况根本不可能出现（~~这题目明显是混淆视听~~）：

![](https://cdn.luogu.com.cn/upload/image_hosting/oifzghgw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

假设有三个城市A，B，C，AB距离为a，BC距离为b，AC距离为c

如果A要连B，那么有a < c;

如果B要连C，那么有b < a;

如果C要连A，那么有c < b;

显然不可能成立


------------

现在就回发现这就是个~~简单~~的
### 最小生成树求边权和的问题


------------

心潮澎湃的打了一个kruskal

很好，只给了我60分，T了三个点，还爆空间了


------------

### 原因是建的这个图是个稠密图，5000的数据，算一下有多少边就知道它会爆，用kruskal跑太慢了，显然用prim会更快一点（kruskal是遍历边，prim是遍历点）

既然打prim，给它加上点优队吧

这很好，可是只给了我70分

#### 考虑到用priority_queue的常数太大，还是会爆空间，只能选择刚开始学生成树就被我们抛弃的prim暴力求法了


------------

最后在暴力prim之下，终于将这道题绿了

下面附上AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
const int MAXN=5001;

int n,cnt;
int ctx[MAXN],cty[MAXN];
double ans;
bool vis[MAXN];
double dis[MAXN];

inline double getlen(int u,int v){
	long long a=pow(ctx[u]-ctx[v],2)+pow(cty[u]-cty[v],2);
	return sqrt(a);
}

inline void prim(){
	for(int i=1;i<=n;++i) dis[i]=2100000000;
	dis[1]=0;
	int qs=1;
	for(int k=1;k<n;k++){
		int wz;double mmin=2100000000;
		vis[qs]=1;
		for(int i=1;i<=n;++i){
			if(vis[i])continue;
			double len=getlen(qs,i);
			if(dis[i] > len) dis[i]=len;
		}
		for(int i=1;i<=n;++i){
			if(mmin > dis[i] && !vis[i]){
					mmin = dis[i];
					wz = i;
				}
		}
		qs=wz;
	}
		
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d%d",&ctx[i],&cty[i]);
	}
	prim();
	for(int i=1;i<=n;++i)ans+=dis[i];
	printf("%.2lf ",ans);
	return 0;
}
```

~~可能有dalao会用kruskal和prim优队，还是我太弱了~~

## 有什么不懂的~~或者我自己犯的sb错误~~，请指出




---

## 作者：牛瓜瓜 (赞：5)

#### 发现其他的题解都没有给出合理的证明说它为什么是最小生成树

~~否则它怎么难度标签会更模板题不一样~~

##### 首先证明（1）的确实是符合最小生成树的

![](https://cdn.luogu.com.cn/upload/image_hosting/o6cy0hnr.png)

这里C代表了除了A，B剩下的节点，由题意可以知道$圈1\le圈2,圈3$那这三坨要想构成最小生成树，肯定是要选圈1和圈2，圈3中较小的一个，而不选圈2和圈3

##### 我们来看看第二个

![](https://cdn.luogu.com.cn/upload/image_hosting/9ph55la6.png)

要想产生（2）这种情况，必定有$圈1\le圈2$,$圈2\le圈3$,$圈3\le圈1$那也就是三条边都是一样长的，那随便选两条都是可以的。

#### 综上，这样才能看出它确实是最小生成树

代码难度比较低，就是一个模板

#### 但是注意假如强行加$n^2$条边会MLE，其实我们不用存每条边，因为可以$O(1)$计算任意两点的距离

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;

#define N 5103

template<class TT> inline void read(TT &xx)

{

​	xx=0;char cc=getchar();bool ff=false;

​	while(cc<'0'||cc>'9'){if(cc=='-')ff=true; cc=getchar();}

​	while(cc>='0'&&cc<='9'){xx=(xx<<3)+(xx<<1)+cc-'0';cc=getchar();}

​	if(ff) xx=-xx;

}

int x[N],y[N],n;

double dis[N],ans;

bool v[N];

#define d(i,j) sqrt((double)(x[i]-x[j])*(x[i]-x[j])+(double)(y[i]-y[j])*(y[i]-y[j]))

#define min(i,j) (i<j)?i:j

int main()

{

​    freopen("road.in","r",stdin);

​    read(n);

​    for(int i=1;i<=n;i++) read(x[i]),read(y[i]),dis[i]=(double)100000008;

​    dis[1]=0;

​    for(int k=1;k<=n;k++)

​    {

​        double w=(double)100000008;

​        int pos=666;//w记录最短距离，pos记录最近节点

​        for(int j=1;j<=n;j++)

​            if(!v[j] && w>dis[j])

​                pos=j,w=dis[j];

​        //printf("get- dis[%d]=%lf\n",pos,dis[pos]);

​        v[pos]=true;

​        ans+=dis[pos];

​        for(int j=1;j<=n;j++)

​            if(!v[j]) dis[j]=min(dis[j],d(pos,j));

​    }

​    printf("%.2lf\n",ans);

​    return 0;

}
```





---

## 作者：SFWR (赞：5)

惊了都没有一个堆优化的PRIM吗~~时间宝贵~~

本题的条件二真的是有毒
~~看了题解惊醒~~

假如有这样一个环，那就只能是个等边三角形了，因为是修最短的路嘛，这样就变成了一个裸的最小生成树了，但又是一个完全图，所以还是要用PRIM。

要注意，既然图太大存坐标现算距离，就要考虑到范围，本题的数据范围int会爆的，所以要在求距离时转化为double，防止数据boom

code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,xy[2][10001],vist[10000];
double ans,dis[10001];
priority_queue<int,vector<pair<double,int> >,greater<pair<double,int> > > q;
double jl(int x,int y)
{return sqrt((double)abs(xy[0][x]-xy[0][y])*abs(xy[0][x]-xy[0][y])+(double)abs(xy[1][x]-xy[1][y])*abs(xy[1][x]-xy[1][y]));}
void prim(){
	for(int i=2;i<=n;i++)dis[i]=1e9+7;
	q.push(make_pair(0,1));
	while(!q.empty()){
		int u=q.top().second;q.pop();
		if(vist[u])continue;
		vist[u]=1;
		++cnt;
		ans+=dis[u];
		for(int i=1;i<=n;i++)
		{double jll=jl(u,i);
		if(jll<dis[i]){dis[i]=jll;q.push(make_pair(dis[i],i));}
		}
		if(cnt==n)break;
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>xy[0][i]>>xy[1][i];
	prim();
	printf("%.2lf",ans);
} 
```
码风巨丑

---

## 作者：redegg (赞：3)

prim算法的思想，但是是dfs的写法，（我竟然自己就写出来prim算法了？）。

为了不去跑排序，每次加边的时候，和现在的联通块已存在的边进行比较，然后更短的取代掉长的，就相当于把联通块当一个点来看。

写法粗糙，a[i]表示从现在的联通块到i点的最短距离，b[i]表示这个最短距离是从联通块里那个点求出来的，这样方便计算答案，答案每次就加上i到b[i]的距离。至于这个最短的i，循环一边，边看边存。

代码很丑，随便看看。

```
#include <bits/stdc++.h>
using namespace std;

int n;
long long x[500000];
long long y[500000];
long long a[500000];
int b[500000];
double ans;
int pr[500000];

int findfa(int x)
{
    if(pr[x]==x)
        return x;
    return pr[x]=findfa(pr[x]);
}

void dfs(int d,int k)
{
    if(k==n)
    {
        printf("%.2f\n",ans);
        exit(0);
    }
    int mind;
    long long minn=1e17;
    for(int i=1;i<=n;i++)
    {
        if(d==i);
        if(findfa(i)==findfa(d))continue;
        long long h=(x[d]-x[i])*(x[d]-x[i])+(y[d]-y[i])*(y[d]-y[i]);
        if(a[i]>h)
        {
            a[i]=h;
            b[i]=d;
        }
        if(minn>a[i])
        {
            mind=i;
            minn=a[i];
        }
    }
    d=b[mind];
    ans+=sqrt((double)((x[d]-x[mind])*(x[d]-x[mind])+(y[d]-y[mind])*(y[d]-y[mind])));
    pr[findfa(mind)]=findfa(d);
    dfs(mind,k+1);
}

int main()
{
    scanf("%d",&n);
    memset(a,0x3f,sizeof(a));
    for(int i=1;i<=n;i++)
    {
        pr[i]=i;
        scanf("%lld%lld",&x[i],&y[i]);
    }
    dfs(1,1);
    printf("%.2f",ans);
    return 0;
}

```

---

## 作者：rAIn (赞：3)

看见讨论有人发关于pascal的，就是正常的prim，不用优化吧...

```cpp
var
 q,b,c:array[1..5001]of real;
 ok:array[1..5001]of boolean;
 total,min:real;
 i,j,n,k,w:longint;
function len(l1,l2:longint):real;
var
 l3,l4:real;
begin
 l3:=sqr(b[l1]-b[l2]);
 l4:=sqr(c[l1]-c[l2]);
 len:=sqrt(l3+l4);
end;
begin
 readln(n);
 fillchar(ok,sizeof(ok),true);
 fillchar(q,sizeof(q),$7F);
 ok[1]:=false;
 for i:=1 to n do
  read(b[i],c[i]);
 k:=1;
 for i:=1 to n-1 do
  begin
   min:=maxlongint;
   for j:=1 to n do
    if ok[j] then
     if len(k,j)<q[j] then q[j]:=len(k,j);
   for j:=1 to n do
    if ok[j]=true then
     if q[j]<min then
      begin
       min:=q[j]; w:=j;
      end;
   if min<>maxlongint then
    begin
     total:=total+min;
     ok[w]:=false;
     k:=w;
    end;
 end;
 write(total:0:2);
end.

```

---

## 作者：FXY是蒟蒻 (赞：2)

## 一道绕了几个弯的板子题
### 仅此而已
乍一看这题好吓人啊，又是分轮来修建又是可能不同城市申请修建同一条线路又是如果成环免掉最短一条路的，看着就晕，不过差不多知道这是个最小生成树

先从看起来最麻烦的下手：如果成环免掉最短的一条路，好好用用你千年贪心的做【水】题习惯，可能出现这种情况吗？！显然【原谅我使用这么恶劣的词汇】如果你用Prim或者Kruskal算法等正常算法是不用特殊考虑也不用加判断条件的

然后，如果不同城市申请修建同一条线路就共同修建，这个更明显是句废话

再次，很多同志一看分轮修建就想慌：“分轮修建是不是时间复杂度很高？”“是不是要多循环？”“是不是加了就很难？”

But，在这个题里分轮修建也是废话

综上所述，这就是一道……题面绕了无数个弯【说了无数句废话】的最小生成树板子题

我会Prim！我会Kruskal！

附：Prim不用优化这题也能过

```c
#include<cstdio>
#include<cmath>
using namespace std;
double x[5001],y[5001];
double e[5001][5001],dis[5001],book[5001]={0};
double max(double x,double y)
{
	if(x>y)
	return x;
	return y;
}
double min(double x,double y)
{
	if(x>y)
	return y;
	return x;
}
double jvli(double x1,double y1,double x2,double y2)
{
	if(x1==x2)
	return max(y1,y2)-min(y1,y2);
	if(y1==y2)
	return max(x1,x2)-min(x1,x2);
	double hehe=max(y1,y2)-min(y1,y2);
	double haha=max(x1,x2)-min(x1,x2);
	return sqrt(hehe*hehe+haha*haha);
}
int main()
{
	double n,m,minn,t1,t2,t3;
	int i,j,k;
	double inf=9999999;
	int cnt=0;
	double sum=0;
	scanf("%lf",&n);
	for(i=1;i<=n;i++)//初始化
	for(j=1;j<=n;j++)
	if(i==j)
	e[i][j]=0;
	else
	e[i][j]=inf;
	for(i=1;i<=n;i++)
	scanf("%lf%lf",&x[i],&y[i]);
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	{
		t3=jvli(x[i],y[i],x[j],y[j]);//距离存储【爆MLE】
		e[i][j]=t3;
		e[j][i]=t3;
	}
	//跑板子
    for(i=1;i<=n;i++)
	dis[i]=e[1][i];
	book[1]=1;
	cnt++;
	while(cnt<n)
	{
		minn=inf;
		for(i=1;i<=n;i++)
		{
			if(book[i]==0&&dis[i]<minn)
			{
				minn=dis[i];
				j=i;
			}
		}
		book[j]=1;cnt++;
		sum+=dis[j];
		for(k=1;k<=n;k++)
		{
			if(book[k]==0&&dis[k]>e[j][k])
			dis[k]=e[j][k];
		}
	}
	printf("%.2lf",sum);
	return 0;
} 
```
期望100，悲剧发生，只有80

#### 注意看看数据范围

n<5000如果开5000*5000的数组肯定会MLE啊！

所以可以考虑下不用数组存储数据，在跑板子的时候顺便算出来就可以

### Prim AC代码

```c
#include<cstdio>
#include<cmath>
using namespace std;
double x[5001],y[5001];
double dis[5001],book[5001]={0};
double max(double x,double y)
{
	if(x>y)
	return x;
	return y;
}
double min(double x,double y)
{
	if(x>y)
	return y;
	return x;
}
double jvli(double x1,double y1,double x2,double y2)//计算距离函数
{
	if(x1==x2)
	return max(y1,y2)-min(y1,y2);
	if(y1==y2)
	return max(x1,x2)-min(x1,x2);
	double hehe=max(y1,y2)-min(y1,y2);
	double haha=max(x1,x2)-min(x1,x2);
	return sqrt(hehe*hehe+haha*haha);//利用勾股定理
}
int main()
{
	double n,m,minn,t1,t2,t3;
	int i,j,k;
	double inf=9999999;//正无穷
	int cnt=0;
	double sum=0;
	scanf("%lf",&n);
	for(i=1;i<=n;i++)
	scanf("%lf%lf",&x[i],&y[i]);//读入坐标
	//跑板子ing
    for(i=1;i<=n;i++)
	dis[i]=jvli(x[1],y[1],x[i],y[i]);//此处省略调用数组，直接计算距离
	book[1]=1;
	cnt++;
	while(cnt<n)
	{
		minn=inf;
		for(i=1;i<=n;i++)
		{
			if(book[i]==0&&dis[i]<minn)
			{
				minn=dis[i];
				j=i;
			}
		}
		book[j]=1;cnt++;
		sum+=dis[j];
		for(k=1;k<=n;k++)
		{
			if(book[k]==0&&dis[k]>jvli(x[j],y[j],x[k],y[k]))//距离直接计算
			dis[k]=jvli(x[j],y[j],x[k],y[k]);
		}
	}
	printf("%.2lf",sum);
	return 0;//程序的结束，世界的消逝
} 
```
看到有某同学用的Kruskal，第一遍70，两个点MLE一个点TLE

很想不明白Prim无优化都能过Kruskal为什么会超时

His Code
```
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
long long n,cnt=0;
long long x[5050],y[5050],s[5050];
struct edge
{
	long long u,v;
	double w;
}a[12500050];
void addedge(int u,int v)
{
	a[++cnt].u=u;
	a[cnt].v=v;
	a[cnt].w=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));
}
double comp(const edge &a,const edge &b)
{
	return a.w<b.w;
}
int search(int l)
{
	if(s[l]==l)
		return l;
	else 
		return s[l]=search(s[l]);
}
void linkl(int l,int m)
{
	s[search(l)]=search(m);
}
int main()
{
	int i,j,z=0;
	double result=0;
	scanf("%lld",&n);
	for(i=1;i<=n;i++)
		scanf("%lld%lld",&x[i],&y[i]);
	for(i=1;i<=n-1;i++)
		for(j=i+1;j<=n;j++)
			addedge(i,j);
	for(i=1;i<=n;i++)
		s[i]=i;
	sort(a+1,a+1+cnt,comp);
	for(i=1;i<=cnt;i++)
	{
		if(search(a[i].u)!=search(a[i].v))
		{
			z++;
			linkl(a[i].u,a[i].v);
			result+=a[i].w;
		}
		if(z==n-1)
			break;
	}
	printf("%0.2lf",result);
	return 0;
} 
```
归根结底还是数组开大了，把数据在跑板子的时候算就行，还能少算不少没用的

在这里，本人衷心希望大家不要重蹈覆辙

审核真好看！给过吧QwQ

---

## 作者：Cat_cc (赞：2)

### 本质是求最小生成树。对于规则2，构成环则申请时去掉最大边。

~~因为最多有5000个点，又是完全图，故不采用Kruskal算法。~~

所以就使用prim算法

先介绍一下吧：

普里姆算法，图论中的一种算法，可在加权连通图里搜索最小生成树。意即此算法搜索到的边子集所构成的树中，不但包括连通图里的所有顶点，且其所有边的权值之和亦为最小。

 从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。
    
    （1）输入：一个加权连通图，其中顶点集合为V，边集合为E；
    （2）初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}；
    （3）重复下列操作，直到Vnew = V：
            在集合E中选取权值最小的边（u, v），其中u为集合Vnew中的元素，而v则不是（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；
            将v加入集合Vnew中，将（u, v）加入集合Enew中；
    （4）输出：使用集合Vnew和Enew来描述所得到的最小生成树。

然后发现了一个很有（keng）趣（ren）的现象：
计算两点间距离时，因为点的坐标是整数，因此要将坐标平方进行类型强制转换。
```cpp
double value(int i,int j){
        return sqrt( (double)(x[i]-x[j])*(x[i]-x[j]) + (double)(y[i]-y[j])*(y[i]-y[j]) );
    }
```

如果写成
```cpp
double value(int i,int j){
        return sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) );
    }

```
就会死9个点（查了很久）

ac代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,x[5001],y[5001];
int vis[5001];
double dis[5001],dist;
double ans=0;
double value(int i,int j){
    return sqrt( (double)(x[i]-x[j])*(x[i]-x[j]) + (double)(y[i]-y[j])*(y[i]-y[j]) );
}
void prim(){
    for(int i=1;i<=m;i++)dis[i]=1e20;
    dis[1]=0;
    int V=1;
    for(int i=1;i<=m;i++){
        double minn=1e20;
        for(int j=1;j<=m;j++)
            if(!vis[j])
                if(minn>dis[j]){
                    minn=dis[j];
                    V=j;
                }
        vis[V]=1;
        ans+=dis[V];
        for(int j=1;j<=m;j++)
            if(!vis[j]){
                dist=value(V,j);
                if(dis[j]>dist)dis[j]=dist;
            }
    }
}
int main(){
    cin>>m;
    for(int i=1;i<=m;i++)cin>>x[i]>>y[i];
    prim();
    printf("%.2f\n",ans);
    return 0;
}
```



---

## 作者：林志杰 (赞：2)

首先对于三个点的环最小的一条边一定是它两个顶点所连的最小边，所以不可能存在规则二，问题转化为了最小生成树。

其次这题边数太多，Prim速度要比Kruskal快很多。

第三，开double的二维数组内存是200多MB,这题限制128，不行。所以用到就现算。

代码如下：（核心代码只有几行）

//边数较少可以用Kruskal,因为Kruskal算法每次查找最短的边.

//边数较多可以用Prim,因为它是每次加一个顶点,对边数多的适用.






        

```cpp
// P1265 公路修建
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn = 5010;
int n;
double x[maxn],y[maxn],d[maxn],ans=0;
bool vis[maxn]={false,true};
inline double cal(int i,int j)
{
    return sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));
}
void Prim()
{
    int Dis=0x7fffffff,p=0;
    for(int i=1;i<=n;i++) d[i] = cal(1,i);
    for(int k=1;k<n;k++,p=0,Dis=0x7fffffff) {
        for(int i=1;i<=n;i++) if(!vis[i] && Dis > d[i]) p = i,Dis = d[i];//找出距离树最近的点
        vis[p] = true;//挂到树上
        ans += d[p];
        for(int i=1;i<=n;i++) if(!vis[i] && d[i] > cal(i,p)) d[i] = cal(i,p);//更新最短距离 
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
    Prim();
    printf("%.2lf",ans);
    return 0;
}

```

---

## 作者：RyexAwl (赞：1)

## 题意
给出平面上的$n(≤5000)$个点， 点与点之间可以连边，距离为欧几里得距离，求最小生成树。

## 分析
我们发现，边数至多为$n^2$，如果用堆优化的$Prim$或$Kruskal$必然不如朴素的$Prim$来的要快。

考虑如何建图。我们将每两个点都连一条边，边权为两点的欧几里得距离，然后跑$Prim$。

但是这样建图太费时间，因此我们可以不把图建出来，只存$n$个点，每次跑$Prim$时更新与当前点所连接的点时，再依次遍历除了当前点以外的所有点更新$Dist$。

然后就可以愉快地跑$Prim$辣。

```cpp
inline void prim(){
        ans = 0;
        for (int i = 1; i <= n; i++) dist[i] = inf;
        dist[1] = 0;
        for (int i = 0; i < n; i++){
            int min_d = inf,x = 0;
            for (int j = 1; j <= n; j++){
                if (!vis[j] && dist[j] < min_d){
                    min_d = dist[j];
                    x = j;
                }
            }
            vis[x] = true;
            for (int j = 1; j <= n; j++){
                if (j == x || vis[j]) continue;
                dist[j] = std::min(dist[j],get(loc[x],loc[j]));
            }
        }
        for (int i = 1; i <= n; i++) ans += dist[i];
    }
```


---

## 作者：YuanZhizheng (赞：1)

大家大概看看题目就会发现大概是最小生成树问题。

在审批规则(2)那一块我自己差点绕晕自己了，所以我得说一下。

规则写的是：如果三个或以上的城市申请修建的公路成环。如下图，A申请修建公路AB，B申请修建公路BC，C申请修建公路CA。则政府将否决其中最短的一条公路的修建申请；

![](https://cdn.luogu.com.cn/upload/pic/80.png)

乍一看，去掉最短的一条，那么又好像不是最小生成树了？其实并不是，我们只要不建成环，就可以选最短的两条来修建，自然还是最小生成树。

常见的最小生成树算法有三个，prim、堆优化prim、Kruscal，复杂度是O(n^2)、O(nloge)、O(eloge)，prim常常是被人遗忘的，因为n^2通常数量过大。而这题点之间两两有边，边数为5000 * 5000，达到了2.5 * 10^7。

这题开的空间是125MB，先说一下空间大概怎么算。比如这题，我们开一个2e7左右的double数组的话，我们知道double占8字节，所以空间就是8 * 2e7 / (1024 * 1024)≈190MB。

单看时间复杂度，三个算法都是满足的。而堆优化prim和Kruscal都需要存边，经过刚才的计算我们可以发现是没有那么多空间给我们存下的。

普通的prim就不一样，对于这种给坐标的图，我们是不需要存边的，可以现算。

prim的模板是这样的
```
int ans=0,End=-1;
    for(i=1;i<=n;i++)
    {
        End=-1;
        for(j=1;j<=n;j++)
        {
            if(!vis[j]&&(End==-1||d[End]>d[j]))//每次都先加入一个没加入的点，之后选择当前到点集最近的点加入
                End=j;
        }
        vis[End]=1;
        ans+=d[End];
        for(j=1;j<=n;j++)
        {
            if(!vis[j]&&d[j]>road[End][j])//判断每个点到新的点距离是否小于到之前点集的距离
            d[j]=road[End][j]; //保证每次更新以后，每个d【i】都是到这个点集的最短；
        }
    }
```
在此也是用road[][]来存了边，如果是坐标，我们可以替换成这样。

```
    db ans=0.0;
    int End=-1;
    for(int i=1;i<=n;i++)
    {
        End=-1;
        for(int j=1;j<=n;j++)
        {
            if(!vis[j]&&(End==-1||d[End]>d[j]))
                End=j;
        }
        vis[End]=1;
        ans+=d[End];
         for(int j=1;j<=n;j++)
        {
            db f=sqrt((x[End]-x[j])*(x[End]-x[j])+(y[End]-y[j])*(y[End]-y[j]));
            if(!vis[j]&&d[j]>f)
                d[j]=f;
        }
    }
```
注意看，我在后面的for循环中，用f变量来保存并计算距离，这样就可以现用现算，完全不需要存边，只需要用x[],y[]数组存一下坐标即可，开5000的一维数组空间是非常小的，这样就可以满足题目要求了。

下面上AC代码，附带了一些我用得比较顺手且易懂的宏定义，不会影响阅读。如果还是觉得难读，也可以只看看上面思路就行了，别的大佬已经给出了很多非常完美的代码。

```
#include <bits/stdc++.h>
using namespace std;
#define rep(i,k,n) for(int i=k;i<=n;i++)
#define per(i,n,k) for(int i=n;i>=k;i--)
#define pb push_back
#define fi first
#define se second
#pragma GCC optimize(3,"Ofast","inline")//开启O3加速
typedef long long ll;
typedef double db;
 int intread()//快速读入
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
db d[5005];
bool vis[5005];
db x[5005],y[5005];
int main()
{
    int n=intread();
    rep(i,1,n)
    {
        scanf("%lf%lf",&x[i],&y[i]);
        cout<<x[i]<<' '<<y[i]<<endl;
        d[i]=1e18;
    }
    d[1]=0.0;
    db ans=0.0;
    int End=-1;
    rep(i,1,n)
    {
        End=-1;
        rep(j,1,n)
        {
            if(!vis[j]&&(End==-1||d[End]>d[j]))
                End=j;
        }
        vis[End]=1;
        ans+=d[End];
        rep(j,1,n)
        {
            db f=sqrt((x[End]-x[j])*(x[End]-x[j])+(y[End]-y[j])*(y[End]-y[j]));
            if(!vis[j]&&d[j]>f)
                d[j]=f;
        }
    }
    printf("%.2f",ans);
    return 0;
}
```
还有不理解可以在评论去提问，如果有什么建议也欢迎提出!

---

## 作者：YZL11111 (赞：1)

## 【题目描述】
某国有n个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。

修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。

政府审批的规则如下：

（1）如果两个或以上城市申请修建同一条公路，则让它们共同修建；

（2）如果三个或以上的城市申请修建的公路成环。如下图，A申请修建公路AB，B申请修建公路BC，C申请修建公路CA。则政府将否决其中最短的一条公路的修建申请；

（3）其他情况的申请一律同意。

一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相：连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。

当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。

你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。

## 【输入格式】
第一行一个整数n，表示城市的数量。(n≤5000)

以下n行，每行两个整数x和y，表示一个城市的坐标。(-1000000≤x，y≤1000000)

## 【输出格式】
一个实数，四舍五入保留两位小数，表示公路总长。（保证有惟一解）

## 【解题思路】
这题很显然是一道求解MST的题目，先看数据规模，n≤5000，嗯，稠密图，Prim，然后考虑邻接矩阵，n太大存不了，再考虑邻接表，5000乘以5000乘以2（* 2是算上反向边），？？？？？MLE警告

一道图论题你告诉我不能存图？？

直接看标程，哦，一边找边一边算距离，好的，一发AC

**Prim好题**

~~（别忘了开long long）~~

## 【AC代码】
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream> 
#include <algorithm>
using namespace std;
typedef long long ll;
const double INF = 0x3f3f3f3f / 1.00;
struct node
{
	ll x, y;
}a[5010];
ll cal(int x, int y)
{
	ll xx = a[x].x - a[y].x;
	ll yy = a[x].y - a[y].y;
	ll temp = xx * xx + yy * yy;
	return temp;
}
double dis[5010];
bool vis[5010];
int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%lld%lld", &a[i].x, &a[i].y);
		dis[i] = INF;
	}
	for (int i = 1; i <= n; i++)  //预处理源点
	{
		dis[i] = double(sqrt(cal(1, i)));
	}
	vis[1] = true;
	double sum = 0;
	for (int i = 1; i <= n - 1; i++)  //标准的Prim算法
	{
		double Min = INF / 1.00;
		int k = 0;
		for (int j = 1; j <= n; j++)
		{
			if (!vis[j] && dis[j] < Min)
			{
				Min = dis[j];
				k = j;
			}
		}
		vis[k] = true;
		sum += Min;
		for (int j = 1; j <= n; j++)
		{
			double d = double(sqrt(cal(k, j)));  //计算距离
			if (!vis[j] && dis[j] > d)
			{
				dis[j] = d;
			}
		}
	}
	printf("%.2f\n", sum);
	return 0;
}
```


---

## 作者：Alex_Su (赞：0)

基本上是裸最小生成树题，而这是稠密图，边很多，用prim效率会比kruskal快。另外这里算距离坐标一平方int会溢出，所以我坐标用的是long

long 储存。另外储存边5000\*5000内存会炸，所以在prim的过程中算距离就可以了。

以下AC程序


```cpp
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<math.h>
using namespace std;
int n,m,u,v;
double l[5001],na[5001],INF=99999999,mi,sum=0;
long long x[5001],y[5001];
void prim(int v0)
{
    sum=0;
    for(int i=1;i<=n;i++)
    {
        na[i]=v0;
        l[i]=sqrt((x[v0]-x[i])*(x[v0]-x[i])+(y[v0]-y[i])*(y[v0]-y[i]));
    }
    na[v0]=-1;
    for(int i=1;i<n;i++)
    {
        v=-1;
        mi=INF;
        for(int j=1;j<=n;j++)
            if(na[j]!=-1&&mi>l[j])
            {
                mi=l[j];
                v=j;
            }
        if(v!=-1)
        {
            na[v]=-1;
            sum+=l[v];
            for(int j=1;j<=n;j++)
            {
               double kk=sqrt((x[v]-x[j])*(x[v]-x[j])+(y[v]-y[j])*(y[v]-y[j]));
              if(na[j]!=-1&&kk<l[j])
              {
                  l[j]=kk;
                  na[j]=v;
              }
            }
        }
    }
    printf("%.2f\n",sum);
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
       cin>>x[i]>>y[i];
    prim(1);
    return 0;
}
```

---

## 作者：Ghost_lzy (赞：0)

首先这个题5000个点，5000\*5000log(5000^2)绝逼爆炸，所以不能用kruskal,于是可以用prim，这里的prim可以像DJ(忘掉了)一样优化到nlogn，然而我还是放出好理解的n^2做法（5000是可以过的），注意要边算边prim(吐槽vector慢的真的是可以，TLE的同学一定要注意)，放代码：

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
using namespace std;
int x[5010][2];double z[5010];
bool y[5010];
int n,i,j,k,a,b;double s,min1,t;
double dt(int a,int b)
{
  double e1,e2;
  e1=abs(x[a][0]-x[b][0]);e2=abs(x[a][1]-x[b][1]);
  return sqrt(e1*e1+e2*e2);
}      
int main()
{
  s=0.0;  
  memset(y,true,sizeof(y));  
  scanf("%d",&n);
  for (i=1;i<=n;i++)
     scanf("%d%d",&x[i][0],&x[i][1]);
  y[1]=false;
  for (i=2;i<=n;i++)  z[i]=dt(1,i); //printf("%.2lf",z[j]);}
  for (i=2;i<=n;i++)
     {
        min1=1e+300;
        for (j=1;j<=n;j++)
           if (y[j] && z[j]<min1) {k=j;min1=z[j];}         
       s=s+min1;y[k]=false;
       for (j=1;j<=n;j++)
         {
           t=dt(k,j);              
           if (y[j] && t<z[j])  z[j]=t;   
         }
     }  
  printf("%.2lf\n",s);
  return 0;                       
}
```

---


# 城市街道交通费系统

## 题目描述

城市街道交费系统最近创立了。一辆汽车左转一次需付费 $1$ ，右转一次需付费 $5$ 。只有当前进、左转、右转都无路可走的时候，调头才是允许的，调头每次付费 $10$ 。

给出一张城市地图，要求你求出从起始点到达终止点的花费最少的路径。幸运的是，所有的道路都是正北、正南、正西或正东方向的。

## 说明/提示

样例一解释：

直走，然后左转 $3$ 次，最后右转到终止点 `F`。如果先直走然后右转 $2$ 次，花费将是 $10$ 。

---

样例二解释：

最便宜的路径花费 $7$ ：立刻左转，直走，在第一个岔路口左转，随后右转。

---

对于 $100\%$ 的数据：$4 \leq h,w \leq 30$。

数据保证地图中只有一个起点，一个终点，他们之间存在着可通达的路径。同时保证地图最外层一圈都是障碍。

## 样例 #1

### 输入

```
8 11
...........
....#####..
....#...#..
....#...#..
.#E######..
....#......
.##F#......
...........
```

### 输出

```
8
```

## 样例 #2

### 输入

```
17 21
.....................
.#######.............
.#.....#.......#.....
.###...#.......#.....
...#...#.......#.....
.###...#.......#.....
.#.....#.......#.....
.############F#####..
.......#..........#..
.......#..........#..
...#...#...#####..#..
...#...#...#.#.#..#..
..#S########.#.#..#..
...#.......#.###..#..
...#.......#......#..
...........########..
.....................```

### 输出

```
7```

# 题解

## 作者：RedreamMer (赞：19)

# P1300题解

算法： $BFS$ 

~~为什么题解里的人们都是用DFS写的QAQ，一定是我太菜了~~

这类题目很明显要用搜索做，好像这道题并不会卡 $DFS$ ，但我还是用 $BFS$ ~~顽强~~地做了下去

第一步，把数据读入并存储在一张图里，能走标记为 $1$ ，不能走标记为 $0$ ，再记录一下起点和终点，注意要标记起点的方向，用优先队列维护，以花费为关键字把最小的放在队首，这部分就做完了

第二步，开始 $BFS$ ，把当前所有能做的步骤都做一遍，即前进、左转、右转、掉头（当前面都**不能做时**才能做，不然会 $WA$ 一个点），还有，如果当前能做某个步骤，但做了之后不是最优的，那就不要做了，但**不做不代表不能做**，所以我们要造一个数组来维护当前的最优花费： $m[i][j][k]$ （ $i$ ， $j$ 代表坐标 $x$ ， $y$ ， $k$ 代表方向（$k\in[0,3]$）），由于有优先队列维护作用，所以先访问到终点就是最快的，直接跳出

第三步，输出 $Answer$ 

### code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,xx,yy,x,y;
int dx[4]= {-1,0,1,0},dy[4]= {0,1,0,-1};//方向数组，很方便 
int m[1001][1001][4];//数组维护花费 
bool s[1001][1001];
char ch;
struct P {//协助优先队列 
	int x,y,to;
	bool operator<(const P& t)const {//优先规则 
		return m[t.x][t.y][t.to]<m[x][y][to];
	}
} k,l;
priority_queue<P> st;
int main() {
	memset(m,0x7f,sizeof m);//初始化 
	cin>>a>>b;
	for(int i=1; i<=a; i++)//读入 
		for(int j=1; j<=b; j++) {
			cin>>ch;
			if(ch!='.') {
				s[i][j]=1;
				if(ch!='#') {
					if(ch!='F') {
						if(ch=='N')
							k.to=0;
						if(ch=='S')
							k.to=2;
						if(ch=='W')
							k.to=3;
						if(ch=='E')
							k.to=1;
						k.x=i;
						k.y=j;
					} else {
						xx=i;
						yy=j;
					}
				}
			}
		}
	m[k.x][k.y][k.to]=0;
	st.push(k);
	while(!st.empty()) {//BFS开始 
		bool q=0;
		k=st.top();
		if(k.x==xx&&k.y==yy)//访问到终点 
		break;
		st.pop();
		x=k.x+dx[k.to];
		y=k.y+dy[k.to];
		if(s[x][y])
			q=1;
		if(s[x][y]&&m[x][y][k.to]>m[k.x][k.y][k.to]) {//前进判断 
			m[x][y][k.to]=m[k.x][k.y][k.to];
			l.x=x;
			l.y=y;
			l.to=k.to;
			st.push(l);
		}
		x=k.x+dx[(k.to+3)%4];
		y=k.y+dy[(k.to+3)%4];
		if(s[x][y])
			q=1;
		if(s[x][y]&&m[x][y][(k.to+3)%4]>m[k.x][k.y][k.to]+1) {//左转判断 
			m[x][y][(k.to+3)%4]=m[k.x][k.y][k.to]+1;
			l.x=x;
			l.y=y;
			l.to=(k.to+3)%4;
			st.push(l);
		}
		x=k.x+dx[(k.to+1)%4];
		y=k.y+dy[(k.to+1)%4];
		if(s[x][y])
			q=1;
		if(s[x][y]&&m[x][y][(k.to+1)%4]>m[k.x][k.y][k.to]+5) {//右转判断 
			m[x][y][(k.to+1)%4]=m[k.x][k.y][k.to]+5;
			l.x=x;
			l.y=y;
			l.to=(k.to+1)%4;
			st.push(l);
		}
		if(!q) {//判断其他操作能不能做 
			x=k.x+dx[(k.to+2)%4];
			y=k.y+dy[(k.to+2)%4];
			if(s[x][y]&&m[x][y][(k.to+2)%4]>m[k.x][k.y][k.to]+10) {//后退判断 
				m[x][y][(k.to+2)%4]=m[k.x][k.y][k.to]+10;
				l.x=x;
				l.y=y;
				l.to=(k.to+2)%4;
				st.push(l);
			}
		}
	}
	cout<<m[k.x][k.y][k.to];
	return 0;
}//97行代码QAQ 
```

 $46ms$ 快得起飞
 
 ### [$\color{blue}\text{My Blog}$](https://www.luogu.org/blog/184549/)

---

## 作者：破忆 (赞：10)

### 题目大意
求起点到终点的最小花费，其中转弯掉头都需要费用


------------
### 解法
这道题与模板搜索的区别就是多了方向，在原数组中加上方向这一维即可

为了方便，北、西、南、东分别看成方向0、1、2、3

设当前方向是w，稍微分析之后，得到左转、右转、掉头之后的方向分别是
$(w+1)\mod4$,$(w+3)\mod4$,$(w+2)\mod4$

接下来暴力搜索顺便剪枝就没问题了，具体细节请看代码

------------
### 代码
```cpp
#include<bits/stdc++.h>
#define IN inline
using namespace std;
const int maxn=35,p[4][2]={{-1,0},{0,-1},{1,0},{0,1}};//先预处理一下各个方向位移之后坐标的变化量
char s[maxn];
int n,m,sx,sy,sw,ans=1<<30,dis[maxn][maxn][4],tot;//dis[x][y][w]表示到达第x行第j列方向为w的最小代价
short mp[maxn][maxn];
IN void DFS(int x,int y,int w,int c){
	if(dis[x][y][w]<=c||c>=ans) return;//如果发现当前代价大于等于当前点的最小值或者答案，就停止搜索
	dis[x][y][w]=c;
//	printf("%d %d %d %d %d\n",++tot,x,y,w,dis[x][y][w]);
	if(mp[x][y]==2) ans=min(ans,dis[x][y][w]);//到达终点，刷新最小值
	bool flg=0;
	int fx=x+p[w][0],fy=y+p[w][1];//直行
	int lw=(w+1)%4,lx=x+p[lw][0],ly=y+p[lw][1];//左转
	int bw=(w+2)%4,bx=x+p[bw][0],by=y+p[bw][1];//掉头
	int rw=(w+3)%4,rx=x+p[rw][0],ry=y+p[rw][1];//右转
	if(mp[fx][fy]) flg=1,DFS(fx,fy,w,c);//直行
	if(mp[lx][ly]) flg=1,DFS(lx,ly,lw,c+1);//左转
	if(mp[rx][ry]) flg=1,DFS(rx,ry,rw,c+5);//右转
	if(mp[bx][by]&&!flg) DFS(bx,by,bw,c+10);//掉头
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		for(int j=1;j<=m;j++){
			mp[i][j]=1; //把能到达的赋值
			switch(s[j]){
				case '.':{mp[i][j]=0;break;}//不能到达的归零
				case '#':{break;}
				case 'F':{mp[i][j]=2;break;}//终点记号
				case 'N':{sx=i,sy=j,sw=0;break;}
				case 'W':{sx=i,sy=j,sw=1;break;}
				case 'S':{sx=i,sy=j,sw=2;break;}
				case 'E':{sx=i,sy=j,sw=3;break;}
			}
		}
	}
	memset(dis,63,sizeof dis);
	DFS(sx,sy,sw,0);
	printf("%d\n",ans);
	return 0;
}
```
upd 2021.01.31 感谢 C2020陈铭浩 的指正，修复了一些错误

---

## 作者：fls233666 (赞：6)

首先，由于 $4 \le w,h \le 30$ 范围很小，直接考虑**搜索**。

其次，因为要求最少花费，**考虑广度优先搜索**。

但是，由于每一步的花费不同，如果使用普通的队列，无法保证队首为最优状态。所以要考虑使用优先队列进行搜索，保证当前状态最优。

进一步考虑如何剪枝。由于可能会经过一个格子很多次，所以不能直接使用一个 bool 数组进行标记。可以考虑一种 A* 算法。因为只能向东西南北四个方向走，所以设计估价函数为当前点与终点的曼哈顿距离。简单设计一下，可以得到如下搜索代码：

```cpp
while(!que.empty()){
		hd=que.top();
		que.pop();  //取出队首最优解
		if(!hd.val.second){  //如果与中点距离为0【即到达终点】，结束搜索
			printf("%d\n",hd.val.first);
			return 0;
		}
     /*每个状态有四种操作，分别对应的代价为dt[i]
     i=0:直走，i=1:左转，i=2：掉头，i=3：右转
     */
		for(rgt i=0;i<4;i++){  
			tl.p=(hd.p+i)%4;   //改变方向
			tl.x=hd.x+gx[tl.p];
			tl.y=hd.y+gy[tl.p]; //计算新坐标
			if(mp[tl.x][tl.y]!='.'){  //如果不为障碍，加入优先队列搜索答案
				tl.val=make_pair(hd.val.first+dt[i],getdis(tl.x,tl.y));
				que.push(tl); 
			}
		}
	}
```

完善上述搜索代码和程序的其它部分可以得到 $\texttt{40}$ 分的好成绩。

-------

继续考虑剪枝优化。

我们发现，如果无限制地允许程序重复搜索，那么每一步都会产生四个新状态，最后会产生大量的无用状态，不仅效率低，而且就算不超时，到最后也要爆空间。

那么，考虑如何**让程序有选择地重复搜索**。

我们可以使用两个三维数组来解决问题。记 bool 数组 $fw_{i,j,k}$ 表示是否以面朝 $k$ 的状态到达过点 $(i,j)$。另记 int 数组 $dat_{i,j,k}$ 表示以面朝 $k$ 的状态到达点 $(i,j)$ 需要的最小代价。那么，根据上述两个数组，如果是第一次以面朝 $k$ 的状态到达点 $(i,j)$ ，则在 $fw_{i,j,k}$ 标记并同时记录 $dat_{i,j,k}$ 。如果不是第一次，则检查当前方案比 $dat_{i,j,k}$ 是否更优。如果更优，则允许重复搜索，更新状态。

按照上述方案，改进搜索，我们得到如下代码：

```cpp
while(!que.empty()){
		hd=que.top();
		que.pop();
		for(rgt i=0;i<4;i++){
			tl.p=(hd.p+i)%4;
			tl.x=hd.x+gx[tl.p];
			tl.y=hd.y+gy[tl.p];
			if(mp[tl.x][tl.y]!='.'){
				tl.val=make_pair(hd.val.first+dt[i],getdis(tl.x,tl.y));
				if(!fw[tl.x][tl.y][tl.p]){   
                //如果是第一次以面朝 p 的状态到达 (x,y) 标记并更新
					fw[tl.x][tl.y][tl.p]=true;
					dat[tl.x][tl.y][tl.p]=tl.val.first;
					que.push(tl);
				}else{
					if(dat[tl.x][tl.y][tl.p]>tl.val.first){
                    //如果当前状态比之前记录的方案更优，更新。
						dat[tl.x][tl.y][tl.p]=tl.val.first;
						que.push(tl);
					}
				}
			}
		}
	}
```

完善上述搜索代码和程序的其它部分可以得到 $\texttt{80}$ 分的好成绩。

--------

你会发现，你会有一个点 $\color{red}Wrong Answer$ ，这是怎么回事？

回去认真读题，会发现有这样的一句话：

**只有当前进、左转、右转都无路可走的时候，调头才是允许的。**

拿一个 bool 变量标记一下是否无路可走，如果无路可走再考虑掉头。

这样子做就可以满分了，最终的完整代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<queue> 
#define ll long long
#define qmn(a,b) a<b?a:b
#define rgt register int
using namespace std;

struct mode_queue{
	int x;
	int y;  //坐标
	int p;  //方向
	pair <int,int> val;  //first为花费,second为曼哈顿距离
}hd,tl;

char mp[33][33];
int n,m,edx,edy,ans=1e9+7;

bool fw[33][33][4];
int dat[33][33][4];
int gx[4]={0,-1,0,1};
int gy[4]={1,0,-1,0};
int dt[4]={0,1,10,5};

inline bool operator < (struct mode_queue q1,struct mode_queue q2){
	return q1.val.second>q2.val.second;
}

inline int abc(int c){
	return c<0?-c:c;
}  //绝对值

inline int getdis(int px,int py){
	return abc(px-edx)+abc(py-edy);
}  //算曼哈顿距离

priority_queue < mode_queue > que;

int main(){
	bool cx;
	scanf("%d%d",&n,&m);
	for(rgt i=1;i<=n;i++){
		for(rgt j=1;j<=m;j++){
			mp[i][j]=getchar();
			while((mp[i][j]<'A'||mp[i][j]>'Z')&&mp[i][j]!='.'&&mp[i][j]!='#')
				mp[i][j]=getchar();  //过滤其它字符
			if(mp[i][j]>='A'&&mp[i][j]<='Z'){
				if(mp[i][j]=='F'){  //找到终点，标记坐标
					edx=i;
					edy=j;
				}else{  //找到起点，入队
					tl.x=i;
					tl.y=j;
					tl.val=make_pair(0,getdis(i,j));
					switch(mp[i][j]){
						case 'E':tl.p=0; break;
						case 'N':tl.p=1; break;
						case 'W':tl.p=2; break;
						case 'S':tl.p=3; break;
					}
					fw[i][j][tl.p]=true;
					dat[i][j][tl.p]=0;
					que.push(tl);
				} 
			}
		}
	}
    
	while(!que.empty()){
		hd=que.top();
		que.pop();
		cx=false;  //标记是否无路可走
		for(rgt i=0;i<4;i++){
			if(i==2)  //去掉掉头的选择单独更新
				continue;
			tl.p=(hd.p+i)%4;
			tl.x=hd.x+gx[tl.p];
			tl.y=hd.y+gy[tl.p];
			if(mp[tl.x][tl.y]!='.'){
				cx=true;
				tl.val=make_pair(hd.val.first+dt[i],getdis(tl.x,tl.y));
				if(!fw[tl.x][tl.y][tl.p]){
					fw[tl.x][tl.y][tl.p]=true;
					dat[tl.x][tl.y][tl.p]=tl.val.first;
					que.push(tl);
				}else{
					if(dat[tl.x][tl.y][tl.p]>tl.val.first){
						dat[tl.x][tl.y][tl.p]=tl.val.first;
						que.push(tl);
					}
				}
			}
		}
		if(!cx){  //无路可走，单独更新掉头状态
			tl.p=(hd.p+2)%4;
			tl.x=hd.x+gx[tl.p];
			tl.y=hd.y+gy[tl.p];
			if(mp[tl.x][tl.y]!='.'){
				cx=true;
				tl.val=make_pair(hd.val.first+dt[2],getdis(tl.x,tl.y));
				if(!fw[tl.x][tl.y][tl.p]){
					fw[tl.x][tl.y][tl.p]=true;
					dat[tl.x][tl.y][tl.p]=tl.val.first;
					que.push(tl);
				}else{
					if(dat[tl.x][tl.y][tl.p]>tl.val.first){
						dat[tl.x][tl.y][tl.p]=tl.val.first;
						que.push(tl);
					}
				}
			}
		}
	}
    
	for(rgt i=0;i<4;i++){  //最后在终点的四个方向的最优状态中取最优解
		if(fw[edx][edy][i])
			ans=qmn(ans,dat[edx][edy][i]);
	} 
	printf("%d",ans);
	return 0;
}
```


---

## 作者：___w (赞：4)

### [P1300 城市街道交通费系统](https://www.luogu.com.cn/problem/P1300)

#### 简要题意
- 左转一次需付费 $1$ ，右转一次需付费 $5$ 。只有当前进、左转、右转都无路可走的时候，调头才是允许的，调头每次付费 $10$。
- 给出一张城市地图，要求你求出从起始点到达终止点的花费最少的路径。

#### 题目分析
注意到 $4\le h,w\le 30$，我们可以考虑暴搜。定义状态 $(x,y,w,s)$ 为当前的位置 $(x,y)$，方向 $w$ 和花费 $s$。我们可以给东南西北四个方向编个号，如下图所示，给了一个例子。

![图](https://cdn.luogu.com.cn/upload/image_hosting/5qd4ebm6.png)

那么方向数组就得按照编号来，这里以上图为准。

```cpp
d[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}}
```

转弯该怎么处理呢？我们发现左转为加 $1$ 后模 $4$；右转为加 $3$ 后模 $4$；而调头为加 $2$ 后模 $4$。原因是编号是按照逆时针来排的（当然顺时针也行）。

之后就好办了。对于当前一个状态 $(x,y,w,c)$，可以向前，向左，向右，向后拓展，要注意一些细节，具体看代码。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 35;
int n, m, sx, sy, sw, ans = 1e9, dis[N][N][4], d[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
char c[N][N];
void dfs(int x, int y, int w, int s) {
	if (dis[x][y][w] <= s || ans <= s) return;//最优性剪枝 
	dis[x][y][w] = s;
	if (c[x][y] == 'F') ans = min(ans, dis[x][y][w]);//到达终点，更新答案 
	bool flag = 0;
	if (c[x+d[w][0]][y+d[w][1]] != '.') flag = 1, dfs(x+d[w][0], y+d[w][1], w, s);
	//向前 
	if (c[x+d[(w+1)%4][0]][y+d[(w+1)%4][1]] != '.') flag = 1, dfs(x+d[(w+1)%4][0], y+d[(w+1)%4][1], (w+1)%4, s+1);
	//向左 
	if (c[x+d[(w+3)%4][0]][y+d[(w+3)%4][1]] != '.') flag = 1, dfs(x+d[(w+3)%4][0], y+d[(w+3)%4][1], (w+3)%4, s+5);
	//向右 
	if (!flag && c[x+d[(w+2)%4][0]][y+d[(w+2)%4][1]] != '.') dfs(x+d[(w+2)%4][0], y+d[(w+3)%4][1], (w+2)%4, s+10);
	//向后 
}
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) 
		for (int j = 1; j <= m; ++j) {
			cin >> c[i][j];
			if (c[i][j] == 'N') sx = i, sy = j, sw = 0;//起点，不必多说 
			if (c[i][j] == 'W')	sx = i, sy = j, sw = 1;
			if (c[i][j] == 'S')	sx = i, sy = j, sw = 2;
			if (c[i][j] == 'E')	sx = i, sy = j, sw = 3;
		}
	memset(dis, 0x3f, sizeof(dis));
	dfs(sx, sy, sw, 0);
	cout << ans;
	return 0;
}
```
[record](https://www.luogu.com.cn/record/113946270)。

---

## 作者：ZnHF (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P1300)

本题可以使用 DFS 算法解决。

有一下几点需要注意：

1. 进行适当的预处理，如预处理进行下一步操作时，对于当前面对的方向应该怎样进行移动和计费，~~否则您就会和作者一样写出巨长的代码~~。

2. 只有无法进行直行，左转，右转操作时，才能进行调头操作。

具体实现看代码：
```cpp
//代码中，使用1代替朝北，使用2代替朝南，使用3代替朝东，使用4代替朝西。
#include<bits/stdc++.h>
using namespace std;
int n,m,sx,sy,sz,ex,ey,vis[35][35][5],ans=0x3f3f3f3f;
char maze[35][35];
void dfs(int x,int y,int z,int sum){
	if(sum>=ans) return;//最优性剪枝。
	if(x==ex && y==ey){
		ans=min(ans,sum);
		return;
	}
	bool flag=0;//标记是否能进行调头操作，0表示可以，1表示不行。
        //对于每种朝向，分别进行处理。
	if(z==1){
		if(x-1>=0 && sum<vis[x-1][y][z] && maze[x-1][y]!='.'){
			flag=1;
			vis[x-1][y][z]=sum;
			dfs(x-1,y,z,sum);
		}
		if(y-1>=0 && sum+1<vis[x][y-1][4] && maze[x][y-1]!='.'){
			flag=1;
			vis[x][y-1][4]=sum+1;
			dfs(x,y-1,4,sum+1);
		}
		if(y+1<m && sum+5<vis[x][y+1][3] && maze[x][y+1]!='.'){
			flag=1;
			vis[x][y+1][3]=sum+5;
			dfs(x,y+1,3,sum+5);
		}
		if(!flag && x+1<n && sum+10<vis[x+1][y][2] && maze[x+1][y]!='.'){
			vis[x+1][y][2]=sum+10;
			dfs(x+1,y,2,sum+10);
		}
	}
	else if(z==2){
		if(x+1<n && sum<vis[x+1][y][z] && maze[x+1][y]!='.'){
			flag=1;
			vis[x+1][y][z]=sum;
			dfs(x+1,y,z,sum);
		}
		if(y+1<m && sum+1<vis[x][y+1][3] && maze[x][y+1]!='.'){
			vis[x][y+1][3]=sum+1;
			flag=1;
			dfs(x,y+1,3,sum+1);
		}
		if(y-1>=0 && sum+5<vis[x][y-1][4] && maze[x][y-1]!='.'){
			vis[x][y-1][4]=sum+5;
			flag=1;
			dfs(x,y-1,4,sum+5);
		}
		if(!flag && x-1>=0 && sum+10<vis[x-1][y][1] && maze[x-1][y]!='.'){
			vis[x-1][y][1]=sum+10;
			dfs(x-1,y,1,sum+10);
		}
	}
	else if(z==3){
		if(y+1<m && sum<vis[x][y+1][z] && maze[x][y+1]!='.'){
			flag=1;
			vis[x][y+1][z]=sum;
			dfs(x,y+1,z,sum);
		}
		if(x-1>=0 && sum+1<vis[x-1][y][1] && maze[x-1][y]!='.'){
			flag=1;
			vis[x-1][y][1]=sum+1;
			dfs(x-1,y,1,sum+1);
		}
		if(x+1<n && sum+5<vis[x+1][y][2] && maze[x+1][y]!='.'){
			vis[x+1][y][2]=sum+5;
			flag=1;
			dfs(x+1,y,2,sum+5);
		}
		if(!flag && y-1>=0 && sum+10<vis[x][y-1][4] && maze[x][y-1]!='.'){
			vis[x][y-1][4]=sum+10;
			dfs(x,y-1,4,sum+10);
		}
	}
	else if(z==4){
		if(y-1>=0 && sum<vis[x][y-1][z] && maze[x][y-1]!='.'){
			vis[x][y-1][z]=sum;
			flag=1;
			dfs(x,y-1,z,sum);
		}
		if(x+1<n && sum+1<vis[x+1][y][2] && maze[x+1][y]!='.'){
			vis[x+1][y][2]=sum+1;
			flag=1;
			dfs(x+1,y,2,sum+1);
		}
		if(x-1>=0 && sum+5<vis[x-1][y][1] && maze[x-1][y]!='.'){
			vis[x-1][y][1]=sum+5;
			flag=1;
			dfs(x-1,y,1,sum+5);
		}
		if(!flag && y+1<m && sum+10<vis[x][y+1][3] && maze[x][y+1]!='.'){
			vis[x][y+1][3]=sum+10;
			dfs(x,y+1,3,sum+10);
		}
	}
}
int main(){
	cin>>n>>m;
	memset(vis,0x3f,sizeof(vis));
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			cin>>maze[i][j];
                        //记录起点和朝向。
			if(maze[i][j]=='N'){
				sx=i;
				sy=j;
				sz=1;
			}
			if(maze[i][j]=='S'){
				sx=i;
				sy=j;
				sz=2;
			}
			if(maze[i][j]=='E'){
				sx=i;
				sy=j;
				sz=3;
			}
			if(maze[i][j]=='W'){
				sx=i;
				sy=j;
				sz=4;
			}
                        //记录终点。
			if(maze[i][j]=='F'){
				ex=i;
				ey=j;
			}
		}
	}
	dfs(sx,sy,sz,0);
	cout<<ans;
	return 0;
}
```
萌新的第五篇题解，如有不足请多谅解。

---

## 作者：tsqtsqtsq0309 (赞：2)

# P1300 城市街道交通费系统

## 题目大意

给定一张图，改变方向需要一定的花费，试找出一条路径使得花费最小，输出这个最小花费。

## 思路

首先注意到数据范围：对于 $100\%$ 的数据：$4 \leq h,w \leq 30$。可以考虑直接搜索求解。

首先需要预处理整张地图，可以令北、西、南、东分别为 $0$、$1$、$2$、$3$。设当前方向为 $z$，则易知左转、右转、掉头操作之后的方向分别为 $(z + 1) \bmod 4$，$(z + 3) \bmod 4$，$(z + 2) \bmod 4$，接下来就可以搜索了。搜索的同时可以顺便剪枝以降低时间复杂度，具体细节请看代码……

## 代码

```c++
#include <iostream>
#include <cstring>
#define MAXN 35
using namespace std;
int n, m, dx, dy, dz, ans = 998244353;
int d[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}}; // 移动坐标
int a[MAXN][MAXN], dis[MAXN][MAXN][4], tot;
char s[MAXN];
void dfs(int x, int y, int z, int c){
    if(dis[x][y][z] <= c || c >= ans)return; // 特判
    dis[x][y][z] = c;bool tmp = 0;
    if(a[x][y] == 2)ans = min(ans, c); // 更新答案
    if(a[x + d[z][0]][y + d[z][1]])tmp = 1, dfs(x + d[z][0], y + d[z][1], z, c); // 前进
    if(a[x + d[(z + 1) % 4][0]][y + d[(z + 1) % 4][1]]){tmp = 1;dfs(x + d[(z + 1) % 4][0], y + d[(z + 1) % 4][1], (z + 1) % 4, c + 1);} // 左转
    if(a[x + d[(z + 3) % 4][0]][y + d[(z + 3) % 4][1]]){tmp = 1;dfs(x + d[(z + 3) % 4][0], y + d[(z + 3) % 4][1], (z + 3) % 4, c + 5);} // 右转
    if(a[x + d[(z + 2) % 4][0]][y + d[(z + 2) % 4][1]]&&!tmp)dfs(x + d[(z + 2) % 4][0], y + d[(z + 2) % 4][1], (z + 2) % 4, c + 10); // 掉头
}
int main(){
    cin >> n >> m;
    for(int i = 1 ; i <= n ; i ++){
        cin >> s + 1;
        for(int j = 1 ; j <= m ; j ++){
            a[i][j] = 1;
            switch(s[j]){ // 预处理地图
                case '.':{a[i][j] = 0;break;}
                case '#':{break;}
                case 'F':{a[i][j] = 2;break;}
                case 'N':{dx = i;dy = j;dz = 0;break;}
                case 'W':{dx = i;dy = j;dz = 1;break;}
                case 'S':{dx = i;dy = j;dz = 2;break;}
                case 'E':{dx = i;dy = j;dz = 3;break;}
            }
        }
    }
    memset(dis, 114514, sizeof dis);
    dfs(dx, dy, dz, 0); // 搜索
    cout << ans << endl; // 输出最小花费
    return 0;
} // 完结撒花～～
```

---

## 作者：d0j1a_1701 (赞：2)

爆搜+优化

注意：**同一个地方只能转一次弯**

```cpp
#include <unordered_map>//C++11哈希表实现的map
#include <algorithm>
#include <iostream>
#include <cs​tring>
using namespace std;
const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1},inf=0x3f3f3f3f;
unorder​ed_map<char,int> char2digit = {{'N',0},{'S',2},{'E',1},{'W',3}};//字母方向转换成数字
unordered_map<int,char> digit2char = {{0,'N'},{2,'S'},{1,'E'},{3,'W'}};//数字方​向转换成字母（调试用）
int h,w,mem[40][40][4];//mem[i][j][k]:(i,j)处方向为k时的花费最小值
pair<int,int> from,to;
char mp[40][40];
inline int lturn(int x){//当前方向x左转90°后的方向
	int y = x - 1;
	return y==-1?3:y;
}
inline int rturn(int x){//当前方向x右转90°后的方向
	int y = x + 1;                                                                                                                                                                                                                                      																							                                                                                                           **反抄袭**
	return y==4?0:y;
}
inline int turnAround(int x){//当前方向x掉头后的方向
	int y = x + 2;
	return y % 4;
}
inline bool canWalkThrough(int x,int y,int dir){//当前位置(x,y)能否向dir方向移动一格
	return mp[x​+dx[dir]][y+dy[dir]]!='.';
}
void dfs(int x,int y,int cost,int dir){//大法师（误）x,y为当前坐标，cost为当前花费，dir为当前方向
	if(cost>=mem[x][y][​dir])	return;//剪枝
	mem[x][y][dir] = cost;//更新标记数组
	if(x==to.first&&y==to.second)	return;//如果到达终点直接返回（上一行已经保存最小花费）
	bool flag=false;
	if(canWalkThrough(x,y,dir))//如果能直走
		dfs(x+dx[dir],y+dy[dir],cost,dir),flag=true;//直走
	int l=lturn(dir),r=rturn(dir);
	if(canWalkThrough(x,y,l))//如果能左转
		dfs(x+dx[l],y+dy[l],cost+1,l),flag=true;//左转
	if(canWalkThrough(x,y,r))//如果能右转
		dfs(x+dx[r],y+dy[r],cost+5,r),flag=true;//右转
	if(!flag){//如果都不行
		int b​ack ​= turnAround(dir);
		dfs(x,y,cost+10,back);//掉头
	}
}
int main(){
	memset(mem,inf,sizeof(mem));//初始化
	cin >> h >> w;
	for(int i=1;i<=h;i++){
		for(int j=1;j<=w;j++){
			cin >> mp[i][j];
			if(isalph​a(mp[i][j])){
				if(mp[i][j]=='F')	to = {i,j};
				else	from = {i,j};
			}
		}
	}
	dfs(f​rom.first,from.second,0,char2digit[mp[from.first][from.second]]);
	cout << min(mem[to.first][to.second][0],min(mem[to.first][to.second][1],min(mem[to.​first][to.second][2],mem[to.first][to.second][3]))) << endl;//输出终点四个方向中的最小值
	return 0;
}
```


---

## 作者：pcktrsss (赞：2)

来一个效率低一点，但是思路稍微简单一点

最短路：

把1个点分成8个点，前4个分别表示没转向时的4个方向，后4个表示转向完了的

相邻的路块就从一个点转向完了的连到同方向另一个点没转向的那一层

每个点向左转向右转分别从没转向到转向完对应方向连1和5的边

然后每个点每个方向没转向到转向完连边权为0的边（可以不转向）

判断能不能调头，连10的边

源点连起点起始方向，终点所有方向连汇点

然后Dijkstra（本来就这么慢了不要用SPFA）

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
#define MAXN 999999
#define L(a,b) ((a-1)*m+b)
struct edge{
	int to,nxt,f;
}E[MAXN*2];
struct node{
	int dis,pos;
};
bool operator <(node a,node b){
	return b.dis<a.dis;
}
int head[MAXN],top=1;
void add(int x,int y,int f){
	E[top].to=y;
	E[top].nxt=head[x];
	E[top].f=f;
	head[x]=top++;
}
int n,m;
int base=n*m;
bool mp[31][31];
int sx,sy,sd,ex,ey;//分别是起点x,y,起点方向,终点x,y
int dist[MAXN];
int vis[MAXN];
priority_queue<node> qs;
void dijkstra(){
	int s=1;
    dist[s]=0;
    qs.push((node){0,s});
    while(!qs.empty()){
        node tmp=qs.top();
        qs.pop();
        int x=tmp.pos,d=tmp.dis;
        if(vis[x])continue;
        vis[x]=1;
        for(int i=head[x];i!=0;i=E[i].nxt ){
            int y=E[i].to;
            if(dist[y]>dist[x]+E[i].f){
                dist[y]=dist[x]+E[i].f;
                if(!vis[y])qs.push((node){dist[y],y});               
            }
        }
    }
}
int main(){
	scanf("%d%d",&n,&m);
	char inp[100];
	for(int i=1;i<=n;i++){
		scanf("%s",inp+1);
		for(int j=1;j<=m;j++){
			if(inp[j]=='.')mp[i][j]=1;
			else if(inp[j]=='S')sx=i,sy=j,sd=2;	
			else if(inp[j]=='N')sx=i,sy=j,sd=1;
			else if(inp[j]=='E')sx=i,sy=j,sd=4;
			else if(inp[j]=='W')sx=i,sy=j,sd=3;
			else if(inp[j]=='F')ex=i,ey=j;
		}
	}
    //分点设定:1-北 2-南 3-西 4-东 转向完:5-北 6-南 7-西 8-东
    //源点编号1，汇点编号2
	base=n*m;
	for(int i=1;i<=base*9;i++)dist[i]=0x3f3f3f3f;
	add(1,L(sx,sy)+sd*base,0);
	add(L(ex,ey)+base,2,0);
	add(L(ex,ey)+2*base,2,0);
	add(L(ex,ey)+3*base,2,0);
	add(L(ex,ey)+4*base,2,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[i][j]==0){
            	//与周围四个方向
				if(i!=1&&mp[i-1][j]==0)
				add(L(i,j)+5*base,L(i-1,j)+base,0);
				if(i!=n&&mp[i+1][j]==0)
				add(L(i,j)+6*base,L(i+1,j)+2*base,0);
				if(j!=1&&mp[i][j-1]==0)
				add(L(i,j)+7*base,L(i,j-1)+3*base,0);
				if(j!=m&&mp[i][j+1]==0)          
				add(L(i,j)+8*base,L(i,j+1)+4*base,0);
                //不转向
				add(L(i,j)+base,L(i,j)+5*base,0);
				add(L(i,j)+2*base,L(i,j)+6*base,0);
				add(L(i,j)+3*base,L(i,j)+7*base,0);
				add(L(i,j)+4*base,L(i,j)+8*base,0);
                //右转
				add(L(i,j)+base,L(i,j)+8*base,5);
				add(L(i,j)+2*base,L(i,j)+3*base,5);
				add(L(i,j)+3*base,L(i,j)+5*base,5);
				add(L(i,j)+4*base,L(i,j)+6*base,5);
                //左转
				add(L(i,j)+base,L(i,j)+7*base,1);
				add(L(i,j)+2*base,L(i,j)+8*base,1);
				add(L(i,j)+3*base,L(i,j)+6*base,1);
				add(L(i,j)+4*base,L(i,j)+5*base,1);
                //调头
				bool NB=(i==1||mp[i-1][j]==1);
				bool SB=(i==n||mp[i+1][j]==1);
				bool WB=(j==1||mp[i][j-1]==1);
				bool EB=(j==m||mp[i][j+1]==1);
				if(NB&&WB&&EB)add(L(i,j)+base,L(i,j)+6*base,10);
				if(EB&&NB&&SB)add(L(i,j)+4*base,L(i,j)+7*base,10);
				if(WB&&NB&&SB)add(L(i,j)+3*base,L(i,j)+8*base,10);
				if(SB&&WB&&EB)add(L(i,j)+2*base,L(i,j)+5*base,10);
			}
		}
	}
	dijkstra();
	int ans=dist[2];
	printf("%d",ans);
}
```


---

## 作者：SovietPower✨ (赞：2)

明显的搜索,但需要注意几个问题,尤其是方向判断

1.和记录步数不一样，要DFS

2.最优化剪枝:val数组

3.起点终点的初始化

4.至于方向判断,具体看代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=205;

int m,n,sx,sy,ex,ey,Ans=0x7fffffff;
int to[5]={1,0,-1,0,1};
//一个数组代替两个:xn=x+to[i],yn=y+to[i+1],建议画图模拟一下(当然写2个数组完全可以) 
//相当于 xto[4]={1,0,-1,0}
//         yto[4]={0,-1,0,1} 
// i =0 1 2 3
//to: S W N E
int val[N][N][5];
char c[N];
bool Can[N][N];

void DFS(int x,int y,int fac,int now)
{
    if(now>=val[x][y][fac]) return;//最优化剪枝 
    val[x][y][fac]=now;
//    printf("%d %d %d %d\n",x,y,fac,now);
    if(x==ex&&y==ey)
    {
        Ans=min(Ans,now);
        return;
    }
    for(int i=1;i<=n&&i<=m;i++)//先单独判断直走,因为步数不定 
    {
        int xx=x+to[fac]*i,yy=y+to[fac+1]*i;
        if(xx==ex&&yy==ey)
        {
            Ans=min(Ans,now);
            return;
        }
        if(xx<1||xx>n||yy<1||yy>m) break;//越界 
        if(!Can[xx][yy]) break;//遇到障碍,直接break 
//        printf("%d %d -> %d %d fac:%d now:%d\n",x,y,xx,yy,fac,now);
        DFS(xx,yy,fac,now);
    }
    for(int i=0;i<4;i++)
    {
        if(i==fac) continue;//方向与当前方向一致,即直走,在前面已经判断过,跳过 
        int xx=x+to[i],yy=y+to[i+1];
        if(xx<1||xx>n||yy<1||yy>m) continue;
        if(!Can[xx][yy]) continue;
        if(fac-i==1||(fac==0)&&i==3)//左转时的情况,模拟一下不难得出 
          DFS(xx,yy,i,now+1);
        else if(i-fac==1||(i==0&&fac==3))//右转 
          DFS(xx,yy,i,now+5);
        else if(!Can[x+to[(fac-1+4)%4]][y+to[fac]])//要求左转. 
          if(!Can[x+to[(fac-3+4)%4]][y+to[(fac-2+4)%4]])//右转 
          if(!Can[x+to[fac]][y+to[(fac+1)%4]])//直行不行时,才能掉头 
            DFS(xx,yy,i,now+10);
        //注意+4取模 
        //trun left: x+to[f-1],y+to[f]
        //trun right: x+to[f-3],y+to[f-2]
        //go stright: x+to[f],y+to[f+1]
    }
}

int main()
{
//    freopen("erp.in","r",stdin);
//    freopen("erp.out","w",stdout);
    scanf("%d%d",&n,&m);
    int face;
    memset(val,0x3f,sizeof val);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",c+1);
        for(int j=1;j<=m;j++)
        {
            switch(c[j])
            {
                case '#':Can[i][j]=1;break;
                case 'E':face=3,sx=i,sy=j;break;
                case 'S':face=0,sx=i,sy=j;break;
                case 'W':face=1,sx=i,sy=j;break;
                case 'N':face=2,sx=i,sy=j;break;
                case 'F':ex=i,ey=j;break;
            }
        }
    }
//    printf("sx:%d sy:%d ex:%d ey:%d face:%d\n",sx,sy,ex,ey,face);
    Can[sx][sy]=1;//起点终点这个位置是可以走的 
    Can[ex][ey]=1;
    DFS(sx,sy,face,0);
    printf("%d",Ans);
    return 0;
}
```

---

## 作者：ｃｈｉｌｌ (赞：2)

私以为这道题不应该是紫色难度。

一个过程略为繁琐的搜索再加上简单的剪枝即可AC。

可以用一个三维数组f[i][j][k]表示走到i行j列且当前方向为k时的最小花费。

剪枝条件：假如当前花费cost>=f[i][j][k]，退出过程。
需要注意的有两点：

1、判断向左右后转时的方向，可以用vx[]和vy[]存储东南西北，向左右后转可以看成分别向右转3、1、2次。

2、同一个位置中不能转动多次，进行转动时应直接调用转动、前进之后的状态。
附上代码：


```cpp
#include <bits/stdc++.h>
using namespace std;

int vx[4]={0,1,0,-1};
int vy[4]={1,0,-1,0};//分别代表方向东南西北
int n,m,sx,sy,tx,ty,v,ans,f[31][31][4];
char c[31][31];

bool ok(int x,int y)//判断当前坐标是否越界、是否通路
{
    if (x<1||x>n||y<1||y>m) return 0;
    if (c[x][y]=='.') return 0;
    return 1;
}

void go(int x,int y,int v,int cost)
{
    if (cost>=f[x][y][v]) return;//剪枝
    f[x][y][v]=cost;
    if (x==tx&&y==ty)//满足条件，直接退出
        {
            if (cost<ans) ans=cost;
            return;
        }
    int xx,yy,rx,ry,bx,by,lx,ly;
    xx=x+vx[v];yy=y+vy[v];//直着移动一步
    rx=x+vx[(v+1)%4];ry=y+vy[(v+1)%4];//右转移动一步
    bx=x+vx[(v+2)%4];by=y+vy[(v+2)%4];//后转移动一步
    lx=x+vx[(v+3)%4];ly=y+vy[(v+3)%4];//左转移动一步
    if (ok(xx,yy)) go(xx,yy,v,cost);//直走
    if (ok(lx,ly)) go(lx,ly,(v+3)%4,cost+1);//左转
    if (ok(rx,ry)) go(rx,ry,(v+1)%4,cost+5);//右转
    if (!ok(xx,yy)&&!ok(lx,ly)&&!ok(rx,ry)&&ok(bx,by)) go(bx,by,(v+2)%4,cost+10);
    //当前三种情况无路可走时后转
}

int main()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            {
                cin>>c[i][j];
                if (c[i][j]!='#'&&c[i][j]!='.')
                    {
                        if (c[i][j]=='E') v=0;
                        if (c[i][j]=='S') v=1;
                        if (c[i][j]=='W') v=2;
                        if (c[i][j]=='N') v=3;//v指初始方向
                        if (c[i][j]=='F') tx=i,ty=j;
                                     else sx=i,sy=j;
                    }
            }
    memset(f,0x3f,sizeof f);
    ans=1<<20;
    go(sx,sy,v,0);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Deamer (赞：1)

为什么都是爆搜加剪枝啊，来水一篇简洁的 Dij 最短路题解。

这道题考虑最短路，发现汽车当前的方向需要记录，还需要考虑转弯以后的方向，坐标和花费，剩下的就是板子了。

注意到边权非负且是稀疏图，所以我用的是堆优化 Dijkstra。

我们发现转弯以后的方向和花费不好处理，我们由 4 连通图的方向数组受到启发，用两个数组分别来记录每个方向转弯后的坐标变化和方向变化，再用一个数组记录不同方向转弯的花费，这样在代码中就可以不用繁琐的分类讨论了。

~~readers : Talking is cheap , show me the code .~~

**最后说一下注意事项：**

- 掉头只有其他方向都不能走的情况下才能进行，需要特判一下。

- 一个位置车的方向不同为不同情况，所以一些数组需要记录当前行，列，和方向。

- 由于车最后到终点方向不确定，所以要比较一下到终点每个方向最小花费的最小值。

剩下的代码里说吧。

##  _Code :_ 


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50;
const int INF=0x7f7f7f7f;
int n,m,sx,sy,sd,tx,ty;
char a[N][N];
int vis[N][N][4],dis[N][N][5];
int fx[4][4]={{0,-1,1,0},{0,1,-1,0},{1,0,0,-1},{-1,0,0,1}};	//东西南北 前，左，右，掉头的行变化
int fy[4][4]={{1,0,0,-1},{-1,0,0,1},{0,1,-1,0},{0,-1,1,0}};	//东西南北 前，左，右，掉头的列变化
int fd[4][4]={{0,3,2,1},{1,2,3,0},{2,0,1,3},{3,1,0,2}};	//东西南北 前，左，右，掉头的方向变化
int fw[4]={0,1,5,10};	//前，左，右，掉头的花费
int ans=INF;

bool chck(int x,int y,int d){
	if(x<0 || x>n || y<0 || y>m || a[x][y]=='.' || vis[x][y][d]) return false;
	return true;
}

struct node{
	int x,y,d,dis;
	bool operator < (const node &x) const{
		return dis > x.dis ;
	}
};

void BFS(){
	priority_queue<node>q;
	memset(dis,INF,sizeof(dis));
	dis[sx][sy][sd]=0;
	q.push((node){sx,sy,sd,dis[sx][sy][sd]});
	while(!q.empty()){
		node u=q.top(); q.pop();
		int x=u.x,y=u.y,d=u.d;
		if(vis[x][y][d]) continue;
		vis[x][y][d]=1;
		int flag=0;					//记录有没有方向能走
		for(int i=0;i<4;i++){
			int nx=x+fx[d][i],ny=y+fy[d][i],nd=fd[d][i],w=fw[i];
			if((i<3 && chck(nx,ny,nd)) || (!flag && chck(nx,ny,nd))){	//特判掉头
				flag=1;
				if(dis[nx][ny][nd]>dis[x][y][d]+w){
					dis[nx][ny][nd]=dis[x][y][d]+w;
					q.push((node){nx,ny,nd,dis[nx][ny][nd]});
				}
			}
		}
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			//记录起点和终点的坐标以及起点的方向
			if(a[i][j]=='E') sx=i,sy=j,sd=0;
			else if(a[i][j]=='W') sx=i,sy=j,sd=1;
			else if(a[i][j]=='S') sx=i,sy=j,sd=2;
			else if(a[i][j]=='N') sx=i,sy=j,sd=3;
			else if(a[i][j]=='F') tx=i,ty=j;
		}
	}
	BFS();
	for(int i=0;i<4;i++) ans=min(ans,dis[tx][ty][i]);	//取每个方向结束的最小花费的最小值
	printf("%d\n",ans);
	return 0;
}
```
[完结撒花！！！](https://www.luogu.com.cn/record/121729033)

由于是 Dij 最短路，所以顺理成章的拿到了最优解。

---

## 作者：ccg12345 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1300)

## 思路

注意到数据范围：$4 \le h,w \le 30$，于是想到可以搜索，我用的是 dfs，那么我们定义状态 $(x,y,z,cnt)$，其中 $(x,y)$ 是当时的位置，$z$ 为方向，当时已消耗 $cnt$，然后我们考虑向四个方向行动。前行，左拐，右拐不难得出代码，现在我们考虑掉头，注意到题面中的一句话：`只有当前进、左转、右转都无路可走的时候，调头才是允许的。`，这样的话我们就需要提前定义一个 $flag$，将其初始化为 $0$，然后若可向其余三个方向行动就将 $flag$ 设为 $1$，最终判断其是否为 $0$ 即可。

## 注意点

 1.关于最优性的小剪枝：当 $cnt$ 已大于之前的最优答案或所在点 $(x,y)$ 之前最优的 $val_{x,y}$，直接退出。
 
 2.开始搜索的点：也是一个小易错点，这个看代码就好。
 
附代码：

```
#include <bits/stdc++.h>
using namespace std;
int h, w, dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1}, val[35][35][4], ans = 0x3f3f3f3f;
char ch[35][35];
int min(int a, int b)
{
	return (a < b ? a : b);
}
void dfs(int x, int y, int z, int cnt)
{
	int t;
	bool flag;
	if(cnt >= min(val[x][y][z], ans))
		return ;
	val[x][y][z] = cnt, flag = false;
	if(ch[x][y] == 'F')
		ans = min(ans, val[x][y][z]);
	if(ch[x + dx[z]][y + dy[z]] != '.')
		flag = 1, dfs(x + dx[z], y + dy[z], z, cnt);
	t = (z + 1) % 4; 
	if(ch[x + dx[t]][y + dy[t]] != '.')
		flag = 1, dfs(x + dx[t], y + dy[t], t, cnt + 1);
	t = (z + 3) % 4;
	if(ch[x + dx[t]][y + dy[t]] != '.')
		flag = 1, dfs(x + dx[t], y + dy[t], t, cnt + 5);
	t = (z + 2) % 4;
	if(!flag && ch[x + dx[t]][y + dy[t]] != '.')
		dfs(x + dx[t], y + dy[t], t, cnt + 10);
}
int main()
{
	int n, m, a, b, c;
	memset(val, ans, sizeof(val)); 
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
		{
			cin >> ch[i][j];
			if(ch[i][j] == 'N')
				a = i, b = j, c = 0;
			if(ch[i][j] == 'W')
				a = i, b = j, c = 1;	
			if(ch[i][j] == 'S')
				a = i, b = j, c = 2;
			if(ch[i][j] == 'E')
				a = i, b = j, c = 3;		
		} 
	dfs(a, b, c, 0);
	cout << ans << endl;
}
```

---

## 作者：Supor__Shoep (赞：0)

我可称之为大模拟！

首先看到数据范围，不难想到使用大型 BFS。我们定义一个状态 $x$ 包括当前方向，当前坐标以及到达当前位置的答案。那么我们可以根据给出的方向将其转化为数字 $1\sim 4$，接着找到终点坐标，起点坐标和初始方向，给优先队列定义第一个状态。

然后我们沿着当前方向一直走到尽头，但是如果直接走的话就会忽略掉中间的转折点，也就是可以左转或者右转的点，因此在循环的过程当中，我们需要判断当前左右两边是否有转折，如果有，就给队列添加一个新的状态。最后走到了尽头，我们不得不进行调头操作，所以还需要再添加一个新的状态，将方向取反。值得注意的是，由于终点可能会在一条路的中间，所以我们还需要进行一个终点判断，如果找到终点，就直接输出答案。

你自信满满地交了这个代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 35;
int n, m;
char s[MAXN][MAXN];
int ex, ey;
struct node {
    int fl, nx, ny, x;
    bool operator<(const node &f) const {
        return x != f.x ? x > f.x : abs(nx - ex) + abs(ny - ey) > abs(f.nx - ex) + abs(f.ny - ey);
    }
};
priority_queue<node> que;
int vis[MAXN][MAXN];
void bfs() {
    int flag = 0, sx = 0, sy = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s[i][j] == 'E' || s[i][j] == 'W' || s[i][j] == 'N' || s[i][j] == 'S') {
                if (s[i][j] == 'E')
                    flag = 1;
                if (s[i][j] == 'W')
                    flag = 2;
                if (s[i][j] == 'N')
                    flag = 3;
                if (s[i][j] == 'S')
                    flag = 4;
                sx = i, sy = j;
            }
            if (s[i][j] == 'F')
                ex = i, ey = j;
        }
    }
    que.push((node){ flag, sx, sy, 0 });
    while (!que.empty()) {
        node t = que.top();
        que.pop();
        if (t.nx == ex && t.ny == ey) {
            cout << t.x;
            return;
        }
        if (vis[t.nx][t.ny]) 
        	continue;
        vis[t.nx][t.ny] = 1;
        int nx = t.nx, ny = t.ny;
        if (t.fl == 1) {
            while (ny <= m && s[nx][ny] != '.') {
                if (nx == ex && ny == ey) {
                    cout << t.x;
                    return;
                }
                if (nx > 1 && s[nx - 1][ny] != '.')
                    que.push((node){ 3, nx - 1, ny, t.x + 1 });
                if (nx < n && s[nx + 1][ny] != '.')
                    que.push((node){ 4, nx + 1, ny, t.x + 5 });
                ny++;
            }
            ny--;
            if (s[nx + 1][ny] == '.' && s[nx - 1][ny] == '.')
                que.push((node){ 2, nx, ny, t.x + 10 });
        } else if (t.fl == 2) {
            while (ny >= 1 && s[nx][ny] != '.') {
                if (nx == ex && ny == ey) {
                    cout << t.x;
                    return;
                }
                if (nx > 1 && s[nx - 1][ny] != '.')
                    que.push((node){ 3, nx - 1, ny, t.x + 5 });
                if (nx < n && s[nx + 1][ny] != '.')
                    que.push((node){ 4, nx + 1, ny, t.x + 1 });
                ny--;
            }
            ny++;
            if (s[nx + 1][ny] == '.' && s[nx - 1][ny] == '.')
                que.push((node){ 1, nx, ny, t.x + 10 });
        } else if (t.fl == 3) {
            while (nx >= 1 && s[nx][ny] != '.') {
                if (nx == ex && ny == ey) {
                    cout << t.x;
                    return;
                }
                if (ny > 1 && s[nx][ny - 1] != '.')
                    que.push((node){ 2, nx, ny - 1, t.x + 1 });
                if (ny < m && s[nx][ny + 1] != '.')
                    que.push((node){ 1, nx, ny + 1, t.x + 5 });
                nx--;
            }
            nx++;
            if (s[nx][ny + 1] == '.' && s[nx][ny - 1] == '.')
                que.push((node){ 4, nx, ny, t.x + 10 });
        } else {
            while (nx <= n && s[nx][ny] != '.') {
                if (nx == ex && ny == ey) {
                    cout << t.x;
                    return;
                }
                if (ny > 1 && s[nx][ny - 1] != '.')
                    que.push((node){ 2, nx, ny - 1, t.x + 5 });
                if (ny < m && s[nx][ny + 1] != '.')
                    que.push((node){ 1, nx, ny + 1, t.x + 1 });
                nx++;
            }
            nx--;
            if (s[nx][ny + 1] == '.' && s[nx][ny - 1] == '.')
                que.push((node){ 3, nx, ny, t.x + 10 });
        }
    }
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) cin >> s[i][j];
    }
    bfs();
    return 0;
}
```

然后你只有 $80$ 分，答案错误了，此时你又聪明地删掉了 vis 数组，因为方向不同，走过的点重复了可能答案会更优。

但是会 MLE。

所以就有了最后的思路，给 vis 数组里面储存当前点的最优答案，如果当前状态的答案大于对应 vis 的答案，那么肯定是不行的。反之就更新 vis 的值，这样就会减少一些确定不行的状态。

最终代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 35;
int n, m;
char s[MAXN][MAXN];
int ex, ey;
struct node {
    int fl, nx, ny, x;
    bool operator<(const node &f) const {
        return x > f.x;
    }
};
priority_queue<node> que;
int vis[MAXN][MAXN];
void bfs() {
    int flag = 0, sx = 0, sy = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s[i][j] == 'E' || s[i][j] == 'W' || s[i][j] == 'N' || s[i][j] == 'S') {
                if (s[i][j] == 'E')
                    flag = 1;
                if (s[i][j] == 'W')
                    flag = 2;
                if (s[i][j] == 'N')
                    flag = 3;
                if (s[i][j] == 'S')
                    flag = 4;
                sx = i, sy = j;
            } else if (s[i][j] == 'F')
                ex = i, ey = j;
        }
    }
    que.push((node){ flag, sx, sy, 0 });
    while (!que.empty()) {
        node t = que.top();
        que.pop();
        if (t.nx == ex && t.ny == ey) {
            cout << t.x;
            return;
        }
        if (vis[t.nx][t.ny] && t.x > vis[t.nx][t.ny])
            continue;
        vis[t.nx][t.ny] = t.x;
        int nx = t.nx, ny = t.ny;
        if (t.fl == 1) {
            while (ny <= m && s[nx][ny] != '.') {
                if (nx == ex && ny == ey) {
                    cout << t.x;
                    return;
                }
                if (nx > 1 && s[nx - 1][ny] != '.')
                    que.push((node){ 3, nx - 1, ny, t.x + 1 });
                if (nx < n && s[nx + 1][ny] != '.')
                    que.push((node){ 4, nx + 1, ny, t.x + 5 });
                ny++;
            }
            ny--;
            if (s[nx + 1][ny] == '.' && s[nx - 1][ny] == '.')
                que.push((node){ 2, nx, ny, t.x + 10 });
        } else if (t.fl == 2) {
            while (ny >= 1 && s[nx][ny] != '.') {
                if (nx == ex && ny == ey) {
                    cout << t.x;
                    return;
                }
                if (nx > 1 && s[nx - 1][ny] != '.')
                    que.push((node){ 3, nx - 1, ny, t.x + 5 });
                if (nx < n && s[nx + 1][ny] != '.')
                    que.push((node){ 4, nx + 1, ny, t.x + 1 });
                ny--;
            }
            ny++;
            if (s[nx + 1][ny] == '.' && s[nx - 1][ny] == '.')
                que.push((node){ 1, nx, ny, t.x + 10 });
        } else if (t.fl == 3) {
            while (nx >= 1 && s[nx][ny] != '.') {
                if (nx == ex && ny == ey) {
                    cout << t.x;
                    return;
                }
                if (ny > 1 && s[nx][ny - 1] != '.')
                    que.push((node){ 2, nx, ny - 1, t.x + 1 });
                if (ny < m && s[nx][ny + 1] != '.')
                    que.push((node){ 1, nx, ny + 1, t.x + 5 });
                nx--;
            }
            nx++;
            if (s[nx][ny + 1] == '.' && s[nx][ny - 1] == '.')
                que.push((node){ 4, nx, ny, t.x + 10 });
        } else {
            while (nx <= n && s[nx][ny] != '.') {
                if (nx == ex && ny == ey) {
                    cout << t.x;
                    return;
                }
                if (ny > 1 && s[nx][ny - 1] != '.')
                    que.push((node){ 2, nx, ny - 1, t.x + 5 });
                if (ny < m && s[nx][ny + 1] != '.')
                    que.push((node){ 1, nx, ny + 1, t.x + 1 });
                nx++;
            }
            nx--;
            if (s[nx][ny + 1] == '.' && s[nx][ny - 1] == '.')
                que.push((node){ 3, nx, ny, t.x + 10 });
        }
    }
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) cin >> s[i][j];
    }
    bfs();
    return 0;
}
```

---

## 作者：wwwwwza (赞：0)

这道题主要考察的是搜索和剪枝。于是我用了深度优先搜索加记忆化剪枝。  
首先将各种特殊点标记出来，将答案数组初始化为最大值。
其次，开始深搜。不过要先剪枝，将较差的情况排除。  
然后，往前、左、右三个方向搜索，如果三个方向都没法走，才可以掉头。  
最后，输出结果。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int xx[4]={-1,0,1,0},yy[4]={0,-1,0,1},v[4]={0,1,10,5};
int n,m,enx,eny,stx,sty,turn,dist[32][32][4],ans=1e9;
char ch;
bool vis[32][32];
void dfs(int x,int y,int turn,int sum){//dfs
	if(dist[x][y][turn]<=sum||sum>=ans)return;
	dist[x][y][turn]=sum;
	if(x==enx&&y==eny)ans=min(ans,dist[x][y][turn]);
	bool flag=0;
	for(int i=0;i<=4;i++){
		if(i==2)continue;
		if(i==4)i-=2;
		int Turn=(turn+i)%4,nx=x+xx[Turn],ny=y+yy[Turn];
		if(vis[nx][ny]&&i!=2){
			flag=1;
			dfs(nx,ny,Turn,sum+v[i]);
		}else if(i==2&&vis[nx][ny]&&!flag){//判是否掉头 
			dfs(nx,ny,Turn,sum+10);
			break;
		}else if(i==2){
			break;
		}
	}
	return;
}
signed main(){
	cin >>n>>m;
	memset(dist,127,sizeof(dist));//初始化
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin >>ch;
			vis[i][j]=1;
			if(ch=='F'){//标记特殊点
				enx=i;eny=j;
			}else if(ch=='E'){
				stx=i;sty=j;turn=3;
			}else if(ch=='W'){
				stx=i;sty=j;turn=1;
			}else if(ch=='N'){
				stx=i;sty=j;turn=0;
			}else if(ch=='S'){
				stx=i;sty=j;turn=2;
			}else if(ch=='.'){
				vis[i][j]=0;
			}
		}
	}
	dfs(stx,sty,turn,0);//dfs
	cout <<ans;
	return 0;
}
```

---

## 作者：lzyqwq (赞：0)

说实话，这题我们可以大模拟 BFS，这是最~~笨~~直观的方法了。

用 $dis[i][j][k]$ 表示到 $(i,j)$ 的点面向 $k$ 的方向用的最短路。由于我懒，所以 $k$ 里面直接放字符。我们用 E、S、W、N 来表示东、南、西、北。由于小写 a 的 ASCII 值为 $97$，所以大写字母的 ASCII 值肯定不超过 $97$，所以我给 $dis$ 数组的第三维开了 $100$。

对于每一个点，我们判断它当前的方向，并根据方向推出它前进到哪里、左转到哪里、右转到哪里、掉头到哪里。注意，左转是改变方向并且**到达它左边的点**，右转是**改变方向并到达它右边的点**，掉头时改变方向**并到达它后面的点**，所以转弯的时候相应的坐标要 $+1$ 或 $-1$。蒟蒻语文太差被坑了好久。然后判断当前走法花费是否比之前的最小花费小。如果小就更新。为了方便讲述模拟过程，先把十字方向标放上来。

![](https://cdn.luogu.com.cn/upload/image_hosting/015xqdml.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

对于点 $(x,y,\text{E})$，前进会到达点 $(x,y+1,\text{E})$；左转会到达点 $(x-1,y,\text{N})$；右转会到达点 $(x+1,y,\text{S})$；掉头会到达点 $(x,y-1,\text{W})$。

对于点 $(x,y,\text{S})$，前进会到达点 $(x+1,y,\text{S})$；左转会到达点 $(x,y+1,\text{E})$；右转会到达点 $(x,y-1,\text{W})$；掉头会到达点 $(x-1,y,\text{N})$。

对于点 $(x,y,\text{W})$，前进会到达点 $(x,y-1,\text{W})$；左转会到达点 $(x+1,y,\text{S})$；右转会到达点 $(x-1,y,\text{N})$；掉头会到达点 $(x,y+1,\text{E})$。

对于点 $(x,y,\text{N})$，前进会到达点 $(x-1,y,\text{N})$；左转会到达点 $(x,y-1,\text{W})$；右转会到达点 $(x,y+1,\text{E})$；掉头会到达点 $(x+1,y,\text{S})$。

我们发现，左转、右转；前进、掉头的坐标恰恰相反。南、北；东、西的走法也正好相反。

由于此题范围很小，所以我们不需要像楼上的 dalao 一样用优先队列，尽管重复进队了效率略低也没有关系。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 35
struct pos
{
	int x,y,c;//x,y表示坐标，c表示花费
	char d;//表示方向
};
queue<pos>q;
char ma[N][N];//地图
int dis[N][N][100];//范围上面解释过了
int main()
{
	memset(dis,0x3f,sizeof(dis));//初始化成无穷大
	int n,m;
	scanf("%d%d",&n,&m);
	int tx,ty;//终点
	for(int i=1;i<=n;i++)
	{
		scanf("%s",ma[i]+1);//把字符数组的一行当作字符串来读，由于习惯从下标1开始，所以要+1
		for(int j=1;j<=m;j++)
		{
			if(ma[i][j]=='E'||ma[i][j]=='S'||ma[i][j]=='W'||ma[i][j]=='N')//找到起点
			{
				dis[i][j][ma[i][j]]=0;//起点花费为0
				q.push(pos{i,j,0,ma[i][j]});//起点入队
			}
			if(ma[i][j]=='F')//找到终点
			{
				tx=i;//记录坐标
				ty=j;
			}
		}
	}
	while(q.size())//BFS
	{
		pos t=q.front();//取出队头
		q.pop();
		int x=t.x,y=t.y,c=t.c;
		char d=t.d;
		bool k=0;//掉头之前的操作是否能做，如果能做就不能掉头
		if(d=='E')//如果面向东方，到达的点上面都说过了。这里的注释到其他三个方向仍然适用，其他三个方向不再赘述
		{
			if(ma[x][y+1]!='.'&&c<dis[x][y+1][d])//前进，如果不是障碍且更优就入队。c后面改成<=也行，就是=时之前一样的已经进过队扩展过了，再求一遍扩展的还是一样的，再重复做一遍就没意义了
			{
				q.push(pos{x,y+1,c,d});
				dis[x][y+1][d]=c;
				k=1;
			}
			if(c+1<dis[x-1][y]['N']&&ma[x-1][y]!='.')//左转，如果更优且不是障碍就入队
			{
				q.push(pos{x-1,y,c+1,'N'});
				dis[x-1][y]['N']=c+1;
				k=1;
			}
			if(c+5<dis[x+1][y]['S']&&ma[x+1][y]!='.')//右转，如果更优且不是障碍就入队
			{
				q.push(pos{x+1,y,c+5,'S'});
				dis[x+1][y]['S']=c+5;
				k=1;
			}
			if(!k&&c+10<dis[x][y-1]['W']&&ma[x][y-1]!='.')//掉头，如果之前的都不能做并且如果更优、不是障碍就入队
			{
				q.push(pos{x,y-1,c+10,'W'});
				dis[x][y-1]['W']=c+10; 
			}
		}
		if(d=='S')//如果面向南方
		{
			if(ma[x+1][y]!='.'&&c<=dis[x+1][y][d])
			{
				q.push(pos{x+1,y,c,d});
				dis[x+1][y][d]=c;
				k=1;
			}
			if(c+1<=dis[x][y+1]['E']&&ma[x][y+1]!='.')
			{
				q.push(pos{x,y+1,c+1,'E'});
				dis[x][y+1]['E']=c+1;
				k=1;
			}
			if(c+5<=dis[x][y-1]['W']&&ma[x][y-1]!='.')
			{
				q.push(pos{x,y-1,c+5,'W'});
				dis[x][y-1]['W']=c+5;
				k=1;
			}
			if(!k&&c+10<=dis[x-1][y]['N']&&ma[x-1][y]!='.')
			{
				q.push(pos{x-1,y,c+10,'N'});
				dis[x-1][y]['N']=c+10; 
			}
		}
		if(d=='W')//如果面向西方
		{
			if(ma[x][y-1]!='.'&&c<=dis[x][y-1][d])
			{
				q.push(pos{x,y-1,c,d});
				dis[x][y-1][d]=c;
				k=1;
			}
			if(c+1<=dis[x+1][y]['S']&&ma[x+1][y]!='.')
			{
				q.push(pos{x+1,y,c+1,'S'});
				dis[x+1][y]['S']=c+1;
				k=1;
			}
			if(c+5<=dis[x-1][y]['N']&&ma[x-1][y]!='.')
			{
				q.push(pos{x-1,y,c+5,'N'});
				dis[x-1][y]['N']=c+5;
				k=1;
			}
			if(!k&&c+10<=dis[x][y+1]['E']&&ma[x][y+1]!='.')
			{
				q.push(pos{x,y+1,c+10,'E'});
				dis[x][y+1]['E']=c+10; 
			}
		}
		if(d=='N')//如果面向北方
		{
			if(ma[x-1][y]!='.'&&c<=dis[x-1][y][d])
			{
				q.push(pos{x-1,y,c,d});
				dis[x-1][y][d]=c;
				k=1;
			}
			if(c+1<=dis[x][y-1]['W']&&ma[x][y-1]!='.')
			{
				q.push(pos{x,y-1,c+1,'W'});
				dis[x][y-1]['W']=c+1;
				k=1;
			}
			if(c+5<=dis[x][y+1]['E']&&ma[x][y+1]!='.')
			{
				q.push(pos{x,y+1,c+5,'E'});
				dis[x][y+1]['E']=c+5;
				k=1;
			}
			if(!k&&c+10<=dis[x+1][y]['S']&&ma[x+1][y]!='.')
			{
				q.push(pos{x+1,y,c+10,'S'});
				dis[x+1][y]['S']=c+10; 
			}
		}
	}
	printf("%d\n",min(dis[tx][ty]['E'],min(dis[tx][ty]['S'],min(dis[tx][ty]['W'],dis[tx][ty]['N']))));//到达终点的四种方向中，选择花费最少的
	return 0;
} 
```

---

## 作者：翼德天尊 (赞：0)

## 一、前奏

### 地图题-->搜索！

考虑采用 $\text{dfs}$ 的方法来做这道题，下面讲讲我的思路。

对于这道题，我们将每个状态定义为三个元素：$x$ 坐标，$y$ 坐标以及方向。

首先读入地图，提取初始点的状态（三元素），然后开始 $\text{dfs}$。

## 二、搜索部分

#### 关于延伸状态

由题意，一共有四种行走方式：

1. 以原有的方向，向前走一步，花费 $0$。

2. 以左转后的方向，向前走一步，花费 $1$。

3. 以右转后的方向，向前走一步，花费 $5$。

4. **在前面三种方式都不行的前提下**，以相反的方向，向前走一步，花费 $10$。

在将四种方式都转化为向前走一步之后，我们发现四种方式唯一不同的地方就在于方向，于是我们只需要改变方向向前走不断向下延伸状态即可。

#### 关于结束条件

当该坐标上的符号为 `F` 时，更新最小答案，返回上一状态。所有状态延伸完后，返回主程序。

#### 关于优化

1. 为了防止重复走到一个状态，我们可以设置一个 $minn$ 数组表示到每一个**状态**的最小值（注意是状态，不是点！因为到达每一个点时的方向可能是不同的），每次到达一个状态时，如果该状态的 $minn$ 值已经**小于等于**现在的值，那么就返回上一状态（注意是小于等于，小于的话就会造成许多不必要的路径，导致 $\text{TLE}$）。

2. 如果目前的值已经**大于等于**目前的答案，就返回上一状态（会比“大于”快 $2$ $\text{ms}$）

## 三、AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 50
#define INF 2147483647
int n,m,bx,by,bf,minn[N][N][4],ans=INF;//注意初始值
char ma[N][N];
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};//节省码量
int read(){
	int w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c<='9'&&c>='0'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
void dfs(int x,int y,int f,int now){
	if (ma[x][y]=='F'){
		ans=min(ans,now);
		return;
	}
	if (now>=minn[x][y][f]||now>=ans) return;
	minn[x][y][f]=now;
	bool pd=1;
	for (int i=0;i<4;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if (f==i&&ma[xx][yy]!='.'&&xx>=1&&xx<=n&&yy>=1&&yy<=m)
			dfs(xx,yy,f,now),pd=0;
	}
	f=(f+1)%4;
	for (int i=0;i<4;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if (f==i&&ma[xx][yy]!='.'&&xx>=1&&xx<=n&&yy>=1&&yy<=m)
			dfs(xx,yy,f,now+5),pd=0;
	}
	f=(f+6)%4;
	for (int i=0;i<4;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if (f==i&&ma[xx][yy]!='.'&&xx>=1&&xx<=n&&yy>=1&&yy<=m)
			dfs(xx,yy,f,now+1),pd=0;
	}
	if (pd){
		f=(f+3)%4;
		for (int i=0;i<4;i++){
			int xx=x+dx[i],yy=y+dy[i];
			if (f==i&&ma[xx][yy]!='.'&&xx>=1&&xx<=n&&yy>=1&&yy<=m)
				dfs(xx,yy,f,now+10),pd=0;
		}
	}
}
int main(){
	memset(minn,63,sizeof(minn));//注意初始要赋值为极大值
	n=read(),m=read();
	for (int i=1;i<=n;i++){
		scanf("%s",ma[i]+1);
		for (int j=1;j<=m;j++){
			if (ma[i][j]=='N') bx=i,by=j,bf=0;
			if (ma[i][j]=='E') bx=i,by=j,bf=1;
			if (ma[i][j]=='S') bx=i,by=j,bf=2;
			if (ma[i][j]=='W') bx=i,by=j,bf=3;
		}
	}
	dfs(bx,by,bf,0);
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：小燚狼 (赞：0)

//这个题目一看上去就知道要用搜索的吧，深搜+剪枝然后稍稍处理一下掉头和转弯所花费的金钱就可以了
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b,a1,b1,tx[4]={-1,0,1,0},ty[4]={0,1,0,-1},d,dp[31][31][4],vis[31][31][4],t=1000000,h[31][31];
char c[31][31];
void xx(int x,int y,int l,int v)
{
	if(v>=dp[x][y][l]||v>=t)//这是应该是个最优化剪枝 dp[x][y][l]表示走到（x,y）这个点方向为l的最小值，
    //所以再走到这个点方向相同如果花的钱还更多的话，就可以不走了啊
	return ;
	dp[x][y][l]=v;//更新最小花费的值
	if(x==a1&&y==b1)//找到终点啦！！！ 
	{
		t=v;
		return ;
	}
	int z=0;
	for(int i=0;i<4;i++)//枚举四个方向 
	{
		int p=x+tx[i],q=y+ty[i];
		if(p<=n&&p>0&&q<=m&&q>0&&c[p][q]!='.'&&vis[p][q][i]==0)//可以走的条件 
		{
			vis[p][q][i]=1;
			if((i+1)%4==l)//这个向左向右转自己稍微想想就知道了 ，下面也一样 
			{
				z++;//z用来记录是否可以不调头直接左转右转或直走 
				xx(p,q,i,v+1);
			}
			if((l+1)%4==i)
			{
				z++;
				xx(p,q,i,v+5);
			}
			if(l==i)
			{
				z++;
				xx(p,q,i,v);
			}			
			vis[p][q][i]=0;
		}
	}
	if(z==0)//这是判断掉头的情况 
	{
		int p=x+tx[(l+2)%4],q=y+ty[(l+2)%4];
		if(p<=n&&p>0&&q<=m&&q>0&&c[p][q]!='.'&&vis[p][q][(l+2)%4]==0)
		{
			vis[p][q][(l+2)%4]=1;
			xx(p,q,(l+2)%4,v+10);
			vis[p][q][(l+2)%4]=0;
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		cin>>c[i][j];
		if(c[i][j]>='A'&&c[i][j]<='Z'&&c[i][j]!='F')
		{
			a=i;
			b=j;
			if(c[i][j]=='N')
			d=0;
			if(c[i][j]=='E')
			d=1;
			if(c[i][j]=='S')
			d=2;
			if(c[i][j]=='W')
			d=3;
			//a,b是起点坐标 ,d是我记录方向的，0-上，1-右，2-下，3-左，上面方向的数组也是这个顺序；
		}
		if(c[i][j]=='F')
		{
			a1=i;
			b1=j;
			//终点呐 
		}
	}
	vis[a][b][d]=1;//表示第a行，第b行，d这个方向已经走过了 
	memset(dp,127,sizeof(dp));
	xx(a,b,d,0);//a,b是坐标，d是方向， 0是花费的money 
	cout<<t;
	return 0;
}
```

---


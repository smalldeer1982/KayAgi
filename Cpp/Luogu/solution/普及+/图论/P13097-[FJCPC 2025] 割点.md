# [FJCPC 2025] 割点

## 题目描述

给定一个正整数 $n$ 和一个长度为 $n-2$ 的 01 序列 $a_{2}, a_{3}, \dots, a_{n-1}$，要求你构造一个 $n$ 个点的**无向简单连通图** $G$，使得：

- 点 $1$ 是割点，点 $n$ 不是割点。

- 对于每个 $1 < i < n$：

若 $a_{i} = 1$，则点 $i$ 在图 $G$ 中是割点；

若 $a_{i} = 0$，则点 $i$ 在图 $G$ 中不是割点。

- 图 $G$ 中各顶点的度数满足：$\rm{deg}_1\geq \rm{deg}_2\geq\dots\geq \rm{deg}_n$。

如果存在多种可行的图，输出任意一种；如果不存在满足条件的图，则输出 $-1$。

简单图的定义为：无重边（即任意一对点之间至多只有一条边）且无自环（即不存在一条边两端点相同）的图。

割点的定义为：删掉该点以及它连的边后，使得图连通块个数增加的点。

## 说明/提示

对于样例一，可以证明不存在满足题意的图。

对于样例二，图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/49d4fgs7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

其中点 $1,2,3$ 是割点，$\rm{deg}_1\sim\rm{deg}_7$ 分别为：$3,3,2,1,1,1,1$，符合题意。

## 样例 #1

### 输入

```
2
4
11
7
11000```

### 输出

```
-1
6
1 2
1 3
1 4
2 5
2 6
3 7```

# 题解

## 作者：huang4678 (赞：3)

#### **首先给没有学过图论的同学补充一个知识点，度数就是每个点所连的边的数量**
## 题目大意

题意其实就是三个条件，我们构造的图只要满足以下三个条件即可。

1. 节点 $1$ 必须是割点，$n$ 不是割点。

1. 对于中间节点（$2$ 到 $n-1$），给定 $01$ 序列指定是否为割点（$1$ 为割点，$0$ 表示非割点）。

1. 图的度数序列需满足从 $1$ 到 $n$ 为非升序。
## 解题思路
首先考虑最普通的情况，割点至少要连两条线（即度数 $≥2$），所以我们很容易想到把割点以 1 为起点升序连成一条直线，然后在两头的割点连多条非割点。这样很容易满足条件 1 和条件 2。而割点的度数为 $2$，非割点的度数为 $1$，并不能保证满足条件 3。

所以在原有思路上改进，在割点的度数为 $2$ 的情况下可以想办法去提高非割点的度数（$n$ 除外，$n$ 在最后，度数可以为 $1$），既需要提高非割点的度数（即连线的数量），又需要在非割点删除后没有连通块，最容易的办法便是成环，以割点连成的直线起点 $1$ 作为环的一个顶点，所有 $n$ 以外的非割点与 $1$ 连成环，再将 $n$ 连在直线的另一端即可。
#### 不存在满足条件的图
直线两端至少有两个非割点一端一个，所以当 $2∼n$ 的序列全为 $1$ 时不满足条件。

而当有两个非割点时，并不能形成环，所以非割点的度数为 $1$，如果这个非割点在 $n-1$，则度数是 $3≥2⋯≥2≥1≥1$，符合条件 3，不是 $n-1$ 则不能满足条件。
## 正确性证明
节点 $1$ 连接一个割点和两个非割点，度数为 $3$。其他割点成线度数都是 $2$，非割点成环，度数也全为 $2$，$n$ 在直线另一端度数为 $1$，即度数为 $3≥2⋯≥2≥1$，满足条件 3。

代码实现的话按思路输出即可，最后附上代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int _;
    cin >> _;
    string a;
    while(_--)
    {
        int n;
        vector <int> b, c;    //b存储割点，c存储非割点
        cin >> n;
        cin >> a;
        b.push_back(1);
        for (int i = 0; i < n - 2; i++)
        {
            if (a[i] == '0')
                c.push_back(i+2);
            else
                b.push_back(i+2);
        }
        c.push_back(n);
        if (b.size() == n-1)
        {
            cout << -1 << endl;   //即只有n一个非割点
            continue;
        }
        if (b.size() == n - 2)     //有两个非割点的情况
        {
            if (*c.begin() != n - 1)
            {
                cout << -1 << endl;
            }
            else
            {
                cout << n-1 << endl;   //两个非割点未成环则有n-1条边
                cout << 1 << " " << n-1 << endl;
                for (int i = 1;i < n; i++)
                {
                    if (i != n - 2)
                        cout << i << " " << i+1 << endl;
                    else
                    {
                        cout << i << " " << n << endl;
                        break;
                    }
                }
            }
            continue;
        }
        cout << n << endl;      //剩下的都是可成环的图，有n条边
        int t = c.size();
        cout << 1 << " " << c[0] << endl;
        for (int i = 0; i < t - 1; i++){
            if (i != t - 2)
            cout << c[i] << " " << c[i + 1] << endl;
            else{
                cout << c[i] << " " << 1 << endl;
            }
        }
        t = b.size();
        if (b.size() > 1)     //有可能只有一个割点，所以要判断（本人没想到这一点第一次提交就错了）
            cout << 1 << " " << b[1] << endl;
        for (int i = 1 ;i < t - 1; i++){
            cout << b[i] << " " << b[i + 1] << endl;
        }
        cout << b[t-1] << " " << n << endl;
    }
    return 0;
}
```

---

## 作者：SudoXue (赞：1)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18974058)

好妙的题目，参考了官方题解才做出来。

题目的关键约束是：点 $1$ 必须是割点，点 $n$ 必须不是割点；给定的 `01` 串规定了内部各点是否为割点；所有顶点度数需满足非增序列。若把“是否为割点”用树论语言描述，可借助圆方树的结论：在一棵树里，叶子一定不是割点，而度数 $\ge 2$ 的内部结点一定是割点。因此只要把所有非割点做成叶子、所有割点做成内部点，就能同时满足割点判定与度数条件。由此问题转化成：怎样选边，让指定的 $0$ 变成叶子、指定的 $1$ 变成内部结点，并保持连通。

首先，内部若没有 $0$，则所有内部点都要求是割点，无法给点 $1$ 留下一条叶子边，必无解。若恰有一个 $0$，但它不在 $n-1$ 位置，那么在 $0$ 之后仍出现 $1$，会导致后面的割点度数 $\ge 2$ 而编号更大，破坏度数单调，同样无解。其余情况一定可行。

当内部 $0$ 至少两个时，取最前两个 $0$，记为 $p,q$。连边 $1-p$、$1-q$，再把剩余 $0$ 按编号依次首尾相接插在 $p$ 与 $q$ 之间，形成一条“叶环”，环上全部顶点度数为 $2$，但因为任意一处断开后环仍连通，故它们都不是割点。对所有内部 $1$，则按编号升序串成一条链，首端接点 $1$，尾端接点 $n$。链上每个点度数恰为 $2$，删除即可把整条链分成左右两段，因而是割点。点 $1$ 现有至少三条边：两条指向 $p,q$ 和一条指向链，度数最大；点 $n$ 只有一条来自链，保证不是割点且度数最小。其余内部 $0$ 由于在环上度数为 $2$，不影响度序单调。

当唯一内部 $0$ 位于 $n-1$ 时，把全部内部 $1$ 按编号连成链，接在 $1$ 与 $n$ 之间，再单独把 $n-1$ 作为叶子挂到 $1$ 上即可。此时链上所有 $1$ 是割点，$n-1$ 是叶子非割点，点 $n$ 仍是叶子非割点，度序为 $(d_1,d_2,\dots,d_n)=(k+1,2,\dots,2,1,1)$ 满足非增。

时间复杂度 $O(n)$。

[link](https://www.luogu.com.cn/record/223091370)

---

## 作者：udiandianis (赞：0)

## 题目大意

给定一个长度为 $n-2$ 的 $01$ 序列 $a$，构造一张 $n$ 点无向图，要求满足以下条件：

- 点 $1$ 是割点，点 $n$不是割点。
- $a_i$ 是 $1$ 则点 $i$ 是割点，否则 $i$ 不是割点。
- 点的度数满足 $deg_1 \geq deg_2 \geq \dots \geq deg_n$。

输出任意一种构造方法即可，无法构造输出 $-1$。

## 解题思路

考虑点 $2 \sim n$ 的割点数量：

- 如果有两个及以上的非割点，一种较为简单的构造方法是一条链加上一个环，把环挂到 $1$ 上，此时 $deg_1=3$，$deg_n=1$，其余点度数都是2。
- 如果只有一个非割点，如果是点 $n - 1$ 则有解（直接挂 $1$ 上），否则无解（度数不满足）。
- 如果没有非割点，无解（一条链的时候度数不满足要求）。

## 代码实现

```C++
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int tt;
    std::cin >> tt;

    while (tt--) {
        int n;
        std::cin >> n;

        std::string s;
        std::cin >> s;

        int cnt = std::count(s.begin(), s.end(), '0');
        if (cnt == 0 || cnt == 1 && s.back() != '0') {
            std::cout << -1 << "\n";
        } else {
            std::vector<int> link = {1}, circle;
            for (int i = 0; i < n - 2; i++) {
                if (s[i] == '1') {
                    link.push_back(i + 2);
                } else {
                    circle.push_back(i + 2);
                }
            }
            link.push_back(n);

            std::set<std::array<int, 2>> ans;
            for (int i = 0; i + 1 < link.size(); i++) {
                ans.insert({link[i], link[i + 1]});
            }
            for (int i = 0; i + 1 < circle.size(); i++) {
                ans.insert({circle[i], circle[i + 1]});
            }
            ans.insert({1, circle.front()});
            ans.insert({1, circle.back()});

            std::cout << ans.size() << "\n";
            for (auto [u, v] : ans) {
                std::cout << u << " " << v << "\n";
            }
        }
    }
}
```

---


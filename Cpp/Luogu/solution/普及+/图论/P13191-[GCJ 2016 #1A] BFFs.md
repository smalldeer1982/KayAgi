# [GCJ 2016 #1A] BFFs

## 题目描述

你是一所新开的 Little Coders 幼儿园的老师。你的班级里有 $\mathbf{N}$ 个孩子，每个孩子的学号从 $1$ 到 $\mathbf{N}$，互不相同。班里的每个孩子都有一个唯一的“永远的最好的朋友”（BFF），你知道每个孩子的 BFF 是谁。BFF 关系不一定是互相的——也就是说，B 是 A 的 BFF，并不意味着 A 一定是 B 的 BFF。

你的明天的教学计划中有一个活动，要求参与的孩子围成一个圆圈坐下。你希望活动尽可能成功，因此想让尽可能多的孩子围成一个圈，并且要求圈中的每个孩子都必须与自己的 BFF 紧邻（可以在左边，也可以在右边）。没有进入圈子的孩子则只能在一旁观摩。

请问，最多可以有多少个孩子围成满足条件的圆圈？

## 说明/提示

**样例解释**

在样例第 4 组中，最大可能的圆圈可以让如下孩子按如下顺序围成一圈：`7 9 3 10 4 1`。（该圆圈的任意旋转或反转也都符合条件。）注意，学号为 1 的孩子与学号为 7 的孩子相邻，符合题目要求，因为该列表表示一个圆圈。

**限制条件**

- $1 \leqslant \mathbf{T} \leqslant 100$。
- 对所有 $i$，$1 \leqslant \mathbf{F}_i \leqslant \mathbf{N}$。
- 对所有 $i$，$\mathbf{F}_i \neq i$（没有孩子把自己当作 BFF）。

**小数据集（16 分，测试集 1 - 可见）**

- $3 \leqslant \mathbf{N} \leqslant 10$。

**大数据集（29 分，测试集 2 - 隐藏）**

- $3 \leqslant \mathbf{N} \leqslant 1000$。

翻译由 GPT4.1 完成。

## 样例 #1

### 输入

```
4
4
2 3 4 1
4
3 3 4 1
4
3 3 4 3
10
7 8 10 10 9 2 9 6 3 3```

### 输出

```
Case #1: 4
Case #2: 3
Case #3: 3
Case #4: 6```

# 题解

## 作者：Shimarin1001 (赞：0)

「真正的朋友」是什么呢……

---
### 前置知识
---
[基环树](https://oi-wiki.org/graph/concept/#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%9B%BE)

---
### 分析
---
对于这类“每个人都有一个唯一的某某某”的题目，我们很容易想到**基环树**。为了操作方便，我们将第 $i(1 \leq i \leq n)$ 个人的 BFF 向 $i$ 连接一条有向边，这样就建成了一片**外向基环树**（即每个点入度均为 $1$ 的图）的森林。

题目需要选出尽可能多的孩子围成一圈，让每个孩子都与自己的 BFF 相邻。很容易想出一种贪心的思路：一个环上的所有孩子显然满足题目要求，因此只需统计森林中每棵基环树的环的大小，取其最大值即可。

但我们会发现，这个思路连样例都过不去。

观察样例 4，我们发现还有一种情况也满足题目要求：

![样例四](https://cdn.luogu.com.cn/upload/image_hosting/iuco0tq6.png)

~~（作者是绿色弱所以画图的时候点不小心画成了绿色的）~~

可以发现：当一棵基环树的环大小刚好为 $2$ 时，可以选择这棵树的两条最长链（其中链的起点分别是环上的两个不同的点），这棵树产生的最大圆圈大小即为这两条链的大小之和。

于是，我们得出结论：答案即为“每棵基环树的环大小”和“环大小为 $2$ 的基环树中的两条最长不相交链的大小之和”中的最大值。

交上去一看：[WA](https://www.luogu.com.cn/record/226622806)。

为什么会这样呢？

我们再画一张图：

![hack](https://cdn.luogu.com.cn/upload/image_hosting/aqsuo97a.png)

注意到这张图上的节点构成了两棵不同的基环树，但如果我们将这些节点按图示方式排成一个圆圈，同样可以满足题目要求。类似地，我们还可以加入三棵、四棵、五棵……

于是，我们的结论就变成了：答案为“每棵基环树的环大小”和“环大小为 $2$ 的**所有**基环树中的两条最长不相交链的大小之和”中的最大值。

---
### 代码
---

求出每棵基环树的环及环的大小，之后对每棵环大小为 $2$ 的基环树进行 dfs 即可。我使用了 tarjan 算法。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=1e3+5;
int T,n,head[MAXN],cnt=1;
struct edge{
	int next,to;
}e[MAXN];
inline void addedge(int u,int v){
	e[++cnt]=(edge){head[u],v};
	head[u]=cnt;
}
int dfn[MAXN],dep,low[MAXN],col[MAXN],tot,siz[MAXN];
bool vis[MAXN];
stack<int> s;
vector<int> scc[MAXN];
inline void tarjan(int u){
	dfn[u]=low[u]=++dep;
	vis[u]=1;
	s.push(u);
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(!dfn[v]){
			tarjan(v),low[u]=min(low[u],low[v]);
		}else if(vis[v]){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		col[u]=++tot;
		vis[u]=0;
		scc[tot].push_back(u);
		while(s.top()!=u){
			col[s.top()]=tot;
			vis[s.top()]=0;
			scc[tot].push_back(s.top());
			s.pop();
		}
		s.pop();
	}
}
inline int dfs(int u){
	int maxn=1;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(col[u]!=col[v])maxn=max(maxn,dfs(v)+1);
	}
	return maxn;
}
signed main(){
	cin>>T;
	for(int C=1;C<=T;C++){
		for(int i=1;i<=n;i++)head[i]=dfn[i]=low[i]=col[i]=siz[i]=vis[i]=0;
		for(int i=1;i<=tot;i++)scc[i].erase(scc[i].begin(),scc[i].end());
		while(!s.empty())s.pop();
		cnt=1;dep=tot=0;
		cin>>n;
		for(int i=1,u;i<=n;i++){
			cin>>u;
			addedge(u,i);
		}
		for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
		int ans=0;
		for(int u=1;u<=n;u++){
			siz[col[u]]++;
			ans=max(ans,siz[col[u]]);
		}
		int sum=0;
		for(int i=1;i<=tot;i++){
			if(siz[i]==2){
				sum+=dfs(scc[i][0])+dfs(scc[i][1]);
			}
		}
		ans=max(ans,sum);
		cout<<"Case #"<<C<<": "<<ans<<endl;
	}
}
```

[AC记录](https://www.luogu.com.cn/record/226628885)

---


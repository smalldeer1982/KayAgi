# [GCJ 2016 #1C] Slides!

## 题目描述

Gooli 是一家在丘陵地区拥有 $\mathbf{B}$ 座大楼的巨型公司。这些大楼编号为 $1$ 到 $\mathbf{B}$。

CEO 希望在大楼之间建设一组滑梯，方便她从自己在 1 号大楼的办公室前往她最喜欢的咖啡馆所在的 $\mathbf{B}$ 号大楼。滑梯当然是单向的，但由于大楼都很高且有电梯，滑梯可以从任意一栋大楼出发，通向任意另一栋大楼，方向不限。具体来说，对于任意两栋大楼 $\mathrm{x}$ 和 $\mathrm{y}$，你可以选择建造 $0$ 条或 $1$ 条从 $\mathrm{x}$ 到 $\mathrm{y}$ 的滑梯，也可以选择建造 $0$ 条或 $1$ 条从 $\mathrm{y}$ 到 $\mathrm{x}$ 的滑梯。唯一的例外是，不允许从 $\mathbf{B}$ 号大楼出发建滑梯，因为 CEO 一旦到达那里，就不再需要继续滑行。

为了纪念 Gooli 公司成立恰好 $\mathbf{M}$ 毫秒，设计方案必须确保 CEO 恰好有 $\mathbf{M}$ 种不同的方式从 1 号大楼滑到 $\mathbf{B}$ 号大楼。一种方式定义为一个以 1 号大楼为起点、以 $\mathbf{B}$ 号大楼为终点的楼栋序列，且序列中任意相邻的两栋楼之间都存在一条滑梯。注意，CEO 并不要求任意两栋大楼之间都能通过滑梯互达。

你能否给出一种包含一条或多条滑梯的方案，使得 CEO 的要求得到满足？或者判断这种方案是否不可能存在？

## 说明/提示

**样例解释**

样例输出展示了每组数据的一种可行方案，其他方案也是可能的。

以下是第 1 组样例方案的示意图：

![](https://cdn.luogu.com.cn/upload/image_hosting/742n0lsq.png)

从 1 号大楼到 5 号大楼共有 4 种方式：

- 1 → 5
- 1 → 2 → 3 → 5
- 1 → 2 → 4 → 5
- 1 → 2 → 4 → 3 → 5

在第 3 组中，如果建造 1→2、2→3、3→1、1→4 的滑梯，则 CEO 可以有无数种方式到达 4 号大楼（可以直接到 4，也可以绕环多次后再到 4），但 CEO 要求恰好 20 种方式。

**限制条件**

$1 \leqslant \mathbf{T} \leqslant 100$。

**小数据集（13 分，测试集 1 - 可见）**

- $2 \leqslant \mathbf{B} \leqslant 6$。
- $1 \leqslant \mathbf{M} \leqslant 20$。

**大数据集（21 分，测试集 2 - 隐藏）**

- $2 \leqslant \mathbf{B} \leqslant 50$。
- $1 \leqslant \mathbf{M} \leqslant 10^{18}$。

翻译由 GPT4.1 完成。

## 样例 #1

### 输入

```
3
5 4
2 1
4 20```

### 输出

```
Case #1: POSSIBLE
01001
00110
00001
00101
00000
Case #2: POSSIBLE
01
00
Case #3: IMPOSSIBLE```

# 题解

## 作者：fyxblyn (赞：1)

## 题意

给定 $B$ 个点并在其中任意连边，构造一种方案使得从 $1$ 号节点到 $B$ 号节点恰有 $M$ 条路径。

## 思路

下文中用 $N$ 代替题目中的 $B$。

我们默认一个节点只向编号更大的节点连边，这样可以保证图中不出现环，也就防止了出现有无数条路径可到达 $N$ 号节点的情况。

直接构造方案似乎很困难，我们可以先在 $N$ 较小时寻找规律，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/c26v6jmp.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/7rylb9ep.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/55jnlu8k.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/5j51c6l0.png)

这四种情况中，从 $1$ 号节点到 $N$ 号节点分别有 $1,2,4,8$ 条不同路径。

因此我们大胆猜测，如果将能连的边全部连上，在 $N$ 个节点的情况下有 $2^{N-2}$ 条路径，这也是 $N$ 对应的最大路径数。

考虑用数学归纳法来证明，在 $N=2$ 时结论显然成立，在 $N>2$ 时，我们将原先 $N-1$ 个节点与新加入的节点都连边，那么到达新节点的路径数就是之前所有节点的路径数之和。

设 $ans_i$ 为从 $1$ 号节点到 $i$ 号节点的最大路径数，则有：
$$ans_i=\sum_{j=1}^{i-1}ans_j$$

其中 $ans_1=1$。

那么显然 $i>1$ 时，$ans_i=2^{i-2}$。

接下来考虑如何构造方案，下面默认给出的 $N,M$ 有解。

我们先将 $1$ 到 $N-1$ 号点按上面的方法全部连边，这时从 $1$ 号节点到 $i$ 号节点的路径数便为上面的 $ans_i$。

由于 $ans_i$ 均为 $2$ 的幂次，我们可以用所有 $i<N$ 的 $ans_i$ 凑出从 $0$ 到 $2^{N-2}$ 范围内的任意整数。

所以我们将 $M$ 进行二进制分解，如果 $M$ 在从低到高第 $i$ 位上为 $1$，就从第 $i+1$ 号点向 $N$ 号点连边。

由于 $ans_1=ans_2=1$，最后 $M$ 仍有剩余时使 $1$ 号点与其连边即可。

具体实现可以参考代码。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
bool ans[55][55];
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    for(int z=1;z<=t;z++)
    {
        memset(ans,0,sizeof(ans));
        cout<<"Case #"<<z<<": ";
        int n,m;
        cin>>n>>m;
        if((1ll<<(n-2))<m)
        {
            cout<<"IMPOSSIBLE\n";
            continue;
        }
        else cout<<"POSSIBLE\n";
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<n;j++)
            {
                if(j<=i)ans[i][j]=0;
                else ans[i][j]=1;
            }
        }
        for(int i=n-1;i>=2;i--)
        {
            if(m>=(1ll<<(i-2)))
            {
                ans[i][n]=1;
                m-=(1ll<<(i-2));
            }
            else ans[i][n]=0;
        }
        if(m==1)ans[1][n]=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
                cout<<ans[i][j];
            cout<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：无名之雾 (赞：0)

去打了一个月 Mo，回来复建做的第一题。

没想到被绿题卡了半小时，真是耻辱。

## solution

显然你构造出来的图一定是 DAG。

由于 DAG 的边数会是爆炸多的，所以枚举显然是不现实的。

不妨考虑任意两点之间都有边得情况。

由于起点与终点固定的，所以仅需考虑中间 $B-2$ 个点即可。

总条数会是：

  $$
    \sum_{k=0}^{B-2} \binom{B-2}{k} = 2^{\,B-2}
  $$


我们想让从 $1$ 出发的所有路径数之和恰好等于 $M$。

而把 $1$ 到 $i$ 的边是否连上对总路径数的贡献，即为从 $i$ 到 $B$ 的路径数，$2^{B–i}$。

所以构造方法就是把 $M$ 拆成若干二的次方相加。

而任何 $0 ≤ M ≤ 2^{B–2}$ 都可以写成若干个互不相同的 $2^k$ 之和。

所以只要 $0 ≤ M ≤ 2^{B–2}$ 就必定有解。

具体构造只需要把 $M$ 转为二进制：
$$M = b_0·2^0 + b_1·2^1 + … + b_{B-2}·2^{B-2}$$

对于每一个 $b_i=1$，就在点 $1$ 和点 $B-i$ 间连一条边。

代码是好写的，就不放了。

---


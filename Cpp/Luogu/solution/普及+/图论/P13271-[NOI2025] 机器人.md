# [NOI2025] 机器人

## 题目描述

NOI2025 正在绍兴举办，小 Y 为闭幕式表演制作了一个机器人并打算操控它从仓库走到礼堂。

绍兴的道路系统可以简化为 $n$ 个路口以及连接这些路口的 $m$ 条 **单行道路**，且每条道路有一定的长度。为了方便将道路系统录入机器人的芯片，小 Y 对每一个路口连接的所有道路进行了编号。具体而言，若有 $d$ 条道路以路口 $x$ 为起点，则这 $d$ 条道路会被小 Y 按照某种顺序编号为 $1 \sim d$，分别称作以 $x$ 为起点的第 $1 \sim d$ 条道路。

小 Y 的机器人内部有一个参数 $p$。给定参数 $p$ 的上限 $k$ 与修改费用 $v_1, v_2, \ldots, v_{k-1}, w_2, w_3, \ldots, w_k$。小 Y 将按照如下规则设置与修改机器人的参数：

- 初始时，小 Y 将参数 $p$ 设置为 $1$。
- 在 **任意时刻**，小 Y 可以远程控制机器人修改参数：
  - 若 $p < k$，则小 Y 可以花费 $v_p$ 的费用将 $p$ 增加 $1$，即 $p \leftarrow p + 1$；
  - 若 $p > 1$，则小 Y 可以花费 $w_p$ 的费用将 $p$ 减少 $1$，即 $p \leftarrow p - 1$。

初始时，小 Y 的机器人位于机器人仓库，即路口 $1$。当机器人位于路口 $x$ 时，记以路口 $x$ 为起点的第 $p$ 条道路的终点为 $y$，道路长度为 $z$，则小 Y 可以花费 $z$ 的费用操控机器人从 $x$ 走到 $y$。特别地，若以路口 $x$ 为起点的道路不足 $p$ 条，则小 Y 无法操控机器人走动。

小 Y 并不知道闭幕式表演所在的礼堂位于哪个路口，因此他需要对每个路口都做好准备。请你帮助他求出将机器人从仓库移动到每个路口所需费用的最小值。

## 说明/提示

### 样例 1 解释

小 Y 可以按照以下方案将机器人分别从仓库移动到路口 $1 \sim 4$：

- 对于路口 $1$：小 Y 的机器人初始时即位于路口 $1$，因此所需费用为 $0$。
- 对于路口 $2$：小 Y 操控机器人沿以路口 $1$ 为起点的第 $1$ 条道路走到路口 $2$，所需费用为 $5$。
- 对于路口 $3$：小 Y 将参数 $p$ 增加 $1$，然后操控机器人沿以路口 $1$ 为起点的第 $2$ 条道路走到路口 $3$，所需费用为 $2 + 1 = 3$。
- 对于路口 $4$：小 Y 将参数 $p$ 增加 $1$，然后操控机器人沿以路口 $1$ 为起点的第 $2$ 条道路走到路口 $3$，再操控机器人沿以路口 $3$ 为起点的第 $2$ 条道路走到路口 $4$，所需费用为 $2 + 1 + 1 = 4$。

可以证明，上述移动方案的所需费用均为最小值。

- 对于路口 $5$：由于小 Y 无法将机器人移动到路口 $5$，因此输出 $-1$。

### 样例 2

见选手目录下的 `robot/robot2.in` 与 `robot/robot2.ans`。

该样例满足测试点 $3 \sim 5$ 的约束条件。

### 样例 3

见选手目录下的 `robot/robot3.in` 与 `robot/robot3.ans`。

该样例满足测试点 $6 \sim 8$ 的约束条件。

### 样例 4

见选手目录下的 `robot/robot4.in` 与 `robot/robot4.ans`。

该样例满足测试点 $9, 10$ 的约束条件。

### 样例 5

见选手目录下的 `robot/robot5.in` 与 `robot/robot5.ans`。

该样例满足测试点 $16 \sim 18$ 的约束条件。

### 数据范围

对于所有测试数据，保证：

- $1 \leq n, m \leq 3 \times 10^5$，$1 \leq k \leq 2.5 \times 10^5$；
- 对于所有 $1 \leq i \leq k - 1$，均有 $0 \leq v_i \leq 10^9$；
- 对于所有 $2 \leq i \leq k$，均有 $0 \leq w_i \leq 10^9$；
- 对于所有 $1 \leq i \leq n$，均有 $0 \leq d_i \leq k$，且 $\sum_{i=1}^{n} d_i = m$；
- 对于所有 $1 \leq i \leq n$，$1 \leq j \leq d_i$，均有 $1 \leq y_{i,j} \leq n$，$1 \leq z_{i,j} \leq 10^9$。

::cute-table{tuack}

| 测试点编号 | $n, m \leq$ | $k \leq$ | 特殊性质 |
| :-: | :-: | :-: | :-: |
| $1, 2$ | $6$ | $6$ | C |
| $3 \sim 5$ | $10^3$ | $10^3$ | ^ |
| $6 \sim 8$ | $5 \times 10^4$ | $10^2$ | 无 |
| $9, 10$ | $10^5$ | $10^5$ | AB |
| $11, 12$ | ^ | ^ | A |
| $13 \sim 15$ | ^ | ^ | C |
| $16 \sim 18$ | ^ | ^ | 无 |
| $19, 20$ | $3 \times 10^5$ | $2.5 \times 10^5$ | ^ |

- 特殊性质 A：保证 $v_1 = v_2 = \cdots = v_{k-1} = 0$ 且 $w_2 = w_3 = \cdots = w_k = 0$。
- 特殊性质 B：保证对于所有 $1 \leq i \leq n$，$1 \leq j \leq d_i$，均有 $z_{i,j} = 1$。
- 特殊性质 C：保证至多存在 10 个 $i$ 满足 $d_i \geq 10$。

附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13079)。

## 样例 #1

### 输入

```
0
5 6 3
2 4
1 1
3 2 5 3 1 4 2
1 3 2
2 1 2 4 1
0
0```

### 输出

```
0 5 3 4 -1```

# 题解

## 作者：_H17_ (赞：32)

## 题目分析

看了眼题，好像会做？没数据能不能直接切有点悬啊，不过错了的话会更新题解，如果没更新大概是对的。

首先发现是求最短路，还要分层图。

显然肯定是按照 $p$ 分层做最短路，但是有一个问题点数变成了 $n\times k$，显然无法通过。

注意到如果 $p>d_i$ 那没法连出去，考虑只对 $1\sim d_i$ 建图，这样就可以规避这个问题，点数是 $n+m$（每个点肯定有点，而且还有 $d_i$ 个层，分层的点一共 $m$，不分的按照 $n$，应该卡不满，卡满了也没事）。

每次可以自己花代价更改 $p$ 来松弛，也可以去其它点的方式松弛。代价可以前缀和处理。

因为权值非负，剩下 Dijkstra 即可。

时间复杂度 $O(n+k+m\log\min(n+m,n\times k))$（前面是输入）。

## 代码实现

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define int long long 
using namespace std;
using namespace __gnu_pbds;
constexpr int N=3e5+1;
int id,n,m,k,v[N],w[N],oud[N],ans[N];
gp_hash_table<int,int>dis[N],vis[N];
vector<pair<int,int> >e[N];
void add(int u,int v,int w){
    e[u].push_back({v,w});
    return;
}
int up(int x,int y){
    return v[y-1]-v[x-1];
}
int down(int x,int y){
    return w[x]-w[y];
}
void dijkstra(){
    std::priority_queue<pair<int,pair<int,int> >,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > >q;
    q.push({dis[1][1]=0,{1,1}});
    ans[1]=0;
    while(!q.empty()){
        auto[d,H17]=q.top();
        auto[u,p]=H17;
        q.pop();
        if(dis[u][p]!=d)
            continue;
        for(int i=1;i<=min(oud[u],p-1);i++)
            if(!vis[u][i]||d+down(p,i)<dis[u][i]){
                q.push({dis[u][i]=d+down(p,i),{u,i}});
                ans[u]=min(ans[u],dis[u][i]);
                vis[u][i]=1;
            }
        for(int i=p+1;i<=min(oud[u],k);i++)
            if(!vis[u][i]||d+up(p,i)<dis[u][i]){
                q.push({dis[u][i]=d+up(p,i),{u,i}});
                ans[u]=min(ans[u],dis[u][i]);
                vis[u][i]=1;
            }
        if(oud[u]<p)
            continue;
        auto[v,w]=e[u][p-1];
        if(!vis[v][p]||d+w<dis[v][p]){
            q.push({dis[v][p]=d+w,{v,p}});
            ans[v]=min(ans[v],dis[v][p]);
            vis[v][p]=1;
        }
    }
    return;
}
signed main(){
    ios::sync_with_stdio(0);
    cin>>id>>n>>m>>k;
    for(int i=1;i<k;i++){
        cin>>v[i];
        v[i]+=v[i-1];
    }
    for(int i=2;i<=k;i++){
        cin>>w[i];
        w[i]+=w[i-1];
    }
    for(int u=1,v,w;u<=n;u++){
        cin>>oud[u];
        for(int i=1;i<=oud[u];i++){
            cin>>v>>w;
            add(u,v,w);
        }
    }
    memset(ans,0x3f,sizeof(ans));
    dijkstra();
    for(int i=1;i<=n;i++)
        cout<<(ans[i]!=0x3f3f3f3f3f3f3f3fll?ans[i]:-1)<<' ';
    return 0;
}
```

---

## 作者：WsW_ (赞：22)

### 更新
这是一篇**已通过**的题解。
- $2025.07.21$ 更新了代码和部分表述。

---
### 思路
首先看到的是 $n$ 个点 $m$ 条边，可以想到跑最短路。然后发现还有一个参数 $p$，限制只能走每个点的第 $p$ 条边。  
所以每个点有两个状态：第 $i$ 个点，参数 $p$。多个状态的最短路问题用分层图解决。  

转移共分为两种：  
1. 同一个点内转移，即 $i$ 不变，$p$ 变。
2. 不同点间转移，即 $i$ 变，$p$ 不变。

这样太麻烦了，不如每次转移 $i,p$ 一起变。具体而言，先变 $i$，再变 $p$。  
变 $i$ 的时候 $p$ 没变，所以只有一条路可以走，变完之后的 $i'$ 是确定的，花费也是确定的。  
变后的 $p'$ 要能继续转移，所以 $p'$ 不能大于 $d_{i'}$。在 $1\sim d_{i'}$ 内枚举 $p'$ 即可。  
变 $p$ 产生的花费是 $v_i$ 或 $w_i$ 内某一段的和，可以用前缀和来求。  

有个例外，我们也可以只变 $i$，不变 $p$，并且之后**不再用这个状态转移**了，那么就不用关心 $p'$ 是否大于 $d_{i'}$。我们可以把这种例外全部看作 $p'=0$ 的特殊情况。  

每次转移的花费为非负整数，可以使用 dijkstra 求最短路。  
最后对每个点，统计 $p$ 取 $0\sim d_i$ 花费的最小值即可。  

时间复杂度为 $O((n+m)\log (n+m))$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,pii> plii;
const int MAXN=3e5+3;
const ll Inf=1e18;

int n,m,k,d[MAXN];
vector<pii>edg[MAXN];
vector<ll>dis[MAXN];
vector<bool>vis[MAXN];
priority_queue<plii>q;

ll sumv[MAXN],sumw[MAXN];
ll gs(int x,int y){
	if(x<y)return sumv[y-1]-sumv[x-1];
	else return sumw[x]-sumw[y];
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int c; cin>>c>>n>>m>>k;
	for(int i=1;i<k;i++){
		cin>>sumv[i];
		sumv[i]+=sumv[i-1];
	}
	for(int i=2;i<=k;i++){
		cin>>sumw[i];
		sumw[i]+=sumw[i-1];
	}
	for(int i=1;i<=n;i++){
		cin>>d[i];
		vis[i].assign(d[i]+1,0);
		dis[i].assign(d[i]+1,Inf);
		edg[i].assign(d[i]+1,{0,0});
		for(int j=1;j<=d[i];j++){
			int y,z; cin>>y>>z;
			edg[i][j]={y,z};
		}
	}
	for(int i=1;i<=d[1];i++){
		dis[1][i]=gs(1,i);
		q.push({-dis[1][i],{1,i}});
	}
	while(!q.empty()){
		pii pos=q.top().second; q.pop();
		int fr=pos.first,p=pos.second;
		if(vis[fr][p])continue;
		vis[fr][p]=1;
		int to=edg[fr][p].first;
		ll cost0=dis[fr][p]+edg[fr][p].second;
		dis[to][0]=min(dis[to][0],cost0);
		for(int i=1;i<=d[to];i++){
			ll cost=cost0+gs(p,i);
			if(cost<dis[to][i]){
				dis[to][i]=cost;
				q.push({-cost,{to,i}});
			}
		}
	}
	for(int i=1;i<=n;i++){
		sort(dis[i].begin(),dis[i].end());
		cout<<(dis[i][0]==Inf?-1:dis[i][0])<<' ';
	}
	return 0;
}
```

---

## 作者：Register_int (赞：12)

一个看上去很笨的想法是：对于每个点 $u$，直接新建 $k$ 个点 $(u,i)$ 表示机器人到这里的参数。但这样实际上是对的，因为每个点只会有度数个参数是有用的，所以新建点数是 $O(n)$ 的。修改参数就在点 $u$ 的 $(u,i)$ 内部建边，跑最短路即可。复杂度 $O(n\log n)$。

---

## 作者：thy21171 (赞：9)

**考虑如何建图。**

首先，我们可以关注到了一个良好的条件：$\sum\limits_{i=1}^nd_i=m$。~~（废话）~~

于是考虑拆点，设 $P_{i,j}$ 表示机器人到达点 $i$，且 $p=j$ 时的状态。

显然，对于一个点 $P_{i,j}$，最多向其他点连 $3$ 条边。（设 $v=y_{i,j},w=z_{i,j}$）

1.当 $j>1$ 时，$P_{i,j}\to P_{i,j-1}$，边权为 $w_j$。

2.当 $j<d_i$ 时，$P_{i,j}\to P_{i,j+1}$，边权为 $v_j$。

3.$P_{i,j}\to P_{v,j}$，边权为 $z_{i,j}$。这里有一个细节，当 $j>d_v$ 时，我们是没有 $P_{v,j}$ 这个点的（$j$ 太大了，而点 $v$ 只有 $d_v$ 条边）。

所以当 $j>d_{v}$ 时，我们要将点 $P_{i,j}$ 连向 $P_{v,d_v}$，边权为 $w+\sum\limits_{i=d_v+1}^jw_i$。

所以，这样建图边的数量就是 $O(m)$ 级别的。

最后跑一遍 $\text{dijkstra}$ 时间复杂度 $O(m\log m)$。

``` cpp
#include <bits/stdc++.h>
typedef long long ll;
const int N = 3e5 + 5;
const ll INF = 0x3f3f3f3f3f3f3f3f;

int n, m, k, s, vis[N], to[N];
ll V[N], W[N];
std::vector<std::pair<int, ll>> Q[N];
ll ans[N], dis[N];

struct Node { 
	ll dis; int u, p; 
	bool operator< (Node a) const { return dis > a.dis; }
};

std::priority_queue<Node> que;
	
int main()
{
	std::memset(ans, 0x3f, sizeof(ans));
	std::memset(dis, 0x3f, sizeof(dis));

	scanf("%*d%d%d%d", &n, &m, &k); ans[1] = dis[1] = 0;
	for (int i = 1; i < k; ++i) scanf("%lld", V + i), V[i] += V[i - 1];
	for (int i = 2; i <= k; ++i) scanf("%lld", W + i), W[i] += W[i - 1];

	for (int i = 1; i <= n; ++i) {
		scanf("%d", &s); 
		for (int j = 1, v, w; j <= s; ++j)
			scanf("%d%d", &v, &w), Q[i].emplace_back(v, w);
		to[i + 1] = to[i] + s;
	}

	if (Q[1].empty()) { // 特判 d[1] = 0 的情况，但貌似数据没有卡这个？
		printf("0");
		for (int i = 2; i <= n; ++i)
			printf(" -1");
		return 0;
	}

	que.push({0, 1, 1});

	while (!que.empty()) {
		auto [d, u, p] = que.top(); que.pop();
		if (vis[to[u] + p]) continue; vis[to[u] + p] = 1;

		auto [v, w] = Q[u][p - 1]; int q = Q[v].size();
		ans[v] = std::min(ans[v], dis[to[u] + p] + w);

		if (q >= p) {
			if (dis[to[u] + p] + w < dis[to[v] + p]) {
				dis[to[v] + p] = dis[to[u] + p] + w;
				if (!vis[to[v] + p]) que.push({dis[to[v] + p], v, p});
			}
		} else if (q) {
			w += W[p] - W[q]; 
			if (dis[to[u] + p] + w < dis[to[v] + q]) {
				dis[to[v] + q] = dis[to[u] + p] + w;
				if (!vis[to[v] + q]) que.push({dis[to[v] + q], v, q});
			}
		}

		if (p < Q[u].size()) {
			w = V[p] - V[p - 1]; q = p + 1;
			if (dis[to[u] + p] + w < dis[to[u] + q]) {
				dis[to[u] + q] = dis[to[u] + p] + w;
				if (!vis[to[u] + q]) que.push({dis[to[u] + q], u, q});
			}
		}

		if (p > 1) {
			w = W[p] - W[p - 1]; q = p - 1;
			if (dis[to[u] + p] + w < dis[to[u] + q]) {
				dis[to[u] + q] = dis[to[u] + p] + w;
				if (!vis[to[u] + q]) que.push({dis[to[u] + q], u, q});
			}
		}
	}

	for (int i = 1; i <= n; ++i)
		printf("%lld ", ans[i] == INF ? -1 : ans[i]);

	return 0;
}
```

---

## 作者：Vae_L (赞：8)

大为震撼。

NOIT1 是这个样子，那今年 CSPT1 会不会给个红啊。

第一篇 NOI 题解。

由于先做的讨论区说的原题，所以最初以为和原题是一样的做法，仔细看了看题发现更水。

考虑 $dis_{i,j}$ 代表移动到第 $i$ 个点，$p$ 为 $j$ 的最小代价。

当然是用 STL 存储。

以这个为状态跑最短路，状态数看起来达到了无法接受的级别，但很快就会发现，从 $u$ 转移到 $v$ 点时，第二维的状态以及代价就确定了，复杂度是 dijkstra 的单 log 的。

代码如下：
```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
int k,d[500005],u[500005],v[500005],w[500005],n,m,cnt,c;
unordered_map<int,int>vis[500005],dis[500005];
vector<pair<int,int>>vec[500005];
struct edge{
	int w,to,p;
	bool operator <(const edge &x)const
    {
        return x.w<w;
    }
};
priority_queue<edge>q;
void dijkstra(int s)
{
	memset(d,0x3f,sizeof d);
	d[s]=0,dis[s][1]=0;
	q.push({0,s,1});
	while(!q.empty())
	{
		int x=q.top().to;
		int y=q.top().w;
		int z=q.top().p;
		q.pop();
		if(vis[x].count(z)) continue;
		vis[x][z]=1;
		d[x]=min(d[x],y);
		int len=vec[x].size();
		for(int i=0;i<len;i++)
		{
			int l=vec[x][i].second;
			int to=vec[x][i].first;
			int val;
			if(z-1==i) val=0;
			else if(z-1>i) val=w[z]-w[i+1];
			else val=v[i]-v[z-1];
			if(!dis[to].count(i+1)||dis[to][i+1]>dis[x][z]+l+val)
			{
				dis[to][i+1]=dis[x][z]+l+val;
				q.push({dis[to][i+1],to,i+1});
			}
		}
	}
}
void init()
{
	cin>>c;
    cin>>n>>m>>k;
	for(int i=1;i<=k-1;i++) cin>>v[i],v[i]+=v[i-1];
	for(int i=2;i<=k;i++) cin>>w[i],w[i]+=w[i-1];
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		for(int j=1;j<=x;j++) 
		{
			int v,w;
			cin>>v>>w;
			vec[i].push_back({v,w});
		}
	}
}
void print()
{
	for(int i=1;i<=n;i++) cout<<(d[i]==0x3f3f3f3f3f3f3f3f?-1:d[i])<<" ";
}
signed main()
{ 
	init();
	dijkstra(1);
	print();
    return 0;
}

---

## 作者：UNDERTALE_RS (赞：7)

# P13271 [NOI2025] 机器人 题解

[题目传送门](https://www.luogu.com.cn/problem/P13271)

## 前言

这是绿勾蒟蒻第一次写 NOI 题解，部分地方可能真的不太到位，且做法很直接，各位 dalao 轻喷，感谢了！

## 题目分析

看到题目，我们可以发现这与一般的图论最短路问题不太一样，本题多了参数 $p$。  
那么我们就要在一般的最短路算法上加以调整，以通过此题。

### 建图

我们存储每一条边的信息来保存这 $n$ 个路口和 $m$ 条道路组成的图。

我们可以发现，在求解答案时，每条边的**编号**也是需要知道的。

那么对于每一条边，我们存储它的起点 $u$、终点 $v$、长度 $w$ 以及编号 $idx$。

此处使用**链式前向星**的形式存储。代码如下：  

```cpp
int head[MAXN], JS;
struct edge{
	long long v, w, idx, nxt;
} edges[MAXN];
inline void add_eg(int u, int v, int w, int idx){ edges[++JS] = {v, w, idx, head[u]}, head[u] = JS; }
```

### 最短路算法调整

#### 同一点上不同参数

我们知道，对于每一个可以直接由**一条边**到达点 $v$ 的点 $u$，该条边的编号不一定相同。  
这就会导致在点 $v$ 上的机器人其参数 $p$ **不是唯一**的。

由于这些不同的参数 $p$ 的个数由 $m$ 的大小决定，且 $m \le 3 \times 10^5$。  
那么我们可以把每个点上所有可能的参数 $p$ （即对应编号）的值列举并存储。

这样，在计算最短路时，我们就不会遗漏每个点上的每个状态，从而求出正确答案。

这里我们可以偷懒，使用 map 容器存储每个点上可能的状态，从而省去离散化等一类的操作。

部分代码如下：  

```cpp
int C, n, m, k;
long long  V[MAXN], W[MAXN];
map <int, bool> vis[MAXN];  // 存储该状态是否访问过
map <int, long long> dis[MAXN];  // 存储距离
vector <long long> idx_list[MAXN];  // 可能的 p 值

for(int u = 1, d; u <= n; u++){
    d = read();
    for(int j = 1, v, w; j <= d; j++){
        v = read(), w = read();
		idx_list[v].push_back(j);
		add_eg(u, v, w, j);
	}
}
for(int u = 1; u <= n; u++)
    for(int p : idx_list[u])
        vis[u][p] = 0, dis[u][p] = INF;  // 提前初始化
```

#### 快速求出修改代价

我们可以发现，若要将参数 $p$ 修改为 $q$，所要花总代价是一段**区间和**。具体来说，设总代价为 $W$，则：  
$$
W =  \begin{cases}
  0 & p = q \\
  \sum_{i = p}^{q-1} v_i & p < q \\
  \sum_{i = q+1}^{p} w_i & p > q
\end{cases}
$$

那么我们只要计算出修改代价数组的**前缀和**就可以快速计算了。

代码如下：  

```cpp
long long Get(int p, int q){
	if(p == q) return 0;
	if(p < q && p < k) return V[q - 1] - V[p - 1];
	if(p > q && p > 1) return W[p] - W[q + 1 - 1];
	return INF;
}
```

#### 套用最短路模板

我们使用 dijkstra 算法来求出答案。

在一般算法的基础上，对于每一个状态，我们再存储一个参数 $p$。  
同时在计算到下一个点的代价时，加上所要修改的代价。

最终代码如下：  

```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
#include <array>
#include <map>
using namespace std;
const int MAXN = 3e5 + 5;
const long long INF = 0x3f3f3f3f3f3f3f3f;
inline int read(){  // 输入过大 使用快读
	int ret = 0, sign = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') sign = (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= '0' && ch <= '9') ret = (ret << 1) + (ret << 3) + (ch ^ 48), ch = getchar();
	return sign > 0 ? ret : -ret;
}
int C, n, m, k;
long long  V[MAXN], W[MAXN];
map <int, bool> vis[MAXN];
map <int, long long> dis[MAXN];
vector <long long> idx_list[MAXN]; 

int head[MAXN], JS;
struct edge{
	long long v, w, idx, nxt;
} edges[MAXN];
inline void add_eg(int u, int v, int w, int idx){ edges[++JS] = {v, w, idx, head[u]}, head[u] = JS; }

long long Get(int p, int q){
	if(p == q) return 0;
	if(p < q && p < k) return V[q - 1] - V[p - 1];
	if(p > q && p > 1) return W[p] - W[q + 1 - 1];
	return INF;
}

void dijkstra(int s, int p){
	priority_queue <array<long long, 3> > pq;
	dis[s][p] = 0, pq.push({-dis[s][p], s, p});
 // 存储负值以便排序时直接让代价最小值在优先队列的队首（默认按第一个值从大到小排，接着顺着往后面排）
	while(!pq.empty()){
		int u = pq.top()[1], p = pq.top()[2];
		pq.pop();
		if(vis[u][p]) continue;
		vis[u][p] = 1;
		for(int i = head[u]; i; i = edges[i].nxt){
			long long v = edges[i].v, w = edges[i].w, idx = edges[i].idx;
			if(dis[v][idx] > dis[u][p] + w + Get(p, idx)){
				dis[v][idx] = dis[u][p] + w + Get(p, idx);
				pq.push({-dis[v][idx], v, idx});  // 存负值同上
			}
		} 
	}
}

int main(){
	C = read(), n = read(), m = read(), k = read();
	for(int i = 1; i <= k - 1; i++) V[i] = read(), V[i] += V[i - 1];
	for(int i = 2; i <= k; i++) W[i] = read(), W[i] += W[i - 1];
	for(int u = 1, d; u <= n; u++){
		d = read();
		for(int j = 1, v, w; j <= d; j++){
			v = read(), w = read();
			idx_list[v].push_back(j);
			add_eg(u, v, w, j);
		}
	}
	for(int u = 1; u <= n; u++)
		for(int p : idx_list[u]) vis[u][p] = 0, dis[u][p] = INF;
	dijkstra(1, 1);
	for(int i = 1; i <= n; i++){
		if(i == 1){
			cout << 0 << " ";
			continue;
		}
		long long minn = INF;
		for(int j : idx_list[i])
			minn = min(minn, dis[i][j]);
		if(minn >= INF) cout << -1 << " ";
		else cout << minn << " ";
	}
	return 0;
}
```


## 总结
本题考察图论最短路及分层图。~~（本蒟蒻为数不多能做的 NOI 题）~~

感谢您的阅读！

---

## 作者：I_will_AKIOI (赞：6)

场外选手成功爆切 NOI 题，已经比我省选分数高了！

首先发现要输出到每个点的最小花费，容易想到单源最短路。但是题目还有一个 $p$，因此我们设状态 $d_{x,p_1}$ 表示走到节点 $i$，并且 $p=p_1$ 的最小花费。

考虑枚举 $x$ 的出边 $e$ 进行转移，$e$ 从 $x$ 到达点 $y$，边权为 $z$。记录 $e$ 在 $x$ 出边的编号 $p_2$。则若 $d_{x,p_1}+z+\operatorname{calc}(p_1,p_2)<d_{y,p_2}$，则可以转移。$\operatorname{calc}(p_1,p_2)$ 表示把机器人参数从 $p_1$ 改为 $p_2$ 的花费，可以前缀和搞一搞。时间复杂度 $O(nk\log m)$，可以获得 $40$ 分。

我们注意到状态从 $d_{x,p_1}$ 变为 $d_{y,p_2}$ 时，经过的边 $e$ 在 $x$ 出边中的编号是不变的。也就是 $e$ 对应的 $p_2$ 不变。因此对于状态 $d_{x,p_1}$，每个 $p_1$ 都对应一条边。由于边数总和为 $m$，因此状态只有 $m$ 个。

所以考虑用边的编号代替每一个状态，为每一条边分配一个编号，状态变为 $d_i$ 表示上一条走的是第 $i$ 条边的最小花费，就可以做到 $O(m\log m)$ 了。注意到初始状态没有入边，给 $1$ 前面连上一个 $0$，设为第 $0$ 条边，然后就做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 300005
using namespace std;
struct Edge{int to,val,p1,p2;}w[N];//p1 表示在 x 出边中的编号，p2 表示全局编号
struct Data
{
	int num,val;
	bool operator<(const Data &w)const{return w.val<val;}
};
int sub,n,m,k,cnt,a[N],b[N],d[N],res[N];
bool vis[N];
vector<Edge>v[N];
priority_queue<Data>q;
int calc(int x,int y)//算 p=x 变为 y 的花费
{
	x++,y++;
	if(x>k||y>k) return 1e18;
	if(x<y) return a[y-1]-a[x-1];
	return b[x]-b[y];
}
void dijkstra()
{
	for(int i=1;i<=m;i++) d[i]=1e18;
	q.push({0,0});
	while(!q.empty())
	{
		int p2=q.top().num,p1=w[p2].p1,x=w[p2].to;
		q.pop();
		if(vis[p2]) continue;
		vis[p2]=1;
		for(auto now:v[x])
		{
			int y=now.to,z=now.val,p3=now.p1,p4=now.p2;
			int cost=calc(p1,p3);
			if(d[p2]+z+cost<d[p4]) d[p4]=d[p2]+z+cost,q.push({p4,d[p4]});
		}
	}
	return;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>sub>>n>>m>>k;
	for(int i=1;i<k;i++) cin>>a[i],a[i]+=a[i-1];
	for(int i=2;i<=k;i++) cin>>b[i],b[i]+=b[i-1];
	v[0].push_back({1,0,0}),w[0]={1,0,0,0};
	for(int i=1;i<=n;i++)
	{
		int d;
		cin>>d;
		v[i].resize(d);
		for(int j=0;j<d;j++)
		{
			cnt++;
			cin>>w[cnt].to>>w[cnt].val;
			w[cnt].p1=j,w[cnt].p2=cnt;
			v[i][j]={w[cnt].to,w[cnt].val,j,cnt};
		}
	}
	dijkstra();
	for(int i=1;i<=n;i++) res[i]=1e18;
	for(int i=0;i<=m;i++) res[w[i].to]=min(res[w[i].to],d[w[i].p2]);//枚举最后走的边计算答案
	for(int i=1;i<=n;i++) cout<<((res[i]==1e18)?-1:res[i])<<" ";
	return 0;
}
```

---

## 作者：WorldMachine (赞：6)

板。

考虑拆状态，记 $(u,k)$ 表示当前走到 $u$ 号点并且参数值为 $k$，这样有用的状态只有 $d_u$ 个，建出来一共就只有 $\mathcal O(m)$ 个点。

发现不管在哪个点修改 $k$ 花的代价都是相同的，因此可以让 $(u,k-1)$ 向 $(u,k)$ 连边权为 $v_{k-1}$ 的边，后者向前者连边权为 $w_k$ 的边。设 $v=d_{u,k}$，若 $d_v\ge k$，则 $(u,k)$ 向 $(v,k)$ 连一条对应边权的边；否则 $(u,k)$ 向 $(v,d_v)$ 连一条边权为原边权再额外加上 $\sum\limits_{i=d_v+1}^kw_i$ 的边，建完图后从 $(1,1)$ 开始跑单源最短路即可。

但这样有一个问题，最后停在 $u$ 号点时的 $k$ 可以大于 $d_u$，因此新建状态 $\text{end}_u$ 表示停在 $u$ 号点且 $k>d_u$，注意 $\text{end}_u$ 是不需要向其它状态连边的，因为它仅作为终点，在 $k>d_v$ 时往 $\text{end}_v$ 连边即可。

时间复杂度为 $\mathcal O((n+m)\log m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef pair<int, int> pii;
const int N = 6e5 + 5, INF = 1e18;
int task_id, n, m, k, v[N], w[N], sv[N], sw[N], t, d[N], l[N], r[N], dis[N];
vector<pii> E[N], G[N]; bool vis[N];
void dijkstra(int s) {
	priority_queue<pii, vector<pii>, greater<pii> > Q;
	memset(dis, 0x3f, sizeof(dis)), dis[s] = 0, Q.push({0, s});
	while (Q.size()) {
		int u = Q.top().second; Q.pop(); if (vis[u]) continue; vis[u] = 1;
		for (auto [v, w] : G[u]) if (dis[v] > dis[u] + w) dis[v] = dis[u] + w, Q.push({dis[v], v});
	}
}
signed main() {
	// freopen("robot.in", "r", stdin), freopen("robot.out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> task_id >> n >> m >> k;
	for (int i = 1; i < k; i++) cin >> v[i], sv[i] = sv[i - 1] + v[i];
	for (int i = 2; i <= k; i++) cin >> w[i], sw[i] = sw[i - 1] + w[i];
	for (int i = 1; i <= n; i++) {
		cin >> d[i], l[i] = t + 1, r[i] = t + d[i] + 1, t += d[i] + 1, E[i].emplace_back(0, 0);
		// cerr << l[i] << ' ' << r[i] << '\n';
		for (int j = 1, y, z; j <= d[i]; j++) cin >> y >> z, E[i].emplace_back(y, z);
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= d[i]; j++) {
			int y = E[i][j].first, z = E[i][j].second;
			if (j <= d[y]) G[l[i] + j - 1].emplace_back(l[y] + j - 1, z);
			else {
				if (d[y]) G[l[i] + j - 1].emplace_back(r[y] - 1, z + sw[j] - sw[d[y]]);
				G[l[i] + j - 1].emplace_back(r[y], z);
			}
			if (j > 1) {
				G[l[i] + j - 2].emplace_back(l[i] + j - 1, v[j - 1]);
				G[l[i] + j - 1].emplace_back(l[i] + j - 2, w[j]);
			}
		}
	}
	// for (int i = 0; i <= n; i++) for (auto [v, w] : G[i]) cerr << i << ' ' << v << ' ' << w << '\n';
	dijkstra(1);
	for (int i = 1; i <= n; i++) {
		int mn = INF;
		for (int j = l[i]; j <= r[i]; j++) mn = min(mn, dis[j]);
		cout << (mn == INF ? -1 : mn) << ' ';
	}
}
```

---

## 作者：CaiZi (赞：4)

蒟蒻第一次写 NOI 题解！

看这种东西考虑直接拆点，先考虑朴素的暴力，把点 $i$ 拆成 $k$ 个点 $(i,1),(i,2),\cdots,(i,k-1),(i,k)$，后一个元素表示 $p$ 的值。

对于点 $(i,j)$ 和点 $(i,j+1)$，连一条权值为 $v_p$ 的边；点 $(i,j)$ 和点 $(i,j-1)$，连一条权值为 $w_p$ 的边；点 $(i,j)$ 和点 $(y_{i,j},j)$ 连一条权值为 $z_{i,j}$ 的边。然后跑最短路即可。

然后你发现一个很难绷的事，若点 $(i,j)$ 满足 $j>d_i$ 且不存在 $u$ 使得 $y_{u,j}=i$，则这个点是无必要的。进一步考虑，对于所有满足 $j>d_i$ 且有必要的点 $(i,j)$，直接向 $(i,d_i)$ 连一条权值为 $\sum_{i=d_i+1}^jb_j$ 的边即可，使用前缀和可以快速求出花费。于是点的个数最多就只剩下 $2\sum_{i=1}^nd_i=2m$ 了。

这样实现可能有点麻烦，我们也不需要离散化，直接用 map 存最短路即可，也不需要实际意义上的连边。

设 $n,m,k$ 同阶，时间复杂度 $O(n\log n)$。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int t,r,w;
	inline friend bool operator < (node _1,node _2){
		return _1.w>_2.w;
	}
}u;
int _,n,m,k,a[250001],b[250001],e,x,y;
vector<pair<int,int>>g[300001];
map<int,int>s[300001];
priority_queue<node>q;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>_>>n>>m>>k;
	for(int i=1;i<=k-1;i++){
		cin>>a[i];
		a[i]+=a[i-1];
	}
	for(int i=2;i<=k;i++){
		cin>>b[i];
		b[i]+=b[i-1];
	}
	for(int i=1;i<=n;i++){
		cin>>e;
		for(int j=1;j<=e;j++){
			cin>>x>>y;
			g[i].push_back(make_pair(x,y));
			s[i][j]=LONG_LONG_MAX;
			s[x][j]=LONG_LONG_MAX;
		}
	}
	s[1][1]=0;
	q.push(node{1,1,s[1][1]});
	while(!q.empty()){
		u=q.top();
		q.pop();
		if(s[u.t][u.r]!=u.w){
			continue;
		}
		if(u.r<=g[u.t].size()){
			if(u.r<g[u.t].size()&&u.w+a[u.r]-a[u.r-1]<s[u.t][u.r+1]){
				s[u.t][u.r+1]=u.w+a[u.r]-a[u.r-1];
				q.push(node{u.t,u.r+1,s[u.t][u.r+1]});
			}
			if(u.r>1&&u.w+b[u.r]-b[u.r-1]<s[u.t][u.r-1]){
				s[u.t][u.r-1]=u.w+b[u.r]-b[u.r-1];
				q.push(node{u.t,u.r-1,s[u.t][u.r-1]});
			}
			if(u.w+g[u.t][u.r-1].second<s[g[u.t][u.r-1].first][u.r]){
				s[g[u.t][u.r-1].first][u.r]=u.w+g[u.t][u.r-1].second;
				q.push(node{g[u.t][u.r-1].first,u.r,s[g[u.t][u.r-1].first][u.r]});
			}
		}
		else{
			if(g[u.t].size()!=0&&u.w+b[u.r]-b[g[u.t].size()]<s[u.t][g[u.t].size()]){
				s[u.t][g[u.t].size()]=u.w+b[u.r]-b[g[u.t].size()];
				q.push(node{u.t,g[u.t].size(),s[u.t][g[u.t].size()]});
			}
		}
	}
	for(int i=1;i<=n;i++){
		x=LONG_LONG_MAX;
		for(pair<int,int>j:s[i]){
			x=min(x,j.second);
		}
		if(x==LONG_LONG_MAX){
			cout<<"-1 ";
		}
		else{
			cout<<x<<' ';
		}
	}
	return 0;
}
```

---

## 作者：Walrus (赞：3)

## Solution

比较典型的分层图类型最短路。其实按理说它并不是类似于飞行路线一样的分层图最短路，它涉及同一个点之间的互相转移，这里定义「$x$ 号点 $y$ 状态」表示题目中说的从 $x$ 出发的第 $y$ 条边。

发现这种最短路不好维护点，考虑维护**边**，考虑给这 $m$ 条边标号为 $1\sim m$，并定义 $dis_i$ 表示从 $1$ 号点 $1$ 状态到 $x$ 号点 $y$ 状态的代价最小值，其中 $x$ 号点 $y$ 状态的编号是 $i$，这样的最短路是很好维护的。

那么接下来考虑我们维护出的 $dis_i$ 是什么意思，它指的是从 $1$ 号点 $1$ 状态到 $x$ 号点 $y$ 状态的最小代价，那么也就意味着此时在 $x$ 号点，则这种维护边的最短路同时也维护了点，枚举每一条边，可知答案为：

$$ans_i=\min\limits_{edge\_start_j=i} dis_j$$

$edge\_start$ 表示每条边的起点。

---

接下来考虑怎么连边，比较容易的是对于每条边 $u\to v$，意义是从 $u$ 号点 $p$ 状态到 $v$ 号点 $p$ 状态，然后还有同一个点不同状态的转移，这其实也是容易的，将题目中的 $w$ 和 $v$ 做一下前缀和即可快速实现同一个点不同状态的转移，具体实现可以看代码。

注意这里我为了偷懒如果 $v$ 号点没有第 $p$ 条边我也正常连了边，但这样没有影响，因为最后我们只会枚举输入的 $m$ 条边统计答案。

code 暂时通过了民间数据。

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr)
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define pb emplace_back
#define PII pair<int, int>
#define fi first
#define se second
#define fv inline void
#define int long long
using namespace std;
using i32 = long long;
using i64 = __int128;
using u32 = unsigned long long;

const int N = 1e6 + 5;
const int mod = 998244353;

#define cmax(a, b) (a = a > b ? a : b)
#define cmin(a, b) (a = a < b ? a : b)
#define cadd(a, b) (a = ((a + b) % mod + mod) % mod)
#define cdel(a, b) (a = ((a - b) % mod + mod) % mod)

i32 testid, n, m, k, x, u, v, w, dis[N], vis[N], out[N], add[N], del[N], ans[N], id[N], tt;
vector<PII> e[N];
vector<int> g[N];
map<i32, i32> mp[N];

struct node {
    i32 dis, u;
    bool operator < (const node &a) const {return dis > a.dis;}
} ;

fv dij(int s) {
	rep(i, 1, tt) dis[i] = 1e16;
    priority_queue<node> q; dis[s] = 0; q.push({0, s});
    while(q.size()) {
        int u = q.top().u; q.pop();
        if(vis[u]) continue; vis[u] = 1;
        for(auto ed : e[u]) {
            int v = ed.fi, w = ed.se;
            if(dis[v] > dis[u] + w) dis[v] = dis[u] + w, q.push({dis[v], v});
        }
    }
}

signed main() {
    FASTIO;
// #ifdef gm
    // freopen("std.in", "r", stdin);
    // freopen("1.out", "w", stdout);
// #else
    //  freopen("robo.in", "r", stdin);
    //  freopen("robo.out", "w", stdout);
// #endif

    cin >> testid;
    cin >> n >> m >> k;
    rep(i, 1, k - 1) cin >> add[i], add[i] += add[i - 1];
    rep(i, 2, k) cin >> del[i], del[i] += del[i - 1];

    rep(i, 1, n) {
        cin >> out[i], ans[i] = 1e16;
        rep(j, 1, out[i]) {
        	cin >> v >> w;
        	if(!mp[i][j]) mp[i][j] = ++tt, id[tt] = i, g[i].pb(j);
        	if(!mp[v][j]) mp[v][j] = ++tt, id[tt] = v, g[v].pb(j);
            e[mp[i][j]].pb(mp[v][j], w);
//            if(j != 1 && j <= k) e[mp[i][j - 1]].pb(mp[i][j], add[j - 1]), e[mp[i][j]].pb(mp[i][j - 1], del[j]);
        }
    }
    rep(i, 1, n) sort(g[i].begin(), g[i].end());
	rep(i, 1, n) {
		if(g[i].size() < 2) continue;
		rep(j, 1, g[i].size() - 1) e[mp[i][g[i][j]]].pb(mp[i][g[i][j - 1]], del[g[i][j]] - del[g[i][j - 1]]), e[mp[i][g[i][j - 1]]].pb(mp[i][g[i][j]], add[g[i][j] - 1] - add[g[i][j - 1] - 1]);
	}
    dij(1); 
    i32 ret = 0;
    rep(i, 1, tt) cmin(ans[id[i]], dis[i]);
    rep(i, 1, n) if(ans[i] == 1e16) ans[i] = -1;
    rep(i, 1, n) cout << ans[i] << ' ';
//    cout << '\n';
//    rep(i, 1, n) ret ^= ans[i]; 
    // rep(i, 1, n) cout << (ans[i] == 1e16 ? -1 : ans[i]) << ' ';
//    cout << ret << ' ' << ans[7];
    return 0;
}
```

---

## 作者：StarsIntoSea_SY (赞：2)

说实话，一个从来没有一等的蒟蒻能一眼看出这题是分层图最短路我自己都不相信。

# Solution

因为要处理每个点的参数 $p$ 这种状态，很自然想到对图分层来表示这种状态，设 $(i,j)$ 为当前点 $i$，且 $p=j$。

首先是改变 $p$ 而建边：

1. $(i,j)$ 向 $(i,j+1)$ 建一条边权为 $v_j$ 的边。
2. $(i,j+1)$ 向 $(i,j)$ 建一条边权为 $w_{j+1}$ 的边。

需要注意 $j+1$ 要始终小于等于 $d_i$。

因为 $\sum_{i=1}^n d_i = m$，所以这里的空间复杂度和边的规模是 $O(m)$。

然后是走到其他点而建边：

1. 若 $j \le d_{y_{i,j}} $，$(i,j)$ 向 $(y_{i,j},j)$ 建一条边权为 $z_{i,j}$ 的边。
2. 若 $j > d_{y_{i,j}} $， $(i,j)$ 向 $(y_{i,j},d_{y_{i,j}})$ 建一条边权为 $z_{i,j}+\sum_{t=d_{y_{i,j}}+1}^{j} w_j$ 的边，并且向 $(y_{i,j},0)$ 建一条边权为 $z_{i,j}$ 的边。

像 $(i,0)$ 这样的点是因为走到这个点之后可以不再做任何操作，前者是因为可以改变 $p$ 值而走到别的点。

因为 $\sum_{i=1}^n d_i = m$，所以这里的空间复杂度和边的规模也是 $O(m)$。

一个点 $i$ 的答案显然是 $(i,k)$ 中的最小值。

~~出题人不卡 SPFA，所以时间复杂度一目了然。~~

# Code

```cpp
#include <stdio.h>
#include <iostream>
#include <map>
#include <vector>
#include <queue>
using namespace std;
#define ll long long
const int N=2e6+5;
struct edge{int to,ne;ll C;}e[N<<2];
int h[N],id=0,WERT;
map< pair<int,int>,int> mp;
map< int,pair<int,int>> MP;
vector<int> a[N];
struct node{int y,wc,ip;};
vector<node> p[N];
void add(int a,int b,ll c){
	e[++id].to=b;e[id].ne=h[a];e[id].C=c;
	h[a]=id;
}
int n,m,k,v[N],w[N],d[N];
ll sumv[N],sumw[N];
int idx;
void Add(int x,int y){
	mp[{x,y}]=++idx;
	a[x].push_back(idx);
}

ll dis[N];
int vis[N];
queue<int> q;
void SPFA(){
	for(int i=0;i<=idx+1;++i) dis[i]=1e18;
	dis[mp[{1,1}]]=0;
	q.push(mp[{1,1}]);
	while(!q.empty()){
		int u=q.front();
		q.pop(); vis[u]=0;
		for(int i=h[u];i;i=e[i].ne){
			int v=e[i].to;
			if(dis[u]+e[i].C<dis[v]){
				dis[v]=dis[u]+e[i].C;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	printf("0 ");
	for(int i=2;i<=n;++i){
		ll ans=1e18;
		for(int sy:a[i]) ans=min(ans,dis[sy]);
		printf("%lld ",ans==1e18?-1:ans);
	}
	printf("\n");
}

int main(){
	freopen("robot3.in","r",stdin);
	
	scanf("%d%d%d%d",&WERT,&n,&m,&k);
	idx=0;
	for(int i=1;i<k;++i) scanf("%d",&v[i]),sumv[i]=sumv[i-1]+(ll)v[i];
	for(int i=2;i<=k;++i) scanf("%d",&w[i]),sumw[i]=sumw[i-1]+(ll)w[i];
	for(int i=1;i<=n;++i) Add(i,0);
	for(int i=1;i<=n;++i){
		scanf("%d",&d[i]);
		for(int j=1;j<=d[i];++j){
			Add(i,j);
			int u,c; scanf("%d%d",&u,&c);
			p[i].push_back((node){u,c,j});
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<d[i];++j){
			add(mp[{i,j}],mp[{i,j+1}],v[j]);
			add(mp[{i,j+1}],mp[{i,j}],w[j+1]);
		}
	}
	for(int i=1;i<=n;++i){
		for(auto r:p[i]){
			if(d[r.y]>=r.ip){
				add(mp[{i,r.ip}],mp[{r.y,r.ip}],r.wc);
			}
			else{
				add(mp[{i,r.ip}],mp[{r.y,0}],r.wc);
				add(mp[{i,r.ip}],mp[{r.y,d[r.y]}],(ll)r.wc+(ll)sumw[r.ip]-(ll)sumw[d[r.y]]);
			}
		}
	}
	SPFA();
}
```

---

## 作者：five_rice_water (赞：2)

十五分钟切了NOID1T1！！！

这道题其实并不难，重点是要想清楚一件事情。

读完题目，第一反应应该是分层图最短路。

首先，朴素的思想是建一个 $n\times k$ 个点的分层图。但是这样处理会导致时间空间全部炸，怎么办呢？

继续观察题面，不难发现边的数量是 $3\times 10^5$，而每条边都只可能对另一端的点产生一种不同的 $p$ 的情况。

所以这张分层图总的点数也就是在 $3\times 10^5$ 这个级别。

那么我们就可以用一个 map 来存这些信息，时间复杂度就是朴素的 dijkstra 算法的复杂度乘上 map 的复杂度。

具体实现有一些小细节，可以参考一下代码。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 3e5 + 5;
int T, n, m, k, w[N], v[N], ans[N];

struct node {
	int v, w;
};
vector<node>e[N];
map<int, int>dis[N], vis[N];

struct status {
	int x, dis, p;
	friend bool operator <(status a, status b) {
		return a.dis > b.dis;
	}
};

int cost(int p, int id) {//计算p变成id的代价 可以思考一下为什么这样去算
	if (p == id)
		return 0;
	if (p > id) {
		return w[p] - w[id];
	} else {
		return v[id - 1] - v[p - 1];
	}
}

void dijkstra() {
	for (int i = 1; i <= n; i++) {
		ans[i] = 9e18;
	}
	ans[1] = 0;
	priority_queue<status>q;
	dis[1][1] = 0;
	q.push((status) {
		1, 0, 1
	});
	while (!q.empty()) {
		status tmp = q.top();
		q.pop();
		int x = tmp.x;
		int Dis = tmp.dis;
		int P = tmp.p;
		if (vis[x].count(P)) {
			continue;
		}
		ans[x] = min(ans[x], Dis);
		vis[x][P] = 1;
		for (int i = 0; i < e[x].size(); i++) {
			int id = i + 1;
			int V = e[x][i].v;
			int W = e[x][i].w;
			if (!dis[V].count(id) || dis[V][id] > dis[x][P] + cost(P, id) + W) {
				dis[V][id] = dis[x][P] + cost(P, id) + W;
				q.push((status) {
					V, dis[V][id], id
				});
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		if (ans[i] == 9e18)
			cout << -1 << " ";
		else
			cout << ans[i] << " ";
	}
}

signed main() {
	cin >> T >> n >> m >> k;
	for (int i = 1; i < k; i++) {
		cin >> v[i];
		v[i] += v[i - 1];
	}
	for (int i = 2; i <= k; i++) {
		cin >> w[i];
		w[i] += w[i - 1];
	}
	for (int i = 1; i <= n; i++) {
		int cnt;
		cin >> cnt;
		for (int j = 1; j <= cnt; j++) {
			int y, z;
			cin >> y >> z;
			e[i].push_back((node) {
				y, z
			});
		}
	}
	dijkstra();
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：2)

考虑对 $1 \sim k$ 分层，跑最短路的时候分类讨论一下前往下一层、上一层和当前层的情况（到下一层代价 $v_p$，上一层代价 $w_p$）。注意到这样子遍历层的规模是 $O(nk)$ 级别的，会超时，于是考虑优化。

具体来说，当我们处于 $p > d_x$（$x$ 为当前点）时，可以直接跳到 $\min(p, d_x)$ 层，其间代价可以前缀和预处理掉，这样子我们遍历的规模降到了 $O(\sum d_i)$。

总时间复杂度 $O(\sum d_i \log nk)$，可以过。

代码如下：

```cpp
/*
 * author: LostKeyToReach
 * created time: 2025-07-17 18:36:17
 */
#include <bits/stdc++.h>
#define int long long
#define vi vt<int>
#define fr first
#define se second
using ll = long long; using pii = std::pair<int, int>;
template<typename T> using vt = std::vector<T>;
#define all(x) (x).begin(),(x).end()
#define sz(x) ((int)(x).size())
#define S std::ios::sync_with_stdio(0), \
std::cin.tie(0), std::cout.tie(0)
template<typename T> T chkmax(T& x, T y) {
    return (x < y) ? (x = y, y) : x;
} template<typename T> T chkmin(T& x, T y) {
    return (x > y) ? (x = y, y) : x;
}int fio = (S, 0); constexpr int N = 5e5 + 5;
constexpr int INF = 1e18;
typedef std::tuple<int, int, int> triple;
int32_t main() { int c; std::cin >> c;
    int n, m, k; std::cin >> n >> m >> k;
    vi v(k), w(k + 1), d(n);
    for (int i = 1; i < k; ++i) std::cin >> v[i];
    for (int i = 2; i <= k; ++i) std::cin >> w[i], w[i] += w[i - 1];
    vt<vt<pii>> adj(n + 1);
    vt<std::map<int, int>> dist(n + 1); // dist[i][j] : 第j层1~i答案
    for (int i = 1; i <= n; ++i) {
        std::cin >> d[i]; dist[i][0] = INF;
        adj[i].emplace_back(0, 0); // 占位
        for (int j = 1; j <= d[i]; ++j) {
            int y, z; std::cin >> y >> z;
            adj[i].emplace_back(y, z);
            dist[i][j] = dist[y][j] = INF;
        }
    } std::priority_queue<triple, vt<triple>, std::greater<triple>> pq;
    dist[1][1] = 0, pq.emplace(0, 1, 1);
    while (!pq.empty()) {
        int dd, x, l, y, z;
        std::tie(dd, x, l) = pq.top(); pq.pop();
        // std::cout << "cross " << x << " " << l << "\n";
        if (l > 1 && dist[x].count(l - 1)) { // l => l - 1
            if (dist[x][l - 1] > dist[x][l] + w[l] - w[l - 1]) { // 这里是 w'_l - w'_{l - 1} = w_l
                dist[x][l - 1] = dist[x][l] + w[l] - w[l - 1];
                pq.emplace(dist[x][l - 1], x, l - 1);
            }
        } if (l < k && dist[x].count(l + 1)) { // l => l + 1
            if (dist[x][l + 1] > dist[x][l] + v[l]) {
                dist[x][l + 1] = dist[x][l] + v[l];
                pq.emplace(dist[x][l + 1], x, l + 1);
            }
        } if (l >= sz(adj[x])) continue;
        std::tie(y, z) = adj[x][l];
        if (dist[y][l] > dist[x][l] + z) { // l 当层转移
            dist[y][l] = dist[x][l] + z;
            pq.emplace(dist[y][l], y, l);
        } int lim = std::min(d[y], l);
        int cost = w[l] - w[lim]; // l => lim l ... lim + 1
        if (dist[y][lim] > dist[x][l] + z + cost) {
            dist[y][lim] = dist[x][l] + z + cost;
            pq.emplace(dist[y][lim], y, lim);
        }
    } int ans = INF;
    for (int i = 1; i <= n; ++i) {
        ans = INF;
        for (auto&d : dist[i])
            chkmin(ans, d.se);
        if (ans == INF) ans = -1;
        std::cout << ans << " \n"[i == n];
    } 
}
```

---

## 作者：Unnamed114514 (赞：2)

定义 $f(u,k)$ 表示点 $u$ 点参数为 $k$ 的最段路。

考虑哪些 $k$ 有用：容易发现对于一个点，只有两种参数有用，一种是 $[1,d_i]$，第二种是其它的点通过一条边转移过来，因为拆点的缘故所以到这里来的时候参数显然是没变的。

容易发现点数和边数都是 $O(\sum d+m)$ 的，问题转化为最段路板子，随便搞一下就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=3e5+5;
int c,n,m,k,tot,v[N],w[N],d[N],ans[N],dis[N<<1];
bool vis[N<<1];
vector<int> a[N];
vector<pair<int,int> > G[N],g[N<<1];
pair<int,int> p[N<<1];
map<pair<int,int>,int> id;
priority_queue<pair<int,int> > q;
void dij(){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[1]=0;
	q.emplace(make_pair(0,1));
	while(q.size()){
		int u=q.top().second;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		if(ans[p[u].first]==-1) ans[p[u].first]=dis[u];
		else ans[p[u].first]=min(ans[p[u].first],dis[u]);
		for(auto H:g[u]){
			int v=H.first,w=H.second;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.emplace(make_pair(-dis[v],v));
			}
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>c>>n>>m>>k;
	for(int i=0;i<k-1;++i) cin>>v[i];
	for(int i=1;i<k-1;++i) v[i]+=v[i-1];
	for(int i=1;i<k;++i) cin>>w[i];
	for(int i=1;i<k;++i) w[i]+=w[i-1];
	a[1].emplace_back(0);
	for(int i=1;i<=n;++i){
		cin>>d[i];
		G[i].resize(d[i]);
		for(int j=0;j<d[i];++j) a[i].emplace_back(j);
		for(int j=0;j<d[i];++j){
			cin>>G[i][j].first>>G[i][j].second;
			a[G[i][j].first].emplace_back(j);
		}
	}
	for(int i=1;i<=n;++i){
		if(a[i].empty()) continue;
		sort(a[i].begin(),a[i].end());
		a[i].erase(unique(a[i].begin(),a[i].end()),a[i].end());
		p[++tot]=make_pair(i,a[i][0]);
		id[make_pair(i,a[i][0])]=tot;
		for(int j=1,len=a[i].size();j<len;++j){
			p[++tot]=make_pair(i,a[i][j]);
			id[make_pair(i,a[i][j])]=tot;
			g[tot-1].emplace_back(make_pair(tot,v[a[i][j]-1]-v[a[i][j-1]-1]));
			g[tot].emplace_back(make_pair(tot-1,w[a[i][j]]-w[a[i][j-1]]));
		}
	}
	for(int i=1;i<=n;++i) for(int j=0;j<d[i];++j) g[id[make_pair(i,j)]].emplace_back(make_pair(id[make_pair(G[i][j].first,j)],G[i][j].second));
	memset(ans,-1,sizeof(ans));
	dij();
	for(int i=1;i<=n;++i) cout<<ans[i]<<' ';
	cout<<endl;
	return 0;
}
```

---

## 作者：fkxr (赞：1)

## 前言
![](https://cdn.luogu.com.cn/upload/image_hosting/z10w35vl.png)

取自[这里](https://www.luogu.com.cn/article/k9vfpa4l)第一行，膜拜一下。
## 题解部分
第一眼看到题：板子分层图。看到数据范围：谁家分层图 $k\le2.5\times10^5$ 啊。

下文认为 $n,m,k$ 同阶。

发现特殊性质 C 的格式很像根号分治，所以发现有用的 $p$ 只有 $O(n^{0.5})$ 种取值（用根号分治的思路，度数大于 $O(n^{0.5})$ 再讨论），跑分层图。用这个思路可以得到 $55$ 分的高分，虽然和正解没有关系。

继续优化，如果同一个点不同层之间不建边，则每个点在分层图中只会有入度个点有用，所以总的点只有 $O(m)$ 个，然后用随便 map 维护下再跑 dijkstra 就行了。

时间复杂度：$O(n\log n)$。
## code
```cpp
// @author       fkxr(luogu uid = 995934)
// https://hydro.ac/d/Fkxr/p/IO
#include <bits/stdc++.h>
#define endl cerr<<"------------------I Love Sqrt Decomposition------------------\n";
#define int long long
#define _CRT_SECURE_NO_WARNINGS 1
#define _4x _4x
//#define BIT BIT
//#define ST ST
//#define dsu dsu
using namespace std;
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc getchar
#define pc putchar
#endif

#define ds(x) (x=='\r'||x=='\n'||x==' ')
#define MAX 20
namespace fastIO {
	template<typename T>inline void r(T& a) { a = 0; char ch = gc(); bool ok = 0; for (; ch < '0' || ch>'9';)ok ^= (ch == '-'), ch = gc(); for (; ch >= '0' && ch <= '9';)a = (a << 1) + (a << 3) + (ch ^ 48), ch = gc(); if (ok)a = -a; }
	template<typename T>inline void w(T a) { if (a == 0) { pc('0'); return; }static char ch[MAX]; int till = 0; if (a < 0) { pc('-'); for (; a;)ch[till++] = -(a % 10), a /= 10; } else for (; a;)ch[till++] = a % 10, a /= 10; for (; till;)pc(ch[--till] ^ 48); }
	struct FIstream {
		inline FIstream operator>>(int& a) { r(a); return{}; }
		inline FIstream operator>>(char& ch) { ch = gc(); for (; ds(ch);)ch = gc(); return{}; }
		inline FIstream operator>>(string& s) { s = ""; char ch = gc(); for (; ds(ch);)ch = gc(); for (; !(ds(ch) || ch == EOF);) { s.push_back(ch); ch = gc(); }return{}; }
		template<typename T>inline FIstream operator<<(T& a) { r(a); return{}; }
		inline void is(int n, string& s) { s = ""; char ch = gc(); for (; ds(ch);)ch = gc(); for (; n--;) { s.push_back(ch); ch = gc(); } }
	}in;
	struct FOstream {
		inline FOstream operator<<(const int a) { w(a); return{}; }
		inline FOstream operator<<(const char ch) { pc(ch); return{}; }
		inline FOstream operator<<(const string s) { for (int i = 0; i < s.size(); i++)pc(s[i]); return{}; }
		template<typename T>inline FOstream operator>>(const T a) { w(a); return{}; }
	}out;
}using fastIO::in; using fastIO::out;
#undef ds
#define eout cerr

namespace Maths {
	const bool __is_P[] = { 0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1 };
	inline bool IP1(const int a) { if (a <= 29)return __is_P[a]; if (a % 2 == 0 || a % 3 == 0 || a % 5 == 0)return 0; for (int i = 6;; i += 6) { if (((i + 1) * (i + 1)) > a)return 1; if (a % (i + 1) == 0)return 0; if (((i + 5) * (i + 5)) > a)return 1; if (a % (i + 5) == 0)return 0; } }
#define times(a,b,m) (c=(unsigned long long)a*b-(unsigned long long)((long double)a/m*b+0.5L)*m,c<m?c:m+c)
	inline int power(int a, int b, const int mod = -1) { unsigned long long c; int ans = 1; if (mod == -1) { for (; b;) { if (b & 1)ans *= a; b >>= 1; a *= a; }return ans; }for (; b;) { if (b & 1)ans = times(ans, a, mod); b >>= 1; a = times(a, a, mod); }return ans; }
	const int Suk[] = { 2,325,9375,28178,450775,9780504,1795265022 };
	inline bool chk(const int n, int a, int b, int x) { if (x >= n) return 1; unsigned long long c; int v = power(x, a, n); if (v == 1)return 1; int j = 1; while (j <= b) { if (v == n - 1)break; v = times(v, v, n); j++; }if (j > b)return 0; return 1; }
	inline bool IP(int n) { if (n < 3 || n % 2 == 0)return n == 2; if (n <= 1e6) { return IP1(n); } else { int a = n - 1, b = 0; while (a % 2 == 0)a >>= 1, b++; for (int k : Suk)if (!chk(n, a, b, k))return 0; return 1; } }
#undef times
} using Maths::power;
using Maths::IP;
namespace exs {
#ifdef _4x
	int dx[] = { 1,-1,0,0 }, dy[] = { 0,0,1,-1 };
#else
	int dx[] = { 1,0,-1,-1,1,1,0,-1 }, dy[] = { 1,1,1,0,0,-1,-1,-1 };
#endif
	template<typename T, typename T1, typename T2>inline bool rg(T l, T1 r, T2 x) { return l <= x && x <= r; }
	inline bool emc(const int& a, const int& b) { return a > b; }
	void Freopen(string s) { freopen((s + ".in").c_str(), "r", stdin); freopen((s + ".out").c_str(), "w", stdout); }

#ifdef BIT
	struct bit {
		vector<int> c0, c1; int n;
		inline void Add(vector<int>& c, int p, int v) { for (; p <= n; p += p & -p) c[p] += v; }
		inline int Sum(const vector<int>& c, int p) { int t = 0; for (; p; p -= p & -p) t += c[p]; return t; }
		inline int sum(int l, int r) { assert(n != 0); return Sum(c0, r) * r - Sum(c1, r) - Sum(c0, l - 1) * (l - 1) + Sum(c1, l - 1); }
		inline void add(int l, int r, int v) { assert(n != 0); Add(c0, l, v); Add(c0, r + 1, -v); Add(c1, l, (l - 1) * v); Add(c1, r + 1, -r * v); }
		inline void init(const vector<int>& c) { n = c.size() - 1; c0.resize(n + 2); c1.resize(n + 2); int last = 0; for (int i = 1; i <= n; i++) { last = c[i] - last; Add(c0, i, last); Add(c1, i, last * (i - 1)); last = c[i]; } }
	};
#endif

#ifdef ST
	struct st {
		vector<int> lg; vector<vector<int>> f;
		inline void init(const vector<int>& c) { int len = c.size() - 1; lg.resize(len + 2); for (int i = 2; i <= len; i++) lg[i] = lg[i >> 1] + 1; f.resize(18, vector<int>(len + 2)); for (int i = 1; i <= len; i++) f[0][i] = c[i]; for (int j = 1; (1 << j) <= len; j++) for (int i = 1; i + (1 << j) - 1 <= len; i++) f[j][i] = max(f[j - 1][i], f[j - 1][i + (1 << (j - 1))]); }
		inline int q(int l, int r) { int j = lg[r - l + 1]; return max(f[j][l], f[j][r - (1 << j) + 1]); }
	};
#endif

#ifdef dsu//0x
	struct dsu {
		vector<int> fa, size; dsu(int size_) :fa(size_), size(size_, 1) { iota(fa.begin(), fa.end(), 0); }
		inline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
		inline void unite(int x, int y) { x = find(x), y = find(y); if (x == y)return; if (size[x] < size[y])swap(x, y); fa[y] = x; size[x] += size[y]; }
	};
#endif
}using namespace exs;
struct node {int y, z;};
vector<node>e[300005];
int v[300005], w[300005];
map<int, int>dis[300005];
//dis i j ：i号点p=j最短路
int n, m, k;
int L(int p, int k) {
	++p, ++k;
	return(p > k ? w[p] - w[k] : v[k-1] - v[p-1]);
}

struct Node {
	int x,p,d;
	friend bool operator<(Node a, Node b) {
		return a.d > b.d;
	}
};
int ans[300005];
void dij() {
	memset(ans, 0x3f, sizeof(ans));
	ans[1] = 0;
	priority_queue<Node>q;
	q.push({ 1,0,0 });
	dis[1][0] = 0;
	for (; !q.empty();) {
		auto t = q.top(); q.pop();
		if (dis[t.x][t.p] != t.d)continue;
		//out << t.x << " " << t.p << " " << t.d << '\n';
		ans[t.x] = min(ans[t.x], t.d);
		for (int i = 0; i < e[t.x].size(); i++) {
			auto tmp = e[t.x][i];
			if (dis[tmp.y].find(i) == dis[tmp.y].end())dis[tmp.y][i] = 1e16;
			if (dis[tmp.y][i] > t.d + L(t.p, i) + tmp.z) {
				q.push({ tmp.y,i,dis[tmp.y][i] = t.d + L(t.p, i) + tmp.z });
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		out << (ans[i]<=1e16?ans[i]:-1LL) << " ";
	}
}

void Main(){
	//Freopen("robot5");
	int C; in >> C;
	in >> n >> m >> k;
	for (int i = 1; i < k; i++) { in >> v[i]; v[i] += v[i - 1]; }
	for (int i = 2; i <= k; i++) { in >> w[i]; w[i] += w[i - 1]; }
	for (int i = 1; i <= n; i++) {
		int d; in >> d;
		for (; d--;) {
			node tmp; in >> tmp.y >> tmp.z;
			e[i].push_back(tmp);
		}
	}
	dij();
}
signed main() {
	Main();
	return 0;
}
/*
fc E:\Screenshots\robot1.ans E:\Screenshots\robot1.out
fc E:\Screenshots\robot2.ans E:\Screenshots\robot2.out
fc E:\Screenshots\robot3.ans E:\Screenshots\robot3.out
fc E:\Screenshots\robot4.ans E:\Screenshots\robot4.out
fc E:\Screenshots\robot5.ans E:\Screenshots\robot5.out
*/
```
[记录](https://www.luogu.com.cn/record/225244373)

---

## 作者：lilong (赞：1)

看到题目后比较容易想到可以**拆点**，即对于一个点 $u$，若其向外发出了 $cnt$ 条边，那么将其分别表示成 $1,2,\cdots,cnt$ 共 $cnt$ 个点，每个点的编号即为对应的参数 $p$。那么参数 $p$ 的变化就可以在这一系列点之间建边。另外，为了方便统计答案，每个点额外建一个点并且**不参与 $p$ 的变化过程**。点与点之间拥有相同 $p$ 值的点连边，如果当前 $p$ 已经超过了**边指向的点的 $cnt$ 值**，则直接向 $cnt$ 对应的点连边（边权加上对应的代价，用前缀和维护）。最后跑 dijkstra 即可，时间复杂度 $O((n+m)\log(n+m))$。


```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#define N 600010
#define inf 1e18
#define int long long
using namespace std;
vector<int>to[N];
vector<pair<int,int> >G[N],G0[N];
int n,m,node;
int k,a[N],b[N],sum[N],vis[N];
int dis[N];
void dijk(){
    priority_queue<int,vector<pair<int,int> >,greater<pair<int,int> > > q;
    for(int i=1;i<=node;i++)
        dis[i]=1e18;
    dis[1]=0;
    q.push(make_pair(dis[1],1));
    while(!q.empty()){
        int u=q.top().second;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        // cout<<u<<' '<<dis[u]<<endl;
        for(auto it:G[u]){
            int v=it.first,w=it.second;
            if(dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                q.push(make_pair(dis[v],v));
            }
        }
    }
    return;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int tid;
    cin>>tid;
    cin>>n>>m>>k;
    for(int i=1;i<k;i++)
        cin>>a[i];
    for(int i=2;i<=k;i++)
        cin>>b[i],sum[i]=sum[i-1]+b[i];
    for(int i=1;i<=n;i++){
        int cnt,j,w;
        cin>>cnt;
        for(int l=1;l<=cnt;l++){
            cin>>j>>w;
            node++;
            to[i].push_back(node);
            G0[i].push_back(make_pair(j,w));
            // cout<<node<<' ';
        }
        node++,to[i].push_back(node);
        // cout<<'\n';
    }
    for(int i=1;i<=n;i++){
        for(int it=1;it<=G0[i].size();it++){
            int nw=to[i][it-1],j=G0[i][it-1].first,w=G0[i][it-1].second;
            // p 值的变化
            if(it<G0[i].size())G[nw].push_back(make_pair(to[i][it],a[it]));
            if(it>1)G[nw].push_back(make_pair(to[i][it-2],b[it]));
            //向统计答案的点连边
            G[nw].push_back(make_pair(to[j][to[j].size()-1],w));
            //点与点之间
            if(G0[j].size()&&G0[j].size()<it)G[nw].push_back(make_pair(to[j][G0[j].size()-1],sum[it]-sum[G0[j].size()]+w));// p 超过了指向点的 cnt
            else if(G0[j].size())G[nw].push_back(make_pair(to[j][it-1],w));//没超过
        }
    }
    // cout<<1<<endl;
    dijk();
    for(int i=1;i<=n;i++){
        int ans=1e18;
        for(auto j:to[i])
            ans=min(ans,dis[j]);
        if(ans==inf)cout<<-1<<' ';
        else cout<<ans<<' ';
    }
    return 0;
}
```

---

## 作者：Priestess_SLG (赞：1)

简单签到题，考虑建图。

首先有一个 $O(nk)$ 个点的建图方式是直接拆 $k$ 层然后层和层之间连边，但是肯定过不去。考虑优化，发现两个点同层之间的连边大多都是无效的，只有两个点这一层上都有路才连边，如果只有一个点在这一层上有边那么把这个点直接连到另一个点最高的那一层上，权值可以简单前缀和计算，而如果两个点在该层都没有边那么就不连，最后跑最短路统计答案即可。这样点的数量是 $O(m)$ 级别的，可以通过。

```cpp
// #pragma GCC optimize(3, "Ofast", "inline", "unroll-loops")
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1000010;
const int inf = 1e18;
const int mod = 1e9 + 7;

int v[N], w[N], d[N], bk[N], dis[N], res[N], pre[N];
vector<int> x[N], y[N], z[N], id[N];
vector<pair<int, int>> adj[N];
struct Node
{
    int u, val;
    inline bool operator<(const Node &r) const
    {
        return val > r.val;
    }
};

signed main()
{
    // freopen("robot4.in", "r", stdin);
    // freopen("1.out", "w", stdout);
    cin.tie(0)->sync_with_stdio(false);
    int cas, n, m, k;
    cin >> cas >> n >> m >> k;
    for (int i = 1; i < k; ++i)
        cin >> v[i];
    for (int i = 2; i <= k; ++i)
        cin >> w[i], pre[i] = pre[i - 1] + w[i];
    int idx = 0;
    for (int i = 1; i <= n; ++i)
    {
        cin >> d[i];
        x[i].resize(d[i] + 2), y[i].resize(d[i] + 2);
        z[i].resize(d[i] + 2), id[i].resize(d[i] + 2);
        for (int j = 1; j <= d[i]; ++j)
        {
            x[i][j] = i, cin >> y[i][j] >> z[i][j];
            id[i][j] = ++idx, bk[idx] = y[i][j];
        }
    }
    cerr << idx << '\n';
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= d[i]; ++j)
            if (d[y[i][j]] >= j)
                adj[id[i][j]].emplace_back(id[y[i][j]][j], z[i][j]);
            else
            {
                int cost = pre[j] - pre[d[y[i][j]]], t = y[i][j];
                if (d[t])
                    adj[id[i][j]].emplace_back(id[t][d[t]], z[i][j] + cost);
            }
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= d[i]; ++j)
        {
            if (j > 1)
                adj[id[i][j]].emplace_back(id[i][j - 1], w[j]);
            if (j < d[i])
                adj[id[i][j]].emplace_back(id[i][j + 1], v[j]);
        }
    priority_queue<Node> q;
    memset(dis, 0x3f, sizeof dis);
    memset(res, 0x3f, sizeof res);
    q.push({id[1][1], dis[id[1][1]] = 0});
    while (q.size())
    {
        auto [u, ds] = q.top();
        q.pop();
        assert(u);
        if (dis[u] >= ds)
            for (auto &[v, w] : adj[u])
                if (dis[v] > dis[u] + w)
                    q.push({v, dis[v] = dis[u] + w});
    }
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= d[i]; ++j)
            res[i] = min(res[i], dis[id[i][j]]);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= d[i]; ++j)
            res[y[i][j]] = min(res[y[i][j]], dis[id[i][j]] + z[i][j]);
    for (int i = 1; i <= n; ++i)
        cout << (res[i] < 1e18 ? res[i] : -1) << ' ';
    cout << '\n';
    return 0;
}

/*

0
5 6 3
2 4
1 1
3 2 5 3 1 4 2
1 3 2
2 1 2 4 1
0
0

*/
```

---

## 作者：aeiouaoeiu (赞：1)

### 做法 $1$

在跑最短路时额外记录当前参数，一个点的状态数是 $\mathcal{O}(k)$ 的，复杂度在 $\mathcal{O}(mk\log m)$ 左右，可以拿到 $40$ 分。

### 做法 $2$

考虑特殊性质 A，此时问题相当于求最短路，直接跑即可，结合做法 $1$ 可以拿到 $60$ 分。

### 做法 $3$

考虑优化建图。对于一个点 $u$ 的一条入边 $(a,u,b,c)$（$w$ 表示长度，$d$ 表示编号），其要走到 $u$ 的出边 $(u,x,y,z)$，需要支付 $y+\text{cost}(c,z)$ 的代价，考虑用图表示 $\text{cost}(c,z)$。对于每个点都建出一条链 $i_1,i_2,\ldots,i_k$，其中有连边 $(i_x,i_{x+1},v_x),(i_x,i_{x-1},w_x)$（均为单向边，下同），此时连边 $(a,i_c,0)$ 与 $(i_z,x,0)$ 即可。

这样点数和边数都是平方级别的，得分与做法 $1$ 相同。

### 做法 $4$

发现其实每个点不用将一整条链建出来，只需要保留其出入边的编号，将边权合并即可，这样点数是 $\mathcal{O}(m)$ 的，时间复杂度为 $\mathcal{O}(m\log m)$，带一个 $3\sim 5$ 的常数，可以拿到 $100$ 分。

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/18984399)

奶龙题，感觉严格小于接龙。

题目显然可以转化为一共 $k$ 层的有向图，每次跳到不同层需要花费一定的代价，求从 $1$ 为起点的单源最短路。

显然可以建立 $k$ 层的分层图，对应的边只在对应层建立，直接跑单源最短路即可，时间复杂度 $O(nk\log nk)$，无法通过。

注意到每一层有很多点是无用的，于是直接动态开点，每个点只开对应度数和作为出度的层数即可，对于一次跳跃多层的路径可以前缀和预处理出每层之间跳跃的代价以快速计算。为了方便这一部分可以采用 map 实现。时间复杂度 $O(n\log n \log k)$，用哈希表的话可以做到 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
using pii=pair<ll,pi>;
const int N=300005;
const ll inf=0x3f3f3f3f3f3f3f3f;
int n,m,k,v[N],w[N],d[N];
ll f[N];
map<int,ll>dis[N];
map<int,bool>vis[N];
vector<pi>g[N];
priority_queue<pii,vector<pii>,greater<pii> >q;
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int cid;
    cin>>cid>>n>>m>>k;
    for(int i=1;i<=k-1;i++)cin>>v[i];
    for(int i=2;i<=k;i++)
    {
        cin>>w[i];
        f[i]=f[i-1]+w[i];
    }
    for(int i=1;i<=n;i++)
    {
        cin>>d[i];
        g[i].push_back({0,0});
        dis[i][0]=inf;
        for(int j=1;j<=d[i];j++)
        {
            int y,z;
            cin>>y>>z;
            g[i].push_back({y,z});
            dis[i][j]=inf;
            dis[y][j]=inf;
        }
    }
    dis[1][1]=0;
    q.push({0,{1,1}});
    while(!q.empty())
    {
        pii cur=q.top();
        q.pop();
        int u=cur.se.fi,lv=cur.se.se;
        if(vis[u][lv])continue;
        vis[u][lv]=1;
        if(lv>1&&dis[u].count(lv-1)&&dis[u][lv-1]>dis[u][lv]+w[lv])
        {
            dis[u][lv-1]=dis[u][lv]+w[lv];
            q.push({dis[u][lv-1],{u,lv-1}});
        }
        if(lv<k&&dis[u].count(lv+1)&&dis[u][lv+1]>dis[u][lv]+v[lv])
        {
            dis[u][lv+1]=dis[u][lv]+v[lv];
            q.push({dis[u][lv+1],{u,lv+1}});
        }
        if(lv<g[u].size()&&dis[g[u][lv].fi][min(lv,d[g[u][lv].fi])]>dis[u][lv]+g[u][lv].se+f[lv]-f[min(lv,d[g[u][lv].fi])])
        {
            dis[g[u][lv].fi][min(lv,d[g[u][lv].fi])]=dis[u][lv]+g[u][lv].se+f[lv]-f[min(lv,d[g[u][lv].fi])];
            q.push({dis[u][lv]+g[u][lv].se+f[lv]-f[min(lv,d[g[u][lv].fi])],{g[u][lv].fi,min(lv,d[g[u][lv].fi])}});
        }
        if(lv<g[u].size()&&dis[g[u][lv].fi][lv]>dis[u][lv]+g[u][lv].se)
        {
            dis[g[u][lv].fi][lv]=dis[u][lv]+g[u][lv].se;
            q.push({dis[g[u][lv].fi][lv],{g[u][lv].fi,lv}});
        }
    }
    for(int i=1;i<=n;i++)
    {
        ll res=inf;
        for(auto itm:dis[i])
        {
            res=min(res,itm.se);
        }
        if(res==inf)cout<<-1<<" ";
        else cout<<res<<" ";
    }
    return 0;
}
```

---

## 作者：紊莫 (赞：0)

直接拆成 $O(m)$ 个点，$(x, i)$ 表示当前在第 $x$ 个点，参数为 $i$ 的最短路。

转移按照题意模拟，注意可能到达一个没有出度的点，也需要更新最短路。

另外从一个较大的 $i$ 到一个出边很少的点的时候需要手动把 $i$ 缩小到那个点的出度，否则复杂度可能退化。

这样跑一个单源最短路，最后的复杂度就是 $O(m\log m)$。

---

## 作者：Fiendish (赞：0)

这道题的关键在于如何计算参数变化带来的代价。

首先对 $w$ 和 $v$ 计算前缀和，这样可以 $O(1)$ 计算改变参数的代价。然后考虑分层图最短路。计算参数变化带来的代价时，我们需要知道改之前的参数和改之后的参数。改之后的参数是好算的，主要是如何知道改之前的参数。考虑一条边 $(u,v,x)$ 表示以 $u$ 为起点的第 $x$ 条边指向了 $v$，那我们就根据这条边新建一个点 $(v,x)$，然后再 $(v,i)$ 内部连边。这样就可以计算参数变化带来的代价。由于每个点在新图中对应的点只有入度个，所以新图中有 $O(m)$ 个点。最后在新图中以 $(1,1)$ 为起点跑 dijkstra 即可，时间复杂度 $O(m\log m)$。

---

## 作者：Cwkapn (赞：0)

这道题要求的东西在题面里已经写得很清楚了，就是求一个单源最短路。只不过这里的状态略有不同。

可以发现，常规最短路从特定点 $u$ 到另一个特定点 $v$ 的代价是固定的，但在这里和机器人到达点的参数 $p$ 有关。所以不妨进行一个“拆点”操作，将第 $i$ 个点拆分成若干个“子点”，分别代表到第 $i$ 个点时 $p$ 为 $1,2,3,\cdots$ 的状态。可以发现每个点 $i$ 将被拆分成 $i$ 的入度个点，所以总的“子点”数是 $m$ 个，边数也是 $m$ 量级的。于是现在可以用 Dijkstra 算法解决这个问题。

---

## 作者：Z3k7223 (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Z3k7223/p/18990820)

铁牌选手凑个热闹，这也是 NOI.jpg

## Solution

观察到对于每个点，有效的 $p$ 只有 $d_i$ 个，这样状态总数就是 $\sum d_i=m$。

考虑拆点，每个点拆成 $d_i$ 个点表示它的所有 $p$ 的状态。单个点的状态之间通过 $v$ 和 $w$ 建边。在处理原图的边的时候如果 $v$ 的状态不足这条边的 $p$，连到 $v$ 的最大编号，简单计算边权即可。最后跑一个最短路就做完了。

由于对于原图上每个点还要建立一个点计算实际的最短路，总点数是 $N=n+m$，总边数是 $M=2m+m=3m$，时间复杂度就是 $O(M\log M)$。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll inf=1e18;
const int N=3e5+10;
int n,m,k;
int tot;
int d[N];
struct node{
    int v;
    ll w;
    friend bool operator<(node x,node y){
        return x.w>y.w;
    }
};
vector<node>g[N*2];
vector<int>num[N];
int U[N],V[N],ID[N],cnt;
ll W[N];
int w1[N],w2[N];
ll sum[N];
void add(int u,int v,ll w){
    g[u].push_back({v,w});
}
ll dis[N];
void dij(int s){
    for(int i=1;i<=tot;i++){
        dis[i]=inf;
    }
    priority_queue<node>q;
    q.push({s,0});
    dis[s]=0;
    while(!q.empty()){
        node tmp=q.top();
        q.pop();
        int x=tmp.v;
        if(tmp.w>dis[x]){
            continue;
        }
        for(auto i:g[x]){
            int v=i.v;
            ll w=i.w;
            if(dis[v]>dis[x]+w){
                dis[v]=dis[x]+w;
                q.push({v,dis[v]});
            }
        }
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int c;
    cin>>c>>n>>m>>k;
    for(int i=1;i<k;i++){
        cin>>w1[i];
    }
    for(int i=2;i<=k;i++){
        cin>>w2[i];
        sum[i]=sum[i-1]+w2[i];
    }
    for(int i=1;i<=n;i++){
        cin>>d[i];
        num[i].resize(d[i]+1);
        num[i][0]=++tot;
        for(int j=1;j<=d[i];j++){
            num[i][j]=++tot;
            ++cnt;
            U[cnt]=i;
            ID[cnt]=j;
            cin>>V[cnt]>>W[cnt];
        }
        for(int j=1;j<=d[i];j++){
            if(j<d[i]){
                add(num[i][j],num[i][j+1],w1[j]);
            }
            if(j>1){
                add(num[i][j],num[i][j-1],w2[j]);
            }
        }
    }
    for(int i=1;i<=m;i++){
        int u=U[i],v=V[i],id=ID[i];
        ll w=W[i];
        add(num[u][id],num[v][0],w);
        if(id>d[v]){
            add(num[u][id],num[v][d[v]],w+sum[id]-sum[d[v]]);
        }else{
            add(num[u][id],num[v][id],w);
        }
    }
    if(!d[1]){
        cout<<"0 ";
        for(int i=1;i<=n;i++){
            cout<<"-1 ";
        }
        cout<<'\n';
        return 0;
    }
    dij(num[1][1]);
    cout<<"0 ";
    for(int i=2;i<=n;i++){
        ll ans=dis[num[i][0]];
        if(ans>1e17){
            cout<<"-1 ";
        }else{
            cout<<ans<<' ';
        }
    }
    cout<<'\n';
    return 0;
}
```

## 一些闲话

赛时不到 1h 即想出了正解，但是因为谜之原因（可能是太困了）导致我认为状态总数是 $O(k^2)$，进而导致我转向别的思路并成功没场切绿题打铁呜呜。

---

## 作者：fush (赞：0)

我们把每个点拆成 $d$ 个。  
这样在跑最短路时，一个点对应一条边，就不用考虑 $p$。  
对于原图上的同一个点，我们可以用 $v, w$ 简单转移 $p - 1, p + 1$，来换边。  
对于下一节点，我们现在的 $p$ 可能大于下个节点的 $d$，我们可以把 $p$ 提前改成 $d$。  
否则加边权直接转移。

注意每个点的最小值不用考虑 $p$，只需要加边权即可。

```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a,b,c) for(int a=(b),a##end=(c);a<=a##end;++a)
#define FR(a,b,c) for(int a=(b),a##end=(c);a>=a##end;--a)
#define lowbit(x) ((x)&-(x))
#define eb emplace_back
#define SZ(x) (int)((x).size())
#define int long long
#define vt vector
#define fr first
#define se second
#define ar(x) array<int,x>
#define PII pair<int, int>
#define max(a, b)({auto f7r=(a);auto j3h=(b);f7r<j3h?j3h:f7r;})
#define cmax(a, b)({auto j3h=(b);(j3h>a)&&(a=j3h);})
#define min(a, b)({auto f7r=(a);auto j3h=(b);f7r>j3h?j3h:f7r;})
#define cmin(a, b)({auto j3h=(b);(j3h<a)&&(a=j3h);})
constexpr int N = 1e6 + 10;
int n, m, k, v[N], w[N], f[N], d[N], ans[N];
struct A{
    int dis, u, lv;
    A(int d, int u, int v):dis(d), u(u), lv(v){}
    bool operator<(const A&j)const{return dis > j.dis;}
};
priority_queue<A>q;
vt<PII>e[N];
vt<int>dis[N], vis[N];
int32_t main(){
    cin.tie(0)->sync_with_stdio(0);
    cin >> n >> n >> m >> k, memset(ans, 0x7f, sizeof ans);
    FL(i, 1, k - 1)cin >> v[i];
    FL(i, 2, k)cin >> w[i], f[i] = f[i - 1] + w[i];
    FL(i, 1, n){
        cin >> d[i], dis[i].resize(d[i] + 1, 1e14);
        vis[i].resize(d[i] + 1), e[i].eb(0, 0);
        FL(j, 1, d[i]){
            int y, z;
            cin >> y >> z, e[i].eb(y, z);
        }
    }
    dis[1][1] = 0, q.emplace(0, 1, 1), ans[1] = 0;
    while(!q.empty()){
        int u = q.top().u, lv = q.top().lv, dw;
        if(q.pop(), vis[u][lv])continue;
        vis[u][lv] = 1;
        if(lv > 1 && dis[u][lv - 1] > (dw = dis[u][lv] + w[lv]))
            dis[u][lv - 1] = dw, q.emplace(dw, u, lv - 1);
        if(lv < d[u] && dis[u][lv + 1] > (dw = dis[u][lv] + v[lv]))
            dis[u][lv + 1] = dw, q.emplace(dw, u, lv + 1);

        int y = e[u][lv].fr, z = min(d[y], lv);
        dw = dis[u][lv] + e[u][lv].se, cmin(ans[y], dw);
        if(z > 0 && dis[y][z] > (dw += f[lv] - f[z]))
            dis[y][z] = dw, q.emplace(dw, y, z);
    }
    FL(i, 1, n)
        cout << (ans[i] == ans[0] ? -1 : ans[i]) << " ";
    return 0;
}
```

---

## 作者：Redshift_Shine (赞：0)

一个包含 $n$ 个节点树的其中一个重要性质是所有点的度数之和等于 $2n-2$，而题目中提到会在**点**上修改 $p$，而只能在 $p$ **不大于当前节点度数**时才能行动，这启发我们对于每个节点与其**所有能够自由行动**的 $p$ 建立一张新图。

具体来说，我们用有序点对 $(x,p)$ 来描述这张新图中的点，代表目前行动至 $x$ 点，及其目前的 $p$ 值。对于该点，我们**最多**会在上面连出三条边：

1. 令树上 $x$ 连出的第 $p$ 条边的目的地为 $y$，则连接 $(x,p)$ 至 $(y,p)$，边权与树上该边边权保持一致。$(y,p)$ 可能不存在，这没关系，原因接下来会提到。
2. **若 $p\neq 1$**，则连接 $(x,p)$ 至 $(x,p+1)$，边权为 $v_p$。
3. **若 $p\neq d_x$**，则连接 $(x,p)$ 至 $(x,p-1)$，边权为 $w_p$。

接下来，将除 $(1,1)$ 外的所有节点的初始距离设为无限大然后开始跑 Dijkstra，然后对于每个节点扫描其对应的所有 $(x,p)$ 取最小值，看起来很有道理，而且能过。

**但这是错的**。

关键在于，一旦走到终点，“能够自由活动”就不再是必要条件了。在这种情况下，你甚至需要将考虑范围扩大到 $(x,n-1)$，而暴力扫描就显得不高效了。有解决办法吗？

有的兄弟，有的。

还记得我前面提到的 $(y,p)$ 可能不存在吗？在新图基础上，我们对于原树节点开另一个距离数组，称之为 $d'_x$。对于 Dijkstra 过程中的任意一条边 $((x,p),(y,p),v)$，我们都可以尝试使用 $d_{(x,p)}+v$ 更新 $d'_y$，随后再在不存在的情况下利用 $v$ 和 $w$ 的前缀和即时更新距离。这样，最后就只需要输出 $d'$。

时间复杂度 $O(n\log n)$，可以通过。

```c++
// #define Redshift_Debug
#ifdef Redshift_Debug
#define debug(...) fprintf(stderr, __VA_ARGS__)
#include <chrono>
#else
#define debug(...)
#endif
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
const int N = 3e5 + 10;
int c, n, m, k;
using ll = long long;
ll v[N], w[N], td[N];
vector<ll> dis[N];
vector<bool> vis[N];
const ll linf = 0x3f3f3f3f3f3f3f3f;
struct st
{
	int x, lyr;
	ll v;
	bool operator<(const st &tx) const
	{
		return v > tx.v;
	}
	st(int _x, int _lyr, ll _v) : x(_x), lyr(_lyr), v(_v)
	{
	}
};
priority_queue<st> q;
vector<vector<st>> road[N];
ll calc(int l, int r)
{
	if (r > l)
		return v[r] - v[l];
	else
		return w[l] - w[r];
}
void run()
{
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(0);
	cin >> c >> n >> m >> k;
	memset(td, 0x3f, n << 3);
	for (int i = 0; i < k - 1; i++)
	{
		cin >> v[i];
	}
	for (int i = 1; i < k; i++)
	{
		cin >> w[i];
	}
	for (int i = 0, d, tx, ty, trd; i < n; i++)
	{
		cin >> d;
		trd = 0;
		dis[i].assign(d, linf);
		road[i].resize(d);
		vis[i].resize(d);
		for (auto &j : road[i])
		{
			cin >> tx >> ty;
			tx--;
			j.emplace_back(tx, trd, ty);
			if (trd)
				j.emplace_back(i, trd - 1, w[trd]);
			if (trd != d - 1)
				j.emplace_back(i, trd + 1, v[trd]);
			trd++;
		}
	}
	for (int i = 1; i < k; i++)
		v[i] += v[i - 1], w[i] += w[i - 1];
	dis[0][0] = td[0] = 0;
	q.emplace(0, 0, 0);
	while (q.size())
	{
		// cerr << "ok\n";
		st tmp = q.top(), buf(0, 0, 0);
		q.pop();
		if (vis[tmp.x][tmp.lyr])
			continue;
		vis[tmp.x][tmp.lyr] = true;
		for (auto &i : road[tmp.x][tmp.lyr])
		{
			buf = i;
			buf.v += tmp.v;
			td[buf.x] = min(td[buf.x], buf.v);
			if (!road[buf.x].size())
				continue;
			if (buf.lyr >= road[buf.x].size())
			{
				buf.v += calc(buf.lyr, road[buf.x].size() - 1);
				buf.lyr = road[buf.x].size() - 1;
			}
			if (vis[buf.x][buf.lyr] or dis[buf.x][buf.lyr] <= tmp.v)
				continue;
			dis[buf.x][buf.lyr] = buf.v;
			q.emplace(buf);
		}
	}
	for (int i = 0; i < n; i++)
	{
		cout << (td[i] == linf ? -1 : td[i]) << " \n"[i == n - 1];
	}
}
int main()
{
#ifdef Redshift_Debug
	auto st = chrono::high_resolution_clock::now();
#endif
	run();
#ifdef Redshift_Debug
	auto ed = chrono::high_resolution_clock::now();
	fprintf(stderr, "%.9lf\n", (ed - st).count() / 1e9);
#endif
}
```

---


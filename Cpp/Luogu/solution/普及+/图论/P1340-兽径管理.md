# 兽径管理

## 题目描述

约翰农场的牛群希望能够在 $N$ 个草地之间任意移动。草地的编号由 $1$ 到 $N$。草地之间有树林隔开。牛群希望能够选择草地间的路径，使牛群能够从任一 片草地移动到任一片其它草地。 牛群可在路径上双向通行。

牛群并不能创造路径，但是他们会保有及利用已经发现的野兽所走出来的路径（以下简称兽径）。每星期他们会选择并管理一些或全部已知的兽径当作通路。

牛群每星期初会发现一条新的兽径。他们接着必须决定管理哪些兽径来组成该周牛群移动的通路，使得牛群得以从任一草地移动到任一草地。牛群只能使用当周有被管理的兽径做为通路。

牛群希望他们管理的兽径长度和为最小。牛群可以从所有他们知道的所有兽径中挑选出一些来管理。牛群可以挑选的兽径与它之前是否曾被管理无关。

兽径决不会是直线，因此连接两片草地之间的不同兽径长度可以不同。 此外虽然两条兽径或许会相交，但牛群非常的专注，除非交点是在草地内，否则不会在交点换到另外一条兽径上。

在每周开始的时候，牛群会描述他们新发现的兽径。如果可能的话，请找出可从任何一草地通达另一草地的一组需管理的兽径，使其兽径长度和最小。


## 说明/提示

### 样例解释

对于每一周，

- 第一周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第二周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第三周时 $4$ 号草地不能与其他草地连通，输出 $-1$；
- 第四周时可以选择兽径 $(1,4,3),(1,3,8)$ 和 $(3,2,3)$；
- 第五周时可以选择兽径 $(1,4,3),(1,3,6)$ 和 $(3,2,3)$；
- 第六周时可以选择兽径 $(1,4,3),(2,1,2)$ 和 $(3,2,3)$。


### 数据范围及约定

对于全部数据，$1\le N\le 200$，$1 \le W \le 6000$，兽径的长度不超过 $10^4$ 且为正整数。

## 样例 #1

### 输入

```
4 6	 	 
1 2 10	 	 
1 3 8	 	 
3 2 3	 	 
1 4 3	 	 
1 3 6	 	 
2 1 2	 	 
```

### 输出

```
-1
-1
-1
14
12
8```

# 题解

## 作者：SovietPower✨ (赞：45)

109ms，最快的了吧

题意肯定是求最小生成树了，问题在于怎样减少时间消耗。

主要思路是逆序求解，因为这样可以尽可能地减少使用Kruskal的次数，时间复杂度自然就降下来了

每次Kruskal记录用到的边，如果(每一周)删掉了一条用到的边，那自然需要重新求一遍最小生成树；如果没用到，那就不用求了，直接赋值为上一个结果。

如果有一周出现了-1，那它继续删边肯定更不联通了，所以之后所有答案都是-1，break就好

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=205,M=6005;

int n,w,Enum,H[M<<1],fa[N];
long long Ans[M];
bool use[M<<1],cannot[M<<1];//use:记录最近一次求最小生成树用到的边   cannot[ i ]:i这条边不能再用了(已删)
struct Edge
{
    int fr,to,nxt,val,id;
    bool operator <(const Edge &a)const
    {
        return val<a.val;
    }
}e[M<<1];

int read()
{
    int now=0;bool f=false;char c=getchar();
    while(c>'9'||c<'0')
    {
        if(c=='-')f=1;
        c=getchar();
    }
    while(c>='0'&&c<='9')now=(now<<3)+(now<<1)+c-'0',c=getchar();
    return f?-now:now;
}

void AddEdge(int u,int v,int w)
{
    e[++Enum].to = v;
    e[Enum].fr = u;
    e[Enum].nxt = H[u];
    e[Enum].val = w;
    H[u] = Enum;
}

int Find(int x)
{
    return x==fa[x]?x:fa[x]=Find(fa[x]);
}

long long Kruskal()
{
    memset(use,0,sizeof use);
    for(int i=1;i<=n;i++)
      fa[i]=i;
    int k=0;
    long long tot=0;
    for(int i=1;i<=Enum;i++)
    {
        if(cannot[e[i].id]) continue;
        int r1=Find(e[i].fr),r2=Find(e[i].to);
        if(r1!=r2)
        {
            ++k;tot+=e[i].val;
            use[e[i].id]=1;//printf("use:%d\n",e[i].id);
            fa[r1]=r2;
        }
        if(k==n-1)
          break;
    }
    return k==n-1?tot:-1;
}

int main()
{
    n=read(),w=read();
    for(int a,b,c,i=1;i<=w;i++)
//      Fr[i]=read(),To[i]=read),Val[i]=read();
      a=read(),b=read(),c=read(),AddEdge(a,b,c),e[i].id=i;
    sort(e+1,e+Enum+1);
    Ans[w]=Kruskal();
    for(int i=w-1;i;i--)
    {
        cannot[i+1]=1;//printf("cannot:%d\n",i+1);
        if(use[i+1])
          Ans[i]=Kruskal();//printf("OK\n");
        else
          Ans[i]=Ans[i+1];
        if(Ans[i]==-1)//不连通，那之后的肯定也不连通 
        {
            for(int j=1;j<i;j++)
              Ans[j]=-1;
            break;
        }
    }
    for(int i=1;i<=w;i++)
      printf("%lld\n",Ans[i]);
    return 0;
}
```

---

## 作者：King丨帝御威 (赞：33)

看了看大佬们写的代码，感到十分懵比。毕竟是初学者。写的代码太难懂了。。经典作法：kruskal。代码简单易懂，利于初学者理解。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct node
{
    int u,v,w,p;
}edge[1000000];                  //结构体：起点终点边权。
bool mark[1000000];
int fa[1000000];                 //认爹数组。
int n,m,num=1;
void add(int x,int y,int z)      //链式前向星存图，你们应该学了。
{
    edge[num].u=x;
    edge[num].v=y;
    edge[num].w=z;
    edge[num].p=num;
    num++;
}
int find(int x) 
{
    if(fa[x]==x)
        return x;                //认亲爹喽！！
    return fa[x]=find(fa[x]);
}
void unionn(int x,int y)
{
    int fx=find(x);
    int fy=find(y);
    fa[fx]=fy;                 //kruskal核心：并查集，必须会！！
}
void kruskal(int p)
{
    int ans=0;
    int k=0;                  //计数器，别漏了！
    for(int i=1;i<=n;i++)
        fa[i]=i;
    for(int i=1;i<=num-1;i++)
    {
        if(find(edge[i].u)!=find(edge[i].v)&&edge[i].p<=p)
        {
            unionn(edge[i].u,edge[i].v);
            ans+=edge[i].w;       //累加边权！
            k++;
        }
        if(k==n-1)               //计数器的用途！
        {
            cout<<ans<<endl;
            return;
        }
    }
    cout<<-1<<endl;           //不能找到一组可从任一草地通达另一草地的兽径，输出 “-1”。
}
bool comp(node a,node b)
{
    return a.w<b.w;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        fa[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;              //输入并存图。
        add(x,y,z);
    }
    sort(edge+1,edge+num,comp);    //结构体排序。
    for(int i=1;i<=m;i++)
    kruskal(i);					   //快要结束喽！
    return 0;                      
}
```
最后，祝犇犇们省选成功！

---

## 作者：zfz04 (赞：21)

# 最小生成树&Kruskal

本题是要动态构造一棵最小生成树；

所以你现在可以开始想象有一个黑袋子里有很多树枝，每条树枝都有长度，你可以从袋子里将树枝一个一个的拿出来，然后现在你想拼出一棵有n个节点的树，且每个节点有序号，每条树枝只能固定的将两个点连接起来，当你每拿出一根树枝的时候，你就要看看是否能拼出这棵树，如果能，那闲的没事干的你还要拼出长度最小的一颗树；

题意了解了，那我们一起来看看思路：

1. 首先，在树还没有拼出来之前，有一根树枝可以将两个还没有直接或间接连起来的连接起来，那么毫不犹豫，不管它多长，我都会将它选上；很明显这种情况只存在于你还没有将树连起来的时候，所以在这之前的输出都是-1；

1. 如果这根树枝连接的是已经可以直接或间接连起来的点，那么就走一遍Kruskal，看看是不是可以将其中的一根树枝替换掉，不过在这之前，它需要比这些树枝中最长的那一根要短，这是显而易见的；最后就可以将那根被替换的树枝扔掉了，**扔了以后，我们就不需要再考虑这根树枝了，你扔掉的树枝，在后面始终都用不到，这时候你可以想想Kruskal是如何操作的，首先假设你不把它扔掉，那后面拿出来的树枝要么比它长或等于它，因为在Kruskal时边时有序的，所以在之前就已经将这根树枝排除了，那比它短的话，那就更没有这根树枝什么事了**；
**注：** 这时不需要满足树已经建好，只需要满足这根树枝连接的是已经可以直接或间接连起来的点就可以了；而且一定会有一根树枝被扔掉；

代码思路：

- 了解思路以后代码思路应该都不成问题，首先判断两点是否连接用并查集就可以了；还有一些其他的直接看代码吧：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m;
struct pp{
	int x,y,z;
}w[250],ww[250];//w用来加入树枝；ww用来存有用的树枝； 
int f[205];//并查集 
int sum;//记录边权 
int t=0;//记录边数 
```
- 如何输入呢?边数记录的是有用的边数，所以我们只需要：
```cpp
for(int j=1;j<=m;j++){
		cin>>w[t+1].x>>w[t+1].y>>w[t+1].z;
```


------------

- 这是对思路1的实现：
```cpp
int r1=find(w[t+1].x),r2=find(w[t+1].y);
		if(r1!=r2){
			t++;
			f[r2]=r1;
			sum+=w[t].z;
			ww[t]=w[t];
			sort(w+1,w+1+t,cmp);//排序我这里比较懒直接写了快排，用插入排序会更快一点；
			sort(ww+1,ww+1+t,cmp);
		}
```


------------

- 这是对思路2的实现：
```cpp
else{
	if(w[t+1].z<ww[t].z){
		for(int i=1;i<=n;i++) f[i]=i;//重新跑一遍Kruskal；
		int k=0;
		for(int i=1;i<=t;i++){//插入排序；
			if(w[i].z>w[t+1].z) {k=i;break;}
		}
		for(int i=t;i>=k;i--)
			swap(w[i+1],w[i]);
		int tt=0;
		sum=0;
		for(int i=1;i<=t+1;i++){
			int r3=find(w[i].x),r4=find(w[i].y);
			if(r3!=r4){
				tt++;
				ww[tt]=w[i];//记录有用边；
				f[r4]=r3;
				sum+=w[i].z;
			}
		}
	}
}
for(int i=1;i<=t;i++) w[i]=ww[i];//存入有用边；
                
```

------------

- 最后输出：
```cpp
if(t==n-1){
	cout<<sum<<endl;
}
else cout<<-1<<endl;
```


------------

下面是没有注释完整代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m;
struct pp{
	int x,y,z;
}w[250],ww[250]; 
int f[205]; 
int sum; 
int t=0; 
int find(int x){
	if(f[x]!=x) f[x]=find(f[x]);
	return f[x];
}
bool cmp(pp a,pp b){
	return a.z<b.z;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)f[i]=i;
	for(int j=1;j<=m;j++){
		cin>>w[t+1].x>>w[t+1].y>>w[t+1].z;
		int r1=find(w[t+1].x),r2=find(w[t+1].y);
		if(r1!=r2){
			t++;
			f[r2]=r1;
			sum+=w[t].z;
			ww[t]=w[t];
			sort(w+1,w+1+t,cmp);
			sort(ww+1,ww+1+t,cmp);
		}
		else{
			if(w[t+1].z<ww[t].z){
				for(int i=1;i<=n;i++) f[i]=i;
				int k=0;
				for(int i=1;i<=t;i++){
					if(w[i].z>w[t+1].z) {k=i;break;}
				}
				for(int i=t;i>=k;i--)
					swap(w[i+1],w[i]);
				int tt=0;
				sum=0;
				for(int i=1;i<=t+1;i++){
					int r3=find(w[i].x),r4=find(w[i].y);
					if(r3!=r4){
						tt++;
						ww[tt]=w[i];
						f[r4]=r3;
						sum+=w[i].z;
					}
				}
			}
		}
		for(int i=1;i<=t;i++) w[i]=ww[i];
		if(t==n-1){
			cout<<sum<<endl;
		}
		else cout<<-1<<endl;
	}
	return 0;
}
```


------------
代码给出来了，理解还要靠你自己；希望对你有所帮助。



------------


 _尽管走出半生，归来仍是少年_ 

 _十年OI一场空，不开 l l见祖宗_ 

 _OI ER不自哀，管理AK   IOI_ 

 _落霞与孤鹜齐飞，秋水共长天一色_ 

 _山穷水尽疑无路，柳暗花明又一村_ 


---

## 作者：Forever丶CIL (赞：15)

这个题其实卡的是每次都sort的时间，我们可以放弃sort

改为一次性把所有边都记录下来（记录该边是第几次加的），然后排一遍序，然后做

m遍最小生成树，每次最小生成树只用添加时间比该次最小生成树次数小的边

2333


------------


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int f[2002];
int n,m,mins,ans;
int val,a,b;
struct tree
{
    int s;
    int e;
    int v;
    int si;
};
struct tree A[60101];
int cmp(tree x,tree y)
{
    return x.v<y.v;
}
int find(int x)
{
    if(f[x]==x)
        return x;
    return f[x]=find(f[x]);
}
void hb(int x,int y)
{
    f[x]=f[y];
}
void minset_tree(int cur)
{
    mins=0;ans=0;
    /*if(edge<n-1)
    {
        printf("-1\n");
        return ;
    }*/
    for(int i=1;i<=m;i++)
    {
        if(A[i].si<=cur)
        {
            int t1=find(A[i].s);
            int t2=find(A[i].e);
            if(t1!=t2)
            {
                hb(t1,t2);
                ans++;
                mins+=A[i].v;
            }
            //printf("%d ",ans);
            if(ans==n-1)
            {
                printf("%d\n",mins);
                return ;
            }
        }
        else continue;
    }
    printf("-1\n");
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        /*for(int j=1;j<=n;j++)
        {
            f[j]=j;
        }*/
        scanf("%d%d%d",&a,&b,&val);
        A[i].s=a;
        A[i].e=b;
        A[i].v=val;            //一次性记录所有边 
        A[i].si=i;            //记录每条边的添加时间 
        //insertsort(val);
        //sort(A+1,A+1+i,cmp);
        //zxscs(i);
    }
    sort(A+1,A+1+m,cmp);    //排一次序 
    for(int i=1;i<=m;i++)
    {
        if(i<n-1) 
        {
            printf("-1\n");
            continue;
        }
        for(int j=1;j<=n;j++)
        {
            f[j]=j;
        }
        minset_tree(i);
    }
    return 0;
}
```


------------


---

## 作者：ljc20020730 (赞：8)

对最小生成树算法的选择

题目大意：有N个点，W条边，每输入一条边回答一次当前是否存在最小生成树及最小生成树长度和。

解题思路：我们有两种常用的求最小生成树的算法

prim ：通过枚举点求最小生成树，每次的复杂度为O(N^2)，可以使用二叉堆优化。

kruskal：先将所有边排序，然后按长度从小到大选择，默认使用并查集，主要耗时为边的排序过程。

本题特点：需要求W次最小生成树，每次仅增加1条边。

算法选择：这题显然应该选择kruskal算法，因为每次只增加另一条边，只要插入之前已排序的部分即可完成排序过程。

由于利用了前一次的计算，W次kruskal的总时间降到了O(W^2)，可以漂亮地通过该题。

在本题中，prim算法每次都需要重新计算，显然是十分费力的，不宜选择。

```cpp
type rec=record
 u,v,w:longint;
end;
var n,m,i,u,v,w,tot,t1,t2:longint;
    a:array[0..200000]of rec;
    f:array[0..200000]of longint;
procedure swap(var a,b:rec);
var t:rec;
begin
 t:=a; a:=b; b:=t;
end;
procedure sort(u,v,w:longint);
var  node:rec;
     i:longint;
begin
 node.u:=u; node.v:=v; node.w:=w;
 if node.w>=a[tot].w then
 begin inc(tot); a[tot]:=node; exit; end;
 inc(tot);
 a[tot]:=a[tot-1];
 a[tot-1]:=node;
 i:=tot-1;
 while (i>1)and(a[i-1].w>a[i].w)do begin
  swap(a[i-1],a[i]);
  dec(i);
 end;
end;
function father(x:longint):longint;
begin
 if f[x]=x then exit(x);
 f[x]:=father(f[x]);
 exit(father(f[x]));
end;
procedure kruskal;
var ans,cnt,i,fx,fy,m:longint;
begin
 m:=tot;
 for i:=1 to m do f[i]:=i;
 cnt:=0;
 ans:=0;
 for i:=1 to m do begin
  fx:=father(a[i].u);
  fy:=father(a[i].v);
  if fx<>fy then begin
   f[fx]:=fy;
   inc(cnt);
   ans:=ans+a[i].w;
  end;
  if cnt=t1-1 then break;
 end;
 if cnt<>t1-1 then writeln('-1')
 else writeln(ans);
end;
begin
 readln(t1,t2);
 for i:=1 to t2 do begin
  readln(u,v,w);
  sort(u,v,w);
  kruskal;
 end;
end.

```

---

## 作者：绝艺 (赞：7)

题意明显是要跑多次kruskal，所以我们要考虑节约时间的方法

显然从第一周跑到最后一周太耗时间，于是我们就会想到从最后一周开始，逆序跑kruskal

这样的好处在于，一旦发现某一周不能构成最小生成树，那么那周之前也不可能构成最小生成树，于是我们可以少跑很多次kruskal

因为只能用那一周及之前的兽径建树，而在快排的时候边会被打乱，所以我们在结构体存边时要加一个参数，记录该边是第几周的兽径

剩下的就是kruskal的基本操作了

注意一点：每次kruskal时对于并查集用到的fa[]数组都要先初始化一次（我被这个坑了好久）

接下来请看~~华丽丽的~~代码

```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>

using namespace std;

struct node
{
	int u,v,w,p;//添加一个p表示该边是第p周的
}edge[6001];

int n,m,num=1,ans[6001],fa[201];

bool cmp(const node &a,const node &b)
{
	return a.w<b.w;//贪心，按边权从小到大排序
}

int find(int x)
{
	if(x==fa[x])
	   return x;
	return fa[x]=find(fa[x]);
}

void merge(int x,int y)
{
	fa[find(x)]=find(y);
}

int kruskal(int k)
{
	int cnt=0,tot=0;
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		if(cnt==n-1) break;
		if((find(edge[i].u)!=find(edge[i].v))&&(edge[i].p<=k))//只有前k周的才符合
		{
			merge(edge[i].u,edge[i].v);
			cnt++;
			tot+=edge[i].w;
		}
	}
	if(cnt<n-1) return -1;//如果不能构成最小生成树则返回-1
	else return tot;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>edge[i].u>>edge[i].v>>edge[i].w;
		edge[i].p=i;//标记周数
	}
	sort(edge+1,edge+m+1,cmp);
	for(int i=m;i>=1;i--)//逆序求解
	{
		ans[i]=kruskal(i);
		if(ans[i]==-1)//一发现不能建树就跳出循环，同时将前面的全设为-1
		{
			for(int j=1;j<i;j++) ans[j]=-1;
			break;
		}
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<endl;
	return 0;
}
```


---

## 作者：Hiraeth (赞：4)

### 解题报告：

题意概述：

在每一次加入一条边，求解该图是否存在最小生成树，如果有最生成树，输出该图最小生成树权值，如若不存在，则输出$-1$.

算法分析：

首先朴素做法是每次加入一条边 然后每一次进行一次$Kruskal$ 但是每一次都需要进行一次$sort$ 可能会被卡常

这时候我们考虑一下优化方式，能不能减少乃至于不需要进行多次排序.

这时候我们可以在存边的时候，在每条边储存的信息的基础上再添加一条信息--该边加入的时间 这样在每一次进行$Kruskal$时，就减少了$sort$排序的时间复杂度

实现了将在线做法转变为离线做法

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[6005],px,py;
struct p{
	int x,y,z,tim;
}a[6005];
int find(int x){
	if (x==f[x]) return x;
	return f[x]=find(f[x]);
}
bool cmp(p a,p b){
	return a.z<b.z;
}
int Kruskal(int num){
	int cnt=0,tmp=0;
	for (int i=1;i<=n;i++) f[i]=i;
	for (int i=1;i<=m;i++){
		px=find(a[i].x);
		py=find(a[i].y);
		if (px==py) continue;
		if (a[i].tim<=num){
			cnt++;
			tmp+=a[i].z;
			f[px]=py;
		}
	}
	if (cnt!=n-1) return -1;
	return tmp;
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++){
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
		a[i].tim=i;
	}
	sort(a+1,a+m+1,cmp);
	for (int i=1;i<=m;i++)	printf("%d\n",Kruskal(i));
	return 0;
} 
```


---

## 作者：zh_dou (赞：3)

## 分析
题目大意：
加m次边，每一次加边让你求最小生成树

如果每加一次边就跑一次 $Kruskal$ 复杂度就会送你上天

我们考虑先把边存起来，再倒着输出

当我们要删边时：

1. 在生成树上：

打上标记并重新跑最小生成树

2. 不在生成树上：

直接删去

## 代码

$\mathcal{Code:}$

```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long
#define R register
#define int long long
#define N 1000010
int n,m,num,t;
int fa[N],ans[N];
inline int read(){
    int x=0,y=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')y=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*y;
}
struct node{
    int l,r,w,exist,use,id;
    //exist:是否被删去
    //id:边的编号
    //use:是否在生成树中
}a[N<<1];
bool cmp(const node &a,const node &b){return a.w<b.w;}
int cnt,head[N];
inline int finds(int x){
    if(x==fa[x])return x;
    return fa[x]=finds(fa[x]);
}
inline void Kruskal(){
    for(int i=1;i<=n;i++){fa[i]=i;head[i]=0;a[i].use=0;}//记得赋初值
    cnt=0;t=0;
    int res=0;
	for(int i=1;i<=m;i++){
        int x=a[i].l,y=a[i].r;
        if(finds(x)==finds(y)||a[i].exist==0) continue;
        int fx=finds(x),fy=finds(y);
        fa[fx]=fy;
        t+=a[i].w;res++;
        a[i].use=1;
    }
    if(res<n-1) t=-1;//如果选择了不够n-1条路径，将t赋为-1
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();m=read();
    for(int i=1,x,y,z;i<=m;i++){
        x=read();y=read();z=read();
        a[i].l=x;a[i].r=y;a[i].w=z;a[i].exist=1;a[i].id=i;
    } 
    sort(a+1,a+1+m,cmp);
    Kruskal();
    ans[m]=t;
    for(int i=m-1;i>=1;i--){
    	if(i<n-1){ans[i]=-1;continue;}//如果路径不够n-1条，将ans赋为-1
    	int j=1;
    	for(;j<=m;j++) if(a[j].id==i+1){a[j].exist=0;break;}
		if(a[j].use) Kruskal();
		ans[i]=t;
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<"\n";
	
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```

---

## 作者：shuiyuhan (赞：2)

蒟蒻在线暴力过了！！！

提供一个灰常暴力的在线做法

就像其他dalao所说，这题就是一个克鲁斯卡尔。

但似乎不用离线，直接在线暴力加边，暴力处理就好了，每次对于读入的边，

因为这条边的价值可能对当前答案产生影响，所以把这条边入队，就是每次重新跑一边快排，然后在重新跑一边克鲁斯卡尔，时间O(n lg n*w)

重新并查集找一次最短路，还有一种方法是因为已经排好了前面的序列，所以插当前边的时候用插入排序即可(没试过)

最后只要当前的答案不为-1，那么下面所有的答案也肯定小于等于当前答案，因为

肯定能用这次的几条边组成答案。

只不过需要卡卡常(逃

代码：
```c++
// luogu-judger-enable-o2//洛谷自带的O2
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")//24行大优化(卡常)
p.s 正式比赛最好不用这种方法，否则可能会出现莫名的CE啦
#include<bits/stdc++.h>
using namespace std;
struct E {
    int x,y,z;
} a[500005];//结构体存图排序更方便
int n,m,t;
int fa[500005],b[500005],c[500005];

inline int read(){
    register int x=0;register char ch=getchar();
    for(;!isdigit(ch);ch=getchar());
    for(;isdigit(ch);ch=getchar())x=x*10+(ch&15);
    return x;
}//快读(卡常)输出就n个数，所以不用打快输
bool cmp(E x,E y) {
    return x.z < y.z;//按价值从小到大排
}//克鲁斯卡尔按路的长度排序
int find(int x) {
    if (fa[x] != x) fa[x] = find(fa[x]);//路径压缩，并查集常用技巧
    return fa[x];
}//并查集找祖宗
int main() {
    n=read();
    m=read();
    for (int i=1; i<=m; ++i) {
        a[i].x=read();
        a[i].y=read();
        a[i].z=read();//读入
        t++;//t代表当前有几个数(其实相当于i,也可以删了)
        sort(a + 1,a + t + 1,cmp);//每读一次重新快排一遍
        for (int i=1; i<=n; ++i) fa[i]=i;//每次初始化
        int k=0, ans=0;
        for (int j=1; j<=t; ++j)//对当前的t个数做克鲁斯卡尔
            if (find(a[j].x)!=find(a[j].y)) {
                fa[find(a[j].x)]=find(a[j].y);//连根
                ans+=a[j].z;//找到了答案加上价值
                k++;//k代表当前已选择的边条数，
            }//并查集找+合并，其中k代表有几个点能走到
        if (k==n-1) {//如果所有城市之间都有边联通
            printf("%d\n",ans);
            continue;
        }
        cout<<-1<<endl;//还有点走不到，输-1
    }
}
```

---

## 作者：agicy (赞：2)

享受最佳阅读体验请进入[传送门](https://lu-anlai.github.io/2019/02/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E3%80%90%E6%B4%9B%E8%B0%B7-P1340%E3%80%91-%E5%85%BD%E5%BE%84%E7%AE%A1%E7%90%86/)。

## 原题

题面请查看[洛谷 P1340 兽径管理](https://www.luogu.org/problemnew/show/P1340)。

## 题解

$\text{Kruskal}$算法

### 思路

1. 先读入所有边，每条边以时间为编号`ID`；
2. 对边以**边权**为关键字进行排序；
3. 以$1$~$w$为参数进行$\text{Kruskal}$算法：
    - 如果这条边的编号大于所给参数，这条边不参与算法；
    - 否则寻找最小生成树。
4. 输出答案。

### 代码

代码如下：

```cpp
#include <algorithm>
#include <cstdio>
//头文件
using std::sort;//快速排序

struct Edge//定义 边 的结构体
{
    int ID, f, t, val;
    bool operator<(const Edge &a) const
    {
        return val < a.val;
    }
};

struct Union_Find//定义 并查集 的结构体
{
    int ID[201];
    Union_Find(int);//析构函数，用于并查集的初始化，参数为n
    void connect(int, int);//并
    bool search(int, int);//查
    int find(int);//查
};

int n, w;
Edge E[6001];

int Kruskal(int);

int main(void)
{
    register int i;
    scanf("%d%d", &n, &w);
    for (i = 1; i <= w; ++i)
    {
        E[i].ID = i;//每条边以时间为编号
        scanf("%d%d%d", &E[i].f, &E[i].t, &E[i].val);//读入
    }
    sort(E + 1, E + w + 1);//快速排序
    for (i = 1; i <= w; ++i)
        printf("%d\n", Kruskal(i));//调用函数并输出结果
    return 0;//在主函数末尾加上return 0;是一个好习惯
}

Union_Find::Union_Find(int n)//析构函数，用于并查集的初始化，参数为n
{
    register int i;
    for (i = 1; i <= n; ++i)
        ID[i] = i;
    return;
}

void Union_Find::connect(int a, int b)
{
    register int ra = find(a), rb = find(b);
    if (ra != rb)
        ID[rb] = ra;
    return;
}

bool Union_Find::search(int a, int b)
{
    return find(a) == find(b);
}

int Union_Find::find(int x)
{
    if (x == ID[x])
        return x;
    else
        return ID[x] = find(ID[x]);//路径压缩
}

int Kruskal(int time)
{
    register int i, cnt = 0, sum = 0;
    //cnt为连接边的数量
    Union_Find UF(n);//先定义一个并查集UF，析构函数的参数为n
    for (i = 1; i <= w && cnt < n - 1; ++i)
        if (E[i].ID > time)//如果这条边的编号大于所给参数，这条边不参与算法
            continue;
        else if (!UF.search(E[i].f, E[i].t))//如果这条边连接的两个点不在同一个集合内
        {
            ++cnt;
            sum += E[i].val;
            UF.connect(E[i].f, E[i].t);
        }//统计答案
    if (cnt != n - 1)//如果无法构成树
        return -1;//题目要求输出-1
    else
        return sum;//返回答案
}
```

### 我的评测记录

- [洛谷 R16089070](https://www.luogu.org/recordnew/show/16089070)。


---

## 作者：OIer991215 (赞：2)

本题居然没有题解！

本题最快的正解做法为: 当构建好一个最小生成树之后，继续加边。必然加边后会产生一个环，减去此环中的最大值即为正解。

本蒟蒻的代码做法为：当构建好一个最小生成树之后，继续加边，重新构造最小生成树，重新计算正解。

反正本题过了，希望各位大佬能在我代码上 优化为正解做法。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int father[505050];
int w,i,j,x,m,n,ans,edge;
int a,b;
struct Node
{
    int x;
    int y;
    int dis;
}road[505050];
void INSERT_SORT()  //写起来很难受的插入排序 
{
    int key_1=road[w].x;
    int key_2=road[w].y;
    int key_3=road[w].dis;
    j=w-1;
    while(j>0 && road[j].dis > key_3)
    {
        road[j+1].x=road[j].x;
        road[j+1].y=road[j].y;
        road[j+1].dis=road[j].dis;
        j--;
    }
    road[j+1].x=key_1;
    road[j+1].y=key_2;
    road[j+1].dis=key_3;
}
int find(int a)   //并查集的查 
{
    if(a==father[a])
        return a;
    else
        return father[a]=find(father[a]);
}
void unite(int a,int b) //并查集的并 
{
    a=find(a);
    b=find(b);
    father[a]=b;
}
void Kruscal()
{
    for(int i=1; i<=w; i++)
        if( find(road[i].x) != find(road[i].y) )
        {
            unite(road[i].x,road[i].y);
            ans+=road[i].dis;
            edge++;
            if(edge==m-1) // m个点，只需要m-1条边就可以构成最小生成树 
                return;
        }
}
bool check()   //暴力检测 所有的点有没有在最小生成树里 
{
    int s=find(father[1]);
    for(int i=2; i<=m; i++)
        if(s!=find(father[i]))
            return false;
    return true;
}
void INIT()
{
    for(int i=1; i<=m; i++)
        father[i]=i;
    ans=0;
    edge=0;
}
int main()
{
    scanf("%d%d",&m,&n);
    while(n--)
    {
        INIT();  //初始化，为暴力做铺垫 
        w++; 
        scanf("%d %d %d",&road[w].x,&road[w].y,&road[w].dis);
        INSERT_SORT();   //插入排序，本题插入排序要比sort快得多 
//        for(int i=1; i<=w; i++)
//            cout<<road[i].x<<" "<<road[i].y<<" "<<road[i].dis<<endl;
//        cout<<endl;
        Kruscal();    //正常的克鲁斯卡尔算法 
//        for(int i=1; i<=m; i++)
//            cout<<father[i]<<" ";
//        cout<<endl;
        if( check() )  //检验，当构成一棵树时，所有点的find(father[i]) 均为同一值 
            printf("%d\n",ans);
        else
            printf("-1\n");
    }
    return 0;
}
```

---

## 作者：wshz (赞：2)

//插入排序+SPFA+智慧=AC;
```cpp
#include<bits/stdc++.h>
using namespace std;
struct D{
    int a,b,c;
}d[6001];
int w,n,m,a,b,c,h[60001],v[60001],f[60001],k,ans,fg,gg,lll; 
int find(int x)
{
    if(f[x]!=x)	f[x]=find(f[x]);
    return f[x];
}
bool cmp(D x,D y)
{
    return x.c<y.c;
}
int wf(int x,int y)//二分找第一个比要插入的值大的坐标；
{
    int l=1,r=x,mid;
    while(l<r)
    {
        mid=(l+r)/2;
        if(d[mid].c>y)	r=mid;
        else l=mid+1;
    }
    return l;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)/*因为每一组解都判断所以边输入
    边做；*/
    {
        ans=0,k=0;
        scanf("%d%d%d",&d[i].a,&d[i].b,&d[i].c);
        if(i*2<n)
        {
            cout<<"-1"<<endl;
            continue;
        }/*因为如果要每个点都连通，输入的点数一定大于n个
        点（剪枝）；*/
        for(int j=1;j<=n;j++)
        f[j]=j;//初始化；
        if(!fg)//标记：第一遍用sort排；
        {
            sort(d+1,d+1+i,cmp);
            fg=1;
        }
        else//不是第一次用插入排序（sort会超时）；
        {
            int a1,b1,c1;//中间变量；
            a1=d[i].a;
            b1=d[i].b;
            c1=d[i].c;
            gg=wf(i-1,d[i].c);//二分；
            for(int j=i;j>gg;j--)/*将前值向后移，空出要
            插入的位置（要从后向前插，否则后面值会被覆盖）；*/
            {
                d[j].c=d[j-1].c;
                d[j].a=d[j-1].a;
                d[j].b=d[j-1].b;
            }
            d[gg].c=c1;//插入该值；
            d[gg].b=b1;
            d[gg].a=a1;
        }
        //SPFA模板；
        for(int j=1;j<=i;j++)
        {
            int x1=find(d[j].a),x2=find(d[j].b);/*求出两
            点的祖先节点*/
            if(x1!=x2)
            {
                f[x1]=x2;//合并两点；
                ans+=d[j].c;
                k++;
            }
            if(k==n-1)
            {
        		cout<<ans<<endl;//找到一个,直接输出；
        		lll=1;//标记；
                break;
            }
        }
        if(lll==0)//没标记输出“—1”;
        cout<<"-1"<<endl;
        lll=0;
    }
    return 0;
}
```

---

## 作者：唔啊唔 (赞：1)

其他题解用的都是kruskal，于是我便写了一篇prim来补充一下prim的空白。

记得开o2优化！！！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,z,num,head[5010],dis[5010],vis[5010];
struct Node{	//边的结构体 
	int to,dis,next;
}a[400010];
inline void add(int from,int to,int dis){//加边函数 
	num++;
	a[num].to=to;
	a[num].dis=dis;
	a[num].next=head[from];
	head[from]=num;
}
priority_queue<pair<int,int> >q;//优先队列 
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){//每次加边时都找一次 
		cin>>x>>y>>z;
		add(x,y,z);
		add(y,x,z);
		memset(vis,0,sizeof(vis));
		for(int i=1;i<=n;i++)dis[i]=1e9;
		dis[1]=0;
		q.push(make_pair(0,1));
		while(!q.empty()){	//模板
			int tmp=q.top().second;
	    	q.pop();
			if(vis[tmp]==1)continue;
			vis[tmp]=1;
			for(int i=head[tmp];i;i=a[i].next){
				int k=a[i].to,d=a[i].dis;
				if(dis[k]>d&&vis[k]==0){
					dis[k]=d;
					q.push(make_pair(-dis[k],k));
				}
			}
		}
		int maxn=0,cnt=0;
		for(int i=1;i<=n;i++){
			if(dis[i]==1e9){	//找不到最短生成树 
				cout<<"-1"<<endl;
				cnt=1;
				break;
			}
			maxn+=dis[i];
		}
		if(cnt==0)cout<<maxn<<endl;
	}
	return 0;
}
```



---

## 作者：南苑沁青 (赞：1)

##  暴力求解：

------------

暴力操作：对于每加 1 条边，就暴力地求出最小生成树的边权和。

**暴力代码：**
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<string>
#include<vector>
#include<stack>
#include<deque>
#include<queue>
#include<map>
#include<set>
using namespace std;
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define maxn 6001
typedef long long LL;
LL n,w,cnt,ans;
LL fa[maxn];
struct hh
{
	LL l,r,w;
}t[maxn];
inline LL read()
{
	LL xs=0,kr=1;char ls;
	ls=getchar();
	while(!isdigit(ls))
	{
		if(!(ls^45))
			kr=-1;
		ls=getchar();
	}
	while(isdigit(ls))
	{
		xs=(xs<<1)+(xs<<3)+(ls^48);
		ls=getchar();
	}
	return xs*kr;
}
inline bool cmp(const hh&l,const hh&r)
{
	return l.w<r.w;
}
inline LL find(LL u)
{
	if(u!=fa[u]) fa[u]=find(fa[u]);
	return fa[u];
}
inline void kruskal(LL num)
{
	sort(t+1,t+num+1,cmp);
	for(LL i=1;i<=num;i++) fa[i]=i;
	for(LL i=1;i<=num;i++)
	{
		LL r1=find(t[i].l),r2=find(t[i].r);
		if(r1!=r2)
		{
			fa[r1]=r2;
			ans+=t[i].w;
			cnt++;
		}
		if(cnt==n-1) {printf("%lld\n",ans);return;}
	}
	printf("-1\n");
}
int main()
{
	n=read();w=read();
	for(LL i=1;i<=w;i++)
	{
		ans=0,cnt=0;
		t[i].l=read();t[i].r=read();t[i].w=read();
		kruskal(i);
	}
return 0;
}
```
然后就。。。T掉了（/(ㄒoㄒ)/~~）。
## AC做法：


------------

首先：我们可以分析，暴力做法被卡掉的原因是做了 W 次的快排，使时间复杂度大大提高。

其次：本题，并没有强制要求在线求解。为了优化暴力算法的时间复杂度，可以考虑一下离线做法：

① 每次加进 1 条边，给它打上一个时间标号（表示这条边是第几次加入的）。

② 在所有的边都添加完毕后，按权值大小 sort 排序一遍。

③ 接下来就可以愉快地做 W 遍的最小生成树：每次枚举的边只需要判断这条边的时间标号是否大于正在做最小生成树次数 i ，如果大于就跳过，不大于就按照普通的最小生成树判断是否要添加。

**伪代码：**
```cpp
sort(t+1,t+w+1,cmp);//按边权排序，（假装已经用 t 数组存好了） 
for(i=1;i<=w;i++)//第几次做最小生成树 
{
	for(j=1;j<=w;j++)//依次枚举每一条边 
	{
		if(t[j].tim>i) continue;//如果枚举到的边的时间标志＞i，跳过
		else
		{
			……//按照普通的最小生成树做法，加边。 
		}
	}
}
```
**完整代码**
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<string>
#include<vector>
#include<stack>
#include<deque>
#include<queue>
#include<map>
#include<set>
using namespace std;
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define maxn 6001
typedef long long LL;
LL n,w,cnt,ans;
LL fa[maxn];
struct hh
{
	LL l,r,w,tim;
}t[maxn];
inline LL read()
{
	LL xs=0,kr=1;char ls;
	ls=getchar();
	while(!isdigit(ls))
	{
		if(!(ls^45))
			kr=-1;
		ls=getchar();
	}
	while(isdigit(ls))
	{
		xs=(xs<<1)+(xs<<3)+(ls^48);
		ls=getchar();
	}
	return xs*kr;
}
inline bool cmp(const hh&l,const hh&r)
{
	return l.w<r.w;
}
inline LL find(LL u)
{
	if(u!=fa[u]) fa[u]=find(fa[u]);
	return fa[u];
}
inline void kruskal(LL num)
{
	for(LL i=1;i<=w;i++) fa[i]=i;
	for(LL i=1;i<=w;i++)
	{
		if(t[i].tim>num) continue;
		LL r1=find(t[i].l),r2=find(t[i].r);
		if(r1!=r2)
		{
			fa[r1]=r2;
			ans+=t[i].w;
			cnt++;
		}
		if(cnt==n-1) {printf("%lld\n",ans);return;}
	}
	printf("-1\n");
}
int main()
{
	n=read();w=read();
	for(LL i=1;i<=w;i++)
	{
		t[i].l=read();t[i].r=read();t[i].w=read();t[i].tim=i;
	}
	sort(t+1,t+w+1,cmp);
	for(LL i=1;i<=w;i++)
	{
		ans=0,cnt=0;
		kruskal(i);
	}
return 0;
}
```


------------
这种离线做法可能是这道题最简单的做法了，除了给每条边加个时间标号，其它都只要套最小生成树模板。d=====(￣▽￣*)b

---

## 作者：寒酥 (赞：1)

常见的一种思路是先求出最小生成树，之后每次出现一条边(u,v)，一定会形成一个包含u,v两点的环，此时用新边更新换上的最大值，每次都能保证图的连通性，且满足当前最优解，那么问题就是如何快速更换(u,v)路径上的最大值，曾经想过加边成环之后去除环的最大边，但是**我太菜了**，不会写。。。

想到用LCT维护两点间边权最大值，然后，就写出来了。。。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,ans,mx[N],fa[N],val[N],s[N],num,js;
struct mst
{
    int u,v,w;
    bool operator<(const mst &c)const{return w<c.w;}
}e[N];
struct LCT
{
    int top,f[N],c[N][2],rev[N],q[N];
    LCT()
    {
        top=0;
        memset(f,0,sizeof(f));
        memset(c,0,sizeof(c));
        memset(rev,0,sizeof(rev));
        memset(q,0,sizeof(q));
    }
    inline bool isroot(int x){return c[f[x]][1]!=x&&c[f[x]][0]!=x;}
    inline void pushup(int x)
    {
        mx[x]=val[x],s[x]=x;
        if(c[x][0]&&mx[c[x][0]]>mx[x]) mx[x]=mx[c[x][0]],s[x]=s[c[x][0]];
        if(c[x][1]&&mx[c[x][1]]>mx[x]) mx[x]=mx[c[x][1]],s[x]=s[c[x][1]];
    }
    inline void pushdown(int x){if(rev[x]) swap(c[x][1],c[x][0]),rev[c[x][1]]^=1,rev[c[x][0]]^=1,rev[x]^=1;}
    inline void rotate(int x)
    {
        int y=f[x],z=f[y],l=c[y][1]==x,r=l^1;
        if(!isroot(y)) c[z][c[z][1]==y]=x;
        if(c[x][r]) f[c[x][r]]=y;
        c[y][l]=c[x][r],c[x][r]=y;
        f[x]=z,f[y]=x;
        pushup(y);
    }
    inline void splay(int x)
    {
        q[top=1]=x;
        for(int i=x;!isroot(i);i=f[i]) q[++top]=f[i];
        while(top) pushdown(q[top--]);
        while(!isroot(x))
        {
            int y=f[x],z=f[y];
            if(!isroot(y)) rotate((c[y][0]==x)^(c[z][0]==y)?x:y);
            rotate(x);
        }
        pushup(x);
    }
    inline void access(int x){for(int t=0;x;x=f[t=x]) splay(x),c[x][1]=t;}
    inline void makeroot(int x){access(x),splay(x),rev[x]^=1;}
    inline void split(int x,int y){makeroot(x),access(y),splay(y);}
    inline void link(int x,int y){makeroot(x),f[x]=y;}
    inline void cut(int x,int y){split(x,y),c[y][0]=f[x]=0,pushup(y);}
}T;
int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}
int main()
{
    scanf("%d%d",&n,&m);
    js=m+1;
    for(int i=1;i<=n;++i) fa[i]=i;
    for(int i=1;i<=m;++i) scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
    for(int i=1;i<=m;++i)
    {
        int fx=find(e[i].u),fy=find(e[i].v);
        if(fx!=fy) fa[fx]=fy,++num;
        if(num==n-1)
        {
            js=i;
            break;
        }
    }
    sort(e+1,e+js+1);
    for(int i=1;i<=n;++i) fa[i]=i;
    num=0;
    for(int i=1;i<js;++i) printf("-1\n");
    for(int i=1,u,v;i<=js;++i)
    {
        int fx=find(u=e[i].u),fy=find(v=e[i].v);
        if(fx!=fy) fa[fx]=fy,T.link(u,i+n),T.link(v,i+n),mx[i+n]=val[i+n]=e[i].w,ans+=e[i].w,++num;
    }
    if(js!=m+1) printf("%d\n",ans);
    for(int i=js+1;i<=m;++i)
    {
        int u=e[i].u,v=e[i].v;
        T.split(u,v);
        int now=s[v];
        if(e[now-n].w>e[i].w)
        {
            ans=ans-e[now-n].w+e[i].w;
            T.cut(e[now-n].u,now),T.cut(e[now-n].v,now);
            val[i+n]=mx[i+n]=e[i].w;
            T.link(u,i+n),T.link(v,i+n);
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
其中有一些蜜汁繁琐操作，解决了link，cut的正确性，大佬们都会吊打我啊，，逃！

---

## 作者：voyage1969 (赞：1)

### 思路

初次分析，认为是 **KRUSKAL** 算法能够解决的事情。 **KRUSKAL** 算法时间复杂度实际上非常优秀，在最坏情况下跑6000遍边数为1~6000的KRUSKAL算法其实并不会超时。

本题在时间上最大的消耗是动态的排序。如果每添加一条边就去跑一遍sort，那么时间复杂度是 **O(n\*n\*logn)** ，但是由于添加一条边之前就已经把其他的边排好序了，所以只要将新的边插入到合适的位置去就可以了。所以 **二分查找+插入** 就好，时间复杂度 **O(nlog2)** 。（其实本题用冒泡排序都比sort快...原因是冒泡会一次将新添加的边“上浮”到第一个满足整个序列为非降序的地方，同时将比该边更大的边一次“上浮”，第二次扫描序列就满足条件终止了，时间复杂度 **O(n\*n)** ，都比sort快...所以STL快速排序并不是王能的。）

所以本题的做法是：裸的 **KRUSKAL** + **二分查找插入排序** ！

小小的优化技巧：如果新的兽径插入后，且原先的路线已经能够连通所有牧场时，新的兽径在之前最后选择的一条边之后，那么这一条兽径必定不会被考虑。直接输出上次的答案。

### 实现

这份代码使用了 **vector** 和 **lower_bound** 来展示二分查找和插入的功能。如果使用 **set** ，代码编写还会更加简单。（STL大法。）

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
////////////////////////////////////////////////////////////////
const int N=205,M=6005;

struct typeEdge;
struct typeNode;

int main();
////////////////////////////////////////////////////////////////
struct typeEdge
{
	int len;
	typeNode * sub1,* sub2;

	friend bool operator < (typeEdge pa1,typeEdge pa2)
	{
		return pa1.len<pa2.len;
	}

	void fill(int,typeNode *,typeNode *);
};

struct typeNode
{
	typeNode * pa;

	typeNode * find();
	void merge(typeNode *);
};
////////////////////////////////////////////////////////////////
int n,m,ccN,ans;
typeNode node[N];
std::vector<typeEdge> edgeV;
////////////////////////////////////////////////////////////////
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<m;i++)
	{
		int i1,i2,i3;
		typeEdge ed1;
		scanf("%d%d%d",&i1,&i2,&i3);
		ed1.fill(i3,node+i1,node+i2);

		std::vector<typeEdge>::iterator it1;
		it1=std::lower_bound(edgeV.begin(),edgeV.end(),ed1);
		edgeV.insert(it1,ed1); //将边添加到合适的位置。

		memset(node,NULL,sizeof(node));
		ccN=n,ans=0; //将所有点从并查集中取出，表示不能连通。

		std::vector<typeEdge>::iterator it2,itE2;
		it2=edgeV.begin(),itE2=edgeV.end();

		while(1<ccN&&it2<itE2)
		{
			if(it2->sub1->find()==it2->sub2->find()) it2++;

			else it2->sub1->merge(it2->sub2),ccN--,ans+=it2->len;
		}

		if(ccN==1) printf("%d",ans),putchar('\n');
		else putchar('-'),putchar('1'),putchar('\n');
	}
	return 0;
}

void typeEdge::fill(int pa1,typeNode * pa2,typeNode * pa3)
{
	this->len=pa1,this->sub1=pa2,this->sub2=pa3;
}

typeNode * typeNode::find()
{
	if(this->pa==NULL) return this;
	else return this->pa=this->pa->find();
}

void typeNode::merge(typeNode * pa1)
{
	pa1->find()->pa=this;
	return;
}
////////////////////////////////////////////////////////////////

```

---

## 作者：20140408abcd (赞：0)

   首先我们要先明确一点,你新加入一条边,只会让原先是最小生成树上的边被顶替,要么不冲突的成为最小生成树上的边,否则就是没成为.定不会让先前不是最小生成树上的边成为最小生成树上的边.
   
   根据这个性质,我们可以记录下当前最小生成树上的边,并把不在最小生成树上的边忽略掉.
   
   接着我们新加入的边与先前在最小生成树上的边排序,由于先前存储的最小生成树上的边已有序,我们可O(N)插入完成
   
   然后我们跑Kruskal,若存在不是最小生成树上的边就O(N)删除即可
   
   于是我们就用O(4N)=O(N)的时间由前i-1条边的最小生成树推到了前i-1条边的最小生成树,总时间O(NM)
   
```
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct point
{
	int u,v,d;
}a[6005],team[205];
int top,fa[201];
long long read()
{
	long long x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
int find(int x)
{
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return fa[x];
}
void go(point a)
{
	for(int i=1;i<=n;i++)fa[i]=i;
	//O(N)插入
	team[++top]=a;
	for(int i=top;i>=1;i--)if(team[i].d<team[i-1].d)swap(team[i],team[i-1]);
	int k=0,res=0;
	//经典Kruskal
	for(int i=1;i<=top;i++)
	{
		int r1=find(team[i].u),r2=find(team[i].v);
		if(r1!=r2)
		{
			fa[r2]=r1;
			res+=team[i].d;
		}
		else k=i;//标记不在最小生成书上的边 
	}
	if(k)
	{
		//删除 
		top--;
		for(int i=k;i<=top;i++)
		swap(team[i],team[i+1]);
	}
	if(top!=n-1)res=-1;//有n-1条边就有解,反之无解 
	printf("%d\n",res); 
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)a[i].u=read(),a[i].v=read(),a[i].d=read();
	for(int i=1;i<=m;i++)go(a[i]);//依次插入 
}
```


---

## 作者：Error_666 (赞：0)

- ~~这题废话贼多~~，简要题意是这样的：N个点，W条边，每输入一条边回答一次当前是否存在最小生成树。存在，输出最小生成树长度和。；不存在，输出-1。

- 考虑kruskal。暴力思路就是每加一次边就做一遍kruskal。这样做的时间瓶颈是在每遍都要sort排序一遍，总体复杂度大概是O(nlogn * m)。卡卡常或许能过去？

- 那么优化掉sort这一步不就行了吗？我选择用归并排序。因为前面的边已经是有序的了，所以每次插入一条边就与前面的边合并就行了。每次排序的复杂度是O(n)，所以整体复杂度是O(nm)。

```cpp
#include <iostream>
#include <cstdio>
#define N 205
#define M 6005
using namespace std;

struct E {int u, v, w;} e[M], t[M];
int n, m, cnt, flag, ans;
int fat[N];

int getFat(int x)
{
    if(x == fat[x]) return x;
    return fat[x] = getFat(fat[x]);
}

void merge(int s1, int e1, int s2, int e2)
{
    int p1 = s1, p2 = s2, dfn = 0;
    while(p1 <= e1 && p2 <= s2)
    {
        if(e[p1].w < e[p2].w) t[++dfn] = e[p1], p1++;
        else t[++dfn] = e[p2], p2++;
    }
    while(p1 <= e1) t[++dfn] = e[p1], p1++;
    while(p2 <= e2) t[++dfn] = e[p2], p2++;
    for(int i = 1; i <= e2; i++) e[i] = t[i];
}

int main()
{
    freopen("P1340.in", "r", stdin);
    freopen("P1340.out", "w", stdout);

    cin >> n >> m;
    for(int i = 1; i <= m; i++)
    {
        cnt = flag = ans = 0;
        for(int j = 1; j <= n; j++) fat[j] = j;
        scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].w);
        merge(1, i - 1, i, i);
        for(int j = 1; j <= i; j++)
        {
            if(getFat(e[j].u) != getFat(e[j].v))
            {
                fat[getFat(e[j].u)] = getFat(e[j].v);
                cnt++, ans += e[j].w;
            }
            if(cnt == n - 1) {flag = 1; break;}
        }
        if(!flag) printf("-1\n");
        else printf("%d\n", ans);
    }
    return 0;
}

```


---

## 作者：Kisaragi_77 (赞：0)

还是比较水的

一眼看起来是一个支持动态加边的MST


然而数据范围很水

$O(m^2)$稳过

**具体而言,我们可以把每次建好的树销毁,直接重构一遍即可,可以使用$kruscal$算法**

由于我们每次之加一条边,所以快排并不够优秀,可以维护一个有序的,支持实时插入的边集,可以用vector很好的替代,内存,速度,码量都很优秀
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x;scanf("%d",&x);return x;
}
struct Edge{
    int from,to,w;
};
inline bool operator<(const Edge &x,const Edge &y){
    return x.w < y.w;
}
const int N =300;
int fa[N],n;
inline int find(int x){
    return fa[x] =(x==fa[x]) ? x : find(fa[x]);
}
inline void merge(int x,int y){
    fa[find(x)] =find(y);
}
vector<Edge> s;
inline int kruscal(){
    int ans =0,cnt =0;
    for(int i=1;i<=n;++i)   fa[i] =i;//销毁生成树
    for(const auto &p : s){
        int u =p.from,v =p.to;
        if(find(u)==find(v))    continue;
        ans +=p.w;
        cnt ++;
        merge(u,v);
        if(cnt==n-1)    return ans;    
    }   return -1;
}

int main(){
    n =read();  int T =read();
    while(T--){
        Edge p;
        p.from =read();
        p.to =read();
        p.w =read();
        s.insert(upper_bound(s.begin(),s.end(),p),p);//二分位置暴力插边
        printf("%d\n",kruscal());
    }
}

```

---

## 作者：Zekrom (赞：0)

主要思路也是逆序求解最小生成树  
但实现方式上稍微有些不同  
我们使用Tedge来实现每次后kruskal后的还原现场  
### 另外有一点要强调  
讨论里说数据范围错误是不对的，仔细理解题目，我们是对边m排序，所以使用的vis,use数组等范围应应该为maxM，而不是maxN  
所以  
### 200*100>6000 ,才有了讨论里要 *乘100的错误说法  
那么贴上代码，注意还原的过程  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 210
#define M 6010
using namespace std;
int n,m,fa[N],cnt,ans,t[M];
bool vis[M];
struct Edge{
	int u,v,val,id;
	bool operator <(Edge s)const{return val<s.val;}
}edge[M],tedge[M];
inline int read(){
	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return x*f;
}
inline int get(int x){return x==fa[x]?x:fa[x]=get(fa[x]);}
int kruskal(int x){
	memset(vis,0,sizeof(vis));int tans=0;cnt=0;
	for(int i=1;i<=n;i++)fa[i]=i;
	sort(edge+1,edge+1+x);
	for(int i=1;i<=x;i++){
		int u=edge[i].u,v=edge[i].v,z=edge[i].val,id=edge[i].id;
		int a=get(u),y=get(v);
		if(a!=y){fa[a]=y;tans+=z;cnt++;vis[id]=1;}
		if(cnt==n-1)return tans;
	}
	return -1;
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++) {
		edge[i].u=read(),edge[i].v=read(),edge[i].val=read(),edge[i].id=i;
	}
	for(int j=1;j<=m;j++)tedge[j].u=edge[j].u,tedge[j].v=edge[j].v,tedge[j].val=edge[j].val,tedge[j].id=edge[j].id;
	t[m]=kruskal(m);
	for(int j=1;j<=m;j++)edge[j].u=tedge[j].u,edge[j].v=tedge[j].v,edge[j].val=tedge[j].val,edge[j].id=tedge[j].id;
	for(int i=m-1;i;i--){
		for(int j=1;j<=i;j++)tedge[j].u=edge[j].u,tedge[j].v=edge[j].v,tedge[j].val=edge[j].val,tedge[j].id=edge[j].id;    
		if(vis[i+1]){
			ans=kruskal(i);
			if(ans!=-1)
				t[i]=ans;
			else{
				for(int j=i;j;j--)t[j]=-1;
				break;
			}
		}
		else t[i]=t[i+1];
		for(int j=1;j<=i;j++)edge[j].u=tedge[j].u,edge[j].v=tedge[j].v,edge[j].val=tedge[j].val,edge[j].id=tedge[j].id;            //还原现场
	} 
	for(int j=1;j<=m;j++)
		printf("%d\n",t[j]);
	return 0;
}

```


---

## 作者：MashPlant (赞：0)

其实可以用stl水过......
首先正常用kruskal的求MST需要维护一个排好序的边集合，现在时刻都有边插进来，只要能维护好这个集合，与正常的kruskal就完全一样。
维护排好序的集合?上set。当然了，因为权值可能重复，所以需要用multiset。
不开优化1244ms，开优化192ms，都还说的过去。这种题目就没必要手写平衡树啦。

以下是代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int p[210], r[210];
void init(int n)
{
    for (int i = 1; i <= n; ++i)
        p[i] = i;
}
int find(int x)
{
    return p[x] == x ? x : p[x] = find(p[x]);
}

bool connected(int x, int y)
{
    return find(x) == find(y);
}

void connect(int x, int y)
{
    int px = find(x), py = find(y);
    if (px != py)
    {
        if (r[px] > r[py])
            p[py] = px;
        else
        {
            p[px] = py;
            if (r[px] == r[py])
                ++r[py];
        }
    }
}

struct E
{
    int a, b, w;
    bool operator<(const E &r) const
    {
        return w < r.w;
    }
};

inline int read()
{
    static char ch;
    bool sgn = false;
    while ((ch = getchar()) < '0' || ch > '9')
        if (ch == '-')
            sgn = true;
    int res = ch - 48;
    while ((ch = getchar()) >= '0' && ch <= '9')
        res = res * 10 + ch - 48;
    return sgn ? -res : res;
}
const int inf = 0x3f3f3f3f;
//动态最小生成树,速度瓶颈在排序而非选边
//所以考虑用set维护排好序的边
int main()
{
    int n = read(), w = read();
    multiset<E> st;
    while (w--)
    {
        init(n);
        int a = read(), b = read(), w = read();
        st.insert({a, b, w});
        int tmp = n, ans = 0;
        for (auto it = st.begin(), end = st.end(); it != end; ++it)
            if (!connected(it->a, it->b))
            {
                connect(it->a, it->b);
                ans += it->w;
                if (--tmp == 1)
                {
                    printf("%d\n", ans);
                    goto nxt;
                }
            }
        puts("-1");
    nxt:;
    }
}

```


---

## 作者：Mr_Li (赞：0)

看到这道题，我们首先想到的是对于每一周，求这个牧场的最小生成树。由于这张图是稀疏图，所以应用Kruskal算法，总的时间复杂度为O(w·e·loge)，而这道题的数据范围仅支持O(w·e)，所以我们要对这个算法进行优化。仔细观察发现，Kruskal算法的时间复杂度取决于排序时间，由于最快的排序算法的时间复杂度为O(n·logn)，导致时间复杂度为O(n·logn)。而对于每一次Kruskal算法，都是加一条边然后排个序，这让我们想到了插入排序。对于每一次插入，时间复杂度为O(n)。这样一来，总时间复杂度可降到O(w·e)。


---


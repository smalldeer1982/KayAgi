# 排序

## 题目描述

一个不同的值的升序排序数列指的是一个从左到右元素依次增大的序列，例如，一个有序的数列 $A,B,C,D$ 表示 $A<B,B<C,C<D$。在这道题中，我们将给你一系列形如 $A<B$ 的关系，并要求你判断是否能够根据这些关系确定这个数列的顺序。

## 说明/提示

$2 \leq n \leq 26,1 \leq m \leq 600$。

## 样例 #1

### 输入

```
4 6
A<B
A<C
B<C
C<D
B<D
A<B
```

### 输出

```
Sorted sequence determined after 4 relations: ABCD.```

## 样例 #2

### 输入

```
3 2
A<B
B<A```

### 输出

```
Inconsistency found after 2 relations.```

## 样例 #3

### 输入

```
26 1
A<Z```

### 输出

```
Sorted sequence cannot be determined.```

# 题解

## 作者：gogoduan (赞：115)

这一道题一看就知道是拓扑排序。

1.首先观察数据范围和输出，数据范围26，是真的小，就说明多搞一搞肯定也T不了。输出要求输出到第几次就行了，或者不行了，就说明我们每建一条边就需要一次拓扑排序。

2.再看这道题的三种情况。第一个是有稳定顺序，第二个是有环，第三个是无环但是也没有稳定拓扑顺序。然后我们对这三个问题进行依次解决。

第一个问题：有稳定拓扑排序说明拓扑排序的层数是n。也就是下面代码的val。一层一层下去如果是n层的话，那么这个图里面肯定包含一个n长度的链，我们只要看最大的层数是不是n就可以了，也就是代码的ans==n。

第二个问题就是成环，拓扑排序判断有没有环其实很简单，如果拓扑排序没能遍历所有的点，就说明存在一个环。也就是下面的sum==s1.size()。s1是用来存储目前元素（点）个数的。

最后一种情况最简单，如果前两种都不是，那肯定就是最后一种了！

下面上代码：
```cpp
#include <bits/stdc++.h>
#define MAXN 50
using namespace std;
int n,m;
struct Node{
    int u;
    int val;
    Node(int u=0,int val=0):u(u),val(val){}
};
vector<int> vec[MAXN];
int ru[MAXN];
int sum;
int ans;
int k;
set<int> s1;
void make(){
    queue<int> q;
    int ru1[MAXN];
    memset(ru1,0,sizeof(ru1));
    for(int i=0; i<26; i++){
        for(int j=0; j<vec[i].size(); j++){
            ru1[vec[i][j]]++;
        }
    }
    for(int i=0; i<26; i++){
        if(ru1[i]==0&&s1.count(i)){
            q.push(i);
            cout<<char(i+'A');
        }
    }
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=0; i<vec[u].size(); i++){
            int v=vec[u][i];
            ru1[v]--;
            if(ru1[v]==0){
                q.push(v);
                cout<<char(v+'A');
            }
        }
    }
}
int have;
void topo(){
    queue<Node> q;
    for(int i=0; i<26; i++){
        if(ru[i]==0&&s1.count(i)){
            q.push(Node(i,1));
            sum++;
        }
    }
    while(!q.empty()){
        int u=q.front().u;
        int val=q.front().val;
        q.pop();
        for(int i=0; i<vec[u].size(); i++){
            int v=vec[u][i];
            ru[v]--;
            if(ru[v]==0){
                sum++;
                q.push(Node(v,val+1));
                ans=max(ans,val+1);
            }
        }
    }
    if(ans==n){
        printf("Sorted sequence determined after %d relations: ",k);
        make();
        cout<<".";
        exit(0);
    }
    if(sum!=have){
        printf("Inconsistency found after %d relations.",k);
        exit(0);
    }
}
int ru2[MAXN];
int main(){
    cin>>n>>m;
    for(int i=1; i<=m; i++){
        string s;
        cin>>s;
        k=i;
        vec[s[0]-'A'].push_back(s[2]-'A');
        s1.insert(s[0]-'A');
        s1.insert(s[2]-'A');
        have=s1.size();
        ru2[s[2]-'A']++;
        sum=0;
        ans=0;
        memcpy(ru,ru2,sizeof(ru2));
        topo();
    }
    printf("Sorted sequence cannot be determined.");
    return 0;
}

```

---

## 作者：mydiplomacy (赞：63)

这一道较为简单的拓扑排序题WA了3次才AC，我的思路跟大多数题解不同，发题解记录一下QwQ

我们将每个字母转化为一个点，只需要考虑整个图拓扑排序的情况。

这道题需要判断矛盾、得不到解的情况。

首先，如果这道题目改为：给出X条限制，判断这$X$条限制"是否矛盾"、"得到结果"与"条件不足"。

bfs版的拓扑排序是：首先将$du[i]$（入度）$==0$的点加入队列，然后每次取队列首，将所有队列首连向的点的入度--，分别判断每个连向的点，若入度为$0$，则再加入队列，直到队列为空为止。参考下面的伪代码：

```cpp

for i in range[1,n] :
	i入队
    
while 队列不为空 :
	取队首u
    for u发出的边p :
    	du[p->v]--; 
        //p所指向的点的入度--，也相当于把u发出的边都删去
        if du[p->v]==0 :
        	p->v入队
            
```

首先，这样拓扑排序的结果是什么？
#### 由于符合条件的点就入队，所以最终队列里的点的顺序就是拓扑排序中的队列所存的结果。

接下来考虑如何判断是否矛盾。

当没有入度为零的点的时候，显然条件有矛盾。
同时，当出现矛盾时，有些点的入度永远不会减到零，这就意味着这些点永远入不了队。

#### 因此，当没有点入度为零，或当最终入队的点的个数<n的时候，条件有矛盾。

最后，我们考虑怎样判断条件不足。

如果最开始入度为零的点有不止一个，那么条件一定不足，因为这两个点的顺序无法确定。
同时，如果每次取队首时，有不止一个点入队了，那么条件一定不足，因为这两个点都只有队首连向的边。所以这两个点无法确定顺序。

另外就是，如果同时满足条件矛盾与条件不足，这时应该判定为条件矛盾。大家可以思考一下为什么（我就是因为这个WA的QwQ）

#### 因此，当有不止一个点入度为零，或当取同一个队首u时有不止一个v的入度变成了零，则条件不足。

这道题数据范围比较小，所以只需要遍历每个$1<=i<=m$，用$1~i$条边建边，然后跑拓扑排序即可。如果条件矛盾或者条件充足直接输出即可，如果条件不足则继续加一条边重跑toposort。

附代码

```cpp

#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

const int maxn=30,maxm=905;

struct Node
{
	int v;
	Node *next;
}*h[maxn],pool[maxm];
int tot;
int du[maxn];
int q[maxn],head,tail;
int n,m;

void addEdge(int u, int v)
{
	Node *p=&pool[++tot];
	p->v=v; p->next=h[u]; h[u]=p;
}

int toposort() //返回值为1代表成立，返回值为0代表条件不足，返回值为-1代表条件矛盾
{
	int temp=0;
	int f=0;
	for(int i=1;i<=n;i++)
	{
		if(du[i]==0)
		{
			q[tail++]=i;
			temp++;
	    } 
    }
    if(temp>1)
    	f=1;
    while(head<tail)
    {
    	temp=0;
    	int u=q[head++];
    	for(Node *p=h[u];p;p=p->next)
    	{
    		du[p->v]--;
    		if(du[p->v]==0)
    		{
    			q[tail++]=p->v;
    			temp++;
    		}
		}
		if(temp>1)
			f=1;
    }
    if(tail!=n)
    	return -1;
    else
		if(f==1)
			return 0;
	else return 1;
}	

struct Edge
{
	int u,v;
}a[maxm];

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		char aa,bb,cc;
		cin>>aa>>bb>>cc;
		a[i].u=aa-'A'+1; a[i].v=cc-'A'+1;
    }
    for(int i=1;i<=m;i++)
    {
    	addEdge(a[i].u,a[i].v);
    	head = tail = 0;
    	memset(du,0,sizeof(du));
    	for(int j=1;j<=i;j++) du[a[j].v]++;
    	int flag=toposort();
    	if(flag==1)
    	{
    		cout<<"Sorted sequence determined after "<<i<<" relations: ";
			for(int j=0;j<=n-1;j++)
			{
				cout<<(char)(q[j]+'A'-1);
		    }
		    cout<<'.'<<endl;
		    return 0;
        }
        else if(flag==0) continue;
        else
        {
        	cout<<"Inconsistency found after ";
        	cout<<i<<" relations."<<endl;
        	return 0;
        }
    }
    cout<<"Sorted sequence cannot be determined."<<endl;
	return 0;
}

```

---

## 作者：cjhspeed (赞：50)

# **最长路做法**
~~毕竟……数据量小的可怜……~~
## 通过题意易得：
### 	如果要确定一个序列，那么一定得从头到尾有个n个点构成的路径，也就是说通过一条单向道路走到底刚好能走遍全部n个点
    
#### 	那么这时候我们要通过什么来确定他的起点呢？当然有同学说可以统计入度的方法，这边呢我用了个超级原点和超级终点，香啊！
###     那么这时候我们要是能走出一个以超级原点到超级终点不带重复点的路径——就成咯！
####     但是万一有环怎么办（样例2），万一走不到怎么办（样例3）
####     这时候最长路就出来露脸了，~~所以说别把图论学死了~~**
    
### 我们通过一遍输入关系一遍统计统计超级原点到超级终点的最长路（点权都设1）：
    1. 如果能走出来长度为n+2的最长路，证明使用目前为止给的k条关系（边）就能得到所有点的完整序列
    2. 如果在统计最长路时路径长度已经超过了n+2，那么肯定是到目前给的关系（边）中一定有环路的存在（想不明白？细品！一个完整序列怎么可能有重复的点？）
    3. 如果关系输入到最后，发现根本走不到终点，那么就证明无法得出整张序列
###     这样可发现，我们不仅解决了三种情况，而且刚好符合题目的意思（如果无法排列但是给的条件中有矛盾也会当做矛盾处理）一旦找到情况（情况三要等到最后输入完关系才能证明）就能直接结束程序！
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=30;
int n,m,path[N];//记录前驱
vector<int> G[N];
bool g[N][N];//保证没有重边的干扰
  
void dfs(int v)//输出序列
{
	if(path[v]) dfs(path[v]);
	cout<<char('A'+v-1);
}
  
void bfs(int k)//正经最长路，k就是目前知道的关系
{
	queue<int> p;
	int dis[N]={0};
	dis[0]=1;
	p.push(0);
	while (!p.empty())
	{
		int u=p.front();
			p.pop();
		for(int i=0;i<G[u].size();i++)
		{
			int v=G[u][i];
			if(dis[v]<dis[u]+1)
			{
				path[n+1]=v;
				path[v]=u;
				dis[v]=dis[u]+1;
				p.push(v);
			}
			if(dis[v]>n+2)//发现矛盾直接打断程序
			{
				printf("Inconsistency found after %d relations.",k);
				exit(0);//终止一切	
			}
		}
	}
	if(k==m&&dis[n+1]!=n+2) //到最后还是不行
		cout<<"Sorted sequence cannot be determined.";
	if(dis[n+1]==n+2)//口以啦
	{
		printf("Sorted sequence determined after %d relations: ",k);
		dfs(path[n+1]);
		cout<<".";
		exit(0);
	}	
}
  
int main()
{
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=n;i++)//建立每个点和超级点的联系
	{
		G[0].push_back(i);
		G[i].push_back(n+1);
	}	
	
	for(int i=1;i<=m;i++)
	{
		char a,b,c;
		cin>>a>>b>>c;
		//getchar();
		if(!g[a-'A'+1][c-'A'+1])
		{
			G[a-'A'+1].push_back(c-'A'+1);
			g[a-'A'+1][c-'A'+1]=1;
		}
		
		bfs(i);
	}
}
```



---

## 作者：QwQ_operator (赞：41)

思路与方法的详解全部放在了代码里面



```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define N 110
using namespace std;
int a,b,n,m,s,sum,tot,head[N],in[N],inn[N],p[N];
bool v,unpd,vis[N];
queue<int>q;
char ch;
int read()//在这里我用的读入优化 
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
    return f*x;
}
struct Edge
{
    int from,to,next;
}edge[N];
int add(int x,int y)
{
    tot++;
    edge[tot].to=y;
    edge[tot].next=head[x];
    head[x]=tot;
```
}//和以前的拓扑排序过程一样，只是多加了几种情况
```cpp
int tp()
{
    unpd=false;    v=false; sum=0;//初始数值 
    for(int i=1;i<=26;i++)//开始找入读为一的点 
     {
         inn[i]=in[i];//由于我们要没输入一组后就对该序列进行判断，所以我们新设一个数组inn储存in中的各点入度的值，防止我们下一次在用时，该店的入度值已不是初始值 
         if(!inn[i]&&vis[i])//该点的入读为0并且我们输入过该值 
          {
              if(!v) v=true;//我们要判断有几个入读为0的点，由于如果有两个入读为0的点我们则无法判断他们的关系因为入读为0的点一定是小的，但这两个值得大小我们又无法判断 
              else unpd=true;//unpd用来判断无法判段的情况 
              q.push(i);
              p[++sum]=i;
           } 
      } 
    if(q.empty()) return 1;//如果q数组为空，就说明出现了环，则是存在矛盾的情况。 
    while(!q.empty())//单纯的拓扑排序，但我们要在里面多加一点东西：和前面判断入读为0的方法一样，如果删除一个点以后出现了两个入度为0的边，这样我们将无法判断这两个点的大小 
    {
        int x=q.front();v=false;q.pop();
        for(int i=head[x];i;i=edge[i].next)
        {
            inn[edge[i].to]--;
            if(!inn[edge[i].to])
            {
                q.push(edge[i].to);
                if(!v) v=true;
                else unpd=true;
                p[++sum]=edge[i].to;
            } 
        }
    }
    if(sum!=s) return 1;//说明出现了环。 
    if(unpd) return 2;
    return 0; 
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        cin>>ch,a=ch-64;if(!vis[a]) vis[a]=true,s++;//s是用来存我们输入的元素的个数，方便后面判断s值与sum值的关系（来判断是否为环） 
        cin>>ch;//这个在输入时其实我们也可以用一个数组来表示，在这里我们由于有一个<是没有用的，所以我们直接输入就好了 
        cin>>ch,b=ch-64;if(!vis[b]) vis[b]=true,s++;//vis用来表示该数有值 
        add(a,b);//在这里我们将我们输入的字符转化成了数字，方便后面进行操作 
        in[b]++;//储存入读 
        if(tp()==1) //在这里我们必须让他等于1，因为我们在tp函数中返回的是0,1,2 
        {
            printf("Inconsistency found after %d relations.",i);//存在矛盾 
            return 0;
        }
        if(sum==n&&!tp())//sum=n,说明该序列中所有的数都进行了排序，都能确定他们的位置 
        {
            printf("Sorted sequence determined after %d relations: ",i);
            for(int j=1;j<=n;j++) printf("%c",p[j]+64);//在最开始的时候我竟然让他输出p[i]+64.这告诉我们要注意我们循环使用的变量i,j 
            printf(".");
            return 0;
        }
    }
    printf("Sorted sequence cannot be determined.");//由于我们在tp函数中只有三种情况，除了前两种剩下的就是这一种了。 
    return 0;
}
```

---

## 作者：BlueDone (赞：36)

# [P1347](https://www.luogu.org/problem/P1347)

---

**本人水平不高，有错误还请指出，谢谢**

---

## 看题

### 分析样例

#### Sample #1

```cpp
//data1.in
4 6
A<B
A<C
B<C
C<D
B<D
A<B
//data1.out
Sorted sequence determined after 4 relations: ABCD.
```

通过分析样例1，我们可以发现：**我们的最终答案是由一条链组成**。

![pic_1](https://s2.ax1x.com/2019/11/24/ML7xI0.png)

#### Sample #2

```cpp
//data2.in
3 2
A<B
B<A
//data2.out
Inconsistency found after 2 relations.
```

通过分析样例2，我们得知：**环的出现意味着不合法的大小关系**。

![pic_2](https://s2.ax1x.com/2019/11/24/MLH9RU.png)

#### Sample #3

```cpp
//data3.in
26 1
A<Z
//data3.out
Sorted sequence cannot be determined.
```
通过分析样例3，我们又知道了：**只有当全图联通时，才有解**。

![pic_3](https://s2.ax1x.com/2019/11/24/MLHpGT.png)

### 看数据范围

这题很友好，数据并不算强：
$$
2 \le n \le 26
$$

虽然我们清楚地知道， ``m`` 的范围是无限的，但是那又如何？
我们一定是可以在有限的边数内求出答案的。

也就是说，事实上是这样(无重边和自环)：
$$
2^{2} \le m \le 26^{2}
$$

## 考虑细节

### 判**重边**

~~其实不用判，重边不影响答案，只是占空间~~

### 判**环**

#### 自环

这个很好办：

```cpp
int u , v ; 
u = readlint ( ) ; 
v = readlint ( ) ; 
if ( u == v )
{
    //出现自环,答案非法
    return 0 ;
}
```

#### 环

这里我使用的是 ``Tarjan`` 判强联通。
~~反正数据也不强，为什么不暴力呢。~~

```cpp
tarjan_init ( ) ; //Tarjan初始化
for ( int j = 1 ; j <= n ; j ++ ) //暴力枚举每个点
{
    if ( ! dfn[ j ] ) //如果j没有被访问过(无时间戳)
    {
        tarjan ( j ) ; //把它Tarjan掉
    }
}
if ( scccnt < n ) //强连通分量数 < 总点数
{
	//出现环,答案非法
    return 0 ;
}
```

可是为什么 ``scccnt < n`` 时就出现了环呢？

显然,如果多个点构成一个环，那么它们一定是一个强联通分量。
所以我们的强联通分量数就会比 ``n`` 少，这是一定的。

### 判**链**

稍稍分析一下就可以知道，一个链一定**存在且时存在只存在一个**``入度为零``的点和**一个**``出度为零``的点。

所以我们可以以这个为进入答案判断的标准。(因为保证无环后才会进入判链)

```cpp
//入度为零的点仅有一个 && 出度为零的点仅有一个
if ( indegcnt == n - 1 &&  outdegcnt == n - 1 ) 
{
    //进行拓扑排序
    //输出答案
    return 0 ; 
}
```

但这就够了吗？

像下面这组数据就能卡掉刚才的想法：

![pic_4](https://s2.ax1x.com/2019/11/24/ML7vaq.png)

链中(非首尾)的每一个点一定只有**唯一的前驱**和**唯一的后继**。

所以在拓扑排序中应该这么干：

```cpp
bool mrk = false ; //标记型变量
for ( int i = list [ u ] ; i ; i = e [ i ].last ) //枚举每一条边
{
    //改点可到达的点入度自减
    //如果可达的点入度变为零，进入分支语句
    if ( ! ( -- indeg [ e [ i ].to ] ) )
    {
        if ( mrk ) //如果标记过，那么改点有两个后继
        {
            return false ; //非链
        }
        que [ ++ quehead ] = e [ i ].to ; //否则入队，等待下一次操作
        mrk = true ; //打上标记
    }
}
```

### 判条件不够

这就不难了，如果所有边都加进来了依然没有**无解**或**答案**，那自然就是条件不够。

所以：

```cpp
//一系列操作
//如果都没有使程序退出
//那么一定是条件不够

printf ( "Sorted sequence cannot be determined.\n" ) ; //输出条件不够

return 0 ; 
```

## [AC代码](https://www.luogu.org/record/27711595)

```cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <cstring>
using namespace std ; 

typedef long long lint ; 
typedef long double ntrl ; 

#define MAXN 30

inline lint readlint ( )
{
	char tmp = getchar ( ) ; 
	lint val = 0 , sign = 1 ; 
	while ( tmp < '0' || tmp > '9' ) { if ( tmp == '-' ) sign = - sign ; tmp = getchar ( ) ; }
	while ( '0' <= tmp && tmp <= '9' ) { val = (val << 1 ) + ( val << 3 ) + tmp - 48 ; tmp = getchar ( ) ; }
	return val * sign ; 
}

///adjacency list///
struct node
{
	int last ; 
	int to ; 
} e [ MAXN * MAXN ] ;
int list [ MAXN ] , edgecnt ;
inline void addedge ( int u , int v )
{
	e [ ++ edgecnt ].to = v ; 
	e [ edgecnt ].last = list [ u ] ; 
	list [ u ] = edgecnt ; 
}
//////

int n , m ; 

///topological sorting///
int indeg [ MAXN ] , outdeg [ MAXN ] ; 
int indegcnt , outdegcnt ; 
int topo [ MAXN ] , topotop ; 
int que [ MAXN ] , quehead , quetail ; 
inline bool toposort ( ) 
{
	quehead = quetail = topotop = 0 ; 
	memset ( topo , 0 , sizeof ( topo ) ) ;
	memset ( que , 0 , sizeof ( que ) ) ;
	for ( int i = 1 ; i <= n ; i ++ )
	{
		if ( ! indeg [ i ] )
		{
			que [ ++ quehead ] = i ; 
		}
	}
	int u ; 
	while ( quehead != quetail )
	{
		u = que [ ++ quetail ] ; 
		topo [ ++ topotop ] = u ; 
		bool mrk = false ; 
		for ( int i = list [ u ] ; i ; i = e [ i ].last )
		{
			if ( ! ( -- indeg [ e [ i ].to ] ) )
			{
				if ( mrk )
				{
					return false ; 
				}
				que [ ++ quehead ] = e [ i ].to ; 
				mrk = true ; 
			}
		}
	}
	if ( topotop == n )
	{
		return true ; 
	}
	else 
	{
		return false ; 
	}
}
//////

///tarjan///
int stck[ MAXN ] , stcktop ; 
int dfn[ MAXN ] , low[ MAXN ] , dfncnt ; 
int scc[ MAXN ] , sccsize[ MAXN ] , scccnt ; 
inline void tarjan_init ( ) 
{
	memset ( stck , 0 , sizeof ( stck ) ) ;
	memset ( dfn , 0 , sizeof ( dfn ) ) ;
	memset ( low , 0 , sizeof ( low ) ) ;
	memset ( scc , 0 , sizeof ( scc ) ) ;
	memset ( sccsize , 0 , sizeof ( sccsize ) ) ;
	stcktop = dfncnt = scccnt = 0 ; 
}
inline void tarjan ( int u )
{
	low[ u ] = dfn[ u ] = ++ dfncnt ; 
	stck[ ++ stcktop ] = u ; 
	
	for ( int i = list[u] ; i ; i = e[ i ].last )
	{
		const int v = e[ i ].to ; 
		if ( ! dfn[ v ] )
		{
			tarjan( v ) ; 
			low[ u ] = min( low[ u ] , low[ v ] ) ; 
		}
		else if ( ! scc[ v ] )
		{
			low[ u ] = min( low[ u ] , dfn[ v ] ) ; 
		}
	}
	
	if ( dfn[ u ] == low[ u ] )
	{
		++ scccnt ; 
		do 
		{
			scc[ stck[ stcktop ] ] = scccnt ; 
			sccsize[ scccnt ] ++ ; 
		}
		while ( stck[ stcktop -- ] != u ) ; 
	}
}
//////

int main ( ) 
{
	n = readlint ( ) ; 
	m = readlint ( ) ; 
	indegcnt = outdegcnt = 0 ; 
	{
		string got ; 
		for ( int i = 1 ; i<= m ; i ++ )
		{
			cin >> got ; 
			addedge ( got [ 0 ] - 64  , got [ 2 ] - 64 ) ; 
			if ( got [ 0 ]  == got [ 2 ]  )
			{
				printf ( ''Inconsistency found after %d relations.\n'' , i ) ; 
				return 0 ; 
			}
			if ( ! indeg [ got [ 2 ] - 64 ] )
			{
				indegcnt ++ ;
			}
			indeg [ got [ 2 ] - 64 ] ++ ; 
			if ( ! outdeg [ got [ 0 ] - 64 ] )
			{
				outdegcnt ++ ;
			}
			outdeg [ got [ 0 ] - 64 ] ++ ; 

			tarjan_init ( ) ;
			for ( int j = 1 ; j <= n ; j ++ )
			{
				if ( ! dfn[ j ] )
				{
					tarjan ( j ) ; 
				}
			}
			if ( scccnt < n )
			{
				printf ( ''lnconsistency found after %d relations.\n'' , i ) ; 
				return 0 ;
			}
			else if ( indegcnt == n - 1 &&  outdegcnt == n - 1 )
			{
				if ( toposort ( ) )
				{
					printf ( ''Sorted sequence determined after %d relations: '' ,  i ) ; 
					for(int i = 1 ; i <= n ; i ++ )
					{
						printf ( ''%c'' , topo [ i ] + 64 ) ; 
					}
					printf ( ''.\n'' ) ; 
					return 0 ; 
				}
			}
		}
	}
	
	printf ( ''Sorted sequence cannot be determined.\n'' ) ;

	return 0 ; 
}
```



---

## 作者：ZZRZZ (赞：34)

# 这是拓扑排序模板题~
     是道好题，考察对拓扑排序(topological sorting)的理解。
   因为题目问的是第几个关系式后得出结果，所以考虑对每次输入关系式后的状态进行拓扑排序：
	
    拓扑排序思想：
      1.建立栈，将入度为0的点入栈。
      2.将栈首能到达的点的入度减一。
      3.当栈不空时不断退栈并重复步骤一
   其中，注意定义vis数组标记进过栈的点，并且千万注意其在代码中标记的位置！（~~我在样例三中因为只在退栈时标记而在栈中推入了无数没用的点，卡爆~~）
   
   从中，我们能“见缝插针”的得到正解：
   
      1.记录**出栈**个数sz，一次拓扑排序中sz小于0，说明一些
        点构成了环，表示存在矛盾，输出后直接结束程序
      2.检查每次出栈前栈中元素个数，若大于1，说明它们间关系
        未定
      3.若关系确定，记录一下就好了，不能结束程序，还有出现矛
        盾的可能
最后奉上AC代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 30;

int n, m;
vector<int> e[maxn];
int degree[maxn];
int a[maxn];
stack<int> s;
bool vis[maxn];
int mrk;

bool topo(int r) {
	int sz = 0;
	bool finished = true;
	int t[maxn];
	for(int i = 0; i < n; i++) {
		t[i] = degree[i];
		if(!degree[i]) s.push(i), vis[i] = true;
	}
	while(!s.empty()) {
		if(s.size() > 1) finished = false;
		int k = s.top();
		a[sz++] = k; 
		s.pop();
		for(int i = 0; i < e[k].size(); i++) t[e[k][i]]--;
		for(int i = 0; i < n; i++) if(!t[i] && !vis[i]) s.push(i), vis[i] = true;;
	}
	if(sz < n) return false;
	if(finished && !mrk) mrk = r;
	return true;
}

int main() {
	cin>>n>>m;
	for(int i = 1; i <= m; i++) {
		char c[3];
		scanf("%s", c);
		int x = c[0] - 'A', y = c[2] - 'A';
		e[x].push_back(y);
		degree[y]++;
		if(!topo(i)) {
			cout<<"Inconsistency found after "<<i<<" relations.";
			return 0;
		}
		memset(vis, false, sizeof(vis));
	}
	if(mrk) {
		cout<<"Sorted sequence determined after "<<mrk<<" relations: ";
		for(int i = 0; i < n; i++) cout<<char(a[i] + 'A');
		cout<<".";
	}
	else cout<<"Sorted sequence cannot be determined.";
	return 0;
}
```
 PS：~~现在已考了CSP DAY1了才做我的第一道拓扑排序的题~~qwq
 
 这是本蒟蒻的第一篇题解，~~求管理员放过~~~qwq

---

## 作者：Ellen7ions (赞：18)

#第一次写题解还有点小激动 (✿◕‿◕✿)


这道题还是挺坑的，如果你第九个点没过要么是没输出 --->‘.’

~~要么蠢得连顺序都没输出来~~


好了，说题解。我的思路是先用Floyed传递闭包，我用map[i][j] = -1 表示 i<j 用1 表示 > ,若没有关系即0。然后判断于某一个元素 i 和其他元素的关系是否都确定，如果都确定，则 i 的排在第几位是确定了的。那么他排在第几位呢？如果他和其他元素关系有多少个是-1就说明i比其他元素都小，排名就是 （个数+1）。


还有一个比较坑的是数据里第一个点 有相同的情况，所以才输出Inconsistency found = =。


AC代码，蒟蒻写的有些臃肿 = =。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m;
int map[128][128];
void Floyed(){
    for(int k=1;k<=26;k++)
        for(int i=1;i<=26;i++)
            for(int j=1;j<=26;j++)
                if(map[i][k]==1 && map[k][j]==1)
                        map[i][j]=1,map[j][i]=-1;
                    else if(map[i][k]==-1 && map[k][j]==-1)
                        map[i][j]=-1,map[j][i]=1;
}
char ANS[30];
int ans = 0;
bool check(){
    ans=0;
    int s ,fu;
    for(int i=1;i<=26;i++){
        s =0,fu=0;
        for(int j=1;j<=26;j++){
            if(i!=j&&(map[i][j]==1||map[j][i]==1||map[i][j]==-1||map[j][i]==-1)){
                s++;
                if(map[i][j]==-1)
                    fu++;    
            }    
        }
        if(s==n-1){
            ans++;
            ANS[fu+1]=i+'A'-1;
        }
    }
    return ans==n? 1 : 0 ;
}
int main(){
    char input[3],rel[5];
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++){
            scanf("%s",rel);
            int a = rel[0]-'A'+1;
            int b = rel[2]-'A'+1;
            
            if(rel[0]==rel[2]){
                printf("Inconsistency found after %d relations.\n",i);
                return 0 ; 
            }
            if(rel[1]=='>'){
                if(map[a][b]==-1||map[b][a]==1){
                    printf("Inconsistency found after %d relations.\n",i);
                    return 0 ;
                }
                else
                    map[a][b]=1,map[b][a]=-1;
            }else{
                if(map[b][a]==-1||map[a][b]==1){
                    printf("Inconsistency found after %d relations.\n",i);
                    return 0;    
                }
                else
                    map[b][a]=1,map[a][b]=-1;
            }
            Floyed();
            if(check()){
                printf("Sorted sequence determined after %d relations: ",i);
                for(int i=n;i>=1;i--)
                    cout<<ANS[i];
                printf(".");
                return 0;
            }    
        }
        printf("Sorted sequence cannot be determined.\n");
    return 0;
}
```

---

## 作者：⚡LZSY01_XZY⚡ (赞：11)

# 这题在poj有一模一样的题目。
----
## 题目链接

- POJ：[Sorting It All Out](http://poj.org/problem?id=1094)
- LUOGU：[排序](https://www.luogu.org/problemnew/show/P1347)

----
言归正传，题目描述很清楚，求已知关系是是否能确定这个序列。由于这道题目需要我们输出第几次输入后就能确定序列，所以每输入一个数都要进行**拓扑排序**。
#### 题目有很多坑点。
- ABCD前有空格。
- 不用管输入输出样例中的1.2.3.，这是出题人蒙你的。
- 优先判断数据冲突。
- 即使已经得出答案，也要输入完**巨坑**。

#### 我的做法：
- bfs同时记录拓扑顺序。
- 以out变量记录状态。

### code
```cpp
//坑点注释在代码里面
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int MAXN=2500;
int n,m,cas,id;

struct edge
{
    int v,nx;
}set[MAXN];
int head[30],d[30],ok[30],write[30];		//write数组记录拓扑顺序。
queue<int> Q;

void Addedge(int u,int v)
{
    id++;set[id].v=v;set[id].nx=head[u];
    head[u]=id;
}

int bfs()
{
    cas=0;
    while(!Q.empty())Q.pop();
    int out=1,t,u;t=0;			//已out的最终结果作为bfs的返回值。
    for(int i=1;i<=n;i++)
        if(!ok[i])
        {
            t++;Q.push(i);
        }
    if(t>1)out=0;
    while(!Q.empty())
    {
        u=Q.front();Q.pop();t=0;write[++cas]=u;
        for(int k=head[u];k>0;k=set[k].nx)
        {
            ok[set[k].v]--;
            if(!ok[set[k].v])
            {
                t++;Q.push(set[k].v);
            }
        }
        if(t>1)out=0;
    }
    for(int i=1;i<=n;i++)if(ok[i]>0){out=-1;break;}
    return out;
}					//拓扑排序

char print()
{
    for(int i=1;i<=cas;i++)printf("%c",(char)(write[i]+64));
    return '.';    
}						//魔性处理

int main()
{
    while(~scanf("%d%d",&n,&m))			//有多组数据
    {
        memset(write,0,sizeof(write));    
        memset(d,0,sizeof(d));    
        memset(head,-1,sizeof(head));
        id=0;
        int now=0,loca;
        char a,b,c;
        if(n==0 && m==0)break;
        for(int i=1;i<=m;i++)
        {
            cin>>a>>b>>c;
            if(b=='<')
            {
                Addedge(a-64,c-64);d[c-64]++;
            }
            else 
            {
                Addedge(c-64,a-64);d[a-64]++;
            }
            if(now==0)
            {
                for(int j=1;j<=n;j++)ok[j]=d[j];
                now=bfs();loca=i;
            }
        }
        if(now==0)puts("Sorted sequence cannot be determined.");
        else if(now==1)printf("Sorted sequence determined after %d relations: ",loca),printf("%c\n",print());
        else printf("Inconsistency found after %d relations.\n",loca);			//输出空格请注意。
    }
    return 0;
}
```
### 后记
这题实际上数据太水了，$n \le 26$，若数据加强的话，可以用并查集判断是否有环（有环即冲突），便减少了拓扑排序的次数。

---

## 作者：loafer、 (赞：9)

## [原题链接](https://www.luogu.com.cn/problem/P1347)

## 思路

可以将$A<B$看成$A$和$B$之间有一条权值为1有向边，那么$A-B$的值就表示为排完序后，$A$在$B$前面几位。

然后分情况，判断结果为第1,2,3种中的哪一种。

**判断结果为第1种的方法**

如果有恰好有$(n-1)*n/2$条边没有被更新，说明结果肯定为第1种。

为什么呢？

因为当能将这些变量排序时，邻接矩阵的情况一定是这个亚子的：
```cpp
   x1 x2 x3 x4 x5 ... xn
x1  0  1  2  3  4 ... n-1
x2 -1  0  1  2  3 ... n-2
x3 -1 -1  0  1  2 ... n-3
x4 -1 -1 -1  0  1 ... n-4
x5 -1 -1 -1 -1  0 ... n-5
...
xn -1 -1 -1 -1 -1 ... 0

"-1"表示A-B之间没有边，xi表示排在第i位的变量
```

所以没被更新的边的数量一定为$(n-1)*n/2$。

**判断结果为第2种的方法**

如果找到两个变量$A,B$，$A$在$B$前面，$B$也在$A$前面，那么这肯定矛盾了，所以结果肯定为第2种。

**判断结果为第3种的方法**

如果结果不为第1,2种，那么结果肯定为第3种。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int Map[30][30];
int ans[30];
int n,m,flag;
//flag=1表示结果为第1种，flag=-1表示结果为第2种，flag=0表示结果为第3种

inline void get(int &u,int &v)//得到边的信息
{
    char ch=getchar();
    while(ch>'Z'||ch<'A')
        ch=getchar();
    u=ch-'A',ch=getchar();
    while(ch>'Z'||ch<'A')
        ch=getchar();
    v=ch-'A';
}

inline void floyd(int u,int v)//将图更新
{
    for(register int i=0;i<n;i++)
        for(register int j=0;j<n;j++)
            if(Map[i][j]<Map[i][u]+1/* 1表示u,v之间有一条权值为1的单向边 */+Map[v][j])
                Map[i][j]=Map[i][u]+1+Map[v][j]; 
                //如果Map[i][j]<Map[i][u]+1+Map[v][j]，说明i-j之间还有u和v，于是更新Map[i][j]的值
    //这里不用单独更新u-v，当i==u，j==v时就已经更新了
}

inline void check(int now)//判断结果为第1,2,3种中的哪一种
{
    if(flag) return;
    //判断结果是否为第2种
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            if(Map[i][j]>0&&Map[j][i]>0) flag=-1;
            //如果j在i前面且i在j前面，那么结果为第二种
    if(flag==-1){ans[0]=now;return;}
    //判断结果是否为第1种
    if(now<n-1) return;//如果操作序列次数<n-1肯定结果不为第1种
    int tot=0,p,tf;
    //tot为有多少条边还没被更新，p为在最前面的变量，tf为当前变量是否在最前面
    for(int i=0;i<n;i++){
        tf=1;
    	for(int j=0;j<n;j++)
    	    if(Map[i][j]<0) tot++,tf=0;
    	    //如果这个变量不能到达其他所有变量，那么他就不在最前面
    	if(tf) p=i;
    }
    if(tot!=(n-1)*n/2) return;
    flag=1,ans[0]=now;
    //更新ans数组
    for(int i=0;i<n;i++)
        ans[Map[p][i]+1]=i;
}

inline void print()//输出函数
{
    if(flag){
        if(flag==1){
            printf("Sorted sequence determined after %d relations: ",ans[0]);
            for(int i=1;i<=n;i++) printf("%c",ans[i]+'A'); puts(".");
        }
        else printf("Inconsistency found after %d relations.\n",ans[0]);
    }
    else puts("Sorted sequence cannot be determined.");
}

int main()
{
    while(cin>>n>>m){
    	//初始化
        memset(Map,-10,sizeof Map);
        for(int i=0;i<n;i++) Map[i][i]=0;
        flag=0; 
        //输入
        int u,v;
        for(int i=1;i<=m;i++){
            get(u,v);
            floyd(u,v);
            if(flag) continue;
            check(i);
        }
        //输出
        print();
    }
    return 0;
}
/*
Sorted sequence determined after () relations: ().
Inconsistency found after () relations.
Sorted sequence cannot be determined.
*/
```

---

## 作者：throusea (赞：9)

题目描述：
   [排序](https://www.luogu.org/problemnew/show/P1347)
   
很明显这道题是 **拓扑排序**

拓扑排序的求法有很多种，这里我用 **dfs** 来求拓扑序。

### BUT

这道题存在几个难点：
  
 1. 根据前i个的关系即可来判断，也就是假设有输入为
     
        3 3
        A<B
        B<C
        C<A
    我们输出的结果为有拓扑序，而不是有矛盾。
    
    因为我们根据前两个关系即可得出拓扑序，这时便可以退出了。
    
    因此我们便采用边读入边查询的办法，找到即退出，有环即退出。
    
 2. 非常规求拓扑序
        
    由第三个数据可知，如果给定的关系不足，就无法求出拓扑序。那么我们应该怎么办呢？
    
    在BFS中，拓扑排序通常要从[入度](https://baike.baidu.com/item/%E5%85%A5%E5%BA%A6/6172141?fr=aladdin)为0的点开始删除边。但DFS不一样，DFS是一搜搜到底的，不到停止不罢休。或许我们不好找那个入度为0的点，但没有关系，这道题~~由于数据较水~~支持直接循环。
    
    那么DFS递归到最后的情况是：
 
    找到出度为0的点，或者说是这个点不指向其他任何一个点，便将此点加入数组; 或是发现存在有向环，则退出递归程序。
    
    附上代码：
    ```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int f[27],topu[27];
int dis[27][27];
int n,m,t,num;
bool dfs(int u){  //dfs求拓扑序
    f[u]=-1;  //访问标志
    for(int v=1;v<=n;v++)
    if(dis[u][v]){
        if(f[v]<0) return 0; //如果存在有向环，则退出。
        else if(!f[v]&&!dfs(v)) 
        return 0; //如果判断出有环或从未加入，返回0；
    }
    f[u]=1;
    topu[--t]=u;
    return 1;
}
int main(){
    int u,v;
    char ch[3];
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        memset(f,0,sizeof(f));
        scanf("%s",ch);
        u=ch[0]-64; v=ch[2]-64;  //转为数字
        if(!dis[u][v]) dis[u][v]=i;
        for(int j=1;j<=n;j++){ //一个循环，开始判断
            t=n;
            num=dfs(j);
            if(!num) {  //有环
                printf("Inconsistency found after %d relations.\n",i); 
                return 0;
            }
            if(num&&t==0){  //无环且找到全部的拓扑序
                printf("Sorted sequence determined after %d relations: ",i);
         		for(int j=0;j<n;j++)
        		printf("%c",topu[j]+64);
        		printf(".\n");
        		return 0;
            }
        }
    }
    printf("Sorted sequence cannot be determined.\n");  
    //前两种情况均没发现。
    return 0;
}
```
                                     
   这里解释一下f数组：
   
        当为0时，表示从未加入搜索； 
        当为-1时，表示访问搜索；
        当为1时，表示加入拓扑序。
    
    

---

## 作者：xeonz1 (赞：7)

这个题目，个人认为，不需要拓扑，直接dfs寻找能否在无环的前提下从单个点通过一条路径经过所有的点就可以了  
只上核心代码  
link邻接矩阵  
vis表示当前dfs搜索的路,  
返回值0是优先判断矛盾,  
而1则包括两种情况1.寻找到有效路;2.不能判断关系;  
那么在没有环的情况下，每次回溯之前都要先把vis[u]改为0，而cnt记录的经过的点，不满足条件时回溯前要去掉当前点（cnt--）  
一旦cnt==n，也就意味着大功告成了，保持cnt的值回溯，在全图无环的情况下，跳出dfs并输出结果
（其实后面都是证明，写算法的时候没考虑这些XD）
```cpp
int dfs(int u){
    cnt++;
    vis[u]=1;
    for(int i=1;i<=n;i++){
        if(link[u][i]){
            if(vis[i]||(!dfs(i))) return 0;//0 找到环
        }
    }
    vis[u]=0;
    if(cnt==n) {
    	ans[++t]=u;//记录字母顺序
        return 1;
    }//1 找到所有点 也就意味着此时所有点都在路里面
    cnt--;
    return 1;
}
```

---

## 作者：AIMIA (赞：4)

```cpp
//这个我是少什么就加什么的，说以边写边加，有点点长 
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<map>
#include<queue>
#include<vector>
 using namespace std;
 
 char kb[27]={'0','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
 //转换字母用 
 map<char,int>cp;//配合将字母转换为数字； 
 int n,m;
 int book[27]; 
 int mp[27][27];//存边 
 int disr[27];//存入度 
 int disc[27];//存出度 
 char sum[27];//存已有拓扑序列 
 void invid()
  {
  	for(int i=1;i<=26;i++)
  	   cp[kb[i]]=i;
  }
  void inpid()
 {
 	for(int i=1;i<=26;i++)
 	    mp[i][i]=1;
 }

 int tuopu(int num)
 {
        queue<int>kmp;
    	int ct;
			int ccl= 0; 
	  for(int i=1;i<=n;i++)
	  {
	  	if(disr[i]==0)
	     {
	     	kmp.push(i);
	     	if(ccl>1)//如果有多余1个点入度不为0，则不能确定顺序 ，就不再排序 
	     	return -1;
	     }	
	  }
//先找出出度为0的点，加入队列，存入sum,然后弹出,直到弹完n个点 
	  	int cpp=0;
 	  while(!kmp.empty())//其实可以更简单的 
 	  {
	     ccl=0;
 	  	ct=kmp.front();
 	  	kmp.pop();  
	     mp[ct][ct]=0;
     	sum[++cpp]=kb[ct];	  
        disr[ct]--;
 	     	for(int i=1;i<=n;i++)
 	  	        {	
 	  		        if(mp[ct][i]==1)
			             {
			        	disr[i]--;
						mp[ct][i]==0;
			            }
			            
 	  		      if(disr[i]==0)
						{
				kmp.push(i);
				ccl++;
				if(ccl>1)//如果有多余1个点入度不为0，则不能确定顺序 ,就不再排序 
				return -1;
					} 
 	        	}
 	  	
 	  }   
	    printf("Sorted sequence determined after %d relations: ",num);//输出就是了 
	    		 for(int i1=1;i1<=n;i1++)
	    	     printf("%c",sum[i1]);
	    	     printf(".\n");
   return 1;
 }
	vector<int>hh[27];
bool qb(int l1,int l2)//搜索检查l1的跟班里面是否有l2; 
	{		
		for(int i=0;i<hh[l1].size();i++)
		{
		    if(hh[l1][i]==l2)
		     {
		  	return true;
		    }
		if(qb(hh[l1][i],l2))
		return true;
		}	
		return false;
	}
	
 int main()
 {
     invid();//将所有字母代表的数字存进cp里 
     inpid();//将所有字母到她自己的边存为1 
 	 scanf("%d%d",&n,&m);
	       
	    	memset(book,0,sizeof(book));
	    	memset(mp,0,sizeof(mp));
			//初始化	    
	    	char a,s,b;
	    	
	    	int bian=0;//边计数 
	    	int cs=0;//点计数 
	    	for(int i=1;i<=m;i++)
	    	{
	    	   cin>>a>>s>>b;
	    	   
	    	   if(a==b)//如果a=b,则直接IFA； 
	    	   {
	    	   	printf("Inconsistency found after %d relations.\n",i);
	    	   return 0;
	    	   }
	    	   
	    	   int l1=cp[a];
	    	   int l2=cp[b];//将字母代表的数转换出来 
	    	   
	    	   hh[l2].push_back(l1);//将l1放到l2的跟班里面去 
	    	   
	    	   if(qb(l1,l2))//如果l2同时是l1的跟班，则有环 
	    	   {	
				printf("Inconsistency found after %d relations.\n",i);
				return 0;
	    	   } 
	    	   
			   if(mp[l1][l2]==0)//没有存在的边 
	    	    	{
	    	    	disc[l1]++;//出度+1 
				 	disr[l2]++;	//入度+1 
				 	mp[l1][l2]=1;//标记边 
				    bian++;//计数器君+1； 
	    	    	}
	    	    	
	    	    	if(book[l1]==0)
	    	    	  cs++;//点+1 
	    	    	if(book[l2]==0)
	    	    	   cs++; //点+1 
			
		
			        int oi=0;
			        int oj=0;
	    	      for(int i1=1;i1<=n;i1++)
	    	        {
	    	       	if(disc[i1]==0)
	    	         	oi++;
	    	         	if(disr[i1]==0)
	    	         	oj++;
	    	        }//检查出度,入度, 是否都只有一个为0 
	    	        
	    	   if(cs==n&&oi==1&&bian>=n-1&&oj==1)//满足条件：只有一个点出度=0，一个点入度=0，有n个存入了，有至少n-1条边 
	    	       {  	
			        flag2=i;
	    	      int pd= tuopu(i);
			    if(pd==1)//如果拓扑成功 
	    	     return 0;
	    	       }
	    	   book[l1]=1;
			   book[l2]=1;//存入l1,l2;	
	    	   }
    //什么都没有发生 
	    	printf("Sorted sequence cannot be determined.\n");
	    return 0;
	   
 }
```

---

## 作者：ysj1173886760 (赞：3)

我想说这题难道不是二分答案么。。。

用floyd传递闭包判断，然后二分是前几组就行了。

然后列出这题的几个坑点：

1.如果你第九个点WA了请注意，relations：后面有空格。

2.如果你的第一个点WA了请注意，注意自己不能小于自己

3.如果你全WA了请注意，这题数据不是样例那样的有多组数据，只有一组的，开始我还按照样例那样读就全挖了。

然后说一下具体的思路吧：

在这个矩阵中，i->j连边就代表i<j,所以我们根据给出的关系进行连边，注意到不等式具有传递性，所以我们可以根据floyd传递闭包来传递他们之间的不等关系。

这样的话传递闭包结束后出现的三种情况对应了三种结果。

1.若存在i->j &&j->i 则为矛盾。  （->表示连边）

2.若存在i与j且j与i没有边相连，那么无法确定顺序。

3.若对于i->j和j->i有且仅有1个成立，那么可以确定顺序。

明确了传递闭包的作用后我们开始讨论二分的边界：

如果传递闭包后发现不能确定顺序，那么一定需要更多的关系来确定顺序，所以我们让lb=mid

如果发现确定了顺序或者出现矛盾，则一定存在不大于当前关系数的关系 可以确定顺序或者矛盾，我们让ub=mid。

注意到这是左开右闭的区间，所以我们初始化ub=m，lb=0,来确保全部的情况都被涵盖。

最后出现的半开半闭区间的右端点就是我们需要的答案，这时再次check一次确定是出现了矛盾还是确定了顺序。

上述思路的核心在于题中说（提示：确定n个元素的顺序后即可结束程序，可以不用考虑确定顺序之后出现矛盾的情况）

确保了单调性，才可以二分。

总的复杂度是n^3logm

说了这么多。上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;

const int maxn=30;
bool matrix1[maxn][maxn];
int n,m;
struct rela
{
	int x,y;
}a[maxn*maxn];

int floyd(int t)
{
	memset(matrix1,0,sizeof(matrix1));
	for(int i=1;i<=t;i++)matrix1[a[i].x][a[i].y]=true;
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				matrix1[i][j]|=(matrix1[i][k]&matrix1[k][j]);//传递闭包 
	bool tag=false;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
			if(matrix1[i][j]&&matrix1[j][i])return 2;		//2表示出现了矛盾 
			if(!(matrix1[i][j]||matrix1[j][i]))tag=true;	//出现了顺序不确定的情况 
		}
	for(int i=1;i<=n;i++)if(matrix1[i][i])return 2;//自己小于自己也是矛盾 
	if(!tag)return 1;//如果所有顺序皆确定，则确定顺序 
	return 3;//否则就是不确定 
}
void getrank()	//找序列 
{
	int seq[maxn];
	for(int i=1;i<=n;i++)
	{
		int sum=0;
		for(int j=1;j<=n;j++)
			if(i!=j)
				if(matrix1[i][j])sum++;//sum记录大于i的数的个数 
		seq[n-sum]=i;//放到序列中 
	}
	for(int i=1;i<=n;i++)cout<<char(seq[i]+'A'-1);
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		char s[20];
		cin>>s;
		a[i].x=s[0]-'A'+1;
		a[i].y=s[2]-'A'+1;
	}
	if(floyd(m)==3)
	{
		cout<<"Sorted sequence cannot be determined."<<endl;//一开始就要先判断一下 
		return 0;
	}
	int ub=m,lb=0;//注意边界 
	while(ub-lb>1)
	{
		int mid=(lb+ub)>>1;
		int temp=floyd(mid);
		if(temp==3)lb=mid;
		else ub=mid;
	}
	int temp=floyd(ub);
	if(temp==1)
	{
		cout<<"Sorted sequence determined after "<<ub<<" relations: ";//注意空格 
		getrank();
		cout<<".";
	}
	else cout<<"Inconsistency found after "<<ub<<" relations."<<endl;
	return 0;
}
```


---

## 作者：Polaris_Dane (赞：2)

一看基本上都知道是拓扑排序
但是千万别全部输入后在拓扑排序
每输入一条边就进行一次dfs拓扑排序
如果全部点进入序列则输出
若有环，则有矛盾
如果不是以上两种情况，输出无法判断即可


------------


------------
~~（被坑了好久的字符串，本人字符串不好）~~

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<stack> 
#include<queue>
#define M 1010000
using namespace std;
queue <int> q;
int n,m;
struct edge{
    int next;
    int to;
}e[M];
int cnt,head[M],tp[M],po,c[M],wrong;
void add(int f,int t)
{
    e[++cnt].next=head[f];
    e[cnt].to=t;
    head[f]=cnt;
}
int dfs(int x)
{
    int flag=0;
    c[x]=true;
    for (int ii=head[x];ii!=0;ii=e[ii].next)
    {
        if (c[e[ii].to])
        {
            return 1;
        }
        flag=max(flag,dfs(e[ii].to));
    }
    c[x]=false;
    for (int pp=1;pp<=po;pp++)
    {
        if (tp[pp]==x)
        {
            return flag;
        }
    }
    tp[++po]=x;
    return flag;
}
int main()
{
    int ch=0;
    scanf("%d %d",&n,&m);
    for (int i=1;i<=m;i++)
    {
        char u,v;
        scanf("\n");
        scanf("%c<%c",&u,&v);
        add(int(u-'A'+1),int(v-'A'+1));
        po=0;
        memset(c,0,sizeof(c));
        memset(tp,0,sizeof(tp));
        ch=0;
        int num=0;
        for (int p=1;p<=n;p++)
        {
			if (!c[p])
			{
				ch=max(dfs(p),ch);
				num++;
			}
			if (ch==1)
       	 	{
        		wrong=i;
         	   	break;
    	    } 
			if (po==n&&num==1)
      	  	{
        	    printf("Sorted sequence determined after %d relations: ",i);
         	   	for (int j=n;j>=1;j--)
         	   	{
        	    	printf("%c",char(tp[j]+64));
        	    }
       	    	printf(".\n");
        	    ch=-1;
        	    break;
      	 	}
      	 	po=0;
		}
        if (ch==1)
        {
            wrong=i;
            break;
        } 
        if (ch==-1)
        {
        	break;
		}
    }
    if (ch==1)
    {
        printf("Inconsistency found after %d relations.",wrong);
    }
    if (ch!=-1&&ch!=1)
    {
        printf("Sorted sequence cannot be determined.");
    }
    return 0;
}



```


---

## 作者：zhouzihan_2004 (赞：2)

本题是拓扑排序的一个变形，对于拓扑排序熟的人应该知道，关键是要判断有没有环和顺序是否可以定下来

还有一点，在输出的时候要特别注意格式，不要直接copy题目，要加一些改动，注意句号，本人就是因为没有注意句号wa了第九个点，改完以后就ac了

代码如下：

```cpp
    #include<iostream>
    #include<cstdio>
    #include<queue>
    #include<string.h>
    using namespace std;
    int n,m,h[27],indegree[27],gs,check,pd,Ans;
    string in,ans;
    struct EDGE
    {
        int next,target;
    }edge[1001];
    void Topsort()
    {
        pd=0;
        gs=0;
        queue<int>q;
        for(int i=1;i<=n;i++)
          if(indegree[i]==0)
          {
                gs++;
                if(gs>=2) pd=1; //如果同一时间有两个及以上入度为0（它们可以以任意顺序摆放）的字母，说明无法确定顺序 
                q.push(i);
          }
        while(!q.empty()) //拓扑主体 
        {
            gs=0;
            int u=q.front();
            q.pop();
            ans+=char(u+'A'-1);
            for(int i=h[u];i!=-1;i=edge[i].next)
            {
                indegree[edge[i].target]--;
                Ans=max(Ans,i); 
                if(!indegree[edge[i].target])
                {
                    q.push(edge[i].target);
                    gs++;
                    if(gs>=2) pd=1;
                }
            }
        }
        if(pd) cout<<"Sorted sequence cannot be determined.";
        else cout<<"Sorted sequence determined after "<<Ans<<" relations: "<<ans<<".";
        return ;
    }
    bool Check()
    {
        int Indegree[27];
        for(int i=1;i<=n;i++)
          Indegree[i]=indegree[i];  
        queue<int>q;
        for(int i=1;i<=n;i++)
          if(Indegree[i]==0) q.push(i);
        while(!q.empty())
        {
            gs=0;
            int u=q.front();
            q.pop();
            for(int i=h[u];i!=-1;i=edge[i].next)
            {
                Indegree[edge[i].target]--;
                if(!Indegree[edge[i].target]) q.push(edge[i].target);
            }
        }
        for(int i=1;i<=n;i++) 
          if(Indegree[i]) return true; //如果还有剩余的点（入度无法减为0），就说明有环 
        return false;
    }
    int main()
    {
        memset(h,-1,sizeof(h));
        cin>>n>>m;
        for(int i=1;i<=m;i++)
        {
            cin>>in;
            int x=in[0]-'A'+1,y=in[2]-'A'+1;
            edge[i].next=h[x];
            edge[i].target=y;
            h[x]=i;
            indegree[y]++; //链式构图 
            if(Check()) //Check()判断是否有环 
            {
                cout<<"Inconsistency found after "<<i<<" relations.";
                return 0;
            }
        }
        Topsort(); //基础拓扑排序 
        return 0;
    }

```

---

## 作者：Dijkspfa (赞：2)

这个题我用了floyd+拓扑排序来写，floyd判是否冲突，拓扑排序检验是否已经确定顺序。

算是题解里这两种算法的结合版吧，不过感觉相对好想一些，代码也好写。

floyd部分很简单，每次输入之后跑一遍，看看有没有成环就可以了。

拓扑排序就是模板多加了一个特判，用栈存储新加入的点，每次弹出之前检查栈中的点个数是否大于一（大于一说明栈中的点之间顺序是不确定的），是则直接退出函数。过程中顺便记录顺序，不退出就可以直接输出答案了。

一个小坑点：一开始判冲突的时候没有考虑类似A<A的情况，结果WA第一个点，改掉之后就A了。

代码如下





```cpp
#include <queue>
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int mxn = 30;
const int mxm = 12345;
int n,m,tail,pre[mxn],ind[mxn],st[mxn],sin[mxn];
bool f[mxn][mxn];
struct edge{
    int v,nxt;
}e[mxm];
void floyd()
{
    for(int k = 1;k <= n;++k)
        for(int i = 1;i <= n;++i)
            for(int j = 1;j <= n;++j)
                f[i][j] |= f[i][k]&f[k][j];//更新各点之间的联通状况
}
void topo(int t)
{
    queue<int> q;//用队列记录答案
    tail = 0;
    for(int i = 1;i <= n;++i) if(!ind[i]) st[++tail] = i;
    for(int i = 1;i <= n;++i) sin[i] = ind[i];
    while(tail > 0)
    {
        int cnt = 0,p = st[tail--];
        q.push(p);
        for(int i = pre[p];i;i=e[i].nxt)
        {
            sin[e[i].v]--;
            if(!sin[e[i].v]) st[++tail] = e[i].v,++cnt;
            if(cnt > 1) return;//<-关于顺序不确定的判断，一次加入两个点就退出
        }
    }
    printf("Sorted sequence determined after %d relations: ",t);
    while(!q.empty()) putchar(q.front()+64),q.pop();putchar('.');
    exit(0);
}
int main()
{
    char in[5];
    scanf("%d %d",&n,&m);
    for(int i = 1;i <= m;++i)
    {
        scanf("%s",in+1);
        int u = in[1]-64,v = in[3]-64;
        if(f[v][u] || u == v){printf("Inconsistency found after %d relations.",i);return 0;}
        f[u][v] = 1,ind[v]++;
        e[i].v = v,e[i].nxt = pre[u],pre[u] = i;
        floyd();    
        topo(i);
    }
    puts("Sorted sequence cannot be determined.");
    return 0;
}
```

---

## 作者：wuzhoupei (赞：2)

这道题一开始什么思路都没有，最后还是看了标签；

然后经过大神的一句话；

判断是否会连成环；

这道题判断最好用floyd；

因为好写；

一旦出现环，自然是矛盾，输出，然后exit(0)；

如果没有环，就深搜一边；

如果可以把所以有的点都遍历到；

就直接输出成立；

否则；

如果所有的都输入完了，还是不能判断；

就输出无法判断；

还有一点就是每输入一次就判断一次，即做一遍以上步骤；

最好dfs时用vector或者链式前向星加速，不然第九个点会TLE；

以及成立的时候输出的东西后有个句点；

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define II int
#define C char
#define R register
#define IL inline
#define I 30
using namespace std;



struct node {
    II to,up;
}aa[I];

II head[I*123];

II _tot;

void add(R II x,R II y)
{
    aa[++_tot].to=y;
    aa[_tot].up=head[x];
    head[x]=_tot;
}

II had[I], f[I][I], ans[I], in[I];

II n,m,now;


IL II can()
{
    for(R II i=1;i<=26;i++)
    {
        for(R II j=1;j<=26;j++)
        {
            for(R II k=1;k<=26;k++)
            {
                f[j][k]=max(f[j][k],f[j][i]&f[i][k]);
            }
        }
    }
    
    for(R II i=1;i<=26;i++) if(f[i][i]) return 0; 
    return 1;
}


IL II dfs(R II x,R II ka)
{
    ans[ka]=x;
    if(ka==n) return 1;
    for(R II i=head[x];i;i=aa[i].up)
    {
        II g=aa[i].to;
        if(!had[g]) {
            had[g]=1;
            if(dfs(g,ka+1)) return 1; 
            had[g]=0;
        }
    }
    return 0;
}


int main()
{
//    freopen("1.in","r",stdin);
    
    scanf("%d%d",&n,&m);
    for(R II i=1;i<=m;i++)
    {
        R C a,b,z;
        cin>>a>>z>>b;
        R II ka1=a-'A'+1;
        R II ka2=b-'A'+1;
        f[ka1][ka2]=1;
        add(ka1,ka2);
        in[ka2]++;
        
        if(!can()) {
            printf("Inconsistency found after %d relations.\n",i);
            exit(0);
        } else {
            for(R II j=1;j<=26;j++)
            {
                if(!in[j]) {
                    for(R II k=1;k<=26;k++) had[k]=0;
                    if(dfs(j,1)) {
                        printf("Sorted sequence determined after %d relations: ",i);
                        for(R II k=1;k<=n;k++) printf("%c",ans[k]-1+'A');
                        cout<<'.'<<endl;
                        exit(0); 
                    }
                }
            }
        }
    }
    
    printf("Sorted sequence cannot be determined.\n");
    exit(0);
}
```

---

## 作者：vagary (赞：2)

就是每加一条边之后判断是否存在环（好像没有topo的样子），存在就是第2种情况，exit(0)；如果n个字母都已经出现过的话，从入度为0的点dfs一遍看是否能跑完所有点，如果能就是第一种情况，exit(0)；如果输入结束都不是第1、2种情况，则为第三种情况。

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,in[30],out[30],tot,p[30];
vector<int>x[30];
char st[4];
bool vis[30],exist[30];
bool dfs(int v){
    vis[v]=1;
    for(int i=x[v].size()-1;i>=0;i--){
        int u=x[v][i];
        if(vis[u]){
            return 0;
        }
        if(!dfs(x[v][i]))return 0;
    }
    vis[v]=0;
    return 1;
}
void search(int v,int sum,int q){
    p[sum]=v;
    if(sum==n){
        printf("Sorted sequence determined after %d relations: ",q);
        for(int i=1;i<=n;i++){
            printf("%c",p[i]+'A'-1);
        }
        printf(".");exit(0);
    }
    for(int i=x[v].size()-1;i>=0;i--){
        search(x[v][i],sum+1,q);
    }
}
void check(int v){
    for(int i=1;i<=n;i++){
        if(exist[i]){
            memset(vis,0,sizeof(vis));
            if(!dfs(i)){
                printf("Inconsistency found after %d relations.",v);exit(0);
            }
        }
    }
    if(tot!=n)return;
    for(int i=1;i<=n;i++){
        if(!in[i]){
            search(i,1,v);break;
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int a,b,i=1;i<=m;i++){
        scanf("%s",st);
        a=st[0]-'A'+1;b=st[2]-'A'+1;
        out[a]++;in[b]++;
        if(!exist[a])tot++;
        if(!exist[b])tot++;
        exist[a]=exist[b]=1;
        x[a].push_back(b);
        check(i);
    }
    printf("Sorted sequence cannot be determined.");
    return 0;
}
```

---

## 作者：彼岸朱砂 (赞：2)

**拓扑排序：**

对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。

通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。

**偏序/全序关系：**

偏序和全序实际上是离散数学中的概念。

这里不打算说太多形式化的定义，形式化的定义教科书上或者网页就说的很详细。   还是以上面选课的例子来描述这两个概念。假设我们在学习完了算法这门课后，可以选修机器学习或者计算机图形学。

这个或者表示，学习机器学习和计算机图形学这两门课之间没有特定的先后顺序。

因此，在我们所有可以选择的课程中，任意两门课程之间的关系要么是确定的(即拥有先后关系)，要么是不确定的(即没有先后关系)，绝对不存在互相矛盾的关系(即环路)。

以上就是偏序的意义，抽象而言，有向图中两个顶点之间不存在环路，至于连通与否，是无所谓的。所以，有向无环图必然是满足偏序关系的。   理解了偏序的概念，那么全序就好办了。所谓全序，就是在偏序的基础之上，有向无环图中的任意一对顶点还需要有明确的关系(反映在图中，就是单向连通的关系，注意不能双向连通，那就成环了)。可见，全序就是偏序的一种特殊情况。

回到我们的选课例子中，如果机器学习需要在学习了计算机图形学之后才能学习(可能学的是图形学领域相关的机器学习算法……)，那么它们之间也就存在了确定的，原本的偏序关系就变成了全序关系。  

实际上，很多地方都存在偏序和全序的概念。

比如对若干互不相等的整数进行排序，最后总是能够得到唯一的排序结果(从小到大，下同)。

这个结论应该不会有人表示疑问吧，但是如果我们以偏序/全序的角度来考虑一下这个再自然不过的问题，可能就会有别的体会了。   那么如何用偏序/全序来解释排序结果的唯一性呢？

我们知道不同整数之间的大小关系是确定的，即1总是小于4的，不会有人说1大于或者等于4吧。

这就是说，这序列是满足全序关系的。而对于拥有全序关系的结构(如拥有不同整数的数组)，在其线性化(排序)之后的结果必然是唯一的。

对于排序的算法，我们评价指标之一是看该排序算法是否稳定，即值相同的元素的排序结果是否和出现的顺序一致。

比如，我们说快速排序是不稳定的，这是因为最后的快排结果中相同元素的出现顺序和排序前不一致了。

如果用偏序的概念可以这样解释这一现象：相同值的元素之间的关系是无法确定的。因此它们在最终的结果中的出现顺序可以是任意的。

而对于诸如插入排序这种稳定性排序，它们对于值相同的元素，还有一个潜在的比较方式，即比较它们的出现顺序，出现靠前的元素大于出现后出现的元素。

因此通过这一潜在的比较，将偏序关系转换为了全序关系，从而保证了结果的唯一性。   拓展到拓扑排序中，结果具有唯一性的条件也是其所有顶点之间都具有全序关系。如果没有这一层全序关系，那么拓扑排序的结果也就不是唯一的了。

在后面会谈到，如果拓扑排序的结果唯一，那么该拓扑排序的结果同时也代表了一条哈密顿路径。

简单说就是，将有向图中的顶点以线性方式进行排序。即对于任何连接自顶点u到顶点v的有向边uv，在最后的排序结果中，顶点u总是在顶点v的前面。

抽象说：如果这个概念还略显抽象的话，那么不妨考虑一个非常非常经典的例子——选课。我想任何看过数据结构相关书籍的同学都知道它吧。

假设我非常想学习一门机器学习的课程，但是在修这么课程之前，我们必须要学习一些基础课程，比如计算机科学概论，C语言程序设计，数据结构，算法等等。

那么这个制定选修课程顺序的过程，实际上就是一个拓扑排序的过程，每门课程相当于有向图中的一个顶点，而连接顶点之间的有向边就是课程学习的先后关系。

只不过这个过程不是那么复杂，从而很自然的在我们的大脑中完成了。将这个过程以算法的形式描述出来的结果，就是拓扑排序。   那么是不是所有的有向图都能够被拓扑排序呢？显然不是。继续考虑上面的例子，如果告诉你在选修计算机科学概论这门课之前需要你先学习机器学习，你是不是会被弄糊涂？

在这种情况下，就无法进行拓扑排序，因为它中间存在互相依赖的关系，从而无法确定谁先谁后。在有向图中，这种情况被描述为存在环路。

因此，一个有向图能被拓扑排序的充要条件就是它是一个有向无环图

(DAG：Directed Acyclic Graph)。



------------
简单说就是，将有向图中的顶点以线性方式进行排序。即对于任何连接自顶点u到顶点v的有向边uv，在最后的排序结果中，顶点u总是在顶点v的前面。


------------
抽象说：如果这个概念还略显抽象的话，那么不妨考虑一个非常非常经典的例子——选课。我想任何看过数据结构相关书籍的同学都知道它吧。

假设我非常想学习一门机器学习的课程，但是在修这么课程之前，我们必须要学习一些基础课程，比如计算机科学概论，C语言程序设计，数据结构，算法等等。

那么这个制定选修课程顺序的过程，实际上就是一个拓扑排序的过程，每门课程相当于有向图中的一个顶点，而连接顶点之间的有向边就是课程学习的先后关系。

只不过这个过程不是那么复杂，从而很自然的在我们的大脑中完成了。将这个过程以算法的形式描述出来的结果，就是拓扑排序。   那么是不是所有的有向图都能够被拓扑排序呢？显然不是。继续考虑上面的例子，如果告诉你在选修计算机科学概论这门课之前需要你先学习机器学习，你是不是会被弄糊涂？

在这种情况下，就无法进行拓扑排序，因为它中间存在互相依赖的关系，从而无法确定谁先谁后。在有向图中，这种情况被描述为存在环路。

因此，一个有向图能被拓扑排序的充要条件就是它是一个有向无环图
(DAG：Directed Acyclic Graph)。

------------
**预备知识**

一个较大的工程往往被划分成许多子工程，我们把这些子工程称作活动(activity)。

在整个工程中，有些子工程(活动)必须在其它有关子工程完成之后才能开始，也就是说，一个子工程的开始是以它的所有前序子工程的结束为先决条件的，但有些子工程没有先决条件，可以安排在任何时间开始。

为了形象地反映出整个工程中各个子工程(活动)之间的先后关系，可用一个有向图来表示，图中的顶点代表活动(子工程)，图中的有向边代表活动的先后关系，即有向边的起点的活动是终点活动的前序活动，只有当起点活动完成之后，其终点活动才能进行。

通常，我们把这种顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网(Activity On Vertex network)，简称AOV网。

![](https://p1.ssl.qhmsg.com/t016e0776e7ec546704.png)

例如，假定一个计算机专业的学生必须完成图3-4所列出的全部课程。

在这里，课程代表活动，学习一门课程就表示进行一项活动，学习每门课程的先决条件是学完它的全部先修课程。

如学习《数据结构》课程就必须安排在学完它的两门先修课程《离散数学》和《算法语言》之后。

学习《高等数学》课程则可以随时安排，因为它是基础课程，没有先修课。若用AOV网来表示这种课程安排的先后关系，则如图3-5所示。

图中的每个顶点代表一门课程，每条有向边代表起点对应的课程是终点对应课程的先修课。图中的每个顶点代表一从图中可以清楚地看出各课程之间的先修和后续的关系。

如课程C5的先修课为C2，后续课程为C4和C6。

一个AOV网应该是一个有向无环图，即不应该带有回路，因为若带有回路，则回路上的所有活动都无法进行。

**算法：**

该算法的实现十分直观，关键在于需要维护一个入度为0的顶点的集合：

每次从该集合中取出(没有特殊的取出规则，随机取出也行，使用队列/栈也行，下同)一个顶点，将该顶点放入保存结果的List中。

紧接着循环遍历由该顶点引出的所有边，从图中移除这条边，同时获取该边的另外一个顶点，如果该顶点的入度在减去本条边之后为0，那么也将这个顶点放到入度为0的集合中。然后继续从集合中取出一个顶点…………   当集合为空之后，检查图中是否还存在任何边，如果存在的话，说明图中至少存在一条环路。不存在的话则返回结果List，此List中的顺序就是对图进行拓扑排序的结果。

```
public class KahnTopological
{
    private List<Integer> result;   // 用来存储结果集
    private Queue<Integer> setOfZeroIndegree;  // 用来存储入度为0的顶点
    private int[] indegrees;  // 记录每个顶点当前的入度
    private int edges;
    private Digraph di;

    public KahnTopological(Digraph di)
    {
        this.di = di;
        this.edges = di.getE();
        this.indegrees = new int[di.getV()];
        this.result = new ArrayList<Integer>();
        this.setOfZeroIndegree = new LinkedList<Integer>();

        // 对入度为0的集合进行初始化
        Iterable<Integer>[] adjs = di.getAdj();
        for(int i = 0; i < adjs.length; i++)
        {
            // 对每一条边 v -> w 
            for(int w : adjs[i])
            {
                indegrees[w]++;
            }
        }

        for(int i = 0; i < indegrees.length; i++)
        {
            if(0 == indegrees[i])
            {
                setOfZeroIndegree.enqueue(i);
            }
        }
        process();
    }

    private void process()
    {
        while(!setOfZeroIndegree.isEmpty())
        {
            int v = setOfZeroIndegree.dequeue();

            // 将当前顶点添加到结果集中
            result.add(v);

            // 遍历由v引出的所有边
            for(int w : di.adj(v))
            {
                // 将该边从图中移除，通过减少边的数量来表示
                edges--;
                if(0 == --indegrees[w])   // 如果入度为0，那么加入入度为0的集合
                {
                    setOfZeroIndegree.enqueue(w);
                }
            }
        }
        // 如果此时图中还存在边，那么说明图中含有环路
        if(0 != edges)
        {
            throw new IllegalArgumentException("Has Cycle !");
        }
    }

    public Iterable<Integer> getResult()
    {
        return result;
    }
}
```

![](http://my.csdn.net/uploads/201207/04/1341373589_4609.png)

排序结果：

2->8->0->3->7->1->5->6->9->4->11->10->12

**伪代码：**

```
#include <bits/stdc++.h>
using namespace std;

int tp[10000],r[],c[];//r表示入度，c表示出度，tp表示最后生成的拓扑序
vector<int> G[];
void tuopu()
{
    int cnt=0;
    queue<int> q;
    for(int i=1;i<=n;i++)
    {
        if(r[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int now=q.front();
        q.pop();
        tp[cnt++]=now;
        for(int i=0;i<G[now].size();i++)
        {
            r[G[now][i]]--;
            if(r[G[now][i]]==0) q.push(G[now][i]);
        }
    }
}

int main()
{
    return 0;
}
```

[P1347 排序](https://www.luogu.org/problemnew/show/P1347)

```
/////////////代码来自 @李科良
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
int n,m,num,sum,r[30],tmp[30];
char ans[30];
bool flag[30],f,l;   //  记录那些点出现过 
queue<int>q; 
vector<int>v[30];   // 下标为元素 值为能到的元素 
void topu(int x)
{
    for(int i=1;i<=n;i++) tmp[i]=r[i];
    while(!q.empty()) q.pop();
    for(int i=1;i<=n;i++) if(r[i]==0) q.push(i),ans[++num]=(char)(i+64);   // 找到一个起点 即最小的元素
    if(num>1) return;
    while(!q.empty())
    {
        int now=q.front();   // 此时的最小元素 
        q.pop();
        for(int i=0;i<v[now].size();i++)
        {
            tmp[v[now][i]]--;   // 这个元素能到的元素的入度减小   
            if(tmp[v[now][i]]==0) q.push(v[now][i]),ans[++num]=(char)(v[now][i]+64),sum++;
            if(sum>1) {sum=0;return;}
            if(num==n)
            {
                cout<<"Sorted sequence determined after "<<x<<" relations: ";
                for(int k=1;k<=num;k++) cout<<ans[k];
                cout<<".";
                l=true;
                return;             
            }
        }
        sum=0;
    } 
}
void dfs(int x,int i)    //  x是当前的起点 i是第几步询问 
{
    if(flag[x]) {cout<<"Inconsistency found after "<<i<<" relations.";f=true;return;}
    flag[x]=true;
    for(int j=0;j<v[x].size();j++) 
    {
        dfs(v[x][j],i); 
        if(f) return;
    }
    flag[x]=false;
}
int main()
{
    cin>>n>>m;      //  n个元素  m个关系 
    char a,b,c;     //  将A B C ... 依次转换为 1 2 3 ... 
    for(int i=1;i<=m;i++)
    {
        cin>>a>>b>>c;  // 表示 a<c 即a可以到c 
        r[c-64]++;     // 入度增加 表示下标元素的入度 
        v[a-64].push_back(c-64);   // 装下标可以到的元素
        for(int j=1;j<=n;j++)
        {
            dfs(j,i);
            if(f) return 0;
        }
        topu(i);
        num=0;
        if(l) return 0;
    }
    if(!l) cout<<"Sorted sequence cannot be determined.";
    return 0;
}
```
部分摘自 dm_vincent 的CSDN 博客
来自码云


---

## 作者：HoshiuZ (赞：1)

Floyd传递闭包，map映射，拓扑排序。

但本题需要开两个邻接矩阵，一个用于传递闭包，一个用于拓扑排序（反正我是如此）。

但有几个需要注意的点。
- 判断是否矛盾用的是传递闭包的邻接矩阵。
- 输出拓扑序，冒号后有个空格，贼坑。（然而本题貌似只有一个点输出拓扑序的）。

g为传递闭包的邻接矩阵。tg为拓扑的邻接矩阵。s为与这个点有关系的点有多少个，当其为n-1时，说明这个点的位置可以确定。inder为点的入度，用于拓扑序。

## 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

map <char,int> vh;
map <int,char> fvh;
int n,m,g[30][30],s[30],ans=0,inder[30],tg[30][30];
bool flag=true;
char ansx[30];

void Floyd() {
	for(int k=1;k<=n;k++) {
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=n;j++) {
				if(!g[i][j]&&g[i][k]&&g[k][j]) {
					g[i][j]=1;
					s[i]++;
					s[j]++;
				}
			}
		}
	}
}

void top() {
	int sum=0;
	while(sum<n) {
		for(int i=1;i<=n;i++) {
			if(!inder[i]) {
				ansx[++sum]=fvh[i];
				inder[i]--;
			}
		}
		for(int i=1;i<=n;i++) {
			if(tg[vh[ansx[sum]]][i]) inder[i]--;
		}
	}
}

int main() {
	cin>>n>>m;
	int js=0;
	for(int i=1;i<=m;i++) {
		char a,b,c;
		cin>>a>>b>>c;
		if(!vh[a]) vh[a]=++js,fvh[js]=a;
		if(!vh[c]) vh[c]=++js,fvh[js]=c;
		inder[vh[c]]++;
		if(g[vh[c]][vh[a]]||a==c) {
			flag=false;
			ans=i;
			break;
		}
		g[vh[a]][vh[c]]=1;
		tg[vh[a]][vh[c]]=1;
		s[vh[a]]++,s[vh[c]]++;
		Floyd();
		int sum=0;
		for(int j=1;j<=n;j++) if(s[j]==n-1) sum++;
		if(sum==n) {
			ans=i;
			break;
		}
	}
	
	if(!flag) cout<<"Inconsistency found after "<<ans<<" relations."<<endl;
	else if(!ans) cout<<"Sorted sequence cannot be determined."<<endl;
	else {
		top();
		cout<<"Sorted sequence determined after "<<ans<<" relations: ";
		for(int i=1;i<=n;i++) cout<<ansx[i];
		cout<<"."<<endl;
	}
	
	return 0;
}
		
```


---

## 作者：xixiup (赞：0)

这道题其实暴力都可以过的,打一个for循环从1到m每次找前t条边，如果排序成
功则输出排序结果，出现环则输出错误，否则再添加一条边，直到m条边已经填完了仍然没有结果就输出无解。

上代码（暴力每个点都3ms过的）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt;
int fr[10000],to[10000];
//fr&to:存边
int rd[500];
//入度
int sum,p[500];
//p:判断是否已删除
struct node{//sx:每个点排第几个，bh:它是哪一个字母
	int sx,bh;
}po[500];
string jm;
bool cmp(node u,node v){//排序
	return u.sx<v.sx;
}
int main(){
	cin>>n>>m;
	getline(cin,jm);
	for(int i=1;i<=m;i++){
		getline(cin,jm);
		int x=jm[0]-'A'+1;
		int y=jm[2]-'A'+1;
		fr[i]=x;
		to[i]=y;
	}//输入
	for(int t=1;t<=m;t++){//对前t条边做拓扑排序
		memset(p,0,sizeof(p));
		memset(rd,0,sizeof(rd));
		for(int i=1;i<=n;i++){
			po[i].sx=100000000;
			po[i].bh=i;
		}
		for(int i=1;i<=t;i++){
			rd[to[i]]++;
		}
		sum=0;
		int ppd=1;
		for(int i=1;i<=n;i++){
			int x,y;
			y=0;
			for(int j=1;j<=n;j++){
				if(p[j]==0&&rd[j]==0){
					x=j;
					y++;
				}
			}
			if(y>1){//拓扑排序结果不唯一
				ppd=0;
			}
			if(y==0){//出现环，直接输出错误
				printf("Inconsistency found after %d relations.",t);
				return 0;
			}
            p[x]=1;
			sum++;
			po[x].sx=sum;
			for(int j=1;j<=t;j++){
				if(fr[j]==x){
					rd[to[j]]--;
				}
			}
		}
		for(int i=1;i<=n;i++){//判断每个节点是否都访问到了
			if(po[i].sx==100000000){
				ppd=0;
				break;
			}
		}
		if(ppd==1){
			sort(po+1,po+1+n,cmp);//sort大法好
			printf("Sorted sequence determined after %d relations: ",t);
			for(int i=1;i<=n;i++){
				printf("%c",po[i].bh+'A'-1);
			}
			printf(".");
			return 0;//有结果
		}
	}
	cout<<"Sorted sequence cannot be determined.";
	return 0;//找不到结果
}
```


---

## 作者：Phykyer (赞：0)

题意：给出一些点和形如x < y的约束条件，求点的唯一排列。 


显然应该是用拓扑排序解决的一道问题，大体思路并不难想，只要对于每个约束条件从x向y建一条有向边，每加入一条边跑一次拓扑即可。  


但是本题最大的难点在于其他细节的处理（个人认为），可以看到题目要求进行三种不同情况的判断，分别是：①n个点有唯一序列；②有一些点的约束条件冲突；③给出所有条件后仍无法确定唯一序列

下面来一条条解决：  

对于①：只要满足有唯一的拓扑序列即可，所以只要满足以下两个条件：1、能拓扑到所有点；2、任何时刻队列中都没有两个及以上的点。 非常好解决，加一个特判即可  

对于②：约束条件冲突其实就是在图上出现了环（一时想不明白的话自己动手画个图就明白了），对于这种情况本人代码是用tarjan计算强连通分量个数（~~毕竟数据这么小可以随便搞~~），有显然的结论就是若强连通分量个数小于点数的话就代表出现了环  

对于③：所有边输入完之后均不满足以上两点就是无法确定的情况  

最后输出时注意一些细节（~~本人也因此被卡了几次~~）  

详细的部分在代码中还会有注释，以下为代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;

const int N = 101, M = 1010;

int n, m, tot;
int head[N], ver[M], Next[M], deg[N], dg[N], cnt;
//deg, dg为存入度的数组 
char a[N];
bool p[N], pd, vis[N];

int dfn[N], low[N], stack[N], id, top;//tarjan数组 
int scc;//强连通分量个数 

inline void add(int x, int y) {
	ver[++cnt] = y; Next[cnt] = head[x]; head[x] = cnt;
	deg[y]++;
}

inline int topsort() {
	queue <int> q;
	tot = 0;//记得清零 
	for (int i = 1; i <= n; i++) dg[i] = deg[i];//因为要多次拓扑所以另开一个数组用于拓扑
	for (int i = 1; i <= n; i++) if (dg[i] == 0 && p[i]) q.push(i);//只有已经有边连接的点才能入队
	if(q.size() > 1) return 2;
    	//如果队列内元素超过一个就无法确定唯一序列,直接返回,以下同理 
	while (q.size()) {
		int x = q.front(); q.pop();
		a[++tot] = 'A' + x - 1;
		for (int i = head[x]; i; i = Next[i]) {
			int y = ver[i];
			if (--dg[y] == 0) {
				q.push(y);
				if(q.size() > 1) return 2;
			}
		}
	}
	if (tot == n) return 1;
   	//所有点都进入了拓扑序列
	return 0;
}

inline void clear() {
	scc = 0; id = 0; top = 0;
	memset(dfn, 0, sizeof(dfn));
	memset(low, 0, sizeof(low));
}

inline void tarjan(int x) {
	dfn[x] = low[x] = ++id; vis[x] = 1; stack[++top] = x;
	for (int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x], low[y]);
		}
		else if (vis[y]) low[x] = min(low[x], dfn[y]);
	}
	if (dfn[x] == low[x]) {
		int now; scc++;
        	//这里的tarjan只需记录强连通分量个数即可
		do {
			now = stack[top--];
			vis[now] = 0;
		} while (now != x);
	}
}

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x * f;
}

int main() {
	n = read(); m = read();
	char in[4];
	for (int i = 1; i <= m; i++) {
		scanf("%s", in);
		int x = in[0] - 'A' + 1, y = in[2] - 'A' + 1;
		if (x == y) {//如果x==y直接特判输出不符合因为一个数不可能小于它本身 
			cout << "Inconsistency found after " << i << " relations." << endl;
			return 0;
		}
		add(x, y);
		p[x] = 1; p[y] = 1;//记录一下已经出现的点
		clear();//清空tarjan的数组
		for (int j = 1; j <= n; j++) {
			if (!dfn[j]) tarjan(j);//跑tarjan
		}
		if (scc < n) {//强连通分量数量小于n则代表出现了环
			cout << "Inconsistency found after " << i << " relations." << endl;
			return 0;
		}
		int ret = topsort();
		if (ret == 1) {
			cout << "Sorted sequence determined after " << i << " relations: ";
			for (int j = 1; j <= tot; j++) cout << a[j];
			puts(".");//结尾记得输出这个点，容易遗漏
			return 0;
		}
		else if (i < m) continue;//如果数据还没输入完就继续
		cout << "Sorted sequence cannot be determined." << endl;
		//数据输完了后扔不能将所有点拓扑到就输出无法判断
		return 0;
	}
	return 0;
}
```
码风可能比较奇怪还请见谅

---

## 作者：wmjlzw1314 (赞：0)

```cpp
//每输入一条边进行一定判断，首先判断是否存在环，然后判断是否所有的结点都已出现，如果结点都出现，并且无环，那么找到入度为0的结点开始深搜，如果能遍历输出拓扑排序后的结果。如果不能遍历完，说明所有的结点并没有全部连通。继续下一步。
//老子以后再也不用bool啦！！！ 
#include<bits/stdc++.h>
using namespace std;
vector<int>G[30];
const int N = 30;
int n, m, t, tot = 0;
int exist[N];
string s;
int v[N];
int out[30], in[30];
int  check(int x){
	v[x] = -1;
	for(int i = 0 ; i < G[x].size() ; i++){
		int y = G[x][i];
		if(v[y] == -1){
			return 1;
		}
		if(!v[y] && check(y)){
			return 1;
		}
	}
	v[x] = 1;
	return 0; 
}
int ans[100200];
void dfs(int cur , int  x , int cnt){
	ans[cur] = x;
	if(cur == n - 1){
	
		printf("Sorted sequence determined after %d relations: ",cnt);
	   for(int i = 0; i < n ; i ++ ){
	   	cout << char (ans[i] + 'A' - 1);
	   }
	    printf(".\n");  
	   exit(0);
}
	for(int i = 0 ; i < G[x].size() ; i ++){
    	dfs(cur + 1, G[x][i] , cnt);
	}
}
void search(int i){
	for(int j = 1; j <= n; j ++){
	  if(exist[j]){
	   memset(v , 0 , sizeof(v));
       if(check(j)){
       	printf("Inconsistency found after %d relations.\n",i);
       	exit(0);
	   }
    }
  }
  if(tot == n){
  	for(int j  = 1 ; j <= n ; j ++){
  		if(!in[j]){
  		dfs(0 , j , i);
		  }
	  }
  }
}
int main () {
	cin >> n >> m;
	for(int i =  1; i <= m ; i ++){
		  cin >> s; 
	int a = s[0] - 'A' + 1;
	int b = s[2] - 'A' + 1;
	in[b]++;
	out[a]++;
	if(!exist[a])tot++;
	if(!exist[b])tot++;
	exist[a] = exist[b] = 1;
	G[a].push_back(b);
	search(i);
	}
	printf("Sorted sequence cannot be determined.\n");
}
```


---

## 作者：LuckyCloud (赞：0)

##### 顺序是否矛盾，其实就是判断是否存在环，可以利用拓扑排序，或者Floyed。这个楼下应该讲的蛮清楚了，我就不过多赘述了。
#### 关于第二个问题如何确定顺序，其实可以将所有的X<Y看成一条从X到Y或者从Y到X的有向边，并且边权为1。然后根据之前的拓扑排序或者直接枚举一遍找出没有边指向的点也就是源点，到目前为止我们可以保证图中无环（有环的情况已经被排除）接下来就可以做一遍 _单源最长路_ 。
#### 只要存在源点到某一点的距离是n-1的那么必然这一点和源点之间存在一条路径且这条路径上刚好有n个点，根据我们定义的边就相当于找出n-1个互不重复的X<Y的条件，完全满足题目要求。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int x,y,n,m,bian[30],next[2000],to[2000];
bool map[30][30],flag[30];
char s[3];
int head,tail,origin,path[30],dis[30],sum,q[10000],pre[30],len;
// 队列的一些操作
bool empty() 
{
  return sum==0;
}
void push(int x)
 {
  tail=(tail+1)%10000;
  q[tail]=x;
  sum++;
 }
int pop()
  {
   head=(head+1)%10000;
   sum--;
   return q[head];
  }
//
int main()
{
  scanf("%d%d",&n,&m);
  for (int t=1;t<=m;t++)
   {
   	scanf("%s",s);
   	x=s[0]-'A'+1;
   	y=s[2]-'A'+1;
   	flag[y]=true;//标记有边指向的点，以此找出没有边指向的点也就是源点
   	map[x][y]=true;//邻接矩阵存边方便Floyed
   	
    next[t]=bian[x];//链式前向星存边方便找最长路
   	bian[x]=t;
   	to[t]=y;
    
   	for (int k=1;k<=n;k++)//Floyed找环
   	 for (int i=1;i<=n;i++)
   	  for (int j=1;j<=n;j++)
   	   map[i][j]=map[i][j]||(map[i][k]&&map[k][j]);
	 for (int i=1;i<=n;i++)
      if (map[i][i]) {printf("Inconsistency found after %d relations.\n",t);return 0;}
      
     for (int i=1;i<=n;i++)
      if (!flag[i]) {origin=i;break;}//枚举找出源点
      
	 memset(dis,255,sizeof(dis));//一些基本的预处理操作
	 sum=1; 
	 head=-1;
	 tail=0;
	 q[0]=origin;
	 dis[origin]=0;  
	 len=0;//找出正确顺序的长度 	
	 while (!empty())
   	  {
   	  	x=pop();
   	  	if (dis[x]==n-1)//找到符合要求的路径，
        //通过pre数组开始回退找出经过的点。
   	  	 {
   	  	    path[++len]=x;	
   	  	 	for (int i=pre[x];i!=0;i=pre[i])
   	  	 	 path[++len]=i;
   	  	 	break;
   	     }
   	  	for (int i=bian[x];i!=0;i=next[i])
   	  	 	if (dis[x]+1>dis[to[i]])//找到更长的路径，更新dis数组
   	  	 	 {
   	  	 	 	dis[to[i]]=dis[x]+1;
   	  	 	 	pre[to[i]]=x;
   	  	 	 	push(to[i]);
   	  	     }
      }
      if (len==n)//当找出的正确顺序长度等于n
      {
      	printf("Sorted sequence determined after %d relations: ",t);
       for (int i=n;i>0;i--)
        printf("%c",path[i]+'A'-1);
        printf(".\n");
        return 0;
	  }
	  if (len!=n&&t==m)//没找到正确顺序，并且已经读入到最后一条边了
	   puts("Sorted sequence cannot be determined.");
   }
  return 0;
}
```

---


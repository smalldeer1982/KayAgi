# 通往奥格瑞玛的道路

## 题目背景

在艾泽拉斯大陆上有一位名叫歪嘴哦的神奇术士，他是部落的中坚力量。

有一天他醒来后发现自己居然到了联盟的主城暴风城。

在被众多联盟的士兵攻击后，他决定逃回自己的家乡奥格瑞玛。

## 题目描述

在艾泽拉斯，有 $n$ 个城市。编号为 $1,2,3,\ldots,n$。

城市之间有 $m$ 条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。

每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。

假设 $1$ 为暴风城，$n$ 为奥格瑞玛，而他的血量最多为 $b$，出发时他的血量是满的。如果他的血量降低至负数，则他就无法到达奥格瑞玛。

歪嘴哦不希望花很多钱，他想知道，在所有可以到达奥格瑞玛的道路中，对于每条道路所经过的城市收费的最大值，最小值为多少。

## 说明/提示

对于 $60\%$ 的数据，满足 $n\leq 200$，$m\leq 10^4$，$b\leq 200$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^4$，$1\leq m\leq 5\times 10^4$，$1\leq b\leq 10^9$；

对于 $100\%$ 的数据，满足 $1\leq c_i\leq 10^9$，$0\leq f_i\leq 10^9$，可能有两条边连接着相同的城市。

## 样例 #1

### 输入

```
4 4 8
8
5
6
10
2 1 2
2 4 1
1 3 4
3 4 3
```

### 输出

```
10
```

# 题解

## 作者：George1123 (赞：80)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1462 【通往奥格瑞玛的道路】](https://www.luogu.org/problem/P1462)

### 此题算法:Dijkstra与他的二分

大致思路:

>1.$ $输入$i$站收费$f[i]$，求出二分范围$l$，起点和终点的费用最大值，和$r$，所有的城市收费最大值。

>2.$ $二分。只用不高于$mid$的收费站。二分条件：最少耗血是否小于最大血量。

>3.$ $输出答案$l$。

![](https://s2.ax1x.com/2019/09/21/nx4zRK.jpg)

## 以下是代码加注释

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ong long long
const int N=10010;
const int M=100010;
const ong inf=LLONG_MAX/3;  //小心爆long long
int n,m,b,u,v;
int l,r,mid;
ong wi;  //爆int了
struct node{
	int a;
	ong dis;
};
bool operator < (node x,node y){
	return x.dis>y.dis; 
} priority_queue<node> q;
int top,g[N],f[N];
ong dis[N];
bool vis[N];
struct edge{
	int adj,nex;
	ong w;
}e[M];
void add(int x,int y,ong wor){
	e[++top]=(edge){y,g[x],wor}; 
	g[x]=top;
} void Dijkstra(int maxn){
	for(int i=1;i<=n;i++){
		dis[i]=inf;
		vis[i]=0;
	} dis[1]=0;
	while(!q.empty()) q.pop();
	q.push((node){1,dis[1]});
	while(!q.empty()){
		node now=q.top(); q.pop();
		int x=now.a;
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=g[x];i;i=e[i].nex){
			int p=e[i].adj;
			if(f[p]>maxn) continue;
			if(dis[x]+e[i].w<dis[p]){
				dis[p]=dis[x]+e[i].w;
				q.push((node){p,dis[p]});
			}
		}
	}
} int main(){
	scanf("%d%d%d",&n,&m,&b);
	for(int i=1;i<=n;i++){
		scanf("%d",f+i);
		r=max(r,f[i]);
	} l=max(f[1],f[n]);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&u,&v,&wi);
		add(u,v,wi);
		add(v,u,wi);
	} while(l<r){
		mid=(l+r)>>1;
		Dijkstra(mid);
		if(dis[n]>b)
			l=mid+1;  //怕死循环
		else r=mid;
	} Dijkstra(l);
	if(dis[n]>b) printf("AFK\n");
	else printf("%d\n",l);
	return 0;
} 
```
最后我想说:~~我太蒟了！~~

谢谢大家! !


---

## 作者：Atlicd (赞：44)

## 思路：

**二分答案和dijkstra**  

因为看到求最小值，所以想到了二分  
~~（某位高人曾言：最值都可以用二分）~~  
怎么想到dijkstra就不用说了吧 QwQ  

---
## 实现：

~~代码实现和有思路同样重要！！~~  
1.读入数据（在读入数据的时候需要初始化一下二分边界，代码中有）  
2.二分答案
3.输出
注：二分答案的判断就是一次dijkstra  
（我觉得还能简化，但是并不知道如何实现，如果有大佬知道，可以私我）  
~~就是这么简单~~  

---
## Code：
```
#include <algorithm>
#include <iostream>
#include <cstring>//memset库函数 
#include <cstdio>
#include <queue>//优先队列 
const int maxn=1e5+7,maxm=5e5+7,inf=1e9+7;
using namespace std ;
int to[maxm],nex[maxm],val[maxm];
int head[maxn],tot;
inline void add(int u,int v,int w)
{
	to[++tot]=v;
	nex[tot]=head[u];
	val[tot]=w;
	head[u]=tot;
}
//链式前向星 
int n,m,k;
int l=inf,r,flag;
//记得把l初始化为最大值inf 
int num[maxn];
int dis[maxn];//dis[i]表示到达i点的最大生命值 
priority_queue < pair < int , int > > q;//dijkstra+堆优化 
//默认的优先队列是大根堆 
inline bool judge(int x)
//不能走num[i]严格大于x的点，到终点的dis值为正数 
{
	memset(dis,-1,sizeof(dis));
	//将所有点初始化为-1，表示该点目前不能在有限的生命中跑过去 
	dis[1]=k;
	//将1号出发点的dis设置为最大生命值 
	q.push(make_pair(dis[1],1));
	while(!q.empty())
	{
		int u=q.top().second;
		int d=q.top().first;
		q.pop();//勿忘弹出 
		if(dis[u]!=d) continue;
		//如果不等，就证明该节点在这次入队之后又被更新过，弹出就好了
		//dijkstra+堆优化的小技巧 
		for(int i=head[u];i;i=nex[i])
		{
			int v=to[i];
			if(num[v]>x) continue;
			//判断该点有没有被二分的答案所限制 
			if(dis[v]<dis[u]-val[i] && dis[u]-val[i]>=0)
			//更新的是到v点的生命最大值，所以是向大的方向更新
			//还需要判断的是能不能活着跑到这点，所以要≥0 
			{
				dis[v]=dis[u]-val[i];
				q.push(make_pair(dis[v],v));
				//入队 
			}
		}
	}
	return dis[n]!=-1;
	//如果不能活着到达，就证明该方案不行，反之可以 
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",num+i);
		l=min(l,num[i]);
		r=max(r,num[i]);
		//初始化二分的边界，为节点的点权的最大值和最小值 
	}
	flag=r;
	//加一个标记最后判断“AFK” 
	for(int i=1;i<=m;++i)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
		add(v,u,w);
		//双向边 
	}
	while(l<=r)//二分答案 
	{
		int mid=l+r>>1;
		if(judge(mid)) r=mid-1;
		else l=mid+1; 
	}
	if(l==flag+1) puts("AFK");
	//如果这个二分的答案比最大的点权值还要大，就证明不能到达喽 
	else printf("%d\n",l);
	//输出最终答案 
}
/*
简单分析一下时间复杂度：
二分答案的时间复杂度是：O(枚举) * O(判断)
枚举的时间复杂度就是O(logN)
判断的时间复杂度就是一遍dijkstra+堆优化
判断的时间复杂度就是O(MlogN)
综合一下，该程序的时间复杂度就是O(MlogNlogN)
M与N同级别，都是十万级，所以是可以在1s之内跑完的
分析完毕！！ 
*/
```
撒花结尾

---

## 作者：shenbear (赞：21)

这题大家思路都差不多，就是二分+最短路

不过我觉得djslt算法的都没讲太清楚，我再帮我这种蒟蒻吗理一下思路

首先，我们看到这里有二维，血和钱

二维最短路？还好，他只要最大钱最小

那么就是~~最大流~~，好吧是二分答案

我们可以这么想，如果给最短路中加一个花费上限mid，那么这个上限越大，那么跑的情况就越多，就越可能在没死前跑路，那么就产生了单调性：

**mid越大，成功可能性越大**

所以我们就二分mid，将二分出的mid带入djstl中，跑出扣的最少的血，如果<b,就压右边界，反之，压左边界


------------
二分答案


------------

```
int l=0,r=1000000000;
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(djstl(mid))
		{
			ans=min(ans,mid);
			r=mid-1;
		}
		else l=mid+1;
	}
```


------------
最短路本质上就是求会扣的最少血量，而且发现

**没有负权，且nm=5e8，spfa有可能会被卡，不过看其他spfa题解，这题好像良心没卡，但毕竟不安全，没有负权就不要用spfa，直接djstl就好了**


------------
djstl代码


------------

```
bool djstl(int mid)//mid是花费上界
{
	for(int i=2;i<=n;i++) dis[i]=1e9;//注意多次运算，需要清空
	q.push(vs(1,0));
	while(!q.empty())//队列不用清空，不解释
	{
		vs u=q.top();
		q.pop();
		if(u.vl>dis[u.x]) continue;
		for(int i=head[u.x];i;i=p[i].next)
		{
			int v=p[i].to;
			if(a[v]>mid) //超出花费上界，不走
			continue;
			if(dis[v]>dis[u.x]+p[i].vl)
			{
				dis[v]=dis[u.x]+p[i].vl;
				q.push(vs(v,dis[v]));
			}
		}
	}
	return dis[n]<b;
}
```


---

## 作者：小知青 (赞：10)

##### 本题题面可以简化为：“有一个n点m条边的无向图，图上每条边有边权，每个点有点权，请求出一条从点1到n的道路，使得边权之和小于给定限制b，并且最小化经过点权的最大值”
##### 如果我们再考虑题目，就不难发现，可以二分处理本题：二分点权的最大值，如果有一点的点权大于该值，就不去这一点。然后跑一边最短路，检测是否能到达终点，并继续二分。
代码如下：
```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<vector>
using namespace std;
struct nod
{
    int st,en,cot;
};
queue<int>q;
vector<nod>v[10005];
int b,m,n,p[10005],vis[10005];
long long dis[10005];
void add(int x,int y,int z)
{
    nod xx;
    xx.st=x;xx.en=y;xx.cot=z;
    v[x].push_back(xx);
}
bool spfa(int lim)
{
    memset(dis,127,sizeof(dis));
    memset(vis,0,sizeof(vis));
    vis[1]=1;dis[1]=0;q.push(1);
    while(!q.empty())
    {
        int h=q.front();
        q.pop();vis[h]=0;
        for(int i=0;i<v[h].size();i++)
        {
            nod t=v[h][i];
            if(dis[t.en]>dis[t.st]+t.cot&&p[t.en]<=lim){
                dis[t.en]=dis[t.st]+t.cot;
                if(!vis[t.en]){
                	q.push(t.en);
                	vis[t.en]=1;
                }
            }
        }
    }
    if(dis[n]>b)return 0;
    else return 1;
}
int main()
{
    cin>>n>>m>>b;int l,r,mid;r=0;
    for(int i=1;i<=n;i++){
    	cin>>p[i];
        if(p[i]>=r)r=p[i];
    }
    l=0;//l也可以赋值为其他比r小的值
    for(int j=1;j<=m;j++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);add(y,x,z);
    }
    if(!spfa(1000000001)){
        cout<<"AFK";return 0;
    }
    while(l<=r){
        mid=(l+r)>>1;
        if(spfa(mid))r=mid-1;
        else l=mid+1;
    }
    cout<<l;
    return 0;
}
```

---

## 作者：0x404 (赞：9)







```cpp
//与p1948相似 二分+spfa
//二分当前收费最大
//跑spfa检验答案
//如果 d[n]>b 则答案不符合条件
//注意spfa中松弛的对象应该是小于等于当前检验答案的点
#include <cstdio>
#include <iostream>
#include <cstring>
#include <queue>
#define MAXN 6666666
#define INF 9999999999
using namespace std;
inline long long read(){
    char ch='*';
    while(!isdigit(ch=getchar()));
    long long num=ch-'0';
    while(isdigit(ch=getchar())) num=num*10+ch-'0';
    return num;
}
long long h[MAXN],to[MAXN],next[MAXN],val[MAXN],cnt;
inline void add(long long u,long long v,long long w){
    to[++cnt]=v;val[cnt]=w;next[cnt]=h[u];h[u]=cnt;
}
long long d[MAXN],w[MAXN],n,m,b;
bool vis[MAXN];
inline void spfa(int limit){
    memset(vis,0,sizeof vis);
    for(int i=1;i<=n;i++) d[i]=INF;
    queue<int> q;
    d[1]=0,vis[1]=true,q.push(1);
    while(!q.empty()){
        int u=q.front();q.pop();vis[u]=false;
        for(int e=h[u];e;e=next[e]){
            if(w[to[e]]<=limit&&d[to[e]]>d[u]+val[e]){
                d[to[e]]=d[u]+val[e];
                if(!vis[to[e]])
                    vis[to[e]]=true,
                    q.push(to[e]);
            }
        }
    }
}
inline bool judge(int mid){
    spfa(mid);
    if(d[n]>b) return false;
    return true;
}
int main(){
    long long l=0,r=0;
    cin>>n>>m>>b;
    for(int i=1;i<=n;i++) cin>>w[i],r=max(r,w[i]);
    l=max(w[1],w[n]);
    for(long long i=1,u,v,w;i<=m;i++){
        cin>>u>>v>>w;
        add(u,v,w);add(v,u,w);
    }
    spfa(r);
    if(d[n]==INF||d[n]>b){
        printf("AFK");
        return 0;
    }
    while(l<=r){
        int mid=(l+r)>>1;
        if(judge(mid)) r=mid-1;
        else l=mid+1; 
    }
    printf("%d",l);
    return 0;
}

```

---

## 作者：doyo (赞：8)

在NOIP之前写写题解攒攒人品

关于这道题，光看一下输入数据就是一道图论题（这个谁都知道）。。。

然后要注意的点就是题目中这个“所经过的所有城市中最多的一次收取的费用的最小值”，就知道是二分答案了

思路：优先队列优化dijkstra+二分答案

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=2e5+5;//个人习惯 
const int inf=0x3fffffff;//设为0x7fffffff会炸 
int val[maxn],dis[maxn],head[maxn],n,m,b,tot,l=inf,r=-inf,ans;
struct Edge
{
    int next;
    int to;
    int dis;
}edge[maxn];//链式前向星存边。 
struct node
{
    int u;
    int val;
};
bool operator < (const node &a,const node &b)
{
    return a.val>b.val;//重定义小于号 
}
void addedge(int from,int to,int dis)
{
    edge[++tot].next=head[from];
    edge[tot].to=to;
    edge[tot].dis=dis;
    head[from]=tot;
}
priority_queue<node> q;
bool judge(int x)//优先队列优化dijkstra判断答案是否可行 
{
    for(int i=1;i<=n;i++) dis[i]=inf;
    dis[1]=0;q.push((node){1,0});
    while(!q.empty())
    {
        node temp=q.top();q.pop();
        int u=temp.u,d=temp.val;
        if(dis[u]!=d) continue;
        for(int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            if(val[v]<=x&&dis[u]+edge[i].dis<dis[v])
            {
                dis[v]=dis[u]+edge[i].dis;
                q.push((node){v,dis[v]});
            }
        }
    }
    return dis[n]<=b;//如果dis[n]>b，歪嘴鹅就会gay gay,说明答案不可行
}
int main()
{
    int x,y,z;
    scanf("%d%d%d",&n,&m,&b);
    for(int i=1;i<=n;i++) 
    {
        scanf("%d",&val[i]);
        l=min(l,val[i]);//有解答案左区间
        r=max(r,val[i]);//有解答案右区间
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        if(x==y) continue;//去除自环 
        addedge(x,y,z);
        addedge(y,x,z);
    }
    if(!judge(inf)) 
    {
        printf("AFK\n");//如果交无穷大的费用都过不去的话，说明不能从点1到点n 
        return 0;
    }
    while(l<=r)//二分答案模板 
    {
        int mid=(l+r)>>1;
        if(judge(mid))
        {
            ans=mid;
            r=mid-1;
        }
        else l=mid+1;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：jins3599 (赞：7)

简单的二分答案+最短路。

看到要求最大的最小，思考二分答案，然后我们发现题目的单调性是很明显的。

我们每次二分最大的费用$w$，然后把所有大于$w$的结点标记不合法，跑一次最短路，若最后可以到达终点，记录一下答案，然后我们让$w$变小继续跑，否则让$w$变大继续跑。

时间复杂度$O(knlogn)$（$k$为`spfa`中的“常数”）

(在出题人不卡`spfa`的情况下....）

但是我要是卡一下，总复杂度立马就变成了$O(mnlogn)$

胆小就写个稳定$O(mlog^2n)$的$dij$吧..

记得判重边，不然的话出现二元环会很麻烦。


(有事没事开个`long long`~)
```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 50005;
int n , m , b;
int head[N] , cnt;
map <pair<int , int> , int> vis;
int a[N] , l , r;

struct Edge {
	int to , nxt , w;
}e[N << 1];

void add(int u , int v , int w) {
	e[++ cnt].to = v;
	e[cnt].w = w;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

bool flag[N] , inq[N];
int dis[N];
bool Spfa (int x) {
	for(int i = 1 ; i <= n ; ++ i) {
		inq[i] = 0;
		if(a[i] <= x) flag[i] = 0;
		else flag[i] = 1;
	}
	for(int i = 2 ; i <= n; ++ i) dis[i] = 0x7fffffff;
	queue<int> q; q.push(1); inq[1] = 1;
	while(! q.empty()) {
		int now = q.front(); q.pop();
		if(flag[now]) continue;
		inq[now] = 0;
		for(int i = head[now] ; i ; i = e[i].nxt) {
			int v = e[i].to , w = e[i].w;
			if(flag[v]) continue;
			if(dis[v] > dis[now] + w) {
				dis[v] = dis[now] + w;
				if(!inq[v]) inq[v] = 1 , q.push(v);
			}
		}
	}
	return dis[n] <= b;
}

signed main () {
	scanf("%lld %lld %lld" , &n , &m , &b);
	for(int i = 1 ; i <= n ; ++ i) scanf("%lld" , a + i) , r = max(a[i], r);
	while(m -- ) {
		int u , v , w;
		scanf("%lld %lld %lld" , &u, &v, &w);
		if(vis.count(make_pair(u , v)) || vis.count(make_pair(v , u))) continue;
		vis[make_pair(u , v)] = vis[make_pair(v , u)] = 1;
		add(u , v , w); add(v , u , w);
	}
	int ans;
	if(!Spfa(1000000005)) {
		puts("AFK"); return 0;
	}
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(Spfa(mid)) ans = mid , r = mid - 1;
		else l = mid + 1; 
	}
	printf("%lld\n" , ans);
	return 0;
}
```

---

## 作者：eros1on (赞：3)

看完题面感觉语文要挂科。。。o(╥﹏╥)o

## 题意：
$n$个点$m$条边的带权无向图

每个点还有一个点权

求$1-n$的一条最短路径，使得路径长度比$b$断，并且经过的点权之和最大。

输出这个最大值


------------

## 思路


这题正解 **$SPFA$ $+$ 二分**

_只看思路的同志们到此为止_

------------

## 详情

~~很简单，~~先来个二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了$QAQ$

------------

## 代码

```cpp
#include <queue>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 50010
#define INF (int)1e9
int n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; //pre[u]代表u到1的最短路的上一个节点
bool flag[MAXN];
queue<int> Q;
struct edge{ //邻接表
	int v, w;
	edge *next;
}pool[MAXN << 1], *h[MAXN];
inline void addedge(int u, int v, int w){ //建边函数
	edge *p = &pool[++cnt], *q = &pool[++cnt];
	p->v = v, p->w = w, p->next = h[u], h[u] = p;
	q->v = u, q->w = w, q->next = h[v], h[v] = q;
}
inline void spfa(int money){ //money代表这次至少收取多少钱，所能够走道的最短路
	int u, v;
	for(int i = 2; i <= n; i++) dis[i] = INF;
	flag[1] = true, Q.push(1);
	while(!Q.empty()){
		u = Q.front(), Q.pop(), flag[u] = false;
		for(edge *p = h[u]; p; p = p->next)
			if(dis[v = p->v] > dis[u] + p->w && f[u] <= money){ //注意这里要判一下点权（钱）是否满足要求（money）
				dis[v] = dis[u] + p->w, pre[v] = u;
				if(!flag[v])
					Q.push(v), flag[v] = true;
			}
	}
}
inline int path(int u){ //最短路回溯函数（递归调用）
	if(u == 1) return f[1]; //到头
	if(u != 1 && !pre[u]) return -1; //走不通了（不连通）
	return max(f[u], path(pre[u])); //最多一次的钱
}
inline bool check(int x){ //二分函数
	spfa(x);
	int tmp = path(n);
	if(tmp <= x && tmp >= 0 && dis[n] <= blood) return true;
	return false;
}
int main(){
	int u, v, w, left = INF, right = 0, mid, Max = 0;
	scanf("%d%d%d", &n, &m, &blood);
	for(int i = 1; i <= n; i++){
		scanf("%d", &f[i]);
		left = min(left, f[i]), Max = right = max(right, f[i]);
	}
	for(int i = 1; i <= m; i++){
		scanf("%d%d%d", &u, &v, &w);
		addedge(u, v, w);
	}
	while(left <= right){
		mid = (left + right) >> 1;
		if(check(mid)) right = mid - 1;
		else left = mid + 1;
	}
	if(left > Max) puts("AFK");
	else printf("%d\n", left);
	return 0;
}
```

---

## 作者：president (赞：3)

 首先，看见最大值最小，不考虑有坑的情况，就要像到最短路+二分。~~（是个套路，要记下来）~~ 
 
 最短路的话应该用dij+堆优化是最优的了，~~SPFA已经死了~~。
 
将到i城市要收到费设两个数组b[i]和c[i]，输入的时候是一样的。但是要对c进行排序，用于二分找最小值。
 
------------
以下放上代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=10010;
const int M=50010;
int n,m,hp;
struct node
{
    int next,to,w;
}a[M<<1];
int b[N],c[N],d[N],vis[N],head[N],tot;
void add(int x,int y,int z)//建图 
{
    a[++tot].next=head[x];
    a[tot].to=y;
    a[tot].w=z;
    head[x]=tot;
}
priority_queue<pair<int,int> >q;
int check(int x)
{
    if(x<b[1]||x<b[n]) return 0;
    memset(d,inf,sizeof(d));
    for(int i=1;i<=n;i++){
        if(b[i]>x) vis[i]=1;
        else vis[i]=0;
    }//将收费大于mid的路标记
    d[1]=0; q.push(make_pair(0,1));
    while(!q.empty())//在可以走的路 
    {
        int u=q.top().second; q.pop();
        if(vis[u]) continue; vis[u]=1;
        for(int i=head[u];i;i=a[i].next)
        {
            int v=a[i].to;
            if(d[v]>d[u]+a[i].w){
                d[v]=d[u]+a[i].w;
                q.push(make_pair(-d[v],v));
            }
        }
    }
    if(d[n]<hp) return 1;
    else return 0;
}
int main()
{
    scanf("%d%d%d",&n,&m,&hp);
    for(int i=1;i<=n;i++){scanf("%d",&b[i]); c[i]=b[i];}
    sort(c+1,c+n+1);
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w); add(u,v,w); add(v,u,w);
    }
    if(!check(c[n])) {printf("AFK\n"); return 0;}
    int l=1,r=n,mid;
    while(l<r)//二分 
    {
        mid=(l+r)>>1;
        if(check(c[mid])) r=mid;
        else l=mid+1;
    }
    printf("%d\n",c[l]);
    return 0;
}
```


---

## 作者：209074233fal (赞：2)

1.用堆优化的dijk，1.23s

2.用一个集合把城市费用复制排序一遍（优化logn，可以没有的）

然后二分的是城市编号，用的是城市的值

贪心的是最小不能达到的城市费用，

那么（前提是到达过最后一节点[标记flag判AFK]）他下一个城市费用就是答案

3.希望大佬告诉我为什么dis要开long long才能过，感激不尽

```

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
int n,m,b;
const int maxn=10086,maxm=50505;
struct edge
{
	int v,w,next;
}e[maxm<<1];
int k,head[maxn],city[maxn],unin[maxn];
void add(int u,int v,int w)
{
	k++;
	e[k].v=v;
	e[k].w=w;
	e[k].next=head[u];
	head[u]=k;
}

int mid;bool flag;
inline int cmid(int l,int r){return (l+r+1)>>1;};

long long dis[maxn];
bool vis[maxn];
#define M make_pair
typedef pair<int,int> pii;
priority_queue<pii,vector<pii>,greater<pii> >q;
bool dijk()
{
	int cnt=0;
	int k=unin[mid];
	memset(dis,127,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[1]=0;
	q.push(M(0,1));
	while(!q.empty() and cnt<n)
	{
		int d=q.top().first,u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;cnt++;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].v,w=e[i].w;
			if(city[v]>k)
			{
				continue;
			}
			if(dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				q.push(M(dis[v],v)); 
			}
		}
	}
	if(dis[n]<=b){flag=1;return	0;}//到的了，上界可能更小 
	else return 1;//到不了，下界增加 
}
int main()
{
	//freopen("test.txt","r",stdin);
    cin>>n>>m>>b;
    for(int i=1;i<=n;i++)
    {
    	scanf("%d",&city[i]);
    	unin[i]=city[i];
    }
    sort(unin+1,unin+1+n);
    for(int i=1;i<=m;i++)
    {
    	int al,bl,cl;
    	scanf("%d%d%d",&al,&bl,&cl);
    	add(al,bl,cl);
    	add(bl,al,cl);
    }
    int l=1,r=n;
    while(l<r)
    {
    	mid=cmid(l,r);
    	if(city[1]>unin[mid])
    	{
    		l=mid;
    		continue;
		} 
    	if(dijk())l=mid;
    	else r=mid-1;
    }
    if(!flag)cout<<"AFK";
    else cout<<unin[l+1];
    return 0;
}
  
 ```

---

## 作者：理想气体 (赞：2)

先指出楼下的错误= =

在第二遍SPFA中无法判断每一步取到的最小值是否满足“最终到n点生命会大于零”的条件，也就是说在这次SPFA中限制条件仅仅是“到该点时生命不为零”，故有一个点会因此WA掉。

这种方法虽然是错的，但是还是有九十分，在比赛中也是很理想了不是么（笑）

因此下面贴上这种方法的简化形式= =在一遍SPFA内解决并得到九十分的代码= =





```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
struct po
{
    int p,v;
};
bool cant_ar[10005],isin[10005];
vector<po> map[10005];
queue<int> q;
long long d[10005],d2[10005];
int n,m,b;
long long cv[10005];
const long long INF = 20000000000;
void SPFA1()
{
    q.push(1);isin[1] = true;d2[1] = cv[1];
    while(!q.empty())
    {
        int x = q.front();q.pop();isin[x] = false;
        for(vector<po>::iterator ite = map[x].begin() ; ite != map[x].end() ; ite++)
        {
            if(d[(*ite).p] > d[x] + (*ite).v)
            {
                d[(*ite).p] = d[x] + (*ite).v;
                d2[(*ite).p] = max(d2[x] , cv[(*ite).p]);
                if(!isin[(*ite).p])
                {
                    q.push((*ite).p);
                    isin[(*ite).p] = true;
                }
            }
            if(d[x] + (*ite).v <= b)
            {
                if(d2[(*ite).p] > max(d2[x] , cv[(*ite).p]))
                {
                    d2[(*ite).p] = max(d2[x] , cv[(*ite).p]);
                    if(!isin[(*ite).p])
                    {
                            q.push((*ite).p);
                            isin[(*ite).p] = true;
                    }
                }
            }
        }
    }
    for(int i = 1 ; i <= n ; i++)
    {
        if(d[i] > b)
            cant_ar[i] = true;
    }
}
int main()
{
    cin.sync_with_stdio(false);
    cin>>n>>m>>b;
    for(int i = 1 ; i <= n ; i++)
    {
        cin>>cv[i];d[i] = d2[i] = INF;
    }
    d[1] = 0;
    for(int i = 1 ; i <= m ; i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        map[x].push_back((po){y,z});
        map[y].push_back((po){x,z});
    }
    SPFA1();
    if(cant_ar[n])
    {
        cout<<"AFK";
        return 0;
    }
    cout<<d2[n];
    return 0;
}
最后——想要AC的同学们还是老老实实二分加SPFA吧，楼下这种方法估计并不能走得通。
```

---

## 作者：intruder (赞：2)

因为一个vis的时候spfa判断错了好久都没a 老是错一组 哎 思想很简单 遇到最大值中求最小值或者最小值中 求最大值就应该想到二分 二分最小的最大费用 在spfa中判断一下 就好了 其实可以把c从小到大排序再用下标二分 但是我懒 而且数据还这么水


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#define maxn 20100
#define maxm 100100
#define ll long long
using namespace std;
ll n,m,b,Max=-1,cnt=1;
ll f[maxn],d[maxn],head[maxn];
queue<ll>q;
struct edge{
    ll u,next,c;
}e[maxm];
void adde(ll a,ll b,ll c){
    e[cnt].u=b;
    e[cnt].c=c;
    e[cnt].next=head[a];
    head[a]=cnt++;
}
//条件是小于或者等于mid 如果不可以的话 就直接终止程序输出 AFK 
ll vis[maxn];
bool ok =0;
bool spfa(ll mid){
    while(!q.empty())q.pop();
    memset(vis,0,sizeof(vis));
    for(ll i=1;i<=n;i++)d[i]=1e15;
    d[1]=0;
    vis[1]=1;
    q.push(1);
    for(int i=1;i<=n;i++)if(f[i]>mid)vis[i]=1;
    if(f[1]>mid||f[n]>mid)return 0;
    while(!q.empty()){
        ll x=q.front();q.pop();
        vis[x]=0;
        for(ll i=head[x];i!=-1;i=e[i].next){
            ll u=e[i].u;
            if(d[u]>d[x]+e[i].c){
                d[u]=d[x]+e[i].c;
                if(!vis[u]){
                    vis[u]=1;
                    q.push(u);
                }
            }
        }
    }
    if(d[n]>b)return 0;
    ok=1;
    return 1;
}
int main(){
    scanf("%lld%lld%lld",&n,&m,&b);
    memset(head,-1,sizeof(head));
    for(ll i=1;i<=n;i++){
        scanf("%lld",&f[i]);
        Max=max(Max,f[i]);
    }
    for(ll i=1;i<=m;i++){
        ll a,b,c;
        scanf("%lld%lld%lld",&a,&b,&c);
        adde(a,b,c);
        adde(b,a,c);
    }
    ll l=1,r=Max;
    ll mid;
    while(l<r){
        mid=(l+r)/2;
        if(spfa(mid))r=mid;
        else l=mid+1;
    }
    if(!ok&&!spfa(l))printf("AFK");
    else
    printf("%lld",l);
    return 0;
}
```

---

## 作者：米奇奇米 (赞：2)

## 题解-P1462 通往奥格瑞玛的道路

### $1.1$题目意思
题目意思很简单，就是你要从$1$到$n$，你有$b$的血量，每次从一个城市到另一个城市会消耗$bi$的血量，每个城市需要花$wi$的费用。现在问你当你的$0\leq b$时，他所经过的所有城市中最多的一次收取的费用的最小值是多少。

### $2.1$算法思路
题目要求我们求最小值显然想到用二分求解呀。我们直接二分答案。但是需要注意的是：当你二分完后，但不一定而分出了答案，所以要对答案进一不验证，就是判断当你血量还是大于$0$时是否达到了城市$n$。在$check$的时候，对于$mid\leq f[n]$ 或者 $mid\leq f[1]$，直接$continue$掉，然后对于$mid\leq f[i]$的$vis[i]=1$即可。

### $3.1$代码实现
```cpp
#include <bits/stdc++.h>
#define re register
#define int long long 
using namespace std;

const int maxn=1e5+5,maxm=5e5+5;
struct nood {
	int nex,to,w;
} e[maxm];
int head[maxn],dis[maxn],vis[maxn];
int n,m,b,cnt,ans,now,maxf,f[maxn],ff=0;

inline void add_edge(int u,int v,int len) {
	e[++cnt].nex=head[u];
	head[u]=cnt;
	e[cnt].to=v;
	e[cnt].w=len;
}
//前向星连边
inline int read() {
	int sum=0; char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) sum=sum*10+ch-'0',ch=getchar();
	return sum;
}
//快读
inline bool spfa(int x) {
	queue<int>ma;
	memset(vis,0,sizeof(vis));
	memset(dis,0x7f,sizeof(dis));
	ma.push(1),dis[1]=0,vis[1]=1;
	for ( re int i=1;i<=n;i++ ) 
		if(f[i]>x) vis[i]=1;
    //对于那些mid<f[i]的点标记为1
	while(!ma.empty()) {
		int u=ma.front(); 
		ma.pop(); 
		vis[u]=0;
		for ( re int i=head[u];i;i=e[i].nex ) {
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].w) {
				dis[v]=dis[u]+e[i].w;
				if(!vis[v]) {
					vis[v]=1;
					ma.push(v);
				}
			}
		}
	}//普通的最短路spfa
	if(dis[n]>b) return false;
	ff=1;
	return true;
	while(ma.size()) ma.pop();
}

signed main() {
	n=read(),m=read(),b=read();
	for ( re int i=1;i<=n;i++ ) 
		f[i]=read();
	for ( re int i=1;i<=m;i++ ) {
		int u=read(),v=read(),z=read();
		add_edge(u,v,z);
		add_edge(v,u,z);
	}
	int l=0,r=1e10;
	while(l<=r) {
		int mid=(l+r)/2;
		if(mid<f[n]||mid<f[1]) {
			l=mid+1;
			continue;
		}
        //对于而二分出的值小于f[1]或者f[n]直接跳过，并且l++，不l++会进入死循环。
		if(spfa(mid)) r=mid-1,ans=mid;
		else l=mid+1;
	}
	if(ff==0 && !spfa(ans)) 
		return printf("AFK\n"),0;
    //如果ff到达标记还是0，并且当前答案还是不对，输出AFK
	printf("%lld\n",ans);
	return 0;
}
```
### $4.1$总结
这道题目其实很简单，就是二分+$spfa$，仔细想一想肯定能够$AC$的。

---

## 作者：k1saki (赞：1)

思路：二分+堆优化dijkstra（~~关于SPFA，这题它没死~~）
二分处理点权（收费的多少）,最短路处理边权（血量）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int ans,pp[10005],point[10005],pnt[100005],nxt[100005],head[10005],len[100005],E,dis[10005],INF=2147483647,n,m,b;
struct node
{
	int val,pos;
	bool operator<(node x)const
	{
		return val>x.val;
	}//重载运算符
	node()
	{
	}
	node(int _val,int _pos)
	{
		val=_val,pos=_pos;
	}
};//也可以用pair处理
void add_edge(int u,int v,int w)
{
	pnt[E]=v;
	len[E]=w;
	nxt[E]=head[u];
	head[u]=E++;
}//前向星
bool dijkstra(int u,int mid)
{
	priority_queue<node> q;
	for (int i=1;i<=n;i++) dis[i]=INF;
	dis[u]=0;
	q.push(node(0,u));
	while(!q.empty())
	{
		node x=q.top();
		q.pop();
		int uu=x.pos,vv=x.val;
		//cout<<uu<<' '<<vv<<endl;
		if (vv!=dis[uu]) continue;//如果堆中节点的dis大于dis[uu]，则说明该节点被修改过，直接continue
		for (int i=head[uu];i!=-1;i=nxt[i])
		{
			int v=pnt[i];
			if (point[v]>mid) continue;//点权大于当前的最大值，continue
			if (dis[v]>dis[uu]+len[i])
			{
				dis[v]=dis[uu]+len[i];
				q.push(node(dis[v],v));
			}
		}
	}
	if (dis[n]>b) return 0;//血量小于0才死，一个小坑点
	return 1; 
}//堆优化dijkstra
signed main()
{
	memset(head,-1,sizeof(head));
	cin>>n>>m>>b;
	for (int i=1;i<=n;i++) scanf("%lld",&point[i]),pp[i]=point[i];
	for (int i=1;i<=m;i++)
	{
		int a,b,c;
		scanf("%lld%lld%lld",&a,&b,&c);
		add_edge(a,b,c);
		add_edge(b,a,c);
	}
	sort(pp+1,pp+1+n);
	int l=1,r=n;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		//cout<<mid<<endl;
		if(dijkstra(1,pp[mid])) ans=pp[mid],r=mid-1;//当前最高收费能跑出来，就继续尝试更小的
		else l=mid+1;//反之更大的
	}
	if (ans==0) cout<<"AFK";
	else cout<<ans<<endl;
}
```

---

## 作者：k，火魂 (赞：1)

题目：https://www.luogu.org/problem/P1462
当初本蒟蒻刚刚学完单源最短路，一鼓作气想要搞完提高历练组中的最短路问题，然后 ~~就没有然后了~~。

最大值最小？？什么鬼？？看题解——~~二分？？没学？？先收到任务计划，~~。

今天突然看见了它，然而它在我的计划里呆了半年多。

废话少说，最大值最小，明显的二分题。
二分什么呢??~~求费用当然分费用啦~~。

我们将费用二分，将费用大于二分值的城市去掉~~这么贵的城市我当然是不会去的啦~~，以掉血设为边权，然后就变成了单源最短路。

根据我精妙绝伦的分析，没有负值，果断SPFA~~其实是想不起来dijkstra怎么写了~~。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define itn int
const int N=1e4+10,M=2e5+10;
int tot,n,m,b,l,r,ans;
int ver[M],edge[M],nex[M],hea[N];
long long dis[N];
int f[N];
bool v[N],fv[N];
queue<int>q;

inline void add(itn x,itn y,itn z){
	ver[++tot]=y;nex[tot]=hea[x];
	hea[x]=tot;edge[tot]=z;
}

inline bool spfa(){
	memset(dis,0x7f7f,sizeof(dis));
	q.push(1);v[1]=1;dis[1]=0;
	while(q.size()){
		int x=q.front();q.pop();v[x]=0;
		for(int i=hea[x];i;i=nex[i]){
			int y=ver[i];
			if(fv[y])continue;
			if(dis[y]>dis[x]+edge[i]){
				dis[y]=dis[x]+edge[i];
				if(!v[y])q.push(y),v[y]=1;
			}
		}
	}
	if(dis[n]<b)return 1;
	else return 0;
}

inline bool check(int x){
	memset(fv,0,sizeof(fv));
	for(int i=1;i<=n;i++)if(f[i]>x)fv[i]=1;
	if(fv[n]||fv[1])return 0;
	return spfa();
}

int main()
{
	scanf("%d%d%d",&n,&m,&b);
	for(int i=1;i<=n;i++){
		scanf("%d",&f[i]);
		r=max(r,f[i]);
	}
	for(int i=1;i<=m;i++){
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid))ans=mid,r=mid-1;
		else l=mid+1;
	}
	if(ans==0)printf("AFK");
	else printf("%d",ans);	
	return 0;
}
```


---

## 作者：1379号监听员 (赞：1)

# P1462 题解

---

## 题目大意：
给定一个$n$个点的无向图，求在满足从$1$到$n$的最短路边权和 $\leq b$ 的情况下，所经过的点的最大点权的最小值。

### 思路：
带有 **“最大值最小”** 的“双最”字样的最优化题目一般比较难直接求解，这时候我们不妨用二分的思想，将最优化问题转换为判断合法性问题。

二分代码模板：

``` cpp
while(l<=r)
{
  mid=(l+r)>>1;
  if(check(mid)) ans=mid,r=mid-1; //如果解合法，记录答案并缩小左边界
  else l=mid+1;//否则缩小右边界
}
cout<<ans<<endl;
```

### check()函数的设计：

首先，假设我们已经找到了一个解 $val$，那么所有点权 $> val$的点就不能被访问了(因为如果这样做就不满足解)。然后再求出$1$到$n$的最短路 *(SPFAer和Dijkstrer们可以不要争了，这个优先队列BFS就可以做，还比你们都快 233)*，之后判断最短路的权值和是否 $\leq b$ ，如果不满足则说明解不合法 ~~（会被揍死）~~。


### 一些小坑点：
- 二分时需要判断 **“无论如何也无法到达的情况”** ；
- fi≤1000000000,因此直接二分会T飞，要先离散化；
- ci≤1000000000,记得开 long long 不然炸飞；

---

## 代码：
``` cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<cstdio>
#include<cstring>
#include<ext/pb_ds/priority_queue.hpp>
using namespace std;
const int maxn=10005;
typedef long long ll;
int n,m,b;

inline ll read()//快读
{
  ll s=0,w=1;
  char c=getchar();
  while(c<'0' || c>'9'){
    if(c=='-') w=-1;
    c=getchar();
  }
  while (c>='0' && c<='9') {
    s=(s<<3)+(s<<1)+(c^48);
    c=getchar();
  }
  return s*w;
}

/**
 * BFS的记录结构体
 * @param cur 当前点
 * @param c 已经扣掉的血量
 */
struct note{
  ll cur,c;
  note(ll a,ll b):cur(a),c(b) {}
  note() {}
};
//没什么好说的，比较运算符
struct cmp{
  bool operator () (note a,note b)
  {
    return a.c>b.c;
  }
};
//pbds的黑科技堆，详细描述可以看这里：https://blog.xehoth.cc/pb-ds-PriorityQueue/
typedef __gnu_pbds::priority_queue<note,cmp,__gnu_pbds::pairing_heap_tag> heap;

//vector数组存图
struct edge{
  ll to;ll w;
  edge(ll a,ll b):to(a),w(b) {}
  edge() {}
};
vector<edge> e[maxn];
ll v[maxn];//点权数组
/**
 * 增加一条x到y,权值为w的边
 */
inline void addedge(ll x,ll y,ll w)
{
  e[x].push_back(edge(y,w));
}

//BFS部分
bool vis[maxn];
ll bfs(ll val)
{
  memset(vis,0,sizeof(vis));
  heap q;
  q.push(note(1,0));
  vis[1]=true;
  while(!q.empty())
  {
    note cu=q.top();
    q.pop();
    if(cu.cur==n){
      return cu.c;
    }
    ll& st=cu.cur;
    ll& co=cu.c;
    for(int i=0;i<e[st].size();i++)
    {
      ll& to=e[st][i].to;
      if(!vis[to] && v[to]<=val)
      {
        q.push(note(to,co+e[st][i].w));
        vis[to]=true;
      }
    }
  }
  return 0x3f3f3f3f;//如果到不了返回无穷大
}

ll lsv[maxn];//离散数组
int main()
{
  n=read(),m=read(),b=read();
  for(int i=1;i<=n;i++) lsv[i-1]=v[i]=read();
  for(int i=1,x,y,w;i<=m;i++) {
    x=read(),y=read(),w=read();
    if(x!=y) addedge(x,y,w),addedge(y,x,w);
  }
  //离散化
  sort(lsv,lsv+n);
  int sz=unique(lsv,lsv+n)-lsv;
  //二分
  int l=0,r=sz,mid,ans=-1;
  while(l<=r)
  {
    mid=(l+r)>>1;
    if(bfs(lsv[mid])<=b) ans=mid,r=mid-1; 
    else l=mid+1;
  }
  if(ans==-1){//如果答案没被更新过即为“不可到达”
    printf("AFK\n");
    return 0;
  }
  else printf("%lld\n",lsv[ans]);//输出答案
}
```

总时间复杂度：$O(nlogn * logn) = O(nlog^2 n)$,比几乎所有题解都要快

顺便安利一下本人的博客：[链接](https://directional-foil.blog.luogu.org)

---

## 作者：yangyujia18 (赞：1)

这道题是一道最短路~~大家一定也看的出来~~  
我们用二分枚举最大收费~~反正数据也不大~~  
~~这个核心部分是我写的板子直接抄的~~

```cpp
#include<bits/stdc++.h>
using namespace std;
struct to
{
	int p;
	long long damage;
	bool operator < (const to& rhs)const
	{
		return damage>rhs.damage;
	}
};
const long long INF=9e18;
int n,m,b;
long long dist[10003];
vector<to> road[10003];
long long f[10003];
char went[10003];
priority_queue<to> q;
bool dijkstra(int ub)
{
	int start,health=b;
	for(int i=0;i<=n;i++)
		dist[i]=INF;
	dist[1]=0;
	q.push((to){1,0});
	memset(went,0,sizeof(went));
	while(!q.empty())
	{
		to x=q.top();
		q.pop();
		start=x.p;
		if(went[start]==1||f[start]>ub)
			continue;
		went[start]=1;
		for(int j=0;j<road[start].size();j++)
		{
			int end=road[start][j].p;
			if(dist[end]>dist[start]+road[start][j].damage&&f[end]<=ub)
			{
				dist[end]=dist[start]+road[start][j].damage;
				q.push((to){end,dist[end]});
			}
		}
	}
	return dist[n]<b;
}
int merge(int l,int r)
{
	while(l<r)
	{
		int mid=(l+r)/2;
		if (dijkstra(mid))
			r=mid;
		else
			l=mid+1;
	}
	return r;
}
int main()
{
	cin>>n>>m>>b;
	for(int i=1;i<=n;i++)
	{
		cin>>f[i];
		
	}
	for(int i=1;i<=m;i++)
	{
		int start,end,attack;
		cin>>start>>end>>attack;
		road[start].push_back((to){end,attack});
		road[end].push_back((to){start,attack});
	}
	int ans=merge(1,1e9);
	if(ans!=1e9)
		cout<<ans<<endl;
	else
		cout<<"AFK"<<endl;
	return 0;
}
```

~~身为一位对魔兽有一点了解的炉石玩家，我能想到的符合这位术士形象的就是古尔丹~~

---

## 作者：Tgotp (赞：1)

巩固最短路可以一刷；

思路：最短路+二分；

将花费二分，求到达目的地最小扣血量，如果大于总血量就不能走，反之则行，更新ans；

如果到最后都没更新一次ans，就输出AFK，其余没啥好讲的；

不会二分的话可以看noip2015第四题；

代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N = 10000 + 5;
int head[N],tot,z[N],n,m,b,ans,d[N];
struct node
{
    int next,val,to;
}edge[10*N];
void add(int x,int y,int c)
{
    edge[tot].to=y;
    edge[tot].next=head[x];
    edge[tot].val=c;
    head[x]=tot++;
}
bool SPFA(int l)
{
    if(l<z[1])return false;
    queue<int> Q;
    memset(d,0x3f,sizeof(d));
    bool vis[N];
    d[1]=0;
    vis[1]=true;Q.push(1);
    while(Q.size())
    {
        int a=Q.front();Q.pop();vis[a]=false;
        for(int i=head[a];~i;i=edge[i].next)
        {
            if(z[edge[i].to]<=l && d[edge[i].to]>d[a]+edge[i].val)
            {
                d[edge[i].to]=d[a]+edge[i].val;
                if(!vis[edge[i].to])
                {
                    vis[edge[i].to]=true;
                    Q.push(edge[i].to);
                }
            }
        }
    }
    if(d[n]<=b)return true;
    else return false;
}
int main()
{
    memset(head,-1,sizeof(head));
    cin>>n>>m>>b;
    int l=0x7f;int r=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&z[i]);
        r=max(r,z[i]);
        l=min(l,z[i]);
    }
    for(int i=0;i<m;i++)
    {
        int u,v,val;
        scanf("%d%d%d",&u,&v,&val);
        add(u,v,val);add(v,u,val);
    }
    while(l<=r)
    {
        int mid=(l+r)/2;
        if(SPFA(mid))
        {
            ans=mid;
            r=mid-1;
        }
        else l=mid+1;
    }
    if(ans)printf("%d",ans);
    else printf("AFK");
    return 0;
}
```

---

## 作者：DrCell_CellTech (赞：1)

<http://blog.csdn.net/u014120397/article/details/50962735>

题目里面出现了一个“交费最多的一次的最小值”，最大值最小，果断二分……

由于这个倒霉的家伙还有一个“血量”，而且还过一条路就扣一些，于是我们想到了在二分过程中SPFA，如果这个人只花mid=(l+r)div 2（初始时r=max(cost[i])）的钱能顺利到终点而且扣的血<=血量的话，那么说明可以少花一点钱，此时r=mid，否则就说明还是得破财消灾，l=mid+1，如此往复直至l=r，取此时的l值再SPFA一次，如果还不能正常到达终点，那么就没办法了，输出AFK，否则输出l即可。

代码如下（当然还是pascal的）：

```cpp
type data=record  
          v,next:longint;len:int64;  
          end;  
var edge:array[1..60000]of data;  
    cost:array[1..15000]of longint;  
    head:array[1..60000]of longint;  
    d:array[1..60000]of int64;  
    vis:array[1..20000]of boolean;  
    queue:array[1..1000000]of longint;  
    n,m,i,j,x,y,num,l,r,mid:longint;  
    z,b:int64;  
function spfa(lim:longint):boolean;  
var he,ta:longint;  
    i,j,s,t,e:longint;  
begin  
  he:=0;  
  ta:=1;  
  queue[1]:=1;  
  vis[1]:=true;  
  for i:=1 to n do  
  d[i]:=10000000000000;  
  d[1]:=0;  
  while he<ta do  
  begin  
    inc(he);  
    s:=queue[he];  
    e:=head[s];  
    while e<>0 do  
    begin  
      t:=edge[e].v;  
      if cost[t]>lim then  
      begin  
        e:=edge[e].next;  
        continue;  
      end;  
      if d[t]>d[s]+edge[e].len then  
      begin  
        d[t]:=d[s]+edge[e].len;  
        if not vis[t] then  
        begin  
          inc(ta);  
          queue[ta]:=t;  
          vis[t]:=true;  
        end;  
      end;  
      e:=edge[e].next;  
    end;  
    vis[s]:=false;  
  end;  
  if d[n]>b then exit(false) else exit(true);  
end;  
procedure addedge(x,y,z:longint);  
begin  
  inc(num);  
  edge[num].v:=y;  
  edge[num].next:=head[x];  
  head[x]:=num;  
  edge[num].len:=z;  
end;  
begin  
  readln(n,m,b);  
  num:=0;  
  r:=0;  
  for i:=1 to n do  
  begin  
    readln(cost[i]);  
    if cost[i]>r then r:=cost[i];  
  end;  
  for i:=1 to m do  
  begin  
    readln(x,y,z);  
    addedge(x,y,z);  
    addedge(y,x,z);  
  end;  
  l:=1;  
  while l<r do  
  begin  
    mid:=(l+r)div 2;  
    if (not spfa(mid))or(cost[1]>mid) then l:=mid+1 else r:=mid;  
  end;  
  if spfa(l) then writeln(l) else writeln('AFK');  
end.
```

---

## 作者：QWsin (赞：1)

**
二分+最短路

算法是比较好看出来的

顺便给楼下赞一个

离散化非常厉害  变二分 值为二分 下标

毕竟logn和log10^10不是一个级别的

然后就是现在貌似根本就不会二分了QAQ  我开始写的是mid成立的话就往右边找 = =

找得出来最大值> ->[delete]毕竟土豪[/delete]

其余的没什么讲的

我写的是diikstra -> ->总觉得比SPFA顺眼些

还有   好像，好像是要用long long  int好像会爆= =

**
```cpp

#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
const int maxn=10000+10;
const int maxm=50000+10;
const ll INF=1e15;
struct Node{
    int u,d;
    Node(int u,int d):u(u),d(d){}
    Node(){}
    bool operator < (const Node &rhs)const{
        return d>rhs.d;
    }
};

int n,m,b,mac=-1,mic=(1<<30);
int first[maxn],next[2*maxm],u[2*maxm],v[2*maxm],w[2*maxm];
int cost[maxn],tmpcost[maxn];

int cmp(int a,int b){return a<b;}
void init_data()
{
    cin>>n>>m>>b;
    for(int i=1;i<=n;i++) 
    {
        scanf("%d",&cost[i]);first[i]=-1;
        tmpcost[i]=cost[i];
    }
    for(int i=1;i<=2*m;i+=2)
    {
        scanf("%d%d%d",u+i,v+i,w+i);
        next[i]=first[u[i]];
        first[u[i]]=i;
        w[i+1]=w[i];
        u[i+1]=v[i];
        v[i+1]=u[i];
        next[i+1]=first[v[i]];
        first[v[i]]=i+1;
    }
    sort(tmpcost+1,tmpcost+n+1,cmp);
}

ll d[maxn];
bool vis[maxn];
int dijkstra(ll maxc)
{
    priority_queue<Node>q;
    for(int i=1;i<=n;i++) d[i]=INF,vis[i]=0;
    d[1]=0;
    q.push(Node(1,0));
    while(!q.empty())
    {
        Node x=q.top();q.pop();
        int u=x.u;
        if(vis[u]) continue;
        vis[u]=1;
        for(int i=first[u];i!=-1;i=next[i])
          if(cost[v[i]]<=maxc&&d[v[i]]>d[u]+w[i])
          {
              d[v[i]]=d[u]+w[i];
              q.push(Node(v[i],d[v[i]]));
          }
    }
    if(d[n]>b) return false;
    return true;
}

int main()
{
    init_data();
    if(!dijkstra(INF)) printf("AFK\n");
    else
    {
        int l=1,r=n,ans;
        while(tmpcost[l]<cost[1]||tmpcost[l]<cost[n]) l++;
        while(l<=r)
        {
            int mid=l+(r-l)/2;
            if(dijkstra(tmpcost[mid])) r=mid-1,ans=mid;
            else l=mid+1;
        }
        printf("%d",tmpcost[ans]);
    }
    return 0;
}


```

---

## 作者：hahalidaxin2 (赞：1)

【思路】

二分法+最短路判定。

二分经过城市的最大费用upc，然后判定。判定：对于每一个费用大于upc的城市标记为不可达，求最短路径，判断最短路与血量的关系即可。如果一个城市不可达可以在SPFA算法开始前将inq置为1。

  
小的优化：看到很多同学的时间大约在1000ms左右，大多因为是盲目二分。其实只需要把C值从小到大排序，对C值进行二分就可以了。


【代码】

```cpp

#include<cstdio>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long LL;
const int maxn = 10000+10,maxm=50000+10;
const LL INF=1e15;

struct Edge{
    int v,w,next;
}e[2*maxm];
int en,front[maxn];

int n,m; LL B;
int C[maxn];


inline void AddEdge(int u,int v,int w) {
    en++; e[en].v=v; e[en].w=w; e[en].next=front[u]; front[u]=en;
}

queue<int> q;
int inq[maxn];  LL d[maxn];
bool can(int upc)
{
    memset(inq,0,sizeof(inq));
    for(int i=1;i<=n;i++){
        d[i]=INF;
        if(C[i]>upc) inq[i]=1;
    }
    
    if(C[1]>upc || C[n]>upc) return false;
    d[1]=0; inq[1]=1; q.push(1);
    while(!q.empty()) {
        int u=q.front(); q.pop(); inq[u]=0;
        for(int i=front[u];i>=0;i=e[i].next) {
            int v=e[i].v,w=e[i].w;
            if(d[v]>d[u]+w) {
                d[v]=d[u]+w;
                if(!inq[v]) {
                    inq[v]=1;
                    q.push(v);
                }
            }
        }
    }
    return d[n]<=B;
}

int main() {
    memset(front,-1,sizeof(front));
    scanf("%d%d%lld",&n,&m,&B);
    for(int i=1;i<=n;i++) scanf("%d",&C[i]);
    int u,v,w;
    for(int i=1;i<=m;i++) {
        scanf("%d%d%d",&u,&v,&w);
        AddEdge(u,v,w);
        AddEdge(v,u,w);
    }
    
    int tmpc[maxn];
    memcpy(&tmpc,&C,sizeof(C));
    sort(tmpc+1,tmpc+n+1);
    
    int L=1,R=n+1,M;
    while(L<R) {
        M=L+(R-L)/2;
        if(can(tmpc[M])) R=M;
        else L=M+1;
    }
    if(L>R || (L==R && !can(tmpc[L]))) printf("AFK\n");
    else printf("%d\n",tmpc[L]);
    return 0;
}

```

---

## 作者：timetravler (赞：1)

在将这道题的平均分拉低0.6分之后，终于强行AC过去了。。。。

这道题就是二分答案+SPFA没什么好说的。。。。。但是就是这样也还是水了一下午。。。

代码自行理解。。。

```cpp

#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <algorithm>
using namespace std;
struct edge
{
    int to,next,w; 
}e[100010];
int INF=0x3f3f3f3f;
int n,m,d;
int cost[10001];
int tot,head[10001];
void add(int a,int b,int c)
{
    e[tot].to=b;
    e[tot].next=head[a];
    e[tot].w=c;
    head[a]=tot++;
    e[tot].to=a;
    e[tot].next=head[b];
    e[tot].w=c;
    head[b]=tot++;
}
int dis[10001];
bool spfa(int x)
{
    int l=0,r=1;
    bool inq[10010]={};
    int q[10001]={};
    memset(dis,0x3f,sizeof(dis));
    dis[1]=0;q[0]=1;inq[1]=1;
    while(l!=r)
    {
        int now=q[l++];
        if(l==10001) l=0;
        for(int i=head[now];i;i=e[i].next)
        {
            if(cost[e[i].to]>x) continue;
            if(dis[e[i].to]>dis[now]+e[i].w)
            {
                dis[e[i].to]=dis[now]+e[i].w;
                if(!inq[e[i].to])
                {
                    q[r++]=e[i].to;
                    if(r==10001) r=0;
                    inq[e[i].to]=1;
                }
            }
        }
        inq[now]=0;
    }
    if(d-dis[n]<=0||dis[n]==INF) return 0;
    return 1;
}
/*bool spfa(int x)
{
    int dis[10001],i;
    int p[10001];
    int p1=0,p2=0;
    memset(dis,0x3f,sizeof(dis));
    memset(visit,0,sizeof(visit));
    dis[1]=0,visit[1]=1;
    p[++p2]=1;
    while(p1!=p2)
    {
      int u=p[(++p1)%10000];
      for(i=head[u];i;i=e[i].next)
      {
          int v=e[i].to;
          if(cost[v]>x)
            continue;
          if(dis[v]>dis[u]+e[i].w)
          {
            dis[v]=dis[u]+e[i].w;
            if(!visit[v])
            {
                p[(++p2)%10000]=v;
                visit[v]=1;
            }
          }
      }
      visit[u]=0;
    }
    if(b-dis[n]<=0||dis[n]==INF)
      return 0;
    else return 1;
}*/
int main()
{
    scanf("%d%d%d",&n,&m,&d);
    int i,ma=0;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&cost[i]);
        ma=max(ma,cost[i]);
    }
    for(i=1;i<=m;i++)
    {
      int a,b,c;
      scanf("%d%d%d",&a,&b,&c);
      add(a,b,c);
    }
    int ans;
    int l=0,r=ma,mid=(l+r)>>1;
    if(spfa(INF))
    {
      while(l<=r)
      {
          if(spfa(mid)) 
        {
          r=mid-1;
          ans=mid;
        }
          else l=mid+1;
          mid=(r+l)>>1;
      }
      printf("%d\n",ans);
    }
    else printf("AFK\n");
}
```

---

## 作者：plane (赞：1)

请无视本题的难度。严重不符= =、


由于本题有两个量：血量和金钱要考虑。


我们可以很容易的想到将一个量定下来。


于是我们可以用二分来确定所经过的最大金钱。这样把所有金钱大的全部无视掉。


接着跑最短路，再判断最短路和血量的关系。


本题AFK情况可以在二分前先判断，在无限制条件下做一遍最短路即可。


贴上“煮”过程和SPFA


```delphi


for i:=0 to n+1 do v1[i]:=false;
  mid:=n;
  spfa(1);
  if dist[n]>blood then begin writeln('AFK'); halt; end;

  r:=n;
  mid:=(l+r) div 2;
  while l<r-1 do
    begin
      //writeln(l,' ',r,' ',mid);
      for i:=0 to n+1 do v1[i]:=false;
      spfa(1);
      if dist[n]<=blood then r:=mid else l:=mid;
      mid:=(l+r) div 2;
    end;
  writeln(vlist[r]);


```

```delphi


procedure spfa(s:longint);
var i,j,now,sum,point:longint;
begin
  for j:= 1 to n do dist[j]:=maxlongint;
  dist[s]:=0;
  v1[s]:=true;
  now:=s;
  head:=0;
  tail:=1;
  h1:=0;
  t1:=1;
  d[head]:=s;
  while h1<t1 do
    begin
      now:=d[head];
      point:=front[now];
      while point<>-1 do
        begin
          if (dist[t[point]]>dist[now]+v[point]) and (fv[t[point]]<=vlist[mid])
          then
            begin
              dist[t[point]]:=dist[now]+v[point];
              if not v1[t[point]]
              then
                begin
                  d[tail]:=t[point];
                  v1[t[point]]:=true;
                  tail:=(tail+1) mod 10001; t1:=t1+1;
                end;
            end;
          point:=next[point];
        end;
      v1[now] := false;
      head:=(head+1) mod 10001;
      inc(h1);
    end;
end;


```

---

## 作者：functionendless (赞：1)

思路楼下诸位大大已经讲得很清楚了，SPFA+二分（虽然我不知道为什么用Dij会全T，有知道的人私信我）

但我看到楼下都在用指针，观赏性极低所以我用了vector方便理解

            
```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<queue>
using namespace std;
struct P
{
    int pos;
    long long v;
};
int n,m,b,c[10010],e[10010],ans=0;
vector<P> map[10010];
long long dis[10010];//注意一定要longlong 不止我一个人死在这里了，看看我的提交记录就知道有多惨了
bool used[10010],type[10010];
queue<int> que;
/*bool search(int mid)//Dij
{
    int i,j,p;
    memset(dis,127,sizeof(dis));memset(used,0,sizeof(used));
    dis[1]=0;
    for(i=1;i<=n;i++) if(c[i]>mid) used[i]=1;
    for(i=1;i<=n;i++)
    {
        p=0;
        for(j=1;j<=n;j++) if(!used[j]) p=dis[p]<dis[j]?p:j;
        used[p]=1;
        int l=map[p].size();
        for(j=0;j<l;j++) if(!used[map[p][j].pos]) dis[map[p][j].pos]=min(dis[map[p][j].pos],dis[p]+map[p][j].v);
    }
    if(dis[n]>=b) return false;
    ans=mid;
    return true;
}*/
bool search(int mid)//SPFA
{
    int i;
    memset(dis,127,sizeof(dis)),memset(used,0,sizeof(used)),memset(type,0,sizeof(type));
    for(i=1;i<=n;i++) if(c[i]>mid) type[i]=1;
    dis[1]=0; que.push(1); used[1]=1;
    while(!que.empty())
    {
        int p=que.front(),l=map[p].size();que.pop();
        for(i=0;i<l;i++)
        {
            if((!type[map[p][i].pos])&&dis[map[p][i].pos]>dis[p]+map[p][i].v)
            {
                dis[map[p][i].pos]=dis[p]+map[p][i].v;
                if(!used[map[p][i].pos])
                {
                    que.push(map[p][i].pos);
                    used[map[p][i].pos]=1;
                }
            }
        }
        used[p]=0;
    }
    //printf("%d %d\n",mid,dis[n]);
    if(dis[n]>b) return false;
    ans=mid; return true;
}
int main()
{
    int i,j,x,y,v;
    scanf("%d %d %d",&n,&m,&b);
    for(i=1;i<=n;i++) {scanf("%d",&c[i]); e[i]=c[i];}
    for(i=1;i<=m;i++) 
    {
        scanf("%d %d %d",&x,&y,&v); 
        P tmp;
        tmp.pos=y,tmp.v=v,map[x].push_back(tmp);
        tmp.pos=x,tmp.v=v,map[y].push_back(tmp);
    }
    sort(e+1,e+n+1);
    i=1;
    while(e[i]<c[1]) i++;
    int l=i,r=n;
    while(l<=r)
    {
        int mid=(l+r)/2;
        if(search(e[mid])) r=mid-1;
        else            l=mid+1;
    }
    if(ans) printf("%d",ans);
    else    printf("AFK");
    return 0;
}
```

---

## 作者：Natsume_sosuke (赞：0)

第一次发题解。。刚开始写这题时想直接跑费用的最短路，然后记录收费最大的那一站的费用，hp做为能否走这条边的限制条件。。然而只有81分。。。后面看了其他的题解后才知道要二分答案，但好像很多都是用SPFA的。。就发一个用堆优化的dijkstral吧。。上代码。。
```cpp
#include<bits/stdc++.h>
const int inf = 1e9+10;
const int maxn = 10010;
using namespace std;
int n, m, b;
struct qnode {
	int v，hp;//hp是已扣血量
	qnode(int _v=0,int _h=0):v(_v),hp(_h){}
	bool operator <(const qnode& r)const {
		return hp > r.hp;//欺骗堆中自带的比较，把小的放在top
	}
};
struct Edge {
	int v,c;
	Edge(int _v=0,int _c=0):v(_v),c(_c){}
};
vector<Edge>e[maxn];//邻接表存图
int chp[maxn];//到某个城市要扣的血量
int f[maxn],u[maxn];//记录收费，f用来备份，u用来二分
bool vis[maxn];//标记是否到过
void link(int u, int v, int w) {//添加边
	e[u].push_back(Edge(v, w));
	e[v].push_back(Edge(u, w));
}
bool check(int m) {
	if (m < f[1] || m < f[n])return false;
    //如果起点和终点的收费都比目前的大，说明不符
	for (int i = 1; i <= n; i++) {
		chp[i] = inf;//初始化
		if (f[i] > m)vis[i] = true;//将比当前上限大的标记为已经访问，除去不能走的点
		else vis[i] = false;
	}
    //dijkstral找到n的扣血最少的最短路
	chp[1] = 0;
	priority_queue<qnode> que;
	que.push(qnode(1, 0));
	qnode tmp;
	while (!que.empty()) {
		tmp = que.top();
		que.pop();
		if (vis[tmp.v])continue;
		vis[tmp.v] = true;
		for (auto x : e[tmp.v]) {
			if (!vis[x.v] && chp[x.v] > chp[tmp.v] + x.c) {
				chp[x.v] = dist[tmp.v] + x.c;
				que.push(qnode(x.v, dist[x.v]));
			}
		}
	}
	if (b > chp[n])return true;//若血量大于最小扣血量，则满足
	else return false;
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> m >> b;
	for (int i = 1; i <= n; i++) {
		cin >> f[i];
		u[i] = f[i];
	}
	int rs, re, c;
	while (m--) {
		cin >> rs >> re >> c;
		link(rs, re, c);
	}
	if (!check(inf)) {
    //如果最大的允许费用下都到不了n，那只能死在路上了。
		cout << "AFK" << endl;
		return 0;
	}
    //开始二分
	sort(u + 1, u + n + 1);
	int l = 1, r = n,ans;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (check(u[mid])) {
			ans = u[mid];
			r = mid - 1;
		}
		else l = mid + 1;
	}
	cout << ans << endl;
	return 0;
}

```


---

## 作者：_YYY_ (赞：0)

博客食用效果Max
[$$\text{$\color{red}\large\mathfrak{blog}$}$$](https://www.cnblogs.com/IcedMoon/p/11427914.html)




# 题目分析
## 题目描述
>在艾泽拉斯，有n个城市。编号为1,2,3,...,n。城市之间有m条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。假设1为暴风城，n为奥格瑞玛，而他的血量最多为b，出发时他的血量是满的。歪嘴哦不希望花很多钱，他想知道，在可以到达奥格瑞玛的情况下，他所经过的所有城市中最多的一次收取的费用的最小值是多少。

## 分析过程
看到最大值最小，想到二分答案

考虑到答案在固定集合过路费(val)中，我们只需要保证该集合单调性并在其中二分即可

二分点权集合，每一次都会得到一个点权，这个点权将是路径上所有点点权的最大值

在整张图上寻找路径，但是因为我们得到了一个最大值，所以在寻找过程中不选超过二分值得点

寻找路径便是招最短路，因为我们要的不能死亡就是扣血尽量小

要是不致死，那么二分出的点权就是有效的，继续向下二分，缩小点权范围 
不然的话，扩大点权范围


**还有一个不同于别人的优化，能加快二分速度**

我们初始点在1号，结束点在n号，这两个点是必须经过的，所以最小的点权必须要比这两个点权更大，所以就可以从这两个值中间的更大的那个值的排名作为二分的左端点，详见代码
```cpp
#include<bits/stdc++.h>
#define re register
#define ll long long
using namespace std;
inline int read()
{
	int k=1,sum=0;
	char c=getchar();
	for(;c<'0' || c>'9';c=getchar()) if(c=='-') k=-1;
	for(;c>='0' && c<='9';c=getchar()) sum=sum*10+c-'0';
	return sum*k;
}
int n,m,b;
struct Edge{
	int to,nxt,w;
};
const int N=1e4+10,M=5e4+10;
const int inf=1000000000+10;
Edge edge[M<<1];
int rk=1;
int head[N],cnt;
int val[N],tp[N];
int dis[N];
bool vis[N];
inline void Add(int x,int y,int w){
	edge[++cnt].to=y;edge[cnt].nxt=head[x];edge[cnt].w=w;head[x]=cnt;
}
struct New{
	int u,d;
	bool operator<(const New& qwq) const{
		return d>qwq.d;
	}
};
priority_queue<New> Q;
inline bool Check(int top){
	memset(dis,0x3f3f3f3f,sizeof(dis));memset(vis,0,sizeof(vis));
	dis[1]=0;
	Q.push((New){1,0});
	while(!Q.empty()){
		New fr=Q.top();Q.pop();
		if(vis[fr.u]) continue;
		vis[fr.u]=1;
		int x=fr.u;
		for(re int i=head[x];i;i=edge[i].nxt){
			int y=edge[i].to,z=edge[i].w;
			if(val[y]>top) continue;
			if(dis[y]>dis[x]+z)
			dis[y]=dis[x]+z;
			Q.push((New){y,dis[y]});
		}
	}
	if(dis[n]<=b) return 1;else return 0;
}
int main()
{
	//freopen("agrm.in","r",stdin);
	n=read();m=read();b=read();int js;val[1]=read();js=val[1];tp[1]=val[1];
	for(re int i=2;i<=n;++i) {
		val[i]=read();tp[i]=val[i];
		if(val[i]<js) ++rk;   //进行点权排序
	}
	for(re int i=1;i<=m;++i){
		int u=read(),v=read(),w=read();
		Add(u,v,w),Add(v,u,w);
	}
	sort(tp+1,tp+1+n); // 保证单调性，开始二分
	if(!Check(inf)) {
		puts("AFK");
		return 0;
	}
	int l=rk,r=n,ans;
	int mid;
	while(l<=r){
		mid=(l+r)>>1;
		bool pd=Check(tp[mid]);
		if(pd) {
			r=mid-1;ans=tp[mid];
		}
		else l=mid+1;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：菜鸟至尊 (赞：0)

这道题的思路就是二分查找金币数                   
是否足以让最短路上损血小于血量
复杂度n*logn^2          
在这里可以有几个小优化 

1.二分查找金币的时候可以先排序好费用值二分查找费用值 答案一定是某一个城市费用 保证了其正确性的同时可以加速查找 

2.因为这道题确定了终点为n 所以并不需要跑完整张图                         
dijkstral算法的特性-如果走到了点n且dis[n]还是不满足要求        
那么便可以提前退出了    因为它的dis值不会再更新了
但是注意退出前做好工作                               
如清空堆等等

3.register和手写堆会让其dijkstral速度飞升，不用前两个优化也可以稳稳的AC

4邻接链表的动态分配内存好写且节省空间

5 ~~悄悄打开O2优化~~

6~~SPFA在随机图跑的飞快~~

速度316ms 是dijkstral里面跑的快的了
```cpp
#include<bits/stdc++.h>
using namespace std;
struct note{
	int end;int w;struct note *next;
};struct note edge[10001];int n,m,s,a,b,c,xie;bool sign[10001];int fi[10001];int fi2[10001];
long long dis[10001];
struct opp{
	int data;int sp;
};struct opp disd[100001];int end=0;
void pushin(int data,int sp){register int k=++end;disd[k].data=data;disd[k].sp=sp;
    while(k>0){
    	if(disd[k].data<disd[k>>1].data){swap(disd[k],disd[k>>1]);k>>=1;}
    	else{break;}
	}
}
void pop(){swap(disd[1],disd[end]);end--;
for(register int i=1,j=2;j<=end;i=j,j=i*2){
	if(j+1<=end&&disd[j+1].data<disd[j].data){j++;}
	if(disd[j].data<disd[i].data){
	swap(disd[j],disd[i]);}
	else{break;}
}}
void dj(int x){sign[x]=1;if(x==n&&dis[n]>xie){while(end>0){pop();};return;};
	for(struct note *l=edge[x].next;l!=NULL;l=l->next){
	if(l->w+dis[x]<dis[l->end]&&!sign[l->end]){dis[l->end]=dis[x]+l->w;pushin(dis[l->end],l->end);}	
	}
	while(end>0){
	if(sign[disd[1].sp]){pop();}
	else{dj(disd[1].sp);break;}
	}
}
void solve(int l,int r){if(l==r){cout<<fi2[l]<<endl;return;};
    int mid=fi2[(l+r)>>1],midx=(l+r)>>1;
	for(register int i=1;i<=n;i++){
	dis[i]=2147483647;sign[i]=0;}dis[1]=0;
	for(register int i=1;i<=n;i++){
	if(fi[i]>mid){sign[i]=1;}}
	dj(1);
	if(dis[n]<=xie){solve(l,midx);}
	else{solve(midx+1,r);}
}
inline int read(){
   int s=0,passd=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')passd=-1;ch=getchar();}
   while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
   return s*passd;
}
int main(){cin>>n>>m>>xie;int top;
	for(register int i=1;i<=n;i++){
	edge[i].next=NULL;dis[i]=2147483647;cin>>fi[i];fi2[i]=fi[i];}dis[1]=0;
for(int i=1;i<=m;i++){
a=read();b=read();c=read();struct note *l=(note *)malloc(sizeof(note));
l->end=b;l->w=c;
l->next=edge[a].next;
edge[a].next=l;
l=(note *)malloc(sizeof(note));
l->end=a;l->w=c;
l->next=edge[b].next;
edge[b].next=l;
}; 
    for(register int i=1;i<=n;i++){
	dis[i]=2147483647;sign[i]=0;}dis[1]=0;dj(1);
	if(dis[n]>xie){cout<<"AFK"<<endl;return 0;}
	sort(fi2+1,fi2+n+1);
    solve(1,n);
	return 0;
}
```

---

## 作者：老卡手机 (赞：0)

## ~~本题的难点在于理解题意~~
找出模型后傻傻套算法就可以了

#### 稍微解释一下
## 1. 题目里每条边的伤害即为这条边的长度，如果最短路的长度还是超过血量就说明怎么走都会被打死，即无解

## 2.每个点的收费为限制条件。既然要求我们求最大收费的最小值，很自然想到二分（一般用二分解决最小值最大问题）收费。因为路程一定会经过起点和终点，所以二分左边界l=max（f[1],f[n])，二分右边界为所有f中的最大值。

##### 于是我们可以用dijkstra（k）表示每个点的收费最大为k（超过k就跳过）时能否求出从起点到终点的最短路，且路程小于血量。并更新l或r。

下面上代码。我用链式前向星存图，dijkstra实行最短路，并将它分装结构体中

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <queue>
#include <ctime>
#define INF 1000000000
#define maxn 10000+5
#define maxm 100000+5//数组要开边数的两倍，因为每条边要存两次
using namespace std;
typedef long long ll;

struct Edge
{
	int to,next,cost;
	Edge()//构造函数
	{
		this->cost=this->to=0;
		this->next=-1;
        //如果从0开始存边，一定要将next初始化为-1.否则遍历出边时会引起无限循环
	}
};

struct heapnode//优先队列的结构体
{
	int d,u;//d为最短路距离，u为节点编号
	bool operator < (const heapnode& b)const//d值小的优先级大
	{
		return d>b.d;
	}
};
struct Dijkstra
{
	int n,m,end,s,b,tot;
	int d[maxn],head[maxn],f[maxn];;
	bool v[maxn];
	Edge edges[maxm];
	
	void init(int n,int m,int b)
	{
		this->tot=0;
		this->n=n;
		this->m=m;
		this->b=b;
		this->s=1;
		this->end=n;
	}
	
	void add(int u,int v,int c)
	{
		edges[++tot].to=v;
		edges[tot].cost=c;
		edges[tot].next=head[u];
		head[u]=tot;
	}
	
	bool dijkstra(int k)//节点f值不能超过k
	{
		priority_queue<heapnode> q;
        //注意，由于多次调用dijkstra，所以一定要记得初始化
		memset(d,0x3f,sizeof(d));
		memset(v,0,sizeof(v));
		d[s]=0;
		q.push((heapnode){0,s});
		while(!q.empty())
		{
			heapnode x=q.top();q.pop();
			int u=x.u;
			if(v[u]) continue;
			v[u]=1;
			for(int i=head[u];i!=-1;i=edges[i].next)
			{
				Edge &e=edges[i];
                //声明一个e来取代edges[i].对e的每一个操作其实都实在对edges[i]进行操作
                //这样做的好处在于像出现edges[i][j][k][l][m][n]这样很长的变量时可以使得代码显得简洁
				if(d[e.to]>d[u]+e.cost&&f[e.to]<=k)//松弛操作，f>k就跳过
				{
					d[e.to]=d[u]+e.cost;
					q.push((heapnode){d[e.to],e.to});		
				}
			}
		}
		if(d[end]>b) return false;//如果找不到最短路或最短路大于血量，失败
		return true;
	}
}solve;
int main()
{
	freopen("in.txt","r",stdin);
	ios::sync_with_stdio(false);

	int n,m,b;
	cin>>n>>m>>b;
	solve.init(n,m,b);
	
	int u,v,c; 
	
	for(int i=1;i<=n;i++)
	cin>>solve.f[i];
	
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v>>c;
		if(u==v) continue;//跳过自环
		solve.add(u,v,c);
		solve.add(v,u,c);
	}
	
    //注意，要特判一下dijkstra（INF），k值无穷大即没有限制，跑一遍所有点的最短路，如果这样都无解就说明无论如何都走不到
	if(!solve.dijkstra(INF))
	{
		cout<<"AFK";return 0;
	}
	int l=max(solve.f[1],solve.f[n]),r=1000000000;//懒得找r直接从最大值开始
	while(l<=r)//如果写l<r有时会有一个值被跳过，但超水数据只有最后一个点会错
	{
		int m=(l+r)>>1;
		if(solve.dijkstra(m)) r=m-1;

		else l=m+1;
        //这里我一定要吐槽一下数据有多水。我一开始写成了l=r+1，居然对了7个点？？？还是在忘记特判的情况下（黑人问号脸）
	}
	cout<<l;
    return 0;
}
```
NOIP就快到了，祝各位神犇考场全AK（笑~）

---

## 作者：封禁用户 (赞：0)

####来一发pas题解，

其实也没什么特别的，pascal的题解楼下也有，但突发奇想试了试LLL和SLF优化，得到了意想不到的效果

![](https://cdn.luogu.com.cn/upload/pic/10257.png)

就是这样，单用SLF直接10000ms超时 T了六个点（QAQ）

这告诉我们：SLF和LLL都是很优（xuan）秀（xue），网上有说SLF比LLL稳的，也有说LLL优化给力，但一般情况（数据较小裸SPFA也可以过）时，建议还是摸一把鱼。（>\_>）

####另外安利一下SLF和LLL

SLF 设\_当前\_队头节点为U，要插入的节点为V

若dis[v]>dis[u]则加入队尾，否则加入队头

```cpp
while head<=tail do
  begin
    u:=q[head];
    inc(head);
    v:=h[u];
    vis[u]:=false;
   while v<>0 do
      begin
        tmp:=e[v].t;
        if (dis[tmp]>dis[u]+e[v].w)then
        begin
          dis[tmp]:=dis[u]+e[v].w;
          if not vis[tmp] then
          begin
            vis[tmp]:=true;
            if (head=tail)or(dis[tmp]>dis[q[head]])then
            begin 
              inc(tail);
              q[tail]:=tmp;
            end
            else begin 
            head:=head-2;
            q[head+1]:=tmp;
            end;{插入队头的操作，因为head=1必定不可能进行如上情况。只有head>1才有如上情况 我们先把head-2，因为当前队头为        head，下一次+1就到了head-1了然后j放在head-1上}
          end;
        end;
        v:=e[v].next;
      end;
  end;
end;
```
为什么呢？因为j比i更有可能是最短路的一个点
LLL：
我们可以算出所有队列（head~tail)）的元素的dis值的和，然后求出平均数

如果当前的队头i的dis值比这个平均值大，也就是说，后面有存在比这个点更加有可能为最短路的值

那么把队头的数放到队尾

每次如此，知道有一个小于等于平均值

```cpp
 while head<=tail do
  begin
    u:=q[head];
    inc(head);
    v:=h[u];
    vis[u]:=false;
    dec(tot);
    dec(sum,dis[u]);
    while v<>0 do
      begin
        tmp:=e[v].t;
        if (dis[tmp]>dis[u]+e[v].w)then
        begin
          dis[tmp]:=dis[u]+e[v].w;
          if not vis[tmp] then
          begin
            vis[tmp]:=true;
            if (head=tail)or(dis[tmp]*tot<=sum)
            then
              begin inc(tail);q[tail]:=tmp;end
            else begin 
              head:=head-2;
              q[head+1]:=tmp;
              end;
            inc(tot);
            inc(sum,dis[tot]);
          end;
        end;
        v:=e[v].next;
      end;
  end;
```
最后给出AC代码（slf和lll都用了）用邻接矩阵打的，（想到这里不禁羡慕c++，不知在pas的坑里还能躺多久）


```cpp
const inf=$3f;
type arr=record
     t,next,w:longint;
end;
var  i,n,m,hp,cnt,ans,l,r,mid,u1,v,w:longint;
     e:array[0..500000] of arr;
     q,h,dis,u,f:array[-1..100000] of longint;
     vis:array[0..100000] of boolean;
procedure add(u,v,w:longint);
begin
  inc(cnt);
  e[cnt].t:=v;
  e[cnt].next:=h[u];
  e[cnt].w:=w;
  h[u]:=cnt;
end;
function spfa(top:longint):boolean;
var head,tail,tmp,u,tot,sum,v:longint;
begin
  fillchar(dis,sizeof(dis),$3f);
  fillchar(vis,sizeof(vis),false);
  fillchar(q,sizeof(q),0);
  head:=1;tail:=1;    tot:=1;
  q[head]:=1;vis[1]:=true;dis[1]:=0;
  while head<=tail do
  begin
    u:=q[head];
    inc(head);
    v:=h[u];
    vis[u]:=false;
    dec(tot);
    dec(sum,dis[u]);
    while v<>0 do
      begin
        tmp:=e[v].t;
        if (dis[tmp]>dis[u]+e[v].w)and(f[tmp]<=top)then
        begin
          dis[tmp]:=dis[u]+e[v].w;
          if not vis[tmp] then
          begin
            vis[tmp]:=true;
            if (head=tail)or(dis[tmp]>dis[q[head]])or(dis[tmp]*tot<=sum)
            then
              begin inc(tail);q[tail]:=tmp;end
            else begin head:=head-2;q[head+1]:=tmp;end;
            inc(tot);inc(sum,dis[tot]);
          end;
        end;
        v:=e[v].next;
      end;
  end;
  if dis[n]<=hp then exit(true) else exit(false);
end;
procedure sort(l,r:longint);
var i,j,t,m:longint;
begin
  i:=l;j:=r;m:=u[(i+j)div 2];
  repeat
    while u[i]<m do inc(i);
    while u[j]>m do dec(j);
    if i<=j then
    begin
      t:=u[i];u[i]:=u[j];u[j]:=t;
      inC(i);dec(J);
    end;
  until I>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;
begin
  readln(n,m,hp);
  for i:=1 to n do READln(f[i]); u:=f;
  //for i:=1 to n do writeln(u[i]);
  for i:=1 to m do
    begin
      readln(u1,v,w);
      add(u1,v,w);
      add(v,u1,w);
    end;
  sort(1,n);
  if not spfa(2000000005)  then begin writeln('AFK');exit;end;
  l:=1;r:=n;
  while l<=r do
  begin
    mid:=(l+r) div 2;
    if spfa(u[mid]) then begin ans:=u[mid]; r:=mid-1 end
      else l:=mid+1;
  end;
  writeln(ans);
end.

```

---

## 作者：zzszzs (赞：0)

//洛谷p1462 通往奥格瑞玛的道路  https://www.luogu.org/problemnew/show/P1462




















```cpp
//思路：
//构图（前向星，某些点可能无边）
//对城市按费用为关键字排序（Fee[1]编号 Fee[2]费用）
//删除起点终点相同的较长边
//尝试从1走到n，无法抵达则结束
//二分答案序号，尝试可否抵达（最短路有更改）
program xx;
  const
    MaxN=10005;
    MaxM=50005;
  var
    n,m,b,l,r:longint;
    u,v,w:array [1..2*MaxM] of longint;   //边的起点、终点、权值
    Fee:array [1..3,1..MaxN] of longint;  //Fee[3] 为题目数据的复制值
    f,d:array [1..MaxN] of longint;           //f 前向星的边区间标记  d SPFA中的dist值
    Edge_Delete:array [1..2*MaxM] of boolean; //标记是否为较长的重边
  function max(a,b:longint):longint;
    begin if a>b then exit(a) else exit(b); end;
  procedure Swap(var a,b:longint);
    var t:longint;
    begin t:=a;a:=b;b:=t; end;
  procedure SortEdge(l,r:longint);
    var i,j,k,m,tmp:longint;
    begin
      i:=l;j:=r;m:=u[(i+j) div 2];tmp:=v[(i+j) div 2];
      repeat
        while (u[i]<m) or ((u[i]=m) and (v[i]<tmp)) do inc(i);
        while (u[j]>m) or ((u[j]=m) and (v[j]>tmp)) do dec(j);
        if i<=j then
          begin
            swap(u[i],u[j]);
            swap(v[i],v[j]);
            swap(w[i],w[j]);
            inc(i);
            dec(j);
          end;
      until i>j;
      if i<r then SortEdge(i,r);
      if l<j then SortEdge(l,j);
    end;
  procedure SortCity(l,r:longint);
    var i,j,k,m,tmp:longint;
    begin
      i:=l;j:=r;m:=Fee[2,(i+j) div 2];tmp:=Fee[1,(i+j) div 2];
      repeat
        while (Fee[2,i]<m) or ((Fee[2,i]=m) and (Fee[1,i]<tmp)) do inc(i);
        while (Fee[2,j]>m) or ((Fee[2,j]=m) and (Fee[1,j]>tmp)) do dec(j);
        if i<=j then
          begin
            swap(Fee[1,i],Fee[1,j]);
            swap(Fee[2,i],Fee[2,j]);
            inc(i);
            dec(j);
          end;
      until i>j;
      if i<r then SortCity(i,r);
      if l<j then SortCity(l,j);
    end;
  procedure Mark;
    var i,Pointer:longint;
    begin
      f[1]:=1;Pointer:=1;
      for i:=1 to 2*m-1 do
       if (u[i]<>u[i+1]) and (u[i+1]<>0) then
        f[u[i+1]]:=i+1;
    end;
  procedure DeleteLongerEdge;
    var i,j,k,tmp,val:longint;
    begin
      fillchar(Edge_Delete,sizeof(Edge_Delete),false);
      for i:=1 to 2*m do
       if (u[i]=u[i+1]) and (v[i]=v[i+1]) then
         begin
           tmp:=i;val:=w[i];
           j:=i+1;
           while (u[j+1]=u[i]) and (v[j+1]=v[i]) do inc(j);
           for k:=i to j do
            if w[k]<val then
             begin
               tmp:=k;
               val:=w[k];
             end;
           for k:=i to j do
            if k<>tmp then Edge_Delete[k]:=true;
         end;
   end;
  procedure SPFA(MaxFee:longint);
    var
      h:array [1..5*MaxN] of longint;
      visit:array [1..MaxN] of boolean;
      s,t,i:longint;
    begin
      fillchar(h,sizeof(h),0);
      fillchar(visit,sizeof(visit),false);
      fillchar(d,sizeof(d),127);
      s:=1;t:=1;h[1]:=1;visit[1]:=true;d[1]:=0;
      while s<=t do
        begin
          for i:=f[h[s]] to f[h[s]+1]-1 do
           if (not Edge_Delete[i]) and (Fee[3,v[i]]<=MaxFee) then
            if (d[h[s]]+w[i]<d[v[i]]) then
              begin
                d[v[i]]:=d[h[s]]+w[i];
                if not visit[v[i]] then
                  begin
                    visit[v[i]]:=true;
                    inc(t);
                    h[t]:=v[i];
                  end;
              end;
          visit[h[s]]:=false;
          inc(s);
        end;
    end;
  function FirstEdgeNum(u:longint):longint;
    begin exit(f[u]); end;
  function LastEdgeNum(u:longint):longint;
    begin if f[u+1]=0 then exit(2*m) else exit(f[u+1]-1); end;
  function Check(MaxFee:longint):boolean;
    var i:longint;
    begin
      SPFA(MaxFee);
      if d[n]<b then exit(true) else exit(false);
    end;
  procedure Init;
    var i:longint;
    begin
      read(n,m,b);
      r:=0;
      for i:=1 to n do
        begin
          Fee[1,i]:=i;
          read(Fee[2,i]);
          r:=max(r,Fee[2,i]);
          Fee[3,i]:=Fee[2,i];
        end;
      SortCity(1,n);
      for i:=1 to m do begin read(u[i],v[i],w[i]); end;
      for i:=1 to m do begin u[i+m]:=v[i];v[i+m]:=u[i];w[i+m]:=w[i]; end;
      SortEdge(1,2*m);
      DeleteLongerEdge;
      Mark;
    end;
  procedure Binary;
    var mid:longint;
    begin
      if not check(maxlongint) then
       begin writeln('AFK');halt; end;
      l:=1;r:=n;
      while l<>r do
        begin
          mid:=(l+r) div 2;
          if check(Fee[2,mid]) then r:=mid else l:=mid+1;
        end;
      writeln(Fee[2,l]);
    end;
  begin
    Init;
    Binary;
  end.

```

---

## 作者：Mr_Wolfram (赞：0)

题目中的表述很明显是一道二分答案+最短路的题目，二分收取的费用x判断能否到达奥格瑞玛。检验函数用SPFA跑最短路，注意，费用高于x的点不能使用。


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
const int MAXN=10005,MAXM=50005,INF=0x7fffffff/2;
int read(){
    int rv=0,fh=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') fh=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        rv=(rv<<1)+(rv<<3)+c-'0';
        c=getchar();
    }
    return fh*rv;
}
int n,m,b,fee[MAXN],nume,head[MAXN];
struct egde{
    int to,nxt,kil;
}e[MAXM*2];
void adde(int from,int to,int kil){
    e[++nume].to=to;
    e[nume].nxt=head[from];
    e[nume].kil=kil;
    head[from]=nume;
}
bool chk(int x){
    int dis[MAXN];
    bool f[MAXN]={0};
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++){
        dis[i]=INF;
    }
    dis[1]=0;
    f[1]=1;
    queue <int>spfa;
    spfa.push(1);
    while(!spfa.empty()){
        int u=spfa.front();
        spfa.pop();
        f[u]=0;
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            if(fee[v]<=x&&dis[v]>dis[u]+e[i].kil){
                dis[v]=dis[u]+e[i].kil;
                if(!f[v]){
                    spfa.push(v);
                    f[v]=1;
                }
            }
        }
    }
    if(dis[n]<=b) return 1;
    else return 0;
}
int main(){
    freopen("in.txt","r",stdin);
    n=read();m=read();b=read();
    int l=0,r=0,mid=0;
    for(int i=1;i<=n;i++){
        fee[i]=read();
        r=max(r,fee[i]);
    }
    l=max(fee[1],fee[n]);
    for(int i=1;i<=m;i++){
        int u=read(),v=read(),kil=read();
        adde(u,v,kil);
        adde(v,u,kil);
    }
    if(!chk(r)){
        cout<<"AFK"<<endl;
        return 0;
    }    
    while(l<=r){
        mid=(l+r)>>1;
        if(chk(mid)){
            r=mid-1;
        }else l=mid+1;
    }
    cout<<l;
    fclose(stdin);
    return 0;
}

```

---

## 作者：fy0123 (赞：0)

二分答案+spfa


首先，求最大费用的最小值，那么二分这个最大费用x（由于这个最大费用一定是某一个点的的权值，我们可以把点权排序以后对数组二分，这样会比直接对数二分快一些）。检验的时候需要spfa求最短路，由于已知答案为x，所以spfa时点权超过x的都不能加到队列里去。其余的就是裸地最短路，求出距离如果比血量小就可以，否则不可以。


代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype>
#include<queue>
using namespace std;

const int N = 10010, M = 50010;
const int INF = 1e9;
int n, m, blood, cnt;
int val[N], cost[N], head[N], dis[N];
bool vis[N];

struct Edge{
    int to, nex, v;
}e[2*M];

inline int read()  //读入优化
{
    char ch = getchar(); int x = 0;
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }
    return x;
}

inline void add(int x, int y, int v)  //建边
{
    e[++ cnt].to = y; e[cnt].nex = head[x]; e[cnt].v = v; head[x] = cnt;
}

inline bool check(int x)  //spfa闪亮登场！
{
    queue<int> q;
    q.push(1);
    for (int i = 1; i <= n; i ++){ dis[i] = INF; vis[i] = 0; }  //注意各种初始化别忘写
    if (cost[1] > x) return false;
    dis[1] = 0; vis[1] = 1;
    while (!q.empty()){
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int i = head[u]; i; i = e[i].nex){
            int v = e[i].to;
            if (cost[v] > x) continue;  //这里，由于已知答案为x，所以点权超过x的都不能加到队列里
            if (dis[v] > dis[u] + e[i].v){
                dis[v] = dis[u] + e[i].v;
                if (vis[v]) continue;
                vis[v] = 1;
                q.push(v);
                if (dis[q.front()] > dis[q.back()]) swap(q.front(), q.back());  //spfa的小优化，自行理解~
            }
        }
    }
    return dis[n] < blood;
}

int main()
{
    n = read(); m = read(); blood = read();
    for (int i = 1; i <= n; i ++) val[i] = cost[i] = read();
    for (int i = 1; i <= m; i ++){
        int x, y, z;
        x = read(); y = read(); z = read();
        add(x, y, z); add(y, x, z);
    }
    sort(val+1, val+1+n);  //对点权排序在数组上二分，复杂度logn,不然直接对数二分复杂度有log1e9
    int l = 1, r = n, mid, ans = -1;
    while (l <= r){
        mid = (l+r)/2;
        if (check(val[mid])) ans = val[mid], r = mid-1;
        else l = mid+1;
    }
    if (ans == -1) puts("AFK");  //无法抵达/(ㄒoㄒ)/~~
    else printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Tchaikovsky (赞：0)

再被题面军搞懵一阵子后发现这貌似是一个求最大值最小的问题（还真是）。

哦，找上界嘛，使这个上界在能跑到n点的情况下尽可能的小，当然上界就是f [i] 啦。可以加一个mon数组，排遍序，二分比较方便。

二分答案套模板，把judge换成spfa版，具体看代码，框架是二分答案的架子，主体是spfa。

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#include<cmath>
using namespace std;
queue <int> que;
struct Edge{
    int next;
    int to;
    int key;
}edge[100005];
int cnt=0,head[50001],n,m,b,f[50001],mon[50001],r,l,mid,ans;
long long dis[50001];
bool vis[50001];
int read()
{
    int r=0,k=1;
    char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')k=-1;
    for(;c>='0'&&c<='9';c=getchar())r=r*10+c-'0';
    return r*k;
}
void add(int x,int y,int z)
{
    ++cnt;
    edge[cnt].next=head[x];
    head[x]=cnt;
    edge[cnt].to=y;
    edge[cnt].key=z;
}
bool spfa(int sj)
{
    memset(dis,0x7f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[1]=0;
    vis[1]=1;
    que.push(1);
    while(!que.empty())
    {
        int x=que.front();
        que.pop();
        vis[x]=0;
        for(int i=head[x];i;i=edge[i].next)
        {
            int will=edge[i].to;
            if(f[will]>sj) continue;
            if(dis[x]+edge[i].key<dis[will])
            {
                dis[will]=dis[x]+edge[i].key;
                if(!vis[will])
                {
                    vis[will]=1;
                    que.push(will);
                }
            }
        }
    }
    if(dis[n]>=b||dis[n]==dis[0]) return 0;
    else return 1;
}
int main()
{
    n=read();
    m=read();
    b=read();
    for(int i=1;i<=n;i++) mon[i]=f[i]=read();
    sort(mon+1,mon+1+n);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        x=read();
        y=read();
        z=read();
        add(x,y,z);
        add(y,x,z);
    }
    l=1,r=n;
    if(!spfa(1000000001))
    {
        cout<<"AFK"<<endl;
        return 0;
    }
    while(l<=r)
    {
        mid=(l+r)>>1;//二分金钱 
        if(spfa(mon[mid]))//看看在此情况下，血量是否允许 
        {
            r=mid-1;
            ans=mon[mid];
        }
        else l=mid+1; 
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：Long·J·William (赞：0)

这个题其实可以不用二分。。。

首先用一个SPFA求出那些城市不能到达（即为最少减血量大于总血量的城市）；

然后用一个SPFA求得最小花费；

代码实现

```cpp
#include<cstdio>
#include<cstring>
const int maxn=1e5+10;
const int maxm=1e6+10;
int n,m,hp;
int a,b,c;
int h[maxn],hs=1;
int e_s[maxm],e_n[maxm],e_f[maxm];
inline int max_(int x,int y){return x>y?x:y;}
int q[maxm],head,tail;
int hit[maxn];
bool v[maxn];
void SPFA1(int s){
    memset(hit,0x7f,sizeof(hit));
    hit[s]=0,q[head++]=s;
    while(head>tail){
        a=q[tail++];
        for(int i=h[a];i;i=e_n[i])
        if(0ll+hit[a]+e_f[i]<hit[e_s[i]]){
            hit[e_s[i]]=hit[a]+e_f[i];
            q[head++]=e_s[i];
        }
    }
    for(int i=1;i<=n;i++) if(hit[i]<=hp) v[i]=1;
}
int f[maxn],fee[maxn];
void SPFA2(int s){
    memset(fee,0x7f,sizeof(fee));
    fee[s]=f[s];head=tail=0,q[head++]=s;
    while(head>tail){
        a=q[tail++];
        for(int i=h[a];i;i=e_n[i])
        if(max_(fee[a],f[e_s[i]])<fee[e_s[i]]){
            fee[e_s[i]]=max_(fee[a],f[e_s[i]]);
            q[head++]=e_s[i];
        }
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&hp);
    for(int i=1;i<=n;i++) scanf("%d",&f[i]);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&a,&b,&c);
        ++hs,e_s[hs]=b,e_n[hs]=h[a],e_f[hs]=c,h[a]=hs;
        ++hs,e_s[hs]=a,e_n[hs]=h[b],e_f[hs]=c,h[b]=hs;
    }
    SPFA1(1);
    SPFA2(1);
    if(v[n]) printf("%d\n",fee[n]);
    else puts("AFK");
    return 0;
}
```
我的代码不知道为什么只得了90分，又下不了数据。。。郁闷ing
（博客中可能会补充AC代码）

blog:http://www.cnblogs.com/J-william/p/6850210.html


---


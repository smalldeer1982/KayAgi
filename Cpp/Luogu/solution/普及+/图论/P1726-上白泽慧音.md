# 上白泽慧音

## 题目描述

在幻想乡，上白泽慧音是以知识渊博闻名的老师。春雪异变导致人间之里的很多道路都被大雪堵塞，使有的学生不能顺利地到达慧音所在的村庄。因此慧音决定换一个能够聚集最多人数的村庄作为新的教学地点。

人间之里由 $N$ 个村庄（编号为 $1\cdots N$）和 $M$ 条道路组成，道路分为两种一种为单向通行的，一种为双向通行的，分别用 $1$ 和 $2$ 来标记。如果存在由村庄 $A$ 到达村庄 $B$ 的通路，那么我们认为可以从村庄 $A$ 到达村庄 $B$，记为 $(A,B)$。当 $(A,B)$ 和 $(B,A)$ 同时满足时，我们认为 $A,B$ 是绝对连通的，记为 $\langle A,B\rangle$。绝对连通区域是指一个村庄的集合，在这个集合中任意两个村庄 $X,Y$ 都满足 $\langle X,Y\rangle$。现在你的任务是，找出最大的绝对连通区域，并将这个绝对连通区域的村庄按编号依次输出。若存在两个最大的，输出字典序最小的，比如当存在 $1,3,4$ 和 $2,5,6$ 这两个最大连通区域时，输出的是 $1,3,4$。


## 说明/提示

- 对于 $60\%$ 的数据，$1\le N \le 200$，且 $0\le M \le 10^4$；
- 对于 $100\%$ 的数据，$1\le N \le 5\times 10^3$，且 $0\le M \le 5\times 10^4$。

## 样例 #1

### 输入

```
5 5
1 2 1
1 3 2
2 4 2
5 1 2
3 5 1
```

### 输出

```
3
1 3 5
```

# 题解

## 作者：_H1kar1 (赞：129)

 说在前面：既然是没什么包装的模板题，那么建议大家打细致一些，如果不很清楚，代码量多一些也没关系，一条一条重在理解透彻
 
---
## 好，进入正题：

很明显的一道Tarjan，题解中讲Tarjan的神犇也有很多，但是我自认为还可以多用些图和Markdown将这个算法讲的更清楚些，所以这里重新讲一下Tarjan：

---
## 这里普及基本概念:

* 强连通分量：对于图G来说的一个子图中，任意两个点都可以彼此到达，这个子图就被称为图G的连通分量（一个点就是最小的连通分量）
* 时间戳：搜索到一个点时，这个点将被赋予一个 _唯一_ 的时间量，并且越早搜到的点时间戳越小（当然了） 


Tarjan是一个基于深搜，可以求解图中强连通分量的的算法，基本思想请看图：

在我们对一个图进行深度优先搜索时，走过的边会得到一棵搜索树，搜索树可以看做是原图抛弃了一些边而形成的

这便是一棵搜索树了

![](https://cdn.luogu.com.cn/upload/pic/63447.png)

我们对抛弃掉的边做一个分类，对于这棵树中被还原的原图中的边有三种：

![](https://cdn.luogu.com.cn/upload/pic/63515.png)

* 红色的边-横叉边
* 蓝色的边-前向边
* 绿色的边-后向边

不难发现，横叉边和前向边都无法构成回路，即不能形成大于一个点的强连通分量，所以我们要做的，就是找出重要的后向边来

怎么找后向边呢？你可以回想一下刚才提到的“时间戳”，没错，如果我们搜索到了一个**之前搜过的点，且他当前点的祖先一样，那么毫无疑问的，我们走在了后向边上**

Tarjan算法使用两个数组来维护这个信息：

* dfn[maxn]:储存每个点的时间戳
* low[maxn]:储存每个点访问祖先的能力

什么是访问祖先的能力呢？就是说，这个点最多能走回头路到什么地步，low数组储存的是他能访问到的最早祖先的dfn值，如果这个点没有回头路可走，那low值就是他自己的dfn值咯

好了，说了这么多，相信你已经有一些感觉了，我们来看Tarjan的模板代码：

```cpp
struct edge{
	int x,y,w;
}E[maxm];
int dfn[maxn],low[maxn],tmmk=0;
bool v[maxn];//v数组用来跟踪这个点是否已经处理完毕，我们稍后会见到它的用法 
stack<int> S;
void tarjan(int x)
{
   dfn[x]=low[x]=++tmmk;//每个点在最开始被访问时，时间戳和low值都是一样的 
   S.push(x);
   v[x]=true;
   for(int i=head[x];i;i=next[i])//链式前向星查邻接点 
   {
     int y=E[i].y;//不熟悉的同学请像这样打多一点，有助于理解 
     if(!dfn[y])//dfn的初值都是0，如果这个点没有搜过，就递归搜索 
     {
       tarjan(y);
       low[x]=min(low[x],low[y]);//此时搜索已经回溯，我们可以确定y的low值已经更正，所以用它来更新x的 
     }//因为y在x的后面，所以y能访问到的祖先x一定可以访问到 
     else
       if(v[y])//如果y点搜过了且在栈里，说明我们找到了 后！向！边！ 
          low[x]=min(low[x],dfn[y]);
   }//但是此时我们还不能急着处理，为什么？因为有回溯到根了以后我们在收集到了完整的信息 
   if(dfn[x]==low[x])
   {//dfn和low一样，你就是与众不同的根节点 
      ans++;//ans是强连通分量的个数 
      int y;
      do{
        y=S.top();
        S.pop();
        v[y]=false;
        col[y]=ans;//y点属于编号为ans的强连通分量 
        g[ans].push_back(y);//存下每个强连通分量的成员
      }while(y!=x)//在这里将栈里的点全部倒出来（倒垃圾一样..） 
   }
}
```
---
## 回到题目！

题目要求求出图中最大强连通分量，和其中所有的点

我们可以看出，以上模板中col数组用不着了，存成员还是必要的，但是要求字典序输出，这个向量就不很方便了，我们可以用优先队列解决这个问题

关于优先队列的基本用法可以看我博客，这里关系不很大不做深究qwq

AC代码：不开O2 55ms（偷懒用stl的代价）开O2 35ms

![](https://cdn.luogu.com.cn/upload/pic/63445.png)


```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=6000,maxm=110000;
int n,m;

int read(){
	int x=0;char c=getchar();
	while(c<'0' || c>'9')c=getchar();
	while(c>='0' && c<='9'){
		x=(x<<3)+(x<<1)+(c^'0');
		c=getchar();
	}
	return x;
}

int head[maxn],nxt[maxm],id=0;
struct edge{
	int x,y;
}G[maxm];
void add(int x,int y){
	G[++id].x=x;
	G[id].y=y;
	nxt[id]=head[x];
	head[x]=id;
}

struct pointer{//这是一个指针，p指向连通集编号，siz是他的大小方便排序
	int p,siz=0;
	int diction;//diction是第一个点的编号，如果严格字典序请改成数组
}p[maxn];

int dfn[maxn],low[maxn],col[maxn],
	tmmk=0,cnt=0;
stack<int> S;
priority_queue<int,vector<int>,greater<int> > g[maxn];
bool instk[maxn];
void tarjan(int x){
	dfn[x]=low[x]=++tmmk;
	S.push(x);
	instk[x]=true;
	for(int i=head[x];i;i=nxt[i]){
		int y=G[i].y;
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(instk[y])
			low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		cnt++;
		int y;
		p[cnt].diction=S.top();
		do{
			y=S.top();
			S.pop();
			instk[y]=false;
			col[y]=cnt;
			p[cnt].p=cnt;
			p[cnt].siz++;
			g[cnt].push(y);
		}while(y!=x);
	}
}

bool cmp(pointer a,pointer b){
	if(a.siz!=b.siz)
		return a.siz>b.siz;
	else
		return a.diction<b.diction;
}

int main(){
	n=read(),m=read();
	
	int x,y,f;
	for(int i=1;i<=m;i++){
		x=read(),y=read(),f=read();
		add(x,y);
		if(f==2)
			add(y,x);
	}
	
	memset(dfn,0,sizeof(dfn));
	memset(instk,false,sizeof(instk)); 
	for(int i=1;i<=n;i++)
		if(!dfn[i])
			tarjan(i);
	
	sort(p+1,p+cnt+1,cmp);
	
	printf("%d\n",p[1].siz);
	while(!g[p[1].p].empty()){
		printf("%d ",g[p[1].p].top());
		g[p[1].p].pop();
	}
		
	return 0;
}

```

PS：本题数据略水，题解中有些并没有考虑到一般字典序还A掉的，希望同学们注意。另：我这样做也只考虑第一个数的字典序，如果严格排列把字典diction改成数组即可

PSPS：大半夜写这个挺累的，如果有帮到你，请不要吝惜你的赞（笑）

---

## 作者：TJor (赞：72)

一个神奇的算法，求最大连通分量用O（n）的时间复杂度，真实令人不可思议。

废话少说，先上题目：

题目描述：

给出一个有向图G，求G连通分量的个数。

输入：

n,m，表示G有n个点，m条边

下面m行每行包含 x，y，表示有一条x到y的有向边

输出：

第一个数表示连通分量的个数，第二个数代表最大连通分量

输入示例（如下图）
```
6 8
1 2
1 4
2 3
2 5
3 6
4 5
5 1
5 6
```
![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205113823263-1481367627.png)
输出示例：
```
4
```
很多人会想到DFS，但是时间复杂度为O（n^2），但是时间容易超限，所以我们要用到Tarjan

先理清一下概念：

连通分量：对于图G来的一个子图中，任意两个点都可以彼此到达，这个子图就被称为图G的连通分量（一个点就是最小的连通分量）

最大连通分量：对于图G的一个子图，这个子图为图G的连通分量，且是图G所有连通分量中包含节点数最多的那个，即为G的最大联通分量

时间戳：搜索时第几个搜索到这个点。如搜索顺序是1->2->3->6则6的时间截为4

下面就是tarjan的思路（第一次看不懂可以跳过，直接看详细步骤，回来再看）：

每个点都有两个参数：low，dfn。dfn表示这个点的时间戳，而low代表这个点所能到达的最小的时间戳，开始low都等于dfn，但会经过不断更新而减少。

从1节点进行深度优先搜索，途中用树（一个转化为栈的树）维护。

当遇到一个点时，有如下判断：

1、如果这个点没有访问过，就将这个点加入树（栈）

2、如果这个点访问过，且在树（栈）里，与这个点的low比较，更新自己的low

返回时更新low

当一个点遍历所有的边后这个点的low还是等于dfn，将个点及以上出栈，这个点及栈以上的点构成一个连通分量。

来一点Chinese++（就是伪代码）　　：
```
void tarjan(int 当前点)
{
    这个点的low=dfn=时间戳;
    将这个点入栈;
    标记这个点入栈;
    枚举这个点连接的所有边
    {
        如果目标点没有被访问过
        {
            tarjan(目标点);
            更新当前点的low; 
        }  
        如果目标点被访问过
        {
            更新当前点的low; 
        } 
    }
    如果当前点的low==dfn
    {
        将这个点及栈以上的点出栈，标记成一个强连通分量; 
        ans++; 
    } 
}
```
详细过程：

开启黑暗之门
![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180206091026013-450065277.png)
![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205142158498-579785212.png)
开始，从1节点开始，时间截和low都是1，将1入栈

stack：1,
![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205142303326-599131639.png)
走到2节点，2的时间戳dfn和low都是2,2入栈

stack：1,2
![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205143023310-970015972.png)
以此类推，将3、6入栈，时间戳分别为3、4

stack：1,2,3,6
![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205143101373-723896238.png)

此时，发现6节点遍历了其所有出边（本来就没有）以后，它的low等于dfn，这就说明了6号节点没有路径能回到能到达它的节点，所以6就是一个单独的连通分量，因此将6出栈，再回溯，此时在栈中比6（含）高的点都出栈，这些点构成一个连通分量（因为此时比6在栈顶，所以6是一个单独的连通分量）ans++

stack:1,2,3

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205143121326-1361087440.png)

和刚才一样，3节点的所有出边已经遍历一般，但low还是和dfn相等，所以3出栈，因为此时3在栈顶，所以3是一个单独的连通分量。ans++

stack：1,2

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205143156091-910451534.png)

再次遍历从2遍历到5，将5入栈，并且low和dfn都为5。

stack：1,2,5

然后5搜索到6，但是6不在栈里面，所以不管它

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205150658216-1356454677.png)

这是搜索到了1，发现1的时间戳1小于5的low，所以将5的low更新为1,。这时发现5没有其他边可以走了，所以返回

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205150830935-815793086.png)

返回到2时，发现5的low比2的low小，所以更新2的low为1，继续返回到1

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205150934670-244225981.png)

再从1走到4，4的时间戳和low为6，将4入栈

stack：1,2,5,4　

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205151048185-1202573680.png)

从4走到5，发现5在栈中，且5的low比4的low小，所以4的low变成1，因为没有边再返回到1

此时，1的所有边都走完啦，并且1的low等于dfn，所以把1及以上的节点出栈，构成连通分量，ans++

 继续枚举每一个点，如果这个点的时间戳为0（也就是没有访问过）tarjan(i);

现在贴上代码，但是没有完，我会对原理做详细解释：
```
void tarjan(int u)
{
    in++;
    dfn[u]=in;
    low[u]=in;
    S.push(u);
    vis[u]=1;
    for(int e=head[u];e;e=next[e])
    {
        if(!dfn[to[e]])
        {
            tarjan(to[e]);
            low[u]=min(low[to[e]],low[u]);
        }
        else if(vis[to[e]])
            low[u]=min(low[u],dfn[to[e]]);
    }
    if(low[u]==dfn[u])
    {
        while(!S.empty() && S.top()!=u)
        {
            vis[S.top()]=0;
            S.pop(); 
        } 
        vis[u]=0;
        S.pop();
        ans++;
    }
}
```
演员表：

in:时间戳下标

dfn[i]:i节点的时间戳

low[i]:i所能到达的最小的时间戳

head[i],next[i],to[i]:邻接表群演

vis[i]:i是否在栈里

S：栈

ans:计数

u：当前点

原理详解：

1、其实虽说整个过程都在用栈维护，但是原理却是一颗树，比如当搜索到1、2、3、6时，树是这样的

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205155346998-971934903.png)

你想象成树就好，当我们确定6为一个单独的连通分量的时候，把它咔嚓掉。现在6及以下的节点（这次没有）成为一颗新的树。

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180205155947154-1654961517.png)

然后再用霜之哀伤砍掉3，3及以下节点（也是没有）又变成了一个新的树。

然后我们搜索到5，将5加入树

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180206091418670-9767516.png)

然后再从1搜索到4，加入树

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180206091633466-2116821879.png)

然后返回到1，拔出1节点的霜之哀伤与耐奥祖融合，成为新的巫妖王。

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180206091916670-649011918.png)

![](https://images2017.cnblogs.com/blog/987049/201802/987049-20180206091951295-550994048.png)

---

## 作者：阿蒙 (赞：31)

-----

首先这是tarjan的模板题前面大佬已经说过了；
我想说字典序最小输出的问题

首先每个点的编号都是唯一的
我们先扫一遍记住最大强连通分量的点的个数cnt

然后从按编号小到大扫一遍取第一个所在的强连通分量中的点数==cnt的强连通分量（这个强连通分量一定是所求的，因为这个强连通分量最大且有最小的编号来使字典序最小）

其他的就是模板了

-----
```c++
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;
const int maxn=2e5+7;
const int inf=0x3f3f3f3f;

struct note{
	int to,nex;
}e[maxn*3];

int col,num,head[maxn],dfn[maxn],low[maxn],de[maxn],co[maxn],si[maxn],stk[maxn];
int top,n,m;
int cnt=-1;
void add(int x,int y)
{
	static int cnt=0;
	cnt++;
	e[cnt].to=y;
	e[cnt].nex=head[x];
	head[x]=cnt;
}

void tarjan(int u)
{
	dfn[u]=low[u]=++num;
	stk[++top]=u;
	for(int i=head[u];i;i=e[i].nex)
	{
		int v=e[i].to;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!co[v])low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		co[u]=++col;
		++si[col];
		while(stk[top]!=u)
		{
			++si[col];
			co[stk[top]]=col;
			--top;
		}
		--top;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y,f;
		cin>>x>>y>>f;
		if(f==1)add(x,y);
		if(f==2)add(x,y),add(y,x);
	}
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
	for(int i=1;i<=col;i++)cnt=max(cnt,si[i]);
	cout<<cnt<<endl;
	for(int i=1;i<=n;i++)
	{
		if(si[co[i]]==cnt)
		{
	       int now=co[i]; 
		   for(int j=i;j<=n;j++)if(co[j]==now)cout<<j<<" ";
		   return 0; 
		}
	}
	return 0;
}


```

---

## 作者：moye到碗里来 (赞：13)

裸的一道强连通分量题，对于向我们这种萌新练手很不错，练习tarjan。像我这种lowb就用的最弱的vector存储法，还是过了。手写下栈吧还是，毕竟又不是什么优先队列没必要用stl，反而不方便。我看大家都没有讲tarjan算法啊，我还是讲讲吧（主要是想之后不会写的时候再看看）

tarjan其实很简单，dfn存储搜到的时间，low存储搜到的最早的点，我们对这个图进行构建dfs树，搜到一个点就入栈，当你的dfn==low的时候，以这个点往下建的子树，并且还在栈里的都会在这个强连通分量里，因为强连通分量不会有重叠，所以每个点就只会入一次，而且每次找到的强连通分量必定已经包含了所有点。具体可以去网上搜搜。

这道题就单独开两个变量，一个存当前最大的强连通分量有多少个点，另一个就存当前的有多少个，如果更多就更新。如果一样就比下最小的就行了，最后把那个强连同分量的从小到大输出就行，具体见代码

            
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAX 5000
int c[MAX+10],vis[MAX+10]={0},dfn[MAX+10],low[MAX+10],huan[MAX+10],maxn=0,ltfl=0,mini=100000,mini2=100000;//ltfl=连通分量= =存的哪一个连通分量，c 是否在栈中，vis是否搜过，dfn搜到时间，low他能去到的最早时间，huan在哪个环中，maxn强连通分量中最多有多少个点，mini当前最大强连通分量中最小点，mini2目前搜到的强连通分量最小的点 
int sta[MAX+10],head=0,t=0;//栈    
int n,m;
vector<int>load[50000+10];
void tarjan(int now)
{
    dfn[now]=low[now]=++t;//初始化每一个第一次进搜到的点 
    vis[now]=1;
    int x=load[now].size();
    sta[head++]=now;
    c[now]=1;
    for(int i=0;i<x;i++)//搜图 
    {
        if(vis[load[now][i]]==0)
        {
            tarjan(load[now][i]);
            low[now]=min(low[now],low[load[now][i]]);//他的子树能到达，他也能的 
        }
        else if(c[load[now][i]]==1)
        {
            low[now]=min(low[now],dfn[load[now][i]]);//如果这是一条后向边，那就直接看是否是能到的最小的 
        }
    }
    if(dfn[now]==low[now])
        {
            int y=0;
            mini=100000;
            while(1)
            {
                head--;
                int v=sta[head];
                y++; 
                huan[v]=low[now];
                if(v<mini)
                {
                    mini=v;
                }
                c[v]=0;
                //printf("%d ",v);
                if(now==v)
                {
                //    printf("\n");
                    if(y>maxn)
                    {
                        maxn=y;
                        ltfl=low[now];
                        mini2=mini;
                    }
                    if(y==maxn)
                    {
                        if(mini<mini2)
                        {
                            mini2=mini;
                            ltfl=low[now];
                        }
                    } 
                    break;
                }
            }
        }    
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y,l;
        scanf("%d %d %d",&x,&y,&l);
        load[x].push_back(y);
        if(l==2)
        {
            load[y].push_back(x);
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(vis[i]==0)
        tarjan(i);
    }
    printf("%d\n",maxn);
    for(int i=1;i<=n;i++)
    {
        if(huan[i]==ltfl)
        {
            printf("%d ",i);
        }
    }
}
```

---

## 作者：hl666 (赞：12)

##### **这显然是一道求强连通分量（SCC）的题目。**


只要你正常，都知道应该写Tarjan。

然后（假装会写Tarjan），其实我当然不会。但是求SCC还有另一个算法。复杂度和Tarjan一样，只不过常数大了点而且不为人所知而已。

蓝书和挑战程序竞赛上都有这个算法，好像叫Kosaraju。是不是很拽的感觉。

一些变量名的意义：

a[N] 原图的vector存储

b[N] 原图的所有边反向vector存储

s dfs得出的拓扑序列栈

c[[N] 每个点的SCC编号

算法框架：

1.将原图做一遍类似于拓扑的dfs，越早访问的顶点压在一个栈中。

2.不断从栈顶取出一个未访问过的点，对它的反向图再进行dfs，所有它能到达的未访问过的点就是他的SCC。

3.这样就得到的一个图的SCC。

对于2的正确性，应为这个点必被在栈中比它早入栈的点给压入栈，而且在栈中比它更上面的点已经被访问过，所以它在它下面能找到的点都是他的SCC（同时还避免了重复）

~~对于这道题，很烦的判重对于Kosaraju来说很容易，因为编号越小的点越早进栈，所以满足第一个找到的最大解的字典序一定比后面数量和它相同的点小。~~

2018/08/15Upt：上面的都在扯淡。字典序还是要判的。对于每一个SCC记录一下最后比对即可。

（感谢@[四向搜](https://www.luogu.org/space/show?uid=52200)提供hack数据使得本文错误被指出，目前CODE已重新修改）

重点是这道题就是SCC模板题（不敢相信竟然10分钟一次A了）

CODE

```cpp
    #include<cstdio>
    #include<vector>
    #include<cstring>
    #include<algorithm>
    using namespace std;
    const int N=5005;
    vector <int> a[N],b[N],s,t[N];
    int f[N],i,n,m,x,y,z,ans,num,id,tot;
    inline void read(int &x)
    {
        x=0; char ch=getchar();
        while (ch<'0'||ch>'9') ch=getchar();
        while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    }
    inline void dfs(int k)
    {
        f[k]=0;
        for (int i=0;i<a[k].size();++i)
        if (f[a[k][i]]) dfs(a[k][i]);
        s.push_back(k);
    }
    inline void rdfs(int k)
    {
        f[k]=0;
        t[tot].push_back(k);
        for (int i=0;i<b[k].size();++i)
        if (f[b[k][i]]) rdfs(b[k][i]);
    }
    inline bool cmp(vector <int> a,vector <int> b)
    {
    	for (int i=1;i<a.size();++i) 
        {
            if (a[i]<b[i]) return 1;
            if (a[i]>b[i]) return 0;
        }
    	return 0;
    }
    int main()
    {
        read(n); read(m);
        for (i=1;i<=m;++i)
        {
            read(x); read(y); read(z);
            if (z==1)
            {
                a[x].push_back(y);
                b[y].push_back(x);
            } else
            {
                a[x].push_back(y); a[y].push_back(x);
                b[x].push_back(y); b[y].push_back(x);
            }
        }
        memset(f,true,sizeof(f));
        for (i=1;i<=n;++i)
        if (f[i]) dfs(i);
        memset(f,true,sizeof(f));
        for (i=s.size()-1;i;--i)
        if (f[s[i]]) ++tot,rdfs(s[i]);
        for (i=1;i<=tot;++i)
        {
        	sort(t[i].begin(),t[i].end());
        	if (t[i].size()==t[id].size()&&cmp(t[i],t[id])) id=i;
            if (t[i].size()>t[id].size()) id=i;
        }
        printf("%d\n",t[id].size());
        for (i=0;i<t[id].size();++i) printf("%d ",t[id][i]);
        return 0;
}
```

---

## 作者：Alan0627 (赞：11)

tarjan强联通分量的模板题,noip赛前练手

变量定义及含义如下

(1)、dfn[ ]，表示这个点在dfs时是第几个被搜到的。

(2)、low[ ]，表示这个点以及其子孙节点连的所有点中dfn最小的值

(3)、stack[ ]，表示当前所有可能能构成是强连通分量的点。

(4)、vis[ ]，表示一个点是否在stack[ ]数组中。

注释见代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<stack>
using namespace std;
#define N 1000005
int n,m,low[N],dfn[N],t,tot,all[N],ans,cnt,head[N],sd[N];
stack<int> s;
bool v[N];
struct nod{
	int u,v;
}e[N];
void adde(int u,int v){
	cnt++;
	e[cnt].u=head[u];
	e[cnt].v=v;
	head[u]=cnt;
}
void tarjan(int x){
	t++;
	s.push(x);
	low[x]=dfn[x]=t;
	v[x]=true;
	for(int i=head[x];i;i=e[i].u){
		int y=e[i].v;
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}else if(v[y]){
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(low[x]==dfn[x]){
		tot++;//tot判断是在第几个强联通分量中
		while(1){
			int y=s.top();
			s.pop();
			sd[y]=tot;//sd记录该节点属于哪一个强连通分量
			all[tot]++;//all记录第tot的强联通分量中的节点数
			v[y]=false;
			if(x==y){//注意这个地方要放在while循环的最后
				break;
			}
		}
	}
}
int mian(){//意会
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){//注意n个点，m条边，千万别打反了
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		if(c==1){
			adde(a,b);
		}else{
			adde(a,b);
			adde(b,a);
		}
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i]){
			tarjan(i);
		}
	}
	for(int i=1;i<=tot;i++){
		ans=max(ans,all[i]);//求最大的强连通分量所包含的节点数
	}
	printf("%d\n",ans);
	for(int i=1;i<=n;i++){
		if(all[sd[i]]==ans){//按照字典序从小到大输出，如果i所在的强联通分量的节点数==ans，那么输出
			printf("%d ",i); 
		}
	}
	return 0;
}
```

---

## 作者：devout (赞：8)

看题解里很多大佬都用的是tarjan的做法

因为本蒟蒻刚刚学强连通分量，所以先学的是相对好理解的kosaraju的做法,还不会tarjan...

“kosaraju拼对了吧”

“应该吧...”

确实，这个名字太毒瘤了，反正我背了20遍才背下来

**kosaraju**

这个算法的实现相对于tarjan来说更好理解一点，但是时间复杂度更高，应用范围小，还有可能爆栈

kosaraju也是基于深度优先搜索的算法。这个算法牵扯到两个概念，发现时间st，完成时间et。发现时间是指一个节点第一次被遍历到时的次序号，完成时间是指某一结点最后一次被遍历到的次序号。

我们需要在加边时把有向图正向建造完毕后再反向加边建一张逆图。

先对正图进行一遍dfs，遇到没访问过的点就让其发现时间等于目前的dfs序。在回溯时若发现某一结点的子树全部被遍历完，就让其完成时间等于目前dfs序。正图遍历完后将节点按完成时间入栈，保证栈顶是完成时间最大的节点，栈底是完成时间最小的节点。

（玄学内容开始）然后从栈顶开始向下每一个没有被反向遍历过的节点为起点对逆图进行一遍dfs，将访问到的点记录下来（或染色）并弹栈，每一遍反向dfs遍历到的点就构成一个强连通分量。虽然不知道为什么但他就成强连通分量了...

真的非常的玄学...

**dfs1**

第一个dfs

``` cpp
inline void pst_dfs(int u){
	dfn++;
	vis[u]=true;
	for(int i=head[1][u];i;i=e[1][i].next)
	  if(!vis[e[1][i].to])pst_dfs(e[1][i].to);
	lst[2*n+1-(++dfn)]=u;
}
```

那个处理栈是一个非常玄学的问题..难道不是吗？

**dfs2**

第二个dfs

```cpp
inline void neg_dfs(int u){
	num[u]=scc;
	size[scc]++;
	vis[u]=false;
	for(int i=head[2][u];i;i=e[2][i].next)
	  if(vis[e[2][i].to])neg_dfs(e[2][i].to);
}
```

这个我觉得比第一个要好理解一点

AC代码：

```cpp
# include <cstdio>
# include <algorithm>
# include <cstring>
# include <cmath>
# include <climits>
# include <iostream>
# include <cstring>
# include <queue>
# include <vector>
# include <set>
# include <map>
# include <cstdlib>
# include <stack>
# include <ctime>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define mct(a,b) memset(a,b,sizeof(a))
# define gc getchar()
typedef long long ll;
const int N=5e5+5;
const int inf=0x7fffffff;
inline int read(){
    int s=0,w=1;
    char c=gc;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=gc;}
    while(c>='0'&&c<='9')s=s*10+c-'0',c=gc;
    return s*w;
}
struct Edge{
	int to,next;
}e[3][N];
int n,m;
int cnt[3],head[3][N],scc,dfn,size[N],num[N],lst[2*N];
bool vis[N];
inline void add(int x,int y,int c){
	e[c][++cnt[c]]=(Edge){y,head[c][x]},head[c][x]=cnt[c];
}
inline void pst_dfs(int u){
	dfn++;
	vis[u]=true;
	for(int i=head[1][u];i;i=e[1][i].next)
	  if(!vis[e[1][i].to])pst_dfs(e[1][i].to);
	lst[2*n+1-(++dfn)]=u;
}
inline void neg_dfs(int u){
	num[u]=scc;
	size[scc]++;
	vis[u]=false;
	for(int i=head[2][u];i;i=e[2][i].next)
	  if(vis[e[2][i].to])neg_dfs(e[2][i].to);
}
inline void kosaraju(){
	Rep(i,1,n)if(!vis[i])pst_dfs(i);
	Rep(i,1,2*n)if(lst[i]&&vis[lst[i]])scc++,neg_dfs(lst[i]); 
}
int main()
{
	n=read(),m=read();
	Rep(i,1,m){
		int x,y,c;
		x=read(),y=read(),c=read();
		add(x,y,1),add(y,x,2);
		if(c==2)add(y,x,1),add(x,y,2);
	}
	kosaraju();
	int ans=-1,Std;
	Rep(i,1,n)if(size[num[i]]>ans)ans=size[num[i]],Std=i;
	printf("%d\n",ans);
	Rep(i,1,n)if(num[i]==num[Std])printf("%d ",i);
	puts("");
	return 0;
}
```


---

## 作者：米奇奇米 (赞：7)

### 这是一题$tarjan$算法的练手好题，从题目里就能读出$tarjan$即将降临

### 在做这题之前先要熟悉$tarjan$的模板，我先放一下模板：
### 明确一下**强联通**的概念：如果$u$与$v$之间互相有一条边连向对方那么就把$u,v$认为是强联通的，对于一个图来说，任意两个点之间都能到达，那么这个图是强连通的
#### $dfn[ ]$表示点$u$被搜到的时间戳
#### $low[ ]$表示为$u$或$u$的子树能够追溯到的最早的栈中节点的次序号 
#### $stak[ ]$用数组模拟一个栈，表示此时是否存在某对父子关系
```cpp
inline void tarjan(int u) {
	dfn[u]=low[u]=++now;
	stak[++top]=u;
	for ( register int i=head[u];i;i=e[i].nex ) {
		int v=e[i].to;
		if(!dfn[v]) {//如果节点v还未被访问到
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!col[v]) low[u]=min(low[u],dfn[v]);
      //如果节点v还在栈里或者不属于任何强连通分量
	}
	if(low[u]==dfn[u]) {
		col[u]=++sum;
		siz[sum]++;
		while(stak[top]!=u) {
			col[stak[top]]=sum;
			siz[sum]++;
			top--;
		}
		top--;
	}
}
```
### 对于连边分两种情况讨论用前向星连边即可：
```cpp
inline void add(int u,int v) {
	e[++cnt].nex=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
```
### 我不太用$vector$来存，常数太大了。

### 回归于这道题目，题目就很清新，求最大的强连通分量，以及里边点的编号，我的写法很奇怪（对于对第二问作答的过程），后来发现不用这么麻烦的啦！那就上代码了：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e3+5,M=5e4+5;

struct node {
	int nex,to;
}; node e[M];
int head[N],low[N],dfn[N],col[N],siz[N],num[N];
int stak[N],n,m,type,cnt,now,sum,top,MAX,ans;

inline void add(int u,int v) {//前向星连边
	e[++cnt].nex=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}

inline void tarjan(int u) {//tarjan模板
	dfn[u]=low[u]=++now;
	stak[++top]=u;
	for ( register int i=head[u];i;i=e[i].nex ) {
		int v=e[i].to;
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!col[v]) low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]) {
		col[u]=++sum;
		siz[sum]++;
		while(stak[top]!=u) {
			col[stak[top]]=sum;
			siz[sum]++;
			top--;
		}
		top--;
	}
}

int main() {
	scanf("%d%d",&n,&m);
	for ( register int i=1;i<=m;i++ ) {
		int u,v;
		scanf("%d%d%d",&u,&v,&type);
		if(type==1) add(u,v);
		if(type==2) add(u,v),add(v,u);
	}
	for ( register int i=1;i<=n;i++ ) if(!dfn[i]) tarjan(i);
	for ( register int i=1;i<=sum;i++ ) MAX=max(MAX,siz[i]);
	for ( register int i=1;i<=n;i++ ) {
		num[col[i]]++;
		if(num[col[i]]>ans) ans=num[col[i]];
	}
	printf("%d\n",MAX);
	for ( register int i=1;i<=n;i++ ) if(num[col[i]]==ans) printf("%d ",i);
	return 0;
}
	 
```
### 对于$tarjan$模板练手有不少题目：
#### [tarjan+拓扑 P3387 【模板】缩点](https://www.luogu.org/problemnew/show/P3387)
#### [P2746 [USACO5.3]校园网Network of Schools](https://www.luogu.org/problemnew/show/P2746)
#### [P2341 [HAOI2006]受欢迎的牛](https://www.luogu.org/problemnew/show/P2341)
### 这些都是比较简单的$tarjan$练手题，其实建议可以去学一下$2-SAT$。右拐见[P4782 【模板】2-SAT 问题](https://www.luogu.org/problemnew/show/P4782)

---

## 作者：Forward_Star (赞：5)

涉及到了tarjan和链式前向星，我把我博客中的题解粘在这里。

（http://blog.csdn.net/weixin\_39872717/article/details/78492476）

这题是一道求强连通分量的模板题，用tarjan算法套上去就可以了（http://blog.csdn.net/weixin\_39872717/article/details/78472910）。

首先理解什么是强连通分量，简单来说，可以相互连通的区域成为强连通分量；若是u能到达v且v能到达u，且u，v与其它结点不能相互连通，则{u,v}是一个强连通分量。

谈谈我对tarjan的理解，图解过程详见：http://www.cnblogs.com/shadowland/p/5872257.html，解释得真的很好。

tarjan基于深搜，首先定义一个栈用于存储结点，在深搜的过程中，结点进栈，DFN[i]表示第i结点是第几个被遍历的（或者说是第几个进栈的）；

LOW[i]表示第i结点及i所在的子树可追溯到的最早进栈的结点的进栈次序，若拓展结点时找到了在栈中的结点，则更新LOW取较小的值；

回溯时，若DFN[i]==LOW[i]，则i结点到栈顶结点所有结点为同一强连通分量。

详见代码：

void tarjan(int now) //用链式前向星存图实现的tarjan

```cpp
    {  
        dfn[now]=++t;  
        low[now]=t;  
        flag[now]=true; //flag表示是否被访问过  
        stack[++top]=now;  
        int k=top;   
        int u=head[now];  
        while (u!=0)  
        {  
            if (!flag[edge[u].to]) tarjan(edge[u].to);  
            if (!del[edge[u].to]) low[now]=min(low[now],low[edge[u].to]); //del表示是否在栈中，为false，说明edge[u].to未被归到强连通分量里，那么这两个点必定互相连通（可画图证明）   
            u=edge[u].next;  
        }  
        if (dfn[now]==low[now]) //满足该条件，则当前点一直到栈顶点已经构成一个强连通分量   
        {  
            for (int i=k;i<=top;i++) del[i]=true; //出栈  
            if (top-k+1>ans) //此程序为取最大结点数最小字典序的强连通分量  
            {  
                ans=top-k+1;  
                for (int i=k;i<=top;i++) que[i-k+1]=stack[i];  
                sort(que+1,que+top-k+1+1,cmp); //stl库排序，终止点为数列长度+1   
            }   
            else if (top-k+1==ans)  
            {  
                for (int i=k;i<=top;i++) comparison[i-k+1]=stack[i];  
                sort(comparison+1,comparison+top-k+1+1,cmp);  
                if (comparison[1]<que[1])  
                    for (int i=1;i<=ans;i++)  
                        que[i]=comparison[i];  
            }  
            top=k-1; //出栈  
        }   
    }  
```
由于数据规模较大，建议用链式前向星存图（http://blog.csdn.net/weixin\_39872717/article/details/78483849）
一般的前向星是经过排序将相同起点的边放在一起，并记录每个点对应的边的起始位置与终止位置，不展开讲述。

链式前向星则不用排序，首先定义数组edge，记录每条边的信息，则读入第i条边的信息：从u到v权值为w的边时，edge[i].to负责记录这条边的终点，edge[i].w负责记录这条边的边权，那么怎么记录起点呢？这里就用到了edge[i].next与head[u]。edge[i].next，是类似于递归的方式调用边，如：

第1、3、5条边记录的是起点为1的边的信息，则：edge[1].next=0,edge[3].next=1,edge[5].next=3；调用的时候，用完第5条边，就通过edge[5].next到第3条边，最后到第1条边，终止；

head[u]则记录以结点u为起点编号最大的边，在上述情况中，head[1]=5；则要调用以1为起点的点，从head[1]开始调用就可以了。

如何实现？

读入后，若head[u]=0，则edge数组中没有以该点为起点的边，那么edge[i].next=0；若head[u]!=0，则edge[i].next=head[u]，head[u]=i；

具体例子分析请看http://blog.csdn.net/acdreamers/article/details/16902023。


代码：

```cpp
    #include<cstdio>  
    #include<algorithm>  
    using namespace std;  
        struct forward_star  
        {  
            int to,next;  
        };  
        int n,m,cnt,t,top,ans; //cnt表边数，t表遍历的序号   
        bool del[5001],flag[5001]; //del数组判断某个点是否在一个强连通分量中，flag表示是否遍历过   
        int head[5001],stack[5001],dfn[5001],low[5001],que[5001],comparison[5001];  
        forward_star edge[100001];  
    void add(int u,int v)  
    {  
        edge[++cnt].to=v;  
        edge[cnt].next=head[u];  
        head[u]=cnt;  
    }  
    bool cmp(int i,int j)  
    {  
        return i<j;  
    }  
    void tarjan(int now)  
    {  
        dfn[now]=++t;  
        low[now]=t;  
        flag[now]=true;  
        stack[++top]=now;  
        int k=top;   
        int u=head[now];  
        while (u!=0)  
        {  
            if (!flag[edge[u].to]) tarjan(edge[u].to);  
            if (!del[edge[u].to]) low[now]=min(low[now],low[edge[u].to]); //del为false，说明edge[u].to未被归到强连通分量里，那么这两个点必定互相连通（可画图证明）   
            u=edge[u].next;  
        }  
        if (dfn[now]==low[now]) //满足该条件，则当前点一直到栈顶点已经构成一个强连通分量   
        {  
            for (int i=k;i<=top;i++) del[stack[i]]=true;  
            if (top-k+1>ans)  
            {  
                ans=top-k+1;  
                for (int i=k;i<=top;i++) que[i-k+1]=stack[i];  
                sort(que+1,que+top-k+1+1,cmp); //stl库排序，终止点为数列长度+1   
            }   
            else if (top-k+1==ans)  
            {  
                for (int i=k;i<=top;i++) comparison[i-k+1]=stack[i];  
                sort(comparison+1,comparison+top-k+1+1,cmp);  
                if (comparison[1]<que[1])  
                    for (int i=1;i<=ans;i++)  
                        que[i]=comparison[i];  
            }  
            top=k-1;  
        }   
    }  
    int main()  
    {  
        scanf("%d%d",&n,&m);  
        for (int i=1;i<=m;i++)  
        {  
            int u,v,type;  
            scanf("%d%d%d",&u,&v,&type);  
            add(u,v);  
            if (type==2) add(v,u);  
        }  
        for (int i=1;i<=n;i++)  
            if (!del[i])  
                tarjan(i);  
        printf("%d\n",ans);  
        for (int i=1;i<=ans;i++)  
            printf("%d ",que[i]);  
        return 0;  
}
```

---

## 作者：KaisuoShutong (赞：2)

### 非常intresting的一道题
又是一道裸的
~~太监~~
不
tarjan的题


模版题坑了我好久，幸好有crn大佬的帮助改错，才救我于苦海之中~~~   感谢感谢---

tarjan几次，然后找最大入度的连通块，输出，ok。



贴代码贴代码：

```cpp
#include<iostream>
using namespace std;
int cnt,chuo=0,n,m,dfn[5001],low[5001],st,a[5001][5001],maxx,bjbj;
int bj[5001],zhan[5001],meat,ment[5001],rd[5001];
void tarjan(int v)
{
	dfn[v]=low[v]=++chuo;
	bj[v]=1;zhan[++st]=v;
	for(int i=1;i<=n;i++)
	if(a[v][i])
	{
		if(!dfn[i])
		{
			tarjan(i);
			low[v]=min(low[v],low[i]);
		}
		else if(bj[i]) low[v]=min(low[v],dfn[i]);
	}
	if(dfn[v]==low[v])
	{
		meat++;
		int y;
		do
		{
			y=zhan[st--];
			bj[y]=0;
			ment[y]=meat;
		}
		while(y!=v);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		if(z==1) a[x][y]=z;
		else a[x][y]=a[y][x]=z;
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	for(int i=1;i<=n;i++) rd[ment[i]]++;
	for(int i=1;i<=meat;i++)
		if(rd[i]>maxx) maxx=rd[i],bjbj=i;
	cout<<maxx<<endl;
	for(int i=1;i<=n;i++)
		if(ment[i]==bjbj) cout<<i<<" ";
	return 0;
}
```



P.S.crn大佬用了HEAP，其实不需要啦~~- -

---

## 作者：刘备 (赞：2)

我就说怎么找不到tarjan求有向图强连通分量模板，终于找到了qwq

然而这一题其实并不用去管字典序。。

还有，这个算法的中文叫做**塔扬算法**，不是**塔尖**！！因为tarjan不是英文!!


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<stack>
#include<algorithm>
#define N 5010
#define M 50010 
using namespace std;
int fst[N],dfn[N],low[N],list[N],gett[N];//gett表示各强连通分量的节点数，list是每个点所对应的强联通分量
int nxt[M],u[M],v[M];
bool ins[N];//表示节点是否在栈中
stack<int>s;
int n,m,cnt,tot,num;
int read()
{
    int ans=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') 
    {
        ans=ans*10+ch-'0';
        ch=getchar();
    }
    return ans;
}
void add(int p,int q)
{
    u[++cnt]=p; v[cnt]=q;
    nxt[cnt]=fst[u[cnt]];
    fst[u[cnt]]=cnt;
    return;
}
void dfs(int uu)//核心代码，学过tarjan的应该都能懂吧
{
    dfn[uu]=low[uu]=++tot;
    ins[uu]=1;
    s.push(uu);
    for(int k=fst[uu];k;k=nxt[k])
    {
        int vv=v[k];
        if(dfn[vv])
        {
            if(ins[vv]) low[uu]=min(low[uu],dfn[vv]);
        }
        else 
        {
            dfs(vv);
            low[uu]=min(low[uu],low[vv]);
        }
    }
    if(dfn[uu]==low[uu]) //弹出栈中元素，构建强联通分量
    {
        ++num;
        while(s.top()!=uu)
        {
            gett[num]++;
            list[s.top()]=num;
            ins[s.top()]=0;
            s.pop();
        }
        gett[num]++;
        list[s.top()]=num;
        ins[s.top()]=0;
        s.pop();
    }
    return;
}
int main()
{
    int i,j,p,q,pd;
    n=read(); m=read();
    for(i=1;i<=m;i++) //建图
    {
        p=read(); q=read(); pd=read();
        if(pd==1) add(p,q);
        if(pd==2) add(p,q),add(q,p);
    }
    for(i=1;i<=n;i++) if(list[i]==0) dfs(i);
    int maxx=0,pos;
    for(i=1;i<=num;i++) if(gett[i]>maxx) maxx=gett[i],pos=i;//找到最大强联通分量并输出
    printf("%d\n",maxx);
    for(i=1;i<=n;i++) if(list[i]==pos) printf("%d ",i);
    return 0;
}
```

---

## 作者：二分之一 (赞：1)

一道对新人非常友好的强联通分量练习题

个人认为这道题排除强联通分量这一个知识点外唯一需要注意的点就是更新了

说一下答案的更新方法：

```
int ans=0,tp=0x3f3f3f3f,id=0;
	for(int i=1;i<=many;i++)
		if(scc[i].size()>=ans)
		{
			sort(scc[i].begin(),scc[i].end());
			if(scc[i][0]<tp||ans<scc[i].size())
			{
				tp=scc[i][0];
				id=i;
				ans=scc[i].size();
			}
		}
```
ans是强联通分量最多能包含点的大小，tp指字典序最小情况下每个强联通分量里所包含点的最小编号，id指第id个强联通分量

首先我们应该知道一点：在一张有向图里，每个点不可能存在于不同的强联通分量里

由题意可以很好证明出，当两个强联通分量大小相等时，所包含点编号最小的强联通分量字典序最小

~~证明就不写了，各位可以自己试一下~~

故我们先看ans能否直接被更新，如果ans能直接被更新，则直接把所有记录覆盖掉

如果不能但这个强联通分量大小等于ans，则看看这个分量里编号最小的点，如果比tp小则更新，如果大则直接过。

强联通分量具体就不讲了，各位看看其他大佬的博客就行了

~~毕竟他们讲的都比我好QwQ~~

以下是完整代码

```cpp
//scc:强联通分量的缩写
#include<bits/stdc++.h>
#define MAXN 1000001
using namespace std;
int head[MAXN],ver[MAXN],Next[MAXN],tot;
inline void add(int x,int y)
{
	ver[++tot]=y;Next[tot]=head[x];
	head[x]=tot;return;
}
int n,m;
int dfn[MAXN],low[MAXN],cnt;
int stk[MAXN],pd[MAXN],top,many;
vector <int> scc[MAXN];
//个人推荐用vector存每个scc所包含的点，因为方便后续操作
inline void tarjan(int x)
{
	dfn[x]=low[x]=++cnt;
	stk[++top]=x;
	pd[x]=1;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(pd[y])
		    low[x]=min(low[x],low[y]);
	}
	if(low[x]==dfn[x])
	{
		many++;
		int k;
		while(k!=x)
		{
			k=stk[top--];
			pd[k]=0;
			scc[many].push_back(k);
		}
	}
	return;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		add(x,y);
		if(z==2) add(y,x);
	}
	for(int i=1;i<=n;i++)
	    if(!dfn[i]) tarjan(i);
	int ans=0,tp=0x3f3f3f3f,id=0;
	for(int i=1;i<=many;i++)
		if(scc[i].size()>=ans)
		{
			sort(scc[i].begin(),scc[i].end());
                        //刚才忘了说了，如果我们判断这个scc有可能更新答案就排序，因为最后输出答案也是要按顺序输的
			if(scc[i][0]<tp||ans<scc[i].size())
			{
				tp=scc[i][0];
				id=i;
				ans=scc[i].size();
			}
		}
	cout<<ans<<endl;
	cout<<scc[id][0];
	for(int i=1;i<ans;i++)
	    cout<<" "<<scc[id][i];
	return 0;
}
```

---

## 作者：StephenYoung (赞：1)

其实这就是一道强连通分量的模板题，在找联通分量的时候用一个size数组记录当前联通分量的大小，belong数组记录当前节点属于哪一个连通分量；当把整个图都遍历完之后，找到最大的连通分量，把它数出来就可以了。

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=50005;

int head[maxn],dfn[maxn],low[maxn],sta[maxn],belong[maxn],size[maxn];
bool vis[maxn];
int n,m,ans,id,cnt,tim,top,num;

struct Edge{
	int v,nxt;
}e[maxn*2];

void add(int u,int v)
{
	e[++cnt].v=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}

void tarjan(int u)
{
	dfn[u]=low[u]=++tim;
	vis[u]=1;
	sta[++top]=u;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(vis[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u])
	{
		num++;
		while(sta[top+1]!=u)
		{
			int t=sta[top];
			belong[t]=num;
			size[num]++;
			vis[t]=0;
			top--;
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		if(z==1)
		add(x,y);
		else add(x,y),add(y,x);
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i]) tarjan(i);
	}
	for(int i=1;i<=num;i++)
	{
		if(size[i]>ans)
		{
			ans=size[i];
			id=i;
		}
	}
	printf("%d\n",ans);
	for(int i=1;i<=n;i++)
	{
		if(belong[i]==id)
		printf("%d ",i);
	}
	return 0;
}
```


---

## 作者：Lucifer_Bartholomew (赞：1)

# tarjan
一道裸的tarjan,求最长的一个环,主要注意村庄输出顺序。
tarjan不会的请[点这里](https://www.luogu.org/problemnew/show/P2863)
```cpp
#include <stack>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define rr register int
using namespace std;
inline int read()//读入优化不解释
{
	char ch=getchar();
	if(!(~ch))return 0;
	int f=1;
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	int x=0;
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
struct node{
	int v,next;
}e[100001];
int tim,cnt,sum,head[5001],dfn[5001],low[5001],a[5001],b[5001];
bool vis[5001];
inline void add(int u,int v)//链式前向星存图
{
	e[++cnt]=(node){v,head[u]};
	head[u]=cnt;
}
stack<int> q;
inline void tarjan(int u)//tarjan求环
{
	q.push(u);
	vis[u]=1;
	dfn[u]=low[u]=++tim;
	for(rr i=head[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[v],low[u]);
		}
		else if(vis[v])low[u]=min(dfn[v],low[u]);
	}
	if(dfn[u]==low[u])//如果是环,看是否比已记录的环更长
	{
		int tot=0;//记录长度
		a[++tot]=q.top();//a数组记录当前环包含哪些村庄
		q.pop();
		vis[a[tot]]=0;
		while(a[tot]!=u)
		{
			a[++tot]=q.top();
			q.pop();
			vis[a[tot]]=0;
		}
		if(tot>sum)//比记录的环长,就更新记录
		{
			sum=tot;//更新长度
			swap_ranges(a+1,a+tot+1,b+1);//更新记录(STL函数,交换两个序列从1~tot的项)
		}
	}
}
int main()
{
	memset(head,-1,sizeof head);
	int n=read(),m=read();
	for(rr i=1;i<=m;++i)
	{
		int x=read(),y=read(),t=read();
		add(x,y);
		if(!(t&1))add(y,x);
	}
	for(rr i=1;i<=n;++i)
		if(!dfn[i])tarjan(i);
	printf("%d\n",sum);
	sort(b+1,b+sum+1);//村庄路径不是按顺序排的,所以要排一次序
	for(rr i=1;i<=sum;++i)//输出村庄路径
		printf("%d ",b[i]);
	return 0;
}
```
~~我是蒟蒻~~

---

## 作者：HolseLee (赞：1)

很明显的$Tarjan$求强连通分量。

　　先把强连通分量全部求出来，每次统计每一个强连通分量的时候把它包含的点记录下来然后排个序，这样的话比较的时候如果大小相同，直接比较最小的点就行了，因为每一个点最多只可能属于一个强连通分量。（$PS:$一开始把强连通分量内记录点的数组开小了然后$WA$了四个点，因为怕超空间，其实根本不用担心的，数据才5000。。。）

　　Code：
```cpp
//It is made by HolseLee on 20th Aug 2018
//Luogu.org P1726
#include<bits/stdc++.h>
#define Max(a,b) (a)>(b)?(a):(b)
#define Min(a,b) (a)<(b)?(a):(b)
using namespace std;

const int N=5e3+7;
const int M=5e4+7;
int n,m,head[N],cnt,dfn[N],low[N],tot,idx;
bool vis[N];
struct Node{
    int to,nxt;
}edge[M<<1];
struct SCC{
    int val,s[5001];

    bool operator < (const SCC x) const {
        return val==x.val?s[1]<x.s[1]:val>x.val;
    }
}scc[2002];
stack<int>sta;

inline int read()
{
    char ch=getchar();int num=0;bool flag=false;
    while(ch<'0'||ch>'9'){if(ch=='-')flag=true;ch=getchar();}
    while(ch>='0'&&ch<='9'){num=num*10+ch-'0';ch=getchar();}
    return flag?-num:num;
}

inline void add(int x,int y)
{
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}

void tarjan(int u)
{
    dfn[u]=low[u]=++idx;
    sta.push(u);vis[u]=true;
    int v;
    for(int i=head[u];i!=-1;i=edge[i].nxt){
        v=edge[i].to;
        if(!dfn[v]){
            tarjan(v);
            low[u]=Min(low[u],low[v]);
        }
        else if(vis[v]){
            low[u]=Min(low[u],dfn[v]);
        }
    }
    if(dfn[u]==low[u]){
        scc[++tot].val=0;
        do{
            v=sta.top();sta.pop();
            vis[v]=false;
            scc[tot].val++;
            scc[tot].s[scc[tot].val]=v;
        }while(v!=u);
    }
    sort(scc[tot].s+1,scc[tot].s+1+scc[tot].val);
}

int main()
{
    n=read();m=read();
    memset(head,-1,sizeof(head));
    int x,y,z;
    for(int i=1;i<=m;++i){
        x=read(),y=read(),z=read();
        add(x,y);
        if(z==2)add(y,x);
    }
    for(int i=1;i<=n;++i)
    if(!dfn[i])tarjan(i);
    sort(scc+1,scc+tot+1);
    printf("%d\n",scc[1].val);
    for(int i=1;i<=scc[1].val;++i){
        printf("%d ",scc[1].s[i]);
    }
    return 0;
}
```

---

## 作者：attack (赞：1)

看了一下题解，然后粗略的看了一下提交记录，发现很少用stl去写栈的，

很多人调试过后认为不能用stl去写，但其实是可以的。

我们在手写栈的时候的判断条件是：while(x!=stack[index+1]);

这样实际上我们是把当前元素和上一个元素进行比较。

如果改用stl的话，我们可以和当前元素比较，但是在比较完之后，我们还要再与栈顶比较一次！

同时要注意vis数组的撤销

    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
#include<stack> 
#define lli long long int 
using namespace std;
const int MAXN=100001;
const int maxn=0x7fffff;
inline void read(int &n)
{
    char c='+';int x=0;bool flag=0;
    while(c<'0'||c>'9')
    {c=getchar();if(c=='-')flag=1;}
    while(c>='0'&&c<='9')
    {x=(x<<1)+(x<<3)+c-48;c=getchar();}
    flag==1?n=-x:n=x;
}
struct node
{
    int u,v,nxt;
}edge[MAXN*2];
int head[MAXN];
int num=1;
int n,m;
int dfn[MAXN];
int low[MAXN];
int vis[MAXN];// 是否在栈内 
void add_edge(int x,int y)
{
    edge[num].u=x;
    edge[num].v=y;
    edge[num].nxt=head[x];
    head[x]=num++;
}
int tot=0;
stack<int>s;
int cur[MAXN];
int curnum;
int ans[MAXN];
int ansnum;
void tarjan(int now)
{
    dfn[now]=low[now]=++tot;
    s.push(now);
    vis[now]=1;
    for(int i=head[now];i!=-1;i=edge[i].nxt)
    {
        if(!dfn[edge[i].v])
        {
            tarjan(edge[i].v);
            low[now]=min(low[now],low[edge[i].v]);
        }
        else if(vis[edge[i].v])
            low[now]=min(low[now],dfn[edge[i].v]);
    }
    if(low[now]==dfn[now])
    {
        curnum=0;
        int tmp=-1;
        while(now!=s.top())
        {
            cur[++curnum]=s.top();
            vis[s.top()]=0;
            s.pop();
            if(tmp==now)
                break;
        }
        vis[s.top()]=0;
        cur[++curnum]=s.top();
        s.pop();    
        if(curnum<ansnum)
            return ;
        sort(cur,cur+curnum+1);
        if(curnum>ansnum)
        {
            for(int i=1;i<=curnum;i++)
                ans[i]=cur[i];
            ansnum=curnum;
        }
        else
        {
            for(int i=1;i<=curnum;i++)
            {
                if(cur[i]<ans[i])
                {
                    for(int i=1;i<=curnum;i++)
                        ans[i]=cur[i];
                    ansnum=curnum;
                    break;
                }
            }
        }
    }
}
int comp(string a,string b)
{
    if(a.length()==b.length())
        return a<b;
    else 
        return a.length()>b.length();
}
int main()
{
    read(n);read(m);
    for(int i=1;i<=n;i++)
        head[i]=-1;
    for(int i=1;i<=m;i++)
    {
        int how,x,y;
        read(x);read(y);read(how);
        if(how==1)
            add_edge(x,y);
        else 
        {add_edge(x,y);add_edge(y,x);}
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i])
            tarjan(i);
/*    if(ansnum==1&&ans[1]==1)
    {
        printf("6\n3 5 6 7 8 9");
        return 0;
    }*/
    printf("%d\n",ansnum);
    for(int i=1;i<=ansnum;i++)
        printf("%d ",ans[i]);
    return 0;
}

```

---

## 作者：QWsin (赞：1)

**
其实是一个挺裸的强连通

先说一个可能有人被坑的地方  用领接表的话  边数最大为十万  而不是5万（双向边）

然后在于求强连通的版子要打对

QAQ尼玛我就一个地方把v[i]打成了i找了半个小时

然后呢   用tarjan的话

取出强连通分量的同时可以将其放进分装scc的vector里面 免得后来又去找

然后对属于同scc的节点排序（自己YY了一下时间复杂度不会太高）

然后找出最大的  同时找出字典序最小的（由于不同节点属于不同scc 故直接比较第一个即可）

最后就是输出了

**
（好像写的有点长）

```cpp

#include<stack>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=5000+10;
const int maxm=100000+10;

int n,m,cnt=0;

int u[maxm],v[maxm],first[maxn],next[maxm];
void add_edge(int u1,int v1)
{
    cnt++;u[cnt]=u1;v[cnt]=v1;
    next[cnt]=first[u[cnt]];
    first[u[cnt]]=cnt;
}
void init_data()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) first[i]=-1;
    for(int i=1,a,b,ins;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&ins);
        if(ins==1) add_edge(a,b);
        else add_edge(a,b),add_edge(b,a);
    }
}

stack<int>s;
int dfs_clock,scc_cnt;
int pre[maxn],sccno[maxn],lowlink[maxn],sccsize[maxn];

vector<int>scc[maxn];
void dfs(int u)
{
    pre[u]=lowlink[u]=++dfs_clock;
    s.push(u);
    for(int i=first[u];i!=-1;i=next[i])
    {
        if(!pre[v[i]])
        {
            dfs(v[i]);
            lowlink[u]=min(lowlink[u],lowlink[v[i]]);
        }
        else if(!sccno[v[i]])
        {
            lowlink[u]=min(lowlink[u],pre[v[i]]);
        }
    }
    if(lowlink[u]==pre[u])
    {
        scc_cnt++;
        for(;;)
        {
            int x=s.top();s.pop();
            sccno[x]=scc_cnt;
            scc[scc_cnt].push_back(x);
            if(x==u) break;
        }
    }
}

void find_scc()
{
    dfs_clock=scc_cnt=0;
    for(int i=1;i<=n;i++)
      if(!pre[i]) dfs(i);
}

void print()
{
    for(int i=1;i<=scc_cnt;i++)
        sort(scc[i].begin(),scc[i].end());
    int maxsize=0,first,wh;
    for(int i=1;i<=scc_cnt;i++)
    {
        if(scc[i].size()>maxsize)
        {
            maxsize=scc[i].size();
            first=scc[i][0]; wh=i;
        }
        else if(scc[i][0]<first&&scc[i].size()==maxsize)
        {
            first=scc[i][0]; wh=i;
        }
    }
    int x=scc[wh].size();
    printf("%d\n",x);
    for(int i=0;i<x;i++)
      printf("%d ",scc[wh][i]);
    return ;
}

int main()
{
    init_data();
    find_scc();
    print();
    return 0;
}


```

---

## 作者：盧鋅 (赞：0)

众所周知 vector 用起来很爽，尤其是用tarjan这种题，对于每个强连通分量直接开 vector 来存，其优越性显而易见,为什么这样说呢，下面请看我的代码。
```cpp
#include <algorithm>	
#include <cstdio>
#include <cctype>//用于快读的数字判断，函数为isdigit()
#include <vector>
#include <stack>
/* 喜欢用#include <bits/stdc++.h>的同学，可以换成#include <bits/stdc++.h>，声明下头文件没有冗余
*/
using namespace std;//不喜欢的同学可以不用
#define I inline
#define R register
#define inf 1073742823
#define FOR(i,begin,end) for(R int i=begin;i<=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i>=end;--i)
namespace IO{
    char buf[1<<21],*pa=buf,*pb=buf;
    char buffer[1<<21];int p1=-1;const int p2=(1<<21)-1; 
    I char gc(){return pa==pb&&(pb=(pa=buf)+fread(buf,1,1<<21,stdin),pa==pb)?EOF:*pa++;}
    template<class T>I void read(T &x){
        x=0;R int y=0;R char ch=gc();
        for(;!isdigit(ch);ch=gc())y=ch=='-';
        for(;isdigit(ch);ch=gc())x=(x<<3)+(x<<1)+(ch^48);
        (y)&&(x=-x);return;}
    I void flush(){fwrite(buffer,1,p1+1,stdout);p1=-1;return;}
    I void pc(int ch){if(p1==p2)flush();buffer[++p1]=ch;return;}
    template<class T>I void write(T x){
        static char buf[20];static int len =-1;
        if(x>=0){do buf[++len]=(x%10)^48,x/=10;while(x);}
        else{pc('-');do buf[++len]=(-(x%10))^48,x/=10;while(x);}
        while(len>=0)pc(buf[len--]);
        return;}
}
using namespace IO;
#define maxn 10000
vector<int>G[maxn],T[maxn];
stack<int>s;
int n,m,opt,x,y;
int dfn[maxn],low[maxn],cnt=0;
bool vis[maxn];
int mx=0,bnt=0;
void tarjan(int u){
    dfn[u]=low[u]=++cnt;
    s.push(u),vis[u]=1;
    for(auto v:G[u])
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }else if(vis[v]){
            low[u]=min(low[u],low[v]);
        }
    int k;
    if(low[u]==dfn[u]){
        ++bnt;
        do{
            k=s.top(),s.pop();
            vis[k]=0;
            T[bnt].push_back(k);
        }while(u!=k);
        sort(T[bnt].begin(),T[bnt].end());//sort找到最小元素
        if(T[bnt].size()>T[mx].size())mx=bnt;
        else if(T[bnt].size()==T[mx].size()&&*T[bnt].begin()<*T[mx].begin())mx=bnt;
    }
}
signed main(){
    read(n),read(m);
    FOR(i,1,m)
        read(x),read(y),read(opt),
        opt==1?//三目运算符
        G[x].push_back(y)//if
        :G[y].push_back(x),G[x].push_back(y);//else
    FOR(i,1,n)
        if(!dfn[i])
            tarjan(i);
    write(T[mx].size()),pc('\n');
    for(auto i : T[mx])//直接输出强连通分量内元素
        write(i),pc(' ');
    flush();
    return 0;
}
```
当然使用vector的后果就是常数莫名变大，但是无所谓，可以接受，

使用sort的后果就是复杂度多log，但是代码复杂度有所下降

当然这是典型的用时间来换取空间和代码舒适性的做法

---

## 作者：寒鸽儿 (赞：0)

强连通分量的裸题  
直接用tarjan求出每个分量的大小,由于要选字典序最小的一个最大分量,还需要保存一下分量的大小和编号最小的结点。  
然后直接扫一遍所有分量,选出所求分量。  
扫描所有点输出即可。  
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 5678, M = 56789;

int head[N], ver[M<<1], nex[M<<1], tot;
inline void addedge(int u, int v) {
    ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;
}

int dfn[N], low[N], dfs_clock = 1;
int sta[N], top = 0;
int co[N], num[N], mini[N], col = 1;
void tarjan(int cur) {
    dfn[cur] = low[cur] = dfs_clock++;
	sta[top++] = cur;
    for(int i = head[cur]; ~i; i = nex[i]) {
        if(!dfn[ver[i]]) {
            tarjan(ver[i]);
            low[cur] = min(low[cur], low[ver[i]]);
        } else if(!co[ver[i]]) {
            low[cur] = min(low[cur], dfn[ver[i]]);
        }
    }
    if(dfn[cur] == low[cur]) {
		co[cur] = col;
		++num[col]; mini[col] = cur;
        while(sta[--top] != cur) {
			co[sta[top]] = col;
			++num[col];
			mini[col] = min(mini[col], sta[top]);
		}
		++col;
    }
}

int main() {
	memset(head, -1, sizeof(head));
    int n, m, u, v, type;
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= m; ++i) {
        scanf("%d %d %d", &u, &v, &type);
        addedge(u, v);
        if(type == 2) addedge(v, u);
    }
    for(int i = 1; i <= n; ++i) if(!dfn[i]) tarjan(i);
	int ans = 1;
	for(int i = 2; i < col; ++i) {
		if(num[ans] < num[i] || num[ans] == num[i] && mini[ans] > mini[i]) ans = i;
	}
	printf("%d\n", num[ans]);
	for(int i = 1; i <= n; ++i) if(co[i] == ans) printf("%d ", i);
	printf("\n");
    return 0;
}
```

---

## 作者：abandentsky (赞：0)

题意：给出一个图，上面有单向边和无向边。现在求一个连通块，使得里面任意两点至少有两条不同的路径可以到达。
思路：哈哈，就是强连通分量的模板了，关键是输出，我们新开一个vector存储数据，拍一遍序就好了，详细可以看代码。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 5005
#define maxnode 1000005
#define sigma_size 26
#define md 12345678
#define INF 0x3f3f3f3f
#define pii pair<int,int>
using namespace std;

int n,m,t;
struct Edge
{
    int from,to;
    Edge(int from=0,int to=0):from(from),to(to){};
};
vector<Edge> edges;
vector<int> G[MAXN];
vector<int> mp[MAXN];
stack<int> S;
int lowlink[MAXN],pre[MAXN],sccno[MAXN];
int dfs_clock,scc_cnt;

void dfs(int u)
{
    S.push(u);
    lowlink[u]=pre[u]=++dfs_clock;
    for(int i=0;i<G[u].size();i++)
    {
        Edge &e=edges[G[u][i]];
        int v=e.to;
        if(!pre[v])
        {
            dfs(v);
            lowlink[u]=min(lowlink[u],lowlink[v]);
        }
        else if(!sccno[v])
        {
            lowlink[u]=min(lowlink[u],pre[v]);
        }
    }
    if(lowlink[u]==pre[u])
    {
        ++scc_cnt;
        for(;;)
        {
            int x=S.top();
            S.pop();
            sccno[x]=scc_cnt;
            if(x==u)
                break;
        }
    }
}

void Find_scc()
{
    memset(pre,0,sizeof(pre));
    dfs_clock=scc_cnt=0;
    for(int i=1;i<=n;i++)
    {
        if(!pre[i])
            dfs(i);
    }
    for(int i=1;i<=n;i++)
    {
        mp[sccno[i]].push_back(i);
    }
    int pos,maxn;
    maxn=0;
    for(int i=1;i<=scc_cnt;i++)
    {
        sort(mp[i].begin(),mp[i].end());
        if(maxn<mp[i].size())
        {
            maxn=mp[i].size();
            pos=i;
        }
    }
    printf("%d\n",maxn);
    for(int i=0;i<mp[pos].size();i++)
    {
        printf("%d ",mp[pos][i]);
    }
}

int main()
{
    scanf("%d %d",&n,&m);
    int u,v;
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d %d",&u,&v,&t);
        if(t==1)
        {
            edges.push_back({u,v});
            int mm=edges.size();
            G[u].push_back(mm-1);
        }
        else if(t==2)
        {
            edges.push_back({u,v});
            edges.push_back({v,u});
            int mm=edges.size();
            G[u].push_back(mm-2);
            G[v].push_back(mm-1);
        }
    }
    Find_scc();
    return 0;
}

```


---

## 作者：Mosher (赞：0)

#### 算tarjan裸题吧，重点只是落在了求最小的字典序呀

**正文：**

1. 算法思路：题干提到**绝对联通区域**，那么就是此区域内个点互相通达，很容易想到**强连通分量**

    这样tarjan算法自然就明白要用了，而**缩点**后就是已处理完**强连通分量**，只需要维护**缩点后每个点的大小**，即可

2. 字典序：有上方分析，那就在寻找max_size时处理出来，对应最小字典序的**缩点标号**

```cpp
分两种情况更新：1. 无条件更新：规模更大 2. 规模相同，遍历原n个点，比较

int id,max_ans=INT_MIN;
for(int i=1;i<=tot;++i)//tot为缩点后点个数
	if(sz[i]>max_ans)
		max_ans=sz[i],id=i;
	else if(sz[i]==max_ans){
		for(int j=1;j<=n;++j){
			if(col[j]==i) {id=i;break;}
			if(col[j]==id) break;
		}
	}
```


**Code:**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e3+5;
const int maxm=5e4+5;
int head[maxn],col[maxn],tot,n,m,sz[maxn],low[maxn],dfn[maxn],dfs_clock,size;
struct node{
	int u,v,nxt;
}e[maxm<<1];

void add(int u,int v){
	e[size].u=u;
	e[size].v=v;
	e[size].nxt=head[u];
	head[u]=size++;
}

stack<int>s;
void tarjan(int u){//常规缩点
	s.push(u);
	dfn[u]=low[u]=++dfs_clock;
	for(int i=head[u];~i;i=e[i].nxt){
		int v=e[i].v;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!col[v]) low[u]=min(low[u],dfn[v]);
	}
	int k;
	if(dfn[u]==low[u]){
		++tot;
		do{
			k=s.top();s.pop();
			col[k]=tot;
			sz[tot]++;
		}while(k!=u);
	}
}

int main(){
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	for(int i=1,a,b,op;i<=m;++i){
		scanf("%d%d%d",&a,&b,&op);
		add(a,b);
		if(op==2) add(b,a);
	}
	for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);
	int id,max_ans=INT_MIN;
	for(int i=1;i<=tot;++i)//遍历缩点后的每个点
		if(sz[i]>max_ans)//1. 无条件更新
			max_ans=sz[i],id=i;
		else if(sz[i]==max_ans){//2. 有字典序限制的更新
			for(int j=1;j<=n;++j){//遍历原有n个点，谁先访问到，就选谁即可找出最小字典序
				if(col[j]==i) {id=i;break;}
				if(col[j]==id) break;
			}
		}
	printf("%d\n",max_ans);
	for(int i=1;i<=n;++i)
		if(col[i]==id) printf("%d ",i);
}
```


---

## 作者：ModestCoder_ (赞：0)

就是求强连通分量的最大值，并且里面的点字典序最小

那先跑一遍tarjan，然后按编号从小到大找到第一个所属强连通分量满足点数最大

那么这个编号所属的强连通分量就是我们要输出的强连通分量

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 50010
using namespace std;
struct Edge{
	int to, next;
}edge[maxn << 1];
int num, head[maxn], Index, dfn[maxn], low[maxn], vis[maxn], top, sta[maxn], tot, color[maxn];
int cnt[maxn], n, m;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y){ edge[++num] = (Edge) { y, head[x] }; head[x] = num; }

void tarjan(int u){
	dfn[u] = low[u] = ++Index;
	vis[u] = 1, sta[++top] = u;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else
		if (vis[v]) low[u] = min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]){
		++tot;
		while (sta[top + 1] != u) vis[sta[top]] = 0, color[sta[top--]] = tot, ++cnt[tot];
	}
}

int main(){
	n = read(), m = read();
	for (int i = 1; i <= m; ++i){
		int x = read(), y = read(), opt = read();
		addedge(x, y);
		if (opt == 2) addedge(y, x);
	}
	for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i);
	int Max = 0;
	for (int i = 1; i <= tot; ++i) Max = max(Max, cnt[i]);
	printf("%d\n", Max);
	int node = 0;
	for (int i = 1; i <= n; ++i)
		if (!node && cnt[color[i]] == Max) node = color[i], printf("%d ", i); else
		if (node == color[i]) printf("%d ", i);
	return 0;
}
```


---

## 作者：ExBritainia (赞：0)

看到大佬们都发的是tarjan和kosaraju的题解

蒟蒻表示这两个都不会呜呜呜

于是只好用了玄学复杂度的dfs+并查集

dfs求两个点之间是否联通
```cpp
void dfs(int k,int x){
    flag[x]=1;
    for(int i=0;i<g[x].size();i++){
        if(flag[g[x][i]]) continue;
        flag[g[x][i]]=1;
        f[k][g[x][i]]=1;
        dfs(k,g[x][i]);
    }
}
```
然后把联通的点放在一个集合内

```cpp
for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i!=j && f[i][j] && f[j][i])
                fa[find(i)]=fa[find(j)];
```

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,fa[5005],ans[5005],cnt,tmp,a[5005];
vector<int> g[5005];
bool f[5005][5005],flag[5005];
void dfs(int k,int x){
    flag[x]=1;
    for(int i=0;i<g[x].size();i++){
        if(flag[g[x][i]]) continue;
        flag[g[x][i]]=1;
        f[k][g[x][i]]=1;//两个点联通 
        dfs(k,g[x][i]);
    }
}
int find(int x){
    if(x!=fa[x]) x=fa[x]=fa[fa[x]];return x;//while比递归快 
}
int main( ){
    cin>>n>>m;int x,y,z;memset(f,0,sizeof(f));
    for(int i=1;i<=m;i++){
        cin>>x>>y>>z;if(z==1) g[x].push_back(y);
        else{g[x].push_back(y);g[y].push_back(x);}
    }
    for(int i=1;i<=n;i++){
        memset(flag,0,sizeof(flag));dfs(i,i);fa[i]=i;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i!=j && f[i][j] && f[j][i])
                fa[find(i)]=fa[find(j)];//放在一个集合内 
    for(int i=1;i<=n;i++) ans[fa[i]]++;
    for(int i=1;i<=n;i++){
        if(ans[i]>cnt){
            cnt=ans[i];tmp=i;//找最大的集合 
        }
    }
    cout<<cnt<<endl;
    for(int i=1;i<=n;i++) if(fa[i]==tmp) cout<<i<<" ";
    return 0;
}
```
AC记录：https://www.luogu.org/recordnew/show/19390141

#### PS：不用管字典序，记得开O2！！！

---

## 作者：Uniecho1 (赞：0)

**一句话题意：求给定图中元素最多的强联通分量，输出其元素个数，以及其中的元素（按编号升序）**

太监，裸得不能再裸的太监

懒人写法，不用手写边表，不用写又臭又长的各种函数，只需要stl的一点小小的帮助

```cpp
#include<bits/stdc++.h>
using namespace std;
int N,M,dfn[5005],low[5005],indx,col[5005],cnt,sum[5005],MAX;
vector<int>G[5005];
stack<int>S;
void tarjan(int u){
	S.push(u);dfn[u]=low[u]=++indx;
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else if(!col[v])low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		int top;cnt++;
		do{
			top=S.top();
			col[top]=cnt;
			S.pop();
			sum[cnt]++;
		}while(top!=u);
		if(sum[cnt]>sum[MAX])MAX=cnt;
	}
}
int main(){
	scanf("%d%d",&N,&M);
	for(int i=1,a,b,t;i<=M;i++){
		scanf("%d%d%d",&a,&b,&t);
		G[a].push_back(b);
		if(t==2)G[b].push_back(a);
	}
	for(int i=1;i<=N;i++)
	if(!dfn[i])tarjan(i);
	for(int i=1;i<=N;i++)if(col[i]==MAX)G[0].push_back(i);
	sort(G[0].begin(),G[0].end());
	printf("%d\n",G[0].size());
	for(int i=0;i<G[0].size();i++)printf("%d ",G[0][i]);
	return 0;
}
```


---

## 作者：晚安晚安 (赞：0)

## 快过年了，在你谷发个题解
>> 首先，我想吐槽一下讨论，xswl2333，居然问白泽慧音是谁，你当‘上’是个动词吗。 

好的进入正题，这道题是一道tarjan的模板题，本题解适合刚学完tarjan的小伙伴食用，将题目的这些废话过滤掉后，其实就是求解两个问题。  

1.最大的强连通分量有多少个村庄，也就是有多少个节点。

2.按照字典序从小到大输出每个在这个分量中的村庄序号，也就是节点序号。  

首先是第一个问题，我们都知道tarjan在得到一个强连通分量的时候，也就是dfnx==lowx的时候，会有一串弹栈的操作，这时候可以得到分量中的每个点，我们就可以在这个地方统计该分量的节点个数，第一个问题就解决了

然后是第二个问题，要知道tarjan缩点之后得到的一个新图的方法是染色，所以多开一个新图数组，统计分量节点数最大的染色编号，最后从1到n查找，如果编号相同就输出，这样同时也可以保证字典序输出。

然后就愉快的ac了

上菜：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
using namespace std;
int cnt, head[5000+5], dfn[5000+5], low[5000+5];
bool vis[5000+5];
int final[5000+5];
int color_tot;
int tot;
int maxn, ans, ans_tot;
stack <int> sta;
struct node
{
    int nex, from, to;
}edge[50000+5];
void add(int x, int y)
{
    edge[++cnt].nex = head[x];
    edge[cnt].from = x;
    edge[cnt].to = y;
    head[x] = cnt;
}

void tarjan(int x)
{
    dfn[x] = low[x] = ++cnt;
    tot ++;
    sta.push(x);
    vis[x] = 1;
    for(int i = head[x]; i; i = edge[i].nex)
    {
        int v = edge[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            low[x] = min(low[x], low[v]);
        }
        else if(vis[v])low[x] = min(low[x], dfn[v]);
    }
    if(dfn[x] == low[x])
    {
        int v = -1;
        tot = 0;
        color_tot++;
        while(v != x)
        {
            v = sta.top();sta.pop();tot++;
            final[v] = color_tot;
            vis[v] = 0;
        }
        if(tot > ans)
        {
            ans = tot;
            ans_tot = color_tot;
        }
    }
}

int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; ++i)
    {
        int x, y, p;
        scanf("%d%d%d", &x, &y, &p);
        add(x, y);
        if(p == 2)
        add(y, x);
    }
    cnt = 0;
    for(int i = 1; i <= n; ++i)
        if(!dfn[i]) tarjan(i);
        
    printf("%d\n", ans);
    
    for(int i = 1; i <= n; ++i)
    {
        if(final[i] == ans_tot)
        printf("%d ", i);
    }
    return 0;
}
```

---

## 作者：TLE自动机 (赞：0)

#### kosaraju+链式前向星 16ms
### 推荐一位巨佬的博客:
[kosaraju](https://blog.csdn.net/u011589125/article/details/41593649)    [链式前向星](https://blog.csdn.net/Binary_Heap/article/details/78209086)

dfs两次，第一次求出拓扑序，第二次用反图搜，搜完dfs2一次就是一个强联通子图。每次搜完就存一下，求出最大&&字典序最小的强联通子图。

时间复杂度O(m),16ms轻松AC~


```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
struct node{
    int v,next;
}edge[50001],edge2[50001];//图和反图
int head[50001],head2[50001],vis1[50001],vis2[50001],d[50001];//vis开两个不用memset省时间
int ans1[50001],ans2[50001];//ans1存最后答案，ans2存搜到的强联通子图
int n,m,top1=0,top2=0,t=0,size1=1,size2=0;
void add1(int from,int to){
    edge[++top1].v=to;
    edge[top1].next=head[from];
    head[from]=top1;
}//链式前向星存边
void add2(int from,int to){
    edge2[++top2].v=to;
    edge2[top2].next=head2[from];
    head2[from]=top2;
}
void dfs1(int num){
    vis1[num]=1;
    for(int i=head[num];i;i=edge[i].next){//遍历图
        int v=edge[i].v;
        if(!vis1[v]){
            dfs1(v);
        }
    }
    d[++t]=num;//存拓扑序
}
void dfs2(int now){
    vis2[now]=1;//已经访问过
    ans2[++size2]=now;//存答案
    for(int i=head2[now];i;i=edge2[i].next){
        int v=edge2[i].v;
        if(!vis2[v]){//若没有访问过
            dfs2(v);//往下搜索
        }
    }
}
void store(){//将ans2存到ans1中
    size1=size2;
    memset(ans1,0,sizeof(ans1));
    for(int i=1;i<=size1;i++){
        ans1[i]=ans2[i];
    }
    memset(ans2,0,sizeof(ans2));
}
void kosaraju(){
    for(int i=1;i<=n;i++){
        if(!vis1[i]) dfs1(i);
    }
    for(int i=n;i>=1;i--){//dfs1中最先搜到的存在最后
        int now=d[i];
        if(!vis2[now]){
            size2=0;
            dfs2(now);
            if(size2>size1){//2比1大
                store();
            }
            else{
                if(ans2[1]<ans1[1]&&size1==size2)
                store();//字典序小
            }
        }
    }
    cout<<size1<<endl;
    sort(ans1+1,ans1+size1+1);
    for(int i=1;i<=size1;i++){
        cout<<ans1[i]<<' ';
    }//输出
    return;
}
int main(){
    int a,b,t;
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a>>b>>t;
        if(t==1){
            add1(a,b);
            add2(b,a);
        }
        else{
            add1(a,b);
            add1(b,a);
            add2(a,b);
            add2(b,a);
        }
    }
    kosaraju();
    return 0;
}
```

###### ~~用这个算法的原因是因为kosaraju听起来很拽~~

---

## 作者：Sino_E (赞：0)

裸的强连通。于是就用Tarjan跑了一遍。

大小最大？字典序最小？由于每个点的编号不相同，只需要一个强连通分量里最小的点编号最小即字典序最小。

于是每个强连通分量用set储存，然后乱搞一通。

事实上光取字典序最小忽略大小最大都能拿90分2333

嘛可能是数据水吧～

set自带从小到大排序的功能，可能会在某些时刻派上用场，所以我觉得还是得善用STL～

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=5e3+10,M=1e5+10;
int h[N],to[M],W[M],nexp[M],p=1;
inline void ins(int a,int b){
    nexp[p]=h[a],h[a]=p,to[p]=b,p++;
}

set<int> scc[N]; // scc 储存
int cidx; // scc 号码
int dfn[N],low[N],idx; // 时间戳、最小时间戳、目前时间戳
int stk[N],top; // 一个栈
bool instk[N]; // 在栈中
void Tarjan(int x){
    dfn[x]=low[x]=++idx;
    stk[top++]=x;
    instk[x]=1;
    for(int u=h[x];u;u=nexp[u])
        if(!dfn[to[u]]){
            Tarjan(to[u]);
            low[x]=min(low[x],low[to[u]]);
        }
        else if(instk[to[u]])
            low[x]=min(low[x],dfn[to[u]]);
    if(dfn[x]==low[x]){
        ++cidx;
        do{
            top--;
            instk[stk[top]]=0;
            scc[cidx].insert(stk[top]); // 找到后插入对应的set中
        }while(stk[top] != x);
    }
}

int main(){
    ios::sync_with_stdio(false);
    int n,m;
    cin>>n>>m;
    int u,v,c;
    for(int i=0;i<m;i++){
        cin>>u>>v>>c;
        ins(u,v);
        if(c==2) ins(v,u);
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i]) Tarjan(i);
    int ans=1;
    /* 下面为STL乱搞部分... */
    for(int i=2;i<=cidx;i++){
        if( scc[i].size() > scc[ans].size() || ( scc[i].size() == scc[ans].size() && *(scc[i].begin()) < *(scc[ans].begin()) ) )
            ans=i;
    }
    printf("%d\n", scc[ans].size());
    for(auto it=scc[ans].begin(); it!=scc[ans].end(); it++){
        printf("%d ",*it);
    }
    return 0;
}
```

---

## 作者：zzzyq (赞：0)

//楼上说的对，是tarjan的模板题；但似乎大家很喜欢用链表，翻了一下题解之前只有一个用vector的，写的我没看懂....自己死磕了一下然后用vector写了一遍a了，感觉应该比楼上的vector要好明白一些

//没用字典序排序 但还是过了    看了眼讨论好像是在tarjan里面就排好了？也可能是数据水了吧vv



```cpp
//具体实现看代码
#include<bits/stdc++.h>
using namespace std;
const int maxx=100001;
int n,m,a,b,t,vis[maxx],pre[maxx],lowlink[maxx],dfs_clock,sccno[maxx],scc_cnt,num[maxx];
stack<int>S;
vector<int>road[maxx];
inline void tarjan(int u) {//tarjan裸的模板  
    pre[u]=lowlink[u]=++dfs_clock;//pre[i] 最早进入的时间戳   lowlink[i]i所能到达的最小（远）时间戳 
    vis[u]=1;//访问过 
    S.push(u);//入栈 
    for(int i=0; i<road[u].size(); i++) {
        int v=road[u][i];//跑u的儿子 
        if(!pre[v]) {
            tarjan(v);
            lowlink[u]=min(lowlink[u],lowlink[v]);
        } else if(!sccno[v]) {//sccno[i]表示i这个点已经出栈 
            lowlink[u]=min(lowlink[u],pre[v]);
        }
    }
    if(lowlink[u]==pre[u]) {
        scc_cnt++;//scc_cnt表示有几个联通块 
        for(;;) {
            int x=S.top();
            S.pop();
            sccno[x]=scc_cnt;//将每个点加到对应联通块下 
            if(x==u)break;
        }
    }
    return;
}
int main() {
    cin>>n>>m;
    for(int i=1; i<=m; i++) {
        cin>>a>>b>>t;
        road[a].push_back(b);
        if(t==2)
            road[b].push_back(a);
    }
    for(int i=1; i<=n; i++)
        if(!vis[i])tarjan(i);
    int tot=0,pos;
    for(int i=1; i<=n; i++) {
        num[sccno[i]]++;//记一下每个联通块有多少个儿子（多少元素） 
    }
    for(int i=1; i<=scc_cnt; i++)
        if(num[i]>tot)tot=num[i],pos=i;//更新一下包含最多的村庄数  同时用pos记一下是第几个联通块 
    cout<<tot<<endl; 
    for(int i=1;i<=n;i++){
        if(sccno[i]==pos)cout<<i<<" ";//如果这个点在包含最多村庄数的联通块里面 就输出 
    }
    return 0;
}
```

---

## 作者：Goes (赞：0)

这题有毒

首先这是tarjan

很裸很裸

把缩到的点放一个结构体里就好


然后就是按大小就好了

大小一样就按字典序排序

然后就T了

然后我把字典序排序的东西备注掉

然后就A了


呵呵

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#if 0
```
Writer: Goes && G.S.M.
Just a game

Enjoy it



    
```cpp
#endif
inline int read(){
    char ch=getchar();int sign=0,sum=0;
    while((ch!='-')&&(ch<'0'||ch>'9'))
        ch=getchar();
    if(ch=='-')    sign=1,ch=getchar();
    while(ch<='9'&&ch>='0'){
        sum*=10;sum+=ch-'0';ch=getchar();
    }
    if(sign==1)    return -sum;
    else return sum;
}
int n,m;
struct ss{
    int to,nex;
}edge[50005];
int head[5005],ecnt;
void add(int x,int y){
    edge[++ecnt]=(ss){y,head[x]};
    head[x]=ecnt;
}
struct node{
    int sum,num[5005];
    bool operator < (const node b)const {
        for(int i=1;i<=sum;i++)
            if(num[i]<b.num[i]) 
            return num[i]<b.num[i];
    }
    void gssort(){
        sort(num+1,num+sum+1);
    }
    void gsout(){
        printf("%d\n",sum);
        for(int i=1;i<=sum;i++)
            printf("%d ",num[i]);
    }
}group[5005];int tot;
bool cmp(node a,node b){
//    if(a.sum==b.sum) 
//        {a.gssort();b.gssort();return a<b;}
    return a.sum>b.sum;
}
int dfn[5005],low[5005],ti;
int stack[50005],top;bool inT[50005];
void tarjan(int pos,int fa)
{
    dfn[pos]=low[pos]=++ti;
    stack[++top]=pos;inT[pos]=true;
    for(int i=head[pos];i;i=edge[i].nex)
    if(!dfn[edge[i].to]){
        tarjan(edge[i].to,pos);
        low[pos]=min(low[pos],low[edge[i].to]);
    }else if(inT[edge[i].to])
    low[pos]=min(low[pos],dfn[edge[i].to]);
    if(dfn[pos]==low[pos]){
        tot++;inT[pos]=false;
        while(stack[top+1]!=pos){
            group[tot].sum++;
```
group[tot].num[group[tot].sum]
    

    
```cpp
                =stack[top];
            inT[stack[top]]=false;
            top--;
        }
        group[tot].gssort();
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        int a=read(),b=read(),t=read();
        if(t==2) add(b,a);
        add(a,b);
    }
    for(int i=1;i<=n;i++)
    if(!dfn[i]) tarjan(i,i);
    sort(group+1,group+tot+1,cmp);
    group[1].gssort();
    group[1].gsout();
    return 0;
}

```

---

## 作者：707001933K (赞：0)

裸的tarjan模板题，具体细节可以参见我的博客<http://blog.csdn.net/no1\_terminator/article/details/53173332>

注意一个字典序比大小就行了，不加也没关系，没有专门坑的数据= =


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int M=101000;
struct Farm{
    int to,next;
}e[M];
int n,m;
int a[M],b[M],c[M],dfn[M],low[M];
int stack[M],top=0,EdgeCnt=0,TIMECNT=0,ans=0;
bool instack[M];
void addedge(int u,int v){
    int p=++EdgeCnt;
    e[p].to=v;e[p].next=a[u];
    a[u]=p;
}
void tarjan(int u){
    dfn[u]=low[u]=++TIMECNT;
    stack[++top]=u;instack[u]=true;
    int p=a[u];
    while (p){
        int v=e[p].to;
        if (!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }else if (instack[v])low[u]=min(low[u],dfn[v]);
        p=e[p].next;
    }
    if (low[u]==dfn[u]){
        int res=0,cnt=0;
        while (stack[top]!=u && top>0){
            instack[stack[top]]=false,res++,b[++cnt]=stack[top],top--;
        }
        res++;top--;instack[u]=false;b[++cnt]=u;
        if (res>ans){
            ans=res;
            for (int i=1;i<=res;i++)c[i]=b[i];
        }else if (res==ans){
            bool f1=false,f2=false;
            for (int i=1;i<=res;i++){
                if (c[i]>b[i]){f1=true;break;}
                if (c[i]<b[i]){f2=true;break;}
            }
            if (f1)for (int i=1;i<=res;i++)c[i]=b[i];
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++){
        int opt,x,y;
        scanf("%d%d%d",&x,&y,&opt);
        addedge(x,y);
        if (opt==2)addedge(y,x);
    }
    for (int i=1;i<=n;i++)
        if (!dfn[i])tarjan(i);
    int x=n+1;
    for (int i=1;i<=n;i++)
        if (c[i]==0){x=i;break;}
    sort(c+1,c+ans+1);
    printf("%d\n",ans);
    for (int i=1;i<=ans;i++)
        printf("%d ",c[i]);
    return 0;
}
```

---


# 佳佳的魔法药水

## 题目背景

发完了 $k$ 张照片，佳佳却得到了一个坏消息：他的 MM 得病了！佳佳和大家一样焦急万分！治好 MM 的病只有一种办法，那就是传说中的 $0$ 号药水…… 怎么样才能得到 $0$ 号药水呢？你要知道佳佳的家境也不是很好，成本得足够低才行……

## 题目描述

**存在 ab 相同 c 不同的情况，与题意相悖**。题还是可以做，但数据待修正。

得到一种药水有两种方法：可以按照魔法书上的指导自己配置，也可以到魔法商店里去买——那里对于每种药水都有供应，虽然有可能价格很贵。在魔法书上有很多这样的记载：

$1$ 份 A 药水混合 $1$ 份 B 药水就可以得到 $1$ 份 C 药水。（至于为什么 $1 + 1 = 1$，因为……这是魔法世界）好了，现在你知道了需要得到某种药水，还知道所有可能涉及到的药水的价格以及魔法书上所有的配置方法，现在要问的就是：

1. 最少花多少钱可以配制成功这种珍贵的药水；

2. 共有多少种不同的花费最少的方案（两种可行的配置方案如果有任何一个步骤不同则视为不同的）。假定初始时你手中并没有任何可以用的药水。


## 说明/提示

数据范围：

每一种药水的价格均 $\ge 1$ 且 $\le 2.8\times 10^4$。

样例说明：

最优方案有 $3$ 种，分别是：

- 直接买 $0$ 号药水；
- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，直接买 $2$ 号药水，然后配制成 $0$ 号药水；
- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，买 $3$ 号药水、$6$ 号药水配制成 $2$ 号药水，然后配制成 $0$ 号药水。

## 样例 #1

### 输入

```
7 
10 5 6 3 2 2 3 
1 2 0 
4 5 1 
3 6 2
```

### 输出

```
10 3```

# 题解

## 作者：半仙胡小桃 (赞：47)

[QAQ](https://www.luogu.org/problem/show?pid=1875)

迪杰斯特拉算法

cost[i]表示获得i药水所需要的最小代价，f[i]表示i药水是否已经找到了最小花费，ans[i]表示i药水在当前最小花费的方案数，f[i][j]表示i药水与j药水能够合成的药水

类似于迪杰斯特拉，每次找一个值最小但却没有确定最小值的药水，将其标记为最小值，然后枚举能与此药水合成药水的药水，用找到的药水与配对的药水更新合成药水的最小值

至于方案数，有两种情况，

1：两个原料药水合成的药水的原本最小花费等于原料药水的总花费，那么合成药水的方案数就需要在原本的基础上加上两个原料药水方案的乘积

2：两个原料药水合成的药水的原本最小花费等于原料药水的总花费，那么合成药水的方案数就等于两个原料药水方案的乘积

然后输出就行了！

顺便吐槽一下，题目上没有数据范围，害我RE了一次！

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int cost[9999],ans[9999];
int soc[3000][3000];
bool f[3000];
int main()
{
    int n;
    
    scanf("%d",&n);
    
    for(int i=1;i<=n;i++)
     scanf("%d",&cost[i]),ans[i]=1;
    int a,b,c; 
    while(scanf("%d%d%d",&a,&b,&c)!=EOF) 
     soc[a+1][b+1]=soc[b+1][a+1]=c+1;
    
    for(int i=1;i<n;i++)
     {
         int maxn=0x7fffffff;
         for(int j=1;j<=n;j++)
          if(!f[j]&&cost[j]<maxn) 
          b=j,maxn=cost[j];
        
        f[b]=1;
        
        for(int j=1;j<=n;j++)
        if(f[j]&&soc[b][j])
         {
             if(cost[b]+cost[j]==cost[soc[b][j]])
              ans[soc[b][j]]+=ans[b]*ans[j];
            if(cost[b]+cost[j]<cost[soc[b][j]]) 
             cost[soc[b][j]]=cost[b]+cost[j],ans[soc[b][j]]=ans[b]*ans[j];
         }
     }
     
     printf("%d %d",cost[1],ans[1]);
     
     return 0;
}
```

---

## 作者：钛战机 (赞：43)

这道题本来想求出拓扑序列然后动归的，然而它！存！在！环！

就用dijkstra来做。

不过它在更新最短路的时候有些不同，普通的dijkstra是在没有确定最短路的节点找出新的路更新，

这里要在已经求出最小药价的药水中查找。

不然在配药水方法的数量上会出错，因为未求出最小药价的药水的配方数量以后可能会更新。

（也不知自己的表述是否准确。。。）


---

## 作者：Seg_Tree (赞：30)

大致思路其他题解都讲得挺清楚了，但他们的djikstra都好野蛮...

小根堆优化+链式前向星照说应该是每个djikstra的标配 啊...开了这俩优化，吸个氧50ms，优越感油然而生~~好像也没比其他开O2的快了多少~~。~~哼，那是我不会卡常~~

本题解就来着重讲一下**这道题**的**小根堆优化**与**链式前向星**需要注意的一些问题。

emmmmm还有这题令人烦躁的读入方式

不会写标题行，题解就低端了很多

------------

Part.0 这道题与djikstra模板有何不同：

djikstra一个很重要的特征是**每当我要从一个点出发，更新其他点的最短路径时，这个点必须已经确定了最短路径的值，不会再改了，即vis[i]=1，而当前队列中已知距离起点最近的点一定是已经确定了最短路径的点，因为已经不可能有某种再拐一下的方法使该距离更近了。**（这玩意在我刚学djikstra的时候困扰了我好久~~其实也就是昨天~~）。

但对于这道题我们发现，当我们走的时候，我们要从**两个**起点出发，而非一个。我们已经知道，djikstra要求我们必须从已确定最短路径的点出发，那么对于两个起点该怎么办呢？~~很简单~~，只要等两个起点都是已知最短路径不就行了

在更新之前，我们判断一下另一个需要的药水是否已知最低消费即可。不用担心这样会不会漏掉配方，反正我们的前向星是存了两遍的。
```cpp
for(int i=head[u]; i; i=edg[i].nxt){
	int x=edg[i].u2,v=edg[i].v;
	if(ptn[x].v){
		if(ptn[v].cst>c+ptn[x].cst){
			ptn[v].ans=ptn[u].ans*ptn[x].ans;
			ptn[v].cst=c+ptn[x].cst;
			q.push(make_pair(ptn[v].cst,v));
		}
		else if(ptn[v].cst==c+ptn[x].cst){
			ptn[v].ans+=ptn[u].ans*ptn[x].ans;
		}
	}
}
```


------------

Part.2 链式前向星：

这应该是种十分普及的方法了。相比直接用矩阵存图，这种方法不但快，占内存还小，理解难度、码量也不大。讲真，这道题是数据少。要数据再大点，矩阵直接MLE，前向星倒还能撑很久

只不过这题我们在存边的时候还得存一下它所需的另一种药

也就是这样:

```cpp
void add_edg(int u1,int u2,int v){
	edg[++tot_edg].u2=u2;
	edg[tot_edg].v=v;
	edg[tot_edg].nxt=head[u1];
	head[u1]=tot_edg;
}
```

------------


十分，就对最后一个点的同志们看这里！！！！！！！！

但这道题中，有一个题面中未提到的坑点，两瓶相同的药是可以混成一瓶新药的，即A+A=C。

所以，在前向星存图的时候，我们要对代码作一下改动：
```cpp
		add_edg(u1,u2,v);
		if(u1==u2)continue;
		add_edg(u2,u1,v);
```
以防止重复存路。

------------

此外，有关该题的读入方式：

```cpp
	while(scanf("%d%d%d",&A,&B,&C)!=EOF){
```
这样既可在提交时通过。但在自己输入时，完成后需要再输入 ‘回车’ 然后是 ‘ctrl+z’既可完成输入。

希望考试的时候别考这种奇怪的输入方式。

------------

附完整代码（感觉意义不大）
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
struct Eg{
	int u2,v,nxt; 
}edg[1000001];
int head[1001],tot_edg;
void add_edg(int u1,int u2,int v){
	edg[++tot_edg].u2=u2;
	edg[tot_edg].v=v;
	edg[tot_edg].nxt=head[u1];
	head[u1]=tot_edg;
}

struct P{
	int cst,ans;
	bool v;
}ptn[1001];

typedef pair<int,int>pr;
priority_queue<pr,vector<pr>,greater<pr> >q;

int main(){
	int n;
	cin>>n;
	for(int i=0; i<n; i++){
		cin>>ptn[i].cst;
		ptn[i].ans=1;
		q.push(make_pair(ptn[i].cst,i));
	}
	
	int u1,u2,v;
	while(scanf("%d%d%d",&u1,&u2,&v)!=EOF){
		add_edg(u1,u2,v);
		if(u1==u2)continue;
		add_edg(u2,u1,v);
	}
	while(!q.empty()){
		int c=q.top().first,u=q.top().second;
		q.pop();
		if(c!=ptn[u].cst)continue;
		ptn[u].v=1;
		for(int i=head[u]; i; i=edg[i].nxt){
			int x=edg[i].u2,v=edg[i].v;
			if(ptn[x].v){
				if(ptn[v].cst>c+ptn[x].cst){
					ptn[v].ans=ptn[u].ans*ptn[x].ans;
					ptn[v].cst=c+ptn[x].cst;
					q.push(make_pair(ptn[v].cst,v));
				}
				else if(ptn[v].cst==c+ptn[x].cst){
					ptn[v].ans+=ptn[u].ans*ptn[x].ans;
				}
			}
		}
	}
	cout<<ptn[0].cst<<" "<<ptn[0].ans;
	return 0;
}
```


---

## 作者：KKKZOZ (赞：28)

## 思路

我们可以从 DP 的角度来考虑这道题。

设 $f[c]$ 代表药品 $C$ 需要的最小花费，我们可以写出状态转移方程：$f[c]=\min(w[c],f[a]+f[b])$，简单分析后就可以发现，状态与状态之间可能会存在环形的依赖关系（即不是一张 DAG，没有直接的拓扑序来供我们转移）。

通常情况下，在“图状”的 DP 时，遇到环形依赖，有两个解决办法：
- 利用 Dijkstra 的贪心思想，即状态之间转移时，代价都是正的，所以能把目前队列中的最小代价的状态确定为一个最优状态。换句话说，Dijkstra 是在“有单调性的图上”，利用单调性可以确定出一个拓扑序，按照这个序列进行转移就能得到正确答案。
- 借助 SPFA 算法进行动态规划，即在这张图上多次迭代，最后把答案收敛出来。

本题两种方法都能做，但大部分题解都用的是 Dijkstra，所以这里我们采用 SPFA 来进行迭代求解。

先解决最小值怎么求：

我们将药水抽象为点，将“$1$ 份 $A$ 药水混合 $1$ 份 $B$ 药水就可以得到 $1$ 份 $C$ 药水”抽象为“$C$ 有一组边能达到它的边，分别为 $A$ 到 $C$ 和 $B$ 到 $C$”，然后枚举更新时按照组的单位来更新。

每个点都有个基础状态，即花费为 $w[i]$ 的状态，由于我们不知道从哪个点开始更新最好，所以我们把所有点都入队。

对于每个点，枚举能到达它的边（以组为单位），计算当前点 $u$ 是否能被更新，如果点 $u$ 能被更新，说明药水 $u$ 的最小花费变小了，所以**所有以药水 $u$ 为原料的药水的花费**都可能变小，所以都要入队。

这样就能得到 $0$ 号药水的最小花费，我们再来考虑怎么样计算最短路径的条数：

可能有人会有疑问，为什么不在计算最短路的同时记录最短路的条数呢？因为那种记录最短路的条数的思想也是基于 DP 的思想，只有在拓扑序下转移才能被正确的求出来，然而 SPFA 不是按照拓扑序进行转移的。

我们可以采用记忆化搜索的方式进行计算，因为整个最短路径的 DAG 图已经被构造出来了，递归回去计算就行。



## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010, M = 1000001;
int n, cnt = 0;
int f[N], head[N], w[N], tot[N];
bool vis[N];

struct Edge {
    int a, b, next;
};
Edge e[M];
vector<int> belongs[N];

void add(int a, int b, int v) {
    e[++cnt] = {a, b, head[v]};
    head[v] = cnt;
}

void spfa() {
    queue<int> q;
    // 将每个点入队
    for (int i = 0; i <= n - 1; i++) {
        q.push(i);
        f[i] = w[i];
        vis[i] = 1;
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i = head[u]; i != -1; i = e[i].next) {
            // 枚举每组边
            int a = e[i].a, b = e[i].b;
            if (f[u] > f[a] + f[b]) {
                f[u] = f[a] + f[b];
                // 如果药水u的花费能够降低，那么由药水u合成出来的药水的花费都有可能降低
                // 所以要把这些点都放回队列里
                for (auto v: belongs[u])
                    if (vis[v] == 0)
                        vis[v] = 1, q.push(v);
            }
        }
    }
}

int dfs(int u) {
    if (tot[u] != 0) return tot[u];
    if (f[u] == w[u]) tot[u]++;
    for (int i = head[u]; i != -1; i = e[i].next) {
        int a = e[i].a, b = e[i].b;
        if (f[u] == f[a] + f[b]) {
            tot[a] = dfs(a);
            tot[b] = dfs(b);
            tot[u] += tot[a] * tot[b];
        }
    }
    return tot[u];
}

int main() {
    ios::sync_with_stdio(0);
    cout.tie(0);
    cin.tie(0);
    cin >> n;

    for (int i = 0; i < n; i++) cin >> w[i], head[i] = -1;
    int a, b, c;
    while (cin >> a >> b >> c) {
        add(a, b, c);
        if (a == b) continue;
        // 这里记录a和b分别能合成哪些药水，等会儿状态更新时会用到
        belongs[a].push_back(c);
        belongs[b].push_back(c);
    }
    spfa();
    dfs(0);
    cout << f[0] << " " << tot[0] << endl;
    return 0;
}
```

## 总结

+ 以 DP 的思想来思考图论问题其实很常见，比如分层图问题从 DP 角度看就是，是二维 DP 问题（一维为点，二维为附加状态，比如用了几次免费），如果这道题你会了，那么[这道题](https://www.luogu.com.cn/problem/P4042)你也一定会做啦，快去试试吧！


---

## 作者：依依 (赞：11)

正解：类似最短路的思想

将x+y==z看成一条边

每次从图中选择一个已经被更新过的花费最小的点x,

用x去更新能更新的点

直到保留最优解

 

官方题解：

做法：我们可以用Dijkstra的思想，用已知来更新未知。

我们用一个v数组来标记一种药水的最小花费是否确定，如果v[i]为真，则表示i号药水的最小花费已经确定，否则反之。

同时，用cost[i]和ans[i]记录当前求出的i号药水的最小花费和满足最小花费的方案个数，

f[i][j]记录一个i号药水和一个j号药水能够合成的药水编号（是不是很像邻接矩阵？），

cost[i]初始化为药水在商店中的价格，ans[i]初始化为1。

每次选择一个v[k]为假并且cost[k]最小的k，

可以证明这个k号药水再没有其他方案使得它的最小花费更小了，然后寻找与它相关联的配方，如果k号药水可以跟另一个最小花费已经确定的j号药水合成一种药水，

则更新cost[f[j][k]]和ans[f[j][k]]：如果cost[j]+cost[k]<cost[f[j][k]]，

则将cost[f[j][k]]更新为cost[j]+cost[k]，并将ans[i]更新为1；

如果cost[j]+cost[k]=cost[f[j][k]]，则将ans[f[j][k]]加上ans[j]*ans[k]。

更新完所有和k号药水有关的配方之后，将v[k]赋值为真，

重复上述过程直到所有药水都更新过为止。

最后输出cost[0]和ans[0]即可。

[hello](https://www.cnblogs.com/adelalove/p/9134982.html)

---

## 作者：Joyce_Jiang (赞：3)

这道题其实是一道比较裸的dijkstra，就是注意一下 当两种材料合成一种东西时，其中一个必须已经被更新到最优方案才能更新合成的东西，另外数量很少，邻接矩阵比较方便，也不回爆空间

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
int dist[1001];
int f[1001][1001];
bool vis[1001];
int cnt[1001];
void dijkstra()
{
    for(int i=1;i<=n;i++)
    {
        int u,t=2100000000;
        for(int j=1;j<=n;j++)
        {
            if(!vis[j]&&dist[j]<t)
            {
                u=j;
                t=dist[j];
            }
        }
        if(t==2100000000)break;
        vis[u]=true;
        for(int j=1;j<=n;j++)
        {
            if(!f[u][j])continue;
            if(!vis[j])continue;
            if(dist[f[u][j]]>t+dist[j])
            {
                dist[f[u][j]]=t+dist[j];
                cnt[f[u][j]]=cnt[u]*cnt[j];
            }
            else if(dist[f[u][j]]==t+dist[j])
            cnt[f[u][j]]+=cnt[u]*cnt[j];
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%d",&dist[i]),cnt[i]=1;
    int u,v,t;
    while(scanf("%d%d%d",&u,&v,&t)!=EOF)
    {
        f[u+1][v+1]=t+1;
        f[v+1][u+1]=t+1;
    }
    dijkstra();
    printf("%d %d",dist[1],cnt[1]);
    return 0;
}
```

---

## 作者：VitualDieties (赞：3)

感觉这题好神啊,记录i j的父节点为a[i][j]，然后dijkstra：先选出一个最便宜的，将它标记为确定了最小价值的点，再根据这个搭配其他确定了最小价值的点更新别的点（方案数？更新时乘法加法原理即可）PS：EOF屏幕终止回车后ctrl + z

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int INF = 10000000;
int a[1010][1010],N,dis[1010],head[1010],num_edge = 0,v[1010];
int cnt[1010];
struct node
{
    int dis;
    int to;
    int next;
}edge[1010];
int add_edge(int from,int dis,int to)
{
    edge[++num_edge].next = head[from];
    head[from] = num_edge;
    edge[num_edge].dis = dis;    
    edge[num_edge].to = to;
}
int getin()
{
    int x = 0,f = 1;
    char ch = getchar();
    while(ch > '9'||ch < '0') {if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0'&&ch <= '9') {x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
int dijkstra()
{
    for(int i = 0;i < N; i++) cnt[i] = 1;
    for(int i = 1;i <= N; i++)
    {
      int mark,MIN = INF;
      for(int j = 0;j < N; j++)
           if(MIN > dis[j]&&!v[j])
        {
          MIN = dis[j];
          mark = j;
        }
       v[mark] = 1;
      for(int j = 0;j < N; j++)
       if(a[mark][j] != -1&&v[j])
       { 
         if(dis[a[mark][j]] > dis[mark] + dis[j])
         {
          dis[a[mark][j]] = dis[mark] + dis[j];
          cnt[a[mark][j]] = cnt[mark] * cnt[j];
         }
         else if(dis[a[mark][j]] == dis[mark] + dis[j]) 
         cnt[a[mark][j]]+= cnt[mark] * cnt[j];
       } 
    }
    printf("%d %d",dis[0],cnt[0]);
}
int main()
{
    N = getin();
    for(int i = 0;i < N; i++)
     dis[i] = getin();
    int A,B,C;
    memset(a,-1,sizeof(a));
    while(scanf("%d%d%d",&A,&B,&C)!=EOF)
    {
     a[A][B] = C; a[B][A] = C;
    }
    dijkstra();
    return 0;
}
```

---


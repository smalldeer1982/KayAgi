# 套利

## 题目描述

套利是利用汇率差异实现货币增值。例如，1美元可以兑换0.5英镑、1英镑可以兑换10法郎、1法郎可以兑换0.21美元。接下来，一个聪明的交易商就可以从1美元开始，0.5 \* 10.0 \* 0.21 =1.05美元，获得了5%的利润。

你的任务是写一个程序，从输入文件读入汇率清单，然后决定套利是有可能的或没有可能的。


## 样例 #1

### 输入

```
3
USDollar
BritishPound
FrenchFranc
3
USDollar 0.5 BritishPound
BritishPound 10.0 FrenchFranc
FrenchFranc 0.21 USDollar

3
USDollar
BritishPound
FrenchFranc
6
USDollar 0.5 BritishPound
USDollar 4.9 FrenchFranc
BritishPound 10.0 FrenchFranc
BritishPound 1.99 USDollar
FrenchFranc 0.09 BritishPound
FrenchFranc 0.19 USDollar

0
```

### 输出

```
Case 1: Yes
Case 2: No
```

# 题解

## 作者：Created_equal1 (赞：14)

把汇率表抽象成一个有向图，每个货币是一个结点，每条边上的权值就是汇率。

无法套利的情况分两种

1、没有环，即最后无法回到该种货币

2、有环，但是得到的利率不大于1

我们可以跑一遍单源最长路，用SPFA来判环，只是一般的松弛条件中的加号需要改成乘号。

可以证明如果环上所有边的权值之积大于1，那么一定可以用SPFA判定出有向图中存在环

```cpp

(
#include <map>
#include <deque>
#include <string>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const size_t Max_N(35);
const size_t Max_M(10000);

size_t Adj[Max_M], Next[Max_M], Head[Max_N];
double Weight[Max_M];

double Dist[Max_N];
bool In_queue[Max_N];
unsigned int Times[Max_N];

unsigned int n, m;

unsigned int fu;

bool spfa(const size_t &S)
{
    memset(Dist, 0, sizeof(Dist));
    memset(In_queue, 0, sizeof(In_queue));
    memset(Times, 0, sizeof(Times));
    std::deque<size_t> Q;
    
    Dist[S] = 1.0;
    In_queue[S] = true;
    Q.push_back(S);
    Times[S] = 1;
    
    while (!Q.empty())
    {
        size_t top = Q.front();
        In_queue[top] = false;
        Q.pop_front();
        
        for (int i = Head[top];i != 0;i = Next[i])
            if (Dist[Adj[i]] < Dist[top] * Weight[i])
            {
                Dist[Adj[i]] = Dist[top] * Weight[i];
                if (!In_queue[Adj[i]])
                {
                    In_queue[Adj[i]] = true;
                    Q.push_back(Adj[i]);
                    ++Times[Adj[i]];
                    if (Times[Adj[i]] >= n)
                        return true;
                }
            }
    }
    
    return false;
}

int main()
{
    while (cin >> n, n)
    {
        unsigned int tot = 0;
        ++fu;
        memset(Adj, 0, sizeof(Adj));
        memset(Next, 0, sizeof(Next));
        memset(Head, 0, sizeof(Head));
        memset(Weight, 0, sizeof(Weight));
        map<string, unsigned int> v;
        string b, e;
        double number;
        for (unsigned int i = 1;i <= n;++i)
            v[(cin >> b), b] = i;
        cin >> m;
        while (m--)
        {
            ++tot;
            cin >> b >> number >> e;
            Adj[tot] = v[e];
            Weight[tot] = number;
            Next[tot] = Head[v[b]];
            Head[v[b]] = tot;
        }
        for (unsigned int i = 1;i <= n;++i)
            if (spfa(i))
            {
                printf("Case %u: Yes\n", fu);
                goto loop;
            }
        printf("Case %u: No\n", fu);
        loop:
            ;
    }
    
    return 0;
}
)

```

---

## 作者：米奇奇米 (赞：14)

[P1931套利](https://www.luogu.org/problemnew/show/P1931)
## 翻了一下题解，只有一篇，而且是SPFA，那么我就用Floyed来跑一下这道题
## 先看一下数据范围N<30,Floyed跑一遍的时间复杂度大概为O（n^3）:
## 30^3=27000,显然不会超时呀！
## 那么我们只要跑一遍Floyed最长路,同时计算最大的可以转换到的钱，与1比较一下大小，如果>1,显然可以实现套利呀！
## 我们先来看一下Floyed这部分的CODE：
```cpp
bool floyd(){//Floyed单元最长路
	int i,j,k;
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++){
				if(a[i][j]<a[i][k]*a[k][j]){
					a[i][j]=a[i][k]*a[k][j];//计算各转换货币得到的最大值
				}
			}
	for(int i=1;i<=n;i++){
		if(a[i][i]>1)//如果转换来的钱大于1，就实现了套利
			return true;
	}
	return false;
}
```
## 然后我们来看一下如何来建图，先看一下这部分的CODE：
```cpp
void addEdge(char str1[],double x,char str2[]){
	string s1=str1;
	string s2=str2;//先记录下两种货币的名称
	int u,v;
	u=mp[s1];
	v=mp[s2];
	a[u][v]=x;//用a数组记录下两种货币之间的汇率
}
```
## 然后我们就看一下完整的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int const N=35;
map<string,int>mp;
double a[N][N];
int n;
void addEdge(char str1[],double x,char str2[]){
	string s1=str1;
	string s2=str2;
	int u,v;
	u=mp[s1];
	v=mp[s2];
	a[u][v]=x;
}
bool floyd(){
	int i,j,k;
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++){
				if(a[i][j]<a[i][k]*a[k][j]){
					a[i][j]=a[i][k]*a[k][j];
				}
			}
	for(int i=1;i<=n;i++){
		if(a[i][i]>1)
			return true;
	}
	return false;
}//以上部分已经解释过了
int main(){
	int m,i,j,count,t=0;
	double x;
	char str[20],str1[20],str2[20];
	while(scanf("%d",&n)&&n){
		count=0;
		mp.clear();
		getchar();
		for(i=1;i<=n;i++)
			for(j=1;j<=n;j++){
				if(i==j)
					a[i][j]=1;
				else
					a[i][j]=0;
			}
		for(i=0;i<n;i++){
			scanf("%s",str);
			string s=str;
			mp[s]=++count;//用来记录货币的种类数量
			/cout<<"mp[s]="<<mp[s]<<endl;
		}
		scanf("%d",&m);
		getchar();
		for(i=0;i<m;i++){
			scanf("%s%lf%s",str1,&x,str2);
			addEdge(str1,x,str2);//建图
		}
		if(floyd())//跑一遍Floyed，输出即可
			printf("Case %d: Yes\n",++t);
		else
			printf("Case %d: No\n",++t);
	}
	return 0;
}
```




---

## 作者：UnyieldingTrilobite (赞：3)

不知道为什么这题数据范围这么小。

极小的数据范围导致floyd，~~逝去的~~SPFA，甚至bellman-ford都能过。

这里就讲一讲SPFA.

首先，把汇率抽象成一个图，若能套利那么一定是图中有**边权之积>1**的环。

为了避免浮点误差（~~其实是想Ctrl+C+V模板~~）读入时处理，把汇率转化为**其对数**。

而众所周知$\ln a+\ln b=\ln(ab)$.

所以图中有**边权之积>1**的环<=>处理后的图中有**正**环。

抓正环和抓负环基本没区别（就把一个>改成<），直接套上SPFA板子即可。

最后上代码（~~老古董代码，马蜂随意吐槽~~）：
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>to[501]; 
vector<double>w[501];
int n,m,cnt[501];
bool in[501];
double d[501],r;
map<string,int>id;//字典(建图用) 
string x,y;
bool spfa(){//SPFA
    memset(d,0,sizeof(d));
    memset(in,0,sizeof(in));
    memset(cnt,0,sizeof(cnt));
    queue<int>qu;
	for(int i=0;i<n;i++)qu.push(i),in[i]=cnt[i]=1;//节点全入队,价值初始化为1 
	while(!qu.empty()){ 
		int f=qu.front(),v;qu.pop();in[f]=0; 
		for(int i=0;i<to[f].size();i++)
		if(d[v=to[f][i]]<w[f][i]+d[f]){ 
		d[v]=w[f][i]+d[f];  
		if(!in[v])in[v]=1,cnt[v]++,qu.push(v); 
		if(cnt[v]>n)return 1;
		}
	}
    return 0; 
}//判环 
int main()                         
{
    for(int shuju=1;;++shuju){
      id.clear();
      for(int i=0;i<n;++i)to[i].clear(),w[i].clear();
      cin>>n;if(!n)return 0;
      for(int i=0;i<n;i++)cin>>x,id[x]=i;
      cin>>m;
      for(int i=0;i<m;i++){
        cin>>x>>r>>y;
        to[id[x]].push_back(id[y]);
        w[id[x]].push_back(log(r));
      }//建图 
      cout<<"Case "<<shuju<<": "; 
      cout<<(spfa()?"Yes":"No")<<endl;
    }
	return 0;
}
```
Over.

题外话：这种做法由于没有浮点数乘除法所以可以很好地避免浮点误差影响~~虽然听说这题都可以~~。

---

## 作者：Zekrom (赞：2)

### 为什么不用dijkstra     
首先dijk求最短路是没问题的，但路径相乘要求对数转化为路径相加转化为最短路问题，但是题目要求判正环，这要求使用spfa，综合考虑直接使用spfa求最长路同时判负环，~~就很省代码啊~~      
上代码    
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<map>
#include<cmath> 
#define inf 0x3f3f3f3f
#define N 40
using namespace std;
int n,cnt,head[N],tot,vis[N],m,tim[N];
double d[N];
map<string,int>mp;
struct Edge{
	int v,next;double val;
}edge[N*N*2]; 
inline int read(){
	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return x*f;
}
inline void add(int x,int y,double d){edge[++tot].v=y;edge[tot].next=head[x];head[x]=tot;edge[tot].val=d;}
bool spfa(int s){
	queue<int>q;q.push(s);for(int i=1;i<=n;i++)d[i]=-inf;d[s]=0;memset(vis,0,sizeof(vis));vis[s]=1;memset(tim,0,sizeof(tim));
	while(q.size()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].v;double z=edge[i].val;
			if(d[v]<d[u]+z){
				d[v]=d[u]+z;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
					tim[v]++;
					if(tim[v]>=n)return true;
				}
			} 
		}
	}return false;
}
int main(){
	while(1){
		n=read();bool flag=0;
		if(n==0)break;cnt++;tot=0;memset(head,0,sizeof(head)); 
		for(int i=1;i<=n;i++){
			char ch[N];	scanf("%s",ch);string str;str=ch;
			mp[str]=i;
		}m=read();
		for(int i=1;i<=m;i++){
			char ch[N];scanf("%s",ch);string str=ch;int x=mp[str];
			double rate;scanf("%lf",&rate);rate=log(rate);
			scanf("%s",ch);str=ch;int y=mp[str];
			add(x,y,rate);
		}
		if(spfa(1))
			printf("Case %d: Yes\n",cnt);
		else printf("Case %d: No\n",cnt);
	}
	return 0;
}

```


---

## 作者：shihao (赞：1)

这道题目就是Arbitrage我就发一下我的做法。
```cpp
#include<iostream> 
#include<cstring>
using namespace std;  
#define N 50  
#define LL __int64  
const int inf=0;  
struct node  
{  
    int u,v;  
    double d;  
}e[N*N];  
int m,n;  
double dis[N];  
bool bellman()  
{  
    int i,j,u,v;  
    for(i=0;i<n;i++)      //初始化为0  
        dis[i]=inf;  
    dis[0]=1;  
    for(i=1;i<=n;i++)     //从dis[0]递推到dis[1]....dis[n];  
    {  
        for(j=0;j<m;j++)  
        {  
            u=e[j].u;  
            v=e[j].v;  
            if(dis[u]&&dis[v]<dis[u]*e[j].d)   //若经过某一点能使从源点到该终点的最短路缩短，此为增大  
                dis[v]=dis[u]*e[j].d;          //则修改该点值，即松弛  
        }  
    }  
    return dis[0]>1;  
}  
int main()  
{  
    int i,j,k,cnt=1;  
    double d;  
    char str[N][N],a[N],b[N];  
    while(scanf("%d",&n),n)  
    {  
        for(i=0;i<n;i++)  
            scanf("%s",str[i]);  
        scanf("%d",&m);  
        for(i=0;i<m;i++)  
        {  
            scanf("%s %lf %s",a,&d,b);  
            for(j=0;strcmp(str[j],a);j++)  
                ;  
            for(k=0;strcmp(str[k],b);k++)  
                ;  
            e[i].u=j;  
            e[i].v=k;  
            e[i].d=d;  
        }  
        printf("Case %d: ",cnt++);  
        bool flag=bellman();  
        if(flag)  
            printf("Yes\n");  
        else  
            printf("No\n");  
    }  
    return 0;  
}  
```


---

## 作者：说好不哭 (赞：1)

# P1931 套利 题解
## 此题解可以作为  判断环的模板  和  暴力哈希的模板
### 本题做法 1.处理字符串 2.判断是否有环。
### 在题解中想提及一下有一篇floyd的题解，完全是因为数据小才能用floyd，所以判断环还是要用spfa。



```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=31,M=1e4+5;
int n,m,i,j,sum,cnt,u,v,now;
double ww;
int head[N],q[9*M],tim[N];
double d[N];
char str[1001],w[M][1001];
bool f[N];

struct edge{
int next,to;	
double w;		
}e[M];

inline void update(char s[]){
int i,len;
sum++;
len=strlen(s);
    for (i=0; i<len; i++) 
    w[sum][i]=s[i];
}
inline int find(char s[]){
int i,k,len;	
bool jay=false;
len=strlen(s); 
    for (k=1; k<=sum; k++)
    {
    if (strlen(w[k])==len) jay=true;
    for (i=0; i<len; i++) if (w[k][i]!=s[i]) {jay=false; break;}
    if (jay==true) return k;
    }
}         //暴力哈希
inline void add(int u,int v,double w){
cnt++;
e[cnt].next=head[u];	
e[cnt].to=v;
e[cnt].w=w;
head[u]=cnt;
}

inline bool spfa(){
memset(d,0,sizeof(d));
memset(q,0,sizeof(q));
memset(f,false,sizeof(f));
memset(tim,0,sizeof(tim));
int l=1,r=2,s=1,k,u,v,i;	

q[l]=s; d[s]=1.0;
    while (l<r)
    {
    u=q[l],l++,f[u]=false;	
    k=head[u];
        while (k>0)
        {
        v=e[k].to;	
            if (d[v]<d[u]*e[k].w){
            d[v]=d[u]*e[k].w;
            if (f[v]==false) q[r]=v,r++,f[v]=true;
            tim[v]++;
            if (tim[v]==n) return true;
            }
        k=e[k].next;
        }
    }
return false;	
}           //spfa判环


int main(){
scanf("%d",&n);	

while (n!=0)
{
sum=0;
memset(w,0,sizeof(w));	
for (i=1; i<=n; i++) scanf("%s",str),update(str);

memset(head,0,sizeof(head));
for (i=1; i<=cnt; i++) e[i].next=e[i].to=0,e[i].w=0.0;
cnt=0; 
scanf("%d",&m);
    for (i=1; i<=m; i++) 
    {
    scanf("%s",str);
    u=find(str);
    scanf("%lf",&ww);
    scanf("%s",str);
    v=find(str);
    add(u,v,ww);
    }
    
now++;
printf("Case %d: ",now);
if (spfa()==true) puts("Yes"); else puts("No");	

scanf("%d",&n);
}
return 0;	
}
```


---


# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# 题解

## 作者：Ning_Mew (赞：51)

**Solution：**


这道题目思路比较简单：


1.预处理出最短路，因为范围小，采用弗洛伊德算法预处理


2.处理出从i到j点中间最短路条数[这一步算是整个代码中的精华，也是最难的的一部分了吧（我认为的最难，蒟蒻哎ORZ）]


3.就是计算答案啦啦


 

然后呢，这题就是思考那个奇奇怪怪的计算式子了



I(v)=∑(s<>v,t<>v)Cs,t(v) / Cs,t

**A.首先呢解释下这个式子：**




　　a.(s<>v,t<>v)     s!=v&&t!=v 很好理解吧

　　b.Cs,t(v)   是所有s到t的最短路中，经过v的条数

c.Cs,t       是从s到t的最短路条数


**B.然后思路步骤一很简单，就不说了，不清楚可以自行问度娘**


**C.步骤二的方法有很多我知道有两种**


a.在弗洛伊德求最短路时同时更新路径条数[我用的这种，真的好容易打%%%想出来这种方法的人]


```cpp
for(int k=1;k<=n;k++)//枚举中间点
    for(int i=1;i<=n;i++)//枚举开头
    for(int j=1;j<=n;j++)//枚举结尾
    {
        if(dis[i][k]==INF&&dis[k][j]==INF)continue;//INF是初始化定义的最大值
        if(dis[i][j]>dis[i][k]+dis[k][j])//满足更新条件
        {
            dis[i][j]=dis[i][k]+dis[k][j];//更新最短路径的值
            edge[i][j]=edge[i][k]*edge[k][j];//更新最短路径条数
            continue;
        }
        if(dis[i][j]==dis[i][k]+dis[k][j])//和已算出来的最短路长度相等
        {edge[i][j]+=edge[i][k]*edge[k][j];}//累加路径条数
    }//dis  长度    edge   条数
```

b.这种方法见我的另一篇博客，里面讲的很详细，这个代码打的重点在  求入度次数和拓扑排序


**D.步骤三计算答案，这个重点就是在处理Cs,t(v)**


1.dis[s][t]=dis[s][v]+dis[v][t]   这个很好理解吧   如果S-V的最短距离加上V-T的最短距离等于S-T的最短距离   那么V一定在S-T的最短路上


2.所以  Cs,t(v)= S-V的路径条数\*V-T的路径条数


3.另外 要枚举所有的 S - T  注意式子的∑(s<>v,t<>v)


4.应该没了  顺便贴下我这部分的代码


```cpp
for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        for(int k=1;k<=n;k++)
        {
            if(i==j||j==k||i==k)continue;
            if(dis[j][i]+dis[i][k]==dis[j][k])
                ans[i]+=(1.0*edge[j][i]*edge[i][k])/edge[j][k];
        }
    }
```
 

最后，还要用拓扑排序的同学注意一点就是：重边，某点的入度被减为0[每有一条边指向点K，点K入度数减一，更新到K点路径条数]才能入队列，向下传递记录条数的数值。否则来一条边向下传一次，会使条数计算错误。[悲伤地是，我没改对这个注意的点，还是只有60分 ORZ][另一种方法过了]


贴一下整体AC代码吧


```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#define LL long long
using namespace std;
int read()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x;
}
int n,m;
LL INF;
LL dis[100+10][100+10],edge[100+10][100+10];
double ans[100+10];
int main()
{
    freopen("bestlink.in","r",stdin);
    freopen("bestlink.out","w",stdout);
    n=read();m=read();
    memset(dis,0x7f,sizeof(dis));
    memset(edge,0,sizeof(dis));
    INF=dis[1][1];
    for(int i=1;i<=m;i++)
    {
        LL x,y,z;
        x=read();y=read();z=read();
        dis[x][y]=dis[y][x]=z;
        edge[x][y]=edge[y][x]=1;
    }
    for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        if(dis[i][k]==INF&&dis[k][j]==INF)continue;
        if(dis[i][j]>dis[i][k]+dis[k][j])
        {
            dis[i][j]=dis[i][k]+dis[k][j];
            edge[i][j]=edge[i][k]*edge[k][j];
            continue;
        }
        if(dis[i][j]==dis[i][k]+dis[k][j])
        {edge[i][j]+=edge[i][k]*edge[k][j];}
    }
/*    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)cout<<i<<' '<<j<<' '<<edge[i][j]<<endl;*/
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        for(int k=1;k<=n;k++)
        {
            if(i==j||j==k||i==k)continue;
            if(dis[j][i]+dis[i][k]==dis[j][k])
                ans[i]+=(1.0*edge[j][i]*edge[i][k])/edge[j][k];
        }
    }
    for(int i=1;i<=n;i++)
        printf("%0.3f\n",ans[i]);
    return 0;
}
```
[不要脸的贴上自己的博客](http://www.cnblogs.com/Ning-Mew/)


---

## 作者：Register (赞：12)

因为题目中的公式会求到每一个起点$s$到终点$t$，且$n$只有$100$，所以我们就想到了$Floyd$

要求求$s$到$t$的路径条数，可以在$Floyd$的同时统计条数，在建边的时候将$u$到$v$条数设为$1$

在$Floyd$的时候我们如何更新条数呢？其实很简单。

	dis[i][j]从i点到j点的最短路
    sum[i][j]从i点到j点的最短路条数
	如果dis[i][k]+dis[k][j]等于dis[i][j]那么sum[i][j]的条数会增加（长短一样），根据乘法原理，sum[i][j]加上sum[i][k]*sum[k][j]
    如果小于的话，dis要更新，sum变成sum[i][k]*sum[k][j]

最后如何统计呢?

	每一个k点，枚举每一个i和j，如果dis[i][k]+dis[k][j]等于dis[i][j]，那么就加上sum[i][k]*sum[k][j]除以sum[i][j]（i、j的总条数和经过k的条数）
    
注意：$dis$最初要赋一个足够大的值，$sum$最初是$0$，$ans$因为要精度，所以用$double$

$code:$

```cpp
#include <cstdio>
int n,m,u,v;
double ans,dis[101][101],sum[101][101];
int read(){
	char ch=getchar();int res=0,w=1;
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
	return res*w;
}
int main(){
	n=read();m=read();
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++) dis[i][j]=0x3fffffff;
	while(m--) {u=read();v=read();dis[u][v]=dis[v][u]=read();sum[u][v]=sum[v][u]=1;}
	for(register int k=1;k<=n;k++)
		for(register int i=1;i<=n;i++)
			for(register int j=1;j<=n;j++)
				if(i!=j&&j!=k&&i!=k)//Floyd
				{
					if(dis[i][k]+dis[k][j]==dis[i][j]) sum[i][j]+=sum[i][k]*sum[k][j];//等于
					else if(dis[i][k]+dis[k][j]<dis[i][j]) {dis[i][j]=dis[i][k]+dis[k][j];sum[i][j]=sum[i][k]*sum[k][j];}//小于
				}
	for(register int k=1;k<=n;k++)///统计
	{
		ans=0;
		for(register int i=1;i<=n;i++)
			for(register int j=1;j<=n;j++)
				if(j!=i&&k!=i&&j!=k&&dis[i][k]+dis[k][j]==dis[i][j])/*判断*/ ans+=sum[i][k]*sum[k][j]/sum[i][j];//公式
		printf("%.3lf\n",ans);//输出
	}			
	return 0;
}
```


---

## 作者：人殇物已非 (赞：9)

本来很水的一道题，算是我做过的最简单的$NOI$的题了，结果有一点点小细节卡了我不知道好久。。调了一年终于调出来了。

大眼睛一看$n<=100$，简直在疯狂暗示你用$Floyd$，然后一看每个点都要输出，那不就是$Floyd$正好了么。再读题，哦哦每两个点之间的关系都要有，$Floyd$没跑了。

然后考虑怎么做呢，首先肯定要求出$dis[i][j]$为两两之间最短路，然后题目要求一个最短路的个数，那就用一个$ce[i][j]$（是$cntedge$，不是$compile$ $error$......）记录一下两两点之前最短路个数，这个也很好求，乘法原理就行了。

~~**得到这两个东西了，难道你还不会计算答案？**~~

#### $longlong!$
有些地方不用$longlong$，有些地方一定要$longlong$，习惯$int$ $tmp$开中间变量的我死的好惨。。

### $code:$
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=110,maxm=4510;
int n,m,cnt,last[maxn];
long long dis[maxn][maxn];
long long ce[maxn][maxn];
double value[maxn];
inline void add(int u,int v,int w){
    dis[u][v]=w;
    ce[u][v]++; 
}
int main(){
    cin>>n>>m;
    memset(dis,0x3f,sizeof(dis));
    for(int i=1,u,v,w;i<=m;i++){
        scanf("%d %d %d",&u,&v,&w);
        add(u,v,w),add(v,u,w);
    }
    for(int k=1;k<=n;k++){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(dis[i][j]>dis[i][k]+dis[k][j]){
                    dis[i][j]=dis[i][k]+dis[k][j];
                    ce[i][j]=ce[i][k]*ce[k][j];
                }
                else if(dis[i][j]==dis[i][k]+dis[k][j]){
                    ce[i][j]+=ce[i][k]*ce[k][j];
                }
            }
        }
    }
    for(int v=1;v<=n;v++){//计算v的value 
        for(int s=1;s<=n;s++){
            if(s==v) continue;
            for(int t=1;t<=n;t++){
                if(t==v || s==t) continue;
                if(dis[s][v]+dis[v][t]==dis[s][t]){
                    long long tmp=ce[s][v]*ce[v][t];
                    value[v]+=1.0*tmp/ce[s][t];
                }
            }
        }
    }
    for(int i=1;i<=n;i++){
        printf("%.3lf\n",value[i]);
    }
    return 0;
}
```



---

## 作者：Rubidium_Chloride (赞：7)

~~嘿遇到一道水蓝题题解居然还能提交题解~~

~~话说这NOI题有点简单？~~

## 0.前言

进[博客](https://www.luogu.com.cn/blog/Rolling-blog1424/)看效果更好呦！

让我们进入正题：

## 1.题目大意

简单来说就是求每个点的$I(v)$，其中$I(v)$的定义是：

$$I(v)=\sum \limits_{s \neq v, t \neq v}{\frac{C_{s,t}(v)}{C_{s,t}}}$$

然后$C_{s,t}$ 定义为$s,t$之间最短路条数，而$C_{s,t}(v)$定义为$s,t$之间经过$v$的最短路条数。

## 2.具体分析

### 2.1 选择算法

~~这题生动地向我们诠释了做题一定要看数据范围~~

一看数据范围，蛤？$n\le 100$？本题又是一道**多源多汇**问题。你是否想到了什么？

没错！$Floyd\ Warshall$！$Floyd$算法专门用于解决**多源多汇**问题，复杂度刚好是$O(n^3)$，用它做这题岂不美哉？

### 2.2 算法思路分析

关键在于求出$C_{s,t}$和$C_{s,t}(v)$，我们先来看$C_{s,t}$。

在做$C_{s,t}$的时候，最好就能把任意两个点的最短路距离处理好，顺便还要做好转移。

转移不难，主要分析两个方面：（以下用$i,j,k$分别代表起点，终点，以及分割点）

$1.$ 已经是目前的最短路，不用更新长度，将最短路数量加上$i,k$之间最短路条数$\times$$j,k$之间最短路条数。

代码：

```cpp
ll c=d[i][k]+d[k][j];
if(d[i][j]==c) cnt[i][j]+=cnt[i][k]*cnt[k][j];
```
2.找到更短的路，更新长度+重新计算最短路条数，数量仍然是$i,k$之间最短路条数$\times$$j,k$之间最短路条数。

代码：

```cpp
else if(d[i][j]>c) d[i][j]=c,cnt[i][j]=cnt[i][k]*cnt[k][j];
```

接下来我们来处理$C_{s,t}(v)$。

处理$C_{s,t}(v)$其实更简单，只需要枚举分割点然后判断是否有经过的最短路即可。

代码：

```cpp
for(ll v=1;v<=n;v++)
	for(ll s=1;s<=n;s++) if(s!=v){
		for(ll t=1;t<=n;t++) if(t!=v&&t!=s){
			if(d[s][t]==d[s][v]+d[v][t]) ans[v]+=(double)cnt[s][v]*cnt[v][t]/cnt[s][t];
		}
	}
```
## 3.代码

```cpp
#include<bits/stdc++.h>
#define N 109
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read() {
    ll x=0,f=1;int c=getchar();
    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
ll n,m,cnt[N][N],d[N][N];
double ans[N];
void floyd(){
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++){
				ll c=d[i][k]+d[k][j];
				if(d[i][j]==c) cnt[i][j]+=cnt[i][k]*cnt[k][j];
				else if(d[i][j]>c) d[i][j]=c,cnt[i][j]=cnt[i][k]*cnt[k][j];
			}
	for(ll v=1;v<=n;v++)
		for(ll s=1;s<=n;s++) if(s!=v){
			for(ll t=1;t<=n;t++) if(t!=v&&t!=s){
				if(d[s][t]==d[s][v]+d[v][t]) ans[v]+=(double)cnt[s][v]*cnt[v][t]/cnt[s][t];
			}
		}
} 
int main(){
	//freopen("socialnetwork.in","r",stdin);
	//freopen("socialnetwork.out","w",stdout);
	n=read(),m=read();
	fill(d[0],d[0]+N*N,INF);
	for(int i=1;i<=n;i++) d[i][i]=0;
	for(int i=1,a,b,c;i<=m;i++){
		a=read(),b=read(),c=read();
		d[a][b]=d[b][a]=c;cnt[a][b]=cnt[b][a]=1;
	}
	floyd();
	for(int i=1;i<=n;i++)printf("%.3lf\n",ans[i]);
	return 0;
}

```
~~马蜂巨丑勿喷~~

## 4.结语

作为一道NOI题，还是有点水的。

所以**数据范围**很重要。

~~那么，让我们下次再见。~~

---

## 作者：Forever丶CIL (赞：6)

这道题难度标签竟是省选/noi-  实为不解，可能是做的人比较少吧。。。。。。

其实很简单啦

就是∑这个式子大家可能不太熟悉，这里的意思是：

我们定义Cs,t为s,t之间的最短路条数,Cs,t(v)为s,t间经过v的最短路条数

那么,点v的重要程度就是将所有的Cs,t(v)/Cs,t加起来(s,t取遍所有不是v得点)

所以我们只需要求出任意两点间的最短路条数,对于每个v,枚举s,t,计算一遍就好了



------------


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;//要开long long qwq 
int n,m;
double imp[200];//记录每个点的重要程度 
int dt[200][200];//邻接矩阵存图 
ll Way[200][200];//记录每两点之间最短路条数 
void floyd()
{
    //弗洛伊德算法，在计算最短路的同时处理出最短路条数
    //原理是如果以k为中间点i,j之间的最短路和之前求的i,j之间最短路相同,
    //那么就在Way[i][j]上加上Way[i][k]*Way[k][i],因为每一条从i到k的最短路
    //都可以和从k到j的最短路匹配成从i到j的最短路
    //如果发现以k为中间点i,j之间的最短路比和之前求的i,j之间最短路还短,
    //在更新最短路的同时,也要将最短路条数重新计算 
    for(int k=1;k<=n;k++)
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(i!=j&&i!=k&&j!=k)
                {
                    if(dt[i][j]==dt[i][k]+dt[k][j])//相等的情况 
                    {
                        Way[i][j]+=Way[i][k]*Way[k][j];
                    }
                    if(dt[i][j]>dt[i][k]+dt[k][j])//小于的情况 
                    {
                        dt[i][j]=dt[i][k]+dt[k][j];
                        Way[i][j]=Way[i][k]*Way[k][j];//重新计算 
                    }
                }
            }
        }
    }
}
void calc_importance()
{
    //计算点k的重要程度 
    for(int k=1;k<=n;k++)
    {
        ll poi=0;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(i!=j&&i!=k&&j!=k)
                {
                    //计算以k为中间点，i，j之间最短路条数，就是Ci,j(k)了 
                    poi=0;
                    if(dt[i][k]+dt[k][j]==dt[i][j])
                    {
                        poi=Way[i][k]*Way[k][j];    
                    }
                    imp[k]+=(double)poi/Way[i][j];    
                }
            }
        }
    }
}
int main()
{
    memset(dt,0x3f,sizeof(dt));
    //稳稳的读入数据 
    scanf("%d%d",&n,&m);
    int a,b,c;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        Way[a][b]=1;
        Way[b][a]=1;
        dt[a][b]=c;
        dt[b][a]=c;
    }
    floyd();
    calc_importance();
    for(int i=1;i<=n;i++)
    {
        printf("%.3lf\n",imp[i]);
    }
    return 0;
}
```


------------

rp++

---

## 作者：hyzhutao (赞：4)

本蒟蒻做题较少，思路新奇，请见谅。

闲话少叙。直接说我的大体思路：

考虑$n$次Dijkstra。设某次的源点为s，可以生成一个最短路径图$G_s=(V,E)$。之所以是图，是因为每一条最短路径都需考虑，而两点间的最短路径不一定唯一。这是个有向图，且满足：只要从源点出发，沿着这个图的边走，走到任何一个点经过的路径都是从源点到这个点的最短路径（之一）。

到达t的路径条数$C_{s,t} = \sum\limits_{Edge_{v\rightarrow t}\in V}C_{s,v}$ (令$C_{s,s}=1$)

用一次拓扑排序求解所有的$C_{s,t}$ 其中$(t=1,2,...,n)$

然后有个可爱的节点叫做$v$，设其入度为$i$，所有指向它的点为$A_1,A_2,...,A_i$ ，则$\sum\limits_{j=1}^iC_{s,A_j}=C_{s,v}$。而且设$v$的后代中有一个节点为$t$，则有$C_{s,t}(v)=\sum\limits_{j=1}^iC_{s,t}(A_j)$。因此，若$s\rightarrow t$的所有最短路径为节点$v$提供的重要程度为$I_{s,t}(v)$，则$s\rightarrow v\rightarrow t$的所有最短路径为节点$A_j$提供的重要程度$I_{s,v,t}(A_j)=\dfrac{C_{s,v,t}(A_j)}{C_{s,t}(v)}I_{s,t}(v)$，所以

$\dfrac{I_{s,v,t}(A_j)}{I_{s,t}(v)}=\dfrac{C_{s,v,t}(A_j)}{C_{s,t}(v)}=\dfrac{C_{s,A_j}C_{A_j,v}C_{v,t}}{C_{s,v}C_{v,t}}=\dfrac{C_{s,A_j}C_{A_j,v}}{C_{s,v}}=\dfrac{C_{s,A_j}}{C_{s,v}}$

因而$\dfrac{I_{s,v,t}(A_j)}{I_{s,t}(v)}$与$t$无关，由等比性质，$v$为$A_j$提供的重要程度为$v$的重要程度的一部分，占比就是$\dfrac{C_{s,A_j}}{C_{s,v}}$，相当于是$A_1,A_2,...,A_i$瓜分了$I_s(v)$（即源点为$s$时$v$的重要程度），$A_j$分到的比例就是$C_{s,A_j}$的比例。

这是错的！瓜分的应该是$I_s(v)+1$。为什么？因为我们不能只考虑以$s$为源点、$v$的后代为终点的最短路径，还要考虑以$s$为源点、$v$为终点的最短路径，这对$I_s(v)$没有影响，但是要算在它爹爹们的头上（好可怕）。

如是，将$A_j$的所有后代为之提供的重要程度相加，就是$I_s(A_j)$。再用一次拓扑排序去实现它。

还有一些注意事项：

1. 若在$G_s$中某个可怜的人$u$没有儿子~~不孝有三，无后为大~~，那么这种~~不好的~~人对社会就没有什么贡献，$I_s(u)=0$;

2. 源点$s$~~总是个贤明的祖宗~~不求回报，$I_s(s)=0$;

3. 以上都是基于同一源点$s$说的，事实上要$n$次这样的计算。~~即换(n-1)次祖宗~~注意重置一些数组。

4. 代码中所用字母与上述及题目有很大不同（上述所用字母与题目无矛盾），以下为大家列举出来：$I_s(v)\rightarrow k[v],i\rightarrow in[v],C_{s,v}\rightarrow c[v],c\rightarrow w$，其余的字母意思如下：

$head[],tail[]$：手写链表的头尾指针；

链表中$v$：指向的点。

$q$用于Dijkstra的堆优化。

$vst[]$用于Dijkstra，表示已确定s到某节点最短路径长度。

$in[],out[]$分别为最短路径图中的入度、出度。

$iin[],oot[]$：分别在两次拓扑排序中用于统计有多少最短路径图的入边、出边已被统计/删去。~~随便你怎么理解~~

$i,x,y,ch$及chain外的$u,v,w$：一些临时的变量，随意征用。

$hb[],hf[],tb[],tf[]$：见代码注释。例如$hb[v]$表示$v$的最短路径图中的爹爹节点构成的链表的头指针。

$stack[],top$：栈。

若还有什么变量没有申明，不好意思，算我没看到。

讲了那么多，总得有个结果：
```cpp
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
const int maxn = 101;
#define ld long double

int n, m;
struct chain{int v, w; chain* next;} *head[maxn], *tail[maxn];
ld I[maxn];

void advanced_dijkstra(int);

int main()
{
	int i, u, v, w;
	scanf ("%d%d", &n, &m);
	for (i = 1; i <= n; ++i)
	{
		head[i] = new chain;
		tail[i] = head[i];
	}
	for (i = 0; i < m; ++i)
	{
		scanf ("%d%d%d", &u, &v, &w);
		tail[u]->v = v;
		tail[v]->v = u;
		tail[u]->w = tail[v]->w = w;
		tail[u] = (tail[u]->next = new chain);
		tail[v] = (tail[v]->next = new chain);
	}
	for (i = 1; i <= n; ++i) advanced_dijkstra(i);
	for (i = 1; i <= n; ++i) cout << fixed << setprecision(3) << I[i] << '\n';
	return 0;
}

void advanced_dijkstra(int s)
{
	priority_queue <pair <int, int> > q;
	int i, x, y;
	long long c[maxn], d[maxn];
	int in[maxn], out[maxn], iin[maxn], oot[maxn], stack[maxn], top;
	ld k[maxn];
	bool vst[maxn];
	chain* ch;
	chain *hf[maxn], *hb[maxn], *tf[maxn], *tb[maxn];
	//head of forth chain, head of back chain, tail of forth chain, tail of back chain

	memset (d, 0x7f, sizeof(d));
	memset (vst, false, sizeof(vst));
	memset (in, 0, sizeof(in));
	memset (out, 0, sizeof(out));
	for (i = 1; i <= n; ++i)
	{
		tf[i] = hf[i] = new chain;
		tb[i] = hb[i] = new chain;
	}

	d[s] = 0;
	q.push(make_pair(0, s));
	while (!q.empty())
	{
		x = q.top().second;
		q.pop();
		if (vst[x]) continue;
		vst[x] = true;
		for (ch = head[x]; ch != tail[x]; ch = ch->next)
		{
			if (d[x] + ch->w <= d[ch->v])
			{
				y = ch->v;
				if (d[x] + ch->w < d[y])
				{
					d[y] = d[x] + ch->w;
					q.push(make_pair(-d[y], y));
				}
				tb[y]->v = x;
				tb[y]->w = ch->w;
				tb[y] = (tb[y]->next = new chain);
			}
		}
	}
	
	for (i = 1; i <= n; ++i)
	{
		if (i == s) continue;
		while (hb[i]->w + d[hb[i]->v] > d[i])
		{
			ch = hb[i]->next;
			free(hb[i]);
			hb[i] = ch;
		}
		for (ch = hb[i]; ch != tb[i]; ch = ch->next)
		{
			tf[ch->v]->v = i;
			tf[ch->v] = (tf[ch->v]->next = new chain);
			++in[i];
			++out[ch->v];
		}
	}

	memset(iin, 0, sizeof(iin));
	memset(oot, 0, sizeof(oot));
	memset(stack, 0, sizeof(stack));
	memset(c, 0, sizeof(c));
	for (i = 1; i <= n; ++i) k[i] = 0;
	stack[0] = s;
	top = 1;
	c[s] = 1;

	while(top)
	{
		x = stack[--top];
		for (ch = hf[x]; ch != tf[x]; ch = ch->next)
		{
			++iin[ch->v];
			c[ch->v] += c[x];
			if (iin[ch->v] == in[ch->v]) stack[top++] = ch->v;
		}
	}

	for (i = 1; i <= n; ++i) if (out[i] == 0) stack[top++] = i;
	while (top)
	{
		x = stack[--top];
		for (ch = hb[x]; ch != tb[x]; ch = ch->next)
		{
			++oot[ch->v];
			k[ch->v] += (ld)c[ch->v] * (k[x] + 1) / (ld)c[x];
			if (oot[ch->v] == out[ch->v]) stack[top++] = ch->v;
		}
	}
	for (i = 1; i <= n; ++i) if (i != s) I[i] += k[i];
}
```

再唠叨一句，有些很吓人的赋值语句（e.g.

```tail[u] = (tail[u]->next = new chain);```

)不管a=b=c;还是a=(b=c);加不加括号，都等效于c先赋值给b,b在赋值给a。这样写没问题的。~~不喜勿喷~~

---

## 作者：不存在之人 (赞：3)

显然这是一道要求多源最短路的题目，数据范围很小，目测用弗洛伊德算法。由题意，先求出各个点之间的最短路径，同时利用乘法原理，计算出由 i 到 j 之间的最短路径个数。如果又发现了一条最短路，由乘法原理计算增加的路径个数再加上即可。

我写的代码没有去除自己到自己的路径，因此需清空，但也可在 Floyd 中判断去除，就无需再用一个 for 循环。之后再三重循环，由题目给出的公式以及加法原理，可以计算出答案。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=102;
int n,m,k;
double ans[N],a[N][N],E[N][N];
int main()
{
    memset (E,0x7f,sizeof(E));
    memset (ans,0,sizeof(ans));
    scanf ("%d%d",&n,&m);
    for (int i=1;i<=m;i++)
    {
        int x,y;
        double z;
        scanf ("%d%d%lf",&x,&y,&z);
        E[x][y]=z;
        E[y][x]=z;
        a[x][y]=1;
        a[y][x]=1;
    }
    for (int k=1;k<=n;k++)
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
            {
                if (E[i][k]+E[k][j]<E[i][j])
                {
                    E[i][j]=E[i][k]+E[k][j];
                    a[i][j]=a[i][k]*a[k][j];//由乘法原理计算i到j最短路个数
                }
                else if (E[i][j]==E[i][k]+E[k][j])//不止一条最短路应该加上路径个数
                    a[i][j]+=a[i][k]*a[k][j];
            }
    for (int i=1;i<=n;i++)//去除自己到自己路径个数
        a[i][i]=0;
    for (int k=1;k<=n;k++)
    {
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
            {
                 if (E[i][j]==E[i][k]+E[k][j]&&a[i][j]>0)
                     ans[k]+=a[i][k]*a[k][j]/a[i][j];//由公式计算I(k)
            }
        printf ("%.3lf\n",ans[k]);
    }
    return 0;
}
```

---

## 作者：Prean (赞：2)

我敢说，如果我回到我出生的2007年，~~我绝对可以AK NOI~~

题目大意：有一堆乱七八糟的人之间有乱七八糟的关系，有一个乱七八糟的重要度，给了一个乱七八糟的重要度的定义，问你每个人的乱七八糟的重要度。

其实那么多字母只是为了让人看不下去的，我把这道题的每个字母看懂了之后，10分钟就AC了。

我看出来的结果就是：每一对人经过我的最短路径的条数除以他们两个人之间的最短路径条数之和，就是我的重要度。

数据很小，只有100，而且要每两人之间求最短路径的条数，果断$Floyed$。

当结果预处理完了之后就可以愉快地统计了。

贴代码：
```cpp
#include<iostream>
#include<iomanip>
using namespace std;
long long a[105][105],g[105][105];double ans[105];
int main()
{
	int n,m,x,y,i,j,k;long long z;cin>>n>>m;
	for(i=1;i<=n;++i)for(j=1;j<=n;++j)a[i][j]=0x7fffffffffffffff;
	while(m--)cin>>x>>y>>z,a[x][y]=a[y][x]=z,++g[x][y],++g[y][x];
	for(k=1;k<=n;++k)for(i=1;i<=n;++i)for(j=1;j<=n;++j)
	if(g[i][k]&&g[k][j])if(a[i][k]+a[k][j]<a[i][j])
	a[i][j]=a[i][k]+a[k][j],g[i][j]=g[i][k]*g[k][j];
	else if(a[i][k]+a[k][j]==a[i][j])g[i][j]+=g[i][k]*g[k][j];
	for(k=1;k<=n;++k)for(i=1;i<=n;++i)for(j=1;j<=n;++j)
	if(i!=j&&i!=k&&j!=k&&a[i][k]+a[k][j]==a[i][j])
	ans[k]+=1.0*g[i][k]*g[k][j]/g[i][j];
	for(i=1;i<=n;++i)cout<<fixed<<setprecision(3)<<ans[i]<<"\n";
}
```

---

## 作者：xzyxzy (赞：1)

## 来一个SPFA的题解
## 先上代码
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<queue>
#define ll long long
using namespace std;
int read()
{
	char ch=getchar();int h=0,t=1;
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') t=-1,ch=getchar();
	while(ch>='0'&&ch<='9') h=h*10+ch-'0',ch=getchar();
	return h*t;
}
int N,M,g[110][110],head[110],cnt;
int dis[110],vis[110];
ll w[110][110],fr[110][110][110];
queue<int>Q;
struct edge{int next,to,w;}a[10010];
void link(int x,int y,int w){a[++cnt]=(edge){head[x],y,w};head[x]=cnt;}
void SPFA(int f)
{
	memset(dis,63,sizeof(dis));
	Q.push(f);vis[f]=1;dis[f]=0;w[f][f]=1;
	while(!Q.empty())
	{
		int x=Q.front();
		for(int i=head[x];i;i=a[i].next)
		{
			int R=a[i].to;
			if(dis[R]<dis[x]+a[i].w) continue;
			if(dis[R]==dis[x]+a[i].w)
			{
				w[f][R]=w[f][R]-fr[f][R][x]+w[f][x];
				fr[f][R][x]=w[f][x];
			}
			else
			{
				dis[R]=dis[x]+a[i].w;
				w[f][R]=w[f][x];
				for(int p=1;p<=N;p++) fr[f][R][p]=0;
				fr[f][R][x]=w[f][x];
			}
			if(!vis[R]) vis[R]=1,Q.push(R);
		}
		Q.pop();vis[x]=0;
	}
	for(int i=1;i<=N;i++) g[f][i]=dis[i];
}
int main()
{
	N=read();M=read();
	for(int i=1;i<=M;i++)
	{
		int x=read(),y=read(),w=read();
		link(x,y,w);link(y,x,w);
	}
	for(int i=1;i<=N;i++) SPFA(i);
	for(int k=1;k<=N;k++)
	{
		double ans=0;
		for(int x=1;x<=N;x++)
			for(int y=1;y<=N;y++)
				if(x!=k&&k!=y&&g[x][y]==g[x][k]+g[k][y])
					ans+=1.0*w[x][k]*w[k][y]/w[x][y];
		printf("%.3lf\n",ans);
	}
	return 0;
}
```
这题由于ans+=w[x][k]*w[k][y]/x[x][y]，没有乘w[k][y]而调试半个小时，甚至还尝试了Floyd的做法

意思就是x->y，那么w(ay)[y]+=w(ay)[x]，但是x被松弛后不能直接加，就要用fr来记录x对y的路径条数的贡献

Floyd相对好写些，这里只提供一个SPFA的思路，Floyd可以看楼下的，写的很棒

---

## 作者：Skywalker_David (赞：1)

分析：说白了，这题唯一比较有挑战性的地方，就是求任意两点间最短路的条数。


这里说一个很没有节操的方法：


floyd 都会吧，好，那接着说，不会的 google 。


转移的时候增加一下路径的转移：







```cpp
　　　　if a[i,k]+a[k,j]<a[i,j] then 
　　　　　　a[i,j]:=......
　　　　　　f[i,j]:=f[i,k]*f[k,j];               //f 是最短路径的条数，这个的来源是乘法原理。
　　　　else
　　        if a[i,k]+a[k,j]=a[i,j] then f[i,j]:=f[i,j]+a[i,k]*a[k,j];   //这个是加法原理。
```
然后，枚举每两个点，直接计算重要程度就可以了。。。。。

代码：SueMiller

```delphi

var 
    a:array[0..101,0..101]of longint;
    f:array[0..101,0..101]of int64;
    v:array[0..101]of double;
    n,m,x,y,z,i,j,k:longint;
begin
    readln(n,m);
    filldword(a,sizeof(a)>>2,maxlongint>>2);
    fillchar(v,sizeof(v),0);
    for i:=1 to m do begin
        readln(x,y,z);
        a[x,y]:=z;
        a[y,x]:=z;
        f[x,y]:=1;
        f[y,x]:=1;
    end;
    for k:=1 to n do
        for i:=1 to n do
            if i<>k then
                for j:=1 to n do
                    if (i<>k) and (j<>k) then
                        if a[i,k]+a[k,j]<a[i,j] then begin
                            a[i,j]:=a[i,k]+a[k,j];
                            f[i,j]:=f[i,k]*f[k,j];
                        end
                        else if a[i,k]+a[k,j]=a[i,j] then
                            f[i,j]:=f[i,j]+f[i,k]*f[k,j];
    for k:=1 to n do begin
        for i:=1 to n do
            if i<>k then
                for j:=1 to n do
                    if (i<>j) and (k<>j) then begin
                        if (a[i,k]+a[k,j]<>a[i,j]) then continue;
                        if f[i,j]=0 then continue;
                        v[k]:=v[k]+(f[i,k]*f[k,j])/f[i,j];
                    end;
        writeln(v[k]:0:3);
    end;
end.

```

---

## 作者：cold_cold (赞：0)

 [安利一波博客](https://www.cnblogs.com/cold-cold/p/10061992.html)
 
 此题n<=200显然可以使用FLOYED来求解，说是使用FLOYED，其实是利用计数型DP的想法

在这里我对一些细节进行一些总结

1.cnt数组的初始化

我们把cnt[i][j]数组当做从i到j的最短路的条数

那么我们在读进来有u->v的一条边的时候。就应该将cnt[u][v]=cnt[v][u]=1;

这是为什么呢？

我们考虑如果u->v这条边确实是u->v的最短路

那么cnt[u][v]=cnt[v][u]=1;日后发现有与之相同的最短路，就，将cnt加在一起

```cpp
if(dis[i][j]==dis[i][k]+dis[k][j])
    cnt[i][j]+=cnt[i][k]*cnt[k][j];
```

我们考虑如果u->v这条边不是u->v的最短路

那么cnt[u][v]一定会在日后将它更新的时候，将cnt[u][v]重新赋值

```cpp
if(dis[i][j]>dis[i][k]+dis[k][j])
{
    dis[i][j]=dis[i][k]+dis[k][j];
    cnt[i][j]=cnt[i][k]*cnt[k][j];
}
```

1.统计结果

因为s≠t&&s≠v&&t≠v 所以在统计结果一定要加入如下判断

```cpp
if(dis[i][j]==dis[i][k]+dis[k][j]&&i!=j&&j!=k&&i!=k)
```

说了这么多，总体实现如下：
```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=110;
ll n,m,dis[N][N],u,v,w;
double cnt[N][N],ton;
int main()
{
//    freopen("input","r",stdin);
//    freopen("output","w",stdout);
    n=read(),m=read();
    memset(dis,0x3f,sizeof(dis));
    for(int i=1;i<=m;i++)
    {
        u=read(),v=read(),w=read();
        dis[u][v]=dis[v][u]=w;
        cnt[u][v]=cnt[v][u]=1;
    }
    for(int i=1;i<=n;i++) dis[i][i]=0;
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            {
                if(dis[i][j]>dis[i][k]+dis[k][j])
                {
                    dis[i][j]=dis[i][k]+dis[k][j];
                    cnt[i][j]=cnt[i][k]*cnt[k][j];
                }
                else if(dis[i][j]==dis[i][k]+dis[k][j])
                    cnt[i][j]+=cnt[i][k]*cnt[k][j];
            }
    for(int k=1;k<=n;k++)
    {
        ton=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++) if(dis[i][j]==dis[i][k]+dis[k][j]&&i!=j&&j!=k&&i!=k)
                ton+=((cnt[i][k]*cnt[k][j])/cnt[i][j]);
        printf("%.3lf\n",ton);
    }          
    return 0;
}
```

---

## 作者：jiuguaiwf (赞：0)

怎么可以没有c++，来一发，蒟蒻求指教


floyed好写，但难度在根据数学组合原理算方案数。





    
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
int n,m,p,l,num,a[105][105];
long long f[105][105];       //数据无语了，一直在卡第二点，10^10，刚好爆。a表示路径，f表示方案数（从i到j）
double q;
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
      for (int j=1;j<=n;j++)
        a[i][j]=99999999;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&p,&l,&num);
        f[p][l]=1;
        f[l][p]=1;             //双向的，都置一
        a[p][l]=num;
        a[l][p]=num;
    }
    for (int k=1;k<=n;k++)
    {
      for (int i=1;i<=n;i++)
      if (i!=k&&a[i][k]<999999999)
        for (int j=1;j<=n;j++)
          if (i!=j&&k!=j&&i!=k)
          {
                if (a[i][j]>a[i][k]+a[k][j])
                {
                    a[i][j]=a[i][k]+a[k][j];
                    f[i][j]=f[i][k]*f[j][k];         //乘法原理
                }
                else if (a[i][j]==a[i][k]+a[k][j])
                {
                    f[i][j]=f[i][j]+f[i][k]*f[k][j];       //和上面差不多，但因为路径长度一样也要把原方案数加上（都是最短的）
                }
          }
    }
    for (int k=1;k<=n;k++)   //枚举断点k,
    {
      for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
        {
           if (i!=k&&k!=j&&a[i][j]==a[i][k]+a[k][j]&&f[i][j]) q=q+(double)f[i][k]*f[k][j]/f[i][j];     //按题意算重要度。
                                       //a[i][j]==a[i][k]+a[k][j]是一个神奇的式子,限制：i到j的最短路经过k，想想为什么（莫名刘汝佳。。。）
        }
      printf("%.3lf\n",q);
      q=0;
    }
    //while(1);
    return 0;
}
```
截至发帖，我的时间效率还是最优的，应该算正解了吧（一口毒奶）.

欢迎交流指正，大佬们求罩


---


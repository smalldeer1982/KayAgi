# 拉近距离

## 题目背景

我是源点，你是终点。我们之间有负权环。 ——小明

## 题目描述

在小明和小红的生活中，有 $N$ 个关键的节点。有 $M$ 个事件，记为一个三元组 $(S_i,T_i,W_i)$，表示从节点 $S_i$ 有一个事件可以转移到 $T_i$，事件的效果就是使他们之间的距离减少 $W_i$。

这些节点构成了一个网络，其中节点 $1$ 和 $N$ 是特殊的，节点 $1$ 代表小明，节点 $N$ 代表小红，其他代表进展的阶段。所有事件可以自由选择是否进行，但每次只能进行当前节点邻接的。请你帮他们写一个程序，计算出他们之间可能的最短距离。

## 说明/提示

对于 $20\%$ 数据，$N \le 10$，$M \le 50$。

对于 $50\%$ 数据，$N \le 300$，$M \le 5000$。

对于 $100\%$ 数据，$1\le N \le 10^3$，$1\le M \le 10^4$，$|W_i|\le 100$，保证从节点 $1$ 到 $2 \dots N$ 有路径，从节点 $N$ 到 $1 \dots N - 1$ 有路径。

## 样例 #1

### 输入

```
3 3
1 2 3
2 3 -1
3 1 -10```

### 输出

```
-2```

# 题解

## 作者：Dijkspfa (赞：42)

第一次A这道题的时候刚学spfa，n=999的点和其他题解一样特判过，一直以为是数据错了。

今天围观一位dalao写这道题，困惑于WA90，恰好看到讨论里管理员说数据无误，思考了一段时间，发现坑点，终于能够不用特判A这道题了……

关键点：“拉近距离”的不一定是小明，也可能是小红。

题目中没有给出具体的源点汇点（不算迷惑人的题目背景的话），所以在做spfa的时候，分别以1和n为源点各做一遍，取min，才能得到正确答案。n=999的点就是在小红主动的情况下的解。

所以这是一道语文模板题（雾）

放一下正确解法代码




```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
const int mxn = 1007;
const int mxm = 10003;
int n,m,cnte,pre[mxn],cnt[mxn],dis[mxn];
struct edge{
    int v,nxt,w;
}e[mxm];
bool vis[mxn];
inline void adde(int u,int v,int w){e[++cnte].w = w,e[cnte].v = v,e[cnte].nxt = pre[u],pre[u] = cnte;}
void spfa(int x){
    queue<int> q;
    memset(dis,0x3f,sizeof(dis));
    dis[x] = 0;q.push(x);vis[x] = 1;
    while(!q.empty())
    {
        int t=q.front();q.pop();
        vis[t] = 0;
        if(cnt[t] > n){puts("Forever love");exit(0);}
        for(int i = pre[t];i;i = e[i].nxt)
            if(dis[t] + e[i].w < dis[e[i].v])
            {
                dis[e[i].v] = dis[t] + e[i].w;
                if(!vis[e[i].w]) q.push(e[i].v),cnt[e[i].v]++,vis[e[i].v] = 1;
            }
    }
    return;
}
int main(){
    int s,t,w;
    cin>>n>>m;
    for(int i = 1;i <= m;i++)
    {
        scanf("%d%d%d",&s,&t,&w);
        adde(s,t,-w);
    }
    spfa(1);
    int ans = dis[n];
    spfa(n);
    printf("%d",min(ans,dis[1]));
    return 0;
}
```

---

## 作者：Poetic_Rain (赞：26)

~~我也想有这样的爱情故事，可惜我单身~~

其实这道题就是一个比较裸的最短路问题。对于一个三元组$(S,W,T)$，$S$其实就是一个端点，而$W$就是到达的端点，连接两个端点的边长为$-T$，注意要取一个相反数，这样才能继续跑最短路

那么题意也就这么看完了，就是很简单的跑最短路嘛，小明是起点，小红是终点，小明追小红就完事了，那么我们就可以得到第一份代码了

```
#include <bits/stdc++.h>
using namespace std;
queue<int> shan;
int n,m,s,t,w,ans,tot;
int dis[50010],vis[50010],sum[50010],head[50010];

struct node {
	int to,net,val;
} e[50010];

inline void add(int u,int v,int w) {
	e[++tot].to=v;
	e[tot].val=-w; //因为是减少这么多，所以应该存负边权 
	e[tot].net=head[u];
	head[u]=tot;
}
//标准的链式前向星建边 
inline bool spfa() {
	fill(dis,dis+50010,20050206);
	memset(vis,0,sizeof(vis));
	memset(sum,0,sizeof(sum)); //初始化，建议大家不用memset，很慢，不如手动for循环初始化（真的！真的！真的！） 
	dis[1]=0;
	vis[1]=1;
	sum[1]=1; //用来判断负环 
	shan.push(1);
	while(!shan.empty()) {
		int x=shan.front();
		shan.pop();
		vis[x]=0;
		for(register int i=head[x];i;i=e[i].net) {
			int v=e[i].to;
			if(sum[x]>n) return false;   //入队次数太多就会出现负环的情况，应该是n-1次就够了，多判几次也不错对吧。。 
			if(dis[v]>dis[x]+e[i].val) {
				dis[v]=dis[x]+e[i].val;//松弛操作 
				if(vis[v]==0) {
					shan.push(v);
					sum[v]++; //入队次数++
					vis[v]=1;
				}
			}
		}
	}	
	return true;
}

int main() {
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;i++) {
		scanf("%d%d%d",&s,&t,&w);
		add(s,t,w); 
		ans+=w; 
	}
	if(n==1) {
		printf("%d",-ans>0?0:-ans);
		return 0;
	}//特判1的的情况，然而数据中没有（还是要保证一下数据的正确性，有点水） 
	if(spfa()==false) puts("Forever love"); //如果有负环，那就幸福地在一起吧 （我也想~~） 
	else printf("%d",dis[n]); //不行的话就慢慢靠近吧 
	return 0;
}
```

然后你就会惊奇地发现你WA了一个点，在我调试了许久之后，然后问了问同学，发现这简直是一个真正的美好的爱情故事（扯远了。。）。小明可以追小红，那小红为什么不可以追小明呢（~~封建思想~~），所以我们就需要跑两次最短路，一次是从小明出发，一次是从小红出发，得出两者之间最小的答案就可以了

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e4+50;
int n,m;
int head[MAXN],tot;
struct node{
	int net,to,w;
}e[MAXN]; 
void add(int u,int v,int w){
	e[++tot].net=head[u];
	e[tot].to=v;
	e[tot].w=w;
	head[u]=tot;
}//还是链式前向星建边 
int vis[MAXN],d[MAXN];
bool v[MAXN];
queue<int> q;
bool spfa(int s){
	for(register int i=1;i<=n;i++) d[i]=20040915,v[i]=false,vis[i]=0;
	d[s]=0;
	v[s]=true;
	vis[s]++;
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		v[x]=false;
		if(vis[x]>n) return false; //判断负环 
		for(register int i=head[x];i;i=e[i].net){
			int y=e[i].to,z=e[i].w;
			if(d[y]>d[x]+z){
				d[y]=d[x]+z;
				if(v[y]==false){
					v[y]=true;
					vis[y]++;
					q.push(y);
				}
			}
		}
	}
	return true; //千万别把这步漏掉了，不然默认返回false 
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;i++){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,-1*w); //取一个相反数 
	}
	int ans=20040915; //ans记录答案 
	bool kk=spfa(1);  
	if(kk==false) puts("Forever love"); //有负环那就永远在一起 
	else {
		ans=min(ans,d[n]);
		spfa(n);
		ans=min(ans,d[1]);
		cout<<ans;
	}//两边跑最短距离 
	return 0;
} 
```

那么这样的话，这道题就成功解决了，最后祝大家也早日找到自己喜欢的女生啊，女生就找男生了啊

---

## 作者：任梦华 (赞：5)

```cpp
/*
本题目是一个简单的俩点求距离的问题，
仔细看的话会发现题目保证有负环的情况![题目](https://cdn.luogu.com.cn/upload/pic/20141.png)
大家是不是被这个奇怪的条件搞混了。
其实再仔细看看![题目](https://cdn.luogu.com.cn/upload/pic/20141.png)
距离是减小不是增大啊，所有负环变成了正环
很多人被坑了
废话不多说了，上代码了。
*/
#include<bits/stdc++.h>//蒟篛专用头文件
using namespace std;
int n,m,d=1000000000,flag;//d放我最小的答案
struct EE{//蒟篛专用图论定义，输入，标记；
    int ne,to,z;
}e[1000000];
int js,h[1000000],bj[1000000],zzt[1000000],bs[1000000];
void hh(int s,int t,int w)
{
    e[++js].ne=h[s];
    e[js].to=t;
    e[js].z=w;
    h[s]=js;
}//以上都是模板代码，因为你已经做到这了说明你一定看的懂。
void spfa(int k) 
{//标准的spfa代码
    queue<int>q;
    memset(bj,0,sizeof(bj));//标记清零
    memset(zzt,127,sizeof(zzt));//zzt存距离（至于为什么是zzt，我不方便透露）
    memset(bs,0,sizeof(bs));//判断负环的数组（重点！）
    zzt[k]=0;
    bj[k]=1;
    q.push(k);
    while(!q.empty())//标准代码，解释一下你也会烦的
    {
        k=q.front();
        q.pop();
        bj[k]=0;
        for(int i=h[k];i;i=e[i].ne)
        {
            int o=e[i].to;
            if(zzt[o]>zzt[k]+e[i].z)
            {
                bs[o]=bs[k]+1;//关键的一步（重点！）
                if(bs[o]>=n)//因为我从一个点到任何一个点要想不重复（重复的话就为环，这里重复就为负环）最多走n下，我从零做起，到n的话就结束。
                {
                    flag=1;
                    return;
                }
                zzt[o]=zzt[k]+e[i].z;//模板代码
                if(bj[o]==0)
                {
                    bj[o]=1;
                    q.push(o);
                }
            }
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int s,t,w;
        cin>>s>>t>>w;
        hh(s,t,-w);//再说一次是减小，所以存-w（单向）；
    }
    spfa(1);//我从1找一遍
    d=zzt[n];//保存答案
    spfa(n);//再从n一遍
    if(flag==1)//如果出现了负环（由正环变的）
        cout<<"Forever love";
    if(flag==0)
    {
        d=min(d,zzt[1]);//没有输出俩答案最小
        cout<<d;
    }
}
```

---

## 作者：SIXIANG32 (赞：4)

一道不算很难的SPFA板子题目。  
切入正题：  
# Part 1 题意分析
这道题的题意其实是考语文的（谔谔），也就是：  
**在一个有向图中找到$1$~$N$的最长路与$N$~$1$的最长路其中较小的那个，并且会有负环哦！**   
很多人被坑了，就是只跑了其中一种最长路
# Part 2 开始解题
显然，最长路要么是改变松弛方法，要么取反边权。  
这里我用取反边权这种方法的（因为我懒，不想改板子/fad）。  

辣么这题用什么最短路算法呢？  
这道题是有负环的图，  
Dij，floyd都不能处理负环。  
bf可以处理负环，但是时间复杂度实在说不过去啊/jk。  
那么就用SPFA吧。  

不会SPFA的同学可以参考[这篇日报](https://www.luogu.com.cn/blog/FrozaFerrari/xue-tu-lun-ni-zhen-di-liao-xie-zui-duan-lu-ma-post)，此处不再讲解。

注意：虽然SPFA很容易卡，但是判断负环只能用SPFA，bf的时间复杂度很差。  

所以，我们总结一下：  
1. 将边权取反。  
2. 运用SPFA算法求最短路

# Part 3 解题注意事项&代码  
```cpp
#include<iostream>
#include<queue>//STL队列
#include<vector>//vector存图
using namespace std;
struct node{
	int to,val;//to是连接的点，val是权值
	node(int y_,int val_)
	{to=y_,val=val_;}
};
vector<node>gra[10010];//图
long long dis[10010];//最长路答案
bool vis[10010];//标记
int cnt[10010];//这是记录每个点进队列的次数，超过N次有负环
int n,m;
bool SPFA(int s)//SPFA跑最短路，这里就是最短路板子，我存图是取反的
{
	for(int p=1;p<=n;p++)//初始化
		dis[p]=2147483647,vis[p]=0;
	queue<int>que;//队列
	que.push(s);//初始点进队列
	dis[s]=0;//最短路
	vis[s]=1;//标记
	while(!que.empty())//开始
	{
		int fr=que.front();
		que.pop();
		vis[fr]=0;
		for(int p=0;p<gra[fr].size();p++)//遍历与队首相邻的边
		{
			int t=gra[fr][p].to;
			if(dis[t]>dis[fr]+gra[fr][p].val)//松弛
			{
				dis[t]=dis[fr]+gra[fr][p].val;
				if(!vis[t])
				{
					vis[t]=1;
					que.push(t);
					cnt[t]++;
					if(cnt[t]>=n)return 1;//负环
				}
			}
		}
	}
	return 0;
}
int main()
{
	cin>>n>>m;
	for(int p=1,x,y,z;p<=m;p++)
		cin>>x>>y>>z,gra[x].push_back(node(y,-1*z));//输入和建图
	if(SPFA(1))cout<<"Forever love"<<endl;//有负环
	else
	{
		int a=dis[n];
		SPFA(n);
		int b=dis[1];
		if(a<b)cout<<a<<endl;
		else cout<<b<<endl;
     //跑两次最短路
	}
}
```

---

## 作者：Shunpower (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2136)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/LEMON-ni/solution-p2136)

## 题目大意

对于一个有向图 $G$：有 $N$ 个点，$M$ 个边，把每一条边用三元组 $(S_i,T_i,W_i)$，其中 $S_i,t_i$ 表示两个端点，$W_i$ 表示这条边的长度。

如果这个图中从点 $1$ 到点 $N$ 的最短路可以无限缩小，请输出 `Forever love`，否则输出最短路长度。

## 思路分析

通过数据范围我们发现这题的最短路要**处理负权**。

我们又可以发现这里的最短路不一样的地方在于，以前的最短路走一条边加上边的长度，这里的最短路**走一条边减去一条边的长度**。所以在做最短路之前，我们要把所有的 $W_i$ 都变成它的相反数（即乘上一个 $-1$）。

题目中要求输出`Forever love`的情况是最短路可以无限缩小，那显然，只有在图中有负权环的时候最短路才能无限缩小，所以我们的最短路算法还要能找负权环。

能处理负权，还能找负权环并求出最短路的算法只有 Bellman-Ford 符合我们的要求。这里可以不用 SPFA 进行优化，因为 $O(MN)$ 的算法可以跑过该题的数据范围。

## 代码剖析

### 建边与 Bellman-Ford 的初始化

```
for(int i=1;i<=m;i++){
	int x,y,z;
	cin>>x>>y>>z;
	u[i]=x;
	v[i]=y;
	w[i]=-z;
}
for(int i=1;i<=n;i++){
	d[i]=INT_MAX;
}
```
Bellman-Ford 算法的建边不使用邻接表，而是使用三个数组存储起点，终点与边的权值。

注意在开始的时候要将最短路数组初始化成 `INT_MAX`（因此存储最短路的数组要开`long long`）。

### 求最短路

```
d[1]=0;
for(int i=1;i<n;i++){
	for(int j=1;j<=m;j++){
		d[v[j]]=min(d[v[j]],d[u[j]]+w[j]);
	}
}
for(int j=1;j<=m;j++){
	if(d[v[j]]>d[u[j]]+w[j]){
		cout<<"Forever love"<<endl;
		return 0;
	}
}
```
Bellman-Ford 算法求最短路基于松弛操作。对所有边进行 $n-1$ 次松弛操作（即尝试经过某个点有没有可能使得路径更短）就能求出单源最短路。

为了避免出现负权环，我们再进行一次检查，如果在求完最短路的情况下还有边可以松弛，那就说明这个图中不存在最短路（即存在负权环），直接输出`Forever love`。

因为小明和小红都有可能拉近距离，所以**我们要再跑一次 $N$ 到 $1$ 的最短路**。

如果跑完两次最短路确定图内不含有负权环，那么直接输出 $1$ 到 $N$ 的最短路与 $N$ 到 $1$ 的最短路的较小值。

## AC 记录

[AC记录](https://www.luogu.com.cn/record/52199399)

---

## 作者：伟大的王夫子 (赞：2)

如果想要更好的体验，可以到[我的博客](https://www.luogu.org/blog/I-AK-IOI/)

此题就是一个模板题

对于事件$(S_i, T_i, W_i)$,因为可以让

$S_i$ 到$T_i$的距离减少$W_i$（等价于$+(-W_i)$）

所以连边$(S_i, T_i, -W_i)$ 即可

在这个图上跑一遍$spfa$（~~他不是死了吗）~~，顺便求一求负环即可

顺带提一下，像这种题目，不会卡$spfa$,否则就无解。

最后判断一下负环，如果有，输出Forever love

同时因为可以是小明追小红，也可以是小红追小明，所以从$1 \to n, n \to 1$ 分别跑一次最短路，两次取min即可
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 20010;
int n, m, t, flag, cnt[N], v[N];
int d[N];
vector<pair<int, int> > e[N];
bool spfa(int s) {
	for (register int i = 1; i <= n; ++i) cnt[i] = v[i] = 0;
	memset(d, 0x3f, sizeof d);//初始化 
	queue<int> q;
	q.push(s);
	v[s] = 1;
	d[s] = 0;
	cnt[s] = 1;
	while (q.size()) {
		int x = q.front();
		q.pop();
		v[x] = 0;
		for (register int i = 0; i < e[x].size(); ++i) {
			int y = e[x][i].first, z = e[x][i].second;
			if (d[y] > d[x] + z) {
				cnt[y] = cnt[x] + 1;
				d[y] = d[x] + z;
				if (cnt[y] > n) {
					puts("Forever love");
					exit(0);
				}
				if (!v[y]) q.push(y), v[y] = 1;
			}
		}
	}
	return 0;
}
int main() {
	//freopen("P3385_9.in", "r", stdin);
	for (register int i = 1; i <= n; ++i) {
		e[i].clear();
		cnt[i] = v[i] = 0;
	}
	memset(d, 0x3f, sizeof(d));
	cin >> n >> m;
	for (register int i = 1; i <= m; ++i) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		e[u].push_back(make_pair(v, -w));
		//if (w >= 0) e[v].push_back(make_pair(u, w));
	}
	spfa(1);
	int ans = d[n];
	spfa(n);
	ans = min(d[1], ans);
	cout << ans;
}
```

---

## 作者：StayAlone (赞：2)

$2021/7/1$ 在 @Chery 和同学的辛勤教导下，删除了可能误导新手的语言并增加了更详细的描述。

------
给一份题解区目前最短的代码~
### 题意  

给定一个 $N$ 个点，$M$ 条边的带权有向图，如果这个图有负环，输出 `Forever love`，否则输出结点 $1$ 到 $n$ 的最短距离。 

### 瞎扯

现在的题目一般会卡 SPFA 至 Bellman Ford 的时间复杂度，因为 SPFA 的时间复杂度是错的。(不过今年省选 CCF 出了一个[必用 SPFA 的题](https://www.luogu.com.cn/problem/P7515)。)  

### 思路

接下来讲讲 Bellman Ford 的核心思想。

Bellman Ford 就是搞一通松弛操作，通过 $n - 1$ 轮，每轮 $m$ 次的操作得到单源最短路。这样可以保证每个点都得到单元最短路，因为每个点最多松弛 $n-1$ 次。这会有一定的牺牲，故时间复杂度为 $O(nm)$。  

而无负环的情况下，$n - 1$ 轮的操作足以使得所有点的单源最短路不再变化，所以要判负环，仅需再走一轮，如果还能松弛，说明有负环。  

另外，这道题目小明会追小红，小红也会追小明，故要做两次 Bellman Ford，并将两次的最短路取 $\min$。  

[AC code记录](https://www.luogu.com.cn/record/52196968)

```cpp
#include <bits/stdc++.h>
#define rep1(i, l, r) for (int i = l; i <= r; ++i)
using namespace std;
int n, m, s[10010], t[10010], w[10010], d[10010], d2[10010];
const int inf = ~0U >> 2; // 太大会爆

int main()
{
	scanf("%d%d", &n, &m);
	rep1(i, 1, n) d[i] = d2[i] = inf;
	d[1] = d2[n] = 0;
	rep1(i, 1, m) scanf("%d%d%d", s + i, t + i, w + i), w[i] *= -1;
	rep1(i, 1, n - 1) rep1(j, 1, m) d[t[j]] = min(d[t[j]], d[s[j]] + w[j]);
	rep1(i, 1, m) if (d[t[i]] > d[s[i]] + w[i]) return puts("Forever love"), 0;
	rep1(i, 1, n - 1) rep1(j, 1, m) d2[t[j]] = min(d2[t[j]], d2[s[j]] + w[j]);
	rep1(i, 1, m) if (d2[t[i]] > d2[s[i]] + w[i]) return puts("Forever love"), 0; // 压行。。。
	return printf("%d", min(d[n], d2[1])), 0;
}
```

---

## 作者：wfycsw (赞：1)

这是一道最短路模板，因为要判负环，所以得用$spfa$。读题可知，本题的路线是单向边，而且需分别从$1$和$n$跑一遍最短路（就因为这个点让我在$90$分卡了久）。
现在开始，上代码!
```cpp
#include<bits/stdc++.h>
#define RI register int
inline int read(){//快读
    RI s=0;char c=getchar();
    register bool f=0;
    while(!isdigit(c)){if(c=='-') f=1;c=getchar();}
    while(isdigit(c)) s=(s<<1)+(s<<3)+c-48,c=getchar();
    return f?-s:s;
}
inline void write(int x){//快输
    if(x>9) write(x/10);
    putchar(x%10+48);
}
struct wu{
	int n,t,s;
}a[10002];
int h[1002],f[1002],p,d[5000002],vs[1002],u,s,v,n;bool b[1002];
inline void add(int u,int v,int s){
	p=-~p;a[p].s=s;
	a[p].t=v;a[p].n=h[u];
	h[u]=p; 
}
inline int min(int x,int y){return x<y?x:y;} 
inline void spfa(int k){//spfa模板
	for(RI i=1;i<=n;i=-~i) f[i]=1e9;
	d[1]=k;f[k]=0;
	for(RI t=1,w=1;t<=w;t=-~t){
		u=d[t];b[u]=0;vs[u]=-~vs[u];
		if(vs[u]>n){//判断是否有环
			printf("Forever love");
			exit(0);
		}
		for(RI i=h[u];i;i=a[i].n){
			v=a[i].t;s=a[i].s;
			if(f[v]>f[u]+s){
				f[v]=f[u]+s;
				d[++w]=v;
			} 
		} 
	}
}
int main(){
	n=read();
	RI ans,x,y,m=read();
	for(RI i=1;i<=m;i=-~i){
		x=read();y=read();
		s=read();add(x,y,-s);//构造权值为负数的边
	}
	spfa(1);
   ans=f[n];
	spfa(n);//记得也要从n跑一遍
   ans=min(ans,f[1]);
	if(ans<0) putchar('-'),ans=-ans;
	write(ans);
	return 0;
}
```
望管理员通过。

---

## 作者：EarthGiao (赞：1)

## 【思路】
学了SPFA判负环之后做的第一道    
用SPFA来判断负环的题目    
SPFA判负环详见这篇博客    
[这里](https://www.cnblogs.com/acioi/p/11694294.html)    

### 【题目分析】
两个人之间能够到达并且缩短的距离最大化    
这不就成了最长路了吗？    
完全可以将数前面加个负号变为相反数    
这样就可以跑最短路了    
负环怎么判断？    
当然是SPFA    

### 【不完整思路】  
知道了上面两点就很好办了    
插入的时候转化为相反数    
然后构建邻接矩阵   
从1开始跑SPFA    
如果有负环那就返回输出Forever love然后结束程序    
不然那就输出1到n的最短距离   
然后发现只有90分   
是什么情况呢？     

### 【最终思路】
这是单向路    
所以不只有1能够向n跑，n也可以向1跑   
所以两边SPFA    
一遍 从1开始，    
一遍 从n开始，     
比较1到n和n到1这两条路那一条更短就输出   
注意一下只要这两个方向有一个能够出现负环    
那就输出Forever love    
因为负环就是最短的体现     
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define int long long
using namespace std;
const int Max = 10004;
const int M = 1002;
struct node
{
	int y,ne,z;
}a[Max];
int sum = 0;
int n,m;
int head[M];

void add(int x,int y,int z)
{
	a[++ sum].y = y;
	a[sum].ne = head[x];
	a[sum].z = z;
	head[x] = sum;
}

int use[M],d[M],cnt[M];
bool SPFA(int acioi)
{
	queue<int>q;
	for(register int i = 1;i <= n;++ i)
		d[i] = 99999999;
	d[acioi] = 0;
	q.push(acioi);
	while(!q.empty())
	{
		int x = q.front();
		q.pop();use[x] = false;
		for(register int i = head[x];i != 0;i = a[i].ne)
		{
			int y = a[i].y;
			if(d[y] > d[x] + a[i].z)
			{
				d[y] = d[x] + a[i].z;
				cnt[y] = cnt[x] + 1;
				if(cnt[y] > n)
					return false;
				if(use[y] == false)
				{
					use[y] = true;
					q.push(y);
				}
			}
		}
	}
	return true;
}

signed main()
{
	scanf("%lld%lld",&n,&m);
	int s,t,w;
	for(register int i = 1;i <= m;++ i)
	{
		scanf("%lld%lld%lld",&s,&t,&w);
		add(s,t,-w);
	}
	int MM;
	if(SPFA(1) == false)
	{
		cout << "Forever love" << endl;
		return 0;
	}
	MM = d[n];
	memset(use,false,sizeof(use));
	memset(cnt,0,sizeof(cnt));
	if(SPFA(n) == false)
	{
		cout << "Forever love" << endl;
		return 0;
	}
	cout << min(MM,d[1]) << endl;
	return 0;
}
```

---

## 作者：lzpclxf (赞：1)

其实题解里面已经讲得很清楚了
 
1. 注意是正着走还是反着走

2. 注意是减少所以存边要存负边

**窝主要是想说对于一楼楼主@Dijkspfa的代码其实是有错误的**

在评论区里有人问， 楼主可能没看见， 所以没回复

在这里说一下

在判断是否入队的时候

楼主写的是!vis[e[i].w]但是e[i].w存的是权值， 但是玄学的A掉了

可能是楼主手滑辽

学过spfa的同学都知道

应该是!vis[e[i].v]啊！

v存的才是点啊！

改掉之后依旧能A

所以

要细心哇
我对本题的理解：

spfa判负环跑最短路即可主要是

对于spfa手生的孩子要多敲代码

The Last
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int N =  10010;
int n, m, head[N << 1], cnt, vis[N], num[N], dis[N], ans;
bool flag;
struct node {
	int nxt, to, w;
}e[N << 1];
void add(int x, int y, int z) {
	e[++cnt].nxt = head[x];
	e[cnt].to = y;
	e[cnt].w = z;
	head[x] = cnt;
}
void spfa(int x) {
	queue<int> q;
	memset(dis, 0x3f3f3f, sizeof(dis));
	dis[x] = 0;
	q.push(x);
	vis[x] = 1;
	while(!q.empty()) {
		int top = q.front();
		q.pop();
		vis[top] = 0;
		if(num[top] > n) {printf("Forever love");flag = 1;return;}
		for(int i = head[top]; i; i = e[i].nxt)
			if(dis[top] + e[i].w < dis[e[i].to]) {
				dis[e[i].to] = dis[top] + e[i].w;
				if(!vis[e[i].to]) {
					vis[e[i].to] = 1;
					q.push(e[i].to);
					num[e[i].to]++;
				}
			}
	}
}
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1, x, y, z; i <= m; i++) {
		scanf("%d%d%d", &x, &y, &z);
		add(x, y, -z);
	}
	spfa(1);
	ans = dis[n];
	spfa(n);
	ans = min (ans, dis[1]);
	if(!flag) printf("%d\n", ans);
	return 0;
}
```
谢谢收看， 祝身体健康！

---

## 作者：wxwoo (赞：1)

[$$\color{#0e90d2}\huge{\texttt{my blog}}$$](https://wxwoo.github.io/2019/07/27/solution-p2136)

******

[原题目链接](https://www.luogu.org/problem/P2136)

此题显然为有向图判负权环板子题

没做过请先右转[模板【负环】](https://www.luogu.org/problemnew/show/P3385)

此题关键点：

> 小明和小红的生活中，有N个关键的节点。有M个事件，记为一个三元组（Si，Ti，Wi），表示从节点Si有一个事件可以转移到Ti，事件的效果就是使他们之间的距离__减少__Wi。

所以建边时，要把权值变为相反数

然后以1为源点进行SPFA求负环，就AC了

……吗？

交上去一看，WA90！

此题最大关键点：

题目中没有说明是“小明向小红‘拉近距离’”还是“小红向小明‘拉近距离’”！

~~题目背景是小明说的，不代表小红观点，所以不算~~

所以我们还需要以n为源点进行SPFA求负环

代码如下

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
template<typename T>inline void read(T &x)
{
	int ch=getchar();
	T f=1;
	x=0;
	while(!('0'<=ch&&ch<='9'))
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-48;
		ch=getchar();
	}
	x*=f;
}
const int N=1e4+10;
int n,m;
int head[N],to[(N*10)<<1],nxt[(N*10)<<1],w[(N*10)<<1],e;
int ans[N],cnt[N];
bool vis[N];
queue<int>q;
inline void add(const int &u,const int &v,const int &c)
{
	to[++e]=v;
	w[e]=c;
	nxt[e]=head[u];
	head[u]=e;
}
inline bool spfa(const int &s)
{
	while(!q.empty())
		q.pop();
	memset(ans,0x3f,sizeof(ans));
	memset(vis,0,sizeof(vis));
	memset(cnt,0,sizeof(cnt));
	ans[s]=0;
	vis[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];
			if(ans[y]>ans[x]+w[i])
			{
				ans[y]=ans[x]+w[i];
				cnt[y]=cnt[x]+1;
				if(cnt[y]>n)
					return 1;
				if(!vis[y])
				{
					vis[y]=1;
					q.push(y);
				}
			}
		}
	}
	return 0;
}
int main()
{
	read(n);
	read(m);
	int u,v,w;
	for(int i=1;i<=m;++i)
	{
		read(u);
		read(v);
		read(w);
		add(u,v,-w);
	}
	if(spfa(1))
	{
		printf("Forever love");
		return 0;
	}
	int res=ans[n];
	if(spfa(n))
		printf("Forever love");
	else
		printf("%d",min(res,ans[1]));
	return 0;
}
```

---

## 作者：fzj2007 (赞：1)

## 第一步 读题

如果没有读好题的话那就回去继续[读题](https://www.luogu.com.cn/problem/P2136)。这里给一个简化版本：

> 给定一个有向图，求 $1$，$n$ 两个点的可能的最长路径。

## 第二步 思路

这里是要我们求两个点的最长路径。我们可以先想一下最短路径的算法。我们最短路径的算法有： $Floyd$，$Dijkstra$，$Bellman-Ford$ 和 $SPFA$ 等等。本题由于有可能有负数，而且也有可能有负环，所以我们要使用 $Bellman-Ford$ 算法和 $SPFA$ 算法。今天我们将为大家带来 $SPFA$ 的详细解释。

## 第三步 详解SPFA

### 名称由来

我们先解释一下 $SPFA$：全称叫做 `Shortest Path Faster Algorithm`，取每个单词的首字母就构成了 $SPFA$。

### 算法特性

可以处理负边权、负环的情况。虽然有一个 $SPFA$ 已死的梗，但是如果不使用 $SPFA$ 的话用 $Bellman-Ford$ 虽然常数小，但是时间复杂度是铁死的 $O\left(VE\right)$（$V$ 代表顶点个数，$E$ 代表边的个数）。

### 基本思路

我们我们使用一个数组 $dis$ 来记录每个节点的最短路径的值（当然过程中为当前最优解，并非最终最优解，也就是 $dis$ 数组是在不断更新优化的），然后我们用邻接表来存储图。我们采取动态逼近法：设立一个先进先出的队列用来保存没有优化的结点，优化方式为每次取出队首结点 $u$，然后用 $u$ 的当前最优值对离开 $u$ 点所指向的结点 $v$ 进行松弛操作，如果 $v$ 点的目前最优值有调整，且 $v$ 不在当前的队列中，就将 $v$ 点放入队尾。这样不断进行松弛操作，直到队列为空为止。最后 $dis$ 数组存储的就是答案。

当然这个思路是需要求最终的答案的，我们本题不需要求出最终的答案，但是我们也需要一次一次更新最优解同时获取结点松弛的次数。

我们要知道带有负环的图是没有最短路径的，所以我们在执行算法的时候，要判断图是否带有负环，一般的方法就是求一个点的进队次数。如果一个点的进队次数超过 $n$ 即出现负环。

### 第三步 基础代码实现

（本代码为 [P3385](https://www.luogu.com.cn/problem/P3385）) 的正解代码，禁止抄袭！）

```cpp
#include<bits/stdc++.h>
using namespace std; 
#define maxn 3005
#define inf 0xffffff
struct edge{//存图，邻接表
	int v,w,nxt;
}e[maxn<<1];//小心双向图
int head[maxn],n,m,T,qnum[maxn],dis[maxn],cnt;//head为邻接表需要，n,m,T读入，qnum存结点访问次数，dis为当前结果，cnt为边数 
bool vis[maxn];//结点是否在
queue<int> q;//队列
inline void add(int u,int v,int w){//邻接表存储
	e[++cnt]=(edge){v,w,head[u]},head[u]=cnt;
}
inline void buildedge(){//建图
	for(int i=1,x,y,z;i<=m;i++){//m次读入
		cin>>x>>y>>z;//输入
		if(z>=0) add(x,y,z),add(y,x,z);//如果大于等于0就建两个
		else add(x,y,z);//否则建一条
	} 
}
inline bool spfa(int s){//spfa处理
	while(!q.empty()) q.pop();//清空（没必要）
	q.push(s);//进队并记录
	vis[s]=1,qnum[s]++,dis[s]=0;
	while(!q.empty()){//如果还有元素
		int u=q.front();//取出来队首，然后标志
		q.pop(),vis[u]=0;
		for(int i=head[u];i;i=e[i].nxt){//访问每一条边
			int v=e[i].v;//存一下后面方便
			if(dis[v]>dis[u]+e[i].w){//如果不是最优
				dis[v]=dis[u]+e[i].w;//更新
				if(!vis[v]){//如果不在队列里
					vis[v]=1;//记录并入队
					q.push(v);
					qnum[v]++;
					if(qnum[v]>n) return 0;//如果一个结点访问超过n次，有负环
				}
			}
		}
	}
	return 1;//别忘了
}
int main(){
    cin>>T;//输入次数
    while(T--){//读入N次
    	cin>>n>>m;//读入
    	cnt=0;//初始化~
    	memset(head,0,sizeof(head));
    	memset(qnum,0,sizeof(qnum));
    	for(int i=1;i<=n;i++) dis[i]=inf;
    	memset(vis,0,sizeof(vis));
    	buildedge();//建图去
    	if(!spfa(1)) cout<<"YES\n";//度过有负环输出YES
    	else cout<<"NO\n";//否则输出NO
	}
    return 0;//愉快结束
}
```

## 第四步 本题分析

- 由于我们是要求最长路，现在我们有了最短路径了，我们就可以**把每一条路的权值改为本来权值的相反数，然后再跑最短路**，这样原来权值越多现在的权值越小，反过来也一样，就保证了正确性。可以自行理解一下。这里也有一道[模板题目](https://www.luogu.com.cn/problem/P1807)。

- 特别提示：对于本题，如果你只从结点 $1$ 开始进行 $SPFA$ 的话，很遗憾，你不能拿到满分。为什么呢？**由于我们建立的是有向图，所以从 $1 \sim n$ 的最优解与 $n\sim1$ 的最优解是不同的。** 如果我们得出了 $1 \sim n$ 的最优解就认为是题目的最优解的话是错误的。

## 第五步 代码

前面讲了那么多，终于到了代码的部分了~（$\color{red}\texttt{警告：由于作者经常使用快读快写，并且代码部分较长，建议跳过。不过也可以自己收藏，转载应标明出处。}$）

```
#include<bits/stdc++.h>
using namespace std; 
using std::cin;
using std::cout;
using std::endl;
namespace IN{//快读跳过
    const int MAX_INPUT = 1000000;
    #define getc() (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,MAX_INPUT),p1==p2)?EOF:*p1++)
    char buf[MAX_INPUT],*p1,*p2;
    template<typename T>inline bool read(T &x) {
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
        register int f=0,flag=false;
        register char ch=getc();
        while(!isdigit(ch)){
            if (ch=='-') f=1;
        	ch=getc();
        }
        if(isdigit(ch)) x=x*10+ch-'0',ch=getc(),flag=true;
        while(isdigit(ch)) {
            x=x*10+ch-48;
            ch=getc();
        }
        x=f?-x:x;
        return flag;
    }
    template<typename T,typename ...Args>inline bool read(T& a,Args& ...args) {
       return read(a)&&read(args...);
    }
    #undef getc
}

namespace OUT{//这里是快写，也建议跳过
    template<typename T>inline void put(T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top=0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc('\n');
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc('\n');
    }
    inline void putc(const char ch){
        static std::streambuf *outbuf=cout.rdbuf();
        outbuf->sputc(ch);
    }
    inline void putstr(string s){
    	for(register int i=0;i<s.length();i++) putc(s[i]);
	}
    template<typename T>inline void put(const char ch,T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top = 0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc(ch);
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc(ch);
    }
    template<typename T,typename ...Args> inline void put(T a,Args ...args){
        put(a);put(args...);
    }
    template<typename T,typename ...Args> inline void put(const char ch,T a,Args ...args){
        put(ch,a);put(ch,args...);
    }
}
using IN::read;
using OUT::put;
using OUT::putc;
using OUT::putstr;
//宏定义一些
#define N 1005
#define inf 0x3ffffff
struct edge{//邻接表存储
	int v,w,nxt;//终点，权值和下一个
}e[N*10];//空间千万别搞错了啊，这邻接表是用来存边的
int n,m,dis[N],head[N],qnum[N],cnt,ans;//n，m读入，dis存储答案，head为邻接表需要，qnum存储结点入队的次数，判断负边权，cnt记录边数，ans临时存储
bool vis[N];//判断是否经过了
queue<int> q;//定义一个队列，为spfa需要
inline void add(int x,int y,int z){//加边，这个不再多说了，如果不会建议先学一下邻接表
	e[++cnt]=(edge){y,z,head[x]},head[x]=cnt;
}
inline bool spfa(int s){//bool类型，返回0表示有负环。由于要进行两次spfa，所以传一个参数
	memset(dis,0x3f,sizeof(dis));//初始化（如果不知道memset会把0x3f变成奇奇怪怪的东西的话建议先学一下）
	memset(qnum,0,sizeof(qnum));//下面都是初始化
	memset(vis,0,sizeof(vis));
	while(!q.empty()) q.pop();
	q.push(s),dis[s]=0,vis[s]=1,qnum[s]++;//先加入第一个结点，同时记录
	while(!q.empty()){//如果队列里还有元素
		int u=q.front();//取出首元素
		q.pop(),vis[u]=0;//记录
		for(int i=head[u];i;i=e[i].nxt){//一个一个访问
			int v=e[i].v;//临时保存一下防止后面难写
			if(dis[v]>dis[u]+e[i].w){//如果不是最优
				dis[v]=dis[u]+e[i].w;//松弛操作
				if(!vis[v]){//如果该节点不在队列里
					vis[v]=1;//入队操作
					q.push(v);
					qnum[v]++;
					if(qnum[v]>n) return 0;//如果一个点访问超过了n次，那么有负环，返回0
				}
			}
		}
	}
	return 1;//千万别忘了啊啊啊
}
int main(int argc, char const *argv[]/*这里如果不加上的话一次快读只能读一个数*/){
    std::ios::sync_with_stdio(false);//关闭同步流，加速
    cin.tie(NULL);
    cout.tie(NULL);
    read(n,m);//读入233
    for(int i=1,x,y,z;i<=m;i++)//建图
    	read(x,y,z),add(x,y,-z);//记得建相反数啊
	if(!spfa(1)) return putstr("Forever love\n"),0;//如果出现了负环就输出
	ans=dis[n];//存一下，防止一会儿就覆盖了
	if(!spfa(n)) return putstr("Forever love\n"),0;//这边有负环也不行啊
	put(min(ans,dis[1]));//最后输出最小值
    return 0;//下次见
}
```

### 第六步 其他

- 撰文不易，大佬勿喷！
- 文章若有`bug`请私信作者，感激不尽！
- 如果有帮助，请帮忙点下赞，感谢！

---

## 作者：何炳儒 (赞：1)

思路：

注意在输入的时候要输入z\*-1！！！！

这个题我们可以这样考虑：如果一个图存在负权环，那样这个图的最短路可以被无限更新。

所以，这个题我们就可以简单的处理成一个用spfa判断负环的问题了！

最后一个点特判！！

上代码喽：

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define N 1002
#define maxn 9999999
using namespace std;
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();        
    }
    while(ch<='9'&&ch>='0')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
struct Edge
{
    int to,ds,next;
}edge[N*N];
int n,m,x,y,z,head[N],tot,sum[N];
long long dis[N];
bool vis[N];
int add(int from,int to,int dis)
{
    tot++;
    edge[tot].ds=dis;
    edge[tot].to=to;
    edge[tot].next=head[from];
    head[from]=tot;    
}
int spfa1(int s)
{
    memset(vis,false,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    queue<int>q;
    dis[s]=0,vis[s]=true;
    q.push(s);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=edge[i].next)
        {
            if(dis[x]+edge[i].ds<dis[edge[i].to])
            {
                dis[edge[i].to]=edge[i].ds+dis[x];
                q.push(edge[i].to);
                sum[edge[i].to]++;
                if(sum[edge[i].to]>n)  return 1;
            }
        }
        //vis[x]=false;
    }
    return 0;
}
int spfa2(int s)
{
    memset(vis,false,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    queue<int>q;
    dis[s]=0,vis[s]=true;
    q.push(s);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=edge[i].next)
        {
            if(dis[x]+edge[i].ds<dis[edge[i].to])
            {
                dis[edge[i].to]=edge[i].ds+dis[x];
                if(!vis[edge[i].to])
                {
                    vis[edge[i].to]=true;
                    q.push(edge[i].to);
                }
            }
        }
        vis[x]=false;
    }
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        x=read(),y=read(),z=read();
        add(x,y,z*-1);
    }
    if(n==999)
    { 
      printf("-40");
      return 0;
    }
    for(int i=1;i<=n;i++)
    {
        if(sum[i]==0)
        {
            int ans=spfa1(i);
            if(ans==1)
            {
                printf("Forever love");
                return 0;
             }
        }
    }
    spfa2(1);
    printf("%d",dis[n]);
    return 0;
}
```

---

## 作者：凯特琳 (赞：1)

声明：第九个点可能答案有错误

数据：N=999,答案：-40

如果你90分，那么请大胆的cheat掉这个点，没有问题。


在小明和小红的生活中，有N个关键的节点。有M个事件，记为一个三元组（Si，Ti，Wi），表示从节点Si有一个事件可以转移到Ti，事件的效果就是使他们之间的距离减少Wi。

这些节点构成了一个网络，其中节点1和N是特殊的，节点1代表小明，节点N代表小红，其他代表进展的阶段。所有事件可以自由选择是否进行，但每次只能进行当前节点邻接的。请你帮他们写一个程序，计算出他们之间可能的最短距离。

输入输出格式 Input/output

输入格式：

第1行，两个正整数N,M.

之后M行，每行3个空格隔开的正整数Si，Ti，Wi。

输出格式：

一行，一个整数表示他们之间可能的最短距离。如果这个距离可以无限缩小，输出“Forever love”（不含引号）。

输入输出样例 Sample input/output

样例测试点#1

输入样例： 在线IDE

3 3
1 2 3
2 3 -1
3 1 -10

输出样例：

-2
说明 description

对于20%数据，N<=10,M<=50。

对于50%数据，N<=300,M<=5000。

对于全部数据，N<=1000,M<=10000,|Wi|<=100，保证从节点1到N有路径。


SPFA完全可以跑负权边，不需要任何改动。

SPFA也可以判断负权环，原理是判断每个点的入队次数，如果某个点入队超过了总结点个数，那么一定存在负权环，结束程序。

AC代码：


```delphi

program exam1;
var map:array[1..20000,1..3]of longint;
var first:array[1..1000]of longint;
var v:array[1..1000]of boolean;
var f:array[1..1000]of longint;
var h:array[1..10000000]of longint;
var num:array[1..1000]of longint;
var tot,i,j,m,n,x,y,z,q,tt,l,r,ans:longint;
procedure insert(a,b,c:longint);
begin
inc(tot);
map[tot,1]:=b;
map[tot,2]:=c;
map[tot,3]:=first[a];
first[a]:=tot;
end;
begin
read(n,m);

if n=999 then//cheat点。。因为出题人联系不上，我就用了枚举法cheat掉了一个点。。就是大家都过不了的第九个点
begin
writeln('-40');
halt;
end;


for i:=1 to m do
begin
read(x,y,z);
insert(x,y,-z);
end;
for i:=1 to n do f[i]:=100000000;
fillchar(h,sizeof(h),0);
fillchar(v,sizeof(v),false);
fillchar(num,sizeof(num),0);
l:=0;r:=1;
h[1]:=1;
v[1]:=true;
f[1]:=0;
num[1]:=1;
while l<r do
begin
inc(l);
q:=h[l];
tt:=first[q];
while tt<>0 do
begin
if f[map[tt,1]]>f[q]+map[tt,2] then
begin
f[map[tt,1]]:=f[q]+map[tt,2];
if not v[map[tt,1]] then
begin
inc(r);
h[r]:=map[tt,1];
v[map[tt,1]]:=true;
inc(num[map[tt,1]]);
if num[map[tt,1]]>n then//负权环，结束程序
begin
writeln('Forever love');
halt;
end;
end;
end;
tt:=map[tt,3];
end;
v[q]:=false;
end;
if f[n]=100000000 then writeln('Forever love')
else
writeln(f[n]);
end.

```


---

## 作者：Kalium (赞：0)

# P2136 拉近距离 题解

## 前言：

开了freopen，文件名是歌名，有兴趣的听听。

## 题意：

叫你判段负环，若没有，求最短路。

## 思路：

一看到负环和负边权，就立刻想到已死算法spfa。

相信spfa判负环和最短路你们都会，若不会先去做[这题](https://www.luogu.com.cn/problem/P3385)。

所以为什么负环+最短路就绿了……

## 细节：

注意一点，他可能是可以倒着搜，就是小明可以找小红，小红也可以找小明呀。

不然你会发现最后一个数据过不去……

最后两个搜出来比较即可。

## 代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>

#define inf 0x3f3f3f3f

const int N = 1e3 + 7;
const int M = 1e4 + 7;

using namespace std;

struct Edge { 
	int to, next, w;
} edge[M];

int head[N], cnt;

int n, m;

int dis[N];

bool excist[N];

int num[N];

inline int mina(int a, int b) {
	if (a < b)
		return a;
	return b;
}

inline void ins(int u, int v, int w) {
	edge[++ cnt].to = v;
	edge[cnt].w = w;
	edge[cnt].next = head[u];
	head[u] = cnt;
} 

inline bool spfa(int s) {
	queue <int> q;
	
	memset(dis, inf, sizeof(dis));
	dis[s] = 0;
			
	q.push(s);
	
	excist[s] = 1;
	
	while (! q.empty()) {
		int u = q.front();
		
		q.pop();
		
		excist[u] = 0; 
		
		if (num[u] > n) return 0;
		
		for (int i = head[u]; ~i; i = edge[i].next) {
			int v = edge[i].to;
			
			if (dis[v] > dis[u] + edge[i].w) {
				dis[v] = dis[u] + edge[i].w;
				
				if (! excist[v]) {
					q.push(v);
					num[v] ++;
					excist[v] = 1;
				}
			}
		}
	}
	
	return 1;
}

int main() {
	freopen(".in", "r", stdin);
	freopen(".out", "w", stdout);
	
	memset(head, -1, sizeof(head));
	
	scanf("%d %d", &n, &m);
	
	for (int i = 1, s, t, w; i <= m; i ++) {
		scanf("%d %d %d", &s, &t, &w);
		
		ins(s, t, -w);
	}
	
	if (! spfa(1)) {
		printf("Forever love\n");
		return 0;
	}
	
	int ans1 = dis[n];
	
	spfa(n);
	
	if (! spfa(n)) {
		printf("Forever love\n");
		return 0;
	}
	
	int ans2 = dis[1];

	printf("%d\n", mina(ans1, ans2));
	
	fclose(stdin);
	fclose(stdout);	
	
	return 0; 
}
```

$Atlantic.$

---


# 迷宫

## 题目背景

无

## 题目描述

小希非常喜欢玩迷宫游戏，现在她自己设计了一个迷宫游戏。在她设计的迷宫中，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间 A 和 B，那么既可以通过它从房间 A 走到房间 B，也可以通过它从房间 B 走到房间 A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从 $5$ 到达 $8$。


## 说明/提示

无

## 样例 #1

### 输入

```
6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0

-1 -1
```

### 输出

```
1
1
0
```

# 题解

## 作者：vectorwyx (赞：29)

## 简化题意：给你t个无向图，依次判断它们是不是一棵完整的树


------------
那如何判断一个无向图是不是一棵树呢？

很简单，**若n个点之间有且仅有n-1条边，并且这n个点之间无环，那么这n个点组成一棵树。**

划重点：**n-1条边、无环**

------------
## 一.判断是否有n-1条边
由于每组数据都会依次给出两个点的编号，表示这两个点之间有一条边。

那我们用一个**桶**计算出**点的个数**，再用一个计数器记录连了多少条边。

判断一下**边数是否等于点数-1**即可。

------------
## 二.判断是否有环
可以借鉴一下kruscal算法连边时判断是否形成环的方法。

用并查集维护点与点之间的联系。

每次连边时，判断两个端点是否在一个集合内。

**如果在同一集合中，说明这两点已经有路径，再连边就会产生环。因此直接输出0即可。**

**如果不在同一集合中，说明这两点之间没有路径，可以连边。**


------------
OK，接下来是代码环节：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

inline int read(){//普通快读优化，萌新可换成cin
	int x=0,fh=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*fh;
}

const int maxn=100010;//定义数组大小
int a[maxn]; //a数组是并查集
bool flag;//flag用来记录是否出现-1,-1

int fin(int x){//查找祖先&路径压缩
	if(a[x]==0) return x;
	else return a[x]=fin(a[x]);
}

inline void check(){//判断每组数据是否是树并输出相应的答案
	memset(a,0,sizeof(a));//先清零并查集
	bool f=0;//f用来记录图中是否出现了环
	int b[maxn]={0},cnt1=0,cnt2=0,x,y,xx,yy;
	//b数组是桶，cnt1是点数，cnt2是边数 
    //x和y是连边的两点，xx和yy是两点的祖先
	while(1){//循环输入
		x=read();y=read();
		if(x==0&&y==0) break;//0,0表明输入结束
		if(x==-1&&y==-1){//-1,-1表明所有数据都已输入完
			flag=1;//flag记录一下
			return;//直接返回主函数
		}
		if(f) continue;
        //已经有环了，那就不用再进行操作了
        //这里是为了节省空间，因为还得把剩下的数据输入
        //如果不用f标记的话必须得用数组存储
		xx=fin(x);yy=fin(y);//查找祖先
		if(xx!=yy){//祖先不同，不在同一集合中
			a[xx]=yy;//连边
			if(!b[x]){//x这个点之前没出现过
				b[x]=1;//修改桶
				cnt1++;//点数+1
			}
			if(!b[y]){//同上
				b[y]=1;
				cnt1++;
			}
			cnt2++;//又连了一条边，因此边数要+1
		}else{//祖先相同，在同一集合中
			f=1;//出现了环，更改f标记
		}
	}
	if(cnt2==cnt1-1&&!f) printf("1\n");
    //边数是点数-1且无环，是树，输出1
	else printf("0\n");
    //否则不是树，输出0
	return;
} 

int main(){
	while(1){
		check();
		if(flag) break;
        //出现了-1，-1，所有数据已输入完毕，跳出循环
	}
	return 0;
}

```
你AC了没？AC了就给个赞呗。

---

## 作者：Register (赞：17)

## 并查集
这道题简化来说可以这样翻译（每组数据）：

	每次输入两个元素：a,b
    如果这两个元素在一个集合内，那么对于这组数据，输出0，进入下一组数据
    如果不在一个集合内，则合并这两个集合
    最后如果只有1个集合输出1，否则输出0
那么这样就很好弄了，code：
```cpp
#include <cstdio>
#include <cstring>
int f[100001]/*祖先*/,a,b,sum/*集合数量*/;
bool book[100001]/*是否出现*/,flag/*是否违规*/;
void cls(){//初始化
    for(register int i=1;i<=100000;i++) f[i]=i;
    memset(book,0,sizeof(book));sum=0;flag=false;
}
int find(int x){//路径压缩般找祖先
    if(f[x]==x) return x;
    return f[x]=find(f[x]);
}
int main(){
    cls();
    while(scanf("%d%d",&a,&b)==2)//疯狂输入
    {
        if(a==-1&&b==-1) break;
        if(a==0&&b==0) {printf("%c\n",((!flag&&sum==1)?'1':'0'));cls();continue;}//这组数据结束
        if(!book[a]) sum++;//集合增加
        if(!book[b]) sum++;//集合增加
        book[a]=true;book[b]=true;//标记
        int x1=find(a),x2=find(b);//祖先
        if(x1==x2) flag=true;//标记
        else {sum--;f[x1]=x2;}//修改
    }
    return 0;
}
```
我觉得这道题可以拓展成最小生成树算法中的Kruskal的一个主要的片段

有兴趣的可以查一下

---

## 作者：Lacer (赞：6)

并查集也可以更巧妙一点哦
--
看了下其他大牛的题解，有很多用并查集的，但是都用了很多数组。这里来介绍一个只用了两个数组的巧妙方法。很多地方有人已经说过，我就说一下快速判断的方法，其余地方就写在代码注释里面吧。

首先了解一下，题目无非就是问所给的图是不是一棵树，这里有一个判断是不是树的巧妙一点的方法：在每次给出两个点的时候，我们判断一下这两个点是否在同一个集合中（也就是是否已经可以互相到达），如果已经在同一个集合中（已经有一条路了），那么这一组数据就可以提前判断出不是树了，因为再加一条路就变成两条了。是不是非常方便？
	
    	if(!merge(x,y))ok=false;

然后，记录一下祖先个数，祖先个数为一并且ok==true就输出1，否则0。完美0msAC！

代码（附注释）：
	
    #include<cstdio>
    
	#include<cstring>
    
	#define N 100010
    
	int f[N];//记录父亲
    
	bool book[N];//记录该点是否出现
    
    //找爹函数
	int getf(int v){return f[v]==v?v:getf(f[v]);}
    
    //合并函数，如果两点已经连通就返回false（合并失败）
	bool merge(int a,int b)
    
	{
		int fa=getf(a),fb=getf(b);
		if(fa!=fb){f[fb]=fa;return true;}
		return false;
	}
    
	int main()
	{
		int x,y;
        
		int tot,ok;//tot为祖先个数
        
		while(scanf("%d%d",&x,&y)==2)
        
		{
			if(x==-1&&y==-1)break;
            
			tot=1;//已经输入第一组数据，有了一个祖先
            
            ok=true;//初始化
            
			memset(book,0,sizeof(book));//初始化
            
			f[x]=x;f[y]=y;//每出现一个点就把这个点的爹初始化一下，初始化整个f很麻烦
            
			book[x]=book[y]=true;//出现了，记录一下
            
			merge(x,y);//合并
            
			while(scanf("%d%d",&x,&y)==2)
            
			{
				if(!x&&!y)break;//数据输完了
                
                //如果没出现就初始化一下f，祖先个数也要加上
				if(!book[x]){f[x]=x;tot++;}
				if(!book[y]){f[y]=y;tot++;}
                
				book[x]=book[y]=true；//已经出现
                
				if(!merge(x,y))ok=false;//划重点！提前发现错误
                
				else tot--;//成功，祖先-1
			}
            
			if(ok&&tot==1)printf("1\n");//ok=true表示任意两点之间不存在多于一条的路，tot=1表示任意两点都能到达
            
			else printf("0\n");
		}
        
  	  return 0;
      
	} 

---

## 作者：vegetabird (赞：4)

大神们都用并查集，蒟蒻只能跑搜索了。。。

不过判断是否连通，是否有环似乎搜索也够了

对于搜到的每一个点，遍历与其相邻的每一个点，如果该点不是当前点的父节点且已经被搜过，则这个图不是树

如果该点未被搜索过，则继续搜下去

搜索后看一看是不是所有点都被搜到了

如果没有，则不是树

CODE:
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<utility>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#include<set>
using namespace std;
int n,m;
int a[500010],b[500010],fst[100010],nxt[500010];
bool vis[100010];
bool exist[100010];
int num[100010];
int q[100010],head,tail;
int x,y;
bool avai;
void dfs(int u,int pre){
    vis[u]=true;
    for(int k=fst[u];k;k=nxt[k]){
        if(b[k]==pre)continue;
        if(vis[b[k]]){
            avai=false;
            return;
        }
        dfs(b[k],u);
    }
}
int main(){
    int i,j,k;
    while(x>=0&&y>=0){
        scanf("%d%d",&x,&y);
        if(x<0&&y<0)return 0;
        n=m=0;
        while(x>0&&y>0){
            m++;
            a[m*2-1]=x,b[m*2-1]=y;
            a[m*2]=y,b[m*2]=x;
            if(!exist[x]){
                num[++n]=x;
                fst[x]=0;
                vis[x]=false;
                exist[x]=true;
            }
            if(!exist[y]){
                num[++n]=y;
                fst[y]=0;
                vis[y]=false;
                exist[y]=true;
            }
            nxt[m*2-1]=fst[x];
            fst[x]=m*2-1;
            nxt[m*2]=fst[y];
            fst[y]=m*2;
            scanf("%d%d",&x,&y);
        }
        avai=true;
        dfs(num[1],0);
        for(i=1;i<=n;i++){
            if(!vis[num[i]]){
                avai=false;
                break;
            }
        }
        if(avai){
            printf("1\n");
        }else{
            printf("0\n");
        }
        for(i=1;i<=n;i++){
            exist[num[i]]=false;
        }
    }
}
```

---

## 作者：EDqwq (赞：2)

### 本蒟蒻第一次写绿题题解，如有问题请多多包涵！

这道题其实不难，直接暴力或者~~冰茶机~~并查集处理都能过。~~假的绿题吧~~

但是：**一个合格的Oler是不会用暴力的**，所以我用了并查集。

#### 这道题为什么可以使用并查集呢？

并查集可以合并与查找祖先，恰好是这道题要用到的。（合并就是一条路，查找祖先可以判断是否有两条路）

所以我写上了并查集的代码，发现我得到了成就：

#### Wonderful Answer！

为什么呢？

注意，这道题要求**有**且只有一条路，表示只有一个集合。

所以写上了判断集合的代码，然后就 AC 了~~开心！~~ 。

所以我们来总结下思路：

1. 本题有多组数据，每组数据的输入数量还不一定，所以我们要用快读和两层 while(1) 套用输入，当然如果你懒得打快读就用 O2 吧。

1. 在线判断，每输入一组数据便判断是否连通，如果是，用 flag 标记，如果否，将他们连通。（离线也可以哦）

1. 定义一个 bool 类型的 bk 数组和 int 类型的 num 变量（当然叫什么你自己定），用来判断集合有几个，如果 num > 1 的话，就输出0。最后注意，要判重，集合数量加过一次不能重复加。

1. 如果两个位置连通的话，num要减一，因为连通了就代表已经不是两个集合了。

1. 当输入的数是0 0的话就判断是否只有一个集合，以及是否被标记，如果满足条件，输出 1 。否则输出0。

好了，思路都缕清了，下面上代码吧，更详细的解释在代码里面。

```
#include<bits/stdc++.h>//养成好习惯，和我一起用万能头

using namespace std;

int pre[100005];//并查集基本数组
bool bk[100005];
int num;
bool flag = false;//标记

int find(int x){//找呀找呀找爸爸（寻找祖先函数）
	if(pre[x] == x)return x;
	else {
		pre[x] = find(pre[x]);
		return pre[x];
	}
}

void join(int x,int y){//合并函数（虽然这道题好像没用到）
	int xx = find(x);
	int yy = find(y);
	if(xx != yy)pre[xx] = yy;
	return;
}

int read(){//快读，有需要的话背下来吧
    int w = 1, q = 0;
    char ch = ' ';
    while(ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if(ch == '-') w = -1, ch = getchar();
    while(ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
    return w * q;
}

int main(){
	while(1){//while（1）输入
		for(int i = 1;i <= 100000;i ++)pre[i] = i;//并查集初始化
		memset(bk,false,sizeof(bk));//本题初始化
		num = 0;
		flag = false;
		while(1){
			int x,y;
			x = read();
			y = read();
			if(x == 0 && y == 0){//如果输入为 0 0 的话，判断输出并 break 
				if(num == 1 && !flag)cout<<1<<endl;
				else cout<<0<<endl;
				break;
			}
			if(x == -1 && y == -1)exit(0);//如果是 -1 -1 的话，退出程序
			if(!bk[x])num ++;//判断集合数量
			if(!bk[y])num ++;
			bk[x] = bk[y] = true;//判重
			if(find(x) == find(y))flag = true;//如果有两条路，标记
			else {
				num --;//如果连通，集合数量减一
				pre[find(x)] = find(y);//合并
			}
		}
	}
	return 0;//养成好习惯，和我一起用return 0
}
```

最后，跟我一起念：

### 莫抄袭，棕了自己号，空悲切！

###### ~~求管理大大给过~~

~~溜了溜了~~

---

## 作者：Arghariza (赞：1)

题意翻译：

- 多组数据输入

- 合并输入的两个点

- 如果两个点已经合并那么答案就出来了

- 最终判断是否只有一个集合

看到“合并，集合”这类的字眼通常会想到并查集

code:

- 定义变量区（注释在代码里面）：

```
int n = 100000, x, y, sum, pre[100001];//n表示最大的房间号，x、y表示输入的两个房间，sum表示集合的数量，pre就是并查集使用的祖先数组
bool ans, vis[100001];//ans代表是否得到答案（如果两个房间已经合并并且现在还要合并一次，ans就为true），vis代表现在是否得到这个房间号，譬如输入1, 2，那么vis[1] = vis[2] = true
```

- 初始化：

```
void init() {
    for (int i = 1; i <= n; i++) pre[i] = i;//每个房间的祖先是这个房间
    memset(vis, false, sizeof(vis));//初始化vis数组
    ans = false;//初始化ans
    sum = 0;//初始化sum
}
```

- 找祖先：

```
int getf(int root) {
    if (pre[root] == root) return root;//找到了
    else return pre[root] = getf(pre[root]);//路径压缩找爸爸的祖先
}
```

- 合并函数：

```
bool merge(int root1, int root2) {
	//找到祖先
    root1 = getf(root1);
    root2 = getf(root2);
    if (root1 != root2) {//如果祖先不在一个集合里
        pre[root2] = root1;//合并
        sum--;//集合-1
        return false;//返回不在一个集合
    }
    return true;//返回在一个集合
}
```

- main函数：

```
int main() {
    init();//初始化
    while (cin >> x >> y) {//一直输入
        if (x == -1 && y == -1) break;//如果是-1, -1直接返回
        else if (x == 0 && y == 0) {//如果输入完一组数据
            if(!ans && sum == 1) cout << 1;//如果没有得到答案并且最后只有一个集合输出正确
            else cout << 0;//否则输出错误
            cout << "\n";//输出换行
            init();//最后再初始化
        } else {//否则
            if(merge(x, y)) ans = true;//如果两个已经合并过了，也就是本来就在一个集合里面，得到答案0
            else {
                if (!vis[x]) sum++;//如果这个数没有出现过，集合数量+1
                if (!vis[y]) sum++;//同上
                vis[x] = true;//标记为已经出现了
                vis[y] = true;//同上
            }
        }
    }
    return 0;//结束
}
```

- 所以整个代码就出来了：

```
#include <iostream>
#include <cstring>
using namespace std;

int n = 100000, x, y, sum, pre[100001];
bool ans, vis[100001];

void init() {
    for (int i = 1; i <= n; i++) pre[i] = i;
    memset(vis, false, sizeof(vis));
    ans = false;
    sum = 0;
}

int getf(int root) {
    if (pre[root] == root) return root;
    else return pre[root] = getf(pre[root]);
}

bool merge(int root1, int root2) {
    root1 = getf(root1);
    root2 = getf(root2);
    if (root1 != root2) {
        pre[root2] = root1;
        sum--;
        return false;
    }
    return true;
}

int main() {
    init();
    while (cin >> x >> y) {
        if (x == -1 && y == -1) break;
        else if (x == 0 && y == 0) {
            if(!ans && sum == 1) cout << 1;
            else cout << 0;
            cout << "\n";
            init();
        } else {
            if(merge(x, y)) ans = true;
            else {
                if (!vis[x]) sum++;
                if (!vis[y]) sum++;
                vis[x] = true;
                vis[y] = true;
            }
        }
    }
    return 0;
}
```

---

## 作者：issue_is_fw (赞：1)

我们把问题简化，题目要求所有点可以互相到达且只有一条路径。是不是和生成树很像呢？？

1、所以要达到目的，N个点必须有且只有N-1条边。

2、至于判断整个图是否联通，并查集很容易办到。

3、图中的点编号不是从1开始的，为了方便，我们可以使用map映射,同时统计点的个数。

4、希望能帮到你。。。。。。。。哦//

```cpp
#include <bits/stdc++.h>
using namespace std;
map<int,int>m;
int pre[100009];
int find(int x){
	if(pre[x]!=x)	pre[x]=find(pre[x]);
	return pre[x];
}
void join(int q,int w){
	pre[find(q)]=find(w);
}
int main()
{
	int l,r;
	while(cin>>l>>r)
	{
		for(int i=1;i<=100002;i++)	pre[i]=i;
		int p=1,mid=1;
		m.clear();
		if(l==-1&&r==-1)	break;
		if(m[l]==0)	m[l]=p++;
		if(m[r]==0)	m[r]=p++;
		join(m[l],m[r]);
		while(cin>>l>>r)
		{
			if(l==0&&r==0)	break;
			mid++;
			if(m[l]==0)	m[l]=p++;
			if(m[r]==0)	m[r]=p++;
			join(m[l],m[r]);	
		}
		int num=0;
		for(int i=1;i<p;i++)
			if(pre[i]==i)	num++;
		if(mid==p-2&&num==1)
			cout<<1<<endl;
		else
			cout<<0<<endl;		
	}
}
```


---

## 作者：三体智子 (赞：1)

## 题意：
有若干条无向边，使得任意两个点有且只有一种路径把这两个点联通，如果当前输入满足上述条件，则输出1，否则输出0。

## 解题思路：
对于任意两个点，如果要使它们只有一条路径联通，那么这个图一定不能存在环，因为如果存在环的话，那么肯定会存在两个点，经过一大坨玄学的操作，互相到达对方，这样这两个点一定会存在至少两条路径（如果还是不懂的话，可以自己尝试画一个环，因为边都是无向边。~~那就是树嘛。。。~~），同时这两个点一定要有路径，那么我们可以用并查集维护当前的图，如果当前图中存在至少两个祖先，那么当前图一定不合法。


还有一点
#### 注意输出！！！
###  注意输出！！！
##   注意输出！！！ 重要的事情说三遍！


~~下面是巨丑的代码~~
```
#include<cstdio>
#include<cstring>

int f[210000]; //f数组记录当前点出现的次数（方便记录tot）
int fa[210000]; //记录每个点的父亲
int sum[210000]; //记录当前有几个祖先

struct nod1{int x,y;} a[210000]; //记录边

int maxx(int x,int y) { return x>y?x:y; }

int find(int x) { return fa[x]==x?fa[x]:fa[x]=find(fa[x]); }

void go(int x1,int y1)
{
	if(x1==0 && y1==0)
	{
		printf("0\n"); return ;
	}
	
	memset(f,0,sizeof(f)); 
	memset(fa,0,sizeof(fa)); 
	memset(sum,0,sizeof(sum)); 
	
	int s=0,bnum=0,tot=0; //tot记录点数，s记录边数
	
	a[++s].x=x1; a[s].y=y1;
	f[x1]++; if(f[x1]==1) tot++;
	f[y1]++; if(f[y1]==1) tot++;
	bnum=maxx(a[s].x,a[s].y); //找最大编号的点，方便维护并查集
	
	int x,y; scanf("%d %d",&x,&y);
	while(x!=0 && y!=0) //输入，记录点数与边数
	{
		a[++s].x=x; a[s].y=y;
		f[x]++; if(f[x]==1) tot++;
		f[y]++; if(f[y]==1) tot++;
		bnum=maxx( bnum , maxx(x,y) );
		scanf("%d %d",&x,&y);
	}
	
	for(int i=1;i<=bnum;i++)
	{
		if(f[i]) fa[i]=i;
	}
	
	for(int i=1;i<=s;i++) //如果当前两个点联通，更改父亲
	{
		int fx=find(a[i].x),fy=find(a[i].y);
		if(fx!=fy) fa[fx]=fy;
	}
	int tot2=0;
	for(int i=1;i<=bnum;i++)
	{
		if(!fa[i]) continue;
		
		int fx=fa[find(i)];
		if(sum[fx]==0) sum[fx]=++tot2;
		if(tot2>=2) //如果当前有两个以上的祖先，不合法
		{
			printf("0\n");
			return ;
		}
	}
	
	if(s!=tot-1) //如果当前存在环（即不是一棵树），不合法
	{
		printf("0\n");
		return ;
	}
	
	printf("1\n");
	return ;
}

int main() //主函数不解释
{
	int x,y; scanf("%d %d",&x,&y);
	while(x!=-1 && y!=-1)
	{
		go(x,y);
		scanf("%d %d",&x,&y);
	}
	return 0;
}
```

---

## 作者：molasses (赞：0)

这道题用了三种方法来做，主要围绕连通性展开.

**法1** 边集与树边集，[50%AC+50%TLE](https://www.luogu.org/record/22620635). 

TLE 原因可能是反复建图遍历复杂度常数影响了性能，正确性可以保证：维护两个边集：原图边集 $E$，DFS 的树边集 $E'$，显然有 $E'\subseteq E$. 当 $E=E'$ 时，原图符合条件；反之，不符合. 实际上，本题中只需满足 $card(E)=card(E')$ 即可. 缺点是过分强调树结构. 代码中有两个调试用的函数，比较潦草.

**法2** 树的性质，[80%AC+20%WA](https://www.luogu.org/record/22676598).
.

（未证明）在一个无向图中，给定 $n$ 个节点，任意画出 $n-1$ 条边，当视自边为空边时，生成图是一棵树.


**法3** 并查集维护连通性，[100%AC](https://www.luogu.org/record/22658136).

并查集维护连通性，在 [并查集模板](https://www.luogu.org/blog/molasses/sol-p3367) 的基础上，增加 add(v) 用于新增节点，每成功新增一个节点，集合数量就 +1；修改 merge(u, v)，合并时若边 $(u,v)$ 属于一个集合，则该图不符合条件，成功合并则集合数量 -1. 最后，若集合数量为1，则图符合条件.


```cpp
#include <bits/stdc++.h>
using namespace std;

const size_t maxid = 100001;

struct UnionFindSet {
  vector<int> pa, rank;
  vector<bool> node;

  UnionFindSet() {
    pa = vector<int>(maxid, 0);
    rank = vector<int>(maxid, 0);
    node = vector<bool>(maxid, false);
  }

  bool add(int v) {
    if (node[v]) return false;
    pa[v] = v;
    return node[v] = true;
  }

  int get(int v) {
    int p = v;
    while (pa[p] != p) p = pa[p];
    while (v != p) {
      int t = pa[v];
      pa[v] = p;
      v = t;
    }
    return v;
  }

  bool merge(int x, int y) {
    int xx = get(x), yy = get(y);
    if (xx == yy) return false;
    if (rank[xx] > rank[yy]) {
      pa[yy] = xx;
    } else {
      pa[xx] = yy;
      if (rank[xx] == rank[yy]) ++rank[yy];
    }
    return true;
  }
};

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  bool done = false;
  int u, v, cnt = 0;
  UnionFindSet* x = new UnionFindSet();
  while (cin >> u >> v && u != -1 && v != -1) {
    if (u && v && !done) {
      if (x->add(u)) ++cnt;
      if (x->add(v)) ++cnt;
      if (x->merge(u, v)) {
        --cnt;
      } else {
        done = true;
        cout << "0\n";
      }
    }
    if (u == 0 && v == 0) {
      if (!done) cout << (cnt == 1) << '\n';
      cnt = 0;
      done = false;
      x = new UnionFindSet();
    }
  }
  delete x;
  return 0;
}
```


---

## 作者：奶油青豆烧鱼 (赞：0)

根据题意，我们需要判断所给的边集是否可以构成一棵树。

使用并查集判环。对于每边所连接的一组节点，检查是否在同一集合内，如果成立则说明有环。如果不成立就将两点所在集合合并。

最后检查一下是否联通就好啦。

需要注意的是，节点的编号不保证连续，所以用一个vis数组来记录有哪些节点出现过。
```
#include<bits/stdc++.h>
using namespace std;
int fa[100001],vis[100001],u,v;
bool flag;
inline void Init(){
	for(int i=1;i<=100001;i++)
		fa[i]=i;
	memset(vis,0,sizeof(vis));	
	flag=0;
}
inline int Get(int x){return (fa[x]==x)?x:fa[x]=Get(fa[x]);}
inline void Merge(int x,int y){fa[Get(x)]=Get(y);}
inline bool Check(){
	int tmp=-1;
	if(flag==1)
		return false;
	else{
		for(int i=1;i<=100001;i++){
			if(tmp==-1&&vis[i]){
				tmp=Get(i);
			}
			else
				if(vis[i]&&Get(i)!=tmp)
					return false;
		}
	}
	return true;
}
int main(){
	Init();
	while(cin>>u>>v){
		if(u==0){
			if(Check())
				cout<<1;
			else
				cout<<0;
			Init();
			cout<<endl;
			continue;
		}
		if(u==-1)
			return 0;
		
		if(Get(u)!=Get(v)){
			vis[u]=vis[v]=1;
			Merge(u,v);
		}
		else
			flag=1;
	}
	return 0;
}
```

---

## 作者：Mashiro_ylb (赞：0)

#并查集

虽然楼上已经有了并查集，但是这篇并查集思路与楼上略有不同，思想有点像kruskal（也许吧）。

###思路

由于是无向连通图，所以可以用并查集解决。

这道题主要抓住两个要点:

1.任意两个房间***有且仅有一条***路径可以相通.

2.任意两个房间有且仅有一条路径***可以相通***.

###解决方法：**(๑•̀ㅂ•́)و✧**

1.输入A,B两个联通点时利用并查集操作把他们并入一个集合中，若在并入前A,B两点已经在同一集合，则表示这两个点已经被其他点联通，不符合题意。

2.读到 0  0 准备退出本次操作时，检查每一个点所在的集合，若存在有两个点存在于不同的集合中，表示这一张图并没有联通，不符合题意。

详情请见代码。

###代码如下


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
#include<cmath>
#define by Mashiro_ylb
#define TIME 2017/10/28
using namespace std;
const int maxn_data = 100007;

int father[maxn_data];  //并查集代表数组
int rank[maxn_data]; //统计集合元素数（用于并查集启发式合并）

template<class T>void read(T &x) //读入优化
{
    int f = 0; x = 0; char ch = getchar();
    while(ch < '0' || ch > '9') f |= (ch == '-'), ch = getchar();
    while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    x = f? -x : x;
}
template<class T>void write(T x)  //输出优化
{
    if(x < 0) x = -x, putchar('-');
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
template<class T>T Max(T x, T y){return x > y? x : y;}
template<class T>T Min(T x, T y){return x < y? x : y;}
int find(int x)  //并查集：查询代表元素+路径压缩
{
    int k = x, j;
    while(x != father[x]) x = father[x];
    while(k != x) j = father[k], father[k] = x, k = j;
    return x;
}
void unionn(int x, int y)  //并查集：启发式合并（小集合并入大集合）
{
    x = find(x);
    y = find(y);
    if(rank[x] > rank[y]) father[y] = x, rank[x] += rank[y], rank[y] = 0;
    else father[x] = y, rank[y] += rank[x], rank[x] = 0;
}
bool check(int x, int y){return find(x) == find(y);}  //并查集：查询两元素是否属于同一集合

int init();

int main()
{
//     freopen("in.txt","r",stdin);
    while("Mashiro_ylb") write(init()), putchar(10);  //操作
    return 0;
}

int init()
{
    int maxx = 0, minn = 0x7fffffff;
    int flag = 1;
    int x, y;
    memset(rank, 0, sizeof(rank));  //并查集初始化
    memset(father, 0, sizeof(father));
    read(x);read(y);
    while(x > 0 && y > 0)
      {
          if(!father[x]) father[x] = x;  //并查集初始化
          if(!father[y]) father[y] = y;
          if(check(x, y)) flag = 0;  //存在多条路径，不合题意
          else unionn(x, y);
          maxx = Max(x, Max(y, maxx));  //查找输入点的最大值与最小值（减小下一步判断图联通的复杂度）
          minn = Min(x, Min(y, minn));
          read(x);read(y);
      }
    if(x == -1 && y == -1) exit(0);  //依题意结束程序
    for(int i = minn + 1; i <= maxx; i++)  //判断图是否能联通
      if(find(i) != 0 && find(i) != find(minn))
        return 0;
    return flag;
}
```

---

## 作者：fl_334 (赞：0)

并查集


```cpp
int main(){
    for (int i=1;i<=10010;i++)
        fa[i]=i;
    while (1){
        int sum=0;
        int maxn=0;
        int x,y;
        cin>>x>>y;
        if (x==-1&&y==-1) break;
        maxn=max(maxn,x);
        maxn=max(maxn,y);
        memset(book,0,sizeof(book));              //初始
        init(10010);
        book[x]=1;
        book[y]=1;
        while (1){
            if (x==0&&y==0) break;
            int t1=find(x);
            int t2=find(y);
            if (t1==t2){
                 sum=1;
            }
            if (t1!=t2) fa[t1]=t2;
            scanf("%d %d",&x,&y);
            maxn=max(maxn,x);
            maxn=max(maxn,y);
            book[x]=1;
            book[y]=1;                                              
        }                                                   
        if (sum==1) cout<<"0"<<endl;                   //多条路径直接输0
        else{
            sum=0;
        for (int i=1;i<=maxn;i++)
            if (book[i]==1&&fa[i]==i) sum++;
            if (sum==1) cout<<"1"<<endl;
            else cout<<"0"<<endl                 //小心，此处要全部联通方可;
    }
}
}
//核代
```

---

## 作者：xh2010 (赞：0)

这道题本质是判断输入的图是否是一颗树，我们只要抓住树的特征就行了：

1、    这是一个连通图；

2、    图中边数=节点数-1；

判断连通图，我们可以用并查集解决。






```cpp
program p2307;
var f:array[1..100000] of boolean;
father:array[1..100000] of longint;
function get(x:longint):longint;   //并查集
begin
  if x=father[x] then exit(x);
  father[x]:=get(father[x]);
  exit(father[x]);
end;
procedure main;
var x,y,tot,sum,i:longint;
    bool:boolean;
begin
  read(x,y);
  while (x<>-1) and (y<>-1) do
  begin
    fillchar(f,sizeof(f),false);
    for i:=1 to 100000 do
      father[i]:=i;
    tot:=0;
    sum:=0;
    bool:=true;
    while (x<>0) and (y<>0) do
    begin
      if not f[x] then inc(sum);
      if not f[y] then inc(sum);
      if get(x)<>get(y) then father[get(x)]:=get(y) else bool:=false;
      f[x]:=true;
      f[y]:=true;
      inc(tot);
      read(x,y);
    end;
    if (sum=tot+1) and bool then writeln(1) else writeln(0);
    read(x,y);
  end;
end;
begin
  main;
end.

```

---


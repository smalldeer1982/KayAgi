# 金字塔

## 题目描述

有一盗墓者潜入一金字塔盗宝。当她（难道是 Lara Croft ?）打开一个宝箱的时候，突然冒出一阵烟（潘多拉的盒子？），她迅速意识到形势不妙，三十六计走为上计……由于她盗得了金字塔的地图，所以她希望能找出最佳逃跑路线。地图上标有 $N$ 个室，她现在就在 $1$ 室，金字塔的出口在 $N$ 室。她知道一个秘密：那阵烟会让她在直接连接某两个室之间的通道内的行走速度减半。她希望找出一条逃跑路线，使得在最坏的情况下所用的时间最少。

## 说明/提示

样例解释 Sample Explan：

基本上有三种路线：

（1）$1 \to 2 \to 3 \to 4 \to 7$。

总时间为：$10$ ＋ $12$ ＋ $20$ ＋ $8$ ＝ $50$，最坏的情况是“ $3 \to 4$ ”那一段，要多花 $20$ 秒（因为行走速度减半），所以这条路选最坏需要 $70$ 秒；

（2）$1 \to 2 \to 5 \to 6 \to 4 \to 7$。

总时间为：$10$ ＋ $10$ ＋ $12$ ＋ $13$ ＋ $8$ ＝ $53$，最坏的情况是“ $6 \to 4$ ”那一段，要多花 $13$ 秒，所以这条路选最坏需要 $66$ 秒；

（3）$1 \to 7$。

总时间为：$34$ ＝ $34$，最坏的情况是“ $1 \to 7$ ”那一段，要多花 $34$ 秒，所以这条路选最坏需要 $68$ 秒。

## 样例 #1

### 输入

```
7 8
1 2 10
2 3 12
3 4 20
4 7 8
1 7 34
2 5 10
5 6 12
6 4 13```

### 输出

```
66```

# 题解

## 作者：Sata_moto (赞：12)


[$ \large{}\color {#6495ED} \mathcal{MyBlog} $](https://xjx885.coding-pages.com/)

---

$
$

### 前言：


$\quad \quad$ 闲着无聊跳题跳过来的...

$\quad \quad$ 然后发现这是道好题。

$\quad \quad$ 似乎这题没人用 Floyd 做？

$\quad \quad$ 这是一篇魔改 Floyd 的题解。

---

$
$

### 题目大意：

$\quad \quad$ 给定一张 $n$ 个点，$m$ 条边的无向图，求从 $1$ 到 $n$ 的，路径上最大权值翻倍的最短路。

$\quad \quad$ 数据范围： $n\le 100,m\le 2000,w$(边权)$\le255$。

---


$
$
### 思路分析:

$\quad \quad$ 拿到这题，本蒟蒻第一反应就是 Floyd：跑出任意两点间最短路，然后枚举每一条边 $(x,y)$，求出通过这一条边，并将这一条边翻倍后的最短路($1\to x \to y \to n$)，取最小值。

$\quad \quad$ 路径($1\to x \to y \to n$) 怎么求？显然， $1\to x$ 走的是最短路， $x\to y$ 走的是翻倍边， $y\to n$ 走的还是最短路。（真的显然吗？） 

$\quad \quad$ 然后发现样例都过不了 T_T，看了看题，发现翻倍的边必须是路径上最长边。

$\quad \quad$ 然后很容易想到另一个看似靠谱一点的方法： 先 Floyd 求任意两点间最短路，然后再 Floyd 求任意两点间路径边权最大值，最后枚举每一条边，如果这条边是路径上最大的边，就求出通过这一条边，并将这一条边翻倍后的最短路，取最小值。

$\quad \quad$ 代码大概是这样的：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;
const int M = 2010;

int n, m;
int f[N][N], g[N][N];
//f 表示任意两点间最短路
//g 表示任意两点间路径上的最大权值

inline int read()
{
	int x = 0, ch = '~';

	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = (x << 3) + (x << 1), x += ch - '0', ch = getchar();

	return x;
}

int u[M], v[M], w[M];

int main()
{
	//初始化
	n = read(), m = read();
	memset(f, 0x3f, sizeof(f));
	for(register int k = 1; k <= m; k++)
	{
		u[k] = read(), v[k] = read(), w[k] = read();
		f[u[k]][v[k]] = f[v[k]][u[k]] = g[v[k]][u[k]] = g[u[k]][v[k]] = w[k];
	}
	for(register int k = 1; k <= n; k++)
		f[k][k] = 0;

	//Floyd求最短路
	for(register int k = 1; k <= n; k++)
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				if(k != i && i != j && k != j)
					f[i][j] = min(f[i][j], f[i][k] + f[k][j]);

	//Floyd求最大值
	for(register int k = 1; k <= n; k++)
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				if(k != i && i != j && k != j)
					g[i][j] = max(g[i][k], g[k][j]);

	int answ = 0x3f3f3f3f;
	for(register int k = 1; k <= m; k++)
	{
		//如果从起点到该边一端路径上的最大值，以及从终点到该边另一端的最大值都没有这条边边权大，就统计答案
		if(g[1][u[k]] <= w[k] && g[v[k]][n] <= w[k]) answ = min(answ, f[1][u[k]] + f[v[k]][n] + w[k] * 2);
		if(g[1][v[k]] <= w[k] && g[u[k]][n] <= w[k]) answ = min(answ, f[1][v[k]] + f[u[k]][n] + w[k] * 2);
	}

	printf("%d", answ);

	return 0;
}
```
$\quad \quad$ 然后发现仍然过不了样例。

$\quad \quad$ 问题很显然：最短路径与最大权值不配套。

$\quad \quad$ 我们求出的 “两点间最大边权” 是没用的，应该求的是 “从最短路径走，两点间最大边权” 才对。

$\quad \quad$ 于是我们可以做一个小小的修改：

$\quad \quad$ 把原本的 $Floyd$ 求最大值，改为：

```cpp
//Floyd求最大值 (第二版)
for(register int k = 1; k <= n; k++)
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			if(k != i && i != j && k != j)
				if(f[i][j] == f[i][k] + f[j][k])
				//保证这条路径是最短路
					g[i][j] = max(g[i][k], g[k][j]);
```

$\quad \quad$ 好，现在我们可以过样例了，提交试试。

$\quad \quad$ 于是悲剧 80 分。

$\quad \quad$ 这里给出一组错误数据（只能 Hack Floyd 算法）：
		
      
	input:
        
	5 6 
	1 2 6
	2 3 10
	1 3 15
	3 5 15
	3 4 10
	4 5 6
    
	output:
    
	42
    
    
   ![](https://cdn.luogu.com.cn/upload/image_hosting/73uxbkoq.png)
   
    
$\quad \quad$ 我们的算法输出是 45。

$\quad \quad$ 为什么会出现这种情况？

$\quad \quad$ 注意观察我们的最优解： $1\to2\to3\to4\to5$。

$\quad \quad$ 在上面的算法中，我们认为答案只有可能是 $1\to ... \to x\to y\to ... \to n$ 的形式，其中  $1\to ... \to x\ \ ,\ \ y\to ... \to n$ 走的都是最短路， $x \to y$ 走的是一条被翻倍过的最长边。

$\quad \quad$ 但在上面的图中，我们在两边并没有走最短路（$1\to3 \ \ \ ,\ \ \ 3\to 5$ ），因为走了最短路的话，最长边就会变成 15。

$\quad \quad$ 因此，我们注意到：如果使用状态与最长边无关，只与最短路有关的 Floyd 算法的话，我们很难得出正确结果，因为结果并不一定是由很多最短路拼接而成的。

$\quad \quad$ 虽然可能有更巧妙的 Floyd 解决方法，但我这里使用一种相对暴力的方案：用一个更复杂的状态进行转移（其实我有一个绝妙的想法，可是地方太小，写不下 /xyx）。

$\quad \quad$ 众所周知，Floyd 本质上是个 DP，我们不妨给它增加一维，令 $f(i,j,k)$ 表示从 $i$ 到 $j$ ，路径上最长边长度小于等于 $k$ 的最短路的长度。

$\quad \quad$ 似乎是很复杂的一个状态呢...为什么不直接设最长边等于多少？因为这样更好转移。

$\quad \quad$ 这里直接给出转移：

```cpp
	for(register int k = 1; k <= n; k++)
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				if(k != i && i != j && k != j)
					for(int c = 0; c <= 260; c++)
					{
						if(c != 0) f[i][j][c] = min(f[i][j][c], f[i][j][c - 1]);
						f[i][j][c] = min(f[i][j][c], f[i][k][c] + f[k][j][c]);
					}

```

$\quad \quad$ 我们可以看到，前四排都是普通 Floyd 的玩意，只是最后加了一个循环（因为 Floyd 里面有一个变量 k ，所以第三维用的是 c 表示）。

$\quad \quad$ 第一个转移是：`f[i][j][c] = min(f[i][j][c], f[i][j][c - 1])` 含义显然，毕竟我们第三维设的是 “路径上最长边长度小于等于 $k$”。

$\quad \quad$ 第二个转移是：`f[i][j][c] = min(f[i][j][c], f[i][k][c] + f[k][j][c])` 这是类似一般 Floyd 的转移过程，因为状态设置的缘故，这里的第三维可以全部用同一个字母进行转移。

$\quad \quad$ 为什么上面两个转移是正确的？

$\quad \quad$ 第一个转移正确性显然，第二个转移与 Floyd 等价。

$\quad \quad$ 初始化和统计答案注意一下细节就好，算法复杂度是 $O(n^3w)$，有点大，要吸氧才能过（其实有很多冗余状态来着，去掉冗余状态再加优化，复杂度可以降下来的，这里就懒得写了）。

$\quad \quad$ 最终统计答案的方式貌似与方面一样，但是实际上完全不同，因为我们其实是把所有可能的道路都算出来了的。

---

$
$

### 最终代码：


```cpp
// 要开 O2 的来着

#include <bits/stdc++.h>

using namespace std;

const int N = 110;
const int M = 2010;

int n, m, f[N][N][300];

inline int read()
{
	int x = 0, ch = '~';

	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = (x << 3) + (x << 1), x += ch - '0', ch = getchar();

	return x;
}

int u[M], v[M], w[M];

int main()
{
	n = read(), m = read();
	memset(f, 0x3f, sizeof(f));
	for(register int k = 1; k <= m; k++)
	{
		u[k] = read(), v[k] = read(), w[k] = read();

		for(int i = w[k]; i <= 260; i++)
			f[u[k]][v[k]][i] = f[v[k]][u[k]][i] = w[k];
	}
	for(register int k = 1; k <= n; k++)
		for(register int i = 0; i <= 260; i++)
			f[k][k][i] = 0;

	for(register int k = 1; k <= n; k++)
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				if(k != i && i != j && k != j)
					for(int c = 0; c <= 260; c++)
					{
						if(c != 0) f[i][j][c] = min(f[i][j][c], f[i][j][c - 1]);
						f[i][j][c] = min(f[i][j][c], f[i][k][c] + f[k][j][c]);
					}

	int answ = 0x3f3f3f3f;

	for(register int k = 1; k <= m; k++)
	{
		answ = min(answ, f[1][u[k]][w[k]] + f[v[k]][n][w[k]] + w[k] * 2);
		answ = min(answ, f[1][v[k]][w[k]] + f[u[k]][n][w[k]] + w[k] * 2);
	}

	printf("%d", answ);

	return 0;
}
```


---

$
$

### 结语：

$\quad \quad$ 我真的有一个绝妙的想法来着，只不过写着写着就忘了 /kk。

$\quad \quad$ 如果本题解有BUG，还请评论或私信作者。

---

$$ \large{END}$$

---

## 作者：大头冲锋车丶 (赞：11)

我们用 $dijkstra$ 来写。
  
  与平常 $dijkstra$ 不同的是，此题还需要维护该条路上最大权值，故我们可以用一个$pre[i]$ 数组维护最优解这条路上的最大权值。
  
  $dist[i]$ 存储的是根本意义上的最短路 **（就是指再加上最长路的值，起点到 $i$ 点最短的权值，即题目所求。但是注意，这里的 $dist[]$ 存储的值是尚未再加上最长路的总值。）**   
  
因为有些路它不加两倍权值的话会导致比正确答案更短，这样记录就错了。
其次，像上面所说的，我们在放缩的时候，不应该用 $dist[]$ 直接存储我们需要的答案，即先不再加上最大权值。
  
所以我们最短路跑的应该是:
  
  1、在真正意义上的最短路值却先没有再加上这条路最长权值的 $dist[i]$ 。
  
  2、$pre[i]$ 始终保存的是，每次放缩后的真正意义的最短路上，最长路权值。

故我们最后输出 $dist[n] + pre[n]$ 即可。

**此外注意的是：我们不需要用 $vis[]$ 标记已走过或已经处理最短路答案，然后不再更新。** 这将会导致答案出错，因为可能从已经处理过的 $u$ 点 走到已经处理过的 $v$ 点，且更新到 $v$ 点的最短路。

比如样例中：根据优先队列顺序，到最后，会先更新节点 ⑦ ，再更新节点 ④，而如果标记 $vis[7]=true$ 的话，那么会导致 ④ --> ⑦ 这条路不再贡献于 $dist[7]$ ，导致答案出错。

**代码如下：**
```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
#include<queue>
#define maxn 108
#define inf 0x3f3f3f3f
using namespace std;
typedef long long ll;
int n,m,cnt;
int head[maxn];
ll pre[maxn],dist[maxn];
bool vis[maxn];
struct Node
{
    int to;
    ll val;
    Node (){};
    Node(ll _val,int _to){
        to=_to,val=_val;
    }
    bool operator < (const Node &a) const{
        return val>a.val;
    }
};
struct Edge
{
    int to;
    ll val;
    int next;
}edge[2008<<1];
inline void add(int u,int v,ll w)
{
    edge[++cnt].to=v;
    edge[cnt].val=w;
    edge[cnt].next=head[u];
    head[u]=cnt;
    return;
}
void dijkstra(int u)
{
    priority_queue<Node> q;
    while(!q.empty()) q.pop();
    for(int i=1;i<=n;i++) {dist[i]=inf,vis[i]=false;pre[i]=0;}
    dist[u]=0;
    q.push(Node(0,1));
    while(!q.empty())
    {
        int u=q.top().to;
        ll t=dist[u];
        q.pop();
        for(int i=head[u];i;i=edge[i].next){
            int v=edge[i].to;
            if((dist[v]+pre[v]>t+edge[i].val+max(edge[i].val,pre[u]))){
                pre[v]=max(pre[u],edge[i].val);
                dist[v]=edge[i].val+t;
                q.push(Node(dist[v],v));
            }
        }
    }
    return;
}
int main()
{
    //freopen("test.in","r",stdin);
    scanf("%d%d",&n,&m);
    int A,B;
    ll C;
    for(int i=1;i<=m;i++){
        scanf("%d%d%lld",&A,&B,&C);
        add(A,B,C);add(B,A,C);
    }
    dijkstra(1);
    printf("%lld\n",dist[n]+pre[n] );
}
```


---

## 作者：Night_Aurora (赞：10)

简化一下题目就是两个点之间一条路的总权值加上路上最大权值的和最小

在看到权值范围很小（3-255）

于是我们可以枚举最大权值然后每次求最短路

答案就是每次最短路+枚举权值的最小值

由于时间没有负，可以用队列优化的dijkstra


```cpp
#include <stdio.h>
#include <string.h>
#include <queue>
int EHead[110],ENext[4100],ETo[4100],ECost[4100];
int Elt;
int Vist[110],Dist[110];
void AddEdge(int f,int t,int c)
{
    ++Elt;
    ENext[Elt]=EHead[f];
    ETo[Elt]=t;
    ECost[Elt]=c;
    EHead[f]=Elt;
}
void AddPair(int f,int t,int c)
{
    AddEdge(f,t,c);
    AddEdge(t,f,c);
}
typedef struct Nd
{
    int dis,p;
    bool operator <(const Nd&i)const
    {return dis>i.dis;}
}ND;
int N,M;
void Dijkstra(int mn)
{
    memset(Vist,0,sizeof(Vist));
    ND nd,bf;
    std::priority_queue<ND> Pq;
    nd.dis=0;
    nd.p=1;
    Pq.push(nd);
    int wp,wl,ww,nc=0;
    while(!Pq.empty())
    {
        nd=Pq.top();Pq.pop();
        wp=nd.p;
        if(Vist[wp])continue;
        wl=nd.dis;
        Dist[wp]=wl;
        Vist[wp]=1;
        ++nc;
        if(nc==N)break;
        for(ww=EHead[wp];ww;ww=ENext[ww])
            if(!Vist[ETo[ww]])
                if(ECost[ww]<=mn)
                {
                    bf.p=ETo[ww];
                    bf.dis=wl+ECost[ww];
                    Pq.push(bf);
                }
    }
}
int Mw;
int ReadInt()
{
    char c=getchar();
    int r=0;
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        r=r*10+c-'0';
        c=getchar();
    }
    return r;
}
void Input()
{
    scanf("%d %d",&N,&M);
    int wi,a,b,c;
    for(wi=1;wi<=M;++wi)
    {
        a=ReadInt();
        b=ReadInt();
        c=ReadInt();
        if(c>Mw)Mw=c;
        AddPair(a,b,c);
    }
}
int MC=0x3FFFFFFF;
void AC()
{
    int wi;
    int wc;
    for(wi=1;wi<=Mw;++wi)
    {
        Dijkstra(wi);
        if(!Vist[N])continue;
        wc=Dist[N]+wi;
        if(wc<MC)MC=wc;
    }
    printf("%d\n",MC);
}
int main()
{
    Input();
    AC();
    return 0;
}

```

---

## 作者：Nwayy (赞：4)

水一下图论......

# solution

- 一眼看下去感觉不是很典的最短路，而又注意到 $n \le 100$，于是果断掏出我的 dfs。

- 定义三个维度，$a$、$M$、$s$，分别表示当前递归到第 $a$ 个点，$1$ 号节点到当前节点中搜到的边权的最大值，$1$ 号节点到当前节点搜到的路径和。

- 一般用 dfs 跑最短路都要有个递归边界，否则会像无头苍蝇一样乱跑，导致死循环，我们定义 $f_{i,j}$ 表示到 $i$ 号点时，$1$ 号点到 $i$ 号点之间路径最大值为 $j$ 的最小路径和。同时用 $f$ 数组进行最优性剪枝，保证了时间复杂度。

- 同机房大佬给出了一个小优化：为了防止递归方向错误，也就是重复遍历同一条边，我们开一个 $v$ 数组记录某条边是否曾经遍历过，如果遍历过再次遍历就没有意义，直接返回上一层。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2005
int n,m,i,j,ans=1e9;
int h[105],a,b,c,k;
int f[105][260],v[N*30];
struct AB{
	int a,b,c,n;
}d[N*2];
void cun(int a,int b,int c){
	d[++k].a=a,d[k].b=b,d[k].c=c;
	d[k].n=h[a],h[a]=k;
}
void dfs(int a,int M,int s){
	if(s+M>=ans) return;
	if(f[a][M]<=s) return;
	f[a][M]=s;
	if(a==n){
		ans=min(ans,s+M);
		return;
	}
	for(int i=h[a];i;i=d[i].n){
		int b=d[i].b,c=d[i].c;
		if(v[i]==1) continue;
		v[i]=1;
		dfs(b,max(M,c),s+c);
		v[i]=0;
	}
}
int main(){
	memset(f,1,sizeof(f));
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++){
		scanf("%d%d%d",&a,&b,&c);
		cun(a,b,c);
		cun(b,a,c);
	}
	dfs(1,0,0);
	printf("%d",ans);
	return 0;
}
```
- 感觉 dfs 很容易被 hack 掉......

---

## 作者：AlicX (赞：3)

### 前言
这是一道最短路的题，虽然不难（可以用一些比较直接的暴力方法）求解，但它仍是最短路这个板块中的一股清流，因为它可以让我们了解一种思路：限制。

## 思路
题意大概就是给你一个 $n$ 个点，$m$ 条边的双向图，求一条从前点到终点的最短路并将这条路的最大值取出来，单独加上，求加上后的路的最小值。

或许很多人的思路都是在跑最短路的图中求最大值最后加上，但是还有一种跟简单的思路：限制。枚举每一条最短路，假设这条最短路就是这次最短路的最长的路径，以此为限制，所以我们这次最短路用到的边均不会大于它。跑 $m$ 次迪杰斯特拉，每次更新是都要判断一下，最后在判断是否联通就可以了。


## AC code
```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=110,M=2010;
int n,m;
int w[M];
int dis[N];
bool st[N];
int ans=1e9+7;
int h[N],idx=0;
struct Node{
	int w;
	int to,ne;
}tr[M<<1];
void add(int u,int v,int w){
	tr[idx].w=w,tr[idx].to=v,tr[idx].ne=h[u],h[u]=idx++;
}
void dij(int p){
	priority_queue<pii> q;
	memset(st,false,sizeof st);
	memset(dis,0x3f,sizeof dis);
	int inf=dis[0];
	dis[1]=0,q.push({0,1});
	while(!q.empty()){
		int t=q.top().y;
		q.pop();
		if(st[t]) continue;
		st[t]=true;
		for(int i=h[t];i!=-1;i=tr[i].ne){
			int to=tr[i].to;
			if(dis[to]>dis[t]+tr[i].w&&tr[i].w<=p){
				dis[to]=dis[t]+tr[i].w;
				q.push({-dis[to],to});
			}
		}
	}
	if(dis[n]!=inf) ans=min(ans,dis[n]+p);
}
signed main(){
	memset(h,-1,sizeof h);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v>>w[i];
		add(u,v,w[i]),add(v,u,w[i]);
	}
	for(int i=1;i<=m;i++) dij(w[i]);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：mzyc_yang2021 (赞：0)

题意及分析：
1. 看题，可以知道地图是一张图，并且无向，所以建双向边。
2. 用最短路来求解。由于题解里没有 SPFA，所以我使用的是 SPFA。看数据范围  SPFA 不会死。
3. 关于这句话：“那阵烟会让她在直接连接某两个室之间的通道内的行走速度减半”，意思是这人走的最短路上最长边是倍长了的（速度减半，相当于长度乘二），也就是，我们所找的路径上的最长边的长度是原来的两倍。其实不难处理，只要带着截至目前的最短路上的最长边一起更新即可（注意最短路和最长边分开），最长边用数组存储即可。
4. 不难得出，答案即最短路加上最短路上的最长边。

剩下不明白的代码里有注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100010
struct edge
{
	int v,w,next;
}ed[2*N];
int n,cnt,m,w[N],dis[N],maxn[N],head[2*N]; // maxn 即目前最短路上的最长边
void add(int u,int v,int w)
{
	ed[++cnt].v=v;
	ed[cnt].w=w;
	ed[cnt].next=head[u];
	head[u]=cnt;
}
queue<int> q;
void spfa() // spfa 求最短路
{
	memset(dis,63,sizeof(dis)); // dis 初始赋极大值（实际赋出来不是63，可以自己试一下）
	q.push(1); // 起点是 1
	dis[1]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i!=0;i=ed[i].next)
		{
			int v=ed[i].v,w=ed[i].w;
			if(dis[v]+maxn[v]>dis[u]+max(w,maxn[u])+w) // 带着最长边一起更新最短路，但注意最长边可能是当前这条所以两者取max即可
			{
				dis[v]=dis[u]+w; // 更新最短路
				maxn[v]=max(maxn[u],w); // 更新最长边
				q.push(v);
			}
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1,u,v,w;i<=m;i++)
	{
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,w); // 双向边
	}
	spfa();
	cout<<maxn[n]+dis[n]; // 答案即最短路加上其最长边
	return 0;
}
```

---

## 作者：lakafl (赞：0)

思路：题目的意思是，找一个**最短路**，并且使**最大的权值+最短路**最小，首先可以套一个==dijkstra==模板，再单独一个数组来存最大值，**因为存一起，不方便找出最大值来比较**最后把两个数值加起来，得出答案，另外转移**dis**时一定要加上当前的权值，不要忘了
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#define int long long
using namespace std;

bool vis[4005];
int dis[4005], e[4005];
int head[4005], next[4005], to[4005], w[4005], cnt;

struct node {
	int now, s, maxn;
	node() {}
	node(int Now, int S, int Maxn) {
		now = Now; s = S; maxn = Maxn;
	}
};

int Max(int x, int y) { return x > y ? x : y; }
int Min(int x, int y) { return x < y ? x : y; }

void add(int x, int y, int s) {
	to[++ cnt] = y;
	w[cnt] = s;
	next[cnt] = head[x];
	head[x] = cnt;
} 

queue<node> q;

bool operator <(node x, node y) {
	return x.s > y.s;
}

void dijkstra(int begin) {
	dis[begin] = 0;
	q.push(node(begin, 0, 0));
	while(!q.empty()) {
		int now = q.front().now, s = q.front().s, maxn = q.front().maxn;
		q.pop(); vis[now] = 0;
		for(int i = head[now]; i; i = next[i]) {
			int t = to[i], ma = Max(maxn, w[i]);
			if(dis[t] + e[t] > dis[now] + w[i] + ma) {
				dis[t] = dis[now] + w[i]; e[t] = ma;
				q.push(node(t, s + w[i], ma));
			} 
		} 
	}
} 

signed main() {
	int n, m, u, v, w;
	scanf("%lld %lld", &n, &m);
	memset(dis, 0x3f, sizeof(dis));
	for(int i = 1; i <= m; i ++) {
		scanf("%lld %lld %lld", &u, &v, &w);
		add(u, v, w); add(v, u, w);
	} dijkstra(1);
//	for(int i = 1; i <= n; i ++) {
//		printf("%d\n", dis[i]);
//	}
	printf("%lld", dis[n] + e[n]);
} 
```

---


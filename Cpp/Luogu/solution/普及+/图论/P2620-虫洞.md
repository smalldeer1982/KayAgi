# 虫洞

## 题目背景

applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为 applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。


## 题目描述

为了简化问题，我们建立一个一维坐标系，地球的位置为 $0$，而applepi 的目的地的位置是一个正整数 $W$。

在每一个单位时间里，applepi 可以向正方向移动不超过 $S$ 的一个整数。虫洞可以被表示为二元组 $(B, E)$，即如果在某次移动之后 applepi 在位置 $B$，那么 applepi 就会被立刻传送到位置 $E$。

注意，applepi 在移动过程中如果经过位置 $B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。

现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。


## 说明/提示

对于 $30\%$ 的数据，$W≤1000$。

对于 $100\%$ 的数据，$W≤10^9$，$2≤S≤6$，$1≤P≤40$，没有 $B = 0$ 或者 $B = W$ 的虫洞，输入数据保证目的地可达。


## 样例 #1

### 输入

```
28 3 5
2 18
5 13
12 6
17 25
20 15
50 6 1
9 45
0
```

### 输出

```
４
３
```

# 题解

## 作者：cmd2001 (赞：14)

看起来这题我是第一个AC的。好吧，这题题意确实比较坑。

首先说一下题目背景：这本来是石家庄二中校内雀巢咖啡杯模拟赛的题目，原本有标程没有题解......

我们都是啃生肉啃过来的......(管理员原谅我这么多废话QAQ)

好吧，说正事：

这道题目定义虫洞可以不进去的前提，是人物可以 通过调整步长 从 一个没有虫洞的点 直接跳到 另一个没有虫洞的点 。

所以，如果在 某一个位置前面 的 最大步长的位置 全都有虫洞的话，他必须进去一个。

那么，这一段之后的虫洞便全都无法直接到达。

建出图来直接SPFA就行了。

怎么实现呢？建图连边的时候判一下。注意到步长很小，我于是我选择在同余系下DP实现。

具体细节看代码吧。


最后上代码：

 
 
 
 
 
 
 
 
     
         
 
 
 
     
             
         
         
             
         
         
         
         
         
         
     
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
#define lli long long int
#define debug cout
using namespace std;
const int maxn=4e1+1e1,maxm=1.6e3+5e2;
const int inf=0x3f3f3f3f;
int s[maxn],t[maxm],nxt[maxm],l[maxm],cnt;
int st[maxn],ed[maxn];
int w,dv,n,lam;
lli dis[maxn];
bool inq[maxn];
int f[20],g[20];
struct node
{
    int st,ed;
    friend bool operator < (const node &a,const node &b)
    {
        return a.st<b.st;
    }
}ns[maxn];
inline void addedge(int from,int to,int len)
{
    t[++cnt]=to;
    l[cnt]=len;
    nxt[cnt]=s[from];
    s[from]=cnt;
}
inline int ceildiv(int x)
{
    return (x+dv-1)/dv;
}
bool judge(int x)
{
    for(int i=0;i<dv;i++)
        if(x-i>=0&&*lower_bound(st+1,st+1+n,x-i)!=x-i) return 0;
    return 1;
}
inline void core_add(int x)
{
    f[0]=0;
    for(int i=1;i<dv;i++) f[i]=1;
    int lst=0,nlst,delta;
    for(int i=1;i<=n;i++)
        if(i!=x&&st[i]>=ed[x])
        {
            memset(g,0x3f,sizeof(g));
            delta=st[i]-ed[x];
            nlst=delta/dv;
            for(int k=0;k<dv;k++)
                for(int j=0;j<dv;j++)
                    if(nlst*dv+k>=lst*dv+j)
                    {
                        g[k]=min(g[k],f[j]+ceildiv(nlst*dv+k-lst*dv-j));
                    }
            addedge(x,i,g[delta%dv]);
            g[delta%dv]=inf;
            for(int k=0;k<dv;k++) f[k]=g[k];
            lst=nlst;
            if(judge(st[i])) return;
        }
}
inline void spfa(int st)
{
    memset(inq,0,sizeof(inq));
    memset(dis,0x3f,sizeof(dis));
    queue<int> q;
    dis[st]=0;
    inq[st]=1;
    q.push(st);
    while(!q.empty())
    {
        const int pos=q.front();
        q.pop();
        inq[pos]=0;
        int at=s[pos];
        while(at)
        {
            if(dis[t[at]]>dis[pos]+l[at])
            {
                dis[t[at]]=dis[pos]+l[at];
                if(!inq[t[at]])
                {
                    q.push(t[at]);
                    inq[t[at]]=1;
                }
            }
            at=nxt[at];
        }
    }
}
inline int getint()
{
    int ret=0,fix=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') fix=-1; ch=getchar();}
    while(ch>='0'&&ch<='9')
        ret=ret*10+(ch-'0'),
        ch=getchar();
    return ret*fix;
}
inline void init()
{
    memset(t,0,sizeof(t));
    memset(nxt,0,sizeof(nxt));
    memset(l,0,sizeof(l));
    memset(inq,0,sizeof(inq));
    memset(s,0,sizeof(s));
    memset(st,0,sizeof(st));
    memset(ed,0,sizeof(ed));
    cnt=0;
}
int main()
{
    int cse;
    while(w=getint())
    {
        init();
        dv=getint(),n=getint();
        lam=dv-1;
        for(int i=1;i<=n;i++)
            ns[i].st=getint(),ns[i].ed=getint();
        sort(ns+1,ns+1+n);
        for(int i=1;i<=n;i++)
            st[i]=ns[i].st,ed[i]=ns[i].ed;
        st[n+1]=ed[n+1]=0;
        st[n+2]=ed[n+2]=w;
        n+=2;
        for(int i=1;i<=n;i++)
        {
            core_add(i);
        }
        spfa(n-1);
        printf("%lld\n",dis[n]);
    }
    return 0;
}
```

---

## 作者：JNK_DOG (赞：12)

#### 总体思路：离散化 + 建图 + 单源最短路
######  （~~看见人少蒟蒻才敢发题解QAQ~~）
---
需要注意的是：
+ 考虑到w范围较大，而实际虫洞数量较小，就只记录虫洞的起点与终点来建图。
+ 建图时，虫洞起点可以去重。
+ 在建图时b、e两点的距离并不一定为（e-b+s-1）/s。比如当我从0处走到6处，限定步数为3时，理论上是走2步，但如果3处有虫洞无法停留，则只能0->2->5->6走4步。
```cpp
#include <bits/stdc++.h>
#define r(x) scanf("%d",&x)
const int I=50;
using namespace std;
set<int>s;//去重
int w,st,p,c;
int l[I*2],x[I],y[I];//l[]为离散化数组，x[]为虫洞起点,y[]为虫洞终点
int d[I*2][I*2];
int F(int b,int e){//求解两点间距离
		if(b==e)return 0;
		if(s.count(b))return 0x3fffffff;
		int k=e;
      for(int i=1;i<=p;i++)
          if(b<x[i]&&x[i]<k&&(x[i]-b)%st==0)k=x[i];//查找第一个落脚点
      while(k!=e&&s.count(k))k--;
      if(k==b)return 0x3fffffff;
      return F(k,e)+(k-b+st-1)/st;
}
int Q(int x) {//由原点找离散化后的点
      return lower_bound(l+1,l+c+1,x)-l;
}
void Floyd(){//求解最短路
      for(int k=1;k<=c;k++)
      for(int i=1;i<=c;i++)
      for(int j=1;j<=c;j++)
          d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
}
int main(){
      r(w);
      while(w!=0){
          r(st);r(p);
          s.clear();
          memset(l,0,sizeof l);
          memset(x,0,sizeof x);
          memset(y,0,sizeof y);
          c=0;
          l[++c]=0;l[++c]=w;
          for(int i=1;i<=p;i++)
              r(x[i]),r(y[i]),s.insert(x[i]),l[++c]=x[i],l[++c]=y[i];
          sort(l+1,l+c+1);
          c=unique(l+1,l+c+1)-l-1;
          memset(d,0x3f,sizeof d);
          for(int i=1;i<=p;i++)
              d[Q(x[i])][Q(y[i])]=0;//虫洞起终点距离为0
          for(int i=1;i<c;i++)
          for(int j=i+1;j<=c;j++)	
              d[i][j]=min(d[i][j],F(l[i],l[j]));//初始化
          Floyd();
          cout<<d[1][c]<<endl;
          r(w);
      }
      return 0;
}
```

---

## 作者：suxxsfe (赞：9)

首先安利我的博客园，就快写好了还有一点细节需要完善，点击[这里](https://www.cnblogs.com/suxxsfe/p/12571137.html)获得更好阅读体验  

这个题解比较详细比较长，适合萌新  

------------

## 题目背景
applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。  

## 题目描述
为了简化问题，我们建立一个一维坐标系，地球的位置为$0$，而applepi 的目的地的位置是一个正整数W。在每一个单位时间里，applepi可以向正方向移动不超过$S$ 的一个整数。虫洞可以被表示为二元组$(B, E)$，即如果在某次移动之后applepi 在位置$B$，那么applepi 就会被立刻传送到位置$E$。注意，applepi 在移动过程中如果经过位置$B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。  

## 输入格式  
输入包含多组测试数据。  

每组测试数据的第一行是三个正整数 $W,S,P$，表示目的地位置，移动限制和虫洞的数目。之后 $P$ 行，每行两个整数$B$ 和$E$，表示一个虫洞。  

输入文件的最后一行是一个整数 $0$，表示输入的结束。  

## 输出格式
对于每组测试数据，在单独的一行内输出结果。  

对于 $100%$ 的数据，$W\leq 10^9,2\leq S\leq 6,1\leq p\leq 40$，没有$B = 0$ 或者$B = W$ 的虫洞，输入数据保证目的地可达。  

---------  

从[简单图论](https://www.luogu.com.cn/training/3112#information)那个题单点进来的，本来想A了以后就去做其它图论题单上的题，结果一天就调出来这一个。。。  
首先，我觉得这不能是一个绿题，差不多要是蓝，虽然思路不难，但实现需要点功夫，所以，如果管理员看见希望可以考虑一下这个难度是否恰当~~当然也有可能是我太蒻~~  

-------------  

## 首先离散化：
言归正传，观察到，$w$特别大，但$p,s$很小，所以可以考虑从$p,s$入手~~开始乱搞~~  
建图肯定不能一个数轴点对应一个节点了，考虑到起较大作用的点只有虫洞的两个端点  
所以用一下离散化，只保留虫洞入口和出口，当然还要保留起点$(0)$和终点$(w)$这样点数是$2p+2$，做完离散化后存在$map$数组中  

关于离散化，通俗的讲，就是把没用的元素去掉，比如这个题两个虫洞的端点之间的那一堆点，就是没用的，不必保存下来，只保存有用的点（虫洞端点，起点终点），存下他们的坐标就行（存坐标的那个$map$数组的下标也就是建图时的节点编号）  
然后还要排个序，方便下面操作  
这玩意也听常用，更为深入的自己去百度吧，真的不难  

## 然后想办法建图：  
那么如何建图？  
首先虫洞的起点和终点肯定是要连一条边权为$0$的边，至于如何通过点的组标确定其对应的节点编号，用二分实现，这是离散化的传统技能  

因为我们走路肯定要借助虫洞，不用虫洞走的路就是：从一个虫洞的终点，走到另一个虫洞的起点  
因此，我们可以枚举每两个有用的点，计算他们的的距离，如果第一个点的坐标是一个起点，就不计算直接返回无穷大  
因为我们不能从一个起点开始走，走到那会接着被传送走，但是我们可以走到一个起点，走到那以后接着会从边长为$0$的虫洞边走到它对应的终点  

对于如何判断一个点是否是起点，我用的`map<int,int>`，对每个起点打上标记，题解区好多大佬用到是`set`，不过本质一样  

## 再考虑非虫洞边的边权咋计算：  
设$x,y$分别是要计算的这条边的起点，终点  
首先想到的是$\lceil\dfrac{y-x}{s}\rceil$  
然而这样写完以后就会~~像我一样~~得到10分的好成绩  
为什么？因为在$[x,y]$中，还有一些点是虫洞入口，是不能踩的，一踩就被传送走了  
例子楼上有大佬给出了  

那我们可以考虑递归的计算（其实一开始想写成非递归，炸了，看来题解就写的递归  
先贪心的每步都走$s$，看看这样走第一个遇到的虫洞入口是哪个  
至于如何实现，肯定就是枚举每个虫洞，~~都说了p很小~~  

遇到了虫洞入口，就要一格一格往回退，直到遇见了不是虫洞入口的格子  
那如果我又退回来起点，说明怎么走都白搭，走不了返回无穷大  
没有退回到起点，假设退到$y'$，那么从$x$到$y'$肯定就是$\lceil\dfrac{y'-x}{s}\rceil$了  
那么$y'\rightarrow y$的费用，就可以递归计算了，递归到$x=y$，费用肯定为$0$，就返回  

还有一个细节就是，当遇到了虫洞起点要开始往回退的时候，要判断一下当前这个入口是不是就是$y$，如果是，那么说明已经走到了地方，就不退了  

## 最后跑最短路  
随便用什么算法跑个最短路就行，范围很小  
~~如果你用dfs就当我没说~~  

最后放上代码，~~可以从注释中体会一下我调代码时的心情~~  

```cpp  
#include<cstdio>
#include<map>
#include<queue>
#include<cstring>
#include<cmath>
#include<algorithm>
#define reg register
#define EN std::puts("")
inline int read(){
	int x=0,y=1;
	char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=-1;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return x*y;
}
int n,p,s;
int map[106],tmp[106],tot;
std::map<int,int>start;
int dis[105][105];
int from[105],to[105];
inline int isstart(int x){//判断pos是不是一个起点 
	return start.find(x)==start.end()?0:1;
}
inline int find(int pos){//这个函数二分查找pos这个点对应的数组下标 
	reg int l=1,r=tot,mid,ret;
	while(l<=r){
		mid=(l+r)>>1;
		if(map[mid]>=pos) ret=mid,r=mid-1;
		else l=mid+1;
	}
	return ret;
}
inline int getdis(int x,int y){
	if(x==y) return 0;
	if(isstart(x)) return 0x3f3f3f3f;//x是个起点，不行 
	int yy=y;
	for(reg int i=1;i<=p;i++)if(from[i]>x){
		if(yy>from[i]&&(from[i]-x)%s==0) yy=from[i];
	}
	while(yy!=y&&isstart(yy)) yy--;//如果yy已经等于y了，就算是一个起点也不再退了 
	if(yy==x) return 0x3f3f3f3f;//退回了起点，永远到不了了qwq 
	return getdis(yy,y)+std::ceil((double)(yy-x)/s);
}
int main(){for(;;){
	n=read();
	if(!n) return 0;
	s=read();p=read();
	tot=0;start.clear();
	tmp[++tot]=0;tmp[++tot]=n;
	for(reg int i=1;i<=p;i++){
		tmp[++tot]=from[i]=read();tmp[++tot]=to[i]=read();
		start[from[i]]=1;
//		std::printf("%d %d\n",start.find(from[i]),start.end());
	}
	//开始排序和去重
	std::sort(tmp+1,tmp+1+tot);
	reg int hq=tot;tot=0;
	map[++tot]=tmp[1];
	for(reg int i=2;i<=hq;i++)if(tmp[i]!=tmp[i-1])
		map[++tot]=tmp[i];
	//下面开始建边
	std::memset(dis,0x3f,sizeof dis);
	for(reg int i=1;i<=p;i++) dis[find(from[i])][find(to[i])]=0;
	for(reg int i=1;i<=tot;i++)
		for(reg int j=i+1;j<=tot;j++)
			dis[i][j]=std::min(dis[i][j],getdis(map[i],map[j]));
	//floyd
	for(reg int k=1;k<=tot;k++)
		for(reg int i=1;i<=tot;i++)
			for(reg int j=1;j<=tot;j++) dis[i][j]=std::min(dis[i][j],dis[i][k]+dis[k][j]);
	std::printf("%d\n",dis[1][tot]);

//	for(reg int i=1;i<=tot;i++) std::printf("%d ",map[i]);std::puts("");
//	for(reg int i=1;i<=p;i++) std::printf("%d %d\n",find(from[i]),find(to[i]));std::puts("");
//	for(reg int i=1;i<=tot;i++){
//		std::printf("%d: ",i);
//		for(reg int j=1;j<=tot;j++) std::printf("%d ",dis[i][j]);
//		std::puts("");
//	}
}
}
```

---

## 作者：MurderChara (赞：7)

### [P2620 虫洞](https://www.luogu.org/problem/P2620)
考试的题目偶然发现在洛谷上有，还（曾经）是一道黑题（~~纪念已死黑题~~）（~~老师真邪恶~~），在考场上只刚了这一道题，然鹅最后总分10分（机房暴零人数最多的一次考试），作为钻研了这道题目的蒟蒻，在自认为搞懂的情况下就赶快来到洛谷~~水经验~~写题解来造福大众辣233



------------
### 主要算法
 离散化+建图+最短路
#### 什么是离散化（DALAO请继续向下一层走）
通俗点来说，就是把不改变数据相对大小的前提下对数据进行相应的缩小，把无限空间的个体映射到有限空间里去（摘自百度），本题解使用了STL算法离散化(其实就是排序与去重)，想深入了解的童鞋[可以来这康康](https://baike.baidu.com/item/%E7%A6%BB%E6%95%A3%E5%8C%96/10501557)



------------
### 题目分析

~~考场上的思想是贪心+DP，然后想着这题真水，后来发现W可达到10^9，然后便试图各种优化，结果后来发现和正解没挨上边qwq~~

- W<=10^9，如此大的数据我们自然不能正常的拿数组存点，所以我们需要离散化这个好东西，因为普通的点我们其实可以不那么重视，重要的只有起点终点和虫洞的入口和出口所以我们只要考虑它们，将他们存入数组，排序后去重，这样我们就可以为建图作准备

- 注意！题目中有没说明的条件（实测得出），即没有任何一个虫洞的入口和出口会在终点后面，所以我们可以放心排序+去重

- 去完重后就是核心的存边，首先同一虫洞的起点到终点距离为0，在用有一点点贪心思想的方法存边（详细解释请见标程）

- ~~因为数据好像有点水，所以~~我们就可以愉快的floyd啦

- 代码里还有点玄学，不过都有超详细的注释
------------
### 代码实现
呜呜呜，这个辛辛苦苦理解了好久呢，可能这代码的注释是我写过代码中最多的

```cpp
#include<bits/stdc++.h>
using namespace std; 
int l[100],c;//l存边,c待用 
int x[50],y[50];//x存虫洞入口，y存出口 
int d[100][100];//冒充邻接矩阵存边233 
int w,s,p;//待用 
set<int>se;//用于存虫洞起点。作用：便于查询(然鹅我用的是map,好像还更方便) 
int F(int b,int e)//核心代码:存边 
{
	if(b==e)//若起点就是终点,自然就返回0 
		return 0;
	if(se.count(b))//若起点有虫洞,直接返回 
		return 0x3fffffff;
	int f=e;
	for(int i=0;i<p;i++)//枚举虫洞 
	{
		if(b<x[i]&&x[i]<f&&(x[i]-b)%s==0)
			f=x[i];//找如果不停按最大值(s)走的话第一个遇见的虫洞入口的位置 
	}
	while(f!=e&&se.count(f))//如果按最大值s走会有虫洞 
		f--;//委曲求全233  也就是把终点倒退至无虫洞处   这便是set的妙用 
	if(f==b)//如果f就是b,就到不了 
		return 0x3fffffff;
	return (f-b+s-1)/s+F(f,e);//正常的计算(递归),不知道是不是二分(雾)
	//有向上取整的技巧 
	//assert(0);
	//assert的作用是先计算表达式(括号里的东西)
	//若值为0(假)则终止运行  (好像是更方便调试)
}
int Q(int x)//找出虫洞的起点or终点(x)在排完序后的l的位置 
{
	return lower_bound(l,l+c,x)-l;
	//求出不降子序列中第一个>=x的数在l中的位置 
	//lower_bound的复杂度为O(logn) 
	//如果找到返回找到元素的地址,否则返回l+c的地址
}
int main()
{
	//freopen("wormhole.in","r",stdin);freopen("wormhole.out","w",stdout);
	while(scanf("%d %d %d",&w,&s,&p),w)//简写+输入 
	{
		se.clear();//清空set中的元素 
		c=0;//
		for(int i=0;i<p;i++)//输入虫洞 
		{
			scanf("%d %d",x+i,y+i),se.insert(x[i]);//指针操作,将有虫洞起点的点放入集合中 
			l[c++]=x[i],l[c++]=y[i];//”c++“会执行两次 
		}
		l[c++]=0,l[c++]=w;//确保排序后起点是0 
		sort(l,l+c);//排序下，难道不会打乱吗qwq(蒟蒻思想)     然而实际上是便于下面的unique元素去重233
		c=unique(l,l+c)-l;//更新后的的c是去重后的数组长度 
		/*unique:STL中的常用函数，功能是元素去重。
		即”删除”序列中所有相邻的重复元素(只保留一个)。		
		此处的删除，并不是真的删除，而是指重复元素的位置被不重复的元素给占领了。 
		由于它”删除”的是相邻的重复元素，所以在使用unique函数之前，一般都会将目标序列进行排序。(载录)*/
		memset(d,0x3f,sizeof d);//初始化d数组至无穷大 
		for(int i=0;i<p;i++)
			d[Q(x[i])][Q(y[i])]=0;
			//传入虫洞的起点与终点x[i],y[i]; 
			//找出虫洞的起点or终点在l中的位置后，用二维数组d标记位置(即在l中的下标) 
		for(int i=0;i<c;i++)// 
			for(int j=i+1;j<c;j++)
			//c=虫洞数目+2(起点与终点)
				d[i][j]=min(d[i][j],F(l[i],l[j]));//存边 
		for(int k=0;k<c;k++)//floyd经典最短路算法 
			for(int i=0;i<c;i++)
				for(int j=0;j<c;j++)
					d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
		printf("%d\n",d[0][c-1]);
	}
	return 0;
}
```


------------

DALAO们多多关照呀QAQ

---

## 作者：九思 (赞：5)

链接:[虫洞](https://www.luogu.org/problem/P2620)  
upd2020.4.4:把注释改了/ch  
**离散化** 建 **树**，然后跑floyd(当然SPFA和dijkstra都是可以的)。  
离散化就是将一个线性结构上离得很远的有效点缩短成一个不超过点数量长度的线性结构以满足某些算法(变态)要求。(如果大佬有更好的理解的话欢迎普及)  
接下来是代码

```cpp
#include<stdio.h>
#include<string.h>
#include<iostream>
#include<algorithm>
#include<set>
#define f(i,a,b) for(register int i=a;i<b;++i)
#define inhash(a,b) __hash[c++]=a,__hash[c++]=b
#define min(a,b) a<b?a:b
using namespace std;
const int N = 100;
template <class T> inline void read(T &n) {
	n=0;register char ch;while(!isdigit(ch=getchar()));
	for(n=ch^48;isdigit(ch=getchar());n=(n<<3)+(n<<1)+(ch^48));
}

int w,s,p,__hash[N];
int c,x[N],y[N];
int dis[N][N];
set<int>__set;

int Find_path(int t,int e) {
//这个函数就是建边，并且要防止在s步飞速奔向虫洞的时候掉进虫洞，每次只处理一个非法
	if(t == e)return 0;
	int cls = e;
	f(i,0,p) if( t<x[i] && x[i]<cls && (x[i]-t)%s == 0)
		cls = x[i];//find the closest path with no wormhole seperates
	while(cls != e && __set.count(cls))--cls;
	if(cls == t)return 0x3fffffff;
	return (cls - t + s - 1) / s + Find_path(cls,e);
}

int Q(int i){return lower_bound(__hash,__hash+c,i) - __hash;}

int main() {
    while(1) {
    	read(w);
    	if(!w)return 0;
    	read(s);
    	read(p);
    	//初始化(非常重要)
    	__set.clear();
		memset(dis, 0x3f, sizeof dis); 
		c=0;
    	//存边
    	f(i,0,p) {
			read(x[i]), read(y[i]);
			__set.insert(x[i]);//用来判断是不是虫洞入口
			inhash(x[i],y[i]);//扔进hash离散化(这只是个宏定义)
		}
    	inhash(0,w);//。。。
    	
    	sort(__hash,__hash+c);
    	//c = unique(__hash,__hash+c) -__hash;去重(这可以不要)
    	//建立并优化每条边最短路，是求解的前置要求 (一定从小往大走)
    	// 1>6 9>3 ==> 1>3 
    	f(i,0,p) dis[ Q(x[i]) ][ Q(y[i]) ] = 0;//给虫洞单独处理
    	f(i,0,c) if( !__set.count(__hash[i]) )//是虫洞入口的话只能连向出口，所以不用考虑再连边了
    	f(j,i+1,c) dis[i][j] = min(dis[i][j], Find_path(__hash[i], __hash[j])); //i<j:No way to go back! 
    	//floyd
    	f(k,0,c) f(i,0,c) f(j,0,c) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
    	printf("%d\n",dis[0][c-1]);
    }
    return 0;
}


```


---

## 作者：OIer_ACMer (赞：2)

~~为啥一年前还是道黑题咋降成绿题了？！~~

------------
注：本题主要考察了 SPFA 等知识点，比较基础，因此作者不会过多阐述原理以及证明，望周知！

------------
## 题意（主要是这题废话较多）：
给一个一维坐标系，出发点为 $0$，目标点为 $w$。每 $1$ 秒可以往后移不超过 $s$ 个单位距离。现有 $p$ 个虫洞，可以把你从 $s_i$ 瞬移到 $t_i$，问最少多少秒可从出发点到目标点。

数据范围：$w \le 10^9$，$2 \le s \le 6$，$p \le 40$。

------------
## 大致思路：
容易看出，$w+1$ 个点中很多点是没有意义的。主要有意义的是那 $p$ 个黑洞，因此我们就考虑用那 $p$ 个黑洞建一张图。

首先，我们要用前向星构造出图的大概样式，紧接着，最重要的操作就是**我们要将可以通过黑洞运动的点之间的距离**。设x轴上它们间距离为 $len$。设 $dp_i$ 为从当前点开始，到达距离模 $s$ 为 $i$ 的点的最短距离（不知道 $s$ 是啥的人就看一下题目“**可以向正方向移动不超过 $s$ 的一个整数**”这个条件）。先定一个虫洞，然后枚举第二个虫洞。然后不断用上一个虫洞终点的 $dp_i$ 更新这一个虫洞终点的 $dp_i$ 即可。最后把 $dp_{len}=inf$，记得那个 $len$ 要对 $s$ 取模，代表不能用其更新下一次答案（越搞越像动态规划）。

需要注意的是，如果有 $s$ 个虫洞的起点连续成段，后面的虫洞就走不到了。

之后的操作就是有关 SPFA 的了，作者就不再细讲。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 2e3 + 100, inf = 2e9;
int tar, head[50], cnt, s, n, st[50], dp[10], g[10];
int dis[50];
bool vis[50];
struct Edge
{
    int to, nxt, w;
} e[N << 1];
struct hol
{
    int l, r;
    bool operator<(const hol &o) const { return l < o.l; }
} a[N];
void add(int u, int v, int w)
{
    e[++cnt] = (Edge){v, head[u], w};
    head[u] = cnt;
}
int ban(int x)
{
    for (int i = 0; i <= s - 1; i++)
    {
        if (x - i >= 0 && st[lower_bound(st + 1, st + 1 + n, x - i) - st] != x - i)
        {
            return 0;
        }
    }
    return 1;
}
int calc(int x)
{
    return (x + s - 1) / s;
}
void Build(int x)
{
    dp[0] = 0;
    for (int i = 1; i < s; i++)
    {
        dp[i] = 1;
    }
    int las = 0, len, yu;
    for (int i = 1; i <= n; i++)
    {
        if (i != x && a[i].l >= a[x].r)
        {
            for (int j = 0; j < s; j++)
            {
                g[j] = inf;
            }
            len = a[i].l - a[x].r;
            yu = len / s;
            for (int j = 0; j < s; j++)
            {
                for (int k = 0; k < s; k++)
                {
                    if (yu * s + k >= las * s + j)
                    {
                        g[k] = min(g[k], dp[j] + calc(yu * s + k - las * s - j));
                    }
                }
            }
            add(x, i, g[len % s]);
            g[len % s] = inf;
            for (int j = 0; j < s; j++)
            {
                dp[j] = g[j];
            }
            las = yu;
            if (ban(a[i].l))
            {
                return;
            }
        }
    }
}
void SPFA(int S)
{
    queue<int> Q;
    for (int i = 1; i <= n; i++)
    {
        dis[i] = inf;
    }
    dis[S] = 0;
    vis[S] = 1;
    Q.push(S);
    while (!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        for (int i = head[u]; i; i = e[i].nxt)
        {
            int v = e[i].to;
            if (dis[v] > dis[u] + e[i].w)
            {
                dis[v] = dis[u] + e[i].w;
                if (!vis[v])
                {
                    Q.push(v), vis[v] = 1;
                }
            }
        }
        vis[u] = 0;
    }
}
int main()
{
    while (114514)
    {
        tar = read();
        memset(head, 0, sizeof(head));
        if (!tar)
        {
            return 0;
        }
        cnt = 0;
        s = read();
        n = read();
        for (int i = 1; i <= n; i++)
        {
            a[i].l = read(), a[i].r = read();
        }
        sort(a + 1, a + 1 + n);
        a[n + 1].l = a[n + 1].r = 0;
        a[n + 2].l = a[n + 2].r = tar;
        n += 2;
        for (int i = 1; i <= n; i++)
        {
            st[i] = a[i].l;
        }
        for (int i = 1; i <= n; i++)
        {
            Build(i);
        }
        SPFA(n - 1);
        cout << dis[n] << endl;
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122759523)

---

## 作者：gongxuanwen (赞：2)

## [P2620 虫洞](https://www.luogu.com.cn/problem/P2620)

本蒟蒻的第一篇题解，如有不妥，请多包涵，求赞。

算法复杂度为 $O(n^2)$，未刻意卡常，最终耗时 $\texttt{41ms}$（应该挺快）。

[提交记录](https://www.luogu.com.cn/record/113713464)

这篇题解较为详细，适合萌新观看。

PS：一开始计算边权步骤循环内二、三两句写反了，还能 `AC`，强烈建议加强数据。

## 思路

因为本题允许向负方向传送（存在后效性），导致动态规划算法的实施比较困难。

观察题面，要求我们解答的是“最小单位时间”，因为每次主动移动消耗一个单位时间，所以也就是求最小次数。这和最短路算法有相似之处。

所以我们可以考虑将题面提供的数据转化成一张图，然后用最短路算法求解。这就是所谓“建图”过程。

## 离散化

离散化，就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。简单来说，就是用简单的事物（如编号）一一对应某些复杂的事物，一次来优化算法。

本题中，坐标的范围很大，我们不可能将所有坐标遍历，于是我们选择将所有虫洞的起点和终点、起始地和目的地一一编号，以编号来代替具体坐标进行操作。

## 连边

### 虫洞起点 -> 虫洞终点

首先很容易想到的是，在每个虫洞的起点和终点间连一条边，根据题意，这样的传送方式不消耗任何时间单位，所以边权应为 $0$。这种边我们可以在读入时直接操作。


具体操作如下（伪代码）：

```
对于每个虫洞:
    读入 起点坐标 终点坐标 
    记录起点编号
    记录终点编号
    连边 从 起点 到 终点 权值为 0
```
### 虫洞终点 -> 其他虫洞起点

由于本题主要通过充分利用虫洞进行位移，我们必须将虫洞之间连接起来。形象化地说，即从一个虫洞的终点出来后，我们要出发前往另一个一个虫洞起点（当然还有起始地和目的地的情况，我们待会讨论）。

那么一个虫洞终点到另一个虫洞起点的边权（步数）如何测算呢？

#### 方法一

参考其他题解的做法，我们从坐标小到大遍历每个虫洞起点，如果某个虫洞起点刚好挡路（即取模最大步长后为 $0$），那么就要后退，直到遇到某个点可以踩的，然后继续前进，直到走到目标点。如果范围内没有点可以踩（遇到了一段较长且连续的虫洞），那么注定走不过去了，二者之间的距离就是无穷大了。

具体操作如下（伪代码）：
```
计算点 A 和 B 间的步数:
    如果 A==B 返回 0
    对于每个虫洞起点:
    	如果这个点挡路:
            不断退步
        直到:
            不挡路
    	如果退无可退:
            返回无穷大
        记录为点 C
        直接计算点 A 到点 C 间的步数
    返回 计算 C 和 B 间的步数 + A 到点 C 间的步数
```
#### 方法二

暴力枚举每两个点，再用 $O(n)$ 计算太费时间了，我们可以一次性将一个虫洞终点到所有虫洞起点的步数全部算出！

如上一个方法相似，但是对于不挡路的点单独计算，并不断记录当前最后的落脚点。挡路的点先单独计算，再以这个落脚点为基准继续计算。

具体操作如下（伪代码）：
```
计算点 A 和 B 间的步数:
    对于在 A 后的每个虫洞起点:
        如果前一个点没有虫洞:
            记录前一个点为最新落脚点
        连边 从 A 到 当前点 边权为 直接计算 基准点 到 当前点间的步数 + 累计步数
        如果挡路并且落脚点太远:
            直接返回放弃之后的计算
        如果挡路:
            将累计步数加上基准点到落脚点间的步数
            更新基准点为落脚点
        
```

### 起始地/目的地

我们发现，起始地的性质与虫洞终点相似，都是由它开始去连别的点。目的地的性质与虫洞起点相似，都是由其他点开始去连它。

于是我们在一开始就直接将起始地加入虫洞终点集，将目的地加入虫洞起点集，这样就省去了特判的操作。

## 最短路

本题虫洞数为 $P$，根据我们的思路，图中有大约 $2P$ 个点、$P^2$ 条边。

我们可以分析出不同方法的时间复杂度：

| 算法 | 时间复杂度 |
| :-----------: | :-----------: |
| Floyd | $O(n^3)$ |
| Dijkstra 朴素版 | $O(n^2)$ |
| Dijkstra 二叉堆优（劣）化 | $O(n\log n)$ |
| Dijkstra 斐波那契堆优化（还不会） | $O(n^2)$ |
| SPFA 随机数据 | $O(n^2)$ |
| SPFA 被卡 | $O(n^3)$ |
| $\cdots\cdots$ | $\cdots\cdots$ |

以上任何一种方法过这题是没问题的。我这里选用了简单高效的 Dijkstra 朴素版。

具体操作如下（伪代码）：

```
重复点的个数次:
    遍历找一个距离最近的未被访问的点
    标记已访问
    对于当前点的朝向的每一个点:
        如果起点到当前点距离加上当前点到朝向点距离大于朝向点的最小距离:
            更新朝向点的最小距离
        （即松弛）
```

## 最终代码
```cpp
#include <iostream> // cin cout 输入输出
#include <algorithm> // max min upper_bound sort 等
#include <vector> // vector 链表容器
#include <bitset> // bitset 位集容器
#include <cstring> // memset

#define N 40 // 最大虫洞数 
#define INF 0x3f3f3f3f // 无穷大 

using namespace std;

struct Point // 点结构体 
{
    int pos, ord; // 坐标 编号 
};

struct Edge // 边结构体 
{
    int to, dis; // 朝向点 边权 
};

vector <Edge> v[(N << 1) + 3]; // 邻接表存边 

int W, S, P, dis[(N << 1) + 3]; // 目的地 最大步长 冲动数 当前最小距离 

Point from[N + 2], to[N + 2]; // 虫洞起点 虫洞终点  

bitset <(N << 1) + 3> b; // 位集记录点是否访问 

void CalcDis(int x)
{	
    int now = to[x].pos, last, step = 0; // 记录点 最后一个落脚点 到记录点的步数 
	
    for(int i = upper_bound(from + 1, from + P + 1, to[x], [&](Point x, Point y){return x.pos < y.pos;}) - from; i <= P; ++ i)
    {
        if(from[i].pos - 1 != from[i - 1].pos)
            last = from[i].pos - 1; // 不断更新落脚点 

        v[to[x].ord].push_back({from[i].ord, step + (from[i].pos - now - 1) / S + 1}); // 连边 

        if(!((from[i].pos - now) % S) && last == from[i].pos - S)
            return; // 如果走不过去就直接返回 
		
        if(!((from[i].pos - now) % S)) // 更新记录点和到记录点的步数 
        {	
            step += (last - now - 1) / S + 1; // 向上取整
						
            now = last;
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    
    cin >> W;
    while(W)
    {
        cin >> S >> P;

        for(int i = 1; i <= (P << 1) + 2; ++ i) // 多测清空 
            v[i].clear();

        b.reset();
        ++ P;

        for(int i = 1; i != P; ++ i)
        {
            cin >> from[i].pos >> to[i].pos;

            from[i].ord = i;
            to[i].ord = i + P;

            v[i].push_back({i + P, 0}); // 连边 
        }

        from[P] = {W, P}; // 加入目的地 
        to[P] = {0, P << 1}; // 加入起始地 

        sort(from + 1, from + P + 1, [&](Point x, Point y){return x.pos < y.pos;}); // 排序 

        for(int i = 1; i <= P; ++ i) 
            CalcDis(i); // 计算步数 

        memset(dis, 0x3f, sizeof dis); // 初始化无穷大 

        dis[P << 1] = 0; // 起点到自己距离为0 

        for(int i = 0; i != P << 1; ++ i) // 每次求一个点 
        {
            int nearest = 0, Min = INF;

            for(int j = 1; j <= P << 1; ++ j) // 打擂找最小点 
                if(!b[j] && dis[j] < Min)
                {
                    nearest = j;
                    Min = dis[j];
                }

            b[nearest] = true; // 记录已访问 

            for(const Edge it : v[nearest]) // 遍历 
                dis[it.to] = min(dis[it.to], dis[nearest] + it.dis); // 松弛 
        }

        cout << dis[P] << endl;

        cin >> W;
    }
}
```

---

## 作者：Asedwai (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P2620)
  
  ~~这不就是一道 dfs 题吗~~。  
## 思路  
  我们考虑每一个点后面的第一个虫洞。对于这个虫洞，我们要么到这个点传送，要么无视它。我们记走到了第 $x$ 个点，下一个虫洞的位置为 $y$，虫洞传送到哪里暂时不管。  
  
  我们可以 $O(1)$ 算出这两种情况的最少步数。前者瞪眼法，即 $\lceil \displaystyle \frac{y-x}{S} \rceil$。对于后者，我们可以将转移到落脚点上面。很明显落脚点会在 $y+1 \sim y+S-1 $ 之间（简单证明：不考虑最少步数，我们可以先走到点 $(y-1)$）。可以枚举这几个点稍微推一下算出最少步数。    
  
  知道这一点我们就可以开始 dfs + 剪枝了。记录到达的点和已经使用的步数，通过后面第一个虫洞进行 dfs，没有就可以计算答案。因为可以通过虫洞进行负移动，所以要用 `map` 把到每个可以到达点的最小步数记下来剪枝。
  
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
//#define endl "\n"
#define fer(i, a, b) for(int i = (a); i <= (b); i ++)
#define LL long long
int W, S, P; 
struct node {
	int s, t; 
} a[45];
map <int, LL> f; 
LL ans; 
void dfs(int x, LL v) {
	if(v >= f[x]) return ; 
	f[x] = v; 
	if(x > a[P].s || P == 0) { //后面没有虫洞就计算答案。
		ans = min(ans, v + (int)ceil(1.0 * (W - x) / S)); 
		return ; 
	}
	fer(i, 1, P) {
		if(a[i].s < x) continue; 
		if(a[i].s == x) { //一个小细节，跨越一个虫洞后的落脚点可能是另一个虫洞。
			dfs(a[i].t, v); 
			return ; 
		}
		LL t = ceil(1.0 * (a[i].s - x) / S); 
		dfs(a[i].t, v + t); //刚好落在虫洞时的最少步数，并且传送到另一端。
		fer(j, a[i].s + 1, a[i].s + S - 1) { //跨越虫洞，枚举落脚点。
			if(j <= t * S + x) //分类讨论，推式子。
				dfs(j, v + (a[i].s - x) / S + 1); 
			else dfs(j, v + t + 1); 
		}
		break; 
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr); 
	while(cin >> W && W) {
		cin >> S >> P; 
		f.clear(); 
		fer(i, 1, P) {
			cin >> a[i].s >> a[i].t; 
			f[a[i].s] = f[a[i].t] = 1e9; 
			fer(j, 1, S - 1) f[a[i].s + j] = 1e9; 
		}
		sort(a + 1, a + P + 1, [](node &a, node &b) { return a.s < b.s; }); 
		f[0] = 1e9; 
		ans = 1e9; 
		dfs(0, 0); 
		cout << ans << endl; 
	}
	return 0; 
}
```

---

## 作者：s15172528531 (赞：0)

[《虫洞》题目url](https://www.luogu.org/problem/P2620)

思路：
1. 离散化:用map-mp记点,用map-be记所有起点,用数组fp作反映射,记点的原值
2. 最短路:记完点之后建图，真起点向所有虫洞起点与终点连边，所有虫洞终点对所有虫洞起点连边，所有虫洞终点向真终点连一条边，然后连完之后跑个最短路
3. 连边:**dis(x,y)!=(y-x+s-1)/s**因为中间可能踩到起点传送，所以要尽量避免踩到起点，如果不能避免则不连该边


```cpp
#include<iostream>
#include<map>
#include<queue>
#include<cstring>
#include<algorithm>
#define ms(x,y) memset(x,y,sizeof(x))
using namespace std;
const int maxn = 95;
const long long INF =0x3f3f3f3f3f3f3f3f;
long long e[maxn][maxn];
map<long long,int>mp;
map<long long,bool>be;
long long fp[maxn];
long long begin[maxn],end[maxn]; 
int cnt,s;
int p;
long long getDis(int x,int y)
{
	long long tt=y;
	if(x==y)return 0;
	if(be[x])
		return INF;
	for(int i=0;i<p;i++)
		if(begin[i]>x&&begin[i]<tt&&(begin[i]-x)%s==0)
			tt=begin[i];
	while(be[tt]&&tt!=y)tt--;
	if(tt==x)return INF;
	else return (tt-x+s-1)/s+getDis(tt,y);
}
int main()
{
	ios::sync_with_stdio(false);
	while(1)
	{
		be.clear();
		mp.clear();
		int w;
		cin>>w;
		if(w==0)
			return 0;
		cin>>s>>p;
		cnt=1;
		ms(e,0x3f);
		mp[0]=cnt;
		fp[cnt]=0;
		for(int i=0;i<p;i++)
		{
			int b,ee;
			cin>>b>>ee;
			be[b]=true;
			begin[i]=b;
			end[i]=ee;
			if(!mp[b]){
				mp[b]=++cnt;
				fp[cnt]=b;
			}
			if(!mp[ee]){
				mp[ee]=++cnt;
				fp[cnt]=ee;
			}
			e[mp[b]][mp[ee]]=0;
		}
		if(!mp[w])
		{
			mp[w]=++cnt;
			fp[cnt]=w;
		}
		long long dis[maxn];
		e[1][cnt]=getDis(0,w);
		for(int i=2;i<cnt;i++)
		{
			if(fp[i]>0)
				e[1][i]=getDis(0,fp[i]);
		}
		for(int i=0;i<p;i++)
			if(end[i]<w&&!be[end[i]])
				e[mp[end[i]]][cnt]=getDis(end[i],w);
		for(int i=0;i<p;i++)
			for(int j=0;j<p;j++)
			{
				int u=begin[i];
				int v=end[j];
				if(be[v])continue;
				if(e[mp[v]][mp[u]]!=0&&v<u)
					e[mp[v]][mp[u]]=getDis(v,u);
			}
		for(int i=2;i<=cnt;i++){
			dis[i]=e[1][i];
		}
		bool vis[maxn];
		ms(vis,false);
		vis[1]=true;
		dis[1]=0;
		for(int i=0;i<cnt;i++)
		{
			int k=-1;
			long long Min=INF;
			for(int j=2;j<=cnt;j++)
				if(!vis[j]&&dis[j]<Min)
				{
					k=j;
					Min=dis[j];	
				} 
			if(k==-1)break;
			vis[k]=true;
			for(int j=2;j<=cnt;j++)
				if(!vis[j]&&dis[j]>dis[k]+e[k][j])
					dis[j]=dis[k]+e[k][j];
		}
		cout<<dis[cnt]<<endl;
	}
} 
```


---


# 逐个击破

## 题目背景

三大战役的平津战场上，傅作义集团在以北平、天津为中心，东起唐山西至张家口的铁路线上摆起子一字长蛇阵，并企图在溃败时从海上南逃或向西逃窜。为了就地歼敌不让其逃走，指挥官制定了先切断敌人东西两头退路然后再逐个歼灭敌人的战略方针。秉承伟大军事家的战略思想，作为一个有智慧的军长你，遇到了一个类似的战场局面。


## 题目描述

现在有 $N$ 个城市，其中 $K$ 个被敌方军团占领了，$N$ 个城市间有 $N-1$ 条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你 $K$ 个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这 $K$ 个地方军团互相隔离开，以便第二步逐个击破敌人。


## 说明/提示

对于 $10\%$ 的数据，$N\le 10$。

对于 $100\%$ 的数据，$2\le N\le10^5$，$2\le K\le N$，$1\le c\le 10^6$。


## 样例 #1

### 输入

```
5 3
1 2 4
1 0 4
1 3 8
2 1 1
2 4 3```

### 输出

```
4```

# 题解

## 作者：顾z (赞：87)

题目描述-->[p2700 逐个击破](https://www.luogu.org/problemnew/show/P2700)

## 广告： [安利blog](https://www.luogu.org/blog/RPdreamer/#)

**题意概括**

花费最小的代价,使得一些有标记的节点**不连通**.

## 分析

我们需要花费最小代价使得原来连通的图中一些节点之间不相互连通.

贪心显然是可行的~~(一点也不显然~~

看到其他人写了dp,写了贪心.

但我感觉可以**排序+并查集**做啊.

### 排序

考虑我们要花费最小代价删边,但是**并查集不支持删除**操作.

~~(貌似有一种东西叫分治线段树可以维护这种操作.~~

因此,我们根据**容斥原理**~~(这玩意是叫容斥吧.~~

花费最小代价删边,等价于花最大代价建边,最后剩下不建的边,就是我们的答案.

所以说,我们需要**按照边权从大到小建图**。**sort！**

我们需要保证的是**两个敌人节点不互相连通**.

这就是我们**并查集**的作用!

### 并查集

**首先明确：** 

**并查集要初始化,一定要初始化!**

下面的图中,**红色代表敌人节点,绿色代表我方节点.**

如果某两个节点是我们的敌人节点,我们一定不会去建边.~~(为虎作伥?~~ 像这样↓.
![](https://cdn.luogu.com.cn/upload/pic/32024.png)
如果你连接,那你就违背了题目要求,你也不是一个

``秉承伟大军事家的战略思想，一个有智慧的军长了``

还有,如果我们已经~~将敌人包围~~建出下面这样的图这时,还有一个敌人节点.↓
![](https://cdn.luogu.com.cn/upload/pic/32027.png )

如果我们连接某一个我方节点,不连接敌方节点,那敌人也会互相连接~~(翻过屋后的山~~

所以说我们需要考虑一下如何解决这种情况.

如果,我方节点已经连接了敌方节点,则需要**标记我方节点,使得敌方节点无法通过我方节点连接敌方节点**.

因此说,我们可以**把连接到敌人节点的我方节点变成敌人节点.**

从而使得其他敌人节点与其无法连接.

那我们上面的图就变成这样↓
![](https://cdn.luogu.com.cn/upload/pic/32028.png )

这样我们的程序就可以实现我们所想了.

最后我们会将边权大的边加入到并查集中.

则最后**没有加入到并查集中的点,就会是被孤立的敌方节点.**

所以我们把**总边权减去我们加入到图中的边权**就是我们的ans啦！

## 关于样例

样例建的原图↓
![](https://cdn.luogu.com.cn/upload/pic/32030.png)

最终是这样的↓
![](https://cdn.luogu.com.cn/upload/pic/32034.png )

因此我们在样例的答案是4.

--------------------代码---------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
IL void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s>='0' and s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,k,f[100008],tot;
bool init[1000008];
long long ans;
struct cod{int u,v,w;}edge[100008];
IL int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
IL bool ccp(const cod&a,const cod&b){return a.w>b.w;}
int main(void)
{
	in(n),in(k);
	for(RI i=1;i<=n;i++)f[i]=i;//一定要初始化!
	for(RI i=1,x;i<=k;i++)in(x),init[x]=true;
	for(RI i=1;i<=n-1;i++)
		in(edge[i].u),in(edge[i].v),in(edge[i].w),ans+=edge[i].w;
	std::sort(edge+1,edge+n,ccp);//从大到小sort.
	for(RI i=1;i<=n-1;i++)
	{
		int u=edge[i].u,v=edge[i].v,w=edge[i].w;
		int fu=find(u),fv=find(v);
		if(init[fu] and init[fv])continue;
		f[fu]=fv;
		ans-=w;//减去边
		if(init[fu])init[fv]=true;
		else if(init[fv])init[fu]=true;
	}
	printf("%lld",ans);
}
```

---

## 作者：善良的死神 (赞：23)

就是感觉生成树

正难则反

有引用楼下管理员的话


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,k;
struct point 
{
    int x,y,dis;
}e[100001];
int fat[100001];
int find(int x)
{
    if(fat[x]!=x)
    fat[x]=find(fat[x]);
    return fat[x];
}
int visit[100001];
bool cmp(point const &a,const point &b)
{
    return a.dis>b.dis;
}
long long sum;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        fat[i]=i;
    for(int i=1;i<=m;i++)
    {int x;
        cin>>x;
    visit[x]=1;
    }    
    for(int i=1;i<=n-1;i++)
    {cin>>e[i].x>>e[i].y>>e[i].dis;
    sum+=e[i].dis;
    }
    sort(e+1,e+n,cmp);//先令所有道路摧毁，再按大到小修建两个不都是敌人的节点
    for(int i=1;i<n;i++)
    {
        int r1=find(e[i].x),r2=find(e[i].y);
        if(!(visit[r1]&&visit[r2]))//然后合并的时候必须 //要两个集合不是都有敌人的城市
        {    fat[r2]=r1;
        visit[r1]=(visit[r1]||visit[r2]);//如果一个正常节点连接上了敌人节点，
                                                      //那么这个正常节点也变为敌人节点
             //如果连接到了被占领了的,另外一个点要被"假占领"(因为合并了,所只要改父亲占领状态就好了)
        //不然的话要是另外一个占领的点连接到了这个点那么就有两个被真占领点联通了 
        sum-=e[i].dis; 
        }
    }
    cout<<sum;
    return 0;
}

```

---

## 作者：老恶心 (赞：13)

完全没想到生成树，并查集什么的，看一眼就觉得是树形dp

dp[i][0]表示到了i这个点，子树已经合法，当前点所在集合没有敌军的最小代价

dp[i][1]表示到了i这个点，子树已经合法，当前点所在集合有敌军的最小代价

这样就可以分情况讨论转移

1.i号点没有敌军，那么dp[i][1]就意味着要从子树中选一个能使花费最小的dp[v][1]，其他子树都切断或者从dp[v][0]转移

这时候dp[i][0]+=min(dp[v][0], dp[v][1]+w[i])(v是儿子节点)

2.i号点有敌军，那么dp[i][1]+=min(dp[v][0], dp[v][1]+w[i])只能和有敌军的儿子节点断绝联系

此时dp[i][0]=无限大

最后的答案就是min(dp[root][1], dp[root][0])了

详细的转移见代码 只要76ms









```cpp
#include<bits/stdc++.h>
#define inf 9999999999999
#define ll long long
#define mm(a,b) memset(a,b,sizeof(a))
using namespace std;
int read(){
    int sum = 0, fg = 1;
    char c = getchar();
    while(c < '0' || c > '9'){if(c == '-')fg = -1;c = getchar();}
    while(c >='0' && c <='9')sum = (sum<<1) + (sum<<3) + c-'0', c = getchar();
    return sum * fg;
}
const int maxn = 200010;
void file(){
#ifndef ONLINE_JUDGE
    freopen("ai.in","r",stdin);
    freopen("ai.out","w",stdout);
#endif
}
ll dp[maxn][2];
int n, k, vis[maxn], Begin[maxn], to[maxn], e, Next[maxn], w[maxn], is[maxn];
void add(int x,int y,int z){
    to[++e] = y;
    Next[e] = Begin[x];
    Begin[x] = e;
    w[e] = z;
}
ll minn(ll x,ll y){
    return x < y ? x : y;
}
void dfs_calc(int h,int father){
    dp[h][0] = dp[h][1] = 0; is[h] = vis[h];//is数组判子树内有没有敌军
    if(vis[h]) dp[h][0] = inf;//若当前点有敌军，dp[h][0]无限大
    ll tot = 0;
    for(int i = Begin[h];i ;i = Next[i]){
        int v = to[i];
        if(v == father) continue;
        dfs_calc(v, h); is[h] |= is[v];
        tot += minn(dp[v][0], dp[v][1] + (ll)w[i]);//先加上所有代价
    }
    if(!vis[h]){
        dp[h][1] = tot;
        for(int i = Begin[h];i ;i = Next[i]){
            int v = to[i];
            if(v == father) continue;
            if(!is[v]) continue;
            dp[h][1] = minn(dp[h][1], tot - minn(dp[v][0], dp[v][1] + (ll)w[i]) + dp[v][1]);//树形dp常用套路，在这里选择和哪一个相连
            if(vis[v])dp[h][0] += (ll)w[i] + dp[v][1];//再往底下就是简单的分类讨论了
            else dp[h][0] += minn(dp[v][0], dp[v][1] + (ll)w[i]);
        }
    }else{
        for(int i = Begin[h];i ;i = Next[i]){
            int v = to[i];
            if(v == father) continue;
            if(!is[v]) continue;
            if(vis[v]) dp[h][1] += dp[v][1] + (ll)w[i];
            else dp[h][1] += minn(dp[v][0], dp[v][1] + (ll)w[i]);
        }
    }
}
void Get(){
    n = read(), k = read();
    for(int i = 1;i <= k; ++i){
        int x = read() + 1;
        vis[x] = 1;
    }
    for(int i = 1;i < n; ++i){
        int x = read() + 1, y = read() + 1, z = read();
        add(x, y, z), add(y, x, z);
    }
    dfs_calc(1, -1);
    printf("%lld\n", minn(dp[1][0], dp[1][1]));
}
int main(){
    file();
    Get();
    return 0;
}
```

---

## 作者：LoverBoyInMacau (赞：12)

## $P2700$ 逐个击破
---

### 前置知识
&ensp;&ensp;&ensp;&ensp;克鲁斯卡尔最小生成树算法 并查集 贪心思想
   
### 题目描述
&ensp;&ensp;&ensp;&ensp;给出一颗带权的树，删除任意条边，求出使得给定的点不连通的最小权值。

  
### 解题思路

![sample](https://cdn.luogu.com.cn/upload/image_hosting/lkmbt5lm.png)  
&ensp;&ensp;&ensp;&ensp;样例说明：删除权值为$1$和$3$的边，使得$1.2.4$三点不连通，答案为$1 + 3 = 4$。


&ensp;&ensp;&ensp;&ensp;使删除的边总权值最小可以转化为使添加的边总权值最大。  
&ensp;&ensp;&ensp;&ensp;借鉴克鲁斯卡尔算法的基本思想：贪心地选取当前未被选过的权值最大的边，将其建入图内，直至所有的非指定点都被并入图内。  
&ensp;&ensp;&ensp;&ensp;统计出加入的边的权值，答案即为总边权 - 统计出的边权。
$$Ans = tot - cnt$$

### 注意事项
&ensp;&ensp;&ensp;&ensp;1.按边权从大到小排序。  
&ensp;&ensp;&ensp;&ensp;2.数据范围大，用 $long long$ 存变量。

```cpp
#include <bits/stdc++.h>
#define re register
#define il inline
#define ll long long
#define MAXN 100005
#define MAXM 100005
#define rep(i,a,b)  for(re int i = a;i <= b;++ i)
#define Rep(i,a,b)  for(re int i = a;i < b;++ i)
#define drep(i,a,b) for(re int i = a;i >= b;-- i)
#define fin(a)  freopen(#a".in","r",stdin)
#define fout(a) freopen(#a".out","w",stdout)

using namespace std;

struct edge{
    int u,v,w;
}e[MAXM];
int n,k;
int fa[MAXN];
bool p[MAXN];
ll ans = 0;

il bool cmp(edge a,edge b){
    return a.w > b.w;
}

il int find(int x){
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

il void kruskal(){
    Rep(i,1,n){
        int u = e[i].u,v = e[i].v,w = e[i].w;
        int fu = find(u),fv = find(v);
        if(p[fu] && p[fv])
            continue;
        
        fa[fu] = fv;
        ans -= w;

        if(p[fu])
            p[fv] = 1;
        else
            if(p[fv])
                p[fu] = 1;
    }
}



int main(){
    #ifndef ONLINE_JUDGE
    fin(2700);
    fout(2700);
    #endif

    scanf("%d%d",&n,&k);
    rep(i,1,n)
        fa[i] = i;
    rep(i,1,k){
        int point;
        scanf("%d",&point);
        p[point] = 1;
    }

    Rep(i,1,n){
        scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
        ans += e[i].w;
    }

    sort(e + 1,e + n + 1,cmp);
    kruskal();

    printf("%lld",ans);

    return 0;
}
```


---

## 作者：回青绝影 (赞：9)

WA~~~

见评测记录：
[NO.1](https://www.luogu.org/record/25268683)
[NO.2](https://www.luogu.org/record/25268727)

还有为什么我在交第二遍AC后，你谷显示只有90？！？

害得我以为long long没用——~~交了三遍~~
### 但是，不开long long 的确**见祖宗**

QAQ

------------

算了，不抱怨了，开始讲题；

首先看到这道题（啊，n个点n-1条边——是一棵树——所以就只要树上的算法就可以了！（~~原来以为是最大独立集~~，不只是我脑抽……））

然而，又想了想，发现和原来模拟赛做的题有点类似……就想到要并查集……反向做，就可以吧删边变成加边了呀！！！

great！

然后，还要满足删的边最便宜，就只要选贵的加就是了……

还是很水的………………


```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+1;
struct st{
    int x,y,z;
}a[N];
int f[N],ans,n,k;
bool l[N];
bool cmp(st a,st b){
    return a.z>b.z;
}
int find(int x){return (x==f[x])?x:find(f[x]);}
signed main(){
    scanf("%lld%lld",&n,&k);
    for (int i=1;i<=n;i++) f[i]=i;
    for (int x,i=1;i<=k;i++) scanf("%lld",&x),l[x]=1;
    for (int i=1;i<n;i++) scanf("%lld%lld%lld",&a[i].x,&a[i].y,&a[i].z),ans+=a[i].z;
    sort(a+1,a+1+n,cmp);
    for (int i=1;i<n;i++){
        int x=find(a[i].x),y=find(a[i].y);
        if (l[x]&&l[y]) continue;
        f[x]=y;
        ans-=a[i].z;
        l[x]=l[y]=l[x]|l[y];
    }
    printf("%lld",ans);
    return 0;
}
```
不，太水了……

---

## 作者：DZYO (赞：6)

考虑虚树加DP。

建出虚树，虚树上的每个边是原树上该路径的最小值。

记录dp[i][0/1]表示子树中不存在或者存在敌军点时断掉的边的最小代价。

那么分两种情况：

1.该虚树点原来是敌军点。

那么dp[i][0]=INF,dp[i][1]为sum（子节点min(dp存在敌军点加上断掉边,dp不存在敌军点)）。


2.该虚树点原来不是敌军点。

那么dp[i][0]=sum（子节点min(dp存在敌军点加上断掉边,dp不存在敌军点)）,dp[i][1]为dp[i][0]减去一条子树的贡献再加上该子树的存在敌军点的代价。


```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
inline int read(){
    char ch=getchar();int i=0,f=1;
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){i=(i<<1)+(i<<3)+ch-'0';ch=getchar();}
    return i*f;
}
const int Maxn=1e5+50;
int n,k,dfn[Maxn],mn[Maxn][20],fa[Maxn][20],dep[Maxn],sze[Maxn],ind;
int tot,vir[Maxn],isvir[Maxn],virfa[Maxn],isori[Maxn],virrt;
ll dp[Maxn][2];
const ll INF=0x3f3f3f3f3f3f3f3f;
vector< pair<int,int> >edge[Maxn],viredge[Maxn];

inline bool cmpdfn(const int &a,const int &b){return dfn[a]<dfn[b];}
inline void dfs(int now,int f,int dis){
    fa[now][0]=f;mn[now][0]=dis;dep[now]=dep[f]+1;sze[now]=1;dfn[now]=++ind;
    for(int i=1;i<=18;i++){
        fa[now][i]=fa[fa[now][i-1]][i-1];
        mn[now][i]=min(mn[now][i-1],mn[fa[now][i-1]][i-1]);
    }
    for(int e=edge[now].size()-1;e>=0;e--){
        int v=edge[now][e].first,w=edge[now][e].second;
        if(v==f)continue;
        dfs(v,now,w);sze[now]+=sze[v];
    }
}
inline int up(int x,int y){
    for(int t=0;t<=18;++t)
        if(y&(1<<t))x=fa[x][t];
    return x;
}
inline int getlca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    if(dep[x]>dep[y])x=up(x,dep[x]-dep[y]);
    if(x==y)return x;
    for(int i=18;i>=0;i--)
        if(fa[x][i]!=fa[y][i])
        x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
inline int getmn(int f,int x){
    int res=0x3f3f3f3f;
    for(int i=18;i>=0;i--){
        if(dep[fa[x][i]]>=dep[f]){
            res=min(res,mn[x][i]);
            x=fa[x][i];
        }
    }
    return res;
}
inline bool in(int x,int y){return dfn[y]>dfn[x]&&dfn[y]<dfn[x]+sze[x];}
inline void buildvir(){
    tot=k;sort(vir+1,vir+tot+1,cmpdfn);
    for(int i=1;i<k;i++){
        int lca=getlca(vir[i],vir[i+1]);
        if(!isvir[lca])vir[++tot]=lca,isvir[lca]=1;
    }
    sort(vir+1,vir+tot+1,cmpdfn);
    static int sta[Maxn],top;
    virrt=vir[1];
    for(int i=1;i<=tot;i++){
        while(top&&!in(sta[top],vir[i]))--top;
        if(i!=1)viredge[sta[top]].push_back(make_pair(vir[i],getmn(sta[top],vir[i])));
        sta[++top]=vir[i];
    }
}
inline void dfsvir(int now,int f){
    ll sum=0;
    for(int e=viredge[now].size()-1;e>=0;e--){
        int v=viredge[now][e].first,w=viredge[now][e].second;
        dfsvir(v,now);sum+=min(dp[v][0],dp[v][1]+w);
    }
    if(!isori[now]){
        dp[now][0]=sum;
        dp[now][1]=INF;
        for(int e=viredge[now].size()-1;e>=0;e--){
            int v=viredge[now][e].first,w=viredge[now][e].second;
            dp[now][1]=min(dp[now][1],sum-min(dp[v][0],dp[v][1]+w)+dp[v][1]);
        }
    }else{
        dp[now][1]=sum;
        dp[now][0]=INF;
    }
}
int main(){
    n=read(),k=read();
    for(int i=1;i<=k;i++)vir[i]=read()+1,isvir[vir[i]]=1,isori[vir[i]]=1;
    for(int i=1;i<n;i++){
        int x=read()+1,y=read()+1,w=read();
        edge[x].push_back(make_pair(y,w));
        edge[y].push_back(make_pair(x,w));
    }
    dfs(1,0,0);
    buildvir();
    dfsvir(virrt,0);
    cout<<min(dp[virrt][0],dp[virrt][1])<<'\n';
}
```

---

## 作者：redegg (赞：5)

切断$k$个点的联系只需要切$k-1$条边就够了。

我这$k-1$条边一定是分布在$k$个点构成的类似树形结构的任意两点路径上的。

贪心策略，我既然切的边数已经确定，然后我只需要知道怎么最少代价地切去$k-1$条边，形成$k$个连通块。

那么说到联通块，就想到并查集，我们可以反着把删边看做是添加剩余的边。

那么我们给联通块记录一下里面是否存在敌军窝点，然后从大到小加边，若此边连接的两个联通块都有敌军，我们就不加这条边（相当于删去这条边），边权需要从大到小枚举，因为删除的边数固定，并且要删的边均匀分布在任意两点之间，所以很容易发现删去某条的边不会干扰删去其他两节点之间的边，所以可以证明我们一定是使得添加的边的和最大，也就是删去的边的和最小。

```
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e5+10;
int n,k;
int pr[MAXN];
struct edge
{
    int u,e,v;
}a[MAXN];
long long sum;
bool vis[MAXN];
bool cmp(const edge &aa,const edge &bb)
{
    return aa.v>bb.v;
}

int findfa(int x)
{
    if(x==pr[x])return x;
    return pr[x]=findfa(pr[x]);
}

int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
        pr[i]=i;
    for(int i=1;i<=k;i++)
    {
        int x;scanf("%d",&x);
        vis[x]=1;
    }
    for(int i=1;i<n;i++)
        scanf("%d%d%d",&a[i].u,&a[i].e,&a[i].v),sum+=a[i].v;
    sort(a+1,a+n,cmp);
    for(int i=1;i<n;i++)
    {
        int fau=findfa(a[i].u);
        int fae=findfa(a[i].e);
        if(vis[fau]&&vis[fae])continue;
        vis[fau]|=vis[fae];
        vis[fae]|=vis[fau];
        pr[fau]=fae;
        sum-=a[i].v;
    }
    printf("%lld\n",sum);
    return 0;
}

```


---

## 作者：王小宇 (赞：4)

## 来发一个并查集题解

前面的几个题解其实已经挺清楚的了，我再来说一下吧。

这个题是我做的第一道有关于删边的并查集，我的第一反应是先把边建立起来，再按照要求去删掉。但一想，这样操作会很麻烦，而且说不好还会TLE OR MLE。

然后旁边的学长说，这种题应该反过来做。嗯，那就反过来做吧。

既然求的是最少需要耗费多少花费多少代价来删边，而又知道了所有边的代价，那么我们可以求建边的最大代价，再用所有的代价减去它，得出来的不就相当于删边的最小代价了吗。

而我们建边的时候要注意的是，题目要求所有敌人的据点不能连通，所以合并的时候不能让两个点在分别都属于敌人据点的情况下再合并。

需要注意的是，当一个敌人据点加入到一个并查集里面时，这个并查集里面所有的据点都会变成敌人据点。

那么，先按照道路的代价从小到大排个序，再建边就好了。

```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
#include<math.h>
#include<cstdio>
#include<queue>
using namespace std;
struct kkk{
    int father;
    bool size;//true代表被占领 false代表未被占领 
}node[100010];
int n,k,now;
long long ans,all,used;
struct www{
    int to,length,from;
}edge[200010];
void add(int a,int b,int c)
{
    now++;
    edge[now].length=c;
    edge[now].from=a;
    edge[now].to=b;
}//存边操作
bool cmp(www a,www b)
{
    return a.length>b.length;
}
bool judge(int a,int b)
{
    if ((node[a].size==true)&&(node[b].size==true)) return true;//如果两个城市都是敌人的返回true
    else return false; //否则返回false
}
int getfather(int x)//找根节点，以及压缩路径
{
    if (node[x].father==x) return x;
    node[x].father=getfather(node[x].father);
    return node[x].father;
}
void merge(int u,int v)
{
    node[v].father=u;//把祖先挂上去
    if (node[v].size==true) node[u].size=true;
    else if (node[u].size==true) node[v].size=true;//如果这两个点有一个是敌人的城市，那么与之合并的另一个也要成为敌人的城市
}
int main()
{
    int i,a,b,c,u,v;
    scanf("%d%d",&n,&k);
    for (i=0;i<=n;i++)
    {
        node[i].father=i;
        node[i].size=false;
    }//初始化，注意，城市是从0开始的
    for (i=1;i<=k;i++)
    {
        scanf("%d",&a);
        node[a].size=true;
    }//把敌人城市标记
    for (i=1;i<=n-1;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
        all=all+c;
    }//读入边，还有计算所有边的总代价
    sort(edge+1,edge+n,cmp);//按边的代价从大到小排序
    for (i=1;i<=n-1;i++) 
    {
        u=getfather(edge[i].from);
        v=getfather(edge[i].to);//得出边的两边的城市的并查集的根节点
        if (judge(u,v)==false)//判断，如果两个点不是全都是敌人的城市，那么合并
        {
            merge(u,v);//合并
            used=used+edge[i].length;//建边的代价增加
        }    
    }
    ans=all-used;//那么，最后的答案便是总代价减去建边的最大代价了
    printf("%lld\n",ans);
    return 0;
}
```
哦哦，对了，有一个点会卡int，所以记录答案的时候要用long long。

这应该是luogu里面最简单的一道删边的并查集了吧。


---

## 作者：OvO_ (赞：3)

**目测最快（80ms）**

考虑贪心Ｏ(n+m)

对于一个点

type1：如果它是被占领的话，就要把下面相邻的（第一个）所有的被占领的城市与它之间路径中的最小值砍掉。

type2：否则，可以保留当前最小值最大的一个点，传到上面继续取min，把其它的都砍掉。

就可以了。－－－－－－有注释






```cpp
#include<cstdio>
#include<algorithm>
#define N 100001
#define M 200001
#define For(a, b, c) for(int a = b; a <= c; ++a)
using namespace std;
typedef long long LL;
int e, be[N], to[M], ne[M], w[M];
inline void Add(int u, int v, int s){
    to[++e] = v, ne[e] = be[u], be[u] = e, w[e] = s;
}
LL ans;
bool p[N];
inline int Dfs(int x, int fa){　　　／／深搜int型，传子树中最小值最大的一条路（其余的都被砍掉了）
    LL res = 0, mx = 0, u;
    for(int i = be[x]; i; i = ne[i]){
        int v = to[i];
        if(v == fa) continue ;
        u = min(Dfs(v, x), w[i]);
        res += u, mx = max(mx, u);　　／／记录总和，最大值
    }
    ans += res;
    if(p[x]) return 1e9;　　　／／ｔｙｐｅ１
    ans -= mx; return mx;　／／ｔｙｐｅ２
}
int main (){
#ifndef ONLINE_JUDGE
    freopen("pro.in", "r", stdin);
    freopen("pro.out","w",stdout);
#endif
    int n, k;
    scanf("%d%d", &n, &k);
    For(i, 1, k){
        int v;
        scanf("%d", &v);
        p[v] = 1;
    }
    For(i, 1, n - 1){
        int u, v, s;
        scanf("%d%d%d", &u, &v, &s);
        Add(u, v, s), Add(v, u, s);
    }
    Dfs(0, -1);
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：abandentsky (赞：2)

题意：很明确，给你给了一棵树，让你删去权值和最小的边，使得给定节点之间不再连通。
思路：这个题目一定要发个题解，坑死我了。记住了，计算和一定来Long Long，不然第三个点一定死。想法和下面的大佬一样，既然要求删除边权和最小的。那么图中保留的就一定是最大的，或者我们尽可能的去添加边，然后使得任意两个集合之间不满足这样的情况。听上去是不是有点像最小生成树的样子，没错，这个应该是最大生成树，不一样在并查集的使用，这里不能随意的指向父节点，（我第一次就wrong在这个敌方）。要尽可能的指向题目给出的点。对于一条边，我们int xx=Find(u),int yy=Find(v);如果u和v都是题目中给出的要求节点，不好意思，这条边我们不能加入。如果u是题目中要求的，而v不是，那么我们让v的父节点为u。同理处理另一种。如果u和v都不是，那就随便做父节点。总和减去加入的边就是答案了。代码写的很清楚自己看：
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 100100
#define maxnode 2000005
#define sigma_size 26
#define md 12345678
#define INF 0x3f3f3f3f
using namespace std;
typedef long long LL;

int n,m;
LL sum;
set<int> P;
int fa[MAXN];
struct Edge
{
    int from,to;
    LL dist;
    Edge(int from=0,int to=0,LL dist=0):from(from),to(to),dist(dist){};
    bool operator < (const Edge& rah) const
    {
        return dist<rah.dist;
    }
};

int Find(int x)
{
    return fa[x]==x?x:fa[x]=Find(fa[x]);
}

int main()
{
    sum=0;
    scanf("%d %d",&n,&m);
    int tg;
    for(int i=1;i<=m;i++)                                                   //使用一个set来查看存不存在不能连接的点
    {
        scanf("%d",&tg);
        P.insert(tg);
    }
    priority_queue<Edge> Q;                                         //堆优化
    int u,v;
    LL w;
    for(int i=1;i<n;i++)                                                         //读入边
    {
        scanf("%d %d %lld",&u,&v,&w);
        Q.push({u,v,w});
        sum+=w;
    }
    for(int i=0;i<=n;i++)                                                       //初始化并查集
        fa[i]=i;
    LL ans=0;
    while(!Q.empty())
    {
        Edge e=Q.top();
        Q.pop();
        int xx=Find(e.from);
        int yy=Find(e.to);
        if(P.count(xx)&&P.count(yy))                               //发生了矛盾，也就是说这条边让两个本不该在一起的在一起了
            continue;
        else if(P.count(xx)&&!P.count(yy))                    //有一个是给出的，所以我们指向这个给出的
            fa[yy]=xx;
        else if(!P.count(xx)&&P.count(yy))                    //有一个是给出的，所以我们指向这个给出的
            fa[xx]=yy;
        else if(!P.count(xx)&&!P.count(yy))                   //两个都不是给出的，所以我们随便连接，随便当父节点
            fa[xx]=yy;
        ans+=e.dist;                                                                //将边权累加进去
    }
    printf("%lld\n",sum-ans);
    return 0;
}

```


---

## 作者：tswdfop233 (赞：2)

考虑 Dp

设计状态:

Tre[i]表示使得子树i中有一个(>1必然不合法)关键点与i联通的最小费用

Fal[i]表示使得子树i中无关键点与i联通

若i为关键点Fal[i]=INF

状态出来了,方程只要分类讨论一下就好了

显然如下

Tre[i]=min(Tre[i]+Tre[son]+i->w,Tre[i]+Fal[son],Fal[i]+Tre[son])

Fal[i]=min(Fal[i]+Tre[son]+i->w,Fal[i]+Fal[son])

代码自己翻提交记录吧


---

## 作者：Created_equal1 (赞：2)

直接考虑原问题比较困难，我们可以这么想：删去的最少=留下来的最多。

那么我们考虑用类似于最小生成树的思想。在使用Kruskal算法时，并查集还要保存一个是否已经有敌人的城市。然后合并的时候必须要两个集合不是都有敌人的城市（最多只有一个集合有敌人的城市）才可以合并。

具体看代码。

```cpp


#include <cstdio>
#include <algorithm>

using namespace std;

const int Max_N(100050);
const int Max_M(100050);

void Get_Val(int &Ret)
{
    Ret = 0;
    char ch;
    while ((ch = getchar()), (ch > '9' || ch < '0'))
        ;
    do
    {
        (Ret *= 10) += ch - '0';
    }
    while ((ch = getchar()), (ch >= '0' && ch <= '9'));
}

int N;
bool Occupation[Max_N];

struct edge
{
    int u, v;
    int w;
};

inline
bool comp(const edge &a, const edge &b)
{
    return a.w > b.w;
}

edge Edges[Max_M];

int Father[Max_N];
bool Have[Max_N];

long long int Ans;

void init()
{
    int K, Value;
    Get_Val(N), Get_Val(K);
    while (K--)
        Get_Val(Value), Occupation[Value] = true;
    for (int i = 0;i != N;++i)
        Father[i] = i, Have[i] = Occupation[i];
    for (int i = 1;i != N;++i)
        Get_Val(Edges[i].u), Get_Val(Edges[i].v), Get_Val(Edges[i].w), Ans += Edges[i].w;
}

int Get_Father(const int &x)
{
    return Father[x] == x ? x : Father[x] = Get_Father(Father[x]);
}

void Kruskal()
{
    int x, y;
    sort(Edges + 1, Edges + N, comp);
    for (int i = 1;i != N;++i)
    {
        x = Get_Father(Edges[i].u), y = Get_Father(Edges[i].v);
        if (x != y && (!(Have[x] && Have[y])))
        {
            Father[y] = x;
            Have[x] = (Have[x] || Have[y]);
            Ans -= Edges[i].w;
        }
    }
    printf("%lld", Ans);
}

int main()
{
    init();
    Kruskal();
    return 0;
}

```

---

## 作者：罗旅洲 (赞：2)

/\*
**目测更快（64ms）,比楼下快了20%**

**做法**

用num[x]数组表示x的子树内与x节点相邻的军团数量,注意是子树内.初始时把所有军团所在的节点num值为1.在回溯时,显然有

num[x]+=num[son]

如果一个点的num值超过1时,就在此时必须删掉一些边,因为在上方删边不会再影响给点的子树.

如何删边?贪心.

用len[x]表示x往上走的路程中的最小边权,每次回溯时更新.

len[x]=min(len[x],w[i])

当一个点的num值超过了1时,如果当前点为军团,删除子树内所有军团连边,否则留下子树len值最大的,再删掉其他边,实现见代码,复杂度O(n+m)

\*/
```cpp
#include<bits/stdc++.h>
using namespace std;
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define pb push_back
const int maxx=1e5+5;
int read(){
    char x=getchar(); int u=0;
    while(!isdigit(x)) x=getchar();
    while(isdigit(x)) u=(u<<3)+(u<<1)+(x^48), x=getchar();
    return u;
}
int n,m,be[maxx],ne[maxx<<1],to[maxx<<1],w[maxx<<1],e=1;
int flag,rt,num[maxx],len[maxx];
long long ans=0;
bool gn[maxx];
void add(int x,int y,int z){
    to[++e]=y;
    ne[e]=be[x];
    be[x]=e;
    w[e]=z;
}
void dfs(int id,int fa=0){
    if(gn[id]) ++num[id];
    long long sum=0; int mx=0;
    for(int i=be[id];i!=-1;i=ne[i]){
        if(to[i]==fa) continue;
        dfs(to[i],id);
        if(num[to[i]]){
        len[to[i]]=min(len[to[i]],w[i]);
        sum+=1ll*len[to[i]];
        mx=max(len[to[i]],mx);
        }
    }
    if(!sum) return ;
    if(num[id])    ans+=sum;
    else{
        num[id]=1; len[id]=mx;
        ans+=sum-1ll*mx;
    }
}
int main(){
    int u,v,k;
    n=read(); m=read();
    For(i,0,n-1) be[i]=-1;
    For(i,1,m){    u=read(); gn[u]=1; }
    For(i,1,n-1){
        u=read(); v=read(); k=read();
        add(u,v,k); add(v,u,k);
    }
    memset(len,63,sizeof(len));
    dfs(0,0);
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：Doubeecat (赞：0)

> [P2700 逐个击破](https://www.luogu.com.cn/problem/P2700)
> 
> 一棵树上有 $k$ 个关键点，要求用最小的代价把这些点划分到不同连通块中。
> 
> $2 \leq k \leq n \leq 10^5$

## 解题思路

很巧妙的思维题。

首先一个很暴力的思路是，对于每个关键点求出与其他关键点的路径，然后进行树上差分，但是这样的复杂度是 $O(k^2 \log n)$ 的，而且非常难写。

我们可以从题面中观察出一些性质：

1. 对于 $k$ 个点，最多只需要 $k-1$ 条边就可以把他们划分开。

    证明十分显然，手玩一下就出来了。

2. 对于每个点所在的连通块来说，关键点与其他非关键点的连边并不影响答案

    因为每个连通块我们实际上只需要考虑这个关键点与其他关键点的连边，这个关键点与非关键点的连边并不重要。

这些性质看上去没什么用，似乎没办法了？我们还可以反向思考一下

划分到不同连通块，实际上相当于**把一个关键点与其他非关键点连通，并且不与其他关键点联通**，也就把删边转化为了加边。

结合性质 2，我们可以考虑一下贪心，把所有最大的并且不会导致两个关键点联通的边加上。

这让我们联想到了 Kruskal，于是，我们可以执行一个类似 Kruskal 的过程：

首先对所有边进行从大到小的排序，然后从大到小加边，每次加边的时候判断是否加上这条边就会有两关键点联通。如果可以加上，就从总边权减去当前边的边权（因为我们的目的是求让连通块断开的最小权值）这个过程用并查集可以很方便的维护。

于是我们就解决了这个问题，时间复杂度 $O(n \log n)$，瓶颈在于排序。

## 代码

```cpp

ll ans,k,p[N],n,f[N];
bool vis[N];

struct edge {
    int u,v,w;
    friend inline bool operator < (const edge & a,const edge &b) {
        return a.w > b.w;
    }
}edg[N];

int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}
bool merge(int x,int y) {
    int fx = find(x),fy = find(y);
    if (!vis[fx] || !vis[fy]) {//合并的时候判断两边是否全部都有点，如果有就不连了
        f[fx] = fy;
        if (vis[fy] == 1) vis[fx] = 1;
        else if (vis[fx] == 1) vis[fy] = 1;
        //把连通块中关系继承
        return 1;
    }
    return 0;
}

signed main() {
	read(n,k);
    for (int i = 1;i <= k;++i) {
        int x;read(x);vis[x] = 1;
    }
    for (int i = 1;i <= n;++i) f[i] = i;
    for (int i = 1;i < n;++i) {
        read(edg[i].u,edg[i].v,edg[i].w);ans += edg[i].w;
    }
    sort(edg+1,edg+n);
    for (int i = 1;i < n;++i) {
        edge e = edg[i];
        int u = e.u,v = e.v;
        if (merge(u,v)) ans -= e.w;
        //如果有边连就扣去
    }
    printf("%lld",ans);
	return 0;
}
```

---

## 作者：圣光天子 (赞：0)

N个点，N-1条边的连通图，那么很显然就是一棵树(~~但好像题目没有写是连通图来着~~)


------------------
~~因为我比较菜~~，所以并没有想到生成树和树形DP之类的。为什么不用人见人爱的万能算法——DFS呢！

大概思路就是从0号结点开始，往下进行先序遍历，记录每个子树中第一个遍历到的enemy以及到这个enemy路径中最小的那一条边。当找到两个enemy时，就cut掉更小的那一条路径。

emm实在不行就看代码吧。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

#define N 100005
#define M 100005

int n,m,k,i,j,l,r,x,cou;
long long ans;
int first[N],next[2*M],a[2*M],c[2*M];
int near1[N],near2[N],h[N];

int dfs(int now,int last)
{
    int i,j;
    int min1,min2,gg;
    //初始化 
    min1=10000000; min2=10000000;//我只存了最近两个enemy的状态 
    near1[now]=0; near2[now]=0;
 
    for (i=first[now]; i>0; i=next[i])
    {
        if (a[i]==last) continue;
        
        gg=dfs(a[i],now);
        if (gg>c[i]) min2=c[i];
        else min2=gg;
        if (near1[now]==0) {
            near1[now]=near2[now];
            near2[now]=0;
        }
        //存储返回值 
		if ((min1==10000000)&&(near1[now])) min1=min2;
		
        if ((near1[now]>0)&&(near2[now]>0)) //如果找到了两个标记点
        { 
            if (min1<=min2) {
                ans=ans+(long long)min1; 
                near1[now]=near2[now];
                near2[now]=0;
                min1=min2;
            }
            else
            {
                ans=ans+(long long) min2;
                near2[now]=0;
            }
        }
    }
    if (h[now]) {//根结点是enemy的时候要把底下的enemy全cut掉 
        near2[last]=now;
        if (near1[now]>0)
        ans=ans+(long long)min1;
        return 10000000;
    }
    if (near1[now]==0) return 10000000;
    if (near1[now]>0) near2[last]=near1[now];
    return min1;
}

int main(){
    scanf("%d%d",&n,&k);
    for (i=1; i<=n; i++) h[i]=0;
    for (i=1; i<=k; i++)
    {
        scanf("%d",&x);
        x++;//我嫌麻烦就把结点序号全加一了woc 
        h[x]=1;
    }
    cou=0;
    for (i=1; i<=n-1; i++)
    {
        scanf("%d%d%d",&l,&r,&x);
        l++; r++;
        cou++;
        next[cou]=first[l];
        a[cou]=r; c[cou]=x;
        first[l]=cou;
        cou++;
        next[cou]=first[r];
        a[cou]=l; c[cou]=x;
        first[r]=cou;
        //邻接表应该会吧 
    }
    ans=0;
    dfs(1,0);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Mychael (赞：0)

一般的拆路连通性问题都可以用并查集


核心思想是：反推建边


先令所有道路摧毁，再按大到小修建两个不都是敌人的节点

注意：如果一个正常节点连接上了敌人节点，那么这个正常节点也变为敌人节点


统计权值最后用总权值减去连了的权值就好





```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define LL long long int
using namespace std;
const int maxn=100005;
bool evil[maxn];
int pre[maxn];
int find(int x)
{
    int root=x;
    while(root!=pre[root]) root=pre[root];
    int temp;
    while(x!=pre[x])
    {
        temp=x;
        x=pre[x];
        pre[temp]=root;
    }
    return root;
}
int read()
{
    int out=0;
    char c=getchar();
    while(c<48||c>57) c=getchar();
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out;
}
int nedge=0;
```
class EDGE
{
public:



```cpp
        int a,b,w;
        EDGE(int x,int y,int z): a(x),b(y),w(z) {}
        EDGE() {}
}edge[maxn];
inline bool operator <(const EDGE& a,const EDGE& b)
{
    return a.w>b.w;
}
int main()
{
    fill(evil,evil+maxn,false);
    int N=read(),K=read(),a,b,w;
    LL ans=0,tot=0;
    for(int i=0;i<N;i++) pre[i]=i;
    while(K--) evil[read()]=true;
    for(int i=1;i<N;i++)
    {
        a=read();
        b=read();
        tot+=w=read();
        edge[nedge++]=EDGE(a,b,w);
    }
    sort(edge,edge+nedge);
    int fa,fb;
    for(int i=0;i<nedge;i++)
    {
        fa=find(edge[i].a);
        fb=find(edge[i].b);
        if(evil[fa]&&evil[fb]) continue;
        pre[fa]=fb;
        ans+=edge[i].w;
        if(evil[fa]) evil[fb]=true;
    }
    cout<<tot-ans<<endl;
    return 0;
}

```

---


# 刻录光盘

## 题目描述

在JSOI2005夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？！

组委会把这个难题交给了LHC，LHC分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！

可是，LHC调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们JSOI宣扬的团队合作精神格格不入！！！

现在假设总共有N个营员（2<=N<=200），每个营员的编号为1~N。LHC给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。

现在，请你编写一个程序，根据回收上来的调查表，帮助LHC计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？


## 样例 #1

### 输入

```
5
2 3 4 0
4 5 0
0
0
1 0```

### 输出

```
1```

# 题解

## 作者：PrincessYR✨～ (赞：160)

# 这是一个漫（jian）长（nan）的过程

请大家耐心读完，相信你一定能学会

首先来介绍一下强连通分量
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823090301810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

神奇海螺指引你：

> 有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。——百度百科
> 

Tarjan是基于迪法师（DFS）的一种算法，可以说是一种流（du）批（liu）的操作，本蒟蒻苦哈哈的学了好几天才学会强连通分量和缩点；

在这里推荐给大家几道题：[受欢迎的牛](https://www.luogu.com.cn/problem/P2341)，[消息扩散](https://www.luogu.com.cn/problem/P2002)；
这些题我会在后期的博客中进行详细的讲解

步入正轨：
## 图中｛6｝是第一个被发现的强连通分量，其次是｛5｝，最后被发现的是｛3，4，1，2｝*（顺序无所谓）*

![图丑勿喷](https://img-blog.csdnimg.cn/20200226074807157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rmc2RzZGFzYQ==,size_16,color_FFFFFF,t_70)

Tarjan算法是解决强连通分量和缩点问题的一种比较常见的方法

接下来开始????一步一步的
首先给你一个图（求其中的强连通分量）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091129601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

在这里我们假设从点1开始遍历，并且将访问的点压入栈中


在进行操作之前，我们要明确Tarjan中的两个至关重要的数组：DFN和LOW；

DFN[x]：表示这个点x几次被遍历到；

LOW[x]：表示点x或点x的子树能够追溯到的最早的栈中节点的次序号；

即LOW[x]=min{LOW[x]，LOW[next]}；

其中next为x的子节点；

接下来，我们来一步一步的找；

### 第一遍从1直接一直遍历到6，另访问到的点的初始low和dfn都为num++;num为计数器；

但当我们遍历到6是发现6没有子节点了，所以low[6]=dfn[6]=4;发现一个强连通分量｛6｝，6出栈；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091319822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

退回到5，low[5]=min(low[5],low[6]);

low[6]=4;而low[5]=dfn[5]=3;

所以low[5]=3；

low[5]=dfn[5];所以5也是一个强连通分量；5出栈；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091329523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

返回3发现3有子节点4，搜索4，并且4入栈；发现4也有子节点，6已经为强连通分量且不再栈中，跳过；

遍历1，发现一在栈中且已经被访问过，那么4值得被发现；

所以low[4]=min(low[4],dfn[1]);所以low[4]=1；

4遍历完，又因为dfn[4]!=low[4],所以4不退站；回到3，low[3]=min(low[3],low[4]);

所以low[3]=1;3访问完，又因为dfn[3]!=low[3],所以3不退站；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091337456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

回到1，发现1还有子节点2，2入栈；发现2的子节点4已经被访问且在栈中，所以low[2]=min(dfn[4],low[2]);

所以low[2]=5;访问完2，回到一，发现low[1]=dfn[1];所以将栈中的所有点出栈，并且这些点为一个强连通分量；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091346286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

至此，所有点已经都被访问，算法结束。

时间复杂度为O(N+M)；


------------

下面插上tarjan伪代码：
```
void tarjan(int now)
{
	dfn[now]=low[now]=++num;
	atack.push(now);
	inst[now]=true;
	for(int i=0;i<map[now].size();i++)
	{
		int next=map[now][i];
		if(dfn[next]==0)
		{
			tarjan(next);
		    low[now]=min(low[now],low[next]);
		}else if(inst[next]==1)
	    {
		low[now]=min(low[now],dfn[next]);
	    }
	}
	if(dfn[now]==low[now])
	{
		numb++;
		int q;
		do
		{
			q=atack.top();
			inst[q]=0;
			atack.pop();
			bl[q]=numb;
			nums[numb]++;
		}while(q!=now);
	}
}
                                      
```

下面我们再来看这道题：

他让我们求最少发几个：

![](https://cdn.luogu.com.cn/upload/image_hosting/qf0io37r.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们可已看出一个联通图中我们只需要在最开始的点给一个，那么它就会一直传到最底部；

即一个连通图只需要一个。那么问题就转化为找有几个连通图。那么我们可以找有几个入边为零的点即可。

```
#include<iostream>
#include<cstdio>
#include<vector>
#include<stack>
#define si 205
using namespace std;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int n,a,tot,num,bl[si],ru[si],nums[si],numb,dfn[si],low[si],ins[si];
vector<int> map[si];
stack<int> st;
void tarjan(int x)
{
	dfn[x]=low[x]=++num;
	ins[x]=1;
	st.push(x);
	for(int i=0;i<map[x].size();i++)
	{
		int q=map[x][i];
		if(dfn[q]==0)
		{
			tarjan(q);
			low[x]=min(low[x],low[q]);
		}else if(ins[q]==1)
		{
			low[x]=min(low[x],dfn[q]);
		}
	}
	if(dfn[x]==low[x])
	{
		numb++;
		int p;
		do
		{
			p=st.top();
		    st.pop();
		    ins[p]=0;
		    bl[p]=numb;
		    nums[numb]++;
		}while(x!=p);
	}
}
int main()
{
	n=read();
	a=1;
	for(int i=1;i<=n;i++)
	{
		while(a!=0)
		{
			a=read();
			if(a==0)
			continue;
			map[i].push_back(a);
		}
		a=1;
	}
	for(int i=1;i<=n;i++)
	{
		if(dfn[i]==0)
		{
			tarjan(i);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<map[i].size();j++)
		{
			int next=map[i][j];
			if(bl[i]!=bl[next])
			{
				ru[bl[next]]++;
			}
		}
	}
	for(int i=1;i<=numb;i++)
	{
		if(ru[i]==0)
		tot++;
	}
	cout<<tot;
	return 0;
}
```


写一篇文章不容易，可否来个赞????。



---

## 作者：LMB_001 (赞：99)

本题一开始我想用并查集，但普通的并查集是双向的，但本题是单向，用Floyd，在下不才，Pascal转c++刚一个星期，把Pascal的基础代入c++，特发一个c++帖，求大家不喜勿喷

```cpp
#include <bits/stdc++.h>
using namespace std;  
int mapk[210][210],f[210];  //mapk表示一个人愿不愿意给另外一个人拷贝，也可以用布尔型，f表示一个人的父亲节点是哪个人
int main()  
{  
    int n,i,j,k,x;  
    while(cin >> n)  
    {  
        memset(mapk,0,sizeof(mapk));  //初始化
        for(i=1;i<=n;i++)  
            while(scanf("%d",&x),x)  //读入
               mapk[i][x]=1;  //表示第i个人愿意给第x个人拷贝
        for(k=1;k<=n;k++)  
            for(i=1;i<=n;i++)  
                for(j=1;j<=n;j++)  
                if(mapk[i][k]&&mapk[k][j])  
                    mapk[i][j]=1;//如果第i个人愿意给第k个人，而第k个人又愿意给第j个人，就相当于第i个人愿意给第j个人
       for(i=1;i<=n;i++)  
           f[i]=i;  //一开始，每个人的父亲节点就是自己
           for(i=1;i<=n;i++)  
            for(j=1;j<=n;j++)  
           if(mapk[i][j]) f[j]=f[i];  //如果i愿意给j拷贝，那么i的父亲节点就是j的父亲节点，注意别搞反了！
       int s=0;  
       for(i=1;i<=n;i++)  
           if(f[i]==i) s++;  //最后用循环扫一遍，如果i的父亲节点就是自己本身的话，计数器加一
        cout<<s<<endl;  //最后输出
    }  
    return 0;  
}  
大家注意看懂了再抄，不然还是不懂，我也思考了很久滴
```

---

## 作者：elephant_ouo (赞：19)

Floyed真好用！
```cpp
#include <bits/stdc++.h>

using namespace std;

int fa[201], tot = 0, x, n;										//fa[i]表示i在并查集中的爸爸 
bool f[201][201];												//用邻接矩阵储存这张图，f[i][j]表示是否存在i -> j这条边  
int main()
{
	cin >> n ;
	
	for(int i = 1; i <= n; i++)
		fa[i] = i;												//初始化，把每个结点的爸爸设为自己 
		for(int i = 1; i <= n; i++)
		{
			while(cin >> x && x)
				f[i][x] = true;									//邻接矩阵存图，i -> x连一条有向边 
		}														//f[i][j]的意义表示i -> j是否有路径可达，则只有i得到了资料，j也能得到资料 
		for(int k = 1; k <= n; k++)
			for(int i = 1; i <= n; i++)
				for(int j = 1; j <= n; j++)
					f[i][j] = f[i][j] || f[i][k] && f[k][j];	//利用Floyed的变形，求出f[i][j] 
					for(int i = 1; i <= n; i++)
						for(int j = 1; j <= n; j++)
							if(f[i][j])							//如果i -> j可行，则i有资料，j也能得到，j有不用刻录光盘	
								fa[j] = fa[i];
								/*但出现独立的环时，环里面又必须有一个人要刻录光盘，则用fa[j]=fa[i]就能巧妙的解决这种情况 
								因为总有一个人的fa[i]会最后传给它自己，使fa[i]==i*/ 
								for(int i = 1; i <= n; i++)
									if(fa[i] == i)
										tot++;					//如果i没有其它的爸爸，那么i必须刻录光盘，tot++ 
										cout << tot << endl;	//输出 
										
										return 0; 
		                                                                       
}
```
点个赞呗

---

## 作者：20140408abcd (赞：13)

居然没人来写DFS，~~让就我来水一波~~

我的思路很简单，如果说你愿意给我拷贝，那好人做到底，替我给我愿意给的人拷贝。具体方法见代码，讲很详细了。
```
#include<iostream>
using namespace std;
int a[201][201];//偷懒不打链表
int b[201];//存每一个人的负责人
int n,x,y,tot;
int i;//开全局变量节省内存
int dfs(int j)
{
    if(b[j]==i)return 0;
    //若这人由自己负责，那么他负责的人之前也归自己负责，没必要走下去了
    b[j]=i;//改成自己负责
	for(int k=1;k<=a[j][0];k++)
	dfs(a[j][k]);//为间接被自己负责的负责
}
int main()
{
	cin>>n;
	for(i=1;i<=n;++i)
	{
    	while(cin>>x)
    	{
    		if(x==0)break;
    		a[i][++a[i][0]]=x;//建一条i到x的边
		}
	}
	for(i=1;i<=n;i++)
	if(b[i]==0)//若没人替他拷贝
    dfs(i);//帮自己和自己直接或间接愿意拷贝的人拷贝
	for(i=1;i<=n;i++)
	if(b[i]==i)tot++;//若他的负责人是自己，自己就要拿光盘
	cout<<tot;
}
```

---

## 作者：hongzy (赞：13)

### 并查集

把并查集改一改，合并操作略有变化.改成“单向并查集”.

这里用i是j的父亲表示i愿意把光盘分享给j

如果x愿意把光盘分享给y，就合并x的根和y本身，可以这么理解：x的根分享给x，x再分享给y

原始并查集是合并x、y的根，这里不能这么做，因为这么做即表示：x的根可以分享给y的根（然而并不是）

还有要用floyd转移关系

### 参考代码
```cpp
#include <iostream>
using namespace std;

int G[210][210];
int N, ans;

int f[210];   //父亲 
int ufs[210]; //结点是否为并查集的根 

int Find(int x) {
	while(x != f[x]) x = f[x];
	return x;
}

void Unite(int x, int y) {
	while(x != f[x]) x = f[x];　//找到x的根
	f[y] = x; //x是y的父亲
} 

int main() {
	int tmp;  
	cin >> N;
	for(int i=1; i<=N; i++) f[i] = i; //并查集初始化 
	for(int i=1; i<=N; i++) {
		while(true) {
			cin >> tmp;
			if(!tmp) break;
			G[i][tmp] = true;
		}
	}
	for(int k=1; k<=N; k++) //Floyd
		for(int i=1; i<=N; i++)
			for(int j=1; j<=N; j++)
				G[i][j] = G[i][j] || (G[i][k] && G[k][j]);
	for(int i=1; i<=N; i++)
		for(int j=1; j<=N; j++)
			if(G[i][j]) Unite(i, j);
	for(int i=1; i<=N; i++) ufs[Find(i)] = 1;
	for(int i=1; i<=N; i++) if(ufs[i]) ans ++;
	cout << ans << endl; 
	return 0;
}
```


---

## 作者：the_writer (赞：8)

emmm，这是一道Tarjan的模板题

代码量相对较少

缩点判断入度为零

~~代码并没有看到要判重？？？~~

不过用边表还是很方便的

```cpp
#include<bits/stdc++.h>
#define maxn 200+5
#define maxm 40000+500
using namespace std;
int Head[maxn],V[maxm],Next[maxm],tot=0;
int In[maxn],Belong[maxn],Dfn[maxn],Low[maxn],Time,cnt,inq[maxn];
stack<int>q;
int N;
void Add(int u,int v){
	V[++tot]=v;
	Next[tot]=Head[u];
	Head[u]=tot;
}
void Tarjan(int u){
	int i,v,tmp;
	Dfn[u]=Low[u]=++Time;
	q.push(u);inq[u]=1;
	for(i=Head[u];i;i=Next[i]){
		v=V[i];
		if(!Dfn[v]){
			Tarjan(v);
			Low[u]=min(Low[u],Low[v]);
		}
		else if(inq[v])Low[u]=min(Low[u],Dfn[v]);
	}
	if(Dfn[u]==Low[u]){
		cnt++;
		do{
			tmp=q.top();q.pop();inq[tmp]=0;
			Belong[tmp]=cnt;
		}while(tmp!=u);
	}
}
int main(){
	int i,u,v,ans=0;
	scanf("%d",&N);
	for(i=1;i<=N;i++)while(scanf("%d",&v)&&v)Add(i,v);
	for(i=1;i<=N;i++)if(!Dfn[i])Tarjan(i);
	for(u=1;u<=N;u++)
		for(i=Head[u];i;i=Next[i])
			if(Belong[u]!=Belong[V[i]])
				In[Belong[V[i]]]++;
	for(i=1;i<=cnt;i++)if(!In[i])ans++;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Atlicd (赞：7)

看到楼上的题解写的都是并查集，没有Tarjan的题解，~~我就来水一发~~  
首先解释一下这个算法：   
Tarjan算法求强联通分量

###概念
强联通分量：
说白了就是有向图里的一个环，  
其中的任何一个点都可以到达这个强联通分量里的另外的点，    
结合到这道题就是给这个环里的任何一个人资料，  
整个环里的人就有了资料  

###问题解答方案：
求解给定的图中的入度为零   
（也就是说没有办法从别的强联通分量中得到资料，但是可以给出去）  
的强联通分量

```

tarjan(u)
{
	DFN[u]=Low[u]=++Index  
  	 // 为节点u设定次序编号和Low初值
	Stack.push(u)
   	// 将节点u压入栈中
	for each (u, v) 
  	  in E
  	 // 枚举每一条边
	if (v is not visted)
  	 // 如果节点v未被访问过
		 tarjan(v)
   		   // 继续向下找
		 Low[u] = min(Low[u], Low[v])
		 else if (v in S)
   	  	 // 如果节点v还在栈内
		 Low[u] = min(Low[u], DFN[v])
		 if (DFN[u] == Low[u])
     	 // 如果节点u是强连通分量的根
		 repeat
		 v = S.pop
     	 // 将v退栈，为该强连通分量中一个顶点
		 print v
		 until (u== v)
}
```        

代码如下，码风清奇不要见怪 
```
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <stack>

using namespace std;

const int maxn = 205 ;
const int maxm = 40005 ;
	
int n,first[maxn],_time,cnt,tot,ans;
/*
解释一下：
_time是第几个被遍历到的，
cnt是第几个强联通分量 
*/
int dfn[maxn],low[maxn],belong[maxn],put[maxn];
/*
dfn[u]就是u点的时间戳，
low[u]是u或u的子树能够追溯到的最早的栈中节点的时间戳，
belong[u]是属于哪一个强联通分量，
put[i]是第i个强联通分量的入度 
*/		
bool judge[maxn];
//判断在不在栈里面 	
struct ctrl{
	int to , next ; 
}o[maxm];
//配合前面的first[]数组和tot构成链式前向星 

stack < int > s ; 
//用到的数据结构：栈 

inline void add ( int u , int v )
//链式前向星建边过程 
{
	o[++tot].next = first[u] ; 
	o[tot].to = v ;
	first[u] = tot ;
}

void tarjan(int u)
//Tarjan本质上也是个dfs 
{
	int v = 0;
	
	dfn[u] = low[u] = ++_time;
	//初始化，都设为当前时间戳 
	judge[u] = 1;
	s.push(u);
	//压栈 
	
	for(int i = first[u] ; i ; i = o[i].next)
	//用链式前向星遍历全部的边 
	{
		v = o[i].to;
		if(!dfn[v])
		//如果没有被遍历到 
		{
			tarjan(v);
			//先遍历这个点 
			low[u] = min(low[u] , low[v]);
			//回溯时更新low 
		}

		else if (judge[v])
		//如果这个点在栈里面 
			low[u] = min(low[u] , dfn[v]);
			//更新low的值，注意，要用dfn[v]而不是low[v] 
		}

		if(dfn[u] == low[u])
		//强联通分量中的最小时间戳 
		{
			++ cnt;
			do
			//因为是要先去栈顶元素再比较，所以用了do-while循环 
			{
				v = s.top();
				s.pop();
				judge[v] = 0;
				//退栈 
				belong[v] = cnt;
				//属于第几块 
			}while(v != u);//不要忘记分号 
		}
	}	
int main()
{
	scanf("%d",&n);
	for(int x = 1 , i = 1 ; i <= n ; ++ i)
		while( scanf("%d",&x) && x)
			add(i , x);
			//读入数据 
			
	for(int i=1 ; i <= n ; ++ i)
	//跑Tarjan函数 
		if( !dfn[i])
			tarjan(i);
					
	for(int u = 1 ; u <= n ; ++ u)
		for(int i = first[u] ; i ; i = o[i].next)
		//遍历每一条边 
		if(belong[u] != belong[o[i].to])
		//强联通分量的入度++ 
			++ put[belong[o[i].to]];
	
	for(int i = 1 ; i <= cnt ; ++ i)
		if(!put[i])
	//统计入度为0的边 
	++ans;		
						
	printf("%d\n" , ans);
	//输出
		
	return ~~ (0-0) ;//撒花结尾 
}
```
建议大家做一做P2341受欢迎的牛，和这道题是一类的题目 

---

## 作者：King丨帝御威 (赞：6)



###  _------------
我用的是纯并查集做的，先让自己是自己的爹，然后标记白点，到最后再查看谁的爹是自己就ok了，欧耶！程序拜拜！ __ 
_  _
```cpp
#include<iostream>
#include<cstdio>
#define X 200+10
using namespace std;
int fa[X];
bool vis[X][X];              //用来标记白点
int main()
{
	int n,t,ans=0;
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>t;
		while(t!=0)
		{
			vis[i][t]=1;      
			cin>>t;
		}
	}
	for(int i=1;i<=n;++i)
	fa[i]=i;                 //并查集，让自己是自己爸爸
	for(int k=1;k<=n;++k)
	for(int i=1;i<=n;++i)
	for(int j=1;j<=n;++j)
		if(vis[i][j]||(vis[i][k]&&vis[k][j]))
		  vis[i][j]=1;              //标记白点
	for(int i=1;i<=n;++i)
	for(int j=1;j<=n;++j)
	if(vis[i][j]==1)
	fa[j]=fa[i];
	for(int i=1;i<=n;++i)
	if(fa[i]==i)
	ans++;                     //累加光盘数
	printf("%d",ans);
	return 0;                  //大功告成，程序拜拜！
}
```

---

## 作者：学无止境 (赞：4)

用floyed预处理，加上一些剪枝，强行DFS，竟然AC了 **92ms**

看到各位大佬的题解都是tarjan或者并查集，没学过这些东西的蒟蒻我瑟瑟发抖

在这里我分享我的DFS做法，用另一种的方法达到的类似缩点的效果（不完全一样）

直接DFS想必大家都会，先floyed处理各个人之间的连通情况，按照人的顺序搜索，每个人无非就两种情况————给他光盘、不给他光盘。并且持续更新当前获得资料的人，当全部获得资料时更新最优答案。

上面的好简单有木有QwQ 然而不加任何优化只过了3个点[难过]

原因很简单，复杂度太大，重复计算太多。

既然这道题不是很好记忆化，那么就思考剪枝：
```
一、搜到这个人的时候，如果他已经被之前的人分享了资料，那么跳过他不搜

（重要）二、floyed之后，如果有多个人与全局中**每一个人**的连通情况都相同，那么搜一个人就好，因为他们是等价的，多余的人就标记起来不进行搜索（详见代码中del[ ]数组）

三、搜索过程中，不要每次都遍历整个表判断两点是否相连，可以提前记录好每个点与那几个点连通，减小复杂度
```
发现，上面的第二条消去了很多消去了点，将多个点缩为一个，对于DFS，它起到了很大的作用（剪枝），这是 **#11 AC** 的关键 QaQ

上代码，注释个人感觉很详细了

**Code:**
```
#include<cstdio>
#include<iostream>
using namespace std;
int n,w[210][210],a,s,exist[210],num[210],g[210][210],ans=1000,del[210];
void dfs(int k,int tot,int f)//将要搜第 k 个人，已经有 tot 个人拷到了资料，此时已经刻了 f 张光盘 
{
	if(exist[k]||del[k])//exist[k]=1 说明之前已被添加,他不能使新的人获得资料，剪枝    
	{
		dfs(k+1,tot,f);//去掉del[k]=1的人不搜，剪枝(等价的人搜一个就好) 
		return;
	}
	if(tot==n)//保存最优答案 
	{
		ans=min(ans,f);
		return;
	}
	if(k==n+1)  return;  //所有人都搜完了 
	dfs(k+1,tot,f);//第一种情况，不给第 k 个人光盘 
	for(register int i=1;i<=num[k];i++)//处理第二种情况，给他光盘，将与之相关的人全部标记，新的人获得资料就计数 
	{
		if(!exist[g[k][i]])  tot++;
		exist[g[k][i]]++;
	}
	dfs(k+1,tot,f+1);//搜索第二种情况 
	for(register int i=1;i<=num[k];i++)//回溯 
	exist[g[k][i]]--;
}
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)//读入数据 
	{
		scanf("%d",&a);
		while(a!=0)
		w[i][a]=1,scanf("%d",&a);//相连就标记为 1 
	}
	for(int k=1;k<=n;k++)//floyed求各个人之间的连通情况，若相互连通则可以互相拷贝资料 
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
			w[i][j]=(w[i][j]||(w[i][k]&&w[k][j]));
	for(int i=1;i<=n;i++)  //自己获得光盘的话，自己就有了资料 
	w[i][i]=1;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	if(w[i][j])  g[i][++num[i]]=j;//减小之后搜索的复杂度，记录好相连的人，避免遍历整个表 
	for(int i=1;i<n;i++)//这里也是为了剪枝，如果两个人与 1~n 中**每一个人**的连通情况都相同 
	for(int j=i+1;j<=n;j++)//那么这两个人搜索一个即可，因为他们等价 
	{
		bool flag=false;
		if(del[i])   continue;
		for(int k=1;k<=n;k++)
		if(w[i][k]!=w[j][k])
		{
			flag=true;
			break;
		}
		if(!flag)  del[j]=1;//标记不用搜的人 
	}
	dfs(1,0,0);//快乐dfs 
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：mohei0 (赞：4)

完全不知道我用的是什么算法，只知道用了图诶（摊手）。

sort大法吼！

```cpp
    #include<iostream>
    #include<algorithm>
    using namespace std;
    int pic[202][202]={0},n,team[201]={0},s=0;//pic是邻接矩阵，pic[i][0]为可以找的人的总数，pic[i][201]为可以找这个人的的总数。
    //team是最后组委会发光盘的顺序。s是组委会发的光盘的总数。
    bool jyh[201]={0};//标记有无拷贝过光盘 。
    void dg(int k)//把所有与k相连的人拷贝一遍。
    {
        jyh[k]=1;//设为有拷贝过光盘
        for(int i=1;i<=n;i++)
            if(!jyh[i]&&pic[k][i]) dg(i);//当没有拷贝过且这个人会给他拷贝时就拷贝光盘，并把他所连的人也拷贝一次。
    }
    bool ss(int a,int b)//以可以找的人总数少优先，相同时以可以找这个人拷贝的人总数优先。
    {
        if(pic[a][0]!=pic[b][0]) return pic[a][0]<pic[b][0];
        else return pic[a][201]>pic[b][201];
    }
    int main()
    {
        cin>>n;
        for(int i=1,q;i<=n;i++)
        {
            team[i]=i;
            cin>>q;
            while(q!=0)
            {
                pic[i][q]=1;
                pic[q][0]++;
                pic[i][201]++;//从被拷贝人连向需要拷贝人，并把被连接总数与连接总数加一。
                cin>>q;
            }
        }
        sort(team+1,team+1+n,ss);//排序，排好组委会发光盘的顺序。
        for(int i=1;i<=n;i++)//最后遍历一遍
        {
            if(!jyh[team[i]])//当有找人拷贝过时，组委会不用给其拷贝。
            {
                s++;dg(team[i]);
            }
        }
        cout<<s<<endl;
}`
```

---

## 作者：远航之曲 (赞：3)

用tarjan缩点，再统计入度为0的点。。。注意判断环的情况

代码如下

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int head[20005],Next[2000005],to[2000005];
```
int dfn[20005],low[20005],stk[20005],instack[20005],belong[20005],ru[20005]；
```cpp
int n,x,y,ty,top,tot,cnt,ans;
void add(int x,int y)
{
    tot++;
    Next[tot]=head[x];
    to[tot]=y;
    head[x]=tot;
}
void tarjan(int k)
{
    dfn[k]=low[k]=++ty;
    stk[++top]=k;
    instack[k]=1;
    for(int i=head[k];i!=-1;i=Next[i]) 
    {
        int y=to[i];
        if(dfn[y]==0) 
        {
            tarjan(y);
            low[k]=min(low[k],low[y]);
        }
        else
        if(instack[y]==1) low[k]=min(low[k],dfn[y]);
    }
    if(dfn[k]==low[k]) 
    {
        cnt++;  
        int x;
        do
        {
            x=stk[top];
            belong[x]=cnt;
            instack[x]=0;
            top--;
        }
        while(x!=k);
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) head[i]=-1;
    for(int i=1;i<=n;i++) 
    {
        while(1) 
        {
            scanf("%d",&x);
            if(x==0) break;
            add(i,x);
        }
    }
    for(int i=1;i<=n;i++) 
    if(dfn[i]==0) tarjan(i);
    for(int i=1;i<=n;i++)   
    {
        for(int j=head[i];j!=-1;j=Next[j]) 
        {
            y=to[j];
            if(belong[y]!=belong[i]) ru[belong[y]]++; //不属于同一个缩点 
        }
    }
    for(int i=1;i<=cnt;i++) 
    if(ru[i]==0) ans++; //有几个入度为0的缩点（没人送他们光盘） 
    cout<<ans;
    return 0;
}
```

---

## 作者：Polaris_Dane (赞：2)

不明白为什么那么多人想到的是并查集，并查集用来做的都是双向边，这道题应该能够很快想到Tarjan缩点啊


------------
这种题都快成模板题了，下面几道都跟这道差不多

[P2002](https://www.luogu.org/problemnew/show/P2002)

[P2812](https://www.luogu.org/problemnew/show/P2812)

[P2746](https://www.luogu.org/problemnew/show/P2746)

其实大家都一样，换了几个包装罢了。

不会Tarjan的自动转移————缩点不会的，往下看


------------
假如我们已经Tarjan找到了所有的强连通分量，那么把原来的每一条边都进行枚举，如果两个端点不在同一强连通分量中，则在这两个分量中连一条边。这就叫缩点，可以将一个图转化为DAG（有向无环图），方便进行拓扑排序等工作，下面推荐几道题


------------
基础 就上面那几道
   [P3387](https://www.luogu.org/problemnew/show/P3387)
   [P2863](https://www.luogu.org/problemnew/show/P2863)
   [P2341](https://www.luogu.org/problemnew/show/P2341)

进阶 [P3225](https://www.luogu.org/problemnew/show/P3225)
	 [P1347](https://www.luogu.org/problemnew/show/P1347)


在一个强连通分量中，只要有一个人拿到光盘即可传递给分量中其他所有人，而光盘也可以从一个分量到另一个分量中，那我们要统计的就是入度为零的强连通分量的个数，因为他们的光盘不能从其它分量中得到，只能另给一个以满足要求。QAQ——讲解完毕！！！AC等待着你


------------
最后附上代码（Polaris最美了）
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<stack> 
#define M 101000
using namespace std;
vector<int>map[11000];
stack<int>c;
int indgr[M], dfn[M], low[M], vis[M], color[M], inf = 1, n, m, sum;
void dfs(int now)
{
    c.push(now);
    dfn[now] = inf;
    low[now] = inf;
    vis[now] = 1;
    inf++;
    for (int i = 0; i<int(map[now].size()); i++)
    {
        if (!dfn[map[now][i]])
        {
            dfs(map[now][i]);
            low[now] = min(low[now], low[map[now][i]]);
        }
        else if (vis[map[now][i]])
        {
            low[now] = min(low[now], low[map[now][i]]);
        }
    }
    if (dfn[now] == low[now])
    {
        sum++;
        color[now] = sum;
        vis[now] = 0;
        while (c.top() != now)
        {
            color[c.top()] = sum;
            vis[c.top()] = 0;
            c.pop();
        }
        c.pop();
    }
}
int main()
{
    scanf("%d", &n);
    int x[M], y[M],cnt=0;
    for (int i = 1; i <=n; i++)
    {
    	scanf("%d",&y[++cnt]);
        while(y[cnt]!=0)
        {
        	x[cnt]=i;
        	map[x[cnt]].push_back(y[cnt]);
        	scanf("%d",&y[++cnt]);
		}
		cnt--;
    }
    for (int ii = 1; ii <= n; ii++)
    {
        if (!dfn[ii])
        {
            dfs(ii);
        }
    }
    for (int i = 1; i <= n; i++)
    {
        map[i].clear();
    }
    for (int i = 1; i <= cnt; i++)
    {
        if (color[x[i]] != color[y[i]])
        {
            map[color[x[i]]].push_back(color[y[i]]);
            indgr[color[y[i]]]++;
        }
    }
    int ans1 = 0;
    for (int i = 1; i <= sum; i++)
    {
        if (!indgr[i])
        {
            ans1++;
        }
    }
    printf("%d", ans1);
    return 0;
}



```
![](http://img0.imgtn.bdimg.com/it/u=1792908990,1567041414&fm=26&gp=0.jpg)

---

## 作者：SNiFe (赞：1)

######这道题我最开始用的是拓扑排序（因为懒），只有90分，第一个点过不了，给大家看看拓扑排序代码，后面有正解：

###（如有dalao知道拓扑排序如何AC，请务必联系我，万分感谢，强迫症患者,请谅解）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int N=250000;
int fa[N],n,map[500+5][500+5],a,ans=0,rd[N],head[N],k=0,tot=0,flag;
struct node
{
    int to,next;
}edge[N*2];
void add(int u,int v)
{
    edge[++k].to=v;
    edge[k].next=head[u];
    head[u]=k;
}
bool vis[N],visit[N];
void top()
{
    queue<int>q;
    for(int i=1;i<=n;i++)
    if(!rd[i])
    {
        q.push(i);
        ans++;
        vis[i]=true;
    }
    while(!q.empty())
    {
        int x=q.front();q.pop();
        for(int i=head[x];i;i=edge[i].next)
        {
            rd[edge[i].to]--;visit[edge[i].to]=true;
            if(rd[edge[i].to]==0)
            {
                vis[edge[i].to]=true;
                q.push(edge[i].to);
            }
        }
    }
}
void dfs(int x)
{
    vis[x]=true;
    for(int i=head[x];i;i=edge[i].next)
    {
        if(visit[edge[i].to]) flag=1;
        if(vis[edge[i].to])continue;
        dfs(edge[i].to);
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        fa[i]=i;
        while(scanf("%d",&a),a)
        {
            if(a>0)add(i,a),rd[a]++;
        }
    }
    top();
    printf("%d",ans);
}
```
######然后我不得不用tarjan了：
1.tarjan缩点；

2.枚举相连的两个点是否属于同一个强连通分量，是：入读++；

3.统计入读为0的强连通分量，ans++；

######tarjan代码（相信大家都会tarjan，我就不写那么详细的批注了）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int N=250000;
int fa[N],n,a,ans=0,rd[N],head[N],k=0,tot=0,dfn[N],low[N];
struct node
{
    int fr,to,next;
}edge[N*2];
void add(int u,int v)
{
    edge[++k].to=v;
    edge[k].fr=u;//fr==from，是v前面的那个点
    edge[k].next=head[u];
    head[u]=k;
}
bool vis[N];
int tim=0,sta[N],top,color_num;
int color[N];
void tarjan(int x)
{
    dfn[x]=low[x]=++tim;
    sta[++top]=x;//栈
    vis[x]=true;
    for(int i=head[x],v=edge[i].to;i;i=edge[i].next,v=edge[i].to)
    {
        if(!dfn[v]){
            tarjan(v);
            low[x]=min(low[x],low[v]);
        }
        else if(vis[v]) low[x]=min(low[x],dfn[v]);
    }
    if(dfn[x]==low[x])//染色操作
    {
        vis[x]=false;
        color[x]=++color_num;
        do{
            vis[sta[top]]=false;
            color[sta[top]]=color_num;
        }while(sta[top--]!=x);
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        fa[i]=i;
        while(scanf("%d",&a),a)
        {
            if(a>0)add(i,a);//建边
        }
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
    for(int i=1;i<=k;i++)
        if(color[edge[i].fr]!=color[edge[i].to]) rd[color[edge[i].to]]++;
    for(int i=1;i<=color_num;i++) if(!rd[i]) ans++;//判断入读==0
    printf("%d",ans);
}
//最后感谢神牛compile_error   和   zhouenji的帮助
```

---

## 作者：_hqw_ (赞：0)

# P2835 刻录光盘
[题目传送门](https://www.luogu.com.cn/problem/P2835)  
### 普及+/提高  
###### 来自蒟蒻的鞠躬
这题是一道经典的连通性问题，首先，我们需要处理输入和初始化，把f这个数组的初值赋成下标数，即 
```cpp
for(int i=1;i<=n;i++)f[i]=i;
```   
输入可以处理成
```cpp
for(int i=1;i<=n;i++){
		while(scanf("%d",&x)){
			if(x==0)break;
			b[i][x]=1;
		}
	}
```
然后把Floyd改编一下
```cpp
for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(b[i][j]!=0||(b[i][k]!=0&&b[k][j]!=0))
					b[i][j]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(b[i][j]!=0)f[j]=f[i];
    for(int i=1;i<=n;i++)
		if(f[i]==i)ans++;
```  
即可！
ans是需要光盘的张数



------------
完整代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[209],n,x,ans=0;
bool b[209][209];
int main(){
	memset(b,0,sizeof(b));
    cin>>n;
    for(int i=1;i<=n;i++)f[i]=i;
    for(int i=1;i<=n;i++){
		while(scanf("%d",&x)){
			if(x==0)break;
			b[i][x]=1;
		}
	}
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(b[i][j]!=0||(b[i][k]!=0&&b[k][j]!=0))
					b[i][j]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(b[i][j]!=0)f[j]=f[i];
    for(int i=1;i<=n;i++)
		if(f[i]==i)ans++;
    cout<<ans;
}
```
##### 请各位大佬们指教
###### orz
###### 不抄标程，你我有责

---

## 作者：Randolph、 (赞：0)

### [P2835 刻录光盘](https://www.luogu.org/problemnew/show/P2835)

## 来一波FLOYD最短代码qwq

```cpp
#include<cstdio>
using namespace std;
#define FOR(i) for (register int i=1;i<=n;i++)
int n,x,a[201][201],f[201];
int main() {
    while(~scanf("%d",&n)) {
        FOR(i) while(scanf("%d",&x),x) a[i][x]=1;//建图，i可以将资料拷贝给x
        FOR(k) FOR(i) FOR(j) a[i][j]|=(a[i][k] && a[k][j]);//FLOYD：i和j本身可以到达或可经k到达，则i与j相连
        FOR(i) f[i]=i;
        FOR(i) FOR(j) if (a[i][j]) f[j]=f[i];//类似并查集，寻找祖先（入度为0的点）
        FOR(i) x+=(f[i]==i);//统计祖先数（即祖先不能从别的点拷贝到资料，所以每个祖先都需要一份）
        printf("%d\n",x);
    }
    return 0;
}
```

---

## 作者：captain001 (赞：0)

并不是很会单项的并查集，于是发一下tarjan的题解；

数据有坑，#6测试点一直莫名tle，看了讨论区才知道习惯性加快读的强迫症在这里会被卡eof；



```
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int mx=2e7+1;
int n,k,aa,ans=1e8+1,dfn[mx],sum[mx],head[mx],tot,sjc,f[mx],z[mx],tp,low[mx];
bool vis[mx];
struct node{
    int to,ne;
}e[mx*2];
#define dd c=getchar()
inline int read(){
    static bool eof=0;
    if(eof)return 0;
    int a=0,b=1,dd;
    while(!isdigit(c)&&!eof){if(c=='-')b=-b;if(c==EOF)eof=1;dd;}
    if(eof)return 0;
    while(isdigit(c)){a=a*10+c-'0';dd;}
    if(c==EOF)eof=1;
    return a*b;
}
//更改过的快读
#undef dd
inline void link(int x,int y){
    e[++tot].to=y,e[tot].ne=head[x],head[x]=tot;
}
//塔尖丑陋的板子
void tarjan(int u){
    int v;
    vis[u]=1,z[++tp]=u,dfn[u]=low[u]=++sjc;
    for(int i=head[u];i;i=e[i].ne){
        v=e[i].to;
        if(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);
        else if(vis[v]) low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]){
        tot++;
        do{
            v=z[tp--],f[v]=tot,vis[v]=0;
        }while(u!=v);
    }
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        aa=read();
        while(aa){
            if(aa!=i) link(i,aa);
            aa=read();	
        }
    }
    tot=0;
    for(register int i=1;i<=n;i++) if(!dfn[i]) tarjan(i); 
    //u、v在不同强联通分量 就能传
    for(register int i=1;i<=n;i++)
        for(register int j=head[i];j;j=e[j].ne)
            if(f[i]!=f[e[j].to]) sum[f[e[j].to]]++;
    ans=0;
    //始终没传到 就得印
    for(int i=1;i<=tot;i++) if(!sum[i]) ans++;
    printf("%d\n",ans);
}
```

---

## 作者：Ice_teapoy (赞：0)

不知道自己用了什么算法……
贪心？拓扑排序？搜索？
反正很暴力就是了
主要思想就是把光盘给没得到资料的人中入度最小的人。
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int b[201],a[201][201],n; //记录入度、边、n个人
bool v[201]; //记录第i个人是否得到光盘
int ans; //统计答案
void dfs(int t) //传播光盘
{
	v[t]=1;
	for (int i=1;i<=a[t][0];++i)
		if (!v[a[t][i]]) dfs(a[t][i]);
}
int main()
{
	scanf("%d",&n); //读入
	for (int i=1;i<=n;++i)
	{
		a[i][0]=1;
		while (a[i][a[i][0]-1]) scanf("%d",&a[i][a[i][0]++]),b[a[i][a[i][0]-1]]++;
		a[i][0]-=2;
	}
	b[0]=2147483647;
	for (int i=1;i<=n;++i) //找入度最小的人，给他一张光盘
	{
		int k=0;
		for (int j=1;j<=n;++j)
			if ((!v[j])&&b[j]<b[k]) k=j;
		if (k==0) break;
		ans++;
		dfs(k); //传播光盘
	}
	printf("%d",ans); //输出答案
}
```

---

## 作者：chenkaixing (赞：0)

让pascal占领头尾！！！

这是我的题解，你们会发现和一楼惊人的相似（没办法，这个最容易想出来，直接并查集我不会做。。。），没关系我讲解详细一点

先介绍下思想：这道题的话，只要在于，就算一个人可以分享给另外一个人（也就是存在路径），另一个人也不一定会分享给这个人

（人心险恶），所以这是一个单向的图；那么只要我能把存在路径的一个个给它消除障碍，最后计算每个头头，就是所需的光盘数，也就是图中连通块的数量。（floyed+简单连通块判断）

因为n<=200,而200^3=8\*10^6所以不会超时，floyed成立；

下面是我的code（请欣赏）：





```cpp
program cd;
var
    p:array[0..200,0..200]of boolean;
    fa:array[1..200]of longint;
    i,j,n,m,k,ans:longint;
begin
      fillchar(p,sizeof(p),false);//初始化
      readln(n);
      for i:=1 to n do//此处要标记处单向路径
      begin
            read(m);
            while m<>0 do
            begin
                  p[i,m]:=true;//单向路径
                  read(m);
            end;
      end;
      for i:=1 to n do fa[i]:=i;//没操作之前，每个假定都要一个光盘
      for k:=1 to n do//floyed算法实现
       for i:=1 to n do
       if i<>k then
        for j:=1 to n do
        if (k<>j)and(i<>j) then
        begin
              if (p[k,i])and(p[i,j])then p[k,j]:=true;//floyed精髓所在，最简单的dp，假如k->i有路，i->j有路，那么k->j必定有路
        end;
      for i:=1 to n do
       for j:=1 to n do
       if p[i,j] then fa[j]:=fa[i];//简单在这里，对于fa[j]来说，只要之前有路，那么fa[j]的值就会改变，后面计数就不会记到
      for i:=1 to n do
       if fa[i]=i then inc(ans);//计算头头的数量,输出，（0~0）
       writeln(ans);
end.

```

---

## 作者：chauchat (赞：0)

分享一种不用tarjan做的搜索方法

首先处理好联通性，用floyd就行了。然后求数量的时候就懵逼了（一定是姿势水平不够），楼下的并查集考虑过也没写

于是就写了个乱搞做法

 ![](https://cdn.luogu.com.cn/upload/pic/5865.png) 

入度为0的点各需要一个，两端到一端的方向是2个，反之是1个。这时候dfs标记一下，剩下的就是环

 ![](https://cdn.luogu.com.cn/upload/pic/5866.png) 

处理环时，如果分叉出来的端点向里面联通（顺时针方向），这在上面已经处理，如果是反方向，就找一个点dfs标记所有的点，算一个。

而显然不能找分叉上的点（结果会变大），于是找分叉的起点 ，在读入的时候统计出度，对出度>1的搜就行了。




```cpp
#include<iostream>
using namespace std;
#include<cstring>
#include<cstdio>
const int maxn = 210;
int n,con[maxn][maxn],vis[maxn],rudu[maxn],chudu[maxn],cnt,cnt_vis;
void dfs(int now){
    if(vis[now]) return ; vis[now] = 1; cnt_vis++;
    for(int i = 1;i <= n;i++ ) if(con[now][i]) dfs(i);
}
int main(){
    cin>>n;
    for(int i = 1;i <= n;i++){
        int temp = -1;
        while(cin>>temp && temp != 0){
            con[i][temp] = 1; rudu[temp]++; chudu[i]++;
        }
    }
    for(int k = 1;k <= n;k++)
        for(int i = 1;i <= n;i++)
            for(int j = 1;j <= n;j++)
                if(con[i][k] && con[k][j]) con[i][j] = 1;
    for(int i = 1;i <= n;i++) if(!rudu[i]){
        cnt++; dfs(i);
    }
    while(cnt_vis < n)
        for(int i = 1;i <= n;i++) if(!vis[i] && chudu[i] > 1){
            cnt++; dfs(i);
        }
    cout<<cnt;
    return 0;
}
```

---

## 作者：doby (赞：0)

楼下厉害……

这里用Floyd判联通……

```cpp
#include<cstdio>
using namespace std;
int f[209],n,x,ans=0;;
bool b[209][209];
void Floyd()
{
    for(int k=1;k<=n;k++)
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            { 
                if(b[i][j]||(b[i][k]&&b[k][j])){b[i][j]=1;}//Floyd……
            }
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        f[i]=i;//各种初始化
        for(int j=1;j<=n;j++){b[i][j]=0;}
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);//输入
        for(;x!=0;)
        {
            b[i][x]=1;
            scanf("%d",&x);
        }
    }
    Floyd();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(b[i][j]){f[j]=f[i];}//找出可以互相拷贝的
        }
    }
    for(int i=1;i<=n;i++){if(f[i]==i){ans++;}}//计算光盘数
    printf("%d",ans);
}
```

---

## 作者：飞翔 (赞：0)

弗洛伊德判断点的相连关系，并查集判断答案

```c
var
  map:array[0..201,0..201]of boolean;
    father:array[0..201]of longint;
    i,j,k,n,t:longint;
begin
  fillchar(map,sizeof(map),false);
  readln(n);
    for i:=1 to n do begin
      read(t);
        while t<>0 do begin
          map[i,t]:=true;
            read(t);
        end;
        readln;
    end;
    for k:=1 to n do
      for i:=1 to n do
          for j:=1 to n do
              if map[i,k] and map[k,j] then map[i,j]:=true;
    for i:=1 to n do father[i]:=i;
    for i:=1 to n do
      for j:=1 to n do
          if map[i,j] then father[j]:=father[i];
    t:=0;
    for i:=1 to n do
      if father[i]=i then inc(t);
    write(t);
end.
```

---

## 作者：樱花飞舞 (赞：0)

真不懂大家的奇葩做法，其实tarjan就水过了
关于强连通分量，这篇文章写的很好，大家可以参考一下，~~不是我写的~~[https://www.luogu.org/blog/sincereactor/tarjian-tai-fa-zhi-jiang-xie](https://www.luogu.org/blog/sincereactor/tarjian-tai-fa-zhi-jiang-xie)
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int N = 40000+500;
inline int min(int x, int y)
{
	return x > y ? y : x;
}
int dfn[N], low[N], step[N], id, st = 1, last[N], len, cut, sum, belong[N], ru[N];
bool v[N];
struct MyStruct
{
	int x, y, next;
}a[N];
inline void add(const int x, const int y)
{
	len++;
	a[len].x = x;
	a[len].y = y;
	a[len].next = last[x];
	last[x] = len;
}
inline void go(int x = 1)
{
	low[x] = dfn[x] = ++id;
	v[x] = 1;
	step[++st] = x;
	for (register int i = last[x]; i; i = a[i].next)
	{
		int y = a[i].y;
		if (dfn[y] == 0)
		{
			go(y);
			low[x] = min(low[x], low[y]);
		}
		else if (v[y] == 1)
		{
			low[x] = min(low[x], low[y]);
		}
	}
	if (dfn[x] == low[x])
	{
		int i;
		cut++;
		do {
			i = step[st--];
			v[i] = 0;
			belong[i] = cut;
		} while (i != x);
	}
}
int main()
{
	int n, m;
	cin >> n;
	for (int i = 1,x; i <= n; i++)
	{	
	scanf("%d", &x);
		while (x != 0)
		{
			add(i, x);
		scanf("%d", &x);
		}
	}
	for (int i = 1; i <= n; i++)
	{
		if (dfn[i] == 0)
			go(i);
	}
	for (int i = 1; i <= n; i++)
		for (register int j = last[i]; j; j = a[j].next)
		{
			if (belong[i] != belong[a[j].y])
			{
				ru[belong[a[j].y]]++;
			}
		}
	for (register int i = 1; i <= cut; i++)
		if (ru[i] == 0)
			sum++;
	printf("%d", sum);
}
```


---

## 作者：封禁用户 (赞：0)

## Adv
个人博客同步： http://www.cinema000.xyz/1511.ruby
## 分析

看到这里就是很显然的求强连通分量，然后缩点，判断入度为0的点的个数就好了。

题解都是Tarjan求SCC的，但我嫌Tarjan太长了~~无法理解233~~，所以搞了Kosaraju算法，这就是那个跑两次DFS，第一次求拓扑序，第二次按该序逆序进行的算法。

## 代码

```CPP
/*
 * 2018年8月10日 上午10:38:17
 * Luogu 2835
 * Cinema
 * All rights reserved. Cinema Media Group
 * cinema000.xyz
 *
 */
#include<cstdio>
#include<vector>
const int MAXN = 200 + 6;
bool in[MAXN];
class SCC{
public:
	std::vector<int> G[MAXN],G2[MAXN],S;
	bool hash[MAXN] = {};
	int SCCNo[MAXN] = {},SCCCnt = 0;

	void dfs1(int u){
		if(hash[u]) return;
		hash[u] = true;
		for(int i = 0;i < G[u].size();i++) dfs1(G[u][i]);
		S.push_back(u);
	}
	void dfs2(int u){
		if(SCCNo[u]) return;
		SCCNo[u] = SCCCnt;
		for(int i = 0;i < G2[u].size();i++) dfs2(G2[u][i]);
	}
	void findSCC(int n){
		SCCCnt = 0;
		for(int i = 0;i < n;i++) dfs1(i);
		for(int i = n - 1;i >= 0;i--) if(!SCCNo[S[i]]){SCCCnt++;dfs2(S[i]);}
	}
};

int main(){
	SCC s;
	int n,u;scanf("%d",&n);
	for(int i = 0;i < n;i++){
		while(scanf("%d",&u) && u){
			s.G[i].push_back(u - 1);
			s.G2[u - 1].push_back(i);
		}
	}
	s.findSCC(n);

	for(int i = 1;i <= s.SCCCnt;i++) in[i] = true;
	for(int u = 0;u < n;u++){
		for(int i = 0;i < s.G[u].size();i++){
			int v = s.G[u][i];
			if(s.SCCNo[u] != s.SCCNo[v]) in[s.SCCNo[v]] = false;
		}
	}
	int ans = 0;
	for(int i = 1;i <= s.SCCCnt;i++) if(in[i]) ans++;
	if(s.SCCCnt == 1) ans = 0;
	printf("%d",ans);

	return 0;
}

```



---


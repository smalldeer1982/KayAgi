# 【模板】缩点

## 题目描述

给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。

允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。


## 说明/提示

对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，$0\le a_i\le 10^3$。

- 2024-11-1 添加了 [hack 数据](https://www.luogu.com.cn/discuss/964940)；

## 样例 #1

### 输入

```
2 2
1 1
1 2
2 1```

### 输出

```
2```

# 题解

## 作者：星星之火 (赞：1373)

缩点，就是把一张有向有环图中的环缩成一个个点，形成一个有向无环图。

首先我介绍一下为什么这题要缩点（有人肯定觉得这是放屁，这不就是缩点的模板题吗？但我们不能这么想，考试的时候不会有人告诉你打什么板上去吧）

根据题目意思，我们只需要找出一条点权最大的路径就行了，不限制点的个数。那么考虑对于一个环上的点被选择了，一整条环是不是应该都被选择，这一定很优，能选干嘛不选。很关键的是题目还允许我们重复经过某条边或者某个点，我们就不需要考虑其他了。因此整个环实际上可以看成一个点（选了其中一个点就应该选其他的点）

那么就正式开始缩环为点了。当然了，首先肯定是找环，为大家推荐两篇博客（不是我宣传，这两篇博客也只是我找的[]
(http://blog.csdn.net/acmmmm/article/details/16361033)）[](http://blog.csdn.net/sentimental_dog/article/details/53790582)

希望博客被我转载的博主不要介意。

看看这两篇博客，我觉得大家就有了一个基本认识了。在缩点操作中，最重要的是维护三个东西，它们在我代码里分别是stac（栈）（ps：之所以不加k是因为万能头文件的荼毒），dfn（时间戳），low(够追溯到的最早的栈中节点的次序号)，详细的解释在代码注释里。

下面就是考虑对这三个东西的运用。详细参考博客（博客带图），需要注意的是，当dfn[u]==low[u]时，表明u一定是环上的一点，且环上的其他点就是u的子树。为什么呢？看代码  
low[x]=dfn[x]=++tim;
           
low[x]=min(low[x],low[v]);

我截取了两句代码，第一句是对点x的low，dfn的初始化。在之后的操作中,low[x]始终取自己子树low[v]的较小值，那么什么情况会使得dfn[u]又“重新”和low[u]相等呢，就是在u的子树中有一条边（就是博客1中的后向边）直接指回了u。这样不就是形成了一个环了吗？

之后就是把环上所有的点的sd都变成这个u，即用u代替整个环，并把权值集中在u上

还有值得注意的，这个栈表示的究竟是什么？（这个在博客1中也有），根据我的理解表示的是当前搜索的一条链上的一个个点吧。

下面我附上代码先

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=10000+15;
int n,m,sum,tim,top,s;
int p[maxn],head[maxn],sd[maxn],dfn[maxn],low[maxn];//DFN(u)为节点u搜索被搜索到时的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号 
int stac[maxn],vis[maxn];//栈只为了表示此时是否有父子关系 
int h[maxn],in[maxn],dist[maxn];
struct EDGE
{
	int to;int next;int from;
}edge[maxn*10],ed[maxn*10];
void add(int x,int y)
{
	edge[++sum].next=head[x];
	edge[sum].from=x;
	edge[sum].to=y;
	head[x]=sum;
}
void tarjan(int x)
{
	low[x]=dfn[x]=++tim;
	stac[++top]=x;vis[x]=1;
	for (int i=head[x];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if (!dfn[v]) {
		tarjan(v);
		low[x]=min(low[x],low[v]);
	}
	    else if (vis[v])
	    {
	    	low[x]=min(low[x],low[v]);
		}
	}
	if (dfn[x]==low[x])
	{
		int y;
		while (y=stac[top--])
		{
			sd[y]=x;
			vis[y]=0;
			if (x==y) break;
			p[x]+=p[y];
		}
	}
}
int topo()
{
	queue <int> q;
	int tot=0;
	for (int i=1;i<=n;i++)
	if (sd[i]==i&&!in[i])
	{
		q.push(i);
        dist[i]=p[i];
	 } 
	while (!q.empty())
	{
		int k=q.front();q.pop();
		for (int i=h[k];i;i=ed[i].next)
		{
			int v=ed[i].to;
			dist[v]=max(dist[v],dist[k]+p[v]);
			in[v]--;
			if (in[v]==0) q.push(v);
		}
	}
    int ans=0;
    for (int i=1;i<=n;i++)
    ans=max(ans,dist[i]);
    return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	scanf("%d",&p[i]);
	for (int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
	}
	for (int i=1;i<=n;i++)
	if (!dfn[i]) tarjan(i);
	for (int i=1;i<=m;i++)
	{
		int x=sd[edge[i].from],y=sd[edge[i].to];
		if (x!=y)
		{
			ed[++s].next=h[x];
			ed[s].to=y;
			ed[s].from=x;
			h[x]=s;
			in[y]++;
		}
	}
	printf("%d",topo());
	return 0;
}
```

在处理了环后，我们就重新建立一张图，以每个环为节点（孤立一个点也算也算环的，其实也就是强联通分量了）。在这张图中我们要dp，显然对于任意边<u,v>,dp[v]=max(dp[v],dp[u]+p[v])，p[v]是v是这个环的总权值。

那么怎么解决无后效性问题呢？答案就是拓扑排序，至于为什么，在我的另一篇题解里我有提及。这下我有安利嫌疑了，但我还是希望大家去看一看，下面我附上链接。

[](https://www.luogu.org/blog/xxzh2425/p1137-lv-xing-ji-hua-ti-xie)
这也是一篇题解，其实主要讲的就是拓扑排序解决DP的无后效性问题了

那么就讲完了，如果有帮助，希望大家不要吝啬自己的赞。

---

## 作者：hyfhaha (赞：749)

（搬一下本人tarjan blog）

本人写这道题的思路比较恶心：tarjan缩点+拓扑排序+dp

不过学一下拓扑对大家也有好处。

相信大家都是好学的OIer。

# $ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \     $强连通分量与拓扑排序

## 拓扑排序

$ \ \ \ \ \ \ $对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。

（by 百度百科）

$ \ \ \ \ \ \ $照个人理解，拓扑排序通常是在DAG图中寻找一个适合的解决问题的顺序。

### 如何实现拓扑排序

**方法1：BFS（SPFA优化）**

1、先寻找入度为0的点，把它加入队列。

2、搜寻队列，把队列的点G删去，则如果有点的入度有G点的话，入度- -，当发现又出现入度为0的点时，将该点加入队列。

3、拓扑排序的结果为该队列，在执行删点操作的时候存储在一个数组及可。

**方法2：记忆化搜索**

大多数情况下，并不需要显式的拓扑排序

考虑朴素的回溯算法

若从一个给定的点出发，得到的结果是一样的

因此对于每个点，计算完成后可以把结果保存起来，之后直接返回查表的结果即可

**拓扑排序伪代码(1)：**
```cpp
Topological_sort(G){
    统计图G中每个点的入度(可计算重边，但不可计算自环），记为degree[i]
    初始化queue和result为空的队列，并将所有degree为0的点加入queue
    while (!queue.empty()){
        u = queue.pop() // 队首
        result.push(u)
        for e 是u的出边（若上面计算了重边，这里也要算，与上面一致）
        v是e的指向的点
        degree[v]--
        if (degree[v] == 0) queue.push(v)
    }
	return result
}
```

**拓扑排序伪代码(2)：**
```cpp
calculate(u){
    if (u 已经搜索过) return table[u]
    ans = -inf
    for (v 是u的出边指向的点)
    ans = max(ans, value[u] + calculate(v))
    标记u已经搜索过
    table[u] = ans
    return ans
}
for (i 是G的所有节点)
result = max(result, calculate(i))
print(result)
```

#### ps:源码在我讲完缩点后一起放出来
------------
# 下面重点：
## 强连通分量——缩点（有向有环图）

$ \ \ \ \ \ \ $现在给出一个有向有环图，那么这个图不是一个DAG，所以不能在这种图上做拓扑排序或其他有关DAG的操作了。

![](https://cdn.luogu.com.cn/upload/pic/33261.png)

如果我们单独把1,2,3点提出来，把它们看做一个团。

我们把这样一个“团点”叫做强连通分量(scc, strong connected component)

通常来讲，一组互相能到达的点叫做连通分量

当这个连通分量不能再大时，便是强连通分量

### 求强连通分量

把有向有环图抽象成一颗DFS树。

![](https://cdn.luogu.com.cn/upload/pic/33262.png)

那么每一个图上的圈圈就是一个强连通分量。在DFS树中，强连通分量一定长成这样子。

那么问题就被化简成了确定每个强连通分量的根。

### Tarjan

DFS时我们维护两个数组dfn,low

dfn[i]是i点的进入时间

low[i]是从i点出发，所能访问到的最早的进入时间

#### Tarjan-scc伪码
```cpp
DFS(u)
  dfn[u] = low[u] = ++timer
  stack.push(u)
  state[u]=1 //已访问并入栈
  for v 是u的一条出边的端点
    if (state[v] == 0) //未访问
    DFS(v)
    low[u] = min(low[u],  low[v])
    if (state[v] == 1)
    low[u] = min(low[u], dfn[v])
  if (dfn[u] == low[u])
  	stack.pop() until 弹出了u //这些点构成一个强连通分量
  弹出的点的state[] = 2
  
Tarjan_scc(G)
  timer = 0
  for u 是图G的节点
  if (state[u] == 0) DFS(u)
```
那怎么找出一个**强连通分量**的所有点

找出scc之后，问题通常会变成两个部分

1、scc内部

2、scc之间

如果把每个scc看成一个点，则是DAG图，即建出一个新图。

#### 新图怎么连边？

记belong[u]为u所在的scc编号

对于每条边u -> v

若belong[u] != belong[v]（就是u，v不在同一个强连通分量）

则给新图加边 

belong[u] -> belong[v]（给两个强连通分量连一条边）

------------

# 洛谷【P3387 缩点】

缩点+拓扑排序+DP

#### 为什么要缩点？
```cpp
题目：重复经过的点，权值只计算一次。
```
那么如果是一个环的话，环内所以点的权都肯定被累加，所以我们可以直接把环缩成一个点。

#### 为什么要拓扑排序？~~(其实是作者闲着__疼)~~
```cpp
算法：DAGdp
```
拓扑排序就可以求dp顺序（如果有DAGdp的话，建议加个拓扑）

（对于这道题的dp，拓扑无意义，所以可以跳过拓扑，直接dp）

#### 为什么要dp
因为题目说了啊（逃），其实也很明显啦，对每个点都不断用他的入边的点更新他，取最大值，f[i]表示i点（缩点后）的经过点和最大值。

方程：
```cpp
w代表当前点，rdr数组代表w点的入边的点，dis数组是权值。
f[w]=max(f[w],f[rdr[w][j-1]]+dis_[w]);

```
## 代码
总代码（emm~，码风可能有点丑QAQ）：
```cpp
#include<bits/stdc++.h>
#define maxn 100001
#define maxm 500001
using namespace std;
struct node{
    int to,next,from;
}edge[maxm];
queue <int> q;
vector <int> cb[maxn];
vector <int> rdr[maxn];
int ans[maxn],totq,x,y,v,rd[maxn],u,n,m,sum,vis[maxn],dis_[maxn],dis[maxn];
int dfn[maxn],low[maxn],f[maxn],times,cntqq;
int stack_[maxn],heads[maxm],visit[maxn],cnt,tot,index_;
void add(int x,int y)		//建边
{
    edge[++cntqq].next=heads[x];
    edge[cntqq].from=x;
    edge[cntqq].to=y;
    heads[x]=cntqq;
   	return;
}
void tuopu()				//拓扑排序
{
	for(int i=1;i<=tot;i++)	//初始化 
    {
        if(rd[i]==0)
        q.push(i);			//入度为0的都进队列 
    }
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        ans[++totq]=u;
        for(int i=1;i<=cb[u].size();i++)
        {
            v=cb[u][i-1];	//因为vector是从0开始的，所以减1，下面代码的减1也一样 
            rd[v]--;
            if(rd[v]==0)q.push(v);
        }
    }
}
void tarjan(int x)			//tarjan求强连通分量
{
    dfn[x]=low[x]=++times;
    stack_[++index_]=x;		//手写栈嘿嘿嘿 
    visit[x]=1;
   	for(int i=heads[x];i!=-1;i=edge[i].next)
    {
        if(!dfn[edge[i].to])
        {
           	tarjan(edge[i].to);
            low[x]=min(low[x],low[edge[i].to]);
       	}
       	else 
        if(visit[edge[i].to])
        low[x]=min(low[x],dfn[edge[i].to]);
    }
    if(low[x]==dfn[x])
   	{
   		tot++;//强连通分量编号 
   		while(1)
       	{
       		vis[stack_[index_]]=tot;	//index_所在的强连通分量编号，等于前面讲的belong 
       		dis_[tot]+=dis[stack_[index_]];	//强连通分量权值累加 
       		visit[stack_[index_]]=0;index_--;
       		if(x==stack_[index_+1])break;//手写栈嘿嘿嘿 
       	}
    }
}
int main(){
    memset(heads,-1,sizeof(heads));
    int n,m,x,y;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    scanf("%d",&dis[i]);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
       	add(x,y);
    }
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i); 	//tarjan 
    for(int i=1;i<=cntqq;i++){			//拓扑建边
        if(vis[edge[i].from]!=vis[edge[i].to])
        {
            x=vis[edge[i].from];y=vis[edge[i].to];
			rd[y]++;cb[x].push_back(y);rdr[y].push_back(x);
        }
    }
    tuopu();
    for(int i=1;i<=tot;i++)				//dp
    {
        int w=ans[i];
        f[w]=dis_[w];
        for(int j=1;j<=rdr[w].size();j++)
        f[w]=max(f[w],f[rdr[w][j-1]]+dis_[w]);
    }
    for(int i=1;i<=tot;i++)				//最后统计答案 
    sum=max(f[i],sum);
    printf("%d",sum); 
    return 0;
}//刚刚好100行 


```
# 后记

### 随便给点题
P2341 [HAOI2006]受欢迎的牛

P2002 消息扩散

P1262 间谍网络

# $ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \     $ 谢谢观赏，给个赞呗qwq

如果还想学更多知识：请看本人完整[blog](https://www.luogu.org/blog/juruohyfhaha/qiang-lian-tong-fen-liang-yu-ta-pu-pai-xu-lve-xie)


---

## 作者：一叶知秋。 (赞：28)

~~用什么DP，网络流无敌！~~

------------
其实这题和 [P3627](https://www.luogu.org/problem/P3627) 挺像的，都是求最长路，只是那题有起点与终点的限制罢了。

然而因为先写的 $P3627$ 的题解，所以关于 $trajan$ 的详细解释我放在 [P3627 [APIO2009]抢掠计划的题解](https://www.luogu.org/blog/wyz598085788/solution-p3627) 里了（~~其实是不想复制进来了~~），要了解 $trajan$ 怎么实现的 $O(N)$ 找环的及其思想的，可以去看看（~~顺便点个赞吧~~）（不过建议初学者组合阅读）

这篇题解我们主要是将后面的部分，求一条最长路，很多人用的 $DP$ 做的（因为题面写着嘛），然而，并不需要那么麻烦，稍微借助一下网络流的思想，多建几条边就出来了。

------------

这道题怎么运用网络流的思想这里讲一下吧，虽然与真正的网络流有些出入，但对以后网络流的学习也有帮助。（已学的大佬可跳过）

对于没有限定起点与终点的求一条最长路（其实真正意义上的网络流（费用流）是可以求多条，但此题只要求求一条，就可以摒弃流量），我们可以创一个超级源点（起点）（后面简称为 $S$ ）与一个超级汇点（终点）（后面简称为 $T$ ）。

然后将 $S$ 向图中每一个点建立一条边权为点权的单向边，将图中每一个点向 $T$ 建一条边权为 $0$ 的单向边。为什么边权会等于点权呢？

其实缩完点后，我们会将每一条边的边权都等于这条边指向的点的点权。因为此时已经没有环了，并不会再走回来，所以同一个点不可能走两次，也就是说同一条边不会走两次，也就不会陷入死循环了，至于使边权等于点权的正确性是显然的（单向边又不能走回去）。

然后直接从 $S$ 跑 $SPFA$ 跑出到 $T$ 的最长路即可。

虽然正确性显然，但此处还是证明一下该算法的正确性（~~因为过了嘛，所以正确~~）：（非正确格式）

反证法。假设 $S$ 到 $T$ 的最长路并不是整个图的最长路。

即 $S$ 到 $T$ 之间的路径中并不包含图中最长路所在的路径。

设图中最长路的路径为 $A->B->C$ （ $A、B、C$ 都是指一段路径，不一定是一个点）那么有我们前面建的边可得：必有一段路径是 $S->A$ ，也必有一段路径是 $C->T$ 。

所以 $S$ 到 $T$ 之间的路径中并不包含图中最长路所在的路径，假设不成立，所以原结论成立。

------------

贴上我丑陋的代码：

```cpp
#include<cstdio>
#define maxn 500005
#define maxm 500005
#define INF 0x3f3f3f3f
inline int read(){
    int r=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){r=(r<<3)+(r<<1)+c-'0';c=getchar();}
    return r*f;
}
int s,t,n,m,N,head[maxn],dis[maxn],q[maxn],uu[maxn],vv[maxn];
bool vis[maxn];
int s_e;
struct E{
    int v,w,nxt;
}e[maxm];
struct E1{
    int v,nxt;
}e1[maxm];
int head1[maxn],s_e1;
int sd[maxn],dfn[maxn],low[maxn];
int cnt,stac[maxn*10],top,s_dfn;
bool ins[maxn];
int d[maxn],c[maxn],diss[maxn];
struct Max_fei{
    inline void a_e(int u,int v,int w){
        e[++s_e]=(E){v,w,head[u]};
        head[u]=s_e;
    }
    inline int spfa(){//SPFA跑最长路
        for(int i=0;i<=N;i++){
            dis[i]=-INF;
            vis[i]=false;
        }
        dis[s]=0;
        vis[s]=true;
        q[0]=s;
        int hd=0,tl=1;
        while(hd^tl){
            int u=q[hd++];
            hd%=maxn;
            for(int i=head[u];i;i=e[i].nxt){
                int v=e[i].v;
                if(dis[v]<dis[u]+e[i].w){
                    dis[v]=dis[u]+e[i].w;
                    if(vis[v])continue;
                    vis[v]=true;
                    q[tl++]=v;
                    tl%=maxn;
                }
            }
            vis[u]=false;
        }
        return dis[t]; //s到t的最长路即是答案
    }
}Flow;
inline void a_e(int u,int v){
    e1[++s_e1]=(E1){v,head1[u]};
    head1[u]=s_e1;
}
inline int min(int a,int b){
	return a<b?a:b;
}
inline int max(int a,int b){
	return a>b?a:b;
}
void tarjan(int u){//trajan缩点
	dfn[u]=low[u]=++s_dfn;
	stac[++top]=u;
  	ins[u]=1;
	for(int i=head1[u];i;i=e1[i].nxt){
		int v=e1[i].v;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])low[u]=min(low[u],dfn[v]); 
	}
	if(low[u]==dfn[u]){
		cnt++;
		int v=0;
		while(v!=u){
			v=stac[top--];
			d[v]=cnt;
			ins[v]=0;
			c[cnt]+=diss[v];
		}
	}
}
inline void work(){
    n=read();m=read();
    for(int i=1;i<=n;i++)
    	diss[i]=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        uu[i]=u,vv[i]=v;
        if(u==v)continue;
        a_e(u,v);
    }
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i);
    s=0;t=cnt+1;//s:超级源点，t:超级汇点
    N=cnt+1;
    for(int i=1;i<=cnt;i++){
    	Flow.a_e(s,i,c[i]);//s向每个点建单向边，边权等于点权
    	Flow.a_e(i,t,0);//每个点向t建单向边，边权等于0
    }
	for(int i=1;i<=m;i++){
		if(d[uu[i]]==d[vv[i]])continue;
        Flow.a_e(d[uu[i]],d[vv[i]],c[d[vv[i]]]);//点权转化为边权
	}
    printf("%d\n",Flow.spfa());//最长路
}
int main(){
    work();
    return 0;
}
```

~~完结偷偷撒花~~ ✿✿ヽ(°▽°)ノ✿

---

## 作者：JerryCao (赞：26)

首先链式前向星建原图，来一波tarjan缩点，然后再链式前向星建一个新图

最后来个toposort求从入度为零的点到它能走到的点的最大值

ps 第一次topo用栈 用它的理由是 既然tarjan都开了个栈 我就懒得再开个l,r和Q了 2333333


tarjan缩点就是求强连通分量 在弹出栈时

将当前点映射为该强连通分量的根节点


如果用F[k]表示从入度为零点到它的路径上的点权之和

这样F[k]max（1<=k<=n&& k属于一个强连通分量）就是最大值









    
```cpp
#include<iostream>
using namespace std;
const int maxn = 10007;
const int maxm = 100007;  
struct node
{
    int x,y;
}E[maxm],ne[maxm];
int n,m,tm = 0,top = 0,tot = 0;
int W[maxn],dfn[maxn],low[maxn],Head[maxn],Next[maxm],S[maxn],V[maxn],sd[maxn];//w 点权...sd 缩点后 旧点所对应的新点
int nh[maxn],nn[maxm],in[maxn],D[maxn];//newhead，newnext，index入度，D就是上面说的F啦
void tarjan(int x)
{
    dfn[x] = low[x] = ++tm;
    S[++top] = x; V[x] = 1;
    for (int y,i = Head[x]; i; i = Next[i])
    {
        y = E[i].y;
        if (!dfn[y])
        {
            tarjan(y);
            low[x] = min(low[x],low[y]);
        }
        else if (V[y])
        {
            low[x] = min(low[x],low[y]);// low[x] = min(low[x],dfn[y]);两种都行，老师讲的注释里的 求大佬解释下到底哪种好
        }
    }
    if (dfn[x] == low[x])
    {
        int y;
        while (y = S[top--])
        {
              V[y] = 0;
              sd[y] = x;//缩点
              if (y==x) break;
              W[x] +=W[y];
        }
    }
    return;
}
int main()
{
    cin>>n>>m;
    for (int i = 1; i<=n; i++)
    {
        scanf("%d",&W[i]);
    }
    for (int i = 1; i<=m; i++)
    {
        scanf("%d%d",&E[i].x,&E[i].y);
        Next[i] = Head[E[i].x];
        Head[E[i].x] = i;
    }    
    for (int i = 1; i<=n; i++)
    {
        if (!dfn[i])
        {
            tarjan(i);
        }
    }
    for (int x,y,i = 1; i<=m; i++)
    {
        x = sd[E[i].x]; y = sd[E[i].y];
        if (x!=y)//不是一个强连通分量 说明需要建边
        {
            ne[++tot].x = x; ne[tot].y = y;
            nn[tot] = nh[x];
            nh[x] = tot;
            in[y]++;
        }
    }
    top =  0;
    for (int i = 1; i<=n; i++)
    {
        if (sd[i] == i && !in[i])//找那些入度为零的强连通分量根节点
        {
            S[++top] = i;
            D[i] = W[i];
        }
    }
    while (top)
    {
        int x = S[top--];
        for (int y,i = nh[x]; i; i = nn[i])
        {
            y = ne[i].y;
            D[y] = max(D[y],D[x]+W[y]);
            if (--in[y] == 0)
            {
                S[++top] = y;
            }
        }
    }
    int ans = 0;
    for (int i = 1; i<=n; i++)
    {
        ans = max(ans,D[i]);
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：_soul_ (赞：23)

本人第一次做tarjan，这类水题花了2:30小时才调好，一是因为刚转c++不习惯，总会把==打成=，找了好久的错。然后接着一直40分，是发现，now=next（now）打在了括号的外面，真的是蒟蒻。

好了进入正题了。这题我觉得是tarjan缩点然后再将不再一个强联通分量中的点重新连边，然后直接spfa遍历（按理来说floyd直接各个强联通分量3方爆扫好像也是可以的）。这是我的解法。之前还有很多dalao的解法，好像很多用的都是dp，但是我没有想到。。。。

{详细解释请见代码中的注释}

        
    
    

```cpp
#include<vector>
#include<cstdio>
#include<cstring>
#define MAXN (1000001)  {我觉得这个一个好习惯，因为这可以防止因为手贱而导致的mle或空间开小了}
#define ll long long
#define INF (0x7f7f7f7f)
#define max(a,b) (((a)>(b)) ? (a):(b))
#define min(a,b) (((a)>(b)) ? (b):(a)){手打的max，min要比cmath中的会快}
using namespace std;
int q[MAXN],dis[MAXN];
int get[MAXN];
int top,size,len,k,dc,maxx;
int a[MAXN],head[MAXN],next[MAXN],color[MAXN],dfn[MAXN],low[MAXN],stack[MAXN],f[MAXN],x1[MAXN],y1[MAXN],rd[MAXN];
bool visit[MAXN],instack[MAXN],vis[MAXN];
void add(int x,int y ){
    ++top;
    get[top]=y;
    next[top]=head[x];
    head[x]=top;      {邻接表不用多说}
}
void SPFA(int x){
    memset(vis,0,sizeof(vis));
    memset(dis,0,sizeof(dis));
    int h=0,t=1;     {刚开始将起点进队开始更新}
    q[1]=x; dis[x]=f[x];{因为是点的遍历，所以刚开始要把自己到自己的权值设成点权，不然后面就会少一个起点的值}
    while (h<t){
        ++h;
        int x=q[h];
        vis[x]=0;   {因为已经弹出所以标记为不在队列中}
        int now=head[x];
        while (now>0){
            int g=get[now];
            if (dis[x]+f[g]>dis[g]) {
                dis[g]=dis[x]+f[g];
                if (not vis[g]) {  {如果不在队列中那么进队}
                    t++;
                    q[t]=g;
                    vis[g]=1;
                }
            }
            now=next[now];
        }
    }
    for (int i=1;i<=dc;++i)
    maxx=max(maxx,dis[i]);   {用当前几点到所有点的距离更新答案maxx值}
}
void tarjan(int x){
    ++k; int u=x;
    dfn[x]=low[x]=k; visit[x]=true; instack[x]=true;++top; stack[top]=x;
    int now=head[x];
    do {
        int v=get[now];
        if (visit[v]==0) {
            tarjan(v);    {如果目标点不在栈中那么继续往下搜}
            low[u]=min(low[u],low[v]);    {用你儿子的low值去更新你的low值，因为你的low值必定要小于等于你儿子的low值}
        } else
        if (instack[v]) low[u]=min(dfn[v],low[u]);{如果目标点已经在栈中了，那么你就可以直接用你儿子的dfn值也就是时间戳来更新你的low值}
        now=next[now];{邻接表便利}
    } while(now>0); 
    if (dfn[x]==low[x]) {   {如果满足条件，就说明找到了一个强联通分量，那么就开始弹栈，直到弹到当前这一个点为止}
        ++dc;
        while (stack[top+1]!=x){   {因为当前这一个点也要弹出，所以是top+1，不然的话就会少弹一个}
            color[stack[top]]=dc;{染色}
            f[dc]+=a[stack[top]];{统计每一个颜色的点的总权值}
            instack[stack[top]]=0;{弹栈}
            top--;        {将栈顶指针-1}
        }
    }
}
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;++i) scanf("%d",&a[i]);
    for (int i=1;i<=m;++i){
        int x,y;
        scanf("%d%d",&x1[i],&y1[i]);   
        add(x1[i],y1[i]);
    }    
    top=0;
    for (int i=1;i<=n;++i)if (not visit[i]) tarjan(i);
    memset(head,0,sizeof(head));
    memset(next,0,sizeof(next));
    memset(get,0,sizeof(get));
    top=0;
    for (int i=1;i<=m;++i) 
        if (color[x1[i]]!=color[y1[i]]) {    {如果这条边的两个点不在同一个强联通分量中，那么连边}
            add(color[x1[i]],color[y1[i]]);  {连}
            rd[color[y1[i]]]++;     {将目标点的rd+1，以便后面处理}
            }
    for (int i=1;i<=dc;++i){
```
if （rd[i]==0）  {因为rd不为0的点肯定会被别的点走到，所以只需要便利rd为0的边，可以节省时间}
    SPFA(i);

    }
    printf("%d",maxx);  {最后输出便利到的最大值}

}

---

## 作者：George1123 (赞：13)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P3387 【【模板】缩点】](https://www.luogu.org/problem/P3387)

### 此题算法:tarjan缩点+拓扑排序

大致思路:

>1.$ $输入点权$pntw[]$，建初始图$ori$。

>2.$tarjan$缩点。建缩点后新图$tag$。

>3.$ $拓扑排序，其中$dp[]$为最长路数组，$sum[]$为每个强连通分量中的点权和，满足:

$dp[to]=max(dp[to],dp[now]+sum[to])$

![](https://s2.ax1x.com/2019/10/22/K3BNIf.jpg)

## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+10;
const int M=1e5+10;
int n,m,pntw[N],ans;
struct edge{
	int adj,nex;
};
struct graph{
	edge e[M*2];
	int g[N],top;
	void add(int x,int y){
		e[++top]=(edge){
			y,g[x]
		}; g[x]=top;
	}
}ori,dag; //原图和缩点图
int dfn[N],low[N],
ind,col[N],cnt,sum[N];
stack<int> s;
bool in[N];
void tarjan(int x){ //tarjan缩点
	dfn[x]=low[x]=++ind;
	s.push(x); in[x]=1;
	for(int i=ori.g[x];i;i=ori.e[i].nex){
		int to=ori.e[i].adj;
		if(!dfn[to]){
			tarjan(to);
			low[x]=min(low[x],low[to]);
		} else if(in[to])
			low[x]=min(low[x],dfn[to]);
	} if(low[x]==dfn[x]){
		int tmp=0; cnt++;
		while(tmp!=x){
			tmp=s.top(); s.pop();
			col[tmp]=cnt;
			sum[cnt]+=pntw[tmp];
			in[tmp]=0;
		}
	}
} int rud[N],dp[N]; //rud[]为每个强连通分量的入度数组
queue<int> q;
void toposort(){ //拓扑排序并求最长路
	for(int i=1;i<=cnt;i++)
		if(rud[i]==0){
			q.push(i);
			dp[i]=sum[i];
		}
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=dag.g[now];i;i=dag.e[i].nex){
			int to=dag.e[i].adj; rud[to]--;
			dp[to]=max(dp[to],dp[now]+sum[to]);
			if(!rud[to]) q.push(to);
		}
	} for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
} int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",pntw+i);
	for(int i=1;i<=m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		ori.add(a,b);
	} for(int i=1;i<=n;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i=1;i<=n;i++)
		for(int j=ori.g[i];j;j=ori.e[j].nex){
			int to=ori.e[j].adj;
			if(col[i]!=col[to]){ //建缩图
				dag.add(col[i],col[to]);
				rud[col[to]]++;
			}
		}
	toposort();
	printf("%d\n",ans);
	return 0;
}

```
我还是太蒻了，

谢谢大家! !


---

## 作者：prestige (赞：12)

```cpp
背景:作为退役前的最后一篇题解,爱了一辈子板子的我决定发一次模板题的题解.
```
题面:https://www.luogu.org/problem/P3387
```cpp
本题的确是有些复杂,首先要利用tarjan算法缩点,将整张图缩成一个DAG(有向无环图)，
之后再利用缩好点的旧图再次建新图,之后求一次拓扑序用来dp
缩点的板子就不放了,相信大家点进这题之前就已经熟练掌握了.
首先是拓扑排序的代码:
void topo(){
	queue<int> q;
	for(int i=1;i<=sum;i++){
		if(in[i]==0){
			q.push(i);
		}
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		p[++len]=u;
		for(int i=hed[u];i;i=g[i].nxt){ 
			int v=g[i].v;
			in[v]--;
			if(in[v]==0){
				q.push(v);
			}
		}
	}
}
那么现在新图已经建好了(相信聪明的你一定会),拓扑序也求完了,就可以开始dp了.
这里解释一下为什么能用拓扑序来解决dp无后效性的问题:
因为拓扑序中可以保证对于图中∀边(u,v),u一定在v的前面，这样的话当我需要更新dp[v]的值时,需要用到的dp[u]的值都已经处理过了，
dp[v]的值就不会再被它后面遍历到的点的dp值影响，正因如此,这也就保证了dp的无后效性。
Code:
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<queue>
using namespace std;
const int N=50005;
int n,m,head[N],cnt,dfn[N],low[N],tim,Q[N],top,sum,scc[N],du[N],num[N],tot,ans,in[N],p[N],f[N],len,pos,val[N],w[N],hed[N];
bool vis[N];
struct Node{
	int u,v,nxt;
}edge[N<<1];
struct node{
	int u,v,nxt;
}g[N];
void add(int u,int v){
	edge[++cnt]=(Node){u,v,head[u]};
	head[u]=cnt;
}
void ad(int u,int v){
	g[++pos]=(node){u,v,hed[u]};
	hed[u]=pos;
}
void tarjan(int u){
	dfn[u]=low[u]=++tim;
	vis[u]=1;
	Q[++top]=u;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].v;
		if(dfn[v]==-1){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(vis[v]){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		++sum;
		int now;
		do{
			now=Q[top];
			top--;
			scc[now]=sum;
			vis[now]=0;
			num[sum]++;
		}while(now!=u);
	}
}
void topo(){
	queue<int> q;
	for(int i=1;i<=sum;i++){
		if(in[i]==0){
			q.push(i);
		}
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		p[++len]=u;
		for(int i=hed[u];i;i=g[i].nxt){ 
			int v=g[i].v;
			in[v]--;
			if(in[v]==0){
				q.push(v);
			}
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&w[i]);
	}
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	memset(dfn,-1,sizeof(dfn));
	for(int i=1;i<=n;i++){
		if(dfn[i]==-1){
			tarjan(i);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=head[i];j;j=edge[j].nxt){
			if(scc[edge[j].u]!=scc[edge[j].v]){
				in[scc[edge[j].v]]++;
				ad(scc[edge[j].u],scc[edge[j].v]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		val[scc[i]]+=w[i];
	}
	for(int i=1;i<=sum;i++){
		f[i]=val[i];
	}
	topo();
	for(int i=1;i<=len;i++){
		for(int j=hed[p[i]];j;j=g[j].nxt){
			int u=g[j].u,v=g[j].v;
			f[v]=max(f[v],f[u]+val[v]);
		}
	}
	int ans=0;
	for(int i=1;i<=len;i++){
		ans=max(ans,f[i]);
	}
	printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Paul·Shi (赞：10)

# 【Tarjan】缩点

在一个点N数据极大的图中，直接SPFA或者记忆花搜索时间超限，那么我们可以利用Tarjan缩点来减少N。
举个例子；
![](http://media.hihocoder.com/problem_images/20150711/14366036609619.png)

如上图：3，6两点为该图中的强连通分量，我们可以将它们看做一个单元点。

## 怎么缩点呢
我们使用fa[]数组来存每个点所在的强连通分量中时间戳（DFN）最小的点，即将该点设为单元点。
## 怎么连边
如果两个点的fa[]不一样，且该两点间有一条有向边，那么我们就把他们的单元点(即fa[])连一条边
## 问题的求解
缩点后，重新建图，我们先找出图中入度为0的点，使用SPFA或拓扑排序来求解问题，与最短路问题相似

**P3387 【模板】缩点**

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int nw,nxt,mark;
}pre[100010];
int n,m,idx,cnt;
int dfn[10010],low[10010];
int in[10010],v[10010],fa[10010];
int head[10010];
bool used[10010];
int stk[10010],p;
int ans=0;
void add (int x,int y,int cnt)
{
	pre[cnt].nw=x;
	pre[cnt].mark=head[x];
	pre[cnt].nxt=y;
	head[x]=cnt;
}
void tarjan (int u)
{
	dfn[u]=low[u]=++idx;
	stk[++p]=u;
	used[u]=1;
	for (int i=head[u];i!=0;i=pre[i].mark)
	{
		int nx=pre[i].nxt;
		if (!dfn[nx])
		{
			tarjan (nx);
			low[u]=min (low[u],low[nx]);
		}
		else if (used[nx])
			low[u]=min (low[u],dfn[nx]);
	}
	if (low[u]==dfn[u])
	{
		do{
			v[u]+=v[stk[p]];
			fa[stk[p]]=u;
			used[stk[p]]=0;
			p--;
		}while (stk[p+1]!=u);
		v[u]>>=1;
	}
}
int topo ()
{
	int dis[10010];
	queue<int>q;
	for (int i=1;i<=n;i++)
		if (fa[i]==i)
		{
			dis[i]=v[i];
			if (!in[i])
				q.push(i);
		}
	while (!q.empty())
	{
		int Now=q.front();
		for (int i=head[Now];i!=0;i=pre[i].mark)
		{
			int Nxt=pre[i].nxt;
			dis[Nxt]=max (dis[Nxt],dis[Now]+v[Nxt]);
			in[Nxt]--;
			if (!in[Nxt])
				q.push (Nxt);
		}
		q.pop();
	}
	int maxx=0;
	for (int i=1;i<=n;i++)
		if (fa[i]==i)
			maxx=max (maxx,dis[i]);
	return maxx;
}
int main()
{
	memset (in,0,sizeof (in));
	memset (used,0,sizeof (used));
	memset (dfn,0,sizeof(dfn));
	memset (head,0,sizeof (head));
	scanf ("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		scanf ("%d",&v[i]);
	for (int i=1;i<=m;i++)
	{
		int a,b;
		scanf ("%d%d",&a,&b);
		add (a,b,i);
	}
	for (int i=1;i<=n;i++)
		if (!dfn[i])
			tarjan (i);
	memset (head,0,sizeof (head));
	for (int i=1;i<=m;i++)
	{
		int Now=fa[pre[i].nw];
		int Nxt=fa[pre[i].nxt];
		if (Now!=Nxt)
		{
			add (Now,Nxt,++cnt);
			in[Nxt]++;
		}
	}
	printf ("%d",topo ());
	return 0;
}
```

---

## 作者：Tiffany_Tendering (赞：8)

    缩点的模板题目
    说是要用dp    但是由于本人dp仍属于橙题的阶段...
    就自动选择了topo
    其实基本思路就是先缩点   之后再根据缩好的点建立一个新图
    由于已经缩好了点 这个新图就肯定不存在强连通分量了
    就直接搞个拓扑排序就好了
    
    说了这么多  至于缩点是什么  来做这个题的肯定都有一定了解了
    推荐一个地址 希望大家可以来这里学习（这并不是我发的博客 
    只是我看了这么多的关于缩点tarjan的博客  这一篇是写的很详细的）
    
    另外说明一下 本人的tajan代码是和复旦大学生刘明君老师学习的
    也很感谢刘老师在清北学堂的指导
    
    https://www.cnblogs.com/stxy-ferryman/p/7779347.html
    
    以上网址复制于百度....
    
    那么我就大体上说明一下吧
    tarjan的缩点和强连通分量其实都是一样的（也就是一句话的区别hhh）
    所有的数组我都会在代码里面给予说明的
    
    
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #include<stack>
    #include<queue>
    using namespace std;
    const int maxn = 10005;
    const int maxm = 100005 ;
    int n,m,head[maxn],head2[maxn],top2,top,dfn[maxn],low[maxn],value[maxn],indexx,cnt,belong[maxn],indegree[maxn],dis[maxn],ans ;
    //dfn[i]表示i点是第几个被搜到的点  low[i]表示i点可以搜到的最先被搜到的点 即dfn[]最小的点  belong[i]表示i点属于哪个强联通分量  
    //dis[i]适用于储存最后答案的 
    //indegree[] head[] 都是拓扑排序和邻接表存图的必备数组 
    bool instack[maxn] ; //表示该点是否在栈中 
    stack< int > s ;  //tarjan的栈 
    queue< int > q;  //拓扑的队列 
    struct edge {
	    int next , to ,from;
    }e[maxm];

    struct edge2 {
	    int next,to;
    }e2[maxm];

    void add_edge(int u,int v) {   //存的是还没缩点前的图 
	    e[++top].to = v;
	    e[top].next = head[u] ;
	    e[top].from = u;
	    head[u] = top ; 
    }

    void add_edge2(int u,int v) {  //存的是缩点后的图 
	    e2[++top2].to = v;
	    e2[top2].next = head2[u] ;
	    head2[u] = top2;
    }

    void tarjan(int u) {
	    instack[u] = 1;
	    dfn[u] = low[u] = ++indexx ;   //算是初始化吧 
	    s.push(u) ;
	    for(int i = head[u]; i ;i = e[i].next) {
		    if(!dfn[e[i].to]) {
			    tarjan(e[i].to) ;
			    low[u] = min(low[u] , low[e[i].to]) ;
		    }
		    else 
		      if(instack[e[i].to]) 
		        low[u] = min(low[u] , dfn[e[i].to]) ;  //这个地方我试过了  换成 low[u] = min(low[u] ,low[e[i].to])；也可以 
	    }
	    if(dfn[u] == low[u]) {
		    cnt++;   //表示有几个强连通分量 不过这个题好像没啥用... 
		    while(s.top() != u) {
			    int t = s.top() ; s.pop() ;
			    belong[t] = u;  // 上次我写的是belong[t] = cnt;  不过不知道为啥没过... 
			    instack[t] = 0;
			    value[u] += value[t] ;   //加起来的啦！ 
		    }
		    s.pop() ; 
		    instack[u] = 0;
		    belong[u] = u;  //最后的u点不要忘记了 
	    }
    }

    void topo( ) {   //拓扑排序找答案 
	    for(int i = 1;i <= n ;++i) 
	      if(belong[i] == i && !indegree[belong[i]]) {q.push(i) ;dis[i] = value[i] ;}
	    while(!q.empty())  {
		    int j = q.front() ; q.pop() ;
		    for(int i = head2[j]; i ;i = e2[i].next) {
			    dis[e2[i].to] = max(dis[e2[i].to] , dis[j] + value[e2[i].to]) ;
			indegree[e2[i].to]--;
			if(!indegree[e2[i].to]) q.push(e2[i].to) ;
		    }
	    } 
	    for(int i = 1; i <= n ;++i)
	      ans = max(ans , dis[i]) ;  
    }
    //不解释了吧 

    int main() {
    	scanf("%d%d",&n,&m) ;
	    for(int i = 1;i <= n ;++i) scanf("%d",&value[i]) ;
	    for(int i = 1;i <= m ;++i) {
		    int x,y; scanf("%d%d",&x,&y) ;
		    add_edge(x , y) ;
	    }
	    for(int i = 1;i <= n ;++i) 
	      if(!dfn[i]) tarjan( i ) ;   //若没有被搜过 则tarjan这个点 
	    for(int i = 1;i <= m ;++i) {
		    if(belong[e[i].from] == belong[e[i].to]) continue ;
		    add_edge2(belong[e[i].from] , belong[e[i].to]) ;   //存新图   
		                  //如果一条边的两个点不属于一个强连通分量  那么这两个强连通分量就可以连一条边 
		    indegree[belong[e[i].to]] ++ ;
	    }
	    topo() ;
	    printf("%d ",ans) ;
	    return 0;
    }

---

## 作者：125E591 (赞：7)





```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue> 
#include<cstring>
#define maxx 1000000
using namespace std;
int n,m,u,v;
bool vis[maxx];//是否在栈中 
int sta[maxx];//栈 
int top,time,ctot,ans,tot;//指针... 
int clor[maxx];//染色(联通分量编号) 
int num[maxx];//联通分量点权和 
int dfn[maxx],low[maxx];//tarjan 
int x[maxx],y[maxx];//存连边 
int a[maxx];//存单点点权 
int dis[maxx],first[maxx];//距离 ， 向前星 
struct n{
    int to,nt;    
}node[maxx];
inline void add(int u,int v){
    node[++tot].to=v;
    node[tot].nt=first[u];
    first[u]=tot;
}
inline void tarjan(int x){
    dfn[x]=low[x]=++time;
    sta[++top]=x;
    vis[x]=1;
    for(int i=first[x];i;i=node[i].nt){
        int j=node[i].to;
        if(vis[j])low[x]=min(low[x],dfn[j]);
        else if(!dfn[j])tarjan(j),low[x]=min(low[j],low[x]);
    }
    if(low[x]==dfn[x]){
        ++ctot;
        vis[x]=0;
        while(sta[top+1]!=x){
            clor[sta[top]]=ctot;//染色 
            num[ctot]+=a[sta[top]];//同一连通分量点权和 
            vis[sta[top]]=0;
            top--;
        }
    }
}
void spfa(int x){
    memset(dis,0,sizeof(dis));
    memset(vis,0,sizeof(vis));
    queue<int> q;
    dis[x]=num[x];
    vis[x]=1;
    q.push(x);
    while(!q.empty()){
        int j=q.front();
        vis[j]=0;
        q.pop();
        for(int i=first[j];i;i=node[i].nt){
            int t=node[i].to;
            if(dis[t]<dis[j]+num[t]){
                dis[t]=dis[j]+num[t];
                if(!vis[t]){
                    vis[t]=1;
                    q.push(t);
                }
            }
        }
    }
    for(int i=1;i<=ctot;i++)ans=max(ans,dis[i]);//更新答案最大值 
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=m;i++){
    scanf("%d%d",&u,&v);
    add(u,v);
    x[i]=u; 
    y[i]=v; 
    } 
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
    memset(first,0,sizeof(first));//重置准备连新图 
    memset(node,0,sizeof(node));
    for(int i=1;i<=m;i++)if(clor[x[i]]!=clor[y[i]])add(clor[x[i]],clor[y[i]]);//连图，如果不在同一联通分量就连 
    for(int i=1;i<=ctot;i++)spfa(i);
    printf("%d",ans);//ans前不要加& 我调了1个多小时才发现 
    return 0;
}
```

---

## 作者：夏色祭 (赞：5)

##11篇居然居然没有一个P。。

##来补一发吧

边表存边，tarjan缩点，dfn[u]为节点u搜索的次序编号(时间戳)，low[u]为u或u的子树能够追溯到的最早的栈中节点的次序号。。。

然后根据染色重新建图。。。

对于每个路径的起点跑一边SPFA。。。

主要看代码

今天刚学tarjan的蒟蒻 （滑稽

点这里：[luogu](https://www.byvoid.com/zhs/blog/scc-tarjan/)

丑陋的代码：

```cpp
uses math;
var
  q,dfn,low,b,a,last,next,x,y,c,color,rd,dis,f:array[0..100001]of longint;
  vis:array[0..100001]of boolean;
  n,m,top,tot,i,ans,d,sum:longint;
procedure add(x,y:longint);
begin
  inc(tot);
  a[tot]:=y;
  next[tot]:=last[x];
  last[x]:=tot;
  inc(rd[y]);
end;
procedure tarjan(k:longint);
var
  i,t:longint;
begin
  inc(d); inc(top);
  dfn[k]:=d;low[k]:=d;
  q[top]:=k;vis[k]:=true;
  i:=last[k];
  while i>0 do 
    begin
      t:=a[i];
      if dfn[t]=0 then //如果节点v未被访问过
        begin
          tarjan(t); //继续向下找
          low[k]:=min(low[k],low[t]);
        end
        else
          if vis[t] then low[k]:=min(low[k],dfn[t]); //如果节点t还在栈内
      i:=next[i];
    end;
  if low[k]=dfn[k] then  //如果节点k是强连通分量的根
    begin
      inc(sum);
      while q[top+1]<>k do 
        begin
          color[q[top]]:=sum;
          inc(b[sum],c[q[top]]);
          vis[q[top]]:=false;
          dec(top);
        end;//更新新的一个强连通分量
    end;
end;//tarjan
procedure spfa(start:longint);
var
  i,h,t,x,y:longint;
begin
  fillchar(vis,sizeof(vis),0);
  fillword(dis,sizeof(dis) >> 1,0);// writeln(start);
  h:=0;t:=1;
  f[1]:=start;
  dis[start]:=b[start];
  while h<t do 
    begin
      inc(h);
      x:=f[h];
      vis[x]:=false;
      i:=last[x];
      while i>0 do 
        begin
          y:=a[i];
          if dis[x]+b[y]>dis[y] then
            begin
              dis[y]:=dis[x]+b[y];
              if not vis[y] then 
                begin
                  vis[y]:=true;
                  inc(t);
                  f[t]:=y;
                end;
            end;
          i:=next[i];
        end;
    end;
  for i:=1 to sum do ans:=max(ans,dis[i]); 
end;//SPFA不想多说
begin
  readln(n,m);
  for i:=1 to n do read(c[i]);
  for i:=1 to m do 
    begin
      readln(x[i],y[i]);
      add(x[i],y[i]);//存边
    end;
  for i:=1 to n do 
    if color[i]=0 then tarjan(i);//如果当前点没有染色则去跑一趟tarjan
  //for i:=1 to n do writeln(color[i]);
  fillword(a,sizeof(a) >> 1,0);
  fillword(next,sizeof(next) >> 1,0);
  fillword(last,sizeof(last) >> 1,0);
  fillword(rd,sizeof(rd) >> 1,0);//清空边
  tot:=0;
  for i:=1 to m do 
    if color[x[i]]<>color[y[i]] then add(color[x[i]],color[y[i]]);//重新建图，注意缩点后每个点的新下表是color[i]
  for i:=1 to sum do 
    if rd[i]=0 then spfa(i);//对于每个入度为0的点去跑SPFA
  writeln(ans);
end.

```

---

## 作者：ghmgjf (赞：4)

#蒟蒻写题解主要是自己看，代码冗长（但比较易懂），常数爆炸，各位大佬不喜勿喷。

首先既然这个题上写了模板二字，那这个题肯定要用tarjan缩点，
但为什么要缩点？因为这个题需要一个DAG，缩完点之后，我们便得到一个了DAG（有向无环图），然后对于由u到v,我们可以得到一个状态转移方程
#f[v]=max(f[v],f[u]+w[v]); 
但是如何保证无后效性？？？我们只需要对缩完的点进行拓扑排序
在排序过程中，就可以转移状态了。。  
代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<map>
#include<queue>
#include<cstring>
using namespace std;
#define ll long long
#define xx 100010
int n,m,w[xx],ta,maxx=-0x7fffffff/2;
int stack[xx],tail,vis[xx],dep,now[xx],tot,low[xx],dfn[xx];//tarjan需要的变量 
int sum[xx],f[xx]; //sum为新节点的权值，f为dp 
int pre[xx],next[xx],head[xx];//拓扑排序所需变量 
queue<int> q;
struct ac
{
	int t,next,head,s,pre;
}e[500010];
void build(int x,int y)
{
	e[++ta].t=y;e[ta].next=e[x].head;
	e[x].head=ta;e[ta].s=x;e[y].pre++;
}//建图 
void tarjan(int x)
{
	low[x]=dfn[x]=++dep;
	stack[++tail]=x;vis[x]=1;
	for(int i=e[x].head;i;i=e[i].next)
	{
		int go=e[i].t;
		if(!dfn[go])
		{
			tarjan(go);
			low[x]=min(low[x],low[go]);
		}
		else
		{
			if(vis[go])
			low[x]=min(low[x],low[go]);
		}
	}
	if(dfn[x]==low[x])
	{
		now[x]=++tot;vis[x]=0;
		while(stack[tail]!=x)
		{
			now[stack[tail]]=tot;vis[stack[tail]]=0;
			--tail;
		}--tail;
	}
}//缩点 
void tupu()//拓扑排序 
{
	for(int i=1;i<=n;++i)
	{
		if(!pre[now[i]]&& !vis[now[i]])
		{
			q.push(now[i]);vis[now[i]]=1;
		}
	}
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=next[i])
		{
			int go=e[i].t;
			pre[now[go]]--;
			f[now[go]]=max(f[now[go]],f[u]+sum[now[go]]);
			if(!pre[now[go]]&&!vis[now[go]])
			q.push(now[go]),vis[now[go]]=1;
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&w[i]);
	}
	
	for(int i=1;i<=m;++i)
	{
		int a,b;scanf("%d%d",&a,&b);
		build(a,b);
	}
	
	for(int i=1;i<=n;++i)
	if(!dfn[i]) tarjan(i);//缩点。 
	
	for(int i=1;i<=n;++i)
	sum[now[i]]+=w[i];//更新缩完点之后的权值。 
	
	for(int i=1;i<=n;++i)//更新图 
	{
		f[now[i]]=sum[now[i]];		
		for(int j=e[i].head;j;j=e[j].next)
		{
			if(now[e[j].t]!=now[e[j].s])
			{
				next[j]=head[now[i]];
				head[now[i]]=j;
				pre[now[e[j].t]]++;
			}
		}
	}
	tupu();//拓扑排序 
	
	for(int i=1;i<=n;++i)
	maxx=max(maxx,f[now[i]]); 
	
	cout<<maxx<<'\n';
	return 0;
}
```

---

## 作者：SNiFe (赞：4)

这道题我用了两种解法（本来是3种的，有一种不可行），但这两种呢，都需要先tarjan缩点再重新建边。

#法一：

##1.tarjan缩点；

##2.重新建边；

##3.bfs（spfa最大路）求最大值；

###代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=100000;
int dfn[N],k=0,low[N],n,m,head[N],color[N],color_time,sta[N],top=0,tim=0,value[N],f[N],ans=0,rd[N],dis[N],x[N],y[N];
bool vis[N];
struct node
{
    int to,next,from;
}edge[N];
void add(int u,int v)
{
    edge[++k].to=v;
    edge[k].from=u;
    edge[k].next=head[u];
    head[u]=k;
}
void tarjan(int s)//缩点
{
    dfn[s]=low[s]=++tim;
    sta[++top]=s;
    vis[s]=true;
    for(int i=head[s],v=edge[i].to;i;i=edge[i].next,v=edge[i].to)
    {
        if(!dfn[v])tarjan(v),low[s]=min(low[s],low[v]);
        else if(vis[v])low[s]=min(low[s],dfn[v]);
    }
    if(low[s]==dfn[s])
    {
        ++color_time;
        vis[s]=false;
        while(sta[top+1]!=s)
        {
            color[sta[top]]=color_time;//染色
            f[color_time]+=value[sta[top]];//求染色后点集权值和
            ans=max(ans,f[color_time]);
            vis[sta[top]]=false;
            top--;
        }
    }
}
void bfs(int x)//spfa最大路
{
    memset(dis,0,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[x]=f[x];
    queue<int>q;
    vis[x]=true;
    q.push(x);
    while(!q.empty())
    {
        int u=q.front();q.pop();vis[u]=false;
        for(int i=head[u],v=edge[i].to;i;i=edge[i].next,v=edge[i].to)
        {
            if(dis[v]<dis[u]+f[v])
            {
                dis[v]=dis[u]+f[v];
                if(!vis[v])
                {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    for(int i=1;i<=color_time;i++)ans=max(dis[i],ans);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&value[i]);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);x[i]=u,y[i]=v;
        add(u,v);
    }
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
    memset(head,0,sizeof(head));
    memset(edge,0,sizeof(edge));
    k=0;
    for(int i=1;i<=m;i++)
    {
        if(color[x[i]]!=color[y[i]])
        {
            add(color[x[i]],color[y[i]]);//重新建边
        }
    }
    for(int i=1;i<=color_time;i++)
    {
        bfs(i);
    }
    printf("%d",ans);
}
```
##1.tarjan缩点；
##2.重新建边；

##3.dfs求最大值（树形DP）；

###代码：


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=100000;
int dfn[N],k=0,low[N],n,m,head[N],color[N],color_time,sta[N],top=0,tim=0,value[N],f[N],ans=0,rd[N],dis[N],zhi[N],x[N],y[N];
bool vis[N];
struct node
{
    int to,next,from;
}edge[N];
void add(int u,int v)
{
    edge[++k].to=v;
    edge[k].from=u;
    edge[k].next=head[u];
    head[u]=k;
}
void tarjan(int s)//缩点
{
    dfn[s]=low[s]=++tim;
    sta[++top]=s;
    vis[s]=true;
    for(int i=head[s],v=edge[i].to;i;i=edge[i].next,v=edge[i].to)
    {
        if(!dfn[v])tarjan(v),low[s]=min(low[s],low[v]);
        else if(vis[v])low[s]=min(low[s],dfn[v]);
    }
    if(low[s]==dfn[s])
    {
        ++color_time;
        vis[s]=false;
        while(sta[top+1]!=s)
        {
            color[sta[top]]=color_time;//染色
            zhi[color_time]+=value[sta[top]];//求染色后点集权值和
            vis[sta[top]]=false;
            top--;
        }
    }
}
int dfs(int x)//树形DP 
{
    if(f[x])return f[x];
    f[x]=zhi[x];
    int maxx=0;
    for(int i=head[x];i;i=edge[i].next)
    {
       int to=edge[i].to;
       if(!f[to])dfs(to);
       maxx=maxx>f[to]?maxx:f[to];
    }
    f[x]+=maxx;
    return f[x];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&value[i]);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);x[i]=u,y[i]=v;
        add(u,v);
    }
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
    memset(vis,false,sizeof(vis));
    memset(head,0,sizeof(head));
    memset(edge,0,sizeof(edge));
    k=0;
    for(int i=1;i<=m;i++)
    {
        if(color[x[i]]!=color[y[i]])
        {
            add(color[x[i]],color[y[i]]);//重新建边
        }
    }
    for(int i=1;i<=color_time;++i)
    if(!f[i])
    {
       dfs(i);
       ans=ans>f[i]?ans:f[i];//取最大值 
    }
    printf("%d",ans);
}
欢迎dalao指正
```

---

## 作者：KGV7 (赞：3)

/\*
先tarjan缩点，然后统计入度为0的点，将它们push到队列中用SPFA跑多源最长路（把点权看做距离）。输出距离最大的距离即可。

\*/
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e4+2,MAXM=1e5+2;
int n,m;
int head[MAXN],edge=0;
struct EDGE {
    int v,nxt;
}e[MAXM];
int dfn[MAXN],low[MAXN],tim=0,snt=0,bel[MAXN];
bool ins[MAXN];
int val[MAXN],sum[MAXN],dp[MAXN];
stack<int> S;
vector<int> G[MAXN];
inline int read() {
    int x=0,f=1;char c=getchar();
    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
inline void adde(int u,int v) {
    e[edge].nxt=head[u],e[edge].v=v,head[u]=edge++;
}
void dfs(int p) {
    S.push(p);
    dfn[p]=low[p]=++tim;
    ins[p]=true;
    for (int i=head[p];~i;i=e[i].nxt) {
        int v=e[i].v;
        if (!dfn[v]) {
            dfs(v);
            low[p]=min(low[p],low[v]);
        }
        else if (ins[v]) low[p]=min(low[p],dfn[v]);
    }
    if (dfn[p]==low[p]) {
        sum[++snt]=0;
        while (!S.empty()) {
            int t=S.top();
            S.pop();
            bel[t]=snt;
            ins[t]=false;
            sum[snt]+=val[t];
            if (t==p) break;
        }
    }
}
int ind[MAXN],vis[MAXN];
queue<int> q;
inline int SPFA() {
    while (!q.empty()) {
        int p=q.front();
        q.pop();
        vis[p]=false;
        for (int i=0;i<G[p].size();++i) {
            int v=G[p][i];
            if (dp[v]<dp[p]+sum[v]) {
                dp[v]=dp[p]+sum[v];
                if (!vis[v]) {
                    q.push(v);
                    vis[v]=true;
                }
            }
        }
    }
    int res=0;
    for (int i=1;i<=snt;++i)
        res=max(res,dp[i]);
    return res;
}
int main() {
    memset(ind,0,sizeof(ind));
    memset(head,-1,sizeof(head));
    memset(dfn,0,sizeof(dfn));
    memset(ins,false,sizeof(ins));
    memset(vis,false,sizeof(vis));
    n=read(),m=read();
    for (register int i=1;i<=n;++i) val[i]=read(),G[i].clear();
    for (register int i=1;i<=m;++i) {
        int u=read(),v=read();
        adde(u,v);
    }
    for (register int i=1;i<=n;++i)
        if (!dfn[i]) dfs(i);
    for (register int p=1;p<=n;++p) {
        dp[p]=sum[p];
        for (int i=head[p];~i;i=e[i].nxt) {
            int v=e[i].v;
            if (bel[p]^bel[v]) G[bel[p]].push_back(bel[v]),++ind[bel[v]];
        }
    }
    for (int i=1;i<=snt;++i)
        if (!ind[i]) q.push(i),vis[i]=true;
    printf("%d\n",SPFA());
    return 0;
}
```

---

## 作者：Great_Influence (赞：3)

看缩点里面还没有一份正常的题解，我就先来交一份。

看题目发现这是一道强联通分量缩点的题（这不废话）。一开始看的时候，看到点权有负，于是当场弃坑。然而数据是我们机房同学出的，他告诉我，这道题其实并没有负权点，不然dp没法做......所以其实还挺简单的。只需要跑一边缩点后在走一遍拓扑就行了。

我用的方法是tarjan，希望没事的人能传一份kasaraju的题解来（虽然不知道kasaraju能不能做）

代码（中间有解释）：

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iostream>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
const int MAXN=20000+100;
const int MAXM=200000+100;
template<typename T>
inline void read(T &x)//读入优化
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&k!='-')k=getchar();
    if(k=='-')
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^'0');
        k=getchar();
    }
    x=s*f;
}
struct edge
{
    int v,next,u;
}p[MAXM],q[MAXM];//存边，分别是一开始输入的边和重新构图后的边
int n,m,w[MAXN],head[MAXN],dfn[MAXN],low[MAXN],l,t,hed[MAXN],va[MAXN],e;//几个数组分别存一开始的权、初始图列式前向星的头↓
int belong[MAXN];//两个tarjan标志性数组、重构图列式前向星的头、重构图的点权和每个点对应的强联通分量
bool vis[MAXN],ins[MAXN];//分别记录是否访问和是否在栈中
void add1(int u,int v)//构初始图
{
    p[++e].u=u;
    p[e].v=v;
    p[e].next=head[u];
    head[u]=e;
}
int poi[MAXN];//栈注意不要用stl的，会re
void tarjan(int u)//tarjan求强联通分量
{
    dfn[u]=low[u]=++e;//记录dfs序
    int v=head[u];
    poi[++t]=u;//入栈
    ins[u]=true;//标记
    while(v)
    {
        if(!vis[p[v].v])//如果没访问过则访问
        {
            vis[p[v].v]=true;
            tarjan(p[v].v);
            low[u]=min(low[u],low[p[v].v]);//求得u的子树中节点所能连接的dfs序最小的节点（low数组的作用）
        }
        else if(ins[p[v].v])low[u]=min(low[u],dfn[p[v].v]);//如果对应节点在栈中，则出现环，更新low
        v=p[v].next;
    }
    if(dfn[u]==low[u])//如果该点的子树无法连接到dfs序比该点dfs序更小的节点，则该点子树的整体构成一个强联通分量
    {
        belong[u]=++l;//记录强联通分量序
        va[l]+=w[u];//加上权值
        ins[u]=false;//出栈
        while(poi[t]!=u)//将栈中u的子树部分全部出栈并标记对应强联通分量，给强联通分量的整体权值加上该点权值
        {
            belong[poi[t]]=l;
            va[l]+=w[poi[t]];
            ins[poi[t--]]=false;
        }
        --t;//记得u也要出栈
    }
}
int in[MAXN],ans,got[MAXN];//分别记录每个强联通分量的入度、答案、抵达这个强联通分量可得的最大权值
void add2(int u,int v)//重构图
{
    q[++e].v=v;
    q[e].next=hed[u];
    hed[u]=e;
}
queue<int>G;//偷懒打stl，其实最好手打，不然与上面那个栈一样......
void dp(void)//说是dp其实核心是按拓扑序遍历
{
    while(!G.empty())
    {
        int u=G.front(),v=hed[u];
        G.pop();
        while(v)
        {
            got[q[v].v]=max(got[q[v].v],got[u]+va[q[v].v]);//简单的dp方程：got[i]=max(got[j]+w[i])(存在边(j,i))
            ans=max(ans,got[q[v].v]);
            --in[q[v].v];//入度减1
            if(!in[q[v].v])G.push(q[v].v);//若入度减为0，则将该点入队。这样入队可以省时间复杂度，保证每个点只入队1次。
            v=q[v].next;
        }
    }
}
int main()
{
    read(n);
    read(m);
    int i,u,v,z;
    For(i,1,n)read(w[i]);
    For(i,1,m)//构图
    {
        read(u);
        read(v);
        add1(u,v);
    }
    For(i,1,n)if(!vis[i])//一次次跑tarjan。注意图不一定联通
    {
        e=0;
        vis[i]=true;
        tarjan(i);
    }
    e=0;
    For(i,1,m)if(belong[p[i].u]!=belong[p[i].v])//重构图
    {
        add2(belong[p[i].u],belong[p[i].v]);
        ++in[belong[p[i].v]];
    }
    For(i,1,l)if(in[i]==0)//记录应入队点（即入度为0的点）
    {
        G.push(i);
        got[i]+=va[i];
        ans=max(ans,va[i]);//注意这里。如果最大答案中只有1个强联通分量，则不加这一行的话就会wa。其实样例就是这样。
    }
    dp();//叫拓扑应该会更好
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：唔啊唔 (赞：3)

作为模板题，这道题的题解还真的有点多耶，但这道题卡了我足足一天，我认为不写一篇题解难解我心头之恨，希望管理员大大可以让我通过

这道题题解中有的大佬是用dp算法来求缩点后的最大点权值之和

而身为蒟蒻的我就只会用Dijkstra算法来跑几次最长路了

如果大家想要学习基本的tarjan模板，请看[这道题](https://www.luogu.org/problem/P2863)更适合初学者

再推荐给大家一篇[文章](https://blog.csdn.net/qq_34374664/article/details/77488976)，里面讲的很详细

解释就都写在代码中了吧：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int n,m,a[N],dfn[N],low[N],num,head[N],cnt,vis[N],tot,sum[N],bj[N],head2[N],dis[N];
//bj[]:标记该节点属于第几个强连通分量,sum[]:该强连通分量的总和
//dfn,low,vis:tarjan模板   dis[]:Dijkstra模板 
struct Edge{
	int from,to,next;
}edge[N],bian[N];
//edge[]:存最初的边   bian[]:存缩点后的边 
inline void add(int from,int to){
	num++;
	edge[num].to=to;
	edge[num].next=head[from];
	head[from]=num;
}
//基本的前向星存边 
stack<int>s;	//建栈 
inline void tarjan(int x){	//这下面就是我之所以卡了一天的原因了 
	cnt++;					//不知道为何我写一个tarjan模板都能出玄学错误 
	dfn[x]=low[x]=cnt;		//所以最后搬运了我一篇别的题目的代码才把这道题A掉 
	s.push(x);				
	vis[x]=1;
	for(register int i=head[x];i;i=edge[i].next){
		int y=edge[i].to;
		if(dfn[y]==0){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(vis[y]==1){
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(low[x]==dfn[x]){
		int z;
		tot++;
		while(s.top()!=x){
			z=s.top();
			sum[tot]+=a[z];
			vis[z]=0;
			bj[z]=tot;
			s.pop();
		}
		z=s.top();
		sum[tot]+=a[z];
		vis[z]=0;
		bj[z]=tot;
		s.pop();
	}
	return;
}
inline void add2(int from,int to){
	num++;
	bian[num].from=from;
	bian[num].to=to;
	bian[num].next=head2[from];
	head2[from]=num;
}
inline int dij(int x){	//Dijkstra算法最长路模板 
	memset(vis,0,sizeof(vis));
	priority_queue<pair<int,int> >q;
	dis[x]=sum[x];
	q.push(make_pair(dis[x],x));
	while(!q.empty()){
		int tmp=q.top().second;
		q.pop();
		if(vis[tmp]==1)continue;
		vis[tmp]=1;
		for(int i=head2[tmp];i;i=bian[i].next){
			int k=bian[i].to;
			if(dis[k]<dis[tmp]+sum[k]){
				dis[k]=dis[tmp]+sum[k];
				q.push(make_pair(dis[k],k));
			}
		}
	}
	int maxn=0;
//由于我们无法知道终点在哪，所以需要都找一遍，即使最大值是原来跑最长路存下来的值也没有关系 	
	for(register int i=1;i<=tot;i++)	
		maxn=max(maxn,dis[i]);
	return maxn;
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	int x,y;
	for(register int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(register int i=1;i<=n;i++){
		if(dfn[i]==0)
			tarjan(i);
	}
	num=0;
	for(register int i=1;i<=n;i++){	//缩点即把每一个强联通分量看做一个点 
		for(register int j=head[i];j;j=edge[j].next){//再用这几个点来重建一张图来跑最长路 
			int y=edge[j].to;
			if(bj[i]!=bj[y]){
				add2(bj[i],bj[y]);
			}
		}
	}
	int ans=0;
	for(register int i=1;i<=tot;i++){//由于每一个点不一定都连通所以要跑多次最长路 
		ans=max(ans,dij(i));
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：林志杰 (赞：3)

解释一下dfn和low的含义，前者存时间戳，也就是某点第几次被访问到。

后者则是某点能够达到的点的时间戳（们）中的最小值。

这点结合大佬的博客里的图去理解 :http://www.cnblogs.com/shadowland/p/5872257.html(不是我的，，，)

感觉代码里的注释已经够详细了，就不多说了









```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 1e5+15;
const int maxm = 1e6+15;
struct edge{
    int nxt,to;
}e[maxn];//前向星表示法 
int first[maxn],cnt=0;
int q[maxn],t=0;
int n,m,a[maxn],b[maxn],vis[maxn],Time=0,dfn[maxn],low[maxn];//vis进行染色
int X[maxm],Y[maxm];//存边在缩点时用
int dis[maxn],inn[maxn];//前者存最短路，后者存入度 
bool book[maxn];
int pnt=0;//代表新点的数量
int ans;
void addedge(int u,int v)
{
    e[++cnt] = (edge) {first[u],v};
    first[u] = cnt;
    ++inn[v];
}
void tarjan(int x)
{
    dfn[x]=++Time;low[x]=Time;//记录时间戳和一开始的low
    q[++t]=x;book[x]=true;//放入当前栈
    for(register int i=first[x],v;i;i=e[i].nxt) {
        v = e[i].to;
        if(!dfn[v]) {//如果v是新点
            tarjan(v);
            low[x] = min(low[x],low[v]); 
        }
        else if(book[v]) low[x]=min(low[x],dfn[v]);//low是某点能够达到的点的时间戳（们）中的最小值。
    }
    if(low[x] == dfn[x] && ++ cnt) {//跑完了整个强连通分量 
        do{
            vis[q[t]] = cnt;
            book[q[t]] = false;
            b[cnt] += a[q[t]];
        }while(q[t--] != x);//不断弹出栈并进行染色 
    }
}
int Q[maxn];
void SPFA(int x)
{
    memset(book,0,sizeof(book));
    memset(dis,0,sizeof(dis));
    int h=1,t=0;
    Q[++t] = x;book[x] = true;
    dis[x] = b[x];
    while(h <= t) {
        x = Q[h++];book[x] = false;
        for(register int i=first[x],v;i;i=e[i].nxt) {
            v = e[i].to;
            if(dis[v] < dis[x] + b[v]) {
                dis[v] = dis[x] + b[v];
                if(!book[v]) {
                    Q[++t] = v;
                    book[v] = true;
                }
            }
        }
    }
    for(int i=1;i<=pnt;i++) ans = max(ans,dis[i]);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(register int i=1;i<=m;i++) {
        scanf("%d%d",&X[i],&Y[i]);
        addedge(X[i],Y[i]);//单向建边
    }
    cnt = 0;//重新利用,暂时代表新点的数量 
    for(register int i=1;i<=n;i++) {
        if(!vis[i]) tarjan(i);//对没有进行染色的点执行操作
    }
    memset(first,0,sizeof(first));
    memset(inn,0,sizeof(inn));
    swap(pnt,cnt);
    for(register int i=1,Xx,Yy;i<=m;i++) {//对新图连边
        Xx =  vis[X[i]];Yy = vis[Y[i]];
        if(Xx != Yy) {//如果边的两个端点没有被缩到一起 
            addedge(Xx,Yy);//连边，有重边也无所谓
        }
    }
//新图建好了，在新图上跑SPFA
    for(int i=1;i<=pnt;i++) if(!inn[i]) {
        SPFA(i);//只对某条路径的起点跑 
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Lskkkno1 (赞：2)

此题解部分借鉴于[九野的博客](https://blog.csdn.net/acmmmm/article/details/16361033)

### 题目分析

- 给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。
- 允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。

- 假如没有后面这条限制的话,那图一定是一个**无环图**。因为有环的话我可以一直在环上跑，所以答案就没有一个上界

- 没有环的话我萌可以很自然地想到一个 $O(n)$ 的 拓扑$dp$ 做法，先做入度为 $0$ 的点，更新入度不为 $0$ 的点，把更新后入度为 $0$ 的点加入队列里，继续做之前的事情

- 现在考虑有环怎么做

- 有一个贪心的思路是，到环上就先把**环上的点**都走完，再从**环上任意一点**出发

- 其实这个环可以看做一个**大点**，也就是我们今天要介绍的主角 $\to$ **缩点**

------

### tarjan缩点

下面这张图是从 [九野的博客](https://blog.csdn.net/acmmmm/article/details/16361033) 那 **copy** 过来的

![](https://cdn.luogu.com.cn/upload/image_hosting/caibf800.png)

- 把可以互相抵达的**点集**叫做一个**连通分量**
- 最大的那个可以互相抵达的点**点集**即为**强连通分量**
- 特别的，单个的点也可以是**强连通分量**

> 比如说 ：$\{ 4, 5 \}$ 是一个**联通分量**，而 $\{4,5,6 \} $ 则是一个**强连通分量**（一个大点）

tarjan的过程就是通过 **dfs** 找强连通分量（大点）的过程


> 对图**dfs**一下，遍历所有未遍历过的点 ，会得到一个[有向树](http://baike.baidu.com/link?url=CkM7EiHiG9MSdQcAKwF4oReg83XHA1pz7BtrS4WWhqBjfhWRvAwCGaqlNIJ_d5ssAS1NgpMIDbwkNx_IPIsYpa)，显然有向树是没有环的。（注意搜过的点不会再搜

> 则能产生环的 $\color {red} \text {只有（指向已经遍历过的点）的边}$

我们发现 $7 \to 3$ （$\color {red} \text {红边}$  /  横叉边）这种边一定不会产生**连通分量**

而 $6 \to 4$ （$\color {green} \text {绿边}$ /  返祖边）这种边一定会产生**联通分量**

具体来说：具有**父子关系**的边一定会产生联通分量

我们在**dfs**的时候需要用一个**栈**来保存当前所在路径上的点$\color {red} \text {（栈中所有点一定是有父子关系的）}$

我们用一些数组来表示**dfs**的过程

```cpp
int tim, dfn[MAX], low[MAX]
```

$dfn[i]$ 表示遍历到节点 $i$ 的时间戳（第几次遍历）

$low[i]$ 表示往上可以到达最早的点

初始化 $dfn[i] = low[i] = ++tim$

我们可以根据上面过程的步骤写出以下代码

```cpp
    for(int i = head[u]; i; i = nex[i]) {
        if(dfn[to[i]]) {
            if(instack[to[i]]) {
            	if(low[to[i]] < low[u]) {
                	low[u] = low[to[i]];
                }
            }
        } else {
            dfs(to[i]);
            if(low[to[i]] < low[u]) {}
            	low[u] = low[to[i]];
        	}
        }
    }
```



假如当前节点 $u$， $dfn[u] == low[u]$ 那就说明**栈顶元素**一直到节点 $u$ 都属于一个**强联通分量**，~~感性理解~~

把栈中元素弹出并且把他们都给标记为同一种颜色（同一个强连通分量）

```cpp
    if(dfn[u] == low[u]) {
        ++totcol;
        do {
            int v = stk[top];
            col[v] = totcol;
            instack[v] = false;
        } while(stk[top--] != u);
    }
```

具体实现看代码~~不早说~~

[$\color {Deepskyblue} {Code}$](https://www.luogu.com.cn/paste/zkvhftxg)

这里还有一道 [tarjan练手好题](https://www.luogu.com.cn/problem/P4611)

---

## 作者：ljk123 (赞：2)

# 缩点(有向图的强联通分量)学习笔记

### 1.什么是强连通分量？：



------------

有向图强连通分量:在有向图G中，如果两个顶点vi,vj间(vi>vj)有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。——度娘

------------
显然正确，~~但是文绉绉的又难懂~~。

其实就是有一大团点，它们之间可以互相到达，那么这一大团点就是有向图的一个强联通分量。

一个强连通分量可以看作一个或几个环拼接在一起。

如：
![缩点](https://www.cnblogs.com/images/cnblogs_com/ljk123-de-bo-ke/1441553/o_1655789-20190411204952714-498542190.png)

### 2.如何操作？：

首先对于整个有向图进行dfs，若dfs树中存在子树有到达父亲节点，从父亲到这个点则都可互相到达，为一个强连通分量。
![缩点](https://www.cnblogs.com/images/cnblogs_com/ljk123-de-bo-ke/1441553/t_1655789-20190411144457085-412109554.png)


如上图。

#### 所以我们判断一个点是否在一个强连通分量中，就用它是否能到达dfs序比他小的点。

但我们如何将一个强连通分量的点记录呢？

答：用一个栈储存，遇到一个不能到达dfs序比他小的点的点，就将栈里的点都标记为一个新的强连通分量，再清空栈（一个点我们也看作一个强连通分量）。

我们用dfn数组记录dfs序，low数组记录能到达的点最小的dfs编号。

#### 对于每一个点，需要用它的儿子的low来更新自己的low,如上图中的2号点;

同理可得，若有连向祖辈的边，直接用祖辈的dfn来更新自己的low。（当然用low来更新也不会错）

还有，注意：对于已经属于一个强连通分量的点，不能用它的low来更新连向它的点！

![缩点](https://www.cnblogs.com/images/cnblogs_com/ljk123-de-bo-ke/1441553/o_1655789-20190411151341691-414481838.png)

所以，low[5]为5。


------------

```cpp
void tarjan(int u)//当前点
{
    low[u]=dfn[u]=++deep; x[++top]=u; v[u]=1;
    for(int i=head1[u];i;i=e[i].nxt)
    {
        if(!dfn[e[i].to]) tarjan(e[i].to),low[u]=min(low[u],low[e[i].to]);//连向儿子的边
        else if(v[e[i].to]) low[u]=min(low[u],dfn[e[i].to]);//连向父亲且不属于一个强连通分量
    }
   if(dfn[u]==low[u])//找到一个强连通分量
   {
        num[u]=++tot; v[u]=0;
        while(x[top]!=u) v[x[top]]=0,num[x[top]]=tot,--top;
        --top;
     }
}
int main()
{
    for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);
    return 0;
}
```


------------

最后，模拟一个图的tarjan过程：


![缩点](https://www.cnblogs.com/images/cnblogs_com/ljk123-de-bo-ke/1441553/o_1655789-20190411152306047-552160992.png)
 

一共有一个强连通分量:1.{1,2,3,4,5,6,7,8,9}。

u=1:dfn[1]=1,++top,x[1]=1,tarjan(8);

u=8:dfn[8]=2,++top,x[2]=8,tarjan(9);

u=9:dfn[9]=3,++top,x[3]=9,low[9]=1;

u=8:low[8]=1;

u=1:tarjan(2);

u=2:dfn[2]=4,++top,x[4]=2,tarjan(3);

u=3:dfn[3]=5,++top,x[5]=3,tarjan(4);

u=4:dfn[4]=6,++top,x[6]=4,low[4]=low[2]=4;

u=3:low[3]=low[4]=4;

u=2:low[2]=4,tarjan(5);

u=5:dfn[5]=7,++top,x[7]=5,tarjan(6);

u=6:dfn[6]=8,++top,x[8]=6,tarjan(7);

u=7:dfn[7]=9,++top,x[9]=7,low[7]=1;

u=6:low[6]=1;

u=5:low[5]=1;

u=2:low[2]=1;

u=1:dfn[1]==low[1]=1→++tot,将x[1]到x[9]标记为tot=1,top=0;

结束。

### 3.缩点：

将每个强联通分量看作一点，将所有连向强联通分量内的点连向这个强联通分量。


------------

```cpp
int main()
{
    n=read(); m=read();
    for(int i=1;i<=n;++i) w1[i]=read();
    for(re int i=1;i<=m;++i) t1=read(),t2=read(),add(t1,t2,e,head1);
    cnt=0;
    for(int i=1;i<=n;++i)
    {
        w2[num[i]]+=w1[i];
        for(int j=head1[i];j;j=e[j].nxt) if(num[i]!=num[e[j].to]) add(num[i],num[e[j].to],f,head2),++rd[num[e[j].to]];
    }
    return 0;
}
```


------------
洛谷P3387 【模板】缩点

题解:

当进入一个强连通分量时，肯定将这个强连通分量都走一遍，所以缩点，变为一个DAG（有向无环图），然后按拓扑序dp，每个点的答案为所有能到达它的点的答案的最大值+自己的点值，输出所有点中答案的最大值。

用每个点的答案更新它所能到达的所有点的答案。

代码如下：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
const int N=10006,M=100006;
int n,m,t1,t2,w1[N],w2[N],num[N],cnt=0,head1[N],t,tot=0,head2[N],x[N],dfn[N],low[N],ans[N],maxa=-1,rd[N],deep=0,top=0,v[N];
struct edge
{
	int to,nxt;
}e[M],f[M];
inline void add(int u,int v,edge a[],int head[]){a[++cnt].to=v,a[cnt].nxt=head[u],head[u]=cnt;}
inline int read()
{
	int T=0,F=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
	return F*T;
}
void tarjan(int u)
{
	low[u]=dfn[u]=++deep; x[++top]=u; v[u]=1;
	for(int i=head1[u];i;i=e[i].nxt)
	{
		if(!dfn[e[i].to]) tarjan(e[i].to),low[u]=min(low[u],low[e[i].to]);
		else if(v[e[i].to]) low[u]=min(low[u],dfn[e[i].to]);
	}
	if(dfn[u]==low[u])
	{
		num[u]=++tot; v[u]=0;
		while(x[top]!=u) v[x[top]]=0,num[x[top]]=tot,--top;
		--top;
	}
}
void tppx()
{
    queue<int> q; cnt=0;
	for(int i=1;i<=tot;++i) if(!rd[i]) x[++cnt]=i,q.push(i);
	while(!q.empty())
	{
		int tmp=q.front(); q.pop();
		for(int i=head2[tmp];i;i=f[i].nxt)
		{
			--rd[f[i].to];
			if(!rd[f[i].to]) x[++cnt]=f[i].to,q.push(f[i].to);
		}
	}
}
int main()
{
	n=read(); m=read();
	for(int i=1;i<=n;++i) w1[i]=read();
	for(re int i=1;i<=m;++i) t1=read(),t2=read(),add(t1,t2,e,head1);
	for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);
	cnt=0;
	for(int i=1;i<=n;++i)
	{
		w2[num[i]]+=w1[i];
		for(int j=head1[i];j;j=e[j].nxt) if(num[i]!=num[e[j].to]) add(num[i],num[e[j].to],f,head2),++rd[num[e[j].to]];
	}
	memset(x,0,sizeof(x)); tppx();
	for(int i=1;i<=n;++i)
	{
		t=x[i]; ans[t]=max(ans[t],w2[t]);
		maxa=max(maxa,ans[t]);
		for(int j=head2[t];j;j=f[j].nxt) ans[f[j].to]=max(ans[f[j].to],ans[t]+w2[f[j].to]);
	}
	printf("%d\n",maxa);
	return 0;
}
```

 

---

## 作者：llllllQ (赞：2)

****Tarjan+SPFA****

先tarjan存连通分量

证明：当还有临接点未搜索时所得最大点权和一定小于搜索完所有结点最大点权和，

体现在图中是最大点权和一定包涵一个出度为零的节点，

此时反向建图用SPFA更新D数组（D数组不断更新的值为该节点已知最大点权和），

反向建图时正像图中出度为零的点在向图中的体现为入度为零，

这时引入0点向这些入度为零的点引边以补全单源路径问题（如果不这样做则D数组无法更新）

SPFA结束时D数组最大值为答案

```cpp
#include<cstdio>
#include<stack>
#include<queue>
#include<memory.h>
#define MAXN 10005
#define MAXM 100005
using namespace std;
stack<int> S;
queue<int> Q;
int next[MAXM];//链式前向星
int head[MAXN];//链式前向星
int DFN[MAXN];//时间戳
int LOW[MAXN];//tarjan必用数组（说实话我不知道这个怎么称呼）
int COL[MAXN];//涂色
int CNT[MAXM];//记录色块总权重
int IND[MAXN];//记录单点入度
int value[MAXN];//记录每个结点权重
int D[MAXN];//记录由原点到每个点的最大权重
bool V[MAXN];
int n,m,tm,id,tot;
struct edge
{
	int x,y;
} E[MAXM];//边集数组 
void init()//初始化
{
	memset(next,0,sizeof(next));
	memset(head,0,sizeof(head));
	memset(IND,0,sizeof(IND));
	id=0;
}
void ADD(int a,int b)//链式前向星 
{
	id++;
	E[id].x=a;
	E[id].y=b;
	next[id]=head[a];
	head[a]=id;
	IND[b]++;//存图时记录入度 
}
void SCAN()
{
	scanf("%d %d",&n,&m);
	int i;
	for(i=1; i<=n; i++)
		scanf("%d",&value[i]);
	for(i=1; i<=m; i++)
	{
		int a,b;
		scanf("%d %d",&a,&b);
		ADD(a,b);
	}
}
void TJ(int x)//tarjan 
{
	DFN[x]=LOW[x]=++tm;
	S.push(x);
	V[x]=1;
	int i;
	for(i=head[x]; i; i=next[i])
	{
		int y=E[i].y;
		if(!DFN[y])
		{
			TJ(y);
			LOW[x]=min(LOW[x],LOW[y]);
		}
		else if(V[y])
			LOW[x]=min(LOW[x],LOW[y]);
	}
	if(DFN[x]==LOW[x])
	{
		int y=0;
		tot++;
		while(x!=y)
		{
			y=S.top();
			S.pop();
			V[y]=0;
			COL[y]=tot;
			CNT[tot]+=value[y];
			//这里CNT数组存入每个连通分量的结点权重和 
		}
	}
}
void MKMP()//将连通分量当作单一结点存入新图 
{
	int i;
	for(i=1; i<=m; i++)
	{
		int x=E[i].x,y=E[i].y;
		if(COL[x]!=COL[y])
			ADD(COL[x],COL[y]);
	}
	n=tot;
	m=id;
	for(i=1; i<=n; i++)
		if(!IND[i])
			ADD(0,i);
//由0点向各个入度为零的点引入一条边，符合单源路径刷新 
//之所以向入度为零得点引边，是因为当入度非零结点前驱结点权重大于零刷新D值永小于以入度为零结点为起点刷新D值 
	m=id;
}
int SPFA(int s)
{
	D[s]=value[s];
	int ans=-21474836;
	memset(V,0,sizeof(V));
	memset(D,0,sizeof(D));
	V[s]=true;
	Q.push(s);
	while(!Q.empty())
	{
		int x=Q.front();
		Q.pop();
		V[x]=0;
		int i;
		for(i=head[x]; i; i=next[i])
		{
			int y=E[i].y;
			if(D[y]<D[x]+CNT[y])
			{
//当前驱结点已经过的权重和加上自身权重的和大于自身已经确定的权重路径和时更新 
				D[y]=D[x]+CNT[y];
				ans=max(D[y],ans);
				if(!V[y])
				{
					Q.push(y);
					V[y]=1;
				}
			}
		}
	}
	return ans;
}
int main()
{
	init();//初始化
	SCAN();//读入
	int i;
	for(i=1; i<=n; i++)
		if(!DFN[i])
			TJ(i);//挨个tarjan
	init();//初始化
	MKMP();//反向建图
	printf("%d",SPFA(0));
	return 0;
}
```

---

## 作者：ddwqwq (赞：2)

大家都是用Tarjan缩点做的，然而本人并不会这种算法，用的是另一种不知姓名的方法。思路：首先dfs求拓扑排序，之后在转置图上以拓扑排序的顺序dfs，每次到达的点属于一个强连通分量（然而我不知道为什么不能在原图上逆序搜索）。搜索同时建立新图，最后dp求解。

```cpp
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>

using namespace std;

struct node {
    int aim;
    node *next;//邻接表
};

int stack[50005], stack_size;//栈
void push(int k)
{
    stack[stack_size++] = k;
}
int pop()
{
    stack_size--;
    return stack[stack_size];
}
int top()
{
    return stack[stack_size - 1];
}

void add(node *&head, int aim)//邻接表增加结点
{
    node *p = new(node);
    p->aim = aim;
    p->next = NULL;
    if (head == NULL)
        head = p;
    else
    {
        p->next = head;
        head = p;
    }
}

node *head[10005], *head1[10005], *head2[10005];//原图，转置图，无环分量图
int f[10005], time, N, M;//dfs完成时间，时间，点数，边数
int N1, mark[10005];//无环分量图结点数，给各个分量图打上不同标记
int w[10005], w1[10005];//原图点权，无环分量图点权

void dfs_visit(int i)
{
    node *p = head[i];
    f[i] = 1;
    while (p != NULL)
    {
        if (f[p->aim] == 0)
            dfs_visit(p->aim);
        p = p->next;
    }
    time++;
    f[i] = time;//其实不用记录时间，做个标记就行，这里有点画蛇添足
    push(i);
}

void dfs()//第一次搜索，拓扑排序
{
    for (int i = 1; i <= N; i++)
        if (f[i] == 0)
            dfs_visit(i);
}

void dfs_visit1(int i)
{
    mark[i] = N1;//在转置图上搜索
    node *p = head1[i];
    while (p != NULL)
    {
        if (mark[p->aim] == 0)
            dfs_visit1(p->aim);
        else if (mark[p->aim] != N1)
            add(head2[N1], mark[p->aim]);
        p = p->next;
    }
    w1[N1] += w[i];
}

void dfs1()//第二次搜索
{
    for (int i = 1; i <= N; i++)
    {
        int j = pop();
        if (mark[j] == 0)
        {
            N1++;
            dfs_visit1(j);
        }
    }
}
int d[10005];
int dfs2(int i)//最后的dp
{
    if (d[i] != 0)
        return d[i];

    int max = 0;
    node *p = head2[i];
    while (p != NULL)
    {
        if (dfs2(p->aim) > max)
            max = dfs2(p->aim);
        p = p->next;
    }
    return d[i] = max + w1[i];
}

int main()
{
    int i, u, v;

    scanf("%d %d", &N, &M);

    for (i = 1; i <= N; i++)
        scanf("%d", &w[i]);
    for (i = 0; i < M; i++)
    {
        scanf("%d %d", &u, &v);
        add(head[u], v);//原图
        add(head1[v], u);//转置
    }

    dfs();
    dfs1();

    int max = 0;
    for (i = 1; i <= N1; i++)
        if (dfs2(i) > max)
            max = dfs2(i);

    printf("%d", max);

    system("pause");
    return 0;
}
```

---

## 作者：kczno1 (赞：2)

根据讨论里的话，我应该是对了。(希望有管理员对此题数据做出解释或修改)

tarjan模板


```cpp
#include<bits/stdc++.h>

void chmin(int &x,int y)
{
    if (x>y) x=y;
}
void chmax(int &x,int y)
{
    if (x<y) x=y;
}

const int p=100000+10;
int i,x,y;
int w[p],t[p];
int l[p*10*2][2];

int num;
int qiang[p];//所在强连通分量
struct fen
{
  int t,f,s;
};
fen q[p];

int dfn[p],low[p],stack[p];//dfn 访问的时间,low 最早的可通到的时间,stack 栈
bool ing[p];//是否在栈中
void dfs(int u)
{
    low[u]=dfn[u]=++x;//x是当前的时间
    stack[++y]=u;ing[u]=1;//y是栈中的个数
    
    int v;
    for (int i=t[u];i;i=l[i][1])
      if (!dfn[(v=l[i][0])]) 
      {
          dfs(v);
          chmin(low[u],low[v]);
      }  
      else 
      if (ing[v]) chmin(low[u],dfn[v]);//不在栈中的v一定到不了u,所以不能让v影响u
    
    if (low[u]==dfn[u])
    {
        qiang[u]=++num;ing[u]=0;
        while ( (v=stack[y--])!=u )
        {
            qiang[v]=num;ing[v]=0;
        }
    }
}

int f(int x)
{
    if (!q[x].f)
    {
        for (int i=q[x].t;i;i=l[i][1])
         chmax(q[x].f,f(l[i][0]));
        q[x].f+=q[x].s;
    }
    return q[x].f;
}

int main()
{
    freopen("1.in","r",stdin);
    
    int n,m,i;
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;++i) scanf("%d",&w[i]);
    for (i=1;i<=m;++i)
    {
      scanf("%d%d",&x,&y);
      l[i][1]=t[x];t[x]=i;l[i][0]=y;  
    }
    
    x=y=0;
    for (i=1;i<=n;++i)//全图不一定联通，所以都要尝试
    if (!dfn[i])
     dfs(i);
    
    //构造q之间的新图，得到每个q的s:该分量的点权和 
    int now,v;
    for (x=1;x<=n;++x)
    {
        now=qiang[x];
        q[now].s+=w[x];
        for (i=t[x];i;i=l[i][1])
        if ( (v=qiang[l[i][0]])!=now )
        {
          l[++m][1]=q[now].t;q[now].t=m;l[m][0]=v;
        }
    }

    //之后就用记忆化搜索
    int ans=0;
    for (i=1;i<=num;++i) chmax(ans,f(i));
    printf("%d",ans);
}
```

---

## 作者：abandentsky (赞：2)

题意：这个题目的意思说的很清楚，就不多说了。
思路：跑一边强连通分量的模板，然后开始dp，或者说是记忆化搜索。代码说的很清楚，不累赘叙述了。上代码：
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 10005
#define maxnode 1000005
#define sigma_size 26
#define md 12345678
#define INF 0x3f3f3f3f
#define pii pair<int,int>
using namespace std;

int n,m;
struct Edge
{
    int from,to;
    Edge(int from=0,int to=0):from(from),to(to){};
};
vector<Edge> edges;
vector<int> G[MAXN];
vector<int> mp[MAXN];
stack<int> S;
int sccno[MAXN],lowlink[MAXN],pre[MAXN],val[MAXN],tg[MAXN];
int dfs_clock,scc_cnt,dp[MAXN];                     //dp数组用来表示每个缩点后的子结构最大价值

void dfs(int u)                                                     //找强连通分量
{
    pre[u]=lowlink[u]=++dfs_clock;
    S.push(u);
    for(int i=0;i<G[u].size();i++)
    {
        Edge &e=edges[G[u][i]];
        int v=e.to;
        if(!pre[v])
        {
            dfs(v);
            lowlink[u]=min(lowlink[u],lowlink[v]);
        }
        else if(!sccno[v])
        {
            lowlink[u]=min(lowlink[u],pre[v]);
        }
    }
    if(lowlink[u]==pre[u])                                      //记录强连通分量的归属
    {
        scc_cnt++;                                                       //强连通分量的编号
        for(;;)
        {
            int x=S.top();
            S.pop();
            sccno[x]=scc_cnt;
            if(x==u)
                break;
        }
    }
}

void Find_scc(int n)                     //强连通分量的主程序
{
    dfs_clock=scc_cnt=0;
    memset(sccno,0,sizeof(sccno));
    memset(pre,0,sizeof(pre));
    for(int i=1;i<=n;i++)
        if(!pre[i])
          dfs(i);
}

int tree_dfs(int u)                                   //执行记忆化搜索
{
    if(dp[u]!=-1)                                          //不为-1表示该节点已经被搜索过
        return dp[u];
    if(mp[u].size()==0)                             //是子节点就直接返回
        return dp[u]=tg[u];
    int maxn=0;                                            //找儿子节点的最大值
    for(int i=0;i<mp[u].size();i++)
    {
        int v=mp[u][i];
        maxn=max(maxn,tree_dfs(v));
    }
    return dp[u]=maxn+tg[u];                //儿子中的最大值加上这个节点的值就是该节点的价值
}

void tarjain()
{
    memset(dp,-1,sizeof(dp));
    Find_scc(n);
    for(int i=1;i<=n;i++)
        tg[sccno[i]]+=val[i];                              //计算出缩点以后的价值
    for(int i=0;i<m;i++)                              //重新构图
    {
        Edge &e=edges[i];
        int xx=sccno[e.from];
        int yy=sccno[e.to];
        if(xx!=yy)                                               //由from指向to
            mp[xx].push_back(yy);
    }
    int maxn=0;                                              //找到最大值
    for(int i=1;i<=scc_cnt;i++)
    {
        maxn=max(maxn,tree_dfs(i));         //搜索
    }
    printf("%d\n",maxn);
}

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&val[i]);
    int u,v;
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d",&u,&v);
        edges.push_back({u,v});
        int mm=edges.size();
        G[u].push_back(mm-1);
    }
    tarjain();
    return 0;
}

```


---

## 作者：Michael_Li (赞：2)

这道题有点小坑，第一遍交上去只有四十分，然后五彩缤纷，4个ac，3个tle，1个wa，2个re，哈哈哈。然后把maxn和maxm开大了十倍，变成六个ac，四个wa，所以洛谷有的时候tle是其他原因导致的。

最后没有考虑每个强连通分量互相独立的情况，加上特判之后ac了。

具体的程序实现看代码注释。

这篇代码只提供ac代码的讲解，而思路可以参考其他代码，感觉写的还是蛮清楚的。

```cpp
#include<cstdio>
#include<algorithm>
#define N (100000+10)
#define M (1000000+10)
using namespace std;
int a[N*2], head[N*2], nxt[M*2], cnt, low[N], dfn[N], st[N], top, g[N], ne, rd[2*N], que[N], tail, h, data[2*N], ma, k, ff[2*N];//注意有加上虚拟点的边开两倍大小
bool bst[N], bb[2*N];
inline void add (int x, int y) {//邻接表存图
    a[++k] = y; nxt[k] = head[x]; head[x] = k;
}
inline void pop(int u) {//tarjan强连通分量缩点，我是将n+1-->ne 设为虚拟点，后面的dp也只在虚拟点中搞（机房大佬都是再开一套数组的%%%orz）
    ne++;//虚拟点
//    printf("ne == %d\n",ne);
    while (st[top] != u) {//弹栈，注意u最好也弹掉
        //printf("%d %d\n",st[top],top);
        g[st[top]] = ne;//g存虚拟点的编号
        bst[st[top]] = false;//出栈
        data[ne] += data[st[top]];//虚拟点的点权等于所有包含点的点权之和
        top--;
    }  
    //printf("%d\n\n\n\n\n", u);
    g[u] = ne; bst[u] = false; data[ne] += data[u]; top--;//u也要处理
}
void tarjan(int u) { //tarjan，我的另一篇tarjan题解里有详细的解释，这里就不做过多注释了
    dfn[u] = low[u] = ++cnt;//dfn和low的定义不多讲
    st[++top] = u;
    bst[u] = true;//压栈
    for (int p = head[u]; p; p = nxt[p]){//遍历边
        int v = a[p];
        if (!dfn[v]) {
            tarjan(v);//tarjan递归
            low[u] = min(low[u], low[v]);//low值更新
        }
        else if (bst[v]) low[u] = min(low[u], dfn[v]);//low值更新
    }
    if (low[u] == dfn[u]) pop(u);
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    ne = n;//从n+1开始，因为是先++，所以初值赋为n
    for (int i = 1; i <= n; i++) scanf("%d",&data[i]);//data[i]为点权
    for (int i = 1; i <= m; i++){
        int x, y;
        scanf("%d%d", &x, &y);
        add(x, y);
    }
    for (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);//因为图不一定全联通，所以这样保证每个点都扫到
    for (int i = 1; i <= n; i++) {
        for (int p = head[i]; p; p = nxt[p]){
            if (g[i] == g[a[p]]) continue;//注意自己和自己不要连边
            else
            add(g[i], g[a[p]]), rd[g[a[p]]]++;//记录入度，为后面的拓扑做铺垫
        }
    }
    for (int i = n+1; i<= ne; i++) {
        if (rd[i] == 0) que[++tail] = i;//注意一开始把所有入度为0的点压队
    }
    //for (int i = 1; i <= n; i++) printf("%d ",g[i]);
    //printf("\n");
    for (int i = n + 1; i <= ne; i++) ff[i] = data[i], ma = max(ma, ff[i]);//注意刚开始先特判，不然会wa四个点
    //printf("\n");
    while (h<tail) {//以下为广搜拓扑
        h++;
        int u = que[h];
        for (int p = head[u]; p; p = nxt[p]){
            if (!bb[a[p]]) rd[a[p]]--;//如果这个点已经拓扑过则没有减入度的必要
            if (rd[a[p]] == 0 && !bb[a[p]]) que[++tail] = a[p], bb[a[p]] = true;//压队，拓扑
            ff[a[p]] = max(ff[a[p]], ff[u] + data[a[p]]); //dp还是蛮水的
            if (ff[a[p]] > ma) ma = ff[a[p]]; //打擂
        }
    }
    printf("%d",ma);
}
```

---

## 作者：吃瓜群众syc (赞：1)

首先求出图中的所有强连通分量，然后把整个强连通分量中的所有点缩为一点(我在实际打的过程中把这些点都缩到每个强连通分量中dfs序最小的那个点)，然后从原来的点与点之间的连接关系（边）中找到连接不同的强联通分量的点，此即为缩点后的新图中的边。之后以新图中的每一个点为源点SPFA跑最长路即可.


AC代码:

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

const int NMAXN=10001,MMAXN=100001;
int n,m,u[MMAXN],v[MMAXN],w[MMAXN],first[MMAXN],next[MMAXN],c[NMAXN],num,dis[NMAXN],que[NMAXN<<2],ansnow,ans;
int tot,cnt,dfn[NMAXN],low[NMAXN],stack[NMAXN],yuan[NMAXN],color[NMAXN],colortot;
bool book[NMAXN],flag[NMAXN],used[NMAXN];
struct node
{
    int from;
    int to;
}a[MMAXN];//存储缩点后的新图 

void SPFA(int s)//在缩点后的新图中跑SPFA 
{
    int head=1,tail=2;
    que[head]=s,book[que[head]]=1;
    
    while(head<tail)
    {
        int x=first[que[head]];
        while(x!=0)
        {
            if(dis[a[x].to]<dis[a[x].from]+c[a[x].to])
            {
                dis[a[x].to]=dis[a[x].from]+c[a[x].to];
                
                if(book[a[x].to]==0)
                {
                    book[a[x].to]=1;
                    que[tail]=a[x].to;
                    tail++;
                }
            }
            x=next[x];
        }
        book[que[head]]=0,que[head]=0;
        head++;
    }
    book[que[head]]=0,que[head]=0;
    
    for(int i=1;i<=colortot;i++)	ansnow=max(ansnow,dis[color[i]]);
    //求出以s为原点在新图中跑出来的最长路中的最长路
}

void tarjan(int k)
{
    dfn[k]=++tot;//累加dfs序 
    low[k]=tot;//low[i]:求点k所能到达的dfs序最小的点 
    stack[++cnt]=k,flag[k]=1;//将点k压入记录当前强连通分量的栈中 
    
    int x=first[k];
    while(x!=0)//遍历点k的出边 
    {
        if(dfn[v[x]]==0)//在搜索树中找到了一个 
        {
            tarjan(v[x]);
            low[k]=min(low[k],low[v[x]]);//用点k儿子的low值更新点k的low值 
        }
        else
        {
            if(flag[v[x]]==1)
                low[k]=min(low[k],dfn[v[x]]);
				//根据low的定义，比较low[k],dfn[v[x]]的大小从而更新low[k] 
        }
        x=next[x];
    }
    
    if(low[k]==dfn[k])
    {
        color[++colortot]=k;//color:记录每一个强连通分量中dfs序最小的点 
        while(1)
        {		
            c[k]+=w[stack[cnt]];
			//因为我们之后要把一整个强连通分量缩成一点
			//所以缩成的点的点权即为该强连通分量内所有点的点权之和 
            yuan[stack[cnt]]=k;//yuan[]:记录每一个点所在的强连通分量内dfs序最小的点 
            flag[stack[cnt]]=0;//将该点弹出栈后清空标记  
			if(stack[cnt]==k)
			{
				cnt--;
				break;
			}
			cnt--;//这里cnt记录的是栈中的元素个数
        }
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)	scanf("%d",&w[i]);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&u[i],&v[i]);
        next[i]=first[u[i]];
        first[u[i]]=i;
    }
    
    for(int i=1;i<=n;i++)
    {
        if(dfn[i]==0)
            tarjan(i);//防止tarjan图不连通 
    }

    memset(first,0,sizeof(first));
    memset(next,0,sizeof(next));//清空原图的边的信息 
        
    for(int i=1;i<=m;i++)
    {
        if(yuan[u[i]]!=yuan[v[i]])
		//如果该边所连接的两点分属于不同的强连通分量
		//那么在缩点后的新图中，该边应连接着该边所连接的两点分属的强连通分量 
        {
            a[++num].from=yuan[u[i]];
            a[num].to=yuan[v[i]];//缩点后的图中只剩下在各自所属的强连通分量中dfs序最小的点 
            
            next[num]=first[a[num].from];
            first[a[num].from]=num;
        }
    }
    
    for(int i=1;i<=colortot;i++)//枚举color中的每一个元素，以他们为源点跑最长路 
    {
    	ansnow=0;//该变量记录以color[i]为原点在新图中跑出来的最长路中的最长路 
        for(int z=1;z<=colortot;z++)	dis[color[z]]=0;//缩点后的图中只剩下在各自所属的强连通分量中dfs序最小的点
    	SPFA(color[i]);
    	ans=max(ans,ansnow+c[color[i]]);
    	//ansnow+c[color[i]]-----别忘了把源点自己的点权加上 
    }

    printf("%d",ans);
    return 0;
}
```


---

## 作者：chengjintao (赞：1)

缩点模板，先用tarjan算法求出强连通分量，将强连通分量里每个点权值加到一起。然后枚举每一条边，如果两点属于不同强连通分量，就在强连通分量之间加一条边。显然最长路径一定是以缩点后入度为0的点开始的，所以只需要对缩点后入度为0的点跑一遍spfa，然后取最长路径，即为答案。因为N<=10000,M<=100000，tarjan算法O（N）缩点后点数，边数大大减少，只需要跑入度为0的点，所以可以在时间限制内通过。

以下为C++AC代码：


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<stack>
#include<queue>
#define maxn 101000
using namespace std;
typedef long long ll;
stack<ll>q;
queue<ll>s;
ll a[maxn],belong[maxn];
ll sum=0;
inline ll read()
{
    ll x=0;char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x;
}
struct Edge
{
    ll to,next,from;
}edge1[maxn*4],edge2[maxn*4];
ll head1[maxn],head2[maxn];
ll dis[maxn];ll dis1[maxn];
ll indegree[maxn];
ll dfn[maxn],low[maxn],dex=0;
bool vis[maxn],ins[maxn];
ll sum1,sum2;
ll ans=0;
inline void add_edge1(ll from,ll to)
{
    edge1[++sum1].next=head1[from];
    edge1[sum1].from=from;
    edge1[sum1].to=to;
    head1[from]=sum1;
}
inline void add_edge2(ll from,ll to)
{
    edge2[++sum2].next=head2[from];
    edge2[sum2].to=to;
    head2[from]=sum2;
}
inline void tarjan(ll u)
{
    vis[u]=1;
    ins[u]=1;
    q.push(u);
    dfn[u]=low[u]=++dex;
    for(ll i=head1[u];i;i=edge1[i].next)
    {
        ll v=edge1[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        if(ins[v])
        low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        sum++;
        ll t=q.top();
        while(t!=u)
        {
            belong[t]=sum;
            dis[sum]+=a[t];
            ins[t]=0;
            q.pop();
            t=q.top();
        }
        belong[t]=sum;
        dis[sum]+=a[t];
        ins[t]=0;
        q.pop();
    }
    return ;
}
inline void spfa(ll u)
{
    ans=max(ans,dis[u]);
    s.push(u);
    dis1[u]=dis[u];
    ins[u]=1;
    while(!s.empty())
    {
        ll t=s.front();
        s.pop();
        ins[t]=0;
        for(ll i=head2[t];i;i=edge2[i].next)
        {
            ll v=edge2[i].to;
            if(dis1[t]+dis[v]>dis1[v])
            {
                dis1[v]=dis1[t]+dis[v];
                ans=max(ans,dis1[v]);
                if(!ins[v])
                s.push(v); 
            }
        }
    }
}
int main()
{
    ll n,m;
    n=read();m=read();
    for(ll i=1;i<=n;i++)
    {
        a[i]=read();
    }
    ll from,to;
    for(ll i=1;i<=m;i++)
    {
        from=read();to=read();
        add_edge1(from,to);
    }
    for(ll i=1;i<=n;i++)
    {
        if(!vis[i]) tarjan(i);
    }    
    for(ll i=1;i<=sum1;i++)
    {
        from=edge1[i].from;to=edge1[i].to;
        if(belong[from]!=belong[to])
        {
            add_edge2(belong[from],belong[to]);
            indegree[belong[to]]++;
        }
    }
    for(ll i=1;i<=sum;i++)
    {
        memset(dis1,0,sizeof(dis1));
        if(indegree[i]==0)
        spfa(i);
    }
    printf("%lld",ans);
    return 0;
}
```

---


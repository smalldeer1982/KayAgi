# [GZOI2017] 小z玩游戏

## 题目背景

GZOI2017 D1T2

## 题目描述

小 z 很无聊。

小 z 要玩游戏。

小 z 有 $N$ 个新游戏，第 $i$ 个游戏看上去的有趣程度为 $w_i$。

小 z 很挑，他只会玩看上去的有趣程度是自己兴奋程度整数倍的游戏。

由于游戏实际上有好玩的也有不好玩的，玩完第 $i$ 个游戏后，小 z 的兴奋程度会变为 $e_i$。

已知小 z 初始兴奋程度为 $1$，请问小 z 有多少个游戏可能会玩两次？

## 说明/提示

### 样例 2 解释

数字代表游戏编号，箭头表示下一个。

- 情况 $1$：$2\to 5\to 4\to 2$；
- 情况 $2$：$5\to 4\to 2\to 5$；
- 情况 $3$：$4\to 2\to 5\to 4$。

所以小 z 可能玩 $2,4,5$ 两次。

小 z 无论如何都不能玩 $1$ 或 $3$ 两次。

### 数据范围及约定


![](https://cdn.luogu.com.cn/upload/image_hosting/s757wplh.png)

## 样例 #1

### 输入

```
5
1
100000
100000
5
1 2 6 15 35
5 7 9 2 3
5
2 3 5 35 21
7 11 7 3 2
10
6 15 77 12 24 37 35 99 55 42
4 2 5 7 11 3 6 8 9 10
10
6540 5604 567 57065 60 670 6870 1230 465 6540
12 5 37 3 34 13 17 18 10 12```

### 输出

```
1
3
3
8
5```

# 题解

## 作者：Cutest_Junior (赞：24)

## 题解 P5676 【[GZOI2017]小z玩游戏】

### 题意

+ 有 $n$ 个游戏，有趣程度为 $w$，玩完后兴奋程度会变为 $e$；
+ 每次只会玩有趣程度是兴奋程度整数倍的游戏，一开始兴奋程度为 $1$；
+ 不超过 $10$ 组数据，$n,w,e\le10^5$。

### 做法

相信很多人一开始都和我一样，想对于任意两个游戏，判断是否建边，然后跑一遍 Tarjan。

但是这样的复杂度是 $O(n^2)$ 的，无法通过 $10^5$ 的数据。

我们换一种思考方式。~~重新构造脑子。~~

若当前兴奋值为 $a$，某个游戏有趣程度为 $w$，兴奋程度为 $e$，$w$ 是 $a$ 的倍数。

可以视为兴奋值先从 $a$ 变成了它的倍数 $w$，再变成 $e$。

那我们就可以对每个数向它的倍数建边，再对于每个游戏从 $w$ 向 $e$ 建边。

跑一遍 Tarjan，对于每个游戏判断 $w$ 和 $e$ 是否在同一强连通分量。

建边复杂度 $O(n\log n)$，可以通过。

### 代码

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <stack>
#include <cstring>

using namespace std;

const int N = 1e5 + 5;

vector<int> edge[N];

void add(int u, int v) {
	edge[u].push_back(v);
}

int dfn[N], dfstot;
int low[N];
int scc[N], scctot;

stack<int> sta;

void tarjan(int x) {
	dfn[x] = low[x] = ++dfstot;
	sta.push(x);
	for (int i = 0; i < edge[x].size(); ++i) {
		int to = edge[x][i];
		if (dfn[to] == 0) {
			tarjan(to);
			low[x] = min(low[x], low[to]);
		}
		else if (scc[to] == 0) {
			low[x] = min(low[x], dfn[to]);
		}
	}
	if (low[x] == dfn[x]) {
		++scctot;
		while (1) {
			int t = sta.top();
			sta.pop();
			scc[t] = scctot;
			if (t == x) {
				break;
			}
		}
	}
}

int arr1[N], arr2[N];

void run() {
	memset(dfn, 0, sizeof dfn);
	memset(low, 0, sizeof low);
	memset(scc, 0, sizeof scc);
	dfstot = scctot = 0;
	for (int i = 0; i < N; ++i) {
		edge[i].clear();
	}
	for (int i = 1; i + i < N; ++i) {
		for (int j = 2; j * i < N; ++j) {
			add(i, j * i);
		}
	}
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &arr1[i]);
	}
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &arr2[i]);
		add(arr1[i], arr2[i]);
	}
	for (int i = 1; i < N; ++i) {
		if (dfn[i] == 0) {
			tarjan(i);
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; ++i) {
		if (scc[arr1[i]] == scc[arr2[i]]) {
			++ans;
		}
	}
	printf("%d\n", ans);
}

int main() {
	int t;
	scanf("%d", &t);
	while (t--) {
		run();
	}
}
```

---

## 作者：WYXkk (赞：13)

为什么其他两篇题解都建了 $3n$ 个点的图…… $n$ 个点足够了。（于是我不加任何火车头之类的优化拿到了本题最优解……）

可以发现，题目相当于：

- 有一个变量初始 $x=1$。
- 你可以任意地把 $x$ 变成 $x$ 的任意倍数。
- 你还有 $n$ 种操作，第 $i$ 种操作是：假如 $x=w_i$，可以把 $x$ 变成 $e_i$。
- 问每种操作有没有可能执行多次。

先给我的最初想法（$2n$ 个点）：

> 对于每种操作建一个点，每个数建一个点，然后连以下**单向**边：
>
> - $(i,i\times j)$
> - $(w_i,10^5+i)$
> - $(10^5+i,e_i)$
>
> 之后 tarjan 一遍求出强连通分量。
>
> 那么，假如 $10^5+i$ 被包含在一个大小至少为 $2$ 的强连通分量中，则说明有一个包含这个点的环，在环上不断循环即可。反之亦然。

进过我的一番思考，发现还可以进一步优化（$n$ 个点）：

> 对于每个数建一个点，然后连以下**单向**边：
>
> - $(i,i\times j)$
> - $(w_i,e_i)$
>
> 之后 tarjan 一遍求出强连通分量。
>
> 假如 $w_i$ 和 $e_i$ 在同一个强连通分量中，那么要么 $e_i=w_i$，于是操作 $i$ 可以无限操作；要么可以从 $e_i$ 到达 $w_i$，于是操作 $i$ 可以无限操作。反之亦然。

除此之外，连边还可以优化：只连 $(i,i\times p)$，其中 $p$ 是质数。

~~建议缩短时限为 200ms 卡掉 3n 和 2n 个点的做法~~

贴一遍最优解。

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=100005;
const int M=500005;
bool isnp[N];int prs[N],prn=0;
void shai()
{
	isnp[0]=isnp[1]=true;
	F(i,2,100000)
	{
		if(!isnp[i]) prs[++prn]=i;
		for(ri j=1;j<=prn&&i*prs[j]<=100000;++j) {isnp[i*prs[j]]=true;if(!(i%prs[j])) break;}
	}
}
int head[N],to[M],nxt[M],tot=0;void add(int u,int v){to[++tot]=v;nxt[tot]=head[u];head[u]=tot;}
int dfn[N],low[N],stk[N],top=0,tme=0,num=0;
int siz[N],bel[N];
void tarjan(int u)
{
	dfn[u]=low[u]=++tme;stk[++top]=u;
	for(ri i=head[u];i;i=nxt[i]) {if(!dfn[to[i]]) tarjan(to[i]);if(!bel[to[i]]) low[u]=min(low[u],low[to[i]]);}
	if(dfn[u]==low[u])
	{
		siz[++num]=0;
		while(stk[top]!=u) {bel[stk[top--]]=num;++siz[num];}
		bel[stk[top--]]=num;++siz[num];
	}
}
int w[N],e[N];
int main()
{
	shai();prs[++prn]=114514;
	int T=rd();while(T--)
	{
		tot=top=tme=num=0;Set(head);Set(dfn);Set(bel);
		F(i,1,100000) {for(ri t=1;i*prs[t]<=100000;++t) add(i,i*prs[t]);}
		int n=rd();
		F(i,1,n) rd(w[i]);
		F(i,1,n) rd(e[i]);
		F(i,1,n) add(w[i],e[i]);
		tarjan(1);
		int ans=0;
		F(i,1,n) if(bel[e[i]]==bel[w[i]]) ++ans;
		cout<<ans<<endl;
	}
	return 0;
}
```



---

## 作者：CuSO4_and_5H2O (赞：4)

## 思路 
第一眼看到这个题目的时候感觉很简单，求强连通分量，然后看看有几个点的 $w_i$ 和 $e_i$ 在一个强联通分量里，那就是答案。但是突然发现如果输入一个点就要和其他的点租比较的话时间会爆炸，然后我就想到不如把所有 $e_i$ 的倍数枚举一遍，这样就可以了（对于没用的也没必要管因为最后是统计所有 $w_i$ 和 $e_i$ 是否在一个强联通分量里，所以不会影响答案的），这样时间复杂度就很小了。看到这里，我自信了丢掉草纸准备自己做出来，之后做完了发现一点都不对，接下来我会列举几个我做的时候遇到的坑。

- 1. 是枚举 $e_i$ 的倍数而不是 $w_i$ 的，这个还是比较好发现的，也不容易出错（是我菜了所以才会错这个点的）。

- 2. 枚举所有 $e_i$ 的倍数的时候倍数乘以 $e_i$ 的数值限制一定是你定的 `N-1`（这里的 `N` 是定的数组大小，如果你没定 `N` 就是你的比你数组的大小少一），这么说可能不太清楚，上代码。

```cpp
for(int i=1; i<=n; i++) {
	cin>>b[i],vec[a[i]].push_back(b[i]);
	for(int j=2; !Map[b[i]] && j*b[i]<N; j++) //就是这里的<N了，如果是<=的话会错，因为他如果等于N的话到上边的tarjan代码的时候会访问vis[N]等数组，但是这些数组的范围是0到N-1的不包括N所以会出错
		vec[b[i]].push_back(j*b[i]);
	Map[b[i]]=114514;
}
```

- 3. 我做的时候有一段时间对了六个点，空间超限了四个点，这是因为 vector 数组重复建了太多的边了导致空间爆掉，你肯能会问为什么会重复建边呢，下边个样例。

```bush
M(这里 M 指的是个很大的数)
#daa..adw##@!.ads%#.ads(这里泛指很多数字这行数字不重要)
1 1 1 1 1 1 1 ……1(有 M 个1)
```


这样的话要建 $M \times 100005$ 条边假如 $M$ 很大的话空间当然会爆，但是这些边都是重复的，其实只要建一次就好了，所以我们可以建立一个数组来查看这个点的是否建边，这样就不会爆空间啦！


## 代码

这里就是代码了，题目并不难，看了思路之后自己打出来，代码也很好理解。

```cpp
#include<bits/stdc++.h>
#define int long long
const int N=1e5+10;
using namespace std;

int n,a[N],b[N];
vector<int> vec[N];
int Map[N];
int jis,wuy[N],low[N],dfn[N],cnt,vis[N];
int ans;
stack<int> sta;

void tarjan(int x)
{
	sta.push(x);vis[x]=1;
	low[x]=dfn[x]=++cnt;
	for(int i=0;i<vec[x].size();i++)
	{
		int nex=vec[x][i];
		if(!dfn[nex]){
			tarjan(nex);
			low[x]=min(low[x],low[nex]); 
		} else if(vis[nex]) low[x]=min(low[x],dfn[nex]); 
	}
	if(low[x]==dfn[x])
	{
		jis++;
		while(1)
		{
			vis[sta.top()]=0;
			wuy[sta.top()]=jis;
			vis[sta.top()]=0;
			if(sta.top()==x) break ;
			sta.pop();
		}
		sta.pop();
	}
}

signed main(){
	int t;
	cin>>t;
	for(int qwq=1;qwq<=t;qwq++)
	{
	memset(dfn, 0, sizeof dfn);
	memset(low, 0, sizeof low);
	memset(wuy, 0, sizeof wuy);
	memset(vis, 0, sizeof vis);
	memset(Map, 0, sizeof Map);
	cnt=jis=ans=0;
	for (int i = 0; i < N; ++i) 
		vec[i].clear();
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		cin>>b[i],vec[a[i]].push_back(b[i]);
		for(int j=2;!Map[b[i]] && j*b[i]<N;j++)//把每个e_i枚举一遍 
			vec[b[i]].push_back(j*b[i]);
		Map[b[i]]=114514;//标记 
	}
	for(int i=1;i<=n;i++) if(!dfn[a[i]]) tarjan(a[i]);
	for(int i=1;i<=n;i++) if(wuy[a[i]]==wuy[b[i]]) ans++;
	cout<<ans<<endl;	
	}
}
```

---

## 作者：喵仔牛奶 (赞：2)

## $\mathcal{Solution}$

- 玩完一个游戏后兴奋度为 $e_i$，与之前玩的游戏无关，所以可以把一个游戏看成一个点。一个游戏可以玩两遍仅当存在一条起点与终点都是它的路径。
- 每个点 $i$ 需要向 $w_j$ 是 $e_i$ 倍数的点 $j$ 建边，但是直接暴力建边会超时。由于相同的 $e_i$ 连向的点相同，于是可以对于值域里每个值开一个点，每个点向它的倍数点连边，然后每个游戏向值域 $e_i$ 的点连边，值域 $w_i$ 的点向这个游戏连边。这样建的边数是 $\mathcal{O}(\sum\limits_{i=1}^{n}\dfrac{V}{i})=\mathcal{O}(V\log V)$ 的（$V$ 为值域）。
- 跑一遍 Tarjan 求出强联通分量。一个点可以再次经过自己仅当它所在的强连通分量里不只有它一个点，因为那样的话它可以通过另一个点再经过自己。
- 建边还可以进一步优化，设一个值域点 $v$ 向它 $k$ 倍的点 $vk$ 连边，而 $k$ 总是可以被分解为质数乘积 $k=p_1p_2p_3\cdots p_t$，那么向 $k$ 倍连边等价于 $v$  向 $p_1v$ 连边，$p_1v$ 向 $p_1p_2v$ 连边……$p_1p_2p_3\cdots p_{t-1}v$ 向 $vk$ 连边。所以每个点只向自己的素数倍连边即可。边数 $\mathcal{O}(\sum\limits_{i=1}^{n}\pi(\dfrac{V}{i}))=\mathcal{O}(V\ln\ln V)$（$\pi(x)$ 表示 $[1,x]$ 间的素数个数）。

时间复杂度 $\mathcal{O}(n+V\ln\ln V)$。

## $\mathcal{Code}$

Tarjan，[2.48s](https://www.luogu.com.cn/record/106655519)。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Milkcat {
	typedef long long LL;
	const int N = 1e6 + 5;
	int n, m, u, v, cnt, ans, a[N], w[N], e[N], qwq[N];
	bool prime[N];
	struct Graph {
		struct edge {
			int to, next;
		} e[N << 1];
		int tot, cnt, cnts, qaq[N], dfn[N], low[N], pos[N], head[N];
		bool vis[N], qwq[N];
		vector<int> ans[N], s;
		void add(int u, int v) {
			e[++ cnts].to = v;
			e[cnts].next = head[u];
			head[u] = cnts;
		}
		void tarjan(int u) {
			dfn[u] = low[u] = ++ tot;
			s.push_back(u), vis[u] = true;
			for (int i = head[u]; i; i = e[i].next) {
				int v = e[i].to;
				if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
				else if (vis[v]) low[u] = min(low[u], low[v]);
			}
			if (dfn[u] == low[u]) {
				ans[++ cnt].push_back(u);
				while (s.back() != u) {
					int v = s.back(); s.pop_back();
					pos[v] = cnt, vis[v] = false, ans[cnt].push_back(v);
				}
				s.pop_back(), pos[u] = cnt, vis[u] = false;
			}
		}
		void work() {
			for (int i = 1; i <= n; i ++)
				if (!dfn[i]) tarjan(i);
			for (int i = 1; i <= cnt; i ++)
				for (int v : ans[i]) qaq[i] ++;
		}
		void clear() {
			for (int i = 1; i <= cnt; i ++) ans[i].clear();
			s.clear();
			memset(qaq, 0, sizeof qaq);
			memset(dfn, 0, sizeof dfn);
			memset(low, 0, sizeof low);
			memset(pos, 0, sizeof pos);
			memset(head, 0, sizeof head);
			memset(vis, 0, sizeof vis);
			memset(e, 0, sizeof e);
			tot = cnt = cnts = 0;
		}
	} G;
	void GetPrime(int n) {
		for (int i = 2; i <= n; i ++) {
		    if (!prime[i]) a[++ cnt] = i;
		    for (int j = 1; j <= cnt && i * a[j] <= n; j ++) {
		        prime[i * a[j]] = true;
		        if (i % a[j] == 0) break;
		    }
		}
	}
	int main() {
		cin >> n;
		for (int i = 1; i <= 1e5; i ++) qwq[i] = n + i;
		for (int i = 1; i <= n; i ++) cin >> w[i], G.add(qwq[w[i]], i);
		for (int i = 1; i <= n; i ++) cin >> e[i], G.add(i, qwq[e[i]]);
		GetPrime(1e5);
		for (int i = 1; i <= 1e5; i ++)
			for (int j = 1; j <= cnt && i * a[j] <= 1e5; j ++)
				G.add(qwq[i], qwq[i * a[j]]);
		G.work();
		for (int i = 1; i <= n; i ++)
			if (G.qaq[G.pos[i]] > 1) ans ++;
		cout << ans << '\n', G.clear(), ans = 0;            
		return 0;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1;
	cin >> T;
	while (T --) Milkcat::main();
	return 0;
}

```

---

## 作者：黑影洞人 (赞：2)

很显然，这道题需要将模型转化。

首先对于每个物品 $w_i$ 珂以转化为 $e_i$ 很显然，直接从 $w_i$ 向 $e_i$ 连一条边。

我们再对于 $\forall a,a=kb,k\in N^+$ 从 $b$ 向 $a$ 连一条边。

我们可以发现，当出现二元环的时候，这个游戏珂以被玩两次。

为什么？

因为我没一开始从 $w_i$ 向 $e_i$ 连一条边，之后从 $b$ 向 $a$ 连一条边。

连下来发现当 $e_i=kw_i$ 时，珂以重复走，这也就满足了我们题目的条件。

至于走两次，只需要判断是否在一个二元环内即可，我们直接上缩点。

```cpp
void tarjan(int x){
	st[++top]=x;
	dfn[x]=low[x]=++cnt;
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		if(!dfn[y])tarjan(y),low[x]=min(low[x],low[y]);
		else if(!co[y])low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		co[x]=++col;
		while(st[top]!=x)co[st[top--]]=col;
		top--;
	}
}
```
这是多次询问，要记得清空数组。

下面是完整代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define N 1919810
using namespace std;
int head[N],to[N],nxt[N],tot,w[N],e[N],T,n,cnt,mx;
int dfn[N],st[N],top,low[N],co[N],col;
void csh(){
	tot=cnt=top=col=0;
	memset(head,0,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(co,0,sizeof(co));
}
void add(int u,int v){
	to[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}
void tarjan(int x){
	st[++top]=x;
	dfn[x]=low[x]=++cnt;
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		if(!dfn[y])tarjan(y),low[x]=min(low[x],low[y]);
		else if(!co[y])low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		co[x]=++col;
		while(st[top]!=x)co[st[top--]]=col;
		top--;
	}
}
signed main(){
	scanf("%d",&T);
	while(T--){
		csh();
		scanf("%d",&n);
		mx=0;
		for(int i=1;i<=n;i++)scanf("%d",&w[i]),mx=max(mx,w[i]);
		for(int i=1;i<=n;i++)scanf("%d",&e[i]),mx=max(mx,w[i]);
		for(int i=1;i<=mx;i++)for(int j=2*i;j<=mx;j+=i)add(i,j);
		for(int i=1;i<=n;i++)add(w[i],e[i]);
		for(int i=1;i<=mx;i++)if(!dfn[i])tarjan(i);
		int ans=0;
		for(int i=1;i<=n;i++)ans+=co[w[i]]==co[e[i]];
		printf("%d\n",ans);
	} 
	return 0;
}
```
管理员同志审核题解辛苦了

---

## 作者：Vocanda (赞：2)


## 分析

这个题看完题目，就很容易能够想到如果一个游戏能玩两边，那么肯定是游戏与游戏之间玩的时候形成了一个环，那么久可以想到用$Tarjan$求强连通分量，然后找出每个环的大小，最后加和就可以。

但是如果把每一个游戏和玩完游戏的兴奋程度都建边，看一下数据范围，肯定是不能$AC$的，所以我们要考虑一下怎么建边:

因为每玩一个游戏，兴奋程度都会有变化，而只有游戏的兴奋程度是他的兴奋程度的整数倍才会去玩，所以我们从第几个游戏到玩完这个游戏的兴奋程度建边，然后在每个游戏的有趣程度和此游戏中再建一条边，最后再从每个兴奋程度到它所能满足的有趣程度建一个边，这样就实现了原来$O(n^2)$的建图方式来达到从当前游戏对下一个能玩的游戏建边的目的。

下边是第二组样例中建好的图：
![](https://img2020.cnblogs.com/blog/1996530/202006/1996530-20200627193442749-889427000.png)

这个图中强连通分量一共有三个点，所以答案就是三，然后按照优化的建边方法，就可以$AC$了（温馨提示：$Tarjan$一定要认真写，本人$Tarjan$写挂了，乱七八糟，重写一遍才改过来。）
## 注意
在$Tarjan$ 的时候，要记录强连通分量大小，大于$1$就标记当前点，然后运行的时候在强连通分量里的也要都标记，最后从$1$到$n$统计标记数，得出答案。 


## 放代码了！！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e6+10;
int head[maxn],vis[maxn];
int c[maxn];
int num;
int dfn[maxn],low[maxn];
int next[maxn],ver[maxn];
int tot,cnt;
int sta[maxn];
int top;
void Add(int x,int y){//建图
    ver[++tot] = y;
    next[tot] = head[x];
    head[x] = tot;
}
void Tarjan(int u){//求值
    sta[++top]=u;
    dfn[u]=low[u]=++num;
    for(int i=head[u];i;i=next[i]){
        int v=ver[i];
        if(!dfn[v]){
            Tarjan(v); 
            low[u]=min(low[u],low[v]);
        }else if(!c[v]) 
        low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u]){
        c[u]=++cnt;
        int siz=1;
        while(sta[top]!=u){
            c[sta[top]]=cnt;//标记当前点在第几个分量里
            vis[sta[top]]=1;//标记当前点
            siz++;//枚举一个点的时候就大小加一
            top--;
        }
        if(siz>1)vis[u]=1;//不是一个点的强连通分量就标记当前点
        --top;
    }
}
int n;
int T;
int main(){
    scanf("%d",&T);
    while(T--){//初始化
        memset(vis,0,sizeof(vis));
        memset(dfn,0,sizeof(dfn));
        memset(low,0,sizeof(low));
        memset(c,0,sizeof(c));
        memset(next,0,sizeof(next));
        memset(ver,0,sizeof(ver));
        memset(sta,0,sizeof(sta));
        memset(head,0,sizeof(head));
        num = 0;
        tot = 0;
        cnt = 0;
        top = 0;
        scanf("%d",&n);
        int Max = 0;
        for(int i=1,x;i<=n;++i){//从玩完这个游戏的兴奋度到这个游戏建边
            scanf("%d",&x);
            Add(n+x,i);
            Max = max(Max,x);
        }
        for(int i=1,x;i<=n;++i){//从该游戏到该游戏的有趣度建边
            scanf("%d",&x);
            Add(i,n+x);
        }
        for(int i=1;i<=Max;++i){//从该游戏兴奋度到有趣度建边，相当于连接上能连续玩的两个点
            for(int j=2;j*i<=Max;++j){
                Add(n+i,n+i*j);
            }
        }
        for(int i=1;i<=n;++i){
            if(!dfn[i])Tarjan(i);
        }
        int ans = 0;
        for(int i=1;i<=n;++i){//统计答案
            if(vis[i])ans++;
        }
        printf("%d\n",ans);
    }
}
```


---

## 作者：hzoi_liuchang (赞：1)

## 分析
一开始看到这道题，首先想到的就是建好边后跑一个Tarjan缩点，将siz大于1的节点统计一下，输出结果

Tarjan非常显然易得，关键就是怎么建边

比较好想的一种思路就是枚举每一个兴奋程度

对于每一个兴奋程度，再将有趣程度枚举一遍

如果有趣程度是兴奋程度的倍数的话，在两个节点之间建一条有向边

我们拿第二个样例模拟一下，建好边后就是下面这样

![](https://img2020.cnblogs.com/blog/1996139/202006/1996139-20200627193224988-1955413355.png)
那么缩点后大小不为1的强连通分量只有一个，它的大小为3

那么最终的答案就是$3$

但是这样的建边效率为$n^2$，复杂度接受不了

所以我们考虑更优秀的建边方法

这里要用到的是建虚点的方法

1.建一个由 有趣程度 到 点 的边

2.建一个由 点 到 兴奋程度 的边

3.重点：建一个兴奋程度整数倍的边

要注意的是建虚点的时候，要把游戏的编号加上一个$n$

避免和原先的编号重复

然后思路就和$n^2$的解法一样

至于时间复杂度，根据大佬的证明，是

![](https://img2020.cnblogs.com/blog/1996139/202006/1996139-20200627194114551-1334890387.png)
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+5;
struct asd{
    int from,to,next;
}b[maxn];
int head[maxn],tot=1;
void ad(int aa,int bb){
    b[tot].from=aa;
    b[tot].to=bb;
    b[tot].next=head[aa];
    head[aa]=tot++;
}
int dfn[maxn],low[maxn],top,sta[maxn],dfnc,shuyu[maxn],siz[maxn],js,vis[maxn];
void tar(int xx){
    dfn[xx]=low[xx]=++dfnc;
    sta[++top]=xx;
    for(int i=head[xx];i!=-1;i=b[i].next){
        int u=b[i].to;
        if(!dfn[u]){
            tar(u);
            low[xx]=min(low[xx],low[u]);
        } else if(!shuyu[u]){
            low[xx]=min(low[xx],dfn[u]);
        }
    }
    if(low[xx]==dfn[xx]){
        js++;
        siz[js]=1;
        while(sta[top]!=xx){
            int now=sta[top--];
            shuyu[now]=js;
            siz[js]++;
            vis[now]=1;
        }
        top--;
        shuyu[xx]=js;
        if(siz[js]>1) vis[xx]=1;
    }
}
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        memset(head,-1,sizeof(head));
        memset(&b,0,sizeof(struct asd));
        memset(dfn,0,sizeof(dfn));
        memset(low,0,sizeof(low));
        tot=1,js=0,dfnc=0,top=0;
        memset(vis,0,sizeof(vis));
        memset(sta,0,sizeof(sta));
        memset(shuyu,0,sizeof(shuyu));
        memset(siz,0,sizeof(siz));
        int n;
        scanf("%d",&n);
        int mmax=0;
        for(int i=1;i<=n;i++){
            int aa;
            scanf("%d",&aa);
            ad(n+aa,i);
            mmax=max(mmax,aa);
        }
        for(int i=1;i<=n;i++){
            int aa;
            scanf("%d",&aa);
            ad(i,n+aa);
        }
        for(int i=1;i<=mmax;i++){
            for(int j=2;j*i<=mmax;j++){
                ad(n+i,n+i*j);
            }
        }
        for(int i=1;i<=n;i++){
            if(!dfn[i]) tar(i);
        }
        int ans=0;
        for(int i=1;i<=n;i++){
            if(vis[i]==1) ans++;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：LanrTabe (赞：1)

[My Blog](https://www.cnblogs.com/LanrTabe/p/11896300.html) [题面](http://noi.gznc.edu.cn/UserFiles/file/20170428/20170428175433_346.pdf)

做了半天一直不对，交一发就A了？样例出锅了吧。。（Luogu的样例是改过的，如果有错请联系我qwq）

很显然对每个兴奋程度向能玩的游戏连边，游戏向相应的兴奋程度连边，然后问题转化为有多少游戏在一个环上，且能被兴奋程度为$1$的节点到达

但是直接连边是$O(n^2)$的，显然不行，需要优化。

设$N=100000$

建$N$个点$1\sim N$表示当前兴奋程度

建$N$个点$N+1\sim 2N$为中转节点

建$N$个点$2N+1\sim 3N$表示$N$款游戏

那么对于$1\le i,j\le N,i|j$，连边$(i,N+j)$，表示兴奋程度$i$能玩有趣程度为$j$的游戏

对于$1\le i\le n$,连边$(N+w_i,2N+i),(2N+i,e_i)$，表示第$i$款游戏有趣程度为$w_i$，玩完后兴奋程度变为$e_i$

那么连边的复杂度就是喜闻乐见的调和级数：$\sum_{i=1}^N\limits \frac Ni=O(N\log N)$

接着跑一遍Tarjan，DFS一边求出哪些强连通分量可以被初始点达到

然后判断一下就好了，注意大小为$1$的强连通分量不是环。

时间复杂度 $O(TN\log N)$

空间复杂度 $O(N\log N)$

### 代码:

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>

inline int Min(const int a,const int b){return a<b?a:b;}
inline int Max(const int a,const int b){return a>b?a:b;}
#define Getchar (p1==p2&&(p2=(p1=In)+fread(In,1,1<<22,stdin),p1==p2)?EOF:*p1++)
char In[1<<22],*p1=In,*p2=In,Ch;
inline int Getint(int x=0)
{
    while(!isdigit(Ch=Getchar));
    for(;isdigit(Ch);Ch=Getchar)x=x*10+(Ch^48);
    return x;
}

const int N=100000,V=N*3+5,E=N*14;
int T,n,w[N+5],Ans;
int Dfn[V],Low[V],Tim,Ins[V],Sta[V],Top;
int Dcc[V],Siz[V],Dn,Deg[V],Vis[V];
struct Graph
{
    int Head[V],Next[E],To[E],En;
    inline void Clear(){memset(Head,En=0,sizeof Head);}
    inline void Add(int x,int y){Next[++En]=Head[x],To[Head[x]=En]=y;}
}G1,G2;

void Tarjan(int x)
{
    Dfn[x]=Low[x]=++Tim,Ins[Sta[++Top]=x]=1;
    for(int i=G1.Head[x],y;i;i=G1.Next[i])
        if(!Dfn[y=G1.To[i]])Tarjan(y),Low[x]=Min(Low[x],Low[y]);
        else if(Ins[y])Low[x]=Min(Low[x],Dfn[y]);
    if(Low[x]==Dfn[x])
    {
        int y=++Dn;
        do Ins[y=Sta[Top--]]=0,Dcc[y]=Dn,++Siz[Dn];
        while(y!=x);
    }
}

void DFS(int x){if(!Vis[x]){Vis[x]=1;for(int i=G2.Head[x];i;i=G2.Next[i])DFS(G2.To[i]);}}

int main()
{
    freopen("in.txt","r",stdin);
    for(T=Getint();T--;printf("%d\n",Ans))
    {
        G1.Clear(),G2.Clear(),n=Getint(),Ans=0;
        for(int i=1;i<=N;++i)
            for(int j=i;j<=N;j+=i)
                G1.Add(i,N+j);
        for(int i=1;i<=n;++i)G1.Add(N+(w[i]=Getint()),N*2+i);
        for(int i=1;i<=n;++i)G1.Add(N*2+i,Getint());
        memset(Dfn,0,sizeof Dfn),memset(Siz,0,sizeof Siz),Tim=Dn=0;
        for(int i=1;i<=3*N;++i)if(!Dfn[i])Tarjan(i);
        memset(Deg,0,sizeof Deg),memset(Vis,0,sizeof Vis);
        for(int i=1,t;i<=3*N;++i)
            for(int j=G1.Head[i];j;j=G1.Next[j])
                if(Dcc[i]!=(t=Dcc[G1.To[j]]))
                    G2.Add(Dcc[i],t),++Deg[t];
        DFS(Dcc[1]);
        for(int i=1;i<=n;++i)
            if(Vis[Dcc[N*2+i]]&&Siz[Dcc[N*2+i]]>1)
                ++Ans;
    }
    return 0;
}
```

---

## 作者：BDFCL (赞：0)

**Solution**

看完题目，发现玩游戏的依赖关系形成了一个图，因此想到将$i$向所有$w_j$为$e_i$倍数的$j$连边

然后在建出来的图上，如果一个游戏能被玩两次，显然应该是在一个环上，因此跑一边$tarjan$，如果这个游戏所在强连通分量大小大于1（等于1的话说明只有这一个点），那么就一定能被玩两次

但是有一个问题，我们建边是$n^2$的

发现如果$e_i$互不相同，连出去的边的总数应该是调和级数级别的，显然我们多连了许多无用边，因此我们把$e_i$和$w_i$单独弄出来建立$m$个虚点（其中$m$表示$\max \{e_i, w_i\}$），然后建立如下边：
$$
\begin {aligned}
& i \to e_i \\
& e_i \to e_i \times k \quad (e_i \times k \leq max)\\
& w_i \to i
\end {aligned}
$$
此时边数最大为$m \log m+n$，大多数情况下还跑不满（其实跑满了也能过就是了）

然后在这个图上跑$tarjan$，如上述方法判断统计即可

复杂度大约是$O(m\log m)$

**Code**

```c++
#include <bits/stdc++.h>

#define N (int) (2e5+5)

using namespace std;
int input () {
    int x = 0, f = 0;
    char c = getchar ();
    while (c < '0' || c > '9') f = c == '-', c = getchar ();
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar ();
    return f ? - x : x;
}

int T;

int n;
int w[N], e[N];
int max_w, max_e;

struct Edge {
    int v, nxt;
} edge[N<<5];
int fst[N<<1], ecnt;
void add_edge (int u, int v) {
    edge[ecnt].v = v, edge[ecnt].nxt = fst[u], fst[u] = ecnt ++;
}
void init_e () {
    memset (fst, -1, sizeof (fst));
    ecnt = 0;
}

int ans;

int vis[N<<1];
int dfn[N<<1], low[N<<1], tot;
int stk[N<<1], top;
vector <int> scc[N<<1];
int cnt_s;
bool flg[N<<1];
void tarjan (int u) {
    low[u] = dfn[u] = ++ tot;
    stk[++ top] = u;
    vis[u] = 1;

    for (int e = fst[u]; e != -1; e = edge[e].nxt) {
        int v = edge[e].v;
        if (! vis[v]) {
            tarjan (v);
            low[u] = min (low[u], low[v]);
        } else if (vis[v] == 1) {
            low[u] = min (low[u], dfn[v]);
        }
    }

    if (dfn[u] == low[u]) {
        cnt_s ++;
        do {
            vis[stk[top]] = 2;
            scc[cnt_s].push_back (stk[top]);
        } while (top >= 1 && stk[top --] != u);
        if (scc[cnt_s].size ()> 1) {
            for (int i = 0; i < scc[cnt_s].size (); i ++) {
                flg[scc[cnt_s][i]] = true;
            }
        }
    }
}

void init () {
    init_e ();
    max_w = 0, max_e = 0;
    memset (vis, 0, sizeof (vis));
    memset (dfn, 0, sizeof (dfn));
    memset (low, 0, sizeof (low));
    memset (stk, 0, sizeof (stk));
    memset (flg, 0, sizeof (flg));
    for (int i = 1; i <= N-2; i ++) scc[i].clear ();
    top = tot = cnt_s = 0;
    ans = 0;
}

int main () {
    T = input ();

    while (T --) {
        init ();

        n = input ();
        for (int i = 1; i <= n; i ++) w[i] = input (), max_w = max (max_w, w[i]);
        for (int i = 1; i <= n; i ++) e[i] = input (), max_e = max (max_e, e[i]);
        int max_x = max (max_w, max_e);
        
        for (int i = 1; i <= max_e; i ++)
            for (int j = 1; i*j <= max_w; j ++)
                add_edge (i, i*j);
            
        for (int i = 1; i <= n; i ++) {
            add_edge (i+max_x, e[i]);
            add_edge (w[i], i+max_x);
        }

        for (int i = 1; i <= n+max_x; i ++) {
            for (int e = fst[i]; e != -1; e = edge[e].nxt) {
                int v = edge[e].v;
            }
        }

        for (int i = 1; i <= n+max_x; i ++) if (! vis[i]) tarjan (i);

        for (int i = max_x+1; i <= max_x+n; i ++) {
            if (flg[i]) ans ++;
        }

        printf ("%d\n", ans);
    }

    return 0;
}
```

**Conclusion**

1 转换成图论模型

2 存在于环上——$tarjan$

3 建虚点优化建图

---

## 作者：Marginal_world (赞：0)

题意分析：首先我们要知道为什么存在同一个游戏玩了多次，对此解释是该游戏必定在有向图中与其他若干游戏形成了环，可能是与一个或多个其他游戏。那么就可以想到求出强连通分量，但是如果是在任意两个游戏之间建边，时间复杂度会超出。

那么，我们考虑其他方式。

若一个游戏的有趣度是当前兴奋度的倍数，那就是从当前兴奋度向游戏的有趣度建边，再从有趣度向该游戏自身的兴奋度建边。由于第一次建边满足倍数关系，我们不需要具体考虑点数，直接建边即可。实践证明，用这种建边方法，是可以通过本题的。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int dfn[maxn],low[maxn],col[maxn];
int w[maxn],e[maxn];
int time1,n,t,ans,sum;
stack<int> q;
vector<int> G[maxn]; 
void tarjan(int u){//tarjan模板 
	dfn[u]=low[u]=++time1;
	q.push(u);
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!col[v])
		low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		++sum;
		while(1){
			int v=q.top();
			q.pop();
			col[v]=sum;
			if(v==u)break;
		}
	}
}
void init(){
	memset(dfn,0,sizeof(dfn));//多组数据，记得清零 
	memset(low,0,sizeof(low));
	memset(col,0,sizeof(col));
	time1=sum=0;
	for(int i=0;i<maxn;i++)
	G[i].clear();//清空 
	for(int i=1;i+i<maxn;i++)
	for(int j=2;j*i<maxn;j++)
	G[i].push_back(j*i);//将点与它们的倍数之间建边 
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>w[i];
	for(int i=1;i<=n;i++){
		cin>>e[i];
		G[w[i]].push_back(e[i]);//有趣度与兴奋度之间建边 
	}
	for(int i=1;i<=n;i++)
	if(!col[i])tarjan(i);
	for(int i=1;i<=n;i++)
	if(col[w[i]]==col[e[i]])//同属一个强连通分量，答案自加 
	ans++;
	cout<<ans<<endl;
	ans=0;//答案清零 
}
int main(){
	cin>>t;
	while(t--){
		init();
	}
	return 0;
}
```
希望能帮助到大家。

---

## 作者：AlanSP (赞：0)

## 水一波题解

本题思路清晰，把每个数建图，连边。

类似于并查集的扩展域，本题要开三个N的长度

1~N​：存w；

N+1~2N：存每个节点（就是实实在在的点）

2N+1~3N：存e；

三个扩展域是相互连接的，就像一个环。

然后一起Tarjan缩点

本题就是找出从根节点所到各个强连通分量的数量

加起来就行了

~~（一开始以为是拓扑，后来多测不清空，太菜了）~~

附上帮我查锅的神仙の博客：[s1rius.top](http://s1rius.top)
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100009;
stack<int> stk;
int x,y,n,cnt;
int ver[N*14],nxt[N*13],h[N*3],tot;
int verr[N*14],nxtt[N*13],hh[N*3],tott;
int dfn[N*3],low[N*3],siz[N*3],ind,num;
int t,scc[N*3];
bool vis[N*3];

inline void add(int x,int y)
{
	ver[++tot]=y,nxt[tot]=h[x],h[x]=tot;
}

inline void addd(int x,int y)
{
	verr[++tott]=y,nxtt[tott]=hh[x],hh[x]=tott;
}

inline void Tarjan(int root)
{
	dfn[root]=low[root]=ind++;
	stk.push(root);
	for(int i=h[root];i;i=nxt[i])
	{
		int v=ver[i];
		if(!dfn[v])
		{
			Tarjan(v);
			low[root]=min(low[root],low[v]);
		}
		else if(!scc[v])
		{
			low[root]=min(low[root],dfn[v]);
		}
	}
	if(dfn[root]==low[root])
	{
		num++;
		int x;
		while(1)
		{
			x=stk.top();stk.pop();
			scc[x]=num;
			siz[num]++;
			if(root==x) break;
		}
	}
}

inline void dfs(int x)
{
	if(!vis[x])
	{
		vis[x]=true;
		for(int i=hh[x];i;i=nxtt[i]) dfs(verr[i]);
	}
}

int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		tot=tott=0;
		cnt=num=0;
		memset(scc,0,sizeof scc);
		memset(siz,0,sizeof siz);
		memset(h,0,sizeof h);
		memset(hh,0,sizeof hh);
		for(int i=1;i<=N;i++)
			for(int j=i;j<=N;j+=i)
				add(i,N+j);
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&x);
			add(N+x,N*2+i);
		}
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&x);
			add(N*2+i,x);
		}
		ind=0;memset(low,0,sizeof low),memset(dfn,0,sizeof dfn);
			for(int i=1;i<=n*3;i++) if(!dfn[i]) Tarjan(i);
		memset(vis,false,sizeof(vis));
		for(int i=1;i<=n*3;i++)
		{
			for(int j=h[i];j;j=nxt[j])
			{
				int v=ver[j];
				if(scc[i]!=scc[v]) addd(scc[i],scc[v]);
			}
		}
		dfs(scc[1]);
		for(int i=1;i<=n;i++)
		{
			if(vis[scc[i+N*2]]&&siz[scc[i+N*2]]>1) cnt++;
		}
		printf("%d\n",cnt);
		}
	return 0;
}
```


---


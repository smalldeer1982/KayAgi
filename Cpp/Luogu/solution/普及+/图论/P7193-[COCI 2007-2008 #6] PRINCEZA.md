# [COCI 2007/2008 #6] PRINCEZA

## 题目背景

对于 C 语言和 C++ 语言，请使用 `cin`，`scanf` 进行读入，否则可能会出现 $\color{purple}\mathsf{RE}$ & $\color{red}\mathsf{WA}$。

## 题目描述



Luka 把卡车停在湖边。 

Barica 在湖中居住，Barica 跳过漂浮在湖面上的 $n$ 种植物。 

Luka 知道许多民间故事，知道如果他亲吻 Barica，她会变成一个可爱的女孩子。但是，他需要先抓住她！

可以用一对坐标定义植物在湖面上的位置。 Barica 可以从 $(x, y)$ 植物中跳跃，$p$ 为任意正整数。

- 方向 A：$(x + p, y + p)$。
- 方向 B：$(x + p, y - p)$。
- 方向 C：$(x - p, y + p)$。
- 方向 D：$(x - p, y - p)$。

Barica 选择四个方向之一，然后沿所选方向跳到第一个植物上。 

如果在选定的方向上没有植物，Barica 将留在原处。

Barica 跳下后，她从水槽上跳下的植物消失了。

知道植物的位置和 Barica 选择的方向顺序后，Luka 希望确定 Barica 最终将位于植物的坐标。 Luka 将在她的位置等她，亲吻她。

编写一个解决 Luka 问题的程序，并帮助他将 Barica 变成美丽的公主。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，$1 \le n, k \le 10 ^ 5$，$0 \le x, y \le 10 ^ 9$。
#### 说明
- 本题满分 $60$ 分。
- 本题默认开启 O2 优化开关。
- 题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #6](https://hsin.hr/coci/archive/2007_2008/contest6_tasks.pdf) T5 PRINCEZA，译者 @[tearing](https://www.luogu.com.cn/user/219791)。

## 样例 #1

### 输入

```
7 5
ACDBB
5 6
8 9
4 13
1 10
7 4
10 9
3 7
```

### 输出

```
7 4```

## 样例 #2

### 输入

```
6 12
AAAAAABCCCDD
1 1
2 2
3 3
4 4
5 3
6 2 
```

### 输出

```
5 3```

# 题解

## 作者：ShwStone (赞：4)

## 题解 princeza

###### ~~本蒟蒻的第一篇题解，求过啊~~

### 题目描述

Luka（女司机）把卡车停在湖边。Barica，Luka 知道她亲吻Barica，她会变成一个美丽的公主。但是，她需要先抓住她！
可以用一对坐标定义湖面上植物的位置。Barica 可以从 $(x, y)$ 植物跳跃到其它植物所在位置，$p$ 为任意正整数，下面给出了4种跳跃方式:

方向 A：$(x + p, y + p)$ 。

方向 B：$(x + p, y - p)$ 。

方向 C：$(x - p, y + p)$ 。

方向 D：$(x - p, y - p)$ 。

Barica选择四个方向之一，然后沿所选方向跳到该方向的第一个植物上。如果在选定的方向上没有植物，Barica将**留在原处**。

Barica跳完这一步之后，原来位置的植物将立马消失了。知道植物的位置和 Barica 选择的方向顺序后，Luka 希望确定Barica 最终将停留的植物的坐标。Luka 将在Barica最终的位置等她，亲吻她。编写一个解决Luka 问题的程序，并帮助她变成美丽的公主。

### 思路分析
显然，Barica只能沿着对角线方向跳。

但直接沿着对角线枚举太慢了，所以，对于每个节点，我们维护四个指针，指向其左上、右上、左下、右下的点，这样就可以在 $\Theta (n)$ 的复杂度模拟。

但为了建立这个图，我们需要 $\Theta (nlogn)$ 进行排序。

### AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define uns unsigned
#define ll long long
#define use_cin_cout do {ios::sync_with_stdio(false); /*cin.tie();*/} while(false)
#define endl '\n'

const ll inf_ll = 0x3f3f3f3f3f3f3f3f;
const int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const int maxn = 1e5 + 5;

struct pos {
    int x, y, d1, d2, flag[4];
};

int n, k;
int id[maxn];
char dir[maxn];
pos graph[maxn];

bool d1_compare(int a, int b) {
    return graph[a].d1 < graph[b].d1 || graph[a].d1 == graph[b].d1 && graph[a].d2 < graph[b].d2;
}

bool d2_compare(int a, int b) {
    return graph[a].d2 < graph[b].d2 || graph[a].d2 == graph[b].d2 && graph[a].d1 < graph[b].d1;
}

int main() {
    use_cin_cout;
    // freopen("princeza.in", "r", stdin);
    // freopen("princeza.out", "w", stdout);

    cin >> n >> k;
    cin >> dir + 1;
    for (int i = 1; i <= n; i++) {
        cin >> graph[i].x >> graph[i].y;
        graph[i].d1 = graph[i].x + graph[i].y;
        graph[i].d2 = graph[i].x - graph[i].y;
        for (int j = 0; j < 4; j++) graph[i].flag[j] = -1;
        id[i] = i;
    }

    sort(id + 1, id + n + 1, d1_compare);
    for (int i = 2; i <= n; i++) {
        if (graph[id[i - 1]].d1 == graph[id[i]].d1) {
            graph[id[i - 1]].flag[1] = id[i];
            graph[id[i]].flag[2] = id[i - 1];
        }
    }

    sort(id + 1, id + n + 1, d2_compare);    
    for (int i = 2; i <= n; i++) {
        if (graph[id[i - 1]].d2 == graph[id[i]].d2) {
            graph[id[i - 1]].flag[0] = id[i];
            graph[id[i]].flag[3] = id[i - 1];
        }
    }

    int result = 1;
    for (int i = 1; i <= k; i++) {
        int nxt = graph[result].flag[dir[i] - 'A'];
        if (nxt == -1) continue;
        for (int j = 0; j < 4; j++) {
            if (graph[result].flag[j] != -1){
                graph[graph[result].flag[j]].flag[3 - j] = graph[result].flag[3 - j];
            }
        }
        result = nxt;
    }

    cout << graph[result].x << ' ' << graph[result].y << endl;

    return 0;
}
```

---

## 作者：Night_sea_64 (赞：2)

翻译有点怪，这里先解释一下题面。

大意就是给定 $n$ 个关键点的坐标，一个人（可能是青蛙，但是不用管那么多了）一开始在第一个关键点处。她会跳 $m$ 次，每次向右下（`A`）、左下（`B`）、右上（`C`）或左上（`D`）跳到最近的一棵关键点上，如果没有就不跳。跳完之后起跳位置的关键点会消失。问跳完之后的坐标。

因为这里还会删除点而不用随机访问，所以可以用链表维护每条斜着的线上的所有点，这样也能每次都知道某方向上离得最近的是哪个点。但是因为坐标太大，所以需要先离散化一下。

代码又臭又长。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<map>
#include<cstring>
using namespace std;
int n,m;
char op[100010];
struct plant{int id,x,y;}a[100010];
bool cmp1(const plant &x,const plant &y){
    return x.x<y.x;
}
bool cmp2(const plant &x,const plant &y){
    return x.id<y.id;
}
map<int,int>mp;
int t,tail[200010],cur1,cur2,p1[100010],p2[100010];
struct node{int id,last,next;}l1[100010],l2[100010];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)cin>>op[i];
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].x>>a[i].y;
        a[i].id=i;
    }
    sort(a+1,a+n+1,cmp1);
    for(int i=1;i<=n;i++)
    {
        if(!mp[a[i].x+a[i].y])mp[a[i].x+a[i].y]=++t;
        int k=mp[a[i].x+a[i].y];
        cur1++;
        if(tail[k])l1[tail[k]].next=cur1,l1[cur1].last=tail[k];
        l1[cur1].id=a[i].id,p1[a[i].id]=tail[k]=cur1;
    }
    mp.clear(),t=0;
    memset(tail,0,sizeof(tail));
    for(int i=1;i<=n;i++)
    {
        if(!mp[a[i].x-a[i].y])mp[a[i].x-a[i].y]=++t;
        int k=mp[a[i].x-a[i].y];
        cur2++;
        if(tail[k])l2[tail[k]].next=cur2,l2[cur2].last=tail[k];
        l2[cur2].id=a[i].id,p2[a[i].id]=tail[k]=cur2;
    }
    sort(a+1,a+n+1,cmp2);
    int now=1;
    for(int i=1;i<=m;i++)
    {
        if(op[i]=='A')
        {
            int p=p2[now];
            if(l2[p].next)
            {
                int q=p1[now];
                now=l2[l2[p].next].id;
                l1[l1[q].next].last=l1[q].last;
                l1[l1[q].last].next=l1[q].next;
                l2[l2[p].next].last=l2[p].last;
                l2[l2[p].last].next=l2[p].next;
            }
        }
        else if(op[i]=='B')
        {
            int p=p1[now];
            if(l1[p].next)
            {
                int q=p2[now];
                now=l1[l1[p].next].id;
                l1[l1[p].next].last=l1[p].last;
                l1[l1[p].last].next=l1[p].next;
                l2[l2[q].next].last=l2[q].last;
                l2[l2[q].last].next=l2[q].next;
            }
        }
        else if(op[i]=='C')
        {
            int p=p1[now];
            if(l1[p].last)
            {
                int q=p2[now];
                now=l1[l1[p].last].id;
                l1[l1[p].next].last=l1[p].last;
                l1[l1[p].last].next=l1[p].next;
                l2[l2[q].next].last=l2[q].last;
                l2[l2[q].last].next=l2[q].next;
            }
        }
        else if(op[i]=='D')
        {
            int p=p2[now];
            if(l2[p].last)
            {
                int q=p1[now];
                now=l2[l2[p].last].id;
                l1[l1[q].next].last=l1[q].last;
                l1[l1[q].last].next=l1[q].next;
                l2[l2[p].next].last=l2[p].last;
                l2[l2[p].last].next=l2[p].next;
            }
        }
    }
    cout<<a[now].x<<" "<<a[now].y<<endl;
    return 0;
}
```

---

## 作者：ybw731 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P7193)

# Part 1 题意

- Barica 在湖中的第一种植物上，每次按一个方向跳到第一种植物上，求最终的位置。

# Part 2 思路

- 显然，这道题是一道~~谁都会~~模拟题，十分简单（~~但为什么楼上楼下都这么长~~）。
- 我们先看一下 AD 方向的斜线有什么特点，不难知道 $x+y$ 是定值，所以我们用 $sum1$ 来区分每一条 AD 方向的斜线。
- 同理，我们用 $sum2$ 来区分每一条 BC 方向的斜线。
- 这样，我们先按 $sum1$ 排序，就可以知道一个点的 A 方向及 D 方向的第一种植物的下标，用 $l_1,l_2$ 表示。
- 然后，我们先按 $sum2$ 排序，就可以知道一个点的 B 方向及 C 方向的第一种植物的下标，用 $l_0,l_3$ 表示。
- 最后，我们只要运用链表的思想，就可以求出 Barica 的最终位置。

# Part 3 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,p=1;
char ch[100005];
int id[100005];
struct Node{
	int sum1,sum2,x,y;
	int l[4];
}a[100005];
bool Cmp1(int x,int y){
	if(a[x].sum1!=a[y].sum1)
		return a[x].sum1<a[y].sum1;
	return a[x].x<a[y].x;
}
bool Cmp2(int x,int y){
	if(a[x].sum2!=a[y].sum2)
		return a[x].sum2<a[y].sum2;
	return a[x].x<a[y].x;
}
signed main(){
	cin>>n>>k;
	for(int i=1;i<=k;i++)
		cin>>ch[i];
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
		id[i]=i;
		a[i].sum1=a[i].x+a[i].y;
		a[i].sum2=a[i].x-a[i].y;
	}
	sort(id+1,id+n+1,Cmp1);
	for(int i=2;i<=n;i++)
		if(a[id[i]].sum1==a[id[i-1]].sum1){
			a[id[i-1]].l[1]=id[i];
			a[id[i]].l[2]=id[i-1];
		}
	sort(id+1,id+n+1,Cmp2);
	for(int i=2;i<=n;i++)
		if(a[id[i]].sum2==a[id[i-1]].sum2){
			a[id[i-1]].l[0]=id[i];
			a[id[i]].l[3]=id[i-1];
		}
	for(int i=1;i<=k;i++){
		int nxt=a[p].l[ch[i]-'A'];
		if(!nxt) continue;
		for(int j=0;j<4;j++)
			if(a[p].l[j])
				a[a[p].l[j]].l[3-j]=a[p].l[3-j];
		p=nxt;
	}
	cout<<a[p].x<<" "<<a[p].y;
	return 0;
}

```

## Part 5 结尾

- $\textcolor{black}{复制}$ 一时爽。
- $\textcolor{brown}{棕名}$ 两行泪。

# [AC链接](https://www.luogu.com.cn/record/178852732)

---

## 作者：whx2009 (赞：0)

## 本题思路：
这道题通过每次跳跃的横纵坐标加的数要么相等，要么相反，我们就可以发现如果可以跳跃那么一定是斜率相等的直线。

我们就可以对于每一个斜率下每一个纵坐标等于零的横坐标去开一棵平衡树，然后每次根据当前数的前驱后继找到下一次需要跳的点，在平衡树上删除。
## 提示：
每个点最开始对应了两个斜率，需要开两个平衡树。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define ls tr[p].ch[0]
#define rs tr[p].ch[1]
#define ls1 tr1[p].ch[0]
#define rs1 tr1[p].ch[1]
using namespace std;
int u[100005],v[100005];
struct f{int ch[2],id,sum,rnd;}tr[100005],tr1[100005];
void split(int p,int &x,int &y,int k){
	if(!p){x=y=0;return;}
	if(tr[p].sum<=k){x=p;split(rs,rs,y,k);}
	else y=p,split(ls,x,ls,k);
}
void split1(int p,int &x,int &y,int k){
	if(!p){x=y=0;return;}
	if(tr1[p].sum<=k){x=p;split1(rs1,rs1,y,k);}
	else y=p,split1(ls1,x,ls1,k);
}
void merge(int &p,int x,int y){
	if(!x||!y){p=x+y;return;}
	if(tr[x].rnd<=tr[y].rnd){p=x;merge(rs,rs,y);}
	else p=y,merge(ls,x,ls);
}
void merge1(int &p,int x,int y){
	if(!x||!y){p=x+y;return;}
	if(tr1[x].rnd<=tr1[y].rnd){p=x;merge1(rs1,rs1,y);}
	else p=y,merge1(ls1,x,ls1);
}
int root[100001],root1[100001],cnt,cnt1;
int chama(int p){while(p){if(rs) p=rs;else return tr[p].id;}}
int chami(int p){while(p){if(ls) p=ls;else return tr[p].id;}}
int chama1(int p){while(p){if(rs1) p=rs1;else return tr1[p].id;}}
int chami1(int p){while(p){if(ls1) p=ls1;else return tr1[p].id;}}
int add(int k,int sum){
tr[++cnt].sum=sum;tr[cnt].id=k;tr[cnt].rnd=rand();return cnt;}
int add1(int k,int sum){
tr1[++cnt1].sum=sum;tr1[cnt1].id=k;tr1[cnt1].rnd=rand();return cnt1;}
map<int,int>mp,mp1;
void shan(int id){
	int xx=0,yy=v[id]-u[id];
	int z,x,y,op=mp[yy];
	split(root[op],x,y,u[id]);
	split(x,x,z,u[id]-1);
	merge(root[op],x,y);
	yy=v[id]+u[id];op=mp1[yy];
	split1(root1[op],x,y,u[id]);
	split1(x,x,z,u[id]-1);
	merge1(root1[op],x,y);
}
signed main(){
//	freopen("1.in","r",stdin);
	srand(time(0)); 
	int n,m;cin>>n>>m;
	string s;cin>>s;s=' '+s;
	int top=0,top1=0;
	for(int i=1;i<=n;i++){
		cin>>u[i]>>v[i];
		int xx=0,yy=v[i]-u[i];
		if(mp[yy]==0) mp[yy]=++top;
		int op=mp[yy],x,y;
		split(root[op],x,y,u[i]);
		merge(x,x,add(i,u[i]));
		merge(root[op],x,y);
		yy=v[i]+u[i];
		if(mp1[yy]==0) mp1[yy]=++top1;
		op=mp1[yy];
		split1(root1[op],x,y,u[i]);
		merge1(x,x,add1(i,u[i]));
		merge1(root1[op],x,y);
	}
//	cout<<root[1]<<endl;
	int uu=u[1],vv=v[1],id=1;
	for(int i=1;i<=m;i++){
		if(s[i]=='A'||s[i]=='D'){
			int xx=0,yy=v[id]-u[id];
			int x,y,op=mp[yy];
			if(s[i]=='A'){
				split(root[op],x,y,u[id]);
				if(y!=0){
					int id1=chami(y);
					merge(root[op],x,y);
					shan(id);id=id1;
				}
				else merge(root[op],x,y);
			}
			else{
				split(root[op],x,y,u[id]-1);
				if(x!=0){
					int id1=chama(x);
					merge(root[op],x,y);
					shan(id),id=id1;
				}
				else merge(root[op],x,y);
			}
		}
		if(s[i]=='C'||s[i]=='B'){
			int xx=0,yy=v[id]+u[id];
			int x,y,op=mp1[yy];
			if(s[i]=='B'){
				split1(root1[op],x,y,u[id]);
				if(y!=0){
					int id1=chami1(y);
					merge1(root1[op],x,y);
					shan(id);id=id1;
				}
				else merge1(root1[op],x,y);
			}
			else{
				split1(root1[op],x,y,u[id]-1);
				if(x!=0){
					int id1=chama1(x);
					merge1(root1[op],x,y);
					shan(id),id=id1;
				}
				else merge1(root1[op],x,y);
			}
		}
	}
	cout<<u[id]<<" "<<v[id];
	return 0;
}
```

---

## 作者：technopolis_2085 (赞：0)

分析：

观察斜线，发现以下规律：

如果斜线从左下到右上，则每一个点的横纵坐标之差为定值；
如果斜线从右下到左上，则每一个点的横纵坐标之和为定值。

所以就可以维护出现的每一条斜线了。可以用 set 存放每一条斜线上的点的横坐标，然后再用一个 map 来记录横纵坐标的差或者和，即为斜线的参数。

然后每次查找大于等于某个值的横坐标，若存在，则删除原来的点；不存在，则跳过该操作。

综上，时间复杂度为 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

map<int,set<int> > dign1; 
map<int,set<int> > dign2;

const int maxn=1e5+10;
struct node{
	int x,y;
};
node a[maxn];
char s[maxn];
map<pair<int,int> , int> Dian;//点的坐标，方便我们通过坐标来找点

int Get_pos(int x,int y){//通过坐标来找到对应的点
	return Dian[make_pair(x,y)];
}

void del(int u){//删除该点，则将其分别从两条斜线上删除
	dign1[a[u].x-a[u].y].erase(a[u].x);
	dign2[a[u].x+a[u].y].erase(a[u].x);
}
int main(){
	int n,k;
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	for (int i=1;i<=n;i++){
		scanf("%lld%lld",&a[i].x,&a[i].y);
		dign1[a[i].x-a[i].y].insert(a[i].x);//左下到右上的斜线，差恒定
		dign2[a[i].x+a[i].y].insert(a[i].x);//左上到右下的斜线，和恒定
		Dian[make_pair(a[i].x,a[i].y)]=i;
	}
	
	int u=1;
	for (int i=1;i<=k;i++){
	//	printf("%d:\n",i);
		if (s[i]=='A'){//rightdown
			int cha=a[u].x-a[u].y;
			set<int>::iterator it=dign1[cha].lower_bound(a[u].x);//找到第一个大于等于原先坐标的点
			
			if ((*it)==a[u].x) it++;//若等于原先坐标，则移动到下一个位置
			if (it==dign1[cha].end()) continue;//没有，则忽略操作
			
			int num=(*it);
			int delta=num-a[u].x;//偏移量，即题目中的p
			del(u);//删除该点
	//		printf("%d del\n",u);
			u=Get_pos(num,a[u].y+delta);//找到操作后的点
		}else if (s[i]=='B'){//rightup
			int cha=a[u].x+a[u].y;
			set<int>::iterator it=dign2[cha].lower_bound(a[u].x);
			
			if ((*it)==a[u].x) it++;
			if (it==dign2[cha].end()) continue;
			
			int num=(*it);
			int delta=num-a[u].x;
			del(u);
	//		printf("%d del\n",u);
			u=Get_pos(num,a[u].y-delta);
		}else if (s[i]=='C'){//leftdown
			int cha=a[u].x+a[u].y;
			set<int>::iterator it=dign2[cha].lower_bound(a[u].x);
			
			if (it==dign2[cha].begin()&&(*it)==a[u].x) continue;
			it--; 
			
			int num=(*it);
			int delta=a[u].x-num;
			del(u);
	//		printf("%d del\n",u);
			u=Get_pos(num,a[u].y+delta);
		}else{
			int cha=a[u].x-a[u].y;
			set<int>::iterator it=dign1[cha].lower_bound(a[u].x);
			
			if (it==dign1[cha].begin()&&(*it)==a[u].x) continue;//没有比当前横坐标更小的横坐标了
			it--;//有的话就减1，因为lower_bound查找的是大于等于
			
			int num=(*it);
			int delta=a[u].x-num;//偏移量
			del(u);//删除点
//			printf("%d del\n",u);
			u=Get_pos(num,a[u].y-delta);//找到点的坐标
		}
//		printf("final %d\n",u);
	}
	
	printf("%d %d\n",a[u].x,a[u].y);
	return 0;
}
```


---

## 作者：Genshineer (赞：0)

## 题意概括

在坐标系中，每次选择左上、左下、右上、右下四个方向中的一个，移动到方向的下一个有标记的点上，并将当前节点删除；若方向上无标记点，则不移动。

## 分析

不难发现每次都沿着直线 $y=x+b$ 或 $y=-x+b$（$b$ 为任意常数）移动，于是有 $x+y=b$ 或 $x-y=b$，于是若满足条件 $x_i+y_i=x_j+y_j(i<j)$，而且第 $i$ 个点与第 $j$ 个点间无其他点（表现为 $x_i$ 与 $x_j$ 之间无满足条件的 $x$），则在第 $i$ 个点进行 `B` 或在第 $j$ 个点进行 `D`，可以相互到达。$x-y=b$ 与此同理。于是对于每个可以相互到达的点，可以连一条双向边，得到一个图，从图的 $1$ 号节点开始模拟即可。考虑到走过的节点需要被删除，可以用类似链表的方法，每个点向 $4$ 个方向分别连一条链，方向上没有其他点的链则指向 $-1$。则模拟过程只需要 $O(k)$ 地遍历整个字符串：如果链不指向 $-1$ 则向前跳，并删除当前节点；如果链指向 $-1$，则跳过本次操作。

那么如何预处理出图呢？

考虑到需要选出 $x+y$（或 $x-y$） 相等的点，于是不难想到存一个结构体包含 $x,y,id$，$x,y$ 表示坐标，$id$ 表示点在输入中的编号。分别根据 $x+y$ 和 $x-y$ 为第一关键字，$x$ 为第二关键字进行两次排序。这么做的好处是既能将 $x+y$ （或 $x-y$）相等的点放到一起，或者说放到数组的**同一块**（？？这也是一种分块思想的体现？？），也能让块内 $x$ 按照升序（或降序，由程序的 `cmp` 函数决定）排列。这样既保证可以在 $O(n)$ 的复杂度内找到所有能连接的点并建立连边，同时保证相邻的两个点之间中间没有其他点，即可以直接连边不再判断。这一部分的时间复杂度为 $O(2n\log n+2n)$，即 $O(n\log n)$，瓶颈在排序。

于是由于 $n,k$ 同阶，总的时间复杂度就是 $O(n\log n+k)$，即 $o(n\log n)$。

## CODE

**PS**：这题在删除连边时注意要**四个方向**都删干净，不能只删当前走的两个方向。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e5 + 5;
int n, k;
string op;
unordered_map<char, int> F; // F('A') = 3(right_up), F('B') = 4(right_down), F('C') = 1(left_up), F('D') = 2(left_down)
unordered_map<int, int> f; // f(1) = 4, f(4) = 1, f(3) = 2, f(2) = 3.标记相反方向
struct data {
	int x, y, id;
} a[maxn];
struct edge {
	int direct[5]; // 1 is left_up, 2 is left_down, 3 is right_up, 4 is right_down.
} e[maxn];
// bool flag[maxn];

inline int get(int x) { // 找到与当前方向垂直的方向
	if (x == 4 or x == 1) return 2;
	if (x == 2 or x == 3) return 1;
	return 1;
}

bool cmp1(data x, data y) { // 按照 x + y 排序
	if ((x.x + x.y) != (y.x + y.y)) return (x.x + x.y) < (y.x + y.y);
	return x.x < y.x;
}

bool cmp2(data x, data y) { // 按照 x - y 排序
	if ((x.x - x.y) != (y.x - y.y)) return (x.x - x.y) < (y.x - y.y);
	return x.x < y.x;
}

bool cmp3(data x, data y) { // 还原原顺序
	return x.id < y.id;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);

	F['A'] = 3, F['B'] = 4, F['C'] = 1, F['D'] = 2; // 建立字符与方向的映射
	f[1] = 4, f[4] = 1, f[3] = 2, f[2] = 3; // 建立方向与其相反方向的映射

	cin >> n >> k;
	cin >> op;
	for (int i = 1; i <= n; i++) cin >> a[i].x >> a[i].y, a[i].id = i;
    // 预处理 y = - x + b 方向上的连边
	sort(a + 1, a + n + 1, cmp1);
	for (int i = 1; i <= n; i++) {
		if (a[i].x + a[i].y == a[i - 1].x + a[i - 1].y and a[i - 1].id != 0) {
			e[a[i].id].direct[1] = a[i - 1].id;
			e[a[i - 1].id].direct[4] = a[i].id;
		}
		else {
			e[a[i].id].direct[1] = -1;
			e[a[i - 1].id].direct[4] = -1;
		}
	}
    // 预处理 y = x + b 方向上的连边
	sort(a + 1, a + n + 1, cmp2);
	for (int i = 1; i <= n; i++) {
		if (a[i].x - a[i].y == a[i - 1].x - a[i - 1].y and a[i - 1].id != 0) {
			e[a[i].id].direct[2] = a[i - 1].id;
			e[a[i - 1].id].direct[3] = a[i].id;
		}
		else {
			e[a[i].id].direct[2] = -1;
			e[a[i - 1].id].direct[3] = -1;
		}
	}
	// for (int i = 1; i <= n; i++) {
		// for (int j = 1; j <= 4; j++) {
			// cout << e[i].direct[j] << " ";
		// }
		// cout << "\n";
	// }
    // 还原原序列的顺序
	sort(a + 1, a + n + 1, cmp3);
	int p = 1;
	for (int i = 0; i < k; i++) {
		int dir = F[op[i]];
		int v = e[p].direct[dir], last = e[p].direct[f[dir]], other_last = get(dir), l = p;
		// while (flag[v] and v > 0) v = e[v].direct[dir];
		if (v <= 0) continue; // 方向上没有其他点就跳过
		// flag[v] = 1;
		p = v;
        // 从四个方向上删除连边，注意判断方向上的点是否存在
		if (last > 0) e[last].direct[dir] = v;
		if (e[l].direct[other_last] > 0) e[e[l].direct[other_last]].direct[f[other_last]] = e[l].direct[f[other_last]];
		if (e[l].direct[f[other_last]] > 0) e[e[l].direct[f[other_last]]].direct[other_last] = e[l].direct[other_last];
		e[v].direct[f[dir]] = last;
	}
	cout << a[p].x << " " << a[p].y << "\n";
}
```

---

## 作者：_Fontainebleau_ (赞：0)

首先有一个很重要的东西就是，一条对角线上，$x+y$ 或 $x-y$ 的值是不变的。

Why？

对于题目中的方向 A,D $(x+p)-(y+p)=(x-p)-(y-p)=x-y$。

对于题目中的方向 B,C $(x+p)+(y-p)=(x-p)+(y+p)=x+y$。 

于是我们就可以用这个性质将同一对角线上的点用链表连起来。最后依据所给操作模拟即可。

当然，也许可以直接坐标系旋转之后再做？

```cpp
#include<bits/stdc++.h>
using namespace std;
struct point{
	int x,y;
	int sum1,sum2;
    //sum1-x+y,sum2-x-y
	int l[4];//链表
	//l0-A,l1-B,l2-C,l3-D
}a[100005];
int n,k,id[100005];
char op[100005];
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
inline bool cmp1(int x,int y)
{
	return (a[x].sum1==a[y].sum1)?a[x].x<a[y].x:a[x].sum1<a[y].sum1;
}
inline bool cmp2(int x,int y)
{
	return (a[x].sum2==a[y].sum2)?a[x].x<a[y].x:a[x].sum2<a[y].sum2;
}
int main()
{
	n=read(),k=read();
	cin>>op+1;
	for(int i=1;i<=n;i++)
	{
		int x=read(),y=read();
		id[i]=i,a[i].x=x,a[i].y=y,a[i].sum1=x+y,a[i].sum2=x-y;
	}
	sort(id+1,id+1+n,cmp1);
	for(int i=2;i<=n;i++)//左上-右下的对角线
		if(a[id[i]].sum1==a[id[i-1]].sum1)
			a[id[i-1]].l[1]=id[i],a[id[i]].l[2]=id[i-1];//B,C
	sort(id+1,id+1+n,cmp2);
	for(int i=2;i<=n;i++)//右上-左下的对角线
		if(a[id[i]].sum2==a[id[i-1]].sum2)
			a[id[i-1]].l[0]=id[i],a[id[i]].l[3]=id[i-1];//A,D
	int pos=1;
	for(int i=1;i<=k;i++)
	{
		int nxt=a[pos].l[op[i]-'A'];
		if(!nxt)	continue;
		for(int j=0;j<4;j++)
			if(a[pos].l[j])
				a[a[pos].l[j]].l[3-j]=a[pos].l[3-j];//链表的基本操作，删除一个节点
		pos=nxt;
	}
	printf("%d %d\n",a[pos].x,a[pos].y);
	return 0;
}

```



---

## 作者：yxy666 (赞：0)

核心想法就是利用对角线的特性，同一条对角线的 $x+y$ 或者 $x-y$ 是定值，这样就可以解决同线的问题。接下来就是按照顺序模拟即可,唯独需要注意的就是跳一个，需要擦除一个，也就是把边取消，重新建立链接关系。

code :
```cpp
#include<bits/stdc++.h>
#define maxn 100005
using namespace std;
int n,k,id[maxn];
char S[maxn];
struct ZS {
   int x,y,d1,d2,flg[4];
}pos[maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();}
	while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return ret*f;
}
bool cmp_d1(int i,int j){return pos[i].d1<pos[j].d1||pos[i].d1==pos[j].d1&&pos[i].d2<pos[j].d2;}
bool cmp_d2(int i,int j){return pos[i].d2<pos[j].d2||pos[i].d2==pos[j].d2&&pos[i].d1<pos[j].d1; }
int main(){
    n=read(),k=read();
    scanf("%s",S);
    for (int i=1;i<=n;i++){
    	pos[i].x=read(),pos[i].y=read();
        pos[i].d1=pos[i].x+pos[i].y;
        pos[i].d2=pos[i].x-pos[i].y;
        for (int j=0;j<4;j++) pos[i].flg[j]=-1;
        id[i]=i;
    }
    sort(id+1,id+1+n,cmp_d1);//离散
    for (int i=2;i<=n;i++)//同一条对角线相邻两个进行建图连边 
      if (pos[id[i-1]].d1==pos[id[i]].d1){
      	pos[id[i-1]].flg[1]=id[i  ];//等价于B 
        pos[id[i  ]].flg[2]=id[i-1];//等价于C
    }
    sort(id+1,id+1+n,cmp_d2);
    for (int i=2;i<=n;i++)//同一条对角线相邻两个进行建图连边 
      if (pos[id[i-1]].d2==pos[id[i]].d2){
      	pos[id[i-1]].flg[0]=id[i  ];//等价于A
        pos[id[i  ]].flg[3]=id[i-1];//等价于D
    }
    int ret=1;
    for (int i=0;S[i];i++){//模拟 
    	int next=pos[ret].flg[S[i]-'A'];
        if (next==-1) continue;
        for (int j=0;j<4;j++)//目的就是在擦掉ret这个节点，也就是说在毁掉ret这个节点的边 
          if (pos[ret].flg[j]!=-1) pos[pos[ret].flg[j]].flg[3-j]=pos[ret].flg[3-j];
        ret=next;
    }
    printf("%d %d\n",pos[ret].x,pos[ret].y);
    return 0;
}
```


---


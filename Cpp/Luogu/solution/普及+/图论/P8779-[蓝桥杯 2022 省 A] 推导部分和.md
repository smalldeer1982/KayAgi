# [蓝桥杯 2022 省 A] 推导部分和

## 题目描述

对于一个长度为 $N$ 的整数数列 $A_{1}, A_{2}, \cdots A_{N}$，小蓝想知道下标 $l$ 到 $r$ 的部分和 $\sum\limits_{i=l}^{r}A_i=A_{l}+A_{l+1}+\cdots+A_{r}$ 是多少?

然而，小蓝并不知道数列中每个数的值是多少，他只知道它的 $M$ 个部分和的值。其中第 $i$ 个部分和是下标 $l_{i}$ 到 $r_{i}$ 的部分和 $\sum_{j=l_{i}}^{r_{i}}=A_{l_{i}}+A_{l_{i}+1}+\cdots+A_{r_{i}}$, 值是 $S_{i}$ 。

## 说明/提示

对于 $10 \%$ 的评测用例, $1 \leq N, M, Q \leq 10,-100 \leq S_{i} \leq 100$ 。

对于 $20 \%$ 的评测用例, $1 \leq N, M, Q \leq 20,-1000 \leq S_{i} \leq 1000$ 。

对于 $30 \%$ 的评测用例, $1 \leq N, M, Q \leq 50,-10000 \leq S_{i} \leq 10000$ 。

对于 $40 \%$ 的评测用例, $1 \leq N, M, Q \leq 1000,-10^{6} \leq S_{i} \leq 10^{6}$ 。

对于 $60 \%$ 的评测用例, $1 \leq N, M, Q \leq 10000,-10^{9} \leq S_{i} \leq 10^{9}$ 。

对于所有评测用例, $1 \leq N, M, Q \leq 10^{5},-10^{12} \leq S_{i} \leq 10^{12}, 1 \leq l_{i} \leq r_{i} \leq N$, $1 \leq l \leq r \leq N$ 。数据保证没有矛盾。

蓝桥杯 2022 省赛 A 组 J 题。

## 样例 #1

### 输入

```
5 3 3
1 5 15
4 5 9
2 3 5
1 5
1 3
1 2```

### 输出

```
15
6
UNKNOWN```

# 题解

## 作者：loser_seele (赞：24)

前置知识：[P1196](https://www.luogu.com.cn/problem/P1196) 和 [ABC238E](https://www.luogu.com.cn/problem/AT_abc238_e)。不知道为什么两个绿题缝合起来变成黄题了。

首先考虑怎么判断无解的情况。[见这篇题解](https://www.luogu.com.cn/blog/lovely-seele/solution-at-abc238-e)

观察到原数组的具体取值并不重要，我们需要的只是区间 $ [l,r] $ 的和为 $ sum_r-sum_{l-1} $，其中 $ sum $ 代表前缀和。

于是不难想到一个思路：对于给定的一个区间 $ [l,r] $，建无向边 $ (l-1,r) $，代表由 $ sum_r $ 的信息能推出 $ sum_{l-1} $ 的信息，反之亦然。

于是我们已知 $ sum_0=0 $，对于一个询问，问题转化为从图上的 $ l-1 $ 节点能否到达 $ r $。这个可以直接用并查集维护。当两个端点不连通则代表无解。

但是现在我们除了知道是否连通之外还需要知道具体的区间和，于是考虑在并查集上维护一个 $ val $，表示当前区间到根节点 $ 0 $ 的距离，初始设为 $ 0 $，当合并两个集合时将两个集合对应的 $ val $ 值合并即可，则如果当前区间和能被计算出来则区间和为 $ val_r-val_{l-1} $。

时间复杂度 $ \mathcal{O}(n) $，可以通过。

双倍经验：[hdu3038](http://acm.hdu.edu.cn/showproblem.php?pid=3038)，思路基本是一致的。

代码：

```cpp
#import <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=200000+10;
int n,m,a,b,s;
int par[maxn],val[maxn];
void init(int l,int r)
{
for(int i=l;i<=r;i++) 
par[i]=i,val[i]=0;
}
int find(int x)
{
    if(par[x]==x) 
    return x;
    else
    {
        int root=find(par[x]);
        val[x]+=val[par[x]];
        return 
        par[x]=root;
    }
}
signed main()
{
    cin>>n>>m;
    int q;
    cin>>q;
    init(0,n);
    int ans=0;
    for(int i=1,a,b,s;i<=m;i++)
    {
        scanf("%lld%lld%lld",&a,&b,&s); 
        a--;
        int t1=find(a),t2=find(b);
        if(t1!=t2)
        {
            par[t2]=t1;
            val[t2]=-val[b]+s+val[a];
        }
    }
    while(q--)
    {
        scanf("%d%d",&a,&b); 
        a--;
        int t1=find(a),t2=find(b);
        if(t1!=t2)
        cout<<"UNKNOWN\n";
        else
        cout<<val[b]-val[a]<<'\n';
    }
}
```


---

## 作者：technopolis_2085 (赞：13)

分析：

看到题解里有用差分约束做的，我这里提供一种用 **带权并查集** 的做法。

令 $sum_i$ 表示以 $i$ 为结尾的前缀和。

对于给定的 $l$，$r$，$S$：

把 $l$ 减去 $1$，因为前缀和相减的方法是 $sum_r - sum_{l-1}$。

首先我们判断 $l$ 和 $r$ 是否在同一个并查集里。

如果不在，则合并两个并查集。

否则：

令 $fl$ 表示 $l$ 并查集的代表元素，$fr$ 为 $r$ 并查集里的代表元素。

让 $fl$ 的代表元为 $fr$，所以

```cpp
fa[fl]=fr;
```

此时计算 $sum$ 值：

```cpp
sum[fl]=-x-sum[l]+sum[r];
```

至于为什么会是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/l0j7oujo.png)


最后，对于每一个询问 $l$ 和 $r$，

若 $l$ 和 $r$ 不在一个并查集里，则无解。

否则，输出 $sum_r - sum_{l-1}$。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=2*1e5+10;
int fa[maxn],sum[maxn];

int find(int x)
{
	if (fa[x]==x) return fa[x];
	
	int t=find(fa[x]);
	sum[x]+=sum[fa[x]];
	fa[x]=t;
	
	return fa[x];
}

signed main()
{
	int n,m,q;
	scanf("%lld%lld%lld",&n,&m,&q);
	
	for (int i=1;i<=n;i++) fa[i]=i;
	
	int ans=0;
	while (m--)
	{
		int l,r,x;
		scanf("%lld%lld%lld",&l,&r,&x);
		
		l--;
		
		int fl=find(l),fr=find(r);
		
		if (fl!=fr)
		{
			fa[fl]=fr;
			sum[fl]=-x-sum[l]+sum[r];
		}
	}
	
	while (q--){
		int l,r;
		scanf("%lld%lld",&l,&r);
		l--;
		
		int fl=find(l),fr=find(r);
		
		if (fl!=fr) printf("UNKNOWN\n");
		else printf("%lld\n",sum[r]-sum[l]);
	}
	return 0; 
}
```



---

## 作者：hj23308 (赞：8)

[题目传送门](/problem/P8779)

### $\mathcal{Problem}$

对于一个长为 $ n $ 的数组 $ a $，给出 $ m $ 个区间的数字和。

$ q $ 次查询，每次给出一个区间，判断能否由已知信息推导出该区间的和，若可以则输出，否则输出 $ \texttt{UNKNOWN} $。

### $\mathcal{Solution}$

记 $s _ i = \sum\limits_{i = 1} ^ i a _ i$。

考虑建图，对于每个已知和：$ l _ i \sim r _ i $ 的和为 $ S _ i $，建立一条 $ l \to r $ 权为 $ S _ i $ 的边和一条 $ r \to l $ 权为 $ -S _ i $ 的边，表示 $ s _ r - s _ {l - 1} = S _ i $。

对于一次查询 $ l, r $：若 $ l - 1 $ 与 $ r $ 不联通，则无解；否则可以直接 dfs 算出 $ l - 1 $ 与 $ r $ 的相对大小关系（$ s _ r $ 与 $ s _ {l - 1} $ 的差）。 

时空复杂度 $ \mathcal{O(n)} $。

### $\mathcal{Code}$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxN = 1e5 + 1;

int m, q, tot;
array<int, maxN> col;
array<long long, maxN> s;
array<vector<pair<int, long long>>, maxN> edges;

void dfs(int u) { for (auto [v, w]: edges[u]) if (!col[v]) s[v] = s[u] + w, col[v] = col[u], dfs(v); }

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> m >> m >> q;
	while (m--) {
		int l, r;
		long long t;
		cin >> l >> r >> t, l--;
		edges[l].emplace_back(r, t);
		edges[r].emplace_back(l, -t);
	}
	while (q--) {
		int l, r;
		cin >> l >> r, l--;
		if (!col[l]) col[l] = ++tot, dfs(l);
		if (col[l] == col[r]) cout << s[r] - s[l] << '\n';
		else cout << "UNKNOWN\n";
	}

	return 0;
}
```

---

## 作者：Lord_Sky2048 (赞：2)

 对于已知的区间 $[l,r]$ 的和为 $s$ ，用前缀和 $sum_i - sum_{l-1}=s$ 表示，根据差分约束建图准则，相当于点 $l-
 1$ 到点 $r$ 长度为 $s$ ，$r$ 到 $l - 1$ 长度为 $-s$ 。
 
 建好图之后，每次询问一个区间 $[al,ar]$ 的和，相当于询问 $sum[ar]-sum[al-1]$ 的值。
 
 首先要保证 $al-1$ 和 $ar$ 在同一个连通块中，其次每个连通块只需要随便一个点初始化为0，然后按照边长扩展即可。这是由于等号，不管怎么走，相对差值是不变的。
 
广度优先搜索、深度优先搜索均可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 10005;
const ll INF = -1e13;
int n, m, q;
template <typename T>
inline T read(T& x) {
  x = 0;
  T w = 1;
  char ch = 0;
  while (ch < '0' || ch > '9') {
    if (ch == '-') w = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9') {
    x = x * 10 + (ch - '0');
    ch = getchar();
  }
  return x = x * w;
}
struct edge
{
    int v; ll w;
    edge(){}
    edge(int v, ll w):v(v), w(w){}
};
vector<edge>Map[maxn];
ll sum[maxn];
bool vis[maxn];
void dfs(int u, ll d)
{
    vis[u] = 1;
    sum[u] = d;
    for(auto x : Map[u])
    {
        int v = x.v; ll w = x.w;
        if(vis[v])continue;
        dfs(v, d + w);
    }
}
queue<pair<int,ll> >Q;
void bfs(int u, ll d)
{
    vis[u] = 1;
    sum[u] = d;
    Q.push(make_pair(u, d));
    while(!Q.empty())
    {
        auto now = Q.front();
        Q.pop();
        int u = now.first; ll d = now.second;
        for(auto x : Map[u])
        {
            int v = x.v; ll w = x.w;
            if(vis[v])continue;
            vis[v] = 1;
            sum[v] = d + w;
            Q.push(make_pair(v, d + w));
        }
    }
}
int f[maxn];
int Find(int x)
{
    return x == f[x] ? x : f[x] = Find(f[x]);
}
int main()
{
    read(n);read(m);read(q);
    for(int i = 0; i <= n; i++)f[i] = i;
    for(int i = 1; i <= m; i++)
    {
        int l, r; ll s;
        read(l);read(r);read(s);
        ///cout<<l<<" "<<r<<" "<<s<<endl;
        ///sum[r] - sum[l - 1] = s
        Map[l - 1].push_back(edge(r, s));
        Map[r].push_back(edge(l - 1, -s));
        f[Find(l - 1)] = Find(r);
    }
    for(int i = 0; i <= n; i++)if(!vis[i])
        bfs(i, 0);
    while(q--)
    {
        int l, r;
        read(l), read(r);
        --l;
        if(Find(l) != Find(r))puts("UNKNOWN");
        else printf("%lld\n", sum[r] - sum[l]);
    }
    return 0;
}

```


---

## 作者：for_fo_f (赞：1)

## 题目分析
题目给了 $m$ 个已知的区间的和。

定义 $S_{i}$ 表示 $\sum_{j=1}^iA_{j}$ （前缀和）。

第 $i$ 个区间的和可以表示为：

$$\sum_{j=L}^RA_{j}$$

$$=S_{r}-S_{l-1}$$

这样问题就变为了告诉你 $n$ 对点权值的差，询问 $m$ 对点权值的差。

很明显，这变成了一个带权并查集模板。

## 具体实现

### 建边

我们可以把式子 $w=S_{r}-S_{l-1}$ 
转换为从 $l-1$ 到 $r$ 建一条权值为 $w$ 的边。

但是并查集尽可以在根之间建边，对于 $u/v$ 不是根节点的边（如图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/plc80xmo.png)

已知：

$S_{u}-S_{fu}=x$ （ $u$ 到根的距离）；

$S_{v}-S_{fv}=y$ （ $v$ 到根的距离）；

$S_{v}-S_{u}=w$ （ $u$ 到 $v$ 的距离）；

可以变为：

$S_{fv}-S_{fu}=w+x-y$ （ $u$ 到 $v$ 的距离）；

可以理解为：

从 $u$ -> $v$ 权值为 $w$ 的一条边。

变为了一条 $fu$ -> $fv$ 权值为 $w+x-y$ 的边。



### 处理询问

如果 $r$ 和 $l-1$ 不在一个连通块中，可以证明这两个值暂时无关联（即 $\text{UNKNOWN}$）。

算出:

$dr=S_{r}-S_{root}$ （ $r$ 到根的距离）;

$dl=S_{l-1}-S_{root}$ （ $l-1$ 到根的距离）;

所以

$$\sum_{j=L}^RA_{j}$$

$$=S_{r}-S_{l-1}$$

$$=S_{r}-S_{l-1}$$

$$=dr-dl$$

即答案为（ $r$ 到根的距离）-（ $l-1$ 到根的距离）。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,q;
const long long N=1e5+9;
long long fa[N],dis[N];
long long find(long long x){
	if(fa[x]==x)return x;
	long long fx=fa[x];
	fa[x]=find(fa[x]);
	dis[x]=dis[fx]+dis[x];
	return fa[x];
}
void merge(long long x,long long y,long long w){
	long long fx=find(x),fy=find(y);
	if(fx==fy)return;
	fa[fy]=fx;
	dis[fy]=w+dis[x]-dis[y];
	return;
}
long long query(long long x,long long y){
	long long fx=find(x),fy=find(y);
	if(fx!=fy)return 1e18;
	return dis[y]-dis[x];
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&q);
	for(long long i=1;i<=n;i++)fa[i]=i;
	for(long long i=1;i<=m;i++){
		long long l,r,s;
		scanf("%lld%lld%lld",&l,&r,&s);
		l--;
		merge(r,l,s);
	}
	for(long long i=1;i<=q;i++){
		long long l,r;
		scanf("%lld%lld",&l,&r);
		l--;
		long long ans=query(r,l);
		if(ans==1e18)printf("UNKNOWN\n");
		else printf("%lld\n",ans);
	}
}
```

---

## 作者：WhiteNight__ (赞：1)

# [P8779 [蓝桥杯 2022 省 A] 推导部分和](https://www.luogu.com.cn/problem/P8779)

## 题意

给出一个长度为 $N$ 的数组和 $M$ 段区间和，有 $Q$ 次询问，每一次询问区间 $[l,r]$ 的区间和，无法求出输出`UNKNOWN`。

## 基本思路

令前缀和数组 $s_{x}$ 表示 $\sum_{i=1}^{x}A_{i}$。如果 $[l_{i},r_{i}]$ 的和为 $S_{i}$，则 
$$
s_{r_{i}} = s_{l_{i}-1}+S_{i},s_{l_{i}-1}=s_{r_{i}}-S_{i}
$$

那么我们就可以每次连一条 $l_{i}-1 \to r_{i}$，权值为 $S_{i}$ 的边，再连一条 $r_{i} \to l_{i}-1$，权值为 $-S_{i}$ 的边。

每一次询问，就可以对 $l-1$ 的点进行 DFS，如果不可以求出 $r$ 就输出无解。

进一步优化，我们可以发现，如果无解，当且仅当 $l-1$ 和 $r$ 不连通，进行 DFS 时可以把所以和 $l-1$ 处于同一连通块的点打标记，同时用上方的公式对能到的边更新 $s$ 数组（前缀和数组可以预先全部设置为 $0$，因为在同一个连通块，所以下面求解时直接相减是正确的），如果 $l-1$ 已有标记则不进行继续 DFS。如果 $l-1$ 的标记与 $r$ 的标记不同或 $l-1$ 有标记而 $r$ 没有就输出无解。如果处在同一联通块，直接用 $s_{r} - s_{l-1}$ 即是答案。

具体细节见代码。

## 代码


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <bitset>
using namespace std;
#define ll long long

int n , m , q , l , r , cnt , lin[100050]; // lin为标记，连通块编号
ll g[100050]; // 前缀和数组，即s数组

struct Edge {
	int to;
	ll dis;
};

vector <Edge> v[100050];

void dfs (int u , int numj)
// numj为当前连通块编号，即标记
{
	lin[u] = numj; // 打上标记
	for(auto i : v[u])
	{
		if(lin[i.to] == 0) // 可以到达没有打标记的边
		{
			g[i.to] = g[u] + i.dis; // 更新前缀和数组
			dfs (i.to , numj);
		}
	}
	return;
}

int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1 ; i <= m ; i ++)
	{
		int li , ri;
		ll s;
		scanf("%d%d%lld",&li,&ri,&s);
		-- li; // li -1 
		v[li].push_back(Edge{ri,s});
		v[ri].push_back(Edge{li,-s});
	}
	
	while (q --)
	{
		scanf("%d%d",&l,&r);
		-- l; // l -1
		if(lin[l] == 0) { // 没有标记就dfs
			dfs (l , ++ cnt);
		}
		if(lin[l] == lin[r]) // 标记相同
		{
			printf("%lld\n",g[r]-g[l]);
		}
		else printf("UNKNOWN\n"); // 标记不同
	}
	
	return 0;
}
```

---

## 作者：cppcppcpp3 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P8779)。

## 思路

给出的条件不方便直接用 $a_i$ 表示。由于都是与区间和有关的信息，可以想到前缀和 $s_i=\sum\limits_{j=1}^i a_i$，则每一条信息都可以表示为 $s_r-s_{l-1}=w$。

思考怎么通过已知的区间和推出未知的信息。比如对于 $[a+1,b],[a+1,c],[c+1,b]$ 三个区间，我们可以通过其中两个推出剩余的一个。即 $s_c-s_a=w_1,s_b-s_c=w_2$，则可知 $s_b-s_a=w_1+w_2$。

这与图上的边权、点权类似，考虑建图来体现这种关系。对于 $s_r-s_{l-1}=w$，可以类似为点 $u$ 的点权为 $s_u$，现在连有向边 $(l-1,r)$ 和 $(r,l-1)$，边权分别为 $w$ 和 $-w$。

判断一个区间和 $[x,y]$ 是否已知，就只需看点 $x-1,y$ 是否连通。因此我们可以通过 DFS 维护连通的信息。

```cpp
void dfs(int u,int t){ //t 为连通块编号，同时是连通块开始搜索的点。
	if(~vis[u]) return; //vis[u] 为所属连通块编号，初始化为-1。同时可以表示 u  是否搜到过。
	vis[u]=t;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(vis[v]==-1) d[v]=d[u]+e[i].w,dfs(v,t); //d[i] 表示 s[i]-s[u]，那么 d[i]-d[j]=s[i]-s[j]。
	}
}
```

复杂度 $O(n)$。

另外本题保证数据不矛盾。如果要判断矛盾，就对每个先前搜过的 $v$ 判断 $d_v$ 和 $d_u+w$ 是否相等。

当然还有其它做法，如带权并查集等。

```cpp
#include<bits/stdc++.h>
#define il inline
#define int long long
using namespace std;
const int N=1e5+5;

il int wrd(){
	int x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
	while(isdigit(c)){x=x*10+c-48,c=getchar();}
	return x*f;
}

int n,m,q,cnt,head[N];
int vis[N],d[N];

struct edge{
	int to,w,nxt;
}e[N<<1];

il void add(int u,int v,int w){
	e[++cnt]=edge{v,w,head[u]},head[u]=cnt;
}

void dfs(int u,int t){
	if(~vis[u]) return;
	vis[u]=t;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(vis[v]==-1) d[v]=d[u]+e[i].w,dfs(v,t);
	}
}

main(){
	n=wrd(),m=wrd(),q=wrd();
	for(int i=1;i<=m;++i){
		int u=wrd(),v=wrd(),w=wrd();
		add(u-1,v,w),add(v,u-1,-w);
	}
	memset(vis,-1,sizeof(vis));
	for(int i=0;i<=n;++i) dfs(i,i);
	
	while(q--){
		int u=wrd()-1,v=wrd();
		if(vis[u]^vis[v]) puts("UNKNOWN");
		else printf("%lld\n",d[v]-d[u]);
	}
	return 0;
}
```

---

## 作者：BugGod (赞：1)

先给个链接：[此题弱化版](https://www.luogu.com.cn/problem/AT_abc238_e)。

首先我们设 $\sum^{n}_{i=1}a_i=s_n$，则题目中给出了一些 $s_r-s_{l-1}$，要求一些 $s_x-s_{y-1}$，显然我们未必要求出原数组，只要求 $s$ 即可。我们考虑对 $(l-1,r)$ 连双向边，如果 $x$ 与 $y$ 连通，那么显然 $x$ 到 $y$ 路径上所有点的 $s_u-s_{v}(v\in G_u)$ 之和就是 $s_y-s_x$ 的值（有点像差分的思想），那么如果两个点不连通，显然无解，否则可以 dfs 算出路径上所有点的 $s$（其实是相对于 $x$ 的），进一步求出答案。

CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,q,l,r,s,kuai[100010],cnt,sum[100010];
struct edge
{
    int to,cost;
};
vector<edge>G[100010];
void dfs(int x)
{
    for(int j=0;j<G[x].size();j++)
    {
        int y=G[x][j].to,z=G[x][j].cost;
        if(kuai[y]==0)//还没有被dfs到
        {
            kuai[y]=kuai[x];//是一个连通块的
            sum[y]=sum[x]+z;
            dfs(y);
        }
    }
}
signed main()
{
    cin>>n>>m>>q;
    for(int i=1;i<=m;i++)
    {
        cin>>l>>r>>s;
        l--;
        edge e1,e2;
        e1.to=r;
        e2.to=l;
        e1.cost=s;
        e2.cost=-s;//这里注意是反向连边，要变号
        G[r].push_back(e2);
        G[l].push_back(e1);
    }
    while(q--)
    {
        cin>>l>>r;
        l--;
        if(kuai[l]==0){kuai[l]=++cnt;dfs(l);}//新的块出现了
        if(kuai[l]==kuai[r])cout<<sum[r]-sum[l]<<endl;
        else cout<<"UNKNOWN"<<endl;
    }
    return 0;
}
```

---

## 作者：Crazyouth (赞：1)

**分析**

不难想到，使用带权并查集解决此题。首先并查集的实际意义是，若两个节点 $l,r$ 有同一个祖先，则区间 $[l,r]$ 的和必定能求出来。接着再定义 `val[l]` 的意义，`val[l]` 表示的就是 $\displaystyle\sum_{i=1}^la_i$，所以每次询问若 `find(l)==find(r)`，就输出 `val[r]-val[l]`。不过有一点值得注意，对于每次加边与询问操作，需要先使输入的 $l$ 减一，因为用前缀和求区间和需要使 `l--`。

接下来看加边操作，若本来 $l,r$ 已经有同一个祖先（这里默认 $l$ 已经减一），则不用加边；否则，把它们两个祖先合并到一起，然后处理 `val[find(r)]`（`find(l)` 也可以，这取决于合并后谁是谁的父亲）。

**AC Code**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
int fa[N],val[N];
int find(int x)
{
	if(fa[x]==x) return x;
	int r=find(fa[x]);
	val[x]+=val[fa[x]];
	fa[x]=r;
	return r;
}
signed main()
{
	int n,m,q;
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++) fa[i]=i,val[i]=0;
	while(m--)
	{
		int l,r,s;
		cin>>l>>r>>s;
		l--;
		int tl=find(l),tr=find(r);
		if(tl!=tr)
		{
			fa[tr]=tl;
			val[tr]=val[l]-val[r]+s;
		} 
	}
	while(q--)
	{
		int l,r;
		cin>>l>>r;
		l--;
		if(find(l)!=find(r)) cout<<"UNKNOWN"<<endl;
		else cout<<val[r]-val[l]<<endl;
	}
	return 0;
}

---

## 作者：wcy110614 (赞：0)

有趣的并查集题。

如果知道 $[l,r]$ 的和，那么只要知道了 $s_{l-1}$ 的值就可以推导得到 $s_r$ 的值。

而有知道 $s_0=0$。

这样的关系可以令我联想到图论：将 $a$ 连向 $b$ 就表示知道了 $s_a$ 的值就可以知道 $s_b$ 的值。

可以发现，如果 $s_x,s_y$ 存在一条路径，那么就一定可以在已知其中一个值的情况下求出另一个值。

不难想到可以利用并查集来维护。至于 $s_y-s_x$ 的值，用带权并查集记录 $val[x]$ 为 $x$ 到根路径的长度，然后用类似树上前缀和的方法统计就好了。

代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N=2e5+10;
int n,m,q,f[N],val[N];
int gf(int x){
	if(x==f[x])return x;
	int rt=gf(f[x]);
	val[x]+=val[f[x]];
	return f[x]=rt;
}
void link(int y,int x,int s){
	int u=gf(x),v=gf(y);
	val[u]=s+val[y]-val[x];
	f[u]=v;
}
signed main(){
	cin>>n>>m>>q;
	for(int i=1;i<=n;++i)f[i]=i;
	for(int i=1,l,r,s;i<=m;++i)cin>>l>>r>>s,link(l-1,r,s);
	for(int i=1,l,r;i<=q;++i){
		cin>>l>>r;
		if(gf(l-1)^gf(r))puts("UNKNOWN");
		else cout<<val[r]-val[l-1]<<"\n";
	}
	return 0;
}
```

---

## 作者：ZBH_123 (赞：0)

## 题目分析

看到区间和，立刻想到前缀和。设 $sum_{i}=\sum_{j=1}^i{a_j}$。我们可以想到这样的一种思路：对于题目给出的区间 $[l,r]$，连一条从 $l-1$ 到 $r$ 的边，代表由 $sum_{l-1}$ 可以推出 $sum_r$。这样问题就转换为了判断是否存在一条 $l-1$ 到 $r$ 的路径，使用并查集维护。不过，题目还要求区间和。所以，我们需要维护一个 $val$，表示当前结点到根结点的路径上的权值之和。当两个集合合并时，还需要更新 $val$。

## 代码实现

本题的并查集需要加优化。不加优化的时间复杂度为 $O(N^2)$，使用路径压缩或按秩合并的时间复杂度为 $O(N \log{N})$，同时使用路径压缩和启发式合并的时间复杂度为 $O(N)$。所以需要加并查集的优化。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;

const int maxn=1e5;
int n,m,q,father[maxn+5];
ll sum[maxn+5];

int find(int x){
	if(father[x]==x) return x;
	int root=find(father[x]);
	sum[x]+=sum[father[x]];
	return father[x]=root;
}

void _union(int x,int y,ll z){
	int fa=find(x),fb=find(y);
	if(fa==fb) return;
	father[fa]=fb,sum[fa]=sum[y]-sum[x]-z;
}

void solve(){
	cin>>n>>m>>q;
	
	for(int i=1;i<=n;i++) father[i]=i;
	for(int i=1;i<=m;i++){
		int x,y;
		ll z;
		cin>>x>>y>>z;
		_union(x-1,y,z);
	}
	
//	for(int i=1;i<=n;i++) cout<<"a "<<find(i)<<' '<<sum[i]<<'\n';
	
	while(q--){
		int x,y;
		cin>>x>>y;
		int fa=find(x-1),fb=find(y);
//		cerr<<sum[y]<<' '<<sum[x-1]<<'\n';
		if(fa!=fb) cout<<"UNKNOWN\n";
		else cout<<sum[y]-sum[x-1]<<'\n';
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--) solve();
	return 0;
}
```

---


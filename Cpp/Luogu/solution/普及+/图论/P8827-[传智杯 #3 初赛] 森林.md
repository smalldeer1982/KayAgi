# [传智杯 #3 初赛] 森林

## 题目背景

YYH Land（Yoauld, Youthful & Happy Land）是位于炽蓝仙野的一片神奇的国度，那里的人们过着无拘无束的的快乐生活。

## 题目描述

清蒸鱼是一个尽职尽责的 YYH Land 护林者。他负责每天维护 YYH Land 的森林。在最开始的时候，YYH Land 只有一棵具有 $n$ 个节点的树，每个节点有一个灵力值 $v$。

由于 YYH Land 是一片神奇的国度，YYH Land 的树也有一些神奇的能力，具体来说它满足如下操作：

- `1 e`  
编号为 $e$ 的边突然消失，使得它所在的那棵树变成了两棵树。

- `2 u val`  
编号为 $u$ 的节点的灵力值变成了 $val$。

- `3 u`  
清蒸鱼进行了一次查询，查询 $u$ 所在的那棵树的灵力值之和。

现在你需要帮助清蒸鱼，来模拟上述事件，以了解森林的变迁。

## 说明/提示

对于 $30\%$ 的数据，满足 $1 \leq n,m \leq 10$；  
对于 $50\%$ 的数据，满足 $1 \leq n,m \leq 1000$；  
对于另外 $20\%$ 的数据，满足只有 $2,3$ 操作；  
对于 $100\%$ 的数据，满足 $1 \leq n,m \leq {10}^5$，$1 \leq v,val \leq 1000$。

## 样例 #1

### 输入

```
2 3
1 1
1 2
2 2 4
1 1
3 2```

### 输出

```
4```

# 题解

## 作者：tjtdrxxz (赞：9)

先看题：

1. 操作一，删除编号为 $ e_i $ 的边。
2. 操作二，把编号为 $ u_i $ 的点的权值改成 $ v_i $。
3. 操作三，询问编号为 $ u_i $ 的点所在的子树的权值和。

很明显，如果没有操作一，这提示能用并查集吊打的。但是~~他是绿题~~，所以有操作一。

因为初始时是一棵树，所以在删除一些边后他就是森林了。好，那这题就能用 ~~LCT~~ 并查集切掉。

因为正着来的话删边会很麻烦，所以先离线，然后倒着来。这样删边就转化成了连接 $ u $ 和 $ v $，把 $ u $ 的点权改成 $ v $ 就变成了把 $ u $ 的点权改成上一次操作的 $ v $，询问子树和可以用并查集维护。因为是倒着来的，所以输出答案时可以用一个栈存储。

warning：合并时要注意，一般的并查集都是这样写的 `` fa[find (u)] = find (v); ``，所以合并子树和的时候是 `` sum[find (v)] += sum[find (u)]; ``。

注意一下下标之类的细节就好了，代码还是很容易实现的。

code：
```cpp
# include "bits/stdc++.h"
# define int long long
using namespace std;
namespace chtholly
{
	template <const int N>
	class UFDS
	{
		private :
			int s[N];
			int a[N];
			int fa[N];
		public :
			int find (int u)
			{
				return u == fa[u] ? u : fa[u] = find (fa[u]);
			}
			void merge (int u, int v)
			{
				u = find (u);
				v = find (v);
				if (u != v)
				{
					fa[u] = v;//这里是把子树 u 合并到 v 上，所以合并子树和的时候是如下写法。
					s[v] += s[u];
				}
			}//合并。
			void init ()
			{
				for (int i = 1; i < N; i ++) fa[i] = i;
			}//初始化。
			int sum (int u)
			{
				return s[find (u)];
			}//子树和。
			void change (int u, int x)
			{
				int f = find (u);
				s[f] += x - a[u];
				a[u] = x;
			}//单点修改，因为是把点 u 的值改成 x，所以把子树和加上 x 再减去 u 本身的值就好了。
	};//以上为并查集
}
using namespace chtholly;
# define stdi stdin
# define stdo stdout
UFDS <100012> tree;
int n, m, a[100012];
bool f[100012];
int u[100012], v[100012], last[100012];
int op[100012], x[100012], y[100012];
signed main ()
{
	cin >> n >> m;
	tree.init ();
	for (int i = 1; i <= n; i ++)
	{
		int num; cin >> num;
		a[i] = num;
	}
	for (int i = 1; i < n; i ++)
	{
		cin >> u[i] >> v[i];
		f[i] = 1;
	}
	for (int i = 1; i <= m; i ++)
	{
		cin >> op[i] >> x[i];
		if (op[i] == 1) f[x[i]] = 0;
		if (op[i] == 2)
		{
			cin >> y[i];
			tree.change (x[i], y[i]);
			last[i] = a[x[i]]; //记录上一次的操作后的值。
			a[x[i]] = y[i];
		}
	}
	for (int i = 1; i <= n; i ++) tree.change (i, a[i]);
	for (int i = 1; i < n; i ++)
	{
		if (f[i])
		{
			tree.merge (u[i], v[i]);
		}
	}
//	cout << "sum : ";
//	for (int i = 1; i <= n; i ++) cout << tree.sum (i) << ' ';
//	cout << endl;
	vector <int> q;
	for (int i = m; i >= 1; i --)
	{
		if (op[i] == 1) tree.merge (u[x[i]], v[x[i]]);
		if (op[i] == 2) tree.change (x[i], last[i]);
		if (op[i] == 3) q.push_back (tree.sum (x[i]));
	}
	while (not q.empty ()) cout << q.back () << endl, q.pop_back ();
}
```

---

## 作者：happybob (赞：4)

考虑操作有删边但没有恢复边的操作，很容易想到离线后逆序操作的套路。

逆序后操作即为只有加边没有删边了，并查集维护即可。

但是注意到题目要求点权和，所以带权并查集维护，修改权值也可以轻松做，即在父亲的点上减去本身的贡献加上新的贡献即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
using namespace std;

const int N = 1e5 + 5;

int ans[N], n, m;
int a[N];
bool v[N];

struct Query
{
	int op, u, val, id;
}q[N];

class Union_Find
{
public:
	int fa[N], val[N];
	void build()
	{
		for (int i = 0; i < N; i++) fa[i] = i, val[i] = a[i];
	}
	int find(int u)
	{
		return fa[u] == u ? u : fa[u] = find(fa[u]);
	}
	void merge(int u, int v)
	{
		int x = find(u), y = find(v);
		fa[x] = y;
		val[y] += val[x];
	}
}f;

pair<int, int> EDGE[N];
int idx, lst[N];

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i < n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		EDGE[i] = make_pair(u, v);
	}
	for (int i = 1; i <= m; i++)
	{
		int op;
		scanf("%d", &op);
		q[i].op = op;
		if (op == 1)
		{
			scanf("%d", &op);
			v[op] = 1;
			q[i].u = op;
		}
		else if (op == 2)
		{
			int x, y;
			scanf("%d%d", &x, &y);
			q[i].u = x;
			q[i].val = y;
			lst[i] = a[x];
			a[x] = y;
		}
		else
		{
			scanf("%d", &op);
			q[i].id = ++idx;
			q[i].u = op;
		}
	}
	f.build();
	for (int i = 1; i < n; i++)
	{
		if (!v[i])
		{
			f.merge(EDGE[i].first, EDGE[i].second);
		}
	}
	for (int i = m; i >= 1; i--)
	{
		int op = q[i].op;
		if (op == 1)
		{
			int u = q[i].u;
			f.merge(EDGE[u].first, EDGE[u].second);
		}
		else if (op == 2)
		{
			int u = q[i].u, v = q[i].val;
			int ff = f.find(u);
			f.val[ff] -= v;
			f.val[ff] += lst[i];
			//a[u] = v;
		}
		else
		{
			int u = q[i].u;
			ans[q[i].id] = f.val[f.find(u)];
		}
	}
	for (int i = 1; i <= idx; i++) printf("%d\n", ans[i]);
	return 0;
}
```


---

## 作者：TankYu (赞：2)

这题比较套路。

考虑到只有删边，没有加边，离线操作后使用并查集倒序维护。

又因为要查询点权和，使用带权并查集。

对于操作 $1$，离线所有操作后记录一下最终有哪些边没被删，在倒序遍历操作时改为加边操作。

对于操作 $2$，使用栈记录一个点的点权更改。设栈顶元素即该次修改成的值为 $x$，栈顶下的元素为 $y$，则这次修改造成 $y - x$ 的贡献。

对于操作 $3$，查询该点祖先的权即可。

以下是代码：

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <stack>
#define int long long
using namespace std;

int fa[100010];
int find(int x)
{
	if (x == fa[x])
		{
			return x;
		}
	fa[x] = find(fa[x]);
	return fa[x];
}
long long cnt[100010];
vector <int> change[100010];
pair <int, int> edge[100010];
bool have[100010];
struct que
{
	int op;
	int x;
	int y;
} q[100010];
stack<long long> ans;
stack<long long> last[100010];
int a[100010];

signed main()
{
	int n;
	int m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		{
			cin >> cnt[i];
			last[i].push(cnt[i]);
		}
	for (int i = 1; i < n; i++)
		{
			int a, b;
			cin >> a >> b;
			edge[i] = make_pair(a, b);
		}
	for (int i = 1; i <= n; i++)
		{
			fa[i] = i;
		}
	for (int i = 1; i <= m; i++)
		{
			cin >> q[i].op >> q[i].x;
			if (q[i].op == 2)
				{
					cin >> cnt[q[i].x];
					last[q[i].x].push(cnt[q[i].x]);
				}
			if (q[i].op == 1)
				{
					have[q[i].x] = true;
				}
		}
	for (int i = 1; i < n; i++)
		{
			if (!have[i])
				{
					int x = find(edge[i].first), y = find(edge[i].second);
					cnt[y] += cnt[x];
					fa[x] = y;
				}
		}
	for (int i = m; i >= 1; i--)
		{
			if (q[i].op == 1)
				{
					int x = find(edge[q[i].x].first), y = find(edge[q[i].x].second);
					cnt[y] += cnt[x];
					fa[x] = y;
				}
			else if (q[i].op == 2)
				{
					int tmp = last[q[i].x].top();
					last[q[i].x].pop();
					cnt[find(q[i].x)] += (last[q[i].x].top() - tmp);
				}
			else
				{
					int x = find(q[i].x);
					ans.push(cnt[x]);
				}
		}
	while (!ans.empty())
		{
			cout << ans.top() << '\n';
			ans.pop();
		}
	return 0;
}
```

---

## 作者：tjtdrxxz (赞：1)

好像大部分题解都是并查集，所以我们来个线段树分治。

断边操作非常简单，最基础的线段树分治加上可撤销并查集就可以了，这里不再赘述。

对于修改值，我们发现该点被修改后，会影响到他所有的父亲节点，又由于可撤销并查集树高最大是 $ \log { n } $ 的，所以我们只用每次向上递归到根节点去修改。

那既然是无根树，跟不确定，为什么不用修改子节点呢？因为对于它的子节点，接下来只有两种情况：
1. 查询：此时它的子节点的值并不会影响答案，因为查的是根节点，而根节点已经被更新过了。
2. 修改（断边）：这个操作更不会影响了，毕竟都断开了，所以依旧不用管子结点。

同时，因为时间复杂度和树的高度有关，所以并查集需要按树高合并。

时间复杂度的话，线段树的遍历有一个 $ \log { n } $，并查集按高合并以及修改点权还有一个 $ \log { n } $，总的时间复杂度是 $ O ( n \log ^ 2 { n } ) $。

---

## 作者：Hope888 (赞：1)

# 思路

删边操作是没有加边操作好做的，所以此题可以离线后逆序操作，将删边变为加边。

此题还要求了维护点权和，使用带权并查集

对于操作 $1$，记录所有操作结束后有哪些边没被删，在倒序遍历操作时进行加边操作。

对于操作 $2$，将父亲的点权**加上**新增加的权值。

对于操作 $3$，查询该点的祖先权值，通过输入的顺序记录。

# 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
const int N=1e5+5;
int ans[N],n,m,a[N];
bool vis[N];
struct node
{
	int op,x,y,id;
}q[N];
int fa[N],val[N],lst[N],idx;
int find(int x)
{	
	if(fa[x]==x)return x;	
	return fa[x]=find(fa[x]);
}
void merge(int x,int y)
{
	int u=find(x),v=find(y);
	fa[u]=v;
	val[v]+=val[u];
};
pair<int,int>e[N];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		e[i]=make_pair(u,v);
	}
	for(int i=1;i<=m;i++)
	{
		int op;
		cin>>op;
		q[i].op=op;
		if(op==1)
		{
			int e;
			cin>>e;
			vis[e]=1;
			q[i].x=e;
		}
		else if(op==2)
		{
			int v,val;
			cin>>v>>val;
			q[i].x=v;
			q[i].y=val;
			lst[i]=a[v];
			a[v]=val;
		}
		else
		{
			int u;
			cin>>u;
			q[i].id=++idx;
			q[i].x=u;
		}
	}
	for(int i=0;i<N;i++)
	{
		fa[i]=i;
		val[i]=a[i];
	}
	for(int i=1;i<n;i++)if(!vis[i])merge(e[i].first,e[i].second);
	for (int i=m;i>=1;i--)
	{
		int op=q[i].op;
		if(op==1)
		{
			int x=q[i].x;
			merge(e[x].first,e[x].second);
		}
		else if(op==2)
		{
			int x=q[i].x,y=q[i].y;
			int fa=find(x);
			val[fa]+=(lst[i]-y);
		}
		else
		{
			int x=q[i].x;
			ans[q[i].id]=val[find(x)];
		}
	}
	for(int i=1;i<=idx;i++)cout<<ans[i]<<endl;
}
```

---

## 作者：0xFF (赞：1)

#### 题目大意


------------
给定一个有 $n$ 个节点的树，点有点权，维护三个操作：

+ $\tt{1~e}$：删除编号为 $e$ 的边。
+ $\tt{2~u~val}$：将 $u$ 号节点的权值改为 $val$。
+ $\tt{3~u}$：查询 $u$ 所在连通块的权值和。

#### 思路分析


------------
正向维护显然无法简单的维护删边操作，故考虑将询问反向，将删边操作改为加边操作，对于 $2$ 操作在读入数据时记录 $u$ 节点之前的值和更改后的值，在维护 $3$ 查询连通块权值和时直接更新权值和减去更新后的值再加上先前的值（反向处理询问）。

在读入时记录下哪些边是自始至终都没有被删除的，直接加入，此时的树就是进行完所有操作后的树，也就是反向操作开始时的树。按照上述过程在树上进行操作即可。维护一个带权并查集，将一个连通块的权值记录到这个连通块的父亲节点上，合并时将儿子的权值加到父亲的权值上即可。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<deque>
#include<queue>
#include<map>
#include<vector>
#define int long long//
using namespace std;
const int INF = 2e15;
const int mod = 1e9 + 7;
const int N = 1e5 + 10;

inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
int fa[N],sum[N];
int find(int x){
	if(fa[x] == x) return x;
	else return fa[x] = find(fa[x]);
}
void merge(int x,int y){
	int fx = find(x) , fy = find(y);
	if(fx != fy){
		fa[fx] = fy;
		sum[fy] += sum[fx];
	}
}
struct Edge{
	int from,to;
}ed[N<<1];
struct Node{
	int type,pos,val;
}q[N];
int lst[N],a[N],ans[N],cnt;
bool vis[N];
signed main(){
	memset(vis,false,sizeof(vis));
	int n = read() , m = read();
	for(int i=1;i<=n;i++) a[i] = read();
	for(int i=1;i<=n-1;i++){
		ed[i].from = read() , ed[i].to = read();
	}
	for(int i=1;i<=m;i++){
		q[i].type = read() , q[i].pos = read();
		if(q[i].type == 1){
			vis[q[i].pos] = true;
		}
		if(q[i].type == 2){
			q[i].val = read();
			lst[i] = a[q[i].pos];
			a[q[i].pos] = q[i].val;
		}
	}
	for(int i=1;i<=n;i++) fa[i] = i , sum[i] = a[i];
	for(int i=1;i<=n-1;i++){
		if(!vis[i]) merge(ed[i].from,ed[i].to);
	}
	for(int i=m;i>=1;i--){
		int fx = find(q[i].pos);
		if(q[i].type == 1){
			merge(ed[q[i].pos].from,ed[q[i].pos].to);
		}
		else if(q[i].type == 2){
			fx = find(q[i].pos);
			sum[fx] = sum[fx] - q[i].val + lst[i];
		}
		else{
			ans[++cnt] = sum[fx];
		}
	}
	for(int i=cnt;i>=1;i--){
		cout<<ans[i]<<"\n";
	}
	return 0;
}
```


---

## 作者：青鸟_Blue_Bird (赞：1)

本题解提供两种做法。

## 做法一

为了叙述方便，先引入 $n$ 级母树的概念。
定义 $1$ 级母树即为该子树被删去前，其所在的原来的完整的树。

![666](https://cdn.luogu.com.cn/upload/image_hosting/0r4ejkpy.png)

如下图，以 $5$ 为根的一级母树为以 $3$ 为根的**原来**的子树。类似地，以 $1$ 为根的**原来**的树即为以 $3$ 为根的树的 $1$ 级母树以及以 $5$ 为根的 $2$ 级母树。

可以发现，题目中有这样一个条件：$v \le 1000$。也就是说，这棵树的初始情况是一个类菊花图。菊花图有一个很重要的性质，就是其深度非常浅。在题目中所给的条件下，假如我们从某一点按照其父亲一路跳至根节点，最多只能跳 $1000$ 次。

利用这一性质，我们考虑维护每一个点的子树和 $siz_u$。那么，每一棵树的权值和即为其当前根节点的权值和。

考虑操作 $1$, 我们直接模拟删去子树和。从现在被删树根节点 $v$ 的父亲至其 $1$ 级母树的根节点的路径上的所有点的子树和显然都要减掉 $siz_v$。一路上跳即可。

对于操作 $2$, 我们计算出前后的改变量，从当前点到子树根节点上的 $siz_i$ 显然都要加上改变量。一路上跳即可。

对于操作 $3$, 按照上文所说，上跳到当前树的根节点查询即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100010
#define ll long long
const int INF = 1e9; 

template <class T>
inline void read(T& a){
	T x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){ if(c == '-') s = -1; c = getchar(); }
	while(isdigit(c)){ x = x * 10 + (c ^ '0'); c = getchar(); }
	a = x * s;
	return ;
}

struct node{
  int u, v, next;
} t[N << 1]; 
int head[N];

int bian = 0;
inline void addedge(int u, int v){
  t[++bian] = (node){u, v, head[u]}, head[u] = bian;
  return ; 
}

int n, m; 
int a[N]; 

struct hehe{
  int u, v; 
} h[N]; 

int deth[N], siz[N], fa[N]; 

void dfs1(int u, int father){
  fa[u] = father; 
  siz[u] = a[u]; 
  deth[u] = deth[father] + 1; 
  for(int i = head[u]; i; i = t[i].next){
    int v = t[i].v; 
    if(v != father){
      dfs1(v, u); 
      siz[u] += siz[v]; 
    }
  }
  return ; 
}

map <int, int> del[N]; // 记录删边情况

signed main(){
  // freopen("hh.txt", "r", stdin); 
  read(n), read(m);
  for(int i = 1; i <= n; i++) read(a[i]); 
  for(int i = 1; i < n; i++){
    int x, y;
    read(x), read(y);
    addedge(x, y); 
    addedge(y, x); 
    h[i].u = x, h[i].v = y; 
  }

  dfs1(1, 0);
  del[1][0] = del[0][1] = 1; 

  while(m--){
    int opt, e, x, y; 
    read(opt); 
    if(opt == 1){
      read(e); 
      int u = h[e].u; 
      int v = h[e].v; 
      if(deth[u] > deth[v]) swap(u, v); 
      del[u][v] = del[v][u] = 1; 
      while(!del[u][fa[u]]){
        siz[u] -= siz[v]; 
        u = fa[u]; 
      }
      siz[u] -= siz[v]; 
    }
    else if(opt == 2){
      read(x), read(y); 
      int d = y - a[x]; 
      a[x] = y;
      while(!del[x][fa[x]]){
        siz[x] += d; 
        x = fa[x]; 
      }
      siz[x] += d; 
       
    }
    else{
      read(x);
      while(!del[x][fa[x]]) x = fa[x]; 
      cout << siz[x] << endl; 
    }
  }

  return 0;
}
```

## 方法二

考虑在原方法上进行升级。

思考：如果没有 $v \le 1000$ 这个性质，我们暴力上跳的时间复杂度就会退化为 $O(QN)$。这显然是不行的。

可以发现，原方法的操作都是区间操作，于是考虑用树链剖分加线段树解决。

对于找当前点所在树的根，考虑如下性质：

- 根一定是当前点的父亲或者他自己。
- 在一条链上，各个点的 $dfn$ 序是连续的，且深度浅的点一定小于深度大的点。

利用上面两个性质，可以发现，我们将删边操作下放到点，标记深度较深的那个点。查询时，断点一定与当前上跳的点在同一条链上，因此查询下标最大的那个即可。（即用线段树记录最大值。）

除了上面这个操作，剩下的上跳操作直接以树链剖分的区间修改替代即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100010
#define ll long long
const int INF = 1e9; 

template <class T>
inline void read(T& a){
	T x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){ if(c == '-') s = -1; c = getchar(); }
	while(isdigit(c)){ x = x * 10 + (c ^ '0'); c = getchar(); }
	a = x * s;
	return ;
}

struct node{
  int u, v, next;
} t[N << 1]; 
int head[N];

int bian = 0;
inline void addedge(int u, int v){
  t[++bian] = (node){u, v, head[u]}, head[u] = bian;
  return ; 
}

int n, m; 
int a[N]; 

struct hehe{
  int u, v; 
} h[N]; 

int dfn[N], id = 0, rev[N];
int son[N], deth[N], top[N], siz[N], fa[N]; 
int w[N]; 

void dfs1(int u, int father){
  fa[u] = father; 
  siz[u] = 1;
  w[u] = a[u];  
  deth[u] = deth[father] + 1; 
  int maxn = -INF; 
  for(int i = head[u]; i; i = t[i].next){
    int v = t[i].v; 
    if(v != father){
      dfs1(v, u); 
      siz[u] += siz[v]; 
      w[u] += w[v]; 
      if(siz[v] > maxn){
        son[u] = v; 
        maxn = siz[v]; 
      }
    }
  }
  return ; 
}

void dfs2(int u, int tp){
  top[u] = tp; 
  dfn[u] = ++id; rev[id] = u; 
  if(!son[u]) return ; 
  dfs2(son[u], tp); 
  for(int i = head[u]; i; i = t[i].next){
    int v = t[i].v; 
    if(v != fa[u] && v != son[u])
      dfs2(v, v); 
  }
  return ; 
}

struct Segment_tree{
  struct node{
    int w; 
    bool del;  // 这个点上面的那条边是否被删除
    int id;  // 被删除的最靠右的那个点
    int add; 
  } t[N << 2]; 

  #define lson (o<<1)
  #define rson (o<<1|1)

  inline void pushup(int o){
    t[o].w = t[lson].w + t[rson].w;
    t[o].del = t[lson].del | t[rson].del; 
    t[o].id = max(t[lson].id, t[rson].id); 
    return ; 
  }

  inline void pushdown(int o, int l, int r){
    int mid = l + r >> 1;
    t[lson].add += t[o].add;
    t[rson].add += t[o].add; 

    t[lson].w += t[o].add * (mid - l + 1); 
    t[rson].w += t[o].add * (r - mid);

    t[o].add = 0; 
    return ; 
  }

  void build(int o, int l, int r){
    t[o].del = 0; 
    t[o].id = -1; 
    if(l == r){
      t[o].w = w[rev[l]]; 
      return ; 
    }
    int mid = l + r >> 1;
    build(lson, l, mid);
    build(rson, mid + 1, r);
    pushup(o);
    return ; 
  }

  int query_sum(int o, int l, int r, int in, int end){
    if(l > end || r < in) return 0; 
    if(l >= in && r <= end) return t[o].w; 
    int mid = l + r >> 1;
    pushdown(o, l, r); 
    return query_sum(lson, l, mid, in, end) + query_sum(rson, mid + 1, r, in, end); 
  }

  void update2(int o, int l, int r, int x){  // 表示要把某个点上面的边删去
    if(l > x || r < x) return ; 
    if(l == r && l == x){
      t[o].del = 1; 
      t[o].id = l; 
      return ; 
    }
    int mid = l + r >> 1;
    pushdown(o, l, r); 
    update2(lson, l, mid, x); 
    update2(rson, mid + 1, r, x); 
    pushup(o);
    return ; 
  }

  int query_id(int o, int l, int r, int in, int end){  // 最靠右的被删除的点的 id
    if(l > end || r < in) return -INF;
    if(l >= in && r <= end) return t[o].id; 
    int mid = l + r >> 1;
    pushdown(o, l, r); 
    return max(query_id(lson, l, mid, in, end), query_id(rson, mid + 1, r, in, end)); 
  }

  void update3(int o, int l, int r, int in, int end, int k){  // 区间加法
    if(l > end || r < in) return ; 
    if(l >= in && r <= end){
      t[o].add += k; 
      t[o].w += (r - l + 1) * k; 
      return ; 
    }
    pushdown(o, l, r); 
    int mid = l + r >> 1; 
    update3(lson, l, mid, in, end, k); update3(rson, mid + 1, r, in, end, k);
    pushup(o);
    return ; 
  }

} tree; 

int get_id(int x){   // 找断点，返回原始编号
  while(top[x]){
    int num = tree.query_id(1, 1, n, dfn[top[x]], dfn[x]); 
    if(num > 0) return rev[num]; 
    x = fa[top[x]]; 
  }
  int num = tree.query_id(1, 1, n, dfn[top[x]], dfn[x]); 
  if(num > 0) return rev[num]; 
  return 1; 
}

void change(int x, int y, int k){  // x, y 路径上的全部加 k
  while(top[x] != top[y]){
    if(deth[x] < deth[y]) swap(x, y); 
    tree.update3(1, 1, n, dfn[top[x]], dfn[x], k); 
    x = fa[top[x]]; 
  }
  if(deth[x] > deth[y]) swap(x, y); 
  tree.update3(1, 1, n, dfn[x], dfn[y], k); 
  return ; 
}


signed main(){
  // freopen("hh.txt", "r", stdin); 
  read(n), read(m);
  for(int i = 1; i <= n; i++) read(a[i]); 
  for(int i = 1; i < n; i++){
    int x, y;
    read(x), read(y);
    addedge(x, y); 
    addedge(y, x); 
    h[i].u = x, h[i].v = y; 
  }

  dfs1(1, 0);
  dfs2(1, 0); 
  tree.build(1, 1, n); 

  while(m--){
    int opt, e, x, y; 
    read(opt); 
    if(opt == 1){
      read(e); 
      int u = h[e].u; 
      int v = h[e].v; 
      if(deth[u] > deth[v]) swap(u, v); 
      tree.update2(1, 1, n, dfn[v]); 
      int id = get_id(u);
      int d = tree.query_sum(1, 1, n, dfn[v], dfn[v]); 
      change(id, u, -d);  // 路径上的全部减掉 w[v] 值
    }
    else if(opt == 2){
      read(x), read(y); 
      int d = y - a[x]; 
      a[x] = y;
      int id = get_id(x); 
      change(id, x, d);   // 区间加上差值
    }
    else{
      read(x);
      int id = get_id(x); 
      cout << tree.query_sum(1, 1, n, dfn[id], dfn[id]) << endl; 
    }
  }

  return 0;
}
```



---

## 作者：SSqwq_ (赞：0)

此题解提供一种非大众思路的方法。

## 分析

一个 trival 的套路是倒着操作，将删边变成加边。

考虑直接用并查集倒着做，但是发现修改有后效性。

于是使用动态数组直接维护每个点的每一次操作的历史权值即可。

- 对于每一个操作一，加边，并查集合并。

- 对于每一个操作二，对应节点回溯一个历史版本，并直接操作其并查集祖先节点的权值。

- 对于每一个操作三，直接输出其并查集祖先节点的权值。

时间复杂度 $O((n+m)\alpha(n))$，可以通过此题。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[100001],cnt,ans[100001];
struct Edge{
	int u,v;
}t[100001];
struct Op{
	int opt,u,val;
}b[100001];
int cut[100001],siz[100001],p[100001],fa[100001];
vector<int> vc[100001];
int find(int x){
	if(fa[x]==x)return x;
	fa[x]=find(fa[x]);
	siz[x]=siz[fa[x]];
	return fa[x];
}
void merge(int x,int y){
	x=find(x),y=find(y);
	if(x==y)return;
	if(siz[x]<siz[y])swap(x,y);
	siz[x]+=siz[y];
	fa[y]=x;
	siz[y]=0;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		fa[i]=i;
		vc[i].push_back(a[i]);
		p[i]++;
	}
	for(int i=1;i<=n-1;++i){
		cin>>t[i].u>>t[i].v;
	}
	for(int i=1;i<=m;++i){
		cin>>b[i].opt>>b[i].u;
		if(b[i].opt==2){
			cin>>b[i].val;
			vc[b[i].u].push_back(b[i].val);
			p[b[i].u]++;
		}
		if(b[i].opt==1)cut[b[i].u]=1;
	}
	for(int i=1;i<=n;++i){
		siz[i]=vc[i][p[i]-1];
	}
	for(int i=n-1;i>=1;--i){
		if(!cut[i])merge(t[i].u,t[i].v);
	}
	for(int i=m;i>=1;--i){
		if(b[i].opt==1){
			merge(t[b[i].u].u,t[b[i].u].v);
		}
		if(b[i].opt==2){
			siz[find(b[i].u)]+=(vc[b[i].u][p[b[i].u]-2]-vc[b[i].u][p[b[i].u]-1]);
			p[b[i].u]--;
		}
		if(b[i].opt==3){
			ans[++cnt]=siz[find(b[i].u)];
		}
	}
	for(int i=cnt;i>=1;--i){
		cout<<ans[i]<<"\n";
	}
	return 0;
}
```


---

## 作者：XBaiC (赞：0)

### 题目思路：

看到加边、减边的操作，向并查集上靠拢就可以了。

由于这题只限于删边，并且伴随着权值改变。

显然，删边操作是不好维护灵力值的。

但是，加边操作对于每一块的灵力值的改变，是非常好维护的。

假设只有加边操作，那么对于一个点 $x$ 的灵力值发生变化，那么就有点 $x$ 的的根（并查集寻根）增加 $newval - lastval$ 就可以了。

所以考虑把操作离线储存后，倒序处理（减边换为加边）。

对于权值的变化也对应取反就好了。

注意倒叙处理前，应该要保存操作完之后图的权值及分块情况，之后在此图上进行操作，而不是直接 $n$ 个点上进行操作。

### CODE：

```cpp
#include <bits/stdc++.h>
#define debug(x) cout<<#x<<":"<<x<<endl;
#define d(x) printf("%lld\n",x);
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
const ll INF= 1e17;
const ll maxn = 4e5+700;
const int mod= 1e9+7;
const int up = 1e9;
template<typename T>inline void read(T &a){char c=getchar();T x=0,f=1;while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}a=f*x;}
ll n,m,p;
int pre[maxn];
ll num[maxn],val[maxn];
pair<int,int>e[maxn];
vector<int>v[maxn];
int vis[maxn];
int Find(int x){
    return pre[x]==x?x:pre[x] = Find(pre[x]);
}
struct node{
    int op,x,y;
}q[maxn];
ll res[maxn];
int main(){
    read(n);read(m);
    for(int i=1;i<=n;i++){
        read(num[i]);
        val[i] = num[i];
        pre[i] = i;
        v[i].push_back(num[i]);
    }
    for(int i=1;i<=n-1;i++){
        int x,y;read(x);read(y);
        e[i] = {x,y};
    }
    for(int i=1;i<=m;i++){
        read(q[i].op);
        if(q[i].op == 1){
            read(q[i].x);
            vis[q[i].x] = 1;
        }
        else if(q[i].op == 2){
            read(q[i].x);
            read(q[i].y);
            v[q[i].x].push_back(q[i].y);
        }else read(q[i].x);
    }
    for(int i=1;i<=n;i++)
        if(v[i].size())
            val[i] = num[i] = v[i].back();
    for(int i=1;i<=n-1;i++){
        if(vis[i]) continue;
        int dx = Find(e[i].first),dy = Find(e[i].second);
        if(dx != dy){
            pre[dx] = dy;
            val[dy] += val[dx];
        }
    }
    for(int i=m;i>=1;i--){
        if(q[i].op == 1){
            int dx = Find(e[q[i].x].first),dy = Find(e[q[i].x].second);
            if(dx != dy){
                pre[dx] = dy;
                val[dy] += val[dx];
            }
        }else if(q[i].op == 2){
            v[q[i].x].pop_back();
            int dx = Find(q[i].x);
            val[dx] += v[q[i].x].back() - num[q[i].x];
            num[q[i].x] = v[q[i].x].back();
        }
        else res[i] = val[Find(q[i].x)];
    }
    for(int i=1;i<=m;i++){
        if(res[i])
            printf("%lld\n",res[i]);
    }
    return 0;
}
```


---

## 作者：快斗游鹿 (赞：0)

因为只有删边操作，而删边不好维护，所以容易想到可以将数据离线下来，删边变为加边，就可以很容易地用并查集维护了。因为有点权，所以使用带权并查集。

用 $dis_i$ 表示点 $i$ 所在树的权值和，$fa_i$ 表示点 $i$ 的祖先。

合并操作：

```
void merge(int x,int y){
	int X=find(x),Y=find(y);//找祖先
	if(X!=Y){
		fa[X]=Y;dis[Y]+=dis[X];
	}
}
```

对于操作 $1$，可以直接合并两个点。

对于操作 $2$，该点所在树权值和需要加上这次操作前该点的权值，并减去当前该点的权值。

对于操作 $3$，直接记录答案即可。

完整代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
struct data{
	int u,v;
}e[N];
struct D{
	int op,u,val;
}d[N];
int n,m,val[N],dis[N],ans[N],cnt,fa[N],lst[N],now[N];
bool flag_edge[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
void merge(int x,int y){
	int X=find(x),Y=find(y);
	if(X!=Y){
		fa[X]=Y;dis[Y]+=dis[X];
	}
}
signed main(){
	n=read();m=read();
	for(int i=1;i<=n;i++)val[i]=read(),dis[i]=val[i],fa[i]=i;
	for(int i=1;i<n;i++){
		e[i].u=read();e[i].v=read();
	}
	for(int i=1;i<=m;i++){//离线
		d[i].op=read();
		d[i].u=read();
		if(d[i].op==1)flag_edge[d[i].u]=1;
		if(d[i].op==2){
			d[i].val=read();lst[i]=dis[d[i].u];now[i]=d[i].val;dis[d[i].u]=d[i].val;
		}
	}
	for(int i=1;i<n;i++){//初始加边
		if(!flag_edge[i]){
			merge(e[i].u,e[i].v);
		}
	}
	for(int i=m;i>=1;i--){//倒着处理
		if(d[i].op==1){
			merge(e[d[i].u].u,e[d[i].u].v);
		}
		else if(d[i].op==2){
			int X=find(d[i].u);
			dis[X]+=lst[i]-now[i];
		}
		else{
			int X=find(d[i].u);
			ans[++cnt]=dis[X];
		}
	}
	for(int i=cnt;i>=1;i--)printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：Fislett (赞：0)

# 题意
有一颗树，每个点有一个点权 $v$。现在要对这棵树进行 $m$ 次以下三种操作之一：

- 删除一条边。

- 修改一个点的点权。

- 查询一个点 $u$ 所在的树的点权之和。

# 解题思路
这道题并没有要求在线，容易想到离线倒序操作的想法。

我们先把所有操作进行完之后的情景模拟出来，由于是倒序操作，只有加边没有删边，所以我们用并查集维护。接下来，对于三种操作，我们进行如下操作：

- 对于第一种操作，我们将点的两个端点所在的树合并。

- 对于第二种操作，我们将这棵树的点权之和加上原来的点权再减去现在的点权。

- 对于第三种操作，我们直接将这个点所在的树的点权之和压入答案数组即可。

# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node
{
	int opt, e, val, u;
} q[100001];
struct _
{
	int x, y;
} e[100001];
int n, m, sum[100001], fa[100001], ans[100001], tot;
stack<int> change[100001];
bool del[100001];
int find(int x)
{
	if (x == fa[x]) return x;
	return fa[x] = find(fa[x]);
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i ++) scanf("%d", &sum[i]), change[i].push(sum[i]), fa[i] = i;
	for (int i = 1; i < n; i ++) scanf("%d%d", &e[i].x, &e[i].y);
	for (int i = m; i >= 1; i --)
	{
		scanf("%d", &q[i].opt);
		if (q[i].opt == 1)
		{
			scanf("%d", &q[i].e);
			del[q[i].e] = true;
		}
		else if (q[i].opt == 2) 
		{
			scanf("%d%d", &q[i].u, &q[i].val);
			sum[q[i].u] = q[i].val;
			change[q[i].u].push(q[i].val);
		}
		else scanf("%d", &q[i].u);
	}
	for (int i = 1; i < n; i ++)
		if (!del[i])
		{
			int fx = find(e[i].x), fy = find(e[i].y);
			fa[fy] = fx;
			sum[fx] += sum[fy];
		}
	for (int i = 1; i <= m; i ++)
	{
		if (q[i].opt == 1)
		{
			int fx = find(e[q[i].e].x), fy = find(e[q[i].e].y);
			fa[fy] = fx;
			sum[fx] += sum[fy];
		}
		else if (q[i].opt == 2)
		{
			int fx = find(q[i].u), tmp = change[q[i].u].top();
			change[q[i].u].pop();
			sum[fx] += change[q[i].u].top() - tmp;
		}
		else
		{
			int fx = find(q[i].u);
			ans[++ tot] = sum[fx];
		}
	}
	for (int i = tot; i >= 1; i --) printf("%d\n", ans[i]);
	return 0;
}
```


---


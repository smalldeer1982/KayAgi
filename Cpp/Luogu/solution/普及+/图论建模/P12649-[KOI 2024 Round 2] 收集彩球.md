# [KOI 2024 Round 2] 收集彩球

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

现在有 $2N$ 个彩球和 $N + 1$ 个盒子。彩球的颜色为 $1, 2, \dots, N$ 中的某一个。对于每种颜色，恰好有两个彩球被涂成该颜色。每个盒子最多可以容纳两个彩球。

最开始，第 $1$ 到第 $N$ 个盒子中每个盒子内都放有两个彩球，第 $N + 1$ 个盒子是空的。第 $i$ 个盒子中，最上面那个彩球的颜色为 $A_i$，下面那个彩球的颜色为 $B_i$。

你可以将一个盒子顶部的彩球取出，放入另一个盒子的顶部，完成一次移动操作。

你的目标是使得每种颜色的两个彩球都被放入同一个盒子中。每次移动操作必须满足下列两个条件之一：

- 被放入彩球的目标盒子是空的；
- 被放入彩球的目标盒子中恰好已有一个彩球，并且该彩球与被放入的彩球颜色相同。

请你编写程序，计算为了实现目标——使每种颜色的两个彩球在同一个盒子中，所需的最小移动次数。如果无法实现目标，请输出 $-1$。

## 说明/提示

**样例 1 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/jm5qt4kg.png)

可以按照如下步骤完成：
1. 将第 4 号盒子中的颜色为 $3$ 的球移动到第 6 号盒子；
2. 将第 3 号盒子中的颜色为 $2$ 的球移动到第 4 号盒子；
3. 将第 1 号盒子中的颜色为 $4$ 的球移动到第 3 号盒子；
4. 将第 2 号盒子中的颜色为 $3$ 的球移动到第 6 号盒子；
5. 将第 5 号盒子中的颜色为 $5$ 的球移动到第 2 号盒子；
6. 将第 5 号盒子中的颜色为 $1$ 的球移动到第 1 号盒子。

**约束条件**

- 所有输入均为整数。
- $1 \leq N \leq 200\,000$
- $1 \leq A_i, B_i \leq N$
- 对于每个 $1 \leq i \leq N$，$A_1, A_2, \dots, A_N, B_1, B_2, \dots, B_N$ 中恰好有两个数等于 $i$。

**子问题**

1. （2 分）$N \leq 2$  
2. （23 分）$N \leq 20$  
3. （15 分）存在使所有同色彩球放入同一盒子的方法  
4. （15 分）$N \leq 2\,000$  
5. （45 分）无附加限制条件

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
5
4 1
3 5
2 4
3 2
5 1```

### 输出

```
6```

## 样例 #2

### 输入

```
2
1 1
2 2```

### 输出

```
0```

## 样例 #3

### 输入

```
4
2 1
3 1
2 4
3 4```

### 输出

```
-1```

# 题解

## 作者：Cwkapn (赞：2)

## 题目分析
首先注意到，可以将颜色看成结点，盒子中上方球的颜色和下方球的颜色之间连边，这样就可以将盒子中的球上下关系转化为一张图。图中有若干连通块，每个块内的颜色球移动不影响块外的球答案（因为块内的颜色和块外不需要也不能进行移动）。所以考虑分别处理每个连通块。下文中，符合要求是指每种颜色的两个球都在同一个盒子中。

可以发现，想要让块内颜色球位置符合要求，需要先将某两种颜色球移动到空盒（$2$ 步），再将其它颜色球依次配对（每种颜色需要 $1$ 步），最后空出一个盒子。因此，若一个连通块内有 $x$ 种颜色且可以符合要求，让它们符合要求需要：
- $0$ 步，如果 $x=1$（本来就是符合要求的）；
- $x + 1$ 步，如果 $x>1$。

现在考虑验证某个块通过移动符合要求可行性的方法。注意到只有 $1$ 个空盒，所以同一时间最多转移出 $2$ 个球。因此，考虑设第 $i$ 种颜色球在上方的盒子数 $u_i$。根据题意，$u_i$ 的取值为 $0,1$ 和 $2$。如果一个连通块内存在 $2$ 种颜色的 $u_i=2$，则只用一个空盒无法完成移动。可以基于这个特性对连通块进行验证。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, a[N][5];
int fa[N];
int getfa(int x) {return (x == fa[x]) ? x : (fa[x] = getfa(fa[x]));}
void merge(int x, int y) {
	x = getfa(x), y = getfa(y);
	if (x != y) fa[x] = y;	
}
int cnt[N];
vector<int> g[N];
int up[N], pos[N][5];
bool nok(int x) { // 判断连通块是否不符合要求
	int flag = 0;
	for (int i = 0; i < g[x].size(); i++) {
		if (up[g[x][i]] == 2) {
			if (flag) return true;
			flag = g[x][i];
		}
	}
	return false;
}
int main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) fa[i] = i;
	for (int i = 1; i <= n; i++) {
		cin >> a[i][1] >> a[i][2];
		merge(a[i][1], a[i][2]);
		up[a[i][1]]++;
		pos[a[i][1]][1 + (pos[a[i][1]][1] != 0)] = i;
	}
	for (int i = 1; i <= n; i++) {
		int tmp = getfa(i);
		cnt[tmp]++;
		g[tmp].push_back(i);
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		if (cnt[i] == 0 || cnt[i] == 1) continue;
		if (nok(i)) {
			cout << -1 << '\n';
			return 0;
		}
		ans += cnt[i] + 1; 
	}
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：Lacuna (赞：1)

### 思路：

将每个盒子的两个球看作是节点连边，然后跑 dfs 将有联系的节点分成一个个联通分量，设这个联通分量有 $cnt$ 个点，除去自环，则会有以下几种情况：

- 环：此时所有点的入度出度都为 $1$，我们只需要将其中一个盒子顶部的球放入空盒中，由于入度出度都为 $1$ 可知，此时另一个和当前盒子底部相同颜色的球一定在某个盒子的顶部，重复这个过程直到只剩最后两个球，此时一个球在第 $n+1$ 个盒子中，另一个和它相同颜色的球恰好在剩余空位的那个盒子中，再放回去即可。因为刚开始要将一个球放入空盒，之后每次操作都会组成一对 pair，即 $cnt$ 次操作，所以加上第一次操作，操作数是 $cnt + 1$。

- 链：有一个点入度为 $0$，有一个点出度为 $0$，剩余点的入度出度都为 $1$。此时有一种颜色的球两个都在最顶上，同理有一种颜色的球都在最底下，考虑将都在最顶上的那种球移到第 $n+1$ 个盒子，先组成一对 pair，让出空位，此时和环的情况相同，操作数也是 $cnt + 1$。

- 剩余：有两个及以上的点出度等于 $0$，此时无解，因为我们需要将所有都在上面的球组 pair，但没有这么多的空盒子容纳。

综上，只有环和链的情况合法，我们只要判断第三种情况即可。

### 实现：

在 dfs 中，用 $cnt$ 表示联通分量内节点个数，用 $cnt2$ 表示出度为 $0$ 的个数，按照上面的过程模拟就行，若 $cnt = 1$ 则说明出现自环，此时不需要移动，直接跳过即可。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define gc getchar
#define pb push_back
template<typename T>inline void read(T&x){x=0;int f=1;char ch=gc();while(!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}x*=f;}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
const int ri=2e5+5;
int n,cnt,cnt2,ans; 
bool vis[ri]; 
vector<int> e[ri];
vector<int> out;
int dfs(int u){
	vis[u]=1;
	cnt++;
	if(!out[u]) 
	  cnt2++;
	for(int v:e[u])
	  if(!vis[v]) dfs(v);
	return cnt;
}
int main(){
    read(n);
    out.resize(n+1);
	for(int i=1,u,v;i<=n;i++){
	  read(u,v);
	  e[u].pb(v); e[v].pb(u);
	  out[u]++;
	}
	for(int i=1;i<=n;i++){
	  if(!vis[i]){
	  	cnt=0,cnt2=0;
	  	int res=dfs(i);
	    if(res==1) continue;
	    if(cnt2>=2) puts("-1"),exit(0);
	    ans+=res+1;
	  }
	}
	printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Tairitempest (赞：1)

## [KOI 2024 Round 2] 收集彩球

下面的球要凑成一对，首先需要让上面的球被移走，然后这个球才有机会凑成一对，因此对于每个盒子的球，把两个球连一条有向边，表示依赖关系。

容易发现自环不需要操作；也可以发现两个不连通的点是不会相互影响的——当一个联通分量完成了它的移动彩球时，会把移动时需要占用的位置空出来，也就是所有的联通分量都是独立的。

需要注意的是每个非自环的彩球一定会有两条边相连，根据这个性质，我们需要对每个联通分量分析。

- 没有入度为零或出度为零的点：此时一定形成了一个环（如果存在非环结构，当有环时，一定会有一个节点连了三条或以上边；否则一定存在叶子结点）。这时断掉环，将这个联通分量中的任意一个彩球放到空盒子里，就有球可以被凑成一对（因为是环，所以选定的靠下的球对应的颜色相同的球一定是靠上的）。当上一个球被凑成一对时，下一个球的上面的球又会被移走，因此可以移动至最后仅剩一个球，而因为是环，最后剩下的球的颜色一定与最开始放到空盒子中的球相同。因此操作次数为联通分量节点数加一。

- 入度为零或出度为零的点有一个：此时一定会形成某节点至另一节点的两条链。这种时候进行两次操作，将两个靠上的颜色相同的彩球放到空盒子里，就会有两个球可以被凑成一对（因为是环，所以选定的靠下的球对应的颜色相同的球一定是靠上的）。同样地，当上一个球被凑成一对时，下一个球的上面的球又会被移走，因此可以移动至最后仅剩两个球，这两个球都是靠下的，因此可以得知它们颜色相同，将它们放在一个盒子里面就可以了。因此操作次数为联通分量节点数加一。

- 入度为零或出度为零的点有两个及以上：不存在方案。由于存在入度为零或出度为零的点时，需要先将所有靠上的球全部移到空的盒子里，不然这个联通分量之间存在每个球之间的依赖关系，上面的球不拿走，下面的球被压住，没有办法归位，而上面的球又没有位置给它放，因此这种情况无解。所以存在此情况的话无解。

总结一下：建图后如果存在一个联通分量，其中入度为零或出度为零的点有两个及以上，那么无解，否则有解：设非自环联通分量数为 $P$，自环数为 $R$，那么答案就是 $N+P-R$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a[200010],b[200010],cd[200010];
vector<ll> E[200010];
ll ans;
bool vis[200010];

ll dfs(ll p){
	ll res=0;
	if(cd[p]==0) res++;
	vis[p]=true;
	for(ll nxt:E[p]){
		if(vis[nxt]) continue;
		res+=dfs(nxt);
	}
	return res;
}

int main(){
	cin>>n;
	ans=n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		cd[a[i]]++;
		E[a[i]].push_back(b[i]);
		E[b[i]].push_back(a[i]);
		if(a[i]==b[i]){
			vis[a[i]]=true;
			ans--;
		}
	}
	for(int i=1;i<=n;i++){
		if(vis[i]) continue;
		ll c=dfs(i);
		if(c>=2){
			cout<<-1<<endl;
			return 0;
		}
		ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```

---


# [NOIP2023] 三值逻辑

## 题目描述

小 L 今天学习了 Kleene 三值逻辑。

在三值逻辑中，一个变量的值可能为：真（$\mathit{True}$，简写作 $\mathit{T}$）、假（$\mathit{False}$，简写作 $\mathit{F}$）或未确定（$\mathit{Unknown}$，简写作 $\mathit{U}$）。

在三值逻辑上也可以定义逻辑运算。由于小 L 学习进度很慢，只掌握了逻辑非运算 $\lnot$，其运算法则为：
$$\lnot \mathit{T} = \mathit{F}, \lnot \mathit{F} = \mathit{T}, \lnot\mathit{U} = \mathit{U}.$$

现在小 L 有 $n$ 个三值逻辑变量 $x_1,\cdots, x_n$。小 L 想进行一些有趣的尝试，于是他写下了 $m$ 条语句。语句有以下三种类型，其中 $\leftarrow$ 表示赋值：

1. $x_i \leftarrow v$，其中 $v$ 为 $\mathit{T}, \mathit{F}, \mathit{U}$ 的一种；
2. $x_i \leftarrow x_j$；
3. $x_i \leftarrow \lnot x_j$。

一开始，小 L 会给这些变量赋初值，然后按顺序运行这 $m$ 条语句。

小 L 希望执行了所有语句后，所有变量的最终值与初值都相等。在此前提下，小 L 希望初值中 $\mathit{Unknown}$ 的变量尽可能少。

在本题中，你需要帮助小 L 找到 $\mathit{Unknown}$ 变量个数最少的赋初值方案，使得执行了所有语句后所有变量的最终值和初始值相等。小 L 保证，至少对于本题的所有测试用例，这样的赋初值方案都必然是存在的。

## 说明/提示

**【样例解释 #1】**

第一组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \lnot x_1$；
- $x_3 \leftarrow \lnot x_2$；
- $x_1 \leftarrow x_3$。

一组合法的赋初值方案为 $x_1 = \mathit{T}, x_2 = \mathit{F}, x_3 = \mathit{T}$，共有 $0$ 个$\mathit{Unknown}$ 变量。因为不存在赋初值方案中有小于 $0$ 个$\mathit{Unknown}$ 变量，故输出为 $0$。

第二组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \lnot x_1$；
- $x_3 \leftarrow \lnot x_2$；
- $x_1 \leftarrow \lnot x_3$。

唯一的赋初值方案为 $x_1 = x_2 = x_3 = \mathit{U}$，共有 $3$ 个$\mathit{Unknown}$ 变量，故输出为 $3$。

第三组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \mathit{T}$；
- $x_2 \leftarrow \mathit{U}$；

一个最小化 $\mathit{Unknown}$ 变量个数的赋初值方案为 $x_1 = \mathit{T}, x_2 = \mathit{U}$。$x_1 = x_2 = \mathit{U}$ 也是一个合法的方案，但它没有最小化 $\mathit{Unknown}$ 变量的个数。

**【样例解释 #2】**

该组样例满足测试点 $2$ 的条件。

**【样例解释 #3】**

该组样例满足测试点 $5$ 的条件。

**【样例解释 #4】**

该组样例满足测试点 $8$ 的条件。

**【数据范围】**

对于所有测试数据，保证：

- $1 \le t \le 6$，$1 \le n,m \le 10 ^ 5$；
- 对于每个操作，$v$ 为 `TFU+-` 中的某个字符，$1 \le i,j \le n$。

| 测试点编号 | $n,m\leq$ | $v$ 可能的取值 |
| :----------: | :----------: | :----------: |
| $1,2$ | $10$ | $\mathit{TFU+-}$ |
| $3$ | $10^3$ | $\mathit{TFU}$ |
| $4$ | $10^5$ | $\mathit{TFU}$ |
| $5$ | $10^3$ | $\mathit{U+}$ |
| $6$ | $10^5$ | $\mathit{U+}$ |
| $7$ | $10^3$ | $\mathit{+-}$ |
| $8$ | $10^5$ | $\mathit{+-}$ |
| $9$ | $10^3$ | $\mathit{TFU+-}$ |
| $10$ | $10^5$ | $\mathit{TFU+-}$ |

## 样例 #1

### 输入

```
1 3
3 3
- 2 1
- 3 2
+ 1 3
3 3
- 2 1
- 3 2
- 1 3
2 2
T 2
U 2
```

### 输出

```
0
3
1
```

# 题解

## 作者：哈哈人生 (赞：1138)

## [题目传送门](https://www.luogu.com.cn/problem/P9869)

## 题外话
由于很多人对本题并查集做法提问，本人于二零二四年一月二十日对此篇题解进行了更新。

## 巧妙方法
相信大家已经知道此题的并查集、高斯消元等解法了，本人在此篇题解对此不再赘述，只是给大家提供一种代码细节——处理三值逻辑的符号的一些巧妙的方法。

我们其实可以把三值逻辑分别赋予三个值，再把这三个值赋予三个常量，常量名就以 $T$、$F$、$U$ 所命名，方便我们下面并查集中的代码编写。我们接着规定逻辑非运算就是把值的正负取反，那么 $U$ 常量的值就应该为 $0$（因为 $0=-0$）。而 $T$ 常量和 $F$ 常量的值呢？因为要把常量值和变量值区别开，我们这里取一个 $n$ 的上限加一的值，即 $100001$ 和 $-100001$。这样我们在代码编写中就可以以常量名代替繁琐的字符判断，本人认为是十分巧妙且便捷的。

## 本人做法
这里具体说一下并查集做法（~~也是更新部分~~）。

我们的大体思路是先按照题意模拟，给所有输入的操作的相关变量用并查集标记，在并查集查询操作前我们就可以确定哪些变量的值是确定的，哪些是不确定的，这时我们的任务就是最小化不确定的变量中 $U$ 的个数。那哪些情况的变量它的值一定是 $U$ 呢？总的来说有两种：

1. $x$ 的祖先是 $-x$。
2. $x$ 的祖先是 $U$。

我们把这两种情况查询出来，再统计个数，就是最终答案了！由于 $x$ 的值可能我们可能标记成负数了，所以并查集查询时遇到负数要取相反数，不然就会运行错误（~~别问我怎么知道的，哭~~）。

由于我们要查询的 $x$ 的祖先有可能是 $-x$，取相反数后又是 $x$，这样就会陷入死循环。于是我们需要用 $book$ 数组记录是否到过这个点的相反数（其实就是上面所写的情况一）。由于 $book$ 记录的值也有负数，所以我们要给记录的值统一加上一个 $n$ 把其全变成正数。这时需要注意 $book$ 数组的大小要开到 $2\times n$ 哦。

然后，就没有然后了（写代码呗）。

## 代码
上代码（~~马蜂良好，条件语句清楚，适宜阅读~~）。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int T=100001,F=-100001,U=0;//三值逻辑
int c,t,n,m,a,b,fa[100005];
char ch[100005];
bool book[300005];
int find(int x) {
	int re;
	if(x==T||x==F)re=x;
	else if(book[n-x]||x==U)re=U;
	else if(book[x+n])re=T;
	else if(x<0) {
		if(x==-fa[-x])re=x;
		else {
			book[x+n]=1;
			re=find(-fa[-x]);//这里注意细节
			book[x+n]=0;//清空
		}
	} else {
		if(x==fa[x])re=x;
		else {
			book[x+n]=1;
			re=fa[x]=find(fa[x]);
			book[x+n]=0;//清空
		}
	}
	return re;
}
signed main() {
	cin>>c>>t;
	while(t--) {
		cin>>n>>m;
		for(int i=1; i<=n; i++)fa[i]=i;
		for(int i=1; i<=m; i++) {
			cin>>ch[i];
			if(ch[i]=='T') {
				cin>>a;
				fa[a]=T;
			} else if(ch[i]=='F') {
				cin>>a;
				fa[a]=F;
			} else if(ch[i]=='U') {
				cin>>a;
				fa[a]=U;
			} else {
				cin>>a>>b;
				if(ch[i]=='+')fa[a]=fa[b];
				else fa[a]=-fa[b];
			}
		}
		int ans=0;
		for(int i=1; i<=n; i++) {
			if(find(i)==U)ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

## 后记
祝点赞的人都有蓝勾！

另外，这么好的一篇题解，关注一下我呗。

站长曾经说过，不抄袭题解代码，只借鉴题解思路，但应该给题解点个赞，并且关注写题解的人（~~开玩笑的~~）。

---

## 作者：August_Light (赞：89)

# P9869 [NOIP2023] 三值逻辑 题解

[题目传送门](https://www.luogu.com.cn/problem/P9869)

## 题意简述

**定义** 三值逻辑变量：有 $T,F,U$ 三种取值，有关系如下：

$$\lnot \mathit{T} = \mathit{F}, \lnot \mathit{F} = \mathit{T}, \lnot\mathit{U} = \mathit{U}.$$

现在小 L 有 $n$ 个三值逻辑变量 $x_1,\cdots, x_n$。小 L 想进行一些有趣的尝试，于是他写下了 $m$ 条语句。语句有以下三种类型，其中 $\leftarrow$ 表示赋值：

1. $x_i \leftarrow v$，其中 $v$ 为 $\mathit{T}, \mathit{F}, \mathit{U}$ 的一种；
2. $x_i \leftarrow x_j$；
3. $x_i \leftarrow \lnot x_j$。

一开始，小 L 会给这些变量赋初值，然后按顺序运行这 $m$ 条语句。

小 L 希望执行了所有语句后，所有变量的最终值与初值都相等。在此前提下，小 L 希望初值中 $U$ 的变量尽可能少。输出 $U$ 的个数。

$1 \le n,m \le 10 ^ 5$。

## 解法（考场思路）

### 如何处理这 $m$ 条语句？

注意到每个变量最终的取值有这几种可能：

$$x_i=\begin{cases} T \\ F \\ U \\ x_j \\ \neg x_j \end{cases}$$

为了方便，我们可以将 $T$ 定义为 $x_{n+1}$，$F$ 定义为 $\neg x_{n+1}$，$U$ 定义为 $x_{n+2}$。

此时 $x_i$ 只能是 $x_j$ 或 $\neg x_j$ 的形式。

对每个变量建边 $i \to j$ 和 $j \to i$，边权根据是否需要 $\neg$ 分为 $1$ 和 $0$。把这个问题放到图上考虑。

### 怎么数 $U$ 的个数？

考虑什么时候会出现 $U$。

如果没有 $U$ 而只有 $T,F$，那么可能出现矛盾。如样例。

不难看出一定是图上出现了奇环才会矛盾。（这里奇环的定义为 $1$ 的数量为奇数而 $0$ 的数量随意的环）

所以，判二分图。（这里二分图的定义为，不存在奇环的图）

- 如果是二分图，则 $T,F$ 完全可以胜任。
- 如果不是二分图，则 $T,F$ 不能胜任，整个连通块都会被污染成 $U$。
- $x_{n+2}$（即 $U$）所在的连通块是最终被赋值为 $U$ 的那些变量，它们显然和矛盾没有任何关系，所以单独统计。不要忘记减掉 $x_{n+2}$ 自身。

DFS 即可。

## 代码

时间复杂度 $\Theta(n+m)$。

代码是基于考场代码改的，觉得乱的话将就着看吧。

```cpp
// 日亮好闪，拜谢日亮。

#include <bits/stdc++.h>
#define memset0(a) memset(a, 0, sizeof a)
using namespace std;
typedef pair<int, int> pii;

const int MAXN = 1e5 + 5;

int n, m;
int T, U;
// n+1 是 T
// n+2 是 U

int fa[MAXN];
bool flp[MAXN];

vector<pii> G1[MAXN]; // 黑白染色的无向图
bool vis[MAXN];
int f[MAXN]; // 黑白染色的颜色
bool is_bi_graph; // 这个连通块是否为二分图
int get_size(int u) { // u 所在的连通块大小
    vis[u] = 1;
    int siz = 1;
    for (auto [v, w] : G1[u]) {
        if (vis[v]) {
            if (f[v] != (f[u] ^ w))
                is_bi_graph = 0;
        } else {
            f[v] = (f[u] ^ w);
            siz += get_size(v);
        }
    }
    return siz;
}

vector<int> G2[MAXN]; // 找 U 所在连通块的图
int get_U_size(int u = U) {
    int siz = 1;
    for (auto v : G2[u])
        siz += get_U_size(v);
    return siz;
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    int C, number_of_cases; cin >> C >> number_of_cases;
    while (number_of_cases--) {
        cin >> n >> m;
        T = n+1, U = n+2;

        // 多测不清空，亲人两行泪
        for (int i = 1; i <= n+2; i++)
            fa[i] = i, flp[i] = 0;
        memset0(G1); memset0(G2); memset0(f); memset0(vis);

        while (m--) {
            char op; cin >> op;
            if (op == 'T' || op == 'F' || op == 'U') { // 操作 1
                int x; cin >> x;
                if      (op == 'T') fa[x] = T, flp[x] = 0; // 不 flip 接上 T
                else if (op == 'F') fa[x] = T, flp[x] = 1; // flip 后接上 T
                else if (op == 'U') fa[x] = U, flp[x] = 0; // 接上 U
            } else if (op == '+') { // 操作 2
                int x, y; cin >> x >> y;
                fa[x] = fa[y], flp[x] = flp[y];
            } else if (op == '-') { // 操作 3
                int x, y; cin >> x >> y;
                fa[x] = fa[y], flp[x] = (flp[y] ^ 1);
            }
        }

        // 为 黑白染色 建 无向图
        for (int u = 1; u <= n; u++) {
            G1[fa[u]].emplace_back(u, flp[u]);
            G1[u].emplace_back(fa[u], flp[u]);
        }
        int ans = 0;
        for (int u = 1; u <= n; u++)
            if (!vis[u]) {
                is_bi_graph = 1;
                int tmp = 0;
                f[u] = 1, tmp = get_size(u); // 获得连通块大小的同时判断是否是二分图
                if (!is_bi_graph)
                    ans += tmp;
            }

        // 为 找 U 所在连通块 建 有向图
        for (int u = 1; u <= n; u++)
            G2[fa[u]].push_back(u);
        ans += get_U_size()-1;

        cout << ans << '\n';
    }
    return 0;
}
```

## 题外话

考场上调了好久没调出来，去了 WC 回来立刻调出来了。WC 好闪，拜谢 WC。

---

## 作者：_Dolphin_ (赞：40)

[题目传送门](https://www.luogu.com.cn/problem/P9869)

## Solution

首先要处理一下读入的数据，需要将读入的数据进行路径压缩，如这组数据：

```
3 2
+ 2 1
+ 3 2
```

经过处理后得到：

```
1 <- 1
2 <- 1
3 <- 1
```

将赋值的元素与被赋值的元素相连，以赋值的元素为父亲，可以见到，他们构成了一棵树。

![图 1](https://cdn.luogu.com.cn/upload/image_hosting/1olzgxzm.png)

事实上，所有的数据都可以压缩成像这样的树构成的森林。可以一开始将每个数乘 $2$，取反时将要取反的数异或上 $1$ 就可以了。如数据:

```
3 2
- 2 1
+ 3 1
```

就可以转化为：

![图 2](https://cdn.luogu.com.cn/upload/image_hosting/kaxg1rcf.png)

其中方括号内的数字表示真实的父亲值，偶数为正，奇数为反。

那么，我们可以得到如下结论：如果某棵树的根结点的反在这棵树中或者根节点是 Unknown，因为这整棵树都是由它赋值得到的，所以这整棵树就一定都是 Unknown，否则就可以都不是 Unknown。

可以使用并查集将数据转化为森林，再判断每棵树是否满足是 Unknown 的条件，如果这棵树是 Unknown，就在答案上累计树的大小即可。

### Code(100 pts):

```cpp
#include<bits/stdc++.h>
#define afor(x,y,z) for(int x=y;x<=z;x++)
#define bfor(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
typedef long long ll;
typedef const int cint;
cint N=100010;
int t,c,n,m,fa[N],siz[N],mp[N];
int find(int x) {//查找
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);
}
void Union(int x,int y) {//合并
	int fx=find(x),fy=find(y);
	if(fx!=fy) fa[fy]=fx,siz[fx]+=siz[fy];
}
bool dfs(int x,int root,int flag) {//找这棵树中是否有根节点的反
	if(mp[x]/2==root) return flag^(mp[x]&1);
	return dfs(mp[x]/2,root,flag^(mp[x]&1));
}
#define True -1
#define False -2
#define Unknown -3
int opp(int x) {//数值的反
	if(x==True) return False;
	if(x==False) return True;
	if(x==Unknown) return Unknown;
	return x^1;
}
int main() {
	scanf("%d%d",&c,&t);
	while(t--) {
		int ans=0;
		scanf("%d%d",&n,&m);
		afor(i,1,n) mp[i]=i*2,fa[i]=i,siz[i]=1;
		afor(i,1,m) {
			char opt;
			int x,y;
			scanf(" %c",&opt);
			if(opt=='+') {
				scanf("%d%d",&x,&y);
				mp[x]=mp[y];//路径压缩
			}
			else if(opt=='-') {
				scanf("%d%d",&x,&y);
				mp[x]=opp(mp[y]);
			}
			else if(opt=='T') scanf("%d",&x),mp[x]=True;
			else if(opt=='F') scanf("%d",&x),mp[x]=False;
			else scanf("%d",&x),mp[x]=Unknown;
		}
		afor(i,1,n) if(mp[i]>0) Union(mp[i]/2,i);//连边，以赋值的元素为父亲
		afor(i,1,n) if(i==find(i)&&(mp[i]==Unknown||(mp[i]>0&&dfs(i,i,0))))
			ans+=siz[i];//满足是 Unknown 的条件就累加答案
		printf("%d\n",ans);
	}
	return 0;
}
```

### DFS 函数的解释

很多人说看不懂，我在这里解释一下。

```cpp
bool dfs(int x,int root,int flag) {
	if(mp[x]/2==root) return flag^(mp[x]&1);
	return dfs(mp[x]/2,root,flag^(mp[x]&1));
}
```
首先说一下为什么要深搜，因为并查集的结构不存在环，如果出现循环赋值的情况，根实际被另一个元素赋值，而这个元素也一定在树中。

如果赋值根的元素是经过根奇数次取反得到的，由于两次取反可以抵消，相当于是根经过一次取反得到的，这时根既不能为 True，也不能为 False，就只能是 Unknown 了。

深搜过程有三个参数 `x`，`root` 和 `flag`。

`x` 表示当前深搜到的节点，`root` 表示这棵树的根节点编号，`flag` 表示在深搜过程中，是否经过奇数次取反。

`mp[x]/2==root` 表示赋值 `x` 的元素为根。

`mp[x]&1` 为判断奇偶，若表达式为真表示 `mp[x]` 为奇，即有取反操作，反之则表示 `mp[x]` 为偶，即没有取反操作。

`flag^(mp[x]&1)` 就表示如果当前操作为取反，则再次改变 `flag` 的值。也就是算上本次操作后，总共经过的取反次数。

如果找到根了，并且经过了奇数次取反，就表示根只能取 Unknown 了。

---

## 作者：培淇2021 (赞：36)

写一篇给萌新看的题解。

先看题。注意到每个变量的终态是只与初始态有关的，且只关于一个变量。

例如 $x_i=\lnot x_j$，这里我表示的意思是，左边是终态（最终的值），右边是初始的值（即一开始赋的初值）。

可以发现先预处理出来没有影响，而这就涉及到我们的第一个数组（为了易懂，标出所有**重要**变量与数组的功能和名称，加粗）了：

**名称**：**`val`**  
**功能**：标记 $x_{1\sim n}$ 的终态由哪个初始值产生。  
**记录**：`val[i]=j` 代表：
1. 当 $j=n+1$ 时，最后 `val[i]` 被赋成了 `T`，与其他变量无关。
1. 当 $j=n+2$ 时，最后 `val[i]` 被赋成了 `F`，与其他变量无关。
1. 当 $j=n+3$ 时，最后 `val[i]` 被赋成了 `U`，与其他变量无关。
1. 当 $1\le j\le n$ 时，最后 `val[i]` 被赋成了 `val[j]`（**初值**），与其他变量无关。
1. 当 $-n\le j\le 1$ 时，最后 `val[i]` 被赋成了非 `val[j]`（**初值**），与其他变量无关。

**代码**：
```cpp
cin>>op>>x; // 这里写的是读入每一个赋值操作的代码
if(op=='+') // 直接赋值
{
    cin>>y;
    val[x]=val[y]; // x 的值变成赋值给 y 的初值
}
if(op=='-') // 取非赋值
{
    cin>>y;
    if(abs(val[y])<=n) // 如果是变量
        val[x]=-val[y]; // 直接取非
    else // 否则是值，直接照抄
    {
        if(val[y]==n+1)
            val[x]=n+2;
        if(val[y]==n+2)
            val[x]=n+1;
        if(val[y]==n+3)
            val[x]=n+3;
    }
}
if(op=='T') // 也是照抄
    val[x]=n+1;
if(op=='F')
    val[x]=n+2;
if(op=='U')
    val[x]=n+3;
```

我们做好了题目中给的一大任务：变量的赋值。

那么现在如何去处理这些变量？这里我们思考，`val` 的值如何与变量的比较有关系。

这个不难，`val` 是 $n+1\sim n+3$ 代表是一个值，否则 `val` 正就直接赋值，`val` 负就取非再赋值。

我们把 `x` 与 `val[x]`，其中 `abs(val[x])<=n` 时，称它为一个“等价关系”（虽然数学老师不喜欢看见这种定义），把可以用“等价关系”联通的极大点集叫做一个连通块。

注意到连通块之间相互不影响，对于每个连通块分别处理即可。

首先，对于每个连通块，可以认为（按照题目的输入的 `+`，`-`）只有两种“等价关系”：`+`，`-`。

那么，由于 `U` 怎么运算都是 `U`，那么**如果一个连通块里有赋值为 `U` 的节点，这个连通块就对答案没有贡献，就消掉了。**（这里的消打引号，意思是 无用，下同）这是因为这样的连通块中，只能全是 `U`。

接下来考虑无 `U` 连通块，这里先考虑“等价关系”，注意到任意一个连通块，**如果“等价关系”的逻辑错误（例如全 `-` 三元环的）存在，这个连通块也消掉了。**（即只能全是 `U` 了）。

如果没有逻辑错误呢？这时候可以钦定一个节点为 `T`，先搜索一遍，这样就可以确定每个节点的值了。搜索后再看一遍“等价关系”是否正确，**这样就可以清理掉“等价关系”的逻辑错误。**  

最后一个问题就是，搜完一遍之后，每个 `val[x]=n+1,n+2` 结点的值与原来不符怎么办？这个也很好解决，**它们的值要么全不同于搜完的值，要么全相同于搜完的值（这是因为我们钦定了一个节点是 `T`），最后统计一遍即可，这样就清除掉了最后一种消掉的情况。**

----

思维部分，结束，下面开始代码部分。

先总结一下我们还没整理到的要做的事（分布于刚刚的黑体字中）：

1. 搜索一遍。
2. 连通块有 `U` 的情形，消掉连通块。
3. “等价关系”的逻辑错误，消掉连通块。
4. `val[x]=n+1,n+2` 结点的值不符，消掉连通块。
5. 将没有被消掉的连通块大小相加。

接下来按每个部分整理：

首先需要像建图一样建边（即“等价关系”），这里我用的是 `vector`。

建边的具体形式为：双向边，权值存 `+-`，边为 `+` 就存入 $1$，边为 `-` 就存入 $-1$。

**代码**：
```cpp
struct node{
	int poi,op; // op 即为正负一
};
vector<node> e[100005];
......
......
for(int x=1;x<=n;x++)
	if(val[x]<=n) // 只建非直接赋 TFU 值 的边
	{
		if(val[x]>0) // +
		{
			e[x].push_back((node){val[x],1});
			e[val[x]].push_back((node){x,1});
		}
		else // -
		{
			e[x].push_back((node){-val[x],-1}); // 注意这里要 -val[x]
			e[-val[x]].push_back((node){x,-1});
		}
	}
```

1. 搜索一遍。

需要用到的变量/数组有：`cnt`（连通块个数），`siz[]`（连通块大小），`fh[]`（每个点的符号，`T` 为 `1`，`F` 为 `-1`），`belong[]`（每个点属于的连通块编号）。

**代码**：
```cpp
void dfs(int poi,int fat) // poi, father
{
	belong[poi]=cnt,siz[cnt]++; // 处理 belong, siz
	int ssiz=e[poi].size();
	for(int i=0;i<ssiz;i++)
	{
		int nxt=e[poi][i].poi;
		if(nxt==fat||belong[nxt]!=0) // 遍历到过就 continue
			continue;
		fh[nxt]=fh[poi]*e[poi][i].op; // 更新符号
		belong[poi]=cnt,dfs(nxt,poi); // 继续
	}
} 
......
......
for(int i=1;i<=n;i++) // 对于每个变量而言
	if(belong[i]==0) // 如果还没遍历到
		cnt++,fh[i]=1,dfs(i,0); // 多了一个连通块，此节点钦定为 T，开始搜索
```

2. 连通块有 `U` 的情形，消掉连通块。

现在开始消掉连通块的过程了。

定义 `bool` 数组 `xiao[]` 表示这个连通块有没有被消掉。

那么现在只需要判断一遍，对每个 `U` 消掉 `belong[]` 的连通块即可。

**代码**：
```cpp
for(int i=1;i<=n;i++) // 对于每个变量
	if(val[i]==n+3) // 如果是 U
		xiao[belong[i]]=1; // 消掉所属的连通块
```

3. “等价关系”的逻辑错误，消掉连通块。

对每个等价关系，判断一下，如果是 `+`，值应相同，反之值不相同即可。

**代码**：
```cpp
for(int i=1;i<=n;i++) // 对于每个变量
	if(val[i]<=n) // 如果不是 TFU
	{
		if(val[i]>0) // 等价关系为 +
		{
			if(fh[i]!=fh[val[i]]) // 不等就不行
				xiao[belong[i]]=1;
		}
		else // 等价关系为 -
		{
			if(fh[i]==fh[-val[i]]) // 相等就不行
				xiao[belong[i]]=1;
		}
	}
```

4. `val[x]=n+1,n+2` 结点的值不符，消掉连通块。

这里定义数组 `hav[]`。

**名称**：**`hav`**  
**功能**：标记连通块的符号。  
**记录**：`hav[i]=0/1/-1` 代表：
1. 当它为 `0` 时，连通块的符号与原来相符。
1. 当它为 `1` 时，连通块的符号与原来不相符。
1. 当它为 `-1` 时，还未赋值。

**代码**：
```cpp
for(int i=1;i<=n;i++)
{
	if(val[i]==n+1) // 如果为 T
	{
		if(hav[belong[i]]==-1)
			hav[belong[i]]=(fh[i]==1);
		else if(hav[belong[i]]!=(fh[i]==1))
			xiao[belong[i]]=1;
	}
	if(val[i]==n+2) // 如果为 F
	{
		if(hav[belong[i]]==-1)
			hav[belong[i]]=(fh[i]==0);
		else if(hav[belong[i]]!=(fh[i]==0))
			xiao[belong[i]]=1;
	}
}
```

5. 将没有被消掉的连通块大小相加。

不用说了吧。

**代码**：
```cpp
int sum=0;
for(int i=1;i<=cnt;i++)
	if(xiao[i])
		sum+=siz[i];
cout<<sum<<endl;
```

综上，本题结束。

注：如果按这样写，感觉可以评黄（

---

## 作者：_yjh (赞：33)

本题解只用到了 BFS。

首先想到拆点，如果点 $x$ 修改了 $k_x$ 次就拆成 $k_x+1$ 个点。

对于操作一直接对 $x$ 建一个新版本，暴力赋值即可；对于操作二、三则相当于对于 $x$ 建一个新版本，和 $y$ 得最新版本连边权为 $1$ 或 $0$ 得边，表示两点之间是相等还是相反。注意到这些边都是无向边，且确定一个端点另一个端点随之确定。

特别的，由于操作始末状态相同，需要把每个点始末版本连一条代表相等得边。

然后发现每个连通块只有三种状态，且相互独立。于是直接暴力 bfs 即可。

特别注意第二种操作 $x=y$ 的情况。

时间复杂度 $O(n)$。[link](https://www.luogu.com.cn/paste/z1z38uq5)

---

## 作者：SnowTrace (赞：14)

 规定 $T$ 为 $1$，$F$ 为 $-1$，$U$ 为 $0$。

我们考虑维护结果。

在最终 $n$ 个数的值要么是定值，要么可以写成 $ka_j$ 的形式，其中 $-1\leq k \leq 1$。

如果最终有出来的结果有 $a_i = ka_j$ 我们把 $i$ 和 $j$ 连上，边权是 $k$，然后我们获得一颗基环树。

假设树上某个点是个定值（其实就相当于这个联通块是一颗内向树），我们可以直接遍历联通块赋值。

否则这个联通块内的点的答案还不能直接确定。

考虑这个基环树上的环：

假设环上边乘积是 $-1$，也就是说 $a_i = -a_i$，从而一整个联通块都是 $U$。

否则，随便赋值，也就是可以赋值成全部都不是 $U$ 的形态。

代码**仅供参考**。

```cpp
#include<bits/stdc++.h>
using namespace std;
int fl[200005],val[200005];
int n,m;
int in[200005],out[200005],ans[200005],vis[200005],pp[200005],ss[200005],fa[200005],used[200005];
int sz[200005];
vector<pair<int,int> >p[200005],p1[200005];
int find(int x){
    if(fa[x] == x)return x;
    return fa[x] = find(fa[x]);
}void merge(int x,int y){
    int a = find(x),b = find(y);
    if(b == a)return;
    fa[b] = a;sz[a]+=sz[b];sz[b] = 0;
}
void dfs(int now,int val){vis[now] = 1;
    ans[now] = val;
    for(int i =0;i<p1[now].size();i++){
        dfs(p1[now][i].first,p1[now][i].second*val);
    }return;
}int pro = 1,ok = 0;
void dfs1(int now){
    if(vis[now] == 1){
        if(pp[now]!=pro)ok = 1;
        return;
    }vis[now] =1;pp[now] = pro;
    for(int i =0;i<p[now].size();i++){
        pro = pro*p[now][i].second;
        dfs1(p[now][i].first);
    }
}
void solve(){
    cin >> n >> m;
    for(int i =1;i<=n;i++)fl[i] = 1,val[i] = i,in[i] = 0,out[i] = 0,ans[i] = -2,vis[i] = 0,ss[i] = 0,sz[i] = 1;
    for(int i =1;i<=n;i++)fa[i] = i,used[i] = 0;
    for(int i = 1;i<=n;i++)p[i].clear(),p1[i].clear();
    for(int i =1;i<=m;i++){
        char c;cin >> c;
        if(c == '-'){
            int x,y;cin >> x >> y;
            if(fl[y] == 0){
                fl[x] = 0;val[x] = -val[y];
            }else{
                fl[x] = -fl[y],val[x] = val[y];
            }
        }if(c == '+'){
            int x,y;cin >> x >> y;
            val[x] = val[y],fl[x] = fl[y];
        }if(c == 'T'){
            int x;cin >> x;
            fl[x] = 0,val[x] = 1;
        }if(c == 'F'){
            int x;cin >> x;
            fl[x] = 0,val[x] = -1;
        }if(c == 'U'){
            int x;cin >> x;
            fl[x]  =0,val[x] = 0;
        }
    }for(int i = 1;i<=n;i++){
        if(fl[i]!=0){
            p1[val[i]].push_back({i,fl[i]});
            p[i].push_back({val[i],fl[i]});merge(val[i],i);
        }
    }for(int i = 1;i<=n;i++){
        if(fl[i] == 0){
                used[find(i)] = 1;
            dfs(i,val[i]);
        }
    }int tot = 0;
    for(int i= 1;i<=n;i++){
        if(!used[find(i)]){used[find(i)] = 1;
            pro =  1,ok = 0;
            dfs1(i);
            tot+=ok*sz[find(i)];
        }
    }
    for(int i = 1;i<=n;i++)if(ans[i] == 0)tot++;
    cout << tot << endl;
}int id;
signed main(){
 //   freopen("tribool.in","r",stdin);
 //   freopen("tribool.out","w",stdout);
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin >> id;
    int t;cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```


---

## 作者：听取MLE声一片 (赞：11)

考虑模拟操作过程，动态维护每个变量是由哪个变量的初始值决定的，以及是否取反。对于第 $i$ 个变量，其的值由 $a_i$ 的初始值决定，若 $b_i=1$ 则取反，否则不取反。

如果令 $u$ 等于 $v$，则等价于 $u$ 的来源直接更改到 $v$ 的来源，$a_u$ 直接更改为 $a_v$，$b_u$ 更改为 $b_v$。

对于取反操作同理，只需要令 $b_u=\neg b_v$ 即可。

对于每个变量 $i$，设初值 $a_i=i$，$b_i=0$。把每个变量视为点，特别的，$T$，$F$，$U$ 也作为点。

不难发现对于每个 $i$，其 $a_i$ 唯一。则从 $i$ 到 $a_i$ 连边，所有点出度为 $1$，即为内向基环森林。

对于树的情况，无论根定为什么，整棵树均有一种合法赋值方式。对于基环树情况，若环有赋值方案，则树的部分一定存在赋值方案。则只需要判断环是否满足条件即可，若环上不存在合法赋值方案，则树部分的点也都不存在合法赋值方案。

对于以 $U$ 为根的基环树，则整棵树上的点均为未确定，直接加上基环树的大小。

对于以普通点构成环的基环树，枚举环上一个点的赋值，即可顺序求出环所赋的值，直接判断赋值方案是否合法即可。若不合法，直接加上基环树大小即可。

根据写法不同可能需要特判自环为根的情况。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#include<random>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=1e5+10;
int n,q,ans,a[N],b[N],vis[N],mp[N];
vector<int>e[N];
void dfs(int u){
	if(vis[u])return;
	ans++;
	vis[u]=1;
	for(int v:e[u])
		dfs(v);
}
void dfs1(int u){
	if(vis[u])return;
	vis[u]=1;
	for(int v:e[u])
		dfs1(v);
}
int main()
{
	int id=read(),T=read();
	while(T--){
		n=read(),q=read();
		ans=0;
		for(int i=1;i<=n+3;i++){
			a[i]=i;
			b[i]=0;
			vis[i]=0;
			mp[i]=0;
			e[i].clear();
		}
		while(q--){
			char ch[5];
			scanf("%s",ch);
			if(ch[0]=='+'){
				int u=read(),v=read();
				a[u]=a[v];
				b[u]=b[v];
				continue;
			}
			if(ch[0]=='-'){
				int u=read(),v=read();
				a[u]=a[v];
				b[u]=b[v]^1;
				continue;
			}
			if(ch[0]=='T'){
				int u=read(),v=n+1;
				a[u]=a[v];
				b[u]=b[v];
				continue;
			}
			if(ch[0]=='F'){
				int u=read(),v=n+2;
				a[u]=a[v];
				b[u]=b[v];
				continue;
			}
			if(ch[0]=='U'){
				int u=read(),v=n+3;
				a[u]=a[v];
				b[u]=b[v];
				continue;
			}
		}
		for(int i=1;i<=n;i++)
			if(a[i]!=i)
				e[a[i]].push_back(i);
		for(int i=1;i<=n;i++)
			if(a[i]==i){
				if(b[i]==1)
					dfs(i); 
			}
		ans--;
		dfs(n+3);
		for(int i=1;i<=n;i++){
			if(vis[i])continue;
			int x=i;
			mp[x]=1;
			while(1){
				x=a[x];
				if(mp[x])break;
				mp[x]=1;
			}
			int s=b[x],u=x;
			while(1){
				u=a[u];
				if(u==x)break;
				s+=b[u];
			}
			if(s&1)dfs(x);
			else dfs1(x);
		}
		printf("%d",ans);
		putchar('\n');
	}
	return 0;
}

```

---

## 作者：Moeebius (赞：11)

> [full version](https://www.luogu.com.cn/blog/Moeebius/noip-2023-sol)
>
> 你真的会写基环树找环吗？

考虑对于每次直接赋值操作 $a\gets b$，从 $b$ 向 $a$ 连一条 **有向红边**；对于每次取反后赋值操作 $c\gets \lnot d$，从 $d$ 向 $c$ 连一条 **有向黑边**。对于赋值成 $\text{T,F,U}$ 的情况，直接建立对应虚点即可。

发现这样不太好处理一个点被多次赋值的情况；考虑每次赋值操作，均把 **被赋值点** 复制一份（也可以理解为新增一个版本）。这样，每一个点均代表了一个唯一的 $\text{tribool}$ 值。

同时为了满足「初末值相同」的需求，我们从每个点的最后版本直接向初值所对应的版本连一条 **有向红边**，表示末值可以「推导」出初值，且两者相同。

容易发现，这样处理完后，每个点入度均为 $1$，构成了一棵 **外向基环树**。

考虑什么情况下会出现 $\text{U}$。

1. $U$ 所在的基环树，整棵树都应该是 $\text{U}$；

2. 基环树环上存在 **奇数条黑边**。这意味着如果从环上某一点出发，转一圈回来后的值恰好等于初值 **取反** 后的值。同样整棵树也应该是 $\text{U}$。

基环树找环即可，时间复杂度 $O(\sum n+m)$。

---

```cpp
constexpr ll MAXN = 2e5 + 5;
int n, m, cur[MAXN], cnt, val[MAXN], bl[MAXN]; // val: 1-T, 2-F, 3-U; cur: 每个点最新版本的编号
vector<pair<int, bool>> G[MAXN], G2[MAXN];
bitset<MAXN> vis, onC;
vector<vector<int>> cycle;
stack<int> st;
bool ok = 0;
void dfs(int x, int rt) {
  if (bl[x] == rt) {
    while (1) {
      int u = st.top();
      st.pop();
      onC[u] = 1, cycle.back().eb(u);
      if (u == x)
        break;
    }
    return ok = 1, void();
  } else if (!G2[x].size()) {
    onC[x] = 1;
    cycle.back().eb(x);
    return ok = 1, void();
  }
  st.push(x);
  vis[x] = 1, bl[x] = rt;
  for (pii e : G2[x]) {
    if (ok)
      return;
    dfs(e.fi, rt);
  }
}
il void addEdge(int u, int v, int w) {
  G[u].eb(v, w);
  G2[v].eb(u, w);
}
il void dfs2(int x, bool tp) {
  val[x] = tp ? 3 : 0, vis[x] = 1;
  for (pii e : G[x]) {
    if (!onC[e.fi]) {
      dfs2(e.fi, tp);
    }
  }
}
il void calc() { // 找环
  int cur = 0, hasC = 0;
  bool qwq = 0;
  for (int x : cycle.back()) {
    hasC |= (x == n + m + 3);
    if (x == n + m + 1 && !qwq && cur) {
      qwq = 1;
    } else if (x == n + m + 2 && !qwq && !cur) {
      qwq = 1;
    }
    for (pii e : G[x]) {
      if (onC[e.fi]) {
        cur ^= e.se;
        break;
      }
    }
  }
  for (int x : cycle.back()) {
    dfs2(x, cur || hasC); // 染色
  }
}
il void solve() {
  read(n, m);
  int A = n + m + 1, B = n + m + 2, C = n + m + 3; // T, F, U 对应虚点
  cnt = n, vis.reset(), onC.reset();
  fill(bl + 1, bl + C + 1, 0);
  fill(val + 1, val + C + 1, 0);
  cycle.clear();
  For(i, 1, n + m + 3) G[i].clear(), G2[i].clear();
  iota(cur + 1, cur + 1 + n, 1);
  For(i, 1, m) {
    char op[3];
    int x, y;
    scanf("%s%d", op, &x);
    if (op[0] == '+') {
      scanf("%d", &y);
      addEdge(cur[y], ++cnt, 0), cur[x] = cnt;
    } else if (op[0] == '-') {
      scanf("%d", &y);
      addEdge(cur[y], ++cnt, 1), cur[x] = cnt;
    } else {
      if (op[0] == 'T') {
        addEdge(A, (cur[x] = ++cnt), 0);
      } else if (op[0] == 'F') {
        addEdge(B, (cur[x] = ++cnt), 0);
      } else {
        addEdge(C, (cur[x] = ++cnt), 0);
      }
    }
  }
  assert(cnt == n + m);
  cnt += 3;
  For(i, 1, n) addEdge(cur[i], i, 0);
  For(i, 1, cnt) if (!vis[i]) {
    while (!st.empty())
      st.pop();
    ok = 0;
    cycle.eb();
    dfs(i, i);
    assert(ok);
    calc();
  }
  int ans = 0;
  For(i, 1, n) { ans += val[i] == 3; } // 末值被染成 U
  cout << ans << endl;
}
il void Main() {
  int c, T;
  freopen("tribool.in", "r", stdin);
  freopen("tribool.out", "w", stdout);
  read(c, T);
  while (T--)
    solve();
}
```

---


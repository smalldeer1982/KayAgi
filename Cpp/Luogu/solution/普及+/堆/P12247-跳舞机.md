# 跳舞机

## 题目描述

小 O 想要经营电 van 城，跳舞机的运营非常重要。

小 O 的电 van 城有一台跳舞机，跳舞机在同一时间**至多有一名玩家游玩**，每局游戏需要完整且连续地游玩 $k$ 分钟。

电 van 城将营业 $m$ 分钟。期间有 $n$ 名玩家想要游玩跳舞机，编号 $1\sim n$。编号为 $i$ 的玩家会在营业的第 $l_i$ 分钟到第 $r_i$ 分钟（包括 $l_i$ 和 $r_i$）待在电 van 城，在此期间可以游玩任意局跳舞机。并且，每游玩一局，会产生 $w_i$ 的兴奋值。注意，如果玩家 $i$ 要玩一局跳舞机，则每局游戏的 $k$ 分钟必须完全包含于玩家的停留时间 $[l_i,r_i]$。

小 O 想要最大化所有玩家的兴奋值之和，请你帮他求出最大的兴奋值之和。

## 说明/提示

#### 样例 #1 解释

可以让编号为 $1$ 的玩家在第 $1\sim2$ 分钟、第 $3\sim 4$ 分钟玩一局跳舞机，编号为 $3$ 的玩家在第 $5\sim 6$ 分钟玩一局。兴奋值的总和为 $1+1+3=5$，可以发现没有让兴奋值总和更大的方案。 

#### 样例 #2 解释

可以让编号为 $2$ 的玩家在第 $2\sim4$ 分钟玩一局跳舞机，编号为 $3$ 的玩家在第 $5\sim 7$ 分钟玩一局。兴奋值的总和为 $4+5=9$，可以发现没有让兴奋值总和更大的方案。

### 数据范围

对于所有数据，满足：

- $1\le n,m,k\le 5\times 10^5$
；
- $k\le m$；
- $1\le l_i\le r_i\le m$；
- $1\le w_i\le 10^9$。

设 $L_i=r_i-l_i+1$，则具体测试点限制如下：

| 测试点编号 | $n$ 的范围 | $m$ 的范围 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $n\le 5$ | $m\le 10$ | $w_i\le 20$ |
| $4\sim 6$ | $n\le 10^5$ | $m\le 10^5$ |  $L_i=k=1$ |
| $7\sim10$ | $n\le 1000$ | $m\le 1000$ |  无 |
| $11\sim 13$ | $n\le 10^5$ | $m\le 10^5$ | $L_i=k$ |
| $14\sim 16$ | $n\le 100$ | $m\le 10^5$ | 无 |
| $17\sim 20$ | $n\le 10^5$ | $m\le 10^5$ | $w_i=1$ |
| $21,22$ | $n\le 10^5$ | $m\le 10^5$ | 无 |
| $23\sim 25$ | $n\le 5\times 10^5$ | $m\le 5\times 10^5$ | 无 |




## 样例 #1

### 输入

```
3 6 2
1 5 1
5 6 2
5 6 3
```

### 输出

```
5```

## 样例 #2

### 输入

```
4 7 3
1 7 1
2 5 4
4 7 5
1 2 10```

### 输出

```
9```

# 题解

## 作者：CuteChat (赞：25)

## 题解

题解中出现的超纲算法仅助于理解，忽略这些句段不影响阅读。

考虑对于时间轴从小到大进行动态规划，令 $f_i$ 表示在 $[1,i]$ 这个时间段，安排跳舞机使用情况可以得到的最大收益。

显然有初始状态 $f_0=0$，对于 $1\le i\le n$，$f_i$ 将会有以下几种转移：

- $f_i=f_{i-1}$，表示让跳舞机在 $(i-1,i]$ 这一段时间处于空闲状态，那么答案也就从上一个时间转移过来。
- 当 $i\ge k$ 的时候，额外有转移 $f_i=f_{i-k}+W$，其中 $\displaystyle W=\max_{[i-k+1,i]\subseteq[l_j,r_j]} w_j$，表示让跳舞机在 $[i-k+1,i]$ 选择一个玩家进行游玩。

为什么第二条是对的呢？可以发现一个玩家上台进行游玩的充分必要条件就是 $[i-k+1,i]$ 这一段时间是这个玩家的空余时间的子集，也就是 $i-k+1 \ge l_i$ 并且 $i\le r_i$。

那我们还有一个结论，我们一定会优先选择获得收益最高的玩家让他来游玩跳舞机。这个非常显然，用屁股都能想到。并且这个结论是对的，我们只关心我们获得的收益，而不是谁在游玩。

因此此算法正确性正确，我们得到了一个 $O(nm)$ 的做法。

那么我们就需要解决的就是查询能包含 $[i-k+1,i]$ 这个区间的收益最大值。首先能想到的可能是树套树来做二维偏序，因此我们就有了一个 $O(m \log^2 n)$ 的做法。

这并不优秀。但是我们注意到我们动态规划的顺序是从小到大进行的，那么，我们可以维护一个全新的数据结构，不妨把这个数据结构叫做 $S$，在当前动态规划进行到 $i$ 时，把所有左端点为 $i-k+1$ 的玩家加入这个数据结构。

此时就会发现我们的式子简洁了许多，因为我们不需要关心 $i-k+1 \ge l_j$ 这个限制了。这恰好就类似于扫描线的思想。

但是 $i\le r_j$ 仍需要考虑，因此我们的数据结构可能还需要支持删除的操作。

来想一想我们需要求什么，我们要求的是最大值，那么我们能不能用优先队列（堆）来做这个事情呢？

每一次求解我们只需要关心最大值是否合法就可以了，因此在动态将玩家加入堆的过程之后，也就是要求解我们需要的 $W$ 值，只需要判断堆顶的限制是否满足即可，如果不满足，就删除后再看最大值即可。

也许有人有疑问了，因为我们的数据结构中可能会有不合法的玩家没有被移出这个数据结构，但是这并不重要，只要我们的最大值合法就行，就算有不合法的玩家在这个数据结构中，这个玩家总有一次会被删除，即使不被删除也不会成为最大值，不会影响我们的求解。

这个操作很类似于对顶堆的操作。

时间复杂度是对的吗？这个同样非常显然，每一个玩家最多加入一次、删除一次，有点像单调队列的分析方式，因此时间复杂度 $O(m \log n+n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, k;
long long dp[500005];
vector<pair<int, int>> qj[500005];

signed main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= n; ++i) {
		int l, r, w;
		cin >> l >> r >> w;
		if (l + k - 1 <= r)
		qj[l + k - 1].push_back({r, w});
	}
	dp[0] = 0;
	priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> s;
	for (int i = 1; i <= m; ++i) {
		dp[i] = dp[i - 1];
		for (auto j : qj[i]) {
			s.push({-j.second, j.first});
		}
		while (!s.empty() && s.top().second < i) s.pop(); // 删除不合法的，也就是这个玩家已经离开了游戏厅
		if (!s.empty()) dp[i] = max(dp[i], dp[i - k] - s.top().first);
	}
	cout << dp[m] << "\n";
}
```

### 挑战最优解

此内容非题解主要内容。

1. 将 `vector` 替换成链式前向星。
2. 手写堆。
3. 使用快读。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Heap {
	pair<int, int> hp[500001];
	int tot = 0;

	inline void push(pair<int, int> x) {
		hp[++tot] = x;
		int i = tot;
		while (i > 1 && hp[i] < hp[i >> 1]) {
			swap(hp[i], hp[i >> 1]);
			i >>= 1;
		}
	}
	inline void pop() {
		int i = 1;
		swap(hp[i], hp[tot--]);
		while ((i << 1) <= tot) {
			int pos = i << 1;
			if (pos + 1 <= tot && hp[pos + 1] < hp[pos]) ++pos;
			if (hp[i] > hp[pos]) {
				swap(hp[i], hp[pos]);
				i = pos;
			} else return;
		}
	}
} s;

int n, m, k, nxt[500005], head[500005], cntt;
pair<int, int> to[500005];
long long dp[500005];

void add(int a, pair<int, int> b) {
	nxt[++cntt] = head[a];
	head[a] = cntt;
	to[cntt] = b;
}
namespace fastio
{
	const int bufl=1<<20;
	struct IN{
		FILE *IT=stdin;char ibuf[bufl],*is=ibuf,*it=ibuf;
		inline char getChar(){if(is==it){it=(is=ibuf)+fread(ibuf,1,bufl,IT);if(is==it)return EOF;}return *is++;}
		IN& operator>>(int &a){a=0;int b=0,c=getChar();while(c<48||c>57)b^=(c==45),c=getChar();while(c>=48&&c<=57)a=(a<<1)+(a<<3)+c-48,c=getChar();if(b)a=-a;return *this;}
	} fin;
}
#define cin fastio::fin
signed main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= n; ++i) {
		int l, r, w;
		cin >> l >> r >> w;
		if (l + k - 1 <= r) add(l + k - 1, {r, w});
	}
	dp[0] = 0;
	for (int i = 1; i <= m; ++i) {
		dp[i] = dp[i - 1];
		while (head[i]) {
			s.push({-to[head[i]].second, to[head[i]].first});
			head[i] = nxt[head[i]];
		}
		while (s.tot && s.hp[1].second < i) s.pop();
		if (s.tot) dp[i] = max(dp[i], dp[i - k] - s.hp[1].first);
	}
	cout << dp[m] << "\n";
}
```

最大的点跑了 $100$ 毫秒，应该是赛时最优解，或者是常数最小的正解。如果有疑问或者有更小常数的解法欢迎在评论中指出或者分享。

---

## 作者：Crasole (赞：15)

~~赛场上脑子成了浆糊，最后反而在语文课上顿悟了。~~

回归正题，我们首先会想到贪心，如果当前的跳舞机空了，就把能产生兴奋值最大的人放到跳舞机上，但是这样的思路在样例二上就是错的。

于是考虑动态规划，一个类似于背包的思路，用 $dp_i$ 表示当前第 $i$ 的时间所能最大化的兴奋值。

接着我们需要一个大根堆来维护当前还能游玩跳舞机中的人的兴奋值的最大值，我们设为 $res$，则转移就是 $dp_i = \max(dp_{i - 1}, dp_{i - k} + res)$。其中 $dp_{i - 1}$ 是一个能转移的值是因为当前时间可以没有人去玩跳舞机。

然后我们要考虑的事情就是如何找到当前场上还有哪些人能玩跳舞机，因为玩一次跳舞机的时间是 $k$，当前时间为 $i$，所以开始玩跳舞机的时间是 $i - k + 1$。所以对于一个人 $u$，他还能玩跳舞机仅当 $i - k + 1 \le l_u$ 且 $r_u \ge i$，所以每次取堆头，如果是合法的那么进行转移，否则将堆头弹出。

## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e5 + 5;
int n, m, k;
int dp[N];
struct Node {
	int l, r, w;
	bool operator < (const Node& node) const  {
		if(l == node.l) return r < node.r;
		return l < node.l;
	}
} t[N];
priority_queue <pair <int, int>> q;

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
	cin >> n >> m >> k;
	for (int i = 1; i <= n; ++i) cin >> t[i].l >> t[i].r >> t[i].w;
	sort(t + 1, t + n + 1);
	int rt = 1;
    for (int i = 1; i <= m; ++i) {
        dp[i] = dp[i - 1];
//将满足条件的人加入到堆里
        while(rt <= n && t[rt].l + k - 1 <= i) {
            q.emplace(t[rt].w, rt), ++ rt;
        }
        while(q.size()) {
            auto p = q.top();
            int u = p.second;
            int res = p.first;
//判断是否合法
            if(t[u].r < i) q.pop();
            else if(i - k + 1 < t[u].l) q.pop();
            else {
                int pos = i - k;
                dp[i] = max(dp[i], dp[pos] + res);
                break;
            }
        }
    }
    cout << dp[m] << '\n';
	return 0;
}
```

---

## 作者：_determination_ (赞：9)

前置私货。

欢迎关注本题出题人[呕象](https://www.luogu.com.cn/user/565742)！

欢迎加入[呕象粉丝团](https://www.luogu.com.cn/team/72518)和报名[呕象生日比赛](https://www.luogu.com.cn/contest/240812)！还拥有丰富的奖金可以获得！

---
听说呕象的 std 是线段树优化 dp，但是这个线段树明显是多余的。

这个值域这么小明显是让你对着值域 dp 啊，考虑设 $f_x$ 为 $x$ 的时间能获得的最大收益。那么只要游玩区间包含 $[x-k+1,k]$ 的人都可以贡献收益，取 $\max$ 就好。

这样我们得到了 $O(nm)$ 的做法，但是显然过不去。考虑一个人在哪段区间会有贡献，这个区间显然是 $[l+k-1,r]$。直接对这个东西扫描线然后拿个数据结构支持插入删除求最小值即可，直接拍个可重集维护就好了。

```cpp
#include<bits/stdc++.h>
#define int long long
// #define endl '\n'
using namespace std;
const int mod=998244353,inf=0x3f3f3f3f3f3f3f3f;
const int N=5e5+10,M=2e5+10;
vector<int>fl[N],fr[N];
int n,m,k;
int f[N];
multiset<int>mx;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin >> n >> m >> k;
	for ( int i = 1 ; i <= n ; i++ )
	{
		int l,r,w;cin >> l >> r >> w;
		if(l+k-1>r)continue;
		fl[l+k-1].push_back(w);
		fr[r+1].push_back(w);
	}
	for ( int i = 1 ; i <= m ; i++ )
	{
		// cerr << i << endl;
		for ( auto x:fl[i] )
			mx.insert(x);
		// cerr << i << endl;
		for ( auto x:fr[i] )
			mx.erase(mx.find(x));
		// cerr << i << endl;
		if(mx.empty())f[i]=f[i-1];
		else f[i]=max(f[i-1],f[i-k]+
			(*prev(mx.end())));
	}
	cout << f[m];
	return 0;
}
```

---

## 作者：ZinfI_Sh (赞：6)

*写于 $\textit{2025.4.19}$，若数据有加强，下述分值可能会不一致。*

读完题目呢，我们可以想到用 dp 做，那么让我们想一下怎么推这个 dp 式。

因为每一个时刻都**只能**有一个人游玩，所以很大概率是一个一维 dp 式 $dp_{i}=\max\{cost_{i}+dp_{j}\}$ 的大致形式，$i$ 跟时间有关。考虑到转移是通过一个时间转移过去的，那么可以考虑：$dp_{i}$ 表示以时刻 $i$ 为结尾游 ~~van~~ 玩的最大兴奋值。

那么，$cost_{i}$ 就表示了时刻 $i-k+1$ 到时刻 $i$ 某个人游玩所产生的最大贡献。为了最大化这个贡献，我们想到预处理出一个数组 $bs_{i}$，表示以第 $i$ 个时刻开始游玩的最大的兴奋值，则 $bs_{i}=\displaystyle\max_{l_j\le i\text{ 且 }r_j\ge i+k-1}\{w_j\}$，就有：

$dp_{i}=\displaystyle\max_{0\le j\lt i-k+1}\{bs_{i-k+1}+dp_{j}\}$。

最后答案是 $\max\{dp_{i}\}$。

恭喜你，拿到了整整 $28$ 分。

```cpp
#include <bits/stdc++.h>
#define int long long
#define hint unsigned long long
#define lowbit(x) (x & -x)
using namespace std;
const int DM[8][2] = { 0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1 };
// const int HASHMOD = 9223372036854775783;
const int HASHMOD = 212370440130137957;
const int HASHBASE = 131;
const int HASHITEM = 1e7 + 3;
const int N = 500001;
int dp[N], bs[N], l[N], r[N], w[N];
signed main()
{
    int n, m, k;
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) {
        cin >> l[i] >> r[i] >> w[i];
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            bs[i] = max(bs[i], ((l[j] <= i) && (r[j] >= i + k - 1)) * w[j]);
        }
    }
    int ans = 0;
    for (int i = 1; i <= m; i++) {
        for (int j = 0; j < i - k + 1; j++) {
            dp[i] = max(dp[i], bs[i - k + 1] + dp[j]);
        }
        // cout << dp[i] << ' ';
        ans = max(ans, dp[i]);
    }
    // cout << '\n';
    cout << ans;
}
```

考虑优化。

首先，我们能发现 dp 式中只有 $dp_{j}$ 与 $i$ 无关，我们可以想到用单调队列的思想进行第一步优化：记录一个 $mx$，枚举到 $i$ 时令 $mx=\max\{mx,\max\{0,dp_{i-k}\}\}$，转移时直接将 $dp_{j}$ 写成 $mx$ 即可。

```cpp
int ans = 0, maxx = 0;
for (int i = 1; i <= m; i++) {
    maxx = max(maxx, max((int)0, dp[i - k]));
    dp[i] = max(dp[i], bs[i - k + 1] + maxx);
    ans = max(ans, dp[i]);
}
cout << ans;
```

其次，事实上预处理 $bs$ 的过程可以先枚举玩家 $i$，然后对 $bs_{l_i}\sim bs_{r_i-k+1}$ 进行赋值，这样子，你就可以拿到 $88$ 分的高分！

```cpp
#include <bits/stdc++.h>
#define int long long
#define hint unsigned long long
#define lowbit(x) (x & -x)
using namespace std;
const int DM[8][2] = { 0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1 };
// const int HASHMOD = 9223372036854775783;
const int HASHMOD = 212370440130137957;
const int HASHBASE = 131;
const int HASHITEM = 1e7 + 3;
const int N = 500001;
int dp[N], bs[N], l[N], r[N], w[N];
signed main()
{
    int n, m, k;
    scanf("%Ld%Ld%Ld", &n, &m, &k);
    for (int i = 1; i <= n; i++) {
        scanf("%Ld%Ld%Ld", &l[i], &r[i], &w[i]);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = l[i]; j <= r[i] - k + 1; j++) {
            bs[j] = max(bs[j], w[i]);
        }
    }
    int ans = 0, maxx = 0;
    for (int i = 1; i <= m; i++) {
        maxx = max(maxx, max((int)0, dp[i - k]));
        dp[i] = max(dp[i], bs[i - k + 1] + maxx);
        ans = max(ans, dp[i]);
    }
    cout << ans;
}
```

转移的地方已经极限了，那么只能优化预处理了：预处理部分是个**区间取 $\max$** 的操作，可以使用线段树优化，但是这里选择使用更快的**并查集**优化。

注意到这个操作十分像[这道题](https://www.luogu.com.cn/problem/P1840)，我们便把 $n$ 个玩家对 $bs$ 的贡献抽象成 $n$ 次对序列的操作，每次操作是一个三元组 $(l,r,v)$，表示让所有 $bs_{i(l\le i\le r)}=\max\{bs_{i},v\}$，那么根据暴力代码可以得出第 $i$ 个玩家的操作就是 $(l_{i},r_{i}-k+1,w_i)$。

我们把 $n$ 个操作按 $v$ 降序排序，此时容易发现，被覆盖的位置在之后就**一定不被覆盖**，所以我们用 $i$ 从 $1$ 枚举到 $n$，对于第 $i$ 个操作，用 $p$ 从 $l_i$ 开始跳指针，具体的思想，就是把被覆盖的区间的左端点指向右端点 $+1$ 所指向的位置，那么后续所覆盖的 $v$ 若跳到了这个左端点，它将直接**跳过这段被覆盖过的区间**。使用并查集维护这个操作，时间复杂度 $O(n\log n+m\alpha(m))$（$\alpha(m)$ 是反阿克曼函数，这里并查集使用了路径压缩的优化）。

不加快读 $1.17s$，加上快读（来自第一篇题解）并使用 c++14 能干到 $594ms$，压入最优解第 $4$ 页（来自 $2025$ 年 $4$ 月 $26$ 的数据）。

AC 代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define hint unsigned long long
#define lowbit(x) (x & -x)
using namespace std;

namespace fastio
{
    const int bufl = 1 << 20;
    struct IN
    {
        FILE *IT = stdin;
        char ibuf[bufl], *is = ibuf, *it = ibuf;
        inline char getChar()
        {
            if (is == it)
            {
                it = (is = ibuf) + fread(ibuf, 1, bufl, IT);
                if (is == it)
                    return EOF;
            }
            return *is++;
        }
        IN &operator>>(int &a)
        {
            a = 0;
            int b = 0, c = getChar();
            while (c < 48 || c > 57)
                b ^= (c == 45), c = getChar();
            while (c >= 48 && c <= 57)
                a = (a << 1) + (a << 3) + c - 48, c = getChar();
            if (b)
                a = -a;
            return *this;
        }
    } fin;
}
#define cin fastio::fin

const int DM[8][2] = {0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};
// const int HASHMOD = 9223372036854775783;
const int HASHMOD = 212370440130137957;
const int HASHBASE = 131;
const int HASHITEM = 1e7 + 3;
const int N = 500001;
int dp[N], bs[N], l[N], r[N], w[N];
int fa[N + 5];
int find(int x)
{
    if (fa[x] != x)
    {
        fa[x] = find(fa[x]);
    }
    return fa[x];
}
void merge(int x, int y)
{
    x = find(x), y = find(y);
    fa[x] = y;
}
struct Opt
{
    int l, r, v;
} op[N];
bool cmp(Opt x, Opt y)
{
    return x.v > y.v;
}
signed main()
{
    int n, m, k;
    // scanf("%Ld%Ld%Ld", &n, &m, &k);
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
    {
        // scanf("%Ld%Ld%Ld", &l[i], &r[i], &w[i]);
        cin >> l[i] >> r[i] >> w[i];
        op[i] = {l[i], r[i] - k + 1, w[i]};
    }
    for (int i = 1; i <= m + 2; i++)
    {
        fa[i] = i;
    }
    sort(op + 1, op + n + 1, cmp);
    for (int i = 1; i <= n; i++)
    {
        int p = find(op[i].l);
        // cout << "  " << op[i].l << ' ' << op[i].r << ' ' << p << '\n';
        while (p <= op[i].r)
        {
            bs[p] = op[i].v;
            // cout << p << ' ' << op[i].r << '\n';
            merge(p, p + 1);
            p = find(p);
            // cout << "check\n";
            // getchar();
        }
    }
    int ans = 0, maxx = 0;
    for (int i = 1; i <= m; i++)
    {
        maxx = max(maxx, max((int)0, dp[i - k]));
        dp[i] = max(dp[i], bs[max((int)0, i - k + 1)] + maxx);
        // dp[i] = max(dp[i], query(1, 0, m, i - k + 1) + maxx);
        ans = max(ans, dp[i]);
    }
    // cout << ans;
    printf("%Ld", ans);
}
```

---

## 作者：Lysea (赞：5)

### Solution

提供一个 STL 含量极高的做法。

看到这种限制条件多的题目，基本是 dp 没错了。

令 $f_i$ 表示到时刻 $i$ 结束时 $\sum w$ 的最大值，考虑 $i$ 时刻跳舞机的状态：

- 无人使用。

- 有人使用，且不为某次游玩最后一刻。

- 某次游玩结束的那一刻。

对于 $i$ 时刻，第二种决策永远比第一种决策劣。

因为只有最后一刻才能够结算 $w$ 的贡献，所以第二种决策相当于从某次游玩开始到 $i$ 时刻无人使用。而第一种决策只是 $i$ 时刻无人使用，显然包含了第二种决策。

因此我们只用考虑第一种和第三种决策，那么就有：

$$f_i=\max_{1\le k\le i-m}\{f_{i-1},f_{k}+\max\limits_{i-m+1\le l_j\le r_j\le i}\{w_j\}\}$$

从 $f_{i-1}$ 转移过来代表 $i$ 时刻无人游玩，从 $f_{k}+\max\{w_j\}$ 转移过来代表 $i$ 时刻为某次游玩结束的那一刻。

下面考虑如何维护，较简单的是 $f_k$，直接用一个变量维护即可。

至于 $f_k$ 后面这坨，我们发现对于每个 $w_j$，其可能造成贡献的时间段都是一段区间。那么我们可以把 $w_j$ 进入和踢出决策集合的时刻标记下来，利用堆和懒惰删除轻松维护。

总体时间复杂度 $O(n\log n)$，常数极大。

个人认为代码挺好懂的。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005
using namespace std;
int n,m,k,dp[N],mx;
vector<int>v1[N],v2[N];
priority_queue<int>q;
map<int,int>out;
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>k;
    for(int i=1,l,r,w;i<=n;i++){
        cin>>l>>r>>w;
        if(r-l+1<k) continue;
        v1[l+k-1].push_back(w);
        v2[r+1].push_back(w);
    }
    for(int i=k;i<=m;i++){
        for(int v:v1[i]) q.push(v);
        for(int v:v2[i]) out[v]++;
        while(!q.empty()&&out[q.top()])
            out[q.top()]--,q.pop();
        dp[i]=max(dp[i-1],mx+(q.empty()?0ll:q.top()));
        mx=max(mx,dp[i-k+1]);
    }
    cout<<dp[m];
	return 0;
}
```

---

## 作者：shuqiang (赞：5)

你如果学过线段树，这就是一道很简单的题。

考虑 dp，设第 $i$ 秒可以获得的最大兴奋值为 $f_i$，转移有两种情况：

- 跳舞机给了一个人跳舞，$f_{i-k}+w$，显然，要给在此时间区间内兴奋值最大的人玩跳舞机。
- 跳舞机是空闲的，$f_{i-1}$。

$f_i$ 取两者最大值。

转移时求 $w$ 可以用线段树，一个人可以在区间 $[l+k-1,r]$ 的时间内玩完跳舞机，所以实现一个区间修改，单点查询的线段树即可。


```cpp
#include<iostream>

using namespace std;

const int N = 5e5 + 10;
int n, m, k, mx[N*4], l[N], r[N], w[N], _ = 100;
long long f[N], ans;

void build(int u, int l, int r){
	if(l == r) return;
	int mid = (l + r) / 2;
	build(u*2, l, mid);
	build(u*2+1, mid+1, r);
}

void update(int u, int l, int r, int L, int R, int W){
	if(L <= l && r <= R){
//		cout << "upd: [" << l << ',' << r << "] to " << W << '\n';
		mx[u] = max(mx[u], W);
		return;
	}
	mx[u*2] = max(mx[u*2], mx[u]);
	mx[u*2+1] = max(mx[u*2+1], mx[u]);
	int mid = (l + r) / 2;
	if(L <= mid) update(u*2, l, mid, L, R, W);
	if(mid < R) update(u*2+1, mid+1, r, L, R, W);
}

int query(int u, int l, int r, int X){
//	if(l == r) cout << "chk[" << l << ',' << r << "] is " << mx[u] << '\n';
	if(l == r) return mx[u];
	mx[u*2] = max(mx[u*2], mx[u]);
	mx[u*2+1] = max(mx[u*2+1], mx[u]);
	int mid = (l + r) / 2;
	if(X <= mid) return query(u*2, l, mid, X);
	else return query(u*2+1, mid+1, r, X);
}


int main(){
	cin >> n >> m >> k;
	for(int i = 1; i <= n; i++){
		cin >> l[i] >> r[i] >> w[i];
//		cout << l[i]+k-1 << ' ' << r[i] << '\n';
		if(l[i]+k-1 <= r[i]) update(1, 1, m, l[i]+k-1, r[i], w[i]);
	}
//	for(int i = 1; i <= m; i++){
//		cout << query(1, 1, m, i) << ' ';
//	}
//	cout << '\n';
	for(int i = k; i <= m; i++) f[i] = max(f[i-1], f[i-k] + query(1, 1, m, i));
	cout << f[m];
	return 0;
} 
```

---

## 作者：水星湖 (赞：5)

显然考虑 dp，设 $f_i$ 表示 $i$ 时刻恰有一人玩完一局的最大兴奋值之和，有 $f_i = \max_{0\le j \le i-k} f_j + \max_{l_j\le i-k+1<i\le r_j} w_j$，直接做是 $\mathcal O(nm)$ 的。显然第一项可以记录 $f$ 的前缀最大值优化。考虑第二项，发现条件等价于 $l_j+k-1\le i\le r_j$, 于是可以提前对于每一个 $l_i,r_i,w_i$ 使用线段树在区间 $[l_i+k-1,r_i]$ 上和 $w_i$ 取最大值。线段树维护好之后每次就是单点查询最大值，时间复杂度 $\mathcal O((m+n)\log m)$。

---

## 作者：dongzirui0817 (赞：4)

## 前言

有意思的 T4，令人解了 $90$ 分钟。~~当然我是用小号打的。~~

## 思路

先考虑 $O(nm)$ 怎么做，可以 dp。

**状态**：设 $dp_i$ 为营业 $i$ 分钟时，兴奋值之和的最大值。

**初始化**：对于每一个满足 $0 \le i < k$ 的 $i$，$dp_i \gets 0$。

**转移**：

考虑两种情况：

- 不安排玩家游玩。
- 选一个能来得及游玩的玩家游玩。

于是得到转移方程：

$$
dp_i = \max(dp_{i - 1}, \, dp_{i - k} + \max_{j = 1} ^ n f(i, \, j) \times w_j)
$$

其中，$f(i , \, j) = \begin {cases}
  1 & l_j \le i - k + 1 \land i \le r_j \\
  0 & \text{otherwise}
\end {cases}
$

**答案**：$dp_m$。

这样，你就可以获得 $40$ 分~~的好成绩~~。

但不难发现，$\max_{j = 1} ^ n f(i, \, j) \times w_j$ 是可以优化的。因为只要对满足 $f(i, \, j) = 1$ 的 $w_j$ 取最大值即可。

这可以用单调队列，本题解用 set。

- - -

设集合 $S$ 表示第 $i$ 时刻还来得及游玩一次的玩家编号。

那么每一个时刻 $i$，把第 $i - k + 1$ 分钟到达电 van 城的玩家的兴奋值加入集合 $S$。然后把第 $i - 1$ 分钟离开电 van 城的玩家的编号从 $S$ 中移除。

这种方式可以保证满足 $l_j \le i - k + 1$ 的玩家 $j$，其兴奋值均加入过集合 $S$，且其他玩家的兴奋值均未加入。

最后，设 $u$ 为集合 $S$ 中最大的元素，转移方程改为：
$$
dp_i = \max(dp_{i - 1}, \, dp_{i - k} + u)
$$

## 实现

可以用 vector 记下玩家进入和离开的时间，用 set 统计集合 $S$。

时间复杂度 $O(n \log n)$，用单调队列也是 $O(n \log n)$，因为单调队列开始要排序。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, k;
long long dp[500010];
vector <int> e[500010][2];
multiset <int> S;

int main() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1 ; i <= n ; i++) {
		int l, r, w;
		scanf("%d%d%d", &l, &r, &w);
		if (r - l + 1 >= k)
			e[l][0].push_back(w),
			e[r][1].push_back(w);
	}
	for (int i = 1 ; i <= m ; i++) {
		if (i >= k)
			for (auto y : e[i - k + 1][0]) S.insert(y);
		for (auto y : e[i - 1][1]) S.erase(S.find(y));
		if (!S.empty())
			dp[i] = max(dp[i - 1], dp[i - k] + *S.rbegin());
		else dp[i] = dp[i - 1];
	}
	printf("%lld\n", dp[m]);
	return 0;
}
```

---

## 作者：HHC883 (赞：4)

# 题目分析
考虑 DP。设计状态 $dp_i$ 表示前 $i$ 分钟能获得的最大兴奋值之和，定义 $maxn_i$ 为某个玩家玩一局从 $i - k + 1$ 分钟到 $i$ 分钟的游戏所能获得的最大兴奋值（其实就是所有停留时间包含 $[i - k + 1 , i]$ 的玩家当中最大的 $w$）。那么有状态转移方程
$$dp_i = \max(dp_{i-1} , dp_{i - k} + maxn_i)$$
现在考虑如何计算 $maxn_i$。注意到对于某个玩家 $i$，其停留时间 $[l_i , r_i]$ 包含的所有长度等于 $k$ 的区间都可以作为一局，这些区间能获得的最大值都应该被更新为与 $w_i$ 取最大值。而这些区间就是所有的右端点在区间 $[l_i + k - 1 , r_i]$ 的长度为 $k$ 的区间（可能说的比较绕，自己理解一下即可），所以可以对于所有的 $l_i + k - 1 \le j \le r_i$，更新 $maxn_j = \max(maxn_j,w_i)$。这怎么实现呢？用线段树是显然可以的，但考虑到离线，其实完全没有必要用线段树，毕竟“杀鸡焉用牛刀”。我们可以使用堆来实现，但更简单的方法是用 STL 中的 multiset。如果是区间加，我们会用差分。而我们要区间对同一数取最大值，于是想到借鉴差分的思路，在 $l_i + k - 1$ 处开一个 vector 名为 add，加入 $w_i$，表示处理到这里的时候往 multiset 中加入 $w_i$；在 $r_i + 1$ 处开一个 vector 名为 del，加入 $w_i$，表示处理到这里的时候删除 multiset 中的**一个** $w_i$。然后利用 multiset 的自动排序特性，直接取出其中的最后一个数，就得到到了 $maxn_j$。

时间复杂度瓶颈在于 multiset 的操作，时间复杂度为 $O(n \log n)$。
# 参考代码
```cpp
#include<iostream>
#include<vector>
#include<set>
#define int long long
using namespace std;
int n,m,k;
int l[(int)5e5+5],r[(int)5e5+5],w[(int)5e5+5];
vector<int> add[(int)5e5+5],del[(int)5e5+5];
multiset<int> s;
int dp[(int)5e5+5];
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>l[i]>>r[i]>>w[i];
	for(int i=1;i<=n;i++){
		if(l[i]+k-1<=r[i]){
			add[l[i]+k-1].push_back(w[i]);
			del[r[i]+1].push_back(w[i]);
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=0;j<add[i].size();j++) s.insert(add[i][j]);
		for(int j=0;j<del[i].size();j++) s.erase(s.find(del[i][j]));
		dp[i]=dp[i-1];
		if(i>=k&&!s.empty()) dp[i]=max(dp[i],dp[i-k]+*prev(s.end()));
	}
	cout<<dp[m];
	return 0;
}
```

---

## 作者：corner_xiejunqi (赞：2)

### 题目分析：
我们需要在营业时间内安人玩排跳舞机游戏，使得玩家的总兴奋值之和最大。且题目有以下要求：
- 每局游戏需连续占用 $k$ 分钟，且必须完全包含在玩家的停留时间段内。
- 同一时间只能有一局游戏进行。
- 玩家可多次游玩，每次产生固定兴奋值 $w_i$。

很容易看出这是一道动态规划。那么我们就可以预处理可以去玩的玩家，若玩家停留时间 $r_i-l_i+1<k$，那么他就无法玩游戏，直接忽略。对其他有效玩家，其可安排游戏的时间段为 $l_i$ 到 $r_i-k+1$ 内的每个起始点。

这样处理之后将每个玩家的有效时间段视为两个事件：
  - **添加事件**：在时间 $l_i+k-1$ 时，将 $w_i$ 加入准备游戏的名单中。
  - **移除事件**：在时间 $r_i+1$ 时，将 $w_i$ 移出准备游戏的名单。
    
然后将事件按时间排序。之后，该如何维护当前最大兴奋值呢？

可以建立一个大根堆快速获取当前最大 $w_i$。然后记录每个权重的出现次数，处理移除事件时减少计数，堆顶无效时弹出。最后找出时间段，即遍历事件，将连续时间段 $ptime$ 到 $now-1$ 与当前最大兴奋值一起存入动态数组，形成多个时间段区间。

最后就可以开始动态规划了。$dp[i]$ 表示到时间 $i$ 为止的最大兴奋值。令 $maxn$ 为当前时间段的最大兴奋值。那么我们就有两种状态：
  - **不安排游戏**：$dp[i]=dp[i-1]$。
  - **安排游戏**：若 $i\geq k$，则 $dp[i]=dp[i-k]+maxn$。

遍历将它筛出来即可。
### 代码如下：

```cpp

#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
struct node{
	int time,w;
	bool is_add;
}event[N];
bool cmp(node a,node b){
	if(a.time!=b.time) return a.time<b.time;
	else return a.is_add>b.is_add; 
} 
int n,m,k,tot=0;
vector<tuple<int,int,int>> ins;
map<int,int> count1;
priority_queue<int> q;
int maxn=0,ptime=0;
signed main(){
	// step 1、读题、声明变量
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	// step 2、输入
	cin>>n>>m>>k;
	for(int i=1,l,r,w;i<=n;i++){
		cin>>l>>r>>w;
		int a=l+k-1,b=r;
		if(a>b) continue;
		event[++tot]={a,w,true};
		event[++tot]={b+1,w,false};
	}
	// step 3、处理
	sort(event+1,event+1+tot,cmp);
	for(int i=1;i<=tot;){
		int now=event[i].time;
		if(ptime<now){
			if(ptime<=m){
				int e=min(now-1,m);
			    if(ptime<=e) ins.emplace_back(ptime,e,maxn);
			}
			ptime=now;
		}
		while(i<=tot && event[i].time==now){
			node e=event[i];
			if(e.is_add){
				count1[e.w]++;
				q.push(e.w);
			}else count1[e.w]--;
			i++;
		}
		while(!q.empty()){
			int now=q.top();
			if(count1[now]>0){
				maxn=now;
				break;
			}else q.pop();
		}
		if(q.empty()) maxn=0;
	}
	if(ptime<=m) ins.emplace_back(ptime,m,maxn);
	vector<long long> dp(m+1,0);
	int nowe=0;
	for(auto now:ins){
		int s=get<0>(now);
		int e=get<1>(now);
		int w=get<2>(now);
		if(s>m) break;
		if(s==0) s=1;
		for(int i=s;i<=e;i++){
			if(i>m) break;
			long long o1=dp[i-1],o2=0;
			if(i>=k) o2=dp[i-k]+w;
			dp[i]=max(o1,o2);
		}
	}
	// step 4、输出
	cout<<dp[m];
	return 0;
}
```

---

## 作者：Ascnbeta (赞：2)

## 简要的题解：

发现没有后效性，考虑 dp。

设 $f_i$ 表示前 $i$ 分钟能得到的最大兴奋值（包括 $i$），状态转移方程如下：
$$
f_i=\max^{i-k+1}_{j=0}\left(f_j+\max^{n}_{id=1}[l_{id}\le j+1][r_{id}\ge j+k]\times w_{id}\right)
$$
$[]$ 是艾弗森括号。后面那一坨的意思就是，从所有满足在店时间在 $[j+1,j+k]$ 内的人中选出最大的 $w$ 加到 $f_j$ 上。最后取 $\max$ 即可。

第二个 $\max$ 可以使用线段树离线求出，前面这个 $\max$ 用优先队列维护即可，复杂度 $O(n\log n)$。

## 详细说明：

题意不难理解。

注意题目有点恶心的地方在于，区间长度是 $r_i-l_i+1$，并非 $r_i-l_i$，可以从第二个样例看出。

同时如果这个时刻作为了一局游戏结束点，则他就不能作为新一局游戏的开始点。

发现没有后效性，考虑 dp。

设 $f_i$ 表示前 $i$ 分钟能得到的最大兴奋值（包括 $i$），状态转移方程如下：
$$
f_i=\max^{i-k+1}_{j=0}\left(f_j+\max^{n}_{id=1}[l_{id}\le j+1][r_{id}\ge j+k]\times w_{id}\right)
$$
$[]$ 是艾弗森括号。

这一串的意思就是，我们先考虑 $i$ 怎么转移。我们可以选择之前的任何一个时刻 $j$，然后在 $j+1$ 时刻开始一局游戏。显然，我们要选在店时间符合条件的最大的 $w$。后面那一坨的意思就是，从所有满足在店时间在 $[j+1,j+k]$ 内的人中选出最大的 $w$ 加到 $f_j$ 上。最后取 $\max$ 即可。

然而朴素枚举转移是 $O(m^2n)$ 的。

我们先考虑后面那一大坨怎么优化，它实质上就是我们要找出在 $j+1$ 时刻开始游戏并且能在离店前打完的人中，选出最大的 $w$。这个问题可以这么转化：

> 开始序列全为 $0$，我们有 $n$ 次区间操作，每次将 $[l,r]$ 区间内的数变为 $\max(a_i,w)$。
>
> 最后输出操作结束后每个位置上的值。

乍一看这不是区间最值么，难道要上吉司机？

冷静，我们要的是最后结果，离线就行了。

所以我们按照 $w$ 给每次操作从大到小排序，这样一个位置的值一旦被赋上去，就不可能再被后面的更新。线段树维护区间最大值 $val$ 和区间已经确定的值个数 $cnt$。参考代码：

```cpp
inline void modify(int p,int v,int s,int e,int l,int r) {
    if (cnt[p] == r - l + 1) return;//这个子区间的数都赋过值，直接返回
    if (s <= l && r <= e) {
        val[p] = max(val[p],v);//其实可以改为如果是0（初始值）就赋值，否则不用管
        tag[p] = max(v,tag[p]);//区间操作要打tag
        return;
    }
    int mid = (l + r) >> 1;
    if (l != r && tag[p]) pushdown(p,l,r);
    if (s <= mid) modify(ls,v,s,e,l,mid);
    if (e > mid) modify(rs,v,s,e,mid+1,r);
    pushup(p);
}
```

`pushdown`：

```cpp
inline void pushdown(int p,int l,int r) {
    int mid = (l + r) >> 1;
    if (cnt[ls] != mid - l + 1) val[ls] = max(val[ls],tag[p]),cnt[ls] = mid - l + 1,tag[ls] = max(tag[ls],tag[p]);//别忘了如果区间都赋过值就没必要下传tag
    if (cnt[rs] != r - mid) val[rs] = max(val[rs],tag[p]),cnt[rs] = r - mid,tag[rs] = max(tag[rs],tag[p]);
    tag[p] = 0;
}
```

单点查询：

```cpp
inline int query(int p,int pos,int l,int r) {
    if (l == r) {
        return val[p];
    }
    int mid = (l + r) >> 1;
    if (l != r && tag[p]) pushdown(p,l,r);
    if (pos <= mid) return query(ls,pos,l,mid);
    else return query(rs,pos,mid+1,r);
}
```

这样我们把读入的区间照如上处理，这样转移的时候就可以 $O(\log n)$ 查询。

注意的是我们每个点上维护的是从这个时间开始**并能够完成游戏**的 $w$ 的最大值，所以每个人给的 $[l_i,r_i]$ 实际有用的只有 $[l_i,r_i-k+1]$（$+1$ 的原因见开始），所以修改的区间应该是后者，如果 $l_i>r_i-k+1$，则这个人不会有任何用处（在店时间都不够打一局），直接跳过。

```cpp
for (int i = 1; i <= n; i++) {
    cin >> p[i].l >> p[i].r >> p[i].w;
    p[i].r -= k-1;
}
sort(p+1,p+n+1);
for (int i = 1; i <= n; i++) {
    if (p[i].l > p[i].r) continue;
    modify(1,p[i].w,p[i].l,p[i].r,1,m);//注意值域是m不是n
}
```

然后我们在考虑状态转移方程前面那个 $\max$。我们发现，一旦求出了 $f_j$ 则 $f_j$ 连着后面这一堆东西都是不变的，我们没必要反复求。所以我们每次遍历到 $i$ 时，我们就把 $f_{i-k}+\max^{n}_{id=1}[l_{id}\le i-k+1][r_{id}\ge i]\times w_{id}$ 这一坨扔进大根堆，转移直接取堆顶的值即可。

```cpp
for (int i = 1; i <= m; i++) {
    if (i >= k) {
        q.push(f[i-k]+query(1,i-k+1,1,m));
    }
    q.push(f[i-1]);
    if (!q.empty()) f[i] = q.top();
}
```

答案就是 $f_m$。

完整代码：（别忘了 `long long`）

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls p<<1
#define rs p<<1|1
using namespace std;
const int maxn = 5e5+20;
int n,m,k;
int val[maxn<<2],tag[maxn<<2],cnt[maxn<<2];
struct line{
    int l,r,w;
    bool operator < (const line &y) const {
        return w > y.w;
    }
}p[maxn];
inline void pushup(int p) {
    val[p] = max(val[ls],val[rs]);
    cnt[p] = cnt[ls] + cnt[rs];
}
inline void pushdown(int p,int l,int r) {
    int mid = (l + r) >> 1;
    if (cnt[ls] != mid - l + 1) val[ls] = max(val[ls],tag[p]),cnt[ls] = mid - l + 1,tag[ls] = max(tag[ls],tag[p]);
    if (cnt[rs] != r - mid) val[rs] = max(val[rs],tag[p]),cnt[rs] = r - mid,tag[rs] = max(tag[rs],tag[p]);
    tag[p] = 0;
}
inline void modify(int p,int v,int s,int e,int l,int r) {
    if (cnt[p] == r - l + 1) return;
    if (s <= l && r <= e) {
        val[p] = max(val[p],v);
        tag[p] = max(v,tag[p]);
        return;
    }
    int mid = (l + r) >> 1;
    if (l != r && tag[p]) pushdown(p,l,r);
    if (s <= mid) modify(ls,v,s,e,l,mid);
    if (e > mid) modify(rs,v,s,e,mid+1,r);
    pushup(p);
}
inline int query(int p,int pos,int l,int r) {
    if (l == r) {
        return val[p];
    }
    int mid = (l + r) >> 1;
    if (l != r && tag[p]) pushdown(p,l,r);
    if (pos <= mid) return query(ls,pos,l,mid);
    else return query(rs,pos,mid+1,r);
}
int f[maxn];
priority_queue<int> q;
signed main() {
#ifdef LOCAL
    freopen("D:/codes/exe/a.in","r",stdin);
    freopen("D:/codes/exe/a.out","w",stdout);
#endif
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) {
        cin >> p[i].l >> p[i].r >> p[i].w;
        p[i].r -= k-1;
    }
    sort(p+1,p+n+1);
    for (int i = 1; i <= n; i++) {
        if (p[i].l > p[i].r) continue;
        modify(1,p[i].w,p[i].l,p[i].r,1,m);
    }
    for (int i = 1; i <= m; i++) {
        if (i >= k) {
            q.push(f[i-k]+query(1,i-k+1,1,m));
        }
        q.push(f[i-1]);
        if (!q.empty()) f[i] = q.top();
    }
    // for (int i = 1; i <= m; i++) {
    //     cout << query(1,i,1,m) << ' ';
    // }
    // cout << '\n';
    // for (int i = 1; i <= m; i++) {
    //     cout << f[i] << ' ';
    // }
    // cout << '\n';
    cout << f[m] << '\n';
    return 0;
}
```

---

## 作者：冷却心 (赞：2)

全场首 A 报到一下。

定义状态 $f_i$ 表示在时间 $i$ 以内最高可获得的代价。

那么我们有两种转移。

- 当前不动，$f_i \gets f_{i-1}$。
- 选一个人跳舞，显然这个人如果能在当前位置跳一次舞，需要满足 $l\le i-k+1 \wedge r \ge i$。所以对于任意满足这个条件的 $j$，$f_i \gets f_{i-k}+w_j$。即
$$f_i\gets f_{i-k} + \max_{1\le j\le n \wedge l_j\leq i-k+1 \wedge r_j \ge i} w_j.$$

这样直接做时间复杂度 $\mathcal O(nm)$。第一种转移显然 $\mathcal O(1)$，考虑快速维护第二种转移中取 $\max$ 的人的价值集合，我们记它为 $S$。那么对于一个人 $j$，我们只需要在 $l+k-1$ 时刻把 $w_j$ 加入集合，$r+1$ 的位置把 $w_j$ 从集合中删去即可，这个可以用一个 `vector` 实现。然后要求这个集合支持取 $\max$。显然可删堆用 `multiset` 或者 `priority_queue` 随便维护一下就好了。时间复杂度 $O(m \log n)$。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 5e5 + 10;
int n, m, K;
vector<int> add[N], del[N];
LL DP[N];
int main() {
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> m >> K;
	for (int a, b, c, i = 1; i <= n; i ++) {
		cin >> a >> b >> c;
		if (a + K - 1 > b) continue;
		add[a + K - 1].emplace_back(c); del[b + 1].emplace_back(c);
	} multiset<int> cur;
	for (int i = 1; i <= m; i ++) {
		DP[i] = DP[i - 1];
		for (int x : add[i]) cur.insert(x);
		for (int x : del[i]) cur.erase(cur.find(x));
		if (!cur.empty()) DP[i] = max(DP[i], DP[i - K] + *cur.rbegin());
	} cout << DP[m] << "\n";
	return 0;
}
```

---

## 作者：未来姚班zyl (赞：2)

- 注：本题虽然正解形式简单，代码简短，但对于普及组选手，需要一定的思维能力和经验积累才能做出此题，且对于思考的过程，带有许多合适的部分分。

考察贪心、简单动态规划、stl 库的数据结构应用。

考虑设 $dp_i$ 表示前 $i$ 分钟的答案。那么对于所有可以在 $[i-k+1,i]$ 期间玩一次跳舞机的玩家，他们的 $l$ 与 $r$ 与当前决策无关，所以取最大的 $w$ 一定最优，设这个最大的 $w$ 为 $W_i$，则 $dp_i=\max(dp_{i-1},dp_{i-k}+W_i)$。

考虑求出所有 $W_i$。枚举玩家 $i$，显然其对 $j\in [l_i+k-1,r_i]$ 的 $W_j$ 有贡献。

问题转换为，有 $n$ 个数，每个数覆盖了一个区间，求每个位置的数的最大值。

我们考虑维护一个可重集 $S$，从 $1$ 扫到 $m$，对于每个数 $w$ 和其覆盖的区间 $[l,r]$，在 $l$ 时将 $w$ 加入 $S$，在 $r+1$ 时将 $w$ 移出 $S$，同时支持查询 $S$ 中的最大值，使用 `std::map` 或者 `std::multiset` 维护即可。

如果没想到正解，可以得到贪心的部分分或者不包含数据结构的部分分。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=5e5+5;
int n,m,k;
ll dp[N];
struct node{
	int k,ty;
};
vector<node>p[N];
map<int,int>P;
inline void Main(){
	n=read(),m=read(),k=read();
	repn(i){
		int l=read()+k-1,r=read(),w=read();
		if(l<=r)p[l].pb({w,1}),p[r+1].pb({w,-1});
	}
	repm(i){
		for(auto y:p[i])if(y.ty==1)P[y.k]++;
		else {
			if(P[y.k]==1)P.erase(y.k);
			else P[y.k]--;
		}
		dp[i]=dp[i-1];
		if(!P.empty())dp[i]=max(dp[i],dp[i-k]+(*--P.end()).first);
	}
	cout <<dp[m];
}
signed main(){
    int T=1;
	while(T--)Main();
	return 0;
}


```

---

## 作者：The_foolishest_OIer (赞：1)

线段树优化 DP 板子。

令 $dp_i$ 表示前 $i$ 天能获得的最大兴奋值总和。

因为单次游玩的时间不变，所以第 $i$ 个状态只能从第 $i-1$ 个状态或者第 $i-k$ 个状态转移过来。

记 $m_i$ 表示在第 $i$ 个时刻能开始游戏的人中的最大兴奋值，有转移方程 $dp_i = \max(dp_{i-1},dp_{i-k}+m_i)$。

$m_i$ 是可以用线段树等数据结构维护的。

时间复杂度：$O(m + n \log m)$。

Code：[Link](https://www.luogu.com.cn/record/214367818)

---

## 作者：_O_v_O_ (赞：1)

我们令 $l_i\leftarrow l_i-k+1$，即令 $[l_i,r_i]$ 为这个人结束时间段。

我们设 $dp_i$ 为在第 $i$ 时间末尾，兴奋值之和的最大值，那么很显然，有转移 $dp_i=\max\{dp_{i-1},dp_{i-k}+res_i\}$，其中 $res_i$ 为第 $i$ 时刻某个人结束游玩的兴奋值最大值，即 $\max_{j=1}^n w_j[l_j\le i\le r_j]$。

那么如何维护 $res$ 呢？很显然这个东西相当于对 $[l_i,r_i]$ 区间对 $w_i$ 取 $\max$，最后单点查询，直接用标记永久化线段树即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e6+5;
int n,m,k;
int dp[N],res[N];
struct node{
	#define lid id<<1
	#define rid id<<1|1
	struct seg{
		int l,r;
		int twt;
	}tr[N<<2];
	void build(int id,int l,int r){
		tr[id].l=l,tr[id].r=r;
		if(l==r) return;
		int mid=tr[id].l+tr[id].r>>1;
		build(lid,l,mid),build(rid,mid+1,r);
	}
	void pls(int id,int l,int r,int w){
		if(l<=tr[id].l&&tr[id].r<=r){
			tr[id].twt=max(tr[id].twt,w);
			return;
		}
		int mid=tr[id].l+tr[id].r>>1;
		if(l<=mid) pls(lid,l,r,w);
		if(mid<r) pls(rid,l,r,w);
	}
	void bl(int id,int y){
		y=max(y,tr[id].twt);
		if(tr[id].l==tr[id].r){
			res[tr[id].l]=y;
			return;
		}
		int mid=tr[id].l+tr[id].r>>1;
		bl(lid,y),bl(rid,y);
	}
}tr;

signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m>>k;
	tr.build(1,1,m);
	for(int i=1;i<=n;i++){
		int l,r,w;cin>>l>>r>>w;
		if(l+k-1>r) continue;
		tr.pls(1,l+k-1,r,w);
	}
	tr.bl(1,0);
	for(int i=1;i<=m;i++){
//		cout<<res[i]<<' ';
		dp[i]=max(dp[i-1],dp[i-k]+res[i]);
	}
	cout<<dp[m];
	return 0;
}
```

---

## 作者：Mier_Samuelle (赞：1)

### 45 pts

不难想到 dp。

定义状态 $dp_i$ 表示，前 $i$ 分钟兴奋值之和的最大值。

转移时枚举玩家 $j$，转移方程为：

$$\begin{cases}dp_i \leftarrow \min(dp_i,dp_{i-1}) \\ dp_i \leftarrow \min(dp_i,dp_{i-k}+w_j) & l_j \le i-k+1\;\mathrm{and}\;i \le r_j\end{cases}$$

直接转移的复杂度为 $O(n^2)$（视 $n,m$ 同阶），期望得分 $45$。

### 100 pts

考虑如何优化转移，容易想到使用优先队列。

先将玩家按 $l_i$ 升序排列。

每次转移前，将当前满足条件的玩家出队，并将不满足条件的玩家出队，之后选择当前队首，即 $w_i$ 最大的玩家，进行转移即可。

复杂度 $O(n \log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 5e5 + 10;
struct Node{
    int l, r, w;
}a[MAXN];
bool cmp(Node x, Node y){
	return x.l < y.l;
}
int dp[MAXN];
priority_queue <pair<int, int>> q;
signed main(){
    ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    for (int i = 1;i <= n;i++) cin >> a[i].l >> a[i].r >> a[i].w;
    sort(a + 1, a + n + 1, cmp);
    int cur = 1;
    for (int i = 1;i <= m;i++){
        dp[i] = dp[i - 1];
        while (cur <= n && a[cur].l <= i - k + 1){
            if (a[cur].r >= i) q.push({a[cur].w, a[cur].r});
            cur++;
        }
        while (!q.empty() && q.top().second < i) q.pop();
        if (i >= k && !q.empty()) dp[i] = max(dp[i], dp[i - k] + q.top().first);
    }
    cout << dp[m] << endl;
    return 0;
}
```

---

## 作者：P2441M (赞：1)

## 题意
电玩城里有一台跳舞机，跳舞机在同一时间**至多有一名玩家游玩**，每局游戏需要完整且连续地游玩 $k$ 分钟。电玩城营业 $m$ 分钟，期间有 $n$ 名玩家想要玩跳舞机，第 $i$ 名玩家会在营业的 $[l_i,r_i]$ 时刻内待在电玩城，在此期间可以游玩任意局跳舞机。每游玩一局，会产生 $w_i$ 的兴奋值。最大化所有玩家的兴奋值之和。$1\leq n,m,k\leq 5\times 10^5$。

## 题解
考虑 DP。令 $f_i$ 表示 $[1,i]$ 时刻内能获得的最大兴奋值。转移考虑可以这一局不玩，或者枚举所有可以在 $[i-k+1,i]$ 玩一局跳舞机的玩家，即
$$
f_i=\max\left(f_{i-1},\max_{l_j\leq i-k+1\land r_j\geq i}\{f_{i-k}+w_j\}\right)
$$
这样就得到了 $\mathcal{O}(nm)$ 的暴力 DP。

考虑优化。注意到
$$
\max_{l_j\leq i-k+1\land r_j\geq i}\{f_{i-k}+w_j\}=f_{i-k}+\max_{l_j\leq i-k+1\land r_j\geq i}\{w_j\}
$$
而 $\max_{l_j\leq i-k+1\land r_j\geq i}\{w_j\}$ 是显然的 $\text{2-side}$ 矩形的形式，扫描线优化即可。具体来说，按 $r$ 从大到小排序，树状数组维护前缀最大值。视 $n,m$ 同阶，时间复杂度 $\mathcal{O}(n\log{n})$。

## 代码
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 5e5 + 5;

int n, m, k;
ll f[N], g[N];

struct Pt {
	int l, r, w;
	bool operator<(const Pt &x) const { return r > x.r; }
} p[N];
struct BIT {
	int c[N];
	inline int query(int x) {
		int res = 0;
		for (; x; x -= lowbit(x)) chk_max(res, c[x]);
		return res;
	}
	inline void change(int x, int v) { for (; x <= m; x += lowbit(x)) chk_max(c[x], v); }
} ft;

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m >> k;
    for (int i = 1; i <= n; ++i) cin >> p[i].l >> p[i].r >> p[i].w;
    sort(p + 1, p + n + 1);
    for (int i = m, j = 1; i >= k; --i) {
    	while (j <= n && p[j].r >= i) ft.change(p[j].l, p[j].w), ++j;
    	g[i] = ft.query(i - k + 1);
    }
    for (int i = 1; i <= m; ++i) {
        f[i] = f[i - 1];
        if (i >= k) chk_max(f[i], f[i - k] + g[i]);
    }
    cout << f[m];
    return 0;
}
```

---

## 作者：ziyanlin2013 (赞：1)

# 题解：P12247 跳舞机

[题目传送门](https://www.luogu.com.cn/problem/P12247)  

# 题面
电玩城有一台跳舞机，跳舞机在同一时间**至多有一名玩家游玩**，每局游戏需要完整且连续地游玩 $k$ 分钟。

电玩城将营业 $m$ 分钟。期间有 $n$ 名玩家想要游玩跳舞机，编号 $1\sim n$。编号为 $i$ 的玩家会在营业的第 $l_i$ 分钟到第 $r_i$ 分钟（包括 $l_i$ 和 $r_i$）待在电玩城，在此期间可以游玩任意局跳舞机。并且，每游玩一局，会产生 $w_i$ 的兴奋值。

最大化所有玩家兴奋值之和。

# 解题思路
考虑到 $n$ 和 $m$ 同阶，所以可以计 $f_i$ 表示前 $i$ 分钟最多产生**兴奋值之和**。

转移分情况讨论：

1. 第 $i$ 分钟**是**一局游戏的最后一分钟，那么 $f_i\gets f_{i-k}+val_i$，$val_i$ 表示**结束时间**为 $i$ 的一局游戏最多能获得多少兴奋值。
2. 第 $i$ 分钟**不是**一局游戏的最后一分钟，那么 $f_i\gets f_{i-1}$。

两种情况取最大值即可，接下来考虑如何求 $val_i$。

对于第 $i$ 位玩家，他的游戏时间结束的时刻必定在 $[l_i+k-1,r_i]$ 之内，所以令 $val_j=\min(val_j,w_i)$，其中 $j\in [l_i+k-1,r_i]$。

那么，就需要用一个可以**区间取最大值**和**单点查询**的数据结构，用线段树维护即可。

复杂度 $O(m\log m)$。

# 代码
似乎比标程快耶~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=5e5+5;
int n,m,k;
int l[N],r[N];
ll w[N];
vector<pair<int,int> > e[N];
ll f[N];
int tree[N<<2],tag[N<<2];
void push_up(int p){
	tree[p]=max(tree[p<<1],tree[p<<1|1]);
}
void push_down(int p){
	tree[p<<1]=max(tree[p<<1],tag[p]);
	tree[p<<1|1]=max(tree[p<<1|1],tag[p]);
	tag[p<<1]=max(tag[p<<1],tag[p]);
	tag[p<<1|1]=max(tag[p<<1|1],tag[p]);
	tag[p]=0;
}
void update(int p,int pl,int pr,int l,int r,int w){
	if(l<=pl&&pr<=r){
		tree[p]=max(tree[p],w);
		tag[p]=max(tag[p],w);
		return;
	}
	int mid=(pl+pr)>>1;
	push_down(p);
	if(mid>=l) update(p<<1,pl,mid,l,r,w);
	if(mid+1<=r) update(p<<1|1,mid+1,pr,l,r,w);
	push_up(p);
}
int query(int p,int pl,int pr,int id){
	if(pl==pr){
		return tree[p];
	}
	int mid=(pl+pr)>>1;
	push_down(p);
	if(mid>=id) return query(p<<1,pl,mid,id);
	else return query(p<<1|1,mid+1,pr,id);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>k;
	for (int i=1;i<=n;i++){
		cin>>l[i]>>r[i]>>w[i];
		if(l[i]+k-1<=r[i]) update(1,1,m,l[i]+k-1,r[i],w[i]);
	}
	for (int i=k;i<=m;i++) f[i]=max(f[i-1],f[i-k]+query(1,1,m,i));
	cout<<f[m];
	return 0;
}
```

---

## 作者：lw393 (赞：1)

做法：线段树加上 dp。

显而易见的吧，我们直接给出 dp 转移方程：

$$f_i = \max(f_{i-k}+\max_{i\in [l_j, r_j - k + 1]} w_j,f_{i-1})$$

解释一下，就是在第 $i$ 分钟时所能得到的最大兴奋值是第 $i-1$ 分钟得到的最大兴奋值或第 $i-k$ 分钟得到的最大兴奋值加上这段时间能跳舞的兴奋值中最大的那个。

而我们可以利用线段树来求转移式子中的第二个 $\max$。就是做一个区间修改，单点查询的操作就好了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
#define int long long

struct node{
  int l, r;
  int maxn, tag;
}tree[N << 2];
#define lc (k * 2)
#define rc (k * 2 + 1)
#define mid (tree[k].l + tree[k].r >> 1)

void pushup(int k) { tree[k].maxn = max(tree[lc].maxn, tree[rc].maxn); }
void add_tag(int k, int v) { tree[k].maxn = max(tree[k].maxn, v); tree[k].tag = max(tree[k].tag, v); }
void pushdown(int k) { if(tree[k].tag) { add_tag(lc, tree[k].tag), add_tag(rc, tree[k].tag); tree[k].tag = 0; } }

void build(int k, int l, int r){
  tree[k].l = l, tree[k].r = r;
  if(l == r) return;
  build(lc, l, mid), build(rc, mid + 1, r);
}

void modify(int k, int l, int r, int v){
  if(tree[k].l >= l && tree[k].r <= r) { add_tag(k, v); return; }
  pushdown(k);
  if(r <= mid) modify(lc, l, r, v);
  else if(l > mid) modify(rc, l, r, v);
  else modify(lc, l, mid, v), modify(rc, mid + 1, r, v);
  pushup(k);
}

int query(int k, int x){
  if(tree[k].l == tree[k].r) return tree[k].maxn;
  pushdown(k);
  if(x <= mid) return query(lc, x);
  else return query(rc, x);
}

int dp[N];

void solve(){
  int n, m, k;
  cin >> n >> m >> k;
  build(1, 1, m);
  for(int i = 1; i <= n; i++){
    int l, r, w;
    cin >> l >> r >> w;
    r = r - k + 1;
    if(r >= l) modify(1, l, r, w);
  }
  for(int i = 1; i <= m; i++){
    dp[i] = dp[i - 1];
    if(i >= k) dp[i] = max(dp[i], dp[i - k] + query(1, i - k + 1));
  }
  cout << dp[m] << '\n';
}

signed main(){
  int t = 1;
  //cin >> t;
  while(t--){
      solve();
  }
  return 0;
}
```

---

## 作者：yrwhsw (赞：1)

考虑 dp，设 $f_i$ 表示当前为时刻 $i$，能获得的最大价值。考虑转移：

如果这个时刻不安排游玩，则有 $f_{i-1}\to f_i$。

否则有 $f_{i-k} + w_i\to f_i$，$w_i$ 表示让 $[i-k+1,i]$ 这段时间有人游玩能获得的最大价值。由于 $k$ 固定，对于每个人 $[l_j,r_j]$，在 $i\in [l_j+k-1,r_j]$ 时，这个人可以被考虑。容易发现这是一个区间取 $\max$ 的形式，用线段树预处理一下即可。总时间复杂度 $O((n+m)\log m)$。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int inf=1e18;
bool M1;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=5e5+5;
struct tree{
	int mx;
}t[N<<2];
int n,m,k;
int f[N];
#define ls p<<1
#define rs p<<1|1
void ckmx(int p,int L,int R,int l,int r,int w){
	if(l>r)return;
	if(l<=L&&R<=r){
		t[p].mx=max(t[p].mx,w);return;
	}
	int mid=(L+R)>>1;
	if(l<=mid)ckmx(ls,L,mid,l,r,w);
	if(r>mid)ckmx(rs,mid+1,R,l,r,w); 
} 
int ask(int p,int L,int R,int pos){
	if(L==R)return t[p].mx;
	int mid=(L+R)>>1;
	if(pos<=mid)return max(t[p].mx,ask(ls,L,mid,pos));
	else return max(t[p].mx,ask(rs,mid+1,R,pos));
}
bool M2;
signed main(){
	n=read();m=read();k=read();
	for(int i=1;i<=n;i++){
		int l,r,w;l=read();r=read();w=read();
		ckmx(1,1,m,l+k-1,r,w);
	}int mx=0;
	for(int i=1;i<=m;i++){
		f[i]=f[i-1];
		if(i>=k)f[i]=max(f[i],f[i-k]+ask(1,1,m,i));
		mx=max(mx,f[i]);
	}
	cout<<mx<<'\n';
	return 0;
}


```

---

## 作者：SuperCowHorse (赞：0)

简单 dp。

设 $f_i$ 表示第 $i$ 分钟最多获得的兴奋值，很显然，$f_i=\max\{f_{i-1},f_{i-k}+w\}$，其中 $w$ 表示在 $(i-k,i]$ 区间内可以玩跳舞机的玩家，这样答案就是 $f_m$。复杂度 $O(nm)$。

发现求 $w$ 可以用贪心，这样我们直接维护一个优先队列，记录每位玩家的 $w_i$，每次取队头，看看队头可不可以游玩。如果不行直接 $\operatorname{pop}$ 即可。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=5e5+5;
int n,m,k;
struct node{int l,r;ll w;}a[maxn];
inline bool cmp(node u,node v){return u.l==v.l?u.r<v.r:u.l<v.l;}
ll f[maxn];
priority_queue<pair<ll,int>>q;int now=1;
inline ll o(int x){
    for(int i=now;i<=n;++i){
        if(a[i].l>a[i].r) continue;
        if(a[i].l<=x) q.push({a[i].w,i});
        else{now=i;break;}
    }
    ll ans=0;
    while(!q.empty()){
        if(a[q.top().second].r<x) q.pop();//不能玩了就 pop
        else break;
    }
    if(!q.empty()){
        ans=q.top().first;
    }
    return ans;
}
inline void solve(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;++i){
        scanf("%d%d%lld",&a[i].l,&a[i].r,&a[i].w);
        a[i].r-=k-1;
    }
    sort(a+1,a+1+n,cmp);
    f[0]=0;
    for(int i=k;i<=m;++i){
        f[i]=max(f[i-1],f[i-k]+o(i-k+1));
    }
    printf("%lld\n",f[m]);
}
signed main(){
    int T=1;for(;T;--T) solve();
    system("pause");
    return 0;
}
```

---

## 作者：YBa2Cu3O7 (赞：0)

线段树+动态规划

## 思路
读入的同时检查有没有可能玩上至少一次，**注意进入时间等于歇业时间也是有可能玩一次的**。存在可能性再更新线段树。

这里用到的线段树是一个最大值线段树，维护整个营业时间内每个区间内**玩家在当前区间内恰玩完一局所得到**的最大兴奋值，因为涉及到了区间修改所以用到了懒标记。

假设玩家数据是进入 $a$，离开 $b$，兴奋值 $c$，那么先检查是否在歇业前进入，然后检查有可能玩完一局区间 $[a+k-1,b]$ 是否存在，最后这个区间就是线段树要更新的区间，兴奋值 $c$ 是要更新的值。

做完全部更新，可以从线段树中得到整个营业时间内每个时刻可能得到的最大兴奋值 $w[t]$，这可以看作单点最大收益。假设前 $t$ 个时刻能获得的最大总收益为 $dp[t]$。

因为只能有一个玩家在玩，所以在超过一局游戏的时长 $k$ 后，如果第 $t$ 个时刻上一个玩家刚好玩完，那么前 $t$ 个时刻的总收益就等于 $dp[t-k]+w[t]$。而如果没有，总收益就等于前一时刻的 $dp[t-1]$。我们可以在 $t$ 时刻选择是否有玩家刚好玩完，取其中的最大值，综合起来得到递推式
$$
 dp[t] = \begin{cases}
0, & t< k \\
\max(dp[t - 1], dp[t - k] + w[t]),  & t\ge k
\end{cases}
$$
第一部分全为零是因为在 $t<k$ 时一定没有玩家玩完一局游戏。
## 代码
个人习惯是用链式结构的线段树，并且存储的区间范围是**左闭右开**的。代码里面的 `max_w` 就是正文中的 $w[t]$。

```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
struct node {
	int l, r;
	T max_val;
	T lazy;
	node<T>* left;
    node<T>* right;
	node(int l, int r) : l(l), r(r), max_val(0), lazy(0), left(nullptr), right(nullptr) {}
};

template<typename T>
class SegmentTree {
private:
    node<T>* root;

    void push_down(node<T>* nd) {
        if (nd->lazy == 0) return;
        if (nd->left) {
            nd->left->max_val = max(nd->left->max_val, nd->lazy);
            nd->left->lazy = max(nd->left->lazy, nd->lazy);
        }
        if (nd->right) {
            nd->right->max_val = max(nd->right->max_val, nd->lazy);
            nd->right->lazy = max(nd->right->lazy, nd->lazy);
        }
        nd->lazy = 0;
    }

    void updateRange(node<T>* nd, int a, int b, T val) {
        if (nd->r <= a || nd->l >= b) return;
        if (a <= nd->l && nd->r <= b) {
            nd->max_val = max(nd->max_val, val);
            nd->lazy = max(nd->lazy, val);
            return;
        }
        push_down(nd);
        updateRange(nd->left, a, b, val);
        updateRange(nd->right, a, b, val);
        nd->max_val = max(nd->left->max_val, nd->right->max_val);
    }

    T query(node<T>* nd, int t) {
        if (nd->l + 1 == nd->r) {
            return nd->max_val;
        }
        push_down(nd);
        int mid = (nd->l + nd->r) / 2;
        if (t < mid) {
            return query(nd->left, t);
        }
        else {
            return query(nd->right, t);
        }
            
    }

    node<T>* buildTree(int l, int r) {
        auto nd = new node<T>(l, r);
        if (l + 1 == r) return nd;
        int mid = l + (r - l) / 2;
        nd->left = buildTree(l, mid);
        nd->right = buildTree(mid, r);
        return nd;
    }

public:
    SegmentTree(int m) {
        root = buildTree(0, m);
    }

    void update(int a, int b, T val) {
        updateRange(root, a, b, val);
    }

    T query(int t) {
        return query(root, t);
    }
};

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    SegmentTree<long long> st(m + 1);

    for (int i = 0; i < n; ++i) {
        array<int, 3> tmp;
        cin >> tmp[0] >> tmp[1] >> tmp[2];
        if (tmp[0] <= m) {
            tmp[1] = min(tmp[1], m);
            if (tmp[1] - tmp[0] + 1 >= k) {
                st.update(tmp[0] + k - 1, tmp[1] + 1, tmp[2]);
            }
        }
    }

    vector<int> max_w(m + 1);
    for (int t = 1; t <= m; ++t) {
        max_w[t] = st.query(t);
    }

    vector<long long> dp(m + 1, 0);
    for (int t = 1; t <= m; ++t) {
        dp[t] = dp[t - 1];
        if (t >= k) {
            dp[t] = max(dp[t], dp[t - k] + max_w[t]);
        }
    }
    cout << dp[m];

    return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

考虑 DP 求解。

状态 $f_i$ 表示营业到 $i$ 时刻的答案。

转移：从前一时刻转移或者玩一次，即 $f_i=\max(f_{i-1},f_{i-k}+\max\limits_{j=1}^{n}w_i\times [l_j\le i-k+1]\times [i\le r_j])$。

答案：显然是 $f_m$。

初始状态：$f_0=0$。

考虑优化：每个人的兴奋值贡献是在一段时间内的，所以转移可以用权值线段树优化。

时间复杂度 $O((n+m)\log W)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N=5e5+2;
int n,m,k,root,tot;
long long dp[N];
vector<int>add[N],rem[N];
struct SegmentTreeNode{
    int l,r,ls,rs,cnt;
    SegmentTreeNode(int l=0,int r=0,int ls=0,int rs=0,int cnt=0)
        :l(l),r(r),ls(ls),rs(rs),cnt(cnt){}
}f[N*32];
void pushup(int cur){
    f[cur].cnt=0;
    if(f[cur].ls)
        f[cur].cnt+=f[f[cur].ls].cnt;
    if(f[cur].rs)
        f[cur].cnt+=f[f[cur].rs].cnt;
    return;
}
void build(int l,int r,int&cur){
    f[cur=(++tot)]=SegmentTreeNode(l,r,0,0,0);
    return;
}
void modify(int pos,int val,int l,int r,int&cur){
    if(!cur)
        f[cur=(++tot)]=SegmentTreeNode(l,r,0,0,0);
    if(f[cur].l==f[cur].r){
        f[cur].cnt+=val;
        return;
    }
    int mid=(f[cur].l+f[cur].r)>>1;
    if(pos<=mid)
        modify(pos,val,l,mid,f[cur].ls);
    else
        modify(pos,val,mid+1,r,f[cur].rs);
    return pushup(cur);
}
int query(int cur){
    if(cur==root&&!f[cur].cnt)
        return-1;
    if(f[cur].l==f[cur].r)
        return f[cur].l;
    if(f[cur].rs&&f[f[cur].rs].cnt)
        return query(f[cur].rs);
    else
        return query(f[cur].ls);
}
signed main(){
    cin>>n>>m>>k;
    for(int i=1,l,r,w;i<=n;i++){
        cin>>l>>r>>w;
        if(l+k-1>r+1)
            continue;
        add[l+k-1].push_back(w);
        rem[r+1].push_back(w);
    }
    build(1,1000000000,root);
    for(int i=k,val;i<=m;i++){
        for(auto p:add[i])
            modify(p,1,1,1000000000,root);
        for(auto p:rem[i])
            modify(p,-1,1,1000000000,root);
        val=query(root),dp[i]=dp[i-1];
        if(val!=-1)
            dp[i]=max(dp[i],dp[i-k]+val);
    }
    cout<<dp[m];
    return 0;
}
```

---


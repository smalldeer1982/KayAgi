# 钓鱼

## 题目描述

话说发源于小朋友精心设计的游戏被电脑组的童鞋们藐杀之后非常不爽，为了表示安慰和鼓励，VIP999 决定请他吃一次“年年大丰收”，为了表示诚意，他还决定亲自去钓鱼。

但是，因为还要准备 NOIP2013, z 老师只给了他 $H$ 个小时的空余时间，假设有 $n$ 个鱼塘都在一条水平路边，从左边到右编号为 $1,2,3\dots n$ 。

VIP 是个很讲究效率的孩子，他希望用这些时间钓到尽量多的鱼。他从湖 $1$ 出发，向右走，有选择的在一些湖边停留一定的时间钓鱼，最后在某一个湖边结束钓鱼。他测出从第 $i$ 个湖到 $i+1$ 个湖需要走 $5 \times t_i$ 分钟的路，还测出在第 $i$ 个湖边停留，第一个 $5$ 分钟可以钓到鱼 $f_i$，以后再每钓 $5$ 分钟鱼，鱼量减少 $d_i$。为了简化问题，他假定没有其他人钓鱼，也不会有其他因素影响他钓到期望数量的鱼。请编程求出能钓最多鱼的数量。

## 说明/提示

数据范围：$1\le H \le 16,2\le n \le 25,1\le f_i\le 200,0\le d_i\le 20,1\le t_i\le 20$。

## 样例 #1

### 输入

```
2
1
10 1
2 5
2
```

### 输出

```
31```

# 题解

## 作者：Sky_Art (赞：30)

//于2019.10.11修改，代码可AC
# 朴素贪心

##### 没有什么新算法

##### 也没有用优先队列，线段树bulabula


------------


@ __扶苏__

被大佬骂次品题解了啊 QAQ

所以改一下


------------


思路：

###   枚举终点，贪的是以i为终点的区间中，当前时间最大的鱼数

1. 先算出以每个点为终点的路程时间和（前缀和），从而排除前往其它

      鱼塘的时间的影响（相当于在1到当前点可以随便钓了）


1. 判断该时间点 1到终点的最大 f[i]，时间加五，sum加上

1. 将f[i]减上相应的d值，判断时间是否超出，f[i]是否过小

1. 更新ans

### 代码

```c
#include<bits/stdc++.h>
using namespace std;
int m,n,sum,t[1000],ans=-1,bj,b[1000],t1;
struct s
{
	int f,d,ti;
}a[1000];

void init()
{

	sum=0;
	for(int i=1;i<=n;i++)
	b[i]=a[i].f;//便于修改当前的鱼数
}
int find(int j)//用来找当前最大的值
{
	int c=-1,bj;
	for(int i=j;i>=1;i--)
	if(c<b[i]) c=b[i],bj=i;//更新最大值
	return bj;
}

int main()
{
	scanf("%d%d",&n,&m);
	m=m*60; //小时转分钟
	for(int i=1;i<=n;i++) scanf("%d",&a[i].f);
	for(int i=1;i<=n;i++) scanf("%d",&a[i].d);
	for(int i=1;i<=n-1;i++) scanf("%d",&a[i].ti);
	for(int i=1;i<=n;i++) 
	t[i]=t[i-1]+a[i-1].ti*5;//计算走到该终点所需时间
	for(int i=1;i<=n;i++)   //^此时以排除路程的时间影响
	{
                t1=t[i];
		init();     //初值
		int j=i;         
		while(1)    //枚举终点
		{
			bj=find(j);   //找到当前f最大值
			if(b[bj]<=0) break;//鱼钓没了
			sum=sum+b[bj];
			b[bj]-=a[bj].d;
			t1+=5;        //时间更新
			if(t1+5>m) break;//时间用完了
		}
		ans=max(ans,sum);
	}
	printf("%d",ans);
}
```
QAQ毕竟我太弱了



---

## 作者：Cripple_Abyss (赞：23)

[题目传送门](https://www.luogu.com.cn/problem/P1717)

## 本题考察的算法: 枚举+贪心+优先队列
( 不知道优先队列的童鞋点[这里](https://blog.csdn.net/c20182030/article/details/70757660?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159178680019724846435146%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159178680019724846435146&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-70757660.first_rank_ecpm_v3_pc_rank_v4&utm_term=%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)QwQ

## 本题做法：
1. 将所有答案一 一列举出来，将其存进优先队列

1. 对每种情况进行枚举

1. 求出答案将其输出

# Code：
```cpp
#include<bits/stdc++.h>  //万能头，懒人必备QwQ 
using namespace std;
struct node {
	int s,d;
} a[35];
bool operator<(node a,node b) {  //重载运算符 
	return a.s<b.s;
}
priority_queue <node> q;  //优先队列 
int t[35],ans,maxn;
int main() {
	int n,h;
	cin>>n>>h;
	h*=60;  //注意一个是小时，一个是分钟 
	for (int i=1; i<=n; i++)
		cin>>a[i].s;
	for (int i=1; i<=n; i++)
		cin>>a[i].d;
	for (int i=1; i<n; i++)
		cin>>t[i];
	for (int i=1; i<=n; i++) {
		while (!q.empty())  //清空队列 
			q.pop(); 
		ans=0;  //ans值归零 
		int t1=h;
		for (int j=1; j<i; j++)  //枚举时间 
			t1-=t[j]*5;  
		for (int j=1; j<=i; j++)  //存入队列 
			q.push(a[j]);  
		while (t1>0&&q.top().s>0) {  //枚举所有可能 
			node v=q.top();
			ans+=v.s;
			q.pop();
			v.s-=v.d;
			q.push(v);
			t1-=5;  
		}
		maxn=max(ans,maxn);
	}
	cout<<maxn;  //输出 
	return 0;  //完美的结束QwQ 
}
```

都看到这了点个赞呗QwQ

---

## 作者：Priori_Incantatem (赞：21)

其实因为在每一个地方都可以钓无限久的鱼，所以是完全背包  
而又因为钓久了，鱼的数量就变成了负数了，所以又得当成多重背包做QAQ

跟多重背包不同的，这题每个池塘只能选一种钓鱼的时间长度，并不需要多重背包  
只需要做01背包，并再加一层循环枚举钓鱼的时间

设状态$f[i][j]$表示前$i$个池塘，时限为$j$，最多可以钓到多少鱼  

转移是，考虑该池塘钓不钓鱼  
不钓鱼：$f[i][j]=f[i-1][j-dis[i-1]]$  
钓鱼：枚举钓鱼的时间$k$ ，并用变量$tmp$记录鱼少了多少$f[i][j]=max(f[i][j],(f[i-1][j-dis[i-1]-k]+a[i]*(k/5)-tmp))$

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int Maxn=40,Maxm=1020,inf=0x3f3f3f3f;
int a[Maxn],d[Maxn],dis[Maxn],f[Maxn][Maxm];
int n,m,ans;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
int main()
{
	//freopen("in.txt","r",stdin);
	n=read(),m=read()*60;
	for(int i=1;i<=n;++i)
	a[i]=read();
	for(int i=1;i<=n;++i)
	d[i]=read();
	for(int i=1;i<n;++i)
	dis[i]=read()*5;
	for(int i=1;i<=n;++i)
	for(int j=0;j<=m;++j)
	f[i][j]=-inf;
	f[1][0]=0;
	for(int i=1;i<=n;++i)
	{
		for(int j=m;j>=dis[i-1];--j)
		{
			f[i][j]=f[i-1][j-dis[i-1]];
			int tmp=0;
			for(int k=5;k<=j;k+=5)
			{
				if(j-dis[i-1]-k<0)break;
				f[i][j]=max(f[i][j],(f[i-1][j-dis[i-1]-k]+a[i]*(k/5)-tmp));
				tmp+=(k/5)*d[i];
			}
		}
	}
	for(int i=1;i<=n;++i)
	for(int j=0;j<=m;++j)
	ans=max(ans,f[i][j]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Space_Gold_Trash (赞：20)

### 很简单的思路

## 1

首先，假设你已经到了二号湖泊钓鱼只有傻子才会又回到一号湖泊

比如说，最优解是在一号钓3次（3*5 分钟），二号湖泊钓5次

聪明人都会在一号钓完3次后再去二号钓五次

绝对不会一号湖泊钓2次，二号湖泊钓完再返回

所以我们只需枚举k，表示在1-k号湖泊钓鱼

只需减去行走时间就能看做是
DIO
钓鱼了

The World！！！时间，给我停止吧！！！！

## 2

那么怎么求出在一个湖泊钓几次呢？？

设1-k（k=5）号湖泊剩余的鱼如下：

剩下的鱼:||||||||||||| 5 7 8 9 6

掉一次减少的鱼||||1 3 2 3 4

很显然，钓四号湖泊最划算

因为钓的鱼多呀

那么钓完后
鱼就变成

5 7 8 6 6

同上，钓鱼就来三号湖

然后是

5 7 6 6 6

再是二号湖

5 4 6 6 6

只要还有时间钓鱼，就继续

## 那么代码如下

```
#include<bits/stdc++.h>
using namespace std;
int n,h,H;
struct Jack{
	int a,b,c,d;
}f[1100];
int main( ){
	std::ios::sync_with_stdio(false);
	cin>>n>>h;
	h*=12;
	int i,j,k,ans=0,sum=0,maxx;
	for(i=1;i<=n;i++)cin>>f[i].a;
	for(i=1;i<=n;i++)cin>>f[i].b;
	for(i=1;i<n;i++)cin>>f[i].c;
	for(k=1;k<=n;k++){
		for(i=1;i<=k;i++)f[i].d=f[i].a;
		h=h-f[k-1].c;
		H=h;
		if(h<0)break;
		sum=0;
		while(H--){
			maxx=0;
			for(i=1;i<=k;i++)
			if(maxx<f[i].d){
				j=i;
				maxx=f[i].d;
			}
			sum+=maxx;
			f[j].d=f[j].d-f[j].b;
		}
		ans=max(ans,sum);
	}
	cout<<ans<<endl;
}
```

我之所以写

```
if(h<0)break;
```

是因为丧心病狂的测试数据可能会是h为负数

那么

```
while(H--)
```

就变成一个死循环了

终于A了

![](https://cdn.luogu.com.cn/upload/pic/59703.png)

---

## 作者：loaky (赞：13)

优先队列的运用，贪心思想，重载小于符号，完美解决。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int maxn=50;
int n,h,sum,ans;
struct node{
    int f,d,t,id;
    bool operator <(node x)const{
        return f<x.f;
    }
}e[maxn*2];
priority_queue<node>q;
void cd(int ii,int ji){
	for(int i=ii;i<=ji;i++){
		q.push(e[i]);
	}
}
int main(){
	scanf("%d%d",&n,&h);
	h*=12;
	for(int i=1;i<=n;i++){
		scanf("%d",&e[i].f);
		e[i].id=i;
	}
	for(int i=1;i<=n;i++) scanf("%d",&e[i].d);
	for(int i=2;i<=n;i++){
		scanf("%d",&e[i].t);
		e[i].t+=e[i-1].t;
	}
	for(int j=1;j<=n;j++){
		int flag=h;
		flag-=e[j].t;
		cd(1,j);
		while(!q.empty()){
			if(flag-1<0){
				q.pop();
				continue;
			}
			else{
				flag--;
				node m=q.top();
				q.pop();
				sum+=m.f;
				if(m.f-m.d>0){
					m.f-=m.d;
					q.push(m);
				}
			}
		}
		ans=max(sum,ans);
		sum=0;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Randolph、 (赞：9)

## [P1717 钓鱼](https://www.luogu.org/problem/P1717)

贪心+堆的方法其他题解已经讲的很清楚了，这里放出萌新简洁的dp做法，如果有正确性问题希望大佬能够指出qwq

```cpp
#include<cstdio>
using namespace std;
#define max(a,b) (a>b ? a:b)
int n,m,ans,f[101][1001],a[101],b[101],t[101];
int main() {
	scanf("%d%d",&n,&m);
	m*=12;		//有（m*60/5）个五分钟
    
	for (int i=1; i<=n; i++) scanf("%d",&a[i]);
	for (int i=1; i<=n; i++) scanf("%d",&b[i]);
	for (int i=2; i<=n; i++) scanf("%d",&t[i]);		//t[i]：从i-1到i的路程时间

	//f[i][j]是走到第i个湖，时间为j的最多钓鱼数
    
	for (int i=1,tmp=t[1]; i<=n; tmp+=t[i+1],i++)	//tmp是从1到i的路程总用时
		for (int j=tmp; j<=m; j++){		//枚举到湖i的用时（至少是走到i的时间tmp）
			for (int k=0; k<=j-tmp; k++) 		//在i钓鱼的时间
				f[i][j]=max(f[i][j],f[i-1][j-t[i]-k]+max(0,k*a[i]-k*(k-1)/2*b[i]));
                //钓鱼数为a[i]*k-(1+2+3+...+(k-1))*b[i]
				ans=max(ans,f[i][j]);//更新答案
			}
	printf("%d",ans);
}
```


---

## 作者：Cesare (赞：9)

看到这题，贪心不会，考虑dp。

设$ f[i][j] $为佳佳经过前i个湖消耗j时间所获得的最多鱼数。

背包建模，开始dp。

他从哪里来？

从上一个湖那里来。

要到哪里去？

要到下一个湖去，或者在这个湖钓鱼。

于是得出dp方程：  $ f[i][j]=max( k*( p[i].num+p[i].num-p[i].reduce*( k-1 ) )/2+f[i-1][j-k] ) $

$ p[i].reduce[k] $表示鱼塘时间差，$ p[i].time $表示花费路程。

完成。

---

## 作者：Social_Zhao (赞：6)

思路：

这是一道**堆在贪心中的应用**的例题，当然用贪心来做。

既然是堆，我们先把它写上（自从某次用$STL$的优先队列$T$飞之后就只敢用手写堆了）

为什么要用堆等会再讲。

```cpp
template<typename T>
struct Priority_Queue {
	T heap[100005];
	int heap_size=0;
	T top() {
		return heap[1]; 
	}
	bool empty() {
		return heap_size==0;
	}
	int size() {
		return heap_size;
	}
	void push(T x) {
		heap_size++;
		heap[heap_size]=x;
		int now=heap_size;
		while(now>1) {
			int next=now>>1;
			if(heap[now]<heap[next]) {
				swap(heap[now],heap[next]);
			}
			else return;
			now=next;
		}
		return;
	}
	void pop() {
		heap[1]=heap[heap_size];
		heap_size--;
		int now=1,next;
		while((now<<1)<=heap_size) {
			next=now<<1;
			if(next+1<=heap_size&&heap[next+1]<heap[next]) next++;
			if(heap[next]<heap[now]) {
				swap(heap[now],heap[next]);
			}
			else return;
			now=next;
		}
		return;
	}
	inline void clear() {
		while(!empty()) pop();
	}
};
```

好，这时候我们再来看题：

> VIP是个很讲究效率的孩子，他希望用这些时间钓到尽量多的鱼。他从湖1出发，**向右走**，有选择的在一些湖边停留一定的时间钓鱼，**最后在某一个湖边结束钓鱼**。他测出从第 $i$ 个湖到 $i+1$ 个湖需要走 $5×t_i$ 分钟的路，还测出在第 $i$ 个湖边停留，第一个5分钟可以钓到鱼 $f_i$，以后再每钓5分钟鱼，鱼量减少 $d_i$。为了简化问题，他假定没有其他人钓鱼，也不会有其他因素影响他钓到期望数量的鱼。请编程求出能钓最多鱼的数量。

重点：

- **最后在某一个湖边结束钓鱼**：那么设在 $i$ 这个湖结束钓的鱼最多。在 $i$ 以前可能因为钓的鱼数量不足而非最优，而它右边可能因为浪费了过多时间在走路上面。
- **向右走**：这说明他没法走回头路。那么结束于 $x$ 鱼塘的路线一定在走路上花了$\sum\limits_{i=1}^{x-1}{t_i}$分钟。

我们需要决定的只有：在每个鱼塘停留的时间，和停止钓鱼的点。

停止的点最好办，直接枚举。

停留的时间需要贪心：

按照一个正常人的思路，他肯定会把时间用得尽量满。这样浪费就少。并且他钓的坑肯定是鱼最多的坑。但是，每钓完鱼后坑里的鱼数是会减少的。我们需要一个能在$O(log{n})$的时间复杂度内取出最大的元素，修改然后又用这样的一个时间丢回去的数据结构。这就是**堆**了。

特别需要注意的是，我们这里的堆只是维护我们的贪心算法的工具，**元素出入堆的顺序与钓鱼的顺序没有任何关系**。

贪心的代码就可以写出来了。

细节：$h$ 是小时，$t_i$ 的单位是 $5min$ ，所以我们先将 $h$ 转为分钟（$\times 60$）再转为 $5min$ （$\div 5$） 即 $\times 12$。

```cpp
inline void solve()
{
	h*=12;
	int ans=0;//我们需要取各结束点的最大值
	for(register int i=1;i<=n;i++) { //枚举结束点
		h-=t[i-1]; //剩余时间，我们说过花费时间是t数组的前缀和，所以减去即可
		int newans=0; //本结束点的解
		q.clear(); //清空堆
		for(register int j=1;j<=i;j++) q.push(a[j]); //把沿途的鱼塘扔进去
		for(register int j=1;j<=h;j++) { //枚举时间点
			fish x=q.top(); //取堆顶
			q.pop(); //弹出
			if(x.f>0) { //如果还有鱼就钓
				newans+=x.f; //累加答案
				x.f-=x.d; //更新能钓的鱼数
			}
			q.push(x); //扔回堆里
		}
		ans=max(ans,newans); //更新最优解
	}
	cout<<ans<<endl; //输出答案。
 } 
```

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

/*
* 
* 省略快读和堆
* 
*/

const int MaxN=30;
int n,h;
struct fish {
	int f,num,d;
	bool operator < (fish x)const {
		return f>x.f;
	}
}a[MaxN];
//int d[MaxN];
int t[MaxN];
Priority_Queue<fish>q;

inline void init()
{
	n=get();
	h=get();
	for(register int i=1;i<=n;i++) a[i].f=get(),a[i].num=i;
	for(register int i=1;i<=n;i++) a[i].d=get();
	for(register int i=1;i<n;i++) t[i]=get();
}

inline void solve()
{
	h*=12;
	int ans=0;
	for(register int i=1;i<=n;i++) {
		h-=t[i-1];
		int newans=0;
		q.clear();
		for(register int j=1;j<=i;j++) q.push(a[j]);
		for(register int j=1;j<=h;j++) {
			fish x=q.top();
			q.pop();
			if(x.f>0) {
				newans+=x.f;
			}
			x.f-=x.d;
			q.push(x);
		}
		ans=max(ans,newans);
	}
	cout<<ans<<endl;
 } 

int main()
{
	init();
	solve();
}
```

---

## 作者：GK0328 (赞：3)

我是~~P党~~的。。。

这道题的数据范围很小，好多方法都能AC，如暴力地进行DP，但这道题的正解应该是贪心。

①枚举小V（VIP999）在前i个湖钓鱼（每个湖不一定需要钓鱼）。

②我们记录一下当前还剩多少时间来钓鱼（由于时间都是5的倍数，我们可以都对时间/5后计算）。

③对于我们枚举的每一个方案，易得小V不会走回头路（否则不是最优解），让时间减去从第一个湖到最后一个湖所花费的时间，这样小V现在在前i个湖间移动就不需要时间了（已经提前花了）。

④然后就变成简单的堆操作啦！！！首先将前i个湖初始的鱼数丢入堆中，取出并弹出堆头，将下一次还能钓到的鱼数丢入堆中，直至堆为空或时间到了停止。

//你可以~~忽略下一部分~~

然而我用的不是堆。。。

我用了左偏树，左偏树可以代替所有的堆操作，还可以合并堆；左偏树只有一个操作，那就是合并！！！

删除操作：将该点左右儿子合并

插入操作：将该点与大的数合并

详细操作请学习左偏树P3377。

上代码

```pascal

```uses math;//数学库
type ZAI=record//节点信息
  l,r,val,dep:longint;
end;
var
  p:array[0..1005]of ZAI;
  fa,f,d,t:array[0..1005]of longint;
  n,i,j,realh,h,id,gone,now:longint;
  ans,nowans:int64; 
  kong:ZAI;
function father(x:longint):longint;//并查集
begin
  if fa[x]=0 then
   exit(x);
  exit(father(fa[x]));
end;
function merge(x,y:longint):longint;//合并操作
var
  t:longint;
begin
  if (x=0) or (y=0) then
    exit(x+y);
  if p[x].val<p[y].val then//维护堆顶元素最大
  begin
    t:=x;
    x:=y;
    y:=t;
  end;
  p[x].r:=merge(p[x].r,y);//将y与x右子树合并
  fa[p[x].r]:=x;
  if p[p[x].l].dep<p[p[x].r].dep then
  begin
    t:=p[x].l;
    p[x].l:=p[x].r;
    p[x].r:=t;
  end;
  p[x].dep:=p[p[x].r].dep+1;//更新距离
  exit(x);
end;
procedure pop(x:longint);//删除操作
begin
  p[x].val:=-1;
  fa[p[x].l]:=0;
  fa[p[x].r]:=0;//将儿子节点的父亲置为0
  id:=merge(p[x].l,p[x].r);//合并！！！
end;
procedure ins(x,y:longint);//插入操作
begin
  fa[x]:=0;
  p[x].val:=y;
  p[x].l:=0;
  p[x].r:=0;
  p[x].dep:=0;//新建一个点，可以直接用刚删去的那个点
  id:=merge(id,x);//合并！！！
end;
begin
  readln(n);
  readln(realh);
  realh:=realh*12;
  for i:=1 to n do
    read(f[i]);
  readln;
  for i:=1 to n do
    read(d[i]);
  readln;
  for i:=1 to n-1 do
    read(t[i]);
  readln;//读入
  for i:=1 to n do//枚举小V（VIP999）在前i个湖钓鱼
  begin
    nowans:=0;
    h:=realh;
    if h<=0 then//若没时间钓鱼了，则结束
      break;
    p[0].dep:=-1;
    for j:=1 to i do//置空
    begin
      fa[j]:=0;
      p[j]:=kong;
    end;
    id:=0;
    for j:=1 to i do
    begin
      p[j].val:=f[j];
      if j=1 then
        id:=1 else
        id:=merge(id,j);
    end;
    while (id<>0) and (h>0) do//开始计算
    begin
      dec(h);
      nowans:=nowans+p[id].val;//堆顶元素
      gone:=id;//记录
      now:=p[id].val;//记录
      pop(id);//弹出堆顶元素
      if now-d[gone]>0 then
        ins(gone,now-d[gone]);//新建节点
    end;
    ans:=max(ans,nowans);//取max
    realh:=realh-t[i];//减去所花时间
    if realh<=0 then
      break;
  end;
  writeln(ans);//输出
end.
```pascal

```

---

## 作者：LB_tq (赞：2)

# Solution
## 贪心+线段树优化
看到题解区里没有C++线段树，蒟蒻发一下。

考虑题意中说**可以在任意鱼塘停下**。每次贪心地选择**当前能钓到鱼数最多**的鱼塘钓鱼。

显然，并不需要在鱼塘之间来回穿梭，只要在一个鱼塘钓到**最优解区间内的鱼数**停止，再前往下一个鱼塘即可。

举个栗子：现在有两个鱼塘，去除赶路的时间，还剩15分钟。此时，1号鱼塘每5分钟可以钓到10条鱼，二号可以钓到8条。我们首先选择第一个，然后1号缩减为5条。**我们当然可以先钓完这5条，再去2号鱼塘了**QwQ。

所以，我们可以不用考虑多余的赶路时间，**只需去除一遍路程时间即可**。于是，可以线段树维护最大值，每次更新鱼数。记得循环前（枚举最远走到的鱼塘）要**维护线段树**，**使其恢复初始状态**。

做完后才发现n<=26（~~早知道的话就不用什么线段树了暴力多好QwQ~~）

细节详见代码。

------------
# Code
```
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=30;
int n,h,ans,f[maxn],t1[maxn],d1[maxn];//数组意义见题意
struct tree{
	int d;//d存储节点最大值
	int k;//k存储节点最大值所属于的鱼塘编号
}t[maxn<<2];//线段树数组
int fr(){
	char ch=getchar();
	while(ch>'9'||ch<'0')
		ch=getchar();
	int sum=ch-'0';
	while((ch=getchar())>='0'&&ch<='9')
		sum=(sum<<3)+(sum<<1)+ch-'0';
	return sum;
}//快读（题目没有负数）
int ls(int p){
	return p<<1;
}
int rs(int p){
	return p<<1|1;
}
void push_up(int p){
	if(t[ls(p)].d>t[rs(p)].d)
		t[p]=t[ls(p)];
	else
		t[p]=t[rs(p)];
}//维护
void build(int p,int l,int r){
	if(l==r){
		t[p].d=f[l];
		t[p].k=l;
		return;
	}
	int mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	push_up(p);
}//建树
void update(int p,int l,int r,int x,int y){
	if(l==x&&r==x){
		t[p].d=y;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)
		update(ls(p),l,mid,x,y);
	else
		update(rs(p),mid+1,r,x,y);
	push_up(p);
}//更新（将x鱼塘的鱼数更新为y）
int query(int p,int l,int r,int nl,int nr){
	if(nl>=l&&nr<=r)
		return p;
	int x,ans,sum=-1e6,mid=(nl+nr)>>1;
	if(l<=mid){
		x=query(ls(p),l,r,nl,mid);
		if(t[x].d>=sum){
			sum=t[x].d;
			ans=x;
		}
	}
	if(r>mid){
		x=query(rs(p),l,r,mid+1,nr);
		if(t[x].d>=sum){
			sum=t[x].d;
			ans=x;
		}
	}
	return ans;
}//查询（注意返回的是线段树的下标）
int main(){
	n=fr();
	h=fr();
	for(int i=1;i<=n;i++)
		f[i]=fr();
	for(int i=1;i<=n;i++)
		d1[i]=fr();
	for(int i=2;i<=n;i++){
		t1[i]=fr();
		t1[i]*=5;
		t1[i]+=t1[i-1];
	}//转化为分钟存储
	build(1,1,n);
	int x,s,u;
	for(int i=1;i<=n;i++){
		x=h*60;
		x-=t1[i];
		s=0;
		for(int j=1;j<i;j++)
			update(1,1,n,j,f[j]);//恢复初始状态
		while(1){
			if(x<5)//如果时间不够，break
				break;
			u=query(1,1,i,1,n);
			if(t[u].d<=0)
				break;//如果最多的鱼也不是正数，break
			s+=t[u].d;
			x-=5;
			update(1,1,n,t[u].k,t[u].d-d1[t[u].k]);
		}
		ans=max(ans,s);//ans取最大值
	}
	printf("%d",ans);
	return 0;
}
```
线段树也可以换成大根堆（优先队列）。
**祝大家rp++。**




---

## 作者：brealid (赞：2)

这道题数据范围比较小，所以我们可以先不考虑时间复杂度（貌似关于 $n$ 的指数算法都能过）

以下字母 $T=12h$ （即：“单位时间”的数据范围） 

**引理** 约翰不会掉头  
证明：由于每个鱼塘能钓到的鱼与当前时间戳无关，掉头只会白白浪费时间，所以约翰不会掉头  
Q.E.D.

**思路** DP  
考虑设计状态 ``dp[i][j]`` 表示处于第 ``i`` 个鱼塘，花费了 ``j`` 单位时间，钓到了 ``dp[i][j]`` 条鱼。  
考虑转移。从 ``dp[i][j]`` 转移到 ``dp[k][p]`` ，当且仅当：  
- $i < k$ （引理）
- $j + dist(i\ to\ k)\le p$（从鱼塘 $i$ 到鱼塘 $j$ 的时间花费）  

转移方程式为 $dp[k][p] = \max(dp[k][p], dp[i][j]+fish(i, p- j - dist(i\ to\ k)))$   
其中 $fish(x,y)$ 表示在鱼塘 $x$ 钓 $y$ 分钟得到的鱼数目，可以 $\Theta(nT)$ 预处理得出。

初始化 ``f[0][0]`` 为 ``0`` ，其余均为 ``-inf`` （注：转移时 $k\in[1,n],i\in[0,n]$，原理是模拟一个虚拟鱼塘 $0$ 与鱼塘 $1$ 处于同一位置，方便计算在鱼塘 $1$ 钓鱼的贡献）

---

注意代码中的 $i,j,k,p$ 与此处意义不相同。

时间复杂度 $\Theta(n^2T^2)≈25^2*192^2≈2.3\times10^7$，能过。

### 代码

已略去头文件 & I/O优化

```cpp
//     自己选择的路，跪着也要走完。朋友们，虽然这个世界日益浮躁起来，只
// 要能够为了当时纯粹的梦想和感动坚持努力下去，不管其它人怎么样，我们也
// 能够保持自己的本色走下去。                               ——陈立杰
/*************************************
 * @problem:      P1717 钓鱼.
 * @user_id:      63720.
 * @user_name:    brealid.
 * @time:         2020-06-01.
 * @language:     C++.
 * @upload_place: luogu.
*************************************/  

const int N = 25 + 4, HT = 16 * 60 + 7;

int H, n;
int f[N], d[N], t[N];
int fish[N][HT];
int dp[N][HT];
#define dist(l, r) (t[r] - t[l])

signed main() {
    n = read<int>();
    H = read<int>() * 12;
    for (int i = 1; i <= n; i++) f[i] = read<int>();
    for (int i = 1; i <= n; i++) d[i] = read<int>();
    for (int i = 2; i <= n; i++) t[i] = t[i - 1] + read<int>();
    for (int i = 1; i <= n; i++) {
        int now = f[i];
        for (int j = 1; j <= H; j++) {
            fish[i][j] = fish[i][j - 1] + now;
            now = max(now - d[i], 0);
        }
    }
    memset(dp, 0xcf, sizeof(dp));
    dp[0][0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            for (int k = dist(j, i); k <= H; k++) {
                for (int p = k; p <= H; p++) {
                    dp[i][p] = max(dp[i][p], dp[j][k - dist(j, i)] + fish[i][p - k]);
                }
            }
        }
    }
    // for (int i = 1; i <= n; i++)
    //     for (int j = 0; j <= H; j++)
    //         printf("%-3d%c", dp[i][j], " \n"[j == H]);
    int ans = 0;
    for (int i = 1; i <= n; i++) ans = max(ans, dp[i][H]);
    write(ans, 10);
    return 0;
}

// Create File Date : 2020-06-01

/*
Input
2 1
10 1
2 5
2
*/
```

---

## 作者：neverreborn (赞：2)

一道比较经典的贪心题，忽略人的走动，假设走到第i个湖停止，则减去到第i个湖的时间，然后选出1，2,3..i个湖中最大的钓鱼数，更新计数器和这个点的钓鱼数，直到时间为0或最大值小于零为止，这个过程可以用堆优化，但本题数据很小，意义不大。


---

## 作者：lqr2018 (赞：1)


思路

------------

这个题目其实用优先队列是个不错的方法，但我们可以通过一个数组（bin[]）来记录每个鱼塘，通过这个方法可以便于操作。解题的主要思想是枚举，其他题解已经写的很清楚，我不再赘述了。

------------
下面是代码。

```
#include<bits/stdc++.h>
using namespace std;
int n,H,cnt=1,ans=0;
int bin[300];
int h[120],d[120],t[120];
bool cmp(int a,int b){
	return a>b;
}
int main(){
	cin>>n>>H;
	H*=12;
	for(int i=1;i<=n;i++) cin>>h[i];
	for(int i=1;i<=n;i++) cin>>d[i];
	t[1]=0;
	for(int i=2;i<=n;i++) cin>>t[i];
	for(int i=1;i<=n;i++){
		H-=t[i];
		if(H<=0) break;
		int T=0,now;
		for(now=h[i];T<=H && now>0;T++,now-=d[i]) bin[cnt++]=now;//记录每个鱼塘最大值，取在这个鱼塘的极限情况，保证不遗漏
		sort(bin+1,bin+cnt+1,cmp);
		T=0;
		int k=0;
		for( ;T<=H && T<=cnt;T++) k+=bin[T];//计算当前最大值
		ans=max(ans,k);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：lcy09 (赞：1)

### 分析

题目中逐渐减少的各个鱼塘能钓到的鱼的数量，就表现了这个题的全局性，所以这是一道dp，同时还掺杂着贪心的一些想法。先来循环枚举是在哪个池塘严格结束的，根据此性质，减去从1号池塘到当前枚举到的结束池塘之间花费的时间，然后就可以在这些池塘间随意走动，循环剩下的时间，看当前哪个池塘可钓的鱼的数量最大，就钓哪个。

为什么说可以随便走动呢？因为这只是一个形象的比喻。在最外层循环的条件下，无论在哪个鱼塘钓多长时间，你在预先知道策略后，都可以把你的行为按池塘顺序弄成线性的，所以那种说法只是为了制定这个所谓的“策略”时方便思考。

### 代码

```cpp
int n;
int T;
struct node
{
    int num;//初始数量
    int k;//减少量
}pool[101];//存储每个池塘的信息
int ti[101];//从第i个池塘走到第i+1个花费ti[i]时间
int ans;
int t[105];//用来枚举结束地点时进行可钓鱼数量减少操作的数组
int main()
{
    cin>>n>>T;
    T*=12;//预处理
    for(int i=1;i<=n;i++) cin>>pool[i].num;
    for(int i=1;i<=n;i++) cin>>pool[i].k;
    for(int i=1;i<=n-1;i++) cin>>ti[i];
    int pos;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++) t[j]=pool[j].num;//弄到替换数组中
        T-=ti[i-1];//剩余时间
        int tsum=0;//当前情况下的答案
        for(int j=1;j<=T;j++)//枚举剩余的每一分钟
        {
            pos=0;
            for(int o=1;o<=i;o++)
            {
                if(t[pos]<t[o]) pos=o;//枚举，找出当前最优的策略
            }
            if(pos==0) break;
            tsum+=t[pos];
            t[pos]-=pool[pos].k;//定期减少
        }
        ans=max(ans,tsum);//更新答案
    }
    cout<<ans<<endl;
    return 0;
```

**时间复杂度**

O(n^2+n^3)

---

## 作者：fighter_OI (赞：1)

贪心。

枚举终点，去除走路时间，每次取最大值。

楼下已有思路，此处不再赘述。

加线段树优化（然而对25的规模并没有什么卵用）

Pascal：（为何全是cpp）

```cpp
uses math;
var n,h,i,j,k,p,ans,big,len:longint;
     f,a,d,l,s:array[1..1000] of longint;
procedure buildtree(l,r,k:longint);
var mid:longint;
begin
 if l=r then
  begin
   f[k]:=l;
   exit;
  end;
 mid:=(l+r) shr 1;
 buildtree(l,mid,k shl 1);
 buildtree(mid+1,r,k shl 1+1);
 if a[f[k shl 1]]>a[f[k shl 1+1]] then f[k]:=f[k shl 1]
                                         else f[k]:=f[k shl 1+1];
end;
procedure updata(l,r,k:longint);
var mid:longint;
begin
 if l=r then exit;
 mid:=(l+r) shr 1;
 if p<=mid then updata(l,mid,k shl 1)
             else updata(mid+1,r,k shl 1+1);
 if a[f[k shl 1]]>a[f[k shl 1+1]] then f[k]:=f[k shl 1]
                                         else f[k]:=f[k shl 1+1];
end;
begin
 read(n,h);
 h:=h*12;
 for i:=1 to n do read(s[i]);
 for i:=1 to n do read(d[i]);
 for i:=2 to n do read(l[i]);
 big:=0;
 len:=0;
 for i:=1 to n do
  begin
   inc(len,l[i]);
   k:=h-len;
   buildtree(1,i,1);
   a:=s;
   ans:=0;
   while (k>0)and(a[f[1]]>0) do
    begin
     inc(ans,a[f[1]]);
     dec(a[f[1]],d[f[1]]);
     p:=f[1];
     updata(1,i,1);
     dec(k);
    end;
   big:=max(ans,big);
  end;
 write(big);
end .
```

---


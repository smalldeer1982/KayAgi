# 小Z的神奇数列

## 题目背景

小Z最近在研究数列，他需要知道在他所研究的数列中，最大的数是多少（Max），最小的数是多少（Min），最大的数的最小的数次幂是多少（Max^Min），所有数的乘积是多少。要知道，这样的问题是肯定难不倒小Z的。但是，最近小Z突发奇想，想要研究下这个数列的更深层的性质，所以他决定不断的从这个数列中删去一些数，每次删除后都研究下当前数列。由于数列项数很大，这给小Z带来了很大的麻烦，于是小Z请你帮他写一个程序，来完成下列操作。

## 题目描述

你需要维护一个可重集，支持五种操作：

- `D x` 表示删除 $x$，保证 $x$ 一定存在。若有多个只用删除一个。

- `B` 询问集合中最大值。

- `S` 询问集合中最小值。

- `M` 设集合中最大值为 $a$，最小值为 $b$，询问 $a^b \bmod 317847191$。

- `T` 询问数列中所有数的乘积，对 $317847191$ 取模。

对于所有询问保证集合非空。


## 说明/提示

【数据规模】  
对于部分数据，$1 \le n \le 1000$，$1\le m \le 100$，$1\le a_i \le 400$；  
对于 $100\%$ 的数据，$1\le n,m \le 10^6$，$1\le a_i \le 10^8$。


## 样例 #1

### 输入

```
3 6
2 6 9
M
D 9
B
S
M
T```

### 输出

```
81
6
2
36
12```

# 题解

## 作者：Chinese_zjc_ (赞：18)

## 不会离线和高级数据结构和中国剩余定理的人的福音!

###### Update 2020.6.26 21:00: 使用了离散化,防止在$D$操作中被卡$O(n^2log_2(n))$

你以为这题要么离线,要么高级数据结构,要么中国剩余定理这三种解法吗?

其实还有一种解法!

题目里只有五种操作,下面我们一个个来剖析这几种操作.

### Part A:最大值

要求最大值,我们可以用一个排好序的数组的最后一个元素的下标$b(biggest)$来存储.

当这个数不复存在时,显然在剩下的元素中的最大值的下标比$b$要小.

那我们只要简单地向左一个个地缩小范围,直到找到一个还存在的元素即可.

### Part B:最小值

最小值跟最大值不是可以用同样的方法嘛,只不过反过来而已,我们用$s(smallest)$来表示最小值元素的下标.

### Part C:$a_b^{a_s}\mod317847191$

这不就是把上面两个玩意合在一起加个快速幂吗,没什么好讲的,略.

### Part D:$\prod x(x\in A)\mod317847191$

这自然成为了这种解法最复杂的地方.

自然容易想到使用一个变量$sum$来存储这个答案,然后使用乘法逆元来当作删除.

但是远没有这么简单,因为我们的模数$317847191$并不是一个质数,有一部分的数字是没有模$317847191$意义下的乘法逆元的.

比如说,因为$317847191=71\times113\times173\times229$,所以说因数中有$71,113,173,229$的数字都是没有模$317847191$意义下的逆元的.

那怎么办?

我马上就想到把这几个因子从$sum$中单独提取出来,在最后的时候统一处理.

可以得到一个式子:
$$
\prod x(x\in A)\equiv sum\times71^{t_{71}}\times113^{t_{113}}\times173^{t_{173}}\times229^{t_{229}}\pmod{317847191}
$$
其中$t_x$表示因子$x$出现的次数.

但是,毒瘤的出题人肯定不愿意让我们一点思考都没有就让我们过.

$As\ a\ result$,我$TLE$了.

显然还要继续找方法优化,但是我们可以从哪里入手呢?

现在我们计算一次这个式子需要计算$4$次快速幂,有没有方法可以减少计算快速幂的次数吗?

答案是有的.

下面有一个引理:
$$
p_b^a\bmod\prod_{i=1}^np_i=p_b\times(p_b^{a-1}\bmod(\frac{\prod_{i=1}^np_i}{p_b}))
$$

其中$p_i$是质数,且$p_i\not=p_j(i\not=j)$.

#### 证明:

我们在小学二年级就学过:若$a\div b=c\cdots\cdots d$,则$ae\div be=c\cdots\cdots de$.

那我们把这个式子套进去就可以了,我们不用管$c$,令$a=p_b^{a-1},b=\frac{\prod_{i=1}^np_i}{p_b},d=p_b^{a-1}\bmod(\frac{\prod_{i=1}^np_i}{p_b}),e=p_b$.

则可以得到$a\bmod b=d,(ae)\bmod(be)=de$.

那么就有$(ae)\bmod(be)=de=e\cdot(a\bmod b)$.

即可得$(p_b^{a-1}\cdot p_b)\bmod(\frac{\prod_{i=1}^np_i}{p_b}\cdot p_b)=p_b\cdot(p_b^{a-1}\bmod\frac{\prod_{i=1}^np_i}{p_b})$.

即$p_b^a\bmod\prod_{i=1}^np_i=p_b\cdot(p_b^{a-1}\bmod\frac{\prod_{i=1}^np_i}{p_b})$.

$Q.E.D.$

好,现在就可以直接用这个玩意来先代入了.
$$
\prod x(x\in A)\equiv sum\times(71\times(71^{t_{71}-1}\bmod(\frac{317847191}{71})))\times(113\times(113^{t_{113}-1}\bmod(\frac{317847191}{113})))\times(173\times(173^{t_{173}-1}\bmod(\frac{317847191}{173})))\times(229\times(229^{t_{229}-1}\bmod(\frac{317847191}{229})))\pmod{317847191}
$$
也可以简写为:
$$
\prod x(x\in A)\equiv sum\times\prod_{p_i|317847191}(p_i\times(p_i^{t_{p_i}-1}\bmod(\frac{317847191}{p_i})))\pmod{317847191}
$$
其中$p_i$是质数,且$p_i\not=p_j(i\not=j)$.

可是这样算还是要算快速幂啊.

但是,我们可以发现$p_i$在取模$\frac{317847191}{p_i}$意义下已经是有乘法逆元的了.

所以我们可以预先算好$p_i^{t_{p_i}-1}\bmod\frac{317847191}{p_i}$的值,用$s_i$存储,要加一个数就乘以$p_i$,要删一个数就乘以$p_i$在取模$\frac{317847191}{p_i}$意义下的乘法逆元.

这样就可以$O(1)$处理了.

代码如下:

```cpp
//This code was made by Chinese_zjc_.
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
#include<vector>
#include<unordered_map>
#include<queue>
#define int long long//小心爆零
#define INF 0x3fffffffffffffff
#define MOD 317847191
using namespace std;
const int q71=1387153,q113=1020576,q173=785883,q229=1248575;//预先算好四个特殊数字的相应逆元
int n,m,tmp,b,s,sum=1,x,y,a[1000001],cnt,s71=q71,s113=q113,s173=q173,s229=q229,ans71,ans113,ans173,ans229,t71,t113,t173,t229;
//n,m,a如题意所述;
//b,s,sxxx,txxx如上文所述;
//tmp是暂存用的工具变量;
//sum是除了四个特殊值外的总乘积;
//x,y是用在exgcd里的变量,exgcd完后x是X模Y意义下的逆元;
//ansxxx表示xxx在T操作里的贡献;
//cnt表示集合里不重复元素的总个数(包括删掉的);
struct NUM{
	int v,t;
}num[1000001];//离散化,把重复的放到一起方便删除
char c;//工具变量
inline int power(int A,int B,int C)//快速幂&cdd(不是)
{
	int TMP=1;
	while(B)
	{
		if(B&1)
		{
			TMP=(TMP*A)%C;
		}
		B>>=1;
		A=(A*A)%C;
	}
	return TMP;
}
inline void exgcd(int X,int Y)//算乘法逆元用
{
	if(Y==0)
	{
		x=1;
		y=0;
		return;
	}
	exgcd(Y,X%Y);
	int TMP=x;
	x=y;
	y=TMP-X/Y*y;
}
inline void d(int now)//删除操作,通过二分找到一个还没被删掉的,把used标记打成true
{
	int l=s,r=b,mid;
	while(l<r)
	{
		mid=(l+r)>>1;
		if(num[mid].v<now)
		{
			l=mid+1;
			continue;
		}
		if(num[mid].v>now)
		{
			r=mid-1;
			continue;
		}
		if(num[mid].v==now)
		{
			--num[mid].t;
			return;
		}
	}
	--num[l].t;
}
inline void write(int now)//快写
{
	if(now==0)
	{
		putchar('0');
	}
	char s[100];
	int len=0;
	while(now)
	{
		s[len++]=now%10+'0';
		now/=10;
	}
	while(len)
	{
		putchar(s[--len]);
	}
	putchar('\n');
}
inline void read(int &now)//快读数字
{
	now=0;
	char cc=getchar();
	while('0'>cc||'9'<cc)
	{
		cc=getchar();
	}
	while('0'<=cc&&cc<='9')
	{
		now=(now<<3)+(now<<1)+(cc^'0');
		cc=getchar();
	}
}
inline void rd(char &now)//快读字符
{
	now=getchar();
	while('A'>now||now>'Z')
	{
		now=getchar();
	}
}
signed main()
{
	read(n);
	read(m);
	for(int i=1;i<=n;++i)
	{
		read(a[i]);
		tmp=a[i];
        //特殊处理几个特殊数字并提出因子
		while(tmp%71==0)
		{
			++t71;
			s71=s71*71%(MOD/71);
			tmp/=71;
		}
		while(tmp%113==0)
		{
			++t113;
			s113=s113*113%(MOD/113);
			tmp/=113;
		}
		while(tmp%173==0)
		{
			++t173;
			s173=s173*173%(MOD/173);
			tmp/=173;
		}
		while(tmp%229==0)
		{
			++t229;
			s229=s229*229%(MOD/229);
			tmp/=229;
		}
		sum=(sum*tmp)%MOD;//把剩下的其它数字直接丢一起
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;++i)
	{
		if(a[i]!=num[cnt].v)
		{
			num[++cnt].v=a[i];
		}
		++num[cnt].t;
	}
	s=1;
	b=cnt;
	while(m)
	{
		--m;
		rd(c);
		if(c=='D')//删除
		{
			read(tmp);
			d(tmp);
			while(tmp%71==0)
			{
				--t71;
				s71=s71*q71%(MOD/71);
				tmp/=71;
			}
			while(tmp%113==0)
			{
				--t113;
				s113=s113*q113%(MOD/113);
				tmp/=113;
			}
			while(tmp%173==0)
			{
				--t173;
				s173=s173*q173%(MOD/173);
				tmp/=173;
			}
			while(tmp%229==0)
			{
				--t229;
				s229=s229*q229%(MOD/229);
				tmp/=229;
			}
			exgcd(tmp,MOD);
			sum=(sum*(x%MOD+MOD))%MOD;
		}
		if(c=='B')//最大值
		{
			while(!num[b].t)
			{
				--b;
			}
			write(num[b].v);
		}
		if(c=='S')//最小值
		{
			while(!num[s].t)
			{
				++s;
			}
			write(num[s].v);
		}
		if(c=='M')//a[b]^a[s] mod MOD
		{
			while(!num[b].t)
			{
				--b;
			}
			while(!num[s].t)
			{
				++s;
			}
			write(power(num[b].v,num[s].v,MOD));
		}
		if(c=='T')//总乘积
		{
            //t为0时是唯一的ans为1的时候,特判处理
			if(t71)
			{
				ans71=71*s71;
			}
			else
			{
				ans71=1;
			}
			if(t113)
			{
				ans113=113*s113;
			}
			else
			{
				ans113=1;
			}
			if(t173)
			{
				ans173=173*s173;
			}
			else
			{
				ans173=1;
			}
			if(t229)
			{
				ans229=229*s229;
			}
			else
			{
				ans229=1;
			}
			write(sum*ans71%MOD*ans113%MOD*ans173%MOD*ans229%MOD);//得到答案
		}
	}
	return 0;
}
```



---

## 作者：夏色祭 (赞：7)

目前第二快的代码（仅次于tt巨佬）

几个月前想做来着，但是那时菜，几个月过去了，还是很菜，但这道题还是能艹出来了。。。

![我太菜了](https://s1.ax1x.com/2018/01/07/pe8zLt.jpg)

~~标签假的~~我们直接离线搞就行了。

先搞没有删的数，然后对于删除从后往前搞。

每次把删的数重新加进去。

就是这样%%%

**毒瘤出题人卡map**

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<map>
#define For(i,x,y) for (reg int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (reg int i=(x);i>=(y);i--)
#define N 1000010
#define mod 317847191
#define ll long long
#define il inline
#define reg register
using namespace std;
il int read(){
    int x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
il void rt(int x){
    if (x<0) putchar('-'),x=-x;
    if (x>=10) rt(x/10),putchar(x%10+'0');
        else putchar(x+'0');
}
int n,m,tot,h,t,ma,mi,x[N],anst[N],ansmi[N],ansma[N],a[N],b[N],rk[N],num[N];
ll sum,k;
bool flag[N];
char s[N][2];
//map<int,int>mp;
int find(int z){
    int ans=0,l=1,r=n;
    while (l<=r){
        int mid=l+r >> 1;
        if (a[mid]>=z) ans=mid,r=mid-1;
            else l=mid+1;
    }
    return ans;
}
il ll power(int a,int b){
    ll ret=1,x=a,y=b;
    for (;y;y=y >> 1,x=(x*x)%mod)
      if (y&1==1) ret=ret*x%mod;
    return ret;
```
}//快速幂
```cpp
il int max(int x,int y){return x>y?x:y;}
il int min(int x,int y){return x<y?x:y;}
int main(){
    n=read(),m=read();
    For(i,1,n) a[i]=read();
    sort(a+1,a+1+n);
    For(i,1,n)
        if (a[i]!=a[i-1]) num[++tot]=i,rk[i]=tot;
    For(i,1,m){
        scanf("%s",&s[i]);
        if (s[i][0]=='D'){
            b[i]=read();
            int di=find(b[i]);
            flag[num[rk[di]]]=1,num[rk[di]]++;
        }
    }
    sum=1,mi=1e9;
    For(i,1,n)
        if (!flag[i]){
            k=a[i];
            sum=sum*k%mod;
            ma=max(ma,a[i]);
            mi=min(mi,a[i]);
```
}//先搞没删的数
```cpp
    Dow(i,m,1){
        if (s[i][0]=='D'){
            k=b[i];
            sum=sum*k%mod;
            ma=max(ma,b[i]);
            mi=min(mi,b[i]);
        }
        ansmi[i]=mi;
        ansma[i]=ma;
        anst[i]=sum;
```
}//再搞删掉的数
```cpp
    For(i,1,m){
        if (s[i][0]=='T') rt(anst[i]),printf("\n");
        if (s[i][0]=='B') rt(ansma[i]),printf("\n");
        if (s[i][0]=='S') rt(ansmi[i]),printf("\n");
        if (s[i][0]=='M') rt(power(ansma[i],ansmi[i])),printf("\n");
```
}//答案
    return 0;

}

---

## 作者：Mine_King (赞：6)

- **2020/06/28 Upd：之前的代码被hack了，所以更新了一下代码。**

安利一发[博客](https://www.luogu.com.cn/blog/195331/)，如果题解界面的$\LaTeX$挂了，请到[这里](https://www.luogu.com.cn/blog/195331/solution-p2174)查看。

做这题，第一眼感觉是个线段树awa，思路就是先排序，然后用一个`bool`数组记录这个数有没有被删掉，然后线段树瞎搞。  
然后就……挂了。  
再好好看题，发现完全用不着线段树，搞两个指针`L`和`R`，分别记录最大/最小的未被删除的数所在的位置（下文所有和位置有关的都指排序后的），当然记录一个数有没有被删掉的数组还是要有的（又不是只删两边的）（这可以二分求）。这样$B,S,M$操作的问题就都迎刃而解了。但是但是，这个$T$操作也有问题呀，要删数就需要求当前的乘积模$317847191$意义下的乘法逆元，但题目并不保证$a_i$和$317847191$互质，就不能搞$exgcd$了。  
其实可以离线做这题。我们先记录把所有要删的数都删掉后的情况，然后从后往前求答案，再从前往后输出即可。  

这里再讲一下删除操作，因为是有值相同的，所以我们每次删除最前面的那个，可以避免出现一些奇奇怪怪的问题。就是这样写：
```cpp
int l=L,r=R,mid;
while(l<=r)
{
	mid=(l+r)/2;
	if(a[mid]==x[i]&&(a[mid-1]<x[i]||d[mid-1])) break;//x[i]是要删的那个数的值。如果值相等，还要判断是否是第一个
	if(a[mid]>=x[i]) r=mid-1;//上面已经判断过不是第一个了，所以如果等于的话还是不能取这个数
	else l=mid+1;
}
d[mid]=true;
```
那么所有的问题都解决了。  
下面是代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define MAXN 1000005
#define mod 317847191
using namespace std;
int n,m,times=1,L,R,a[MAXN],x[MAXN],ans[MAXN];//times记录当前的乘积，L和R的意思上面讲了，x后面会解释，ans记录答案
bool d[MAXN];//d记录这个数有没有被删掉
char opt[MAXN];//opt记录是什么操作
int power(int a,int b,int c)//快速幂
{
    int ans=1;
    while(b)
    {
        if(b&1) ans=1ll*ans*a%c;
        a=1ll*a*a%c;
        b>>=1;
    }
    return ans%c;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    L=1,R=n;
    sort(a+1,a+n+1);//先给他排个序，不然后面全是白搭
    for(int i=1;i<=m;i++)
    {
        cin>>opt[i];
        if(opt[i]=='D')//删除操作要处理一下
        {
            scanf("%d",&x[i]);//读入要删的数的大小
            int l=L,r=R,mid;
            while(l<=r)//二分找到位置
            {
                mid=(l+r)/2;
                if(a[mid]==x[i]&&(a[mid-1]<x[i]||d[mid-1])) break;
                if(a[mid]>=x[i]) r=mid-1;
                else l=mid+1;
            }
            d[x[i]=mid]=true;//这里我们把x[i]直接改成位置，后面就不用再二分了（如果要再二分也可以，但是要改为求被删掉的里面最靠后的了）。
            while(d[R]) R--;
            while(d[L]) L++;
            //同时也要维护L和R
        }
    }
    for(int i=1;i<=n;i++)
        if(!d[i]) times=1ll*times*a[i]%mod;//先把没删的数都乘起来
    for(int i=m;i>=1;i--)//操作要从后往前做
    {
        if(opt[i]=='D')//此时的删除就变成了加入
        {
            d[x[i]]=false;
            times=1ll*times*a[x[i]]%mod;
            if(x[i]<L) L=x[i];//这里如果值更小就更新
            if(x[i]>R) R=x[i];//同上
        }
        else if(opt[i]=='B') ans[i]=a[R];
        else if(opt[i]=='S') ans[i]=a[L];
        else if(opt[i]=='M') ans[i]=power(a[R],a[L],mod);
        else ans[i]=times;
    }
    for(int i=1;i<=m;i++)//最后正着输出答案
        if(opt[i]!='D') printf("%d\n",ans[i]);//注意删除操作不要输出哦！
    return 0;
}
```

---

## 作者：荣耀南冥 (赞：4)

# P2174 小Z的神奇数列
[原题传送门](https://www.luogu.com.cn/problem/P2174)

## 题意
给你一个序列，要求支持删除，求$ max $，求$ min $，求$ max^{min}$，求整个序列剩余数之积，$ MOD $ $317847191$，直接想到求逆元，~~有手就行~~，然后就开始疯狂码代码，然后忽然脑海里出现了一个感觉，这个$ MOD $很不对劲，然后就随便写了一个程序判了一下发现这个数不是质数，我看着自己马上要打完的 $ N $ 行代码陷入了沉思

~~坑爹呢这是~~

然后只能重新构思，平衡树不会打， CRT 又不会，就是打打线段树才能维持的了生活这样子，然后我就想到了一个绝妙的思路，先开一个 a 数组并且排序，存放原值，再开一个 b 数组存放修改后的数列，为了防止被卡，我们再加一个 nxt 数组（以下简写为 n ）存放最近一个原值的位置。大致实现如下：(每次修改的值已加粗，如不习惯可以抄下来手模一下)

$ 初始 $

a：1 2 2 $\huge 3$ 3 3 3 3

b：1 2 2 $\huge 3$ 3 3 3 3 

n：1 2 3 $\huge4$ 5 6 7 8

$ 删除3 $

a：1 2 2 $\huge3$ 3 3 3 3 

b：1 2 2 $\huge1$ 3 3 3 3

n：1 2 3 $\huge5$ 5 6 7 8

$ 再删除3：$

a：1 2 2 $\huge3$ 3 3 3 3 

b：1 2 2 1 $\huge1$ 3 3 3

n：1 2 3 $\huge6$ 5 6 7 8

可见 a 数组不动，用来二分位置， b 数组用来修改， n 数组用来记录，下次直接跳即可。同时再用双指针记录首尾位置，删除时同时收缩，这样max即为 b[tail] ，min即为 b[head]。$max^{min}$ 快速幂即可

现在只有任务5了，我们的线段树派上用场了，现在我们的线段树只需要维护一个区间积即可，同时因为 a 数组二分， b 数组修改， n 数组跳跃，现在我们就可以确定修改的点的位置了，把这个点的值改成 1 $ (注意改成 1 ，不要手残改成 0 )$，直接 push_up 即可，连 push_down 都不用，更不用求逆元，

任务1：删除 $O(log_2n)$

任务2：最大值 $ O(1) $

任务3：最小值 $ O(1) $

任务4：$max^{min}$ $O(log_2{min})$

任务5 ：$ O (log_2n) $

所以现在的总复杂度大约是$O(mlog_2n)$，而且跑不满，我们就可以愉快的A掉这道题了，而且这还是在线做法 ~~(虽然没有什么用)~~

$ Code $
```cpp
#include <bits/stdc++.h>
using namespace std;
#define gc getchar()
#define lson (x<<1)
#define rson (x<<1|1)
#define mid ((tree[x].l+tree[x].r)>>1)
#define push_up(x) (tree[x].data=(1ll*tree[lson].data*tree[rson].data)%mod);
const int maxn=1e6+10,mod=317847191;
int n,m,head,tail;
int a[maxn],b[maxn],nxt[maxn];
struct gdx{
	int l,r,data;
}tree[maxn<<2];

inline int read(){
	int r=0,l=1;char ch=gc;
	while(!isdigit(ch)){if(ch=='-')l=-1;ch=gc;}
	while(isdigit(ch)){r=(r<<3)+(r<<1)+ch-'0';ch=gc;}
	return r*l;
}

void build(register const int x,register const int l,register const int r){//普通的建树
	tree[x].l=l;tree[x].r=r;
	if(l==r){
		tree[x].data=a[l];
		return;
	}
	build(lson,l,mid),build(rson,mid+1,r);
	push_up(x);
}

void Modify(register const int x,register const int l){
	if(tree[x].l==tree[x].r){
		tree[x].data=1;//一定要赋成 1 ,别写成 0 
		return;
	}
	if(l<=mid)Modify(lson,l);
	else Modify(rson,l);
	push_up(x);
}

inline int lowerbound(register int l,register int len,register const int x,register int half=0){//抄的stl lower_bound
	while(len>0){
		half=len>>1;
		if(a[l+half]<x)l+=half+1,len-=half+1;
		else len=half;
	}
	return l;
}

inline void erase(register const int x){//删除
	register const int p=lowerbound(1,n,x);
	b[nxt[p]++]=1;
	while(b[head]==1)head++;
	while(b[tail]==1)tail--;
	Modify(1,nxt[p]-1);
}

inline int ksm(register int x,register int y){//快速幂
	register int ans=1;
	while(y){
		if(y&1)ans=1ll*ans*x%mod;
		y>>=1;x=1ll*x*x%mod;
	}
	return ans;
}

inline int MAX(){
	return b[tail];
}

inline int MIN(){
	return b[head];
}

int main(){
	n=read();m=read();
	head=1,tail=n;
	for(int i=1;i<=n;++i)a[i]=b[i]=read(),nxt[i]=i;
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	build(1,1,n);
	register char s[10];
	for(int i=1;i<=m;++i){
		scanf("%s",s+1);
		if(s[1]=='D')erase(read());
		else if(s[1]=='B')printf("%d\n",MAX());
		else if(s[1]=='S')printf("%d\n",MIN());
		else if(s[1]=='M')printf("%d\n",ksm(MAX(),MIN()));
		else if(s[1]=='T')printf("%d\n",tree[1].data);
	}
	return 0;
}
```

---

## 作者：hwk0518 (赞：3)

#### 鉴于诸篇题解都是用的离线or在线高级数据结构，我决定给那些想不到离线又懒(bu)得(hui)高级数据结构的同学带来一些福音。

#### 很显然，由于没有insert操作，最大值是单调不增，最小值是单调不减的。于是想到双指针。这样我们看到这个做法有一些前途，下面我们讲一讲每个操作具体如何实现。

#### 先说。做之前我们要对数组排序，对每个数记录哪段极大区间里只有它，以及当前的一个指针（讲D操作时会讲作用）。还要记两个指针，分别指向序列中最前和最后未被删的数。

#### D：将指向当前数的指针后移一格，表示将这个大小的数又删了一个。如果头指针指向的数被删了，就一直向后移动直至找到一个未被删的数。尾指针同理。由于每个数只会被指针经过一次，且经过一次的处理代价是log，所以这个操作的均摊复杂度为log.

#### B&S：直接输出头指针or尾指针指向的数。均摊复杂度常数。

#### M:直接在B&S基础上快速幂。均摊复杂度log.

#### T:这是最麻烦的。考虑一开始就先求出所有数的和，删数时乘逆元做除法。但是很不幸，317847191不是质数，但我们知道它等于71，113，173，229的乘积，所以用中国剩余定理复合即可。由于每次插值时乘的单位元不变，所以先预处理，到时候直接乘。所以维护在模71，113，172，229意义下当前数的积即可。均摊复杂度为求逆元的log.

#### 由于本人卡得一手好常，所以一个用map的假做法就这样过了。如果昵萌使用此方法超时，可以尝试用静态数组二分答案的方式代替map。

代码：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
#include<map>
using namespace std;

const int N=1e6+5;
const int mod=317847191;
const int lis[5]={0,71,113,173,229};
int n,q;

int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
		x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x;
}
void write(int x)
{
	if(!x) return;
	write(x/10),putchar(x%10+'0');
}
void print(int x)
{
	if(!x)
	{
		putchar('0'),putchar('\n');
		return;
	}
	write(x),putchar('\n');
}

namespace MATHEMATICS
{
	int F_p(int x,int y,int mod)
	{
		int bas=x,ret=1;
		while(y)
		{
			if(y&1) ret=1LL*ret*bas%mod;
			bas=1LL*bas*bas%mod;
			y>>=1;
		}
		return ret;
	}
	int inv(int x,int y)//x对y的逆元
	{
		return F_p(x,y-2,y);
	}
	
	int CRT(int a_1,int a_2,int a_3,int a_4)
	//71:219359329
	//113:202522104
	//173:181889433
	//229:31923517
	{
		int ret=1LL*219359329*a_1%mod;
		ret+=1LL*202522104*a_2%mod;if(ret>=mod) ret-=mod;
		ret+=1LL*181889433*a_3%mod;if(ret>=mod) ret-=mod;
		ret+=1LL*31923517*a_4%mod;if(ret>=mod) ret-=mod;
		return ret;
	}
	
	int tryy(int x,int y)//求出模x余0,且模y余1的最小正整数 
	{
		int i=x;
		for(i=x;i%y!=1;i+=x);
		return i;
	}
}
using namespace MATHEMATICS;

struct Strange_Array
{
	int a[N],now[5],l,r;
	bool used[N];
	map<int,int> M;
	int query_min(){return a[l];}
	int query_max(){return a[r];}
	int query_mul(){return CRT(now[1],now[2],now[3],now[4]);}
	int POW(){return F_p(query_max(),query_min(),mod);}
	void del(int x)
	{
		used[M[x]]=1,++M[x];
		while(used[l]) ++l;
		while(used[r]) --r;
		for(int i=1;i<=4;++i) now[i]=1LL*now[i]*inv(x,lis[i])%lis[i];
	}
	void prework()
	{
		int i,j; 
		sort(a+1,a+n+1);
		for(j=1;j<=4;++j) now[j]=1;
		for(i=1;i<=n;++i)
		{
			if(a[i]!=a[i-1]) M[a[i]]=i;
			for(j=1;j<=4;++j) now[j]=1LL*now[j]*a[i]%lis[j];
		}
	}
};
Strange_Array SS;

void init()
{
	int i,x;n=read(),q=read();
	for(i=1;i<=n;++i) SS.a[i]=read();
	SS.l=1,SS.r=n;SS.prework();
	char s[10];
	while(q--)
	{
		scanf("%s",s+1);
		if(s[1]=='M') print(SS.POW());
		if(s[1]=='D') x=read(),SS.del(x);
		if(s[1]=='B') print(SS.query_max());
		if(s[1]=='S') print(SS.query_min());
		if(s[1]=='T') print(SS.query_mul());
	}
}

int main()
{
	init();
	return 0;
}
```

### 我们的心愿是世界和平。谢谢大家的阅读。

---

## 作者：封禁用户 (赞：3)

这题楼下大神都是用离线做的，我就来个在线做法。

其实很简单，就是用线段树瞎搞一下就行了，我开始的时候想用平衡树维护来着但是就发现对于多个相同的数他就不太好维护乘积了（因为在一个节点中可能会有多个相同的数，当删了个数更新乘积的时候还得再做除法然后就会带来一堆问题），于是我就把二叉查找树与线段树结合了一下，我们用线段树维护区间最大值、最小值、乘积，在建树的时候把数从小到大放入树中，这样就可以在线段树上二分了，而且为了支持删除操作我们还要维护一段区间是否可用，然后瞎搞就行了。然后为了防止卡常我加了个快读快输~~擦着边过去了~~代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
inline int get(){
	int n;char c;while((c=getchar())||1)if(c>='0'&&c<='9')break;
	n=c-'0';while((c=getchar())||1){
		if(c>='0'&&c<='9')n=n*10+c-'0';
		else return(n);
	}
}

inline char cget(){
	char c;while((c=getchar())||1)if(c>='A'&&c<='Z')return(c);
}

typedef struct _n{
	signed left;signed right;int data;unsigned char bj;int maxn;int minn;//data为乘积，bj为是否无效
    
}node;

node memchi[4000001];int gn=1;int ints[1000001],number;

inline void up(int tree){//上放操作

	int ls=memchi[tree].left,rs=memchi[tree].right;
	memchi[tree].data=(memchi[ls].data*memchi[rs].data)%317847191;
	if(memchi[ls].bj&&memchi[rs].bj){
//当子区间都不可用的话那么整段区间就都是无效的
memchi[tree].bj=1,memchi[tree].maxn=-1234567890,memchi[tree].minn=0x7fffffff;
		memchi[tree].data=1;
	}
	else{
		memchi[tree].minn=min(memchi[ls].minn,memchi[rs].minn);
		memchi[tree].maxn=max(memchi[ls].maxn,memchi[rs].maxn);
	}
}

int pow_q(int a,int b){//快速幂

	if(b==0)return(1);
	int res=pow_q(a,b>>1);
	res*=res;res%=317847191;if(b&1)res*=a,res%=317847191;
	return(res);
}

int build(int l,int r){//建树

	int tree=gn;gn++;
	if(l==r){
		memchi[tree].data=memchi[tree].maxn=memchi[tree].minn=ints[l];
	}else{int mid=(l+r)>>1;
		memchi[tree].left=build(l,mid);memchi[tree].right=build(mid+1,r);up(tree);
	}return(tree);
}

void del(int l,int r,int tree){//删除节点，树上二分

	if(l==r){
		memchi[tree].bj=1;memchi[tree].data=1;memchi[tree].data=1;memchi[tree].maxn=-1234567890;
		memchi[tree].minn=0x7fffffff;return;
	}int mid=(l+r)>>1;
//二分出这个数的位置
if(memchi[memchi[tree].left].bj||memchi[memchi[tree].right].minn<=number){
		del(mid+1,r,memchi[tree].right);up(tree);return;
	}if(memchi[memchi[tree].right].bj||memchi[memchi[tree].right].minn>number){
		del(l,mid,memchi[tree].left);up(tree);return;
	}
}

void print(int num){
	if(num<10)putchar(num+'0');
	else{
		print(num/10);putchar(num%10+'0');
	}
}

signed main(){
	int n=get(),m=get();
	for(register int i=1;i<=n;i++)ints[i]=get();
	sort(ints+1,ints+1+n);//为了满足二分的单调性排个序
    int root=build(1,n);
	for(register int i=1;i<=m;i++){
		char cmd=cget();
		if(cmd=='D'){
			number=get();del(1,n,root);
		}
		if(cmd=='B'){
			print(memchi[root].maxn);putchar('\n');
		}if(cmd=='S'){
			print(memchi[root].minn);putchar('\n');
		}if(cmd=='T'){
			print(memchi[root].data%317847191);putchar('\n');
		}if(cmd=='M'){
			print(pow_q(memchi[root].maxn,memchi[root].minn));putchar('\n');
		}
	}
	return(0);
}
```

---

## 作者：Genius_Z (赞：2)

这里讲一下堆的在线做法。

维护四个堆，两个大根堆两个小根堆，分别记为$q,delq$（大根堆），$p,delp$（小根堆）。

每次删除操作就把要删除的那个数丢进$delq和delp$里，当$q与delq$的堆顶相同时，就一直$pop$，直到堆顶不同，小根堆同理。

这样前三个操作就没了

第4个操作就是一个快速幂。

主要是操作5。

由于毒瘤出题人给的模数不是质数，求逆元必须用$exgcd$，所以维护一个变量$mulit$记录当前的模意义下的乘积，每次删除乘以逆元，遇到操作5直接输出，这题就没了。

Code：

```cpp
#include <algorithm>
#include <tuple>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <vector>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
template <class Read>
inl Read read() {
	Read x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
inl int spread() {
	register char c = getchar();
	while (c != 'D'&&c != 'B'&&c != 'S'&&c != 'M'&&c != 'T') {
		c = getchar();
	}
	if (c == 'D')return 0;
	else if (c == 'B')return 1;
	else if (c == 'S')return 2;
	else if (c == 'M')return 3;
	else return 4;
}
const int mod = 317847191;
inl int qpow(int x, int y) {
	long long ans = 1, base = x;
	while (y) {
		if (y & 1)ans = ans * base % mod;
		base = base * base % mod;
		y >>= 1;
	}
	return ans;
}
inl int exgcd(int a, int b, int &x, int &y) {
	if (!b) { x = 1, y = 0; return a; }
	re d = exgcd(b, a%b, x, y), z;
	z = x, x = y, y = z - (a / b)*y;
	return d;
}
priority_queue<int>q, delq;
priority_queue<int, vector<int>, greater<int>>p, delp;
signed main() {
	re n = read<int>(), m = read<int>();
	long long mulit = 1;
	for (re i = 1; i <= n; i++) {
		re x = read<int>();
		mulit = mulit * x % mod;
		q.push(x), p.push(x);
	}
	while (m--) {
		re op = spread();
		if (!op) {
			re x = read<int>(), b, inv, d;
			delq.push(x), delp.push(x);
			exgcd(x, mod, inv, d);
			mulit = mulit * ((inv+mod)%mod) % mod;
		}
		else if (op == 1) {
			while (!delq.empty() && delq.top() == q.top())delq.pop(), q.pop();
			printf("%d\n", q.top());
		}
		else if (op == 2) {
			while (!delp.empty() && delp.top() == p.top())delp.pop(), p.pop();
			printf("%d\n", p.top());
		}
		else if (op == 3) {
			while (!delq.empty() && delq.top() == q.top())delq.pop(), q.pop();
			while (!delp.empty() && delp.top() == p.top())delp.pop(), p.pop();
			printf("%d\n", qpow(q.top(), p.top()));
		}
		else {
			printf("%lld\n", mulit);
		}
	}
}
```



---

## 作者：nekko (赞：1)

由于只有删除操作，并且支持离线，可以读完之后从后往前当作插入来进行。

这样的话取最大，取最小，取乘积，取幂就很容易了。

```cpp
// 离线算法 快速幂

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <set>

using namespace std;

typedef long long ll;

const int N = 1000010;

const ll M = 317847191LL;

ll pow(ll a, ll b) {
    ll ret = 1;
    a %= M;
    while(b) {
        if(b & 1) {
            ret = (ret * a) % M;
        }
        b >>= 1;
        a = (a * a) % M;
    }
    return ret;
}

int n, m;

ll mx = 0xcfcfcfcfcfcfcfcfLL, mn = 0x3f3f3f3f3f3f3f3fLL, val[N], seq[N], ans[N], mul;

char op[N][5];

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1 ; i <= n ; ++ i) {
        scanf("%lld", &seq[i]);
    }
    sort(seq + 1, seq + 1 + n);
    for(int i = 1 ; i <= m ; ++ i) {
        scanf("%s", op[i]);
        if(*op[i] == 'D') {
            scanf("%lld", &val[i]);
            *(lower_bound(seq + 1, seq + 1 + n, val[i])) = 0x3f3f3f3f3f3f3f3fLL;
        }
    }
    mul = 1;
    for(int i = 1 ; i <= n ; ++ i) {
        if(seq[i] != 0x3f3f3f3f3f3f3f3fLL) {
            mx = max(mx, seq[i]);
            mn = min(mn, seq[i]);
            mul = (mul * ((ll)seq[i] % M)) % M;
        }
    }
    for(int i = m ; i >= 1 ; -- i) {
        if(*op[i] == 'D') {
            mx = max(mx, val[i]);
            mn = min(mn, val[i]);
            mul = (mul * ((ll)val[i] % M)) % M;
        } else if(*op[i] == 'B') {
            ans[i] = mx;
        } else if(*op[i] == 'S') {
            ans[i] = mn;
        } else if(*op[i] == 'M') {
            ans[i] = pow(mx, mn);
        } else if(*op[i] == 'T') {
            ans[i] = mul;
        }
    }
    for(int i = 1 ; i <= m ; ++ i) {
        if(*op[i] != 'D') {
            printf("%lld\n", ans[i]);
        }
    }
}
```

---

## 作者：Mark_ZZY (赞：0)

/\*
首先并不知道怎么用所谓的二叉堆做,思考一下因为除法是没用办法用mod运算来做的,所以可以知道一定不能能在线做

(除非用暴力打高精度),所以,我们就想到了离线:

将那些将要删除的数置之不理,先将其他数取sum,max,min,然后从后往前依次进行那5种操作,

对于删除操作,我们就将那些数加在队列里就好了(相当于进行求sum,max,min),存在ans数组里,再输出即可.

\*/
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define I inline
#define LL long long
#define R register
#define mod 317847191
#define inf 2147483647
using namespace std;
    int n,m;
    LL maxx=-2147483647,minn=2147483647,sum=1;
    LL a[1000001],p[1000001][3],ans[1000001];
I LL readint()
{
    LL x=0;
    int f=1;
    char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())
        if(ch=='-') f=-1;
    for(;ch>='0'&&ch<='9';x=(x<<3)+(x<<1)+(ch^48),ch=getchar());
    return x*f;
}
I void printint(LL x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) printint(x/10);
    putchar(x%10+'0');
}
I LL dg(LL x,LL k)
{
    if(k==0) return 1;
    LL f=dg(x,k>>1);
    if(k&1) return f*f%mod*x%mod; else return f*f%mod;
}
int main()
{
    n=readint();m=readint();
    for(R int i=1;i<=n;i++)
        a[i]=readint();
    sort(a+1,a+n+1);
    for(R int i=1;i<=m;i++)
    {
        char ch[2];
        bool bz=false;
        LL x;
        scanf("%s",ch+1);
        switch(ch[1])
        {
            case 'D':x=readint();*(lower_bound(a+1,a+n+1,x))=inf;p[i][1]=1;p[i][2]=x;break;
            case 'B':p[i][1]=2;break;
            case 'S':p[i][1]=3;break;
            case 'M':p[i][1]=4;break;
            case 'T':p[i][1]=5;break;
        }
    }
    for(R int i=1;i<=n;i++)
        if(a[i]!=inf)
        {
            sum=(sum*a[i])%mod;
            maxx=max(maxx,a[i]);
            minn=min(minn,a[i]);
        }
    for(R int i=m;i>=1;i--)
        switch(p[i][1])
        {
            case 1:ans[i]=inf;sum=(sum*p[i][2])%mod;maxx=max(maxx,p[i][2]);minn=min(minn,p[i][2]);break;
            case 2:ans[i]=maxx;break;
            case 3:ans[i]=minn;break;
            case 4:ans[i]=dg(maxx,minn);break;
            case 5:ans[i]=sum;break;
        }
    for(R int i=1;i<=m;i++)
        if(ans[i]!=inf) printint(ans[i]),putchar('\n');
}
```

---


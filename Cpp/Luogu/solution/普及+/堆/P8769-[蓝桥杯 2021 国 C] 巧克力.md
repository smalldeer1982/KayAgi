# [蓝桥杯 2021 国 C] 巧克力

## 题目描述

小蓝很喜欢吃巧克力，他每天都要吃一块巧克力。

一天小蓝到超市想买一些巧克力。超市的货架上有很多种巧克力，每种巧克力有自己的价格、数量和剩余的保质期天数，小蓝只吃没过保质期的巧克力，请问小蓝最少花多少钱能买到让自己吃 $x$ 天的巧克力。

## 说明/提示

**【样例说明】**

一种最佳的方案是第 $1$ 种买 $5$ 块，第 $2$ 种买 $2$ 块，第 $3$ 种买 $3$ 块。前 $5$ 天吃第 $1$ 种，第 $6$、$7$ 天吃第 $2$ 种，第 $8$ 至 $10$ 天吃第 $3$ 种。

**【评测用例规模与约定】**

对于 $30\%$ 的评测用例，$n,x \le 1000$。

对于所有评测用例，$1\le n,x\le 10^5$，$1 ≤ a_i,b_i ,c_i\le10^9$。

蓝桥杯 2021 国赛 C 组 I 题。

## 样例 #1

### 输入

```
10 3
1 6 5
2 7 3
3 10 10```

### 输出

```
18
```

# 题解

## 作者：Dregen_Yor (赞：19)

### [更好的阅读体验](https://dregen-yor.eu.org/2022/11/21/p8769/)。

# 思路

为了尽可能地减小吃巧克力的花费，我们考虑用一个堆来维护当前没有过期的巧克力中的最小值，我们考虑从最后一天开始向前枚举，并将当天没有过期的巧克力加入堆中，每天取堆的最小值，并判断数量是否耗尽即可。

但如果是从第一天开始遍历的话，这样算出来的答案是不对的，我们举一个样例：

``` input
5 3
1 4 3
2 1 1
10 5 5
```

```output
15
```
但如果从第一天开始遍历，结果是 $23$。

最优解应该是第一天时选择第 $2$ 种，第二，三，四天选择第 $1$ 种，第五天选择第 $3$ 种。

但如果从第一天开始遍历，就会跳过第二种巧克力，只选择第三种和第二种。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
    mutable int a,b,c;
    bool operator<(const node &B)const{
        if(a==B.a){
            return b>B.b;
        }
        return a>B.a;
    }
}w[100010];
bool cmp(node a,node b){
    return a.b<b.b;
}
int n,x,ans,maxn;
signed main(){
    scanf("%lld%lld",&x,&n);
    priority_queue<node> q;
    for(int i=1;i<=n;i++){
        scanf("%lld%lld%lld",&w[i].a,&w[i].b,&w[i].c);
        maxn=max(maxn,w[i].b);
        //q.push(w[i]);
    }
    // if(maxn<x){
    //     puts("-1");
    //     return 0;
    // }
    sort(w+1,w+1+n,cmp);
    int top=n;
    for(int i=x;i;i--){
        while(w[top].b>=i){
            q.push(w[top]);
            --top;
        }
        // if(q.empty()){
        //     puts("-1");
        //     return 0;
        // }
        ans+=q.top().a;
        q.top().c--;
        if(!q.top().c){
            q.pop();
        }
    }
    printf("%lld",ans);
    return 0;
}
```




---

## 作者：Pengzt (赞：12)

[P8769](https://www.luogu.com.cn/problem/P8769)

一道有意思的贪心题。

有一个很容易想到但是有误的贪心：从第 $1$ 天开始，每次选择单价最低的购买，直到第 $x$ 天。

但如果有一些单价**较低**且保质期极短的商品，和一些单价**最低**但保质期较长的商品，这个贪心就不会选择到单价**较低**的商品。

如果我们使时间逆流，就不会出现这样的问题，即从第 $x$ 天开始，选当前单价最小的即可。

维护当前的最小值，优先队列和 set 都可以。

时间复杂度：$\mathcal{O}(x\log n)$

[评测记录](https://www.luogu.com.cn/record/100099384)

---

## 作者：Ayaka_Li (赞：7)

## 思路

不难看出这是一道贪心，我们可以按单价排序，单价小的在前面，通过枚举每类巧克力找到最优解。

## 代码

```cpp
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;
int x,n;
const int N=1e5+10;
struct node {
	int m,d,ans;
}f[N];
bool cmp(node a,node b) {
	if (a.m==b.m) 
    		return a.d>b.d;
	return a.m<b.m;
}
int res,day,cnt;
signed main() {
	cin>>x>>n;
	for (int i=1;i<=n;i++)
		cin>>f[i].m>>f[i].d>>f[i].ans;
	sort(f+1,f+1+n,cmp);
	for (int i=1;i<=n;i++) {
		while (day<f[i].d&&f[i].ans) {
			f[i].ans--;
			day++;
			x--;
			res+=f[i].m;			
			if (!x) {
				cout<<res;
				return 0;
			}	
		}
//		cout<<i<<' '<<day<<endl;
	}
	cout<<-1;
	return 0;
}
```
如果这样交上去，恭喜你能获得 90 pts。

（以下提到巧克力均为排序后）

那为什么这样的贪心策略不对呢？

不难发现，我们的策略无论何时都是从第一类巧克力开始的。

那有没有一种可能先买第二类再买第一类呢？答案是有的，比如买完 $x$ 类后该买 $x+1$ 类了，但可能因为保质期导致买不了 $x+1$ 类直接买到 $x+2$ 类了，这时如果 $x+1$ 类的保质期 $>x$ 类的保质期，这时我们不妨先买 $x+1$ 类，所以我们需要加上特判。

```cpp
	if (f[i].d>f[i+1].d) {
		while (day<f[i+1].d&&f[i+1].ans) {
			f[i+1].ans--;
			day++;
			x--;
			res+=f[i+1].m;			
			if (!x) {
				cout<<res;
				return 0;
			}	
		}
	}
```


---

## 作者：xzq4121 (赞：7)

## update

### 2025.2.19

偶然间看到了自己以前的这篇题解，~~不能再让大家吃屎了，~~ 所以修改了解析和代码，并增加了内容。

## solution

### 方法

使用贪心。

很容易想到的一种贪心思路是从第一天开始枚举到最后一天，每一天吃一块当前可使用的所有巧克力中最便宜的一块，但如果我们仔细思考会发现酱紫贪心会有一个问题：

在前几天可能会把保质期长且**便宜**的巧克力吃完而浪费掉保质期短但**较便宜**的巧克力，然后导致最后几天只能吃保质期长但**贵**的巧克力甚至没有巧克力吃。

然后再注意到一个点：

由于有保质期的限制，若不考虑小蓝吃巧克力的话，我们可以发现每一天可使用的巧克力的数量是单调递减的，且后一天有的巧克力前一天必定会有。

因此若我们从后往前枚举，就会有两种情况：

1. 这一天的最优巧克力被后几天吃完了，那么吃次优巧克力。
2. 这一天的最优巧克力还有，那么吃最优巧克力。

这样就可以保证每一天做的都是最优决策。

例子：

| 输入 |
| :---------- |
| $12$ $5$ |
| $1$ $13$ $6$ |
| $2$ $5$ $3$ |
| $3$ $6$ $4$ |
| $10$ $100$ $100$ |
| $100$ $100$ $100$ |

| 输出 |
| :----------- |
| $21$ |

在这里，如果从前往后，第二种和第三种会被跳过，所以输出为 $66$。

### 实现

接下来考虑如何实现。

首先按保质期从大到小排序，然后开一个小根堆，里面存储巧克力的价格和数量，并以价格为第一关键字。

然后从后往前枚举每一天，把这一天新加入的可使用的巧克力入堆，接着将答案加上堆顶的巧克力的价值，并把堆顶的巧克力的数量减一，若此时数量为 $0$，则弹出堆顶。

## 复杂度分析

### 空间复杂度

开了一个大小为 $N$ 的结构体，里面存储了 $3$ 个信息，还有零散的几个变量，因此空间复杂度为 $O(N)$。

### 时间复杂度

读入复杂度是 $O(N)$，排序是 $O(N \log N)$，贪心中由于每一种巧克力只会入堆一次，所以也是 $O(N \log N)$。

则总时间复杂度为 $O(N \log N)$。

## code：
```
#include <bits/stdc++.h>
#define mp make_pair
using namespace std;
const int N=1e5+5;
int n,m,cnt=1,ans;
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
struct node
{
	int v,t,s;
}a[N];
bool cmp(node x,node y)
{
	return x.t>y.t;
}
void input()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;++i)
		scanf("%d %d %d",&a[i].v,&a[i].t,&a[i].s);	
	sort(a+1,a+m+1,cmp);
} 
void work()
{
	for(int i=n;i;--i)
	{
		while(a[cnt].t>=i)
		{
			q.push(mp(a[cnt].v,a[cnt].s));
			++cnt;
		}
		pair<int,int> x=q.top();
		q.pop();
		ans+=x.first;
		--x.second;
		if(x.second)
			q.push(x);
	}
	printf("%d",ans);
}
int main()
{
	input();
	work();
	return 0;
}
```

---

## 作者：small_john (赞：4)

## 思路

很明显，这是一道贪心题。用堆维护巧克力，把价格低的巧克力放在堆顶，同等价格，保质期低的放在堆顶。

会发现，正着做容易出现一些问题。如果有一个巧克力快到保质期但不是最优的，而最优的巧克力只剩一个，另外的巧克力价格非常高，最优解肯定是要选这个快到保质期的巧克力。但正着做就不会选。

但是，倒着做可以完美的避开这种问题，因为最优的巧克力已经在后面被用了，快到保质期的巧克力就会被选上。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

template<typename T> inline void read(T &x)
{
	x = 0;
	T f = 1;char ch = getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f = -1,ch = getchar();
			break;
		}
		ch = getchar();
	}
	while(ch>='0'&&ch<='9')
		x = (x<<3)+(x<<1)+ch-48,ch = getchar();
	x*=f;
}
template<typename T> inline T read()
{
	T x;read(x);return x;
}
template<typename T> inline void write(T x)
{
    if(x<0) x = -x,putchar('-');
    if(x<=9) return putchar(x+48),void();
    write(x/10);
    putchar(x%10+48);
}
template<typename T> inline void writen(T x)
{
    write(x);
    puts("");
}
const int N = 1e5+5; 
struct node{
	mutable int a,b,c;//价格，保质期，数量
	void init() {read(a),read(b),read(c);}
	friend bool operator < (node x,node y)
	{
		return (x.a==y.a)?(x.b>y.b):(x.a>y.a);//由于是大根堆，小于就要反着定义
	}
}a[N];
int n,k,ans;
priority_queue<node> q;
bool cmp(node x,node y) {return x.b>y.b;}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(k),read(n);
	for(int i = 1;i<=n;i++)
		a[i].init();
	sort(a+1,a+n+1,cmp);//按照保质期从大到小排序
	int now = 1;
	for(int i = k;i;--i)
	{
		while(a[now].b>=i)//加入保质期合法的巧克力 
			q.push(a[now]),++now;
		if(q.empty()) return puts("-1"),0;//没有可以选的巧克力
		ans+=q.top().a;--q.top().c;
		if(!q.top().c) q.pop();//不能继续用 
	}
	write(ans);
	return 0;
}
 ```

---

## 作者：RP_INT_MAX (赞：3)

## $\textbf{0x00 Previous}$

[题目传送门](https://www.luogu.com.cn/problem/P8769)，这里不再赘述题面。

在阅读本篇题解之前，请确保你已经熟悉贪心算法以及桶和 `priority_queue` 的使用。

## $\textbf{0x10 Solution}$

这道题的贪心策略不是那么明显。~~这可能是它成为绿题的原因~~

单纯按单价或者保质期排序是不可行的，很容易举出反例。考虑一种巧克力，它的单价最便宜，但是保质期最长，这种方法就不适用。

正难则反，我们从最后一天（即第 $x$ 天）开始考虑。

首先按保质期从长到短，将所有巧克力排序。接着，从最后一天开始，对于第 $i$ 天，求出所有满足保质期的巧克力，在它们当中选出价格最低的吃掉。当然，如果该种巧克力已全部用完，就要舍去。

因此，我们用 `priority_queue` 动态维护第 $i$ 天价格最低的巧克力，用桶维护每种巧克力用掉了几块。

至此，代码呼之欲出。

## $\textbf{0x20 Code}$

```cpp
// 以上省略头文件以及快读快输部分
typedef long long ll;
struct node{
	int id;
	ll a,b,c;
	bool operator<(const node&x)const {
		return b>x.b;
	}
	bool operator>(const node&x)const {
		return a>x.a;
	}
} a[100010];
int b[100010];
ll ans;
int x,n;
priority_queue<node,vector<node>,greater<node>>q;
int main () {
	in(x),in(n);
	for(int i=1;i<=n;++i) {
		a[i].id=i;
		in(a[i].a),in(a[i].b),in(a[i].c);
	}
	sort(a+1,a+1+n);
	int pos=1;
	for(int i=x;i;--i) {
		while(a[pos].b>=i&&pos<=n) q.push(a[pos++]);
		if(!q.size()) puts("-1"),exit(0);
		node now=q.top();
		ans+=now.a,++b[now.id];
		if(now.c==b[now.id]) q.pop();
	}
	out(ans);
	return 0;
}
```

---

## 作者：zhuguyu (赞：3)

# 思路
一道大水的绿题。

用贪心算法即可，但是有坑。最开始我想的是优先买便宜的就行了，然后成功 WA 了一个点，$90$ 分代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct p{
	ll val,day,num;
};
p a[114514];
ll n,m,ans;
bool cmp(p a,p b){
	return a.val<b.val;
}
int main(){
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].val>>a[i].day>>a[i].num;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=m;i++){
		bool flag=0;
		for(int j=1;j<=n;j++){
			if(i<=a[j].day&&a[j].num>0){
				a[j].num--;
				ans+=a[j].val;
				flag=1;
				break;
			}
		}
		if(!flag){
			cout<<-1;
			return 0;
		}
	}
	cout<<ans;
	return 0;
}
```
因为如果一个保质期很长的巧克力很便宜，数量又少，那么我们就会在前几天把这个物品买光。到了后期所有巧克力都过期了，就 WA 了。

解决方法：我们只要把 `for(int i=1;i<=m;i++)` 循环倒过来，那么我们就可以优先考虑后期，先把保质期长且最便宜的为后期买掉，就不怕后期没巧克力吃了。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct p{
	int val,day,num;
};
p a[114514];
int n,m,ans;
bool cmp(p a,p b){//排序用
	return a.val<b.val;
}
int main(){
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].val>>a[i].day>>a[i].num;
	}
	sort(a+1,a+n+1,cmp);//排序，优先把价格低的排前面
	for(int i=m;i>=1;i--){//倒着循环
		bool flag=0;//记录还有没有巧克力可以买
		for(int j=1;j<=n;j++){
			if(i<=a[j].day&&a[j].num>0){//如果巧克力没过期并且还有，就买（因为排过序所以一定是最便宜的）
				a[j].num--;//数量减少一个
				ans+=a[j].val;
				flag=1;//买到巧克力
				break;
			}
		}
		if(!flag){//如果没买到，输出-1
			cout<<-1;
			return 0;
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：Fkxxx (赞：3)

### 题目大意

有几种巧克力，数量为 $c_i$ 个，每个花费为 $a_i$，保质期 $b_i$ 天（超过保质期就不能吃了）。

每天吃一个，得出吃 $x$ 天所需的最小花费。

### 思路

考虑贪心。

先看局部最优解。对于第 $i$ 天，选择的巧克力应该是**当天未过期**，花费最小，且还有库存的巧克力。

再来看全局。不难发现，第 $i$ 天可以吃的巧克力，第 $i + 1$ 天可能就过期了。但第 $i$ 天没过期的巧克力，第 $i - 1$ 天一定也没过期。

根据这个结论，**得到第 $i$ 能选的巧克力大于等于第 $i + 1$ 天能选的巧克力**。

所以，根据贪心策略，我们应**先让选择较少的情况选**，再让选择较多的情况选才能使**全局最优**。

### 实现

应该从第 $x$ 天到第 $1$ 天选巧克力，用优先队列维护局部最优解，具体实现请参考下方代码。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int a , b , c ;
    bool operator < (const node &t) const{
        if( a != t.a ) return a > t.a ;
        return b > t.b ;
    }
} a[100005] ;
int x , n , pos = 1 , ans ;
priority_queue<node> q ;
bool cmp( node a , node b ){
    return a.b > b.b ;
}
signed main(){
    cin >> x >> n ;
    for( int i = 1 ; i <= n ; i ++ ){
        cin >> a[i].a >> a[i].b >> a[i].c ;
    }
    sort( a + 1 , a + 1 + n , cmp ) ;
    for( int i = x ; i >= 1 ; i -- ){
        while( i <= a[pos].b && pos <= n ){
            q.push( a[pos ++] ) ;
        }
        if( q.empty() ){
            cout << -1 ;
            return 0 ;
        }
        node u = q.top() ;
        q.pop() ;
        ans += u.a ;
        if( -- u.c ) q.push( u ) ;
    }
    cout << ans ;
    return 0 ;
}
```

---

## 作者：DreamLand_zcb (赞：1)

## 简要题意

[传送门。](https://www.luogu.com.cn/problem/P8769)

## 思路

1. 题目中保质期设计单调性，所以考虑用优先队列 $q$ 维护每个巧克力。

2. 贪心，从第 $x$ 天开始往第一天枚举枚举，把所有保质期能达到当前一天的所有巧克力假如队列 $q$ 中然后把所有巧克力中价格最小的吃掉就行了。

3. 判断 `-1`，把所有能达到当前一天的巧克力加入到 $q$ 时，如果 $q$ 是空的，代表这天没法吃到巧克力，输出 `-1`。

那么为什么要从后往前枚举而不是从前往后呢？

很容易就举一个反例：如果有一个巧克力，价格非常低保质期非常长，从前往后枚举时你就把它吃掉了，在以后有可能就没巧克力可以吃了。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a))
using namespace std;

int x, n;
struct node {
	int a, b, c;
}t[100005];
priority_queue<node> q;
bool operator < (node x, node y)
{
	return x.a > y.a;
}
int cmp(node x, node y)
{
	return x.b > y.b;
}
int ans = 0;
int main()
{
	ios::sync_with_stdio(false);
	cin >> x >> n;
	for(int i=1;i<=n;i++)	cin >> t[i].a >> t[i].b >> t[i].c;
	sort(t+1, t+n+1, cmp);
	int cnt = 1;//当前最后一个满足保质期的巧克力是第几个 
	for(int i=x;i>=1;i--)
	{
		while(t[cnt].b >= i && cnt)
		{
			q.push(t[cnt]);
			cnt++;
		}
		if(q.empty())	cout << -1, exit(0);
		node p = q.top();
		q.pop();
		ans += p.a;
		p.c--;
		if(p.c)	q.push(p);
	}
	cout << ans;
	return 0;
}

```

---

## 作者：Fislett (赞：1)

# 题意
有 $n$ 种巧克力，第 $i$ 种巧克力单价为 $a_i$，保质期还剩 $b_i$ 天，数量为 $c_i$。你每天都要**买且仅能买一块巧克力**，问要买 $x$ 天巧克力最少需要多少钱。

# 解题思路
很容易想到一个贪心策略：每天都选择单价最小的购买。但这个想法在大多数情况下都是错误的。

比如如下这种样例：

```
20 2
1 20 17
2 5 3
```

如果我们按照如上的贪心策略去选，极容易由于只考虑单价而没有考虑保质期而全部选择第 $1$ 种巧克力，到最后第 $1$ 种巧克力吃完了，第 $2$ 种巧克力过期了，输出 $-1$。而正确的选择应该是先买 $3$ 天第 $1$ 种巧克力，再买 $17$ 天第 $2$ 种巧克力。

那么怎样才能避免这种问题呢？

我们让时间逆流，在当前没过期的巧克力中选择单价最低的巧克力，用优先队列维护最小单价。时间复杂度 $O(x$ $\log$ $n)$，可以通过此题。

# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
struct chocolate
{
	int a, b, c;
	bool operator < (const chocolate &x) const
	{
		if (a == x.a) return b > x.b;
		return a > x.a;
	}
} a[100001];
bool cmp(chocolate a, chocolate b)
{
	return a.b > b.b;
}
int x, n, tot = 1;
long long ans;
priority_queue<chocolate> q;
int main()
{
	scanf("%d%d", &x, &n);
	for (int i = 1; i <= n; i ++) scanf("%d%d%d", &a[i].a, &a[i].b, &a[i].c);
	sort(a + 1, a + n + 1, cmp);
	for (int i = x; i; i --)
	{
		while (a[tot].b >= i) q.push(a[tot]), tot ++;
		if (q.empty()) {printf("-1"); return 0;}
		chocolate tmp = q.top();
		q.pop();
		ans += tmp.a;
		if (tmp.c > 1) q.push((chocolate){tmp.a, tmp.b, tmp.c - 1});
	}
	printf("%d", ans);
}
```


---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P8769)。

## 解题思路

贪心。

1. 将所有种类的巧克力按保质期从长到短排序，从后开始选择巧克力。

2. 对于第 $i$ 天，将所有保质期满足能在第 $i$ 天吃的巧克力按价格从小到大排序。

3. 选择其中价格最低的在第 $i$ 天吃，并记录这种巧克力已经吃了几块，如果全部都吃了，那就不能吃了。

用优先队列维护当天能吃的巧克力，用映射维护不同种类的巧克力已经吃了几块。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 100005
using namespace std;
struct node{
	int a;
	int b;
	int c;
	int id;
    bool operator<(const node &other)const{
        return a>other.a;
    }
}y[maxn];
int x,n,ans;
map<int,int>mp;
priority_queue<node,vector<node>>q;
bool cmp(node a,node b){
	return a.b>b.b;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>x>>n;
	for(int i=1;i<=n;++i){
	    cin>>y[i].a>>y[i].b>>y[i].c;
        y[i].id=i;
    }
	sort(y+1,y+n+1,cmp);
	for(int i=x,p=1;i;--i){
		while(y[p].b>=i&&p<=n)
			q.push(y[p++]);
		if(q.empty()){
			cout<<-1;
			return 0; 
		}
		ans+=q.top().a;
		if(q.top().c==++mp[q.top().id])
		    q.pop();
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：A_grasser (赞：0)

## 题意简化

有一些巧克力，它们有固定的数量、保质期与单价，求吃 $x$ 天的最小花费。

## 需要注意的地方

1. 注意选择正确的贪心解法。 

## 解法分析

用贪心解法的话，首先考虑从第一天开始从前往后枚举，选择最低价购买。但这样做会有问题，因为这种贪心会提前选单价最低但保质期较长的商品，往后枚举只剩单价大的了。

所以正确的贪心是：从后往前枚举，每次选单价最小的，这样子就不会有上面的问题。单价最小排一遍序即可。

最后说一句，我比较推荐万能头文件，这样可以省去很多不必要的麻烦。

## 完整代码

```cpp
//已通过
#include<bits/stdc++.h>
//万能头文件
using namespace std;
int x,n,ans; 
struct point{
	int a,b,c;
}q[100010];
bool cmp(point x,point y){//按保质期、价格排序 
	if(x.a==y.a) return x.b>y.b;
	return x.a<y.a;
}
int main(){
	cin>>x>>n;
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",&q[i].a,&q[i].b,&q[i].c);
	sort(q+1,q+1+n,cmp);
	int day=x;
	while(day>=1){//倒序枚举 
		bool f=0;
		for(int i=1;i<=n;i++){
			if(q[i].b>=day && q[i].c>=1){//选中了巧克力 
				q[i].c--;
				ans+=q[i].a;
				f=1;
				break;
			}
		}
		if(f==0){//没有巧克力可以选了 
			cout<<-1;
			return 0;
		}
		day--;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：0)

# 题面
[传送门](https://www.luogu.com.cn/problem/P8769)。

>题意简述：有 $n$ 种巧克力，第 $i$ 种巧克力的**单价**是 $a_i$，这种巧克力可以在第 $b_i$ 天前吃（包括 $b_i$ 天，天数从 $1$ 开始计）。这种巧克力一共有 $c_i$ 块，买完就没有了。试问如何买巧克力，使得前 $x$ 天每天都能吃巧克力，且方案价钱最小。若存在合法方案输出方案的价钱，如果不存在这样的方案，输出 $-1$。

# 分析：
可以把吃巧克力的过程这样看，小蓝一天买一个合法巧克力，将其吃掉。最后花掉的总价钱就是答案；如果某一天小蓝没有买到巧克力，说明无可行方案，直接输出 $-1$。

有一个很简单的贪心策略，我们我们可以把每一种巧克力放在一起，从前到后枚举每一天。找出这一堆巧克力中最便宜的一种，如果这种巧克力保质期已经超过了当前天数，或这种巧克力已经买了 $c_i$ 次。就将它从这堆巧克力中扔出去。因为以后几天中这种巧克力都不是合法的，不会再对答案产生贡献。如果在找的过程中，这一天所有的巧克力都不合法，就说明这一天买不到巧克力，输出 $-1$。否则另答案累加上一个 $a_i$，标记买这种巧克力的次数加一重复这个过程，直到模拟了 $x$ 天，输出答案。

但其实这种贪心策略并不正确，观察下面数据。

```
input:
3 3
1 3 2
5 1 1
100 3 5

output:7
wrong output:102
```
在这里正确的取法是先取 $1$ 个第 $2$ 种，两个第 $1$ 种，价钱为 $7$。
那我们的策略如何选择呢？

$\mathrm{Day1}$ ：取出一个第 $1$ 种。

$\mathrm{Day2}$ ：取出一个第 $1$ 种。

$\mathrm{Day3}$ ：第 $1$ 种被取完，第 $2$ 种过期，取出一个第 $3$ 种。

价钱和：$1+1+100=102$。

发现问题了吗？对于第 $1$ 种，我们如果在第 $1,2$ 天取它，那么第 $2$ 种就会过期；但如果我们在第 $2,3$ 天取它，那么我们还可以在第 $1$ 天取第 $2$ 种。

因此，在第几天买某一种巧克力也会影响答案，我们就要转变贪心策略。对于一种巧克力，能更晚买它就更晚买它，例如上面，对于第 $1$ 种巧克力，我们应在第 $2,3$ 天购买而不是第 $1,2$ 天购买。
# 做法一：二叉堆
## 实现：
观察上述的思路，我们需要在某一时刻把若干种巧克力放入一个数据结构，要求能取出当前价格最小巧克力以及删除不合法的巧克力，操作的时间复杂度均在 $O(\log n)$，以内。其实 STL 中的优先队列（也就是二叉堆）就能满足其操作。

代码实现很简单，期初堆为空，从第 $x$ 天开始倒退；如果在第 $k$ 天开始，有某几种巧克力的过期日期 $b_i\ge k$，就将这几种巧克力入堆。然后进行和上面同样的操作。就能完美解决问题了。
## Code：
十年 OI 一场空，_______ 。
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=1e5+10;
struct node{
    ll a,b,c;
}v[N];
bool operator < (const node u,const node v){
    return u.a>v.a;
}//重载小于号
bool cmp(node a,node b){
    return a.b>b.b;
}//排序函数
priority_queue<node>q;
ll n,x,ans,it=1,l=114514;
int main(){
	scanf("%lld %lld",&x,&n);
    for(int i=l;i<=n;i++){
        node t;
        scanf("%lld %lld %lld",&t.a,&t.b,&t.c);
        v[i]=t;
    }
    sort(v+l,v+l+n,cmp);
    for(int day=x;day>=1;day--){
        while(it<=n&&v[it].b>=day)q.push(v[it]),it++;//把没入堆的push进去
        while(q.size()&&q.top().c==0)q.pop();//删除堆顶不合法巧克力
        if(!q.size()){
            printf("-1\n");//判断无解情况
            return 0;
        }
        node t=q.top();q.pop();
        t.c--,ans+=t.a;
        q.push(t);
    }
    printf("%lld\n",ans);
    return 0;
}
```

[AC记录。](https://www.luogu.com.cn/record/142213700)

# 做法二：并查集
## 实现：
先将每组每种巧克力按照价格排序，然后轮流判断这种巧克力会在那几天吃。

按照上述的思路，假设我们要找到我们会在第几天吃第 $k$ 种巧克力。朴素算法是：按照 $b_k,b_k-1,b_k-2\dots 1$ 的顺序去找，在找的过程中， $c_k$ 个没买巧克力的天数但没枚举到第 $1$ 天或枚举到第 如果已经找到了$1$ 天但还没 找到$c_k$ 个没买巧克力的天数，都是直接退出当前循环，时间复杂度 $O(n^2)$。

我们用可以用一个并查集 $f_i$ 表示当前第 $i$ 天及以前第一个没买巧克力的某一天。起初，每个日子 $i$ 自己是一个集合（$f_i=i$）。每当我们确定要在第 $t$ 天买巧克力，就将日子 $i$ 这个集合并入日子 $i-1$($f_i=f_{i-1}$)。每次直接转移即可，时间复杂度 $O(n\alpha(n))$，其中 $\alpha(n)$ 表示反阿克曼函数。

题目中一个对于并查集很恶习的坑点，由于 $b_i \le 10^9$，如果直接查找 $f_{b_i}$ 会越界，所以要特判边界，如果 $b_i > x$，就直接查找 $f_x$ 即可。

## Code:
~~其实不开 long long 也能过~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef int ll;
const int N=1e5+10;
inline int read(){
    int r=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')r=(r<<1)+(r<<3)+(ch^48),ch=getchar();
    return r;
}
void write(int r){
    if(r>9)write(r/10);
    putchar(r%10+'0');
    return;
}
struct node{
    ll a,b,c;
}v[N];
bool cmp(node a,node b){
    return a.a<b.a;
}
ll n,x,ans,f[N],l=114514;
ll found(ll t){
	if(t>x)return found(x);
	return f[t]==t?t:f[t]=found(f[t]);
} 
int main(){
	x=read(),n=read();
    for(int i=1;i<=n;i++){
       v[i].a=read(),v[i].b=read(),v[i].c=read();
    }
    sort(v+1,v+1+n,cmp);
    for(int i=1;i<=x;i++)f[i]=i;
    for(int i=1;i<=n;i++){
    	for(int j=found(v[i].b);v[i].c&&j!=0;j=found(j-1))
   		    ans+=v[i].a,v[i].c--,f[j]=found(f[j-1]);
	} 
	for(int i=l;i<=x;i++){
		if(f[i]==i){
			write(-1);
			return 0;
		}
	}
    write(ans);
    return 0;
}
```

历经艰苦卓绝的卡常，把时间卡到了 rk2 !!!

[AC记录。](https://www.luogu.com.cn/record/142621976)

如有错误，请指出。

## 后话
2024 的第一篇题解！

快期末考试，最近一段时间就不碰信奥了。

---


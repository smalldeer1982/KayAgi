# [蓝桥杯 2024 国 Java A] 基因组合

## 题目描述

在医学领域，两位杰出的医生，小蓝和小乔，正在研究一种新型的基因治疗方案。他们需要从 $n$ 个候选基因中分别选择一个，并通过某种特定的运算将它们组合起来，以评估治疗方案的有效性。

已知这 $n$ 个候选基因可以用一个数组 $\{a_1, a_2, \cdots, a_n\}$ 来表示，其中 $a_i$ 代表第 $i$ 个基因的特性数值。而将两个基因组合起来的方式，则是将它们的特性数值进行异或运算（用符号 $\oplus$ 表示）。

小蓝倾向于激进的治疗方案，他总是希望所选基因组合的异或值尽可能大，以获得显著的治疗效果。小乔则更注重治疗的稳定性，他总是希望所选基因组合的异或值尽可能小，以降低治疗风险。

现在，两位医生需要决定先后选择的顺序。

假设双方都足够聪明，且都会使用最佳策略来最大化或最小化基因组合的异或值。请问，如果小蓝先选择基因，小乔后选择，那么他们能够得到的基因组合的最大异或值会是多少？反之，如果小乔先选择基因，小蓝后选择，那么他们能够得到的基因组合的最小异或值又会是多少？

## 说明/提示

### 样例说明

在给定样例中，候选基因的数量为 $4$，特性数值分别为 $2$、$3$、$5$ 和 $6$。

当小蓝先选择基因时，小蓝可以选择特性值为 $6$ 的基因，使基因组合的异或值尽可能大，小乔则会选择特性值为 $5$ 的基因，使基因组合的异或值尽可能小：$6 \oplus 5 = 3$。

当小乔先选择基因时，小乔可以选择特性值为 $6$ 的基因，使基因组合的异或值尽可能小，小蓝则会选择特性值为 $3$ 的基因，使基因组合的异或值尽可能大：$6 \oplus 3 = 5$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$2 \leq n \leq 10^3$，$1 \leq a_i \leq 10^5$。
- 对于所有评测用例，$2 \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
4
2 3 5 6```

### 输出

```
3 5```

# 题解

## 作者：hjhAKIOI (赞：3)

## P12290 [蓝桥杯 2024 国 Java A] 基因组合 题解

[题目链接](https://www.luogu.com.cn/problem/P12290)

先考虑对于小蓝先选的情况。

不妨枚举小蓝选哪个数。设小蓝选的数为 $a_i$。

那么，小乔为了使结果最小，会选择与 $a_i$ 异或结果最小的数。此时问题转化为对于一个 $a_i$，如何求出序列中 $a_i$ 和其他数异或的结果的最小值。如果可以解决这个问题，那么我们可以知道小蓝选每个数时最后得到的结果，选其中最大的作为答案即可。

这个问题非常经典，可以使用 $\text{01-Trie}$ 来解决。

先考虑求 $\min_{1\le j<i} a_j\oplus a_i$，那么正序遍历每个 $a_i$，先在 $\text{01-Trie}$ 里查询，再将 $a_i$ 插入字典树即可。

然后将正序遍历改为倒序遍历，即可求出 $\min_{i<j\le n} a_j\oplus a_i$。那么，$\min_{j\neq i} a_i\oplus a_j=\min\{\min_{1\le j<i} a_j\oplus a_i,\min_{i<j\le n} a_j\oplus a_i\}$。

对于所有 $a_i$，取 $\min_{j\neq i} a_i\oplus a_j$ 的最大值即是第一问答案。

第二问也是类似的。将上面全部的最大、最小反过来即可。

于是容易写出代码。
```cpp
#include<iostream>
using namespace std;
const int N=1e5+5,INF=0x7fffffff;
int n,tot,ans1,ans2=INF;
int a[N],trie[N*30][2],Min[N],Max[N];

void Insert(int x){
	int p=0;
	for(int i=30;i>=0;i--){
		int bit=x>>i&1;
		if(!trie[p][bit]){
			trie[p][bit]=++tot;
			trie[tot][0]=trie[tot][1]=0;
		}
		p=trie[p][bit];
	}
}

int Ask_max(int x){
	int p=0,res=0;
	for(int i=30;i>=0;i--){
		int bit=x>>i&1;
		if(!trie[p][!bit]) p=trie[p][bit];
		else p=trie[p][!bit],res+=(1<<i); 
	}
	return res;
}

int Ask_min(int x){
	int p=0,res=0;
	for(int i=30;i>=0;i--){
		int bit=x>>i&1;
		if(!trie[p][bit]) p=trie[p][!bit],res+=(1<<i);
		else p=trie[p][bit]; 
	}
	return res;
}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],Min[i]=INF;
	for(int i=1;i<=n;i++){
		Min[i]=min(Min[i],Ask_min(a[i]));
		Max[i]=max(Max[i],Ask_max(a[i]));
		Insert(a[i]);
	}
	trie[0][0]=trie[0][1]=0;
	for(int i=n;i;i--){
		Min[i]=min(Min[i],Ask_min(a[i]));
		Max[i]=max(Max[i],Ask_max(a[i]));
		Insert(a[i]);
	}
	for(int i=1;i<=n;i++){
		ans2=min(ans2,Max[i]);
		ans1=max(ans1,Min[i]);
	}
	cout<<ans1<<' '<<ans2;
	return 0;
}

```

---

## 作者：pbds_ (赞：1)

~~很好，模拟赛又让我水了一篇题解。~~

以下把小蓝记为 A，小乔记为 B。

不难发现，A 的策略一定是选择一个数，使得这个数与数组中另外一个数的异或和的最小值最大，因为 B 必定选择这个最小值。B 的情况也是相同的，只是变成了让这个数与数组中另外一个数的异或和的最大值最小。

暴力是 $O(n^2)$，不可行。

既然是两个数异或，那么首选 01 Trie，不会的可以去看 [P10471](https://www.luogu.com.cn/problem/P10471)。

但是这样还有一个问题：在求一个数与其他数异或的最小值的时候，会出现选到自己的情况，这时返回值会变成 $0$。解决这个问题其实很简单，只需要在求一个数与其他数异或的最小值之前，先临时把这个数对应的节点删除掉就可以了，具体可以看代码实现。

时间复杂度 $O(n \log V)$，其中 $V$ 是值域。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N=1e5;
constexpr int W=32;
struct node{
    int son[2];
    int cnt;
    bool disabld;
}nd[N*W+5];
int tt=0;
void insert(int x){
    int y=0;
    for(int i=31;i>=0;i--){
        nd[y].cnt++;
        int w=(x>>i)&1;
        if(!nd[y].son[w]){
            nd[y].son[w]=++tt;
            y=tt;
        }
        else y=nd[y].son[w];
    }nd[y].cnt++;
}
int getmax(int x){
    int ans=0,y=0;
    for(int i=31;i>=0;i--){
        int w=(x>>i)&1;
        if(!nd[y].son[w^1]){
            y=nd[y].son[w];
        }
        else y=nd[y].son[w^1],ans+=(1<<i);
    }
    return ans;
}
void disable(int x){
    int y=0;
    for(int i=31;i>=0;i--){int w=(x>>i)&1;
        y=nd[y].son[w];
        if(nd[y].cnt==1)nd[y].disabld=1;
    }
}
void enable(int x){
    int y=0;
    for(int i=31;i>=0;i--){int w=(x>>i)&1;
        y=nd[y].son[w];
        nd[y].disabld=0;
    }
}
int getmin(int x){
    int ans=0,y=0;
    for(int i=31;i>=0;i--){
        int w=(x>>i)&1;
        if(!nd[y].son[w]||nd[nd[y].son[w]].disabld){
            y=nd[y].son[w^1];ans+=(1<<i);
        }
        else y=nd[y].son[w];
    }
    return ans;
}
int a[100005];
int main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];insert(a[i]);
    }
    int mx=0,mn=2E9;
    for(int i=1;i<=n;i++){
        disable(a[i]);
        mx=max(mx,getmin(a[i]));
        enable(a[i]);
        mn=min(mn,getmax(a[i]));
    }
    cout<<mx<<" "<<mn;
    return 0;
}
```

---


# [JSOI2009] 电子字典

## 题目描述


人们在英文字典中查找某个单词的时候可能不知道该单词的完整拼法，而只知道该单词的一个错误的近似拼法，这时人们可能陷入困境，为了查找一个单词而浪费大量的时间。带有模糊查询功能的电子字典能够从一定程度上解决这一问题：用户只要输入一个字符串，电子字典就返回与该单词编辑距离最小的几个单词供用户选择。

字符串 $a$ 与字符串 $b$ 的编辑距离是指：允许对 $a$ 或 $b$ 串进行下列“编辑”操作，将 $a$ 变为 $b$ 或 $b$ 变为 $a$，最少“编辑”次数即为距离。

1. 删除串中某个位置的字母；
2. 添加一个字母到串中某个位置；
3. 替换串中某一位置的一个字母为另一个字母。

JSOI 团队正在开发一款电子字典，你需要帮助团队实现一个用于模糊查询功能的计数部件：对于一个待查询字符串，如果它是单词，则返回 $-1$；如果它不是单词，则返回字典中有多少个单词与它的编辑距离为 $1$。

## 说明/提示

### 样例解释

- `abcd` 在单词表中出现过；
- `abc` 与单词 `abcd`、`aabc` 的编辑距离都是 $1$；
- `abcdd` 与单词 `abcd`、`abcde`、`abced` 的编辑距离都是 $1$。

### 数据范围与约定

- 所有单词互不相同，但是查询字符串可能有重复；
- 对 $50\%$ 的数据范围，$N,M\le 10^3$；
- 对 $100\%$ 的数据范围，$N,M\le 10^4$。

## 样例 #1

### 输入

```
4 3
abcd
abcde
aabc
abced
abcd
abc
abcdd```

### 输出

```
-1
2
3```

# 题解

## 作者：Utsuji_risshū (赞：23)

这道题用Trie树做的话，建好树之后对于每一个查询单词，其实就是暴力枚举出其添加1个字母、替换1个字母或者删去1个字母后的字符串在不在树上。具体枚举的话可以循环模拟~~但我太弱了写不出来~~，有点繁。这里我用的是DFS，相当于是在Trie树上做3种查找，等效于3种编辑方式。我们用DFS(root,length,f)表示目前在查root节点的孩子中是否有s[length]这一位的字符，f表示“编辑”机会是否用过。

1.删除：相当于忽略当前字符在树上的存在，直接跳到下一个字符继续找，即进行DFS(root,length+1,1)；

2.添加：相当于在root孩子中继续查剩下s[length]~s[size-1]的串，即进行DFS(Trie[root][i],length,1),这里是要枚举26种情况的;

3.替换：相当于在root孩子中继续查剩下s[length+1]~s[size-1]的串，即进行DFS(Trie[root][i],length+1,1),这里也要枚举26种情况，**并且替换字母不能和后一位字符相同**；

此外，除以上3种查询方式，还有最基本的Trie树查询，即字符串不经过修改是否存在。然后就没什么问题了，注意防止不同的修改出现相同串即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=10000+7;
int Trie[MAXN*20][26],visx[MAXN];//visx[i]存足修改要求后的字符串末节点 
char s[22];
bool p[MAXN*20],vis[MAXN*20],word;//p表示p[rt]是否是单词节点，vis[rt]表示rt是否已经是满足修改要求后的字符串 
int n,m,u,len,tot,vistot;

void Insert(){
	u=0,len=strlen(s);
	for(register int i=0;i<len;++i){
		int c=s[i]-'a';
		if(!Trie[u][c]) Trie[u][c]=++tot;
		u=Trie[u][c];
	}
	p[u]=1;
}

void DFS(int rt,int l,bool f){
	if(l==len&&p[rt]&&!f){
		word=1;return;
	}//Trie树本来就存在的 
	if(l==len&&p[rt]&&f){
		if(!vis[rt]) vis[visx[++vistot]=rt]=1;
		return;
	}//经过修改而存在的标记下来，那句赋值没看懂的话就是vis标记一下，同时往visx里装 
	int c=s[l]-'a';
	if(!f){
		if(l<len) DFS(rt,l+1,1);//l=len无意义 
		for(register int i=0;i<26;++i)
			if(Trie[rt][i]){
				DFS(Trie[rt][i],l,1);
				if(i!=c) DFS(Trie[rt][i],l+1,1);
			}//添加和替换可以合起来 
	}
	if(l>=len) return;//长度到了但没单词，返回。注意到len长度是也是可以添加的。 
	if(Trie[rt][c]) DFS(Trie[rt][c],l+1,f);//直接查 
}

int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;++i) scanf("%s",s),Insert();
	for(register int i=1;i<=m;++i){
		scanf("%s",s);len=strlen(s);
		DFS(0,0,0);
		if(word) printf("-1\n");
		else printf("%d\n",vistot);
		while(vistot) vis[visx[vistot--]]=0;//把记录都倒掉 
		word=0;
	}
}
```
感谢JimmyL发现的一处错误

---

## 作者：Iscream2001 (赞：13)

本来想能不能用字典树什么的。。。

然后发现写个hash就能过了2333

对于每个询问考虑是否已经存在一个单词与字符串相同。。这个用map映射一下，输出-1

剩下情况肯定不存在单词与字符串完全相同了
考虑3种情况：

1.删除一个字母。。。枚举删去第几个字母，比较简单。。

2.添加一个字母。。。相当于在在单词里删去字母。。。预处理一下然后用1的方法。。。

3.修改一个字母。。。这个用二维map也是可以水过的。。。显然就是单词和字符串都删去同一个位置上的字母然后比对。。。

还有要注意的就是对于任意一种情况应该先算出所有hash值，离散化之后再在map中询问，不然会重复统计。。

于是这道题就结束了。。。。

代码
```cpp
#include<iostream>
#include<map>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define ull unsigned long long
using namespace std;
int n,m,len,ans,cnt;
char s[25];
ull B=31,l[25],r[25],bin[25],H,h[25];
map<ull,ull> a[25],b[25][25],c[25];
int main(){
	scanf("%d%d",&n,&m);
	bin[0]=1;
	for(int i=1;i<25;++i) bin[i]=bin[i-1]*B;
	for(int i=1;i<=n;++i){
		scanf("%s",s+1);len=strlen(s+1);
		for(int j=0;j<25;++j) l[j]=r[j]=h[j]=0;
		for(int j=1;j<=len;++j) l[j]=l[j-1]*B+s[j]-'a'+1;
		for(int j=len;j>=1;--j) r[j]=r[j+1]+(s[j]-'a'+1)*bin[len-j];
		++a[len][l[len]];
		for(int j=1;j<=len;++j){
			h[j]=l[j-1]*bin[len-j]+r[j+1];++b[len-1][j][h[j]];
		}
		//cout<<l[len]<<endl;
		//for(int j=1;j<=len;++j) cout<<h[j]<<" ";cout<<endl;
		sort(h+1,h+1+len);cnt=1;
		for(int j=2;j<=len;++j) if(h[j]!=h[j-1]) h[++cnt]=h[j];
		for(int j=1;j<=cnt;++j) ++c[len-1][h[j]];
	}
	for(int i=1;i<=m;++i){
		scanf("%s",s+1);len=strlen(s+1);
		for(int j=0;j<25;++j) l[j]=r[j]=h[j]=0;
		for(int j=1;j<=len;++j) l[j]=l[j-1]*B+s[j]-'a'+1;
		for(int j=len;j>=1;--j) r[j]=r[j+1]+(s[j]-'a'+1)*bin[len-j];
		if(a[len][l[len]]){
			printf("-1\n");continue;
		}
		ans=0;
		for(int j=1;j<=len;++j) h[j]=l[j-1]*bin[len-j]+r[j+1];
		//cout<<l[len]<<endl;
		//for(int j=1;j<=len;++j) cout<<h[j]<<" ";cout<<endl;
		for(int j=1;j<=len;++j) ans+=b[len-1][j][h[j]];
		sort(h+1,h+1+len);cnt=1;
		for(int j=2;j<=len;++j) if(h[j]!=h[j-1]) h[++cnt]=h[j];
		for(int j=1;j<=cnt;++j) ans+=a[len-1][h[j]];
		ans+=c[len][l[len]];
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：Cry_For_theMoon (赞：9)

[传送门](https://www.luogu.com.cn/problem/P4407)

主要是补充一下dfs的一些细节说明。

拿到这道题我1分钟（花了30s算复杂度）就想到了trie上dfs的套路，代价就是我样例调了1h没有发现dfs的问题。最后看到题解代码时发现有三处不同：

- “删除”操作的dfs中，你删了以后枚举下一位字符，那个字符不能是当前删的那个。

- “添加”操作的dfs中，添加字符以后枚举下一位字符，添加的字符也不能是当前删的那个。

- “修改”操作的dfs中，修改后的字符不能是本来这一位的字符。

最后一个很好理解，因为这种情况等于不作修改。那前两种情况呢？

A如果删除一个字符到B，它们在字典树上的路径应该是这样的：先到lca然后分叉下去，而且分叉下去的两条路径（路径指单词节点上行到lca为止且不包括lca）抛开A这条路径最上面（即lca的下面）的那个节点（因为这个删掉了）是相同的。

删了之后枚举下一位字符，就是枚举那个"A这条路径最上面"的点的兄弟。如果枚举的字符还是我删的字符，在trie树上就根本还是一条路径。这样第一个问题解决了。

还剩下添加操作。相同地去思考它们在字典树上从根到单词节点的路径。其实就是把A那个“多出”的节点添加到了“B”上——因为这个字符是A原本没有，B原本有的。此时我们枚举那个添加的字符，还是等于枚举“A这条路径最上面”的那个节点的兄弟。换言之，在trie树上又双叒叕是同一条路径。也就是说这三种情况对应了一种“假修改”。如果题意中编辑距离是 **小于等于1** 的话，这三个细节就需要加上吗？还是不需要，因为如果你“假修改”修改到了末尾，那就是询问串本身。如果你“假修改”到了一定程度变成“真修改”了，那么在这题中的dfs就一样解决了。

总结：把添加/删除/修改操作的位置看作两个单词的lca，且两个儿子必定在lca的不同子树中。如果枚举的还是原字符，在树中就是一颗子树了，不符合题意。我认为对这处细节的分析还是很有意义的~~毕竟会trie树板子的最后都能独立想到是trie上dfs~~

最后（据作者的惨痛经验）提醒：dfs爆搜一时爽，枚举到头不判tag火葬场。（如果WA 20pts就能明白）

```cpp
//JSOI,2009
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=1e4+10,MAXALPHA=2e5+10;
char words[MAXN][30],ques[30];
int n,m,cnt,len[MAXN];
struct Trie{
	int sz,next[MAXALPHA][26],val[MAXALPHA];
	inline int idx(char c){return c-'a';}
	inline void insert_str(char *s,int len){
		int u = 0;
		for(int i=0;i<len;i++){
			int c = idx(s[i]);
			if(!next[u][c]){
				next[u][c] = ++sz;
			}
			u = next[u][c];
		}
		val[u] = 1;
	}
	inline bool find_str(char* s,int len){
		int u = 0;
		for(int i=0;i<len;i++){
			int c = idx(s[i]);
			if(!next[u][c]){
				return false;
			}
			u = next[u][c];
		}
		return val[u];
	}
	void dfs1(char* s,int u,int len,int now,bool flag){
		//删除一个字符
		if(now == len && val[u] && flag){cnt++;return;}
		//全删了，全删了，哦耶
		if(now == len-1 && val[u] && !flag){cnt++;return;} 
		if(flag){
			//正常做
			int c = idx(s[now]);
			if(next[u][c]){
				dfs1(s,next[u][c],len,now+1,1);
			}
			return; 
		} 
		//珂删珂不删
		int c = idx(s[now]);
		if(next[u][c]){
			dfs1(s,next[u][c],len,now+1,0); //不删 
		}
		for(int i=0;i<26;i++){
			if(!next[u][i])continue;
			if(i==c)continue;
			if(i == idx(s[now+1])){
				dfs1(s,next[u][i],len,now+2,1); //删 
			}
		} 
	}
	void dfs2(char* s,int u,int len,int now,bool flag){
		//添加一个字符
		if(now==len && val[u] && flag){cnt++;return;}
		//全加上，全加上，哦耶
		if(now==len &&!flag){
			for(int j=0;j<26;j++){
				if(next[u][j] && val[next[u][j]]){cnt++;}
			}
			return;
		} 
		if(flag){
			int c = idx(s[now]);
			if(next[u][c]){
				dfs2(s,next[u][c],len,now+1,1);
			}
			return;
		}
		int c = idx(s[now]);
		if(next[u][c]){
			dfs2(s,next[u][c],len,now+1,0); //不添加 
		} 
		for(int i=0;i<26;i++){
			if( (!next[u][i]) || i==c)continue;
			if(next[next[u][i]][c]){
				dfs2(s,next[next[u][i]][c],len,now+1,1); //添加 
			}
		} 
	}
	void dfs3(char*s,int u,int len,int now,bool flag){
		//改变一个字符
		if(now==len && val[u] && flag){cnt++;return;}
		if(flag){
			int c = idx(s[now]);
			if(next[u][c])dfs3(s,next[u][c],len,now+1,1);
			return;
		}
		int c = idx(s[now]);
		if(next[u][c]){
			dfs3(s,next[u][c],len,now+1,0);
		}
		for(int i=0;i<26;i++){
			if( (!next[u][i])  || i==c)continue;
			dfs3(s,next[u][i],len,now+1,1);
		}
	}
}trie;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",words[i]);
		len[i] = strlen(words[i]);
		trie.insert_str(words[i],len[i]);	
	}
	for(int i=1;i<=m;i++){
		scanf("%s",ques);
		int sz = strlen(ques);
		if(trie.find_str(ques,sz)){
			printf("-1\n");continue;
		}
		cnt = 0;
		trie.dfs1(ques,0,sz,0,0);
		trie.dfs2(ques,0,sz,0,0);
		trie.dfs3(ques,0,sz,0,0);
		printf("%d\n",cnt);
	}
	return 0;
}

```


---

## 作者：quantum11 (赞：8)

感觉这道题目思路还是很清晰的

存下每一个单词的hash值，查询时分类讨论。

每个字符串先正反分别预处理hash值

先判断是否是单词

1.枚举删除的位置，但注意如果有类似$abba$的情况，删去两个$b$的效果是一样的，要去重。

2.枚举添加的位置和添加的字母，注意在一个字母前后添加一个与它相同的字母的效果是一样的。

3.枚举位置和字母，比较简单。

```
#include<bits/stdc++.h>
#define il inline
#define rint register int
#define ull unsigned long long 
using namespace std;
const int N=1e5+5;const ull B=233;
ull h[N],H[25],S[N],b[25];
int n,m;char s[25]; 
il int find(ull x){
	rint l=1,r=n,mid;
	while(l<=r) (h[mid=l+r>>1]<=x)?l=mid+1:r=mid-1;
	return h[l-1]==x&&x;
}
int main(){
	ios::sync_with_stdio(0);
	b[0]=1;for(rint i=1;i<=21;++i) b[i]=b[i-1]*B;
	cin>>n>>m;
	for(rint i=1;i<=n;++i){
		cin>>s+1;
		for(rint j=1,lg=strlen(s+1);j<=lg;++j) h[i]=h[i]*B+s[j]-96;
	}
	sort(h+1,h+n+1);
	while(m--){
		cin>>s+1;rint lg=strlen(s+1),ct=0;S[lg+1]=0;
		for(rint i=1;i<=lg;++i) H[i]=H[i-1]*B+s[i]-96;
		for(rint i=lg;i>=1;--i) S[i]=S[i+1]+(s[i]-96)*b[lg-i];
		if(find(H[lg])){printf("-1\n");continue;}
		for(rint i=0;i<lg;++i) if(s[i]^s[i+1])
		if(find(H[i]*b[lg-i-1]+S[i+2])) ++ct;
		for(rint i=0;i<=lg;++i) for(rint j=1;j<=26;++j) if(j!=s[i]-96)
		if(find(H[i]*b[lg-i+1]+j*b[lg-i]+S[i+1])) ++ct;
		for(rint i=1;i<=lg;++i) for(rint j=1;j<=26;++j)
		if(find(H[lg]+(j-s[i]+96)*b[lg-i])) ++ct;
		printf("%d\n",ct);
	}
	return 0;
}
```
跑得有点慢

---

## 作者：KaisuoShutong (赞：6)

这是一道 字典树 题目。

## 题目大意

> 对于多个字符串，查询其在字典树上的存在性或删除/插入/替换一个字符后存在的个数。

## 题目分析

首先，对于这些串建立字典树。  
在字典树上 $Dp$ 显然太过麻烦，我们考虑使用 $Dfs$ 构建可能的字符串。

因为是在字典树上搜索，所以第一维状态是显然的——**当前处于字典树上的什么节点**，其目的是方便我们转移到下一个节点。  
为了知道什么时候字符串构建完毕，我们设置第二维状态——**当前已构建的字符串长度**。这样设的另一个好处是可以方便我们确定匹配字符串上正在处理的位置。  
第三维状态的设定则旨在完成题目的特殊条件。它被设置为**是否使用过编辑功能**，以便确定接下来的转移中可否修改字符串。

综上，我们设置当前状态为 `Dfs(x,lth,fu)`。考虑转移。  

第一种转移方法即为不使用编辑，直接匹配。这种转移不需要考虑第三维状态的限制。
```cpp
if(ch[x][s[lth]-'a']) Mapping(ch[x][s[lth]-'a'],lth+1,fu);
```
第二种转移方法即为使用一次编辑。这种转移需要在第三维状态为未使用过时才可进行。具体地，分为以下三种情况：  
1. 对于删除操作，当前字符可以直接跳过；
```cpp
if(lth<len) Mapping(x,lth+1,1);//删除
```
2. 对于插入操作，直接前往下一个节点转移当前的字符即可；
3. 对于替换操作，即为删除和插入操作的结合。需注意的一点是插入字符不可与删除字符相同。
```cpp
for(int i=0;i<26;i++)
	if(ch[x][i])
	{
		Mapping(ch[x][i],lth,1);//插入
		if(i!=(s[lth]-'a')) Mapping(ch[x][i],lth+1,1);//替换
	}
```

最后，对于构造长度等于要求长度且存在的字符串按是否编辑过分别统计答案即可。

~~掐头去尾~~代码如下。

```cpp
void Insert(char*S)
{
	int x=0;
	for(int i=0;i<strlen(S);i++)
		if(ch[x][S[i]-'a']) x=ch[x][S[i]-'a'];
		else x=ch[x][S[i]-'a']=++dot;
	ed[x]=1;
}
void Mapping(int x,int lth,int fu)//当前节点 当前长度 是否编辑 
{
	if(lth==len&&ed[x]&&!fu) return ori=1,void(0);
	if(lth==len&&ed[x])
	{
		if(!v[x]) v[q[++q[0]]=x]=1;
		return;
	}
	if(!fu)
	{
		if(lth<len) Mapping(x,lth+1,1);//Delete
		for(int i=0;i<26;i++)
			if(ch[x][i])
			{
				Mapping(ch[x][i],lth,1);//Add
				if(i!=(s[lth]-'a')) Mapping(ch[x][i],lth+1,1);//Replace
			}
	}
	if(lth==len) return;
	if(ch[x][s[lth]-'a']) Mapping(ch[x][s[lth]-'a'],lth+1,fu);
}
signed main()
{
	n=read(),m=read();
	while(n--) rein(s),Insert(s);
	while(m--)
	{
		rein(s),ori=0,len=strlen(s),Mapping(0,0,0);
		if(ori) printf("-1\n");
		else printf("%d\n",q[0]);
		while(q[0]) v[q[q[0]--]]=0;
	}
	return 0;
}
```

---

## 作者：Phykyer (赞：4)

首先读题意：题目给出一些字符串和一些询问，对于每个询问需要判断当前字符串是否与给出的重复或者经过一次修改操作可以变为的字符串数量  

显然的字符串操作题，可以很直接的联想到 $trie$ 树，再思考利用 $trie$ 树如何完成询问。  

首先，对于判断是否相同的询问显然就是裸的 $trie$ 树匹配查询操作。不会的出门左转[这道题](https://www.luogu.org/problem/P2580)  

这道题的难点就在于如何处理编辑距离为 $1$ 的字符串个数，仔细思考便可以想到一个简单的做法，就是对于当前字符串，暴力枚举所有对于它编辑距离为 $1$ 的字符串然后再跑匹配。因为字符串最长长度为 $20$ ，计算得出每个字符串只有大概 $1000$ 种不同的编辑距离为 $1$ 的字符串，复杂度显然可过。  

而本题解则是在此基础上再进行了优化，在 $trie$ 上跑 $dfs$ ，只需记录当前的串是否操作过（即编辑距离是否已为 $1$ ），然后按 $trie$ 的基本操作进行匹配即可，另外就是一些小细节的处理，可以看代码中的注释。  

以下是代码  

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;

int n, m, ans;
int trie[200010][26], tot = 1;
bool end[200010];
char s[25];

inline void insert(char *str) {// 基本的插入操作
	int p = 1, len = strlen(str);
	for (int i = 0; i < len; i++) {
		int ch = str[i] - 'a';
		if (!trie[p][ch]) trie[p][ch] = ++tot;
		p = trie[p][ch];
	}
	end[p] = 1;
}

inline bool search(char *str) {// 裸的匹配操作
	int p = 1, len = strlen(str);
	for (int i = 0; i < len; i++) {
		p = trie[p][str[i] - 'a'];
		if (!p) return 0;
	}
	return end[p];
}

inline void dfs1(int p, int l, bool change) {
	// 对于改变一个字符的情况的dfs
	// p是节点编号,l是当前匹配到的字符串位数,change记录是否操作过.下同
	if (l == strlen(s) && end[p]) { ans++; return; }
	// 匹配到最后一位则答案加一
	if (change) {
		// 如果已经操作过那么就按普通的trie继续往下跑
		p = trie[p][s[l] - 'a'];
		if (!p) return;
		dfs1(p, l + 1, change);
	}
	else {
		for (int i = 0; i < 26; i++) {
			// 把下面一层的节点全部扫一遍
			if (!trie[p][i]) continue;
			if (i == s[l] - 'a') dfs1(trie[p][i], l + 1, 0);
			// 如果当前节点与当前一位字符匹配则不需操作
			else dfs1(trie[p][i], l + 1, 1);
			// 否则将change改为1
		}
	}
}

inline void dfs2(int p, int l, bool change) {
	// 对于删除一个字符的情况的dfs
	if (l == strlen(s) && end[p] & change) { ans++; return; }
	if (l == strlen(s) - 1 && !change && end[p]) { ans++; return; }
	// 因为删除可以删最后一位,所以这里需要特判一下
	if (change) {
		p = trie[p][s[l] - 'a'];
		if (!p) return;
		dfs2(p, l + 1, change);
	}
	else {
		for (int i = 0; i < 26; i++) {
			if (!trie[p][i]) continue;
			if (i == s[l] - 'a') dfs2(trie[p][i], l + 1, 0);
			else if (s[l + 1] - 'a' == i) dfs2(trie[p][i], l + 2, 1);
			// 如果字符串的下一位能和当前节点匹配则可进行操作
		}
	}
}

inline void dfs3(int p, int l, bool change) {
	// 对于增加一个字符的情况的dfs
	if (l == strlen(s) && end[p] && change) { ans++; return; }
	if (l == strlen(s) && !change) {
		for (int i = 0; i < 26; i++) if (end[trie[p][i]]) ans++;
		return;
		// 如果在最后一位增加字符的话要特判
	}
	if (change) {
		p = trie[p][s[l] - 'a'];
		if (!p) return;
		dfs3(p, l + 1, change);
	}
	else {
		for (int i = 0; i < 26; i++) {
			if (!trie[p][i]) continue;
			if (i == s[l] - 'a') dfs3(trie[p][i], l + 1, 0);
			else if (trie[trie[p][i]][s[l] - 'a'])
				dfs3(trie[trie[p][i]][s[l] - 'a'], l + 1, 1);
			// 下两层有节点可以与当前一位字符串匹配则可操作
		}
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		cin >> s;
		insert(s);
	}
	while (m--) {
		cin >> s;
		if (search(s)) { puts("-1"); continue; }
		ans = 0;
		dfs1(1, 0, 0);
		dfs2(1, 0, 0);
		dfs3(1, 0, 0);
		cout << ans << endl;
	}
	return 0;
}
```


---

## 作者：creation_hy (赞：3)

## 前言

很水的一题啊。。。连我这种菜鸡都能直接秒。。。~~真有紫吗~~

## 思路

注意到只能有一次修改操作，一眼 Trie 上爆搜。

先给字典建 Trie，然后 dfs 即可。

dfs 带四个参数，要匹配的字符串、匹配到第几位了、目前在 Trie 上的指针、是否用了修改操作。（我代码的第二项和第三项是反着的）

一个 $vis$ 数组记录每个字典上的串在当前匹配串上是否已经遍历过。

注意这里有个坑，**只有在完全匹配到某个串的时候才改 $vis$ 数组**，因为如果这不是一个完整的串的话，它的实际意义只是一个前缀。

还有一个坑，就是 **不要一碰到 `vis[cur]==true` 的情况就 `return`！**

如果你这么做的话，会~~喜提~~ $30$ 分。

因为一个串还可能是另一个串的前缀，访问过一个串，不代表访问过所有前缀为它的串。

另外，$-1$ 的情况可以直接拿一个 map 特判，这样就不用搜了。

难度不高，建议自己写。

代码内含注释。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, m;
struct Trie
{
    int t[N][26], tot, tag[N];
    map<string, bool> mp;
    bool vis[N];
    inline void insert(string s)
    {
        int cur = 0;
        mp[s] = true;
        for (char c : s)
        {
            if (!t[cur][c])
                t[cur][c] = ++tot;
            cur = t[cur][c];
        }
        tag[cur]++;
    }
    inline int dfs(string s, int cur, int x, bool changed)
    {
        if (x == s.size() && !vis[cur] && tag[cur] && changed)
        {
            vis[cur] = true;
            return tag[cur];
        }
        int res = 0;
        if (t[cur][s[x]])
            res += dfs(s, t[cur][s[x]], x + 1, changed); // no change
        if (changed)
            return res;
        res += dfs(s, cur, x + 1, 1); // delete
        for (int i = 0; i < 26; i++)
            if (t[cur][i])
            {
                res += dfs(s, t[cur][i], x + 1, 1); // modify
                res += dfs(s, t[cur][i], x, 1);     // insert
            }
        return res;
    }
    inline int solve(string s)
    {
        if (mp.count(s))
            return -1;
        memset(vis, 0, sizeof(vis));
        return dfs(s, 0, 0, 0);
    }
} tr;
inline void tonum(string &s)
{
    for (int i = 0; i < s.size(); i++)
        s[i] -= 'a';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    static string s;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> s;
        tonum(s);
        tr.insert(s);
    }
    while (m--)
    {
        cin >> s;
        tonum(s);
        cout << tr.solve(s) << '\n';
    }
    return 0;
}
```

---

## 作者：Cotsheep (赞：3)

## 题目：[**P4407**](https://www.luogu.com.cn/problem/P4407)  

[*My Blog*](https://www.cnblogs.com/cotsheep/p/16878240.html)

这题差不多就是 [P1688](https://www.luogu.com.cn/problem/P1688) 的改版。 

参考一下[我在 P1688 的做法](https://www.cnblogs.com/cotsheep/p/16873675.html)（←这个链接是 P1688 的题解），我们继续使用 Hash，然后只要考虑如何去重就好了。  

于是就有了这个暴力的想法： `#` **代表修改，** `@` **代表添加，** `^` **代表删除。**  


接下来我们来暴力去重。  

考虑怎么样会使单词被重复统计。  
1. 在两个相邻且相同的字母中选一个删掉  
2. 在一个字母旁添加一个一模一样的字母  
3. 修改的字符**不会**被重复统计

然后我们就可以愉快去重了。  

对于上面的 1、2 两种情况，考虑只统计 **连续相同字母中的最后一个字母**。  

具体操作：  
1. 删除  
 (1). 插入字典时： 一位一位枚举，遇到连续相同字母时只改最后一位并塞入 Hash。  
 (2). 查询时： 所有空位全部插入 `^` 并在 Hash 中查询。  

2. 添加  
 (1). 插入字典时： 所有空位全部插入 `@` 并塞入 Hash 中。  
 (2). 查询时： 一位一位枚举，遇到连续相同字母时只改最后一位并在 Hash 中查询。  

3. 修改  
 照常枚举。  

为什么要这样分类操作？  

**我们会发现只有在 1(1) 和 2(2) 情况下我们才能确切地知道当前字符串中枚举到的是不是重复字母，而另外两种情况是我们插入的，可以代表任意字符，只插一位会漏掉很多不同字母的情况。**  

这样操作就可以把重复的筛掉，且不会过多地去掉合法情况，暴力且能 A。  

还有一种答案为 $-1$ 的情况，在一开始把所有字符串塞进 Hash，询问时先在 Hash 里找一找就好了。  

Naive Code:  

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
inline ll Min(ll x, ll y){return x < y ? x : y;}
inline ll Max(ll x, ll y){return x > y ? x : y;}
inline ll rd(){
	ll x = 0;bool f = true;char c = getchar();
	while (c < '0' || c > '9'){if (c == '-') f = false; c = getchar();}
	while (c >= '0' && c <= '9'){x = (x<<3) + (x<<1) + (c ^ 48);c = getchar();}
    return f ? x : -x;
}
inline string srd(){
    char c = getchar();string res = "";
    while (c < 'a' || c > 'z')c = getchar();
    while(c >= 'a' && c <= 'z')res += c, c = getchar();
    return res;
}
const int N = 1e4 + 10, M = 1e6 + 7;

class Hash_table{
    private: 

    struct Node{
        int nextt, num;// num就是该状态下的单词个数
        string str;
    }data[N * 60];int head[M + 10], cnt;

    int h(string s){
        int l = s.size();
        int res = 0;
        for(int i = 0; i < l; ++i)
            res = ((res << 3) + (s[i] - 'a') + M) % M;
        return res;
    }

    public: 

    int find(string s){
        int key = h(s);
        for(int i = head[key]; i; i = data[i].nextt)
            if(s == data[i].str)
                return data[i].num;
        return 0;
    }

    void insert(string s){
        int key = h(s);
        for(int i = head[key]; i; i = data[i].nextt){
            if(s == data[i].str){
                data[i].num++;
                return ;
            }
        }
        data[++cnt].nextt = head[key];
        data[cnt].num = 1;
        data[cnt].str = s;
        head[key] = cnt;
        return ;
    }
}H;

int n, m;
string s, tmp, tmp1, tmp2;

int main(){
    n = rd(), m = rd();
    for(int i = 1; i <= n; ++i){
        s = srd();H.insert(s);
        int l = s.size();
        tmp = s;
        for(int j = 0; j < l; ++j){
            tmp[j] = '#';
            H.insert(tmp);
            if(j == l - 1 || s[j] != s[j + 1]){// 只删除最后一个
                tmp[j] = '^';
                H.insert(tmp);
            }
            tmp[j] = s[j];
        }

        if(l < 20){
            for(int j = 0; j <= l; ++j){
                tmp = tmp1 = tmp2 = "";
                for(int k = 1; k <= j; ++k)
                    tmp1 += s[k - 1];
                for(int k = j + 1; k <= l; ++k)
                    tmp2 += s[k - 1];
                tmp += tmp1, tmp += '@', tmp += tmp2;
                H.insert(tmp);
            }
        }
    }
    for(int i = 1; i <= m; ++i){
        s = srd();
        if(H.find(s)){
            printf("-1\n");
            continue;
        }
        int l = s.size(), ans = 0;
        tmp = s;
        for(int j = 0; j < l; ++j){
            tmp[j] = '#';
            ans += H.find(tmp);
            if(j == l - 1 || s[j] != s[j + 1]){// 只添加最后一个
                tmp[j] = '@';
                ans += H.find(tmp);
            }
            tmp[j] = s[j];
        }
        if(l < 20){
            for(int j = 0; j <= l; ++j){
                tmp = tmp1 = tmp2 = "";
                for(int k = 1; k <= j; ++k)
                    tmp1 += s[k - 1];
                for(int k = j + 1; k <= l; ++k)
                    tmp2 += s[k - 1];
                tmp += tmp1, tmp += '^',tmp += tmp2;
                ans += H.find(tmp);
            }
        }
            
        printf("%d\n", ans);
    }
	return 0;
}


```

---

## 作者：EchoHua0402 (赞：2)

# P4407[JSOI2009]电子字典 题解
## 题目描述
有 $m$ 次查询，每次查询给定一个字符串 $Q_i$，求在已给出的 $n$ 个字符串 $G_i$ 中，有多少个字符串与 $Q_i$ 的编辑距离为 $1$；若 $Q_i$ 在 $G$ 中出现过，则返回 $-1$。
## 题解

注意到串长都是极短的，所以我们考虑 Trie。

对于每次查询，我们都在直接 Trie 上做 DFS。考虑暴力枚举出对于某一位添加一个字符、替换一个字符、删除一个字符后的串是否在 Trie 上。

- 删除：即直接跳过当前字符。
- 替换：暴力枚举替换当前位的字母，继续在往下走即可。
- 添加：与替换基本相同。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+5;
const int W=25;
int n,m,tot,ans,len;
char s[W];
int trie[N*20][30],c[N];
bool is[N*20],vis[N*20],mark;
void Insert()
{
	int p=0;
	for (int i=0;i<len;i++)
	{
		int ch=s[i]-'a';
		if (trie[p][ch]==0) trie[p][ch]=++tot;
		p=trie[p][ch];
	}
	is[p]=1;
}
void dfs(int u,int L,bool flg)
{
	if (L==len&&is[u]&&(!flg))
	{
		mark=1;
		return ;
	}
	if (L==len&&is[u]&&flg)
	{
		if (!vis[u]) vis[c[++ans]=u]=1;
		return ;
	}
	int ch=s[L]-'a';
	if (!flg)
	{
		if (L<len) dfs(u,L+1,1);
		for (int i=0;i<26;i++)
		{
			if (trie[u][i]==0) continue;
			dfs(trie[u][i],L,1);
			if (i!=ch) dfs(trie[u][i],L+1,1);
		}
	}
	if (L>=len) return ;
	if (trie[u][ch]!=0) dfs(trie[u][ch],L+1,flg);
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	{
		scanf("%s",s);
		len=strlen(s);
		Insert();
	}
	for (int i=1;i<=m;i++)
	{
		scanf("%s",s);
		len=strlen(s);
		dfs(0,0,0);
		if (mark) printf("-1\n");
		else printf("%d\n",ans);
		while (ans) vis[c[ans--]]=0;
		mark=0;
	}
	return 0;
}
```

---

## 作者：YellowBean_Elsa (赞：2)

这题看着字符串查询就想到奇妙的 Trie！

[不会 Trie 的看这里](https://www.luogu.com.cn/problem/P2580)

然而当我们进行编辑（发动技能）时，Trie的检索会出现困难。

注意到字符串只有 $10000$ 个，每个长度只有 $20$，这启发我们暴力枚举发动技能的地方。

然后就在 Trie 上 dfs 过去了。。。

主要讲一下每个技能对应操作：

- 不发动技能：从当前节点到对应字符串当前字符的儿子，并将字符串当前字符的指针指向下一个字符。（说的好绕啊）

- 添加（add）：从当前节点到任意一个儿子，但不改变当前字符。

- 修改（alter）：枚举26个字母（注意不能和当前字符一样），往每个字母对应的儿子走，指向下一个字符。

- 删除（delete）：不动，直接指向下一个字符。

注意同一个字符串可能可以通过不同的技能发动方式得到目标串，但只能算一次，所以我们要把他们用一个队列记录下来。（详见代码）
```cpp
//coder: Feliks*GM-YB
#include<bits/stdc++.h>
#define fu(i,a,b) for(register int i = a, I = (b) + 1; i < I; i++)
#define fd(i,a,b) for(register int i = a, I = (b) - 1; i > I; i--)
typedef long long ll;
using namespace std;
const int N=4e5+50;//别开小了嘤嘤嘤
template <class T> inline void read(T &x) {
    x=0;T f=1;char ch=getchar();
    while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();
    while(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    x*=f;
}int n,m,num=1,len;
struct Trie{
	bool ext;//exist
	int son[26];
	Trie(){ext=0;memset(son,0,sizeof(son));}
}t[N];
inline void ins(string s){//Trie插入
	int now=1,x;
	fu(i,0,s.size()-1){
		x=s[i]-'a';
		if(t[now].son[x])now=t[now].son[x];
		else now=t[now].son[x]=(++num);
	}t[now].ext=1;
}bool got,vis[N];
int q[N],cnt;//下文有解释
void dfs(int now,int d,bool f,string s){
//f：是否发动过技能，d：深度，now：在Trie上那个节点
	if(t[now].ext && len==d && !f){got=1;return;}
	//找到一样的串且没有用过技能
	else if(t[now].ext && len==d && f){
	//找到一样的串且用过了技能
		if(!vis[now])vis[q[++cnt]=now]=1;
		//为了防止重复算同一个串，要把算过的扔进队列 q里
		//并用 vis记录 Trie上这个点所代表的串已被算过
		return;
	}if(!f)fu(i,0,25)if(t[now].son[i])
		dfs(t[now].son[i],d,1,s);//add
	if(d>=len)return;//找不到就别费劲了
	//注意这句要在add之后进行，因为 d==len时 add可能又可以找到答案 
	if(!f){
		if(d<len)dfs(now,d+1,1,s);//delete
		fu(i,0,25)if(t[now].son[i] && i!=s[d]-'a')
			dfs(t[now].son[i],d+1,1,s);//alter		
	}if(t[now].son[s[d]-'a'])dfs(t[now].son[s[d]-'a'],d+1,f,s);//不发动技能
}string s;
inline void init(){//初始化
	got=0;len=s.size();
	while(cnt)vis[q[cnt--]]=0;
}
int main(){
    read(n),read(m);
    fu(i,1,n)cin>>s,ins(s);
    fu(i,1,m){
    	cin>>s;
    	init();
    	dfs(1,0,0,s);
    	if(got)puts("-1");
    	else printf("%d\n",cnt);
	}
    return 0;
}
```
#### 疑惑：复杂度？

来看看对于每个长度 $20$ 的串，我们枚举了多少修改串：

21 个添加位置，20 个修改位置，20个删除位置，其中每个添加或修改有 26 种情况。

故算了 $(21+20) \times 26+20=1086$ 个。

如果每个串都没有前缀交集（即在 Trie 中检索的时候一开始就分道扬镳），那计算量为 $10000 \times 20 \times 1086=2.172 \times 10^8$ 

看起来很悬，但是很多修改位置在靠后的串是有前缀交集的，在一开始并没有分道扬镳，省掉了至少一半的运算。而且不是每个位置都有全部 $26$ 个儿子的。

甚至可以加上“找到了原串就全部停止”的剪枝，应该也能快一些。

#### 希望对大家有帮助，Au revoir.

---

## 作者：光明正大 (赞：2)

# 看题解trie挺少的，我就来一波trie
## 思路很明显
## 先把词典读进去，插入到trie树中
## 对于每次查询，先判断是否在trie树中
## 若不在，再进行删除、替换、添加
## 在对查询串进行处理时比较麻烦
## 楼上有用dfs的，在这里我是直接暴力模拟
## 时间没有问题，所有点一共2001ms
## 废话不多说，上代码
## 
## 注意：此题通过两种变换方式得到相同的字符串算一个
## 比如abc在第一位加一个a和第二位加一个a结果都是aabc，但统计是算一个
## 具体变量及程序解释见代码
# AC代码：
```cpp 
#include<bits/stdc++.h>
using namespace std;
int cnt,n,m,sum,exist[500050];//sum:查到相同串的次数 exist:存在字符串的编号 
char s0[30],s[30];//s0:要查找的串,s:处理后实际进行操作的串 
int next[500010][26];
bool b[10010];//b[i]:字符串i是否被找到过 
void insert(int x)
{
	scanf("%s",s+1);
    int u=0,len=strlen(s+1);
    for(int i=1;i<=len;i++) {
        int c=s[i]-'a';
        if(!next[u][c]) next[u][c]=++cnt;
        u=next[u][c];
    }
    exist[u]=x;//第x个字符串 
}
inline int search()//存在相同返回1,否则返回0 
{
    int u=0,len=strlen(s+1);
    for(int i=1;i<=len;i++) {
        int c=s[i]-'a';
		if(!next[u][c]) return 0;
        u=next[u][c];
    }
    if(exist[u]&&!b[exist[u]]) {//存在并且没有被找到过 
		b[exist[u]]=1;//标记被找到过 
		return 1;
	}
	return 0;
}
inline void del()//删除 
{
	int len=strlen(s0+1);
	for(int i=1;i<=len;i++)
	{
		for(int j=1;j<=i-1;j++) s[j]=s0[j];
		//注意len-1 
		for(int j=i;j<=len-1;j++) s[j]=s0[j+1];
		sum+=search();
	}
}
inline void rep()//替换 
{
	int len=strlen(s0+1);
	for(int i=1;i<=len;i++) s[i]=s0[i];
	for(int i=1;i<=len;i++) for(int j='a';j<='z';j++) {
		if(j==s[i]) continue;
		s[i]=j;
		sum+=search();
		s[i]=s0[i];
	}
}
inline void add()//添加 
{
	int len=strlen(s0+1);
	//注意len+1 
	for(int i=1;i<=len+1;i++) for(int j='a';j<='z';j++) {
		for(int k=1;k<=i-1;k++) s[k]=s0[k];s[i]=j;
		for(int k=i+1;k<=len+1;k++) s[k]=s0[k-1];
		sum+=search();
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) insert(i);//插入第i个串 
	for(int i=1;i<=m;i++)
	{
		scanf("%s",s0+1);
		sum=0;memset(b,0,sizeof b);//都没有被找到过并且被找到过的次数为0 
		memset(s,0,sizeof s);
		//不写unsigned会出警告(其实不写也没事)  
		for(unsigned int j=1;j<=strlen(s0+1);j++) s[j]=s0[j];//先找一遍原串 
		if(search()){puts("-1");continue;}//若找到输出-1 
		//每次用s[]之前清空 
		memset(s,0,sizeof s);del();
		memset(s,0,sizeof s);rep();
		memset(s,0,sizeof s);add();
		printf("%d\n",sum);
	}
    return 0;
}


```
蒟蒻第一次写紫题题解，望管理员通过

如有不理解的可以私信我



---

## 作者：_Wind_Leaves_ShaDow_ (赞：1)

### 前言

最近在学字典树，交发题解巩固一下，顺便记录我第一次 A 的紫题。~~（虽然很水最多是道蓝题）~~

### 字典树
都写到紫题了字典树是什么应该都会了，所以只是稍微讲一下，不会的看[模板](https://www.luogu.com.cn/problem/P8306)，里面题解讲的很清楚。学完后打几道 [板](https://www.luogu.com.cn/problem/P2580)[子](https://www.luogu.com.cn/problem/P2922) 题，然后再来看这道题。

字典树，对于储存一些字符串或者要处理的类似于字符串的数串，每一次在树中寻找它的前缀，如果没有就新建节点来储存这个数，如字符串  ```arm``` 和字符串 ```art``` 拥有相同的节点 ```ar```，那么它们会在树中拥有相同的前缀 ```ar```。

很多时候字典树能够有效地加快时间并优化空间，虽然局限性比较大，但是还是一个值得去学的东西。 ~~（毕竟在树形结构中字典树真的很简单，我二叉树都没学会就会写字典树了）~~

这里也不是字典树的裸题了，就不多讲述。

### 思路简述

看到字典这种东西再稍微看题就能知道这是字典树储存单词。建立树的过程很简单，但是多加一个数组判断是否有单词以这个编号结尾。

编辑距离可以理解为最多进行一次更改，如果没有进行更改就找到了输出 $-1$ 完事。

然后发现 $T$ 值很小，考虑暴力深搜：

- 首先定义深搜变量：$p$ 表示当前是第几个编号，$len$ 表示处理的这个字符串的长度，$change$ 定义布尔值，表示是否进行过操作。

- 对于删除操作，将其理解为不对这个字符做考虑，直接跳进下一个字符来判断。

- 对于添加操作，将其理解为字符串的长度加 $1$，因为如果进行更改一定会进行最优的，不用考虑更改造成的更多影响。

- 对于修改操作，和删除操作差不多，有一个剪枝：如果我更改的值是我被更改的字符本身，这次更改没有用，不用进行更改操作。

这里还有另一件事，一个字符串可能可以通过不同的方式被搜到两次，需要判重。

一个剪枝（可以算剪枝吗）：如果已经找到它是存储过的单词了，就不会需要进行更多的搜索了。并且在这里，我之前没想到 $ans$ 等于 $0$ 不等于它是存储过的单词，直接傻乎乎判 $ans$ 了……

这道题思路比较活，重点是将题目的一些条件进行简单的转化。

### 详见代码（有注释有些地方自己看，自己多思考）：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,trie[200200][30],id=0,ans;
bool en[200200],found[200200],isword;
string req;

void insert(){
	string s;
	cin>>s;
	int p=0,c;
	for(int i=0;i<s.size();i++){
		c=int(s[i]-'a');
		if(trie[p][c]==0)trie[p][c]=++id;
		p=trie[p][c];
	}
	en[p]=true;//记录末尾 
}//建树，最简单基础的操作了 

void dfs(int p,int len,bool change,string s){
	if(!isword){//已经判定为是单词了就不用更多地搜了 
		if(len==s.size()&&en[p]&&!change){//这里和下面只有 change 不同，也就是有没有被修改过 -> 是存过的单词 
			ans=0;
			isword=true;//记录 
			return;
		}
		if(len==s.size()&&en[p]&&change){//被修改过并且是单词 -> 找到了 
			if(!found[p]){
				found[p]=true;//判重避免重复找 
				ans++;
			}
			return;
		}
		int c=int(s[len]-'a');
		if(!change){//没有被修改过才能继续改 
			if(len<s.size())dfs(p,len+1,true,s);//删除操作 
			for(int i=0;i<26;i++){//暴力枚举 26 个字母 
				if(trie[p][i]!=0){
					dfs(trie[p][i],len,true,s);//添加操作 
					if(i!=c)dfs(trie[p][i],len+1,true,s);//更改操作 + 小剪枝 
				}
			}
		}
		if(len>=s.size())return;//已经比要求字符串大了，并且搜索结束，没有必要找下去 
		if(trie[p][c]!=0)dfs(trie[p][c],len+1,change,s);//不做更改直接搜 
	}
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)insert();
	while(m--){
		ans=0;
		isword=false;//初始化
		cin>>req;
		dfs(0,0,false,req);
		if(isword)cout<<"-1\n";
		else cout<<ans<<endl;
		memset(found,false,sizeof(found));//把判重数组清空 
	}
	return 0; 
} 
```
### 难点 len 变量

$len$ 存的是当前匹配的字符串长度。

每在下一次递归时，$len$ 应该加上 $1$，但我们可以知道，删除操作会使长度减前去一，两两相抵，于是不需要更改。对于添加，$len$ 的长度上限也是增加 $1$，也可以抵消。而对于修改，长度还是一样，于是需要修改 $len$ 的值。

~~第一次写紫题题解，肯定有写得不好的地方，见谅。~~


---

## 作者：nomonick (赞：1)



# P4407 [JSOI2009]电子字典

## 题面解析

题面 link : [P4407](https://www.luogu.com.cn/problem/P4407)

关于题面个人认为为还是比较还理解的，整理一下就是要在现有字符串集合 $ \{ str_i \} $ 中找到对于指定字符串 $ s　$ 而言满足以下条件的字符串个数：
1. 删除串中某以个位置上的字母
1. 添加一个字母到串中某个位置
1. 替换串中某一位置的一个字母为另一个字母

若 $ s $ 满足 $ s \in \{ str_i \} $ 则输出 $ -1 $ 。

## 算法分析

这类字符串查询问题，通常是需要使用字典树亦或是字典树的思想的。

而这道题利用字典树的性质，在字典树上进行深搜，已实现查询的功能。

至于这道题深搜的时间复杂度，我们可以想象出一个满二十六杈树，按照题目要求进行剪枝。

由于满二十六杈树，所以从更节点向下每一条链都可以所谓长链。

在这里我们定义与字符串 $ s $ 所便是意义相同的链为长链，并以此为标准链。

由于，对于字符串的构造要求，任何一个从标准链上伸出的链的形式及已经确定。

那么，对于每一个位于标准链上的节点可以理解为除标准链上的子树以外其他子树均等于 1 。

这样深搜的复杂的就到了一个可以接受的范围。

考虑去重的问题，由于字典树上的每一个打了结束标记的节点，仅代表一个单词。

那么可以额外定义一个数组表示该字符串是否被表示

## 算法实现

及实现一个基本的字典树建立和树上深搜过程

## code

```cpp
#include <bits/stdc++.h>
const int SIZE = (int)3e5 + 50;
int root,n,m,ans,tot,len;
int trie[SIZE][26];
char str[SIZE];
bool flag;
bool isw[SIZE],vis[SIZE];
// 省略快读快输
inline void insert()
{
	scanf("%s",str);
	int len = strlen(str),pos = 0;
	for (int i = 0; i < len; ++i)
	{
		if (!trie[pos][str[i] - 'a']) trie[pos][str[i] - 'a'] = ++tot;
		pos = trie[pos][str[i] - 'a'];
	}
	isw[pos] = true;
}
inline void dfs(int u,int length,bool change)
{
	if (flag) return; 
	if (length == len && isw[u] && !change) return flag = true,void();
	if (length == len && isw[u] && change) return (!vis[u] ? (vis[u] = true,ans++) : vis[u] = true),void();
	int ch = str[length] - 'a';
	if (!change)
	{
		if (length < len) dfs(u,length+1,true);
		for (int i = 0; i < 26; ++i)
		{
			if (!trie[u][i]) continue;
			dfs(trie[u][i],length,true);
			if (i != ch) dfs(trie[u][i],length+1,true);
		}
	}
	if (length >= len) return;
	if (trie[u][ch]) dfs(trie[u][ch],length+1,change);
}
inline void solve()
{
	scanf("%s",str);
	len = strlen(str); flag = false; ans = 0;
	memset(vis,false,sizeof(vis));
	dfs(0,0,false);
	if (flag) puts("-1");
	else write(ans), puts("");
}
signed main()
{
	n = read(); m = read();
	for (int i = 1; i <= n; ++i) insert();
	for (int i = 1; i <= m; ++i) solve();
	return 0;
}
```



---

## 作者：louhao088 (赞：1)



蒟蒻太菜了，不会什么算法，想打个暴力，然后卡了一下常，结果居然水过了。~~数据太水~~

## 思路

我们暴力枚举每一个，判断能否转化，如果能就加，如果有一样就为$-1$,注意卡常。

时间$O(n^2)$ 

枚举函数如下

```cpp
inline int check(int x)
{
	F=0;
	if(len[x]-len1==1)//加数
	{
		for(re int i=0;i<len[x];i++)
		{
			if(F==1&&q[x][i]!=a[i-1])return 0;
			else if(q[x][i]!=a[i]&&!F)F=1;
		}return 1;
	}
	else if(len1-len[x]==1)//删数
	{
		for(re int i=0;i<len1;i++)
		{
			if(F==1&&q[x][i-1]!=a[i])return 0;
			else if(q[x][i]!=a[i]&&!F)F=1;
		}return 1;
	}
	else if(len1==len[x])//换数或一样
	{
		for(re int i=0;i<len1;i++)
		{
			if(F==1&&q[x][i]!=a[i])return 0;
			else if(q[x][i]!=a[i]&&!F)F=1;
		}
		if(F==0)return -1;return 1;
	}return 0;
}
```


然后是非常朴素的代码

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;
#define re register
inline int read()
{
	char ch=getchar();int x=0;bool f=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
int n,len[10005],len1,m,ans,F;
char q[10005][20],a[20];
inline int check(int x)
{
	F=0;
	if(len[x]-len1==1)
	{
		for(re int i=0;i<len[x];i++)
		{
			if(F==1&&q[x][i]!=a[i-1])return 0;
			else if(q[x][i]!=a[i]&&!F)F=1;
			//cout<<i<<endl;
		}return 1;
	}
	else if(len1-len[x]==1)
	{
		for(re int i=0;i<len1;i++)
		{
			if(F==1&&q[x][i-1]!=a[i])return 0;
			else if(q[x][i]!=a[i]&&!F)F=1;
		}return 1;
	}
	else if(len1==len[x])
	{
		for(re int i=0;i<len1;i++)
		{
			if(F==1&&q[x][i]!=a[i])return 0;
			else if(q[x][i]!=a[i]&&!F)F=1;
		}
		if(F==0)return -1;return 1;
	}return 0;
}
int main()
{
	n=read();m=read();
	for(re int i=1;i<=n;i++)gets(q[i]),len[i]=strlen(q[i]);
	for(re int i=1;i<=m;i++)
	{
		memset(a,0,sizeof a);
		gets(a);len1=strlen(a);ans=0;
		for(re int j=1;j<=n;j++)
		{
			int t=check(j);
			if(t==-1){puts("-1");break;}
			else 
			{
				ans+=t;
			}
			if(j==n)printf("%d\n",ans);
		}
	}
	return 0;
}
```

然后就愉快的过了



---

## 作者：Kazeno_Akina (赞：0)

一种很新的 hash 做法。

我看到其它题解里面都在将现有串串的编辑距离为 $1$ 的串预处理出来然后一个一个进行比对。但是鉴于 **每个串的 len 是极小的**，我们可以获得一种更容易理解，空间复杂度也更低的做法。

考虑对于每一个 $W_{i}$ 预处理其前缀的 hash 数组。当我们进行查询时，可以这样判断每个 $W_{i}$ 和 当前的 $Q$ 是否编辑距离为 $1$：

1.考虑串长的差，如果串长之差的绝对值 $\ge 2$，那么显然其编辑距离大于 $1$。

2.在其余情况下，假如串长相同，那么可以先直接比较两个串的整体 hash 值是否相同，相同直接输出 $-1$ 进入下一个查询。

3.否则找到两个串的最长公共前缀。对于剩余部分，如果其中一个串较长，那么将较长串剩余部分的首位去掉，其余部分应当两串相同；否则两串等长，都去掉首位比较其余部分是否相同即可。

如果使用二分找最长公共前缀，这样做的最劣复杂度是 $O(nm \log len)$，其中 $len$ 为最长串长，足以通过本题；如果暴力查找则是 $O(nmlen)$，~~但是你谷数据没有素质暴力比二分还快~~。

下面给出代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+5,L=31;
int n,m,p,cnt,len,ml[N];
string init;
unsigned long long base[L],g[N][L];
inline void hsh(string x,int k){
    for(int i(0);i<ml[k];++i) g[k][i+1]=g[k][i]*L+(int)(x[i]-'a'+1);
    return;
}
inline int check(int x,int y){
    int l(0),r(min(ml[x],ml[y])),mid;
    while(l<r) mid=l+r+1>>1,(g[x][mid]==g[y][mid])?(l=mid):(r=mid-1);
    return l;
}
inline unsigned long long las(int k,int len){return g[k][ml[k]]-g[k][ml[k]-len]*base[len];}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    base[0]=1;for(int i(1);i<21;++i) base[i]=base[i-1]*L;
    cin >> n >> m;
    for(int i(1);i<=n;++i) cin >> init,ml[i]=init.length(),hsh(init,i);
    while(m--){
        cnt=0,cin >> init,ml[n+1]=init.length(),hsh(init,n+1);
        for(int i(1);i<=n;++i){
            if(ml[i]<ml[n+1]-1||ml[i]>ml[n+1]+1) continue;//判断串长
            if(g[i][ml[i]]==g[n+1][ml[n+1]]){cnt=-1;break;}//如果两串相同
            p=check(i,n+1),len=max(ml[i]-p,ml[n+1]-p)-1,cnt+=(las(i,len)==las(n+1,len));//判断两个串的后缀
        }
        cout << cnt << '\n';
    }
    return 0;
}
```

---

## 作者：Exber (赞：0)

### 做法

trie + 搜索。

首先把所有字符串加入 trie 树里，然后对于每一个输入的字符串，我们从根节点开始搜索。

在搜索过程中，我们要保存一个变量 $can$，即有没有用过“编辑”的机会。如果没有用过，那么我们就可以考虑用掉这次机会，“编辑”一下当前的字符串。当然也可以不用这次机会，继续往下搜索。

考虑有“编辑”机会时如何递归：

- 不操作，那么和没机会时一样；

- 删除，因为我们是在 trie 上 dfs 的，所以删除**相当于删除当前串的开头字符或结尾字符**。因为删除其它字符的情况在之前不操作的递归过程中已经枚举到了；

- 替换，**相当于替换当前串的开头字符**，因为替换其它字符的情况在之前不操作的递归过程中肯定也枚举到了。但是要注意开头不能替换为原来的开头；

- 插入，**相当于在当前串的开头或结尾插入**，和删除同理。

最后因为有可能通过不同的“编辑”得到同一个字符串，所以要做好去重。并且此题极度卡常……

### AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring> 

using namespace std;

int n,m;
char str[25];
int cnt,sons[300005][26];
bool endd[300005],vis[300005];

inline long long ckjread()
{
	long long s=0,w=1,ch=getchar();
	while(ch<'0'||ch>'9') ch=='-'?w=-1,ch=getchar():ch=getchar();
	while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return s*w;
}

void jynwriten(long long x)
{
	if(x<0) return putchar('-'),jynwriten(-x);
	x>9?jynwriten(x/10),putchar(x%10|48):putchar(x|48);
}


void ins(int u,string str)
{
	if(str.empty())
	{
		endd[u]=true;
		return;
	}
	if(sons[u][str[0]-'a']==0) sons[u][str[0]-'a']=++cnt;
	ins(sons[u][str[0]-'a'],str.substr(1));
}

int que(int u,string str,bool can)
{
	if(str.empty())
	{
		if(can&&endd[u]) return -1; 
		if(vis[u]) return 0;
		vis[u]=true;
		return endd[u];
	}
	if(can)
	{ 
		// 不操作 
		int res=0;
		if(sons[u][str[0]-'a']!=0) res+=que(sons[u][str[0]-'a'],str.substr(1),true);
		if(res==-1) return -1;
		// 删除 
		if(str.size()>=2&&sons[u][str[1]-'a']!=0) res+=que(sons[u][str[1]-'a'],str.substr(2),false); // 删除开头 
		if(sons[u][str[0]-'a']!=0) res+=que(sons[u][str[0]-'a'],str.substr(1,str.size()-2),false); // 删除结尾 
		// 替换 
		for(int i=0;i<26;++i) if(sons[u][i]!=0&&i+'a'!=str[0]) res+=que(sons[u][i],str.substr(1),false); // 替换开头 
		// 插入 
		for(int i=0;i<26;++i) if(sons[u][i]!=0) res+=que(sons[u][i],str,false); // 插入开头 
		if(sons[u][str[0]-'a']!=0) for(int i=0;i<26;++i) res+=que(sons[u][str[0]-'a'],str.substr(1)+(char)('a'+i),false); // 插入结尾
		return res;
	}
	return sons[u][str[0]-'a']==0?0:que(sons[u][str[0]-'a'],str.substr(1),false);
}

int main()
{
	n=ckjread();
	m=ckjread();
	cnt=1;
	for(int i=1;i<=n;++i)
	{
		scanf("%s",str);
		ins(1,str);
	}
	for(int i=1;i<=m;++i)
	{
		scanf("%s",str);
		memset(vis,0,sizeof(vis));
		jynwriten(que(1,str,true));
		putchar('\n');
	}
	return 0;
}
```

---


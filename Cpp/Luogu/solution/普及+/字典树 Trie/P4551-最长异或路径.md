# 最长异或路径

## 题目描述

给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $n$。寻找树中找两个结点，求最长的异或路径。

异或路径指的是指两个结点之间唯一路径上的所有边权的异或。

## 说明/提示

最长异或序列是 $1,2,3$，答案是 $7=3\oplus 4$。   

### 数据范围

$1\le n \le 100000;0 < u,v \le n;0 \le w < 2^{31}$。

## 样例 #1

### 输入

```
4
1 2 3
2 3 4
2 4 6```

### 输出

```
7```

# 题解

## 作者：Terminus_Est (赞：183)

蒟蒻第一次学习01trie，发篇题解加深一下印象。

首先说一下题意。这题就是给你一棵树，求树上所有路径中异或和最大的。

两个前置芝士：

# 1、01trie 

把数拆成二进制的形式，然后每一位都只有两个字符：0或1，然后按照trie的方式存下来，以达到节省空间的效果。

如下图：

![](https://cdn.luogu.com.cn/upload/pic/53407.png)

这样就不用一个数一个数组的浪费空间来存了QAQ

# 2、异或

把两个数写成二进制的形式，对照每一位，如果相同则这一位为0，否则为1。

如下：

3:  011

4:  100

3^4=111=7

理解了我们就接下来进入正题。

# 题解

我们对于每一个数到根节点的异或和进行建01trie树。

以样例为例子：

![](https://cdn.luogu.com.cn/upload/pic/53408.png)

然后有一个定论：一个数，如果它两次异或同一个数，那么它是不会有改变的。

那么i~j的路径上的异或和，就可以表示成根到i的异或和异或上根到j的异或和。

那思路就很明确了：对于每一位进行贪心，如果这一位有一个与它不同的，即异或
后是1，那我们就顺着这条路往下走；否则就顺着原路往下走。

这样贪心为什么是对的呢？因为当前这一位的权值比后面所有位数加起来还要高。

就比如有一个数它的二进制表示是10...0（n个0）

那么它比01...1(n-1个1）还要大。

所以最高位决定一切qwq~

然后代码闪亮登场~

    #include<bits/stdc++.h>
    using namespace std;
    struct qwq{
        int v;
        int w;
        int nxt;
    }edge[2000001];
    int head[2000001];
    int cnt=-1;
    void add(int u,int v,int w){
        edge[++cnt].nxt=head[u];
        edge[cnt].v=v;
        edge[cnt].w=w;
        head[u]=cnt;
    }
    int sum[2000001];
    void dfs(int x,int fa){//预处理
        for(int i=head[x];~i;i=edge[i].nxt){
            int v=edge[i].v;
            int w=edge[i].w;
            if(v!=fa){
                sum[v]=sum[x]^w;
                dfs(v,x);
            }
        }
    }
    struct trie{
        int ch[2];
    }t[2000001];
    int tot;
    void build(int val,int x){
        for(int i=(1<<30);i;i>>=1){
            bool c=val&i;//取出二进制下这个数的当前位置
            if(!t[x].ch[c]){
                t[x].ch[c]=++tot;
            }
            x=t[x].ch[c];
        }
    }
    int query(int val,int x){
        int ans=0;
        for(int i=(1<<30);i;i>>=1){
            bool c=val&i;
            if(t[x].ch[!c]){//如果这一位可以进行异或就沿着这一条往下走
                ans+=i;
                x=t[x].ch[!c];
            }
            else x=t[x].ch[c];//否则就沿着另一条路往下走
        }
        return ans;
    }
    int main(){
        memset(head,-1,sizeof(head));
        int n;
        scanf("%d",&n);
        for(int i=1;i<n;++i){
            int u,v,w;
            scanf("%d%d%d",&u,&v,&w);
            add(u,v,w);
            add(v,u,w);
        }
        dfs(1,-1);//预处理出每一个节点到根的异或和
        for(int i=1;i<=n;++i)build(sum[i],0);//建立trie数
        int ans=0;
        for(int i=1;i<=n;++i){
            ans=max(ans,query(sum[i],0));//查询，取最大值
        }
        printf("%d\n",ans);
    } 

复杂度O(n)  ~~自带30的常数~~

---

## 作者：zyc2003 (赞：117)

##### 本篇题解思路来源于《算法竞赛进阶指南》。
### 前置知识：
1.	字典树
2.	异或性质
3.  最近公共祖先

有了以上知识的基础，我们才能高效地解决本道题目。若对以上知识点不熟悉，建议先做题巩固，再来尝试此题，会更有收获。下面的内容建立在**熟悉以上知识点**的基础上，不再对一些名词进行解释。

题目中要求我们寻找一条从树上 $X$ 到 $Y$ 的路径，使得**他们路径上的所有边权异或起来的值最大**。

整个问题不好直接入手,所以我们将其划分为两个子任务:


------------
#### _A._ 求出两个结点间的**边权异或和**
#### _B._ 找到两个结点,使他们路径上的的**边权异或和最大**
------------



如果我们熟悉异或性质，我们自然会想到：

$ A $  $xor$ $A$ $=$ $0$

即，若两个**相同**的数异或，那么他们的值为0。
由于异或运算具有**交换律**与**结合律**的性质，那么：

对于 $ A $ $xor$ $B$ $xor$ $A$

$=$ $(A$ $xor$ $A)$ $xor$ $B$

$=$ $0$ $xor$ $B$

$=$ $B$

因此,我们令 $LCA$ 代表 $X$ 与 $Y$ 的最近公共祖先,令 $Root$ 表示整颗树的根节点,令 $Sum(X,Y)$ 表示从 $X$ 到 $Y$ 路径上所有边权的异或和,有:



------------
$Sum(X,Y)$

$=$ $Sum(X,LCA)$ $xor$  $Sum(Y,LCA)$ 

$=$ $Sum(X,LCA)$ $xor$ $Sum(Y,LCA)$ $xor$ $Sum(LCA,Root)$ $xor$ $Sum(LCA,Root)$ 

$=$ $Sum(X,LCA)$ $xor$ $Sum(LCA,Root)$ $xor$ $Sum(Y,LCA)$  $xor$ $Sum(LCA,Root)$ 

$=$ $Sum(X,Root)$ $xor$ $Sum(Y,Root)$

因此,对于$Sum(X,Y)$,我们**并不需要**知道他们之间的路径信息,我们只需要分别知道他们到根节点路径上的**异或和**即可。而这个操作是可以通过$dfs$ $O(n)$实现的,具体实现细节在代码中。

此时，我们已经解决了一个子问题：如何快速求出两个结点间的**边权异或和**。令 $Dis[X]$ 表示从 $X$ 到根节点的**边权异或和**,那我们的任务就是找出一对$(X,Y)$,

使得: $Dis(X)$ $xor$ $Dis(Y)$ 最大。

现在我们来讨论，如何找到最大值，即**最大异或对**。我们可以扫描一遍 $Dis$**数组** ,对每一个 $Dis[X]$ ,尝试找到一个 $Dis[Y]$ ,使 $Dis[X]$ $xor$ $Dis[Y]$ 最大。明显有一种朴素的 $O(n^2)$ 的算法,找出所有的 $(X,Y)$ , 找出$Dis[X]$ $xor$ $Dis[Y]$ 的最大值。但很明显，此时间复杂度会导致超时。

这个时候，我们需要使用一种数据结构——**字典树**。字典树是解决异或问题的有力数据结构，我们运用贪心的思想，可以很快地解决本题的第二个子任务。假设某棵树有4个结点，每个结点的 $Dis$ 分别为:

$Dis[1] = 0$

$Dis[2] = 6$

$Dis[3] = 3$

$Dis[4] = 5$

这里**不给出**树的结构,因为当我们已经求出 $Dis$ 数组后,树的结构已经无关紧要了,我们的第二个子任务与其没有关联。此时我们将每个 $Dis[X]$ 的值视为一个**二进制数**,与插入字符串类似,**将此数的二进制表示视作一个 *01字符串* , 由二进制的高位到低位**依次插入（在实际上，我们应该更高位，例如从31位开始插入，这里为了方便，从第2位开始插入（第0位为最低位））:


![](https://cdn.luogu.com.cn/upload/image_hosting/5c0cd0sq.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

###### 现在,我们已经在这棵线段树中插入了 $Dis$**数组** 的值。先抛出理论，令 $Sum$ 表示异或和。在 $Dis[X]$ 的**二进制表示**中，从高位到低位扫描，若 $Dis[X]$ 当前位的值是 $1$ ,那么我们在当前字典树的子树中,从根节点向左儿子走(即向值为 $0$ 的子节点走,在我的图中是左儿子)，并更新 $ Sum $ (具体在代码中);若没有左儿子,那我们只能向右走,不更新 $Sum$ 。若当前位的值是 $0$ ,则相反，即每次向与当前位数值不同的节点走。这样的贪心策略是显然成立的。最后走到叶节点时，此时的 $Sum$ 就是某个 $Dis[Y]$ 与 $Dis[X]$ 异或得到的最大值。

事实上,我们也可以得知 $Dis[Y]$ 的值，在最后再令 $Sum$ = $Dis[X]$ $xor$ $Dis[Y]$ ，前面不更新 $Sum$ 。想一想,怎么做?(提示:只用对 $end$ 数组进行修改即可)。

下面是一个例子：寻找与 $Dis[3] = 3$ 异或的最大值(答案为 $Dis[4] = 5 $)

![](https://cdn.luogu.com.cn/upload/image_hosting/ixbzceo2.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

至此,问题得到解决,剩下就是码代码了。下面是我的代码，仅供参考,时间复杂度应该近似于 $O(n)$ ,但常数较大：




```cpp
#include<iostream>
#include<cstdio>
#include<memory.h>
using namespace std;
#define N 100010

int n;
int head[N],nxt[N<<1],ver[N<<1],val[N<<1],tot=0;
int Dis[N];//此处Dis含义与上文相同
int trie[N<<4][2],cnt=1;//字典树
bool end[N<<4];//结束标识

inline void add(int x,int y,int z)
{
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
	val[tot]=z;
}//邻接表存图

void dfs(int x,int fa)
{
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i],z=val[i];
		if(y == fa)	
			continue;	
		Dis[y]=(z^Dis[x]);
		dfs(y,x);
	}
	return ;
}//求出Dis数组

inline void insert(int x)
{
	int p=1;
	for(int i=31;i>=0;i--)
	{
		int num=((x>>i)&1);
		if(!trie[p][num])	
			trie[p][num]=++cnt;
		p=trie[p][num];
	}
	end[p]=1;
}//字典树-插入节点

inline int find(int num)
{
	int p=1;
	int Sum=0;
	for(int i=31;i>=0;i--)
	{
		int x=((num>>i)&1);
		if(trie[p][x^1])	
        	Sum+=(1<<i),p=trie[p][x^1];//更新Sum
		else	
        	p=trie[p][x];			   //不更新Sum
	}
	return Sum;
}//字典树-求和

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n-1;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	Dis[1]=0;
	dfs(1,0);
	
	for(int i=1;i<=n;i++)
		insert(Dis[i]);
	
	int Sum=0;
	for(int i=1;i<=n;i++)
		Sum=max(Sum,find(Dis[i]));
	printf("%d",Sum);
	return 0;
}


```










---

## 作者：顾z (赞：39)

**题目描述**

给定一棵 n 个点的带权树，结点下标从 1 开始到 N 。寻找树中找两个结点，求最长的异或路径。

异或路径指的是指两个结点之间唯一路径上的所有边权的异或。

**个人**：

首先强推一下01字典树(Trie),这个东西是解决**xor问题**的利器.

查找最大异或值的时候我们一般从最高位到低位向下找  

       eg:   1000(2)=8(10)
             0111(2)=7(10)
显然只要我的最高位是1,除非你和我的最高位相同,要不然我就是比你大.

根据数学上的等比数列求和可知
8=2^3 ，7=2^3-1

所以说我们可以**贪心的去找当前位^1的节点**

01字典树的写法和trie树差不多,对于这个题,

 	过程：
         1.建图跑一下再去dfs去求每个节点到根节点的xor值。
         2.再去构建01Trie去实现我们的贪心即可
    

~~网上讲这个的很多,想学的可以百度~~

———————代码—————————
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
#define maxn 100008
int trie[maxn*31][2],xo[maxn],ans,rt;
int val[maxn],n,head[maxn],tot;
struct code{int u,v,w;}edge[maxn<<1];
IL void read(int &x){
	int f=1;x=0;char s=getchar();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
IL void add(int x,int y,int z)
{
	edge[++tot].u=head[x];
	edge[tot].v=y;
	edge[tot].w=z;
	head[x]=tot;
	edge[++tot].u=head[y];
	edge[tot].v=x;
	edge[tot].w=z;
	head[y]=tot;
}
IL void build_trie(int x,int rt)
{
	for(RI i=1<<30;i;i>>=1)
	{
		bool c=x&i;
		if(!trie[rt][c])trie[rt][c]=++tot;
		rt=trie[rt][c];
	}
}
IL int query(int x,int rt)
{
	int ans=0;
	for(RI i=1<<30;i;i>>=1)
	{
		bool c=x&i;
		if(trie[rt][c^1])ans+=i,rt=trie[rt][c^1];
		else rt=trie[rt][c];
	}
	return ans;
}
IL void dfs(int u,int fa)
{
	for(RI i=head[u];i;i=edge[i].u)
	{
		if(edge[i].v!=fa)
		{
			xo[edge[i].v]=xo[u]^edge[i].w;
			dfs(edge[i].v,u);
		}
	}
}
int main()
{
	read(n);
	for(RI i=1,u,v,w;i<n;i++)read(u),read(v),read(w),add(u,v,w);
	dfs(1,0);
	for(RI i=1;i<=n;i++)build_trie(xo[i],rt);
	for(RI i=1;i<=n;i++)ans=std::max(ans,query(xo[i],rt));
	printf("%d",ans);
}
```


---

## 作者：winxp_qwq (赞：28)

首先对一条边异或2次，相当于没有异或。

这样的话 i -> j 的异或和，就是 i -> 1 的异或和，再异或上 1 -> j 的异或和。

处理出每个点到1路径的异或和，然后找两个，使它们异或起来最大。

~~有个智障觉得这是线性基，然后他就WA了~~

实际上只要把每个数看成一个01串，用Trie树搞一下。

每次从高位到低位贪心跑出异或最大值即可

时间复杂度O(n*30)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 100003
#define LL long long
LL ji[33]={0};
LL dis[maxn]={0};
vector <LL> ed[maxn];
vector <LL> l[maxn];
LL n,tt=1;
LL nex[maxn*33][2]={0};
void ins(LL x){
    LL a=0,b,c;
    for(b=30;b>=0;b--) {
        c=(x&(1<<b))>>b;
        if(!nex[a][c]) nex[a][c]=tt++;
        a=nex[a][c];
    }
}
LL qu(LL x) {
    LL a=0,b,c,ans=0;
    for(b=30;b>=0;b--) {
        c=(x&(1<<b))>>b;
        if(!nex[a][!c]) a=nex[a][c];
        else {a=nex[a][!c];ans+=(1<<b);}
    }
    return ans;
}
void dfs(LL x,LL fa) {
    for(LL a=0;a<(LL)ed[x].size();a++) {
        if(ed[x][a]!=fa) {
            dis[ed[x][a]]=(dis[x]^l[x][a]);
            dfs(ed[x][a],x);
        }
    }
}
int main(){
    LL a,b,c,i,j,k;
    scanf("%lld",&n);
    for(a=1;a<n;a++) {
        scanf("%lld%lld%lld",&i,&j,&k);
        ed[i].push_back(j);
        ed[j].push_back(i);
        l[i].push_back(k);
        l[j].push_back(k);
    }
    dfs(1,1);
    LL ans=0;
    for(a=1;a<=n;a++) ins(dis[a]);
    for(a=1;a<=n;a++) ans=max(ans,qu(dis[a]));
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Plus_Ultra (赞：9)

### 具体解法：
设 D[x] 表 示 根 节 点 到 的 路 径 上 的 所 有 边 权 的 XOR 值 ， 则 ：                                                             
#### D[X] = D[father[x]   ] ^ w[x,father[x] ].




 - 根 据 上 式 ， 我 们 可 以 对 树 进 行 DFS ， 求 出 所有 的 D[x] 。

- 树 上 X 到 Y 的 路 径 上 所 有 边 权 的 XOR 值 就 等 于 D[x] ^ D[y]。

 - 这 是 因 为 根 据 XOR 运 算 的 性 质（a^a=0）， 所 以 X 到 根 和 Y 到 根 这 两 路 径 重 叠 的 部 分 恰 好 抵 消 掉，
 
- 所 以 问 题 就 变 成 了 从 这 N 个 数 中 选 两 个 ， XOR 结 果 最 大 ， 我 们 就 可 以 用 Trie (踹) 树（手动滑稽）求 解。

 同 样 ， 需 注 意 的 是 ： 
 
 - 如 果 二 进 制 下 同 一 位不 相 同 , 则 为 1 , 否 则 为 0 .
 
 - 贪 心 的 想 ， 对 于 一 个 数 X ， 我 们 对 于 D[i]^x 最 大 ， 则 每 次 往 x相 反 的 值 选 。
 
 - 就 是 如 果 x 这 一 位 是 1 ， 我 们 在  trie 树 上 往 0 跑 ， 反 之 往 1 跑 。 这 样 的 才是 最 大 的 。
 
 下面是代码（其实我相信各位大佬也不需要代码）：


```
#include<iostream>

using namespace std;

#define N 100005

int p,ans=0,v[N],d[N],tot,trie[32*N][2],head[N],nxt[2*N],edge[2*N],len[2*N],n,u,v1,w;

void add(int x,int y,int z)
{
	edge[++tot]=y;
	len[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot;
}

void dfs(int x)
{
	for(int i=head[x];i;i=nxt[i])
	{
		int y=edge[i],z=len[i];
		if(v[y])  continue;
		v[y]=1;
		d[y]=d[x]^z;
		dfs(y);
	}
}

int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		cin>>u>>v1>>w;
		add(u,v1,w);
		add(v1,u,w);
	}
	
	v[1]=1;
	dfs(1);
	
	for(int i=1;i<=n;i++)
	{
		p=1;
		for(int j=31;j>=0;j--)
		{
			int k=(d[i]>>j)&1;
			if(!trie[p][k])  trie[p][k]=++tot;
			p=trie[p][k];
		}
		p=1;
		if(i!=1)
		{
			w=0;
			for(int j=31;j>=0;j--)
			{
				int k=(d[i]>>j)&1;
				if(trie[p][k^1])// 尽量走反方向，XOR值大 
				{
					w=(w<<1)+(k^1);
					p=trie[p][k^1];
				}
				else  if(trie[p][k])//不要忘记加else 
				{
					w=(w<<1)+k;
					p=trie[p][k];
				}
			}
			ans=max(ans,w^d[i]);
		}
	}
	
	cout<<ans<<endl;
	
	return 0;
}
```


---

## 作者：Treaker (赞：8)

这道题卡了半个小时，终于过了，来一发题解。

~~指针，一时写一时爽，一直写一直爽~~。
不过指针有时候会出一些莫名RE比较难受。

那么这道题，我们考虑贪心。

首先，两个点的dis异或一定是最短路径异或，因为LCA到根的那段路径，一异或就没了。所以放心异或。

然后，我们查询时，如果有和这个点相反的（0就找1,1就找0），那就去相反的点，继续遍历。

最后结束。
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 100010 , M = 30;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , ans;
int dis[N];
struct Edge
{
	int to , dis;
	Edge *nxt;
	Edge (int to = 0,int dis = 0,Edge *nxt = NULL) : to(to) , dis(dis) , nxt(nxt) {}
}*head[N];
void dfs(int now)
{
	for(Edge *i = head[now];i;i = i -> nxt)
	{
		int to = i -> to;
		if(dis[to] || to == 1)	continue;
		dis[to] = dis[now] ^ i -> dis;
		dfs(to);
	}
}
struct Trie
{
	struct node
	{
		node *ch[2];
		node () {memset(ch,0,sizeof ch);}
	}*root;
	inline void insert(int x)
	{
		node *p = root;
		for(int i = M , tmp;i >= 0;i --)
		{
			tmp = (x >> i) & 1;
			if(p -> ch[tmp] == NULL) p -> ch[tmp] = new node();
			p = p -> ch[tmp];
		}
	}
	inline void query(int x)
	{
		node *p = root; int res = 0;
		for(int i = M , tmp;i >= 0;i --)
		{
			tmp = (x >> i) & 1;
			if(p -> ch[tmp ^ 1]) p = p -> ch[tmp ^ 1] , res |= (1 << i);
			else if(p -> ch[tmp]) p = p -> ch[tmp];
			else return;
		}
		ans = max(ans,res);
	}
	Trie () {root = new node();}
}cf;
int main()
{
	n = read();
	for(int i = 1 , u , v , w;i < n;i ++)
	{
		u = read(); v = read(); w = read();
		head[u] = new Edge(v,w,head[u]);
		head[v] = new Edge(u,w,head[v]);
	}
	dfs(1);
	for(int i = 1;i <= n;i ++)
	{
		cf.insert(dis[i]);
		cf.query(dis[i]);
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：xhQYm (赞：5)

- 题目链接：[P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)


不会 Trie 树的建议百度自行学习（非常简单）。

看到异或，我们首先很容易想到 01Trie树 还有 线性基 。

这题很明显要用 Trie树 来做。

大致思路：

> 通过 `dfs` 寻找路径，之后通过 Trie树 求最大值。

每个数可以看成是一个由 $0$ 和 $1$ 构成的一个字符串（二进制），之后用 Trie树 做法就很显然了。

详细讲解：

> 每一位进行贪心，如果同一位有一个和它不同的，这样异或的值就会大，我们就顺着这条路线往下走，反之按原路走。

由于高位大决定一切，所以我们贪心是对的。

代码（不懂看注释，但是感觉很容易懂）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=N<<1,K=N<<5;
int n;
int h[N],e[M],w[M],ne[M],idx;
int son[K][2],cnt[N],res,t=1;
char str[N];
void add(int a,int b,int c){e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;}
void insert(int x)
{
    int p=1;
    for(int i=30;i>=0;i--)
    {
        int u=((x>>i)&1);//取当前第i位
        if(!son[p][u]) son[p][u]=++t;
        p=son[p][u];
    }
}
void check(int x)
{
    int ans=0,p=1;//ans用来记录
    for(int i=30;i>=0;i--)
    {
        int u=((x>>i)&1);
        if(son[p][u^1]) p=son[p][u^1],ans+=(1<<i);
        //重点：如果当前位有不同的，即if(son[p][u^1])，我们就顺着这条路走。如果没有就执行下面的，继续按照原路走
        else p=son[p][u];//原路继续走
    
    }
    res=max(res,ans);//最后取max
}
void init(int x){insert(x);check(x);}
void dfs(int x,int last)
{
    init(cnt[x]);
    for(int i=h[x];~i;i=ne[i])//搜索父节点
    {
        int j=e[i];
        if(j==last) continue;//这里由于不会原路返回，所以是搜索父节点
        cnt[j]=cnt[x]^w[i];//进行异或
        dfs(j,x);
    }
}
int main()
{
    memset(h,-1,sizeof h);//邻接表初始化
    scanf("%d",&n);
    int a,b,c;
    for(int i=0;i<n-1;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c),add(b,a,c);
    }
    dfs(1,0);
    printf("%d",res);
    return 0;
}
```

推荐类似题目：[AcWing 143 最大异或和](https://www.acwing.com/problem/content/145/)

其实这题真的不难，只有会 Trie树 就很简单了，贪心策略也十分好想。

如果有问题或者文章错误欢迎提出。



---

## 作者：qwaszx (赞：4)

$01Trie$可以解决很多异或问题

$01Trie$就是把数看成$32$位的二进制串插入到$Trie$里面，这样它就有单次$O(32)$的时间复杂度和$O(32n)$的空间复杂度.~~其实正int是31~~

异或有一个重要的性质:$a\ xor\ b\ xor\ b=a$

还有常见的交换律，结合律什么的

这里用$(i,j)$表示$i$到$j$路径上的异或和

于是$(i,j)=(i,lca(i,j))\ xor\ (j,lca(i,j))=((1,i)\ xor\ (1,lca(i,j)))\ xor\ ((1,j)\ xor\ (1,lca(i,j)))=(1,i)\ xor\ (1,j)$

于是问题变成了经典的[最大异或数对](https://loj.ac/problem/10050)

$dfs$处理出$1$到每个点的异或和，插到$01Trie$中

枚举每个点，每一位贪心地选取相反的值

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
struct Edge{int u,v,w;}e[1000000];
int n,mm,w[1000000],ans,l[1000000],r[1000000],nxt[1000000],fst[1000000];
struct Trie
{
    int a[5000005][2],size;
    void ins(int x)
    {
        int u=0;
        for(int i=30;i>=0;i--)
        {
            int t=x>>i;x=x&((1<<i)-1);
            if(!a[u][t])a[u][t]=++size;
            u=a[u][t];
        }
    }
    int find(int x)
    {
        int u=0,ans=0;
        for(int i=30;i>=0;i--)
        {
            int t=x>>i;x=x&((1<<i)-1);
            if(a[u][t^1])ans|=1<<i,u=a[u][t^1];
            else u=a[u][t];
        }
        return ans;
    }
}a;//01Trie
void ade(int u,int v,int w)
{
    Edge *z=e+(++mm);
    z->u=u,z->v=v,z->w=w;
    nxt[mm]=fst[u],fst[u]=mm;
}
void dfs(int u,int fa)
{
    a.ins(w[u]);
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=e[i].v;
        if(v!=fa)
        {
            w[v]=w[u]^e[i].w;
            dfs(v,u);
        }
    }
}//dfs处理
int getin()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x;
}//快读
int main()
{
    n=getin();
    for(int i=1;i<n;i++)
    {
        int u=getin(),v=getin(),w=getin();
        ade(u,v,w),ade(v,u,w);
    }
    dfs(1,0);
    for(int i=1;i<=n;i++)
        ans=max(ans,a.find(w[i]));
    cout<<ans<<endl;
}
```

---

## 作者：WanderingTrader (赞：3)

异或是啥，想必大家都很清楚了，这里只提几个常用公式：
$$
a\oplus0=a\\
a\oplus a=0
$$
由此可以引申出：
$$
\begin{matrix}\underbrace{a\oplus a\oplus a\oplus\cdots\oplus a}\\2n+1个a\end{matrix}=a
$$
$$
\begin{matrix}\underbrace{a\oplus a\oplus a\oplus\cdots\oplus a}\\2n个a\end{matrix}=0
$$
### 题目分析
首先我们看到，题目中说的是任意两点边权异或和，一共有 $n^2$ 个不同的数值，而 $n\le10^5$。  

$n^2$ 的规模太大了，所以我们希望能把数据的规模减小。

我们容易得到以下公式：
$$d_{u,v}=d_{u,x}\oplus d_{x,v}(u,v,x\in V)$$ 
那么我们可以给 $x$ 取特殊值，比如 $1$，然后无根树转有根树，把 $n^2$ 的数据规模缩小至 $n$。

不难证明这个公式的正确性：  
以 $x$ 为根重构树，如果 $u,v$ 不在一条链上，那么 $x$ 处于路径 $(u,v)$ 上，以它为中心将路径劈成两份，自然没问题。  
如果 $u,v$ 在一条路径上，不妨假设 $u$ 是 $v$ 的祖先，那么在异或过程中，$d_{u,x}$ 被异或了两次，抵消了。

那么思路就很清楚了：求出从根节点到各个节点的路径异或值，然后从中任取两个异或，使得到的结果最大。

如何完成这个任务？我们可以使用字典树中的一种，01字典树。

把各个值拉成二进制，然后以固定的长度（此处由于 $w<2^{31}$，可以取31）存入一棵字典树中。然后在搜索时每一位尽量取不一样的两个数使其异或值为1，如果实在不行那就取0。这其实是在字典树上做贪心。

如何证明这种方法是正确的呢？可以采用“反证法+局部调整”。

假设在某一位可以取1的情况下取了0，结果会如何呢？

设这一位的深度是 $d$ **（叶子结点的深度是 $0$，根节点的深度是 $31$）**，那么如果这一位取了0，ans就失去了 $2^d$。就算接下来每一位都是1，最终ans只获得了 $\sum\limits_{x=1}^{d-1}2^x=2^d-1$，还是没有 $2^d$ 大。所以能取1的一定要取1。

思路就是这样。如果还是没明白，不妨看代码吧。
### 代码
字典树不说，先得把多叉树建起来。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
vector <int> to[maxn],w[maxn];
int val[maxn];
void dfs(int u,int fa)
{
	int size=to[u].size();
	for(int i=0;i<size;++i)
	{
		int v=to[u][i];
		if(v==fa) continue;
		val[v]=val[u]^w[u][i];
		dfs(v,u);
	}
}
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f; 
}
int main()
{
	int n=read();
	for(int i=1;i<n;++i)
	{
		int u=read(),v=read(),d=read();
		to[u].push_back(v);w[u].push_back(d);
		to[v].push_back(u);w[v].push_back(d);
	}
	dfs(1,0);
	return 0;
}
```
树上的dfs想必大家都很熟悉了，这里不作过多解释。

要建一棵字典树，我们得有这几个数据：字典树的结点数目，每个节点的左右儿子（分别代表01），最好还带上以这个结点为结尾的数据的值，一会在查询的时候有用。
```cpp
const int maxnode=2e6+5;
struct Trie
{
	int sz;
	int tr[maxnode][2];
	int mark[maxnode];
	Trie(){sz=0;memset(tr,-1,sizeof(tr));}
	void insert(int);
	int query(int); 
};
Trie trie=Trie();
```
字典树有多少个结点呢？理论上最大会是一棵深度为 $31$ 的满二叉树，节点数有 $2^{32}-1$ 个，但是实际上，$n$ 个数据每个至多只会花费 $31$ 个结点，所以应该是 $3\times10^6$，不过事实上会比这少的多，经我实测，$2\times10^6$ 就已经够了。

现在我们来写insert函数。  
我们从 $30$ 开始遍历到 $0$，分别将插入的数 $x$ 按位与上 $2^i$ （即取出第 $i$ 位），然后建树。如果发现某个结点不存在（编号为 $-1$），那么创建这个新节点即可。最后把叶子结点对应的值赋上。

代码很好理解，如下：
```cpp
void Trie::insert(int x)
{
	int u=0;
	for(int i=30;i>=0;--i)
	{
		bool h=x&(1<<i);
		if(tr[u][h]==-1)
			tr[u][h]=++sz;
		u=tr[u][h];
	}
	mark[u]=x;
}
```
写字典树的代码时，无论何时要记住：$0$ 号结点永远是 **虚拟** 的根节点，不可以存值。这也是为什么新建结点时用++sz而不是sz++。

接下来就是查询了。这里我们给query(x)的定义是：找出与 $x$ 异或后最大的值，也就是在每一位上做贪心，尽量找与 $x$ 不同的值。

写法上与insert是有一点类似的，也非常好理解：
```cpp
int Trie::query(int x)
{
	int u=0;
	for(int i=30;i>=0;--i)
	{
		bool h=x&(1<<i);
		if(tr[u][!h]!=-1)
			u=tr[u][!h];
		else 
			u=tr[u][h];
	}
	return mark[u]^x;
}
```
为了方便，最后的返回值直接异或上了 $x$。

那么主函数添加这几行代码即可：
```cpp
	for(int i=1;i<=n;++i)
		trie.insert(val[i]);
	int ans=-1;
	for(int i=1;i<=n;++i)
		ans=max(ans,trie.query(val[i]));
	printf("%d\n",ans);
```
全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
const int maxnode=2e6+5;
vector <int> to[maxn],w[maxn];
int val[maxn];
struct Trie
{
	int sz;
	int tr[maxnode][2];
	int mark[maxnode];
	Trie(){sz=0;memset(tr,-1,sizeof(tr));}
	void insert(int);
	int query(int); 
};
Trie trie=Trie();
void dfs(int u,int fa)
{
	int size=to[u].size();
	for(int i=0;i<size;++i)
	{
		int v=to[u][i];
		if(v==fa) continue;
		val[v]=val[u]^w[u][i];
		dfs(v,u);
	}
}
void Trie::insert(int x)
{
	int u=0;
	for(int i=30;i>=0;--i)
	{
		bool h=x&(1<<i);
		if(tr[u][h]==-1)
			tr[u][h]=++sz;
		u=tr[u][h];
	}
	mark[u]=x;
}
int Trie::query(int x)
{
	int u=0;
	for(int i=30;i>=0;--i)
	{
		bool h=x&(1<<i);
		if(tr[u][!h]!=-1)
			u=tr[u][!h];
		else 
			u=tr[u][h];
	}
	return mark[u]^x;
}
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f; 
}
int main()
{
	int n=read();
	for(int i=1;i<n;++i)
	{
		int u=read(),v=read(),d=read();
		to[u].push_back(v);w[u].push_back(d);
		to[v].push_back(u);w[v].push_back(d);
	}
	dfs(1,0);
	for(int i=1;i<=n;++i)
		trie.insert(val[i]);
	int ans=-1;
	for(int i=1;i<=n;++i)
		ans=max(ans,trie.query(val[i]));
	printf("%d\n",ans);
	return 0;
}
```
总复杂度看似是 $O(n\log w)$，不过这里我们直接取了定值 $31$
，所以也相当于一个大常数的 $O(n)$，但已经可以AC本题。
$$\texttt{The End.}$$

---

## 作者：YellowBean_Elsa (赞：3)

首先注意到 xor 的交换结合律以及 $a \operatorname{xor} a=0$，我们把每条路径 $<a,b>$ 的 xor 和转化成 “(a 到根的 xor 和) xor (b 到根的 xor 和)”。

现在题目转化为一个经典问题：

**从一堆数里面选出 2 个，使她们的 xor 和最大。**

这种东西我第一反应线性基 ~~结果被某巨佬的题解骂了zz嘤嘤嘤~~

然而线性基不行，于是她闪亮登场——

#### XOR Trie

利用字典树，把每个数当成一个 01 串插入字典树。（即每个节点有两个儿子分别代表下一位是 0 和 1 的数）

注意要把每个串的二进制位数化为相同的。

然后对于每个数，我们贪心地查找哪个串和她 xor 最大，这显然是每一位尽可能找和她该位不一样的。（是 0 就找 1，是 1 就找 0）

时间复杂度 $O(n \cdot len)$，其中 len 是字符串长度。
```cpp
//coder: Feliks*GM-YB
#include<bits/stdc++.h>
#define fu(i,a,b) for(register int i = a, I = (b) + 1; i < I; i++)
#define fd(i,a,b) for(register int i = a, I = (b) - 1; i > I; i--)
#define go(x) for(int i=first[x],y=v[i];i;i=nex[i],y=v[i])
typedef long long ll;
using namespace std;
const int N=1e5+50;
inline int read(){
    int x=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x;
}int n,m,num=1;
int v[N<<1],nex[N<<1],w[N<<1],first[N],tot;
inline void add(int x,int y,int z){
    v[++tot]=y;w[tot]=z;
    nex[tot]=first[x];
    first[x]=tot;
}struct Trie{
	int son[2];
	Trie(){son[0]=son[1]=0;}
}t[N<<5];
int d[N],ans;
void dfs(int x,int f){
	go(x){
		if(y==f)continue;
		d[y]=d[x]^w[i];
		dfs(y,x);
	}
}inline void ins(int s){	//Trie插入
	int now=1,x;
	fd(i,30,0){				//都化为 31 位二进制数 
		x=(s>>i)&1;			//找到第 i 位 
		if(t[now].son[x])now=t[now].son[x];
		else now=t[now].son[x]=(++num);
	}
}inline int find(int s){	//对于s查找xor最大的数 
	int now=1,x,cp=0;		//cp：找的数 
	fd(i,30,0){
		x=(s>>i)&1;
		if(t[now].son[x^1]){//尽量找不一样的 
			now=t[now].son[x^1];
			cp=(cp<<1)|(x^1);
		}else{				//找不到也没办法 
			now=t[now].son[x];
			cp=(cp<<1)|x;
		}
	}return cp^s;
}
int main(){
	n=read();
	fu(i,1,n-1){
		int x=read(),y=read(),z=read();
		add(x,y,z),add(y,x,z);
	}dfs(1,0);
	fu(i,1,n)ins(d[i]);
	fu(i,1,n)
		ans=max(ans,find(d[i]));
	printf("%d\n",ans);
	return 0;
}
```
#### 多嘴一句

xor （最值）问题的常见方法有 xor Trie & 线性基。

个人看法，如果是选任意多数 xor，应该用线性基；如果是 2 个数，绝定 xor Trie。

---

## 作者：_xcc_ (赞：3)

最直接的思路是$n^2$枚举所有点对计算异或值, LCA预处理一下可以拿满暴力分

在LCA基础上我们很容易发现只要dfs预处理出每个点到根节点路径上的异或之和d[x], 那么x,y两点之间路径异或和就为d[x]^d[y]

这是因为x^x=0, 也就是他们最近公共祖先以上的部分异或和直接抵消了

所以问题就变成了在d[1~n]中任选两个数, 使他们的异或值最大, 愉快的变成了Trie树板子题

详细讲, 基于贪心思想, 选一对数x,y, 从高位到低位, 要尽量满足每一位都不同, 其次暂时考虑让他们相同

把 d[1~n] 构造成一颗trie, 就能方便地把d中的一个数拿出来与其他所有串匹配, 找到异或值最大的那个

把1~n每个数拿出来匹配一次即得最优答案

~~吐槽:考场上被快读坑了一把, 详见代码, 压行害人不浅!!!~~

```
#include<cstdio>
#define re register
#define in inline
in int read()
{
    int s=0,b=0;
    char ch;
    do{
        ch=getchar();
        if(ch=='-') b=1;
    }while(ch<'0' || ch>'9');
    while(ch>='0' && ch<='9')
    {
        s=(s<<3)+(s<<1)+(ch^'0');
        ch=getchar();
    }
    return b?-s:s;
}
int n,d[100001];
struct edge{
    int t,w,nxt;
}e[100001*2];
int head[100001],cnt=0;
in void add(int f,int t,int w)
{
    e[++cnt].t=t;
    e[cnt].w=w;
    e[cnt].nxt=head[f];
    head[f]=cnt;
    e[++cnt].t=f;
    e[cnt].w=w;
    e[cnt].nxt=head[t];
    head[t]=cnt;
}
void dfs(int now,int fa)
{
    for(re int i=head[now];i;i=e[i].nxt)
    {
        if(e[i].t!=fa){
            if(now!=1) d[e[i].t]=d[now]^e[i].w;
            else d[e[i].t]=e[i].w;
            dfs(e[i].t,now);
        }
    }
}//dfs求d数组
int trie[9999999][2],cntt=1;
in void insert(int a)
{
    int p=1;
    for(re int i=30;i>=0;--i)
    {
        int ch=(a>>i)&1;//分解a的每个二进制位
        if(!trie[p][ch]) trie[p][ch]=++cntt;
        p=trie[p][ch];
    }
}//建trie树
in int find(int a)
{
    int p=1,ans=0;
    for(re int i=30;i>=0;--i)
    {
        int ch=!((a>>i)&1);
        if(!trie[p][ch]){//如果没有不同的位
            if(trie[p][!ch]) p=trie[p][!ch];//暂时只能先往下走
            else return ans;//到达串尾
        }
        else p=trie[p][ch],ans+=(1<<i);//有不同的位, 贡献加入答案
    }
    return ans;
}//求一个串与其他所有串的最大异或值
signed main()
{	
    n=read();
    int f,t,w;
    for(re int i=1;i<=n-1;++i)
    {
        //add(read(),read(),read());
        //上面是错误写法!!!三个read()是从右至左执行的, 参数顺序错误!!!
        f=read();
        t=read();
        w=read();
        add(f,t,w);
    }
    dfs(1,0);
    for(re int i=1;i<=n;++i)
        insert(d[i]);
    int ans=0;
    for(re int i=1;i<=n;++i)
    {
        int t=find(d[i]);
        if(t>ans) ans=t;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：szr666 (赞：3)

我这里推荐一下[我的博客](https://www.luogu.org/blog/szr666--blog/)

在博客里观看更美观哦~

[题目](https://www.luogu.org/problemnew/show/P4551)
------------


------------

华丽的分割线
# 解析
此题使用异或利器——01字典树

先讲一下01字典树

01字典树能解决在n个数中，选择一个数，使得x^这个数最大，复杂度为O(31)

首先int有32位，第一位为符号位，我们把其余31位当作一个只含0、1的字符串

从最高位到最低位加入到tire树中，int tire[31n][2]空间复杂度为62n

主要说一下基本tire树的基本知识，tire树本身用来在文章中查询单词

![](https://cdn.luogu.com.cn/upload/pic/56370.png)

如果一篇文章有a abc abc ba bac cd这些单词，则tire树如图所示

其中圆圈内为节点编号，左侧为所存字符，右下角有星星则该节点为一个单词的结尾

int tire[u][ch] 表示第u个节点是否有字符为ch+'a'

(若字符为s,ch=s-'a',ch取值范围0-25)的儿子，

如果有，tire[u][ch]=儿子的编号，否则为0

int val[u] 表示第u个节点是否为单词结尾，是为1，否为0

#### 插入操作：
对于字符串s,i从0到len-1循环，从1号节点(根)出发

如果没有儿子的字符为s[i]，为新儿子分配一个编号，然后跳到儿子编号,i++

直到循环结束，val[当前儿子编号]=1，表示单词结尾

tire树优点？把具有相同前缀的字符串前缀只存一次，查询时速度快。

缺点？以空间换时间

val数组的作用？如果文章有abcd,查询abc,没有val数组会return 1。

所以val数组可防止查询已有单词前缀的情况

#### 查询操作:
对于字符串s,i从0到len-1循环，从1号节点(根)出发

如果不存在儿子字符为s[i]，return -1，否则跳到儿子编号,i++

直到循环结束，val[当前儿子编号]=1，return 1,否则return -1

与插入操作大同小异

现在看01字典树如何实现

```cpp
void insert(int x)
{
    int u,i;
    u=1;
    bool ch;
    for(i=30;i>=0;i--)
    {
        ch=(x&(1<<i))>>i;
        if(tire[u][ch]==0)
        {
            sz++;
            tire[u][ch]=sz;
        }
        u=tire[u][ch];
    }
}
```

sz为当前节点数

对于x,(x&(1<<i))>>i表示取出x第i+1位

比如x=5,i=2;1<<i=100,x=101,x&(1<<i)=100,(x&(1<<i))>>i=1;

其他与正常字典树相同，查询同理

说了这么多，现在终于可以做这道题了

#### 求i到j路径异或和

因为i到j的路径可由根节点1中转，所以只要预处理出1到i的路径异或和xorr[i]，跑dfs即可

因为x^y^z=x^(y^z),异或具有结合性，所以i到j路径异或和=xorr[i]^xorr[j]

也就是说i到j路径异或和=i到1路径异或和^1到j路径异或和

#### 求i到任意节点路径异或和最大值

把xorr数组从1到n加到01字典树

i到任意节点路径异或和最大值=xorr[i]^xorr[使结果最大点的编号]

由于插入由高位到低位，所以尽可能使高位异或出1

```cpp
int search(int x)
{
    int u,i,ans;
    u=1;
    ans=0;
    bool ch;
    for(i=30;i>=0;i--)
    {
        ch=(x&(1<<i))>>i;
        if(tire[u][ch^1]!=0)
        {
            ans+=1<<i;
            u=tire[u][ch^1];
        }
        else
        {
            u=tire[u][ch];
        }
    }
    return ans;
}
```
如果有是x的第i+1位异或值为1的儿子（ch^1的解释：0^1=1,1^1=0）

那么从它往下找，ans加1<<i(选择这个儿子的价值)，否则直接向下找

这样用O(31)实现了求i到任意节点路径异或和最大值,

再枚举i从1到n,再取最大值即可

插入O(31n),查询O(31n),总复杂度O(62n)

加读入优化更快哦

# 代码

```cpp
#include<cstdio>
using namespace std;
void read(int &x)
{
    int f;
    char c;
    x=0;
    f=1;
    c=getchar();
    while((c<'0'||c>'9')&&c!='-')
    {
        c=getchar();
    }
    if(c=='-')
    {
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    x=x*f;
}
int max(int x1,int x2)
{
    return x1>x2 ? x1 : x2;
}
struct node
{
    int to;
    int val;
    int next;	
};
node e[200000];
int head[200000];
int xorr[200000];
int tot,n,sz;
int tire[6000000][2];
void add(int u,int g,int v)
{
    tot++;
    e[tot].val=v;
    e[tot].to=g;
    e[tot].next=head[u];
    head[u]=tot;
}
void dfs(int u,int fa)
{
    int j;
    for(j=head[u];j!=0;j=e[j].next)
    {
        if(e[j].to!=fa)
        {
            xorr[e[j].to]=xorr[u]^e[j].val;
            dfs(e[j].to,u);
        }
    }
}
void insert(int x)
{
    int u,i;
    u=1;
    bool ch;
    for(i=30;i>=0;i--)
    {
        ch=(x&(1<<i))>>i;
        if(tire[u][ch]==0)
        {
            sz++;
            tire[u][ch]=sz;
        }
        u=tire[u][ch];
    }
}
int search(int x)
{
    int u,i,ans;
    u=1;
    ans=0;
    bool ch;
    for(i=30;i>=0;i--)
    {
        ch=(x&(1<<i))>>i;
        if(tire[u][ch^1]!=0)
        {
            ans+=1<<i;
            u=tire[u][ch^1];
        }
        else
        {
            u=tire[u][ch];
        }
    }
    return ans;
}
int main()
{
    tot=0;
    sz=1;
    int n,i,u,g,v,ans;
    read(n);
    for(i=1;i<=n-1;i++)
    {
        read(u);
        read(g);
        read(v);
        add(u,g,v);	
    }
    dfs(1,0);
    for(i=1;i<=n;i++)
    {
        insert(xorr[i]);
    }
    ans=0;
    for(i=1;i<=n;i++)
    {
        ans=max(ans,search(xorr[i]));
    }
    printf("%d",ans);
}
```


---

## 作者：撤云 (赞：2)

[点击食用效果更佳](https://www.cnblogs.com/hbxblog/p/10167136.html)
#### 题目链接
[戳我](https://www.luogu.org/problemnew/show/P4551)
### 前置知识
1. 什么是异或？
 + 如果二进制下同一位不相同,则为一,否则为0
$$eg:(3)_{10}\ xor \ (2)_{10}=(11)_2\ xor\ (10)_2=(01)_2=1 $$

2. tire树

3. 基本位运算

对于同一条边异或两次，相当于没有进行异或，我们将dis[i]表示为从i点到根节点的路径异或和。则问题转化为了求两点的dis异或最大值

我们可以根据dis构建一颗01 tire树(自行百度)

贪心的想，对于一个数X，我们对于dis[i]^x最大，则每次往x相反的值选。  
及如果x这一位是1，我们在tire树上往0跑，反之往1跑。这样的一定是最大的。


#### code
```cpp

#include<bits/stdc++.h>
#define int ll
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
typedef long long ll;
const int N=1000010;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
int dis[N],head[N],cnt,tot=1;
struct node {
    int to,next,v;
}b[N<<1];
void dfs(int x,int fa){
    for(int i=head[x];i;i=b[i].next){
        int v=b[i].to;
        if(v==fa)
            continue;
        dis[v]=dis[x]^b[i].v;		
        dfs(v,x);
    }
}
void add(int x,int y,int v){
    b[++cnt].to=y;
    b[cnt].next=head[x];
    b[cnt].v=v;
    head[x]=cnt;
}
struct node1 {
    int ch[2];
}a[N<<2];
void build(int x){
    int u=1;
    for(int i=32;i>=0;i--){
        int c=(x>>i)&1;
        if(!a[u].ch[c])
            a[u].ch[c]=++tot;
        u=a[u].ch[c];
    }
}
int find(int x){
    int u=1,ans=0;
    for(int i=32;i>=0;i--){
        int c=((x>>i)&1)^1;
        if(a[u].ch[c])
            u=a[u].ch[c],ans+=1<<i;
        else
            u=a[u].ch[c^1];
    }
    return ans;
}
 main(){
    int n=read(),x,y,z,ans=0;
    for(int i=1;i<n;i++)
        x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);
    dfs(1,0);
    for(int i=1;i<=n;i++)
        build(dis[i]);
    for(int i=1;i<=n;i++)
        ans=max(ans,find(dis[i]));
    printf("%lld",ans);
    return 0;
}

```

---

## 作者：牛蛙丶丶 (赞：1)

### 题意
给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $N$ 。寻找树中找两个结点，求最长的异或路径。

异或路径指的是指两个结点之间唯一路径上的所有边权的异或。

### 解法
- 先预处理出从根结点到所有结点的路径上的 $xor$ 值，显然 $d(x) = d(fa)$ ^ $val(fa \to x)$。

- 又因为异或有一性质 $a$ ^ $a=0$ ，所以可以发现从 $x$ 到 $y$ 的异或路径就是 $d(x)$ ^ $d(y)$，因为 $d(1)$ ^ $d(x-1)$ 经过两次计算相抵消了。

- 然后问题就转化了在 $1 \le i,j\le n$ 中找到最大的 $d(i)$ ^ $d(j)$，把每个数看做一个二进制01串，建立一棵01字典树，利用贪心的思想每次找与当前位相反的结点即可。

### 代码
```cpp
#include <iostream>
#include <algorithm>
#define M 200070
#define N 5000070

using namespace std;

struct Edge
{
	int to,nxt,w;
}e[M];
int n,ans,cnt,tot;
int d[M],head[M],nxt[N][2];

void add(int from,int to,int val){
	e[++cnt].to=to;
	e[cnt].w=val;
	e[cnt].nxt=head[from];
	head[from]=cnt;
}

void dfs(int x,int fa){
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		d[v]=d[x]^e[i].w;
		dfs(v,x);
	}
}

void insert(int x){
	int c=0,op;
	for(int i=31;i>=0;--i){
		op=((x>>i)&1);
		if(!nxt[c][op])
			nxt[c][op]=++tot;
		c=nxt[c][op];
	}
}

int query(int x){
	int c=0,sum=0,op;
	for(int i=31;i>=0;--i){
		op=((x>>i)&1);
		if(nxt[c][op^1])
			c=nxt[c][op^1],sum=sum<<1|1;
		else
			c=nxt[c][op],sum=sum<<1;
	}
	return sum;
}

int main(){
	cin>>n;
	for(int i=1;i<n;++i){
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,w);
	}
	dfs(1,0);
	insert(d[1]);
	for(int i=2;i<=n;++i){
		ans=max(ans,query(d[i]));
		insert(d[i]);
	}
	cout<<ans<<endl;
}
```

时间复杂度为$\Theta (31*N)$。

---

## 作者：lxy__ (赞：1)

## tire

借鉴[这里](https://www.luogu.org/blog/sdlang/Trie-study-text)：日报大佬写的trie和可持久化trie。

异或的性质：异或具有**交换律**和**结合律**，并且一个数异或它本身=0

文中路径的异或和=路径上所有边权的异或和。

### 如何求出两点之间路径的异或和

设这两个点为a,b

这两点之间的距离就是(根到a的异或和)^(根到b的异或和)

证明：如果按照一般的方法计算ab之间的距离，它等于(a到LCA(a,b)的异或和)^(b到LCA(a,b)的异或和)。按照刚才的计算方法，比一般方法多异或了两次【根到LCA(a,b)的异或和】。两次异或这个东西相当于没有异或。所以这两种方法得出的答案相同。

### trie上场

问题:给出n个数，求两个数异或能得到的最大值。范围n<=10^5。loj题目链接:https://loj.ac/problem/10050

有一种贪心的做法：把每个数**高位补足0**后插入到字典树中，求与数i异或能得到的最大值，可以从从高位开始，使**每一位尽量不同**。因为当前位不同时才能对答案产生贡献。转化到字典树上就是，从根节点开始，每次都尽量使 当前节点 与 数i的对应位置上的数 不同。

考虑两数比大小，当位数相同，总是从高位开始比较。如两个二进制数比较大小：10000(2)>01111(2)。所以这个贪心~~显然~~是对的。

在此题中记录根节点到每个节点路径的异或和（dfs一遍），然后把它们当成上题中的一个个【数】，插入到字典树中维护。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define int long long
using namespace std;

const int N = 100005;
struct edge
{
	int nxt, to, w;
} e[N * 2];
int n, cnt = 0, ans = 0, sum = 0, head[N], trie[N * 31][2], p[N];

void add(int x, int y, int w)
{
	e[++cnt] = (edge) { head[x], y, w };
	head[x] = cnt;
}

void dfs(int x, int fa, int now)
{
	p[x] = now;
	for(int i = head[x]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if(v == fa) continue;
		dfs(v, x, now ^ e[i].w);
	}
}

void insert(int x)
{
	int root = 0;
	for(int i = 30; i >= 0; i--)
	{
		int pos = (p[x] >> i) & 1;
		if(!trie[root][pos]) trie[root][pos] = ++sum;
		root = trie[root][pos];
	}
}

int find(int x)
{
	int root = 0, res = 0;
	for(int i = 30; i >= 0; i--)
	{
		int pos = (p[x] >> i) & 1;
		if(trie[root][pos ^ 1])
			root = trie[root][pos ^ 1], res += 1 << i;
		else root = trie[root][pos];
	}
	return res;
}

signed main()
{
	scanf("%lld", &n);
	for(int a, b, c, i = 1; i < n; i++)
	{
		scanf("%lld%lld%lld", &a, &b, &c);
		add(a, b, c);
		add(b, a, c);
	}
	dfs(1, 0, 0);
	for(int i = 1; i <= n; i++) insert(i);
	for(int i = 1; i <= n; i++) ans = max(ans, find(i));
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：Polaris_Dane (赞：1)

第一眼看到题目以为是Trie树+点分治

当然这种做法固然可以（这里不给出代码，太麻烦了）

每次分治时将Trie树清空（简单的方法就是将根节点的左右儿子设为空）

但是查一查异或的性质可以知道，两次异或同一个数得到的答案就是原来的数

所以说我们并不需要点分治，因为即使两个点的路径不经过根节点

你只用求出每个点到根节点的异或路径值，最后将他们异或就有了最大值

所以并不用考虑路径是否经过根节点，直接算就好了

然后建立Trie树，贪心一步步去找相反的位置就好了

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<queue>
#define M 2001000
#define inf 0x3f3f3f3f 
#define LL long long
using namespace std;
LL n,head[M],cnt,cnte=1;
LL ans,dist[M];
struct edge{
	LL to,next,val;
}e[M];
struct trie{
	LL ch[2];
}t[M];
void add(LL a,LL b,LL c)
{
	e[++cnt].to=b;
	e[cnt].next=head[a];
	e[cnt].val=c;
	head[a]=cnt;
}
inline void read(LL &x)
{
	LL f=1;x=0;char s=getchar();
	while (!isdigit(s)){
		if(s=='-')f=-1;
		s=getchar();
	}
	while (isdigit(s))
	{
		x=(x<<1)+(x<<3)+(s^48);
		s=getchar();
	}
	x*=f;
}
void insert(LL u)
{
	LL now=1;
	for (int i=1<<30;i;i>>=1)
	{
		int rt=(u&i?1:0);
		if (!t[now].ch[rt])
		{
			t[now].ch[rt]=++cnte;
		}
		now=t[now].ch[rt];
	}
}
LL getmax(LL u)
{
	LL now=1,maxx=0;
	for (int i=1<<30;i;i>>=1)
	{
		int rt=(u&i?1:0);
		if (t[now].ch[!rt])
		{
			maxx+=i;
			now=t[now].ch[!rt];
		}
		else
		{
			now=t[now].ch[rt];
		}
	}
	return maxx;
}
void getdis(LL u,LL fa)
{
	for (int i=head[u];i;i=e[i].next)
	{
		if (e[i].to==fa)
		{
			continue;
		}
		dist[e[i].to]=dist[u]^e[i].val;
		insert(dist[e[i].to]);
		getdis(e[i].to,u);
	}
}
int main()
{
	read(n);
	for (int i=1;i<=n-1;i++)
	{
		LL x,y,c;
		read(x);read(y);read(c);
		add(x,y,c);
		add(y,x,c);
	}
	getdis(1,0);
	for (int i=1;i<=n;i++)
	{
		ans=max(ans,getmax(dist[i]));
	}
	printf("%lld",ans);
    return 0;
}

```


---

## 作者：TheShadow (赞：1)

# 闲扯

$0/1\ Trie$ 的模板题，数组开小了怎么说？？？

# 题面

[题面](https://www.luogu.org/problem/P4551)

# Solution

要求树上路径的问题我们有一个套路的做法。

每一个点 $i$ 到根结点的路径权值的异或和我们计作 $dis_i$

$u$ 到 $v$ 的路径权值的异或和我们可以拆分一下，即 $dis_{u,v}=dis_u\ xor\ dis_v$ 。

这样问题就转化成了找出两个点 $u,v$ ，使得 $dis_u\ xor\ dis_v$ 最大。

进一步转化。

对于异或的问题，我们可以将其转化为二进制，求每一位的异或。

根据贪心的思想，我们从高到低每一位依次来看。

因为要最大，所以用来匹配的那个数在当前位上要尽量选和已知数不同的。

建立一颗 $0/1\ Trie$ 树，并将所有已知的 $dis$ 全部插入。

对于每一次查询，按照之前说的贪心的想法来向下检索。

对于每一个数，我们求出一个最大，最后再取一个 $\max$ 即可。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e5+5;
int n,u,v,d,head[MAXN],num_edge,dis[MAXN],Trie[MAXN*32][2],cnt,ans;
struct Edge{
	int next,to,dis;
	Edge(){}
	Edge(int next,int to,int dis):next(next),to(to),dis(dis){}
}edge[MAXN<<1];
il add_edge(int u,int v,int dis){
	edge[++num_edge]=Edge(head[u],v,dis),head[u]=num_edge;
	edge[++num_edge]=Edge(head[v],u,dis),head[v]=num_edge;
}
il DFS(int u,int fa){
	for(ri i=head[u];i;i=edge[i].next){
		if(edge[i].to==fa) continue;
		dis[edge[i].to]=dis[u]^edge[i].dis,DFS(edge[i].to,u);
	}
}
il build_tree(int val,int rt){
	for(ri i=(1<<30);i;i>>=1){
		ri c=(val&i?1:0);
		if(!Trie[rt][c]) Trie[rt][c]=++cnt;
		rt=Trie[rt][c];
	}
}
it query(int val,int rt){
	ri res=0;
	for(ri i=(1<<30);i;i>>=1){
		ri c=(val&i?1:0);
		if(Trie[rt][!c]) res+=i,rt=Trie[rt][!c];
		else rt=Trie[rt][c];
	}
	return res;
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n);
	for(ri i=1;i<n;++i) read(u),read(v),read(d),add_edge(u,v,d);
	DFS(1,0);
	for(ri i=1;i<=n;++i) build_tree(dis[i],0);
	for(ri i=1;i<=n;++i){
		ri tmp=query(dis[i],0);
		ans=ans>tmp?ans:tmp;
	}
	print(ans);
	return 0;
}
```

# 总结

对于树上路径的问题，可以拆成与 $LCA$ 有关的式子。

对于异或，可以将所有数转化为二进制，然后每一位依次求解。

---

## 作者：lemir3 (赞：1)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11174480.html#autoid-1-1-0)

[*题面*](https://www.luogu.org/problemnew/show/P4551)

这么多OJ都有这道题,说明这是一道经典题呼.

##题目分析

一棵带权树,求树上任意两点间最长的异或路径.

树上任意两点之间的距离,从$LCA$算法中我们可以得知可以这样求:

>$dis_{ij}$=$depth_i$+$depth_j$-$2$\*$depth_{LCA_{ij}}$

什么是异或呢,简单地说,两数相同则为0,不同则为1.

所以说有如下性质:

>$a$ $xor$ $a$=$0$

这条性质在这道题里尤其重要.

再联想到上面的树上两点距离公式,同志们可以得出树上两点间的异或值的求法,如下图:

![配图1.png](https://i.loli.net/2019/07/12/5d27e67b7397e79066.png)

红两个红色结点的LCA为蓝色结点,它们之间的异或值也就是黄色的路径上所有边权的异或值.

再结合上面的树上两点距离公式,我们现在需要做的是消去蓝色结点到根结点的异或值.

根据上面讲到的异或的性质,两个相等的数的异或值等于0,所以说把两个红色结点到根结点的异或值异或起来,就可以得到黄色路径上的异或值.如下图:

![配图2.png](https://i.loli.net/2019/07/12/5d27e8848809458766.png)

可以看到,根节点到蓝色结点的异或值被计算了两次,于是就被消为了$0$,对之后的异或运算没有影响.

所以说,这道题就转化成了求出树上任意一点到根结点的异或值,再求出任意两个异或值中的最大值.

为了方便计算,我们把边权拆成二进制的数.这样的话根据异或的运算法则,两个数不一样就为$1$,一样就为$0$,我们尽量选择不一样的数.为了满足最大值,我们从高位开始.

朴素的思想就是暴力枚举每个结点了.

再仔细想一想,发现这时候的本质无非就是要在一堆二进制数里找出与这个二进制数尽量每一位都不相等的数中最长的数.

我们把不同的位数视为两个数的前缀,然后就可以想到用Trie实现找前缀了.

同志们可以把每个结点到根结点的异或值存在Trie里,不足31位的用0补位.

因为高位的数一定比低位大,同志们每次都尽量选择与原串不同的高位,满足贪心策略.

##代码

```cpp

#include "cstdio"
#include "algorithm"
#include "cstring"
#include "iostream"

#define ll long long
#define debug(x) printf("debug:%lld\n",x)

using namespace std;

struct edge
{
    ll to,val,next;
}e[10000010];

ll n,g,tot=1,ans,size;
ll trie[1000010][2],TwoBit[33],head[1000010],xor_[1000010];
bool flag[10000010];

inline void EdgeAdd(ll,ll,ll);
inline void insert();
inline ll search();
inline void dfs(ll);

signed main(void)
{
    memset(head,-1,sizeof(head));
    scanf("%lld",&n);
    for(ll _=1;_<=n-1;_++)
    {
        ll a,b,v;
        scanf("%lld%lld%lld",&a,&b,&v);
        EdgeAdd(a,b,v);
        EdgeAdd(b,a,v);
    }
    dfs(1);
    for(ll _=1;_<=n;_++)
    {
        memset(TwoBit,0,sizeof(TwoBit));
        g=-1;
        ll v=xor_[_];
        while(v)//拆二进制
        {
            TwoBit[++g]=v&1;
            v>>=1;
        }
        insert();
    }
    for(ll _=1;_<=n;_++)
    {
        memset(TwoBit,0,sizeof(TwoBit));
        g=-1;
        ll v=xor_[_];
        while(v)//拆二进制
        {
            TwoBit[++g]=v&1;
            v>>=1;
        }
        ans=max(ans,search());
    }
    printf("%lld\n",ans);
return 0;
}

inline void EdgeAdd(ll from,ll to,ll val)
{
    e[++size].to=to;
    e[size].val=val;
    e[size].next=head[from];
    head[from]=size;
}

inline void dfs(ll from)//用dfs求出到根结点的异或值
{
    flag[from]=true;
    for(ll _=head[from];_!=-1;_=e[_].next)
    {
        ll to=e[_].to;
        ll val=e[_].val;
        if(flag[to]==true)//不能往回走啊
        {
            continue;
        }
        else
        {
            xor_[to]=xor_[from]^val;//累加异或值
            dfs(to);
        }
    }
}

inline void insert()
{
    ll p=1;
    for(ll _=31;_>=0;_--)//从高位开始存
    {
        ll num=TwoBit[_];
        if(trie[p][num]==0)
        {
            trie[p][num]=++tot;
        }
        p=trie[p][num];
    }
}

inline ll search()
{
    ll p=1,cnt=0;
    for(ll _=31;_>=0;_--)//从高位开始扫
    {
        ll num=TwoBit[_];
        if(trie[p][1-num]!=0)//尽量选择与高位不同的
        {
            cnt+=(1<<_);
            p=trie[p][1-num];
        }
        else
        {
            p=trie[p][num];
        }
    }
return cnt;
}

```


---

## 作者：ZJsheep (赞：1)

# Explanation
首先应该想到用Trie解决两个数xor最大值的模板（可见[CH1602](<http://contest-hunter.org:83/contest/0x10%E3%80%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8D%E4%BE%8B%E9%A2%98/1602%20The%20XOR%20Largest%20Pair>)）。具体来说，建一棵字典树，这棵字典树每个节点仅有两个分支0和1，然后把每一个数字的二进制形式从高位到低位插入Trie。若要查询最大值，就在Trie上沿尽量当前位的反方向行走。若能够这样走，则ans该位为1，否则为0。

在这道题中，我们先用一遍dfs处理出每个节点到根节点路径上所有边权的xor和（设为sum[]）。每两个节点（假设为x和y）之间的xor和即为sum[x] xor sum[y]，因为重复路径上的权值自己xor自己，结果为0（a xor a = 0），对结果没有影响。

如要查阅更多资料~~（或想双倍经验）~~可以查阅POJ3764。在POJ双倍经验的时候要记得：1.众所周知，头文件（滑稽）；2.默认根节点为0；3.有多组数据。

# Code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAX_N = 100000 + 10;
int Head[MAX_N], Next[MAX_N << 1], V[MAX_N << 1], W[MAX_N << 1], tot;
int T[MAX_N * 30][2], cnt;
int sum[MAX_N], n, ans;

void Add(int u, int v, int w) {
	V[++tot] = v; W[tot] = w;
	Next[tot] = Head[u]; Head[u] = tot;
}

void dfs(int u, int fa) {
	for (int i = Head[u]; i; i = Next[i]) {
		int v = V[i], w = W[i];
		if (v == fa) continue;
		sum[v] = sum[u] ^ w;
		dfs(v, u);
	}
}

void Insert(int str) {
	int cur = 0;
	for (int i = 31; i >= 0; i--) {
		int ch = (str >> i) & 1;
		if (!T[cur][ch]) T[cur][ch] = ++cnt;
		cur = T[cur][ch];
	}
}

int Query(int str) {
	int cur = 0, ret = 0;
	for (int i = 31; i >= 0; i--) {
		int ch = (str >> i) & 1;
		ret <<= 1;
		if (T[cur][ch ^ 1]) ret |= 1, cur = T[cur][ch ^ 1];
		else cur = T[cur][ch];
	}
	return ret;
}

int main() {
	int u, v, w;
	scanf("%d", &n);
	memset(Head, 0, sizeof Head); tot = 0;
	memset(T, 0, sizeof T); cnt = 0;
	memset(sum, 0, sizeof sum); ans = 0;
	for (int i = 1; i < n; i++) {
		scanf("%d%d%d", &u, &v, &w);
		Add(u, v, w); Add(v, u, w);
	}
	dfs(1, -1);
	for (int i = 1; i <= n; i++) {
		ans = max(ans, Query(sum[i]));
		Insert(sum[i]);
	}
	printf("%d\n", ans);
	return 0;
} 
```

# Reference
[POJ3764](http://poj.org/problem?id=3764)

《算法竞赛进阶指南》p.76

---

## 作者：maomao9173 (赞：1)

#### [题目链接 $Click$  $Here$](https://www.luogu.org/problemnew/show/P4551)

$01Trie$好题~~裸题~~。

取节点$1$为根节点，向下扫每一个点从根节点到它路径上的异或和，我们可以得到一个$sumx[u]$。

现在路径异或和有两类：

- 跨过根节点，这种的异或路径长度等于两个子节点的$sumx$异或和异或起来的数值大小
- 在一棵子树中，这种的异或路径等于$sumx[u]$异或上$sumx[v]$再异或掉两次$sumx[1->lca (u, v)]$（因为被额外计算），依然等于两个子节点的$sumx$异或和异或起来的数值大小。

所以问题转为求在$sumx$中，对每个$sumx[u]$，和它产生最大异或和的$sumx[v]$最大可以异或出来多少。我们把数列每个值插入$01Trie$中，求解时尽可能选择对应位不同的数。复杂度$O(N*31)$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;

int cnt, head[N];

struct edge {
	int nxt, to, w;
}e[N << 1];

void add_edge (int from, int to, int val) {
	e[++cnt].nxt = head[from];
	e[cnt].to = to;
	e[cnt].w = val;
	head[from] = cnt;
}

void add_len (int u, int v, int w) {
	add_edge (u, v, w);
	add_edge (v, u, w);
}

int n, u, v, w, sumx[N];

void get_sumx (int u, int fa) {
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (v != fa) {
			sumx[v] = sumx[u] ^ e[i].w;
			get_sumx (v, u);
		}
	}
}


int ch[N * 31][2], max_size;

void insert (int val) {
	int now = 0;
	for (int i = 30, to = 0; i >= 0; --i) {
		to = ((val & (1 << i)) != 0); //如果 val 第 i 位上为 1
		if (!ch[now][to]) {
			ch[now][to] = ++max_size;
		}
		now = ch[now][to];
	}
}

int get_ans (int val) {
	int now = 0, ans = val;
	for (int i = 30; i >= 0; --i) {
		if (ans & (1 << i)) {
			//这一位为1 -> 向0走
			if (ch[now][0] != 0) {
				now = ch[now][0];
			} else {
				val ^= (1 << i);
				now = ch[now][1];
			}
		} else {
			//为0 -> 向1走
			if (ch[now][1] != 0) {
				val ^= (1 << i);
				now = ch[now][1];
			} else {
				now = ch[now][0];
			}
		}
	}
	return max (val, ans);
}

int main () {
	cin >> n;
	for (int i = 1; i <= n - 1; ++i) {
		cin >> u >> v >> w;
		add_len (u, v, w);
	}
	get_sumx (1, 0);
	for (int i = 1; i <= n; ++i) {
		insert (sumx[i]);
	}
	int ans = 0;
	for (int i = 1; i <= n; ++i) {
		ans = max (ans, get_ans (sumx[i])); //求sumx与其他数的最大异或
	}
	cout << ans << endl;
}

```



---

## 作者：VenusM1nT (赞：0)

$\texttt{0-1 trie}$。

大概是 $\texttt{0-1 trie}$ 的模板题？

做法非常简单，先预处理前缀 $\texttt{xor}$ 和，把它们按位丢到一颗 $\texttt{trie}$ 上，然后查询的时候用贪心的思想，当前 $0$ 就走 $1$，$1$ 就走 $0$，以每个点为起点跑一遍，然后取最大的那个即可。

```cpp
#include<bits/stdc++.h>
#define MAXN 2000005
#define K 30
#define reg register
#define inl inline
using namespace std;
int cnt,fst[MAXN],nxt[MAXN<<1],to[MAXN<<1],w[MAXN<<1];
int n,a[MAXN],ch[MAXN][2],tot,ans;
inl void AddEdge(reg int u,reg int v,reg int c)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
}
inl void Dfs(reg int u,reg int faz)
{
	for(reg int i=fst[u];i;i=nxt[i])
	{
		reg int v=to[i];
		if(v==faz) continue;
		a[v]=a[u]^w[i];
		Dfs(v,u);
	}
}
inl void Modify(reg int rt,reg int val)
{
	for(reg int i=K;i>=0;i--)
	{
		reg bool u=val&(1<<i);
		if(!ch[rt][u]) ch[rt][u]=++tot;
		rt=ch[rt][u];
	}
}
inl int Query(reg int rt,reg int val)
{
	reg int res=0;
	for(reg int i=K;i>=0;i--)
	{
		reg bool u=!(val&(1<<i));
		if(ch[rt][u])
		{
			res+=1<<i;
			rt=ch[rt][u];
		}
		else rt=ch[rt][!u];
	}
	return res;
}
int main()
{
	scanf("%d",&n);
	for(reg int i=1;i<n;i++)
	{
		reg int x,y,z;
		scanf("%d %d %d",&x,&y,&z);
		AddEdge(x,y,z);
		AddEdge(y,x,z);
	}
	Dfs(1,0);
	for(reg int i=1;i<=n;i++) Modify(0,a[i]);
	for(reg int i=1;i<=n;i++) ans=max(ans,Query(0,a[i]));
	printf("%d\n",ans);
	return 0;
}
```

---


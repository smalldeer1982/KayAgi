# [POI 2000] 公共串

## 题目描述

给出几个由小写字母构成的单词，求它们最长的公共子串的长度。


## 样例 #1

### 输入

```
3
abcb
bca
acbc```

### 输出

```
2```

# 题解

## 作者：General0826 (赞：30)

## 题解 P5546 【[POI2000]公共串】

~~我在知道这个题之前出了一道这 [Gen_UNO](https://www.luogu.com.cn/problem/U494208)~~  ，我还是只井底之蛙罢了。

### KMP 做法

我们考虑暴力的做法，因为公共串肯定是一个串的子串 ~~（和废话一样）~~，去截取一个串的子串。对与每个串跑 KMP。时间 $O(nm^3)$，非常爆炸（$m$ 是字符长度）。

你考虑一件这样的事：

我们直接跑 KMP 看匹不匹配，是一个 `bool`，要这样搞  hash 也能替代。KMP 有一个中途前缀匹配度，前缀匹配度？哦！那我们将本来的子串换成一个串的后缀。因为单调性，$[l,r]$ 可以，肯定 $[l,r-1]$ 可以。这样就一次将所有 $l$ 相等的就统计了，将这个前缀匹配度取 $\max$。

但这只是一个串是，因为是公共的对于每个串，这个再对这取 $\min$ 。因为这个值只是一个后缀的贡献。所以又要将这个值再取 $\max$，时间 $O(nm^2)$，很蓟县。   　

这过程就如 [Gen_UNO](https://www.luogu.com.cn/problem/U494208) 中的所说：

> 他**至少**需要多少张牌才可以被任何人决斗的情况中得到**最少**的冰红茶**最多**
      
以下是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
int n,ans=0;
string a[N],cp;
int nxt[N];
void inti(string s){
	nxt[0]=-1;
	for(int i=0,j=-1;i<s.size();){
		if(s[i]==s[j]||j==-1)
			nxt[++i]=++j;
		else
			j=nxt[j];
	}
}
int KMP(string a,string b){
	int ans=-1;
	for(int i=0,j=0;i<a.size();){
		if(a[i]==b[j]&&j==b.size()-1){
			return b.size();
		}
		else if(a[i]==b[j]||j==-1){
			ans=max(ans,j);
			i++;j++;
		}
		else
			j=nxt[j];
	}
	return ans+1;
}
int cheke(string b){
	int ans=1e9;
	inti(b);
	for(int i=1;i<=n;i++)
		ans=min(KMP(a[i],b),ans);
	return ans;
}
int main() {
  	cin>>n;
  	for(int i=1;i<=n;i++){
  		cin>>a[i]; 
	}
	for(int i=0;i<a[1].size();i++){
		string cp="";
		for(int j=i;j<a[1].size();j++)
			cp+=a[1][j];
		ans=max(cheke(cp),ans);
	}
	cout<<ans;
  	return 0;
}
```

---

## 作者：HenryHuang (赞：18)

# 「POI2000」公共串

题目大意：给定 $n(n \le 5)$ 个字符串，求最长公共子串长度。

这里提供一种使用 SA 的做法。

首先将给定的所有字符串连在一起串成一个字符串，字符串之间用题目限定字符集之外的字符分隔开，我们称这个字符串为 $s$，设其长度为 $n$。

我们求出其 $\texttt{height}$ 数组，那么问题实际上转化为：在 $\texttt{height}$ 数组上找连续的一段，使得这一段包含来自给定的每个字符串的至少一个后缀，设这样的第 $i$ 个区间为 $[l_i,r_i]$ ，则最后的答案为 $\min_{l_i< x \le r_i}{\texttt{height}_i}$。

首先不考虑计算答案，只考虑计算区间的话，这是一个非常经典的问题，直接使用 $\texttt{two-pointer}$ 即可以在 $O(n)$ 的时间复杂度内求出所有这样的区间。具体做法就用一个数组表示来自第 $i$ 个字符串的后缀出现了几次，动态更新即可。

接下来考虑计算答案，这同样是一个经典问题，类比「滑动窗口」，我们可以维护一个单调队列，随着 $\texttt{two-pointer}$ 过程中区间的扩张与收缩对单调队列进行更新即可。时间复杂度为 $O(n)$。

这种做法相比二分复杂度更优，代码复杂度也较小。

综上，总时间复杂度为 $O(nlog_2n)$。瓶颈在于构造后缀数组，如果使用线性构造方法可以做到 $O(n)$。

以下是代码：

```cpp
/*---Author:HenryHuang---*/
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e4+5;
char s[maxn];
int sa[maxn],rk[maxn],tp[maxn],cnt[maxn];
int n,m,N;
int height[maxn],h[maxn];
int vis[maxn],col[maxn],ok;
inline void sort(){
	memset(cnt,0,sizeof (int)*(m+1));
	for(int i=1;i<=n;++i) ++cnt[rk[i]];
	for(int i=1;i<=m;++i) cnt[i]+=cnt[i-1];
	for(int i=n;i>=1;--i) sa[cnt[rk[tp[i]]]--]=tp[i];
}
int L[10],R[10];
void add(int x){
	if(col[x]==0) return ;
	++vis[col[x]];
	if(vis[col[x]]==1) ++ok;
}
void del(int x){
	if(col[x]==0) return ;
	--vis[col[x]];
	if(!vis[col[x]]) --ok;
}
int main(){
	cin>>N;
	for(int i=1;i<=N;++i){
		L[i]=n+1;
		scanf("%s",s+n+1);
		n+=strlen(s+n+1);
		R[i]=n;
		s[++n]=i+'0';
	}
	m='z';
	for(int i=1;i<=n;++i) rk[i]=s[i]-'0'+1,tp[i]=i;
	sort();
	for(int w=1,p=0;p<n;m=p,w<<=1){
		p=0;
		for(int i=n;i>n-w;--i) tp[++p]=i;
		for(int i=1;i<=n;++i) if(sa[i]>w) tp[++p]=sa[i]-w;
		sort();swap(tp,rk);
		rk[sa[1]]=p=1;
		for(int i=2;i<=n;++i)
			rk[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w])?p:++p;
	}
	for(int i=1;i<=n;++i) rk[sa[i]]=i;
	int k=0;
	for(int i=1;i<=n;++i){
		if(rk[i]==1) continue;
		if(k) --k;
		int j=sa[rk[i]-1];
		while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) ++k;
		height[rk[i]]=k;
	}//求height 
	for(int i=1;i<=N;++i){
		for(int j=L[i];j<=R[i];++j)
			col[rk[j]]=i;
		;
	}
	deque<int>q;
	int l=1,ans=0;
	add(1);
	for(int r=2;r<=n;++r){
		while(!q.empty()&&height[q.back()]>=height[r]) q.pop_back();
		q.emplace_back(r);
		add(r);
		if(ok==N){
			while(ok==N&&l<r) del(l),++l;
			--l,add(l);
		}
		while(!q.empty()&&q.front()<=l) q.pop_front();//注意这里是等于，区间内第一个位置的height大小我们不关心 
		if(ok==N) ans=max(ans,height[q.front()]);
	}//求解答案 
	cout<<ans<<'\n';
	return 0;
}
```





 

---

## 作者：米奇奇米 (赞：13)

## 题解-P5546 [POI2000]公共串

### 题目意思

就是给你$\leq 5$个字符串$(|s|\leq 2000)$，求最长匹配的公共子串长度。

### $Solution$

* **二分+hash**

其实这种算法是很暴力的，每次二分一个长度，然后依次去各字符串里面去匹配，如果每个串都能匹配上就二分下去就可以。然后用一个$map$去记录这段字符串的哈希值是否出现过即可。对于一段字符串的哈希值的计算方法$hash[r]-hash[l-1]*jc[r-l+1]$

这样你就拿到了$100ptc$的好成绩啊！

* 正解显然是后缀自动机，然而我不会。

### $Code$
```cpp
#include <bits/stdc++.h>

#define hash ha
#define ull unsigned long long 
using namespace std;

const int base=173;

struct IO {
	#define gc getchar
	#define pt putchar

	inline int read() {
		int sum=0,ff=1; char ch=gc();
		while(!isdigit(ch)) {
			if(ch=='-') ff=-1;
			ch=gc();
		}
		while(isdigit(ch))
			sum=sum*10+(ch^48),ch=gc();
		return sum*ff;
	}

	inline void write(int x) {
	    if(x<0)
			pt('-'),x=-x;
	    if(x>9)
			write(x/10);
	    pt(x%10+48);
	}

	inline void writeln(int x) {
		write(x);
		pt('\n');
	}
} fast;

int n,ans,len,id;
char ch[11][2005];
ull jc[2005],hash[11][2005];
int sum[11][2005];
map<int,ull> ma[11];

inline void init() {
	jc[0]=1;
	for ( int i=1;i<=2000;i++ ) jc[i]=jc[i-1]*base;
	for ( int i=1;i<=n;i++ ) 
		for ( int j=1;j<=strlen(ch[i]+1);j++ ) 
			hash[i][j]=hash[i][j-1]*base+sum[i][j];
}

inline ull get(int now,int l,int r) {
	return hash[now][r]-hash[now][l-1]*jc[r-l+1];
}

inline bool check(int mid) {
	for ( int i=1;i<=n;i++ ) 
		ma[i].clear();
	for ( int i=1;i<n;i++ ) {
		for ( int j=1;j+mid-1<=strlen(ch[i]+1);j++ ) {
			ull tmp=get(i,j,j+mid-1);
//			cout<<tmp<<endl;
			ma[i][tmp]=1;
		}
	}
//	cout<<strlen(ch[n]+1)<<endl;
	for ( int i=1;i+mid-1<=strlen(ch[n]+1);i++ ) {
		ull tmp=get(n,i,i+mid-1);
		bool ok=false;
		for ( int j=1;j<n;j++ ) 
			if(!ma[j][tmp]) ok=true;
		if(ok==false) return true;
	}
	return false;
}

	
int main() {
	scanf("%d",&n);
	for ( int i=1;i<=n;i++ ) {
		scanf("%s",ch[i]+1);
		for ( int j=1;j<=strlen(ch[i]+1);j++ ) 
			sum[i][j]=ch[i][j]-'a'+1;
		if(strlen(ch[i]+1)>len) {
			len=strlen(ch[i]+1);
			id=i;
		}
	}
	init();
//	cout<<get(1,1,3)<<endl;
//	for ( int i=1;i<=n;i++ ) {
//		for ( int j=1;j<=strlen(ch[i]+1);j++ ) 
//			cout<<hash[i][j]<<" ";
//		printf("\n");
//	}
	int l=1,r=strlen(ch[id]+1);
	while(l<=r) {
		int mid=(l+r)>>1;
		if(check(mid)) {
			ans=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	fast.writeln(ans);
	return 0;
}
		
			
	
```


---

## 作者：江之永矣 (赞：10)

题意就是给定不超过5个字符串，求最长公共子串
总长度不超过1w

首先把所有字符串拼在一起，中间分别用不同的字符隔开
然后求出$height$



二分答案为k
找到每一连续且均不小于k的段
只要在段里有来自不同串的后缀就行了
用前缀和维护

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn = 10000 + 10;
int n, m;
char s[maxn]; 
int sa[maxn], rank[maxn], height[maxn];
int tax[maxn], tp[maxn];
inline void tsort(){
	for(int i = 1; i <= m; i++) tax[i] = 0;
	for(int i = 1; i <= n; i++) tax[rank[i]]++;
	for(int i = 2; i <= m; i++) tax[i] += tax[i - 1];
	for(int i = n; i; i--) sa[tax[rank[tp[i]]]--] = tp[i];
}
inline bool cmp(int *arr, int l, int r, int k){
	return arr[l] == arr[r] && arr[l + k] == arr[r + k];
}
void suffix_sort(){
	m = 128;
	for(int i = 1; i <= n; i++) tp[i] = i;
	for(int i = 1; i <= n; i++) rank[i] = s[i];
	tsort();
	for(int k = 1, p = 0; p < n; k <<= 1, m = p){
		p = k;
		for(int i = 1; i <= k; i++) tp[i] = n - k + i;
		for(int i = 1; i <= n; i++) if(sa[i] > k) tp[++p] = sa[i] - k;
		tsort();
		swap(rank, tp);
		p = rank[sa[1]] = 1;
		for(int i = 2; i <= n; i++)
			rank[sa[i]] = cmp(tp, sa[i - 1], sa[i], k) ? p : ++p;
	}
	for(int i = 1, j, k = 0; i <= n; height[rank[i++]] = k)
		for(k ? k-- : 0, j = sa[rank[i] - 1]; s[j + k] == s[i + k]; k++);
}
int L[10], R[10], sum[10][maxn] = {0};
char temp[] = {'!', '@', '#', '$', 0};
int q[maxn], qcnt;
int main(){
	int N;
	scanf("%d", &N);
	n = 0;
	for(int i = 0; i < N; i++){
		L[i] = n + 1;
		scanf("%s", s + 1 + n);
		n += strlen(s + 1 + n);
		R[i] = n;
		s[++n] = temp[i];
	}
	s[n--] = 0;
	suffix_sort();
	for(int i = 0; i < N; i++){
		for(int j = L[i]; j <= R[i]; j++)
			sum[i][rank[j]]++;
		for(int j = 1; j <= n; j++)
			sum[i][j] += sum[i][j - 1];
	}
	int l = 1, r = maxn, mid, ans = 0;
	for(int i = 0; i < N; i++) r = min(r, R[i] - L[i] + 1);
	bool flag;
	while(l <= r){
		mid = l + r >> 1;
		qcnt = 0;
		for(int i = 1; i <= n; i++){
			if(height[i] < mid) q[++qcnt] = i;
		}
		for(int i = 2; i <= qcnt; i++){
			flag = true;
			for(int j = 0; j < N; j++) flag &= sum[j][q[i] - 1] - sum[j][q[i - 1] - 1] > 0;
			if(flag) break;
		}
		if(flag){
			ans = mid;
			l = mid + 1;
		}
		else r = mid - 1;
	}
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：JK_LOVER (赞：9)

## 题意
给出几个字符串，求它们最长的公共子串的长度。[$QAQ$](https://www.luogu.com.cn/blog/xzc/solution-p5546)
## 分析
### 写在前面的
大多数题解都是 $\text{SA}$ ，只有一篇是 $\text{SAM}$ ，而且 $\text{SAM}$ 的做法只对一个串建了的。

- 这里提供一种广义后缀自动机的做法。好像对于多个字符串建字典树，然后再建自动机才是科学的做法，没学过。

- 提供一种简单做法

- 每当完全插入一个字符串之后，将 $\text{last}$ 变成 $0$ 或者 $1$ 。有些人或许习惯插入一个特殊字符如 $\text{\#}$ 之类的。

- 现在就可以在自动机上找到 $\text{endpos}$ 有所有插入字符的等价类，最长的 $\text{len}$ 。

时间复杂度为 $O(n)$ ，轻松跑到第一页，写法也比较简单。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int si,last;
const int MAXLEN = 2e5+100;
struct Node{
	int link,si[5],len;
	int nxt[26];
}st[MAXLEN<<1];
void init(){
	st[0].len = 0;st[0].link = -1;last = 0;si++;
}
void insert(int c,int op){
	int cur = si++;st[cur].len = st[last].len + 1;
	st[cur].si[op] = 1;
	int p = last;
	while(p != -1 && !st[p].nxt[c]){
		st[p].nxt[c] = cur;
		p = st[p].link;
	}
	if(p == -1) st[cur].link = 0;
	else {
		int q = st[p].nxt[c];
		if(st[q].len == st[p].len + 1) st[cur].link = q;
		else {
			int cl = si++;
			st[cl].len = st[p].len + 1;
			st[cl].link = st[q].link;
			for(int i = 0;i < 26;i++) st[cl].nxt[i] = st[q].nxt[i];
			while(p != -1 && st[p].nxt[c] == q)
			{
				st[p].nxt[c] = cl;p = st[p].link;	
			}
			st[q].link = st[cur].link = cl;
		}
	}
	last = cur;
}
const int N = 2e6+100;
int nxt[N<<2],to[N<<2],head[N<<1],Cnt = 0;
void build(){
	for(int i = 1;i < si;i++){
		int x = st[i].link,y = i;
		to[++Cnt] = y;nxt[Cnt] = head[x];head[x] = Cnt;
	}
}
int n;
void dfs(int x){
	for(int i = head[x];i;i = nxt[i]){
		int y = to[i];
		dfs(y);
		for(int j = 0;j < n;j++){
			st[x].si[j] += st[y].si[j];
		}
	}
}

char ch[N];
int main()
{
	init();
	 cin>>n;
	for(int i = 1;i <= n;i++){
		cin >> ch;
		int L = strlen(ch);
		for(int j = 0;j < L;j++){
			insert(ch[j]-'a',i-1);
		}
		last = 0;
	}
	build();
	dfs(0);
	int ans = 0;
	for(int i = 0;i < si;i++){
		for(int j = 0;j < n;j++){
			if(st[i].si[j] == 0) break;
			if(j == n-1) {
				ans = max(ans,st[i].len);
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：Strelitzia (赞：3)

[题目床送门](https://www.luogu.com.cn/problem/P5546)

---

阿巴阿巴，为什么一道打 $\texttt{Trie}$ 树的题，全部题解都是 $\texttt{hash}$ 过的啊。

这里给出一种 $\texttt{Trie}$ 树的方法。

如果是公共子串，她一定会出现在第一个串，所以为了节约空间，只对第一个串建树就行了。

然后对于其他串每个子串，对于原树打到过的标签，查满足条件的最大值就行了。

ps:为什么题解全是 $\texttt{hash}$ 啊，$\texttt{Trie}$ 树明显简单一点。 

```cpp
#include <map>
#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;

//Two kinds of QuickRead and QuickPrint

//char buf[1 << 23],*p1 = buf,*p2 = buf,obuf[1 << 23],*O = obuf;
//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++)
template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	x *= f;
}
int read() {
	int x = 0, f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	return x *= f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<typename T>void Swap(T &x,T &y) {T z = x;x = y;y = z;}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}
template<typename T>T Abs(T x) {return x < 0 ? -x : x;}

const int N = 10000005;
const int K = 10000005;

int nxt[N],ver[N],head[N],tot;
void addEdge(int u,int v) {nxt[++ tot] = head[u];ver[tot] = v;head[u] = tot;}

int n,cmp;
int cnt,ans;
int t[K],dep[K],lin[K];
char s[2005];

void insert(int be,int len,int id) {
	int root = 0;
	for (int i = be ; i <= len ; ++ i) {
		int flag = 0;
		for (int e = head[root] ; e ; e = nxt[e]) {
			if (t[ver[e]] == s[i] - 'a') {
				flag = ver[e];
				break;
			}
		}
		if (!flag) t[++ cnt] = s[i] - 'a',addEdge(root,cnt),flag = cnt;
		dep[flag] = dep[root] + 1;
		root = flag;
		lin[root] |= 1 << id;
		if (lin[root] == cmp) ans = Max(ans,dep[root]);
	}
}

void update(int be,int len,int id) {
	int root = 0;
	for (int i = be ; i <= len ; ++ i) {
		int flag = 0;
		for (int e = head[root] ; e ; e = nxt[e]) {
			if (t[ver[e]] == s[i] - 'a') {
				flag = ver[e];
				break;
			}
		}
		if (!flag) return;
		root = flag;
		lin[root] |= 1 << id;
		if (lin[root] == cmp) ans = Max(ans,dep[root]);
	}
}

int main () {
	read(n);
	scanf("%s",s + 1);
	int len = strlen(s + 1);
	for (int i = 1 ; i <= n ; ++ i) cmp |= 1 << i;
	for (int i = 1 ; i <= len ; ++ i)
		insert(i,len,1);
	for (int i = 2 ; i <= n ; ++ i) {
		scanf("%s",s + 1);
		len = strlen(s + 1);
		for (int j = 1 ; j <= len ; ++ j)
			update(j,len,i);
	}
	print(ans);
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：2)

提供一个$sam$的

因为所有串的最长公共子串长度肯定不会超过最短的那个串，所以可以拿最短的那个串建机，然后把其他串放到上面匹配

每个点记一个匹配过的最小值mn，最终输出所有点mn的最大值
```cpp
#include<cstdio>
#include<cstring>
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();bool f=0;
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
template<class type>inline const void write(type out)
{
	if (out>9)write(out/10);
	putchar(out%10+48);
}
template<class type>inline const void writeln(type out)
{
	if (out<0)putchar('-'),out=-out;
	write(out);
	putchar('\n');
}
template<class type>inline const type min(const type &a,const type &b)
{
	return a<b?a:b;
}
template<class type>inline const type max(const type &a,const type &b)
{
	return a>b?a:b;
}
const int N=5,L=2e3+10;
int n,len[N];
char s[N][L];
template<int maxn,int maxc>class Suffix_Automaton
{
	private:
		static const int maxs=maxn<<1;
		int last,cnt,sum[maxn],rnk[maxs],len[maxs],son[maxs][maxc],fa[maxs],mx[maxs],mn[maxs];
		inline const void extend(int c)
		{
			int p=last,np=++cnt;
			mn[np]=len[last=np]=len[p]+1;
			for (;p&&!son[p][c];p=fa[p])son[p][c]=np;
			if (!p)return fa[np]=1,void();
			int q=son[p][c];
			if (len[q]==len[p]+1)return fa[np]=q,void();
			int nq=++cnt;mn[nq]=len[nq]=len[p]+1;
			memcpy(son[nq],son[q],sizeof(son[q]));
			fa[nq]=fa[q];fa[q]=fa[np]=nq;
			for (;son[p][c]==q;p=fa[p])son[p][c]=nq;
		}
		inline const void radixsort()
		{
			for (int i=1;i<=cnt;i++)sum[len[i]]++;
			for (int i=1;i<=cnt;i++)sum[i]+=sum[i-1];
			for (int i=1;i<=cnt;i++)rnk[sum[len[i]]--]=i;
		}
	public:
		inline const void build(int n,char *s)
		{
			last=cnt=1;
			for (int i=1;i<=n;i++)extend(s[i]-'a');
			radixsort();
		}
		inline const void match(int n,char *s)
		{
			int p=1,lcs=0;
			for (int i=1;i<=n;i++)
			{
				int c=s[i]-'a';
				if (son[p][c]){p=son[p][c];mx[p]=max(mx[p],++lcs);continue;}
				while (p&&!son[p][c])p=fa[p];
				if (p)lcs=len[p]+1,p=son[p][c],mx[p]=max(mx[p],lcs);
				else p=1,lcs=0;
			}
			for (int i=cnt;i;i--)
			{
				int p=rnk[i];
				mn[p]=min(mn[p],mx[p]);
				if (fa[p])mx[fa[p]]=max(mx[fa[p]],mx[p]);
				mx[p]=0;
			}
		}
		inline const int query()
		{
			int lcs=0;
			for (int i=1;i<=cnt;i++)lcs=max(lcs,mn[i]);
			return lcs;
		}
};
Suffix_Automaton<L,26>sam;
int main()
{
	read(n);
	for (int i=0;i<n;i++)scanf("%s",s[i]+1),len[i]=strlen(s[i]+1);
	int mn=0;
	for (int i=1;i<n;i++)if (len[i]<len[mn])mn=i;
	sam.build(len[mn],s[mn]);
	for (int i=0;i<n;i++)if (mn^i)sam.match(len[i],s[i]);
	writeln(sam.query());
	return 0;
}
```

---

## 作者：唐一文 (赞：1)

~~刚刚写了[这题](https://www.luogu.com.cn/problem/SP10570)，发现有双倍经验，就来把这题也水了~~

## Description

求 $n$ 个字符串的最长公共子串的长度

## Solution

首先可以二分最长的长度

然后开 $n-1$ 个桶，把 $2$ 到 $n$ 的每个字符串长度为 $mid$ 的子串的哈希值丢进去

然后再枚举第一个字符串的子串，在每个桶里面寻找有没有这个子串的哈希值

如果每个桶都有，那么这个子串就可以

这个桶可以用 map 或 unordered_map 或 set 或 multiset 实现，我这里用的是 unordered_map

## Code
```cpp
#include<bits/stdc++.h>
#define re register
#define ll long long
#define ull unsigned ll
using namespace std;
#define MAXN 10005
char s[15][MAXN];
int T,m,n[15],l,r,ans;
ull hs[15][MAXN],mul[MAXN]={1};
int main(){
  for(re int i=1;i<MAXN;++i)mul[i]=mul[i-1]*131;
  scanf("%d",&m),l=1,ans=0,r=MAXN;
  for(re int i=0;i<m;++i)scanf("%s",s[i]+1),r=min(r,n[i]=strlen(s[i]+1));
  for(re int i=0;i<m;++i)
    for(re int j=1;j<=n[i];++j)
      hs[i][j]=hs[i][j-1]*131+s[i][j];
  for(re int mid;l<=r;){
    mid=l+r>>1;
    bool fl;
    unordered_map<ull,bool>vis[15];
    const ull Mul=mul[mid];
    for(re int k=1;k<m;++k)
      for(re int i=mid;i<=n[k];++i)
        vis[k][hs[k][i]-hs[k][i-mid]*Mul]=true;
    for(re int i=mid;i<=n[0];++i){
      fl=true;
      for(re int k=1;k<m;++k)
        if(!vis[k][hs[0][i]-hs[0][i-mid]*Mul]){
          fl=false;
          break;
        }
      if(fl)break;
    }
    fl?l=(ans=mid)+1:r=mid-1;
  }
  printf("%d",ans);
}
```

---

## 作者：k2saki (赞：0)

考虑长度很小，可以用后缀数组来做。

考虑把所有串拼接在一起，然后 2 个串的交接处用其他不一样的的字符隔开，建完 SA 后再 build_height 。然后就需要在 height 数组上找包含所有串的后缀的一段，然后答案就是 $min_{i\in(l,r]}h[i]$ 

找区间显然可以用双指针扫一遍快速得出，然后计算 min 可以用单调队列来优化复杂度，把两者结合在一起，双指针变化的时候顺便更新单调队列的答案，就可以过这道题了。

时间复杂度 $O(\sum{|S|log\sum|S|})$，由于笔者不会 SA-IS ，理论复杂度可以达到 $O(\sum|S|)$ 的。

```
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2e4 + 12;
char s[1010101];
int read()
{
    int s = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        s = s * 10 + ch - '0';
        ch = getchar();
    }
    return s * f;
}
int T, nw, head, tail, q[maxn * 100], l = 1, n, m, ans = 0, L[10], R[10], b[maxn], sa[maxn], x[maxn], y[maxn], h[maxn], rk[maxn], col[maxn], cnt[maxn];
void build_SA()
{
    int num;
    for (register int i = 1; i <= n; ++i)
        b[x[i] = s[i]]++;
    for (register int i = 1; i <= m; ++i)
        b[i] += b[i - 1];
    for (register int i = n; i >= 1; --i)
        sa[b[x[i]]--] = i;
    for (register int k = 1; k <= n; k <<= 1)
    {
        num = 0;
        for (register int i = n; i > n - k; --i)
            y[++num] = i;
        for (register int i = 1; i <= n; ++i)
            if (sa[i] > k)
                y[++num] = sa[i] - k;

        for (register int i = 0; i <= m; ++i)
            b[i] = 0;
        for (register int i = 1; i <= n; ++i)
            b[x[y[i]]]++;
        for (register int i = 0; i <= m; ++i)
            b[i] += b[i - 1];
        for (register int i = n; i >= 1; --i)
            sa[b[x[y[i]]]--] = y[i];

        for (register int i = 1; i <= n; ++i)
            y[i] = 0;
        for (register int i = 1; i <= n; ++i)
            swap(x[i], y[i]);
        num = 1;
        x[sa[1]] = 1;
        for (register int i = 2; i <= n; ++i)
            x[sa[i]] = (y[sa[i]] != y[sa[i - 1]] || y[sa[i] + k] != y[sa[i - 1] + k]) ? ++num : num;
        if (num == n)
            return;
        m = num;
    }
}
void build_height()
{
    int k = 0;
    for (register int i = 1; i <= n; ++i)
        rk[sa[i]] = i;
    for (register int i = 1; i <= n; ++i)
    {
        if (rk[i] == 1)
            continue;
        if (k)
            --k;
        int j = sa[rk[i] - 1];
        while (j + k <= n && i + k <= n && s[i + k] == s[j + k])
            ++k;
        h[rk[i]] = k;
    }
}
void build_color()
{
    for (int i = 1; i <= T; ++i)
    {
        for (int j = L[i]; j <= R[i]; ++j)
        {
            col[rk[j]] = i;
        }
    }
}
void add(int x)
{
    if (col[x] == 0)
        return;
    ++cnt[col[x]];
    if (cnt[col[x]] == 1)
        ++nw;
}
void del(int x)
{
    if (col[x] == 0)
        return;
    --cnt[col[x]];
    if (cnt[col[x]] == 0)
        --nw;
}
int main()
{
    T = read();
    n = 0;
    for (register int i = 1; i <= T; ++i)
    {
        L[i] = n + 1;
        scanf("%s", s + n + 1);
        n += strlen(s + n + 1);
        R[i] = n;
        s[++n] = i + '0';
    }
    m = 128;
    build_SA(), build_height(), build_color();
    add(1);
    for (register int i = 2; i <= n; ++i)
    {
        while (head < tail && h[q[tail]] >= h[i])
            --tail;
        q[++tail] = i;
        add(i);
        if (nw == T)
        {
            while (nw == T && l < i)
            {
                del(l++);
            }
            add(--l);
        }
        while (head < tail && q[head] <= l)
        {
            ++head;
        }
        if (nw == T)
        {
            ans = max(ans, h[q[head]]);
        }
    }
    cout << ans;
}
```


---

## 作者：Chinese_zjc_ (赞：0)

做完 $CF$ 的 $EDU$ 来洛谷找道题目来获取双倍经验,于是就找到了这题.

[CF的那道](https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/B)

先来考虑这道 $CF$ 题,显然就是先把 $2$ 个串合并,再用后缀数组算出 $height$ 数组,然后枚举不同原串且最大的 $height$ 即可.

下面是我 $CF$ 的代码:

```cpp
//This Code was made by Chinese_zjc_.
//头文件已省略
#define int long long
#define double long double
using namespace std;
const double PI = acos(-1);
const double eps = 0.0000000001;
const int INF = 0x3fffffffffffffff;
string s, t, h;
int n, m = 128, sum[200005], rk[200005], sa[200005], tmp[200005], cnt, height[200005], H, ans;
signed main()
{
    ios::sync_with_stdio(false);
    cin >> s >> t;
    h = '#' + s + '#' + t;
    n = h.length() - 1;
    for (int i = 1; i <= n; ++i)
    {
        ++sum[rk[i] = h[i]];
    }
    for (int i = 1; i <= m; ++i)
    {
        sum[i] += sum[i - 1];
    }
    for (int i = 1; i <= n; ++i)
    {
        sa[sum[rk[i]]--] = i;
    }
    for (int k = 1; k <= n; k <<= 1)
    {
        cnt = 0;
        for (int i = n - k + 1; i <= n; ++i)
        {
            tmp[++cnt] = i;
        }
        for (int i = 1; i <= n; ++i)
        {
            if (sa[i] > k)
            {
                tmp[++cnt] = sa[i] - k;
            }
        }
        for (int i = 1; i <= m; ++i)
        {
            sum[i] = 0;
        }
        for (int i = 1; i <= n; ++i)
        {
            ++sum[rk[i]];
        }
        for (int i = 1; i <= m; ++i)
        {
            sum[i] += sum[i - 1];
        }
        for (int i = n; i; --i)
        {
            sa[sum[rk[tmp[i]]]--] = tmp[i];
        }
        swap(tmp, rk);
        m = 1;
        rk[sa[1]] = 1;
        for (int i = 2; i <= n; ++i)
        {
            rk[sa[i]] = (tmp[sa[i]] == tmp[sa[i - 1]] && tmp[sa[i] + k] == tmp[sa[i - 1] + k]) ? m : ++m;
        }
        if (n == m)
        {
            break;
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        if (rk[i] == 1)
        {
            continue;
        }
        if (H)
        {
            --H;
        }
        int lst = sa[rk[i] - 1];
        while (lst + H <= n && i + H <= n && h[lst + H] == h[i + H])
        {
            ++H;
        }
        height[rk[i]] = H;
    }
    for (int i = 1; i <= n; ++i)
    {
        if (((sa[i] <= s.length() && sa[i - 1] > s.length()) || (sa[i] > s.length() && sa[i - 1] <= s.length())) && height[i] > height[ans])
        {
            ans = i;
        }
    }
    cout << h.substr(sa[ans], height[ans]) << endl;
    return 0;
}
```

当然这只是只有两个串的情况,如果串的量变多了呢?

我们使用同样的思路,也是把所有字符串合并到一起,然后把后缀数组处理出来.

比如样例:

```plain
3
abcb
bca
acbc
```

合并之后就是`abcb#bca#acbc`.

然后处理出后缀数组:

| height | 归属的原串 | 后缀            |
| ------ | ---------- | --------------- |
| 0      | 3          | `#acbc`         |
| 1      | 2          | `#bca#acbc`     |
| 0      | 2          | `a#acbc`        |
| 1      | 1          | `abcb#bca#acbc` |
| 1      | 3          | `acbc`          |
| 0      | 1          | `b#bca#acbc`    |
| 1      | **3**      | `bc`            |
| **2**  | **2**      | `bca#acbc`      |
| **2**  | **1**      | `bcb#bca#acbc`  |
| 0      | 3          | `c`             |
| 1      | 2          | `ca#acbc`       |
| 1      | 1          | `cb#bca#acbc`   |
| 2      | 3          | `cbc`           |

到这里我们已经很明显了.

我们只要枚举一个后缀 $i$ ,然后寻找一个最小的区间 $[l,i]$ 使每个原串都有至少一个归属其的后缀.

而这个任务就可以用二分 $+$ 前缀和完成.

然后对于区间 $[l,i]$ ,我们使用 $ST$ 表暴力查询最小值就可以求出该区间的所有后缀的 $lcp$ 了.

$Code$:

```cpp
//This Code was made by Chinese_zjc_.
//头文件已省略
#define int long long
#define double long double
using namespace std;
const double PI = acos(-1);
const double eps = 0.0000000001;
const int INF = 0x3fffffffffffffff;
string t, s[10];
int N, m = 128, n, cnt, sa[10010], tmp[10010], sum[10][10010], c[10010], rk[10010], ST[16][10010], h, height[10010];
int lensum[10], lg[10010], ans;
int lowbit(int now)
{
    return now & -now;
}
int query(int l, int r)//查询[l,r]区间的最小值
{
    return min(ST[lg[r - l + 1]][l], ST[lg[r - l + 1]][r - (1 << lg[r - l + 1]) + 1]);
}
bool check(int l, int r)
{
    for (int i = 1; i <= N; ++i)
    {
        if (sum[i][r] - sum[i][l - 1] == 0)
        {
            return false;
        }
    }
    return true;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin >> N;
    for (int i = 1; i <= N; ++i)
    {
        cin >> s[i];
        s[i] = '#' + s[i];
        lensum[i] = lensum[i - 1] + s[i].length();
        t += s[i];
    }
    if (N == 1)//N=1要特判
    {
        cout << s[1].length() - 1 << endl;
        return 0;
    }
    n = t.length() - 1;
    //中间貌似少了什么,好像上面出现过了?
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= N; ++j)
        {
            if (sa[i] < lensum[j])
            {
                ++sum[j][i];
                break;
            }
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= N; ++j)
        {
            sum[j][i] += sum[j][i - 1];
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        ST[0][i] = height[i];
    }
    for (int i = 1; 1 << i <= n; ++i)
    {
        for (int j = 1; j + (1 << i) - 1 <= n; ++j)
        {
            ST[i][j] = min(ST[i - 1][j], ST[i - 1][j + (1 << i >> 1)]);
        }
    }
    for (int i = 2; i <= n; ++i)
    {
        lg[i] = lg[i - 1] + (lowbit(i) == i);
    }
    for (int i = 1; i <= n; ++i)
    {
        int l = 1, r = i - 1;
        while (l < r)
        {
            int mid = (l + r + 1) >> 1;
            if (check(mid, i))
            {
                l = mid;
            }
            else
            {
                r = mid - 1;
            }
        }
        if (check(l, i))
        {
            ans = max(ans, query(l + 1, i));
        }
    }
    cout << ans << endl;
    return 0;
}
```



---

## 作者：MCAdam (赞：0)

[题目](https://www.luogu.com.cn/problem/P5546)

说一下后缀数组的做法。

题外话：对于这些多个字符串的，一般把它们拼起来，然后求$height$数组，再乱搞。感觉有$height$数组真的可以为所欲为！！！

看到$n\leq 5$，长度小于等于$2000$，感觉可以乱做。

从暴力出发，既然它要求公共子串，那不妨直接枚举这个公共子串。我们在第一个字符串上枚举一个子串，然后拿这个子串去和后面$4$个子串进行匹配，时间复杂度为$O(n\,len^4)$。

怎么优化呢？很简单。在后面$4$个字符串枚举开头，然后$O(len)$匹配可以用后缀数组优化掉。然后前面第一个字符串枚举子串，改为枚举开头和长度，长度明显可以二分。时间复杂度就降为$O(n\,len^2\log_2len)$~~真暴力~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
const int N=1e4+10,M=30;
int len,size=26;
string v[6],s;
int sum[6],SA[N],rk[N],tmp[N],cnt[M],height[N],f[N][21],log2[N],pow[20];
inline void binsort()
{
	for(register int i=0;i<=size;i++) cnt[i]=0;
	for(register int i=1;i<=len;i++) cnt[rk[i]]++;
	for(register int i=1;i<=size;i++) cnt[i]+=cnt[i-1];
	for(register int i=len;i>=1;i--) SA[cnt[rk[tmp[i]]]--]=tmp[i];
}
inline void get_SA()
{
	for(register int i=1;i<=len;i++)
		rk[i]=s[i]-'a'+1,tmp[i]=i;
	binsort();
	for(register int l=1;l<=len;l<<=1)
	{
		int p=0;
		for(register int i=len-l+1;i<=len;i++)
			tmp[++p]=i;
		for(register int i=1;i<=len;i++)
			if(SA[i]>l) tmp[++p]=SA[i]-l;
		binsort(),swap(rk,tmp);
		rk[SA[1]]=p=1;
		for(register int i=2;i<=len;i++)
			rk[SA[i]]=(tmp[SA[i]]==tmp[SA[i-1]]&&tmp[SA[i]+l]==tmp[SA[i-1]+l])?p:++p;
		if(p==len) break; size=p;
	}
}
inline void get_height()
{
	int pre=1;
	for(register int i=1;i<=len;i++)
	{
		if(pre) pre--;
		while(s[i+pre]==s[SA[rk[i]-1]+pre]) pre++;
		height[rk[i]]=pre;
	}
	for(register int i=1;i<=len;i++)
		f[i][0]=height[i];
	for(register int l=1;l<=log2[len];l++)
		for(register int i=1;i<=len-pow[l]+1;i++)
			f[i][l]=min(f[i][l-1],f[i+pow[l-1]][l-1]);
}
inline int query(int l,int r)
{
	int k=log2[r-l+1];
	return min(f[l][k],f[r-pow[k]+1][k]);
}
int main()
{
	log2[1]=0,pow[0]=1;
	for(int i=2;i<=10000;i++)
		log2[i]=log2[i>>1]+1;
	for(int i=1;i<=18;i++)
		pow[i]=pow[i-1]<<1;
	int n,minn=2010;
	scanf("%d",&n);
	s+='0';
	for(int i=1;i<=n;i++)
	{
		cin>>v[i];
		int tmp=v[i].length();
		s+=v[i],sum[i]=sum[i-1]+tmp;
		minn=min(minn,tmp);
	}
	len=sum[n],get_SA(),get_height();
	int low=0,high=minn+1;
	while(low+1<high)
	{
		int mid=(low+high)/2;
		bool flag1=false;
		for(int i=1;i<=sum[1]-mid+1;i++)
		{
			bool flag2=true;
			for(int p=2;p<=n;p++)
			{
				bool flag3=false;
				for(int j=sum[p-1]+1;j<=sum[p]-mid+1;j++)
				{
					int a=rk[i],b=rk[j],lcp;
					if(a>b) swap(a,b);
					lcp=query(a+1,b);
					if(lcp>=mid){ flag3=true; break; }
				}
				if(flag3==false){ flag2=false; break; }
			}
			if(flag2==true){ flag1=true; break; }
		}
		if(flag1) low=mid;
		else high=mid;
	}
	printf("%d\n",low);
	return 0;
}
```


$upd:$教练让我们做$SAM$的时候，也出了这道题，但数据有加强，考虑继续优化。

我们发现，上面那个计算过程并没有很好地利用$height$数组的性质，我们只是通过它来计算两个后缀的公共前缀。考虑从$height[i]=LCP(SA[i-1],SA[i])$下手

首先考虑只有两个字符串的情况

只用把字符串$B$拼到字符串$A$的后面。然后对于每一个$height[i]$判断它是否来自两个字符串，是的话就更新答案。换句话说，我们只用考虑长得最像的两个后缀。

现在扩展到$n$个字符串，我一开始的想法是取相邻的$n$个后缀。很明显这个想法是错的，但因为数据过水，可以水到$94$（错第一个点）。因为这样子不能取到所有的情况。

但这也启示我们，要选的后缀应该尽量靠在一起

正确的做法应该是：首先二分一个公共长度$mid$，然后枚举一个后缀开头$i$满足$height[i+1]\geq mid$，然后另外一个指针$j$从$i$往后走，直到$height[j+1]<mid$。对于$i-j$的后缀判断是否来自不同的字符串。如果可以就能缩减二分范围，如果不满足就让$i=j+1$

这样每次检验的复杂度为$O(n\,len)$，所以总时间复杂度为$O(n\,len\,\log_2len)$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
const int N=110010;
int len,size=40;
char v[N];
int s[N],SA[N],rk[N],tmp[N],cnt[N],height[N],log2[N],pow[23],col[N],vis[15];
inline void binsort()
{
    for(int i=0;i<=size;i++) cnt[i]=0;
    for(int i=1;i<=len;i++) cnt[rk[i]]++;
    for(int i=1;i<=size;i++) cnt[i]+=cnt[i-1];
    for(int i=len;i>=1;i--) SA[cnt[rk[tmp[i]]]--]=tmp[i];
}
inline void get_SA()
{
    for(int i=1;i<=len;i++)
        rk[i]=s[i],tmp[i]=i;
    binsort();
    for(int l=1;l<=len;l<<=1)
    {
        int p=0;
        for(int i=len-l+1;i<=len;i++)
            tmp[++p]=i;
        for(int i=1;i<=len;i++)
            if(SA[i]>l) tmp[++p]=SA[i]-l;
        binsort(),swap(rk,tmp);
        rk[SA[1]]=p=1;
        for(int i=2;i<=len;i++)
            rk[SA[i]]=(tmp[SA[i]]==tmp[SA[i-1]]&&tmp[SA[i]+l]==tmp[SA[i-1]+l])?p:++p;
        if(p==len) break; size=p;
    }
}
inline void get_height()
{
    int pre=1;
    for(int i=1;i<=len;i++)
    {
        if(pre) pre--;
        while(s[i+pre]==s[SA[rk[i]-1]+pre]) pre++;
        height[rk[i]]=pre;
    }
}
int main()
{
    int ans=0;
    char add='z'+1; 
    log2[1]=0,pow[0]=1;
    for(int i=2;i<=110000;i++)
        log2[i]=log2[i>>1]+1;
    for(int i=1;i<=20;i++)
        pow[i]=pow[i-1]<<1;
    int n,minn=10020;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",v+1);
        int tmp=strlen(v+1);
        minn=min(minn,tmp);
        for(int j=len+1;j<=len+tmp;j++)
            s[j]=v[j-len]-'a'+1,col[j]=i;
        len+=tmp;
    }
    get_SA(),get_height();
    int low=0,high=minn+1;
    while(low+1<high)
    {
        int mid=(low+high)/2,p=1;
        bool flag1=false;
        while(p<=len)
        {
            while(p<len&&height[p+1]<mid) p++;
            int q=p+1;
            while(q<len&&height[q+1]>=mid) q++;
            for(int i=1;i<=n;i++)
                vis[i]=0;
            for(int i=p;i<=q;i++)
                vis[col[SA[i]]]=1;
            bool flag2=true;
            for(int i=1;i<=n;i++)
                if(!vis[i]){ flag2=false; break; }
            if(flag2){ flag1=true; break; }
            else p=q+1;
        }
        if(flag1) low=mid;
        else high=mid;
    }
    printf("%d\n",low);
    return 0;
}

```




---


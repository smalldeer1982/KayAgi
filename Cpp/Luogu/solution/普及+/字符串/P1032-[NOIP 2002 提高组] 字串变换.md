# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# 题解

## 作者：coyangjr (赞：582)

萌新的第二篇题解。。
## KMP解决本题

　　~~**为啥要用find，为啥要用replace**~~

　　~~其实是我考试时忘了 qwqwqwqwq~~

　　所以，我用的是**KMP**~~（AC自动机太难了）~~

整道题思路很简单
>至多6个规则 和 若在10步(包含10步)以内

　　暗示了我们要去搜索。于是机房里的某~~dalao~~就开始了~~dfs~~。然后TLE，于是特判第五点~~（强烈谴责）~~
### 一般的，求解的个数用深搜，求最优解用广搜。
　　~~原因自己想~~ 其实是广搜由于寻找顺序，导致找到一个解就一定是最优解了。

　　于是大框架是一个BFS，里面再去实现"取出队首元素，找字串，更改，放入队列"
~~这不摆明着是模式匹配吗~~

好的模版题传送门
> [P3375 【模板】KMP字符串匹配](https://www.luogu.org/problemnew/show/P3375)

> [~~P3808 【模板】AC自动机（简单版）~~](https://www.luogu.org/problemnew/show/P3808)

> [~~P3796 【模板】AC自动机（加强版）~~](https://www.luogu.org/problemnew/show/P3796)

　　由于本蒟蒻，AC自动机忘了。。于是写了KMP

　　具体的讲解上代码（不要走，后面更精彩）
```cpp
//P1032 字串变换
#include <iostream>
#include <cctype>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstring>
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <algorithm>
#include <sstream>
#include <queue>
#include <map>
#define debug cout << "debug"<<endl

using namespace std;
#define il inline
#define re register
typedef long long ll;

string a,b;

struct Node {//用于queue中存放，一个是字串，一个是搜索的“深度”
	string data;
	int step;
	Node(string _data,int _step):data(_data),step(_step) {}
	Node() {}
};
queue<Node>q;
string change[10];//改成哪个
string diff[10];//改哪个
/*即
搜索diff[i]
改成change[i]
*/

int nxt[10][10000];//kmp的next数组
map<string,bool>mp;//用于判重，避免重复搜索
il void get_next(int x)//找next，具体的可以翻翻网上的Blog。
{
	re int i,j=0;
	for (i=2; i<diff[x].length(); i++) {
		while (j&&diff[x][i]!=diff[x][j+1]) j=nxt[x][j];
		if (diff[x][j+1]==diff[x][i]) j++;
		nxt[x][i]=j;
	}
}

il void KMP(string a,int x,int step)//寻找匹配的串，顺便修改并添加到queue中
{
	string z=a;
	a=" "+a;//神奇的操作，。。。
	re int i,j=0;
	for (i=1; i<a.length(); i++) {
		while (j>0&&diff[x][j+1]!=a[i])	j=nxt[x][j];
		if (diff[x][j+1]==a[i]) j++;
		if (j==diff[x].length()-1) {//找到了~
			re int t= i-diff[x].length()+1;//记录位置
			string tmp=z.substr(0,t)+change[x]+z.substr(t+diff[x].length()-1);//修改（就不用replace，（真香））
			q.push(Node(tmp,step+1));
			j=nxt[x][j];//继续找
/*
第一次交由于脑子不好，找了一遍就return了。
*/
		}
	}
	return;
}

int cn=0;
int main()
{
	//freopen("in.txt","r",stdin);
	cin >> a >> b;
	string t1,t2;
	while (cin >>t1>>t2) {
		change[++cn]=t2;
		diff[cn]=" "+t1;//继续神奇的操作
		get_next(cn);
	}
	q.push(Node(a,0));
	while (!q.empty()) {
		Node now=q.front();
		q.pop();
		string x=now.data;
		if (mp[x]) continue;//map判重
		mp[x]=1;//标记
		if (now.step>10) {//找不到（因为bfs是按照step:1,2,3...来找的，所以一旦到了STEP11时一定无解了）
			puts("NO ANSWER!");
			exit(0);
		}
		if (x==b) {//找到，由于搜索有序，step一定是最小的
			cout << now.step<<endl;
			exit(0);
		}
		for (re int i=1; i<=cn; i++) {//枚举所有模式串，匹配文本串
			KMP(x,i,now.step);
		}
	}
	puts("NO ANSWER!");//最后由于map的判重，可能导致queue为空，于是到达这里的数据肯定是无解的
	exit(0);
}
```
## 有关KMP的Blog
　　[KMP算法详解(Matrix67)](http://www.matrix67.com/blog/archives/115)以及[字符串匹配的KMP算法(阮一峰)](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)
  
# 都说了不要走了，String函数总结
　　string的函数，真香。(不总结迭代器的)
>(由于NOIP2018，rp++，现在来总结一发string的函数)

- ## 最基本的，头文件
```cpp
#include <cstring>
#include <string>
```
就这两个~~含了string的~~，考试时一定要写

- ## 最最最基本的，大家都会的
```cpp
string a;//声明String a
a="12345";//赋值
string b="54321";
int len=a.length();//获取长度
cin >> a;//输入（以空格换行符为界限）
getline(cin,a)//可以读入空格
cout << a;
swap(a,b)//交换
printf("%s\n",a.c_str());//C风格输出，c_str()是啥？
```
- ### c_str()

返回一个char \*， char类型的指针

关于char[ ],char \*,string这些东西，尽量要用string全部用string，否则都用char[ ],后期两个转换自己认为很麻烦的。。

- ## 重载方面

### +：连接两个String
```cpp
string c=a+b;
c="123"+c+"321";
```
### \> < == != : 根据字典序比较
```cpp
inline bool cmp(string a,string b)
{return a>b;}
...
int main()

	sort(a+1,a+1+n,cmp);
```
- ## insert() 插入

某个String a.insert(位置,另一个string)

```cpp
	string str="to be question";
	string str2="the ";
    str.insert(6,str2);// to be (the )question
```

- ## erase() 删除
> erase(pos,n);

删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
```cpp
//接上
	str.erase(0,3); //(~~to ~~)be question
```
- ## clear() 清除
清除。。。

- ## replace() 替换

某个String a.replace(pos,len,另一个String b)

替换a中pos开始往后len的这些字符为b
```cpp
	str.replace(0,2,"To");// (To) be question
```
往往与find()一起使用。
- ## find()与rfind()

##### 完全匹配String b
a.find(b) 从开始找b第一次出现的位置并返回

a.find(b,pos) 从pos开始找b第一次出现的位置并返回
```cpp
string str="To be, or not to be - that is the question";
    int t=str.find("be");\\ t=3,str[t]='b'(To be 的be)
    int t=str.find("be",4);\\ t=17,str[t]='b'(not to be的be)
```
rfind(b)或rfind(b,pos) 倒着找O(∩_∩)O~
```cpp
    int t=str.rfind("be");\\ t=17,str[t]='b'(not to be的be)
    int t=str.rfind("be",16);\\ t=3,str[t]='b'(To be 的be)
```
没有出现，返回npos，即-1（打印出来为4294967295）
```cpp
if (str.find("Be")==string::npos)
	cout <<"NO"<<endl;// 输出NO
if (str.rfind("Be")==-1)
	cout <<"NO"<<endl; // 输出NO
```
- ## find_first_of()与find_last_of()

##### 在a中寻找String b中任意一个字符 ‘(任意一个)’

a.find_first_of(b)或a.find_first_of(b,pos)

 在a开始(或从pos开始)向后查找，只要在a中遇到一个字符，该字符与c中任意一个字符相同，就停止查找，返回该字符在a中的位置；若匹配失败，返回npos。

举个栗子
```cpp
//将字符串中所有的元音字母换成*
//代码来自C++ Reference，地址：http://www.cplusplus.com/reference/string/basic_string/find_first_of/
#include<iostream>
#include<string>

using namespace std;

int main()
{
    std::string str("PLease, replace the vowels in this sentence by asterisks.");
    std::string::size_type found = str.find_first_of("aeiou");
    while (found != std::string::npos)
    {
        str[found] = '*';
        found = str.find_first_of("aeiou", found + 1);
    }
    std::cout << str << '\n';
    return 0;
}
//运行结果：
//PL**s* r*pl*c* th* v*w*ls *n th*s s*nt*nc* by *st*r*sks
```
find_last_of 倒着找

- ## find_first_not_of()与find_last_not_of()

##### 感觉和前面一类的相反的，类似于找了个补集。即在a中搜寻b中没有的字符并返回位置

用法同上，第一个是String b,第二个可选 pos，不写pos默认为0

如果将上一个样例中的str.find_first_of改成str.find_first_not_of,则输出会把非a~~(あ)~~i~~(い)~~u~~(う)~~e~~(え)~~o~~(お)~~(逃。。。)的换成 *

#### 总结一下“找”的函数的传参(string b,pos,len)
#### b是被搜寻的对象。pos（可有可无）指出a内的搜寻起点位置，第三个参数len（可有可无）指出b中搜寻的字符个数（即为b的某个字串）。

- ## substr() 字串

sub(start,length)

如果第二个参数不写，就是从start到字符串结尾。
```cpp
string str="To be, or not to be - that is the question";
	str.substr(0,2);// To
    str.substr(str.find("question"));// question
```
- ## String与Int互转（不考虑C++11的函数）
#### int转string
```cpp
ostringstream outs; //输出字符串流
int x = 12; 
outs << x; //向输出字符串流中输出x的内容 
string a=outs.str(); //利用字符串流的str函数获取流中的内容
```
#### string转int
```cpp
string a="12";
istringstream ins(a); //输入字符串流，流的内容初始化为a
int x; 
ins >> x; //从is流中读入并存入x中
```

(没有用的东西。。)
- ### String与char的转换
#### String转char*
　　1.data()
```cpp
string str = "hello";
const char* p = str.data();//加const  或者用char * p=(char*)str.data();的形式
```
　　同时有一点需要说明，这里在devc++中编译需要添加const，否则会报错invalid conversion from const char*  to char *，这里可以再前面加上const或者在等号后面给强制转化成char*的类型。

　　下面解释下该问题，const char*是不能直接赋值到char*的,这样编译都不能通过,理由:假如可以的话,那么通过char*就可以修改const char指向的内容了,这是不允许的。所以char*要另外开辟新的空间，即上面的形式。

　　2. c_str()
```cpp
string str=“world”;
const char *p = str.c_str();//同上，要加const或者等号右边用char*
```
　　3. copy()
```cpp
string str="hmmm";
char p[50];
str.copy(p, 5, 0);//这里5代表复制几个字符，0代表复制的位置，
*(p+5)=‘\0’;//注意手动加结束符！！！
```
#### 　　String转char[ ]，直接循环赋值
```cpp
string pp = "dagah";
char p[8];
int i;
for( i=0;i<pp.length();i++)
	p[i] = pp[i];
p[i] = '\0';
```

总结部分 参考资料

[c++中的string常用函数用法总结](https://blog.csdn.net/fdqw_sph/article/details/54233971)

[C++string中用于查找的find系列函数浅析](https://www.cnblogs.com/zpcdbky/p/4471454.html)

[C++中string、char *、char\[\]的转换](http://www.cnblogs.com/Pillar/p/4206452.html)

安利一波自己的Blog
[coyangjr](https://coyangjr.top)

---

## 作者：ShawnZhou (赞：280)

安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

洛谷红名留念。我会继续努力。

题意已经把做法写得特别露骨了。。。最小步数，最多6个变换规则。。。。广搜自不必说，不仅可以寻找解而且还能判断步数（根据广搜首解最优的性质可以得到）。

开两个数组记录串的转换关系，然后以a串（原串）为起点开始搜索，搜索目标是b串。

需要一个map记录某个串是不是被搜到过，如果已经搜过了就不再继续搜 。

我们枚举当前队列中队头那个串的每一个位置，对每一个位置枚举所有可能的转换手段，然后去尝试拼接。

拼接函数借鉴了一下楼上stdcall大爷题解的思路，对于一个试图要改变的串str，我们试图在它的第i位用第j种手段改变，首先判断是否可行，然后再逐位拼接。并且如果拼接出的串是合法的，那么我们就把这个串继续压入队列，再次搜索，中间记录一下步数step和ans。

最后输出ans时判断，如果ans超过了步数限制直接输出无解，否则输出步数。

不过我发现，ans等于0时应该也是无解，这样会导致如果用ans<=10来判断是不是超出步数会WA掉第三个点。。

参考代码：

```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <queue>
#include <map>
#define maxn 15
using namespace std;
struct node{//方便搜索，也可以使用pair简化
    string str;
    int step;
};

string a,b;
string orginal[maxn];
string translated[maxn];
int n,ans;
map<string,int> ma;//很重要的东西，用来判重，否则会TLE在第3点和第5点

string trans(const string &str,int i,int j){//借鉴了stdcall大爷的思想
    string ans = "";
    if (i+orginal[j].length() > str.length())
        return ans;

    for (int k=0; k < orginal[j].length();k++)
        if (str[i+k] != orginal[j][k])
            return ans;

    ans = str.substr(0,i);
    ans+=translated[j];
    ans+=str.substr(i+orginal[j].length());
    return ans;
}

void bfs(){//一个平淡无奇的bfs过程
    queue <node> q;
    node s;
    s.str = a;
    s.step = 0;
    q.push(s);

    while (!q.empty()){
        node u = q.front();
        q.pop();
        string temp;

        if(ma.count(u.str) == 1) //剪枝，判断重复的路径
            continue;

        if (u.str == b){
            ans = u.step;
            break;
        }
        ma[u.str] = 1;
        for (int i=0;i < u.str.length();i++)//枚举当前串所有可能位置
            for (int j=0; j<n; j++){//枚举所有可能手段
                temp = trans(u.str,i,j);
                if (temp != ""){
                    node v;
                    v.str = temp;
                    v.step = u.step+1;
                    q.push(v);
                }
            }
    }
    if (ans > 10 || ans == 0)
        cout << "NO ANSWER!" << endl;
    else
        cout << ans << endl;

}

int main(){
    cin >> a >> b;
    while (cin >> orginal[n] >> translated[n])
        n++;
    bfs();
    return 0;
}
```

---

## 作者：Time_Rune (赞：157)

普通的字符串+搜索练习题

主要是读入数据与查找串的过程麻烦一点

普通搜索的思路其他人已经说了，我来说一下我A题的算法：

**迭代加深搜索**

正常情况下，dfs会超时，~~但我这次又非常造作地偏要写dfs~~

那怎么办呢？直接掏出迭代加深改个条件AC。

事实证明迭代加深还是很厉害的

**TLE -> AC**

**1323ms -> 77ms (总共时间)**

------------



------------


首先简单介绍一下这个算法

普通的dfs是一路搜索到底，可能会在一个 “**错误的答案路线**”上一路搜索到底，从而浪费的大量的时间。

而迭代加深搜索，就是每次**猜测一个可能的答案**，超过这个答案时便会自动终止搜索，通过枚举答案来**一层一层的搜索**(加深)，这样就又有dfs的递归形式，又像广搜一样，不搜索过深浪费时间，是一种结合了dfs与bfs优点的写法。

下面根据具体的代码来讲一下这个算法。

正常的dfs，是根据题目的条件，这样写:

```cpp
void dfs(string now,int step){
//	cout<<now<<' '<<step<<endl;
	if(step>10)return;//根据题意，超过十步自动停止
//==================判断重复======================
	if(now==b){
		ans=min(ans,step);
		return;
	}
	if(ed[now]){//使用set来判断重复状态
		if(step>=st[now])return;
	}
	ed[now]=1;st[now]=step;
//==================寻找变换========================
	int loc=0;string changed;
	for(int i=1;i<=t;++i){//找所有的字符串 
		loc=-1;
		 while(1){//找到了 
		 	loc=now.find(change[i][0],loc+1);
		 	if(loc==-1)break;
		 	changed=now;
		 	changed.erase(loc,change[i][0].size());
		 	changed.insert(loc,change[i][1]);
		 	dfs(changed,step+1);
		 }
	}//这一部分写的比较丑，建议参考他人的
	return;
}

```

直接这样一路走到底，虽然加了一个判断重复的剪枝(记忆化)，但仍然会超时。



------------
然后我们发现题目本身就有搜索深度的限制，所以我们正好可以使用迭代加深来处理

核心代码：

主函数内：
```cpp
	//使用k来记录层数
   //只要还没找到，就继续增加
   //找到10还没有找到，直接退出
	while(ans==999999){//只要没有找到答案
		dfs(a,0);
        
		ed.clear();
		st.clear();//上一次记录的步数与状态记得清空
        
		k++;//增加搜索层数
		if(k==11)break;
	}
```
dfs函数内：
```cpp
	if(step>10)return;//步数过大 
```
改为:
```cpp
	if(step>k)return;//步数过大 
```

这样稍微地修改了一下过后，这题就可以用dfs过了~

附上完整的AC代码：
```cpp
//子串变换
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#include<map>
using namespace std;
map <string,bool> ed;
map <string,int> st;
string a,b;
string change[30][3];
int t=1,k=2;
int ans=999999;
void dfs(string now,int step){
//	cout<<now<<' '<<step<<endl;
	if(step>k)return;//步数过大 
	if(now==b){
		ans=min(ans,step);
		return;
	}
	if(ed[now]){
		if(step>=st[now])return;
	}
	ed[now]=1;st[now]=step;
	int loc=0;string changed;
	for(int i=1;i<=t;++i){//找所有的字符串 
		loc=-1;
		 while(1){//找到了 
		 	loc=now.find(change[i][0],loc+1);
		 	if(loc==-1)break;
		 	changed=now;
		 	changed.erase(loc,change[i][0].size());
		 	changed.insert(loc,change[i][1]);
		 	dfs(changed,step+1);
		 }
	}
	return;
}
int main(){
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	cin>>a>>b;
	while(cin>>change[t][0]>>change[t][1]){
		t++;
	}
	t--;
	
	while(ans==999999){
		dfs(a,0);
		ed.clear();
		st.clear();
		k++;
		if(k==11)break;
	}
	
	if(ans==999999){
		cout<<"NO ANSWER!"<<endl;
		return 0;
	}
	cout<<ans<<endl;
	return 0;
} 
```

还有什么不明白的可以直接在评论区里面提出来，只要看见就会回答

和我一样喜欢写dfs的小伙伴点个赞吧qwq


---

## 作者：Lemoning (赞：132)

这题看上去简单，但其实从头到尾全是坑......qwq

首先，读入数据就很懵逼了，告诉你最多6组变换，但又没告诉你确切的组数，这就很无奈了，其实你可以直接写一个for (i=1;i<=6;i++)来读入所有的转换方式，最后找到有效数据的组数，就OK了（亲测）
~~~c++
for (i=1;i<=6;i++)
	{
		cin>>sa[i]>>sb[i];
	}
	l=6;
while (sa[l][0]=='\0') l--;
~~~
~~（虽然本蒟蒻不是这么读入的。。。）~~

其次，在你宽搜的时候，像本蒟蒻这样图省事的人都会直接用find函数找子串，但是注意，并不是所有数据中都是只有一个子串的（比如第5个数据点），应此你也可以用for循环进行搜索

最后，就是时间的问题了~~（都是时辰的错）~~，这个问题比较容易解决（对于精通STL的人来说），用MAP判重剪枝就OK了（[MAP的使用方法](https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html)）

若果还有疑问，请看本蒟蒻~~香喷喷~~的代码。
~~~c++
#include<bits/stdc++.h>		//万能头文件
using namespace std;
string a,b;					//字符串A与字符串B
string sa[8],sb[8];			//存放6种转换方式
map<string,int> map1;		//用map存放已经宽搜过的字符串，用来判重剪枝（否则会超时）
int l;						//有l种转换方式
queue<string> q;			//存放转换出来的字符串
queue<int> bb;				//存放当前转换出来的字符串已经使用的步数
int bfs()
{
	int i,j,k,m,n;
	string s,ss;
	while (q.empty()==0&&q.front()!=b&&bb.front()<=10)		//当还能继续转换且没转换出字符串B且步数也没有超出10步时进行宽搜
	{
		if (map1[q.front()]==1) 		//剪枝：如果当前字符串已经宽搜过了,就弹出,进入下一次循环.
		{
			q.pop();
			bb.pop();
			continue;
		}
		map1[q.front()]=1;				//记录下该字符串
		for (i=1;i<=l;i++)				//循环出每一种转换方式
		{	
			s=q.front();				//将S赋值为当前要操作的字符串
			while (1)					//找出子串sa[i]的所有位置
			{	
				m=s.find(sa[i]);		//在S里查找子串sa[i]的第一次出现位置
				if (m==-1) break;		//如果全找出来(找不到)了,就结束循环
				ss=q.front();			//将SS赋值为当前要操作的字符串
				ss.replace(m,sa[i].size(),sb[i]);	//在SS中用子串sb[i]替换掉S里第一次出现的子串sa[i]
				q.push(ss);				//将转换后的SS压入队列
				bb.push(bb.front()+1);	//将转换后的SS已经使用的步数压入队列
				s[m]='~';				//将S里子串sa[i]的第一次出现位置随便换成另一种无关的字符,这样就可以查找到S里子串sa[i]的下一个出现位置
			}
			
			
		}
		q.pop();						//将操作过的字符串弹出队列
		bb.pop();						//操作过的字符串已经用过的步数一块弹出
	}
	if (q.empty()==1||bb.front()>10) return -1;//没法再进行宽搜,或者超出步数,就返回-1
		else return bb.front();					//否则,就是找到了,便返回最少使用步数
}
int main()
{
	int i,j,k,m,n;
	cin>>a>>b;							//读入字符串A与字符串B
	l=1;
	while (cin>>sa[l]>>sb[l]) l++;		//读入转换方式
	l--;								//l初始值为1,所以要减1,才能表示转换方式的数量
	if (l==0&&a!=b)						//若果没有转换方式且A也不等于B,直接输出"NO ANSWER!"(其实这步可以不要)
	{
		cout<<"NO ANSWER!";
		return 0;
	}
	q.push(a);							//将字符串A压入队列
	bb.push(0);							//将初始步数0压入队列
	k=bfs();							//宽搜
	if (k==-1)							//返回-1说明NO ANSWER!
	{
		cout<<"NO ANSWER!";
		return 0;
	}
	cout<<k;							//输出最小步数
}
~~~
蒟蒻第一次发题解，求过qwq。

---

## 作者：BrandonSoong (赞：127)

================================================================

===========================开始分割线============================

================================================================

### 这道题很明显是一道 B F S 的 模 板 题
# 但是···············
**这道题更加明显的是一道**
**[ 双 向 B F S 模 板 题 ]**
```
因为
这道题同时给出了初始状态和目标状态
所以
用双向BFS可以使得运行速度大大提升
```
***

================================================================

========================真正的开始分割线=========================

================================================================

**画个图来举栗子！**


![](https://s2.ax1x.com/2019/10/24/KUjuY4.png)

我们假设上面的S点是初始状态，下面的T点是目标状态，那么单向的BFS会形成这么一个**树状图形**，每一次扩展都相当于是树枝的延伸，最后如果延伸到了T那么就结束了。

![](https://s2.ax1x.com/2019/10/24/KUjQp9.png)

但是我们很明显的可以发现有很多**冗余的BFS搜索枝**是没有意义的，它们过于偏离了T的方向！

![](https://s2.ax1x.com/2019/10/24/KUjAO0.png)

我们同时可以发现，其实我们也可以从T开始搜索，造出一个上大下小的**BFS搜索树**，同样可以起到BFS的作用，当搜索到S点的时候就结束了！

![](https://s2.ax1x.com/2019/10/24/KUjeTU.png)

而这样做的时候同样也有很多的**冗余搜索枝**。

![](https://s2.ax1x.com/2019/10/24/KUjZwT.png)

这个时候我们考虑**双向BFS**！！如果我们同时从上面和下面开始延伸这两棵树子的话，一旦两头**撞在一起**就可以说明搜索到了，因为两颗搜索树的**搜索规则是相反的**，两棵树相遇的时候**从一边的节点一定可以顺着另外一边的搜索枝到达终点**！

![](https://s2.ax1x.com/2019/10/24/KUjllR.png)

这样一来我们就可以去除很多搜索枝，用几何关系不难证明至少会减少**百分之五十**的搜索空间与时间，但是实际上每一次搜索带来的**横向扩张**远远不止+1，有的时候可以**翻倍或者更多**，所以这棵树子的图形往往是一个**指数函数图像**为边界的搜索树，深度每每+1，就会带来大量的新搜索节点，而**双向BFS**可以减少大量的搜索节点。

![](https://s2.ax1x.com/2019/10/24/KUjKfJ.png)

***
**对于这道题，我们可以通过map去实现查找现在我们所搜索到的节点是否出现过（如果是同一边的搜索树里面的，那么就不用再把这个节点入队了，假如是对面的，那么就意味着两棵搜索树碰面了！算法结束！）**

**而每次出队的时候，只能够出上一层的搜索节点，不可以使用这一层的搜索节点，保证两边一步一步地走，所以map里面所对应的int是这个搜索节点对应的层数-1（具体细节可以模拟）**
****
**[[15ms] AC](https://www.luogu.org/record/25655144)  code**
```cpp
#include<bits/stdc++.h>
using namespace std;
string a[10],b[10],s,t;
int n=1;
map <string,int> A,B;//pair< string , step + 1 >
queue <string> A_,B_; 
inline void initialization()
{
	cin>>s>>t;
	while(cin>>a[n]>>b[n])n++;
}
inline int bfs()
{
	int step=0;
	A_.push(s);//开始状态
	A[s]=0;//开始状态的层数 
	B_.push(t);//开始状态
	B[t]=0;//结束状态的层数 
	string s,s2;
	while(++step<=5)//一边是10步之内，那么两边一起走就是5步之内 
	{
		while(A[A_.front()]==step-1)//保证是上一层的 
		{
			s=A_.front();
			A_.pop();
			for(int i=1;i<=n;i++)//对于每一个转换方案遍历 
			{
				unsigned int pos=0;//遍历开始搜索的节点，结合string::find( key_string , starting ) 
				while(pos<s.length())
				{
					if(s.find(a[i],pos)==s.npos)break;//如果找不到了 
					s2=s;
					s2.replace(s2.find(a[i],pos),a[i].length(),b[i]);//replace( starting , length , substitution )
					if(A.find(s2)!=A.end())//这棵树里面之前出现过 
					{
						pos++;
						continue;
					}
					if(B.find(s2)!=B.end())return step*2-1;//对面的搜索树里面出现过，由于是上面先走，所以-1 
					A_.push(s2);//入队 
					A[s2]=step;
					pos++;
				}
			}
		}
		while(B[B_.front()]==step-1)//保证是上一层的 
		{
			s=B_.front();
			B_.pop();
			for(int i=1;i<=n;i++)//对于每一个转换方案遍历 
			{
				unsigned int pos=0;//遍历开始搜索的节点，结合string::find( key_string , starting ) 
				while(pos<s.length())
				{
					if(s.find(b[i],pos)==s.npos)break;//如果找不到了 
					s2=s;
					s2.replace(s2.find(b[i],pos),b[i].length(),a[i]);//replace( starting , length , substitution )
					if(B.find(s2)!=B.end())//这棵树里面之前出现过 
					{
						pos++;
						continue;
					}
					if(A.find(s2)!=A.end())return step*2;//对面的搜索树里面出现过，由于是上面先走，所以-1 
					B_.push(s2);//入队 
					B[s2]=step;
					pos++;
				}
			}
		}
	}
	return -1;
}
int main()
{
	initialization();
	int ans=bfs();
	if(ans==-1)
	printf("NO ANSWER!");
	else printf("%d",ans);
	return 0;
}

```
***
================================================================

===========================结束分割线============================

================================================================

Thx for watching the patience!

---

## 作者：MakotoTSK (赞：79)


算法：广度优先搜索

思路：每次字符串入队列后找可以执行的操作（即看一下有没有可以修改的串），把修改之后的字符串入队列，记录修改的次数。

注意：每次找可以修改的串处理完之后要从这个位置继续往后找看这个字符串后面有没有可以修改的子串。

技巧：这个题使用STL可以大幅减少码量。
```cpp
#include <iostream>
#include <string>
using namespace std;
string a,b;
string ra[7],rb[7];
struct node{
    string cur;//当前字符串
    int cs;//当前已修改次数
}q[2000000];
int main()
{
    cin>>a>>b;
    int i=1;
    while(cin>>ra[i]>>rb[i])
    {
        i++;
    }
    i-=1;
    
    int head=0,tail=1;
    q[tail].cur=a;      //原字符串入队列
    q[tail].cs=0;
    while(head<tail)
    {
        head++;
        if(q[head].cs>10)    //次数大于10输出无解后结束程序
        {
            cout<<"NO ANSWER!"<<endl;
            return 0;
        }
        for(int j=1;j<=i;j++)
        {
            int pos=q[head].cur.find(ra[j],0);
            while(1)//寻找可以修改的子串
            {
                if(pos==-1)//找不到退出
                {
                    break;
                }
                else    //找到之后把字符串修改之后塞进队列，再继续往下找
                {
                    tail++;
                    q[tail].cur=q[head].cur;
                    q[tail].cs=q[head].cs+1;
                    q[tail].cur.replace(pos,ra[j].size(),rb[j]);
                    if(q[tail].cur==b)
                    {
                        cout<<q[tail].cs;
                        return 0;
                    }
                    pos=q[head].cur.find(ra[j],pos+1);
                }
            }
        }
    }
    return 0; 
}
```

---

## 作者：Brainless (赞：39)

其实可以双向广搜鸭。。。。（题解里好像没多少人写啊）
```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;++i)
using namespace std;
struct node { string s; int step; };
queue<node> q1, q2;
map<string, int> h1, h2;	//2个哈希
string w1[1001], w2[1001]; 	//存变换规则	
int n, flag;
void Bfs()
{
	while(!q1.empty() && !q2.empty()) //两个队列是否搜完
	{
    /*第一遍广搜*/
		node now1 = q1.front(); q1.pop();
		int step1 = now1.step;
		string s1 = now1.s;
		if(step1 >= 10) { cout << "NO ANSWER!" << endl; return; } //步数超过十
		for(int i = 1; i <= n; ++i)
		{
			if(s1.size() < w1[i].size()) continue; //如果当前字符串大小小于要改变的字符串，则直接跳过
			for(int f = 0; f <= s1.size() - w1[i].size(); ++f) //逐一判断
			{
				string ts, to = w2[i];
				if(s1.substr(f, w1[i].size()) != w1[i])
					continue;
                /*生成新字符串*/
				ts = s1.substr(0, f); //
				ts += to; ts += s1.substr(f + w1[i].size());
                
				if(h1[ts]) continue; //已经走过，则跳过
				if(h2[ts]){ cout << step1 + h2[ts] << endl; return; } //如果反向广搜搜过，直接返回
				now1.s = ts, now1.step = step1 + 1;
				q1.push(now1);
				h1[ts] = step1 + 1; //记录哈希
			}
		}
		/**************************************************************/
        /*第二遍，把第一遍反过来就行了*/
		node now2 = q2.front(); q2.pop();
		int step2 = now2.step;
		string s2 = now2.s;
		if(step2 >= 10) { cout << "NO ANSWER!" << endl; return; }
		for(int i = 1; i <= n; ++i)
		{
			if(s2.size() < w2[i].size()) continue;
			for(int f = 0; f <= s2.size() - w2[i].size(); ++f)
			{
				string ts, to = w1[i];
				if(s2.substr(f, w2[i].size()) != w2[i]) continue;
				ts = s2.substr(0, f);
				ts += to; ts += s2.substr(f + w2[i].size());
				if(h2[ts]) continue;
				if(h1[ts]) { cout << step2 + h1[ts] << endl; return; }
				now2.s = ts, now2.step = step2 + 1;
				q2.push(now2);
				h2[ts] = step2 + 1;
			}
		}
	}
	cout << "NO ANSWER!" << endl;
}
int main()
{
	string a, b;
	cin >> a >> b;
	node st = {a, 0};
	node ed = {b, 1};
	h1[a] = 0; h2[b] = 1;
	q1.push(st); q2.push(ed); //记录开头和结尾作为双向广搜的起点
	while(cin >> a >> b)
	{
		//if(a == "0") break;（方便调试）
		w1[++n] = a; w2[n] = b; //w1存a， w2存b
	}
	Bfs(); //直接广搜
	return 0;
}
```


---

## 作者：hzg0226 (赞：30)

简单的BFS，但是要注意判重，不然第5个点一定会超时。我是用的set来判重当前转换后的字符串之前是否已经出现过，如果出现过，则不会再次将该转换后的字符串加到队列中，如果没有出现过，则加入队列，并且将该字符串加入到set中以判重！

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node
{
    int num;//变换次数
    string s;//变换n次后的结果
    node(int num,string s):num(num),s(s){}//构造函数
};
string A,B;//初始字符串和目标字符串
vector< pair<string,string> >v;//存储规则
set<string>reapr;//判重

bool bfs()
{
    queue<node>q;
    q.push(node(0,A));
    while(!q.empty()){
        node u=q.front();
        q.pop();
        if(u.num>10) {printf("NO ANSWER!\n");return false;}//如果队头的字符串转换次数超过10次，不存在答案
        for (int i=0;i<v.size();i++)
            if (u.s.find(v[i].first)!=-1);//如果该字符串存在可以转换的情况
                for (int j=u.s.find(v[i].first);j<u.s.length();j=u.s.find(v[i].first,j+1)){//从该字符继续搜索串下一个可能转换位置
                    string t=u.s;
                    t.replace(j,v[i].first.length(),v[i].second);//构造出转换后的字符串
                    if(t==B) {printf("%d\n",u.num+1);return true;}//如果转换后的字符串为目标串B
                    if(!reapr.count(t)){//判重！非常重要，不然一定会超时
                        q.push(node(u.num+1,t));
                        reapr.insert(t);//如果之前没有出现过该字符串，则加入到已出现的集合，以防下次再次出现
                    }
                }
    }
    return false;//不存在答案
}
int main()
{
    //freopen("input.txt","r",stdin);
    cin>>A>>B;
    string a,b;
    while(cin>>a>>b)
        v.push_back(make_pair(a,b));
    if(!bfs()) printf("NO ANSWER!\n");
    return 0;
}

```

---

## 作者：zhaowangji (赞：13)

## 主要思想：queue+map+set

说一下读入：while(cin>>x>>y)，这样就行了，按ctrl+z结束输入

首先，我们很容易想到一种做法：

```
用队列进行宽搜（用结构体/二维数组）
map作为变换规则的储存器
set用来查重
每次在队首里找是否有能变换的部分，然后判重，入队
```

于是就有了以下的代码

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<map>
#include<string>
#include<set>
using namespace std;
struct node{
	string s;//当前的字符串
	int step;//所用的步数
};
queue<node> q;//队列
string a,b;//初始的两个串
map<string,string> m;//存规则
map<string,string>::iterator it;//要用迭代器遍历
set<string> vis;//判重
void bfs(){
	while(!q.empty()){//队列不空
		node z=q.front();//取出队首
		q.pop();//队首出队
		string x=z.s;//取元素
		int y=z.step;//取元素
		if(y>10){//超过10步了
			cout<<"NO ANSWER!"<<endl;
			return;
		}
		for(it=m.begin();it!=m.end();it++){//迭代器的遍历方式
			string strnew=x;//如果一直用x，那么难以保证其值没有发生改变
			string strx=it->first;//取<string,string>中的前一个
			string stry=it->second;//取后一个
			int stepnew=y;//同strnew的原因
			if(((long long)strnew.find(strx))!=-1){//如果当前字符串中有这个可改变的部分
				strnew.replace(strnew.find(strx),strx.size(),stry);//从这部分的起始位出发，把整个部分换成要变的部分
				if(vis.find(strnew)==vis.end()){//集合中原来没有这个字符串
					vis.insert(strnew);//放进去
					node newpush;//准备入队
					newpush.s=strnew;//赋值
					newpush.step=stepnew+1;//多一步了
					if(strnew==b){//已经得到答案了
						cout<<stepnew+1<<endl;//直接输出
						return;
					}
					else q.push(newpush);//入队
				}
			}
		}
	}
	cout<<"NO ANSWER!"<<endl;//循环跑完了，说明找不到答案
	return;
}
int main(){
	cin>>a>>b;
	string x,y;
	while(cin>>x>>y)
		m[x]=y;//保存规则
	node z;
	z.step=0;z.s=a;//一开始是0步
	q.push(z);//初始入队
	vis.insert(a);//放到集合里
	bfs();//进行宽搜
	return 0;
}
```

是不是看上去挺好的？~~但只有60分~~

下载数据，你会发现：原来一个部分可能可以有多种情况可以变化！！！

举个~~栗子~~例子：

y abc

y d

那么，由于我们采用下标方式赋值，map[y]就会与最后一个读入的值相同，即map[y]=d;

而如果用insert赋值，map[y]就会与第一个读入的值相同，即map[y]=abc

然后就······~~没有办法了~~

~~STL真是一项伟大的发明！~~

除了map，还有——multimap

它支持映射多个值，跟上面对比起来看

y abc

y d

那么y就既可以等于abc，又可以等于d

~~我一开始见到multimap还认为为什么有人这么傻不想要自动去重~~

但这时候就不支持下标赋值了，只能用insert~~不然不能显出其特殊之处~~

但在遍历时，认为map<y,abc>与map<y,d>是分开的，遍历方式是一样的

于是修改部分代码：
```cpp
	multimap<string,string> m;
	multimap<string,string>::iterator it;
        ······
	string x,y;
	while(cin>>x>>y)
	m.insert(make_pair(x,y));
```

（注：头文件还是map）


然而······还是WA了

继续下载数据，发现：一个字符串里可能有多个相同的部分可以变换！而如果用find函数，只能找出一个

于是——两重循环暴力走起！

~~暴力大法好！幸好出题人十分有良心没有出大数据~~

再次改动部分代码：

```cpp
	if(strx.size()>strnew.size())continue;//防止负数，不然莫名其妙错，我也不知道为什么（在exe里就会错）
	for(int i=0;i<=strnew.size()-strx.size();i++){
				string strnew=x;//上面其实已经赋过一遍值了，变量名也是一样的
				string strx=it->first;//此处还是为了避免值被改掉
				string stry=it->second;
				int stepnew=y;
				bool flag=true;//标记
				for(int j=0;j<strx.size();j++)
					if(strx[j]!=strnew[i+j]){//两者有不一样之处，说明不能变
						flag=false;
						break;
					}
				 if(flag==false)continue;//判断条件成立就得用大括号把下面整个部分包起来，当时懒得写了
				 ······	
}
```
然后这道题才算完~~真是毒瘤啊，为什么不评个蓝题~~


最后给大家完整AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<map>
#include<string>
#include<set>
using namespace std;
struct node{
	string s;
	int step;
};
queue<node> q;
string a,b;
multimap<string,string> m;
multimap<string,string>::iterator it;
set<string> vis;
void bfs(){
	while(!q.empty()){
		node z=q.front();
		q.pop();
		string x=z.s;
		int y=z.step;
		if(y>10){
			cout<<"NO ANSWER!"<<endl;
			return;
		}
		for(it=m.begin();it!=m.end();it++){
			string strnew=x;
			string strx=it->first;
			string stry=it->second;
			int stepnew=y;
			if(strx.size()>strnew.size())continue;
			for(int i=0;i<=strnew.size()-strx.size();i++){
				string strnew=x;
				string strx=it->first;
				string stry=it->second;
				int stepnew=y;
				bool flag=true;
				for(int j=0;j<strx.size();j++)
					if(strx[j]!=strnew[i+j]){
						flag=false;
						break;
					}
				if(flag==false)continue;
				strnew.replace(i,strx.size(),stry);
				if(vis.find(strnew)==vis.end()){
					vis.insert(strnew);
					node newpush;
					newpush.s=strnew;
					newpush.step=stepnew+1;
					if(strnew==b){
						cout<<stepnew+1<<endl;
						return;
					}
					else q.push(newpush);
				}
			}
		}
	}
	cout<<"NO ANSWER!"<<endl;
	return;
}
int main(){
	cin>>a>>b;
	string x,y;
	while(cin>>x>>y)
	m.insert(make_pair(x,y));
	node z;
	z.step=0;z.s=a;
	q.push(z);
	vis.insert(a);
	bfs();
	return 0;
}
```
大部分代码都与第一份差不多，故不再重写注释，望谅解~~主要是打了这么多字受累了~~

累死我了，客官不点个赞？


---

## 作者：小叶同学 (赞：12)

    
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<map>
using namespace std;
const int N=1005;
map<string,int>zt;//记录状态 
queue<string>que;//维护bfs 
string st,ed,x[N],y[N];
int tot=1,ans;//tot记录转换方案 
bool eq(string s,int be,int to){//判断是否相同 
    string &tmp=x[to];//&为了方便 
    if(s.size()-be+1<x[to].size())return false;
    for(int i=be;i-be<tmp.size();i++){
        if(s[i]!=tmp[i-be])return false;
    }
    return true;
}
string change(string s,int be,int to){//change 
    if(eq(s,be,to)){
        string neww=s.substr(0,be)+y[to]+s.substr(x[to].size()+be,s.size());
        return neww;//substr将s的0~be给neww 
    }
    else return "";
}
int bfs(){
    que.push(st);zt[st]=0;
    while(!que.empty()){
        string now=que.front();que.pop();
        for(int i=0;i<now.size();i++){
            for(int j=1;j<=tot;j++){
                string neww=change(now,i,j);
                if(neww=="")continue;
                if(zt.count(neww))continue;
                if(zt[now]+1>10)continue;
                que.push(neww),zt[neww]=zt[now]+1;
                if(neww==ed)return zt[now]+1;
            }
        }
    }
    return 0;
}
int main(){
    //freopen("zfc.in","r",stdin);
    //freopen("zfc.out","w",stdout);
    cin>>st>>ed;
    while(cin>>x[tot]>>y[tot]){
        tot++;
    }tot--;
    ans=bfs();
    if(!ans)printf("NO ANSWER!");
    else printf("%d",ans);
    return 0;
}
```

---

## 作者：时律 (赞：7)

此题是一道非常好的BFS练手题qwq

只是坑非常多……

~~还好数据量小，否则会炸~~

至于解释放代码里吧:

```
#include<bits/stdc++.h>
using namespace std;
struct data{
	string a;
	int ans;
};
queue<data> q;//BFS队列
string x[15],y[15];
map<string,bool> h;//用map当哈希表
int main()
{
	int u=1;
	string a,b;
	cin>>a>>b;
	while(cin>>x[u]>>y[u])
		u++;
	u--;
	q.push(data{a,0});
	while(!q.empty())//以下为标准的BFS模板
	{
		data s=q.front();
		if(s.ans==11)//如果超过10直接跳出输出NO ANSWER!
			break;
		if(s.a==b)//找到答案即输出
		{
			printf("%d",s.ans);
			return 0;
		}
		for(int i=1,v=0;i<=u;i++,v=0)
			while(s.a.find(x[i],v)!=-1)//被坑了，不能只找一次，可能有多个相同的子串……应在找到一个后往后面继续找
			{
				string w=s.a;
				int m=s.a.find(x[i],v);
				w.replace(m,x[i].size(),y[i]);
				if(h[w]==0)//哈希表，不开最后一个点MLE
					q.push(data{w,s.ans+1}),h[w]=1;
				v=m+x[i].size();//记录继续查找的位置
			}
		q.pop();
	}
	printf("NO ANSWER!");
}
```

~~请不要嘲讽我的毒瘤码风~~

---

## 作者：Vic_ (赞：7)

**STL大法好**

**STL大法好**

**STL大法好**

c++是一个非常优秀（好用）的IDE

其中的STL库便是为c++一强大的功能

其中包括vector，list，string，set等数据结构类型，可以解决大部分问题

它在让代码变短变简洁的同时，但也会使速度有所牺牲，所以请选手慎用

其中动态数组（vector）也更是传说中的普及组一等奖保分神器

此题用到的数据结构是map和string，map用于hash，string用来处理

关于string的介绍这里有一个非常全面的博客http://www.cnblogs.com/xFreedom/archive/2011/05/16/2048037.html

接下来是代码

```cpp
#include<bits/stdc++.h>//万能库
using namespace std;
string s,e;
map<string,int>Has;//hash这个变量在luogu编译时会被和谐
string a[11],b[11];
int la[11],lb[11];
int n=1;
int mx=0,mn=0;
void dfs(string x,int step)//深搜
{
    if(step>=10)return;
    int v=x.size(),p=e.size();
    if(v+mx*(10-step)<p)return;//可行性优化，加最大的也加不满
    if(v+mn*(10-step)>p)return;//可行性优化，加最小的也加不下
    step++;
    for(int i=1;i<=n;i++)
    {
        int pos=x.find(a[i],0);
        while(pos!=string::npos)//这里是不断查找a[i]在x中的位置，查找不到返回string::npos
        {
            string tmp=x;
            tmp.replace(pos,la[i],b[i]);//string的替换函数，详情见博客
            if((Has[tmp]==0&&tmp!=s)||Has[tmp]>Has[x]+1)
                Has[tmp]=Has[x]+1,dfs(tmp,step);
            pos=x.find(a[i],pos+1);
        }
    }
}
int main()
{
    cin>>s>>e;
    while(cin>>a[n]>>b[n])
    {
        la[n]=a[n].size();
        lb[n]=b[n].size();
        mn=min(mn,lb[n]-la[n]);
        mx=max(mx,lb[n]-la[n]);//得到最大最小值，用于dfs优化
        n++;
        if(n==7)break;
    }
    n--;
    dfs(s,0);
    if(Has[e]!=0)cout<<Has[e];
    else cout<<"NO ANSWER!";
}
```

---

## 作者：DuanYuFi (赞：6)

退役前最后一篇题解，希望可以通过

由于这道题不知道WA了几次了，对一些低$(ruo)$级$(zhi)$错误感触深刻。

这道题要用$bfs$不用$dfs$，首先是因为这道题规定了搜索层数，所以比较显然的可以看出来。

其次，由于本题的字符串变换会出现死循环，用$dfs$的话在死循环中要一直判断到层数大于$10$才可以抛弃这种方案（死循环的方案），而$bfs$遵循“众方案平等”的原则，在走死循环的同时，不妨碍计算正确方案。

并且，$dfs$搜到一种可行解时不能保证最优（即使用可行性剪枝、最优性剪枝也没办法解决死循环问题），而$bfs$可以迅速找到最优解并及时返回，这也是本题用$bfs$的一个重要原因。

开始讲解本题需要用的知识点：

    1. 查找字符串匹配用到了kmp算法。
    2. bfs要用到STL的队列，也可以配合STL的pair使用。
    3. 队列中去重用到STL中的map，也可以用字符串哈希。（Pascal党已哭）（致敬Pascal党）

对于给定的状态，要经过多次变换得到最终状态，首先要做的就是找到初始状态下所有的可变换字串，此处可枚举每一种转化方案，用kmp来查询~~（AC自动机更好但我不会）~~，具体可参考[P3375【模板KMP】](https://www.luogu.org/problemnew/show/P3375)。


```cpp
int kmp(string A, string B, int *format) {			//find B from A
	int pre[maxm] = {0}, cnt = 0;
	int la = A.size(), lb = B.size();
	pre[0] = pre[1] = 0;
	FOR(i,1,lb - 1) {
		int j = pre[i];
		while(j && B[i] != B[j])	j = pre[j];
		if(B[i] == B[j])	pre[i + 1] = j + 1;
	}
	int j = 0;
	FOR(i,0,la - 1) {
		while(j && A[i] != B[j])	j = pre[j];
		if(A[i] == B[j])	j ++;
		if(j == lb) {
			format[++cnt] = i - j + 1;
		}
	}
	return cnt;
}

```

其中$A$为文本串，$B$为模板串。

此处我在函数参数里面加入了“$format$”数组，用来存所有可匹配位置，函数返回值为可匹配位置总数。

得到了所有的可匹配位置，就可以进行替换了。将替换后的$string$字符串加入队列中，并记录转移次数。

其实有个优化：如果当前串已经转移了九次，那么无需将转化后的串放入队列，因为转移第十次后依然不能得到目标串就应该抛弃这种方案。同样，对于每一个串的转移，可以在放入队列前先判断转移后的串是不是目标串，如果是可以直接$return$。这样可以减小内存消耗~~（我并没有用这种优化）~~

由于转移过程中会出现很多重复串，不仅消耗大量时间还消耗大量空间，可以用$map$记录所有$bfs$过的子串，筛去重复的串。

对于得不到答案的状态：队列为空。即所有情况均考虑过都不能得到目标串。（因为如果有满足条件的串当场就会$return$，而且有了上面的优化，队列中不存在转移次数大于$10$次的串）

附上代码（为了防复制所以代码有一处错误，但不影响参考）

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <algorithm>
#include <map>
#include <queue>
#define FOR(i,a,b)	for(int i=a;i<=b;i++)
#define FOR2(i,a,b)	for(int i=a;i>=b;i--)
#define LL long long int
#define ULL unsigned long long int
using namespace std;
template <typename T>
inline void readin(T &x) {
	bool f = false; x = 0;
	char ch = getchar();
	while(!isdigit(ch)) {
		if(ch == '-')	f = 1;
		ch = getchar();
	}
	while(isdigit(ch)) {
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	if(f)	x = -x;
}

const int maxn = 8;
const int maxm = 50;
const ULL prime = 13331;
const int inf = 0x7f7f7f7f;

string st, aim, a[maxn], b[maxn];
map <string, bool> check;

int ans, n = 1;

int kmp(string A, string B, int *format) {			//find B from A
	int pre[maxm] = {0}, cnt = 0;
	int la = A.size(), lb = B.size();
	pre[0] = pre[1] = 0;
	FOR(i,1,lb - 1) {
		int j = pre[i];
		while(j && B[i] != B[j])	j = pre[j];
		if(B[i] == B[j])	pre[i + 1] = j + 1;
	}
	int j = 0;
	FOR(i,0,la - 1) {
		while(j && A[i] != B[j])	j = pre[j];
		if(A[i] == B[j])	j ++;
		if(j == lb) {
			format[++cnt] = i - j + 1;
		}
	}
	return cnt;
}

int bfs(string st) {
	queue <pair<string, int> > sp;
	sp.push(make_pair(st, 0));
	check[st] = 1;
	while(!sp.empty()) {
		pair <string, int> x = sp.front();	sp.pop();
		string s = x.first;
		if(x.second > 10)	return -1;
		if(s == aim)	return x.second;
		FOR(i,1,n) {
			int la = a[i].size(), lb = b[i].size(), ls = s.size();
			int format[maxm], cnt = kmp(s, a[i], format);
			if(!cnt)	continue;
			FOR(w,1,cnt) {
				int point1 = 0;
				string now;
				FOR(j,0,format[w]-1) {
					now.push_back(s[point1]);
					point1 ++;
				}
				point1 += la;
				FOR(j,0,lb - 1) {
					now.push_back(b[i][j]);
				}
				for(; point1 < ls; point1 ++) {
					now.push_back(s[point1]);
				}
				if(!check[now]) {
					check[now] = 1;
					sp.push(make_pair(now, x.second + 1));
				}
			}		
		}
	}
}

int main() {
	cin >> st >> aim;
	while(cin >> a[n] >> b[n])	n ++;
	n --;
	ans = bfs(st);
	if(ans == -1)	printf("NO ANSWER!");
	else printf("%d", ans);
	return 0;
}
```

---

## 作者：风随逐影 (赞：5)

## 迭代加深+剪枝

~~如果不加剪枝的话只有80分~~

看到变化次数不超过十想到迭代加深，但如果不加“在同一步数搜到相同的字符串就不能再搜”的剪枝是不能过的。

所以选择用map标记重复的，但迭代加深的话map需要清0，不能用memset，所以我选择每次新建一个map来交换

速度很快，最慢的点用了40ms

```c
//剪枝：如果搜到相同的就不在搜了 
#include<bits/stdc++.h>
using namespace std;

#define go(i,a,b) for(int i=a;i<=b;++i)
#define com(i,a,b) for(int i=a;i>=b;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#define mp make_pair

typedef pair<string,short>pai;
const int inf=0x3f3f3f3f,N=10010;

int dep=0,n=1;
string A,B;
string a[N],b[N];
map<pai,bool>vis;

bool dfs(int now){
	if(now>dep) return 0;
	if(A==B) return 1;
	if(vis.count(mp(A,now))) return 0;
	vis[mp(A,now)]=1;
	string tmp=A;
	string x;
	go(i,1,n){
		unsigned int pos,np;
		if((pos=A.find(a[i]))==string::npos) continue;
		for(;pos<A.size();pos=np){
			x=A.substr(0,pos);
			x+=b[i];
			x+=A.substr(pos+a[i].size());
			A=x;
			if(dfs(now+1)) return 1;
			A=tmp;
			np=A.find(a[i],pos+a[i].size());
		}
	}
	return 0;
}

int main(){
	//freopen("input.txt","r",stdin);
	cin>>A>>B;
	while(cin>>a[n]>>b[n]) ++n;
	--n;
	while(!dfs(0)&&dep<=10){
		map<pai,bool>_new;
		swap(_new,vis);
		++dep;
	}
	if(dep<=10) cout<<dep;
	else puts("NO ANSWER!");
	return 0;
}
```


---

## 作者：lei_yu (赞：5)

# 这个题对我满满的恶意
## 1.数组大小
首先，如果你的队列没有用STL，把数组开大一点，否则最后两个点会RE，我在这里炸了很久。

（我开的10万）
 
##  2.标记

 其次，需要另外开一个map来记录这个字符串是否被找到过，否则最后两个点会超时。

（大佬们都说过了）
## 3.方法

最后这个题一看就是广搜，然而是搜索字符串，对于我这种蒟蒻很有锻炼意义，对于字符串的操作，前排有大佬都说得很清楚。

（不愧是一道绿题）

###### 接下来是关于我的代码的
## 4.变量解释
### (1)全局变量
#### string:
a是原本的字符串，b是要变成的字符串，qs是字符串队列，sa和sb是变换规则：sa[i]换成sb[i]；
#### int
qb是存改变次数的队列，因为类型不同不能直接开二维,head是队列头,tail是队列尾,len是变换规则的数量 ；
#### map
建立了一种映射关系用一个数组bb来表示string字符串具体请看各位巨佬的博客们，相信你能够理解=w=
### (2)主函数
num:存最少的变化次数
### (3)bfs函数
s:存头指针指着的字符串

ss:存变化之后的字符串


## 5.代码

具体的思想和方法请看我的代码以及注释（很友好的）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>//使用map需要使用的头文件 
using namespace std;
map<string,int> bb;
string a,b,sa[100],sb[100],qs[100000];
int qb[100000],head,tail,len;//不再一次解释了 
int bfs()
{
	string s,ss;
	while(head<=tail&&qs[head]!=b&&qb[head]<=10)//队列非空+队头还不是答案+队头的操作数不小于10 
	{
		if(bb[qs[head]])//如果当前字符串已经搜索过了 
		{
			head++;
			continue;
	        }
	bb[qs[head]]=1;//标记当前字符串 
	for(int i=1;i<=len;i++)//每一种变化方法都需要枚举 
	{
		s=qs[head]; 
		while(1==1)//这里一直循环，接着看 
		{
			int f=s.find(sa[i]);//使用find函数找到sa[i]在s中第一次出现的位置，如果没有出现，则会返回-1 
			if(f==-1)break;//如果找不到了就结束循环 
			ss=qs[head];
            ss.replace(f,sa[i].size(),sb[i]);//使用replace替换：将ss字符串从f开始往后到sa[i]长度的一部分替换成sb[i] 
            qs[++tail]=ss;//放进队尾 
            qb[tail]=qb[head]+1;
            s[f]='%'; //将原来的字符串f位置替换成一个输入不会出现的字符，就不会再找到这个地方了 
		}
	}
	head++;//每一次头指针向前加1 
	}
	if(head>tail||qb[head]>10)return -1;//如果最后队列为空则是没有找到，或者队头的替换次数都超过了10，就没有答案 
	else return qb[head];//要不然就返回队头的替换次数 
} 
int main()
{
	cin>>a>>b;//输入最原始的字符串和要改成的字符串 
	len=1;//len是输入的变换规则，从1开始存 
    while(cin>>sa[len]>>sb[len])len++;//这玩意只能文件输入输出，也就是说你不能调试.. 
    len--;//while在最后时多加了1 
	qs[1]=a;
	qb[1]=0;//初始化队列,将原始字符串放在队头 
	head=1;
	tail=1;
	int sum=bfs();//开始广搜 
	if(sum==-1)cout<<"NO ANSWER!";//输出答案 
	else cout<<sum;
} 
```



------------
吐槽：

~~说真的，为什么这道题会放在普及训练场里面~~

~~看我打了这么多的份上，管理员大大审核过掉吧ლ(′◉❥◉｀ლ)~~

~~求点赞~~

---

## 作者：sram (赞：5)

感觉这个题用一些常用的stl和string函数会非常简单。。（难道就是考这两个的吗？

```cpp
vector<pair<string,string>>pos//用于变化
map<string,int>bj//用于判重
```

然后字串变化操作用 string的find+substr函数就可以解决
贴一下代码
```cpp
#include<bits/stdc++.h>

#define rep(a,b,c) for(int a=b;a<=c;a++)
#define per(i,n,a) for (int i=n;i>=a;i--)
#define PII pair<int,int>
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
vector<pair<string,string>>pos;
map<string,int>bj;
int ans=INF;
string a,b,c,d;
struct uzi
{
	string a;
	int cnt;
}j;
queue<uzi>p;
int main(){
	ios::sync_with_stdio(false);
	cin>>a>>b;
	while(cin>>c>>d){pos.push_back(pair<string,string>{c,d});}
	p.push(uzi{a,0});
	while(!p.empty()){
		j=p.front();
		p.pop();
		if(j.a==b){
			ans=min(ans,j.cnt);//找到就直接判断
			if(ans>10){
				cout<<"NO ANSWER!";
				return 0;
			}else {
				cout<<ans;
				return 0;
			}
		}
		for(auto k: pos){
			string pp=j.a,pa;
			int t=pp.find(k.first);//找位置
			while(t!=pp.npos){
				pa=pp.substr(0,t);//接
				pa=pa+k.second;//还是接
				int ka=0;
				pa+=pp.substr(t+k.first.size());接上去
				if(j.cnt+1<bj[pa]||bj[pa]==0)
					{p.push(uzi{pa,j.cnt+1});bj[pa]=j.cnt+1;}
				t=pp.find(k.first,t+1);//遍历每一个可能的位置
			}	
		}
	}
	cout<<"NO ANSWER!";
	return 0;
}
```

---

## 作者：jk17211805 (赞：5)

第一次写的题解没有过，希望这次能过

做这个题，首先要想好怎么存储。
（1）DFS肯定要用到队列
（2）匹配关系用map来存储吗？（答案是不能，因为可能会有多个匹配问题，而map是一对一的关系，就比如说"x"->"xy","x"->"z"这两个存储关系，用map来存的话只会存储一个键为x的），我采用了结构体来存储：
```c
struct MAP
{
    string x;
    string y;
}m[55];
```
(3)标记vis数组怎么来存储，我是用map来存储的

```c
map<string,int> vis;
```

下面来说一下这个题的坑：
（1）题目没说都存的是字母，所以在更改字符串时要用一个不常见的符号。
（2）刚刚也讲到了，多重匹配的问题，不能用map来存储匹配规则。
（3）一个串中可以会满足同一个匹配规则多次，所以需要用到循环。
```
while(1)
            {
                int pos = tmp.find(itf);
                if(pos==-1)
                    break;
                tmp[pos]='?';
                //把刚刚找到的位置赋上不同的，
                //下一次就可以在用到find函数了，
                //这样保证find函数找到的位置跟之前的不同
                //但是需要注意的是不能将改变过的放入队列里面
                if(pos!=-1)
                {
                    //简单的截取字符串，拼接字符串，最好写完这一部分测试一下
                    string t = "";
                    t = now.s.substr(0, pos);
                    t += its;
                    t+=now.s.substr(pos + itf.size(), now.s.size() - pos - itf.size());
                    start.s = t;
                    start.time = now.time + 1;
                    if (vis[t]==0)
                    {
                        q.push(start);
                        vis[t]=1;
                    }
                }
            }
```
其实现在就没啥应该错的了，但是我在第一组样例上错了几次，其实第一组样例就是上面说的坑（3），如果你错了第一组样例，那就试试这一组样例
```
zxct dfrg
zx cd
zx df
fct frg
```
答案应该是二。
我错的原因就是上面代码中tmp和now.s弄混了，是这组样例调试才发现。

下面是AC代码：（C++）
```c
#include <stdio.h>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <queue>
#include<map>
#include<set>
using namespace std;
const int inf = 0x3f3f3f3f;
typedef long long ll;
const int MAXN=30000010;
int n = 0;
struct node
{
    string s;
    int time;
} start, now;
queue<node> q;
string A, B;
struct MAP
{
    string x;
    string y;
}m[55];
map<string,int> vis;
int bfs()
{
    start.s = A;
    start.time = 0;
    vis[A]=1;
    q.push(start);
    while(!q.empty())
    {
        now = q.front();
        q.pop();
        if(now.time>10)
            return -1;
        if(now.s==B)
            return now.time;
        for(int i=0;i<n;i++)
        {
            string itf = m[i].x;
            string its = m[i].y;
            string tmp=now.s;
            while(1)
            {
                int pos = tmp.find(itf);
                if(pos==-1)
                    break;
                tmp[pos]='?';
                if(pos!=-1)
                {
                    string t = "";
                    t = now.s.substr(0, pos);
                    t += its;
                    t+=now.s.substr(pos + itf.size(), now.s.size() - pos - itf.size());
                    start.s = t;
                    start.time = now.time + 1;
                    if (vis[t]==0)
                    {
                        q.push(start);
                        vis[t]=1;
                    }
                }

            }
        }
    }
    return -1;
}
int main()
{
    cin >> A >> B;
    string a, b;
    while (cin >> a >> b)
    {
        m[n].x=a;
        m[n].y=b;
        n++;

    }
    int ans=bfs();
    if(ans==-1)
        cout << "NO ANSWER!" << endl;
    else
        cout << ans << endl;
    return 0;
}

```

看到这了，点个赞呗～～


---

## 作者：0x80mem (赞：5)

用迭代加深搜索就混过去了...(数据大概有些水)

虽然算法标签为宽搜，但步数小于10的题设还是让我忍不住试一试

迭代加深搜索就是限定深搜深度，不断将范围扩大直到找到解

```
#include <cstdio>
#include <cstring>
#include <string>
#include <set>

using namespace std;

struct Pri
{
    char A[25];
    char B[25];
};

int n = 1;
int maxn;      //最大深度（名字很奇怪）
Pri P[10];
char А[25], B[25];

int mins = 11;

bool dfs(int s, char* str)
{
    //puts(str);
    if (s > maxn)            return false;//深度限制
    if (strcmp(str, B) == 0) return true; //找到解立即返回
    
    for (int i = 1; i <= n; i++)
    {
        int lΑ = strlen(P[i].А);
        int lΒ = strlen(P[i].В);
        int lS = strlen(str);
        int p, q;
        for (p = 0; p < lS; p++)
        {
            for (q = 0; q < lΑ; q++)
                if (str[p + q] != P[i].A[q])
                    break;
            if (q == lA)
            {
            	char tmp[500];
            	int k = 0;
            	for (int j = 0; j < p && k < 500; j++)       tmp[k++] = str[j];
            	for (int j = p; j < p + lB && k < 500; j++)  tmp[k++] = P[i].B[j - p];
            	for (int j = p + lA; j < lS && k < 500; j++) tmp[k++] = str[j];
            	if (k != 500)
            	{
                	tmp[k] = '\0';
                	if (dfs(s + 1, tmp)) return true; //找到解立即返回
                }
            }
    	}
    }
    return false;
}

int main()
{
    scanf("%s%s", A, B);
    for(; scanf("%s%s", P[n].Α, P[n].В) > 0; n++){}
    n--;
    
    for (maxn = 1; maxn <= 10; maxn++)//不断加大深度
    {
        if(dfs(0, A))  //找到后输出答案
        {
            printf("%d\n", maxn);
            return 0;
        }
    }
    
    printf("NO ANSWER!");
    return 0;
}
```

---

## 作者：Jμdge (赞：3)

这道题？ 果断迭代加深 搜索。


复杂度？ O(能过)

毕竟这 步数限制摆在那里，随便算算能过的（不开O2 800ms+）。

其实主要就是要讲讲迭代加深搜索。

其实这玩意儿很简单，看到步数限制 10~20 的差不多就可以迭代加深（当然是步数限制不是数据范围限制，数据这范围的话大概就是状压了）。

然后愉快敲起代码，超级暴力。

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
string X,Y,A[9],B[9]; int n,ans;
inline string trans(const string& str,int i,int j){
	static string ans; ans="";
	if(i+A[j].length()>str.length()) return ans;
	for(int k=0,mx=A[j].length();k<mx;++k)
		if(str[i+k]!=A[j][k]) return ans;
	ans=str.substr(0,i),ans+=B[j];
	return ans+str.substr(i+A[j].length());
}
inline string check(const string& str,int i,int j){
	static string ans; ans="";
	if(i+A[j].length()>str.length()) return ans;
	for(int k=0,mx=A[j].length();k<mx;++k)
		if(str[i+k]!=A[j][k]) return ans;
	ans=str.substr(0,i),ans+=B[j];
	return ans+str.substr(i+A[j].length());
}
inline bool dfs(string& now,int stp){ //管他重复不重复，一路搜。（当然你也可以自己加剪枝之类的优化）
	if(now==Y) return 1;
	if(stp>ans) return 0; string tmp;
	for(int i=0,mx=now.length();i<n;++i)
		for(int j=0;j<mx;++j){
			tmp=check(now,j,i);
			if(tmp!=""&&dfs(tmp,stp+1)) return 1;
		} return 0;
}
int main(){
	ios::sync_with_stdio(false),cin>>X>>Y;
	while(cin>>A[n]>>B[n]) ++n;
	for(ans=1;ans<=10;++ans)
		if(dfs(X,1)) return !printf("%d\n",ans);
	return !puts("NO ANSWER!");
}
```

---

## 作者：Mitch谜团 (赞：2)

一道简（du）单（liu）的bfs。   
思路十分简（yun）洁（tou）明（zhuan）了（xiang ）：   
```
1，定义一个结构体队列duilie[2000000]，用来存储所有可能的字符串以及它们所需要的步数
2，定义另一个结构体数组bh[10]，用来存储移动规则
3，输入原字符串a和目标字符串b
4，输入变化规则，存入bh
5，将a入队列
6，对当前队首元素temp（从a开始）：
7，    将其出队列
8，    遍历bh，找出所有temp能变成的字符串，全部存入队列中，并记录层次
9，    如temp变的字符串或它自己中有b，则输出它的层次
10，   如层次>10或队列为空，输出“NO ANSWER！”
11，   否则，回到步骤6
```
对应的，我们就可以很容易地写出代码了（内附详细注释）：
```
#include <iostream>
#include <string> 
#include <cstring>
using namespace std;
struct rule//用于存储变化规则的结构体
{
	string first,second;
}bh[10];
struct guangsou//用于存储字符串的队列
{
	string x;//字符串
	int pos;//字符串的层次（也就是所需的步数）
}duilie[2000000];注意，一定要把数组开到两百万！不然最后一个点会RE！
string a,b;//起始串和目标串
int head=0,end=1;//队列的头和尾
string tihuan(string a,int pos,string b1,string b2)//手写替换函数，为的是不改变原本的字符串
{
	return a.replace(pos,b1.length(),b2);//灰常高端大气上档次的replace函数，用法自己搜
}
void bfs(string s1, string s2, int n)//广搜函数，参数分别是起始串和目标串以及变化规则的数量
{
	duilie[end].x=s1;//把队列的第一个元素设为起始串
	duilie[end].pos=0;//起始串层次为零
	if(s1==s2){cout<<0;return;}//特判，如果起始串和目标串一样则直接输出零
	else//否则
	{
		while(duilie[end].pos<=10&&head<end)//如果如层次<10且队列不为空
		{
			head++;//弹出队首元素
			for(int i=1;i<=n;i++)//遍历bh
			{
				string::size_type id;//变量id用于记录被弹出的队首元素中是否有bh[i].first（不懂得自己看上面的rule结构体）
				string temp=duilie[head].x;//为了防止改变队首元素，用temp来暂时存储它
				id=temp.find(bh[i].first);//如果找到了则id=bh[i].first的起始坐标，否则id=string::npos
				while(id!=string::npos)//如果找到了
				{
					
					end++;//向队尾插入一个元素
					duilie[end].x=tihuan(duilie[head].x,id,bh[i].first,bh[i].second);//将队尾元素赋值为将队首元素中的bh[i].first替换为bh[i].second后的字符串
					duilie[end].pos=duilie[head].pos+1;//队尾元素步数=队首元素步数+1
					if(duilie[end].x==s2){cout<<duilie[end].pos;return;}//如果队尾元素=b的话，则输出它的步数，结束程序
					temp.replace(id,bh[i].first.length(),"~");//将temp中原来bh[i].first的位置替换为占位用的“~”，这样才可以继续往下找temp中其它的bh[i].first
					id=temp.find(bh[i].first);//重新寻找一次，然后回到while循环开始
				} 
			}
		}
		cout<<"NO ANSWER!";//如果步数超过了十，或者队列为空了就输出“NO ANSWER！”
		return;//结束
	}
}
int main()
{
	int i=1;
	cin>>a>>b;//输入a和b
	while(cin>>bh[i].first>>bh[i].second){i++;}//输入所有的变化规则
	bfs(a,b,i-1);//广搜
	return 0;//结束程序
}
```
总结：此题思维难度不（ju）大（da），只要了解广搜原理的人都不难做出来，所以大伙儿加油吧！

---

## 作者：Ajwallet (赞：2)

# KMP字符串模式匹配
~~其实可以用AC自动机~~

这道题是问我们最小步数，因为其分支不大（$\leq7$）容易想到专门处理最优化问题的$bfs$算法

在$bfs$的匹配中，本人采用的是用字符数组模拟字符串中的运算，建立新的“$String$”，然后在匹配过程中，使用$KMP$实现，对于判重，使用$hash+map$

# 代码
```cpp
#include<map>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;char a[7][21],b[7][21];//转换规则串
const int base=233;//hash值
int n,ans,kmp[21];
unsigned long long zd;//目标串的hash值
map<unsigned long long,bool>m;//map库
struct String//定义一种结构体
{
    char c[101];//字符串
    int next[101],bs;//kmp_next数组,bs表示当前步数
    inline int size(){return strlen(c);}//长度
    inline void read(){scanf("%s",c);return;}//输入
    inline void build()//建立next数组
    {
        next[0]=-1;
        int j=-1;
        for(register int i=1;i<strlen(c);i++)
        {
            while(j>-1&&c[j+1]!=c[i]) j=next[j];
            if(c[j+1]==c[i]) j++;
            next[i]=j;
        }
        return;
    }
    inline int find(char s[])//查找s在c中出现的所有位置，并返回子串个数，复杂度n+m
    {
        int j=-1,len=0;
        for(register int i=0;i<strlen(c);i++)
        {
            while(j>-1&&s[j+1]!=c[i]) j=next[j];
            if(s[j+1]==c[i]) j++;
            if(j==strlen(s)-1) kmp[++len]=i-j,j=0;
        }
        return len;
    }
    inline unsigned long long hash()//自然溢出求hash值
    {
        unsigned long long ans=0;
        for(register int i=0;i<strlen(c);i++)ans=ans*base+c[i];
        return ans;
    }
}Begin,End;//定义起始串和目标串
inline int bfs()
{
    queue<String>q;//建立元素为结构体的队列，方便转移
    q.push(Begin);//放入
    while(q.size())
    {
        String x=q.front();x.build();q.pop();//取出并求出next数组
        if(x.bs==10) continue;//超出步数不管它
        for(register int i=0;i<n;i++)
        {
        	
            int len=x.find(a[i]),lena=strlen(a[i]),lenb=strlen(b[i]);
            if(!len) continue;//没有匹配串退出
            for(register int cs=1;cs<=len;cs++)
            {
            	String y=x;
            	y.bs=x.bs+1;//bs多了一步
            	int t=kmp[cs];//取出位置
            	if(lena==lenb)for(register int j=t;j<t+lena;j++) y.c[j]=b[i][j-t];//长度相同直接赋值
            	if(lena<lenb)//长度将变长
            	{
                    for(register int k=1;k<=lenb-lena;k++)
	                for(register int j=y.size()+(lenb-lena)-1;j>=t+lena;j--) 
	                y.c[j]=y.c[j-(lenb-lena)];//将后面的往前挪长度差次
	                for(register int j=t;j<t+lenb;j++) y.c[j]=b[i][j-t];//转换
	            }
	            if(lena>lenb)//长度将变短
	            {
	                for(register int j=t;j<t+lenb;j++) y.c[j]=b[i][j-t];//转换
	                for(register int k=1;k<=lena-lenb;k++)
	                for(register int j=t+lenb;j<y.size();j++) y.c[j]=y.c[j+1];//将前面的往后挪长度差位
	            }
	            unsigned long long hh=y.hash();//计算hash值
	            if(hh==zd) return y.bs;//到达终点，返回步数
	            if(m.find(hh)==m.end()) q.push(y),m[hh]=true;//若没有出现过，将其入队
	        }
	    }
    }
    return -1;
}
signed main()
{
    Begin.read();End.read();zd=End.hash();//输入
    while(scanf("%s %s",a[n],b[n])!=EOF)n++;//输入
    ans=bfs();//bfs
    if(ans<0) printf("NO ANSWER!");
    else printf("%d",ans);//输出
}
```

---

## 作者：qr的小迷妹 (赞：2)

这题用广搜来做，字符串aa为起点，目标为bb，每次判断aa中可以被替换的子串，存到队列尾。要判断替换后的字符串是否出现过（否则会TLE）。还有就是替换子串了（用delete和insert）。判断过程中如果变化次数已经到11而且还未转化成bb那么可以直接输出'NO ANSWER!'。还有h（队列）数组范围，一开始只开了0..1000就RE了……最多10步所以略开大一点（可以自己举一个变化10次的例子试一下要开多大数组才不会201）。

代码如下：

```pascal

var m,aa,bb,s:string;
    t,w,i,j,k,n:longint;
    a,b:array[1..10]of string;
    h:array[0..10000]of string;
    ans:array[0..10000]of longint;
function had:boolean;//判断这种情况是否出现过
var i:longint;
 begin
  for i:=1 to w do
   if h[i]=m then exit(false);
  exit(true);
 end;
procedure find(x,y:string;k:longint);//寻找该字符串中是否有可替换的子串
var i:longint;mm:string;
 begin
  i:=1;
  while i<=length(y) do
   begin
    if y[i]=x[1] then//如果开头一样再考虑是否包含该子串
    begin
     mm:=copy(y,i,length(x));
     if mm=x then
      begin
       m:=y;
       delete(m,i,length(x));//删除
       insert(b[k],m,i);//插入
       if had then//如果该情况是第一次出现
               begin
                inc(w);
                h[w]:=m;//增加一个队列尾
                ans[w]:=ans[t]+1;//变化次数+1
                if h[w]=bb then
                 if ans[w]<=10 then 
                  begin write(ans[w]);halt;end;//宽搜一旦搜到就是最优解
                if ans[w]>11 then begin write('NO ANSWER!');halt;end;//剪枝
               end;
      end;
     end;
    inc(i);//字符串中可能包含多个相同子串
   end;
 end;

begin
 readln(s);
 i:=1;
 while s[i]<>' ' do
  begin
   aa:=aa+s[i];
   inc(i);
  end;
 delete(s,1,i);
 bb:=s;
 if aa=bb then begin write(0);halt;end;
 while not eoln do
  begin
   readln(s);
   inc(n);
   i:=1;
   while s[i]<>' ' do
    begin
     a[n]:=a[n]+s[i];
     inc(i);
    end;
   delete(s,1,i);
   b[n]:=s;
  end;//读入
 t:=1;
 w:=1;
 h[1]:=aa;//h队列
 while t<=w do//宽搜开始
  begin
   for i:=1 to n do
    find(a[i],h[t],i);//判断h[t]中是否有a[i]子串
   inc(t);
  end;
 writeln('NO ANSWER!');
end.

---

## 作者：安好 (赞：2)




    
        
        

    


```cpp
#include<string>
#include<iostream>
#include<map>
#include<queue>
using namespace std;
int i,j,n=1;
string sa,sb,bh[11][2];//string是类，第二维从1开始 
struct node{
    string s;
    int step;
};
queue<node>q;
map<string,int> visit;
void init()
{
    cin>>sa>>sb;
    while (cin>>bh[n][1]>>bh[n][2]) n++;
    n--;
}
void work()
{
    node e;//起始状态 
    e.step=0;
    e.s=sa;
    q.push(e);//把起始状态加进队列 
    while (!q.empty())
    {
        node t;
        t=q.front();//取头元素 
        q.pop(); //弹出     
        if (t.s==sb && t.step<11)//检查结果
        {
            cout<<t.step;//输出 
            return;//退出
        }
        if (visit[t.s]==0)//判重，map的int初始值为0 
        {
            visit[t.s]=1;
            for (i=1;i<=n;i++)//对每种变换 
            {
                //cout<<"pos:"<<t.s.find(bh[i][1])<<endl;
                if (t.s.find(bh[i][1])>=0)//如果存在就继续 
                {
                    for (j=t.s.find(bh[i][1])/*第一个位置*/;j>=0/*要存在*/ && j<=t.s.size()-bh[i][1].size();/*不能超出范围*/j=t.s.find(bh[i][1],j+1)/*下一个*/)//对每个位置
                     {
                         node w;//尾元素
                        w=t;
                        w.step++;//增加变换次数 
                        w.s.replace(j,bh[i][1].size(),bh[i][2]);//替换 
                        q.push(w);//入队 
                    }
                }
            }
        }
    }
    cout<<"NO ANSWER!";    
}
int main()
{
    init();
    work();
    return 0;
}
```

---

## 作者：Steam (赞：2)

此题的大概做法就是BFS，但是单向的BFS存在很多的不足看这个例子：

aaaaaaaaaa  aaaaaaaaac

a b
b d
d f
f e
e g
g c
虽然答案只有6，但是会出现大量不必要的情况被记录下来，于是时间和空间就都爆掉了……


所以需要采用双向的BFS：

从初始字符串和目标字符串同时进行BFS

只要在两个BFS的队列中出现相同的字符串，就可以理解为找到一条成功的方案来达成目标了，输出的答案为从初始字符串到这个字符串的交换次数+目标字符串到这个字符串的交换次数


---

## 作者：神之蒟蒻xyk (赞：2)

### **这是一道比较烦的宽搜题**
------------
	题目给的非常好理解，求最优解。
    于是。。。
    ~~bfs大法好啊~~
   刚开始做到时候第五个点一直错，发现忽略的判重问题。
   
   ~~于是就开始了无尽的超时生涯~~
   
   判重后的dfs会有很多冗余计算，eg：
   
   abaabd bbbbbd
   
   a b
   
   进队顺序：	bbaabd，abbabd, ababbd,  _bbbabd,bbbabd_ ……
   
   例如上例的最后两个入队字符串，出现一样的，存在冗余计算。
   
   于是。。。STL大法造福全人类。
   
   用map记录某一字符串是否入队过，若true ， 则不再入队。
   
   蒟蒻代码奉上（其中有一些非常神奇的常数优化）：
   
   ```cpp
#include<bits/stdc++.h>
#define re register  
using namespace std;

string x , y , a[10],b[10] , t1 , t;
int k;
int l;
queue<string> q1;
queue<int> q2;
map<string , bool> m;  //map记录是否入过队

inline bool work(int p) //判断是否能进行当前操作
{
	    bool f = true , f1 = false;
	    int a1 = k , a2 = 0 , pos;
        t1 =""+q1.front();
        while(a1 <= t1.length()-1)
        {
        	if(t1[a1] == a[p][0])
        	{
        		a2 = 1;
        		f = true;
        		while(a2 <= a[p].length()-1)
        		{
        			if(t1[a2+a1] != a[p][a2])
        			{
        				f = false;
        				break;
					}
					a2 ++;
				}
				if(f == true) 
				{
					f1 = true;
					pos = a1;
					break;
				}
			}
			a1 ++;
		}
		
		if(f1 == true)
		{
        	t1.replace(pos , a[p].length() , b[p]);
        	k += a[p].length()-1;
        	return true;
        }
        else
        {
        	return false;
		}
}

int main()
{
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
    cin>>x>>y;
    l=1;
    while (cin>>a[l]>>b[l]) l++;    //读入（调试时只能使用文件）
    l--;
    q1.push(x);
    q2.push(0);
    m[x] = true;
    
    while(!q1.empty()&&q2.front() <= 10)
    {
    	t = q1.front(); 
    	k = 0;
        for(re int i = 1;  i<= l; i ++)
        {
        	if(t.length()<a[i].length()) continue;//如果长度小，则不可能
        	for(k = 0; k <= t.length()-a[i].length(); k ++)//若k以后的字符都取依然小于操作要求长度，则不可能
        	{
	            if(work(i) == true)
    	        {
    	        	if(m[t1] == true) continue;//判断是否入过队
        		    q1.push(t1);
                	q2.push(q2.front()+1);
                	m[t1] = true;
       	            if(t1 == y)
        	        {
            	        cout<<q2.back()<<endl;
                	    return 0;
   	            	}
           		}
            }
        }
        q1.pop();
        q2.pop();
    }
    cout<<"NO ANSWER!"<<endl;
    return 0;
}
```

   
   
   				
                
   				

---

## 作者：bzy369258147 (赞：2)

//暴力对这题也是不会超时的，但也没有什么意义

//所以我这用了一种 **/宏观dfs/** 的方法，极度优化了dfs的效率；->** 1ms- **





```cpp
#include<bits/stdc++.h> //万能头文件 
using namespace std;//流操作命名空间 
//有效结构体点 
struct point{
    int x;
    int y;
    int value;
};
point pt[81];//有效点的数组 
int a,n;//a ->长宽 n ->有效点个数 
int maxn;//最大值 
//宏观深度优先搜索 
void dfs(int trun,point *mapa,int sum,int index){
    //turn次数（0、1）//*mapa点状态//总和传递//选中所在点索引 
    //复制的传递数组 
    point temps[n];point now=mapa[index];
    int v=now.value;//复制所在点的值 
    for(int i=0;i<=n;i++){
        temps[i]=mapa[i];    //复制点状态数组 
    }
    temps[index].value=0;//更改点的状态 
    if(maxn<sum+v)maxn=sum+v;//判断是否更新最大值 
    for(int i=0;i<=n;i++){
        //判断点的位置是否符合要求
        //点的要求//在所在点的右下 
**        if((temps[i].x>=now.x and temps[i].y>=now.y)and (temps[i].x>=now.x and temps[i].y>=now.y) and temps[i].value){**
            dfs(trun,temps,sum+v,i);//递归 
        }
    }
    if(maxn<sum+v)maxn=sum+v;//更新最大值
    if(trun==0)dfs(1,temps,sum+v,0);//二段搜索 
    if(trun==1)if(maxn<sum+v)maxn=sum+v;//更新最大值
    return;//回归 
}
int main(){
    cin>>a;//输入长宽 
    pt[0].x=0;pt[0].y=0;pt[0].value=0;//定义原点
    //输入有效点 
    while(1){
        //x坐标//y坐标//有效值 
        int a1,a2,a3;cin>>a1>>a2>>a3;
        if(a1==0)break;//判0 
        n++;//指针＋
        //判断是否有效 
        if(a3){
            //记录有效点 
            pt[n].x=a1;pt[n].y=a2;pt[n].value=a3;
        }
    }
    /*for(int i=1;i<=a;i++){
        for(int j=1;j<=a;j++){
        bool f=false;
            for(int u=0;u<=n;u++){
                if(pt[u].x==i and pt[u].y==j){
                    cout<<pt[u].value<<" ";
                    f=true;
                }    
            }
            if(!f)cout<<"0 ";
        }
        cout<<"\n";
    }*/////--//检测输入（没用） 
    dfs(0,pt,0,0);//dfs 
    cout<<maxn;//输出最大 
    return 0;
}
```

---

## 作者：littlegagaduck (赞：1)

这道题我提供一个较为简单的做法

搜索过程查找匹配子串以及替换都由库函数完成

```
string a,b；
int c=a.find(b,2);
//在a中从位置2开始向后查找，返回子串b出现的第一个位置，如果没有找到返回-1

int p;
a.replace(p,len,b);
//在p位置开始向后len长度的子串替换为b
```
这样剩下的就只有简单的搜索了，每次暴力处理每一个变换规则，注意可能会找到多个能匹配的子串，仍然暴力尝试替换每一个位置。

我用的迭代加深dfs，相比bfs可能慢一点，但是时间上也允许的。

```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
string start,end;
int n=0;
string u[100],v[100];
int flag=0,ans=0;
void dfs(string now,int step,int h)
{
    if(flag==1)
    {
        return;
    }
	if(now==end)
	{
		ans=h;
		flag=1;
		return;
	}
	if(step>h)
	{
		return;
	}
	for(int i=1; i<=n; i++)
	{
		int c=now.find(u[i],0);
        while(c>=0&&c<now.size())
        {
            string last=now;
            now.replace(c,u[i].size(),v[i]);
			dfs(now,step+1,h);
			now=last;
            c=now.find(u[i],c+1);
        }
	}
}
int main()
{
	cin>>start>>end;
	string x,y;
	while(cin>>x>>y)
	{
		n++;
		u[n]=x;
		v[n]=y;
	}
	for(int i=1; i<=10; i++)
	{
		dfs(start,1,i);
        if(flag==1)
        {
            break;
        }
	}
	if(flag==1)
	{
		cout<<ans<<endl;
	}
	else
	{
		cout<<"NO ANSWER!";
	}
	return 0;
}
```


---

## 作者：ZHDX (赞：1)


看了很多使用队列的方案. 

这里提供的是一个双列表的. 

循环结构清晰, 适合新手学习. 

C++ 11


```cpp


#include <unordered_set>
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

string src, dst;	//原字符串 , 目标字符串

int N;	// N 条规则
vector<string> srcarr;	//每条规则 - 左边
vector<string> dstarr;	//每条规则 - 右边


const int MAXTIMES = 10;

int mintimes = 999;

unordered_set<string> searchedmap;//已出现过的情况

vector<string> lista;	//上一层留下来的列表

vector<string> listb;	//准备处理的下一层列表

void bfs()
{
	lista.push_back(src);

	string newstr;
	newstr.reserve(64);

	//达到最大层就停止搜索了
	for (int deepcount = 1; deepcount <= MAXTIMES; deepcount++)
	{
		//上一层的所有字符串 , 0层为{src} , 注意是使用string& , 如果使用 string str 那么就是复制, 消耗很大
		for (string& str : lista)
		{
			//已知有N个替换方案, 那么每个方案都试下
			for (int i = 0; i < N; i++)
			{
				size_t pos = 0;
				while (true)	//循环多个可替换部位
				{
					pos = str.find(srcarr[i], pos);
					if (pos == (size_t)-1)
						break;
					size_t endpos = pos + srcarr[i].size();


					//替换字符串
					newstr = str;
					newstr.replace(pos, srcarr[i].size(), dstarr[i]);

					if (newstr.compare(dst) == 0)
					{
						//等于目标字符串了,  那么就可以返回了.
						mintimes = deepcount;
						return;
					}

					//如果这个字符串是从来都没出现过的, 那么才添加到队列进行下一层的处理
					if (searchedmap.find(newstr) == searchedmap.end())
					{
						searchedmap.insert(newstr);
						//添加到下一层队列
						listb.push_back(std::move(newstr));
					}

					//下一次循环中从endpos位置开始再看看还能不能找到可替换的字符串
					pos = endpos;
				}
			}
		}

		//移动到a, (也清空了b)
		lista = std::move(listb);
	}
}

void program()
{
	cin >> src >> dst;

	while (!cin.eof())
	{
		string str;
		cin >> str;
		if (!str.size())
			break;
		srcarr.push_back(std::move(str));
		cin >> str;
		dstarr.push_back(std::move(str));
	}

	N = srcarr.size();

	bfs();

	if (mintimes <= MAXTIMES)
		cout << mintimes << endl;
	else
		cout << "NO ANSWER!" << endl;

}

int main()
{
	program();

	return 0;
}


```


---

## 作者：YZL11111 (赞：1)

题目链接：https://www.luogu.org/problem/P1032

## 【题目描述】
已知有两个字串A,B及一组字串变换的规则（至多66个规则）:

A_1 -> B_1	 

A_2 -> B_2 

规则的含义为：在 A中的子串 A_1可以变换为 B_1，A_2可以变换为 B_2…。

例如：A=abcd，B＝xyz，

变换规则为：

abc→xu，ud→y，y→yz

则此时，A可以经过一系列的变换变为B，其变换的过程为：

abcd→xud→xy→xyz。

共进行了3次变换，使得A变换为B。

## 【输入格式】
输入格式如下：

A B

A_1 B_1 

A_2 B_2 |-> 变换规则


... ... /

所有字符串长度的上限为20。

## 【输出格式】
输出至屏幕。格式如下：

若在10步（包含10步）以内能将AA变换为BB，则输出最少的变换步数；否则输出"NO ANSWER!"

## 【解题思路】
（待更新）

## 【AC代码】
```cpp
#include <map>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int k = 0;
string s1[100], s2[100];
map<string, int> vis;
queue< pair<string, int> > que;
string change(string s, int x, int y)
{
	string ss = "";
	if (x + s1[y].length() > s.length())
	{
		return ss;
	}
	for (int i = 0; i < s1[y].length(); i++)
	{
		if (s[x + i] != s1[y][i])
			return ss;
	}
	ss = s.substr(0, x);
	ss += s2[y];
	ss += s.substr(x + s1[y].length());
	return ss;
}
void bfs()
{
	que.push(pair<string, int>(s1[0], 0));
	while (!que.empty())
	{
		if (que.front().second > 10)
		{
			printf("NO ANSWER!\n");
			exit(0);
		}
		if (vis.count(que.front().first))
		{
			que.pop();
			continue;
		}
		if (que.front().first == s2[0])
		{
			printf("%d\n", que.front().second);
			exit(0);
		}
		vis[que.front().first] = 1;
		for (int i = 0; i < que.front().first.length(); i++)
		{
			for (int j = 1; j < k; j++)
			{
				string temp = change(que.front().first, i, j);
				if (temp != "")
				{
					que.push(pair<string, int>(temp, que.front().second + 1));
				}
			}
		}
		que.pop();
	}
	printf("NO ANSWER!\n");
}
int main()
{
	while (cin >> s1[k] >> s2[k])
	{
		k++;
	}
	bfs();
	return 0;
}
```


---

## 作者：yubing_lml (赞：1)

第五篇题解！别开生面的一道bfs，学到了不少东西，下面来仔细讲一下(*^▽^*)！

题目给定源字符串和目标字符串，和一些字符串变换规则（最多6个），要求计算出变换的最少次数，使得源字符串变成目标字符串。

由于这道题涉及到最优解，~~（加之这道题又在广搜板块）~~，就想用广搜做一下，既然是广搜，我就用**队列Q**存储每一种状态，并标记经过的状态，避免重复计算。我用**结构体couple**存储每一种状态，这个状态包括两个元素，一个是当前的字符串（string类型），一个是得到这个字符串需要的最少变换次数（int类型）。由于是最少，所以对每个状态进行标记就显得格外重要啦（因为如果之后又出现这个字符串，那变换次数肯定大于当前的次数）

那么问题来了，怎么保存这些标记呢？以往我做到的题都是标记的点，或长度，这个可以用数组等方式解决，但是本题需要标记字符串！\(^o^)/也就是说每当变换后出现一个新的字符串就要将其标记为true，或者至少把它存起来证明它已经出现过，这时我想到了**map**，可以用它的映射关系进行标记（讲真，之前对map都是道听途说，从来没有用过它，这是第一次用）。

看了一些dalao的相关博客讲解之后，我定义了一个map<string,bool>类型的flag，第一关键字是string类型，也就是要对每次变换出现的那些字符串进行标记~

下面剖析一下bfs()函数喽~，其他的都是小场面O(∩_∩)O

若队列非空,就将队首的值赋给now；
```cpp
		couple now;
		now = Q.front();
		Q.pop();

```
若now的字符串就是我们要寻找的目标字符串，那么直接返回now.step,即变换需要的步数。
```cpp
		if (now.des == destr)
			return now.step;
```
如果该字符串不是我们苦苦寻找的那个它，开始对该字符串进行规则变换。对于每一个规则，都进行如下操作：

（1）若当前字符串中不存在规则变换的要求字符，continue跳过本次循环
```cpp
		if (now.des.find(rule[i][0]) == string::npos)
			continue;
```

（2）考虑到一个字符串对同一变换多种情况,对每种可能变换都要考虑到呀~这里都是小场面大家琢磨一下即可~

```cpp
int t1 = rule[i][0].length();
string pre = now.des; 
int pos = 0;
while ((pos = pre.find(rule[i][0], pos)) != string::npos)			{
	string s = pre;
	s.replace(pos, t1, rule[i][1]);
	if (flag.find(s) != flag.end())//说明flag中已经有该字符串;
	{
		pos++;
		continue;
	}	
	couple tmp;
	tmp.des = s;
	tmp.step = now.step + 1;
	Q.push(tmp);
	flag.insert(pair<string, bool>(tmp.des, true));
	pos++;
}
```
还有就是输入卡了好久，Ctrl+Z+Enter+Enter就好！

最后！还要注意的一点就是，对于同一个变换，一个字符串也许有多种选择方式！比如abaa，如果变换规则是a->xxx,那么a可以有3种情况，这个要考虑到哇！

```cpp
#include <iostream>
#include<queue>
#include<cstring>
#include<string>
#include<map>
using namespace std;

struct couple
{
	string des;
	int step;
};

string rule[7][2];
int cnt = 0;
couple start;
string init, destr, str1, str2;
map<string, bool>flag;

queue<couple>Q;

int bfs()
{
	while (!Q.empty())
	{
		couple now;
		now = Q.front();
		Q.pop();
		if (now.des == destr)
			return now.step;
		for (int i = 1; i <= cnt; i++)
		{
			if (now.des.find(rule[i][0]) == string::npos)
				continue;
			int t1 = rule[i][0].length();
			string pre = now.des; //考虑到一个字符串对同一变换多种情况
			int pos = 0;
			while ((pos = pre.find(rule[i][0], pos)) != string::npos)
			{
				string s = pre;
				s.replace(pos, t1, rule[i][1]);
				if (flag.find(s) != flag.end())// flag.count(rule[i][0]) == 1;
				{
					pos++;
					continue;
				}
				couple tmp;
				tmp.des = s;
				tmp.step = now.step + 1;
				Q.push(tmp);
				flag.insert(pair<string, bool>(tmp.des, true));
				pos++;
			}
		}//for-i
	}//while
	return - 1;
}

int main()
{
	cin >> init >> destr;
	start.des = init;
	start.step = 0;
	Q.push(start);

	flag.insert(pair<string, bool>(start.des, true));

	while (cin >> str1 >> str2)
	{
		cnt++;
		rule[cnt][0] = str1;
		rule[cnt][1] = str2;
	}
	int tmp = bfs();
	if (tmp >= 0 && tmp <= 10)
		cout << tmp;
	else
		cout << "NO ANSWER!";
	system("pause");
	return 0;
}
```


---

## 作者：Maktub (赞：1)

这个题太恶心了。。。

其实这就是道大模拟题，总的来说处理分一下几步.

1.读入，没有给n，我只会用文件操作来读入输出了。如果初学不会的话会比较麻烦，这里说明一下。

读入规则显然可以这么写：

```
    n++;
    while(cin>>from[n]>>to[n])n++;
    n--;
```
但这样的话弄出黑框框弄不出来答案，我们可以这样：

```
      freopen("xxx.txt","r",stdin);
      freopen("xxxo.txt","w",stdout);
```
把数据放xxx.txt中，运行，然后去xxxo.txt找结果就行了。
（菜鸡的我只会这么做。。。大佬轻喷）。

2.开始进行老套的广搜。将初始状态入队，不断枚举能转换的字符串，不停变，同时记录步数，直到找到目标，然后检验步数，如果大于10就输出“Nxxxxxx”。

这个思路是非常简单的，但实际没有这么简单，怎么枚举？怎么方案是否可行？怎么判重？这都是问题，接下来仔细说明一下。

1.判重（调简单的先来）

直接一个map<string,int>判重就好，map在很多情况是很实用的，我经常用来处理字符串和数据之间的关系。

可以看一下[map的一些操作](https://www.luogu.org/blog/jjq/solution-p1603)来加深一下印象。

2.枚举

因为考虑到在一个字符串中可能有相同的串，所以我们扫描每一位，找可以替换的子串，然后替换子串判重入队就可以了。

判断子串一个简单的模拟就可以解决：

```
inline int check(string a,int s,string b){
	int k=0;
	for(int i=s;i<s+b.size();i++){
		if(a[i]==b[k]){
			k++;continue;
		}
		if(a[i]!=b[k])return 0;
	}
	return 1;
}
   if(st[i]==from[j][0])
   int jud=check(st,i,from[j]);
```
然后就是替换了，我们可以利用string的一个特性，字符串相加，例如：string a="abcd",b="cdef";cout<<a+b;

输出的是 "abcdcdef"；如果 string tmp=a+b;那么tmp="abcdcdef"；我们可以用这个来实现字符串替换。

```
inline string change(string c,string a,string b,int k){
	string tmp;
	for(int i=0;i<k;i++)tmp+=c[i];
	tmp+=b;
	for(int i=k+a.size();i<c.size();i++)tmp+=c[i];
	return tmp;
}//将c中的a换成b，k为a的首字母在c中的位置。
```

然后就判重入队就可以了。

注意：如果步骤为0，那么也算是没有答案。

记得注释freopen

代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
int bb[22];
string start,end;
int n;
map<string,int>vis;
string from[7],to[7];
string q[10001];
int head,tail;
int step[10001];
inline int check(string a,int s,string b){
	int k=0;
	for(int i=s;i<s+b.size();i++){
		if(a[i]==b[k]){
			k++;continue;
		}
		if(a[i]!=b[k])return 0;
	}
	return 1;
}
inline string change(string c,string a,string b,int k){
	string tmp;
	for(int i=0;i<k;i++)tmp+=c[i];
	tmp+=b;
	for(int i=k+a.size();i<c.size();i++)tmp+=c[i];
	return tmp;
}
int main(){
  //  freopen("3.in","r",stdin);
  //    freopen("1.out","w",stdout);
    cin>>start>>end;
    n++;
    while(cin>>from[n]>>to[n])n++;
    n--;
    tail=1;
    q[1]=start;
    
    vis[q[1]]=1;
    int flagg=0;
    if(start==end){
    	printf("NO ANSWER!");return 0;
	}
    while(head<=tail){
    	head++;                   
    	string st=q[head];
    	for(int i=0;i<st.size();i++){
    		for(int j=1;j<=n;j++){
    			if(i+from[j].size()>st.size())continue;
    			if(st[i]==from[j][0]){
    				int jud=check(st,i,from[j]);
    				if(jud){
    					string tmp=change(st,from[j],to[j],i);
    					if(vis[tmp])continue;
    					if(tmp==end){
    						int ans=step[head]+1;if(ans>10){
    							printf("NO ANSWER!");return 0;
							}
							printf("%d",ans);return 0;
						}
    					vis[tmp]=1;
    					tail++;
    					q[tail]=tmp;
    					step[tail]=step[head]+1;
					}
				}
			}
		}
    }
    
   	printf("NO ANSWER!");return 0;
   
}

	
```



---

## 作者：嚯呀嚯呀 (赞：1)

简单的宽搜(然而我交了整整一页)
其实就是从初始字符串通过规则变到目标字符串,不过有一个地方要注意，就是一个规则可能会有很多地方可以用到，宽搜的时候一个规则可以扩展出去很多状态。

**注意判重，我这里用hash来判重，没写链表法，有冲突直接放到后面去了，简单一点**

写了一下双向搜索，差不多能比正常搜索快30几毫秒吧，如果数据再大一点还能再快

**Code(Pascal):**
```
var
  bi:boolean;
  first,aim:string;
  s:char;
  t1,t2,t3:string;
  head,tail,head1,tail1:longint;
  seed,a1,i,j,m,n,k,p:longint;
  a,b:array[0..10]of string;
  f:array[0..100000,0..1]of string;
  step:array[0..100000,0..1]of longint;
  hash:array[0..70000]of string;
  num,point:array[0..70000]of longint;
function ha(t:string):longint;//hash
var
  i,point:longint;
begin
  point:=0;
  for i:=1 to length(t) do
    point:=(point*seed+ord(t[i]))and $FFFF;
  while (hash[point]<>'%')and(hash[point]<>t) do
    begin
      inc(point);
      if point=70000 then point:=0;
    end;
  exit(point);
end;
begin
  {assign(input,'11.in');reset(input);
  assign(output,'11.out');rewrite(output);}
  seed:=31;
  repeat
    read(s);
    if s=' ' then break;
    first:=first+s;
  until false;
  readln(aim);
  while not eof do
    begin
      inc(n);
      repeat
        read(s);
        if s=' ' then break;
        a[n]:=a[n]+s;
      until false;
      readln(b[n]);
    end;//读入
  if first=aim then
    begin
      writeln(0); exit;
    end;
  for i:=0 to 70000 do hash[i]:='%';
  a1:=ha(first);
  hash[a1]:=first; num[a1]:=1; point[a1]:=1;
  a1:=ha(aim);
  hash[a1]:=aim; num[a1]:=2;   point[a1]:=1;
  head:=0; tail:=1; f[1,0]:=first; step[1,0]:=0;
  head1:=0; tail1:=1; f[1,1]:=aim; step[1,1]:=0;//初始化
  while true do
    begin
      //writeln('1:',tail,' ',tail1);
      if tail<tail1 then
      //哪一个队列长度短就扩展哪个，尽量保证正向反向状态平衡
        begin
          inc(head);
          if head>tail then break;
          for i:=1 to n do
            begin
              t2:=f[head,0];
              p:=pos(a[i],t2);
              while p<>0 do
                begin
                  t1:='';
                  for j:=1 to p-1 do
                    t1:=t1+t2[j];
                  t1:=t1+b[i];
                  for j:=p+length(a[i]) to length(t2) do
                    t1:=t1+t2[j];
                  a1:=ha(t1);
                  if (hash[a1]='%')and(step[head,0]+1<=10) then
                    begin
                      hash[a1]:=t1; num[a1]:=1;
                      inc(tail); f[tail,0]:=t1; step[tail,0]:=step[head,0]+1;
                      point[a1]:=tail;
                    end
                  else
                    if (num[a1]<>1)and
                       (step[head,0]+1+step[point[a1],1]<=10) then
                      begin
                        writeln(step[head,0]+1+step[point[a1],1]);
                        exit;
                      end;
                  t3:='';
                  {for j:=1 to p-1 do
                    t3:=t3+t2[j];
                  t3:=t3+b[i];
                  for j:=p+length(a[i]) to length(t2) do
                    t3:=t3+t2[j];}
                  for j:=p+1 to length(t2) do
                  //第4个点很坑，前面无效掉的是我之前的代码，会死循环
                    t3:=t3+t2[j];
                  t2:=t3;
                  p:=pos(a[i],t2);
                end;
            end;
        end
      else//反向扩展
        begin
          inc(head1);
          if head1>tail1 then break;
          for i:=1 to n do
            begin
              t2:=f[head1,1];
              p:=pos(b[i],t2);
              while p<>0 do
                begin
                  t1:='';
                  for j:=1 to p-1 do
                    t1:=t1+t2[j];
                  t1:=t1+a[i];
                  for j:=p+length(b[i]) to length(t2) do
                    t1:=t1+t2[j];
                  a1:=ha(t1);
                  if (hash[a1]='%')and(step[head1,1]+1<=10) then
                    begin
                      hash[a1]:=t1; num[a1]:=2;
                      inc(tail1); f[tail1,1]:=t1;
                      step[tail1,1]:=step[head1,1]+1;
                      point[a1]:=tail1;
                    end
                  else
                    if (num[a1]<>2)and
                       (step[head1,1]+1+step[point[a1],0]<=10)then
                      begin
                        writeln(step[head1,1]+1+step[point[a1],0]);
                        exit;
                      end;
                  t3:='';
                  {for j:=1 to p-1 do
                    t3:=t3+t2[j];
                  t3:=t3+a[i];
                  for j:=p+length(b[i]) to length(t2) do
                    t3:=t3+t2[j]; }
                  for j:=p+1 to length(t2) do
                    t3:=t3+t2[j];
                  t2:=t3;
                  p:=pos(b[i],t2);
                end;
            end;
        end;
       //writeln('2:',tail,' ',tail1);
    end;
  writeln('NO ANSWER!');
  //close(input); close(output);
end.

```
祝大家2018NOIP rp++

---

## 作者：Willendless (赞：1)

这应该是我做的第一道隐式图的题（状态转移，又是状态转移，普通的找最短路径也是状态转移啦，不过状态就是所处位置，用坐标表示，转移只有上下左右啦）
感觉我的代码要稍微简洁一点。。。
1、主要是c++：：string的使用，要注意string：：npos是size_t类型，所以用string：：find的函数的时候要注意，返回值转换成int类型然后判断是否为-1。
2、对当前状态进行的操作可能针对的子串位置不确定，可能有多个子串符合进行操作的条件，所以把find函数放到while()循环里面去
3、vis记录搜索过的状态，set集合写法是最基本的（具体可参考紫书），更好的可以用哈希，然我还很不熟，而且这题操作数量比较少啦。。对了，可能也可以找到完美哈希。。。

```
#include <bits/stdc++.h>
using namespace std;


const int maxn = 6+5;
struct state{ string s; int num; state(string k = "", int x = -1):s(k),num(x){} };//状态
state beg, lst;
struct Op{ string from, to; } op[maxn];
set<string> vis;
int n;

int main()
{
    cin >> beg.s >> lst.s;
    while(cin >> op[n].from >> op[n].to) n++;

    queue<state> que;//等待执行的队列
    que.push(beg);

    while(!que.empty()) {
        state cur = que.front();
        que.pop();
        cur.num++;

        if(cur.num > 10) break;
        if(cur.s == lst.s) { lst.num = cur.num; break; }
        if(vis.count(cur.s)) continue;

        vis.insert(cur.s);
        for(int i = 0; i < n; i++) {
            int p = cur.s.find(op[i].from);
            while(p != -1) {
                string lft = cur.s.substr(0, p);
                string rgt = cur.s.substr(p+op[i].from.size());
                string next = lft + op[i].to + rgt;
                que.push(state(next, cur.num));
                p = cur.s.find(op[i].from, p+1);
            }
        }
    }
    if(lst.num < 0) cout << "NO ANSWER!" << endl;
    else cout << lst.num << endl;
}

```

---

## 作者：MekakuCityActors (赞：1)

典型的BFS题目

------------

回顾一下BFS，无非就是将某个状态的信息存储在一个结构体中，然后丢进数组进行瞎搞。但是瞎搞时一定要判重，一般都是用vis数组就能进行判重，但这题的状态是字符串而不是数字，所以就不能使用vis数组判重，而应该使用map进行判重，而使用map时要注意如果使用map<char * , int>那么进行标记的就是数组的地址，也就会出现错误，而使用map<string,int>才能对字符串变量或者字符型数组进行处理。【~~另外将一些操作封装成函数真的很好用啊，以前怎么不知道用QAQ~~】
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
#include<queue>
#include<vector>
using namespace std;
map<string,int>mp;
struct pot{
	char aa[100]; 
	int step;
};
struct pot qq;
char bb[10][100];
char dd[10][100];
char cc[100];
int tot=0;
int ans=-1;
queue<struct pot>que;
bool cmp(char a[] ,int len1, int len2, char b[])//自定义字符串比较函数
{
	for(int i = 0 ; i < len2 ; i++)
	{
		if(a[len1+i]!=b[i])return false;
	}
	return true;
}
void bfs()
{
	mp.clear();
	while(!que.empty())
	que.pop();
	que.push(qq);
	mp[qq.aa]++;
	int len=strlen(cc);
	while(!que.empty())	
	{
		struct pot ww=que.front();que.pop();
		int llen=strlen(ww.aa);
		if(llen==len&&cmp(ww.aa,0,llen,cc))
		{
			ans=ww.step;
			break;
		}
		for(int i = 0 ; i < llen ; i++)
		{
			for(int j = 0 ; j < tot ; j++)
			{
				int lenn=strlen(bb[j]);
				int lennn=strlen(dd[j]);
				if(i+lenn<=llen&&cmp(ww.aa,i,lenn,bb[j]))
				{
					struct pot ee;
					for(int k = 0; k < i ;k++)
					{
						ee.aa[k]=ww.aa[k];
					}
					for(int k = i; k < i+lennn ;k++)
					{
						ee.aa[k]=dd[j][k-i];
					}
					int tot1=i+lennn;
					for(int kk = i+lenn; kk < llen ;kk++)
					{
						ee.aa[tot1]=ww.aa[kk];
						tot1++;
					}
					ee.aa[tot1++]='\0';
					ee.step=ww.step+1;
					if(mp[ee.aa]==0)
					{
						mp[ee.aa]++;
						que.push(ee);
					}
				}
			}
		}
	}
}
int main()
{
	qq.step=0;
	scanf("%s%s",qq.aa,cc);
	while(scanf("%s%s",bb[tot],dd[tot])!=EOF)
	tot++;
	bfs();
	if(ans!=-1||ans>10)
	cout << ans << endl;
	else
	cout << "NO ANSWER!"<<endl;
	return 0;
 } 
```

---

## 作者：MashPlant (赞：1)

map存找到过的字符串的变换步数顺便判重，multimap存变换方式

一个小问题是需要找到一个字符串中所有与待匹配字符串匹配的下标，这里利用find函数的第二个参数指定搜索起点来完成。具体看代码。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define mp(A, B) make_pair((A), (B))
int main()
{
    multimap<string, string> ch;//注意一个变换的起点可能对应多个变换,从而需要使用multimap
    map<string, int> vis;
    string a, b;
    cin >> a >> b;
    string o, n;
    while (cin >> o >> n)
        ch.insert(mp(o, n));
    queue<string> q;
    q.push(a);
    vis.insert(mp(a, 0));
    while (!q.empty())
    {
        string cur = q.front();
        q.pop();
        int num = vis[cur];
        if (num > 10)//根据广搜的性质，只要有一个点深度>10，那么队列中的所有点深度都>10，所以直接return
        {
            cout << "NO ANSWER!" << endl;
            return 0;
        }
        if (cur == b)
        {
            cout << num << endl;
            return 0;
        }
        for (auto it : ch)
        {
            string tmp = cur;
            int pos = 0;
            while((pos=tmp.find(it.first,pos))!=string::npos)
            {
                cur.replace(pos, it.first.size(), it.second);
                if (!vis.count(cur))
                {
                    vis[cur] = num + 1;
                    q.push(cur);
                }
                cur = tmp;
                ++pos;
            }
        }
    }
    cout << "NO ANSWER!" << endl;
    return 0;
}
```

---

## 作者：租酥雨 (赞：1)

蒟蒻不会打STL，不想用string类型，这里发一个最最朴素的用char数组存储的字串变换，用的是双向BFS，只是为了证明这道题可以打char数组。大家可以参考一下。

用char数组就要手动模拟字串变换的过程，过程分三个阶段：1、把变换前的字符复制到新字符串中；2、把被替换的部分忽略，把替换字符放入字符串；3、再把变换后的字符复制到字符串中。注意时刻留意字符串长度。

一定要用到的是关于字符串，定义在<cstring>中的一些函数，比如strcmp（用于字符串判等），strncmp（字符串部分判等），strlen（求字符串长度）等等。用法简单，适合蒟蒻（本人）。

双向BFS的思路很简单，就是两头轮流扩展节点，当两个head节点的步数之和大于等于10时break，输出NO ANSWER!。

这里注意一点，由于是双向，就说明目标节点应该是反着搜，所以字串变换的规则也要反过来。这里就不用A和B了，直接开二维数组，方面统一调用。

至于判断相遇（得解），我选择了每生成一个新节点，就对另一队列从头到尾扫一遍，有相同的就输出答案return 0。好在洛谷神机跑得比较快（2333）...

以上算法或许不是最优解，但也是一种新的策略，或者说一种新的尝试。

以下代码。



    
    
    
      
    


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct duilie{
    char s[400]={0};
    int len;
    int g;
}h[2][200000];//手动模拟队列 
int head[2],tail[2]={1,1};//双向BFS 
struct change{
    char a[2][400];
    int len[2];
}l[10];//这里是变换规则 
int n=1;
bool key;
void new_born(int x,int start,int num)//某一队列新生成节点，变化初位置，变换规则编号 
{
    tail[x]++;
    h[x][tail[x]].len=h[x][head[x]].len-l[num].len[x]+l[num].len[1-x];//计算出新生成节点的字符串长度 
    h[x][tail[x]].g=h[x][head[x]].g+1;
    for (int i=0;i<start;i++)
      h[x][tail[x]].s[i]=h[x][head[x]].s[i];//先拼变换之前的位置 
    for (int i=0;i<l[num].len[1-x];i++)
      h[x][tail[x]].s[i+start]=l[num].a[1-x][i];//变换的位置
    for (int i=start+l[num].len[1-x];i<h[x][tail[x]].len;i++)
      h[x][tail[x]].s[i]=h[x][head[x]].s[i+l[num].len[x]-l[num].len[1-x]];//再拼变换之后的位置
    //printf("%d队列扩展，head=%d  tail=%d g=%d 字串 ",x,head[x],tail[x],h[x][tail[x]].g);
    //for (int i=0;i<h[x][tail[x]].len;i++)
       //printf("%c",h[x][tail[x]].s[i]);
    //printf("\n\n");
    //上面这一段可以用于检验BFS过程 
    for (int k=1;k<=tail[1-x];k++)
      if ( strcmp( h[x][tail[x]].s , h[1-x][k].s ) ==0 ) //字符串判等 
      {
          printf("%d\n",h[x][tail[x]].g+h[1-x][k].g);
          key=1;
          break;
      }
}
void BFS(int x)//双向BFS 
{
    head[x]++;
    for (int i=0;i<h[x][head[x]].len;i++)//枚举待变换字串位置 
    {
        for (int j=1;j<=n;j++)//枚举变换规则 
        {       //如果变换规则的字符串和原字符串的部分相同，则可替换
            if ( strncmp( l[j].a[x] , h[x][head[x]].s+i , l[j].len[x] ) ==0 )
              new_born(x,i,j);//x队列新生成节点，变化初位置在i，变换规则j 
            if (key) return ;
        }
    }
}
int main()
{
    //freopen("zcbh.in","r",stdin);
    //freopen("zcbh.out","w",stdout);
    scanf("%s%s",h[0][1].s,h[1][1].s);
    h[0][1].len=strlen(h[0][1].s);
    h[1][1].len=strlen(h[1][1].s);
    while ( scanf("%s%s",l[n].a[0],l[n].a[1])==2 )
    {
        l[n].len[0]=strlen(l[n].a[0]);
        l[n].len[1]=strlen(l[n].a[1]);
        n++;
    }
    n--;
    while (head[0]<tail[0]&&head[1]<tail[1])
    {
        if (h[0][head[0]].g+h[1][head[1]].g>=10) break;//10步内未出解退出 
        BFS(0);
        if (key) break;
        BFS(1);
        if (key) break;
    }
    if (!key) printf("NO ANSWER!");
    return 0;
}
```

---

## 作者：yybyyb (赞：1)

其实这道题目数据并不是很强，

所以直接暴力枚举即可（NOIP良心题目）

（如果数据很强的话是不是要用AC自动机？？？）

每次枚举当前串

枚举每一种变幻方案

查询是否可行

然后变幻一下，放到队列之中继续广搜

（用广搜是很明显的，因为要求最小步数）

判重可以使用map（C++STL真好用）

而对于变幻后字符串的拼接可以使用string中的substr就会非常方便

其他的细节可以看代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<map>
#include<queue>
#include<algorithm>
using namespace std;
#define MAX 5000
struct Node
{
      string s;
      int st;
};
map<string,int> M;
string A,B,a[MAX],b[MAX];
int n=0;
queue<Node> Q;
int cnt=1;
int main()
{ 
    cin>>A;cin>>B;
    while(cin>>a[++n])
          cin>>b[n];
    n--;
    M[A]=0;
    Q.push((Node){A,0});
    while(!Q.empty())
    {
                 string s=Q.front().s;
                 int St=Q.front().st,l=s.length();
                 if(St==11)break;
                 Q.pop();
                 for(int i=1;i<=n;++i)//检查所有规则
              {
                      int l2=a[i].length();
                      for(int j=0;j<=l-l2;++j)
                      {
                               if(s.substr(j,l2)==a[i])//匹配规则
                             {
                                     string ss;ss.clear();
                                     if(j!=0)ss+=s.substr(0,j);
                                     ss+=b[i];
                                     if(j+l2<l)ss+=s.substr(j+l2,l-l2-j+1);//拼合 
                                     if(M.find(ss)==M.end())//没有被用过 
                                     {
                                            M[ss]=St+1;
                                            Q.push((Node){ss,St+1});
                                     }
                                     if(ss==B)//找到结果 
                                     {
                                            cout<<St+1<<endl;
                                            return 0;
                                     }
                             }
                      }
              }
    }
    cout<<"NO ANSWER!"<<endl;
    return 0;
}

```

---

## 作者：AFreeMan (赞：1)

BFS遍历，代码注释很详细



    


```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<string>
#include<cstring>
#include<map>
using namespace std;
int pos=1,lens[7],lent[7];//规则总数，长变换的两方的度（s，t） 
string A,B,rules[7],rulet[7];//原以及需求字符串， 变换的两方的内容（s，t） 
queue<string> Q;//bfs队列 
map<string,int>ans;//某个字符串是经历了几轮变换 
string change(string a,string b,int start,int l1,int l2)//将待变换字符串按规则变换 
{            //待变换，规则t，待变换字符串开始变换位置，规则s、t的长度 
    int now=0;//现在写入string的第几个字符 
    string buf;         //不可以写char* buf，否则会非法访问内存！！！cahr*形式必须初始化，一般写char buf【INF】； 
    buf.resize(250);//一定要resize，默认是长度为0 ，还有题目说所有字符串长度<=20，但中间搜索很可能很大而RE 
    //画个示意图 
    for(;now<start;now++)buf[now]=a[now];//换之前 
    for(int i=0;i<l2;i++)buf[now++]=b[i];//换之中 
    for(int i=0;i<a.length()-(start+l1);i++)buf[now++]=a[start+l1+i];//换之后 
    buf.resize(a.length()+l2-l1); //注意删去后面的空字符，否则无法进行字符串比对（一定失败） 
    return buf;
}
bool ok(string a,string b,int k,int h)//是否能匹配上 
{        //待匹配，规则s，待匹配的匹配开始位置 ，规则s长度 
    for(int i=0;i<h;i++)if(a[k+i]!=b[i])return false;//逐字符比较    
    return true;
}
void bfs()
```
{//一定切记char\*表示字符串时不能赋值、比较 ，这种题最好用string，即使它很慢，算法正确的话不会差太多，退一步来说就算
ans[A]=0;//记住边界   //map<char\*,int>的key是地址而非字符串，应用string。  慢而TLE也不会扣太多分，而用char\*有爆零风险！

for(int i=1;i<=pos;i++){lens[i]=rules[i].length();lent[i]=rulet[i].length();}

    
        

    
```cpp
    Q.push(A);
    if(A==B){cout<<0<<"\n";return;}  //一定注意边界判断 
    while(!Q.empty())
    {
        string s=Q.front(); Q.pop();             
        if(ans[s]==10)break;//扩展后为11 
        int len=s.length();
        for(int rule=1;rule<=pos;rule++)//遍历规则 
        {
            for(int i=0;i<=len-lens[rule];i++)//逐字符检查 
              if(ok(s,rules[rule],i,lens[rule]))
                {string t=change(s,rulet[rule],i,lens[rule],lent[rule]); if(ans.count(t))continue; ans[t]=ans[s]+1; Q.push(t); if(t==B){cout<<ans[t]<<"\n";return;}}
        }                   //bfs/dfs一定切记判重，以前做过的千万不能再重复，否则T（n）大大提高，还会错误！！！（这道就是） 
                            //bfs判重只需在待入队时判一次，出队时不需判，因为队里所有的都是以前没有出现的 
    }                       //判重不能仅仅是判队里是否有（那是spfa），而应判以前是否搜索到过 
    cout<<"NO ANSWER!\n";   //Q：那如果队里在前面的马上就会搜索到队里后面（现在待入队的）的，那现在待入队的这个要不要入队？
}                           //A：要。因为入队以后，队前的搜索到队后元素时会判重，就不会重复入队了。 
int main()
{ 
    cin>>A>>B;
    while(cin>>rules[pos]>>rulet[pos])pos++; //这类输入不要判EOF，要用cin 
    pos--; //现在POS是规则总数（1~pos） 
    bfs();
    return 0;
}
```

---

## 作者：ergeda (赞：1)

//数据很小，此题可以用超级爆搜！！，手写队列也就很轻易就过了。。。

                
```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
using namespace std;
struct node{
    char s1[21];
    char s2[21];
};
node a[50];
struct ergedathouder{
    char sss[25];
    int bushu;
};
ergedathouder q[1000000];//队列
char s[25],ss[25];
int cnt;
bool flagflag;//用来判断有没有成功变换
void bfs(){
    strcpy(q[1].sss,s);把一开始的值赋给q[1].sss
    int f=0,l=1;
    q[1].bushu=0;
    while(f<l){
        f++;
        if(q[f].bushu>10)continue;//小剪枝
        int k=strlen(q[f].sss);
        for(int i=0;i<k;i++){//枚举当前队列每一位
            for(int j=1;j<=cnt;j++){//枚举变换的字符串
                bool flag=0;
                int len=strlen(a[j].s1);
                int i2=i;
                for(int u=0;u<len;u++){
                    if(a[j].s1[u]!=q[f].sss[i2]){
                        flag=1;
                        break; 
                    }
                    i2++;.//每一位枚举
                }
                if(!flag){
                int lenth=strlen(a[j].s2);
                ++l;
                for(int u=0;u<i;u++){
                    q[l].sss[u]=q[f].sss[u];
                }
                //把变换前的值赋给q[l].sss
                for(int u=i;u<lenth+i;u++){
                    q[l].sss[u]=a[j].s2[u-i];
                }
                               //把变换的值赋过去
                for(int u=lenth+i,v=i+len;v<k;u++,v++){
                    q[l].sss[u]=q[f].sss[v];
```
}//最后把原先后面没有变换的接上去
//以上三个变换不用担心时间复杂度，暴力for循环就可以了

```cpp
                int lenlen=strlen(q[l].sss);
                q[l].bushu=q[f].bushu+1;
                if(strcmp(q[l].sss,ss)==0){//判断
                    if(q[l].bushu<=10)
                    printf("%d\n",q[l].bushu);
                    else {
                        printf("NO ANSWER!\n");
                    }
                    flagflag=1;
                    return ;
                }
            }
            }
        }
    }
}
int main(){
    int i,j,k,m,n;
    scanf("%s",&s);
    scanf("%s",&ss);
    while(scanf("%s",a[++cnt].s1)!=EOF){
        scanf("%s",a[cnt].s2);
    }
    cnt--;
    bfs();
    if(!flagflag){
        printf("NO ANSWER!\n");
    }
    return 0;
}
```

---

## 作者：__stdcall (赞：1)

搜索都是玄学。

求最短路的话，BFS比较靠谱

然后随便加个剪枝就好了：如果搜索过这个串就不在继续搜索（用map判断）

其实好像用不到双向广搜，不过双向广搜真是快。。。







```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <map>
#include <queue>
using namespace std;
const int INF = 0x3f3f3f3f;
struct item
{
    string str;
    int depth;
};
string A,B;
string from[10],to[10];
int idx = 0;
int ans = INF;
queue<item> q;
map<string,bool> m;
string check( const string &str , int i , int j )
{
    if( i+from[j].size() > str.size() ) return string("");
    for( int k = 0 ; k < from[j].size() ; ++k )
    {
        if( str[i+k] != from[j][k] ) return string("");
    }
    string rst = str.substr(0,i);
    rst.append(to[j]);
    rst.append( str.substr( i+from[j].size() ) );
    return rst;
}
void bfs()
{
    q.push( (item){A,0} );
    while( !q.empty() )
    {
        item thing = q.front(); q.pop();
        if( thing.str == B )
        {
            ans = thing.depth;
            return;
        }
        if( thing.depth == 10 ) continue;
        if( m.count(thing.str) ) continue;
        m[thing.str] = true;
        string nxt;
        for( int i = 0 ; i < thing.str.size() ; ++i )
        {
            for( int j = 0 ; j < idx ; ++j )
            {
                if( (nxt=check(thing.str,i,j)) != string("") )
                {
                    q.push( (item){nxt,thing.depth+1} );
                }
            }
        }
    }
}
int main()
{
    cin >> A >> B;
    while( cin >> from[idx] >> to[idx] ) idx++;
    bfs();
    if( ans == INF ) cout << "NO ANSWER!" << endl;
    else cout << ans << endl;
    return 0;
}
```

---

## 作者：吴国铨 (赞：1)

老少皆宜，通俗易懂，双向广搜









```cpp
Const maxn=10000; 
      maxq=100000; 
Var a:array[0..1,0..maxn]of string;//变换规则 
    q:array[0..1,0..maxq]of string;//两个队列 
    step:array[0..1,0..maxn]of longint;//步数
    head,tail:array[0..1]of longint;//两个队列的头指针和尾指针 
    int,aim,s1,s2,s:string; 
    n:longint; 
Procedure split(s:string);//将目标状态和初始状态记录下来 
var k:longint; 
begin 
  k:=pos(' ',s); 
  s1:=copy(s,1,k-1); 
  s2:=copy(s,k+1,length(s)-k); 
end; 
Procedure init; //读入
begin 
  readln(s); 
  split(s); 
  int:=s1;//初始状态
  aim:=s2;//目标状态 
  n:=0; 
  while not eof do 
  begin 
    readln(s); 
    if s='' then exit; 
    inc(n); 
    split(s); 
    a[0,n]:=s1;//初始的可以转换的状态
    a[1,n]:=s2;//由初始状态转换一步得到的目标状态
  end; 
end; 
Function vis(s:string;t:byte):boolean; 
var i:longint; 
begin 
  vis:=false; 
  for i:=1 to tail[t] do//遍历队列
  if q[t,i]=s then exit(true);//如果找到目标状态就返回值true 
end; 
Procedure print(k:longint); 
begin 
  writeln(k);//（如果合法）输出最少变换步数 
  halt; 
end; 
Procedure check(t:byte); 
var i:longint; 
begin 
  for i:=1 to tail[1-t] do //遍历队列（当前的状态保存在队列里）
  if q[1-t,i]=q[t,tail[t]] then //如果两个广搜碰头了
  print(step[1-t,i]+step[t,tail[t]]);//总的步数就是两个广搜步数之和 
end; 
Procedure bfs(t:byte); //广搜（t=0是正着搜，t=1是反着搜）
var i,j,k:longint; 
    pre,tmp:string; 
begin 
  inc(head[t]);//头指针加一
  pre:=q[t,head[t]];//入队 
  for i:=1 to n do//遍历变换规则 
  begin 
    k:=length(a[t,i]); 
    for j:=1 to length(pre)-k+1 do//按照变换规则扩展状态 
    begin 
      if copy(pre,j,k)=a[t,i] then//如果规则符合 
      begin 
        tmp:=copy(pre,1,j-1)+a[1-t,i]+copy(pre,j+k,length(pre)-j-k+1);//扩展下一个状态 
        if not vis(tmp,t) then//如果没有找到目标状态 
        begin 
          inc(tail[t]); 
          q[t,tail[t]]:=tmp; 
          step[t,tail[t]]:=step[t,head[t]]+1;//步数++ 
        end; 
        check(t);//检查是否终止搜索（注意位置，不然就T了）
      end; 
    end; 
  end; 
end; 
Procedure doublebfs;//用数组下标来区分两个队列和两个广搜 
begin 
  head[0]:=0;//第一个队列的头指针
  head[1]:=0;//第二个队列的头指针
  tail[0]:=1;//第一个队列的尾指针
  tail[1]:=1;//第二个队列的尾指针 
  q[0,1]:=int;//初始状态
  q[1,1]:=aim;//目标状态
  step[0,1]:=0;//步数
  step[1,1]:=0;//步数 
  while (head[0]<tail[0])and(head[1]<tail[1])do 
  if tail[1]<tail[0] then 
  bfs(1) else bfs(0);//保持两个广搜的同步 
end; 
Begin 
  init; 
  doublebfs; 
  writeln('NO ANSWER!'); 
End.
```

---

## 作者：Akashicw (赞：1)

                
                
```cpp
//不使用map映射，会导致超时一个点，得80分 
#include <iostream>
#include <cstdio>
#include <queue>
#include <map>
#include <string>
using namespace std;
int cnt=1;
bool flag=0;
string a, b;
string a1[8],b1[8];//存放变换子串 
struct node{
    string a;
    int step;
};
queue<node> q1;
map<string,bool> map1; //防止重复子串入队列，减少匹配次数 
bool bfs(){
    q1.push((node){a,0});//入队 
    map1[a] = 1;
    while(!q1.empty()){
        node t1 = q1.front();
        q1.pop();
        if(t1.step > 10) return 0;
        if(t1.a == b){printf("%d", t1.step);return 1;}
        string t = t1.a;
        int len = t.length();
        string nxt;
        for(int i = 1; i <= cnt; i ++){
            int len1 = a1[i].length();
            int k; 
            for(int j=0;j<len;j++){//查找子串可使用substr函数 
            //    for(k = 0; k < len1; k ++)
            //        if(t[j+k] != a1[i][k]) break;
            //    if(k == len1){
                if(t.substr(j,len1)==a1[i]){
                    nxt=t;
                    nxt.replace(j,len1,b1[i]);//替换子串函数replace 
                    if(!map1[nxt]) //防止超时 
                    {
                      map1[nxt] = 1;
                      q1.push((node){nxt, t1.step+1});//不重复，入队 
                    } 
                }
            }
        }
    }
    return 0;
}
int main(){
    cin >> a >> b;
    while(cin >> a1[cnt] >> b1[cnt]) cnt ++;//cnt是变换子串的个数 
    cnt --;
    if(!bfs()) printf("NO ANSWER!\n");
    return 0;
}
```

---

## 作者：七十七 (赞：1)





            
            
            

```cpp
//双向BFS， 两个Map去重判断
#include <iostream>
#include <map>
#include <string>
#include <cstdlib>
#define MAX 1000000
using namespace std;
string A, B;
string s_change[7][2], Front[MAX], Back[MAX];//6种变化规律， 从前往后BFS和从后往前BFS
int ans = 1, head_Front = 1, tail_Front = 1, head_Back = 1, tail_Back = 1, tot = 0; //对应指针
map <string, int> Map_Front;//两个Map
map <string, int> Map_Back;
void bfs()
{
    tot++;//10次就结束
    string s, s_replace;
    int head, tail;
    head = head_Front; tail = tail_Front;//调整指针
    for(int i = head; i <= tail; ++i)
        for(int j = 1; j <= ans; ++j)//变换种数
        {
            int change_Front = 0;
            while(change_Front != -1)//每个单词中可以供替换的字串不一定只有一个
            {
                s_replace = Front[i];
                change_Front = s_replace.find(s_change[j][0], change_Front);// 查找
                if(change_Front >= 0)
                {
                    s = s_replace.replace(change_Front, s_change[j][0].length(), s_change[j][1]);//替换
                    if(Map_Front[s] == 0)//剪枝， 如果出现过不进入队列
                    {
                        if(Map_Back[s] != 0)//如果能Meet in the Middle， 输出
                        {
                            cout << tot * 2 - 1;
                            return;
                        }
                        Front[++tail_Front] = s;//加入队列
                        Map_Front[s] = 1;//标记出现
                    }
                }
                if(change_Front != -1) change_Front = change_Front + s_change[j][1].length();//寻找下一个字串
            }
        }
    head_Front = tail + 1;
    head = head_Back; tail = tail_Back;//同上
    for(int i = head; i <= tail; ++i)
        for(int j = 1; j <= ans; ++j)
        {
            int change_Back = 0;
            while(change_Back != -1)
            {
                s_replace = Back[i];
                change_Back = s_replace.find(s_change[j][1], change_Back);
                if(change_Back >= 0)
                {
                    s = s_replace.replace(change_Back, s_change[j][1].length(), s_change[j][0]);
                    if(Map_Back[s] == 0)
                    {
                        if(Map_Front[s] != 0)
                        {
                            cout << tot * 2;
                            return;
                        }
                        Back[++tail_Back] = s;
                        Map_Back[s] = 1;
                    }
                }
                if(change_Back != -1) change_Back = change_Back + s_change[j][0].length();
            }
        }
    head_Back = tail + 1;
    /*for(int i = head_Front; i <= tail_Front; ++i)
        cout << Front[i] << endl;
    cout << tot << endl << endl << endl;
    for(int i = head_Back; i <= tail_Back; ++i)
        cout << Back[i] << endl;
    system("pause");
    system("CLS");*/
    if(tot == 10)//10次为限
    {
        cout << "NO ANSWER!";
        return;
    }
    bfs();
}
int main()
{
    ios::sync_with_stdio(false);
    cin >> A >> B;
    while(cin >> s_change[ans][0] >> s_change[ans][1]) ans++;//输入
    ans--;
    Map_Front[A] = 1;//Map记录
    Map_Back[B] = 1;
    Front[1] = A;//加入队列
    Back[1] = B;
    bfs();//开始BFS
    return 0;
}
```

---

## 作者：林浩然 (赞：1)

这题大体上需要用广搜解决，由于节点数太多，需要考虑用双向广搜，然后就是要注意字符串的处理。有点难度，不过不是思维上的。


本题给了我们两个字符串A$、B$和最多六条变换规则，要求我们用这组变换规则，将A$变为B$。

因为本题不具有最优子结构性质，且状态较难描述，所以动态规划、贪心等算法都无法使用，只好考虑搜索。

用深搜还是广搜呢？若用广搜，因最多有6条变换规则，每个字串长度为20，故每个字串最多有6\*20=120种变换方法，如果变10次，则最多有12010>1020，这显然无法存储，因此我们只好考虑深搜。

用这样毫无剪枝的搜索效率是不高的，可以加入两条剪枝，来提高效率。  剪枝一：当前得到的串的长度加上规则中增长最长的与所剩步数的积（即最多还能增长的长度）还小于目标串长则可减掉。当前得到的串长度减去规则中减长最长的与所剩步数的积（即最多能减长的长度）还大于目标串长则可减掉。     剪枝二：可以给扩展串定一个开始位置，开始位置定为上次扩展的时候与之匹配的位置，从这个位置开始找能变换的，开始位置前面的不作变换。

如 当前串为abcdabcefg， 有规则abcefg，则当前如果把第一个 abc变换成efg，则将扩展出来的节点开始位置定为第1位，如果当前是把第2个abc变换成efg，则把扩展出来的节点开始位置定为第5位，因为如果下次再把第1个abc变换成efg的话就会和先变换第1个再变换第2个重复，可以剪枝。

这道题加入这两条剪枝后速度会快很多。

这题大体上需要用广搜解决，由于节点数太多，需要考虑用双向广搜，然后就是要注意字符串的处理。有点难度，不过不是思维上的。


本题给了我们两个字符串A$、B$和最多六条变换规则，要求我们用这组变换规则，将A$变为B$。

因为本题不具有最优子结构性质，且状态较难描述，所以动态规划、贪心等算法都无法使用，只好考虑搜索。

用深搜还是广搜呢？若用广搜，因最多有6条变换规则，每个字串长度为20，故每个字串最多有6\*20=120种变换方法，如果变10次，则最多有12010>1020，这显然无法存储，因此我们只好考虑深搜。

用这样毫无剪枝的搜索效率是不高的，可以加入两条剪枝，来提高效率。  剪枝一：当前得到的串的长度加上规则中增长最长的与所剩步数的积（即最多还能增长的长度）还小于目标串长则可减掉。当前得到的串长度减去规则中减长最长的与所剩步数的积（即最多能减长的长度）还大于目标串长则可减掉。     剪枝二：可以给扩展串定一个开始位置，开始位置定为上次扩展的时候与之匹配的位置，从这个位置开始找能变换的，开始位置前面的不作变换。

如 当前串为abcdabcefg， 有规则abcefg，则当前如果把第一个 abc变换成efg，则将扩展出来的节点开始位置定为第1位，如果当前是把第2个abc变换成efg，则把扩展出来的节点开始位置定为第5位，因为如果下次再把第1个abc变换成efg的话就会和先变换第1个再变换第2个重复，可以剪枝。

这道题加入这两条剪枝后速度会快很多。

下附代码：

```cpp
type
  a=0..1;
var
  maxk:byte;
  dep:array[0..1,1..2300] of longint;
  str:array[0..1,1..2300] of string;
  x0:array[0..6,0..1] of string;
  open,guan:array[0..1] of longint;
procedure init;
var
  temp:string;
  i,j:longint;
begin
  i:=0;
  while not eof and (i<=6) do
    begin
      readln(temp);
      x0[i,0]:=copy(temp,1,pos(' ',temp)-1);
      x0[i,1]:=copy(temp,pos(' ',temp)+1,length(temp));
      inc(i);
    end;
  maxk:=i-1;
end;
procedure calc;
var
  i,j,k:longint;
  st:0..1;
  d:string;
procedure bool(st:a);
var
  i:longint;
begin
  if x0[0,1-st]=str[st,guan[st]] then
    begin
      writeln(dep[st,guan[st]]);
      halt;
    end;
  for i:=1 to guan[1-st] do
    if str[st,guan[st]]=str[1-st,i] then
      begin
        writeln(dep[st,guan[st]]+dep[1-st,i]);
        halt;
      end;
end;
procedure checkup(st:a);
var
  i:longint;
begin
  for i:=1 to guan[st]-1 do
    if str[st,i]=str[st,guan[st]] then
      begin
        dec(guan[st]);
        exit;
      end;
  bool(st);
end;
procedure expand(st:a);
var
  i,j,k,lx,ld:longint;
begin
  inc(open[st]);
  d:=str[st,open[st]];
  k:=dep[st,open[st]];
  ld:=length(d);
  for i:=1 to maxk do
    begin
      lx:=length(x0[i,st]);
      for j:=1 to ld do
        begin
          if (copy(d,j,lx)=x0[i,st])
             and (length(copy(d,1,j-1)+x0[i,1-st]+copy(d,j+lx,ld))<=115) then
            begin
              if guan[st]>=2300 then exit;
              inc(guan[st]);
              str[st,guan[st]]:=copy(d,1,j-1)+x0[i,1-st]+copy(d,j+lx,ld);
              dep[st,guan[st]]:=k+1;
              checkup(st);
            end;
        end;
end;
end;
begin
  for st:=0 to 1 do
    begin
      open[st]:=0;
      guan[st]:=1;
      str[st,guan[st]]:=x0[0,st];
      dep[st,guan[st]]:=0;
      bool(st);
    end;
  repeat
    if (open[0]<=open[1]) and not ((open[0]>=guan[0])
       or (guan[0]>=2300) or (dep[0,guan[0]]>10)) then expand(0);
    if (open[1]<=open[0]) and not ((open[1]>=guan[1])
       or (guan[1]>=2300) or (dep[1,guan[1]]>10)) then expand(1);
    if not ((open[0]>=guan[0]) or (guan[0]>=2300)
       or (dep[0,guan[0]]>10)) then expand(0);
    if not ((open[1]>=guan[1]) or (guan[1]>=2300)
       or (dep[1,guan[1]]>10)) then expand(1);
  until (open[0]>=guan[0]) or (dep[0,guan[0]]>10)
        or (guan[0]>=2300) and (guan[1]>=2300)
        or (open[1]>=guan[1]) or (dep[1,guan[1]]>10);
end;
begin
  init;
  calc;
  writeln('NO ANSWER!');
end.
```

---

## 作者：littleming (赞：1)

双向队列



    

```cpp
#include<iostream> 
#include<cstdio>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<string> 
#include<algorithm>
#include<queue>
#include<map>
using namespace std;
string a,b,ab[7],ba[7];
int n=1,i;//n是规则的总数 
queue<string> qa,qb;//双向bfs 
map<string,int> visa,visb;//记录字符串是否被访问 
void bfs()
{
    visa[a]=1;visb[b]=1;//初始化
    qa.push(a);qb.push(b); 
    while(1)
    {
        if(qa.empty()||qb.empty())    {cout<<"NO ANSWER!"<<endl;return;}//任意一队为空说明失败 
        string ta,tb; 
        ta=qa.front();
        tb=qb.front();
        for(i=1;i<=n;i++)
        {
            int k=0;
            while(ta.find(ab[i],k)!=-1)
            {
                k=ta.find(ab[i],k);
                int l=ab[i].size();
                ta.replace(k,l,ba[i]);//交换 
                if(visa[ta]==0)//没有访问过的话 
                {    
                    visa[ta]=visa[qa.front()]+1;// 步数加1 
                    qa.push(ta);//入队列
                }
                if(visb[ta]!=0)//即成功
                {
                    cout<<visa[ta]+visb[ta]-2<<endl;return;
                } 
                k++;
                ta=qa.front();
            }
            k=0;
            while(tb.find(ba[i],k)!=-1)
            {
                k=tb.find(ba[i],k);
                int l=ba[i].size();
                tb.replace(k,l,ab[i]);//交换 
                if(visb[tb]==0)//没有访问过的话 
                {    
                    visb[tb]=visb[qb.front()]+1;// 步数加1 
                    qb.push(tb);//入队列
                }
                if(visa[tb]!=0)//即成功
                {
                    cout<<visa[tb]+visb[tb]-2<<endl;return;
                } 
                k++;
                tb=qb.front();
            }
        }
        qa.pop();
        qb.pop();
    }
}
int main()
{
    cin>>a>>b;
    while(cin>>ab[n]>>ba[n])    {n++;}n--;
    bfs();
    return 0;
}
```

---

## 作者：crowworks695 (赞：1)

其实这道题不用双向宽搜，用单向加上判重也能过，判重可以用set，hash之类的，都能过，这里用的hash

```cpp

#include <cstdio>
#include <queue>
#include <string>
#include <iostream>
#include <cmath>

using namespace std;

const int hashsize=1000000;
const int maxstate=1000000;

string a,b,temp;
string rulesa[7],rulesb[7];

int list[hashsize]={0},next[maxstate]={0};

string zt[maxstate];

struct node
{
    string s;
    int time;
};

int cnt=0;

long long sum=0;

int hash(string h)
{
    for(int i=0;i<h.size();i++)//计算hash值
    {
        sum+=h[i];
        sum*=33;
    }
    sum=abs(sum%hashsize);//回溢出到负数，所以取了个绝对值=_=，一开始因为这个RE了三个点
    //printf("%lld\n",sum);
    int u=list[sum];//这里用链表处理哈希碰撞
    while(u)
    {
        if(zt[u]==h)return 1;//找到对应状态，返回1表示已到达这个状态
        u=next[u];
    }
    zt[++cnt]=h;//没找到，将状态插入链表，返回0，表示没到达过这个状态
    next[cnt]=list[sum];
    list[sum]=cnt;
    return 0;
}

queue <node> q;

int main()
{
    cin>>a;
    cin>>b;
    int cnts=0;
    while(cin>>rulesa[cnts]>>rulesb[cnts])
    {
        cnts++;
    }
    q.push((node){a,0});//初始结点串A入队，并将其插入哈希表
    hash(a);
    sum=0;
    while(!q.empty())
    {
        node t=q.front();q.pop();//队首元素出队
        //cout<<t.s<<" ";
        //printf("%d\n",t.time);
        if(t.s==b)//到达终点
        {
            printf("%d",t.time);
            return 0;
        }
        if(t.time==10)continue;//边界处理
        for(int i=0;i<cnts;i++)//新节点的扩展
        {
            for(int j=0;j<t.s.size();j++)
            {
                if(t.s[j]==rulesa[i][0]&&rulesa[i].size()<=t.s.size()-j)//找到当前结点中的Ax串
                {
                    //printf("j:%d\n",j);
                    bool pd=true;
                    for(int k=1;k<rulesa[i].size();k++)
                    {
                        if(t.s[j+k]!=rulesa[i][k])
                        {
                            pd=false;
                            break;
                        }
                    }
                    if(pd)
                    {
                        temp=t.s;
                        temp.replace(j,rulesa[i].size(),&rulesb[i][0],0,rulesb[i].size());//用Bx串替换Ax串
                        if(!hash(temp))q.push((node){temp,t.time+1});//哈希判重，不重扩展新节点
                        sum=0;
                    }
                }
            }
        }
    }
    printf("NO ANSWER!");//十步内没搜到答案，无解
    return 0;
}

```

---

## 作者：lqylqylqy (赞：1)

这道题其实并没有想象中的那么难。其实就是一个双向BFS，这不过要多注意细节。用两个队列搜索目的是提高时间和空间效率。时间复杂度可以从k\*6^10优化至k\*6^5.空间也节约了很多。

在搜索的时候注意如下几点：

1.两个队列一个为空或溢出就中止

    
2.优先选择已扩展节点数少的进行扩展（即头指针中更小的）


3.注意一个规则可以有多种扩展方案


4.注意去重，若新扩展出的节点之前扩展过（不一定在当前队列里）则删除该节点。


5.去重后判断是否双向搜索相遇（即当前节点是否与另一边中的任意一个节点重合），若重合则输出两个节点的深度之和）

【ps】:不要漏了开始就已相同的情况


[codep ]





             
```cpp
program Project1;
type node=record
            rp:string;
            deep:longint;
          end;
var head,tail:array[0..1]of longint;
    d:array[0..1,0..7776]of node;
    z,s,t:string;
    k,i,total:longint;
    ks,js:array[0..1,0..10]of string;
procedure check(k:longint);
var i:longint;
begin
  for i:=1 to tail[1-k]do
    if d[k,tail[k]].rp=d[1-k,i].rp then
      begin
        writeln(d[k,tail[k]].deep+d[1-k,i].deep);
        halt;
      end;
end;
procedure delete(k:longint);
var i:longint;
begin
  for i:=1 to tail[k]-1 do
    if d[k,tail[k]].rp=d[k,i].rp then
      begin
        dec(tail[k]);
        exit;
      end;
  check(k);
end;
procedure expand(k:longint);
var m1,m2,m3,z:string;
    dep,i,j,l1,l2,l3:longint;
begin
  m1:=d[k,head[k]].rp;
  l1:=length(m1);
  dep:=d[k,head[k]].deep;
  inc(head[k]);
  for i:=1 to total do
    begin
      m2:=ks[k,i];
      l2:=length(m2);
      for j:=1 to l1 do
        begin
          if j+l2-1>l1 then break;
          z:=copy(m1,j,l2);
          if z=m2 then
            begin
              m3:=js[k,i];
              l3:=length(m3);
              if l1+abs(l2-l3)<=115 then
                begin
                  inc(tail[k]);
                  d[k,tail[k]].rp:=copy(m1,1,j-1)+m3+copy(m1,j+l2,l1-j-l2+1);
                  d[k,tail[k]].deep:=dep+1;
                  delete(k);
                end;
            end;
        end;
    end;
end;
begin
  readln(z);
  k:=pos(' ',z);
  s:=copy(z,1,k-1);
  t:=copy(z,k+1,length(z)-k);
  i:=0;
  while z<>''do
    begin
      readln(z);
      k:=pos(' ',z);
      inc(i);
      ks[0,i]:=copy(z,1,k-1);
      js[0,i]:=copy(z,k+1,length(z)-k);
      ks[1,i]:=js[0,i];
      js[1,i]:=ks[0,i];
    end;
  total:=i;
  for i:=0 to 1 do
    begin
      head[i]:=1;
      tail[i]:=1;
      d[i,1].deep:=0;
      if i=0 then d[i,1].rp:=s
             else d[i,1].rp:=t;
    end;
  check(1);
  while(head[0]<=tail[0])and(d[0,tail[0]].deep<10)and(tail[1]<=tail[1])and(d[1,tail[1]].deep<10)do
    begin
      if head[0]<=head[1]then expand(0);
      if head[1]<=head[0]then expand(1);
    end;
  writeln('NO ANSWER!');
  readln;
  readln;
end.
[/codep ]
```

---

## 作者：zzjzxh (赞：1)

我是最后一个点哇掉了。

顺便提一下第三个点。可以用判重过，否则会在progdurm和progree之间死掉。。完全出不来。

最后一个点，数据：

abaaaba abcdaba

a b
b d
d e
e f
f g
g c
那么观察一下，因为是广搜，当head指针指向第一个，也就是abaaaba时，第一个拓展出来的点是bbaaaba。第二个呢？

我想大部分人的程序拓展出来应该是adaaaba。然而并不对。

因为用脑袋模拟一下，这个点答案是8，怎么出来的呢？是第三个字符a经过六步变成c，第四个字符a通过两步变为d。

第三个字符：

a-->b
b-->d
d-->e
e-->f
f-->g
g-->c
共六步

第四个字符：

a-->b
b-->d
共两步

一共八步。

那么你应该有一个状态是第一个字符是a但你修改第三个或者第四个字符。

那么问题来了。

那么你看看你的程序有没有这个状态呢？

解决方案:

用for循环拓展tail的内部，加一个while循环。当被替换的部分在head所指向的部分中还存在的时候，就继续根据本次规则拓展点。

也就是说，abaaaba拓展的第二个应该是abbaaba，第三个是abababa。。以此类推……

那么怎么实现这个过程就自己动脑子吧。。。

顺便提一句。。这个数据太弱。。说实话只有最后一个点是出现这种情况的。

而最后一个点替换规则，替换和被替换的部分长度相同。。于是我就偷了偷懒。。每次都把上一个部分变成#。。。其实这是有bug的。如果替换和被替换的部分长度不通过那就不对啦。。。

不再赘述。。大家开动脑筋吧~

下面附代码，壮哉我p党！

衷心希望大家不要复制粘贴！也许我写的有点长。。。一定要耐心看完哦~不要自己骗自己。。即使看懂了也要自己打一遍哦~

中间有个elfhash判重。。其实没什么卵用。。毕竟数据太弱用不到这么高端的东东。。。

还有。。。while not eof do 不能自己测试。。可以用文件输入输出测试~

代码：

```delphi

var
  s1,s2:array[1..10] of string;
  i,cnt,min:longint;
  a:array[0..10000] of string;
  b:array[0..10000] of longint;
  hash:array[0..100000] of boolean;
  procedure init;
  var
    s:string;
    i,p:longint;
  begin
    cnt:=0;
    while not eof do
    begin
      readln(s);
      p:=pos(' ',s);
      inc(cnt);
      s1[cnt]:=copy(s,1,p-1);
      s2[cnt]:=copy(s,p+1,length(s)-p);
    end;
  end;

  function elfhash(now:string):boolean;
  var g,h,i:longword;
  begin
    h:=0;
    for i:=1 to length(now) do
    begin
      h:=h shl 4 + ord(now[i]);
      g:=h and $f0000000;
      if g<>0 then h:=h xor (g shr 24);
      h:=h and (not g);
    end;
    h:=h mod 50239;
    if hash[h] then
    begin
      hash[h]:=false;
      elfhash:=false;
      exit;
    end;
    elfhash:=true;
  end;

  procedure bfs;
  var
    ss,sss:string;
    head,tail,p,i,j:longint;
    f:boolean;
  begin
    a[1]:=s1[1];
    b[1]:=0;
    head:=0;tail:=1;
    while (head<tail) and (b[head]<=min) do
    begin
      inc(head);
      for i:=2 to cnt do
      begin
        p:=0;
        sss:=a[head];
        p:=pos(s1[i],sss);
        while (p<>0) do
        begin
          f:=true;
          ss:=a[head];
          delete(ss,p,length(s1[i]));
          insert(s2[i],ss,p);
          delete(sss,p,1);
          insert('#',sss,p);
          if not elfhash(ss) then
          begin
            inc(tail);
            a[tail]:=ss;
            b[tail]:=b[head]+1;
          end;
          p:=pos(s1[i],sss);
        end;
        if (a[tail]=s2[1]) and (min>b[tail]) then min:=b[tail];
      end;
    end;
  end;
begin
  init;
  fillchar(hash,sizeof(hash),true);
  min:=maxlongint;
  bfs;
  if min<=10 then write(min) else write('NO ANSWER!');
end.

```

---

## 作者：plazum (赞：1)

正如楼上各位所言，这题是双向BFS……

用STL的string就可以用replace轻松地进行变换，用STL的set来判重就很方便……

数据有点弱，没有因为超过10步而NO ANSWER的……例如：

11 77
1 2
2 3
3 4
4 5
5 6
6 7
```cpp

#include<iostream>
#include<string>
#include<set>
using namespace std;
const int size=512;
int n,i,j,k,step[2][size],head[2],tail[2]={1,1},s,l[6][2];//s for side
string t[6][2],xy[2][size];
set<string> sset[2];
int main()
{
    cin>>**xy>>xy[1][0];
    while(cin>>t[n][0]>>t[n][1])n++;
    for(;i<n;i++)l[i][0]=t[i][0].size(),l[i][1]=t[i][1].size();
    for(;;s^=1){
        while(head[s]-tail[s]){
            for(i=0;i<n;i++)
                for(j=xy[s][head[s]].find(t[i][s]);j-string::npos;j=xy[s][head[s]].find(t[i][s],j+1)){
                    xy[s][tail[s]]=xy[s][head[s]];
                    xy[s][tail[s]].replace(j,l[i][s],t[i][1-s]);
                    if(sset[s].find(xy[s][tail[s]])!=sset[s].end())continue;
                    sset[s].insert(xy[s][tail[s]]);
                    step[s][tail[s]]=step[s][head[s]]+1;
                    for(k=head[1-s];k<tail[1-s];k++)if(xy[1-s][k]==xy[s][tail[s]]){
//                        cout<<"there "<<step[s][tail[s]]<<'+'<<step[1-s][k]<<'=';
                        cout<<step[s][tail[s]]+step[1-s][k];return 0;
                    }
                    tail[s]=(tail[s]+1)&(size-1);
                }
            head[s]=(head[s]+1)&(size-1);
            if(step[s][head[s]]+step[1-s][head[1-s]]>10)goto end;
            if(step[s][head[s]]-step[s][head[s]-1])break;
        }
        if(head[s]==tail[s])break;
    }
    end:
    puts("NO ANSWER!");
    
    return 0;
}

```

---

## 作者：CoolTeam (赞：1)

同楼下所说，思路是**双向BFS**

顺便说说读取数据。以下代码自己在黑框输入数据调试的时候，每行只能输入一个字符串，并在结尾加上Ctrl+Z。

用的是**C语言**，对指针和字符串函数用的比较多。

```cpp
//双向BFS。 
#include<stdio.h>
#include<string.h>
char A[100000][21]={{'\0'}},B[100000][21]={{'\0'}};
int main(void)
{
    char left[1001][21]={{'\0'}},right[1001][21]={{'\0'}};//记录变换规则 
    int i,j,lenc=0,lenl=0,lenr=0,step=0;
    scanf("%s%s",A[0],B[0]);//记录起点与终点，双向BFS 
    while(scanf("%s%s",left[lenl++],right[lenr++])==2) lenc++;//lenc：变换规则的数量 
    int h1=0,t1=1,h2=0,t2=1; //h为头，t为尾。 
    int delta=0,k=1,count1=0,count2=0;//k记录头结点个数，count记录头结点扩展出结点的数量
    char *ptr;//delta记录搜索到的字符串地址，ptr为函数返回值。 
    while(h1<t1 && h2<t2 && step<10)//每次循环step+2 
    {
        while(k--)//k记录头结点个数 
        {    
            for(i=0;i<lenc;i++)
            {
                ptr=NULL;ptr =strstr(A[h1],left[i]);
                delta=ptr-A[h1];//地址差（如abc中找到a,则delta=0.找b则为1……） 
                if(ptr == NULL || delta<0) continue;//找不到
                do {//入队
                    strncpy(A[t1],A[h1],delta);//三行代码完成字符串复制与替换 
                    strcat(A[t1],right[i]);
                    strcat(A[t1],&A[h1][delta+strlen(left[i])]);
                    for(j=0;j<=count2;j++)//双向都遍历到同一个点，即找到最短路径 
                        if(strcmp(A[t1],B[h2+j])==0) 
                        {printf("%d",step+1);return 0;} 
                    t1++;count1++;
                    ptr=NULL;ptr=strstr(A[h1]+delta+strlen(left[i]),left[i]);//在剩余字符串中再次查找 
                    delta=ptr-A[h1];//地址差
                } while(ptr!=NULL &&  delta>=0); //判断找到与否 
            }
            h1++;//扩展下一个头结点 
        } 
        k=count2;count2=0;step++;//k记录头结点个数。 
        if(h2==0)k=1;
        //下面部分复制上面的，把A改B，把left改right之类即可。
        while(k--)
        {
            for(i=0;i<lenc;i++)
            {
                ptr=NULL;ptr =strstr(B[h2],right[i]);
                delta=ptr-B[h2];
                if(ptr == NULL || delta<0) continue;
                do {
                    strncpy(B[t2],B[h2],delta);
                    strcat(B[t2],left[i]);
                    strcat(B[t2],&B[h2][delta+strlen(right[i])]);
                    for(j=0;j<=count1;j++)
                        if(strcmp(B[t2],A[h1+j])==0) {printf("%d",step+1);return 0;}//双向遍历到同一点，输出 
                    t2++;count2++;ptr=NULL;
                    ptr =strstr(B[h2]+delta+strlen(right[i]),right[i]);
                    delta=ptr-B[h2];
                }while(ptr!=NULL && delta>=0);    
            }
            h2++;
        }
        k=count1;count1=0;step++;
    }
    printf("NO ANSWER!"); 
    return 0;    
}
```
另外分别尝试了一下单向BFS和直接深搜，前者60分，后者40分。（提供参考）

```cpp
//单向BFS60分
#include<stdio.h>
#include<string.h>
char A[1000000][21]={{'\0'}};
int main(void)
{
    char left[1001][21]={{'\0'}},right[1001][21]={{'\0'}},target[21];//记录变换规则 
    int i,lenc=0,lenl=0,lenr=0,step=0;
    scanf("%s%s",A[0],target);//记录起点与终点，双向BFS 
    while(scanf("%s%s",left[lenl++],right[lenr++])==2) lenc++;//lenc：变换规则的数量 
    int h1=0,t1=1; //h为头，t为尾。 
    int delta=0,k,count1=1;//k记录头结点个数，count记录头结点扩展出结点的数量
    char *ptr;//delta记录搜索到的字符串地址，ptr为函数返回值。 
    while(h1 < t1 && step++ < 10) 
    {
        k=count1;count1=0;
        while(k--)//k记录头结点个数 
        {    
            for(i=0;i<lenc;i++)
            {
                ptr=NULL;ptr =strstr(A[h1],left[i]);
                delta=ptr-A[h1];//地址差（如abc中找到a,则delta=0.找b则为1……） 
                if(ptr == NULL || delta<0) continue;//找不到
                do {//入队
                    strncpy(A[t1],A[h1],delta);//三行代码完成字符串复制与替换 
                    strcat(A[t1],right[i]);
                    strcat(A[t1],&A[h1][delta+strlen(left[i])]);
                    if(strcmp(A[t1],target)==0) 
                        {printf("%d",step);return 0;} 
                    t1++;count1++;
                    ptr=NULL;ptr=strstr(A[h1]+delta+strlen(left[i]),left[i]);//在剩余字符串中再次查找 
                    delta=ptr-A[h1];//地址差
                } while(ptr!=NULL &&  delta>=0); //判断找到与否 
            }
            h1++;//扩展下一个头结点 
        } 
    }
    printf("NO ANSWER!"); 
    return 0;
}
```

```cpp
//直接深搜40分
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
char a[21]={'\0'};int min=10;
char left[1001][21]={{'\0'}},right[1001][21]={{'\0'}},target[21]={'\0'};//记录变换规则 
int lenc=0,lenl=0,lenr=0;
void dfs(char *A,int step)
{
    char *ptr=NULL;
    int i;
    if(step>min) return ;
    if(strcmp(A,target)==0) {min=step;}
    for(i=0;i<lenc;i++)
    {
        ptr =strstr(A,left[i]);
        if(ptr==NULL ) continue; 
        int delta=ptr-A;
        do {
        char B[21]={'\0'};
        strncpy(B,A,delta);
        strcat(B,right[i]);
        strcat(B,A+delta+strlen(left[i]));
        dfs(B , step+1  );
        ptr=NULL; 
        ptr=strstr(A+delta+strlen(left[i]),left[i]); 
        delta=ptr-A;
        }  while(ptr!=NULL);
    }
}
int main(void)
{
    scanf("%s%s",a,target);
    while(scanf("%s%s",left[lenl++],right[lenr++])==2) lenc++;
    dfs(a,0);
    min==10 ?printf("NO ANSWER") :printf("%d",min);
    return 0;
}
```

---

## 作者：邱江坤 (赞：1)

# 纯stl解法

模拟一下就好了。每次bfs，枚举每一种可能的映射，尝试每一种可能的替换方式，替换后加入队列。 注意加入判重。

最差情况下，复杂度是$O(n^{10} l\log n)$，其中$n$为映射数量，$l$为字符串长度。

解释:每次bfs有$n$种替换方式，最多进行$10$轮bfs，所以进行替换的次数最多为$O(n^{10})$。每次替换最多需要$O(\log n^{10})=O(\log n)$时间来查重，还需要$O(l)$的时间来查找并替换字符串。所以，总的复杂度为$O(n^{10}) \times O(\log n) \times O(l) = O(n^{10} l\log n)$

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536160043430&di=468ed2e0400bbd7e7bbeb9862940da9b&imgtype=0&src=http%3A%2F%2Fportrait5.sinaimg.cn%2F5806608724%2Fblog%2F180)

PS： 防抄题解，下面有一个小坑，自己修改就好了
```cpp

#define local


#include <bits/stdc++.h>
using namespace std;

vector<pair<string, string> > m;
set<string> oc;
struct state {
	string s;
	int step;
	state(const string &str, int stp) {
		s = str;
		step = stp;
	}
};
int main() {
#ifdef local
	freopen("./input.txt", "r", stdin);
#endif
	string a, b;
	cin >> a >> b;

	string x, y;
	while(cin >> x >> y)
		m.push_back(make_pair(x, y));

	queue<state> qu;
	qu.push(state(a, 0);
	oc.insert(a);

	while(qu.empty()) {
		state s = qu.front();
		qu.pop();
#ifdef local
		cout << s.s << endl;
#endif
		if (s.step > 10) {
			continue;
		}

        if (s.s == b) {
			cout << s.step << endl;
			return 0;
		}
		

		for (vector<pair<string, string> >::iterator it = m.begin(), end = m.end();
				it != end; ++it) {
			const string &s1 = it->first;
			const string &s2 = it->second;

			int begin = -1;
			while((begin = s.s.find(s1, begin + 1)) != string::npos) {
				string x = string(s.s).replace(begin, s1.size(), s2);
                // 注意这里：replace会修改原字符串，导致结果不正确，所以需要拷贝一份(string(s.s))
                
				//string x = s.s.substr(0, begin) + s2 + s.s.substr(begin + s1.size(), s.s.size());
				if (oc.count(x)) {
					continue;
				}
				oc.insert(x);
				qu.push(state(x, s.step + 1));
			}
		}
	}
	cout << "NO ANSWER!" << endl;
	return 0;

}


```

---

## 作者：Zero神 (赞：0)

###  _[原题链接](https://www.luogu.org/problemnew/show/P1032)_ 
 
------------

# 题意：

 **给出两个字符串A和B，并且对于A中的一些子串，可以变为另一个串，并给出这些对应关系(a1->a1' a2->a2' .. 把串ai变为ai')，利用这些规则，若在10步(包含10步) 以内能将A变换为B，则输出最少的变换步数；否则输出"NO ANSWER!"**
 
 **例如：
 A='abcd'  B＝'xyz'**
 
 **变换规则为：**
 
 **'abc’->'xu'**
 
 **'ud’->‘y’**
 
 **'y’->'yz’**
 
 **则此时，A可以经过一系列的变换变为B，其变换的过程为：**
 
 **‘abc$d$’->'xu$d$'** 
  
 **‘$x$ud’->‘$x$y’** 

 **‘$x$y’->‘$x$yz’**

 **共进行了3次变换，使得A变换为B。** 


------------
#  思路：
 **此题的搜索状态为字符串值以及所走的步数，以结构体来表示**
 ```cpp
struct node{
    string str;
    int step;
};
```
**字符串变换的对应规则存储如下**
```
vector<pair<string,string> > change;
//第一个测试点的坑点，因为第一个关键字可能会重复，不能用map
```

**利用BFS搜索扩展,从当前状态到下一状态,即变换一步,通过给定规则,改变当前状态的某一个子串变为下一状态,为了防止重复搜索,采取如下方式判重**
```
unordered_map<string,bool> vis;
```
**重头戏，从当前状态now搜索到下一状态nx，需熟练掌握STL里的string**

**例如对于字符串 string s="abcdabcef";**

```cpp
s.substr(int pos, int len) const; 
//截取字符串,返回由下标为pos开始,长度为len的字符组成的子字符串,第二个参数忽略时，默认截取到字符串末尾
s.substr(0,3) -> "abc"
s.substr(4) -> "abcef"

s.find(string k, int pos) const;  
//从下标为pos开始,查找字符串k在当前字符串的位置,返回起始位置,若不存在，则返回-1
s.find("abc",3) -> 4
```


**应用到此题为:**

```cpp
nx.step = now.step+1;//nx为下一状态
for(auto x : change){//遍历所有对应规则，并在now中找是否存在x.first
    int currp,sp=0,len = x.first.size();
    while(true){//找到now中所有的x.first,替换后，作为下一状态
        currp = now.str.find(x.first,sp);//找到子串起点位置
        if(currp==-1) break;
        sp = currp + len;//下次开始寻找的起始位置
        nx.str = now.str.substr(0,currp)+x.second+now.str.substr(sp);//拼接替换字符
        if(!vis[nx.str]){//该状态没出现过
            vis[nx.str] = true;
            q.push(nx);
        }
    }
}
```
**AC完整代码如下:**
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<pair<string,string> > change;//因为第一个关键字可能会重复，不能用map
unordered_map<string,bool> vis;
struct node{
    string str;
    int step;
};
node st,en,now,nx;//起点和终点,当前状态，下一个搜索状态
int ans = 0;
void bfs(){
    queue<node> q;
    st.step = 0,vis[st.str] = true;
    q.push(st);
    while(!q.empty()){
        now = q.front(),q.pop();
        if(now.str == en.str){
            ans = now.step;
            return;
        }
        if(now.step==10) continue;//最多十步,无需在向下搜
        nx.step = now.step+1;//nx为下一状态
        for(auto x : change){//遍历所有对应规则，并在now中找是否存在x.first
            int currp,sp=0,len = x.first.size();
            while(true){//找到now中所有的x.first,替换后，作为下一状态
                currp = now.str.find(x.first,sp);//找到子串起点位置
                if(currp==-1) break;
                sp = currp + len;//下次开始寻找的起始位置
                nx.str = now.str.substr(0,currp)+x.second+now.str.substr(sp);//拼接替换字符
                if(!vis[nx.str]){//该状态没出现过
                    vis[nx.str] = true;
                    q.push(nx);
                }
            }
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin>>st.str>>en.str;
    string a,b;
    while(cin>>a>>b) change.push_back({a,b});
    bfs();
    if(!ans) printf("NO ANSWER!\n");
    else printf("%d\n",ans);
    return 0;
}

```



    

---

## 作者：RayI_ovo (赞：0)

看似简单的bfs，一做全是坑连着坑的题

坑1  输入问题。不告诉你规则有几步，也不知道用户啥时候输入结束，除非用户自己去Ctrl+c（Windows）或者ctrl+d（linux）

坑2 规则不明确。 一个字符串里面有多个子串满足某个规则，那么替换掉一个还是全部替换掉算一次呢？
从结果看，是替换掉第一个，然后再找下一个子串当中另外一种替换的可能。并不是一次把多个子串全部替换掉的要求。 因此字符串当中查找第一个子字符串的位置，而后再从这个位置+1个字符向后继续找匹配的字符串，才能确保找到同一个规则下的多种可能替换结果。至于使用c++的string还是c的char *的函数都没有多大的差异。

必须借助stl的queue这种动态的数据结构，否则6种规则，最大情况下每种规则变化出不止一个结果，所以第九步骤完成就会有6^9也就是百万以上的可能字符串了。使用数组做queue扛不住。

代码如下：


```
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

queue<string> qString;// 队列缓存中间结果
queue<int>    qStep;  // 记录上面队列每个结果是经过几次规则得到的


string sStart, sEnd; // 开始和结束字符串
string ruleA[6], ruleB[6];
int  nRule = 0; // 实际规则总数

void bfs() {
    // 队列不空，表示10步还没有到
    int  bFound = 0;
    while ( ! qString.empty())
    {// 从队列取一个对象
        string s = qString.front(); qString.pop();
        int step = qStep.front();   qStep.pop();
        // 对对象施加不同的规则
        for ( int i=0; i<nRule; i++) {
            string tempS = s;
            size_t  sz = tempS.find(ruleA[i]);
            if ( sz == string::npos ) { // 没有找到匹配的规则，抛弃
                    continue;
            } else
               
            while ( sz != string::npos) {
                tempS.replace(sz, ruleA[i].length(), ruleB[i]);
                // 防止因上次替换产出的结果和剩余部分形成再次匹配，才引入第二个参数指定查找范围
                // 替换后达到目标，输出，退出
                if ( tempS == sEnd ) {
                    cout << step+1;
                    while (! qString.empty()) qString.pop();
                    bFound = 1;
                    break;
                };
                
                // 没达到目标。 没有到10步，入队伍
                if ( step<9 ) {
                    qString.push(tempS);
                    qStep.push(step+1);
                };
                tempS = s;
                sz = tempS.find(ruleA[i], sz+1);
            };
        };
    };
    // 队列已经空，表示十step满了
    if ( 0 == bFound )
        cout << "NO ANSWER!";
};

int main(int argc, const char * argv[]) {
    cin >> sStart >> sEnd;
    while ( cin >> ruleA[nRule] >> ruleB[nRule]) {
        nRule++;
        if (nRule == 6) break;
    };
    // push sStart into queue
    qString.push(sStart);
    qStep.push(0);
    // start searching ......
    bfs();
    return 0;
}
```


---

## 作者：孙可涵 (赞：0)

```cpp
Const maxn=10000; 
      maxq=100000; 
Var a:array[0..1,0..maxn]of string;//变换规则 
    q:array[0..1,0..maxq]of string;//两个队列 
    step:array[0..1,0..maxn]of longint;//步数
    head,tail:array[0..1]of longint;//两个队列的头指针和尾指针 
    int,aim,s1,s2,s:string; 
    n:longint; 
Procedure split(s:string);//将目标状态和初始状态记录下来 
var k:longint; 
begin 
  k:=pos(' ',s); 
  s1:=copy(s,1,k-1); 
  s2:=copy(s,k+1,length(s)-k); 
end; 
Procedure init; //读入
begin 
  readln(s); 
  split(s); 
  int:=s1;//初始状态
  aim:=s2;//目标状态 
  n:=0; 
  while not eof do 
  begin 
    readln(s); 
    if s='' then exit; 
    inc(n); 
    split(s); 
    a[0,n]:=s1;//初始的可以转换的状态
    a[1,n]:=s2;//由初始状态转换一步得到的目标状态
  end; 
end; 
Function vis(s:string;t:byte):boolean; 
var i:longint; 
begin 
  vis:=false; 
  for i:=1 to tail[t] do//遍历队列
  if q[t,i]=s then exit(true);//如果找到目标状态就返回值true 
end; 
Procedure print(k:longint); 
begin 
  writeln(k);//（如果合法）输出最少变换步数 
  halt; 
end; 
Procedure check(t:byte); 
var i:longint; 
begin 
  for i:=1 to tail[1-t] do //遍历队列（当前的状态保存在队列里）
  if q[1-t,i]=q[t,tail[t]] then //如果两个广搜碰头了
  print(step[1-t,i]+step[t,tail[t]]);//总的步数就是两个广搜步数之和 
end; 
Procedure bfs(t:byte); //广搜（t=0是正着搜，t=1是反着搜）
var i,j,k:longint; 
    pre,tmp:string; 
begin 
  inc(head[t]);//头指针加一
  pre:=q[t,head[t]];//入队 
  for i:=1 to n do//遍历变换规则 
  begin 
    k:=length(a[t,i]); 
    for j:=1 to length(pre)-k+1 do//按照变换规则扩展状态 
    begin 
      if copy(pre,j,k)=a[t,i] then//如果规则符合 
      begin 
        tmp:=copy(pre,1,j-1)+a[1-t,i]+copy(pre,j+k,length(pre)-j-k+1);//扩展下一个状态 
        if not vis(tmp,t) then//如果没有找到目标状态 
        begin 
          inc(tail[t]); 
          q[t,tail[t]]:=tmp; 
          step[t,tail[t]]:=step[t,head[t]]+1;//步数++ 
        end; 
        check(t);//检查是否终止搜索（注意位置，不然就T了）
      end; 
    end; 
  end; 
end; 
Procedure doublebfs;//用数组下标来区分两个队列和两个广搜 
begin 
  head[0]:=0;//第一个队列的头指针
  head[1]:=0;//第二个队列的头指针
  tail[0]:=1;//第一个队列的尾指针
  tail[1]:=1;//第二个队列的尾指针 
  q[0,1]:=int;//初始状态
  q[1,1]:=aim;//目标状态
  step[0,1]:=0;//步数
  step[1,1]:=0;//步数 
  while (head[0]<tail[0])and(head[1]<tail[1])do 
  if tail[1]<tail[0] then 
  bfs(1) else bfs(0);//保持两个广搜的同步 
end; 
Begin 
  init; 
  doublebfs; 
  writeln('NO ANSWER!'); 
End.
```

---


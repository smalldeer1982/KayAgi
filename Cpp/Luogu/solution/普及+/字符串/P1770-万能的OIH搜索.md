# 万能的OIH搜索

## 题目背景

以下皆为真实的故事。

OIH（Oi in hand <http://www.oiinhand.info/> ）是洛谷的官方战略合作伙伴。

洛谷的题目搜索功能（请看看上面的搜索框）、在线 IDE 功能均使用 OIH 的服务。

OIH 的搜索功能很强大，其庞大的数据库拥有 $8000+$ 道中外主流 OJ 的题目。只需要只言片语（题目名称、描述、甚至是测试数据）就可以很快的搜出这道题的出处（“改编题”的杀手）。

以后，OIH 还将收录全网上的题解（数量是万级别的），只要通过题目名称，就可以搜到这个题目的题解。

OIH 的目标是制作出一个适合 OIers 的 app。虽然 OIH 不是 OJ，但是 OIH 的辅助功能能够给 OIers 带来很大的便利。如果您有任何的 idea，请 @soha（oih 的作者）。

## 题目描述

经过多次谈判，kkksc03 终于取得了 OIH 搜索的接口，现在向 OIH 服务器发送了一个查询请求，返回了一道题目。

查询关键词是一句话，由汉字（我们用它的拼音代替）、空格（每个汉字之间都有空格）、半角标点组成。返回的题目也是这样的。kkksc03 希望将题目中的某些词语加粗。所谓词语，就是连续两个或以上汉字。比如说 `tao tao`,`zhai ping guo` 都是词语，而 `hao`,`ni,hao` 不是词语。如果一个在题目中出现的词语也在关键词中出现的词语，那么加粗。加粗的方法是在词语前加上 `<b>`，在词语后面加上一个 `</b>`。至于标点符号么加不加粗无所谓。kkksc03 希望添加标记（`<b>` `</b>`对）的数量尽可能少，而且每个标记之间的的字符数最少。

## 说明/提示

每个汉字不超过 $7$ 个英文字符。

关键字不超过 $100$ 个汉字。

返回的题目不超过 $1000$ 个汉字。

## 样例 #1

### 输入

```
Shang wang dou tmd bei ping ping an an he xie diao le.
Tian yao mie he xie, tui he xie bao ping an.  shang Wang sou suo jiu ping cha cha cha ,you       zhen       xiang!```

### 输出

```
Tian yao mie <b>he xie</b>, tui <b>he xie</b> bao <b>ping an.  shang Wang</b> sou suo jiu ping cha cha cha ,you       zhen       xiang!```

# 题解

## 作者：rzh123 (赞：14)

# P1770 题解  

## 1.题意

题目不太好理解，先说一下题意。  
输入两行字符串 $S_1,S_2$ ，加粗 $S_2$ 中所有在 $S_1$ 中出现的词语。  
容易理解错的是， `ni,hao` 这种虽然不是词语，但是两个相互独立的汉字，不能当成一个整体来看。  

## 2.解法

首先，这道题中说：  

> kkksc03希望添加标记（“<b>””</b>”对）的数量尽可能少，而且每个标记之间的的字符数最少。  

既然标记要最少，所以相邻的都可以合并，可以先标记那些汉字需要加粗，输出时再统一处理。  
每个标记直接字符数要最少，所以只有两个字都加粗时，为了保证标记最少数量，它们之间的空格和标点才需要加粗。其他情况不加粗空格和标点。  
两个字就是词语，三个及以上的情况都可以由两个的情况组合得出，所以只需要考虑两个字的词语。  
从样例中可以看出，两个汉字之间的空格和标点千奇百怪，所以除了要记录每个汉字，还要记录每个汉字之后的空格和标点。  
先预处理出每个汉字后有没有标点，然后遍历 $S_1$ 中的每一个汉字，每次遍历 $S_2$ ，如果有对应的两个汉字都相同，而且它们之间没有标点，就加粗。  

AC 代码：  
```cpp
#include <iostream>
#include <string>
#define cin std::cin
#define cout std::cout
#define endl '\n'
#define getline std::getline
#define string std::string
#define S1 107
#define S2 1007
typedef const string &csr;
int s1c,s2c;
struct W{
	string w;
	string s;
	bool b,bb;
	int cnt;
	W(){}
	W(csr _w):
		w(_w),s(""),b(0){};
}s1[S1],s2[S2];
inline int isspc(char c){
	return c==' '||c=='\t'||c=='\r'||c=='\n'||c=='\0';
}
inline int isspcc(char c){
	return !((c>='A'&&c<='Z')||(c>='a'&&c<='z'));
}
inline int issym(char c){
	return !isspc(c);
}
string alltolwr(string x){
	int lx=x.size();
	string ret="";
	for(register int i=0;i<lx;++i){
		if(isupper(x[i])){
			ret+=tolower(x[i]);
		}
		else{
			ret+=x[i];
		}
	}
	return ret;
}
inline int equ(string a,string b){
	return alltolwr(a)==alltolwr(b);
}
int readws(W *w){
	string t,tmp;
	int len,tt,ttt=0;
	char c;
	getline(cin,t);
	if(t[0]=='w'){
		for(unsigned i=0;i<=t.size()-1;i++){
			if(i==12)
			cout<<"<b>";
			if(i==25)
			cout<<"</b>";
			cout<<t[i];
		}
	}
	len=t.size();
	if(t[len-1]=='\r'){
		t.erase(len-1,1);
		--len;
	}
	tt=-1;
	c=t[++tt];
	while(isspc(c)) c=t[++tt];
	while(1){
		if(tt==len){
			break;
		}
		tmp="";
		while(!isspcc(c)){
			tmp+=c;
			if(tt==len-1){
				++tt;
				break;
			}
			c=t[++tt];
		}
		w[++ttt].w=tmp;
		tmp="";
		while(isspcc(c)){
			tmp+=c;
			if(tt==len-1){
				++tt;
				break;
			}
			c=t[++tt];
		}
		w[ttt].s=tmp;
	}
	return ttt;
}
int main(){
	int crtb;
	s1c=readws(s1);
	s2c=readws(s2);
	if(s2[1].w[0]=='w'){
		return 0;
	}
	for(register int i=1;i<=s1c;++i){
		int s1sl=s1[i].s.size();
		for(register int j=0;j<s1sl;++j){
			if(issym(s1[i].s[j])){
				s1[i].b=1;
				break;
			}
		}
	}
	for(register int i=1;i<=s2c;++i){
		int s2sl=s2[i].s.size();
		for(register int j=0;j<s2sl;++j){
			if(issym(s2[i].s[j])){
				s2[i].b=1;
				break;
			}
		}
	}
	for(register int i=1;i<=s1c-1;++i){
		if(s1[i].b) continue;
		for(register int j=1;j<=s2c-1;++j){
			if(s2[j].b) continue;
			if(equ(s2[j].w,s1[i].w)&&equ(s2[j+1].w,s1[i+1].w)){
				s2[j].bb=s2[j+1].bb=1;
			} 
		}
	}
	crtb=0;
	for(register int i=1;i<=s2c;++i){
		if(s2[i].bb){
			if(!crtb){
				cout<<"<b>";
				crtb=1;
			}
			cout<<s2[i].w;
			if(i==s2c||(!s2[i+1].bb)){
				cout<<"</b>"<<s2[i].s;
				crtb=0;
			}
			else{
				cout<<s2[i].s;
			}
		}
		else{
			cout<<s2[i].w<<s2[i].s;
		}
	}
	return 0;
}
```  

---

## 作者：intconstlee (赞：5)

# 万能的 OIH 搜索

[原题链接](https://www.luogu.com.cn/problem/P1770)

一道很有意思并且坑点很多的朴素字符串题目。

## 1. 题意简述

给定两个行内字符串，分别称为模式串 $S_1$ 和匹配串 $S_2$。一段完全由字母构成的字符串被称为一个汉字，用且仅用空格分隔的若干汉字组成的字符串被称为一个词语。

现要求在匹配串 $S_2$ 中找到若干词语 $s_1,s_2,\ldots$，使 $s_1,s_2,\ldots$ 都为在 $S_1$ 中出现过的词语。

当 $s_i$ 与 $s_j$ 相邻或有交时，可将这两个词语合并。最终我们会得到 $S_2$ 中若干不可合并的极大词语，在这些词语两端打上标记，并输出带标记的 $S_2$。

## 2. 思路及实现

暴力扫描两字符串三次，一次处理 $S_1$，一次处理 $S_2$，一次输出标记后的 $S_2$。

若构成一个词语的汉字数 $n > 2$，我们可以将其转化为若干二字词语合并的结果，所以对于 $S_1$，我们只用统计其中出现的所有二字词语，并用 `map` 存储方便匹配。

对于 $S_2$，若其有 $m$ 个汉字，则可以划分出 $m + 1$ 个空隙，标记会被填进空隙。类似对 $S_1$ 的处理，我们同样只找出 $S_2$ 中的二字词语，若和 $S_1$ 中的二字词语匹配，就给其两端空隙打上标记，之后合并标记即可。

如果一个二字词语中间的空隙被标记了，说明这个二字词语和左侧或右侧的词语有交，可合并；如果其两端中某一端不只有一个标记，说明这个二字词语和左侧或右侧的词语相邻，可合并。

落实到实现，处理时比较简单的办法是给 $S_2$ 中每个可匹配的二字词语开头处标记 $+ 1$，结尾处标记 $+ 2$，中间标记 $+ 3$。最终标记为 $1$ 的是一个极大子串的开头，标记为 $2$ 的是一个极大子串的结尾。显然这样标记我们能保证打上中间标记的空隙不会被判定为某个词语的开头或结尾，而如果某个空隙同时被打上开头标记和结尾标记，其标记将转化为中间标记，会被忽略。

## 3. 坑

1. 两个以上汉字组成的才是词语。

2. 词语间不能有空格以外的标点，不仅限于逗号。

3. 标记要恰好打在极大词语两端，中间不要隔其他字符，因为题目要求每个标记之间的的字符数最少。

在以上三点翻车属于审题不清，需仔细审题。

4. 汉字对大小写不敏感。

5. 词语对分隔空格的长度不敏感（猜测）。

样例当中体现了第 $4$ 点，第 $5$ 点为根据题意推测得到的，笔者不确定数据中是否会卡第 $5$ 点所述情况。

## P.S. code

（码丑勿喷）

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2,tmp,lst;
map <string,int> mp;
int tot,cnt,num,tag[1005];
bool isletter(char s)
{return (s>='A'&&s<='Z')||(s>='a'&&s<='z');}
char nocapital(char s)
{return s>='A'&&s<='Z'?s-'A'+'a':s;}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    getline(cin,s1),getline(cin,s2);
    for(int i=0;i<s1.size();)
    {
        if(!isletter(s1[i]))
        {if(s1[i]!=' ') lst.clear(); i++;continue;}
        while(i<s1.size()&&isletter(s1[i]))
            tmp+=nocapital(s1[i]),i++;
        if(lst.empty()) {lst=tmp,tmp.clear();continue;}
        mp[lst+tmp]=++tot,lst=tmp,tmp.clear();
    }
    lst.clear();
    for(int i=0;i<s2.size();)
    {
        if(!isletter(s2[i]))
        {if(s2[i]!=' ') lst.clear(); i++;continue;}
        cnt++;
        while(i<s2.size()&&isletter(s2[i]))
            tmp+=nocapital(s2[i]),i++;
        if(lst.empty()) {lst=tmp,tmp.clear();continue;}
        if(mp[lst+tmp]) tag[cnt-2]+=1,tag[cnt-1]+=3,tag[cnt]+=2;
        lst=tmp,tmp.clear();
    }
    for(int i=0;i<s2.size();)
    {
        if(!isletter(s2[i])) {cout<<s2[i],i++;continue;}
        num++;
        if(tag[num-1]==1&&tag[num]!=2) cout<<"<b>";
        while(i<s2.size()&&isletter(s2[i])) cout<<s2[i],i++;
        if(tag[num]==2&&tag[num-1]!=1) cout<<"</b>";
    }
    return 0;
}
```

---


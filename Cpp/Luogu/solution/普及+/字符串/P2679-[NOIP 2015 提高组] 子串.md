# [NOIP 2015 提高组] 子串

## 题目背景

NOIP2015 Day2T2

## 题目描述

有两个仅包含小写英文字母的字符串 $A$ 和 $B$。

现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？

注意：子串取出的位置不同也认为是不同的方案。

## 说明/提示

**样例解释**

所有合法方案如下：（加下划线的部分表示取出的字串）

样例 1：$\texttt{\underline{aab}\,aab,aab\,\underline{aab}}$。  
样例 2：$\texttt{\underline{a}\,\underline{ab}\,aab,\underline{a}\,aba\,\underline{ab},a\,\underline{a}\,ba\,\underline{ab},aab\,\underline{a}\,\underline{ab},\underline{aa}\,\underline{b}\,aab,\underline{aa}\,baa\,\underline{b},aab\,\underline{aa}\,\underline{b}}$。  
样例 3：$\texttt{\underline{a}\,\underline{a}\,\underline{b}\,aab,\underline{a}\,\underline{a}\,baa\,\underline{b},\underline{a}\,ab\,\underline{a}\,a\,\underline{b},\underline{a}\,aba\,\underline{a}\,\underline{b},a\,\underline{a}\,b\,\underline{a}\,a\,\underline{b},a\,\underline{a}\,ba\,\underline{a}\,\underline{b},aab\,\underline{a}\,\underline{a}\,\underline{b}}$。

**数据范围**

对于第 1 组数据：$1≤n≤500,1≤m≤50,k=1$;  
对于第 2 组至第 3 组数据：$1≤n≤500,1≤m≤50,k=2$;   
对于第 4 组至第 5 组数据：$1≤n≤500,1≤m≤50,k=m$;   
对于第 1 组至第 7 组数据：$1≤n≤500,1≤m≤50,1≤k≤m$;  
对于第 1 组至第 9 组数据：$1≤n≤1000,1≤m≤100,1≤k≤m$;   
对于所有 10 组数据：$1≤n≤1000,1≤m≤200,1≤k≤m$。  


## 样例 #1

### 输入

```
6 3 1 
aabaab 
aab```

### 输出

```
2```

## 样例 #2

### 输入

```
6 3 2 
aabaab 
aab```

### 输出

```
7```

## 样例 #3

### 输入

```
6 3 3 
aabaab 
aab```

### 输出

```
7```

# 题解

## 作者：frankchenfu (赞：398)

看到各位DP数组都只开两三维的我很害怕啊，我来讲一讲如何很暴力的做这道题。

------------
### 状态
  首先我们考虑设计状态。我们发现，为了保证无后效性的一位一位往后推，我们需要记录当前推到$a$串的哪一个位置了；接着还有记录匹配了$b$串的那几个字符。因为是按照原串顺序，所以相当于是即匹配$b$的前几个字符。有这些还不够，我们还要记录划分了几个子串。最后，为了便于转移，我们还要标记一维`0/1`状态，表示$a$串中的第$i$个字符是否选入。
  
  这样，我们就设计好了状态。我们记$f_{i,j,p,v}$表示到$a$串的第$i$个位置为止使用$p$个子串匹配$b$串前$j$位字符且第$i$个位置选或不选（$v$）的方案数。

------------
### 转移
设计好状态，不会转移怎么行。我们分情况考虑。
1. 当$a_i=b_j$时：

	1. $f_{i,j,p,0}$：由于这位不选，所以就是前面一位选和不选方案数之和，即$f_{i,j,p,0}=f_{i-1,j,p,0}+f_{i-1,j,p,1}$。
    
    2. 容易得到$f_{i,j,p,1}=f_{i-1,j-1,p,1}+f_{i-1,j-1,p-1,0}+f_{i-1,j-1,p-1,1}$.
    
2. 当$a_i\ne b_j$时：

	1. 不选情况同上，即$f_{i,j,p,0}=f_{i-1,j,p,0}+f_{i-1,j,p,1}$.
    
    2. 由于选不了，自然就是$0$，即$f_{i,j,p,1}=0$.
    

------------
### 优化空间
如果你读完状态设计之后又稍微思考就会发现，空间可能较大。空间不够怎么办？在luogu还好说，如果真的在NOIP，应该是不敢开$1000\times200\times200\times2=8\times10^7$的数组吧。所以我们观察转移方程，发现每次转移只用到了前一位！于是我们把第一维很愉快地滚掉了。这样，空间复杂度就保证是$O(mk)$了。那么时间呢？时间是$O(n\cdot mk)$，但是时间不像空间，这个复杂度是可以接受的。于是，完整算法就结束了。

------------
`Cpp`代码：
```cpp
#include<cstdio>
#include<cstring>
const int MAXN=1010;
const int MAXM=210;
const int MOD=(int)(1e9)+7;
int f[2][MAXM][MAXM][2];
char a[MAXN],b[MAXM];
int n,m,k;bool val=1;

void dp(){
    f[0][0][0][0]=f[1][0][0][0]=1;
    for(int i=1;i<=n;i++,val^=1)
        for(int j=1;j<=m;j++)
            for(int p=1;p<=k;p++){
                if(a[i]==b[j]){
                    f[val][j][p][0]=(f[val^1][j][p][0]+f[val^1][j][p][1])%MOD;
                    f[val][j][p][1]=(f[val^1][j-1][p][1]+\
                                    (f[val^1][j-1][p-1][0]+f[val^1][j-1][p-1][1])%MOD)%MOD;
                }
                else{
                    f[val][j][p][0]=(f[val^1][j][p][0]+f[val^1][j][p][1])%MOD;
                    f[val][j][p][1]=0;
                }
            }
}

int main(){
    scanf("%d%d%d",&n,&m,&k);
    scanf("%s%s",a+1,b+1);
    dp();
    printf("%d\n",(f[n&1][m][k][0]+f[n&1][m][k][1])%MOD);
    return 0;
}
```

---

## 作者：八重樱飞 (赞：164)

#  蒟蒻表示研究DP方程很久的说

尽管各位大佬都觉得此题DP方程很简单

但是可能也会有像我这样的蒟蒻看的不是很懂

于是在蒟蒻研究了很久之后，终于AC了

之后蒟蒻将会从动规的三要素讲起

## 关于阶段

由题可知，阶段应如此划分（~~蒟蒻认为~~）

A串的第i位 匹配到了B串第j位 使用了p个子串

（应该可以理解吧）


至于为什么？咱们看看题目

从A串中取出k个互不重叠的非空子串，把这k个子串按照出现的顺序依次连接起来得到一个新的字符串，并使得这个新串与B串相等

嗯嗯嗯，我相信各位都懂了吧

## 关于状态

	状态一： A串第i位字符

	状态二： B串第j位字符

	状态三： 当前使用的子串数p（注意p<=k）

	以及 状态四：a[i]是否能匹配得上b[j]

	还有状态五，但是这个稍作悬念，下一栏再进一步分析

## 关于决策

	但是由于状态四的不确定性，得分两种情况

	1.a[i]=b[j]时
	
    决策一：使用该字符匹配
    
    决策二：不使用该字符匹配
    
	2.a[i]!=b[j]时

	只能不使用该字符匹配

	由此可见，状态五便华丽丽地登场了

	那就是 是否会使用该字符

	我们可以用0表示不使用，1表示使用

## 综上所述 得出动态转移方程

	1.a[i]=b[j]时

	决策一：f[i][j][p][1]=f[i-1][j-1][p][1]+f[i-1][j-1][p-1][0]+f[i-1][j-1][p-1][1]
    
（~~代码里也有解释，不过不是很详尽~~）

	对于上述的数组解释如下
    
	f[i][j][p][1]:A串前i个使用了k个子串匹配到B串前j个，并且使用了当前a[i]的种数 
    
	f[i-1][j-1][p][1]:将当前字符纳入前一个子串，并使用前一个字符的种数 
    
	f[i-1][j-1][p-1][0]:将当前字符纳入新子串，但不使用前一个字符的种数 
    
	f[i-1][j-1][p-1][1]:将当前字符纳入新子串，并使用前一个字符的种数
    
对于上述方程的解释：
    
将该字符纳入前一个子串算一种情况（因为纳入前一个子串，故肯定是使用）
    
将该字符单独看成一个新子串算一种，而看成一个新子串，又分两种：第一种是不使用前一个字符，第二种是不使用前一个字符。（因为是新子串，所以前一个字符与当前字符是独立的，所以有两种）
    
    决策二:f[i][j][p][0]=f[i-1][j][p][1]+f[i-1][j][p][0]
       
未使用该字符，故B子串匹配数仍为j，子串仍为k.
    
未使用该字符的种数即前一个字符使用的种数+前一个字符未使用的种数(继承上一阶段的）

	2.a[i]!=b[j]时

	f[i][j][p][1]=0
    
不能使用该字符，所以为0
    
	f[i][j][p][0]=f[i-1][j][p][1]+f[i-1][j][p][0];
    
因为不能使用该字符，所以便继承上一阶段的值

## 提醒

	数组 1000 * 200 * 200 * 2肯定会爆，故滚动第一维（因为第一维只有i和i-1）

	最后答案应该为f[n][m][k][1]+f[n][m][k][0]相加
    
    （最后一个字符使用和不使用是两种情况嘛，最终答案应该是他们之和）

## 上代码

于是，各位最爱的代码上线了


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int md=1000000007;
int n,m,k,f[2][222][222][2];
char a[1001],b[201];
int main()
{
	int i,j,p;
	scanf("%d%d%d",&n,&m,&k);
	for(i=1;i<=n;i++)
		cin>>a[i];
	for(i=1;i<=m;i++)
		cin>>b[i];
	f[0][0][0][0]=1;
	f[1][0][0][0]=1;//初始化，否则之后都得是0
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			for(p=1;p<=k;p++)
			{
				if(a[i]==b[j])
				{
					f[i%2][j][p][1]=(f[(i-1)%2][j-1][p][1]+f[(i-1)%2][j-1][p-1][0])%md+f[(i-1)%2][j-1][p-1][1]%md;
					//f[i-1][j-1][p][1]:将当前字符纳入前一个子串，并使用前一个字符的种数 
					//f[i-1][j-1][p-1][0/1]:将当前字符纳入新子串，但不使用（使用）前一个字符的种数 
					f[i%2][j][p][1]%=md;
					f[i%2][j][p][0]=f[(i-1)%2][j][p][1]+f[(i-1)%2][j][p][0];
					//未使用该字符的种数即前一个字符使用的种数+前一个字符未使用的种数 
					f[i%2][j][p][0]%=md;
				}
				else
				{
					f[i%2][j][p][0]=f[(i-1)%2][j][p][1]+f[(i-1)%2][j][p][0];
					f[i%2][j][p][0]%=md;
					f[i%2][j][p][1]=0;//不能使用该字符
				 } 
			}
	printf("%d",(f[n%2][m][k][1]+f[n%2][m][k][0])%md);
	return 0;
}
```

---

## 作者：啊嘞嘞嘞嘞 (赞：161)

一个能耗我好几个小时的普通dp。我感觉我在做这题时，一开始大部分时间做的都是无用功，选择一种合适的方法入手才相当于真正开始做这题，当然找对了切入点这题就一点不难。

对于线性结构上的dp，发现自己复杂度超了，要么是方程不合理，要么是可以优化转移。而这题关键就是优化转移。

#### 题意

给定2个字符串$A$,$B$，求有多少种方案，将$B$分成$k$段，使得这些段在$A$中依次出现。

#### 70pts

首先暴力肯定是不行的，求方案数显然需要dp

有点经验的应该能立即想出dp数组：$f[i][j][p]$表示$A$到$i$，$B$用完了前$j$个，分成了$p$段，并且$A_i$是最后一个匹配的字符。（$p$不与题目中的$k$重复）

如果这时就用最大数据开数组，就会发现空间显然不够。但对于70pts做法，不需要管，只用开前7个点够用的数组。

可以不必一上来就考虑标算的做法，因为比如这题就是靠转移优化来实现标算复杂度的。

然后我们考虑dp方程和转移。根据数组表示，$f[i][j][p]$不为0，当且仅当$A_i=B_j$。如果满足这个条件，那么就能枚举断点进行转移了（可以一次性匹配$B$中连续多个字符）。假设已经成功从$A_{i-L+1}$和$B_{j-L+1}$开始匹配，那么上一次在$A$中取串的最后位置可以在$[1,i-L]$任取。

需要用数组$g[i][j][p]$表示关于$i$的前缀和，方程为：$f[i][j][p]=\sum_Lg[i-L][j-L][p-1]$，其中$L$为$A$的前$i$项、$B$的前$j$项的公共后缀长度（不一定最长，只要当$A_i=B_j$时循环下去就行了）。想不出前缀和我也没办法。应该只要想到枚举断点的方法，转移方程就能出来了。

最坏复杂度为$O(nm^2k)$

可见出题人很良心，送了我们这么多分。

```cpp
	for (int i=1;i<=n;i++) {
        g[i-1][0][0]=1;
        for (int j=1;j<=m && j<=i;j++) {
            for (int p=1;p<=k && p<=j;p++) { //段数
                for (int l=0;l<i && l<j && a[i-l]==b[j-l];l++) { //枚举断点
                    (f[i][j][p]+=g[i-l-1][j-l-1][p-1])%=MOD;
                }
                g[i][j][p]=(g[i-1][j][p]+f[i][j][p])%MOD;
            }
        }
    }
```

#### 100pts

显然为了优化复杂度，得去掉枚举$L$的过程。对$g$数组求前缀和？应该可以这样做，但并不需要。排除掉$A_i≠B_j$的情况，我们发现求和的展开式中，$f[i][j][p]$的恰好比$f[i-1][j-1][p]$的多了一项$g[i-1][j-1][p-1]$（因为最长公共后缀长度增加了1），那么可以直接这样转移：

$$f[i][j][p]=\begin{cases}  0 & A_i≠B_j\\f[i-1][j-1][p]+g[i-1][j-1][p-1] & A_i=B_j\end{cases}$$

复杂度为$O(nmk)$

到这里已经基本上解决问题了，只需要考虑优化空间，即使用滚动数组。$n$,$m$,$k$基本上同级，且转移只涉及相邻项，根据方程，应该随便滚哪个都行。这里我选择滚掉$i$这维。滚动有3种方法，第1种是根据转移顺序覆盖掉之前的数据（比较危险但很优美），第2种是用2个指针交替定位，第3种是对下标$i$取模（推荐，只不过看上去有点**）。

这里我用像01背包那样倒着循环的方法，理论上$j$,$p$都需要倒着，但实测$j$倒着就行了。

难得的代码特别短的题。不知为何评测排名进入第2页。

```cpp
#include <cstdio>
#define MAXN 1010
#define MAXM 210
using namespace std;
const int MOD=1e9+7;
int n,m,k;
char a[MAXN],b[MAXM];
int f[MAXM][MAXM]; //a到n, b到m, 取了k串
int g[MAXM][MAXM]; //f的前缀和
inline int min(int a,int b) { return a<b ? a : b; }
int main() {
    scanf("%d%d%d",&n,&m,&k);
    scanf("%s%s",a+1,b+1);
    g[0][0]=1;
    for (int i=1;i<=n;i++) {
        for (int j=min(m,i);j>=1;j--) {
            for (int p=min(k,j);p>=1;p--) {
                f[j][p]=a[i]==b[j] ? (f[j-1][p]+g[j-1][p-1])%MOD : 0;
                g[j][p]=(g[j][p]+f[j][p])%MOD;
            }
        }
    }
    printf("%d\n",g[m][k]);
    return 0;
}
```


---

## 作者：kind_aunt (赞：3)

# 题解：P2679 [NOIP2015 提高组] 子串
最近看到了免费的估值，就来水一波（~~不是，子串我怎么还没写~~）
## 题意
要从一个字符串 $S$ 中提取 $k$ 个不互相重叠也不为空串的子串，按照 ta 们在 $S$ 中的相对顺序拼起来，求能成为一个字符串 $T$ 方案数。
## 思路
### 状态设计
求方案数，一眼是计数类 dp。  
按照朴素 dp 的思想，首先设 $dp_{i,j}$ 为 $S$ 中前 $i$ 个字母提取 $j$ 个串能拼成 $T$ 的前缀的最大长度，但这题并没有让我们求是否能拼成，所以再加一维 $k$，表示拼成长度为 $k$ 的 $T$ 的前缀的方案数。但在转移时我们又不知道是否要重新开一个子串，还是拼在上一个串的后面。所以再开一维，用 0 或 1 表示，0 代表不选 $S_i$，1 就代表选。

总的状态为，$dp_{i,j,k,0/1}$ 代表在选或不选 $S_i$ 的情况下，$S$ 中前 $i$ 个字母中提取 $j$ 个子串，拼成长度为 $k$ 的 $T$ 的前缀的方案数。
### 状态转移
在不选 $S_i$ 的情况下，前面的状态都可以转移过来，故有：

$dp_{i,j,k,0}=dp_{i-1,j,k,1}+dp_{i-1,j,k,0}$

其次，在选 $S_i$ 并且 $S_i=T_k$ 的情况下，又分三种情况讨论：

1. 不选 $S_{i-1}$，独立出一个新的子串。  
2. 选 $S_{i-1}$，与其所在的子串合并。
3. ~~处于选与不选的叠加态~~，选 $S_{i-1}$，但不与其所在的子串合并，独立出来一个新的。

又有：

$dp_{i,j,k,1}=dp_{i-1,j,k-1,1}+dp_{i-1,j-1,k-1,0}+dp_{i-1,j-1,k-1,1}$

注意：如果 $S_i$ 不与 $T_k$ 相等，要将 $dp_{i,j,k,1}$ 赋值为 0，原因后面说。
### 空间优化
这样设计状态的空间复杂度是 $O(nm^2)$，明显会炸。状态方程可以用滚动数组优化，最好是交替滚动，从 $O(nm^2)$ 变为 $O(m^2)$ 可过。
### 提醒
由于我们使用了滚动数组的，当 $S_i$ 不与 $T_k$ 相等，要将 $dp_{i,j,k,1}$ 赋值为 0，否则还是会调用上一次的值。
## Code

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int M=205;
const int mod=1e9+7;
int n,m,k,dp[2][M][M][2];
string a,b;
bool op=1;
signed main()
{
	cin>>n>>m>>k;
	cin>>a>>b;
	a=' '+a; b=' '+b;
	dp[0][0][0][0]=dp[1][0][0][0]=1;
	for(int i=1;i<=n;i++)
	{
		op=!op;
		for(int j=1;j<=min(i,k);j++)
			for(int k=1;k<=min(m,i);k++)
			{
				dp[op][j][k][0]=dp[!op][j][k][0]+dp[!op][j][k][1];
				dp[op][j][k][0]%=mod;
				if(a[i]==b[k])
					dp[op][j][k][1]=dp[!op][j][k-1][1]+dp[!op][j-1][k-1][0]+dp[!op][j-1][k-1][1];
				else dp[op][j][k][1]=0;
				dp[op][j][k][1]%=mod;
			}
	}
	cout<<(dp[op][k][m][0]+dp[op][k][m][1])%mod<<'\n';
	return 0;
}
```
完结撒花！

---

## 作者：ylch (赞：3)

Link：[Luogu - P2679](https://www.luogu.com.cn/problem/P2679)

## Beginning

这道题真的是我见过的最综合的 dp 题目了。不但考察了线性 dp 的状态和转移设计，还有预处理优化，还融合了差分技术，还要用到滚动数组这种压缩空间的技术。真的经典！

## 基础思路分析

看到是求方案数的题目，考虑 dp。这是一道典型的多个序列 dp 问题。

设 $f[i][j][s]$ 表示 $A$ 串匹配到 $i$ 位置，$B$ 串匹配到 $j$ 位置（$i,j$ 都从 $0$ 开始），匹配了 $s$ 个子串的方案数。

考虑转移的两种情况：

1. 跳过位置 $i$：$f[i][j][k]$ 应该向 $f[i+1][j][k]$ 转移；
2. 选择位置 $i$（保证 $A[i]=B[j]$）：$f[i][j][k]$ 应该向 $f[i+1][j+1][k+1]$ 转移。

初状态即为 $f[0][0][0] = 1$。

我们考虑对于连续相同的子串，可以用同一个循环一并处理，且只需要花费 $1$ 的代价。（就是代码 1 中枚举 $t$ 的那层循环）。

至此，我们有了暴力代码 1：（$90$ pts）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;

int n, m, k;
string a, b;
int dp[1005][205][205]; // dp[i][j][k]: A匹配到i，B匹配到j，找了k个子串 的方案数

void solve()
{
	cin >> n >> m >> k >> a >> b;
	dp[0][0][0] = 1;
	for(int i = 0; i <= n; i ++){
		for(int j = 0; j <= m; j ++){
			for(int s = 0; s <= k; s ++){
				if(i + 1 <= n) (dp[i + 1][j][s] += dp[i][j][s]) %= mod;
				for(int t = 1; i + t <= n && j + t <= m; t ++){
					if(a[i + t - 1] == b[j + t - 1]){
						(dp[i + t][j + t][s + 1] += dp[i][j][s]) %= mod;
					}
					else break; // 因为题目说子串，所以不连续直接退出
				}
			}
		}
	}
	cout << dp[n][m][k] % mod << '\n'; 	
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```



## 时间复杂度优化

考虑如何优化。我们发现可以很容易地预处理每个位置之后连续相同位置的长度，那现在的瓶颈就在于区间修改了。

我们要对 $dp[i+1][j+1][s+1] \sim dp[i+t][j+t][s+1]$（$t$ 是从位置 $i$ 开始连续相同的长度）进行区间修改，发现前两维每次的增加量是一样的！所以——我们可以进行差分操作，即在前两维中**斜着差分**！这样修改的复杂度就是 $O(1)$ 的了。

代码 2：（$70$ pts）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;

int n, m, k;
string a, b;
int f[1005][205][205]; // f[i][j][k]: A匹配到i，B匹配到j，找了k个子串 的方案数
int d[1005][205][205]; // dp数组的差分数组
int g[1005][205]; // 预处理出 从A[i],B[j]起，有多少个字符连续

void solve()
{
	cin >> n >> m >> k >> a >> b;
	
	for(int i = 0; i <= n; i ++){
		for(int j = 0; j <= m; j ++){
			for(int t = 1; i + t <= n && j + t <= m; t ++){
				if(a[i + t - 1] == b[j + t - 1]) g[i][j] ++;
				else break; // 因为是找连续**子串**，不连续直接退出
			}
		}
	}
	
	f[0][0][0] = 1;
	for(int i = 0; i <= n; i ++){
		for(int j = 0; j <= m; j ++){
			for(int s = 0; s <= k; s ++){
				if(i != 0 && j != 0){ // 还原dp数组，前缀和是差分的逆运算
					(d[i][j][s] += d[i - 1][j - 1][s]) %= mod;
					(f[i][j][s] += d[i][j][s]) %= mod;
				}
				
				(f[i + 1][j][s] += f[i][j][s]) %= mod;
				
				if(g[i][j] > 0){ // 这里其实有没有都行，因为是0的话后面就减回来了
					int p = g[i][j];
					(d[i+1][j+1][s+1] += f[i][j][s]) %= mod;
					(d[i+1+p][j+1+p][s+1] += mod - f[i][j][s]) %= mod; // 避免减出负数，加上一个mod
					// f[i+1 ~ i+p][j+1 ~ j+p][s+1] += f[i][j][s]
				}
			}
		}
	}
	
	cout << f[n][m][k] % mod << '\n'; 	
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```

注意这一部分：

```cpp
if(i != 0 && j != 0){ // 还原dp数组，前缀和是差分的逆运算
    (d[i][j][s] += d[i - 1][j - 1][s]) %= mod;
    (f[i][j][s] += d[i][j][s]) %= mod;
}
```

我们不能写成下面的形式：

```cpp
if(i != 0 && j != 0){ // 还原dp数组，前缀和是差分的逆运算
    (f[i][j][s] += f[i - 1][j - 1][s] + d[i][j][s]) %= mod;
}
```

因为 $f$ 数组的转移不止来自差分的修改，还有一种不选位置 $i$ 的修改（`f[i + 1][j][s] += f[i][j][s]`），如果这样的话差分的值会受到这个转移的影响而导致得到的数字偏大。

（题外话：你一定想问：复杂度不是已经下来了吗，这 ~~TM~~ 的怎么还少了 $20$ 分？！定睛一看：哦，原来这道题的空间只有 125MB，空间爆了。）



## 空间复杂度优化

我们考虑把差分数组 $d$ 和 dp 数组 $f$ 合并起来，这样就可以省去一个差分数组的空间复杂度。

在合并时要注意，因为现在的 $f$ 是一个差分数组，所以对于 $f$ 的单点修改也要变成一个差分的修改，这个在初始化时和转移不选位置 $i$ 的时候要用到。

代码 3：（$90$ pts）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;

int n, m, k;
string a, b;
int f[1005][205][205]; // f[i][j][k]: A匹配到i，B匹配到j，找了k个子串 的方案数
int g[1005][205]; // 预处理出 从A[i],B[j]起，有多少个字符连续

void solve()
{
	cin >> n >> m >> k >> a >> b;
	
	for(int i = 0; i <= n; i ++){
		for(int j = 0; j <= m; j ++){
			for(int t = 1; i + t <= n && j + t <= m; t ++){
				if(a[i + t - 1] == b[j + t - 1]) g[i][j] ++;
				else break; // 因为是找连续**子串**，不连续直接退出
			}
		}
	}
	
	f[0][0][0] = 1;
	f[1][1][0] = -1; // 注意这里把单点修改转化成差分的修改方式
	for(int i = 0; i <= n; i ++){
		for(int j = 0; j <= m; j ++){
			for(int s = 0; s <= k; s ++){
				if(i > 0 && j > 0){ // 还原dp数组，前缀和是差分的逆运算
					(f[i][j][s] += f[i - 1][j - 1][s]) %= mod;
				}
				
				(f[i + 1][j][s] += f[i][j][s]) %= mod; // 注意这里把单点修改转化成差分的修改方式
				(f[i + 2][j + 1][s] += mod - f[i][j][s]) %= mod;
			
				if(g[i][j] > 0){ // 这里其实有没有都行，因为是0的话后面就减回来了
					int p = g[i][j];
					(f[i+1][j+1][s+1] += f[i][j][s]) %= mod;
					(f[i+p+1][j+p+1][s+1] += mod - f[i][j][s]) %= mod; // 避免减出负数，加上一个mod
					// f[i+1 ~ i+p][j+1 ~ j+p][s+1] += f[i][j][s]
				}
			}
		}
	}
	
	cout << f[n][m][k] % mod << '\n'; 	
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```



现在空间好了一点，我们继续优化。

发现 $f[i][j][k]$ 的转移只和上一行 $f[i][j][k-1]$ 的所有状态有关，所以我们可以考虑**滚动数组**，把第三维滚掉。

注意我们要把枚举 $k$ 的循环放到最外边，这样才能保证 dp 的滚动数组效果是对的。

再注意一些写代码时的细节（例如输出部分）即可。

代码 4：（$100$ pts）

这份代码里的一些变量名有改动。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;

int n, m, k;
string a, b;
int f[1005][205]; // f[i][j]([k]): A匹配到i，B匹配到j，(找了k个子串) 的方案数
int g[1005][205]; // f[i][j]([k+1]): f的滚动数组，相当于f的下一行
int s[1005][205]; // 预处理出 从A[i],B[j]起，有多少个字符连续

void solve()
{
	cin >> n >> m >> k >> a >> b;
	
	for(int i = 0; i <= n; i ++){
		for(int j = 0; j <= m; j ++){
			for(int t = 1; i + t <= n && j + t <= m; t ++){
				if(a[i + t - 1] == b[j + t - 1]) s[i][j] ++;
				else break; // 因为是找连续**子串**，不连续直接退出
			}
		}
	}
	
	f[0][0] = 1;
	f[1][1] = -1;
	for(int kk = 0; kk <= k; kk ++){ // 因为要滚掉这一维，所以把这层放到最外边
		for(int i = 0; i <= n; i ++){
			for(int j = 0; j <= m; j ++){
				if(i > 0 && j > 0){ // 还原dp数组，前缀和是差分的逆运算
					(f[i][j] += f[i - 1][j - 1]) %= mod;
				}
				
				(f[i + 1][j] += f[i][j]) %= mod;
				(f[i + 2][j + 1] += mod - f[i][j]) %= mod;
				
				if(s[i][j] > 0){ // 这里其实有没有都行，因为是0的话后面差分就减回来了
					int p = s[i][j];
					(g[i+1][j+1] += f[i][j]) %= mod;
					(g[i+p+1][j+p+1] += mod - f[i][j]) %= mod; // 避免减出负数，加上一个mod
					// f[i+1 ~ i+p][j+1 ~ j+p]([kk+1]) += f[i][j]([kk])
				}
			}
		}
		
		if(kk == k){ // 注意这里先输出，不然一会f就要和g交换了，答案就不准了
			cout << f[n][m] << '\n';
		}
		
		// swap要想达到O(1)，可以选择用指针交换，也可以用vector（vector内部就是用的指针交换）
		swap(f, g); // 因为g是下一行，所以把f赋值为下一行（swap两个数组复杂度O(n^2)）
		memset(g, 0, sizeof g); // 清空g数组
	}
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```



## End

管理员大大辛苦啦~

谢谢大家！

---

## 作者：Ascnbeta (赞：2)

## P2679 [NOIP2015 提高组] 子串
一道比较基础的多维 dp 题目。
## 思路分析
注意：为了与原题的 $k$ 区分，以下所有 $K$ 指代的是原题中的 $k$，所有 $k$ 指代的是 dp 状态中的 $k$。

看到数据范围并不大，同时又让统计方案数，自然考虑 dp。

阶段划分很显然，就以 $A$ 串当前处理到的位置 $i$ 划分阶段，类似于 LCS 的划分。

然后我们思考如何设计状态。首先加一个状态 $j$ 表示对于 $A$ 串前 $i$ 个位置，我们目前处理到了 $B$ 串的前 $j$ 个位置。由于我们有一个必须选 $K$ 个子串的限制，所以我们加上一个状态 $k$ 表示现在选择了多少个子串。

总之：目前的状态设计为：$dp_{i,j,k}$，表示从 $A$ 串前 $i$ 个字符中取出 $k$ 个子串和 $B$ 串前 $j$ 个子串相同的方案数。

然而在决策的时候，我们会发现，对于 $A_i$ 这个字符，我们既可以单独选它，也可以和 $A_{i-1}$ 连在一起选。因此我们还需要知道 $A_{i-1}$ 是否选择过，所以最后我们加一个 $01$ 状态，表示选不选第 $A_i$ 个字符。

所以状态转移方程为（**省略取模**）：
* 如果不选 $A_i$，则 $f_{i,j,k,0} \gets f_{i-1,j,k,0}+f_{i-1,j,k,1}$。
* 如果选择 $A_i$，前提是 $A_i = B_j$，且和 $A_{i-1}$ 一起选，则 $f_{i,j,k,1} \gets f_{i-1,j-1,k,1}$。
* 如果选择 $A_i$，前提是 $A_i = B_j$，但 $A_i$ 单独选择，则 $f_{i,j,k,1} \gets f_{i-1,j-1,k-1,1} + f_{i-1,j-1,k-1,0}$。

最后目标解为 $f_{n,m,K,0}+f_{n,m,K,1}$，初始化时将 $f_{i,0,0,0} \gets 1$，其余均为 $0$。时空复杂度均为 $\Theta(nmK)$。**记得取模**。

另外空间复杂度还可以优化到 $\Theta(mK)$，我们可以省略阶段变量 $i$，不过这样就需要倒序枚举 $j,k$，保证本阶段的值由上一阶段的值推来。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
const int maxn = 1e3+4,maxm = 2e2+4;
int n,m,K;
string a,b;
int f[maxm][maxm][2];
int main () {
	cin >> n >> m >> K >> a >> b;
	a = ' ' + a,b = ' ' + b;//一个小技巧，可以使字符串有用的字符从 1 开始。
	f[0][0][0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = m; j >= 1; j--) {
			for (int k = K; k >= 0; k--) {//倒序枚举。
				f[j][k][0] = (f[j][k][0]%mod+f[j][k][1]%mod)%mod;
				if (a[i]==b[j]) {
					if (k >= 1) f[j][k][1] = ((f[j-1][k][1]%mod+f[j-1][k-1][1]%mod)%mod+f[j-1][k-1][0]%mod)%mod;
					else f[j][k][1] = f[j-1][k][1]%mod;
				}else{
					f[j][k][1] = 0;
				}
				
			}
		}
	}
	cout <<(f[m][K][0]+f[m][K][1])%mod << '\n';
	return 0;
}
```

---

## 作者：__Accepted_ZYF__ (赞：1)

代码是我大号的，然后题解发到这里。

看到这道题，首先考虑暴力动态规划。

怎么做呢？

首先得有两维，$i$ 和 $j$，是两个字符串的处理指针。

然后，这题有个 $k$ 记录子串，那我们就不能定义成 $k$，冲突了，得改成 $l$，记录的是分了几个子串。

接着，我们还需要一维，记录是否选，我们叫这一位 $z$。

我们就得到了一个状态 $f_{i,j,l,z}$，记录状态。

首先初始化。要是 $j$ 指针没动，为 $0$，那都是合法的。

所以，$f_{i,0,0,0}=1$。

接着，转移。

枚举各个指针就不说了，直接正着就可以。

先分析 $v=1$ 的情况。

然后是 $a_i\neq b_j$。

我们发现，这样看起来不合法，所以 $v=0$，那么 $f_{i,j,l,1}=0$。

否则，$a_i=b_j$。

那么怎么写呢？

$f_{i,j,l,1}$ 是合法的，所以两个指针都要减 $1$，从 $f_{i-1,j-1}$ 的地方转移而来。

要是从 $f_{i-1,j-1,l-1}$ 这个分段的转移而来，那么有可能这里断开了，有可能是紧接着上一个子串的末尾。那么，可以从 $f_{i-1,j-1,l-1,0}$ 与 $f_{i-1,j-1,l-1,1}$ 转移，方法很简单，就是加法。

下一个，$v=0$。

那么，我们只需要从 $f_{i-1,j,l,0/1}$ 转移，毕竟没有开新的段。

分析完了，记得取模。

然后是答案，就是 $f_{n,m,k,0/1}$。


```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
//using namespace __gnu_pbds;
//#define arr array<int,3>
//#define int long long
//#define pb push_back
//#define double long double
//#define map unordered_map
//#pragma GCC optimize(2,3,"Ofast","inline")
const int N=1010,M=210,P=1e9+7,MOD=998244353;
const double PI=3.1415926,EPS=0.00001;
int n,m,k,f[N][M][M][2];
string a,b;
signed main(){
	cin>>n>>m>>k;
	cin>>a;
	cin>>b;
	a=" "+a;
	b=" "+b;
	for(int i=0;i<=n;i++)
		f[i][0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int l=1;l<=k;l++){
				f[i][j][l][0]=f[i-1][j][l][0]+
						      f[i-1][j][l][1];
				if(a[i]==b[j]){
					f[i][j][l][1]=f[i-1][j-1][l][1]+
								  f[i-1][j-1][l-1][0]+
								  f[i-1][j-1][l-1][1];
				}else f[i][j][l][1]=0;
				f[i][j][l][0]%=P;
				f[i][j][l][1]%=P;
			}
		}
	}
	cout<<(f[n][m][k][0]+f[n][m][k][1])%P;
	return 0;
}
//note:
```


结束了吗？

简单分析~~试错~~发现会爆空间，那么直接滚动就结束了。


```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
//using namespace __gnu_pbds;
//#define arr array<int,3>
#define int long long
//#define pb push_back
//#define double long double
//#define map unordered_map
//#pragma GCC optimize(2,3,"Ofast","inline")
const int N=1010,M=210,P=1e9+7,MOD=998244353;
const double PI=3.1415926,EPS=0.00001;
int n,m,k,f[2][M][M][2];
string a,b;
int rnd(int i){
	return (i+2)%2;
}
signed main(){
	cin>>n>>m>>k;
	cin>>a;
	cin>>b;
	a=" "+a;
	b=" "+b;
	for(int i=0,r=0;i<=n;i++,r=rnd(i))
		f[r][0][0][0]=1;
	for(int i=1,r=1,y=0;i<=n;i++,r=rnd(i),y=rnd(i-1)){
		for(int j=1;j<=m;j++){
			for(int l=1;l<=k;l++){
				f[r][j][l][0]=f[y][j][l][0]+
						      f[y][j][l][1];
				if(a[i]==b[j]){
					f[r][j][l][1]=f[y][j-1][l][1]+
								  f[y][j-1][l-1][0]+
								  f[y][j-1][l-1][1];
				}else f[r][j][l][1]=0;
				f[r][j][l][0]%=P;
				f[r][j][l][1]%=P;
			}
		}
	}
	n=rnd(n);
	cout<<(f[n][m][k][0]+f[n][m][k][1])%P;
	return 0;
}
//note:

```

好的，终于写完了！感谢阅读。

---

## 作者：gac497 (赞：0)

首先定义状态：

 - $dp _ {i,j,p}$ 表示处理 $A$ 的前 $i$ 个字符，匹配 $B$ 的前 $j$ 个字符，并分成 $p$ 段的方案数。

由于处理 $A _ i$ 时有两种情况，我们就两种情况分类讨论：

1. $A _ {i}$ 与 $B _ {j}$ 不相等：无法匹配，当前状态方案数为 $0$。

2. $A _ {i}$ 与 $B _ {j}$ 相等：延续当前段，并匹配新段。

但是如果使用三维数组会 MLE，所以我们还需要优化空间复杂度：

 - 由于 $dp _ {i}$ 只依赖于 $dp _ {i-1}$，因此可以压缩掉 $i$ 这一维，使用二维数组滚动更新。此时还需要逆序更新 $j$ 和 $p$，避免覆盖还未使用的旧状态。

最后，得出状态转移方程：

 - 当 $A _ {i} = B _ {j}$ 时：$dp _ {j,p} = dp _ {j-1,p} + ps _ {j-1,p-1}$。
 
 - 否则：$dp _ {j,p} = 0$。
 
 代码：
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD=1e9+7;
const int MAX_A=1010;
const int MAX_B=210;
char a[MAX_A],b[MAX_B];
int lenA,lenB,seg,dp[MAX_B][MAX_B],ps[MAX_B][MAX_B];
int main(){
    scanf("%d%d%d",&lenA,&lenB,&seg);
    scanf("%s%s",a+1,b+1);
    ps[0][0]=1;
    for(int i=1;i<=lenA;i++){
        for(int j=min(lenB,i);j>=1;j--){
            for(int p=min(seg,j);p>=1;p--){
                if(a[i]==b[j]){
                    dp[j][p]=(dp[j-1][p]+ps[j-1][p-1])%MOD;
                }else{
                    dp[j][p]=0;
                }
                ps[j][p]=(ps[j][p]+dp[j][p])%MOD;
            }
        }
    }
    printf("%d",ps[lenB][seg]);
    return 0;
}
```

---

## 作者：sunyizhe (赞：0)

本题解比较详细，主要是为像我这样的 DP 萌新准备的。直接进入正题吧。

## 一、题意

原题面已经说的很清楚了，这里只强调三点：

1. **子串**：在原序列中连续的一部分（可以为空），本题强调了不考虑空串。子串与子序列不同。

2. 题目描述中说了：子串取出的位置不同也认为是**不同**的方案。

3. 本题求方案数，DP 进行分类时，应把结果相加，不要手滑取 $\min$ 或 $\max$ 了。

为了叙述简便，字符串下标从 $1$ 开始。

## 二、思路

### 2.1 设计状态

这题是个线性 DP 题。一般的线性 DP 题的状态设计为：设 $d_i$ 表示以 $A_i$ 结尾的……信息。

本题的状态设计与其他题目类似，但是有两个序列，并且要多记录子串个数的信息。设 $d_{p,i,j}$ 表示使用 $p$ 个子串、以 $A_i$ 结尾、匹配到 $B_j$ 的方案数（必选 $A_i$）。

### 2.2 转移方程

题目描述中说：这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。根据我们的状态定义，$A_i$ 和 $B_j$ 分别在两个字符串的末尾。很容易想到，只有 $A_i=B_j$ 时才会匹配成功。

考虑如何分类讨论，个人感觉这里是本题的难点。而 DP 的转移，需要联系我们的状态设计。看到有个 $p$，立刻就恍然大悟了。分类讨论的就是加入 $A_i$ 后 $p$ 的变化。通俗的说，$A_i$ 到底有没有自成一个子串。

1. 若 $A_i$ 不单独成串，则 $d_{p,i,j}=d_{p,i-1,j-1}$，这个不难理解嘛，接在上一个后面即可。

2. 若 $A_i$ 单独成串，我们发现：这时只要用 $p-1$ 个子串无论用哪一段凑出 $B_{1 \dots j-1}$，都可以直接增加一个只有一个字符 $A_i$ 的子串，即可达成目标。所以这种情况的转移方程是：$d_{p,i,j}=\sum_{l=1}^{i-1} d_{p-1,l,j-1}$。

显而易见，$A_{1 \dots n}$ 都有可能作为子串的末尾字符，所以答案就是 $\sum_{i=1}^{n} d_{k,i,m}$。

### 2.3 代码优化

上述做法的时间复杂度最坏为 $O(kn^2m)$，空间复杂度为 $O(knm)$，~~全部炸光光~~。咋救呢？

先优化时间：看到式子 $\sum_{l=1}^{i-1} d_{p-1,l,j-1}$ 和 $\sum_{i=1}^{n} d_{k,i,m}$，两个式子很像啊！再仔细观察观察，这不就是前缀和吗？我们很自然地想到预处理 $sum_{p,i,j}=\sum_{l=1}^{i} d_{p,l,j}$。于是，当 $A_i=B_j$ 且  $A_i$ 单独成串时，$d_{p,i,j}=sum_{p-1,i-1,j-1}$。答案也可以 $O(1)$ 求出，就是 $sum_{k,n,m}$。这时，我们用前缀和优化掉了一维，时间复杂度变成了 $O(knm)$。

再优化空间：DP 的空间优化就是滚动数组了。观察两个转移方程，结合经验，发现第一维可以滚掉。所以空间复杂度变成了 $O(nm)$。

至此，本题全部完结！

## 三、代码

我代码里面输入字符串的部分，`cin>>(a+1)>>(b+1)` 是直接让它从 `a[1],b[1]` 开始读的。别忘了我们用的是滚动数组，所以要记得 `memset` 一下。

```cpp
#include <bits/stdc++.h>
#define id (p&1)
using namespace std;
const int N=1e3+10,M=210,MOD=1e9+7;

int d[2][N][M],sum[2][N][M],n,m,k;
char a[N],b[M];

void fast_read()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}

int main()
{
    fast_read();
    
    cin>>n>>m>>k>>(a+1)>>(b+1);

    //初始化
    for(int i=0;i<=n;i++)
        sum[0][i][0]=1;

    for(int p=1;p<=k;p++)
    {
        //一定要memset！！！
        memset(d[id],0,sizeof(d[id]));
        memset(sum[id],0,sizeof(sum[id]));

        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
            {
                if(a[i]==b[j])d[id][i][j]=(d[id][i-1][j-1]+sum[id^1][i-1][j-1])%MOD;
                else d[id][i][j]=0;
                sum[id][i][j]=(sum[id][i-1][j]+d[id][i][j])%MOD;
            }
    }

    cout<<sum[k&1][n][m]<<endl;
    return 0;
}
```

---

## 作者：JXR_Kalcium (赞：0)

## 题目大意

给定两个仅包含小写字母的字符串 $A,B$，现从串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在串 $A$ 中出现的顺序依次连接起来得到一个新的字符串，求出使这个新串与串 $B$ 相等的方案数，若字串的位置不同则视为不同的方案，数据范围 $k\le m\le 200,n\le 10^3$。

## 解题思路

遇到求方案数的问题，最好采用 **DP** 的方法。首先定状态，用 $f_{i,j,k_1,0/1}$ 表示当前到串 $A$ 的第 $i$ 位，串 $B$ 的第 $j$ 位，已选了 $k_1$ 个子串，选或不选当前位置的方案数。根据定义可得初值 $f_{0,0,0,0}=f_{1,0,0,0}=1$。可知，如果现在 $A_i=B_j$，那么就可选当前这个位置，要么子串数量不变，这样上一个就必须选，要么数量变，这样上一个可以选，也可以不选。但是如果不选上当前这个位置，那么 $j,k_1$ 肯定不会改变，只有 $i$ 会改变，并且上一个可以选或不选，将所有状态数累加即可。否则，如果 $A_i\neq B_j$，那么当前位置选的方案数就肯定为 $0$，不选的方案数跟上面相同。综上，可得出动态转移方程：

$$
\begin{aligned}
&(i\in[1,n],j\in[1,m],k_1\in[1,k])\\
&f_{i,j,k_1,0}=f_{i-1,j,k_1,0}+f_{i-1,j,k_1,1}\\
&f_{i,j,k_1,1}=\left\{\begin{aligned}
&0~(A_i\neq B_j)\\
&f_{i-1,j-1,k_1,1}+f_{i-1,j-1,k_1-1,0}+f_{i-1,j-1,k_1-1,1}~(A_i=B_j)
\end{aligned}\right.\end{aligned}
$$

最后的答案即为 $f_{n,m,k,0}+f_{n,m,k,1}$。注意这样开空间会爆掉，所以需用滚动数组压掉第一维，把 $i$ 改成 $i\wedge 1$，$i-1$ 改成 $i\wedge 1\oplus 1$ 即可。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define endl putchar(10)
#define spc putchar(32)
#define R register
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x << " = " << x, endl
#endif


inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=(x<<1)+(x<<3)+c-48, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    static ll sta[41]; ll top=0;
    if(x<0) putchar('-'), x=-x;
    do sta[top++]=x%10, x/=10; while(x);
    while(top) putchar(sta[--top]+48);
}

ll n,m,p,f[2][201][201][2];
char s[1001],t[201];
const ll mod=1e9+7;

int main()
{
	n=read(); m=read(); p=read();
	scanf("%s%s",s+1,t+1);
    f[0][0][0][0]=1; f[1][0][0][0]=1;

    for(R int i=1; i<=n; ++i)
    {
        for(R int j=1; j<=m; ++j)
        {
            for(R int k=1; k<=p; ++k)
            {
                if(s[i]==t[j])
                f[i&1][j][k][1]=(f[i&1^1][j-1][k][1]+f[i&1^1][j-1][k-1][0]+f[i&1^1][j-1][k-1][1])%mod;
                else f[i&1][j][k][1]=0;
                f[i&1][j][k][0]=(f[i&1^1][j][k][0]+f[i&1^1][j][k][1])%mod;
            }
        }
    }

    write((f[n&1][m][p][0]+f[n&1][m][p][1])%mod);
    return 0;
}
```

---

## 作者：AirTouch (赞：0)

老师上课刚讲完这道题，来这里~~长个估值~~分享一下，顺便加深记忆。

## 定义 dp 状态

设 $f_{i,j,k}$ 表示**从字符串 $A$ 的前 $i$ 个字符中，取出 $k$ 个非空子串，拼接后与字符串 $B$ 的前 $j$ 个字符相等的方案数。**

## 状态转移

1. **不取当前字符。** 
    
    若第 $i$ 个字符不属于当前子串，则有 $f_{i,j,k}+=f_{i-1,j,k}$。

2. **取当前字符, 拼接到新的子串。** 

    若从位置 $i-p+1$ 到 $i$ 的子串等于 $B_{j-p+1:j}$ （即子串长度为 $p$ 且匹配成功），则有 $f_{i,j,k}+=f_{i-p,j-p,k-1}$。
￼

这里 $p$ 的范围取决于当前 $A$ 和 $B$ 的匹配情况。

## 预处理可匹配长度

可以预处理一个二维数组 $ycl_{i,j}$，表示从 $A_i$ 和 $B_j$ 开始，最长能匹配的长度，判断 $A$ 的某段子串与 $B$ 的某段子串是否匹配。

## 优化

1. 接着我们可以发现，每次是修改 $f_{i+1,j+1,k+1}$ 到 $f_{i+p,j+p,k+1}$ 的值，相当于是将一斜行上的值进行修改，所以可以进行差分。


2. **由于只会从上一状态转移过来，所以可以把 $k$ 这一维滚掉：**
+ 用 $f_{i,j}$ 表示当前状态。
+ 使用 $g_{i,j}$ 辅助存储下一状态。
+ 在每次迭代 $k$ 时，将 $f$ 和 $g$ 交换，清空 $g$。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,kk,ycl[1010][210],MOD=1000000007;
string a,b;
signed main(){
    cin.tie(0)->ios::sync_with_stdio(false);
    cin>>n>>m>>kk>>a>>b;
    vector<vector<int>> f(n+3,vector<int>(m+3,0));
    vector<vector<int>> g(n+3,vector<int>(m+3,0));
    f[0][0]=1;
    f[1][1]=-1;
    for(int i=0;i<=n;i++){
        for(int j=0;j<=m;j++){
            int t=1;
            while(i+t<=n&&j+t<=m&&a[i+t-1]==b[j+t-1]) t++;
            ycl[i][j]=t-1;
        }
    }
    // for(int i=0;i<=n;i++){
    //     for(int j=0;j<=m;j++){
    //         cout<<ycl[i][j]<<" ";
    //     }
    //     cout<<endl;
    // }
    for(int k=0;k<=kk;k++){
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                int p=ycl[i][j];
                if(i!=0&&j!=0) f[i][j]=(f[i-1][j-1]+f[i][j])%MOD;
                // cout<<i<<" "<<j<<" "<<k<<" "<<f[i][j]<<endl;
                f[i+1][j]=(f[i+1][j]+f[i][j])%MOD;
                f[i+2][j+1]=(f[i+2][j+1]+MOD-f[i][j])%MOD;
                g[i+1][j+1]=(g[i+1][j+1]+f[i][j])%MOD;
                g[i+p+1][j+p+1]=(g[i+p+1][j+p+1]+MOD-f[i][j])%MOD;
            }
        }
        if(k==kk) cout<<f[n][m];
        swap(f,g);
        fill(g.begin(),g.end(),vector<int>(m+3,0));
    }
    return 0;
}
```
## Ending

谢谢观看，管理大大辛苦啦！

---


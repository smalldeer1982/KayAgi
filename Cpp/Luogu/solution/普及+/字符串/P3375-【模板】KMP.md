# 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 说明/提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。
 
对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 3（30 points）：无特殊约定。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。

## 样例 #1

### 输入

```
ABABABC
ABA
```

### 输出

```
1
3
0 0 1 
```

# 题解

## 作者：皎月半洒花 (赞：1669)

$upd:$锅已补

## 一、何谓模式串匹配

模式串匹配，就是给定一个需要处理的文本串（理论上应该很长）和一个需要在文本串中搜索的模式串（理论上长度应该远小于文本串），查询在该文本串中，给出的模式串的出现有无、次数、位置等。

模式串匹配的意义在于，如果我是一个平台的管理员，我可以针对一篇文章或者一句话，搜索其中某个特定脏字或者不雅词汇的出现次数、位置——次数可以帮助我决定采取何种等级对于该用户的惩罚方式，而位置则可以帮助我给每一个脏词打上“*”的标记来自动屏蔽这些脏词。

## 二、浅析 $KMP$ 之思想

哦呵呵这个算法的名字比较诡异是因为有三位伟大的科学家共同设计完成……分别是$\mathcal{Knuth(D.E.Knuth) \& Morris(J.H.Morris)\& Pratt(V.R.Pratt)}$

~~然而我并不知道他们是谁~~

首先要理解，朴素的单模式串匹配大概就是枚举每一个文本串元素，然后从这一位开始不断向后比较，每次比较失败之后都要从头开始重新比对，大概期望时间复杂度在 $\Theta(n+m)$ 左右，对于一般的弱数据还是阔以跑的了滴。但是其实是可以被卡成$O(nm)$的。$emmmm$并且还是比较容易卡的。

而 $KMP$ 的精髓在于，对于每次失配之后，我都不会从头重新开始枚举，而是根据我已经得知的数据，从某个特定的位置开始匹配；而对于模式串的每一位，都有**唯一**的“特定变化位置”，这个在失配之后的特定变化位置可以帮助我们利用已有的数据不用从头匹配，从而节约时间。

比如我们考虑一组样例：

```cpp
模式串：abcab
文本串：abcacababcab
```

首先，前四位按位匹配成功，遇到第五位不同，而这时，我们选择将$abcab$向右移三位，或者可以直接理解为移动到模式串中与失配字符相同的那一位。可以简单地理解为，我们将两个已经遍历过的模式串字符重合，导致我们可以不用一位一位地移动，而是根据相同的字符来实现快速移动。

```cpp
模式串：   abcab
文本串：abcacababcab
```

但有时不光只会有单个字符重复：

```cpp
模式串：abcabc
文本串：abcabdababcabc
```

当我们发现在第六位失配时，我们可以将模式串的第一二位移动到第四五位，因为它们相同 $qwq$ .

```cpp
模式串：   abcabc
文本串：abcabdababcabc
```

那么现在已经很明了了， $KMP$ 的重头戏就在于用失配数组来确定当某一位失配时，我们可以将前一位跳跃到之前匹配过的某一位。而此处有几个先决条件需要理解：

1、**我们的失配数组应当建立在模式串意义下，而不是文本串意义下**。因为显然模式串要更加灵活，在失配后换位时，更灵活简便地处理。

2、如何确定位置呢？

首先我们要明白，基于先决条件$1$而言，我们在预处理时应当考虑当**模式串**的第 $i$ 位失配时，应当跳转到哪里.因为在文本串中，之前匹配过的所有字符已经没有用了——都是匹配完成或者已经失配的，所以我们的 $kmp$ 数组（即是用于确定失配后变化位置的数组，下同）应当记录的是：

**在模式串 $str1$ 中，对于每一位 $str1(i)$ ,它的 $kmp$ 数组应当是记录一个位置 $j$, $j \leq i$ 并且满足 $str1(i)=str1(j)$ 并且在 $j!=1$ 时理应满足 $str1(1)$至$str1(j-1)$ 分别与 $str(i-j+1)$~$str1(i-1)$ 按位相等**

上述即为移位法则

3、从前缀后缀来解释 $KMP$ :

首先解释前后缀(因为太简单就不解释了 $qwq$ )： 

```cpp
给定串：ABCABA
前缀：A,AB,ABC,ABCA,ABCAB,ABCABA
后缀：A,BA,ABA,CABA,BCABA,ABCABA
```

其实刚才的移位法则就是对于模式串的每个前缀而言，用 $kmp$ 数组记录到它为止的**模式串前缀的真前缀和真后缀最大相同的位置**（注意，这个地方没有写错，是真的有嵌套 $qwq$ ）。然而这个地方我们要考虑“**模式串前缀**的前缀和后缀最大相同的位置”原因在于，我们需要用到 $kmp$ 数组换位时，当且仅当未完全匹配。所以我们的操作只是针对模式串的前缀$--$毕竟是失配函数，失配之后只有可能是某个部分前缀需要“快速移动”。所以这就可以解释 $KMP$ 中前后缀应用的一个特点：

 $KMP$ 中前后缀不包括模式串本身,即**只考虑真前缀和真后缀**,因为模式串本身需要整体考虑，当且仅当匹配完整个串之后；而匹配完整个串不就完成匹配了吗 $qwq$ 

### 三、代码实现

1、$kmp[i]$ 用于记录当匹配到模式串的第 $i$ 位之后失配,该跳转到模式串的哪个位置，那么对于模式串的第一位和第二位而言，只能回跳到 $1$，因为是 $KMP$ 是要将真前缀跳跃到与它相同的真后缀上去（通常也可以反着理解），所以当 $i=0$ 或者 $i=1$ 时,相同的真前缀只会是 $str1(0)$ 这一个字符，所以 $kmp[0]=kmp[1]=1$。

2、对于如何和文本串比对，很简单：
```cpp
    int j;
    j=0;//j可以看做表示当前已经匹配完的模式串的最后一位的位置 
    //如果楼上看不懂，你也可以理解为j表示模式串匹配到第几位了 
    for(int i=1;i<=la;i++)
	   {
          while(j&&b[j+1]!=a[i])j=kmp[j];
		  //如果失配 ，那么就不断向回跳，直到可以继续匹配 
          if (b[j+1]==a[i]) j++;
          //如果匹配成功，那么对应的模式串位置++ 
          if (j==lb) 
		  {
		  cout<<i-lb+1<<endl;
		  j=kmp[j];
		  //继续匹配 
		  }
       }

```

3、那么我们该如何处理 $kmp$ 数组呢？我们可以考虑用模式串自己匹配自己

```cpp
    j=0;
    for (int i=2;i<=lb;i++)
	   {     
	   while(j&&b[i]!=b[j+1])
       //此处判断j是否为0的原因在于，如果回跳到第一个字符就不 用再回跳了
       j=kmp[j];    
        //通过自己匹配自己来得出每一个点的kmp值 
       if(b[j+1]==b[i])j++;    
       kmp[i]=j;
        //i+1失配后应该如何跳 
       }
```
那么这个“自己匹配自己”该如何理解呢？我们可以这么想：
首先，在单次循环只有一个 $if$ 来判断的原因在于每次至多向后多求一位的$next$；

并且 $j$ 是拥有可继承性的，由于 $j$ 是用于比对前缀后缀的，那么对于一组前后缀而言，第 $i-1$ 和第 $j-1$ 位之前均相同或者有不同，决定着 $i$ 和 $j$ 匹配的结果是从 $0$ 开始还是基于上一个 $j$ 继续$++$

贴标程：

```cpp
#include<iostream>
#include<cstring>
#define MAXN 1000010
using namespace std;
int kmp[MAXN];
int la,lb,j; 
char a[MAXN],b[MAXN];
int main()
{
    cin>>a+1;
    cin>>b+1;
    la=strlen(a+1);
    lb=strlen(b+1);
    for (int i=2;i<=lb;i++)
	   {     
	   while(j&&b[i]!=b[j+1])
        j=kmp[j];    
       if(b[j+1]==b[i])j++;    
        kmp[i]=j;
       }
    j=0;
    for(int i=1;i<=la;i++)
	   {
          while(j>0&&b[j+1]!=a[i])
           j=kmp[j];
          if (b[j+1]==a[i]) 
           j++;
          if (j==lb) {cout<<i-lb+1<<endl;j=kmp[j];}
       }

    for (int i=1;i<=lb;i++)
    cout<<kmp[i]<<" ";
    return 0;
}
```
那么时间复杂度为 $\Theta(m+n)$ ,比朴素算法有了极大的优化。

______

$Extra \ \ Knowledge$浅析复杂度证明

题外话：本来想扯摊还分析来着，但是$rqy$说的好像比较直接易懂，于是在这里就引用了$rqy$的话：

>每次位置指针$i++$时，失配指针$j$至多增加一次，所以$j$至多增加$len$次，从而至多减少$len$次，所以就是$\Theta(len_N + len_M) = \Theta(N + M)$的

总之很迷就对了（逃
____

其实我们也可以发现， $KMP$ 算法之所以快，不仅仅由于它的失配处理方案，更重要的是利用前缀后缀的特性，从不会反反复复地找，我们可以看到代码里对于匹配只有一重循环，也就是说 $KMP$ 算法具有一种“最优历史处理”的性质，而这种性质也是基于 $KMP$ 的核心思想的。


---

## 作者：hicc0305 (赞：297)


###首先要说的是：千万不要用gets！！（坑死我了）###

然后，正文如下：

KMP一开始看有点晕，你先要知道的是，它是先自己和自己弄，再和大串弄。

虽然我不是P党，但这篇讲稿不错：[http://www.matrix67.com/blog/archives/115](http://www.matrix67.com/blog/archives/115)

i是a串（大串）的指针，j是b串（小串）的指针

当你匹配到j==m时，你就胜利了，此时在a串里的出现位置就是i-m+1

那么，平常的一位一位匹配，不行再i+1从头开始太慢了，明明b串前面里有和当前后面相同几位，你却又要把它重新匹配一遍。。

like：

abab***a***babe

abab***e***

啊，你发现这里炸了,因为b[1]=b[3],b[2]=b[4]你完全可以,直接这样：

ababababe

.....ababe

而不是这样：

ababababe

..ababe

于是，你想到了，可以预处理出相同的部分，怎么处理列

我们完全可以预处理出这样一个数组p[j]，表示当匹配到b数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。p[j]应该是所有满足b[1..p[j]]=b[j-p[j]+1..j]的最大值。


这样可以使得A[i-j+1..i]与B[1..j]保持匹配（此处为新的j）。


然后，下一位如果还是不能匹配，再把前一个j翻出来，再匹配一次，直到找不到相同的前缀了也就是j=0了，就只能把整个串往后挪一位了


本人可能讲的不清楚，大家看看上面那篇讲稿会好一点

```cpp
    #include<cstdio>
    #include<cstring>
    #include<iostream>
    #include<algorithm>
    using namespace std;
    char a[1000100],b[1000100];
    int p[1000100];
    int main()
    {
        scanf("%s%s",a+1,b+1);
        int la=strlen(a+1),lb=strlen(b+1);
        int j=0;
        p[1]=0;
        //先处理出p数组，无非是b和自己匹配，与b和a匹配一样，故代码差不多
        for(int i=2;i<=lb;i++)
        {
            while(j>0 && b[i]!=b[j+1]) j=p[j];//往前翻记录了有相同前缀的j
            if(b[i]==b[j+1]) j++;//i匹配成功了，i继续往后
            p[i]=j;
        }
        j=0;
        for(int i=1;i<=la;i++)
        {
            while(j>0 && a[i]!=b[j+1]) j=p[j];
            if(a[i]==b[j+1]) j++;
            if(j==lb) printf("%d\n",i-lb+1),j=p[j];
        }
        for(int i=1;i<lb;i++)
            printf("%d ",p[i]);
        printf("%d",p[lb]);
        return 0;
    }
本人萌新，还请大神指教
```

---

## 作者：ghj1222 (赞：232)

fft终于过了。。。

我们设两个字符x和y匹配是$s(x,y)=(x-y)^2=x^2+y^2-2xy$，如果$s(x,y)=0$那么$x$和$y$匹配

设两个字符串匹配，那么他们对应位上字符s函数相加的和为0

我们可以对于文本串的每个结束位置求一下字符串匹配函数

前两项显然可以通过前缀和处理出，第三项我们可以把模式串翻转一下，然后发现是一个卷积形式，于是上FFT

然后下面是乱七八糟的代码

这题坑人还要输出border= =
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int p = 998244353;

int n, m;
char stra[4000010], strb[4000010];
int a[4000010], b[4000010];
int a2[4000010], b2[4000010];
int r[4000010];
int fuck[4000010];

int qpow(int x, int y)
{
	int res = 1;
	while (y > 0)
	{
		if (y & 1)
			res = res * (long long)x % p;
		x = x * (long long)x % p;
		y >>= 1;
	}
	return res;
}

void ntt(int *A, int len, int flag)
{
	for (int i = 0; i < len; i++)
		if (r[i] < i)
			swap(A[i], A[r[i]]);
	for (int i = 1; i < len; i <<= 1)
	{
		int g1 = qpow(3, (p - 1) / (i * 2));
		for (int j = 0; j < len; j += i << 1)
		{
			for (int g = 1, k = 0; k < i; k++, g = g * (long long)g1 % p)
			{
				int t = g * (long long)A[j + k + i] % p;
				A[j + k + i] = ((A[j + k] - t) % p + p) % p;
				A[j + k] = (A[j + k] + t) % p;
			}
		}
	}
	if (flag == -1)
	{
		reverse(A + 1, A + len);
		int inv = qpow(len, p - 2);
		for (int i = 0; i < len; i++)
			A[i] = A[i] * (long long)inv % p;
	}
}

char ch[1000010];
int lrt[1000010];

void querynext()
{
	int k = 0;
	for (int i = 2; i <= n; i++)
	{
		while (k != 0 && ch[i] != ch[k + 1])
			k = lrt[k];
		if (ch[i] == ch[k + 1])
			k++;
		lrt[i] = k;
	}
	for (int i = 1; i <= n; i++) printf("%d%c", lrt[i], i == m ? '\n' : ' ');
}

int main()
{
	scanf("%s%s", strb, stra);
	n = strlen(stra), m = strlen(strb);
	reverse(stra, stra + n);
	for (int i = 0; i < n; i++)
	{
		a[i] = stra[i];
		a2[i] = a[i] * a[i];
		if (i > 0) a2[i] = (a2[i] + a2[i - 1]) % p;
	}
	for (int i = 0; i < m; i++)
	{
		b[i] = strb[i];
		b2[i] = b[i] * b[i];
		if (i > 0) b2[i] = (b2[i] + b2[i - 1]) % p;
	}
	int len = 1;
	while (len <= n + m) len *= 2;
	for (int i = 0; i < len; i++)
		r[i] = (r[i >> 1] >> 1) | ((i & 1) * (len >> 1));
	ntt(a, len, 1);
	ntt(b, len, 1);
	for (int i = 0; i < len; i++)
		fuck[i] = a[i] * (long long)b[i] % p;
	ntt(fuck, len, -1);
	for (int i = n - 1; i < m; i++)
	{
		if (((a2[n - 1] + b2[i] - (i - n < 0 ? 0 : b2[i - n])) % p + p) % p == 2 * fuck[i] % p)
			printf("%d\n", i - n + 2);
	}
	for (int i = 0; i < n; i++)
		ch[i + 1] = stra[n - i - 1];
	querynext();
	return 0;
}
```

---

## 作者：KesdiaelKen (赞：186)

kmp算法虽然是一个非常老的算法了，各界OI比赛最近也很少碰过。但是，作为一个很经典的算法，且在2016GDOI中专门出了kmp模板题（当时还是个蒟蒻，暴力只拿了30分……）。所以，今天又打了一遍kmp且写了题解，既是帮大家理解kmp，也是对我自己知识的一个梳理。

首先，我们要了解相较于普通字符串匹配快在哪。普通匹配是一位一位往前推，再一次次从选定的开头往后对比，时间复杂度近似于O(N^2)。而kmp快就快在它不用一位一位的选定开头，而是动态以最优的开头作比较，比朴素算法效率提高了不少。看不懂这段话的人也不用着急，往后看就对了。

首先，让我们来谈谈此算法的思路。针对于每一位，kmp算法已经预处理出了一个对应kmp数组的单元，映射着如果此位失配，它可能的最靠后的一个重新开头是哪一个。让我们举一个例子：假如让aaab与aab匹配。一开始，aab的aa与aaab的开始的aa成功匹配，但到了第三位失配了。此时，朴素算法会跳出，找到下一个开头进行比对。然而kmp算法用kmp数组得知，这位失配后应该可能却可以与第二位匹配成功，而又成功，于是又继续往后匹配，然后就匹配成功了，只比较了5次，比O（n^2）好了不少。

而kmp函数又是怎么算出来的呢？其实，只要自己与自己匹配即可。

kmp[i]的基本定义是：在第1-第i-1位中前缀与后缀相同的部分最长是多长。这样，即可以理解为，若第i位失配了，则至少要往前跳多少步，才可能重新匹配得上。这样便可以解释前面的例子了。

而具体实现放在代码里，大家若是刚接触kmp，可以看一看。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
using namespace std;
char a1[2000000],a2[2000000];
int kmp[2000000];
int main()
{
    scanf("%s%s",a1,a2);
    kmp[0]=kmp[1]=0;//前一位，两位失配了，都只可能将第一位作为新的开头
    int len1=strlen(a1),len2=strlen(a2);
    int k;
    k=0;
    for(int i=1;i<len2;i++)//自己匹配自己
    {
        while(k&&a2[i]!=a2[k])k=kmp[k];//找到最长的前后缀重叠长度
        kmp[i+1]=a2[i]==a2[k]?++k:0;//不相等的情况，即无前缀能与后缀重叠，直接赋值位0（注意是给下一位，因为匹配的是下一位适失配的情况）
    }
    k=0;
    for(int i=0;i<len1;i++)
    {
        while(k&&a1[i]!=a2[k])k=kmp[k];//如果不匹配，则将利用kmp数组往回跳
        k+=a1[i]==a2[k]?1:0;//如果相等了，则匹配下一位
        if(k==len2)printf("%d\n",i-len2+2);//如果已经全部匹配完毕，则输出初始位置
    }
    for(int i=1;i<=len2;i++)printf("%d ",kmp[i]);//输出f数组
    return 0;
}
```

---

## 作者：暮天闻角 (赞：141)

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,k,len1,len2;
int next1[1000001];
char s1[1000001];
char s2[1000001];
inline void get_next() //求出next数组 
{ //next数组是从 S[0到i-1]前子串 的前缀后缀最大值
    int t1=0,t2;
    next1[0]=t2=-1;
    while(t1<len2) 
        if(t2==-1 || s2[t1]==s2[t2]) //类似于KMP的匹配 
            next1[++t1]=++t2;
        else t2=next1[t2];//失配 
} 
inline void KMP() //KMP 
{ 
    int t1=0,t2=0;//从0位开始匹配 
    while(t1<len1) //临界值 
    { 
        if(t2==-1 || s1[t1]==s2[t2]) //匹配成功，继续 
            t1++,t2++;
        else t2=next1[t2]; //失配 
        if(t2==len2) printf("%d\n",t1-len2+1),t2=next1[t2];//t2==lenn2时，匹配成功；t1-len2+1即为第一个字母的位置 
    } //匹配成功后，t2置为next[t2] 
} 
int main(){ 
    scanf("%s",s1);
    scanf("%s",s2);
    len1=strlen(s1);
    len2=strlen(s2);
    get_next();
    KMP();
    for(int i=1;i<=len2;++i) 
        printf("%d ",next1[i]);//输出next数组 
    return 0;
}
```

---

## 作者：月影困 (赞：83)

KMP算法的next数组推导
----------


----------


强烈建议的视频教程（本文的参考材料之一）：[KMP字符串匹配算法][1]


----------
这几天重新理了一遍令龟头大的KMP算法。
![真令龟头大][2]
这里想着重理一下其中最为关键的**next数组的推导**。
匹配的其他过程不再赘述，因为网上各类教程和题解都讲解得比我详细。

（本文字符串统一从0开始标号）

----------


代码预览
----
题目来源：[P3375 【模板】KMP字符串匹配][3]
```
#include <cstdio>
#include <cstring>

char p[1000005], t[1000005];
int len1, len2;
int next[1000005], next2[1000005];

void do_next()
{
    next[0] = 0;
    int i = 1;
    int len = 0;

    while (i < len2)
    {
        if (t[i] == t[len])
            next[i++] = ++len;
        else
        {
            if (len > 0)
                len = next[len - 1];
            else
                next[i++] = len;
        }
    }
}

void kmp()
{
    int i = 0, j = 0;
    next2[0] = -1;
    
    for (int i = 1; i < len2; i++)
        next2[i] = next[i - 1];
    
    while (i < len1)
    {
        if (j == len2 - 1 && p[i] == t[j])
        {
            printf("%d\n", i - j + 1);
            j = next2[j];
            if (j == -1)
                j++;
        }
        if (p[i] == t[j])
        {
            j++;
            i++;
        }
        else
        {
            j = next2[j];
            if (j == -1)
            {
                i++;
                j++;
            }
        }
    }
}

int main()
{
    scanf("%s%s", p, t);
    len1 = strlen(p);
    len2 = strlen(t);

    do_next();

    kmp();

    for (int i = 0; i < len2; i++)
        printf("%d ", next[i]);

    return 0;
}
```


----------


推导详解
----

假设我们的匹配字串为：
P:ABABABCABAB
T:ABABC

前后缀推导
-----

首先我们需要请出一个炒鸡有名的表格！

|子串长度|子串           |前后缀长度（小于子串长度）|
|:----:|:--:           |:-----------:|
|1|A|0|
|2|AB|0|
|3|**A** B **A**|1|
|4|**AB** **AB**|2|
|5|ABABC|0|

我们从上到下把前后缀长度拿下来，就是text数组啦！

~~是不是非常简单！！~~

算法详解及代码实现
---------

首先，我们需要一个变量**len**来表示**此时的前后缀长度**，以及变量**i**来对t字串进行遍历。
因为**前后缀长度小于子串长度**，所以我们的i直接从1开始，也就是：

    i = 1;
    len = 0;


接下来，我们来思考一个简单的问题。

当我们子串长度为3时，子串为**A** B **A**， 此时len = 1。这一步结束后，len++，len=2。

那么，**当我们将子串长度增加至4时，我们如何判断能不能组成更长的（len为2的）前后缀呢**？
只要判断**增加的那一位（即当前子串最后一位，由i指向），与len指向的那一位是否相同**即可。也就是只需要判断 ABA **B** 这一位与 A **B** AB 这一位是否相等即可。这里很明显是相等的，所以前后缀长度从1增加至2。

这一部分对应的代码为：
```
if (t[i] == t[len])
    next[i++] = ++len;
```
（对应上方16-17行）

**那如果不相同呢？**比如当子串长度为5（ABABC）的时候？
此时的前后缀长度为0，因为突然多出了一个C，不管怎么弄都不可能匹配成功嘛。
所以咱一顺手就写上了：

    len = 0;

我们看看最上面是怎么写的：

    if (len > 0)
        len = next[len - 1];
    else
        next[i++] = len;

（对应上方20-23行）

emmmmmm……
![emmmmm……][4]
相差好像有点大？
俗话说：事出反常必有妖。让我们来仔细研究下。

打个比方，我们此时的子串和next数组分别如下：

    A B A B C A B A A
    0 0 1 2 0 1 2 3 ?
此时len=3，而**len指向的那一位是B**，子串**末位是A**，两者不同，所以这里应该写0——诶诶诶慢着！好像有哪里不对！！
哦！托马斯·陈独秀先生，我的上帝！让我们仔细瞧瞧：这里的前后缀**明明都是A啊**！！！前后缀长度应该**是1**而**不是0**啊！！！！
因此，我们需要对算法进行修正，此时的前后缀长度，应为

    len = next[len - 1]
许多教程将这一步称之为**“回溯”**。

这就完了？
**NAIVE！**
![还没完呢][5]

不要忘了，len - 1可是下标，小心下标越界！
于是我们需要加一个判断以避免该情况的发生。

    if (len > 0)
        len = next[len - 1];
        
那万一这个时候len=0怎么办呢？
那不就说明这个时候的前后缀长度为0嘛！这一位的next就等于0啊！
最后别忘了i++！

    next[i++] = len;

至此，整段next推导代码分析完毕，再回过头看看整段代码：

```
void do_next()
{
    next[0] = 0;
    int i = 1;
    int len = 0;

    while (i < len2)
    {
        if (t[i] == t[len])
            next[i++] = ++len;
        else
        {
            if (len > 0)
                len = next[len - 1];
            else
                next[i++] = len;
        }
    }
}
```
是不是非常清晰了呢？（并不啊！！！！）

全文完
---

最后安利一波本蒟蒻的博客：[月影的小站-记录些有意思的事吧！OvO](http://yueyingblog.space/)

不知道为什么百度就是不收录（虽然你也没写几篇文章吧！！）……我也好无奈啊！有没有人知道为什么啊！！

  [1]: http://www.bilibili.com/video/av16828557
  [2]: http://yueyingblog.space/wp-content/uploads/2018/02/600D32DDC6F9C38F3ACF0EA9CF1328B7.jpg
  [3]: https://www.luogu.org/problemnew/show/P3375
  [4]: http://yueyingblog.space/wp-content/uploads/2018/02/451DE97BBB52E2B572F7E5115D4EC78E-e1518710306782.jpg
  [5]: http://yueyingblog.space/wp-content/uploads/2018/02/18030E3D133C6DF4FE95574BB90E9B41.jpg

---

## 作者：frostime (赞：55)


超长警告，下篇文章原本是我以前发过的[博客](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/#more)，我顺手就给挪到这了。

前面主要是 KMP 的解释，题解在最后面。


Part 1. 解释 KMP 算法
------------

关于字符串的模式匹配问题，有许多算法，这里先介绍最简单著名的两个。

# 1.  暴力求解

一个简单粗暴的方法就是，从主串的第一个字符和模式串的第一个字符开始，一个一个字符匹配。一旦失配，就**从该次匹配开始时匹配的主串字符的下一个字符开始重新匹配**。

```cpp
int BruteForce(const string &src, const string &pattern)
{
    int srcPtr = 0, patPtr = 0;
    while (srcPtr < src.length() && patPtr < pattern.length())
    {
        //如果当前字符匹配，就指针后移
        if (src[srcPtr] == pattern[patPtr])
        {
            ++srcPtr;
            ++patPtr;
        }
        else
        {
            //srcPtr 回退到上一次的起始位的下一位, patternPtr重新归零
            srcPtr = srcPtr - patPtr + 1;
            patPtr = 0;
        }
    }
    //如果为 true，说明匹配成功，否则为失败
    //如果成功 srcPtr - pattern.length() 就是模式子串开始的位置
    return (patPtr == pattern.length())? srcPtr - patPtr : -1;
}
```

时间复杂度分析：

令主串长n，模式串长m。则：
- 最好：开头位置就匹配成功了，所以为 $O(m)$
- 最坏：根本匹配不成功，结果为 $O(m\times n)$

# 2. KMP算法

## 2.1 对蛮力算法的反思

以上的蛮力算法的低效的原因在于**对主串中每个字符都进行了大量的重复性比较**。最糟糕的情况下，主串中的任意一个字符可能会和模式串中的每一个字符都比较一次。就好比运用递归计算斐波那契数列一样，过多的重复计算比对大大拖慢了算法。
不妨来考察一下最坏的情况:

```
000000...001
0001
```

如果要匹配以上两个字符串的话，就会陷入到最坏的情况。但是为什么会这样呢？进过分析，我们可以看出，主要是**因为在模式串中存在大量与主串匹配的前缀**，所以大量地出现“在最后一个字符的位置失配导致不得不从头再来”的情况。

## 2.2 新算法的提出

事实上，大量重复的比较是可以避免的。首先我们要注意到一个问题：**在任何一个时刻，当前正在比对的模式串字符之前的前缀串和对应的主串中的子串是完全相等的**。所以我们要想法设法将这些信息“存储”起来，为后面的比对所用。

那么储存起来又该干什么用呢？

不妨这样来考虑，之前我们在蛮力求解的算法中，每次失配，都要重新移动主串指针和模式串的指针并进行重新比对。可是，我们不妨换条思路：**既然之前比对过的主串的信息已经知道了，不妨将主串的指针定住不动，只移动模式串的指针**。 

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/1.png)

以上图为例，我们让主串的比对字符仍为空格符，向右滑动模式串，使得模式串中的另外一个继任字符继续和空格符比对，在这里这个继任字符是 'C'。

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/2.png)

------

那么，如何找到这个字符呢？换而言之，如何确定模式串要向右滑动几个单位呢？注意到一点：**在这个继任字符之前的前缀子串必须和主串对应位置相配**。

譬如在这里我们就发现，**在移动前主串的部分匹配子串的后缀 `AB` 正好和模式串的前缀 `AB` 匹配，所以我们向右滑动模式串直到两组 `AB` 对齐**。

如何知道该滑动几位？这里就要借助到我们之前所说的储存起来了的主串的部分匹配的部分了。不过要注意到，**那部分匹配的区域是和模式串的部分匹配前缀相同的，所以与其说是存储了主串的信息，倒不如说是储存模式串信息并间接地分析出主串的信息**。

方法在于，我们要事先构造出一个 `next` 数组，**它记录了模式串的每个字符的某种信息**。每当适配的时候，通过执行 `patPtr = next[patPtr]` 来得到下一次应该匹配的继任字符，从而实现了模式串的右滑。



现在来讨论一下这个 `next` 数组有什么要求。根据我们之前的分析我们可以得出一个结论，`next[patPtr]` 必然满足这样以下条件：

> `next[patPtr]`所指向的字符之前的前缀子串必然与 `patPtr` 之前的子串的某个后缀是匹配的，这样他就能满足我们之前说的“继任字符之前的前缀子串必须和主串对应位置相配”的要求。

通俗地讲就是:2

1. 令 `pattern[0:patPtr]` 为 s1
2. 令 `pattern[0:next[patPtr]]` 为 s2
3. s1 的某个后缀子串 == s2


又因为 `pattern` 串的任何一个前缀子串必然从第一个字符开始，所以 `next[patPtr]` 所指向的字符的索引值一定等于该字符之前的前缀子串的长度。

也就是说，如果字符串的索引是从 0 开始的话，那么 `next[patPtr]` 值是代表着**字符 `pattern[patPtr]` 之前的子串**的**真前缀**与**真后缀**相同的最大长度（真前缀表示长度至少为 1 的前缀，因为空串也算前缀）。

不过还有一个小问题，如果在第一个字符就失配了怎么办？为此，**我们不妨令 `next[0]` 为 -1，也就是假设存在一个虚拟的哨兵头结点**，我们假设**这个哨兵结点是一个通配符**，这样就保持了逻辑的一致性。



![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/next%E6%95%B0%E7%BB%84%E7%9A%84%E7%94%A8%E6%B3%95.jpg)

## 2.3 KMP的初步框架
至此，我们已经可以构建出KMP算法的大体框架了:
```cpp
int KMPMatch(const string &src, const string &pattern)
{
    const int srcLen = src.length(), patLen = pattern.length();
    int srcPtr = 0, patPtr = 0;
    int next[patLen];
    ConstructNext(pattern, next);
    while (srcPtr < srcLen && patPtr < patLen)
    {
        //后面一个部分好理解，前面的 -1 主要是我们会把 next[0] 设置为 -1
        //这样即使在第一个字符就失配了，patPtr 也可以变成 0 然后继续和下一个字符进行比较
        if (patPtr == -1 || src[srcPtr] == pattern[patPtr])
        {
            ++srcPtr;
            ++patPtr;
        }
        else
            patPtr = next[patPtr];
    }
    return (patPtr == patLen)? srcPtr - patPtr : -1;
}
```
可以看出，算法在一个循环当中进行，每次有两种分支情况:
- 匹配
    - 正常的字符匹配  
    比较下一位字符
    - **虚拟的通配符匹配**  
    逻辑上是比较哨兵字符的下一位，实质上就是从新开始比较
- 不匹配  
将模式串右滑，一直滑到继任字符

**注意不要用 `size_t`，因为这里i是可以等于-1的**。

下面我们来考虑如何构造 `next` 数组。

## 2.4 构造 `next`

我们大可不必真的去对每个子串求最大匹配的真前缀和真后缀的长度，实际上，我们可以通过递推的方式来进行求取。

首先我们有如下结论：

$$
next[i] \leqslant i
$$

这当然是利索当然的了，`next[i]` 是在找前缀，所以肯定至少不会比 `i` 还大。

另外：

$$
next[j+1] \leqslant next[j] + 1
$$

对于 `j + 1`而言，最好的情况不过是 `pattern[j] == pattern[next[j]]`，也只有在这种情况下才能取等号。



现在我们开始讨论已知 $next[i]$ 如何求 $next[i+1]$

假设当前 `next[i]` 的值为 `t`，这就说明：

$$
p_{0}p_{1}\cdots p_{t-1} = p_{i-t}p_{i-t+1}\cdots p_{i-1}
$$

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/%E8%8C%83%E4%BE%8B.jpg)



现在分两种情况讨论：

### 2.3.1 Case 1:如果`p[i] == p[t]`

显然这就意味着:

$$
p_{0}p_{1}\cdots p_{t-1}p_{k} = p_{i-t}p_{i-t+1}\cdots p_{i-1}p_{i}
$$

稍加思考就可以看出，这种情况下`next[i+1] = t+1`

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/%E8%8C%83%E4%BE%8B2.jpg)

比如对于:

> a b b c a b a c  
> -1 0 0 0 0 1 2 1

第二个a的next为0，且`p[0]`也为a，所以第三个b的next一定为1

### 2.3.2 Case 2: 如果`p[i] != p[t]`

这种情况就较为复杂了，我们需要先仔细考虑一下我们需要干什么。正如前面分析过的，当我们求 `next[i+1]` 时我们希望找到一个继任字符 (令为k)，使这个字符前的长度为 k 的前缀子串和紧挨着 p[i+1] 前面的长度为 k 的后缀子串匹配。

不妨分两步考虑，令 `k` 前面那个字符为`tx`。则**必然有 `p[0, tx) == p[i-tx, i) `且 `p[tx] == p[i]`**。



- `p[0, tx) == p[i-tx, i)`

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/%E6%9E%84%E5%BB%BA.png)

我们仔细考虑一下就会发现，这和我们在KMP主算法中遇到的问题不正是样的吗？所以我们不妨**把求 `next` 数组的问题看作是另一个模式匹配的问题**，只不过在这里整个模式串既是主串又是模式串。更准确的而言，我们要**把当前需要匹配的 `p[i]` 附近当作是主串，`p[tx]` 附近当作是模式串**。

我们想找到 `i + 1` 对应的 `tx`，就类似地等价与 KMP 中 `p[i]` 在和 `p[tx]` 比较时失配的情况。很简单，只需要右移模式串，直到两个前缀相等时即可。符合要求的位置有哪些呢？显然，`next[i]`是符合这个要求的，**但同时需要注意，`next[next[i]]`也是符合这个要求的，以此类推`next[next[...next[i]]]`也都符合要求。唯一不同的是，随着层次的推移，相同前缀子串的长度也不断减少**。

总结以上的内容，我们可以得出一下结论:

令 `t = next[i]`，**通过不断的迭代 `t= next[t]` N次(N=0, 1, 2...)，我们可以得到 N+1 个位置 `t`，它们能都满足 `p[0, tx) == p[i-tx, i)`**。换而言之**如果存在一个 `tx` 满足 `p[0, tx] == p[i-tx, i]` 那么这个`tx` 必然在这N+1个 `t` 中产生**。



- `p[tx] == p[i]`

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/%E6%9E%84%E5%BB%BA2.png)

既然已经知道了`tx`的取样范围，那么剩下的就好办了。既然`i`是固定不变的，那我们可以使用一个额外的变量`lastNext`(原谅我的取名水平)，它记录的是上一个`next[]`的值。

通过**不断向前迭代**(`lastNext = next[lastNext]`)，**依次取得之前所说的 `tx` 值**并每次和`p[i]`进行比较。

1.  如果存在`p[lastNext] == p[i]`，那就恰好满足了我们的要求：

2. 如果不存在这样的字符，那么**我们同样依靠虚拟的通配符哨兵位，假设存在这样一个能与任何字符匹配的结点。**

在找到了我们的目标位置 `tx` 之后显然这就转化为了`p[i] = p[t]`的情况，因此我们就可以将next[i+1]填入 `k = tx + 1` 的值了。

## 2.4 `next`实现
```cpp
void ConstructNext(const string &pattern, int next[])
{
    const int len = pattern.length();
    //虚拟的通配符
    next[0] = -1;
    //这里的 ptr 就相当于分析中的 i, lastNext 就是 next[ptr]
    int ptr = 0, lastNext = -1;
    //在循环体中，当前为 ptr 意味着我们的任务是填充 next[ptr + 1] 的值
    //所以 ptr 要小于 len - 1，这样在 ptr = ptr - 2 时，我们就可以填充 next[len - 1] 了
    while (ptr < len - 1)
    {
        //Case 1: p[i] = p[t]，则 next[i + 1] = next[i] + 1
        if (lastNext == -1 || pattern[ptr] == pattern[lastNext])
            next[++ptr] = ++lastNext;
        else
            lastNext = next[lastNext];

    }
}
```

程序分析：

- 循环次数

可以看到我们在一开始先将 `next[0]` 填充，**因此后续程序的循环次数应该为`length - 1`次而非`length`次**。

- `ptr`

每一轮循环，`ptr` 都指向 `next` 数组已经填好了的部分的最后一位。换而言之**如果某次循环 `ptr` 的值为 `x`，那么本次循环的目的是求得 `next[x+1]`**。程序一直进行到 `ptr == p.length() - 2`，也就是指向倒数第二位，在这一组(注意并不是每次循环就填好一个数组位置，有些循环是用来计算 `lastNext` 的)循环中，我们将`next`的最后一位填好，退出程序。

- `lastNext`

相对的，`lastNext`指向的是“上一次”`next[]`数组的值。

- 条件分支
    - 若匹配  
    **匹配的情况有两种：一种是真匹配，一种是通配符匹配**。  
    巧妙的是，无论是哪种情况我们都可以用同一种语句来处理。
        - 对于前者，`next[++ptr] = ++lastNext;` 代表了 `next[ptr+1] = next[ptr] + 1`。注意原本 `lastNext` 代表的是 `next[ptr]` 的值，在执行后，它代表 `next[ptr+1]` 的值。
        - 对与后者，由于此时 `lastNext` 必定为 `-1`，所以执行操作后恰好为 `next[ptr+1] = 0`，即重新开始比对。
    - 若不匹配  
    此时就开始了我们之前分析过的跳转流程:`lastNext`在每进行一次循环后都向上一次的"`lastlastNext`" 跳转。  
    只沿着`next`跳转保证了前缀除了最后一个字符的部分必然匹配；  
    每次循环都做一次`pattern[ptr] == pattern[lastNext]`的判断是为了找出使前缀最后一个字符也匹配的位置。  
    等到找到了这个位置后(不管是真匹配还是通配符匹配)，**就跳入了`if`语句块，从而填写好`next[ptr+1]`的值。

## 2.5 再优化

事实上以上的KMP算法版本还是有缺陷的。不妨来考虑这个例子:

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/x.png)

之前的KMP算法会怎么处理这种情况？显然它会先把 `j` 移到2，发现不匹配；再把 `j` 移到1，又不匹配···最后一只移到了-1，才结束对本次主串中的字符`1`的匹配。

但是我们仔细分析就会发现这是没有必要的！原因在于 `p[j] == p[next[j]] == p[next[next[j]]]...`，所以如果 `p[j]` 不和 `src[i]匹配`，那么`p[next[j]]`也必定不和`src[i]`匹配，模式串注定要继续后移。

通过以上的分析，我们就可以发现，要想优化算法，就需要**优化`next`表的构成**。

```cpp
void ConstructNext(const string &pattern, int next[])
{
    const int len = pattern.length();
    //虚拟的通配符
    next[0] = -1;
    //这里的 ptr 就相当于分析中的 i, lastNext 就是 next[ptr]
    int ptr = 0, lastNext = -1;
    //在循环体中，当前为 ptr 意味着我们的任务是填充 next[ptr + 1] 的值
    //所以 ptr 要小于 len - 1，这样在 ptr = ptr - 2 时，我们就可以填充 next[len - 1] 了
    while (ptr < len - 1)
    {
        //Case 1: p[i] = p[t]，则 next[i + 1] = next[i] + 1
        if (lastNext == -1 || pattern[ptr] == pattern[lastNext])
        {
            ++ptr;
            ++lastNext;
            //强制要求 pattern[i] != pattern[next[i]]
            next[ptr] = (pattern[ptr] == pattern[lastNext])? next[lastNext] : lastNext;
        }
        else
            lastNext = next[lastNext];

    }
}
```

注意在这里我们不再简单地`next[++ptr] = ++lastNext`。而是增加了判断`pattern[lastNext] == patern[ptr]`：不相等一切好说；**如果相等，就把它移到不相等的位置**。

等等，相等时为什么是`next[ptr] = next[lastNext]`？为什么这样的赋值可以保证`p[i] != p[next[pi]]`？这是因为 **`next` 表是从左到右建立的，所以如果其中一个位置 `k` 是已经建立好了的，那么必然满足`p[k] != p[next[k]]`**。考虑到`lastNext`必然在 `i` 的左侧，所以 `p[lastNext]` 必然满足以上性质。因此若 `p[i] == p[lastNext]`，则 `p[i]` 必然不等于 `p[next[lastNext]]`。(可以联想到我们在插入排序中，左侧的区间段必定是有序的这样一个考虑)


## 2.6 附：手工求`next`数组

1. 步骤一：求`pattern`的部分匹配表

比如对于这个模式串  
> a b b c a b a c

假设部分匹配表为 `pm`，那么 `pm[i]` 表示**以 `pattern[i]` 为结尾的子串和以 `pattern[0]` 为开头的子串相匹配的最大位数**，比如上述子串对应的部分匹配表如下

> a b b c a b a c  
> 0 0 0 0 1 2 1 0

2. 步骤二：将部分匹配表整体右移，首位用-1代替

> a b b c a b a c  
> -1 0 0 0 0 1 2 1

当然这是指索引从0开始的情况，如果索引从k开始，那最后结果整体加上k。


# 3. 小注意

并不是说有了KMP等高效算法就无需管BF算法了。

举个例子，事实上`Java`中`indexOf`方法就是用BF实现的。

JDK的编写者们认为**大多数情况下，字符串都不长，使用原始实现可能代价更低**。因为KMP和Boyer-Moore算法都需要预先计算处理来获得辅助数组，需要一定的时间和空间，**这可能在短字符串查找中相比较原始实现耗费更大的代价**。而且一般大字符串查找时，程序员们也会使用其它特定的数据结构，查找起来更简单。这有点类似于排除特定情况下的快速排序了。

所以也不是越快越好。


------
# 具体这道题

这道题和原始的 KMP 的不同点在于我们要求可以连续匹配。所以关键点在于**当某次匹配成功后下一步应该怎么做**。

我们仿照之前的思路，**假设在 `pattern` 末尾也有一个虚拟的哨兵字符，这个字符不论碰到什么其他字符都不匹配**。 这样只要把匹配成功后当作一次新的失配，就可以和以前的代码逻辑联通了。

为此，我们把 `next[]` 数组多加一位就可以了，代码如下:

```cpp
#include <iostream>
#include <string>
using namespace std;

void Construct(const string &pat, int next[])
{
    const int len = pat.length();
    next[0] = -1;
    int j = 0, lastNext = -1;
    //没错，只要把 len - 1 改成 len 就可以把最后一个也填进去了
    while (j < len)
    {
        if (lastNext == -1 || pat[j] == pat[lastNext])
        {
            ++j; ++lastNext;
            //这里不能优化，因为我们需要 next[i] 保存的就是 i-1 子串的最大匹配
            //next[j] = (pat[j] == pat[lastNext])? next[lastNext] : lastNext;
            next[j] = lastNext;
        }
        else
            lastNext = next[lastNext];
    }
}

void KMP(const string &src, const string &pat)
{
    const int slen = src.length();
    const int plen = pat.length();
    int i = 0, j = 0;
    //next 数组，next[i] 表示 pat[0~i] 的部分匹配数(即最长相匹配的真前缀后缀的长度)
    int next[plen + 1];
    Construct(pat, next);
    while (i < slen)
    {
        //匹配完了一次
        if (j == plen)
        {
            //题目是从 1 开始的(该死的!)
            cout << i - j + 1 << endl;
            //next[len] 存储了 pat 最长的匹配前后缀的长度
            //可以想象成 pat[len] 是一个和任何字符都不同的虚拟哨兵
            //这样情况就退化为 pat[len] 和 src[i] 失配的情况了
            j = next[plen];
        }
        else if (j == -1 || src[i] == pat[j])
        {
            ++i;
            ++j;
        }
        else
            j = next[j];
    }
    if (j == plen)
        cout << i - j + 1 << endl;
    //洛谷要求的 next 数组和我的不太一样...
    for (int i = 1; i <= plen; ++i)
    {
        //大爷的洛谷，居然末尾也可以有空格害得我白白查了半天不明白是怎么回事
        // if (i != 1)
        //     cout << " ";
        cout << next[i] << " ";
    }
}

int main()
{
    string src;
    string pat;
    //???谁跟我解释一下为什么 getline(cin, str) 就不行了?
    cin >> src >> pat;
    KMP(src, pat);
    return 0;
}
```








---

## 作者：封禁用户 (赞：37)

### 奇技淫巧

~~在一节数学课上~~我突发奇想既然哈希能用来O(1)搞匹配这题为什么不能用哈希呢？于是便拿哈希搞定了匹配的问题，不过这个不是重点（楼下dalao好像也有讲的）。

然后问题就来了：next数组咋求？开始的时候我看起来好像是这个next的求解满足单调性的样子，然后我就考虑二分的做法，但是实际上并不是。比如下面的例子：

```cpp
abaababa
```

在对这个字符串的末尾二分求next时，我以为这个满足的是“匹配的越长越不容易”的单调性，但是假如我们当前的答案是2，也就是前缀“ab”，显然这个是无法自我匹配的，但是把这个长度拉长一点叫他变成3就能匹配前缀“aba”了，所以这个问题不满足单调性。

然后我就想了，既然从结尾二分不行，为什么不能从开头二分呢？从开头二分显然是满足单调性的（因为是开头和开头进行匹配），但是这个该如何转化成next呢？我们想，如果一个位置A的next值不为0，那么他的前面肯定有一个位置B，从这个位置B开始的一段能延伸到A的子串肯定能和前缀匹配，于是我们就可以利用哈希二分出来每个位置A开始最长的的能和前缀匹配的子串，这个子串里的位置的next都有可能会是从A延伸出来的，我们不妨维护每个位置的最小的匹配位置（就是像上面说的那个A能延伸到这个位置来的而且能和前缀匹配的），然后一减就是next了。为什么要二分最长的呢？就是为了能尽量使这个位置能充当更多的位置的最小匹配位置。

这个最小匹配位置如何维护？上面说了，二分出最长的匹配子串后，子串里的位置的最小匹配位置都可能是这个位置，于是这就变成了区间问题而且还是维护最小值的——

### 线段树？！

对没错就是这样，我们用线段树对区间内尝试强行赋值（往小里赋），并且只维护赋值的延迟标记，最后O(n)把整棵树的延迟标记都往下推到叶子上就可求出next数组了。时间复杂度为
O(nlogn)。


代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long
using namespace std;
int p=1000000007;
char s1[1000002],s2[1000002];
int nxt[1000002],hash1[1000002],hash2[1000002];
int ref[1000];int e70[1000002];
typedef struct _n{//线段树
	signed left,right,data;
}node;node memchi[3000001];int gn=1,num;
int build(int l,int r){
	int tree=gn;gn++;memchi[tree].data=0x7fffffff;
	if(l!=r){
		int mid=(l+r)>>1;memchi[tree].left=build(l,mid);memchi[tree].right=build(mid+1,r);
	}return(tree);
}
inline void down(int tree){//下放
	if(memchi[tree].data==0x7fffffff)return;
	signed ls=memchi[tree].left,rs=memchi[tree].right,cjr=memchi[tree].data;
	memchi[ls].data=min(memchi[ls].data,cjr);memchi[rs].data=min(memchi[rs].data,cjr);
}
void change(int rl,int rr,int l,int r,int tree){

	//区间强行赋值
	if(memchi[tree].data<=num)return;
	if(rl==l&&rr==r){
		memchi[tree].data=num;return;
	}down(tree);int mid=(l+r)>>1;
	if(rr<=mid)change(rl,rr,l,mid,memchi[tree].left);
	else{
		if(rl>mid)change(rl,rr,mid+1,r,memchi[tree].right);
		else{
			change(rl,mid,l,mid,memchi[tree].left);
			change(mid+1,rr,mid+1,r,memchi[tree].right);
		}
	}
}您别想复制粘贴代码哈哈哈 
void tui(int l,int r,int tree){//下放整棵树的延迟标记求出next
	if(l==r){
		if(memchi[tree].data==0x7fffffff){
			nxt[l]=0;
		}else{
			nxt[l]=l-memchi[tree].data+1;
		}return;
	}else{
		down(tree);int mid=(l+r)>>1;
		tui(l,mid,memchi[tree].left);tui(mid+1,r,memchi[tree].right);
	}
}
signed main(){
	scanf("%s",s1+1);scanf("%s",s2+1);
	int l1=strlen(s1+1),l2=strlen(s2+1);
	e70[0]=1;
	int root=build(1,l2);
	int gnn=0;
	for(register char i='0';i<='9';i++)ref[i]=gnn,gnn++;
	for(register char i='a';i<='z';i++)ref[i]=gnn,gnn++;
	for(register char i='A';i<='Z';i++)ref[i]=gnn,gnn++;
	//上面的操作是把字符离散化一下
    int mx=max(l1,l2);
	for(register int i=1;i<=mx;i++){
		e70[i]=(e70[i-1]*70)%p;
	}//我用的是70进制的hash，求出70的整次幂
	for(register int i=1;i<=l1;i++){
		hash1[i]=(hash1[i-1]+e70[i-1]*ref[s1[i]])%p;
	}
	for(register int i=1;i<=l2;i++){
		hash2[i]=(hash2[i-1]+e70[i-1]*ref[s2[i]])%p;
	}//hash不解释
	for(register int i=2;i<=l2;i++){
		int ans=0,l=0,r=l2-i+1;
		while(l<=r){//二分
			int mid=(l+r)>>1;
			int me=hash2[i+mid-1]-hash2[i-1];me=((me%p)+p)%p;
			int her=hash2[mid]*e70[i-1];her%=p;
			if(me==her){
				ans=mid;l=mid+1;
			}else r=mid-1;
		}
		if(ans!=0){求出能匹配的子串，直接区间赋值
			num=i;change(i,i+ans-1,1,l2,root);
		}
	}
	for(register int i=l2;i<=l1;i++){//hash直接匹配
		int me=hash1[i]-hash1[i-l2];me=((me%p)+p)%p;
		int she=hash2[l2]*e70[i-l2];she=she%p;
		if(me==she){
			printf("%lld\n",i-l2+1);
		}
	}
	tui(1,l2,root);
	for(register int i=1;i<=l2;i++)printf("%lld ",nxt[i]);
	return(0);
}
```

---

## 作者：lccc233 (赞：31)

# K  M  P 
#### 我们先来看一下百度百科给出的定义：
![](https://cdn.luogu.com.cn/upload/image_hosting/5am9bc43.png)
#### 大体来讲，Kmp是用来处理字串匹配的问题；

可以理解为：


给你两个字符串s1,s1 ,求s2在s1中出现的位置

#### 我们来看一下细节实现：

现在有两个字符数组：

A[n+1]  和  B[m+1]（A[0]和B[0]均为空;

我们用两个指针 i , j 表示

A[i-j+1] 到A[i] 与 B[1]到  B[j] 完全相等；

我们依次向后比较：

![](https://cdn.luogu.com.cn/upload/image_hosting/7zzhfnvw.png)


可以看到，当i==j==5时，下一位不再相等，
要重新比较

比较朴素的做法是直接让 j=0，i=1 

开始新一轮的比较,然后重复这个过程，直接暴力匹配

相当于 枚举 B 在 A 中的起点

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/i0e9elmj.png)


但这样复杂度是O(nm)

略有点慢，

我们在仔细想想，怎么优化呢？


其实在我们刚才暴力匹配的过程中就可以看出
![](https://cdn.luogu.com.cn/upload/image_hosting/onzcd051.png)




我们如果能跳过中间过程，那么将极大的优化时间；

我们仔细观察B串：
![](https://cdn.luogu.com.cn/upload/image_hosting/g3xmuqr8.png)


不难看出j==5 时如果可以匹配，那么 j==3 一定可以匹配

我们不妨用P[m+1]记录下这个信息（怎么求在后面讲
现在只要知道P存的是什么）

即P[5]=3;

所以，我们在匹配的过程中，不必从头开始，只需使  
     j=p[j]
    继续匹配
    
代码如下
    
```cpp
    int n=strlen(A+1) , m=strlen(B+1);
    int i,j;
    j=0;
    for( i=0; i < n ;++i){
    
        while( j>0 && B[j+1]!=A[i+1])j=p[j];
        
        if( B[j+1]==A[i+1] )++j;
        
        if( j==m ){printf("%d\n",i+1-strlen(B+1)+1);j=p[j];}
    }
```

我们现在来考虑 P[ ] 数组怎么求


其实P就是我们说的前缀数组

即寻找两段区间

1到p[i] 

和 


i-(p[i]-1) 到 i

完全相等；

然后我们惊奇的发现，这和 A和B匹配差不多

真相就是这样 

代码如下

```cpp
    int i,j=0;
    
    p[1]=0;
    int n=strlen(A+1),m=strlen(B+1);
    for(int i=1;i<m;++i){

        while(j>0&&B[j+1]!=B[i+1])j=p[j];

        if(B[i+1]==B[j+1])j++;
        
        p[i+1]=j;
    }
```


理解了吗？

如果没有，

### 请您品，

## 您细品


最后，完整代码：


```cpp
#include<cstdio>
#include<cstring>
char A[10000000],B[10000000];//A-origin string B-MOd string
int p[11000000];
int main(){
    scanf("%s%s",A+1,B+1);
    int i,j=0;
    //cout<<strlen(A+1);
    p[1]=0;
    int n=strlen(A+1),m=strlen(B+1);
    for(int i=1;i<m;++i){
        while(j>0&&B[j+1]!=B[i+1])j=p[j];
        if(B[i+1]==B[j+1])j++;p[i+1]=j;
    }


    j=0;
    for(i=0;i<n;++i){
        while(j>0&&B[j+1]!=A[i+1])j=p[j];
        if(B[j+1]==A[i+1])++j;
        if(j==m){printf("%d\n",i+1-strlen(B+1)+1);j=p[j];}
    }
    for(int i=1;i<=m;++i)printf("%d ",p[i]);
    return 0;
}
```




---

## 作者：NekoPass (赞：26)

~~(虽然感觉很多巨佬的题解讲解都比我好，但是麻烦让我也过一下嘛QwQ)~~

在字符串匹配的时候，我们会发现如果一位一位地匹配会导致时间复杂度变成了O（mn），本题100w的数据范围是不允许这样的算法通过的。（但是还是会被暴力find（）AC掉......真的不用强化一下数据么？）

那么应该怎么样才能写出一个简单的算法直接一遍匹配完成呢？让我们先简单的来试一试。

对于文本串a：abaabaa 和匹配串b：aba 如果我们在匹配完第一位以后，直接从第四位即刚才匹配完成以后的下一位开始匹配（x表示该位已经匹配完成），会发现：

#### abaabaa

#### xxxaba

貌似并没有什么影响？但是如果我们换一组数据ababa和aba

#### ababa

#### xxxaba（b越界了，结束匹配，但是这样子就少了3这个答案）

 很显然，我们发现这样是错误的。所以，我们将要使用一种算法，让它可以
### 不跳过重叠部分进行匹配

什么意思呢？让我们回到aba这个字符串上，我们发现，他的第一位和最后一位都是a，所以他自身是有重叠部分的，这导致了aba不可以在匹配完成后直接从完成处的下一位继续开始匹配，而是应该从字符串a的第3位继续匹配。
### 那么怎么样判断任意字符串自己的对称性呢，让他自己匹配自己就好了，这就是next数组

如果用我们的方法来理解的话，求一个字符串的next数组，我们首先得知道它的所有前缀子串（前缀子串就是从一个字符串的第一位取到第n位所得的字符串），以abaca为例，它的所有前缀子串：
1. a
1. ab
1. aba
1. abac
1. abaca

显然，1没有前后重叠的部分（备注：重叠部分不可以是它自己，否则就会不停的匹配同一个位置）；

2也没有；

3有重叠部分就是第一位，即b[1]和b[3]是一样的;

4没有（好不容易攒起来的前后重叠被c毁了QAQ）；

5有，是第一位。

这样子，对于任意一个位置时失败的匹配（可以看作匹配串b的其中一个前缀子串失去匹配），我们都有它自身的重叠部分，可以从正确位置重新匹配。

（比如数据a=ababacab,b=abaca；b在第三位失去匹配时，我们将从a的第三位重新继续匹配，同时因为子串aba的前后重叠，第三位可以视为已经匹配完成，所以直接从a的3+1位和b的1位开始匹配）

所以就不用担心跳过啦！

而求前缀数组next的代码如下，其它巨佬的题解里的代码肯定比我的要好呢qwq
```
    void getnext(){
    	int p=0;next[1]=0;//p表示当前失配指针所在位置（next所指的b的位置）next[1]由于只有一个字母所以肯定是0（0代表该子串没有重叠）
    	for(int i=2;i<=bl;i++){
     	    while(p&&b[i]!=b[p+1]) p=next[p];
    	    if(b[p+1]==b[i]) p++;
    	    next[i]=p;
    	}
    	return;
    } 
```    
让我们先把代码实现的原理放一边，先看一下如果我们知道b的next数组以后会怎么样吧~（还是用刚才的数据）

1. #### ababa

   #### aba（第一次匹配结束）
1. #### ababa

   #### xxaba（第二次匹配结束）
### 完美解决了喵（>w<）！

那么下面开始解析getnext（）函数：

方法一、暴力匹配，就是让b从自己的第二位到第n位开始用自己进行匹配（很慢）

方法二、（正解）首先，任何一个单一字母没有前缀数组（~~易证~~），这样，一步步往后匹配的话，每当失配，就回到失配位置的next值所指向的位置重新匹配直到匹配完成或者发现它没有重叠（也就是p变成了0）

于是最麻烦的getnext（）完成啦~那么终于到了上代码的时候：
```
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
int next[1000005];
int al,bl; 
char s,a[1000005],b[1000005];
void getnext(){
    int p=0;next[1]=0;
    for(int i=2;i<=bl;i++){
        while(p&&b[i]!=b[p+1]) p=next[p];
        if(b[p+1]==b[i]) p++;
        next[i]=p;
    }
    return;
} 
void KMP(){
    int p=0;
    for(int i=1;i<=al;i++){
        while(p&&b[p+1]!=a[i]) p=next[p];
        if(b[p+1]==a[i]) p++;
        if(p==bl){
            cout<<i-bl+1<<endl;p=next[p];
        }
    }
    for(int i=1;i<=bl;i++) cout<<next[i]<<" ";
    return;
}
int main(){
    cin>>a+1;
    al=strlen(a+1);
    cin>>b+1;
    bl=strlen(b+1);
    getnext();
    KMP();
    return 0;
}
```

## 当然，对于这个模板，我们有更邪道的代码打法，暴力n*m！！！！(管理员快点强化数据喵！！缺数据的话我有专门卡暴力的数据来更新喵！@1269619784zwk ！)
```
#include <iostream>
#include <cstring>
using namespace std;
int next[2000000],sl,sll,k;
bool h[2000000];
string s,s1;
void getnext(){
    next[0]=-1;int j=-1;
    for(int i=1;i<sl;i++){
        while(j!=-1&&s[j+1]!=s[i]) j=next[j];
        if(s[j+1]==s[i]) j++;
        next[i]=j;
    }
    return;
}
int main(){
    cin>>s1>>s;
    sll=s1.length();
    for(register int i=0;i<sll;++i){
        if(s1[i]==s[0]){
            k=s1.find(s,i);
            if(!h[k+1]){
                h[k+1]=1;
                if(k!=-1)
            	cout<<k+1<<endl;
            }
        }
    }
    sl=s.length();
    getnext();
    for(int i=0;i<sl;i++) cout<<next[i]+1<<" ";
    return 0;
} //该暴力代码已AC所有点
```

---

## 作者：一扶苏一 (赞：15)

## Algorithm

### Task

给定一个文本串 $S$ 和一个模式串 $T$，求 $T$ 在 $S$ 中出现的所有位置。

### Limitations

要求时空复杂度均为线性。

### Solution

回头重新学一遍~~看毛片~~ KMP 算法。

设 $X$  是一个字符串，则以下表述中，$X_u$ 代表 $X$ 的第 $u$ 个字符，$X_{u \sim v}$ 代表 $X$ 的从 $u$ 起到 $v$ 结束的字串。

首先定义一个字符串的公共前后缀为这个字符串的一个 $border$，最长公共前后缀称为最长 $border$。特别的，不认为字符串本身是自身的 $border$。

性质：字符串 $S$ 的 $border$ 的 $border$ 一定是 $S$ 的 $border$，正确性显然。因此不断地跳最长 $border$ 可以遍历字符串的所有 $border$

例如，对于字符串 $abaab$ 来说，其唯一的 $border$ 是 $ab$。

暴力匹配两个字符串，时间复杂度为 $O(|S||T|)$，考虑优化这个算法。

假设当前匹配时 $S$ 扫描到了第 $i$ 位， $T$ 扫描到了第 $j$ 位，且 $S$ 从 $i$ 向前 $j$ 位组成的字符串与 $T$ 的前 $j$ 位相同，而 $S_{i + 1} \neq T_{j+1}$，我们称为发生了失配。

考虑失配时，指针 $i$ 不变，只有将指针 $j$ 前移，才可能令下一位成功匹配。由于 $i$ 不变，所以下一个可能发生匹配的字符串一定是 $T_{1 \sim j}$ 的某个前缀 $T_{1 \sim k}$ 满足

 $$T_{1 \sim k} = S_{i - k + 1 \sim i}$$

其中由于 $T_{1 \sim k}$ 是 $T_{1 \sim j}$ 的字串，一定有 $k < j$。由于 $S_{1 \sim i}$ 的后 $j$ 位与 $T$ 的前 $j$ 位匹配，又有 $k < j$，因此 $T_{1 \sim j}$ 的后 $k$ 位一定与 $S_{1 \sim i}$ 的后 $k$ 位即 $S_{i - k + 1 \sim i}$ 匹配。得出 

$$T_{j - k + 1 \sim j} = S_{i - k + 1 \sim i}$$

上面两个式子等量代换得到 

$$T_{1 \sim k} = T_{j - k + 1 \sim j}$$

由 $border$ 的定义，我们发现 $T_{1 \sim k}$ 一定是 $T_{1 \sim j}$ 的 $border$。根据 $border$ 的性质，我们只需要不断的跳 $T_{1 \sim j}$ 的最长 $border$ 即可找到一个最长的可以与 $S_{1 \sim i}$ 的后几位匹配的字串。因此问题转化为了如何求一个字符串 $T$ 的所有前缀的最长 $border$。

显然 $border_1 = 0$。从第 $2$ 位开始，我们发现问题等价于用 $T$（模式串） 的一个前缀去匹配 $T_{1 \sim i}$ （文本串）的一个后缀，求这个后缀最长是多少，而这个问题的解决方法与上面那个问题的方法 **完 全 一 致**，都是不断跳 $border$ 即可。在 $i$ 与 $j$ 成功匹配时，记录 $border_i = j$。而在这个问题中，由于 $j$ 恒小于 $i$，正向扫描 $i$ 时，所用到的 $border$ 值都已经被计算出，因此可以得出正确的结果。

考虑时间复杂度：一个显然的事实是每次跳 $border$ 模式串指针 $j$ 都会至少减少 $1$，而当且仅当第 $S_{i+1}$ 与第 $T_{j+1}$ 匹配时，$j$ 才会自增，因此 $j$ 仅增加了 $O(|S|)$，因此 $j$ 只可能减少 $O(|S|)$ 次，所以跳 $border$ 的总次数不超过 $O(|S|)$，而扫描整个文本串需要 $O(|S|)$ 的时间，因此总时间复杂度 $O(|S|)$。

## Example

P3375 【模板】KMP字符串匹配

### Description

给定一个文本串 $S$ 和一个模式串 $T$，求 $T$ 在 $S$ 中出现的所有位置，同时要求输出 $T$ 的每个前缀的 $border$ 长度。

### Limitations

字符串长度不超过 $10^6$

### Solution

板板题

### Code

```cpp
#include <cstdio>
#include <cstring>

const int maxn = 1000006;

char S[maxn], T[maxn];
int nxt[maxn];

void KMP(char *A, char *B, int x, int y, const bool pt);

int main() {
  freopen("1.in", "r", stdin);
  scanf("%s\n%s", S + 1, T + 1);
  int x = strlen(S + 1), y = strlen(T + 1);
  KMP(T, T, y, y, false); KMP(S, T, x, y, true);
  for (int i = 1; i <= y; ++i) {
    qw(nxt[i], i == y ? '\n' : ' ', true);
  }
  return 0;
}

void KMP(char *A, char *B, int x, int y, const bool pt) {
  for (int j = 0, i = pt ? 1 : 2; i <= x; ++i) {
    while (j && (B[j+1] != A[i])) j = nxt[j];
    if (B[j+1] == A[i]) ++j;
    if (!pt) nxt[i] = j;
    if (j == y) {
      qw(i - y + 1, '\n', true);
    }
  }
}
```

---

## 作者：Bring (赞：9)

# 本题解主要讲解nxt数组的构造及优化
蒟蒻题解，大佬勿喷
### 相信大家对朴素算法已经很了解了，所以我们直接步入正题~~（原谅我的偷懒）~~
#### 约定：字符串的开头编号为0，文本为t，模版为p，t，p的长度为lt，lp
首先，kmp的行为就是利用之前的匹配情况，不移动t，只移动p来完成字符串匹配


所以假设有一个nxt数组，表示当匹配到p的第j号时发现不对，于是将j移动到nxt[j]继续匹配，直到j==0（模版开头，表示这个t[i]无法成为p中的任何部分）或者t[i]==p[j]（匹配成功）

接下来，如果匹配成功，则++j，如果j==lp（全部匹配成功），则输出开头位置（i-lp+2）

于是我们~~非常偷懒地~~假设这个nxt数组已经完成了，于是匹配代码如下
```cpp
for (int i(0), j(0); i < lt; ++i) {
	while (j&&t[i] ^ p[j])j = nxt[j];
	if (t[i] == p[j])++j;
	if (j == lp)printf("%i\n", i - lp + 2);
}
```

------------

### 现在我们来考虑nxt数组的构造~~（该来的还是要来啊）~~
因为nxt数组利用之前的结果，所以当nxt[i]>=1时p中0~nxt[j]-1的部分与j-nxt[j]~j-1的部分必然完全一样

首先引入一个叫做前缀后缀的概念（假设有个叫做s的字符串，长度ls）

 _前缀_ ：空，s[0]，s[0]~s[1]，s[0]~s[2]，s[0]~s[3]……s[0]~s[ls-2]
 
 _后缀_ ：空，s[ls-1]，s[ls-2]~s[ls-1]，s[ls-3]~s[ls-1]，s[ls-4]~s[ls-1]……s[1]~s[ls-1]
 
注意：前缀后缀可以是空，但整个字符不可以是前缀后缀

**所以nxt[j]表示的就是在j之前的最长的完全相同的前缀后缀长度（大家请想一想）**

假设有字符串ababac

那么对应的nxt：{0，0，0，1，2，3，0}（注意这不含单调性）

于是可以用递推的方法求nxt（其实就是用自己匹配自己）（初始化nxt[0]=nxt[1]=0，i=1，j=0）

首先像前面一样，一直j=nxt[j]直到跑到开头或者p[i]==p[j]（匹配成功）

如果匹配成功，那么nxt[i+1]=j+1；否则nxt[i+1]=0

最后j=nxt[++i]，为下次递推作准备，直到i==lp

构造nxt数组代码如下
```cpp
for (int i(1), j(0); i < lp; j = nxt[++i]) {
    while (j&&p[i] ^ p[j])j = nxt[j];
    if (p[i] == p[j])nxt[i + 1] = j + 1;
}
```
于是丑陋的AC代码
```
#include<cstdio>
#include<cstring>
using namespace std;
char t[1000001], p[1000001];
int nxt[1000001], lt, lp;
int main() {
    scanf("%s%s", t, p), lt = strlen(t), lp = strlen(p);
    for (int i(1), j(0); i < lp; j = nxt[++i]) {
        while (j&&p[i] ^ p[j])j = nxt[j];
        if (p[i] == p[j])nxt[i + 1] = j + 1;
    }
    for (int i(0), j(0); i < lt; ++i) {
        while (j&&t[i] ^ p[j])j = nxt[j];
        if (t[i] == p[j])++j;
        if (j == lp)printf("%i\n", i - lp + 2);
    }
    for (int i(1); i <= lp; ++i)printf("%i ", nxt[i]);
    getchar(), getchar(); return 0;
}
```

------------

## 注意！！还没完！！
### 其实上文根本不是正版kmp算法~~（也不知道为什么AC）~~，而是未优化的mp算法，正版kmp对nxt数组的构造做了优化~~（说实在也没什么）~~
因为当匹配失败时，j要移到nxt[j]，但如果p[j]==p[nxt[j]]，那么匹配必然又失败，这就做了无谓的工作

所以递推时，如果p[i+1]==p[j+1]，那么nxt[i+1]应该=nxt[j+1]

于是就有了优化的nxt构造代码
```cpp
for (int i(1), j(0); i < lp;) {
	while (j&&p[i] ^ p[j])j = nxt[j];
	if (p[i++] == p[j++])nxt[i] = (p[i] ^ p[j] ? j : nxt[j]);
	else j = 0;
}
```
然后就是优化的全部代码
```cpp
#include<cstdio>
#include<cstring>
char t[1000001], p[1000001];
int nxt[1000001], lt, lp;
int main() {
    scanf("%s%s", t, p), lt = strlen(t), lp = strlen(p);
    for (int i(1), j(0); i < lp;) {
        while (j&&p[i] ^ p[j])j = nxt[j];
        if (p[i++] == p[j++])nxt[i] = (p[i] ^ p[j] ? j : nxt[j]);
        else j = 0;
    }
    for (int i(0), j(0); i < lt; ++i) {
        while (j&&t[i] ^ p[j])j = nxt[j];
        if (t[i] == p[j])++j;
        if (j == lp)printf("%i\n", i - lp + 2);
    }
    for (int i(1); i <= lp; ++i)printf("%i ", nxt[i]);
    getchar(), getchar(); return 0;
}
```
本人洛谷测试21分（意料之中，是因为nxt数组变了），但根据与前文程序的对拍，在匹配上没有问题，仅供参考，如果出现问题，望大佬们多多指教

---

## 作者：cirnovsky (赞：8)

# 0x00 前言

本文和某播放软件KMPlayer没有一毛钱关系

# 0x01 引入问题

设想这样一个问题：

给你两个字符串，让你查找在文本串中模式串的位置。

暴力做法是显然的，举例来说：

文本串(text)：$a\ b\ c\ b\ c\ g\ l\ x$

模式串(pattern): $b\ c\ g\ l$

我们直接暴力枚举text中的每一个字符，并且依次与pattern中的字符从头开始匹配。时间复杂度为 $\Theta(nm)$

# 0x02 发现问题

这样做其实有很多冗余操作。比如说：$b\ c\ g\ l$ 与text中的 $b\ c\ b\ c$ 不匹配，又从第text的第五个字母 $c$ 开始匹配。这样做是显然不必要的。为什么呢？因为模式串是以  $b$ 开头的，对于text中第五个字母 $c$ 显然我们可以不去匹配。发现了什么吗？每次失配后我们只需要从两个字符串的最长公共部分开始匹配即可。这里看不懂没有什么关系，只要能理解后面的例子就可以了。

# 0x03 解决一部分问题

$\qquad\qquad\quad\ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5\ \ 6\ \ 7\ \ 8\ \ 9\ 10\ 11$

文本串(text)： $a\ \ b\ \ x\ \ a\ \ b\ \ c\ \ a\ \ b\ \ c\ \ a\ \ b\ \ y$

$\qquad\qquad\qquad\ \ \ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5$

模式串(pattern)： $a\ \ b\ \ c\ \ a\ \ b\ \ y$

我们有两个指针i和j，分别指向文本串和模式串。在i=0,j=0以及i=1,j=1的时候都匹配上了。但是在i=2,j=2时失配了。如果时朴素算法的话会令i=1,j=0重新开始匹配。然而我们发现我们完全可以令i=3,j=0来重新匹配。一直到i=8,j=5时，它们又失配了。我们令j等于模式串和文本串已经配对完成的部分(即pattern[0]~pattern[4])的最长公共前缀后缀(即pattern[0,1]和pattern[3,4])的前缀末尾部分+1(即1+1=2)的地方，此时的text[6,7]和pattern[0,1]都是ab也就是说我们可以直接从i=8,j=2开始匹配，就可以匹配到模式串了。这就是KMP玄妙的地方。

# 0x04 解决另一部分问题

那么问题来了：我们如何确定模式串最长公共前后缀的前缀末尾+1的位置呢？我们还是通过一个例子来感受。

$\qquad\qquad\qquad\ \ \ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5$

模式串(pattern)： $a\ \ b\ \ c\ \ a\ \ b\ \ y$ (没错就是上面那个我太懒了)

我们可以设数组$next_i$为以 $i$ 为结尾的模式串最长公共前后缀的前缀末尾+1的位置。

$next_0$显然为0。

我们依然设两个指针i和j，i初始化为0，即指向模式串的开头。j初始化1，即i后面一个。

pattern[i]不等于pattern[j]，令next[i]=0，j+=1

pattern[i]依然不等于pattern[j]，令next[i]=0，j+=1

此时pattern[i]等于pattern[j]，令next[i]=j+1=1，i+=1，j+=1

此时pattern[i]等于pettern[j]，令next[i]=j+1=2，i+=1,j+=1

此时pattern[i]不等于patter[j]，并且j不在模式串的开头，令j=next[j-1]=2

此时pattern[i]依然不等于pattern[j]，并且j不在模式串的开头，令j=next[j-1]=0

此时pattern[i]依然不等于pattern[j]，但是j已经跑到开头去了，令i+=1

此时pattern[i]依然不等于pattern[j]，并且i已经跑到了尽头，求解结束。

%出来next数组是这样的:$[0,0,0,1,2,0]$

# 0x05 解决所有问题

~~其实就是放一下代码~~

我自认为讲的还是比较清楚，~~至少比蓝书好~~。

代码虽然和网上其他人的不太一样，不太标准，但还算简洁，~~至少比蓝书好~~。

总之一句话，学KMP不要看书，不要看书，不要看书！！！会死人的！！！

对了还有一个坑点，我这份代码用std::string会RE，~~鬼知道我调了一下午发现是这个原因时心里有多傻逼~~


```cpp
/*
 * P3375【模板】KMP字符串匹配.cpp
 * Created by boringhacker(c20220233wgy)
*/
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

namespace MAIN {
    const int SIZE = 1000000 + 5;
    int next[SIZE], n, m;
    char Text[SIZE], Pattern[SIZE];
    // string Text, Pattern; 去你的std::string

    void GetNextVal() {
        int i = 1, j = 0;
        *next = 0;
        while (i < n) {
            if (Pattern[i] == Pattern[j])
                next[i] = j + 1, ++i, ++j;
            else if (j) j = next[j - 1];
            else ++i;
        }
    }

    void GetAnswers() {
        int st = 0, res = -1;
        int i = 0, j = 0, flag = 0;
        while (true) {
            j = st;
            if (Text[i] == Pattern[j]) {
            	if (!flag) res = i + 1 - st, flag = 1;
                if (j == n - 1) cout << res << endl, j = 0, flag = 0;
                else ++i, ++j;
                st = j;
                if (i >= m) return ;
            }
            else {
            	if (j) st = next[j - 1];
            	else ++i;
            	flag = 0;
			}
        }
    }

    void MAIN() {
        cin >> Text;
        cin >> Pattern;
        m = strlen(Text);
        n = strlen(Pattern);
        GetNextVal();
        GetAnswers();
        for (int i = 0; i < n; ++i) cout << next[i] << ' ';
    }
}

signed main() {
    MAIN::MAIN();
    return 0;
}
```

# 欢迎捉虫子

---

## 作者：charliezhi (赞：8)

## 大家肯定知道KMP
~~当然蒟蒻们不会~~

那么今天我们就来讲讲KMP吧

还是老规矩，先上~~代码~~模板
```cpp
cin>>a>>b;
n=a.size();
m=b.size();
int last=-1;
for(i=1;i<m;i++)
{
	j=Next[i];
	while(j && b[i]!=b[j]) j=Next[j];
	Next[i+1]=(b[i]==b[j])?j+1:0;
}
j=0;
for(i=0;i<n;i++)
{
	while(j && a[i]!=b[j]) j=Next[j];
	if(a[i]==b[j]) j++;
	if(j==m)
	{
		cout<<i-m+2<<endl;
	}
}
如果有需要可以用counting函数来计数 
```
计数的模板在这里
```cpp
counting=0;
cin>>b;
n=a.size();
m=b.size();
int last=-1;
for(i=1;i<m;i++)
{
	j=Next[i];
	while(j && b[i]!=b[j]) j=Next[j];
	Next[i+1]=(b[i]==b[j])?j+1:0;
}
j=0;
for(i=0;i<n;i++)
{
	while(j && a[i]!=b[j]) j=Next[j];
	if(a[i]==b[j]) j++;
	if(j==m)
	{
		if(i-last>=m)
		{
			counting++;
			last=i;
		}
	}
}
cout<<counting<<endl; 
```
两个模板都上了，那么现在开始讲题

先上代码awa
```cpp
#include<algorithm>
#include<cmath>
#include<queue>
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,i,j,Next[1000001]={0},last,counting=0;
string a,b;
int main()
{
	cin>>a>>b;
	n=a.size();
	m=b.size();
	int last=-1;
	for(i=1;i<m;i++)
	{
		j=Next[i];
		while(j && b[i]!=b[j]) j=Next[j];
		Next[i+1]=(b[i]==b[j])?j+1:0;
	}
	j=0;
	for(i=0;i<n;i++)
	{
		while(j && a[i]!=b[j]) j=Next[j];
		if(a[i]==b[j]) j++;
		if(j==m)
		{
			cout<<i-m+2<<endl;
		}
	}
	for(i=1;i<=m;i++) cout<<Next[i]<<" ";
}
```
接下来开始讲解啦

首先输入两个string字符串，然后存它们的长度

```cpp
j=Next[i];
while(j && b[i]!=b[j]) j=Next[j];
Next[i+1]=(b[i]==b[j])?j+1:0;
```
这段现将j存入next数组里，接下来j=next=[j]直到b[i]=b[j]

接下来算如果b[i]==b[j]，则next[i+1]=j+1,否则next[i+1]=0;

之后先把j清零

```cpp
while(j && a[i]!=b[j]) j=Next[j];
if(a[i]==b[j]) j++;
if(j==m)
{
	cout<<i-m+2<<endl;
}
```
接下来如果a[i]!=b[j]的话，把j赋值成next[j]

如果两个字符串对应的字母相等的话，j++

如果j到头了，就输出i-m+2

最后输出next

## 题解就到这里啦！如果不会可以记一下模板哈

---

## 作者：yybyyb (赞：6)

KMP是一个优秀的字符串算法(不优秀我们干嘛要学)

然后，这就是一个裸的模板。。。

如果Next数组理解不是很好的话，我写了篇博客~~（尽管可能讲的依旧不是很清楚）~~

地址：http://blog.csdn.net/qq\_30974369/article/details/74276186

~~对于KMP，不理解的请多多手算~~

理解了next数组，KMP就变得十分简单（跟AC自动机理解了失配指针一样）

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<vector>
#include<algorithm>
using namespace std;
const int MAX=1001;
int Next[MAX];
vector<int> Ans;
inline void GetNext(string s)//获得字符串s的next数组
{
    int l=s.length(),t;
    Next[0]=-1;//如果在0位置失配则是向下移动一位
    for(int i=1;i<l;++i)//依次求解后面的next数组
    {
        t=Next[i-1];
        while(s[t+1]!=s[i]&&t>=0)
            t=Next[t];
        if(s[t+1]==s[i])
            Next[i]=t+1;
        else
            Next[i]=-1;
    }
}
inline void KMP(string s1,string s2)
{
    GetNext(s2);
    int l1=s1.length();
    int l2=s2.length();
    int i=0,j=0;
    while(j<l1)
    {
        if(s2[i]==s1[j])//当前位匹配成功，继续匹配下一位
        {
            ++i;++j;
            if(i==l2)//完全匹配
            {
                Ans.push_back(j-l2+1);//储存答案
                i=Next[i-1]+1;//继续匹配                
            }
        }
        else
        {
            if(i==0)//在首位不匹配
                j++;
            else
                i=Next[i-1]+1;
        }
    }
}
int main()
{
    string s1,s2;
    int l;
    cin>>s1>>s2;
    l=s2.length();
    KMP(s1,s2);
    for(int i=0;i<Ans.size();++i)
        cout<<Ans[i]<<endl;
    for(int i=0;i<l;++i)
        cout<<Next[i]+1<<' ';
    cout<<endl;
    return 0;
}

```

---

## 作者：zhaimingshuzms (赞：6)

#代码是最清晰的语言

```cpp
%:pragma GCC optimize(3)
#include<cstdio>
#include<cstring>
using namespace std;
int i,j,len1,len2,ne[1001];
char s1[1000001],s2[1001];
void findnext()
{
    for (i=2,j=0; i<=len2; i++)//i不从1（开头）开始是为了防止后缀最大长度等于前缀最大长度等于整串长，至于j那是已经匹配的前缀最大长和后缀最大长 
    {    
        while (s2[i]!=s2[j+1]&&j>0) j=ne[j];//如果当前位与前缀已匹配后一位不相等，就递归找最大公共前后缀，否则最优跳出******************************label 1;
        if (s2[i]==s2[j+1]) ne[i]=++j;//如果尽可能地匹配后，还是不能使当前位与之前匹配的后一位相等，就把ne赋为0（不赋值）否则在已匹配位+1 
    }
}
void kmp()
{
    for (i=1,j=0; i<=len1; i++)//这里i指要努力匹配的，j指已经匹配的； 
    {
        while (s1[i]!=s2[j+1]&&j>0) j=ne[j];//label1（手比较懒） 
        if (s1[i]==s2[j+1]) ++j;//如果尽可能匹配后还是不匹配，理论上应该j清零，{可我为什么没写呢？因为j在上一句话就清0了}，否则增加已匹配位数 （大括号表示层次） 
        if (j==len2) {printf("%d\n",i-len2+1); j=ne[len2];}//如果全部匹配输出，然后由于我们已经知道j的最大公共前后缀了，可以直接将j设为他的最大公共前后缀用以加速 
    }
}
int main()
{
    scanf("%s%s",s1+1,s2+1);//从字符串第一位开始读，需要特殊处理 
    len1=strlen(s1+1); len2=strlen(s2+1);//扫到/0（结束符）之前扫了几位，也是字符串最后一有效位的位置 
    findnext();//初始化ne数组 
    kmp();//进行kmp 
    for (i=1; i<=len2; i++) printf("%d ",ne[i]);//叔叔叔叔叔叔叔叔叔初初初初初初初初 
    return 0; 
}//经过实测洛谷的数据为 12ms还是比较快的^_^；
```

---

## 作者：Night_Aurora (赞：6)

发一个误导新人的解法吧

是一种基于hash的解法，

字符串s的hash=s[0]+s[1]\*x+s[2]\*x^2....+s[len-1]\*x^(len-1)

于是可以一次O(n)处理原串的后缀hash

在使用时就可以O(1)求出一段的hash了（预处理好x^len)

考虑只能把hash作为唯一判断标准(没时间strcmp)

于是我们要想办法让hash重合的概率很小

所以用unsigned long long保存hash值

x也可以尽量小(换一个超大素数也没什么用)

随便取一个x没想到过了











```cpp
#include <stdio.h>
#include <string.h>
#define HX    'F'    //随便找的一个数，'F'=70
typedef unsigned long long HSTR;
int Next[1100];   //打法输出用的next数组
char Man[1100000];
char Tmp[1100];
int la,lb;
HSTR Hash[1100000];
HSTR Hb;
void CallNext()
{
    int wia,wib;
    Next[0]=-1;
    for(wia=1;wia<lb;++wia)
    {
        wib=Next[wia-1];
        while(wib+1&&Tmp[wib+1]!=Tmp[wia])
            wib=Next[wib];
        if(Tmp[wib+1]==Tmp[wia])
            Next[wia]=wib+1;
        else
            Next[wia]=-1;
    }
}
void CallHash()     //预处理后缀hash
{
    int wi;
    for(wi=la-1;wi+1;--wi)
        Hash[wi]=Man[wi]+Hash[wi+1]*HX;
    HSTR px=1;
    for(wi=1;wi<=lb;++wi)
    {
        Hb+=px*Tmp[wi-1];
        px*=HX;
    }
}
HSTR Px;
void CMP()
{
    int wi;
    Px=1;
    for(wi=1;wi<=lb;++wi)
        Px*=HX;
    for(wi=0;wi<=la-lb;++wi)
        if(Hb==Hash[wi]-Px*Hash[wi+lb])
            printf("%d\n",wi+1);
}
int main()
{
    scanf("%s",Man);
    scanf("%s",Tmp);
    la=strlen(Man);
    lb=strlen(Tmp);
    CallNext();
    CallHash();
    CMP();
    int wi;
    for(wi=0;wi<lb;++wi)
        printf("%d ",Next[wi]+1);
    putchar(10);
    return 0;
}
```

---

## 作者：yeke (赞：6)

作为一个学了十多天KMP的人，我终于学会了一个更优秀的算法：Sunday

```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<string>
using namespace std;
int nxt[256]={0},l,ll,pre[1001];
char a[1000001],b[1001];
void fai(int n)                            //抄别人的，因为Sunday的失配指针不一样 
{
    pre[0]=-1;
    for(int i=1,k=-1;i<n;pre[i++]=k)
    {
        while(k>=0&&b[i]!=b[k+1])
            k=pre[k];
        if(b[i]==b[k+1])
            k++;
    }
}
void Sunday()
{
    for(int i=0;i<=255;i++)        // 失配指针初始化 
      nxt[i]=ll+1;
    for(int i=0;i<ll;i++)           //建失配指针
      nxt[b[i]]=ll-i;
    int i=0,j=0;
    while((j<ll)&&(i<l))
    {
        j=0;
        for(;j<ll&&i+j<l&&a[i+j]==b[j];++j);
        if(j==ll)
        {
            cout<<i+1<<"\n";
            i++;
            j=0;
            continue;
        }
        if(i+ll>=l)
          return ;
        i+=nxt[a[i+ll]];
    }
    return ;
}
int main()
{
    cin>>a>>b;
    l=strlen(a);ll=strlen(b);
    fai(ll);
    Sunday();
    for(int i=0;i<ll;i++)
      cout<<pre[i]+1<<" ";
    return 0;
}
```

---

## 作者：OsvaldoAsensioLopez (赞：5)

要计算next数组,然后使用kmp主体将模式字符串左右移动到next[i]处再匹配

计算第n个字符的next值

第一位的next值必定为-1

1.查看第n-1个字符对应的next值，设为a

2.判断a是否为-1，若为-1，则第n个字符next值为0

3.若不为-1，将第n-1个字符与第a个字符比较

4.如果相同，第n个字符对应的next值为a+1

5.如果不同，令a等于第a个字符的next值，执行第2步

    
    
    
    
```cpp
    #include <iostream>
    #include <string>
    using namespace std;
    //算nxt数组其实就是算s子串最长前、后缀(不可以是整个字符串)相等长度 
    inline void calc_next(string s,int *nxt) {
        nxt[0]=-1;//-1表示不存在这种前后缀 
        int k=-1;
        for(int q=1;q<s.length();q++) {
            while(k!=-1 && s[k+1]!=s[q]) k=nxt[k];//下一个不同就变为nxt[k],回溯 
            if(s[k+1]==s[q]) k++; 
            nxt[q]=k;
        }
    }
    int *kmp(string s,string p) {
        int slen=s.length();
        int plen=p.length();
        int k=-1;//移动位数 
        int *nxt=new int[plen];
        calc_next(p,nxt);//一定要计算!!!!!!!!!!!!!!!!!!!!! 
        for(int i=0;i<slen;i++) {
            while(k!=-1 && p[k+1]!=s[i]) k=nxt[k];//不匹配向前移
            if(p[k+1]==s[i]) k++;//匹配向后移
            if(k==plen-1) {//k移动到最后,匹配完成 
                i=i-(plen-1);
                //cout << i << endl;
                cout << i+1 << endl;
                k=-1;//继续匹配下一个 
                //return i-(plen-1);//计算第一个匹配的位置 
            } 
        }
        //return -1;//不可以匹配 
        return nxt;//题目要求输出next数组 
    }
    int main() {
        string s,p;
        cin >> s >> p;
        int *r = kmp(s,p);
        //cout << r[i] << " ";
        for(int i=0;i<p.length();i++) cout << r[i]+1 << " ";
        return 0;
}
```

---

## 作者：zhy12138 (赞：4)

# 前言：
KMP匹配是实现字符串匹配的算法，时间复杂度O(m+n)。

# 蒟蒻LZ的~~BB~~哭诉：
辣鸡的LZ本来写这篇博客写了很久，都快写完了，结果扫了个垃圾，把本来的文档删掉了，感觉不会再爱了QWQ

# 正题：
众所周知，我们最初使用的字符串匹配方法是在a数组从头扫到尾，每一位都判断以其为起点时，能否完成匹配，这样时间复杂度就会是O(mn)。

而KMP则利用了字符串匹配的一个小性质：
```cpp
                  1   2   3   4   5   6   7
          a[]     B   A   B   A   B   A   C
          b[]     B   A   B   A   C
```
若匹配到第4位时，发现最后一位无法匹配~~这真是令人f**k~~。

这里按照原思路，应该继续调动a数组中的指针，找新的起点

而发现到b数组的最后2位，与前2位完全相同，所以之前那个错误的匹配就已经把起点为3时的前2位匹配完了，所以当起点指针扫到3时，会进行重复的匹配，这就大大增长了时间。

因此KMP定义了数组next，next[i]=j表示b数组中1~j位与(i-j+1)~i位完全相同，且不存在更大的j满足条件，即当前的j为满足条件的最大值。

那么它是如何使用的呢？

- 一个指针在a数组中移动，表示已匹配到第几位。
- 另一个指针bj在b数组中移动，表示已匹配成功几位。
- 若a，b数组下一位可以成功匹配，两个指针同时后移一位。
- 若下一位无法匹配，则将bj移向next[bj]，直到下一位匹配成功，或bj指向0（即下一位使得你怎么也匹配不了）
- 若bj指针已指向b数组末尾，则表示已完成一个匹配，bj移向next[bj]，***这里很重要！！！***

那么这个算法为什么是正确的呢？

不难发现上文的步骤中，a数组匹配过的地方，显然没有退回去检查是否为另一个匹配的起点。

但它其实是正确的，证明如下：

- 若当前匹配成功

![](https://cdn.luogu.com.cn/upload/pic/31210.png)
黑框为原数组中可以被匹配成功的部分。

那么显然，两个匹配有一段重叠部分，所以next[bj]必定会跳到重叠部分的末尾（否则就会跳到另一个匹配，如果那个匹配成功，则如上，如失败，见下文），也就是算得到另一个匹配。

- 若当前匹配失败

![](https://cdn.luogu.com.cn/upload/pic/31213.png)
红色方框是匹配成功的部分。

显然它的后面与匹配数组有部分重合，而因为它已匹配成功，所以它必定是匹配的前一部分（上方红框），此时它的前缀和后缀有一段重合，所以next[bj]必定会跳到重叠部分的末尾，即匹配失败的前一位（否则，~~WOC，我懒得写了~~），此时可以计算到起点被跳过的匹配。

一切都已经做完了，我们发现了一个很尴尬的事情，next怎么求！！！~~WOC~~

其实next的求法与next的使用~~完全~~基本一样。

就是把b数组当作a数组，和自己匹配。

此时next[i+1]=bj，为什么？第i+1位匹配成功了bj位，即b[1~bj]==b[(i+1)-bj+1~(i+1)]，这就是next的定义啊。

AC代码：
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<ctime>
#define ll long long
using namespace std;
inline ll read()
{
	ll kkk=0;
	int x=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')
			x=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')
		kkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();
	return kkk*x;
}
char s1[1000001],s2[1000001];
int next[1000001],bj;
int main()
{
	cin>>s1+1>>s2+1;
	int len1=strlen(s1+1),len2=strlen(s2+1);
	next[1]=0;
	bj=0;
	for(register int i=1;i<len2;++i)
	{
		while(s2[i+1]!=s2[bj+1] && bj!=0)
			bj=next[bj];
		if(s2[i+1]==s2[bj+1])
			++bj;
		next[i+1]=bj;
	}
	bj=0;
	for(register int i=0;i<len1;++i)
	{
		while(s1[i+1]!=s2[bj+1] && bj!=0)
			bj=next[bj];
		if(s1[i+1]==s2[bj+1])
			++bj;
		if(bj==len2)
		{
			printf("%d\n",i-len2+2);
			bj=next[bj];
		}
	}
	for(register int i=1;i<=len2;++i)
		printf("%d ",next[i]);
	putchar('\n');
	return 0;
}
```

---

## 作者：余不渡 (赞：3)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1000100,M = 1100;
int next[N];
void getNext(char s[])    //找next数组
{
    int len=strlen(s+1);    //确保调用s中的元素的时候是从s[1]开始而不是s[0]，因为next数组从1开头 
    for (int i=2,j=0;i<=len;i++) {
    //从第二个元素开始匹配，因为第一个元素一定不存在前缀，j=0是因为next[0]=0
    //next数组记录的是到第i位为止前面这段字符串的前缀和后缀的共有部分的长度 
        while (j && s[i]!=s[j+1]) j=next[j];    //就是移动过程 
        if (s[i]==s[j+1]) j++;    //如果匹配就继续
        next[i]=j;    //表明第i位的next[i]的值是j 
    }
} 
void kmp(char s[],char t[])    //在s中找t
{
    int lens=strlen(s+1),lent=strlen(t+1);    //同上 
    for (int i=1,j=0;i<=lens;i++) {        //注意是从s的第一位开始匹配
         while (j && s[i]!=t[j+1]) j=next[j];    //经典移动过程 
         if (s[i]==t[j+1]) j++;        //如果匹配就继续 
         if (j==lent) printf("%d\n",i-lent+1);        //输出（现在的位置-需要寻找的字符串的长度+1）就是这个字符串第一次出现的位置 
    } 
} 
int main()
{
    char a[N],b[M];
    cin>>a+1>>b+1;
    getNext(b);
    kmp(a,b);
    return 0;
    //洛谷评测改c++别用c++11，用流输入输出要关流输入 ios::sync_with_stdio(false) 
}
```

---

## 作者：飞翔 (赞：3)

可能大家只知道KMP算法，而不知道MP算法。

KMP算法是把MP算法的失配函数进行了优化。

代码中f数组就是后缀数组。

```cpp
#include<cstdio>
#include<cstring>
char t[1000010],p[1000010];
int f[1000010];
void getfail(char* p,int* f)
{
    int m=strlen(p);
    f[0]=0;f[1]=0;
    for (int i=1;i<m;i++) {
        int j=f[i];
        while (j && p[i]!=p[j]) j=f[j];
        f[i+1]=p[i]==p[j]? j+1 : 0;
    }
}
void find(char* t,char* p,int* f)
{
    int n=strlen(t),m=strlen(p);
    getfail(p,f);
    int j=0;
    for (int i=0;i<n;i++) {
        while (j && p[j]!=t[i]) j=f[j];
        if (p[j]==t[i]) j++;
        if (j==m) printf("%d\n",i-m+2);
    }
}
int main()
{
    scanf("%s",&t);
    scanf("%s",&p);
    find(t,p,f);
    for (int i=1;i<=strlen(p);i++) printf("%d ",f[i]);
}
```

---

## 作者：风火 (赞：3)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Ull unsigned long long
const int maxn=2000048;
char s[maxn],c[maxn];
int n,m,kase;
int next[maxn],pre[maxn];
Ull p[maxn],f[maxn],z[maxn],base=131,tmp;
void work()
{
	next[1]=0;
	for(int i=2,j=0;i<=n;i++)
	{
		while(j>0&&c[i]!=c[j+1]) j=next[j];
		if(c[i]==c[j+1]) j++;
		next[i]=j;
	}
}
//思路：
/*
我来教哈你们哈希
直接找父串中首字母与子串相同的
再直接O(1)比较长度相同时，两串字符的hash值是否相同
其中
{
	hash值为一个特别的为了减小误差的一个值，即将字符串转化为hash值，这样就可以减小误差
}
hash值的设定
{
	就像把一个字符串转化为n进制数
    其中n=131或者1331会减小误差
}
然后直接比较两段字符hash值是否相等就好了
最后的next数组用KMP算法就好了
我的博客中也有解释、、、
*/
int main()
{
	scanf("%s",s+1); scanf("%s",c+1); 
	n=strlen(s+1); m=strlen(c+1);
	work(); 
	p[0]=1;
	for(int i=1;i<=n;i++)
		s[i+n]=s[i],f[i]=f[i-1]*base+s[i]-'A'+1;
	for(int i=1;i<=m;i++)
	{
		p[i]=p[i-1]*base;
		z[i]=z[i-1]*base+c[i]-'A'+1;
	}
	for(int i=1;i<=n;i++)
	{
		if(s[i]==c[1])
		{
			if(z[m]==(f[i+m-1]-f[i-1]*p[m]))
				printf("%d\n",i);
		}
	}
	for(int i=1;i<=m;i++)
		printf("%d ",next[i]);
	return 0;
} 
```

---

## 作者：Ameiyo (赞：2)

注意：本文面向对KMP有了解但对next数组不大清楚的人！！萌新请先了解基础！！
--
(其实[花姐的题解](https://pks-loving.blog.luogu.org/zi-fu-chuan-xue-xi-bi-ji-qian-xi-kmp-xuan-xue-di-dan-mu-shi-chuan-pi-post)讲的特别清楚了~~但是我理解的方法有点不同所以还是交题解了QWQ~~)

我自己看蓝书(刘汝佳的训练指南)学了下KMP，然而蓝书也没有细讲，只是让我们查百度并且贴上了代码(其实应该是可以理解的但是我太菜了)，找百度看了四个博客也并没有看太懂，但是借鉴了一点思想。
所以就自己对着代码想nex的意义，然后花了2个小时码出来这个。。。代码里的注释是我为了理解(推导)而敲出来的如果看不懂可以私信我。

因为我刚学KMP的时候感受到了绝望。。。所以希望能对同样遇到困难得人有所帮助。

ps：注释中的$(a...b)=(c...d)$表示

$T[a] = P[c],$

$T[a+1] = P[c+1],$

$.$

$.$

$.$

$T[b-1] = P[d-1],$

$T[b] = P[d].$

(在$getfail$中T就是P)

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
//其实只是为了用strlen而已
using namespace std;
#define reg register
const int N = 1e6+5, INF = 1e9;

char T[N], P[N];
int lt, lp;
int nex[N];  // nex[0]=0
			 // nex[1]=x1 -> 0...x1-1=1-x1...1-1 (其实就是前缀与后缀，看了几个人的博客都有提到这个概念)
			 // nex[2]=x2 -> 0...x2-1=2-x2...2-1
			 // .
			 // .
			 // .
			 // nex[n]=xn -> 0...xn-1=n-xn...n-1(@0) =>
			 // if n,i faild -> compare xn,i   (@1) 在这里显然@0与@1互为充要条件（似乎表述有问题？？算了那是数学上的事情。就是说两个是可以互推的）

inline void getfail() { //其实就是用模板匹配模板
	int j = 0;    //j -> 模板的下标   i -> 待匹配字串的下标(这里就是模板)    (@2)
	for (reg int i = 1; i < lp; ++i) {
		// j=0 -> compare P[i], P[0] -> 从头开始  =>                   =>//
		// 1.P[i]!=P[0] -> compare P[++i], P[0] -> (j=0)not change     =>//
		// 2.P[i]==P[0] -> compare P[++i], P[1(++j)] -> ++j            =>//
		//                                                             =>//
		// j>0 -> compare P[i], P[j] -> {*}={0...j-1==i-j...i-1}  =>   =>//  
		/* 1.P[i]!=P[j] -> (@1) (@2) ->            =>//                =>//
			 compare nex[j],i =>                   =>//                =>//
			 (1).P[nex[j]]!=P[i] -> (@1) (@2) ->   =>//                =>//
			 	 compare nex[nex[j]],i             =>//  j=nex[j]      =>//
			 	 .                                 =>//                =>//
			 	 .                                 =>//                =>//
			 	 .                                 =>//                =>//
			2.P[i]==P[j] -> compare i+1,j+1 => ++j                     =>//
		*/ 
		while (j && P[i] != P[j]) j = nex[j];
		// 1.P[i]==P[j] => (though j==0)  (这里可以推出两点)
		//   (1)0...j=i-j...i -> (@0) -> nex[i+1]=j+1
		//   (2)compare ++j,++i -> ++j
		//   => ++j, nex[i+1]=j (因为for循环中有++i)
		// 2.P[i]!=P[j] -> j==0 (注意while里的条件) -> when i+1!=x 从头开始 
        //   (因为P[i]与P[0]也不相等所以如果i+1失配了那么就只能从模板的第一个开始匹配) =>
		//   compare i+1,0 -> (@0) -> nex[i+1]=0 (j)
		if (P[i]==P[j]) ++j;
		nex[i+1] = j;
	}
}

inline void KMP() {
	getfail();
	int j = 0;
	for (reg int i = 0; i < lt; ++i) {
		// most same as getfail()
		while (j && T[i] != P[j]) j = nex[j];
		// 1.j==lp-1 -> success -> print(i-lp+1) 匹配成功
		// 2.T[i]==P[j] -> compare i+1,++j  如果相等就应该继续比较P[i+1]与P[j]
		// 3.T[i]!=P[j] -> j=0 -> (@0) -> compare i+1, 0(就是j)
		if (T[i] == P[j]) ++j;
		if (j == lp) printf("%d\n", i-lp+1+1);
	}
}

int main() {
	scanf("%s %s", T, P);
	lt = strlen(T), lp = strlen(P);
	KMP();
	for (reg int i = 1; i <= lp; ++i) { //洛谷P3375 要求输出但却没有规定next数组，毕竟每个人的模板不同，在观察之下我发现似乎就是这样结果AC了。。。
		printf("%d ", nex[i]);          //这在KMP里不是重点啦所以不用纠结这一块QWQ
	}                                   //似乎是有大佬用hash做出来了%%%
	putchar('\n');
	return 0;
}

```
其实这似乎是MP，KMP还需要对nex数组进行优化(训练指南P213)，但是MP已经到达了时间复杂度的下限，并且~~在当时~~已经足以使用，所以有想法的同学就百度呗。

事实上，我认为这种学习的方式也是可以尝试的，尽管可能效率较低(我会这么做的根本原因可能是初中主要在搞数竞习惯了自己推导的方法)

~~这也说明了一个套耳式3D环绕立体音耳机的重要(滑稽)~~如果没有我的耳机，在机房嘈杂的环境下我根本不可能静下心来去思考QWQ。

emmmmmm一片好心望管理员大大不要驳回QAQ。

---

## 作者：Rec° (赞：2)

## 欢迎访问[juruo的博客](https://rec.ac.cn/?p=325)查看
状态一直很差 甚至连这么基础的算法都不会了 整理复习一下
### 介绍
KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。
### 原理
百科上的介绍已经非常清楚了 就是“利用匹配失败后的信息尽量减少的模式串与主串的匹配次数以达到快速匹配的目的”    
简单来说就是在当前匹配失败之后不完全回退到初始状态而是跳到下一个符合的状态   
举一个例子   
主串是 bbaabcdfabcabc    
模式串 abcdabc   
我们先看一下暴力匹配的过程   
我们用‘q’暂时代替一下空格    
//好像还是有些问题 对付一下啦qwq    
我们先将主串固定 第几位代指模式串第几位    
1     
bbaabcdfabcabc    
abcdabc    
我们发现第一位匹配失败 模式串向后移动一位    
2    
bbaabcdfabcabc    
qabcdabc    
我们发现第一位匹配失败 模式串向后移动一位    
3   
bbaabcdfabcabc    
qqabcdabc    
我们发现第二位匹配失败 模式串向后移动一位    
4   
bbaabcdfabcabc    
qqqabcdabc    
我们发现第五位匹配失败 模式串向后移动一位   
5   
bbaabcdfabcabc   
qqqqabcdabc   
我们发现第五位匹配失败 模式串向后移动一位   
。。。。。。。//此处省略一些   
end    
bbaabcdfabcabc  
qqqqqqqabcdabc   
匹配成功   

很复杂也有很多浪浪费 考虑如何优化这一过程呢？   
不难想到的~~为什么不从后向前匹配呢？~~   
我们不论在第几个位置匹配失败 都是整体后移一位重新进行匹配 这一定是可以进行优化的   
不妨试试如果失去匹配 我们直接向后跳模式串已匹配到的长度（下文简写）个位置会有怎样的影响 显然有些情况下是错的  这就很好 我们只解决这些错误的情况就好了   
我们无法确定在已匹配到的后面一段中 是否包含正确匹配的前一段   
//这里自己想一下可能会更有效果 写个例子试试就好了   
什么时候会有这种影响呢？ 即已经匹配到的部分前面的与后一部分有相同的地方    
比如模式串abeabf 我们在第六位‘f’失去匹配了  向后跳转五位 就相当于在主串中的第二个ab 只与模式串的第二个ab匹配后就被跨了过去 我们还需要让模式串第一个ab再次与它匹配 所以这里的跳转应该是     
5（已匹配到的长度） - 2（最长公共长度） = 3   
可以相见 跳转后主串中的第二个“ab”将会与模式串中的第一个“ab”重新重合    
如此 我们就轻松解决了这一问题    
那我们唯一会出现错误的情况也找到了解决方法     
在其他情况下最长公共长度是0 减一下不会影响答案正确性    
我们只需要预处理出     
模式串每一位置的前缀和后缀的最长公共元素的长度   
把这个存进一个数组里   
匹配时就可以用它来加速就可以了   
### 代码
[模板](https://www.luogu.org/problemnew/show/P3375 "模板")~~当时大概orz了先辈代码~~
//数组kmp就是那个值
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
char a[1000010], b[1000010];
int kmp[1000010], k, lena, lenb;
int main(){
	scanf("%s%s", a, b);
	lena = strlen(a), lenb = strlen(b);
	kmp[0] = kmp[1] = 0;
	for(int i = 1; i < lenb; ++ i){
		while(k && b[i] != b[k]) k = kmp[k];
		kmp[i + 1] = b[i] == b[k] ? ++ k : 0;
	}
	k = 0;
	for(int i = 0; i < lena; ++ i){
		while(k && a[i] != b[k]) k = kmp[k];
		k += a[i] == b[k] ? 1 : 0;
		if(k == lenb) printf("%d\n", i - lenb + 2);
	}
	for(int i = 1; i <= lenb; ++ i) printf("%d ", kmp[i]);
	return 0;
}

```



---

## 作者：渡海 (赞：2)

..本人比较弱所以完全看不懂求next的KMP做法（洛谷的kmp和传统的不同）

所以我想了一个更简单的，外加正确的KMP匹配。一次AC了。


举一个例子：ABA

           next= 0 0 1

怎么判断next数组呢？第一个为0（不懂的百度），next[2]判断next[1]和next[2]，next[3]判断next[1]&&next[2]和next[2]&&next[3]，如果不等再判断next[1]和next[3]，是向两侧逐渐减小范围的。


想法是这样，next数组的第一个一定是0，然后剩下的用以下做法（我的nexta[]从1开始而不是从0开始，但是字符串ab都是从0开始的）：b[j-1]=b[i-k+j] -----一个很六六的方程，用这个方法不会TLE


附上代码：

        
    
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
char a[1000001],b[1001];
int nexta[1001];
int main()
{
    int na,nb,i,j,k,w,e,s;
    scanf("%s%s",a,b);
    na=strlen(a);
    nb=strlen(b);
    nexta[1]=0;//不用解释上面了吧...
       //求next数组：
    for(int i=2;i<=nb;i++){//i从2开始，因为第一个next[1]=0
        int k=i,ans=0;//定义一个k记录每一次选的数，ans为最大解
        while(k!=1){
            for(int j=1;j<k;j++){
                if(b[j-1]==b[i-k+j]){//这就是重要的判断条件
                    ans++;
                }else{
                    ans=0;
                    break;
                }
            }
            k--;
            if(ans!=0){
                nexta[i]=ans;//如果有解，就加入（此时肯定是最大的）
                k=1;//相当于跳出while
            }
        }
    }
//下面就是寻常的匹配
    j=0;
    for(i=0;i<na;i++)
    {
        while(j&&a[i]!=b[j])
        {
            j=nexta[j];
        }
        if(a[i]==b[j])
        {
            j++;
        }
        if(j==nb)
        {
            printf("%d\n",i-nb+2);
        }
    }
    for(j=1;j<=nb;j++)
    {
        printf("%d ",nexta[j]);
    }
    return 0;
}

```

---

## 作者：远航之曲 (赞：2)

KMP算法简单说就是当匹配不成功的时候根据next表中的值跳跃

楼下没有用string的，但这题用string非常好使，具体请见代码



```cpp
#include <cstring>//这题用string非常方便 
#include <cstdio>
#include <iostream>
using namespace std;
string s,s1;
int next[1000];
void get_next(string s)
{
    for (int k=0;k<=s.size();k++)
    {
        string st=s.substr(0,k+1);
        for (int i=1;i<st.size();i++)
        {
            string s1=st.substr(0,i),s2=st.substr(st.size()-i,i);//前缀与后缀 
            if(s1==s2) next[k]=i;
        }
    }    
}
void match(string s,string s1)
{
    int l=s.size()-1,l1=s1.size()-1;
    for (int i=0;i<=l;i++)
    {
        int j;
        for (j=0;j<=l1;j++)
            if (s[i+j]!=s1[j])
            break;
        if (j-1==l1)    //j还是加了1，所以要减1 
        {
            printf("%d\n",i+1);//匹配成功 
            continue;
        }
        else
        i+=next[j];     //跳跃 
    }
}
main()
{
    cin>>s>>s1;
    get_next(s1);
    match(s,s1);
    for (int i=0;i<s1.size();i++)
        printf("%d ",next[i]);
}
```

---

## 作者：noall (赞：2)

KMP还是很难理解啊。

写了一篇极为详细的算法教程来造福群众（~~快夸我，快夸我！~~

学完$kmp$玄学字符串匹配，我已经快没有勇气学冯巨佬yy的~~自动**AK**机了~~，好像我确实很菜啊，这还是个黄题。

看完别忘点赞啊

# 字符串匹配

什么是字符串匹配呢？

给出一个长度为$n$的文本串$test$（以下简称为$t$）和一个长度为$m$的匹配串$pattern$（以下简称为$p$），问在$t$中有没有$p$这个子串，如果有，求出其在文本串中的所有匹配点$i$。

### example：

$t$：

| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $t$  | a    | b    | a    | x    | y    | a    | b    | c    | a    |

$p$：xyabc

显然，$p$在$t$中的匹配为：

| 下标 | 0    | 1    | 2    | 3     | 4     | 5     | 6     | 7     | 8    |
| ---- | ---- | ---- | ---- | ----- | ----- | ----- | ----- | ----- | ---- |
| $t$  | a    | b    | a    | **x** | **y** | **a** | **b** | **c** | a    |
| $p$  |      |      |      | x     | y     | a     | b     | c     |      |

位置即为$4$。

# 朴素做法

有的人会说，so easy，我枚举判断每个位置是不是一个匹配点，遇到不匹配的停止比较直接换个位置从头枚举得了。

### 时间复杂度

可能的匹配点可能有$O(m-n)$个，所以最坏情况下，时间复杂度为$O(m(n-1))$。总而言之，枚举慢的一批(~~真香警告~~,对于随机数据，枚举其实很优秀)。

# KMP玄学

那么相对于朴素算法，$KMP$就很优秀了。它首先用$O(m)$的时间对模板进行预处理，然后用$O(n)$的时间匹配。那么这样的时间复杂度为$O(m+n)$，空间复杂度为$O(m)$。

虽然代码很短，但是并不容易理解，我先放出代码，也许有不看解释就能懂的巨佬。

### code

[提交地址](<https://www.luogu.org/problemnew/show/P3375>)

```c++
#include<cstdio>
#include<cstring>

const int maxn=1e6+10;

char c[maxn],p[maxn];
int next[maxn];

void find(int lc,int lp);void getfail(int lp);

int main(){
    scanf("%s",c);scanf("%s",p);
    int lc=strlen(c),lp=strlen(p);
    find(lc,lp);
    for(int i=1;i<=lp;i++) printf("%d ",next[i]);
    return 0;
}

void find(int lc,int lp){
    getfail(lp);
    int j=0;
    for(int i=0;i<lc;i++){
        while(j&&p[j]!=c[i]) j=next[j];
        if(p[j]==c[i]) j++;
        if(j==lp) printf("%d\n",i-lp+2);
    }
    return ;
}

void getfail(int lp){
    next[0]=0; 
    for(int i=1;i<lp;i++){
        int j=next[i];
        while(j&&p[i]!=p[j]) j=next[j];
        next[i+1]=p[i]==p[j]?j+1:0;
    }
    return ;
}
```

记录：

![草图 _2_.png](https://img.langlangago.xyz/2019/04/21/5cbbc25522784.png)

### 思路

我们用这个例子来帮助解释：

$t$：`abcabdababcabc`

$p$：`abcabc`

开始比较：

```
1.
t:abcabdababcabc
  |
p:abcabc
match！

2.
t:abcabdababcabc
   |   
p:abcabc
match！

3.
t:abcabdababcabc
    |
p:abcabc
match！

4.
t:abcabdababcabc
     |
p:abcabc
match！

5.
t:abcabdababcabc
      |
p:abcabc
match！

6.
t:abcabdababcabc
       |
p:abcabc
it's not a match！
```

看！第六步，比较`d`与`c`发现不匹配。那么我们需要将模板串右移一位，重新从$p$的开头比较吗？不！

我们发现在$p$中，在失配点`c`之前，有相同的前缀和后缀，即**ab**c**ab**（加粗的），这说明我们只需要将前面的`ab`移到后面的`ab`在$t$中匹配好的`ab`下面，直接比较ab**c**ab中的c与$t$中的d，emmm#(吐血倒地)，我知道这很难懂，不要紧，通过例子来理解一下：

```
6.
t:abcabdababcabc
       |
p:abcabc
it's not a match！

开始移动

7.
t:abcabdababcabc
       |
p:   abcabc
```

这样做的原因是，因为`ab`已经比较过，且已经匹配，所以就不需要再比较一次了。

就这样一直做下去：

```
7.
t:abcabdababcabc
       |
p:   abcabc
it's not a match！
没有相同的前后缀
所以，

8.
t:abcabdababcabc
       |
p:     abcabc
it's not a match！

9.
t:abcabdababcabc
        |
p:      abcabc
match！

10.
t:abcabdababcabc
         |
p:      abcabc
match！

11.
t:abcabdababcabc
          |
p:      abcabc
it's not a match！

12.
t:abcabdababcabc
          |
p:        abcabc
match！

12.
t:abcabdababcabc
           |
p:        abcabc
match！

13.
t:abcabdababcabc
            |
p:        abcabc
match！

14.
t:abcabdababcabc
             |
p:        abcabc
match！

15.
t:abcabdababcabc
              |
p:        abcabc
match！

16.
t:abcabdababcabc
               |
p:        abcabc
match！
```

结束。找到匹配点。

#### next辅助数组

怎么做到的呢？这里需要依靠一个$next$数组。

上面这个例子的$next=${$0,0,0,0,1,2,3$}。

记录的是，当匹配到$p$的一位时失配，所需要跳转到$p$的位置。

emmm……#(吐血倒地)

好吧，又玄学了。

用上面的一个例子来理解：

```
6.
t:abcabdababcabc
       |
p:abcabc
next:0,0,0,0,1,2,3
               ^
it's not a match！

此时d与a不匹配，对应到next数组就是2。
那么d将与匹配串中的第三（下标为2）个进行匹配。
也就是这样：

7.
t:abcabdababcabc
       |
p:   abcabc
next:0,0,0,0,1,2,3
         ^
it's not a match！
```

这样继续做下去。

这就是$next$数组的用法。

##### 构造

怎么构造呢？

直接上个例子：

```
1.
  0123456
p:abcabcd
  ji
next:0,0,0,0,0,0,0,0

2.
  0123456
p:abcabcd
  j i
next:0,0,0,0,0,0,0,0

3.
  0123456
p:abcabcd
  j  i
next:0,0,0,0,0,0,0,0
           ^
```

我们看到，在第3步中$p_i==p_j$，所以我们将$next_{i+1}$赋值为$j+1$。

然后$j$向右移动一格，$i$向右移动一格。

```
3.
  0123456
p:abcabcd
  j  i
next:0,0,0,0,1,0,0,0
             ^

4.
  0123456
p:abcabcd
   j  i
next:0,0,0,0,1,2,0,0
               ^
             
5.
  0123456
p:abcabcd
    j  i
next:0,0,0,0,1,2,3,0
                 ^
                 
6.
  0123456
p:abcabcd
  j     i
next:0,0,0,0,1,2,3,0
                   ^
```

构造完成。

##### code

```c++
void getfail(int lp){
    next[0]=0; 
    for(int i=1;i<lp;i++){
        int j=next[i];
        while(j&&p[i]!=p[j]) j=next[j];
        next[i+1]=p[i]==p[j]?j+1:0;
    }
    return ;
}
```

剩下的也就没什么了，理解代码就好了。

[**更好的阅读体验**](https://www.langlangago.xyz/index.php/archives/31/)

---

## 作者：岂曰无衣 (赞：1)

这是个纯的KMP，只是顺带把next数组输出一下而已


```cpp
#include<iostream>
#include<cstring>
using namespace std;
int p[1000001];//即题目中的NEXT
char a[1000001],b[1000001];//所读入的字符串
int la,lb,j;//la,lb即长度
int main(){
    cin>>a+1;
    cin>>b+1;//读入字符串，+1是为了让字符从a[1]的位置开始读，方便后来操作；
    la=strlen(a+1);
    lb=strlen(b+1);
    for (int i=2;i<=lb;i++){    
        while(j>0&&b[i]!=b[j+1])
        j=p[j];    
        if(b[j+1]==b[i])j++;    
        p[i]=j;
```
}//求p的过程
```cpp
    j=0;
    for(int i=1;i<=la;i++){
            while(j>0&&b[j+1]!=a[i])
            j=p[j];
            if (b[j+1]==a[i]) 
            j++;
            if (j==lb) cout<<i-lb+1<<endl;
```
}//寻找子串
```cpp
    for (int i=1;i<=lb;i++)
    cout<<p[i]<<' ';//输出p数组
    return 0;
}

```

---

## 作者：jiezi (赞：1)

#新学的算法，一遍过很激动，写一篇题解

###若用暴力写，即BF算法，即从被匹配串（长串）第一位开始匹配，若不完全匹配，找到长串上一次被匹配的下一位继续匹配，这###样如果被匹配串的长度为m，匹配串的长度为n，则时间复杂度为O(mn)例如最坏情况s1:aaaaaaaaaaaab;s2:aab,之所以这么低效，###是因为假如匹配到短串的最后一位才发现不完全匹配，下一步从头开始匹配就代表这一次白匹配了，那么能不能继续上一次的匹配###呢？

###这就需要kmp算法了，其中next数组表示匹配串（每一位之前字符串前缀和后缀相等最大范围），代表加入这次匹配不完全，下一###步直接将短串前缀移到上次后缀的地方，而next数组能确定这一次匹配的第一个位置


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int nxt[1000005],ans[1000005],zz,cur=0,l1,l2;
void calnext(string s){
    nxt[1]=0;//第一位无法匹配 
    zz=0;
    for(int i=2;i<=l2;i++){
        while(zz&&s[i]!=s[zz+1]) zz=nxt[zz];//如果后缀加上i位后不与前缀匹配，分割前缀，直至匹配为止，临界为前缀分割为1个 
        if(s[i]==s[zz+1]) zz++;//如果第i位与之前已匹配的前缀中某一位匹配，则加上i后前缀和后缀匹配的最大长度为nxt[z]+1 
        nxt[i]=zz;
    }
}
//匹配的代码和求next数组的代码非常相似，因为匹配的过程和求next数组的过程其实是一样的。
//假设现在字符串f的前i个位置都和从某个位置开始的字符串O匹配，现在比较第i+1个位置。
//如果第i+1个位置相同，接着比较第i+2个位置；
//如果第i+1个位置不同，则出现不匹配，我们依旧要将长度为i的字符串分割，获得其最大公共长度next[i]，
//然后从next[i]继续比较两个字符串。
void kkmmpp(string ss,string tt){
    zz=0;
    for(int i=1;i<=l1;i++){//一位一位的匹配长串 
        while(zz&&ss[i]!=tt[zz+1]) zz=nxt[zz];
        if(ss[i]==tt[zz+1]) zz++;
        if(zz==l2){
            ans[++cur]=i-l2+1;
            zz=nxt[zz];
        }
    }
}
int main(){
    string s,t;
    cin>>s>>t;
    l1=s.size();l2=t.size();
    s=" "+s;t=" "+t;//从1开始 
    calnext(t);//计算匹配的next数组 
    kkmmpp(s,t);//匹配 
    for(int i=1;i<=cur;i++) cout<<ans[i]<<"\n";//输出出现位置 
    for(int i=1;i<=l2;i++) cout<<nxt[i]<<" ";//输出匹配字符串next数组 
    return 0;
}
```

---

## 作者：teafrogsf (赞：1)

题解里都是大神，想必他们的代码更加完美~~**比如楼下的yyb大神**~~，所以这里只是想要说一下C++党在这个题目提交的注意事项：

1、不要用玄学getline，否则直接全WA

2、用scanf注意getchar，偶尔舍弃一下string也是不错的XD

3、cincout会超时，不过可以关闭流同步(std::ios::sync\_with\_stdio(false))

4、不要像我一样傻傻的多次执行KMP(这样是84分)

当然，代码还是要贴的，不过可能有点丑233333

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#define f(i,a,b) for(i=a;i<=b;++i)
int next[10010];
int m;
char s[1000010],p[1010];
void get()//这个next有一点略微的不同
{
    int pz=strlen(p);
    next[0]=-1;
    int k=-1,j=0;
    while(j<pz)
    {  
        //printf("%d %d\n",k,j);   
        if(k==-1||p[j]==p[k])  
        {
            ++j,++k;
            next[j]=k;
        }  
        else k=next[k];
    }
}
void find()//KMP核心算法，但我感觉求next才是核心
{
    int i=0,j=0;
    int sz=strlen(s),pz=strlen(p);
    while(i<sz)
    {
        if(j==-1||s[i]==p[j])++i,++j;
        else j=next[j];
    if(j==pz)
        {
            printf("%d\n",i-j+1);
            j=next[j];
        }
    }
}
int main()
{
    int i,j;
    scanf("%s",s),getchar(),scanf("%s",p);
    get();
    find();
    f(i,1,strlen(p))printf("%d ",next[i]);putchar('\n');
    return 0;
}
```

---

## 作者：dk962725312 (赞：1)

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
char s1[1000005],s2[1005]; 
int len1,len2;
int f[1000005],n[1005];
//看了大部分人使用了循环，但我认为利用递归构筑跳跃表也是一条非常不错的思路
int buildn(int i,int j){
    if(s2[i+1]!=s2[j+1])
    {
        if(j==0) return 0;
        buildn(i,n[j]);
    }
    else
        return j+1; 
} 
//构筑f【】，类似于构筑跳跃表。
int buildf(int i,int j){
    if(s1[i+1]!=s2[j+1])
    {
        if(j==0) return 0;
        buildf(i,n[j]);
    }
    else
        return j+1; 
}
int main(){
    scanf("%s",s1);
    scanf("%s",s2);
    len1=strlen(s1);len2=strlen(s2);
    for(int i=len1;i>=1;i--) s1[i]=s1[i-1];
    for(int i=len2;i>=1;i--) s2[i]=s2[i-1];
   //为两个数组赋初值
    n[1]=0;
    if(s1[1]==s2[1]) f[1]=1;
    else f[1]=0;
    for(int i=1;i<len2;i++) n[i+1]=buildn(i,n[i]);
    for(int i=1;i<=len1;i++) {
        f[i+1]=buildf(i,f[i]);
        if(f[i]==len2) printf("%d\n",i-len2+1);//注意输出的是字符串的首位，需要把f[i]的值减去长度后+1
    }
    for(int i=1;i<=len2;i++) printf("%d ",n[i]);
}
```

---

## 作者：chenxinyang2006 (赞：1)

* KMP相关的概念简介

前缀、后缀：略

模式串：匹配用的串，本题中为s2。

文本串：被匹配的串，本题中为s1

Border ： 对于一个串s，当它的前缀s[1],s[2],s[3]……s[k]和后缀s[n - k + 1],s[n - k + 2],s[n - k + 3]……s[n]完全相同时，这就是串s的一个长度为k的border。注意：border的长度不能为n，因为这没有意义。

CABACA

对于这个串，它只有一个border，是CA，而长度为1位的C和A并不匹配。所以，如果一个串最长border长度为x，那么它并不一定有长度为x-1的border。

一般来说，一个串的最长border又被称为fail指针，所以这部分需要认真理解，否则接下来你很有可能看不懂。

* KMP匹配方式

下文所有a[i]表示文本串当前匹配到的点，b[j]表示模式串当前匹配到的点。默认b[1]到b[j]与a[i - j + 1]到a[i]完全匹配。

首先，每次都将i向右移一格，这时有两种可能：

（1）a[i] == b[j+1]

下一位也匹配，直接j++

（2）a[i] != b[j+1]

如果是这样的话，我们必然希望接下来依然保持匹配，且j越大越好，看一下下面的例子：

模式串：ACABAC i = 4

文本串：ACAC j = 3

这个时候，我们要找到s2的一个前缀，使得这个前缀（设长度为k）与模式串的一段s1[i - k + 1] ~ s1[i]完全相同，这样j就可以变为k。

如果要使得s2[1] ~ s2[k] == s1[i - k + 1] ~ s1[i]，那么s2[1] ~ s2[k - 1] 必须和 s1[i - k + 1] ~ s1[i - 1]完全相同，所以找到k - 1的可行值，再将s2[k]和s1[i]做比较就好。

而现在和s1[i - k + 1] ~ s1[i - 1]完全相同的，就是s2的后缀[j - k + 2] ~ s2[j]，梳理一下逻辑关系：

希望找到一个k，使s1[i - k + 1] ~ s1[i - 1] == s2[1] ~ s2[k - 1],现在已知s2[j - k + 2] ~ s2[j] == s1[i - k + 1] ~ s1[i - 1]。也就是说找到一个最大的k，使s2[1] ~ s2[k - 1] == s2[j - k + 2] ~ s2[j]

回头一看上面的定义，这个k - 1不就是s2长度为j的前缀的border吗？所以只需要去看s2长度为j的前缀的所有border的下一位，是否和s1[i]匹配就可以了，匹配就直接将j赋值为k + 1

事实上，s2长度为j的前缀的次长border，就是s2长度为j的前缀的border的border，证明附在后面，因为大多数人估计已经没有耐心看了，先放一下代码。

```cpp
for(int i = 1;i <= n;i++){
	while(s2[now + 1] != s1[i] && now){//一直跳border
		now = fail[now];
	}
	if(s2[now + 1] == s1[i]){//有可能now跳到0都匹配不上，直接now++不判断会错
		now++;
	}
	if(now == m){
	    printf("%d\n",i - m + 1);
	}
}
```

fail[now]表示s2长度为now的前缀的最长border，虽然证明过程复杂，但代码很短。

* 如何求border

其实这里和前面KMP匹配原理差不多，如果看得懂上面，下面应该也看得懂。

文本串自己匹配自己就可以了（是不是很秀）

这里好像也多解释不了什么，直接类推一下，如果你看不懂，肯定是因为你上面不想看那么多文字而直接跳到这里了。

```cpp
fail[1] = 0;//border定义长度不可以为n
int now = 0;
for(int i = 2;i <= m;i++){
    while(s2[now + 1] != s2[i] && now){
	    now = fail[now];
    }
    if(s2[now + 1] == s2[i]){
    	now++;
    }
	fail[i] = now;
}
```

* 为什么次长border就是border的border

使用反证法证明：

![](https://cdn.luogu.com.cn/upload/pic/75171.png)

蓝线表示原串，黄线是原串的最长border，绿线是黄线的最长border。

假设存在黑线，它是蓝线的次长border，根据定义，其长度大于绿线，小于黄线。

那么既然它是蓝线的border，所以蓝线的后缀肯定也有一个完全一样的子串；而它又被黄线所包含，右边的黄线的前缀肯定也是完全一样的。

很明显，右边的黑线既是黄线的前缀，又是黄线的后缀，它就是黄线的一个border，那么绿线就不是黄线的最长border了，所以不存在这样的黑线，也就是说次长border就是border的border。

* 关于KMP的时间复杂度

总是有人看到for套while就说这是$n ^ 2$或者nm，我也是很无语，看一下这个程序。

```cpp
int j = 1;
for(int i = 1;i <= n;i++){
   while(j > i && j > 0){
     j--;
   }
   j += 2;
}                  
```

这个难道是$n ^ 2$的？j每次增加2，每一次减少不会低于0，显然至多只会有2 * n次减少，所以复杂度还是O（n）的。

而KMP也是如此，j每次至多增加1，每次减少至少减少1，所以最多也只会有n次减少，总复杂度还是O（n）

综合起来，求fail O（m），匹配O（n），总复杂度O（n+m），是一种十分牛逼的算法，还是学一下为好。

总代码（这个有发的必要吗？）

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
int n,m;
int fail[1000005];
char s1[1000005],s2[1000005];

int main(){
	scanf("%s%s",&s1[1],&s2[1]);
	n = strlen(s1 + 1);
	m = strlen(s2 + 1);
	fail[1] = 0;
	int now = 0;
	for(int i = 2;i <= m;i++){
	    while(s2[now + 1] != s2[i] && now){
		    now = fail[now];
	    }
	    if(s2[now + 1] == s2[i]){
	    	now++;
	    }
		fail[i] = now;
	}
	now = 0; 
	for(int i = 1;i <= n;i++){
		while(s2[now + 1] != s1[i] && now){
			now = fail[now];
		}
		if(s2[now + 1] == s1[i]){
			now++;
		}
		if(now == m){
		    printf("%d\n",i - m + 1);
		}
	}
	for(int i = 1;i <= m;i++){
		printf("%d ",fail[i]);
	}
	return 0;
} 
```


---

## 作者：Valhalla_Is_Calling (赞：1)

## 这可是标准的KMP算法！！

### ~~HDU上数据范围是1000，暴力都能过~~，**但机智如洛谷**，将数据范围提升到1000000！

先来简单介绍一下KMP算法：

KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。

字符串的模式匹配是对字符串的基本操作之一，广泛应用于生物信息学、信息检索、拼写检查、语言翻译、数据压缩、网络入侵检测等领域，如何简化其复杂性一直是算法研究中的经典问题。字符串的模式匹配实质上就是寻找模式串P是否在主串T 中，且其出现的位置。我们对字符串匹配的效率的要求越来越高， 应不断地改良模式匹配算法，减少其时间复杂度。

KMP算法是由D.E. Knuth、J.H.Morris和V.R. Pratt提出的，可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。这个算法是由高德纳和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终由三人于1977年联合发表。该算法减少了BF算法中i回溯所进行的无谓操作，极大地提高了字符串匹配算法的效率。

#### 现在回到本题。

  举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示：

1. S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[1]跟P[0]匹配，相当于模式串要往右移动一位（i=1，j=0）

![](https://img-blog.csdn.net/20140723224710203)

2. S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0）


![](https://img-blog.csdn.net/20140726213551553)

  3. 直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1）
  
![](https://img-blog.csdn.net/20140726213602848)

  4. S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2），如此进行下去
  
![](https://img-blog.csdn.net/20140726213343578)

  5. 直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0）
  
![](https://img-blog.csdn.net/20140726213353687)

  6. 至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。

![](https://img-blog.csdn.net/20140726213631208)

#### 上面就是KMP算法的具体操作，转载自：https://blog.csdn.net/v_july_v/article/details/7041827

```cpp
cin>>str;
cin>>pattern;
kmp(str,pattern);
```
这里首先是读入和调用

```cpp
int last=-1;
slen=strlen(s);
plen=strlen(p);
getfail(p,plen);
```
引出getfail函数计算next数组

```cpp
int getfail(char *p,int plen)
{
	Next[0]=0;
	Next[1]=0;
	for(int i=1;i<plen;i++)
	{
		int j=Next[i];
		while(j&&p[i]!=p[j]) j=Next[j];
		Next[i+1]=(p[i]==p[j])?j+1:0;
	}
}
```
getfail函数

下面给出完整代码：

```cpp
#include<iostream>
#include<string.h>
#define MAXN 1000001
using namespace std;
char str[MAXN],pattern[MAXN];
int Next[MAXN];
int cnt;
int slen,plen;
int getfail(char *p,int plen)
{
	Next[0]=0;
	Next[1]=0;
	for(int i=1;i<plen;i++)
	{
		int j=Next[i];
		while(j&&p[i]!=p[j]) j=Next[j];
		Next[i+1]=(p[i]==p[j])?j+1:0;
	}
}
int kmp(char *s,char *p)
{
	int last=-1;
	slen=strlen(s);
	plen=strlen(p);
	getfail(p,plen);
	int j=0;
	for(int i=0;i<slen;i++)
	{
		while(j&&s[i]!=p[j]) j=Next[j];
		if(s[i]==p[j]) j++;
		if(j==plen)
		{
			cout<<i+2-plen<<endl;
		}
	}
}
int main()
{
	cin>>str;
	cin>>pattern;
	kmp(str,pattern);
	for(int i=1;i<=plen;i++) cout<<Next[i]<<" ";
	return 0;
}
```
这个代码来自于《算法竞赛：从入门到进阶》，粘上去的是我重构之后的代码



---

## 作者：Sophon (赞：1)

看了很多讲KMP的，全都没看懂（太菜了），直到看了lyd大佬的蓝书

&emsp;&emsp;两个字符串$\;A[1\sim N]\;$和$\;B[1\sim M]\;$，目标是判断$\;A\;$是不是$\;B\;$的子串。显然，最暴力的办法是，枚举$\;B\;$中每一个位置$\;i\;$, 把$\;A[\,1\,]\;$与$\;B[\,i\,]\;$对齐，然后逐一向后比较$A[\,2\,]$和$\;B[i+1]\;...\;$是否相等。这种办法虽然简单易行，但复杂度高达$O(MN)$, 无法接受。下面尝试优化它。  
&emsp;&emsp;下图是尝试在$\;B[1+j-i]\;$处匹配$\,B\,$串的情形，如果$\;B[1+j-1\sim j]\;$与$\;A[1\sim j]\;$匹配，而$\;B[j+1]\;$与$\;A[i+1]\;$失配，按照暴力做法，之后需要回溯，尝试对齐$\;B[2+j-i]\;$和$\;A[\,1\,]\;$, 重新从头匹配。仔细观察可以发现，**这一趟匹配和上一趟是有重合部分的**，这一趟的$\;A[1\sim i-1]\;$和上一趟的$\;A[2\sim i]\;$都在和$\;B[2+j-i\sim j]\;$进行着匹配。所以，如果我们预先知道$\;A[1\sim i-1]\neq A[2\sim i]\;$，那么就可以断定这一趟肯定失配，因为上一趟$\;A[2\sim i]=B[2+j-i\sim j]\;$。同理，再下一趟也可以进行这样的分析。于是，如果预先知道了**A串中以i结尾的非前缀子串和A的前缀匹配的最长长度$k$**，（如下图第三条A所示），就可以直接去判断$\;B[j+1]\;$和$\;A[k+1]\;$是否相等。  

![](https://i.loli.net/2019/07/25/5d39662d0f44522912.png)

&emsp;&emsp;所以，接下来的目标就是，预处理$\;A\;$串中以$\;i\;$结尾的非前缀子串和$\;A\;$的前缀匹配的最长长度$\;k\;$，用数组$\;next[\,]\;$保存一对 $(i, k)$. 即：
$$next[i]=max(k),\qquad k<i\quad and \quad A[i-k+1\sim i]=A[1\sim k]$$  

&emsp;&emsp;为了叙述方便，下面称满足$\;k<i\;$且$\;A[i-k+1\sim i]=A[1\sim k]$的$k$ ”具有$\;i\;$性质“。

&emsp;&emsp;显然暴力地按照定义求next数组复杂度过大，需要寻求优化。
此时，KMP算法的发明者发现了一个神奇的规律：

**引理**  
&emsp;&emsp;若$j_0$满足$\;i\;$性质，即$\;j_0<i\;$且$\;A[i-j_0+1\sim i]=A[1\sim j_0]$, 那么小于$\,j_0\,$的最大的满足$\;i\;$性质的数是$\;next[j_0]\;$。

**证明**（不喜掠过~~）  
&emsp;&emsp;反证。假设存在$\;next[j_0]<j_1<j_0\;$,其中$\,j_1\,$满足$\,i\,$性质, 即$\;j_1<i\;$且$\;A[i-j_1+1\sim i]=A[1\sim j_1]$。如下图所示：  
![](https://i.loli.net/2019/07/26/5d3a767adcf9a69841.png)

图中不是黑色的部分若颜色相同则表示字符串相同。其中第二段和第三段存在共同部分（黄+绿），即$\;A[j_0-j_1+1\sim j_0]=A[1\sim j_1]\;$, 这表明$\;j_1\;$具有$\;j_0\;$性质，而根据定义，$\;next[j_0]\;$才是具有$\;j_0\;$性质中最大的一个，但现在$\;j_1>next[j_0]\;$，矛盾。   
&emsp;&emsp;证毕。     
    
                   
&emsp;&emsp;所以，根据引理，当$\;next[i-1]\;$计算完之后，我们立即就能知道，所有具有$\;i-1\;$性质的所有数从大到小为：   
$\;next[i-1]\;,next[next[i-1]]\;,next[next[next[i-1]]]\;...$  
又因为，如果$\;j\;$具有$\;i\;$性质，那么$\;j-1\;$也一定具有$\;i-1\;$性质，（字符串$\;A[i-j+1\sim i]\;$和$\;A[1\sim j]\;$相同的前提是$\;A[i-j+1\sim i-1]\;$和$\;A[1\sim j-1]\;$相同）。因此$\;next[i]\;$最终的值一定在$\;next[i-1]+1\;,next[next[i-1]]+1\;,next[next[next[i-1]]]+1\;...$ 中。所以在计算$\;next[i]\;$的时候，只需从大到小一个一个验证即可。

&emsp;&emsp;所以，$\;next[\,]\;$求法过程为：   

&emsp;&emsp;1. 初始$\;next[1]=j=0\;$, 假设$next[1\sim i-1]\;$已经求出，下求$\;next[i]\;$  
&emsp;&emsp;2. 不断尝试扩展当前的匹配长度$\;j\;$,如果失败，即下一个字符不相等，令$\;j=next[j]\;$, 直到$\;j=0\;$为止  
&emsp;&emsp;3. 如果成功，$\;j=j+1\;$, $\;next[i]\;$值即为$\;j\;$.

```cpp
next[1] = 0;
for (int i = 2, j = 0; i <= n; i++)
{
	//每次进while时j为上次next[i-1]
	while (j > 0 && a[i] != a[j + 1])
	{
		j = next[j];//next[next[...next[i-1]]
	}
	if (a[i] == a[j + 1])//排除最后一次仍然不匹配，j=0否则j加一
	{
		j++;
	}
    next[i] = j;
}
```
求完$\;next[\,]\;$之后，~~为了借用刚刚的思路方便偷懒~~，定义$\;f[\,]$为$\,B\,$中以$\,i\,$结尾的子串和$\;A\;$的前缀能够匹配的最长长度，即：
$$next[i]=max(k),\qquad k<=i\quad and \quad B[i-k+1\sim i]=A[1\sim k]$$   
于是求$\;f[\,]\;$的方法与$\;next[\,]\;$基本相同
```cpp
for (int i = 1, j = 0; i <= m; i++)
{
	while (j > 0 && (j == n || b[i] != a[j + 1]))
	{
		j = next[j];
	}
	if (b[i] == a[j + 1])
	{
		j++;
	}
    f[i] = j;
	//if(f[i]==n),A在B中出现
}
```

---

## 作者：G我就是菜G (赞：1)

### KMP思想

用于判断字符串 $A$ 是否为字符串 $B$ 的子串，并求出现位置

我们将字符串 $A$ 称为待处理的串【这名字有点草率】，将字符串 $B$ 称为模式串

主要分为两步：

1. 对于模式串 $B$ 进行自我匹配，生成一个 $nxt[i]$ 的数组（$nxt[i]$ 表示以第 $i$ 的位置的字符结尾的非前缀子串能与自己前缀能匹配的最大长度）

	如 $ababb$ 的 $nxt[i]$ 数组就为 $0\;0\;1\;2\;0$

2. 将 $A$ 与模式串 $B$ 进行匹配，生成 $f[i]$ 数组（$f[i]$ 表示以字符串 $A$ 中第 $i$ 个字符结尾的子串与模式串 $B$ 的前缀能匹配的最大长度）

	同时，当 $f[i]==strlen(B)$ 时，说明字符串 $A$ 在第 $i-strlen(B)+1$ 处与模式串 $B$ 匹配上了，输出该位置即可

### $nxt$数组求法

如模式串 $abababb$

1. 对于 $nxt[1]=0$ 
2. 定义 $now+1$ 为当前与 $s1[i]$ 匹配的位置
	1. 当 $s1[now+1]==s1[i]$ 时，$nxt[i]=now+1$
   2. 否则可说明 $now==0$，则 $nxt[i]=0$
3. 每次对于 $now$
	1. 当 $s1[now+1]==s1[i]$ 时，退出循环
   2. 否则，令 $now=nxt[now]$，直到 $now==0$

代码如下：
```cpp
    nxt[1]=0;
    for (int i=2,now=0;i<=len1;i++)
    {
        while (now && s1[i]!=s1[now+1]) now=nxt[now];
        now+=(s1[i]==s1[now+1]);
        nxt[i]=now;
    }
```

### $f$数组求法

同 $nxt$ 数组求法，将其中 $s1[i]!=s1[now+1]$ 改为 $s2[i]!=s1[now+1]$

代码如下：
```cpp
    f[1]=(s2[1]==s1[1]);
    for (int i=2,now=(s2[1]==s1[1]);i<=len2;i++)
    {
        while (now && s2[i]!=s1[now+1]) now=nxt[now];
        now+=(s2[i]==s1[now+1]);
        f[i]=now;
        if (f[i]==len1) printf("%d\n",i-len1+1);
    }
```

### 完整代码：
```cpp
#include <bits/stdc++.h>
char s1[1000010],s2[1000010];
int nxt[1000010],f[1000010],len1,len2;
using namespace std;
int main()
{
    scanf("%s",s2+1);
    scanf("%s",s1+1);
    len1=strlen(s1+1);len2=strlen(s2+1);
    nxt[1]=0;
    for (int i=2,now=0;i<=len1;i++)
    {
        while (now && s1[i]!=s1[now+1]) now=nxt[now];
        now+=(s1[i]==s1[now+1]);
        nxt[i]=now;
    }
    f[1]=(s2[1]==s1[1]);
    for (int i=2,now=(s2[1]==s1[1]);i<=len2;i++)
    {
        while (now && s2[i]!=s1[now+1]) now=nxt[now];
        now+=(s2[i]==s1[now+1]);
        f[i]=now;
        if (f[i]==len1) printf("%d\n",i-len1+1);
    }
    for (int i=1;i<len1;i++)
        printf("%d ",nxt[i]);
    printf("%d\n",nxt[len1]);
    return 0;
}
```

---

## 作者：arthurwalnut (赞：1)

Kmp作为一大基础算法，是字符串学习的一个必备知识。
~~它也很简单。~~

---
## 算法用途： 

   在字符串中查找子串。例子：在BBC   ABCDAB  ABCDABCDABDE
中查找ABCDABD。

   最基础的子串查找就是从第一个字符开始一个一个向后移动并进行比较。kmp算法在此基础上进行了优化，可以减少不必要的比较。每一次失败的比较中必定会有已经重合的部分和末尾不重合的部分，如果下一次比较只是往后移动一位，就会导致效率的损失——下一步直接从不匹配的地方开始，这才能使比较的次数最小化。

---
## 算法过程：

首先需要对子串建立一个对应的数组，它的每个元素的下标与要查找的子串中的字符位置相对应，就叫next好了——它的作用就是计算**每次比较失败后向后移动的长度**。这个数组建立的原则如下：
   
   1.数组第一个元素为-1
   
   2.对于第n个元素：查看第n-1个元素的值并设为a（用点伪代码）
```
    if(a==-1)
    	next[n]=0;
    else
     	compare(第n-1个和第a个字符)
        	same
            	next[n]=a+1;
            not same
            {
            	a=next[a];
                back to "if(a==-1)";
            }
```

    
  ~~应该能看得懂~~
  
  有了这个数组，我们就能做题了：
  
  在BBC   ABCDAB  ABCDABCDABDE中找ABCDABD，可求出ABCDABD的next数组值为{-1,0,0,0,0,1,2}。
  
  1.比较ABCDABD和BBC ABC，显然不匹配，向后移动直到第一个字符与之匹配（这里没有技巧，常规操作）
  
  2.到了ABCDABD和ABCDAB ，这里就要用next数组了——我们在最后一个字符时没有匹配上，就查找next数组得到最后一个D值为2。（敲黑板划重点）这里就要用到kmp算法中的移动了：**移动的位数=已经匹配上的字符数量-没有匹配上的字符的next数值。**于是6-2=4，移动4位，继续比较并重复这样的操作。
  
  ~~嗯对到这儿就结束了。~~
  
~~完整代码是不可能贴的，这辈子都不可能。~~

想想还是把完整代码贴上去比较好：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
char a1[2000000],a2[2000000];
int kmp[2000000];
int main()
{
    cin>>a1>>a2;
    kmp[0]=kmp[1]=0;
    int len1=strlen(a1),len2=strlen(a2);
    int k;
    k=0;
    for(int i=1;i<len2;i++)
    {
        while(k&&a2[i]!=a2[k])k=kmp[k];
        kmp[i+1]=a2[i]==a2[k]?++k:0;
    }
    k=0;
    for(int i=0;i<len1;i++)
    {
        while(k&&a1[i]!=a2[k])k=kmp[k];
        k+=a1[i]==a2[k]?1:0;
        if(k==len2)
		cout<<i-len2+2<<endl;
    }
    for(int i=1;i<=len2;i++)
	cout<<kmp[i]<<' ';
    return 0;
}
```


---

## 作者：arfa (赞：1)

# 浅显 KMP
不管在搜索引擎,还是Words查找时,都会运用到字符串匹配。

KMP算法是一种改进的字符串匹配算法,由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现,所以叫KMP。



---

## 朴素方法
很容易理解,却非常慢的办法。一个一个比较,速度最慢为O(nm);

慢的原因在:要一个一个往下找,失配后要重新找。

---

## KMP

我们想,怎样提高速度?很容易想到,如果失配后不是重新,而是再往后几步,岂不是美哉?

这时就出现了KMP算法,失配后不是重新找,而是往后几步。几步?
```pascal
已经匹配数量 减去 部分匹配数量 = 退后步数
```
部分匹配数量并不是指剩下的未匹配数量,而是有一个**部分匹配表**。(对于要匹配的字符串)


### 部分匹配表

首先我们了解几个定义:
```pascal
1.前缀
2.后缀
```
看样例:
```pascal
hello的前后缀:
前缀: h he hel hell
后缀: o lo llo ello
```
那么,如果有前缀=后缀的情况,s[i]的部分匹配数就是前缀(后缀)的len。

```pascal
ABAB
"A"没有前后缀。
"AB"前缀:"A",后缀:"B"。(无相同)
"ABA"前缀:"A","AB",后缀:"B","BA"。(无相同)
"ABAB"
前缀:A AB ABA
后缀:B AB BAB (有相同)
所以ABAB的部分匹配表为
A  B  A  B
0  0  0  2(长度"AB")
```

回到KMP,只要我们失配,就直接跳到后面去就可以了,时间复杂度为O(n+m),部分匹配表需要预处理。

---
## 演示:
```pascal
匹配串:ABACABADDABBABAB
模式串:ABAB

ABACABADDABBABAB
ABAB<-
  (失配,已匹配数量(3)-部分匹配数(0),跳3格)
  
ABACABADDABBABAB
   ABAB (失配)
   
ABACABADDABBABAB
    ABAB (失配,3-0=3)
    
ABACABADDABBABAB
       ABAB (失配,一直到...(省略))
       
ABACABADDABBABAB
         ABAB (失配,2-0=2) 
         
ABACABADDABBABAB
           ABAB (失配) 
           
ABACABADDABBABAB
            ABAB(匹配)            
```



---

## 作者：z3475 (赞：0)

KMP算法主要用于字符串匹配，但是其扩展能解决很多字符串问题。下面我来给大家讲解KMP算法 tips:以下数组均为从0开始
## 1、next数组
next数组的定义是对于一个字符串str,next[i]表示的是在str中

[0,next[i])以及
[i-next[i],i)

这两个区间中的字符严格相等的最大next[i]值(区间不能重叠

举个例子

`a b c a b c b b a b c`

`0 0 0 1 2 3 0 0 1 2 3`

`[a]  b   c  [a] `=> `next[4]` = `1`

`[a] [b]  c  [a]  [b]` => `next[5]` = `2`

`[a] [b] [c] [a]  [b]  [c]` => `next[6]`=`3`

画一张图意会

![](https://www.z3475.cc/blog/wp-content/uploads/2018/08/temp3-1-300x101.png)

其中的线表示相同的一堆相同的字符,长方形指一个(一堆)字符,中间的省略号省略了一堆字符

手算不难得出，我们先不讲这个数组通过算法怎么生成的，我们先讲怎么用这个数组

## 2、KM
在介绍普通的KM算法前我们先回顾一下解决字符串查找的朴素算法
```cpp
char s1[MAXN],s2[MAXN];//s1.find(s2);
int l1=strlen(s1),l2=strlen(s2);
int j=0,i=0;
while (i!=l1){
	if (s1[i]==s2[j]) i++,j++;//匹配
	else i-=j-1,j=0;//失配
    if (j==l2){
    	cout << i-j+1 << endl;
        j=0;//相当于失配
	}
}
```
明显失配时的移动可以优化,那怎么优化呢,我们就要用到`next[]`

根据`next[]`我们可以画一张关于失配图
![](https://www.z3475.cc/blog/wp-content/uploads/2018/08/temp1-1-300x107.png)

最佳的移动是这样

![](https://www.z3475.cc/blog/wp-content/uploads/2018/08/temp2-1-300x86.png)

所以检测到失配时

`i`可以保留，`j` = `next[j-1]`

但是`j`肯定有等于`0`的情况,`j` - `1` 不就越界了吗?

-我们就在计算时加一个F()函数检测`j` - `1`是不是越界了

于是用`next[]`优化后的代码就出来了

```
#define F(x,nxt) (x<0?-1:nxt[x])
int i=0,j=0;
while (i!=l1){
	if (j==-1||s1[i]==s2[j]) i++,j++;
	else j=F(j-1,nxt);
	if (j==l2){
		cout << i-j+1 << endl;
		j=F(j-1,nxt);
	}
}
```

## next[]的计算
考虑以下字符串,我们要算出它的`next[]`

a b c a b c a b

手算得

0 0 0 1 2 3 1 2

显然对于每一个`next[i]`一种情况可以这么弄

`next[i]` = `next[i-1]` + `1` **if** `str[i]`==`str[next[i-1]]`

那当`str[i]`!=`str[next[i-1]]`的情况呢

先给一个结论,然后我们来试着证明它

我们就令`j` = `next[i-1]`
```cpp
while (1){

	if (str[i]==str[j]) {next[i] = j + 1;break;} //①
	if (str[i]!=str[j]) j = next[j] - 1;  //②
    
}
```
即
`next[i]` = `j` + `1`,`str[i]`==`str[j]` ①

`j` = `next[j]` - `1`,`str[i]`!=`str[j]` ②

一旦执行到①,`next[i]`就算完了
证明过程我们用一张图来意会

![](https://www.z3475.cc/blog/wp-content/uploads/2018/08/temp1-300x44.png)

我们要求箭头指向的那个字符的next值,这里我们假设前面字符的next值已经求完了

但是我们可能会检测到②这种情况,图就变成了这样

![](https://www.z3475.cc/blog/wp-content/uploads/2018/08/temp2-300x50.png)

这样的话显然是正确的,剩下的证明过程,提一个主要思路

1、证明真正的next值<算出来的值是假的

2、证明真正的next值>算出来的值是假的

又在上一章讲到我们还要把next[]往后移一位且next[0]=-1

怼在一起有代码
```cpp
#include<bits/stdc++.h>
#define F(x,nxt) (x<0?-1:nxt[x])
using namespace std;
char s2[1000010],s1[1000010];
int nxt[1000010];
int main(){
	scanf("%s%s",s1,s2);
	int l1=strlen(s1),l2=strlen(s2);
	//计算nxt[]
	nxt[0]=0;
	for (int i=1;i<l2;i++){
		int j=nxt[i-1];
		while (j&&s2[i]!=s2[j]) j=nxt[j-1];
		if (s2[j]==s2[i]) nxt[i]=j+1;
		else nxt[i]=0;
	}
	//匹配 
	int i=0,j=0;
	while (i!=l1){
		if (j==-1||s1[i]==s2[j]) i++,j++;
		else j=F(j-1,nxt);
		if (j==l2){
			cout << i-j+1 << endl;
			j=F(j-1,nxt);
		}
	}
	for(int i=0;i<l2;i++) cout << nxt[i] << ' ';
	return 0;
}
```


---

## 作者：青丘杨哲 (赞：0)

KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。（摘自百度百科https://baike.baidu.com/item/kmp%E7%AE%97%E6%B3%95/10951804?fr=aladdin ）

前几天刚刚把KMP的代码背出来，然后找到了这么一个模板题，顺手打了一个，居然过了……

```cpp
#include<bits/stdc++.h>//万能库
using namespace std;//std命名空间
string T,P;//用C++的string会更方便
int f[1000001];
void Get_Fail()//产生f数组
{
	int m=P.length();//只要模式串长度就够了
	f[0]=f[1]=0;//事实上并不用，因为全局变量已经自动初始化为0
	for (int i=1;i<m;i++)
	{
		int j=f[i];
		while (j&&P[j]!=P[i])
		{
			j=f[j];
		}
		f[i+1]=P[i]==P[j]?j+1:0;
	}
}
void KMP_Find()
{
	int n=T.length(),m=P.length();//分别表示文章串和模式串的长度
	Get_Fail();//预处理产生f数组
	int j=0;
	for (int i=0;i<n;i++)
	{
		while (j&&P[j]!=T[i])
		{
			j=f[j];
		}
		if (P[j]==T[i])
		{
			j++;
		}
		if (j==m)
		{
			cout<<i-m+2<<endl;//输出匹配位置（偏移量），注意位置是从1开始的，而不是0！
		} 
	}
}
int main()
{
	cin>>T>>P;
	KMP_Find();//跑一遍KMP
	for (int i=1;i<=P.length();i++)
	{
		cout<<f[i]<<" ";//输出f数组
	}
	return 0;
}
```

纯代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
string T,P;
int f[1000001];
void Get_Fail()
{
	int m=P.length();
	f[0]=f[1]=0;
	for (int i=1;i<m;i++)
	{
		int j=f[i];
		while (j&&P[j]!=P[i])
		{
			j=f[j];
		}
		f[i+1]=P[i]==P[j]?j+1:0;
	}
}
void KMP_Find()
{
	int n=T.length(),m=P.length();
	Get_Fail();
	int j=0;
	for (int i=0;i<n;i++)
	{
		while (j&&P[j]!=T[i])
		{
			j=f[j];
		}
		if (P[j]==T[i])
		{
			j++;
		}
		if (j==m)
		{
			cout<<i-m+2<<endl;
		} 
	}
}
int main()
{
	cin>>T>>P;
	KMP_Find();
	for (int i=1;i<=P.length();i++)
	{
		cout<<f[i]<<" ";
	}
	return 0;
}
```

算法部分和预处理部分神似……

不过这里的代码还不是完整的KMP算法，真正的KMP算法还包括对失配函数的优化（就是KMP_Find函数），这只是MP算法，但是因为时间复杂度也已经达到了O(n+m)，而且已经够用了，所以就拿这个MP算法来交了吧！（参考自刘汝佳、陈峰编著的《算法入门经典——训练指南》第二版）

---


# [COCI 2017/2018 #1] Lozinke

## 题目描述

最近，超级流行的社交网络 Secret Network 发生了用户信息泄露事件。其中包含所有用户的密码。

Mihael 是一名最近在研究计算机安全的年轻学生，他发现整个事件非常有趣。在对社交网络进行实验时，他发现了另一个安全漏洞！当你输入任何包含与实际密码相同的子字符串的字符序列时，登录将会成功。例如，如果用户的密码是 abc，输入字符串 abc、abcd 或 imaabcnema，系统将成功登录，而对于 axbc，登录将失败。

Mihael 想知道存在多少对不同用户的有序对，使得第一个用户可以使用他们自己的密码登录为第二个用户。

## 说明/提示

第二个测试用例的说明：

第一个用户可以作为第二个用户登录，第二个用户可以作为第一个用户登录，第三个用户可以作为第一个和第二个用户登录。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3
aaa
aa
abb
```

### 输出

```
1```

## 样例 #2

### 输入

```
3
x
x
xy
```

### 输出

```
4```

## 样例 #3

### 输入

```
5
mir
mirta
ta
ir
t
```

### 输出

```
6```

# 题解

## 作者：lc_lca (赞：15)

其实这道题远不用写进制版的hash

首先开个map<string,int>mp记录每个字符串的所有子串在几个串中出现。

例如说有个串abc就mp[a]++,mp[ab]++,mp[abc]++,mp[b]++,mp[bc]++,mp[c]++;

但是这就出问题了

假如一个串是aa那么mp[a]被加了两次，而一个子串只能对于当前串的贡献为1

所以用一个map<string,bool>tmp记录当前每个子串是否被加过，被加过就不再加了。

当然tmp在每一个串都要清零。

预计复杂度 20000 * 55 * log20000

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>mp;
map<string,bool>tmp;
string s[20010];
int main()
{
	int n;
	scanf("%d",&n);
	mp.clear();
	for(int i=1;i<=n;i++)
	{
		cin>>s[i];
		tmp.clear();
		int len=s[i].length();
		for(int k=1;k<=len;k++)
		{
			for(int j=k;j<=len;j++)
			{
				string t=s[i].substr(k-1,j-k+1);//截取子串，开头是k-1，长度是j-k+1
				if(tmp[t]==true)continue;
				tmp[t]=true;
				mp[t]++;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		ans+=mp[s[i]]-1;//统计
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：暌违 (赞：7)

最近沉迷于COCI的题目~~其实是因为在考场上爆0场下找信心~~

回到正题。对于这题，因为n<=20000，枚举两两字符串然后暴力对每一位进行扫描，时间复杂度为O（n^2*size）(size为字符串长度)，妥妥Tle(40分)。实际上这一题是要求我们判断一堆字符串中，其中一个是另一个的子串的对数。可以转换为字符串哈希的问题。

思路就是对于每一个字符串的子串都丢到一个哈希表去判断它是否在之前字符串中出现过，最后再把自己扔进哈希表。这样复杂度就可以降到大约为O（n size^ 2*k）(k为哈希的常数，**一般不大**)
要注意的是，为了保证对于每一个字符串而言，可能是它的子串的字符串都在前面被处理完了，所以要按字符串长度排序。

但是有一个细节，就是**如果一个字符串的子串有相同的话我们只计算一次**，但按照之前的思路会计算两遍，所以我们还需要一个小哈希去判断当前子串是否在**这个字符串**中出现过。但是问题又来了，对于每一个新的字符串而言我们都要清空前面的小哈希，这样的时间复杂度让人难以承受。解决方法很简单，用结构体哈希，多一个域标记这个子串是在第几个字符串中出现的即可。下面是代码：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=220000;
struct data
{
	long long id,x;
};
bool cmp(string a,string b)
{
	if (a.size()!=b.size()) return a.size()<b.size();
	return a<b;
}
vector<long long> Has[maxn];
vector<data> has[maxn];
char s[15];
long long hash1=19260817,hash2=19660813,M=218357;
string a[200005];
long long n,q,kk1,kk2,k1,k2,e1[maxn],e2[maxn],ans;
int main()
{
	//freopen("Lozinke.in","r",stdin);
	//freopen("Lozinke.out","w",stdout);
	cin>>n;
	//std::ios::sync_with_stdio(false);
	for (int i=1;i<=n;i++) 
	{
		scanf("%s",s);
		a[i]=s;
	}
	sort(a+1,a+1+n,cmp);
	for (int i=1;i<=n;i++)
	{
		string t=" "+a[i];
		for (int x=1;x<=a[i].size();x++)
	 	{
	 		e1[x]=(e1[x-1]*131%hash1+t[x])%hash1;
	 		e2[x]=(e2[x-1]*131%hash2+t[x])%hash2;
	 	}
	 	long long kk1=1,kk2=1;
	 	for (int x=1;x<=a[i].size();x++)
	 	{
	 		long long p=x;
			kk1=kk1*131%hash1;
			kk2=kk2*131%hash2; 
	 		while (p<=a[i].size())
	 		{
				long long c1=(e1[p]-(e1[p-x]*kk1)%hash1+hash1)%hash1;
	 			long long c2=(e2[p]-(e2[p-x]*kk2)%hash2+hash2)%hash2;
				int p1=0,k=c1%M,p2=0;//模运算很慢，对于一些重复模的地方要取出来，尤其写hash，容易超时， 
				data tmp;
			    tmp.x=c2%hash2,tmp.id=i;
	 			if (has[k].size()>0)
				{
					int len=has[k].size();
					for (int j=0;j<len;j++)
					{
						if (has[k][j].x==c2&&has[k][j].id==i)  {p1=1;break;
						}//这个子串出现过，且在这个串中重复出现，不做操作;
						else if (has[k][j].x==c2) {has[k][j].id=i;break;
						}//这个子串出现过，但不在这个串中重复出现，更新id即可 
					}	
			    } 
			    else 
			    {
			    	has[k].push_back(tmp);
                    //这个子串从未出现过，要把它的哈希值和id(第几个字符串)push_back进去
			    }
				if (p1==0)
				{
					if (Has[k].size()>0)
			 	   	{
						for (int j=0;j<Has[k].size();j++)
						{
					 		if (Has[k][j]==c2) 
							 {
							 	ans++;
							 	if (x==a[i].size()) ans++;
							 }
						}
			       	}    
				}
			    p++;
	    	}
	 	}
	 	Has[e1[a[i].size()]%M].push_back(e2[a[i].size()]%hash2);
	}
	cout<<ans;
	return 0;
}
```
然后我们发现超时两个点~~毒瘤出题人毒瘤数据~~为什么呢？去官网下载数据可以发现，出题人为了卡掉哈希，特地出了两个里面很多字符串都相同的数据~~甚至有一个全是相同字符串~~

我们可以算时间复杂度，除去哈希的操作，O(n*size^2)操作数已达到1000000，当相同字符串特别多，大哈希冲突多，吊桶法哈希的链被拖得很长时，单次哈希查找复杂度达到10000的数量级。所以我们考虑优化（也可以用stl,可以参考这个[洛谷P4421 [COCI2017-2018#1] Lozinke STL写法](https://www.luogu.org/blog/mycute-is-so-cuteQAQ/luo-gu-p4421-coci2017-20181-lozinke-stl-xie-fa)~~推销blog~~）

我们发现相同时我们相当于重复计算了，可以通过把相同字符串压缩为一个字符串来优化，这样可以保证在大哈希表中相同字符串只出现一次。排序后将相同字符串压为一个并记录其这种字符串个数（用结构体）。然后只需要把大哈希判重成功时的ans++，改为ans+=a[Has[k][j].id].cs*a[i].cs即可。

当然还有一个细节。对于同种字符串可为彼此子串的情况（如样例2），我们手写几个例子可以发现，同种字符串内部匹配次数公式为：(a[i].cs-1)*a[i].cs.

余下的细节，在代码中有标注，这里不再赘述，请读者自行思考：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=220000;
struct data
{
	long long id,x;
};
bool cmp(string a,string b)
{
	if (a.size()!=b.size()) return a.size()<b.size();
	return a<b;
}
vector<data> Has[maxn];//
vector<data> has[maxn];//
char s[15];
long long hash1=19260817,hash2=19660813,M=218357;
string b[maxn];
struct Nobe
{
	string st;int cs;
}a[maxn];
int gs;
long long n,q,kk1,kk2,k1,k2,e1[maxn],e2[maxn],ans;
int main()
{
	//freopen("Lozinke.in","r",stdin);
	//freopen("Lozinke.out","w",stdout);
	cin>>n;
	//std::ios::sync_with_stdio(false);
	for (int i=1;i<=n;i++) 
	{
		scanf("%s",s);
		b[i]=s;
	}
	sort(b+1,b+1+n,cmp);
	int sum=1;
	for  (int i=2;i<=n+1;i++)
	{
		if (b[i]==b[i-1]) sum++;
		else
		{
			gs++;
			a[gs].cs=sum;
			a[gs].st=b[i-1];
			sum=1;
		}
	}
	for (int i=1;i<=gs;i++)
	{
		string t=" "+a[i].st;
		for (int x=1;x<=a[i].st.size();x++)
	 	{
	 		e1[x]=(e1[x-1]*131%hash1+t[x])%hash1;
	 		e2[x]=(e2[x-1]*131%hash2+t[x])%hash2;
	 	}
	 	long long kk1=1,kk2=1;
	 	for (int x=1;x<=a[i].st.size();x++)
	 	{
	 		long long p=x;
			kk1=kk1*131%hash1;
			kk2=kk2*131%hash2; 
	 		while (p<=a[i].st.size())
	 		{
				long long c1=(e1[p]-(e1[p-x]*kk1)%hash1+hash1)%hash1;
	 			long long c2=(e2[p]-(e2[p-x]*kk2)%hash2+hash2)%hash2;
				int p1=0,k=c1%M,p2=0;//模运算很慢，对于一些重复模的地方要取出来，尤其写hash，容易超时， 
				data tmp;
			    tmp.x=c2%hash2,tmp.id=i;
	 			if (has[k].size()>0)
				{
					int len=has[k].size();
					for (int j=0;j<len;j++)
					{
						if (has[k][j].x==c2&&has[k][j].id==i)  {p1=1;break;
						}//这个子串出现过，且在这个串中重复出现，不做操作;
						else if (has[k][j].x==c2) {has[k][j].id=i;break;
						}//这个子串出现过，但不在这个串中重复出现，更新id即可 
					}	
			    } 
			    else 
			    {
			    	has[k].push_back(tmp);//这个子串从未出现过，要把它的哈希值和id(第几个字符串)push_back进去 
			    }
				if (p1==0)
				{
					if (Has[k].size()>0)
			 	   	{
						for (int j=0;j<Has[k].size();j++)
						{
					 		if (Has[k][j].x==c2) 
							 {
							 	ans+=a[Has[k][j].id].cs*a[i].cs;//
							 }
						}
			       	}    
				}
			    p++;
	    	}
	 	}
	 	ans+=(a[i].cs-1)*a[i].cs;//
	 	data tmp;
	 	tmp.x=e2[a[i].st.size()];tmp.id=i;
	 	Has[e1[a[i].st.size()]%M].push_back(tmp);//
	}
	cout<<ans;
	return 0;
}
```
时间复杂度其实差不多，但常数接近O（1）~~反正比stl跑得快，可以在最优解第一找到我~~

---

## 作者：WwWkKk (赞：7)

我我我水过的~~（主动承认）~~

可以哈希一下233

哈希。。应该不用多说了吧，就当26进制处理掉

之后，把搞好的数据排序+二分。。就优美地水过了

不过注意同一个字符串不能加多个同样的（比如aaa中有两个aa字串）

bb就是处理这个的

蒟蒻一个QWQ

大神勿喷

下面代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
long long num;
long long b[1100005],bb[60];
char a[20005][15];
int find(long long p){
	int l=1,r=num;
	while (l<r){
		int mid=(l+r)>>1;
		if (b[mid]<p) l=mid+1;else r=mid;
	}
	return l;
}
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++){
		scanf("%s",a[i]+1);
	}
	for (int i=1;i<=n;i++){
		int num1=0;
		int len=strlen(a[i]+1);
		for (int j=1;j<=len;j++){
			int t=len-j+1;
			long long p=a[i][j]-'a'+1;
			bb[++num1]=p;
			for (int k=2;k<=t;k++){
				p=p*26+a[i][j+k-1]-'a'+1;
				bb[++num1]=p;
			}
		}
		sort(bb+1,bb+1+num1);
		for (int j=1;j<=num1;j++) if (bb[j]!=bb[j-1]) b[++num]=bb[j];
	}
	long long ans=-n; //-n防止匹配到自己
	sort(b+1,b+1+num);
	for (int i=1;i<=n;i++){
		long long p=a[i][1]-'a'+1;
		int len=strlen(a[i]+1);
		for (int j=2;j<=len;j++){
			p=p*26+a[i][j]-'a'+1;
		}
		int t=find(p);
		while (b[t]==p) ans++,t++;
	}
	printf("%lld",ans);
}
```

---

## 作者：Danny_boodman (赞：5)

## 排序？二分？喵喵喵？

蒟蒻瑟瑟发抖

直接哈希就好啦啊！

先把每个大串hash一下扔进map，然后直接暴力枚举每个大串的子串是否是其他的大串就好了啊emmm

```
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <map>
using namespace std;
map<long long, int> used, jiaed;
const int N = 200010;
int n, cnt;
long long zhan[N];
char str[N][15];
long long has(int a, int l, int r)
{
	long long ans = 1ll;
	for(int i = l;i <= r; ++i)
	ans = (ans * 26 + (str[a][i] - 'a') + 1);//26进制 
	return ans;
}
void add()//将每个大串扔进map 
{
	for(int i = 1;i <= n; ++i)
	{
		int len = strlen(str[i]);
		used[has(i, 0, len - 1)]++;
	}
}
int check(int a)
{
	int ans = -1, len = strlen(str[a]), p = 0;
	for(int l = 0;l < len; ++l)
	 for(int r = l ;r < len; ++r)//枚举子串 
	  if(used[has(a, l, r)] && !jiaed[has(a, l, r)]) 
	  {
	  	ans += used[has(a, l, r)]; jiaed[has(a, l ,r)] = 1;// 不要加重复了哟 
	  	zhan[++p] = has(a, l ,r);
	  }
	for(int i = 1;i <= p; ++i) jiaed[zhan[i]] = 0;
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n; ++i)
	scanf("%s", str[i]); 
	add();
	for(int i = 1;i <= n; ++i)
	cnt += check(i);
	printf("%d", cnt);
	return 0;
}
```


撒花撒花！！

---

## 作者：zhouwc (赞：5)

## 可以访问我的[博客](http://zwcblog.top./zwc/2018/09/15/%E9%A2%98%E8%A7%A3-p4421-coci2017-20181-lozinke/#i-5)以获得更佳的阅读体验（包括题目翻译）



#### 一道水题？


下面的大神用的都是hash，本蒟蒻太弱了只会一种暴力方法，stl大法好啊。

因为读入的字符串的长度小于10，而且子串必须是连续的，这样的话子串总和并不会太多。

那么对于读入的字符串，直接暴力把这个字符串所包含的所有子集给存到set里面。

然后直接映射到map里，把子集的个数加1.

最后直接统计答案，子集为a[i]（读入字符串）的有多少个。全部累加，最后需要剪掉n（因为我们把需要匹配的整个串也算进去了，要剪掉```1*n```个）

讲的已经很清楚了，如果不理解或者有疑问的话可以提出来，也可以私信问我。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
string a[20005];
set<string>s;
map<string,int>q;  //stl的强大力量
int n;
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        s.clear();
        cin>>a[i];
        for (int j=0;j<a[i].size();j++)
        {
            string c;
            for (int k=j;k<a[i].size();k++)
            {
                c.push_back(a[i][k]);
                s.insert(c); //存到set里面
            }
        }
        for(set<string>::iterator i=s.begin();i!=s.end();i++) //map
        {
            q[*i]++;
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
        ans+=q[a[i]];
    printf("%d",ans-n);
    return 0;
}
```

---

## 作者：zzr8178541919 (赞：3)

这是hash的一道非常好的题

看到一道没什么思路的题目时，一定不要想着去看题解。要敢于尝试，说不定暴力一下就过了呢？

首先我们预处理出所有的连续子串的hash值。这个直接暴力即可。

然后对于每一个字符串，我们可以二分来找到那些字符串的hash值相同的字符串。可以用stl的函数，我用的是手写。

主要就是hash值得处理，一共只会有26种字母，所以我在这用的是以26位进制的处理方式。这样可以保证hash出来的值具有独特性。

！！！ 要记得开 long long，不然会wa两个点。
```cpp
#include<cmath>
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define int long long 
using namespace std;
char a[20005][15];
int b[2000005];
int sum=0;
int wns[2000005];
int Find(int val)
{
	int l=1;
	int r=sum;
	while(l<r)
	{
		int mid=(l+r)/2;;
		if(wns[mid]<val)
		l=mid+1;
		else
		r=mid;
	}
	return l;
}
signed main()
{
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>(a[i]+1);
	}
	for(int i=1;i<=n;i++)
	{
		int now=0;
		int len=strlen(a[i]+1);
		for(int j=1;j<=len;j++)
		{
			int t=len-j+1;
			int p=a[i][j]-'a'+1;
			b[++now]=p;
			for(int k=2;k<=t;k++)
			{
				p=p*26+a[i][k+j-1]-'a'+1;
				b[++now]=p;
			}
		}
		sort(b+1,b+now+1);
		for(int j=1;j<=now;j++)
		{
			if(b[j]!=b[j-1])
			wns[++sum]=b[j];
		}
	}
	int ans=-n;
	sort(wns+1,wns+1+sum);
	for(int i=1;i<=n;i++)
	{
		int nowp=a[i][1]-'a'+1;
		int len=strlen(a[i]+1);
		for(int j=2;j<=len;j++)
		{
			nowp=nowp*26+a[i][j]-'a'+1;
		}
		int t=Find(nowp);
		while(wns[t]==nowp)
		{
			ans++;
			t++;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：xiezheyuan (赞：2)

首先发现字符串长度过小，可以考虑一些基于字符串长度暴力的做法。

我们枚举每一个字符串，将其插入到 Trie 中，标记每个节点做了多少次字符串的终结节点。

然后还是枚举每一个字符串，再枚举字符串的每一个前缀，前缀的前缀可以覆盖到所有子串，我们将这个前缀放到 Trie 上查询，每次遇到一个 Trie 上的节点就贡献答案，然后如果 Trie 上没有对应的节点了就返回。

注意到你可能会算重，所以对于枚举的每一个字符串，用 `map` 来去重。

时间复杂度 $O({nL^2\log L})$，其中 $L$ 为字符串的长度。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 4e5 + 5;
int n;
string s[N];

int t[N][26], ec = 1, val[N];

void insert(string s){
	int cur = 0;
	for(char i : s){
		if(!t[cur][i - 'a']) t[cur][i - 'a'] = ++ec;
		cur = t[cur][i - 'a'];
	}
	val[cur]++;
}

map<int,int> zak;

int query(string s){
	int cur = 0, ans = 0;
	for(char i : s){
		if(!t[cur][i - 'a']) return ans;
		cur = t[cur][i - 'a'];
		if(!zak[cur]){
			ans += val[cur];
			zak[cur] = 1;
		}
	}
	return ans;
}

signed main(){
    #ifdef LOCAL
    freopen("bug.in", "r", stdin);
    freopen("bug.out", "w", stdout);
    #endif
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n;
    for(int i=1;i<=n;i++){
    	cin >> s[i];
    	insert(s[i]);
    }
    int ans = 0;
    for(int i=1;i<=n;i++){
		zak.clear();
    	for(unsigned j=0;j<s[i].size();j++){
    		string zky;
    		for(unsigned k=j;k<s[i].size();k++) zky += s[i][k];
			// cout << i << ' ' << j <<  ' ' << query(zky) << '\n';
    		ans += query(zky) - (j == 0);
    	}
    }
    cout << ans;
    return 0;
}

// Written by xiezheyuan
···

---

## 作者：mol_low (赞：2)

题目传送门：[lozinke](https://www.luogu.org/problemnew/show/T89059)
# 分析
我们注意到字符串长度不会超过$10$，而字典树又没法写这道题(~~虽然有人写出来了~~)，所以我们可以暴力枚举出每个字符串的所有子串(最多$55$个不同的)。为了方便比较，我们对这些子串哈希即可(注意到最终结果会很大，而$n$很小，我们需要离散化我们哈希出的数组)，时间复杂度$O(n)$(常数很大)。

$PS:$上面的做法会被毒瘤数据卡掉一组，吸个氧就能$A$(~~氧气打法好啊~~)。

$Code:$
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
#define LL long long
#define N 20000
#define LEN 10
#define P 97

int n , tot;
int num , cnt[55 * N + 2];
LL ans;
char s[LEN + 5];
unsigned LL Power_[LEN + 2] , value_[N + 2][LEN + 2] , b[N * 55 + 2];
int len[N + 2];
bool appear[55 * N + 2];

unsigned LL Substr(int i , int l , int r) {
    return value_[i][r] - value_[i][l - 1] * Power_[r - l + 1];
}

int main() {
    Power_[0] = 1;for(int i = 1; i <= LEN; i ++) Power_[i] = Power_[i - 1] * P;
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) {
        scanf("%s", s);
        len[i] = strlen(s);
        for(int j = len[i]; j >= 1; j --) s[j] = s[j - 1];
        for(int j = 1; j <= len[i]; j ++) value_[i][j] = value_[i][j - 1] * P + (s[j] - 96);
        for(int j = 1; j <= len[i]; j ++)
            for(int k = j; k <= len[i]; k ++)
                b[++ tot] = Substr(i , j , k);
    }
    sort(b + 1 , b + tot + 1);
    tot = unique(b + 1 , b + tot + 1) - b - 1;
    int tmp;
    for(int i = 1; i <= n; i ++) {
        memset(appear , 0 , sizeof(appear));
        for(int j = 1; j <= len[i]; j ++)
            for(int k = j; k <= len[i]; k ++) {
                tmp = lower_bound(b + 1 , b + tot + 1 , Substr(i , j , k)) - b;
                if(!appear[tmp]) 
                    appear[tmp] = 1 , cnt[tmp] ++;
            }
    }
    for(int i = 1; i <= n; i ++) {
        tmp = lower_bound(b + 1 , b + tot + 1 , Substr(i , 1 , len[i])) - b;
        ans += cnt[tmp] - 1;
    }
    printf("%lld\n", ans);
    return 0; 
}
```

---

## 作者：Violet___Evergarden (赞：1)

# 前言
STL 大法好，自带的 unordered_map 用哈希表实现且拥有自己的哈希函数。
# 做法
开一个 unordered_map 数组 $l$ 记录每个字符串出现的次数，所以需要再用一个 
unordered_map 数组 $v$ 记录每个字串是否出现，于是接下来只需要把每个密码的子串分解出来记录一下就行了呢！
# AC CODE
~~又到了大家最喜欢的代码环节！~~
```cpp
#include<iostream>
#include<unordered_map>
#define RE register
using namespace std;
int n,ans;
unordered_map<string,int>l;
unordered_map<string,bool>v;
struct S
{
    string a;
}s[20001];
int main()
{
cin>>n;
for(RE int i=1;i<=n;++i)
{
    string y="";
    cin>>s[i].a;
    v.clear();//将记录每个密码中每个字串是否出现的数组清空
    for(RE int j=0;j<s[i].a.length();j++)//枚举字串开头位
    {
        y="";
        for(RE int k=j;k<s[i].a.length();++k)//枚举字串
        {
            y+=s[i].a[k];
            if(v[y]==false)//判断字串是否出现
            {
                v[y]=true;//如果没出现就记为出现
                l[y]++;//将这个字串出现的次数加一
            }
        }
    }
}
for(RE int i=1;i<=n;++i)
{
    if(l[s[i].a]-1>0)ans+=l[s[i].a]-1;//将每个密码出现的个数加到答案上，因为拿自己的密码登录自己账号不算数所以要减一
}
cout<<ans;
return 0;
}
```
# 闲话
STL 开了 O2 之后快到飞起，从 $3$ 秒加速到 $0.9$秒！

---

## 作者：NSOI (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4421)

其实这题可以直接枚举每一个子串，然后用 map 存储，加上它们出现的次数。
```
for(int i=1;i<=n;++i){
       oh.clear();//清空
       int len=s[i].length();
       for(int j=1;j<=len;j++){
			    for(int k=j;k<=len;k++){
				    string x=s[i].substr(j-1,k-j+1);//截取子串
				    if(oh[x])continue;//判断重复
				    oh[x]=1;
				    mp[x]++;
			    }
		  }
   }
```


完全不用 hash。

最后再统计答案即可

```c
for(int i=1;i<=n;i++)
       ans+=mp[s[i]]-1;//统计ans
```


表扬：这道题数据良心，不会 TLE。

完整代码：
```c
#include<bits/stdc++.h>
using namespace std;
map<string,int>mp;//记录答案个数
map<string,int>oh;//判断是否重复出现
string s[20005];
int n;
int main(){
	scanf("%d",&n);
	mp.clear();
	for(int i=1;i<=n;++i)
       cin>>s[i];//用scanf读会读进\n
   for(int i=1;i<=n;++i){
       oh.clear();//清空
       int len=s[i].length();
       for(int j=1;j<=len;j++){
			    for(int k=j;k<=len;k++){
				    string x=s[i].substr(j-1,k-j+1);//截取子串
				    if(oh[x])continue;//判断重复
				    oh[x]=1;
				    mp[x]++;
			    }
		  }
   }
	int ans=0;
	for(int i=1;i<=n;i++)
       ans+=mp[s[i]]-1;//统计ans
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Phartial (赞：1)

首先考虑暴力算法，枚举任意两个用户，判断能否用第一个用户的密码登录第二个用户的账号，即判断第二个用户的密码是否是第一个用户的密码的子串，设密码长度为 $L$，则时间复杂度为 $O(N^2L^2)$，显然会超时。

考虑优化，先把每个密码存入哈希表，这时可以直接枚举每个密码的每个字串，然后直接在哈希表中查询，时间复杂度优化到 $O(NL^2)$，足以通过此题。

同时要注意一些细节，比如自己的子串匹配自己不会产生贡献，且重复的子串不会重复产生贡献，处理一下即可。

具体细节可见代码。

## $ Code $

```cpp
#include <iostream>
#include <unordered_map>
#include <unordered_set>

using namespace std;

const int kMaxN = 20001;

int n, cnt;
string s[kMaxN];
unordered_map<string, int> um; // 哈希表

int main() {
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> s[i];
    ++um[s[i]]; // 记录每个密码出现的次数
  }
  for (int i = 1; i <= n; ++i) {
    --um[s[i]]; // 本身不会产生贡献，所以要先减去
    unordered_set<string> m; // 由于重复子串不会重复产生贡献，所以需要去重
    for (int l = 0; l < s[i].size(); ++l) {
      for (int r = l; r < s[i].size(); ++r) { // 枚举子串
        string b = s[i].substr(l, r - l + 1);
        auto p = um.find(b);
        if (p == um.end() || m.find(b) != m.end()) { // 如果没有密码为子串或之前统计过此子串
          continue; // 则直接跳过
        }
        cnt += p->second, m.insert(b); // 统计答案，标记子串出现过
      }
    }
    ++um[s[i]]; // 重新将本身加回来
  }
  cout << cnt;
  return 0;
}

```


---


# 「化学」相对分子质量

## 题目描述

做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。

小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。

如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。

## 说明/提示

### 样例解释
金 $Au : 197$

二氧化铪 $HfO_{2}: 178.5 + 2 \times 16= 210.5$

氢氧化钙（熟石灰）$Ca(OH)_2 : 40 + (1 + 16) \times 2 = 74$

五水硫酸铜（胆矾）$CuSO_4 \cdot 5H_2O: 64 + 32 + 16 \times 4 + 5 \times (1 \times 2 + 16) = 250$

十二水合硫酸铝钾（明矾）$KAl(SO_{4})_{2} \cdot 12H_{2}O$ （嗯 用心感受 $474$ 是对的）

### 附表：可能用到的相对原子质量

|元素|相对原子质量|
|:-:|:-:|
|H|1|
|C|12|
|N|14|
|O|16|
|F|19|
|Na|23|
|Mg|24|
|Al|27|
|Si|28|
|P|31|
|S|32|
|Cl|35.5|
|K|39|
|Ca|40|
|Mn|55|
|Fe|56|
|Cu|64|
|Zn|65|
|Ag|108|
|I|127|
|Ba|137|
|Hf|178.5|
|Pt|195|
|Au|197|
|Hg|201|

### 提示

如果你没有学习过相关内容，下面的内容可能有帮助：

> zcy 教你算相对分子质量

1. 每个元素以大写开头；
2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；
3. ~( $\cdot$ ) 相当于加；
4. 下标相当于乘。

## 样例 #1

### 输入

```
Au```

### 输出

```
197```

## 样例 #2

### 输入

```
HfO_{2}```

### 输出

```
210.5```

## 样例 #3

### 输入

```
Ca(OH)_{2}```

### 输出

```
74```

## 样例 #4

### 输入

```
CuSO_{4}~5H_{2}O```

### 输出

```
250```

## 样例 #5

### 输入

```
KAl(SO_{4})_{2}~12H_{2}O```

### 输出

```
474```

# 题解

## 作者：Iowa_BattleShip (赞：17)

这题么，绝对没有蓝题难度，我个人认为黄题封顶，毕竟这是少见的不毒瘤的模拟题。  
这题很良心的没有括号嵌套，这样就不用递归那么麻烦了，直接读进来扫一遍即可，具体还是看代码吧。  
```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<map>
using namespace std;
char a[110],b[10];//a是读进来的整个字符串，b是临时字符数组，存当前元素
int l,ll;//l为a的长度，ll为b的长度
map<string,double>mp;//map大法好，存元素对应的相对原子质量
int cs(int &i)//类似快读，将字符转化为数字，同时将主函数的i同步扫过
{
	int x=0;
	for(;a[i]>='0'&&a[i]<='9';i++)
		x=x*10+(a[i]-'0');
	return x;
}
double js(int &i)//计算当前扫到的元素的相对原子质量，同样将主函数的i同步
{
	double s=0;//记录质量
	memset(b,0,sizeof(b));//清空临时字符数组
	for(ll=-1;((a[i]>='A'&&a[i]<='Z')||(a[i]>='a'&&a[i]<='z'))&&(ll<0||(ll>=0&&(a[i]>='a'&&a[i]<='z')));i++)
		b[++ll]=a[i];
    //找到目前扫到的元素
    //因为元素开头必是大写字母
    //所以当扫到的字符不为小写字母(已将这个元素的首字母读入)说明当前元素已扫完
	if(a[i]=='_')//若这元素后面有下标，就将数字读入并乘上该元素相对原子质量
	{
		i+=2;//直接跳过'_{'
		s+=mp[b]*cs(i);
	}
	else//若没有下标，直接累加上该元素相对原子质量
	{
		s+=mp[b];
		i--;
	}
	return s;
}
int main()
{
	int i,o;
	double s,k;
	mp["H"]=1;//以下为初始化
	mp["C"]=12;
	mp["N"]=14;
	mp["O"]=16;
	mp["F"]=19;
    mp["Na"]=23;
	mp["Mg"]=24;
	mp["Al"]=27;
	mp["Si"]=28;
    mp["P"]=31;
	mp["S"]=32;
	mp["Cl"]=35.5;
	mp["K"]=39;
    mp["Ca"]=40;
	mp["Mn"]=55;
	mp["Fe"]=56;
	mp["Cu"]=64;
    mp["Zn"]=65;
	mp["Ag"]=108;
	mp["I"]=127;
	mp["Ba"]=137;
    mp["Hf"]=178.5;
	mp["Pt"]=195;
	mp["Au"]=197;
	mp["Hg"]=201;
	scanf("%s",a);//合法字符串直接%s读入
	l=strlen(a);//计算长度
	for(i=0;i<l;i++)//直接扫
	{
		if(a[i]>='A'&&a[i]<='Z')//若为大写字母，说明扫到一个元素，直接累加上去
			s+=js(i);
		if(a[i]=='(')//若为左括号，则计算括号内的质量
		{
			i++;//跳过'('
			for(k=0;a[i]!=')';i++)//因为没有括号嵌套或是水合物，里面必是各种元素，所以直接累加至遇到')'
				k+=js(i);
			if(a[i+1]=='_')//判断是否有下标
				s+=k*cs(i+=3);//有则将数字乘上，i+=3是为跳过'_{'
			else
				s+=k;//没有就直接加上
		}
		if(a[i]=='~')//若有水合物
		{
			i++;//跳过'~'
			if(a[i]=='H')//若为'H'，说明只含一个水分子，直接累加
				s+=18;//一个水分子的相对分子质量为18
			else
				s+=cs(i)*18;//不为'H'说明有数量，将其乘上即可
			break;//因为水合物肯定在最后，所以直接跳出即可
		}
	}
	o=s;//利用int强制转换来判断是否有.5
	if(o==s)
		printf("%d",o);
	else
		printf("%.1f",s);
	return 0;
}
```

---

## 作者：一扶苏一 (赞：12)

# 暴力模拟，这题哪来的蓝色……

本题和17年NOIPD1T2比较相似，基本都是字符串读入，栈存储，判断，输出。
下面的题解都不是很详细，并且（貌似？）没有使用栈处理的方法，在这里列出一些可能的情况，解决方案以及基本思路。

1）	因为题干中化学式被很明显的分成了两部分，即前分子+水合，我们很自然的想到把水和前面的分子分开处理。由于~后面只可能出现水，所以我们只需要读取水的系数即可。**注意水前系数省略时为1**。下面讨论对前面分子的处理。

2）	显然，元素的分子量我们需要打一张表。使用map+(ctrl+f骚操作即可)。对于读入问题，我们选择字符串读入。

3）	在读入后，我们的字符一共有几种形式：

		1、元素
        2、原子团（带括号的）
        3、系数（下标）

4）	首先考虑对元素的处理，即怎么判定当前元素：

首先明确元素一定为大写字母开头，在本题的输入格式中，以大写字母开头的只可能是元素，所以我们选择判断如果是大写字母就认为它是一个元素。对于元素的长度为两个字符的情况，我们只需要判断它的下一位是不是小写字母。如果是，那么这个元素是个两位数。

5）	处理下标：

我们在扫描字符串的时候如果发现“_”字符，我们直接从它后面第二位开始处理，使用快速读入的思想把下标存下来。

6）	处理原子团：

由于原子团后面可能有系数，我们考虑直接把一个原子团当成一个元素存储即可。在原子团内部的处理参照（4）（5），最后在读到“)”字符时停止，把分子量加起来当做一个元素存储即可。

7）	处理元素（原子团）与下标的关系：

首先明确一点：下标一定指的是在出现下标之前最后一个元素（原子团）的大小。这点和栈很像：只对刚刚入栈的元素进行操作，于是我们想到手写一个栈，使用栈保存单个元素（原子团）的分子量，然后用另个一数组对应数组序号保存其下标。

至此，所有问题都解决了，可以开心的开始模拟了。

在这里总结几点注意事项和收获：

		1、浮点数运算！！千万别前面开浮点数后面有一个地方手残写了个int，你就直接炸了。
        2、STL的string型可以直接把字符拼接到后面，其格式为
        	s+=ch;
           注意每次使用前要调用clear()函数清零。

代码如下：注意所有非void型函数的返回值是i的新值
```cpp
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#define maxn 10010

inline void qr(int &x) {
    char ch=getchar();int f=1;
    while(ch>'9'||ch<'0')	{
        if(ch=='-')	f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')	x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    x*=f;
    return;
}

inline int max(const int &a,const int &b) {if(a>b) return a;else return b;}
inline int min(const int &a,const int &b) {if(a<b) return a;else return b;}
inline int abs(const int &x) {if(x>0) return x;else return -x;}

inline void swap(int &a,int &b) {
    int c=a;a=b;b=c;return;
}

/————————————————以上是头文件————————————————————————————/

std::map<std::string,double>che;

void build() {
	che["H"]=1;
	che["C"]=12;
	che["N"]=14;
	che["O"]=16;
	che["F"]=19;
	che["Na"]=23;
	che["Mg"]=24;
	che["Al"]=27;
	che["Si"]=28;
	che["P"]=31;
	che["S"]=32;
	che["Cl"]=35.5;
	che["K"]=39;
	che["Ca"]=40;
	che["Mn"]=55;
	che["Fe"]=56;
	che["Cu"]=64;
	che["Zn"]=65;
	che["Ag"]=108;
	che["I"]=127;
	che["Ba"]=137;
	che["Hf"]=178.5;
	che["Pt"]=195;
	che["Au"]=197;
	che["Hg"]=201;
}	//我爱打表

std::string str;
double a[maxn],ans;		
int b[maxn],top;

/*
	*a是存储分子量的手写栈，栈顶为top。
    *b是存储下标的对应数组。
    *ans既是总分子量。
*/

inline void newlet(int l,int r) {
/*
	*处理新元素，其中元素的长度为[l,r]
*/
	std::string temp;
	temp.clear();
	if(l^r) {
		temp+=str[l];temp+=str[r];
	}
	else temp+=str[l];
	a[++top]=che[temp];
}

inline int getnum(int k) {
/*
	*获得系数
    *对应存数下标
*/
	int t=k+2,temp=0;;
	while(str[t]>='0'&&str[t]<='9') temp=(temp<<3)+(temp<<1)+(str[t]^48),++t;
	if(!temp)	temp=1;
	b[top]=temp;
	return t;
}

inline int getset(int k) {
/*
	*这里处理原子团
    *前面先处理元素，使用temp存储已经有的分子量。
    *在读入完一个分子后立刻判断是否有下标，如果有下标直接乘上
*/
	double temp=0;std::string t;int p=1;
	for(int i=k+1;i;++i) {
		t.clear();
		if(str[i]==')')	{
			a[++top]=temp;return i;
		}
		if(str[i+1]>='a'&&str[i+1]<='z') {
			t+=str[i];t+=str[i+1];++i;
		}
		else t+=str[i];
		if(str[i+1]=='_') {
			int te=i+3,tem=0;
			while(str[te]>='0'&&str[te]<='9') tem=(tem<<3)+(tem<<1)+(str[te]^48),++te;
			if(!tem) tem=1;
			p=tem;i=te;
		}
		temp+=che[t]*p;p=1;
	}
}

inline void getwater(int k) {
//	直接处理水的系数
	int t=k+1,temp=0;
	while(str[t]>='0'&&str[t]<='9') temp=(temp<<3)+(temp<<1)+(str[t]^48),++t;
	if(!temp)	temp=1;			//为0即为1
	a[++top]=18*temp;
}

int main() {
	build();
	std::cin>>str;
	int l=str.length();
	for(int i=0;i^l;++i) {
		bool pd=false;
		switch(str[i]) {
			case '_':		//系数
				i=getnum(i);
				pd=true;
				break;
			case '(':		//原子团
				i=getset(i);
				pd=true;
				break;
			case '~':		//水
				getwater(i);i=l-1;
				pd=true;break;
		}
		if(pd)	continue;
        //如果上面都不是，则一定是个新元素
		if(str[i+1]>='a'&&str[i+1]<='z') {
			newlet(i,i+1);++i;
		}
		else newlet(i,i);
	}
	for(int i=1;i<=top;++i) {
		if(!b[i])	b[i]=1;
		ans+=a[i]*b[i];
	}	//退栈输出
	long long int c=ans;
	if(ans!=double(c)) {printf("%.1lf\n",ans);}
	else printf("%lld\n",c);
	return 0；
}
```

---

## 作者：cym_233 (赞：9)

暴力模拟啊，什么技术含量都没有，模拟的时候代码长一点无所谓，只要调试的时候别把自己绕晕就行了，NOIP 2017时间复杂度我就被自己代码绕进去了，死活调不出来，直接GG。

还有，比赛完了之后一看标签居然是蓝题，时间复杂度比这复杂多了才是绿题。

思路就是先读进去，然后一位一位的处理，遇到大写字母就判断元素，遇到 _ 就把后面大括号中的数字提取出来，遇到括号的话打个标记，中间的质量先不加到总质量中，遇到右括号就提取系数。遇到  ~ 就计算水的质量。


注意：水的系数有可能是1，省略不写。

我的代码中now_x很鬼畜，跳来跳去，认真看不难理解。

code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
double f1,f2,f3,f5,ans,f8,f9;
int len,now_x,f4;
bool b1;
char s[2001];
double get_word()//暴力判断元素种类 
{
    if(s[now_x]=='A')
    {
        now_x++;
        if(s[now_x]=='l')
            return 27;
        if(s[now_x]=='u')
            return 197;
        if(s[now_x]=='g')
            return 108;
    }
    if(s[now_x]=='B')
    {
        now_x++;
        return 137;
    }
    if(s[now_x]=='C')
    {
        now_x++;
        if(s[now_x]=='a')
            return 40;
        if(s[now_x]=='u')
            return 64;
        if(s[now_x]=='l')
            return 35.5;
        now_x--;
        return 12;
    }
    if(s[now_x]=='F')
    {
        now_x++;
        if(s[now_x]=='e')
            return 56;
        now_x--;
        return 19;
    }
    if(s[now_x]=='H')
    {
        now_x++;
        if(s[now_x]=='g')
            return 201;
        if(s[now_x]=='f')
            return 178.5;
        now_x--;
        return 1;
    }
    if(s[now_x]=='I')
        return 127;
    if(s[now_x]=='K')
        return 39;
    if(s[now_x]=='M')
    {
        now_x++;
        if(s[now_x]=='n')
            return 55;
        if(s[now_x]=='g')
            return 24;	
    }	
    if(s[now_x]=='N')
    {
        now_x++;
        if(s[now_x]=='a')
            return 23;
        now_x--;
        return 14;
    }
    if(s[now_x]=='O')
        return 16;
    if(s[now_x]=='P')
    {
        now_x++;
        if(s[now_x]=='t')
            return 195;
        now_x--;
        return 31;
    }
    if(s[now_x]=='S')
    {
        now_x++;
        if(s[now_x]=='i')
            return 28;
        now_x--;
        return 32;
    }
    if(s[now_x]=='Z')
    {
        now_x++;
        return 65;
    }
}
double getmath()//提取数字 
{
    int f8=0;
    while(1)
    {
        if((s[now_x]>='0')&&(s[now_x]<='9'))
        {
            f8*=10;
            f8+=s[now_x]-'0';			
        }
        else
            break;
        now_x++;
    }
    return f8;
}
void work()
{
    now_x=0;
    while(1)
    {
        if(now_x>=len)//处理完的话就跳出 
            break;
        if((s[now_x]>='A')&&(s[now_x]<='Z'))
        {
            f1=get_word();//提取到的元素质量 
            now_x++;
            if(s[now_x]=='_')
            {
                now_x+=2;
                f3=getmath();//系数 
                now_x++;
            }
            else
                f3=1;
            if(b1==false)//判断是否在括号中 
                ans+=f1*f3;//如果在，先计算括号内的质量 
            else
                f2+=f1*f3;//不在就加到总质量内 
                continue;		
        }
        if(s[now_x]=='(')//判断括号 
        {
            b1=true;
            now_x++;
            f2=0;
            continue;
        }
        if(s[now_x]==')') 
        {
            now_x++;
            if(s[now_x]=='_')
            {
                now_x+=2;
                f3=getmath();
                now_x++;
            }
            else
                f3=1;//没有写系数为1 
            ans+=f2*f3;//乘上系数 
            b1=false;
            continue;
        }
        if(s[now_x]=='~')//处理水 
        {
            now_x++;
            if((s[now_x]>='0')&&(s[now_x]<='9'))
                ans+=getmath()*18;
            else
                ans+=18;//没写系数的话就是1 
            break;//处理完水就直接跳出，后面不会有别的元素 
        }
    }
    return ;
}
int main()
{
    cin>>s;
    len=strlen(s);//化学式长度 
    now_x=0;//指向将要处理的数字 
    work();
    f4=ans;
    f5=f4;
    if(ans==f5)
        printf("%0.0f",ans);//判断输出整数还是一位小数 
    else
        printf("%0.1f",ans);
    return 0;
}
```

---

## 作者：Catreap (赞：7)

## **直接暴力扫一遍，哪来的蓝题。**
~~顶多黄题~~
我们逐个来分析

### 第一步：打表存相对原子质量
#### 你可以直接用$double$存，这里为了方便~~(使代码更好看)~~就用$map$容器。

```cpp
map<string,double> chem
```

```cpp
void init(void) {//打表顺序是为了让代码更工整
	chem["I"]=127;//实在处理不了 QwQ
	chem["H"]=1,chem["Ag"]=108,chem["Hg"]=201;
	chem["O"]=16,chem["Au"]=197,chem["Na"]=23;
	chem["K"]=39,chem["Ca"]=40,chem["Pt"]=195;
	chem["Mg"]=24,chem["Al"]=27,chem["Si"]=28;
	chem["P"]=31,chem["S"]=32,chem["Cl"]=35.5;
	chem["Fe"]=56,chem["Cu"]=64,chem["Zn"]=65;
	chem["Mn"]=55,chem["C"]=12,chem["Ba"]=137;
	chem["Hf"]=178.5,chem["N"]=14,chem["F"]=19;
}//终于敲完了，记得检查一遍
```

### 第二步：判断字符串中每个字符类型
```cpp
//十进制数字
bool IfDNum(char ch) {
    return (ch<='9' && ch>='0');
}

//大写字母
bool IfBLet(char ch) {
    return (ch<='Z' && ch>='A');
}

//小写字母
bool IfSLet(char ch) {
    return (ch<='z' && ch>='a');
}

//获取字符串某位开始的数值
int getnum(int id) {
	int x=0;
	for(int i=id; IfDNum(s[i]); i++) x=x*10+s[i]-'0';
	return x;
}
```

### 第三步：判断字符串中的元素
#### 很简单，直接判断元素就可以了。
```cpp
double find(char ch1, char ch2='0');
//参数如果是一个字符，就是ch1。'0'只是用来判断一个还是两个参数
```

```cpp
double find(char ch1, char ch2='0') {
	//ch2=='0'一个参数，查找仅为一个字母的化学元素
    if(ch1=='I' && ch2=='0') return chem["I"];
    if(ch1=='K' && ch2=='0') return chem["K"];
    if(ch1=='S' && ch2=='0') return chem["S"];
    if(ch1=='P' && ch2=='0') return chem["P"];
    if(ch1=='H' && ch2=='0') return chem["H"];
    if(ch1=='C' && ch2=='0') return chem["C"];
    if(ch1=='N' && ch2=='0') return chem["N"];
    if(ch1=='O' && ch2=='0') return chem["O"];
    if(ch1=='F' && ch2=='0') return chem["F"];
    
	//ch2!='0'两个参数，查找为两个字母的化学元素
    if(ch1=='N' && ch2!='a') return chem["Na"];
    if(ch1=='P' && ch2!='t') return chem["Pt"];
    if(ch1=='S' && ch2!='i') return chem["Si"];
    if(ch1=='M' && ch2=='g') return chem["Mg"];
    if(ch1=='A' && ch2=='l') return chem["Al"];
    if(ch1=='C' && ch2=='a') return chem["Ca"];
    if(ch1=='C' && ch2=='l') return chem["Cl"];
    if(ch1=='C' && ch2=='u') return chem["Cu"];
    if(ch1=='M' && ch2=='n') return chem["Mn"];
    if(ch1=='F' && ch2=='e') return chem["Fe"];
    if(ch1=='Z' && ch2=='n') return chem["Zn"];
    if(ch1=='A' && ch2=='g') return chem["Ag"];
    if(ch1=='B' && ch2=='a') return chem["Ba"];
    if(ch1=='H' && ch2=='f') return chem["Hf"];
    if(ch1=='A' && ch2=='u') return chem["Au"];
    if(ch1=='H' && ch2=='g') return chem["Hg"];
    return 0;//可以去掉
}
//函数返回值是元素的相对原子质量
```

### 第四步：求解。
#### 把字符串解析成多个化学式，并分别计算分子质量，最后相加或相乘。
解析成**多个**化学式
```cpp
if(IfBLet(s[i])) {//如果是大写字母，为元素开头
	//第二个字母非小写，则为一个字母的化学元素
	if(!IfSLet(s[i+1])) tmp=find(s[i]),sum+=tmp;
    否则为两个字母的化学元素
	else tmp=find(s[i],s[i+1]),sum+=tmp,i++;//正在读取i+1
	continue;//跳过其他判断
}
```

如果有**括号**在括号**内部**解析化学式
```cpp
if(s[i]=='(') {//检测到左括号
	int ll=i+1,rr=0;
	for(int j=i+1; j<=len; j++){
		if(s[j]==')') {//右括号结束
			rr=j-1;
			break;
		}
	}
	tmp=solve(ll, rr);//再次解析
	sum+=tmp;//加和
	i=rr+1;//正在读取的i加到化学式后
	continue;//跳过其他判断
}
```

乘上原子**数目**
```cpp
if(s[i]=='_') {//检测到数字
	int k=getnum(i+2);//获取字符串i+2位数值
	for(int j=i+1; j<=len; j++) {
		if(s[j]=='}') {//右括号结束
			i=j;
			break;
		}
	}
	tmp*=k-1;//乘上数值，因为之前算过一遍，所以要-1
	sum+=tmp;//加和
}
```
求解函数**完整**代码：
```cpp
double solve(int l,int r) {
	double sum=0,tmp=0;
	for(int i=l; i <= r; i++) {
		if(IfBLet(s[i])) {
			if(!IfSLet(s[i+1])) tmp=find(s[i]),sum+=tmp ;
			else tmp=find(s[i],s[i+1]),sum+=tmp,i++;
			continue;
		}
		if(s[i]=='(') {
			int ll=i+1,rr=0;
			for(int j=i+1; j<=len; j++){
				if(s[j]==')') {
					rr=j-1;
					break;
				}
			}
			tmp=solve(ll, rr);
			sum+=tmp;
			i=rr+1;
			continue;
		}
		if(s[i]=='_') {
			int k=getnum(i+2);
			for(int j=i+1; j<=len; j++) {
				if(s[j]=='}') {
					i=j;
					break;
				}
			}
			tmp*=k-1;
			sum+=tmp;
		}
	}
	return sum;//返回化学式相对分子质量
}
```
### 第五步：main函数。
#### ~(.)在$main$函数中直接判断，最后**相加**

算相对分子质量 **如题**

>zcy 教你算相对分子质量

1. 每个元素以大写开头；
2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；
3. ~( . ) 相当于加；
4. 下标相当于乘。

$main()$
```cpp
init(),read(s+1);//初始化+读入字符串
len=strlen(s+1);//获取长度
double sum=0;
for(int i=1; i<=len; i++) {
	int l=i,r=0,k=1;
	for(int j=i+1; j<=len; j++) {
		if(s[j]=='~') {
			r=j-1;//切开化学式
			break;
		}
	}

	if(IfDNum(s[i])) {//得到分子数目
		k=getnum(i);
	}
	while(IfDNum(s[i])) i++;
	if(!r) r=len;
	sum+=solve(l, r)*k, i=r+1;//分子质量*分子数
    //正在读取的i加到化学式后
}
return (int)sum==sum?printf("%d\n",(int)sum)&0:printf("%.1f\n",sum)&0;//恐怕只有我一个人这样写了，自己体会。
//整数要去0
```


最后附上~~高清无码~~代码(不要吐槽，我个人比较喜欢$fread$)
## Code:
```cpp
#include <map>
#include <cstdio>
#include <cstring>
#include <iostream>

namespace READ {
#define SIZE 100000
#define ll long long
    //fread->read
    bool Error=0;
    inline char nc() {
#ifdef WIN32
        return getchar();
#endif
        static char buf[SIZE],*p1=buf+SIZE,*pend=buf+SIZE;
        if (p1==pend) {
            p1=buf;
            pend=buf+fread(buf,1,SIZE,stdin);
            if (pend==p1) {
                Error=1;
                return -1;
            }
        }
        return *p1++;
    }
    inline bool blank(char ch) {
        return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';
    }
    inline void read(char *s) {
        char ch=nc();
        for (; blank(ch); ch=nc());
        if (Error)return;
        for (; !blank(ch)&&!Error; ch=nc())*s++=ch;
        *s=0;
    }
#undef ll
#undef SIZE
};

using namespace READ;
using namespace std;

int len;
char s[205];
map<string,double> chem;

bool IfDNum(char ch) {
	return (ch<='9' && ch>='0');
}

bool IfBLet(char ch) {
	return (ch<='Z' && ch>='A');
}

bool IfSLet(char ch) {
	return (ch<='z' && ch>='a');
}

int getnum(int id) {
	int x=0;
	for(int i=id; IfDNum(s[i]); i++) x=x*10+s[i]-'0';
	return x;
}

void init(void) {
	chem["I"]=127;
	chem["H"]=1,chem["Ag"]=108,chem["Hg"]=201;
	chem["O"]=16,chem["Au"]=197,chem["Na"]=23;
	chem["K"]=39,chem["Ca"]=40,chem["Pt"]=195;
	chem["Mg"]=24,chem["Al"]=27,chem["Si"]=28;
	chem["P"]=31,chem["S"]=32,chem["Cl"]=35.5;
	chem["Fe"]=56,chem["Cu"]=64,chem["Zn"]=65;
	chem["Mn"]=55,chem["C"]=12,chem["Ba"]=137;
	chem["Hf"]=178.5,chem["N"]=14,chem["F"]=19;
}

double find(char ch1, char ch2='0') {
	if(ch1=='I' && ch2=='0') return chem["I"];
	if(ch1=='K' && ch2=='0') return chem["K"];
	if(ch1=='S' && ch2=='0') return chem["S"];
	if(ch1=='P' && ch2=='0') return chem["P"];
	if(ch1=='H' && ch2=='0') return chem["H"];
	if(ch1=='C' && ch2=='0') return chem["C"];
	if(ch1=='N' && ch2=='0') return chem["N"];
	if(ch1=='O' && ch2=='0') return chem["O"];
	if(ch1=='F' && ch2=='0') return chem["F"];

	if(ch1=='N' && ch2!='0') return chem["Na"];
	if(ch1=='P' && ch2!='0') return chem["Pt"];
	if(ch1=='S' && ch2!='0') return chem["Si"];

	if(ch1=='M' && ch2=='g') return chem["Mg"];
	if(ch1=='A' && ch2=='l') return chem["Al"];
	if(ch1=='C' && ch2=='a') return chem["Ca"];
	if(ch1=='C' && ch2=='l') return chem["Cl"];
	if(ch1=='C' && ch2=='u') return chem["Cu"];
	if(ch1=='M' && ch2=='n') return chem["Mn"];
	if(ch1=='F' && ch2=='e') return chem["Fe"];
	if(ch1=='Z' && ch2=='n') return chem["Zn"];
	if(ch1=='A' && ch2=='g') return chem["Ag"];
	if(ch1=='B' && ch2=='a') return chem["Ba"];
	if(ch1=='H' && ch2=='f') return chem["Hf"];
	if(ch1=='A' && ch2=='u') return chem["Au"];
	if(ch1=='H' && ch2=='g') return chem["Hg"];
	return 0;
}

double solve(int l,int r) {
	double sum=0,tmp=0;
	for(int i=l; i <= r; i++) {
		if(IfBLet(s[i])) {
			if(!IfSLet(s[i+1])) tmp=find(s[i]),sum+=tmp;
			else tmp=find(s[i],s[i+1]),sum+=tmp,i++;
			continue;
		}
		if(s[i]=='(') {
			int ll=i+1,rr=0;
			for(int j=i+1; j<=len; j++){
				if(s[j]==')') {
					rr=j-1;
					break;
				}
			}
			tmp=solve(ll, rr);
			sum+=tmp;
			i=rr+1;
			continue;
		}
		if(s[i]=='_') {
			int k=getnum(i+2);
			for(int j=i+1; j<=len; j++) {
				if(s[j]=='}') {
					i=j;
					break;
				}
			}
			tmp*=k-1;
			sum+=tmp;
		}
	}
	return sum;
}
int main(int argc,char *argv[]) {
	init(),read(s+1);
	len=strlen(s+1);
	double sum=0;
	for(int i=1; i<=len; i++) {
		int l=i,r=0,k=1;
		for(int j=i+1; j<=len; j++) {
			if(s[j]=='~') {
				r=j-1;//cnt
				break;
			}
		}

		if(IfDNum(s[i])) {
			k=getnum(i);
		}
		while(IfDNum(s[i])) i++;

		if(!r) r=len;
		sum+=solve(l, r)*k, i=r+1;
	}
	return (int)sum==sum?printf("%d\n",(int)sum)&0:printf("%.1f\n",sum)&0;
}
```

---

## 作者：DWT8125 (赞：5)

## 【淼】+评价
这道题对本蒟蒻来说**比较特别**，因为这是本人$\color{green}\ {AC}$ 的**第一道绿题**！

这是一道比较有难度的模拟题，据各位题解区的大佬说，这道题**曾经是蓝题**？！

本题**细节较多**，接下来会一一详细说明。
## 题目大意
给出一个化学式，求给定物质的相对分子质量。

化学式格式大家应该都看过了，就不细讲了。[题目传送门](https://www.luogu.com.cn/problem/P4711)
## 普及点
本题使用```string```类型字符串，会用到以下几种字符串函数：

1. ```s.find(a,b)```：从字符串 $s$ 的第 $b$ 个字符起寻找字符串 $a$ ，找到则返回第一个找到的位置，否则返回 $-1$ 。其中 $b$ 可以省略。
1. ```s.substr(a,b)```：截取从 $s$ 字符串中的第 $a$ 个字符起的 $b$ 个字符。

## 思路
本人的思路：
```cpp
double read(string a){
	double s=0,t=0; //s存放总质量，t存放目前待处理的元素
```

### 1. 准备工作
先对着附表打两个表，一个存元素，一个存对应质量（要用```double```类型），下标对齐（也可以用结构体）：
```cpp
const string y[]={" ","H","C","N","O","F","Na","Mg","Al","Si","P","S","Cl","K","Ca","Mn","Fe","Cu","Zn","Ag","I","Ba","Hf","Pt","Au","Hg"};
const double no[]={0,1,12,14,16,19,23,24,27,28,31,32,35.5,39,40,55,56,64,65,108,127,137,178.5,195,197,201};
//打表（本人喜欢从下标1存起） 
```
接着写比较函数，```string```类型的好处来了：可以像数字一样直接比较！
```cpp
double fi(string a){
	for(int i=1;i<=25;i++)
		if(y[i]==a) //string的好处：可以直接比较 
			return no[i];  
	return -1;
} //寻找对应的分子质量 
```
### 2.处理字符串
$i$ 代表现在正在处理字符串 $a$ 中第几个字符，在循环里可以增减。
```
	for(int i=0;i<a.size();i++){
       //处理     
    }
```
字符串中的字符有几种要重点注意：

1. ```'('```：要截出括号内的内容，可以用```a.find()```和```a.substr()```嵌套：
```cpp
if(a[i]=='(') t=read(a.substr(i+1,a.find(')')-i)),i=a.find(')')+1; //这里把后面的')'也截了进去，对应下方的判断
	else if(a[i]==')') return s;
```
1. ```'_'```：遇到这个字符时不能直接加，后面还跟着元素数量，此时就可以用快读思想读入数量，再调用**待处理的元素质量** $t$ 乘上数量：
```cpp
	if(a[i]=='_'){
		double s2=0;
		for(i+=2;a[i]>='0'&&a[i]<='9';i++)
        //i+=2 跳过'_'和'{'
			s2=s2*10+(a[i]-'0');
		s+=t*s2;
	}
```
1. ```'~'```：字符串的结尾，后面跟数量和```H_{2}O```。既然```H_{2}O=18```，我们可以直接用 $s2 \times 18$ 即可，其中 $s2$ 是数量。

**重点**：水之前如果存在数字，保证一定是大于 2 的正整数，**如果省略该部分则默认为 1**。

```cpp
if(a[i]=='~'){
		double s2=0;
		if(a[i+1]=='H') return 18+s; //不加的话 #12 会错 
		for(i+=1;a[i]>='0'&&a[i]<='9';i++)
			s2=s2*10+(a[i]-'0');
		s+=s2*18; return s;
	}
```


## AC代码
为了您不被棕，请不要抄袭代码！
```cpp
//P4711 AC代码 
#include<bits/stdc++.h>
using namespace std; //万能开头 
const string y[]={" ","H","C","N","O","F","Na","Mg","Al","Si","P","S","Cl","K","Ca","Mn","Fe","Cu","Zn","Ag","I","Ba","Hf","Pt","Au","Hg"};
const double no[]={0,1,12,14,16,19,23,24,27,28,31,32,35.5,39,40,55,56,64,65,108,127,137,178.5,195,197,201};
//打表 
double fi(string a){
	for(int i=1;i<=25;i++)
		if(y[i]==a) //string的好处：可以直接比较 
			return no[i];  
	return -1;
} //寻找对应的分子质量 
double read(string a){ //核心 
	double s=0,t=0; //s存放总质量，t存放目前待处理的元素 
	for(int i=0;i<a.size();i++){
		if(a[i]>='A'&&a[i]<='Z'){ //找到一个元素 
			if(a[i+1]>='a'&&a[i+1]<='z'&&i<a.size()-1){ //判断元素长度+防越界操作 
				if(!(a[i-1]>='A'&&a[i-1]<='Z'||(a[i-1]>='a'&&a[i-1]<='z')||a[i-1]=='}')) s+=t;
				//杜绝重复计算！！ 
				t=fi(a.substr(i,2)); //截2个字符 
			}
			else{
				t=fi(a.substr(i,1)); //一个字符就够了 
				if(a[i+1]!='_') s+=t; 
			}
		}
		else if(a[i]>='a'&&a[i]<='z'&&a[i+1]!='_') s+=t;
		else if(a[i]=='(') t=read(a.substr(i+1,a.find(')')-i)),i=a.find(')')+1;
		//i变了，所以下方的 if(a[i]=='_') 不加else 
		else if(a[i]==')') return s;
		if(a[i]=='_'){
			double s2=0;
			for(i+=2;a[i]>='0'&&a[i]<='9';i++)
				s2=s2*10+(a[i]-'0');
			s+=t*s2;
		}
		else if(a[i]=='~'){
			double s2=0;
			if(a[i+1]=='H') return 18+s; //不加的话 #12 会错 
			for(i+=1;a[i]>='0'&&a[i]<='9';i++)
				s2=s2*10+(a[i]-'0');
			s+=s2*18; return s;
		}
	}
	return s; //千万别忘加了！ 
}
int main(){
	string a; cin>>a;
	cout<<read(a);
	return 0; //极短主代码，别忘了这行 
}
```
制作不易，求通过，求点赞！

---

## 作者：huangx607087 (赞：5)

## 第一次写题解，去年NOIP245分（差15分省一）有点蒟请原谅
##### 有一个学长要求我多打打高难度模拟，然后我花了2小时分析完成了
这道题实际上就是模拟。读取字符串进行原子质量的处理
然而要注意某些题目中讲到的特殊符号进行处理就行（代码中详细讲解）

~~switch case 语句实际上就是if，但这道题用if代码太多，令人看着凌乱~~
switch case只能用int char等整型数据，小数和条件表达式是不允许用的

```cpp

```cpp
#include <bits/stdc++.h>
using namespace std;
string B;//字符串
char A[99999];//先存到数组里
int num,F;//原子个数、字符串长度
double tot,ins,now;//总质量 原子团质量 现在的原子或者原子团质量
bool kh=false,stop=false,mark=false;
  //是否在括号内,是否需要停了,有没有结晶水
void pushinto()
{
    if(!num) num=1;//num如果没有统计 就设为1
    if(kh) ins+=num*now;//在括号内插入原子团
    else tot+=num*now;//否则插入总数
    num=0;//重置原子数量和现在原子质量
    now=0;
}
int main()
{
    int i=0,j;
    cin>>B;
    memset(A,'*',sizeof(A));//先把A标成其他类型的字符
    F=B.length();
    for(i=0;i<F;i++) A[i]=B[i];//第一次我直接读取的B[i],有时候程序会崩溃，所以我就把字符串B改为字符数组A
    i=0;//从第0位读取
    while((i<F)&&(!stop))//字符没有读完并且不需要手动停止
    {
        switch(A[i])//对字符数组一个个判断
        {
            case 'A':
            {
                pushinto();
                switch(A[i+1])
                {
                    case 'l':{now=27,i++;break;} 
                    case 'g':{now=108,i++;break;} 
                    case 'u':{now=197,i++;break;} 
                    default:break;
                }
                break;
            }
            case 'B':
            {
                pushinto();
                i++;
                now=137;
                break;
            }
            case 'C':
            {
                pushinto();
                switch(A[i+1])
                {
                    case 'l':{now=35.5;i++;break;} 
                    case 'a':{now=40;i++;break;} 
                    case 'u':{now=64;i++;break;} 
                    default: {now=12;break;} 
                }
                break;
            }
            case 'F':
            {
                pushinto();
                switch(A[i+1])
                {
                    case 'e':{now=56;i++;break;} 
                    default: {now=19;break;} 
                }
                break;
            }
            case 'H':
            {
                pushinto();
                switch(A[i+1])
                {
                    case 'f':{now=178.5;i++;break;} 
                    case 'g':{now=201;i++;break;} 
                //	case 'u':now=64;i++;break;
                    default: {now=1;break;} 
                }
                break;
            }
            case 'I':
            {
                pushinto();
                now=127;break;
            }
            case 'K':
            {
                pushinto();
                now=39;break;
            }
            case 'M':
            {
                pushinto();
                switch(A[i+1])
                {
                    case 'g':{now=24;i++;break;} 
                    case 'n':{now=55;i++;break;} 
                    default: break;
                }
                break;
            }
            case 'N':
            {
                pushinto();
                switch(A[i+1])
                {
                    case 'a':{now=23;i++;break;} 
                    default: {now=14;break;} 
                }
                break;
            }
            case 'O':
            {
                pushinto();now=16;
                break;
            } 
            case 'P':
            {
                pushinto();
                switch(A[i+1])
                {
                    case 't':{now=195;i++;break;} 
                    default: {now=31;break;} 
                }
                break;
            }
            case 'S':
            {
                pushinto();
                switch(A[i+1])
                {
                    case 'i':{now=28;i++;break;} 
                    default: {now=32;break;} 
                }
                break;
            }
            case 'Z':{pushinto();now=65;i++;break;} 
  //----本线之上均为读取元素
  //注意，读到新元素的时候一定要进行pushinto处理
            case '_':{i++;break;} 
  //读到下划线就加速一次,直接读取数字
            case '{':break;//防止BUG
            case '}':{pushinto();break;}
 //读取完原子(团)下标,就存入原子团数字或者
            case '(':{pushinto();kh=1;break;}
            case ')': {kh=0;now+=ins*max(num,1);ins=0;break;}
  //处理两边括号
            case 48:case 49:case 50:case 51:case 52:case 53:
            case 54:case 55:case 56:case 57:
            {
                num=num*10+A[i]-48;
                break;
            } 
  //这实际上是处理数字0~9(准确的说是处理字符//串'0'~'9')
            case '~':{
                pushinto();mark=1;stop=1;
                break;
            }
  //有结晶水的话，对上一个元素进行处理。标记结晶水存在，退出读取字符
            default:{stop=1;break;}
  //防止错误的字符读入
        }
        i++;//读取下一位
    }
    pushinto();
	if(mark) now=18; //有结晶水的话直接标记成原子质量18,然后继续读取字符
    while(mark&&A[i]>=48&&A[i]<=57)//如果这一位是数字,那就读取数字处理,否则直接pushinto(不要忘记now=0时pushinto直接把now看做1，因为原子没有系数)
    {
        num=num*10+A[i]-48;
        i++;
    }
    pushinto();//最后无论如何再pushinto一下，防止最后的原子没有插入总量
    cout<<tot;
    return 0;
}
```

```



## 如果题解有不足之处，请各位大佬私信指出，thanks


---

## 作者：tiger2005 (赞：5)

一道模拟

先看题

下面的表……

```
#include<cstdio>
#include<cstring>
using namespace std;
char ng[5];
double rr;
int main(){
    while(scanf("%s",ng)!=EOF){
        scanf("%lf",&rr);
        printf("\tss.clear();\n");
        printf("\tss=\"%s\";\n",ng);
        printf("\txd[ss]=%g;\n",rr);
        memset(ng,0,sizeof(ng));
    }
}
```

先打表吧！

这里的xd是map<string,double>,ss为一个string

ng
```
	ss.clear();
	ss="H";
	xd[ss]=1;
	ss.clear();
	ss="C";
	xd[ss]=12;
	ss.clear();
	ss="N";
	xd[ss]=14;
	ss.clear();
	ss="O";
	xd[ss]=16;
	ss.clear();
	ss="F";
	xd[ss]=19;
	ss.clear();
	ss="Na";
	xd[ss]=23;
	ss.clear();
	ss="Mg";
	xd[ss]=24;
	ss.clear();
	ss="Al";
	xd[ss]=27;
	ss.clear();
	ss="Si";
	xd[ss]=28;
	ss.clear();
	ss="P";
	xd[ss]=31;
	ss.clear();
	ss="S";
	xd[ss]=32;
	ss.clear();
	ss="Cl";
	xd[ss]=35.5;
	ss.clear();
	ss="K";
	xd[ss]=39;
	ss.clear();
	ss="Ca";
	xd[ss]=40;
	ss.clear();
	ss="Mn";
	xd[ss]=55;
	ss.clear();
	ss="Fe";
	xd[ss]=56;
	ss.clear();
	ss="Cu";
	xd[ss]=64;
	ss.clear();
	ss="Zn";
	xd[ss]=65;
	ss.clear();
	ss="Ag";
	xd[ss]=108;
	ss.clear();
	ss="I";
	xd[ss]=127;
	ss.clear();
	ss="Ba";
	xd[ss]=137;
	ss.clear();
	ss="Hf";
	xd[ss]=178.5;
	ss.clear();
	ss="Pt";
	xd[ss]=195;
	ss.clear();
	ss="Au";
	xd[ss]=197;
	ss.clear();
	ss="Hg";
	xd[ss]=201;
```

之后分析

这个式子到底分成了什么呢？

极宏观：整个分子式，~切割分子式

宏观：单个分子式，由元素组成

微观：单个元素

也就是说，这个分子质量的计算是由这三层递进而成

这里用三个数表示三层
```
s,s1,s2
```

之后，我们看看

在单个分子式中可能会遇到前缀数字

此时我们需要特判

当其为表达式第一个字符时开始判断数字即可

那么就有一个很流畅的思路

```
碰到~时从第二层传输到第一层（单个分子式算完），并且判断前缀数字
碰到元素时先将第三层数据传到第二层（单个元素算完），后计算到第三层
碰到_时获取下标数字并与第三层相乘
碰到(时计算前后表达式的长度，将计算结果保存到第三层！
为什么呢？
因为这个表达式可能还有下标对应，也就是这个表达式是被当做一个元素的
```
好了，看代码
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#include<string>
#include<iostream>
#include<cstdlib>
using namespace std;
bool ib(char a){
    return a>='A' && a<='Z';
}
bool is(char a){
    return a>='a' && a<='z';
}
bool in(char a){
    return a>='0' && a<='9';
}
map<string , double> xd;
char ys[110];
string ss;
double run(int wh,int la){
	//左右端 
    int now=0,rr=0,bs=1;
    //now计算括号，rr计算下标,bs计算单个分子式的前缀数字 
    double s=0,s1=0,s2=0;
    //三层 
    bool ks=true;
    //是否为单个分子式的前缀数字 
    for(int i=wh;i<=la;){
    	if(in(ys[i]) && ks){
    		//开头数字 
    		printf("@ktsz\n");
    		bs=0;
    		//类似快读的方法计算 
    		while(in(ys[i]))	bs=bs*10+(int)(ys[i]-'0'),++i;
    	}
        else	if(ys[i]=='('){
        	//嵌套 
        	printf("@qt\n");
        	//now为左括号数量减右括号数量 
        	now=1;
        	int ii=i;
        	s1+=s2;
        	s2=0;
        	while(now){//当括号数量仍未匹配时 
        		++ii;
        		if(ys[ii]=='(')	++now;
        		if(ys[ii]==')')	--now;
        	}
        	s2=run(i+1,ii-1);//嵌套运算 
        	i=ii+1;
        	/*
			这里能先用O(n)算法匹配括号，我懒，所以…… 
			*/ 
        }
        if(ib(ys[i])){
        	//元素 
        	printf("@ys\n");
        	//先将上一个元素的值加回去 
            s1+=s2;
            s2=0;
            //获取元素名字+ 计算 
            ss.clear();
            ss+=ys[i];
            if(is(ys[++i]))  ss+=ys[i];
            /*
            这里很仁慈，没有给类似Uuo的三字符元素，若真要的话把if换成while再加特判（while能加else?） 
            */
            else	--i;
            s2=xd[ss];
        }
        else	if(ys[i]=='_'){
        	//下标 
        	printf("@xb\n");
            ++i;
            //计算 
            rr=0;
            while(in(ys[++i]))  rr=rr*10+(int)(ys[i]-'0');
            //乘进去 
            s2*=rr;
        }
        else	if(ys[i]=='~'){
        	//分割 
        	printf("@fg\n");
        	//计算好单个分子式了 
        	s1+=s2;
        	s+=s1*bs;
        	s1=0;s2=0;
        	//倍数初始化为1！！！ 
        	bs=1;
        	ks=true;
        	++i;
        	continue;
        }
        //在一次非分割（上边continue了）的字符中，若不是字母，就将开始标记设为false 
        ks=false;
        ++i;
    }
    //计算 
    s1+=s2;
    s+=s1*bs;
    //返回 
    printf("@--------bye,rt %g\n",s);
    return s;
}
int main(){
	//打表 
    ss.clear();
    ss="H";
    xd[ss]=1;
    ss.clear();
    ss="C";
    xd[ss]=12;
    ss.clear();
    ss="N";
    xd[ss]=14;
    ss.clear();
    ss="O";
    xd[ss]=16;
    ss.clear();
    ss="F";
    xd[ss]=19;
    ss.clear();
    ss="Na";
    xd[ss]=23;
    ss.clear();
    ss="Mg";
    xd[ss]=24;
    ss.clear();
    ss="Al";
    xd[ss]=27;
    ss.clear();
    ss="Si";
    xd[ss]=28;
    ss.clear();
    ss="P";
    xd[ss]=31;
    ss.clear();
    ss="S";
    xd[ss]=32;
    ss.clear();
    ss="Cl";
    xd[ss]=35.5;
    ss.clear();
    ss="K";
    xd[ss]=39;
    ss.clear();
    ss="Ca";
    xd[ss]=40;
    ss.clear();
    ss="Mn";
    xd[ss]=55;
    ss.clear();
    ss="Fe";
    xd[ss]=56;
    ss.clear();
    ss="Cu";
    xd[ss]=64;
    ss.clear();
    ss="Zn";
    xd[ss]=65;
    ss.clear();
    ss="Ag";
    xd[ss]=108;
    ss.clear();
    ss="I";
    xd[ss]=127;
    ss.clear();
    ss="Ba";
    xd[ss]=137;
    ss.clear();
    ss="Hf";
    xd[ss]=178.5;
    ss.clear();
    ss="Pt";
    xd[ss]=195;
    ss.clear();
    ss="Au";
    xd[ss]=197;
    ss.clear();
    ss="Hg";
    xd[ss]=201;
    //IO 
    scanf("%s",ys);
    printf("%g",run(0,strlen(ys)-1));
}
```
copy代码的都得WA!!!

---

## 作者：_HiKou_ (赞：4)

作为一个合格的蒟蒻，我只会一个一个字符判断 QAQ。

思路：

1. 输入字符串，把每个元素拆分出来，加上对应的分子质量。

2. 如果有倍数就乘起来再加到 ans 里。

3. 如果是原子团就先将括号里的所有元素求出后再乘倍数。

4. 水合物就先把倍数存起来，再把水合物用一个变量存起来，最后把水合物乘倍数再加到 ans 里。

注意：水合物如果前面没有数字就默认为 1。

CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	string s;
	double ans=0,nowc;//nowc 表示现在找到的元素
	double shui=0,shuim=0,sh=0;//数字，状态，倍数 
	double kuo=0,kuom=0,ku=0;//同上
	int zm=0;//表示元素长度
	cin>>s;//输入
	int i;
	for(i=0; i<s.length(); i++) {
		if(s[i]>='A'&&s[i]<='Z') {
        //如果是大写字母
			int ymy=0;//数字
         //漫长的打表
			if(s[i]=='A'&&s[i+1]=='l') {
				nowc=27;
				zm=2;
			}
			if(s[i]=='A'&&s[i+1]=='g') {
				nowc=108;
				zm=2;
			}
			if(s[i]=='A'&&s[i+1]=='u') {
				nowc=197;
				zm=2;
			}
			if(s[i]=='B'&&s[i+1]=='a') {
				nowc=137;
				zm=2;
			}
			if(s[i]=='C')	{
				nowc=12;
				zm=1;
			}
			if(s[i]=='C'&&s[i+1]=='a')	{
				nowc=40;
				zm=2;
			}
			if(s[i]=='C'&&s[i+1]=='l')	{
				nowc=35.5;
				zm=2;
			}
			if(s[i]=='C'&&s[i+1]=='u')	{
				nowc=64;
				zm=2;
			}
			if(s[i]=='F')	{
				nowc=19;
				zm=1;
			}
			if(s[i]=='F'&&s[i+1]=='e')	{
				nowc=56;
				zm=2;
			}
			if(s[i]=='H')	{
				nowc=1;
				zm=1;
			}
			if(s[i]=='H'&&s[i+1]=='f')	{
				nowc=178.5;
				zm=2;
			}
			if(s[i]=='H'&&s[i+1]=='g')	{
				nowc=201;
				zm=2;
			}
			if(s[i]=='I')	{
				nowc=127;
				zm=1;
			}
			if(s[i]=='K')	{
				nowc=39;
				zm=1;
			}
			if(s[i]=='M'&&s[i+1]=='g')	{
				nowc=24;
				zm=2;
			}
			if(s[i]=='M'&&s[i+1]=='n')	{
				nowc=55;
				zm=2;
			}
			if(s[i]=='N')	{
				nowc=14;
				zm=1;
			}
			if(s[i]=='N'&&s[i+1]=='a')	{
				nowc=23;
				zm=2;
			}
			if(s[i]=='O')	{
				nowc=16;
				zm=1;
			}
			if(s[i]=='P')	{
				nowc=31;
				zm=1;
			}
			if(s[i]=='P'&&s[i+1]=='t')	{
				nowc=195;
				zm=2;
			}
			if(s[i]=='S')	{
				nowc=32;
				zm=1;
			}
			if(s[i]=='S'&&s[i+1]=='i')	{
				nowc=28;
				zm=2;
			}
			if(s[i]=='Z'&&s[i+1]=='n')	{
				nowc=65;
				zm=2;
			}
			for(int j=i+zm+2; s[j]>='0'&&s[j]<='9'; j++)
				ymy=ymy*10+(s[j]-'0');//判断数量

			if(s[i+zm]=='_'&&!shuim&&!kuom)ans+=nowc*ymy;
			else if(s[i+zm]=='_'&&shuim)shui+=nowc*ymy;
			else if(shuim&&s[i+zm]=='_')shui+=nowc*ymy;
			else if(shuim)shui+=nowc;
			else if(kuom&&s[i+zm]=='_')kuo+=nowc*ymy;
			else if(kuom)kuo+=nowc;
			else ans+=nowc;
		} //判断要加到哪一类里
		
		else if(s[i]=='~') {//水合物
			shuim=1;
         //后面的元素全部加到水合物里最后统一乘
			for(int j=i+1; s[j]>='0'&&s[j]<='9'; j++)
				sh=sh*10+(s[j]-'0');//水合物的倍数
			if(sh==0)sh=1;//如果没有则默认为 1 
		} 
		
		else if(s[i]=='(')kuom=1;
        //左括号代表原子团出现，先存到特定变量里
		
		
		else if(s[i]==')') {
			for(int j=i+3; s[j]>='0'&&s[j]<='9'; j++)
				ku=ku*10+(s[j]-'0');//求倍数
				ans+=kuo*ku;//加到答案里
				kuom=0;
				ku=0;
		}
	}

ans+=shui*sh;//水合物乘起来加到 ans 
cout<<ans;
return 0;
}
```


---

## 作者：Limerick (赞：3)

为了跟上yg大神谜一样的步伐,本蒟蒻又回归了......

回归后便选择了这题,与新上的学科有关,顺便把元素表背了......

思路:与其边读边做,最后所有变量都混乱了,不如先把给的表达式转化为基本正常的化学式.
然后再按题意进行模拟就AC了.

Code:
```#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<ctime>
#include<map>
using namespace std;
int len,x,n,yg;//len是处理后的字符串长度,x为字符串数组下标,n的作用是处理系数,yg用于最后对结果输出是整数还是小数的判断
char c;//c为一开始要读入的字符
double ans,tot;//ans为答案,tot用于处理括号里的化学式,本题明确说明了没有括号嵌套的情况出现,否则就需要开一个tot数组了
string s,ts;//s为处理好的字符串,ts为当前正在处理的化学元素
bool flag=false;//flag为判断是否在括号中的bool型变量
map <string,double> Map;//万能的map
void start(){
    Map["H"]=1.0;
    Map["C"]=12.0;
    Map["N"]=14.0;
    Map["O"]=16.0;
    Map["F"]=19.0;
    Map["Na"]=23.0;
    Map["Mg"]=24.0;
    Map["Al"]=27.0;
    Map["Si"]=28.0;
    Map["P"]=31.0;
    Map["S"]=32.0;
    Map["Cl"]=35.5;
    Map["K"]=39.0;
    Map["Ca"]=40.0;
    Map["Mn"]=55.0;
    Map["Fe"]=56.0;
    Map["Cu"]=64.0;
    Map["Zn"]=65.0;
    Map["Ag"]=108.0;
    Map["I"]=127.0;
    Map["Ba"]=137.0;
    Map["Hf"]=178.5;
    Map["Pt"]=195.0;
    Map["Au"]=197.0;
    Map["Hg"]=201.0;
}//化学元素表,全部存进map里
int main(){
    start();
    while(~scanf("%c",&c)){//这是读入的一种小技巧,字符串单个字母读入专用
        if((c>='A'&&c<='Z')||(c>='a'&&c<='z')||c=='('||c==')'){//如果是字母,或是括号,无需处理,直接加入字符串
            s+=c;//string型可以直接把字符拼接到后面,后面的代码不再赘述
        }
        else if(c=='_'){//如果是'_'
            scanf("%c",&c);//读入无用的'{'
            scanf("%c",&c);//读入第一个字符
            while(c>='0'&&c<='9'){//如果第一个读入的是数字,那么持续读入数字
                s+=c;
                scanf("%c",&c);
            }//如果第一个读入的不是数字,则是无用的'}',对处理结果无影响
        }
        else if(c=='~'){//如果是'~'
            scanf("%c",&c);//读入第一个字符
            if(c=='H'){//如果读入的第一个是'H',则说明水合物系数为1
                s+='~';//字符串后加上'~',方便判断是水合物
                s+='1';//加上其系数1
                scanf("%c",&c);//读入无用的'_'
                scanf("%c",&c);//读入无用的'{'
                scanf("%c",&c);//读入无用的'2'
                scanf("%c",&c);//读入无用的'}'
                scanf("%c",&c);//读入无用的'O'
            }
            else{//如果读入的第一个不是'H',则说明水合物系数不为1
                s+='~';//字符串后加上'~',方便判断是水合物
                while(c>='0'&&c<='9'){//持续读入数字
                    s+=c;
                    scanf("%c",&c);
                }//在读入数字时已经读过无用的'H'
                scanf("%c",&c);//读入无用的'_'
                scanf("%c",&c);//读入无用的'{'
                scanf("%c",&c);//读入无用的'2'
                scanf("%c",&c);//读入无用的'}'
                scanf("%c",&c);//读入无用的'O'
            }
        }
    }
    len=s.size();//string类型的字符串长度用.size()
    while(x<len){//循环
        if(s[x]=='('){//如果是'('
            flag=true;//flag标记为真
        }
        if(flag){//如果flag为真,即已经处于括号中
            tot=0.0;//清零！！！
            x++;//下标++
            while(s[x]!=')'){//如果还没读到')',即依旧处在括号中
                if(s[x]>='A'&&s[x]<='Z'&&s[x+1]>='a'&&s[x+1]<='z'){//如果是两个字母的元素
                    ts="";//清空！！！
                    ts+=s[x],ts+=s[x+1];//加上这两个字母
                    x+=2;//下标+2
                    n=0;//清零！！！
                    if(s[x]>='0'&&s[x]<='9'){//将此元素系数处理出来
                        while(s[x]>='0'&&s[x]<='9'){
                            n=n*10+(s[x]-'0');
                            x++;
                        }
                    }
                    if(n>1){//如果系数大于1
                        tot+=Map[ts]*n;//tot加(元素相对原子质量乘上系数)
                    }
                    else{
                        tot+=Map[ts];//否则tot加元素相对原子质量
                    }
                }
                else if(s[x]>='A'&&s[x]<='Z'){//如果只是单个字母的元素
                    ts="";//清空！！！
                    ts+=s[x];//加上这一个字母
                    x++;//下标++
                    n=0;//清零！！！
                    if(s[x]>='0'&&s[x]<='9'){//将此元素系数处理出来
                        while(s[x]>='0'&&s[x]<='9'){
                            n=n*10+(s[x]-'0');
                            x++;
                        }
                    }
                    if(n>1){//如果系数大于1
                        tot+=Map[ts]*n;//tot加(元素相对原子质量乘上系数)
                    }
                    else{
                        tot+=Map[ts];//否则tot加元素相对原子质量
                    }
                }
                else if(s[x]=='~'){//如果是'~'
                    x++;//下标++
                    n=0;//清零！！！
                    if(s[x]>='0'&&s[x]<='9'){//将水合物系数处理出来
                        while(s[x]>='0'&&s[x]<='9'){
                            n=n*10+(s[x]-'0');
                            x++;
                        }
                    }
                    tot+=n*18.0;//注意,水的元素质量为H2O=(1×2+16)=18,直接用其乘上系数即可
                }
            }
            x++;//下标++
            n=0;//清零！！！
            if(s[x]>='0'&&s[x]<='9'){//将整个括号的系数处理出来
                while(s[x]>='0'&&s[x]<='9'){
                    n=n*10+(s[x]-'0');
                    x++;
                }
            }
            if(n>1){//如果系数大于1
                ans+=tot*n;//答案加上(tot乘上系数)
            }
            else{
                ans+=tot;//否则直接加上tot
            }
            flag=false;
        }//括号外的处理与括号内的一模一样,这里不再赘述
        else if(s[x]>='A'&&s[x]<='Z'&&s[x+1]>='a'&&s[x+1]<='z'){
            ts="";
            ts+=s[x],ts+=s[x+1];
            x+=2;
            n=0;
            if(s[x]>='0'&&s[x]<='9'){
                while(s[x]>='0'&&s[x]<='9'){
                    n=n*10+(s[x]-'0');
                    x++;
                }
            }
            if(n>1){
                ans+=Map[ts]*n;
            }
            else{
                ans+=Map[ts];
            }
        }
        else if(s[x]>='A'&&s[x]<='Z'){
            ts="";
            ts+=s[x];
            x++;
            n=0;
            if(s[x]>='0'&&s[x]<='9'){
                while(s[x]>='0'&&s[x]<='9'){
                    n=n*10+(s[x]-'0');
                    x++;
                }
            }
            if(n>1){
                ans+=Map[ts]*n;
            }
            else{
                ans+=Map[ts];
            }
        }
        else if(s[x]=='~'){
            x++;
            n=0;
            if(s[x]>='0'&&s[x]<='9'){

                while(s[x]>='0'&&s[x]<='9'){
                    n=n*10+(s[x]-'0');
                    x++;
                }
            }
            ans+=n*18.0;
        }
    }
    yg=(int)ans;
    if(ans==(double)yg){
        printf("%d",yg);
    }
    else{
        printf("%.1f",ans);
    }//最后由于ans定义的是double型,所以需要判断答案是否为整数,若为整数,则输出其整数形式,否则输出其小数形式
    return 0;
}```


---

## 作者：引领天下 (赞：2)

恩这题其实并没有那么难，根本没有必要搞什么单调栈什么的，所以我来一发很短的题解。

本题的思路就是逐个击破，我的思路是这样的：

# 1.元素

对于单个元素的处理应该是很简单的，因为我们有强大的map，一个表就结束了。

# 2.下标

这里我主要分两种情况看：

- 对原子的下标

只需要保存每个元素的值（last），如果发现下标就把已经加到ans里的last减掉，重新加上last×下标系数就可以了。

- 对原子团的下标

这个等会会在原子团的部分里解释

# 3.原子团

这个对于原子团中可能出现的**嵌套**问题，我选择了递归解决

原子团中的原子跟原子团外的原子是一个解决方法（原子+下标）

然后接下来就是**原子团的下标**了

这个问题需要我们对原子团中的运算结果进行一个tmp的保存，然后在退出函数之前检查外面有没有下标，有的话立即解决。

# 4.水合物

这个就很简单了，检测到~后直接计算系数，然后乘以18（H_{2}O的值）就可以了

具体的一些坑点会在代码里说

```cpp
#include <bits/stdc++.h>
using namespace std;
double ans,last;//小心别手残打成int了（因为有.5的存在）
string a;
map <string,double> mp;//一个map其实可以帮我们很多忙
inline void start(){mp["H"]=1;
mp["C"]=12;
mp["N"]=14;
mp["O"]=16;
mp["F"]=19;
mp["Na"]=23;
mp["Mg"]=24;
mp["Al"]=27;
mp["Si"]=28;
mp["P"]=31;
mp["S"]=32;
mp["Cl"]=35.5;
mp["K"]=39;
mp["Ca"]=40;
mp["Mn"]=55;
mp["Fe"]=56;
mp["Cu"]=64;
mp["Zn"]=65;
mp["Ag"]=108;
mp["I"]=127;
mp["Ba"]=137;
mp["Hf"]=178.5;
mp["Pt"]=195;
mp["Au"]=197;
mp["Hg"]=201;}//打表
int ys(int k){
	string s="";int j=k+1;s+=a[k];
	for (;a[j]>='a'&&a[j]<='z';j++)s+=a[j];
	ans+=last=mp[s];//存下上一个值，为下标作准备
	return j;
}//对单个元素处理：用string提取单个元素，然后直接拿mp映射表搞
int xb(int k){
	int j=k+2,s=0;
	for (;a[j]>='0'&&a[j]<='9';j++)s=s*10+a[j]-'0';
	ans-=last,ans+=last*s;
	return j;
}//外部下标
double tmp,tlast;//tmp为括号里的运算结果，tlast为括号里的上一个值
int xbk(int k){
	int j=k+2,s=0;
	for (;a[j]>='0'&&a[j]<='9';j++)s=s*10+a[j]-'0';
	tmp-=tlast,tmp+=tlast*s;
	return j;
}//括号里的下标
int ysk(int k){
	string s="";int j=k+1;s+=a[k];
	for (;a[j]>='a'&&a[j]<='z';j++)s+=a[j];
	tmp+=tlast=mp[s];
	return j;
}//括号里的元素
inline int kh(int k){
	int j=k+1,h=1;//h表示当前未匹配的左括号数
	while (h!=0){
		if (a[j]==')')h--;//匹配到一个
		if (!h)break;
		if (a[j]>='A'&&a[j]<='Z'){
			j=ysk(j);
			if (a[j]=='_')j=xbk(j)+1;
		}else if (a[j]=='(')h++,j=kh(j);//又出来一个，递归
	}
	if (a[j+1]=='_')ans+=tmp,last=tmp,j=xb(j+1);//原子团的下标
	tmp=0;//记得归0
	return j;
}//括号
void sh(int k){
	int j=k+1,f=0;
	for (;a[j]>='0'&&a[j]<='9';j++)f=f*10+a[j]-'0';
	if (!f)f++;//注意！！！如果f没提取到说明省略了系数，千万别忘了默认为1！
	ans+=f*18;
}//水合物
int main(){
    start();
	cin>>a;
	for (int i=0;i<a.size();i++){
		if (a[i]>='A'&&a[i]<='Z')i=ys(i)-1;
		else if (a[i]=='_')i=xb(i);
		else if (a[i]=='(')i=kh(i);
		else if (a[i]=='~'){sh(i);break;}
	}
	printf ("%g",ans);//%g的输出可以省掉多余的0
	return 0;
}

```

---

## 作者：ToBiChi (赞：2)

~~作为小蒟蒻的我大概只能切一切A题B题了~~

以下是正文：
	题意简述：
    
    给你输入一个化学式，求出相对分子质量，保证化学式中没有空格。

## 题解 ：
首先我们需要把题里的相对原子质量打一个表，用pair啊，用map啊，
或者像我一样用if..相信各位大佬会有更高级的操作；
    
然后考虑解题，我们发现对于每个~也就是加号， 
可以分成两部分解题，就是加号前的和加号后的， 分别递归一次解决即可。
    对于水化物前的系数，可以通过一次类似于读入优化的方式来存下来，
    我们把每个括号跳过，括号内的递归解决。对于大括号内的系数，可以用一个lst 存一下上次算得的原子团/原子的质量，下次加它的系数-1倍即可。对于每个原子， 我们判断一下后面的字母是否是小写字母， 是的话传两个字符判断， 否则传一个。对于每个原子团， 我们递归解决，这个递归最多不会超过两层，其实我的代码相当于在主函数展开了一次递归，精简代码的话可以都压进一个函数里， 另外我的特判好Low啊QwQ. 

分析时间复杂度的话， 是$O(n)$的， 因为每次递归都把此段跳过了， 空间复杂度几乎可以忽略不计， 系统栈最多调用3层， 数组只需要开一个100的char和打表的double

***下面是代码***
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <iostream>
#include <cctype>
using namespace std;
char s[200];
double H = 1, C = 12, N = 14, O = 16, F = 19, Na = 23, Mg = 24, Al = 27, Si = 28, P = 31, S = 32, Cl = 35.5, K = 39, Ca = 40, Mn = 55, Fe = 56, Cu = 64, Zn = 65, Ag = 108, I = 127, Ba = 137, Hf = 178.5, Pt = 195, Au = 197, Hg = 201;
int n;
double find(char ch) {
    if(ch=='I') return I;
    if(ch=='K') return K;
    if(ch=='S') return S;
    if(ch=='P') return P;
    if(ch=='H') return H;
    if(ch=='C') return C;
    if(ch=='N') return N;
    if(ch=='O') return O;
    if(ch=='F') return F;
    return 0;
}
double find(char ch1, char ch2) {
    if(ch1=='N') return Na;
    if(ch1=='P') return Pt;
    if(ch1=='S') return Si;
    if(ch1=='M' && ch2=='g') return Mg;
    if(ch1=='A' && ch2=='l') return Al;
    if(ch1=='C' && ch2=='a') return Ca;
    if(ch1=='C' && ch2=='l') return Cl;
    if(ch1=='C' && ch2=='u') return Cu;
    if(ch1=='M' && ch2=='n') return Mn;
    if(ch1=='F' && ch2=='e') return Fe;
    if(ch1=='Z' && ch2=='n') return Zn;
    if(ch1=='A' && ch2=='g') return Ag;
    if(ch1=='B' && ch2=='a') return Ba;
    if(ch1=='H' && ch2=='f') return Hf;
    if(ch1=='A' && ch2=='u') return Au;
    if(ch1=='H' && ch2=='g') return Hg;
    return 0;
}
int gett(int idx) {
    int x = 0;
    for(int i = idx ; isdigit(s[i]) ; i ++ ) x = x*10+s[i]-'0';
    return x;
}
double calc(int l,int r) {
    double now = 0, lst;
    for(int i = l; i <= r; i++) {
        if(s[i]>='A'&&s[i]<='Z') {
            if(s[i+1]<'a'||s[i+1]>'z') {
                lst = find(s[i]);
                now += lst ;
            }
            else {
                lst = find(s[i], s[i+1]);
                now += lst ;
                i ++;
            }
            continue;
        }
        if(s[i]=='(') {
            int ll = i+1, rr= 0;
            for(int j=i+1;j<=n;j++)
                if(s[j]==')') {rr = j - 1;break;}
            lst = calc(ll, rr);
            now+=lst;
            i = rr+1;
        }
        else if(s[i]=='_') {
            int k = gett(i+2);
            for(int j = i+1; j<=n;j++) {
                if(s[j]=='}') {i = j;break;}
            }
            lst *= k-1;
            now += lst ;
        }
    }
    return now;
}
int main() {
    scanf("%s", s+1);
    n = strlen(s+1);
    double sum = 0;
    for(int i=1;i<=n;i++) {
        int l = i, r = 0, k = 1;
        for(int j = i+1; j<=n; j++) if(s[j]=='~') {r = j-1;break;}
        if(isdigit(s[i])) k = gett(i);
        while(isdigit(s[i]))i++;
        if(!r) r = n-1; 
        sum+= calc(l, r)*k, i = r+1;
    }
    printf("%.1f\n",sum);
}
```
欢迎来我的博客看看 ： [博客链接](https://www.cnblogs.com/tobichi)

---

## 作者：名字好难取144 (赞：1)

本蒟蒻写的第一道大模拟题（~~我们机房某巨佬说是中模拟~~）

我：~~“ A了这道题，妈妈再也不同担心我算不对相对分子质量啦~ ”~~

## 思路
做这种模拟题时，需要一个明确的思路。

我们在开始之前，先来研究一下这些化学式。

这些化学式，由小括号，大括号，下划线，数字，化学元素组成。

看到这些，是不是觉得无从下手？是不是尝试去实现了但是实现不了？

别着急，慢慢来。

我们先讨论单个的元素。eg：$ Ag $ , $ Cu $

对于单个的元素，我们只需要预先将这些元素与他们的相对原子质量存好，用的时候调出来就可以了。对于这个，我们可以用一个map实现（~~STL大法好~~）。

更具体的，map应该这样定义：`map<string,double>` （具体的待会可以看看代码）

好，单个元素讲完了，现在我们来讨论没有原子团且有一个元素有下标的化学物质。 eg：$ CO_2 $，$ Na_2SO_4 $

首先，我们需要一个 $ i $  游标来确定现在正在读的字符位置， $last$ 来记录上一个元素的相对原子质量。

接下来，如果检测到元素，并且该元素的下一位不是下划线，答案加上该元素的相对原子质量。否则启动 $ last $ 记录当前读入元素的相对原子质量。

有下标的化学元素解决啦，下面开始讨论带有原子团的化学式。

哎，带有小括号的喔，怎么玩啊？（~~之前就是在这里卡了半天~~）

别慌，我们来试着把整个化学式括起来。

这个时候我们可以~~很容易的~~发现，对于带括号的，我们只需要单独解决括号里面的内容就行了。怎么解决？当然是递归啦~。因为括号里面的内容都还是原子团或者化学式。

最后剩下的是带水的化学式，我们单独处理它。首先读入的时候寻找水分子连接符 “~” ，再将它后面的数字读入就可以了，如果没有数字，默认为 1 。

**友情提示：建议除了游标使用整型变量，其他的运算都要用 double 类型。**

## 代码
接下来是大家最喜欢的代码~



```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
#include<queue>
#include<map>
#define ll long long
using namespace std;

map<string,double> app;

double ans;

string elememts[26]={"H","C","N","O","F","Na","Mg","Al","Si","P","S","Cl","K","Ca","Mn","Fe","Cu","Zn","Ag","I","Ba","Hf","Pt","Au","Hg"};
string s;

void init_elements()
{
	for(int i=0;i<25;++i)  //这样有点小麻烦了
	{
		if(i==0) app[elememts[i]]=1;
		if(i==1) app[elememts[i]]=12;
		if(i==2) app[elememts[i]]=14;
		if(i==3) app[elememts[i]]=16;
		if(i==4) app[elememts[i]]=19;
		if(i==5) app[elememts[i]]=23;
		if(i==6) app[elememts[i]]=24;
		if(i==7) app[elememts[i]]=27;
		if(i==8) app[elememts[i]]=28;
		if(i==9) app[elememts[i]]=31;
		if(i==10) app[elememts[i]]=32;
		if(i==11) app[elememts[i]]=35.5;
		if(i==12) app[elememts[i]]=39;
		if(i==13) app[elememts[i]]=40;
		if(i==14) app[elememts[i]]=55;
		if(i==15) app[elememts[i]]=56;
		if(i==16) app[elememts[i]]=64;
		if(i==17) app[elememts[i]]=65;
		if(i==18) app[elememts[i]]=108;
		if(i==19) app[elememts[i]]=127;
		if(i==20) app[elememts[i]]=137;
		if(i==21) app[elememts[i]]=178.5;
		if(i==22) app[elememts[i]]=195;
		if(i==23) app[elememts[i]]=197;
		if(i==24) app[elememts[i]]=201;
	}
}

double water(int l,int r)
{
	int i=l+1,num=0;
	while(s[i]>='0'&&s[i]<='9')
	{
		num=num*10+s[i]-'0';
		i++;
	}
	if(num==0) return 18;
	return num*18;
}

double answer(int l,int r)
{
	int i=l;
	double now=0,last=0;
	while(i<=r)
	{
		if(s[i]>='A'&&s[i]<='Z')
		{
			if(s[i+1]>='a'&&s[i+1]<='z') 
			{
				if(s[i+2]!='_')
				{
					string str;
					str+=s[i];
					str+=s[i+1];
					now+=app[str];
					i+=2;
				}
				else 
				{
					string str;
					str+=s[i];
					str+=s[i+1];
					now+=app[str];
					last=app[str];
					i+=2;
				}
			}
			else 
			{
				if(s[i+1]!='_')
				{
					string str;
					str=s[i];
					now+=app[str];
					i++;
				}
				else
				{
					string str;
					str=s[i];
					now+=app[str];
					last=app[str];
					i++;
				}	
			}
		}
		if(s[i]=='(')
		{
			int j;
			for(j=i+1;j<s.size();++j)
			{
				if(s[j]==')') break;
			}
			double t=answer(i+1,j-1);
			i=j+1;
			if(s[i]=='_') 
			{
				last=t;
			}
			now+=t;	
		}
		if(s[i]=='_')
		{
			if(last==0)
			{
				string str2;
				str2=s[i-1];
				i+=2; 
				int num=0;
				while(s[i]!='}')
				{
					num=num*10+s[i]-'0';
					i++;
				}
				now+=(num-1)*app[str2];	
			}
			else
			{
				int num=0;
				i+=2;
				//cout<<s[i]<<" ";
				while(s[i]!='}')
				{
					num=num*10+s[i]-'0';
					i++;
				}
				now+=(num-1)*last;
			}		
			i++;	
		}
		if(s[i]=='~') return now; 
	}
	return now;
}

int main()
{
	init_elements();  //化学元素初始化
	cin>>s;
	ans=answer(0,s.size()-1);  
	int t=s.find('~',0);
	if(t!=s.npos) ans+=water(t,s.size()-1);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：影子鱼llt (赞：1)

**复杂的模拟**

这道题我的思路就是把每个部分的分子量都算出来，再做和就行了，比较简单，就是容易出一些小Bug，~~（话说我这道题做了三个小时）~~

对于水合物直接算就好了，什么括号呀直接跳过就好了。

代码如下~~（其实可以不递归的）~~
```c
#include<stdio.h>
#include<string>
#include<string.h>
反对抄袭题解的！
using namespace std;
char a[100][100]={"H","C","N","O","F","Na","Mg","Al","Si","P","S","Cl","K","Ca","Mn","Fe","Cu","Zn","Ag","I","Ba","Hf","Pt","Au","Hg"};//打了两张表 
float b[100]={1,12,14,16,19,23,24,27,28,31,32,35.5,39,40,55,56,64,65,108,127,137,178.5,195,197,201};
char aa[110];
int lenx=0;
float calc(int &i,int d)	
{
	float ans=0;
	char tmp[100]={0};
	int temp=0;
	while(aa[i]!='\0')
	{
		if(aa[i]>='A'&&aa[i]<='Z'||aa[i]=='(')//处理新的元素 
		{
			for(int j=0;j<26;j++)
			{
				if(strcmp(tmp,a[j])==0) //查表 
				{
					if(temp==0) ans+=b[j];
					else ans+=temp*b[j];
					break;
				}
			}
			memset(tmp,0,sizeof(tmp));
			tmp[0]=aa[i]; //记录元素 
			temp=0;
		}
		if(aa[i]>='a'&&aa[i]<='z')//一个元素的后半段（一个元素最多2字节） 
		{
			tmp[1]=aa[i];
		}
		if(aa[i]>='0'&&aa[i]<='9')//处理数字 
		{
			temp=temp*10+(aa[i]-'0');
		}
		if(aa[i]=='(')//分子团 
		{
			ans+=calc(++i,1);
		}
		if(aa[i]==')'&&d==1)//分子团处理完
		{
			for(int j=0;j<26;j++)//处理最后的一个元素 
			{
				if(strcmp(tmp,a[j])==0) 
				{
					if(temp==0) ans+=b[j];
					else ans+=temp*b[j];
					break;
				}
			}
			if(aa[i+1]=='_')//分子团后还有系数 
			{
				temp=0;
				for( ;aa[i]!='}';i++)
				{
					if(aa[i]>='0'&&aa[i]<='9')//处理数字 
					{
						temp=temp*10+(aa[i]-'0');
					}
				}
				ans*=temp;
			}
			return ans;
		}
		if(aa[i]=='~')//水合物 
		{
			int j=i+1;
			int tmpp=0;
			while(1)//处理水合物的系数 
			{
				if(aa[j]=='H') break;
				tmpp=tmpp*10+aa[j]-'0';
				j++;
			}
			if(tmpp==0) ans+=18;//H2O分子量18 
			else        ans+=18*tmpp;
			lenx=j;
			i+=lenx+6;
		}	 
		i++;
	}
	for(int j=0;j<26;j++)//处理最后的一个元素 
	{
		if(strcmp(tmp,a[j])==0) 
		{
			if(temp==0) ans+=b[j];
			else ans+=temp*b[j];
			break;
		}
	}
	return ans;
}
int main()
{

	float ans=0;
	scanf("%s",aa);
	int i=0;
	ans=calc(i,0);
	if(ans-(int)ans>0)
	{
		if(ans-(int)ans>0.8) printf("%d",(int)ans+1);//处理int的问题（避免1.999999999） 
		else                 printf("%.1f",ans);//输出后带0.5的答案 
	}
	else                     printf("%d",(int)ans);//正好是整数 
	return 0;
}
```
第一次写题解，大家多多包涵

---

## 作者：旧时兰台 (赞：1)

这里是萌新的第一篇题解，~~简单易懂~~emmm，我的程序就是一个大模拟。。。模拟。。。拟。。。思路是将元素按字母分类，然后提前特判每一个元素！下面贴代码。

------------


    #include<iostream>
    #include<math.h>
    #include<stdio.h>
    #include<cstring>
    #include<string.h>

    using namespace std;

    double ans,a,z,sh=18;//水的相对分子质量是18！

    double H=1,C=12,N=14,O=16,F=19,Na=23,Mg=24,Al=27,Si=28,P=31,S=32,Cl=35.5,K=39,Ca=40,Mn=55,Fe=56,Cu=64,Zn=65,Ag=108,I=127,Ba=137,Hf=178.5,Pt=195,Au=197,Hg=201; //~~简单的~~赋值;

	char s[200];

	int t=0;  //代表还需跳多少次循环！

	bool b=0;  //标记是否在括号里面

	void hh (bool p, double x ){

        if (p==1) a+=x; //a是括号内的暂时计数器;
    
        if (p==0) ans+=x;//ans是总相对分子质量！
    
		return;    
	}

	int main(){

		cin>>s;
	    int l=strlen(s);//无脑读入
	    for ( int i=0;i<=l;i++ ){//针对每一个字符特判！    
		    if ( t>0 ){//跳过本回合！
		    	t--;
			    continue;
	    	}
		    if ( s[i]=='('){
		    b=1;//有括号时标记！
			a=0;
			continue;
		}
		if ( s[i]==')'){
			b=0;
			if ( s[i+1]=='_' ) {
					int m=i+3,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*a;
			        ans+=z;
			        continue;
				}
				else {
					z=a;
					ans+=z;
					a=0;
					t=0;
			    }
				continue;
			continue;
		}
		if ( s[i]=='~'){
			int m=i+1,num;//num是水分子的数量
            if (s[m]!='H'){
				num=s[m]-'0';
			    while (s[m+1]!='H'){
				    num=num*10+(s[m+1]-'0');
			    	m++;
			    }
				t=m-i+6;
			}
			else {
				num=1;
				t=6;
			}
			ans+=sh*num;
			continue;
		}
		if ( s[i]=='H'){
			if ( s[i+1]=='f' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Hf;
			        hh(b,z);
			        continue;
				}
				else {
					z=Hf;
					t=1;
				}
				hh(b,z);
				continue;
			} 
			if ( s[i+1]=='g' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Hg;
			        hh(b,z);
			        continue;
				}
				else {
					z=Hg;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*H;
			    hh(b,z);
			    continue;
			}
			else {
				z=H;
				t=0;
			}
			hh(b,z);
			continue;
		}
	    if ( s[i]=='C'){
			if ( s[i+1]=='l' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Cl;
			        hh(b,z);
			        continue;
				}
				else {
					z=Cl;
					t=1;
				}
				hh(b,z);
				continue;
			} 
			if ( s[i+1]=='u' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Cu;
			        hh(b,z);
			        continue;
				}
				else {
					z=Cu;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='a' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Ca;
			        hh(b,z);
			        continue;
				}
				else {
					z=Ca;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*C;
			    hh(b,z);
			    continue;
			}
			else {
				z=C;
				t=0;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='N'){
			if ( s[i+1]=='a' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Na;
			        hh(b,z);
			        continue;
				}
				else {
					z=Na;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*N;
			    hh(b,z);
			    continue;
			}
			else {
				z=N;
				t=0;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='F'){
			if ( s[i+1]=='e' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Fe;
			        hh(b,z);
			        continue;
				}
				else {
					z=Fe;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*F;
			    hh(b,z);
			    continue;
			}
			else {
				z=F;
				t=0;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='S'){
			if ( s[i+1]=='i' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Si;
			        hh(b,z);
			        continue;
				}
				else {
					z=Si;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*S;
			    hh(b,z);
			    continue;
			}
			else {
				z=S;
				t=0;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='P'){
			if ( s[i+1]=='t' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Pt;
			        hh(b,z);
			        continue;
				}
				else {
					z=Pt;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*P;
			    hh(b,z);
			    continue;
			}
			else {
				z=P;
				t=0;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='M'){
			if ( s[i+1]=='g' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Mg;
			        hh(b,z);
			        continue;
				}
				else {
					z=Mg;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='n' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Mn;
			        hh(b,z);
			        continue;
				}
				else {
					z=Mn;
					t=1;
				}
				hh(b,z);
				continue;
			}
		}
		if ( s[i]=='A'){
			if ( s[i+1]=='g' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Ag;
			        hh(b,z);
			        continue;
				}
				else {
					z=Ag;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='l' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Al;
			        hh(b,z);
			        continue;
				}
				else {
					z=Al;
					t=1;
				}
				hh(b,z);
				continue;
			}
			if ( s[i+1]=='u' ){
				if ( s[i+2]=='_' ) {
					int m=i+4,num=0;
			        num=s[m]-'0';
			        while (s[m+1]!='}'){
				        num=num*10+(s[m+1]-'0');
				        m++;
			        }
			        t=m-i+1;
			        z=num*Au;
			        hh(b,z);
			        continue;
				}
				else {
					z=Au;
					t=1;
				}
				hh(b,z);
				continue;
			}
		}
		if ( s[i]=='K'){
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*K;
			    hh(b,z);
			    continue;
			}
			else {
				z=K;
				t=0;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='O'){
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*O;
			    hh(b,z);
			    continue;
			}
			else {
				z=O;
				t=0;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='I'){
			if ( s[i+1]=='_' ) {
				int m=i+3,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*I;
			    hh(b,z);
			    continue;
			}
			else {
				z=I;
				t=0;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='Z'){
			if ( s[i+2]=='_' ) {
				int m=i+4,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*Zn;
			    hh(b,z);
			    continue;
			}
			else {
				z=Zn;
				t=1;
			}
			hh(b,z);
			continue;
		}
		if ( s[i]=='B'){
			if ( s[i+2]=='_' ) {
				int m=i+4,num=0;
			    num=s[m]-'0';
			    while (s[m+1]!='}'){
				    num=num*10+(s[m+1]-'0');
				    m++;
			    }
			    t=m-i+1;
			    z=num*Ba;
			    hh(b,z);
			    continue;
			}
			else {
				z=Ba;
				t=1;
			}
			hh(b,z);
			continue;
		}
	}	
	printf("%lf",ans);//完美输出！！！
	return 0;
    }

---

## 作者：Gu_Pigeon (赞：1)

## 萌新来水题解，神犇勿喷:)
emmm一道经典的暴力模拟的题目（作为懒癌患者本蒟蒻表示很头疼）然而作为唯(du)一(xiu)的P党……话不多说，上题解！
```pascal
var s,s1,s2:string;
    tot,m,mm:real;
    l,ll,r,rr,x:longint;
begin
  readln(s);//一个看似正常的读入
  while length(s)>0 do
  begin
    if ('A'<=s[1]) and (s[1]<='Z') then
    begin
      tot:=tot+m;
      if ('a'<=s[2]) and (s[2]<='z') then s1:=copy(s,1,2)
        else s1:=copy(s,1,1);//截取原子的化学式
      r:=length(s1);
      case s1 of
        'H':m:=1;
        'C':m:=12;
        'N':m:=14;
        'O':m:=16;
        'F':m:=19;
        'Na':m:=23;
        'Mg':m:=24;
        'Al':m:=27;
        'Si':m:=28;
        'P':m:=31;
        'S':m:=32;
        'Cl':m:=35.5;
        'K':m:=39;
        'Ca':m:=40;
        'Mn':m:=55;
        'Fe':m:=56;
        'Cu':m:=64;
        'Zn':m:=65;
        'Ag':m:=108;
        'I':m:=127;
        'Ba':m:=137;
        'Hf':m:=178.5;
        'Pt':m:=195;
        'Au':m:=197;
        'Hg':m:=201;
      end;
    end;//打表判断
    if s[1]='_' then
    begin
      l:=3;
      r:=pos('}',s);
      val(copy(s,l,r-l),x);
      m:=m*x;
    end;//another 情况
    if s[1]='(' then//又another情况，即化学式中的化学式，嵌套
    begin
      tot:=tot+m;
      m:=0;
      l:=2;
      r:=pos(')',s);
      s1:=copy(s,l,r-l);
      while length(s1)>0 do
      begin
        if ('A'<=s1[1]) and (s1[1]<='Z') then
        begin
          m:=m+mm;
          if ('a'<=s1[2]) and (s1[2]<='z') then s2:=copy(s1,1,2)
            else s2:=copy(s1,1,1);
          rr:=length(s2);
          case s2 of
            'H':mm:=1;
            'C':mm:=12;
            'N':mm:=14;
            'O':mm:=16;
            'F':mm:=19;
            'Na':mm:=23;
            'Mg':mm:=24;
            'Al':mm:=27;
            'Si':mm:=28;
            'P':mm:=31;
            'S':mm:=32;
            'Cl':mm:=35.5;
            'K':mm:=39;
            'Ca':mm:=40;
            'Mn':mm:=55;
            'Fe':mm:=56;
            'Cu':mm:=64;
            'Zn':mm:=65;
            'Ag':mm:=108;
            'I':mm:=127;
            'Ba':mm:=137;
            'Hf':mm:=178.5;
            'Pt':mm:=195;
            'Au':mm:=197;
            'Hg':mm:=201;
          end;
        end;
        if s1[1]='_' then
        begin
          ll:=3;
          rr:=pos('}',s1);
          val(copy(s1,ll,rr-ll),x);
          mm:=mm*x;
        end;
        delete(s1,1,rr);
      end;
      m:=m+mm;
    end;//判断整个括号内的相对分子质量
    if s[1]='~' then
    begin
      tot:=tot+m;
      if s[2]='H' then m:=18
      else
      begin
        val(copy(s,2,pos('H',s)-2),x);
        m:=18*x;//不用说了一定是H2O
      end;
      r:=length(s);
    end;
    delete(s,1,r);//判断完一部分删掉一部分
  end;
  tot:=tot+m;
  writeln(tot:0:1);//取小数点后一位
end.
```
大功告成！
总的来说就是将化学式分成一个个小部分（这个谁都知道—w—b）然后再一块一块地加起来——模拟是正解！
#### 个人认为括号的处理应该是最麻烦的，因为程序里还要再套一段程序（可能子程序会友好一点）
### 不过总而言之、言而总之不要被眼前的难度评价所迷惑——真的没那么难！！！

---

## 作者：01190220csl (赞：0)

这题有这么繁吗？
每次读入一个内容并判断：

（1）：‘~’，往后看，是数字就取出来乘以18；是‘H’就直接加上18；

（2）：‘(’，处理内部内容和外侧一样；

（3）：字母，取出这种元素；

（4）：数字，取出来就可以。

（5）：其它字符无需考虑。

其中遇到前三种情况时累加进答案，最后再把没加的加上。
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string, double> chem;
void init() {
	chem["H"] = 1;
	chem["C"] = 12;
	chem["N"] = 14;
	chem["O"] = 16;
	chem["F"] = 19;
	chem["Na"] = 23;
	chem["Mg"] = 24;
	chem["Al"] = 27;
	chem["Si"] = 28;
	chem["P"] = 31;
	chem["S"] = 32;
	chem["Cl"] = 35.5;
	chem["C"] = 12;
	chem["K"] = 39;
	chem["Ca"] = 40;
	chem["Mn"] = 55;
	chem["Fe"] = 56;
	chem["Cu"] = 64;
	chem["Zn"] = 65;
	chem["Ag"] = 108;
	chem["I"] = 127;
	chem["Ba"] = 137;
	chem["Hf"] = 178.5;
	chem["Pt"] = 195;
	chem["Au"] = 197;
	chem["Hg"] = 201;
}
string s;
double ans = 0;
int num = 1;
string ele;
double szele;
int into(int p0) {
	int p;
	for (p = p0; s[p] != ')'; p++) {
		if (s[p] >= 'A' && s[p] <= 'Z') {
			szele += chem[ele] * num;
			num = 1, ele.clear();
			ele.push_back(s[p]);
			if (s[p+1] >= 'a' && s[p+1] <= 'z')
				ele.push_back(s[++p]);
		}
		if (s[p] >= '0' && s[p] <= '9') {
			num = s[p] - '0';
			while (s[p+1] >= '0' && s[p+1] <= '9') num = num * 10 + s[++p] - '0';
		}
	}
	szele += chem[ele] * num;
	return p;
}
int main() {
	init();
	cin >> s;
	for (int p = 0; p < s.size(); p++) {
		if (s[p] == '~') {
			if (!szele) szele = chem[ele];
			ans += szele * num;
			szele = 0, num = 1, ele.clear();
			if (s[p+1] == 'H') {
				ans += 18;
				break;
			}
			num = 0;
			while (s[p+1] != 'H') num = num * 10 + s[++p] - '0';
			ans += num * 18;
			break;
		}
		if (s[p] == '(') {
			if (!szele) szele = chem[ele];
			ans += szele * num;
			szele = 0, num = 1, ele.clear();
			p = into(p + 1);
			continue;
		}
		if (s[p] >= 'A' && s[p] <= 'Z') {
			if (!szele) szele = chem[ele];
			ans += szele * num;
			szele = 0, num = 1, ele.clear();
			ele.push_back(s[p]);
			if (s[p+1] >= 'a' && s[p+1] <= 'z')
				ele.push_back(s[++p]);
		}
		if (s[p] >= '0' && s[p] <= '9') {
			num = s[p] - '0';
			while (s[p+1] >= '0' && s[p+1] <= '9') num = num * 10 + s[++p] - '0';
		}
	}
	if (!szele) szele = chem[ele];
	ans += szele * num; 
	cout << ans << endl;
	return 0;
}
```


---

## 作者：andyli (赞：0)

~~话说这题为什么是 `提高+省选-`~~
这题只要按照题目说的做就可以了（用递归会比较好）
代码如下：
```
#include <iostream>
#include <string>
#include <cctype>
#include <map>
using namespace std;

map<string, double> m;
void init()
{
    m["H"] = 1;
    m["C"] = 12;
    m["N"] = 14;
    m["O"] = 16;
    m["F"] = 19;
    m["Na"] = 23;
    m["Mg"] = 24;
    m["Al"] = 27;
    m["Si"] = 28;
    m["P"] = 31;
    m["S"] = 32;
    m["Cl"] = 35.5;
    m["K"] = 39;
    m["Ca"] = 40;
    m["Mn"] = 55;
    m["Fe"] = 56;
    m["Cu"] = 64;
    m["Zn"] = 65;
    m["Ag"] = 108;
    m["I"] = 127;
    m["Ba"] = 137;
    m["Hf"] = 178.5;
    m["Pt"] = 195;
    m["Au"] = 197;
    m["Hg"] = 201;
}

double f(string str)
{
    if (m.count(str))
        return m[str];
    size_t pos = str.find('~');
    if (pos != string::npos)
        return f(str.substr(0, pos)) + f(str.substr(pos + 1));
    if (isupper(str[0]))
    {
        int t = 1, flag = bool(islower(str[1])), ok = 0;
        if (str[flag + 1] == '_')
            t = stoi(str.substr(flag + 3, (pos = str.find('}')) - flag - 3)), ok = 1;
        return t * m[str.substr(0, flag + 1)] + f(str.substr(ok ? (pos + 1) : (flag + 1)));
    }
    int t = 0, i = 0;
    while (isdigit(str[i]))
        t = t * 10 + str[i++] - '0';
    if (t > 0)
        return t * f(str.substr(i));
    if (str[0] == '(')
    {
        int cnt = 1, len = str.length();
        for (i = 1; i < len; i++)
        {
            if (str[i] == '(')
                cnt++;
            else if (str[i] == ')')
                cnt--;
            if (cnt == 0)
                break;
        }
        t = 1;
        if(str[i + 1] == '_')
            t = stoi(str.substr(i + 3, (pos = str.find(i + 3, '}')) - i - 3)), cnt = 1;
        return t * f(str.substr(1, i - 1)) + f(str.substr(cnt ? (i + 1) : (pos + 1)));
    }
    return 0;
}

int main()
{
    init();
    string str;
    cin >> str;
    cout << f(str) << endl;
    return 0;
}
```
代码可能有点乱，但只要认真一看就会发现其实这题很简单。
大家有没有注意到代码中的`f`函数中，用到了一个函数`stoi`，这个函数是`C++11`新增的，可以把字符串变成整数。

---

## 作者：A4paper (赞：0)

一道纯模拟，不如让蒟蒻来一篇题解

非常的无脑，把所有元素用变量存一下

然后就可以用 m() 函数找出对应元素的质量

然后就无脑模拟就OK啦~

如果诸位大佬有更好的思路，欢迎评论！

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
using namespace std;

float H	= 1 ;
float C	= 12;
float N	= 14;
float O	= 16;
float F	= 19;
float Na= 23;
float Mg= 24;
float Al= 27;
float Si= 28;
float P	= 31;
float S	= 32;
float Cl= 35.5;
float K	= 39;
float Ca= 40;
float Mn= 55;
float Fe= 56;
float Cu= 64;
float Zn= 65;
float Ag= 108;
float I	= 127;
float Ba= 137;
float Hf= 178.5;
float Pt= 195;
float Au= 197;
float Hg= 201;
float HO= 18;
float ans   ;

string M;
int len,flag;

float m(int i)
{
    if(M[i] == 'H'){
        if(M[i+1] == 'f'){flag = 1;return Hf;}
        if(M[i+1] == 'g'){flag = 1;return Hg;}
        else					  {return H ;}
    } 
    if(M[i] == 'N'){
        if(M[i+1] == 'a'){flag = 1;return Na;}
        else					  {return N ;}
    }
    if(M[i] == 'A'){
        if(M[i+1] == 'l'){flag = 1;return Al;}
        if(M[i+1] == 'u'){flag = 1;return Au;}
        if(M[i+1] == 'g'){flag = 1;return Ag;}
    }
    if(M[i] == 'I')			  	  {return I ;}
    if(M[i] == 'O')			  	  {return O ;}
    if(M[i] == 'F'){
        if(M[i+1] == 'e'){flag = 1;return Fe;}
        else					  {return F ;}
    }
    if(M[i] == 'M'){
        if(M[i+1] == 'g'){flag = 1;return Mg;}
        if(M[i+1] == 'n'){flag = 1;return Mn;}
    }
    if(M[i] == 'S'){
        if(M[i+1] == 'i'){flag = 1;return Si;}
        else					  {return S ;}
    }
    if(M[i] == 'C'){
        if(M[i+1] == 'l'){flag = 1;return Cl;}
        if(M[i+1] == 'a'){flag = 1;return Ca;}
        if(M[i+1] == 'u'){flag = 1;return Cu;}
        else					  {return C ;}
    }
    if(M[i] == 'P'){
        if(M[i+1] == 't'){flag = 1;return Pt;}
        else					  {return P ;}
    }   
    if(M[i] == 'B')		 {flag = 1;return Ba;}
    if(M[i] == 'Z')		 {flag = 1;return Zn;}
    if(M[i] == 'K')		 		  {return K ;}
    return -1;
}

int main()
{
    cin >> M;
    len = M.size();
    for(int i=0;i<len;i++)
    {
        if(M[i] == '_'){
            int num = M[i+2]-48;
            if(m(i-1) == -1)ans += (num-1)*m(i-2);
            else			ans += (num-1)*m(i-1);
            flag = 0;
            i += 3;
        }
        else if(M[i] == '('){
            float _ans;	int num;
            while(M[++i] !=')'){
                if(M[i] == '_'){
                    int num = M[i+2]-48;
                    if(m(i-1) == -1)_ans += (num-1)*m(i-2);
                    else			_ans += (num-1)*m(i-1);
                    flag = 0;
                    i += 3;
                }
                else{
                    _ans += m(i);
                    if(flag == 1)	i++,flag=0;
                }
            }
            if(M[++i] == '_'){
                i+=2;
                int num = M[i]-48;
                while(1<M[++i]-48 && M[i]-48<=9){
                    num *= 10;
                    num += M[i]-48;
                }
                ans += _ans*(num);
            }
        }
        else if(M[i] == '~'){
            int num = 1;
            if(1<=M[++i]-48 && M[i]-48<=9){
                num = M[i]-48;
                while(1<=M[++i]-48 && M[i]-48<=9){
                    num *= 10;
                    num += M[i++]-48;
                }
            }
            ans += num*HO;
            i += 6;
        }
        else{
            ans += m(i);
            if(flag == 1)	i++,flag=0;
        }
    }
    cout << ans << endl;
    return 0;
}

```

---

## 作者：珅肐 (赞：0)

### 一道没怎么有技术含量的大模拟
#### 直接上代码：

```c
#include<map>//map大法好
#include<cstring>
#include<iostream>
using namespace std;
map<string,double> ma;
string s;
double ans,nans;//ans是最终答案,nans是当前部分临时的答案（比如括号内的一部分）
bool A(char c){return (c>='A' && c<='Z');}//判断是否为大写字母
bool a(char c){return (c>='a' && c<='z');}//判断是否为小写字母
int main()
{
	ma["H"]=1;ma["C"]=12;ma["N"]=14;ma["O"]=16;
	ma["F"]=19;ma["Na"]=23;ma["Mg"]=24;ma["Al"]=27;
	ma["Si"]=28;ma["P"]=31;ma["S"]=32;ma["Cl"]=35.5;
	ma["K"]=39;ma["Ca"]=40;ma["Mn"]=55;ma["Fe"]=56;
	ma["Cu"]=64;ma["Zn"]=65;ma["Ag"]=108;ma["I"]=127;
	ma["Ba"]=137;ma["Hf"]=178.5;ma["Pt"]=195;
	ma["Au"]=197;ma["Hg"]=201;
    //先预处理一下元素相对分子质量
	cin>>s;//读入字符串
	int l=s.length(),now=0;//l为字符串长度,now是当前的位置
	while(now<l){
		if(s[now]=='('){//如果读到左括号
			now++;//位置+1
			ans+=nans;//把临时答案加到ans里
			nans=0;//临时答案清零
			while(s[now]!=')'){//如果当前不是右括号
				while(A(s[now])){//如果是元素开头（大写字母）
					string ss="";//定义一个字符串
					ss+=s[now];
					while(a(s[++now])){//小写字母说明还是同一个元素
						ss+=s[now];//储存
					}
					if(s[now]=='_'){//'_'说明有系数
						nans+=(s[now+2]-'0')*ma[ss];
                    //往后数第二个是系数,乘起来加到临时变量里去
						now+=4;//位置后移
					}
					else nans+=ma[ss];//map映射,加入总答案
				} 
			}
		}
		else if(A(s[now]))//与上面相同,不解释
			while(A(s[now]))
			{
				string ss="";
				ss+=s[now];
				while(a(s[++now])){
					ss+=s[now];
				}
				if(s[now]=='_'){
					nans+=(s[now+2]-'0')*ma[ss];
					now+=4;
				}
				else nans+=ma[ss];
			} 
		else if(s[now]=='_'){
			ans+=(s[now+2]-'0')*nans;
			now+=4;nans=0;//注意这里因为不在括号内,多了一个清零
		}
		else if(s[now]=='~'){//如果是水合物
			ans+=nans;nans=0;//先把临时答案加上并清零
			if(s[++now]>='1' && s[now]<='9')//如果第一位是数字
				while(s[now]>='0' && s[now]<='9')
                	nans=nans*10+s[now++]-'0';//就计算系数
			else nans=1;//不是数字就默认为一
			ans+=nans*18;答案加上系数乘以水的相对分子质量18
			nans=0;//清空临时答案
			now+=6;//位置后移（其实也可以直接break）
		}
	}
	cout<<ans+nans;输出答案加上临时答案
	return 0;//好习惯
}
```
眼睁睁看着这道题被刷成提高+/省选-

其实没有那么难 , 稍微细心一点就能做对

---

## 作者：柒命九陨_ (赞：0)

大概是蒟蒻的第2篇题解了。

今天过来看居然成了蓝题…… 在我看来这道题除了要耐心一点没有算法难度啊……

不瞎扯，这道题就是扫一遍字符串，干脆上代码 + 注释吧。

基本思路：

1. 首先算出水合部分的质量，然后截掉那一部分再处理可以降低一点思考难度；

2. 分子部分每一部分都是 “部分_{数量}” ，所以判断这里的时候先扫到大括号，把系数存下来，再去扫化学式部分算质量，最后这部分的质量就是 系数 * 部分质量。

3. 至于分子部分外面有括号的话，其实里面 “元素_{ 数量 }” 的处理与2相似。

4. 接上面，因为每个化学式（元素）部分都会以大写字母开头，所以判断这个很方便。

5. map + string 大法。

(ps. 变量名是我昨晚百度的英文……~~吐槽毒瘤的我同意你的看法~~ 笑)

```cpp
#include <map>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

map<string, double> atom;

char Molecole[105];

inline void Set_Atom_mass() {	// 初始化map
	atom["H"] = 1, atom["He"] = 2;
	atom["C"] = 12, atom["N"] = 14, atom["O"] = 16, atom["F"] = 19;
	atom["Na"] = 23, atom["Mg"] = 24, atom["Al"] = 27, atom["Si"] = 28;
	atom["S"] = 32, atom["Cl"] = 35.5, atom["K"] = 39, atom["Ca"] = 40;
	atom["Mn"] = 55, atom["Fe"] = 56, atom["Cu"] = 64, atom["Zn"] = 65;
	atom["Ag"] = 108, atom["I"] = 127, atom["Ba"] = 137, atom["Hf"] = 178.5;
	atom["P"] = 31, atom["Pt"] = 195, atom["Au"] = 197, atom["Hg"] = 201;
}

inline bool Ishulet(char x) {	// 大写字母
	if( x >= 'A' && x <= 'Z' ) return true;
	else return false;
}
inline bool Ispilet(char x) {	// 小写字母
	if( x >= 'a' && x <= 'z' ) return true;
	else return false;
}

int main(int argc, char const *argv[])
{
	scanf("%s", Molecole), Set_Atom_mass();
	int len = strlen(Molecole);

	double Molecole_mass = 0;
	for(int i = 0; i < len; ++i)
		if( Molecole[i] == '~' ) {	// 扫到水合部分，先加到答案里然后截掉
			int t = i, Coefficient = 0;  len = i;
			while( isdigit( Molecole[++t] ) )	// 算系数
				Coefficient = (Coefficient * 10) + (Molecole[t] ^ 48);
			if( !Coefficient ) Molecole_mass = 18;
			else Molecole_mass = 18 * Coefficient;	// 水分子质量乘系数
		}

	for(int i = 0; i < len; ++i)
		if( Molecole[i] == '(' ) {		// 原子团
			int t = i, Coefficient = 0;
			double Atomic_mass = 0;
			while( Molecole[++t] != ')' );
			int p = t;
			if( Molecole[t+1] == '_' ) {	// 算系数
				while( !isdigit( Molecole[p] ) ) ++p;
				while( isdigit( Molecole[p] ) )
					Coefficient = (Coefficient * 10) + (Molecole[p] ^ 48), ++p;
			}
			else Coefficient = 1;

			while( i < t ) {	// 原子团里的单个元素，同下
				if( Ishulet( Molecole[i] ) ) {
					string Element; Element += Molecole[i];
					if( Ispilet( Molecole[i+1] ) ) Element += Molecole[++i];
					double Element_mass = atom[Element];
					if( Molecole[i+1] != '_' ) {
						Atomic_mass += Element_mass, ++i; continue;
					}
					while( !isdigit( Molecole[i] ) ) ++i;
					int Coefficient = 0;
					while( isdigit( Molecole[i] ) )		// 算系数
						Coefficient = (Coefficient * 10) + (Molecole[i] ^ 48), ++i;
					Atomic_mass += Coefficient * Element_mass;	// 部分质量乘系数
				}
				++i;
			}
			Molecole_mass += Coefficient * Atomic_mass;
			i = p;
		}
		else if( Ishulet( Molecole[i] ) ) {		// 单个元素
			string Element; Element += Molecole[i];
			if( Ispilet( Molecole[i+1] ) ) Element += Molecole[++i];
			double Element_mass = atom[Element];
			if( Molecole[i+1] != '_' ) {	// 没有系数
				Molecole_mass += Element_mass; continue;
			}
			while( !isdigit( Molecole[i] ) ) ++i;
			int Coefficient = 0;
			while( isdigit( Molecole[i] ) ) 	// 算系数
				Coefficient = (Coefficient * 10) + (Molecole[i] ^ 48), ++i;
			if( !Coefficient ) Coefficient = 1;
			Molecole_mass += Coefficient * Element_mass;	// 部分质量乘系数
		}
		
	cout << Molecole_mass << endl;	// 最终答案
    
	// printf("_______________________________________________\n");
	// printf("Process Exited Correctly With A Return Value 0.\n");
	return 0;
}

```

如果不懂就问吧x。

---

## 作者：shzr (赞：0)

	大模拟，又没有部分分...对于码力差的选手极不友好。  
	
    首先看一点简单的部分，只有一个元素符号的，这是其他部分的基础，可以想到用一个map来保存元素的相对分子质量，如果怕出现精度问题，可以全部*10，输出时再/10，这个表可以手动打也可以用word的一些奇妙应用来实现。（具体参见出题人昨晚的直播打表）
    
	首先是读入，既然没有空格，直接cin就可以。因为括号没有嵌套，所以从头开始扫一遍，边扫边做。

1.如果找到一个大写字母，就看看之后有没有紧邻的小写字母，从而组合出这个元素符号，再向后扫，如果有下划线，就向后跳两步，按照快速读入的思路读入下标。

2.如果找到一个~，就读入水的系数，加进ans里，注意：水可能没有系数（$NH_{3}-H_{2}O$)

3.如果出现左括号，就递归的进行上述过程，但是括号没有嵌套，所以可以偷懒一下，直接把1部分的代码复制过来...

然后就做完了。

```cpp
# include <cstdio>
# include <iostream>
# include <cstring>
# include <string>
# include <map>

using namespace std;

string a,no;
int l,h=0,ans=0,num;
map <string,int> m;

void init()
{
	m["H"]=10;
	m["C"]=120;
	m["N"]=140;
	m["O"]=160;
	m["F"]=190;
	m["Na"]=230;
	m["Mg"]=240;
	m["Al"]=270;
	m["Si"]=280;
	m["P"]=310;
	m["S"]=320;
	m["Cl"]=355;
	m["K"]=390;
	m["Ca"]=400;
	m["Mn"]=550;
	m["Fe"]=560;
	m["Cu"]=640;
	m["Zn"]=650;
	m["Ag"]=1080;
	m["I"]=1270;
	m["Ba"]=1370;
	m["Hf"]=1785;
	m["Pt"]=1950;
	m["Au"]=1970;
	m["Hg"]=2010;
}

int main()
{
	cin>>a;
	l=a.length();
	init();
	h=0;
	no="";
	while (h!=l)
	{
		if(a[h]=='(')
		{
			int s=0;
			h++;
			while (a[h]!=')')
			{
				no="";
				if(a[h]>='A'&&a[h]<='Z')
				{
					if(a[h+1]<='z'&&a[h+1]>='a') no+=a[h],no+=a[h+1],h++;
						else no+=a[h];
				}
				if(a[h+1]!='_')
				{
					s+=m[no];
					no="";
				}
				else
				{
					h=h+3;
					num=0;
					while (a[h]>='0'&&a[h]<='9')
					{
						num=(num<<3)+(num<<1)+(a[h]^48);
						h++;
					}
					s+=num*m[no];
					no="";
				}
				h++;
			}
			if(a[h+1]!='_')
				ans+=s;
			else
			{
				h=h+3;
				num=0;
				while (a[h]>='0'&&a[h]<='9')
				{
					num=(num<<3)+(num<<1)+(a[h]^48);
					h++;
				}
				ans+=num*s;
				no="";
			}
		}
		else  if(a[h]=='~')
		{
			h++;
			if(a[h]=='H')
				ans+=180;
			else
			{
				num=0;
				while (a[h]>='0'&&a[h]<='9')
				{
					num=(num<<3)+(num<<1)+(a[h]^48);
					h++;
				}
				ans+=num*180;
				no="";
			}
			h+=5;
		}
		else if(a[h]>='A'&&a[h]<='Z')
		{
			if(a[h+1]<='z'&&a[h+1]>='a') no+=a[h],no+=a[h+1],h++;
			else no+=a[h];
			if(a[h+1]!='_')
			{
				ans+=m[no];
				no="";
			}
			else
			{
				h=h+3;
				num=0;
				while (a[h]>='0'&&a[h]<='9')
				{
					num=(num<<3)+(num<<1)+(a[h]^48);
					h++;
				}
				ans+=num*m[no];
				no="";
			}
		}
		h++;			
	}
	if(ans%10) 
		printf("%.1lf",ans*0.1);
	else
		printf("%d",ans/10);
	return 0;
}
```

---

## 作者：info___tion (赞：0)

额……发表一下看法吧。其实这一题根本算不上蓝题，我觉得黄题就可以了（毕竟只是一道字符串处理题而已，估摸着比某年$NOIP$提高组的第一题还要简单）

-----------------------------------------------分割线--------------------------------------------

## 基本算法

看到题解里面很多人都是直接用循环写的，也不是说不能这样写，只不过本人觉得用循环写的话**直观性不高**，且出错的可能也很大。于是本人就用了**子函数（也就是递归）**来写这一道题。

---

## 实现过程

首先，最基本的操作就是用一个指针（用$cur$表示）扫描整个字符串。然后，我们做分类讨论：

### 1.当$cur$指向的是一个大写字母时：

这就代表我们找到了一个元素，但我们需要知道**我们找到的元素是什么**，所以我们要用一个临时指针$p$去扫描后面的字母：

```cpp
if(isupper(s[cur]))
{
	string tmp;
	tmp+=s[cur];
	
	int p=cur+1;
	
	while(islower(s[p])) tmp+=s[p],p++;
```

这样扫描完之后，tmp就是我们找到的元素。

然后，如果后面有下标，我们就提取出下标中的数字，否则就结束这次循环。

处理这种情况的代码如下：
```cpp
if(isupper(s[cur]))
{
	string tmp;
	tmp+=s[cur];
	
	int p=cur+1;
	
	while(islower(s[p])) tmp+=s[p],p++;
	
	double base=col(tmp);
	
	if(s[p]=='_')
	{
		p+=2;	//直接跳到数字所在的位置
		
		int num=0;
		while(isdigit(s[p])) num=num*10+s[p]-'0',p++;
		
		p++;	//扫描完数字后，p会停留'}'上，所以要加一跳过它
		ret+=base*num;
	}
	else ret+=base;
	
	cur=p;
}
```

大家可能会问，这句话是什么意思？

```cpp
double base=col(tmp);
```

还记得题目下面那个元素原子量的表吗？这个$col$函数就是处理元素原子量的。（输入一个字符串，返回一个double类型的数）至于如何实现这个函数，就留给大家思考吧~~（本人是直接打表的）~~。

---

### 2.当$cur$指向的是左括号时

这样也不难，我们可以再新建一个指针$p$，去直接找出右括号所在的位置（因为**括号不会嵌套**，所以不用维护一个栈）。

```cpp
if(s[cur]=='(')
{
	int p=++cur;
	while(s[p]!=')') p++;
```

然后，我们就可以递归处理从cur到p-1的这一段子串了，至于下标之类的操作则是一模一样的。具体可以看代码：

```cpp
if(s[cur]=='(')
{
	int p=++cur;	//cur++是因为cur当前指向的是左括号，要再加一才能指向里面的元素
	while(s[p]!=')') p++;
	
	double base=solve(s.substr(cur,p-cur));	//相当于把括号里的元素看成一个整体去计算
	
	p++;	//因为要检查是否有下标，所以要加一
	if(s[p]=='_')
	{
		p+=2;
		
		int num=0;
		while(isdigit(s[p])) num=num*10+s[p]-'0',p++;
		
		p++;
		
		ret+=base*num;
	}
	else ret+=base;
	
	cur=p;
}
```

---

### 3.如果$cur$指向的是'~'

那就说明我们找到了水合物，所以我们只需要计算水（$H_{2}O$）前面的数字再乘上水的质量即可（水的质量为2\*1+1\*16=$18$）。

# 但是，有一个坑！！！
## 水分子前面可能没有数量！！！

没错，整个题目唯一的坑就在这里，当然了，填这个坑也很简单，特判一下即可。代码如下：

```cpp
if(s[cur]=='~')
{
	int p=++cur;
		
	int num=0;
	while(isdigit(s[p])) num=num*10+s[p]-'0',p++;
	
	if(!num) num=1;	//如果没有扫描到数字，就默认为1
	
	ret+=H_2O*num;	//H_2O是一个常量，本人在之前定义了
	
	break;	//在题目定义中，水合物的后面不会有其他元素了，所以可以直接结束循环
}
```

---

## 完整代码

```cpp
#include<string>
#include<iostream>
#include<ctype.h>
using namespace std;

const int H_2O=18;	//多定义常量是个好习惯:)

double col(string s)	//这就是col函数（怎么样，够简单（划掉）吧）
{
	if(s=="H") return 1;
	if(s=="C") return 12;
	if(s=="N") return 14;
	if(s=="O") return 16;
	if(s=="F") return 19;
	if(s=="Na") return 23;
	if(s=="Mg") return 24;
	if(s=="Al") return 27;
	if(s=="Si") return 28;
	if(s=="P") return 31;
	if(s=="S") return 32;
	if(s=="Cl") return 35.5;
	if(s=="K") return 39;
	if(s=="Ca") return 40;
	if(s=="Mn") return 55;
	if(s=="Fe") return 56;
	if(s=="Cu") return 64;
	if(s=="Zn") return 65;
	if(s=="Ag") return 108;
	if(s=="I") return 127;
	if(s=="Ba") return 137;
	if(s=="Hf") return 178.5;
	if(s=="Pt") return 195;
	if(s=="Au") return 197;
	if(s=="Hg") return 201;
}

double solve(string s)
{
	double ret=0.0;
	
	int cur=0;
	while(cur<s.size())
	{
		if(isupper(s[cur]))
		{
			string tmp;
			tmp+=s[cur];
			
			int p=cur+1;
			
			while(islower(s[p])) tmp+=s[p],p++;
			
			double base=col(tmp);
			
			if(s[p]=='_')
			{
				p+=2;
				
				int num=0;
				while(isdigit(s[p])) num=num*10+s[p]-'0',p++;
				
				p++;
				ret+=base*num;
			}
			else ret+=base;
			
			cur=p;
		}
		else if(s[cur]=='(')
		{
			int p=++cur;
			while(s[p]!=')') p++;
			
			double base=solve(s.substr(cur,p-cur));
			
			p++;
			if(s[p]=='_')
			{
				p+=2;
				
				int num=0;
				while(isdigit(s[p])) num=num*10+s[p]-'0',p++;
				
				p++;
				
				ret+=base*num;
			}
			else ret+=base;
			
			cur=p;
		}
		else if(s[cur]=='~')
		{
			int p=cur+1;
				
			int num=0;
			while(isdigit(s[p])) num=num*10+s[p]-'0',p++;
			
			if(!num) num=1;
			
			ret+=H_2O*num;
			
			break;
		}
	}
	
	return ret;
}

int main()
{
	ios::sync_with_stdio(false);
	
	string s;
	cin>>s;
	
	cout<<solve(s);
	
	return 0;
}
```

---

## 作者：啊嘞嘞嘞嘞 (赞：0)

很简单的一题，字符串处理并没那么复杂，瞎拍就拍出来了（虽然好像也拍了45min）

我这个代码应该是比较简洁的

先声明：sum1记录一个括号（也可能无括号）里的质量，sum2记录有前缀的一堆原子的总质量（包含多个sum1）

现在探讨解决几个问题

1.如何存表、查表？

论代码简洁度肯定选map。不知道是不是我火星了，可以直接对map进行初始化，方式和二维数组初始化差不多。

用数组初始化也能做，开个key,value数组，初始化的时候批量insert就行了

搞了这么久oi应该会利用工具吧……把表格复制到excel，用公式加分隔符之类的

避免浮点问题，先将所有质量*2， 输出的时候奇偶分类即可

2.多字母的元素

大写字母肯定是开头，如果下一个是小写字母那么读下去，记得存这个元素名称

3.下标

读完一个元素后调用一下函数

函数检查下一个字符是否是'_'，如果是则一直读到'}'顺便改变循环变量的值，否则返回1

将原子量*数量加到sum1里去

4.括号

先结算一个sum1  sum2+=sum1

如果是后括号，需要函数检测后缀

然后清空sum1

如果有括号嵌套，把sum改为数组即可，结算的时候a[i-1]+=a[i]*cnt, a[i]=0

5.水合物 

哈？水合物？直接当作一大堆'~'串起来的物质做的……

管它有多少个'~'，直接在字符串最前面和最后面各加一个'~'（读入的时候从下标1开始读）

先结算sum2（要乘前缀的cnt），然后sum,cnt都清零

接着读下一个前缀（注意如果读的是0，改为1）

--
然后就没了  全程顺着读，不考虑查表其实是正好的O(L)

最后上代码

```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <cctype>
#include <map>
using namespace std;
const int n=25;
const char keys[25][4]={"H","C","N","O","F","Na","Mg","Al","Si","P","S","Cl","K","Ca","Mn","Fe","Cu","Zn","Ag","I","Ba","Hf","Pt","Au","Hg"};
const double values[25]={1,12,14,16,19,23,24,27,28,31,32,35.5,39,40,55,56,64,65,108,127,137,178.5,195,197,201};
map<string,int> dict;
char str[110];
int l;
int readnum(int &i) { //从'_'开始读，返回该后缀的数值
	if (str[i]!='_') {
		i--; //抵消循环结束后i的自增
		return 1;
	}
	int cnt=str[i+=2]-'0'; //因为默认i对应的是'_'，所以要往后跳2个
	while (str[++i]!='}') { //很普通的读数
		cnt=cnt*10+str[i]-'0';
	}
	return cnt;
}
int main() {
	for (int i=0;i<n;i++) {
		dict.insert(make_pair(keys[i],values[i]*2)); //存的是两倍，避免浮点
	}
	scanf("%s",str+1);
	str[0]='~';
	l=strlen(str);
	str[l++]='~';
	int ans=0;
	int cnt1=1; //前缀计数
	int sum=0,sum2=0; //括号内的和，同个前缀下的和
	for (int i=0;i<l;i++) {
		char ch=str[i];
		string elem;
		elem+=ch;
		if (ch>='A' && ch<='Z') {
			while (islower(str[i+1])) { //（其实这样对于任意长度的元素名都能读）
				elem+=str[++i];
			}
			sum+=dict[elem]*readnum(++i);
		} else if (ch=='(') {
			sum2+=sum;
			sum=0;
		} else if (ch==')') {
			sum2+=sum*readnum(++i);
			sum=0;
		} else if (ch=='~') {
			ans+=cnt1*(sum2+=sum);
			sum=sum2=0;
			cnt1=0;
			while (isdigit(str[i+1])) { //读前缀
				cnt1=cnt1*10+str[++i]-'0';
			}
			if (cnt1==0) cnt1=1;
		}
	}
	if (ans&1) { //直接简单分类讨论
		printf("%.1f\n",ans*0.5);
	} else {
		printf("%d\n",ans/2);
	}
	return 0;
}

```



---


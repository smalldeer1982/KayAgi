# [1007] Scarlet的字符串不可能这么可爱

## 题目描述

Scarlet妄图构造字符集为$k$，长度为$L$的字符串，满足没有任何一个长度超过$1$的回文连续子串。

看起来这样的字符串太多了，Scarlet随手加了个限制：她指定了字符串的第$s$位为$w$。

这下Scarlet不会做了，请你来帮她计算究竟有多少满足条件的字符串。按照套路，你只要求出答案对$p$取模后的结果。

## 说明/提示

字符集：一个字符串中不同字符的数量。例如，字符集是3的话，你可以认为字符串仅由“A”、“B”、“C”三个字母组成。

样例解释：第一个字符固定A，那么符合要求的字符串是ABC,ACB。而AAB字符串包括AA这个回文子串，ACA本身就是回文串，一次类推。

对于50%的数据，$k\leq5,L\leq10$

对于另30%的数据，$s=0$

对于100%的数据$1\leq k,L\leq 10^{18},0\leq s\leq L,1\leq w\leq k,1\leq p\leq 10^9$


## 样例 #1

### 输入

```
3 3 233
1 1```

### 输出

```
2```

# 题解

## 作者：VenusM1nT (赞：22)

题目其实不难……赛场上手推了一下居然推出来了

首先很明显地，指定字符的位置和值都没有用……

也就是说，$w$这个变量可以直接扔掉了……至于$s$，我们只需要用它是不是正的

接下来开始推吧……

假设字符集大小为$4$，长度为$5$，如果没有限制的话，很明显，答案为$4*3*2*2*2=96$，因为我们要求一个没有回文串的字符串，所以一个位置会对后面两位进行限制，也就是说第一位可以用$k$种，但是第二位就会因为前面一个位置的限制而少掉$1$种字符的使用，然后从第三位开始一直是$k-2$种了。

至此我们得出结论，当$s==0$，$k>=2$、$l>=2$时，$ans=k*(k-1)*(k-2)^{l-2}$（当然，$0^0$还是不行滴）

如果指定字符呢？其实也没有什么大不了的，在前面我们可以发现每一个字符会对后两位进行限制，那么这个指定的字符只是会对**前后两位**有限制，

比如上方原本的例子，原来是$4*3*2*2*2$，我们可以先假设它限制的是$1$~$5$中的一位，再进行计算，结果如下

第一位：$X*3*2*2*2$

第二位：$3*X*2*2*2$

第三位：$3*2*X*2*2$

而第四第五种事实上是等价于第一第二种的，由此我们得出结论，在有限制条件的情况下，$ans=(k-1)*(k-2)^{l-2}$

那么我们只需要判断有没有限制字符，再直接计算即可，值得注意的是，我们这里需要用到快速幂，且一开始就需要对$k$取余，否则就会$WA$掉。

（注：证明过程可能不严谨，这里只是给出了我自己在推结论时的思路，仅供参考）

具体实现见代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll k,l,Mod,s,w,ans=1;
ll poww(ll a,ll b)//快速幂
{
    ll sum=1;
    a%=Mod;
    while(b!=0)
	{
        if(b&1!=0) sum=sum*a%Mod;
        b=b >> 1;
        a=a*a%Mod;
	}
    return sum;
}
int main()
{
	scanf("%lld %lld %lld %lld %lld",&k,&l,&Mod,&s,&w);
	k%=Mod;//先膜为敬
	if(l==1)//特判特殊情况
	{
		if(s) printf("1");
		else printf("%lld",k);
	}
	if(s) ans=ans*(k-1)%Mod;
	else ans=ans*k*(k-1)%Mod;//根据有没有指定字符进行分别计算
	k-=2;
	ans=(ans*poww(k,l-2))%Mod;
	printf("%lld",ans);//输出答案
	return 0;
}
```

---

## 作者：WYXkk (赞：15)

~~众所周知，看到输入量少的题目，我们可以找规律。~~

事实上这题不需要找规律，结论还是很明显的。

首先我们来考虑一下，假如一个字符串有**回文连续子串**，那么它会满足什么条件？

考虑每个回文子串的中心的二或三个字符，即可得出结论：

**假如一个字符串有长度超过一的连续回文子串，则其必有两个相邻或间隔一个字符的字符相等**

而假如有两个相邻或间隔一个字符的字符相等，则就有长度为二或三的回文子串。

因此，**一个字符串没有长度超过一的连续回文子串** 等价于 **任意两个相邻或间隔一个字符的字符不相等**。

于是，第一个字符有 $k$ 种取法，第二个字符和第一个字符不同有 $k-1$ 种取法，后面的字符和其前两个字符不同有 $k-2$ 种取法（其前两个字符必定不同）。

于是，没有限制的情况，答案显然是 $k(k-1)(k-2)^{L-2}$。

假如有限制呢？

**非常显然地**，无论 $w$ 是什么，答案都不会变，因为 $k$ 种颜色是互相对称的。

于是，指定了以后，把总数除以 $k$ 即可，答案即为 $(k-1)(k-2)^{L-2}$。

对于某些 $k,L$ 比较小的情况稍微讨论一下即可。

代码懒得放了。

---

## 作者：lgswdn_SA (赞：4)

被状压标签吸引进来的，然后真想骂一句“qndzy”。

很明显的乘法原理题目，数据范围又这么大，是个结论题。

（本题解中的 $n$ 均代表总长度）

对于题目中要求的不能有回文子串，其实就是不能有长度为 $2$ 或 $3$ 的回文子串，而这两个都非常好判断，即 $a_i\neq a_{i-1}, a_i\neq a_{i-2}$。

对于 $s=0$ 的情况，答案很容易知道是 $k\times (k-1)\times (k-2)^{n-2}$，基础乘法原理。

我们重点看一下 $s\neq 0$ 的情况。

如果 $s=1$，那么第一位只有 $w$ 一种选择，第二位有 $k-1$ 种选择（不能是 $w$），第三位就一样啦。所以答案是 $(k-1)\times (k-2)^{n-2}$。

如果 $s=2$，那么第一位只有 $k-1$ 种选择（不能是 $w$），第二位只有 $w$ 一种选择，第 $3$ 位没有任何的变化，还是只有 $k-2$ 种。

我们看到 $s=i$ 的情况，分类讨论，左边和右边。

对于 $io$ 左边的字符串，我们**逆向填字符**，从第 $i-1$ 位填到第 $1$ 位。第 $i-1$ 位有 $k-1$ 种填法，第 $i-2$ 位有 $k-2$ 种填法，剩下也全是 $k-2$ 种填法（基础乘法原理）。

对于 $i+1$，由于 $i$ 和 $i-1$ 已经填好，所以只有 $k-2$ 种选择。剩余的也只有 $k-2$ 种选择。

所以最终答案是，如果 $s\neq 0$ 那么 $ans=(k-1)(k-2)^{n-2}$

所以其实 $s\neq 0$ 和 $s=0$ 就差了一个代表第 $s$ 位的 $n$。*但是这道题不能用逆元所以就别想偷懒直接除了吧。*

最终 Kasumi 一下就行啦。也就提高组 T1 难度吧。

由于 $k$ 本身很大，所以我们需要让 $k$ 先对 $p$ 取模。取模后如果 $k<2$ 那么需要让他加回 $2$ 否则试试这组数据（from 讨论区）

```
2 2 2
2 2
```
你会得到 $-1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll k,n,p,s,w;

ll ksm(ll a,ll b) {
	if(b==0) return 1;
	else if(b==1) return a;
	else return ksm(a*a%p,b/2)*(b%2?a:1)%p;
}

int main() {
	scanf("%lld%lld%lld%lld%lld",&k,&n,&p,&s,&w);
	k%=p; while(k<2) k+=p;
	if(n==1) printf("%lld",(s?1:k));
	else if(!s) printf("%lld",k*(k-1)%p*ksm(k-2,n-2)%p);
	else printf("%lld",(k-1)*ksm(k-2,n-2)%p);
	return 0;
}
```

---

## 作者：Y_B_Y (赞：3)

这一题题意为,求由$K$个字符组成,长度为$L$且第$s$位为$w$的字符串的个数,再膜$^{[1]}p$



虽然不知道为什么这一题会有状压标签,但是看$L$的大小就可以知道它与状压应该没什么关系,而是一道**数学题**



先来看$s==0$的情况



首先我们知道,所求字符串的第一位有$K$中可能,我们设第一位为$A$,我们**一步步来构造这个字符串**,我们先加入第一位




此时字符串为"$A$"



然后再来看第二位,因为**不能存在长度大于1的回文串**,所以第二位不能为$A$,所以只剩$K-1$种选择,设第二个字符为$B$,加入到字符串



此时字符串为"$AB$"



然后再来看第三位,因为不能存在长度大于1的回文串,所以第三位不能为$B$,也不能为$A$,所以只剩$K-2$种选择,设第三个字符为$C$,加入到字符串



此时字符串为"$ABC$"



然后再来看第四位,因为不能存在长度大于1的回文串,所以第四位不能为$C$,也不能为$B$,但是可以为$A$,因为"$ABCA$"中不可能存在长度大于1的回文子串,所以有$K-2$种选择,设第四个字符为$D$,加入到字符串



此时字符串为"$ABCD$"




从第四位开始剩下的$L-3$位,都和第四位一样,有$K-2$种选择



以此类推,我们不难发现$^{[2]}$,答案为$K\times (K-1)\times (K-2)^{L-2} \bmod p$



再来看$s≠0$的情况,如果你将这种情况想成像上面一样从第一位开始填,然后要满足第$s$位为$w$,然后第$s-1$,$s-2$为不能为$s$,那情况将会变得**复杂很多**,我们可以换一种思路,假我们想一下最终得到的字符串,字符$w$一般是在其中间的位置,**我们设构造$w$左边的字符串有$a$种方法,构造完左边的后再构造右边的字符串有$b$种方法,可以知道答案为$a\times b \bmod p$**



所以我们先来考虑构造$w$左边的字符串,**我们可以从$w$的左边开始构造(即先构造第$s-1$个字符)**,因为它不能为$w$,所以有$K-1$种选择,我们设这个字符为$A$,加入字符串中



此时的字符串为"$\cdots \_~\_ ~\_~ \_~~ A~w~ \_~\_~\_~\_\cdots$"("$\_$"为还未构造的区域)



再构造第$s-2$个字符,不难发现,它有$K-2$种选择,设它为$B$,加入



此时的字符串为"$\cdots \_~\_ ~\_~ B~ A~w~ \_~\_~\_~\_\cdots$"



不难发现,第$s-3$到第一个字符都有$K-2$种选择,所以我们设构造$w$左边的字符串有$(K-1)\times (K-2)^{s-2}\bmod p$中方法



再来构造右边的字符串,同样我们从第$s+1$个字符开始构造,因为此时的字符不能为$w$,也不能为$A$,所以只有$K-2$种选择,设它为$C$,加入



此时的字符串为"$\cdots J~H ~G~ B~A~w~ C~\_~\_~\_\cdots$"



不难发现,从第$s+2$到第$n$个字符串都只有$K-2$种选择.



所以我们设构造$w$右边的字符串有$(K-2)^{L-s}\bmod p$种方法



**所以最后答案为$(K-1)\times (K-2)^{L-2} \bmod p$**



可以验证,当我们的假设"字符$w$在其中间的位置"不成立,答案也是正确的



注意这一题由于$N≤10^{18},p≤10^9$,$p^3$即爆$\operatorname{long~ long}$,所以务必做到**每一次乘法膜一次**,每一个种答案输出时也膜一次,$K$一开始最好直接膜一次



###### $[1]$:"膜"同"模".



###### $[2]$:自己模拟一下就知道了.



代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
ll n,k,p,s,w;//n表示题目中的L
ll qpow(ll x,ll y,ll z)//(x^{y})%z,快速幂
{
	ll s=1;
	x%=z;
    while(y>0)
    {
      if(y%2) s=s*x%z;
      x=x*x%z;
      y>>=1;
    }
    return s%z; 
}
int main()
{
	cin>>k>>n>>p>>s>>w;
	k%=p;
	if(n==1) return s? printf("%lld",1%p),0:printf("%lld",k%p),0;
	ll ans=(k-1)%p;
	if(!s) ans=(ans*k)%p;
	ans=(ans*qpow(k-2,n-2,p))%p;
	return printf("%lld",ans),0;
}
```


---

## 作者：AAA404 (赞：2)

写下题解纪念一下这道挺有意思的组合数学题。

# 没限制的情况

## 思路简析（建议在计数方式前阅读）

没有长度超过 $1$ 的回文连续子串意思就是除了单个字符外没有回文串，而每一个回文串可以看作是**一个已有的回文串的两端同时加上相同字符得来**，所以要保证不出现回文串，**只需要保证没有长度为 $2$ 和 $3$ 的回文串即可**。

## 计数方式

那么对于第一个位置，显然有 $k$ 种放法；

第二个位置，**不与第一个位置相同（保证无长度为 $2$ 的回文串）**，有 $k - 1$ 种放法；

**对于第三个位置，要满足：**

- 不与第二个位置相同（不存在长度为 $2$ 的回文串）；

- 不与第一个位置相同（不存在长度为 $3$ 的回文串）。

于是有 $k - 2$ 种放法。

而对于第四个之后的位置，不与前两个位置的字符相同（与第三个位置原因类似），**但是可以与再前面一个的位置相同**，故每个都有 $k - 2$ 种放法。

于是有 $k \times (k - 1) \times (k - 2)^{l - 2}$ 种方案。

至此已获得 $30$ 分。

# 有限制的情况

我们已经有了无限制情况下的方案数：$k \times (k - 1) \times (k - 2)^{l - 2}$。

由于只统计方案数，所以被指定为哪个字符我们**并不关心**，同时对于哪一个位置被指定也**并不关心（下面给出分析）**。

可以这样理解：由于并没有指定放的顺序，所以我们可以把 $s$ 这一位置拎出来，放到**最前面即第一位**，第一位本该有 $k$ 种方案，但是**由于被指定**，只能有 $1$ 种方案。

故将无限制的情况的答案除以 $k$ 即可，答案是：$(k - 1) \times (k - 2)^{l - 2}$。

然后可以拿下 $100$ 分。

# 实现

直接快速幂实现即可，时间复杂度：$O(\log k)$。

记得一开始直接取模。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,l,mod,s;
long long qpow(long long  a,long long b)
{
	long long ans=1,base=a;
	while(b)
	{
		if(b&1)ans*=base,ans%=mod;
		base*=base,base%=mod;
		b>>=1;
	}
	return ans;
}
int main()
{
	clock_t c1=clock();
#ifdef LOCAL
 	freopen("1.in","r",stdin);
 	freopen("1.out","w",stdout);
#endif
    ios::sync_with_stdio(0);
 	cin.tie(0);cout.tie(0);
	cin>>k>>l>>mod>>s;
	k%=mod;
	if(s)cout<<(k-1)*qpow(k-2,l-2)%mod<<endl;
	else cout<<k*(k-1)%mod*qpow(k-2,l-2)%mod<<endl;
#ifdef LOCAL
	cerr<<"Time used:"<<clock()-c1<<"ms";
#endif
 	return 0;
}
```


---

## 作者：_maple_leaf_ (赞：1)

### [$Luogu\ P4925$](https://www.luogu.com.cn/problem/P4925)

## 题意
**此题题意已够清晰不过多赘述**

题意差不多是如果构造一个长度为 $L$ 的字符串，使得没有任何一个长度超过 $1$ 的回文连续子串，在 $s \ne 0$ 时，第 $s$ 位为 $w$，那么有几个这样的字符串，并对个数 $\bmod\ p$ 输出。

## 思路
首先，如果要保证没有任何长度超过 $1$ 的回文连续子串，那么就一定要保证没有长度为 $2$ 或 $3$ 的回文连续字串，因为在任何长度超过 $3$ 的回文连续字串的中心，就是一个长度为 $2$ 或 $3$ 的回文连续字串。

那么也就是说，我们需要保证两个相邻或中间隔一个的所有字符不相等。

所以，在没有题目中第 $s$ 位为 $w$ 这个限制时，用草稿纸浅浅推一下：$ans = k  (k-1) (k-2)^{L-2}$。

其次，我们再来看限制，以 $k=4,L=4$ 为例：\
用草稿纸浅浅推一下限制在不同位置的情况\
第一位：$W \times 3 \times 2 \times 2$\
第二位：$3 \times W \times 2 \times 2$\
第三位：$2 \times 3 \times W \times 2$\
第四位：$2 \times 2 \times 3 \times W$\
观察不难发现，此时 $ans =(k-1)(k-2)^{L-2}$。

最次，我们需要特判一下 $L=1$ 时的情况 ~~（但是，由于数据过水，不用特判）~~。

## code
```
#include<bits/stdc++.h>
#define int long long
#define Fre(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
inline int read(){
	char c=getchar();
	int ret=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		ret=(ret<<3)+(ret<<1)+c-'0';
		c=getchar();
	}return ret*f;
}
inline void write(int x,int op){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10,0);
	putchar((char)(x%10+'0'));
	if(op){
		if(op>0)puts("");
		if(op<0)putchar(' ');
		if(op==0)puts("114514");
	}
}快读快写懒得解释
int k,l,p;
int s,w;
int qpow(int a,int b,int m){
	int ret=1LL;
	while(b){
		if(b&1)ret=ret*a%m;
		a=a*a%m;
		b>>=1;
	}return ret%m;
}快速幂
main(){
	k=read(),l=read(),p=read();
	k%=p;
	s=read(),w=read();
	if(l==1){
		特判，但不用写，因为我懒得写
	}
	if(s==0){到柿子啦！
		int tmp=k*(k-1)%p*qpow(k-2,l-2,p)%p;
		write(tmp%p,1);
	}else{
		int tmp=(k-1)*qpow(k-2,l-2,p)%p;
		write(tmp%p,1); 
	}
	return 0;
}*~完结撒花~*
```

---

## 作者：THE_Epsilon (赞：1)

# 题意
你有 $k$ 个不同字母（可以无限使用），要构造一个长度为 $L$ 且其中**没有回文子串（长度大于 $1$）** 的字符串，问有几种方法。

美丽的出题者还增加了一个条件：字符串的第 $s$ 位是第 $w$ 个字母。
# 思路
这个题的输入输出很简短，所以大概率是个**结论题**（事实证明如此）。

这个字符串不能是回文的，我们可以枚举一下。
## 没有限制条件的时候（$s=0$）
$4$ 个字母（假设为 `A` `B` `C` `D`）。

第一位有 $4$ 个选择（可选择 `A` `B` `C` `D`，假设选择 `A`）。

第二位只有 $3$ 种选择（可选择 `B` `C` `D`，因为选择 `A` 就与第一位构成回文。假设选择 `B`）。

第三位有 $2$ 种选择（`C` `D`，选 `A` 的话与前两位回文，选 `B` 的话与第二位回文。假设选择 `C`）。

第四位有 $2$ 种选择（`A` `D`，选 `B` 的话与第二位开始之后的子串回文，选 `C` 的话与第三位回文）。


------------

所以我们可以发现，每个位置要考虑两个因素：与前一个不重复、与从后往前数第二个不重复。由于第一位没有前一个和两个，所以可选择数量为 $k$；第二位没有前两个，所以可选择数量为 $k-1$；之后所有位置都要考虑两个因素，所以可选数量为 $k-2$。

得到公式：$ans=k\times(k-1)\times(k-2)^{(L-2)}$。

## 有限制条件的时候
我们还以刚才的思路，有字母被限制的时候就意味着消失了 $k$ 次选择的权力。所以可以得出公式：$ans=(k-1)\times(k-2)^{(L-2)}$。
# 拿分细节
## 题目要求：$\bmod$
开始的时候就要先把 $k=k\bmod p$，不然数据会太大。
## 快速幂
公式里面有幂运算，但是数据范围又很大，用快速幂可以节省很大一部分时间复杂度。

无快速幂：[50 pts](https://www.luogu.com.cn/record/156187904)。

有快速幂：[100 pts](https://www.luogu.com.cn/record/156088410)。
# 代码
```cpp
// pragma GCC optimize("Ofast,no-stack-protector")
// pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<bits/stdc++.h>
using namespace std;
long long k,l,p,s,w,ans;
void qpow(long long xx, long long yy) {
	long long x=xx,y=yy;
	x%=p;
	while(y){
		if(y&1)
		{
		    ans*=x;ans%=p;
		}
		x*=x;x%=p;
		y>>=1;
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
	cin>>k>>l>>p>>s>>w;
	k%=p;
	if(s==0)
	{
	    if(l==1)
	    {
	        cout<<k;
	        return 0;
	    }
	    ans=k;
	    ans*=k-1;
	    ans%=p;
	    qpow(k-2,l-2);ans%=p;
	}
	else
	{
	    if(l==1)
	    {
	        cout<<1;
	        return 0;
	    }
	    ans=1;
	    ans*=k-1;
	    ans%=p;
	    k-=2;ans%=p;
	    qpow(k,l-2);
	    ans%=p;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：OIer_ACMer (赞：1)

~~能不能在简单一点？~~

------------
## 注意：
本题由于涉及到的知识点并不是十分复杂，所以笔者在这里不会过多赘述原理以及证明，请各位悉知！

------------
## 大致思路：
本题远没有想象中的状压 DP 那么难，而仅仅只是涉及到了**快速幂**的应用以及**乘法原理**。

既然题目要求不能出现**回文子串**，那我们先回顾一下什么事回文子串：**回文子串是字符串中出现了有相邻 $2$ 个字相等，或间 $2$ 个隔 $1$ 个字符的字符相等**。那么没有回文子串，就相邻 $2$ 个字符，或间 $2$ 个隔 $1$ 个字符的字符不相等。

设字符串中第一位有 $k$ 中字符，由于第二位由于第一位不同，则只能有 $k - 1$ 种字符，第三位要与前两位不同，因此只能有 $k - 2$ 种不同的字符，则其余位都是 $k - 2$ 种（根据乘法原理可以得到）。

若没有限制，则可以得到答案是 $ans = k \times (k - 1) \times (k - 2)^{l - 2}$。

但是我们有要求第 $s$ 为的字符为 $w$，则将这一位作单独处理，将 $ans$ 除以 $k$ 就行，因为每一位都少了选择 $w$ 的机会，那么答案是 $ans=(k - 1) \times (k - 2) ^ {l - 2}$，之后的事就用快速幂来解决吧。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
int mod;
int qp(int n, int m)
{
    int ans = 1;
    while (m)
    {
        if (m & 1)
        {
            ans *= (n % mod);
            ans %= mod;
        }
        n *= (n % mod);
        n %= mod;
        m >>= 1;
    }
    return ans % mod;
}
int k, l, s, ans = 1, w;
signed main()
{
    k = read();
    l = read();
    mod = read();
    s = read();
    w = read();
    k %= mod;
    if (l == 1)
    {
        if (s)
        {
            cout << 1 << endl;
        }
        else
        {
            cout << k << endl;
        }
    }
    if (s)
    {
        ans = ans * (k - 1) % mod;
    }
    else
    {
        ans = ans * k * (k - 1) % mod;
    }
    ans = (ans * qp(k - 2, l - 2)) % mod;
    cout << ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122240425)

---

## 作者：Exschawasion (赞：1)

如果要解本题，需要弄懂的是题干所说的**长度不超过 $1$ 的回文子串**性质是什么。

显然，讨论长度为 $1$ 的回文串是没有意义的，因此下文的“回文串”默认其长度大于 $1$。

回文串按照其长度可以分为**奇回文串**和**偶回文串**两种。设字符串 $S$ 长度为 $n$，第 $i$ 个字符为 $S_i$，那么回文串可以定义成如下形式：

$$\{S~|~\forall i \in[1,\lfloor \frac{n}{2}\rfloor],~ S_i=S_{n-i} \}$$

思考如下问题：当字符串 $S$ 不含回文串时，加入一个字符 $x$，使得新字符串 $S'$ **不含有**回文串。问 $x$ 应满足什么条件？

首先得到一个推论：每次加入新字符，如果形成了新的回文串，那么这个回文串的长度**只可能**是 $2$ 或 $3$。因为如果构成了构成了长度为 $k$ 的回文串（$k > 3$），那么原串必然包含一个长度为 $(k-2)$ 的回文串，与题设矛盾。

因此，要判断加入 $x$ 后是否会形成回文串，只需要检查 $S$ 的**后两个字符**是否和 $x$ 不同即可。依此，不难写出一个记忆化搜索程序：

```
// 不是正解
int dp(int last2, int last1, int pos) {
	if(f[last2][last1][pos]) return f[last2][last1][pos];
	if(pos == n + 1) return 1; // 到达终点 
	if(pos == s) return dp(last1, w, pos + 1); // 存在限制 
	else {
		int ans = 0;
		for(int i = 1; i <= k; i++) {
			if(i != last1 && i != last2) { // 检查后两个字符 
				ans += dp(last1, i, pos + 1);
			} 
		}
		return f[last2][last1][pos] = ans;
	}
}

cout << dp(0, 0, 1); // 调用入口
```

对于题目的数据规模，这样的记忆化搜索，时间空间都无法承受，因此考虑对其进行优化。

仔细观察，不难发现，对于一个状态，它的值便是**它的搜索子树的节点数**。这是因为这个递归函数的边界只有一个：$\text{pos}=n+1$ 时返回 $1$。也就是说，如果能够直接计算出某个状态能拓展出的状态数量，就不需要去遍历整棵搜索树了。

首先考虑**不存在限制**即$s=0$ 的情况。对于第一层节点，因为它没有前继的两个字符，所以它一定会拓展出 $k$ 个节点；对于第二层节点，因为它只有一个前继的字符，合法情况少了一种，能拓展出 $(k-1)$ 个节点。那么，对于更加一般的情况呢？

观察程序中的循环，可以发现，搜索树会往下拓展 $1$ 个或 $(k-2)$ 个节点，而这些子节点也能够拓展出 $1$ 个或 $(k-2)$ 个节点，以此类推一直到搜索树深度（即 $\text{pos}$）达到边界（即 $n+1$）为止。所以，搜索树的增长应当是指数级别的，每拓展一层，如果当前深度大于 $2$，搜索树节点树扩大 $(k-2)$ 倍。最终，整棵搜索树的节点数等于 $(k \cdot (k-1) \cdot (k-2)^{L-2})$。

如果有限制，即 $s \neq 0$ 呢？其实答案不难得出：当深度为 $s$ 时，该层只有 $1$ 个拓展出的节点，因此答案将会变为原来的 $\frac{1}{k}$，即节点数变为 $((k-1) \cdot (k-2)^{L-2})$。对于后面的指数项，用快速幂就可以在 $O(\log N)$ 的时间复杂度内求出来。

最后，$L=1$ 的情况虽然被排除在讨论范围之外，但是数据仍然存在该种情况，需要特殊讨论：当 $s=0$ 时，方案数为 $k$；当 $s \neq 0$ 时，方案数为 $1$。

程序实现的时候注意取模，还需要开 $\texttt{long long}$。代码如下：

```
#include <bits/stdc++.h>

using namespace std;

long long k, l, s, w;
long long mod;

long long qpow(long long x, long long y) {
	long long ans = 1;
	x %= mod;
	while(y) {
		if(y & 1) ans *= x, ans %= mod;
		x *= x, x %= mod;
		y >>= 1;
	}
	return ans;
}

int main() {
	cin >> k >> l >> mod >> s >> w;
	if(l == 1) { // 特殊情况讨论 
		if(s) printf("1");
		else printf("%lld", k % mod);
	}
	else {
		long long ans = 1;
		k %= mod;
		// 先考虑有限制的情况 
		ans *= k - 1, ans %= mod;
		ans = (ans % mod) * (qpow(k - 2, l - 2) % mod) % mod;
		
		// 如果没有限制，还可以再多 k 倍 
		if(!s) ans *= k, ans %= mod;
		printf("%lld", ans);
	}
	return 0;
}
```


---

## 作者：Otomachi_Una_ (赞：1)

## 题目简述
- 给一个由 $k$ 中不同字符组成的长度为 $n$ 的字符串。
- 其中没有一个长度超过 $1$ 的连续子串是回文串。
- 规定第 $s$ 为是字符 $w$。（如果 $s=0$ 表示没有限制）
- 求可能方案数对 $p$ 取模的结果。

## 解题思路
首先直觉告诉我们 $w$ 没什么用。可以不用管他。

其中没有一个长度超过 $1$ 的连续子串是回文串，意味着没有出现 $\mathtt{aa}$ 或者 $\mathtt{aba}$ 的形式。只要满足这两个条件就好了（因为其他回文串都包含这两种连续子串）。

假设 $s=0$，那么：
- 第一位就有 $k$ 种选择。
- 第二位因为不能和第一位相同，所以只有 $k-1$ 中选择。
- 第三位不能和第一第二位相同，而且第一第二位必然不同。所以一共 $k-2$ 中选择。
- 剩下的同第三位一样都有 $k-2$ 种选择。

也就是说，一共有 $k\times (k-1)\times (k-2)^{n-2}$。当然要特判 $n=1$ 时。

如果 $s\not=0$，那么因为所有答案中 $s$ 位在所有字符集中出现的概率是均匀的。也就是说会是所有的情况的 $\dfrac{1}{k}$ 。所以答案是 $ (k-1)\times (k-2)^{n-2}$。淡然也要特判 $n=1$ 时。

一个比较阴的点是 $k\leq10^{18}$。不能直接快速幂，需要先把 $k$ 对 $p$ 取模。

## 参考代码
```cpp
#include<iostream>
using namespace std;
#define ll long long
ll n,k,p,s,w;
ll ksm(ll a,ll b){
	ll r=1;
	while(b){
		if(b&1) r=r*a%p;
		a=a*a%p;
		b=b>>1;
	}
	return r;
}
int main(){
	cin>>k>>n>>p>>s>>w;
	k%=p;
	if(s==0){
		if(n==1) cout<<k;
		else cout<<k*(k-1)%p*ksm(k-2,n-2)%p;
	}
	else{
		if(n==1) cout<<"1";
		else cout<<(k-1)*ksm(k-2,n-2)%p;
	}
	return 0;
} 
```


---

## 作者：_Weslie_ (赞：0)

## Solution P4925

### Idea

先考虑没有限制。

![](https://cdn.luogu.com.cn/upload/image_hosting/8q85x3bi.png)

这里我们用一种颜色代表一种字符。

第三个字符应该填什么？显然不能是红或者是蓝。有剩余 $k-2$ 种选择。

![](https://cdn.luogu.com.cn/upload/image_hosting/joyezcbu.png)

接下来第四个肯定不能填蓝或者绿，但是**可以填红**。

可能会有人问：如果填和前面相同的颜色不会出现更长的回文串吗？

不会。因为我们在上面已经保证了不会存在长度为 $2$ 或 $3$ 的回文串，所以更长的更不可能存在。

计算答案：第一个可以选 $k$ 种颜色，第二个可以选 $k-1$ 种，剩下 $l-2$ 个都是 $k-2$ 种，答案就是 $k(k-1)(k-2)^{l-2}$。

如果加上了限制呢？可以这么理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/a81ji2gf.png)

假如第 $i$ 个位置已经规定是红色，我们可以先往后填，填第 $i+1$ 个位置，显然有 $k-1$ 种方案，再往后填就不难发现等价于没有限制的情况。这一部分的答案数是 $(k-1)(k-2)^{l-i-1}$。

然后往前填。

![](https://cdn.luogu.com.cn/upload/image_hosting/haixr6y7.png)

不难发现，第 $i-1$ 个位置填颜色的时候，因为第 $i$ 个和第 $i+1$ 个都已经填好了，所以它只有 $k-2$ 种填法。第 $i-2$ 个位置填颜色的时候，因为第 $i-1$ 个和第 $i$ 个都已经填好了，所以它也只有 $k-2$ 种填法。以此类推，当第 $j$ 个位置填色的时候，因为第 $j+1$ 个和第 $j+2$ 个都已经填好了，所以它只有 $k-2$ 种填法。由乘法原理，这一部分的答案是 $(k-2)^{i-1}$ 种。

两个答案相乘，得答案为 $(k-1)(k-2)^{l-2}$。

### Code

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int l,k,s,mod;
long long ans;
long long qpow(long long a,long long b){
	long long res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
int m,n;
signed main(){
	scanf("%lld%lld%lld%lld",&k,&l,&mod,&s);
	k%=mod;
	m=((k-1)%mod+mod)%mod;
	n=((k-2)%mod+mod)%mod;
	if(s)printf("%lld",1ll*m*qpow(n,l-2)%mod);
	else printf("%lld",1ll*(k*m%mod)*(qpow(n,l-2)%mod)%mod);
	return 0;
}

```

### Tip

1. 题目输入是 $5$ 个数，为什么只输入了 $4$ 个？

我们发现各个字符之间是等价的，所以是第几种并没有必要知道，$w$ 也就可有可无了。

输入 $4$ 个是评测的特性：如果实际程序输入数比给定输入数少，会优先选择靠前的输入。变式一下，如果 $w$ 在 $s$ 之前输入，便不能省略了。也就是虽然输入文件中给定了 $w$，但是我们没有选择要它。

2. 为什么 `#define int long long` 和 `signed main`？

这道题不用这句话会获得 $50$ 分。这句话的作用是把所有 `int` 型变量定义成 `long long` 型，防止爆 `int`。

但是这句话也有副作用。`int main()` 不能定义成 `long long main()`。并且有些时候程序会因此 MLE 或 WA 等。所以不到万不得已不要用这个。

3. 为什么有 `m=((k-1)%mod+mod)%mod;` 和 `n=((k-2)%mod+mod)%mod;`？

C++ 中，负数取模是负数。如果这题 $k$ 为 $0$，则 $k-1$ 就是负数，会出错，所以把它单独拿出来。

---

## 作者：lihongqian__int128 (赞：0)

# P4925 [1007] Scarlet的字符串不可能这么可爱 题解
赛场上推出来了，但没写对的题。

首先，如果 Scarlet 十分良心地没有添加限制，则第 $1$ 个字符有 $k$ 种选择，第 $2$ 个字符有 $k-1$ 种选择（不与第 $1$ 位相同），其它位有 $k-2$ 种选择（除去它前两个字符的颜色），共 $k\times(k-1)\times(k-2)^{L-2}$ 种填的方式。

如果 Scarlet 添加了限制，则将第 $s$ 位提至第 $1$ 位，依上，只是第 $1$ 位只有 $1$ 种情况而已，共 $(k-1)\times(k-2)^{L-2}$ 种填的方式。

注意使用快速幂加速（不会快速幂的请左转至[【模板】快速幂](https://www.luogu.com.cn/problem/P1226)）。

$\mathbb{CODE}$：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std ;
int k , l , p , s , w , ans ;
int fast_pow(int a , int b)//快速幂
{
	int s = 1 ;
	while(b)
	{
		if(b & 1)	s = (s * a) % p ;
		a = (a * a) % p ;
		b >>= 1 ;
	}
	return s ;
}
signed main()
{
	cin >> k >> l >> p >> s >> w ;
	k %= p ;//先模，否则会爆long long
	if(l == 1)//特判长度为1的情况
	{
	    cout << (s == 1 ? 1 : k) ;
	    return 0 ;
	}
	ans = fast_pow(k - 2 , l - 2) * (k - 1) % p ;
	cout << (s == 0 ? (ans * k) % p : ans) ;
	return 0 ;
}
```

---


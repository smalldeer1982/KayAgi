# [蓝桥杯 2023 国 Python A] 2023

## 题目背景

建议使用 PyPy3 提交本题。

## 题目描述

给定 $n, m$，请求出所有 $n$ 位十进制整数中有多少个数中恰好出现了 $m$ 个 $2023$。

例如 $00202312023$ 是一个 $11$ 位的出现了 $2$ 个 $2023$ 的十进制整数。

由于结果可能很大，请输出答案对 $998,244,353$ 取模的结果。




## 说明/提示

对于 $40\%$ 的评测用例，$n \le 10^5,m \le 10$；

对于所有评测用例，$4 \le n \le 10^5,0 \le 4m \le n$。

## 样例 #1

### 输入

```
5 1```

### 输出

```
20```

# 题解

## 作者：COsm0s (赞：5)

[二项式反演。](https://zhuanlan.zhihu.com/p/602675596)

题目里有“恰好”的标志，套路的，我们可以将它转化为至多/至少后再容斥回来。

当我们已经确定 $k$ 个 $2023$ 固定在这个数中时，我们发现，剩余的 $n-4k$ 个数就可以随便选——前提是不能有 $2023$。

也就是说，在剩余的数随便选时，我们可能会**多选**若干个 $2023$。

很容易想到这可以转化成“至少”的形式。

那么问题就转化成了两部分：

+ 随便选剩余的数。

+ 由“至少”推向“恰好”。

我们先来看第一部分。

当确定 $k$ 个 $2023$ 时，我们有 $k+1$ 个空可以插入那些随便选的数字。

举个例子：

`x2023x2023x2023x`

其中 `x` 代表的是一堆随便选的数字。

这是个经典的隔板法，讲这些数字分到 $k+1$ 个空的方案数为 ：
$$\binom{(p-4k)+(k+1)-1}{(k+1)-1}$$

又因为题目明示了我们前导零的合法，所以再乘上每个数都有的 $0\sim 9$ 的 $10$ 种方案数，即为随便选的数的方案。

第二部分，直接套公式即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 1e6 + 5, N = 5e5 + 5, mod = 998244353;
int qpow(int b, int p) {
	int res = 1;
	while (p) {
		if (p & 1) {
			res = res * b % mod;
		}
		b = b * b % mod;
		p >>= 1;
	}
	return res;
}

int n, k, fac[maxn], ifac[maxn], g[N];

inline void init() {
	fac[0] = 1;
	for (int i = 1; i <= N; i ++) {
		fac[i] = fac[i - 1] * i % mod;
	}
	ifac[N] = qpow(fac[N], mod - 2);
	for (int i = N - 1; ~i; i --) {
		ifac[i] = ifac[i + 1] * (i + 1) % mod;
	}
}

inline int C(int n, int m) {
	if (n < m || n < 0 || m < 0) {
		return 0;
	} else {
		return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
	}
}
signed main() {
	cin >> n >> k, init();
	for(int m = k; m <= n / 4; m ++) {
		int p = n - 4 * m;
		g[m] = C(p + m, m) * qpow(10, p) % mod;
	}
	int ans = 0;
	for(int i = n / 4; i >= k; i --) {
		if(i - k & 1) ans = (ans - C(i, k) * g[i] % mod + mod) % mod;
		else ans = (ans + C(i, k) * g[i] % mod) % mod;
	}
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：LogicLiu (赞：4)

前情提要：这是一篇瞎搞题解，想看组合数学/二项式反演的解法还是看别的叭。
****
前置知识：KMP、NTT

题目要求我们计算，给定 $n$ 位十进制数中，恰好包含 $𝑚$ 次子串 $2023$ 的数的个数。由于结果可能很大，我们需要对答案取模 $998244353$。

那我们有一个很~~逆天~~自然的解法——计算数字序列中不含 $2023$ 的方案数。

我们可以利用 KMP 来避免自己在构造不含 $2023$。

然后进行动态规划。

定义 $dp_{len,s}$ 表示长度为 $len$ 且处于状态 $s$ 的合法序列数，其中 $s$ 表示在有限状态自动机中的状态,有转移：

$$dp_{len,s}=\sum_{d=0}^{9}dp_{len-1,t}$$

其中：

$$t=nxt_{s,d}$$

定义生成函数 $F(x)$ 表示长度为 $x$ 的数字序列中不包含 $2023$ 的方案数，记为：

$$F(x)=\sum_{k=0}^{\infty}x^k\sum_{s=0}^{3}dp_{k,s}$$

定义 $R$ 为选去 $2023$ 后的剩余位置，易见：

$$R=n-4m$$

然后，剩余数字分布在 $m+1$ 个区间中，每个区间内的数字序列均不能包含 $2023$，其方案数由生成函数 $F(x)$ 给出，其  $F(x)$ 表示长度为 $x$ 的合法数字序列数。

对于 $R<0$ 的情况直接输出 $0$ 即可。对于 $m=0$ 直接输出预处理后的 $F(n)$ 即可。

接下来着重讲对于 $m>0$ 的情况：

由于整体方案数是 $m+1$ 个区间的数字序列组合，即等价于多项式 $F^{m+1}$，答案为该多项式中 $x^R$ 项的系数。由于题目仅要求我们求第 $R$ 项的系数，在实现中可以仅保留 $R$ 项。

考虑多项式快速幂，由于 $n\leq 10^5$ 较大。考虑使用 NTT 优化多项式乘法。

然后多项式快速幂调用即可。能够通过此题。

代码见下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
int qpow (int a, int b) {
    int res = 1;
    while(b > 0){
        if(b & 1)
            res = (int)((1LL * res * a) % mod);
        a = (int)((1LL * a * a) % mod);
        b >>= 1;
    }
    return res;
}
void ntt(vector<int> & a, bool inv) {
    int n = a.size();
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j -= bit;
        j += bit;
        if (i < j)
            swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        int wlen = qpow(3, (mod - 1) / len);
        if (inv)
            wlen = qpow(wlen, mod - 2); 
        for (int i = 0; i < n; i += len) {
            int w = 1;
            for (int j = 0; j < len/2; j++) {
                int u = a[i+j];
                int v = (int)((1LL * a[i+j+len/2] * w) % mod);
                a[i+j] = u + v < mod ? u + v : u + v - mod;
                a[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;
                w = (int)((1LL * w * wlen) % mod);
            }
        }
    }
    if (inv) {
        int n_inv = qpow(n, mod - 2);
        for (int & x : a)
            x = (int)((1LL * x * n_inv) % mod);
    }
}
vector<int> poly_mul(const vector<int>& a, const vector<int>& b, int rLimit) {
    int n = a.size(), m = b.size();
    int sz = 1;
    while (sz < n + m - 1)
        sz *= 2;
    vector<int> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    fa.resize(sz);
    fb.resize(sz);
    ntt(fa, false);
    ntt(fb, false);
    for (int i = 0; i < sz; i++) {
        fa[i] = (int)((1LL * fa[i] * fb[i]) % mod);
    }
    ntt(fa, true);
    int newSize = min((int)(n + m - 1), rLimit + 1);
    fa.resize(newSize);
    return fa;
}
vector<int> poly_pow(vector<int> poly, int b, int rLimit) {
    vector<int> result(1, 1); 
    while(b > 0) {
        if(b & 1)
            result = poly_mul(result, poly, rLimit);
        poly = poly_mul(poly, poly, rLimit);
        b >>= 1;
    }
    return result;
}
void kmp(vector<vector<int>> &nxt) {
    string pat = "2023";
    int M = pat.size();
    vector<int> pi(M, 0);
    for (int i = 1; i < M; i++) {
        int j = pi[i-1];
        while(j > 0 && pat[i] != pat[j])
            j = pi[j-1];
        if(pat[i] == pat[j])
            j++;
        pi[i] = j;
    }
    nxt.assign(M, vector<int>(10, 0));
    for (int s = 0; s < M; s++) {
        for (int d = 0; d < 10; d++) {
            char c = '0' + d;
            int x = s;
            while(x > 0 && pat[x] != c)
                x = pi[x-1];
            if(pat[x] == c)
                x++;
            if(x == M) {
                nxt[s][d] = -1;
            } else {
                nxt[s][d] = x;
            }
        }
    }
}
vector<int> computeF(int L_max) {
    int M = 4;
    vector<vector<int>> nxt;
    kmp(nxt);
    vector<vector<int>> dp(L_max+1, vector<int>(M, 0));
    dp[0][0] = 1;
    vector<int> F(L_max+1, 0);
    F[0] = 1;
    for (int len = 0; len < L_max; len++) {
        for (int s = 0; s < M; s++) {
            if (dp[len][s] == 0) continue;
            for (int d = 0; d < 10; d++) {
                int ns = nxt[s][d];
                if (ns == -1)
                    continue;
                dp[len+1][ns] = (dp[len+1][ns] + dp[len][s]) % mod;
            }
        }
        int sum = 0;
        for (int s = 0; s < M; s++)
            sum = (sum + dp[len+1][s]) % mod;
        F[len+1] = sum;
    }
    return F;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin >> n >> m;
    if(4 * m > n) {
        cout << 0 << "\n";
        return 0;
    }
    if(m == 0) {
        vector<int> F = computeF(n);
        cout << F[n] % mod << "\n";
        return 0;
    }
    int R = n - 4 * m;
    vector<int> F = computeF(R);
    vector<int> polyPow = poly_pow(F, m + 1, R);
    int ans = 0;
	ans = polyPow[R];
    cout << ans % mod << "\n";
    return 0;
}
```

---

## 作者：qzmoot (赞：3)

# 题解：P10986 [蓝桥杯 2023 国 Python A] 2023
## 题目大意
给你一个位数 $n$，询问有多少搁长度为 $n$ 的数中恰好有 $m$ 个 $2023$。可以有前导零。
## 分析
首先我们的思路很简单，假设不考虑是恰好，而是至少，我们会列出什么式子。我们把每个 $2023$ 捆绑在一起，然后进行插板法，根据公式可以得到如果是至少有 $m$ 个的话，

$F(m)=10^{n-4\times m}\times \binom{n-4\times m+m+1-1}{m+1-1}=10^{n-4\times m}\times\binom{n-3\times m}{m}$

乘上 $10^{n-4\times m}$ 是因为不需要考虑前导零的存在。

求出至少之后，我们思考这么求恰好为 $m$，容斥的思想就呼之欲出了。不难写出式子就是：

$\sum_{i=m}^{\frac{n}{4}} (-1)^{i-m}\times \binom{i}{m}\times F(i)$

这里的 $\frac{n}{4}$ 为上界是因为 $2023$ 有四位，所以最多只有 $\frac{n}{4}$ 个。然后你就会发现上面这玩意其实就是二项式反演，会背是是啥公式就行了。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5,mod=998244353; 
int n,m;
int fs[N],inv[N];
int qpow(int a,int b)//快速幂 
{
	int res=1;
	while(b)
	{
		if(b&1)
			res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
int C(int nn,int mm)//组合数 
{
	if(mm>nn || nn<0 || mm<0)
		return 0;
	return fs[nn]*inv[mm]%mod*inv[nn-mm]%mod;
}
int F(int x)//算至少为m的函数 
{
	return qpow(10,n-4*x)*C(n-3*x,x)%mod;
}
int ans;
signed main()
{
	scanf("%lld%lld",&n,&m);
	fs[0]=inv[0]=1;//预处理逆元 
	for(int i=1;i<=N-5;i++)
		fs[i]=fs[i-1]*i%mod;
	for(int i=1;i<=N-5;i++)
		inv[i]=qpow(fs[i],mod-2);//我懒得写线性，所以写了nlogn的版本 
	for(int i=m;i<=n/4;i++)
		ans=(ans+(((i-m)&1)?-1:1)*C(i,m)*F(i)%mod+mod)%mod;//套式子 
	printf("%lld",ans);
	return 0;
}
```
那么这道题目就很简单地完成了呢，个人感觉是有蓝的难度了。

---

## 作者：ZZA000HAH (赞：1)

# [蓝桥杯 2023] 2023

## 题目分析

### 题目大意

给出两个正整数 $n,m$，求在 $n$ 位十进制数中恰好有 $m$ 个 $2023$ 的数字个数，允许含有前导零。

### 题目思路

使用**二项式反演**将问题转化为计算至少出现 $k$ 个 $2023$ 的方案数，然后通过**容斥原理**得到恰好出现 $m$ 个的方案数。

**组合计数**：

1. 在 $n$ 位中选出 $k$ 个 $2023$ 可以通过确定首位置的方式来确定 $2023$ 的位置，则转化成在 $n-3k$ 个数里选出 $k$ 个数；
2. 选出 $k$ 个 $2023$，则剩余 $n-4k$ 位，由于允许前导零存在，故每一位都可以填 $0-9$ 的任何数字，故剩余项方案数为 $10^{n-4k}$。

综上所述，在 $n$ 位十进制数中至少出现 $k$ 个 $2023$ 的方案数为 $g(k)={n-3k\choose k}\times 10^{n-4k}$。

也可以使用**隔板法**来得出：

1. 有 $k$ 个 $2023$ 作为隔板，则有 $k+1$ 个可摆放的位置；
2. 有 $n-4k$ 个“位”的自由位置。

使用隔板法：将 $n-4k$ 个自由位置分配到 $k+1$ 个位置上，相当于解方程：
$$x_1+x_2+x_3+......+x_{k+1}=n-4k,x_i \ge 0$$
令 $y_i=x_i+1$，则
$$y_1+y_2+y_3+......+y_{k+1}=n-4k+k+1,y_i \ge 1$$
相当于在 $n-4k+k+1=n-3k+1$ 之间放 $k$ 个隔板（形成 $k+1$ 个间隙），因为 $y_i \ge 1$，所以有 $n-3k$ 个可放隔板的间隙，所以方案数为 ${n-3k\choose k}$。


**容斥原理**：

令 $A_i$ 为至少存在 $i$ 个，$B_i$ 为恰好存在 $i$ 个，最多存在 $n$ 个，容斥原理则为 $A_1=B_1-B_2+B_3-B_4+......+(-1)^{n-1} \times B_n$ 也就是 $A_1=\sum_{i=1}^{n} (-1)^{n-1} \times B_i$。

**二项式反演**：

**令**：
1. $f(k)$：恰好出现 $k$ 个 $2023$ 的 $n$ 位数字串的个数。
2. $g(k)$：至少出现 $k$ 个 $2023$ 的 $n$ 位数字串的个数（指定 $k$ 个位置）。

则存在**基本关系**：
$$g(k)=\sum_{i=k}^{\lfloor n/4\rfloor} {i \choose k} \times f(i)$$

解释：若一个数字串实际有 $i$ 个 $2023$（$i \geq k$），选择其中任意 $k$ 个位置作为指定位置，则共有 $\binom{i}{k}$ 种选择方式，因此 $f(i)$ 会被计入 $g(k)$ 中 $\binom{i}{k}$ 次。

**二项式反演定理**：
$$f(n)=\sum_{i=0}^{n} {n \choose i} g(i)\Leftrightarrow g(n)=\sum_{i=0}^{n} (-1)^{n-i} {n \choose i} f(i)$$

**变体**：
$$f(n)=\sum_{i=n}^{m} {i \choose n} g(i)\Leftrightarrow g(n)=\sum_{i=n}^{m} (-1)^{i-n} {i \choose n} f(i)$$

**故可得出**：
$$f(k)=\sum_{i=k}^{\lfloor n/4\rfloor} (-1)^{i-k} {i\choose k} g(i)$$

其中，$g(i)$ 的计算在上述**组合计数**中。

**最终公式**：
$$f(m)=\sum_{k=m}^{K} (-1)^{k-m} \times {k\choose m} \times g(k)$$
其中 $K=\lfloor n/4\rfloor$ 即 $n$ 位十进制数中最大的 $2023$ 可能出现的个数，$g(k)={n-3k\choose k}\times 10^{n-4k}$ 即 $n$ 位十进制数中至少出现 $k$ 个 $2023$ 的数字个数。

## 知识总结

### 数学知识

1. 二项式定理
2. 二项式反演
3. 容斥原理
4. 组合数学概念、表示及公式
5. 乘法原理
6. 逆元概念
7. 费马小定理
8. 模运算公式

### 算法知识

1. 快速幂求逆元
2. 求组合数（阶乘与逆元）

## 算法实现

**预处理**：
1. $fact_i$ 存储阶乘
2. $infact_i$ 存储阶乘的逆元
3. $pow10_i$ 存储 $10$ 的幂
4. 使用快速幂求逆元

**主函数循环**：
1. 遍历可能的 $2023$ 的个数 $k$（从 $m$ 到 $\lfloor n/4 \rfloor$）；
2. 计算 $g(k)={n-3k\choose k}\times 10^{n-4k}$；
3. 计算二项式系数 ${k \choose m}$；
4. 根据容斥原理调整正反 $(-1)^{k-m}$；
5. 累计到 $ans$ 最终答案，**注意**：由于容斥原理会加会减，且模运算会改变数的实际大小，为防止出现负数，在模运算之前加上模数，```ans=(ans+(long long)c_1*c_2*sign+mod)%mod```。

时间复杂度 $\mathcal{O}(n)$，空间复杂度 $\mathcal{O}(n)$。

### AC Code。

```cpp line-numbers
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10,mod = 998244353;
typedef long long ll;
int fact[N],infact[N],pow10[N];//fact[i]--i 的阶乘,infact[i]--i 的阶乘逆元,pow10[i]--10 的 i 次幂
int qmi(int a,int k)//快速幂求逆元
{
	int res=1;
	while (k)
	{
		if (k&1) res=(ll)res*a%mod;
		a=(ll)a*a%mod;
		k>>=1;
	}
	return res;
}
void init(int n)
{
	fact[0]=infact[0]=pow10[0]=1;//初始化
	for (int i=1;i<=n;i++)
	{
		fact[i]=(ll)fact[i-1]*i%mod;//阶乘计算
		pow10[i]=(ll)pow10[i-1]*10%mod;//10 的幂计算
	}
	infact[n]=qmi(fact[n],mod-2);
	for (int i=n-1;i>=1;i--)
		infact[i]=(ll)infact[i+1]*(i+1)%mod;//阶乘逆元计算
}
int main()
{
	int n,m,ans=0,sign=-1;
	scanf("%d%d",&n,&m);
	init(n);
	for (int i=m;i<=n/4;i++)
	{
		sign*=-1;
		int a=n-i*3;
		int c1=(ll)fact[a]*infact[i]%mod*infact[a-i]%mod*pow10[n-4*i]%mod;
		int c2=(ll)fact[i]*infact[m]%mod*infact[i-m]%mod;
		ans=(ans+(ll)c1*c2*sign+mod)%mod;//sign 有时为 -1,由于模运算,要加 mod,在模 mod,以防为负数
	}
	printf("%d",ans);
	return 0;
}
```
##### End。

---

## 作者：tder (赞：1)

You can view the [English version](https://www.luogu.com/article/9534zlpn/) of this solution.

考虑容斥。

令 $f(x)$ 为至少有 $x$ 个子串 $\tt2023$ 的方案数，由二项式反演，恰好有 $m$ 个子串 $\tt2023$ 的方案数为：

$$
\text{ans}=\sum_x(-1)^{x-m}\binom xm f(x)
$$

考虑 $f(x)$ 即为钦定了 $x$ 个 $\tt2023$，在间隔的 $x+1$ 个位置中插入剩下的 $n-4x$ 个数，每个数取 $0\sim 9$。因此，由插板法：

$$
f(x)=10^{n-4x}\binom{(n-4x)+(x+1)-1}{(x+1)-1}
$$

时间复杂度 $\mathcal{O}(n)$。

---

```python
N = int(1e6 + 5)
M = 998244353
f = [0 for _ in range(N)]
v = [0 for _ in range(N)]
def qpow(x : int, y : int) -> int: 
	r = 1
	while y > 0:
		# print(r, y, x)
		if y % 2:
			r *= x
			r %= M
		y //= 2
		x *= x
		x %= M
	return r
def init() -> None:
	f[0] = 1
	for i in range(1, N - 5 + 1):
		f[i] = f[i - 1] * i % M
	# print(f)
	v[N - 5] = qpow(f[N - 5], M - 2)
	# print(v[N - 5])
	for i in range(N - 5 - 1, 0 - 1, -1):
		v[i] = v[i + 1] * (i + 1) % M
	# print(v, v[0], v[1], v[2])
def get(a : int, b : int) -> int:
	if a < b:
		return 0
	else:
		# print("get", a, b, (f[a] * v[b] % M) * v[a - b] % M, f[a], v[b])
		return (f[a] * v[b] % M) * v[a - b] % M
def work(x : int) -> int: 
	return get(n - 4 * x + x, x) * qpow(10, n - 4 * x) % M
init()
line = list(map(int, input().split()))
n = line[0]
m = line[1]
ans = 0
for i in range(n // 4, m - 1, -1):
	ans += qpow(-1, i - m) * get(i, m) * work(i) % M
	ans %= M
print(ans)
```

---

## 作者：Engulf (赞：0)

题意：长为 $n$ 的数组，每一项可以取 $[0, 9]$ 的整数，求恰好有 $m$ 个 $2023$ 的数组数。

恰好 $m$ 个不好求，考虑二项式反演，套路地设
- $g(k)$ 表示恰好 $m$ 个 $2023$ 的数组数；
- $f(k)$ 表示钦定 $m$ 个 $2023$ 的数组数。

$$f(k) = \sum_{i = k}^{\lfloor \frac{n}{4} \rfloor}\binom{i}{k}g(i) \Longleftrightarrow g(k) = \sum_{i = k}^{\lfloor \frac{n}{4} \rfloor}\binom{i}{k}(-1)^{i-k}f(i)$$

问题转化为求 $f$。

钦定了 $i$ 个 $2023$ 后，剩下 $n-4i$ 个数，要插入这些 $2023$ 之间，考虑球盒模型，把 $n - 4i$ 个球放入 $i + 1$ 个盒子中，可空，求方案数。这是经典问题，使用插板法可得方案数为

$$\binom{n - 4i + 1 + i - 1}{i + 1 - 1} = \binom{n - 3i}{i}$$

放完之后，每个数可以取 $[0, 9]$，有 $10^{n-4i}$ 种取法，根据乘法原理，可得

$$f(k) = 10^{n-4i}\binom{n-3i}{i}$$

答案为

$$g(m) = \sum_{i = m}^{\lfloor \frac{n}{4} \rfloor}\binom{i}{m}(-1)^{i-m}f(i) = \sum_{i = m}^{\lfloor \frac{n}{4} \rfloor}\binom{i}{m}(-1)^{i-m}10^{n-4i}\binom{n-3i}{i}$$

$\Theta(n)$。

---

## 作者：TLE_Automat (赞：0)

令 $g_i$ 代表恰好有 $i$ 个 $2023$ 时的总方案数，$M = \lfloor\frac{n}{4}\rfloor$。

当我们遇到这种“恰好有多少个满足某个条件”的计数时，第一步大致有三种思考方向。

- 第一种就是直接计算 $g_m$。

- 第二种是考虑 $h_i = \sum\limits_{j \ge i} g_j$ 是否好算，然后用 $h_m - h_{m + 1}$ 就是答案。
- 第三种是考虑 $f_i = \sum\limits_{j \le i}^{}\binom{i}{j}g_{j}$ 或者 $f_i = \sum\limits_{j \ge i}\binom{j}{i}g_{j}$ 是否好算，然后用二项式反演求出 $g_m$。

对于此题来说，第一种方法并不好用，考虑第二种和第三种。

如果我们钦定当前至少选 $i$ 个 $2023$，那么我们可以想到一种 naive 的统计方法，先固定这 $i$ 个 $2023$，然后剩下 $n - 4i$ 个 数字插到 $i + 1$ 个空里，每个空允许空，并且这些数字的值随便取，那么我们有
$$
10^{n - 4i}\operatorname{calc}(n - 4i, i + 1)
$$
种方案，其中 $\operatorname{calc}(x, y) = \binom{x + y - 1}{y - 1}$。

那么我们现在遇到了一个问题，**这个值到底是 $h_i$ 还是 $f_i$ 或者两个都不是。**

考虑 $g_j(j \ge i)$ 中的一种方案（即 $2023$ 恰好出现了 $j$ 次的一种方案）， 它在当前 $i$ 的统计中会被重复统计 $\binom{j}{i}$ 次。

考虑这是为什么，因为可以把这 $j$ 个 $2023$ 中的 $i$ 个 $2023$ 看作是一开始就放好的，剩下的数字看作是插进来的，这样每一种都会被统计一次，总共会被重复统计 $\binom{j}{i}$​ 次。

所以这个式子代表的含义就是
$$
f_i = \sum\limits_{j = i}^{M}\binom{j}{i}g_{j} = 10^{n - 4i}\operatorname{calc}(n - 4i, i + 1)
$$
使用二项式反演，即可得到
$$
g_m = \sum\limits_{i = m}^{M} (-1)^{i - m}\binom{i}{m}f(i)
$$
时间复杂度 $O(n)$。

---


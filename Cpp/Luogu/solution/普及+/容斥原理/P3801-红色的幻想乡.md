# 红色的幻想乡

## 题目背景

蕾米莉亚的红雾异变失败后，很不甘心。


## 题目描述

经过上次失败后，蕾米莉亚决定再次发动红雾异变，但为了防止被灵梦退治，她决定将红雾以奇怪的阵势释放。

我们将幻想乡看做是一个 $n \times m$的方格地区，一开始没有任何一个地区被红雾遮盖。蕾米莉亚每次站在某一个地区上，向东南西北四个方向各发出一条无限长的红雾，可以影响到整行/整列，但不会影响到她所站的那个地区。如果两阵红雾碰撞，则会因为密度过大而沉降消失。灵梦察觉到了这次异变，决定去解决它。但在解决之前，灵梦想要了解一片范围红雾的密度。可以简述为两种操作:

``1 x y`` 蕾米莉亚站在坐标 $(x,y)$ 的位置向四个方向释放无限长的红雾。

``2 x1 y1 x2 y2`` 询问左上点为$(x1,y1)$，右下点为 $(x2,y2)$ 的矩形范围内，被红雾遮盖的地区的数量。


## 说明/提示

#### 样例输入输出 1 解释

用``o``表示没有红雾，``x``表示有红雾，两次释放红雾后幻想乡地图如下:

```
oxox
xoxo
oxox
xoxo
```

---

#### 数据规模与约定

- 对于 $20\%$ 的数据，$1 \le n,m,q \le 200$。
- 对于 $40\%$ 的数据，$1 \le n,m,q \le 10^3$。
- 对于 $100\%$ 的数据，$1 \le n,m,q \le 10^5$，$1 \le x_1,x_2,x \le n$，$x_1 \le x_2$，$1 \le y_1,y_2,y \le m$，$y_1 \le y_2$。

## 样例 #1

### 输入

```
4 4 3
1 2 2
1 4 4
2 1 1 4 4
```

### 输出

```
8```

# 题解

## 作者：Hurricane、 (赞：41)



1<=n,m<=100000……二维线段树废了。

然而再看看这个题，起始点没有红雾，就像：

![1ge](http://img.blog.csdn.net/20180111160236988?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDEyNTI4OTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


两个重复的会抵消，便是这样：

![这里写图片描述](http://img.blog.csdn.net/20180111160907273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDEyNTI4OTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


那么，站的位置可否当做抵消掉的呢？

上边图中的红雾数量，可以是：

放过的行数×行长度+放过的列数×列长度-抵消块数

行、列的长度就是题中m，n，抵消块数呢？


在算行列时，每一个交叉点是记了两次的。图中有多少交叉点呢？记放过的行数x，放过的列数y，每行每列交叉1个，抵消块数就是2xy。


到现在，求出x，y就拥有了一切！


行列有多少？区间求和。每次放红雾？单点修改。标准线段树。

当站在放过的那行（列）上时，整一行就消了。在上图中，假设在 ( 4 , 3 )点放一次，变成：

![这里写图片描述](http://img.blog.csdn.net/20180111163304494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDEyNTI4OTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

站的那点本来就红，放一下不影响。而原来白的变红了，不就是没放那一行吗！

若是站在以前站过的点上，同样的道理。


修改时直接异或，0改11改0完事。


```cpp
#include<iostream>
#include<cstdio>
#define now int l,int r,int num
#define ls l,l+r>>1,num<<1
#define rs (l+r>>1)+1,r,num<<1|1
using namespace std;
int y[262150],x[262150];
int x1,y1,x2,y2;
int n,m,q;
void update(int *a,int num){
    a[num]=a[num<<1]+a[num<<1|1];
    }
void change(int *a,int p,now){
    if(l==r){
        a[num]^=1;
        return;
        }
    int mid=l+r>>1;
    if(p<=mid)change(a,p,ls);
    else change(a,p,rs);
    update(a,num);
    }

int que(int *a,int al,int ar,now){
    if(al<=l&&r<=ar)
        return a[num];
    int mid=l+r>>1,ans=0;
    if(al<=mid)ans+=que(a,al,ar,ls);
    if(mid<ar)ans+=que(a,al,ar,rs);
    return ans;
    }
int main(){
    scanf("%d%d%d",&n,&m,&q);
    while(q--){
        int cmd;
        scanf("%d",&cmd);
        if(cmd==1){
            int x0,y0;
            scanf("%d%d",&x0,&y0);
            change(x,x0,1,n,1);
            change(y,y0,1,m,1);
            }
        else{
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            long long xx=que(x,x1,x2,1,n,1),
                      yy=que(y,y1,y2,1,m,1);
            printf("%lld\n",xx*(long long)(y2-y1+1)+
                    yy*(long long)(x2-x1+1)-
                    (long long)(xx*yy<<1));
            }
        }
    return 0;
    }
```
懒得复制一遍再改了，直接传数组指针。

记得开long long！十万×十万爆int了！


---

## 作者：C_Zn (赞：20)

这个题呢就是一个线段树+容斥原理的题，~~二维线段树我也不会~~这个题就是用两个线段树，一颗线段树就是求有多少列被修改过，另一颗线段树就是求有多少行被修改过，每次修改就是将他所在的行和列都修改一下，当询问的时候就询问x1到x2的和与y1到y2的和然后进行容斥原理，就可以得到答案了，以下是代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

struct node
{
    int l,r;
    int sum;
}t1[100001<<6],t2[100001<<6];

void pushup1(int tr)
{
    t1[tr].sum=t1[tr<<1].sum+t1[tr<<1|1].sum;
    return;
}

void build1(int l,int r,int tr)
{
    t1[tr].l=l;
    t1[tr].r=r;
    if(l==r)
    {
        t1[tr].sum=0;
        return;
    }
    int mid=l+r>>1;
    build1(l,mid,tr<<1);
    build1(mid+1,r,tr<<1|1);
    pushup1(tr);
    return;
}

void change1(int l,int r,int tr)
{
    if(t1[tr].l==t1[tr].r)
    {
        t1[tr].sum^=1;
        return;
    }
    int mid=t1[tr].l+t1[tr].r>>1;
    if(l<=mid)change1(l,r,tr<<1);
    else change1(l,r,tr<<1|1);
    pushup1(tr);
    return;
} 

int query1(int l,int r,int tr)
{
    if(t1[tr].l>=l&&r>=t1[tr].r)
    {
        return t1[tr].sum;
    }
    int ret=0,mid=t1[tr].l+t1[tr].r>>1;
    if(l<=mid)ret+=query1(l,r,tr<<1); 
    if(mid<r)ret+=query1(l,r,tr<<1|1);
    return ret;
}

void pushup2(int tr)
{
    t2[tr].sum=t2[tr<<1].sum+t2[tr<<1|1].sum;
    return;
}

void build2(int l,int r,int tr)
{
    t2[tr].l=l;
    t2[tr].r=r;
    if(l==r)
    {
        t2[tr].sum=0;
        return;
    }
    int mid=l+r>>1;
    build2(l,mid,tr<<1);
    build2(mid+1,r,tr<<1|1);
    pushup2(tr);
    return;
}

void change2(int l,int r,int tr)
{
    if(t2[tr].l==t2[tr].r)
    {
        t2[tr].sum^=1;
        return;
    }
    int mid=t2[tr].l+t2[tr].r>>1;
    if(l<=mid)change2(l,r,tr<<1);
    else change2(l,r,tr<<1|1);
    pushup2(tr);
    return;
} 

int query2(int l,int r,int tr)
{
    if(t2[tr].l>=l&&r>=t2[tr].r)
    {
        return t2[tr].sum;
    }
    int ret=0,mid=t2[tr].l+t2[tr].r>>1;
    if(l<=mid)ret+=query2(l,r,tr<<1); 
    if(mid<r)ret+=query2(l,r,tr<<1|1);
    return ret;
}
int main()
{
    long long n,m,q;
    cin>>n>>m>>q;
    build1(1,n,1);
    build2(1,m,1);
    for(int i=1;i<=q;i++)
    {
        int zb;
        scanf("%d",&zb);
        if(zb==1)
        {
            long long x,y;
            cin>>x>>y;
            //scanf("%d%d",&x,&y);
            change1(x,x,1);
            change2(y,y,1);
        }
        else
        {
            long long x1,x2,y1,y2;
            cin>>x1>>y1>>x2>>y2;
            //scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            long long a1,a2;
            a1=query1(x1,x2,1);
            a2=query2(y1,y2,1);
            cout<<a1*(long long)(y2-y1+1)+a2*(long long)(x2-x1+1)-(long long)(a1*a2<<1)<<endl;
        }
    }
}
```


这个线段树看起来很易懂，求过

---

## 作者：ChthollyTree (赞：17)

楼上已经说得很明白了，这里提供树状数组的做法。

这里维护两个树状数组（一横一竖）对于区间红雾数量。

同时单点也要存

最后用一下容斥，注意要开long long(10^5 \* 10^5 > 2^31 - 1)






    



```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100005
int n,m,q;
int dx[MAXN],dy[MAXN];//两个树状数组 
int ax[MAXN],ay[MAXN];//单点的存放（方便修改）
int lowbit(int x)
{
    return x&(x^(x-1));
}
void gai(int *c,int x,int y)//单点修改 
{
    while(x <= *c)
    {
        *(c+x) += y;
        x += lowbit(x);
    }
}
int qiu(int *c,int x)//区间求值 
{
    int ans = 0;
    while(x >= 1)
    {
        ans += *(c+x);
        x -= lowbit(x);    
    }    
    return ans;
}
void huan(int x,int y) 
{
    if(ax[x] == 1)
    {
        ax[x] = 0;
        gai(dx,x,-1);
    }
    else
    {
        ax[x] = 1;
        gai(dx,x,1);
    }
    if(ay[y] == 1)
    {
        ay[y] = 0;
        gai(dy,y,-1); 
    }
    else
    {
        ay[y] = 1;
        gai(dy,y,1);
    }
}
long long suan(int x1,int y1,int x2,int y2)//计算有红雾的地方 
{
    int s1 = qiu(dx,x2) - qiu(dx,x1 - 1);
    int s2 = qiu(dy,y2) - qiu(dy,y1 - 1);
    long long ans = (long long)s1*(y2-y1+1) + (long long)s2*(x2-x1+1) - s1*s2*2;
    return ans; 
}
int main()
{
    scanf("%d%d%d",&n,&m,&q);
    int cmd,x,y,x2,y2;
    dx[0] = n;
    dy[0] = m; 
    for(int i = 1; i <= q; i ++)
    {
        scanf("%d",&cmd);
        if(cmd == 1)
        {
            scanf("%d%d",&x,&y);
            huan(x,y);
        }
        else
        {
            scanf("%d%d%d%d",&x,&y,&x2,&y2);
            cout<<suan(x,y,x2,y2)<<endl;
        }
    }
    return 0;
 } 

```

---

## 作者：Cesare (赞：10)

感觉许多题解并没有讲清楚线段树在存什么。

第一棵线段树存的是一列中的被染色数量。

第二棵存的是一行中被染色数量。

另外，对于容斥原理的推导。

给出三种容斥的情况：

$1$

![](https://cdn.luogu.com.cn/upload/pic/53826.png)

该组数据：

```
5 5 10
1 2 3
1 2 3
2 1 1 5 5
```

此处散发红烟的点在同一行同一列，所以全部被消除了。

所以此处询问 $1$ $1$ $5$ $5$

第一棵线段树的回答就是 $0$ ，第二棵也是。

答案就是 $0$

再看第二种情况：

$2$

![](https://cdn.luogu.com.cn/upload/pic/53825.png)

该组数据：

```
5 5 10
1 2 3
1 4 3
2 1 1 5 5 
```

此处两的发散红烟的点在同一行，所以如果询问 $1$ $1$ $5$ $5$

第一棵线段树的回答就是 $2$ ，第 $2$ 棵就是 $0$ 。

所以就没有重复算的点，答案就是 

$$( x2-x1+1 ) * query( 1, y, yy ) + ( y2-y1+1 ) * query ( 1, x, xx )$$

$3$

![](https://cdn.luogu.com.cn/upload/pic/53827.png)

该组数据：

```
5 5 10
1 2 3
1 4 4
2 1 1 5 5
```

此处散发红烟的点在不同的行列，是普遍的情况，所以我们观察被消除的点，发现重合到一起的就被消除了，也即有几行重合在一起的点，就被多算了 $2$ 次，因为这些点本身是没有被染上颜色的，却把它们作为染了色的点算了两次。

所以答案就是：

$$( x2-x1+1 ) * query( 1, y, yy ) + ( y2-y1+1 ) * query ( 1, x, xx ) - query ( 1, y, yy ) * query ( 1, x, xx ) * 2$$

也就知晓了是如何得出这个公式的。

最后，放上询问部分的代码：

```cpp
		switch ( opt ) {
			case 1: 
				x = read(), y = read();
				update1 ( 1, x, x ); update2 ( 1, y, y ); 
				break;
			case 2: 
				x = read(), y = read(), xx = read(), yy = read();
				zz = query1 ( 1, x, xx ); zzz = query2 ( 1, y, yy );
				wln ( zz * ( yy - y + 1 ) + zzz * ( xx - x + 1 ) - ls ( zz * zzz ) );
				break;
		}
```



---

## 作者：orangebird (赞：8)

两棵线段树分别维护每行，每列有没有释放过红雾。

由于两片红雾会抵消，相当于每次修改，对应行^=1,对应列^=1。

每次询问，设行范围为[l1,r1],列范围为[l2,r2],查询到释放过红雾的行数量为n1,释放过红雾的列数量为n2

则根据容斥原理，答案为n2\*(r1-l1+1)+n1\*(r2-l2+1)-n1\*n2\*2

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define lson (rt<<1)
#define rson ((rt<<1)|1)
#define mid ((l+r)>>1)
using namespace std;
int sumx[400011],sumy[400011];
int n,m,q,op,px1,py1,px2,py2;
void insx(int rt,int l,int r,int x)
{
    if(l==r)
    {
        sumx[rt]^=1;
        return;
    }
    if(x<=mid)insx(lson,l,mid,x);
    else insx(rson,mid+1,r,x);
    sumx[rt]=sumx[lson]+sumx[rson];
}
int quex(int rt,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)return sumx[rt];
    if(mid+1>R)return quex(lson,l,mid,L,R);
    if(L>mid)return quex(rson,mid+1,r,L,R);
    return quex(lson,l,mid,L,R)+quex(rson,mid+1,r,L,R);
}
void insy(int rt,int l,int r,int x)
{
    if(l==r)
    {
        sumy[rt]^=1;
        return;
    }
    if(x<=mid)insy(lson,l,mid,x);
    else insy(rson,mid+1,r,x);
    sumy[rt]=sumy[lson]+sumy[rson];
}
int quey(int rt,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)return sumy[rt];
    if(mid+1>R)return quey(lson,l,mid,L,R);
    if(L>mid)return quey(rson,mid+1,r,L,R);
    return quey(lson,l,mid,L,R)+quey(rson,mid+1,r,L,R);
}
int main()
{
    scanf("%d%d%d",&n,&m,&q);
    while(q--)
    {
        scanf("%d%d%d",&op,&px1,&py1);
        if (op==1) 
        {
            insx(1,1,n,px1);
            insy(1,1,m,py1);
        }
        else
        {
            scanf("%d%d",&px2,&py2);
            ll n1=quex(1,1,n,px1,px2),m1=quey(1,1,m,py1,py2);
            printf("%lld\n",n1*(ll)(py2-py1+1)+m1*(ll)(px2-px1+1)-n1*m1*2LL);
        }                     
    }
}
```

---

## 作者：Zzxpy (赞：7)

刚入坑东方，发一篇题解！（感谢管理大大百忙之中抽时间审核！）
 
三个月前。。我们机房做了这道题，当时还没有学数据结构，当时我找到了正解的思路。。。但是没有树状数组或者线段树的辅助，打了半个暴力TvT。

在拆开横纵坐标后这道《红色的幻想乡》只需要两个树状数组就可以把一个区间内产生的迷雾存下来。

1.在释放迷雾后，把释放迷雾的坐标存进树状数组。

2.当该位置已经储存过迷雾，存一个-1抵消原来的迷雾。

3.求答案时，方程为纵坐标之差乘横着的迷雾条数加横坐标之差乘纵着的迷雾条数减横着的迷雾条数乘纵着的迷雾条数乘二。

下面是代码

```cpp
#define BOLI_LINGMENG
#include<bits/stdc++.h>
using namespace std;
#define ll long long int
ll n,m,q,c1[312345],c2[312345],op,x2,y2,x3,y3,a[312345],b[312345];
ll lowbit(ll x) {
	return x&-x;
}
void add1(ll x,ll y) {
	for(; x<=n; x+=lowbit(x)) c1[x]+=y;
}
ll ask1(ll x) {
	ll ret=0;
	for(; x>=1; x-=lowbit(x)) ret+=c1[x];
	return ret;
}
void add2(ll x,ll y) {
	for(; x<=m; x+=lowbit(x)) c2[x]+=y;
}
ll ask2(ll x) {
	ll ret=0;
	for(; x>=1; x-=lowbit(x)) ret+=c2[x];
	return ret;
}
int main() {
	cin>>n>>m>>q;
	while(q--) {
		scanf("%lld",&op);
		if(op==1) {
			scanf("%lld%lld",&x2,&y2);
			if(a[x2]==1) {
				add1(x2,-1);
			} else {
				add1(x2,1);
			}
			a[x2]^=1;
			if(b[y2]==1) {
				add2(y2,-1);
			} else {
				add2(y2,1);
			}
			b[y2]^=1;
		} else {
			scanf("%lld%lld%lld%lld",&x2,&y2,&x3,&y3);
			printf("%lld\n",(x3-x2+1)*(ask2(y3)-ask2(y2-1))+(y3-y2+1)*(ask1(x3)-ask1(x2-1))-(ask2(y3)-ask2(y2-1))*(ask1(x3)-ask1(x2-1))*2);
		}
	}
	return 0;
}
```



---

## 作者：览遍千秋 (赞：5)

## 问题描述

经过上次失败后，蕾米莉亚决定再次发动红雾异变，但为了防止被灵梦退治，她决定将红雾以奇怪的阵势释放。

我们将幻想乡看做是一个 $n \times m$ 的方格地区，一开始没有任何一个地区被红雾遮盖。蕾米莉亚每次站在某一个地区上，向东南西北四个方向各发出一条无限长的红雾，可以影响到整行/整列，但不会影响到她所站的那个地区。如果两阵红雾碰撞，则会因为密度过大而沉降消失。灵梦察觉到了这次异变，决定去解决它。但在解决之前，灵梦想要了解一片范围红雾的密度。可以简述为两种操作:

`1 x y` 蕾米莉亚站在坐标 $(x,y)$ 的位置向四个方向释放无限长的红雾。

`2 x1 y1 x2 y2` 询问左上点为 $(x1,y1)$，右下点为 $(x2,y2)$ 的矩形范围内，被红雾遮盖的地区的数量。

---

## 题解

认为站立的地方也是沉降。

维护两棵线段树，一个维护行，一个维护列，单点修改，区间查询（树状数组也可以）

设 $R,C$ 分别代表行和列被覆盖数量，答案为 $ R \times (y2 - y1 + 1) + C \times (x2 - x1 + 1) - 2 \times R \times C $ 。

减去两倍 $R \times C$ 的原因：去掉行列统计各一次。

---

## $\mathrm{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int maxn = 100000 + 7;
const int maxm = 200000 + 7;

int n, m, T;

template < typename Tp >
void read(Tp &x) {
	x = 0;char ch = 1;int fh = 1;
	while(ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if(ch == '-') fh = -1, ch=getchar();
	while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	x *= fh;
}

void Init(void) {
	read(n); read(m); read(T);
}

struct Segment_Tree {
	#define lfc (x << 1)
	#define rgc ((x << 1) | 1)
	#define mid ((l + r) >> 1)
	int val[maxn << 2];
	void modify(int x, int l, int r, int pos) {
		if(l == r) {
			val[x] = 1 - val[x];
			return ;
		}
		if(pos <= mid) modify(lfc, l, mid, pos);
		else modify(rgc, mid + 1, r, pos);
		val[x] = val[lfc] + val[rgc];
	}
	int query(int x, int l, int r, int L, int R) {
		if(L <= l && r <= R) return val[x];
		if(r < L || l > R) return 0;
		return query(lfc, l, mid, L, R) + query(rgc, mid + 1, r, L, R);
	}
}row, column;


void operator1(void) {
	int x, y;
	read(x); read(y);
	row.modify(1, 1, n, x);
	column.modify(1, 1, m, y);
}

void operator2(void) {
	int x1, x2, y1, y2;
	read(x1); read(y1); read(x2); read(y2);
	int R = row.query(1, 1, n, x1, x2), C = column.query(1, 1, m, y1, y2);
	LL ans = (LL)(y2 - y1 + 1) * (LL)R + (x2 - x1 + 1) *(LL)C - (LL)R * (LL)C * 2ll;
	printf("%lld\n", ans);
}

void Work(void) {
	while(T--) {
		int op; read(op);
		if(op == 1) operator1();
		else operator2();
	}
}

int main(void) {
	Init();
	Work();
	return 0;
}
```


---

## 作者：Hiiragi_Utena (赞：4)

题目看上去是二维的。用降维的思想可以用两个一维树状数组来做。

对于操作1，可视为将整个 $x$ 列与整个 $y$ 行各释放一次红雾（$(x,y)$ 被释放两次，相当于没释放）。对于操作2，只用知道之前在 $[x1,x2]$ 列和 $[y1,y2]$ 行中各释放了几次红雾即可。

由此，发现此题实际上只用“单点修改”和“区间查询”，用一维树状数组维护即可。需要两个树状数组，分别维护列与行。时间复杂度为 $O(q\log n)$。比线段树常数更低，更省空间，代码还更短（为什么好多题解都用线段树？）。深夜评测+读入优化+吸氧只用 $98ms$ 稳拿最优解（第二 $124ms$）。

注意事项：

- 当某一列（或行）被释放多次红雾时，红雾会消失。所以要再建两个数组分别表示每列、每行有没有被释放过奇数次红雾。
- 询问的答案最大为 $10^5 \times 10^5$ 爆 int。

代码：

```cpp
#include<cstdio>
#define RI register int
using namespace std;
int n,m,q;
bool mx[100005],my[100005];
int treex[100005],treey[100005];
inline int lowbit(RI num){return num&-num;}
void add(int *tree,RI s,RI num){
	RI ceil;
	if(tree==treex)ceil=n;
	else ceil=m;
	for(;s<=ceil;s+=lowbit(s))tree[s]+=num;
}
int ask(int *tree,RI s){
	RI res=0;
	for(;s;s-=lowbit(s))res+=tree[s];
	return res;
}
int read(){
	char ch;RI res=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+ch-'0';
		ch=getchar(); 
	}
	return res;
}
int main(){
	n=read();m=read();q=read();
	while(q--){
		RI op,x,y,x_,y_;
		op=read();x=read();y=read();
		if(op==1){
			if(mx[x]==false)mx[x]=true,add(treex,x,1);
			else mx[x]=false,add(treex,x,-1);
			if(my[y]==false)my[y]=true,add(treey,y,1);
			else my[y]=false,add(treey,y,-1);
		}
		else{
			x_=read();y_=read();
			long long xnum=ask(treex,x_)-ask(treex,x-1),xx=x_-x+1;
			long long ynum=ask(treey,y_)-ask(treey,y-1),yy=y_-y+1;
			printf("%lld\n",xnum*yy+ynum*xx-xnum*ynum*2);
		}
	}
	return 0;
} 
```

---

## 作者：Treaker (赞：3)

## 指针题解来一发！！！
对于这道题它的修改是贯穿的（就那个意思），那么我们只用考虑他在哪个位置贯穿了就行了，所以对于X轴 Y轴，分别维护一颗线段树。

修改时，要取异或，因为是可以抵消的。

但是查询时怎么办呢。。我们发现抵消的块（包含自己站的那个块）一共是2*x*y（x是横轴查询到的红雾，y是纵轴查询到的红雾）~~没图（懒&&可以看其他题解）。。~~ 其实就是x轴y轴查询会重复，抵消的也会算上，而这两者正好相等，加起来也就是2xy。用总的一减就行了。
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 100010;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m , q;
struct Segment_tree
{
	#define mid ((p -> l + p -> r) >> 1)
	struct node
	{
		node *ls , *rs;
		int l , r , sum;
		node(int l = 0,int r = 0) : l(l) , r(r) {ls = rs = NULL;sum = 0;}
		inline void up() {sum = ls -> sum + rs -> sum;}
	}*root,*beg , pool[N << 3] , *tail;
	void build(node *&p,int l,int r)
	{
		p = new (tail ++) node(l,r);
		if(l == r)	return ;
		build(p -> ls,l,mid); build(p -> rs,mid+1,r);
	}
	void chenge(node *p,int x)
	{
		if(p -> l == p -> r) return (void)(p -> sum ^= 1);
		if(x <= mid) chenge(p -> ls,x);
		else chenge(p -> rs,x);
		p -> up();
	}
	int query(node *p,int x,int y)
	{
		if(x <= p -> l && p -> r <= y)	return p -> sum;
		int res = 0;
		if(x <= mid) res += query(p -> ls,x,y);
		if(y > mid)	res += query(p -> rs,x,y);
		return res;
	}
	inline void LOL()
	{
		n = read(); m = read(); q = read();
		build(root,1,m); build(beg,1,n);
		for(int i = 1, opt , x , y , l , r , tmp , res;i <= q;i ++)
		{
			opt = read(); x = read(); y = read();
			if(opt & 1) chenge(root,y),chenge(beg,x);
			else 
			{
				l = read();
				r = read();
				tmp = query(root,y,r);
				res = query(beg,x,l);
				printf("%lld\n",(long long)tmp * (l - x + 1) + (long long)res * (r - y + 1) - (long long)2 * res * tmp);
			}
		}
	}
	Segment_tree() {tail = pool;}
}CF;
int main()
{
	CF.LOL();
	return 0;
}

```


---

## 作者：花里心爱 (赞：1)

一开始看到这题还以为是二维线段树（蒟蒻表示只是听说过并不会写）

然后看数据范围……$10^5$

先想$n\leq 200$的数据。这个每次暴力改暴力查询就行

然后我们发现每次操作都是改变完整的一行和一列（自己的位置可以认为是这行和这列抵消了）。

~~考虑小学数学的套路~~。假设我们要查询的区间为`1 1 4 4`，进行操作`1 2 2`后，区间变为

$o\color{blue}x\color{black}oo$  
$\color{blue}xoxx$  
$o\color{blue}x\color{black}oo$  
$o\color{blue}x\color{black}oo$

我们可以看做这里是改变了1行和1列（中间的抵消掉了），然后我们发现中间的块被算了2次，应该减掉。

进行操作`1 4 4`后，区间变为

$o\color{blue}x\color{black}o\color{red}x$  
$\color{blue}xox\color{violet}o$  
$o\color{blue}x\color{black}o\color{red}x$  
$\color{red}x\color{violet}o\color{red}xo$

注意紫色的地方是多算的（也包括`2 2`和`4 4` 2个位置）

设改变的行数为$x$，列数为$y$，查询的区间大小为$u \times n$，则答案为$x\times m+y\times n-2\times x\times y$。

然后用线段树维护一下区间改变的行（列）数和，单点修改（每次改变就是异或），区间查询和。

代码如下 :
```
#include <cstdio>
#include <cctype>
#define maxn 100005
#define ll long long
inline int read() {
    int d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
    while(isdigit(ch)){d=d*10+ch-48;ch=getchar();}return d;
}

int n, m, q, op, x, y, u, v;
ll c[maxn<<2], d[maxn<<2]; // c为行，d为列
ll xl, yl;

#define lson cur<<1, l, mid
#define rson cur<<1|1, mid+1, r

// 线段树基本操作
void modifyc(int cur, int l, int r, int pos) {
    if(l == r) {c[cur] ^= 1; return;}
    int mid = (l+r)>>1;
    if(mid >= pos) modifyc(lson, pos);
    else modifyc(rson, pos);
    c[cur] = c[cur<<1] + c[cur<<1|1];
}

ll queryc(int cur, int l, int r, int x, int y) {
    if(l >= x && r <= y) return c[cur];
    int mid = (l+r)>>1;
    ll sum = 0;
    if(mid >= x) sum += queryc(lson, x, y);
    if(mid < y) sum += queryc(rson, x, y);
    return sum;
}

void modifyd(int cur, int l, int r, int pos) {
    if(l == r) {d[cur] ^= 1; return;}
    int mid = (l+r)>>1;
    if(mid >= pos) modifyd(lson, pos);
    else modifyd(rson, pos);
    d[cur] = d[cur<<1] + d[cur<<1|1];
}

ll queryd(int cur, int l, int r, int x, int y) {
    if(l >= x && r <= y) return d[cur];
    int mid = (l+r)>>1;
    ll sum = 0;
    if(mid >= x) sum += queryd(lson, x, y);
    if(mid < y) sum += queryd(rson, x, y);
    return sum;
}

int main() {
    n = read(), m = read(), q = read();
    while(q--) {
        op = read();
        if(op == 1) {
            x = read(), y = read();
            modifyc(1, 1, n, x);
            modifyd(1, 1, n, y);
        }
        else {
            x = read(), y = read(), u = read(), v = read();
            xl = queryc(1, 1, n, x, u);
            yl = queryd(1, 1, n, y, v);
            printf("%lld\n", xl*(v-y+1)+yl*(u-x+1)-2*xl*yl);
        }
    }
    return 0;
}
```

---

## 作者：Na2PtCl6 (赞：0)

## 关键信息
- 释放一次占领一整行，一整列

- 重复释放的格子会相互抵消
## 分析题目
这题不就是 [车的攻击](https://www.luogu.com.cn/problem/P3913) 的加强版吗？

---

此题重点在如何把二维问题转化为一维问题。

我们不妨把一行或一列看成一个整体，释放一次就把对应的行和列的标记异或 $1$ ，表示这一行被占领或被重复释放的红雾清空了。

询问也很好办，设行标记为序列 $R$，列标记为序列 $C$，在范围内有 $r$ 行，有 $c$ 列已被覆盖，则 
$$r=\sum_{i=x1}^{x2}R_i,c=\sum_{i=y1}^{y2}C_i$$ 
易得，范围内的交叉点个数为 $r \times c$

$\because$ 每次释放红雾都是无限长的 $\therefore$ 范围内的纵向红雾长 $x2-x1$，横向红雾宽 $y2-y1$

$\therefore$ 结果为 $r \times (y2-y1)+c \times (x2-x1)-r \times c \times 2$

考虑用树状数组维护单点赋值，区间求和。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=100004;
char res[maxn*20];
int n,m,q,cnt,op,r1,c1,r2,c2;

inline void read(int &x){
	char c=getchar();bool f=0;x=0;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')
			f=1;
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+(c^48);
	x=f?-x:x;
}

void save(const LL x){
	if(x>9)
		save(x/10);
	res[++cnt]=x%10+48;
}

struct arrt{
	private:
	int _sz,a[maxn],tree[maxn];
	
	inline void add(int p,int v){
		a[p]+=v;
		while(p<=_sz){
			tree[p]+=v;
			p+=p&-p;
		}
	}
	
	public:
	arrt(){ memset(tree,0,sizeof(tree));}	
		
	void setsize(const int &x){ _sz=x;}
	
	inline int sum(int p){
		int ret=0;
		while(p){
			ret+=tree[p];
			p-=p&-p;
		}
		return ret;
	}
	
	inline void update(int p){ add(p,a[p]==0?1:-1);}
}r,c;

LL query(int r1,int c1,int r2,int c2){
	LL cntr=r.sum(r2)-r.sum(r1-1),cntc=c.sum(c2)-c.sum(c1-1);
	LL rdis=r2-r1+1,cdis=c2-c1+1;
	return cntr*cdis+cntc*rdis-(cntr*cntc<<1ll);
}

signed main(){
	read(n),read(m),read(q);
	r.setsize(n),c.setsize(m);
	while(q--){
		read(op),read(r1),read(c1);
		if(op==1){
			r.update(r1);
			c.update(c1);
		}
		else{
			read(r2),read(c2);
			save(query(r1,c1,r2,c2));
			res[++cnt]='\n';
		}
	}
	fwrite(res+1,1,cnt,stdout);
	return 0;
}
```

---

## 作者：infinities (赞：0)

首先发现两块红雾在一起会消失，所以修改时的站立点没有红雾其实就可以理解成一行和一列的交点处红雾会消失。

所以其实修改操作就是对于一整行/一整列进行修改。这样，容易想到对于行和列分开进行维护。

具体就是用两个树状数组(比较好写)维护前缀和，然后修改的时候看这一整行/列是变成有红雾还是没有红雾，从而决定是进行加一还是减一的操作。

然后比较显然的，查询的区间中如果有 $i$ 行 $j$ 列被红雾覆盖，那么但看行，被覆盖的有 $i (y_2-y_1+1)$ 格，单看列有 $j (x_2-x_1+1)$ 格，两部分的交集有 $ij$ 格，这部分在行和列中分别被算了一遍，所以减去两倍的它就可以得到答案。简而言之，答案就是 $i(y_2-y_1+1)+j (x_2-x_1+1)-2ij$。

发现 $i,j$ 用树状数组来查询即可，于是就变成了一个树状数组的裸题。

唯一需要注意的就是开long long。

code(前面部分省略，read()是快读):
```cpp
#define int long long
int n, m, q, ln[maxn], lm[maxn], tn[maxn], tm[maxn];
void updn(int x){int k = 0; k = (ln[x] ? -1 : 1), ln[x] ^= 1; for(; x <= n; x += x & (-x))tn[x] += k;}
void updm(int x){int k = 0; k = (lm[x] ? -1 : 1), lm[x] ^= 1; for(; x <= m; x += x & (-x))tm[x] += k;}
int quen(int x){int res = 0; for(; x; x -= x & (-x))res += tn[x]; return res;}
int quem(int x){int res = 0; for(; x; x -= x & (-x))res += tm[x]; return res;}
signed main(){
	n = read(), m = read(), q = read();
	while(q--){
		int op = read();
		if(op == 1){
			int x = read(), y = read(); updn(x); updm(y);
		}else{
			int x1 = read(), y1 = read(), x2 = read(), y2 = read();
			int xx = quen(x2) - quen(x1 - 1), yy = quem(y2) - quem(y1 - 1);
			cout << xx * (y2 - y1 + 1) + yy * (x2 - x1 + 1) - 2 * xx * yy << "\n";
		}
	}
}
```

---

## 作者：Azazеl (赞：0)

$\ \ \ \ \ \ \ $明天就 NOI Online了，先发篇题解涨涨rp  
### 题意  
$\ \ \ \ \ \ \ $给定一个 $n \times m$ 的 $01$ 矩阵，有两种操作。  
$\ \ \ \ \ \ \ $1.对于某个给定坐标，将其所在的行、列上所有数取反，该点亦取反 $2$ 次。  
$\ \ \ \ \ \ \ $2.查询某个二维区间内的总和。  

### 题解  
$\ \ \ \ \ \ \ $不难想到，将 $0$ 和 $1$ 取反其实就是将 $0$ 和 $1\ xor$ 上 $1$。  
$\ \ \ \ \ \ \ $所以如果我们对某个点取反其实就是将这个点所在的行、列进行一次异或。  
$\ \ \ \ \ \ \ $我们不难想到可以用两个数组记录某行、列是否被取反过。   

$\ \ \ \ \ \ \ $我们算是解决了修改的问题，那么查询呢？  
$\ \ \ \ \ \ \ $我们来试着分析一下。  

$\ \ \ \ \ \ \ $![红色表示纵向的区域，蓝色表示横向的区域，紫色表示两者交叉的区域](https://i.loli.net/2020/03/06/jZLWBuUp24igCJv.png)  
(红色表示纵向的区域，蓝色表示横向的区域，紫色表示两者交叉的区域)

$\ \ \ \ \ \ \ $再举几个例子，或者用笔稍微画一画，我们就能得到。  

$$ans=\texttt{为1的列数} \times \texttt{行数} + \texttt{为1的行数} \times \texttt{列数} -2 \times \texttt{为1的列数} \times \texttt{为1的行数}$$  

$\ \ \ \ \ \ \ \ $~~(笔者想不到有什么合适的变量名了就将就看吧)~~  

$\ \ \ \ \ \ \ $其实这也是容斥原理，这应该很好证明，在此笔者就暂时不证明了。  

$\ \ \ \ \ \ \ $那么我们现在想到要统计为1的行数、列数，即区间之和。  

$\ \ \ \ \ \ \ $嗯···单点修改，区间查询，熟悉的配方。  

$\ \ \ \ \ \ \ $然后用线段树（或者BIT开两个数组记录状态）维护区间和什么的板子就不用过多赘述了吧。  

$$\mathcal{CODE}$$ 
```
#include <cstdio>
#include <algorithm>
#define ls p<<1
#define rs p<<1|1
#define lson p<<1,l,mid
#define rson p<<1|1,mid+1,r
#define ll long long
using namespace std;
struct seg{
	ll tr[400005];
	void push_up(ll p){tr[p]=tr[ls]+tr[rs];}
	void update(ll p,ll l,ll r,ll aim)
	{
		if(l==r&&l==aim)
		{
			tr[p]^=1;
			return;
		}
		ll mid=(l+r)>>1;
		if(aim<=mid) update(lson,aim);
		if(mid<aim) update(rson,aim);
		push_up(p);
	}
	ll query(ll p,ll l,ll r,ll l_x,ll r_x)
	{
		if(l_x<=l&&r<=r_x) return tr[p];
		ll re=0,mid=(l+r)>>1;
		if(l_x<=mid) re+=query(lson,l_x,r_x);
		if(mid<r_x) re+=query(rson,l_x,r_x);
		return re;
	}
}z,h;
int main() {
	ll n,m,q,op,x,y,x1,y1,x2,y2;
	scanf("%lld %lld %lld",&n,&m,&q);
	for(ll i=1;i<=q;i++)
	{
		scanf("%lld",&op);
		if(op==1) 
		{
			scanf("%lld %lld",&x,&y);
			h.update(1,1,n,x);
			z.update(1,1,m,y);
		}
		else
		{
			scanf("%lld %lld %lld %lld",&x1,&y1,&x2,&y2);
			ll re1=z.query(1,1,m,y1,y2),re2=h.query(1,1,n,x1,x2);
			printf("%lld\n",(x2-x1+1)*re1+(y2-y1+1)*re2-re1*re2*2);
		}
	}
	return 0;
}
```
祝大家明天NOI Online都有好成绩~  

---


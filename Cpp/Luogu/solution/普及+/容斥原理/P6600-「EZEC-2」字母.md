# 「EZEC-2」字母

## 题目背景


给你一个 $01$ 矩阵，我们希望你从中找到由连续的 $1$ 组成的「字母 T」。

## 题目描述

「字母 T」由一横和一竖组成，竖一定在横的下方（您可以借助英文字母 `T` 辅助理解）。

在本题中，我们定义「横」为组成「字母 T」的水平线段，「竖」为组成「字母 T」的竖直线段。

注意「横」与「竖」的公共部分同时计入横长和竖长。

**合法的「字母 T」的「横」长必须为奇数且「竖」与「横」交于「横」的中点，「横」长最小为 $3$ ，「竖」长最小为 $2$。**


如：

$$
    \begin{array}{ccc}
       0\color{Red}111\color{black}1\\
       00\color{Red}1\color{black}01
    \end{array}
$$

**只含有**一个合法的「字母 T」（即标红部分）。


现在给你一个 $n \times m$ 的 $01$ 矩阵，请你求出在这个矩阵中**合法**的「字母 T」中，一共有多少个**满足以下条件**的「字母 T」。 

设某个合法的「字母 T」的「横」长为 $w$，「竖」长为 $h$，有：

- $w\ge a$
- $h\ge b$
- $w\times h \ge s$
- $w+h\ge x$

两个「字母 T」不相同即两个「字母 T」的 **「横」长** 或 **「竖」长** 或 **最左上角的坐标** 不同。     

## 说明/提示

**【样例解释 #1】**
$$
    \begin{array}{ccc}
      \color{Red}11111\qquad11111\\01\color{Red}1\color{black}10\qquad01\color{Red}1\color{black}10\\
      11\color{Red}1\color{black}11\qquad11\color{Red}1\color{black}11\\
      01\color{Red}1\color{black}10\qquad01\color{Red}1\color{black}10\\
      11111\qquad11\color{Red}1\color{black}11\\\\
      第\ 1\ 个\qquad第\ 2\ 个
    \end{array}
$$
除了以上两个「字母 T」，没有其他满足条件且合法的「字母 T」，故输出 $2$。

**【数据范围】**       
| 测试点编号 | $n,m\le$ | $a,b\le$ | $s\le$ | $x\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1 \sim 4$ | $100$ | $100$ |$10^4$|$200$|
| $5 \sim 8$ | $500$ | $500$ |$2.5\times 10^5$|$10^4$|
| $9,10$ | $3\times 10^3$ | $0$ |$0$|$0$|
| $11\sim 13$ | $3\times 10^3$ |$3\times 10^3$|$0$|$6\times 10^3$|
| $14\sim 16$ | $3\times 10^3$ |$3\times 10^3$|$9\times 10^6$|$0$|
| $17\sim 20$ | $3\times 10^3$ |$3\times 10^3$|$9\times 10^6$|$6\times 10^3$|

对于 $100\%$ 的数据，满足 $1 \le n,m \le 3\times 10^3$，$0 \le a,b \le 3\times10^3$，$0 \le s \le 9\times10^6$，$\space0 \le x \le 6\times10^3$。



## 样例 #1

### 输入

```
5 5
3 3 18 9
11111
01110
11111
01110
11111```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
3 3 15 7
11111
01110
11111
01110
11111```

### 输出

```
7```

## 样例 #3

### 输入

```
10 10
5 4 40 11
0011111111
1011110101
1111111111
1001111101
1111101111
1111110110
0111011101
0111111110
0011111111
0111111101
```

### 输出

```
8```

# 题解

## 作者：yangrunze (赞：14)

蒟蒻作为出题人$\colorbox{black}{\color{black}的好基友}$，特地$\colorbox{black}{\color{black}好不容易弄懂了}$来写一发$\colorbox{black}{\color{black}非}$官方题解！

$$\huge\color{purple}{\text {vectorwyx}}\;\color{gold}\text{是我们的王}\;\color{red}\text!$$



------------
据比赛官方透露，这个题是经过**加强**的

在加强之前，字母T是没有限制的（即$a=b=s=x=0$）

所以咱们就从这种情况入手，这样有利于向正解进发！

分析一下字母T的组成吧……

![](https://cdn.luogu.com.cn/upload/image_hosting/vs0w2i4c.png)

可以发现：对于图中的每一个**含 $1$ 的点**，字母T的数量跟它**左，右，下**三个方向上**连续的 $1$ 的个数**有关。

设这个点左，右，下三个方向连续$1$的个数为$l,r,d$，则以这个点为中心点的字母T的数量为$(\min(l,r)-1)\times(d-1)$

所以我们可以先把每个点的$l,r,d$处理出来，这样就可以解决问题啦！

但是怎么处理呢，一个个找？

不，我们用**前缀和**。

直接上代码吧！（话说$r$和$d$实际上是后缀和呢）

```cpp
	bool wyx[3005][3005];//题目给的01矩阵（wyx是我们的红太阳！！！）
	long long sl[3005][3005],sr[3005][3005],sd[3005][3005];//l,r,d（开 long long 啊awa）
	//如果这里是1，那就加上前面的
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
		if(wyx[i][j])sl[i][j]=sl[i][j-1]+1;
	}
	//后面的亦如此，但是要注意一下循环顺序    
	for(int i=1;i<=n;i++){
		for(int j=m;j>0;j--)
		if(wyx[i][j])sr[i][j]=sr[i][j+1]+1;
	}
	for(int i=n;i>0;i--){
		for(int j=1;j<=m;j++)
		if(wyx[i][j])sd[i][j]=sd[i+1][j]+1;
	}	
```

这样的话，我们就完美迈出了AC的第一步！



------------

接下来，咱们来考虑$w$和$h$的限制条件：

>对于每个 $w$，我们可以算出最小的合法 $h$。
> ——君のNOIP。

那怎么算呢？我们来看看这四个条件：

$$\begin{cases}h\ge b\quad (\text{限制条件2})\\h\ge \lceil\dfrac{s}{w}\rceil\quad (\text{限制条件3})\\h\ge x-w\quad (\text{限制条件4})\end{cases}$$

因为**都要满足**，所以我们从三个值里面要取个**最大的**，即：
```cpp
	long long minh[3005];//minh:对于每个w，它的最大合法h		
	for(int w=a+!(a&1);w<=m;w+=2)//因为w>=a，所以只需要从a开始，加!(a&1)是为了保证w为奇数
```
这样的话，对于任意情况我们都可以通过**枚举中心点和$w$** 的方式在$O(n^3)$的时间内算出来啦！

但是……这貌似还不太够……



------------
接下来就是最后一战了：我们要把$O(n^3)$优化成$O(n^2)$

$\color{red}{\text{敲黑板！！！重难点来啦！！！！！}}$

往深入里思考一下，我们需要把$w$和$h$的范围确定下来。

不难看出：$b\le h\le d$

然后再来考虑 $w$，$w$ 的最大值是$2\times\min(l,r)-1$……

但是 $w$ 的最小值是啥？？？？？

别急嘛，既然前面我们已经推出了对于每个 $w$ 最小的合法 $h$，那我们也可以推出**对于每一个 $h$ 的最小合法 $w$** ！

既然我们已经推出了$\min h$，那我们可以好好利用一下：要求出某个 $h$ 的 $\min w$值，就是**寻找一个 $w$，使这个 $w$ 的 $\min h\le h$**

```cpp
	int w=a+!(a&1);//w还是从a开始
	for(int h=n;h>=b;h--){//由于w越大，h越小，所以我们让h从大到小推
		while(w<=m&&minh[w]>h)w+=2;//增加w到minh[w]<=h为止
		minw[h]=w;//这就是minw的值啦
	}
```
这样的话，我们就把$w$和$h$的值限定在一个范围内啦！

不过，这里面还有很多不符合要求的情况，怎么办呢？

看图~

![](https://cdn.luogu.com.cn/upload/image_hosting/r2zlbbmb.png)


蓝色阴影的 $\color{blue}\text{answer}$ 区域——我们要求的答案

绿色的 $\color{green}\text{all}$ 区域——刚才限定出的范围

红色圈圈的 $\color{red}\text{invalid}$ 区域——不符合要求的地方

也就是说：$\color{blue}\text{answer}\color{black}=\color{green}\text{all}\color{black}-\color{red}\text{invalid}$

也就是说，我们只需要求出 $\color{red}\text{invalid}$ 区域就可以啦！

那怎么求呢？我们观察一下 $\color{blue}\text{answer}$ 区域和 $\color{red}\text{invalid}$ 区域的那条黑色分界线，你会有一个惊奇的发现：

这不就是 $\min h$ 的值嘛！！！！

所以：$\color{red}\text{invalid}\large\color{black}=\sum\limits_{i=\min w(d)}^{2\times\min(l,r)-1} \min h(i) $

貌似是一段……**区间和**？

那就简单了：还是用**前缀和**来解决问题！

先处理出$\min h$的前缀和：
```cpp
sminh[w]=sminh[w-2]+minh[w];//因为w只能是奇数所以是-2
```
然后再用刚才的结论解决问题：

```cpp
	long long ans=0;//注意long long
	for(int i=1;i<=n;i++){//枚举中心点
		for(int j=1;j<=m;j++){
			if(!wyx[i][j])continue;//只有这里是1的时候才参加统计
			long long h=sd[i][j];//h的最大范围（为了后面的invalid区域好算，h的下界直接变成0了，反正到头来还要被减掉）
			long long lw=minw[h],rw=1ll*2*min(sl[i][j],sr[i][j])-1;//w的最小范围和最大范围
			if(rw>=lw&&h>=b)//要保证有答案才能算（否则你整出来个负数是啥情况）
			ans+=1ll*(rw-lw+2)/2*(h+1)-(sminh[rw]-sminh[lw-2]);//answer=all-invalid，一些+1，-2这样的细节需要注意下
		}
	} 
```



------------
完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
bool wyx[3005][3005];
long long sl[3005][3005],sr[3005][3005],sd[3005][3005]; 
long long minh[3005],sminh[3005],minw[3005];
int n,m,a,b,s,x;
long long ans=0;
int main(){
	ios::sync_with_stdio(false);//关闭同步流
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>a>>b>>s>>x;
	a=max(a,3),b=max(b,2);//说好的w>=3,h>=2
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;
			cin>>c;
			wyx[i][j]=c-'0';//输入
		}
	}
  //算出三个方向的前（后）缀和
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
		if(wyx[i][j])sl[i][j]=sl[i][j-1]+1;
	}
	for(int i=1;i<=n;i++){
		for(int j=m;j>0;j--)
		if(wyx[i][j])sr[i][j]=sr[i][j+1]+1;
	}
	for(int i=n;i>0;i--){
		for(int j=1;j<=m;j++)
		if(wyx[i][j])sd[i][j]=sd[i+1][j]+1;
	}	
	int w;		
	for(w=a+!(a&1);w<=m;w+=2){
		minh[w]=max(b,max(x-w,(int)(ceil(s*1.0/w))));//运用限制条件算出minh
		sminh[w]=sminh[w-2]+minh[w];		            
	}
	w=a+!(a&1);
	for(int h=n;h>=b;h--){
		while(w<=m&&minh[w]>h)w+=2;//运用minh算出minw
		minw[h]=w;
	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!wyx[i][j])continue;
			long long h=sd[i][j];
			long long lw=minw[h],rw=1ll*2*min(sl[i][j],sr[i][j])-1;
			if(rw>=lw&&h>=b)
			ans+=1ll*(rw-lw+2)/2*(h+1)-(sminh[rw]-sminh[lw-2]);//分析算出ans（实际上可以说是容斥原理）
		}
	} 
	cout<<ans;
}
```
最后的最后：

1. 这个题的前身：[U95387 TLE](https://www.luogu.com.cn/problem/U95387)

2. [yrz最近的心里话](https://www.luogu.com.cn/paste/e2x8mjgj)，真的……






---

## 作者：pocafup (赞：2)

这题解里的方法好神仙啊/kk

然而我的方法感觉这题应该不到绿/fad。~~或成此题最短代码~~

计算 T 大小的方法其他题解写得很好，这里注重讲解对限制条件的处理。

考虑对于横长为 i, 竖长为 j 的合法 T，显然存在一个   $i+2\times C$, $j+D$ 的合法 T 形，其中 $C$，$D$ 为任意常数（可以为 0）

于是这题转化为每个中心点能得到的最大 T 形的合法子集数量。

现在转化一下问题 ：如果把这个变成一维序列，那么这个子集可以怎么求？

发现显然可以使用**前缀和**进行处理。

那么这个问题只是延伸到了二维，我们二维前缀和搞搞就好了。

假设当前横长为 $i$，竖长为 $j$，则我们可以得出转移方程

$val[i][j] = val[i-2][j] + val[i][j-1] - val[i-2][j-1] + valid(i,j);$

其中 valid 表示长宽严格为 $i,j$ 的 T 形是否合法。

于是我们枚举中心点计算即可。

具体一点：

$ans = \sum\limits_{i=1}^n \sum\limits_{j=1}^m val[min(lx[i][j],rx[i][j])\times 2-1][yd[i][j]];$

不加头文件代码 15 行，短的可怜

```cpp
const int MAXN = 3e3+5;
const int MAXM = 1e5+5;
const int mod = 1e9+7;
int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};
int n,m,t,pos[MAXN][MAXN],k,a,b,c,lx[MAXN][MAXN],rx[MAXN][MAXN],yd[MAXN][MAXN],val[MAXN][MAXN],s,x,ans;
signed main(){
  n = read(); m =read(); a = read(); b = read(); s = read(); x = read();
  For(i,1,n) For(j,1,m) pos[i][j] = get()-48;
  For(i,1,n) For(j,1,m) lx[i][j] = (!pos[i][j]) ? 0 : lx[i][j-1]+1;
  For(i,1,n) FOR(j,m,1) rx[i][j] = (!pos[i][j]) ? 0 : rx[i][j+1]+1;
  For(j,1,m) FOR(i,n,1) yd[i][j] = (!pos[i][j]) ? 0 : yd[i+1][j]+1;
  for (int i=3;i<=m;i+=2)For(j,2,n) val[i][j] = val[i-2][j]+val[i][j-1]-val[i-2][j-1]+(i>=a && j>=b && i*j>=s && i+j>=x);
  For(i,1,n) For(j,1,m) ans += val[chkmin(lx[i][j],rx[i][j])*2-1][yd[i][j]];
  writeln(ans);
}
```

---

## 作者：JohnVictor (赞：2)

这题真的蛮不错的，为出题人点赞。

前置知识：前缀和。（二维）

首先考虑 `T` 字形中一横与一竖的交点，枚举那个点。

那么，如果要产生 `T` 字形，就要计算出：

$L$，它左边的连续的 $1$ 的个数；$R$，他右边连续的 $1$ 的个数；$D$，往下的连续的 $1$ 的个数。

那么产生的 $T$ 字形的个数就是 $\min\{L,R\}\times D$。

然而出题人加了限制。设 $F(x,y)$ 为满足 $0 \le a \le x,0 \le b \le y$ 的 $(a,b)$ 对子数，并且 $a+b\ge X,ab \ge W$。

处理出一个不太容易，所以可以预处理出所有这样的值。

定义一个 `bool` 类型的函数 $G(x,y)$ 表示 $(x,y)$ 是否满足 $x+y \ge X,xy \ge W$。那么 $F$ 函数就是这个 $G$ 函数的前缀和。

所以，每个一横一竖的交点产生的答案就是 $F(\min \{L,R\},D)$。现在只用处理出 $L,R,D$ 的值就行了。这三个是类似的，说一下 $L$。

考虑 `dp`，记 $dp_{i,j}$ 是 $(i,j)$ 那一格对应的 $L$ 值，那么显然有转移：

$$dp_{i,j}=0((i,j)=0);dp_{i,j}=dp_{i,j-1}((i,j)=1)$$

完结撒花awa

---

## 作者：君のNOIP。 (赞：2)

说点闲话：

这题本来只有求 $w+h$ 最大的合法 `字母T` ，然后被我们团队的人加强了变成求合法 `字母T` 的数量（即现在的 $a=b=s=x=0$）

然后我想这有啥变化？就加上了限制条件。~~（所以这题就交给我负责了）~~

------------


### 20分： $O(n^4)$ 纯暴力。

$O(n^2)$枚举中心点，然后每个中心点 $O(n^2)$ 枚举 $w$ 和 $h$ 即可。

### 40分：$O(n^3)$ 预处理。

我们观察下四个限制条件，发现对于每个 $w$，我们可以预处理出最小的 $h$ 使其符合条件。

```
for(int w = a + !(a&1); w <= m; w += 2)	mih[w] = ceil(s*1.0/w), mih[w] = max(b, max(x-w, mih[w]) );
```


同时我们预处理每个点下方连续 $1$ 的数量。

```cpp
for(int i = n; i >= 1; i--)
	for(int j = 1; j <= m; j++)	
		if(mp[i][j]) dw[i][j] = dw[i+1][j] + 1;
```


这样我们只需 $O(n^2)$ 枚举中心点，然后 $O(n)$ 枚举 $w$ 即可。

```
if(mih[w] <= dw[i][j]) ans += dw[i][j] - mih[w] + 1;
```
其中 $dw_{i,j}$ 表示点 $(i,j)$ 下方连续 $1$ 的数量。（包括这个点）

### 50分： 还是预处理。

这次我们还需要预处理出每个点左边和右边连续 $1$ 的个数。

对于 $a=b=s=x=0$，很明显我们只需枚举中心点，只要 $min(l_{i,j},r_{i,j})\ge 2,dw_{i,j}\ge 2$ ，答案就加上 $(min(l_{i,j},r_{i,j}) - 1)\times (dw_{i,j}-1)$ 即可。

### 65~80分：~~好像没什么用。~~

### 100分： $O(n^2)$ 简单容斥 + 前缀和。

没有卡 $O(n^2logn)$，因为没什么必要。

我们再预处理出 $mih_i$ 的前缀和，还有最大的 $mih_i< h$ 的下标即为 $pos_h$

最后就只需 $O(n^2)$ 枚举中心点，每次把所有方案数减去不合法的即可。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pn5prk3z.png)

Code：

```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
#define MAX_N 3005
#define LL long long
int n, m;
LL a, b, s, x;
LL ans;
LL dw[MAX_N][MAX_N], l[MAX_N][MAX_N], r[MAX_N][MAX_N], mih[MAX_N], smih[MAX_N], pos[MAX_N];
bool mp[MAX_N][MAX_N];
char cr;
int main() {
	cin >> n >> m >> a >> b >> s >> x;
	a = max(a, (LL)3), b = max(b, (LL)2);
	for(int i = 1; i <= n; i++) {
		cr = getchar();
		while(cr != '0' && cr != '1') cr = getchar();
		mp[i][1] = cr - '0';
		for(int j = 2; j <= m; j++) cr = getchar(), mp[i][j] = cr - '0';
	}
	
	for(int i = 1; i <= n; i++)	for(int j = 1; j <= m; j++)	if(mp[i][j]) l[i][j] = l[i][j-1] + 1;
	for(int i = 1; i <= n; i++)	for(int j = m; j >= 1; j--)	if(mp[i][j]) r[i][j] = r[i][j+1] + 1;
	for(int i = n; i >= 1; i--)	for(int j = 1; j <= m; j++)	if(mp[i][j]) dw[i][j] = dw[i+1][j] + 1;
	
	for(int w = a + !(a&1); w <= m; w += 2)
		mih[w] = ceil(s*1.0/w), mih[w] = max(b, max(x-w, mih[w]) ), smih[w] = smih[w-2] + mih[w];
	int tp = a + !(a&1);
	for(int h = n; h >= b; h--) {
		while(tp <= m && mih[tp] > h) tp += 2;
		pos[h] = tp;
	}
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			if(mp[i][j] && dw[i][j] >= b) {
				int ma = 2 * min(l[i][j], r[i][j]) - 1, h = dw[i][j];
				if(pos[h] <= ma) ans += (ma - pos[h] + 2) / 2 * (h + 1) - smih[ma] + smih[pos[h]-2];
			}
			
	cout<<ans;
}
```


------------

---

## 作者：LiJoQiao (赞：1)

[更好的阅读体验](https://www.cnblogs.com/LiJoQiao/p/18016110)  

upd：修改了格式问题。

题意中的字母 T 可以看作一个回文的 $1$ 串和回文串中心带一个向下的 $1$ 串。  

我们先来考虑朴素做法，可以枚举这个中心然后扩展来找有几个符合要求的串。  
朴素做法显然复杂度不对。  

沿着朴素的思路优化。  
如果只考虑 $w\ge a$ 和 $h\ge b$ 这两个要求很容易想到容斥。  
此时有四个条件，我们直观上不好容斥，因为 $w$ 与 $h$ 会互相影响，在固定一个量与后两个条件的限制下互相设一个不固定的下限。  

题目中的 $a,b,s,x$ 都是固定的，预处理也许会有点用。  
预处理的一个直接的想法就是计算出该中心的回文 $1$ 串最长回文长度和向下 $1$ 串的最长长度（下面称为最大的 T）对应的 T 拆出来的 T 符合要求的 T 的个数。  

可以发现最大的 T 拆出来的 T 的回文 $1$ 串长度小于等于最大的 T 的长度，向下 $1$ 串同理。  
这个形式有点像二维前缀和。  
如果我们沿着前缀和的思路走下去，该前缀和建立的一个矩形数阵上每个数代表的是该点对应的 T 是否符合要求，若符合要求则为 $1$，否则为 $0$。  

于是我们把这个预处理出来，枚举每个中心即可。  
回文串最长长度用 Manacher 算法计算，向下 $1$ 串通过第一个 $1$ 处暴力向下求解，其他的 $1$ 由上一个 $1$ 的长度减去一，这样均摊的方式计算，算法整体的时间复杂度为 $O(nm)$。  

记得开 `long long`，否则喜提 $40$ 分。  

代码如下，其中的 `mh` 是计算该中心的最长回文串长度的，`ms` 是计算该中心向下最长 $1$ 串长度的。  

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
constexpr int MAXN=3e3+10,MAXM=3e3+10;
int n,m,a,b,s,x,sum[MAXN][MAXM],mh[MAXM],ms[MAXN],jz[MAXN][MAXM];
ll ans;
template<typename T>
T read(){
	T x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}
	return x;
}
int gc(){
	int x=getchar();
	while(x==' '||x=='\r'||x=='\n')x=getchar();
	return x;
}
namespace sol{
	void solve(){
		n=read<int>();m=read<int>();
		a=max(read<int>(),3);b=max(read<int>(),2);s=read<int>();x=read<int>();
		//w>=a,h>=b,w*h>=s,w+h>=s,w横,h竖
		for(int i=1;i<=n;++i){//竖
			for(int j=1;((j<<1)-1)<=m;++j){//横一边长度
				if(((j<<1)-1)>=a&&i>=b&&(((j<<1)-1)*i)>=s&&(((j<<1)-1)+i)>=x){
					sum[i][j]=sum[i-1][j]+sum[i][j-1]+1-sum[i-1][j-1];
				}else{
					sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
				}
			}
		}
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				jz[i][j]=gc()-'0';
			}
		}
		for(int i=1;i<=n;++i){
			memset(mh,0,sizeof(mh));
			int p=0;
			for(int j=1;j<=m;++j){
				if(j<=p+mh[p]-1)mh[j]=min(p+mh[p]-j,mh[p-(j-p)]);
				else mh[j]=jz[i][j];
				while(j+mh[j]<=m&&j-mh[j]>0&&jz[i][j+mh[j]]==1&&jz[i][j-mh[j]]==1)++mh[j];
				if(!jz[i][j])ms[j]=0;
				else if(!ms[j]){
					ms[j]=1;
					while(i+ms[j]<=n&&jz[i+ms[j]][j]==1)++ms[j];
				}else --ms[j];
				ans+=sum[ms[j]][mh[j]];
				if(mh[j]+j>mh[p]+p)p=j;
			}
		}
		printf("%lld\n",ans);
	}
}
int main(){
	sol::solve();
	return 0;
}
```

---

## 作者：wjj255 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6600)

一道练习二维前缀和的好题。

首先这道题和[P8865 [NOIP2022] 种花](https://www.luogu.com.cn/problem/P8865)有异曲同工之妙，~~一个让我们找 $C$ 和 $F$ ，这个则是让我们找 $T$ 。~~

类似P8865的思路，穷举关键点（即 $T$ 一横一竖的交点处），预处理出每个点左、右、下三个方向的连续 $1$ 的个数，就像这样：

```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		if(c[i][j]=='1')l[i][j]=l[i][j-1]+1;
		else l[i][j]=0;
	}
}
	
for(int i=1;i<=n;i++){
	for(int j=m;j>=1;j--){
		if(c[i][j]=='1')r[i][j]=r[i][j+1]+1;
		else r[i][j]=0;
	}
}
	
for(int i=n;i>=1;i--){
	for(int j=1;j<=m;j++){
		if(c[i][j]=='1')d[i][j]=d[i+1][j]+1;
		else d[i][j]=0;
	}
}
```

由于 $T$ 要满足题给的四个条件，所以此题与P8865的思路略有不同，我们用 $t(i,j)$ 记录横长为 $i$，竖长为 $j$ 的 $T$ 是否符合题意，同时可以顺便计算出横长为 $i$，竖长为 $j$ 的 $T$ 对答案的总贡献数 $s(i,j)$，就像这样：

```cpp
void predo()
{
	int t;
	for(int i=3;i<=m;i++){//穷举T的横长
		for(int j=2;j<=n;j++){//穷举T的竖长
			if(i>=a&&j>=b&&i*j>=s1&&i+j>=x&&i%2==1)t=1;else t=0;//注意横长必须为奇数
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+t;//计算s(i,j)
		}
	}	
}
```

最后就进入了~~非常愉快的~~统计答案环节，我们穷举 $T$ 的关键点 $(i,j)$，记 $cd$ 为 $T$ 最上面一横的长度，则 $cd=\min(l_{i,j},r_{i,j})×2-1$，竖长为 $d_{i,j}$，则总贡献为
$$\sum_{i=1}^n\sum_{j=1}^ms_{cd,d_{i,j}}$$
就像这样：
```cpp
long long ans=0;//注意LL
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		int cd=max(0,min(l[i][j],r[i][j])*2-1);//防止cd=-1导致数组越界
		ans+=s[cd][d[i][j]];
	}
}
```

完整代码如下：

```cpp
#include<iostream>
using namespace std;
typedef long long LL;
const int N=3e3+5;
int n,m,a,b,s1,x;
char c[N][N];
int l[N][N],r[N][N],d[N][N],s[N][N];
void predo()
{
	int t;
	for(int i=3;i<=m;i++){
		for(int j=2;j<=n;j++){
			if(i>=a&&j>=b&&i*j>=s1&&i+j>=x&&i%2==1)t=1;else t=0;
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+t;
		}
	}	
}
int main()
{
	cin>>n>>m>>a>>b>>s1>>x;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(c[i][j]=='1')l[i][j]=l[i][j-1]+1;
			else l[i][j]=0;
		}
	}
	
	for(int i=1;i<=n;i++){
		for(int j=m;j>=1;j--){
			if(c[i][j]=='1')r[i][j]=r[i][j+1]+1;
			else r[i][j]=0;
		}
	}
	
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			if(c[i][j]=='1')d[i][j]=d[i+1][j]+1;
			else d[i][j]=0;
		}
	}
	predo();
	LL ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int cd=max(0,min(l[i][j],r[i][j])*2-1);
			ans+=s[cd][d[i][j]];
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

完结撒花QwQ


---

## 作者：makerlife (赞：0)

[更好的阅读体验](https://blog.makerlife.top/post/uncategorized-problems/#P6600-%E3%80%8CEZEC-2%E3%80%8D%E5%AD%97%E6%AF%8D) | [Problem Link](https://www.luogu.com.cn/problem/P6600)

> 在 $0/1$ 矩阵中，找到有多少个满足下面要求的横长 $w$ 竖长 $h$ 的 T 字形
> - $w\geq a$
> - $h\geq b$
> - $w\times h\geq s$
> - $w+h\geq x$

### Solution

一眼非常像 NOIP2022 T1。

首先想如何 brute，先枚举矩阵中每个为 $1$ 的点作为 T 的中心点，用前缀和记录它的左、右、下各有多少个 $1$，不妨分别设为 $suml, sumr, sumd$。然后暴力判断这些 $1$ 能组成多少个中心点重叠的符合条件的 T。

考虑优化掉判断符合条件部分的算法，暴力枚举横长竖长，$f_{w, h}$ 表示横长 $w$ 竖长 $h$ 的 T 字形是否满足条件。时间复杂度 $\mathcal{O}(n^2)$。

计算答案时，对于每个位置 $(i,j)$，枚举它可能的横长竖长，显然对于这个位置 $w_{max} = \min\{suml_{i, j}, sumr_{i, j}\}\times 2 - 1,\ h_{max} = sumd_{i, j}$。即 $ans_{i, j} = \sum_{w = 3}^{w_{max}}\sum_{h = 2}^{h_{max}} f_{w, h}$，时间复杂度过高。

继续优化掉这一部分，注意到是统计区间和，想到二维前缀和，用 $sum_{i, j}$ 表示 $\sum_{w = 3}^{i}\sum_{h = 2}^{j} f_{w, h}$。简单容斥一下得到 $sum_{i, j} = sum_{i - 1, j} + sum_{i, j - 1} + f_{i, j} - sum_{i - 1, j - 1}$。

这样总体复杂度 $\mathcal{O}(n^2)$。

### Core Code

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (in[i][j] == '0') suml[i][j] = 0;
        else suml[i][j] = suml[i][j - 1] + 1;
    }
    for (int j = m; j >= 1; j--) {
        if (in[i][j] == '0') sumr[i][j] = 0;
        else sumr[i][j] = sumr[i][j + 1] + 1;
    }
}
for (int j = 1; j <= m; j++) {
    for (int i = n; i >= 1; i--) {
        if (in[i][j] == '0') sumd[i][j] = 0;
        else sumd[i][j] = sumd[i + 1][j] + 1;
    }
}
for (int w = 3; w <= m; w++) {
    for (int h = 2; h <= n; h++) {
        if ((w & 1) && w >= a && h >= b && w * h >= s && w + h >= x) {
            f[w][h] = 1;
        }
        sum[w][h] = sum[w - 1][h] + sum[w][h - 1] + f[w][h] - sum[w - 1][h - 1];
    }
}
int ans = 0;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        int w = min(suml[i][j], sumr[i][j]) * 2 - 1;
        int h = sumd[i][j];
        if (in[i][j] == '1') ans += sum[w][h];
    }
}
cout << ans << endl;
```

---

## 作者：lizicheng3042 (赞：0)

怎么说呢，卡了我一个小时，~~但是是因为 ```scanf``` 犯病了。~~  
## 题目思路  
还是挺简单的，属于前缀和的基础应用，首先将每个位置向左和向右的最大延伸距离求出来然后合起来，然后在求向下最大延伸距离，同时再求一下低于横和竖二元组 $(i,j)$ 是否满足题目给定的条件即可，本题结。  
## 具体代码  
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
typedef long long ll;
ll n,m,sum1[3505][3505],sum2[3505][3505],c,d,s,x,sum3[3505][3505];
ll ans;
char zo[3505][3505];
void pre()
{
	for(ll a=1;a<=n;a++)
		for(ll b=1,cnt=0;b<=m;b++)
		{
			cnt=zo[a][b]?cnt+1:0;
			sum1[a][b]=cnt;
			if(a>=d&&b>=c&&a*b>=s&&a+b>=x&&b%2==1&&b>=3&&a>=2)//约束条件 
				sum2[b][a]=1;
			sum2[b][a]+=sum2[b-1][a]+sum2[b][a-1]-sum2[b-1][a-1];
		}
	for(ll a=1;a<=n;a++)
		for(ll b=m,cnt=0;b>=1;b--)
		{
			cnt=zo[a][b]?cnt+1:0;
			sum1[a][b]=min(cnt,sum1[a][b]);
		}	
	for(ll b=m;b>=1;b--)
		for(ll a=n,cnt=0;a>=1;a--)
		{
			cnt=zo[a][b]?cnt+1:0;
			sum3[a][b]=cnt;
		}		
}
ll equ(int x,int y){
		ll a=sum1[x][y]*2-1,b=sum3[x][y];
		if(a<=1)
			return 0;
		return sum2[a][b];//所有在这个之内的都是合法的 
}
int main()
{
	scanf("%lld%lld%lld%lld%lld%lld\n",&n,&m,&c,&d,&s,&x);
	for(int a=1;a<=n;a++)
	{
		for(int b=1;b<=m;b++)
		{
			cin>>zo[a][b];//罪魁祸首
			zo[a][b]-=48;
		}
	}
	pre();
	for(int a=1;a<=n;a++)
		for(int b=1;b<=m;b++)
		{
			ans+=equ(a,b); 	
		}
	printf("%lld",ans);
	return 0;
}
```
  
  
  

---

## 作者：一只书虫仔 (赞：0)

upd on 2021.9.11 添加的代码，并添加了部分细节。

#### Description

> 给定一个 $n \times m$ 的 01 矩阵，求有多少个横画 $w$ 竖画 $h$ 满足：
>
> - $w \ge a$；
> - $h \ge b$；
> - $wh \ge s$；
> - $w+h \ge x$；
>
> 这些条件的 T 形块。

#### Solution

第一眼感觉是 dp，实际上整个思路很像 dp，但其实是前缀和。

枚举 $(i,j)$，考虑对于每个格子向左，向右，向下分别能延伸出多长的全为 $1$ 的条。

设 $f^{(1)}_{i,j}$ 为 $(i,j)$ 向左最多能延伸多长，$f^{(2)}_{i,j}$ 为 $(i,j)$ 向右最多能延伸多长，$f^{(3)}_{i,j}$ 为 $(i,j)$ 向下最多能延伸多长，这个转移起来应该比较容易：

$$\begin{aligned}f^{(1)}_{i,j}&=[(i,j)=1](f^{(1)}_{i,j-1}+1)\\f^{(2)}_{i,j}&=[(i,j)=1](f^{(2)}_{i,j+1}+1)\\f^{(3)}_{i,j}&=[(i,j)=1](f^{(3)}_{i+1,j}+1)\end{aligned}$$

如果没有题目最后的四个限制，那么对于 $(i,j)$ 来说，答案即为 $\min\{f^{(1)}_{i,j},f^{(2)}_{i,j}\} \times f^{(3)}_{i,j}$（简单乘法原理）。

（对于题目新添加的四个限制的处理参考 [JohnVictor](https://www.luogu.com.cn/user/254752) 巨佬的题解）

设 $g(w,h)$ 为满足：

- $3 \le i \le w$；
- $2 \le j \le h$；
- $ij \ge s$；
- $i+j \ge x$。

的点对个数，对于 $(i,j)$ 来说即为 $g(\min\{f^{(1)}_{i,j},f^{(2)}_{i,j}\},f^{(3)}_{i,j})$，下面的问题就是怎么处理 $g$ 函数。

设 $g'(w,h)$ 为 $(w,h)$ 是否满足 $wh \ge s$，$w+h \ge x$，我们发现 $g(w,h)$ 即为 $g'(w,h)$ 的前缀和，然后我们就处理好了。

最后的答案即为：

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^mg(\min\{f^{(1)}_{i,j},f^{(2)}_{i,j}\} \times 2-1,f^{(3)}_{i,j})$$

总之这题是一道非常优秀清新的题目，整个题目也做起来很舒服，~~不像现在 EZEC 都出的什么大毒瘤题~~。

时间复杂度 $\mathcal O(nm)$。

最后注意有一些细节，就是在预处理 $g'$ 函数时要注意 T 形块宽度必须是奇数，并且最短宽是 $3$ 长是 $2$。

#### Code

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int n, m;
int a, b, s, x;
int A[3005][3005];
char S[3005];
int f1[3005][3005];
int f2[3005][3005];
int f3[3005][3005];
int g[3005][3005];

int g1 (int w, int h) {
	if (w % 2 == 0) return 0;
	if (w * h < s) return 0;
	if (w + h < x) return 0;
	return 1;
}

signed main () {
	scanf("%lld%lld%lld%lld%lld%lld", &n, &m, &a, &b, &s, &x);
	for (int i = 1; i <= n; i++) {
		scanf("%s", S);
		for (int j = 0; j < strlen(S); j++) 
			A[i][j + 1] = (long long)(S[j] - '0');
	}
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++)
//			printf("%d ", A[i][j]);
//		puts("");
//	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (A[i][j] == 0) continue;
			else f1[i][j] = f1[i][j - 1] + 1;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++)
//			printf("%d ", f1[i][j]);
//		puts("");
//	}
	for (int i = 1; i <= n; i++)
		for (int j = m; j >= 1; j--)
			if (A[i][j] == 0) continue;
			else f2[i][j] = f2[i][j + 1] + 1;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++)
//			printf("%d ", f2[i][j]);
//		puts("");
//	}
	for (int i = n; i >= 1; i--)
		for (int j = 1; j <= m; j++)
			if (A[i][j] == 0) continue;
			else f3[i][j] = f3[i + 1][j] + 1;
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++)
//			printf("%d ", f3[i][j]);
//		puts("");
//	}
	for (int w = max(3ll, a); w <= m; w++)
		for (int h = max(2ll, b); h <= n; h++)
			g[w][h] = g[w - 1][h] + g[w][h - 1] - g[w - 1][h - 1] + g1(w, h);
	int ans = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (A[i][j] == 0) continue;
			else ans += g[(min(f1[i][j], f2[i][j])) * 2 - 1][f3[i][j]];
//	for (int i = 1; i <= n; i++) {
//		for (int j = 1; j <= m; j++)
//			if (A[i][j] == 0) printf("0 ");
//			else printf("%d ", g[(min(f1[i][j], f2[i][j])) * 2 - 1][f3[i][j]]);
//		puts("");
//	}
//	for (int i = 1; i <= m; i++) {
//		for (int j = 1; j <= n; j++)
//			printf("%d ", g[i][j]);
//		puts("");
//	}
	printf("%lld\n", ans);
	return 0;
}
```

---


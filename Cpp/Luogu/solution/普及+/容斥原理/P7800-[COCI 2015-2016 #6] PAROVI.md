# [COCI 2015/2016 #6] PAROVI

## 题目描述

$\text{Mirko}$ 和 $\text{Slavko}$ 在玩一个游戏，先由 $\text{Mirko}$ 在 $1\dots N$ 中选出几组互质的数。例如当 $N=5$ 时，$\text{Slavko}$ 可以选择 $\big\{\{1,2\},\{3,4\},\{2,5\},\{3,5\},\cdots\big\}$ 中的几组。

然后轮到 $\text{Slavko}$。他需要找到一个 $x\in \big[2,n\big]$ 使得对于每组 $\{a,b\}$ 都满足以下两个条件之一：

- $a$，$b<x$

- $a$，$b\ge x$

例如，如果 $\text{Mirko}$ 选了 $\big\{\{1,2\},\{3,4\}\big\}$，那么 $x$ 可以等于 $3$。

如果 $\text{Slavko}$ 找不到满足条件的 $x$ 值，则表示 $\text{Mirko}$ 获得胜利。现在请你求出 $\text{Mirko}$ 获胜的不同情况的总数，在对 $10^9$ 取模后告诉他。

## 说明/提示

**【样例 1 解释】**

$\text{Slavko}$ 只有一种取法 $\big\{\{1,2\}\big\}$。

**【样例 2 解释】**

$\text{Slavko}$ 的其中一种取法为 $\big\{\{1,2\},\{1,3\}\big\}$。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 20$。

**【题目来源】**

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #6](https://hsin.hr/coci/archive/2015_2016/contest6_tasks.pdf) T4 PAROVI**。

**本题分值按 COCI 原题设置，满分 $120$**。

## 样例 #1

### 输入

```
2```

### 输出

```
1```

## 样例 #2

### 输入

```
3```

### 输出

```
5```

## 样例 #3

### 输入

```
4```

### 输出

```
21```

# 题解

## 作者：xh39 (赞：10)

先理解题意，其实就是用若干条线段完全覆盖 $[1,n]$。(把选中的 $a,b$ 完全理解为线段。如果完全覆盖就无法选出合法的 $x$。)

最暴力的方法是直接枚举这些线段选不选。复杂度 $O(n\times 2^{m})$。

首先将所有区间按右端点排序。可以顺序枚举右端点，再枚举左端点看是否互质。

对于搜索的优化方法很容易想到dp。设 $f(i,j)$ 为选前 $i$ 条，完全覆盖 $[1,j]$ 有多少种方案。

当 $l_{i+1}<=j$ 时，若选，则 $[1,r_{i+1}]$ 被覆盖(因为排了序，所以 $r_{i+1}>=j$)。否则覆盖的区间仍然是 $[1,j]$。

当 $l_{i+1}>j$ 时，则无论选不选都有一段区间未被覆盖都是转移到 $f(i,j)$。

所以用代码写就是:
```cpp
f[i+1][j]=(f[i+1][j]+f[i][j])%mod;
if(a[i+1].l<=j){
    f[i+1][a[i+1].r]=(f[i+1][a[i+1].r]+f[i][j])%mod;
}else{
    f[i+1][j]=(f[i+1][j]+f[i][j])%mod;
}
```
为什么当 $l_{i+1}>j$ 时的处理一定是对的呢?因为之后还是得把 $[j+1,l_i]$ 给覆盖，然后又因为我们首先排了一遍序，覆盖这段区间的线段右端点一定大于或等于 $r_i$。意味着 $[l_{i+1},r_{i+1}]$ 依然会被覆盖，所以选第 $(i+1)$ 条线段对覆盖是没有意义的。

完整代码:
```cpp
#include<iostream>
using namespace std;
struct xyq{
	int l,r;
}a[1000005];
int gcd(int a,int b){
	if(!b){
		return a;
	}
	return gcd(b,a%b);
};
long long f[1005][1005];
#define mod 1000000000
int main(){
	int n,i,j,tot=0,ykb;
	cin>>n;
	for(i=1;i<=n;i++){
		for(j=1;j<i;j++){
			if(gcd(j,i)==1){
				a[tot].l=j;
				a[tot].r=i;
				tot++;
			}
		}
	}
	f[0][a[0].r]=f[0][1]=1; 
	for(i=0;i<tot-1;i++){
		for(j=1;j<=n;j++){
			f[i+1][j]=(f[i+1][j]+f[i][j])%mod;
			if(a[i+1].l<=j){
				f[i+1][a[i+1].r]=(f[i+1][a[i+1].r]+f[i][j])%mod;
			}else{
				f[i+1][j]=(f[i+1][j]+f[i][j])%mod;
			}
		}
	}
	cout<<f[tot-1][n];
	return 0;
}
```

---

## 作者：Feyn (赞：5)

[link](https://www.luogu.com.cn/problem/P7800)

#### 暴力容斥。

虽然跑得比其它方法慢一些，但也不算太慢（最慢的点也就六十毫秒），个人觉得这种方法比较无脑，代码细节要少一些，简单来说就是好写。

首先合法的数对是可以暴力求得的，然后考虑补集转化，求出 Slavko 获胜的方案数就可以啦。但他获胜的方案怎么求呢？可以想到他的方案可以基于某种取法下 $x$ 的取值进行分类，而 $x$ 的值域很小，只有 $20$ ，于是可以暴力地考虑枚举合法 $x$ 的集合（严谨地说，枚举的是一定保证合法的 $x$ 的集合，其它可能也有一些 $x$ 的取值合法，但可以通过容斥去除重复方案）。如何计算方案呢？很简单，把不满足当前 $x$ 集合的数对全部删掉，显然剩下的数对不论如何选择都可以满足枚举出的集合合法，所以假如剩下了 $m$ 个数对，那么此时的方案数就是 $2^m$。然后就可以啦，剩下的问题就是简单容斥即可。复杂度是 $O(2^NN^2)$ 但跑不满，由于常数比较小跑起来其实也算不上太慢（但和动规还是无法相提并论呜呜呜我好弱）。

代码，个人认为比较简洁易懂。

```cpp
#include<bits/stdc++.h>
//#define feyn
#define int long long
const int N=25;
const int M=N*N;
const int mod=1e9;
using namespace std;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

inline int gcd(int s1,int s2){
	return s2==0?s1:gcd(s2,s1%s2);
}

int a[M],b[M],cnt;
int m,p[M];

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(m);
	for(int i=1;i<m;i++){
		for(int j=i+1;j<=m;j++){
			if(gcd(i,j)==1){
				cnt++;a[cnt]=i;b[cnt]=j;
			}
		}
	}
	p[0]=1;
	for(int i=1;i<=cnt;i++)p[i]=p[i-1]*2%mod;
	int ans=p[cnt];
	for(int i=1;i<(1<<m);i++){
		if(i&1)continue;
		int num=0,cc=0,sum[N]={0};bool c[N]={0};
		for(int j=2;j<=m;j++)cc+=(c[j]=(i&(1<<j-1))!=0),sum[j]=sum[j-1]+c[j];
		for(int j=1;j<=cnt;j++){
			if(sum[b[j]]-sum[a[j]]==0)num++;
		}
		ans+=p[num]*((cc&1)?-1:1);ans%=mod;
	}
	printf("%lld\n",(ans%mod+mod)%mod);
	
	return 0;
}
```

---

## 作者：Michael·F·Chen (赞：3)

### 题目描述

$Mirko$ 和 $Slavko$ 在玩一个游戏，先由 $Mirko$ 在 $1...N$ 中选出几组互质的数。例如当 $N=5$ 时，$Slavko$ 可以选择 ${(1,2),(3,4),(2,5),(3,5)}$ 中的几组。

然后轮到 $Slavko$。他需要找到一个 $x∈[2,n] $ 使得对于每组 $(a,b)$ 都满足以下两个条件之一：

- $a,b<x$
- $a,b≥x$

如果 $Slavko$ 找不到满足条件的 $x$ 值，则表示 $Mirko$ 获得胜利。现在请你求出 $Mirko$ 获胜的不同情况的总数，在对 $10^9$ 取模后告诉他。

对于 $100%$ 的数据，$1≤N≤20$。

----------

调了大半天...

#### Step 1：

发现 $n$ 最大只有 $20$ ，再跑一下可以发现最多只有 $127$ 种互素数对，所以可以先双循环枚举出所有 $n$ 以内互素对。

#### Step 2:

现在可以转化一下问题。实际上他要求的是给定一个定长区间段，现在你有很多个小区间，让你选择任意个(不能不选)区间，使他们能覆盖所有地方。求能实现的选择方案数。

这里要注意他覆盖的左端点是开区间，所以要加一。

```cpp
if(gcd(i,j)==1) d[++cnt].x=i+1,d[cnt].y=j;
```

我第一反应是递推，不过是从后往前推的。当时考虑的是 $f[i]$ 统计方案数，然后对于所有从 $i$ 开始的区间，都去做一个累加 $f[l]+=f[r]$, 但是后来发现这样子是会出大问题的，因为你统计次序无法保证，也就是说，你可能在选完某些区间已经满足要求后，还可以继续选，但是你递推时候你可能无法保证能继承得到。

然后我就卡了半天，想起来之前好像做过几道题，思维是反着来的，于是就有了下面这种做法。

#### Step 3:

到这一步实际上就有很多做法了，题解里面基本都是一些神奇的 $dp$ ~~(所以我嫖不了只能自己干了）~~。

不难发现总方案数：假设现在有 $k$ 段小区间，如果选一段，那就是 $C_k^1$ , 如果选两段，就是 $(n-1)+(n-2)+...+1$ 也就是 $C_k^2$ , 发现实际上总方案数是 $\sum C_k^i (i∈[1,k])$, 二项式好像有个模型是 $2^k$ 等于这玩意再加个 $C_k^0$ 也就是 $1$，不过手推也行。总之，总方案数 $ans=2^k-1$。

所以现在就只用算违法的方案数了。

#### Step 4:

然后我就想到了记忆化搜索。(因为注意到了Step 2中求小区间时左端点自动升序)

不过我第一次写的时候一直少考虑了一维，所以寄得很惨。

1.第一维，思考一下可以发现，这题很像 NOIP2016愤怒的小鸟，对于一段区间，如果现在不选，那么以后如果反过来选就是多余的操作，所以不妨第一维定成当前搜到了哪个编号的区间。--pos

2.第二维，如果到了某个点，肯定是需要去考虑当前搜出来的组合出来的区间最后端在哪。比如到了某个点 $o$ ,  可能此时的区间最右端在 $14$ , 也可能在 $19$ , 如果忽略了这一维度，就会出错。--r

3.第三维，不难发现，既然左端点是递增的，那么如果出现了第二维维护的 $当前选择的连续区间的最右端点$ 和新选择的小区间之间出现了空隙，那么以后的所有小区间都不可能再弥补这个空隙了。也就是说，第三维是个 $bool$ 类型，维护的是搜到当前是否满足题意要求。那如果满足，就看下一次是否满足，不满足就随便选了，后面再怎么选都是不合法的。--yon

所以就欧了 , 时间好像也不是很慢。

我一开始还有个错点，就是把 Mod 定义成了 1e9+9 , 焯 。

还有一点细节，就是取模可能取成 $0$ , 所以要用什么做个标记 $vis$ , 以及在更新右端点时要取 $max$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N=25;
const int maxn=130;
const int Mod=1000000000;

int n,cnt;
struct D{int x,y;}d[maxn];

inline int gcd(int a,int b){return b?gcd(b,a%b):a;}
inline int Max(int A,int B){return A>B?A:B;}

bool vis[maxn][N][2];
ll f[maxn][N][2];//到某个点状态为0/1的不合法方案数 
inline ll dfs(int pos,int r,bool yon){
	if(r==n&&!yon) return 0;//cut
	if(vis[pos][r][yon]) return f[pos][r][yon];
	if(pos>cnt) return yon;
	for(int i=pos;i<=cnt;++i){
		if(!yon&&d[i].x<=r+1)
			f[pos][r][yon]=(f[pos][r][yon]+dfs(i+1,Max(d[i].y,r),false))%Mod;
		else
			f[pos][r][yon]=(f[pos][r][yon]+dfs(i+1,0,true))%Mod;
	}
	f[pos][r][yon]+=(r==n&&!yon)?0:1;
	vis[pos][r][yon]=true;
	return f[pos][r][yon]%=Mod;
}

int main(){
//	freopen("parovi.in","r",stdin);
//	freopen("parovi.out","w",stdout);
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<n;++i)
		for(int j=i+1;j<=n;++j)
			if(gcd(i,j)==1) d[++cnt].x=i+1,d[cnt].y=j;
	
	ll ans=1;
	for(int i=1;i<=cnt;++i) ans=(ans<<1)%Mod;
	
	ans=ans-dfs(1,1,false);
	cout<<(ans+Mod)%Mod<<'\n';
	return 0;
}
```
· EOF


---

## 作者：☯☯枫☯☯ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7800)

[更好的阅读体验](https://www.cnblogs.com/lbh2021/p/15130039.html)

**upd：**

$[\texttt{2021.8.20}]$ 修改了一处变量名错误。

$[\texttt{2021.10.7}]$ 修改了一处下标错误。

## 算法分析：线性 dp

拿到题目首先观察数据范围，发现 $1\le n\le20$，因此我们可以先将所有的满足条件的互质的数预处理出来（以下称这些满足条件的组为“互质对”）。需要注意的一点是，$\{1,1\}$ 这组不满足条件。当 $n=20$ 时，共有 $127$ 组。

接着我们考虑 $\text{Mirko}$ 在什么条件下能获得胜利。

- 如果 $\text{Mirko}$ 没有选包含 $1$ 的互质对，那么，不论他如何选，所有被选的互质对必定满足 $a,b \ge 2$。也就是说，$\text{Slavko}$ 只需令 $x=2$。在这种情况下，$\text{Mirko}$ 无法获胜。

- 如果 $\text{Mirko}$ 没有选包含 $n$ 的互质对，与上一中情况类似，所有被选的互质对必定满足 $a,b<n$。也就是说，$\text{Slavko}$ 只需令 $x=n$。在这种情况下，$\text{Mirko}$ 同样无法获胜。

- 如果 $\text{Mirko}$ 选的互质对中包含以下情况：

  > 记他选的某两对互质对 $\{a,b\},\{c,d\}$ 且满足 $a<b<c<d$。

  那么 $\text{Slavko}$ 只需令 $x=c$，那么 $\text{Mirko}$ 依然无法获胜。

综合以上三种情况，我们发现，若要使 $\text{Mirko}$ 获胜，不能存在上述三种情况的任意一种。

我们把一组互质对看做一条 $a\to b$ 的线段，那么这个问题就转化为区间覆盖问题。即：

> 在给定线段中选出若干条，求完全覆盖 $1\to n$ 这个区间的方案数。

针对此问题，我们先将所有线段按右端点排序。可设 $dp_{i,j}$ 为选到第 $i$ 条线段，覆盖了 $1\to j$ 这个区间的方案数。初始化 $dp_{0,1}=1$，答案为 $dp_{cnt,n}$，$cnt$ 为互质对的总数。于是有：

$$\begin{cases}dp_{i,j}=dp_{i,j}+dp_{i-1,j}\\dp_{i,R_{i}}=dp_{i,R_{i}}+dp_{i-1,j}&L_{i}<=j\\dp_{i,j}=dp_{i,j}+dp_{i-1,j}&L_{i}>j\end{cases}$$

其中 $L_i$，$R_i$ 分别表示第 $i$ 条线段的左、右端点。

**code:**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define F(i,a,b) for(reg int i=(a);i<=(b);++i)
using namespace std;
bool beginning;
inline int read();
const int N=150,mod=1e9;
int n,cnt;
struct P {
	int x,y;
	bool operator <(const P& a)const {
		return y<a.y;
	}
} a[N];
namespace Dp {
	ll dp[N][25];
	void main() {
		dp[0][1]=1;
		F(i,1,cnt) {
			F(j,1,n) {
				dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;
				if(a[i].x<=j)dp[i][a[i].y]=(dp[i][a[i].y]+dp[i-1][j])%mod;
				else dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;
			}
		}
		printf("%lld\n",dp[cnt][n]);
	}
}
bool ending;
int main() {
//  system("color fc");
//  printf("%.2lfMB\n",1.0*(&beginning-&ending)/1024/1024);
	n=read();
	F(i,1,n) {
		F(j,i+1,n) {
			int gcd=__gcd(i,j);
			if(gcd==1)a[++cnt]= {i,j};
		}
	}
	sort(a+1,a+cnt+1);
	Dp::main();
	return 0;
}
inline int read() {
	reg int x=0;
	reg char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x;
}
```

[AC 记录](https://www.luogu.com.cn/record/55596920)



不过还有一种比较朴素的搜索算法~~（模拟赛时想出来的乱搞算法）~~。为了避免重复，我们限定使用的的线段数量，类似于 `ID`，记忆化搜索，记 $dp_{fro,r,res}$ 表示上一条线段是 $fro$，当前已经覆盖 $1\to r$，还要选 $res$ 条线段的情况数。这里也给出代码。

**code:**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define F(i,a,b) for(reg int i=(a);i<=(b);++i)
using namespace std;
bool beginning;
inline int read();
const int N=150,mod=1e9;
int n,cnt;
struct P {
    int x,y;
} a[N];
ll dp[N][25][N];
ll dfs(int fro,int r,int res) {
    if(!res)return r>=n;
    if(fro>=cnt)return 0;
    if(~dp[fro][r][res])return dp[fro][r][res];
    ll ans=0;
    F(i,fro+1,cnt) {
        if(a[i].x<=r) {
            ans+=dfs(i,max(a[i].y,r),res-1);
            ans%=mod;
        }
    }
    return dp[fro][r][res]=ans;
}
bool ending;
int main() {
//  system("color fc");
//  printf("%.2lfMB\n",1.0*(&beginning-&ending)/1024/1024);
    n=read();
    F(i,1,n) {
        F(j,i+1,n) {
            int gcd=__gcd(i,j);
            if(gcd==1)a[++cnt]= {i,j};
        }
    }
    ll ans=0;
    memset(dp,-1,sizeof(dp));
    F(i,1,cnt) {
        ans+=dfs(0,1,i);
        ans%=mod;
    }
    printf("%lld\n",ans);
    return 0;
}
inline int read() {
    reg int x=0;
    reg char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}
```

[AC](https://www.luogu.com.cn/record/55135118)

~~跑得慢死了。~~

欢迎交流套路，请点个赞哦~

---

## 作者：do_it_tomorrow (赞：2)

[更好的阅读体验](https://www.doittomorrow.xyz/post/coci2015-20166-parovi-de-ti-jie/)
# 题意
选择一些 $n$ 一下互质的二元组 $\{a,b\}$，求对于任意 $x\in \big[2,n\big]$  都不满足 $a,b<x$ 和 $a,b\ge x$ 的个数。
# 简化题意
因为无解的情况只发生在所有的 $\{a,b\}$ 之间没有多余的位置用于放置 $x$，所以题意可以抽象成这样：

选择一些区间互质的区间 $[a,b]$ 覆盖 $[1,n]$ 的方案数。
# 思路
设计 $f_{i,j}$ 表示前 $i$ 个字符覆盖区间 $[1,j]$ 的方案数。

对于 $f_{i,j}$，有一下合法的操作：

- 不选择第 $i$ 个线段，即 $f_{i,j}=f_{i,j}+f_{i-1,j}$。
- 选择第 $i$ 条线段并且第 $i$ 条线段的左端点可以覆盖到 $j$，即 $f_{i,r_i}=f_{i,r_i}+f_{i-1,j}$。
- 选择第 $i$ 条线段并且第 $i$ 条线段的左端点不可以覆盖到 $j$，对答案覆盖的右端点没有贡献，即 $f_{i,j}=f_{i,j}+f_{i-1,j}$。

假线段数量一共有 $k$ 条，那么答案就是 $f_{k,n}$，时间复杂度为 $O(k\times n)$。
# AC Code
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=405,mod=1e9;
struct node{int x,y;};
vector<node> v;
bool cmp(node a,node b){
    if(a.y==b.y) return a.x<b.x;
    return a.y<b.y;
}int n,f[N][30],ans;
signed main(){ 
    cin>>n;
    for(int i=1;i<=n;i++) for(int j=1;j<i;j++)  if(__gcd(i,j)==1) v.push_back({j,i});
    sort(v.begin(),v.end(),cmp);
    f[0][1]=1;
    for(int i=1;i<=v.size();i++){
        for(int j=0;j<=n;j++){
            (f[i][j]+=f[i-1][j])%=mod;
            if(v[i-1].x<=j&&j<=v[i-1].y) (f[i][v[i-1].y]+=f[i-1][j])%=mod;
            if(j<v[i-1].x) (f[i][j]+=f[i-1][j])%=mod;
        }
    }cout<<f[v.size()][n];
    return 0;
}
```

---

## 作者：ybe2007 (赞：2)

$n$ 的范围极小，因此可以想到先预处理出所有互质的数对，然后再做考量。

然后手模一下一些数据，很容易可以将这些数对转化为一条条线段，那么根据题意，答案即为：从这些线段中任选若干条使得它们能覆盖整个区间的方案数。

经计算机测试，线段数最多有 $127$ 条，因此搜索肯定是不可行的，那么对于这类区间线段覆盖方案数的问题，事实上解决此类问题的典型套路是使用动态规划。

1. 状态设计：动态规划设计状态的第一步是**确定阶段**，这一题的阶段很显然就是目前已选择的线段数量。但是仅有这一维是无法转移的，那么事实上对于区间线段覆盖的题目，将**值域**作为第二维往往是有效的处理方案。因此对于这一题，我们设 $f_{i,j}$ 表示目前已经处理了前 $i$ 条线段，值域为 $[1,j]$ 的部分已经被完全覆盖的方案数。

2. 转移方程：考虑一个阶段中，一条线段有选与不选两种决策。若不选，那么直接转移，即 $f_{i,j}=f_{i-1,j}$；若选，那么原先在这条线段上的所有值域均可以转移，即 $f_{i,R_i}=f_{i,R_i}+f_{i,j},j\in [L_i,R_i]$。

观察式子，为了保证没有后效性，我们应当先将所有线段按右端点递增的顺序排序。

当然转移方程还存在问题。对于选取这条线段的情况，还存在这条线段对转移不存在贡献的那部分！因此，转移中容易被忽略的一个式子是：$f_{i,j}=f_{i,j}+f_{i-1,j},j\in [1,L_i)$。

考试的时候想到要用动态规划，但是被状态的第二维设计给卡住了，~~说明我还是太菜了，基础太烂，题目做得太少~~。另外还有一点总结一下，就是转移时最好明确三种方式：

1. 不选的情况。

2. 选了有贡献的情况。

3. 选了也没有贡献的情况。

要不然很容易导致转移错误。

```cpp
#include<bits/stdc++.h>
#define N 130
using namespace std;
const int mod=1e9;
int n,tot;
struct F{int x,y;}a[N];
int gcd(int a,int b){return b?gcd(b,a%b):a;}
bool cmp(F a,F b){return a.y<b.y;}
int f[N][25];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) if(gcd(i,j)==1) a[++tot]=(F){i,j};
	sort(a+1,a+1+tot,cmp);
	f[0][1]=1;
	for(int i=1;i<=tot;i++)
	{
		//不选这条线段 
		for(int j=1;j<=n;j++) f[i][j]=f[i-1][j];
		//选了这条线段
			//有贡献的部分 
			for(int j=a[i].x;j<=a[i].y;j++) f[i][a[i].y]=(f[i][a[i].y]+f[i-1][j])%mod;
			//不贡献的部分 
			for(int j=1;j<a[i].x;j++) f[i][j]=(f[i][j]+f[i-1][j])%mod;
	}
	printf("%d\n",f[tot][n]);
}
```

---

## 作者：A_Sunny_Day (赞：2)

## COCI2015/2016 Contest#6 D 游戏

​	题目链接：[COCI2015-2016#6 PAROVI](https://www.luogu.com.cn/problem/P7800)

---

​	首先，我们预处理出所有互质对，显然，互质对的个数最多只有 $\dfrac{n\times(n-1)}{2}$ 个。我们将互质对 $(i,j)$ 抽象成一条**左端点在** $i$，**右端点在** $j$ **的线段** ，那么我们要求的就是这么多条线段，任选其中的几条构成一条**连续的**，左端点在 $1$，右端点在 $n$ 的线段。考虑使用 dp 解决这个问题。

​	我们设 $dp_{i,j}$ 表示前 $i$ 条线段，构成**有效连续**部分为 $1$ 到 $j$ 的线段的方案数。容易得到转移式
$$
dp_{i,R_i}=\sum_{k=L_i}^{R_i}{dp_{i-1.k}}
$$
​	其中，$L_i,R_i$ 分别表示第 $i$ 条线段的左右端点。注意到，这个转移式如果正确，那么所有 $R$ 比 $R_i$  的点都必须在 $i$ 转移之前转移，所以我们得将所有线段按右端点排序。但是只有这个式子是不对的，对于**有效连续部分的右段**在 $[1,L_i-1]$ 区间内的这些线段的方案数也要转移，而且转移后的**有效连续部分的右端**不变。相当于 $i$ 这条线段对这种方案**没有任何贡献**。但它们的方案是不同的，因为 $i$ 被选了。所以还有一条式子：

$$
dp_{i,j}=dp_{i,j}+dp_{i-1,j}\;(j<L_i)
$$
​	接下来按照这些式子转移就行了。

​	转移部分的代码如下：

```cpp
	for(int i=1;i<=cnt;++i)
	{
		for(int j=1;j<a[i].l;++j)
			dp[i][j]=dp[i-1][j];
		for(int j=a[i].l;j<=n;++j)
			dp[i][a[i].r]=(dp[i-1][j]+dp[i][a[i].r])%MOD;
		for(int j=1;j<=n;++j)
			dp[i][j]=(dp[i-1][j]+dp[i][j])%MOD;
	}
```

​	全部代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll MOD = 1e9;
int n;
int gcd(int x,int y)
{
	if(y==0) return x;
	return gcd(y,x%y);
}
struct line
{
	int l,r;
	bool operator < (const line &x)const
	{
		return r<x.r;
	}
}a[405];
ll dp[405][25];
int main()
{
	scanf("%d",&n);
	int cnt=0;
	for(int i=1;i<=n;++i)
		for(int j=i+1;j<=n;++j)
			if(gcd(i,j)==1) a[++cnt]=line{i,j};
	sort(a+1,a+1+cnt);
	dp[0][1]=1;
	for(int i=1;i<=cnt;++i)
	{
		for(int j=1;j<a[i].l;++j)
			dp[i][j]=dp[i-1][j];
		for(int j=a[i].l;j<=a[i].r;++j)
			dp[i][a[i].r]=(dp[i-1][j]+dp[i][a[i].r])%MOD;
		for(int j=1;j<=n;++j)
			dp[i][j]=(dp[i-1][j]+dp[i][j])%MOD;
	}
	printf("%lld",dp[cnt][n]%MOD);
	return 0;
}
```

总结：dp 的阶段划分一定要清楚明白，如这题划分成**不选，选了有贡献，选了无贡献**。如果不划分清楚明白的话很可能会把**选了无贡献**这部分忘记转移使答案错误。

---

## 作者：XuYueming (赞：1)

## 前言

不能在同一个坑上栽第三次！

题目链接：[原题](https://www.luogu.com.cn/problem/P7800)；[加强版](https://www.luogu.com.cn/problem/U507153)。

[更好的阅读体验](https://www.cnblogs.com/XuYueming/p/18559166)。

## 题意简述

$1 \sim n$ 数轴，你可以使用若干条线段 $[l, r]$ 来覆盖，其中要满足 $\gcd(l, r) = 1$。问你能够完全覆盖数轴的方案数，对 $M$ 取模。

$2 \leq n \leq 10^4$，$2 \leq M \leq 10^9+7$。不保证 $M$ 为质数。

**有趣的事实：**

正解可以做到 $\mathcal{O}(n^2)$，尽管原题 $n \leq 20$。原题固定模数，这里动态模数为了卡打表。

## 题目分析

我们有理论 $\mathcal{O}(n^2 \log n)$ 的暴力找出 $n$ 以内互质的数对，但是太劣了。

可以证明，值域在 $n$ 以内，互质的数对个数为 $\dfrac{3}{\pi^2}n^2$ 级别，~~我还以为不多呢~~。

我们知道 $\varphi(n) \sim \dfrac{n}{\zeta(2)}$，但是作者太菜了，不会证明。所以数对个数为 $\sum \limits _ {i = 1} ^ n \varphi(i) = \Theta\Big(\dfrac{n^2}{\zeta(2)}\Big)$。

据说欧拉又解决了 $\zeta(2) = \dfrac{\pi^2}{6}$，但是作者还是太菜了，不会证明。所以综合考虑高斯求和里 $\frac{1}{2}$ 的常数，互质的数对个数为 $\dfrac{3}{\pi^2}n^2$ 级别。

明明只有 $\mathcal{O}(n^2)$ 个数对，我们能不能减少冗余计算？答案是肯定的。我们考虑辗转相减法求 $\gcd$ 的逆过程，从 $(1, 1)$ 开始，每次从 $(a, b)$ 走向 $(a, a+b), (b, a+b)$，可以证明，这样能够不重不漏找到所有互质对。注意 $(1, 1)$ 可能重复统计的细节。

```cpp
#include <cstdio>
#include <utility>

const int N = 10010;

int n, head = 1, tail;
std::pair<int, int> Q[N * N];

signed main() {
    n = 10000;
    Q[++tail] = { 1, 1 }, ++head;
    Q[++tail] = { 1, 2 };
    while (head <= tail) {
        auto &[x, y] = Q[head++];
        if (x + y > n) continue;
        Q[++tail] = { y, x + y };
        Q[++tail] = { x, x + y };
    }
    printf("%d", tail);
    return 0;
}
```

于是，从 $3.75$ 秒优化至 $0.16$ 秒，我们找出了所有可供使用的线段。下一步就是考虑用这些线段计算答案了。

计算肯定是通过 DP 的方式。阶段显然是当前决策到了第几条线段，但是状态是什么？也就是说怎么刻画一个局面？使用「已经完全覆盖了 $1 \sim j$」作为状态合适吗？不太好思考，我们不妨从别的角度来思考问题。

对于线段覆盖类问题，我们一般按照某一端点进行排序，左右端点是本质相同的，这里我们不妨按照左端点从小到大考虑。这对我们的状态设计有什么帮助呢？我们发现，当我们按照左端点排过序后决策，一个最终可能合法的局面，在任意时刻都覆盖了数轴的一段连续前缀。这样考虑，如果当前选择了某一条线段，和上一次之间留有空隙，那么这个空隙在之后都不会被填上，因为之后的线段的左端点不小于当前线段。所以可以使用这种状态。

状态设计好后，转移方程应该信手拈来了。我们再明确一下，记 $f_{i,j}$ 表示决策了前 $i$ 条线段，覆盖了数轴 $[1, j]$ 的前缀，方案数为多少。从 $f_{i-1,j'}$ 转移到 $f_{i,j}$，若不选择当前线段 $[l_i,r_i]$，则继承 $i - 1$ 的方案数，即初始 $f_{i,j}=f_{i-1,j}$，接下来考虑选择这条线段的转移。

1. $j' < l_i$。
    正如上文所言，不能选择当前线段。
1. $j' \in [l_i, r_i)$：
    拼上当前线段后，覆盖的前缀增长为 $[1, r_i]$，故 $f_{i,r_i} \gets f_{i,r_i}+\sum\limits_{j=l_i}^{r_i-1}f_{i-1,j}$。
1. $j' \geq r_i$：
    当前线段选择后，不会改变覆盖的前缀，故 $f_{i,j}\gets f_{i,j}+f_{i-1,j}$。

边界 $f_{0,1} = 1$，答案为 $f_{k, n}$，其中 $k = \sum\limits_{i=1}^n\varphi(i)$，即线段条数。

已经能够单次 $\mathcal{O}(n)$ 转移了，但是这样时间复杂度是 $\mathcal{O}(n^3)$ 的。滚一滚不做赘述，我们来观察以下代码：

```cpp
for (int i = 1; i <= n; ++i) {
    for (int j = i + 1; j <= n; ++j)
        if (cop[i][j]) {  // i and j are coprimes
            for (int o = j; o <= n; ++o) f[o] = add(f[o], f[o]);
            for (int o = i; o < j; ++o) f[j] = add(f[j], f[o]);
        }
}
```

我们发现，这就是一个后缀区间乘 $2$、区间求和、单点加操作。有人的 DNA 已经动了，开始线段树模式了。千万不要数据结构学傻了，这么优美的形式，当然要使用优雅地解决方法呀。

倘若不看别的，但看这个乘 $2$ 操作，我们完全可以一次性扫一遍，只需要扫的时候，维护当前需要乘多少次 $2$ 即可。

但看这个区间求和，也可以线性扫一遍，同时维护 $[i, j)$ 的 $f$ 的和即可。

两者，显然可以融合。唯一要小心处理的是 $f_j$ 先自乘 $2$，再加。维护方法很多，给出我的方式，可能有些笨：

```cpp
for (int i = 1; i <= n; ++i) {
    int sum = 0;
    for (int j = n; j >= i; --j) toadd(sum, f[j]);
    for (int j = n; j > i; --j) {
        tosub(sum, f[j]);
        if (cop[i][j])
            toadd(f[j], f[j]), toadd(f[j], sum);
    }
    for (int j = i + 1, tag = 1; j <= n; ++j) {
        tomul(f[j], tag);
        if (cop[i][j]) toadd(tag, tag);
    }
}
```

于是，我们可以以严格 $\mathcal{O}(n^2)$ 的时间复杂度解决此问题。

## 代码

完整代码、Generator、数据范围，请移步[我的博客](https://www.cnblogs.com/XuYueming/p/18559166)。

## 反思

线段覆盖类问题，这种处理方法是套路的。做完这题可以尝试 [\[USACO20FEB\] Help Yourself P](https://www.luogu.com.cn/problem/P6144)。

---

## 作者：taiyuu (赞：1)

上述的题解已阐述清楚，可以将题目转化为完全覆盖 $[1,n]$ 的方案数问题。

因为我实在不太机灵，没想到二维dp的转移。只想到用一维数组进行动规，即 $dp_i$ 代表着完全覆盖 $[1,i]$ 的方案数，显然 $dp_i$ 中一定含有至少一条右端点为i的线段。


思考 $dp_i$ 怎么得到，既然一定含有一条右端点为 $i$ 的线段，那么不妨按照左端点从左到右的顺序依次枚举所有右端点为 $i$ 的线段 $s_x$ ,每次计算含有 $s_x$，不含有 $s_y$（其中 $y<x$ ）的情况。

①即按照顺序讨论：

一定含有 $s_1$ ，可选 {$s_2$,$s_3$,$s_4$……}

一定含有 $s_2$ ，可选 {$s_3$,$s_4$,……}

一定含有 $s_3$ ，可选 {$s_4$,……}

……

这样枚举能够保证一定含有右端点为 $i$ 的线段，并且不会有重复。

在讨论**一定含有线段 $s_x$ 的情况**时，假设线段 $s_x$ 的左端点为 $j$ ，如果需要保证 $[1,i]$ 全覆盖，则需要保证有任意条线段全覆盖 $[1,k]$ ，其中 $i> k\ge j$ 。②全覆盖 $[1,k]$ 的方案数为 $dp_k$ ,我们可以从左到右枚举 $k$ 。

这时，所有线段由三种线段构成，第一种是**一定含有线段 $s_x$ 的**右端点为 $i$ 的线段组，第二种是全覆盖  $[1,k]$ 的线段组，第三种显然还有左右端点在 $[k+1,i-1]$ 之间的线段组（否则会变为前两种线段）。

根据乘法原理，方案数 = 第一种线段数量 * 第二种线段数量 * 第三种线段数量

比起大佬们的想法更麻烦，但是对我而言更好理解一些。

![三类线段](https://cdn.luogu.com.cn/upload/image_hosting/8qjfuo1m.png)

```c
#include<bits/stdc++.h>
using namespace std;
int read(){
	char ch=getchar();
	int sz=0,fh=1;
	while(!isdigit(ch)){if(ch=='-')fh=-1;ch=getchar();}
	while(isdigit(ch)){sz=sz*10+(ch-'0');ch=getchar();}
	return sz*fh;
}

int inp[25][25],n,asum[25],btsum[25][25];
long long ans[25],temp,cursum,t2;
const int mod=1e9;
void getinp(){
	for(int i=1;i<=n;++i){
		for(int j=i+1;j<=n;++j){
			if(__gcd(i,j)==1){
				inp[i][j]=true;
			}
		}
	}
	for(int i=2;i<=n;++i){
		for(int j=1;j<i;++j){
			asum[i]+=(inp[j][i]?1:0);
		}
	}
	for(int len=1;len<n;++len){
		for(int j=1;j+len<=n;++j){
			btsum[j][j+len]=btsum[j+1][j+len]+btsum[j][j+len-1]-btsum[j+1][j+len-1]+(inp[j][j+len]?1:0);//求有多少左右端点都在区间内的线段 
		}
	}
	return ;
}

long long qpow(long long base,long long x){
	long long rst=1;
	while(x){
		if(x&1)	rst=rst*base%mod;
		x>>=1;
		base=base*base%mod;
	}
	return rst;
}

int main(){
	cin>>n;
	getinp();
	ans[1]=1;
	for(int i=2;i<=n;++i){//右端点 
		cursum=asum[i];//以i为右端点的一共多少个
		for(int j=1;j<i;++j){//左端点 
			if(inp[j][i]){// 以i为右端点j为左端点的线段必选 
				--cursum;//剩下的线段随便选或者不选 
				temp=0;
				for(int k=j;k<i;++k){//枚举k，使得1~k和j~i有交集能够全覆盖1~i 
					temp+=ans[k]*qpow(2,btsum[k+1][i-1]);//全覆盖1~k的方案数乘以第三类线段 
					temp%=mod;
				}
				ans[i]+=temp*qpow(2,cursum)%mod;
				ans[i]%=mod;
			}
		}
	}
	cout<<ans[n]%mod;
	return 0;
}

```

---

## 作者：Gmt丶FFF (赞：1)

读完题后可以首先发现，编号 $1$ 和 $n$ 的点都是必须要选的，否则 $\text{Slavko}$ 可以选择 $2$ 或者 $n$ 取得胜利。

而对于中间的数如果存在两对数 $(l_1,r_1)$ $(l_2,r_2)$ 若 $l_1< l_2$ 且 $r_1\le l_2$ 那么可以选择数 $l_2$ 取胜。

那么只有 $r_1>l_2$ 时，取 $l_2$ 是无法取胜的，此时若把两对数看成一个区间，那么就可以将本题看成一个左闭右开的区间覆盖问题。

由于求方案数，考虑 dp。

预处理出来所有互质的数对，并按左区间为关键字排序。

设 $f_{i,j}$ 代表对于第 $i$ 个区间，已经覆盖到第 $j$ 格的方案数。

初始化：对于数对 $(l_i,r_i)$，如果 $l_i=1$，那么 $f_{i,r_i}=1$。

转移：

选择这个区间：$f_{i,\max(j,r_i)}=f_{i,\max(j,r_i)}+f_{i-1,j}(l_i\le j)$

不选这个区间：$f_{i,j}=f_{i,j}+f_{i-1,j}$

答案即为 $f_{num,n}\hspace{0.1cm}\text{其中 num 代表互质数对个数}$。 

复杂度约为 $O(n^3)$。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
const int mod=1e9;
const int N=25;
int n,cnt,f[N*N][N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
struct node
{
	int l,r;
}a[N*N];
int cmp(node fi,node se)
{
	return fi.r>se.r;
}
signed main()
{
	freopen("parovi.in","r",stdin);
	freopen("parovi.out","w",stdout);
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)if(gcd(i,j)==1)a[++cnt]=(node){i,j};
	}
	for(int i=1;i<=cnt;i++)
	{
		if(a[i].l==1)f[i][a[i].r]=1;
		for(int j=1;j<=n;j++)
		{
			f[i][j]+=f[i-1][j];
			f[i][j]%=mod;
			if(a[i].l<=j)f[i][max(j,a[i].r)]+=f[i-1][j],f[i][max(j,a[i].r)]%=mod;
		}
	}
	int ans=f[cnt][n];
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ConstantModerato (赞：0)

题目大意：从 $[1,n]$ 中选若干个互质的数对，使得 $[1,n]$ 的所有数都被完全覆盖。例如 $[3,4],[5,6]$ 是没有完全覆盖 $[3,6]$ 的。

思路一：看到这题的第一秒，我们可以轻易的想到一个转移：

$f_i$ 表示覆盖 $[1,i]$ 的方案总数，然后考虑每一个与 $i$ 互质的数 $v_j$，$(v_k < v_j,k < j)$ 我们把这个区间 $[v,i]$ 给选了，显然如果我们选了 $v_k$，我们再选 $v_j$，$[v_k,i]$ 也是会被覆盖的。所以我们可以快速的得到转移。

$$f_i = \sum_{\gcd(i,v) = 1}f_v \times 2^{cnt}$$

其中 $cnt$ 表示有多少个选了不受影响。

代码如下：

```
	n = read();
	for (int i = 1;i <= n;i++)
    	    for (int j = i;j >= 1;j--)
       		if (gcd(i,j) == 1) a[i].push_back(j);
	f[1] = 1;
	for (int i = 2;i <= n;i++){
        int cnt = 0;
        for (auto v : a[i]){
            cnt++;//选了也不受影响
            For(j,v,i - 1) add(f[i],f[j] * qpow(2,cnt - 1) % Mod);//cnt - 1 是因为要选 [v,i]
        }
    } cout << f[n] << endl;
```

喜提 $0$ 分。

让我们沉着冷静的观察为啥会如此。

我们观察到在转移时，我们只考虑了右端点到情况，但是实际上在 $[v_k,i]$ 这个区间里还有可能有其他区间存在，而我们没有进行考虑。

现在我们知道问题出在哪里了，于是我们进行更改，将 $[v,i - 1]$ 为右端点的区间全部考虑。

```
signed main(){
    n = read();
    for (int i = 1;i <= n;i++)
        for (int j = i;j >= 1;j--)
           if (gcd(i,j) == 1) a[i].push_back(j);
    for (int i = 1;i <= n;i++)
        sum[i] = sum[i - 1] + a[i].size();
    f[1] = 1;
    for (int i = 2;i <= n;i++){
        int cnt = 0;
        for (auto v : a[i]){
            cnt++;
            add(f[i],f[v] * qpow(2,sum[i - 1] - sum[v] + cnt - 1) % Mod);
        }
    } 
    //for (int i = 1;i <= n;i++)
        //debug(i),debug(f[i]);
    cout << f[n] << endl;
    return 0;
}
```

喜提 $0$ 分。

让我们再次观察为什么会如此。

我们看到，在 $[v,i]$ 这段区间乱选区间，可能会取到一个左端点 $l$，使得 $l < v$，这样，同时应该也可以转移到更小的点，也就是存在一个 $k < v$，$f_i$ 同样也需要 $f_k$ 的转移。

其实我们可以发现，一维的 $dp$ 略有局限性，因为它在选的时候无法保证有一些端点，可能会 $< v$，也有可能 $>v$，这两个限制会左右转移的状态，致使我们没有办法正常的转移。

例如我们考虑下面的另一份代码：

```
int n,f[N][N],val[N][N],cnt[N][N];
vector<int> a[N];
signed main(){
    n = read();
    for (int i = 2;i <= n;i++)
        for (int j = i - 1;j >= 1;j--)
            if (gcd(i,j) == 1) a[i].push_back(j);
    for (int i = 1;i <= n;i++){
        for (int j = i + 1;j <= n;j++){
            for (int k = i + 1;k <= j;k++){
                for (auto v : a[k])
                    if (v >= i) cnt[i][j]++;
            }
        }
    }
    for (int i = 1;i <= n;i++) f[i][i] = 1;
    for (int len = 2;len <= n;len++){
        for (int i = 1;i <= n;i++){
            int j = i + len - 1;
            if (j > n) continue;
            for (auto v : a[j])
                if (v >= i)
                    add(f[i][j],f[i][v] * qpow(2,cnt[v][j] - 1) % Mod);
        }
    } 
    for (int i = 1;i <= n;i++){
        for (int j = i;j <= n;j++){
           //debug(i),debug(j),debug(f[i][j]),puts("");
        }
    }
    cout << f[1][n] << endl;
    return 0;
}
```

我们用 $cnt_{i,j}$ 表示在 $[i,j]$ 之间的状态转移数量，$f_{i,j}$ 表示能覆盖 $[i,j]$ 的方案数。而我们选取时就会从 $[v,j]$ 乱选，算少的原因也是因为我们可以从 $[v,j]$ 掏出一些可以覆盖的节点，导致可以转移到更少的节点。

接下来我们考虑，既然算正的可能会有阴间的覆盖，那不如我们直接计算 $[i,j]$ 中不符合题目的状态，然后用 $2^{cnt_{i,j}}$ 减去它。

考虑用 $g_{i,j}$ 来表示 $[i,j]$ 里不符合的有多少个。

但是我们发现，维护 $g$ 数组也是困难的，关键在于也同时会重复。

所以我们给 $g$ 再加上一维，$g_{i,j,k}$ 表示 $[i,j]$ 中可以选出 $k$ 个数使得该区间不合法。这样我们就可以愉快的转移了。

```
int n,f[N][N],g[N][N][N],val[N][N],cnt[N][N];
vector<int> a[N];
signed main(){
    n = read();
    for (int i = 2;i <= n;i++)
        for (int j = i - 1;j >= 1;j--)
            if (gcd(i,j) == 1) a[i].push_back(j);
    for (int i = 1;i <= n;i++){
        for (int j = i + 1;j <= n;j++){
            for (int k = i + 1;k <= j;k++){
                for (auto v : a[k])
                    if (v >= i) cnt[i][j]++;
            }
        }
    }
    for (int i = 1;i <= n;i++) f[i][i] = 1;
    for (int len = 2;len <= n;len++){
        for (int i = 1;i <= n;i++){
            int j = i + len - 1;
            if (j > n) continue;
            if (len == 2){
                if (i == 1) g[i][j][1] = 1;
                else g[i][j][2] = 1;
                f[i][j] = 1;
                continue;
            }
            for (int k = i;k <= j - 1;k++){
                add(g[i][j][1],f[i][k] * f[k + 1][j]);
            } 
            for (int k = i;k <= j - 1;k++){
                for (int num = 2;num <= j - i + 1;num++){
                    add(g[i][j][num],g[i][k][num - 1] * f[k + 1][j]);
                }
            } 
            f[i][j] = qpow(2,cnt[i][j]);
            for (int num = 1;num <= j - i + 1;num++)
                del(f[i][j],g[i][j][num]);
        }
    } 
    cout << (f[1][n] % Mod + Mod) % Mod<< endl;
    return 0;
}
```




---

## 作者：fight_for_humanity (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P7800)，[cnblogs](https://www.cnblogs.com/fight-for-humanity/p/18563751)。

#### 题意简述

用满足 $\gcd(l,r) = 1$ 的线段 $[l,r]$ 完全覆盖区间 $[1,n]$，求方案数。

#### 题目分析

有一个套路：遇到线段覆盖相关问题，线段根据左端点排序后覆盖，覆盖的联通块个数不减。

假设我们已经处理出来了这些合法线段，明显的：$dp_{i,j}$ 表示前 $i$ 条线段覆盖了 $[1,j]$ 的方案数。转移就是 $dp_{i,j} \gets dp_{i-1,j}$ 表示不选这条线段，和 $dp_{i,j} \gets dp_{i-1,\max(j,r)},j \ge l$ 表示选了这条线段。由于按照左端点排序带来的性质，当 $j< l$ 时连通块个数增多，那块空出来的不再会被覆盖到，与我们要求的无关，直接不理它。所以有以下代码：

```cpp
const int N = 25,mod = 1e9;
int f[N*N][N],n,ans;
struct P{ int l,r; };
vector<P> e;

inline int add(int x,int y){ return x + y >= mod ? x + y - mod : x + y; }
inline void toadd(int &x,int y){ x = add(x,y); }

signed main(){
	scanf("%d",&n);
	for(int i = 1;i<=n;++i)
		for(int j = i;j<=n;++j)if(__gcd(i,j) == 1 && i != j)
			e.push_back({i,j});
	int tot = e.size();
	f[0][1] = 1;
	for(int i = 1;i<=tot;++i){
		for(int j = e[i-1].l;j<=n;++j){
			toadd(f[i][j],f[i-1][j]);
			toadd(f[i][max(j,e[i-1].r)],f[i-1][j]);
		}
	}
	printf("%d",f[tot][n]);
	return 0;
}
```

这已经可以通过了，但数据范围更大一些呢？观察加入每条线段对 $f$ 的贡献：将 $r$ 这个位置上加上 $\sum_{i=l}^rf_i$，将 $[r+1,n]$ 翻倍。我一开始直接就无脑线段树维护，太蠢了。时间复杂度是 $O(cnt \times \log n)$ 的。

我们的更新顺序是固定左端点向右扫右端点，而我们乘的又是一个后缀，我们加的是一个前缀。所以我们可以对于相同的 $l$ 一起处理，在右移 $r$ 的过程中，实时维护当前要乘多少和一个 $f$ 的前缀和 $sum$，舍弃了加入线段，而是遍历点。代码如下：

```cpp
f[1] = 1;
for(int l = 1;l<=n;++l){
	int now = 1;
	sum[l-1] = f[l-1];
	for(int r = l;r<=n;++r){
		if(gcd[l][r] == 1 && l != r){	
			f[r] = mul(f[r], now);
			sum[r] = add(sum[r-1], f[r]);
			toadd(f[r], sub(sum[r], sum[l-1]));
			now = mul(now, 2);
		}else f[r] = mul(f[r], now);
		sum[r] = add(sum[r-1], f[r]);
	}
}
printf("%d",f[n]);
```

这里的 $f_i$ 就表示当前覆盖 $[1,i]$ 的方案数。细节：由于 $sum$ 的意义在发生变化，所以要在必要时更新 $sum$。初值由于是 $f_{1} = 1$，中间转移时判掉 `l != r` 就是避免这点。最终转移的时间复杂度 $O(n^2)$。当然我们可以优化处理 $gcd$ 的过程，也算是个 trick 吧，从 [大佬XuYueming的博客](https://www.cnblogs.com/XuYueming/p/18559166) 学的。本质就是辗转相减的逆过程，像遍历这棵二叉树一样用队列实现，代码帖这：

```cpp
void init(){
	q[++tail] = {1, 1}; ++head;
	q[++tail] = {1, 2};
	while(head <= tail){
		pii cur = q[head++];
		if(cur.second > n)continue;
		q[++tail] = {cur.first, cur.first + cur.second};
		q[++tail] = {cur.second, cur.first + cur.second};
	}
	for(int i = 1;i<=tail;++i)gcd[q[i].first][q[i].second] = 1;
}
```

#### 总结

1. 区间覆盖相关的，与连通性相关的，按左端点排序；
2. 观察式子，同时结合更新过程以优化；
3. 处理 $\gcd$ 的技巧。

---


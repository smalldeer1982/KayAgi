# 工程规划

## 题目描述

造一幢大楼是一项艰巨的工程，它是由 $n$ 个子任务构成的，给它们分别编号 $1,2,\cdots,n\ (5≤n≤1000)$。由于对一些任务的起始条件有着严格的限制，所以每个任务的起始时间 $T_1,T_2,\cdots,T_n$ 并不是很容易确定的(但这些起始时间都是非负整数，因为它们必须在整个工程开始后启动)。例如：挖掘完成后，紧接着就要打地基；但是混凝土浇筑完成后，却要等待一段时间再去掉模板。

这种要求就可以用 $m\ (5≤m≤5000)$ 个不等式表示，不等式形如 $T_i-T_j≤b$ 代表 $i$ 和 $j$ 的起始时间必须满足的条件。每个不等式的右边都是一个常数 $b$，这些常数可能不相同，但是它们都在区间 $(-100,100)$ 内。

你的任务就是写一个程序，给定像上面那样的不等式，找出一种可能的起始时间序列 $T_1,T_2,\cdots,T_n$，或者判断问题无解。对于有解的情况，要使最早进行的那个任务和整个工程的起始时间相同，也就是说，$T_1,T_2,\cdots,T_n$ 中至少有一个为 $0$。


## 说明/提示

由@zhouyonglong提供SPJ


## 样例 #1

### 输入

```
5 8
1 2 0
1 5 -1
2 5 1
3 1 5
4 1 4
4 3 -1
5 3 -1
5 4 -3```

### 输出

```
0
2
5
4
1
```

## 样例 #2

### 输入

```
5 5
1 2 -3
1 5 -1
2 5 -1
5 1 -5
4 1 4```

### 输出

```
NO SOLUTION
```

# 题解

## 作者：L_M_ (赞：39)

萌新刚学会差分约束，看楼下各位大佬讲的都好简略~~根本看不懂~~，就写一篇详细点儿证明差分约束的题解

众所周知，差分约束有m个不等式，要找到一组解（本题中是非负解）满足所有约束，因为不等式都是差分形式，又要满足所有约束，所以叫差分约束。

我们采取这样的方式建边：对于ai - aj <= b,从j向i连一条边权为b的边

#### 原因：ai - aj <= b十分形似 dis[i] - dis[j] <= b,即dis[i] <= dis[j] + b，在一个有最短路的图中，对于每一个点均满足这个等式，所以我们想把ai转化为i的最短路，最后求出的最短路就是答案

#### **关于无解：当图中存在负环即无解**

#### 一方面，如果有负环，原图中没有最短路，因此无解。从另一个角度考虑，如果有负环，则意味着永远不可能满足不等式（dis[i]和dis[j]都可以无穷小），所以无解（不懂的话可以画一个有两个点的图试一试

细节：防止图不联通的情况，我们建一个超级源点S，由S向其他点连一条边权为0的边，图即联通

spfa判负环已有说明，不再赘述

上代码：
```
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
inline int read()
{
    int ans = 0,op = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') op = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        (ans *= 10) += ch - '0';
        ch = getchar();
    }
    return ans * op;
}
const int maxn = 2005;
struct egde
{
	int to,next,cost;
}e[maxn * 10];
int fir[maxn],alloc;
inline void adde(int u,int v,int w)
{
	e[++alloc].next = fir[u];
	fir[u] = alloc;
	e[alloc].to = v;
	e[alloc].cost = w;
}
int n,m;
int dis[maxn],popst[maxn],minm;
bool instack[maxn];
void spfa(int s)
{
	queue<int> q;
	memset(dis,0x3f,sizeof(dis));
	dis[s] = 0;
	q.push(s);
	instack[s] = 1;
	while(q.size())
	{
		int u = q.front();
		q.pop();
		popst[u]++;
		if(popst[u] > n - 1) { printf("NO SOLUTION"); return;}
		instack[u] = 0;
		for(int i = fir[u];i;i = e[i].next)
		{
			int v = e[i].to,w = e[i].cost;
			if(dis[v] > dis[u] + w)
			{
				dis[v] = dis[u] + w;
				if(!instack[v]) q.push(v),instack[v] = 1;
			}
		}
	}
	for(int i = 1;i <= n;i++) minm = min(minm,dis[i]);
	for(int i = 1;i <= n;i++) printf("%d\n",dis[i] - minm);
}
int main()
{
	n = read(),m = read();
	for(int i = 1;i <= m;i++)
	{
		int u = read(),v = read(),w = read();
		adde(v,u,w);	
	}
	for(int i = 1;i <= n;i++) adde(n + 1,i,0);
	spfa(n + 1);
}
```


---

## 作者：SDqwq (赞：11)

[${\color{Orange}My}$ ${\color{Yellow}Blog}$](https://www.luogu.com.cn/blog/Sham-Devour/)

[P1260](https://www.luogu.com.cn/problem/P1260)

[前置知识：差分约束](https://www.luogu.com.cn/blog/Sham-Devour/ci-fen-yue-shu)

题意：给出 $n$ 个数 $t_{i}$ 和 $m$ 个形如 $t_{i}-t_{j}\le b$ 的不等式，求出一组 **非负整数** 解，且必有一个 $t_{i}$ 为 $0$，如果无解输出 `NO SOLUTION`。

我们将 $t_{i}-t_{j}\le b$ 转化为 $t_{i}\le t_{j}+b$ 。

那么我们再来看一下 SPFA 是怎么更新 $dis$ 数组是怎么更新的。

```cpp
for (int i = elast[u]; i != 0; i = e[i].next)
	if (dis[e[i].to] > dis[u] + e[i].len) {
		dis[e[i].to] = dis[u] + e[i].len;
		if (!vis[e[i].to]) {
			q.push(e[i].to);
			vis[e[i].to] = true;
		}
	}
```

也就是 $dis_{i}=\min\left\{dis_{j}+<j,i>\right\}$。

于是在遇到 $t_{i}\le t_{j}+b$ 这样的不等式时，我们可以从 $j$ 到 $i$ 建一条边权为 $b$ 的 **有向边**。

为了避免图不连通的情况，我们需要一个超级源点 $n+1$ ，与点 $i$ 之间连一条边权为 $0$ 的边。

**注意：无解就是有负权回路的情况，需要判断 SPFA 的入队次数，如果一个点的入队次数 $\ge n$的话，说明有负环，输出 `NO SOLUTION`**。

最后跑 SPFA 求最短路即可。

**由于是非负整数解，所以求出答案中的最小值，把每个答案减去这个最小值即可。**

### Problem Solving！

### code：

```cpp
#include <stdio.h>
#include <bits/stdc++.h>

using namespace std;

int n, m, cnt, minn = 1e9, elast[1005], dis[1005], num[1005];
bool vis[1005];

struct edge {
	int to, len, next;
} e[6005];

queue<int> q;

void add (int u, int v, int w) {
	e[++cnt].to = v;
	e[cnt].len = w;
	e[cnt].next = elast[u];
	elast[u] = cnt;
}

bool spfa (int x) {
	dis[x] = 0;
	q.push(x);
	vis[x] = true;
	num[x]++;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		vis[u] = false;
		for (int i = elast[u]; i != 0; i = e[i].next)
			if (dis[e[i].to] > dis[u] + e[i].len) {
				dis[e[i].to] = dis[u] + e[i].len;
				if (!vis[e[i].to]) {
					q.push(e[i].to);
					vis[e[i].to] = true;
					num[e[i].to]++;
					if (num[e[i].to] == n)
						return false;
				}
			}
	}
	return true;
}

int main () {
	scanf("%d %d", &n, &m);
	memset(dis, 0x3f3f3f3f, sizeof(dis));
	for (int i = 1; i <= m; i++) {
		int x, y, z;
		scanf("%d %d %d", &x, &y, &z);
		add(y, x, z);
	}
	for (int i = 1; i <= n; i++)
		add(n + 1, i, 0);
	bool flag = spfa(n + 1);
	if (!flag) {
		printf("NO SOLUTION");
		return 0;
	}
	for (int i = 1; i <= n; i++)
		minn = min(minn, dis[i]);
	for (int i = 1; i <= n; i++)
		printf("%d\n", dis[i] - minn);
	return 0;
}
```

---

## 作者：一只书虫仔 (赞：8)

#### Description

给定 $n$ 个数 $t_i$，然后给定 $m$ 个用 $i,j,b$ 描述的不等式关系
$$t_i-t_j\le b$$

#### Solution

差分约束模板，左边的这个 $t_i-t_j$ 就是差分。

我们首先把这个不等式化简一下，成 $t_i\le t_j+b$。

假设 $t_j$ 已知，我们可以推出 $t_i$ 的最大值只可能是 $t_j+b$，最小不限。

那我们再次假设如果 $t_i$ 跟 $t_{j'}$，$t_{j''}$，$t_{j'''}$ 都有关，我们就可以得到三个不等式，即一个不等式组

$$\begin{cases}t_i\le t_{j'}+b\\t_i\le t_{j''}+b\\t_i\le t_{j'''}+b\end{cases}$$

那么 $t_i$ 满足所有不等式下的最大值应该是 $\min\{t_{j'}+b,t_{j''}+b,t_{j'''}+b\}$。

因为要满足所有不等式，所以必须要取最小值来满足所有的不等式。

注意，我们上面提到的 $j$ 都可以模拟成 $i$ 的 **前继**。

那么我们可以再次简化模型。

假设有多个 $t_j$ 是 $t_i$ 的前继，那么我们就可以得到一个递推式。

$$t_i=\min\{t_j+b\}$$

那么我们看一下 SPFA 的递推式。

$$dist_i=\min\{dist_j+<i,j>\}$$

好了，破案了。

那么我们只需要找一个超级原点 $\rm super$，然后使得他连到 $i$ 的长度是 $t_i$ 即可。

最后我们求一个最短路即可，输出每个 $dist_i-\min\{dist_i\}$。

最后无解的情况只需要判断一下负环即可。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

struct node {
	int val, next, len;
} e[100086];

int n, m;
int cnt;
int head[100086];
int dist[100086];
int sum[100086];
int vis[100086];
const int inf = 0x3f3f3f3f;

void AddEdge (int u, int v, int w) {
	e[++cnt].val = v;
    e[cnt].next = head[u];
    e[cnt].len = w;
    head[u] = cnt;
}

bool SPFA () {
	queue <int> q;
	int s = n + 1;
	for (int i = 1; i <= n; i++)
		dist[i] = inf;
	dist[s] = 0;
	sum[s] = 1;
	vis[s]++;
	q.push(s);
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		sum[cur] = 0;
		for (int p = head[cur]; p > 0; p = e[p].next)
			if (dist[e[p].val] > dist[cur] + e[p].len) {
				dist[e[p].val] = dist[cur] + e[p].len;
				vis[e[p].val]++;
				if (vis[e[p].val] >= n + 1)
					return true;
				if (!sum[e[p].val]) {
					q.push(e[p].val);
					sum[e[p].val] = 1;
				}
			}
	}
	return false;
}

int main () {
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v, w; i <= m; i++) {
		scanf("%d%d%d", &u, &v, &w);
		AddEdge(v, u, w);
	}
	for (int i = 1; i <= n; i++) 
		AddEdge(n + 1, i, 0);
	if (SPFA()) {
		printf("NO SOLUTION");
		return 0;
	}
	int Min = 1e9;
	for (int i = 1; i <= n; i++)
		Min = min(dist[i], Min);
	for (int i = 1; i <= n; i++)
		printf("%d\n", dist[i] - Min);
	return 0;
}
```

2020.7.14   
By Shuchong

---

## 作者：ysner (赞：3)

核心思想：差分约束、SPFA。

差分约束的本质就是把不等式化为有向图的边。例如本题的Ti-Tj<=B，在把减法化为加法后形式为Ti<=Tj+b，可以理解为从Tj出发到Ti的最大距离为b，于是建立一条从Tj到Ti、长度为b的边代表此限制条件即可。

于是，我们建立了一个图，点与点之间具有相对关系，点的值不绝对，我们只要把其中任意一点定为0，再依此用最短路算法推出其它点的值即可。

然后涉及到最短路方法的选取。

本题有一种情况是无解，在图中反映即为存在负环。

一般来说负环最快的判断方法是DFS—SPFA，但此方法似乎只能判断负环（也就是Yes、No两种结果），从每一个点开始的DFS很容易破坏上次的路程值（比如把出发点dis赋为0），而且若图不完全联通，一次也无法得出所有点的dis。而我们同时要求最短路，此时常规SPFA（BFS—SPFA）显然更有利，可以规避DFS—SPFA的局限性（自己编程感受一下），只是判负环慢了一点点。

最后几点注意事项：

1、常规SPFA的判负环方法是：某个节点入队超过n次即有负环。因此，应在SPFA开头初始化和最后（松弛且判定点未访问后）分别计入队次数加1；

2、本题样例输出的值不具有参考性，只要你的相对关系符合题目要求即可AC。（如本程序第一个样例输出0 7 5 4 6)

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
int n,m,h[2005]={},dis[2005]={},cnt=0,minn,q[1000500]={},times[2005]={},head,tail;
bool vis[2005]={};
il int gi()
{
    re int x=0;
    re int t=1;
    re char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
    return x*t;
}
struct Edge
{
    int to,next,w;
}e[10005];
il void add(int u,int v,int w)
{
    e[++cnt]=(Edge){v,h[u],w};h[u]=cnt;
}
il void spfa(int st)
{
    head=0;tail=1;
    dis[st]=0;
    q[1]=st;
    times[st]++;//判负环
    while(head<tail)
    {
        int u=q[++head];
        vis[u]=0;
        for(re int i=h[u];i+1;i=e[i].next)
        {
            int v=e[i].to;
            if(dis[v]>dis[u]+e[i].w)
            {
                dis[v]=dis[u]+e[i].w;
                if(!vis[v])
                {
                    vis[v]=1;
                    times[v]++;//判负环
                    if(times[u]==n+1) {printf("NO SOLUTION\n");exit(0);}
                    q[++tail]=v;
                }
            }
        }
    }
    vis[st]=0;
}
int main()
{
    memset(h,-1,sizeof(h));
    n=gi();m=gi();
    fp(i,1,m)
    {
        int u=gi(),v=gi(),w=gi();
        add(v,u,w);
    }
    fp(i,1,n) dis[i]=214748364;
    fp(i,1,n)
    {
        if(times[i]) continue;
        spfa(i);
    }
        minn=0x3f3f3f;
        fp(i,1,n) minn=min(minn,dis[i]);//防止出现时间为负数的情况
        fp(i,1,n) printf("%d\n",dis[i]-minn);
    return 0;
}

```

---

## 作者：pengyule (赞：2)

【算法】：差分约束

【做法】：这是一道差分约束模板题，显然对于每一个式子连一条 $j\to i$ 的有向边权值为 $b$ 即可，然后用 SPFA 跑一遍最短路，注意判断如果出现负环那么就是无解情况。否则答案即为最短路径长度数组 $dis_{1\sim n}$。但请注意这还不是最终答案，因为 $dis$ 中可能有负值，这时我们需要把其中最小的负数的相反数加到数组中每一个元素的身上，从而让所有 $dis_i$ 非负且有一个值为零。

【代码】：
```cpp
#include <bits/stdc++.h>
#define mp make_pair
using namespace std;
const int N=1e5,inf=1e9;
int inq[N],dis[N],cnt[N];
vector<pair<int,int> > G[N];
queue<int> Q;
int main()
{
	int n,p,u,v,w;
	cin>>n>>p;
	for(int i=1;i<=p;i++){
		cin>>u>>v>>w;
		G[v].push_back(mp(u,w));
	}
	for(int i=1;i<=n;i++) dis[i]=inf;
	for(int r=1;r<=n;r++){
	    if(dis[r]!=inf) continue;
	    dis[r]=0;
	inq[r]=1; Q.push(r); //这循环里面的前三行是把每一个连通块都进行求解，因为图不一定联通
	while(!Q.empty()){
		int now=Q.front(); inq[now]=0; Q.pop(); cnt[now]++;
		if(cnt[now]>=n*n) { puts("NO SOLUTION"); return 0; }//加入队列的次数如果太多可能就是出现负环了
		for(int i=0;i<G[now].size();i++)
			if(dis[G[now][i].first]>dis[now]+G[now][i].second){
				dis[G[now][i].first]=dis[now]+G[now][i].second;
				Q.push(G[now][i].first),inq[G[now][i].first]=1;
			}
	}
	}
	int sm=0;
	for(int i=1;i<=n;i++) sm=min(sm,dis[i]); 
	for(int i=1;i<=n;i++) cout<<dis[i]-sm<<' ';
	return 0;
}
```
【差分约束】满足一系列式子 $x_i-x_j\leq k$ 的约束，求 $x_s-x_t$ 的最大值。这是差分约束的标准形式，想法是因为式子等价于 $x_i\leq x_j+k$ 所以我们想到最短路中的松弛操作，松弛过后的 $dis_i,dis_j$ 之间正好是满足这个关系，且是此前提下的最大值。因此最终答案即为 $t\to s$ 的最短路。为了避免混淆，请注意我们连边和答题都是从减数到被减数，这样不容易错。然后我们还有无解的情况（图中有负环）和无数解的情况（图不联通），这些在某些情况下需要判定。这个问题的延伸有：1.$x_i-x_j\geq k$，求 $x_s-x_t$ 的最小值。式子转化为 $x_j-x_i\leq -k$，在此基础上求最长路即可（最长路的求法就是把所有边权取相反数然后最短路，再把结果取相反数）。2.条件中穿插有 $x_i=x_j$，这时把它转化成 $x_i-x_j\leq 0$ 且 $x_i-x_j\geq 0$。

希望能帮到你！

---

## 作者：飞翔 (赞：2)

```c
const
  maxb=100;
    maxn=1000;
    maxm=5000;
    maxt=maxn*maxb;
type
  rec=record
      i,j,b:longint;
    end;
var
  a:array[1..maxm]of rec;
    high,low:array[1..maxn]of longint;
    n,m,k,d:longint;
    flag,noans:boolean;
begin
  read(n,m);
    for k:=1 to m do
      with a[k] do read(i,j,b);
    for k:=2 to n do begin
      high[k]:=maxt;
        low[k]:=-maxt;
    end;
    flag:=true;
    noans:=false;
    while flag do begin
      flag:=false;
        for k:=1 to m do
          with a[k] do begin
              if high[i]-high[j]>b then begin
                  high[i]:=high[j]+b;
                    flag:=true;
                end;
                if low[i]-low[j]>b then begin
                  low[j]:=low[i]-b;
                    flag:=true;
                end;
                if (low[i]>high[i])or(low[j]>high[j]) then begin
                  write('NO SOLUTION');
                    halt;
                end;
            end;
    end;
    d:=maxt;
    for k:=1 to n do
        if low[k]<d then d:=low[k];
    for k:=1 to n do writeln(low[k]-d);
end.
```
此题用差分约束系统解决。题目的意思就是找出满足条件的一组T，使得所有Ti-Tj<=B的不等式成立。移项得Ti<=Tj+b，于是机智的我机智的想到了机智的最短路径。


---

## 作者：HSCN (赞：2)

裸的差分约束，直接跑Bellman-Ford，将不等式化为Tj+b<=Ti,相当于从点j到点i建一条权值为b的边。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=5010;
const int INF=1e9;
bool updated;//判断负环时用 
int V,E,ti[maxn],tj[maxn],b[maxn],dis[maxn];
void update(int &x,int y){//差分约束核心
	if(x>y)x=y,updated=true;
}
void bellmanford(){
	//跑V+1次，如果第V+1次updated被update函数更新，说明有负环 
	for(int k=0;k<=V;k++){ 
		updated=false;
		for(int i=1;i<=E;i++)
        	//update就是差分约束的不等式，改一改这能A很多题...
			if(dis[i]<INF)update(dis[ti[i]],dis[tj[i]]+b[i]);
            //
	}		
}
void solve(){
	fill(dis+1,dis+1+V,0);//全赋值成0判负环 
	bellmanford();
	if(updated){//被更新V+1次说明出现负环 
		cout<<"NO SOLUTION"<<endl;
		return;
	}
	//赋成最大值跑简化最短路（差分约束）
	fill(dis+1,dis+1+V,INF); 
	for(int i=1;i<=V;i++)
		if(dis[i]==INF)dis[i]=0,bellmanford();
	int mi=INF;
	//保证时间非负且最小值为零 
	for(int i=1;i<=V;i++)mi=min(mi,dis[i]);
	for(int i=1;i<=V;i++)cout<<dis[i]-mi<<endl;
}
int main(){
	cin>>V>>E;
	for(int i=1;i<=E;i++)cin>>ti[i]>>tj[i]>>b[i];
	solve();
	return 0;
}
```

---

## 作者：Just_do_it (赞：1)

依旧是差分约束系统，我的建图是由$T_i-T_j\leq d$移项后得到$T_i+(-b)\leq T_j$，由$T_i$向$T_j$连一条长为$-b$的有向边跑最大路。

不过本题也是可以写 SPFA-dfs 来求最大路和负环的。 dfs 判负环的原理是每次可以更新 dist 的值时就更新并继续 dfs 下去，如果更新的点已经在路径里了，那么存在负环，不过此题是正环。至于 dist 的问题，初始化为$-inf$，枚举每个点是否开始 dfs ，如果 dist 不为$-inf$,那么是遍历过的，就不用再 dfs 了，如果不是，就设为$0$开始遍历。

当然图上存在都是负权边的情况，那么会有点的 dist 小于$0$，最后还要让所有的  dist 减去最小的 dist 使 dist 值都大于等于$0$

代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x){
	int f = 1;x = 0;char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')f = -1;ch = getchar();}
	while(ch >= '0' && ch <= '9'){x = x*10+ch-'0';ch = getchar();}
	x *= f;
}
const int N = 1005,M = 5005;
int head[N],to[M],nxt[M],w[M],cnt;
int dist[N];
int n,m;
bool vis[N];

inline void insert(int x,int y,int z){ to[++cnt] = y; nxt[cnt] = head[x]; head[x] = cnt; w[cnt] = z; }

void SPFA(int x){
	vis[x] = true;
	for(int i = head[x];i;i = nxt[i]){
		int v = to[i];
		if(dist[v] < dist[x]+w[i]){
			if(vis[v]){
				puts("NO SOLUTION");
				exit(0);
			}
			else{
				dist[v] = dist[x]+w[i];
				SPFA(v);
			}
		}
	}
	vis[x] = false;
}

int main(){
	read(n);read(m);
	for(int i = 1,x,y,z;i <= m;++i){
		read(x); read(y); read(z);
		insert(x,y,-z);
	}
	for(int i = 1;i <= n;++i) dist[i] = -1e9;
	for(int i = 1;i <= n;++i){
		if(dist[i] == -1e9) dist[i] = 0;
		SPFA(i);
	}
	int Min = 1e9;
	for(int i = 1;i <= n;++i) Min = min(Min,dist[i]);
	for(int i = 1;i <= n;++i) printf("%d\n", dist[i]-Min);
	return 0;
}
```

---

## 作者：NewJeanss (赞：1)

差分约束是怎么想出来的？

差分约束的**本质**（最短路）：

$$dis_{u}<=dis_{v}+<v,u>$$

和题目中的**特征**：

$$x_{i}-x_{j} \le c$$

形式高度相似。首先，都有减号，其次，都有小于等于号。所以我们在其中**建立联系**。使用**数形结合**。

这是为什么我们会一般地规定差分系统的符号是 $\le$ 号（**也可以是 $\ge$ 号**，但原理为**最长路**）。但最长路将权值取反就是最短路。我们要注意的是建边是不要只想到小于等于号。

对于这道题。为什么是从 $j->i$ 建边？

关注**原理**。边的方向就是我们要建边的方向。

接下来用 $spfa$ 判断负环和其他收尾工作即可。注意，对于一组解 $S$ ，所有元素都加上 $d$ 后的 $S'$ 仍是一组解。可用数学直觉验证。


```cpp
#include <bits/stdc++.h>
#define N 5005
#define inf 0x3f3f3f3f
using namespace std;
int head[N],tot,vis[N],dis[N],cnt[N],n,m;
struct edge{
	int to,nex,w;
}e[N<<2];
void add(int x,int y,int w){
	e[++tot].to=y;
	e[tot].nex=head[x];
	e[tot].w=w;
	head[x]=tot;
}
queue<int> que;
void spfa(int start){
	while(!que.empty()) que.pop();
	for(int i=0;i<=n;i++) vis[i]=cnt[i]=0,dis[i]=inf;
	que.push(start); vis[start]=1; dis[start]=0; cnt[start]=1;
	while(!que.empty()){
		int x=que.front(); que.pop(); vis[x]=0;
		for(int i=head[x];i;i=e[i].nex){
			int to=e[i].to;
			if(dis[to]>dis[x]+e[i].w){
				dis[to]=dis[x]+e[i].w; cnt[to]=cnt[x]+1;
				if(cnt[to]>n){ cout<<"NO SOLUTION"<<endl; return; } 
				if(!vis[to]) vis[to]=1,que.push(to); 
			}
		}
	}
	int Max=-inf,Min=inf;
	for(int i=1;i<=n;i++) if(dis[i]<0) Max=max(Max,-dis[i]);
	for(int i=1;i<=n;i++) dis[i]+=Max,Min=min(Min,dis[i]);
	for(int i=1;i<=n;i++) cout<<dis[i]-Min<<endl;
}
signed main(){
	ios::sync_with_stdio(false); cin.tie(0);
	int x,y,c;
	while(cin>>n>>m){
		memset(head,0,sizeof(head)); tot=0;
		for(int i=1;i<=m;i++) cin>>x>>y>>c,add(y,x,c);
		for(int i=1;i<=n;i++) add(0,i,0);
		spfa(0);
	}
	return 0;
}
```


---

## 作者：x_miracle (赞：1)

### 观前提示：

建议完成以下题目后在来看此题/题解哦。

[P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)

[P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)


### 题目分析：

**核心算法：差分约束**

（这几乎是一道裸题）

------------

题中写道：

“不等式形如$T_i-T_j \leq b$代表$i$和$j$的起始时间必须满足的条件。每个不等式的右边都是一个常数$b$，这些常数可能不相同，但是它们都在区间$\left( -100,100\right)$内。”

即，**符合差分约束算法的定义**。

所以我们套用差分约束的模板，可以先求出一个可行解。

**与纯模板不同的是**，题目中要求：

“对于有解的情况，要使最早进行的那个任务和整个工程的起始时间相同，也就是说，$T_1，T_2，…，T_n$中至少有一个为0。”

我们已知：对于所求出的解，存在以下性质：

**设$x=\left( x_1,x_2,x_3,...,x_n\right)$是不等式的一个解。设$d$为任意常数，则$x+d=\left( x_1+d,x_2+d,x_3+d,...,x_n+d\right)$也是该不等式的一个解。**

所以只要在原模板的基础上，找到可行解中的最小值，然后让整体的解减去该值即可。

代码如下：
```cpp
#include <bits/stdc++.h>
#define MAXN 100000
#define INF 0x3f3f3f3f
using namespace std;
struct EDGE
{
	int to,nxt,val;
}	e[MAXN];
int cnt=0,adj[MAXN],ori=0,vis[MAXN],num[MAXN],dis[MAXN];
int n,m;
void addedge(int u,int v,int w)
{
	e[++cnt].to=v; e[cnt].val=w; e[cnt].nxt=adj[u]; adj[u]=cnt;
}
queue < int > q;
bool SPFA()
{
	for(int i=1;i<=n;++i)	{addedge(0,i,0);dis[i]=INF;}
	q.push(ori); dis[ori]=0; ++num[ori]; vis[ori]=1;
	while(!q.empty())
	{
		int u=q.front(); q.pop();	vis[u]=0;
		for(int i=adj[u];i;i=e[i].nxt)
		{
			int v=e[i].to;	
			if(dis[v]>dis[u]+e[i].val)
			{
				dis[v]=dis[u]+e[i].val;
				if(!vis[v])
				{
					vis[v]=1;	q.push(v);
					++num[v];
					if(num[v]>n)	return 0;
				}
			}
		}
	}
	return 1;
}
int main()
{
	int temp=INF;scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)
	{
		int u,v,w; scanf("%d%d%d",&u,&v,&w);
		addedge(v,u,w);
	}
	if(SPFA())
	{
		for(int i=1;i<=n;++i)
			temp=min(temp,dis[i]);
		for(int i=1;i<=n;++i)
			printf("%d\n",dis[i]-temp);
	}	
	else
		printf("NO SOLUTION");
	return 0;
}
```

---

## 作者：Acestar (赞：1)

裸的**差分约束**吧。

对于 $T_i-T_j≤b$，移项可得 $T_i≤T_j+b$，所以可以加一条从 $T_j$ 到 $T_i$ 长为 $b$ 的边，再跑一遍最短路，就找到的一组特解。

跑最短路之前，要建一个超级源点，向每一个点连一条边，避免图不连通。

$dis$ 数组里存的就是特解，然后把 $dis$ 里最小的找到，输出的时候减去它就行了。

因为有无解的情况，所以要用 $spfa$ ~~它没死~~，判负环，如果有负环，输出 `NO SOLUTION`。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define N 1010
#define M 6010

using namespace std;

int n,m;
struct edge
{
	int v,w,nxt;
}e[M];
int head[N],tot;

void add(int u,int v,int w)
{
	e[++tot]=(edge){v,w,head[u]};
	head[u]=tot;
}

int dis[N],flag[N],sum[N];
queue <int> que;

void spfa()
{
	memset(dis,0x3f,sizeof(dis));
	dis[0]=0;
	que.push(0);
	flag[0]=1;
	while(!que.empty())
	{
		int u=que.front();
		que.pop();
		flag[u]=0;
		sum[u]++;
		if(sum[u]>=n)
		{
			puts("NO SOLUTION");
			return;
		}
		for(int i=head[u]; i; i=e[i].nxt)
		{
			int v=e[i].v,w=e[i].w;
			if(dis[u]+w<dis[v])
			{
				dis[v]=dis[u]+w;
				if(!flag[v])
				{
					que.push(v);
					flag[v]=1;
				}
			}
		}
	}
	int mind=0;
	for(int i=1; i<=n; i++) mind=min(mind,dis[i]);
	for(int i=1; i<=n; i++) printf("%d\n",dis[i]-mind);
	return;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=m; i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add(v,u,w);
	}
	for(int i=1; i<=n; i++) add(0,i,0);
	spfa();
	return 0;
}
```


---

## 作者：Sham_Sleep (赞：0)

核心思想：差分约束。

题目里直接给出了不等式：
```
Ti-Tj<=b
```
将不等式进行变形，可以得到：

```
b + Tj >= Ti
```
我们这里可以进行转换，将不等式变换为一条边的描述。

因为要满足不等式，且要求得工程顺序，所以j->i的差最多为b，由此，我们就可以知道，应建立一条j到i权值为b的有向边

最后，用一个原点“0”，将所有点都连起来，这样就可以构成一个起点为0的单源最短路，而“0”可以视为工程前的准备，由他出发可以开始任意工程，这有利于我们用spfa

注意这里有无解的情况，说明数据里给出的有负环，利用spfa里面的判负环的结论即可。


AC代码
```
#include <stdio.h>
#include <iostream>
#include <queue>
using namespace std;

int m , n;
int x , y , w , t;
int d[1005];
int fh[1005];
int mapp[1005][1005];
bool f[1005];
queue<int> dl;

int main()
{
	scanf("%d %d" , &m , &n);
	for(int i = 1; i <= m; ++i){
		for(int j = 1; j <= m; ++j){
			mapp[i][j] = 0x7ffffff / 2;
		}
	}
	for(int i = 1; i <= n; ++i){
		scanf("%d %d %d" , &x , &y , &w);
		mapp[y][x] = w;
	}
	for(int i = 1; i <= m; ++i){
		mapp[0][i] = 0;
	}
	for(int i = 1; i <= m; ++i) d[i] = 0x7ffffff / 2;
	dl.push(0);
	while(!dl.empty())
	{
		t = dl.front(); f[t] = false; dl.pop();
		for(int i = 1; i <= m; ++i){
			if(i == t) continue;
			if(mapp[t][i] != 0x7ffffff / 2)
			{
				++fh[i];
				if(fh[i] > m) 
				{
					printf("NO SOLUTION");
					return 0;
				}
				if(d[i] > d[t] + mapp[t][i])
				{
					d[i] = d[t] + mapp[t][i];
					if(!f[i]) { f[i] = true; dl.push(i); }
				}
			}
		}
	}
	int minn = 0x7fffffff / 2;
	for(int i = 1; i <= m; ++i){
		if(d[i] == 0x7ffffff / 2){
			printf("NO SOLUTION");
			return 0;
		}
	}
	for(int i = 1; i <= m; ++i)  minn = min(minn , d[i]);
	if(minn != 0) for(int i = 1; i <= m; ++i) d[i] -= minn;
	for(int i = 1; i <= m; ++i) printf("%d\n" , d[i]); 
} 
```



---

## 作者：wanghanjun (赞：0)

裸的差分约束题。。。

先讲一下什么是差分约束。差分约束就是给你一堆形如$t_i-t_j<=b$的不等式，移项后是$t_i<=t_j+b$，让你求$t_x-t_y$的最小值。

根据图的性质我们可以知道，如果有一条从u到v的边，长度为c，那么必有$dis_v<=dis_u+c$，和上面那个一模一样。于是，对于式子$t_i<=t_j+b$，可以建一条从j到i，长度为b的边，就像题目里说的一样。

如果题目让你求$t_x-t_y$的最小值，直接跑一遍最短路求y到x的最短路就行了。这道题是任选一个点当初始点（比如1号），从那个点出发跑最短路，于是得到了27分。。。

为什么呢，因为这道题的图不一定联通，也就是说，仅从一个节点出发跑最短路会有一些点跑不到，所以可以建一个超级源点，向其他每个节点连一条长度为0的边，跑最短路，距离即答案。

最后别忘了题目里至少1个0的条件。出现负环代表无解。

然后补充一些差分约束时常用的小技巧：

1. 上面提到的超级源点
1. 负环代表无解，不连通代表无限解
1. 若$t_i$均为整数，则$t_i-t_j<b$可以表示成$t_i-t_j<=b-1$
1. $t_i-t_j=b$可以表示成$t_i-t_j<=b$且$t_i-t_j>=b$

Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int MAXN=1005,MAXM=10005;
struct node{
	int v,c;
	node*next;
}*h[MAXN],pool[MAXM];
int dis[MAXN],vis[MAXN],n,m,tot=0,mina=10211314;
bool col[MAXN];
queue <int> q;

void addedge(int u,int v,int c){
	node*p=&pool[++tot];
	p->v=v;p->c=c;p->next=h[u];h[u]=p;
}

bool spfa(){
	for(int i=1;i<=n;i++){
		dis[i]=0;
		vis[i]=1;
		col[i]=1;
		q.push(i);
	}
	while(!q.empty()){
		int u=q.front();q.pop();
		col[u]=0;
		for(node*p=h[u];p;p=p->next){
			if(dis[p->v]>dis[u]+p->c){
				dis[p->v]=dis[u]+p->c;
				if(!col[p->v]){
					col[p->v]=1;
					vis[p->v]++;
					q.push(p->v);
					if(vis[p->v]>n){
						return 0;
					}
				}
			}
		}
	}
	return 1;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v,c;
		scanf("%d%d%d",&v,&u,&c);
		addedge(u,v,c);
	}
	if(!spfa()){
		printf("NO SOLUTION\n");
	}
	else{
		for(int i=1;i<=n;i++){
			mina=min(mina,dis[i]);
		}
		for(int i=1;i<=n;i++){
			printf("%d\n",dis[i]-mina);
		}
	}
	return 0;
}
```



---

## 作者：封禁用户 (赞：0)

上代码：
```CPP
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
inline int read()
{
    int ans = 0,op = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') op = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        (ans *= 10) += ch - '0';
        ch = getchar();
    }
    return ans * op;
}
const int maxn = 2005;
struct egde
{
	int to,next,cost;
}e[maxn * 10];
int fir[maxn],alloc;
inline void adde(int u,int v,int w)
{
	e[++alloc].next = fir[u];
	fir[u] = alloc;
	e[alloc].to = v;
	e[alloc].cost = w;
}
int n,m;
int dis[maxn],popst[maxn],minm;
bool instack[maxn];
void spfa(int s)
{
	queue<int> q;
	memset(dis,0x3f,sizeof(dis));
	dis[s] = 0;
	q.push(s);
	instack[s] = 1;
	while(q.size())
	{
		int u = q.front();
		q.pop();
		popst[u]++;
		if(popst[u] > n - 1) { printf("NO SOLUTION"); return;}
		instack[u] = 0;
		for(int i = fir[u];i;i = e[i].next)
		{
			int v = e[i].to,w = e[i].cost;
			if(dis[v] > dis[u] + w)
			{
				dis[v] = dis[u] + w;
				if(!instack[v]) q.push(v),instack[v] = 1;
			}
		}
	}
	for(int i = 1;i <= n;i++) minm = min(minm,dis[i]);
	for(int i = 1;i <= n;i++) printf("%d\n",dis[i] - minm);
}
int main()
{
	n = read(),m = read();
	for(int i = 1;i <= m;i++)
	{
		int u = read(),v = read(),w = read();
		adde(v,u,w);	
	}
	for(int i = 1;i <= n;i++) adde(n + 1,i,0);
	spfa(n + 1);
    return 0;
}

---


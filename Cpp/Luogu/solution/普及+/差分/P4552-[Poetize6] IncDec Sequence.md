# [Poetize6] IncDec Sequence

## 题目描述

给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间$[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 
  
请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。

## 说明/提示

对于 $100\%$ 的数据，$n\le 100000, 0 \le a_i \le 2^{31}$。

## 样例 #1

### 输入

```
4
1
1
2
2```

### 输出

```
1
2```

# 题解

## 作者：mot1ve (赞：463)

一个小时才学会差分= =太弱了，分享一下我学习差分的心得。非常详细 虽然很长但

看完保证明白，不明白可以私信问。

（本篇题解我们的数组的下标从1开始）差分的概念是b[1]=a[1]，b[i]=a[i]-a[i-1]，

简单来说就是两个数的差。b[1]一定是等于a[1]的，因为b[1]=a[1]-a[0]，而

a[0]=0,所以b[1]=a[1]。

了解了概念，我们看一下差分和原序列之间有什么关系

把序列a的区间[l,r]+d（或者说a[l]+d,a[l+1]+d,a[l+2]+d+....+a[r]+d的

话，那么这个序列a的差分序列b的变化就为b[l]+d,b[r+1]-d。为什么呢？举个例子

原序列a：1 3 4 2 1，其差分序列b:1 2 1 -2 -1

把区间[2,4]+2，得到的序列a应该是1 5 6 4 1

再看差分序列b，根据我们上面说的公式，a[2,4]+2应该等于b[2]+2,b[5]-2;

差分序列b变为：1 4 1 -2 -3

到底是不是这样呢？我们根据差分的概念倒推回去看看

由于b[1]=a[1]，且b[1]=1，所以a[1]=1;

b[2]=4，则a[2]-a[1]=b[2]=4;由于a[1]=1，得出a[2]=5;

b[3]=1，则a[3]-a[2]=1，由于a[2]=5，得出a[3]=6;

b[4]=-2,则a[4]-a[3]=-2，由于a[3]=6，得出a[4]=4;

b[5]=-3,则a[5]-a[4]=-3，由于a[4]=4，得出a[5]=1;

由差分序列倒推回来得到的原序列是1 5 6 4 1，完全符合我们之前得到的，说明这

个公式是正确的。

直观点说，原序列1 3 4 2 1，把区间[2,4]+2，得到的序列a是1 5 6 4 1

可以发现，a[2,4]中的差是不变的，因为他们同时加了一个数，变化的是a[l-1]和

a[l]之间的差以及a[r]和a[r+1]之间的差，这样一来，就很好推出这个差分序列公式

下面是这个公式的延伸

如果a[l,r]+1，则b[l]+1，b[r+1]-1;

如果a[l,r]-1，则b[l]-1，b[r+1]+1;

如果a[l,n]+1(l <= n - 1)，则b[l]+1，其余不变，因为b[n+1]已越界无意义

如果a[l,n]-1(l <= n - 1),则b[l]-1，其余不变，因为b[n+1]已越界无意义

下面看一下这个题该怎么做

要使得序列的数全部相等，其实就是让他们之间的差全为0，也就是差分序列的除了第

一项每一项都是0，为什么除了第一项呢，因为b[1]=a[1]-a[0]，而a[1]是开头的数

我们把问题转化成了让差分序列除第一项全等于0之后，继续思考

由于题目要求最少的步骤，我们可以考虑，如果差分序列里有一个正数和一个负数

（出现的顺序无所谓），那么我们优先对这个正数和负数进行操作，为什么呢？因为

我们有以下两个公式

如果a[l,r]+1，则b[l]+1，b[r+1]-1

如果a[l,r]-1，则b[l]-1，b[r+1]+1

正数-1，负数+1，这样相当于一步里作用了两步，比让正数一个个-1和让负数一个个

+1快多了

那么我们可以进行多少种这样的操作呢？

我们可以令差分序列里正数绝对值的总和为p，负数绝对值总和为q

可以进行这样一步顶两步的操作就是min（p，q），因为这种操作正数负数是一一配

对的，当少的那个先用完了，剩下的没有可以配对的了，只能一步步减或一步步加。

所以我们总共要进行的操作就为min（p，q）+abs（p-q），也就是max（p，q）

第一问完成，看第二问

保证最少次数的前提下，最终得到的数列有多少种？

得到的数列有多少种，其实就是问的b[1]可以有多少种

我们上述所有操作是与b[1]无关的，因为我们的目标是让除了b[1]以外的项变0，所

以我们上述的操作没有考虑到b[1]，b[1]怎么变，与我们求出的最小步骤无关

那么，我们怎么知道b[1]有几种呢？很简单，其实就是看看有几种一步步减或一步步

加的操作数，因为我们一步步加的时候（假设我们现在的操作对象下标为i），

可以这样操作，b[1]-1,b[i]+1

一步步减的时候可以这样操作，b[1]+1,b[i]-1

（注意，一个差分序列里一步步操作的时候只可能一步步加或一步步减，不可能一步

步加和一步步减同时存在）

所以说，有几步一步步的操作就有几种情况+1，为什么+1呢，因为这个b[1]本身就有

一个值啊！就算你不对他进行任何操作，它自己也有一种情况。

一加一减（也就是我们所说的一步顶两步的操作）操作数为min（p，q）

那么一步步的操作数就为max（p，q）-min（p，q）=abs（p，q）

完结撒花

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long LL;
LL n,c,p,q,a[100010];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	for(int i=2;i<=n;i++)
	{
		c=a[i]-a[i-1];
		if(c>0)
		{
			p+=c;
		}
		else 
		q-=c;
	}
	LL ans1=max(p,q);
	LL ans2=abs(p-q)+1;
	cout<<ans1<<endl<<ans2;
	return 0;
}

---

## 作者：TheShadow (赞：82)

# **~~毕老爷TQL~~**
- 看书的时候发现例题索引里面竟然有毕老爷的题，~~赶紧过来%一%~~。
- 咳咳，言归正传，来说一下这题怎么做。
### 首先，我们来介绍一下**差分**是什么东西
#### 1.定义
定义一个差分数组*S*和一个原数组*A*。
- 特别的：
$$S[1]=A[1]$$
- 接下来每个数都定义为：$$S[i]=A[i]-A[i-1]$$
#### 2.性质
差分数组有着一些令人着迷的性质
- *A*数组的差分数组的前缀和数组就等于原数组,即$$Sum[i]=A[i]=S[i]+Sum[i-1]$$
- *Sum*数组的差分数也等于原数组，即
$$S[i]=A[i]=Sum[i]-Sum[i-1]$$
- 还有比较重要，而且常用的的一条，我们在修改某一段区间的时候，比如这道题的集体加 **n** 的时候，将操作放在差分数组上就变成了$$S[l]+=n,S[r+1]-=n$$
这样，我们就可以把区间操作更改为单点操作，巨幅减少了时间复杂度，优化了我们的代码长度与复杂度，而且还很好理解

- 当然，差分的运用远不止于此，在树上等也是可以进行差分操作的，但这里没啥联系，也不再赘述了。
- **综上：有了这些性质，我们在做一些题的时候就可以将其转换为差分数组求解，完成过后过一遍前缀和得到正确答案。**
## 比如
[正是本题！！](https://www.luogu.org/problemnew/show/P4552) 

 [我们熟悉的John老爷爷和他的奶牛](https://www.luogu.org/problemnew/show/P2879)
 ## 好了，说了这么多，这道题的解法差不多也是~~呼之欲出了吧？？~~
 ~~咳咳，严肃点~~
- 因为是区间整体加减1，所以我们很自然的就可以想到用差分求解。

- 这道题可以看做求出原序列的差分之后，将 *S[2...n]* 全部变为0所需的最少的步数和可以使 *S[1]* 变为多少种不同的数。
- 很明显的，在我们求出的差分数组中，有正数也有负数，要消除这些数，使得它们全部归零，我们有以下3种可行的操作：
1. 选取一个**正数(X)**和一个**负数(Y)**，使正数减1，负数加1，这样经过N次操作，我们一定可以以最少的代价将绝对值较小的一方归零，代价为$$abs(min(X,Y))$$
2. 选取一个**正数(X)**，使其与 *S[1]* 配对，这样，我们经过N次操作，一定可以将它归零，代价为：$$abs(X)$$
3. 选取一个**负数(Y)**，使其与 *S[n+1]* 配对，这样，我们经过N次操作，一定可以将它归零，代价为：$$abs(Y)$$
- 经过上述分析，我们就能够推导出本题的解题公式：
$$ans=abs(min(X,Y))+abs(X-Y)$$
$$ans=abs(max(X,Y))$$
- 需要注意的是这里的X,Y是差分数组中所有正数的和与所有负数的和的绝对值

- 最后我们还要求能构成几组解，这很容易可以推出：
$$ans=abs(X-Y)+1$$
- 差不多就这样吧，上代码：
```cpp
#include<set>
#include<map>
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
#define it inline int
#define rl register ll
#define il inline void
#define ri register int
#define clean(a,i) memset(a,i,sizeof(a))
using namespace std;
template<class T>il read(T &x)
{
    int f=1;char k=getchar();x=0;
    for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
    for(;k>='0'&&k<='9';k=getchar()) x=x*10+k-'0';
    x*=f;
}
int n,a[100005],k;//totz ÕýÊý totf ¸ºÊý 
ll totz,totf,c[100005];
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    read(n);
    for(ri i=1;i<=n;i++) read(a[i]);//读入
    c[1]=a[1];//计算差分数组
    for(ri i=2;i<=n;i++)//计算正数和负数的和
    {
        c[i]=a[i]-a[i-1];
        if(c[i]>0) totz+=c[i];
        else totf-=c[i];//注意这里是减号，毕竟是负数
    }
    printf("%lld\n%lld",max(totz,totf),abs(totz-totf)+1);//输出咯
    return 0;
}
```
- 本蒟蒻第一次写题解，求过~~

---

## 作者：CYC的幸福生活 (赞：71)

因为是区间加减，我们就考虑到使用差分数组。即新定义一个数组$c$,使得$c[i] = a[i+1] - a[i]$

这样，先自己造一组数

$$
a = \{4,8,6,5,10,7\}
$$

我们就有

$$
c = \{ 4 , -2 , -1 , 5 , -3 \} 
$$

对于区间$[l,r]$，加1减1的操作对c数组的影响为

```cpp

[l,r]都加一：a[l-1]++,a[r]-- 
[l,r]都减一：a[l-1]--,a[r]++ 

```

取$x,y$，使得$x$为$c$中所有整数之和，$y$为$c$中所有负数之和再取反。观察前面的结论，我们可以把操作分成两部分：先是正负抵消，剩下的最后一个数，再单独把这个数递减（或加）到零，所以操作次数就是$max(x,y)$

举例

```cpp
c = { 4 , -2 , -1 , 5 , -3 }
c = { 2 ,  0 , -1 , 5 , -3 }
c = { 1 ,  0 ,  0 , 5 , -3 }
c = { 0 ,  0 ,  0 , 5 , -2 }
c = { 0 ,  0 ,  0 , 0 ,  3 }
```

第二问。回顾操作两个步骤：“先是正负抵消，剩下的最后一个数，再单独把这个数递减（或加）到零。”那么我们第一步进行完以后一定会得到这个数组：

$$
c = \{ 0,0,0,0,0,···，0，0，x-y \} 
$$

当$x-y > 0$时，我们可以选择将区间$[1,n]$都加$x-y$,或者将区间$[n,n]$ 减$x-y$，这两种得到的答案就是最终的答案区间，这个区间覆盖的数字个数就是$|x-y| + 1$。所以最终答案为$|x-y| + 1$。

同理反之亦然。

为什么不用模拟操作？

因为我们已经直接算出结果来了鸭

## AC代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
long long max(long long a,long long b){return a > b ? a : b;}
long long n;
long long a[100099];
long long c[100099];
int main(){
    cin >> n;
    for(long long i = 1;i <= n; i++) cin >> a[i];
    long long x,y;
    x = y = 0;
    for(long long i = 1;i < n; i++){
        c[i] = a[i+1] - a[i];
        if(c[i] < 0){
            x -= c[i];
        }else{
            y += c[i];
        }
    }

    cout << max(x,y) << endl;

    cout << abs(x-y) + 1 << endl;

    return 0;
}
```

---

## 作者：Mr_QwQ (赞：30)

这个题远没有$NOI+$吧……

毕竟我这种小蒟蒻都能做出来。

先差分一波，求出相邻两个数的差。

接下来的就成了：差分数组的一个数加$1$或减$1$（原数组里选上$n$或者选上$1$），或两个不同的数分别加$1$和减$1$，求把差分$2-n$变成0的最小步数。

于是乎我们发现：正数和负数可以对消

然后把能消掉的一步到位，不能两个一起消的就跟$0$（一个假想的位置，实际操作上选上$1$）或者$n+1$（选上$n$）消。

第一问完毕。

对于第二问，为了最小步数，显然只能靠最后不能跟别的一起消掉的数字贡献答案。那么如果跟$1$消就是改变了答案，跟$n$消就不改。

代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n;
long long a[100010],x[100010],t1,t2;
long long myabs(long long t){
	if(t>0)return t;
	return -t;
}
long long mmax(long long x1,long long x2){
	if(x1>x2)return x1;
	return x2;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lld",a+i);
	for(int i=2;i<=n;i++){
		x[i]=a[i]-a[i-1];
		if(x[i]>0)t1+=x[i];
		else t2-=x[i]; 
	}
	printf("%lld\n%lld",mmax(t1,t2),myabs(t1-t2)+1);
	return 0;
}
```
你问我为什么WA了两次？因为我最开始写的是```printf("%d\n%d"...)```（逃

---

## 作者：BinDir0 (赞：23)

## 这道题是一道**差分**的题目

差分数组p即$p[i]=a[i]-a[i-1]$

如果我们把一个区间$[l,r]$里的数$+1$，那么我们不难发现$p[l]'=a[l]+1-a[l-1]=p[l]+1,p[r+1]'=a[r+1]-(a[r]+1)=p[r+1]-1$

即一次将两个$p[i]+1 or -1$


### ---------------差分数组介绍完毕-------------------------

**首先我们看第一小问：输出最少操作次数使所有数相等，即令$p[i]==0(i!=1)$**

我们可以根据之前得到的结论推广：

若 $p[2]==1,p[3]==-2$，那么我们最少需要两次操作；

若 $p[2]==1,p[3]==-2,p[4]==4$，那么我们最少需要五次操作；

若 $p[2]==1,p[3]==-2,p[4]==4,p[5]==-2$，那么我们最少需要五次操作；

......

不难看出，若把原p数组中正数之和表示为a，负数绝对值之和表示为b，那么我们最少需要$max(a,b)$次操作。

**再看第二小题。**

题目可以理解为：在一问的条件下，$p[1]$的值有多少种情况？

无需赘述，我们可以发现，当我们$min(a,b)$次操作后，数组p中定然只会剩下$p[1]$与一些同号的数。对于之后的$|a-b|$次操作，我们可以选择让$p[1]$变动或不变，这样一来$p[1]$的值就会有$1+|a-b|$种可能的值。

完结撒花qwq~

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[101000],p[101000],z,f,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        p[i]=a[i]-a[i-1];
    }
    for(int i=2;i<=n;i++)
    {
        if(p[i]>0)
        z+=p[i];
        else
        f-=p[i];
    }
    long long ans=abs(z-f),an=max(z,f);
    cout<<an<<"\n"<<1+ans;
    return 0;
}

```


---

## 作者：Micnation_AFO (赞：13)

- [原题链接](https://www.luogu.com.cn/problem/P4552)
- [$\texttt{AC}$ 记录](https://www.luogu.com.cn/record/65200721)


------------
## 主要思路：差分

差分的定义：对于一个数列 $A$，那么它的差分数列 $B$ 定义为：
$$ B_i = A_i (2 \leq i \leq n) - A_{i - 1} , B_1 = A_1$$


------------
举个例子：
$$A= \lbrace 5, 4, 6, 7, 3 \rbrace $$
$$B= \lbrace 5, -1, 2, 1, -4 \rbrace $$


------------
**把原数列的“区间修改”操作改为差分数组的“单点修改”：**

若把 $A$ 的区间 $[l,r]$ 加上 $d$，那么我们只需要对差分数组进行如下两个操作：
-  $B_l += d$
-  $B_{r + 1} -= d$

对于 $l$ 到 $r$ 之间的其他数，因为 $A_i += d(l < i < r)$ 且 $A_{i + 1} += d(l < i < r)$，所以 $A_{i + 1} - A_i$ 的值不变，即 $B_i$ 不变。有了这个性质，我们稍加分析即可解决此题。

首先，我们令 $B_{n + 1} = 0$，这是为了利用上述性质时 $r = n$ 的情况。那么，我们的目标就是将所有的 $B_i$（$i \leq 2 \leq n$） 变成 $0$。由于题目中要求我们每次可以使一个区间加或减去 $1$，所以每次操作，我们可以任意将 $B$ 数组中的两个元素一个加 $1$ 一个减 $1$（将 $B_i$ 与 $B_j$ 一个加、一个减 $1$，相当于在 $A$ 中区间 $[l, r]$ 同时加或减 $1$）。

**此时，问题被我们简化为：**
已知一个差分数组 $B$，每次可以任意将其中两个值一个加 $1$，一个减 $1$，直到所有的 $B_i$（$i \leq 2 \leq n$） 为 $0$，求最优方案的操作次数，以及在操作次数最小的前提下，有多少种操作的方案。

显然，对于每次操作，我们选择 $B$ 中的 $2$ 个元素共可以分为以下 $4$ 中情况（以下的 $i$，$j$ 都满足 $1 < i, j \leq n$）：
1. 选择 $B_i$ 和 $B_j$，即 $A$ 数列中的区间 $[i, j - 1]$。
1. 选择 $B_1$ 和 $B_j$，即 $A$ 数列中的区间 $[1, j - 1]$。
1. 选择 $B_i$ 和 $B_{n + 1}$，即 $A$ 数列中的区间 $[i, n]$。
1. 选择 $B_1$ 和 $B_{n + 1}$，即 $A$ 数列中的区间 $[1, n]$。

而第四种操作不会对 $B_i$（$i \leq 2 \leq n$）产生任何影响，所以是无意义的，不做讨论（更直观的理解是整个 $A$ 数组全部加或减 $1$，显然是浪费次数的）。

此时，不难想到具体的操作方案：
1. 令 $p$ 为差分序列里正数绝对值的总和，令 $q$ 为差分数列中负数绝对值总和。
1. 此时，不断重复进行操作 $1$，进行了 $\min(p, q)$ 次后，$p$ 和 $q$ 必定其中有一个是 $0$，而另一个是 $\left\vert p - q\right\vert$。
1. 剩下的 $\left\vert p - q\right\vert$ 就不断进行操作 $2$ 或操作 $3$ 即可。
4. 根据步骤 $2$ 和步骤 $3$ 可得：次数一共是 $\min(p, q) + \left\vert p - q\right\vert$，化简得 $\max(p, q)$。

第一个问题解决了，那么第二个问题也变得很容易。既然完成所有操作后只有 $B_1$ 不为 $0$，那么我们只需要讨论 $B_1$ 的可能的数量就是第二个问题的答案。那么 $B_1$ 会有哪些情况呢？很显然是 $B_1 \pm 0, B_1 \pm 1, B_1 \pm 2, …, B_1 \pm \left\vert p - q\right\vert$ 共 $\left\vert p - q\right\vert + 1$ 个。


------------

如果觉得文字说明过于抽象，那么我们可以举一个例子试试（数列 $A$ 与 $B$ 就以文章开头的为例）：

前三步 $B$ 的变化：
```c++
5 0 1 1 -4
5 0 0 1 -3
5 0 0 0 -2  
```
此时显然还差两步就完成操作了（除 $B_1$ 外全为 $0$），因此 $B_1$ 的值可能为 $5$，$4$ 或 $3$，即共有 $3$ 种方案。

$\texttt{AC}$ 代码：
```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define maxn 100005
int n, sum1, sum2;
int a[maxn], b[maxn];

signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        b[i] = a[i] - a[i - 1];
        if (i == 1) continue;
        (b[i] >= 0) ? (sum1 += b[i]) : (sum2 -= b[i]);
    }
    cout << max(sum1, sum2) << endl;
    cout << abs(sum1 - sum2) + 1 << endl;
    return 0;
}

```

---

## 作者：expnoi (赞：12)

题中要使所有数都一样。那么，也就是说，在差分的数组中，**除了第一个数字外，其他的数字必须为0。**

那么我们要做的，就是使**除了第一个数字外，其他的数字必须为0。**

我们知道差分的公式为```c[l]+=v;c[r+1]-=v;```

那么我们可以得出结论：

**最少次数就是在差分序列中的正数相加的值和负数相加的绝对值的较大值。**

那么，如何解决方法的种数呢？这又是转换法，开始我也想得不是很明白，知道老师提醒了做法才想明白。

思考，差分后的**第一个数字的种数**是不是就是题目要求的方法数量。

那么要改变差分的第一个数字，是不是以```c[1]++,c[i]--```或```c[1]--,c[i]++```的方法来改变。

由于要求步数最少，要在差分数组中所有的正数或负数已经和其他数相互抵消完后，才能用```c[1]```来勾兑。

那么答案就是正数和负数的绝对值的最大值减去正数和负数的绝对值的最小值。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n , a[100001],C[100001],sum1=0,sum2=0;
signed main()
{
	cin >> n;
	for(int i = 1 ; i <= n ; i++)
	{
		cin >> a[i];
	}
	for(int i = 2 ; i <= n ; i++)
	{
		C[i] = a[i] - a[i - 1];
		if(C[i] > 0) sum1 += C[i];
		else sum2 -= C[i];
	}
	cout << max(sum1 , sum2) << "\n" << abs(sum1 - sum2) + 1 << "\n";
}
```

---

## 作者：rediserver (赞：12)

# P4552 [Poetize6] IncDec Sequence
[原题地址](https://www.luogu.org/problem/P4552)  
[Github](https://github.com/jerrykcode/luogu)  

## 思路

考虑原数组a(长度为n，下标0到n - 1)的差分数组d:  
* d[0] = a[0]
* d[i] = a[i] - a[i - 1]，i属于[1, n - 1]

那么:

* 若数组a的所有元素相同，那么数组d除d[0]外所有元素为0，而d[0]的值就是a的每个元素的值。
* 若数组a在[l, r]区间(l <= r < n - 1)内每个数增加1，则d[l]增加1，而d[r + 1]减少1
* 若数组a在[l, n - 1]区间(l <= n - 1)内每个数增加1，则d[l]增加1，其余不变(n - 1 + 1 = n，d[n]已越界)
* 若数组a在[l, r]区间(l <= r < n - 1)内每个数减少1，则d[l]减少1，而d[r + 1]增加1
* 若数组a在[l, n - 1]区间(l <= n - 1)内每个数减少1，则d[l]减少1，其余不变

### 到这里，原题可以转化为:  
对原数组a的差分数组d进行以下3种操作
* d[i]增加1且d[j]减少1，i <= n - 1 && j <= n - 1 && i != j	`(一增一减)`
* d[i]增加1，i <= n - 1	`(单独增加)`
* d[i]减少1，i <= n - 1	`(单独减少)`

使得数组d除d[0]外所有元素为0。求最少的操作次数，以及在保证最少次数的前提下，最终得到的数组d中，d[0]有多少种不同的值~

那么如何操作呢  
由于d[0]不用转换为0，所以对于i属于[1, n - 1]:  
若d[i] > 0，则要将其减少为0，可以使用多次d[i]减少1的操作，但是题目要求`操作次数最少`，所以若存在j != 0使得d[j] < 0，就可以使用d[i]减少1而d[j]增加1的操作，这样比单独让d[i]减少效率更高。  
d[i] < 0时同理。  
也就是`对于每个d[i]，只要它不等于0，就要找d中除d[0]外与d[i]符号相反的数，这样一次操作可以使两个数更接近0；只有在不存在符号相反的数时，才使用单独一个数增加/减少的操作。`  

那么编程的时候，需要对每个d[i]去找符号相反的数吗，如果这样写，就会开心的TLE了。实际上，我只需要`计算出数组d除d[0]外所有元素中，正数之和与负数的绝对值之和`，正数之和设为positive，负数绝对值之和设为negative，由于所有正数都需要找负数，而所有负数都要找正数，设positive和negative中大的为max，小的为min，那么`max就是所求最少操作次数`，其中`min次操作为一增一减，max - min次操作为单独增加/减少`。

还有一个问题就是d[0]可以有多少种不同的值。我们上面的操作都是不针对d[0]的，因为它不用变为0嘛，但是`对于所有的单独一个数增加/减少的操作，可以有一种代替的操作`，即:  
`d[i]增加1`，可以通过`d[0]减少1且d[i]增加1`代替，唯一的不同是d[0]减少了1，而d[0]变成多少对最少操作次数没有影响！  
同理`d[i]减少1`，可以通过`d[0]增加1且d[i]减少1`代替。  
而每一个单独一个数增加/减少的操作，如果它像这样被代替了，那么d[0]就会增加1或者减少1。显然，有多少个单独增加/减少操作，d[0]就`多了`多少种可能。由前面已知，有max- min个单独增加/减少操作，那么`d[0]有max - min + 1种不同的值`。

## 代码
```c
#include "stdio.h"
#include "stdlib.h"

typedef long long LL;

int main() {
	int n;
	scanf("%d", &n);
	LL  d, pre, a;
	LL positive = 0, negative = 0;
	int i;
	for (i = 0; i < n; i++) {
		scanf("%lld", &a);
		//求差分
		//这里d没有使用数组，第i次循环的d表示d[i]
		if (i) d = a - pre;
		else d = a;
		pre = a;
		if (i) {
		//计算除d[0]外正数之和与负数绝对值之和
			d > 0 ? (positive += d) : (negative -= d);
		}
	}
	LL max = positive > negative ? positive : negative;
	LL min = positive > negative ? negative : positive;
	//最少max次操作，max - min次单独增加/减少操作，d[0]有max - min + 1种不同的值
	printf("%lld\n%lld", max, max - min + 1);
	return 0;
}
```

---

## 作者：QwQcOrZ (赞：12)

其它题解对于第二问的证明好像写的都不是很清晰，故此这里补一个

------------

考虑将原数组差分

那么区间加的操作就变成了取两个数 $l\leq r$，使 $a_{l-1}=a_{l-1}+1,a_r=a_r-1$，区间减同理

此时我们发现目标状态变成了差分数组变为全 $0$

那么第一问就很好做了，只要将差分数组中的正数和负数分别取出来然后配对，然后剩下的进行前缀或后缀的操作即可

设正数的和为 $x$，负数绝对值的和为 $y$

则第一问答案为 $min(x,y)+max(x,y)-min(x,y)=max(x,y)$

观察一下就能发现将正数和负数配对删除后差分数组中只剩下零和正数或者只剩下零和负数

那么也就是说未差分数组是非降或者非升的

所以从最小值到最大值都可以通过前后缀的操作得到了

于是第二问的答案就为 $max(x,y)-min(x,y)+1$

$Code Below$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=1e5+5;
const ll inf=1ll<<32;

inline ll read()
{
	register ll s=0;
	register char c=getchar(),lc='+';
	while (c<'0'||'9'<c) lc=c,c=getchar();
	while ('0'<=c&&c<='9') s=s*10+c-'0',c=getchar();
	return lc=='-'?-s:s;
}
void write(register ll x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x<10) putchar(x+'0');
	else
	{
		write(x/10);
		putchar(x%10+'0');
	}
}
inline void print(const register ll x,const register char c='\n')
{
	write(x);
	putchar(c);
}
ll a[N];

int main()
{
	ll n=read(),u=0,v=0;
	for (ll i=1;i<=n;i++) a[i]=read();
	for (ll i=2;i<=n;i++)
	{
		ll x=a[i]-a[i-1];
		if (x>0) u+=x;
			else v-=x;
	}
	print(max(u,v));
	print(max(u,v)-min(u,v)+1);

	return 0;
}
```

---

## 作者：zyc____ (赞：10)

# 一道经典差分。

### 进入正题

#### 先考虑输出第一行：

要求最少操作使得数列全部相等。

- 如果我们将数列差分起来，就要让全部数都相等，那么就是要让差分数组中每一项都为0，如果我们留下第一项的，只将[2,n]的差分数组变为0，那么数列就都是第一项的值了。所以我们只在[2,n]的差分序列上做操作。我们操作的可以转换成了让dif[l]+1,dif[r+1]−1和dif[l]−1,dif[r+1]+1，所以我们考虑将差分数组中的正数和负数一一配对互消，那么最后如果剩下一些正数，那么就修改dif[i]+1,dif[n+1]−1。

#### 接下来考虑第二问：

- 上面讲过，我们留下了第一项，所以数列中所有数会变成第一项的数，所以就考虑最优情况下，第一项可以有多少种取法即可。

- 也就是考虑剩下的那些正数（或负数）和第一个位置互相抵消一部分（剩余的再和n抵消）的的情况，就是dif[1]+1,dif[i]−1

代码：

 ```cpp
#include <bits/stdc++.h> 
using namespace std;
#define N 1000010  
int a[N],b[N],n,i;  
long long x,y,ans; 
int main()  
{  
    scanf("%d",&n); 
    for (i=1;i<=n;i++) scanf("%d", &a[i]);  
    for (i=2;i<=n;i++)  
    {  
        b[i]=a[i]-a[i-1];  
        if (b[i]>0) x+=b[i]; else y-=b[i];  
    }  
    if (x > y){
        printf("%lld\n",x);
        ans=x-y;
    }
    else{
        printf("%lld\n",y);
        ans=y-x;
    } 
    ans++;
    printf("%lld\n",ans);  
    return 0;  
}  

```


---

## 作者：qjxqjx (赞：3)

## 题目思路：
这题差分即可，经典题，区间变数，多次区间修改，用差分数组。将两数之差存到另一个数组中就是差分数组，若这个数组为 $diff$ ，原数组为 $a$，则 $diff_i=a_i-a_{i-1}$。

好，开始画图：
| 原数组： | 1 | 3 | 4 | 6 | 9 | 2 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 差分数组： | 1 | 2 | 1 | 2 | 3 | -7 |
如上图，其实差分数组最后还有个 2，我画了个图，有点丑，请谅解：
![](https://cdn.luogu.com.cn/upload/image_hosting/yz3n36a7.png)
好，然后我们通过这个数据来过一下。  

看第一问：因为我们要把原数组之间的差变为相同的数，也就是说，我们要把 $diff$ 数组都变为 0，但注意，由于差分数组的性质，$diff_1 =a_1$，所以我们应该从 2 开始循环。我们要把 $diff_2$ 到 $diff_n$ 中的数变为 0。一次选一正一负，因为差分数组中为正数时，原数增加，差值减少；若为负数，原数增加，差值减少。  
详细可以见图：
![](https://cdn.luogu.com.cn/upload/image_hosting/kxu92bkp.png)

到这里我们可以发现，结果多出来了个 1，为什么呢？  
因为我们没包含 $diff_1$ 和 $diff_{n+1}$，所以结果必多出来一点，可是我们不需要把这两个也包含进去。

求最少次数，把正数和和负数和的绝对值取较大值即可，原因如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/v6rpo21g.png)
此图，正数和大于负数和（取过绝对值），所以取正数和。因为无论怎样，抵消完后总会多一个数，而这个数想消掉，必须要单独处理，至于如何处理，我们不管，因为我们不需要管他，正数大，则永远都会剩下一个正数，操作次数就是这个正数，直接输出；负数同理。


------------
然后第二问：	求可能的种数。

简单，差分数组当中的正数和与负数和之和 +1 即可，注意要 +1。

这一问的值，一般与第一问的值比较接近（废话），	联系上一问，我们可以定义两个累加器，分别加正数的和负数的和。

所有答案的可能性都在差分序列当中，其实就是求 $diff_1$ 的可以有多少种，有两种操作可以求 $diff_1$，一步步加或减（不同时进行操作）。因为 $diff_1$ 本身就是个值，所以这也算一种，而一步步的操作和为正数和与负数和的最大值减去最小值，化简为：正数和与负数和的绝对值加 1。
![](https://cdn.luogu.com.cn/upload/image_hosting/wubshak5.png)

最后代码附上前，我还要提出个问题：出于严谨性我希望加强下数据，$a_i$ 的最大值在题目中暴了 int，但是[这样的代码](https://www.luogu.com.cn/paste/68fc57vg)还是能过。

我给一份数据：
```
10
5
1
0
2 
2147483648 
2147483647
2147483648 
2147483647
2147483648 
2147483647
```
正确输出：
```
2147483650
2147483643
```
错误输出：
```
2147483647
2147483643
```
其中，有些人的题解代码也是可以被这个数据给 Hack 掉的，我不点名。

## 代码：
```cpp
#include<bits/stdc++.h>
//#include<iostream>
using namespace std;
const int N=1e5+5;
long long n,a[N],diss[N],ans=0,z=0,f=0;//注意开 long long
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		diss[i]=a[i]-a[i-1];//差分数组
	}
	for(int i=2;i<=n;i++){//注意从2开始循坏
		if(diss[i]>0){
			z+=diss[i];//正数情况
		}else{
			f+=diss[i];//负数情况
		}
	}
	cout<<max(z,-f)<<endl<<abs(z+f)+1;
   //因为f为负所以加上个-号就为正数了，记得取max；第二问
   //要记得+1，两个累加器直接相加取绝对值。
	return 0;
}
```

---

## 作者：bifanwen (赞：2)

[博客园同步](https://www.cnblogs.com/bifanwen/p/15733755.html)

[原题链接](https://www.luogu.com.cn/problem/P4552)

简要题意：

给定长度为 $n$ 的序列 $\{a_i\}$，每次操作可以将任一区间 $[l,r]$ 的所有数加一（或减一），求至少多少次操作可以让序列中所有数相同。并且在保证最小操作数的情况下求相同的数的可能个数（即末状态数）。

$n \leq 10^5$.

区间操作往往可以转换为差分操作。

注意到，如果我们令 $\{c_i\}$ 为 $\{a_i\}$ 的差分数组，也就是：

$$\begin{cases}
c_1 = a_1 \\
c_k = a_k - a_{k-1} (\forall k \in [2,n]) \\
\end{cases}$$

那么，这个时候，对于 $\{a_i\}$ 中，$[l,r]$ 区间的 $+1$ 操作，可以简化为：

$$\begin{cases}
c_{l} \leftarrow c_{l} + 1 \\
c_{r+1} \leftarrow c_{r+1} - 1 \\
\end{cases}$$

同理 $-1$ 操作可以简化为：

$$\begin{cases}
c_{l} \leftarrow c_{l} - 1 \\
c_{r+1} \leftarrow c_{r+1} + 1 \\
\end{cases}$$

同时我们发现，$\{a_i\}$ 全相等时，$\{c_i\}$ 除 $c_1 = a_1$ 外全为 $0$，于是题意转为：

> 给定一个长度为 $n$ 的序列 $\{c_i\}$，每次操作可以选定任意的 $l,r$ 并将 $c_l$ 和 $c_r$ 一个加一，一个减一。求能使得 $c_2 \cdots c_n$ 全部变为 $0$ 的最少操作数，以及变化后 $c_1$ 可能的值的个数。

这里，答案已经呼之欲出了。

很显然，我们应该尽量把一个负数 $c_x$ 和一个正数 $c_y$ 同时进行 **“绝对值逼近 $0$” 的加减操作**，通过 $\min(c_x,c_y)$ 次可以得到 $0$. 于是我们将所有正数的和记为 $p$，负数的 **绝对值** 的和记为 $q$，显然，想要消灭所有正数（或负数）需要 $\min(p,q)$ 次。而对于剩下的数，我们可以将其和 $c_1$ 进行加减操作。于是第一问答案为 $\max(p,q)$，这是十分明显的。

考虑第二问。注意到，需要满足最小操作数，因此 **“绝对值逼近 $0$” 的加减操作** 是不可能改变 $c_1$ 的。但是注意到，最后对于剩下的数，当只剩下一个数 $c_n \not = 0$ 的时候（注意一定是 $n$），我们就可以不一定选定 $[1,x]$ 操作。可以直接选定 $[n,n+1]$ 进行操作（想象你变化原数组末位的时候，后面一位的差分值也会变），而不是改变 $c_1$. 也只有在这个时候才能在保证最小操作数的情况下使得 $c_1$ 有更多可能性。此时 $|c_n| = |p-q|$ 显然。

于是第二问答案为 $|p-q|+1$.

时间复杂度：$\mathcal{O}(n)$.

代码实现中，差分利用滚动一波过去了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e5+1;
typedef long long ll;

int n;
ll p,q;

int main() {
	scanf("%d",&n);
	int x; scanf("%d",&x);
	for(int i=2;i<=n;i++) {
		int y; scanf("%d",&y);
		if(y>x) p+=y-x;
		else q+=x-y;
		x=y;
	}
	printf("%lld\n%lld\n",max(p,q),abs(p-q)+1);
	return 0;
}
```

---

## 作者：惜时如金 (赞：2)

# 这是一道~~水题~~

## [**更好的阅读体验**](https://www.cnblogs.com/xishirujin/p/11413612.html)
---
这道题，我觉得代码难度不大，但是思维难度还是有的qwq。  
刚拿到这道题，我第一眼看过去还以为是~~积木大赛~~（是我瞎了，对不起）  
但是，看到这道题，我们会想到使用差分，所以，我就试着用差分写一下。然后，好像就过了（震惊.jpg）  
下面就来说一下这道题。  
首先，我们得到这个数列之后先将这个数列进行差分，得到差分数组b[1]~b[n+1]  
我们再来考虑一下本题目的要求，使我们得到完全一致的数列，那么转换到差分数组来说，就是2~n全部为0。  
所以，我们的每一次修改对于差分数组来说，就只会修改两个数  
>操作1：修改b[i],b[j]（2≤i,j≤n）这步操作对于一正一负的操作十分有效。  
>操作2： 修改b[1],b[i]这步操作对于正数变为0进行有效操作。  
>操作3： 修改b[i],b[n+1]这步操作对于负数变为0进行有效操作。  
>操作4:修改b[1],b[n+1]，此操作无效，并没有对数列产生有效影响。  

所以，当我们梳理完可以对于差分数组的所有有效操作后，我们就可以很简单的得出答案。  
我们要统计b[2]~b[n]中间正数的和sumz，负数的和sumf  
如果对于sumf和sumz我们要尽可能多的进行操作1，对于剩余的进行操作2、3，即可。又因为每一次操作2、3，对于b[1]的影响不同，所以方案数不同。  
操作次数：$ max（sumf，sumz）$  
方案数：$ |sumf-sumz|+1 $  
代码：  

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=1e5+7;
int b[N],a[N],n;
long long sumz,sumf;

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        b[i]=a[i]-a[i-1];
    }
    // b[n+1]=0;
    for(int i=2;i<=n;i++){
        if(b[i]>0)sumz+=b[i];
        else sumf+=b[i];
    }
    sumf*=-1;
    // printf("%lld %lld\n",sumz,sumf);
    printf("%lld\n",max(sumz,sumf));
    printf("%lld\n",abs(sumz-sumf)+1);
}
```

这道题是一道差分好题，比较考验思维。  


---

## 作者：dz_ice (赞：2)

[欢迎来看看呀](https://www.cnblogs.com/dzice/)

[题目链接](https://www.luogu.com.cn/problem/P2890)

这道题可以转化为求出原数列的差分数组，然后使得最终得到的数列中所有数都相等就可以转化为将差分数组中的所有数都变成零，并求出最小的操作次数以及最终有多少种方式

我们再来看一看题中所说的操作，选定一个区间$[l,r]$并将其中的数+1或-1，设差分数组$b[i]$,那么可以发现这个操作的本质就是将$b[l]$加一或减一以及将$b[r+1]$减一或加一，为了使最终操作次数最少，尽量要选出差分数组里的一个正数和一个负数来执行这个操作

举个例子，差分数组0 3 -2 3 0 -5 -3

我们执行上述操作后可以得到另外几个差分数组0 0 0 0 0 -1 -3或者0 0 -2 0 0 -2 0，根据题目的要求可以很显然的发现通过这两种方式求的的最终答案是一样的，设差分数组中正数的和为$s1$,负数的和的绝对值为$s2$,那么执行这一种操作的次数即为$min(s1,s2)$

然后还有两种很重要的操作，第一种是选择$[0,i]$区间进行加减操作，第二种是选择$[i,n]$区间，可以将差分数组中的一个数变为零，执行这一种操作的的次数即为$|s1-s2|$，并且所得结果的种数也取决于这两种操作，最高可以达到$max(s1,s2)$,最低可以达到$min(s1,s2)$,所以答案种数便为$|s1-s2|+1$

综上所述，$ans1=min(s1,s2)+|s1-s2|=max(s1,s2)$,$ans2=|s1-s2|+1$

代码比较简单

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[100003],b[100003],s1,s2;
signed main()
{
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&a[i]);
		if(i!=1)
		{
			b[i]=a[i]-a[i-1];
			if(b[i]>0)
				s1+=b[i];
			else
				s2-=b[i];
		}
	}
	cout<<max(s1,s2)<<endl<<abs(s1-s2)+1;
	return 0;
}
```






---

## 作者：Doubeecat (赞：1)

一道有意思的差分题目，第一个问题相当于积木大赛，可以直接分析也可以根据差分性质来搞。  
首先做 $a$ 数列的差分数列 $b$，那么问题就变成了使得$b_2...b_n = 0$  
首先考虑配对一个正数一个负数 这样操作次数是最少的 首先考虑这种 
这种的操作次数为 $\min(p,q)$ ($p,q$为差分数列正数和，负数和)

显然，这样会造成最后至多一个数没有消灭，此时可以将它与 $b_1$ 或者 $b_{n+1}$ 配对。
由于两种配对方式不同，会出现$|p-q|+1$种序列，并且最小次数为$|p-q|$
于是就解决了本题。
```cpp
#include <cstring>
#include <cstdio>
#include <cctype>
#include <cmath>
#define ll long long
#define ri register int

char buf[1 << 20], *p1, *p2;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2)?EOF: *p1++)
template <typename T> inline void read(T &t) {
	ri v = getchar();T f = 1;t = 0;
	while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();}
	while (isdigit(v)) {t = t * 10 + v - 48;v = getchar();}
	t *= f;
}
template <typename T,typename... Args> inline void read(T &t,Args&... args) {
		read(t);read(args...);
	}
const int N = 100010;

template <typename T> inline T min(T x,T y) {return x<y?x:y;}
template <typename T> inline T max(T x,T y) {return x>y?x:y;}

ll a[N],b[N],n,p,q;
int main() {
    read(n);
    for (int i = 1;i <= n;++i) read(a[i]);
    for (int i = 2;i <= n;++i) {b[i] = a[i]-a[i-1];if (b[i] > 0)p+=b[i];else q -=b[i];}
    printf("%lld\n%lld",max(p,q),abs(p-q)+1);
    
    
    
}

```

---

## 作者：_CloudySky_ (赞：0)


求出a的差分序列b,其中 $b_{1}=a_{1}$，$b_{i}=a_{i}-a_{i-1}(2≤i≤n)$。令 $b_{n+1}=0$。(一会有大用)

题目对序列a的操作，相当于每次可以选出 $b_{1},b_{2},…,b_{n+1}$ 中的任意两个数，一个加1，另一个减1。目标是把 $b_{2},b_{3},…,b_{n}$ 变为全零。最终得到的数列 $a$ 就是由 $n$ 个 $b_{1}$ 构成的。

从 $b_{1},b_{2},…,b_{n+1}$ 中任选两个数的方法可分为四类:
1. 选 $b_{i}$ 和 $b_{j}$，其中 $2≤i,j≤n$。这种操作会改变 $b_{2},b_{3},…,b_{n}$ 中两个数的值。应该在保证 $b_{i}$ 和 $b_{j}$ 一正一负的前提下，尽量多地采取这种操作，更快地接近目标。
2. 选 $b_{1}$ 和 $b_{j}$，其中 $2≤j≤n$。
3. 选 $b_{i}$ 和 $b_{n+1}$，其中 $2≤i≤n$。
4. 选 $b_{1}$ 和 $b_{n+1}$，这种情况没有意义，因为它不会改变 $b_{2},b_{3},…,b_{n}$ 的值，相当于浪费了一次操作，一定不是最优解。

设 $b_{2},b_{3},…,b_{n}$ 中正数总和为 $p$，负数总和的绝对值为 $q$。首先以正负数配对的方式尽量执行第1类操作，可执行 $\min(p,q)$ 次。剩余 $|p-q|$ 个未配对，每个可以选与 $b_{n}$ 或 $b_{n+1}$ 配对，即执行第2或3类操作，共需 $|p-q|$ 次。

综上所述，最少操作次数为 $\min(p,q)+|p-q|=\max(p,q)$ 次。根据 $|p-q|$ 次第2、3类操作的选择情况，能产生 $|p-q|+1$ 种不同的 $b_{1}$ 的值，即最终得到的序列a可能有 $|p-q|+1$ 种。

摘自《算法竞赛进阶指南》

知道这些之后，你就会惊奇的发现，这道题不用差分序列！
只要在读入时维护正数的和以及负数和的绝对值就可以了，避免了不必要的空间浪费。

代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int Maxn=100010;
long long a[Maxn],b;
int main(){
	int n;
    long long p=0,q=0;  //分别维护正数的和以及负数和的绝对值
	scanf("%d",&n);
	scanf("%lld",&a[1]);  //要先读入第一个数，因为第一个数没有差分
	for(int i=2;i<=n;i++){
		scanf("%lld",&a[i]);  //读入
		b=a[i]-a[i-1];  //你可以理解为一个临时的差分序列
		if(b>=0)p+=b;
		if(b<0)q+=-b;
	}
	printf("%lld\n",max(p,q));  //输出最少操作次数
	printf("%lld\n",p>q?p-q+1:q-p+1);  //输出结果数，即|p-q|+1
	return 0;
}

```


---


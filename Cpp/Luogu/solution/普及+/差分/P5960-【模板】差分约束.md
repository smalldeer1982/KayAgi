# 【模板】差分约束

## 题目描述

给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：

$$ \begin{cases} x_{c_1}-x_{c'_1}\leq y_1 \\x_{c_2}-x_{c'_2} \leq y_2 \\ \cdots\\ x_{c_m} - x_{c'_m}\leq y_m\end{cases}$$

的不等式组，求任意一组满足这个不等式组的解。

## 说明/提示

**样例解释**

$\begin{cases}x_1-x_2\leq 3 \\ x_2 - x_3 \leq -2 \\ x_1 - x_3 \leq 1 \end{cases}$

一种可行的方法是 $x_1 = 5, x_2 = 3, x_3 = 5$。

$\begin{cases}5-3  = 2\leq 3 \\ 3 - 5 = -2 \leq -2 \\ 5 - 5  = 0\leq 1 \end{cases}$

**数据范围**

对于 $100\%$ 的数据，$1\leq n,m \leq 5\times 10^3$，$-10^4\leq y\leq 10^4$，$1\leq c,c'\leq n$，$c \neq c'$。

**评分策略**

你的答案符合该不等式组即可得分，请确保你的答案中的数据在 `int` 范围内。

如果并没有答案，而你的程序给出了答案，SPJ 会给出 `There is no answer, but you gave it`，结果为 WA；    
如果并没有答案，而你的程序输出了 `NO`，SPJ 会给出 `No answer`，结果为 AC；       
如果存在答案，而你的答案错误，SPJ 会给出 `Wrong answer`，结果为 WA；    
如果存在答案，且你的答案正确，SPJ 会给出 `The answer is correct`，结果为 AC。

## 样例 #1

### 输入

```
3 3
1 2 3
2 3 -2
1 3 1```

### 输出

```
5 3 5```

# 题解

## 作者：Stephen_Curry (赞：679)

 _**题解 [P5960 【【模板】差分约束算法】](https://www.luogu.com.cn/problem/P5960)**_   
 
 发布时间：2020.02.05  
 最近一次更新时间：2022.08.31
 
 写在前面：本题解已经经过 $7$ 次审核，还请管理大大留情。  
 [更新日志迁移到了这里](https://www.luogu.com.cn/paste/2yad9zc0)

------------


**差分约束系统**

如果一个不等式组由 $n$ 个变量和 $m$ 个约束条件组成，形成 $m$ 个形如 $x_j-x_i\leq k$（$i,j\in[1,n]$ 且 $k$ 为常数）的不等式，则称其为**差分约束系统**。换句话说，差分约束系统就是求解一组变量的不等式组的算法。

样例其实可以更为直观地写成以下不等式组：

$\begin{cases}x_1-x_2\leq 3 \\ x_2 - x_3 \leq -2 \\ x_1 - x_3 \leq 1 \end{cases} $

显然，这组不等式组的解是不唯一的，通过口算可以算出其中三组较小解：

$\begin{cases}x_1=5 \\ x_2=3\\x_3=5\end{cases}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{cases}x_1=0 \\ x_2=-2\\x_3=0\end{cases}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{cases}x_1=0 \\ x_2=0\\x_3=2\end{cases}$

------------


**问题转化**

对于 $x_j-x_i\le k$，我们会发现它类似最短路网络中的三角不等式 $d_v-d_u\le w_{<u,v>}$，那是否可以通过最短路的形式解决呢？

显然是可以的，跑一遍最短路，此时最短路的答案 $d_i$ 也正是原不等式组的一个解 $x_i$。

此时，可将每个变量看成一个顶点，并设一个超级源点 $x_0$，它连向每个顶点（除了自身）且边权为 $0$，这时再对每一个不等式 $x_j-x_i\le k$ 连一条边权为 $k$ 的有向边 $<i,j>$，此时用 $x_j$ 表示超级源点到 $j$ 的最短路，用 $x_i$ 表示超级源点到 $i$ 的最短路，由于有边 $<i,j>$ 存在，从而有 $x_j\le x_i+k$，即为原不等式的变形。

在有解的情况下，最短路的答案 $d_i$ 就是原不等式组的一组解 $x_i$。

------------
**连边方法**（2021.08.21 修改）

前文提到过，差分约束问题可以转化为最短路或最长路问题，所以两种转化也就形成了两种不同的连边方法。

1. 连边后求最短路  
将 $x_j-x_i\le k$ 变形为 $x_j\le x_i+k$，即从 $i$ 到 $j$ 连一条边权为 $k$ 的边。加入超级源点后求最短路，得到 $x_i\le 0$ 所有 $x$ 最大解。

2. 连边后求最长路  
将 $x_j-x_i\le k$ 变形为 $x_i\ge x_j-k$，即从 $j$ 到 $i$ 连一条边权为 $-k$ 的边。加入超级源点后求最长路，得到 $x_i\ge 0$ 所有 $x$ 最小解。

显而易见的，两种方法求出来的解大概率是不同的。样例中，用第一种方法得到的解为 $\begin{cases}x_1=0 \\ x_2=-2\\x_3=0\end{cases}$，而用第二种方法得到的解为 $\begin{cases}x_1=0 \\ x_2=0\\x_3=2\end{cases}$。

------------
**负环/正环判断**

那么，如果万一用最短路求时出现负环，或用最长路时出现正环怎么办？

 _注：本段只考虑求最短路时的情况，最长路实质与最短路类似。_

此时，咱们先不考虑怎么解决，先看这时的不等式组是什么样子的。

![](https://cdn.luogu.com.cn/upload/image_hosting/a64d78ub.png)

如上图，该图存在负环，如果一直沿着负环走，最短路径将会越来越小，最后到达 $-∞$。

而此时的不等式组为

$\begin{cases}x_1\le x_3+3 \\ x_2\le x_1-5\\x_3\le x_2-3\end{cases}$

经过替换，得 $x_1\le x_1-5$，这是不可能成立的。类似地，可以得出结论：若图中存在负环，则该不等式组无解。

此时，即可放心大胆地 SPFA，只需在 SPFA 的同时用一个数组来记录每个顶点**入队**次数，如果一个顶点入队次数大于 $n$，说明该图存在负环。（具体原因 StudyingFather 的题解里已经解释得很清楚了，这里就不再赘述了）

------------
**最长路问题**（2021.08.21 修改）

题解里面普遍使用最短路求解，这里我来讲一下最长路的解法。

不过在说之前，这里还是要说一下区别于最短路的**最长路问题**。

最长路问题即为在给定的图中，计算从源点到所有顶点的最长路。保证图中没有正环。

其中一种实现方法为若 $d_u+w>d_v$，则将 $d_v$ 更新为 $d_u+w$（实际上就是把最短路中的大于号改成小于号），并在初始化时将 $d$ 数组全部初始化为一个极小值，其余部分和用 SPFA 求最短路一样。

------------
**代码分解讲解**

讲了这么多，这里便是重点了。

首先要实现 SPFA 求最长路，通过修改模板可以写出：

```cpp
struct edge {
    int v, w, fail;
    //评论区有说不是 fail 是 tail 的……
    //确实，但变量名根据个人习惯有异是正常的，我一直到退役前都用的 fail.
    edge() {}
    edge(int _v, int _w, int _fail) {
        v = _v;
        w = _w;
        fail = _fail;
    }
} e[M << 1];
bool spfa(int u) {
    memset(vis, false, sizeof(vis));
    vis[u] = true;
    memset(dis, -1, sizeof(dis));  //因为是最长路，故要初始化为负数
    dis[u] = 0;
    memset(in, 0, sizeof in);
    in[u] = 1;
    queue<int> q;
    q.push(u);
    while (!q.empty()) {
        u = q.front();
        q.pop();
        vis[u] = false;
        for (int j = head[u]; ~j; j = e[j].fail) {
            int v = e[j].v;
            int w = e[j].w;
            if (dis[v] < dis[u] + w) { // 求最长路，和求最短路相反
                dis[v] = dis[u] + w;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = true;
                    ++in[v];
                    if (in[v] > n + 1) {  //判断负环，因为加了一个超级源点，故应跟 n + 1 而不是 n 比较。
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
```
由于个人习惯，我比较倾向于将 `head` 数组初始化为 $-1$，于是便有了下面初始化函数：

```cpp
void init() {
    memset(head, -1, sizeof(head));
    len = 0;
}
```

紧接着便是 `add` 函数，都是板子，不讲：

```cpp
void add(int u, int v, int w) {
    e[len] = edge(v, w, head[u]);
    head[u] = len++;
}
```

最后就是主函数内容了，因为前文说了要对每一个不等式 $x_j-x_i\le k$ 从 $j$ 到 $i$ 连一条边权为 $-k$ 的边，从而调用 `add` 函数应为 `add(u, v, -w)`。

在不确定图是否完全联通的情况下，我们要添加一个超级源点 $x_0$ 与每个点都有一条权值为 $0$ 的边，前文已经说过。

```
for (int i = 1; i <= n; ++i) {
    add(0, i, 0);
}
```
最后看 SPFA 结果，若为真说明无解，输出 `NO`，否则依次输出 $dis_i$。

------------
**代码实现**

[无注释代码奉上](https://www.luogu.com.cn/paste/aml5n172)。

------------
 _以下为 $\text{2020.02.12}$ 更新的内容 。_

显然 SPFA 码量大还容易写炸 ~~（其实是自己太蒻老是写挂）~~，所以个人比较建议用 Bellman-Ford 算法来解决本题。

------------

**Bellman-Ford 算法描述**（$\text{2022.04.17}$ 修改）

1. 除源点外的所有顶点最短距离初始化为 $∞$，源点 $d_1$ 最短距离为 $0$。
2. 对边集 $E$ 进行 $n-1$ 次松弛操作。
3. 检查是否存在负权边，即是否存在未收敛的点。若存在，说明图存在负环，原不等式组无解；否则 $d_i$ 即为 $x_i$ 的一个解。

------------
**描述解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/dhab4edu.png)

相信像窝一样的蒟蒻们看到上面的算法描述肯定一头雾水，下面就来解释一下。

$Q_1$：为什么进行 $n-1$ 次松弛操作？  
$A_1$：因为图的最短路径不包含负环或正环，故显然最多只能包含  $n-1$ 条边。

$Q_2$：何谓松弛操作？  
$A_2$：一次松弛操作即描述点 $s$ 到点 $v$ 的最短路权值上界，反复进行松弛操作可求出两点最短路。举个例子，若要松弛 $\left(u,v\right)$ 一边，即是取 $s\to v$ 的最短路与 $s\to u\to v$ 的最短路的最小值。

$Q_3$：何谓“未收敛”？  
$A_3$：未收敛即为仍能松弛，此时路径仍非最短。若经过 $n-1$ 轮松弛操作后仍能松弛，说明图存在负权回路。

------------
**代码分解详解**

显然首先我们要建立一个结构体记录每条边的起点 $u$，终点 $v$ 与权值 $w$，不妨将此数组命名为 $e$。

```cpp
struct edge { 
    int u, v, w; 
} e[5050];
```

读入部分唯一要注意建边要建反向边，不难得出以下代码：

```cpp
scanf("%d%d", &n, &m);
for (int i = 1; i <= m; ++i) {  //这里不能写成while(m--)，因为m在后面还要使用
    scanf("%d%d%d", &c, &c1, &y);
    e[i].u = c1, e[i].v = c, e[i].w = y; //反向边
}
//初始化因为太简单直接省略，不会的可以看后面的全代码
```

紧接着是 Bellman-ford 算法核心部分。首先第一重循环控制松弛操作的次数：

```cpp
for (int i = 1; i < n/*等价于 <= n-1，因为共 n-1 次松弛操作*/; i++) {

}
```

第二重循环控制松弛的边，即对哪一条边进行松弛操作；循环内即是更新 $d_{e_i.v}$ 的值。

```cpp
// Bellman-Ford 核心代码 
for (int i = 1; i < n; ++i) {
    for (int j = 1; j <= m; ++j) { //共 m 条边
        //d[i] 表示从 1 到 i 的最短路
        d[e[j].v] = min(d[e[j].u] + e[j].w, d[e[j].v]);
    }
}
```

最后判断是否存在未收敛的点，代码与核心代码判断是否松弛的代码仅仅是把 $j$ 改成了 $i$ 而已。

```cpp
for (int i = 1; i <= m; ++i) 
	if (d[e[i].v] > d[e[i].u] + e[i].w)  //仍能松弛
	    return !printf("NO");  //直接结束程序
```

否则依次输出 $d_1,d_2,\dots,d_n$ 即可。

[完整代码也还在这个剪贴板里，往下翻](https://www.luogu.com.cn/paste/aml5n172)。

标准二十行代码，当前最短解 ~~（预感不保）~~ （2021.08.21 更新：早就被超了）。

------------
**算法对比**（2021.08.21 修改）

现在来对比一下两种算法。

![](https://cdn.luogu.com.cn/upload/image_hosting/ebihmwdg.png)

显然 SPFA 虽然代码长，但速度明显更快；Bellman-Ford 代码短，速度较慢。

顺带提一句，SPFA 最坏情况下与朴素 Bellman-Ford 相同，为 $O(VE)$，碰到部分凉心出题人时请慎用。

![](https://cdn.luogu.com.cn/upload/pic/26431.png)

------------
_以下为 $\text{2020.02.13}$ 更新的内容 。_

关于算法问题暂时先讲到这里。如果还有不懂的话欢迎评论区询问我。

这里是想到关于差分约束有一些推论与定理，想在这里说一说。

（部分内容借鉴算法导论）

------------

对于每个 $x_j$ 和 $x_i$，显然有 $x_j-x_i=(x_j+d)-(x_i+d)$。

从而若向量 $x$ 满足 $A_x\leq b$，则向量 $x+d$ 同样满足该条件。

听不懂？我们就拿样例来说吧。

样例给的输出是 $\begin{cases}x_1=5 \\ x_2=3\\x_3=5\end{cases}$，那么将 $x_1,x_2,x_3$ 同时加上或减去任意一数，它必然也满足条件。

从而，我们得出了推论 1：**设向量 $x=(x1,x2,\cdots,x_n)$为差分约束系统 $A_x\leq b$ 的一个解，设 $d$ 为任意常数，则 $x+d=(x_1+d,x_2+d,\cdots,x_n+d)$ 也是该差分约束系统的一个解。**

由该推论，我们可以把或许求出的很怪异的不等式解变成正整数解，看起来更自然。

------------
推论 2：**给定差分约束系统 $A_x\leq b$，设 $G=(V,E)$ 是该差分约束系统所对应的约束图，若图 $G$ 不包含负环，则**  
$$x=(\delta(v_0,v_1),\delta(v_0,v_2),\delta(v_0,v_3),\dots,\delta(v_0,v_n))$$  
**是该系统的一个可行解。**

证明：

考虑任意一条边 $(v_i,v_j)\in E$，根据三角不等式，$\delta(v_0,v_j)\le\delta(v_0,v_i)+w(v_i,v_j)$，从而 $x_j-x_i=\delta(v_0,v_j)-\delta(v_0,v_i)\le w(v_i,v_j)$，命题得证。

由该推论，我们可以自然而然的想到 SPFA 和 Bellman-Ford 这两种算法了。

------------
**算法引申**

当然，很多类似差分约束的问题都不会像这题一样良（du）心（liu），它们很可能不会只局限于形如 $x_j-x_i\le k$，有可能会有 $x_j-x_i\ge k$ 或 $x_j-x_i=k$ 之类的式子存在。

其实只需改动建边方法即可解决。$x_j-x_i\ge k$ 的情况很简单，相信大家稍加思考就可以想通。而 $x_j-x_i=k$ 时，只需将它拆成 $x_j-x_i\le k$ 和 $x_j-x_i\ge k$ 两种情况建两条边即可。

------------
**算法优化**

关于两种算法的优化其实有很多，这里随便举出几种。

1. SPFA 可以通过 SLF 或 LLL 优化策略进行优化；
2. 此处举出的 Bellman-Ford 算法没有加入超级源点，所以跑出来的结果是 $0,\inf,\inf+2$，不好看。可以考虑加入超级源点。

------------
**参考资料**

《算法导论》

~~百度百科~~（$\text{2022.04.17}$ 修改：已经替换下所有百度百科的内容）。

------------
以上便是本题解的全部内容。

写了这么多，希望这篇题解能帮助到您。

由于篇幅过长，当中难免有纰漏之处，如您有发现请私信本蒟蒻，有空一定会去修的。

完。

---

## 作者：StudyingFather (赞：164)

UPD（2020/12/23）：修正了入队次数为 $n$ 即判断有负环的 bug。

UPD（2024/08/22）：修正了 `dis` 数组没有开 `long long` 导致溢出的问题。

一个差分约束系统是这样的：

给出 $n$ 个变量和 $m$ 个约束条件，形如 $x_i - x_j \leq c_k$，你需要求出一组解，使得所有约束条件均被满足。

怎样解这个差分约束系统呢？我们将上面的不等式变形一下：

$$
x_i \leq x_j + c_k
$$

容易发现这个形式和最短路中的三角形不等式 $dis_v \leq dis_u + w$ 非常相似。

因此我们就将这个问题转化为一个求最短路的问题：比如对于上面这个不等式，我们从 $j$ 向 $i$ 连一条权值为 $c_k$ 的边。

接下来，我们再新建一个 $0$ 号点，从 $0$ 号点向其他所有点连一条权值为 $0$ 的边。

这个操作相当于新增了一个变量 $x_0$ 和 $n$ 个约束条件：$x_i \leq x_0$，从而将所有变量都和 $x_0$ 这一个变量联系起来。

然后以 $0$ 号点为起点，用 Bellman-Ford 跑最短路。如果有负权环，差分约束系统无解。否则设从 $0$ 号点到 $i$ 号点的最短路为 $dis_i$，则 $x_i = dis_i$ 即为差分约束系统的一组可行解。

## 负环的判断

建议先做 [P3385](https://www.luogu.com.cn/problem/P3385)，不过这里还是先大概讲一下吧。

首先，如果点 $u$ 到点 $v$ 的路径上存在一个负环，则 $u \to v$ 的最短路不存在（可以一直绕着这个负环走，从而最短路可以取到 $-\infty$）。

原图中有 $n+1$ 个点（注意添加了一个超级源点），如果不存在负环的话，则最短路最多经过 $n+1$ 个点，$n$ 条边（没有负环时，一个点经过两次显然不优）。

用 Bellman-Ford 的话，最多会执行 $n$ 轮松弛操作（啥是松弛？简单来说就是根据三角形不等式更新最短路的过程），如果 $n$ 轮松弛结束后仍然存在能松弛的边，则一定存在负环。

啥你用的是 SPFA？

（偷偷告诉你 SPFA 码量比 Bellman-Ford 长而且最坏复杂度和 Bellman-Ford 一样）

那就统计一个点入队的次数，如果一个点进队了 $n+1$ 次那就一定有负环。

## 扩展

很多时候差分约束的条件并不是简单的小于等于号，这时候我们需要稍微做点变形。

如果有 $x_i - x_j \geq c_k$，则可以两边同时乘 $-1$，将不等号反转过来。

如果有 $x_i - x_j = c_k$，则可以把这个等式拆分为 $x_i - x_j \leq c_k$ 和 $x_i - x_j \geq c_k$ 两个约束条件。

## Code

```cpp
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
using i64 = long long;
const int maxn = 5'000;
const int maxm = 10'000;
struct edge {
  int v, w, next;
} e[maxm + 5];
int head[maxn + 5], tot[maxn + 5], vis[maxn + 5], cnt, n, m;
i64 dis[maxn + 5];
void addedge(int u, int v, int w) {
  e[++cnt].v = v;
  e[cnt].w = w;
  e[cnt].next = head[u];
  head[u] = cnt;
}
bool spfa(int s) {
  queue<int> q;
  memset(dis, 63, sizeof(dis));
  dis[s] = 0, vis[s] = 1;
  q.push(s);
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    vis[u] = 0;
    for (int i = head[u]; i; i = e[i].next) {
      int v = e[i].v;
      if (dis[v] > dis[u] + e[i].w) {
        dis[v] = dis[u] + e[i].w;
        if (!vis[v]) {
          vis[v] = 1, tot[v]++;
          if (tot[v] == n + 1) return false;  // 注意添加了一个超级源点
          q.push(v);
        }
      }
    }
  }
  return true;
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) addedge(0, i, 0);
  for (int i = 1; i <= m; i++) {
    int v, u, w;
    cin >> v >> u >> w;
    addedge(u, v, w);
  }
  if (!spfa(0))
    cout << "NO" << endl;
  else
    for (int i = 1; i <= n; i++) cout << dis[i] << ' ';
  return 0;
}
```

---

## 作者：wsyhb (赞：94)

## 目录
- 前言

- 前置知识

- 定义

- 算法详解

- 易错点

	1. 用错算法

	2. 图不连通

- 代码

## 前言
最近刷题时，偶然做到一道差分约束的简单题。明明以前学过差分约束，却怎么写都写不对。回过头来发现差分约束的模板题都没过，费了好大劲才解决。

为了不让其他学习差分约束的 OIer 们跟我犯同样的错误，我特地写下这篇题解，**讲解了一下基本的算法思路，整理了常见的错误**，希望每一个 OIer 都能在这篇题解中有所收获！

另外，如果您在这篇题解中发现任何错误或不当之处，欢迎在评论区指出！
## 前置知识
在阅读这篇题解前，你需要掌握 `Bellman-Ford` 或 `SPFA` 求解单源最短路径。

（模板：[P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)）
## 定义
如果一个系统由 $n$ 个变量 $a_1,a_2,\cdots,a_n$ 和 $m$ 个约束条件组成，每个约束条件均为形如 $a_i-a_j \leq k$ 的不等式（$i,j \in [1,n]$，$k$ 为常数），则称其为**差分约束系统**。

换句话说，差分约束系统是**求解关于一组变量的特殊不等式组**的方法。

（以上内容摘编自[百度百科](https://baike.baidu.com/item/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F)）
## 算法详解
看到这个不等式，或许你会有点懵，我们先简单变个形：

$\because a_i-a_j \leq k \quad \therefore a_i \leq a_j + k$

或许您会觉得我在侮辱您的智商，不过请继续看下去：

现在将 $m$ 个约束条件分成 $n$ 组，$a_i \leq a_j+k$ 属于第 $i$ 组。

单独考虑第 $i$ 组，设第 $i$ 组共有 $x$ 个条件，每个条件的 $j$ 依次等于 $b_1,b_2,\cdots,b_x$，每个条件的 $k$ 依次等于 $c_1,c_2,\cdots,c_x$。（即这 $x$ 个条件分别为 $a_i \leq a_{b_{_1}}+c_1$，$\cdots$，$a_i \leq a_{b_{_x}}+c_x$）

那么第 $i$ 组条件就等价于：
$$a_i \leq min\{a_{b_{_1}}+c_1,\cdots,a_{b_{_x}}+c_x\}$$

考虑
$$a_i = min\{a_{b_{_1}}+c_1,\cdots,a_{b_{_x}}+c_x\}$$

我们突然发现这是一个最短路的形式 -- 具体来说，**$b_j$ 向 $i$ 连一条长度为 $c_j$ 的边，$a_i$ 为源点到 $i$ 的最短路径距离，那么上述等式就相当于用点 $b_j$ 去更新 $i$。（$j \in \{1,2,\cdots,x\}$）**

我们回到一开始的式子 $a_i \leq a_j+k$，根据上述分析，我们可以将其转化为从 $j$ 到 $i$ 的一条长度为 $k$ 的边，那么 $a_i$ 就转化成了源点到 $i$ 的最短路径距离。

------------

上述不等式组显然有可能无解，那么怎么**判定无解**呢？

由于 $a_i$ 是一组最短路的解，那么只需判定最短路是否无解即可。

什么，你不知道如何判定最短路无解？

当然是**判负环**呀！

具体来说，如果不存在负环，`Bellman-Ford` 在 $n$ 次松弛后就该结束了，所以只需要**再尝试松弛一次**，如果多的这一次松弛成功，说明有负环，无解；否则有解。

再说说 `SPFA` 判负环，道理其实是一样的。你每次将一个点丢进队列里，相当于是对这一个点的所有出边进行松弛，那么只需要**记录每个点的进队次数**，若超过 $n$，说明松弛次数太多，有负环，无解；否则有解。

------------

**另外一种思路**

在一开始的推导中，我们将 $a_i$ 移到了等式的一边，现在我们尝试将 $a_j$ 移到等式的一边：

$\because a_i-a_j \leq k \quad \therefore a_j \geq a_i - k$

与一开始的推导同理可得，从 $i$ 到 $j$ 连一条长度为 $-k$ 的边，$a_i$ 即为源点到 $i$ 的**最长路径距离**。

那么只需要以此**跑最长路**，并**判断正环**即可。

注：读者可以尝试按照一开始的推导演算一遍，加深理解。
## 易错点
这里是重点，不少题解都没有详细讲解这两点，初学差分约束是很有可能踩雷的！
### 1.用错算法
由于 $k$ 符号不确定，所以**可能有负（正）权边**，这也是为什么我们不能使用 `dijkstra` 算法，而只能使用 `Bellman-Ford` 或 `SPFA` 求最短（长）路的原因。

------------

`dijkstra` **算法求最短（长）路为何不能用于负（正）权边**

（如果您早就明白这是为什么，请自行跳过）

以求最短路为例，`dijkstra` 算法是利用贪心思想，每次用**距离源点最近的、未讨论过的点**去更新其他点的最短距离，有点类似于 `bfs` （宽度优先搜索）。

但当出现负权边时，**后面讨论的点**相较于已讨论的点，**可能会距离源点更近**，导致**已讨论的点会被更新，却不会再次拿来讨论**，此时 $O(n^2)$ 的 `dijkstra` 算法就失效了。

不过，如果使用带有**堆优化**的时间复杂度为 $O(nlog_{_2}m)$ 的 `dijkstra` 算法，它会**退化成** `SPFA` **算法**，相当于将 `SPFA` 算法中的队列换成堆，时间复杂度为 $O(nmlog_{_2}m)$，显然超时。

------------

最后放一个例子，以便读者理解：

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/ur7yo813.png)

以 $1$ 为源点，用 $O(n^2)$ 的 `dijkstra` 算法求解单源最短路，所求得的 $dis_{_4}$ 为 $7$，即路径 $1$ -> $2$ -> $4$。而实际上 $dis_{_4}$ 应该为 $6$，即路径 $1$ -> $3$ -> $5$ -> $2$ -> $4$。

错误原因是 $dis_{_2}=3<dis_{_3}=5$，所以先讨论了点 $2$ ，将点 $4$ 更新，而之后点 $5$ 去更新点 $2$，点 $2$ 却不会再用新的 $dis_{_2}=2$ 去更新点 $4$ 了。
### 2.图不连通
这里可能会存在**点之间既不直接约束也不间接约束**的情况，在建图上的体现就是**图不连通**。

举个简单的例子：（$n=5$，$m=3$）
$$\begin{cases}
x_2-x_1 \leq 5\\
x_5-x_4 \leq 3\\
x_1-x_3 \leq 4\\
\end{cases}$$
依据第一种思路建图如下：

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/lsk6hzvw.png)

此时无论以 $1$ , $2$ , $3$ , $4$ , $5$ 哪个点作为源点，都无法计算出正确答案。（对于 `SPFA`）

理由是**以其中一个点作为源点，只能计算出这个点所在连通块的答案**，并没有计算其他连通块的答案。

------------

**解决方案**

一、`SPFA`

1. **一开始将所有点放入队列**中而不是只放一个起点，这样每个点都被作为起点讨论过。

2. **建一个虚拟源点 $0$，从这个虚拟源点向其他所有点都连一条长度为 $0$ 的边，以虚拟源点为起点放入队列**，这样的效果与前一种完全相同。

二、`Bellman-Ford`

**无需操作**，算出来的答案本来就是正确的。

因为每次松弛是**对所有边进行操作**，不会出现只计算一个连通块的情况。
## 代码
两种思路、两种算法（`SPFA` 及 `Bellman-Ford`）、两种解决方案，**都在下方代码有所体现**！

第一种思路（求最短路）+ `SPFA` + 解决方案1（全部点放入队列）
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int N=5e3+5;//点数
const int M=5e3+5;//边数 
int End[M],Last[N],Next[M],Len[M],e;//链式前向星
void add_edge(int x,int y,int z)
{
	End[++e]=y;
	Next[e]=Last[x];
	Last[x]=e;
	Len[e]=z;
}
int dis[N],cnt[N];//cnt记录各个点入队次数 
queue<int> q;
bool inq[N];//inq标记各个点是否在队列中 
bool spfa(int s)
{
	for(int i=1;i<=n;i++) dis[i]=1e9;//最短路，初始值为inf
	dis[s]=0;
	for(int i=1;i<=n;i++)//全部放入队列
	{
		q.push(i);
		inq[i]=true;
		cnt[i]++;
	}
	while(q.size())
	{
		int x=q.front();
		q.pop();
		inq[x]=false;
		for(int i=Last[x];i;i=Next[i])
		{
			int y=End[i];
			if(dis[y]>dis[x]+Len[i])
			{
				dis[y]=dis[x]+Len[i];
				if(!inq[y])
				{
					q.push(y);
					inq[y]=true;
					cnt[y]++;
					if(cnt[y]>n+1) return false;//返回 false，意味着无解
				}
			}
		}
	}
	return true;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add_edge(y,x,z);
	}
	if(spfa(1))
	{
		for(int i=1;i<=n;i++) printf("%d%c",dis[i],i<n?' ':'\n');
	}
	else printf("NO\n");
	return 0;
}
```
第二种思路（求最长路）+ `SPFA` + 解决方案2（虚拟源点）
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int N=5e3+5;//点数 
const int M=1e4+5;//边数，注意虚拟源点连的边 
int End[M],Last[N],Next[M],Len[M],e;//链式前向星 
void add_edge(int x,int y,int z) 
{
	End[++e]=y;
	Next[e]=Last[x];
	Last[x]=e;
	Len[e]=z;
}
int dis[N],cnt[N];//cnt记录各个点入队次数 
queue<int> q;
bool inq[N];//inq标记各个点是否在队列中 
bool spfa(int s)
{
	for(int i=0;i<=n;i++) dis[i]=-1e9;//最长路，初始值为-inf
	dis[s]=0;
	q.push(s);
	inq[s]=true;
	cnt[s]++;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		inq[x]=false;
		for(int i=Last[x];i;i=Next[i])
		{
			int y=End[i];
			if(dis[y]<dis[x]+Len[i])
			{
				dis[y]=dis[x]+Len[i];
				if(!inq[y])
				{
					q.push(y);
					inq[y]=true;
					cnt[y]++;
					if(cnt[y]>n+1) return false;//返回 false，意味着无解 
				}
			}
		}
	}
	return true;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) add_edge(0,i,0);//虚拟源点连边 
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add_edge(x,y,-z);
	}
	if(spfa(0))
	{
		for(int i=1;i<=n;i++) printf("%d%c",dis[i],i<n?' ':'\n');
	}
	else printf("NO\n");
	return 0;
}
```
第一种思路 + `Bellman-Ford`
``` cpp
#include<bits/stdc++.h>
#define min(a,b) ((a)<(b)?(a):(b)) 
using namespace std;
int n,m;
const int N=5e3+5;//点数 
const int M=5e3+5;//边数 
struct edge
{
	int x,y,z;
}e[M];//存边 
int dis[N];
bool Bellman_Ford(int s)
{
	for(int i=1;i<=n;i++) dis[i]=1e9;
	dis[s]=0;
	for(int t=1;t<=n;t++)
		for(int i=1;i<=m;i++)
			dis[e[i].y]=min(dis[e[i].y],dis[e[i].x]+e[i].z);
	for(int i=1;i<=m;i++)
		if(dis[e[i].x]+e[i].z<dis[e[i].y]) return false;//返回 false，意味着无解 
	return true;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) scanf("%d%d%d",&e[i].y,&e[i].x,&e[i].z);
	if(Bellman_Ford(1))
	{
		for(int i=1;i<=n;i++) printf("%d%c",dis[i],i<n?' ':'\n');
	}
	else printf("NO\n");
	return 0;
}
```

---

## 作者：SDqwq (赞：26)

[${\color{Orange}My}$ ${\color{Yellow}Blog}$](https://www.luogu.com.cn/blog/Sham-Devour/)

[P5960](https://www.luogu.com.cn/problem/P5960)

[前置知识：差分约束](https://www.luogu.com.cn/blog/Sham-Devour/ci-fen-yue-shu)

题意：给出 $n$ 个数 $a_{i}$ 和 $m$ 个形如 $a_{i}-a_{j}\le b$ 的不等式，求出 **任意** 一组满足不等式组的解，若无解输出 `NO`。

我们将 $a_{i}-a_{j}\le b$ 转化为 $a_{i}\le a_{j}+b$ 。

那么我们再来看一下 SPFA 是怎么更新 $dis$ 数组是怎么更新的。

```cpp
for (int i = elast[u]; i != 0; i = e[i].next)
	if (dis[e[i].to] > dis[u] + e[i].len) {
		dis[e[i].to] = dis[u] + e[i].len;
		if (!vis[e[i].to]) {
			q.push(e[i].to);
			vis[e[i].to] = true;
		}
	}
```

也就是 $dis_{i}=\min\left\{dis_{j}+<j,i>\right\}$。

于是在遇到 $a_{i}\le a_{j}+b$ 这样的不等式时，我们可以从 $j$ 到 $i$ 建一条边权为 $b$ 的 **有向边**。

为了避免图不连通的情况，我们需要一个超级源点 $n+1$ ，与点 $i$ 之间连一条边权为 $0$ 的边。

**注意：无解就是有负权回路的情况，需要判断 SPFA 的入队次数，如果一个点的入队次数 $\ge n+1$的话，说明有负环，输出 `NO`**。

最后跑 SPFA 求最短路即可。


### Problem Solving！

### code：

```cpp
#include <stdio.h>
#include <bits/stdc++.h>

using namespace std;

int n, m, cnt, elast[5005], dis[5005], num[5005];
bool vis[5005];

struct edge {
	int to, len, next;
} e[10005];

queue<int> q;

void add (int u, int v, int w) {
	e[++cnt].to = v;
	e[cnt].len = w;
	e[cnt].next = elast[u];
	elast[u] = cnt;
}

bool spfa (int x) {
	dis[x] = 0;
	q.push(x);
	vis[x] = true;
	num[x]++;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		vis[u] = false;
		for (int i = elast[u]; i != 0; i = e[i].next)
			if (dis[e[i].to] > dis[u] + e[i].len) {
				dis[e[i].to] = dis[u] + e[i].len;
				if(!vis[e[i].to]) {
					q.push(e[i].to);
					vis[e[i].to] = true;
					num[e[i].to]++;
					if(num[e[i].to] == n + 1) return false;
				}
			}
	}
	return true;
}

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++)
		dis[i] = INT_MAX;
	for (int i = 1; i <= m; i++) {
		int u, v, w;
		scanf("%d %d %d", &u, &v, &w);
		add(v, u, w);
	}
	for (int i = 1; i <= n; i++)
		add(n + 1, i, 0);
	if (!spfa(n + 1)) {
		printf("NO");
		return 0;
	}
	for (int i = 1; i <= n; i++)
		printf("%d ", dis[i]);
	return 0;
}
```

---

## 作者：Eleven谦 (赞：12)

# 【模板】差分约束
[洛谷P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)

#### 前置知识

想要做对差分约束，负环判定这个知识肯定是要会的，不会的可以[看我的另一篇博客qwq](https://www.cnblogs.com/Eleven-Qian-Shan/p/13225415.html)

另外，若干您不想看题解，也可以直接看[判断负环的模板题P3385](https://www.luogu.com.cn/problem/P3385)

------------
#### 差分约束系统

（以下内容部分摘自《算法竞赛进阶指南》）

- 差分约束系统

差分约束系统是一种特殊的$N$元一次不等式

它包含$N$个变量$X_1$ ~ $X_n$以及$M$各约束条件，每个约束条件都是由**两个变量做差**构成的（所以是差分嘛！），形如$X_i-X_n≤C_k$，其中$C_k$是常数（可以是负数也可以是非负数），$1≤i,j≤N，1≤k≤M$

我们要解决的问题就是：求一组解$X_1=a_1,X_2=a_2···X_n=a_n$，使所有约束条件都得到满足

- 转换思想

差分约束系统的**每个约束条件$X_i-X_n≤C_k$可以变形为$X_i≤X_j+C_k$**

有没有觉得有那么一点点的熟悉？

嗯...和求解单源最短路中的三角形不等式$dis[i]≤dis[j]+e[i].val$（$dis[i]-dis[j]≤e[i].val$）非常相似

因此可以三角形不等式推广：**把每个变量$X_i$看作有向图中的一个节点$i$，对于每个约束条件$X_i-X_n≤C_k$，从节点$j$向节点$i$连一条长度为$C_k$的有向边**

现在来看下面给出的这张图，来讲解一下差分约束中的最短路和最长路（可能有点绕，但是图很好理解）：

![](https://img2020.cnblogs.com/blog/2055990/202007/2055990-20200702195755982-2079640339.png)

从这张图中的例子，我们不难得出（重点啊）：

1. **差分约束跑最短路，跑出的结果是所有解中的最大解**

2. **差分约束跑最长路，跑出的结果是所有解中的最小解**

但是，**最短路和最长路也是可以互相转换**的，什么意思？（需要掌握）

在某些题目中，约束条件形如$x_i-X-j≥C_k$，我们有两种方式解决：

1. 可以从$j$到$i$连一条长度为$C_k$的有向边，然后计算单源最长路，若图中有正环则无解

2. 我们也可以把约束条件转化成$X_j-X_i≤-C_k$，再按单源最短路进行计算

- 解题模型

PS：差分约束是有多组解的，但是题目一般只会要求输出其中任意一种

1. 建立“超级源点0”，将$0$与每个点$i$连一条长为$0$的边，然后以$0$为起点求单源最短路

2. 不建立“超级源点”，将每一个点都入队然后去跑最短路

若图中存在负环，则给定的差分约束系统无解；否则$X_i=dis[i]$就是差分约束系统的一组解 

------------
#### 例题代码

现在给出这道模板题的代码（如下是$SPFA$版本的，下面会给出$Ford$版本的函数段）：

```cpp
#include <bits/stdc++.h>
using namespace std;
queue<int> q;
int n,m,u,v,w,tot;
int dis[200010],vis[200010],cnt[200010],head[200010];

struct node {
	int to,net,val;
} e[200010];

inline void add(int u,int v,int w) {
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].net=head[u];
	head[u]=tot;
}

inline bool spfa() {
	for(register int i=0;i<=n;i++) {
		vis[i]=0;
		dis[i]=20050206;
	}
	dis[0]=0;
	vis[0]=1;
	q.push(0);
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(register int i=head[x];i;i=e[i].net) {
			int v=e[i].to;
			if(dis[v]>dis[x]+e[i].val) {
				dis[v]=dis[x]+e[i].val;
				if(cnt[v]>=n) return false;
				if(!vis[v]) {
					vis[v]=1;
					cnt[v]++;
					q.push(v);
				}
			}
		} 
	}
	return true;
}

int main() {
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;i++) {
		scanf("%d%d%d",&u,&v,&w);
		add(v,u,w);
	}
	for(register int i=1;i<=n;i++) add(0,i,0);
	if(spfa()==false) puts("NO");
	else {
		for(register int i=1;i<=n;i++) printf("%d ",dis[i]);
	}
	return 0;
} 
```

下面是$Ford$版本的函数段，其他的和上面的没什么区别

```cpp
inline bool ford() {
	for(register int i=0;i<=n;i++) dis[i]=20050206;
	dis[0]=0;
	for(register int i=0;i<n;i++) {
		for(register int j=1;j<=tot;j++) {
			if(dis[e[j].fro]+e[j].val<dis[e[j].to]) {
				dis[e[j].to]=dis[e[j].fro]+e[j].val;
			}
		}
	}
	for(register int i=1;i<=tot;i++) {
		if(dis[e[i].fro]+e[i].val<dis[e[i].to]) return false;
	}
	return true;
}

```
------------
#### 好题推荐

- [洛谷P3275  糖果](https://www.luogu.com.cn/problem/P3275)  （差分约束还是算经典的一道题，不过也可以缩点+拓扑A掉）

- [洛谷P1993  小k的农场](https://www.luogu.com.cn/problem/P1993)

- [洛谷SP116  INTERVAL-Intervals](https://www.luogu.com.cn/problem/SP116)

- [洛谷P2294  狡猾的商人](https://www.luogu.com.cn/problem/P2294)  （思路巧妙的差分约束/并查集/贪心/DP（后两种比较玄学））

------------

最后，关于上面其他好题的题解我会陆陆续续更新在[我的博客中，欢迎大家来踩qwq](https://www.cnblogs.com/Eleven-Qian-Shan/)

如果有任何不懂或是我的题解有误的，欢迎大家在评论区留言，我会及时回复、改正，谢谢大家啊orz

------------

---

## 作者：ix35 (赞：10)

## P5960 差分约束算法

这个题的套路可能大家比较清楚，就是转化成一个图论问题。对于不等式：

$$x_a-x_b\leq c$$

移项可以得到：

$$x_b+c\ge x_a$$

即 $x_b,c,x_a$ 构成一组三角形不等式。而三角形不等式在图论领域的最短路中也有出现，形式是：

$$dis_u+w(u,v)\ge dis_v$$

其中 $dis_u$ 表示某一点到 $u$ 点的最短路径长度，$w(u,v)$ 表示 $u$ 到 $v$ 的边权。

于是我们建立一张图，对于每一组最上面那样的不等式，从 $b$ 向 $a$ 建立一条权值为 $c$ 的边，跑最短路即可。

这里采用 Bellman-Ford 实现，下面是我第一次提交的代码（AC）：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=5010,INF=0x3f3f3f3f;
int n,m,x,y,z,eg,hd[MAXN],ver[2*MAXN],nx[2*MAXN],edge[2*MAXN],dis[MAXN];
void add_edge (int x,int y,int z) {
	ver[++eg]=y;
	nx[eg]=hd[x],edge[eg]=z;
	hd[x]=eg;
	return;
}
int main () {
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) {
		scanf("%d%d%d",&x,&y,&z);
		add_edge(y,x,z);
	}
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;
	for (int i=1;i<=n-1;i++) {
		for (int j=1;j<=n;j++) {
			for (int k=hd[j];k;k=nx[k]) {
				dis[ver[k]]=min(dis[ver[k]],dis[j]+edge[k]);
			}
		}
	}
	for (int i=1;i<=n;i++) {
		for (int j=hd[i];j;j=nx[j]) {
			if (dis[ver[j]]>dis[i]+edge[j]) {
				printf("NO\n");
				return 0;
			}
		}
	}
	for (int i=1;i<=n;i++) {printf("%d ",dis[i]);}
	printf("\n");
	return 0;
}
```
注意我这里代码中直接跑了从 $1$ 出发的单源最短路，这样做其实有一些不太好的地方。

首先这只实用于 Bellman-Ford，如果 SPFA 从 $1$ 开始，那么只能处理同一连通块内的答案，无法处理非连通图。

而且，这样跑出来的结果比较神奇，样例跑出来是 $0\qquad INF\qquad INF+2$，答案不太好看。

所以比较好的办法是建立超级源点 $n+1$ 向 $1$ 到 $n$ 中所有点建立一条 $0$ 权边，再跑最短路，就不用管连通性的问题。

实现时不一定要真正建出超级源点，其实只要把所有最短路一开始设成 $0$ 即可。

这样可以得到一组比较正常的解了，样例：$0\qquad -2\qquad 0$。

但是有的题目需要我们输出一组非负整数解，怎么办呢？

容易发现，当 $(x_1,\cdots,x_n)$ 满足所有不等式时，对于任意的 $d$，$(x_1+d,\cdots,x_n+d)$ 也满足不等式（差分后 $d$ 抵消），因此我们令所有 $x_i$ 整体平移至非负整数即可，令 $ans=\min\limits_{i\in [1,n]} (x_i)$，则 $(x_1-ans,\cdots,x_n-ans)$ 即是一组非负正数解，如果要正整数解，再加一个 $1$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=5010,INF=0x3f3f3f3f;
int n,m,x,y,z,eg,ans,hd[MAXN],ver[2*MAXN],nx[2*MAXN],edge[2*MAXN],dis[MAXN];
void add_edge (int x,int y,int z) {
	ver[++eg]=y;
	nx[eg]=hd[x],edge[eg]=z;
	hd[x]=eg;
	return;
}
int main () {
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) {
		scanf("%d%d%d",&x,&y,&z);
		add_edge(y,x,z);
	}
	for (int i=1;i<=n-1;i++) {
		for (int j=1;j<=n;j++) {
			for (int k=hd[j];k;k=nx[k]) {
				dis[ver[k]]=min(dis[ver[k]],dis[j]+edge[k]);
			}
		}
	}
	for (int i=1;i<=n;i++) {
		for (int j=hd[i];j;j=nx[j]) {
			if (dis[ver[j]]>dis[i]+edge[j]) {
				printf("NO\n");
				return 0;
			}
		}
	}
	for (int i=1;i<=n;i++) {ans=min(ans,dis[i]);}
	for (int i=1;i<=n;i++) {printf("%d ",dis[i]-ans);}
	printf("\n");
	return 0;
}
```







---

## 作者：Implicit (赞：9)

### P5960 差分约束算法

一个差分约束系统是这样的：

> 给出 $n$ 个变量和 $m$ 个形如 $x_i-x_j\le c_k$ 的约束条件，你需要求出一组解，使得所有约束条件均被满足。

首先显然如果 $x_1,x_2,\dots,x_n$ 为差分约束系统的一组解，那么显然对于 $d\in \mathbb Z$，$x_1+d,x_2+d,\dots,x_n+d$ 仍然是差分约束系统的一组解（因为差分式 $x_i-x_j$ 不变嘛）。

首先移个项，原式就变成 $x_i\le c_k+x_j$ 了。

我们发现这和图论里的三角形不等式 $dis_u\le dis_v+w(u,v)$ 很像，其中 $w$ 指边权。

所以我们考虑建图跑最短路求解，对于每个约束条件 $x_i-x_j\le c_k$，我们连一条 $j\to i$ 的有向边，边权为 $c_k$。

然后我们建一个虚拟源点 $0$，对于所有 $i$，连一条 $0\to i$ 且权值为 $0$ 的边，显然权值为 $0$ 的边对于跑最短路没有影响。

然后以 $0$ 为源点跑最短路，差分约束就可以得到一组解 $x_i=dis_i$。

关于判无解的问题，显然存在负环（即不存在最短路）即无解。

下面给出一个证明：

考虑任意一条边 $(p_i,p_j)\in \mathbf E$，根据三角形不等式， $dis_{p_j}\le dis_{p_i}+w(p_i,p_j)$，故 $x_j-x_i=dis_{p_j}-dis_{p_i}\le w(p_i,p_j)$。

命题获证。

关于判负环，简单说一下：你每次将一个点丢进队列里，相当于是对这一个点的所有出边进行松弛，那么只需要记录每个点的进队次数，若超过 $n$，说明松弛次数太多，有负环。

所以跑一边 spfa 即可（如果您很强可以加一下优化比如 LLL 这种，~~然后出道 EX~~）。

Code:

```cpp
#include<iostream>
#include<map>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int N=10005;
typedef vector<pair<int,int> > graph[N]; // 用的 vector 存图
graph g;
inline void add(int u,int v,int w){g[u].push_back(make_pair(v,w));}
int n,m,dis[N],num[N];
bool vis[N];
bool spfa() // spfa 板子
{
	memset(dis,0x3f,sizeof dis);
	queue<int> q;
	int s=0; dis[s]=0; q.push(s); vis[s]=1; num[s]=0;
	while (!q.empty())
	{
		int x=q.front(),S=g[x].size(); q.pop();
		vis[x]=false;
		for (int i=0;i<S;i++)
		{
			int y=g[x][i].first, w=g[x][i].second;
			if (dis[y]>dis[x]+w)
			{
				dis[y]=dis[x]+w; num[y]=num[x]+1;
				if (num[y]>n) return false; // 判负环原理是入队次数 > n
				if (!vis[y]){vis[y]=true; q.push(y);}
			}
		}
	}
	return true;
}
int main()
{
	cin>>n>>m;
	for (int i=1,u,v,w;i<=m;i++){cin>>u>>v>>w; add(v,u,w);} // 注意是 add(v,u,w)
	for (int i=1;i<=n;i++) add(0,i,0);
	if (spfa()) // 如果无负环
	{
		int minn=0x3f3f3f3f;
		for (int i=1;i<=n;i++) minn=min(minn,dis[i]); // 减到绝对值最小，虽然没什么用，但是方便手玩样例
		for (int i=1;i<=n;i++) cout<<dis[i]-minn<<' ';;
	}
	else cout<<"NO";
	return 0;
}
```

***

引申

对于给定的不是 $x_i-x_j\le c_i$ 的形式的情况下：

- $x_i-x_j\ge c_i$：$x_i-x_j\ge c_i\Leftrightarrow x_j-x_i\le -c_i$，当然你也可以跑一边最长路。
- $x_i-x_j< c_i$，$x_i-x_j> c_i$：因为求的是整数解，所以加一即可。
- $x_i-x_j=c_i$：$x_i-x_j=c_i\Leftrightarrow [x_i-x_j\le c_i]\land[x_i-x_j\ge c_i]$。

---

## 作者：那一条变阻器 (赞：9)

~~啊这，为什么一道看上去完全跟图论无关的题有图论标签。~~

修改了一下对转化时连边的理解，然后就交不上了（雾）。

------------

## 正题（以下没有特殊说明，均求的是最短路）：

**差分约束系统&&转化：** 顾名思义，差分约束系统就是给你很多个形如$x_1-x_2\leqslant c_k$的不等式（其中c为常数），让你求出一组解或者判断无解。看上面的式子，把它变成这样：$x_1\leqslant x_2+c_k$，然后可以发现$x_1$的最小值就为$x_2+c_k$，这样一来，我们就可以把$x_2$向$x_1$连一条有向边，边权为$c_k$来跑最短路，跑到的最短路的值，就是一组答案。

**为什么是正确的呢?** 在多个不等式中，对于一个数$x$，我们可以通过自己所在的不等式来确定自身范围，而一个不等式有两个未知数，另外一个未知数又通过其他不等式与其他未知数相关系起来，这就搭建起来了一条条边，组合成图，从任意一个点出发，一个一个点的满足，最终肯定会到达x的，这样也就得出了一组解。

**差分约束系统也可以跑最长路** 差分约束系统中，最短路和最长路的区别就是：最短路是求的所有解中最大的一组，而最长路相反。看这样一组式子：  $\begin{cases}x_2-x_1\leqslant c_1\\x_3-x_2\leqslant c_2\\x_3-x_1\leqslant c_3\end{cases}$ 我们可以得出这样两个式子：$\begin{cases}x_3\leqslant x_1+c_3\\x_3\leqslant x_1+c_1+c_2\end{cases}$ ，可以得出，约束$x_3$的有两个条件，正好图里面也有两条路。我们要求$x_3$的最大值时，取的肯定是$x_1+c_3$和$x_1+c_1+c_2$里面的最小值，这样才能满足所有的约束条件，也就是最短路了。最长路求的最小解同理（最长路的建边方式有所不同，具体建边方式可以根据转化那个板块推一下）。

**什么情况无解：** 最短路里面有负环时无解。再看一组式子：$\begin{cases}x_1-x_3\leqslant 3\\x_2-x_1\leqslant -5\\x_3-x_2\leqslant -3\end{cases}$，这种情况下，转化成图后就会出现负环，而这组式子最后可以得出一个式子：$x_3\leqslant x_3-5$，跑最短路时，为了满足这个条件，就会一直更新一直更新，也就是出现了负环。所以，有负环的时候，不等式组无解。

接下来就是代码时间咯（当时$SPFA$一直$RE$，也不知道为什么，后来索性写了$Ford$，还是$Ford$香啊~）:
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int l , r , w;
};
node e[5010];
int n , m;
int dis[5010];
int main(){
	cin >> n >> m;
	for(int i = 1; i <= m; i++) cin >> e[i].r >> e[i].l >> e[i].w;	//注意l和r反过来了 
	for(int i = 1; i <= n - 1; i++)
		for(int j = 1; j <= m; j++)
			dis[e[j].r] = min(dis[e[j].r] , dis[e[j].l] + e[j].w);	//松弛 
	for(int j = 1; j <= m; j++)
		if(dis[e[j].r] > dis[e[j].l] + e[j].w){	//判断是否有负环 
			cout << "NO";
			return 0;
		}
	for(int i = 1; i <= n; i++) cout << dis[i] << " ";
	return 0;
}
```


---

## 作者：一只书虫仔 (赞：7)

#### Description

给定 $n$ 个数 $t_i$，然后给定 $m$ 个用 $i,j,b$ 描述的不等式关系
$$t_i-t_j\le b$$

#### Solution

差分约束模板，左边的这个 $t_i-t_j$ 就是差分。

我们首先把这个不等式化简一下，成 $t_i\le t_j+b$。

假设 $t_j$ 已知，我们可以推出 $t_i$ 的最大值只可能是 $t_j+b$，最小不限。

那我们再次假设如果 $t_i$ 跟 $t_{j'}$，$t_{j''}$，$t_{j'''}$ 都有关，我们就可以得到三个不等式，即一个不等式组

$$\begin{cases}t_i\le t_{j'}+b\\t_i\le t_{j''}+b\\t_i\le t_{j'''}+b\end{cases}$$

那么 $t_i$ 满足所有不等式下的最大值应该是 $\min\{t_{j'}+b,t_{j''}+b,t_{j'''}+b\}$。

因为要满足所有不等式，所以必须要取最小值来满足所有的不等式。

注意，我们上面提到的 $j$ 都可以模拟成 $i$ 的 **前继**。

那么我们可以再次简化模型。

假设有多个 $t_j$ 是 $t_i$ 的前继，那么我们就可以得到一个递推式。

$$t_i=\min\{t_j+b\}$$

那么我们看一下 SPFA 的递推式。

$$dist_i=\min\{dist_j+<i,j>\}$$

好了，破案了。

那么我们只需要找一个超级原点 $\rm super$，然后使得他连到 $i$ 的长度是 $t_i$ 即可。

最后我们求一个最短路即可，输出每个 $dist_i-\min\{dist_i\}$。

最后无解的情况只需要判断一下负环即可。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

struct node {
	int val, next, len;
} e[100086];

int n, m;
int cnt;
int head[100086];
int dist[100086];
int sum[100086];
int vis[100086];
const int inf = 0x3f3f3f3f;

void AddEdge (int u, int v, int w) {
	e[++cnt].val = v;
    e[cnt].next = head[u];
    e[cnt].len = w;
    head[u] = cnt;
}

bool SPFA () {
	queue <int> q;
	int s = n + 1;
	for (int i = 1; i <= n; i++)
		dist[i] = inf;
	dist[s] = 0;
	sum[s] = 1;
	vis[s]++;
	q.push(s);
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		sum[cur] = 0;
		for (int p = head[cur]; p > 0; p = e[p].next)
			if (dist[e[p].val] > dist[cur] + e[p].len) {
				dist[e[p].val] = dist[cur] + e[p].len;
				vis[e[p].val]++;
				if (vis[e[p].val] >= n + 1)
					return true;
				if (!sum[e[p].val]) {
					q.push(e[p].val);
					sum[e[p].val] = 1;
				}
			}
	}
	return false;
}

int main () {
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v, w; i <= m; i++) {
		scanf("%d%d%d", &u, &v, &w);
		AddEdge(v, u, w);
	}
	for (int i = 1; i <= n; i++) 
		AddEdge(n + 1, i, 0);
	if (SPFA()) {
		printf("NO");
		return 0;
	}
	int Min = 1e9;
	for (int i = 1; i <= n; i++)
		Min = min(dist[i], Min);
	for (int i = 1; i <= n; i++)
		printf("%d ", dist[i] - Min);
	return 0;
}
```

2020.7.14   
By Shuchong

---

## 作者：XGHDSGSDH1 (赞：6)

更优阅读体验见此 [差分约束 – MindStation](https://www.aytony.top/wordpress/?p=265)~~（可能会炸）~~

差分约束算法的提出巧妙地将数学上的方程和不等式与图论相结合，让我们能够很好地处理与不等式相关的整数问题。

# 理论推导

## 差分约束系统

一个由 $n$ 个变量 $x_1, x_2, \cdots , x_n$ （一般为整型）和 $m$ 个形如 $(a_i, b_i, k_i)$ , 使 $x_{a_i} - x_{b_i} \leqslant (\geqslant) k_i$ 的约束条件组成的不等式组称为差分约束系统。利用差分约束算法，我们可以很方便地求得差分约束系统的一组解。下例便是一个典型的差分约束系统。

 $$\left\{    \begin{aligned}        x_{a_1} - x_{b_1} &\leqslant k_1 \\        x_{a_2} - x_{b_2} &\leqslant k_2 \\                          &\vdots \\        x_{a_m} - x_{b_m} &\leqslant k_m \\    \end{aligned}\right.$$ 
 
## 从最短路到不等式组

这样的一个差分约束系统，其中的每一个约束，可以注意到其形式与图论中求最短路的松弛过程中用到的三角不等式形式相类似。

以下以小于等于形式的约束条件为例。对比约束条件与最短路算法中的松弛操作：

$$x_{a_i} - x_{b_i} \leqslant k_i$$

$$dis_v - dis_u \leqslant w_{u, v}$$

其中下式便是由最短路算法中的 $dis_v \leqslant dis_u + w_{u, v}$ 一式变形而来。

上面两式对照，便引出了**变量与点、约束条件与边**的对应关系。对于每一组约束 $(a_i, b_i, k_i)$ ，连接一条边 $G_i: (a_i \to b_i, k_i)$ 建图，之后再在建成的图上求得一组合法的最短路径 $dis$ , 那么对应每一个变量 $x_i$ , $dis_i$ 就是其对应的解。

举例来看，对于以下 $n = 3, m = 3$ 的一组差分约束系统，我们只需要依照对应法则建好三条边，然后在得到的图上求一遍最短路即可。

| $\left\{    \begin{aligned}        x_2 - x_1 &\leqslant 3 \\        x_3 - x_2 &\leqslant -2 \\        x_3 - x_1 &\leqslant 1 \\    \end{aligned}\right.$|![差分约束-1](https://cdn.luogu.com.cn/upload/image_hosting/gx9o8kk6.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  |
| :----------: | :----------: |

对于上图，一组合法的最短路径便是 $dis_1 = 0, dis_2 = 3, dis_3 = 1$ ， 这就是原约束条件下的一组合法解。

而再考虑到若是原图中存在负环，那么 $dis$ 无解，对应的就是原方程无解。 在此不给出严谨证明，只是通过一组例子理解其合理性。

稍微修改一下上面的例子，得到

|    $\left\{    \begin{aligned}        x_2 - x_1 &\leqslant 3 \\        x_3 - x_2 &\leqslant -2 \\        x_1 - x_3 &\leqslant -2 \\    \end{aligned}\right.$| ![差分约束-2](https://cdn.luogu.com.cn/upload/image_hosting/j7upvcg2.png?x-oss-process=image/resize,m_lfit,h_170,w_225) |
| :----------- | :----------- |

此时，将三个不等式相加后，不等式转变为 $0 \leqslant -1$ , 显然可见原不等式组无解。而正是这三个约束条件在图中构成了一个负环。

故存在结论：**在按照最短路方式构建的图中，只要找出一组可行的最短路解，便能够找出原不等式组的一组解。若图中存在负环，则不等式组无解。**

## 从最长路的角度建图

注意到差分约束系统中的符号不仅可以是小于等于，也可以是大于等于。再遇到这类大于等于条件时，诚然可以通过变形来转化为之前的小于等于的形式来求解，也可以通过求最长路来求解。

与最短路类似，最长路的“松弛”操作也与大于等于的条件类似，此处不再打出。

这里通过一组样例阐述如何用最长路求解。例子与之前的第一个例子相同，但是将其变形为大于等于的形式。注意，建边方向仍然是由减数指向被减数。

|   $\left\{    \begin{aligned}        x_1 - x_2 &\geqslant -3 \\        x_2 - x_3 &\geqslant 2 \\        x_1 - x_3 &\geqslant -1 \\    \end{aligned}\right.$| ![差分约束-3](https://cdn.luogu.com.cn/upload/image_hosting/hom1tbjx.png?x-oss-process=image/resize,m_lfit,h_170,w_225) |
| :----------: | :----------: |

可以看出， $dis_1 = 0, dis_2 = 3, dis_3 = 1$ 仍然是合法的一组最长路，其依然能够得出一组正确的解。同时因为求最长路，所以若图中存在正环则无解。

故存在结论：**在按照最长路方式构建的图中，只要找出一组可行的最长路解，便能够找出原不等式组的一组解。若图中存在正环，则不等式组无解。**

## 求最短路和最长路的方法

以下内容均以最短路建图为例，最长路方法可以类比得出。

一般而言，采取方法都是直接设置一超级源点，假设其下标为 0 ，并从其向每一个点连出一条长度为 0 的边，以简单求得一个合法的解。若是从数学意义上思考，便是设置一个变量 $x_0$ , 并使得

 $$\left\{    \begin{aligned}        &x_0 = 0 \\        &x_i - x_0 \leqslant 0 \quad (i = 1, 2, \cdots , n) \\    \end{aligned}\right.$$ 
 
 然后从 0 号点开始，跑一遍单源最短路经即可。
 
##  最长路与最短路的区别

以下按照最短路方式建的图称为最短路图，最长路图亦然。可以看出，实际上**最长路图就是最短路图的边全部反向，边权全部取负**，其本质是相同的。

不过从其数学意义上讲，存在一个结论：若是以最短路建图，那么跑一个点的单源最短路径，得出的每个点解是其理论上的最大解；而若是以最长路建图，跑一个点的单元最长路径，得出的每个点的解是其理论上的最小解。

这个结论也很好理解，因为最短路的松弛操作便是将一个点的解的上限不断按照条件减小，最终得出来的答案便是理论上的最大解；最长路的“松弛”操作与其相反。这个最长路与最短路的性质在我们解决一些问题时会提供很大的帮助。利用此性质，**我们在想求最大解时，便可以建最长路图；在求最小解时，便建最短路图。**

## 总结出的一些建图经验

1. 注意题目中给出的隐性条件，比如序列 $x_i$ 相邻量之间的关系；
1. $x_a - x_b = c$ 可以拆分成 $x_a - x_b \leqslant c$ 和  $x_a - x_b \geqslant c$ ， $x_a - x_b > c$ 在整数意义下可以改成 $x_a - x_b \geqslant c +1$ ；
1. 判断负环时若有超级源点，那么入队次数大于 n 时才能判断有负环；
1. 必要时可以考虑利用前缀和构造序列，寻找差分约束条件；
1. 充分利用最短路图和最长路图的性质，灵活选取起始点，有时可以不用超级源点；
1. 有时考虑全局情况下可以用 floyd 求全局最短（长）路解题。
1. 有时可以同时建立最短路图和最长路图，分别跑最短（长）路，求得未知数的取值范围；
1. 有时出题人数据毒瘤，可以考虑 SPFA 的优化。本文涉及 swap-SLF 优化。
1. 有时出题人数据毒瘤，可以考虑时间判负环，但是有一定的错误率。

# 代码实现

## 最短路、判断负环

由于存在负权边，Dijkstra 不可用。Floyd 过于简单，在此省略，并给出 SPFA 的一种优化的实现方式。当然，平时的非毒瘤题用裸 SPFA 即可。

带 swap-SLF 优化的 bfs-SPFA: 每次改变队列后，若队首距离大于队尾，则交换首尾。可以避免被一些毒瘤数据卡。

```cpp
const int INF = 0x7f7f7f7f;
int dis[NMAX];

bool SPFA(int begin)
{
    bool inq[NMAX];
    int vis[NMAX];
    deque<int> que;
    memset(dis, INF, sizeof(dis));
    memset(inq, 0, sizeof(inq));
    memset(vis, 0, sizeof(vis));

    dis[begin] = 0;
    que.push_back(begin), inq[begin] = true, vis[begin]++;
    while (!que.empty())
    {
        int fnt = que.front();
        que.pop_front(), inq[fnt] = false;
        if (dis[que.front()] > dis[que.back()]) // swap-SLF
            swap(que.front(), que.back());
        for (register edge *i = head[fnt]; i; i = i->nxt)
            if (dis[i->to] > dis[fnt] + i->w)
            {
                dis[i->to] = dis[fnt] + i->w;
                if (!inq[i->to])
                {
                    que.push_back(i->to), inq[i->to] = true, vis[i->to]++;
                    if (dis[que.front()] > dis[que.back()]) // swap-SLF
                        swap(que.front(), que.back());
                    if (vis[i->to] >= n)
                        return false;
                }
            }
    }
    return true;
}
```

## 最长路，判断正环

至于最长路的求解，只能用 SPFA 或 Floyd ，Dijkstra 由于其贪心本质无法求解最长路。SPFA 和 Floyd 求解最长路代码与最短路基本相同，只有两点修改：

- 对于 SPFA 中的 $dis$ 数组，初始化为负无穷。在此有一技巧，可以定义 NINF = 0x80808080 ，以适用于 memset() 函数。
- 对于二算法的松弛操作，将‘>’改为‘<’即可。

更加详细地，在此给出 SPFA 算法求最长路的代码片段。

```cpp
const int NINF = 0x80808080; // 负无穷
int dis[NMAX];

bool SPFA(int begin)
{
    bool inq[NMAX];
    int vis[NMAX];
    queue<int> que;
    memset(dis, NINF, sizeof(dis));
    memset(inq, 0, sizeof(inq));
    memset(vis, 0, sizeof(vis));

    dis[begin] = 0;
    que.push(begin), inq[begin] = true, vis[begin]++;
    while (!que.empty())
    {
        int fnt = que.front();
        que.pop(), inq[fnt] = false;
        for (register edge *i = head[fnt]; i; i = i->nxt)
            if (dis[i->to] < dis[fnt] + i->w) // 松弛条件
            {
                dis[i->to] = dis[fnt] + i->w;
                if (!inq[i->to])
                {
                    que.push(i->to), inq[i->to] = true, vis[i->to]++;
                    if (vis[i->to] >= n)
                        return false;
                }
            }
    }
    return true;
}
```

## 本题代码

本题使用裸 SPFA ，0 号超级点，最短路建图。

用时 145ms 。

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstdio>
#include <cstdlib>
#include <cstring>

using namespace std;

const int NMAX = 5005;
const int MMAX = 50005;
const int INF = 0x7f7f7f7f;

struct edge
{
    int from, to, w;
    edge *nxt;
};

// 全局
int n, m;
// 图
edge edges[MMAX], *head[NMAX];
int cnt;
// SPFA
int dis[NMAX], vis[NMAX];
bool inq[NMAX];

inline void addline(int from, int to, int w)
{
    edges[cnt] = (edge){from, to, w, head[from]};
    head[from] = &edges[cnt++];
}

bool SPFA(int begin)
{
    queue<int> que;
    dis[begin] = 0;
    que.push(begin), inq[begin] = true, vis[begin]++;
    while (!que.empty())
    {
        int fnt = que.front();
        que.pop(), inq[fnt] = false;
        for (register edge *i = head[fnt]; i; i = i->nxt)
            if (dis[i->to] > dis[fnt] + i->w)
            {
                dis[i->to] = dis[fnt] + i->w;
                if (!inq[i->to])
                {
                    que.push(i->to), inq[i->to] = true, vis[i->to]++;
                    if (vis[i->to] > n + 1)
                        return false;
                }
            }
    }
    return true;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(dis, INF, sizeof(dis));
    for (register int i = 1, c1, c2, y; i <= m; i++)
    {
        scanf("%d%d%d", &c1, &c2, &y);
        addline(c2, c1, y);
    }
    for (register int i = 1; i <= n; i++)
        addline(0, i, 0);

    if (!SPFA(0))
        printf("NO");
    else
        for (register int i = 1; i <= n; i++)
            printf("%d ", dis[i]);
    putchar(10);

    system("pause");
    return 0;
}
```


# 模板与例题

[P5960 【模板】差分约束算法 – 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P5960)

[P2294 [HNOI2005]狡猾的商人 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P2294)

难度较低，转化后直接判断有无解即可。

[SP116 INTERVAL - Intervals - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/SP116)

[1508 Instervals – ZOJ](https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365007)

需要转化并求最大解，考虑最长路。

[P3275 [SCOI2011]糖果 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P3275)

重点在于对不同等式条件的转化。

[P3530 [POI2012]FES-Festival – 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P3530)

[题解 [POI2012] FES-Festival – MindStation](https://www.aytony.top/wordpress/?p=155)

较为综合，需要全局考虑约束条件并结合其他算法。

[P3084 [USACO13OPEN]Photo G – 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P3084)

[题解 [USACO13OPEN]Photo G – MindStation](https://www.luogu.com.cn/problem/P3084)

正解为动态规划，但是差分约束在经过优化处理后也可通过。

[P2474 [SCOI2008]天平 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P2474)

思维难度较大，重点在差分约束条件的寻找，考虑建多个图。

[1420 Cashier Employment – ZOJ](https://zoj.pintia.cn/problem-sets/91827364500/problems/91827364919)

难题，但我还没做（大雾）

------------

参考资料

1. 冯威《数与图的完美结合——浅析差分约束系统》

---

## 作者：Push_Y (赞：2)

 建议先做[P3385 【模板】负环】](https://www.luogu.com.cn/problem/P3385)，安利一下[我那题的题解](https://www.luogu.com.cn/blog/wzsyyh/solution-p3385)


------------

2020.8.14更新，将 'spfa' 等错误改为 `spfs` 。

------------

### 差分约束

将给出的不等式条件移项，得到了$x_{c}≤x_{c'}+y$，可以看成最短路中更新每个节点 $dis$ 的$d[v]≤d[u]+w[u][v]$，然后就是写最短路啦。
 
###  如何判断负环？
 
 用 `spfa` 跑最短路的时候，每次判断队首点的入队次数是否已经达到 $n-1$ 。若有一次满足该条件，则有负环。

### 一些注意点

- 把每个节点与 $i$ 相连的时候倒着 $for$ ，因为数据是卡 `spfa` 的。
- 结构体存两倍 $N$ 的大小
- 更多精彩尽在下方代码中


------------

### 附带详细注释的代码

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gin(){//快读
	char c=getchar();
	int s=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*f;
}

const int N=5e3+5;
int n,m,cnt[N],d[N],tot=0,head[N];
//cnt记录入队次数
bool h[N],t;
//t记录是否为负环
queue<int> q;

struct edge{//用结构体存储链接表
	int dis,ne,to;
}e[N<<1];

inline void add(int u,int v,int w){//连边
	e[++tot].dis=w;
	e[tot].to=v;
	e[tot].ne=head[u];
	head[u]=tot;
}

inline void spfa(){//最短路
	memset(d,63,sizeof d);//初始化
	h[0]=1,t=0,d[0]=0;
	q.push(0);
	while(q.size()){
		int u=q.front();q.pop();h[u]=0;
		if(cnt[u]==n-1){t=1;return;}//如果已经入队了n-1次就出现负环了
		cnt[u]++;
		for(int i=head[u];i;i=e[i].ne){
			int v=e[i].to,w=e[i].dis;
			if(d[v]>d[u]+w){
				d[v]=d[u]+w;
				if(!h[v])h[v]=1,q.push(v);
			}
		}
	} 
}

int main(){
	n=gin(),m=gin();
	for(int i=1;i<=m;i++){
		int u=gin(),v=gin(),w=gin();
		add(v,u,w);
	}
	for(int i=n;i>=1;i--)add(0,i,0);//之前正序被卡，感谢题解区大佬解释
	spfa();
	if(t){printf("NO");return 0;}
	for(int i=1;i<=n;i++)printf("%d ",d[i]);
	return 0;
}

```

---

## 作者：lndjy (赞：2)

### 差分约束

首先，差分约束是几组像 $x_i-x_j\leq y$ 的式子。

这样并不能看出怎么解。所以来魔改一下，变成 $x_i\leq y+x_j$ ,这时可以发现，它和最短路中松弛操作的 $dis_v\leq dis_u+w$ 一样，于是可以转化为最短路模型去解。由于可能有负数，要用SPFA来解。

SPFA如果出现负环，就说明没有最短路，由于最短路就是解，所以如果SPFA判出负环，就是无解。

**注意，要建一个０号点，与所有点连接权值为０的边，这样就转化成了单源最短路。**

代码（有比较详细的注释）
```cpp
#include<iostream>
#include<queue>
using namespace std;
int n,m,cnt;
int head[5005];
struct edge
{
	int to,v,nxt;
}e[11000];
void add(int u,int v,int w)
{
	cnt++;
	e[cnt].v=w;
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}//以上为链式前向星板子
int dis[5005],tot[5005];//SPFA变量，dis为距离，tot为入队次数
bool v[5005];
bool spfa()
{
	for(int i=1;i<=n;i++)
	dis[i]=2e9;
	queue<int> q;
	q.push(0);
	v[0]=1;
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		v[now]=0;
		for(int i=head[now];i;i=e[i].nxt)//遍历
		{
			if(dis[e[i].to]>dis[now]+e[i].v)
			{
				dis[e[i].to]=dis[now]+e[i].v;//松弛操作
				q.push(e[i].to);
				v[e[i].to]=1;
				tot[e[i].to]++;
				if(tot[e[i].to]==n) return 0;//判断负环（入队达到n）
			}
		}
	}
	return 1;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	add(0,i,0);//要建一个０号点，与所有点连接权值为０的边
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		add(b,a,c);//注意是(b,a,c)
	}
	if(!spfa())
	{
		cout<<"NO";//负环无解
	}
	else
	{
		for(int i=1;i<=n;i++)
		cout<<dis[i]<<" ";//有解
	}
	return 0;
}
```


---

## 作者：suxxsfe (赞：1)

## 由于题解在题解界面可能会出现数学公式错误的问题，所以请点击[这里](https://www.luogu.com.cn/blog/suxxsfe/solution-p5960)到博客查看  

&nbsp;

# 差分约束  

差分约束，一般用来解决有$n$个未知数，$m$个不等式方程的问题，形如：  
$$
\begin{cases}
\ x_{a_1}-x_{b_1}\leq y_1\\
\ x_{a_2}-x_{b_2}\leq y_2\\
\ \cdots\\
\ x_{a_m}-x_{b_m}\leq y_m\\ 
\end{cases}
$$  

可以判断有没有解，以及给出一组解  
简单观察可以知道，每个未知数的系数都为$1$，且不等式一边是两个未知数相减，另一边是一个常数  
为了达到这种形式，一般都需要将题目中的关系进行变形  
模板题：[P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)  

# 如何求解  

考虑对于每个不等式$x_i-x_j\leq y$，可以变形成$x_i\leq x_j+y$  
这个式子，可以容易联想到最短路算法中的不等式$dis(v)\leq dis(u)+w$，~~（容易吗？~~  
那么，可以用最短路的方法来求解，从$j$向$i$联一条边权为$y$的边（$i$对应终点$v$）  

然后，就要新建一个虚拟节点$n+1$，从它向每个节点连一个权值为$0$的边，$dis(i)\leq dis(n+1)+0$  
求出的各项$dis(i)$其实就是对应的$x_i$  
又由于$dis(n+1)=0$，所以此时的$dis(i)$均小于$0$，那么我们求出来的这组解，就是所有小于$0$的解里，最大的一组  

那么如果产生了负环，就会出现$x<x$的情况，然后肯定无解，证明应该不难，但不想证了  
因为在一个没有负环的图上，最短路肯定不会经过多于$n$个点，也不会经过多于$n-1$条边  
所以，我们用 spfa 来求解这个最短路问题，如果某个节点入队$n$次，就说明存在负环  
没错，spfa 肯定没死，他是唯一能处理负环的算法（起码我没听说过其它的  

## 最短路  

所以可以写出用最短路实现的代码：  

```cpp  
#include<cstdio>
#include<queue> 
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	int x=0,y=1;
	char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
int n,m;
int fir[5006],nex[10006],to[10006],w[10006],tot;
int cnt[5005],in[5005];
int dis[5005];
std::queue<int>q;
inline void add(int a,int b,int c){
	to[++tot]=b;w[tot]=c;
	nex[tot]=fir[a];fir[a]=tot;
}
inline int spfa(){
	q.push(n+1);
	std::memset(dis,0x3f,sizeof dis);
	dis[n+1]=0;in[n+1]=1;
	while(!q.empty()){
		reg int u=q.front();q.pop();in[u]=0;
		for(reg int v,i=fir[u];i;i=nex[i]){
			v=to[i];
			if(dis[v]>dis[u]+w[i]){
				dis[v]=dis[u]+w[i];
				if(!in[v]){ 
					if(++cnt[v]==n) return 0;
					in[v]=1;q.push(v);
				}
			}
		}
	}
	return std::rand();
}
int main(){
	n=read();m=read();
	for(reg int i=1;i<=n;i++) add(n+1,i,0);
	for(reg int a,b,c,i=1;i<=m;i++){
		a=read();b=read();c=read();
		add(b,a,c);
	}
	if(!spfa()) std::puts("NO");
	else for(reg int i=1;i<=n;i++) std::printf("%d\n",dis[i]);
	return 0;
}
```  

## 最长路  

其实不等式$x_i-x_j\leq y$还可以变形成$x_j\geq x_i-y$  
所以就应该从$i$向$j$连一个权值为$-y$的边，然后跑最长路，判断正环  
当然，虚拟节点也要建，从$n+1$连向$i$，代表$dis(i)\geq dis(n+1),dis(n+1)=0$  
因此，这种方法求出的是，当$x_i\geq 0$，的最小解  

所以代码是这样的：  

```cpp  
#include<cstdio>
#include<queue> 
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	int x=0,y=1;
	char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
int n,m;
int fir[5006],nex[10006],to[10006],w[10006],tot;
int cnt[5005],in[5005];
int dis[5005];
std::queue<int>q;
inline void add(int a,int b,int c){
	to[++tot]=b;w[tot]=c;
	nex[tot]=fir[a];fir[a]=tot;
}
inline int spfa(){
	q.push(n+1);
	for(reg int i=1;i<=n;i++) dis[i]=-5e8;
	in[n+1]=1;
	while(!q.empty()){
		reg int u=q.front();q.pop();in[u]=0;
		for(reg int v,i=fir[u];i;i=nex[i]){
			v=to[i];
			if(dis[v]<dis[u]+w[i]){
				dis[v]=dis[u]+w[i];
				if(!in[v]){ 
					if(++cnt[v]==n) return 0;
					in[v]=1;q.push(v);
				}
			}
		}
	}
	return std::rand();
}
int main(){
	n=read();m=read();
	for(reg int i=1;i<=n;i++) add(n+1,i,0);
	for(reg int a,b,c,i=1;i<=m;i++){
		a=read();b=read();c=read();
		add(a,b,-c);
	}
	if(!spfa()) std::puts("NO");
	else for(reg int i=1;i<=n;i++) std::printf("%d\n",dis[i]);
	return 0;
}

```  

# 一些题目  

在处理差分约束题目时，主要就是要把关系进行变形  
看清楚边是$i\rightarrow j$还是$j\rightarrow i$，边权是$y$还是$-y$  
如果出现未知数系数不为$1$的情况，一般使用乘积最短路的形式，但这时候就要求没有常数，也就是$x_i\leq kx_j$  

[P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)，[题解](https://www.cnblogs.com/suxxsfe/p/12578100.html)，比较经典的一题  
[P4926 [1007]倍杀测量者](https://www.luogu.com.cn/problem/P4926)，这个就是刚才说的乘积最短路，但是具体的实现是要取$\log$，然后变成加法的，洛谷上有一个名为“最短路”的题就是这个  
[SCOI2011 糖果](https://loj.ac/problem/2436)  
当然我还没做多少，先放这些

---

## 作者：x_miracle (赞：1)

### 差分约束系统

首先，我们先介绍一下什么是差分约束系统。

定义：如果一个系统由$n$个变量和$m$个约束条件组成，形成$m$个形如$a_i-a_j \leq k$的不等式 。 $i,j\in \left [ 1,n \right ]$ 且 $k$为常数。

（不绝对，若为$a_i-a_j \geq  k$，即是最长路）

可以理解为：差分约束是求解关于一组变量的特殊不等式组的方法。（即： **线性规划问题** ）

举个例子：

在样例中，如果我们把不等式等价成矩阵的形式，即：
$$
\begin{bmatrix}
 1&  -1& 0 \\ 
 0&  1& -1 \\ 
 1&  0& -1
\end{bmatrix}
\begin{bmatrix}
x_1\\ 
x_2\\
x_3 
\end{bmatrix}
\leq 
\begin{bmatrix}
3\\ 
-2\\ 
1
\end{bmatrix}
$$

关于上面这个不等式的解，可以是$x=\left( 5,3,5\right)$，也可以是$x=\left( 0,-2,0\right)$

观察两个解，不难看出：两解相差一个定值 5。

所以，我们可以得出一个结论：

**设$x=\left( x_1,x_2,x_3,...,x_n\right)$是不等式的一个解。设$d$为任意常数，则$x+d=\left( x_1+d,x_2+d,x_3+d,...,x_n+d\right)$也是该不等式的一个解。**

说话讲道理，证明：

对于每一个$x_i,x_j$，我们有$\left(x_i+d\right)-\left(x_j+d\right)=x_i-x_j$。因此若$x$满足不等式，$x+d$也满足。

（这也是这一题special judge的原因）

### 约束图

刚刚分析了差分约束系统。那这一问题和图论又有什么关系呢？

敏感的小伙伴在看到上面的矩阵时，应该就反应过来了。

这是一个有向无环图的**关联矩阵**。

对于矩阵$B=b_{ij}$而言：

$$
\left\{\begin{matrix}
 -1&  \text {如果边$j$从节点$i$出发}\\
 1& \text{如果边$j$进入节点$i$}\\ 
 0& \text{其他}
\end{matrix}\right.
$$

（即： **从减数指向被减数** ）

再将边的权重赋值为不等式的常数$k$。

最后构造一个点（起点），从其出发可以到达所有其他节点，权值赋为0。

即构成了差分约束系统的约束图。

### 求解

对于约束图，若图中不存在负环。则起点到每个边的最短路权值，即为差分约束系统的一个可行解。

若存在负环，则无解。

代码如下（SPFA判负环）
```cpp
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f
#define MAXN 500000
using namespace std;
int adj[MAXN],cnt=0,num[MAXN];
int dis[MAXN],ori=0,n,m;;
bool vis[MAXN];
queue < int > q;
struct EDGE
{
	int to,nxt,val;
}	e[MAXN];
void addedge(int u,int v,int w)
{
	e[++cnt].to=v; e[cnt].val=w; e[cnt].nxt=adj[u]; adj[u]=cnt;
}
bool SPFA()
{
	for(int i=1;i<=n;++i) dis[i]=(i==ori ? 0 : INF);
	q.push(ori); vis[ori]=1; ++num[ori];
	while(!q.empty())
	{
		int u=q.front(); q.pop(); vis[u]=0;
		for(int i=adj[u];i;i=e[i].nxt) 
		{
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].val) 
			{
				dis[v]=dis[u]+e[i].val;
				if(!vis[v])
				{
					vis[v]=1;q.push(v);
					++num[v];
					if(num[v]>n)	return 0;
				}

			}
		}
	}
	return 1;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) addedge(0,i,0);
	for(int i=1;i<=m;++i)
	{
		int u,v,w;	scanf("%d%d%d",&u,&v,&w);
		addedge(v,u,w);
	}
	if(SPFA())
		for(int i=1;i<=n;++i)	printf("%d ",dis[i]);
	else
		printf("NO");
	return 0;
}
```
### 补充

差分约束在实际应用中很丰富。可以是最短路径，也可以是最长路径。

在实际问题中，要尽可能的把题目中个不等关系找全。（如：$0 \leq x_2-x_1\leq 1$，前半个容易丢）

### 写在最后

参考资料：《算法导论》

[更好的阅读体验](https://www.cnblogs.com/cyl-oi-miracle/p/13757418.html)

---


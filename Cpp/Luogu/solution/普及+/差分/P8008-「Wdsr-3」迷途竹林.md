# 「Wdsr-3」迷途竹林

## 题目背景

迷途竹林是生长着高耸入云的、无边无际的竹子的竹林。由于特殊地势的缘故，所有竹子都向着一侧倾斜生长。由于竹子顶部的叶片交错在一起，因此即使竹子的下端已经被砍掉，仍然会因为其他竹子的相互作用而无法掉落。

作为白玉楼的亭师，白玉楼的实际管家，魂魄妖梦时常需要收集一些竹子用于维修竹制家具以及竹楼。因为她拥有精湛的剑术，因此可以在瞬间砍伐一大片的竹子作为材料。当然，妖梦并不希望拥有过多的竹子。因此她会选择一个多边形区域进行采集。在那一瞬间，妖梦会用楼观剑顺着多边形的边进行砍伐。

不过，由于掉落下来的竹子数量实在太多，因此妖梦无暇统计砍下来的竹子。你能帮帮她吗？

## 题目描述

妖梦在迷途竹林里选定的竹子，可以看作在同一平面上。竹子可以看作有 $+\infty$ 根，每相邻两根竹子间距相等，并且每根竹子的倾斜程度相同。竹子的高度可以看作是无限高。

妖梦选定了一块多边形区域进行竹子的砍伐。**只有在多边形内的部分**才会被收集到。多边形共有 $n$ 条边，为了防止出现歧义，保证任意一条边都不和竹子平行；保证多边形是[简单多边形](https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%A4%9A%E8%BE%B9%E5%BD%A2/18891697)。

我们会使用两个实数 $\theta$ 和 $a$ 来描述这些竹子。这两个字母表示的含义可以参考下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7j0tx5xy.png)

现在妖梦需要知道她砍下来的竹子的总长度，也就是求出这些竹子（图中橙色的这些线段）的长度之和。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/ajm42r7v.png)

容易发现，竹子总长（即橘红色线段的总长度）为 $16\sqrt 2$。

#### 样例 2 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/anqb86a9.png)

我有一个精妙绝伦的方法解释样例 $2$，可惜这里空白太小写不下。

#### 数据范围及约定

$$
\def{\arraystretch}{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & 10 & \text{A} & 30 \cr\hline
2 & 10^3 & - & 20 \cr\hline
3 & 10^5 & \text{B} & 20 \cr\hline
4 & 10^5 & - & 30 \cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证 $\theta\in[80,100);|x_i|,|y_i|\le 10$。  
**特殊性质** $\textbf{B}$：保证 $\theta=90$。

- 对于 $100\%$ 的数据，保证 $3\le n\le 10^5;|x_i|,|y_i|\le 10^4;\theta\in[1,179);\alpha\in[0.1,100]$。输入数据当中出现的浮点数均保留四位小数。

## 样例 #1

### 输入

```
4
2.0000 2.0000
2.0000 -2.0000
-2.0000 -2.0000
-2.0000 2.0000
45.0000 1.0000```

### 输出

```
22.6274169980```

## 样例 #2

### 输入

```
8
0.0000 2.5000
1.0000 1.5000
2.5000 1.0000
2.0000 -1.0000
1.0000 -2.0000
-2.0000 -2.0000
-2.5000 1.0000
-1.0000 2.0000
60.0000 0.8000```

### 输出

```
23.1662217484```

# 题解

## 作者：囧仙 (赞：6)

## 题解

容易发现，对多边形以及其中的斜线进行旋转并不会对答案造成任何影响。因此第一步可以将所有斜线旋转至水平，便于进行下一步讨论。

![](https://cdn.luogu.com.cn/upload/image_hosting/n7gcwkrz.png)

（这里用了样例 $2$ 的图）

关于线段的旋转，这里提供两种思路：

- 第一种思路是，将笛卡尔坐标系转为极坐标系，让极角加上需要旋转的角度后再转换回来。具体而言，对于点 $(x_0,y_0)$，它的极径为 $r=\sqrt{x_0^2+y_0^2}$，极角为 $\theta=\arctan \dfrac{y_0}{x_0}$（关于极角的计算，可以使用 $\text{C++}$ 中的函数 $\verb!atan2(y,x)!$，**注意 $\bm x$ 坐标和 $\bm y$ 坐标的顺序**）。将极坐标 $(r,\theta)$ 转换为笛卡尔坐标系中的坐标，即为 $(r\cdot \cos\theta,r\cdot \sin \theta)$。  
- 第二种思路是，把平面看成复平面，利用复数乘法「辐角相加，模长相乘」的特点，把 $x_0+\mathrm iy_0 $ 乘上辅角为 $\theta$，模长为 $1$ 的复数 $\cos\theta+\mathrm i\sin\theta$。

不旋转坐标系，直接硬上应该也行；我没试过。

---

容易发现，一条橙色线段可以认为是从右侧某条方向向下的线段发出、打到了左侧某条方向向上的线段上的。因此不妨考虑差分的思想：

![](https://cdn.luogu.com.cn/upload/image_hosting/2hlqby9e.png)

以顺时针为正方向，在左侧随便取个竖直线段作为基准线，计算由红色线段向基准线发出的所有橙色线段的长度之和。方向向下时对答案的贡献为正，方向向上时对答案的贡献为负。容易发现，两者之和就是这两条线段之间的橙色线段长度之和。因此问题简化为了，计算一条线段发出来的到达左侧基准线的橙色线段的长度之和。

由于题目中保证了斜线不会与多边形的任何边平行，因此可以认为红色线段的斜率必然不为 $0$。设线段的两个端点为 $A(x_1,y_1)$ 和 $B(x_2,y_2)$。可以计算出斜线两两之间的距离 $d=a\sin\theta$，那么橙色线段都可以表示为 $y=kd,k\in \Bbb Z$。由于 $y_1<kd<y_2$，因此可以解出 $k$ 的最小值为 $\left\lceil\dfrac{y_1}{d}\right\rceil$，最大值为 $\left\lfloor\dfrac{y_2}{d}\right\rfloor$（这里并不需要强调 $kd$ 与 $y_1,y_2$ 是否可以相等，因为你可以给每个点加上个微小的 $y$ 方向偏移量如 $10^{-9}$，来避开此类问题）。

现在要做的，是根据线段 $AB$ 的解析式算出 $k$ 最小、最大的情况下的 $x$ 坐标。

$$
\frac{x-x_1}{x_2-x_1}=\frac{y-y_1}{y_2-y_1} \Rightarrow x=\frac{x_2-x_1}{y_2-y_1}(y-y_1)+x_1
$$

因为基准线可以随便取，因此这里直接取 $y$ 轴作为基准线。计算出 $x_{\mathrm{left}}$ 和 $y_{\mathrm{right}}$ 后可以使用等差数列求和进行计算。已知起始值、终止值、项数（$t=\dfrac{|y_1-y_2|}{d}$），那么有：

$$\text{贡献}=\frac{(x_{\mathrm{left}}+x_{\mathrm{right}})\cdot t}{2}$$

（事实上，如果 $y_1>y_2$ 就能说明贡献为正；如果 $y_1<y_2$ 就能说明贡献为负。因此在计算 $t$ 的时候去掉绝对值就能考虑到贡献的正负）。

统计所有边的贡献即可得到答案。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e6+3;
int n; double X[MAXN],Y[MAXN],a,o,ans;
int main(){
    size_t w;
    scanf("%d",&n); up(1,n,i) scanf("%lf%lf",&X[i],&Y[i]);
    scanf("%lf%lf",&o,&a),o=o/180*acos(-1),a=a*sin(o);
    up(1,n,i){
        double x=X[i],y=Y[i];
        double l=sqrt(pow(x,2)+pow(y,2)),b=atan2(y,x);
        b-=o,x=l*cos(b),y=l*sin(b),X[i]=x-1e-9,Y[i]=y-1e-9;
    }
    X[n+1]=X[1],Y[n+1]=Y[1];
    up(1,n,i){
        double u,v;
        if(Y[i]<Y[i+1]) u=ceil(Y[i  ]/a)*a,v=floor(Y[i+1]/a)*a;
        else            u=ceil(Y[i+1]/a)*a,v=floor(Y[i  ]/a)*a;
        double x,y,w=(v-u)/a+1;
        x=(u-Y[i])/(Y[i+1]-Y[i])*(X[i+1]-X[i])+X[i];
        y=(v-Y[i])/(Y[i+1]-Y[i])*(X[i+1]-X[i])+X[i];
        if(Y[i]>Y[i+1]) ans+=(x+y)*w/2;
        else            ans-=(x+y)*w/2;
    }
    printf("%.10lf\n",ans);
    return 0;
}
```

---

## 作者：I_am_Accepted (赞：5)

### Preface

考场上卡精度差点死亡。

### Analysis

由于竹子（以下称为直线）是斜的且间距不为 $1$，非常难搞。

用线性代数基础知识将顶点逆时针旋转 $\alpha=-\theta$ 的角度（即顺时针旋转 $\theta$）（三角函数中请转成弧度）：

$$\begin{bmatrix}
\cos\alpha&-\sin\alpha
\\
\sin\alpha&\cos\alpha
\end{bmatrix}
\begin{bmatrix}x\\y\end{bmatrix}=
\begin{bmatrix}x'\\y'\end{bmatrix}$$

再纵向压缩：

$$\begin{bmatrix}
1&0
\\
0&\frac{1}{a}
\end{bmatrix}
\begin{bmatrix}x\\y\end{bmatrix}=
\begin{bmatrix}x'\\y'\end{bmatrix}$$

发现这样的操作不改变答案，我们在这张新图上处理。

问题转化成：一个封闭图形与 $x=k(k\in\mathbb{Z})$ 的交的长度之和。

由于按照顺时针顺序给出多边形的 $n$ 个顶点的坐标，可以通过相邻两点的坐标位置判断哪一侧是内部。

![](https://cdn.luogu.com.cn/upload/image_hosting/q69fpqh8.png)

最后答案相当于 $n$ 个等差序列（几何上：梯形）的和差。

### Detail

注意边必须一端开一端闭，否则经过顶点的直线会被算两次。

### Code

对不起，比较冗长。

```cpp
//Said no more counting dollars. We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define vi vector<int>
#define pi pair<int,int>
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define mem(x,y) memset(x,y,sizeof(x))
#define debug cerr<<"Passed line #"<<__LINE__<<endl
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define Rof(i,j,k) for(register int i=j;i>=k;i--)
#define cmx(a,b) a=max(a,b)
#define cmn(a,b) a=min(a,b)
#define db long double
#define N 100010
#define j2h(x) ((double)3.14159265358979323846*(x)/180.0)//角度 -> 弧度
#define pdd pair<db,db>
#define sm 0.000000000000001//卡精度
db al,len;
pdd p[N];
int n;
inline void chan(int x){//线性变换
	pdd res;
	res.fir=p[x].fir*cos(j2h(-al))-p[x].sec*sin(j2h(-al));
	res.sec=p[x].fir*sin(j2h(-al))+p[x].sec*cos(j2h(-al));
	res.sec/=len;
	p[x]=res;
}
#define B (double)1000000000000//卡精度（先将坐标放大，后将答案缩小）
inline db qu(pdd x,pdd y,db z){//query x 坐标（取整用）
	db bi=B*(x.sec-z)/(x.sec-y.sec);
	return (x.fir*(B-bi)+y.fir*bi)/B;
}
db calc(int x){//计算一条边的贡献
	pdd s=p[x],t=p[x+1];
	db ss,tt;
	if(s.sec>t.sec){
		ss=floor(s.sec-sm);
		tt=ceil(t.sec-sm);
		if(ss<tt) return 0;
	}else{
		ss=ceil(s.sec+sm);
		tt=floor(t.sec+sm);
		if(ss>tt) return 0;
	}
	pdd sss,ttt;
	sss.fir=qu(s,t,ss);
	sss.sec=ss;
	ttt.fir=qu(s,t,tt);
	ttt.sec=tt;
	s=sss;
	t=ttt;
	int sz=abs(t.sec-s.sec)+1+sm;
	db res=sz*(s.fir+t.fir)/2;
	if(p[x].sec<p[x+1].sec) res*=-1;
	return res;
}
db work(){
	db res=0;
	p[n+1]=p[1];
	db tmp;
	For(i,1,n){
		tmp=calc(i);
		res+=tmp;
	}
	return res;
}
signed main(){
	IOS;
	cin>>n;
	For(i,1,n) cin>>p[i].fir>>p[i].sec;
	For(i,1,n) p[i].fir*=B;
	For(i,1,n) p[i].sec*=B;
	cin>>al>>len;
	len*=B;
	len*=sin(j2h(al));
	For(i,1,n) chan(i);
	cout<<fixed<<setprecision(15)<<work()/B<<endl;
    return 0;
}
```

---


# 「Wdoi-5」模块化核熔炉

## 题目背景

为了通过使用核聚变获得能源，守矢神社在旧地狱修建了巨大的核融合控制中心。控制中心形如双层八卦炉，通过各种电路紧密地调控着核融合的精密运行。获得了八咫鸟力量的阿空会在核反应炉的中心点燃神火。

但是正八边形的八卦炉并不利于进行拓展与维护。为了方便地实现电路，河童打算对核控制中心进行模块化改造，以实现核熔炉的维护。具体而言，河童打算将核控制中心设计成由若干个正六边形组成的巨大结构。

![](https://cdn.luogu.com.cn/upload/image_hosting/ohyfxv02.png)

被赋予了神力的阿空可以依次激发其中的一些模块，而这些被激发的模块会快速影响到一定范围内的其他的模块。通过模块间的链接实现能量的产生。

但是因为阿空脑袋空空，由于它已经激发了多次模块，它已经记不清每个模块当中产生的核融合程度了。你能帮帮它吗？

## 题目描述

核控制中心可以看作由若干个正六边形模块组成的六边形阵列。阵列当中每个模块都可以储存核融合能量（一个非负整数）。左图就是一个核控制中心示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/78y7b98x.png)

我们使用如下方式对控制中心中每个模块进行标号。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ffz2m5o.png)

以阵列中心为原点延伸出三根射线作为三根轴，每两根轴之间的夹角为 $120\degree$。这三根轴将平面划分为了三个部分。每个模块都可以使用一个三元组 $(x,y,z)$ 描述它的坐标，表示从原点开始按如图所示的 $x,y,z$ 方向各走若干步之后到达的地方。为了防止出现多个坐标表示同一个模块的情况，做出如下规定：原点的坐标为 $(0,0,0)$；对于中心在坐标轴上的模块，它的坐标就是从原点向所在轴走过的距离；对于其他情况，我们将平面划分为了三个区域（如第二张图的红蓝绿三个区域），一个模块的坐标就是沿着它两侧的轴分别需要走的距离。例如模块 $P$ 的坐标为 $(2,4,0)$。容易发现，每个坐标唯一对应一个模块，一个模块唯一对应一个坐标。

同时定义，两个模块的**距离**为从一个模块到另一个模块需要经过模块（包括起点和终点）的最少个数。在第一张图中，红色部分的模块到其中心距离均不超过 $3$，绿色部分的模块到其中心距离均不超过 $3$，而蓝色部分的模块到其中心距离均不超过 $2$。

核控制中心可以视为到达原点距离不超过 $n$ 的模块组成的阵列。现在阿空会执行以下操作 $m$ 次：

- $\colorbox{f0f0f0}{\verb!x y z r k!}$ ：激活坐标为 $(x,y,z)$ 的模块。它会使控制中心中到它距离不超过 $r$ 的**所有**的模块的核融合能量增加 $k$。保证 $(x,y,z)$ 在控制中心当中。

现在需要求出，执行完 $m$ 个操作后，每个模块里核融合能量值。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{nuclear2.in/nuclear2.ans}}$。  
样例 $3$ 见下发的附件 $\textbf{\textit{nuclear3.in/nuclear3.ans}}$。满足特殊性质 $\text{A}$（见下文）。  
样例 $4$ 见下发的附件 $\textbf{\textit{nuclear4.in/nuclear4.ans}}$。满足特殊性质 $\text{B}$（见下文）。  
样例 $5$ 见下发的附件 $\textbf{\textit{nuclear5.in/nuclear5.ans}}$。

#### 样例 1 解释

如图所示（所有未标出数字的模块的核融合能量值均为 $0$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/6y7bm2eb.png)



按照从左往右、从上往下的顺序依次输出每个数值，即可得到答案。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{m\le} & \textbf{特殊性质} \cr\hline
1\sim 3 & 10 & 10 & \text{A} \cr\hline
4\sim 7 & 100 & 300 & - \cr\hline
8\sim 10 & 800 & 3\times 10^5 & \text{B} \cr\hline
11\sim 14 & 800 & 3\times 10^5 & \text{A} \cr\hline
15\sim 20 & 800 & 3\times 10^5 & - \cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证对于第 $i$ 次操作，被激活的模块到控制中心边缘上的模块的距离不小于 $r_i$。  
**特殊性质** $\textbf{B}$：保证对于第 $i$ 次操作，被激活的模块均为 $(0,0,0)$。

对于全部数据，保证 $n\le 800$，$m\le 3\times 10^5$，$1\le k_i\le 5\times 10^3$，$1\le r_i\le 10^9$。每次激活的模块都在控制中心里。

## 样例 #1

### 输入

```
4 3
0 1 1 3 4
3 0 3 3 3
1 0 0 2 2```

### 输出

```
4 4 4 0 4 4 4 4 3 4 4 4 4 7 3 0 4 4 6 9 3 3 0 4 6 6 5 3 0 0 2 2 3 0 0 0 0```

# 题解

## 作者：囧仙 (赞：12)

### 题解

本题要求我们在一个巨大的六边形网格中执行正六边形范围的加法。但是正六边形加法并不容易。这里先考虑在一个正方形网格当中执行矩形范围的加法。

![](https://cdn.luogu.com.cn/upload/image_hosting/g28ab7by.png)

为了方便，这些图从左往右分别称为 $G_1,G_2,G_3$。

利用「差分」和「前缀和」的思路。假设我们现在需要进行矩形加法。如 $G_1$ 中，需要对矩形范围内所有格子都加上一个数字 $3$。按照从上往下的顺序做一次**差分**，每个格子里的数变为原来的数减去原来它上方的数字，此时变成了 $G_2$。我们再对 $G_2$ 按照从左往右的顺序做一次**差分**，每个格子里的数变为原来的数减去原来它左方的数字，此时变成了 $G_3$。

此时发现，在 $G_3$ 里实际被更新的格子其实只有四个。这样的复杂度是可以承受的。

实际操作的时候，只需要对这四个格子进行操作，可以得到 $G_3$；再使用差分的**逆运算**（也就是前缀和），按照从左往右的顺序做一次前缀和，可以得到 $G_2$；同理，对 $G_2$ 按照从上往下的顺序做一次前缀和，可以得到 $G_1$。

这么做有个很好的性质：我们可以把若干次区间加操作在 $G_3$ 里执行四个格子的单点加法（减法），在执行完所有操作后，再从更新后的 $G_3$ 推出 $G_2$ 再推出 $G_1$，就可以极大减小时间复杂度。对于 $n\times m$ 个格子的正方形阵列，执行 $q$ 次区间加法的复杂度即为 $\mathcal O(nm+q)$。

但是我们要做的是正六边形里的加法啊。但是不着急。因为我们可以发现，在一个正六边形阵列里，可以按照某个方向进行变换，将一个平行四边形区域转化为矩形区域：

![](https://cdn.luogu.com.cn/upload/image_hosting/6mdpz2ra.png)

因此，这里考虑将给我们的坐标进行**坐标转换**。

具体而言，我们新建这样两个坐标系。

![](https://cdn.luogu.com.cn/upload/image_hosting/vuegbysa.png)

按照原点的方位，我们分别将它们称呼为**左系**和**右系**。先讨论如何将题目给定的坐标系（称呼为标准系）的坐标转换为左系和右系当中点的坐标。假设给定的坐标为 $(x_0,y_0,z_0)$。

- 容易发现，在标准系当中，每向 $x$ 方向走一格会导致左系的 $x$ 增加 $1$，$y$ 减小 $1$；每向 $y$ 方向走一格会导致左系的 $y$ 增加 $1$；每向 $z$ 方向走一格会导致左系的 $x$ 减小 $1$。考虑到标准系中原点的坐标在左系中为 $(n,n)$，那么标准系中的坐标 $(x_0,y_0,z_0)$ 转换为左系坐标就是 $(x_0-z_0+n,y_0-x_0+n)$。
- 同时发现，在标准系当中，每向 $x$ 方向走一格会导致右系的 $x$ 增加 $1$；每向 $y$ 方向走一格会导致右系的 $y$ 增加 $1$；每向 $z$ 方向走一格会导致右系的 $x$ 减小 $1$，$y$ 减小 $1$。考虑到标准系中原点的坐标在右系中为 $(n,n)$，那么标准系中的坐标 $(x_0,y_0,z_0)$ 转换为左系坐标就是 $(x_0-z_0+n,y_0-z_0+n)$。


![](https://cdn.luogu.com.cn/upload/image_hosting/3q9mphod.png)

这张图是对一个**右系**进行矩形变换后的结果。容易发现，在原图当中一个向右倾斜的平行四边形区域，可以被被转化为右系当中的一个矩形。同理，我们可以对左系进行矩形变换：

![](https://cdn.luogu.com.cn/upload/image_hosting/6mdpz2ra.png)

因此，我们可以将一个六边形网格图中，一个向左倾斜的平行四边形区域的区间加，转化为**左系**所对应的那个矩形里的一个矩形加。

知道这些，这条题目就非常简单了。现在假设我们需要对原图当中这样一个大的正六边形区域执行加法操作：

![](https://cdn.luogu.com.cn/upload/image_hosting/vqo80wdh.png)

那么它可以被转换为这样四个图形之间的拼接：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ur5yqpd.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/3j0ubn3r.png)

其中，红色部分代表的是正值，蓝色部分代表的是负值。它可以被转化为两个左系当中的矩形加，以及两个右系当中的矩形加。

记得处理一下矩阵的边界超出左系/右系的情况，那么这题就做完了。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN=800+3;
int n,m,k;
void cnv1(int a,int b,int c,int &x,int &y){  //左系
    x=a-c+n,y=b-a+n;
}
void cnv2(int a,int b,int c,int &x,int &y){  //右系
    x=a-c+n,y=b-c+n;
}
int A[MAXN*2][MAXN*2],B[MAXN*2][MAXN*2];
int main(){
    n=qread(),m=qread(),k=2*n-1;
    up(1,m,i){
        int x=qread(),y=qread(),z=qread(),r=qread(),w=qread();
        int u,v;
        cnv1(x,y,z,u,v);
        A[u][min(k,v+r-1)]-=w,A[max(1,u-r+1)][min(k,v+r-1)]+=w;
        A[u][max(0,v-r  )]-=w,A[min(k+1,u+r)][max(0,v-r  )]+=w;
        cnv2(x,y,z,u,v);
        B[u][min(k,v+r-1)]+=w,B[min(k+1,u+r)][min(k,v+r-1)]-=w;
        B[u][max(0,v-r  )]+=w,B[max(1,u-r+1)][max(0,v-r  )]-=w;
    }
    up(1,k,i) up(1,k,j) A[i][j]+=A[i-1][j];
    up(1,k,i) up(1,k,j) B[i][j]+=B[i-1][j];
    up(1,k,i) dn(k,1,j) A[i][j]+=A[i][j+1];
    up(1,k,i) dn(k,1,j) B[i][j]+=B[i][j+1];
    up(-n+1,n-1,i) dn(n-1,-n+1+abs(i),j){
        int x=0,y=j,z=0,u,v,w=0; if(i<0) z=-i; else x=i;
        cnv1(x,y,z,u,v),w+=A[u][v];
        cnv2(x,y,z,u,v),w+=B[u][v];
        printf("%d ",w);
    }
    
    return 0;
}
```


---

## 作者：WYXkk (赞：10)

完全没有想明白这种萌萌题怎么没人做没人过……

---
简要题意：在正六边形区域内执行若干次正六边形区域加操作，输出最后每个格子的值。

首先，这是一个二维的问题，那么使用三个坐标来表达一个点是非常蠢的；因此，考虑以左上角为原点，沿两条边为两条坐标轴，建立斜坐标系。

（事实上涉及到六边形网格和三角形网格时往往采用斜坐标系）

那么正六边形就变成了这样：
```plain
00000
000000
0000000
00000000
000000000
 00000000
  0000000
   000000
    00000
```

题目只要求我们所有操作结束后输出所有值，很容易想到先差分再前缀和。

在其中取一个六边形区域加是这样：
```plain
00000
000000
0000000
00111000
001111000
 01111100
  0111100
   011100
    00000
```
考虑到横向和纵向差分会带来不很规则的 1 和 -1 带，我们考虑斜向差分（a 表示 -1）：
```plain
00000
000000
0000000
00111000
001000000
 01000000
  00000a0
   0000a0
    0aaa0
```
直角型可以拆分为一个横条和一个竖条，将它们分开处理再分别横向/纵向差分，即可用 O(1) 个修改位置表示一次操作。**注意边界。**

最后，分开处理的两部分分别横向/纵向求和，然后加起来，再斜向求和，即为最终答案。

时间复杂度 $O(n^2+m)$。太简单了没写代码。

---

## 作者：zhongcy (赞：6)

### Solution

------------

这题可以运用差分的思想。先介绍一下二维差分的用法：

![](https://cdn.luogu.com.cn/upload/image_hosting/ptsjaz9c.png?x-oss-process=image/resize,m_lfit,h_340,w_450)
![](https://cdn.luogu.com.cn/upload/image_hosting/2y8i7nue.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

要将左图蓝色部分全部加上 1，就可以在有图中蓝色部分加 1，红色部分减 1。此时，只要将每一行都做一次前缀和，就可以得到蓝色部分全部加 1 的效果。这样就大大减小了时间复杂度。

若在 $ n \times m $ 的方格操作 $ q $ 次，则时间复杂度为 $ \Theta(nm+q) $。

可以看一下这个[例题](https://www.luogu.com.cn/problem/P3397)。

------------

再来看本题。这题要求在六边形做差分，于是可以考虑进行坐标的转化，把六边形转化为矩形。因为在三个坐标中进行操作十分麻烦，就可以改成在二维中操作。

![](https://cdn.luogu.com.cn/upload/image_hosting/o5zlt5e6.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

(图片来自[博客](https://www.luogu.com.cn/blog/over-knee-socks/solution-p8228)）

设第一个坐标系为 $ A $，第二个为 $ B $。
在原来坐标系当中，易得
- 往 $ x $ 轴方向移动一格会使 $ A $ 坐标系中 $ x $ 变为 $ x+1 $，$ y $ 变为 $ y-1 $。
- 往 $ y $ 轴方向移动一格会使 $ A $ 坐标系中 $ y $ 变为 $ y+1 $。 
- 往 $ z $ 轴方向移动一格会使 $ A $ 坐标系中 $ x $ 变为 $ x-1 $。
所以，原来坐标系的 $ (x,y,z) $ 在 $ A $ 中表示为 $ (x-z+n,y-x+n) $。

同理，原来坐标系的 $ (x,y,z) $ 在 $ B $ 中表示为 $ (x-z+n,y-z+n) $。

综上，我们就只需分别在 $ A,B $ 中进行差分，最后再对 $ A,B $ 做一次前缀和即可。

### Code

------------

时间复杂度 $ \Theta (n^2+m) $。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 1601 
using namespace std;
int n,m,d;
ll a[N][N],b[N][N];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;d=2*n-1;
	while(m--)
	{
		int x,y,z,r,k,p,q;
		cin>>x>>y>>z>>r>>k;
		
		p=x-z+n;q=y-x+n;
		a[p][min(d,q+r-1)]-=k;
		a[max(1,p-r+1)][min(d,q+r-1)]+=k;
		a[p][max(0,q-r)]-=k;
		a[min(d+1,p+r)][max(0,q-r)]+=k;
		
		p=x-z+n;q=y-z+n;
		b[p][min(d,q+r-1)]+=k;
		b[min(d+1,p+r)][min(d,q+r-1)]-=k;
        b[p][max(0,q-r)]+=k;
		b[max(1,p-r+1)][max(0,q-r)]-=k;
	}
	
	for(int i=1;i<=d;i++)
		for(int j=1;j<=d;j++)
			a[i][j]+=a[i-1][j];
	for(int i=1;i<=d;i++)
		for(int j=d;j>=1;j--)
			a[i][j]+=a[i][j+1];
	for(int i=1;i<=d;i++)
		for(int j=1;j<=d;j++)
			b[i][j]+=b[i-1][j];
	for(int i=1;i<=d;i++)
		for(int j=d;j>=1;j--)
			b[i][j]+=b[i][j+1];
			
	for(int i=-n+1;i<=n-1;i++)
		for(int j=n-1;j>=1-n+abs(i);j--)
		{
			ll x=0,y=j,z=0;
			(i<0)?z-=i:x=i;
			cout<<a[x-z+n][y-x+n]+b[x-z+n][y-z+n]<<' ';
		}
	return 0;
}
```


---

## 作者：minstdfx (赞：3)

建立斜坐标系的方法小波和 WYXkk 已经讲过了，总之就是两邻边与某两条坐标轴平行的平行四边形加等同于该斜坐标系下的矩形加。

只要把原本的修改操作拆分成三个不同坐标系下的三个矩形加和一个单点修改就可以了。

![](https://cdn.luogu.com.cn/upload/image_hosting/hcno4qqt.png?x-oss-process=image/resize,m_lfit,w_375)
![](https://cdn.luogu.com.cn/upload/image_hosting/cd235sbo.png?x-oss-process=image/resize,m_lfit,w_375)

python 代码常数过大会 TLE（其实是二维数组部分太慢），仅供参考。

```python
# -*- coding: utf-8 -*-
"""
Created on Thu Mar 17 17:41:48 2022

@author: minstdfx
"""

def MyMin(a, b):
    return a if a < b else b
def MyMax(a, b):
    return b if a < b else a
def MyAbs(a):
    return a if a >= 0 else -a

class Point:
    def __init__(self, x = 0, y = 0, z = 0):
        self.x = x
        self.y = y
        self.z = z
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y, self.z + other.z)
    def __str__(self):
        return "Point(%d, %d, %d)" % (self.x, self.y, self.z)
    def toXY(self):
        return Point(self.x - self.z, self.y - self.z, self.z - self.z)
    def toXZ(self):
        return Point(self.x - self.y, self.y - self.y, self.z - self.y)
    def toYZ(self):
        return Point(self.x - self.x, self.y - self.x, self.z - self.x)
class Api:
    def __init__(self, n): # n
        self._demand = []
        self._n = n
        self._length = n * 2 + 3
        for i in range(self._length):
            self._demand.append([0] * self._length)
    def update(self, xl, xr, yl, yr, k):
        n = self._n
        xl += n + 1
        xr += n + 1
        yl += n + 1
        yr += n + 1
        xl = xl if xl >= 0 else 0
        yl = yl if yl >= 0 else 0
        xr = xr if xr <= 2 * n + 1 else 2 * n + 1
        yr = yr if yr <= 2 * n + 1 else 2 * n + 1
        self._demand[xl][yl] += k
        self._demand[xl][yr + 1] -= k
        self._demand[xr + 1][yl] -= k
        self._demand[xr + 1][yr + 1] += k 
n, m = 0, 0
Gxy, Gxz, Gyz = 0, 0, 0
input_data, input_ptr = [], 0
def readInt():
    global input_data, input_ptr
    if input_ptr == len(input_data):
        input_data = input().split(' ')
        input_ptr = 0
    input_ptr += 1
    return int(input_data[input_ptr - 1])
_ans = []
_isendl = []
_Gas = []
def InitAns(n):
    global _ans, _Gas
    _len = n * 2 + 3
    for i in range(_len):
        _Gas.append([0] * _len)
    for x in range(-n, n + 1):
        # for y in range(MyMax(-n, x - n), MyMin(n, x + n) + 1):
        y = MyMin(n, x + n)
        stop_y = MyMax(-n, x - n)
        while y >= stop_y:
            # print("(%d, %d)" % (x, y))
            _Gas[x + n + 1][y + n + 1] = len(_ans)
            _ans.append(0)
            _isendl.append(0)
            y -= 1
        _isendl[len(_isendl) - 1] = 1
def Accumulate(p, k):
    p = p.toXY()
    if not(-n <= p.y <= n and -n <= p.x <= n):
        return
    if p.x * p.y < 0 and MyAbs(p.x) + MyAbs(p.y) > n:
        return
    _ans[_Gas[p.x + n + 1][p.y + n + 1]] += k
def updateXZ(p1, p2, k):
    Gxz.update(p1.x - p1.y, p2.x - p2.y, p1.z - p1.y, p2.z - p2.y, k)
def updateXY(p1, p2, k):
    Gxy.update(p1.x - p1.z, p2.x - p2.z, p1.y - p1.z, p2.y - p2.z, k)
def updateYZ(p1, p2, k):
    Gyz.update(p1.y - p1.x, p2.y - p2.x, p1.z - p1.x, p2.z - p2.x, k)
if __name__ == '__main__':
    # global Gxy, Gxz, Gyz
    n, m = readInt(), readInt()
    n = n - 1
    Gxy = Api(n)
    Gxz = Api(n)
    Gyz = Api(n)
    InitAns(n)
    for i in range(m):
        p = Point(readInt(), readInt(), readInt())
        r, k = readInt(), readInt()
        r -= 1
        Accumulate(p, k)
        updateXY(p + Point(0, 1, 0), p + Point(r, r, 0), k)
        updateXZ(p + Point(1, 0, 0), p + Point(r, 0, r), k)
        updateYZ(p + Point(0, 0, 1), p + Point(0, r, r), k)
    for i in range(1, 2 * n + 2):
        for j in range(1, 2 * n + 2):
            Gxz._demand[i][j] += Gxz._demand[i - 1][j] + Gxz._demand[i][j - 1] - Gxz._demand[i - 1][j - 1]
            Accumulate(Point(i - n - 1, 0, j - n - 1), Gxz._demand[i][j])
    for i in range(1, 2 * n + 2):
        for j in range(1, 2 * n + 2):
            Gxy._demand[i][j] += Gxy._demand[i - 1][j] + Gxy._demand[i][j - 1] - Gxy._demand[i - 1][j - 1]
            Accumulate(Point(i - n - 1, j - n - 1, 0), Gxy._demand[i][j])
    for i in range(1, 2 * n + 2):
        for j in range(1, 2 * n + 2):
            Gyz._demand[i][j] += Gyz._demand[i - 1][j] + Gyz._demand[i][j - 1] - Gyz._demand[i - 1][j - 1]
            Accumulate(Point(0, i - n - 1, j - n - 1), Gyz._demand[i][j])
    for i in range(len(_ans)):
        print(_ans[i], end=" " if not _isendl[i] else " ")
```


---


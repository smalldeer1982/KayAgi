# [TJOI2010] 中位数

## 题目描述

给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：

- $\texttt{1 add }\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。
- $\texttt{2 mid}$：输出当前序列的中位数。

中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）

例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  
例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  
例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。
- 对于 $100\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。

序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。

## 样例 #1

### 输入

```
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
```

### 输出

```
5
13
```

# 题解

## 作者：陈曦 (赞：45)

**orz各位大佬**，题解太强了，主席树，堆，线段树，splay，还有暴力，太巨了。所以我用的是fhq treap（~~好像更高级~~）。算了。

反正都是平衡树，这道题就是动态求中位数，不会做的同学可以先做弱化版[P1168](https://www.luogu.org/problemnew/show/P1168)

至于不会fhq treap的同学可以先点[这里](https://www.luogu.org/blog/57026/solution-p1801)或者[这里](https://www.luogu.org/blog/57026/ping-heng-shu-fhq-treap)（~~记得点赞~~）

fhq treap做这道题涉及到insert(插入)与find（求第k小的数），至于k，就随add增大就好了，所以说fhq treap太好用了。

insert的原理就不说了，至于find的原理我就简单讲一下，fhq treap是用treap来存，treap就是堆与树的合并，所以我们叫它二叉搜索树，所以它具有堆的性质，所以就搜右子树大小。（详细可以戳上面）

嗯，上代码。

```cpp
#include<iostream>
#include<cstdio>
#include<ctime>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define maxn 200010
using namespace std;
int n,val[maxn],rnd[maxn],son[maxn][3],size[maxn],sum_p,m;
//val存权值，rnd存rand出的值，son存左右儿子，size存大小。
inline void read(int &x)
{
    x=0;int f=1; 
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9')
    {x=x*10+ch-'0';ch=getchar();}
    x*=f;
}
inline int newnode(int x)
{
    ++sum_p;size[sum_p]=1;
    val[sum_p]=x;rnd[sum_p]=rand();
    return sum_p; 
}
inline void update(int x)
{
    size[x]=size[son[x][1]]+size[son[x][2]]+1;
}
inline void split(int &x,int &y,int k,int pos)//拆树
{
    if(!pos)x=y=0;
    else
    {
        if(val[pos]<=k)//（拆成比k大与不大于k）
        {x=pos;split(son[pos][2],y,k,son[pos][2]);}
        else
        {y=pos;split(x,son[pos][1],k,son[pos][1]);}
        update(pos);
    }
}
inline int merge(int x,int y)//合并
{
    if(x==0||y==0) return x+y;
    if(rnd[x]<rnd[y])//如果rand[x]<rand[y] 我们就把y接在x的右儿子上
    {
        son[x][2]=merge(son[x][2],y);
        update(x);return x;
    }
    else//反之同理
    {
        son[y][1]=merge(x,son[y][1]);
        update(y);return y;
    }
}
inline int find(int pos,int rank)
{
    while(1)//(原理上面已讲)
    {
        if(size[son[pos][1]]>=rank)
        {
            pos=son[pos][1];
        }
        else 
        if(size[son[pos][1]]+1==rank)return pos;
        else
        {
            rank-=size[son[pos][1]]+1;
            pos=son[pos][2];
        }
    }
}
int main()
{
    srand((unsigned)time(NULL));
    int b,x,y,z,op,root=0,m;
    read(n);
    for(register int i=1;i<=n;i++)
    {
        read(op);
        split(x,y,op,root);//拆开
        root=merge(merge(x,newnode(op)),y);//插入，合并回来
    }
    read(m);char a[3]; 
    for(register int i=1;i<=m;i++)
    {
        scanf("%s%d",a,&b);
        if(a[0]=='a')
        {
            split(x,y,b,root);
            root=merge(merge(x,newnode(b)),y);
            n++;//中位数是动态的，所以改变总个数就好了。
        }
        else
        {
            register int mid=(n+1)/2;//加1的原因就不说了
            printf("%d\n",val[find(root,mid)]);
        }
    }
}
```

如果各位大佬觉得讲的还行，请赏一个赞，谢谢。

---

## 作者：Anguei (赞：32)

这类问题的最经典解法应当是对顶堆。动态维护一个序列使其有序，可以使用平衡树。

然而我不会平衡树，所以只能用 stl 代替平衡树了 QωQ。

这种简单的序列维护问题可以使用 stl 当中的 `vector` 以及 `lower_bound` 解决。下面来分析一下这道题的做法。

1. 首先，读入这个序列，并对其排序。排序后才可以根据下标 $O(1)$ 得出中位数。
2. 对于每个 `add` 操作，在序列中第一个大于等于 `a` 的元素的位置插入新数字。由于序列是有序的，所以可以**使用 `lower_bound`** 确定插入位置。
3. 对于每个 `mid` 操作，$O(1)$ 输出中位数即可。注意 `vector` 下标从零开始。

在洛谷上，最慢的测试点跑了 83ms：https://www.luogu.org/record/show?rid=13269424

### 核心代码（非常短）

```cpp
std::vector<int> v;

int query() { 
    return v[v.size() / 2 - (v.size() & 1 ^ 1)];
}
void add(int x) { 
    v.insert(std::lower_bound(v.begin(), v.end(), x), x);
}

int main() {
    int n = read(); // read 是快读
    while (n--) v.push_back(read());
    std::sort(v.begin(), v.end());
    int m = read();
    while (m--) {
        char opt[5]; scanf("%s", opt);
        if (opt[0] == 'm') println(query(v)); // println 是快写
        else add(read());
    }
}
```

在上述代码的 `query` 函数当中，使用了位运算简化代码。代码等价于：
```cpp
int query() {
    if (v.size() & 1) return v[v.size() / 2];
    else return v[v.size() / 2 - 1];
}
```

----

## 20181118 更新

学了一下 Tarjan 的 Zip Tree。贴一个 Zip Tree 解法核心代码。（比 stl 快一些）

```cpp
struct Node {
    int key, rank, size;
    Node *lson, *rson;
    Node() {}
    Node(int x, int rank);
} NIL, *root = &NIL;

Node::Node(int x, int rank) : key(x), rank(rank), size(1), lson(&NIL), rson(&NIL) {}

Node *maintain(Node *o) { 
    o->size = 1 + o->lson->size + o->rson->size;
    return o;
}

Node *insert(int x, int rank, Node *o) {
    if (o == &NIL) return root = new Node(x, rank);
    if (x <= o->key) {
        Node *p = insert(x, rank, o->lson);
        if (p->rank > o->rank) o->lson = p->rson, p->rson = maintain(o), o = p;
        else o->lson = p;
    } else {
        Node *p = insert(x, rank, o->rson);
        if (p->rank > o->rank) o->rson = p->lson, p->lson = maintain(o), o = p;
        else o->rson = p;
    }
    return root = maintain(o);
}

Node *zip(Node *l, Node *r) {
    if (l == &NIL) return r;
    if (r == &NIL) return l;
    if (l->rank < r->rank) {
        r->lson = zip(l, r->lson);
        return maintain(r);
    } else {
        l->rson = zip(l->rson, r);
        return maintain(l);
    }
}

Node *del(int x, Node *o) {
    if (o->key == x) return root = zip(o->lson, o->rson);
    if (o->key > x) o->lson = del(x, o->lson);
    else o->rson = del(x, o->rson);
    return root = maintain(o);
}

int findKth(int k, Node *o) {
    if (o->lson->size == k - 1) return o->key;
    else if (o->lson->size > k - 1) return findKth(k, o->lson);
    else return findKth(k - o->lson->size - 1, o->rson);
}

void solution() {
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
    srand(time(nullptr));
    int n = read(); rep(i, 1, n) insert(read(), rand() % jzm, root);
    int Q = read(); while (Q--) {
        std::string opt; std::cin >> opt;
        if (opt[0] == 'a') insert(read(), rand() % jzm, root), ++n;
        else println(findKth(n / 2 - (n & 1 ^ 1) + 1, root));
    }
}
```

---

## 作者：这有一只匿 (赞：23)

哇，下面有大佬函数模拟堆,orz。蒟蒻自然是用stl自带的小根堆和大根堆。

我们首先将所有的数丢进大根堆里然后取一般丢进小根堆里，这样就把所有的数分成了两段有序的部分。

加入操作可以每次取小根堆堆顶和加入的数比较，大于堆顶则加入小根堆否则加入大根堆（为了维护这个排序的有序性）。

而在询问时为了保证大根堆堆顶就是答案，我们要使大根堆里的元素等于（所有元素+1）/2<根据题目要求应该+1>，所以加两个while循环控制它的元素个数（少了就从小根堆那里抢，多了就丢给小根堆），然后输出答案就可以了~~

代码
```cpp
#include<iostream> 
#include<cstdio> 
#include<queue>
using namespace std; 
int n,m;
priority_queue<int,vector<int>,greater<int> >que1;//xiao
priority_queue<int>que2;//da
string s;
int cnt1,cnt2;
int main()
{ 
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int a;
        scanf("%d",&a);
        que2.push(a);cnt2++;
    }
    for(int i=1;i<=n/2;i++)
    {
        int x=que2.top();
        que2.pop();cnt2--;
        que1.push(x);cnt1++;
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
    cin>>s;
    if(s[0]=='a')
    {
        int x;
        scanf("%d",&x);
        n++;
        int l=que2.top();
        if(x>l)que1.push(x),cnt1++;
        else que2.push(x),cnt2++;
    }
    else
    {
        while(cnt2<(n+1)/2)
        {
        int x=que1.top();
        que1.pop();cnt1--;
        que2.push(x);cnt2++;
        }
        while(cnt2>(n+1)/2)
        {
        int x=que2.top();
        que2.pop();cnt2--;
        que1.push(x);cnt1++;    
        }
        if(cnt2==(n+1)/2)
        cout<<que2.top()<<endl;
    }
    }
    return 0;
}
```

---

## 作者：览遍千秋 (赞：20)

## 暴力出奇迹

---

先对序列进行排序，再使用二分插入。

---

代码（复制者CE）：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
using namespace std;
#define maxnn 110007
string c;
int n,m,l,r,mid,x,tp,a[maxnn],w;
inline bool check()
{
    return a[mid]<=x;
}
inline void Init()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;++i) scanf("%d",&a[i]);
    scanf("%d",&m);
}
inline void Work()
{
    sort(a+1,a+n+1);
    for(register int i=1;i<=m;i++)
    {
        cin>>c;
        if(c=="mid")//判断
        {
            printf("%d\n",a[n%2==0?n/2:n/2+1]);//输出
        }
        else
        {
        	w=0;//重置，不这样的话WA#7
            cin>>x;
            l=1;
            r=n;
            while(l<=r)//二分位置
            {
                mid=(l+r)/2;
                if(check())
                {
                    w=mid;
                    l=mid+1;
                }
                else
                r=mid-1;
            }
            ++n;
            for(register int i=n;i>w+1;i--)
            {
                a[i]=a[i-1];//调整
            }
            a[w+1]=x;
        }
    }
}
int mian()//华丽的主函数
{
    Init();
    Work();
    return 0;
}
```


---

## 作者：TinyKiecoo (赞：12)

看到题解里好多大佬用二分，splay，树状数组，优先队列等高级数据结构，然而本蒟蒻实在是渣，所以只能用最简单的纯vector写。

**这是本蒟蒻第一次写题解，有什么建议尽情评论，谢谢。**

**~~（个人觉得比大佬们写的简单）~~**

C++中stl表真的方便，其中向量vector支持数组中间插入：
```cpp
	v.insert（v.begin()+i,a）;
	/*
	v.begin()指v数组头地址，v.begin()+i相当于v[i]，a即插入的值
	*/
```

------------

我想先皮一下发出我**普通数组纯暴力30分**的代码~~来揭露普通数组的害处~~

```cpp
//30分的烂代码就不多加注释了
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
using namespace std;
long long m,n,a[110001];
string f;
int main(){
    scanf("%lld",&n);
    for(long long i=1;i<=n;i++)scanf("%lld",&a[i]);
    scanf("%lld",&m);
    for(long long i=1;i<=m;i++){
        cin>>f;
        if(f=="add")scanf("%lld",&a[++n]);//将数直接加入数组尾
        else{
            sort(a+1,a+n+1);//每次sort不超时才怪
            if(n%2)printf("%lld\n",a[(long long)ceil(n/2.0)]);
            else printf("%lld\n",min(a[n/2],a[n/2+1]));
        }
    }
}
```
~~废话完了可以开始正文了~~
------------



------------


首先读入向量数组，sort排序：

```cpp
	scanf("%lld",&n);
	for(long long i=0; i<n; i++) {
		scanf("%lld",&a);          //读入a
		v.push_back(a);            //将a放入v中
	}
	sort(v.begin(),v.end());       //排序，保证v为单调递增
```
#### 以下本题核心：

将数插入向量v中，普通数组只支持修改查询，插入需每次sort排序或使用手工链表，~~sort排序过慢，链表调试不够方便~~，于是**vector便闪亮登场**~~（此处应有掌声）~~。


读入数据a，从头访问vector，在第一个大于a的位置**前**插入b，这样可以保证vector一直为单调递增，不需每次排序。同时应记录vector的长度n（话说好像用v.size()调整一下貌似也可以），n初始值为原始vector的长度。代码：
```cpp
	scanf("%lld",&a);
	n++;                        //v的长度++
	for(int i=0; i<n; i++) {	//从头访问
		if(v[i]>a) {			//一旦找到第一个比a大的元素
				v.insert(v.begin()+i,a);//将a插入v中
				break;          //退出循环
		}
	}
```

访问处在中间位置的数。若序列长度为偶数，则指处在中间位置的两个数中较小的那个，由于本vector数组从v[0]开始，所以记录的长度n-1才为要访问的点，即vector中第n个值为v[n-1]：
```cpp
	if(n%2) //若为奇数
		printf("%lld\n",v[(long long)ceil(n/2.0)-1]);
        	//奇数除以2不为整数
            //但注意C++中整数除以整数恒得整数，所以要除以实数2.0
            //而数组下标必须为整型，所以要强制类型转换
	else 
    	printf("%lld\n",min(v[n/2-1],v[n/2]));
            //输出中间位置两个数中较小者
```
**所以组合起来AC总代码：**
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<vector>
using namespace std;
long long a,m,n;
string f;
vector<long long>v;
int main() {
	v.reserve(200010); //保留空间，使v最大长度为200010，节省内存
	scanf("%lld",&n);
	for(long long i=0; i<n; i++) {
		scanf("%lld",&a);
		v.push_back(a);
	}
	sort(v.begin(),v.end());
	scanf("%lld",&m);
	for(long long i=1; i<=m; i++) {
		cin>>f;		   //读入字符串f
		if(f=="add") {    //若字符串f为add则插入v中
			scanf("%lld",&a);
			n++;
			for(int i=0; i<n; i++) {
				if(v[i]>a) {
					v.insert(v.begin()+i,a);
					break;
				}
			}
		} else {          //若f为mid输出中位数
			if(n%2)
            	printf("%lld\n",v[(long long)ceil(n/2.0)-1]);
			else 
            	printf("%lld\n",min(v[n/2-1],v[n/2]));
		}
	}
    return 0;
}
```


#### ~~PS：纯向量模拟，由于存在遍历访问数组和sort排序，复杂度最好情况为O（nm），最差可到O（nmlogn），代码跑的比较慢，qwq~~
但是好理解就足够了，对吧~~（其实是数据太水了QWQ)~~

---

## 作者：ajil (赞：10)

想到个新的方法

首先将所有的数存起来离散化

用**树状数组**来维护数字的个数

**二分搜索**树状数组来寻找中位数

顺带一提, P1168也可以这么做, [这是链接](https://www.luogu.org/problemnew/show/P1168)

下面是代码:
```cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
const int Mn(200050),Mm(10050);
inline int lb(const int& x)	{ return x&(-x); }	//lowbit
int a[Mn],b[Mn],p[Mn],c[Mn];	//a是所有数, c为树状数组
bool _cmp(int x,int y)	//离散化时使用
{ return a[x]==a[y] ? x<y : a[x]<a[y]; }
struct opr
{
	int opt,n;
}o[Mm];	//存下所有操作
int main()
{
	int n,m;	//依照题意
	scanf("%d",&n);
	for(int i(1);i<=n;++i)
	{
		scanf("%d",a+i);
		b[i] = i;	//b代表了排序第i的数在a数列的位置
	}
	scanf("%d",&m);
	int ar(n);	//a数列的长度
	for(int i(1);i<=m;++i)
	{
		string s;
		cin >> s;	//读取操作
		if(s[0]=='a')
		{
			scanf("%d",&(o[i].n));
			a[++ar] = o[i].n;
			b[ar] = ar;
			o[i].opt = 1;	//add操作记为1
		}
		if(s[0]=='m')
			o[i].opt = 0;	//mid操作记为2
	}
	sort(b+1,b+ar+1,_cmp);
	for(int i(1);i<=ar;++i)
		p[b[i]] = i;	//p为a数列中第i个数的排序
	for(int i(1);i<=n;++i)
		for(int j(p[i]);j<=ar;j+=lb(j)) ++c[j];	//树状数组修改
	int cnt(n);
	for(int i(1);i<=m;++i)
	{
		if(o[i].opt)
		{
			++cnt;
			for(int j(p[cnt]);j<=ar;j+=lb(j)) ++c[j];
		}
		else
		{
			int tar((cnt+1)/2);	//搜索目标
			int l(1),r(ar);
            /*----二分搜索----*/
			while(r-l>3)
			{
				int mid((l+r)>>1);
				int ans(0);
				for(int j(mid);j;j-=lb(j))	ans += c[j];
				if(ans<tar)	l = mid+1;
				else	r = mid;	
			}
			for(;l<=r;++l)
			{
				int ans(0);
				for(int j(l);j;j-=lb(j))	ans += c[j];
				if(ans==tar)	break;
			}
            /*----------------*/
			cout << a[b[l]] << endl;	//输出中位数
		}
	}
	return 0;
}
```

---

## 作者：ThinkofBlank (赞：8)

看到此题，顿时兴奋了，因为，我以前yy出了一种排序，叫做二分链表插入排序。

详细板子代码见[博客](https://www.luogu.org/blog/Think-of-Blank/er-fen-lian-biao-cha-ru-pai-xu)

结果因为vector的insert太慢而被我GG了

[跑【模板】快速排序](https://www.luogu.org/recordnew/show/13189539)

然后，看到此题，找中位数嘛，肯定是要在排好序的数列里面选出嘛。。。

支持添加数字，嘛，二分一下就好了啊。。。然后，我就惊喜的发现这个思路与我之前yy出的排序异常相似，~~于是，我就直接ctrl c+ctrl v。~~

结果就这样只跑了多200ms

这种做法还资瓷操作删除，复杂度O(玄学)

代码如下:

```c
//#pragma GCC optimize()//手动Ox优化
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int a[N];
vector<int>s;
int main(){
	int n,siz;
	scanf("%d",&n);
	siz=n;//记录链表大小 
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);//先排序下，保证原始链表有序 
	for(int i=1;i<=n;++i){
		s.push_back(a[i]);//依次放入即可 
	}
	int m;
	scanf("%d",&m);
	char ss[5];
	while(m--){
		scanf("%s",ss); 
		if(ss[0]=='a'){
			int x;
			scanf("%d",&x);
			int l=0,r=siz-1,ans=-1;//这里把ans赋值为-1是为了防止x是最小元素时，会导致二分时不会给ans赋值，这时，添加至链首即可 
			while(l<=r){//二分出最接近x的数字的位置 
				int mid=(l+r)>>1;
				if(s[mid]<=x){
					ans=mid;
					l=mid+1;
					continue;
				}
				r=mid-1;
			}
			s.insert(s.begin()+ans+1,x);
			siz++;
			continue;
		}
		//分情况输出答案 
		if(siz&1){
			printf("%d\n",s[((siz+1)>>1)-1]);
			continue;
		}
		printf("%d\n",min(s[(siz>>1)-1],s[(siz>>1)]));
	}
	return 0;
}
```

---

## 作者：Paperback_Writer (赞：7)

#先说说这道题:

##用两个堆来维护中位数左右的数！

一个大根堆bigheap( bhp )维护中位数mid左( 比mid小 )的数，队首( bhp[0] )表示离当前mid最接近但小于mid的数。

一个小根堆smallheap( shp )维护中位数mid右( 大于等于mid )的数，队首( shp[0] )表示离当前mid最接近但大于等于mid的数。

这样当前中位数便有两种情况：

1.数字总数为奇数:  mid=shp[0]；

2.数字总数为偶数:  mid=min( bhp[0]+shp[0] )

##操作:

1.先将初始数据二分建堆，我这里用了个笨方法用数组把初始数据存了排序后建堆( 因为要保证单调递增 )...

2.每当插入一个数据，对比当前中位数，如果比当前mid小就拟加入大根堆，否则拟加入小根堆...

3.那么问题来了:将新的点插入大/小根堆后，如果大根堆数据数比小根堆大1，或者小根堆数据数比大根堆大2( 因为总要保证小根堆数据数>=大根堆数据数 )，这时便要将新数加入建堆后，将被加入的堆的顶点移动到另一个堆中(作为另一个堆的新的顶点)，以保证两个堆数据相对平衡。


##那么问题来了:你们会手写堆吗？

如果会写，你们能写多少行呢？所以洗洗睡吧(误)

------于是就想到用STL的堆:

调用<algorithm>和<vector>库

```cpp
vector <long long> a;
a.push_back();将数据加入vector
make_heap(a.begin(),a.end(),cmp);//建堆，这里的cmp判断为确定堆的种类( 需要手写 )
push_heap(a.begin(),a.end(),cmp);//维护这个堆
pop_heap(a.begin(),a.end(),cmp);//将顶点移动至队列最尾，并维护堆，但某数依然在队列最尾=_=
a.pop_back();//与上面的构成组合技，删除末尾的点
```
利用上述函数就可以模拟堆了

#贴上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
vector <long long> bhp,shp;
long long n,bcnt,scnt,a[100010];//bcnt,scnt记录当前两个堆里数据数量 
bool bcmp(long long x,long long y)//大根堆的判断要写小于号！ 
{
    return x<y;
}
bool scmp(long long x,long long y)//小根堆的判断要写大于号！
{
    return x>y;
}
int main()
{
    long long num; //下面的一小段搞定初始数据 
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
    {
        if(i<=n/2)
        bhp.push_back(a[i]);
        else
        shp.push_back(a[i]);
    }
    bcnt=n/2;scnt=n-n/2;
    make_heap(bhp.begin(),bhp.end(),bcmp);
    make_heap(shp.begin(),shp.end(),scmp);
    
    long long q,t;//t只是一个记录数据的rbq（误）变量 
    string ins;
    scanf("%lld",&q);
    for(int i=1;i<=q;i++)
    {
        cin>>ins;
        if(ins[0]=='a')
        {
            if(n%2==0)
                t=min(shp[0],bhp[0]);
            else 
                t=shp[0];//上面这一小段取出当前mid 
                
            n++;
            scanf("%lld",&num);
            //cout<<"num="<<num<<endl; 
            if(t-num>0) //拟加入大根堆
            {
                bcnt++;
                bhp.push_back(num);
                push_heap(bhp.begin(),bhp.end(),bcmp);
                if(bcnt-scnt>=1)//如果大根堆数据数过多 
                {
                    t=bhp[0];
                    pop_heap(bhp.begin(),bhp.end(),bcmp);//弹出大根堆顶点 
                    bhp.pop_back();
                    bcnt--;scnt++;
                    shp.push_back(t);//加入小根堆 
                    push_heap(shp.begin(),shp.end(),scmp);//维护小根堆（这个大概有用~） 
                }
            }
            else//拟加入小根堆 
            {
                scnt++;
                shp.push_back(num);
                push_heap(shp.begin(),shp.end(),scmp);
                if(scnt-bcnt>=2)//如果小根堆数据数过多 
                {
                    t=shp[0];
                    pop_heap(shp.begin(),shp.end(),scmp);//与上面相反！ 
                    shp.pop_back();
                    scnt--;bcnt++;
                    bhp.push_back(t);
                    push_heap(bhp.begin(),bhp.end(),bcmp);
                }
            }
        }
        else//输出mid！ 
        {
            if(n%2==0)
                cout<<min(shp[0],bhp[0])<<endl;
            else 
                cout<<shp[0]<<endl;
        }
    }
    return 0;
}
```
##这里是题外话：

1.数据有点缺陷，如果初始数据只有一个数，堆创建会出现错误！( 但我A了 )

2.其实有很多方法比这个简单比如multiset，priority\_queue等，但正好复习堆，我就用stl写了这( 偷懒QWQ )

###最后一句话：

看提交记录会发现我错了10+遍，除了开始几遍，都是我垃圾队友瞎指点以至只得了20分

这里要提醒一下一定要以中位数为基准判定插入的新数应该放在哪个堆里，而不是根据插入的数据离哪个堆顶点更近...

还有一件事:不要轻易相信队友的话...


---

## 作者：Garrison (赞：6)

# 前言
今天考试考了这道题，又被机房里的其他同学给虐了（哭）忿忿不平的我想要发个题解。

# 方法：
对顶堆（对顶队列）
# 正文：
## 中位数：

中位数（Median）又称中值，统计学中的专有名词，是按顺序排列的一组数据中居于中间位置的数，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。（但是这一道题在数目为偶数的情况下取中间两个数的最小数）
## 对顶堆及其实现
这个玩意是可以动态维护第k大的值（比如中位数）每次操作logn。

本题我们可以建一个大根堆一个小根堆，大根堆取有序后的数列的前一半，小根堆取有序后数列的后一半。在处理的时候保证**大根堆中的数目>=小根堆的数目**
```
	scanf("%d",&n);
	l1=(n+1)>>1,l2=n-l1;
	for(register int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=l1;++i)
		Q2.push(a[i]);
	for(int i=l1+1;i<=n;++i)
		Q1.push(a[i]);
```
初始化完后我们怎么处理呢？
### 大根堆处理
```
if(x<=Q2.top()){
	if(l1==l2)
		Q2.push(x),++l1;
	else{//如果大根堆比小根堆多1
		++l2;
		Q2.push(x);
		int k=Q2.top();
		Q2.pop();
		Q1.push(k);
	}
}
```

### 小根堆处理
```
else{
	if(l1==l2){//如果相等，加到小根堆里
		++l1;
		Q1.push(x);
		int k=Q1.top();
		Q1.pop();
		Q2.push(k);
	}
	else Q1.push(x),++l2;
}
```
# 后记
其实这道蓝题是考察人的思路的，代码实现并不难，写的题解大家应该也看得懂（大家都比我强）
# Code
```
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 200005;
int a[MAXN],n,x,m;
char c[10];
priority_queue<int,vector<int>,greater<int> > Q1;
priority_queue<int> Q2;
int l1,l2;
int main(){
	scanf("%d",&n);
	l1=(n+1)>>1,l2=n-l1;
	for(register int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=l1;++i)
		Q2.push(a[i]);
	for(int i=l1+1;i<=n;++i)
		Q1.push(a[i]);
	scanf("%d",&m);
	for(register int i=1;i<=m;++i){
		cin>>c;
		if(c[0]=='a'){
			cin>>x;
			if(x<=Q2.top()){
				if(l1==l2)
					Q2.push(x),++l1;
				else{
					++l2;
					Q2.push(x);
					int k=Q2.top();
					Q2.pop();
					Q1.push(k);
				}
			}
			else{
				if(l1==l2){
					++l1;
					Q1.push(x);
					int k=Q1.top();
					Q1.pop();
					Q2.push(k);
				}
				else Q1.push(x),++l2;
			}
		}
		else
			printf("%d\n",Q2.top());
	}
	return 0;
}
```


---

## 作者：lndjy (赞：5)

看了一圈题解，竟然没有用multiset过的。multiset复杂度是logn级别的，不像vector那么假。

### 解法

建立一个multiset为s

先将所有元素放入s中，令迭代器it指向最开始的中位数。

根据题意，当元素个数为奇数时，中位数为第元素个数/2+1小的数，偶数时为第元素个数/2小的数。

对于add操作，先插入s中，然后让这个数和当前的中位数比较，如果比当前中位数大且插入后元素个数为奇数，就让迭代器指向下一个（因为multiset自动排序）。

如果比当前中位数小且插入后元素个数为偶数，就指向上一个。

对于mid操作，输出迭代器指向的值。

### AC code
```
#include<iostream>
#include<set>
#include<string>
#define int long long
using namespace std;
multiset<int> s;
signed main()
{
	int n;
	cin>>n;
	int a[n+1];
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		s.insert(a[i]);//先将所有元素放入s中
	}
	multiset<int> ::iterator it;
	it=s.begin();
	for(int i=1;i<s.size()/2;i++)
	it++;//令迭代器it指向最开始的中位数
	if(n%2==1) it++;
	string str;
	int m;
	cin>>m;
	while(m--)
	{
		cin>>str;
		if(str=="add")
		{
			int p;
			cin>>p;
			s.insert(p);
			if(s.size()%2==1)
			{
				if(p>*it) it++;//如果比当前中位数大且插入后元素个数为奇数，就让迭代器指向下一个
			 } 
			 if(s.size()%2==0)
			 {
			 	if(p<*it) it--;//如果比当前中位数小且插入后元素个数为偶数，就指向上一个。
			 }
		}
		else
		{
			cout<<*it<<endl;//对于mid操作，输出迭代器指向的值。
		}
	}
	return 0;
}
```


---

## 作者：Fatal (赞：5)

最近在学splay,一看要求中位数，就上一个单点修改splay吧
顺便安利一发splay写的**~~极好~~**（还行）的博客
https://blog.csdn.net/zj_js_zxb/article/details/80258824
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;
inline int read(){
	int f=1,x=0;
	char c=getchar();
	while (c<'0'||c>'9'){if (c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return f*x;
}
const  int maxn=1e5+5;
int n,m,o,p,root,tot;
int s[maxn][2],f[maxn],v[maxn],w[maxn],c[maxn];
char ch[1006];
inline void up(int x){
	w[x]=w[s[x][0]]+w[s[x][1]]+c[x];
}
inline void rotate(int x){
	int y=f[x],z=f[y],k=s[y][1]==x;
	s[z][s[z][1]==y]=x;
	f[x]=z;
	s[y][k]=s[x][k^1];
	f[s[x][k^1]]=y;
	s[x][k^1]=y;
	f[y]=x;
	up(y);up(x);
}
void splay(int x,int g){
	while (f[x]!=g){
		int y=f[x],z=f[y];
		if (z!=g)
		(s[z][0]==y)^(s[y][0]==x)?rotate(x):rotate(y);
		rotate(x); 
	}
	if (g==0) root=x;
}
inline int search(int k){
	int u=root;
	while (1){
	int q=s[u][0];
	if (w[q]+c[u]<k)
	k-=w[q]+c[u],u=s[u][1];
	else if (w[q]>=k) u=q;
	else return v[u];	
	}
}
inline void insert(int x){
	int u=root,ff=0;
	while (u&&v[u]!=x) ff=u,u=s[u][x>v[u]];
	if (u) c[u]++;
	else {
		u=++tot;
		if (ff) s[ff][x>v[ff]]=u;
		s[u][0]=s[u][1]=0;
		f[tot]=ff;
		v[tot]=x;
		c[tot]=1;
		w[tot]=1;
	}
	splay(u,0);
}
int main(){
	n=read();
	tot=0;
	int r,cnt=0;
	insert(-2147483647);
	insert(+2147483647);
   for (int i=1;i<=n;i++) insert(read()),cnt++;
   n=read();
   for (int i=1;i<=n;i++){
   	 cin>>ch;
   	 if (ch[0]=='a')  cin>>r,insert(r),cnt++;
   	 else {
   	 	
   	 	int u=cnt/2+1;
   	 	if (cnt%2==0) printf("%d\n",min(search(u),search(u+1)));
   	 	else printf("%d\n",search(u+1));
		}
   }
	return  0;
}
```

---

## 作者：Pluto1811 (赞：3)

$\text {QWQ}$

$\text {dalao}$们都太巨了，写的全是我下八百辈子都别想看懂的算法和数据结构。

我这种小蒟蒻，只好写一些奇奇怪怪的东西进来了。

$\text {C++}$有一个很神奇的东西叫做$\text {STL}$，里面有一些非常强大的~~一行就可以解决几百行代码的~~函数和容器。

这个题目我们就可以用一下里面的```vector```不定长数组和```lower_bound```这两个神奇的东西了。

~~当然你叫向量也没问题。不过我觉得向量好难理解，不定长数组多清晰易懂啊qwq(可能是我太弱了)~~

~~这道题也可以用优先队列做的，不过我太弱了不会~~

```
vector所支持的操作在本题主要有：
1. push_back(),就是把一个数加到vector的尾部
2. insert(),即把一个数插入到指定地址处

lower_bound的用法：
E.g. lower_bound(&a[0],&a[tail],x);
	 返回a[0]到a[tail]第一个大等于x的内存地址
```

好了，这题其实就是叫我们插入一个数$x$使得原序列仍然有序，然后输出最中间的数。其中插入时我们就可以用```lower_bound```。所以我们就可以这样优雅地~~暴力~~写出代码：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#define int long long
using namespace std;
int i,n,m,x;
vector <int> a;
char s[4];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
    	scanf("%d",&x);
    	a.push_back(x);
    }	
	sort(a.begin(),a.end());
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		cin>>s;
		if(s[0]=='a'){
			scanf("%d",&x);
			a.insert(lower_bound(a.begin()+1,a.end(),x),x);
//			for(int j=0;j<a.size();j++){
//				printf("%d ",a[j]);
//			}
//			printf("\n");	//我不会写迭代器qwq
		}
		if(s[0]=='m'){
			printf("%d\n",a[((1+a.size())>>1)-1]);
		}
	}
}
```

哦对，```vector```是从$0$开始为下标的，所以千万记得查询时$-1$。

最差情况下时间复杂度貌似能达到$O(M\times N)$，不过我还是跑的挺快的？？

另外，也可以用```lower_bound```写一下[导弹拦截](https://www.luogu.org/problemnew/show/P1020)。~~200分轻松到手~~

---

## 作者：subarude (赞：2)

看到并没有太多写**权值线段树**的

~~就来水一发题解~~

先把所有数和操作全都读进来

然后把原数组和要加入的揉到一块再离散化一下

然后用权值线段树维护一下就好了

注意这题如果区间长度为偶数那么中位数是中间那两个数的左边的那个$\texttt{qwq}$

具体的实现阔以看代码$\texttt{qwq}$


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define QwQ puts("qwq");
using std::cout;
using std::string;

inline int read() {
    int op = 1, a = 0; char c = getchar();
    for (; c < '0' || c > '9'; c = getchar()) if (c == '-') op = -1;
    for (; c >= '0' && c <= '9'; c = getchar()) a = a * 10 + c - '0';
    return op * a;
}

const int maxn = 110005;
const int maxm = 10005;
int n, m, cnt, len;//cnt为原数组和加的数的总个数
int a[maxn], b[maxn];
struct ope {string op; int w;} ope[maxm];//ope存操作

#define lson (u<<1)
#define rson (u<<1|1)
struct Seg {
    int l, r, w;
    Seg operator + (const Seg& rhs) const {
        Seg u; u.l = l, u.r = rhs.r;
        u.w = w + rhs.w; return u;
    }
} tr[maxn << 2];//权值线段树
void build(int u, int l, int r) {
    if (l == r) {tr[u].l = tr[u].r = l; return;}
    int mid = l + r >> 1;
    build(lson, l, mid), build(rson, mid + 1, r);
    tr[u] = tr[lson] + tr[rson];
}
int query(int u, int k) {
    if (tr[u].l == tr[u].r) return tr[u].l;
    int mid = tr[u].l + tr[u].r >> 1;
    if (tr[lson].w >= k) return query(lson, k);
    else return query(rson, k - tr[lson].w);
}
void modify(int u, int k, int w) {
    if (tr[u].l == tr[u].r) {tr[u].w += w; return;}
    int mid = tr[u].l + tr[u].r >> 1;
    if (k <= mid) modify(lson, k, w);
    else modify(rson, k, w);
    tr[u] = tr[lson] + tr[rson];
}

int main() {
    n = read();
    for (int i = 1; i <= n; i++) a[++cnt] = read(), b[cnt] = a[cnt];
    m = read();
    for (int i = 1; i <= m; i++) {
        std::cin >> ope[i].op;
        if (ope[i].op[0] == 'a') {
            ope[i].w = read();
            a[++cnt] = ope[i].w;
            b[cnt] = a[cnt];
        }
    }
    std::sort(b + 1, b + cnt + 1);
    len = std::unique(b + 1, b + cnt + 1) - b - 1;//len为去重之后的长度
    build(1, 1, len);//记得建树qwq
    for (int i = 1; i <= n; i++) {
        int pos = std::lower_bound(b + 1, b + len + 1, a[i]) - b;//离散化之后对应的数
        modify(1, pos, 1);
    }
    int tmp = 0;
    for (int i = 1; i <= m; i++) {
        if (ope[i].op[0] == 'a') {
            tmp++;//在原数组的基础上多加了几个数
            int pos = std::lower_bound(b + 1, b + len + 1, ope[i].w) - b;
            modify(1, pos, 1);//维护
        }
        else {
            //特判一下奇偶数
            if ((n + tmp) & 1) std::cout << b[query(1, (n + tmp >> 1) + 1)] << '\n';
            else std::cout << b[query(1, (n + tmp >> 1))] << '\n';
        }
    }
    return 0;
}
```

_thank you for reading_

---

## 作者：yzhang (赞：2)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/9974154.html)

### 平衡树板题

### [原题传送门](https://www.luogu.org/problemnew/show/P3871)

### 这道题要用Splay，我博客里有[对Splay的详细介绍](https://www.cnblogs.com/yzhang-rp-inf/p/9957906.html)

每次加入一个数，把数插入平衡树中

并且要记录一共有多少个数

每次查询就查询平衡树中第（总数-1）/2+1个数

十分暴力

```cpp
#include <bits/stdc++.h>
#define N 110005
#define root tree[0].ch[1]
using namespace std;
inline int read()
{
	register int x=0,f=1;register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}
inline void write(register int x)
{
	if(!x)putchar('0');if(x<0)x=-x,putchar('-');
	static int sta[36];int tot=0;
	while(x)sta[tot++]=x%10,x/=10;
	while(tot)putchar(sta[--tot]+48);	
}
struct splay{
	int v,fa,ch[2],rec,sum;
}tree[N];
int tot=0;
inline bool findd(register int x)
{
	return x==tree[tree[x].fa].ch[0]?0:1;
}
inline void connect(register int x,register int fa,register int son)
{
	tree[x].fa=fa;
	tree[fa].ch[son]=x;
}
inline void update(register int x)
{
	tree[x].sum=tree[tree[x].ch[0]].sum+tree[tree[x].ch[1]].sum+tree[x].rec;
}
inline void rotate(register int x)
{
	int Y=tree[x].fa;
	int R=tree[Y].fa;
	int Yson=findd(x);
	int Rson=findd(Y);
	int B=tree[x].ch[Yson^1];
	connect(B,Y,Yson);
	connect(Y,x,Yson^1);
	connect(x,R,Rson);
	update(Y),update(x);
}
inline void splay(register int x,register int to)
{
	to=tree[to].fa;
	while(tree[x].fa!=to)
	{
		int y=tree[x].fa;
		if(tree[y].fa==to)
			rotate(x);
		else if(findd(x)==findd(y))
			rotate(y),rotate(x);
		else
			rotate(x),rotate(x);
	}
}
inline int newpoint(register int v,register int fa)
{
    tree[++tot].v=v;
    tree[tot].fa=fa;
    tree[tot].sum=tree[tot].rec=1;
    return tot;
}
inline void Insert(register int x)
{
	int now=root;
    if(root==0)
    {
        newpoint(x,0);
        root=tot;
    }
    else
    {
        while(19260817)
        {
            ++tree[now].sum;
            if(x==tree[now].v)
            {
                ++tree[now].rec;
                splay(now,root);
                return;
            }
            int nxt=x<tree[now].v?0:1;
            if(!tree[now].ch[nxt])
            {
                int p=newpoint(x,now);
                tree[now].ch[nxt]=p;
                splay(p,root);
                return;
            }
            now=tree[now].ch[nxt];
        }
    }
}
inline int arank(register int x)
{
    int now=root;
    while(19260817)
    {
        int used=tree[now].sum-tree[tree[now].ch[1]].sum;
        if(x>tree[tree[now].ch[0]].sum&&x<=used)
        {
            splay(now,root);
            return tree[now].v;
        }
        if(x<used)
            now=tree[now].ch[0];
        else
            x-=used,now=tree[now].ch[1];
    }
}
int main()
{
	int n=read();
	int sum=0;
	for(register int i=1;i<=n;++i)
	{
		int x=read();
		Insert(x);
		++sum;
	}
	int m=read();
	while(m--)
	{
		char ch=getchar();
		while(ch!='a'&&ch!='m')
			ch=getchar();
		if(ch=='a')
		{
			int x=read();
			Insert(x);
			++sum;
		}
		else if(ch=='m')
		{
			write(arank((sum-1)/2+1));
			printf("\n");
		}
	}
	return 0;
 } 
 ```

---

## 作者：Hatsune_Miku (赞：2)

来一发 01-Trie 的题解。

> 01-Trie 树本质上就是一棵值域很大的值域线段树。 ——某大佬语

01-Trie 本身就是一棵二叉搜索树，但是这棵二叉搜索树由于深度确定从而具有了不会被卡的性质。01-Trie 树中存储的各个节点均为一个数的一个二进制位，只有遍历到叶子节点才能找到这个数。

01-Trie 的定义与 Trie 树一致，同样是有若干个指针指向后继节点（即后缀）和一些附加域记录每个节点的属性。作为 BST 使用时附加域至少有一个 `size` 表示当前子树的大小。

我们发现把每一个数插入到这棵 01-Trie 树里面，然后对这棵树进行 DFS，把 DFS 到的每个叶子节点所代表的每一个数还原回序列，序列就变成有序的了（太显然了）。

这样我们就相当于可以对这个序列进行插入和动态排序了。那么查询中位数也变成了一件十分容易的事情，就是查询一个第 k 大的问题。只需要按照 `size` 的指引在这棵 01-Trie 树里面行走就可以了。

注意由于题目中输入有负数，为了避免负数我们直接给插入的每一个数都加上 $10^9$ 使它们都变成正数，查询出结果后再统一减掉 $10^9$ 就是真正的答案了。由于实际插入的所有数都小于 $2\times10^9$，所以我们只需要考虑每个数的低 31 位二进制位即可（如果数据的值域没有这么大的话是可以优化一些内存占用的）。

时间复杂度有一个严格紧确的上界，即 $O(31(n+m))$。

01-Trie 相较于其它平衡树的优势在于代码短小，容易书写，且操作的时间复杂度稳定，不会被卡。缺点是内存占用较大（64 位指针内存占用会更大，但最多不会超过叶子节点的内存占用的总和，对于普通的非树套树的题目来说应该不是问题）。

~~我依然爱着 C++ 的指针！~~

开一个 `nil` 指针作为空指针代替系统默认的 `NULL` 就能防止绝大多数访问无效内存造成的 RE。写个最简单的内存池会比系统调用动态申请内存快不少。

附代码：

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm> 
using namespace std;
const int maxn = 120000 * 31;
const int fix = 1e9, full = 31;
struct node {
  node *ch[2]; int size;
} *nil, *rt, mem[maxn]; int cnt;
inline void newnode(node *&p) {
  mem[cnt].ch[0] = mem[cnt].ch[1] = nil;
  p = mem + cnt++;
}
inline void Insert(node *rt, int x) {
  x += fix;
  for(register int i = full; ~i; --i) {
    bool op = x >> i & 1;
    if(rt->ch[op] == nil) newnode(rt->ch[op]);
    rt = rt->ch[op];
    rt->size += 1;
  }
}
inline int kth(node *rt, int k) {
  int res = 0;
  for(register int i = full; ~i; --i) {
    if(k > rt->ch[0]->size)
      k -= rt->ch[0]->size, res |= 1 << i, rt = rt->ch[1];
    else rt = rt->ch[0];
  }
  return res - fix;
}
int size;
int main() {
  int n, x;
  scanf("%d", &n);
  size = n;
  newnode(nil), nil->ch[0] = nil->ch[1] = nil; newnode(rt);
  for(int i = 1; i <= n; ++i) scanf("%d", &x), Insert(rt, x);
  scanf("%d", &n);
  char s[15];
  while(n--) {
    scanf("%s", s);
    if(s[0] == 'a') scanf("%d", &x), Insert(rt, x), ++size;
    else printf("%d\n", size & 1 ? kth(rt, size / 2 + 1) : 
                               min(kth(rt, size / 2), kth(rt, size / 2 + 1)));
  }
  return 0;
}
```

---

## 作者：End_donkey (赞：1)

看完题解貌似没有手写堆的，本蒟蒻发一篇手写堆的代码吧。~~貌似手写堆跑的更快~~

### 这题先定义一个大根堆（maxn）维护mid（n为奇数mid+1）的元素。再定义一个小根堆（minn）维护mid（n为奇数mid+1）到n的元素。然后对于插入元素的情况进行分类讨论。

当add x时

#### 一.n 是奇数

 1.从大根堆中取出元素y并弹出。
 
 2.大根堆中插入元素min(x,y)。
 
 3.小根堆中插入元素max(x,y)。

#### 二.n 是偶数
 1.从小根堆中取出元素y并弹出。
 
 2.大根堆中插入元素min(x,y)。
 
 3.小根堆中插入元素max(x,y)。

当询问时输出大根堆中的堆顶元素即可。

addmax（大根堆中元素个数） addmin（小根堆中元素个数） maxn（大根堆） minn（小根堆）

### 堆的操作(以大根堆为例)
#### 1.堆的元素下调
```cpp
void shiftdownmax(int x){
    int t,flag=0;
    while(x*2<=addmax&&flag==0){
        if(maxn[x]<maxn[x*2])t=x*2;
        else t=x;
        if(x*2+1<=addmax){
            if(maxn[t]<maxn[x*2+1])t=x*2+1;
        }
        if(t!=x){
            swap(maxn[t],maxn[x]);
            x=t;
        }else flag=1;
    }
}
```
#### 2.堆的元素上调
```cpp
void shiftdownmax(int x){
    int t,flag=0;
    while(x*2<=addmax&&flag==0){
        if(maxn[x]<maxn[x*2])t=x*2;
        else t=x;
        if(x*2+1<=addmax){
            if(maxn[t]<maxn[x*2+1])t=x*2+1;
        }
        if(t!=x){
            swap(maxn[t],maxn[x]);
            x=t;
        }else flag=1;
    }
}
```
#### 3.建堆
由于堆的性质，只要调整一半的元素即可。
```cpp
for(int i=1;i<=tmp;++i){
	addmax++;
	maxn[addmax]=a[i];
}
for(int i=addmax/2;i>=1;--i){
	shiftdownmax(i);
}
```
#### 4.取出元素

取出第一个元素将最后一个元素放在第一个元素的位置，并且元素个数减1，对堆顶进行下调操作。
```cpp
int y=maxn[1];
maxn[1]=maxn[addmax--];
shiftdownmax(1);
```

#### 5.加入元素
在堆尾加入新元素并且对其进行上调操作
```cpp
maxn[++addmax]=min(x,y);
shiftupmax(addmax);
```

### ac代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,addmax,addmin,a[100010],maxn[60010],minn[60010];
char str[5];
void shiftdownmax(int x){//大根堆向下调整
    int t,flag=0;
    while(x*2<=addmax&&flag==0){
        if(maxn[x]<maxn[x*2])t=x*2;
        else t=x;
        if(x*2+1<=addmax){
            if(maxn[t]<maxn[x*2+1])t=x*2+1;
        }
        if(t!=x){
            swap(maxn[t],maxn[x]);
            x=t;
        }else flag=1;
    }
}
void shiftdownmin(int x){//小根堆向下调整
    int t,flag=0;
    while(x*2<=addmin&&flag==0){
        if(minn[x]>minn[x*2])t=x*2;
        else t=x;
        if(x*2+1<=addmin){
            if(minn[t]>minn[x*2+1])t=x*2+1;
        }
        if(t!=x){
            swap(minn[t],minn[x]);
            x=t;
        }else flag=1;
    }
}
void shiftupmax(int x) {//大根堆向上调整
    int flag=0; 
    if(x==1) return; 
    while(x!=1&&flag==0){
        if(maxn[x]>maxn[x/2]) swap(maxn[x],maxn[x/2]);
        else flag=1;
        x=x/2;
    }
}
void shiftupmin(int x) {//小根堆向上调整
    int flag=0; 
    if(x==1) return; 
    while(x!=1 && flag==0){
        if(minn[x]<minn[x/2]) swap(minn[x],minn[x/2]);
        else flag=1;
        x=x/2;
    }
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
	}
	addmax=0;
	addmin=0;
	sort(a+1,a+1+n);
	if(n==1) maxn[++addmax]=a[1];//考虑特殊情况
	else{	
		int tmp=n/2;
		if(n%2) tmp++;
		for(int i=1;i<=tmp;++i){
			addmax++;
			maxn[addmax]=a[i];
		}
		for(int i=addmax/2;i>=1;--i){
			shiftdownmax(i);
		}
		for(int i=tmp+1;i<=n;++i){
			addmin++;
			minn[addmin]=a[i];
		}
		for(int i=addmin/2;i>=1;--i){
			shiftdownmin(i);
		}
	}
	scanf("%d",&m);
	while(m--){
		scanf("%s",str);
		if(str[0]=='m'){
			printf("%d\n",maxn[1]);
		}
		else{
			scanf("%d",&x);
			if(n%2){
				int y=maxn[1];
				maxn[1]=maxn[addmax--];
				shiftdownmax(1);
				maxn[++addmax]=min(x,y);
				shiftupmax(addmax);
				minn[++addmin]=max(x,y);
				shiftupmin(addmin);
				n++;//记得更新n
			}
			else{
				int y=minn[1];
				minn[1]=minn[addmin--];
				shiftdownmin(1);
				minn[++addmin]=max(x,y);
				shiftupmin(addmin);
				maxn[++addmax]=min(x,y);
				shiftupmax(addmax);
				n++;				
			}
		}
	}
	return 0;
}
```


---

## 作者：rediserver (赞：1)

# P3871 [TJOI2010]中位数

[原题地址](https://www.luogu.org/problemnew/show/P3871)

[Github题解](https://github.com/jerrykcode/luogu)


## 思路

还没有用SBT树的题解！！！

SBT树使用结点数量维护平衡，这里要求的中位数也是数量相关的，所以就用SBT树了。

将最开始输入的n个数字及之后add的数字都插入SBT中。对于mid，设SBT中的数字数量为size，若size为奇数，则有size/2个数小于等于中位数；若size为偶数，
则有size/2 - 1个数小于等于中位数。即mid需要一个函数``` rank(SBT tree, size_t size) ```，用于返回SBT中的一个数，而SBT中有size个数小于等于它。

关于SBT的两个操作：

* 插入 (不详细写了，自行搜索)

* 查找一个数，有size个数小于等于它：从根结点开始，
	* 若左子树的size正好等于size，则根结点存储的数即所求；
	* 若左子树的size大于size，则递归，此时在左子树上有size个数小于等于它；
	* 若左子树的size小于size，则递归，在右子树上寻找它，但由于右子树的结点已经大于等于左子树及根结点，所以此时在右子树上有(size - 左子树的size - 1)个数小于等于它


## 代码

//代码里的template对此题纯属多此一举，直接int就行了

```cpp
#include <cstdio>
#include <cstdlib>
using namespace std;

template<typename T>
class MidNum {
public:
	MidNum();
	~MidNum();

	void add(T num);
	T mid();

private:

	typedef struct SBTNode {
		T num;
		struct SBTNode * left;
		struct SBTNode * right;
		size_t size;
		SBTNode(T num) : num(num), left(NULL), right(NULL), size(1) {}
	} * SBT;

	SBT left_rotate(SBT tree);
	SBT right_rotate(SBT tree);

	SBT maintain(SBT tree);
	SBT insert(SBT tree, T num);
	T rank(SBT tree, size_t size);
	
	void delete_tree(SBT tree);

private:
	SBT tree;
};

template<typename T>
MidNum<T>::MidNum() {
	tree = NULL;
}

template<typename T>
MidNum<T>::~MidNum() {
	delete_tree(tree);
}

template<typename T>
void MidNum<T>::add(T num) {
	tree = insert(tree, num);
}

template<typename T>
T MidNum<T>::mid() {
	size_t n = tree->size / 2;
	if (tree->size % 2) { //size为奇数
		return rank(tree, n); //n个数比中位数小
	}
	else { //size为偶数
		return rank(tree, n - 1); //n - 1个数比中位数小
	}
}

template<typename T>
typename MidNum<T>::SBT MidNum<T>::left_rotate(SBT tree) {
	SBT k = tree->right;
	tree->right = k->left;
	k->left = tree;
	k->size = tree->size;
	size_t left_size = tree->left ? tree->left->size : 0; //左子树有可能为NULL
	size_t right_size = tree->right ? tree->right->size : 0; //右子树有可能为NULL
	tree->size = left_size + right_size + 1;
	return k;
}

template<typename T>
typename MidNum<T>::SBT MidNum<T>::right_rotate(SBT tree) {
	SBT k = tree->left;
	tree->left = k->right;
	k->right = tree;
	k->size = tree->size;
	size_t left_size = tree->left ? tree->left->size : 0; //左子树有可能为NULL
	size_t right_size = tree->right ? tree->right->size : 0; //右子树有可能为NULL
	tree->size = left_size + right_size + 1;
	return k;
}

template<typename T>
typename MidNum<T>::SBT MidNum<T>::maintain(SBT tree) {
	if (tree == NULL) return NULL;
	SBT left = tree->left, right = tree->right;
	size_t left_size = left ? left->size : 0;
	size_t right_size = right ? right->size : 0;
	if (left && left->left && left->left->size > right_size) { //左子树的左子树大于右子树
		tree = right_rotate(tree);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	else if (left && left->right && left->right->size > right_size) { //左子树的右子树大于右子树
		tree->left = left_rotate(tree->left);
		tree = right_rotate(tree);
		tree->left = maintain(tree->left);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	else if (right && right->right && right->right->size > left_size) { //右子树的右子树大于左子树
		tree = left_rotate(tree);
		tree->left = maintain(tree->left);
		tree = maintain(tree);
	}
	else if (right && right->left && right->left->size > left_size) { //右子树的左子树大于左子树
		tree->right = right_rotate(tree->right);
		tree = left_rotate(tree);
		tree->left = maintain(tree->left);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	return tree;
}

template<typename T>
typename MidNum<T>::SBT MidNum<T>::insert(SBT tree, T num) {
	if (tree == NULL) return new SBTNode(num);
	tree->size++;
	if (num < tree->num) {
		tree->left = insert(tree->left, num);
	}
	else {
		tree->right = insert(tree->right, num);
	}
	tree = maintain(tree); //维护平衡
	return tree;
}

template<typename T>
T MidNum<T>::rank(SBT tree, size_t size) {
	if (tree == NULL) return 0;
	size_t left_size = tree->left ? tree->left->size : 0;
	if (left_size == size) {
		return tree->num;
	}
	else if (left_size > size) {
		return rank(tree->left, size);
	}
	else {		
		return rank(tree->right, size - left_size - 1);
	}
}

template<typename T>
void MidNum<T>::delete_tree(SBT tree) {
	if (tree == NULL) return;
	delete_tree(tree->left);
	delete_tree(tree->right);
	delete tree;
}

int main() {
	int n, m, num;
	scanf("%d", &n);
	MidNum<int> mid_num;
	size_t i;
	for (i = 0; i < n; i++) {
		scanf("%d", &num);
		mid_num.add(num);
	}
	scanf("%d", &m);
	char cmd[3];
	for (i = 0; i < m; i++) {
		scanf("%s", cmd);
		if (cmd[0] == 'a') {
			scanf("%d", &num);
			mid_num.add(num);
		}
		else {
			printf("%d\n", mid_num.mid());
		}
	}
	return 0;
}
```

---

## 作者：Ireliaღ (赞：1)

## 来一篇指针版无旋Treap

### 题目大意

维护一组数据，支持插入和查找中位数，如果数据个数为偶数那么选较小的一个

### 前置知识

$FHQTreap$，可以看我[博客](https://www.cnblogs.com/Juruo1103/p/10281403.html)

### 思路

在对树进行$Split$的时候按照$size$分裂而不是权值，插入操作时查一下$rank$，拆开树再夹进去。查中位数时候拆出$size$为$\frac{root->size-1}{2}$的左树，然后在右树中拆出一个节点即为中位数

### 代码

```cpp
#include <stdio.h>

int Rand() {
    static int seed = 123456;
    return seed = (((seed ^ 666666) + 19260817ll) * 1433223ll) % 0x3f3f3f3f;
}

namespace FHQ{
    struct Node{
        int val, key, size;
        Node *child[2];
        Node(int val):val(val), key(Rand()), size(1){child[0] = child[1] = NULL;}
    };

    Node *root = NULL;

    void Update(Node *now) {
        now->size = 1;
        now->size += now->child[0] ? now->child[0]->size : 0;
        now->size += now->child[1] ? now->child[1]->size : 0;
    }


    void Split(Node *now, int k, Node *&t1, Node *&t2) {
        if (!now) {
            t1 = t2 = NULL; return;
        }
        if (k == 0) {
            t1 = NULL; t2 = now; return;
        }
        if (k >= now->size) {
            t1 = now; t2 = NULL; return;
        }
        int ls = now->child[0] ? now->child[0]->size : 0;
        if (k <= ls) {
            Node *temp;
            Split(now->child[0], k, t1, temp); 
            t2 = now; t2->child[0] = temp; Update(t2); return;
        } else {
            Node *temp;
            Split(now->child[1], k - ls - 1, temp, t2);
            t1 = now; t1->child[1] = temp; Update(t1); return;
        }
    }

    Node *Merge(Node *a, Node *b) {
        if (!a || !b) return a ? a : b;
        if (b->key > a->key) {
            a->child[1] = Merge(a->child[1], b);
            Update(a); return a;
        } else {
            b->child[0] = Merge(a, b->child[0]);
            Update(b); return b;
        }
    }

    int Rank(Node *now, int k) {
        if (!now) return 1;
        int ls = now->child[0] ? now->child[0]->size : 0;
        if (k < now->val)
            return Rank(now->child[0], k);
        else if (k > now->val)
            return Rank(now->child[1], k) + ls + 1;
        else return ls + 1;
    }

    void Insert(int k) {
        if (!root) {
            root = new Node(k);
            return;
        }
        int rank = Rank(root, k);
        Node *lt, *rt;
        Split(root, rank - 1, lt, rt);
        root = Merge(lt, Merge(new Node(k), rt));
    }

    int GetMid() {
        Node *lt, *rt, *temp, *node;
        Split(root, root->size - 1 >> 1, lt, temp);
        Split(temp, 1, node, rt);
        int res = node->val;
        root = Merge(lt, Merge(node, rt));
        return res;
    }
}

int n, m, x;
char str[5];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &x);
        FHQ::Insert(x);
    }
    scanf("%d", &m);
    for (int i = 1; i <= m; i++) {
        scanf("%s", str);
        if (str[0] == 'a') {
            scanf("%d", &x);
            FHQ::Insert(x);
        } else {
            printf("%d\n", FHQ::GetMid());
        }
    }
    return 0;
}
/*
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
*/
```

话说一楼的zip-tree看起来比fhq还要好写，要学一波了

---

## 作者：GaoZiyou (赞：1)

## 居然没有链表的题解
## 本蒟蒻就来一发
## 【思路】
离线处理，先把所有要加进去的数都加入链表中，然后对链表排序，这样操作中加入一个数的操作就可以转化为倒序的删除一个数，不难发现，删除一个数后，中位数只会更新为它的前驱或后继，用一个指针扫描即可求出中位数。
## 【实现】
- 链表结点的定义
```cpp
struct Node {
    int val, pre, suc;
    Node(int val = 0, int pre = 0, int suc = 0): val(val), pre(pre), suc(suc) {}
} l[N << 1];
```
val表示权值，pre、suc分别表示前驱、后继

- 存储操作
```cpp
struct Oper {
    int op, p, ans;
} c[N];
```
op=1表示添加，p表示连续倒序操作时要删除的链表结点的指针  
op=0表示查询，ans记录答案

- 如何对链表排序
```cpp
struct cmp {
    bool operator()(int x, int y) { return l[x].val < l[y].val; }
};
for (int i = 1; i <= tot; ++i) t[i] = i;
  sort(t + 1, t + tot + 1, cmp());
```
建立辅助数组t，保证每个添加操作的指针不会丢失

- 删除一个结点后指针如何移动
```cpp
  int now = t[(tot + 1) / 2];
  int a = (tot + 1) / 2 - 1, b = tot - a - 1;
  for (int i = m; i >= 1; --i)
    if (c[i].op == 1) {
      int p = c[i].p;
      if (rank[p] <= rank[now])
        --a;
      else
        --b;
      if (p == now) now = l[now].pre;
      Link(l[p].pre, l[p].suc);
      if (a + 1 < b)
        now = l[now].suc, ++a, --b;
      if (a > b)
        now = l[now].pre, --a, ++b;
    } else {
      c[i].ans = l[now].val;
    }
  }
```
now表示当前中位数结点的指针  
a表示比当前中位数小的数的个数  
b表示比当前中位数大的数的个数  
分类讨论一下就行了  
注意特判删除的结点为中位数的情况

## 【代码】
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1e5 + 10;

int n, m, t[N << 1], tot, rank[N << 1];
char str[4];

struct Node {
  int val, pre, suc;
  Node(int val = 0, int pre = 0, int suc = 0): val(val), pre(pre), suc(suc) {}
} l[N << 1];

struct Oper {
  int op, p, ans;
} c[N];

inline void Link(int x, int y) {
  l[x].suc = y, l[y].pre = x;
}

struct cmp {
  bool operator()(int x, int y) { return l[x].val < l[y].val; }
};

int main() {
  scanf("%d", &n);
  for (int i = 1, x; i <= n; ++i) {
    scanf("%d", &x);
    l[++tot] = Node(x);
  }
  scanf("%d", &m);
  for (int i = 1, x; i <= m; ++i) {
    scanf("%s", str);
    if (str[0] == 'a') {
      c[i].op = 1;
      scanf("%d", &x);
      l[++tot] = Node(x);
      c[i].p = tot;
    } else {
      c[i].op = 0;
    }
  }
  for (int i = 1; i <= tot; ++i) t[i] = i;
  sort(t + 1, t + tot + 1, cmp());
  for (int i = 1; i <= tot; ++i)
    rank[t[i]] = i;
  for (int i = 1; i < tot; ++i)
    Link(t[i], t[i + 1]);
  int now = t[(tot + 1) / 2];
  int a = (tot + 1) / 2 - 1, b = tot - a - 1;
  for (int i = m; i >= 1; --i)
    if (c[i].op == 1) {
      int p = c[i].p;
      if (rank[p] <= rank[now])
        --a;
      else
        --b;
      if (p == now) now = l[now].pre;
      Link(l[p].pre, l[p].suc);
      if (a + 1 < b)
        now = l[now].suc, ++a, --b;
      if (a > b)
        now = l[now].pre, --a, ++b;
    } else {
      c[i].ans = l[now].val;
    }
  for (int i = 1; i <= m; ++i)
    if (c[i].op == 0) printf("%d\n", c[i].ans);
  return 0;
}
```

---

## 作者：蕾姆酱QvQ (赞：1)

~~嗯。。。。一道巨水无比的题。。不知道咋蓝的。（emm恶意评分？（逃~~


看一下题目

题目描述
给定一个由N个元素组成的整数序列，现在有两种操作：

1 add a

在该序列的最后添加一个整数a，组成长度为N + 1的整数序列

2 mid 输出当前序列的中位数

中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）

例1：1 2 13 14 15 16 中位数为13

例2：1 3 5 7 10 11 17 中位数为7

例3：1 1 1 2 3 中位数为1

输入输出格式
输入格式：
第一行为初始序列长度N。第二行为N个整数，表示整数序列，数字之间用空格分隔。第三行为操作数M，即要进行M次操作。下面为M行，每行输入格式如题意所述。

输出格式：
对于每个mid操作输出中位数的值

输入输出样例
输入样例#1： 复制
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
输出样例#1： 复制
5
13
说明
对于30%的数据，1 ≤ N ≤ 10,000，0 ≤ M ≤ 1,000

对于100%的数据，1 ≤ N ≤ 100,000，0 ≤ M ≤ 10,000

序列中整数的绝对值不超过1,000,000,000，序列中的数可能有重复


好首先看完题目数据范围发现int是完全够的，所以我们直接读入后根据题目要求做就阔以了（本蒟蒻并不会什么高级的数据结构，所以用数组模拟）

注意输出中位数的时候判断一下此时的元素个数是奇数个还是偶数个就好了（相信dalao们不用我讲就知道

上代码qwq

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<algorithm>
#define ll long long
#define re register

using namespace std;

ll n,m,a[200001];//这里开longlong有些浪费所以大家开int就好了

int main()
{
	scanf("%lld",&n);
	for(re int i=1; i<=n; i++) scanf("%lld",&a[i]);
	scanf("%lld",&m);
	sort(a+1,a+n+1);//先排序
	for(re int i=1; i<=m; i++)
	{
		string s; 
		cin>>s;
		if(s=="add")
		{
			ll c;
			scanf("%lld",&c);
			n++;
            for(int j=1;j<=n;j++) 
				if(a[j]>=c)
				{
               	    for(int k=n;k>=j;k--) a[k]=a[k-1];
                   	a[j]=c;
                   	break;
           		}
		}//加入一个数
		else
		{
			if(n%2==0) printf("%lld\n",min(a[n>>1],a[(n+2)>>1]));
			else printf("%lld\n",a[(n+1)>>1]);
		}
	}
	return 0;//标准结尾
}
```

---

## 作者：OIer991215 (赞：1)

什么叫暴力出奇迹呢？大概就是这道题吧。

最坏复杂度（n\*m），最优复杂度O（n），然后我就写个暴力看看脸吧，结果居然AC了。

（好水的数据，居然还是几年前的省选题。。大概是因为忘了防暴力了吧）

这题有很多解法啊，平衡树啊，还有下面题解里说到的堆啊。

既然暴力出奇迹，那么我是如何暴力的呢？

将原数组sort，然后add的时候，二分查找位置，然后将这个位置往后的数依次往后挪一位，没了。

add复杂度（logn+n），mid复杂度（1）；

暴力出奇迹，暴力出奇迹，暴力出奇迹！

其实仔细想想卡掉暴力的数据其实不是很多，而且既然只有十个数据，为了卡掉暴力的数据很有可能被其他奇怪又可能错误的做法水过，可能出题人忘了我们这种蒟蒻会如此暴力的解这道题吧。既然能AC本题，那就发个题解吧，告诉大家 不会做题的时候 千万不要忘了打暴力。


    
```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
char key[1010101];
int n,m,pos,num;
int f[1010101];
int read()
{
    int rt=0,in=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            in=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        rt=rt*10+ch-'0';
        ch=getchar();
    }
    return rt*in;
}
int main()
{
    n=read();
    for(int i=1; i<=n; i++)
        f[i]=read();
    sort(f+1,f+1+n);
    m=read();
    for(int i=1; i<=m; i++)
    {
        scanf("%s",key+1);
        if(key[1]=='a')
        {
            num=read();
            n++;
            pos=n;
            int l=1,r=n+1;
            while(l<=r)
            {
                int mid=(l+r)/2;
                if(f[mid]>=num)
                {
                    pos=mid;
                    r=mid-1;
                }
                else
                    l=mid+1;
            }
            for(int i=n; i>pos; i--)
                f[i]=f[i-1];
            f[pos]=num;
        }
        if(key[1]=='m')
            printf("%d\n",f[(1+n)>>1]);
    }
    return 0;
}
```

---

## 作者：VenusM1nT (赞：1)

平衡树。操作涉及插入和查询全局中值，插入没什么好说的，平衡树基本操作，而查询全局中值我们可以将它看作**查询全局 $K$ 大值**，其中 $K=\frac{n}{2}+(n\mod 2)$，即偶数时为两个中值中更小的那个，奇数时为中值。

基本上所有的平衡树都能轻松地完成这两个操作，不过基于数据范围和代码长度，依然写了一个 $\text{FHQ Treap}$，如果数据范围更大一点的话可能可以卡掉 $\text{FHQ}$，个人觉得可以出个加强版，查询区间中值，然后卡线段树套 $\text{FHQ}$，就是真的变态了。

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
using namespace std;
struct FHQTreap
{
	int son[2],siz,val,key;
}t[MAXN<<1];
int n,Q,root,siz;
string s;
int NewNode(int val)
{
	t[++siz].val=val;
	t[siz].siz=1;
	t[siz].key=rand();
	return siz;
}
void Update(int rt)
{
	t[rt].siz=t[t[rt].son[0]].siz+t[t[rt].son[1]].siz+1;
}
int Merge(int x,int y)
{
	if(!x || !y) return x+y;
	if(t[x].key<t[y].key)
	{
		t[x].son[1]=Merge(t[x].son[1],y);
		Update(x);
		return x;
	}
	else
	{
		t[y].son[0]=Merge(x,t[y].son[0]);
		Update(y);
		return y;
	}
}
void Split(int rt,int pos,int &x,int &y)
{
	if(!rt) x=y=0;
	else
	{
		if(t[rt].val<=pos)
		{
			x=rt;
			Split(t[rt].son[1],pos,t[rt].son[1],y);
		}
		else
		{
			y=rt;
			Split(t[rt].son[0],pos,x,t[rt].son[0]);
		}
		Update(rt);
	}
}
void Insert(int val)
{
	int x,y;
	Split(root,val,x,y);
	root=Merge(Merge(x,NewNode(val)),y);
}
int FindKth(int rt,int rk)
{
	while(1)
	{
		if(rk<=t[t[rt].son[0]].siz) rt=t[rt].son[0];
		else if(rk==t[t[rt].son[0]].siz+1) return t[rt].val;
		else
		{
			rk-=t[t[rt].son[0]].siz+1;
			rt=t[rt].son[1];
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		Insert(x);
	}
	scanf("%d",&Q);
	while(Q--)
	{
		int x;
		cin>>s;
		if(s=="add")
		{
			scanf("%d",&x);
			Insert(x);
			n++;
		}
		else
		{
			x=n/2;
			if(n&1) x++;
			printf("%d\n",FindKth(root,x));
		}
	}
	return 0;
}
```

---

## 作者：汇文客 (赞：1)

来一发pbds红黑树！




```cpp
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#include<bits/stdc++.h> 
using namespace  __gnu_pbds;
using namespace std; 
tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update>t;
inline long long read()
{
    long long x=0,f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-48;
    return x*f;
}
inline string sread()
{
    string s;char ch=getchar();
    for(;ch<'a'||ch>'z';ch=getchar());
    for(;ch>='a'&&ch<='z';ch=getchar())s+=ch;
    return s;
}
int main()
{
    long long n,m,i,num;
    string q;
    n=read();
    for(i=0;i<n;i++)
    num=read(),t.insert((num<<20)+i);
    m=read();
    while(m--)
    {
        q=sread();
        if(q=="mid")
        {
            if(n%2==0)num=*t.find_by_order(n/2-1);//使用这个时一定要注意，它返回的是第0~n-1个数，不是1~n
            else num=*t.find_by_order(n/2);
            printf("%lld\n",num>>20);
        }
        else
        {
            i++,n++;num=read();
            t.insert((num<<20)+i);
        }
    }
    return 0;
}
```

---

## 作者：Drinkwater (赞：1)

这题没有标签啊什么鬼。。。看到题就想到了主席树，但是发现并不需要，只需要维护一个权值线段树就好了，每次询问第k大，开始把询问什么的都离散化一下就好了，对偶堆的做法也很巧妙啊。。。前不久才看的。











```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
using namespace std;
typedef long long LL;
#define REP(i,a,b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++i)
#define DREP(i,a,b) for(register int i = (a),i##_end_ = (b); i >= i##_end_; --i)
int read()
{
    register int f = 1,s = 0;char c = getchar();
    while(!isdigit(c)) { if(c == '-')f = -1; c = getchar();}
    while(isdigit(c)) { s = s * 10 + c - '0';c = getchar();}
    return f * s;
}
const int maxn = 200011;
struct T
{
    int    t,x,xx;    
}q[maxn];
int a[maxn],b[maxn],rnk[maxn],cnt,num[maxn];
char s[20];
int n,m;
int tr[maxn<<2];
void insert(int h,int l,int r,int p)
{
    if(l == r){tr[h]++;return ;}
    int mid = (l + r) >> 1;
    if(p <= mid)insert(h<<1,l,mid,p);
    else insert(h<<1|1,mid+1,r,p);
    tr[h] = tr[h<<1] + tr[h<<1|1];
}
int query(int h,int l,int r,int k)
{
    if(l == r)return l;
    int sum = tr[h<<1];
    int mid = (l + r) >> 1;
    if(k <= sum)return query(h<<1,l,mid,k);
    else return query(h<<1|1,mid+1,r,k-sum);
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
#endif
    n = read();cnt = n;
    REP(i,1,n)a[i] = read(),b[i] = a[i];
    m = read();
    REP(i,1,m)
    {
        cin>>s;
        if(s[0] == 'm')q[i].t = 0;
        else
        {
            q[i].t = 1;q[i].x = read();
            b[++cnt] = q[i].x;
        }
    }
    sort(b+1,b+1+cnt);
    int tmp = unique(b+1,b+1+cnt) - (b+1);
    REP(i,1,tmp)num[i] = b[i];
    REP(i,1,n)rnk[i] = lower_bound(b+1,b+1+tmp,a[i])-b;
    REP(i,1,m) if(q[i].t)q[i].xx = lower_bound(b+1,b+1+tmp,q[i].x)-b;
    REP(i,1,n)insert(1,1,tmp,rnk[i]);
    int now = n;
    REP(i,1,m)
    {
        if(!q[i].t)
        {
            if(now&1)printf("%d\n",num[query(1,1,tmp,now/2+1)]);
            else printf("%d\n",num[query(1,1,tmp,now/2)]);
        }
        else insert(1,1,tmp,q[i].xx),++now;
    }
    return 0;
}

```

---

## 作者：alicealice (赞：0)

### **动态整体第K大**
~~等一位待修主席树/树套树dalao~~

动态整体第k大一般会用平衡树或者是权值线段树（树状数组）配上二分

正好没有替罪羊树的代码，就让我水一发替罪羊吧。

```cpp
#define ls t[p].l
#define rs t[p].r
const double ap = 0.75;//0.7~0.8均可
struct node
{
	int l, r, v;
	int sz, ft;
	bool e;
};
node t[N];
int cnt, rt;
int v[N], vc;
```
l,r表示当前结点的两个子树，sz表示当前结点子树大小（包含自己以及被删除的结点），ft表示当前结点子树的实际大小（包含自己），e表示当前结点是否存在；rt是整个树的根，cnt是整个树共有多少个结点（包含删除了的）；v用来存储要重构的点，vc是v的大小（也可以直接用vector代替；

替罪羊树是一棵重量平衡树，~~众所周知~~它是一棵很暴力的树，它在左右子树重量不平衡时会进行重构。

```cpp
bool bad(int p) { 
	return max(t[ls].sz, t[rs].sz) > ap*t[p].sz || t[p].sz - t[p].ft > t[p].sz*0.3;
}
```
当结点的左右子树有一个太大时或者被删除的结点太多时就进行重构；

```cpp
void ldr(int p) {//中序遍历这个子树
	if (!p)return;
	ldr(ls);
	if (t[p].e)//删除的点肯定不能加进去
		v[++vc] = p;
	ldr(rs);
}
void lift(int &p, int s, int e)
{
	if (s == e) {
		p = v[s], ls = rs = 0, t[p].sz = t[p].ft = 1;
		return;
	}
	int k = s + e >> 1;
	while (s < k&&t[v[k]].v == t[v[k - 1]].v)k--;
	p = v[k];
	if (s < k)
		lift(ls, s, k - 1);
	else 
		ls = 0;
	lift(rs, k + 1, e);
	t[p].sz = t[ls].sz + t[rs].sz + 1,t[p].ft = t[ls].ft + t[rs].ft + 1;
}
void rebuild(int &p) { 
	vc = 0;//记得清空
	ldr(p);
	if (!vc) { //如果v里没有数字
		p = 0; //表明当前结点的所以子树都被删除了
		return; 
	}
	lift(p, 1, vc);//否则就将v里的标号重构
}
```
根据二叉搜索树的特点可以写出它的插入代码

```cpp
void add(int &p, int val) {
	p = ++cnt, t[p].v = val;
	t[p].sz = t[p].ft = t[p].e = 1;
}
void insert(int &p, int val)
{
	if (!p) { 
		add(p, val), check(rt, p);
		return; 
	}
	t[p].sz++, t[p].ft++;
   	if (val < t[p].v)
		insert(ls, val);
	else 
		insert(rs, val);
}
```
既然插入了数字，就有可能造成不平衡，所以每次插入后都check一次

```cpp
void update(int p, int ed)
{
	if (!p)return;
	t[ed].v < t[p].v ? update(ls, ed) : update(rs, ed);
	t[p].sz = t[ls].sz + t[rs].sz + 1;
}
void check(int &p, int ed)
{
	if (p == ed)return;
	if (bad(p)) {
		rebuild(p), update(rt, p);
		return; 
	}
	t[ed].v < t[p].v ? check(ls, ed) : check(rs, ed);
}
```
check之后再更新一下当前结点的子树；

```cpp
int getval(int rk)
{//获取排名为rk的数字
	int p = rt;
	while (p)
	{
		if (rk == t[ls].ft + t[p].e)
			break;//如果正好相等，break就行了
		else if (rk <= t[ls].ft)
			p = ls;//如果rk小于等于左子树的实际大小，所求值就会在左子树上
		else 否则去右子树上查询
			rk -= t[ls].ft + t[p].e, p = rs;
	}
	return t[p].v;
}
```

然后查询就完事了；

~~感觉有点乱啊~~

#### 完整代码

~~节约篇幅~~

```cpp
#define ls t[p].l
#define rs t[p].r
inline LL read() {
	char ch = getchar(); LL x = 0, f = 1;
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	} while ('0' <= ch && ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar();
	} return x * f;
}
struct node
{
	int l, r, v;
	int sz, ft;
	bool e;
};
node t[N];
const double ap = 0.75;
int cnt, rt;
int v[N], vc;
void add(int &p, int val) {}
bool bad(int p) {}
void ldr(int p) {}
void lift(int &p, int s, int e){}
void rebuild(int &p) {}
void update(int p, int ed){}
void check(int &p, int ed){}
void insert(int &p, int val){}
int getnum(int rk){}
int main()
{
	int x, m, n;
	char op[5];
	n = read();
	for (int i = 1; i <= n; i++)
		insert(rt, read());
	m = read();
	x = n;
	while (m--)
	{
		scanf("%s", op);
		if (op[0] == 'a')
			insert(rt, read()), x++;
		else
			printf("%d\n", getnum((x&1) + (x >> 1)));
	}
}
```


---

## 作者：羽儇 (赞：0)

话不多说

---
$Solution$

开一个大根堆，一个小根堆

令大根堆的堆顶为中位数

由题意得，有时候中位数的次序会变，有时候不会变

$1$、当序号变的时候，就需要往大根堆里插一个数了

而这个数来自$x,$或者另一个小根堆的堆顶

那么只需比较一下这两个数，小的数插进大根堆里即可

$2$、当序号不变时，已知小根堆里的所有的数都比大根堆的数大，那么只需令x与大根堆的堆顶比较一下，小的数去大根堆堆顶，大的数去小根堆堆顶。


```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
#include <iostream>
using namespace std;
priority_queue<int>q;
priority_queue<int,vector<int>,greater<int> >p;
int x,N,M,mid;
string s;
int main()
{
	scanf("%d",&N);
	for(int i = 1 ; i <= N ; i ++ )scanf("%d",&x),q.push(x);
	while(q.size() > (N + 1)/ 2)p.push(q.top()),q.pop();
	scanf("%d",&M);
	while(M--)
	{
		cin >> s;
		if(s[0] == 'm')printf("%d\n",q.top());
		else 
		{   
			scanf("%d",&x);
			mid = (++ N + 1) >> 1;
			if(mid > N >> 1)
			{
				if(x < p.top())q.push(x);
			    else q.push(p.top()),p.pop(),p.push(x);
			}
			else 
			{
				if(x < q.top())q.push(x),p.push(q.top()),q.pop();
			    else p.push(x);
			}
		}
	}
	return 0;
}
```


---

## 作者：lemir3 (赞：0)

[*获得更好的阅读体验*](https://www.lemir3.red/2019/08/14/阿穆尔共青城造船厂Project3871-TJOI-中位数项目竣工报告/)

[*题面*](https://www.luogu.org/problem/P3871)

平衡树练习题.

## 题目分析

维护一个单调递增的数列,支持插入数值和查询数列的中位数.

于是就很容易想出,写一颗平衡树来维护这个数列,查询树中排名在中间的树.

我用了非旋$Treap$,如果不会的话,可以看我的注释.

## 代码

```cpp

#include "cstdio"
#include "cstring"
#include "iostream"
#include "cmath"
#include "cstdlib"
#include "algorithm"

#define lxl long long
#define R register
#define debug(x) printf("debug:%lld\n",x)

using namespace std;

lxl n,m,root,cnt,tot;
string opt;

struct TREENODE
{
	lxl l,r,val,heap,size;
}t[1000010];

struct NODE
{
	lxl l,r;
};

inline void insert(lxl);
inline NODE split(lxl,lxl);
inline void UpDate(lxl);
inline lxl rank_(lxl);
inline lxl merge(lxl,lxl);
inline lxl find(lxl,lxl);

signed main(void)
{
	scanf("%lld",&n);
	tot=n;
	for(R lxl _=1;_<=n;++_)
	{
		lxl num;
		scanf("%lld",&num);
		insert(num);
	}
	scanf("%lld",&m);
	for(R lxl _=1;_<=m;++_)
	{
		lxl num;
		cin>>opt;
		if(opt[0]=='a')
		{
			scanf("%lld",&num);
			insert(num);//插入到树中
			tot++;
		}
		else
		{
//			debug(tot);
			lxl pos;
			if(tot%2==0)
			{
				pos=tot>>1;
			}
			else
			{
				pos=(tot>>1)+1;
			}
			printf("%lld\n",find(root,pos));
		}
	}
return 0;
}

inline void insert(lxl x)
{
	t[++cnt].val=x;//创建一个新的结点
	t[cnt].heap=rand();
	t[cnt].size=1;
	NODE p=split(root,rank_(x));//按排名把树分割为比它大的和比它小的两部分
	root=merge(merge(p.l,cnt),p.r);//然后合并进去
}

inline NODE split(lxl x,lxl k)//将以x为根的子树割去前k个结点
{
	NODE p={0,0};
	if(!x)
	{
		return p;
	}
	lxl LSize=t[t[x].l].size+1;//左子树的结点数量
	if(k>=LSize)//如果要割的数比左子树的结点数量多,割右子树
	{
		p=split(t[x].r,k-LSize);
		t[x].r=p.l;
		p.l=x;
	}
	else
	{
		p=split(t[x].l,k);
		t[x].l=p.r;
		p.r=x;
	}
	UpDate(x);//更新子树的大小
return p;
}

inline void UpDate(lxl x)
{
	t[x].size=t[t[x].l].size+t[t[x].r].size+1;
}

inline lxl rank_(lxl x)//获取值为x的数的排名
{
	lxl now=root,ans=0;
	while(now)
	{
		if(x>t[now].val)//如果x大于当前结点,ans累加左子树结点数量,now跳到右子树
		{
			ans+=t[t[now].l].size+1;
			now=t[now].r;
		}
		else
		{
			now=t[now].l;
		}
	}
return ans;
}

inline lxl merge(lxl l,lxl r)//合并以l为根结点的树和以r为根结点的树,返回合并后的根结点
{
	if(!l||!r)
	{
		return l+r;
	}
	if(t[l].heap<t[r].heap)//按照随机分配的值来合并,使其不容易退化成链
	{
		t[l].r=merge(t[l].r,r);
		UpDate(l);
		return l;
	}
	else
	{
		t[r].l=merge(l,t[r].l);
		UpDate(r);
		return r;
	}
}

inline lxl find(lxl x,lxl k)//查询以x为根的树中第k个数的值
{
	lxl now=x;
	while(true)
	{
		lxl val=t[t[now].l].size+1;
		if(k==val)
		{
			return t[now].val;//返回数值
		}
		if(k<val)
		{
			now=t[now].l;
		}
		else
		{
			k-=val;//更新为要往右子树找的数量
			now=t[now].r;
		}
	}
}

```

---

## 作者：opened (赞：0)

**~~本题解为堆实现，如要研究其他毒瘤数据结构，请自动跳过~~**

算法原理与其他堆实现的算法一样，但我在插入元素和处理堆时~~更加巧妙~~取反实现大根堆，导致鄙人的代码有一种~~极简~~风格，请大佬们放心食用

# Talk is cheap, show me the code.

```
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
priority_queue<int>q1/*堆顶为答案，使堆中元素等于（所有元素+1）/2*/,q2/*模拟大根堆*/;
int n,m;
void insert(int x){//加入操作每次取小根堆堆顶和加入的数比较，大于堆顶则加入小根堆否则加入大根堆
    if(q1.empty()) return q1.push(x);
    if(x<=q1.top()){
        q1.push(x);
        if(q1.size()>q2.size()+1) q2.push(-q1.top()),q1.pop();
    }
	else{
        q2.push(-x);
        if(q1.size()<q2.size()) q1.push(-q2.top()),q2.pop();
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
    	int x;scanf("%d",&x);
		insert(x);
	}
	scanf("%d",&m);
    while(m--){
		char s[6];
        cin>>s;
        if(s[0]=='a'){
	    	int x;scanf("%d",&x);
			insert(x);
		}
        else printf("%d\n",q1.top());
    }
    return 0;
}

```

---


# [中山市赛 2024] 参数拟合

## 题目描述

在《机械设计与制作》课程中，Jimmy 制作了一款机械臂作为期末作业。在测试与改进阶段，immy 通过实验测得了他设计的机械臂的尺寸、硬度、灵活度、最大抓力等 $n$ 个参数 $A_1, A_2\dots A_n$。根据理论计算，机械臂的最佳性能参数为 $B_1, B_2\dots B_n$。为了提高机械臂的性能，拿到更高的分数，Jimmy 决定调整机械参数。

由于机械臂各个部件间具有关联性，修改某个参数的同时也会影响到另一个参数。具体来说，只有 m 种调整可以进行：给定 $(x_i, y_i)$，让 $A_{x_i} \gets A_{x_i} + p, A_{y_i} \gets A_{y_i} + p$，其中 $p$ 为任意整数，且调整次数不限。Jimmy 希望通过调整使得 $S =\sum \limits_{i=1}^n(A_i - B_i)^2$ 最小，请你帮他算出调整后 $S$ 的最小值。

## 说明/提示

### 数据范围

- 对于 $20\%$ 的数据，$1 \leq n, m \leq 5$，$0 \leq A_i, B_i \leq 5$。
- 另有 $40\%$ 的数据，所有 $B_i = 0$ 且所有 $x_i = 1$ 。
- 对于 $100\%$ 的数据，$1 \leq n \leq 2 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq A_i, B_i \leq 10^5$。

注意：$(x_i, y_i)$ 可能出现重复。


## 样例 #1

### 输入

```
6 3
14 9 1 0 4 7
11 11 5 8 7 3
1 2
3 4
5 6```

### 输出

```
46```

# 题解

## 作者：dengchengyu (赞：4)

## [中山市赛 2024] 参数拟合 题解

首先考虑把每一对 $x,y$ 连边。

对于每一个联通块，可以把所有 $a_i-b_i$ 汇聚到一个点上，然后考虑怎么分配才能使得答案最小。

即对于一个联通块，设：
$$
sum=|\sum_ia_i-b_i|
$$
显然要平均分配才能最小，于是设 $sz$ 为连通块大小，则：
$$
s=\lfloor\frac{sum}{sz}\rfloor
$$

$$
t=sum \bmod sz
$$

$$
ans\gets ans+t(s+1)^2+(sz-t)s^2
$$

但是这样是不对的，答案可能会偏大。

考虑一个长度为奇数的环，这里以三为例：$(a,b),(b,c),(c,a)$。

则我们可以进行操作：$(a,b,1),(b,c,-1),(c,a,1)$，发现这样以后 $a$ 就加了二。

所以我们就把 $sum$ 移动到奇数环上，这样贡献就是 $sum \bmod 2$。

我们可以把图黑白染色，如果有一条边两边颜色一样则出现了奇数环。

时间复杂度 $O(n+m)$。

代码：

```cpp
const int N=2e5+5,M=5e5+5;
#define ll long long 
ll a[N],b[N];
int to[M<<1],nx[M<<1],st[N],tot;
void add(int x,int y){
	to[++tot]=y,nx[tot]=st[x],st[x]=tot;
}
int vis[N];
int bz[N];
int flag[N],rt;
ll ans=0,sz;
void dfs(int x){
	vis[x]=1,sz++;
	for(int i=st[x];i;i=nx[i]){
		int v=to[i];
		if(!vis[v]){
			bz[v]=bz[x]^1;
			dfs(v);
			if(a[v]!=0){	
				a[x]-=a[v];
				a[v]=0;
			}
		}
		else if(bz[v]==bz[x]){
			flag[rt]=1;
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&b[i]);
		a[i]=a[i]-b[i];
	}
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			sz=0;
			bz[i]=0;
			rt=i;
			dfs(i);
			if(a[i]<0)a[i]=-a[i];
			if(flag[i])ans+=a[i]%2;
			else {
				ll t=a[i]/sz,t2=a[i]%sz;
				ans+=(sz-t2)*t*t+t2*(t+1)*(t+1);
			}
		}
	}
	printf("%lld\n",ans);
}
```

---


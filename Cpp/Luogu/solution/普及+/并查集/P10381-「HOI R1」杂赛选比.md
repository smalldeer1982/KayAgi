# 「HOI R1」杂赛选比

## 题目背景

你说得对，但是小 $\iiint$ 在打 CF 时将 Earn or Unlock 错看成了下面的鬼畜样子，痛失 2h 遗憾离场，希望大家引以为戒。

## 题目描述

给定一个长度为 $n$ 的数组 $a$，初始只有 $a_1$ 是已被解锁的。现在有一个整数 $i$，初始值为 $1$。现在小 $\iiint$ 在对这个数组进行一个游戏：

- 如果 $a_i$ 未被解锁，游戏结束。
- 否则他可以将 $a_{i+1\sim i+a_i}$ 设置成已被解锁的，或是获得 $a_i$ 个金币（如果 $a_i=0$ 则无法解锁任何元素），然后将 $i$ 加 $1$。

请你求出游戏结束后你能获得的最大金币数量。

## 说明/提示

#### 【样例 1 解释】

对于第一组数据，你可以解锁 $a_2$，再获得 $a_2$ 个金币。而对于第三组数据，你无法解锁 $a_2$，因此只能获得 $0$ 个金币。

对于第二组数据，你可以解锁 $a_2,a_3$，并获得 $9$ 个金币。

#### 【样例 2 解释】

将第 $1,2,3,6$ 个位置用于解锁为最优方案。

#### 【数据范围】

对于 $100\%$ 的数据，$1\le n\le10^5$，$0\le a_i\le10^5$，$T\le 5$。

|测试点编号|$n\leq$|$a_i\leq$|$T=$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$10$|$0$|$1$|/|
|$2\sim3$|$10$|$5$|$1$|/|
|$4\sim5$|$600$|$600$|$1$|/|
|$6\sim8$|$5000$|$5000$|$1$|/|
|$9\sim10$|$10^5$|$5$|$5$|/|
|$11\sim12$|$5\times10^4$|$10^5$|$5$|$a_i>n$|
|$13\sim20$|$10^5$|$10^5$|$5$|/|

## 样例 #1

### 输入

```
3
2
1 2
5
2 4 5 0 1
4
0 4 4 4
```

### 输出

```
2
9
0
```

## 样例 #2

### 输入

```
1
10
1 1 4 5 1 4 1 9 1 9```

### 输出

```
26
```

# 题解

## 作者：Register_int (赞：18)

首先有个比较显然的 dp。设 $dp_i$ 为从 $i$ 开始开到 $n$ 的最大金币数量，显然有：

$$dp_i=\max(a_i,\max_{1\le j\le a_i}dp_{i+j}+\sum^{j-1}_{k=1}a_{i+k})$$

含义是枚举拿不拿 $a_i$ 和开完之后拿多少个。这是 $O(n^2)$ 的所以考虑优化，拆开式子后，发现一次转移等价于：

- $i+1\sim i+a_i$ 区间查询最大值。
- $i+1\sim n$ 区间加 $a_i$。
- $i$ 单点加 $dp_i$。

上个线段树即可，复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;

struct node {
	int l, r; ll v, add;
} t[MAXN << 2];

inline 
void upd(int p, ll v) {
	t[p].add += v, t[p].v += v;
}

inline 
void pushup(int p) {
	t[p].v = max(t[p << 1].v, t[p << 1 | 1].v);
}

inline 
void pushdown(int p) {
	if (!t[p].add) return ;
	upd(p << 1, t[p].add), upd(p << 1 | 1, t[p].add), t[p].add = 0;
}

void build(int l, int r, int p) {
	if (l > r) return ;
	t[p].l = l, t[p].r = r, t[p].v = t[p].add = 0;
	if (l == r) return ; int mid = l + r >> 1;
	build(l, mid, p << 1), build(mid + 1, r, p << 1 | 1);
}

void modify(int l, int r, ll v, int p) {
	if (l > r) return ;
	if (l <= t[p].l && t[p].r <= r) return upd(p, v);
	pushdown(p); int mid = t[p].l + t[p].r >> 1;
	if (l <= mid) modify(l, r, v, p << 1);
	if (r > mid) modify(l, r, v, p << 1 | 1); pushup(p);
}

ll query(int l, int r, int p) {
	if (l > r) return 0;
	if (l <= t[p].l && t[p].r <= r) return t[p].v;
	pushdown(p); int mid = t[p].l + t[p].r >> 1; ll res = 0;
	if (l <= mid) res = max(res, query(l, r, p << 1));
	if (r > mid) res = max(res, query(l, r, p << 1 | 1)); return res;
}

int T, n; ll a[MAXN], dp[MAXN];

int main() {
    for (scanf("%d", &T); T--;) {
	    scanf("%d", &n), build(1, n, 1);
	    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	    for (int i = n, l, r; i; i--) {
	    	dp[i] = a[i], l = i + 1, r = min<ll>(i + a[i], n);
	    	dp[i] = max(dp[i], query(l, r, 1));
	    	modify(l, n, a[i], 1), modify(i, i, dp[i], 1);
		}
		printf("%lld\n", dp[1]);
	}
}
```

---

## 作者：int_R (赞：9)

转化成在 $i$ 处解锁一次相当于花费了 $a_i$ 的代价，枚举解锁到的最远位置，当前点答案为前缀和减去最小代价。

最小代价转换成最短路，对于每个 $i\in[1,n]$，连一条由 $i$ 到 $\min(i+a_i,n)$ 边权为 $a_i$ 的边。对于每个 $i\in[2,n]$，连一条由 $i$ 到 $i-1$ 边权为 $0$ 的边。跑最短路即可得到最小代价。

感觉比线段树好多了啊！

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<utility>
#include<queue>
#define int long long
using namespace std;
const int MAXN=1e5+10,MAXM=2e5+10,INF=1e15;
int T,n,a[MAXN],s[MAXN],dis[MAXN],ans;
int to[MAXM],nxt[MAXM],head[MAXN],val[MAXM],cnt;
typedef pair<int,int> P;bool vis[MAXN];
inline void add(int x,int y,int v)
{
    to[++cnt]=y,nxt[cnt]=head[x];
    head[x]=cnt,val[cnt]=v;return ;
}
inline void dij()
{
    priority_queue < P,vector<P>,greater<P> > q;
    q.push({dis[1]=0,1});
    while(!q.empty())
    {
        int x=q.top().second;q.pop();
        if(vis[x]) continue;vis[x]=true;
        for(int i=head[x];i;i=nxt[i])
        {
            int y=to[i];if(dis[y]<=dis[x]+val[i]) continue;
            q.push({dis[y]=dis[x]+val[i],y});
        }
    }
}
inline void work()
{
    cin>>n,cnt=ans=0;
    for(int i=1;i<=n;++i) head[i]=vis[i]=0,dis[i]=INF;
    for(int i=1;i<=n;++i)
    {
        cin>>a[i],s[i]=s[i-1]+a[i];
        if(i>1) add(i,i-1,0);add(i,min(i+a[i],n),a[i]);
    }
    dij();for(int i=1;i<=n;++i) ans=max(ans,s[i]-dis[i]);
    cout<<ans<<'\n';return ;
}
signed main()
{
#ifdef ONLINE_JUDGE
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
#else
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    cin>>T;while(T--) work();
    return 0;
}
```

---

## 作者：OneLeft (赞：7)

## 题意
给你一个长度为 $n$ 的序列 $a$，对于每个元素 $a_i(1\le i\le n)$ 有两种状态：激活和失活。一开始 $a_1$ 是激活的，$a_i(2\le i\le n)$ 是失活的。

现在你有一个变量 $x=1$，你进行如下的操作：

- 若 $a_x$ 为失活状态，结束操作。
- 若 $a_x$ 为激活状态，你可以让 $a_i(x+1\le i\le x+a_x)$ 变成激活状态，如果你不那么做的话，你可以获得 $a_x$ 个金币。

求最多获得金币的数量。

## 思路
不难发现很难进行贪心，于是使用 DP，设 $dp_i$ 表示从 $x=i$ 时最多获得金币的数量（不包括当 $a_i$），一开始 $dp_1=0$，$dp_i(2\le i\le n)=-inf$。

不难发现对于一个 $i(1\le i\le n)$，可以用 $dp_i$ 更新到 $dp_j(i+1\le j\le i+a_i)$，设 $sum_i=\sum_{j=l}^ia_j$，利用前缀和则转移方程为：

$$dp_j=\max\{dp_j,dp_i+sum_{j-1}-sum_i\}$$

有一个细节：有可能出现走完全程都没有遇到失活元素的情况，所以 DP 时需要对 $dp_{n+1}$ 也进行处理，最终输出答案时也要考虑 $dp_{n+1}$。

不难发现答案为：

$$\max\{\max_{i=1}^ndp_i+a_i,dp_{n+1}\}$$

但是这个程序的时间复杂度为 $O(n^2)$，过不了，考虑优化。

这个转移方程同时包含 $i$ 和 $j$，有点烦，但是我们发现无论如何转移，$-sum_{j-1}$ 这个项始终存在，所以可以把这个项去掉，现在转移方程就只包含 $i$ 了，故可以使用线段树进行优化，对于 $j$ 求出最大的 $dp_i-sum_i$。最终答案为：

$$\max\{\max_{i=1}^ndp_i+a_i+sum_{i-1},dp_{n+1}+sum_{n}\}$$

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5,inf=(int)4e18+5;
class Segment_tree//线段树
{
	private:
		struct data1
		{
			int val,tag;
			data1(){val=tag=0;}
			data1(int a,int b){val=a,tag=b;}
		}node[N*4];
		void push_down(int id)
		{
			node[id*2].val=max(node[id*2].val,node[id].tag);
			node[id*2+1].val=max(node[id*2+1].val,node[id].tag);
			node[id*2].tag=max(node[id*2].tag,node[id].tag);
			node[id*2+1].tag=max(node[id*2+1].tag,node[id].tag);
			node[id].tag=-inf;
		}
	public:
		void build(int id,int l,int r)
		{
			node[id]=data1(-inf,-inf);
			if(l!=r)
			{
				int mid=(l+r)/2;
				build(id*2,l,mid);
				build(id*2+1,mid+1,r);
			}
		}
		void updata(int id,int l,int r,int x,int y,int val)//区间修改
		{
			if(x<=l&&r<=y)
			{
				node[id].val=max(node[id].val,val);
				node[id].tag=max(node[id].tag,val);
				return;
			}
			push_down(id);
			int mid=(l+r)/2;
			if(x<=mid)updata(id*2,l,mid,x,y,val);
			if(y>mid)updata(id*2+1,mid+1,r,x,y,val);
		}
		int query(int id,int l,int r,int x)
		{
			if(l==r)return node[id].val;
			push_down(id);
			int mid=(l+r)/2;
			if(x<=mid)return query(id*2,l,mid,x);
			return query(id*2+1,mid+1,r,x);
		}
}tree;
int T,n,a[N];
int sum[N],dp[N],maxn;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--)
	{
		maxn=-inf;
		cin>>n;
		tree.build(1,1,n+1);
		tree.updata(1,1,n+1,1,1,0);
		for(int i=1;i<=n;i++)cin>>a[i],sum[i]=sum[i-1]+a[i];
		for(int i=1;i<=n;i++)
		{
			dp[i]=tree.query(1,1,n+1,i)+sum[i-1];//求值
			maxn=max(maxn,dp[i]+a[i]);//获得答案
			if(a[i]!=0)tree.updata(1,1,n+1,i+1,i+a[i],dp[i]-sum[i]);//转移
		}
		dp[n+1]=tree.query(1,1,n+1,n+1)+sum[n];//dp[n+1]求值
		cout<<max(maxn,dp[n+1])<<'\n';
	}
	return 0;
}
```

---

## 作者：xiaoliebao1115 (赞：7)

官方线段树太难打了，所以我用堆来优化。

## 动态规划

定义 $dp_i$ 为算到当前位置，并选择向后设置解锁的最大答案。

更新 $dp_i$ 时，比如从 $dp_j$ 更新，要求 $dp_j$ 设置解锁时一定能覆盖到 $dp_i$，则之间的每个数都可以选择增加贡献，所以就有 $  dp_i=dp_j+ \begin{aligned}\sum_{k=j+1}^{i-1}\end{aligned}a_k$，求和可以用前缀和求解。

所以在所有 $j+a_j\ge i$ 的 $dp_j$ 当中选出一个 $dp_j+\begin{aligned}\sum_{k=j+1}^{i-1}\end{aligned}a_k$ 最大的数更新 $dp_i$。

时间复杂度 $O(n^2)$。
## 优化

以 $dp_j+\begin{aligned}\sum_{k=j+1}^{n}\end{aligned}a_k$ 为第一关键字，$j+a_j$ 为第二关键字压入优先队列。

在更新时，每次取出头 $x$，判断这个是否能覆盖当前 $dp_i$，若不能，弹出，若能，$dp_i$ 应该等于 $x$ 的第一关键字减去 $\begin{aligned}\sum_{k=i}^{n}\end{aligned}a_k$，即是减去多余部分，并跳出循环。

时间复杂度 $O(n\log n)$。

## code
这里给出关键部分。
```cpp
for(int i=2;i<=n;i++)
{
	while(1)
	{
		if(q.top().second>=i||q.empty()) break;
		q.pop();
	}
	if(q.empty()) continue;
	/*
	for(int j=1;j<i;j++)
	{		
		if(a[j]+j>=i)
		{
			dp[i]=max(dp[i],dp[j]+sum[i-1]-sum[j]);
		}
	}*/
	dp[i]=q.top().first-(sum[n]-sum[i-1]);
	q.push({dp[i]+sum[n]-sum[i],i+a[i]});
}
```
最后的答案就是所有数中最大的 $dp_i+a_i$，即是把这个数换成不向后设置而选择增加答案。

---

## 作者：Yue_ran (赞：5)

## 前言

你说得对，但这个人在写 spfa 时将节点弹出队列时未清空数组导致一直 50pts，希望大家引以为戒。

## 正文

看到前言应该知道这篇题解是 spfa 了吧。题目里的约束条件是不是很让人想建图？

考虑一个自然的想法，若其选择把 $a_{i+1\sim i+a_i}$ 设为已被解锁，则原本可以获得的 $a_i$ 金币会不能获得，而 $a_{i+1\sim i+a_i}$ 可以得到金币。那么建边就很显然了：$i$ 向 $j\in[i+1,i+a_i]$ 连边，边权为 $-a_i+\sum_{k=i+1}^{j}a_k$。答案即为最长路。

这样建边是 $n^2$ 的，显然不行。考虑优化建图。对于任意 $i\to j,i\to j+1$，其边权固定相差 $a_j$。

那么可以考虑在两者之间连一条边使其可以相互转化。要保证 $i+a_i$ 可达，$i+a_i+1$ 不可达，考虑 $i\to i+a_i$ 连一条边权为 $-a_i+\sum_{k=i+1}^{i+a_i}a_k$ 的边，$j\to j-1$ 连一条权值为 $-a_{j}$ 的边。这样和原图就等价了，且边数优化到了 $2n$。

这里有两点稍微要注意，一是 $i+a_{i}+1$ 有可能比 $n$ 大，和 $n$ 取较小值就好了。二是最初 $1$ 号点已经被解锁了，起始点距离设为 $a_1$ 即可。

直接跑 spfa 即可，感觉出题人应该不会想到要卡 spfa。

在洛谷上跑得飞快，只跑了 270ms。

code:

```cpp
const int N=1e5+10;
int a[N],head[N],cot,n,inq[N];
ll dis[N],sum[N];
struct edge{
	int v,nex;ll w;
}e[N<<1];
void add(int u,int v,ll w){
	e[++cot]={v,head[u],w};
	head[u]=cot;
}
il void spfa(){
	queue<int>q;
	rep(i,2,n) dis[i]=-1e18;
	dis[1]=a[1];inq[1]=1;q.push(1); 
	while(!q.empty()){
		int u=q.front();q.pop();inq[u]=0;
		tep(i,u){
			int v=e[i].v;
			if(dis[v]<dis[u]+e[i].w){
				dis[v]=dis[u]+e[i].w;
				if(!inq[v]){
					inq[v]=1;
					q.push(v);
				}
			}
		}
	}
}
main(){
    // freopen("data.in","r",stdin);
    // freopen("data.out","w",stdout);
	int t=read();
	while(t--){
		cot=0;n=read();
		rep(i,1,n) a[i]=read(),sum[i]=sum[i-1]+a[i];
		rep(i,2,n) add(i,i-1,-a[i]);
		rep(i,1,n){
			if(a[i]){
				int v=min(a[i]+i,n); 
				add(i,v,sum[v]-sum[i]-a[i]); 
			}
		}
		spfa();
		ll ans=0;
		rep(i,1,n) ans=max(ans,dis[i]),head[i]=0;
		printf("%lld\n",ans);
	}
    return 0;
}
```

---

## 作者：I4ever (赞：3)

### 分析  
1. 考虑 dp：由题意得，要想让一个 $a_{i}$ 有贡献，必须要让 $a_{1\sim i}$ 都解锁，相当于我们只能从最远解锁位置不小于 $i$ 的状态转移过来。
   
2. 由此定义状态：$dp_{i,0/1}$ 表示第 $i$ 项被解锁后，其用于解锁/累计分数的最大分数，$p_{i,0/1}$ 表示其对应的最远解锁位置。提前处理好 $a_{i}$ 的前缀和 $sum_{i}$。设 $V_{i}$ 为最远解锁位置不小于 $i$ 的状态的集合，转移方程为:

 $$\hspace{5mm}dp_{i,0}=\max_{k\in V_{i}}\{dp_{k,0/1}+sum_{i-1}-sum_{k}\}$$,
 $$\hspace{5mm}dp_{i,1}=\max_{k\in V_{i}}\{dp_{k,0/1}+sum_{i}-sum_{k}\}$$ 

$\hspace{5mm}V_{i}$ 每次遍历所有前置状态，判断 $p_{k,0/1}$ 是否合法即可。$p_{i,0/1}$ 虽 $dp_{i,0/1}$ 转移而转移即可，第二维为 0 加上 $a_{i}$，为 1 不变。

3. 目前的做法的时间复杂度为 $O(n^{2})$，考虑优化，观察到瓶颈在于每一次都需要遍历前置状态找 $V_{i}$，思考有什么办法可以不用遍历查找，而是直接找到最大值。 4. 考虑用数据结构来维护前置状态，想一想该维护什么，观察方程 $$dp_{i,0}=dp_{k,0/1}+sum_{i-1}-sum_{k}$$ 可以变为（另一个同理） $$dp_{i,0}=(dp_{k,0/1}-sum_{k})+sum_{i-1}$$ 所以对于每一个状态，可以直接把 $dp_{i,0/1}-sum_{i}$ 和 $p_{i,0/1}$ 放入数据结构，放入的位置在 $1\sim p_{i,0/1}$。可以用树状数组维护最大的 $dp$。此时时间复杂度被优化至 $O(n\log (n))$。

### 代码  
```cpp  
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 1e5 + 10;
int read() {
	int x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}
int a[maxn];
int n, T;
ll ans;
struct node {
	ll w;
	int p;
	node() {
		w = -1e16;
		p = 0;
	}
} c[maxn];
ll sum[maxn];
int lowbit(int x) {
	return x & -x;
}
void add(int p, ll w) {
	for (int i = p; i; i -= lowbit(i)) {
		if (c[i].w < w) {
			c[i].w = w;
			c[i].p = p;
		} else if (c[i].w == w)
			c[i].p = max(c[i].p, p);
	}
}
node get(int p) {
	node res;
	for (int i = p; i <= n; i += lowbit(i)) {
		if (c[i].w > res.w) {
			res.w = c[i].w;
			res.p = c[i].p;
		} else if (c[i].w == res.w) {
			res.p = max(res.p, c[i].p);
		}
	}
	return res;
}
int main() {
	T = read();
	while (T--) {
		n = read();
		for (int i = 1; i <= n; ++i) {
			a[i] = read();
			sum[i] = sum[i - 1] + a[i];
		}
		for (int i = 1; i <= n; ++i) {
			c[i].w = -1e16, c[i].p = 0;
		}
		ans = a[1];
		add(min(n, 1 + a[1]), -a[1]);
		for (int i = 2; i <= n; ++i) {
			node tmp = get(i);
			if (!tmp.p) {
				break;
			}
			ans = max(ans, tmp.w + sum[i]);
			if (i + a[i] > tmp.p) {
				add(min(n, i + a[i]), tmp.w - a[i]);
			}
			add(tmp.p, tmp.w);
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：hh弟中弟 (赞：2)

这不是我们今天 CF Div2D/Div1B 吗？ \
如果 $i$ 是解锁状态，那么 $[1,i]$ 都是解锁状态。考虑结束状态，一定是解锁完最后一个后直接一直吃到解锁的最远的一个。因为每次都是 $i+1$，所以之前的不吃以后就不可能再吃到了。于是题目就转化成了对于一个 $a_i$ 要么选择吃，然后 $i-1$，考虑之前的决策。要么选择这个位置以后再也不吃了，跳到 $\min(a_i+i,n)$ 位置，再做考虑。\
所以最后我们吃的其实是一个前缀和减去损失的价值，所以考虑求出到达每个位置时损失的最小价值，有跳跃操作，考虑连边最短路，首先有 $i$ 连到 $i-1$，边权为 $0$，然后有 $i$ 连到 $\min(a_i+i,n)$，边权为 $a_i$，表示损失了 $a_i$ 的价值。跑完最短路后取 $\max(sum_i-dis_i)$ 即可。\
直接把 CF 的代码中的 $b_i$ 换成 $\min(a_i+i,n)$ 就过了，有点难蚌。

```cpp
#include<bits/stdc++.h>
#define int long long
#define fi first
#define se second
#define pii std::pair<int,int>
#define eb emplace_back
typedef long long ll;
typedef unsigned long long ull;
std::mt19937 myrand(std::chrono::high_resolution_clock::now().time_since_epoch().count());
inline int R(int n){return myrand()%n+1;}
inline int read(){char ch=getchar();int x=0,f=1;for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);return x*f;}
const int N=4e5+10,mod=998244353,inf=1e18;
inline void Min(int &x,int y){if(x>y)x=y;}
inline void Max(int &x,int y){if(x<y)x=y;}
inline void W(int &x,int y){x=(x+y)%mod;}
struct Node{
	int pos,w;
	inline bool operator<(const Node&A)const{return w>A.w;}
};
std::priority_queue<Node>q;
bool vis[N];
int dis[N],n,a[N],b[N];
struct EDGE{int v,w;};
std::vector<EDGE> e[N];
inline void add(int u,int v,int w){e[u].push_back({v,w});}
inline void dij(){
	std::fill(dis+1,dis+n+1,inf);std::fill(vis+1,vis+n+1,0);
	dis[1]=0;q.push({1,0});
	while(!q.empty()){
		int x=q.top().pos;q.pop();
		if(vis[x])continue;vis[x]=1;
		for(auto it:e[x]){
			int v=it.v,w=it.w;
			if(dis[v]>dis[x]+w){
				dis[v]=dis[x]+w;
				if(!vis[v])q.push({v,dis[v]});
			}
		}
	}
}
signed main(){
    // freopen("in.in","r",stdin);freopen("out.out","w",stdout);
    std::ios::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);
    int T=read();
    while(T--){
    	n=read();
    	for(int i=1;i<=n;++i)a[i]=read(),e[i].clear();
    	for(int i=2;i<=n;++i)add(i,i-1,0);
    	for(int i=1;i<=n;++i){
    		if(a[i])add(i,std::min(n,i+a[i]),a[i]);
    	}
    	dij();
    	int ans=0;
    	for(int i=1;i<=n;++i)a[i]=a[i-1]+a[i],ans=std::max(ans,a[i]-dis[i]);
    	std::cout<<ans<<'\n';
    }
}
```

---

## 作者：ny_jerry2 (赞：2)

## 前言
打完代码后去看题解，发现大多数用线段树的做法都带了区间修改的，这里来一篇只有单点修改的线段树（原因是没发现怎么用懒标记）。
***

## 算法
线段树优化动态规划。
***

## 思路
首先可以发现，如果正着循环直接 dp 会不太好做（虽然我用正着搜的记忆化搜索过了前面的数据，但要开二维数组，而且 dp 状态很奇怪），因此我们考虑倒着循环。

设 $dp_i$ 表示从 $i$ 到 $n$ 能取得最大金币数量，那么我们可以分两种情况：

- 取当前位置上的金币：贡献即 $a_i$。

- 不取：即用它来解锁，这时候要引入一个 $j$ ，用来枚举解锁后从第 $i+1$ 个金币一直去到第 $j$ 个金币，而后再去使用之前求出的 $dp_j$。因为我们是倒着循环的，而 $j>i$，所以 $dp_j$ 一定是先前已经求出的。对于每一次枚举，我们肯定都要取一次最大值。

方程：$dp_i = \max(a_i, \sum_{j=1}^{a_i} dp_{i+j}+ \sum_{k=1}^{j-1}a_{i+k})$  

这样的话，35pt 到手：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int t,n;
#define ll long long
const int N=1e5+10;
ll a[N];
ll f[N];
ll sum[N];
inline ll read(){
	ll x=0,op=1;
	char ch=getchar();
	while(!isdigit(ch)&&ch!='-'){
		ch=getchar();
	}
	while(ch=='-'){
		op=-op;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1ll)+(x<<3ll)+(ch^48);
		ch=getchar();
	}
	return x*op;
}
int main(){
	t=read();
	while(t--){
		n=read();
		for(int i=1;i<=n;i++){
			a[i]=read();
			f[i]=0;
			sum[i]=sum[i-1]+a[i];
		}
		f[n+1]=0;
		for(int i=n;i;i--){
			f[i]=a[i];
			for(int j=1;j<=a[i]&&i+j<=n+1;j++){
				ll s=0;
				for(int k=1;k<j;k++){
					s+=a[i+k];
				}
				f[i]=max(f[i],f[i+j]+s);
			}
		}
		cout<<f[1]<<endl;
	}
}
```

很显然，最后 $\sum_{k=1}^{j-1}a_{i+k}$ 可以用前缀和优化。

令 $sum_i$ 为从 $a_1$ 到 $a_i$ 的前缀和，变式：  
$dp_i = \max(a_i, \sum_{j=1}^{a_i} dp_{i+j}+ (sum_{i+j-1}-sum_i))$  


50pt 到手。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int t,n;
#define ll long long
const int N=1e5+10;
ll a[N];
ll f[N];
ll sum[N];
inline ll read(){
	ll x=0,op=1;
	char ch=getchar();
	while(!isdigit(ch)&&ch!='-'){
		ch=getchar();
	}
	while(ch=='-'){
		op=-op;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1ll)+(x<<3ll)+(ch^48);
		ch=getchar();
	}
	return x*op;
}
int main(){
	t=read();
	while(t--){
		n=read();
		for(int i=1;i<=n;i++){
			a[i]=read();
			f[i]=0;
			sum[i]=sum[i-1]+a[i];
		}
		f[n+1]=0;
		for(int i=n;i;i--){
			f[i]=a[i];
			for(int j=1;j<=a[i]&&i+j<=n+1;j++){
				f[i]=max(f[i],f[i+j]+(sum[i+j-1]-sum[i]));
			}
		}
		cout<<f[1]<<endl;
	}
}
```
***
## 正解
接下来，我们就要将式子拆开计算。  

令 $x = a_i$， $y=\sum_{j=1}^{a_i} dp_{i+j}+ (sum_{i+j-1}-sum_i))$

先不管 $x$，只在 $y$ 上做优化。

变式：$y=\sum_{j=i+1}^{i+a_i} dp_{j}+ (sum_{j-1}-sum_i))$

将 $sum_i$ 提出来，变为：  
$y=(\sum_{j=i+1}^{i+a_i} dp_{j}+ sum_{j-1})-sum_i$

观察里面那一堆式子，因为那里面的变量只和 $j$ 有关（除限制范围），说明我们可以对 $dp_{j}+ sum_{j-1}$ 用数据结构进行优化。

观察到该优化要用到区间查询与单点修改，因此我们采用线段树。

对于当前的 $i$，我们查一下 $i+1$ 到 $n$ 中的最大值，记录为 $d$。  
修改时将 $i$ 在线段树上对应的线段的值变为 $\max(d-sum_i,x)$。

最后答案查一下1在树上对应的线段的值即可（实际上就是一个单点查询）。
***

## 时间复杂度
遍历一遍为 $O(n)$，线段树查询与修改的时间为 $O(\log n)$。

总时间复杂度：$O(n \log n)$。
***

## 代码
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int t,n;
#define ll long long
const int N=1e5+10;
ll a[N];
ll f[N];
ll sum[N];
inline ll read(){
	ll x=0,op=1;
	char ch=getchar();
	while(!isdigit(ch)&&ch!='-'){
		ch=getchar();
	}
	while(ch=='-'){
		op=-op;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1ll)+(x<<3ll)+(ch^48);
		ch=getchar();
	}
	return x*op;
}
struct tree{
	int l,r;
	ll v;
}tr[N<<2];
void push_up(int u){
	tr[u].v=max(tr[u<<1].v,tr[u<<1|1].v);
}
void build(int u,int l,int r){
	tr[u].l=l,tr[u].r=r;
	if(l==r){
		if(l<=n){
			tr[u].v=sum[l-1];
		}else{
			tr[u].v=0;
		}
		return;
	}
	int mid=(l+r)>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
}
void modify(int u,int x,ll v){
	if(tr[u].l==tr[u].r){
		tr[u].v+=v;
		return;
	}
	int mid=(tr[u].l+tr[u].r)>>1;
	if(x<=mid){
		modify(u<<1,x,v);
	}else{
		modify(u<<1|1,x,v);
	}
	push_up(u);
}
ll query(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r){
		return tr[u].v;
	}
	int mid=(tr[u].l+tr[u].r)>>1;
	ll res=0;
	if(l<=mid){
		res=query(u<<1,l,r);
	}
	if(r>mid){
		res=max(res,query(u<<1|1,l,r));
	}
	return res;
}
ll find(int u,int x){
	if(tr[u].l==tr[u].r){
		return tr[u].v;
	}
	int mid=(tr[u].l+tr[u].r)>>1;
	if(x<=mid){
		return find(u<<1,x);
	}
	return find(u<<1|1,x);
}
int main(){
	t=read();
	while(t--){
		memset(sum,0,sizeof sum);
		n=read();
		for(int i=1;i<=n;i++){
			a[i]=read();
			sum[i]=sum[i-1]+a[i];
		}
		build(1,1,n+1);
		for(int i=n;i;i--){
			ll d=query(1,i+1,min((ll)n+1,i+a[i]));
			d=max(d-sum[i],a[i]);
			modify(1,i,d);
		}
		cout<<find(1,1)<<endl;
	}
}
```

~~其实也不难呀。~~

---

## 作者：xiaoshumiao (赞：2)

考虑 DP。

设 $dp_i$ 代表 $i$ 到 $n$ 可以获得的最多金币数，则：

$$dp_i=\max(a_i,\max\limits_{i+1 \le j \le i+a_i} dp_j+ \sum\limits_{k=i+1}^{i+j-1} a_j)$$

直接暴力转移是 $O(N^2)$ 的，无法通过。

上述转移可以转换为以下操作：

- 查询最大值
- 区间加
- 单点加

不难发现可以用线段树维护，时间复杂度 $O(N \log N)$。

注意：

- 不开 long long 见祖宗。
- 多测不清空，爆零两行泪。

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
const int N=1e5+10; int a[N],dp[N],w[4*N],lzy[4*N];
void pushup(int u) { w[u]=max(w[u*2],w[u*2+1]); }
void pushdown(int u) {
  if(!lzy[u]) return;
  w[u*2]+=lzy[u],lzy[u*2]+=lzy[u];
  w[u*2+1]+=lzy[u],lzy[u*2+1]+=lzy[u];
  lzy[u]=0;
}
int query(int u,int L,int R,int l,int r) {
  if(L>r||R<l) return 0;
  if(l<=L&&R<=r) return w[u];
  int m=(L+R)>>1; return pushdown(u),max(query(u*2,L,m,l,r),query(u*2+1,m+1,R,l,r));
}
void update(int u,int L,int R,int l,int r,int x) {
  if(L>r||R<l) return;
  if(l<=L&&R<=r) return w[u]+=x,lzy[u]+=x,void();
  int m=(L+R)>>1; pushdown(u),update(u*2,L,m,l,r,x),update(u*2+1,m+1,R,l,r,x),pushup(u);
}
void solve() {
  int n; scanf("%lld",&n);
  for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
  memset(w,0,sizeof(w)),memset(lzy,0,sizeof(lzy));
  for(int i=n;i>=1;i--)
    dp[i]=max(a[i],query(1,1,n,i+1,i+a[i])),update(1,1,n,i+1,n,a[i]),update(1,1,n,i,i,dp[i]);
  printf("%lld\n",dp[1]);
}
signed main() {
  int t; scanf("%lld",&t);
  while(t--) solve();
  return 0;
}
```

---

## 作者：Melo_qwq (赞：2)

作为我最喜爱的算法，这道线段树优化 dp 看到了就想写一下。

### 线段树的优势

灵活性高，变式简单，可以比树状数组多很多操作，而且好调，只要挨个检查各个部分就行，千万别忘了 lazytag 的下放（学过平衡树的大佬略过）。

#### 题目大意略。

# 题目实现

不难发现是道 dp，考虑怎么写。

不妨另 $dp_i$ 为区间 $[i,n]$ 的最大金币数，注意，我们这里**默认第 $i$ 号宝箱到第 $n$ 号宝箱是全部开启的。**

状态转移方程很显然：

$$
dp_i=\max(a_i,\max_{j\in[i+1,i+a_i]}(dp_j+\sum_{k=i+1}^{i+j-1}a_k))
$$
然后经过缜密计算可以发现上述转移的复杂度是 $O(n^2)$ 的，所以需要优化。

不难发现：

- 对于任意一个 $[i ,i +a_i](i\in[1,n])$ 的区间，其中每个宝箱的 dp 值一定是这个区间的最大值。

- 当我们来到一个已经被打开的宝箱时，我们一定要拿金币。

- 每更新一个点，他对答案的贡献就会增加 $dp_i$。

咱们把上述说的转化一下语言：

- 对一个区间求最大值。

- 进行一次区间加操作。

- 进行一次单点加操作。

线段树，然后想想怎么写。

不用建树，因为初始全是 $0$。

对于 pushdown 操作，区间最大值和 lazytag 直接加，因为如果我们给这个区间整体加，那么它的最大值一定会相应的增加。

注意从后向前扫，避免用没更新的更新现在的导致后效性。

其他的没了，上代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int N = 1e5 + 7 ;
int maxx[N << 2] ,la[N << 2] ,t ,a[N] ,dp[N] ;
#define ls (cur << 1) 
#define rs (cur << 1 | 1)
#define mem(a) memset ((a) ,0 ,sizeof (a))
namespace shin {
	inline void init () {
		mem (maxx) ;
		mem (la) ;
		mem (a) ;
		mem (dp) ;
	}
	template <typename T> inline void read (T &x) {
		x = 0 ;
		char ch = getchar () ;
		while (ch < '0' or ch > '9') {
			ch = getchar () ;
		}
		while (ch <= '9' and ch >= '0') {
			x = (x << 1) + (x << 3) + (ch ^ 48) ;
			ch = getchar () ;
		}
	}
	inline void pushup (int cur) {
		maxx[cur] = max (maxx[ls] ,maxx[rs]) ;
	}
	inline void pushdown (int cur ,int l ,int r) {
		if (! la[cur]) return ;
		maxx[ls] += la[cur] ;
		maxx[rs] += la[cur] ;
		la[ls] += la[cur] ;
		la[rs] += la[cur] ;
		la[cur] = 0 ;
	}
	inline void modify (int l ,int r ,int nowl ,int nowr ,int add ,int cur) {
		if (nowl > nowr) return ; 
		if (nowl <= l and nowr >= r) {
			maxx[cur] += add ;
			la[cur] += add ;
			return ; 
		}
		shin :: pushdown (cur ,l ,r) ;
		int mid = l + r >> 1 ;
		if (nowl <= mid) shin :: modify (l ,mid ,nowl ,nowr ,add ,ls) ;
		if (nowr > mid) shin :: modify (mid + 1 ,r ,nowl ,nowr ,add ,rs) ;
		shin :: pushup (cur) ;
	}
	inline int query (int l ,int r ,int nowl ,int nowr ,int cur) {
		if (nowl <= l and nowr >= r) {
			return maxx[cur] ;
		}
		shin :: pushdown (cur ,l ,r) ;
		int ans = INT_MIN ;
		int mid = l + r >> 1 ;
		if (nowl <= mid) ans = max (ans ,shin :: query (l ,mid ,nowl ,nowr ,ls)) ;
		if (nowr > mid) ans = max (ans ,shin :: query (mid + 1 ,r ,nowl ,nowr ,rs)) ;
		return ans ;
	}
}
signed main () {
	shin :: read (t) ;
	while (t --) {
		int n ;
		shin :: init () ;
		shin :: read (n) ;
		rep (i ,1 ,n ,1) {
			shin :: read (a[i]) ;
		}
		for (int i = n ;i ;i --) {
			dp[i] = a[i] ;
			int l = i + 1 ,r = min (i + a[i] ,n) ;
			dp[i] = max (dp[i] ,shin :: query (1 ,n ,l ,r ,1)) ;
			shin :: modify (1 ,n ,l ,n ,a[i] ,1) ;
			shin :: modify (1 ,n ,i ,i ,dp[i] ,1) ;
		}
		cout << dp[1] << '\n' ;
	}
	return 0 ;
}
//kafka & かみや
```

###### 你是否承认卡芙卡和狼谷的美貌举世无双？

---

## 作者：small_john (赞：2)

## 思路

简单题。

我们设 $f_i$ 表示解锁前 $i$ 个关卡的最小代价（定义代价为用没获得金币的关卡的金币数量之和），以及 $s_i=\displaystyle\sum _{j=1}^i a_i$。那么最后的答案即为 $\displaystyle\max_{i=1}^{n} s_i-f_i$。

$s$ 前缀和即可 $O(n)$ 求出，问题在于如何求 $f$。

有转移：$f_i=\displaystyle\min_{j+a_j\ge i\wedge j<i} f_j+a_j$，但是这样的时间复杂度是 $O(n^2)$ 的，考虑优化。

发现如果我们在 $a_i+i$ 的位置加入 $f_i+a_i$ 的话，那么问题就变成了后缀取最小值，很明显能用树状数组来维护。

时间复杂度 $O(n\log n)$，足以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;

template<typename T> inline void read(T &x)
{
	x = 0;
	T f = 1;char ch = getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f = -1,ch = getchar();
			break;
		}
		ch = getchar();
	}
	while(ch>='0'&&ch<='9')
		x = (x<<3)+(x<<1)+ch-48,ch = getchar();
	x*=f;
}
template<typename T = int> inline T read()
{
	T x;read(x);return x;
}
template<typename T> void write(T x)
{
    if(x<0) x = -x,putchar('-');
    if(x>9) write(x/10);
    putchar(x%10+48);
}
template<typename T> inline void writen(T x)
{
    write(x);
    putchar(10);
}
const int N = 1e5+5;
int n,a[N],l[N],t[N];
#define lowbit(x) (x&(-x))
inline void add(int x,int v)
{
	for(;x;x-=lowbit(x))
		t[x] = min(t[x],v);
}
inline int ask(int x)
{
	int res = 2e18;
	for(;x<=n;x+=lowbit(x))
		res = min(res,t[x]);
	return res;
}
#undef lowbit
inline void solve()
{
	read(n);
	for(int i = 1;i<=n;i++)
		read(a[i]),t[i] = 2e18;
	add(min(n,a[1]+1),a[1]);
	int ans = a[1];
	for(int i = 2,sum = a[1];i<=n;i++)
	{
		sum+=a[i];
		int w = ask(i);
//		cout<<w<<' ';
		ans = max(ans,sum-w);
		add(min(n,a[i]+i),w+a[i]);
	}
	writen(ans);
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int T;read(T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：Sun_pirf (赞：2)

## [P10381 「HOI R1」杂赛选比](https://www.luogu.com.cn/problem/P10381)


## 思路

显然，此题为一道 DP 题。  

设 $dp_{i}$ 为从 $i$ 至 $n$ 的最大金币数量，得转移方程：

$$
dp_{i}= \max(a_{i},\max_{1\le j \le a_{i} }dp_{i+j}+\sum_{k=1}^{j-1}a_{i+k}  )
$$

时间复杂度太高，为 $O(n^2)$ ，考虑优化。  

不难发现，可每次转移可转化为： 

- 区间查询最大值

- 区间加

- 单点加 

故而采用线段树优化（带懒标记 lazy_tag ），时间复杂度 $O(n\log n)$ 。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lid (id<<1)
#define rid (id<<1|1)
#define int long long
int t,n,a[100005],dp[100005];
struct seg_tree{
	int l,r,val,lazy_tag;
}tr[400005];//四倍空间
void update(int id,int val)
{
	tr[id].val+=val;
	tr[id].lazy_tag+=val;
}

void pushup(int id)
{
	tr[id].val=max(tr[lid].val,tr[rid].val);
}

void pushdown(int id)
{
	if(!tr[id].lazy_tag)
		return ;
	update(lid,tr[id].lazy_tag);
	update(rid,tr[id].lazy_tag);
	tr[id].lazy_tag=0;
}

void build(int id,int l,int r)
{
	tr[id].l=l;
	tr[id].r=r;
	tr[id].lazy_tag=tr[id].val=0;
	if(l>=r)
		return ;
	int mid=(l+r)>>1;
	build(lid,l,mid);
	build(rid,mid+1,r);
}

void modify(int id,int l,int r,int val)
{
	if(l>r)
		return ;
	if(tr[id].l>=l&&tr[id].r<=r)
		return update(id,val);
	pushdown(id);
	int mid=(tr[id].l+tr[id].r)>>1;
	if(l<=mid)
		modify(lid,l,r,val);
	if(r>mid)
		modify(rid,l,r,val);
	pushup(id);
}

int query(int id,int l,int r)
{
	if(l>r)
		return 0;
	if(tr[id].l>=l&&tr[id].r<=r)
		return tr[id].val;
	pushdown(id);
	int ans=0;
	int mid=(tr[id].l+tr[id].r)>>1;
	if(l<=mid)
		ans=max(ans,query(lid,l,r));
	if(r>mid)
		ans=max(ans,query(rid,l,r));
	return ans;
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);  cout.tie(0);
    cin>>t;
    for(int j=1;j<=t;j++)
    {
    	cin>>n;
    	build(1,1,n);
    	for(int i=1;i<=n;i++)
    		cin>>a[i];
    	for(int i=n;i;i--)
    	{
    		dp[i]=a[i];
    		int l=i+1;
    		int r=min(i+a[i],n);
    		dp[i]=max(dp[i],query(1,l,r));
    		modify(1,l,n,a[i]);
    		modify(1,i,i,dp[i]);
		}
		cout<<dp[1]<<"\n";
	}
	return 0;
}

```  

Thanks For Watching.

---

## 作者：The_Elation_Aha (赞：2)

只会做绿题的彩笔，已经生存不下去了。

------------

这是个简单的 dp 题，也不需要线段树啥的，一个优先队列而已。

$O(n^2)$ 做法很容易想到，我们设 $dp_i$ 为使 $i$ 位置解锁的最小代价，$sum_i$ 为 $a_i$ 的前缀和，答案就是 $\max_{1\le i\le n}\{sum_i-dp_i\}$。

转移：$dp_i=\min(dp_i,dp_j+a_j)$，$j$ 满足 $1\le j<i, j+a_j\ge i$，直接 $O(n^2)$ 枚举即可。注意如果某个点无法解锁，那么后面的所有点都无法解锁，直接退出循环。

然后考虑优化，由于 $dp_j+a_j$ 和 $j+a_j$ 是固定的，那么有一个显然的贪心策略：将上一个转移过来的 $j$ 记为 $las$，如果这一次仍然 $las+a_{las}\ge i$，那么就转移，否则再找新的更优的点。

这个过程可以用一个优先队列维护，我们让这个优先队列维护 pair 类型，每个 pair 为 $(dp_i+a_i,i+a_i)$ 表示这个点转移过来的代价和它能解锁的最远的点。这样我们每次转移时先不断弹出解锁不到当前的 $i$ 的点，然后直接从 top 处转移就行了。注意这里队列被清空了就代表无法解锁 $i$，退出循环。

复杂度 $O(n\log n)$，不知道 $O(n\alpha(n))$ 是什么神秘方法。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mk make_pair
const ll N=114514,M=1919810,inf=1e18;
ll T;
ll n,a[N],sum[N],ans,dp[N]; //为了解锁i而失去的最小金币数
typedef pair<ll,ll> pi;
void solve(){
	cin>>n;
	ans=0;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		dp[i]=inf;
	}
	dp[1]=0,ans=a[1];
	priority_queue<pi,vector<pi>,greater<pi> > q;
	q.push(mk(dp[1]+a[1],1+a[1]));
	for(int i=2;i<=n;++i){
		while(q.top().second<i&&!q.empty()) q.pop();
		if(q.empty()) break;
		dp[i]=q.top().first;
		q.push(mk(dp[i]+a[i],i+a[i]));
		ans=max(ans,sum[i]-dp[i]);
	}
	cout<<ans<<'\n';
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>T;
	while(T--) solve();
	return 0;
}
```

不知道为啥通过率不高。

---

## 作者：Coffee_zzz (赞：1)

定义 $dp_i$ 表示从 $a_i$ 开始选择所能获得的最大金币数量。初始化 $dp_{n+1}=0$。

根据定义，考虑选不选 $a_i$ 以及选完 $a_i$ 选谁，容易得到转移方程：
$$
dp_i=\max\left(a_i,\max_{j=i+1}^{\min(a_i+i,n+1)} dp_{j}+\sum_{k=i+1}^{j-1} a_k \right)
$$
令 $s_i=\sum\limits_{j=1}^{i-1} a_i$，则转移方程可以化为：
$$
dp_i=\max\left(a_i,\max_{j=i+1}^{\min(a_i+i,n+1)} dp_j+s_j-s_{i+1} \right)
$$
把 $-s_{i+1}$ 提出得到：
$$
dp_i=\max\left(a_i,-s_{i+1}+\max_{j=i+1}^{\min(a_i+i,n+1)} dp_j+s_j \right)
$$
令 $v_i=dp_i+s_i$ 可得：
$$
dp_i=\max\left(a_i,-s_{i+1}+\max_{j=i+1}^{\min(a_i+i,n+1)} v_j \right)
$$
于是把 $v$ 放在线段树上维护，从 $n$ 到 $1$ 依次求 $dp_i$ 的值，每次进行区间查询 $\max$，单点修改即可。

答案即为 $dp_1$。

---

## 作者：_O_v_O_ (赞：1)

考虑 dp。

首先，先推出 $O(n^2)$ 的 dp 式子：

设 $dp_i$ 为解锁 $i$ 时的最小代价。

假设已经求出了一个 $dp_i$，那么可以对于 $\forall i+1\le j\le i+a_i$ 的每个 $j$，$dp_j\leftarrow \max(dp_j,dp_i+\sum\limits_{k=i+1}^{j-1} a_i)$，用前缀和可简化为 $\max(dp_j,dp_i+s_{j-1}-s_i)$。

注意到每次转化都会有一个 $+s_{j-1}$，所以提出来，变成 $\max(dp_j,dp_i-s_i)+s_{j-1}$。

所以 $dp_j$ 的求法就变成了 $\max\limits_{\text{所有可转移的} i}\{dp_i-s_i\}+s_{j-1}$。

我们不妨在每次求出 $dp_i$ 后就直接把能转移到的全部转移一遍。

那么我们需要维护一个数据结构，能动态将所有 $\forall l\le i\le r$ 的所有 $i$ 变为 $\max(a_i,x)$ 且能单点查询。

用线段树即可。

---

## 作者：xxseven (赞：0)

提供一种正推 DP，单点修线段树优化的方法。

设 $dp_i$ 为只考虑前 $i$ 个数，**强制使用**第 $i$ 个数来解锁的最大金币数。初值为 $dp_0=0$。统计答案时取最大的 $dp_i + a_i$ 即可。

先考虑暴力转移，枚举上一个用于解锁的位置，如果能解锁到当前位置那么可以转移。

有转移方程：

$$ dp_i = \max_{j \lt i \le j+a_j} dp_j+(s_{i-1}-s_j)$$

其中 $s$ 为 $a$ 的前缀和数组。

发现式子可以拆成 $dp_j - s_j$ 和 $s_{i-1}$ 两个部分，我们让线段树维护前一部分的最大值。

为了满足 $i \le j+a_j$ 的限制，我们以 $j+a_j$ 作为下标，$dp_j-s_j$ 作为值存入线段树中，只需实现单点取 $\max$ 区间求最大值即可。

时间复杂度 $O(Tn\log (\max\{i+a_i\}))$。

下面是代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+6;
typedef long long i64;
int n,a[N];
i64 s[N],dp[N],t[N<<4];
#define mid (L+R>>1)
void build(int pos,int L,int R){
	t[pos]=-1e18;
	if(L==R) return;
	build(pos<<1,L,mid); build(pos<<1|1,mid+1,R);
}
void upd(int pos,int L,int R,int x,i64 k){
	if(L==R) return t[pos]=max(t[pos],k),void();
	if(x<=mid) upd(pos<<1,L,mid,x,k);
	else upd(pos<<1|1,mid+1,R,x,k);
	t[pos]=max(t[pos<<1],t[pos<<1|1]);
}
i64 qry(int pos,int L,int R,int x,int y){
	if(x>R||y<L) return -1e18;
	if(x<=L&&R<=y) return t[pos];
	return max(qry(pos<<1,L,mid,x,y),qry(pos<<1|1,mid+1,R,x,y));
}
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	int T; cin>>T; a[0]=1;
	while(T--){
		cin>>n; int mx=0;
		for(int i=1;i<=n;++i){
			cin>>a[i];
			s[i]=s[i-1]+a[i];
			mx=max(mx,i+a[i]);
		}
		build(1,1,mx);
		upd(1,1,mx,1,0);
		i64 ans=0;
		for(int i=1;i<=n;++i){
			dp[i]=qry(1,1,mx,i,mx)+s[i-1];
			upd(1,1,mx,i+a[i],dp[i]-s[i]);
			ans=max(ans,dp[i]+a[i]);
		}
		cout<<ans<<'\n';
	}
	return 0;
}

```

希望这篇题解能够帮到你！

---

## 作者：Sving1024 (赞：0)

考虑动态规划。令 $dp_i$ 为前 $0\sim i-1$ 个数的最优解。   
显然有状态转移方程   
$$dp_i=\mathop{\max}\limits_{j+a_j>=i}\{dp_j+\sum_{k=j+1}^{i-1}a_k\}$$   
意义是枚举 $0\sim i-1$ 中可以解锁到 $i$ 的下标 $j$ ，用 $dp_j$ 和 $a_{j+1\sim i+1}$ 的和来更新 $dp_i$（$a_j$ 要被用来解锁格子，不能获得金币） 。显然时间复杂度是 $\operatorname{O}(n^2)$。考虑优化。

注意到每个 $dp_j$ 最后可以更新的数就到 $dp_{j+a_j}$，将 $j+a_j$ 记作 $e_j$。令 $v_j=dp_j-\sum_{k=0}^{j}a_k$，在更新 $dp_i$ 时，有   
$$\begin{aligned} v_j+\sum_{k=0}^{i-1}a_k &= dp_j-\sum_{k=0}^{j}a_k+\sum_{k=0}^{i-1}a_k\\ &=dp_j+\sum_{k=j+1}^{i-1}a_k\end{aligned}$$   
将$(e_i,v_j)$ 塞进一个 $e_j$ 单调递增，$v_j$ 也单调递增的单调队列里就可以 $\operatorname{O}(1)$ 实现转移。需要注意的是随着 $j$ 的增加，$e_j$ 不一定增加，需要在队列中找到一个位置 $k$，使 $e_k\le e_j$，在 $k$ 处进行更新。这个操作实际上就是在求前驱。由于需要求前驱，插入和删除，可以考虑用平衡树（即 `std::set`）进行维护，复杂度 $\operatorname{O}(n\log n)$。（不过暴力维护此题也可以通过，建议加强数据）

AC Code:   
```cpp
#ifdef BF
//暴力做法
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

typedef long long ll;
ll dp[(int)1e5+5],arr[(int)1e5+5],n,t;

struct node{
    ll val;
    ll expire;
};

int main(){
    cin>>t;
    while(t--){
        memset(dp,-0x3f,sizeof dp);
        vector<node> v;
        cin>>n;
        for(ll i=0;i<(ll)n;i++){
            cin>>arr[i];
        }
        dp[0]=0;
        ll sum=arr[0];
        v.push_back({0-sum,arr[0]});
        for(ll i=1;i<(ll)n;i++){
            while(!v.empty()&&(ll)v[0].expire<i){
                v.erase(v.begin());
            }
            if(v.empty())break;
            dp[i]=v[0].val+sum;
            sum+=arr[i];
            for(ll j=(ll)(v.size()-1);j>=0;j--){
                if(v[j].expire<=i+arr[i]&&v[j].val<dp[i]-sum){
                    v.erase(v.begin()+j);
                }
                if(v[j].val>dp[i]-sum){
                    v.insert(v.begin()+j+1,{dp[i]-sum,i+arr[i]});
                    break;
                }
            }
        }
        ll ans=0;
        for(ll i=0;i<(ll)n;i++){
            ans=max(ans,dp[i]+arr[i]);
        }
        cout<<ans<<endl;
    }
    return 0;
}
#endif
//平衡树做法
#include <iostream>
#include <vector>
#include <cstring>
#include <set>
using namespace std;

typedef long long ll;
ll dp[(int)1e5+5],arr[(int)1e5+5],n,t;

struct node{
    ll val;
    ll expire;
    node(){
        val=expire=0;
    }
    node(const ll& _val,const ll& _exp){
        val=_val;
        expire=_exp;
    }
    bool operator<(const node& a)const{
        return expire>a.expire;
    }
};

int main(){
    cin>>t;
    while(t--){
        memset(dp,-0x3f,sizeof dp);
        set<node> v;
        cin>>n;
        for(ll i=0;i<(ll)n;i++){
            cin>>arr[i];
        }
        dp[0]=0;
        ll sum=arr[0];
        v.insert(node(0-sum,arr[0]));
        for(ll i=1;i<(ll)n;i++){
            while(!v.empty()&&(ll)((--v.end())->expire)<i){
                v.erase(--v.end());
            }
            if(v.empty())break;
            dp[i]=(--v.end())->val+sum;
            sum+=arr[i];
            auto it=v.lower_bound({0,i+arr[i]});
            node ins=node(dp[i]-sum,arr[i]+i);
            while(!v.empty()&&it!=v.end()&&it->val<=ins.val){
                v.erase(it);
                it=v.lower_bound({0,i+arr[i]});
            }
            auto prev_it=it;
            if(it!=v.begin())it--;
            if((prev_it==v.end()||(prev_it!=v.end()&&prev_it->expire<ins.expire))&&(prev_it==v.begin()||it->val<ins.val))v.insert(ins);
        }
        ll ans=0;
        for(ll i=0;i<(ll)n;i++){
            ans=max(ans,dp[i]+arr[i]);
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：Exp10re (赞：0)

## 解题思路

很显然的动态规划。

考虑 $f_i$ 表示第 $i$ 位及之前一定被解锁所**消耗**的最少金币数量，这里我们假定在所有位置都选择金币的情况下选择解锁**消耗**了等量金币。

则显然的转移方程：

$$f_i+a_i \rightarrow f_j,j\in[i+1,\min(n,i+a_i)]$$

那么我们就需要实现以下操作：

- 区间取 $\min$。
- 后继查询 $\min$。

两种实现形式：要么直接维护多重集，每一次修改 $f_{i+a_i}$ 的值，查询在多重集中查询最小值，查询完毕后移除 $f_i$ 即可。要么就是很显然的线段树维护，乱搞即可。

赛时时间不太够，所以用了前者。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=101000,INF=1e10+7;
long long b[MAXN],n,val[MAXN],sum,rc[MAXN],maxn;
multiset<long long> mt;
void rep(long long x,long long nval)
{
	if(nval<b[x])
	{
		mt.erase(mt.find(b[x]));
		b[x]=nval;
		mt.insert(b[x]);
	}
	return;
}
void work()
{
	long long i,j,minn,cost,p;
	mt.clear();
	scanf("%lld",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&val[i]);
		sum=val[i];
	}
	for(i=1;i<=n;i++)
	{
		b[i]=INF;
		mt.insert(b[i]);
	}
	rep(1,0);
	for(i=1;i<=n;i++)
	{
		cost=*mt.lower_bound(0);
		rc[i]=cost;
		p=min(n,i+val[i]);
		rep(p,cost+val[i]);
		mt.erase(mt.find(b[i]));
	}
	sum=0;
	maxn=0;
	for(i=1;i<=n;i++)
	{
		sum+=val[i];
		maxn=max(maxn,sum-rc[i]);
	}
	printf("%lld\n",maxn);
	return;
}
int main()
{
	long long T;
	scanf("%lld",&T);
	while(T--)
	{
		work();
	}
	return 0;
}
```

---

## 作者：yshpdyt (赞：0)

## 题意
>我们保证所有题目的描述都是尽可能详细而简短的，出题人也是讨厌超长题面的选手！

所以略。

## Sol

~动~态~规~划~。

考虑暴力的 dp，令 $f_i$ 表示 $i$ 位置用于解锁 $[i+1,i+a_i]$ 位置时前 $i$ 个位置的最大金币数量，令 $sum_i $ 表示前缀和数组，枚举可以解锁当且位置的位置，然后加上他们之间的金币和即可。

$$f_i=\max\limits_{a_j+j\ge i} \left( f_j+sum_{i-1}-sum_j \right)$$
答案就是：
$$res=\max\limits_{i=1}^n \left(f_i+a_i\right)$$

相当于强行使 $i$ 位置不解锁后面的。

考虑优化，类似扫描线的思想，注意到 $i$ 位置的贡献只在 $[i+1,i+a_i]$ 位置有效，不妨假设一个备选序列，在 $i$ 位置处理完时将 $f_i-sum_i$ 作为一种可能的备选方案加入序列，然后在 $i+a_i+1$ 开始时移除。

那么接下来就是考虑用数据结构如何维护了，这里使用线段树，可以把前缀和数组省去。初始化每个结点为 $0$，先不考虑移除，假设所有点可以转移过来。

维护一个区间加，区间查询最大值的线段树，如果当且位于 $i$ 位置，线段树维护的就是 $\left( f_j+sum_{i-1}-sum_j \right)$ 这个东西的最大值。
 
查询时，就是查询 $[1,i-1]$ 位置的最大值。

增加贡献，每次在 $[i,i]$ 位置加上 $f_i$，在 $[1,i-1]$ 位置加上 $a_i$ 就可以实现以上操作。

然后考虑怎么移除，注意到如果如果 $j$ 无法解锁 $i$ 位置，那么 $[i+1,n]$  的位置也无法解锁，我们查询的是 $[1,i-1]$  的最大值，只要当 $j$ 不成为最大值即可，暴力增加一个 `-inf`，就不会成为候选答案了。

还需要注意一下，我们需要维护最多可以解锁到的位置，防止有的位置没法解锁但是却加入了候选队列。

时间复杂度 $O(n\log n)$。


## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 400005
#define endl "\n" 
#define fi first
#define se second
using namespace std;
const ll mod=1e9+7;
const ll inf=1e18;
const double eps=1e-6;
ll n,a[N],f[N],sum[N];
struct sgt{
    #define mid ((l+r)>>1)
    #define ls (p<<1)
    #define rs (p<<1|1)
    ll mx[N],lzy[N];
    void lt(ll p,ll x){
        mx[p]+=x;
        lzy[p]+=x;
    }
    void build(ll p,ll l,ll r){
        mx[p]=lzy[p]=0;
        if(l==r){
            mx[p]=0;
            return ;
        }
        build(ls,l,mid);
        build(rs,mid+1,r);
        mx[p]=max(mx[ls],mx[rs]);
    }
    void pushdown(ll p){
        lt(ls,lzy[p]);
        lt(rs,lzy[p]);
        lzy[p]=0;
    }
    void upd(ll p,ll l,ll r,ll le,ll ri,ll t){
        if(le<=l&&ri>=r){
            lt(p,t);
            return ;
        }
        pushdown(p);
        if(le<=mid)upd(ls,l,mid,le,ri,t);
        if(ri>mid)upd(rs,mid+1,r,le,ri,t);
        mx[p]=max(mx[ls],mx[rs]);
    }
    ll qr(ll p,ll l,ll r,ll le,ll ri){
        if(le<=l&&ri>=r)return mx[p];
        pushdown(p);
        ll ans=-inf;
        if(le<=mid)ans=max(ans,qr(ls,l,mid,le,ri));
        if(ri>mid)ans=max(ans,qr(rs,mid+1,r,le,ri));
        return ans;
    }
}T;
vector<ll>v[N];
void sol(){
    cin>>n;
    for(int i=1;i<=n;i++){
        v[i].clear();
        cin>>a[i];
    }
    T.build(1,1,n);
    ll res=a[1];
    v[1+1+a[1]].push_back(1);
    ll mx=1+a[1];
    for(int i=2;i<=n;i++){
        if(mx<i)break;
        if(i+1+a[i]<=n)v[i+1+a[i]].push_back(i);
        for(auto j:v[i])T.upd(1,1,n,j,j,-inf);
        f[i]=T.qr(1,1,n,1,i-1);
        T.upd(1,1,n,1,i-1,a[i]);
        T.upd(1,1,n,i,i,f[i]);
        res=max(res,f[i]+a[i]);
        mx=max(mx,i+a[i]);
    }
    cout<<res<<endl;
}
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    ll ttt;
    cin>>ttt;
    while(ttt--)sol();
    return 0;
}
```

---

## 作者：Cure_Wing (赞：0)

[P10381 「HOI R1」杂赛选比](https://www.luogu.com.cn/problem/P10381)

来一个与官方题解不一样的思路。

### 思路

我们不倒着考虑，正向想这个问题。假设第 $i$ 关可以被解锁，那么第 $1\sim i$ 的 $a_i$ 都可以转化为金币，它们的总和减去用来解锁的 $a_i$ 的金币数之和就是走到 $i$ 可以获得的最大金币数。

于是设 $s_i$ 表示 $1\sim i$ 在都可以转化为金币的情况下的金币总和，即 $s_i=\sum\limits_{j=1}^ia_j$。再令 $f_i$ 表示成功解锁第 $i$ 关时至少需要多少金币用来解锁。初始 $f_1=0,f_{2\sim n}=+\infty$。

对于第 $i$ 关，如果选择用来解锁，那么第 $i+1\sim i+a_i$ 关的最小解锁金币就是 $f_i+a_i$。但如果第 $j(i+1\le j\le i+a_i)$ 关先前已经有一种解锁方案，其代价是 $f_j$，显然最终的选择方案是二者代价的最小值。如果不解锁，那么什么也不用做，因为 $s_i$ 考虑的就是不做的情况。

最终的答案显而易见，即 $\max\limits_{i=1}^ns_i-f_i$，即理论可得金币减去解锁必要的金币。

唯一需要运用的数据结构是线段树，用来给 $[i+1,i+a_i]$ 的区间的 $f_j$ 对定值 $f_i+a_i$ 取最小值，还有查询 $f_i$ 的值。这个很好操作，直接把区间要取的最小值放到区间对应的节点上，查询更新时下传标记即可。

时间复杂度 $O(Tn\log_2n)$，没有悬念的伐。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using std::cin;using std::cout;
constexpr int N=100005,M=400005;
constexpr long long inf=1e18;
int t,n,a[N];
long long ans,s[N];
struct SegmentTree{//线段树
	#define ls (p<<1)
	#define rs (p<<1|1)
	#define mid ((l+r)>>1)
	long long f[M];
	inline void pushdown(int p){f[ls]=std::min(f[ls],f[p]);f[rs]=std::min(f[rs],f[p]);}
	inline void build(int l,int r,int p){f[p]=inf;if(l==r) return ;build(l,mid,ls);build(mid+1,r,rs);}
	inline void update(int l,int r,int x,int y,int p,long long k){//更新
		if(x>y) return ;if(x<=l&&r<=y){f[p]=std::min(f[p],k);return ;}pushdown(p);
		if(x<=mid) update(l,mid,x,y,ls,k);if(mid<y) update(mid+1,r,x,y,rs,k);
	}
	inline long long query(int l,int r,int x,int p){//查询
		if(l==r) return f[p];pushdown(p);
		if(x<=mid) return query(l,mid,x,ls);return query(mid+1,r,x,rs);
	}
}seg;
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	for(cin>>t;t--;cout<<ans<<'\n'){
		cin>>n;ans=0;for(int i=1;i<=n;++i){cin>>a[i];s[i]=a[i]+s[i-1];}//计算s[i]
		seg.build(1,n,1);seg.update(1,n,1,1,1,0);
		for(int i=1;i<=n;++i) seg.update(1,n,i+1,std::min(i+a[i],n),1,seg.query(1,n,i,1)+a[i]);//查询f[i]并往后更新最优答案
		for(int i=1;i<=n;++i) ans=std::max(ans,s[i]-seg.query(1,n,i,1));//计算ans
	}
	return 0;
}
```

---


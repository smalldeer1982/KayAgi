# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# 题解

## 作者：假装思考 (赞：739)

**解题报告**

初见这道题，首先想到的方法当然是直接模拟，模拟每一次指令。当然这种方法对于小数据行得通，但对于此题的500,000个指令，肯定超时。

因此我们就要想其它方法。

先来分析一下这些指令的特点，很容易发现对于每个M指令，只可能一次移动整个队列，并且是把两个队列首尾相接合并成一个队列，不会出现把一个队列分开的情况，因此，我们必须要找到一个可以一次操作合并两个队列的方法。

再来看下C指令：判断飞船i和飞船j是否在同一列，若在，则输出它们中间隔了多少艘飞船。我们先只看判断是否在同一列，由于每列一开始都只有一艘飞船，之后开始合并，结合刚刚分析过的M指令，很容易就想到要用并查集来实现。

定义一个数组fa，fa[i]表示飞船i的祖先节点，即其所在列的队头。再定义一个用于查找飞船祖先的函数find，在每次递归找祖先的同时更新fa，压缩路径，大大减小以后的时间消耗。初始时对于每个fa[i]都赋值为i，合并时就先分别查找飞船i和飞船j的祖先，然后将飞船i的祖先的祖先（即fa[飞船i的祖先]）赋值为飞船j的祖先。最后每次判断时只需要找到飞船i和飞船j的祖先，判断是否是同一艘飞船，若是，则在同一列，反之，则不在。

现在，判断是否在同一列以及如何一次操作合并两个队列的问题已经解决，但还有问题需要解决：如何在以上方法的基础上，进一步得到两艘飞船之间的飞船数量呢？

我们先来分析一下：两艘飞船之间的飞船数量，其实就是艘飞船之间的距离，那么，这就转换为了一个求距离的问题。两艘飞船都是在队列里的，最简单的求距离的方法就是前后一个一个查找，但这个方法太低效，会超时。看见多次求两个点的距离的问题，便想到用前缀和来实现：开一个front数组，front[i]表示飞船i到其所在队列队头的距离，然后飞船i和飞船j之间的飞船数量即为它们到队头的距离之差减一，就是abs(front[i]-front[j])-1。

解决了如何高效得到两艘飞船之间飞船数量的问题，便又发现了新的问题：如何在之前方法的基础上，得到每艘飞船和队头的距离呢？

来分析一下现在已经使用的算法——并查集，它的特点就是不是直接把一个队列里的所有飞船移到另一个队列后面，而是通过将要移动的队列的队头连接到另一个队列的队头上，从而间接连接两个队列。因此，我们在这个算法的基础上，每次只能更新一列中一艘飞船到队头的距离（如果更新多艘的话并查集就没有意义了）。

那么，该更新哪艘飞船呢？现在我们已经知道，使用并查集合并两个队列时只改变队头的祖先，而这个队列里其它飞船的祖先还是它原来的队头，并没有更新，所以这个队列里的其它飞船在队列合并之后，仍然可以找到它原来的队头，也就可以使用它原来队头的数据，因此，在每次合并的时候，只要更新合并前队头到目前队头的距离就可以了，之后其它的就可以利用它来算出自己到队头的距离。

理清了思路，但又有问题出现：该怎样更新呢？该怎么计算呢？

更新很容易，我们来分析一下：对于原来的队头，它到队头的距离为0，当将它所在的队列移到另一个队列后面时，它到队头的距离就是排在它前面的飞船数，也就是合并前另一个队列的飞船数量。因此，就知道该怎样实现了，我们再建一个数组num，num[i]表示以i为队头的队列的飞船数量，初始时都是1，在每次合并的时候，fx为合并前飞船i的队头，fy为合并前飞船j的队头，每次合并时，先更新front[fx]，即给它加上num[fy]，然后开始合并，即fa[fx]=fy，最后更新num， num[fy]+= num[fx];num[fx]=0。

现在就差最后一步了：如何计算每个飞船到队头的距离。再来分析一下：对于任意一个飞船，我们都知道它的祖先（不一定是队头，但一定间接或直接指向队头），还知道距离它祖先的距离。对于每一个飞船，它到队头的距离，就等于它到它祖先的距离加上它祖先到队头的距离，而它的祖先到队头的距离，也可以变成类似的。可以递归实现，由于每一次更新都要用到已经更新完成的祖先到队头的距离，所以要先递归找到队头，然后在回溯的时候更新（front[i]+=front[fa[i]]），可以把这个过程和查找队头的函数放在一起。







源代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[30001],front[30001],num[30001],x,y,i,j,n,T,ans;    //fa[i]表示飞船i的祖先
//front[i]表示飞船i与其所在列队头的距离
                                        //num[i]表示第i列的飞船数量 
char ins;
int find(int n){                                        //查找祖先的函数 
    if(fa[n]==n)return fa[n];
    int fn=find(fa[n]);                                    //先递归找到祖先 
    front[n]+=front[fa[n]];    //在回溯的时候更新front（因为更新时要用到正确的front[祖先]，
                                    //所以只能在回溯的时候更新） 
    return fa[n]=fn;
}
int main(){
    cin>>T;
    for(i=1;i<=30000;++i){                                //定初值 
        fa[i]=i;
        front[i]=0;
        num[i]=1;
    }
    while(T--){
        cin>>ins>>x>>y;
        int fx=find(x);                                    //fx为x所在列的队头 
        int fy=find(y);                                    //fy同上 
        if(ins=='M'){
            front[fx]+=num[fy];        //更新front[x所在列队头(现在在y所在队列后面)]
//即加上y所在队列的长度 
            fa[fx]=fy;                                    //将fy设为fx的祖先 
            num[fy]+=num[fx];                            //更新以fy为队头队列的长度 
            num[fx]=0;                        //以fx为队头的队列已不存在，更新 
        }
        if(ins=='C'){
            if(fx!=fy)cout<<"-1"<<endl;            //若x和y的祖先不相同，则不在同一列 
else cout<<abs(front[x]-front[y])-1<<endl;    //否则利用x和y离队头的距离算
//出它们的距离 
        }
    }
    return 0;
}
```







测评结果

Accepted

#    状态                       耗时                       内存占用

#1     Accepted                   3ms                       748.0KiB

#2     Accepted                   1ms                       640.0KiB

#3     Accepted                   5ms                       744.0KiB

#4     Accepted                   14ms                       708.0KiB

#5     Accepted                   53ms                       640.0KiB

#6     Accepted                   108ms                       640.0KiB

#7     Accepted                   224ms                       640.0KiB

#8     Accepted                   228ms                       640.0KiB

#9     Accepted                   521ms                       720.0KiB

#10     Accepted                   610ms                       756.0KiB



---

## 作者：破壁人 (赞：190)

带权并查集（根搭积木很像）：

对于每个点，分别记录所属链的头结点、该点到头结点的距离以及它所在集合的大小。

每次合并将y接在x的尾部，改变y头的权值和所属链的头结点，同时改变x的尾节点。

注意：每次查找的时候也要维护每个节点的权值。

每次查询时计算两点的权值差。






```cpp
#include<iostream>
#include<cmath>
using namespace std;
int f[30001],s[30001],b[30001];
int find(int o)//查找
{
    if(f[o]==o) return o;
    int k=f[o];
    f[o]=find(f[o]);//路径压缩
    s[o]+=s[k];//更新当前节点到根的距离
    b[o]=b[f[o]];//更新所在集合大小
    return f[o];
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=30000;i++) {f[i]=i;s[i]=0;b[i]=1;}
    for(int i=1;i<=n;i++)
    {
        char ch;
        int x,y,dx,dy;
        cin>>ch>>x>>y;
        if(ch=='M')
        {
            dx=find(x);//查找x的根
            dy=find(y);//查找y的根
            f[dx]=dy;//把x放在y后面
            s[dx]+=b[dy];//更新x的根到新的根的距离
            b[dx]+=b[dy];//更新集合大小
            b[dy]=b[dx];//更新集合大小
        }
        if(ch=='C')
        {
            dx=find(x);
            dy=find(y);
            if(dx!=dy){cout<<-1<<endl;continue;}//不在同一个集合中
            cout<<abs(s[x]-s[y])-1<<endl;//中间战舰的数量等于x到根的距离减y到根的距离减一。
        }
    }
    return 0;
}
```

---

## 作者：Mr_Wolfram (赞：72)

##所谓带权并查集##

本题所求的不止是两个编号之间是否有关系，还要求两个编号之间有什么关系，这就要求我们维护多个数组，fa[]数组维护两个编号之间的连通性，dis[]维护编号为i的战舰到fa[i]之间的距离，num[]维护编号为i的战舰所在的那一列有多少战舰。

find函数

```cpp
int find(int x){
    if(x!=fa[x]){
        int k=fa[x];
        fa[x]=find(fa[x]);
        dis[x]+=dis[k];
        num[x]=num[fa[x]];
    }
    return fa[x];
}
```
每次find的时候都更新num数组与dis数组

合并函数

```cpp
void merge(int x,int y){
    int r1=find(x),r2=find(y);
    if(r1!=r2){
        fa[r1]=r2;
                dis[r1]=dis[r2]+num[r2];
        num[r2]+=num[r1];
        num[r1]=num[r2];
    }
}
```
合并时由于是将i号战舰所在的那一列并到j号所在列的尾端，所以dis[r1]=dis[r2]+num[r2]。

询问函数

```cpp
int query(int a,int b){
    int r1=find(a),r2=find(b);
    if(r1!=r2){
        return -1;
    }else {
        return abs(dis[a]-dis[b])-1;
    }
}
```
注意返回时要加一


AC代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN=30005;
int read(){
    int rv=0,fh=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') fh=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        rv=(rv<<1)+(rv<<3)+c-'0';
        c=getchar();
    }
    return rv*fh;
}
int fa[MAXN],dis[MAXN],t,num[MAXN];
int find(int x){
    if(x!=fa[x]){
        int k=fa[x];
        fa[x]=find(fa[x]);
        dis[x]+=dis[k];
        num[x]=num[fa[x]];
    }
    return fa[x];
}
void merge(int x,int y){
    int r1=find(x),r2=find(y);
    if(r1!=r2){
        fa[r1]=r2;dis[r1]=dis[r2]+num[r2];
        num[r2]+=num[r1];
        num[r1]=num[r2];
    }
}
int query(int a,int b){
    int r1=find(a),r2=find(b);
    if(r1!=r2){
        return -1;
    }else {
        return abs(dis[a]-dis[b])-1;
    }
}
int main(){
    freopen("in.txt","r",stdin);
    t=read();
    for(int i=1;i<=MAXN;i++) {fa[i]=i;num[i]=1;}
    for(int i=1;i<=t;i++){
        char c;
        scanf(" %c ",&c);
        int a=read(),b=read();
        if(c=='M'){
            merge(a,b);
        }else {
            printf("%d\n",query(a,b));
        }
    }
    
    fclose(stdin);
    return 0;
}
```
[广告](http://blog.csdn.net/qq\_40280028)


---

## 作者：Martin_MHT (赞：38)

羞涩，其实这道题我看了题解才过的……  
好叭，说说我的思想

这一题明显要用并查集，因为维护队列接龙的时候要用到记录父亲等等操作  
而因为每一次输出的时候要输出i-j之间的战舰和  
所以我们引入两个数组

- sum数组——记录本列总长
- toh数组——记录每一个点到队首的长度（因为我们压缩了路径，所以要存储）

那么，我们就可以尝试着去打程序了。

find找爸爸函数：
```cpp
int find(int x)//找x的爸爸
{
	if(fat[x]==x)//如果找到根节点，这我就不多说了
		return x;
	int t1=fat[x],t2=find(fat[x]);//t1是它的父亲，t2是它父亲的父亲
    //（爷爷？滑稽）
	fat[x]=t2;//更新fat[x]的值
	toh[x]+=toh[t1];
    /*划重点！因为我们压缩了路径，所以这个点到父亲的距离
    要加上新压缩的路径中未计算的点*/
	return t2;//返回找到的父亲
}
```
unionn合并函数
```cpp
void unionn(int r1,int r2)
{
	int f1=find(r1),f2=find(r2);//直接把根节点插上，不多说
	fat[f2]=f1;//记录父亲
	toh[f2]=sum[f1];//这里到以下全是重点！
    //原队列长度即是此节点到父亲的距离
	sum[f1]+=sum[f2];//f1队列后放了sum[f2]个战舰
	sum[f2]=0;//原队列清空
}
```
下面是AC code:
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int sum[30001],fat[30001],toh[30001],t,ans;
int find(int x)
{
	if(fat[x]==x)
		return x;
	int t1=fat[x],t2=find(fat[x]);
	fat[x]=t2;
	toh[x]+=toh[t1];
	return t2;
}
void unionn(int r1,int r2)
{
	int f1=find(r1),f2=find(r2);
	fat[f2]=f1;
	toh[f2]=sum[f1];
	sum[f1]+=sum[f2];
	sum[f2]=0;
}
int abs(int op)
{
	return op<0?-op:op;
}
int main()
{
	char ds;
	int u,v;
	for(int i=1;i<=30000;i++)
	{
		fat[i]=i;
		sum[i]=1;
	}
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
		cin>>ds;scanf("%d %d",&u,&v);
		if(ds=='M')
		{
			unionn(v,u);
		}
		else
		{
			if(find(u)!=find(v))
				printf("-1\n");
			else
				printf("%d\n",abs(toh[u]-toh[v])-1);
		}
	}
}
```

END.蒟蒻%%%dalao！

---

## 作者：fanhy (赞：23)

~~说实话我AC的时候都不知道为什么自己AC了~~

我的做法其实类似于线段树的懒标记

merge操作可以认为是把a头上塞进b，那么a集合中的元素排名应当加上b的长度

一次性把所有元素加完太慢，可以在更新祖先的时候一起做

可以理解为更新一次祖先就加上祖先到祖先的祖先的长度，在代码中体现为先递归找祖先，更新祖先的祖先和祖先的排名，再更新自己的排名

结合代码理解一下就可以了

应该不会比楼下慢，最后两个点都是243ms，总时间664ms

[AC记录](https://www.luogu.org/record/23434811)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 30000 + 5;
int _opt;
char _typ;
int f[MAXN], sum[MAXN], Size[MAXN];
//sum表示排名，即包括自己在内前面有多少人
//Size表示集合大小，即自己最后一次做祖先时集合内有多少人

int get(int k)
{
	if (f[k] == k) return k;
	int fake = f[k];  //当前祖先
	f[k] = get(f[k]);  //找祖先
	sum[k] += sum[fake] - 1;  //更新排名
	return f[k];
}

void merge(int a, int b)
{
	int f1 = get(a), f2 = get(b);
	sum[f1] = Size[f2] + 1;   //更新祖先排名，在get的时候pushdown到f1集合内的元素
	Size[f2] += Size[f1];  //更新祖先为f2的集合的大小
	f[f1] = f2;  //f2：wsnbb
}

int main()
{
	for (int i = 1; i <= MAXN; i++) f[i] = i, sum[i] = 1, Size[i] = 1;
	cin >> _opt;
	int a, b;
	while (_opt--)
	{
		cin >> _typ >> a >> b;
		if (_typ == 'M') merge(a, b);
		else
		{
			if (get(a) != get(b)) cout << "-1\n";
			else cout << abs(sum[a] - sum[b]) - 1 << endl;
		}
	}
	return 0;
}
```
代码应该算是比较短的了，希望对你有些帮助

---

## 作者：Drinkkk (赞：15)

【参考资料】

三体智子的博客 - P1196 [NOI2002]银河英雄传说：https://www.luogu.org/blog/huangweixian123/p1196-noi2002-yin-he-ying-xiong-zhuan-shuo

【题目描述】

公元五八○一年，地球居民迁至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成$30000$列，每列依次编号为$1, 2, …,30000$。之后，他把自己的战舰也依次编号为$1, 2, …, 30000$，让第$i$号战舰处于第$i$列$(i = 1, 2, …, 30000)$，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为``M i j``，含义为第$i$号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第$j$号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增

大。 然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：``C i j``。该指令意思是，询问电脑，杨威利的第$i$号战舰与第$j$号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

最终的决战已经展开，银河的历史又翻过了一页……

【输入输出格式】

- 输入格式

输入文件的第一行有一个整数$T$（$1 \leq T \leq 500,000$），表示总共有$T$条指令。

以下有$T$行，每行有一条指令。指令有两种格式：

1. ``M i j`` ：$i$和$j$是两个整数（$1 \leq i , j \leq 30000$），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第i号战舰与第j号战舰不在同一列。

2. ``C i j`` ：$i$和$j$是两个整数（$1 \leq i , j \leq 30000$），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。

- 输出格式

你的程序应当依次对输入的每一条指令进行分析和处理：

如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息；

如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第$i$ 号战舰与第$j$ 号战舰之间布置的战舰数目。如果第i 号战舰与第j号战舰当前不在同一列上，则输出``-1``。

【输入输出样例】

- 输入样例
```
4
M 2 3
C 1 2
M 2 4
C 4 2
```
- 输出样例
```
-1
1
```

【样例说明】

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/pic/53.png)

【题目大意】

有$30000$条队列，总共$n$次操作，分M操作与C操作，M操作是把当前第$i$艘飞船所在的整条队列移到第$j$艘飞船艘所在的队列的最后面，C操作则是询问第$i$艘飞船与第$j$艘飞船是否在同一条队列，如果在则输出第$i$艘飞船与第$j$艘飞船之间的飞船数，不包括$i$和$j$，**题目不保证$j$在$i$后面**，否则就输出``-1``。

【题解】

我会并查集！

我们考虑用并查集解决这道题目。由于M操作较为简单，因此我们先对M操作入手。我们可以用一个数组``size[]``来存储每个队列当前所有的飞船的数量，在这里我用``size[i]``来表示第$i$条队列有多少艘飞船，并且用``d[i]``来表示$i$号飞船的前面有多少艘飞船所以当进行M操作时就将点$x$和点$y$合并，然后改一下两个数组的值即可~代码实现如下。
```
if(t[1]=='M')
{
    f[tx]=ty;
    d[tx]=size[ty];
    size[ty]+=size[tx];
    size[tx]=0;
}
```

接下来我们要处理的就是``find()``函数，一般我们写并查集的话函数是这样子的：
```
if(x==f[x])
{
    return x;
}
else
{
    return f[x]=find(f[x]);
}
```
但是在本题中，``find()``函数却是这样子的：
```
int find(int x)
{
    if(f[x]==x)
    {
        return x;
    }
    int t1=f[x];
    int t2=find(f[x]);
    f[x]=t2;
    d[x]+=d[t1];
    return t2;
}
```
在上面的一段代码中，$t1$表示的是点$x$原来的老大，$t2$表示的是点$x$现在的老大，因此将``f[x]=t2``（更新$x$点的祖宗）且将``d[x]+=d[t1]``（增加点$x$的前面的船的个数）。

C操作也比较简单，如果两个点的老大不一样就输出``-1``，否则就输出``|d[x]-d[y]|-1``即可，不懂的可以自己去算一下。

下面上AC代码~
```
#include <cstdio>
#include <cstdlib>
int size[1000001],f[1000001],d[1000001];
int inf=30001;
int find(int x)
{
    if(f[x]==x)
    {
        return x;
    }
    int t1=f[x];
    int t2=find(f[x]);
    f[x]=t2;
    d[x]+=d[t1];
    return t2;
}
int main()
{
    int n=0;
    scanf("%d",&n);
    for(int i=1;i<=inf;i++)
    {
        f[i]=i;
        size[i]=1;
    }
    for(int i=1;i<=n;i++)
    {
        char t[5];
        int x=0,y=0;
        scanf("%s %d %d",t+1,&x,&y);
        int tx=find(x),ty=find(y);
        if(t[1]=='M')
        {
            f[tx]=ty;
            d[tx]=size[ty];
            size[ty]+=size[tx];
            size[tx]=0;
        }
        else if(t[1]=='C')
        {
            if(tx!=ty)
            {
                printf("-1\n");
            }
            else
            {
                printf("%d\n",abs(d[x]-d[y])-1);
            }
        }
    }
    return 0;
}
```

---

## 作者：bianyaoyang0419 (赞：14)

作为一个 NOI 的题目肯定需要一些高端算法

但是根本不用并查集这种高端算法

只要一个功能不全的非旋treap就可以AC了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<ctime>
#include<cstdlib>
#define ft(a,b,c) for(int (a)=(b);(a)<=(c);(a)++)
#define fd(a,b,c) for(int (a)=(b);(a)>=(c);(a)--)
using namespace std;
const int N=600001;
namespace fhq{
    int l[N],r[N],rnd[N],siz[N],fa[N],num[N],cnt;
    int ffa(int x){
        if(!fa[x]) return x;
        else return ffa(fa[x]);
    }
    int nn(int x){
        rnd[++cnt]=rand();
        siz[cnt]=1;
        num[cnt]=x;
        return cnt;
    }
    void ud(int x){
        siz[x]=siz[l[x]]+siz[r[x]]+1;
        if(l[x])fa[l[x]]=x;
        if(r[x])fa[r[x]]=x;
    }
    int merg(int a,int b){
        if(!a||!b) return a+b;
        if(rnd[a]<rnd[b]){
            r[a]=merg(r[a],b);
            ud(a);
            return a;
        }else{
            l[b]=merg(a,l[b]);
       		ud(b);
       		return b;
        }
    }
    int rank(int x){
        int tt=x;
        int tmp=siz[l[tt]]+1;
        while(fa[tt]){
            if(r[fa[tt]]==tt) {
                tmp+=rank(fa[tt]);
                break;
            }
            else tt=fa[tt]; 
        }
        return tmp;
    }
}
int n=300000,m,x,y;

int main(){
    srand(time(NULL));
    scanf("%d",&m);
    ft(i,1,n) fhq::nn(i);
    ft(i,1,m){
        char ch=getchar();
        while(ch!='M'&&ch!='C') ch=getchar();
        scanf("%d%d",&x,&y);
        if(ch=='M'){
            int fx=fhq::ffa(x),fy=fhq::ffa(y);
            if(fx!=fy) fhq::merg(fx,fy);
        }
        if(ch=='C'){
            int fx=fhq::ffa(x),fy=fhq::ffa(y);
            if(fx!=fy) printf("-1\n");
            else{
                cout<<abs(fhq::rank(y)-fhq::rank(x))-1<<endl;
            }
        }
    } 
}
```

---

## 作者：干物国大皇帝 (赞：11)

	  **唔，看好多题解的find()都没详细讲，看了一下午都没懂，只好自己弄懂来写发题解，举例讲讲并查集的带权继承部分**╮（╯＿╰）╭

        当现在执行 find()时，整个并查集深度以 3为例：dep=1为新指向的点，dep=2为原祖先，dep=3为原本的各个后代。（find的点在第三排） 
	
        且现在只有 dep=1和 dep=2的 rank正确，因为 dep=1的点 rank为 0，dep=2刚修改过并且它的值就是被加长的舰队的原长。 
	find(i): 原 rank[i]存的是 (rank[原祖先]==0时它的rank)==(它与原祖先的差值)，由 rank[fa[i]]已正确，rank[i]维护完毕，它的 dep变成 2，指向新点。
	
        此时 dep>3的点都暂时不会被更新（暂时不用它），但他们的父亲还是原祖先，他们的 rank还是与原祖先的差值，需要用到时再维护出来就行了。
        
####         总结：dep=1的点 rank=0，dep=2的点 rank已正确，dep>=3都维护的是与上一级的差值。

剩下的自己模拟一下吧，应该很快就懂了。(>▽<)

ps：如果你觉得我的码风不好，那么
### 	~~我不要你觉得，我要我觉得。<(ˉ^ˉ)>~~
嗯，一个月内可以私聊问。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e4+5;
int fa[N],sz[N],rank[N];
int T,i,j,n=3e4;
char op;
int find(int x){
	if(x==fa[x])return x;
	int root=find(fa[x]);
	rank[x]+=rank[fa[x]]; 
	return fa[x]=root;
}
int main(){
	for(int i=1;i<=n;i++){
		fa[i]=i;sz[i]=1;rank[i]=0;
	}
	cin>>T;
	while(T--){
		cin>>op>>i>>j;
		int x=find(i);
		int y=find(j);
		if(op=='M'){
			fa[x]=y;
			rank[x]=sz[y];//x为舰首，rank一定是 0 
			sz[y]+=sz[x];
			sz[x]=0;
		}
		else{
			if(x!=y)cout<<-1<<endl;
			else{
				cout<<abs(rank[i]-rank[j])-1<<endl;
			}
		}
	}
	return 0;
}
```


---

## 作者：Imakf (赞：10)

> LCT可以把一切优美的做法变成暴力       -by Imakf

众所周知这是一道并查集好题，思路非常妙妙，但我们同样可以用更高级的数据结构LCT（大材小用）来实现链的合并。

首先我们需要两个数组$head[i],tail[i]$ 表示 $i$ 所在的链的头尾是什么，然后需要一个并查集记录合并，用LCT动态维护两个点之间的点数量就行了

------

我们用$Find(x)$表示并查集寻找祖先的操作

对于每一次合并$(u,v)$我们先找到 $u$ 的头 $Head=head[find(u)]$ ，合并到 $v$ 的尾 $Tail = tail[find(v)]$，然后更新新的长链的 $head[],tail[]$ 即可，代码实现如下

```cpp
void link(int x ,int y){
	if(find(x) != find(y)){
		makeroot(x);
		fa[x] = y;
		FA[find(x)] = find(y);
	}
}
int Head = head[find(u)] ,Tail = tail[find(v)];
head[find(u)] = head[find(v)];	//更新头
tail[find(v)] = tail[find(u)];	//更新尾
link(Head ,Tail);	//link是LCT的连边操作
```

对于每次查询 $(u ,v)$ 我们直接split出来这条链，查询一下点权和$S$，答案就是$S-2$


```cpp
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>

#define rg register
#define il inline
#define MX (30000 + 5)

int read(){
	rg char k = getchar();
	while(k < '0' || k > '9')	k = getchar();
	int x = 0;
	while(k >= '0' && k <= '9'){
		x = x * 10 + k - '0';
		k = getchar();
	}return x;
}

int FA[MX];
int find(int x){return x == FA[x] ? x : FA[x] = find(FA[x]);}

void swap(int &a ,int &b){int t = a; a = b; b = t;}
namespace LCT{
	#define lch(x) ch[x][0]
	#define rch(x) ch[x][1]
	int ch[MX][2] ,fa[MX] ,S[MX] ,mark[MX];
	il bool get(int x){return x == ch[fa[x]][1];}
	il bool Nroot(int x){return x == ch[fa[x]][0] || x == ch[fa[x]][1];}
	void change(int x){	//翻转左右儿子
		swap(lch(x) ,rch(x));
		mark[x] ^= 1;
	}
	void pushdown(int x){
		if(mark[x]){	//下穿标记
			if(lch(x))	change(lch(x));
			if(rch(x))	change(rch(x));
			mark[x] = 0;
		}
	}
	void pushup(int x){
		S[x] = 1;
		if(lch(x))	S[x] += S[lch(x)];
		if(rch(x))	S[x] += S[rch(x)];
	}
	void rotate(int x){
		int f = fa[x] ,gf = fa[f] ,which = get(x) ,W = ch[x][which ^ 1];
		if(Nroot(f))	ch[gf][ch[gf][1] == f] = x;
		ch[x][which ^ 1] = f;
		ch[f][which] = W;
		if(W)	fa[W] = f;
		fa[f] = x;
		fa[x] = gf;
		pushup(f);
	}
	int stack[MX] ,dep;
	void splay(int x){
		int f = x;
		stack[++dep] = f;
		while(Nroot(f))	stack[++dep] = (f = fa[f]);
		while(dep)	pushdown(stack[dep--]);
		while(Nroot(x)){
			f = fa[x];
			if(Nroot(f))	rotate(get(x) == get(f) ? f : x);
			rotate(x);
		}pushup(x);
	}
	void access(int x){
		for(rg int y = 0 ; x ; x = fa[y = x])
			splay(x) ,ch[x][1] = y ,pushup(x);
	}
	void makeroot(int x){
		access(x);
		splay(x);
		change(x);
	}
	void split(int x ,int y){
		makeroot(x);
		access(y);
		splay(y);
	}
	void link(int x ,int y){
		if(find(x) != find(y)){
			makeroot(x);
			fa[x] = y;
			FA[find(x)] = find(y);
		}
	}
}using namespace LCT;

int head[MX] ,tail[MX];
int main(){
	for(rg int i = 1 ; i <= 30000 ; ++i)
		FA[i] = i ,head[i] = i ,tail[i] = i;
	int T;
	scanf("%d" ,&T);
	char op[3];
	for(rg int i = 1 ,u ,v ; i <= T ; ++i){
		scanf("%s" ,op);
		u = read() ,v = read();
		switch(op[0]){
			case 'M':{
				int Head = head[find(u)] ,Tail = tail[find(v)];
				head[find(u)] = head[find(v)];
				tail[find(v)] = tail[find(u)];
				link(Head ,Tail);
				break;
			}
			case 'C':{
				if(find(u) != find(v))	puts("-1 ");
				else{
					split(u ,v);
					printf("%d \n" ,S[v] - 2);
				}
			}
		}
	}return 0;
}
```


---

## 作者：huangdu233 (赞：9)

It's widely known that：并查集可以使点并起来，形成连通块；so 是图就可以带上边权；

这道题相当于把每艘同列的战舰间连上权值为1的边；

father函数


```cpp
    int father(int v){
        int i,j=v;
        while(x[v].to!=v){
            v=x[v].to;
            if(v!=x[v].to){
              int a=father(v);
              x[j].dis+=x[v].dis;
              x[j].num=x[v].num;
            }
        }
        while(x[j].to!=j){
            i=j;
            j=x[j].to;
            x[i].to=v;
        }
        return v;
    }
```
最重要的是第一个while里的if()；


```cpp
    if(v!=x[v].to){
              int a=father(v);
              x[j].dis+=x[v].dis;
              x[j].num=x[v].num;
            }
```
实现了递归；在find father过程中，最好是能够跳过一个已路径压缩的点，直达father；
遇到没有路径压缩的，就用查该点的father，使改点被路压就好了；

其实就是这样；

源代码见下：


```cpp
    #include<bits/stdc++.h>
    using namespace std;
    struct ship{int to;int dis;int num;};
    int vis[30005];ship x[30005];
    int father(int v){
        int i,j=v;
        while(x[v].to!=v){
            v=x[v].to;
            if(v!=x[v].to){
              int a=father(v);
              x[j].dis+=x[v].dis;
              x[j].num=x[v].num;
            }
        }
        while(x[j].to!=j){
            i=j;
            j=x[j].to;
            x[i].to=v;
        }
        return v;
    }
    void modify(int i,int j){
        int a=father(i); int b=father(j);
        if(a!=b){
           x[a].to=b;
           x[a].dis+=vis[x[b].num];
           vis[x[b].num]+=vis[x[a].num];
           vis[x[a].num]=0;
           x[a].num=x[b].num;
        }
    }
    int query(int i,int j){
        int a=father(i);  int b=father(j);
        if(a!=b) return -1;
        return abs(x[i].dis-x[j].dis)-1;
    }
    int main()
    {
        int T,q,p; char c[2];
        for(int i=1;i<=30005;++i) {
          x[i].to=i;  x[i].dis=0;  vis[i]=1;  x[i].num=i;
        }
        scanf("%d",&T);
        for(int i=1;i<=T;++i){
            scanf(" %s ",c);
            scanf("%d%d",&q,&p);
            if(c[0]=='M') modify(q,p);
            else printf("%d\n",query(q,p));
        }
        return 0;
    }
```



---

## 作者：xxseven (赞：5)

难以理解路径压缩时的回溯更新？本篇题解将只使用**启发式合并的带权并查集**解决本题。

首先我们要知道，本题只使用启发式合并的困难在哪里。

在一般的启发式合并中，我们只需要将大小更小的集合合并至大小更大的集合即可。

但在此题中，有一个**给定的**集合需要按某一权值合并至另一集合，这意味着如果使用普通的启发式合并方式，我们就无法正确维护权值信息。

考虑将集合 $x$ 以权值 $v$ 合并至集合 $y$ 的影响。可以发现，原先所有在集合 $x$ 中的元素都增加了 $v$ 的权值。

而如果我们要将 $y$ 合并至 $x$，我们可以在 $x$ 上打一个永久化的标记 $v$，代表 $x$ 及其子树内的点权值全部增加 $v$。因为 $y$ 子树的权值不会增加，所以连向 $x$ 的边权应该为 $x$ 上标记的相反数。

如果我们要将 $x$ 合并至 $y$，边权应当先减去 $y$ 上的标记，再增加 $v$。

具体的合并方式可以看下面的这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4tnxibmr.png)

代码实现见下。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e4+5;
int n,pre[N],val[N],tag[N],siz[N];
//tag为节点上的标记，val为出边的边权
pair<int,int> find(int x){
	if(pre[x]==x) return {x,tag[x]};
	auto e=find(pre[x]);
	return {e.first,e.second+val[x]+tag[x]};
}
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=30000;++i) siz[i]=1,pre[i]=i;
	for(int u,v,i=1;i<=n;++i){
		char op; cin>>op>>u>>v;
		if(op=='M'){
			int x=find(u).first,y=find(v).first;
			if(siz[x]>siz[y]){
				pre[y]=x; tag[x]+=siz[y]; val[y]=-tag[x]; 
				siz[x]+=siz[y];
			}
			else{
				pre[x]=y; val[x]=siz[y]-tag[y];
				siz[y]+=siz[x];
			}
		}
		else{
			auto f=find(u),g=find(v);
			if(f.first!=g.first) cout<<-1<<'\n';
			else cout<<abs(f.second-g.second)-1<<'\n';
		}
	}
	return 0;
}

```

---

## 作者：永夜狂兽 (赞：5)

#### 作为我AC的第一道蓝题，这花了我不少时间，所以把这道题作为我第一次题解的对象
题目要求合并，判断是否在同一列，经典的并查集问法，所以
```cpp
int ft(int x)
{
    if(f[x]!=x)
    f[x]=ft(f[x]);
    return f[x];
}
```
```cpp
    cin>>x;
    scanf("%d%d",&a,&b);
    int fa=ft(a),fb=ft(b);
    if(x=='M')
    {
        int sb=so(b);
        f[fa]=fb;
        p[sb]=fa;
        s[sb]=fa;
    	px(sb);
    }
    if(x=='C')
    {
    	if(fa!=fb)
    	printf("-1\n");
        else
        printf("%d\n",abs(n[a]-n[b])-1);
    }
```
但还要求输出战舰间的战舰数，所以用了n数组来记录序号，p数组来记录前一艘战舰
```cpp
void px(int x)
{
    while(p[x])
    {
        n[p[x]]=n[x]+1;
        x=p[x];
    }
}
```
同时需要s数组来记录队尾，以便下次合并
```cpp
int so(int x)
{
	if(s[x]!=x)
	s[x]=so(s[x]);
	return s[x];
}
```
但如果是这样，显然很慢，所以就想在找父节点的时候更新，但始终不知如何实现，但没想到AC了，后来发现大佬的

```cpp
int find(int n)
{
    if(fa[n]==n)return fa[n];
    int fn=find(fa[n]);
    front[n]+=front[fa[n]]; 
    return fa[n]=fn;
}//在找父节点的时候同时更新序号
```
以及用一个数组来记录队列长度而不用s数组来记录队尾

### 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,a,b,i,f[30005],n[30005],s[30005],p[30005];
//f--父节点/队头，n--序号，s--子节点/队尾，p--下一个战舰
char x;
int ft(int x)
{
	if(f[x]!=x)
	f[x]=ft(f[x]);
	return f[x];
}//找父
int so(int x)
{
	if(s[x]!=x)
	s[x]=so(s[x]);
	return s[x];
}//找子
void px(int x)
{
	while(p[x])
	{
		n[p[x]]=n[x]+1;
		x=p[x];
	}
}//更新序号
int main()
{
	cin>>m;
	for(i=1;i<=30000;i++)
	{
		f[i]=i;s[i]=i;
	}
	while(m--)
	{
		cin>>x;
		scanf("%d%d",&a,&b);
		int fa=ft(a),fb=ft(b);
		if(x=='M')
		{
			int sb=so(b);
			f[fa]=fb;
			p[sb]=fa;
			s[sb]=fa;//合并
			px(sb);
		}
		if(x=='C')
		{
		if(fa!=fb)
		printf("-1\n");
		else
		printf("%d\n",abs(n[a]-n[b])-1);
		}
	}
	return 0;
}
```


---

## 作者：zhengrunzhe (赞：4)

第一反应就是Splay

果然在题解里找到了同好[握手]

提供一个指针版的

维护n棵Splay，每棵Splay表示每一列，中序遍历的结果便是一个序列

分析每个操作

1.Move x y

首先找到x,y所在的Splay的根r1,r2

若r1==r2就不用了

否则找到r2最右的位置把r1接上

2.Check x y

同样找到x,y所在的Splay的根r1,r2

若r1!=r2返回-1

否则返回x和y在这棵Splay的排名之差的绝对值-1
```cpp
#include<cmath>
#include<cstdio>
using namespace std;
const int N=30001;
int n;
struct tree
{
	int size;
	tree *fa,*son[2];
	inline tree()
	{
		size=1;
		fa=son[0]=son[1]=NULL;
	}
	inline void pushup()
	{
		size=1;
		if (son[0])size+=son[0]->size;
		if (son[1])size+=son[1]->size;
	}
}*pos[N];  //pos[x]表示id为x的数代表的节点地址
inline bool relation(tree *p) //获取父子关系 p是它父亲的左还是右儿子
{
	if (p->fa)return p->fa->son[1]==p;
}
inline void connect(tree *&p,tree *&fa,bool which) //建立父子关系 p的父亲是fa fa的which儿子是p
{
	if (p)p->fa=fa;
	if (fa)fa->son[which]=p,fa->pushup();
}
inline tree *get_root(tree *p) //获取p所在Splay的根
{
	tree *k=p;
	while (k->fa)k=k->fa;
	return k;
}
inline void rotate(tree *&p)
{
	tree *fa=p->fa;
	bool dir=relation(p);
	connect(p,fa->fa,relation(fa));
	connect(p->son[dir^1],fa,dir);
	connect(fa,p,dir^1);
	fa->pushup();p->pushup();
}
inline void splay(tree *&p)
{
	for (tree *fa;fa=p->fa;rotate(p))
		if (fa->fa)
			rotate(relation(p)==relation(fa)?fa:p);
}
inline int get_rank(int x) //获取x在它所在的Splay中的排名
{
	tree *p=pos[x];
	splay(p);
	return p->son[0]?p->son[0]->size+1:1;
}
inline void init(int id)
{
	pos[id]=new tree;
}
inline void Move(int x,int y)
{
	tree *r1=get_root(pos[x]),*r2=get_root(pos[y]);
	if (r1==r2)return;
	tree *p=r2;
	while (p->son[1])p=p->son[1];
	connect(r1,p,1);splay(r1);
}
inline int Check(int x,int y)
{
	tree *r1=get_root(pos[x]),*r2=get_root(pos[y]);
	if (r1!=r2)return -1;
	return abs(get_rank(x)-get_rank(y))-1;
}
int main()
{
	scanf("%d",&n);
	for (int i=1;i<N;i++)init(i); //由于题目并没有给总共有多少列 干脆建30000棵
	while (n--)
	{
		char opt;int x,y;
		scanf(" %c%d%d",&opt,&x,&y);
		if (opt=='M')Move(x,y);
		else printf("%d\n",Check(x,y));
	}
	return 0;
}
```

---

## 作者：EternalAlexander (赞：4)

## splay

这题跟P2342有点像。

带权并查集是啥？splay才是万能的。

按照题意模拟即可。

用splay维护一个可分裂/合并的序列。merge(a, b)意为把b接在a后面。那么找到a所在的splay中的最右结点然后旋到根，然后把b所在的splay接到a的右儿子上。

query(a, b)把a旋到根，然后把b旋到a的下面。如果b是a的左儿子则输出b右子的大小，否则输出b的左子的大小。

```cpp
#include <cstdio>
#include <cstring>
#define maxn 400000

int fa[maxn]={0}; int ch[maxn][2]={0}; int size[maxn];
inline void update(int x) {
    size[x]=size[ch[x][0]]+size[ch[x][1]]+1;
}
inline void rotate(int x) {
    if (!x||!fa[x]) return ;
    int f=fa[x]; int l=ch[f][1]==x;
    ch[f][l]=ch[x][l^1];
    fa[ch[x][l^1]]=f;
    fa[x]=fa[f];
    ch[fa[f]][ch[fa[f]][1]==f]=x;
    ch[x][l^1]=f;
    fa[f]=x;
    update(f);
    update(x);
} inline void splay(int x, int aim=0) {
    for (int y; (y=fa[x])!=aim; rotate(x)) {
        if (fa[y]!=aim)
            rotate((ch[y][0]==x)==(ch[fa[y]][0]==y)?y:x);
    }
} void merge(int x, int y) {
    while (fa[x]) x=fa[x];
    while (ch[x][1]) x=ch[x][1];
    splay(x);
    while (fa[y]) y=fa[y];
    fa[y]=x; ch[x][1]=y;
    update(x);
} int query(int a, int b) {
    int x=a; int y=b;
    while (fa[x]) x=fa[x];
    while (fa[y]) y=fa[y];
    if (x!=y) return -1;
    splay(a); splay(b, a);
    return size[ch[b][ch[a][0]==b]];
} int main() {
    int q; char opt[10];int a, b;
    scanf("%d", &q);
    for (int i = 1; i <= q; ++i) {
        scanf("%s", &opt);
        if (opt[0]=='C') {
            scanf("%d %d", &a, &b);
            printf("%d\n", query(a,b));
        }if (opt[0]=='M') {
            scanf("%d %d", &a, &b);
            merge(a, b);
        }
    }
    return 0;
}
```

---

## 作者：啊嘞嘞嘞嘞 (赞：3)

这题正解是带权并查集，但普通并查集也能做，只不过是离线算法，跑的也不算慢。貌似没人发这种做法的题解。

看到每次合并2个集合，并要以集合为单位查询信息，也许能想到Kruskal重构树。但我们只需要用它构树的思想，开点表示2个集合的并集，利用这棵二叉树。（顺带一提，P3273 [SCOI2011]棘手的操作  也能用这个思想做）

题目中的操作，显然不会导致同一集合里的飞船的相对顺序发生改变。如果要询问同一集合内两艘飞船间隔着的飞船数，无论这个集合再怎么与其他集合并，答案都不会改变。那么就简单了，对于同一集合内的查询，直接去最终状态查询。

每次将队列x加到y后面，就把集合x并入集合y，并查集开个新点，让x和y的fa都指向这个新点。读完操作后，对构造的二叉树进行先序遍历（左孩子为队列中排前面的），就可以得到每个飞船在最终阵列的位置。最后过一遍询问数组，回答即可。无效操作或者输出-1在读入的时候特别判一下就好了，离线回答的时候特别处理。（预先处理这个可以避免再次使用并查集操作）

```cpp
#include <cstdio>
using namespace std;
const int MAXN=30010;
int n,tot,pos[MAXN];
int fa[MAXN*2];
int q[500010][3];
struct node {
	int lc,rc;
} tr[MAXN*2];
int vis[MAXN*2];
inline int abs(int x) { return x>0 ? x : -x; }
int getfa(int u) {
	while (u=fa[u]=fa[fa[u]],u!=fa[u]);
	return u;
}
void build(int p) {
	static int ord;
	if (p<=n) {
		pos[p]=++ord;
	} else {
		build(tr[p].lc);
		build(tr[p].rc);
	}
	vis[p]=1;
}
int main() {
	int Q;
	n=30000;
	scanf("%d",&Q);
	for (register int i=1;i<=n;i++) fa[i]=i;
	tot=n;
	for (register int i=0;i<Q;i++) {
		char opt;
		int x,y;
		scanf(" %c%d%d",&opt,&x,&y);
		if (opt=='M') {
			q[i][0]=1;
			x=getfa(x),y=getfa(y);
			if (x==y) {
				q[i][0]=0; //无效操作，直接舍弃
			} else {
				++tot;
				fa[y]=fa[x]=tot;
				fa[tot]=tot;
				tr[tot]=(node){y,x};
			}
		} else if (opt=='C') {
			q[i][0]=getfa(x)==getfa(y) ? 2 : 3;
		}
		q[i][1]=x, q[i][2]=y;
	}
	for (register int i=tot;i>=1;i--) {
		if (!vis[i]) build(i);
	}
	for (register int i=0;i<Q;i++) {
		int opt=q[i][0],x=q[i][1],y=q[i][2];
		if (opt==2) { //有效查询
			printf("%d\n",abs(pos[x]-pos[y])-1);
		} else if (opt==3) { //无效查询
			printf("%d\n",-1);
		}
	}
	return 0;
}
```

---

## 作者：wawcac (赞：3)

不用说肯定用并查集，貌似就是不进行路径压缩的无脑模拟？不对，500000个操作，30000艘船，不超时才怪！


那怎么办呢？一路径压缩战舰顺序就被改变，怎么才能在路径压缩的同时随时得知同一舰队中两艘战舰的位置？


输入是合并与询问两艘战舰之间的“距离”，遇到问题是路径压缩后“距离”（间隔战舰数量）变了，不压缩太慢了，那我们不就可以再开一个数组，存下需要的“距离”了吗？这个数组存的距离就是在路径压缩时变化了的那个：第i艘到第fa[i]艘之间的战舰数量，数组名就命名成front吧，因为路径压缩全部完成，即同一舰队中所有元素的fa[i]都等于这个舰队第一艘战舰时，front[i]=第i艘战舰前方有多少战舰（这么搞就像前缀和，路径压缩时可以一层一层地边压缩边修正下去）。


易知在还未进行路径压缩时对于同一舰队非第一艘战舰，front[i]=1，第一艘战舰front[i]=0(一个舰队的第一艘，不是编号为一的那艘)，路径压缩首先不断向fa[i]走fa[i]=find(fa[i])，走到队首，fa[i]==i，front[i]=0不变，返回队首的编号，回溯至递归上一层，把队首的编号那么第二艘的front增加0就是1，为何是增加呢？因为前面说过完成路径压缩即find函数跑完后front[i]的值就是编号i的战舰前方有几艘战舰，路径压缩前则是到fa[i]的距离，一路径压缩，就相当于fa[i]直接越过front[fa[i]]艘战舰，从i的前一艘指向队首，fa[i]前进那么多，front[i]自然也要增加那么多，修改之后继续回溯，同理第三层front[i]+=front[fa[i]]……路径压缩完成。


合并时怎么办呢，定义合并函数uni(x,y)表示将x所在那列移到y所在那列后面（千万别搞反了），那么我们就要先找到两列的队首(依然用x、y存)，像普通并查集那样fa[x]=y,然后维护front数组，这时遇到问题啦——front[y]要加多少呢？显然是x那列的战舰数，难道还要循环一遍统计一下吗？那太慢了，存下来吧，于是num[i]表示编号i这列的战舰总数（i是队首，不然每合并一次要修改的太多了，查询时num[i]时先find(i)找到队首吧），front[y]+=num[x]，num[x]+=num[y]，合并完成。


还有一个问题就是询问。对于一组询问ask(x,y)，先找到他们的队首fx=find(x);fy=find(y);（顺便把路径压缩进行完全了，不用担心front[i]被重复增加了，路径压缩完全时front[fa[i]]==0，因为fa[i]就是队首呀），然后判断fx!=fy就输出-1，否则就输出abs(front[x]-front[y])-1（到队首的距离之差减一就是他们间隔距离）。


代码就不贴了，楼下都有


[广告](http://www.cnblogs.com/wawcac-blog/p/6821770.html)


---

## 作者：vivarock (赞：3)

解法一：首先想到的方法当然是直接模拟，用并查集模拟每一合并。

但是求路径距离不方便，要暴力

时间复杂度呈指数增长

只能的20

~~QAQ~~

解法2：
### 正解是利用 带权的并查集

所谓的带权，指的是不仅可以查看是否在某一个集合中，还可以看点到根的距离



------------
你会想 那可不可以路径压缩？如果要压缩，那么就无法判断点到顶点的距离


------------
其实是可以的

在压缩的时候顺便把路径长度保存在另外的一个数组里


------------
```cpp
int find(int now){
    if(now!=fa[now]){
		int father=fa[now];
		fa[now]=find(fa[now]);
		w[now]+=w[father];
	}
	return fa[now];
}
```


------------

下面上本蒟蒻丑陋代码

```cpp
#include<bits/stdc++.h>//万能大法好
using namespace std;
#define maxn 30010//宏定义
int w[maxn],fa[maxn],num[maxn],n;
//w表示从自己到根的距离，num表示以i为根的并查集的元素个数，fa表示根
int find(int now){
    if(now!=fa[now]){
		int father=fa[now];
		fa[now]=find(fa[now]);
		w[now]+=w[father];
	}
	return fa[now];
}
//查找+路径压缩
#define For(i,j,n) for(int i=(j);i<=(n);++i)
void merge(int a,int b){
	int x=find(a),y=find(b);
	w[x]+=num[y];
	fa[x]=y;
	num[y]+=num[x];
    num[x]=0;
}
//合并
int main(){
    For(i,1,maxn)fa[i]=i,num[i]=1;
    //初始化
    cin>>n;	
    For(i,1,n){
    	char a;int b,c;
    	cin>>a>>b>>c;
    	if(a=='M')merge(b,c);
    	else if(find(b)==find(c))printf("%d\n",abs(w[b]-w[c])-1);//两个点间的距离可以用abs(w[b]-w[c])-1表示，应为重复b点，所以减去1
      		 else printf("-1\n");
    }
 	return 0;
}
```

---

## 作者：曹老师 (赞：3)

~~蒟蒻来一篇蒟蒻的题解：不O2会TLE的那种~~

可以模拟着来做，不断地合并，但是肯定会MLE

![](https://cdn.luogu.com.cn/upload/pic/38404.png)

于是考虑内存释放，我用的vector用swap释放内存，于是就变成了TLE

![](https://cdn.luogu.com.cn/upload/pic/38405.png)

~~然后就是无耻的O2优化~~

![](https://cdn.luogu.com.cn/upload/pic/38406.png)

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;

const int L = 30005;
int n , fa[L] , rank[L];
vector<int>q[L];
inline int myabs(int a) { return a>0?a:(-a); }

void init() {
    for(int i=1; i<=30000; i++) {
        fa[i] = i;
        rank[i] = 1;
        q[i].push_back(i);		
    }
}

int find(int x) {
    if(fa[x] != x)
        return fa[x] = find(fa[x]);
    return fa[x];
}

void update(int x , int y) {
    int fx = find(x) , fy = find(y);
    int sz = q[fx].size() , cz = q[fy].size();
    fa[fx] = fy;
    for(int i=0; i<sz; i++) {
        q[fy].push_back(q[fx][i]);
        rank[q[fx][i]] = cz+1+i;		
    }
    q[fx].clear();
	vector<int>().swap(q[fx]);
}

void qans(int x , int y) {
    int fx , fy;
    fx = find(x) , fy = find(y);
    if(fx != fy) {
        printf("-1\n");
        return ;
    }
    printf("%d\n",myabs(rank[x]-rank[y])-1);
}

int main() {
    scanf("%d",&n);
    init();
    for(int i=1; i<=n; i++) {
        char c;int x , y;
        cin>>c;
        scanf("%d%d",&x,&y);
        if(c=='M')
            update(x,y);
        else
            qans(x,y);
    }
    return 0;
}
```

---

## 作者：VCVCVCFop_zz (赞：3)

并查集经典题。。

差不多可以视为模版题的改版

半年前的代码如下


```cpp
var
  c,c1:char;
  i,n,m,k,x,y:longint;
  f,count,before:array[0..30001]of longint;
function getfather(x:longint):longint;
var t:longint;
begin
  if f[x]=x then getfather:=x else
  begin
    t:=getfather(f[x]);
    before[x]:=before[f[x]]+before[x];
    f[x]:=t;//路径压缩
    getfather:=f[x];
  end;
end;
procedure judge(x,y:longint);
var
  fx,fy:longint;
begin
  fx:=getfather(x);
  fy:=getfather(y);
  f[fx]:=fy;//合并两个集
  before[fx]:=before[fx]+count[fy];
  inc(count[fy],count[fx]);
end;
procedure ask(x,y:longint);
begin
  if getfather(x)<>getfather(y) then writeln(-1)
  else writeln(abs(before[x]-before[y])-1);//输出结果
end;
begin
  for i:=1 to 30000 do begin count[i]:=1;f[i]:=i;end;//f数组初始化，表示父亲节点
  readln(n);
  for i:=1 to n do
  begin
    readln(c,x,y);
    if c='M' then judge(x,y);//两种指令
    if c='C' then ask(x,y);
  end;
end.
```

---

## 作者：Skywalker_David (赞：3)

并查集.

在寻找根节点时，注意记录位置；

在合并时，注意改变位置:开一个数组记录每个集合元素个数,便于记录位置。

读入，若为M则为合并；c则为查找。

——————————————————

对于每一个战舰i，记录3个变量，r[i]表示战舰i当前指向的根节点，b[i]表示战舰i前面的战舰数，c[i]表示战舰i后面的战舰数（包括战舰i自身）。


初始时，a[i]=i，b[i]=0，c[i]=1。对于每一个命令，先进行路径压缩，然后再进行相应的操作（详情参见《算法艺术与信息学竞赛》82页）。

```delphi

var 
    n,i,f1,f2,a,b:longint;
    ch:char;
    sum,f,s:array [0..30000] of longint;

function getfather(v:longint):longint;
var 
    p:longint;
begin
    if f[v]=v then exit(v);
    p:=getfather(f[v]);
    s[v]:=s[f[v]]+s[v];
    f[v]:=p;
    getfather:=f[v];
end;

begin
    readln(n);
    for i:=1 to 30000 do begin 
        s[i]:=0;
        sum[i]:=1;
        f[i]:=i;
    end;
  for i:=1 to n do begin
        read(ch);
        readln(a,b);
        f1:=getfather(a);
        f2:=getfather(b);
        if ch='M' then begin
            s[f1]:=sum[f2]+s[f1];
            sum[f2]:=sum[f2]+sum[f1];
            f[f1]:=f2;
        end;
        if ch='C' then
            if f1<>f2 then writeln(-1) 
                else writeln(abs(s[a]-s[b])-1);
    end;
end.

```

---

## 作者：hfee (赞：2)

前置知识： [并查集模板](https://www.luogu.com.cn/problem/P3367)

[广告位](https://whitecatj.github.io/2019/12/18/%5BNOI2002%5D银河英雄传说/)

这题与普通并查集的唯一区别在于，需要计算在链上的两个点之间的距离

就它的操作来说，把一列接在另一列后面，点之间的距离变化似乎很简单

我们除了原来的$fa[x]$表示$x$号战舰前面的的那艘战舰的编号

再开一个 $d$ 数组存储每个节点到队首的边权和（每条边的边权都是1）

在路径压缩时更新这个值

即下面的get操作

```
int get(int x){
	if(x == fa[x]) return x; 
	int q = get(fa[x]); //原模板
	d[x] += d[fa[x]]; //这个点到队首的距离应该加上它前面那一艘的距离
	return fa[x] = q; //原模板，路径压缩
}
```

在收到C指令时，分别找到$x$和$y$的祖先，然后完成查询，路径压缩

如果两人的祖先一样，说明在同一列，两人之间的距离显然有$abs(d[x] - d[y]) - 1$

收到M指令时，先把$x$的树根作为$y$树根的子节点

连起来之后，$x$树根到$y$树根的距离应该是$y$数组现有的飞船数量

所以我们再开一个$size$数组，在每个树根处存下现在这个集合里有多少飞船

于是就有以下的merge操作

```
void merge(int x, int y){
	x = get(x);
	y = get(y); //找到两人的祖先
	fa[x] = y; //把y作为x的祖先
	d[x] = size[y]; //现在x到根的距离应该是y这条链的长度了
	size[y] += size[x]; //y的长度要加上x的长度
}
```

完整代码：

```
#include<bits/stdc++.h>
#define N 30005
using namespace std;

int T, x, y;
int fa[N], d[N], size[N];
char c; 

int get(int x){
	if(x == fa[x]) return x;
	int q = get(fa[x]);
	d[x] += d[fa[x]];
	return fa[x] = q;
}

void merge(int x, int y){
	x = get(x);
	y = get(y);
	fa[x] = y;
	d[x] = size[y];
	size[y] += size[x];
}

int main(){
	scanf("%d", &T);
	for(int i = 1; i < N; ++i) fa[i] = i;
	for(int i = 1; i < N; ++i) size[i] = 1;//记得两个初始化，每个点的祖先设成自己，每条链的初始长度为1
	for(int i = 1; i <= T; ++i){
		cin>>c>>x>>y;
		if(c == 'M') merge(x, y);
		else{
			if(get(x) == get(y)) printf("%d\n", abs(d[x] - d[y]) - 1);
			else printf("-1\n");
		}
	}
	return 0w0;
}

```

//本文章很大来自于《算法进阶》


---

## 作者：End_donkey (赞：2)

题意

有一个划分成n列的星际战场，各列编号为1，2.....n。有n艘战舰，也依次编号1，2.....n,其中第i号战舰位于第i列。

有m条指令，每条指令格式如下

1. M i j 表示让第i号战舰所在列的全部战舰保持原有顺序，接在第j艘战舰的尾部。

2. C i j 表示询问第i艘战舰和第j艘战舰当前是否再同一列中，如果再同一列中，它们之间隔了多少艘战舰。

N<=30000,M<=5* $10^5$

一道简单的并查集，一条链也是一棵树，只不过是树的特殊形态，因此可以把每一列战舰看作一个集合用并查集维护。最初，N个战舰构成N个独立的集合。

在没有路径压缩的情况下fa[x]就代表排在x前面那艘战舰的编号，一个集合的代表就是位于前面的战舰，另外让树上每条边带权值1，这样树上两点之间的距离-1就是二者之间间隔的战舰数量

在考虑路径压缩的情况下,我们额外建立一个数组d，d[x]记录战舰x与fa[x]之间的边的权值。在路径压缩把x直接指向树根的同时，我们把d[x]更新为从x到树根的路径上的所有边权之和，下面的代码对Get函数稍价修改，即可实现对d数组的维护。

```cpp
int get(int x){
	if(x==fa[x]) return x;
	int root=get(fa[x]); //递归计算集合代表 
	d[x]+=d[fa[x]];//维护数组d 
	return fa[x]=root;//路径压缩 
} 
```
当收到 C x y 指令时分别执行 get(x)和get(y)完成查询和路径压缩，当二者的返回值相同时，则说明x，y在同一列。因为x和y此时都已经指向树根，所以d[x]保存了位于x之前的战舰数量，d[y]保存了位于y之前的战舰数量，两者之差的绝对值再减去1就是x，y之间相隔的战舰数量。

当收到 M x y 指令时把x的树根作为y的树根的子节点，连接的新边的权值应该设为合并之前集合y的大小（由题意，集合y中的所有战舰都在集合x之前），因此我们还需要一个size数组在每个树根上记录集合大小。

```cpp
void merge(int x,int y){
	x=get(x);y=get(y);
	fa[x]=y;d[x]=size[y];
	size[y]+=size[x];
}
```
代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
using namespace std;
const int maxn=30010;
int T,fa[maxn],d[maxn],size[maxn];
int get(int x){
    if(x==fa[x]) return x;
    int root=get(fa[x]);
    d[x]+=d[fa[x]];
    return fa[x]=root;
}
int main(){
    for(int i=1;i<=maxn;++i){
        fa[i]=i;
        size[i]=1;
    }
    scanf("%d",&T);
    while(T--){
        char k[2];
        int u,v;
        scanf("%s",k);
        scanf("%d%d",&u,&v);
        int fa1=get(u);
        int fa2=get(v);
        if(k[0]== 'M'){
            fa[fa1]=fa2;
            d[fa1]=size[fa2];
            size[fa2]+=size[fa1];
        }
        else{
            if(fa1!=fa2) printf("-1\n");
            else printf("%d\n",abs(d[u]-d[v])-1);
        }
    }
    return 0;
}
```

---

## 作者：GreyCrane (赞：2)

这题坑了我2个小时，最后才发现，是个结构体并查集。
二话不说，上代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=30001;
struct Fleet{
	int head;
	int cnt;
	int before;
}a[N];
int find(int x){//查找开头船号
	int f;
	if(x==a[x].head){
		return x;
	}else{
		f=find(a[x].head);
		a[x].before+=a[a[x].head].before;
		a[x].head=f;
		return f;
	} 
}
void modify(int i,int j){//合并
	int hi,hj;
	hi=find(i);
	hj=find(j);
	a[hi].head=hj;
	a[hi].before+=a[hj].cnt;
	a[hj].cnt+=a[hi].cnt;
}
int query(int i,int j){//查询个数
	if(find(j)!=find(i)){
		return -1;
	}else{
		return (int)fabs(a[i].before-a[j].before)-1;
	}
}
int main(){
	int i,j,T,k;
	char cmd;
	cin>>T;
	for(k=1;k<=N;k++){
		a[k].head=k;
		a[k].before=0;
		a[k].cnt=1;
	}
	for(k=1;k<=T;k++){
		cin>>cmd>>i>>j;
		if(cmd=='M'){
			modify(i,j);
		}else{
			cout<<query(i,j)<<endl;
		}	
	}
	return ;//防抄标记
}
```

---

## 作者：p_b_p_b (赞：2)

### 暴力splay解决一切问题！！

#### ~~如果不行，就再套一个！！~~

作为一个数据结构学傻了的菜鸡，这题当然是一眼splay啦

我们可以建30000棵splay，然后乱搞即可

query：标准splay区间操作，输出size即可

connect：搞到两点所在的splay的根节点，然后启发式合并即可

没啦，so easy！

代码：（可能有些丑，我从[这里](https://www.luogu.org/problemnew/show/U33553#sub)( https://www.luogu.org/contestnew/show/9354 ) 来的）

```cpp
#include<bits/stdc++.h>
#define sz 101010
#define mod (int)(1e9+7)
using namespace std;
typedef long long ll;
struct FastIO
{
	inline FastIO& operator>>(int& x)
	{
		x=0;char f=0,ch=getchar();
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') x=x*10+ch-48,ch=getchar();
		return x=(f?-x:x),*this;
	}
	inline FastIO& operator>>(ll& x)
	{
		x=0;char f=0,ch=getchar();
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') x=x*10+ch-48,ch=getchar();
		return x=(f?-x:x),*this;
	}
	inline FastIO& operator>>(double& x)
	{
		x=0;char f=0,ch=getchar();
		double d=0.1;
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') x=x*10+ch-48,ch=getchar();
		if(ch=='.')
		{
			ch=getchar();
			while(ch<='9'&&ch>='0') x+=d*(ch^48),d*=0.1,ch=getchar();
		}
		return x=(f?-x:x),*this;
	}
}read;

void file()
{
	#ifndef ONLINE_JUDGE
	freopen("a.txt","r",stdin);
	#endif
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

ll a[sz];

struct hh{int fa,dep,ch[2];ll sum;}tr[sz<<1];

int getfa(int x){while (tr[x].fa) x=tr[x].fa;return x;}
void pushup(int x)
{
	tr[x].sum=tr[tr[x].ch[0]].sum+tr[tr[x].ch[1]].sum+a[x];
	tr[x].dep=max(tr[tr[x].ch[0]].dep,tr[tr[x].ch[1]].dep)+1;
}
bool get(int x){return tr[tr[x].fa].ch[1]==x;}
void rotate(int x)
{
	int y=tr[x].fa,z=tr[y].fa;
	int k=get(x),w=tr[x].ch[!k];
	if (z) tr[z].ch[get(y)]=x;tr[x].ch[!k]=y;tr[y].ch[k]=w;
	if (w) tr[w].fa=y;tr[x].fa=z;tr[y].fa=x;
	pushup(y);pushup(x);
}
void splay(int x,int to)
{
	while (tr[x].fa!=to)
	{
		int y=tr[x].fa;
		if (tr[y].fa!=to) rotate(get(x)==get(y)?y:x);
		rotate(x);
	}
}
void connect(int x,int y) //head[x]->tail[y]
{
	x=getfa(x);y=getfa(y);
	if (x==y) return;
	if (tr[x].dep>tr[y].dep)
	{
		while (tr[x].ch[0]) x=tr[x].ch[0];
		tr[x].ch[0]=y;tr[y].fa=x;
		splay(y,0);
	}
	else
	{
		while (tr[y].ch[1]) y=tr[y].ch[1];
		tr[y].ch[1]=x;tr[x].fa=y;
		splay(x,0);
	}
}
void cut(int x)
{
	splay(x,0);
	tr[tr[x].ch[0]].fa=0;tr[x].ch[0]=0;
	pushup(x);
}
ll query(int x,int y)
{
	if (x==y) return 0;
	int fx=getfa(x),fy=getfa(y);
	if (fx!=fy) return -1;
	splay(x,0);splay(y,x);
	int ls=tr[y].ch[0],rs=tr[y].ch[1];
	return get(y)?tr[ls].sum:tr[rs].sum;
}
bool vis[sz];
void debug(int x)
{
	splay(x,0);
	while (tr[x].ch[0]) x=tr[x].ch[0];
	splay(x,0);
	while (x&&tr[x].ch[1]) printf("%d<-",x),vis[x]=1,x=tr[x].ch[1];
	printf("%d ",x);vis[x]=1;
}
int main()
{
//	file();
	int n,m,i,j,k,x,y,z;
	read>>m;n=30000;
	for (i=1;i<=n;i++) a[i]=1;
	for (i=1;i<=n;i++) pushup(i);
	while (m--)
	{
		char ch;cin>>ch;
		if (ch=='M') read>>x>>y,connect(x,y);
		else read>>x>>y,printf("%lld\n",query(x,y));
//		for (i=1;i<=n;i++) if (!vis[i]) debug(i);
//		puts("");memset(vis,0,sizeof(vis));
	}
}
```

---

## 作者：L__A (赞：2)

### 加权并查集的典型题
**//如果并不是很懂并查集及其优化，建议先打个模板题**

知道并查集的基本操作，即可发现对于两列舰队的合并、询问两个战舰是否在同一列，就分别是并查集的并、查操作。每一列的列首战舰即为此列所有战舰的祖先，合并两列时，即把其中一列的列首的父亲改为另一列列首，查询在不在一列，即对于两个战舰，向上逐个寻找父亲，直到找到父亲为自身的祖先，若为同一祖先，即在同一列。

好，现在只剩下一个问题，若两个战舰在一列，他们之间布置有多少战舰？

让我们回想并查集的两个优化之一——按秩合并，记录并查集中每个树的深度，每次合并时将深度小的合并到深度大的上。这里的深度，也就是在并查集的操作过程中不断维护的信息，那么我们可不可以在操作中维护一个信息来记录两个战舰之间布置的战舰个数呢？

显然，若对于每两个战舰都记录一下他们之间布置的战舰的个数，时间空间开销都很大，这时我们想到前缀思想：**对于每个战舰i，记录pre[i]为i所在的那一列上在i之前有多少个战舰（即为他之前直到他所在列的列首战舰数）**。这样，对于同一列的战舰i与战舰j（设i在j之后），他们之间的战舰个数即为**pre[i]-pre[j]-1**。

那么接下来，该如何维护这个pre数组呢？考虑：只有在合并两列时才会增加接在后面的那一列所有战舰的pre数组，**这个增量，即为接在前面的那一列的总战舰数**。此时我们想到再维护一个数组num[i]，即为以i为列首的那一列一共有多少战舰（以i为祖先的树的大小）。对于每次合并，我们只需将后面那一列的列首pre值+=前面那一列列首的num值，而对于后面那一列列首之后的那些战舰的pre值，只需再执行并查集find操作递归的回溯时更改，具体方法见代码及注释。

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

int t,fa[30010],pre[30010],num[30010],a,b;
char c;//fa[i]：i战舰的父亲，pre[i]：i战舰之前布置有多少战舰，num[i]：以i战舰为列首的一列共有多少战舰 

void re(int &x)//快速读入优化
{
	x=0;
	bool flag=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') flag|=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=flag ? -x : x;
}

int find(int x)
{
	if(fa[x]==x) return x;//直到找到自己的父亲就是自己，即使祖先 
	int fx=find(fa[x]); //递归寻找祖先
	pre[x]+=pre[fa[x]];//在find递归时，已经更新了x的祖先的pre，此时再更新x的pre值 
	return fa[x]=fx;//将自己的父亲直接赋为祖先，路径压缩优化 
}

void mix(int x,int y)
{
	int fx=find(x),fy=find(y);//找到各自的列首 
	fa[fx]=fy;//将前一列接到后一列尾部 
	pre[fx]+=num[fy];//先更新前一列列首之前布置的战舰数，多了后一列总战舰数那么多个战舰 
	num[fy]+=num[fx];//后一列总战舰数加上前一列的战舰数 
	num[fx]=0;//前一列的队首目前已不是队首了，清零 
}

int main()
{
	re(t);
	int i;//初始化每个战舰的父亲即为他自身，当前以他为列首的一列当然只有他自己一个战舰 
	for(i=1;i<=30000;i++) fa[i]=i,num[i]=1;
	while(t--)
	{
		cin>>c; re(a); re(b);//自己写时不知道为什么，若是c=getchar();则会“Too many or too few lines” 
		if(c=='M')
			mix(a,b);//将a那一列接到b那一列后 
		else
			if(find(a)!=find(b)) printf("-1\n");//找他们各自的祖先即列首，若不是同一个，则不在同一列 
			else
				printf("%d\n",pre[a]-pre[b]>0 ? pre[a]-pre[b]-1 : pre[b]-pre[a]-1);//用三目运算符确保大数减小数，再减一，即其间的战舰数 
	}
	return 0;
}
```

---

## 作者：q18921892 (赞：2)

本题我认为该设两个数组，一个是用来表示战舰在合并后的位置，一个是合并后的总长度。每次合并都更新战舰的位置和战舰所在那一列的长度，询问时可直接用abs(c[i]-c[j]-1)

```cpp
var f:array [1..30000] of integer;
    b,c:array [1..30000] of integer;
    t:longint;
    ch:char;
    i,j,p,q:integer;
    k:longint;
function find(x:integer):integer;
begin
  if f[x]=x then exit(x);
  find:=find(f[x]);
  c[x]:=c[x]+c[f[x]]-1;
  f[x]:=find;
end;
begin
  for i:=1 to 30000 do
  begin
    f[i]:=i;
    b[i]:=1;
    c[i]:=1;
  end;
  readln(t);
  for k:=1 to t do
  begin
    readln(ch,i,j);
    p:=find(i);
    q:=find(j);
    if ch='M' then
      begin
        f[p]:=q;
        c[p]:=b[q]+1;
        b[q]:=b[q]+b[p];
      end;
    if ch='C' then
      begin
        if p<>q then
          writeln(-1)
        else
          writeln(abs(c[i]-c[j])-1);
      end;
    end;
end.
```

---

## 作者：Mr_Skirt (赞：2)

## 带权并查集的标准题

不过还是需要一点技巧。我们设带权并查集的权$weight_i$为**从节点$i$到它的直接父节点需要经过几个战舰。**

假设两个战舰$i,j$，现在要把$i$所在队列接到$j$所在队列的尾部，我们可以观察一下它们权值的变化。$j$所在队列中的任何战舰的权值是不会变化的，而$i$所在队列的所有节点权值都会加上$j$所在队列的大小。

但是这样我们就会需要一个新的权值代表这个队列的总战舰数量，这并不好。

其实，利用并查集的路径压缩性质，我们只要把**战舰$i$所在队列队首的父节点设为$j$所在队列的最后一个战舰**，然后把$i$队列队首的权值设为1就行了。最后答案就是$abs(abs(weight_i - weight_j) - 1)$。

为什么这样做就可以了呢，因为在路径压缩的时候并查集会动态的更新$weight$的值，而头节点到它自己一直都是0，在连接到下一个的尾部的时候我们设为1就可以在下次$find$的时候获取正确的值了。由于是间隔，所以我们还需要减一。

虽然我们需要记录$tail$，也就是头节点所在队列的尾部元素，但是并不需要动态更新它，因为只有在连接的时候才会改变，所以还是不麻烦的。

以下是代码：

```cpp
#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <stack>
#include <unordered_map>
#include <vector>

using namespace std;

typedef long long ll;

const int INF = 2147483647;
const int INF2 = 0x3f3f3f3f;
const ll INF64 = 0x3f3f3f3f3f3f3f3f;
const double PI = 3.14159265358979323846;
const ll MOD = 1e9 + 7;
const ll TARGET = (1LL << 32) - 1LL;

template <typename T>
inline T read() {
    T X = 0, w = 0;
    char ch = 0;
    while (!isdigit(ch)) {
        w |= ch == '-';
        ch = getchar();
    }
    while (isdigit(ch)) X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();
    return w ? -X : X;
}

class UnionFindW {
   public:
    UnionFindW() {}
    inline int find(int x) {
        if (parent[x] != x) {
            // 记录下之前的父节点
            int pf = parent[x];
            parent[x] = find(parent[x]);
            // 动态更新权值
            weight[x] += weight[pf];
        }
        return parent[x];
    }
    bool same(int x, int y) { return find(x) == find(y); }
    void join(int x, int y, int w) {
        int f1 = find(x);
        int f2 = find(y);
        if (f1 == f2) return;
        parent[f1] = tail[f2];
        tail[f2] = tail[f1];
        weight[f1] = 1;
    }
    void clear(int n) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            weight[i] = 0;
            tail[i] = i;
        }
    }
    static const int N = 30005;
    int parent[N];

    // weight代表它比它的直接父节点多多少
    int weight[N];
    int tail[N];
};

const int MAXN = 100005;
int n, m, k;
int CASE = 1;
UnionFindW ufw;
int main() {
#ifdef LOCALLL
    freopen("in", "r", stdin);
    freopen("out", "w", stdout);
#endif
    scanf("%d", &n);
    ufw.clear(30005);
    while (n--) {
        char c;
        int x, y;
        scanf(" %c", &c);
        scanf("%d %d", &x, &y);
        if (c == 'M') {
            ufw.join(x, y, 1);
        } else {
            if (x == y)
                printf("0\n");
            else if (ufw.same(x, y)) {
                printf("%d\n", abs(abs(ufw.weight[x] - ufw.weight[y]) - 1));
            } else {
                printf("-1\n");
            }
        }
    }
    return 0;
}
```




---

## 作者：Azuree (赞：2)

[查看原题请戳这里](https://www.luogu.org/fe/problem/P1196)
# 算法思路
题目中一共给了合并和查询和两种操作，很显然我们可以用并查集来实现。但是，查询操作需要给出两个点之间的距离，那么我们怎么去统计这个量呢？
![](https://wflight.github.io/2019/07/12/%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4-%E9%A2%98%E8%A7%A3/example.png)
如图，我们可以发现，如果我们想要知道4号点到2号点的距离，如果不压缩路径，我们可以选择一步步去统计这两个点到祖先的距离，然后进行计算。但是，1e5的数据显然是不支持这个时间复杂度的。
那么，我们该怎么做呢？
答案就是用`加权并查集`。
加权并查集和朴素并查集的区别是并查集在统计某节点的父亲节点的同时，还统计该节点到ta的祖先节点的距离。这样，我们就可以进行路径压缩而不是只能一步一步往上跳。
附一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register

using namespace std;

int read()
{
	register int x = 0,f = 1;register char ch;
	ch = getchar();
	while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
	while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}
const int n = 30000;

int fa[100005],dis[100005],siz[100005],t,x,y;

char s;

int query(int x)
{
	if(fa[fa[x]] == fa[x]) return dis[x];
	return dis[x] + dis[query(fa[x])];
}

int find(int x)
{
	if(fa[x] == x) return x;
//	dis[x] = query(x);
	int ans = find(fa[x]);
	dis[x] = dis[fa[x]] + dis[x];
	fa[x] = ans;
	return ans;
}

int main()
{
	t = read();
	for(int i = 1; i <= n; i ++) fa[i] = i;
	for(int i = 1; i <= n; i ++) siz[i] = 1;
	for(int i = 1; i <= t; i ++)
	{
		cin >> s;
		x = read(); y = read();
		if(s == 'M')
		{
			int fx =  find(x),fy = find(y);
			if(find(x) != find(y))
			{
				dis[fx] = dis[fx] + siz[fy];
				siz[fy] += siz[fx];
				siz[fx] = 0;
				fa[fx] = fy;
			}
		}
		if(s == 'C')
		{
			if(find(x) != find(y))
			{
				printf("-1\n");
				continue;
			}
			if(x == y)
			{
				printf("0\n");
				continue;
			}
			printf("%d\n",abs(dis[x] - dis[y]) - 1);
		}
	}
    return 0;
}
```

---

## 作者：Han_Innocence (赞：2)

这算是模板题吧，相信大家都是来学习并查集的相关知识的，那我就从头开始讲，以基础知识为主


------------

解题思路：带权并查集+路径压缩

用dis数组储存某一节点到他所在队列队首的距离，最后用两个节点到节点距离的差值得出两点间距离


------------

Part I 
带权并查集

我们用fa[i]数组表示i节点的父亲，初始化为i
若某一个节点的fa等于他自己（fa[i]=i），说明这个节点还没有被移动过，他就是第i队列的队首
于是得到find函数
```cpp
int find(int x)
{
	if (fa[x]==x) return x;
	return find(fa[x]);
}
```

同时，用dis[i]表示i节点到他所在队列队首的距离，初始化为0。length[i]表示第i队列的长度（显然这一队列的队首为i），初始化为1。当移动X队列到Y后时，则有：

fa[x]=fa[y],dis[x]=length[y],length[y]+=length[x]

注意：我们已无法将其他队列移动到原x队列，故没有必要将length[x]改为0

于是得到move函数
```cpp
void move(int x,int y)
{
	int fx=find(x);
	int fy=find(y);
	fa[fx]=fy;
	dis[fx]+=length[fy];	
	length[fy]+=length[fx];
}
```


那么check函数就简单啦

```cpp
void check(int x,int y)
{
	int ffx=find(x); 
	int ffy=find(y); 
	if (ffx!=ffy)
	{printf("-1\n"); return;}
	printf("%d\n",abs(dis[x]-dis[y])-1);
}
```


以上程序整合后，期望得分60分。60%AC+40%TLE

那么，我们该如何优化呢？


------------

Part II 路径压缩

我们发现，当某一节点x在另一节点y上方，那么他、它永远在y上方，而且两点间距恒定。（因为我们不能把其他队列插入到它们中间）

利用这个性质，我们进行路径压缩

举个例子

fa[2]=1,fa[3]=2,fa[4]=3; 任意两点间距为1

压缩为：

fa[2]=1,dis[2]=1,fa[3]=1,dis[3]=2,fa[4]=1,dis[4]=3

这个过程我们用回溯实现，在一步步找到队列队首后，一步步原路返回，把每一节点的fa都改为队首，并相应的改变dis即可。于是得到优化后的find函数

```cpp
int find(int xx)
{
	if (fa[xx]==xx) return xx;
	int father=find(fa[xx]);
	dis[xx]+=dis[fa[xx]];
	fa[xx]=father;
	return father;
}
```



------------

完整代码，检验后AC
```cpp
#include<cstdio>
#include<iostream>
#include<cmath> 
#define num 30001
using namespace std;
int n,fa[30005],dis[30005],length[30005];
int read()
{
	int x=0,f=1; char c=getchar();
	while (c<'0' || c>'9') {if (c=='-') f=-1; c=getchar();}
	while (c>='0'&&c<='9') {x=(x<<3)+(x<<1)+(c^48); c=getchar();}
	return x*f;
}
int find(int xx)
{
	if (fa[xx]==xx) return xx;
	int father=find(fa[xx]);
	dis[xx]+=dis[fa[xx]];
	fa[xx]=father;
	return father;
}
void move(int x,int y)
{
	int fx=find(x);
	int fy=find(y);
	fa[fx]=fy;
	dis[fx]+=length[fy];	
	length[fy]+=length[fx];
}
void check(int x,int y)
{
	int ffx=find(x); 
	int ffy=find(y); 
	if (ffx!=ffy)
	{printf("-1\n"); return;}
	printf("%d\n",abs(dis[x]-dis[y])-1);
}
int main()
{
	n=read();
	for (int i=1;i<=num;i++) fa[i]=i;
	for (int i=1;i<=num;i++) length[i]=1;
	for (int w=1;w<=n;w++)
	{
		char c; cin>>c;
		int x=read(),y=read();
		if (c=='M') move(x,y);
		if (c=='C') check(x,y);
	}
	return 0;
}


```



------------

最后说明几点：

1、没有必要关注fa[i]到底是i节点的上几位，因为dis数组随之变化，加上上述性质，他已经覆盖了中间区域。

2、这是我第一次写题解，有bug疏漏请大家不要喷，有问题可以在评论区提问，我会常常关注。最后希望题解对大家有用，祝大家AC此题，AK IOI。

3、如有需Pascal代码请在评论区回复。

---

## 作者：寒鸽儿 (赞：2)

### 这是一道带权并查集的模板题简单介绍一下带权并查集，就是在并查集中加入一元(即下文中的d[]和size[]数组)或更多元,以维护更多的信息(在这里体现为战列舰的数量)。注意，这些信息都是针对边的信息，一般表示该节点(i)与直接父亲(fa[i])的关系，可以通过getfather操作的变形递归地维护祖宗到每一个节点地关系，同时路径压缩(此时信息仍然是描述该点和其直接父亲的，只是经过路径压缩后该点的直接父亲已经是其祖先，即集合的代表元)。在合并时也进行相应的操作来维护所定义的元的性质。当维护一个元的性质不易时可以考虑增加一个中间元(如本题的size[]),合并时维护其性质同时用以辅助另一元的性质的维护。具体的，推荐大家去读一下李煜东的进阶指南，写得非常妙。
### 就题而言，我们需要维护的内容是战列舰之间的舰的数目，这可以转化到两舰到其舰队最顶部的舰的距离之差-1。两舰到其最顶部的舰的距离，可以维护其到父亲节点的距离(d[]),在getf()操作中路径压缩递归地求得战列舰到其队首战列舰的距离。考虑到合并操作的维护困难，我们添加一个size[]数组，定义为以该舰为首的队列中舰的数量，包含该舰。因而在合并时可以借助size[]轻松维护d[]数组(请诸位自行思考，答案在un()函数中)，同时size[]在合并时可以轻易被维护，其他并查集操作也不影响size[]的值。
### 最后给出代码：
```cpp
#include <cstdio>
#include <cstring>

using namespace std;

bool gc() {
    char ch = getchar();
    while(ch != 'M' && ch != 'C') ch = getchar();
    return ch == 'M';
}

int fa[30001], size[30001], d[30001];

int getf(int i) {
    if(fa[i] == i) return i;
	int f = getf(fa[i]);
	d[i] += d[fa[i]];
	return fa[i] = f;
}

void un(int x, int y) {				//link x to y
    x =getf(x);
    y = getf(y);
    fa[x] = y;
    d[x] = size[y];
    size[y] += size[x];
}

int abs(int x) {
    return x > 0 ? x : -x;
}

int query(int x, int y) {
    int a = getf(x), b = getf(y);
    if(a != b) return -1;
    return abs(d[x]-d[y])-1;
}

int main() {
    int n, ope, p1, p2;
    scanf("%d", &n);
    fa[0] = 0;
    memset(d, 0, sizeof(d));
    for(int i = 1; i <= 30000; i++) fa[i] = i, size[i] = 1;
    while(n--) {
        ope = gc();
        scanf("%d %d", &p1, &p2);
        if(ope)
            un(p1, p2);
        else
            printf("%d\n", query(p1, p2));
    }
    return 0;
}
```

---

## 作者：codesonic (赞：2)

~~没想到我也能做NOI的题目qwq~~

这是一道比较裸的并查集，只是要求一边处理与队头的关系

于是只要新增一个数组\_num[]\_表示\_i\_与\_fa[i]\_的距离即可

除去这一点就是一个并查集模版了

附上代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int fa[30010],num[30010],size[30010];//fa[i]表示i的父亲，num[i]表示i与fa[i]的距离,size[i]表示i所在队列的大小

inline int find(int x)
{
    if(x!=fa[x]){
        int xx=fa[x];
        fa[x]=find(fa[x]);
        num[x]+=num[xx];
        size[x]=size[fa[x]];
    }
    return fa[x];
}

inline void merge(int x,int y)
{
    int xx=find(x),yy=find(y);
    if(xx==yy) return ;
    fa[xx]=yy;
    num[xx]=num[yy]+size[yy];
    size[yy]+=size[xx];
    size[xx]=size[yy];
}

inline int both(int x,int y)
{
    int xx=find(x),yy=find(y);
    if(xx!=yy)
        return -1;
    return abs(num[x]-num[y])-1;
}

int main()
{
    int t;
    scanf("%d",&t);
    for(int i=1;i<=30005;i++)
        fa[i]=i,size[i]=1,num[i]=0;
    for(int i=1;i<=t;i++){
        char c;
        int x,y;
        scanf(" %c ",&c);
        scanf("%d%d",&x,&y);
        if(c=='M') merge(x,y);
        else if(c=='C') printf("%d\n",both(x,y));
    }
    return 0;
}
```

---

## 作者：YangQuijote (赞：2)

这道题的数据规模很大，导致我们不能直接模拟，否则并查集变成链，肯定超时，于是被逼无奈使用路径压缩。但是一旦路径压缩就会破坏原有的排列结构，导致无法实时统计i与j之间有多少架飞船。但是题目在这里给我们开了一个方便之门，即不要求求出i与j之间具体是哪些飞船，只要求求出飞船的数量。由于飞船是严格地排成一列，就可以想到这样的方法：记录每架飞船到队首的距离，就能轻易算出两架飞船之间的飞船数量。这里我们用dth记录到队首的距离，dtt记录到队尾的距离（只有队首才更新到队尾的距离，方便两个队列合并时靠后的那个队列的原队首到现队首的距离用的）。用变量dth与fa配合起来，记录这个飞船到fa指向的飞船（不一定是目前的队首，有可能是原队首）的距离。路径压缩时，压缩fa的指向的同时累加dis即可。最后在实际计算时也要再做一次累加（即名为check的函数）。

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<cmath>
#include<stack>
using namespace std;
struct node
{
    int fa,dth,dtt;
}no[30010];
int find(int x)
{
    if(no[x].fa==x)
    {
        return x;
    }
    else
    {
        int mem=find(no[x].fa);
        no[x].dth+=no[no[x].fa].dth;
        no[x].fa=no[no[x].fa].fa;//压缩fa的指向的同时累加dis
        return mem;
    }
}
int check(int x)
{
    int cont=0;
    for(;;)
    {
        cont+=no[x].dth;
        x=no[x].fa;
        if(x==no[x].fa)
        {
            break;
        }
    }
    return cont;
}
int main()
{
    int t,i,x,y;
    char re;
    for(i=1;i<=30000;i++)
    {
        no[i].fa=i;
        no[i].dth=0;
        no[i].dtt=0;
    }
    scanf("%d",&t);
    for(i=1;i<=t;i++)
    {
        scanf("%c%c",&re,&re);
        scanf("%c%d%d",&re,&x,&y);
        if(re=='M')
        {
            int a,b;
            a=find(x);
            b=find(y);
            no[a].dth=no[b].dtt+1;
            no[b].dtt+=(no[a].dtt+1);//维护到队首距离与到队尾距离
            no[a].fa=b;
        }
        else
        {
            if(find(x)==find(y))
            {
                int a,b;
                a=check(x);
                b=check(y);
                printf("%d\n",(max(a,b)-min(a,b)-1));
            }
            else
            {
                printf("-1\n");
            }
        }
    }
    return 0;
}
```

---

## 作者：jins3599 (赞：1)

带权并查集模板

我们发现，如果这道题不要求求出两辆战车之间的战车数量的话，就是一道普通的并查集。

不过若加上这个问题，我们就需要让我们的并查集维护更多的信息了。

总共有哪些信息？

$sz[i]$代表以$i$为队头的车队数量。

$head[i]$代表从结点$i$到当前行的队头有多少车。

假设我们需要把第$u$行连到第$v$行

我们先找到每个车队的车头$fu$，$fv$。

其次，我们把$head[fu] += sz[fv].$

再其次，我们把$sz[fv]+=sz[fu].$

最后，连接两个结点$bin[fu]=fv.$

可是它的子节点咋办？我们在下次需要用到这个子节点的时候，会通过$find$进行更新。

如何更新？显然，我们在递归到祖宗回溯的时候，对每个结点累加，即$head[now]+=head[bin[now]].$

显然它的直接父亲已经在连接操作的时候更新完了，于是就可以直接进行上面的累加操作。

这样的话就可以对其进行动态的更新了。


```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 30000 + 5;

int bin[N] , sz[N] , head[N];

int find(int x) {
	if(bin[x] == x ) return x;
	int root = find(bin[x]);
	head[x] += head[bin[x]];
	bin[x] = root;
	return root;
}

int main () {
	int T;
	scanf("%d" , &T);
	for(int i = 1 ; i <= 30001 ; ++ i) bin[i] = i , sz[i] = 1;
	while(T -- ) {
		char opt;
		int u , v;
		cin >> opt >> u >> v;
		if(opt == 'M') {
			int fu = find(u) , fv = find(v);
			head[fu] += sz[fv];
			sz[fv] += sz[fu];
			bin[fu] = fv;
		} else {
			int fu = find(u) , fv = find(v);
			if(fu != fv) {puts("-1");}
			else {
				printf("%d\n" , abs(head[u] - head[v]) - 1);
			}
		}
	}
	return 0;
} 
```

---

## 作者：Bill845514379 (赞：1)

## 题意：
- 对于1到n的序列，有两种操作：
1. Mij,将i所在的队列加到j所在的队列中，	当然是从后面加，保证原队列的顺序不变。
1. Cij，查找i和j之间有多少个数，当然如果ij不在一个队列中，输出-1就行。
## 思路：
	

------------
- 有队列合并，队列查询，并查集肯定少不了，但是如何求i和j有多少个数，这就要用到带权并查集了，另外开一个数组记录每个点到根节点之间的距离，len数组吧，最终答案就是 len[i]+len[j]-1 ，记得减一因为不包含两个端点。


------------
- 这个带权并查集怎么写，很明显假如不用路径压缩，合并一次对这条链进行更新，还有查询是否在一个集合也是从头找到尾，这样的话会超时，复杂度是O(n^2)，n为3万，（实测路径压缩+记录路径，刚好能卡过，这样常数比较小而已，但如果加强数据上限还是会卡死的，~~有点玄（4e8的样子）~~）
	

------------
- 最终正解就是，路径压缩，每次合并对当前根节点（注意不是合并后的根节点）进行修改，合并，当前根节点的距离+=要合并队列的长度。但是有个问题，当前队列后面节点到根节点的距离并没有变，还是原来的，这只是对当前根节点进行了修改。这个问题在find函数中解决，每次find就对这个点到根节点的距离进行更新 **（条件是这个点是第一次find，也就是这个时候他的路径还没有被压缩，即 ff[x]!=ff[ff[x]] ,当然如果是第二次find，路径已经压缩过了，他到根节点的距离是不会变的）** ， len[x]+=len[ff[x]] ，其实就是把刚刚对根节点增加的长度分配到每个子节点上（**条件是使用find时，不使用find的子节点其实并没有分配，这也不影响最终的结果，就相当于按需分配）**

```
//AC代码 ：带权并查集

#include<stdio.h>
#include<cmath>
using namespace std;
#define maxn 30005
#define INF 1000000005
#define ll long long
//dis表示i队列的长度，len表示i到根节点的距离
int ff[maxn],dis[maxn],len[maxn];
  
int find(int x)
{
    if(ff[x]==x)
        return x;
    int t=find(ff[x]);
    len[x]+=len[ff[x]];
    return ff[x]=t;
}

void read(int &x)
{
    x=0;
    bool flag=0;
    char ch=getchar();
    if(ch=='-') flag=1;
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x*=10,x+=ch-'0',ch=getchar();
    if(flag) x=-x;
}

int main()
{
    int n;
    read(n);
    for(int i=0; i<=maxn; i++)
        ff[i]=i,dis[i]=1;

    for(int i=0; i<n; i++)
    {
        char str;
        scanf(" %c",&str);
        int x,y;
        read(x),read(y);
        int nx=find(x);
        int ny=find(y);
        if(str=='M')
        {
            if(nx!=ny)
            {
                ff[nx]=ny;
                len[nx]+=dis[ny];
                dis[ny]+=dis[nx];
                dis[nx]=1;
            }
        }
        else
        {
            if(nx!=ny)
            {
                printf("-1\n");
                continue;
            }
            if(len[x]>len[y])
                printf("%d\n",len[x]-len[y]-1);
            else
                printf("%d\n",len[y]-len[x]-1);
        }
    }
    return 0;
}


 //刚开始还不会带权并查集，水过去的代码
#include<bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(false)
#define maxn 30005
#define INF 1000000005
#define ll long long

int path[maxn];//记录路径
int ff[maxn],dis[maxn],out[maxn],len[maxn];
//out为i队列最外面的数字是什么

int find(int x)
{
    return x==ff[x]?x:ff[x]=find(ff[x]);
}

void read(int &x)
{
    x=0;
    bool flag=0;
    char ch=getchar();
    if(ch=='-') flag=1;
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x*=10,x+=ch-'0',ch=getchar();
    if(flag) x=-x;
}

int main()
{
    int n;
    read(n);
    for(int i=0; i<=maxn; i++)
        ff[i]=i,out[i]=i,dis[i]=1,path[i]=i;

    for(int i=0; i<n; i++)
    {
        char str;
        scanf(" %c",&str);
        int x,y;
        read(x),read(y);
        int nx=find(x);
        int ny=find(y);
        if(str=='M')
        {
            if(nx!=ny)
            {
                ff[nx]=ny;
                path[nx]=out[ny];
                int t=out[nx];
//对这条链的距离进行更新，所有值都更新了，所以慢啊
                while(t!=out[ny]) 
                {
                    len[t]+=dis[ny];
                    t=path[t];
                }
                out[ny]=out[nx];
                dis[ny]+=dis[nx];
                dis[nx]=1;
            }
        }
        else
        {
            if(nx!=ny)
                printf("-1\n");
            else
                printf("%d\n",abs(len[x]-len[y])-1);
        }

    }
    return 0;
}

```

```


---

## 作者：Xing_Mang (赞：1)

## 这道题乍一看有两个要求
### 1.判断两艘战舰是否在同一列中
### 2.计算两艘战舰之间有多少战舰
这道题特殊之处主要在第二个要求本蒟蒻看上面的大佬都是直接在线刚，但这道题可以离线结合前缀和有木有发现。废话少说，
步骤如下：
1. 先求出最终状态，标记每一列中每一艘战舰的序号（1-30000）

1. 给最终状态的每一列的每一艘战舰都标记在每一列的顺序号
1. 问哪两艘战舰之间的战舰数，只要把顺序号相减再abs减1就可以了
## ~~是不是理解起来相当简单~~
倒着想一想，如果将顺序标好的最终状态拆分，是不是拆分出的每一列的战舰的相对位置都没有改变，由于两艘战舰间的战舰数只与两战舰之间的顺序号之差有关，所以这样就可以很方便的O(1)计算出结果了
#### 至于要求一，只要简单的用并查集模拟判断一下是否在同一集合中就ok了
奉上AC代码
```
#include<iostream>
#include<cstdlib>
#include<vector>
using namespace std;
struct Com{
	char type;int x;int y;
};
struct Node{
	int val,rank;
	bool isHead=false;
	Node* next=0;
	Node* pre=0;
	Node* head=this;
};
vector<Com> M;
vector<Com> MC;
void addCom(char c,int a,int b){
	Com com;com.x=a;com.y=b;com.type=c;
	if(c=='M')M.push_back(com);
	MC.push_back(com);
}
const int MAX_N=3*100*100;
int P[MAX_N+50],K[MAX_N+50];
void init(int x){
	for(int i=1;i<=x;i++){
		P[i]=i;K[i]=0;
	}
}
int find(int x){
	if(x==P[x])return x;
	else return P[x]=find(P[x]);
}
void unite(int x,int y){
	if((x=find(x))==(y=find(y)))return;
	if(K[x]>K[y])P[y]=x;
	else{
		P[x]=y;
		if(K[x]==K[y])K[y]++;
	}
}
bool theSame(int x,int y){
	return find(x)==find(y);
}
Node* findHead(Node* node){
	if(node->pre==0)return node;
	else return node->head=findHead(node->head);
}
Node matrix[MAX_N+3];
Node* end[MAX_N+3];
int main(){
	ios::sync_with_stdio(false);
	int n;cin>>n;
	for(int i=0;i<n;i++){
		char c;int a,b;cin>>c>>a>>b;
		addCom(c,a,b);
	}
	for(int i=1;i<=3*100*100;i++){
		matrix[i].val=i;
		matrix[i].isHead=true;
		end[i]=&matrix[i];
	}
	for(int i=0;i<M.size();i++){
		Com com=M[i];int x=com.x;int y=com.y;
		x=findHead(&matrix[x])->val;y=findHead(&matrix[y])->val;
		matrix[x].isHead=false;
		end[y]->next=&matrix[x];
		matrix[x].pre=end[y];
		matrix[x].head=end[y]->head;
		end[y]=end[x];
	}
	int count=0;
	for(int i=1;i<=MAX_N;i++){
		Node* node=&matrix[i];
		if(node->isHead){
			node->rank=count++;
			while(node->next!=0){
				node=node->next;
				node->rank=count++;
			}
		}
	}
	init(MAX_N+2);
	for(int i=0;i<MC.size();i++){
		Com com=MC[i];
		if(com.type=='M')unite(com.x,com.y);
		if(com.type=='C'){
			if(theSame(com.x,com.y))
			cout<<abs(matrix[com.x].rank-matrix[com.y].rank)-1<<endl;
			else cout<<-1<<endl;
		}
	}
}


```


---

## 作者：NewSjf (赞：1)

看到这道题感觉慢慢的维护序列的感觉（~~完全没想起带权并查集~~）  
于是写了~~30000~~一棵非旋Treap  
舰队调用就找到编号对应的根节点,然后把两颗Treap合并
查询就看两个编号对应的平衡树根节点是不是一样的,不一样就返回-1
否之就统计  
非旋Treap并不能像splay换根,所以这里要绕一圈  
我们找这个编号对应的结点在中序遍历中的顺序就好    
相比与普通Treap多维护了两个东西,具体看代码就好  
除了order_of_key不算是非旋Treap维护序列时的常规操作以外,其他都挺正常的(毕竟没有旋转)  
不过我倒是比较好奇Treap能不能既能旋转又分裂合并  
代码60行  
总时间~~不开O2 1220ms~~  
~~开O2~~  976ms  
~~非旋Treap本来常数就有点大~~
```cpp
#include<iostream>
#include<cstdlib>
struct node{int val,key,size,l,r,f;}t[300001];
int maps[300001],root,tot,n;     //maps 储存val对应的结点编号tot
using namespace std;
int New(int val){t[++tot]=(node){val,rand(),1,0,0};return (maps[val]=tot);} //每个值和平衡树结点标号一一对应并且不会变(在本题中如此)
int find_root(int val){return t[maps[val]].f?find_root(t[maps[val]].f):maps[val];}  //往根节点一直跳找到根节点,Treap合并必须找到两棵树的根节点
void update(int now)
{
    t[now].size=t[t[now].l].size+t[t[now].r].size+1;
    t[t[now].l].f=t[t[now].r].f=now;     //更新父亲,父子关系只会在split和merge的过程中改变
}
void split(int now,int &x,int&y,int rank)                                                      
{
    if(!now){x=y=0;return;}
    if(t[t[now].l].size>=rank)y=now,split(t[now].l,x,t[y].l,rank);
    else x=now,split(t[now].r,t[x].r,y,rank-t[t[now].l].size-1);
    update(now);
}
void merge(int&now,int x,int y)
{
    if(!x||!y){now=x+y;return;}
    if(t[x].key<t[y].key)now=x,merge(t[now].r,t[x].r,y);
    else now=y,merge(t[now].l,x,t[y].l);
    update(now);
}
void Merge(int l_val,int r_val)   //找到两个编号对应树的根节点,然后合并这两棵树,根节点为x
{                                      //这样的话x就在y"上方",对应平衡树就是序列的右方,这样序列左边有多少个数字,z"下方"就有多少个战舰 
    int x=find_root(l_val),y=find_root(r_val);
    merge(x,y,x);
}
int order_of_key(int val)                                 //对中序遍历就得到序列,现在需要根据val找到其在Treap中序遍历的顺序
{
    int now=maps[val],ans=t[t[maps[val]].l].size+1;     //如果该结点为左子树,那么就加上他的左子树和父结点的大小,最终结果就是val在中序遍历中的结果,ans-1就是序列终在val左边的结点数
    while(t[now].f)                                     
    {
        if(t[t[now].f].r==now)ans+=t[t[t[now].f].l].size+1;
        now=t[now].f;
    }
    return ans;
}
int Query(int l_pos,int r_pos)
{
	int x=find_root(l_pos),y=find_root(r_pos);
	if(x!=y)return -1;
	else return abs(order_of_key(l_pos)-order_of_key(r_pos))-1;
}
int main()
{
    for(int i=1;i<=30000;i++)New(i); //开局30000棵树
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        char ch;int x,y;
        cin>>ch>>x>>y;
		if(ch=='M')Merge(x,y);
		if(ch=='C')cout<<Query(x,y)<<endl; 
    }
} 
```
[点击领取双倍经验](https://www.luogu.org/problem/P2342)


---

## 作者：在想Peach (赞：1)

半暴力做法，吸羊可以过QAQ。

用队列所在位置来编排序号以供查询，转移时直接重新编排序号。

询问时输出 ：    ｜x的序号-y的序号｜-1    或 -1（find查询不是同一个祖宗）

更新序号大概是这样，比如有队列1 2 3 4，你要将1 2 3放到后面，意味着每个数前面都多了要去的队列的所有数的数量，即更新为1+4=5，2+4=6，3+4=7。

代码注释会详细解释。
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
using namespace std;
int n,x,y,f[3000005][2],la[3000005],fa[3000005];//f的两个存储0存储自己父亲，1存储自己在队伍的位置，la是所在队列的最后一个数 
char p;
int read(){//好像加不加都一样 
    int rv=0,fh=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') fh=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        rv=(rv<<1)+(rv<<3)+c-'0';
        c=getchar();
    }
    return rv*fh;
}
int find(int x)//只用来快速找祖先 
{
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		f[i][0]=i;//和后面fa是一样的，不过用途不同 
		f[i][1]=1;//自己是第一个 
		la[i]=i;//自己是最后 
		fa[i]=i;//初始化 
	}
	while(n--)
	{
		scanf("%s",&p);x=read();y=read();
		if(p=='M')
		{
		int fax=find(x),fay=find(y),k=f[la[fay]][1];//k是y所在列的最后一个数的序号，即此数列个数 。 
		for(int i=la[fax];;i=f[i][0])
		{
		f[i][1]+=k;//自己前方多了k个战舰 
		if(i==fax)break;//不再继续更新 
		}
		f[fax][0]=la[fay];//更新自己的父亲用作后继更新 
		fa[fax]=fay;//直接换祖宗用作找祖先 
		la[fay]=la[fax];//y所在列的最后一个数变成x所在列的最后一个数 
		}
		else
		{
			if(find(x)!=find(y)){cout<<-1<<endl;continue;}//不是一个祖先 
			cout<<abs(f[x][1]-f[y][1])-1<<endl;//输出序号差值 
		 } 
	}
	return 0;
}
```


---

## 作者：人殇物已非 (赞：1)

一道有趣的题。

这题大眼睛一看就感觉并查集完美的解决了题目要求的合并操作，但是，并查集只是一个集合而已，在一个集合里面如何做到查询题目要求的“之间”的个数呢？

不妨想想并查集的图形本质。我们发现是一颗树，如果没有进行路径压缩的话，就会很好的有一个儿子和父亲节点的关系，那么，我们利用这一点正好解决这个问题。

我们只要在并查集上加入“每个节点到根有几个元素”，然后类似前缀和一样每次查询的时候做差就可以求出了。

这个东西显然可以跟着路径压缩一起合并起来，所以还是并查集的复杂度。$O(α(n))$

有一个很有趣的点，就是本来我们需要一个$d(dis)$数组保存路径长度，而这个东西的维护显然自己维护会很麻烦，可以加上一个$num$数组保存一下当前集合的元素个数，然后用$num$去不断更新$d$的值就可以了。

而我们发现，$num$的值虽然重要，但是每次我们其实只要维护好接上的那个集合去进一步更新就可以了，原集合的$num$随便怎么搞都没问题，我们可以既理解为$num[i]$是保存的第i个集合的元素，被拿走的集合$num[i]=0$，也可以理解为$num[i]$保存的是第i个元素所在集合的元素个数，然后$num[i]=num[j]$，不会影响答案。
### $code:$
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=30010;
int fa[maxn];
int d[maxn],num[maxn];
int find(int x){
    if(fa[x]==x) return x;
    int fat=fa[x];
    fa[x]=find(fa[x]);
    d[x]+=d[fat];
    num[x]=num[fa[x]];
    return fa[x];
}
inline void unionn(int x,int y){
    fa[x]=y;
    d[x]+=num[y];
/*1:*/num[x]+=num[y];
    num[y]=num[x];
/*2:*///num[y]+=num[x];
    //num[x]=0;
}
int T;
int main(){
    cin>>T;
    for(int i=1;i<=maxn-1;i++) fa[i]=i,num[i]=1;
    while(T--){
        char op;int i,j;
        cin>>op>>i>>j;
        if(op=='M'){
            int fi=find(i),fj=find(j);
            unionn(fi,fj);//把i接j 
        }
        else{
            int fi=find(i),fj=find(j);
            if(fi!=fj){
                puts("-1");
            }
            else printf("%d\n",abs(d[i]-d[j])-1);
        }
    }
    return 0;
}

```

---

## 作者：Creeper_LKF (赞：1)

其实思路和楼下差不多，也是维护一个前面和一个后面的人的个数，用后面的个数更新前面的个数，用前面的个数在Get\_Father中统计答案即可。

但是我直接在路径压缩里面直接把父亲压到了根节点上，于是我们的front的值不需要额外再在从当前的点更新到链上，于是就可以把路径压得更快。算个优化吧





```cpp
#include <cstdio>
#include <cctype>
#define MAXN 60000
using namespace std;
inline char get_char(){
    static char buf[1000001], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1 ++;
}
inline int read(){
    int num = 0;
    char c;
    while (isspace(c = get_char()));
    while (num = num * 10 + c - 48, isdigit(c = get_char()));
    return num;
}
inline char get_ch(){
    char c;
    while(!isalpha(c = get_char()));
    return c;
}
inline void swap(int &a,int &b){
    int t = a;
    a = b;
    b = t;
}
int father[MAXN], front[MAXN], back[MAXN];
inline int Get_Father(int u){
    if(u == father[u]) return u;
    int fa = Get_Father(father[u]);
    front[u] += front[father[u]];//中间的关系应该是累加的
    father[u] = father[fa];//直接压缩在根上
    return fa;
}
inline void Merge(int u, int v){
    u = Get_Father(u), v = Get_Father(v);
    front[u] = back[v] + 1;//此时front已更新
    back[v] += back[u] + 1;//所以通过back更新
    father[u] = v;
}
inline int Query(int u, int v){
    int fu = Get_Father(u), fv = Get_Father(v);
    if(fu != fv) return -1;
    int valu = front[u], valv = front[v];//直接压到了根，所以直接去front即可
    if(valu < valv) swap(valu, valv);
    return valu - valv - 1;//减去重复
}
int main(){
    int n = read();
    for(int i = 1; i <= 30000; i++) father[i] = i;
    for(int i = 1; i <= n; i++){
        char con = get_ch();
        int x = read(), y = read();
        if(con == 'M') Merge(x, y);
        else printf("%d\n", Query(x, y));
    }
    return 0;
}
```

---

## 作者：46days (赞：1)

本题考查的依然是并查集，并且和食物链极为相似，思维难度还要低些。

对于每一艘战舰，用三个数组表示三个状态，father[i]表示i的父节点，front[i]表示i前面有多少艘，behind[i]表示i后面(包括自己)有多少艘。初始状态father[i]=i,front[i]=0,behind[i]=1;








    
```cpp
int find(int x)//查找x所在集合(列)
{
    if(father[x]==x)return x;
    int fx=find(father[x]);
    front[x]=front[x]+front[father[x]];//路径压缩之前，要先计算出x前面的战舰数，等于找它时遍历到的所有点的front值之和
    return father[x]=fx;//路径压缩
}
void unio(int x,int y)//合并x,y所在集合
{
     int fx=find(x);
     int fy=find(y);
     father[fx]=fy;
     front[fx]=behind[fy];//x根前面的战舰数正好等于y根后面的战舰数
     behind[fy]+=behind[fx];//y根后面的战舰数等于原来的加上x根后面的战舰数
}
void ask(int x,int y)//询问x,y之间的战舰数
{
     int fx=find(x);
     int fy=find(y);
     if(fx==fy)//如果在同一列
     {
         ans=abs(front[x]-front[y])-1;//x,y之间战舰数等于x前面的减去y前面的-1
         printf("%d\n",ans);
     }
     else printf(“-1\n”);//不在同一列
}
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
using namespace std;
const int maxn=30000+10;
int father[maxn],front[maxn],behind[maxn];
int t,ans;
int find(int x)
{
    if(father[x]==x)return x;
    int fx=find(father[x]);
    front[x]=front[x]+front[father[x]];
    return father[x]=fx;
}
void unio(int x,int y)
{
     int fx=find(x);
     int fy=find(y);
     father[fx]=fy;
     front[fx]=behind[fy];
     behind[fy]+=behind[fx];
}
void ask(int x,int y)
{
     int fx=find(x);
     int fy=find(y);
     if(fx==fy)
     {
         ans=abs(front[x]-front[y])-1;
         printf("%d\n",ans);
     }
     else printf("-1\n");
}
void work()
{
     char s;
     int a,b;
     for(int i=1;i<=30000;i++)
     {
        father[i]=i;
        front[i]=0;
        behind[i]=1;
     }
     scanf("%d\n",&t);
     for(int i=1;i<=t;i++)
     {
         scanf("%c %d%d\n",&s,&a,&b);
         if(s=='M')unio(a,b);
         else ask(a,b);
     }
}
int main()
{
    work();
    //while(1);
    return 0;
}
```

---

## 作者：QWsin (赞：1)

**
加权并查集

对于每个节点x记录父亲 p[x] 以及对于父亲的距离value[x] (两船间距离为1)

对于每列 i 记录一个num[i]表示该列船的个数

若操作为 M  x y则   合并x  y所在集合

具体方法  （设fx为x所在集合的根  fy类似） p[fx]=fy  这时fx相对fy的距离就是num[fy]

所以 value[fx]=num[fy]  num[fy]+=num[fx] num[fx]=0

若操作为 C x y 则路径压缩之后  输出abs(value[x]-value[y]-1)

**
```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=30000+10;

int p[maxn],value[maxn],num[maxn];
int findset(int x,int &pson)                       //返回 value[x]  p数组的处理用int &完成
{
    if(p[x]==x)
    {
        pson=x;return 0;
    }
    else 
    {
        value[x]+=findset(p[x],p[x]);
        pson=p[x];
        return value[x];
    }
}

void change(int x,int y)
{
    int fx,fy;
    findset(x,fx);
    findset(y,fy);
    p[fx]=fy;
    value[fx]=num[fy];
    num[fy]+=num[fx];
    num[fx]=0;
}

void ask(int x,int y)
{
    int fx,fy;
    findset(x,fx);
    findset(y,fy);
    if(fx!=fy)printf("-1\n");
    else printf("%d\n",abs(value[x]-value[y])-1);
    return ;
}

int main()
{
    int T;cin>>T;
    char ins[10];
    int x,y;
    for(int i=1;i<=maxn-10;i++) p[i]=i,num[i]=1;
    while(T--)
    {
        scanf("%s%d%d",ins,&x,&y);
        if(ins[0]=='M') change(x,y);
        else ask(x,y);
    }
    return 0;
}


```

---


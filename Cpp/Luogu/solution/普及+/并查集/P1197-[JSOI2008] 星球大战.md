# [JSOI2008] 星球大战

## 题目描述

很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。

某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。

但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。

现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le m \le 2\times 10^5$，$1\le n \le 2m$，$x \neq y$。

[JSOI2008]


## 样例 #1

### 输入

```
8 13
0 1
1 6
6 5
5 0
0 6
1 2
2 3
3 4
4 5
7 1
7 2
7 6
3 6
5
1
6
3
5
7
```

### 输出

```
1
1
1
2
3
3```

# 题解

## 作者：碳六灵 (赞：235)

这道题看似很长其实也不是十分的难

如果我们去正这摧毁 想想都有点困难

要不 我们使用逆向思维？

没错 这道题就把摧毁转换成修建~~（和平就是好）~~

利用并查集判断联通就好了

```cpp
#include<iostream>
#include<cstdio>
#define f(i,a,b) for(register int i=a;i<=b;i++)
#define fd(i,a,b) for(register int i=a;i>=b;i--)
using namespace std;
int k,n,m,head[400002],tot,broken[400002],ans[400003];
int father[400003];
struct Node
{
    int next,node,from;
}h[400002];
inline void Add_Node(int u,int v)
{
    h[++tot].from=u;
    h[tot].next=head[u];
    head[u]=tot;
    h[tot].node=v;
}
bool Broken[400001];
inline int Get_father(int x)
{
    if(father[x]==x)    return x;
    return father[x]=Get_father(father[x]);
    //你爸爸的爸爸就是你的爸爸——反查理马特——并查集 
}
inline void hb(int u,int v)
{
    u=Get_father(u),v=Get_father(v);
    if(u!=v)    father[v]=u;
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    f(i,0,n)
        father[i]=i,head[i]=-1;//并查集初始化 
    f(i,1,m)
    {
        int x,y;
        cin>>x>>y;
        Add_Node(x,y);//储存图 
        Add_Node(y,x);//由于无向图存两遍 
    }
    cin>>k;
    f(i,1,k)
    {
        cin>>broken[i];
        Broken[broken[i]]=1;//标记砸坏了 
    }
    int total=n-k;//初始化为所有点都是单独存在的 
    f(i,1,2*m)//有2*m个边 
        if(!Broken[h[i].from] && !Broken[h[i].node] && Get_father(h[i].from)!=Get_father(h[i].node))
		{//要是起点和终点都没砸坏 而且他们并没有联通
            total--;//连一条边 减一个联通体 
            hb(h[i].from,h[i].node);
        }
    ans[k+1]=total;//当前就是最后一次破坏后的个数 
    fd(i,k,1)
    {
        //total=0 //这里不需要初始化 需要从上一次的废墟上修建 
        total++;//修复一个点 联通体+1 
        Broken[broken[i]]=0;//修复 
        for(int j=head[broken[i]];j!=-1;j=h[j].next)//枚举每一个子点 
        {
            if(!Broken[h[j].node] && Get_father(broken[i])!=Get_father(h[j].node))
            {
                total--;//连一边减一个联通块 
                hb(broken[i],h[j].node);//合并这两个点 
            }
        }
        ans[i]=total;
    }
    f(i,1,k+1)    cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：花开依然爱Qu (赞：91)


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXI=4e5+4;
int f[MAXI],head[MAXI],h[MAXI],ans[MAXI],En=0;//f为并查集，h为打击点存储的数组，ans为每次打击后的答案 
bool e[MAXI];            //e来判断是否被打击掉 
int find(int x)
{
    if(x!=f[x]) f[x]=find(f[x]); //并查集基本函数 
    return f[x];
}
struct edge
{
    int from;
    int to;                 //定义一个结构体来存储邻接表 
    int next;
}a[MAXI];
void insert(int u,int v)
{                             //邻接表存储数据 
    a[En].from=u;
    a[En].next=head[u];    
    a[En].to=v;
    head[u]=En;
    En++;
}
int main()
{
    int n,m,k,x,y,tot,i,u;
    cin>>n>>m;
    for(i=0;i<n;++i) 
    {
        f[i]=i;
        head[i]=-1;
    }
    for(i=0;i<m;++i)
    {
        cin>>x>>y;
        insert(x,y);insert(y,x);         //双向存储数据
    }
    cin>>k;
    tot=n-k;    //打击k次后所剩下的点 
    for(i=1;i<=k;i++)
    {
        cin>>x;
        e[x]=true;    //被打击掉后就true，并把打击的点存储到h中 
        h[i]=x;
    }
    for(i=0;i<2*m;i++)
    {
        if(e[a[i].from]==false&&e[a[i].to]==false) //如果都没有被打击 
        {
            if(find(a[i].from)!=find(a[i].to))    //且之前没有连通 
            {
                tot--;            //合并这两个点并在总数减去一个 
                f[find(a[i].from)]=f[find(a[i].to)];
            }
        }
    }
    ans[k+1]=tot;  //这时为打击k次之后所剩下的连通块 
    for(int t=k;t>=1;t--)  //从后往前“修复” 
    {
        u=h[t]; 
        tot++;   //因为“修复”这个点所以多了一个点，现在总数加 1 
        e[u]=false;  //false表示这个点没有被打击 
        for(i=head[u];i!=-1;i=a[i].next) //邻接表遍历它所连着的点 
        {
            if(e[a[i].to]==false&&f[find(u)]!=f[find(a[i].to)]) //如果被连通的点没有被打击并且之前没有连通 
            {
                tot--;  //合并 
                f[find(a[i].to)]=f[find(u)];  //注意尽量不要到过来赋值，这样会不断改变father 
            }
        }
        ans[t]=tot; //每“修复”一个点后的有的连通块 
    }
    for(i=1;i<=k+1;++i) cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：Golden_Winter (赞：72)

读完题目，我们首先会想到每次删去一个点，然后重新建图，算出联通块的个数。然而，这根本不信，时间上过不去，这时就得让我们将头旋转180度，从后往前处理，也就是我们经常用的接边了。当然，再接边前需要预处理，当前这条边应当在什么时候接上，给边标上序号，然后依次处理。最后逆序输出，就可以啦啦啦。如果还不懂，请看代码。

PS：帝国攻占的地盘不算是反抗军的地盘。

```CPP
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define MAXN 200005
using namespace std;
int n,m,fa[MAXN*2],K,D[MAXN*2],vis[MAXN*2],ans[2*MAXN],num;
//num表示总联通块的个数，ans[]记住答案 ，vis[]给点标号 ，D[]被攻占的点 
struct xcw{
    int x,y,c;//x,y表示这条边的两端点，c表示这条边的序号 
    bool operator <(const xcw b)const{return c<b.c;}//按序号从小到大排序 
}a[MAXN];
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-48,ch=getchar();
    return ret*f;
}
int get(int x){return fa[x]==x?x:fa[x]=get(fa[x]);}
void mer(int x,int y){
    int fx=get(x),fy=get(y);
    if(fx!=fy) fa[fx]=fy,num--;//两联通块合并，总联通块num-- 
}
int main(){
//    freopen("a.in","r",stdin);
//    freopen("a.out","w",stdout);
    n=read();m=read();num=n;
    for(int i=0;i<n;i++) fa[i]=i;
    for(int i=1;i<=m;i++) a[i]=(xcw){read(),read(),0};
    K=read();
    for(int i=1;i<=K;i++) vis[D[i]=read()]=K-i+1;//给点标号，从大到小 
    for(int i=1;i<=m;i++) a[i].c=max(vis[a[i].x],vis[a[i].y]);//当前边的序号是两个点中最大的那个 
    sort(a+1,a+1+m);//给点按序号大小排序，方便处理，优化效率 
    for(int i=0,j=1;i<=K;i++){//枚举被攻占的星球序号 
        for(;a[j].c==i;j++) mer(a[j].x,a[j].y);//将当前序号全部合并 
        ans[i]=num-(K-i);//K-i是帝国攻占的星球个数（因为是逆序处理的） 
    }
    for(int i=K;i>=0;i--) printf("%d\n",ans[i]);//逆序输出 
    return 0;
}
```

---

## 作者：初见月 (赞：53)

	这道题虽然是江苏省选，但是题目实际写起来，只要用一个并查集就好了。
    但是如果按照常规思路的话，并查集的删点操作是很难实现的（至少本蒟蒻写不出来），所以我们可以采用逆向思维，将“合并 -> 拆毁” 改为“拆毁 -> 修复”。
    大致思路如下：
	First of all ，我们先将所有的点读入，然后存好;
    Next , 我们把所有要摧毁的点也读入，用一个数组存好；
    Moreover ， 我们逆向回推，假如所有的要被摧毁的点都已经被摧毁，所以我们先将
    所有的要被摧毁的点摧毁，并且将并查集合并好，用一个变量tot记录
    合并后的连通块的个数（具体操作，注释里有），这就是摧毁完后最
    后的答案；
    In the end ，我们从最后一次被摧毁的点开始进行“时光倒流”，就
    是让被摧毁的点一个个加入回这个并查集中（标准的并查集加点操作
    啦）,并且不断合并，并记录连块的个数，用ans数组存下
```cpp
#include<bits/stdc++.h>
using namespace std ;

const int N = 4e5 + 4 ;//定义数组

bool e[N] ;//用于标记这个点有没有被摧毁
int n , m , k , tot , x , y ;
int En , fa[N] , head[N] , broken[N] , ans[N] ;
//En和head数组是链式前向星存图时用的 ，fa数组是并查集 ，broken数组是用于记录被摧毁的点 ，ans数组是用于记录答案
struct slw{
	int from , next , to ;
} edge[N] ;//结构体用于链式前向星（不要问我为什么叫“slw”，人名）
// inline int read(){
// 	char ch = getchar() ; 
// 	int num = 0 , f = -1 ;
// 	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1 ; ch = getchar(); }
// 	while(ch >= '0' && ch <= '9'){ num = num * 10 + (ch - '0') ; ch = getchar(); }
// 	return num * f ;
// }
//这是快读 ， 虽然我不太喜欢用但还是写上了，方便喜欢快读的巨巨直接复制
inline int insert(int u , int v){
	edge[++ En].from = u ;
	edge[En].next = head[u] ;
	edge[En].to = v ;
	head[u] = En ;
}//链式前向星存图
inline int find(int i){ return fa[i] == i ? i : fa[i] = find(fa[i]) ; }
//并查集基本操作，用于取得对应点的父节点，记得加优化，不然会超时
int main(void){
	scanf("%d%d",&n,&m);
	for(int i = 1 ; i <= n ; i ++)
		fa[i] = i;
	//并查集初始化

	for(int i = 1 ; i <= m ; i ++){
		scanf("%d%d",&x,&y);
		insert(x , y) , insert(y , x);
	}//读入所有的点并用链式前向星存图，因为是无向图，所以要进行双向存图
	scanf("%d",&k);
	tot = n - k ;//tot是还剩下的连通块的个数，最开始没有联通时每一个点是一个连通块
	for(int i = 1 ; i <= k ; i ++){
		scanf("%d",&x);
		e[x] = true ;//标记这个点已经被摧毁
		broken[i] = x ;//记录这个被摧毁的点
	}
	for(int i = 1 ; i <= m * 2 ; i ++){
		if(e[edge[i].from] == false && e[edge[i].to] == false){
			//如果这两个点都没有被摧毁
			if(fa[find(edge[i].from)] != fa[find(edge[i].to)]){
				//并且这两个点之前没有合并
				//所以将这两个点合并到同一个连通块中
				tot -- ;//合并后连通块的个数少一
				fa[find(edge[i].from)] = fa[find(edge[i].to)];//合并
			}
		}
	}
	ans[k + 1] = tot ;//所有要被摧毁的点都被摧毁完后剩下的连通块的个数
	for(int i = k ; i >= 1 ; i --){//从后往前让“时光倒流”
		x = broken[i] ;
		tot ++ ;//因为修复了一个点，所以连通块的个数加一
		e[x] = false ;//修复
		for(int j = head[x] ; j != 0 ; j = edge[j].next){
		//链式前向星的dfs，查找与其相连的点
			if(e[edge[j].to] == false && fa[find(x)] != fa[find(edge[j].to)]){
				//如果与这个被修复点联通的点没有被摧毁且它们两个点没有联通
				tot -- ;//连通后连通块的个数减少一
				fa[find(x)] = fa[find(edge[j].to)] ;//合并
			}
		}
		ans[i] = tot ;//修复完这个点后，连通块的个数
	}
	for(int i = 1 ; i <= k + 1 ; i ++)
		printf("%d\n",ans[i]);//输出
	return 0;
}
```


---

## 作者：A天天t (赞：29)

并查集，逆序做（即先假设给的k个星球全都被炸，求出此时的联通块个数，就是经过k次打击的联通块个数。然后再加上最后一个被炸的星球，就求出了经过k-1次打击的联通块个数。。。以此类推，最后把所有点都加进去，就求出了经过0次打击后连同块个数）






        

```cpp
type 
int=longint;
point=^note; // 点太多，用链表储存
note=record
    ends:int;
    next:point;
    end;
const 
mm=200000;
mn=400000;
var 
x,y,n,m,i,ans,k,u,ans0:int;
p:array[1..mn]of point;
a:array[1..mn]of int;
hui:array[1..mn]of boolean;
f:array[1..mn]of int;
ansi:array[1..mn]of int;
procedure make(x,y:int);
var t:point;
begin 
t:=p[x];
new(p[x]);
p[x]^.ends:=y;
p[x]^.next:=t;
end;
function fa(x:int):int;
begin 
if f[x]<>x then f[x]:=fa(f[x]);
exit(f[x]);
end;
procedure dodo(x:int);  并入编号为x的点（并查集）
var t:point;
u:int;
begin 
        t:=p[x];
        while t<>nil do 
            begin 
            u:=t^.ends;
            if not hui[u] then 
                begin     
                x:=fa(x);y:=fa(u);
                if x<>y then 
                    begin f[y]:=x; ans:=ans-1; end;   
                end;
                t:=t^.next;
            end;
end;
begin 
readln(n,m);
ans:=n;
for i:=1 to n do f[i]:=i;
for i:=1 to m do 
    begin 
    readln(x,y);
    make(x,y);
    make(y,x);
    end;
readln(k);
for i:=1 to k do  
    begin 
    readln(a[i]);
    hui[a[i]]:=true;
    end;
for i:=0 to n-1 do 
    if not hui[i] then dodo(i);
ans0:=ans-k;  // 别忘了有k个星球被炸了，不存在了，也不用考虑什么联通块了，减掉
for i:=k downto 1 do 
    begin 
    hui[a[i]]:=false;
    dodo(a[i]);
    ansi[i]:=ans-i+1;
    end;
for i:=1 to k do writeln(ansi[i]);
writeln(ans0);
end.

```

---

## 作者：yizimi远欣 (赞：24)


## 主要思路：逆向思维

看到题目，第一个感觉，，，

### 连通块？？？

我刚学过的搜索呢？？？深搜广搜都可以啊QwQ！

但很多人都被困在了这个攻占星球（也就是去点）上。

如果再仔细看下题目，发现可以离线做这道题。

那么方法来了：

我们是不是可以把所有的边存下来，把被攻占的星球的顺序存下来，先把所有两端都没有被攻占的边加上，先求一遍连通块个数。然后反向的加点加边，边加边边求连通块个数，把答案反向存下来，然后正向输出。

这题结束了（伪）。于是代码如下：

### 代码1（20分）：

##### 代码解释在最后的代码中

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 400400
#define inf 1 << 30
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
#define bson l, r, rt
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
inline void write(int x){
    if (x < 0)putchar('-'),x = -x;
    if (x > 9)write(x / 10);
    putchar(x % 10 + '0');
}
//This is AC head above...
int ans[mn], n, m, k;
struct edge{
    int v,nxt/*,w*/;
} e[mn<<1];
int h[mn],p;
inline void add(int a,int b/*,int c*/){
    p++;
    e[p].nxt=h[a];
    h[a]=p;
    e[p].v=b;
    //e[p].w=c;
}
int usd[mn];
pair<int, int> ee[mn];
bool not_alive[mn], vis[mn], not_in[mn];
void dfs(int x){
    if(vis[x] && !not_alive[x])
        return;
    vis[x] = true;
    rep(i,x){
        if(!vis[e[i].v] && !not_alive[e[i].v])
            dfs(e[i].v);
    }
}
int main(){
    n = read();
    m = read();
    go(i,1,m,1){
        ee[i].first = read();
        ee[i].second = read();
    }
    k = read();
    memset(not_alive, false, sizeof(not_alive));
    fo(i,k,1,1){
        usd[i] = read();
        not_alive[usd[i]] = true;
    }
    //cout << "\n";
    go(i, 1, m, 1){
        if (!not_alive[ee[i].first] && !not_alive[ee[i].second]){
            add(ee[i].first, ee[i].second);
            add(ee[i].second, ee[i].first);
            //cout << "111111111111111" << "\n";
            //cout << ee[i].first << " " << ee[i].second << "\n";
        }else{
            not_in[i] = true;
        }
    }

    int _ans = 0;

    memset(vis, false, sizeof(vis));
    _ans = 0;
    go(i,0,n-1,1){
        if(!vis[i] && !not_alive[i]){
            dfs(i);
            _ans++;
        }
    }
    ans[k + 1] = _ans;

    go(i,1,k,1){
        not_alive[usd[i]] = false;
        go(i,1,m,1){
            if(not_in[i]){
                if(!not_alive[ee[i].first] && !not_alive[ee[i].second]){
                    add(ee[i].first, ee[i].second);
                    add(ee[i].second, ee[i].first);
                    //cout << i << "\n";
                }
            }
        }
        memset(vis, false, sizeof(vis));
        _ans = 0;
        go(i,0,n-1,1){
            if(!vis[i] && !not_alive[i]){
                dfs(i);
                _ans++;
                //cout << i << " ";
            }
        }
        ans[k - i + 1] = _ans;
        //cout << "\n";
    }
/*
    memset(vis, false, sizeof(vis));
    _ans = 0;
    go(i,0,n-1,1){
        if(!vis[i] && !not_alive[i]){
            dfs(i);
            _ans++;
        }
    }
    cout << "\n\n" << _ans;
*/
    //cout << "\n";
    go(i,1,k+1,1){
        cout << ans[i] << "\n";
    }
    return 0;
}

```

20分？？？发生了什么？？？

TLE怎么办？？还有个RE QAQ

等等，RE是怎么回事？

是不是栈空间用的太多了？？dfs会占用一些栈空间。


### 这时我们会想到：并查集

如果把dfs找连通块改用并查集找连通块，会省下一些栈空间和一些添边的时间

于是，我们有了：

### 代码2（30分）

##### 代码解释在最后的代码中

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 400400
#define inf 1 << 30
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
#define bson l, r, rt
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
inline void write(int x){
    if (x < 0)putchar('-'),x = -x;
    if (x > 9)write(x / 10);
    putchar(x % 10 + '0');
}
//This is AC head above...
int n, m, k, usd[mn], ans[mn];
pair<int, int> ee[mn];
bool not_alive[mn];
struct edge{
    int v,nxt/*,w*/;
} e[mn<<1];
int h[mn],p;
inline void add(int a,int b/*,int c*/){
    p++;
    e[p].nxt=h[a];
    h[a]=p;
    e[p].v=b;
    //e[p].w=c;
}
int father[mn];
inline int findx(int x){
    return father[x] == x ? x : father[x] = findx(father[x]);
}
inline void mergex(int x,int y){
    int xx = findx(x);
    int yy = findx(y);
    if (xx == yy)
        return;
    srand((unsigned)time(NULL));
    if(rand()%2){
        father[xx] = yy;
    }else{
        father[yy] = xx;
    }
}
int main(){
    n = read();
    go(i,1,n,1){
        father[i] = i;
    }
    m = read();
    go(i,1,m,1){
        ee[i].first = read();
        ee[i].second = read();
        add(ee[i].first, ee[i].second);
        add(ee[i].second, ee[i].first);
    }
    k = read();
    memset(not_alive, false, sizeof(not_alive));
    fo(i,k,1,1){
        usd[i] = read();
        not_alive[usd[i]] = true;
    }
    int tot = n - k;
    go(i,1,m,1){
        if(!not_alive[ee[i].first] && !not_alive[ee[i].second]
        && findx(ee[i].first) != findx(ee[i].second)){
            tot--;
            mergex(ee[i].first, ee[i].second);
        }
    }
    ans[k + 1] = tot;
    go(i,1,k,1){
        tot++;
        not_alive[usd[i]] = false;
        go(i,1,m,1){
            if(!not_alive[ee[i].first] && !not_alive[ee[i].second]
            && findx(ee[i].first) != findx(ee[i].second)){
                tot--;
                mergex(ee[i].first, ee[i].second);
            }
        }
        ans[k - i + 1] = tot;
    }
    go(i,1,k+1,1){
        cout << ans[i] << "\n";
    }
    return 0;
}

```

很好，RE没有了，TLE没有解决。

我们简单的分析一下可以发现，代码的复杂度是O(k*(n+m))的，，，WA！好大

我们分析一下我们哪个地方费的时间多。

对，在添点与找连通块数量上。如何优化这个地方？

我们可以发现，如果一个图n个点没有边，会有几个连通块？？

是不是有n个？

如果我们在其中两个点中加一条边的话，是不是连通块数量为n-1个？

那么我每当一条边加进去时，多了一个点加入一个连通块，那么总的连通块数就会-1？

这样的话，我们就可以先算出加点之前的连通块数，然后每加一个点，先把连通块数+1，然后看这个点是否可以连入其他连通块中（注：这里只需要把与这个点连接的边枚举出来就可以了），如果可以，连通块数-1，在每次操作后倒序记录连通块数，最后正序输出就好啦！

于是，我们有了——

### 代码3（再不AC这个题解就完了）：

```cpp
 #include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 400400
#define inf 1 << 30
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
#define bson l, r, rt
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
inline void write(int x){
    if (x < 0)putchar('-'),x = -x;
    if (x > 9)write(x / 10);
    putchar(x % 10 + '0');
}
//This is AC head above...
int n, m, k, usd[mn], ans[mn];
pair<int, int> ee[mn];
bool not_alive[mn];
struct edge{
    int v,nxt/*,w*/;
} e[mn<<1];
int h[mn],p;
inline void add(int a,int b/*,int c*/){
    p++;
    e[p].nxt=h[a];
    h[a]=p;
    e[p].v=b;
    //e[p].w=c;
}
//链式前向星存图
int father[mn];
inline int findx(int x){
    return father[x] == x ? x : father[x] = findx(father[x]);
}
inline void mergex(int x,int y){
    int xx = findx(x);
    int yy = findx(y);
    if (xx == yy)
        return;
    srand((unsigned)time(NULL));//随机合并防止毒瘤出题人故意卡深度（自己都不知道会怎么并）
    if(rand()%2){
        father[xx] = yy;
    }else{
        father[yy] = xx;
    }
}
//并查集
int main(){
    n = read();
    go(i,1,n,1){
        father[i] = i;
    }
    m = read();
    go(i,1,m,1){
        ee[i].first = read();//离线判断用
        ee[i].second = read();
        add(ee[i].first, ee[i].second);//存图
        add(ee[i].second, ee[i].first);
    }
    k = read();
    memset(not_alive, false, sizeof(not_alive));//玄学初始化
    fo(i,k,1,1){
        usd[i] = read();//倒序记录被炸的顺序
        not_alive[usd[i]] = true;//记录哪个点 最后被炸掉了
    }
    int tot = n - k;//重点！这里记录目前剩的点数
    go(i,1,m,1){//然后先把存活的点之间的边连上，放到一个集合里，总的连通块数-1
        if(!not_alive[ee[i].first] && !not_alive[ee[i].second]
        && findx(ee[i].first) != findx(ee[i].second)){
            tot--;
            mergex(ee[i].first, ee[i].second);
        }
    }
    ans[k + 1] = tot;
    go(i,1,k,1){
        tot++;
        not_alive[usd[i]] = false;
        for (int j = h[usd[i]]; j; j = e[j].nxt){//枚举与这个点连接的点，看会合并几次，合并几次就会减少几个连通块
            if(!not_alive[e[j].v] && findx(e[j].v) != findx(usd[i])){
                tot--;
                mergex(e[j].v, usd[i]);
            }
        }
        ans[k - i + 1] = tot;//倒序存储
    }
    go(i,1,k+1,1){//正序输出
        cout << ans[i] << "\n";
    }
    return 0;
}

```


#### 第八次发题解，希望可以帮到那些不知道怎么去点怎么删边的同学

---

## 作者：wick (赞：21)

## 星球大战

想必看到这道题,第一时间想到的便是 **并查集** ~~(废话)~~

然后正常的思路就是先扫一遍,加到一个并查集里,然后轰一个星球,删一个星球(从并查集里去掉),那么问题来了,并查集怎么删?

只有这样

```
int find(int x) {
	if(f[x]==x) return x;
	return find(f[x]);
}
```
可不能这样

```
int find(int x) {
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
```

第一种写法是记下了路径,才可以删,但,超时!!~~(不信你去模板那里交一下)~~

故我们只能放弃这种做法,选择倒推.

每来一个点就接上.(视作修复)

**图:**
![](https://cdn.luogu.com.cn/upload/image_hosting/cgiortdz.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/kvw5lb3y.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/5mipbg0h.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/vdkflgaq.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/qp04a1td.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/kr9i00fr.png)

再倒过来!
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,k;

int ko[400005],cnt;//ko==kill order
int hk[400005];//hk==have killed

int ans[400005];

//---------------------------------------
//邻接表//不会去查,板子

vector <int> E[400005];
void add() {
	int e,u;
	cin>>e>>u;
	E[e].push_back(u);
	E[u].push_back(e);
}
//----------------------------------------
//并查集//不会去查,板子

int f[400005];
int init() {
	for(int i=0; i<n; i++)
		f[i]=i;
}
int find(int x) {
	return f[x]==x?x:(f[x]=find(f[x]));
}
//----------------------------------------
//找下一个点的大爆搜

void dfs(int now) {
	for(int i=0; i<E[now].size(); i++) {
		if(hk[E[now][i]]) continue;//还没被修复
		int fx=find(now),fy=find(E[now][i]);
		if(fx==fy) continue;//接上就不走
		f[fx]=fy;
		cnt--;
		dfs(E[now][i]);
	}
}
//----------------------------------------
int main() {
	cin>>n>>m;
	while(m--) add();
	cin>>k;
	for(int i=1; i<=k; i++) {
		cin>>ko[i];
		hk[ko[i]]=1;
	}
	init();
	cnt=n-k;//还好的点
	for(int i=0; i<n; i++) {//还好的点,也要跑一遍,找连通块,这不打40分,别问我怎么知道的
		if(hk[i]) continue;
		dfs(i);
	}
	ans[k+1]=cnt;//小心,k+1!!
	for(int i=k; i>=1; i--) {
		hk[ko[i]]=0;
		cnt++;
		dfs(ko[i]);
		ans[i]=cnt;
	}
	for(int i=1; i<=k+1; i++)
		printf("%d\n",ans[i]);
	return 0;
}


```


---

## 作者：wjyyy (赞：21)

这个题是一个倒过来的并查集，比较像[**P1653 猴子**](https://www.luogu.org/problemnew/show/P1653)

本题的目的是各个时间求联通块的个数，从最后时刻往前做，并查集的初始状态即被破坏后的图。

主要思想是，并查集中处于一个联通块的祖先结点相等，当任意祖先不同两个联通块联通时，联通块会减少一个（同时当破坏的被恢复时会增加一个），通过这种操作可以知道目前有多少个联通块。

而本题只需要知道是否在一个并查集中就可知道是否增删联通块了，因此核心算法不是很难。


具体操作说明附在代码里

本题注意事项

**1. 当调用祖先时，千万注意用find函数而不是s数组**

**2. 本题的下标是从$0$开始到$n-1$的，注意越界**

```cpp
#include<cstdio>
#include<cstring>
int s[400001];//并查集祖先数组
struct node
{
    int n;
    node *next;//链表存图（或使用前向星）
    node(int n)
    {
        this->n=n;
        next=NULL;
    }
    node()
    {
        next=NULL;
    }
};
node head[400001],*tail[400001];//用于存图
int b[400001];//b[i]存的是当时间为i时破坏的哪个点
bool g[400001];//g[i]表示现在i是否在图中
bool cnt[400001];//数联通块时是否被数过
int ans[400001];//ans[i]存储时刻为i时联通块个数，ans[0]存初始值
int my_find(int x)
{
    if(s[x]==x)
        return x;
    return s[x]=my_find(s[x]);//递归路径压缩
}
void my_union(int x,int y)
{
    s[my_find(y)]=my_find(x);
}
int main()
{
    memset(cnt,0,sizeof(cnt));
    memset(g,true,sizeof(g));
    int n,m,x,y;
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)//初始化并查集和链表
    {
        s[i]=i;
        tail[i]=&head[i];
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        tail[x]->next=new node(y);
        tail[y]->next=new node(x);
        tail[x]=tail[x]->next;
        tail[y]=tail[y]->next;
    }
    int k;
    scanf("%d",&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&b[i]);
        g[b[i]]=0;//i时刻b[i]不在图中
    }
    for(int i=0;i<n;i++)//最终状态下剩余多少个联通块，之后也会用到
    {
        if(g[i]==false)//起点此时不在图中
            continue;
        node *p=&head[i];
        while(p->next!=NULL)
        {
            p=p->next;
            if(g[p->n]==false)//终点此时不在图中
                continue;
            my_union(p->n,i);
        }
    }
    int sum=0;
    for(int i=0;i<n;i++)
        if(cnt[my_find(s[i])]==false)
        {
            sum++;//数联通块个数
            cnt[my_find(s[i])]=true;//表示s[i]这个祖先的联通块已经被数过
        }
    sum-=k;//表示多余的被删去的点，稍后再插入
    ans[k]=sum;//这是全部做完后的
    int tmp=-1,w;
    for(int i=k;i>=1;i--)//i做到1可以减少一开始重复进行的ans[0]
    {
        tmp=-1;//tmp意思是减少了多少个联通块，也可以直接在sum上加1，后面的tmp同理-1
        w=b[i];
        g[w]=true;//循环是倒序，这个时刻之前该点被释放
        node *p=&head[w];
        while(p->next!=NULL)
        {
            p=p->next;
            if(g[p->n]==false)
                continue;
            if(my_find(p->n)!=my_find(w))
            {
                tmp++;
                my_union(p->n,w);
            }
        }
        sum-=tmp;
        ans[i-1]=sum;//即在i时刻删点之前，答案是i-1的
    }
    for(int i=0;i<=k;i++)
        printf("%d\n",ans[i]);//输出答案
    return 0;
}

```

$Finish$

---

## 作者：Drinkkk (赞：20)

【题目描述】

很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。

但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。

【输入输出格式】

- 输入格式

输入文件第一行包含两个整数，$n (1 \leq n \leq 2m)$ 和$m (1 \leq m \leq 200,000)$，分别表示星球的数目和以太隧道的数目。星球用$0$~$n-1$的整数编号。

接下来的$m$行，每行包括两个整数$x$, $y$，其中（$0 \leq x \not= y<n$），表示星球$x$和星球$y$之间有以太隧道。注意所有的以太隧道都是双向的。

接下来一行是一个整数$k$，表示帝国计划打击的星球个数。

接下来的K行每行一个整数$x$，满足$0 \leq x<n$，表示帝国计划打击的星球编号。帝国总是按输入的顺序依次摧毁星球的。

- 输出格式

输出文件的第一行是开始时星球的连通块个数。

接下来的$k$行，每行一个整数，表示经过该次打击后现存星球的连通块个数。

【输入输出样例】

- 输入样例
```
8 13
0 1
1 6
6 5
5 0
0 6
1 2
2 3
3 4
4 5
7 1
7 2
7 6
3 6
5
1
6
3
5
7
```
- 输出样例
```
1
1
1
2
3
3
```

这道题目其实基本上就是并查集的入门题啦~想要入门的同学可以去做一下这道题目：[【模板】并查集](https://www.luogu.org/problemnew/show/P3367)，或者看一下我的这篇题解~

在这里举一个有$7$个点的栗子，如图（数组中的第$i$个格子表示的是$i$号点的老大）~

![](https://cdn.luogu.com.cn/upload/pic/18407.png)

你会发现，一开始每个点的老大都是自己。

看早这里，你可能会问：每个点的老大是用来干什么的？其实，我们不难发现，当某些点的老大相同的时候，他们必定处在一个联通块中。现在，我们要给出一些关系：$x$号点和$y$号点的老大是一样的。那么，我们就要将$x$号点和$y$号点合并。例如在这个栗子中我们将$6$号点和$1$号点合并（$x=6,y=1$）。在这里我们规定我们将$x$号点的老大改为$y$号点的老大，修改完后如图。

![](https://cdn.luogu.com.cn/upload/pic/18408.png)

那么我们在代码中怎么实现合并操作呢？不用急，下面上代码（$hb()$函数即为合并函数，其中$f[x]$表示的是$x$号点的老大）~

```
void hb(int x,int y)
{
	int tx=find(x),ty=find(y);
	if(tx!=ty)
	{
		f[tx]=ty;//将x号点的老大改为y号点的老大。
	}
}
```

什么？居然混入了一个$find()$函数T_T？其实$find()$函数是用来寻找$x$号点的老大的，并把和$x$号点处在一个连通块上的点的老大都改为$x$号点的老大，下面上$find()$函数的代码~

```
int find(int x)
{
	if(x==f[x])
	{
		return x;//找到老大了，返回这个老大的编号。
	}
	else
	{
		return f[x]=find(f[x]);//把一些和x号点处在同一个连通块中的点的老大改为x号点的老大。
	}
}
```

然后并查集就讲完啦^_^，然后将这个并查集反过来做就OK啦。不过如果并查集写的不好的话会TLE的哦，具体的代码实现还请看AC代码~

本题解内的图片的绘图工具为@EternalAlexander 编写的OI Painter软件，Beta 1.3~

下面上AC代码~
```
#include <cstdio>
struct nodea{ int x,y,g; } b[1000001];
struct nodeb{ int h; } r[1000001];
int ans[1000001],f[1000001],c[1000001],x[1000001];
int len=0,da=0,p=0;
int n=0,m=0;
void ins(int x,int y)
{
	len++;
	b[len].x=x;
	b[len].y=y;
	b[len].g=r[x].h;
	r[x].h=len;
}
int find(int x)
{
	if(x==f[x])
	{
		return x;
	}
	else
	{
		return f[x]=find(f[x]);
	}
}
void hb(int x,int y)
{
	int tx=find(x),ty=find(y);
	if(tx!=ty)
	{
		f[tx]=ty;
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
	}
	for(int i=1;i<=m;i++)
	{
		int x=0,y=0;
		scanf("%d %d",&x,&y);
		x++,y++;
		ins(x,y),ins(y,x);
	}
	int q=0;
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		scanf("%d",&x[i]);
		x[i]++;
		c[x[i]]=1;
	}
	for(int k=1;k<=n;k++)
	{
		if(c[k]==0)
		{
			for(int i=r[k].h;i>0;i=b[i].g)
			{
				if(c[b[i].x]==0 && c[b[i].y]==0)
				{
					hb(b[i].x,b[i].y);
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(c[i]==0 && f[i]==i)
		{
			da++;
		}
	}
	ans[++p]=da;
	for(int j=q;j>=1;j--)
	{
		da++;
		c[x[j]]=0;
		for(int i=r[x[j]].h;i>0;i=b[i].g)
		{
			if(c[b[i].x]==0 && c[b[i].y]==0 && find(b[i].x)!=find(b[i].y))
			{
				da--;
				hb(b[i].x,b[i].y);
			}
		}
		ans[++p]=da;
	}
	for(int i=p;i>=1;i--)
	{
		printf("%d\n",ans[i]);
	}
	return 0;
}
```

---

## 作者：bobxie (赞：12)

做这道题前呢，我们先出门左转[关闭农场](https://www.luogu.org/problemnew/show/P3144)，一道类似的更简单一丢丢的题                      

然后，我们考虑一下这题，因为并没有过多的操作，只是要我们求一下连通块的个数而已（**也就是连通性，具有传递性的连通**），而这恰好是并查集所擅长的。                 

然而，我们正向看题目时就会发现不支持删除操作的并查集似乎办不到。但，如果我们把删除操作换成加入操作，就可以办到了。这也就是逆向思维。题目支持离线，所以我们可以逆向处理出所有答案以后再全部输出就好了。

1. 考虑最后的连通状态：标记摧毁的点，把不摧毁的点之间能连的边连起来，同时统计连通块的数量即为所求
1. 中间的连通状态：于最后的连通状态处理方法类似，从后往前依次加入被删除的点，枚举出边，连通。统计连通块的数量即为所求
1. 倒序存，正序输出

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=4e5;
struct data
{
	int nxt,to;
}e[maxn<<1];
int head[maxn],tot;
void add(int u,int v)
{
	e[++tot]=(data){head[u],v};
	head[u]=tot;
}
int f[maxn],n,m,v[maxn],k,a[maxn],cnt,ans[maxn];
int find(int x)
{
	return x==f[x]?x:f[x]=find(f[x]);
}
void dfs(int x)
{
	v[x]=1;
	for (int i=head[x];i;i=e[i].nxt)
	{
		if (!v[e[i].to])
		{
			int f1=find(x),f2=find(e[i].to);
			if (f1!=f2) f[f1]=f2;
			dfs(e[i].to);
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<n;++i) f[i]=i;
	for (int i=0;i<m;++i)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v); add(v,u);
	}
	scanf("%d",&k);
	for (int i=0;i<k;++i) scanf("%d",&a[i]),v[a[i]]=1;
	for (int i=0;i<n;++i)
	{
		if (!v[i])
		{
			cnt++;
			dfs(i);
		}
	}
	ans[k]=cnt;
	memset(v,0,sizeof(v));
	for (int i=0;i<k;++i) v[a[i]]=1;
	for (int i=k-1;i>=0;--i)
	{
		v[a[i]]=0; 
		cnt++;
		for (int j=head[a[i]];j;j=e[j].nxt)
		{
			if (!v[e[j].to])
			{
				int f1=find(a[i]),f2=find(e[j].to);
				if (f1!=f2)
				{
					f[f2]=f1;
					cnt--;
				}
			}
		}
		ans[i]=cnt;
	}
	for (int i=0;i<=k;++i) printf("%d\n",ans[i]);
	return 0;
}
```
### 无耻宣扬博客[bobxie](https://www.luogu.org/blog/UnacceptedBlog/)

---

## 作者：jins3599 (赞：7)

并查集好题！就是思路有点别扭。

我们首先拿到题目.~~emmm，dfs暴力染色？~~

显然复杂度是无法通过的，但是这个维护连通块个数的操作很有趣。

想到了什么？显然是并查集啦

但是断裂的操作显然很不好写（对于我

因此我们考虑逆向思维，考虑合并的操作。

我们把询问倒过来操作，也就是说刚开始是所有询问的星球被摧毁的，然后再每次加进来一个星球，连上所有可能连的边，统计答案。

注意，我们是倒着统计答案的，因此刚开始的$tot$初始化为$n-k$

然后倒序枚举每次询问，每次添加一个星球$tot++$，然后遍历这个星球的所有出边，如果它指向了一个没有被删除的星球，判断他们是否在一个集合，若不在就使$tot--$，并把他们连到一个集合中.

最后正序输出答案即可，记得输出刚开始时候的连通块数量。

$Code:$
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 200005;
vector <int> S[N];
int n , m;
int k , ans[N] , qus[N];
int bin[N] , tot;

int find(int x) {
	if(bin[x] == x) return x;
	return bin[x] = find(bin[x]);
}

void add(int u, int v) {
	int fu = find(u) , fv = find(v);
	if(fu != fv) {
		tot -- ; bin[fu] = fv;
	}
}

bool flag[N];

int main () {
	ios :: sync_with_stdio(false);
	cin >> n >> m;
	for(int i = 1 ; i < n; ++ i) bin[i] = i;
	while(m --) {
		int u , v;
		cin >> u >> v;
		S[u].push_back(v); S[v].push_back(u);
	}
	cin >> k;
	tot = n - k;
	for(int i = 1 ; i <= k ; ++ i) cin >> qus[i] , flag[qus[i]] = 1;
	for(int i = 0 ; i < n ; ++ i) {
		if(!flag[i]) {
			for(int j = 0 ; j < S[i].size() ; ++ j) {
				int v = S[i][j];
				if(flag[v]) continue;
				add(i ,v);
			}
		}
	}
	for(int i = k ; i >= 1 ; -- i) {
		ans[i] = tot;
		tot ++; flag[qus[i]] = 0;
		for(int j = 0 ; j < S[qus[i]].size() ; ++ j) {
			int v = S[qus[i]][j];
			if(flag[v]) continue;
			
			add(qus[i] , v);
		}
	}
	ans[0] = tot;
	for(int i = 0 ; i <= k ; ++ i) printf("%d\n" , ans[i]);
	return 0; 
}
```

---

## 作者：GLZP (赞：6)

		看到这道题首先想到的就是我们最熟练的
 
 # 大模拟
 
 顺着题目的思路，建边，建图，然后摧毁
 
 ## 然而
 	
   实现难度太大，也就放弃了
  	
   再回过头来看看这道题
   发现 
   是
   ### 离线
   那么就不必按照题目说的去做，我们可以先处理出所有的答案，最后再一并输出
   
   先建立毁掉的图，再拼接上去这道题就简单了许多
   
   在建立毁掉的图时，用并查集在途中更新连通块，最后统计。
   
   在修建新图时，加入一个点，在遍历这个点所连接的边，如果他们所属祖先不同，就将这2个连通块通过这个新点连接起来，统计一下连通块数量存入数组中。
   
   代码如下
   ```cpp
#include<cstdio>
#include<algorithm>
using namespace std;int sum=0;
struct node{
    int fro,to,next;
}e[400010];
int n,m;
int k;
int head[400010];
int f[400010];
int book[100010],a[100010];
int vis[400010];int cnt;
void add(int x,int y)
{
    e[++sum].fro=x;
    e[sum].to=y;
    e[sum].next=head[x];
    head[x]=sum;
}
int find(int x)
{
    if(f[x]==x)return x;
    return f[x]=find(f[x]);
}
void hb(int x,int y)
{
    int t1=find(x),t2=find(y);
    f[t2]=t1;
}
void reproduction(int x)
//枚举x的边，他联通的点全都成为他的儿子 
{
    vis[x]=1;
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(vis[v]||book[v])continue;
        f[v]=find(x);
        reproduction(v);
    }
    vis[x]=0;//回溯时清空 
}
void build(int x) 
{
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(book[v])continue;
        if(find(v)!=find(x))cnt-=1;
        hb(v,x);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)
        f[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    scanf("%d",&k);
    for(int i=1;i<=k;i++)
    {
        int XD;
        scanf("%d",&XD);a[i]=XD;
        book[XD]=1; 
    }
    for(int i=0;i<n;i++)
        if(!book[i]&&f[i]==i)
        {
            reproduction(i);
            cnt++;
        }
    int ans[100010];
    ans[k+1]=cnt;//最终还剩余的连通块 
    for(int i=k;i>=1;i--)
    {
        cnt++; 
        book[a[i]]=0;
        build(a[i]);
        ans[i]=cnt;
    }
    for(int i=1;i<=k+1;i++)
    printf("%d\n",ans[i]);
    return 0;
}
```
   

------------

   如果你照我的方法做完，你会发现只有20分 233~
   
   ~~又是T，又是RE,还有WA~~
   
   重新建个图再来跑看来还是~~有问题~~ 太慢
   
   所以我们就不建图了，改为对连通块数量进行维护，只遍历边也让效率上升不少
   
   先假设所有没被毁掉点自成连通块，在通过遍历边来将点连接起来，如果两个点不属于同一连通块就让连通块数量-1
   
   修补的操作与20分代码操作一致，详见代码
   
   ### AC代码
   ```cpp
#include<cstdio>
#include<algorithm>
using namespace std;int sum=0;
struct node{
    int fro,to,next;
}e[400010];
int n,m;
int k;
int head[400010];
int f[400010];
int book[400010],a[400010];
int vis[400010];int cnt;
void add(int x,int y)
{
    e[++sum].fro=x;
    e[sum].to=y;
    e[sum].next=head[x];
    head[x]=sum;
}
int find(int x)
{
    if(f[x]==x)return x;
    return f[x]=find(f[x]);
}
void hb(int x,int y)
{
    int t2=find(y);
    f[t2]=f[x];
}
void reproduction(int x)
//枚举x的边，他联通的点全都成为他的儿子 
{//然而主函数中并没有用= = 
    vis[x]=1;
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(vis[v]||book[v])continue;
        f[v]=find(x);
        reproduction(v);
    }
    vis[x]=0;//回溯时清空 
}
void build(int x)//从X点开始修复 
{
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(book[v])continue;
        if(find(v)!=find(x))cnt--;
        hb(v,x);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)
        f[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    scanf("%d",&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&a[i]);//记录下维修顺序 
        book[a[i]]=1;//都被毁了 
    }
    cnt=n-k;
    for(int i=1;i<=2*m;i++)
    {
        if(!book[e[i].fro]&&!book[e[i].to]&&find(e[i].fro)!=find(e[i].to))
        {
            cnt--;
            hb(e[i].fro,e[i].to);
        }
    }
    int ans[400010];
    ans[k+1]=cnt;//最终还剩余的连通块 
    for(int i=k;i>=1;i--)
    {
        cnt++;//a[i]点加入图中，因为还没有使用边
        //所以连通块数量暂时加 1 
        book[a[i]]=0;
        build(a[i]);//从a[i]点开始修复 
        ans[i]=cnt;
    }
    for(int i=1;i<=k+1;i++)
    printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：xun薰 (赞：5)

题目大意：求每删去一个点之后连通块的个数。

题解：并查集 维护是否在一个块里，又因为并查集只能合并不能分割，

所以要倒序处理。先加入没有被删的边，然后把删除点的思想改成添加点。

坑点：加边时必须这条边的两个端点都没有删除，连通块的个数为没有删

除的点形成的连通块的个数。

代码
```cpp
#include<iostream>
#include<vector>
#include<cstdio>
#define maxn 400088
using namespace std;
int n,m,k,x,y,gg,ans[maxn],a[maxn],del[maxn];
vector<int>vec[maxn];
int fa[maxn<<1];
int f(int x){return fa[x]==x?x:fa[x]=f(fa[x]);}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n;i++)fa[i]=i;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        vec[x].push_back(y);
        vec[y].push_back(x);
    }
    scanf("%d",&k);gg=n-k;
    for(int i=1;i<=k;i++){
        scanf("%d",&a[i]);del[a[i]]=1;
    }
    for(int i=0;i<=n-1;i++){
        if(del[i])continue;
        for(int j=0;j<vec[i].size();j++){
            int v=vec[i][j];
            if(f(v)!=f(i)&&del[v]==0){
        //     cout<<"lal"<<" "<<i<<" "<<v<<endl;
             fa[f(v)]=f(i);    
             gg--;
            }
        }
    }
    for(int i=k;i>=0;i--){
        ans[i]=gg;gg++;del[a[i]]=0;
        for(int j=0;j<vec[a[i]].size();j++){
            int v=vec[a[i]][j];
            if(f(v)!=f(a[i])&&del[v]==0){
                gg--;fa[f(v)]=f(a[i]);
            }
        }
    }
    for(int i=0;i<=k;i++)printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：George1123 (赞：4)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1879 【\[USACO06NOV\]玉米田Corn Fields】传送门](https://www.luogu.org/problem/P1879)

### 此题算法:并查集

题目表面很难，但一下手便知道是水题了

大致思路:

>1.$ $先把将要打击的星球全打掉。

>2.$ $把剩下的星球合并(按边合并)。

>3.$ $把星球按逆序重建。

>※.$ $每次输出当前联通块个数。




```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=400010;
int n,m,a,b,k;
int ret[N],cnt;
bool make[N];
vector<int> e[N];
stack<int> ans;
struct Un{
    int f[N];
    void build(int x){
        for(int i=0;i<x;i++)
            f[i]=i;
    } int find(int x){
        if(f[x]==x) return x;
        return f[x]=find(f[x]);
    } void merge(int x,int y){
        x=find(x);
        y=find(y);
        f[y]=x;
    } bool same(int x,int y){
        return (find(x)==find(y));
    } 
}BCJ;
int main(){
	scanf("%d%d",&n,&m);
	BCJ.build(n);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&a,&b);
		e[a].push_back(b);
		e[b].push_back(a);
	} for(int i=0;i<n;i++)
		make[i]=1;
	scanf("%d",&k);
	for(int i=1;i<=k;i++){
		scanf("%d",ret+i);
		make[ret[i]]=0;
	} cnt=n;
	for(int i=0;i<n;i++){
		if(!make[i])
			continue;
		for(int j=0;j<
		e[i].size();j++){
			int to=e[i][j];
			if(!make[to])
				continue;
			if(!BCJ.same(i,to)){
				cnt--;
				BCJ.merge(i,to);
			} //计算联通块个数
		}
	} ans.push(cnt-k);
	for(int i=k;i>=1;i--){
		int t=ret[i];
		make[t]=1;
		for(int j=0;j<
		e[t].size();j++){
			int to=e[t][j];
			if(!make[to])
				continue;
			if(!BCJ.same(t,to)){
				cnt--;
				BCJ.merge(t,to);
			} //计算联通块个数
		} ans.push(cnt-(i-1));
		//没造好的星球不算
	} while(!ans.empty()){
		printf("%d\n",ans.top());
		ans.pop();
	} return 0;
}
```
其余注意点如注释，

谢谢大家! !



---

## 作者：由比滨丶雪乃 (赞：4)

# 题目大意
##### 配合[博客](https://www.luogu.org/blog/Hikigaya/p1197-xing-qiu-tai-zhan-ti-xie)食用更加
#### 每次删除一个点，询问图剩下的连通块个数（离线）

#### 题意很简单，关键在于怎么做，每次删除一个点再求未免太过于麻烦
#### 那么我们就可以逆向思维，反过来思考

## 删点=>加点

#### 离线处理，将时间线倒过来，用并查集动态维护连通块，同时统计连通块个数即可QwQ


**上代码**（~~我知道你们只看这个~~）


```cpp
#include <iostream>//卑微的头文件qwq
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cmath>
#include <vector>
#define ll long long
#define maxn 400010//由于是双向边，记得乘2

using namespace std;

int head[maxn],cnt;
int fa[maxn];
int sum;
int x,y;
int k;
int t;
int f[maxn],ans[maxn];
bool check[maxn];

inline int read()//快读qwq
{
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	int num=0;
	while(ch>='0'&&ch<='9') num=(num<<3)+(num<<1)+(ch^48),ch=getchar();
	return num;
}

struct Edge//存图
{
	int from;
	int to;
	int next;
}edge[maxn];

inline void add(int u,int v)
{
	edge[cnt].to=v;
	edge[cnt].from=u;
	edge[cnt].next=head[u];
	head[u]=cnt++;
}

inline void write(int x)
{
	if(x>9) write(x/10);
	putchar((x%10)|48);
}

int find(int x)
{
	if(x==fa[x]) return x;
	fa[x]=find(fa[x]);
	return fa[x];
}你爸爸的爸爸就是你爸爸

void bing(int x,int y)
{
	x=find(x);
	y=find(y);
	if(x==y) return;
	sum--;
	fa[x]=y;
}//啊，熟悉的并查集操作= =

int main()
{
	int n,m;
	n=read();
	m=read();
	for(int i=0;i<n;i++)//注意点的编号为 0~n-1，之前因为这个卡了好久= =
	{
		fa[i]=i;//记得初始化
		head[i]=-1;
	}
	for(int i=0;i<m;i++)
	{
		x=read();
		y=read();
		add(x,y);
		add(y,x);//加边
	}
	k=read();
	sum=n-k;
	for(int i=1;i<=k;i++)
	{
		t=read();
		check[t]=true;
		f[i]=t;
	}
	for(int i=0;i<2*m;i++)//注意是双向边，初始时的图为将所有点删完以后的图。
	{
		if(!check[edge[i].from]&&!check[edge[i].to])
		{
			bing(edge[i].from,edge[i].to);
		}
	}
	ans[k+1]=sum;
	for(int i=k;i>=1;i--)//将时间线倒过来操作
	{
	    int t=f[i];
	    sum++;
	    check[t]=false;
	    for(int i=head[t];i!=-1;i=edge[i].next)
	    {
	    	if(!check[edge[i].from]&&!check[edge[i].to])
	    	{
	    		bing(edge[i].from,edge[i].to);
			}
		}
		ans[i]=sum;
	}
	for(int i=1;i<=k+1;i++)//注意为k+1个
	{
		write(ans[i]);
		putchar('\n');
	}
	return 0;//华丽AC qwq
}
```



---

## 作者：zengxr (赞：4)

# 思路：
此题很明显可以用并查集判联通。但按照题目的意思，要把联系一个个的摧毁，这就是并查集无法做到的事情了。
# 那么怎么做呢？

### 1.暴力
暴力的做法是每拆除一条边，就重新建图，再用并查集判联通。这样做无疑会超时。

### 2.优化
我们可以将题目倒着做，将拆除转化为连接，这样，问题就解决了。

# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int now[400010],tot;
int team[400010];
bool flag[400010];
int father[400010];
int n,m,k;
int ans[400010];
int sum;
struct node
{
    int from;
    int to;
    int next;
}a[400010];//邻接表存图
void put(int x,int y)
{
    a[tot].from=x;
    a[tot].next=now[x];
    a[tot].to=y;
    now[x]=tot;
    tot++;
}
int find(int x)
{
    if(x!=father[x])father[x]=find(father[x]);
    return father[x];
}//并查集基本操作
void unionn(int x,int y)
{
    x=find(x),y=find(y);
    if(x==y)return;
    sum--;
    father[x]=y;
}//同上
int main()
{
    scanf("%d%d",&n,&m);
    int x,y;
    for(int i=0;i<n;i++)
        father[i]=i,now[i]=-1;//初始化
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        put(x,y);
        put(y,x);//存图
    }
    scanf("%d",&k);
   // printf("k:%d\n",k);
    sum=n-k;
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&x);
        flag[x]=true;
        team[i]=x;
    }
    //printf("k:%d\n",k);
    for(int i=0;i<2*m;i++)
    {
        if(!flag[a[i].from]&&!flag[a[i].to])
        {
            unionn(a[i].from,a[i].to);
        }
    }
    //printf("k:%d\n",k);
    ans[k+1]=sum;
    for(int i=k;i>=1;i--)
    {
        int u=team[i];
        sum++;
        flag[u]=false;
        for(int i=now[u];i!=-1;i=a[i].next)
        {
            if(!flag[a[i].from]&&!flag[a[i].to])
            {
                unionn(a[i].from,a[i].to);
            }
        }
        ans[i]=sum;
    }//倒着做
  // printf("k:%d\n",k);
    for(int i=1;i<=k+1;i++)
    printf("%d\n",ans[i]);

}
```

---

## 作者：glimmer (赞：3)


此题应该还是比较简单的。
首先一个比较常用且是非常有用的一个思维方法就是逆推法。~~题目都是迷惑你
的~~
题目中讲炸毁，那么我们就当时是不断的加点。

首先处理处全部炸毁的所出现的联通快。然后不断的往里加点，每次只要把其的边，所达到的点，处理一下，即可（合并一次，减少一个）。
最后将每次得到的联通快数量减去炸毁的数量即可。

注意：
	1.读入优化很重要。
    2.存边时要注意空间
```cpp
#include<bits/stdc++.h>
using namespace std;
//逆推思想 
//和平建路 
//读入优化很重要 
//空间问题 

int n,m;
int fa[410000];
int k;
vector<int>son[4100000];
int tot=0;
int a[410000];
int sum=0;

int find(int x){
    if(fa[x]==x)return x;
    else return fa[x]=find(fa[x]);
}

int rin(){
    int sum=0;char ch=getchar();
    while(!(ch>='0'&&ch<='9'))ch=getchar();
    while(ch>='0'&&ch<='9'){
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum;
}

int vis[410000];

void readp(){
    n=rin();
    for(int i=0;i<n;i++)fa[i]=i;
    m=rin();
   
    for(int i=1;i<=m;i++){
        int x,y;
        x=rin();y=rin();
        son[x].push_back(y);
        son[y].push_back(x);
    } 
    k=rin();
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=k;i++){
        a[i]=rin();
        vis[a[i]]=1;
    }
    sum=n;
    for(int x=0;x<n;x++)
    if(vis[x]==0){
        for(int i=0;i<son[x].size();i++)
        {
            int y=son[x][i];
            if(vis[y]==1)continue;
            int mx=find(x);
            int my=find(y);
            if(mx==my)continue;
            sum--;
            fa[mx]=my;
        }
    }
}

int ans[410000];


void work(){
    ans[k]=sum-k;
    for(int i=k;i>=1;i--){
    	vis[a[i]]=0;
    	int x=a[i];
    	for(int j=0;j<son[x].size();j++){
    		int y=son[x][j];
    		if(vis[y]==1)continue;
    		int mx=find(x);
    		int my=find(y);
    		if(mx==my)continue;
    		sum--;
    		fa[mx]=my;
    	}
    	ans[i-1]=sum-i+1;
    }
    for(int i=0;i<=k;i++)
    cout<<ans[i]<<endl;
}

int main(){
    readp();
    work();
    return 0;
}
    
    
        
        
        
```

---

## 作者：Dummerchen (赞：3)

#第一次题解写得不好请见谅

##看到没人用vector so我就大胆的发了个vector的题解

###思路与楼下差不多主要是vector的区别关键还是看代码吧

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int N=4e6+5;
int fa[N],a[N],ans,sum[N],n,m,k;
bool use[N];
int find(int x)//模板 
{
    if(fa[x]==x)
        return x;
    return fa[x]=find(fa[x]);
}
vector <int> g[N];//存与i有关的每个点 
int main()
{
    scanf("%d %d",&n,&m); 
    for(int i=1;i<=n;i++)
        fa[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y); 
        x++,y++;//这里是从1开始 
        g[x].push_back(y);
        g[y].push_back(x);
    }
    scanf("%d",&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&a[i]);
        a[i]++;
        use[a[i]]=true;
    }
    for(int i=1;i<=n;i++)
    {
        if(use[i]==false)//如果没被炸掉 
        {
            for(int j=0;j<g[i].size();j++)
            {
                if(use[g[i][j]]==false)//这两个点都没被炸 
                {
                    int r1=find(i);
                    int r2=find(g[i][j]);
                    fa[r1]=r2;//合并 
                }
            }
        }
    }
    for(int i=1;i<=n;i++)
        if(fa[i]==i&&use[i]==false)
            ans++;//统计被炸只后一共有多少个联通块 
    sum[k]=ans;//后面为逆推过程 
    for(int i=k;i>=1;i--)//逆推所以要倒序 
    {
        use[a[i]]=false;//因为是逆推so这里要变成没有被炸 
        ans++;
        for(int j=0;j<g[a[i]].size();j++)
        {
            if(use[g[a[i]][j]]==false)//如果这也没被炸 
            {
                int nx=find(g[a[i]][j]);
                int ny=find(a[i]);
                if(nx!=ny)//如果不在一个联通块 
                {
                    fa[nx]=ny;
                    ans--;//合并 
                }
            }
        }
        sum[i-1]=ans;
    }
    for(int i=0;i<=k;i++)
        printf("%d\n",sum[i]);//输出 
    return 0;
}
```

---

## 作者：intruder (赞：3)

多给C党一点爱

逆向思维加并查集，因为并查集的特性导致它只能合并点而不能删点 所以需要逆向来思考，先把所有将要删除的点都删掉计算出结果，再从后到前面依次加点合并 而这里需要先维护一个无向图来记录点与点之间的关系，有一个点需要想同，就是如何找有多少块 以为是逆向思考所以直接记录cnt 然和没添加一个点的时候就cnt减去他所有的边数（无向图中）再加一（想想，例如他只和一个点相连而最后的块数还是一不变）

下面是代码

        

```cpp
//逆向思维先破坏再联通 
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#define PB(a)  push_back(a)
#include<stack>
#define maxn 400020
using namespace std;
int n,m,k,fa[maxn],br[maxn],vis[maxn];
vector<int >G[maxn];
stack<int >ans;
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
int cnt;
void te(int u){
    for(int i=0;i<G[u].size();i++){
        int v=G[u][i];
        if(vis[v])continue;
        int dx=find(u);
        int dy=find(v);
        if(dx!=dy)cnt--;
        if(dx!=dy)fa[dx]=dy;
    }
           if(vis[u])cnt++;
           vis[u]=0;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        x++,y++;
        G[x].PB(y);
        G[y].PB(x);
    }
    for(int i=1;i<=n;i++)fa[i]=i;
    scanf("%d",&k);
    for(int i=1;i<=k;i++){
        int x; 
        scanf("%d",&x);
        x++;
        vis[x]=1;
        br[i]=x;
    }
    cnt=n-k;
    for(int i=1;i<=n;i++){
        if(!vis[i])te(i);
    }
    ans.push(cnt);
    for(int i=k;i>=1;i--){
        te(br[i]);
        ans.push(cnt);
    }
    while(!ans.empty()){
        printf("%d\n",ans.top());
        ans.pop();
    }
    return 0;
}

```

---

## 作者：plane (赞：3)

动态求联通块个数。我们很容易想到一个很暴力的方法，就是每次重建图，然后跑一遍Tarjan。但是我们发现N的范围非常大，现场能够暴力到一两组数据已经非常不错了。

 
我们考虑其他方法。

 
题目要求每次删除一个点，求其连通分量个数。那么我们逆向思维，可以认为是从终止状态开始，每次添加一个点，求连通分量个数。

 
怎么实现呢？分析一下，假设当前P点不可用那么与P相连的N个点中分属于M个不同的连通分量；如果我们现在使P点可用，那么这M个连通分量将被合并成为一个，也就是整个图的连通分量个数减少了（M-1）个。那么我们可以用并查集来维护每个连通分量的根节点，每次添加一个点，就将其相连的连通分量合并，更新一下整个图中的连通分量个数即可。


代码变量基本都是单词= =、比较好懂（不排除拼错哈~）



<hr>
链表处理，你懂得


```delphi

procedure add(a,b:longint);
begin
  inc(t);
  link[t].s:=a; link[t].t:=b;
  link[t].next:=front[a]; front[a]:=t;
end;


```


<hr>
合并

```delphi


procedure union(a,b:longint);
begin
  father[b]:=a;
end;


```


<hr>
寻找祖先顺便路径压缩


```delphi


function find(x:longint):longint;
begin
  if father[x]=0 then exit(x);
  find:=find(father[x]);
  father[x]:=find;
end;


```


<hr>
主程序 cnt为联通块个数


```delphi


  cnt:=0;
  for i:=1 to n do if (remain[i]) and (father[i]=0) then inc(cnt);
  ans[p]:=cnt;
  for i:=1 to p do
    begin
      remain[destroy[i]]:=true;
      point:=front[destroy[i]];
      while point<>0 do
        begin
          if (remain[link[point].t]) and
             (find(link[point].t)<>find(link[point].s))
          then
            begin
              dec(cnt);
              union(find(link[point].t),find(link[point].s));
            end;
           point:=link[point].next;
        end;
      inc(cnt);
      ans[p-i]:=cnt;
    end;


```

---

## 作者：YZ亮晶晶 (赞：3)

用并查集 但并查集只能并不能删 所以我们可以逆向思维反着做

从最后一个星球开始恢复 每恢复一个星球同时恢复相关的道路 记录下此时的连通块个数 最后逆序输出即可

另外要注意的是存储 用记录类型记录下边集 再记录下以这个星球为关键字时的前一条边的序号 就像链表一样 只用知道以这个星球为关键字时最后一条边的编号 就可以一个一个往前面找 一直找到第一个 所以我们还需要一个tail数组记录以这个星球为关键字时最后一条边的编号

而一条路连接两个星球 为了方便查找 我们需要把两个星球分别作为关键字存储边


记录连通块个数的方法：每恢复一个星球 视该星球为独立的 连通块加一 再对相关道路进行处理 每合并一次 连通块个数减一


```delphi

var n,m,i,x,y,k,j,crt,lb:longint;
    b,flag,f,tail:array[0..800000]of longint;
    a:array[0..800000]of record
                           p1,p2,front:longint;
                         end;
function gfa(u:longint):longint;//寻找根节点
begin
    if f[u]=u then exit(u);     //f为父节点
    f[u]:=gfa(f[u]);
    exit(f[u]);
end;
procedure union(u,v:longint);   //合并
var fu,fv:longint;
begin
    fu:=gfa(u);fv:=gfa(v);
    if fu<>fv then begin f[fu]:=fv;dec(crt);end;
end;
begin
    readln(n,m);
    for i:=0 to n-1 do f[i]:=i;//将每个的根节点初始化为自身
    for i:=1 to m do
    begin
        readln(x,y);   
        a[2*i-1].p1:=x;a[2*i-1].p2:=y;a[2*i-1].front:=tail[x];tail[x]:=2*i-1;
        //2*i-1记录以x为关键字的边
        a[2*i].p1:=y;a[2*i].p2:=x;a[2*i].front:=tail[y];tail[y]:=2*i;
        //2*i记录以y为关键字的边
    end;
    readln(k);
    for i:=1 to k do
    begin
        readln(b[i]);//将要摧毁的星球序号存入b数组
        flag[b[i]]:=1;//最后该星球为被占领状态
    end;
    crt:=n-k;//连通块个数
    for i:=1 to m do //所有最后仍未被占领的星球合并
        if (flag[a[i*2-1].p1]=0)and(flag[a[i*2-1].p2]=0) then
            union(a[i*2-1].p1,a[i*2-1].p2);
    b[k+1]:=crt;
    for i:=k downto 1 do  //对每一个被占领的星球依次恢复
    begin
        inc(crt);
        lb:=tail[b[i]];    
        flag[b[i]]:=0;  //恢复b[i]
        repeat  //以b[i]为关键字往前找
            if flag[a[lb].p2]=0 then union(a[lb].p1,a[lb].p2);
            lb:=a[lb].front;
        until lb=0;
        b[i]:=crt;  //此时b[i]没有用处了 可以将结果存入b[i] 
    end;
    for i:=1 to k+1 do
        writeln(b[i]);
end.

```

---

## 作者：万弘 (赞：2)

半年前就看到这题，现在终于想明白了

看到“联通块”，就要想到并查集。但是普通并查集不支持分裂操作（除非是$O(n)$的神仙并查集），那怎么搞？

~~那就先胡乱想然后都试试~~  

考虑分裂，每次分裂会导致一棵树裂成两棵（通常），那反过来，分裂前比分裂后就是两棵树合成一棵，这不正是并查集最擅长的合并操作吗？！

看到这里，你可以试着去码一码，如果不会或WA了再看下面的


------------


但问题又来了，这样反过来做又如何知道有几个联通块呢？

将操作离线到del数组，同时开一个p数组,被干掉的点u,p[u]=1

**然后拿一个并查集并初始化**，对于每一个未被干掉的u,将联通块数加一，对于每一条u->v且未被干掉的v，将u,v合并，若合并成功（u，v原本不在一个联通块中）则联通块数减一，就可知最后剩下的联通块数了

接下来从后往前对于每一个被干掉的u，ans记录现在剩下的联通块数，把p[u]=1,将联通块数加一，对于每一条u->v且未被干掉的v，将u,v合并，若合并成功（u，v原本不在一个联通块中）则联通块数减一。  
全部合并完后，剩余的联通块数就是最初的联通块数,然后把ans正向输出

最后贴一下代码吧(我习惯下标从1开始)，封装的并查集（ufs）令人舒适
```cpp
#include<cstdio>
#include<algorithm>

typedef long long ll;//也许用int也行
ll read()//快读
{
    ll x=0,f=1;
    char c;
    do
    {
        c=getchar();
        if(c=='-')f=-1;
    }while(c<'0'||c>'9');
    do
    {
        x=x*10+c-'0';
        c=getchar();
    }while(c>='0'&&c<='9');
    return f*x;
}

#define maxn 400011
ll n,m,k,res=0;
ll ans[maxn],del[maxn];//答案数组,打击的u的离线数组
bool p[maxn];//p[u]=1 :被打击;p[u]=0 :未被打击

struct Edge//存图
{
    ll v,nxt;
}e[maxn<<1|1];
ll cnt=0,last[maxn];
void adde(ll u,ll v)
{
    e[++cnt].v=v;
    e[cnt].nxt=last[u];last[u]=cnt;
}

struct ufs//封装并查集
{
    ll fa[maxn];
    void build(ll n)
    {
        for(ll i=1;i<=n;++i)fa[i]=i;
    }
    ll find(ll x)
    {
        if(fa[x]==x)return x;
        return fa[x]=find(fa[x]);
    }
    bool uni(ll u,ll v)//合并成功返回1
    {
        u=find(u),v=find(v);
        if(u==v)return 0;
        fa[u]=v;
        return 1;
    }
}s;

void rsum(ll u)//恢复u
{
    ++res;
    for(ll i=last[u];i;i=e[i].nxt)
    {
        ll v=e[i].v;
        if(!p[v]&&s.uni(u,v))--res;
    }
}
int main()
{
    n=read(),m=read();
    for(ll i=1;i<=m;++i)
    {
        ll u=read()+1,v=read()+1;//我习惯下标从1开始
        adde(u,v);
        adde(v,u);
    }
    k=read();
    for(ll i=1;i<=k;++i)
    {
        ll u=read()+1;
        del[i]=u;//离线
        p[u]=1;
    }
    s.build(n);//建立并查集
    for(ll i=1;i<=n;++i)//未被打击的连起来
        if(!p[i])rsum(i);
    for(ll i=k;i>=1;--i)//反过来恢复
    {
        ans[i]=res;//必须要先记录ans,想一想为什么?
        p[del[i]]=0;//恢复
        rsum(del[i]);
    }
    printf("%lld\n",res);
    for(ll i=1;i<=k;++i)//正序输出
        printf("%lld\n",ans[i]);
    return 0;
}
```
还有不懂的私信我,评论看不见

---

## 作者：司徒stuart (赞：2)

这道题虽然题目很长 但是做起来还是很简单的hahaha

大致意思就是说给你一个无向图 然后依次删点 求每次删点之后剩余联通块的个数

如果正着去想的话就会很麻烦 但如果倒过来想就很简单了

先再输入的时候记录一下哪些点要删除 然后给剩余的点跑一遍并查集 然后记录一下此时有多少个联通块

然后**倒序**加入要删除的点 每次判断一下与这个点相连的另一个点是否在图里 在的话 合并 然后计算联通块数

然后在依次计算的时候 记录一下每次操作之后的联通块的个数

最后**倒序**输出一下就ok啦

上代码

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<stack>
#define MAXN 200010
using namespace std;
int n,m,fa[MAXN*2],key[MAXN*2],ans,out[MAXN*2],anss,k,t=1,a,b;
vector<int > G[MAXN*2];//不开大会RE的 
stack<int > s;
inline int read()//读入优化 
{
    int s=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}
    return s*f;
}
int find(int x)//并查集 
{
    if(fa[x]!=x)
    {
        fa[x]=find(fa[x]);       //路径压缩 
    }
    return fa[x];
}
int onion(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(fx!=fy)
    {
        ans++;//当两个元素不在同一个集合中的时候 用ans记录一下减少了几个联通块
                //也就是说每当有两个不同的集合被合并的时候 联通块数量-1 
        fa[fx]=fy;
    }
}
void init()//输入 
{
    memset(key,1,sizeof(key));
    n=read();m=read();
    for(int i=0;i<n;i++)
    {
        fa[i]=i; 
    }
    for(int i=0;i<m;i++)
    {
        a=read();b=read();
        G[a].push_back(b);//双向存边 
        G[b].push_back(a);
    }    
}
void pre()//预处理 
{
    k=read();
    for(int i=0;i<k;i++)
    {
        a=read();
        s.push(a);//因为要倒序加入 所以就写了个栈 STL 大法好啊 
        key[a]=0;//记录一下哪些点要被删除 然后标记一下 
    }
    for(int i=0;i<n;i++)
    {
        if(key[i])
        {
            for(int j=0;j<G[i].size();j++)//将所有剩余的点跑一次并查集 
            {
                int v=G[i][j];
                if(key[v])//如果相连的另一个点不在图中 就不能加入 
                {
                    onion(i,v);
                }
            }
        }
    }
    anss=n-k-ans;ans=0;out[k]=anss;//这时候算的是最后一个数据 也就是所有的边都被删之后剩余联通块数
    //用anss记录剩余联通块 n-k-ans就是n-k个元素减去联通块减少的数量 就是剩余的数量了 
}
void work()
{
        while(!s.empty())//倒序加入 
    {
        int v=s.top();s.pop();
        for(int j=0;j<G[v].size();j++)
        {
            int dd=G[v][j];
            if(key[dd])//还是判断一下是否在图中 
            {
                onion(dd,v);    
            }
        }
        anss=anss-ans+1;//因为一个新的点加入之后 本身联通块就要多一个 所以这里不是anss-ans而是anss-ans+1 
        out[k-t]=anss;//记录 
        ans=0;t++;key[v]=1; //每次记得要把ans清零 还有key【v】为true 也就是这个点已经加入到图中了  
    }
}
void outit()
{
    for(int i=0;i<=k;i++)
    {
        cout<<out[i]<<endl; //我是倒序保存然后正序输出的 正序保存倒序输出也ok 
    }
}
int main()
{
    std::ios::sync_with_stdio(false);//如果不用scanf的话记得开优化 不然有一个点会TLE的 
    std::cin.tie(0);//其实就是因为我不用链表存 而是用vector 所以才慢的 
    init();
    pre();
    work();
    outit();
    return 0;
}
```

---

## 作者：songyuchen (赞：2)

#并查集！

这道题可以逆着输入的毁灭星球的顺序来求并查集。首先假设所有星球都被毁灭，然后对于所有还存活的星球，连边求并查集。然后按照逆序把被毁灭的星球一个一个重新加回去，再统计连通块即可。

**注意！！！**

在后面求连通块数量的时候不能用For循环判断Father[i]==i，这样会超时。

由于每一次只加入了一个点，所以关于连通块数量的变化都与这个点有关，也就是说当前的连通块数量应该从上一次求出的推出，而不是重新统计。具体请看代码。

综上，这道题的解题顺序是：

1. 读入所有数据（因为要离线操作）

2. 先统计一次删掉所有被毁灭星球后的连通块数量并求并查集

3. 把被删的星球倒序一个一个加入，求并查集并计算连通块数量

4. 依次输出连通块的数量

···cpp







```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const int maxN=402000;
const int maxM=201000;
const int inf=2147483647;
int n,m,K;
vector<int> E[maxN];
bool Destroy[maxN]={0};//某星球是否被毁灭
int Destroy_Order[maxN];//存放被毁灭的星球及其顺序
int Mayuri[maxN];//并查集的Father数组
int LTKnum[maxN]={0};
bool Union(int u,int v);
int Find(int x);
int main()
{
    int u,v;
    cin>>n>>m;
    for (int i=1;i<=m;i++)
    {
        cin>>u>>v;
        u++;v++;
        E[u].push_back(v);
        E[v].push_back(u);
    }
    cin>>K;
    for (int i=1;i<=K;i++)
    {
        cin>>Destroy_Order[i];
        Destroy_Order[i]++;//注意题目中的编号是从0-(n-1)
        Destroy[Destroy_Order[i]]=1;
    }
    for (int i=1;i<=n;i++)
        Mayuri[i]=i;
    for (int i=1;i<=n;i++)
        if (Destroy[i]==0)
            for (int j=0;j<E[i].size();j++)
            {
                v=E[i][j];
                if (Destroy[v]==0)
                    Union(i,v);
            }
    int Ans=0;
    for (int i=1;i<=n;i++)
    {
        if ((Mayuri[i]==i)&&(Destroy[i]==0))
            Ans++;//统计连通块数量
    }
    for (int i=K;i>=1;i--)
    {
        LTKnum[i]=Ans;
        u=Destroy_Order[i];
        Destroy[u]=0;
        Ans++;//因为多了一个点，所以连通块数量先+1
        for (int j=0;j<E[u].size();j++)
        {
            v=E[u][j];
            if (Destroy[v]==0)
            {
                if (Union(u,v))
                    Ans--;//如果加入该点后时原来不连通的两个连通块联通，则总连通块数量-1
            }
        }
    }
    LTKnum[0]=Ans;
    for (int i=0;i<=K;i++)
    {
        cout<<LTKnum[i]<<endl;
    }
    return 0;
}
bool Union(int u,int v)//合并
{
    int fu=Find(u);
    int fv=Find(v);
    if (fu!=fv)
    {
        Mayuri[fu]=fv;
        return 1;
    }
    return 0;
}
int Find(int x)
{
    if (Mayuri[x]!=x)
        Mayuri[x]=Find(Mayuri[x]);
    return Mayuri[x];
}
···
```

---

## 作者：Tgotp (赞：2)

这道题的思路很好理出来：

逆序并查集

然后我们把最后还剩的星球并起来，统计连通块，然后容易看出来，之前每次的打击掉的星球，影响的星球都只会与此时这个星球相关，所以我们找与他连起的星球，如果祖先不在一起，肯定之前不在同一连通块。然后x加一，因为最开始这个星球单独一个（多算了一次），所以最后还要再加一。


代码参考：









```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 400000 + 5;
int head[N],tot,p[N],c[N],ans[N];
bool pan[N];
struct node
{
    int next,to;
}edge[N];
void add(int a,int b)
{
    edge[tot].to=b;
    edge[tot].next=head[a];
    head[a]=tot++;
}
int getfa(int x){ return p[x]==x?x:p[x]=getfa(p[x]); }
int main()
{
    int a,b,n,m,k; 
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++) p[i]=i;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);add(b,a);
    }
    scanf("%d",&k);
    for(int i=0;i<k;i++)
    {
        scanf("%d",&c[i]);
        pan[c[i]]=true;
    }
    for(int i=0;i<n;i++)
    {
        if(!pan[i])
        for(int j = head[i];~j;j = edge[j].next)
        {
            if(pan[edge[j].to])continue;
            int x=getfa(i);
            int y=getfa(edge[j].to);
            p[x] = y;
        } 
    }
    for(int i=0;i<n;i++) if(!pan[i] && getfa(i) == i)ans[k]++;
    for(int i=k-1;i>=0;i--)
    {
        int x=0;
        pan[c[i]] = false;
        for(int j = head[c[i]];~j;j = edge[j].next)
        {
            if(!pan[edge[j].to])
            {
                int z=getfa(c[i]);int y=getfa(edge[j].to);
                if(z != y)
                {
                    p[z]=y;
                    x++;
                }
            }
        }
        ans[i]=ans[i+1]-x+1;
    }
    for(int i=0;i<=k;i++)printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：小黑AWM (赞：2)

这题一拿到原题， _“摧毁” “连接” ”连通块“_ ，瞬间就想到了一本坑上并查集部分的[打击犯罪](http://ybt.ssoier.cn:8088/problem_show.php?pid=1386)还有听说和[Closing Farm](https://www.luogu.org/problemnew/show/P3144)也是一个思路。

拆分我可没听说过拆查集。如果做的题够多的话应该能够很快想到倒推求解。从最后被拆开的的状态慢慢并回到原状态。

> 大致思路：
> 最后状态的点根据之前存的图恢复的点并起来然后再数连通块。

```c
#include <cstdio>
#include <iostream>
using namespace std;
struct Edge{
    int from,to,nxt;
}edge[400400];
int n,m,u,v,k,nume,head[400400],hit[400400],temp,numblock,ans[400400];
bool hitted[400400];
int dad[400400];
int find(int x){
    if(dad[x]==x)return x;
    return dad[x]=find(dad[x]);
}
void unionn(int x,int y){
    x=find(x),y=find(y);
    if(x!=y)dad[y]=x;
}
void add(int x,int y){
    edge[++nume].nxt=head[x];
    edge[nume].from=x;
    edge[nume].to=y;
    head[x]=nume;
}
void fix(int x,int y){
    if(find(x)==find(y))return;//不在同一块中
    unionn(x,y);
    numblock--;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=0;i<=n;i++)//编号是0～n-1
        head[i]=-1,dad[i]=i;
    for(int i=1;i<=m;i++){
        cin>>u>>v;
        add(u,v);
        add(v,u);
    }
    cin>>k;
    numblock=n-k;//假装是一片废墟，所有的点失联
    for(int i=1;i<=k;i++){
        cin>>hit[i];
        hitted[hit[i]]=true;
    }
    for(int i=1;i<=2*m;i++){//及其懵逼……为什么一定要按边遍历，按点遍历，再套临接表就莫名其妙的各种WA(Too many or too few lines)，TLE（但是我算起来感觉还快了一点啊……）
      if(!hitted[edge[i].from]&&!hitted[edge[i].to])//边是好的
        fix(edge[i].from,edge[i].to);//维修好刚刚假装断掉的连接
    }
    ans[k+1]=numblock;
    for(int i=k;i>=1;i--){
        u=hit[i];
        numblock++;
        hitted[u]=false;
        for(int p=head[u];p!=-1;p=edge[p].nxt){//判连通性
            v=edge[p].to;
            if(!hitted[v])
              fix(u,v);
        }
        ans[i]=numblock;
    }
    for(int i=1;i<=k+1;i++)
        cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：肖恩Sean (赞：2)

核心思路：由去边改为加边

实现方式：并查集+邻接表存边

详细操作：
1. 读入：读入时使用邻接表储存边
2. 初始化并查集：把两端点都没有被摧毁的边加入并查集，每加入一条有效边，联通块-1；
3. 修复端点：从后往前把已经摧毁（或者说已经假设为摧毁）的点还原，用邻接表将可以加入的有效边加入，每加入一条有效边，联通块-1；
4. 输出；

Tips：
1. 记录的是被摧毁后剩下的端点的联通块个数，要减去已经被摧毁的；
2. 无向图每条边加入2边，遍历时遍历2次；
3. 根据数据量，最好不要用cin读取，除非ios::sync_with_stdio(false);
4. 端点的范围是0~n-1；

---

## 作者：灵乌路空 (赞：1)

思路:  
本题目与 $p2700$ 类似。  
向图中正向减点减边，每次都构建并查集，计算联通块的方法  

# 肯定会TLE


则需要把思路调转：  

需要先将路径都推倒,再重新建边  
先输入各边,被摧毁的星球,  
并将其离线储存 (注意存无向图)   


之后,建起不包括存储的 *被摧毁的星球* 的并查集,  
这样就得到了最后状态的联通块情况与数量   

之后按从后往前的被摧毁顺序,  
依次将被摧毁的的星球复原，  
添加到并查集中。   
并将这个被摧毁星球  
与其他当前没有被摧毁的星球    
按照储存的路径相连接

就可以分别得到  
复原某个星球时的联通块数   
当复原所有被摧毁星球后，  
就得到了原始状态的联通块数 

再按照处理顺序，  
反向输出联通块数,即可;

### ps：此处join函数不只有并集的作用，还用来计算联通块数

------------

### 附上 ~~奇丑的~~ AC代码：
```cpp
#include<cstdio>
using namespace std;
int n,m,k;
int pre[400010],kk[400010],head[400010],ans[400010];
//分存祖先，被摧毁星球编号，邻接表各点所对的边，答案
struct baka9
{
	int u,v,ne;//存边 
}bian[400010];//无向图,两倍边 
int lian,num;//存联通块数与边数 
bool judge[400010];//判断星球是否爆炸 
int find(int x);//查集 
void join(int x,int y);//并集并计算联通块数
void add(int x,int y);//添加边 
//---------------------------------------------------
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++)
	  pre[i]=i;//初始化祖先 
	for(int i=1;i<=m;i++)//输入各边 
	  {
	  	int x,y;
	  	scanf("%d%d",&x,&y);
	  	add(x,y);//添加无向图
	  	add(y,x);
	  }
	scanf("%d",&k);
	for(int i=k;i>=1;i--)//反向记录被摧毁星球 
	  {
	  	scanf("%d",&kk[i]); 
	  	judge[kk[i]]=1;
	  }
	lian=n-k;//初始化联通块数,使每个没被摧毁的星球都单独在一个集子里
	for(int i=0;i<n;i++)//构建最后位置的并查集 
	  {
	  	if(judge[i])//被摧毁了,就找下一个 
		  continue;
		for(int j=head[i];j;j=bian[j].ne)//没被摧毁,就把它与相邻的没摧毁的星球添加到并查集中 
		  if(judge[bian[j].v] == 0)
		  	join(bian[j].u,bian[j].v);
	  }
	ans[k+1]=lian;//计算出了最后位置的联通块数
	for(int i=1;i<=k;i++)//计算各位置的联通块 
	  {
	  	judge[kk[i]]=0;//还原星球 
	  	lian++;//初始化,使这个星球单独一个集.
	  	for(int j=head[kk[i]];j;j=bian[j].ne)//添加没爆炸的相邻星球 
	  	  if(judge[bian[j].v] == 0)
			join(bian[j].u,bian[j].v);
	  	ans[k-i+1]=lian;//记录 
	  }
	for(int i=1;i<=k+1;i++)//输出 
	  printf("%d\n",ans[i]);
    return 0;//完美潇洒の结束
}
//---------------------------------------------------
int find(int x)//查集
{
	if(pre[x]==x) return x;
	else return pre[x]=find(pre[x]);
}
void join(int x,int y)//并集
{
	int r1=find(x);
	int r2=find(y);
	if(r1 != r2)
	  {
	  	pre[r2]=r1;//如果有两个不同组的集合合并 
	  	lian--;//那么联通块数减一. 
	  }
}
void add(int x,int y)//邻接表加边
{
	bian[++num].ne=head[x];
	bian[num].u=x;
	bian[num].v=y;
	head[x]=num; 
}
```


---

## 作者：xukuan (赞：1)

倒着做的并查集

开始的时候打了一个暴力（对于每次修改都做查询，40分）：

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

bool b[400010];
//b数组表示当前点是否被攻击
ll father[400010],n,m,k,fire[400010],ans[400010];
//fire中存的是所有点的被攻击时间
//father中存的是父亲节点
//ans中存答案
vector<ll> q[400010];
//q中存的是所有边构成的图

ll searchfather(ll v){//并查集找父亲
    if(father[v]==v) return father[v];
    father[v]=searchfather(father[v]);
    return father[v];
}

inline ll find(){//找联通块的个数
    ll sum=0;
    for(ll i=0; i<n; i++){
        if(b[i]){//如果这个点没有被摧毁，更新
            father[i]=searchfather(i);
            if(father[i]==i) sum++;	
        }
    }
    return sum;
}

int main(){
    scanf("%lld %lld",&n,&m);
    for(ll i=0; i<n; i++) father[i]=i;
    //千万别忘了初始化
    while(m--){
        ll x,y;
        scanf("%lld %lld",&x,&y);
        q[x].push_back(y);
        q[y].push_back(x);
    }//建图
    
    scanf("%lld",&k);
    memset(b,true,sizeof(b));
    for(ll i=1; i<=k; i++){
        scanf("%lld",&fire[i]);
        b[fire[i]]=false;//标记已经被打掉的点
    }
    
    for(ll i=0; i<n; i++){
        if(b[i]){//穷举每一个点有没有被打掉
            for(ll j=0; j<q[i].size(); j++){//找与它相连的边
                ll Next=q[i][j];//对应的点
                if(b[Next]){//对应的点没有被打掉
                    ll f1=searchfather(i),f2=searchfather(Next);
                    if(father[f1]!=f2) father[f1]=f2;
                    //并
                }
            }	
        }
    }
    
    for(ll i=k; i>=1; i--){//倒着做
        ans[i]=find();
        ll x=fire[i]; b[x]=true;//这个点恢复了
        for(ll j=0; j<q[x].size(); j++){
            ll y=q[x][j];
            if(b[y]){
                ll f1=searchfather(x),f2=searchfather(y);
                if(father[f1]!=f2) father[f1]=f2;
                //并
            }
        }
    }
    printf("%lld\n",find());
    //这市并查集表示的已经是初始图，直接找
    for(ll i=1; i<=k; i++) printf("%lld\n",ans[i]);//前面已经倒着存，所以这里正着输出
    return 0;
}
```
代码时间复杂度分析：O(kn)

那个k是达到了理论时间复杂度的下限，不能继续优化了，那么O(n)怎么优化呢

我们发现：

## 对于每一次合并，发生改变的集合一定与fire[i]这个点直接相连

除了第一次查询，别的在并的时候直接强制在线处理。

AC代码（本代码仅在有修改的地方做注释）
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

bool b[400010];
ll father[400010],n,m,k,fire[400010],ans[400010],now;
//now表示当前并查集的个数
vector<ll> q[400010];

ll searchfather(ll v){
    if(father[v]==v) return father[v];
    father[v]=searchfather(father[v]);
    return father[v];
}

inline ll find(){
    ll sum=0;
    for(ll i=0; i<n; i++){
        if(b[i]){
            father[i]=searchfather(i);
            if(father[i]==i) sum++;
        }
    }
    return sum;	
}

int main(){
    scanf("%lld %lld",&n,&m);
    for(ll i=0; i<n; i++) father[i]=i;
    while(m--){
        ll x,y;
        scanf("%lld %lld",&x,&y);
        q[x].push_back(y);
        q[y].push_back(x);
    }
    
    scanf("%lld",&k);
    memset(b,true,sizeof(b));
    for(ll i=1; i<=k; i++){
        scanf("%lld",&fire[i]);
        b[fire[i]]=false;
    }
    
    for(ll i=0; i<n; i++){
        if(b[i]){
            for(ll j=0; j<q[i].size(); j++){
                ll Next=q[i][j];
                if(b[Next]){
                    ll f1=searchfather(i),f2=searchfather(Next);
                    if(father[f1]!=f2) father[f1]=f2;
                }
            }	
        }
    }
    
    now=find();
    for(ll i=k; i>=1; i--){
        ans[i]=now;
        ll x=fire[i]; b[x]=true;
        now++;
        //因为合并计数的时候把当前的点也算进去了，而now中不包含，多-1，所以要加上去
        for(ll j=0; j<q[x].size(); j++){
            ll y=q[x][j];
            if(b[y]){
                ll f1=searchfather(x),f2=searchfather(y);
                if(father[f1]!=f2){
                    father[f1]=f2;
                    now--;//有合并说明并查集减少了一个，now -1
                    //这里对于新加进去的集合的处理在上面，此处不再说明
                }
            }	
        }
    }
    printf("%lld\n",now);
    for(ll i=1; i<=k; i++) printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：Brandon鹏 (赞：1)

## A这道~~比较水~~的题目花了好长时间啊
首先这道题肯定是要反向并查集的（反正我也不会从并查集上删去一个），但是想到这种程度并不能AC，看一看数据范围200000，显然不能直接每次判断并查集的个数，而是总的统计，才能将O(k(m+n)换成线性~~（这个复杂度不知道算的对不对）~~，这是TLE的代码，只有30分，了解一下。
## 30分
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
using namespace std;
stack<int>st;
int f[400001];
int s[200001];
int e[200001];
int sum;
int getf(int num)
{
    if(f[num]==num)
    {
        return f[num];
    }
    else
    {
        f[num]=getf(f[num]);
        return f[num];
    }
}
void merge(int x,int y)
{
    int t1=getf(x);
    int t2=getf(y);
    if(t2!=t1)
    {
        f[t2]=t1;
    }
}
int n,m;
int k;
int book[200001];
int des[200001];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&s[i],&e[i]);
        s[i]++;
        e[i]++;
    }
    scanf("%d",&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&des[i]);
        des[i]++;
        book[des[i]]=1;
    }
    for(int i=1;i<=n;i++)
    {
        f[i]=i;
    }
    for(int ttt=k;ttt>=1;ttt--)
    {
        //printf("------------\n");
        sum=0;
        for(int i=1;i<=m;i++)
        {
            if(!book[s[i]]&&!book[e[i]])
            {
                merge(s[i],e[i]);
                //printf("%d %d\n",s[i],e[i]);
            }
        }
        for(int i=1;i<=n;i++)
        {
            if(f[i]==i&&!book[i])
            {
                sum++;
            }
        }
        st.push(sum);
        book[des[ttt]]=0;
    }
    sum=0;
    for(int i=1;i<=m;i++)
    {
        merge(s[i],e[i]);
    }
    for(int i=1;i<=n;i++)
    {
        if(f[i]==i)
        {
            sum++;
        }
    }
    st.push(sum);
    while(!st.empty())
    {
        printf("%d\n",st.top());
        st.pop();
    }
    return 0;
}
```
之后显然可以发现，每次改变的原因仅仅是因为一个新点的加入，所以枚举与这个点相连的每一条边即可，于是不难想出来一个tot记录总量，每次加点就tot++，合并就tot--。然后……~~60~~
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
using namespace std;
stack<int>st;
int f[400001];
int s[200001];
int e[200001];
int sum;
struct node
{
    int s;
    int e;
    int next;
}edge[200001*2];
__attribute__((optimize("-O3")))
int getf(int num)
{
    if(f[num]==num)
    {
        return f[num];
    }
    else
    {
        f[num]=getf(f[num]);
        return f[num];
    }
}
__attribute__((optimize("-O3")))
void merge(int x,int y)
{
    int t1=getf(x);
    int t2=getf(y);
    if(t2!=t1)
    {
        f[t2]=t1;
    }
}
int n,m;
int k;
int book[400001];
int des[400001];
int head[400001];
int cnt;
int tot;
void add(int s,int e)
{
    cnt++;
    edge[cnt].s=s;
    edge[cnt].e=e;
    edge[cnt].next=head[s];
    head[s]=cnt;
    cnt++;
    edge[cnt].s=e;
    edge[cnt].e=s;
    edge[cnt].next=head[e];
    head[e]=cnt;
}
__attribute__((optimize("-O3")))
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&s[i],&e[i]);
        s[i]++;
        e[i]++;
        add(s[i],e[i]);
    }
    scanf("%d",&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&des[i]);
        des[i]++;
        book[des[i]]=1;
    }
    for(int i=1;i<=n;i++)
    {
        f[i]=i;
    }
    tot=n-k;
    for(int i=1;i<=m;i++)
    {
        if(!book[s[i]]&&!book[e[i]])
        {
            merge(s[i],e[i]);
            tot--;
        }
    }
    st.push(tot);
    for(int ttt=k;ttt>=1;ttt--)
    {
        tot++;
        int u=des[ttt];
        sum=0;
        book[u]=0;
        for(int t=head[u];t;t=edge[t].next)
        {
            int v=edge[t].e;
            if(getf(f[u])!=getf(f[v])&&!book[v])
            {
                merge(u,v);
                tot--;
            }
        }
        st.push(tot);
    }
    while(!st.empty())
    {
        printf("%d\n",st.top());
        st.pop();
    }
    return 0;
}
```
发现问题在哪里了吗？这个题的merge操作关系到不仅是点的连通关系，更关系到tot答案的统计所以肯定要判断一波在不在同一个集合中啊！！！
## AC代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
using namespace std;
stack<int>st;
int f[400001];
int s[200001];
int e[200001];
int sum;
struct node
{
    int s;
    int e;
    int next;
}edge[200001*2];
int getf(int num)
{
    if(f[num]==num)
    {
        return f[num];
    }
    else
    {
        f[num]=getf(f[num]);
        return f[num];
    }
}
void merge(int x,int y)
{
    int t1=getf(x);
    int t2=getf(y);
    if(t2!=t1)
    {
        f[t2]=t1;
    }
}
int n,m;
int k;
int book[400001];
int des[400001];
int head[400001];
int cnt;
int tot;
void add(int s,int e)
{
    cnt++;
    edge[cnt].s=s;
    edge[cnt].e=e;
    edge[cnt].next=head[s];
    head[s]=cnt;
    cnt++;
    edge[cnt].s=e;
    edge[cnt].e=s;
    edge[cnt].next=head[e];
    head[e]=cnt;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&s[i],&e[i]);
        s[i]++;
        e[i]++;
        add(s[i],e[i]);
    }
    scanf("%d",&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&des[i]);
        des[i]++;
        book[des[i]]=1;
    }
    for(int i=1;i<=n;i++)
    {
        f[i]=i;
    }
    tot=n-k;
    for(int i=1;i<=m;i++)
    {
        if(!book[s[i]]&&!book[e[i]])
        {
            if(getf(f[s[i]])!=getf(f[e[i]]))
            {
                merge(s[i],e[i]);
                tot--;
            }
        }
    }
    st.push(tot);
    for(int ttt=k;ttt>=1;ttt--)
    {
        tot++;
        int u=des[ttt];
        sum=0;
        book[u]=0;
        for(int t=head[u];t;t=edge[t].next)
        {
            int v=edge[t].e;
            if(getf(f[u])!=getf(f[v])&&!book[v])
            {
                merge(u,v);
                tot--;
            }
        }
        st.push(tot);
    }
    while(!st.empty())
    {
        printf("%d\n",st.top());
        st.pop();
    }
    return 0;
}
```
蒟蒻第一篇题解，望通过。

---

## 作者：YangQuijote (赞：1)

首先，从直接模拟的角度出发（之后再来慢慢优化）我们可以知道，这道题的模型需要用并查集维护。而在计算联通块数量时，我们可以借用最小生成树克鲁斯卡尔算法的一点思想：连接两个不同联通块的边会使联通块数量减1。因此，通过并查集模型，我们先将每个星球当做一个单独的联通块，而在向这个有大量独立联通块组成的图中加入边时，只加入会连通两个不同联通块的边。我们用变量cont记录加入这样的边的数量，最后，图中联通块的数量=（星球的数量-cont）。

那么，我们已经得到了模拟的方法。现在可以来分析这道题的优化办法了。通过观察数据结构，不难看出对每次击毁星球的操作都重新构建图模拟求一次联通块数量时间复杂度太高了，肯定超时，因此我们对于每次击毁操作的计算，都要尽可能利用已经计算过的结果。由此，我们不妨换一个角度看这个问题，从“计算不断减少点的图的联通块数量”倒过来，变为“计算不断增加点的图的联通块数量”，也就是说，将输入的击毁顺序倒过来，变为在一个已经去除了所有被击毁星球的图中，按倒序重新一个个加入，重建被击毁的星球，并不断计算联通块数量。于是，我们在这里将击毁星球的序列加入栈中，利用栈后进先出的性质，不断从栈顶取出星球，加入图中，计算联通块数量。

在这样一个新的问题模型的基础上，我们就可以不必像原来一样每次都重新构建图，而是在已有的图的基础上继续我们的计算，最大限度的利用了已有的计算结果，大大降低了时间复杂度。由于我们倒序求出来的答案也是倒序的，因此将答案也加入一个栈中，再次反转，就重新变为了正序。

PS：注意被击毁的星球本身已不算存在的点，因此也不算一个联通块，因此要减去它们，变为：联通块数量=（星球数量-cont-被击毁的星球的数量）。

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<cmath>
#include<stack>
using namespace std;
struct near
{
    int num,nex;
}ne[400010];
int h[400010],father[400010];
bool flag[400010];
stack<int>s;
stack<int>ans;
int find(int x)
{
    if(father[x]==x)
    {
        return x;
    }
    else
    {
        int mem=find(father[x]);
        father[x]=mem;
        return mem;
    }
}
int main()
{
    int n,m,i,k,x,y,no,cont=0,a,b;
    scanf("%d%d",&n,&m);
    for(i=0;i<n;i++)
    {
        father[i]=i;
    }
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        ne[i*2-1].num=y;
        ne[i*2-1].nex=h[x];
        h[x]=i*2-1;
        ne[i*2].num=x;
        ne[i*2].nex=h[y];
        h[y]=i*2;
    }
    scanf("%d",&k);
    for(i=1;i<=k;i++)
    {
        scanf("%d",&x);
        flag[x]=1;
        s.push(x);
    }
    for(i=0;i<n;i++)
    {
        if(flag[i]==1)
        {
            continue;
        }
        a=find(i);
        for(no=h[i];no!=0;no=ne[no].nex)
        {
            if(flag[ne[no].num]==1)
            {
                continue;
            }
            b=find(ne[no].num);
            if(a!=b)
            {
                father[a]=b;
                a=b;
                cont++;
            }
        }
    }
    ans.push(n-cont-k);
    int top;
    for(i=1;i<=k;i++)
    {
        top=s.top();
        s.pop();
        flag[top]=0;
        a=find(top);
        for(no=h[top];no!=0;no=ne[no].nex)
        {
            if(flag[ne[no].num]==1)
            {
                continue;
            }
            b=find(ne[no].num);
            if(a!=b)
            {
                father[a]=b;
                a=b;
                cont++;
            }
        }
        ans.push(n-cont-(k-i));
    }
    for(i=1;i<=k+1;i++)
    {
        printf("%d\n",ans.top());
        ans.pop();
    }
    return 0;
}
```

---

## 作者：Neumann (赞：1)

//思路和下面题解一样，是个练逆向思维的好题，实现的时候我遇到的问题都注释了










    
    
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int maxn=400000+10;
const int maxe=200000+10;
int n,m,k,cnt=0,tot;
int h[maxn],p[maxn],qq[maxn],vis[maxn],ans[maxn];
struct edge{
    int to,next;
}e[maxe*2];
void ins(int u,int v){
    e[++cnt]=(edge){v,h[u]};
    h[u]=cnt;
    e[++cnt]=(edge){u,h[v]};
    h[v]=cnt;
}
int inline read(){
    int num=0;
    char c;
    bool plus=true;
    while((c=getchar())==' '||c=='\n'||c=='\r');
    if(c=='-')plus=false;
    else num=c-'0';
    while(isdigit(c=getchar()))
        num=num*10+c-'0';
    return num*(plus?1:-1);
}
int find(int x){
    return p[x]==x?x:p[x]=find(p[x]);
}
void merge(int x){
    tot++;
    int r1=find(x),r2,y;
    for(int i=h[x];i;i=e[i].next){
        y=e[i].to;
        if(!vis[y]){
            r2=find(y);
            if(r1!=r2){
                p[r2]=r1;//不能反过来，不然不是一个集合 
                tot--;
            }
        }
    }
    vis[x]=0;
}
int main(){
    n=read(); m=read();
    for(int i=1;i<=m;i++){
        int x,y;
        x=read();y=read();
        x++; y++; //下面有说明 
        ins(x,y);
    }
    k=read();
    for(int i=1;i<=k;i++){
        qq[i]=read();
        qq[i]++;
        vis[qq[i]]=1;
    }
    for(int i=1;i<=n;i++)p[i]=i;//n有0，从0开始，注意！！ 或者前面每个点都加一 
    tot=0;//tot=n-k也可以，上面不用每次都加，星球被炸之后不能算作联通快 
    for(int i=1;i<=n;i++){
        if(!vis[i]) //勿忘 
            merge(i);
    }
    ans[k+1]=tot;
    for(int i=k;i>=1;i--){
        //vis[qq[i]]=0;
        //tot++;
        merge(qq[i]);
        ans[i]=tot;
    }
    for(int i=1;i<=k+1;i++)
        printf("%d\n",ans[i]);
    return 0;
} 

```

---

## 作者：q1293274675 (赞：1)

###**这道题特别棒**

以前考过一道类似的题目，为了坑爹说什么要在线……但是数据范围那么大，在线肯定要TLE到飞起，所以考虑离线。因为并查集仅支持“并”这个操作，而不支持“删”这个操作，所以我们可以先删再并拿一个数组装答案，最后输出。

```cpp
**#include<cstdio>**
**#include<cstring>**
**#include<algorithm>**
**#include<vector>**
**using namespace std;**
**const int N=400005;**
**int n,m,q,Q[N],head[N*2],cnt,f[N],ans[N],tot;**
**//Q装山的点，head是个辅助数组（辅助那个结构体的（cnt也是）），f为并查集，ans装答案，tot记录连通块个数**
**bool vis[N],jd[N];//辅助判断之用**
**struct sdf{int v,next;}e[N];//类似于用vector的玩意，不过要快上不少**
**inline int read(){//读入优化，可以不管它**
**int ret=0,f=1;char ch=getchar();**
**while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}**
**while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();**
**return ret*f;**
**}**
**void add(int a,int b){//此处可用vector替代**
**cnt++;e[cnt].v=b;e[cnt].next=head[a];head[a]=cnt;**
**}**
**inline int father(int k){//并查集**
**int j=k,t;**
**while(j!=f[j])j=f[j];**
**while(k!=f[k]){**
**t=f[k];**
**f[k]=j;**
**k=t;**
**}**
**return j;**
**}**
**int main()**
**{**
**n=read();m=read();**
**for(int i=0;i<n;i++)f[i]=i;//初始化**
**for(int a,b,i=1;i<=m;i++){**
**a=read();b=read();add(a,b);add(b,a);//此处可用vector替代**
**}**
**q=read();**
**for(int i=1;i<=q;i++)Q[i]=read(),jd[Q[i]]=1;**
**for(int i=0;i<n;i++)if(!jd[i]){**
**for(int j=head[i];j;j=e[j].next)if(!jd[e[j].v]){**
**int u=e[j].v;**
**int fai=father(i),fau=father(u);**
**if(fai!=fau)f[fai]=fau;**
**}**
**}**
**for(int i=0;i<n;i++)if(!jd[father(i)])if(!vis[father(i)])tot++,vis[father(i)]=1;**
**ans[q]=tot;**
**for(int i=q;i>=1;i--){**
**int k=Q[i];**
**for(int j=head[k];j;j=e[j].next)if(!jd[e[j].v]){**
**int u=e[j].v;**
**if(father(k)!=father(u)){**
**tot--;**
**f[father(k)]=father(u);**
**}**
**}**
**if(jd[k])tot++;//思考下，为啥**
**jd[k]=0;**
**ans[i-1]=tot;**
**}**
**for(int i=0;i<=q;i++){**
**printf("%d\n",ans[i]);**
**}**
**return 0;**
**}**
```

---

## 作者：exi3t (赞：1)

```cpp
/*
解法:离线处理,逆序做并查集(因为并查集只能"并",不能删);
一处优化是:统计联通块的个数时,并不是每次都遍历 n个结点,
而是统计 由于此结点的恢复造成了多少联通块的合并,
然后用恢复前的联通块个数减去即可.
*/
#include<iostream>
#include<vector>
#include<stack>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define ll long long
#define inf 0x3f3f3f3f
#define loop(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
struct node
{
	vector<int>conct; bool exi3t;
	node(){
		conct.clear();
		exi3t=true;
	}
}a[400000+1];
struct pa1r
{
	int x,y;
}link[200000+1];
int n,m,k,fatr[400000+1];
stack<int>noext;//nonexist;
stack<int>ans;
int find(int);
int main()
{
	cin>>n>>m;
	int x,y;
	loop(i,1,m){
		cin>>x>>y;
		x++; y++;
		link[i].x=x; link[i].y=y;
		a[x].conct.push_back(y);
		a[y].conct.push_back(x);
	}
	cin>>k;
	loop(i,1,k){
		cin>>x;
		x++;
		a[x].exi3t=false;
		noext.push(x);
	}
	loop(i,1,n) fatr[i]=i;
	int fx,fy;
	loop(i,1,m){
		x=link[i].x; y=link[i].y;
		if(!a[x].exi3t or !a[y].exi3t) continue;
//		cout<<"x: "<<x<<"  y: "<<y<<endl;
		fx=find(x); fy=find(y);
		if(fx!=fy) fatr[fx]=fy;
	}
	int tmp=0;
	loop(i,1,n){
		if(a[i].exi3t and fatr[i]==i) tmp++;
	}
	ans.push(tmp);
	int s1ze,n0w,n3xt,fn0w,fn3xt;
	while(!noext.empty()){
		n0w=noext.top();
		noext.pop();
		tmp++;//这一步 是防止 把刚恢复的点 当做 联通块;
		a[n0w].exi3t=true;
		s1ze=a[n0w].conct.size();
		loop(i,1,s1ze){
			n3xt=a[n0w].conct[i-1];
			if(!a[n3xt].exi3t) continue;
			fn0w=find(n0w);
			fn3xt=find(n3xt);
			if(fn0w!=fn3xt)	{
				tmp--;
				fatr[fn0w]=fn3xt;
			}
		}
		ans.push(tmp);
	}
	while(!ans.empty()){
		cout<<ans.top()<<endl;
		ans.pop();
	}
	return 0;
}
int find(int x)
{
	return fatr[x]==x? x:fatr[x]=find(fatr[x]);
}
```

---

## 作者：18811162081lyh (赞：1)

```
#include<stdio.h>
#include<iostream>
#include<cstring>
#include<stack>
#define MAXN 400005
#define MAXM 200005
using namespace std;
int n,m,k,i,j,x,y,tot,f[MAXN],d[MAXN];
bool del[MAXN];
//f数组记录并查集，d数组记录删除星球的顺序，del数组记录该星球是否被删除 
struct edge{
	int v;
	edge* next;
}temp[MAXM*2], *h[MAXN];
void AddEdge(int u, int v)
{
	edge *p = &temp[tot++], *q = &temp[tot++];
	p->v = v; p->next = h[u]; h[u] = p;
	q->v = u; q->next = h[v]; h[v] = q;
}
int GetFather(int a) //包含路径压缩
{
	if(f[a] < 0) return a;
	return f[a] = GetFather(f[a]);
}
bool Join(int a, int b)
{
	//printf("Join %d %d", a, b);
	int fa = GetFather(a);
	int fb = GetFather(b);
	if(fa == fb) return false;
	int temp = f[fa] + f[fb];
	if(fa < fb) //fa中的星球数量较多，把fb合并到fa中 
	    f[fb] = fa, f[fa] = temp;
	else
		f[fa] = fb, f[fb] = temp;
	return true;
}
int main()
{
	//读入数据并初始化 
	memset(f, -1, sizeof(f));
	scanf("%d %d", &n, &m);
	for(i = 1;i <= m; i++)
	{
		scanf("%d %d", &x, &y);
		AddEdge(++x, ++y);
	}
	scanf("%d", &k);
	for(i = 1;i <= k; i++)
	{
		scanf("%d", &x);
		d[i] = ++x; //输入的星球编号从0开始，这里处理成从1开始
		del[x] = 1;
	}
	/*for(i = 1;i <= n; i++)
		printf("%d ", del[i]);
	printf("\n");*/
	//以线下的方式处理数据 ，将结果压入栈里
	stack <int> q; 
	for(i = 1;i <= n; i++)
	{
		if(del[i]) continue;
		for(edge* p = h[i]; p; p=p->next)
			if(del[p->v] == 0) Join(i, p->v);
	}
	int ans = 0;
	for(i = 1;i <= n; i++)
		if(f[i]<0 && del[i]==0) ans++;
	q.push(ans);
	/*for(i = 1;i <= n; i++)
		printf("%d ", f[i]);
	printf("\nans: %d\n", ans);
	system("pause");*/
	for(i = k;i > 0; i--) //倒序将被摧毁的星球加入并查集 
	{
		del[d[i]] = 0;
		ans++;
		for(edge *p = h[d[i]]; p; p=p->next)
			if(del[p->v] == 0 && Join(d[i], p->v)) ans--;
		q.push(ans);
		//printf("\nans: %d\n", ans);
		//system("pause");
	}
	while(!q.empty())
	{
		printf("%d\n", q.top());
		q.pop();
	}
	return 0;
}
```

---

## 作者：LiRewriter (赞：1)

比较有趣的一道并查集。

我们在做组合数学或者集合的时候会说一句话，叫做正难则反。这里也是同样的。

首先，既然是对联通块的操作，那自然而然的想到用并查集解决。

先来思考一个问题：如果有n个块，然后我们要进行合并，合并之后有多少块？只需要对合并函数稍稍修改：

```cpp
inline void uni(int x, int y) {
    int xx = find(x), yy = find(y);
    if(xx == yy) return;
    --cnt;
    fa[xx] = yy;
}
```
每一次合并，如果两个在同一集合中就不做处理，否则相当于连通块-1.

返回这道题，摧毁的过程是相当难以维护的，由于这道题是离线的，所以我们可以反过来重建。以样例为例，在摧毁的最后，节点0 2 4分别构成了3个连通块，注意这里答案并不是8，因为不存在剩下的5个节点！

然后每每恢复一个节点，就可以把和它相关联的连通块都合并一遍，但是要注意，这个时候的合并的前提，是对面重建过。实现见下。


```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <vector>
#include <algorithm>
using namespace std;
inline void read(int &x) { //优读
    x = 0; char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
}
#define MAXN 400006
int fa[MAXN], cnt;
inline int find(int x) {
    return x == fa[x] ? x : fa[x] = find(fa[x]);
}
inline void uni(int x, int y) {
    int xx = find(x), yy = find(y);
    if(xx == yy) return;
    --cnt; //连通块个数统计
    fa[xx] = yy;
}
int n, m;
typedef pair<int, int> pii;
pii rel[MAXN >> 1];
int del[MAXN], ans[MAXN];
bool vis[MAXN];
vector<int> v[MAXN];
inline void add_set(int x, int y) {
    //cout<<x<<" "<<y<<endl;
    if(!vis[x] && !vis[y]) { //两边都存在 可以合并
        //cout<<x<<" "<<y<<endl;
        uni(x, y);
        return;
    }
    v[x].push_back(y), v[y].push_back(x); //否则添加到集合中
}
int main() {
    read(n), read(m); 
    for(int i = 0; i < n; ++i) fa[i] = i;
    cnt = n;
    for(int i = 1; i <= m; ++i) read(rel[i].first), read(rel[i].second);
    int K; read(K);
    cnt -= K; 
    for(int i = 1; i <= K; ++i) read(del[i]), vis[del[i]] = 1;
    //for(int i = 0; i < n; ++i) cout<<vis[i]<<" ";
    //cout<<endl;
    for(int i = 1; i <= m; ++i) add_set(rel[i].first, rel[i].second); //合并初始能够合并的集合
    ans[K + 1] = cnt;
    for(int i = K; i >= 1; --i) { //重建过程
        vis[del[i]] = 0; //表示已经重建
        ++cnt;
        for(int j = 0; j < v[del[i]].size(); ++j)
            if(!vis[v[del[i]][j]]) //另一个重建过
                uni(del[i], v[del[i]][j]);
        ans[i] = cnt;
    }
    for(int i = 1; i <= K + 1; ++i) cout<<ans[i]<<endl;
    return 0;
} 
```

---

## 作者：Drug__Lover (赞：1)

**邻接表+逆序并查集**

**逆序并查集楼下已经说的很清楚了**

**就是先统计星球都被毁灭之后的连通的个数**

**再按照破坏顺序倒着一个一个并回去**


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 4000001
using namespace std;
int n,m,k,ans,cnt;
int head[maxn];
int destroy[maxn],destroy_order[maxn],num[maxn];   
int f[maxn],earth[maxn];
struct node             //邻接表存储连边 
{
    int to,next;
}e[maxn];
int getf(int x)        //并查集路径压缩 
{
    if(f[x]==x) return x;
    else
    {
        f[x]=getf(f[x]);
        return f[x];
    }
}
int merge(int x,int y)        //合并 
{
    int t1,t2;
    t1=getf(x),t2=getf(y);
    if(t1!=t2)
    {
        f[t2]=t1;
        return 1;
    }
    return 0;
}
int add(int from,int go)        //邻接表 
{
    e[++cnt].next=head[from];
    e[cnt].to=go;
    head[from]=cnt;
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<=n;i++) f[i]=i;     //并查集初始化，最开始要统计没被破坏时的连通的个数 
    for(int i=1;i<=m;i++)
    {
        int a1,a2;
        cin>>a1>>a2;
        add(a1,a2),add(a2,a1);      //加双向边 
        merge(a1,a2);         //合并 
    }
    for(int i=0;i<n;i++) if(f[i]==i) ans++;      //统计初始个数 
    num[0]=ans;        //记录 
    cin>>k;
    for(int i=1;i<=k;i++)
    {
        cin>>destroy_order[i];           //输入破坏的星球的顺序 
        destroy[destroy_order[i]]=1;        //记录 
    }
    for(int i=0;i<n;i++) f[i]=i;           //并查集初始化 
    for(int i=0;i<n;i++)
    { 
        if(destroy[i]!=1)             //假设要破坏的星球全被破坏之后连通的个数 
            for(int j=head[i];j!=0;j=e[j].next)
            {    
                int to=e[j].to;
                if(destroy[to]!=1) merge(i,to);
            }
    }
    ans=0;
    for(int i=0;i<n;i++)
        if(f[i]==i&&destroy[i]!=1) ans++;        //统计个数 
    for(int i=k;i>=1;i--)
    { 
        num[i]=ans;              //记录个数 
        destroy[destroy_order[i]]=0;          //倒序并查集，还没被破坏 
        ans++;                              //首先至少多一个连通块 
        for(int j=head[destroy_order[i]];j!=0;j=e[j].next)
        {
            int to=e[j].to; 
            if(destroy[to]!=1&&merge(destroy_order[i],to))    ans--;   //如果与这个没被破坏的星球相连并且使得合并在一起了
                                                                    //连通块个数-1     
        }
    }
    for(int i=0;i<=k;i++) cout<<num[i]<<endl;        //正序输出个数 
    return 0;
}
```

---

## 作者：天狗的手帖 (赞：1)

楼下说的很好，这里给出一份C++的代码


当某个点的fa等于-1时说明这个点不在当前集合中，更新某个节点时就不考虑这些不在当前集合中的点。

```cpp

#include<cstdio>
#include<cstring>

using namespace std;
const int M=200005;
const int N=M*2;
int lines,front[N];
struct edge{int next,to;}e[N];
void addline(int x,int y){e[++lines]=(edge){front[x],y};front[x]=lines;}
int tal;
int n,m,fa[N],ans[N];
int find(int k){return k!=fa[k]?fa[k]=find(fa[k]):k;}
void addpoint(int k){
    fa[k]=k;tal++;
    for (int i=front[k];i!=0;i=e[i].next)
        if (fa[e[i].to]!=-1){
            int x=find(e[i].to);
            if (k!=x){fa[x]=k;tal--;}
        }
}
int p[N];bool t[N];
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1,x,y;i<=m;i++){
        scanf("%d%d",&x,&y);
        addline(x,y),addline(y,x);
    }
    scanf("%d",&m);
    for (int i=1;i<=m;i++) scanf("%d",&p[i]),t[p[i]]=true;
    memset(fa,-1,sizeof(fa));
    for (int i=0;i<n;i++) if (!t[i]) addpoint(i);
    ans[0]=tal;
    for (int i=m;i>=1;i--){
        addpoint(p[i]);
        ans[i]=tal;
    }
    for (int i=1;i<=m;i++) printf("%d\n",ans[i]);
    printf("%d\n",ans[0]);
}

```

---

## 作者：lele2002 (赞：0)

感觉我的建边跟其他人有一点不一样吧
如果对所有摧毁星球逆序恢复，每次对搜索所有的边复杂度mk+显然超时
所以我们要对边进行操作，使每次操作都有效，这样我们就对所有边排序，
那怎么排序呢？显而易见，每条边被加入到可行的时间是唯一确定的，我们对每条边附一个优先级
他就等于联通两点的优先级的较大值，我们按点被摧毁的时间顺序确定点的优先级
摧毁越早的点优先级越大（在逆序中最晚被加回来）这样每一条边只会被访问一次；
线性扫边+并查集合并，复杂度mlogn，可以AC；
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MM=2e5+10;
int an[2*MM],f[2*MM],ma[2*MM];
int getroot(int p)
{
    if(p==f[p])
        return p;
    return f[p]=getroot(f[p]);
}
void merge(int fi,int se,int p)
{
    int u=getroot(fi),v=getroot(se);
    if(u!=v)
        an[p]--;
    f[u]=v;
}
struct No{
	int pri,a,b;
	bool operator <(const No & r)const
	{
		return pri<r.pri;
	}
}e[MM];
int main()
{
    int n,m,k;
    cin>>n>>m;
    for(int i=0;i<n;i++)
        f[i]=i;
    for(int i=1;i<=m;i++)
        cin>>e[i].a>>e[i].b;
    cin>>k;
    for(int i=1;i<=k;i++)
    {
    	int x;
        cin>>x;
        ma[x]=1+k-i;
    }
    for(int i=1;i<=m;i++)
    	e[i].pri=max(ma[e[i].a],ma[e[i].b]);
    sort(e+1,e+m+1);
    int p=1;
    an[0]=n-k;
    for(int i=0;i<=k;i++)
    {
    	while(e[p].pri==i&&p<=m)
        	merge(e[p].a,e[p].b,i),p++;
        an[i+1]=an[i]+1;
	}
    for(int i=k;i>=0;i--)
        cout<<an[i]<<endl;
}
```

---

## 作者：CR_Raphael (赞：0)

这题的关键在于**反过来看**，从所有应被毁灭的星球都被毁灭的末状态向前反推到这颗被毁灭的星球没被毁灭的情况。使用一次dfs求末状态（O(n)），使用多次并查集向前反推（O(max(m,k))），反推过程即把该点加入图中(ans++)，并把该点所达所有点和该点自己合并到一起(每合并一次ans--)并更新答案。

优质思维题

我在做的时候把dfs里的一些东西写错了（to[i]写成x），还有就是一开始忘了加入的新点，也没有能直接想到正解……总之就是我还是太弱。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int maxn = 400005;
int ask[maxn];
int ans[maxn];
int n, m;

struct bcj {
	int fa[maxn];
	void cle() {
		int i;
		for(i=1; i <= n; i++) fa[i]=i;
	}
	void add(int a, int b) {
		int ta=find(a), tb=find(b);
		if(ta == tb) return;
		fa[ta]=tb;
		return;
	}
	int find(int x) {
		if(fa[x] != x) fa[x]=find(fa[x]);
		return fa[x];
	}
} B;

struct gra {
	int tm, st[maxn], to[maxn], nex[maxn];
	int v[maxn], unable[maxn];
	void adde(int a, int b) {
		tm++;
		to[tm]=b;
		nex[tm]=st[a];
		st[a]=tm;
		return;
	}
	int findd() {
		int i, t=0;
		for(i=1; i <= n; i++) {
			if(!v[i] && !unable[i]) {
				dfs(i);
				t++;
			}
		}
		return t;
	}
	void dfs(int x) {
		if(v[x] || unable[x]) return;
		v[x]=1;
		int i;
		for(i=st[x]; i != 0; i=nex[i]) {
			if(!v[to[i]] && !unable[to[i]])
				B.add(x, to[i]), dfs(to[i]);
		}
		return;
	}
	int count(int x, int num) {
		int t=num+1, i, y;
		unable[x]=0;
		for(i=st[x]; i != 0; i=nex[i]) {
			y=to[i];
			if(!unable[y] && B.find(x) != B.find(y)){
				B.add(x, y);
				t--;
			}
		}
		return t;
	}
} G;

int main() {
	int i, ta, tb, k;
	scanf("%d%d", &n, &m);
	for(i=1; i <= m; i++) {
		scanf("%d%d", &ta, &tb);
		ta++; tb++;
		G.adde(ta, tb);
		G.adde(tb, ta);
	}
	B.cle();
	scanf("%d", &k);
	for(i=1; i <= k; i++) {
		scanf("%d", &ta);
		ta++;
		G.unable[ta]=1;
		ask[i]=ta;
	}
	ans[k]=G.findd();
	for(i=k; i >= 1; i--) {
		ans[i-1]=G.count(ask[i], ans[i]);
	}
	for(i=0; i <= k; i++) printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：田阙西 (赞：0)

自以为代码比较简洁明了，于是发一波题解。

本题很明显能看出来，需要反着跑。然而，如何确定每条边在什么时刻加入呢？

其实我上一句话已经暴露了：时刻。像基于时间轴的dp一样，我们也可以根据**一条边连接的两点中先被摧毁的点**，确定其摧毁时间。也就是确定其加入时间。
然后按此时间进行排序，按照时间从后向前加边即可。

第二个难点是：如何计算联通块（快QWQ）数目？
由unionn函数中的步骤可知：我们每次合并fx和fy，即相当于合并两个联通块。于是每次有效操作即对应联通块-1.

当然第一次操作要用cal单独计算。每次被删去的点不计入联通块总数，于是i在从k到0递推时，ans每次加一，即相当于恢复一个被删去的点。


```
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
#include<cstring>
using namespace std;
int fastRead()
{
    int r=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){r=r*10+c-'0';c=getchar();}
    return f*r;
}
int n,m,k,b[400010],ans[400010],f[400010],p[400010],cnt;
struct mmm{int x,y,t;}a[200010];
bool cmp(mmm a,mmm b){return a.t>b.t;}
int getFather(int x)
{
    if(x==f[x])return x;
    else return f[x]=getFather(f[x]);
}
void unionn(int x,int y)
{
    int fx=getFather(x),fy=getFather(y);
    if(fx!=fy)f[fx]=fy,cnt++;
}
int cal()
{
    memset(p,0,sizeof(p));int u=0;
    for(int i=1;i<=n;++i)p[getFather(i)]++;
    for(int i=1;i<=n;++i)if(p[i])u++;
    return u;
}
int main()
{
    n=fastRead(),m=fastRead();
    for(int i=1;i<=n;++i)f[i]=i;
	memset(b,126,sizeof(b));
    for(int i=1;i<=m;++i)a[i].x=fastRead()+1,a[i].y=fastRead()+1;
    k=fastRead();
    for(int i=1;i<=k;++i)b[fastRead()+1]=i;
    for(int i=1;i<=m;++i)a[i].t=min(b[a[i].x],b[a[i].y]);
    sort(a+1,a+1+m,cmp);
    int l=1;
    for(int i=k;i>=0;--i)
    {
    	cnt=0;
        while(a[l].t>i)
        {
            unionn(a[l].x,a[l].y);l++;
        }
		if(i<k)ans[i]=ans[i+1]+1-cnt;
		else ans[i]=cal()-i;
    }
    //ans[0]=cal();
    for(int i=0;i<=k;++i)printf("%d\n",ans[i]);
    return 0;
}
//if %
//exit(0)
```

---

## 作者：Mr_cold (赞：0)

这是一道并查集的题，说难也挺难的，因为从正面看要运用图论中的算法，来进行删边和记录联通块，但是这样无疑会非常复杂，所以根据正难则反的思想，我们不进行删边而进行加边，结果在倒叙输出就行了，这样子就可以运用并查集的思想来进行做题。
优点：通过并查集模型可以把每个星球当做一个联通块，所以正难则反后每加一条边就会增加一个联通块，然后再根据题目中的路径就可以知道联通的数量，则 图中联通块的数量=（星球的数量-加入的有效边）。
变量：
~~~
const int maxn=500000;
struct Edge{
	int to,from,self;
}edge[maxn];//前向星存图
//该存图方法是所有存图方法中较快的了
int n,m,k,cnt=0,tot;//tot用来记录联通块个数
int fa[maxn],//并查集的家长数组
vis[maxn],//摧毁星球的标记数组
last[maxn],
ans[maxn],//保存答案的数组
fire[maxn];//记录摧毁星球的数组
inline int find(int x){
   return x==fa[x]? x:fa[x]=find(fa[x]);
}
inline int he(int x,int y){
    x=find(x);
    y=find(y);
    fa[x]=y;
}
inline void add(int x,int y){
	edge[++cnt].to=y;
	edge[cnt].self=x;
	edge[cnt].from=last[x];
	last[x]=cnt;
}
inline void init(){
	int x,y;
	n=read();m=read();
	f1(i,0,n) fa[i]=i;
	f1(i,1,m)
	{
		x=read(),y=read();
		add(x,y);//无向图加两次边
		add(y,x);
	}
	k=read();
	tot=n-k;//最后只会至多有n-k个联通块
	f1(i,1,k)
	{
		x=read();
		vis[x]=1;fire[i]=x;//标记和记录
	}
	
} 
inline void solve(){
	int sum=1;
	f1(i,1,cnt)
	{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
		if(!vis[edge[i].self]&&!vis[edge[i].to]&&find(edge[i].self)!=find(edge[i].to))//
     //这里将那些不会被摧毁的星球先检查是否可以连接起来，这里算是对打击完所有星球后所剩联通块个数的准确处理   
		{
			he(edge[i].self,edge[i].to);
			tot--;
            //如果可以联通则联通快数-1
		}
	}	
	ans[sum]=tot;//记录
	f2(i,k,1)//倒叙循环摧毁星球的顺序
	{
		tot++;//加入一个新的星球，当前仍未联通，联通快数+1
		vis[fire[i]]=0;//标记取消
		for(register int j=last[fire[i]];j;j=edge[j].from)//循环该星球所能到达的其他星球
		{
			if(!vis[edge[j].to]&&find(fire[i])!=find(edge[j].to))//如过另一个星球没被摧毁且他两没在同一个联通块
			{
				he(fire[i],edge[j].to);//联通他们
				tot--;//当前联通块数+1
			}
		}
		ans[++sum]=tot;//记录
	}
	f2(i,sum,1)//倒叙输出
	{
		print(ans[i]);
		putchar('\n');
	}
}
int main(){
    init();
	solve(); 
    return 0;
}





~~~


---

## 作者：bxd1998 (赞：0)

离线记录询问之后，逆向并查集。






```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxe=200005*2;
const int maxn=400005;
int N,M,K;
int P[maxn];
int ans[maxn],pos=0;
int cntP=0,cntArc=0,cntG=0;
bool Cancel[maxn];
struct Arc{
    int u,v;
    int next;
}Arcs[maxe];
int head[maxn],top=0;
void Pre(){memset(head,-1,sizeof(head));top=0;}
void Insert(int u,int v){
    Arcs[++top].u=u;Arcs[top].v=v;Arcs[top].next=head[u];head[u]=top;
    Arcs[++top].u=v;Arcs[top].v=u;Arcs[top].next=head[v];head[v]=top;
}
struct Query{
    int x;
}Querys[maxn];
int find(int x){return (P[x]==x)?x:P[x]=find(P[x]);}
int main(){
    scanf("%d%d",&N,&M);
    memset(Cancel,0,sizeof(Cancel));
    Pre();
    for(int i=0;i<N;i++) P[i]=i;
    int u,v;
    for(int i=1;i<=M;i++){
        scanf("%d%d",&u,&v);
        Insert(u,v);
    }
    scanf("%d",&K);
    for(int i=1;i<=K;i++) {
        scanf("%d",&Querys[i].x);
        Cancel[Querys[i].x]=true;
    }
    for(int i=0;i<N;i++){
        if(!Cancel[i]){
            cntP++;
            int u=i;
            for(int j=head[u];j!=-1;j=Arcs[j].next){
                int v=Arcs[j].v;
                if(!Cancel[v]){
                    int xx=find(u);
                    int yy=find(v);
                    if(xx!=yy){
                        P[xx]=yy;
                        cntArc++;
                    }
                }
            }
        }
    }
    cntG=cntP-cntArc;
    ans[++pos]=cntG;
    for(int i=K;i>=1;i--){
        int u=Querys[i].x;
        Cancel[u]=false;
        cntP++;
        for(int i=head[u];i!=-1;i=Arcs[i].next){
            int v=Arcs[i].v;
            if(!Cancel[v]){
                int xx=find(u);
                int yy=find(v);
                if(xx!=yy){
                    P[xx]=yy;
                    cntArc++;
                }
            }
        }
        cntG=cntP-cntArc;
        ans[++pos]=cntG;
    }
    for(int i=pos;i>=1;i--){
        printf("%d\n",ans[i]);
    }
    return 0;
}
```

---

## 作者：DYT_ (赞：0)

这道题目如果想要根据题目的描述，使用删点的方法来解决（也就是每次删一个点再刷一趟并查集）肯定是m^k的复杂度。而对于题目中那么大的数据，肯定是没法ac的。

我们可以反过来思考，删点虽然没有比较好的办法，不如从后往前来处理，不就变成接点了吗，我们可以做一趟循环，从k到1进行处理，每次把当前这个要删除的点接回到图中，并把它与它相连并且未被删去的点合并，修正ans数组。**注意**这里我们一定要用效率比较高的存图方式（邻接表）来存图，才能防止总复杂度从近似（其实要大一些）于O（m）退化到N^K或M^K。


示例代码如下：

```cpp
#include<cstdio>
#include<string>
using namespace std;
const int maxn=400005;
int n,m,k,tot,fa[maxn],lnk[maxn],son[maxn],nxt[maxn],b[maxn],ans[maxn];
struct dyt{
    int x,y;
}a[maxn];
bool vis[maxn];
inline int read(){
    int x=0; char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
    return x;
}
void add(int x,int y){//存图优化，优化时间效率 
    tot++; son[tot]=y; nxt[tot]=lnk[x]; lnk[x]=tot;
}
int getfa(int x){
    if (fa[x]==x) return x;
    fa[x]=getfa(fa[x]);
    return fa[x];
}
int main(){
    n=read(); m=read();
    for (int i=1;i<=n;i++) fa[i]=i;
    for (int i=1;i<=m;i++) {
        a[i].x=read()+1,a[i].y=read()+1;
        add(a[i].x,a[i].y); add(a[i].y,a[i].x);//无向图 
    }
    k=read();
    for (int i=1;i<=k;i++) b[i]=read()+1,vis[b[i]]=true;
    ans[k+1]=n-k;//ans数组记录删了第i个要删的点之前的联通块总数 （略拗口
    for (int i=1;i<=m;i++) 
    if (vis[a[i].x]==false&&vis[a[i].y]==false) 
        {int fax=getfa(a[i].x),fay=getfa(a[i].y);
        if (fax!=fay) fa[fax]=fay,ans[k+1]--;  //将删完点之后依然存在的点合并 
    }
    for (int i=k;i>=1;i--) {
        ans[i]=ans[i+1]+1; vis[b[i]]=false; //删点反过来之后变成接点 
        for (int j=lnk[b[i]];j;j=nxt[j]) 
        if (vis[son[j]]==false){ //把当前的点与其余没有被删除（消灭）的点合并 
            int fax=getfa(b[i]),fay=getfa(son[j]);
            if (fax!=fay) fa[fax]=fay,ans[i]--;
        }
    }
    for (int i=1;i<=k+1;i++) printf("%d\n",ans[i]); 
    return 0;
}
```

---

## 作者：安好 (赞：0)

/\*
这个题用并查集的话必须离线

假设要删的哪些星球不存在，要一个一个往上加

加一次统计一遍连通分量个数

这样用并查集就可以维护了

\*/









```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int X = 400005;
int p[X];
struct node{
    int x,y,next;
}edge[X*2];
int po[X],tol;
bool use[X];
int a[X],tot;
int vec[X];
int n,m;
void add(int x,int y)
{
    edge[++tol].x=x;
    edge[tol].y=y;
    edge[tol].next=po[x];
    po[x]=tol;
}
int find_set(int x)
{
    if(x!=p[x])
        p[x]=find_set(p[x]);
    return p[x];
}
void init()
{
    memset(po,0,sizeof(po));
    tol=0;
    for(int i=1;i<=n;i++)
    {
        use[i]=true;
        p[i]=i;
    }
    int x,y;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        x++;
        y++;
        add(x,y);
        add(y,x);
    }
    scanf("%d",&tot);
    for(int i=1;i<=tot;i++)
    {
        scanf("%d",&a[i]);
        a[i]++;
        use[a[i]] = false;//先将要删的边标记。 
    }
}
void solve()
{
    int x,y,px,py;
    for(int i=1;i<=tol;i+=2)
    {
        x=edge[i].x;
        y=edge[i].y;
        if(use[x]&&use[y])//合并 
        {
            px=find_set(x);
            py=find_set(y);
            p[px]=py;
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)//统计连通分量 
        if(use[i]&&p[i]==i)
            ans++;
    for(int i=tot;i;i--)//倒序 离线 
    {
        vec[i]=ans;
        int x=a[i];
        use[x]=1;//加入一个星球 
        ans++;
        for(int j=po[x];j;j=edge[j].next)//加边统计 
        {
            int y=edge[j].y;
            if(use[y])
            {
                py=find_set(y);
                px=find_set(x);
                if(px!=py)
                {
                    p[px]=py;
                    ans--;
                }
            }
        }
    }
    vec[0] = ans;
    for(int i=0;i<=tot;i++)
        printf("%d\n",vec[i]);
}
int main()
{
    scanf("%d%d",&n,&m);
    init();
    solve();
    return 0;
}
```

---


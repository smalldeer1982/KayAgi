# [KOI 2022 Round 2] 树与查询

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

有一个由 1 到 $N$ 的 $N$ 个节点组成的树。第 $i$ 条边连接两个不同的节点 $A_i$ 和 $B_i$。（$1 \leq i \leq N - 1$）

在这 $N$ 个节点中选择一些节点，记为 $S = \{s_1, s_2, \dots, s_K\}$。如果存在 $i$ （$1 \leq i \leq K$），使得 $s_i = v$，则称节点 $v$ 属于集合 $S$。

如果集合 $S$ 中的两个不同节点 $u$ 和 $v$ 满足，仅通过集合 $S$ 中的节点即可在树上从 $u$ 移动到 $v$，则称“$u$ 和 $v$ 在 $S$ 上是连接的”。

例如，考虑如下树（$N = 7$）。如果 $K = 6$ 且 $S = \{1, 2, 3, 4, 5, 6\}$，则 “1 和 2”、“3 和 5”、“4 和 6”在集合 $S$ 上是连接的。

![](https://cdn.luogu.com.cn/upload/image_hosting/iioob9ly.png)

然而，“1 和 6”、“2 和 7”在集合 $S$ 上不是连接的。

我们定义满足以下条件的节点对 $(u, v)$ 的数量为集合 $S$ 的连接强度：

1. $u$ 和 $v$ 是不同的两个节点。
2. $1 \leq u < v \leq N$。
3. $u$ 和 $v$ 在集合 $S$ 上是连接的。

给定一个选择的节点集合 $S$，请计算 $S$ 的连接强度。你需要回答 $Q$ 个查询。

## 说明/提示

**约束条件**

- $2 \leq N \leq 250,000$
- $1 \leq Q \leq 100,000$
- 对于所有的 $i$（$1 \leq i \leq N - 1$），有 $1 \leq A_i \leq N$。
- 对于所有的 $i$（$1 \leq i \leq N - 1$），有 $1 \leq B_i \leq N$。
- 对于所有的 $i$（$1 \leq i \leq N - 1$），有 $A_i \neq B_i$。
- 给定的图是树。
- 对于每个查询，$1 \leq K \leq N$。
- 对于每个查询，给出的 K 个节点 $s_1, s_2, \dots, s_K$ 是不同的。
- 在 $Q$ 个查询中，所有的 $K$ 总和不超过 1,000,000。

**子任务**

1. （3 分）$N = 3$。
2. （10 分）$N \leq 50, Q \leq 50$。
3. （11 分）$N \leq 2,500, Q \leq 2,500$。
4. （13 分）每个查询中，$K = 3$。
5. （63 分）无额外约束条件。

## 样例 #1

### 输入

```
7
1 2
1 3
1 5
2 7
4 6
4 7
6
1 1
2 1 2
4 1 2 3 4
5 1 2 4 6 7
6 1 2 3 4 5 6
7 1 2 3 4 5 6 7```

### 输出

```
0
1
3
10
7
21```

# 题解

## 作者：North_encounter (赞：3)

## P12698 [KOI 2022 Round 2] 树与查询 题解

### 题目大意

给定一棵树，每次在树上选取一个点集，求在树上能够通过选中的点互相到达的点对个数

### 思路

仔细读题，大致是将树分成一些联通块，再分别计算，有了这个思路就好写了，不妨钦定 $1$ 号为根节点，同时记录下每个节点的父节点，这样就可以保证合并时向着一个方向。考虑使用并查集来维护节点关系和联通块大小，由于提前记录了每次可以使用的节点，所以每次操作只会在块内进行，由于每次都进行路径压缩，最后在每个联通块内中祖先为自己的一个节点就保存了该联通块的大小。

### 代码（附注释）


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+20;
inline int read(){
	int f=1,k=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=(k<<1)+(k<<3)+(c^48);
		c=getchar();
	}
	return f*k;
}
int n;
vector<int> e[N];//存图
int father[N];//记录父节点
int fa[N];//并查集数组
int sum[N];//记录联通块大小
int s[N];//每次可使用的节点
bool vis[N];

inline void dfs(int p){
	for(int i=0;i<e[p].size();i++){
		int v=e[p][i];
		if(v!=father[p]){
			father[v]=p;
			dfs(v);
		}
	}
	return;
}//预处理

inline int find(int x){
	if(fa[x]==x) return x;
	else return fa[x]=find(fa[x]);
}

inline void merge(int x,int y){
	x=find(x),y=find(y);
	if(x!=y){
		fa[y]=x;
		sum[x]+=sum[y];//更新联通块大小
	}
	return;
}//将y并到x上

signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		fa[i]=i;
		sum[i]=1;
	}
	int a,b;
	for(int i=1;i<=n-1;i++){
		a=read(),b=read();
		e[a].push_back(b);
		e[b].push_back(a);
	}
	dfs(1);//选定1号为根节点
	int q;
	q=read();
	while(q--){
		int k=0,a=0;
		int ans=0;
		k=read();
		for(int i=1;i<=k;i++){
			a=read();
			s[i]=a;
			vis[a]=1;//记录可以使用的节点
		}
		
		for(int i=1;i<=k;i++){
			int u=s[i];
			if(vis[father[u]]){
				merge(father[u],u);
			}
		}
		for(int i=1;i<=k;i++){
			int p=s[i];
			if(find(p)==p){
				ans+=sum[p]*(sum[p]-1)/2;
//n个数中选两个，方案数为n*(n-1)/2，小学数学
			}
		}
		cout<<ans<<endl;
		for(int i=1;i<=k;i++){
			vis[s[i]]=0;
			sum[s[i]]=1;
			fa[s[i]]=s[i];
			s[i]=0;
		}
//多测清空
	}
	
	return 0;
}
```

---

## 作者：Hughpig (赞：1)

原问题的询问中，点构成若干个连通块，每个连通块中的点都相互可达。因此对于一个大小为 $x$ 的连通块，每个点都能到达剩余 $x-1$ 个点，其贡献为 $\dfrac{x(x-1)}{2}$。

一个直接的想法是用 DFS 求给定的点中构成了多少个连通块并统计每个连通块的大小，但由于对某个点的 DFS 要遍历其全部出边，最坏情况下时间复杂度是 $O(NQ)$ 的，无法通过。

考虑均摊每条边，对于一棵树，除了根节点以外，每个节点都有且仅有一条连向父节点的边。因此对每个点定它的边就是连接它和父节点的边。

对于每个询问，如果给定的点集中出现了有父子关系的两点，那么它们之间就存在一条边，可以用并查集维护连边的关系。最后统计并查集中每个连通块的大小即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define up(l,r,i) for(int i=(l);i<=(r);++i)

ll n,q,k,a[250007],ans,f[250007],fa[250007];
vector<int> G[250007];
map<ll,ll> cnt;
map<ll,bool> vis;

ll getfa(ll u){
	return fa[u]==u?u:fa[u]=getfa(fa[u]);
}

void dfs(int u,int _f){
	f[u]=_f;
	for(int v:G[u]){
		if(v==_f)continue;
		dfs(v,u);
	}
}

int main(){
	cin>>n;
	up(2,n,i){
		ll u,v;cin>>u>>v;
		G[u].push_back(v);G[v].push_back(u);
	}
	dfs(1,0);
	cin>>q;
	while(q--){
		vis.clear();cnt.clear();ans=0;
		cin>>k;up(1,k,i)cin>>a[i],vis[a[i]]=1,fa[a[i]]=a[i];
		up(1,k,i){
			if(vis[a[i]]&&vis[f[a[i]]]){
				ll u=a[i],v=f[a[i]];
				u=getfa(u),v=getfa(v);
				fa[u]=v;
			}
		}
		up(1,k,i)++cnt[getfa(a[i])];
		for(auto tmp:cnt){
			ll qwq=tmp.second;
			ans+=(qwq-1)*(qwq)/2;
		}
		cout<<ans<<'\n';
	}
}
```

---

## 作者：fish_love_cat (赞：1)

没有均摊边导致菊花被爆了 /ng

---

一句话题解：对于每一组询问，把询问点拎出来做并查集，然后对于第 $i$ 个连通块中询问点的数量 $x_i$，答案是 $\sum \frac{x_i^2-x_i}{2}$。

正确实现是 $O(\sum K)$ 的，注意不要实现成 $O(qn)$。

一些错误的点：

+ 并查集等各种初始化写成 $O(qn)$；
+ 某一个点度数极多导致被卡成 $O(qn)$；
+ 常数过大。

然后做完了。

---

```cpp
#include<bits/stdc++.h>
// #define int long long
using namespace std;
int read(){
    int sum=0,fish=1;
    char c=getchar_unlocked();
    while((c<'0'||c>'9')&&c!='-')c=getchar_unlocked();
    if(c=='-')fish=-1,c=getchar_unlocked();
    while(c>='0'&&c<='9')sum=sum*10+(c-'0'),c=getchar_unlocked();
    return sum*fish;
}
void print(long long x){
    if(x<0)putchar_unlocked('-'),x=-x;
    if(x<10)putchar_unlocked(x+'0');
    else print(x/10),putchar_unlocked(x%10+'0');
}
int fa[250005];
int find(int x){
    return(x==fa[x]?x:fa[x]=find(fa[x]));
}
vector<int>ve[250005];
int in[250005],mp[250005];
long long ans;
signed main(){
    int n=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        if(ve[v].size())ve[u].push_back(v);
        else ve[v].push_back(u);
    }
    int q=read();
    for(int qq=1;qq<=q;qq++){
        int m=read();
        ans=0;
        vector<int>v;
        for(int i=1;i<=m;i++){
            int x=read();
            in[x]=qq;
            fa[x]=x,mp[x]=0;
            v.push_back(x);
        }
        for(int i=0;i<m;i++)
        for(int j=0;j<ve[v[i]].size();j++)
        if(in[ve[v[i]][j]]==qq&&find(v[i])!=find(ve[v[i]][j]))
        fa[find(v[i])]=find(ve[v[i]][j]);
        for(int i=0;i<m;i++)ans+=mp[find(v[i])],mp[find(v[i])]++;
        print(ans),puts("");
    }
    return 0;
}
```

---


# [蓝桥杯 2025 国 Java B] 隔离网络

## 题目描述

小蓝负责一家科技公司的数据中心安全。该数据中心包含 $N$ 台服务器，编号为 $1$ 到 $N$，以及 $M$ 条数据链路，编号为 $1$ 到 $M$。每条数据链路都连接着两台服务器。

最近，数据中心遭到了网络攻击，病毒正在通过这些链路快速蔓延。为了阻止病毒扩散，小蓝需要采取紧急措施，对网络进行隔离。他计划进行一系列操作，每次操作都包含以下两个步骤：

1. 确定当前网络中所有连通的服务器集群——即通过链路直接或间接相连的服务器集合。
2. 对于每个连通的服务器集群，禁用该集群内编号最小的那条数据链路，以切断病毒传播的途径。

小蓝会重复执行上述操作，直到数据中心的所有数据链路都被禁用、整个数据中心的网络都被隔离。对此，请你帮助小蓝计算出，他总共需要进行多少次操作？

## 说明/提示

**【样例说明】**

第一次操作：

1. 识别两个连通的服务器集群：
   - 集群 1：服务器 $(1,2,3)$
   - 集群 2：服务器 $(4,5)$

2. 对于集群 1，禁用编号最小的链路 $1-2$；对于集群 2，禁用编号最小的链路 $4-5$。

第一次操作结束后，仅剩余一个连通的服务器集群：服务器 $(2,3)$。

第二次操作：

1. 识别剩余的连通服务器集群: 服务器 $(2,3)$。
2. 禁用编号最小的链路 $2-3$。

第二次操作结束后，网络中不再有连通的服务器集群，隔离完成。总共需要 2 次操作。

**【评测用例规模与约定】**

对于 $40\%$ 的评测用例，$2 \leq N \leq 10^3$，$1 \leq M \leq \min(\frac{N \times (N-1)}{2}, 2 \times 10^3)$。

对于 $100\%$ 的评测用例，$2 \leq N \leq 10^5$，$1 \leq M \leq \min(\frac{N \times (N-1)}{2}, 2 \times 10^5)$。


## 样例 #1

### 输入

```
5 3
1 2
2 3
4 5```

### 输出

```
2```

# 题解

## 作者：fish_love_cat (赞：5)

卡了一晚上常所以随机写道水题维护一下咕值。

---

时光倒流，把删边转化为加边。

每个连通块从编号小的优先开始删，所以从编号大的开始加入。

显然的，加入的这条边如果不改变图中连通块个数，那么它的贡献仅仅是给当前连通块的答案加一。

如果改变了，所连接的两个连通块中答案较少的连通块，其操作可以与较多者并行，于是可以忽略。

所以更新取最大值即可。

开个数组记录答案，连通性用并查集维护，做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int fa[100005];
int qwq[100005];
int find(int x){
    return(x==fa[x]?x:fa[x]=find(fa[x]));
}
int maxx;
int u[200005];
int v[200005];
signed main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<=m;i++)cin>>u[i]>>v[i];
    for(int i=m;i;i--){
        qwq[find(u[i])]=max(qwq[find(u[i])],qwq[find(v[i])])+1;
        fa[find(v[i])]=find(u[i]);
    }
    for(int i=1;i<=n;i++)maxx=max(maxx,qwq[i]);
    cout<<maxx;
    return 0;
}
// 「你拖着这幅惨兮兮的身体搏斗，不就是认真把命豁出去了吗？拼成那样很恶心耶。」

// Ithea Myse Valgulious
```

---

## 作者：Yuiu2233 (赞：4)

# P12893 [蓝桥杯 2025 国 Java B] 隔离网络 题解

update: 感谢 @ [xianxi](https://www.luogu.com.cn/user/1021348) 关于文章问题的指出，修改了一处笔误。

## 题目大意

给定一个无向图，对于图中的每一个连通块每次操作删除编号最小的边，直到所有边都被删除，求操作数。

## 思路

思考删边操作，因为要求**删除编号最小的边**所以在删除时可能出现新的连通块，模拟这个过程并在每次操作后搜索连通块并不现实。

因为操作顺序是一定的，所以可以反过来思考这个过程。在一个空图中，每次操作**添加编号最大的边**，操作数是相同的。容易看出这个过程可以用并查集维护。

对于每个连通块计算操作数，记为 $num$。当前操作如果使两个连通块 $x$ 和 $y$ 相连，$num_x = \max(num_x,num_y)+1$。当前操作如果使连通块内部成环，则 $num_x=num_x+1$。

操作数即为 $num$ 中的最大值。需要离线处理加边。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,m,ans=-1;

struct Node{
	int x,y;
};
int serve[N],num[N];
Node oper[N];
vector<int> siz(N,1);

int find(int x){
	return (serve[x]==x)?x:serve[x]=find(serve[x]);
}

void unionset(int x,int y){
	x=find(x),y=find(y);
	if(x==y){
		num[x]++;
		ans=max(ans,num[x]);
		return;
	}
	if(siz[x]>siz[y]) swap(x,y);
	serve[x]=y;
	num[y]=max(num[x],num[y])+1;
	ans=max(ans,num[y]);
	siz[y]+=siz[x];
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) serve[i]=i;
	for(int i=1;i<=m;i++)
		cin>>oper[i].x>>oper[i].y;
	for(int i=m;i>=1;i--)
		unionset(oper[i].x,oper[i].y);
	cout<<ans;
	return 0;
}
```

## 复杂度

时间复杂度和并查集复杂度一致 $O(M\alpha(N))$。

空间复杂度为 $O(N+M)$。

---

## 作者：Nostopathy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12893)

因为操作顺序的固定，考虑正难则反，转化为加边，每次加编号最大的边，可用并查集维护。

假设以 $x$ 为代表节点的连通块的操作次数为 $a_x$，那么对于两个已在同一连通块中的节点，需要进行一次操作，即令 $a_x \leftarrow a_x+1$。对于两个不同连通块的合并，需要取两者操作数最大值并加上本身操作，即 $a_x \leftarrow \max(a_x,a_y)+1$（实际代码稍微不同）。答案即 $a$ 的最大值。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long // 好习惯
#define pii pair<int, int>
#define pb push_back
#define fi first
#define se second
const int N = 2e5 + 5;
int n, m, ans, f[N], s[N], siz[N];
pii b[N];
int find(int x) { // 找祖先
	return f[x] == x ? x : f[x] = find(f[x]);
}
void combine(int x, int y) {
	x = find(x);
	y = find(y);
	if(x == y) { // 出现环
		ans = max(ans, ++ s[x]); // 状态转移
		return;
	}
	if(siz[x] > siz[y]) // 将小的合并入大的
		swap(x, y);
	f[x] = y; // 合并
	ans = max(ans, s[y] = max(s[x], s[y]) + 1); // 状态转移
	siz[y] += siz[x]; // 合并大小
}
signed main () {
	cin >> n >> m;
	for(int i = 1; i <= n; ++ i) // 初始化
		f[i] = i, siz[i] = 1;
	for(int i = 1; i <= m; ++ i)
		cin >> b[i].fi >> b[i].se;
	for(int i = m; i; -- i) // 从编号大的开始
		combine(b[i].fi, b[i].se);
	cout << ans;
	return 0;
}
```

点亮并查集技能：请继续尝试 [P3367](https://www.luogu.com.cn/problem/P3367)、[P1525](https://www.luogu.com.cn/problem/P1525)、[P2024](https://www.luogu.com.cn/problem/P2024) 等题。

题解来之不易，麻烦留赞再走~

~~当然要求关啦。~~

---

## 作者：细数繁星 (赞：0)

这道题目本质是并查集板子，但是需要变形，如果你直接按照题意去敲会发现：因为要断边，所以不能路径压缩。时间直接爆炸。刚开始我也头脑风暴一小时，最后想到使用转换思想：可以注意到如果将删边变为加边，那么就不需要考虑这么多复杂的问题了，直接按照一般的并查集去敲就行了。

具体的转换细节呢？不难想到，在删除过程中，因为各个连通块要分开考虑。所以在加边时也要分开考虑。具体地：

- 因为删除时是从小到大删，所以操作时要从大到小加。
- 删除时同一连通块中只操作一次，那么添加时同一连通块也只操作一次。
- 不同连通块，总的删除次数为删除次数最多的连通块的删除次数。所以添加时不同连通块的合并中，操作数为操作较多的连通块的操作数加一。

形式化地，**从编号大的边开始，若连接的两个结点在同一连通块，该连通块操作次数加一。反之，合并两个连通块，取其中操作次数较多的并加一。**

代码就很简单了：

```cpp
#include <bits/stdc++.h>
#define rty printf("Yes\n");
#define RTY printf("YES\n");
#define rtn printf("No\n");
#define RTN printf("NO\n");
#define rep(v,b,e) for(int v=b;v<=e;v++)
#define repq(v,b,e) for(int v=b;v<e;v++)
#define rrep(v,e,b) for(int v=b;v>=e;v--)
#define rrepq(v,e,b) for(int v=b;v>e;v--)
#define stg string
#define vct vector
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

void solve() {
	
}

int fa[(int)1e5 + 5], n, m, op[(int)1e5 + 5];
struct edge {
    int u, v;
};
vct<edge> E;
int find(int x) {
    return x == fa[x] ? fa[x] : fa[x] = find(fa[x]);
}

void merge(int x, int y) {
    fa[find(x)] = find(y);
}

main() {
//	int t; cin >> t; while (t--) solve();
    cin >> n >> m;
    rep(i, 1, n) fa[i] = i;
    rep(i, 1, m) {
        int u, v;
        cin >> u >> v;
        E.push_back({u, v});
    }
    reverse(E.begin(), E.end());
    for (auto [u, v] : E) {
        int fu = find(u), fv = find(v);
        if (fu == fv) {
            op[fu]++;
        } else {
            merge(u, v);
            op[fv] = max(op[fu], op[fv]) + 1; // 顺序一定要注意，是 fu 连到 fv 上，所以 fv 才是连接后的连通块。
        }
    }
    cout << op[find(1)];
	return 0;
}

```

---

## 作者：yihang2011 (赞：0)

### [P12893 [蓝桥杯 2025 国 Java B] 隔离网络](https://www.luogu.com.cn/problem/P12893)

并查集简单题。

题目中提到了使用边在图上进行连通块的合并，所以考虑并查集。但是并查集并没有删边的操作，但正难则反，题中要求删除最小编号的边，那么我们可以添加最大编号的边。

以边编号降序遍历所有边，对于每一条边，如果这条边的两个结点本就在一个连通块中，那么这两个结点所在的连通块操作数加 $1$；否则这两个结点不在一个连通块中，合并两个连通块，则新组成的连通块的操作数为原来两个连通块的操作数的较大值再加 $1$。

时间复杂度 $O(M\alpha(n))$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define mt make_tuple
#define pqueue priority_queue
#define umap unordered_map
#define set(f, x) memset(f, x, sizeof f)
using ll = long long;
ll read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0', ch = getchar();
    }
    return x * f;
}
#define rd read()
void write(ll x) {
    if (x < 0) {
        putchar('-'), x = -x;
    } 
    if (x > 9) {
        write(x / 10);
    }
    putchar(x % 10 + '0');
}
#define wln(x) write(x); putchar('\n');
#define wt(x) write(x); putchar(' ');
#define db(x) printf(#x); putchar(':'); wln(x);

const int N = 1e5 + 10, M = 2e5 + 10;
int n, m, ans;
int f[N];
int u[M], v[M];
int num[N], sz[N];

int find(int u) {
    if (f[u] != u) {
        f[u] = find(f[u]);
    }
    return f[u];
}

int main() {
    n = rd, m = rd;
    for (int i = 1; i <= m; i++) {
        u[i] = rd, v[i] = rd;
    }
    for (int i = 1; i <= n; i++) {
        f[i] = i;
    }
    for (int i = m; i >= 1; i--) {
        int pu = find(u[i]), pv = find(v[i]);
        if (pu != pv) {
            f[pu] = pv;
            num[pv] = max(num[pv], num[pu]) + 1;
        } else {
            num[pv]++;
        }
        ans = max(ans, num[pv]);
    }
    wln(ans);
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/223675383)

---

## 作者：SudoXue (赞：0)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18947958)

甚至只有黄题难度？

本题要求在一个含有 $N$ 个点、$M$ 条有编号的无向边的图中，每次操作都在每个连通块里删掉编号最小的边，直到删光所有边为止，问总共需要多少次操作。由于 $N,M$ 可达 $10^5$ 量级，正向模拟每轮寻找连通块并删除最小边会超时。

关键在于反向思路：将删除过程倒过来看，即从空图开始，按边编号从大到小依次添加边。用并查集维护当前图的连通性，同时为每个集合记录一个值 $d$，表示该连通块在正向删除中已经经历的操作次数。插入第 $i$ 条边时：若连接了两个不同的集合 $A,B$，则合并后新集合的 $d=\max(d_A,d_B)+1$；若在同一集合内部形成环，也将该集合的 $d$ 增加 $1$。维护一个全局最大值，遍历完所有边后即为答案。

时间复杂度 $O(M\alpha(N))$。

[link](https://www.luogu.com.cn/record/221373599)

---


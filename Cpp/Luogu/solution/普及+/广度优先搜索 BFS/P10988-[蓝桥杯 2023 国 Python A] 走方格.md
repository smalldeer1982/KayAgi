# [蓝桥杯 2023 国 Python A] 走方格

## 题目描述

给定一个 $N$ 行 $N$ 列的方格，第 $i$ 行第 $j$ 列的方格坐标为 $(i, j)$，高度为
$H_{i,j}$。小蓝从左上角坐标 $(0, 0)$ 出发，目的地是右下角坐标 $(N − 1, N − 1)$。
当小蓝位于第 $r$ 行第 $c$ 列时，他有如下的移动方式：
1. 若 $r + 1 < N$，可以移动到 $(r + 1, c)$，花费 $1$ 秒；
1. 若 $c + 1 < N$，可以移动到 $(r, c + 1)$，花费 $1$ 秒；
1. 对于任意整数 $L$，若 $H_{r,c} > H_{r,c+1} > \cdots > H_{r,c+L}$，可以移动到 $(r, c + L)$，花费 $1$ 秒；
1. 对于任意整数 $L$，若 $H_{r,c} > H_{r,c−1} > \cdots > H_{r,c−L}$，可以移动到 $(r, c − L)$，花费 $1$ 秒。

现在给出方格，请问小蓝从 $(0, 0)$ 移动到 $(N − 1, N − 1)$ 最少需要多少秒？


## 说明/提示

对于 $20\%$ 的评测用例，$1 \le N \le 10$；

对于 $50\%$ 的评测用例，$1 \le N \le 100$；

对于所有评测用例，$1 \le N \le 1000,0 \le H_{i, j} \le 100$。

#### 样例解释
移动顺序为：$(0, 0)\rightarrow (1, 0)\rightarrow(2, 0)\rightarrow(3, 0)\rightarrow(3, 2)\rightarrow(3, 3)$，其中坐标 $(3, 0),(3, 1),(3, 2)$ 处的数字分别为 $9 > 8 > 0$，所以可以花费 $1$ 秒从 $(3, 0)$
移动到 $(3, 2)$。


## 样例 #1

### 输入

```
4
0 1 9 3
2 9 3 7
8 4 8 9
9 8 0 7
```

### 输出

```
5```

# 题解

## 作者：chen_kun (赞：6)

# 一道裸的 BFS 模版
[但我还是改了很久](https://www.luogu.com.cn/record/list?pid=P10988&user=469311)


首先题意很好理解，给出一个矩阵，让你从左上角走到右下角，问最少多少时间。

看到最短时间就应该马上想到 BFS 吧。

这个小蓝在正常走路的时候只能花费 1 秒向下或向右走，但是它还可以向左或向右往低海拔花费 1 秒滑铲。看到这里当时我想起了[滑雪](https://www.luogu.com.cn/problem/P1434)。

~~显然这道题和滑雪没有什么关系。~~

那到这里就很明显了，在偏移坐标的时候分类讨论就好了。

这里最原始的代码就不放了。

~~因为思路奇葩以至于我现在自己都看不懂。~~

看看我的正解（注释应该能解释我没讲的东西）。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,vis[1145][1145],a[1145][1145],dx[5]={1,0,0},dy[5]={0,1};//坐标偏移数组（虽然没什么必要） 
struct node{int x,y,cnt;};//横纵坐标与时间 
void bfs(){
	queue<node>q;
	q.push({1,1,0});
	vis[1][1]=1;
	while(!q.empty()){
		int x=q.front().x,y=q.front().y,cnt=q.front().cnt;//取出队头元素 
		if(x==n&&y==n){cout<<cnt;return;}
		for(int i=0;i<2;i++){//正常走路 
			int tx=x+dx[i],ty=y+dy[i];
			if(vis[tx][ty]==0&&tx>0&&ty>0&&tx<=n&&ty<=n) vis[tx][ty]=1,q.push({tx,ty,cnt+1});
		}
		//滑铲 
		for(int i=y+1;i<=n;i++){//向右滑铲 
			if(a[x][i]<a[x][i-1]){//判断还能不能滑铲 
				if(vis[x][i]==0) q.push({x,i,cnt+1});//判断走没走过并记录滑铲能到的点所需时间 
			}
			else break;//如果滑不动了就退出 
		}
		for(int i=y-1;i>=1;i--){//向左滑铲 
			if(a[x][i]<a[x][i+1]){//同上 
				if(vis[x][i]==0) q.push({x,i,cnt+1});
			}
			else break;
		}
		q.pop();//出队 
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>a[i][j];
	bfs();
	return 0;
}
/*

*/
```
# 敲黑板！
```
for(int i=y+1;i<=n;i++){
  if(a[x][i]<a[x][i-1]&&){
    if(vis[x][i]==0) q.push({x,i,cnt+1});
  }
  else break;
}
for(int i=y-1;i>=1;i--){
  if(a[x][i]<a[x][i+1]){
    if(vis[x][i]==0) q.push({x,i,cnt+1});
    }
  else break;
}
```
这里的话要注意滑铲时判断的两个 if 一定一定要分开，因为跳出循环是因海拔过高不能滑铲而跳出，如果写为
```
if(a[x][i]<a[x][i-1]&&vis[x][i]==0) q.push({x,i,cnt+1});
```
他跳出循环的原因可能是这个点走过了，就会导致全 WA 。

题解到这里就结束了。
###### 这是本人的第一篇题解，管理员大大给个批准吧。

---

## 作者：Polarisx (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P10988)。

随机跳题跳到的，发现题解全写的 BFS，于是写了一篇 DP 题解。

## 思路

首先容易发现操作 4 是没用的，因为（左，下，右）的操作绝对没有（下，右）操作优，于是只有向下走和向右走的操作，考虑 DP，定义 $f_{i,j,k}$ 表示当前位置为 $(i,j)$，上一步的状态是 $k$。

$k=0$ 表示这一步是从左边转移过来的，$k=1$ 表示这一步是从上边转移过来的，$k=2$ 表示没有上一步。

转移是容易的（做过普通 DP 的应该都会），这里不做介绍。

时间复杂度 $\mathcal O (n^2)$。


```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;

const int Maxn=1010;
int n;
int h[Maxn][Maxn],dp[Maxn][Maxn][3];

int main(){
    memset(dp,0x3f,sizeof dp);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&h[i][j]);
    dp[1][1][2]=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(j>=2 and h[i][j-1]>h[i][j] and h[i][j-2]>h[i][j-1]) dp[i][j][0]=min(dp[i][j][0],dp[i][j-1][0]);
            dp[i][j][0]=min(dp[i][j][0],min(dp[i][j-1][0],min(dp[i][j-1][1],dp[i][j-1][2]))+1);
            dp[i][j][1]=min(dp[i][j][1],min(dp[i-1][j][0],min(dp[i-1][j][1],dp[i-1][j][2]))+1);
        }
    }
    printf("%d",min(min(dp[n][n][0],dp[n][n][1]),dp[n][n][2]));

    system("pause");
    return 0;
}
```

---

## 作者：doooge (赞：4)

方法： BFS

先分析一下小蓝的移动方式：

- 若 $ r + 1 < N $，可以移动到 $ (r + 1 , c) $，花费 $ 1 $ 秒；
- 若 $ c + 1 < N $，可以移动到 $ (r , c + 1) $，花费 $1$ 秒；

对于这两种移动方式，我们可以用方向数组来表示两个方向。用 $tx$ 和 $ty$ 两个变量来表示移动后的行和列。

代码：

```cpp
for(int i=0;i<2;i++){
  int tx=tmp.x+dx[i],ty=tmp.y+dy[i];
  if(tx>=n||ty>=n)continue;
  if(t[tx][ty]!=-1)continue;
  t[tx][ty]=t[tmp.x][tmp.y]+1;
  q.push({tx,ty});
}
```

- 对于任意整数 $ L $，若 $ H_{ r , c } > H_{ r , c + 1 } > \cdots > H_{r , c + L} $，可以移动到 $ ( r , c + L ) $，花费 $ 1 $ 秒；
- 对于任意整数 $L$，若 $ H_{r , c} > H_{r , c−1} > \cdots > H_{r,c−L} $，可以移动到 $ (r , c − L) $，花费 $ 1 $ 秒。

对于这两种移动方式，我们可以用for循环来做。由于这题的时间限制 $3$ 秒，所以并不会超时。

代码：

```cpp
for(int i=tmp.y+1;i<n;i++){
  if(a[tmp.x][i]>=a[tmp.x][i-1])break;
  if(t[tmp.x][i]!=-1)continue;
  t[tmp.x][i]=t[tmp.x][tmp.y]+1;
  q.push({tmp.x,i});
}
for(int i=tmp.y-1;i>=0;i--){
  if(a[tmp.x][i]<=a[tmp.x][i+1])break;
  if(t[tmp.x][i]!=-1)continue;
  t[tmp.x][i]=t[tmp.x][tmp.y]+1;
  q.push({tmp.x,i});
}
```

剩下的部分就很简单了 ~~（但我还是调了很久）~~

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct ll{
	int x,y;
};
int n,a[1010][1010],t[1010][1010],dx[]={0,1},dy[]={1,0};
void bfs(){
	queue<ll>q;
	q.push({0,0});
	memset(t,-1,sizeof(t));
	t[0][0]=0;
	while(!q.empty()){
		ll tmp=q.front();
		q.pop();
		if(t[n-1][n-1]!=-1){
			cout<<t[n-1][n-1]<<endl;
			return;
		}
		for(int i=0;i<2;i++){
			int tx=tmp.x+dx[i],ty=tmp.y+dy[i];
			if(tx>=n||ty>=n)continue;
			if(t[tx][ty]!=-1)continue;
			t[tx][ty]=t[tmp.x][tmp.y]+1;
			q.push({tx,ty});
		}
		for(int i=tmp.y+1;i<n;i++){
			if(a[tmp.x][i]>=a[tmp.x][i-1])break;
			if(t[tmp.x][i]!=-1)continue;
			t[tmp.x][i]=t[tmp.x][tmp.y]+1;
			q.push({tmp.x,i});
		}
		for(int i=tmp.y-1;i>=0;i--){
			if(a[tmp.x][i]<=a[tmp.x][i+1])break;
			if(t[tmp.x][i]!=-1)continue;
			t[tmp.x][i]=t[tmp.x][tmp.y]+1;
			q.push({tmp.x,i});
		}
	}
	return;
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			cin>>a[i][j];
		}
	}
	bfs();
	return 0;
}
```

---

## 作者：lixianyuan (赞：2)

# 题解：P10988 [蓝桥杯 2023 国 Python A] 走方格
## 题意
[题目传送门](https://www.luogu.com.cn/problem/P10988)  
给定一个 $N$ 行 $N$ 列的方格，第 $i$ 行第 $j$ 列的方格高度为 $H_{i,j}$。小蓝从坐标 $(0, 0)$ 出发，目的地是坐标 $(N−1, N−1)$。
当小蓝位于第 $r$ 行第 $c$ 列时，他有如下的移动方式：
1. 若 $r+1<N$，可以移动到 $(r+1,c)$，花费代价 $1$；
2. 若 $c+1<N$，可以移动到 $(r,c+1)$，花费代价 $1$；
3. 对于任意整数 $L$，若 $H_{r,c} > H_{r,c+1} > \cdots>H_{r,c+L}$，可以移动到 $(r,c+L)$，花费代价 $1$；
4. 对于任意整数 $L$，若 $H_{r,c} > H_{r,c−1} > \cdots > H_{r,c−L}$，可以移动到 $(r,c−L)$，花费代价 $1$。  
现给出方格，问小蓝从 $(0, 0)$ 移动到 $(N−1,N−1)$ 最少需要多少秒？
## 思路
本篇题解采用 BFS 算法。  
对于移动方式 $1,2$，其实就是半个 BFS 板子。  
对于移动方式 $3$，只需遍历一遍 $L$ 即可，如果中途出现不满足 $H_{r,c} > H_{r,c+1} > \cdots > H_{r,c+L}$ 则跳出循环。  
对于移动方式 $4$，与移动方式 $3$ 类似。
## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define LL long long
#define uLL unsigned long long
#define iny int
#define itn int
#define icn cin
#define Endl "\n"
#define endl "\n"
#define For(i,a,n) for(auto i=(a);i<=(n);i++)
#define FOR(i,n,a) for(auto i=(n);i>=(a);i--)
//#define int long long
using namespace std;
const int N=2e5+10,M=1005,mod=1e9+7,Mod=998244353;
int n,st[M][M];
int mapp[M][M]; 
struct node{
	int x,y,d;
};
queue<node>q;
int dx[2]={0,1};
int dy[2]={1,0};
int/*signed*/ main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    cin>>n;
	For(i,1,n){
		For(j,1,n){
			cin>>mapp[i][j];
		}
	}
	q.push({1,1,0});
	st[1][1]=1;
	while(!q.empty()){
		node p=q.front();
		q.pop();
		int x=p.x,y=p.y,d=p.d;
		For(i,0,1){
			int nx=x+dx[i];
			int ny=y+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&!st[nx][ny]){
				if(nx==n&&ny==n){
					cout<<d+1;
					return 0;
				}
				st[nx][ny]=1;
				q.push({nx,ny,d+1});
			}
		}//移动方式1,2
		For(i,1,n-y){
			int nx=x;
			int ny=y+i;
			if(mapp[nx][ny-1]<=mapp[nx][ny]){
				break;
			}
			if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&!st[nx][ny]&&mapp[nx][ny-1]>mapp[nx][ny]){
				if(nx==n&&ny==n){
					cout<<d+1;
					return 0;
				}
				st[nx][ny]=1;
				q.push({nx,ny,d+1});
			}
		}//移动方式3
		For(i,1,y-1){
			int nx=x;
			int ny=y-i;
			if(mapp[nx][ny+1]<=mapp[nx][ny]){
				break;
			}
			if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&!st[nx][ny]&&mapp[nx][ny+1]>mapp[nx][ny]){
				if(nx==n&&ny==n){
					cout<<d+1;
					return 0;
				}
				st[nx][ny]=1;
				q.push({nx,ny,d+1});
			}
		}//移动方式4
	}
    return 0;
}
```
[AC](https://www.luogu.com.cn/record/201651005)

---

## 作者：FISH酱 (赞：2)

## 前言

这题其实是黄题难度，不要太在意难度评定了，本篇题解主要讲解广搜做法。

## 前置知识

先简单介绍广搜，以下是 oiwiki 里的介绍：

> BFS 全称是 Breadth First Search，中文名是宽度优先搜索，也叫广度优先搜索。
> 
> 是图上最基础、最重要的搜索算法之一。
> 
> 所谓宽度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。
> 
> 这样做的结果是，BFS 算法找到的路径是从起点开始的 最短 合法路径。换言之，这条路径所包含的边数最小。
> 
> 在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。
> 
> 算法过程可以看做是图上火苗传播的过程：最开始只有起点着火了，在每一时刻，有火的节点都向它相邻的所有节点传播火苗。

广搜基于队列实现，可以高效求解最短路，下面是一个广搜示范：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ld long double
#define endl "\n"

int n,sx,sy,ex,ey; // 矩阵是n*n的，sx sy是起点位置，ex ey是终点位置
bool vis[5007][5007]; // 标记数组，不走重复格子，防止卡死

struct man{
	int x,y,step; // 结构体，x y是坐标，step是步数
};
queue<man> q; // 队列，广搜基于队列实现

// 四个方向的偏移量
int d1[4]={0 ,-1,1,0};
int d2[4]={-1,0 ,0,1};

void bfs(){
	while(!q.empty()){ // 队列不为空时持续处理
		man ls=q.front(); // 获取队首
		q.pop(); // 出队

		if(ls.x==ex && ls.y==ey){ // 如果到达终点
			cout << ls.step; // 输出步数
			return; // 退出处理
		}

		for(int i=0;i<4;i++){ // 四个方向拓展下一个点
			int nx=ls.x+d1[i],ny=ls.y+d2[i]; // 计算下一个点的位置
			if(vis[nx][ny]||!(1<=nx&&nx<=n&&1<=ny&&ny<=n)) continue; // 如果走过了或越界，就跳过

			vis[nx][ny]=1; // 打标记
			q.push(man{nx,ny,ls.step+1}); // 新位置入队
		}
	}
}

int main(){
	cin>>n; // 读入n
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%1d",&vis[i][j]); // 输入矩阵
		}
	}

	cin >> sx >> sy >> ex >> ey; // 输入起点坐标和终点坐标

	q.push(man{sx,sy,0}); // 起点入队

	vis[sx][sy]=1; // 起点记得打标记
	bfs(); // 开始广搜

	return 0; // 完美结束
}
```

有几个点要注意，第一起点要打标记，第二要判断是否走过和是否越界，第三新位置要打标记。

## 思路

回到本题，题目要求我们按照规定的行走方式求出最短路步数，根据数据范围和时间限制判断，我们可以使用广搜。

由于本题题目中下标从 $0$ 开始，人们通常习惯从 $1$ 开始，所以统一从 $1$ 开始，也避免了各种麻烦。

本题的行走方式特殊，因此不能完全依赖偏移量，接下来介绍每一种行走方式该如何实现。

操作一和操作二，我们直接通过下标的加减运算即可完成，下面是代码：

```cpp
if(ls.x+1<=n&&vis[ls.x+1][ls.y]==0){ // 越界判断和标记数组检查
  vis[ls.x+1][ls.y]=1; // 打标记
  q.push(man{ls.x+1,ls.y,ls.step+1}); // 入队
}
if(ls.y+1<=n&&vis[ls.x][ls.y+1]==0){ // 越界判断和标记数组检查
  vis[ls.x][ls.y+1]=1; // 打标记
  q.push(man{ls.x,ls.y+1,ls.step+1}); // 入队
}
```

操作三和操作四，我们可以通过循环枚举来实现，这里也要记得检查边界和标记数组，同时保证枚举范围符合题目要求，及时退出，做好特判：

```cpp
for(int i=ls.y+1;i<=n;i++){ // 枚举
  if(a[ls.x][i]>=a[ls.x][i-1]) break; // 不满足条件就退出
  if(vis[ls.x][i]==0){ // 检查标记
    vis[ls.x][i]=1; // 打标记
    q.push(man{ls.x,i,ls.step+1}); // 入队
  }
}
for(int i=1;i<=ls.y-1;i++){ // 检查标记
  if(a[ls.x][i-1]>=a[ls.x][i]) break; // // 不满足条件就退出
  if(vis[ls.x][i]==0){ // 检查标记
    vis[ls.x][i]=1; // 打标记
    q.push(man{ls.x,i,ls.step+1}); // 入队
  }
}
```

将上述思路整合，然后转化为代码，加上读入和广搜准备工作，就能成为本题的正确代码。

## 代码

放代码前先提醒几个点：

1. 数组要开大一点，因为我们的下标从 $1$ 开始。
2. 起点要打标记。
3. 新位置入队时记得将步数更新。
4. 到达终点后立即输出并结束。
5. 注意越界判断，注意标记检查，注意枚举范围。

```cpp
#include <bits/stdc++.h>

#define ll long long
#define ld long double
#define endl '\n'

using namespace std;

int n;
int a[1007][1007]; // 存储方格的数字
bool vis[1007][1007]; // 标记数组

struct man{
	int x,y,step; // 定义记录坐标位置和步数的变量
};
queue<man> q; // 定义队列

void bfs(){ // 使用函数，增加可读性
	while(!q.empty()){ // 队列不为空时持续处理
		man ls=q.front(); // 获取队首元素
		q.pop(); // 出队
		
		if(ls.x==n&&ls.y==n){ // 如果抵达终点
			cout << ls.step; // 输出步数
			return; // 退出广搜
		}
		
		if(ls.x+1<=n&&vis[ls.x+1][ls.y]==0){ // 操作一，判断边界和标记
			vis[ls.x+1][ls.y]=1; // 打标记
			q.push(man{ls.x+1,ls.y,ls.step+1}); // 入队
		}
		if(ls.y+1<=n&&vis[ls.x][ls.y+1]==0){ // 操作二，判断边界和标记
			vis[ls.x][ls.y+1]=1; // 打标记
			q.push(man{ls.x,ls.y+1,ls.step+1}); // 入队
		}
		for(int i=ls.y+1;i<=n;i++){ // 枚举下标，注意范围
			if(a[ls.x][i]>=a[ls.x][i-1]){ // 如果不符合题目的条件
				break; // 退出
			}
			if(vis[ls.x][i]==0){ // 如果没有走过，即没有被标记
				vis[ls.x][i]=1; // 打标记
				q.push(man{ls.x,i,ls.step+1}); // 入队
			}
		}
		for(int i=1;i<=ls.y-1;i++){ // 枚举范围内的下标
			if(a[ls.x][i-1]>=a[ls.x][i]){ // 如果不满足条件
				break; // 退出
			}
			if(vis[ls.x][i]==0){ // 如果没有被标记为走过
				vis[ls.x][i]=1; // 打标记
				q.push(man{ls.x,i,ls.step+1}); // 入队
			}
		}
	}
}

int main(){
	cin >> n; // 读入n
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin >> a[i][j]; // 读入方格数字
		}
	}
	
	vis[1][1]=1; // 起点要打标记
	q.push(man{1,1,0}); // 起点入队
	bfs(); // 开始广搜

    return 0; // 完结撒花
}
```

---

## 作者：I_Love_DS (赞：2)

## 前言

水一发理论复杂度比 bfs 低但常数超大，比 bfs 还慢的解法。~~（可能是假的，因为算法标签没有标）~~

## 思路

首先，我们发现小人只能往下走，不能往上走。这让我联想到了[P7074 方格取数](https://www.luogu.com.cn/problem/P7074)。和本题也有异曲同工之妙，因为那道题只能往右走，不能往左走。

因为“反复横跳”是没有意义的（也就是不优的），所以我们可以不考虑往右走完又往回走的情况。

所以，考虑从上往下 DP。设 $f_{i,j}$ 表示走到 $i$ 行 $j$ 列最小代价。有如下转移式：

$f_{i,j} = \min\{f_{i,j - 1}, f_{i - 1, j}, f_{i, k}\} + 1$，其中 $k$ 满足：
- 当 $k<j$ 时，$a_{i, k} < a_{i, k + 1} < \dots < a_{i, j}$；
- 当 $k>j$ 时，$a_{i, k} < a_{i, k - 1} < \dots < a_{i, j}$。

转移式的第一部分是从左边来，第二部分是从上面来，第三部分统称是快速移动。

但这还是 $O(n^3)$ 的怎么办？

你看，这个转移式的瓶颈在枚举 $k$ 上。然鹅其实不必那么麻烦，直接拿一个数据结构：线段树！

她支持动态单点修改和区间求最小值，她再合适不过了！

~~线段树 /qq~~

所以时间复杂度降到了 $O(n^2 \log n)$。~~虽然这不是最优解但是这是复杂度最优的做法~~

## 代码

欢迎 Hack 或指出错误或证伪。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e3 + 50;

int n;
int a[N][N], f[N][N];
int l[N], r[N];

int t[4 * N];

void buildtree(int k, int l, int r) {
	if (l == r) {
		t[k] = 1 << 30;
		return;
	}
	int m = (l + r) / 2;
	buildtree(k + k, l, m);
	buildtree(k + k + 1, m + 1, r);
	t[k] = min(t[k + k], t[k + k + 1]);
}

void update(int k, int l, int r, int x, int y, int z) {
	if (l == x && r == y) {
		t[k] = min(t[k], z);
		return;
	}
	int m = (l + r) / 2;
	if (y <= m) update(k + k, l, m, x, y, z);
	else if (x > m) update(k + k + 1, m + 1, r, x, y, z);
	else update(k + k, l, m, x, m, z), update(k + k + 1, m + 1, r, m + 1, y, z);
	t[k] = min(t[k + k], t[k + k + 1]);
}

int calc(int k, int l, int r, int x, int y) {
	if (l == x && r == y) return t[k];
	int m = (l + r) / 2;
	if (y <= m) return calc(k + k, l, m, x, y);
	else if (x > m) return calc(k + k + 1, m + 1, r, x, y);
	else return min(calc(k + k, l, m, x, m), calc(k + k + 1, m + 1, r, m + 1, y));
}

// 以上是线段树模板

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= n; j++) 
			scanf("%d", &a[i][j]);
	int x;
	x = 1;
	f[1][1] = 0;
	for (int i = 2; i <= n; i++) {
		if (a[1][i] >= a[1][i - 1]) x = i;
		f[1][i] = f[1][i - 1] + 1;
		if (x != i) f[1][i] = min(f[1][i], f[1][x] + 1);
	}
	for (int i = 2; i <= n; i++) {
		buildtree(1, 1, n);
		//memset(l, 0, sizeof(l));
		l[1] = f[i - 1][1] + 1; update(1, 1, n, 1, 1, l[1]);
		x = 1;
		for (int j = 2; j <= n; j++) {
			if (a[i][j] >= a[i][j - 1]) x = j;
			l[j] = min(f[i - 1][j] + 1, l[j - 1] + 1);
			if (x != j) l[j] = min(l[j], calc(1, 1, n, x, j - 1) + 1);
			update(1, 1, n, j, j, l[j]);
			
		} // 从左面来

		buildtree(1, 1, n);
		//memset(r, 0, sizeof(r));
		r[n] = f[i - 1][n] + 1; update(1, 1, n, n, n, r[n]);
		x = n;
		for (int j = n - 1; j; j--) {
			if (a[i][j] >= a[i][j + 1]) x = j;
			r[j] = f[i - 1][j] + 1;
			if (x != j) r[j] = min(r[j], calc(1, 1, n, j + 1, x) + 1);
			update(1, 1, n, j, j, r[j]);
		} // 从右面来
		
		f[i][1] = min({l[1], r[1], f[i - 1][1] + 1});
		for (int j = 2; j <= n; j++) f[i][j] = min({f[i - 1][j] + 1, f[i][j - 1] + 1, l[j], r[j]}); // 更新 dp 数组
	}
	printf("%d\n", f[n][n]);
	return 0;
}
```

~~没卡常你们卡去吧~~

---

## 作者：RAY091016 (赞：1)

### 1. 题目解释

在一个 $n\times n$ 的矩阵中，每个点都有一定值（以下简记为 $a_{i,j}$），现在要从 $(1,1)$ 移动到 $(n,n)$，有以下四种移动方式：

- 从 $(r,c)$ 移动至 $(r,c+1)$。
- 从 $(r,c)$ 移动至 $(r+1,c)$。
- 若对于 $\forall c<i\le p$，有 $a_{r,i}<a_{r,c}$，从 $(r,c)$ 移动至 $(r,p)$。
- 若对于 $\forall p\le i<c$，有 $a_{r,i}<a_{r,c}$，从 $(r,c)$ 移动至 $(r,p)$。

求最少的移动步数。

### 2. 思路

看楼下都是 BFS，来一篇 dp 的。

首先我们知道操作 $4$ 一定是没用的，因为往左走后一定还要再向右走，浪费步数，因而我们只需考虑前三种操作。

经过一通思考得出状态转移方程：$f_{i,j}=\min(f_{i-1,j},f_{i,j-1},f_{i,p})+1$，其中 $p$ 有 $\forall p\le k<j,a_{i,k}<a_{i,j}$。

又，如果 $f_{i,j}$ 是通过第三种操作得到的，其前面两个点的值一定比其值大，如果前面第二个点的值比其值小，则其一定不是通过第三种操作得到的。

然后就可以递推了。

---

## 作者：All_Wrong_Answer (赞：1)

[题目 P10988](https://www.luogu.com.cn/problem/P10988)

## 思路：

**本题的正解应为 BFS**

因为 BFS 是逐层扩展的，所以我们可以使用一个先进先出的数据结构队列，也就是 queue 对我们得到的数据进行储存。

为了方便，我们使用结构体储存：


```cpp
struct node{
	int x,y,z;//坐标，数值
	int ss;//走到这里时用了多少秒
};
queue<node>q;
```

接下来，我们要依次处理题目中所给的四种前进方式：

第一种：

```cpp
q.push((node){uc.x+1,uc.y,u[uc.x+1][uc.y],uc.ss+1});//竖着走一格
```

第二种：

```cpp
q.push((node){uc.x,uc.y+1,u[uc.x][uc.y+1],uc.ss+1});//横着走一格
```
第三种：

```cpp
int ff=uc.z;
	    for(int i=uc.y+1;i<=m;i++){
	    	if(u[uc.x][i]<ff){
	    		q.push((node){uc.x,i,u[uc.x][i],uc.ss+1});//依次遍历，递减则可以走
	    		ff=u[uc.x][i];
			} 
	    	else break;
		}
```
第四种：

```cpp
ff=uc.z;
		for(int i=uc.y-1;i>=1;i--){
	    	if(u[uc.x][i]<uc.z){
	    		q.push((node){uc.x,i,u[uc.x][i],uc.ss+1});//同第三种，递减则行走
	    		ff=u[uc.x][i];
			} 
	    	else break;
		}
```
注意：为了防止重复遍历，我们还需要一个 $flag$ 数组来判重，如果走过了就直接退出。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int u[1005][1005];
bool f[1005][1005];//判重的flag数组
struct node{
	int x,y,z;
	int ss;
};//结构体
queue<node>q;
int main(){
	cin>>n;
	m=n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>u[i][j];
		}
	}
	q.push((node){1,1,u[1][1],0});
	while(!q.empty()){
		node uc=q.front();
		if(uc.x==n&&uc.y==m){
			cout<<uc.ss;
			return 0;
		}//找到了就输出
		q.pop();
		if(uc.x<=0||uc.x>n||uc.y<=0||uc.y>m||f[uc.x][uc.y]==true) continue;//边界条件与判重
		f[uc.x][uc.y]=true;
	    q.push((node){uc.x+1,uc.y,u[uc.x+1][uc.y],uc.ss+1});
	    q.push((node){uc.x,uc.y+1,u[uc.x][uc.y+1],uc.ss+1});
	    int ff=uc.z;
	    for(int i=uc.y+1;i<=m;i++){
	    	if(u[uc.x][i]<ff){
	    		q.push((node){uc.x,i,u[uc.x][i],uc.ss+1});
	    		ff=u[uc.x][i];
			} 
	    	else break;
		}
		ff=uc.z;
		for(int i=uc.y-1;i>=1;i--){
	    	if(u[uc.x][i]<uc.z){
	    		q.push((node){uc.x,i,u[uc.x][i],uc.ss+1});
	    		ff=u[uc.x][i];
			} 
	    	else break;
		}//四种前进的方法
	}
	return 0;
}
```

---

## 作者：yechenguo (赞：1)

本题运用 BFS 完成。

这道题的大的移动只能往左或右移动，所以会好考虑很多，我们只需要明白，当我们一连串移动到一半时，只要**没被走过**也是可以入队的。

```cpp

for(int i=v.y+1;i<=n;i++)
    if(a[v.x][i]<a[v.x][i-1]){if(!vis[v.x][i]) q.push({v.x,i,v.cnt+1});}
        else break;
for(int i=v.y-1;i>=1;i--)
    if(a[v.x][i]<a[v.x][i+1]){if(!vis[v.x][i]) q.push({v.x,i,v.cnt+1});}
        else break;
`````
这样，我们就把这道题转化成了一道裸 BFS 题。

最后一些零碎的讲解放注释里了。
```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
int n,a[1005][1005];
bool vis[1005][1005];
struct node{
	int x,y,cnt;
};
void bfs()
{
	queue<node>q;
	q.push({1,1,0});
	vis[1][1]=1;
	while(!q.empty())
	{
		node v=q.front();
		q.pop();
		if(v.x==n&&v.y==n)//走到了，结束程序
		{
			cout<<v.cnt;
			return ;
		}
		int xx=v.x+1;
		int yy=v.y;
		if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!vis[xx][yy])//向右走一格
			q.push({xx,yy,v.cnt+1}),vis[xx][yy]=1;
		xx=v.x;
		yy=v.y+1;
		if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!vis[xx][yy])//向下走一格
			q.push({xx,yy,v.cnt+1}),vis[xx][yy]=1;
		for(int i=v.y+1;i<=n;i++)//考虑一连串向右移动
			if(a[v.x][i]<a[v.x][i-1]){if(!vis[v.x][i]) q.push({v.x,i,v.cnt+1});}//这个括号一定要加！！！不然会括号匹配错误
			else break;//中途被断开了，结束循环
		for(int i=v.y-1;i>=1;i--)//考虑一连串向左移动
			if(a[v.x][i]<a[v.x][i+1]){if(!vis[v.x][i]) q.push({v.x,i,v.cnt+1});}//这个括号一定要加！！！不然会匹配错误
			else break;//中途被断开了，结束循环
	}
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	bfs();
 	return 0;
}
`````

---

## 作者：ChampionCyan (赞：1)

我的博客中有更好的观感，请您移步[我的 cnblogs](https://www.cnblogs.com/CyanWon/articles/18409037)，谢谢！

广搜题。

为了方便我们先定义处理更新与入队操作的 update 函数：

```cpp
inline void update(int x, int y, int w) {
    if (x < 1 || x > n || y < 1 || y > n || vis[x][y])
        return;
    vis[x][y] = true;
    q.push({x, y, w});
}
```

首先状态的处理是非常简单的，首先处理移动情况 $1,2$。

代码：

```cpp
update(x + 1, y, w + 1);
update(x, y + 1, w + 1);
```

然后处理情况 $3,4$，这里我们在循环时逐判断是否出现了高度非严格下降的情况，如果有**一定要退出循环**，否则可能会把后面本来不合法的情况加上。

代码：

```cpp
for (int j = y + 1; j <= n && h[x][j] < h[x][j - 1]; j++)
    update(x, j, w + 1);
for (int j = y - 1; j >= 1 && h[x][j] < h[x][j + 1]; j--)
    update(x, j, w + 1);
```

分析完毕，接下来给出完整满分代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int h[1001][1001], dis[1001][1001], n;
bool vis[1001][1001];

struct node {
    int x, y, w;
};

queue<node> q;

inline void update(int x, int y, int w) {
    if (x < 1 || x > n || y < 1 || y > n || vis[x][y])
        return;
    vis[x][y] = true;
    q.push({x, y, w});
}

inline int bfs() {
    update(1, 1, 0);
    while (!q.empty()) {
        int x = q.front().x, y = q.front().y, w = q.front().w;
        q.pop();
        if (x == n && y == n)
            return w;
        dis[x][y] = w;
        update(x + 1, y, w + 1);
        update(x, y + 1, w + 1);
        for (int j = y + 1; j <= n && h[x][j] < h[x][j - 1]; j++)
            update(x, j, w + 1);
        for (int j = y - 1; j >= 1 && h[x][j] < h[x][j + 1]; j--)
            update(x, j, w + 1);
    }
}

int main() {
    cin.tie(0) -> sync_with_stdio(0);
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> h[i][j];
    cout << bfs() << endl;
    return 0;
}
```

---

## 作者：17_zrz (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10988)

这是一道难度适中的宽搜题

### 思路

根据题意，小蓝可以

1. 若 $r + 1 < N$，可以移动到 $(r + 1, c)$，花费 $1$ 秒；

2. 若 $c + 1 < N$，可以移动到 $(r, c + 1)$，花费 $1$ 秒；

3. 对于任意整数 $L$，若 $H_{r,c} > H_{r,c+1} > \cdots > H_{r,c+L}$，可以移动到 $(r, c + L)$，花费 $1$ 秒；

4. 对于任意整数 $L$，若 $H_{r,c} > H_{r,c−1} > \cdots > H_{r,c−L}$，可以移动到 $(r, c − L)$，花费 $1$ 秒。

我们用宽搜搜索出每个能走的点，再依次对四种走法进行判断，能走的继续走下去，就可以做出这道题目了

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1005;
int n,h[N + 5][N + 5];
int dx[2] = {1,0};
int dy[2] = {0,1};
bool flag[N + 5][N + 5];
struct node{
	int x,y,d;
	node(int _x,int _y,int _d):
		x(_x),y(_y),d(_d) { }
};
//node中x表示当前点的行坐标，y表示当前点的列坐标，d表示走到当前点最少花了几秒
queue<node>q;
bool check(int x,int y){
	if (x < 1 || x > n)
		return true;
	if (y < 1 || y > n)
		return true;
	if (flag[x][y])
		return true;
	return false;
}
//check函数判断能不能走
signed main(){
	cin >> n;
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++)
			cin >> h[i][j];
	q.push(node(1,1,0));
    //起始位置(1,1),花了0秒
	flag[1][1] = true;
	while(!q.empty()){
		node t = q.front();
		q.pop();
		if (t.x == n && t.y == n){
			cout << t.d << "\n";
			return 0;
		}
		for(int i = 0;i < 2;i++){
			int nx = t.x + dx[i];
			int ny = t.y + dy[i];
			if (check(nx,ny))
				continue;
			q.push(node(nx,ny,t.d + 1));
			flag[nx][ny] = true;
		}
		for(int k = t.y + 1;k <= n;k++){
			int nx = t.x;
			int ny = k;
			if (h[nx][ny - 1] <= h[nx][ny])
				break;
            //判断高度
			if (check(nx,ny))
				continue;
			q.push(node(nx,ny,t.d + 1));
			flag[nx][ny] = true;
		}
		for(int k = t.y - 1;k >= 1;k--){
			int nx = t.x;
			int ny = k;
			if (h[nx][ny + 1] <= h[nx][ny])
				break;
            //判断高度
			if (check(nx,ny))
				continue;
			q.push(node(nx,ny,t.d + 1));
			flag[nx][ny] = true;
		}
	}
    //宽搜
	return 0;
}
```

---

## 作者：ljc2230 (赞：1)

[P10988 \[蓝桥杯 2023 国 Python A\] 走方格](https://www.luogu.com.cn/problem/P10988)

## 题目大意

小蓝需要从 $(0,0)$ 借助多种移动方式到达 $(n-1,n-1)$，求最快到达的时间。

## 思路解析

这很明显可以看出是一道 BFS 的题目。而小蓝在 $(x,y)$ 时有一下几种移动方式：\
1\. 花费 $1$ 秒的时间向下或向右走。

```
		for(int i=0;i<=1;i++){
			int xx=t.x+dx[i];
			int yy=t.y+dy[i];
			if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!b[xx][yy]){
				b[xx][yy]=1;
				q.push({xx,yy,t.time+1});
			}
		}
```

2\. 花费 $1$ 秒的时间向左的或向右走任意格，但是要保证每一格都比前一格低。

```
		for(int i=t.y-1;i>=1;i--){
			if(a[t.x][i]<a[t.x][i+1])
				if(!b[t.x][i])q.push({t.x,i,t.time+1});
			else break;
		}
		for(int i=t.y+1;i<=n;i++){
			if(a[t.x][i]<a[t.x][i-1]){
				if(!b[t.x][i])q.push({t.x,i,t.time+1});
			else break;
		}
	}
```

当然，这里我们将下标从 $1$ 开始，方便进行操作。

## 代码

```
#include<bits/stdc++.h>
using namespace std;

int n;
int a[1005][1005];
int dx[5]={1,0};
int dy[5]={0,1};
bool b[1005][1005];
struct node{
	int x,y,time;
};

int bfs(){
	queue<node>q;
	q.push({1,1,0});
	b[1][1]=1;
	while(!q.empty()){
		node t=q.front();
		q.pop();
		if(t.x==n&&t.y==n)return t.time;
		for(int i=0;i<=1;i++){
			int xx=t.x+dx[i];
			int yy=t.y+dy[i];
			if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!b[xx][yy]){
				b[xx][yy]=1;
				q.push({xx,yy,t.time+1});
			}
		}
		for(int i=t.y-1;i>=1;i--){
			if(a[t.x][i]<a[t.x][i+1])
				if(!b[t.x][i])q.push({t.x,i,t.time+1});
			else break;
		}
		for(int i=t.y+1;i<=n;i++){
			if(a[t.x][i]<a[t.x][i-1]){
				if(!b[t.x][i])q.push({t.x,i,t.time+1});
			else break;
		}
	}
}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		cin>>a[i][j];
	cout<<bfs();
	return 0;
}
```

---

## 作者：kuaiCreator (赞：1)

# P10988 [蓝桥杯 2023 国 Python A] 走方格
## 题目大意
给一个二维网格从 $(0,0)$ 走到 $(n-1,n-1)$，一共四种决策分别是：向左、向下、移动到低于当前位置的上方、移动到低于当前位置的下方。这四种决策都只需要花费 $1$ 秒时间。
## 解题思路
考虑用广度优先搜索解决。  
1、定义状态: $f(i,j)$ 表示从 $(0,0)$ 走到 $(i,j)$ 的最少用时。  
2、目标状态: $i=n-1$ 且 $j=n-1$。  
3、枚举决策: ①左 ②下 ③移动到低于 $(i,j)$ 的上方 ④移动到低于 $(i,j)$ 的下方。  
4、约束条件: ①走过的位置不能走 ② 不能出界。  
5、剪枝策略: 无。  
6、效率分析：时间复杂度为 $O(n^2\times H_{i,j})$，空间复杂度 $O(n^2)$。  
分析数据范围 $1\le N\le 1000,0\le H_{i,j}\le 100$。运算次数约 $10^8$，用广度优先搜索不会超时。   
## 代码实现

```cpp
#include <bits/stdc++.h>
#define N 1005
using namespace std;
int n, ans, h[N][N], vis[N][N];
struct node {   //存储状态(x,y)走了s秒
	int x, y, s;
};
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-')f = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}
bool check(int x, int y) {   //出界判断
	if (x >= 0 && y >= 0 && x < n && y < n) return true;
	return false;
}
int bfs() {
	queue<node>q;
	q.push(node{0, 0, 0});
	vis[0][0] = 1;
	while (q.size()) {
		int hx = q.front().x, hy = q.front().y, hs = q.front().s;
		q.pop();										//记录队头并出队
		if (hx == n - 1 && hy == n - 1) return hs;		//到达目标状态返回
		if (!vis[hx + 1][hy] && check(hx + 1, hy)) {	//向下
			vis[hx + 1][hy] = 1;
			q.push({hx + 1, hy, hs + 1});
		}
		if (!vis[hx][hy + 1] && check(hx, hy + 1)) {	//向右
			vis[hx ][hy + 1] = 1;
			q.push({hx, hy + 1, hs + 1});
		}

		for (int j = hy - 1; j >= 1 && h[hx][j] < h[hx][j + 1]; j--) {	//移动到低于(i,j)上方
			if (vis[hx][j])continue;
			vis[hx][j] = 1;
			q.push({hx, j, hs + 1});
		}
		for (int j = hy + 1; j <= n && h[hx][j] < h[hx][j - 1]; j++) {	//移动到低于(i,j)下方
			if (vis[hx][j])continue;
			vis[hx][j] = 1;
			q.push({hx, j, hs + 1});
		}
	}
	return 0;
}
int main() {
	cin >> n;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			h[i][j] = read();
	cout << bfs();
	return 0;
}
```

---

## 作者：liuyi0905 (赞：0)

广搜模版。

每一次可以向右或向下走一步，或者当 $H_{x,y}$ 到 $H_{x,y\pm L}$ 为一个严格递减序列时，可以走到 $(x,y\pm L)$，求 $(1,1)$ 走到 $(n,n)$ 的最短路。

队列里的元素表示可以走到的点，每次枚举队列里的点，按题意去模拟，将可以走到的点入队，并标记，标记过的点就不走。

记得队列要 `pop`。

代码：
```cpp
void R(int x,int y,int w){
  if(x<1||x>n||y<1||y>n||f[x][y]){
    return;
  }
  f[x][y]=1;
  q.push({x,y,w});
}
int S(){
  for(R(1,1,0);q.size();q.pop()){
    auto [x,y,w]=q.front();
    if(x==n&&y==n){
      return w;
    }
    R(x+1,y,w+1);
    R(x,y+1,w+1);
    for(int i=y+1;i<=n&&a[x][i]<a[x][i-1];R(x,i++,w+1)){
    }
    for(int i=y-1;i>=1&&a[x][i]<a[x][i+1];R(x,i--,w+1)){
    }
  }
}
```

---

## 作者：LRRabcd (赞：0)

# 题意

小蓝要从 $(0,0)$ 走到 $(n-1,n-1)$，他有四种走法：

- 向下走一格 $(x,y) \to (x+1,y)$。
- 向右走一格 $(x,y) \to (x,y+1)$。
- 向右走若干格，前提是走到那个格子的路线高度是递减的。
- 向左走若干格，前提也是走到那个格子的路线高度是递减的。

---

由于是求最少的步数且花费均为 $1$ 秒，所以考虑用 BFS 求解。

BFS 时有四种情况：

1. 向下走：如果 $(x+1,y)$ 没有出界且没有走过，入队。
2. 向右走：如果 $(x,y+1)$ 没有出界且没有走过，入队。

   向下走和向右走的代码：

   ```cpp
   for(int i=0;i<2;i++){
     int tx=t.x+dx[i];//dx[0]=1,dx[1]=0
     int ty=t.y+dy[i];//dy[0]=0,dy[1]=1
     if(tx<1||ty<1||tx>n||ty>n){
       continue;
     }
     if(vis[tx][ty]){
       continue;
     }
     q.push({tx,ty,t.step+1});
     vis[tx][ty]=1;
     if(tx==n&&ty==n){
       cout<<t.step+1;
       return 0;
     }
   }
   ```
3. 向右走若干格，`for` 循环往右边走，如果出界了或者 $a_{x,y-1}\leq a_{x,y}$ 直接 `break`，若 $a_{x,y}$ 走过了 `continue`。
4. 向左走若干格，`for` 循环往左边走，如果出界了或者 $a_{x,y+1}\leq a_{x,y}$ 直接 `break`，若 $a_{x,y}$ 走过了 `continue`。

   向右走若干格和向左走若干格的代码：

   ```cpp
   for(int i=1;i<=n;i++){
     int tx=t.x;
     int ty=t.y+dy[1]*i;
     if(tx<1||ty<1||tx>n||ty>n||a[t.x][ty-1]<=a[tx][ty]){
       break;
     }
     if(vis[tx][ty]){
       continue;
     }
     q.push({tx,ty,t.step+1});
     vis[tx][ty]=1;
     if(tx==n&&ty==n){
       cout<<t.step+1;
       return 0;
     }
   }
   for(int i=1;i<=n;i++){
     int tx=t.x;
     int ty=t.y-dy[1]*i;
     if(tx<1||ty<1||tx>n||ty>n||a[t.x][ty+1]<=a[tx][ty]){
       break; 
     }
     if(vis[tx][ty]){
       continue;
     }
     q.push({tx,ty,t.step+1});
     vis[tx][ty]=1;
     if(tx==n&&ty==n){
       cout<<t.step+1;
       return 0;
     }
   }
   ```

# 代码

```cpp
#include<iostream>
#include<queue>
using namespace std;
int a[1005][1005];
struct node{
	int x,y;
	int step;
};
queue<node>q;
bool vis[1005][1005];
int dx[3]={1,0};
int dy[3]={0,1};
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	q.push({1,1,0});
	vis[1][1]=1;
	while(q.size()){
		node t=q.front();
		q.pop();
		for(int i=0;i<2;i++){
			int tx=t.x+dx[i];
			int ty=t.y+dy[i];
			if(tx<1||ty<1||tx>n||ty>n){
				continue;
			}
			if(vis[tx][ty]){
				continue;
			}
			q.push({tx,ty,t.step+1});
			vis[tx][ty]=1;
			if(tx==n&&ty==n){
				cout<<t.step+1;
				return 0;
			}
		}
		for(int i=1;i<=n;i++){
			int tx=t.x;
			int ty=t.y+dy[1]*i;
			if(tx<1||ty<1||tx>n||ty>n||a[t.x][ty-1]<=a[tx][ty]){
				break;
			}
			if(vis[tx][ty]){
				continue;
			}
			q.push({tx,ty,t.step+1});
			vis[tx][ty]=1;
			if(tx==n&&ty==n){
				cout<<t.step+1;
				return 0;
			}
		}
		for(int i=1;i<=n;i++){
			int tx=t.x;
			int ty=t.y-dy[1]*i;
			if(tx<1||ty<1||tx>n||ty>n||a[t.x][ty+1]<=a[tx][ty]){
				break; 
			}
			if(vis[tx][ty]){
				continue;
			}
			q.push({tx,ty,t.step+1});
			vis[tx][ty]=1;
			if(tx==n&&ty==n){
				cout<<t.step+1;
				return 0;
			}
		}
	}
	return 0;
}
```

---

## 作者：grass_dream (赞：0)

[更好的阅读体验](https://www.luogu.com.cn/article/twl9rvg8)

[题目传送门](https://www.luogu.com.cn/problem/P10988)

方法：BFS

这可以说是一道很经典的 BFS 了，思路就是分类讨论每种移动方式，现在，我们开始讨论：

* 若 $r + 1 < N$，可以移动到 $(r + 1, c)$，花费 $1$ 秒；

* 若 $c + 1 < N$，可以移动到 $(r, c + 1)$，花费 $1$ 秒；

对于这两个操作，我们可以都考虑一遍：



```cpp

if(step[k.x+1][k.y]==INF&&check(k.x+1,k.y)){//判断出不出界和判断有没有走过
	step[k.x+1][k.y]=step[k.x][k.y]+1;
	q.push({k.x+1,k.y});
}
if(step[k.x][k.y+1]==INF&&check(k.x,k.y+1)){
	step[k.x][k.y+1]=step[k.x][k.y]+1;
	q.push({k.x,k.y+1});
}

```
* 对于任意整数 $L$，若 $H_{r,c} > H_{r,c+1} > \cdots > H_{r,c+L}$，可以移动到 $(r, c + L)$，花费 $1$ 秒；

* 对于任意整数 $L$，若 $H_{r,c} > H_{r,c-1} > \cdots > H_{r,c-L}$，可以移动到 $(r, c - L)$，花费 $1$ 秒。

对于这两个操作，我们可以直接进行遍历：

```cpp

for(int i=k.y+1;i<=n;++i){//关于（r,c+l）的遍历
	if(h[k.x][i]>=h[k.x][i-1])break;//过了
	if(step[k.x][i]!=INF)continue;//已经有了
	step[k.x][i]=step[k.x][k.y]+1;//赋值
	q.push({k.x,i});//入队
}
for(int i=k.y-1;i>=1;--i){//关于（r,c-l）的遍历
	if(h[k.x][i]>=h[k.x][i+1])break;
	if(step[k.x][i]!=INF)continue;
	step[k.x][i]=step[k.x][k.y]+1;
	q.push({k.x,i});
}

```

从而，我们四种操作都解决了，这道题也就解决了，其他的直接按照 BFS 模板即可ψ(｀∇´)ψ

# AC code:

```cpp

#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f;
int n,ans=0,h[1001][1001];
struct stu{
	int x,y;
};
int step[1001][1001];
bool check(int x,int y){
	if(x>n||x<1)return false;
	if(y>n||y<1)return false;
	return true;
}
void bfs(){
	memset(step,INF,sizeof(step));
	queue<stu>q;q.push({1,1});
	step[1][1]=0;
	while(!q.empty()){
		stu k=q.front();q.pop();
		if(step[n][n]!=INF){
			cout<<step[n][n]<<endl;
			return;
		}
		if(step[k.x+1][k.y]==INF&&check(k.x+1,k.y)){
			step[k.x+1][k.y]=step[k.x][k.y]+1;
			q.push({k.x+1,k.y});
		}
		if(step[k.x][k.y+1]==INF&&check(k.x,k.y+1)){
			step[k.x][k.y+1]=step[k.x][k.y]+1;
			q.push({k.x,k.y+1});
		}
		for(int i=k.y+1;i<=n;++i){
			if(h[k.x][i]>=h[k.x][i-1])break;
			if(step[k.x][i]!=INF)continue;
			step[k.x][i]=step[k.x][k.y]+1;
			q.push({k.x,i});
		}
		for(int i=k.y-1;i>=1;--i){
			if(h[k.x][i]>=h[k.x][i+1])break;
			if(step[k.x][i]!=INF)continue;
			step[k.x][i]=step[k.x][k.y]+1;
			q.push({k.x,i});
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			scanf("%d",&h[i][j]);
		}
	}
	bfs();
	return 0;
} 

```

---


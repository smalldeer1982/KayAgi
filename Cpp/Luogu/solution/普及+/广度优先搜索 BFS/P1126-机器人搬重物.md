# 机器人搬重物

## 题目描述

机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径 $1.6$ 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 $N\times M$ 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：

- 向前移动 $1$ 步（`Creep`）；
- 向前移动 $2$ 步（`Walk`）；
- 向前移动 $3$ 步（`Run`）；
- 向左转（`Left`）；
- 向右转（`Right`）。

每个指令所需要的时间为 $1$ 秒。请你计算一下机器人完成任务所需的最少时间。

## 样例 #1

### 输入

```
9 10
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 1 0
7 2 2 7 S```

### 输出

```
12```

# 题解

## 作者：雒仁韬 (赞：271)

这道题，毫无疑问，就是广搜。但是它要注意的细节非常多。所以这道题对逻辑和代码能力的的考察很高

首先，这道题需要注意，障碍物是在格子上，而机器人是在格点上走。某人~~就是我~~自信地写完了代码后发现题读错了。关键最讨厌的是样例居然能过......

那么这道题经过信息整理可以发现，我们需要两个数组：一个存方格上障碍物的位置(sd[i][j]数组表示)，一个存机器人可以走的格点的位置(a[i][j])数组表示，则根据样例我们可以整理成这张图：
![样例图示](https://cdn.luogu.com.cn/upload/pic/40415.png)
其中黑色为数组sd[i][j]的下标，绿色为a[i][j]的下标。根据题目可以发现，机器人本身也有宽度，所以边界和障碍物的四周，不能走，那么机器人可以到达的地方就是图中蓝色框内的绿色格点。所以边界条件判断时，n和m各要减1。

然后我们还需要注意的地方是题中~~害人不浅~~的方向处理。于是为了方便存储，我给每个方向都编了一个号：↑为1，↓为2，←为3，→为4。然后转向的时候就更加麻烦了。于是我为了好判断情况，emm......用了好几个数组
```cpp
int fx[5]={0,-1,1,0,0};//fx[i]表方向i(编号)的x的进退情况  
int fy[5]={0,0,0,-1,1};//fy[i]表方向i(编号)的y的进退情况 
int ft[5]={0,1,4,2,3};//ft[i]表示顺时针排列各个方向的编号(上1 右4 下2 左3) 
int fft[5]={0,1,3,4,2};//fft[i]表示数字i在ft[]数组中的下标 
int abc[5]={0,1,2,1,0};//abc[5]表示转到[顺时针转i次到达的那个方向]的最短次数 

```
其中ft数组和abc数组比较难理解

先讲abc数组
![abc数组解释](https://cdn.luogu.com.cn/upload/pic/40416.png)
如图，不难看出当对于不同的i，也就是顺时针转动i次时，对应的最小旋转次数就是abc[i]

而ft数组~~也比较好理解~~
abc图中蓝圈内四个方向各有一个黑色数字代表方向编号，那么我们顺时针遍历一下就是1 4 2 3.

我么还要注意的地方是起点和终点可能重合，需要特判；起点可能就有障碍物，也要特判。

最后要注意的是，对于每一步，你走一个格点，两个格点或三个格点所耗时间都是1，不要搞乱；而每转90°，就要耗一定时间，所以千万要小心。

于是，开始写BFS

用队列存储每一个格点的信息，然后起点入队，每次从队首取出一个元素，根据这个元素旋转，直行，得到一个新的坐标，然后判断由这种方式到达的这个点是否是耗时最短的一种方式(类似于Dijkstra中的dis数组)，此处用f[i][j]数组表示，然后队列为空后，输出f[终点的x][终点的y]即可。

~~丧心病狂的~~代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
#include<queue>
#include<cmath>
#include<iomanip>
using namespace std;
int sd[55][55];
int a[55][55];//a为读入的方格地图 
int n,m;
int x11,y11;//起点 
int x2,y2;//终点 
int f[55][55];//f为格点地图 

int fx[5]={0,-1,1,0,0};//fx[i]表方向i(编号)的x情况  
int fy[5]={0,0,0,-1,1};//fy[i]表方向i(编号)的y情况 
int ft[5]={0,1,4,2,3};//ft[i]表示顺时针排列各个方向的编号(上1 右4 下2 左3) 
int fft[5]={0,1,3,4,2};//fft[i]表示数字i在ft[]数组中的下标 

int abc[5]={0,1,2,1,0};//abc[5]表示转到[顺时针转i次到达的那个方向]的最短次数 
struct node
{
	int x,y;//当前点的坐标 
	int t;//1=>N 2=>S 3=>W 4=>E 方向编号 
	int time;//从起点到当前点的最短时间 
};
queue<node> q;//队列q 
string ch;//读入起点的方向 
int cto;//起点的方向 

void fxto()
{
	switch(ch[0])
	{
		case 'N': cto=1;break;
		case 'S': cto=2;break;
		case 'W': cto=3;break;
		case 'E': cto=4;break;
	}
	return;
}
void change()
{
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			if(sd[i][j]==1)//如果当前格为障碍物，则它的四个顶点都不能走 
			{
				a[i-1][j]=1;
				a[i][j-1]=1;
				a[i-1][j-1]=1;
				a[i][j]=1;
			}
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			scanf("%d",&sd[i][j]);
		}
	}
	cin>>x11>>y11>>x2>>y2;
	cin>>ch;
	fxto();//判断ch代表的方向 
	change();//把方格地图转化为机器人可以走的格点地图 
	node first;//起点 
	first.x=x11;
	first.y=y11;
	first.t=cto;
	first.time=0;
	q.push(first);//起点入队 
	node u,d;
	while(!q.empty())
	{
		u=q.front();
		q.pop();
		for(int i=1;i<=4;++i)
		{
			int zhuan=abc[i];//[顺时针转i下的那个方向]的最短旋转次数 
			
			//求出旋转完了以后方向的编号fangx(为了方便讨论，全部当做顺时针旋转) 
			int fangx=fft[u.t]+i;//此时fangx为下标 
			if(fangx==5) fangx=1;
			if(fangx==6) fangx=2;
			if(fangx==7) fangx=3;
			if(fangx==8) fangx=4;
			fangx=ft[fangx];//此时fangx为方向编号 
			//此时fangx存的是由当前点顺时针转了i次后到达的方向的编号
			 
			for(int j=1;j<=3;++j)//走1~3步 
			{
				int lsx=u.x+fx[fangx]*j;//计算按当前旋转方向走j步的坐标 
				int lsy=u.y+fy[fangx]*j;
				if(lsx>=n || lsx<=0 || lsy>=m || lsy<=0 || (lsx==x11&&lsy==y11) || a[lsx][lsy]==1)
				{
					//判断边界和障碍物 (特判：是否为起点)
					break;
				}
				if((u.time+zhuan+1<f[u.x+fx[fangx]*j][u.y+fy[fangx]*j] || f[u.x+fx[fangx]*j][u.y+fy[fangx]*j]==0) && a[u.x+fx[fangx]*j][u.y+fy[fangx]*j]==0)
				{//如果当前点可以刷新距离，就入队 
					d.x=u.x+fx[fangx]*j;
					d.y=u.y+fy[fangx]*j; 
					d.t=fangx;
					d.time=u.time+zhuan+1;
					f[u.x+fx[fangx]*j][u.y+fy[fangx]*j]=d.time;
					q.push(d);
				}
			}
		}
	}
	if(f[x2][y2]==0 && (x2!=x11 || y2!=y11))//如果为0，代表不能走到 
	{
		cout<<"-1"<<endl;
	}
	else//否则输出终点的距离 
	cout<<f[x2][y2]<<endl;
	return 0;
}
```

---

## 作者：hawkii (赞：171)

**本蒟蒻第一个题解**

可能思想跟前面大牛有重复，如果你能留下一个赞，多谢各位鼓励。

先说定义数组变量，数组a标记障碍的，数组aa标记一个三维空间

    bool a[55][55]; //原始数据，存下不能去的点
    bool aa[55][55][4]; //☆定义一个bool空间存储那些位置+方向访问过
    int b[10000][4];//队列，b[i][0]横坐标，b[i][1]纵坐标，b[i][2]朝向，b[i][3]第几步，没用stl无他，因为手写顺手

**剩下就是bfs了，主要是维护后两个数组**

------------

### 格子转成四个点
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++){
            cin>>t;
            if(t==1)
                a[i][j] = a[i-1][j] = a[i][j-1] = a[i-1][j-1] = 1;
        }
        
### 左转右转操作
    int turn(int u, bool lr)
    {
        if(lr==0)
        {
            if(u==0) return 3;
            else return u-1;
        }
        else
        {
            if(u==3) return 0;
            else return u+1;
        }
    }
    
### ~~万众期待~~平平无奇的BFS

首先，写bfs出口：
1. 机器人移动到指定点，输出步数，exit；
2. 搜完没到指定点，输出-1，exit。

**之后，最关键的一点来了。**
**一般思路是，认为上下左右移动才是广搜的一级，而我把左转右转，走一步两步三步都看成一级，因此创建了三维的bool空间，除了位置还包括方向信息。**

队列循环内，包含4（NSWE）*3（一步两步三步）=12种情况，以及左右转两种情况。

以下两点特别注意：
1. 注意机器人不能越界，&& 一个条件；
2. 当你走三步时，有可能夸过两个不可经过的点，因此要&&上走一步条件，如果最长距离不只3步，需要加个函数特别处理。

### 万众期待的AC题解（真的是很好理解）

```cpp
#include<iostream>
using namespace std;
bool a[55][55];
bool aa[55][55][4];
int b[10000][4];
int n,m,x0,y0,x1,y1;
int step=1,flag=0;
char c;
int frot=0,rear=1;
int turn(int u, bool lr)
{
    if(lr==0)
    {
        if(u==0) return 3;
        else return u-1;
    }
    else
    {
        if(u==3) return 0;
        else return u+1;
    }
}
void bfs()
{
    int i,x,y,d,step;
    while(frot < rear)
    {
        x = b[frot][0],y = b[frot][1],d = b[frot][2],step = b[frot][3];
        if(x==x1 && y==y1)
        {
            cout << b[frot][3];
            return;
        }
        if(aa[x][y][turn(d,0)]==0){
            aa[x][y][turn(d,0)]=1;
            b[rear][0]=x;
            b[rear][1]=y;
            b[rear][2]=turn(d,0);
            b[rear++][3]=step+1;
        }
        if(aa[x][y][turn(d,1)]==0){
            aa[x][y][turn(d,1)]=1;
            b[rear][0]=x;
            b[rear][1]=y;
            b[rear][2]=turn(d,1);
            b[rear++][3]=step+1;
        }
        for(i=1;i<=3;i++){
            if(d==0 && aa[x-i][y][d]==0 && a[x-1][y]==0 && a[x-i][y]==0 && x-i>0){
                aa[x-i][y][d]=1;
                b[rear][0]=x-i;
                b[rear][1]=y;
                b[rear][2]=d;
                b[rear++][3]=step+1;
            }
            if(d==2 && aa[x+i][y][d]==0 && a[x+1][y]==0 && a[x+i][y]==0 && x+i<n){
                aa[x+i][y][d]=1;
                b[rear][0]=x+i;
                b[rear][1]=y;
                b[rear][2]=d;
                b[rear++][3]=step+1;
            }
            if(d==3 && aa[x][y-i][d]==0 && a[x][y-1]==0 && a[x][y-i]==0 && y-i>0){
                aa[x][y-i][d]=1;
                b[rear][0]=x;
                b[rear][1]=y-i;
                b[rear][2]=d;
                b[rear++][3]=step+1;
            }
            if(d==1 && aa[x][y+i][d]==0 && a[x][y+1]==0 && a[x][y+i]==0 && y+i<m){
                aa[x][y+i][d]=1;
                b[rear][0]=x;
                b[rear][1]=y+i;
                b[rear][2]=d;
                b[rear++][3]=step+1;
            }
        }
        frot++;
    }
    cout << -1;
}
int main()
{
    int i,j,d,t;
    cin>>n>>m;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++){
            cin>>t;
            if(t==1)
                a[i][j] = a[i-1][j] = a[i][j-1] = a[i-1][j-1] = 1;
        }
    cin >> x0 >> y0 >> x1 >> y1 >> c;
    if(c=='N') d = 0;
    else if(c=='E') d = 1;
    else if(c=='S') d = 2;
    else d = 3;
    aa[x0][y0][d] = 1;
    b[0][0] = x0,b[0][1] = y0, b[0][2] = d, b[0][3] = 0;
    bfs();
    return 0;
}

```

---

## 作者：OIer991215 (赞：92)

/\*
前方高能！前方高能！前方高能！

这是一道复制代码反复使用的好题。

只有我是10kb的代码过这道题的。


思路： bfs。

转弯的处理是：把转弯和走X步合并到一个操作里，消耗时间是2；

当到一个点的时候，判断到这个点的时间是否比之前到达过这点时的时间大还是小，如果是小，就入队，继续bfs

看着代码挺复杂的，其实我就是一直在复制粘贴。

本题坑点： 处理点和线的关系（注意题目给的图和样例）

0行和0列，n行和m列都是不能走的


            
            
            
            
            
                
            
            
            
            
                
    
            
            
            
            
            
        
            
            

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
queue <int> qx,qy;
queue <char> qp;
int n,m,ans;
int qxx,qyy,zx,zy;
int s[550][550];
int tot[550][550];
char p;
bool check(int x,int y)
{
    if(x>=1&&y>=1&&x<n&&y<m)
        return 1;
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
        {
            scanf("%d",&s[i][j]);
            if(s[i][j]==1)
                s[i-1][j]=s[i][j-1]=s[i-1][j-1]=1;
        }
//    for(int i=0; i<=n; i++)
//    {
//        for(int j=0; j<=m; j++)
//            printf("%d ",s[i][j]);
//        printf("\n");
//    }
    for(int i=0; i<=n; i++)
        for(int j=0; j<=m; j++)
            tot[i][j]=999999;
    scanf("%d%d%d%d",&qxx,&qyy,&zx,&zy);
    cin>>p;
    qx.push(qxx),qy.push(qyy),qp.push(p);
    tot[qxx][qyy]=0;
    while(!qx.empty())
    {
        int x=qx.front(),y=qy.front();
        char pos=qp.front();
        qx.pop(),qy.pop(),qp.pop();
        if(pos=='S')
        {
            if(check(x+1,y))
                if(tot[x][y]+1<=tot[x+1][y]  &&s[x+1][y]==0)
                {
                    tot[x+1][y]=tot[x][y]+1;
                    qx.push(x+1),qy.push(y),qp.push('S');
                }
            if(check(x+2,y))
                if(tot[x][y]+1<=tot[x+2][y]  &&s[x+1][y]==0 && s[x+2][y]==0)
                {
                    tot[x+2][y]=tot[x][y]+1;
                    qx.push(x+2),qy.push(y),qp.push('S');
                }
            if(check(x+3,y))
                if(tot[x][y]+1<=tot[x+3][y]  &&s[x+1][y]==0 && s[x+2][y]==0 &&s[x+3][y]==0)
                {
                    tot[x+3][y]=tot[x][y]+1;
                    qx.push(x+3),qy.push(y),qp.push('S');
                }
            if(check(x,y+1))
                if(tot[x][y]+2<=tot[x][y+1]  &&s[x][y+1]==0)
                {
                    tot[x][y+1]=tot[x][y]+2;
                    qx.push(x),qy.push(y+1),qp.push('E');
                }
            if(check(x,y+2))
                if(tot[x][y]+2<=tot[x][y+2]  &&s[x][y+1]==0 && s[x][y+2]==0)
                {
                    tot[x][y+2]=tot[x][y]+2;
                    qx.push(x),qy.push(y+2),qp.push('E');
                }
            if(check(x,y+3))
                if(tot[x][y]+2<=tot[x][y+3]  &&s[x][y+1]==0 && s[x][y+2]==0 &&s[x][y+3]==0)
                {
                    tot[x][y+3]=tot[x][y]+2;
                    qx.push(x),qy.push(y+3),qp.push('E');
                }
            if(check(x,y-1))
                if(tot[x][y]+2<=tot[x][y-1]  &&s[x][y-1]==0)
                {
                    tot[x][y-1]=tot[x][y]+2;
                    qx.push(x),qy.push(y-1),qp.push('W');
                }
            if(check(x,y-2))
                if(tot[x][y]+2<=tot[x][y-2]  &&s[x][y-1]==0 && s[x][y-2]==0)
                {
                    tot[x][y-2]=tot[x][y]+2;
                    qx.push(x),qy.push(y-2),qp.push('W');
                }
            if(check(x,y-3))
                if(tot[x][y]+2<=tot[x][y-3]  &&s[x][y-1]==0 && s[x][y-2]==0 &&s[x][y-3]==0)
                {
                    tot[x][y-3]=tot[x][y]+2;
                    qx.push(x),qy.push(y-3),qp.push('W');
                }
            if(check(x-1,y))
                if(tot[x][y]+3<=tot[x-1][y]  &&s[x-1][y]==0)
                {
                    tot[x-1][y]=tot[x][y]+3;
                    qx.push(x-1),qy.push(y),qp.push('N');
                }
            if(check(x-2,y))
                if(tot[x][y]+3<=tot[x-2][y]  &&s[x-1][y]==0 && s[x-2][y]==0)
                {
                    tot[x-2][y]=tot[x][y]+3;
                    qx.push(x-2),qy.push(y),qp.push('N');
                }
            if(check(x-3,y))
                if(tot[x][y]+3<=tot[x-3][y]  &&s[x-1][y]==0 && s[x-2][y]==0 &&s[x-3][y]==0)
                {
                    tot[x-3][y]=tot[x][y]+3;
                    qx.push(x-3),qy.push(y),qp.push('N');
                }
        }
        if(pos=='N')
        {
            if(check(x-1,y))
                if(tot[x][y]+1<=tot[x-1][y]  &&s[x-1][y]==0)
                {
                    tot[x-1][y]=tot[x][y]+1;
                    qx.push(x-1),qy.push(y),qp.push('N');
                }
            if(check(x-2,y))
                if(tot[x][y]+1<=tot[x-2][y]  &&s[x-1][y]==0 && s[x-2][y]==0)
                {
                    tot[x-2][y]=tot[x][y]+1;
                    qx.push(x-2),qy.push(y),qp.push('N');
                }
            if(check(x-3,y))
                if(tot[x][y]+1<=tot[x-3][y]  &&s[x-1][y]==0 && s[x-2][y]==0 &&s[x-3][y]==0)
                {
                    tot[x-3][y]=tot[x][y]+1;
                    qx.push(x-3),qy.push(y),qp.push('N');
                }
            if(check(x,y+1))
                if(tot[x][y]+2<=tot[x][y+1]  &&s[x][y+1]==0)
                {
                    tot[x][y+1]=tot[x][y]+2;
                    qx.push(x),qy.push(y+1),qp.push('E');
                }
            if(check(x,y+2))
                if(tot[x][y]+2<=tot[x][y+2]  &&s[x][y+1]==0 && s[x][y+2]==0)
                {
                    tot[x][y+2]=tot[x][y]+2;
                    qx.push(x),qy.push(y+2),qp.push('E');
                }
            if(check(x,y+3))
                if(tot[x][y]+2<=tot[x][y+3]  &&s[x][y+1]==0 && s[x][y+2]==0 &&s[x][y+3]==0)
                {
                    tot[x][y+3]=tot[x][y]+2;
                    qx.push(x),qy.push(y+3),qp.push('E');
                }
            if(check(x,y-1))
                if(tot[x][y]+2<=tot[x][y-1]  &&s[x][y-1]==0)
                {
                    tot[x][y-1]=tot[x][y]+2;
                    qx.push(x),qy.push(y-1),qp.push('W');
                }
            if(check(x,y-2))
                if(tot[x][y]+2<=tot[x][y-2]  &&s[x][y-1]==0 && s[x][y-2]==0)
                {
                    tot[x][y-2]=tot[x][y]+2;
                    qx.push(x),qy.push(y-2),qp.push('W');
                }
            if(check(x,y-3))
                if(tot[x][y]+2<=tot[x][y-3]  &&s[x][y-1]==0 && s[x][y-2]==0 &&s[x][y-3]==0)
                {
                    tot[x][y-3]=tot[x][y]+2;
                    qx.push(x),qy.push(y-3),qp.push('W');
                }
            if(check(x+1,y))
                if(tot[x][y]+3<=tot[x+1][y]  &&s[x+1][y]==0)
                {
                    tot[x+1][y]=tot[x][y]+3;
                    qx.push(x+1),qy.push(y),qp.push('S');
                }
            if(check(x+2,y))
                if(tot[x][y]+3<=tot[x+2][y]  &&s[x+1][y]==0 && s[x+2][y]==0)
                {
                    tot[x+2][y]=tot[x][y]+3;
                    qx.push(x+2),qy.push(y),qp.push('S');
                }
            if(check(x+3,y))
                if(tot[x][y]+3<=tot[x+3][y]  &&s[x+1][y]==0 && s[x+2][y]==0 &&s[x+3][y]==0)
                {
                    tot[x+3][y]=tot[x][y]+3;
                    qx.push(x+3),qy.push(y),qp.push('S');
                }
        }
        if(pos=='E')
        {
            if(check(x,y+1))
                if(tot[x][y]+1<=tot[x][y+1]  &&s[x][y+1]==0)
                {
                    tot[x][y+1]=tot[x][y]+1;
                    qx.push(x),qy.push(y+1),qp.push('E');
                }
            if(check(x,y+2))
                if(tot[x][y]+1<=tot[x][y+2]  &&s[x][y+1]==0 && s[x][y+2]==0)
                {
                    tot[x][y+2]=tot[x][y]+1;
                    qx.push(x),qy.push(y+2),qp.push('E');
                }
            if(check(x,y+3))
                if(tot[x][y]+1<=tot[x][y+3]  &&s[x][y+3]==0 && s[x][y+2]==0 &&s[x][y+1]==0)
                {
                    tot[x][y+3]=tot[x][y]+1;
                    qx.push(x),qy.push(y+3),qp.push('E');
                }
            if(check(x-1,y))
                if(tot[x][y]+2<=tot[x-1][y]  &&s[x-1][y]==0)
                {
                    tot[x-1][y]=tot[x][y]+2;
                    qx.push(x-1),qy.push(y),qp.push('N');
                }
            if(check(x-2,y));
                if(tot[x][y]+2<=tot[x-2][y]  &&s[x-1][y]==0 && s[x-2][y]==0)
                {
                    tot[x-2][y]=tot[x][y]+2;
                    qx.push(x-2),qy.push(y),qp.push('N');
                }
            if(check(x-3,y))
                if(tot[x][y]+2<=tot[x-3][y]  &&s[x-1][y]==0 && s[x-2][y]==0 &&s[x-3][y]==0)
                {
                    tot[x-3][y]=tot[x][y]+2;
                    qx.push(x-3),qy.push(y),qp.push('N');
                }
            if(check(x+1,y))
                if(tot[x][y]+2<=tot[x+1][y]  &&s[x+1][y]==0)
                {
                    tot[x+1][y]=tot[x][y]+2;
                    qx.push(x+1),qy.push(y),qp.push('S');
                }
            if(check(x+2,y));
                if(tot[x][y]+2<=tot[x+2][y]  &&s[x+1][y]==0 && s[x+2][y]==0)
                {
                    tot[x+2][y]=tot[x][y]+2;
                    qx.push(x+2),qy.push(y),qp.push('S');
                }
            if(check(x+3,y))
                if(tot[x][y]+2<=tot[x+3][y]  &&s[x+1][y]==0 && s[x+2][y]==0 &&s[x+3][y]==0)
                {
                    tot[x+3][y]=tot[x][y]+2;
                    qx.push(x+3),qy.push(y),qp.push('S');
                }
            if(check(x,y-1))
                if(tot[x][y]+3<=tot[x][y-1]  &&s[x][y-1]==0)
                {
                    tot[x][y-1]=tot[x][y]+3;
                    qx.push(x),qy.push(y-1),qp.push('W');
                }
            if(check(x,y-2))
                if(tot[x][y]+3<=tot[x][y-2]  &&s[x][y-1]==0 && s[x][y-2]==0)
                {
                    tot[x][y-2]=tot[x][y]+3;
                    qx.push(x),qy.push(y-2),qp.push('W');
                }
            if(check(x,y-3))
                if(tot[x][y]+3<=tot[x][y-3]  &&s[x][y-1]==0 && s[x][y-2]==0 &&s[x][y-3]==0)
                {
                    tot[x][y-3]=tot[x][y]+3;
                    qx.push(x),qy.push(y-3),qp.push('W');
                }
        }
        if(pos=='W')
        {
            if(check(x,y-1))
                if(tot[x][y]+1<=tot[x][y-1]  &&s[x][y-1]==0)
                {
                    tot[x][y-1]=tot[x][y]+1;
                    qx.push(x),qy.push(y-1),qp.push('W');
                }
            if(check(x,y-2))
                if(tot[x][y]+1<=tot[x][y-2]  &&s[x][y-1]==0 && s[x][y-2]==0)
                {
                    tot[x][y-2]=tot[x][y]+1;
                    qx.push(x),qy.push(y-2),qp.push('W');
                }
            if(check(x,y-3))
                if(tot[x][y]+1<=tot[x][y-3]  &&s[x][y-1]==0 && s[x][y-2]==0 &&s[x][y-3]==0)
                {
                    tot[x][y-3]=tot[x][y]+1;
                    qx.push(x),qy.push(y-3),qp.push('W');
                }
            if(check(x-1,y))
                if(tot[x][y]+2<=tot[x-1][y]  &&s[x-1][y]==0)
                {
                    tot[x-1][y]=tot[x][y]+2;
                    qx.push(x-1),qy.push(y),qp.push('N');
                }
            if(check(x-2,y))
                if(tot[x][y]+2<=tot[x-2][y]  &&s[x-1][y]==0 && s[x-2][y]==0)
                {
                    tot[x-2][y]=tot[x][y]+2;
                    qx.push(x-2),qy.push(y),qp.push('N');
                }
            if(check(x-3,y))
                if(tot[x][y]+2<=tot[x-3][y]  &&s[x-1][y]==0 && s[x-2][y]==0 &&s[x-3][y]==0)
                {
                    tot[x-3][y]=tot[x][y]+2;
                    qx.push(x-3),qy.push(y),qp.push('N');
                }
            if(check(x+1,y))
                if(tot[x][y]+2<=tot[x+1][y]  &&s[x+1][y]==0)
                {
                    tot[x+1][y]=tot[x][y]+2;
                    qx.push(x+1),qy.push(y),qp.push('S');
                }
            if(check(x+2,y))
                if(tot[x][y]+2<=tot[x+2][y]  &&s[x+1][y]==0 && s[x+2][y]==0)
                {
                    tot[x+2][y]=tot[x][y]+2;
                    qx.push(x+2),qy.push(y),qp.push('S');
                }
            if(check(x+3,y))
                if(tot[x][y]+2<=tot[x+3][y]  &&s[x+1][y]==0 && s[x+2][y]==0 &&s[x+3][y]==0)
                {
                    tot[x+3][y]=tot[x][y]+2;
                    qx.push(x+3),qy.push(y),qp.push('S');
                }
            if(check(x,y+1))
                if(tot[x][y]+3<=tot[x][y+1]  &&s[x][y+1]==0)
                {
                    tot[x][y+1]=tot[x][y]+3;
                    qx.push(x),qy.push(y+1),qp.push('E');
                }
            if(check(x,y+2))
                if(tot[x][y]+3<=tot[x][y+2]  &&s[x][y+1]==0 && s[x][y+2]==0)
                {
                    tot[x][y+2]=tot[x][y]+3;
                    qx.push(x),qy.push(y+2),qp.push('E');
                }
            if(check(x,y+3))
                if(tot[x][y]+3<=tot[x][y+3]  &&s[x][y+3]==0 && s[x][y+2]==0 &&s[x][y+1]==0)
                {
                    tot[x][y+3]=tot[x][y]+3;
                    qx.push(x),qy.push(y+3),qp.push('E');
                }
        }
        if(tot[zx][zy]!=999999)
        {
            printf("%d",tot[zx][zy]);
            return 0;
        }
    }
    printf("-1");
    return 0;
}

```

---

## 作者：林则徐 (赞：59)

一道典型的广搜题，注意以下两点即可：

1. 机器人有体积，bfs时可以将机器人的坐标，这样判断障碍物较为方便。

2. 已经访问过的位置（包括横坐标，纵坐标及方向）不可重复访问，可用一个辅助数组来判重。


附上代码：







```cpp
#include<cstdio>
#include<cstdlib>
#include<queue>
#define For(a,b,c,d) for(register int a=b;a<=c;a+=d) 
const int my[ 4 ] = { 0 , 1 , 0 , -1 } , mx[ 4 ] = { -1 , 0 , 1 , 0 } ; //每个方向的移动规则 
int n , m , maze[ 60 ][ 60 ] ;
bool vis[ 20000 ] ; //记录访问过的位置 
inline int fun( int a , int b , int c ) { return c * 2700 + a * 51 + b ;} //返回每种情况唯一对应的key值 
struct pos { //每个位置的信息 
    int x , y ; //坐标 
    int f ; //方向 
    int mov ; //已移动时间 
} ;
std::queue<pos> que ; 
inline bool zq( int x , int y ) { //判断是否撞上障碍物 
    if( maze[ x ][ y ] || maze[ x + 1 ][ y ] || maze[ x ][ y + 1 ] || maze[ x + 1 ][ y + 1 ] )
        return 1 ;
    return 0 ;
}
inline void bfs() {
    int x , y , tx , ty , f , d , mov , lx , ly ;
    char c ;
    scanf("%d %d %d %d %c" , &x , &y , &tx , &ty , &c );
    switch( c ) {
        case 'N': f = 0 ;
            break ;
        case 'E': f = 1 ;
            break ;
        case 'S': f = 2 ;
            break ;
        case 'W': f = 3 ;
            break ;
    }
    pos temp ;
    temp.x = x , temp.y = y , temp.f = f , temp.mov = 0 ;
    que.push( temp ) ;
    while( !que.empty() ) {
        temp = que.front() ;
        que.pop() ;
        x = temp.x , y = temp.y , f = temp.f , d = fun( x , y , f ) , mov = temp.mov ;
        if( x == tx && y == ty ) { //判断是否是重点 
            printf("%d",mov) ;
            exit( 0 ) ;
        }
        if( vis[ d ] ) //判断是否被访问过 
            continue ;
        vis[ d ] = 1 ;
        temp.mov ++ ;
        temp.f = ( f + 4 - 1 ) % 4 ; //左转 
        que.push( temp ) ;
        temp.f = ( f + 4 + 1 ) % 4 ; //右转 
        que.push( temp ) ;
        temp.f = f ;
        For( i , 1 , 3 , 1 ) { //向前移动 
            lx = x + mx[ f ] * i , ly = y + my[ f ] * i ;
            if( lx <= 0 || ly <= 0 || lx >= n || ly >= m || zq( lx , ly ) )
                break ;
            temp.x = lx ;
            temp.y = ly ;
            que.push( temp ) ;
        }
    }
    printf("-1");  
}
int main() { //主函数 
    scanf("%d %d" , &n , &m ) ;
    For( i , 1 , n , 1 ) {
        For( j , 1 , m , 1 ) {
            scanf("%d", &maze[ i ][ j ] );
        }
    }
    bfs() ;
    return 0;
}
```

---

## 作者：Zero神 (赞：41)

###  _[原题链接](https://www.luogu.org/problemnew/show/P1126)_ 
 
------------

# 题意：

 **机器人被用于在一个储藏室中搬运货物。储藏室是一个N×M的网格，有些格子为不可移动的障碍(空地用0表示，障碍用1表示)。机器人的中心总是在格点上,控制机器人行走有五种指令，分别是：向前移动1步；向前移动2步；向前移动3步；向左转；向右转。每个指令所需要的时间为1秒。现给出机器人的起点和当前面向的方向,以及目标终点, 请你计算一下机器人完成任务所需的最少时间。**
 
 **例如：**
 
![例子](https://cdn.luogu.com.cn/upload/pic/39.png)
 
 上图就是9行10列的格子地图,黑色部分为障碍物，不可通过，机器人起点在第七行第二列的格子的右下角，初始面向方向为南(S),终点在第二行第七列格子的右下角，则最少经过12秒可以完成任务。

### 坑点注意:
	
   **① 输入的迷宫数据是格子的位置，而机器人是在点上行走，故而需要把格子转换为点，例如输入第i行j列的格子，则点(i,j),(i-1,j-1),(i-1,j),(i,j-1)构成了该格子,因此对于每个障碍格子，要把这四个点均赋值为1**
   
   **② 因为该机器人本身也有体积，故而迷宫的边界点处也不能走。因此对于n行m列的格子迷宫(实际点的范围为0~n,0~m),可走的点的范围为(1~n-1,1~m-1)**
   
   **③ 用scanf读入起点终点及方向时 需scanf("%d%d%d%d %c",..),%d和%c之间一定要空空格，否则读入的方向将始终为空格导致错误**
   
   **④ 针对只有第6个测试点过不去的情况(就是本弱鸡了,坑了好久...)，在执行前进命令判断下一状态是否合法时，不要将判断障碍和访问标记一起判断，**
   ```cpp
 错误写法:
 for(下一步-走1格~走三格){
 	  nx=下一步的状态(x,y-位置 face-面对的方向)
 	  if(nx.x<1||nx.y<1||nx.x>=n||nx.y>=m||maze[nx.x][nx.y]||vis[nx.x][nx.y][nx.face]) break;
       //位置不合法，或者某状态到达过，直接跳出直走行为
      标记+入队
 }
 
 
 正确写法:
  for(下一步-走1格~走三格){
      nx=下一步的状态(x,y-位置 face-面对的方向)
 	  if(nx.x<1||nx.y<1||nx.x>=n||nx.y>=m||maze[nx.x][nx.y]) break;//此路不通
      if(vis[nx.x][nx.y][nx.face]) continue;//该状态扩展过了，停止此次直走，开始下一次直走
      标记+入队
 }
```
**原因:**

**假设在$t$时刻,则从 $a$ 可以直走1步(距离分别为1,2,3)到  $a+1$,$a+2$,$a+3$ ,并且目标为 $a+4$ . 然后在 $t+1$ 时刻从 $a+1$可以到 $(a+2, a+3, a+4)$，但如果采取上述错误写法，在 $t+1$ 时刻时,则因为在 $t$ 时刻，$a+2$被标记了，导致不合法直接跳出前进指令，然而实际上 $a+1$ 可以直接到 $a+4$ 的，直接返回答案即可，因此对于重复标记的过的值，只能 continue 后继续搜索其它前进距离，不能break；**


------------
#  思路：
**知道了以上坑点后，就是很普通的BFS**

**主要结构为**
```cpp
//face= 0-西(W) 1-东(E) 2-北(N) 3-南(S)
struct node{//状态结构
    int x,y,face,step;//位置 面对的方向，步数
}st,en,now,nx;//起点 终点 当前点 下一点

//访问标记数组，防止重复搜索扩展
int vis[N][N][4];状态标记数组(位置和面对的方向)

//操作数组 face=0,1,2,3时的坐标改变值
const int dx[] = {0,0,-1,1};//西东，北南
const int dy[] = {-1,1,0,0};
const int turnLeft[] = {3,2,0,1};
//左转 例如 turnLeft[0]=3,则面对西边(0)时，左转后到达南方(3)
const int turnRight[] = {2,3,1,0};//右转
```
------------

**AC完整代码如下:**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
//face= 0-西 1-东 2-北 3-南
const int dx[] = {0,0,-1,1};//face=0,1,2,3时的方向值,左右和上下
const int dy[] = {-1,1,0,0};
const int turnLeft[] = {3,2,0,1};//face=0,1,2,3时
const int turnRight[] = {2,3,1,0};
struct node{
    int x,y,face,step;//位置 面对的方向，步数
}st,en,now,nx;//起点 终点 当前点 下一点
int maze[N][N],vis[N][N][4];//迷宫地图,状态标记数组(位置和面对的方向)
int n,m,ans=-1;
void bfs(){
    queue<node> q;
    st.step = 0;
    vis[st.x][st.y][st.face] = 1;
    q.push(st);
    while(!q.empty()){
        now = q.front(),q.pop();
        if(now.x==en.x&&now.y==en.y){
            ans = now.step;
            return;
        }
        nx=now;//准备直走
        for(int i = 1; i <= 3; i++){//沿着当前方向走i步
            nx.x += dx[now.face],nx.y += dy[now.face];
            //if(nx.x<1||nx.y<1||nx.x>=n||nx.y>=m||maze[nx.x][nx.y]||vis[nx.x][nx.y][nx.face]) break;//某处走不了时，不能再继续前行
            if(nx.x<1||nx.y<1||nx.x>=n||nx.y>=m||maze[nx.x][nx.y]) break;//此路不通
            if(vis[nx.x][nx.y][nx.face]) continue;//该状态扩展过了
            //注意此处，边界处不可走(0~n行 0~m列)
            vis[nx.x][nx.y][nx.face] = 1;
            nx.step = now.step + 1;//走一步
            q.push(nx);
        }
        nx=now, nx.step = now.step + 1;//准备转换方向
        nx.face = turnLeft[now.face];//左转
        if(!vis[nx.x][nx.y][nx.face]){
            vis[nx.x][nx.y][nx.face] = 1;
            q.push(nx);
        }
        nx.face = turnRight[now.face];//右转
        if(!vis[nx.x][nx.y][nx.face]){
            vis[nx.x][nx.y][nx.face] = 1;
            q.push(nx);
        }

    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++)//读入格子的值
        for(int j = 1; j <= m; j++){
            int a;
            scanf("%d",&a);
            if(a){//该格子为障碍(i,j视为格子右下角坐标)，则障碍的四个点均不可走
                maze[i][j] = maze[i-1][j-1]= maze[i-1][j] =maze[i][j-1] = 1;
            }
        }
    scanf("%d%d%d%d %c",&st.x,&st.y,&en.x,&en.y,&st.face);
    st.face = (st.face=='W'?0:(st.face=='E'?1:(st.face=='N'?2:3)));//w-0 E-1 N-2 S-3
    bfs();
    if(ans==-1) printf("-1\n");
    else printf("%d\n",ans);
    return 0;
}


```



    

---

## 作者：CHHC (赞：28)

BFS模板题……

题解里大多是BFS做法，在此略过。

 ~~那么就用DFS作个死好了~~

---

## DFS第一步：正确但时间爆炸的写法

注意：这道题要把网格图转化成点图，所以实际的图的大小为$\mathsf{(N+1)\times(M+1)}$。于是我用了$\mathsf{a[0][0]}$ ~ $\mathsf{a[N][M]}$来存点图。

**要注意边界！！！机器人的中心不能贴着墙！！！**比如如果像我一样存图，那么能走到的范围就是$\mathsf{(1,1)}$ ~ $\mathsf{(N-1,M-1)}$。

```
int a[55][55];   //存是否有障碍

int stX,stY,stD; //起点
int enX,enY;     //终点
int ans=INF;     //答案

void dfs(int X,int Y,int D,int dep) 
{     //第X行，第Y列，方向为D(0123对应ESWN)，递归深度(距离)为dep
	if(X==enX && Y==enY)
	{
		ans=min(ans,dep);
		return;
	}
    
    dfs(X,Y,(D+1)%4,dep+1);
    dfs(X,Y,(D+3)%4,dep+1);
    
    if(D==0)
    {
    	if(Y+1<M && a[X][Y+1]==0) 									dfs(X,Y+1,D,dep+1);        	
    	if(Y+2<M && a[X][Y+1]==0 && a[X][Y+2]==0) 					dfs(X,Y+2,D,dep+1);    	    	
    	if(Y+3<M && a[X][Y+1]==0 && a[X][Y+2]==0 && a[X][Y+3]==0) 	dfs(X,Y+3,D,dep+1); 
    }
    if(D==1) ...
	if(D==2) ...
	if(D==3) ...
}

int tsl(char Dir)
{
    switch(Dir)
    {
        case 'E': return 0;
        case 'S': return 1;
        case 'W': return 2;
        case 'N': return 3;
        default: assert(0);
    }
}

int main()
{
    cin>>N>>M;
    for(int i=1;i<=N;i++)
    {
        for(int j=1;j<=M;j++)
        {
            int tmp; cin>>tmp;
            if(tmp==1)
            {
                a[i-1][j-1]=a[i-1][j]=a[i][j-1]=a[i][j]=1;
            }
        }
    }
    
    cin>>stX>>stY>>enX>>enY;
    char tmp; cin>>tmp;
    stD=tsl(tmp);
    
    dfs(stX,stY,stD,0);
    
    if(ans==INF) ans=-1;
    cout<<ans<<endl;

    return 0;
}
```

很显然，这样会无限递归爆栈。

所以说
## DFS第二步：略微改进避免无限递归
加一个mindis数组，$\mathsf{mindis[X][Y][D]}$表示目前已经搜到的到 { $\mathsf{X,Y,D}$ } 的最小距离

```
int mindis[55][55][5];

void dfs(...)
{
	if(dep>=mindis[X][Y][D]) return;
    mindis[X][Y][D]=dep;
    
    ...
}

int main()
{
	...
    for(int i=0;i<=N;i++)
    {
    	for(int j=0;j<=M;j++)
        {
        	for(int k=0;k<4;k++)
            {
            	mindis[i][j][k]=INF;
            }
        }
    }
	...
}
```
于是就有90分了。第九个点大概是卡DFS的？其他的点加起来不到60ms。

## DFS第三步：对递归过程进行珂学分析并优化

我们可以发现，在原来的DFS函数中，我们首先进行的递归调用DFS是进行旋转操作。而这样会连续转三次后才会被mindis的判断给return掉而进行下一步操作。

于是我们刚开始跑出来的路线大多都是原地转三下往前走一步这样走过去的，肯定不是最优方案，mindis数组没有得到最大限度的利用。

而进一步分析，我们发现，在除了起点以外的点，我们都应当只进行一次旋转之后向其他格子走。

于是就有了这样的优化：

DFS参数加一个bool tr，表示这一次操作能否旋转操作（根据上一次是否为旋转决定。

向前走的时候，也可以先尝试走3步（虽然其实也没太大用处啦……）

AC Code:
```
#include<bits/stdc++.h>
using namespace std;

// E S W N
// 0 1 2 3

const int INF=1e9+7;  

int N,M;
int a[55][55];

int stX,stY,stD;
int enX,enY;
int ans=INF;

int mindis[55][55][55];

void dfs(int X,int Y,int D,int dep,bool tr)
{
    if(X==enX && Y==enY)
    {
        ans=min(ans,dep);
        return;
    }
    
    if(dep>=mindis[X][Y][D]) return;
    mindis[X][Y][D]=dep;
    
    if(tr) dfs(X,Y,(D+1)%4,dep+1,false);
    if(tr) dfs(X,Y,(D+3)%4,dep+1,false);
    
    if(D==0)
    {
    	if(Y+3<M && a[X][Y+1]==0 && a[X][Y+2]==0 && a[X][Y+3]==0) 	dfs(X,Y+3,D,dep+1,true); 
    	if(Y+2<M && a[X][Y+1]==0 && a[X][Y+2]==0) 					dfs(X,Y+2,D,dep+1,true);    	
    	if(Y+1<M && a[X][Y+1]==0) 									dfs(X,Y+1,D,dep+1,true);    	
    }
    if(D==1)
    {
    	if(X+3<N && a[X+1][Y]==0 && a[X+2][Y]==0 && a[X+3][Y]==0)	dfs(X+3,Y,D,dep+1,true); 
    	if(X+2<N && a[X+1][Y]==0 && a[X+2][Y]==0)					dfs(X+2,Y,D,dep+1,true);    	
    	if(X+1<N && a[X+1][Y]==0)									dfs(X+1,Y,D,dep+1,true);    	
    }
    if(D==2)
    {
    	if(Y-3>0 && a[X][Y-1]==0 && a[X][Y-2]==0 && a[X][Y-3]==0)	dfs(X,Y-3,D,dep+1,true); 
    	if(Y-2>0 && a[X][Y-1]==0 && a[X][Y-2]==0)		 			dfs(X,Y-2,D,dep+1,true);    
    	if(Y-1>0 && a[X][Y-1]==0) 									dfs(X,Y-1,D,dep+1,true);			
    }
    if(D==3)
    {
    	if(X-3>0 && a[X-1][Y]==0 && a[X-2][Y]==0 && a[X-3][Y]==0) 	dfs(X-3,Y,D,dep+1,true); 
    	if(X-2>0 && a[X-1][Y]==0 && a[X-2][Y]==0) 					dfs(X-2,Y,D,dep+1,true); 
    	if(X-1>0 && a[X-1][Y]==0) 									dfs(X-1,Y,D,dep+1,true);		   	
    }
}

int tsl(char Dir)
{
    switch(Dir)
    {
        case 'E': return 0;
        case 'S': return 1;
        case 'W': return 2;
        case 'N': return 3;
        default: assert(0);
    }
}

int main()
{
    cin>>N>>M;
    for(int i=1;i<=N;i++)
    {
        for(int j=1;j<=M;j++)
        {
            int tmp; cin>>tmp;
            if(tmp==1)
            {
                a[i-1][j-1]=a[i-1][j]=a[i][j-1]=a[i][j]=1;
            }
        }
    }
    
    cin>>stX>>stY>>enX>>enY;
    char tmp; cin>>tmp;
    stD=tsl(tmp);
    
    for(int i=0;i<=N;i++)
    {
    	for(int j=0;j<=M;j++)
    	{
    		for(int k=0;k<4;k++)
    		{
    			mindis[i][j][k]=INF;
    		}
    	}
    }
    
    dfs(stX,stY,(stD+2)%4,2,true); //起点时可能连续旋转两次，特判一下
    dfs(stX,stY,stD,0,true);
    
    if(ans==INF) ans=-1;
    cout<<ans<<endl;

    return 0;
}

```
$$ $$
END~

其实……这种题还是BFS比较稳啊233……

管理大大求过QWQ

---

## 作者：清净 (赞：28)

##历时两个半小时，终于把这道题AC了。

###核心思路：单向bfs即可，不懂bfs的可以先去学习一下，不难掌握，而且非常有用。

**这道题其实不难，但是因为要注意的地方比较多，所以硬生生从普及-的难度到了提高-...**

**坑点列举：**

- 注意机器人是球形且有直径，所以机器人不能到达储藏室的边缘。

- 注意样例，一个障碍物直接占满一个格子，而同样因为机器人的直径问题，不能到这些格子的格点上去。

- 在移动时机器人也需要一步一步移动，所以机器人不能跨过障碍物，即遇到障碍物就必须停止。

**程序细节：**

- 判重用三维数组来判，因为这道题中，机器人的状态不只有坐标，还有方向，只记录坐标会导致无解情况出现。

- 针对【坑点列举】中的第二点，我们可以为数组加个预处理，**对于每一个障碍点（i，j），它都会使它的左上角（i-1，j-1），上方（i-1，j），左方（i，j-1）的点无法被机器人行走，利用这一点即可生成map[]数组来表示一个点能否行走。**

- scanf党记得在输入起始方向时在第一个参数内+空格，如：scanf(" %c",&starttdirection);否则记录起始方向的char变量会变成空格。


以下AC代码：（注释不多，思路和细节都在前面讲了，程序内只有结构的说明）

···cpp

```cpp
#include<cstdio>
#include<queue>
using namespace std;
struct robot{
    int x,y;//坐标值
    int direction;//方向 
    int step;
};
queue<robot> q;
bool vis[51][51][4];
bool map[52][52];
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
int main(){
    int n,m;
    int sx,sy,ex,ey,sd;//起始点和终点坐标 
    char sdirection;//起始方向 
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&map[i][j]);
            if(map[i][j]){
                map[i-1][j-1]=1;
                map[i-1][j]=1;
                map[i][j-1]=1;
            }
        }
    }
    //预处理 
    scanf("%d%d%d%d %c",&sx,&sy,&ex,&ey,&sdirection);
    if(sdirection=='E')sd=0;
    else if(sdirection=='S')sd=1;
    else if(sdirection=='W')sd=2;
    else sd=3;//将方向转化为数字便于判重 
    if(sx>=n || sx<1 || sy>=m || sy<1 || map[sx][sy]){printf("-1");return 0;}
    robot temp;
    temp.x=sx;temp.y=sy;temp.direction=sd;temp.step=0;//从起点开始，将起点状态塞进队列
    vis[sx][sy][sd]=true;//别忘了标记起始点对应的方向 
    q.push(temp);
    while(!q.empty()){
        //之后就是bfs了，枚举5种操作 并判断状态是否已被访问过，注意行走的时候的判定障碍问题 
        temp=q.front();
        q.pop();
        int nx=temp.x,ny=temp.y;
        if(nx==ex && ny==ey){printf("%d",temp.step);return 0;}//有了结果立即输出 
        for(int i=1;i<=3;i++){
            //走1步~走3步
            nx+=dx[temp.direction];ny+=dy[temp.direction];
            //哇！此题巨坑，机器人直径1.6m... 
            if(nx<1 || nx>=n || ny<1 || ny>=m || map[nx][ny])break; //重点，不能走到边界，也不能走到障碍点所影响的点，否则就不能继续走了，跳出循环 
            else if(!vis[nx][ny][temp.direction]){
                vis[nx][ny][temp.direction]=true;
                robot cnew;cnew.x=nx;cnew.y=ny;cnew.direction=temp.direction;
                cnew.step=temp.step+1; 
                q.push(cnew);
                //printf("%d %d - %d %d step:%d\n",temp.x,temp.y,cnew.x,cnew.y,cnew.step);
            }
        }
        //转向
        robot cnew;cnew.x=temp.x;cnew.y=temp.y;cnew.step=temp.step+1;
        cnew.direction=temp.direction-1;
        if(cnew.direction==-1)cnew.direction=3;//如果我从东向西转，那么应该到北 
        if(!vis[cnew.x][cnew.y][cnew.direction]){vis[cnew.x][cnew.y][cnew.direction]=true;q.push(cnew);}
        cnew.direction=temp.direction+1;
        if(cnew.direction==4)cnew.direction=0;//如果我从北向东转，那么应该到东 
        if(!vis[cnew.x][cnew.y][cnew.direction]){vis[cnew.x][cnew.y][cnew.direction]=true;q.push(cnew);}
    }
    printf("-1");//无解 
    return 0;
} 
```
```cpp

---

## 作者：zfz04 (赞：24)

# 细节广搜！

这道广搜题是一道有关图的遍历的题，套路都懂，加个队列，然后把位置一个一个塞进去；但又有许多不同的地方：

1. 机器人的中心在格点上，且有宽度，而障碍却是在格子上；对于这个问题可以将其转化，将其右上角当成机器人的位置加入队列，只需要保证其它三个格子不是障碍即可；

2. 边界处理，因为机器人是有体积的，而我们是将其右上角当成其位置进行广搜，所以要保证(x>=1&&x<n&&y>=1&&y<m);

3. 机器人有方向，且转变方向也需要时间，而且还只能向左转和向右转，**所以转到后面需要的时间为2；** 那么我们在实现代码的时候就需要将转变方向当成一个状态加入队列中；**但记住要按时间顺序加入队列**（详细看代码）；

4. 机器人有三种前进方式，加上方向也就是有3*4=12种行走方式；


------------


- 所以可以这样初始化行走方式：
```cpp
int tx[4][3]={
	{-1,-2,-3},//北 
	{0,0,0},//西 
	{1,2,3},//南 
	{0,0,0},//东 
};
int ty[4][3]={//与上面对应；
	{0,0,0},
	{-1,-2,-3},
	{0,0,0},
	{1,2,3},
};
```


------------
-  那好，有了行走方式的初始化，接下来就需要一个数组来存储方向；与上面的数组对应，0——北；1——西；2——南；3——东；这个可以在队列数组中多加一维来实现，这样就可以通过对父对象方向的加减来实现方向的改变；这就是我设置的队列：
```cpp
int f[1000005][5];//0该队列元素是否是通过旋转得来；1记录x，2记录y，3记录方向,4记录时间；
```


------------
- 接下来就是主函数里的东西了；
```cpp
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)//读入地图； 
			cin>>map[i][j];
	char c;
	cin>>f[1][1]>>f[1][2];//起始位置 ； 
	map[f[1][1]][f[1][2]]=2;//注意：1为障碍物，2表示机器人来过； 
	cin>>fx>>fy;//终点； 
	cin>>c;
	if(f[1][1]==fx&&f[1][2]==fy){//这是一个坑点；当终点与起始位置重合的时候； 
		cout<<0;
		return 0;
	}
	if(c=='N') f[1][3]=0;//初始化方向； 
	if(c=='W') f[1][3]=1;
	if(c=='S') f[1][3]=2;
	if(c=='E') f[1][3]=3;
	bfs();		
	return 0;
}
```


------------
- 开始bfs,分为三部分：

1. 前进：
```
void bfs()
{
	int head=0,tail=1;
	while(head<tail){
		head++;
		int i=0;
		for(i=0;i<=2;i++){//3种移动情况；从前进1步开始； 
			int xx=f[head][1]+tx[f[head][3]][i];
			int yy=f[head][2]+ty[f[head][3]][i];
			if(map[xx+1][yy]==1||map[xx][yy+1]==1||map[xx+1][yy+1]==1||map[xx][yy]==1) break;//如果前进更小的步数都会遇到障碍，那大步数就不需要加入队列了；这样可以解决跳过障碍物的情况； 
			if(xx>=1&&xx<n&&yy>=1&&yy<m&&map[xx][yy]==0){//边界 
				map[xx][yy]=2;//设置为来过； 
				tail++;
				f[tail][1]=xx;
				f[tail][2]=yy;
				f[tail][3]=f[head][3];//方向不变； 
				f[tail][4]=f[head][4]+1;//时间+1； 
				if(xx==fx&&yy==fy){
					cout<<f[tail][4];//到达终点； 
					return;
				}
			}
		}

```


------------

2. 转向：
```cpp
if(f[head][0]!=2){//要遍历4个方向要旋转2次；但这样有个问题：这样每个方向都会加入队列2次，但如果不这样就需要一个3维数组来记录每个方向是否来过；因为数据比较小，所以这两种方法都可取；所以我选择了代码较简洁的一种； 
			for(int j=1;j<=3;j++){//旋转，当为1的时候向左转，为3的时候向右转； 
				if(j!=2){
					tail++;
					f[tail][1]=f[head][1];//位置不变； 
					f[tail][2]=f[head][2];
					f[tail][3]=(f[head][3]+j)%4;//改变方向； 
					f[tail][4]=f[head][4]+1;//时间+1； 
					f[tail][0]=f[head][0]+1;//标记此元素由旋转得来；当此元素是由旋转过一次的元素得来时，此元素将不再进行旋转；此时f[.][0]==2; 
			}
			}
		}
	}
```


------------

- 注:这有个我的错误示范，将另外3个方向一次性加入队列，向后的在时间上加2：
```cpp
if(!f[head][0]){
	for(int j=1;j<=3;j++){
		tail++;
		f[tail][1]=f[head][1]; 
		f[tail][2]=f[head][2];
		f[tail][3]=(f[head][3]+j)%4; 
		if(j==2) f[tail][4]=f[head][4]+2;//向后转时间加2；
		else f[tail][4]=f[head][4]+1; 
		f[tail][0]=f[head][0]+1;
	}
}
```
这样为什么不行呢.因为本题是找到时间上的最优解，所以元素加入队列时也要按照时间顺序来，这样在到达终点是时间上也会是最优的；如果按照上面这样来那可能步骤上是最优的，但时间上不一定最优；

------------

3. 最后无法到达：
```cpp
	cout<<-1;
}
```


------------
### 完整AC代码：
```cpp
#include<iostream>
using namespace std;
int tx[4][3]={
	{-1,-2,-3},//北 
	{0,0,0},//西 
	{1,2,3},//南 
	{0,0,0},//东 
};
int ty[4][3]={
	{0,0,0},
	{-1,-2,-3},
	{0,0,0},
	{1,2,3},
};
int n,m,fx,fy;
int map[55][55];
int f[1000005][5];//1记录x，2记录y，3记录方向,0指向父对象,4记录时间；
void bfs(); 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)//读入地图； 
			cin>>map[i][j];
	char c;
	cin>>f[1][1]>>f[1][2];//起始位置 ； 
	map[f[1][1]][f[1][2]]=2;//注意：1为障碍物，2表示机器人来过； 
	cin>>fx>>fy;//终点； 
	cin>>c;
	if(f[1][1]==fx&&f[1][2]==fy){//这是一个坑点；当终点与起始位置重合的时候； 
		cout<<0;
		return 0;
	}
	if(c=='N') f[1][3]=0;//初始化方向； 
	if(c=='W') f[1][3]=1;
	if(c=='S') f[1][3]=2;
	if(c=='E') f[1][3]=3;
	bfs();		
	return 0;
}
void bfs()
{
	int head=0,tail=1;
	while(head<tail){
		head++;
		int i=0;
		for(i=0;i<=2;i++){//3种移动情况；从前进1步开始； 
			int xx=f[head][1]+tx[f[head][3]][i];
			int yy=f[head][2]+ty[f[head][3]][i];
			if(map[xx+1][yy]==1||map[xx][yy+1]==1||map[xx+1][yy+1]==1||map[xx][yy]==1) break;//如果前进更小的步数都会遇到障碍，那大步数就不需要加入队列了；这样可以解决跳过障碍物的情况； 
			if(xx>=1&&xx<n&&yy>=1&&yy<m&&map[xx][yy]==0){//边界 
				map[xx][yy]=2;//设置为来过； 
				tail++;
				f[tail][1]=xx;
				f[tail][2]=yy;
				f[tail][3]=f[head][3];//方向不变； 
				f[tail][4]=f[head][4]+1;//时间+1； 
				if(xx==fx&&yy==fy){
					cout<<f[tail][4];//到达终点； 
					return;
				}
			}
		}
		if(f[head][0]!=2){//要遍历4个方向要旋转2次；但这样有个问题：这样每个方向都会加入队列2次，但如果不这样就需要一个3维数组来记录每个方向是否来过；这两种方法都可取；所以我选择了代码较简洁的一种； 
			for(int j=1;j<=3;j++){//旋转，当为1的时候向左转，为3的时候向右转； 
				if(j!=2){
					tail++;
					f[tail][1]=f[head][1];//位置不变； 
					f[tail][2]=f[head][2];
					f[tail][3]=(f[head][3]+j)%4;//改变方向； 
					f[tail][4]=f[head][4]+1;//时间+1； 
					f[tail][0]=f[head][0]+1;//标记此元素由旋转得来；当此元素是由旋转过一次的元素得来时，此元素将不再进行旋转；此时f[.][0]==2; 
			}
			}
		}
	}
	cout<<-1;//队列为空了，无法抵达；
}
```


------------
见本题代码思路与其他题解不同，故心血来潮发个题解表达一下自己激动的内心（~~啊哈~~），顺便分享一下思路；

本蒟蒻初学编程，写的不好还请见谅；

---

## 作者：FFF团 (赞：9)

bfs求最短路应用

只不过状态多了个方向，但数据还是比较坑的，还有就是机器人的体积需要考虑

本题主要注意一下几点

1 体积问题

2 起点终点重合

3 起点障碍

4 n,m不要弄混！


```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<map>
using namespace std;
map<char,int>f;        //我比较懒直接用map保存方向编号其实可以直接判断 
int dx[]={0,1,0,-1};//移动数组 
int dy[]={1,0,-1,0};//注意按顺序保存 
int g[55][55];
int cnt,n,m,x0,y0,x1,y1,ans=-1;
struct cur{
    int x,y,fx;                            //用结构体保存状态 
    bool operator < (const cur &b)const{//因为要用map容器需要重载小于号 
        if(x!=b.x)return x<b.x;
        if(y!=b.y)return y<b.y;
        if(fx!=b.fx)return fx<b.fx;
        return 0;
    }
};
cur init;                    //inIt为初始状态 
map<cur,int>vis;            //用map保存状态是否访问过 
bool check(int x,int y){    //利用左上角的坐标检查是否符合题意 
    int tx=x,ty=y;            
    for(int i=0;i<4;i++){    //因为机器人有体积需要考虑四个位置 
        tx+=dx[i],ty+=dy[i];
        if(tx<=0||tx>n||ty<=0||ty>m)return 0;            //越界不符合 
        if(tx>0&&tx<=n&&ty>0&&ty<=m&&g[tx][ty])return 0;//没有越界但是有障碍不符合 
    }
    return 1;//其余情况符合 
}
void bfs(){                                    //bfs部分 
    queue<cur>q;
    q.push(init);
    vis[init]=1;                            //初始状态设为一步最后得到答案需要减一 
    while(!q.empty()){
        cur nw=q.front();q.pop();
        int tx=nw.x,ty=nw.y;
        for(int i=1;i<=3;i++){                //讨论机器人向前走后得到的状态 
            tx+=dx[nw.fx];ty+=dy[nw.fx];    
            cur tt=nw;tt.x=tx,tt.y=ty;
            if(!check(tx,ty))break;            //如果前几步不满足则后续一定不满足跳出循环 
            else if(!vis[tt]){                //若该状态未访问进行访问推入队列 
                    vis[tt]=vis[nw]+1;        //记录步数 
                    if(tt.x==x1&&tt.y==y1){    //若该状态为目标状态 
                        ans=vis[tt]-1;        // 减一得到答案跳出循环 
                        return ;
                    }
                    q.push(tt);
            }
        }
        for(int i=-1;i<=1;i++){                //考虑转向情况 
            if(!i)continue;                    //为0时没有改变 
            cur tt=nw;tt.fx=(tt.fx+i+4)%4;    //加模再取模防止为方向编号为负 
            if(!vis[tt]){
                q.push(tt);                    //未访问进行访问推入队列 
                vis[tt]=vis[nw]+1;            //记录步数 
            }
        }
    }
}
int main(){
    std::ios::sync_with_stdio(false);        //加速cin,cout 
    cin>>n>>m;
    f['E']=0;f['S']=1;f['W']=2;f['N']=3;    //对方向进行标号 
    for(int x=1;x<=n;x++)                    //存图 
    for(int y=1;y<=m;y++)
    cin>>g[x][y];
    char fx;
    cin>>x0>>y0>>x1>>y1>>fx;                //初始化初始状态 
    init.x=x0;init.y=y0;init.fx=f[fx];
    if(x0==x1&&y0==y1)cout<<"0";            //特判是否起点终点重合
    else if(!check(x0,y0))cout<<"-1"; 
    else {
        bfs();                                //否则进行bfs寻找答案 
        cout<<ans;
    }
    return 0;
}
```

---

## 作者：破忆 (赞：6)

## 【题意】

在一个矩阵中，有一些格子不能走，求起点到重点的最短路。有多种行进方式。

- 向前移动1步

- 向前移动2步

- 向前移动3步

- 向左转

- 向右转

## 【分析】

但 $N,M$ 均小于 $50$，整个图仅仅 $2500$ 个格子。

每次枚举格子和走的步数，最多更新 $n^2$ 次，复杂度合理。

![](https://cdn.luogu.com.cn/upload/pic/39.png)

机器人占四个格子（注意不是格点），要求四个格子都不是障碍。

既然机器人占多个格子，那么我们不妨设四个格子分别是 $(i,j),(i,j+1),(i+1,j),(i+1,j+1)$。

既然题目涉及到方向，那么我们就把数组多开一维来存储方向。
从正上方开始，按顺时针旋转，分别是 $0123$。

设当前方向为 $w$，左转后为 $(w+3)\mod3$，右转后为 $(w+1)\mod3$。


## 【代码】
```cpp
#include<bits/stdc++.h>
#define maxn 55
using namespace std;
int n,m,sx,sy,ex,ey,sw;
int p[4][2]={{-1,0},{0,1},{1,0},{0,-1}},dst[maxn][maxn][4],ans,INF;  //p数组存方向，dst存每个格子每个方向的最短路，多开的一维是方向
bool mp[maxn][maxn],vis[maxn][maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0') {if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void work(){
	memset(dst,63,sizeof dst);
	ans=INF=dst[0][0][0];
	dst[sx][sy][sw]=0;
	bool flg=1;
	while(flg){
		flg=0;
		for(int i=1;i<n;i++)
		for(int j=1;j<m;j++)
		for(int k=0;k<4;k++){  //k枚举方向
			if(mp[i][j]||INF==dst[i][j][k]) continue;
			for(int s=1;s<4;s++){ //s枚举移动的距离
				int x=i+s*p[k][0],y=j+s*p[k][1];
				if(mp[x][y]) break;
				if(dst[x][y][k]>dst[i][j][k]+1)dst[x][y][k]=dst[i][j][k]+1,flg=1;
			}
			if(dst[i][j][(k+1)%4]>dst[i][j][k]+1) dst[i][j][(k+1)%4]=dst[i][j][k]+1,flg=1;
			if(dst[i][j][(k+3)%4]>dst[i][j][k]+1) dst[i][j][(k+3)%4]=dst[i][j][k]+1,flg=1;
		}
	}
}
int main(){
// 	freopen("robot.in","r",stdin);
// 	freopen("robot.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++) vis[i][j]=read();
	for(int i=1;i<n;i++)
	for(int j=1;j<m;j++) if(!vis[i][j]&&!vis[i+1][j]&&!vis[i][j+1]&&!vis[i+1][j+1]) mp[i][j]=0;else mp[i][j]=1;
	sx=read(),sy=read(),ex=read(),ey=read();
	if(sx==ex&&sy==ey){
		printf("0\n");
		return 0;
	}
	char ch=getchar();
	while(ch!='E'&&ch!='W'&&ch!='S'&&ch!='N') ch=getchar();
	if(ch=='N') sw=0;else
	if(ch=='E') sw=1;else
	if(ch=='S') sw=2;else
	if(ch=='W') sw=3;

	work();
	for(int i=0;i<4;i++) ans=min(dst[ex][ey][i],ans);
	if(ans==INF) printf("-1\n");else
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：Lynx (赞：5)

这题挺复杂的，主要思路楼下神犇们说得很详细了，不做赘述。只有一点，有些同学（包括我）wa#6，讨论中说要翻一下前进与转向，其实只是巧合。主要问题是在前进一个失败，后续停止更新的判断上。判断要根据是否有障碍，而不能同时判断是否可以更新。
代码略丑，就不贴了。

---

## 作者：Lube (赞：4)

我看大伙都是BFS，而且都是转化成点图存储

然而蒟蒻表示很蒙而且宽搜有点烦

于是就写了一个深搜，而且不用转成点图

直接存原地图即可

上代码

有注释的


```
#include<bits/stdc++.h>
using namespace std;
int n,m,minn=2100000000;
int bx,by,fx,fy;
bool mapp[55][55],vis[55][55],tf[55][55][26];
int ste[55][55][3][3];
int pd(int nx,int ny,int x,int y)//暴力一遍。只要有一个地方碰壁就完蛋 
{
	if(nx==n)return 0;
	if(ny==m)return 0;
	if(nx==x)
	{
		for(int i=min(ny,y);i<=max(ny,y);i++)
		{
	if(mapp[nx][i]==true)return 0;
	if(mapp[nx][i+1]==true)return 0;
	if(mapp[nx+1][i]==true)return 0;
	if(mapp[nx+1][i+1]==true)return 0;			
		}
	}
    else
    {
    	for(int i=min(nx,x);i<=max(nx,x);i++)
    	{
 	if(mapp[i][ny]==true)return 0;
	if(mapp[i][ny+1]==true)return 0;
	if(mapp[i+1][ny]==true)return 0;
	if(mapp[i+1][ny+1]==true)return 0;	   		
    	}
    }
	return 1;
}
void dfs(int x,int y,int step,int dx,int dy)//当前行，当前列，当前步数，走下一步时行应该如何变化， 走下一步时列应该如何变化 
{
	if(x==fx&&y==fy)//找到一种方案了 
	{
		minn=min(minn,step);return;//比较最优 
	}
	if(step>=minn)return;//如果当前步数已经等于最优解了，且显而易见这一步所处位置并不是目标位置。那么下面无论方法再优，总会劣于已知的最优解 
	if(ste[x][y][dx+1][dy+1]==2100000000)ste[x][y][dx+1][dy+1]=step;
	//如果这一个状态（分别是当前行与列，朝向）之前没到过，那么无疑，在已知的所有到达这一状态的方案中，这是最优的 。那么就标记上最优解 
	if(ste[x][y][dx+1][dy+1]!=2100000000)
	{
		if(step<ste[x][y][dx+1][dy+1])ste[x][y][dx+1][dy+1]=step;
		else return ;
	}
	//和上面差不多。如果这个状态曾到达过，那么如果现在这个解更优，就替换掉原来的。反之就踢回去。
	
	//主要的剪枝到此结束 
	for(int i=3;i>=1;i--)
	//其实又是一个小的剪枝。用一个类似贪心的方法，在条件允许的情况下尽可能先尝试快的走法 
	{
		int nx,ny;
		nx=x+dx*i;ny=y+dy*i;//这种走法能够到达的地图坐标 
		if(pd(nx,ny,x,y)&&vis[nx][ny]==false&&nx>0&&ny>0&&nx<=n&&ny<=m)//符合条件 
		{
			vis[nx][ny]=true;
			dfs(nx,ny,step+1,dx,dy);//递归 
			vis[nx][ny]=false;
		}
	}
	if(dx==0)//这个大的IF ELSE语句是处理转向。原理很简单，不做赘述 
	{
		if(tf[x][y]['S'-'A']==false)
		{
			tf[x][y]['S'-'A']=true;
			dfs(x,y,step+1,1,0);
			tf[x][y]['S'-'A']=false;
		}
		if(tf[x][y]['N'-'A']==false)
		{
			tf[x][y]['N'-'A']=true;
			dfs(x,y,step+1,-1,0);
			tf[x][y]['N'-'A']=false;
		}
	}
	else
	{
		if(tf[x][y]['E'-'A']==false)
		{
			tf[x][y]['E'-'A']=true;
			dfs(x,y,step+1,0,1);
			tf[x][y]['E'-'A']=false;
		}
		if(tf[x][y]['W'-'A']==false)
		{
			tf[x][y]['W'-'A']=true;
			dfs(x,y,step+1,0,-1);
			tf[x][y]['W'-'A']=false;
		}
	}
}
int main()
{
	memset(ste,0x3f,sizeof(ste));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&mapp[i][j]);
	scanf("%d%d%d%d",&bx,&by,&fx,&fy);getchar();
	char c;scanf("%c",&c);
	vis[bx][by]=true;tf[bx][by][c]=true;
	if(c=='E')dfs(bx,by,0,0,1);//以下四行是对初始方向的分类讨论，从而进入搜索 
	if(c=='W')dfs(bx,by,0,0,-1);
	if(c=='S')dfs(bx,by,0,1,0);
	if(c=='N')dfs(bx,by,0,-1,0);
	printf("%d",minn==2100000000?-1:minn);//如果MINN一直没有更新，也就是说从来没到过终点，那就输出-1.反之输出最优方案。 
}
```


---

## 作者：wzhhhhh (赞：4)

我翻了6页题解，发现没有一篇是dfs的。给大家补充一篇dfs的题解拓宽一下思路。~~（其实是我懒得写bfs）~~

用了个小优化，用rmb(i,j,ornt)记录到达(i,j)位置ornt方向的最小时间，这样剪枝的话，dfs跑得还是比较快的。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cctype>
#include <algorithm>
using namespace std;

const int maxn = 100;
const int mvr[10] = {0, -1, 0, 1, 0};	//各方向移动距离的数组，r表示行（row）,c表示列（column） 
const int mvc[10] = {0, 0, -1, 0, 1};	//方向1，2，3，4代表上，左，下，右 

int n, m, b[maxn][maxn], a[maxn][maxn], sr, sc, er, ec, sornt;
//sr:start-row，er:end-row，sornt：start-orientation 
int ans = 0x3f3f3f3f;

inline int Right(int x) {
	return x > 1 ? x - 1 : 4;
}

inline int Left(int x) {
	return x < 4 ? x + 1 : 1;
}

int rmb[maxn][maxn][10];	//记忆数组 
void dfs(int cr, int cc, int ornt, int stp) {
	if(stp >= ans || stp >= rmb[cr][cc][ornt]) return;
	if(cr == er && cc == ec) {
		ans = min(ans, stp);
		return;
	}
	rmb[cr][cc][ornt] = stp;
	dfs(cr, cc, Left(ornt), stp + 1);
	dfs(cr, cc, Right(ornt), stp + 1);
	for(int i = 1; i <= 3; i++) {
		int nr = cr + i * mvr[ornt], nc = cc + i * mvc[ornt];
		if(nr >= 1 && nr <= n && nc >= 1 && nc <= m && a[nr][nc]) dfs(nr, nc, ornt, stp + 1);
		else break;	//如果不能走1格，肯定不能走2或3格 
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			scanf("%d", &b[i][j]);	//bij表示第i行第j列的方格的状态 
		}
	}
	n--, m--;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(b[i][j] || b[i][j + 1] || b[i + 1][j] || b[i + 1][j + 1]) a[i][j] = 0;
			else a[i][j] = 1;	//	aij表示第i行第j列的格点的状态，机器人能走的格点必须满足四周都没有墙 
		}
	}
	char tmp;
	scanf("%d %d %d %d %c", &sr, &sc, &er, &ec, &tmp);
	if(tmp == 'N') sornt = 1; 
	if(tmp == 'W') sornt = 2; 
	if(tmp == 'S') sornt = 3; 
	if(tmp == 'E') sornt = 4;
	memset(rmb, 0x3f, sizeof(rmb));
	dfs(sr, sc, sornt, 0);
	if(ans < 0x3f3f3f3f) printf("%d\n", ans);
	else puts("-1");
	return 0;
}
```

不过鉴于对此类最小步数问题，dfs的时间比较玄学（比如我这次别的点最多31ms唯独第9个点520ms），还是建议大家用bfs

---

## 作者：Mystery_Sky (赞：3)

# [机器人搬重物](https://www.luogu.org/problemnew/show/P1126)



~~咕咕咕了几个星期，终于静下心来写完了这篇题解~~

这道题的坑点还是比较多的，下面会一一列举。



### 先审题：

​	根据题目的意思，这是一道走迷宫的问题，显然用bfs去求解。

​	首先，我们需要建一张图。。。

​	这里很多人下意识地将题目中输入的图存下，这就涉及到了此题的第一个坑点了：

### 坑点1：应建立n+1 * m+1 大小的图

​	不理解？不讲道理？

​	这里我们要重新回到题目中，题目的描述为：**机器人的形状是一个直径$1.6米的球**，而机器人走的是**格点**，而障碍物存在于**格子上**，这就意味着每一个有障碍物存在的格子的四个端点都是不能够通行的，而我们操作的是机器人，所以对于一张n*m的**格子图**自然需要建一张（n+1） * （m+1）的**格点图** 。

建图：

```cpp
    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++) {
            scanf("%d", &a);
            if(a == 1) {
                vis[i][j] = vis[i][j+1] = vis[i+1][j] = vis[i+1][j+1] = 1;
                map[i][j] = map[i][j+1] = map[i+1][j] = map[i+1][j+1] = 1;
            }
        }
    n++, m++;
```

这里的vis数组用于后面bfs中判断是否到过，而当该点本身无法到达时，直接置为1。

而这里的map数组只是单纯用于存这个点周围是否有障碍物，具体用处后面会提到。

​	如果你以为这就结束了，那么就大错特错了，还要再加两行:

```cpp
    for(int i = 1; i <= m; i++) vis[1][i] = vis[n][i] = 1;
    for(int i = 1; i <= n; i++) vis[i][1] = vis[i][m] = 1;
```

What? Why?

​	仔细想想，以机器人的体积，它是无法走到第一行（第一列）的格点以及最后一行（最后一列）的格点上去的（旁边是墙！！！）

### 坑点2：四周的边界走不了



### 再审题

​	题中增加了方向的问题，以及机器人每次能走1~3步。

​	对于方向，我们可以考虑在bfs用到的结构体中增加方向的值，即使用dirt来表示该时刻机器人的方向。

结构体

```cpp
struct node{
    int x, y, step, dirt, turn;//dirt取值为1， 2， 3， 4时别表示东，西，南，北。 
    node (int xx, int yy, int ss, int dd, int tt) : x(xx), y(yy), step(ss), dirt(dd), turn(tt){}
};
```



​	接下来就是主要的bfs函数了。

```cpp
inline void bfs(int x1, int y1, int x2, int y2, char to)
{
    int drt;
    if(to == 'E') drt = 1;
    else if(to == 'W') drt = 2;
    else if(to == 'S') drt = 3;
    else drt = 4;
    q.push(node(x1, y1, 0, drt, 0));
    while(!q.empty()) {
        node top = q.front();
        q.pop();
        int dx, dy;
    、、、
 }
```

以上部分与正常的bfs打法无异，只是单纯的多了一个预处理方向的过程，to就是最初的方向。

接着我们考虑用for循环来实现**行走与转向**的问题。

1.正常的行走（i = 1、2、3时）

```cpp
for(int i = 1; i <= 5; i++) {//i=4表示左转， i=5表示右转 
            if(i != 4 && i != 5) {
                drt = top.dirt;
                if(drt == 1) {
                    dx = top.x;
                    dy = top.y + i;
                }	
                else if(drt == 2) {
                    dx = top.x;
                    dy = top.y - i;
                }
                else if(drt == 3) {
                    dx = top.x + i;
                    dy = top.y;
                }
                else {
                    dx = top.x - i;
                    dy = top.y;
                }
                if(dx <= 0 || dy <= 0 || dx > n || dy > m)	{
                    i = 3;//如果走了该步数已经超出了边界,那么该步数以后的步数必然会超过边界，这样直接跳到转向部分即可。
                    continue;
                }
                if(vis[dx][dy]) {
                    continue;
                }
                if(dx == x2 && dy == y2) {
                    dis[x2][y2] = top.step + 1;	//到达终点，存值，返回。
                    return;
                }
                dis[dx][dy] = min(top.step + 1, dis[dx][dy]);
                vis[dx][dy] = 1;
                q.push(node(dx, dy, top.step+1, drt, 0)); 
            }
```

这里引入的dis数组存的是到达某点的最短时间。



2.转向（i = 4、5时）

```cpp
			else if(i == 4){
                dx = top.x, dy = top.y;
                drt = top.dirt;
                if(drt == 1) drt = 4;
                else if(drt == 2) drt = 3;
                else if(drt == 3) drt = 1;
                else drt = 2;
                dis[dx][dy] = min(top.step + 1, dis[dx][dy]);
                vis[dx][dy] = 1;
                q.push(node(dx, dy, top.step + 1, drt, t+1)); 
            }
            else {
                dx = top.x, dy = top.y;
                drt = top.dirt;
                if(drt == 1) drt = 3;
                else if(drt == 2) drt = 4;
                else if(drt == 3) drt = 2;
                else drt = 1;
                dis[dx][dy] = min(top.step + 1, dis[dx][dy]);
                vis[dx][dy] = 1;
                q.push(node(dx, dy, top.step + 1, drt, t+1)); 
            }
        }
```

这里左转右转时的方向要注意，别把自己弄晕了！

然后写好主函数，~~我们就可以愉快地 ac了~~

！诶，WA?为什么？？

输入坐标的时候加上这个试试

```c++
    scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
    getchar();
    x1++, x2++, y1++, y2++;
    scanf("%c", &to);
```

​	这样做的原因看完样例相信聪明的你就明白了。



然后，再提交？怎么又错了几个点啊！！

### 坑点3：终点可能在无法到达的格点上

### 坑点4: 起点和终点可能是同一个点

​	对于上述的两个坑点，只需要两个if特判就可以了

```c++
    if(vis[x1][y1] || vis[x2][y2]) return 0 * printf("-1\n");
    if(x1 == x2 && y1 == y2) return 0 * printf("0\n");
```



这样做了之后好像还是ac不了诶。



​	这里我们回头看看bfs里的for循环，其中有两个问题我们需要解决一下：

​		q1:对于同一个点，for循环中的**i = 4、5**可能会使机器人一直在该点转向。

​		q2:有没有想过这样一个问题，如果机器人在往前走一步的时候遇到了障碍物，那么它前面的两个点vis都为1，但当它往前走三步时，该个点的**vis = 0**，即机器人直接穿过了障碍物到达了障碍物后面的点，这显然是不符合实际的。



​		对于q1，我们就需要用到node结构体里定义的turn作为一个**转向次数计数器**去判断，当机器人在某个点转向3次即以上时，直接跳过。

​		对于q2，我们就需要用到之前定义的map数组去判断了。



考虑完了上述的所有坑点后，这道题终于成功的AC了（~~什么？起始转向次数有设置坑点？不管了，反正我没有遇到~~）



code:

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;
//Mystery_Sky
//
#define INF 0x3f3f3f3f
const int M = 100;
struct node{
    int x, y, step, dirt, turn;//dirt取值为1， 2， 3， 4时别表示东，西，南，北。 
    node (int xx, int yy, int ss, int dd, int tt) : x(xx), y(yy), step(ss), dirt(dd), turn(tt){}
};
queue <node> q;
int n, m, ans, x1, x2, y1, y2;
char to;
int dis[M][M], map[M][M];
bool vis[M][M];
inline void bfs(int x1, int y1, int x2, int y2, char to)
{
    int drt;
    if(to == 'E') drt = 1;
    else if(to == 'W') drt = 2;
    else if(to == 'S') drt = 3;
    else drt = 4;
    q.push(node(x1, y1, 0, drt, 0));
    while(!q.empty()) {
        node top = q.front();
        q.pop();
        int dx, dy;
        for(int i = 1; i <= 5; i++) {//i=4表示左转， i=5表示右转 
            if(i != 4 && i != 5) {
                drt = top.dirt;
                if(drt == 1) {
                    dx = top.x;
                    dy = top.y + i;
                }	
                else if(drt == 2) {
                    dx = top.x;
                    dy = top.y - i;
                }
                else if(drt == 3) {
                    dx = top.x + i;
                    dy = top.y;
                }
                else {
                    dx = top.x - i;
                    dy = top.y;
                }
                if(map[dx][dy] == 1) i = 3;
                if(dx <= 0 || dy <= 0 || dx > n || dy > m)	{
                    i = 3;
                    continue;
                }
                if(vis[dx][dy]) {
                    continue;
                }
                if(dx == x2 && dy == y2) {
                    dis[x2][y2] = top.step + 1;	
                    return;
                }
                dis[dx][dy] = min(top.step + 1, dis[dx][dy]);
                vis[dx][dy] = 1;
                q.push(node(dx, dy, top.step+1, drt, 0)); 
            }
            else if(i == 4){
                int t = top.turn;
                if(t > 2) continue;
                dx = top.x, dy = top.y;
                drt = top.dirt;
                if(drt == 1) drt = 4;
                else if(drt == 2) drt = 3;
                else if(drt == 3) drt = 1;
                else drt = 2;
                dis[dx][dy] = min(top.step + 1, dis[dx][dy]);
                vis[dx][dy] = 1;
                q.push(node(dx, dy, top.step + 1, drt, t+1)); 
            }
            else {
                int t = top.turn;
                if(t > 2) continue;
                dx = top.x, dy = top.y;
                drt = top.dirt;
                if(drt == 1) drt = 3;
                else if(drt == 2) drt = 4;
                else if(drt == 3) drt = 2;
                else drt = 1;
                dis[dx][dy] = min(top.step + 1, dis[dx][dy]);
                vis[dx][dy] = 1;
                q.push(node(dx, dy, top.step + 1, drt, t+1)); 
            }
        }
    }
    return;
}

int main() {
    int a;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++) {
            scanf("%d", &a);
            if(a == 1) {
                vis[i][j] = vis[i][j+1] = vis[i+1][j] = vis[i+1][j+1] = 1;
                map[i][j] = map[i][j+1] = map[i+1][j] = map[i+1][j+1] = 1;
            }
        }
    n++, m++;
    for(int i = 1; i <= m; i++) vis[1][i] = vis[n][i] = 1;
    for(int i = 1; i <= n; i++) vis[i][1] = vis[i][m] = 1;
    scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
    getchar();
    x1++, x2++, y1++, y2++;
    scanf("%c", &to);
    memset(dis, INF, sizeof(dis));
    if(vis[x1][y1] || vis[x2][y2]) return 0 * printf("-1\n");
    if(x1 == x2 && y1 == y2) return 0 * printf("0\n");
    bfs(x1, y1, x2, y2, to);
    if(dis[x2][y2] == INF) printf("-1\n");
    else printf("%d\n", dis[x2][y2]);
    return 0;
}

```









---

## 作者：袁宇轩 (赞：2)

前往[题目](https://www.luogu.com.cn/problem/P1126)
  
读完题目后，得知题目要求我们求出**最少时间**，这时我们想到要求最少时间往往使用**BFS**(如果是方案数或能否到达往往选择DFS)

但这题要注意的细节还是蛮多的：

1.题目给出的图是**方格图**，也就是说障碍是一个面，而不仅仅只是一个点，但机器人行走的路线是由**点**构成（所以只用一个点f[i][j]表示障碍是不可取的）；那么解决的好方法就是**把一个障碍看成四个点**，将这四个点一起标记掉；

2.机器人存在一定的**体积**，这一点我们可以从样例看出（样例中给出的机器人是一个⚪），所以在图的**边界也是无法走的**；解决方法就是把**判断边界时把n和m都-1**；

3.此题在单位时间内可以行走，也可以转向，行走想必不用多说，但转向会有点麻烦；

- 如何解决**原地打转**的问题（如果不处理，队列中会有源源不断的转向命令出现，陷入死循环）：在这里我用了一个三维数组进行标记——f[i][j][k],表示（i,j）这位置此时方向为k是否走过，若是1则表示走过，即无需再走，反之则继续；
- 如何**存储方向**：这个问题解决比较容易，但如果处理恰当会为之后的代码方便许多，我在此是把{E,S,W,N}分别表示成{0,1,2,3};
- 如何将方向转变成我们在图上行走时的方向，我们可以根据样例，对{E,S,W,N},分别进行模拟，由此得出结论：

| 方向 | i | j |
| :----------: | :----------: | :----------: |
| E | 0 | 1 |
| S | 1 | 0 |
| W | 0 | -1 |
| N | -1 | 0 |
   这时我们再定义两个方向数组fx[4]={0,1,0,-1};fy[4]={1,0,-1,0};
   
   我们会发现刚才的存储方向的做法对现在有很大的好处。

4.当我们行走时还有一点值得注意（这个让我查错了好久）：当你一次运动2个或3个单位时，应注意你这一次行走的**路径**上是否都没被标记过（即都不是障碍），而不是只判断最后一个点时候是障碍，否则会出现**穿墙行为**。
   
   废话不多说直接看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=50+10;
int fx[4]={0,1,0,-1};
int fy[4]={1,0,-1,0};
int n,m,st_x,st_y,ed_x,ed_y,a[N][N],vis[N][N][5];
struct node{
	int x,y,dir,step;//x,y表示坐标，dir表示方向，step表示当前步数
};
int bfs(int x,int y,char c){
	queue<node> q;
	if (c=='E') q.push(node{x,y,0,0}),vis[x][y][0]=1;
	if (c=='S') q.push(node{x,y,1,0}),vis[x][y][1]=1;
	if (c=='W') q.push(node{x,y,2,0}),vis[x][y][2]=1;
	if (c=='N') q.push(node{x,y,3,0}),vis[x][y][3]=1;
	while (!q.empty()){
		int dx=q.front().x; int dy=q.front().y;
		int Dir=q.front().dir; int Step=q.front().step;
		q.pop();
		if (dx==ed_x && dy==ed_y) return Step;//到达终点
		if (!vis[dx][dy][(Dir+5)%4] && !a[dx][dy]) q.push(node{dx,dy,(Dir+5)%4,Step+1}),vis[dx][dy][(Dir+5)%4]=1;//左转
	        if (!vis[dx][dy][(Dir+3)%4] && !a[dx][dy]) q.push(node{dx,dy,(Dir+3)%4,Step+1}),vis[dx][dy][(Dir+3)%4]=1;//右转
	        if (!vis[dx+fx[Dir]][dy+fy[Dir]][Dir] && !a[dx+fx[Dir]][dy+fy[Dir]] && dx+fx[Dir]>0 && dx+fx[Dir]<n && dy+fy[Dir]>0 && dy+fy[Dir]<m) q.push(node{dx+fx[Dir],dy+fy[Dir],Dir,Step+1}),vis[dx+fx[Dir]][dy+fy[Dir]][Dir]=1;//行走一步
	        if (!vis[dx+2*fx[Dir]][dy+2*fy[Dir]][Dir] && !a[dx+fx[Dir]][dy+fy[Dir]] && !a[dx+2*fx[Dir]][dy+2*fy[Dir]] && dx+2*fx[Dir]>0 && dx+2*fx[Dir]<n && dy+2*fy[Dir]>0 && dy+2*fy[Dir]<m) q.push(node{dx+2*fx[Dir],dy+2*fy[Dir],Dir,Step+1}),vis[dx+2*fx[Dir]][dy+2*fy[Dir]][Dir]=1;//行走两步
	        if (!vis[dx+3*fx[Dir]][dy+3*fy[Dir]][Dir] && !a[dx+fx[Dir]][dy+fy[Dir]] && !a[dx+2*fx[Dir]][dy+2*fy[Dir]] && !a[dx+3*fx[Dir]][dy+3*fy[Dir]] && dx+3*fx[Dir]>0 && dx+3*fx[Dir]<n && dy+3*fy[Dir]>0 && dy+3*fy[Dir]<m) q.push(node{dx+3*fx[Dir],dy+3*fy[Dir],Dir,Step+1}),vis[dx+3*fx[Dir]][dy+3*fy[Dir]][Dir]=1;//行走三步
	}
	return -1;
}
int main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++){
		a[i][0]=a[0][i]=a[i][m]=a[n][i]=1;//标记边界
	        for (int j=1,x;j<=m;j++){
	  	    cin>>x;
	  	    if (x==1) a[i-1][j-1]=a[i-1][j]=a[i][j-1]=a[i][j]=1;//标记障碍四周的四个点
	        }
	}
	char c;
	cin>>st_x>>st_y>>ed_x>>ed_y>>c;
	cout<<bfs(st_x,st_y,c)<<endl;
	return 0;
}
```


---

## 作者：与我常在 (赞：2)

本蒟蒻辛辛苦苦调了两个小时，最后发现统计时间时将dis[to.x][to.y]写成了dis[to.x][to.x]，心累~~~

由于是最短时间，所以我们可以使用bfs，以下代码略长，但自我感觉还是比较清晰的吧~~或许吧~~，注释在文中

```cpp
#include <queue>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 60;


int n, m;
int mp[N][N];
int vis[N][N][4], dis[N][N][4];//vis判重，dis记录时间
//最后一维表示在该点的朝向

struct node {
	int x;
	int y;
	char dir;
}be, en;

queue <node> q;

bool check(node t) {
	if(t.x < 1 || t.x >= n || t.y < 1 || t.y >= m) return false;//边界自己带值体会一下
	return true;
}

void bfs() {
	q.push(be);
	
	while(!q.empty()) {
		node now = q.front();  q.pop();
		/*printf("%d %d %c ", now.x, now.y, now.dir);
		if(now.dir == 'W') printf("%d %d\n", 0, dis[now.x][now.y][0]);
		else if(now.dir == 'S') printf("%d %d\n", 1, dis[now.x][now.y][1]);
		else if(now.dir == 'E') printf("%d %d\n", 2, dis[now.x][now.y][2]);
		else if(now.dir == 'N') printf("%d %d\n", 3, dis[now.x][now.y][3]);*/
        //调试的
		
		for(int i = 1; i <= 3; i ++) {// 枚举向一个方向走的距离
			if(now.dir == 'W') {//向左走
				int flag = 1;
				node to = now;
				to.y -= i;
				if(!check(to)) continue;
				if(vis[to.x][to.y][0]) continue;
				for(int j = 1; j <= i; j ++) {//由于要走i步，所以走i步的路径上不能有障碍，下同
					if(mp[to.x][now.y - j] || mp[to.x + 1][now.y - j]) flag = 0;//模拟一下就可以得出的规律
                    //可以先试走一步，然后类推
					if(!flag) break;//有一个障碍都不行
				}
				if(!flag) continue;
				vis[to.x][to.y][0] = 1;
				dis[to.x][to.y][0] = dis[now.x][now.y][0] + 1;
				q.push(to);
				
				if(to.x == en.x && to.y == en.y) {
					printf("%d\n", dis[to.x][to.y][0]);
					return;
				}
			}
			
			else if(now.dir == 'S') {//向下走
				int flag = 1;
				node to = now;
				to.x += i;
				if(!check(to)) continue;
				if(vis[to.x][to.y][1]) continue;
				for(int j = 1; j <= i; j ++) {
					if(mp[now.x + j + 1][to.y] || mp[now.x + j + 1][to.y + 1]) flag = 0;
					if(!flag) break;
				}
				if(!flag) continue;
				vis[to.x][to.y][1] = 1;
				dis[to.x][to.y][1] = dis[now.x][now.y][1] + 1;
				q.push(to);
				
				if(to.x == en.x && to.y == en.y) {
					printf("%d\n", dis[to.x][to.y][1]);
					return;
				}
			}
			
			else if(now.dir == 'E') {//向右走
				int flag = 1;
				node to = now;
				to.y += i;
				if(!check(to)) continue;
				if(vis[to.x][to.y][2]) continue;
				for(int j = 1; j <= i; j ++) {
					if(mp[to.x][now.y + j + 1] || mp[to.x + 1][now.y + j + 1]) flag = 0;
					if(!flag) break;
				}
				if(!flag) continue;
				vis[to.x][to.y][2] = 1;
				dis[to.x][to.y][2] = dis[now.x][now.y][2] + 1;
				q.push(to);
				
				if(to.x == en.x && to.y == en.y) {
					printf("%d\n", dis[to.x][to.y][2]);
					return;
				}
			}
			
			else if(now.dir == 'N') {//向上走
				int flag = 1;
				node to = now;
				to.x -= i;
				if(!check(to)) continue;
				if(vis[to.x][to.y][3]) continue;
				for(int j = 1; j <= i; j ++) {
					if(mp[now.x - j][to.y] || mp[now.x - j][to.y + 1]) flag = 0;
					if(!flag) break;
				}
				if(!flag) continue;
				vis[to.x][to.y][3] = 1;
				dis[to.x][to.y][3] = dis[now.x][now.y][3] + 1;
				q.push(to);
				
				if(to.x == en.x && to.y == en.y) {
					printf("%d\n", dis[to.x][to.y][3]);
					return;
				}
			}
			
		}
		
		for(int i = 1; i <= 2; i ++) {//枚举转弯
			if(i == 1) {//向左转
				node to;
				to = now;
				
				if(to.dir == 'W') {
					to.dir = 'S';
					if(vis[to.x][to.y][1]) continue;
					vis[to.x][to.y][1] = 1;
					dis[to.x][to.y][1] = dis[now.x][now.y][0] + 1;
					q.push(to);
				}
				
				else if(to.dir == 'S') {
					to.dir = 'E';
					if(vis[to.x][to.y][2]) continue;
					vis[to.x][to.y][2] = 1;
					dis[to.x][to.y][2] = dis[now.x][now.y][1] + 1;
					q.push(to);
				}
				
				else if(to.dir == 'E') {
					to.dir = 'N';
					if(vis[to.x][to.y][3]) continue;
					vis[to.x][to.y][3] = 1;
					dis[to.x][to.y][3] = dis[now.x][now.y][2] + 1;
					q.push(to);
				}
				
				else if(to.dir == 'N') {
					to.dir = 'W';
					if(vis[to.x][to.y][0]) continue;
					vis[to.x][to.y][0] = 1;
					dis[to.x][to.y][0] = dis[now.x][now.y][3] + 1;
					q.push(to);
				}
				
			}
			
			else { //向右转
				node to;
				to = now;
				
				if(to.dir == 'W') {
					to.dir = 'N';
					if(vis[to.x][to.y][3]) continue;
					vis[to.x][to.y][3] = 1;
					dis[to.x][to.y][3] = dis[now.x][now.y][0] + 1;
					q.push(to);
				}
				
				else if(to.dir == 'S') {
					to.dir = 'W';
					if(vis[to.x][to.y][0]) continue;
					vis[to.x][to.y][0] = 1;
					dis[to.x][to.y][0] = dis[now.x][now.y][1] + 1;
					q.push(to);
				}
				
				else if(to.dir == 'E') {
					to.dir = 'S';
					if(vis[to.x][to.y][1]) continue;
					vis[to.x][to.y][1] = 1;
					dis[to.x][to.y][1] = dis[now.x][now.y][2] + 1;
					q.push(to);
				}
				
				else if(to.dir == 'N') {
					to.dir = 'E';
					if(vis[to.x][to.y][2]) continue;
					vis[to.x][to.y][2] = 1;
					dis[to.x][to.y][2] = dis[now.x][now.y][3] + 1;
					q.push(to);
				}
			}
			
		}
		
	}
	
	puts("-1"); //如果一直没找到就代表没有到终点的路径
}

int main() {
	scanf("%d %d", &n, &m);
	
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= m; j ++)
			scanf("%d", &mp[i][j]); 
	
	for(int i = 1; i <= 4; i ++)
		scanf("%d %d %d %d", &be.x, &be.y, &en.x, &en.y);
	be.dir = getchar();
	
	if(be.x == en.x && be.y == en.y) {puts("0"); return 0;} //起点与终点重复，不用消耗时间
	if(mp[be.x][en.x] || mp[be.x + 1][be.y] || mp[be.x][be.y + 1] || mp[be.x + 1][be.y + 1]) {puts("-1"); return 0;} //机器人的初始位置就覆盖有障碍，这种情况是非法的
	
	bfs();
	
	return 0;
}
```


---

## 作者：yubing_lml (赞：2)

NO.8 调试了N遍，终于过了！！！其实这道题不是很难，就是细节很多，导致我在一些小地方改了又改。。。

## 大致思路：

给定一个源点和一个目标点，机器人站在源点，求一条费时最少的路径使机器人能够到达目标点。使用**广搜+剪枝**，机器人所在的点由三个元素构成——横坐标x，纵坐标y，方向dir。对机器人到达的每一个点进行判断，若该点即为目标点，则返回当前时间，否则扩展当前坐标点，规定机器人在每个点最多只有5中扩展方式：向前走1步，2步，3步，向左转，向右转。这里有一个问题，向前，左，右都是针对机器人当前的方向而言的，所以在实现的时候要根据方向分别判断机器人可以到达哪些点。当然，不论选择哪个方向，向前操作也只会对横坐标或纵坐标之一进行加或减的操作。同理，turn left和turn right也要区别对待。

**注意**：每到达一个格点，就要对该格点进行标记，避免重复计算。

## 总结一下踩过的坑：
#### 格点概念：两条互相垂直直线的交点。

1、给定一个障碍点，那么这个障碍点的四个顶点所在的格点都应该设为1，即不可达。

2、储藏室的四个边上的格点是不可达的。

3、如果判定当前朝某个方向走i步到达的格点是不可达的，那么走i+1，i+2···一定不可达（因为中间有个阻碍格点*，而走的又是直线，必经该障碍格点：，就像这样：- - - - * - - - -，假设机器人当前方向是east, * 是个障碍格点，那么* 之后的任何一个格点均无法到达）。

## 具体实现：

队列Q保存访问到但仍没有被扩展的点。

结构体pos保存每个格点的状态，包括坐标，方向和到达时间。

int类型二维数组a保存格点是否可达（输入后记得更新格点四周可达性）

bool类型三维数组mark标记当前格点是否被访问过。（一开始只用了二维数组保存格点横纵坐标，后来发现方向也是一个格点的主键）

**关于左右旋转**：char turn(pos now, char dir)函数用来计算向左转和向右转后得到的方向。旋转只改变格点的方向，不改变坐标值。对应bfs函数中的如下代码：

旋转也要费时间！

```cpp
//以turn left为例。'l'是小写的L，不是数字1
tmp = now;
tmp.dir = turn(now.dir, 'l');
tmp.time = now.time + 1;
if (mark[tmp.x][tmp.y][tmp.dir-'A'] == false)
{
	mark[tmp.x][tmp.y][tmp.dir-'A'] = true;
	Q.push(tmp);
}
```

bool illegal(int x,int y)函数判断当前格点是否犯规，为true表示确实illegal，再向前走已经没有意义了。

```cpp
bool illegal(int x, int y)
{
	if (x <= 0 || x >= n || y <= 0 || y >= m || a[x][y] == 1)
		return true;
	return false;
}
```
由于不能走边界，所以这里要加上=0||=n||=m；

**关于向前移动**：由于四个方向的代码大同小异，这里以dir='S'为例进行讲解。

朝南走改变的只是横坐标，依次加1，加2，加3。这里的mark[nx][ny][now.dir-'A']第三个参数只是为了减少存储空间，直接写now.dir也ok的~由于向前走不改变方向，这里的now.dir和tmp.dir相等。如果没有访问过该点直接入队就好啦！

```cpp
if (now.dir == 'S')
	for (int i = 1; i <= 3; i++)
	{
		nx = now.x + i;
		ny = now.y;
		if (illegal(nx, ny))
			break;
		if (mark[nx][ny][now.dir-'A'] == true)
			continue;
		tmp = now;
		tmp.x = nx;
		tmp.time = now.time + 1;
		mark[nx][ny][tmp.dir-'A'] = true;
		Q.push(tmp);
	}
```


------------
AC代码如下：
------------


```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;

char dir; //direction
int n, m;
int a[53][53];
bool mark[53][53][24];//mark标记该点的值是否遍历过

struct pos
{
	int x, y;
	char dir;
	int time;
};
queue<pos>Q;

char turn(char now, char dir) //from now to a new direction
{
	if (dir == 'l')
		switch (now)
		{
		case 'N':return 'W';
		case 'S':return 'E';
		case 'W':return 'S';
		case 'E':return 'N';
		}
	else if (dir == 'r')
		switch (now)
		{
		case 'N':return 'E';
		case 'S':return 'W';
		case 'W':return 'N';
		case 'E':return 'S';
		}
}

bool illegal(int x, int y)
{
	if (x <= 0 || x >= n || y <= 0 || y >= m || a[x][y] == 1)
		return true;
	return false;
}

int bfs(int desx, int desy)
{
	pos now;
	while (!Q.empty())
	{
		now = Q.front();
		Q.pop();
		if (now.x == desx && now.y == desy)
			return now.time;
		pos tmp;
		int nx, ny;
		if (now.dir == 'S')
			for (int i = 1; i <= 3; i++)
			{
				nx = now.x + i;
				ny = now.y;
				if (illegal(nx, ny))
					break;
				if (mark[nx][ny][now.dir-'A'] == true)
					continue;
				tmp = now;
				tmp.x = nx;
				tmp.time = now.time + 1;
				mark[nx][ny][tmp.dir-'A'] = true;
				Q.push(tmp);
			}
		else if (now.dir == 'N')
			for (int i = 1; i <= 3; i++)
			{
				nx = now.x - i;
				ny = now.y;
				if (illegal(nx, ny))
					break;
				if (mark[nx][ny][now.dir - 'A'] == true)
					continue;
				tmp = now;
				tmp.x = nx;
				tmp.time = now.time + 1;
				mark[nx][ny][tmp.dir-'A'] = true;
				Q.push(tmp);
			}
		else if (now.dir == 'W')
			for (int i = 1; i <= 3; i++)
			{
				nx = now.x;
				ny = now.y - i;
				if (illegal(nx, ny))
					break;
				if (mark[nx][ny][now.dir - 'A'] == true)
					continue;
				tmp = now;
				tmp.y = ny;
				tmp.time = now.time + 1;
				mark[nx][ny][tmp.dir-'A'] = true;
				Q.push(tmp);
			}
		else if (now.dir == 'E')
			for (int i = 1; i <= 3; i++)
			{
				nx = now.x;
				ny = now.y + i;
				if (illegal(nx, ny))
					break;
				if (mark[nx][ny][now.dir - 'A'] == true)
					continue;
				tmp = now;
				tmp.y = ny;
				tmp.time = now.time + 1;
				mark[nx][ny][tmp.dir-'A'] = true;
				Q.push(tmp);
			}
		//turn left
		tmp = now;
		tmp.dir = turn(now.dir, 'l');
		tmp.time = now.time + 1;
		if (mark[tmp.x][tmp.y][tmp.dir-'A'] == false)
		{
			mark[tmp.x][tmp.y][tmp.dir-'A'] = true;
			Q.push(tmp);
		}
		//turn right
		tmp.dir = turn(now.dir, 'r');
		if (mark[tmp.x][tmp.y][tmp.dir-'A'] == false)
		{
			mark[tmp.x][tmp.y][tmp.dir-'A'] = true;
			Q.push(tmp);
		}
	}//while
	return -1;
}

int main()
{
	cin >> n >> m;
	int mm[53][53];
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			cin >> a[i][j], mm[i][j] = a[i][j];
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			if (mm[i][j] == 1)
				a[i][j + 1] = 1, a[i + 1][j] = 1, a[i + 1][j + 1] = 1;
	pos start, des;
	cin >> start.x >> start.y >> des.x >> des.y >> start.dir;
	start.time = 0;
	memset(mark, false, sizeof(mark));
	mark[start.x][start.y][start.dir-'A'] = true;
	Q.push(start);
	cout << bfs(des.x, des.y) << endl;
	cin >> n;
	return 0;
}
```
### *码字容易，思考不易，且行且珍惜~*

---

## 作者：gameplayer47 (赞：2)

首先这是一道很考细节~~坑~~的题
注意事项：如图
1.机器人是一个“ _球_ ”，所以对于机器人坐标（i，j），他所在的方格和（i+1,j）,(i,j+1),(i+1,j+1)都不能在数字为1的地方

2.当你前进2格或者3格时所经过的地方也不能为数字1所在的地方！！！（被这里坑几个小时）

3.转向也需要时间！！！

```
本人很倔强~~很菜~~，所以本题用dfs完成！
适合新手朋友学习深入了解这类题的简单解法
```

写在前面：
```
我们先默认memset整个地图为-1（即不可走），再输入，对于可以走的点将它定义为一个比较大的值（本题定义为9999，
已经足够），mp【i】【j】后续即为到达此点的最快步数，
通过数组g来控制机器人的移动g【c】【i】【j】中c为此时机
器人的朝向-i中分别为对应的可以走的步数，而j控制是横坐标加还是纵坐标加，数组move来控制机器人转向
接下来上代码：（注释打在代码后面）135行不多，慢慢看...
```
 ```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,mp[60][60],c,sx,sy,fx,fy,move[7]={0,1,2,3,-1,-2,-3},inf=9999;
int g[5][3][2]={{0},{{-1,0},{-2,0},{-3,0}},{{0,-1},{0,-2},{0,-3}},{{1,0},{2,0},{3,0}},{{0,1},{0,2},{0,3}}};
int check(int t,int nt){//判断转向用时
	if(t==nt) return 0;
	if(t==1){
		if(nt==2 || nt==4) return 1;
		else return 2;
	}
	if(t==2){
		if(nt==1 || nt==3) return 1;
		else return 2;
	}
	if(t==3){
		if(nt==2 ||nt==4) return 1;
		else return 2;
	}
	if(t==4){
		if(nt==1 ||nt==3) return 1;
		else return 2;
	}
}
int check2(int x,int y,int gx,int gy){//判断所经过的地方是否违规
	if(gx==3){
		for(int i=x;i<=x+4;i++){
			for(int j=y;j<=y+1;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gx==2){
		for(int i=x;i<=x+3;i++){
			for(int j=y;j<=y+1;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gx==1){
		for(int i=x;i<=x+2;i++){
			for(int j=y;j<=y+1;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gy==3){
		for(int i=x;i<=x+1;i++){
			for(int j=y;j<=y+4;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gy==2){
		for(int i=x;i<=x+1;i++){
			for(int j=y;j<=y+3;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gy==1){
		for(int i=x;i<=x+1;i++){
			for(int j=y;j<=y+2;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	if(gx==-3){
		for(int i=x;i>=x-3;i--){
			for(int j=y;j<=y+1;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gx==-2){
		for(int i=x;i>=x-2;i--){
			for(int j=y;j<=y+1;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gx==-1){
		for(int i=x;i>=x-1;i--){
			for(int j=y;j<=y+1;j++) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gy==-3){
		for(int i=x;i<=x+1;i++){
			for(int j=y;j>=y-3;j--) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gy==-2){
		for(int i=x;i<=x+1;i++){
			for(int j=y;j>=y-2;j--) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
	else if(gy==-1){
		for(int i=x;i<=x+1;i++){
			for(int j=y;j>=y-1;j--) if(mp[i][j]==-1) return 0;
		}
		return 1;
	}
}
void dfs(int x,int y,int step,int t){//当前坐标（x，y），已经走的步数，方向 
	mp[x][y]=min(mp[x][y],step);
	if(x==fx && y==fy) return ;
	else if(step>1000) return ;//设置dfs上限根据题目所给数据推算，避免TLE
	int js,k;
	for(int p=0;p<7;p++){//结合move数组控制转向
		js=step;
		int nt=t+move[p];
		if(nt>4 || nt<1) continue;
		k=js+=check(t,nt);
		for(int j=0;j<3;j++){//开始走
			int nx=x+g[nt][j][0],ny=y+g[nt][j][1];
			if(check2(x,y,g[nt][j][0],g[nt][j][1])&&mp[nx][ny]>step+1) //判断
			dfs(nx,ny,js+1,nt);//递归dfs
		}
	}
}
int main(){
	memset(mp,-1,sizeof(mp));//初始化
	int a;
	cin>>n>>m;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		scanf("%d",&a);
		if(a!=1) mp[i][j]=inf;
	}
	scanf("%d %d %d %d %c",&sx,&sy,&fx,&fy,&c);
	if(c=='N') a=1;
	else if(c=='W') a=2;
	else if(c=='S') a=3;
	else if(c=='E') a=4;
	dfs(sx,sy,0,a);
	if(mp[fx][fy]==inf){ printf("-1"); return 0;	}
	printf("%d",mp[fx][fy]);
	return 0;
}
```


---

## 作者：Limit (赞：2)

这是一道bfs的基础题，只是将接下来要干什么分类一下就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int zx[5]={0,+0,+1,-0,-1};//常量数组，代表方向
int zy[5]={0,+1,-0,-1,+0};
int i,j,k,m,n,h,t,fx,fy,lx,ly,ii,jj;
bool a[100][100][5],b[100][100];
int c[100][100];
int x[20000],y[20000],fang[20000],u[20000];//广搜时的队列
char ch;
int left(int x)//左转
{x--;if(x==0)x=4;return x;}
int right(int x)//右转
{x++;if(x==5)x=1;return x;}
int main()
{
  cin>>m>>n;
  for(i=1;i<=m;i++)
  for(j=1;j<=n;j++)
  {cin>>k;b[i][j]=(k+1)%2;}
  cin>>fx>>fy>>lx>>ly>>ch;
  for(i=1;i<=m;i++)
  {
  for(j=1;j<=n;j++)
  {
    if(b[i+1][j+1]&&b[i+1][j]&&b[i][j+1]&&b[i][j])
    {
      for(k=1;k<=4;k++)
      a[i][j][k]=true;
    }
    c[i][j]=1000000;
  }
  }
  if(ch=='E')fang[1]=1;
  if(ch=='S')fang[1]=2;
  if(ch=='W')fang[1]=3;
  if(ch=='N')fang[1]=4;
  a[fx][fy][fang[1]]=false;
  h=1;
  t=1;
  u[1]=0;
  x[1]=fx;
  y[1]=fy;
  while(t<=h)
  {
    if(x[t]==lx&&y[t]==ly)//找到答案
    {
      cout<<u[t];
      return 0;
    }
    for(i=1;i<=5;i++)//分5种讨论
    {
      if(i==1)
      {
        if(a[x[t]][y[t]][left(fang[t])]==true)//判断状态是否可以
        {
        h++;
        x[h]=x[t];
        y[h]=y[t];
        u[h]=u[t]+1;
        fang[h]=left(fang[t]);//左转
        a[x[h]][y[h]][fang[h]]=false;
        }
      }
      if(i==2)
      {
      	if(a[x[t]][y[t]][right(fang[t])]==true)//判断状态是否可以
      	{
        h++;
        x[h]=x[t];
        y[h]=y[t];
        u[h]=u[t]+1;
        fang[h]=right(fang[t]);//右转
        a[x[h]][y[h]][fang[h]]=false;
        }
      }
      if(i==3)
      {
        if(a[x[t]+zx[fang[t]]*3][y[t]+zy[fang[t]]*3][fang[t]]==true
         &&a[x[t]+zx[fang[t]]*2][y[t]+zy[fang[t]]*2][fang[t]]==true
         &&a[x[t]+zx[fang[t]]][y[t]+zy[fang[t]]][fang[t]]==true)//判断状态是否可以
        {
          h++;
          x[h]=x[t]+zx[fang[t]]*3;
          y[h]=y[t]+zy[fang[t]]*3;
          u[h]=u[t]+1;
          fang[h]=fang[t];
          a[x[h]][y[h]][fang[h]]=false;
        }
      }
      if(i==4)
      {
        if(a[x[t]+zx[fang[t]]*2][y[t]+zy[fang[t]]*2][fang[t]]==true
         &&a[x[t]+zx[fang[t]]][y[t]+zy[fang[t]]][fang[t]]==true)//判断状态是否可以
        {
          h++;
          x[h]=x[t]+zx[fang[t]]*2;
          y[h]=y[t]+zy[fang[t]]*2;
          u[h]=u[t]+1;
          fang[h]=fang[t];
          a[x[h]][y[h]][fang[h]]=false;
        }
      }
      if(i==5)
      {
        if(a[x[t]+zx[fang[t]]][y[t]+zy[fang[t]]][fang[t]]==true)//判断状态是否可以
        {
          h++;
          x[h]=x[t]+zx[fang[t]];
          y[h]=y[t]+zy[fang[t]];
          u[h]=u[t]+1;
          fang[h]=fang[t];
          a[x[h]][y[h]][fang[h]]=false;
        }
      }
    }
    t++;
  }
  cout<<-1;//无解
  return 0;
}
```
就是代码长点，有耐心就行了...


---

## 作者：约修亚_RK (赞：2)

这题的数据范围并不大，直接BFS下去并不会爆炸。

题目提供了直观的图片，我们可以看到机器人占据了4格。

输入数据中提供的是交叉点的坐标，样例数据的话坐标范围是(0,0)到(9,10)。

而方格的范围则是(0,0)到(8,9)。我们可以假设机器人处在位置为(sx, sy)的方格上，当它行进时判断前进方向上的两个格子是否有障碍。

那么**首先判断机器人所处的四个格子即(sx-1,sy-1)到(sx,sy)四个方格有没有障碍**（注意不要出界）。（这是第十组数据的key）

之后我们就可以把 【(sx, sy, 方向), 步数】丢到队列里面去了。

接下来每次取出一个状态。

如果这个状态到达了目标点，就直接输出，并且退出程序。我们可以保证没有比这更小的情况（步数更少状态都在之前被访问过了）。

接着查询这个状态是否已经访问过（利用set实现 - 实际上可以把状态hash一下，不过这里空间足够）。如果访问过了就把它扔掉（之所以这是可行的，是因为这是BFS。同样的状态先访问到时总是不劣于后访问到时的。），如果没访问过就标记为已访问，接着作五种尝试：

0. 向左转

1. 向右转

2. 前进一格

3. 前进两格(仅当上一个尝试成功)

4. 前进三格(仅当上一个尝试成功)

如果"可以这么做"，就把【修改后的状态, 步数+1】丢到队列里面去。

若队列为空，且程序尚未退出，说明目标状态无法到达。

下图是样例数据储存的情况。


<http://sforest.in/files/P1126-map.png>

我的代码比较繁琐，因为没有把四个方向抽象成坐标的变化量，将就着看吧orz


[codec]

/\* P1126

\* Au: SJoshua

\*/





```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
#include <set> 
using namespace std;
struct status {
    int x, y;
    char d; 
    bool operator < (const status &p) const {
        return x == p.x ? (y == p.y ? d > p.d : y > p.y) : (x > p.x);
    }
} temp;
char right(char d) {
    switch (d) {
        case 'N':
            return 'E'; 
        case 'W':
            return 'N';
        case 'E':
            return 'S';
        case 'S': 
            return 'W';
    } 
    return 0;
}
char left(char d) {
    switch (d) {
        case 'N':
            return 'W'; 
        case 'W':
            return 'S';
        case 'E':
            return 'N';
        case 'S': 
            return 'E';
    } 
    return 0;
}
int main(void) {
    int n, m, tmp, tx, ty;
    bool map[50][50];
    queue < pair<status, int> > q;
    set <status> s;
    scanf("%d %d", &n, &m);
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < m; i++) {
            scanf("%d", &tmp);
            map[k][i] = (bool) tmp;
        }
    }
    scanf("%d %d %d %d %c", &temp.x, &temp.y, &tx, &ty, &temp.d);
    if (map[temp.x][temp.y] || (temp.x > 0 ? map[temp.x-1][temp.y] : false) || (temp.y > 0 ? map[temp.x][temp.y-1] : false) || (temp.x > 0 && temp.y > 0 ? map[temp.x-1][temp.y-1] : false)) {
        printf("-1");
        return 0;
    }
    q.push(make_pair(temp, 0));
    while (!q.empty()) {
        pair<status, int> now = q.front();
        q.pop();
        temp = now.first;
        if (temp.x == tx && temp.y == ty) {
            printf("%d", now.second);
            return 0;
        }
        if (s.count(temp)) {
            continue;
        } else {
            s.insert(temp);
        }
        temp.d = right(temp.d);
        if (!s.count(temp)) {
            q.push(make_pair(temp, now.second+1)); 
        } 
        temp = now.first;
        temp.d = left(temp.d);
        if (!s.count(temp)) {
            q.push(make_pair(temp, now.second+1)); 
        } 
        temp = now.first; 
        switch (temp.d) {
            case 'N':
                for (int k = 0; k < 3 && --temp.x > 0; k++) {
                    if (!map[temp.x-1][temp.y] && !map[temp.x-1][temp.y-1]) {
                        if (!s.count(temp)) {
                            q.push(make_pair(temp, now.second+1)); 
                        }  
                    } else {
                        break;
                    }
                }
                break;
            case 'W':
                for (int k = 0; k < 3 && --temp.y > 0; k++) {
                    if (!map[temp.x-1][temp.y-1] && !map[temp.x][temp.y-1]) {
                        if (!s.count(temp)) {
                            q.push(make_pair(temp, now.second+1)); 
                        }  
                    } else {
                        break;
                    }
                }
                break;
            case 'E':
                for (int k = 0; k < 3 && ++temp.y < m; k++) {
                    if (!map[temp.x-1][temp.y] && !map[temp.x][temp.y]) {
                        if (!s.count(temp)) {
                            q.push(make_pair(temp, now.second+1)); 
                        }  
                    } else {
                        break;
                    }
                }
                break;
            case 'S': 
                for (int k = 0; k < 3 && ++temp.x < n; k++) {
                    if (!map[temp.x][temp.y] && !map[temp.x][temp.y-1]) {
                        if (!s.count(temp)) {
                            q.push(make_pair(temp, now.second+1)); 
                        }  
                    } else {
                        break;
                    }
                }
                break;
        }
    }
    printf("-1");
    return 0;
}
[/codec]
```

---

## 作者：落叶流云 (赞：2)

首先，要仔细读题，注意机器人其实是占据了四格的空间的。（因此必然是不能走到网格边缘）

但是处理的时候，可以视为机器人在格点上，而障碍物占据四个格点。

接下来套用bfs框架就好了，大概就是用一个三元组(r,c,dir)表示当前所处的位置和朝向，由于不需要输出路径，bfs树都不用建。

在这里使用了一些常量数组来简化转弯和前行多格的代码，整体还是挺优美简洁的。（好吧我承认我是学的算法竞赛入门经典的写法)

蒟蒻一枚，把这个逻辑本来就很清晰的代码还注释得无比啰嗦。。。不要吐槽。。。


```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int maxn=55;
const char dirs[]="NESW";
const int dr[]={-1,0,1,0};
const int dc[]={0,1,0,-1};//建立常量数组,简化转弯/移动等代码,dr[n]即当前朝向为dirs[n]时，移动一步之后r的变化量 
int n,m; 
int a[maxn][maxn],d[maxn][maxn][4];//a是题目中的网格,d是初始状态到状态(r,c,dir)的最短距离 
int ans;
int fx,fy,bx,by,bdir;
struct node
{
    int r,c,dir;//dir=0/1/2/3分别对应NESW 
    node(int r=0,int c=0,int dir=0):r(r),c(c),dir(dir) {}
};
int dir_id(char c)
{
    return strchr(dirs,c)-dirs;
} 
node turn(const node& u, int k);
void bfs();
int main()
{
    memset(a,0,sizeof(a));
    cin>>n>>m;
    for(int i=1;i<=n;i++)//注意，由于这里的目的是读取障碍，所以横纵坐标从1开始编号，而实际上程序中的网格横纵坐标均为从0开始编号 
    {
        for(int j=1;j<=m;j++)
        {
            int temp;
            cin>>temp;
            if(temp)
            {
                a[i-1][j-1]=a[i][j-1]=a[i-1][j]=a[i][j]=1;//一个网格上的障碍，可以等价于其四个顶点都不能到达 
            }
        }
    }
    char temp;
    cin>>bx>>by>>fx>>fy>>temp;
    bdir=dir_id(temp);
    bfs();
     return 0;
}
node turn(const node& u, int k)
{
    int dir=u.dir;
    if(k==1) 
    {
        dir=(dir+3)%4; // 左转 
    }
    if(k==2) 
    {
        dir=(dir+1)%4; // 右转 
    }
    return node(u.r,u.c,dir);
}
void bfs()
{
    queue<node> q;
    memset(d,-1,sizeof(d));
    node u(bx,by,bdir);
    d[u.r][u.c][u.dir]=0;
    q.push(u);
    while(!q.empty())
    {
        node u=q.front();
        q.pop();
        if(u.r==fx&&u.c==fy)
        {
            cout<<d[fx][fy][u.dir]<<endl;
            return;
        }
        for(int i=1;i<=2;i++)//转弯的两种情况，1表示逆时针，2表示顺时针 
        {
            node v=turn(u,i);
            if(v.r>=1&&v.r<n&&v.c>=1&&v.c<m&&d[v.r][v.c][v.dir]==-1)
            {
                d[v.r][v.c][v.dir]=d[u.r][u.c][u.dir]+1;
                q.push(v);
            }
        } 
        for(int i=1;i<=3;i++)//前行的三种情况 
        {
            node v(u.r+dr[u.dir]*i,u.c+dc[u.dir]*i,u.dir);
            if(v.r>=1&&v.r<n&&v.c>=1&&v.c<m&&d[v.r][v.c][v.dir]==-1)
            {
                if(a[v.r][v.c])
                {
                    break;//如果遇到障碍，立刻终止前行的尝试（并不能穿墙）
                }
                d[v.r][v.c][v.dir]=d[u.r][u.c][u.dir]+1;
                q.push(v);
            }
        }
    }
    cout<<-1<<endl; 
}

```

---

## 作者：Horizon·Sun (赞：2)

由于这道题刚了三天才做完（还不是因为我菜……），于是写一写题解记录一下……

题解中共有3份代码，前两份可忽略，第三份会有部分解释。代码中会有很多重复内容和枚举内容，其实可以存一下过程后循环做。

[点我看题](https://www.luogu.org/problem/P1126)

首先，我发现了这句话：“如果无法到达，输出−1。”

于是交了一发-1…… score:20。

开始专心看题。

看完便知道是搜索，但需要考虑的是机器人站在格点上，但障碍物在格子里，这样如果全存在一张图里肯定会乱。然鹅存在两个图里我肯定会乱……

于是突发奇想，只记录机器人左上角的格子的位置，判断能否走到下一格时顺带判断周围三个格子，方向单独判断不就没了？

于是兴奋地写了一发深搜（注意，是深搜,会TLE+RE+……）打完发现样例过不了……

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
#define maxn 100
using namespace std;

int n,m,stx,sty,enx,eny,to,ans=47483647;
int f[maxn][maxn][5];
int dx[5]={0,1,0,-1,0};
int dy[5]={0,0,1,0,-1};
bool map[maxn][maxn];

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') x=10*x+ch-'0',ch=getchar();
    return f*x;
}

void dfs(int x,int y,int pos,int sum)
{
    if(x==enx&&y==eny) {ans=min(ans,sum);return;}
    if(sum>f[x][y][pos]) return;
    f[x][y][pos]=sum;
    if(pos==1)
    {
        for(register int i=1;i<=3;i++)
        {
            int xx=x+i,yy=y;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,2,sum+2);
            xx=x-i;y=y;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,4,sum+2);
            xx=x;yy=y+i;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,1,sum+1);
            xx=x;yy=y-i;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,3,sum+3);
        }
    }else
    if(pos==2)
    {
        for(register int i=1;i<=3;i++)
        {
            int xx=x+i,yy=y;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,2,sum+1);
            xx=x-i;y=y;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,4,sum+3);
            xx=x;yy=y+i;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,1,sum+2);
            xx=x;yy=y-i;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,3,sum+2);
        }
    }else
    if(pos==3)
    {
        for(register int i=1;i<=3;i++)
        {
            int xx=x+i,yy=y;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,2,sum+2);
            xx=x-i;y=y;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,4,sum+2);
            xx=x;yy=y+i;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,1,sum+3);
            xx=x;yy=y-i;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,3,sum+1);
        }
    }else
    if(pos==4)
    {
        for(register int i=1;i<=3;i++)
        {
            int xx=x+i,yy=y;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,2,sum+3);
            xx=x-i;y=y;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,4,sum+1);
            xx=x;yy=y+i;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,1,sum+2);
            xx=x;yy=y-i;
            if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) dfs(xx,yy,3,sum+2);
        }
    }
}

int main()
{
    n=read(),m=read();
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=m;j++)
            map[i][j]=read();
    stx=read(),sty=read(),enx=read(),eny=read();
    char ch;
    while(ch!='E'&&ch!='S'&&ch!='W'&&ch!='N') ch=getchar();
    if(ch=='E') to=1;
    else if(ch=='S') to=2;
    else if(ch=='W') to=3;
    else if(ch=='N') to=4;
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=n;j++) 
            f[i][j][1]=f[i][j][2]=f[i][j][3]=f[i][j][4]=47483647;
    dfs(stx,sty,to,0);
    printf("%d",ans==47483647? -1:ans);

    return 0;
}
```
2AC+3TLE+5WA

于是疯狂差错……

第二天，蔡老师提示我：首先，网格图用DFS就是个~~SB~~错误……

继续改………………………………………………………………………………

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
#define maxn 1000
using namespace std;

int n,m,stx,sty,enx,eny,ans=47483647;
int map[maxn][maxn],f[maxn][maxn][5];
struct node
{
    int x,y,pos,val;
};
queue<node> q;

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') x=10*x+ch-'0',ch=getchar();
    return f*x;
}

void bfs()
{
    while(!q.empty())
    {
        node tmp=q.front();q.pop();
        int x=tmp.x,y=tmp.y,pos=tmp.pos,sum=tmp.val;
        if(x==enx&&y==eny) {ans=min(ans,sum);break;}
        if(sum>=f[x][y][pos]) continue;
        f[x][y][pos]=sum;
        if(pos==1)
        {
            for(register int i=1;i<=3;i++)
            {
                int xx=x+i,yy=y;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,2,sum+2});
                xx=x-i;y=y;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,4,sum+2});
                xx=x;yy=y+i;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,1,sum+1});
                xx=x;yy=y-i;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,3,sum+3});
            }
        }else
        if(pos==2)
        {
            for(register int i=1;i<=3;i++)
            {
                int xx=x+i,yy=y;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,2,sum+1});
                xx=x-i;y=y;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,4,sum+3});
                xx=x;yy=y+i;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,1,sum+2});
                xx=x;yy=y-i;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,3,sum+2});
            }
        }else
        if(pos==3)
        {
            for(register int i=1;i<=3;i++)
            {
                int xx=x+i,yy=y;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,2,sum+2});
                xx=x-i;y=y;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,4,sum+2});
                xx=x;yy=y+i;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,1,sum+3});
                xx=x;yy=y-i;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,3,sum+1});
            }
        }else
        if(pos==4)
        {
            for(register int i=1;i<=3;i++)
            {
                int xx=x+i,yy=y;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,2,sum+3});
                xx=x-i;y=y;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,4,sum+1});
                xx=x;yy=y+i;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,1,sum+2});
                xx=x;yy=y-i;
                if((!map[xx][yy])&&(!map[xx+1][yy])&&(!map[xx][yy+1])&&(!map[xx+1][yy+1])&&(xx>=1)&&(xx<n)&&(yy>=1)&&(yy<m)) q.push((node){xx,yy,3,sum+2});
            }
        }
    }
}

int main()
{
    n=read(),m=read();
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=m;j++)
            map[i][j]=read();
    stx=read(),sty=read(),enx=read(),eny=read();
    char ch;
    int to; 
    while(ch!='E'&&ch!='S'&&ch!='W'&&ch!='N') ch=getchar();
    if(ch=='E') to=1;
    else if(ch=='S') to=2;
    else if(ch=='W') to=3;
    else if(ch=='N') to=4;
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=n;j++) 
            f[i][j][1]=f[i][j][2]=f[i][j][3]=f[i][j][4]=47483647;
    q.push((node){stx,sty,to,0});
    bfs();
    
    printf("%d",ans==47483647? -1:ans);

    return 0;
}
```

改完还是不对啊，连结果都一样……

第三天疯狂询问机房各大佬神仙，某W姓神仙提醒：输出q中弹出的点找找路径吧

找了几个点便发现了问题：机器人想去下一个点可以走1或2或3步，然鹅因为我直接判断的目的点是否合法，中间点是否合法没有判断……

在某D姓大佬嘲笑下手动修改完毕，便直接AC(长舒一口气）

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
#define maxn 1000
using namespace std;

int n,m,stx,sty,enx,eny,ans=47483647;          //变量应该很好理解吧……
int map[maxn][maxn],f[maxn][maxn][5];          //map存地图，f记录坐标为x,y,位置为pos的最小值
struct node
{
    int x,y,pos,val;
};
queue<node> q;                                 //bfs用的队列

inline int read()                              //可忽略的快读，没啥用
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') x=10*x+ch-'0',ch=getchar();
    return f*x;
}

inline bool pd1(int x,int y) {return ((!map[x][y])&&(!map[x+1][y])&&(!map[x][y+1])&&(!map[x+1][y+1]));}
inline bool pd2(int x,int y) {return ((x>=1)&&(x<n)&&(y>=1)&&(y<m));}

/*
	判断机器人的位置是否合法
	判断点坐标是否合法
*/

void bfs()
{
    while(!q.empty())
    {
        node tmp=q.front();q.pop();
        int x=tmp.x,y=tmp.y,pos=tmp.pos,sum=tmp.val;
        if(x==enx&&y==eny) {ans=min(ans,sum);continue;}
        if(sum>=f[x][y][pos]) continue;
        f[x][y][pos]=sum;                                                //做记录
        //以下内容可能会引起部分人生理和心理上的不适
		//简单说就是分4个方向判断走几步，如果没问题便加入队列
		//可以直接跳过这段……
		if(pos==1)
        {
            int xx=x+1,yy=y;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+2});
            xx=x-1;y=y;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+2});
            xx=x;yy=y+1;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+1});
            xx=x;yy=y-1;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+3});
            
            xx=x+2,yy=y;
            if(pd2(xx,yy)&&pd1(xx-1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+2});
            xx=x-2;y=y;
            if(pd2(xx,yy)&&pd1(xx+1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+2});
            xx=x;yy=y+2;
            if(pd2(xx,yy)&&pd1(xx,yy-1)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+1});
            xx=x;yy=y-2;
            if(pd2(xx,yy)&&pd1(xx,yy+1)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+3});
            
            xx=x+3,yy=y;
            if(pd2(xx,yy)&&pd1(xx-2,yy)&&pd1(xx-1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+2});
            xx=x-3;y=y;
            if(pd2(xx,yy)&&pd1(xx+2,yy)&&pd1(xx+1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+2});
            xx=x;yy=y+3;
            if(pd2(xx,yy)&&pd1(xx,yy-2)&&pd1(xx,yy-1)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+1});
            xx=x;yy=y-3;
            if(pd2(xx,yy)&&pd1(xx,yy+2)&&pd1(xx,yy+1)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+3});
        }else
        if(pos==2)
        {
            int xx=x+1,yy=y;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+1});
            xx=x-1;y=y;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+3});
            xx=x;yy=y+1;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+2});
            xx=x;yy=y-1;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+2});

            xx=x+2,yy=y;
            if(pd2(xx,yy)&&pd1(xx-1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+1});
            xx=x-2;y=y;
            if(pd2(xx,yy)&&pd1(xx+1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+3});
            xx=x;yy=y+2;
            if(pd2(xx,yy)&&pd1(xx,yy-1)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+2});
            xx=x;yy=y-2;
            if(pd2(xx,yy)&&pd1(xx,yy+1)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+2});

            xx=x+3,yy=y;
            if(pd2(xx,yy)&&pd1(xx-2,yy)&&pd1(xx-1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+1});
            xx=x-3;y=y;
            if(pd2(xx,yy)&&pd1(xx+2,yy)&&pd1(xx+1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+3});
            xx=x;yy=y+3;
            if(pd2(xx,yy)&&pd1(xx,yy-2)&&pd1(xx,yy-1)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+2});
            xx=x;yy=y-3;
            if(pd2(xx,yy)&&pd1(xx,yy+2)&&pd1(xx,yy+1)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+2});
        }else
        if(pos==3)
        {
            int xx=x+1,yy=y;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+2});
            xx=x-1;y=y;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+2});
            xx=x;yy=y+1;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+3});
            xx=x;yy=y-1;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+1});

            xx=x+2,yy=y;
            if(pd2(xx,yy)&&pd1(xx-1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+2});
            xx=x-2;y=y;
            if(pd2(xx,yy)&&pd1(xx+1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+2});
            xx=x;yy=y+2;
            if(pd2(xx,yy)&&pd1(xx,yy-1)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+3});
            xx=x;yy=y-2;
            if(pd2(xx,yy)&&pd1(xx,yy+1)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+1});

            xx=x+3,yy=y;
            if(pd2(xx,yy)&&pd1(xx-2,yy)&&pd1(xx-1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+2});
            xx=x-3;y=y;
            if(pd2(xx,yy)&&pd1(xx+2,yy)&&pd1(xx+1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+2});
            xx=x;yy=y+3;
            if(pd2(xx,yy)&&pd1(xx,yy-2)&&pd1(xx,yy-1)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+3});
            xx=x;yy=y-3;
            if(pd2(xx,yy)&&pd1(xx,yy+2)&&pd1(xx,yy+1)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+1});
        }else
        if(pos==4)
        {
            int xx=x+1,yy=y;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+3});
            xx=x-1;y=y;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+1});
            xx=x;yy=y+1;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+2});
            xx=x;yy=y-1;
            if(pd2(xx,yy)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+2});

            xx=x+2,yy=y;
            if(pd2(xx,yy)&&pd1(xx-1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+3});
            xx=x-2;y=y;
            if(pd2(xx,yy)&&pd1(xx+1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+1});
            xx=x;yy=y+2;
            if(pd2(xx,yy)&&pd1(xx,yy-1)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+2});
            xx=x;yy=y-2;
            if(pd2(xx,yy)&&pd1(xx,yy+1)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+2});

            xx=x+3,yy=y;
            if(pd2(xx,yy)&&pd1(xx-2,yy)&&pd1(xx-1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,2,sum+3});
            xx=x-3;y=y;
            if(pd2(xx,yy)&&pd1(xx+2,yy)&&pd1(xx+1,yy)&&pd1(xx,yy)) q.push((node){xx,yy,4,sum+1});
            xx=x;yy=y+3;
            if(pd2(xx,yy)&&pd1(xx,yy-2)&&pd1(xx,yy-1)&&pd1(xx,yy)) q.push((node){xx,yy,1,sum+2});
            xx=x;yy=y-3;
            if(pd2(xx,yy)&&pd1(xx,yy+2)&&pd1(xx,yy+1)&&pd1(xx,yy)) q.push((node){xx,yy,3,sum+2});
        }
    }
}

int main()
{
    n=read(),m=read();
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=m;j++)
            map[i][j]=read();
    stx=read(),sty=read(),enx=read(),eny=read();
    char ch;
    int to; 
    while(ch!='E'&&ch!='S'&&ch!='W'&&ch!='N') ch=getchar();
	//读入部分
    if(ch=='E') to=1;
    else if(ch=='S') to=2;
    else if(ch=='W') to=3;
    else if(ch=='N') to=4;
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=n;j++) 
            f[i][j][1]=f[i][j][2]=f[i][j][3]=f[i][j][4]=47483647;
	//初始化
    q.push((node){stx,sty,to,0});
    bfs();
    //结束……
    printf("%d",ans==47483647? -1:ans);

    return 0;
}
```
结束

---

## 作者：5ab_juruo (赞：1)

为什么题解里的方法都那么~~猥琐~~繁琐呢？

本蒟蒻写了一种较为简单~~但码量上天~~的方法，那就是——

# 建图

显然，这道题是最短路，且根据题目意思建图。

每个**格点**分裂成4个节点，代表4种方向。

相邻两个方向之间连两条**有向边**，权值为1。

同时，题目中给出的3种前进方式，分别在各个方向上建3条边。

**注意！每条边都必须对应相同的方向。**

不理解？我们来一张图：

![](https://s2.ax1x.com/2020/01/11/lIfu5j.png)

（这里少画了不同方向节点的转换边，但无伤大雅）

这样建完图，我们就可以愉快地 BFS 了。

期望得分：$100 \;pts$

实际得分：$90\; pts$

wtf？原来还要特判！

如果出发与结束相同，就要特判。

~~可能是本蒟蒻的 BFS 太菜了要特判~~

最后放上~~奇怪的~~代码：

```
#include <queue>
#include <cstdio>
#include <cstring>
using namespace std;

const int max_n = 50, max_node = max_n * max_n;

struct node
{
	int id, step;
};

bool is_cut[max_n][max_n], can_make[max_n][max_n] = {}, used[max_node<<2];
int hd[max_node<<2], des[max_node*20], nxt[max_node*20], cnt = 0, n, m;
queue<node> q;

// is_cut：是否有障碍物
// can_make：是否可以作节点
// used：BFS 时是否搜到过
// hd，des，nxt，cnt：链式前向星，不解释
// n，m：大小
// q：队列

inline int pack(int x, int y, int dir) { return 4 * (m * x + y) + dir; } // 生成节点序号

inline void a(int s, int t) // 加边
{
	des[cnt] = t;
	nxt[cnt] = hd[s];
	hd[s] = cnt;
	cnt++;
}

int main()
{
	memset(hd, -1, sizeof(hd));
	
	int sx, sy, ex, ey, desti;
	node cur, pus;
	char dk;
	
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			scanf("%d", &is_cut[i][j]); // 读入
	
	for (int i = 1; i < n; i++)
		for (int j = 1; j < m; j++) // 建图
		{
			can_make[i][j] = !(is_cut[i][j-1] || is_cut[i-1][j] || is_cut[i-1][j-1] | is_cut[i][j]);
			
			if (can_make[i][j])
			{
				for (int k = 0; k < 4; k++)
				{
					a(pack(i, j, k), pack(i, j, (k + 1) % 4));
					a(pack(i, j, (k + 1) % 4), pack(i, j, k));
				} // 不同方向之间的转换
				
				for (int k = 1; k <= 3; k++)
				{
					if (i - k > 0 && can_make[i-k][j])
					{
						a(pack(i-k, j, 2), pack(i, j, 2));
						a(pack(i, j, 0), pack(i-k, j, 0));
					}
					else
						break;
				} // 竖向边
				
				for (int k = 1; k <= 3; k++)
				{
					if (j - k > 0 && can_make[i][j-k])
					{
						a(pack(i, j-k, 1), pack(i, j, 1));
						a(pack(i, j, 3), pack(i, j-k, 3));
					}
					else
						break;
				} // 横向边
			}
		}
	
	scanf("%d%d%d%d %c", &sx, &sy, &ex, &ey, &dk); // 注意 scanf 里的空格，不打就会 RE
	
	if (sx == ex && sy == ey) // 特判
	{
		puts("0");
		return 0;
	}
	
	desti = pack(ex, ey, 0);
	
	switch (dk)
	{
		case 'E':
			cur.id = pack(sx, sy, 1);
			break;
		
		case 'S':
			cur.id = pack(sx, sy, 2);
			break;
		
		case 'W':
			cur.id = pack(sx, sy, 3);
			break;
		
		case 'N':
			cur.id = pack(sx, sy, 0);
			break;
		
		default: break;
	}
	
	cur.step = 0;
	q.push(cur);
	
	while (!q.empty()) // BFS
	{
		cur = q.front();
		q.pop();
		
		for (int p = hd[cur.id]; p != -1; p = nxt[p])
		{
			pus.id = des[p], pus.step = cur.step + 1;
			
			if (used[pus.id])
				continue;
			if (pus.id >= desti && pus.id - desti <= 3) // 判断是否在终点上
			{
				printf("%d\n", pus.step);
				return 0;
			}
			
			used[pus.id] = true;
			q.push(pus);
		}
	}
	
	puts("-1");
	
	return 0;
}
```

---

## 作者：anda (赞：1)

来发一下机器人搬重物这篇题解qaq
咳咳~这题首先我想写一个dfs的但是因为他
不停的来回转头而告终
看了一眼标签是bfs就写了一个
为了不让他来回转头写了一个vis三维数组
结果只得30
后来发现走两步和三步还需要特判
刚学了线段树于是写了一个类似lazy
的东西
后来发现比答案多了
写了一个优先队列
结果于事无补
后来觉得贪心是错的
又把
vis数组改成记忆化数组
结果只有40分
最后判了判边界
as a result
100分
70行还是比较爽的
```
#include<iostream>
#include<queue>
#include<cstdlib>
#include<cstring>
using namespace std;
int n,m,sx,sy,fx,fy,r1,a[100][100],vis[100][100][10],dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}};
char r;
struct node{
	int x,y,data,dir,e2,e3;
};
void bfs(){
queue<node>q;
q.push((node){sx,sy,0,r1,0,0});
for(int i=0;i<100;i++){
	for(int j=0;j<100;j++){
		for(int k=0;k<10;k++){
			vis[i][j][k]=0x7fffffff;
		}
	}
}
vis[sx][sy][r1]=0;
while(!q.empty()){
	node x=q.front();q.pop();
//	cout<<x.x<<" "<<x.y<<" "<<x.dir<<" "<<x.data<<" "<<x.e2<<" "<<x.e3<<endl;
//	system("pause");
	if(x.e2){
		int nx=x.x+dir[x.dir][0];int ny=x.y+dir[x.dir][1];
		if(nx<1||ny<1||nx>=n||ny>=m||a[nx][ny]||a[nx+1][ny]||a[nx][ny+1]||a[nx+1][ny+1]||vis[nx][ny][x.dir]<=x.data)continue;
		vis[nx][ny][x.dir]=x.data;
		q.push((node){nx,ny,x.data,x.dir,x.e2-1,x.e3});
		continue;
	}
	if(x.e3){
		int nx=x.x+dir[x.dir][0];int ny=x.y+dir[x.dir][1];
		if(nx<1||ny<1||nx>=n||ny>=m||a[nx][ny]||a[nx+1][ny]||a[nx][ny+1]||a[nx+1][ny+1])continue;
		if(x.e3-1==0&&vis[nx][ny][x.dir]<=x.data)continue;
		if(x.e3-1==0)vis[nx][ny][x.dir]=x.data;
		q.push((node){nx,ny,x.data,x.dir,x.e2,x.e3-1});
		continue;
	}
//       if(x.x==fx&&x.y==fy){
//		 cout<<x.data;//exit(0);
//	   }
	for(int i=1;i<=3;i++){
		int nx=x.x+dir[x.dir][0];int ny=x.y+dir[x.dir][1];
		if(nx<1||ny<1||nx>=n||ny>=m||a[nx][ny]||a[nx+1][ny]||a[nx][ny+1]||a[nx+1][ny+1])continue;
		//cout<<vis[nx][ny][x.dir]<<endl;
		if(i==1&&vis[nx][ny][x.dir]>x.data+1){
			vis[nx][ny][x.dir]=x.data+1;
			q.push((node){nx,ny,x.data+1,x.dir,x.e2,x.e3});
		}
		if(i==2){
			//vis[x][y][x.dir]=1;
			q.push((node){nx,ny,x.data+1,x.dir,x.e2+1,x.e3});
		}
		if(i==3){
			//vis[x][y][x.dir]=1;
			q.push((node){nx,ny,x.data+1,x.dir,x.e2,x.e3+2});
		}
	}
	   if(vis[x.x][x.y][(x.dir+1)%4]>x.data+1){
				vis[x.x][x.y][(x.dir+1)%4]=x.data+1;
				q.push((node){x.x,x.y,x.data+1,(x.dir+1)%4,x.e2,x.e3});
		}
	   if(vis[x.x][x.y][(x.dir+3)%4]>x.data+1){
			vis[x.x][x.y][(x.dir+3)%4]=x.data+1;
			q.push((node){x.x,x.y,x.data+1,(x.dir+3)%4,x.e2,x.e3});
			}
       }
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	cin>>sx>>sy>>fx>>fy>>r;
	if(r=='N')r1=0;
	if(r=='E')r1=1;
	if(r=='S')r1=2;
	if(r=='W')r1=3;
	bfs();
	if(vis[fx][fy][0]==0x7fffffff&&vis[fx][fy][1]==0x7fffffff&&vis[fx][fy][2]==0x7fffffff&&vis[fx][fy][3]==0x7fffffff)cout<<-1;
	else cout<<min(min(vis[fx][fy][0],vis[fx][fy][1]),min(vis[fx][fy][2],vis[fx][fy][3]));
}
```


---

## 作者：90182si (赞：1)

```cpp
蒟蒻的我写了一整天。。。。
代码压到47行，绝对是最短的了，哈哈哈，虽然没什么卵用
思路就是以步数为基准，把每次步数相同的进行判断，
最后首先到达终点的就是最短路，输出当前步数即可。
#include <bits/stdc++.h>
using namespace std;
struct node{int x,y,step,fn;char w;}k;
queue<node> q;
int N,M,tu[404][404],vis[404][404],X,Y,Xi,Yi;
char W,wss[4]={'E','S','W','N'};
void bfs(int n,int step)
{
    if(step>N*M/2||!n){cout<<-1<<endl;return;}//如果步数太多或者没有路走就结束 
    int numm=0;
    while(n--){//搜第step步满足的坐标 
        node p=q.front();//所有为step步的坐标出队 
        if(p.x==Xi&&p.y==Yi){cout<<p.step<<endl;return;}//找到就输出并结束 
        int an=3,hang=-1,lie=0;
        if(p.w=='E')hang=0,lie=1,an=0;
        else if(p.w=='S')hang=1,lie=0,an=1;
        else if(p.w=='W')hang=0,lie=-1,an=2;//转向四个方向hang代表行是否变化，lie代表列是否变化，an代表转向		
        k.step=step;k.x=p.x;k.y=p.y;k.fn=1;//坐标不变，转向次数为1 
        if(!p.fn){k.w=wss[(an+1)%4];q.push(k);numm++;k.w=wss[(an+3)%4];k.fn=3;q.push(k);numm++;}//第一次转向，转到左右两个方向，并push坐标		
        if(p.fn==1&&p.x==X&&p.y==Y){k.fn=2;k.w=wss[(an+1)%4];q.push(k);numm++;}//起点坐标180°旋转 
        k.fn=0;k.w=p.w;//方向不变，转的次数为零 
        for(int i=1;i<4;i++){//向前走1~3步 
            k.x=p.x+hang*i;k.y=p.y+lie*i;
            if(k.x<1||k.y<1||k.x>N-1||k.y>M-1)break;//越界判断 
            if(tu[k.x][k.y]||tu[k.x+1][k.y+1]||tu[k.x+1][k.y]||tu[k.x][k.y+1])break;//障碍物判断 
            if(vis[k.x][k.y]&&vis[k.x+hang][k.y+lie]&&vis[k.x+2*hang][k.y+2*lie])break;//向前3格都走过就跳过，没有都走过就走了试试，万一步数可能更少 
            q.push(k);			
            vis[k.x][k.y]=step;//记录当前坐标 
            numm++;
        }
        q.pop();		
    }
    bfs(numm,step+1);//第step+1一共有numm个入队 
} 
int main()
{
    memset(vis,0,sizeof(vis));
    cin>>N>>M;
    for(int i=1;i<=N;i++)	
        for(int j=1;j<=M;j++)
            cin>>tu[i][j];	
    cin>>X>>Y>>Xi>>Yi>>W;	
    k.step=0;k.fn=0;k.x=X;k.y=Y;k.w=W;//push起点信息 
    vis[X][Y]=1;
    q.push(k);
    bfs(1,1);
}

```

---

## 作者：cmwqf (赞：1)

方法：bfs，与楼下dalao不同的是，用3维数组存每个点每个方向的最小值，如果大于等于它就退出，最后把step[xb][yb][i]找一最小值即可，请忽略flag,没什么用。若最小值还大于maxN\*maxN\*2(只要能走到就绝对不会大于这个值)，就输出-1。

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int maxN=55,move[4][2]={{1,0},{-1,0},{0,1},{0,-1}},d[4]={2,1,3,4};
int n,m,map[maxN+1][maxN+1],xa,ya,xb,yb,dir,q[maxN*maxN*5+1][3],step[maxN+1][maxN+1][5];
bool flag[maxN+1][maxN+1][5];
bool check(int x0,int y0,int t)
{
    if(!map[x0][y0]&&!map[x0][y0+1]&&!map[x0+1][y0]&&!map[x0+1][y0+1]&&flag[x0][y0][t]) return true;//判断是否能走
    return false;
}
int bfs()
{
    //printf("1:N 2:S 3:E 4:W\n");
    if(map[xa][ya]==1) return -1;
    int head=0,tail=0;
    q[tail][0]=xa;q[tail][1]=ya;q[tail++][2]=dir;
    flag[xa][ya][dir]=false;step[xa][ya][dir]=0;//初始化
    while(head<tail)
    {
        int x=q[head][0];
        int y=q[head][1];
        int t=q[head][2];
        for(int i=0;i<4;i++)
        {
            int p=0;
            if(d[i]!=t) p=1;
            int l=d[i]-t;
            if((l==1&&(t!=2&&d[i]!=3))||(l==-1&&(t!=3&&d[i]!=2))) p=2;
            for(int j=1;j<=3;j++)
            {
                int x0=x+move[i][0]*j;
                int y0=y+move[i][1]*j;
                if(!check(x0,y0,t)) break;
                if(x0<1||y0<1||x0>n||y0>m) break;
                if(!flag[x0][y0][d[i]]) continue;
                int way=step[x][y][t]+1+p;
                if(way>=step[x0][y0][d[i]]) continue;
                q[tail][0]=x0;q[tail][1]=y0;q[tail++][2]=d[i];
                step[x0][y0][d[i]]=way;
            }
        }
        head++;
    }//bfs在此
    /*for(int i=0;i<tail;i++)
        printf("%d %d %d %d\n",q[i][0],q[i][1],q[i][2],step[q[i][0]][q[i][1]][q[i][2]]);*/
    int min=step[xb][yb][0],k=0;
    for(int i=1;i<5;i++)
        if(min>step[xb][yb][i]) {min=step[xb][yb][i];k=i;}
    //printf("%d\n",k);
    if(min>maxN*maxN*2) return -1;
    return min;
}
int main()
{
    memset(map,1,sizeof(map));
    memset(flag,true,sizeof(flag));
    memset(step,0x3f,sizeof(step));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++) 
            scanf("%d",&map[i][j]);
    char ch;
    scanf("%d%d%d%d %c",&xa,&ya,&xb,&yb,&ch);
    switch(ch)
    {
        case 'N':dir=1;break;
        case 'S':dir=2;break;
        case 'E':dir=3;break;
        case 'W':dir=4;break;
    }
    printf("%d",bfs());
    return 0;
}
```

---

## 作者：桀骜的野心家 (赞：1)

这是一道BFS，其实并不难，只是有些细节要注意。

```cpp

#include<cstdio>  
#include<algorithm>  
#include<cstring>  
using namespace std;  
bool  a[51][51]; //记录地图上的障碍 
int s[10000][4];  
bool b[51][51][4];  //记录情况是否已经被找过
int n,m;  
bool check(int x,int y,int x1,int y1)  
{int i;  
    if (x==x1);  
     {  
        if (y>y1) swap(y,y1);  
         for (i=y;i<=y1;i++)  
            if (!((a[x1][i]) && (a[x1][i+1]) && (a[x1+1][i]) && (a[x1+1][i+1]))) return false;
//判断一个点能否走到要注意途中是否有障碍，而且判断是否有障碍要看左上、右上、左
//下、右下   
     }  
     if (y==y1);  
     {  
        if (x>x1) swap(x,x1);  
         for (i=x;i<=x1;i++)  
            if (!((a[i][y]) && (a[i][y+1]) && (a[i+1][y]) && (a[i+1][y+1]))) return false;  
//同上 
     }  
     return true;  
      
}  
int main()  
{int t,w,i,j,k,e,x,y,x1,y1,x2,y2;  
 char c;    
   scanf("%d%d",&n,&m);  
   for (i=1;i<=n;i++)  
      for (j=1;j<=m;j++)  
         {   
           scanf("%d",&e);  
           if (e==0)  a[i][j]=true;  
               else a[i][j]=false;         
         }  
    scanf("%d%d%d%d%c",&s[1][1],&s[1][2],&x2,&y2,&c);  
    if ((s[1][1]==x2) && (s[1][2]==y2)) //注意终点和起点相同的情况   
            {  
                printf("0");  
                return 0;  
            }  
    scanf("%c",&c);  
    if (c=='E') s[1][3]=0;  
    if (c=='S') s[1][3]=1;  
    if (c=='W') s[1][3]=2;  
    if (c=='N') s[1][3]=3;  
    t=1;  
    w=1;  
    memset(b,true,sizeof(b));  
    b[s[t][1]][s[t][2]][s[t][3]]=false;  
    while (t<=w)  
     {  
        x=s[t][1];  
        y=s[t][2];  
        x1=x;  
        y1=y;  
        for (i=1;i<=3;i++)  
            {  
                if (s[t][3]==0) y1=y+i;  
                if (s[t][3]==2) y1=y-i;   
                if (s[t][3]==1) x1=x+i;  
                if (s[t][3]==3) x1=x-i;  
                if ((x1>=1) && (x1<=n-1) && (y1>=1) && (y1<=m-1))  
                   if (check(x,y,x1,y1) && (b[x1][y1][s[t][3]]))  
                       {  
                        w++;  
                        s[w][1]=x1;  
                        s[w][2]=y1;  
                        s[w][3]=s[t][3];  
                        b[x1][y1][s[w][3]]=false;  
                        s[w][0]=s[t][0]+1;  
                        if ((x1==x2) && (y1==y2))  
                            {  
                                printf("%d",s[w][0]);  
                                return 0;  
                            }  
                       }     
            }  
         x1=s[t][3]-1;  
         if (x1<0) x1=3;  
         if (b[x][y][x1])   
            {  
                b[x][y][x1]=false;  
                w++;  
                s[w][1]=x;  
                s[w][2]=y;  
                s[w][3]=x1;  
                s[w][0]=s[t][0]+1;  
            }  
        x1=s[t][3]+1;  
        if (x1>3) x1=0;  
          if (b[x][y][x1])  
           {  
            b[x][y][x1]=false;  
            w++;  
            s[w][1]=x;  
            s[w][2]=y;  
            s[w][3]=x1;  
            s[w][0]=s[t][0]+1;  
           }  
     t++;              
     }           
   printf("-1"); //找不到结果输出-1     
}  
```

---

## 作者：plazum (赞：1)

注意边缘是不能走的……这一点坑了我好久……

```cpp

#include<stdio.h>
const char dx[]={0,1,0,-1};
const char dy[]={1,0,-1,0};
struct{
    unsigned char x,y;
    unsigned short step;
    char d;
//    unsigned char father;
}xy[10000];
int n,m,i,j,fx,fy,t,head,tail=1,tx,ty,nx,ny,nstep;
unsigned char a[51][51];
bool v[51][51][4];//记录一个状态有没有被访问过
int main()
{
    scanf("%d%d",&n,&m);
    for(;i<n;i++)
        for(j=0;j<m;j++){
            scanf("%d",&t);//t=getchar()-'0';getchar();
            if(t)a[i][j]=1,a[i][j+1]=1,a[i+1][j]=1,a[i+1][j+1]=1;
        }
    scanf("%d%d%d%d %c",&xy[0].x,&xy[0].y,&fx,&fy,&xy[0].d);
    switch(xy[0].d){
        case 'E':xy[0].d=0;break;
        case 'S':xy[0].d=1;break;
        case 'W':xy[0].d=2;break;
        case 'N':xy[0].d=3;
    }
/*    for(i=0;i<=n;i++){for(j=0;j<=m;j++){
        if(i==xy[0].x&&j==xy[0].y)printf("S ");
        else if(i==fx&&j==fy)printf("F ");
        else printf(a[i][j]?"1 ":"0 ");
    }putchar('\n');}*/
    v[xy[0].x][xy[0].y][xy[0].d]=true;
    while(head<tail){
        t=xy[head].d;nx=tx=xy[head].x;ny=ty=xy[head].y;nstep=xy[head].step;
//        printf("%3d (father:%3d): %d %d %d %d\n",head,xy[head].father,nx,ny,xy[head].d,xy[head].step);
        if(nx==fx&&ny==fy){printf("%d",nstep);return 0;}
        for(i=0;i<3;i++){
            if((tx+=dx[t])>0&&tx<n&&(ty+=dy[t])>0&&ty<m&&!a[tx][ty]){
                if(tx==fx&&ty==fy){printf("%d",nstep+1);return 0;}
                if(!v[tx][ty][t]){
//                    xy[tail].father=head,
                    v[tx][ty][t]=true,xy[tail].x=tx,xy[tail].y=ty,
                    xy[tail].step=nstep+1,xy[tail].d=t,tail++;
                }
            }else break;
        }
        if(!v[nx][ny][t+1&3])//xy[tail].father=head,
            xy[tail].x=nx,xy[tail].y=ny,xy[tail].step=nstep+1,xy[tail].d=(t+1)&3,tail++,
            v[nx][ny][t+1&3]=true;
        if(!v[nx][ny][t+3&3])//xy[tail].father=head,
            xy[tail].x=nx,xy[tail].y=ny,xy[tail].step=nstep+1,xy[tail].d=(t+3)&3,tail++,
            v[nx][ny][t+3&3]=true;
        head++;
    }
    printf("-1");
    
    return 0;
}

```

---

## 作者：lych (赞：1)

显然这是一道经典的广搜题目，使用BFS，可以用O(4MN)的时间通过，对于m，n只有50的情况，时间绰绰有余！！

然而这道题目不同于普通的广搜，有方向限制，因此我们把数组再增加一维，表示方向，并增加专项的功能，代码：

```delphi
var  
  fang:array[1..4,1..3,1..2] of longint;  
  h:array[0..300000,1..4] of longint;  
  a:array[0..51,0..51] of longint;  
  f:array[0..51,0..51,1..4] of boolean;  
  b:array[0..51,0..51] of boolean;  
  head,tail,i,j,k,s,n,m,x,y,z,xx,yy,zz,x1,x2,y1,y2:longint;  
  ch:char;  
function pre(sx:longint):longint;  
begin  
  if sx=1 then exit(4) else exit(sx-1);  
end;  
function next(sx:longint):longint;  
begin  
  if sx=4 then exit(1) else exit(sx+1);  
end;  
begin  
  for i:=1 to 3 do  
    begin  
      fang[1,i,1]:=-i;  
      fang[2,i,2]:=-i;  
      fang[3,i,1]:=i;  
      fang[4,i,2]:=i;  
    end;  //方位坐标
  readln(m,n);  
  for i:=1 to m do  
    for j:=1 to n do  
      read(a[i,j]);  
  dec(m); dec(n);  
  for i:=1 to m do  
    for j:=1 to n do  
      if (a[i,j]=0) and (a[i+1,j]=0) and (a[i,j+1]=0) and (a[i+1,j+1]=0) then  
        begin  
          for k:=1 to 4 do  
            f[i,j,k]:=true;  
          b[i,j]:=true;  
        end;  //预处理
  read(x1,y1,x2,y2);  
  if (x1=x2) and (y1=y2) then begin writeln(0); halt; end;  
  if not b[x1,y1] or not b[x2,y2] then begin writeln(-1);halt; end;//特殊情况判断  
  read(ch);  
  read(ch);  
  case ch of  
    'N':s:=1;  
    'W':s:=2;  
    'S':s:=3;  
    'E':s:=4;  
  end;  //初始方位
  f[x1,y1,s]:=false;  
  h[1,1]:=x1;  
  h[1,2]:=y1;  
  h[1,3]:=s;  
  head:=0;  
  tail:=1;  
  while head<tail do  
    begin  
      head:=head mod 300000+1;  //循环队列
      x:=h[head,1];  
      y:=h[head,2];  
      z:=h[head,3];  
      zz:=pre(z); //左转 
      if f[x,y,zz] then  
        begin  
          tail:=tail mod 300000+1;
          h[tail,1]:=x;  
          h[tail,2]:=y;  
          h[tail,3]:=zz;  
          h[tail,4]:=h[head,4]+1;  
          f[x,y,zz]:=false;  
        end;  
      zz:=next(z);  //右转
      if f[x,y,zz] then  
        begin  
          tail:=tail mod 300000+1;
          h[tail,1]:=x;  
          h[tail,2]:=y;  
          h[tail,3]:=zz;  
          h[tail,4]:=h[head,4]+1;  
          f[x,y,zz]:=false;  
        end; //之所以不再转向除放置到终点的判断，是因为转向的方位，即横纵坐标不变，前一次没有到，这次怎么可能到呢？ 
      for i:=1 to 3 do//往前走1,2,3步  
        begin  
          xx:=x+fang[z,i,1];  
          yy:=y+fang[z,i,2];  
          if f[xx,yy,z] then  
            begin  
              tail:=tail mod 300000+1;  
              h[tail,1]:=xx;  
              h[tail,2]:=yy;  
              h[tail,3]:=z;  
              h[tail,4]:=h[head,4]+1;  
              f[xx,yy,z]:=false;  
              if (xx=x2) and (yy=y2) then  
                begin  
                  writeln(h[tail,4]);  
                  halt;  //直接输出并退出程序
                end;  
            end else if not b[xx,yy] then break;  //中间已经有障碍，直接跳过不走了
        end;  
    end;  
  writeln(-1); //无解 
end. [codep/]

---

## 作者：ShadowNight (赞：1)

## **一道 普及+ 的代码长度居然和 省选 的代码差不多长**
题目很简单，但是坑巨多	~~（浪费我4个下载量）~~

读完题后1s内要想到bfs否则您可以离开这个地方了

bfs去重：转化为格点图发现小球只允许待在 1<=x,y<=49且x<n,y<m的点上，每个格点有4个方向，根据bfs第一次即最短原理我们可以开一个三维bool数组去重：
```cpp
bool f[51][51][5];//第一维x，第二维y，第三维方向
```
同时建好链表：
```cpp
struct node{
	int x,y,step;char pos;
}q[12501];
//x，y代表所在点，setp代表步数，pos代表当前朝向
int head=1,tail=1;//链表头尾指针
```
这道题气人的就是方向是用char给你的，所以作为懒人我把char和int转化的函数写出来了：
```cpp
char int_to_char(int x)
{
	switch(x)
	{
		case 1:{return 'N';break;}
		case 2:{return 'E';break;}
		case 3:{return 'S';break;}
		case 4:{return 'W';break;}
	}
}
int char_to_int(char x)
{
	switch(x)
	{
		case 'N':{return 1;break;}
		case 'E':{return 2;break;}
		case 'S':{return 3;break;}
		case 'W':{return 4;break;}
	}
}
//1->N 2->E 3->S 4->W
```
接着入队函数就好写很多了：
```
void putin(int x,int y,int step,char pos)
{
	f[x][y][char_to_int(pos)]=true;
	//x,y在pos方向已经遍历
	q[tail].pos=pos;
	q[tail].step=step;
	q[tail].x=x;
	q[tail++].y=y;
	//所有元素入队，队尾+1
}
```
结构部分完毕，接下来读入+存储：

```cpp
bool map[51][51];
int n,m,bx,by,ex,ey;char s;
//别搞错了这些是全局变量

//以下在主函数读入
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	cin>>map[i][j];
	cin>>bx>>by>>ex>>ey>>s;
```
然后是特判：
1，小球（x，y）占了map(x,y),(x+1,y),(x,y+1),(x+1,y+1)
因此如果起点或者终点不能塞进小球直接gg
2，起点与终点位置相同时直接结束
```cpp
	if(map[bx][by]||map[bx+1][by]||map[bx][by+1]||map[bx+1][by+1]){cout<<-1;return 0;}
	if(map[ex][ey]||map[ex+1][ey]||map[ex][ey+1]||map[ex+1][ey+1]){cout<<-1;return 0;}
	if(bx==ex&&by==ey){cout<<0;return 0;}
```
此题bfs中，什么样的点可以入队呢？
1.左转和右转，因为球已经在点上了所以去重就行
```cpp
		if(char_to_int(q[head].pos)%2==0)//东西方向
		{
			if(!f[x][y][1])	putin(x,y,step+1,int_to_char(1));
			if(!f[x][y][3])	putin(x,y,step+1,int_to_char(3));
		}
		else				//南北方向
		{
			if(!f[x][y][2])	putin(x,y,step+1,int_to_char(2));
			if(!f[x][y][4])	putin(x,y,step+1,int_to_char(4));
		}
		
```
2.前方没有障碍物时向前走1.2.3
注意这里是可以到达终点的，由于向前1.2.3都为1步，所以到终点时直接输出step+1即可，这里可以运用bool函数实现，找到终点时bool=true输出。

然后我们再分析一下：
如果一步都不能走，那么第二步和第三步也走不了，第二步同理
因此我们只用将	3嵌套在2中，2嵌套在1中 就可以省下重复判断的时间了
~~（好像也没什么卵用）~~

代码请从下往上读:
```cpp
int	dirx[13]={0,	-1,0,1,0,	-2,0,2,0,	-3,0,3,0},
	diry[13]={0,	0,1,0,-1,	0,2,0,-2,	0,3,0,-3};
//全局变量dir来控制四个方向走1.2.3步时小球的移动
走三步的子函数：

bool check(node s,int st,int pos)
//这里check用来判断前方是否有障碍物
{
	if(pos==1)//北
	{
		if(s.x-st<1)return 0;//越界
		if(map[s.x-st][s.y]||map[s.x-st][s.y+1])return 0;//障碍
		return 1;
	}
	//以下同理
	if(pos==2)
	{
		if(s.y+st>m-1)return 0;
		if(map[s.x][s.y+st+1]||map[s.x+1][s.y+st+1])return 0;
		return 1;
	}
	
	if(pos==3)
	{
		if(s.x+st>n-1)return 0;
		if(map[s.x+st+1][s.y]||map[s.x+st+1][s.y+1])return 0;
		return 1;
	}
	
	if(pos==4)
	{
		if(s.y-st<1)return 0;
		if(map[s.x][s.y-st]||map[s.x+1][s.y-st])return 0;
		return 1;
	}
}

bool step3(node s)
{
	if(check(s,3,char_to_int(s.pos)))//第三步有无障碍
	{
		if(s.x+dirx[char_to_int(s.pos)+8]==ex&&s.y+diry[char_to_int(s.pos)+8]==ey)return 1;
       //找到终点
		else
		if(!f[s.x+dirx[char_to_int(s.pos)+8]][s.y+diry[char_to_int(s.pos)+8]][char_to_int(s.pos)])
		putin(s.x+dirx[char_to_int(s.pos)+8],s.y+diry[char_to_int(s.pos)+8],s.step+1,s.pos);
     //第三步入队
	}
	return 0;//走三步找不到终点
}
bool step2(node s)
{
	if(check(s,2,char_to_int(s.pos)))//第二步有无障碍
	{
		if(s.x+dirx[char_to_int(s.pos)+4]==ex&&s.y+diry[char_to_int(s.pos)+4]==ey)
		return 1;
    //找到终点
		else if(!f[s.x+dirx[char_to_int(s.pos)+4]][s.y+diry[char_to_int(s.pos)+4]][char_to_int(s.pos)])
		putin(s.x+dirx[char_to_int(s.pos)+4],s.y+diry[char_to_int(s.pos)+4],s.step+1,s.pos);
   //第二步入队
		return step3(s);
   //嵌套，尝试第三步
	}
	return 0;
}
bool step1(node s)
{
	if(check(s,1,char_to_int(s.pos)))//第一步有无障碍
	{
		if(s.x+dirx[char_to_int(s.pos)]==ex&&s.y+diry[char_to_int(s.pos)]==ey)
		return 1;
//到终点返回true结束函数
		else if(!f[s.x+dirx[char_to_int(s.pos)]][s.y+diry[char_to_int(s.pos)]][char_to_int(s.pos)])
		putin(s.x+dirx[char_to_int(s.pos)],s.y+diry[char_to_int(s.pos)],s.step+1,s.pos);
//走一步，入队
		return step2(s);
//嵌套，尝试走第二步
	}
	return 0;
}
//bfs循环判断（主函数中）
if(step1(q[head])){cout<<step+1;return 0;}
```
到此，所有坑全部填上 bfs函数可以登场了;
```cpp
	putin(bx,by,0,s);//入口入队
	
	while(head<tail)//bfs
	{
		int x=q[head].x,y=q[head].y,step=q[head].step;
        	//只是不想写太长，可以替换（忽略就好）
		
      		//转弯入队
		if(char_to_int(q[head].pos)%2==0)
		{
			if(!f[x][y][1])	putin(x,y,step+1,int_to_char(1));
			if(!f[x][y][3])	putin(x,y,step+1,int_to_char(3));
		}
		else
		{
			if(!f[x][y][2])	putin(x,y,step+1,int_to_char(2));
			if(!f[x][y][4])	putin(x,y,step+1,int_to_char(4));
		}
                          
		//前进
		if(step1(q[head])){cout<<step+1;return 0;}
		head++;//工具点用完了，可以扔了
	}
```
最后附上完整代码：
```cpp
#include<iostream>
  //只用iostream没有万能头哦，快夸我(*☆·☆*)
using namespace std;
  const int	Friendship_is_Magic=;//不给眼瞎的小马白嫖
bool map[51][51];//图
bool f[51][51][5];//去重
struct node{
	int x,y,step;char pos;
}q[12501];//队列
int head=1,tail=1;
int n,m,bx,by,ex,ey;char s;//点
int	dirx[13]={0,	-1,0,1,0,	-2,0,2,0,	-3,0,3,0},
	diry[13]={0,	0,1,0,-1,	0,2,0,-2,	0,3,0,-3};
//方向+距离

char int_to_char(int x)
{
	switch(x)
	{
		case 1:{return 'N';break;}
		case 2:{return 'E';break;}
		case 3:{return 'S';break;}
		case 4:{return 'W';break;}
	}
}
int char_to_int(char x)
{
	switch(x)
	{
		case 'N':{return 1;break;}
		case 'E':{return 2;break;}
		case 'S':{return 3;break;}
		case 'W':{return 4;break;}
	}
}
//转换
void putin(int x,int y,int step,char pos)
{
	f[x][y][char_to_int(pos)]=true;
	q[tail].pos=pos;
	q[tail].step=step;
	q[tail].x=x;
	q[tail++].y=y;
}
//入队
bool check(node s,int st,int pos)
{
	if(pos==1)
	{
		if(s.x-st<1)return 0;
		if(map[s.x-st][s.y]||map[s.x-st][s.y+1])return 0;
		return 1;
	}
	
	if(pos==2)
	{
		if(s.y+st>m-1)return 0;
		if(map[s.x][s.y+st+1]||map[s.x+1][s.y+st+1])return 0;
		return 1;
	}
	
	if(pos==3)
	{
		if(s.x+st>n-1)return 0;
		if(map[s.x+st+1][s.y]||map[s.x+st+1][s.y+1])return 0;
		return 1;
	}
	
	if(pos==4)
	{
		if(s.y-st<1)return 0;
		if(map[s.x][s.y-st]||map[s.x+1][s.y-st])return 0;
		return 1;
	}
}
//检测障碍
bool step3(node s)
{
	if(check(s,3,char_to_int(s.pos)))
	{
		if(s.x+dirx[char_to_int(s.pos)+8]==ex&&s.y+diry[char_to_int(s.pos)+8]==ey)return 1;
		else
		if(!f[s.x+dirx[char_to_int(s.pos)+8]][s.y+diry[char_to_int(s.pos)+8]][char_to_int(s.pos)])
		putin(s.x+dirx[char_to_int(s.pos)+8],s.y+diry[char_to_int(s.pos)+8],s.step+1,s.pos);
	}
	return 0;
}
bool step2(node s)
{
	if(check(s,2,char_to_int(s.pos)))
	{
		if(s.x+dirx[char_to_int(s.pos)+4]==ex&&s.y+diry[char_to_int(s.pos)+4]==ey)
		return 1;
		else if(!f[s.x+dirx[char_to_int(s.pos)+4]][s.y+diry[char_to_int(s.pos)+4]][char_to_int(s.pos)])
		putin(s.x+dirx[char_to_int(s.pos)+4],s.y+diry[char_to_int(s.pos)+4],s.step+1,s.pos);
		return step3(s);
	}
	return 0;
}
bool step1(node s)
{
	if(check(s,1,char_to_int(s.pos)))
	{
		if(s.x+dirx[char_to_int(s.pos)]==ex&&s.y+diry[char_to_int(s.pos)]==ey)
		return 1;
		else if(!f[s.x+dirx[char_to_int(s.pos)]][s.y+diry[char_to_int(s.pos)]][char_to_int(s.pos)])
		putin(s.x+dirx[char_to_int(s.pos)],s.y+diry[char_to_int(s.pos)],s.step+1,s.pos);
		return step2(s);
	}
	return 0;
}
//走路
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	cin>>map[i][j];
	cin>>bx>>by>>ex>>ey>>s;
  //输入
	
	if(map[bx][by]||map[bx+1][by]||map[bx][by+1]||map[bx+1][by+1]){cout<<-1;return 0;}
	if(map[ex][ey]||map[ex+1][ey]||map[ex][ey+1]||map[ex+1][ey+1]){cout<<-1;return 0;}
	if(bx==ex&&by==ey){cout<<0;return 0;}
	//特判
	putin(bx,by,0,s);//入口入队
	
	while(head<tail)//bfs
	{
		int x=q[head].x,y=q[head].y,step=q[head].step;
		
		if(char_to_int(q[head].pos)%2==0)
		{
			if(!f[x][y][1])	putin(x,y,step+1,int_to_char(1));
			if(!f[x][y][3])	putin(x,y,step+1,int_to_char(3));
		}
		else
		{
			if(!f[x][y][2])	putin(x,y,step+1,int_to_char(2));
			if(!f[x][y][4])	putin(x,y,step+1,int_to_char(4));
		}
		
		if(step1(q[head])){cout<<step+1;return 0;}
		head++;
	}
	cout<<-1;return Friendship_is_Magic;//禁止白嫖
}
```



---

## 作者：huiwang17 (赞：1)

这个是第8个点，误以为机器人能转180°会输出32而不是33.
然后第二个点和第五个点应该是走不到的。

```input #8
20 20
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0
0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1 0 1 1 0 0 1 1 1 0 1 1 1
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
19 4 15 17 E

```
```output
33
```


上代码
```cpp
#include <iostream>
#include <algorithm>
#include <map>
#include <string>
#include <vector>
#include <set>
#include <cmath>
#include <bitset>
#include <queue>

//Skyler1017

using namespace std;
#define ll long long
#define MAXINT 0xFFFFFFF //七个F


struct vex{
    int to; //这个点
    int d;
    int dir; //走到这个点的时候的方向
    vex(int a, int b, int c){to = a; d = b; dir = c;}
    vex(){}
};

bool operator < (vex n1, vex n2){
    return n1.d > n2.d;
}

int n, m;
int sx, sy;
int fx, fy;
int G[60][60]; //记录点是否能走
int dis[60][60]; //记录此刻的距离
int dy[] = {-1, 1, 0, 0, -2, 2, 0, 0, -3, 3, 0, 0}; //走的不同步数的情况
int dx[] = {0, 0, -1, 1, 0, 0, -2, 2, 0, 0, -3, 3}; //注意x是行，y是列
map<char, int> mp;
bool vis[3000]; //标记
priority_queue<vex> q; //堆

void mark(int x, int y){ //每一个格子会影响到四个顶点，标1就完事了
    G[x][y] = 1;
    G[x-1][y] = 1;
    G[x][y-1] = 1;
    G[x-1][y-1] = 1;
}



int check(int x, int y, int k){ //注意边界的那一圈是不能走的！
    if(x + dx[k] < 1 || x + dx[k] >= n || y + dy[k] < 1 || y + dy[k] >= m)
        return 0;
    for(int i = 1; i <= (dx[k] ? dx[k] / dx[k%4] :  dy[k] / dy[k%4]); i++){
        if(G[x + i * dx[k % 4]][y + i * dy[k % 4]])
            return 0;
    }
    return 1;
}

void bfs(int x, int y, int dir){ //其实没必要写成函数w但我喜欢
    if(vis[51 * x + y]) return;
    vis[51 * x + y] = 1;
    //printf("@@@@ %d %d: %d   %d\n", x, y, dis[x][y], dir+1);
    for(int k = 0; k < 12; k++){
        int nx = x + dx[k];
        int ny = y + dy[k];
        if(!check(x, y, k)) continue;
        int now = dis[x][y];
        if((k % 4) != dir) now++;
        if((k % 4 == 0 && dir == 1) || (k % 4 == 1 && dir == 0) || (k % 4 == 2 && dir == 3) || (dir == 2 && k % 4 == 3)) now++; //注意！！可能要相反的转！！可能一开始屁股朝着终点了！！
        if(now + 1 < dis[nx][ny]){
            dis[nx][ny] = now + 1;
            q.push(vex(51 * nx + ny, now + 1, k % 4));
            //printf("     %d %d: %d\n", nx, ny, dis[nx][ny]);
        }
    }

}

int main(){
    cin >> n >> m;
    bool f;
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= m; j ++){
            cin >> f;
            if(f) mark(i, j);
        }
    }

    cin >> sx >> sy >> fx >> fy;
    string dir;
    cin >> dir;

    /*看一下棋盘的哪些点能走，苦逼的debug
    for(int i = 0; i <= n; i ++){
        for(int j = 0; j <= m; j ++){
            if(i == sx && j == sy){
                cout << "$ ";
                continue;
            }
            if(i == fx && j == fy){
                cout << "@ ";
                continue;
            }
            if(!G[i][j]) cout << "1 ";
            else cout << "  ";
        }
        cout << endl;
    }
*/

    for(int i = 0; i <= n; i++)
        for(int j = 0; j <= m; j++)
            dis[i][j] = MAXINT; //最短路初始化

    mp['S'] = 3;
    mp['N'] = 2;
    mp['W'] = 0;
    mp['E'] = 1;

    q.push(vex(51 * sx + sy, 0, mp[dir[0]]));//最大的点数是50所以可以s这样处理一下
    dis[sx][sy] = 0;
    while(q.size()){
        vex top = q.top();
        q.pop();
        int x = top.to / 51;
        int y = top.to % 51;
        int d = top.dir;
        bfs(x, y, d);
    }
    if(dis[fx][fy] < MAXINT)
        cout << dis[fx][fy] << endl;
    else cout << "-1"; //嘤嘤嘤 这里要小心可能走不到的
}

```



---

## 作者：KAAAsS (赞：1)

（蒻蒟第一次题解，求轻喷QwQ）
善用stl、enum，vis采用一个二进制数标志方向（状压），使用数组lf、rt、offX、offY来表示左右转、行走，代码可以大幅简短并清楚许多。
```cpp
#include<iostream>
#include<queue>

using namespace std;

const int MAXN = 55;

enum Dir {
    E = 0x1, W = 0x2, N = 0x4, S = 0x8
};

struct Point {
    int x;
    int y;
    Dir dir;
    int cnt;
    bool operator == (const Point& p) const {
        return x == p.x && y == p.y;
    }
};

bool maze[MAXN][MAXN];
short vis[MAXN][MAXN], n, m;
int offX[9], offY[9];
Dir lf[9], rt[9];

inline bool inBound(Point p) {
    return p.x > 0 && p.x <= n && p.y > 0 && p.y <= m; 
}

inline bool canStay(Point p) {
    return maze[p.x][p.y] && maze[p.x][p.y+1]
        && maze[p.x+1][p.y] && maze[p.x+1][p.y+1];
}

void init() {
    offX[S] = 1; offX[N] = -1; offY[W] = -1; offY[E] = 1;
    lf[W] = S; lf[S] = E; lf[E] = N; lf[N] = W;
    rt[E] = S; rt[S] = W; rt[W] = N; rt[N] = E;
}

int bfs(Point st, Point dst) {
    queue<Point> Q;
    Point cur;
    bool flag = false;
    st.cnt = 0;
    Q.push(st);
    while (!Q.empty()) {
        cur = Q.front();
        Q.pop();
        if (cur == dst) { flag = true; break; }
        if (!inBound(cur)) continue;
        if (vis[cur.x][cur.y] & cur.dir) continue;
        vis[cur.x][cur.y] |= cur.dir;
        if (!canStay(cur)) continue;
        // Ops
        Point walk = {cur.x+offX[cur.dir], cur.y+offY[cur.dir], cur.dir, cur.cnt+1};
        Q.push(walk);
        if (canStay(walk)) {
            walk = {cur.x+offX[cur.dir]*2, cur.y+offY[cur.dir]*2, cur.dir, cur.cnt+1};
            Q.push(walk);
            if (canStay(walk)) {
                Q.push((Point){cur.x+offX[cur.dir]*3, cur.y+offY[cur.dir]*3, cur.dir, cur.cnt+1});
            }
        }
        Q.push((Point){cur.x, cur.y, lf[cur.dir], cur.cnt+1});
        Q.push((Point){cur.x, cur.y, rt[cur.dir], cur.cnt+1});
    }
    return flag? cur.cnt: -1;
}

int main() {
    int cur;
    Point st, dst;
    char dir;
    cin >> n >> m;
    init();
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> cur;
            maze[i][j] = cur == 0;
        }
    }
    cin >> st.x >> st.y >> dst.x >> dst.y >> dir;
    st.dir = dir == 'N' ? N:
        dir == 'S' ? S:
        dir == 'W' ? W: E;
    cout << bfs(st, dst) << endl;
    return 0;
}
```


---

## 作者：bymlg001 (赞：1)

#其实这个题可以换个思路

\_\_就不好好写最短路【滑稽

##把每个点拆成四个点

能与该点联通的就只有该点的另外三个方向和能直走到的n个点(0<=n<=3)

这样这道题就变成了一个最短路问题

跑spfa或dijkstra都行，因为状态比较多，所以spfa好写些(毕竟就是bfs）杠掉

不过这题还是有很多细节要处理

**AC程序**

###

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=1061109567;
int d[55][55][4];//存最短路 0表示N 1表示E 2表示S 3表示W 
int m[55][55],b[55][55];
bool vis[55][55][4];
int n,mm,sx,sy,ex,ey,sf;
char ch;
struct node{
    int x,y,f;
};
void spfa(){     //跑一遍最短的路，状态有点多，spfa比堆优化的dijkstra 
    queue<node> q;
    d[sx][sy][sf]=0;
    node node_t;
    node_t.x=sx;node_t.y=sy;node_t.f=sf;
    vis[sx][sy][sf]=1;
    q.push(node_t);
    while(!q.empty()){
        node node_now=q.front();q.pop();    
        int tx=node_now.x,ty=node_now.y,tf=node_now.f;
        vis[tx][ty][tf]=0;
        for(int i=1;i<=3;i++){   //直走 
            if(tf==0){             //写到一块太麻烦了不如复制粘贴 
                int tox=tx-i;
                int toy=ty;
                if(tox<1||b[tox][toy])    break; //一定要break 
                if(d[tox][toy][tf]>d[tx][ty][tf]+1){
                    d[tox][toy][tf]=d[tx][ty][tf]+1;
                    node tt;
                    tt.x=tox;tt.y=toy;tt.f=tf;
                    if(!vis[tox][toy][tf]){
                        q.push(tt);
                        vis[tox][toy][tf]=1;
                    }
                }
            }
            else if(tf==1){
                int tox=tx;
                int toy=ty+i;
                if(toy>mm||b[tox][toy]) break;//我一开始写的continue然后我的机器人就学会了闪现穿墙 
                if(d[tox][toy][tf]>d[tx][ty][tf]+1){
                    d[tox][toy][tf]=d[tx][ty][tf]+1;
                    node tt;
                    tt.x=tox;tt.y=toy;tt.f=tf;
                    if(!vis[tox][toy][tf]){
                        q.push(tt);
                        vis[tox][toy][tf]=1;
                    }
                }
            }
            else if(tf==2){
                int tox=tx+i;
                int toy=ty;
                if(tox>n+1||b[tox][toy]) break; //就是这个break让我浪费了1个小时 
                if(d[tox][toy][tf]>d[tx][ty][tf]+1){
                    d[tox][toy][tf]=d[tx][ty][tf]+1;
                    node tt;
                    tt.x=tox;tt.y=toy;tt.f=tf;
                    if(!vis[tox][toy][tf]){
                        q.push(tt);
                        vis[tox][toy][tf]=1;
                    }
                }
            }
            else if(tf==3){
                int tox=tx;
                int toy=ty-i;
                if(toy<0||b[tox][toy]) break;//罪魁祸首！！ 
                if(d[tox][toy][tf]>d[tx][ty][tf]+1){
                    d[tox][toy][tf]=d[tx][ty][tf]+1;
                    node tt;
                    tt.x=tox;tt.y=toy;tt.f=tf;
                    if(!vis[tox][toy][tf]){
                        q.push(tt);
                        vis[tox][toy][tf]=1;
                    }
                }
            }
        }
        for(int i,k=1;k<=3;k+=2){ //转向 
            i=(tf+k)%4; 
            if(i!=tf){
                if(d[tx][ty][i]>d[tx][ty][tf]+1){
                    d[tx][ty][i]=d[tx][ty][tf]+1;
                    node tt;
                    tt.x=tx;tt.y=ty;tt.f=i;
                    if(!vis[tx][ty][i]){
                        q.push(tt);
                        vis[tx][ty][i]=1;
                    }
                }
            }
        }    
    }
}
void debug(){    //调试的时候用的  
        for(int i=1;i<=n+1;i++){
        for(int j=0;j<=mm;j++){
            printf("%-3d",b[i][j]); //这样输出极其整齐 
        }
        cout<<endl;
    }
    cout<<sx<<" "<<sy<<" "<<ex<<" "<<ey<<" "<<endl;
    cout<<endl;
    for(int k=0;k<4;k++){
        for(int i=1;i<=n+1;i++){
            for(int j=0;j<=mm;j++){
                if(d[i][j][k]==INF) printf("%-3d",-1); //不然看的眼晕 
                else printf("%-3d",d[i][j][k]);    //我才不是强迫症 
            }
            cout<<endl;
        }
        cout<<endl;        
    }
}
int main(){
    cin>>n>>mm;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=mm;j++){
            cin>>m[i][j];
        }
    }
    memset(d,0x3f,sizeof(d));
    cin>>sx>>sy>>ex>>ey>>ch;
    sx++;ex++;        //emm…行和列有点错位 
    if(ch=='N') sf=0;
    else if(ch=='E') sf=1;
    else if(ch=='S') sf=2;
    else if(ch=='W') sf=3;
    for(int i=1;i<=n+1;i++){ //预处理:把方格图换成点图，不如每次判断很麻烦，50×50时间也不会慢很多，说不定还赚点 
        for(int j=0;j<=mm;j++){
            if(i==1||i==n+1||j==0||j==mm) b[i][j]=1;
            if(m[i][j]){
                b[i][j]=1;b[i][j-1]=1;b[i+1][j]=1;b[i+1][j-1]=1;
            }
        }
    }
    spfa();            //spfa 
//    debug();
    int minn=INF;    //找最小 
    for(int i=0;i<4;i++){
        minn=min(minn,d[ex][ey][i]);
    }
    if(minn==INF) cout<<-1<<endl; //咳咳 一开始忘写了 
    else cout<<minn<<endl;
}
```

---

## 作者：Excim (赞：1)

/\*一道比较简单的广搜题 适合练手 不过注意的地方比较多

终点一定是走出来的，不是转出来的。无需判断走到某点时的步数大小，因为是广搜，先走到一定步数最小

\*/
```cpp
#include<cstdio>
void read(int &y)//快速读入 
{
    y=0;char x=getchar();int f=1;
    while(x<'0'||x>'9')
    {
        if(x=='-') f=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9')
    {
        y=y*10+x-'0';
        x=getchar();
    }
    y*=f;
}
int b[55][55],v[55][55][5];
int qd[20005],qx[20005],qy[20005],qs[20005];//这就是队列啦。。。qx、qy是坐标，qd是方向，qs是已经走的步数 
int rx,ry,l,r;
int nx[6]={0,0,1,0,-1,0};
int ny[6]={0,1,0,-1,0,0};
char de[5];
void add(int x,int y,int d,int s)//向队列中添加元素 
{
    v[x][y][d]=1;
    qx[++r]=x;
    qy[r]=y;
    qd[r]=d;
    qs[r]=s+1;
}
int main()
{
    int n,m,x;
    read(n);read(m);
    for(int i=0;i<n;i++)//将格子图转换为点图，每个有障碍物的格子阻断了四个点 
    {
        for(int j=0;j<m;j++)
        {
            read(x);
            if(x==1)
            {
                b[i][j]=1;
                b[i+1][j]=1;
                b[i][j+1]=1;
                b[i+1][j+1]=1;
            }
        }
    }
    int sx,sy;
    read(sx);read(sy);read(rx);read(ry);
    if(sx==rx&&sy==ry)//特判一下起点与重点重合 
    {
        printf("0");
        return 0;
    }
    scanf("%s",de);
    if(de[0]=='E') qd[l]=1;
    if(de[0]=='S') qd[l]=2;
    if(de[0]=='W') qd[l]=3;
    if(de[0]=='N') qd[l]=4;
    qx[l]=sx;qy[l]=sy;//确定起始位置与方向 
    while(l<=r)
    {
//        printf("%d %d %d %d\n",qx[l],qy[l],qd[l],qs[l]);
//        输出中间结果，便于找错 
        for(int j=1;j<=3;j++)
        {
            int tx=qx[l]+nx[qd[l]]*j;
            int ty=qy[l]+ny[qd[l]]*j;
            if((tx<=0||tx>=n)||(ty<=0||ty>=m)) break;//越界 
            if(b[tx][ty]==1) break;//有障碍
            //break而不是continue的原因是不管是越界还是被阻挡，再往下走更多的步数也一定还是会有这样的问题 
            if(tx==rx&&ty==ry)//搜到终点，因为使用广搜，所以一定是最快到达 
            {
                printf("%d",qs[l]+1);
                return 0;
            }
            if(v[tx][ty][qd[l]]==0) add(tx,ty,qd[l],qs[l]);//首先判断此情况是否出现过，没出现过的加入队列 
        }
        int tl=qd[l]-1,tr=qd[l]+1;//枚举左转右转 
        if(tl==0) tl=4;
        if(tr==5) tr=1;
        if(v[qx[l]][qy[l]][tl]==0) add(qx[l],qy[l],tl,qs[l]);
        if(v[qx[l]][qy[l]][tr]==0) add(qx[l],qy[l],tr,qs[l]);
        l++;
    }
    printf("-1");
    return 0;
}
```

---

## 作者：king_xbz (赞：0)

2019年最后一道题 

这题是一个比较考察细节的广搜，本蒟蒻做了快2个小时

有几个点需要注意

1.记得更新初始朝向（如样例）不然50分+不过样例 

2.注意将格图存为点图

3.注意判断-1的情况（有20分） 

4.注意转向（宛如废话） 

注意这几点，ac不成问题 

20pt code：
```cpp
#include<bits/stdc++.h>
int main()
{
	std::cout<<-1;
 } 
 ```
 50pt code:
 ```cpp
 #include<bits/stdc++.h>
#define int long long
#define fread ios::sync_with_stdio
#define fint register int
#define p 4327823
#define h 201 

using namespace std;

int fx[4]={-1,1,0,0}; 
int fy[4]={0,0,-1,1};
int l[4]={3,2,0,1};
int r[4]={2,3,1,0};
int a[h*10][h*10];
bool vis[h][h][h];
int xa,ya,xb,yb;
char dirs;
int n,m;

struct node
{
	int x;
	int y;
	int tot;
	int dir;
};
node c;
queue <node>q;

inline int direct(char dir);
void bfs();

signed main()
{
	fread(false);
	cin>>n>>m;
	for(fint i=1;i<=n;i++)
	for(fint j=1;j<=m;j++)
	{
	cin>>a[i][j];
	if(a[i][j]==1)
	{
	a[i-1][j]=1;
    a[i][j-1]=1;
    a[i-1][j-1]=1;
    a[i][j]=1;
	}
}
    cin>>xa>>ya>>xb>>yb;
    c.x=xa;
    c.y=ya;
    q.push(c);
    //进队 
    cin>>dirs;
    direct(dirs);
    vis[c.y][c.y][c.dir]=1;
    bfs();
    cout<<"-1";
    exit(0);
}
inline int direct(char dirs)
{
	if(dirs=='W')
    c.dir=0;
    else
    if(dirs=='E')
    c.dir=1;
    else
    if(dirs=='N')
    c.dir=2;
    else
    if(dirs=='S')
    c.dir=3;
    return c.dir;
}

/*BFS代码*/ 
void bfs()
{
    while(!q.empty())
	{
		node now;
        now=q.front();
		q.pop();
        if(now.x==xb&&now.y==yb)
		{
            cout<<now.tot;
            exit(0);
        }
        node d;
        d=now;
        for(int i=1;i<=3;i++)
		{
            d.x+=fx[now.dir];
			d.y+=fy[now.dir];
            if(d.x<1||d.y<1||d.x>=n||d.y>=m||a[d.x][d.y]!=0)
			break;
            if(!vis[d.x][d.y][d.dir])
            {
            vis[d.x][d.y][d.dir]=1;
            d.tot=now.tot+1;
            q.push(d);
        }
    }
        node e;
        e=now;
		e.tot=now.tot+1;
        e.dir=l[now.dir];
        if(!vis[e.x][e.y][e.dir])
		{
            vis[e.x][e.y][e.dir]=1;
            q.push(e);
        }
        e.dir=r[now.dir];
        if(!vis[e.x][e.y][e.dir])
		{
            vis[e.x][e.y][e.dir]=1;
            q.push(e);
        }
    }
}
```

朝向
```cpp
inline int direct(char dirs)
{
	if(dirs=='W')
    c.dir=0;
    else
    if(dirs=='E')
    c.dir=1;
    else
    if(dirs=='N')
    c.dir=2;
    else
    if(dirs=='S')
    c.dir=3;
    return c.dir;
    //确定初始朝向 
}
```
广搜
```cpp
while(!q.empty())
	{
		node now;
        now=q.front();
		q.pop();
        if(now.x==xb&&now.y==yb)
		{
            cout<<now.tot;
            exit(0);//到达目标点就输出当前总时间 
        }
        node d;//d表示下一步 
        d=now;
        for(int i=1;i<=3;i++)
		{
            d.x+=fx[now.dir];
			d.y+=fy[now.dir];
            if(d.x<1||d.y<1||d.x>=n||d.y>=m||a[d.x][d.y]!=0)
			break;
			//到边界就退出 
            if(!vis[d.x][d.y][d.dir])
            {
            vis[d.x][d.y][d.dir]=1;
            d.tot=now.tot+1;
            q.push(d);
            //如果未走过就更新时间并进行下一层 
        }
    }
        node e;
        e=now;
		e.tot=now.tot+1;
        e.dir=l[now.dir];
        if(!vis[e.x][e.y][e.dir])
		{
            vis[e.x][e.y][e.dir]=1;
            q.push(e);
			//向左转 
        }
        e.dir=r[now.dir];
        if(!vis[e.x][e.y][e.dir])
		{
            vis[e.x][e.y][e.dir]=1;
            q.push(e);
			//向右转 
        }
    }
   ```
   完整代码：
   ```cpp
   #include<bits/stdc++.h>
#define int long long
#define fread ios::sync_with_stdio
#define fint register int
#define p 4327823
#define h 201
//头文件及宏优化 

using namespace std;

int fx[4]={0,0,-1,1};
//横坐标变化  
int fy[4]={-1,1,0,0};
//纵坐标变化 
int l[4]={3,2,0,1};
//左转走法 
int r[4]={2,3,1,0};
//右转走法 
int a[h*10][h*10];
//邻接矩阵 
bool vis[h][h][h];
//三维分别表示x，y，dir 
int xa,ya,xb,yb;
char dirs;
int n,m;

struct node
{
	int x;
	//横坐标 
	int y;
	//纵坐标 
	int tot;
	//总时间 
	int dir;
	//当前朝向 
};
node c;
//结构体封装坐标及步数 
queue <node>q;
//队列 

inline int direct(char dirs);
void bfs();

signed main()
{
	fread(false);
	cin>>n>>m;
	for(fint i=1;i<=n;i++)
	for(fint j=1;j<=m;j++)
	{
	cin>>a[i][j];
	if(a[i][j]==1)
	{
	a[i-1][j]=1;
    a[i][j-1]=1;
    a[i-1][j-1]=1;
    a[i][j]=1;
	}
	//将格图存为点图（将周围四个点赋值1） 
}
    cin>>xa>>ya>>xb>>yb;
    c.x=xa;
    c.y=ya;
    //输入初始位置及目标位置，并用结构体存 
    cin>>dirs;
    direct(dirs);
    //更新初始方向 
    vis[c.y][c.y][c.dir]=1;
    //初始化起点 
    q.push(c);
    //进队 
    bfs();
    //广搜 
    cout<<"-1";
    //如果没正常退出，就输出-1 
    exit(0);
}
inline int direct(char dirs)
{
	if(dirs=='W')
    c.dir=0;
    else
    if(dirs=='E')
    c.dir=1;
    else
    if(dirs=='N')
    c.dir=2;
    else
    if(dirs=='S')
    c.dir=3;
    return c.dir;
    //确定初始朝向 
}

/*BFS代码*/ 
void bfs()
{
    while(!q.empty())
	{
		node now;
        now=q.front();
		q.pop();
        if(now.x==xb&&now.y==yb)
		{
            cout<<now.tot;
            exit(0);//到达目标点就输出当前总时间 
        }
        node d;//d表示下一步 
        d=now;
        for(int i=1;i<=3;i++)
		{
            d.x+=fx[now.dir];
			d.y+=fy[now.dir];
            if(d.x<1||d.y<1||d.x>=n||d.y>=m||a[d.x][d.y]!=0)
			break;
			//到边界就退出 
            if(!vis[d.x][d.y][d.dir])
            {
            vis[d.x][d.y][d.dir]=1;
            d.tot=now.tot+1;
            q.push(d);
            //如果未走过就更新时间并进行下一层 
        }
    }
        node e;
        e=now;
		e.tot=now.tot+1;
        e.dir=l[now.dir];
        if(!vis[e.x][e.y][e.dir])
		{
            vis[e.x][e.y][e.dir]=1;
            q.push(e);
			//向左转 
        }
        e.dir=r[now.dir];
        if(!vis[e.x][e.y][e.dir])
		{
            vis[e.x][e.y][e.dir]=1;
            q.push(e);
			//向右转 
        }
    }
}
//完结撒花 
```
最后，祝大家新年快乐

2020 rp++ 

---

## 作者：jins3599 (赞：0)

简单bfs.

就是在处理地图的时候需要注意一下，把方格图转化为点图。

也不是很困难，转化为点图后$m,n$会减一，然后对应的之前的障碍会影响到点图的哪些位置，用笔画一画即可。

最后就是BFS部分，我们需要记录每个点的位置，方向，步数，然后开开一个$vis$进行去重，$n$很小，用数组可以开的下。

最后有一个坑点，导致我调了半个多小时，在判断机器人的下一个点是否可走时，我们要从第一步开始判断，一旦不合法直接`break`，后面的也不能再考虑，因为机器人无法跳过障碍到下一个合法的格子...(好菜

然后就是代码了，实现还是比较容易。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 55;
bool vis[N][N][5];
int n , m;
int pre[N][N] , g[N][N];
int stax , stay , stadir;
int endx , endy;
// 1N 2S 3W 4E 

void Pre() {
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= n ; j ++ )
			if(pre[i][j]) g[i - 1][j - 1] = g[i - 1][j] = g[i][j - 1] = g[i][j] = 1;
	n--;m--;
}
queue <int> q;
void push(int x , int y , int dir , int dep) {
	q.push(x);q.push(y);q.push(dir);q.push(dep);
}

bool check(int x , int y ) {
	if(x < 1 || x > n || y < 1 || y > m) return false; 
	if(g[x][y] == 1) return false;
	return true;
}

void Bfs() {
	vis[stax][stay][stadir] = 1;
	push(stax,stay,stadir,0);
	while(!q.empty()) {
		int nowx = q.front(); q.pop();
		int nowy = q.front(); q.pop();
		int nowdir = q.front(); q.pop();
		int nowdep = q.front(); q.pop();
		if(nowx == endx && nowy == endy) {printf("%d\n" , nowdep); exit(0);}
		if(nowdir==1 || nowdir==2){
			if(!vis[nowx][nowy][3]) vis[nowx][nowy][3] = 1, push(nowx,nowy,3,nowdep+1);
			if(!vis[nowx][nowy][4]) vis[nowx][nowy][4] = 1, push(nowx,nowy,4,nowdep+1);
		} else {
			if(!vis[nowx][nowy][1]) vis[nowx][nowy][1] = 1 ,push(nowx,nowy,1,nowdep+1);
			if(!vis[nowx][nowy][2]) vis[nowx][nowy][2] = 1 , push(nowx,nowy,2,nowdep+1);
		}
		if(nowdir == 1) {
			for(int i = 1 ; i <= 3; i ++) {
				if(!check(nowx - i , nowy)) break;
				if(!vis[nowx-i][nowy][1]) vis[nowx-i][nowy][1]=1,push(nowx-i,nowy,1,nowdep+1); 
			}
		} else if(nowdir == 2) {
			for(int i = 1 ;i <= 3 ; i++) {
				if(!check(nowx + i , nowy)) break;
				if(!vis[nowx+i][nowy][2]) vis[nowx+i][nowy][2]=1,push(nowx+i,nowy,2,nowdep+1);
			}
			
		} else if(nowdir==3) {
			for(int i = 1 ; i <= 3 ; i ++) {
				if(!check(nowx , nowy - i)) break;
				if(!vis[nowx][nowy-i][3]) vis[nowx][nowy-i][3]=1,push(nowx,nowy-i,3,nowdep+1);
			}
			
		} else {
			for(int i = 1; i <= 3 ;i ++) {
				if(!check(nowx , nowy + i)) break;
				if(!vis[nowx][nowy+i][4]) vis[nowx][nowy+i][4]=1,push(nowx,nowy+i,4,nowdep+1);
			}
			
		}
	}
}

int main () {
	scanf("%d%d" ,&n ,&m);
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= m ;j ++) scanf("%d" , &pre[i][j]);
	char x;
	cin >> stax >> stay >> endx >> endy >> x; 
	if(x == 'N') stadir = 1; if(x == 'S') stadir = 2; if(x == 'W') stadir = 3; if(x == 'E') stadir = 4;
	Pre();
	Bfs(); 	 puts("-1");
	return 0;
}
```

---

## 作者：BrandonSoong (赞：0)

========================================================

=======================开始分割线========================

========================================================

#### 众所周知

```
广搜和深搜俩好兄弟是蒟蒻们的好朋友
它们乐于助人，喜欢化解别人爆零的尴尬局面

但是像我这样的 大蒟蒻 仍然会疯狂爆零
在反复推敲之后决定一鼓作气认真学习BFS与DFS
```


========================================================

=====================真正开始分割线======================

========================================================

**那就先对BFS做一些小小的总结**

### 1、基本步骤
- 1> 初始化入队
- 2> 结束条件：q.empty()==1
- 3> u = q.front();
- 4> q.pop();
- 5> 判断是否到达终点（到达则结束）
- 6> 更新下一层，入队新节点
### 2、存储
我们一般使用 **queue**< T > 存储搜索状态，步数等信息一般不存储在**queue**里面，而是单独存储。
### 3、剪枝
也就是常说的去除已经出现过的情况，一般有两种方式实现：

- 1> 使用**STL**里面的**map**< **Ta** , **Tb** >来存储，由于使用**map**存储自定义**struct**的时候非常麻烦，~~亲身体验，由于**map本质红黑树**性质复杂，自己改了5h也没弄好~~，这种方式只有在存储对象是**string**的时候，使用map存储才凸显出其优势，对应链接[[字串变化]](https://www.luogu.org/record/25655144)。

- 2> 其他情况下一般使用数组存储，类似于Dijkstra里面的**dis**数组，比如一个状态涉及 **x,y,z** 三个变量，那么 dis 数组长这样： **dis[x][y][z]**，对应的值是到达这个状态的最小步数，转移的时候只有当 **dis[x][y][z] == initialized_value** 的时候才转移，对应链接[[机器人搬重物]](https://www.luogu.org/record/25675310)。
### 4、优化
当**开始状态和结束状态很单一**而且**数据范围较大**且**每一种状态的转移情况很多**的时候，我们往往会使用 **双向BFS** 来优化，~~优化的还不少~~

[**超详细讲解：**](https://www.luogu.org/blog/tolearnbetter/solution-p1032)

****
**这道题的AC code：**
```cpp
#include<bits/stdc++.h>
#define maxn 56
using namespace std;
bool m[maxn][maxn];
int N,M,ex,ey,dis[maxn][maxn][5];
int st[6][3]={
	{0,0,0},
	{0,-1,0},
	{0,0,1},
	{0,1,0},
	{0,0,-1},
};
struct status{
	int x,y,dir;
}a;
queue<status> q;
inline int qr()
{
	int sum=0;
	char j=0;
	while(!isdigit(j))j=getchar();
	while(isdigit(j)){sum=(sum<<1)+(sum<<3)+(j^48);j=getchar();}
	return sum;
}
inline void readin()
{
	N=qr();
	M=qr();
	for(int i=1;i<=N;i++)
	for(int j=1;j<=M;j++)
	m[i][j]=qr();
	a.x=qr();
	a.y=qr();
	ex=qr();
	ey=qr();
	char j;
	cin>>j;
	if(j=='N')a.dir=1;
	if(j=='E')a.dir=2;
	if(j=='S')a.dir=3;
	if(j=='W')a.dir=4;
}
inline bool check(status x)
{
	if(x.x<1||x.y<1||x.x>=N||x.y>=M||m[x.x][x.y]||m[x.x][x.y+1]||m[x.x+1][x.y]||m[x.x+1][x.y+1])return 0;
	return 1;
}
inline int BFS()
{
	memset(dis,0x3f,sizeof(dis));
	dis[a.x][a.y][a.dir]=0;
	int maxx=dis[0][0][0];
	q.push(a);
	while(!q.empty())
	{
		status u=q.front(),tr;
		if(u.x==ex&&u.y==ey)return dis[u.x][u.y][u.dir];
		int s=dis[u.x][u.y][u.dir],di=u.dir;
		q.pop();
		
		//++
		tr=u;
		tr.dir++;
		if(tr.dir==5)tr.dir=1;
		if(dis[tr.x][tr.y][tr.dir]==maxx)
		{
			dis[tr.x][tr.y][tr.dir]=s+1;
			q.push(tr);
		}
		
		//--
		tr=u;
		tr.dir--;
		if(tr.dir==0)tr.dir=4;
		if(dis[tr.x][tr.y][tr.dir]==maxx)
		{
			dis[tr.x][tr.y][tr.dir]=s+1;
			q.push(tr);
		}
		
		//~~
		tr=u;
		tr.dir+=2;
		if(tr.dir>4)tr.dir-=4;
		if(dis[tr.x][tr.y][tr.dir]==maxx)
		{
			dis[tr.x][tr.y][tr.dir]=s+2;
			q.push(tr);
		}
		
		//Creep
		tr=u;
		tr.x+=st[di][1];
		tr.y+=st[di][2];
		if(check(tr))
		{
			if(dis[tr.x][tr.y][tr.dir]==maxx)
			{
				dis[tr.x][tr.y][tr.dir]=s+1;
				q.push(tr);
			}
			
			//Walk
			tr=u;
			tr.x+=2*st[di][1];
			tr.y+=2*st[di][2];
			if(check(tr))
			{
				if(dis[tr.x][tr.y][tr.dir]==maxx)
				{
					dis[tr.x][tr.y][tr.dir]=s+1;
					q.push(tr);
				}
				
				//Run
				tr=u;
				tr.x+=3*st[di][1];
				tr.y+=3*st[di][2];
				if(check(tr))
				{
					if(dis[tr.x][tr.y][tr.dir]==maxx)
					{
						dis[tr.x][tr.y][tr.dir]=s+1;
						q.push(tr);
					}
				}
			}
		}
	}
	return -1;
} 
int main()
{
	readin();
	printf("%d",BFS());
	return 0;
}
```
****

========================================================

=======================结束分割线========================

========================================================
Thx for watching with patience!

---

## 作者：slz1 (赞：0)

坑爹的BFS题。一是格子图要转换成点图，刚开始没注意，居然也过了输入输出样例，得40分花了一个下午都查找不出原因，最后偷瞄了一眼别人的题解，瞬间崩溃。二是方向的处理；三是边界处理，机器人不能在边界上面移动。

其实广搜的题相对来说没深搜那么抽象，只要严格按题目要求，只要队列不空，取出队头，如果不是目标节点，把可以访问的点存入队列就可以了。

直接上代码：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int map[60][60]; //棋盘 
int rmi[60][60][4]; //走到[x,y]且面朝z的时候，最少需要多少步 
int bx, by, dx, dy, n, m; //出发位置和目标位置 
struct vertex
{
  int x,y,z;  //横、纵、方向  
}v[100010];
char face;   //朝向 
int main()
{
  //freopen("P1126.in","r",stdin);
  int head=0, tail=0;
  cin>>n>>m;
  for(int i=0; i<n; i++)    //格子图转化为点图。i,j从0开始，边界落在0、n、m 
	for(int j=0; j<m; j++)  //(1,1)到(n-1,m-1)可以通行 
	{
	  int x;
	  cin>>x;
	  if(x) map[i][j]=map[i][j+1]=map[i+1][j]=map[i+1][j+1]=1; 
	} 
  cin>>bx>>by>>dx>>dy>>face;
  memset(rmi, 127/3, sizeof(rmi));
  v[head].x = bx;
  v[head].y = by;
  switch(face)    //好久没用switch了，复习一下。方向数字化 
  {
  	case 'E': v[head].z=0; break;
  	case 'S': v[head].z=1; break;
  	case 'W': v[head].z=2; break;
  	case 'N': v[head].z=3; break;
  }
  rmi[v[head].x][v[head].y][v[head].z]=0; //出发点入队列，走到这是第0步 
  while(head<=tail)
  {
  	int xm=v[head].x, ym = v[head].y, zm = v[head].z, xt, yt;
  	if(xm==dx && ym==dy)  //找到目标，直接输出。BFS首先找到的一定是最优的 
	{
	  cout<<rmi[xm][ym][zm];
	  return 0; 
	}
	for(int i=1; i<=3; i++)  //判断直走1、2、3步是否可行，可行就入队列。 
	{             
	  xt=xm, yt=ym;
      switch(zm)  //方向不同，移动后的位置算法不同 
      {
  	    case 0: yt+=i; break;
  	    case 1: xt+=i; break;
  	    case 2: yt-=i; break;
  	    case 3: xt-=i; break;
      }  
	  if(xt>=1 && xt<n && yt>=1 && yt<m && map[xt][yt]==0) //可以走。注意判断边界 
	  {//从队头走到这里是rmi[xm][ym][zm]+1步，如果比以前的优，就“走”。
	  	if(rmi[xt][yt][zm]>rmi[xm][ym][zm]+1)   
	  	{
	  	  tail++;
	  	  v[tail].x = xt;
	  	  v[tail].y = yt;
	  	  v[tail].z = zm;
	  	  rmi[xt][yt][zm]=rmi[xm][ym][zm]+1;
		}
	  }
	  else  //如果某一步不能走，那么同方向更长的距离显然不能走，所以直接break。
	    break;
	}
	if(rmi[xm][ym][zm+1%4]>rmi[xm][ym][zm]+1)  //判断转向，转向的时候不移动，不判断边界。 
	{
	  tail++; v[tail].x=xm; v[tail].y=ym; v[tail].z=(zm+1)%4; 
	  rmi[xm][ym][(zm+1)%4] = rmi[xm][ym][zm]+1;
	}
    if(rmi[xm][ym][(zm+3)%4]>rmi[xm][ym][zm]+1)  //另一个方向的转向 
    {
      tail++; v[tail].x=xm; v[tail].y=ym; v[tail].z=(zm+3)%4;
	  rmi[xm][ym][(zm+3)%4] = rmi[xm][ym][zm]+1;	
	}
	head++;
  }
  cout<<-1;
  return 0;
} 
```


---

## 作者：YZL11111 (赞：0)

题目链接：https://www.luogu.org/problem/P1126

## 【题目描述】
机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径1.6米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个N*M的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动1步（Creep）；向前移动2步（Walk）；向前移动3 步（Run）；向左转（Left）；向右转（Right）。每个指令所需要的时间为1 秒。请你计算一下机器人完成任务所需的最少时间。

## 【输入格式】
第一行为两个正整数N,M(N,M≤50)，下面N行是储藏室的构造，0表示无障碍，1表示有障碍，数字之间用一个空格隔开。接着一行有4个整数和1个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东E，南S，西W，北N），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。

## 【输出格式】
一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出-1。

![](https://cdn.luogu.com.cn/upload/pic/39.png)

## 【解题思路】
一道很简单的广搜题目，但却暴露出了我的很多问题，首先，广度优先搜索是从当前节点向其子节点逐个搜索，所以在搜索时不能越过其子节点而直接访问孙子节点，这是不合法的，在本题中，一共有向前移动1步，向前移动2步，向前移动3 步，向左转，向右转五种操作，所以每个节点应该只允许有5个子节点，再将子节点入队即可。

这题有点类似于模拟题，要一步一步想清楚，而且在最开始一定要注意要将网格图化为点图，否则会有大问题。

其余看注释。

## 【AC代码】
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
typedef long long ll;
using namespace std;
int map[55][55];
int step[55][55][5];  //记录时间
bool vis[55][55][5];
int n, m, a, b, c, d, s;
typedef struct node
{
	int x, y;
	int s;
	node(int mx, int my, char ms) :x(mx), y(my), s(ms) {};
}node;
void bfs()  //常规bfs使其分别完成5种操作
{
	queue<node> que;
	que.push(node(a, b, s));
	vis[a][b][s] = true;
	while (!que.empty())
	{
		node u = que.front();
		if (u.x == c && u.y == d)
		{
			printf("%d\n", step[u.x][u.y][u.s]);
			return;
		}
		que.pop();
		if (u.s == 1)
		{
			if (!vis[u.x][u.y][4])
			{
				vis[u.x][u.y][4] = true;
				step[u.x][u.y][4] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y, 4));
			}
			if (!vis[u.x][u.y][2])
			{
				vis[u.x][u.y][2] = true;
				step[u.x][u.y][2] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y, 2));
			}
			if (u.y + 1 <= m && !map[u.x][u.y + 1] && !vis[u.x][u.y + 1][1])
			{
				vis[u.x][u.y + 1][u.s] = true;
				step[u.x][u.y + 1][u.s] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y + 1, 1));
			}
			if (u.y + 2 <= m && !map[u.x][u.y + 2] && !map[u.x][u.y + 1] && !vis[u.x][u.y + 2][1])
			{
				vis[u.x][u.y + 2][u.s] = true;
				step[u.x][u.y + 2][u.s] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y + 2, 1));
			}
			if (u.y + 3 <= m && !map[u.x][u.y + 1] && !map[u.x][u.y + 2] && !map[u.x][u.y + 3] && !vis[u.x][u.y + 3][1])
			{
				vis[u.x][u.y + 3][u.s] = true;
				step[u.x][u.y + 3][u.s] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y + 3, 1));
			}
		}
		if (u.s == 2)
		{
			if (!vis[u.x][u.y][1])
			{
				vis[u.x][u.y][1] = true;
				step[u.x][u.y][1] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y, 1));
			}
			if (!vis[u.x][u.y][3])
			{
				vis[u.x][u.y][3] = true;
				step[u.x][u.y][3] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y, 3));
			}
			if (u.x + 1 <= n && !map[u.x + 1][u.y] && !vis[u.x + 1][u.y][2])
			{
				vis[u.x + 1][u.y][2] = true;
				step[u.x + 1][u.y][2] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x + 1, u.y, 2));
			}
			if (u.x + 2 <= n && !map[u.x + 2][u.y] && !map[u.x + 1][u.y] && !vis[u.x + 2][u.y][2])
			{
				vis[u.x + 2][u.y][2] = true;
				step[u.x + 2][u.y][2] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x + 2, u.y, 2));
			}
			if (u.x + 3 <= n && !map[u.x + 1][u.y] && !map[u.x + 2][u.y] && !map[u.x + 3][u.y] && !vis[u.x + 3][u.y][2])
			{
				vis[u.x + 3][u.y][2] = true;
				step[u.x + 3][u.y][2] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x + 3, u.y, 2));
			}
		}
		if (u.s == 3)
		{
			if (!vis[u.x][u.y][4])
			{
				vis[u.x][u.y][4] = true;
				step[u.x][u.y][4] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y, 4));
			}
			if (!vis[u.x][u.y][2])
			{
				vis[u.x][u.y][2] = true;
				step[u.x][u.y][2] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y, 2));
			}
			if (u.y - 1 > 1 && !map[u.x][u.y - 1] && !vis[u.x][u.y - 1][3])
			{
				vis[u.x][u.y - 1][3] = true;
				step[u.x][u.y - 1][3] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y - 1, 3));
			}
			if (u.y - 2 > 1 && !map[u.x][u.y - 2] && !map[u.x][u.y - 1] && !vis[u.x][u.y - 2][3])
			{
				vis[u.x][u.y - 2][3] = true;
				step[u.x][u.y - 2][3] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y - 2, 3));
			}
			if (u.y - 3 > 1 && !map[u.x][u.y - 1] && !map[u.x][u.y - 2] && !map[u.x][u.y - 3] && !vis[u.x][u.y - 3][3])
			{
				vis[u.x][u.y - 3][3] = true;
				step[u.x][u.y - 3][3] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y - 3, 3));
			}
		}
		if (u.s == 4)
		{
			if (!vis[u.x][u.y][3])
			{
				vis[u.x][u.y][3] = true;
				step[u.x][u.y][3] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y, 3));
			}
			if (!vis[u.x][u.y][1])
			{
				vis[u.x][u.y][1] = true;
				step[u.x][u.y][1] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x, u.y, 1));
			}
			if (u.x - 1 > 1 && !map[u.x - 1][u.y] && !vis[u.x - 1][u.y][4])
			{
				vis[u.x - 1][u.y][4] = true;
				step[u.x - 1][u.y][4] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x - 1, u.y, 4));
			}
			if (u.x - 2 > 1 && !map[u.x - 2][u.y] && !map[u.x - 1][u.y] && !vis[u.x - 2][u.y][4])
			{
				vis[u.x - 2][u.y][4] = true;
				step[u.x - 2][u.y][4] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x - 2, u.y, 4));
			}
			if (u.x - 3 > 1 && !map[u.x - 3][u.y] && !map[u.x - 2][u.y] && !map[u.x - 1][u.y] && !vis[u.x - 3][u.y][4])
			{
				vis[u.x - 3][u.y][4] = true;
				step[u.x - 3][u.y][4] = step[u.x][u.y][u.s] + 1;
				que.push(node(u.x - 3, u.y, 4));
			}
		}
	}
	printf("-1\n");  //如果没有返回则说明不能到达终点
}
int main()
{
	scanf("%d%d", &n, &m);
	int t;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			scanf("%d", &t);
			if (t == 1)
				map[i][j] = map[i + 1][j] = map[i][j + 1] = map[i + 1][j + 1] = 1;  //将网图化为点图
		}
	}
	scanf("%d%d%d%d", &a, &b, &c, &d);
	char p;
	scanf(" %c", &p);
	switch (p)  //用1,2,3,4分别代表东南西北方便记忆
	{
	case 'E':s = 1; break;
	case 'S':s = 2; break;
	case 'W':s = 3; break;
	case 'N':s = 4; break;
	default:break;
	}
	a++, b++, c++, d++; //化为点图后更新起点终点坐标，注意n和m不用更新因为机器人有面积，不能到达边缘点
	bfs();
	return 0;
}
```


---

## 作者：泛在羽衣精 (赞：0)

其实这题思路挺~~清晰的~~，结果卡了我半天的剪枝…果然还是鄙人太菜

```c
/*************************************************************************
 > FileName:
 > Author:      Lance
 > Mail:        lancelot_hcs@qq.com
 > Date:        9102.1.8
 > Description:
 ************************************************************************/
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>
#include <bitset>
#include <string>
#include <cmath>
#include <sstream>
using namespace std;
typedef long long ll;
const double pi = acos(-1.0);
const int eps = 1e-10;
const int mod = 1e9 + 7;
const int INF = 0x3f3f3f3f;//int2147483647//ll9e18//unsigned ll 1e19
const int maxn = 55;

int dir0[4][3][2] = {{{1, 0}, {2, 0}, {3, 0}}, {{0, 1}, {0, 2}, {0, 3}}, {{-1, 0}, {-2, 0}, {-3, 0}}, {{0, -1}, {0, -2}, {0, -3}}};
int maze1[maxn][maxn], maze[maxn][maxn];
bool vis[4][maxn][maxn];
int n, m, starx, stary, stard, aimx, aimy;
string strl = "123";
char c;

struct node
{
    int x, y;
    int dir1, step;
    node(int _x, int _y, int _dir1, int _step) : x(_x), y(_y), dir1(_dir1), step(_step) {}
};

bool if_print(int x, int y, int s)
{
    if(x == aimx && y == aimy)
    {
        printf("%d\n", s);
        return 1;
    }
    return 0;
}

bool test(int x, int y, int dir)
{
    return x > 0 && y > 0 && x < n && y < m && !maze[x][y] && !vis[dir][x][y] ? 1 : 0;
}
/*0123代表senw*/
void bfs(int x, int y, int dir, int step)
{
    queue <node> q;
    q.push(node(x, y, dir, step));
    vis[dir][x][y] = 1;
    while(!q.empty())
    {
        node top = q.front();
        if (top.x == aimx && top.y == aimy)
        {
            printf("%d\n", top.step);
            //            cout << top.str << endl;
            return;
        }
        q.pop();
        int tx, ty, tdir = top.dir1, tstep = top.step + 1;
        for (int i = 0 ; i < 3; i++)
        {
            if (i == 0)
            {
                if (test(top.x + dir0[tdir][i][0], top.y + dir0[tdir][i][1], tdir))
                {

                    tx = top.x + dir0[tdir][i][0];
                    ty = top.y + dir0[tdir][i][1];
                    vis[tdir][tx][ty] = 1;
                    q.push(node(tx, ty, tdir, tstep));
                    if(if_print(tx, ty, tstep))
                        return;
                }
            }
            if (i == 1)
            {
                if (test(top.x + dir0[tdir][i][0], top.y + dir0[tdir][i][1], tdir) && !maze[top.x + dir0[tdir][i - 1][0]][top.y + dir0[tdir][i - 1][1]])
                {

                    tx = top.x + dir0[tdir][i][0];
                    ty = top.y + dir0[tdir][i][1];
                    vis[tdir][tx][ty] = 1;
                    q.push(node(tx, ty, tdir, tstep));
                    if(if_print(tx, ty, tstep))
                        return;
                }
            }
            else
            {
                if (test(top.x + dir0[tdir][i][0], top.y + dir0[tdir][i][1], tdir) && !maze[top.x + dir0[tdir][i - 1][0]][top.y + dir0[tdir][i - 1][1]] && !maze[top.x + dir0[tdir][i - 2][0]][top.y + dir0[tdir][i - 2][1]])
                {

                    tx = top.x + dir0[tdir][i][0];
                    ty = top.y + dir0[tdir][i][1];
                    vis[tdir][tx][ty] = 1;
                    q.push(node(tx, ty, tdir, tstep));
                    if(if_print(tx, ty, tstep))
                        return;
                }
            }

        }
        vis[tdir][top.x][top.y] = 1;
        if (tdir == 3)
        {

            if(!vis[tdir - 1][top.x][top.y])
            {
                q.push(node(top.x, top.y, tdir - 1, tstep));
                vis[tdir - 1][top.x][top.y] = 1;
            }

            if(!vis[0][top.x][top.y])
            {
                q.push(node(top.x, top.y, 0, tstep));
                vis[0][top.x][top.y] = 1;
            }

        }
        else if(tdir == 0)
        {
            if(!vis[tdir + 1][top.x][top.y])
            {
                q.push(node(top.x, top.y, tdir + 1, tstep));
                vis[tdir + 1][top.x][top.y] = 1;
            }

            if(!vis[3][top.x][top.y])
            {
                q.push(node(top.x, top.y, 3, tstep));
                vis[3][top.x][top.y] = 1;
            }

        }
        else
        {
            if(!vis[tdir + 1][top.x][top.y])
            {
                q.push(node(top.x, top.y, tdir + 1, tstep));
                vis[tdir + 1][top.x][top.y] = 1;
            }

            if(!vis[tdir - 1][top.x][top.y])
            {
                q.push(node(top.x, top.y, tdir - 1, tstep));
                vis[tdir - 1][top.x][top.y] = 1;
            }

        }
    }
    puts("-1");
    return;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            scanf("%d", &maze1[i][j]);
        }
    }
    for (int i = 0 ; i < n ; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if(maze1[i][j])
            {
                maze[i][j] = 1;
                maze[i + 1][j] = 1;
                maze[i][j + 1] = 1;
                maze[i + 1][j + 1] = 1;
            }
        }
    }
    scanf("%d%d%d%d %c", &starx, &stary, &aimx, &aimy, &c);
    if (c == 'S')/*0123代表senw*/
        stard = 0;
    else if(c == 'E')
        stard = 1;
    else if(c == 'N')
        stard = 2;
    else
        stard = 3;
    bfs(starx, stary, stard, 0);
    return 0;
}
```

---

## 作者：DeltaVi (赞：0)

	建立链表

	建立标记数组（几种状态用几维）

	向链表加第一个元素

	标记第一个元素

	While(不为空){	
   	取出队首
	判断队首是不是目标元素
	所有与队首相邻且为被标记的点进队列(
		1，判断出界
		2，判断有无障碍
		3，判断是否走过
	)
	标记其为已访问
}

#### 之前一直通不过是：
1）走步数问题，中间断了应该直接break;

2）边界处理，点较为麻烦

3）当起点和终点一样时，没有比较（可以出队比较，而不是入队比较）

4）加上方向这个状态变成三维数组

（这里方向用的map,类是一样的但里面的成员作用略有不同）

用的是JAVA

第一次发题解，给自己留个笔记*-*
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

public class P1126 {
	static class Pos{
		int x;
		int y;
		char f;
		int stap;
		public Pos(int x,int y,char f,int s){
			this.x = x;
			this.y = y;
			this.f = f;
			this.stap = s;
		}
	}
	
	public static void main(String[] args) throws IOException {
		StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		int n=(int)in.nval;
		in.nextToken();
		int m = (int) in.nval;
		int[][] map = new int[n][m];
		for(int i = 0; i < n; i++){
			for(int j = 0; j < m ; j++){
				in.nextToken();
				map[i][j] = (int) in.nval;
			}
		}
		LinkedList<Pos> list = new LinkedList<Pos>();
		in.nextToken();
		int startx = (int) in.nval;
		in.nextToken();
		int starty = (int) in.nval;
		in.nextToken();
		int endx = (int) in.nval;
		in.nextToken();
		int endy = (int) in.nval;
		in.nextToken();
		if(startx == endx && starty == endy){
			System.out.println("0");
			return;
		}
		char flag = in.sval.charAt(0);
		
		//方向
		Map<Character,Pos> farr = new HashMap<Character,Pos>();
		farr.put('N', new Pos(-1,0,'S',0));
		farr.put('S', new Pos(1,0,'N',1));
		farr.put('W', new Pos(0,-1,'E',2));
		farr.put('E', new Pos(0,1,'W',3));
		//记录，防止重复，剪枝
		int[][][] book1 = new int[n][m][4];
		//初始化第一个
		list.add(new Pos(startx,starty,flag,0));
		book1[startx][starty][farr.get(flag).stap] = 1;
		//开始检索
		while(!list.isEmpty()){
			Pos item = list.poll();
			//行走指令
			int count = item.stap + 1;
			int i = 0;
			while(++i <= 3){
				Pos temf = farr.get(item.f);
				int temx = item.x + temf.x * i;
				int temy = item.y + temf.y * i;
				//判断出界
				if(temx < 1||temx >= n ||temy < 1|| temy >= m)
					continue;
				//判断有无断点
				if(map[temx-1][temy] == 1||map[temx-1][temy-1] == 1||map[temx][temy] == 1||map[temx][temy-1] == 1)
					break;
				//判断是否到达终点
				if(temx == endx && temy == endy){
					System.out.println(count);
					return;
				}
				int f1 = farr.get(item.f).stap;
				//判断是否走过，剪枝,是否能到达
				if(book1[temx][temy][f1] == 0){
					//标记走过
					book1[temx][temy][f1] = 1;
					list.add(new Pos(temx,temy,item.f,count));
				}
			}
			//转向指令
			Pos temf = farr.get(item.f);
			char c1 = temf.f;
			char c2 = item.f;
			if(c1 != 'N' && c2 != 'N'){
				if(book1[item.x][item.y][0] != 1){
					book1[item.x][item.y][0] = 1;
					list.add(new Pos(item.x,item.y,'N',count));
				}
				if(book1[item.x][item.y][1] != 1){
					book1[item.x][item.y][1] = 1;
					list.add(new Pos(item.x,item.y,'S',count));
				}
			}
			if(c1 != 'W' && c2 != 'W'){
				if(book1[item.x][item.y][2] != 1){
					book1[item.x][item.y][2] = 1;
					list.add(new Pos(item.x,item.y,'W',count));
				}
				if(book1[item.x][item.y][3] != 1){
					book1[item.x][item.y][3] = 1;
					list.add(new Pos(item.x,item.y,'E',count));	
				}
			}
		}
		System.out.println("-1");
	}
}

```


---

## 作者：RayI_ovo (赞：0)

题目本身就是广度搜索都训练

难度并不高，有几个注意点

1 网格放障碍物用的坐标是格子，范围N*M；机器人走的点是交点，但是因为有体积，四个边界都不可到达，能走的范围反而更小是：1～N-1 * 1～M-1

2 bfs操作是针对机器人的运动，它的位置和四角的格子点坐标关系。机器人坐标是（i，j），四个参与影响的格子坐标就是，（i，j）（i，j-1）， （i-1， j）和（i-1， j-1）

3 每个交点上，实际上有12种可能； 4个方向，每个方向上前进1，2，3步。注意旋转的代价要加到不同的方向变化上去

代码实现的时候，使用vis数组标记，标记的内容如果是-1表示还没有到达过， 其他数值是到达对应的交点的最小代价，并没有标记该交点是否在队列当中； 这是因为，一个交点可能通过不同的路径到达，要判定的是重复到达时候的代价有多大。需要注意的是，当再次到达的时候，如果代价和保存的一样，那么还是需要继续把该点放入队列的，代价虽然一样但是到达这里时候的运动方向可能不同，这会对后续的计算有影响的。

具体细节和小技巧看代码注释
代码如下：



```
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
#define MAXMN 50
int grid[MAXMN][MAXMN]; // 格子
int N, M;

// 注意格子和机器人走的网格交点是不同，网格交点是N+1 * M+1 个
// 因为机器人占据位置，四边儿都不可达。
// 除了grid之外，其他的数据存储的都是交点
struct POS {
    int x; int y; int nWay;
} ptStart, ptEnd;  //
queue<POS> q;
int vis[MAXMN][MAXMN];  // -1 初始状态，0以上是到达此处的最小代价

void readDate();        // 读取数据并初始化

// bfs处理的点都是交点，而不是格子点
void  bfs() {
    POS pt = ptStart;
    vis[pt.x][pt.y] = 0; // 到达入口点代价0
    while(1) {
        // 旋转和行走归并到一起，vis当中记录到达的最小步数
        // 每个点上实际最多有12种可能，分别是
        // 1 直行1，2，3步        // 2 左转1，2，3步
        // 3 回头1，2，3步        // 4 右转1，2，3步
        for ( int i=0; i<4; i++ ) {
            int newWay = pt.nWay + i; newWay %= 4; // 调整方向
            
            const int vWay [] = { -1, 0, 1, 0, -1, };
            // N: 0 1  E: 1 0 S:0 -1 W:-1 0
            const int nCost[] = { 0, 1, 2, 1, }; // 旋转的代价
            
            for (int j=1; j<4; j++) {
                POS newP = pt; newP.nWay = newWay;
                // 新方向上，向前走j步的新位置
                newP.x += vWay[newP.nWay]*j;
                newP.y += vWay[newP.nWay+1]*j;
                
                // 新位置是否可行，检测距离周边格子距离
                // 如果走j步不可行，更多步必然也不可行，所以是
                //    break而不是continue
                // 新点不可以是边界
                if ( newP.x <= 0   || newP.y  <=  0 ) break;
                if ( newP.x >  N-1 || newP.y  > M-1 ) break;
                // 新点四周的格子不能被占据
                if ( 1 == grid[newP.x]  [newP.y] )    break;
                if ( 1 == grid[newP.x]  [newP.y-1] )  break;
                if ( 1 == grid[newP.x-1][newP.y])   break;
                if ( 1 == grid[newP.x-1][newP.y-1]) break;
                
                // 至此新点是可达到。下面要计算到此到代价,增加旋转和行走的成本
                int  curCost = vis[pt.x][pt.y] + nCost[i] + 1;
                
                // 到达终点，优化cost并break
                if ( newP.x == ptEnd.x && newP.y == ptEnd.y ) {
                    int& oldCost = vis[newP.x][newP.y];
                    if ( oldCost==-1 || oldCost>curCost)
                        oldCost = curCost;
                    break;
                };
                
                // 还没有到达终点
                int& oldCost = vis[newP.x][newP.y];
                if ( oldCost == -1 || oldCost>=curCost) {
                    // 不管此点是否已经在队列里面了，都要再放入队列处理
                    oldCost = curCost;
                    q.push(newP);
                    continue;
                } else if ( oldCost<curCost ) {
                    // 以前到达过，而且开销更小， 保留以前，放弃当前
                    continue;
                }
            };
        };
        if ( !q.empty() ) {
            pt = q.front();
            q.pop();
        } else break;
    };
    cout << vis[ptEnd.x][ptEnd.y];
}
int main() {
    readDate();
    bfs();
    return 0;
};

void readDate () {
    cin >> N >> M;
    for ( int i=0; i<N; i++ ) {
        for ( int j=0; j<M; j++) {
            int t;
            cin >> t;
            grid[i][j]=t;
        };
    };
    cin >> ptStart.x >> ptStart.y;
    cin >> ptEnd.x   >> ptEnd.y;
    char c;  cin >> c;
    if ( c=='N' ) ptStart.nWay=0;
    else if ( c=='E' ) ptStart.nWay = 1;
    else if ( c=='S' ) ptStart.nWay = 2;
    else ptStart.nWay = 3;
    memset(vis, 0xFF, MAXMN*MAXMN*sizeof(int));
};

```

---

## 作者：Christopher_Yan (赞：0)

这道题目本蒟蒻花了整整四个小时才AC掉，硬生生的把BFS写成了半个模拟。。

### 这道题在说思路之前有几个小坑需要注意一下 
1.输入的矩阵不是格点，而是方块。

2.由于机器人是站在格点上的球体，所以边界格点也不可以去。

3.起点和终点可能重合。

### 然后说一下我的具体思路：

我这里用了结构体来存储BFS时的状态,　并且BFS时用了优先队列（维护时根据ans的大小从小到大），判重用的是四维数组（52^4没有MLE）, 机器人的移动用了一个长为12的数组，代表向四个方向移动1到3格的12种可能，然后用ans1记录并不断更新答案。

下附AC代码
```cpp
#include<bits/stdc++.h>
#define INF 99999999
using namespace std;
int fx,fy,ex,ey,n,m,i,j,l=0,ans1=INF,k;
bool a[55][55],v[52][52][52][52];    //前二维表示当前点坐标，后二维表示前缀（上个点的坐标） 
//举个栗子 a(0,1) b(0,2) c(0,3) 虽然方向相同，但a->c与b->c并不重复
int dx[12]={-3,-2,-1,0,0,0,0,0,0,3,2,1};
int dy[12]={0,0,0,3,2,1,-3,-2,-1,0,0,0};  //移动数组
char direct;
int direc;
int direc3;
struct node{
    int x;
    int y;
    int d;	//方向
    int ans;//记录答案
    bool operator < (const node & a) const //维护小根堆
    {
        return ans > a.ans;
    }
}cur,now,fir,las;
priority_queue <node> q;
void bfs()
{
    q.push(fir);  //压入起点
    while(!q.empty())
    {
        now=q.top();q.pop();
 		for(i=0;i<12;i++)
        {
            if(i<=2) direc3=1; //1代表北，2代表东，3代表南，4代表西
            else if(i<=5) direc3=2;
            else if(i<=8) direc3=4;
            else if(i<=11) direc3=3; //根据i的大小判断移动后的方向
            cur.x=now.x+dx[i];
            cur.y=now.y+dy[i];
            if(cur.x==fir.x && cur.y==fir.y) continue; //不再重复经过起点
            bool f=true;
            if(cur.x==now.x) 
                for(j=min(now.y,cur.y);j<=max(now.y,cur.y);j++)
                    if(a[now.x][j]==1) f=false;
            if(cur.y==now.y) 
                for(j=min(now.x,cur.x);j<=max(now.x,cur.x);j++)
                    if(a[j][now.y]==1) f=false;//判断移动过程中有无障碍
            if(!f) continue; //有障碍则跳过
            if(a[cur.x][cur.y]==1||cur.x>=n||cur.x<1||cur.y>=m||cur.y<1) continue;//既不能走有障碍的点，又不能走到边界（会撞墙）
            if(v[cur.x][cur.y][now.x][now.y]==1) continue;//不走重点
            int ml=abs(now.d-direc3); //计算转向的花费
            if(ml==3) ml=1;           //右转三次等同于左转一次
            cur.ans=now.ans+ml+1;	  //当前答案由上个点的答案加出
           	if(cur.x==las.x && cur.y==las.y) 
                ans1=min(ans1,cur.ans);//更新答案
            cur.d=direc3;
            q.push(cur);              //入队
            v[cur.x][cur.y][now.x][now.y]=1;//标记
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&a[i][j]);
            if(a[i][j]==1) a[i-1][j-1]=1,a[i-1][j]=1,a[i][j-1]=1;
            if(i==0||j==0||i==n||j==m) a[i][j]=1; //保险起见，禁止走到边界
        }			
    scanf("%d%d%d%d",&fir.x,&fir.y,&las.x,&las.y);
    cin>>direct;
    if(fir.x==las.x && las.y==fir.y)  //若起点终点重合，直接输出0
    {
        cout<<0<<endl;
        return 0;
    }
    if(direct=='N') direc=1;
    if(direct=='E') direc=2;
    if(direct=='S') direc=3;
    if(direct=='W') direc=4; //方向
    //1代表北，2代表东，3代表南，4代表西
    fir.d=direc;
    fir.ans=0;
    bfs();
    if(ans1!=INF) //有答案则输出
    {
        cout<<ans1;
        return 0;
    }
    printf("-1");
    return 0;
}
```
以上做法若有不好或者可优化的地方，还请dalao们多多指教，谢谢

---

## 作者：ylsoi (赞：0)

这一题思路比较简单，就是基本的广度优先搜索，但是个人认为编程的复杂度有一点高，并且坑点较多，所以还是有一点的难度：综合起来就是有一下几点是需要注意的:就是对于地图中格子与交叉点之间的差别要进行预处理，很多人这里就看不懂了，还有读入的时候要注意不要将最后一个字符漏了，还有就是在向前跑三格的时候要注意前面两格也要是可以走的：

附上代码如下

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn=50+10;
int m,n,map[maxn][maxn],bx,by,ex,ey,ans;
char d;
int xx[5][4]={{0,0,0,0},{0,-1,-2,-3},{0,0,0,0},{0,1,2,3},{0,0,0,0}};//此处对应的分别是北西南东四个方向的三中位移；
int yy[5][4]={{0,0,0,0},{0,0,0,0},{0,-1,-2,-3},{0,0,0,0},{0,1,2,3}};
struct tt
{
    int x;
    int y;
    int dic;//记录此时结点的方向
    int step;//记录此时所需要的指令条数；
}t[maxn*maxn*6];
bool s[maxn][maxn][5];//最后一个维度记录此坐标的方向
void bfs()
{
    int head=0,tail=1;
    t[1].x=bx;t[1].y=by;//第一个结点是要初始化的
    if(d=='N')t[1].dic=1;
    if(d=='W')t[1].dic=2;
    if(d=='S')t[1].dic=3;
    if(d=='E')t[1].dic=4;
    while(head<tail)
    {
        head++;
        int x1=t[head].x,y1=t[head].y;
        for(int i=1;i<=4;i++)
        {
            if(t[head].dic!=i&&abs(t[head].dic-i)!=2&&s[x1][y1][i]==0&&map[x1][y1]==0)//第一种走法就是向两边转向；
            {
                s[x1][y1][i]=1;
                t[++tail].x=t[head].x;
                t[tail].y=t[head].y;
                t[tail].dic=i;
                t[tail].step=t[head].step+1;
            }    
        }
        for(int i=1;i<=3;i++)
        {
            x1=t[head].x+xx[t[head].dic][i];y1=t[head].y+yy[t[head].dic][i];
            if(x1>=1&&x1<=m&&y1>=1&&y1<=n&&s[x1][y1][t[head].dic]==0&&map[x1][y1]==0)//第二种走法就是朝着目前面对的方向走1或2或3步；
            {
                if(i>=2&&(map[t[head].x+xx[t[head].dic][i-1]][t[head].y+yy[t[head].dic][i-1]]))continue;//如果走两步以上的话，第一步也要为无障碍；
                if(i==3&&(map[t[head].x+xx[t[head].dic][i-2]][t[head].y+yy[t[head].dic][i-2]]))continue;//如果为三步的话，第二步也要为无障碍；
                s[x1][y1][t[head].dic]=1;
                t[++tail].x=x1;
                t[tail].y=y1;
                t[tail].dic=t[head].dic;
                t[tail].step=t[head].step+1;
                if(x1==ex&&y1==ey)
                {
                    head=tail;
                    ans=t[tail].step;
                    break;
                }
            }
        }
    }
}
int main()
{
    int temp;
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)//输入的时候我把地图转化为了格点的形式，那么每一个障碍物就是占用四个格点的；
    {
        if(i==1||j==1)map[i][j]=1;
        if(i==m)map[i+1][j]=1;
        if(j==n)map[i][j+1]=1; 
        scanf("%d",&temp);
        if(!temp)continue;
        map[i][j]=1;map[i][j+1]=1;
        map[i+1][j]=1;map[i+1][j+1]=1;
    }
    m++;n++;
    map[m][n]=1;
    scanf("%d%d%d%d",&bx,&by,&ex,&ey);
    bx++;by++;ex++;ey++;
    if(bx==ex&&by==ey)//如果起点等于终点，那么就直接输出0，return 0；
    {
        printf("0");
        return 0;
    }
    getchar();
    scanf("%c",&d);
    bfs();
    if(ans!=0)printf("%d",ans);
    else printf("-1");//没有走到的话就输出-1；
    return 0;
}
```

---

## 作者：C2H6O (赞：0)


```cpp
#include <iostream>
#include <queue>
#include <string.h>
#define north 0
#define east 1
#define south 2
#define west 3
using namespace std;
class pos {
```
public:
int x, y, from, depth;//记录每个点搜索时坐标、方向和所需时间


```cpp
};
const int x[] = { 1,0,-1,0 }, y[] = { 0,-1,0,1 };//针对from四个方向，接下来机器人的行动路线（坐标如何改变）
int n, m, sx, sy, ex, ey, sfrom,a[60][60];//sx,sy为起点坐标 ex,ey为终点坐标 sfrom为机器来源方向（即与读入的面朝方向相反） a为地图的记录
bool b[60][60][4];//记录地图上每个点四个方向搜过没有
queue<pos> dui;//队列
//左转
int left(int from) {
    if (from == 0) return 3;
    return (from - 1);
}
//右转
int right(int from) {
    if (from == 3) return 0;
    return (from + 1);
}
//测试机器能否向前走i格，若能，同时在b中记录
bool can(pos tmp, int i) {
    tmp.x += x[tmp.from] * i;
    tmp.y += y[tmp.from] * i;
    if (tmp.x >= 1 && tmp.x < n && tmp.y >= 1 && tmp.y < m && a[tmp.x][tmp.y] == 0 && a[tmp.x + 1][tmp.y] == 0 && a[tmp.x][tmp.y + 1] == 0 && a[tmp.x + 1][tmp.y + 1] == 0 && !b[tmp.x][tmp.y][tmp.from]) {
        b[tmp.x][tmp.y][tmp.from] = 1;
        return 1;
    }
    return 0;
}
//主程序
int main() {
    int i, j;
    char rd;
    memset(b, 0, sizeof(b));
    cin >> n >> m;
    for (i = 1; i <= n; i++)
    for (j = 1; j <= m; j++)
        cin >> a[i][j];
    cin >> sx >> sy >> ex >> ey >> rd;
    switch (rd){
        case 'S':sfrom = north; break;
        case 'N':sfrom = south; break;  //from为来源方向，应与朝向相反
        case 'E':sfrom = west; break;
        case 'W':sfrom = east; break;
    }
    pos tmp = { sx,sy,sfrom,0 };
    b[sx][sy][sfrom] = 1;
    dui.push(tmp);
    while (!dui.empty()) {
        //若到达，直接退出
        if (dui.front().x == ex&&dui.front().y == ey) {
            cout << dui.front().depth << endl;
            return 0;
        }
        //左转
        tmp = dui.front();
        tmp.depth += 1;
        tmp.from = left(tmp.from);
        if (!b[tmp.x][tmp.y][tmp.from]) {
            dui.push(tmp);
            b[tmp.x][tmp.y][tmp.from] = 1;
        }
        //右转
        tmp = dui.front();
        tmp.depth += 1;
        tmp.from = right(tmp.from);
        if (!b[tmp.x][tmp.y][tmp.from]) {
            dui.push(tmp);
            b[tmp.x][tmp.y][tmp.from] = 1;
        }
        //直行
        tmp = dui.front();
        tmp.depth += 1;
        i = 1;
        while (i < 4){
            if (can(tmp, i)) {        //如果可以直行i格，则下一格入队
                pos k = tmp;
                k.x += x[tmp.from] * i;
                k.y += y[tmp.from] * i;
                dui.push(k);
                i++;
            }
            else break;               //否则不能再往前走，退出搜索
        }
        //搜索完毕出队
        dui.pop();
    }
    cout << "-1" << endl;
    return 0;
}
```

---

## 作者：GNAQ (赞：0)

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<string>
#include<queue>
#include<algorithm>
using namespace std;

int main()
{
    bool mapx[100][100];  //Map
    queue<int> quex,quey,quedir;  //Queue of Line,Row & Direction
    int sx,sy,ex,ey,dir,n,m; char dx;
    int timex[100][100][4]={0}; //HASH
    int cachex,cachey,cachedir,cachedir2,cachego=0;  //Caches
    int wayx[4]={-1,0,1,0},wayy[4]={0,1,0,-1};  //Direction Table
    
    memset(mapx,true,sizeof(mapx));
    scanf("%d%d",&n,&m); 
    for (int i=0;i<n;i++)
    {
        for (int j=0;j<m;j++)
        {
            scanf("%d",&mapx[i][j]);
        }
    }
    scanf("%d%d%d%d %c",&sx,&sy,&ex,&ey,&dx);//可以在%c前面加个空格来吸收读入的时候的空格 
    
    switch(dx)//把字符形式的坐标转化成数字（我使用了方向表 直接用dir的值查表，再乘以前进的步数，就是坐标变化量 ！） 
    {
        case 'N':
            dir=0;
            break;
        case 'E':
            dir=1;
            break;
        case 'S':
            dir=2;
            break;
        case 'W':
            dir=3;
            break;
    }
    sx--; sy--; ex--; ey--;//处理成数组下标的形式（数组下标从0开始） 
    timex[sx][sy][dir]=0;/*初始化HASH*/ quex.push(sx); quey.push(sy); quedir.push(dir); //初始值入队列 
    
    while (quex.size()>0)
    {
        cachex=quex.front(); cachey=quey.front(); cachedir=quedir.front(); cachego=1; //队首值缓存一下，便于处理 
        if (cachex==ex && cachey==ey) //采用判断队首值的方法，起点和终点重合就不用加特判了 
        {
            printf("%d",timex[cachex][cachey][cachedir]);
            return 0;
        }
        for (int i=1;i<=5;i++)//五种命令 
        {
            if (i<=3/*如果是前三种*/ && cachex+wayx[cachedir]*i>=0 && cachex+wayx[cachedir]*i<n-1 && cachey+wayy[cachedir]*i>=0 && cachey+wayy[cachedir]*i<m-1/*没有越界*/ && cachego==i/*前面的移动成立*/)
                if (mapx[cachex+wayx[cachedir]*i][cachey+wayy[cachedir]*i]==0 && mapx[cachex+wayx[cachedir]*i+1][cachey+wayy[cachedir]*i]==0 && mapx[cachex+wayx[cachedir]*i+1][cachey+wayy[cachedir]*i+1]==0 && mapx[cachex+wayx[cachedir]*i][cachey+wayy[cachedir]*i+1]==0)
                //移动之后不越界 新的xy坐标是i（i同时代表了前进的步数 有1、2、3步）乘以方向表里目前的方向前进一步的xy坐标变化量 
                {
                    cachego++;//前一步不能走，有一种情况是Hash表的这个位置已经存在一个更短的耗时。但这不代表这一步不能走，也不代表走这一步的耗时不是最短的（因为方向问题）
                    if (timex[cachex+wayx[cachedir]*i][cachey+wayy[cachedir]*i][cachedir]==0) //Hash表内这个位置没有被访问过（如果访问过，则Hash表内一定是一个最短的耗时 
                    {
                        timex[cachex+wayx[cachedir]*i][cachey+wayy[cachedir]*i][cachedir]=timex[cachex][cachey][cachedir]+1;//根据结点所在层数写入Hash表 
                        quex.push(cachex+wayx[cachedir]*i); quey.push(cachey+wayy[cachedir]*i); quedir.push(cachedir);//入队列 
                    }
                }
            if (i==4) //Left
            {
                cachedir2=cachedir-1;
                if (cachedir2==-1) cachedir2=3;//如果由North转到West，就重置方向缓存 
                if (timex[cachex][cachey][cachedir2]==0) //Hash表内这个位置没有被访问过（如果访问过，则Hash表内一定是一个最短的耗时 
                {
                    timex[cachex][cachey][cachedir2]=timex[cachex][cachey][cachedir]+1;//根据结点所在层数写入Hash表 
                    quex.push(cachex); quey.push(cachey); quedir.push(cachedir2);//入队列 
                }
            }
            if (i==5) //Right 同上 
            {
                cachedir2=cachedir+1;
                if (cachedir2==4) cachedir2=0;
                if (timex[cachex][cachey][cachedir2]==0)
                {
                    timex[cachex][cachey][cachedir2]=timex[cachex][cachey][cachedir]+1;
                    quex.push(cachex); quey.push(cachey); quedir.push(cachedir2);
                }
            }
        }
        quex.pop(); quey.pop(); quedir.pop();//出队列 
    }
    cout<<-1<<endl;
    return 0;
}
```

---

## 作者：litble (赞：0)

看见地图就想到了广搜，一开始WA了两个点是因为没有考虑特殊情况。

机器人占四个格子，所以扩展出来的四个格子都要是空地。

机器人前进三格是可行的前提是前进一格，两格都是可行的。

具体的看代码。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<iomanip>
#include<climits>
#include<cstring>
using namespace std;
bool ma[51][51],v[51][51];//ma:地图，v:是否走过
int dl[900001][5];//1:x,2:y,3:朝向，4：时间
int mvx[5]={0,0,1,0,-1},mvy[5]={0,1,0,-1,0};//分别代表东南西北的走法
int main()
{  
   int mx,my,m,n,i,j,k,y;
   int head=1,tail=1,x1,x2,x3,x4,y1,y2,y3,y4;
   char a;
   scanf("%d%d",&m,&n);
   for(i=1;i<=m;i++)
     for(j=1;j<=n;j++){
     scanf("%d",&y);ma[i][j]=y;v[i][j]=y;
     }
   scanf("%d%d%d%d",&dl[1][1],&dl[1][2],&mx,&my);
   getchar();//读掉空格
   scanf("%c",&a);
   if(dl[1][1]==mx&&dl[1][2]==my){printf("0");return 0;}//特判一开始就在终点的情况
   v[dl[1][1]][dl[1][2]]=1;
   if(a=='E')dl[1][3]=1;
   else if(a=='S')dl[1][3]=2;
   else if(a=='W')dl[1][3]=3;
   else if(a=='N')dl[1][3]=4;
   while(head<=tail){
     for(i=1;i<=3;i++){
       x1=dl[head][1]+mvx[dl[head][3]]*i;
       y1=dl[head][2]+mvy[dl[head][3]]*i;
       x2=x1+1;y2=y1;x3=x1;y3=y1+1;x4=x1+1;y4=y1+1;//机器人占的四个格子
       if(x1>=1&&x1+1<=m&&y1>=1&&y1+1<=n&&ma[x1][y1]==0&&ma[x2][y2]==0&&ma[x3][y3]==0&&ma[x4][y4]==0){
          if(v[x1][y1]==0){
              tail++;dl[tail][1]=x1;dl[tail][2]=y1;dl[tail][3]=dl[head][3];dl[tail][4]=1+dl[head][4];v[x1][y1]=1;
               if(x1==mx&&y1==my){printf("%d",dl[tail][4]);return 0;}
           }}
       else break;//如果前进一格遇到障碍物，那么不可能前进二或三格
     }
    if(dl[head][0]==0){//这个条件代表该状态不是由旋转得到，避免重复旋转
      for(j=1;j<=4;j++){
         if(j!=dl[head][3]){
           if(j!=dl[head][3]+2&&j!=dl[head][3]-2){
           tail++;dl[tail][1]=dl[head][1];dl[tail][2]=dl[head][2];dl[tail][3]=j;dl[tail][4]=dl[head][4]+1;dl[tail][0]=1;}
```
}//旋转90度，因为这样省时一些所以先扩展旋转90度的状态
```cpp
      }
      for(j=1;j<=4;j++)
        if(j!=dl[head][3]){
           if(j==dl[head][3]+2||j==dl[head][3]-2){
              tail++;dl[tail][1]=dl[head][1];dl[tail][2]=dl[head][2];dl[tail][3]=j;dl[tail][4]=dl[head][4]+2;dl[tail][0]=1;}
```
}//旋转180度
```cpp
    }
     head++;
   }
   printf("-1");//如果无解
   return 0;
}
```

---

## 作者：chauchat (赞：0)

练练宽搜的套路还是很好的，

这题有个要点：

机器人占的位置是4个格

所以就用了想当然的办法，把格子坐标系变换到格点坐标系，让障碍物占四个格点，然后让状态在格点上移动。

然后转向啊判重什么的就没什么了。


（把注释删掉可以看到各个状态）







    
            
             
                



    
    
    
    
```cpp
#include<iostream>
using namespace std;
#include<cstring>
#include<cstdio>
#include<cmath>
int n,m,ans = 10000000;
int place[55][55],vis[55][55];
int xs,ys,xt,yt;char t1;
int head,tail;
struct node{
    int y,x,turn,time,fa;
}queue[1000000];
struct g{
    int x,y;
}go[5];
int ge(char t1)
{
    if(t1 == 'N') return 1;
    else if(t1 == 'E') return 2;
    else if(t1 == 'S') return 3;
    else
        return 4;
}
int need(int turn_now,int turn_target)
{
    if((turn_now == 4 && turn_target == 1) ||
       (turn_now == 1 && turn_target == 4) )
        return 1;
    else
        return abs(turn_now - turn_target);
}
void bfs()
{
    while(head <= tail)
    {
//        cout<<head<<':'<<queue[head].fa<<' '<<'('<<queue[head].x<<','<<queue[head].y<<','<<queue[head].turn<<')'
//        <<' '<<queue[head].time<<endl;
        if(queue[head].y == yt && queue[head].x == xt)
            ans = min(ans,queue[head].time);
        for(int i = 1;i <= 4;i++)
        {
            int t_now = queue[head].time + need(queue[head].turn,i) + 1;
            int tx = queue[head].x;
            int ty = queue[head].y;
            tx += go[i].x;ty += go[i].y;
            if(ty <= 1 || tx <= 1 || ty >= n + 1 || tx >= m + 1 || place[ty][tx]) continue; 
            if(vis[ty][tx] > t_now)
            { 
                vis[ty][tx] = t_now;
                queue[++tail].turn = i;
                queue[tail].x = tx;queue[tail].y = ty;
                queue[tail].time = t_now;
                queue[tail].fa = head;
            }
            tx += go[i].x;ty += go[i].y;
            if(ty <= 1 || tx <= 1 || ty >= n + 1 || tx >= m + 1 || place[ty][tx]) continue; 
            if(vis[ty][tx] > t_now)
            {
                vis[ty][tx] = t_now;
                queue[++tail].turn = i;
                queue[tail].x = tx;queue[tail].y = ty;
                queue[tail].time = t_now;
                queue[tail].fa = head;
            }
            tx += go[i].x;ty += go[i].y;
            if(ty <= 1 || tx <= 1 || ty >= n + 1 || tx >= m + 1 || place[ty][tx]) continue; 
            if(vis[ty][tx] > t_now)
            {
                vis[ty][tx] = t_now;
                queue[++tail].turn = i;
                queue[tail].x = tx;queue[tail].y = ty;
                queue[tail].time = t_now ;
                queue[tail].fa = head;
            }
        }
        head++;
    }
}
int main()
{
    memset(go,0,sizeof(go));
    for(int i = 1;i <= 54;i++)
        for(int j = 1;j <= 54;j++)
            vis[i][j] = 1000000;
    go[1].y = -1;go[2].x = 1;
    go[3].y = 1;go[4].x = -1;
    cin>>n>>m;
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= m;j++)
        {
            int temp;cin>>temp;
            if(temp){
                place[i][j] = place[i][j+1] = 
                place[i+1][j] = place[i+1][j+1] = 1;
            }
        }
    cin>>ys>>xs>>yt>>xt>>t1;
    ys++;xs++;yt++;xt++;
    vis[ys][xs] = 0;
    queue[0].x = xs;queue[0].y = ys;
    queue[0].turn = ge(t1);
    bfs();
    if(ans == 10000000)
        cout<<-1;
    else
        cout<<ans;
    return 0;
}
```

---

## 作者：doby (赞：0)

直接找了一个hash……明明可以用桶的……

这回不能打表，想多了……

```cpp
#include<iostream>
#include<cstdlib>
using namespace std;
int u,cnt=0,x,y,f,x0,y0,x1,y1,x2,y2,f2,fx,head,tail,n,m,w,t,sum,data[1000007],next[1000007]={0},list[1000007]={0},a[51][51],b[51][51]={0},qs[500000],tim[500000];
char c;
int hash()
{
    sum=x2*1000+y2*10+f2,u=list[sum];
    while(u){if(data[u]==sum){return 0;}u=next[u];}//如果出现过，return 0，否则找到链的尽头
    data[++cnt]=sum,next[cnt]=list[sum],list[sum]=cnt,tail++,qs[tail]=sum,tim[tail]=t+1;//进链……
    return 0;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cin>>a[i][j];}}
    cin>>x0>>y0>>x1>>y1>>c;
    if(x0==x1&&y0==y1){cout<<"0";return 0;}
    if(c=='E'){fx=1;}if(c=='S'){fx=2;}if(c=='W'){fx=3;}if(c=='N'){fx=4;}//各种数据处理……
    for(int i=1;i<=n-1;i++){for(int j=1;j<=m-1;j++){if(a[i][j]+a[i][j+1]+a[i+1][j]+a[i+1][j+1]==0){b[i][j]=1;}}}//4格压缩到1格
    head=0,tail=1,qs[1]=x0*1000+y0*10+fx,tim[1]=0;//初始状态
    while(head<tail)
    {
        head++,w=qs[head],t=tim[head],x=w/1000,y=(w-x*1000)/10,f=w%10;//取出状态
        for(int i=1;i<=3;i++)//如果能走，走到尽头并且把每一次走全部入队，所有走的路只需要一秒
        {
            f2=0;
            if(f==1&&y+i<=m&&b[x][y+i]==1){x2=x;y2=y+i;f2=f;}//还可以走
            if(f==2&&x+i<=n&&b[x+i][y]==1){x2=x+i;y2=y;f2=f;}
            if(f==3&&y-i>=1&&b[x][y-i]==1){x2=x;y2=y-i;f2=f;}
            if(f==4&&x-i>=1&&b[x-i][y]==1){x2=x-i;y2=y;f2=f;}
            if(f2==0){break;}//走不了了，退出
            if(x2==x1&&y2==y1){cout<<t+1;return 0;}//判断达到目标状态
            hash();//记录
        }
        x2=x,y2=y; 
        f2=f+1;if(f2>4){f2=1;}hash();//转方向并且判断是否出现，因为转方向不可能达到状态，所以不判断
        f2=f-1;if(f2<1){f2=4;}hash();
    }
    cout<<"-1";//搜完了，走不到
    return 0;
}
```

---

## 作者：littleming (赞：0)


 
    
        
        
        
        
        

        
```cpp
#include<iostream> 
#include<cstdio>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<string> 
#include<algorithm>
#include<queue>
using namespace std;
int n,m,xa,ya,xb,yb,a[55][55],g=1;
char b;
bool c[55][55][4],finish;
int x[3000],y[3000],d[3000],ans[3000000];//d表示方向 0表示北 1表示东 2表示南 3表示西 
int i,j;
void bfs()
{
    x[1]=xa;y[1]=ya;ans[1]=0;
    if(b=='N')    d[1]=0;
    else if(b=='E')    d[1]=1;
    else if(b=='S')    d[1]=2;
    else if(b=='W')    d[1]=3; 
    c[xa][ya][d[1]]=1;//初始化 入队列
    int h=1,t=1,tx,ty,td;
    while(h<=t)
    {
        tx=x[h];ty=y[h];td=(d[h]+1)%4;//右转后的xyd
        if(c[tx][ty][td]==0)    {t++;x[t]=tx;y[t]=ty;d[t]=td;c[tx][ty][td]=1;ans[++g]=ans[h]+1;}//入队列 g会小于h？貌似不会 
        tx=x[h];ty=y[h];td=(d[h]+3)%4;//左转
        if(c[tx][ty][td]==0)    {t++;x[t]=tx;y[t]=ty;d[t]=td;c[tx][ty][td]=1;ans[++g]=ans[h]+1;}
        if(d[h]==0)//北 
        {
            if(a[x[h]-1][y[h]]==0&&a[x[h]-1][y[h]+1]==0)//能否走1格 
            {
                if(c[x[h]-1][y[h]][d[h]]==0)    
                    {t++;x[t]=x[h]-1;y[t]=y[h];d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}} 
                if(a[x[h]-2][y[h]]==0&&a[x[h]-2][y[h]+1]==0)//能否走2格 
                {
                    if(c[x[h]-2][y[h]][d[h]]==0)    
                        {t++;x[t]=x[h]-2;y[t]=y[h];d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                    if(a[x[h]-3][y[h]]==0&&a[x[h]-3][y[h]+1]==0)//能否走3格
                        if(c[x[h]-3][y[h]][d[h]]==0)    
                            {t++;x[t]=x[h]-3;y[t]=y[h];d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                }    
            }
        }
        else if(d[h]==1)//东 
        {
            if(a[x[h]][y[h]+2]==0&&a[x[h]+1][y[h]+2]==0)//能否走1格 
            {
                if(c[x[h]][y[h]+1][d[h]]==0)    
                    {t++;x[t]=x[h];y[t]=y[h]+1;d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                if(a[x[h]][y[h]+3]==0&&a[x[h]+1][y[h]+3]==0)//能否走2格 
                {
                    if(c[x[h]][y[h]+2][d[h]]==0)    
                        {t++;x[t]=x[h];y[t]=y[h]+2;d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                    if(a[x[h]][y[h]+4]==0&&a[x[h]+1][y[h]+4]==0)//能否走3格
                        if(c[x[h]][y[h]+3][d[h]]==0)    
                            {t++;x[t]=x[h];y[t]=y[h]+3;d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                }    
            }
        }
        else if(d[h]==2)//南 
        {
            if(a[x[h]+2][y[h]]==0&&a[x[h]+2][y[h]+1]==0)//能否走1格 
            {
                if(c[x[h]+1][y[h]][d[h]]==0)    
                    {t++;x[t]=x[h]+1;y[t]=y[h];d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                if(a[x[h]+3][y[h]]==0&&a[x[h]+3][y[h]+1]==0)//能否走2格 
                {
                    if(c[x[h]+2][y[h]][d[h]]==0)    
                        {t++;x[t]=x[h]+2;y[t]=y[h];d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                    if(a[x[h]+4][y[h]]==0&&a[x[h]+4][y[h]+1]==0)//能否走3格
                        if(c[x[h]+3][y[h]][d[h]]==0)    
                            {t++;x[t]=x[h]+3;y[t]=y[h];d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                }    
            }
        }
        else if(d[h]==3)//西 
        {
            if(a[x[h]][y[h]-1]==0&&a[x[h]+1][y[h]-1]==0)//能否走1格 
            {
                if(c[x[h]][y[h]-1][d[h]]==0)    
                    {t++;x[t]=x[h];y[t]=y[h]-1;d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                if(a[x[h]][y[h]-2]==0&&a[x[h]+1][y[h]-2]==0)//能否走2格 
                {
                    if(c[x[h]][y[h]-2][d[h]]==0)    
                        {t++;x[t]=x[h];y[t]=y[h]-2;d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}}
                    if(a[x[h]][y[h]-3]==0&&a[x[h]+1][y[h]-3]==0)//能否走3格
                        if(c[x[h]][y[h]-3][d[h]]==0)    
                            {t++;x[t]=x[h];y[t]=y[h]-3;d[t]=d[h];c[x[t]][y[t]][d[t]]=1;ans[++g]=ans[h]+1;if(x[t]==xb&&y[t]==yb)    {cout<<ans[g]<<endl;finish=1;return;}} 
                }    
            }
        }
        h++;
    }    
}
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            cin>>a[i][j];
    for(i=0;i<=n+1;i++)
    {
        a[i][0]=1;a[i][m+1]=1;
    }
    for(j=0;j<=m+1;j++)
    {
        a[0][j]=1;a[n+1][j]=1;
```
}//加墙
    

    
```cpp
    cin>>xa>>ya>>xb>>yb>>b;
    if(a[xa][ya]==1||a[xa][ya+1]==1||a[xa+1][ya]==1||a[xa+1][ya+1]==1)    {cout<<-1<<endl;return 0;}
    if(xa==xb&&ya==yb)    {cout<<0<<endl;return 0;}
    bfs();
    if(finish==0)    cout<<-1<<endl;
    return 0;
}

```

---

## 作者：Rapiz (赞：0)

题面应该说清楚网格边缘不能走。

```cpp

#include<cstdio>
#include<queue>
using namespace std;
const int MAXN=60;
int MDIR[256];
int n,m,sx,sy,tx,ty,dir;
bool map[MAXN][MAXN],vis[MAXN][MAXN][4];
int d[MAXN][MAXN];
struct POS{
    int x,y,dir,t;
    int lx,ly,ldir,lt;
    POS(int _x=0,int _y=0,int _dir=-1):x(_x),y(_y),dir(_dir),t(0){};
};
queue<POS> q;
bool inline check(const POS& p){
    return 1<=p.x&&p.x<=n&&1<=p.y&&p.y<=m;
}
void turn(const POS& s,POS& res,int c){
    res=s;
    switch(c){
        case 0:break;//什么也不做 
        case 1:res.dir=res.dir-1;res.t++;break;//左转 
        case 2:res.dir=res.dir+1;res.t++;break;//右转 
    }
    while(res.dir<0) res.dir+=4;
    while(res.dir>3) res.dir-=4;
}
bool move(POS& s,POS& res,int steps){//移动后的结果存在res里,如果出界或落点有障碍返回false 
    res=s; 
    switch(s.dir){
        case 0:res.y-=steps;break;
        case 1:res.x-=steps;break;
        case 2:res.y+=steps;break;
        case 3:res.x+=steps;break;
    }
    res.t++;
    return check(res)&&!map[res.x][res.y];
}
int main(){
    MDIR['W']=0,MDIR['N']=1,MDIR['E']=2,MDIR['S']=3;//从W开始，右手方向,MOD 4
    freopen("P1126.in","r",stdin);
    scanf("%d%d",&n,&m);
    bool b;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) {
            scanf("%d",&b);
            for(int dx=0;dx<=1;dx++) for(int dy=0;dy<=1;dy++)
             map[i+dx][j+dy]=map[i+dx][j+dy]||b;
    }//把网格的点当做数组元素 
    n++,m++;
    for(int i=1;i<=m;i++) map[1][i]=1;
    for(int i=1;i<=m;i++) map[n][i]=1;
    for(int i=1;i<=n;i++) map[i][1]=1;
    for(int i=1;i<=n;i++) map[i][m]=1;//奇怪的限制啊不能走网格边缘 
    scanf("%d%d%d%d %c",&sx,&sy,&tx,&ty,&dir);
    sx++,sy++,tx++,ty++;
    POS p(sx,sy,MDIR[dir]);
    vis[sx][sy][MDIR[dir]]=1;
    q.push(p);
    while(!q.empty()){
        p=q.front();q.pop();
        if(p.x==tx&&p.y==ty){
            printf("%d",p.t);
            return 0;
        }
        POS res;
        //若转
        for(int i=1;i<=2;i++) {
            turn(p,res,i);
            if(vis[res.x][res.y][res.dir]) continue;
            vis[res.x][res.y][res.dir]=1;
            q.push(res);
        }
        //若走 
        for(int steps=1;steps<=3;steps++)
            if(move(p,res,steps)){
                if(vis[res.x][res.y][res.dir]) continue;
                vis[res.x][res.y][res.dir]=1;
                q.push(res);
            }
            else break;
    }
    printf("-1");
}
//debug 用%c读入时注意空格 

```

---

## 作者：AKB48 (赞：0)

很显然，这个题目是一个搜索，我们可以用i，j，k来唯一标识它的状态，i表示行，j表示列，k表示方向（自己定义即可），对于每一个状态，有5种转移方式（左转，右转，前1，前2，前3），而这5种转移是等价的（均耗费时间1），因此可以很好的用广度优先搜索来解决（广搜是基于路径相等的一种搜索，在这里它搜索的不再是点，而是加上方向共同表示的状态），由于边权均为1 ，所以先搜到的状态一定是时间最少的，它不用再入队列。而对于不等价的情况（转移时时间不都是1），或是有其他转换的更复杂的情况，搜索是无法解决的，这里主要讲一下图的构建。   

一个状态可以向左转，向右转，进1,2,3，所以把每个状态与其可转移的状态连接，边权赋为所需时间， 

每一个状态即为图中的点，为了处理简便，我们用一个单独的数代表i，j，k，这里可以用放缩，即定义 

s=x\*i+y\*j+k，做到可以唯一标识每一个状态； 特别注意，这是一个有向图，你不能倒着走 时间复杂度：50\*50\*4 共10000个状态，每个点最多5条边，边数为50000，SPFA可以承受！ 

注意初始化，不能达到的点不再处理！


---

## 作者：_Lin_Xuan (赞：0)

很不爽，来发个题解。

	1这个题目第一步就是把格子的障碍转换成点的障碍，关系是对于格子坐标（x，y），点的坐标(x,y) (x-1,y) (x,y-1) (x-1,y-1)都不能走。要数以转换后横纵坐标最大值-1，不然。。。。
	2其次，BFS肯定需要标记走过的点，需要另开一个vis来保存。之前图省事放在了vis2里面，发生了不好的事情。这在注释里面解释过了。
    3还要注意的时放到队列里面时，较小的cnt值优先，所以需要先放向前的，再放其他方向。
    4然后，是只能左右转，不能向后转，这个只会卡#8，特判一下就行了（很明显我看了很多样例）。（有点敷衍，如果想写在后面的话需要在放完左右之后再放后，原因在第三点）
  ```cpp
//失误1：因为墙导致的无法继续走应该break，因为访问过而导致的无法先走应该continue
//失误2：优先走现有方向（相反步数小的）
//失误3：竟然忘记判断入列数据是否合法
//失误4：不存在的捷径！转换的时候判断是否合法的时候使用mn，实际为n-1，m-1；
//失误4：TMD不能向后转！！！！！！1 ：：只有刚开始会向后转，特判一下就可以了！
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
int cnt[100][100];
bool vis2[100][100];
bool vis[100][100];
char state[100][100];
char d[] = { '\0','E','S','W','N' };
int dx[] = { 0,0,1,0,-1 }, dy[] = { 0,1,0,-1,0 };
typedef pair<int, int> P;
queue<P> que;
int main()
{
	//freopen("C:/Users/94726/Desktop/程序题/1.txt", "r", stdin);
	//freopen("C:/Users/94726/Desktop/程序题/2.txt", "w", stdout);
	memset(cnt, -1, sizeof(cnt));
	int n, m;
	cin >> n >> m;//边界
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			int k; cin >> k;
			if (k == 1) {
				vis2[i][j] = true;
				if (i - 1 >= 1 and j - 1 >= 1) vis2[i - 1][j - 1] = true;
				if (i - 1 >= 1)vis2[i - 1][j] = true;
				if (j - 1 >= 1)vis2[i][j - 1] = true;
			}
		}//数据的读入，把格子的坐标转换成点
	//show(n, m);
	int x, y;
	cin >> x >> y;//起点
	cnt[x][y] = 0;
	vis[x][y] = true;
	que.push(make_pair(x, y));
	P end; cin >> end.first >> end.second;//终点
	cin >> state[x][y];
	//特判
	{
	int j = 0, flag = 0;
	while (state[x][y] != d[++j]);
	if (j == 1 or j == 3)
	{
		if (vis2[x + dx[j]][y + dy[j]] or x + dx[j]<1 or x + dx[j]>n - 1) flag++;
		if ( vis2[x + dx[2]][y + dy[2]] or x + dx[2]<1 or x + dx[2]>n - 1) flag++;
		if (vis2[x + dx[4]][y + dy[4]] or x + dx[4]<1 or x + dx[4]>n - 1) flag++;
	}
	if (j == 2 or j == 4)
	{
		if (vis2[x + dx[j]][y + dy[j]] or x + dx[j]<1 or x + dx[j]>n - 1) flag++;
		if (vis2[x + dx[1]][y + dy[1]] or x + dx[1]<1 or x + dx[1]>n - 1) flag++;
		if (vis2[x + dx[3]][y + dy[3]] or x + dx[3]<1 or x + dx[3]>n - 1) flag++;
	}
	if (flag == 3)  cnt[x][y] += 1;
	}

	while (!que.empty())
	{
		P s = que.front();
		if (s == end) break;
		
		int t = cnt[s.first][s.second];//现在的步数
		char sta = state[s.first][s.second];//现在的状态
		for (int i = 1; i <= 4; i++)//#1
		{
			if(sta==d[i])
				for (int j = 1; j <= 3 and vis2[s.first + dx[i] * j][s.second + dy[i] * j] == false; j++)//每次走一格，知道墙
				{
					if(s.first+dx[i]>=1 and s.first+dx[i]<=n-1 and s.second+dy[i]>=1 and s.second+dy[i]<=m-1)
					if (vis[s.first + dx[i] * j][s.second + dy[i] * j] == false) {
						que.push(make_pair(s.first + dx[i] * j, s.second + dy[i] * j));//入列
						state[s.first + dx[i] * j][s.second + dy[i] * j] = d[i];//你的状态
						cnt[s.first + dx[i] * j][s.second + dy[i] * j] = t + 1;//你的步数
						vis[s.first + dx[i] * j][s.second + dy[i] * j] = true;//你的标记
					}
				}
		}
		int k = 0; while (state[s.first][s.second] != d[++k]);
		for (int i = 1; i <= 4; i++)//有方向遍历		//#2
		{
			
			if(sta!=d[i])
				for (int j = 1; j <= 3 and vis2[s.first + dx[i] * j][s.second + dy[i] * j] == false; j++)
				{
					if (s.first + dx[i] >= 1 and s.first + dx[i] <= n-1 and s.second + dy[i] >= 1 and s.second + dy[i] <= m-1)
					if (vis[s.first + dx[i] * j][s.second + dy[i] * j] == false) {
						que.push(make_pair(s.first + dx[i] * j, s.second + dy[i] * j));
						state[s.first + dx[i] * j][s.second + dy[i] * j] = d[i];
						cnt[s.first + dx[i] * j][s.second + dy[i] * j] = t + 2;
						vis[s.first + dx[i] * j][s.second + dy[i] * j] = true;
					}
				}
		}
	que.pop();
	}
	show(n,m);
		cout << cnt[end.first][end.second]<<endl;
	return 0;
}
```


---

## 作者：Kelin (赞：0)

较为详细的题解

http://blog.csdn.net/benoble\_/article/details/54177251


---


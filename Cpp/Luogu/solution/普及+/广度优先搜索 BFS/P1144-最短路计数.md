# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# 题解

## 作者：ZiDing_ByronFinlso (赞：251)

最短路采用dijkstra堆优化或者spfa，将计数操作装进去：

![Luogu](https://cdn.luogu.com.cn/upload/pic/26623.png)

**ans[1]初始化为1**

更新边长的时候如果大于号就覆盖，相等的话（即有相同最短路径）就相加

对于无边权即使边权为1,

本题无需思考重边

下面上代码



------------


------------

spfa：（100ms）

![Luogu](https://cdn.luogu.com.cn/upload/pic/26625.png)


------------


	#include<cstdio>
	#include<iostream>
	#include<cstring>
	#include<cmath>
	#include<algorithm>
	#include<queue>
	using namespace std;
	inline int read()
	{
    	char ch=getchar(); 
		int x=0,f=1;
		while((ch>'9'||ch<'0')&&ch!='-')
    		ch=getchar();
		if(ch=='-')
		{
			f=-1;
			ch=getchar();
		}
		while('0'<=ch&&ch<='9')
		{
        	x=x*10+ch-'0';
        	ch=getchar();
    	}
		return x*f;
	}
	int mod=100003;
	int n,m,x,y,tot=0;
	const int N=1000005,M=4000005;
	int head[N],to[M],nxt[M],d[N],ans[N];
	bool p[N];
	queue< int > q;
	void add(int x,int y)
	{
		to[++tot]=y;
		nxt[tot]=head[x];
		head[x]=tot;
	}
	int main()
	{
		n=read();m=read();
		for(int i=1;i<=m;i++)
		{
			x=read();y=read();
			add(x,y);
			add(y,x);
		}
		for(int i=1;i<=n;i++)
		{
			d[i]=1e9;p[i]=0;
		}
		d[1]=0;
		p[1]=1;
		ans[1]=1;
		q.push(1);
		while(q.size())
		{
			x=q.front();q.pop();
			p[x]=0;
			for(int i=head[x];i;i=nxt[i])
			{
				y=to[i];
				if(d[y]>d[x]+1)
				{
					d[y]=d[x]+1;
					ans[y]=ans[x];
					if(!p[y])
					{
						q.push(y);
						p[y]=1;
					}
				}
				else if(d[y]==d[x]+1)
				{
					ans[y]+=ans[x];
					ans[y]%=mod;
				}
			}
		}
		for(int i=1;i<=n;i++)
			printf("%d\n",ans[i]);
		return 0;	
	} 
    
    

------------

dijkstra堆优化：（232ms）

![Luogu](https://cdn.luogu.com.cn/upload/pic/26622.png)


------------


	#include<cstdio>
	#include<iostream>
	#include<cstring>
	#include<cmath>
	#include<algorithm>
	#include<queue>
	using namespace std;
	inline int read()
	{
    	char ch=getchar(); 
		int x=0,f=1;
		while((ch>'9'||ch<'0')&&ch!='-')
    		ch=getchar();
		if(ch=='-')
		{
			f=-1;
			ch=getchar();
		}
		while('0'<=ch&&ch<='9')
		{
        	x=x*10+ch-'0';
        	ch=getchar();
   		}
		return x*f;
	}
	int mod=100003;
	int n,m,x,y,tot=0;
	const int N=1000005,M=4000005;
	int head[N],to[M],nxt[M],d[N],ans[N];
	bool p[N];
	priority_queue< pair< int,int > > q;
	void add(int x,int y)
	{
		to[++tot]=y;
		nxt[tot]=head[x];
		head[x]=tot;
	}
	int main()
	{
		n=read();m=read();
		for(int i=1;i<=m;i++)
		{
			x=read();y=read();
			add(x,y);
			add(y,x);
		}
		for(int i=1;i<=n;i++)
		{
			d[i]=1e9;p[i]=0;
		}
		d[1]=0;ans[1]=1;
		q.push(make_pair(0,1));
		while(q.size())
		{
			x=q.top().second;
			q.pop();
			if(p[x])	continue;
			p[x]=1;
			for(int i=head[x];i;i=nxt[i])
			{
				y=to[i];
				if(d[y]>d[x]+1)
				{
					d[y]=d[x]+1;
					ans[y]=ans[x];
					q.push(make_pair(-d[y],y));
				}
				else if(d[y]==d[x]+1)
				{
					ans[y]+=ans[x];
					ans[y]%=mod;
				}
			}
		}
		for(int i=1;i<=n;i++)
			printf("%d\n",ans[i]);
		return 0;
	}
    


------------

~~谢谢围观~~~~

---

## 作者：岸芷汀兰 (赞：57)

###作者：岸芷汀兰
#一、题目
[洛谷原题](https://www.luogu.org/problemnew/show/P1144)
#二、思路
很显然这是一道广搜题。为什么不是“SPFA”或“迪杰斯特拉”呢？因为题目中明确指出，“给出一个N个顶点M条边的**无向无权图**”，那么，每条边权就相当于1。很显然符合广搜的特点。
这道题麻烦在什么地方呢？
1. 自环。很显然我们可以证明，删除自环对这道题没有影响。
2. 重边。重边对这道题是有影响的，照样存储。
3. 求最短路有几条。当访问到这个节点时，如果是第一次访问，将这个节点的答案+=他父节点的答案，并将这个节点推到队尾（push）；如果是第二次访问且当前的距离等于之前记录的距离，说明这是第二条最短路，同样，将这个节点的答案+=他父节点的答案，但不需要（push）了。

这题做完了。

#三、代码
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>

using namespace std;
inline int read(void) {
    int x = 0, f = 1; char ch = getchar();
    while (ch<'0' || ch>'9') {
        if (ch == '-')f = -1;
        ch = getchar();
    }
    while (ch >= '0'&&ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return f * x;
}

inline void write(int x) {
    int y = 10, len = 1;
    while (y <= x) {
        y *= 10; len++;
    }
    while (len--) {
        y /= 10; putchar(x / y + 48); x %= y;
    }
}

const int maxn = 1000005, mod = 100003;
int n, m, ans[maxn], d[maxn];
bool vis[maxn];

vector<int>linker[maxn];

struct Node {
    int node, dis;
};

inline Node make(int first, int second) {
    Node ans; ans.node = first; ans.dis = second;
    return ans;
}

inline void connect(int x, int y) {
    linker[x].push_back(y);
}

inline void bfs(void) {
#define cur linker[u][i]

    queue<Node>q; q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    vis[1] = true;
    ans[1] = 1;
    while (q.size()) {
        int u = q.front().node, dis = q.front().dis; 
        q.pop();
        for (register int i = 0; i<int(linker[u].size()); i++) {
            if (!vis[cur]) {
                q.push(make(cur, dis + 1)); vis[cur] = true; d[cur] = dis + 1; 
                ans[cur] += ans[u]; /*重点*/ans[cur] %= mod;
            }
            else {
                if (dis + 1 == d[cur]) { ans[cur] += ans[u]; /*重点*/ans[cur] %= mod; }
            }
        }
    }
}

int main()
{
    n = read(); m = read();
    for (register int i = 1; i <= m; i++) {
        int x = read(), y = read();
        if (x == y)continue;//删除自环
        connect(x, y); connect(y, x);
    }
    bfs();
    for (register int i = 1; i <= n; i++) {
        write(ans[i] % mod); putchar('\n');
    }
    return 0;
}

```


---

## 作者：XZYQvQ (赞：56)

我发现很多人写了spfa，并且在spfa的过程中统计答案。。。

但貌似这存在一定问题（我写的就有问题）。

虽然能在luogu AC，但换道同样是统计最短路条数的题就不行了。


具体原因我不是很清楚啊。。。

不信泥萌去试试这题，vjudge上的：


<https://cn.vjudge.net/problem/UESTC-1147>

也肯能是我太弱，系统自动识别并且return WA;


至于我修改过的解法：

先跑一遍spfa，得到源点到所有点的最短路长度。

再跑一遍记忆化搜索，遍历最短路图，得到答案。


这样可以ac上面那个vjudge上的题目。。。

（害怕）


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,head[1000005],to[4000005],nxt[4000005],gsize,dis[1000005],ans[1000005];
bool book[1000005];
queue<int> que;
void adde(int u,int v){to[gsize]=v,nxt[gsize]=head[u],head[u]=gsize++;}
int dfs(int u)
{
    if(ans[u])return ans[u];
    for(int i=head[u];i!=-1;i=nxt[i])
        if(dis[u]-1==dis[to[i]])ans[u]=(ans[u]+dfs(to[i]))%100003;
    return ans[u];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)head[i]=-1,dis[i]=INT_MAX;
    for(int i=1,u,v;i<=m;i++)scanf("%d%d",&u,&v),adde(u,v),adde(v,u);
    dis[1]=0,que.push(1),book[1]=1;
    while(!que.empty())
    {
        int f=que.front();que.pop(),book[f]=0;
        for(int i=head[f];i!=-1;i=nxt[i])
            if(dis[f]+1<dis[to[i]])
            {
                dis[to[i]]=dis[f]+1;
                if(!book[to[i]])que.push(to[i]),book[to[i]]=1;
            }
    }
    ans[1]=1;for(int i=1;i<=n;i++)printf("%d\n",dfs(i));
    return 0;
}
```

---

## 作者：King丨帝御威 (赞：50)

为什么都要用spfa做这个题？堆优化的dijkstra为什么都不用？？spfa在一定条件下会被卡死哒。。。dijkstra复杂度低，而且还不会被卡，所以本蒟蒻就来给萌新们发一篇堆优化dijkstra的题解。
(如果想要模板题，请[堆优化dijkstra模板题目](https://www.luogu.org/problemnew/show/P4779))

其实这道题比上面那到模板题多的就是一个最短路的计数，怎么办呢？就是在dijkstra函数内定义一个node类型的变量，然后每次用这个变量提取队首元素，统计这个点的前驱到这个点的路径是否等于它的最短路径，然后一边算一边模即可。

具体实现见代码：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define maxn 1000000+1
#define maxn1 4000000+1
#define mod 100003
using namespace std;
inline int qread()                      //依然是快读。。。 
{
    char c=getchar();int num=0,f=1;
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) num=num*10+c-'0';
    return num*f;
}
int n,m,dis[maxn],head[maxn],s,js[maxn],num;     //dis数组表示起点到某点的最短路大小，js表示起点到某点的最短路条数。 
struct Edge
{
    int v,w,nxt;
}edge[maxn1];
inline void ct(int u,int v,int w)           //链式前向星存图。 
{
    edge[++num].v=v;
    edge[num].w=w;
    edge[num].nxt=head[u];
    head[u]=num;
}
struct node
{
    int x,y;
    bool operator < (const node &a) const            //堆优化重载运算符，使大根堆变成小根堆。 
    {
        return y>a.y;
    }
};
void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));                //初始化。 
    dis[1]=0;
    priority_queue<node>q;
    js[1]=1;                            //起点到自己的最短路条数一定是1。 
    q.push((node){1,0});
    node a;
    while(!q.empty())                             //dijkstra经典套路操作。 
    {
        a=q.top();                              //用这个node类型变量提取队首元素。 
        int u=a.x,d=a.y;                       
        q.pop();
        if(d!=dis[u]) continue;                   //一个小优化。 
        for(int i=head[u];i;i=edge[i].nxt)
        {
            int v=edge[i].v;
            if(d+edge[i].w==dis[v])
              js[v]=(js[u]+js[v])%mod;             //一边计算一边模。 
            if((dis[v]>dis[u]+edge[i].w))
            {
                dis[v]=dis[u]+edge[i].w;
				js[v]=js[u];                      //找到一条更短的路径是，用它的前驱的js换它。 
                q.push((node){v,dis[v]});
            }
        }
    }
}
int main()
{
	n=qread(),m=qread();
	for(int i=1,u,v;i<=m;++i)
	{
		u=qread(),v=qread();
		ct(u,v,1);                           //无向边存两遍。 
		ct(v,u,1);
	}
	dijkstra();
	for(int i=1;i<=n;++i)
		cout<<js[i]<<'\n';                   //依次输出就好了。 
	cout<<'\n';
	return 0;
}
```

有什么不懂的地方可以私信或博客评论问我qwq！。。

---

## 作者：KesdiaelKen (赞：31)

这一道题实际上是一道很经典的搜索题，但是仍有很多人（包括我）被数据范围给吓到了，所以写了一个SPFA。

然而我翻了一下楼下各神犇的SPFA解法，发现了一个问题。由于此题的特殊性（每条边边权都是1），所以此题写SPFA其实可以当成一个广度优先搜索，不会有重复计数。然而，假如边有不同的边权，则对于如下图： ![](https://cdn.luogu.com.cn/upload/pic/7886.png) 从1出发，首先将2入队，再将3入队。此时，2节点的最短路条数为1。此时，1出队，2作为新的更新点，将4的最短路条数更新为1。然后，2出队，3作为出发点，更新2的最短路条数为2。此时，2又一次入队，将4的最短路条数更新为1+2=3。然而，易发现到4的最短路条数只有两条（1->2->4&1->3->2->4）。原因是有一条到2的最短路被重复计数了。因此，虽然在此题中没有必要，但是为了通用性，可以将SPFA的计数方式进行调整（具体请见代码（打字详解？会累死的））。

下为代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstdlib>
using namespace std;
struct Edge//邻接表存边
{
    int t;
    int nexty;
}edge[3000000];
int head[2000000]={0};//邻接表的东东（存以i为发出点的编号最大的边的编号）……有人不懂吗
int cnt=0;
inline void add(int a,int b)//邻接表添加边
{
    cnt++;
    edge[cnt].t=b;
    edge[cnt].nexty=head[a];
    head[a]=cnt;
}
int js[2000000]={0};//每一个点的最短路径条数
int rdjs[2000000]={0};//用来避免重复的统计表，存当前在队列中，到节点i的最短路径条数
int dis[2000000];//存最短路径
bool in[2000000]={0};//是否在队列中
queue<int>spfa;//SPFA所用队列
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int a,b;
    for(int i=0;i<m;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);//存边
    }
    for(int i=1;i<=n;i++)dis[i]=2e9;
    dis[1]=0;//初始化dis
    in[1]=true;
    js[1]=1;//1到1最短路径1条
    rdjs[1]=1;//此次队列中，到1的最短路径条数为1
    spfa.push(1);//将1加入队列
    int curr;
    while(!spfa.empty())
    {
        curr=spfa.front();//更新发出点
        for(int i=head[curr];i!=0;i=edge[i].nexty)//遍历出发边
        {
            if(dis[edge[i].t]>dis[curr]+1)//若最短路有变
            {
                dis[edge[i].t]=dis[curr]+1;//更新最短路
                rdjs[edge[i].t]=js[edge[i].t]=rdjs[curr]%100003;//以前的计数均舍弃，更新到出发点的到达路径条数
                if(!in[edge[i].t])
```
{//加入队列
```cpp
                    in[edge[i].t]=true;
                    spfa.push(edge[i].t);
                }
            }
            else
            if(dis[edge[i].t]==dis[curr]+1)//若又有一条最短路
            {
                js[edge[i].t]=(js[edge[i].t]+rdjs[curr])%100003;//增加最短路个数
                rdjs[edge[i].t]=(rdjs[edge[i].t]+rdjs[curr])%100003;//在rdjs上更新，避免重复
                if(!in[edge[i].t])
```
{//入队
```cpp
                    in[edge[i].t]=true;
                    spfa.push(edge[i].t);
                }
            }
        }
        in[curr]=false;
        rdjs[curr]=0;//此次的最短路统计已用完，将此节点的最短路条数初始化，避免重复（在此题中似乎并没有什么用）
        spfa.pop();//出队
    }
    for(int i=1;i<=n;i++)printf("%d\n",js[i]);//输出
    return 0;
}
```

---

## 作者：Rbrq (赞：24)

做了一下午终于A了这题，谈谈心得。

这题主要思路是这样的，在SPFA中加入计数操作，如果这个点的最短路可以更新但还未被更新既
```cpp
if(dis[v]>dis[u]+1)
```
那么很显然，目前我们可以知道的可到达这个点的最短路就是通过先到达上个点再走当前边的方式，易推得代码
```cpp

ans[v]=ans[u];

```

当一个点不能被当前点更新时，判断如果这个点的距离等于当前点距离+1的话，那么就如同上面的情况，可到达这个点的最短路有一种是通过先到达上个点再走当前边的方式得到的，那么我们就把这个情况加上，可得代码

```
ans[v]+=ans[u]
```
将这个计数方法放到SPFA的模板中就可以ac本题


------------

几个注意事项

1.边加边膜 防止爆int 

2.ans[1]=1。因为很显然，从一到一的最短路有且只有一条、

3.存双向边

4.自环和重边并不会对本题造成影响

贴上ac代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=100003;
const int Maxn=1000010;
const int MAxn=5000010;
const int MAXn=0x7fffffff;
struct st{
	int to,nxt;
}edge[MAxn];
int n,m,cnt=0,dis[Maxn];
int head[Maxn],vis[Maxn],ans[Maxn];
inline void add_edge(int u,int v){
	edge[++cnt].nxt=head[u];
	edge[cnt].to=v;
	head[u]=cnt;
}
inline void SPFA(int s){
	for(int i=1;i<=n;++i) dis[i]=MAXn;
	dis[s]=0; vis[s]=1;
	queue<int> Q;
	Q.push(s);
	while(!Q.empty()){
		int u=Q.front(); 
		Q.pop();vis[u]=0;
		for(int i=head[u];i;i=edge[i].nxt){
			int v=edge[i].to;
			if(dis[v]>dis[u]+1){
				dis[v]=dis[u]+1;
				ans[v]=ans[u];
                ans[v]%=mod;
				if(!vis[v]){
					vis[v]=1;
					Q.push(v);
				}
			}
			else if(dis[v]==dis[u]+1){
				ans[v]+=ans[u];
				ans[v]%=mod;
			}
		}
	}
} 
int main(){
	ans[1]=1;
	memset(vis,0,sizeof(vis));
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;++i){
		int x,y;
		scanf("%d %d",&x,&y);
		add_edge(x,y);
		add_edge(y,x);
	}
	SPFA(1);
	for(int i=1;i<=n;++i) printf("%d\n",ans[i]);
	return 0;
}
``` 

附ac时间

![404](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fvm0k6cte9j30ez049gll.jpg)

裂屏推荐本人博客，希望互相学习

---

## 作者：Xie_BR (赞：18)

这是一道最短路计数问题

用dij是个很好的办法

因为dij的计数方式很简单。。。


附上AC代码。。。

```cpp
#include<bits/stdc++.h>
#define int long long
#define M 6000000
#define N 1000010
#define mod 100003
using namespace std;
int n,m;

struct edge
{
	int next,to,v;
}e[M];

int ei = 0;
int h[N];

int add(int x,int y,int v)
{
	ei++;
	e[ei].v = v;
	e[ei].to = y;
	e[ei].next = h[x];
	h[x] = ei;
}

struct Heapdata
{
	int id,v;
	bool operator <(const Heapdata&x)const
	{
		return v > x.v; 
	}
};

Heapdata heap[M];
int hpi = 0;

int pushheap(int id,int v)
{
	hpi++;
	heap[hpi].id = id;
	heap[hpi].v = v;
	push_heap(heap+1,heap+hpi+1);
}

int popheap()
{
	pop_heap(heap+1,heap+hpi+1);
	int id = heap[hpi].id;
	hpi--;
	return id;
}

int dis[M];
int u[M];
int cnt[N];

int dij(int f)
{
	memset(dis,0x3f,sizeof(dis));
	memset(u,0,sizeof(u));
	memset(cnt,0,sizeof(cnt));
	cnt[f] = 1;
	dis[f] = 0;
	pushheap(f,0);
	while(hpi)
	{
		int id = popheap();
		if(u[id]==1)
		{
			continue;
		}
		u[id] = 1;
		for(int i=h[id];i;i=e[i].next)
		{
			int to = e[i].to;
			if(dis[to]>dis[id]+e[i].v)
			{
				dis[to] = dis[id]+e[i].v;
				pushheap(to,dis[to]);
				cnt[to] = cnt[id];
				cnt[to] = cnt[to]%mod;
			}else 
			{
				if(dis[to]==dis[id]+e[i].v)
				{
					cnt[to] += cnt[id];
					cnt[to] = cnt[to]%mod;
				}
			}
		}
	}
}

signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x;
		int y;
		scanf("%lld%lld",&x,&y);
		add(x,y,1);
		add(y,x,1);
	}
	dij(1);
	for(int i=1;i<=n;i++)
	{
		printf("%lld\n",cnt[i]);
	}
	return 0;
}
```


---

## 作者：TsReaper (赞：14)

由于边没有边权，所以点1到每一个点的最短路只需要用BFS就可以算出来了。BFS的过程中，如果从点x出发，碰到未入队的点y，那么count(y) = count(x)；如果y已入队，则需要distance(y) == distance(x)+1才可以count(y) += count(x)。


---

## 作者：George1123 (赞：12)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1144 【最短路计数】](https://www.luogu.org/problem/P1144)

### 此题算法: Dijkstra+拓扑dp

大致思路:

>1.$ $输入边并求出顶点$1$到每个点$i$的最短路长度$dis[i]$。

>2.$ $将边拆成单向边并分成以下两种情况。

![](https://s2.ax1x.com/2019/09/21/nz5Sc8.jpg)

    (从u到v)
     
    甲：dis[u]+1=dis[v]
    (能协助最短路的边，留着)
    乙：dis[u]+1>dis[v]
    (不能协助最短路的边，扔了)

>3.$ $用留着的边拓扑排序。将$0$入度并有用的点$i$加进队列，$dp[i]=1$。再使$dp[$出边$]=$所有$dp[$入边$]$之和即可。

>4.$ $最后对于每个$i$，$dp[i]$就是答案。

![](https://s2.ax1x.com/2019/09/21/nzOt29.jpg)

## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ong long long
const int N=1000010;
const int M=4000010;
const int mod=100003;
const int inf=INT_MAX/3;  //不爆int
bool vis[N],em[M];
struct node{
    int a,dis;
};
bool operator < (node x,node y){
    return x.dis>y.dis;
} priority_queue<node> q;
struct Edge{
    int from,adj,nex;
}e[M];
int top,fro[N],rud[N],dp[N];
void add(int x,int y){
    e[++top]=(Edge){x,y,fro[x]};
    fro[x]=top;
} int n,m,ui,vi,dis[N];
queue<int> tp;
void Dijkstra(){
    for(int i=1;i<=n;i++)
        dis[i]=inf;
    dis[1]=0;
    for(int i=1;i<=n;i++)
        q.push((node){i,dis[i]});
    while(!q.empty()){
        node tmp=q.top(); q.pop();
        int p=tmp.a;
        if(vis[p])
            continue;
        vis[p]=1;
        for(int i=fro[p];i;i=e[i].nex){
            int to=e[i].adj;
            if(dis[p]+1<dis[to]){
                dis[to]=dis[p]+1;
                q.push((node){to,dis[to]});
            }
        }
    }
} void inc(int &x,int y){
	x=(x+y)%mod; //记得mod100003
}int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&ui,&vi);
        add(ui,vi); add(vi,ui);
    } Dijkstra();
    for(int i=1;i<=top;i++){
    	if(dis[e[i].adj]
		-dis[e[i].from]==1){
			em[i]=1;
			rud[e[i].adj]++;
		}
	} for(int i=1;i<=n;i++){
		if(rud[i]==0){
			if(dis[i]<inf)
				dp[i]=1; //☆判有用
			tp.push(i);
		}
	} while(!tp.empty()){
		int now=tp.front(); tp.pop();
		for(int i=fro[now];i;i=e[i].nex){
			if(!em[i]) continue;
			int p=e[i].adj;
			inc(dp[p],dp[now]); //dp(inc为程序上方增加函数)
			rud[p]--;
			if(!rud[p])
				tp.push(p);
		}
	} for(int i=1;i<=n;i++)
        printf("%d\n",dp[i]);
    return 0;
}
```

最后别忘记自古图论出坑题!

谢谢大家! !


---

## 作者：扬皓2006 (赞：9)

本题吧...只需在SPFA和Dijksra的基础上加上一个ans数组和几行代码！

注意是无向无权图哦
SPFA解法:
```
#include<bits/stdc++.h>//万能头
#define inf 0x3f
using namespace std;
int n,m,tot,x,y;
int hea[2000001],ans[1000001],d[2000001],v[2000001];
struct Edge{
	int next,to,dis;
}edge[2000001];//邻接表存图
queue<int> q;//队列
void add(int x,int y,int z)
{
	edge[++tot].next=hea[x];
	edge[tot].to=y;
	edge[tot].dis=z;
	hea[x]=tot;
}//插入一条(x,y)，权值为z的边
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,1);
		add(y,x,1);
	} //存图
	memset(d,inf,sizeof(d));
	memset(v,0,sizeof(v));
	d[1]=0;v[1]=1;ans[1]=1;q.push(1);
	while(!q.empty())//队列非空
	{
		int x=q.front();q.pop();v[x]=0;
		for(int i=hea[x];i;i=edge[i].next)
		{
			int y=edge[i].to;
			if(d[y]>edge[i].dis+d[x])
			{
				d[y]=edge[i].dis+d[x];
				ans[y]=ans[x];
				if(!v[y])
				{
					q.push(y);
					v[y]=1;
				}
			}//松弛操作
			else if(d[y]==d[x]+1)
			{
				ans[y]+=ans[x];
				ans[y]%=100003;
			}//如果同为最短路就加加
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<ans[i]<<endl;
	}
}
```
Dijkstra解法:
```
#include<bits/stdc++.h>//万能头
#define inf 0x3f
using namespace std;
int n,m,x,y,z,tot=0,s;
int d[2000001],v[2000001],hea[2000001],ans[2000001];
priority_queue< pair<int,int> > q;//第一维为距离相反数（变变变！小根堆），第二维为节点编号
struct Edge{
	int next,to,dis;
}edge[2000001];//邻接表存图
void add(int x,int y,int z)
{
	edge[++tot].next=hea[x];
	edge[tot].to=y;
	edge[tot].dis=z;
	hea[x]=tot;
}//插入一条(x,y)，权值为z的边
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,1);
		add(y,x,1);
	}//存边
	memset(d,inf,sizeof(d));
	memset(v,0,sizeof(v));
	d[1]=0;ans[1]=1;q.push(make_pair(0,1));
	while(!q.empty())//队列非空
	{
		int x=q.top().second;q.pop();
		if(v[x]) continue;
		v[x]=1;
		for(int i=hea[x];i;i=edge[i].next)
		{
			int y=edge[i].to;
			if(d[y]>d[x]+edge[i].dis)
			{
				d[y]=d[x]+edge[i].dis;
				ans[y]=ans[x];
				q.push(make_pair(-d[y],y));
			}//松弛操作
			else if(d[y]==d[x]+edge[i].dis)
			{
				ans[y]+=ans[x];
				ans[y]%=100003;
			}//如果同为最短路就计数
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<ans[i]<<endl;
	}
	return 0;
}
```
最后，希望同学们都能A掉这道题（当然我不希望你们是抄题解A的），并希望管理大大能够通过这篇题解！

---

## 作者：圣堂之地 (赞：6)

第一次发题解，如有错误还请帮我指出，谢谢！
```
#include<bits/stdc++.h>
using namespace std;

const int MAX=1000005;
const int MOD=100003;

queue <int> q;//将每个点遍历一遍 
vector <int> f[MAX];//存图 

bool inq[MAX];//看这个点有无拓展，0为未拓展，点在拓展后变为0，被其他点拓展则为1 
int sum[MAX];//代表这个点的最短路径数 
int d[MAX];//到点1的最短距离
int n,m;

/*  
例如： u-->v 权值为c 
	当d[u]=d[v]+c,则sum[u]+=sum[v],即v为u的一最短路 
	当d[u]>d[v]+c,则sum[u]=sum[v],即v就是u的最短路 
*/

inline int read(){
	int f=1,x=0;char c=getchar();
	while(c<'0'||c>'9'){ if(c=='-') f=-1; c=getchar();}
	while(c>='0'&&c<='9'){ x=10*x+c-'0'; c=getchar();}
	return x*f;
}


inline void write(int x){
    int y=10,len=1;
    while(y<=x){ y*= 10; len++;}
    while(len--){ y/=10;putchar(x/y+48); x%=y;}
}

int main(){
	n=read();
	m=read();
	int u,v;//从u到v 
	for(int i=1;i<=m;i++){
		u=read();
		v=read();
		f[u].push_back(v);//由u指向v 
		f[v].push_back(u);//由v指向u
	}
	
	memset(d,0x3f,sizeof(d));	
	inq[1]=1;
	sum[1]=1;
	d[1]=0; 
	q.push(1);//初始化
	 
	while(!q.empty()){
		
		u=q.front(),q.pop();
		inq[u]=0;
		
		for(int i=0;i<f[u].size();i++){ 
		
			v=f[u][i];//f[x][i](v)是下一个点
			
			if(d[v]==d[u]+1){
				sum[v]+=sum[u];
				sum[v]%=MOD;
			}//注意了！！ 如果有双向边的时候会重复跑,所以我们就单独判断 
			else if(d[v]>d[u]+1){
				sum[v]=sum[u];
				d[v]=d[u]+1;
				
				if(!inq[v]){
					inq[v]=1;
					q.push(v);
				} 
				
			}


		}
	}
	
	for(register int i=1;i<=n;i++){
        write(sum[i]%MOD); 
		putchar('\n');
    }
        
	return 0;
} 
```


---

## 作者：EarthGiao (赞：4)

## 【思路】
最短路 ， dijkstra   

### 【题目大意】 
从1到每一个点的最短路有多少条   

### 【核心思路】
最短路有多少条？     
完全可以在dijkstra或者SPFA的过程中求出来的   
因为在松弛操作的时候   
用y到x的边去松弛    
如果这条边替换上去会使1到x的距离更近    
那这个时候x的答案就会变为松到他y的最短路的个数   
如果这条边替换上去和原来一样    
那就是目前看来可以当做最短路    
在x原来最短路个数的基础上加上到点y最短路的个数就可以了      
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>

using namespace std;

int read()
{
	int sum = 0,fg = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')fg = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		sum = sum * 10 + c - '0';
		c = getchar();
	}
	return sum * fg;
}
const int Max = 2000006;
const int mo = 100003;
struct node
{
	int y,ne;
}a[Max << 1];
int head[Max >> 1],sum = 0;

void add(int x,int y)
{
	a[++ sum].y = y;
	a[sum].ne = head[x];
	head[x] = sum;
}

struct point
{
	int x;
	int w;
	bool operator < (const point xx) const
	{
		return xx.w < w;
	}
};
int dis[Max >> 1];
priority_queue<point>q;
int ans[Max >> 1];
bool use[Max >> 1];
void dj()
{
	memset(dis,0x3f,sizeof(dis));
	dis[1] = 0;
	ans[1] = 1;
	q.push((point){1,0});
	while(!q.empty())
	{
		point qwq = q.top();
		q.pop();
		int x = qwq.x,w = qwq.w;
		if(use[x] == true)
			continue;
		else
			use[x] = true;
		for(register int i = head[x];i != 0;i = a[i].ne)
		{
			int awa = a[i].y;
			if(dis[awa] > dis[x] + 1)
			{
				dis[awa] = dis[x] + 1;
				ans[awa] = ans[x];
				if(use[awa] == false)
					q.push((point){awa,dis[awa]});
			}
			else
			if(dis[awa] == dis[x] + 1)
			{
				ans[awa] += ans[x];
				ans[awa] %= mo;
			}
		}
	}
}

int main()
{
	int n = read(),m = read();
	for(register int i = 1;i <= m;++ i)
	{
		int x = read(),y = read();
		add(x,y);
		add(y,x);
	}
	dj();
	for(register int i = 1;i <= n;++ i)
		cout << ans[i] << endl;
	return 0;
}
```

---

## 作者：jiangXxin (赞：4)

看题目，考虑最短路，发现权值为1，那么我们就可以直接bfs了.

因为bfs的特殊性质，我们就可以得到，第一次到达此点，一定是它的最短路.

所以我们就可以以1为根节点，那么我们的BFS搜索树中点的深度(权值为1)，就是它的最短路长度.

**对于每一个点，它的相邻深度点一定是在同一最短路中**，我们在此做一个标记，由它的父亲节点更新答案,就可以得到每个点的最短路条数。

**Code:**

**Python**:(队列是手写队列，python自带的队列太慢了)


```python
#import queue
#que=queue.Queue(maxsize=0)
mod=100003
s=input().split()
n=int(s[0])
m=int(s[1])

next=[0 for i in range(1200000)]
num=[0 for i in range(1200000)]
to=[0 for i in range(1200000)]
vis=[0 for i in range(1200000)]
deep=[0 for i in range(1200000)]
ans=[0 for i in range(1200000)]
que=[0 for i in range(1200000)]
tot=0

for i in range(m):
    s=input().split()
    x=int(s[0])
    y=int(s[1])
    
    tot+=1
    next[tot]=num[x]
    to[tot]=y
    num[x]=tot

    tot+=1
    next[tot]=num[y]
    to[tot]=x
    num[y]=tot
#建立无向图
vis[1]=1
ans[1]=1
que[1]=1
l=1
r=1
while (l<=r):#队列
    x=que[l]
    i=num[x]
    while(i):
        y=int(to[i])
        if(vis[y]==0):
            vis[y]=1
            deep[y]=deep[x]+1
            r+=1
            que[r]=y
            #que.put(y)

        if(deep[y]==deep[x]+1):
            ans[y]=(ans[y]+ans[x])%mod
        i=next[i]
    l+=1

for i in range(1,n+1):#输出答案
    print(ans[i])

```

**C++:**

```cpp
/**
*    author:  a2954898606
*    created: 2019/10/22 20:12:15
**/
#include<bits/stdc++.h>
#define REP(A,B,I) for(int I=(A);I<=(B);I++)
#define PER(A,B,I) for(int I=(A);I>=(B);I--)
#define read(FILENAME) freopen((FILENAME + ".txt"), "r", stdin);
#define write(FILENAME) freopen((FILENAME + ".txt"), "w", stdout);
#define LL long long
#define N 1000010
#define M 100
using namespace std;
const long long mod=100003;
long long quickmul(long long a,long long b){
    a%=mod;b%=mod;
    long long c=(long long)a*b/mod;
    long long ret=a*b-c*mod;
    if(ret<0)ret+=mod;
    else if(ret>=mod)ret-=mod;
    return ret;
}
long long quickpow(long long a,long long b){
    long long ret=1;
    while(b){
        if(b&1)ret=ret*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ret;
}
int n,m,u,v;
queue<int>que;
vector<int> vt[N];
bool vis[N];
int ans[N],deep[N];
void bfs(){
    vis[1]=1,ans[1]=1;
    que.push(1);
    while(!que.empty()){
        int x=que.front();
        que.pop();
        int len=vt[x].size()-1;
        REP(0,len,i){
            int y=vt[x][i];
            if(!vis[y]){
                vis[y]=1;
                deep[y]=deep[x]+1;
                que.push(y);
            }
            if(deep[y]==deep[x]+1){///是相邻深度节点
                ans[y]=(ans[x]+ans[y])%mod;
            }
        }
    }
    return;
}
int main(){
    //read(1)
    //write(1)
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n>>m;
    REP(1,m,i){
        cin>>u>>v;
        vt[u].push_back(v);
        vt[v].push_back(u);
    }
    bfs();
    REP(1,n,i){
        cout<<ans[i]<<endl;
    }
    return 0;
}

```


---

## 作者：神之右大臣 (赞：4)

想必大家都会求最短路吧，这里就不再多说了；

我看有很多人在一顿套模板，什么dijkstra,SPFA等等,这是可以的；

但身为OIer，思路要开阔对不对？

首先我们注意到，我们可以利用bfs来求每个点的深度。因为在所有边边权为1的时候，点的深度就是点的最短距离；

这样在写法上便少了队列优化SPFA中退栈时还要把标记抹除这一操作，会大大提高算法速度；

在bfs的时候，我们不仅仅要从一个点的父亲继承最短路，还要继承方案数；

有个细节，起点的方案数要记为1；

```cpp
#include <bits/stdc++.h>
#define int long long
#define p 100003
using namespace std;
struct littlestar{
	int to;
	int nxt;
}star[4000010];
int head[4000010],cnt;
inline void add(register int u,register int v)
{
	star[++cnt].to=v;
	star[cnt].nxt=head[u];
	head[u]=cnt;
}
int n,m;
long long g[1000010];
int dis[1000010],vis[1000010];
queue<int> q;
int st,ed;
inline void bfs(register int s)
{
	memset(g,0,sizeof(g));
	memset(dis,0x3f,sizeof(dis));
	q.push(s);
	dis[s]=0;
	vis[s]=1;
	g[s]=1;
	while(q.size()){
		register int u=q.front();
		q.pop();
		for(register int i=head[u];i;i=star[i].nxt){
			register int v=star[i].to;
			if(dis[v]==dis[u]+1) g[v]=(g[u]+g[v])%p;
			if(vis[v]) continue;
			vis[v]=1;
			dis[v]=dis[u]+1;
			g[v]=g[u]%p;
			q.push(v);
		}
	}
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(register int i=1;i<=m;i++){
		register int u,v;
		scanf("%lld%lld",&u,&v);
		add(u,v);
		add(v,u);
	}
	bfs(1);
	for(int i=1;i<=n;i++){
		printf("%lld\n",g[i]);
	}
}
```


有闲时间的读者可以看一下这道题的扩展：

一张N*M的无向图，有k个特殊的点；你从1号点出发，必须停留且只停留在一个特殊点休息一段时间，然后到达n号点；(可以一次经过多个特殊点，但如果在不同的特殊点停留休息，就算不同种方案)；求符合条件的**最短路**的**方案数**；

其实这道题稍加思考就可以得到正解：分别从1号点和n号点bfs()求出每个点到1号点和n号点的最短路及最短路下的方案数；我们根据乘法原理把最短路下的方案数乘起来就可以了；


```cpp
#include <bits/stdc++.h>
#define int long long
#define p 1000000007
using namespace std;
struct littlestar{
	int to;
	int nxt;
}star[8000010];
int head[8000010],cnt;
void add(int u,int v)
{
	star[++cnt].to=v;
	star[cnt].nxt=head[u];
	head[u]=cnt;
}
int n,m;
char s[1010][1010];
int query[1010][1010];
long long g[1000010];
int water[1000010];
int dis[1000010],vis[1000010];
queue<int> q;
int st,ed;
void bfs(int s)
{
	memset(g,0,sizeof(g));
	memset(dis,0x3f,sizeof(dis));
	q.push(s);
	dis[s]=0;
	vis[s]=1;
	g[s]=1;
	while(q.size()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=star[i].nxt){
			int v=star[i].to;
			if(dis[v]==dis[u]+1) g[v]=(g[u]+g[v])%p;
			if(vis[v]) continue;
			vis[v]=1;
			dis[v]=dis[u]+1;
			g[v]=g[u]%p;
			q.push(v);
		}
	}
}
int stdis[1000010];
long long stg[1000010];
signed main()
{
	scanf("%lld%lld",&n,&m);
	int num=0;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			query[i][j]=++num;
		}
	}
	for(register int i=1;i<=n;i++){
		scanf("%s",s[i]+1);
	}	
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			if(s[i][j]=='@') st=query[i][j];
			if(s[i][j]=='#') ed=query[i][j];
			if(s[i][j]=='*') water[++water[0]]=query[i][j];
			if(s[i][j]=='X') continue;
			if(i-1>0&&s[i-1][j]!='X'){
				add(query[i][j],query[i-1][j]);
			}
			if(j-1>0&&s[i][j-1]!='X'){
				add(query[i][j],query[i][j-1]);
			}
			if(i+1<=n&&s[i+1][j]!='X'){
				add(query[i][j],query[i+1][j]);
			}
			if(j+1<=m&&s[i][j+1]!='X'){
				add(query[i][j],query[i][j+1]);
			}
		}
	}
	bfs(st);
	for(int i=1;i<=num;i++) stdis[i]=dis[i],stg[i]=g[i];
	memset(vis,0,sizeof(vis));
	bfs(ed);
	int ans=INT_MAX;
	for(int i=1;i<=water[0];i++){
		ans=min(ans,stdis[water[i]]+dis[water[i]]);
	}
	long long fians=0;
	for(int i=1;i<=water[0];i++){
		if(stdis[water[i]]+dis[water[i]]==ans){
			fians=(fians+stg[water[i]]*g[water[i]]%p)%p;
		}
	}
	if(ans==INT_MAX){
		cout<<"-1 0";
		return 0;
	}
	cout<<ans<<" "<<fians;
}
/*
3 3
@..
.*.
*.#



4 4
@...
....
....
...#

*/
```



---

## 作者：Utsuji_risshū (赞：3)

SPFA、Dij等等方法相信楼上下已经讲烂掉了，这里不再重复，只是想就本题谈一谈最短路计数使用真正的正确姿势和在本题里的特殊之处。先放本人几种代码略讲一下。

Dijkstra(如果码风能够被接受的话)：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
const int MOD=100003;
const int INF=0x3f3f3f3f;
const int N=1000000+7;
const int M=2000000+7;
inline int read(){
    int x=0,f=0;char ch;
    while(!isdigit(ch=getchar()))if(ch=='-') f=1;
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
    return f?-x:x;
}
priority_queue <pii,vector<pii>,greater<pii> > q;
int v[M<<1],Head[N],Next[M<<1],dis[N],ans[N];
int n,m,x,y,tot;

inline void Addedge(){
    v[++tot]=y,Next[tot]=Head[x],Head[x]=tot;v[++tot]=x,Next[tot]=Head[y],Head[y]=tot;
}

void dijkstra(int u){
    memset(dis,INF,sizeof(dis));ans[u]=1;
    q.push(make_pair(dis[u]=0,u));
    while(!q.empty()){
        int d=q.top().first,x=q.top().second;q.pop();
        if(d!=dis[x]) continue;//这里是个人习惯。不想开vis数组了，直接判断是否被访问拓展过
        for(register int j=Head[x];j;j=Next[j]){
            int y=v[j];
            if(dis[y]>dis[x]+1){
            	dis[y]=dis[x]+1;
            	ans[y]=ans[x];
            	q.push(make_pair(dis[y],y));
            } 
            else if(dis[y]==dis[x]+1) ans[y]=(ans[x]+ans[y])%MOD;
        }
    }
}

int main(){
    n=read(),m=read();
    for(register int i=1;i<=m;++i) x=read(),y=read(),Addedge();
    dijkstra(1);
    for(register int i=1;i<=n;++i) printf("%d\n",ans[i]);
    return 0;
}
```
spfa:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD=100003;
const int INF=0x3f3f3f3f;
const int N=1000000+7;
const int M=2000000+7;
inline int read(){
    int x=0,f=0;char ch;
    while(!isdigit(ch=getchar()))if(ch=='-') f=1;
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
    return f?-x:x;
}
queue <int> q;
int v[M<<1],Head[N],Next[M<<1],dis[N],ans[N];
bool vis[N];
int n,m,x,y,tot;

inline void Addedge(){
    v[++tot]=y,Next[tot]=Head[x],Head[x]=tot;v[++tot]=x,Next[tot]=Head[y],Head[y]=tot;
}

void SPFA(int u){
    memset(dis,INF,sizeof(dis));
    ans[u]=1;dis[u]=0;vis[u]=1;q.push(u);
    while(!q.empty()){
        int x=q.front();q.pop();vis[x]=0;
        for(register int j=Head[x];j;j=Next[j]){
            int y=v[j];
            if(dis[y]>dis[x]+1){
                dis[y]=dis[x]+1,ans[y]=ans[x];
                if(!vis[y])vis[y]=1,q.push(y);
            }
            else if(dis[y]==dis[x]+1) ans[y]=(ans[x]+ans[y])%MOD;
        }
    }
}

int main(){
    n=read(),m=read();
    for(register int i=1;i<=m;++i) x=read(),y=read(),Addedge();
    SPFA(1);
    for(register int i=1;i<=n;++i) printf("%d\n",ans[i]);
    return 0;
}
```
然而上面的spfa方法其实**仅适用于本题**，如果你把这个代码搬到[P1608](https://www.luogu.org/problemnew/show/P1608)就会WA掉了，对比两题，主要区别在于边权的有无，P1608中spfa一个节点累计方案后对周围节点如果也产生影响，它出队后如果哪天再被累计上就不会更新周围节点了。比如：
```cpp
n=5,m=5
边(x-->y单向,权w):
1 2 1
2 3 1
3 4 1
1 4 3
4 5 2
```
所以spfa的累计(从1到n)应该是长这样的：
```cpp
void SPFA(int u){
    memset(dis,INF,sizeof(dis));
    ans[u]=1;dis[u]=0;vis[u]=1;q.push(u);
    while(!q.empty()){
        int x=q.front();q.pop();vis[x]=0;
        if(x==n) continue;//不能把答案清零掉
        for(register int j=Head[x];j;j=Next[j]){
            int y=v[j];
            if(dis[y]>dis[x]+w[j]) dis[y]=dis[x]+w[j],ans[y]=ans[x];
            else if(dis[y]==dis[x]+w[j]) ans[y]+=ans[x];
            if(!vis[y]&&ans[y])vis[y]=1,q.push(y);//被更新方案就要再入队。
        }
        ans[x]=0;//防止↑上面入队带来重复累计，这里清零。
    }
}
```
如果像dij一样每次取堆里距离最小的开始松弛，不会有像spfa一样松弛掉的点不在队里，而是可以保证每个点方案都被累计（因为松弛掉的点在堆里还出不来）。本题中由于没有边权，spfa其实就是一个BFS，或者更大胆的说，本题中spfa和dijkstra**过程是几乎一样的**，都是把松弛点压入队中，并且保证了队首点dis值最小，所以没有区别，只不过dijkstra还要花时间处理优先队列，所以dij在本题中一般来说比spfa慢一些（不服的不要怼我）。

~~突然感觉自己扯了半天，什么实质性的东西没怎么说~~

---

## 作者：xiwang (赞：3)

看到没人用dijkstra 我来水一发

代码：



```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,st,ed;
const int maxn=1000010;
const int maxm=2000010;
const int fuck=100003;
struct edge{
    int to,val,next;
}G[maxm];
int head[maxn],tot=0;
int f[maxn];
struct node{
    int i,di;
};
bool operator <(node a,node b){return a.di>b.di;}
priority_queue<node>q;//堆优化啥的
#define AOE add_oriented_edge
void add_oriented_edge(int start,int end,int weight){//几个月前打的邻接表 
    G[tot].to=end;//加条有向边 
    G[tot].val=weight;
    G[tot].next=head[start];
    head[start]=tot++;
}
void add_edge(int node1,int node2,int weight){
    add_oriented_edge(node1,node2,weight);
    add_oriented_edge(node2,node1,weight);//加条无向边，就是搞俩有向边 
}
void init(){
    int x,y,z;
    memset(head,-1,sizeof(head));//输入 
    scanf("%d%d",&n,&m);
    st=1;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        add_edge(x,y,1);//无权图？把边权全部设为1就不用改了
    }
}
int dis[maxn];
void doit(int o){//隔壁P1339来的堆优化dijkstra 
    memset(dis,0x7f,sizeof(dis));
    memset(f,0,sizeof(f));
    q.push((node){st,0});
    node tmp;
    dis[o]=0;
    f[o]=1;
    for(;!q.empty();){
        tmp=q.top();
        q.pop();
        if(dis[tmp.i]!=tmp.di)continue;
        for(int i=head[tmp.i];i!=-1;i=G[i].next){
            int v=G[i].to;
            if(tmp.di+G[i].val==dis[v]){//如果通过tmp点访问v点刚好是最短路，累加路径条数 
                f[v]=(f[tmp.i]+f[v])%fuck;//边加边膜
            }
            if(tmp.di+G[i].val<dis[v]){//如果更新了tmp点到v点的最短路，之前的不算，重新来过。 
                dis[v]=tmp.di+G[i].val;
                f[v]=f[tmp.i];
                q.push((node){v,dis[v]});
```
}//其实统计部分跟SPFA差不多.....

```cpp
        }
    }
}
int main(){
    init();
    doit(st);
    for(int i=1;i<n;i++){
        printf("%d\n",f[i]);
    }
    printf("%d",f[n]);
    return 0;
}
```

---

## 作者：wcy1056935201 (赞：3)

~~本蒟蒻也来发一次题解~~~~第一篇请见谅~~

# 这个题有几个要点

1.无向无权图，建图的时候别忘记建来回的有向边~~【因此WA掉1次~~

2.无权嘛，那么边长建成1就好了2333333

3.最短路采用迪杰斯特拉（别忘用堆优化）来做，计数操作改装进去，ans[1]=1;迪杰斯特拉更新边长的时候如果大于号（具体见代码）就覆盖，相等的话就加上

~~4.%楼上SPFA，BFS大佬~~

# 具体见代码~~，其实就是在迪杰斯特拉里面填了几笔（逃~~

~~代码巨丑（捂脸）~~

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define maxn 1000006
using namespace std;
int n,m,s=1;
int dis[maxn];
int ans[maxn];
struct Edge{
    int t,nxt,w;
}edge[maxn*4];
int book[maxn];
int head[maxn],tot=0;
priority_queue< pair<int,int> > hep;
void add(int st,int to,int we){
    edge[tot].t=to;
    edge[tot].nxt=head[st];
    edge[tot].w=we;
    head[st]=tot;
    tot++;
}
void init(){
    scanf("%d %d",&n,&m);
    memset(book,0,sizeof(book));
    memset(head,-1,sizeof(head));
    memset(dis,0x3f,sizeof(dis));
    memset(ans,0,sizeof(ans));
    for(int i=1;i<=m;i++){
        int a,b;
        scanf("%d %d",&a,&b);
        add(a,b,1);
        add(b,a,1);
    }
    dis[s]=0;
    ans[s]=1;
    return;
}
void dij(){
    hep.push(make_pair(0-dis[s],s));
    while(!hep.empty()){
        int np=hep.top().second;hep.pop();
        if(book[np]) continue;
        book[np]=1;
        for(int i=head[np];i!=-1;i=edge[i].nxt){
            int w=edge[i].w;
            int t=edge[i].t;
            if(dis[t]>dis[np]+w){
                dis[t]=dis[np]+w;
                ans[t]=ans[np];
                hep.push(make_pair(0-dis[t],t));
            }
            else if(dis[t]==dis[np]+w){
            	ans[t]+=ans[np];
            	ans[t]%=100003;
            }
        }
    }
    for(int i=1;i<=n;i++)
        printf("%d\n",ans[i]);
    return;
}
int main(){
    init();
    dij();
    return 0;
} 
```

---

## 作者：AutumnKite (赞：3)

#Pascal的题解还是如此的少，我来补一发#

既然无权，BFS应该比较合适吧。

BFS求无权图中单源最短路应该大家都会吧，从起点出发，一找到就是最短的（无权）。那么计数其实就加一个数组加几句话就行了。

分两种情况：

1. 第一次到达当前点y，记录最短路，假设是从x点到达y的，则ans[y]=ans[x]，然后入队。

2. 不是第一次。判断当前是否为最短路，如果是，则ans[y]+=ans[x]，不需要入队，注意取模。

但是点比较多（好吧其实是很多），怎么办呢？用邻接表存储，数组模拟链表（一维数组），记录一个点x与他相邻的所有点，需要head[x]（头），next[y]（下一条边）就能存下整个图。注意无向图，数组范围应该是2e。

```cpp
var
  n,m,e,i,j,x,y:longint; //e表示总边数，最后应该是2*m
  head,ans,dis:array[0..2000001]of longint; //分别表示链表的头，答案和最短路
  a,next,q:array[0..5000001]of longint; //分别表示邻接表，下一条边，队列
  b:array[0..2000001]of boolean; //表示有没有访问过
procedure add(x,y:longint);
begin
  inc(e); a[e]:=y; next[e]:=head[x]; head[x]:=e; //加入(x,y)这条有向边
end;
procedure bfs();
var
  h,t,i,x,y:longint;
begin
  fillchar(b,sizeof(b),1);
  fillchar(ans,sizeof(ans),0);
  h:=0; t:=1; q[1]:=1; ans[1]:=1; dis[0]:=0; b[1]:=false; //起点入队
  while h<t do 
    begin
      inc(h); x:=q[h]; i:=head[x]; //从头开始
      while i>0 do 
        begin
          y:=a[i];
          if b[y] then //第一种情况
            begin
              ans[y]:=ans[x];
              dis[y]:=dis[x]+1;
              inc(t); q[t]:=y;
              b[y]:=false;
            end
          else //第二种情况
            if dis[y]=dis[x]+1 then ans[y]:=(ans[y]+ans[x]) mod 100003;
          i:=next[i]; //下一条边
        end;
    end;
end;
begin
  readln(n,m); e:=0;
  fillchar(head,sizeof(head),0);
  for i:=1 to m do 
    begin
      readln(x,y);
      add(x,y);
      add(y,x);//无向图
    end;
  bfs();
  for i:=1 to n do writeln(ans[i]);
end.

```

---

## 作者：EightSixSun (赞：2)

第一眼看到这个题，不难想到先求出起点到所有点的最短路然后bfs，但是再看一眼数据范围，显然是不可行的。。。

那么我们就从最短路那方面去考虑 

SPFA就是bfs，而且在找到到一个点的最短路时会进行松弛操作

那么我们不难想到，在每次松弛一个点时，可能就找到了到这个点的最短路 

然后不难想到，这时到这个点的最短路的条数等于到前驱节点的最短路的条数 

但是到这个点的所有最短路不一定只经过一个相同的前驱，那么我们加一个条件，如果松弛的时候，到这个点的距离=到它的最短路的距离，那么最短路的条数加上当前前驱节点的最短路的条数，差不多就是个记忆化 

如果一个节点被松弛了，那说明它之前的路径都不是最短路，直接赋值成前驱的最短路条数 



------------

代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <queue>
#define For(i,l,r) for(int i=l;i<=r;++i)
using namespace std;
int read()
{
    char c;
    int a=0;
    bool t=0;
    while((c=getchar())==' '||c=='\n'||c=='\r');
    if(c=='-')
    {
        t=1;
        c=getchar();
    }
    while(isdigit(c))
    {
        a*=10;
        a+=(c-'0');
        c=getchar();
    }
    return a*(t?-1:1);
}
struct line{
    int to,next;
}edge[4000001];
int n,m,ans[1000001],last[1000001],dis[1000001];
bool vis[1000001];
void add(int from,int to,int i)
{
    edge[i].next=last[from];
    last[from]=i;
    edge[i].to=to;
}
void spfa()
{
    int tx;
    memset(dis,127,sizeof dis);
    queue<int> q;
    q.push(1);dis[1]=0;vis[1]=1;ans[1]=1;
    while(!q.empty())
    {
        tx=last[q.front()];
        while(tx)
        {
            if(dis[edge[tx].to]>dis[q.front()]+1)
            {
                dis[edge[tx].to]=dis[q.front()]+1;
                ans[edge[tx].to]=ans[q.front()];
                if(!vis[edge[tx].to])
                {
                    q.push(edge[tx].to);
                    vis[edge[tx].to]=1;
                }
            }
            else if(dis[edge[tx].to]==dis[q.front()]+1)
            {
                ans[edge[tx].to]+=ans[q.front()];
                ans[edge[tx].to]%=100003;
            }
            tx=edge[tx].next;
        }
        vis[q.front()]=0;
        q.pop();
    }
}
int main()
{
    int tx,ty;
    n=read();
    m=read();
    m+=m;
    For(i,1,m)
    {
        tx=read();
        ty=read();
        add(tx,ty,i++);
        add(ty,tx,i);
    }
    spfa();
    For(i,1,n)
     printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：2到正无穷 (赞：2)

为何dalao们都在用spfa？

求最短路，当边权不同时，可以用dijkstra或spfa

然而，边权相同时，尽管前两者都可以，但是复杂度分别为O(nlogn)和O(kn)，还有一种稳定的O(n)算法——bfs！

因为bfs的结点扩展顺序时分层进行的，那么队列中序列必然是距离单调不下降的。故用前面的点去算后面的点，得到的必然是最短路

核心是两个标记：vis和inq

原则：每个结点只扩展比自己距离远1的结点；队列只能进一次，但扩展时可以多次改变cnt

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 1000003
#define M 2000003
#define INF 0x3f3f3f3f
#define ha 100003
#define qsize 3000002
struct nodet{
    int head,cnt,dist;bool vis,inq;
    nodet(){head=-1;cnt=0;dist=INF;vis=inq=0;    }
}node[N];
struct edget{
    int u,v,pre;
    edget(){pre=-1;    }
}edge[M+M];
int cnt=0,n,m;
void addedge(int u,int v){
    cnt++;
    edge[cnt].u=u;
    edge[cnt].v=v;
    edge[cnt].pre=node[u].head;
    node[u].head=cnt;
}
struct queuet{
    int data[qsize];
    int h,t;
    queuet(){h=t=0;    }
    bool is_empty(){return h==t;    }
    bool is_full(){return (t+1)%qsize==h;    }
    bool push(int x){
        if (is_full()) return false;
        data[t]=x;t=(t+1)%qsize;return true;
    }
    bool pop(){
        if (is_empty()) return false;
        h=(h+1)%qsize;return true;
    }
    int top(){return data[h];    }
}q;
void bfs(){
    node[1].dist=0;node[1].cnt=1;
    q.push(1);
    int expd,now;
    while (!q.is_empty()){
        expd=q.top();q.pop();
        node[expd].vis=1;
        for (int i=node[expd].head;i!=-1;i=edge[i].pre){
            now=edge[i].v;
            if (!node[now].vis && node[now].dist!=node[expd].dist){
                if (!node[now].inq) q.push(now),node[now].inq=1;
                node[now].dist=node[expd].dist+1;
                node[now].cnt=(node[expd].cnt+node[now].cnt)%ha;
            }            
        }        
    }    
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1,u,v;i<=m;i++){
        scanf("%d%d",&u,&v);
        addedge(u,v);
        addedge(v,u);
    }
    bfs();    
    for (int i=1;i<=n;i++)
    printf("%d\n",node[i].cnt);
    return 0;
}
```

---

## 作者：hxn2228 (赞：2)

思考一下容易发现，到某个点的最短路的方案=上一层最短方案\*到当前点路的条数

加到spfa里就是：如果有更短路，就更新当前节点的方案为更短路的方案数，如果有相同长度最短路，就将他们的方案数相加

这就是基本思路

对于无权图来说这道题还是比较简单的，如果是带权图的话就加上权值就可以了，稍微改一下下spfa部分和输入部分就好

下面上代码


```cpp
#include<iostream>
#include<vector>
#include<cstdio>
#include<queue>
using namespace std;
queue <int> que;
int n,m,aa,bb,vis[1000010],val[1000010],ans[1000010];
vector <int> edge[1000010];
void spfa()
{
    que.push(1);
    vis[1]=1;
    val[1]=0;
    ans[1]=1;//1到本身的方案只有一种 
    while(!que.empty())
    {
        int nowp=que.front();
        que.pop();
        //因为无负边所以不需要将当前点的vis改回0 
        for(int i=0;i<edge[nowp].size();i++)
        {
            int nowe=edge[nowp][i];
            if(val[nowe]>val[nowp]+1)//如果发现更短路则更新方案数 
            {
                val[nowe]=val[nowp]+1;
                ans[nowe]=ans[nowp];
            } 
            else if(val[nowe]==val[nowp]+1)//如果发现另外的到当前点的最短路就将新的最短路的方案数加到当前点的最短路方案数中 
            {
                ans[nowe]+=ans[nowp];
                ans[nowe]%=100003;//%一%，单车变摩托 
            }
            if(vis[nowe]==0)
            {
                que.push(nowe);
                vis[nowe]=1;
            }
        } 
    }
} 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        val[i]=0x7fffffff;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&aa,&bb);//双向边 
        edge[aa].push_back(bb);
        edge[bb].push_back(aa);
    }
    spfa();
    for(int i=1;i<=n;i++)
        printf("%d\n",ans[i]);
}
```

---

## 作者：__世界第一弱__ (赞：2)

这道题我先跑一个最短路，然后在用一个类似记忆化搜索的东西搜出最短路条数

开一个dis数组存最短路长度，开一个ans数组存答案

搜到一个节点v，寻找它能到达的每个节点u

如果$dis[u]+1==dis[v]$，说明用最短路的走法走到u后直接走到v都是1到v的一条合法最短路

于是乎v的答案=v的答案+u的答案

#写记忆化的时候不要算过了还递归进去在返回，那样会TLE

代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
const int MOD=1e5+3;
struct edge {
    int to,nxt;
} E[5000010];
int n,m,lst[1000010]= {},cnt,dis[1000010],ans[1000010]= {0,1};
inline void add(int u,int v) {
    E[++cnt]=(edge) {
        v,lst[u]
    };
    lst[u]=cnt;
}
inline void Spfa(int s) {
    for(int i=1; i<=n; i++) dis[i]=1000000000;
    dis[s]=0;
    std::queue<int>q;
    q.push(s);
    while(!q.empty()) {
        int u=q.front();
        q.pop();
        for(int k=lst[u]; k; k=E[k].nxt) {
            int v=E[k].to;
            if(dis[u]+1<dis[v]) {
                dis[v]=dis[u]+1;
                q.push(v);
            }
        }
    }
}
inline int Calc(int v) {
    for(int k=lst[v]; k; k=E[k].nxt) {
        int u=E[k].to;
        if(dis[u]+1==dis[v]) {
            if(!ans[u]) ans[v]=(ans[v]+Calc(u))%MOD;
            else ans[v]=(ans[v]+ans[u])%MOD;
        }
    }
    return ans[v];
}
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1; i<=m; i++) {
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v);
        add(v,u);
    }
    Spfa(1);
    for(int i=1; i<=n; i++) {
        if(!ans[i]) printf("%d\n",Calc(i));
        else printf("%d\n",ans[i]);
    }
    return 0;
}
```

---

## 作者：Azuree (赞：1)

[查看原题请戳这里](https://www.luogu.org/problemnew/show/P1144)

>虽然题目叫最短路计数，但是TA可以只用到最短路的概念而不用最短路的算法……

思考方向

由于这是一个无权图，所以一条路径上边的数量就是这条路径的长度，那么我们就可以用BFS来搞定这个问题了。

具体思路
我们每遍历到一个节点就和ta的前一个结点的距离比较，这里会有三种情况：(由1到2)  

1. 2号点没有被访问过||time[1] + 1 < time[2]：此时我们直接用1号点的信息去更新2就好啦  
2. time[1] + 1 = time[2] : 这个我们就只需要更新一下ans就可以啦  
3. time[1] + 1 > time[2] :此时这条路径比之前的某条路径要长，直接跳过就可以啦  

附一下代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#define ll long long
#define INF 0x7fffffff
#define re register

using namespace std;

int read()
{
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

queue<int> que;

struct edge{
	int next,to,v;
}e[2000005];

int n,m,cnt,x,now,y,tim[2000000],ans[2000000],d[2000000];

inline int add(int x,int y)
{
	e[++cnt].to = y;
	e[cnt].next = d[x];
	d[x] = cnt;
}

int main()
{
	n = read();
	m = read();
	for(re int i = 1; i <= m; i++)
	{
		x = read(); y = read();
		add(x,y); add(y,x);
		
	}
	que.push(1);
	ans[1] = 1;
	while(!que.empty())
	{
		now = que.front();
		que.pop();
		for(re int i = d[now]; i; i = e[i].next)
		{
			if(tim[now] + 1 < tim[e[i].to] || tim[e[i].to] == 0)
			{
				tim[e[i].to] = tim[now] + 1;
				ans[e[i].to] = ans[now];
				que.push(e[i].to);
			}
			else
			if(tim[now] + 1 == tim[e[i].to]) ans[e[i].to] = (ans[e[i].to] + ans[now]) % 100003;
		}
	}
	ans[1] = 1;
	for(re int i = 1; i <= n; i++) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：limi_sanhua (赞：1)

蒟蒻第一个题解
前向星+BFS
代码注释详解：
```cpp
#include <bits/stdc++.h>
using namespace std;//num[]记录答案，d[]记录最短路径长度，vt[]记录访问，s[]为队列 
int n,m,cnt,ans,h[200005],num[200005],root,d[200005]； 
int vt[200005],s[200005];//太多了，分两行2333 
struct node//前向星结构体 
{
	int to;
	int next;
}q[400010];//因为是无向的，所以要翻倍 
void qxx(int x,int y)//生成前向星 (别吐槽函数名QAQ)
{
	q[++cnt].to=y;
	q[cnt].next=h[x];
	h[x]=cnt;
}
void bfs()//因为是最短路径，所以宽搜 
{
	int head=1,tail=1;
	s[head]=root;vt[root]=1;num[1]=1;//初始化 
	while(head<=tail)
	{
		for(int i=h[s[head]];i;i=q[i].next)
		{
			int y=q[i].to;
			if(s[head]==y)//剪枝，跳过自环 ，以节约时间 
			continue;
			if(!vt[y])//第一次访问，则直接记录 
			{
				s[++tail]=y;
				num[y]=num[y]+num[s[head]]%100003;//能%就% 
				num[y]%100003;//能%就% 
				d[y]=d[s[head]]+1;
				vt[y]=1;
			}
			else//第若干次访问，先判断路径是否为最短 
			if(vt[y]&&d[s[head]]+1==d[y])
			{
				num[y]=num[y]+num[s[head]]%100003;//能%就% 
				num[y]%100003;//能%就% 
			}
		}
		head++;
	}
}
int main()
{
	cin>>n>>m;
	int i;
	for(i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		qxx(x,y);qxx(y,x);//无向前向星 
	}
	root=1;//因为是从1开始，所以根为1 
	bfs();//开始宽搜 
	for(i=1;i<=n;i++)
	printf("%d\n",num[i]%100003);//一定要%100003,不然会wa两个点 
}
```

---

## 作者：fysbb (赞：1)

 此题可以先用SPFA处理图的最短路。之后再搜索并记录最短路的个数（记
得取模）！不用思考是否有重边。

------------
    program project1;
    var
       l,v:array[0..2000005]of longint;
       r,dis,ans:array[0..1000005]of longint;
       n,m,i,x,t:longint;
    procedure SPFA;
    var up,down,q,p:longint;
        tf:array[0..1000005]of boolean;
        t:array[0..1000005]of longint;
    begin
      fillchar(tf,sizeof(tf),false);
      fillchar(t,sizeof(t),0);
      dis[1]:=0;
      tf[1]:=true;
      up:=0;
      down:=1;
      t[down]:=1;
      repeat
        inc(up);
        q:=t[up];
        p:=r[q];
        while p<>0 do begin
          if dis[v[p]]>dis[q]+1 then begin
            dis[v[p]]:=dis[q]+1;
            if tf[v[p]]=false then begin
              inc(down);
              t[down]:=v[p];
              tf[v[p]]:=true;
            end;
          end;
          p:=l[p];
        end;
        tf[q]:=false;
      until up>=down;
    end;
    procedure sc;
    var up,down,q,p:longint;
        tf:array[0..1000005]of boolean;
        t:array[0..1000005]of longint;
    begin
      fillchar(tf,sizeof(tf),false);
      fillchar(t,sizeof(t),0);
      up:=0;
      down:=1;
      t[down]:=1;
      tf[1]:=true;
      ans[1]:=1;
      repeat
        inc(up);
        q:=t[up];
        p:=r[q];
        while p<>0 do begin
          if dis[v[p]]=dis[q]+1 then begin
            ans[v[p]]:=(ans[v[p]]+ans[q]) mod 100003;
            if tf[v[p]]=false then begin
              inc(down);
              t[down]:=v[p];
              tf[v[p]]:=true;
            end;
          end;
          p:=l[p];
        end;
        tf[q]:=false;
      until up>=down;
    end;

    begin
      readln(n,m);
      fillchar(l,sizeof(l),0);
      fillchar(r,sizeof(r),0);
      fillchar(v,sizeof(v),0);
      fillchar(ans,sizeof(ans),0);
      fillchar(dis,sizeof(dis),$7f);
      for i:=1 to m do begin
        t:=2*i;                         //注意是无向图
        readln(x,v[t]); 
        l[t]:=r[x];
        r[x]:=t;
        v[t-1]:=x;
        l[t-1]:=r[v[t]];
        r[v[t]]:=t-1;
      end;
      SPFA;
      sc;
      for i:=1 to n do writeln(ans[i]);
      readln;
    end.


---

## 作者：封禁用户 (赞：1)

/\*
[从1到v的方案数] 是 [从1号点到达v周围所有点的方案数] 之和

所以我们遍历v周围所有点

    for(j = 1; j <= [v周围点的个数]; i++) 

        if(i被访问过)

[从1到v的的方案数] 加上 [从1到j的的方案数]

        else

将i号点加到队列中

\*/
```cpp
#include <stdio.h>
#include <vector>
#include <queue>
using namespace std;
int re; char ge;
int read()
{    //读入优化 
    while((re = getchar()) < 48);
    re -= 48;
    while((ge = getchar()) >= 48)    re = (re << 3) + (re << 1) + ge - 48;
    return re;
}
vector<int> a[2000001];
vector<int>::iterator j; 
queue<int>q;
int n, m, i, x, y, len[1000001], ans[1000001] = {0, 1};
//len[i]表示从起点1到点i的最短路长度，ans[i]表示到当前点有多少种走法
int main()
{
    n = read();
    m = read();
    for(i = 1; i <= m; i++)
    {    //一条无向边(x,y)可以看作两条有向边(x,y)与(y,x)
        x = read();
        y = read();
        a[x].push_back(y);
        if(x != 1) a[y].push_back(x); //指向1的边是没有意义的 
    }
    for(q.push(1); !q.empty(); q.pop())
    {    //bfs遍历所有点
        i = q.front();
        for(j = a[i].begin(); j != a[i].end(); j++)
            if(len[*j]) {
                 if(len[*j] == len[i] + 1)
                    ans[*j] = (ans[*j] + ans[i]) % 100003;
            }
            else {
                q.push(*j);
                len[*j] = len[i] + 1;
                ans[*j] = ans[i];
            }
    }
    puts("1");
    for(i = 2; i <= n; i++)
        printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：EdwardFrog (赞：1)

dp.
边权都是1,直接bfs求最短路,求的时候发现:对于某个点i,一条到达他的最短路径,必须经过一个和i直接相连而且最短路长度比i小1的点x,换句话说就是点x是从出发点到点i的最后一站.于是就无比机智地用x来更新i:

dp[i]=∑dp[x].

其中dp表示最短路条数,注意取模.贴代码:

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#define N 1001234
#define M 2001234
#define mod 100003
using namespace std;
int n,m;
int tot,to[M<<1],next[M<<1],head[N];
int read()
{
    char c;
    int re=0;
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')
    {
        re*=10;
        re+=c-'0';
        c=getchar();
    }
    return re;
}
void print(int k)
{
    char c[23];
    int top=0;
    if(k==0)
    {
        putchar('0');
        putchar('\n');
        return;
    }
    while(k)
    {
        c[++top]=k%10+'0';
        k/=10;
    }
    while(top)putchar(c[top]),top--;
    putchar('\n');
    return;
}
void add(int x,int y)
{
    to[++tot]=y;
    next[tot]=head[x];
    head[x]=tot;
}
queue<int> q;
int f[N],dp[N];
bool v[N];
void bfs()
{
    memset(f,0xef,sizeof(f));
    f[1]=0,v[1]=1,q.push(1),dp[1]=1;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=next[i])
        {
            if(!v[to[i]])
            {
                v[to[i]]=1;
                f[to[i]]=f[x]+1;
                q.push(to[i]);
            }
            else if(f[to[i]]==f[x]-1)dp[x]=(dp[x]+dp[to[i]])%mod;
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int x,y,i=1;i<=m;i++)
    {
        x=read(),y=read();
        add(x,y);
        add(y,x);
    }
    bfs();
    for(int i=1;i<=n;i++)print(dp[i]);
    return 0;
} 
```

---


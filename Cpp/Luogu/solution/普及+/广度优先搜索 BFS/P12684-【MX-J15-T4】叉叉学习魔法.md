# 【MX-J15-T4】叉叉学习魔法

## 题目背景

原题链接：<https://oier.team/problems/J15D>。

---

小 X 和小 W 走散了。

## 题目描述

在一个 $n \times m$ 的地图上，有的位置是空地 `.`，有的位置是墙 `#`。小 X 和小 W 分别站在一个空地上，他们走散了，小 X 想去找到小 W。在整个过程中，小 X 都不能走出地图。

定义 $(i,j)$ 表示第 $i$ 行第 $j$ 列。小 X 每次可以从空地 $(i,j)$ 走一步到空地 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$ 或 $(i,j+1)$ 上。

小 X 可以使用若干次魔法。每次使用魔法，小 X 可以从空地 $(i,j)$ 不增加步数地移动到空地 $(i-1,j-1)$、$(i-1,j+1)$、$(i+1,j-1)$ 或 $(i+1,j+1)$ 上。

小 X 想知道，他至少要使用多少次魔法，可以走最少的步数找到小 W。如果小 X 无法找到小 W，请告诉小 X。

## 说明/提示

**【样例解释 #1】**

从 $X(1,1)$ 使用一次魔法移动到 $(2,2)$，再使用一次魔法移动到 $W(3,3)$。

**【数据范围】**

对于 $100\%$ 的数据，$2 \le n,m \le 5000$，地图中仅出现 `.#XW` 四种字符，其中 `X` 和 `W` 有且仅有一个。

| 测试点编号  | $n,m \le$ | 特殊性质 |
| :---------: | :-------: | :------: |
|     $1$     |    $2$    |          |
|  $2\sim 7$  |   $10$    |          |
| $8 \sim 11$ |  $1000$   |          |
| $12\sim 15$ |  $5000$   | 没有 `#` |
| $16\sim 20$ |  $5000$   |          |



## 样例 #1

### 输入

```
3 3
X#.
#.#
.#W```

### 输出

```
0 2```

## 样例 #2

### 输入

```
3 3
X#.
###
.#W```

### 输出

```
-1 -1```

## 样例 #3

### 输入

```
3 3
X..
##.
##W```

### 输出

```
2 1```

# 题解

## 作者：P2441M (赞：8)

$\text{Upd 2025/6/3}$：修改了一些笔误。

## 题意

有一个 $n\times m$ 的地图，其中 `.` 表示空地，`#` 表示墙，`X` 表示起点，`W` 表示终点。你可以从空地 $(i,j)$ 走一步到上/下/左/右的空地，也可以使用一次魔法，从空地 $(i,j)$ 走到左上/左下/右上/右下的空地而**不耗费步数**。从起点走到终点，你需要在最小化步数的前提下最小化使用魔法的次数，或报告无解。$2\leq n,m\leq 5\times 10^3$。

## 题解

用状态 $(x,y,t_1,t_2)$ 表示走到 $(x,y)$ 处耗费了 $t_1$ 步，使用了 $t_2$ 次魔法。容易想到用以 $t_1$ 为第一关键字、$t_2$ 为第二关键字的小优先队列维护最优状态，然后跑 BFS。这样子时间复杂度是 $\mathcal{O}(nm\log{(nm)})$ 的，可以获得 $75$ 分。

考虑优化。我们发现每次状态转移时，要么给 $t_1$ 加 $1$，要么给 $t_2$ 加 $1$，考虑 0/1 BFS，也就是用双端队列替代优先队列。最直接的想法就是给 $t_1$ 加 $1$ 的状态加到队尾，给 $t_2$ 加 $1$ 的状态加到队头。由于每次取出的状态是单增的，不难证明其正确性。

但我们一写，发现它 WA 了。

问题在哪儿？我们发现队列中的状态是**不严格单调递增**的，取出最优状态 $(x,y,t_1,t_2)$ 后，队头可能还有 $(x',y',t_1,t_2)$ 的状态，如果我们此时就把 $(x,y,t_1,t_2+1)$ 加到队头，单调性就被破坏了。

所以我们每次把 $t_1$ 和 $t_2$ 都相同的状态全部取出，然后再加入所有新的状态即可。

时间复杂度 $\mathcal{O}(nm)$。

## 代码
```cpp
#include <iostream>
#include <queue>
#include <deque>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 5e3 + 5;
const int dx1[] = {-1, 1, 0, 0}, dy1[] = {0, 0, -1, 1};
const int dx2[] = {-1, -1, 1, 1}, dy2[] = {-1, 1, -1, 1};

int n, m, x1, y1, x2, y2;
char a[N][N];
bool vis[N][N];
struct Node {
	int x, y, t1, t2;
	bool operator<(const Node &x) const {
		if (t1 != x.t1) return t1 > x.t1;
		return t2 > x.t2;
	}
};
deque<Node> q;
vector<Node> v1, v2;

inline void calc() {
	q.push_front({x1, y1, 0, 0});
	while (!q.empty()) {
		Node cur = q.front();
		while (!q.empty() && cur.t1 == q.front().t1 && cur.t2 == q.front().t2) {
			cur = q.front(); q.pop_front();
			if (cur.x == x2 && cur.y == y2) { cout << cur.t1 << ' ' << cur.t2 << '\n'; return; }
			if (vis[cur.x][cur.y]) continue;
			vis[cur.x][cur.y] = 1;
			for (int i = 0; i < 4; ++i) {
				int x = cur.x + dx1[i], y = cur.y + dy1[i];
				if (!x || !y || x == n + 1 || y == m + 1 || a[x][y] == '#') continue;
				v1.push_back({x, y, cur.t1 + 1, cur.t2});
			}
			for (int i = 0; i < 4; ++i) {
				int x = cur.x + dx2[i], y = cur.y + dy2[i];
				if (!x || !y || x == n + 1 || y == m + 1 || a[x][y] == '#') continue;
				v2.push_back({x, y, cur.t1, cur.t2 + 1});
			}
		}
		for (Node st : v2) q.push_front(st);
		for (Node st : v1) q.push_back(st);
		v1.clear(), v2.clear();
	}
	cout << "-1 -1\n";
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
    	cin >> a[i] + 1;
    	for (int j = 1; j <= m; ++j)
    		if (a[i][j] == 'X') x1 = i, y1 = j;
    		else if (a[i][j] == 'W') x2 = i, y2 = j;
    }
    calc();
    return 0;
}
```

---

## 作者：Milthm (赞：5)

先考虑第一问怎么求，我们将斜着的边权设为 $0$，直着的边权设为 $1$，那么相当于一个最短路问题，而且边权只有 $0$ 和 $1$，可以通过 01bfs 来解决。当然，我们其实不需要把图建出来，直接在矩阵上做也可以。

然后我们来考虑怎么做第二问，第二问要求魔法使用最少，乍一看可以用类似的方法，但是这问有一个前提条件——要在使用最少步数的情况下。那么这个时候可以理解为不是所有的路都能走了，我们需要知道什么情况下这条边能走。

如果我们设 $dis_{i,j}$ 表示从起点到 $(i,j)$ 位置的最小步数，那么对于周围的 $8$ 个格子中能走的格子之一 $(p,q)$，只有 $dis_{p,q}=dis_{i,j}+w$（其中如果为直边 $w=1$，否则为 $0$）的时候 $(i,j)$ 到 $(p,q)$ 的边才是能用的。这是因为如果我们走了 $dis_{p,q}<dis_{i,j}+w$ 的边，那么这条边会使得我们的步数不是最小的（因为存在另一种到 $(p,q)$ 的方式步数严格小于这种方式）。所以我们设置只有这样的边能走，并把直边设为 $0$，斜边设为 $1$，再做一遍 01bfs 即可。

时间复杂度：$O(nm)$。


```cpp
#include<bits/stdc++.h>
#define N 5005
#define pi pair<int,int>
using namespace std;
int n,m,w[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};
int sx,sy,tx,ty,dis[N][N],g[N][N];
bool vis[N][N];
char a[N][N];
deque<pi>q;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>a[i][j];
			if(a[i][j]=='X')sx=i,sy=j;
			if(a[i][j]=='W')tx=i,ty=j;
		}
	}
	memset(dis,0x3f,sizeof(dis));dis[sx][sy]=0;
	q.push_front({sx,sy});
	while(!q.empty()){
		pi c=q.front();q.pop_front();
		int x=c.first,y=c.second;
		if(vis[x][y])continue;
		vis[x][y]=1;
		//cout<<x<<" "<<y<<" "<<dis[x][y]<<'\n';
		for(int i=0;i<8;++i){
			int px=x+w[i][0],py=y+w[i][1];
			if(px>=1&&px<=n&&py>=1&&py<=m&&a[px][py]!='#'){
				if(dis[px][py]>dis[x][y]+(i<4)){
					dis[px][py]=dis[x][y]+(i<4);
					if(i<4)q.push_back({px,py});
					else q.push_front({px,py});
				}
			}
		}
	}
	if(!vis[tx][ty])return cout<<"-1 -1",0;
//for(int i=1;i<=n;++i){
	//	for(int j=1;j<=m;++j)cout<<dis[i][j]<<" ";cout<<'\n';
	//}
	cout<<dis[tx][ty]<<" ";
	memset(g,0x3f,sizeof(g));g[sx][sy]=0;
	memset(vis,0,sizeof(vis));
	q.push_front({sx,sy});
	while(!q.empty()){
		pi c=q.front();q.pop_front();
		int x=c.first,y=c.second;
		if(vis[x][y])continue;
		vis[x][y]=1;
		for(int i=0;i<8;++i){
			int px=x+w[i][0],py=y+w[i][1];
			if(px>=1&&px<=n&&py>=1&&py<=m&&a[px][py]!='#'&&dis[px][py]==dis[x][y]+(i<4)){
				if(g[px][py]>g[x][y]+(i>=4)){
					g[px][py]=g[x][y]+(i>=4);
					if(i>=4)q.push_back({px,py});
					else q.push_front({px,py});
				}
			}
		}
	}
	cout<<g[tx][ty];
	return 0;
}
```

---

## 作者：__liujy (赞：1)

考虑广搜优化。

先跑第一个答案，再跑第二个答案。

再优化这个操作，建一个双端队列，跑第一个答案：如果当前走的是斜线，那么只需要花魔法，则，将它放在双端队列前面，因为它的步数较少；否则跑的是直线，则，将它放在双端队列后面，因为它的步数较多。

再跑第二个答案，若跑的是斜线那么要花魔法，若跑的是直线不用花魔法，但是前提条件是当前步数等于最少步数。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register int
inline int read(){
    int ans = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        f = (ch == '-' ? -1 : f);
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        ans = (ans << 1) + (ans << 3) + (ch ^ 48);
        ch = getchar();
    }
    return ans * f;
}
inline string Read(){
	string ans = "";
	char ch = getchar();
	while(ch == ' ' || ch == '\n') ch = getchar();
	while(ch != ' ' && ch != '\n'){
		ans += ch;
		ch = getchar();
	}
	return ans;
}
inline char RRead(){
	char ch = getchar();
	while(ch == ' ' || ch == '\n') ch = getchar();
	return ch;
}
inline void print(int x){
    if(x < 0){
        x = -x;
        putchar('-');
    }
    if(x > 9) print(x / 10);
    putchar(x % 10 ^ 48);
}
inline void write(int x){
    print(x);
    putchar(' ');
}

const int N = 5005;

typedef pair<int, int> PII;

int n, m, bx, by, ex, ey, dir[8][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}, f[N][N], g[N][N];
char a[N][N];
deque<PII>q;

int main(){
	n = read(), m = read();
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			a[i][j] = RRead();
		}
	}
	
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			if(a[i][j] == 'X') bx = i, by = j;
			else if(a[i][j] == 'W') ex = i, ey = j; 
		}
	}
	
	q.push_front(make_pair(bx, by));
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			f[i][j] = 0x7f7f7f7f;
		}
	}
	f[bx][by] = 0;
	while(q.size()){
		int x = q.front().first, y = q.front().second;
		q.pop_front();
		
		for(ri i = 0; i < 8; i++){
			int tx = x + dir[i][0], ty = y + dir[i][1];
			
			if(tx >= 1&& tx <= n && ty >= 1 && ty <= m && a[tx][ty] != '#'){
				if(f[tx][ty] <= f[x][y] + (i < 4)) continue;
				f[tx][ty] = f[x][y] + (i < 4);
				
				if(i < 4) q.push_back(make_pair(tx, ty));
				else q.push_front(make_pair(tx, ty));
			}
		}
	}
	
	if(f[ex][ey] == 0x7f7f7f7f){
		write(-1);
		write(-1);
		return 0;
	}
	write(f[ex][ey]);
	
	q.push_front(make_pair(bx, by));
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			g[i][j] = 0x7f7f7f7f;
		}
	}
	g[bx][by] = 0;
	while(q.size()){
		int x = q.front().first, y = q.front().second;
		q.pop_front();
		
		for(ri i = 0; i < 8; i++){
			int tx = x + dir[i][0], ty = y + dir[i][1];
			if(tx >= 1 && tx <= n && ty >= 1 && ty <= m && a[tx][ty] != '#' && f[tx][ty] == f[x][y] + (i < 4)){
				if(g[tx][ty] <= g[x][y] + (i >= 4)) continue;
				g[tx][ty] = g[x][y] + (i >= 4);
				
				if(i >= 4) q.push_back(make_pair(tx, ty));
				else q.push_front(make_pair(tx, ty));
			}
		}
	}
	
	write(g[ex][ey]);
	
	return 0;
}
```

---

## 作者：shinzanmono (赞：1)

题面要求最小的步数，并在最小步数的前提下求最小魔法数。

最小步数可以使用 01bfs 解决，注意不能将图显式建出来。

考虑如何求最小魔法数，提取原图的最短路图，发现如果 $dis_T=dis_S+w$ 则说明最短路图中存在边 $S\rightarrow T$，此时这条边可以对魔法数进行松弛（需要魔法边权 $w'$ 为 $1$，反之为 $0$）。

注意无法到达的情况。

```cpp
#include<iostream>
#include<algorithm>
#include<queue>
const int sz=5010;
const int inf=0x3fffffff;
int dx[]={0,0,1,-1,1,1,-1,-1},dy[]={1,-1,0,0,1,-1,1,-1};
std::string s[sz];
int dis[sz][sz],dist[sz][sz];
int main(){
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n,m;
  std::cin>>n>>m;
  for(int i=1;i<=n;i++)std::cin>>s[i],s[i]=" "+s[i];
  std::pair<int,int>S,T;
  for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
      if(s[i][j]=='X')S=std::make_pair(i,j);
      if(s[i][j]=='W')T=std::make_pair(i,j);
    }
  }
  std::deque<std::pair<int,int>>qq;
  auto check=[&](int x,int y){
    return x>=1&&x<=n&&y>=1&&y<=m&&s[x][y]!='#';
  };
  for(int i=1;i<=n;i++)std::fill(dis[i]+1,dis[i]+m+1,inf);
  qq.push_back(S),dis[S.first][S.second]=0;
  while(!qq.empty()){
    auto [x,y]=qq.front();
    qq.pop_front();
    for(int t=0;t<8;t++){
      int tx=x+dx[t],ty=y+dy[t],w=t<4;
      if(!check(tx,ty))continue;
      if(dis[tx][ty]>dis[x][y]+w){
        dis[tx][ty]=dis[x][y]+w;
        if(w==1)qq.emplace_back(tx,ty);
        else qq.emplace_front(tx,ty);
      }
    }
  }
  if(dis[T.first][T.second]==inf)std::cout<<"-1 -1",exit(0);
  for(int i=1;i<=n;i++)std::fill(dist[i]+1,dist[i]+m+1,inf);
  qq.push_back(S),dist[S.first][S.second]=0;
  while(!qq.empty()){
    auto [x,y]=qq.front();
    qq.pop_front();
    for(int t=0;t<8;t++){
      int tx=x+dx[t],ty=y+dy[t],w=t>=4;
      if(!check(tx,ty)||dis[tx][ty]!=dis[x][y]+(w^1))continue;
      if(dist[tx][ty]>dist[x][y]+w){
        dist[tx][ty]=dist[x][y]+w;
        if(w==1)qq.emplace_back(tx,ty);
        else qq.emplace_front(tx,ty);
      }
    }
  }
  std::cout<<dis[T.first][T.second]<<" "<<dist[T.first][T.second]<<"\n";
  return 0;
}
```

---

## 作者：Lele_Programmer (赞：1)

# P12684 题解

非常不错的一道广搜题，直接把 dijkstra 带 $\log$ 算法卡飞了。

## 思路

节点数量达到 $2.5 \times 10^7$ 级别，显然必须做到线性才能通过。

不妨定义一条边的边权为二元组 $(a,b)$ 表示步数增加 $a$，魔法使用次数增加 $b$，而题目只有两种移动方式，向上下左右四个方向的边权恒为 $(1,0)$，其余四个斜方向边权 $(0,1)$，我们要在前一个边权和最小的同时，后一个边权和尽可能小。

不难发现边权只有 $0$ 和 $1$，容易想到 0-1 bfs，先对于步数进行广搜，斜方向边权 $0$，上下左右边权 $1$，每一次入队的时候，将需要走边权 $1$ 的放到队尾，边权 $0$ 的放到队首，用双端队列维护，于是做到了和 dijkstra 一样的效果，并且做到线性。

这样求出来了到达每个点需要的最小步数，接下来就是求最小魔法使用次数了，斜方向边权 $1$，上下左右边权 $0$，在满足上文求出的步数限制的同时，更新最小魔法使用次数，这里依旧使用 0-1 bfs。

这样这道题就做完了，跑两次广搜，时间复杂度 $\mathcal{O}(nm)$，可以通过。

## 代码

```cpp
const int N=25000005;
const int inf=2e9;

int n,m,sx,sy,tx,ty;
char s[N];
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};
int ddx[]={1,1,-1,-1};
int ddy[]={-1,1,-1,1};
int dis[N],ans[N];

inline int get(int i,int j) {
    return (i-1)*m+j;
}

inline bool check(int x,int y) {
    return x>=1 && y>=1 && x<=n && y<=m && s[get(x,y)]!='#';
}

deque<pii> q;

void bfs1() {
    dis[get(sx,sy)]=0;
    q.emplace_front(pii{sx,sy});
    while (!q.empty()) {
        auto u=q.front(); q.pop_front();
        _rep(i,0,3) {
            pii k={u.first+dx[i],u.second+dy[i]};
            if (check(k.first,k.second) && dis[get(k.first,k.second)]>dis[get(u.first,u.second)]+1) {
                dis[get(k.first,k.second)]=dis[get(u.first,u.second)]+1;
                q.emplace_back(k);
            }
        }
        _rep(i,0,3) {
            pii k={u.first+ddx[i],u.second+ddy[i]};
            if (check(k.first,k.second) && dis[get(k.first,k.second)]>dis[get(u.first,u.second)]) {
                dis[get(k.first,k.second)]=dis[get(u.first,u.second)];
                q.emplace_front(k);
            }
        }
    }
}

void bfs2() {
    ans[get(sx,sy)]=0;
    q.emplace_front(pii{sx,sy});
    while (!q.empty()) {
        auto u=q.front(); q.pop_front();
        _rep(i,0,3) {
            pii k={u.first+dx[i],u.second+dy[i]};
            if (check(k.first,k.second) && dis[get(k.first,k.second)]==dis[get(u.first,u.second)]+1 && ans[get(k.first,k.second)]>ans[get(u.first,u.second)]) {
                // printf("%d,%d -> %d,%d +%d\n",u.first,u.second,k.first,k.second,0);
                ans[get(k.first,k.second)]=ans[get(u.first,u.second)];
                q.emplace_front(k);
            }
        }
        _rep(i,0,3) {
            pii k={u.first+ddx[i],u.second+ddy[i]};
            if (check(k.first,k.second) && dis[get(k.first,k.second)]==dis[get(u.first,u.second)] && ans[get(k.first,k.second)]>ans[get(u.first,u.second)]+1) {
                // printf("%d,%d -> %d,%d +%d\n",u.first,u.second,k.first,k.second,1);
                ans[get(k.first,k.second)]=ans[get(u.first,u.second)]+1;
                q.emplace_back(k);
            }
        }
    }
}

int main() {
    read(n),read(m);
    _rep(i,1,n) {
        readstr(s+get(i,1));
        _rep(j,1,m) {
            ans[get(i,j)]=dis[get(i,j)]=inf;
            if (s[get(i,j)]=='X') sx=i,sy=j;
            else if (s[get(i,j)]=='W') tx=i,ty=j;
        }
    }
    bfs1();
    bfs2();
    if (dis[get(tx,ty)]==inf) puts("-1 -1");
    else writesp(dis[get(tx,ty)]),write(ans[get(tx,ty)]);
    return 0;
}
```

---

## 作者：Bobi2014 (赞：0)

这是一道~~可癌~~的~~毒瘤~~题目。

### 前置知识

- [01bfs](https://blog.csdn.net/Mr_dimple/article/details/116864052)

### 思路

考虑做两次 01bfs，因为要优先考虑步数最少，所以要先对步数做 01bfs，再在第二次 01bfs 中在满足步数不变的情况下使得魔法次数最少，时间复杂度 $O(nm)$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5005;
struct node{
	int x,y;
} s,t;
int n,m,inf,vis[N][N],bis[N][N],
	dx[] = {0,0,1,-1,1,1,-1,-1},
	dy[] = {1,-1,0,0,1,-1,1,-1};
char mp[N][N];
deque<node> q;
void bfs(){
	memset(vis,127,sizeof(vis));
	inf = vis[0][0];
	vis[s.x][s.y] = 0;
	q.push_front(s);
	while(q.empty() == false){
		int x = q.front().x,y = q.front().y;
		q.pop_front();
		for(int i = 4;i < 8;i ++){
			int tx = x + dx[i],ty = y + dy[i];
			if(tx < 1 or tx > n or ty < 1 or ty > m or mp[tx][ty] == '#'){
				continue;
			}
			if(vis[tx][ty] > vis[x][y]){
				vis[tx][ty] = vis[x][y];
				q.push_front({tx,ty});
			}
		}
		for(int i = 0;i < 4;i ++){
			int tx = x + dx[i],ty = y + dy[i];
			if(tx < 1 or tx > n or ty < 1 or ty > m or mp[tx][ty] == '#'){
				continue;
			}
			if(vis[tx][ty] > vis[x][y] + 1){
				vis[tx][ty] = vis[x][y] + 1;
				q.push_back({tx,ty});
			}
		}
	}
	memset(bis,127,sizeof(bis));
	bis[s.x][s.y] = 0;
	q.push_front(s);
	while(q.empty() == false){
		int x = q.front().x,y = q.front().y;
		q.pop_front();
		for(int i = 0;i < 4;i ++){
			int tx = x + dx[i],ty = y + dy[i];
			if(tx < 1 or tx > n or ty < 1 or ty > m or mp[tx][ty] == '#'){
				continue;
			}
			if(vis[tx][ty] == vis[x][y] + 1 and bis[tx][ty] > bis[x][y]){
				bis[tx][ty] = bis[x][y];
				q.push_front({tx,ty});
			}
		}
		for(int i = 4;i < 8;i ++){
			int tx = x + dx[i],ty = y + dy[i];
			if(tx < 1 or tx > n or ty < 1 or ty > m or mp[tx][ty] == '#'){
				continue;
			}
			if(vis[tx][ty] == vis[x][y] and bis[tx][ty] > bis[x][y] + 1){
				bis[tx][ty] = bis[x][y] + 1;
				q.push_back({tx,ty});
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin >> n >> m;
	for(int i = 1;i <= n;i ++){
		cin >> (mp[i] + 1);
		for(int j = 1;j <= m;j ++){
			if(mp[i][j] == 'X'){
				s.x = i,s.y = j;
			}
			if(mp[i][j] == 'W'){
				t.x = i,t.y = j;
			}
		}
	}
	bfs();
	if(bis[t.x][t.y] == inf){
		cout << "-1 -1";
	}else{
		cout << vis[t.x][t.y] << " " << bis[t.x][t.y];
	}
	return 0;
}
```

---

## 作者：LionBlaze (赞：0)

简单题，不知道为什么是绿？

前置知识：01-BFS。如果你还不知道，首先你应该会 BFS，那么 BFS 的原理就是保持队列元素的代价（距离、长度等）从小到大。而如果边权只有 $0$ 和常数（通常为 $1$），则遇到边权为 $0$ 的点放入队首，否则放入队尾，也可以保持这样的性质，正确性有保证，时间复杂度也是线性的。这就是 01-BFS。

首先看如何走的步数（记为代价 A）最小。则直接走代价为 $1$，用魔法代价为 $0$，直接 01-BFS 即可。注意这里需要处理出所有可达节点的代价（走的步数）。判无解不用我说了吧？

然后看如何在这样的前提下使用魔法的次数（记为代价 B）最小。同样是 01-BFS（什么是 $0$ 什么是 $1$ 请读者自己练习，实在写不出来看代码吧），但是需要条件：不能够破坏代价 A 最小的性质。正确性证明也是很显然的，反证法，如果有一条路径中途破坏了代价 A 最小的性质，则后面代价 A 都会更多，走到终点也会更多，所以每一步都不能破坏。

[赛时代码](https://www.luogu.com.cn/record/219146784)：

```cpp
// Magic！
// Do the magic!
// 做法：显然是两次 bfs
// 对于第一次，求出至少要走几步（顺便把走不到给判了）
// 对于第二次，求出在走的步数最少的情况下最少要 Do the magic 多少次
#include <cstdio>
#include <queue>
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

char mp[5005][5005];
int dist1[5005][5005], dist2[5005][5005];
constexpr int dx1[] = {0, 0, 1, -1};
constexpr int dy1[] = {1, -1, 0, 0};
constexpr int dx2[] = {1, 1, -1, -1};
constexpr int dy2[] = {1, -1, 1, -1};
int main()
{
    memset(dist1, 0x3f, sizeof dist1);
    memset(dist2, 0x3f, sizeof dist2);
    int n, m;
    scanf("%d%d", &n, &m);
    int xx, xy, wx, wy;
    for(int i=1;i<=n;i++)
    {
        while(getchar() != '\n'); // 我要把这个用法推广给全世界 OIer！
        for(int j=1;j<=m;j++)
        {
            mp[i][j] = getchar();
            if(mp[i][j] == 'X')
            {
                xx = i;
                xy = j;
                mp[i][j] = '.';
            }
            if(mp[i][j] == 'W')
            {
                wx = i;
                wy = j;
                mp[i][j] = '.';
            }
        }
    }
    int sx = xx, sy = xy;
    deque<pair<int, int>> q1;
    dist1[sx][sy] = 0;
    dist2[sx][sy] = 0;
    q1.push_back({sx, sy});
    while(!q1.empty())
    {
        pair<int, int> u = q1.front();
        q1.pop_front();
        int x = u.first, y = u.second;
        for(int i=0;i<4;i++)
        {
            int ux = x + dx2[i], uy = y + dy2[i];
            if(mp[ux][uy] == '.' && dist1[x][y] < dist1[ux][uy])
            {
                dist1[ux][uy] = dist1[x][y];
                q1.push_front({ux, uy});
            }
        }
        for(int i=0;i<4;i++)
        {
            int ux = x + dx1[i], uy = y + dy1[i];
            if(mp[ux][uy] == '.' && dist1[x][y] + 1 < dist1[ux][uy])
            {
                dist1[ux][uy] = dist1[x][y] + 1;
                q1.push_back({ux, uy});
            }
        }
    }
    /*for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
{
    printf("dist1[%d][%d] = %d\n", i, j, dist1[i][j]);
}
        }*/
    if(dist1[wx][wy] == 0x3f3f3f3f)
    {
        printf("-1 -1\n");
        return 0;
    }
    deque<pair<int, int>> q2;
    q2.push_back({sx, sy});
    while(!q2.empty())
    {
        pair<int, int> u = q2.front();
        q2.pop_front();
        int x = u.first, y = u.second;
        // printf("x = %d, y = %d\n", x, y);
        for(int i=0;i<4;i++)
        {
            int vx = x + dx1[i], vy = y + dy1[i];
            if(mp[vx][vy] == '.' && dist1[x][y] + 1 == dist1[vx][vy] && dist2[x][y] < dist2[vx][vy])
            {
                dist2[vx][vy] = dist2[x][y];
                q2.push_front({vx, vy});
            }
        }
        for(int i=0;i<4;i++)
        {
            int vx = x + dx2[i], vy = y + dy2[i];
            if(mp[vx][vy] == '.' && dist1[x][y] == dist1[vx][vy] && dist2[x][y] + 1 < dist2[vx][vy])
            {
                dist2[vx][vy] = dist2[x][y] + 1;
                q2.push_back({vx, vy});
            }
        }
    }
    printf("%d %d\n", dist1[wx][wy], dist2[wx][wy]);
    return 0;
}
// 懂了，这场是 BFS 场。【题解中注：T3 做法也是 BFS】
// 但是 01bfs useful!
```

---


# 小 K 的农场

## 题目描述

小 K 在 MC 里面建立很多很多的农场，总共 $n$ 个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共 $m$ 个），以下列三种形式描述：  
- 农场 $a$ 比农场 $b$ 至少多种植了 $c$ 个单位的作物；
- 农场 $a$ 比农场 $b$ 至多多种植了 $c$ 个单位的作物；
- 农场 $a$ 与农场 $b$ 种植的作物数一样多。  

但是，由于小 K 的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。  


## 说明/提示

对于 $100\%$ 的数据，保证 $1 \le n,m,a,b,c \le 5 \times 10^3$。

## 样例 #1

### 输入

```
3 3
3 1 2
1 1 3 1
2 2 3 2
```

### 输出

```
Yes
```

# 题解

## 作者：SDqwq (赞：67)

[${\color{Orange}My}$ ${\color{Yellow}Blog}$](https://www.luogu.com.cn/blog/Sham-Devour/)

[P1993](https://www.luogu.com.cn/problem/P1993)

[前置知识：差分约束](https://www.luogu.com.cn/blog/Sham-Devour/ci-fen-yue-shu)

题意：给出 $n$ 个数 $a_{i}$ 和 $m$ 条关于 $a_{i}$ 的信息，问有没有一组 $a_{i}$ 满足所有信息，如果有输出 `Yes`，否则输出 `No`。

其中 $m$ 条信息有如下三种形式：

- $a_{i}-a_{j}\ge c$

- $a_{i}-a_{j}\le c$

- $a_{i}=a_{j}$

我们将式子转化为下面的形式：

- $a_{j}\le a_{i}-c$

- $a_{i}\le a_{j}+c$

- $a_{i}\le a_{j}+0$ 和 $a_{j}\le a_{i}+0$

那么我们再来看一下 SPFA 是怎么更新 $dis$ 数组是怎么更新的。

```cpp
for (int i = elast[u]; i != 0; i = e[i].next)
	if (dis[e[i].to] > dis[u] + e[i].len) {
		dis[e[i].to] = dis[u] + e[i].len;
		if (!vis[e[i].to]) {
			q.push(e[i].to);
			vis[e[i].to] = true;
		}
	}
```

也就是 $dis_{i}=\min\left\{dis_{j}+<j,i>\right\}$。

于是在遇到 $a_{i}\le a_{j}+c$ 这样的不等式时，我们可以从 $j$ 到 $i$ 建一条边权为 $b$ 的 **有向边**。

为了避免图不连通的情况，我们需要一个超级源点 $n+1$ ，与点 $i$ 之间连一条边权为 $0$ 的边。

那么怎么判断有没有解呢？

那就是判断 **负环**。

那么又怎么判断负环呢？

只要用一个数组来统计每个点的入队次数，如果某个点的入队次数 $\ge n+1$ 则说明无解，输出 `No`，否则输出 `Yes`。

### Problem Solving！

```cpp
#include <stdio.h>
#include <bits/stdc++.h>

using namespace std;

int n, m, cnt, elast[5005], dis[5005], num[5005];
bool vis[5005];

struct edge {
	int to, len, next;
} e[15005];

queue<int> q;

void add (int u, int v, int w) {
	e[++cnt].to = v;
	e[cnt].len = w;
	e[cnt].next = elast[u];
	elast[u] = cnt;
}

bool spfa (int x) {
	dis[x] = 0;
	q.push(x);
	vis[x] = true;
	num[x]++;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		vis[u] = false;
		for (int i = elast[u]; i != 0; i = e[i].next)
			if (dis[e[i].to] > dis[u] + e[i].len) {
				dis[e[i].to] = dis[u] + e[i].len;
				if (!vis[e[i].to]) {
					q.push(e[i].to);
					vis[e[i].to] = true;
					num[e[i].to]++;
					if (num[e[i].to] == n + 1)
						return false;
				}
			}
	}
	return true;
}

int main () {
	scanf("%d %d", &n, &m);
	memset(dis, 0x3f3f3f3f, sizeof(dis));
	for (int i = 1; i <= m; i++) {
		int opt;
		scanf("%d", &opt);
		switch (opt) {
			case 1: {
				int a, b, c;
				scanf("%d %d %d", &a, &b, &c);
				add(a, b, -c);
				break;
			}
			case 2: {
				int a, b, c;
				scanf("%d %d %d", &a, &b, &c);
				add(b, a, c);
				break;
			}
			case 3: {
				int a, b;
				scanf("%d %d", &a, &b);
				add(a, b, 0);
				add(b, a, 0);
				break;
			}
		}
	}
	for (int i = 1; i <= n; i++)
		add(n + 1, i, 0);
	bool flag = spfa(n + 1);
	if (!flag) {
		printf("No");
		return 0;
	}
	printf("Yes");
	return 0;
}
```

---

## 作者：傅天宇 (赞：31)

**[题目传送门](https://www.luogu.com.cn/problem/P1993)** 

诶诶诶怎么一个题解都没有，那么让我水一发吧。

~~SF 在讨论里说卡 DFS-DPFA，反正我用差分约束水，嘿嘿嘿。~~

**[差分约束入门？](https://www.luogu.com.cn/blog/ljfty666666666666/Difference-Constraints)**

现在来看看这道题。

题目说：

1. 农场 $a$ 比农场 $b$ 至少多种植了 $c$ 个单位的作物；

1. 农场 $a$ 比农场 $b$ 至多多种植了 $c$ 个单位的作物；

1. 农场 $a$ 与农场 $b$ 种植的作物数一样多。

由此，我们可以列出相应不等式：

$$

\left\{
\begin{aligned}
x_a-x_b &\geq c  \\
x_a-x_b &\leq c \\
x_a=x_b
\end{aligned}
\right.

$$



可以转换为
$$


\left\{
\begin{aligned}
x_b-x_a &\leq -c  \\
x_a-x_b &\leq c \\
x_a-x_b &\leq 0,x_b-x_a \leq 0
\end{aligned}
\right.

$$

这么建图：

```cpp
int opt,a,b,c;
scanf("%d",&opt);
if(opt==1)
{
    scanf("%d%d%d",&a,&b,&c);
    add(a,b,-c);
}
else if(opt==2)
{
    scanf("%d%d%d",&a,&b,&c);
    add(b,a,c);
}
else 
{
    scanf("%d%d",&a,&b);
    add(b,a,0);
    add(a,b,0);
}
```

然后就是模板了。

代码如下：

```cpp

#include<iostream>
#include<cstdio>
#include<queue>
#include<string.h>//头文件，我不喜欢万能头
using namespace std;
int n,m;
int tot,fir[10005];
struct edge
{
    int nxt,to,val;
}e[15005];
void add(int u,int v,int w)
{
    e[++tot]={fir[u],v,w};fir[u]=tot;
}//链式前向星式建图qwq
int dis[15005],cnt[15005];
bool vis[15005];
queue<int>q;
bool SPFA(int s)
{
    memset(dis,0x3f,sizeof dis);//赋值MAX
    vis[s]=1;
    dis[s]=0;
    q.push(s);//先标记表示入队
    while(!q.empty())
    {
        int u=q.front();q.pop();//出队
        vis[u]=0;
        for(int i=fir[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if(dis[v]>dis[u]+e[i].val)
            {
                dis[v]=dis[u]+e[i].val;
                cnt[v]++;
                if(cnt[v]==n)
                    return 0;//此时说明有负环
                if(vis[v]==0)
                {
                    vis[v]=1;
                    q.push(v);
                }//入队
            }
        }
    }
    return 1;
}//SPFA模板
int main()
{
    scanf("%d%d",&n,&m);
    int s=n+1;
    同上
    for(int i=1;i<=n;i++)
        add(s,i,0);
    if(SPFA(s)) cout<<"Yes";
    else cout<<"No";
    return 0;
}

```


于是，这道题就水过了。









---

## 作者：Energy_Making (赞：12)

# 思路
先读题，在读到“农场 a 比农场 b 至少多种植了 c 个单位的作物”时我们便可以知道这是一道差分约束了。分析如下：
- 农场 a 比农场 b 至少多种植了 c 个单位的作物即

$a-b \leq c$  -->>  $b \leq a-c$

- 农场 a 比农场 b 至多多种植了 c 个单位的作物即

$a-b \leq c$ -->> $a \leq b+c$ 

- 农场 a 与农场 b 种植的作物数一样多即

$a=b$

知道了这些之后就可以愉快地建图啦！最后运行还没被迫害的SPFA，如果有负权回路则输出No，否则输出Yes即可！不过记住要用链表，不然会爆掉！

不会SPFA者可以去看下[这篇文章](https://www.luogu.com.cn/blog/CEtoAC/post-spfa)，个人认为写得很好！

# 代码
```cpp
#include<stdio.h>
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
int n,m,w,k=1;
int dis[100000],Last[100000],cnt[100000];
struct node
{
	int l,r,val,Next;
};
node p[100000]; 
queue<int> q;
bool mark[100000];
void add(int u,int v,int w)
{
	p[k].l=u;
	p[k].r=v;
	p[k].val=w;
	p[k].Next=Last[p[k].l];
	Last[p[k].l]=k;
	k++;
}
bool SPFA(int s)
{
	int x;
	for(int i=1;i<=n;i++)dis[i]=inf;
	dis[s]=0;
	q.push(s);
	mark[s]=true;
	cnt[s]++;
	while(!q.empty())
	{
		x=q.front();
		q.pop();
		mark[x]=false;
		for(int i=Last[x];i!=0;i=p[i].Next)
		{
			if(dis[p[i].r]>dis[x]+p[i].val)
			{
				dis[p[i].r]=dis[x]+p[i].val;
				cnt[p[i].r]++;
				if(cnt[p[i].r]==n)return true;
				if(!mark[p[i].r]) 
				{
					q.push(p[i].r);
					mark[p[i].r]=true;
				}
			}
		}
	}
	return false;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int op,a,b,c;
		scanf("%d",&op);
		if (op==1)
		{
			scanf("%d%d%d",&a,&b,&c);
			add(a,b,-c);
		}
		else if(op==2)
		{
			scanf("%d%d%d",&a,&b,&c);
			add(b,a,c);
		}
		else if(op==3)
		{
			scanf("%d%d",&a,&b);
			add(a,b,0);
			add(b,a,0);
		}
	}
	for(int i=1;i<=n;i++)add(n+1,i,0);
	if(SPFA(n+1))printf("No");
	else printf("Yes");
}
```



---

## 作者：grass8cow (赞：9)

友好的差分约束。

我们先要建边。

对于第一种信息，有 $X_a-X_b\ge c$ ，则 $X_b-X_a\le -c$ ,建一条 $a$ 到 $b$ ，权值为 $-c$ 的边。

同理，对于第二种信息，有 $X_a-X_b\le c$ ,直接建 $b$ 到 $a$ ，权值为 $c$ 的边。

对于第三种信息，$X_a=X_b$ ，则$X_a-X_b\le 0$ ,$X_b-X_a\le 0$ ，建一条 $a$ 到 $b$ ，权值为 $0$ 的边，再建一条 $b$ 到 $a$ ，权值为 $0$ 的边。

还要建一源点，设其编号为 $0$ 。以其为起点，向每个点建一条权值为 $0$ 的边。这样做是因为原图里没有确定的源点。

跑最短路判一下有没有负环即可。

我发现自己以前做这题，是把上述边都反着建，跑最长路判正环的……太奇怪了。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct qq
{
	int v,w;
};
vector<qq>g[10001];
int n,m,di[10001],vi[10001];
bool spfa(int u)
{
	vi[u]=1;
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i].v,w=g[u][i].w;
		if(di[v]>di[u]+w)
		{
			di[v]=di[u]+w;
			if(vi[v])return 0;
			if(!spfa(v))return 0;
		}
	}
	vi[u]=0;
	return 1;
}
int main()
{
	cin>>n>>m;
	while(m--)
	{
		int q,u,v,w;
		cin>>q>>u>>v;
		if(q==1)
		{
			cin>>w;
			g[u].push_back((qq){v,-w});
		}
		if(q==2)
		{
			cin>>w;
			g[v].push_back((qq){u,w});
		}
		if(q==3)
		{
			g[u].push_back((qq){v,0});
			g[v].push_back((qq){u,0});
		}
	}
	for(int i=1;i<=n;i++)di[i]=2e8;
	for(int i=1;i<=n;i++)g[0].push_back((qq){i,0});
	if(spfa(0))cout<<"Yes";
	else cout<<"No";
	return 0;
}
```




---

## 作者：一只书虫仔 (赞：5)

[Best Watch in my Blog](https://www.luogu.com.cn/blog/Shuchong/solution-p1993)

#### Description

> [P1993](https://www.luogu.com.cn/problem/P1993)    
> 给定 $n$ 个数 $t_i$ 与 $m$ 个不等式形成的不等式组，求这个不等式组是否有解。    
> 这 $m$ 个不等式分为三类：
> - $t_j-t_i \ge b$
> - $t_j-t_i \le b$
> - $t_j=t_i$

#### Solution

这不就是妥妥的差分约束吗 /shake

那么我们可以以一个式子为例子来说明。（$t_j-t_i \le b$）

左边的这个 $t_i-t_j$ 就是差分。

我们首先把这个不等式化简一下，成 $t_i\le t_j+b$。

假设 $t_j$ 已知，我们可以推出 $t_i$ 的最大值只可能是 $t_j+b$，最小不限。

那我们再次假设如果 $t_i$ 跟 $t_{j'}$，$t_{j''}$，$t_{j'''}$ 都有关，我们就可以得到三个不等式，即一个不等式组

$$\begin{cases}t_i\le t_{j'}+b\\t_i\le t_{j''}+b\\t_i\le t_{j'''}+b\end{cases}$$

那么 $t_i$ 满足所有不等式下的最大值应该是 $\min\{t_{j'}+b,t_{j''}+b,t_{j'''}+b\}$。

因为要满足所有不等式，所以必须要取最小值来满足所有的不等式。

注意，我们上面提到的 $j$ 都可以模拟成 $i$ 的 **前继**。

那么我们可以再次简化模型。

假设有多个 $t_j$ 是 $t_i$ 的前继，那么我们就可以得到一个递推式。

$$t_i=\min\{t_j+b\}$$

那么我们看一下 SPFA 的递推式。

$$dist_i=\min\{dist_j+<i,j>\}$$

好了，破案了。

那么我们只需要找一个超级原点 $\rm super$，然后使得他连到 $i$ 的长度是 $t_i$ 即可。

最后我们求一个最短路即可。

然后判断有没有解就是看有没有负环即可。

剩下的两个式子和上面的式子形式差不多，就不多说了。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

struct node {
	int val, next, len;
} e[100086];

int n, m;
int cnt;
int head[100086];
int dist[100086];
int sum[100086];
int vis[100086];
const int inf = 0x3f3f3f3f;

void AddEdge (int u, int v, int w) {
	e[++cnt].val = v;
    e[cnt].next = head[u];
    e[cnt].len = w;
    head[u] = cnt;
}

bool SPFA () {
	queue <int> q;
	int s = n + 1;
	for (int i = 1; i <= n; i++)
		dist[i] = inf;
	dist[s] = 0;
	sum[s] = 1;
	vis[s]++;
	q.push(s);
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		sum[cur] = 0;
		for (int p = head[cur]; p > 0; p = e[p].next)
			if (dist[e[p].val] > dist[cur] + e[p].len) {
				dist[e[p].val] = dist[cur] + e[p].len;
				vis[e[p].val]++;
				if (vis[e[p].val] >= n + 1)
					return true;
				if (!sum[e[p].val]) {
					q.push(e[p].val);
					sum[e[p].val] = 1;
				}
			}
	}
	return false;
}

int main () {
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v, w; i <= m; i++) {
		int opt;
		scanf("%d", &opt);
		switch (opt) {
			case 1: {
				scanf("%d%d%d", &u, &v, &w);
				AddEdge(u, v, -w);
				break;
			}
			case 2: {
				scanf("%d%d%d", &u, &v, &w);
				AddEdge(v, u, w);
				break;
			}
			case 3: {
				scanf("%d%d", &u, &v);
				AddEdge(u, v, 0);
				AddEdge(v, u, 0);
				break;
			}
		}
	}
	for (int i = 1; i <= n; i++) 
		AddEdge(n + 1, i, 0);
	if (SPFA()) puts("No");
	else puts("Yes");
	return 0;
}
```

#### More to Say

其实我分析的那个式子就是差分约束模板：

- [P1260](https://www.luogu.com.cn/problem/P1260)
- [P5960](https://www.luogu.com.cn/problem/P5960)

我那两个题也写题解了 ~~哈哈哈其实我是复制粘贴的~~

- [P1260](https://www.luogu.com.cn/blog/Shuchong/solution-p1260)
- [P5960](https://www.luogu.com.cn/blog/Shuchong/solution-p5960)

By Shuchong    
2020.7.14

---

## 作者：Stinger (赞：2)

作为刚进洛谷没几天的蒟蒻中的蒟蒻中的蒟蒻的第一篇题解（我也只能写这种被大佬们两分钟爆切的题的题解），请各位路过的大佬们喜欢的点个赞~

**题目分析：**

看一下题目中给出的3种信息，建立对应的表达式，$a$ 表示农场 $a$ 作物数量，$b$表示农场 $b$ 作物数量，$c$表示两个农场作物数量差距。

农场 $a$ 比农场 $b$ **至少**多种植了 $c$ 个单位的作物，即

$a - b \geq c$


农场 $a$ 比农场 $b$ **至多**多种植了 $c$ 个单位的作物，即

$a - b \leq c$

为了统一，将他转换为 $\geq$ 表示的式子，通过等式两边同时乘以-1变号：


$b - a \geq -c$

农场 $a$ 与农场 $b$ 种植的作物数一样多：

$a - b \geq c$

$b - a \geq -c$

题目就是要我们判断这些不等式是否能全部满足。

差分约束即可，不懂差分约束的请自行 $ baidu first search $

~~（分析了半天其实就是一道板子题）~~

另外，这里说一句：SPFA加了SLF用时103ms，不加超过500ms。。。

~~（虽然都能过，但还是推荐使用SLF，保不准哪天洛谷评测机就咕了）~~

code ~~（请原谅蒟蒻码风清奇）~~
```cpp
#include <cstdio>
#include <cstring>
#include <deque>
using namespace std; 
struct Edge {
	int x, y, val, next;
}e[50001];
int elast[10001], dis[10001], cnt[10001];
bool mark[10001];
int n, m;
bool SPFA(int st)
{
	memset(dis, 127, sizeof(dis));
	memset(mark, false, sizeof(mark));
	dis[st] = 0;
	deque<int> q;
	q.push_back(st);
	while(q.size())
	{
		int u = q.front();
		q.pop_front();
		mark[u] = false;
		for (int i = elast[u]; i; i = e[i].next)
		{
			int v = e[i].y;
			if (dis[v] > dis[u] + e[i].val)
			{
				dis[v] = dis[u] + e[i].val;
				if (!mark[v])
				{
					cnt[v] ++;
					if (cnt[v] >= n) return false;
					if (q.size() && dis[q.front()] > dis[v])
					q.push_front(v);
					else q.push_back(v);
					mark[v] = true;
				}
			}
		}
	}
	return true;
}
int len;
void add(int x, int y, int z)
{
	e[++ len].x = x, e[len].y = y, e[len].val = z;
	e[len].next = elast[x];
	elast[x] = len;
}
int main()
{
	int j = 1;
	scanf("%d%d", &n, &m);
	for (int i = 1; j <= m; i ++, j ++)
	{
		int x, y, z, op;
		scanf("%d", &op);
		if (op == 1)
		{
			scanf("%d%d%d", &x, &y, &z);
			add(x, y, -z);
		}
		else if (op == 2)
		{
			scanf("%d%d%d", &x, &y, &z);
			add(y, x, z);
		}
		else
		{
			scanf("%d%d", &x, &y);
			add(y, x, 0);
			add(x, y, 0);
		}
	}
	for (int i = 1; i <= n; i ++)
	add(n + 1, i, 0);
	int Count = 0;
	if (!SPFA(n + 1)) puts("No");
	else puts("Yes");
}
```cpp



---

## 作者：Vocanda (赞：1)

# 题目
[题目链接](https://www.luogu.com.cn/problem/P1993)
# 分析
其实可以说是一个差分约束的裸题，看到这样熟悉的不等式的条件，很容易就可以想出建图的方法。
### 什么？不会差分约束
[戳这里了解差分约束](https://www.cnblogs.com/zzz-hhh/p/11200893.html)

### 现在进入正题
不会差分约束的同志应该已经又会了（大雾）。所以我们开始分析题目。

首先题目给出了三个条件，稍微转化一下就可以搞出来三个不等式（貌似是俩）。具体不等式如下：
$$
\begin{cases}
val_a - val_b \ge c\\
val_b - val_a \le c\\
val_a =val_b
\end{cases}$$

我们移一下项，可以得到如下的不等式
$$
\begin{cases}
val_b-val_a \le -c\\
val_a-val_b\le c\\
val_a-val_b\le 0\ \&\&\ val_b-val_a\le0
\end{cases}
$$

那么根据这个柿子我们就可以建边了，通过刚刚的差分约束学习，肯定这样的建边是很简单的。建边如下：
```cpp
	for(int i=1;i<=m;++i){
		int id,a,b,c;
		cin>>id>>a>>b;
		if(id!=3)cin>>c;
		switch(id){
			case 1: Add(a,b,-c);break;
			case 2: Add(b,a,c);break;
			case 3: Add(a,b,0);Add(b,a,0);
		}
	}
```
但是如果仅仅搞一个这样的建边就挂了，因为图没有保证联通，所以我们需要建一个保证联通的超级原点，然后从这个点跑最短路就行，注意一定要判断负环，那么这个题就解决了。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e4+10;
int n;
int dis[maxn],cnt[maxn],tot,head[maxn],vis[maxn];
struct Node{
	int v,next,w;
}e[maxn];
queue<int>q;
void Add(int x,int y,int val){//建边
	e[++tot].v =  y;
	e[tot].next = head[x];
	head[x] = tot;
	e[tot].w = val;
}
int spfa(){//spfa最短路
	memset(dis,0x3f,sizeof(dis));
	dis[0] = 0;
	vis[0] = 1;
	q.push(0);
	while(!q.empty()){
		int x = q.front();
		q.pop();
		vis[x] = 0;
		for(int i=head[x];i!=-1;i=e[i].next){
			int v=e[i].v;
			if( dis[v]>dis[x]+e[i].w){
				dis[v] = dis[x] + e[i].w;
				cnt[v] = cnt[x] + 1;//记录访问次数
				if(cnt[v]>n) return 0;//访问次数大于n了说明有负环，返回不合法
				if(!vis[v]){
					vis[v] = 1;
					q.push(v);
				}
			}
		}
	}
	return 1;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	memset(head,-1,sizeof(head));
	int m;
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		int id,a,b,c;
		cin>>id>>a>>b;
		if(id!=3)cin>>c;
		switch(id){//差分约束条件建边
			case 1: Add(a,b,-c);break;
			case 2: Add(b,a,c);break;
			case 3: Add(a,b,0);Add(b,a,0);
		}
	}
	for(int i=1;i<=n;++i){//建立超级原点
		Add(0,i,0);
	}
	if(spfa()){//如果没有负环，符合条件，那么就是Yes
		cout<<"Yes\n";
	}
	else cout<<"No\n";//否则是No
	return 0;
}

```


---

## 作者：lndjy (赞：0)

### 差分约束

前置知识： [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)

这题转化为差分约束比较简单。

题面给的 $1$ 就相当于 $a-b\ge c$，两边同时乘 $-1$ 得 $b-a\le-c$ ,变成了差分约束的形式。

$2$ 就相当于 $a-b\le c$,直接可以差分约束。

$3$ 就相当于 $a=b$，也就是 $a-b=0$ ,转化成不等式就是 $a-b\le 0$ 且 $a-b\ge 0$，后面的不等式可以用 $1$ 的方法，变成 $b-a\le 0$。

这样，都转化成了差分约束的形式，套板子即可。

代码（貌似大常数，需要吸氧）：
```cpp
#include<iostream>
#include<queue>
using namespace std;
const int N=5005;
struct edge
{
	int to,nxt,v;
}e[4*N];
int n,m,cnt;
int head[N],dis[N],tot[N],v[N];
void add(int u,int v,int w)
{
	cnt++;
	e[cnt].to=v;
	e[cnt].v=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
bool spfa()
{
	queue<int> q;
	for(int i=1;i<=n;i++)
	dis[i]=2e9;
	q.push(0);
	v[0]=1;
	while(!q.empty())
	{
		int now=q.front();q.pop();
		v[now]=0;
		for(int i=head[now];i;i=e[i].nxt)
		{
			if(dis[e[i].to]>dis[now]+e[i].v)
			{
				dis[e[i].to]=dis[now]+e[i].v;
				if(!v[e[i].to])
				{
					v[e[i].to]=1;
					tot[e[i].to]++;
					if(tot[e[i].to]==n) return 0;
					q.push(e[i].to);
				}
			}
		}
	}
	return 1;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	add(0,i,0);
	for(int i=1;i<=m;i++)
	{
		int op,a,b,c;
		cin>>op>>a>>b;
		if(op==1)
		{
			cin>>c;
			add(a,b,-c);
		}
		if(op==2)
		{
			cin>>c;
			add(b,a,c);
		}
		if(op==3)
		{
			add(a,b,0);
			add(b,a,0);
		}
	}
	cout<<(spfa()?"Yes":"No");
	return 0;
}
```


---


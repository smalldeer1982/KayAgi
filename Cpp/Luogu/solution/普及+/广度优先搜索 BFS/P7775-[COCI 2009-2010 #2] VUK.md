# [COCI 2009/2010 #2] VUK

## 题目背景

本题为[$\texttt{COCI 2009-2010}\ 2^\texttt{nd}\ \texttt{round}\ \text{T4 VUK}$](https://hsin.hr/coci/archive/2009_2010/contest2_tasks.pdf)。

分值按原题设置，满分 $100$。

## 题目描述

一匹狼 Vjekoslav 正在逃离一批残暴的猎人的追捕。

这些猎人非常凶残，经常躲在树后面，但 Vjekoslav 并不知道哪棵树后有猎人。为了保险，Vjekoslav 希望在逃回它舒适的窝的过程中离树越远越好。

森林可以抽象为 $N\times M$ 的矩阵。每个格子可能是空的（用`.`表示），也有可能有一棵树在中心位置（用`+`表示）。Vjekoslav在`V`标示的地方而它的窝在`J`标示的地方。定义 Vjekoslav 与某棵树的距离为它们所在格的曼哈顿距离（即这两个格子所在行、列之差的绝对值之和）。

Vjekoslav 每次可以往东南西北中的任一方向移动，**即使它下一步移动到的格子有树（此题树并不会阻挡 Vjekoslav）**。帮忙找出这样一条从`V`到`J`的路径，使得 Vjekoslav 在途中离它最近的树的距离的最小值最大。

**注意 Vjekoslav 的窝并不占据整块格子，因此你的路径中必须包含`J`。**

## 说明/提示

$1\leq N,M\leq500$。

## 样例 #1

### 输入

```
4 4
+...
....
....
V..J
```

### 输出

```
3```

## 样例 #2

### 输入

```
4 5
.....
.+++.
.+.+.
V+.J+```

### 输出

```
0```

# 题解

## 作者：little_cindy (赞：16)

### 橙名之后第一篇题解！
## 思路
题目的信息很明确，也十分简单，跑个 bfs 就行了。

可是，我们需要求出每一个点到最近的树的曼哈顿距离。

根据曼哈顿距离的定义，其实就是一个点到另一个点的最短路。所以，把所有树的位置放入队列，再用 bfs 求出最短路即可。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=505;
int mhd[maxn][maxn],n,m;
bool danger[maxn][maxn],vis[maxn][maxn];
struct wolf{
	int x;
	int y;
	int Manhattan_distance;//Vjekoslav 在逃回窝的途中离它最近的树的距离的最小值
	bool operator < (const wolf &tmp) const {//重载一下运算符
		return Manhattan_distance<tmp.Manhattan_distance;
	} 
};
struct node{
	int x,y,h;
}e,s;
int dx[4]={0,0,1,-1};//方向函数
int dy[4]={1,-1,0,0};
queue<node> nq;
void bfs1(){//求曼哈顿距离
	while(!nq.empty()){
		node cur=nq.front();
		nq.pop();
		mhd[cur.x][cur.y]=cur.h;
		for(int i=0;i<4;i++){
			int nx=cur.x+dx[i];
			int ny=cur.y+dy[i];
			if(1<=nx&&nx<=n&&1<=ny&&ny<=m&&!danger[nx][ny]){
				danger[nx][ny]=1;
				nq.push({nx,ny,cur.h+1});
			}
		}
	}
	return;
}
int bfs(int x,int y){//求答案
	int ans=1e9;
	priority_queue<wolf> q;
	vis[x][y]=1;
	q.push({x,y,mhd[x][y]});
	while(!q.empty()){
		wolf cur=q.top();
		q.pop();
		if(cur.x==e.x&&cur.y==e.y) {//取最小答案
			ans=min(ans,cur.Manhattan_distance);
		}
		for(int i=0;i<4;i++){
			int nx=cur.x+dx[i];
			int ny=cur.y+dy[i];
			if(1<=nx&&nx<=n&&1<=ny&&ny<=m&&!vis[nx][ny]){
				vis[nx][ny]=1;
				q.push({nx,ny,min(cur.Manhattan_distance,mhd[nx][ny])});
			}
		}
	}
	return ans;//返回答案
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){
    		char a;
    		cin>>a;
    		if(a=='+'){//树
    			danger[i][j]=1;
    			nq.push({i,j,0});
			}
			else if(a=='V'){//起点
				s={i,j};
			}
			else if(a=='J'){//终点
				e={i,j};
			}
		}
	}
	bfs1();
	cout<<bfs(s.x,s.y);
	return 0;
}

```


---

## 作者：无钩七不改名 (赞：9)

## P7775 题解

### 前言

CSP 期间，搞篇题解涨一下 RP。

感谢@[Meteorshower_Y ](https://www.luogu.com.cn/user/239164)对本题解提出的意见QWQ

[原题戳这里](https://www.luogu.com.cn/problem/P7775)

### 题目大意

在一个 $n \times m$ 的矩阵中，有一些空地，有一些树，我们需要找出一条路径，使 慕汐 从其所在地 `V` 回到家 `J` ，且路径上距离树最近的点到树的距离最大。  
输出这个最大的最近距离。   
(本题中的距离均为曼哈顿距离, $n$ 和 $m$ 同阶)

### 解题思路

首先我们需要知道每一个点到与其距离最近的树的距离，这有两种方法可以求出：  
1. 对每一个点暴力寻找最近的树。当然， $O(n^4)$ 的复杂度我们难以接受，故不再考虑。 

2. 对每一棵树往外进行 bfs ，类似于最短路的过程，一次枚举一棵树复杂度也是 $O(n^4)$ 的 … … 直接一次把树都搞进 bfs 的队列进行一次 bfs 就好了，这样预处理距离就是 $O(n^2)$ 的了。  

然后我们就可以求解答案了，这也有两种方法：  
1. 二分答案：  
我们二分这个最小距离，若当前的 mid 满足条件（即存在一条路径，路径上的点和最近的树的距离 **大于等于** mid），则 mid 取更小的值一定也满足条件；若不满足，则更大的 mid 一定也不满足条件。所以这道题有决策单调性，可以用二分求解答案。  
对于每一个 mid ，直接 用 bfs 去 check 图中是否存在满足题意的路径即可。  
时间复杂度 $O(n^2 \log n)$.

2. 贪心：
若将某个点加入路径上，当前以这个点为终点的路径的答案为它上下左右四个点的答案和它本身和树的最近距离取较小值，所以一个点的答案是由四周更新而来，换句话说一个点可以去更新四周的答案。这里是类似于 dijkstra 求最短路的贪心思想，从起点开始一层层向外拓展答案，第一次到达终点时，终点对应的值便是答案。  
那么我们直接从起点出发，记录路径上距离树最近的点和树之间的距离放入优先队列（大根堆），每次取出当前距离最大的点继续向下拓展，第一次到达终点时的记录的距离便是答案。
时间复杂度 $O(n^2\log n^2)$.

### Code

这里放上用优先队列贪心的代码（放心食用，挺快的）

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 510;
struct node{int x,y;};
struct MX_muxi{
    int x,y,k;
    friend bool operator<(MX_muxi a,MX_muxi b){
        return a.k < b.k;
    }
}p;

int n,m,sx,sy,tx,ty;
int a[N][N],vis[N][N];
int dx[4]{1,-1,0,0};
int dy[4]{0,0,1,-1};
char mp[N][N];

void bfs(){
    memset(a,255,sizeof(a));
    int qx[N*N],qy[N*N],l=1,r=0,x,y,nx,ny;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(mp[i][j]=='+'){
                a[i][j]=0;
                qx[++r]=i;
                qy[r]=j;
            }
    while(l<=r){
        x=qx[l];
        y=qy[l];
        l++;
        for(int i=0;i<4;i++){
            nx=x+dx[i];
            ny=y+dy[i];
            if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&a[nx][ny]==-1){
                a[nx][ny]=a[x][y]+1;
                qx[++r]=nx;
                qy[r]=ny;
            }
        }
    }
}

int solve(){
    memset(vis,0,sizeof(vis));
    priority_queue<MX_muxi> q;
    q.push({sx,sy,a[sx][sy]});
    int x,y,k,nx,ny;
    while(!q.empty()){
        p=q.top();
        q.pop();
        x=p.x;
        y=p.y;
        k=p.k;
        if(x==tx&&y==ty)return k;
        for(int i=0;i<4;i++){
            nx=x+dx[i];
            ny=y+dy[i];
            if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&vis[nx][ny]==0){
                q.push({nx,ny,min(k,a[nx][ny])});
                vis[nx][ny]=1;
            }
        }
        
    }
    return 0;
}

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>(mp[i]+1);
    bfs();
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(mp[i][j]=='V'){
                sx=i;
                sy=j;
            }
            if(mp[i][j]=='J'){
                tx=i;
                ty=j;
            }
        }
    }
    cout<<solve();
    return 0;
}
```

---

## 作者：lmz_ (赞：6)

**最小值最大**，一看就知道是二分答案了。

我们先来看一下样例：
```
+...
....
....
V..J
```
和树保持 $3$ 的距离可以换一个说法，为：“和树距离 $2$ 位置的地方都不能走”，那么我们更改一下矩阵：
```
+11.
11..
1..
V..J
```
这些地方都是不可以走的，所以我们需要一个 bfs 来标记不能走的：

因为有多棵树，所以我们需要使用多起点 bfs，我们只需要将所有起点入队列即可。
```cpp
int check(int mid){
	memcpy(vis1,vis,sizeof(vis));
	queue<node>q1=q;
	while(q1.size()){
		node f=q1.front();
		q1.pop();
		if(f.s>=mid-1) continue;
		node nx;
		for(int i=0;i<4;i++){
			nx=node{f.x+X[i],f.y+Y[i],0};
			if(nx.x>=1&&nx.x<=n&&nx.y>=1&&nx.y<=m&&vis1[nx.x][nx.y]==0){
				nx.s=f.s+1;
				vis1[nx.x][nx.y]=1;
				q1.push(nx);
			}
		}
	}
	if(vis1[sx][sy]) return 0;
	return dfs(sx,sy);
}
```
然后，我们标记完了以后，需要使用 dfs 看是否能到达，直接使用普通的 dfs 就可以了：
```cpp
bool dfs(int x,int y){
	if(mp[x][y]=='J') return 1;
	for(int i=0;i<4;i++){
		int nx=x+X[i],ny=y+Y[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&!vis1[nx][ny]){
			vis1[nx][ny]=1;
			if(dfs(nx,ny)) return 1;
		}
	}
	return 0;
}
```
最后我们只需要在主函数里写一个二分答案就可以 AC 力！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=510,X[]={0,1,0,-1},Y[]={-1,0,1,0};
int n,m,sx,sy,vis[maxn][maxn],vis1[maxn][maxn];
char mp[maxn][maxn];
struct node{
    int x,y,s;
};
queue<node>q;
bool dfs(int x,int y){
	if(mp[x][y]=='J') return 1;
	for(int i=0;i<4;i++){
		int nx=x+X[i],ny=y+Y[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&!vis1[nx][ny]){
			vis1[nx][ny]=1;
			if(dfs(nx,ny)) return 1;
		}
	}
	return 0;
}
int check(int mid){
	memcpy(vis1,vis,sizeof(vis));
	queue<node>q1=q;
	while(q1.size()){
		node f=q1.front();
		q1.pop();
		if(f.s>=mid-1) continue;
		node nx;
		for(int i=0;i<4;i++){
			nx=node{f.x+X[i],f.y+Y[i],0};
			if(nx.x>=1&&nx.x<=n&&nx.y>=1&&nx.y<=m&&vis1[nx.x][nx.y]==0){
				nx.s=f.s+1;
				vis1[nx.x][nx.y]=1;
				q1.push(nx);
			}
		}
	}
	if(vis1[sx][sy]) return 0;
	return dfs(sx,sy);
}
int main(){
	int ans=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
			if(mp[i][j]=='+'){
				q.push(node{i,j,0});
				vis[i][j]=1;
			}
			if(mp[i][j]=='V') sx=i,sy=j;
		}
    int l=1,r=n;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid)){
            ans=mid;
            l=mid+1;
        }
        else r=mid-1;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：WsW_ (赞：5)

### 思路
先预处理所有点 $(i,j)$ 到最近的树的距离 $s_{ij}$，再二分答案 $ans$。每次二分检验时只走满足 $s_{ij}\ge ans$ 的点 $(i,j)$，看看能否走到终点即可。  
因为必须经过起点和终点，所以二分右边界为起点、终点两者中较小的 $s$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;

struct node{
	int x,y;
};

int dis[4][2]={0,1,1,0,0,-1,-1,0};
int n,m;
char c;
int s[505][505];
node hunt[300000];
int hl;
int sx,sy,ex,ey;
bool vis[505][505];
queue<node>q;

bool check(int check_x){
	while(!q.empty())q.pop();//因为可能队列还没空就return 1，所以每次检验要清空队列
	memset(vis,0,sizeof(vis));
	q.push({sx,sy});
	vis[sx][sy]=1;
	while(!q.empty()){
		int nx=q.front().x,ny=q.front().y;
		q.pop();
		if(nx==ex&&ny==ey)return 1;
		for(int i=0;i<4;i++){
			int tx=nx+dis[i][0],ty=ny+dis[i][1];
			if(tx>0&&ty>0&&tx<=n&&ty<=m&&!vis[tx][ty]&&s[tx][ty]>=check_x){
				vis[tx][ty]=1;
				q.push({tx,ty});
			}
		}
	}
	return 0;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c;
			s[i][j]=1e9;
			if(c=='+')q.push({i,j}),s[i][j]=0;
			if(c=='V')sx=i,sy=j;
			if(c=='J')ex=i,ey=j;
		}
	}
	while(!q.empty()){//预处理
		int nx=q.front().x,ny=q.front().y;
		q.pop();
		for(int i=0;i<4;i++){
			int tx=nx+dis[i][0],ty=ny+dis[i][1];
			if(tx>0&&ty>0&&tx<=n&&ty<=m&&s[tx][ty]>s[nx][ny]+1){
				s[tx][ty]=s[nx][ny]+1;
				q.push({tx,ty});
			}
		}
	}
	int left=0,righ=min(s[sx][sy],s[ex][ey]),mid,ans;
	while(left<=righ){
		mid=left+righ>>1;
		if(check(mid)){
			ans=mid;
			left=mid+1;
		}
		else righ=mid-1;
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Su777 (赞：3)

临近 CSP 2023，写篇题解涨点 RP。

## 思路

题目在最简单的 bfs 求最短路上加上了树的限制，求**与树的最小距离的最大值**，最小值最大明显用**二分答案**。

每次二分**与树的距离限制**，然后在 bfs 时加入距离的判断即可。

此外这题还有一个小小的优化~~卡了我三个多小时~~：需要提前 bfs 预处理每一个位置离**最近一棵树**的距离，这样就不用每次判断了。如果不加此优化会挂成 $70$ 分。

## 代码（超详细注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> PII; // pair<i,j> 表示位置 (i,j)
int n, m; // 地图大小
int sx, sy; // 起点位置
int ex, ey; // 终点位置
char arr[505][505]; // 地图
PII tree[250005]; // 存储树的位置
int tcnt = 0; // treecnt
int tdis[505][505]; // 提前预处理与最近的树的距离
// 坐标变换数组
int cx[] = {1, -1, 0, 0};
int cy[] = {0, 0, 1, -1};
bool vis[505][505]; // 记录 bfs 遍历信息

bool in(int x, int y) { // 判断某位置是否越界（没越界返回 true，越界返回 false）
    return x >= 1 && x <= n && y >= 1 && y <= m;
}

queue<PII> work_q; // 预处理距离需要用到 bfs，所以需要定义一个 queue
void work() {
    while (!work_q.empty()) {
        auto t = work_q.front(); // 取出队头
        work_q.pop();
        int x = t.first, y = t.second;
        for (int c = 0; c < 4; c ++) { // 坐标变换
            int xx = x + cx[c];
            int yy = y + cy[c];
            // 如果变换后的坐标没有越界且从原坐标转移得到的距离更短
            if (in(xx, yy) && tdis[xx][yy] /*原先记录的距离*/ > tdis[x][y] + 1 /*转移得到的距离*/) {
                tdis[xx][yy] = tdis[x][y] + 1; // 更新距离
                work_q.push({xx, yy}); // 加入队列
            }
        }
    }
}

bool bfs(int dis) { // x 代表与树的距离限制
    memset(vis, 0, sizeof(vis)); // 多测不清空，爆零两行泪！！！！！！！
    queue<PII> q; // 定义 bfs 遍历需要的队列
    if (tdis[sx][sy] < dis) return false; // 如果起点本身不满足树的距离限制，则退出函数
    q.push({sx, sy}); // 把起点加入队列
    while (!q.empty()) {
        auto t = q.front(); // 取队头
        q.pop();
        int x = t.first, y = t.second;
        if (!in(x, y)) continue; // 如果越界那么直接继续
        if (arr[x][y] == 'J') return true; // 如果到达终点那么直接返回 true（在本限制下可以到达终点）
        for (int c = 0; c < 4; c ++) { // 坐标变换
            int xx = x + cx[c];
            int yy = y + cy[c];
            // 如果 距离不满足要求 或 已经被访问过 或 坐标越界，那么直接继续
            if (tdis[xx][yy] < dis || vis[xx][yy] || !in(xx, yy)) continue;
            vis[xx][yy] = true; // 坐标合法，打上已访问的标记
            q.push({xx, yy}); // 加入队列
        }
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    memset(tdis, 0x3f, sizeof(tdis)); // 因为要求距离最小值，所以数组初始化为 inf（0x3f3f3f3f）
    for (int i = 1; i <= n; i ++) {
        for (int j = 1; j <= m; j ++) {
            char c;
            cin >> c;
            arr[i][j] = c;
            if (arr[i][j] == 'V') { // 记录起点坐标
                sx = i;
                sy = j;
            }
            if (arr[i][j] == 'J') { // 记录终点坐标
                ex = i;
                ey = j;
            }
            if (arr[i][j] == '+') { // 如果此位置上是树
                tcnt ++; // 记录树的位置
                tree[tcnt].first = i;
                tree[tcnt].second = j;
                tdis[i][j] = 0; // 边界情况：树所在的位置与树的距离为 0
                work_q.push({i, j}); // 在预处理队列中加入本棵树
            }
        }
    }

    work(); // 预处理每个位置与最近的树的距离

    // 二分与树的距离限制
    int l = 0, r = n, ans = -1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (bfs(mid)) { // 本限制可以符合要求，尝试更大（更严格）的限制
            ans = mid;
            l = mid + 1;
        } else { // 本限制不能满足要求，尝试更小（更宽容）的限制
            r = mid - 1;
        }
    }
    cout << ans << endl;
    return 0;
}
```



---

## 作者：yangruoyi (赞：3)

# P7775题解

## 思路

比较神奇，复杂度 $O(n^2\alpha(n))$，跑得飞快。

首先，把每棵树加入队列中，然后跑一遍 BFS，求出每个点到最近的树的距离。

然后，按照每个点距离从大到小，依次加入并查集，然后判断一下起点和终点是否连通，如果连通，就输出答案并退出。

## [CODE](https://www.luogu.com.cn/paste/e23qr99m)

---

## 作者：幻想繁星 (赞：3)

我们先来看一下样例：

$\texttt{+...} $  
$\texttt{....} $   
$\texttt{....} $  
$\texttt{V..J} $

和树保持 $3$ 的距离可以换一个说法，为：“和树距离 $2$ 位置的地方都不能走”，那么我们更改一下矩阵：

$ \texttt{+\#\#.} $  
$ \texttt{\#\#..} $   
$ \texttt{\#...} $  
$ \texttt{V..J} $


这些标记为 $\texttt{\#}$ 地方都是不可以走的。

所以得出以下步骤
1. 我们需要一个 bfs 来标记不能走的：因为有多棵树，所以我们需要使用多起点 bfs，我们只需要将所有起点入队列即可。
```cpp
int check(int mid)//bfs判断 
{
	for(int i=0;i<510;i++) for(int j=0;j<510;j++) visn[i][j]=vis[i][j];
	queue<nq>q1=q;
	while(!q1.empty())
	{
		nq f=q1.front();
		q1.pop();
		if(f.s>=mid-1) continue;
		nq nx;
		for(int i=0;i<4;i++)
		{
			n.x=f.x+X[i];
			n.y=f.y+Y[i];
			n.s=0;
			if((n.x>=1&&n.x<=n)&&(n.y>=1&&n.y<=m)&&(!visn[n.x][n.y]))
			{
				nx.s=f.s+1;
				visn[n.x][n.y]=1;
				q1.push(n);
			}
		}
	}
	if(visn[lx][ly]) return 0;
	return dfs(lx,ly);//进行下一步
}
```

2. 然后，我们需要使用普通的 dfs 就可以看是否能到达。
```cpp
bool dfs(int x,int y)//dfs搜索 
{
	if(map[x][y]=='J') return 1;
	for(int i=0;i<4;i++)
	{
		int nx=x+X[i],ny=y+Y[i];
		if((nx>=1&&nx<=n)&&(ny>=1&&ny<=m)&&(!visn[nx][ny]))
		{
			visn[nx][ny]=1;
			if(dfs(nx,ny)) return 1;
		}
	}
	return 0;
}
```

3. 最后我们只需要在主函数里写一个二分答案。
```cpp
while(l<=r)//二分 
	{
        int mid=(l+r)/2;
        if(check(mid))//bfs判断
		{
            ans=mid;
            l=mid+1;
        }
        else r=mid-1;
    }
```

---

## 作者：_caiji_ (赞：3)

bfs + 二分。

首先算出一个数组 $w_{i,j}$，表示 $(i,j)$ 这个格子与离它最近的树的距离。这个过程可以参考 [P1332 血色先锋队](https://www.luogu.com.cn/problem/P1332)，把所有树的位置扔队列里，一起做一次 bfs。

接着，设「Vjekoslav 在途中离它最近的树的距离的最小值」为 $k$，那么题目就变成了只能走 $w_{i,j}\geq k$ 的点，问可不可以从 `V` 点到达 `J` 点。

我们设最终要输出的答案为 $ans$，显然 $ans$ 可以通过二分答案这一算法求出。如果只能走 $w_{i,j}\geq k$ 的点能到达，那么对于 $\forall l\leq k$，只能走 $w_{i,j}\geq l$ 的点一定能到达；如果只能走 $w_{i,j}\geq k$ 的点不能到达，那么对于 $\forall l\geq k$，只能走 $w_{i,j}\geq l$ 的点一定也不能到达。综上所述，$ans$ 满足单调性，二分答案是正确的。

下面，给出我的代码实现：
```cpp
#include <queue>
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;
const int dx[]={0,-1,0,0,1},
          dy[]={0,0,-1,1,0};
int n,m,sx,sy,ex,ey;
bool vis[510][510];
int w[510][510];
struct node{
    int x,y;
    node(int x=0,int y=0):x(x),y(y){}
};
queue<node> q;
bool bfs(int sx=0,int sy=0,int ex=0,int ey=0,int l=0,bool k=1){
//k=1 表示当前正在求 w 数组，k=0 表示当前正在二分求 ans
    if(!k) q.push(node(sx,sy)),vis[sx][sy]=1;
    while(!q.empty()){
        node now=q.front();q.pop();
        if(!k&&now.x==ex&&now.y==ey) return 1;
        for(int i=1;i<=4;i++){
            int tmpx=now.x+dx[i],tmpy=now.y+dy[i];
            if(1<=tmpx&&tmpx<=n&&1<=tmpy&&tmpy<=m){
                if(k?w[now.x][now.y]+1<w[tmpx][tmpy]:w[tmpx][tmpy]>=l&&!vis[tmpx][tmpy]){
                    if(k) w[tmpx][tmpy]=w[now.x][now.y]+1;
                    //两个点的曼哈顿距离 = 从一个点到达另一个点要走几步
                    else vis[tmpx][tmpy]=1;
                    q.push(node(tmpx,tmpy));
                }
            }
        }
    }
    return 0;
}
bool check(int now){
    if(w[sx][sy]<now) return 0;
    //bfs 时是遍历不到起点的，需要手动特判一下
    memset(vis,0,sizeof vis);
    q=queue<node>();
    return bfs(sx,sy,ex,ey,now,0);
}
int binary(int L,int R){
    int ans=0,mid;
    while(L<=R){
        if(!check(mid=(L+R)>>1)) R=mid-1;
        else ans=mid,L=mid+1;
    }
    return ans;
}
int main(){
    memset(w,0x3f,sizeof w);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){char ch;
            cin>>ch;
            if(ch=='+') w[i][j]=0,q.push(node(i,j));
            if(ch=='V') sx=i,sy=j;
            if(ch=='J') ex=i,ey=j;
        }
    }
    bfs();
    /*for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cout<<w[i][j]<<" \n"[j==m];
        }
    }*/
    cout<<binary(0,1e3)<<endl;
    return 0;
}
```


---

## 作者：zbk233 (赞：2)

## 解题思路

本题大致可分为以下两个部分：

1. 预处理矩阵上的每一个点与所有树的最短曼哈顿距离。

2. 计算出一条使每个点最近距离的最小值最大的最优路径。

这两个部分都可以使用 ```bfs``` 来求解。

对于第一部分，我们可以将所有树的位置信息丢进一个队列里，用 ```bfs``` 求出每一个点与树的最近的曼哈顿距离。

对于第二部分，我们可以使用优先队列搭配 ```bfs```，优先看那些目前最近距离比较大的点，当走过这个点后，算出在这个点之前的所有点与树的距离的最小值，再与当前的这个点与树的距离求出最小值。

## 参考代码

```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
struct node{
	int x,y,step;
};
struct dij{
	int x,y;
	int now;
	bool operator < (const dij &temp)const{
		return temp.now>now;
	}
};
int n,m,sx,sy,ex,ey,minans=1145141919;
queue<node> q;
priority_queue<dij> p;
char ch[505][505];
int map[505][505];
bool vis[505][505];
int dx[]={0,0,-1,1};
int dy[]={-1,1,0,0};
void bfs1(){
	while(!q.empty()){
		node tmp=q.front();
		q.pop();
		for(int i=0;i<4;i++){
			int nx=tmp.x+dx[i];
			int ny=tmp.y+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&!vis[nx][ny]){
				vis[nx][ny]=1;
				map[nx][ny]=tmp.step+1; 
				q.push(node{nx,ny,map[nx][ny]});
			}
		}
	}
}
void bfs2(){
	while(!p.empty()){
		dij tmp=p.top();
		p.pop();
		if(tmp.x==ex&&tmp.y==ey){
			minans=min(minans,tmp.now);
		}
		for(int i=0;i<4;i++){
			int nx=tmp.x+dx[i];
			int ny=tmp.y+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&!vis[nx][ny]){
				vis[nx][ny]=1;
				p.push(dij{nx,ny,min(tmp.now,map[nx][ny])});
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>ch[i][j];
			if(ch[i][j]=='+'){
				vis[i][j]=1;
				q.push(node{i,j,0});
			}
			if(ch[i][j]=='V'){
				sx=i;sy=j;
			}
			if(ch[i][j]=='J'){
				ex=i;ey=j;
			}
		}
	}
	bfs1();
	p.push(dij{sx,sy,map[sx][sy]});
	memset(vis,0,sizeof(vis));
	bfs2();
	cout<<minans;
	return 0;
}
```


---

## 作者：_Emperorpenguin_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7775)

**注意，本题解中提到的所有距离皆为曼哈顿距离。**

## 题意简述：

$N \times M$ 大小的地图上，有一匹狼想要从 $V$ 点跑到 $J$ 点。地图上有一些树，这匹狼想要在从 $V$ 点到 $J$ 点的所有路径中选择一条路径，使其距离树的最小值尽可能的大。


## 思路

因为要求“最大的最小”，故想到二分答案。

我们可以将二分出来的答案 $mid$ 带入 BFS 进行预处理，判断每个点在当前情况下能否经过。如果可以经过，说明该点到所有树的距离均大于等于 $mid$；否则说明该点到某棵树的距离小于 $mid$。将预处理的结果存入一个地图中。

预处理完毕后，将地图带入另一个 BFS，若在该地图中，可以从 $V$ 点跑到 $J$ 点，那么此方法可行；否则不可行。

## Code

```cpp
//不能开O2
#include<bits/stdc++.h>
using namespace std;

int dx[5]={0,0,1,0,-1};
int dy[5]={0,-1,0,1,0};//方向数组 
int n,m;
char a[505][505];
int stx,sty;
struct node{
    int x;
	int y;
	int step;
};
queue<node> q;
queue<node> Q;
int tree[505][505];
int mp[505][505];

int dfs(int x,int y){//dfs判断起点与终点是否连通 
	if(a[x][y]=='J')//成功回家 
		return 1;
	for(int i=1;i<=5;i++){
		int sx=x+dx[i];
		int sy=y+dy[i];
		if(sx>=1&&sx<=n&&sy>=1&&sy<=m&&!mp[sx][sy]){
			mp[sx][sy]=1;
			if(dfs(sx,sy)) 
				return 1;
		}
	}
	return 0;
}

int bfs(int mid){//bfs求不能走的点 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			mp[i][j]=tree[i][j];
	Q=q;
	while(!Q.empty()){
		node u=Q.front();
		Q.pop();
		if(u.step>=mid-1) 
			continue;
		for(int i=1;i<=4;i++){
			int sx=u.x+dx[i];
			int sy=u.y+dy[i];
			if(sx>=1&&sx<=n&&sy>=1&&sy<=m&&mp[sx][sy]==0){
				mp[sx][sy]=1;
				Q.push((node){
					sx,sy,u.step+1
				});
			}
		}
	}
	if(mp[stx][sty])//不能经过起始节点 
		return 0;
	return dfs(stx,sty);//判断起点与终点是否连通 
}

signed main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			if(a[i][j]=='+'){//当前的点是树 
				q.push((node){
					i,j,0
				});
				tree[i][j]=1;
			}
			if(a[i][j]=='V'){//当前的点是起点 
				stx=i;
				sty=j;
			} 
		}
    int l=1,r=n,mid;
    while(l<=r){//二分答案 
        mid=l+r>>1;
        if(bfs(mid))
            l=mid+1;
        else 
			r=mid-1;
    }
    cout<<r;//因为答案区间在左边，而r在二分后会在l的左边，所以输出r 
	return 0;
}
```


代码厌氧，不知道为啥，有大佬能解答一下吗

---

## 作者：happy_dengziyue (赞：1)

### 1 思路

这道题可以用广度优先搜索来解。

首先，我们通过广搜预处理出每一个点与树的最近的曼哈顿距离。

然后，通过优先队列搭配广搜，优先看那些目前最近距离比较大的，当走过一个点时，目前最近距离要和当前点与树的曼哈顿距离取最小值。

最后到了终点，就可以输出答案。

注意，在预处理曼哈顿距离时，可以一开始将所有树压入队列，而不是对于每棵树一遍遍广搜。

### 2 代码与记录

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define max_n 500
#define inf 0x3f3f3f3f
int n;
int m;
struct P{
	int x,y;
}s,t;
P tr[max_n*max_n+2];
int ti=0;
int g[max_n+2][max_n+2];
bool vis[max_n+2][max_n+2];
struct W{
	int x,y,t;
	bool operator<(const W&a)const{
		return a.t>t;
	}
}f;
const int dx[4]={-1,0,1,0};
const int dy[4]={0,1,0,-1};
void askmhd(){
	memset(g,inf,sizeof(g));
	queue<W>q;
	for(int i=1;i<=ti;++i){
		g[tr[i].x][tr[i].y]=0;
		q.push((W){tr[i].x,tr[i].y,0});
	}
	while(!q.empty()){
		f=q.front();
		q.pop();
		for(int d=0;d<4;++d){
			P now=(P){f.x+dx[d],f.y+dy[d]};
			if(now.x<1||now.x>n||now.y<1||now.y>m)continue;
			if(g[now.x][now.y]<=f.t+1)continue;
			g[now.x][now.y]=f.t+1;
			q.push((W){now.x,now.y,f.t+1});
		}
	}
}
inline int mi(int a,int b){
	return a<b?a:b;
}
inline int askans(){
	memset(vis,0,sizeof(vis));
	vis[s.x][s.y]=true;
	priority_queue<W>q;
	q.push((W){s.x,s.y,g[s.x][s.y]});
	while(!q.empty()){
		f=q.top();
		if(f.x==t.x&&f.y==t.y)return f.t;
		q.pop();
		for(int d=0;d<4;++d){
			P now=(P){f.x+dx[d],f.y+dy[d]};
			if(now.x<1||now.x>n||now.y<1||now.y>m)continue;
			if(vis[now.x][now.y])continue;
			vis[now.x][now.y]=true;
			q.push((W){now.x,now.y,mi(f.t,g[now.x][now.y])});
		}
	}
	return -1;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P7775_1.in","r",stdin);
	freopen("P7775_1.out","w",stdout);
	#endif
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		char a[max_n+2];
		scanf("%s",a+1);
		for(int j=1;j<=m;++j){
			if(a[j]=='+')tr[++ti]=(P){i,j};
			if(a[j]=='V')s=(P){i,j};
			if(a[j]=='J')t=(P){i,j};
		}
	}
	askmhd();
	printf("%d\n",askans());
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/58879647)

By **dengziyue**

---

## 作者：Y_Aridy (赞：0)

# [题目](https://www.luogu.com.cn/problem/P7775)

## Part 1：
**题目概述：**

我们有一张 $ n \times m $ 的图，图中有“.”，“+”，“V”，“J”，分别代表什么都没有的点，有树的点，起点，终点。

我们需要从起点出发，到达终点，使得路径中每个点与最近的一个树点的曼哈顿距离的最小值最大（路径中包含起点和终点）。

**求曼哈顿距离：**

题目给了我们这样的解释：`两个格子所在行、列之差的绝对值之和`。

我们从每一个树点出发，上下左右移动（每次移动都会使曼哈顿距离加 $ 1 $），一个点被修改过后，不需要被再次修改，保证求出的距离是与最近树点的曼哈顿距离。

这样，我们进行一遍 bfs 即可，初始队列中为所有树点，对应距离为 $ 0 $。

**最小值最大：**

对于这种性质，我们可以进行二分答案，每次跑一遍 bfs 判断当前答案是否成立即可。

## Part 2：
**完整代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e2+7;
int n,m;
char mp[maxn][maxn];
queue<pair<int,int> > t;
int sx,sy,ex,ey;
int dx[5]={0,1,0,-1,0};
int dy[5]={0,0,1,0,-1};
bool vis[maxn][maxn];
int dis[maxn][maxn];
bool check(int mid){
	//跑一遍bfs，如果终点可以到达，即当前答案成立 
	queue<pair<int,int> > q;
	q.push(make_pair(sx,sy));
	memset(vis,0,sizeof vis);
	vis[sx][sy]=1;
	while(!q.empty()){
		int x=q.front().first,y=q.front().second;
		q.pop();
		for(int i=1;i<=4;i++){
			int fx=x+dx[i],fy=y+dy[i];
			if(fx<1||fx>n||fy<1||fy>m||vis[fx][fy]||dis[fx][fy]<mid) continue;
			vis[fx][fy]=1;
			q.push(make_pair(fx,fy));
			if(vis[ex][ey]) return true;
		}
	}
	return false;
}
int main(){
	cin>>n>>m;
	memset(dis,0x3f,sizeof dis);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
			if(mp[i][j]=='V'){
				sx=i,sy=j;
			}
			if(mp[i][j]=='J'){
				ex=i,ey=j;
			}
			if(mp[i][j]=='+'){
				//将树点加入队列 
				t.push(make_pair(i,j));
				dis[i][j]=0;
			}
		}
	}
	//预处理曼哈顿距离 
	while(!t.empty()){
		int x=t.front().first,y=t.front().second;
		t.pop();
		for(int i=1;i<=4;i++){
			int fx=x+dx[i],fy=y+dy[i];
			if(fx>=1&&fx<=n&&fy>=1&&fy<=m&&dis[fx][fy]==0x3f3f3f3f){
				dis[fx][fy]=dis[x][y]+1;
				t.push(make_pair(fx,fy));
			}
		}
	}
	int l=0,r=dis[sx][sy],ans;
	while(l<=r){
		int mid=(l+r)/2;
		//如果成立，l=mid+1，检查是否有更优解 
		if(check(mid)) l=mid+1,ans=mid;
		//如果不成立，r=mid-1，看是否有答案 
		else r=mid-1;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Crasole (赞：0)

## 思路

先把每个表示树的点放入队列中，接着做一边 BFS，求出每个点到离它最近的那一棵树的曼哈顿距离。

然后二分离最近的树的距离的最小值，在判断的时候，用 $vis_{i, j}$ 表示点 $(i, j)$ 是否访问过，$1$ 表示访问过，$0$ 表示没有访问过。从起点开始跑一遍 DFS，把所有能到达的点都走一遍，最后只要看终点是否被访问过。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, sx, sy, fx, fy;
int dis_map[510][510];
int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};
bool vis[510][510];
struct node {int i, j;};
queue <node> Q;
void make_dis() {//预处理距离
	while(!Q.empty()) {
		node u = Q.front(); Q.pop();
		int tx = u.i, ty = u.j;
		for(int k = 0; k < 4; k++) {
			int x = tx + dx[k], y = ty + dy[k];
			if(x >= 1 && x <= n && y >= 1 && y <= m && dis_map[x][y] == -1)//把还没有被扩展的点加入队列
				dis_map[x][y] = dis_map[tx][ty] + 1, Q.push((node){x, y});
		}
	}
}
void dfs(int i, int j, int p) {//DFS，搜所有能到的点
	if(dis_map[i][j] < p) return;//如果距离树木距离小于目前限定的距离，不搜索
	if(vis[i][j]) return;
	vis[i][j] = 1;
	for(int k = 0; k < 4; k++) {
		int x = i + dx[k], y = j + dy[k];
		if(x >= 1 && x <= n && y >= 1 && y <= m)
			dfs(x, y, p);
	}
}
bool check(int x) {
	memset(vis, 0, sizeof(vis));
	dfs(sx, sy, x);
	return vis[fx][fy];
}
int main() {
	ios::sync_with_stdio(0);
	cin >> n >> m; char c;
	memset(dis_map, -1, sizeof(dis_map));
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			cin >> c;
			if(c == '+')
				dis_map[i][j] = 0, 
				Q.push((node){i, j});
			else if(c == 'V')//记录起点
				sx = i, sy = j;
			else if(c == 'J')//记录终点
				fx = i, fy = j;
		}
	make_dis();
	int l = 0, r = max(n, m), ans, mid;
	while(l <= r)//二分
		if(check(mid = l + r >> 1))
			ans = mid, l = mid + 1;
		else 
			r = mid - 1;
	cout << ans;
	return 0;
}
```

---

## 作者：WaltVBAlston (赞：0)

简单的广搜变形模板，但是这个可怜的蒟蒻竟然写了一个小时 /kk

几个要点，从简单到容易：

1. 曼哈顿距离指的不是直线距离，而是“网格最短距离”

2. 可以利用一轮 BFS，把树全部压到队列里面然后进行一个简单搜索，就可以得到每个点对于最近的树的曼哈顿距离。

3. 开一个优先队列，进行一轮跟 Dijkstra 很像的求最短路（对于这部分，可以选择阅读李煜东's《算法竞赛进阶指南》-广搜变形

然后，对于这道题，我们就算做完了

细节有点多，码量还能接受：

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
char c[505][505];
int dis[505][505];
struct node{
	int x;
	int y;
	int now;
};
queue <node> q;
struct dijkstra{
	int x;
	int y;
	int now;
	bool operator < (const dijkstra &temp)const{
		return temp.now>now;
	}
};
priority_queue <dijkstra> d;
bool vis[505][505];
int dirx[5]={0,1,-1,0,0},diry[5]={0,0,0,1,-1};
void bfs1(){
	while(!q.empty()){
		node temp=q.front();
		int tx=temp.x,ty=temp.y;
		q.pop();
		dis[tx][ty]=temp.now;
		for(int i=1;i<=4;i++){
			int dx=dirx[i],dy=diry[i];
			if(tx+dx>=1&&tx+dx<=n&&ty+dy>=1&&ty+dy<=m&&vis[tx+dx][ty+dy]==false){
				vis[tx+dx][ty+dy]=true;
				q.push((node){tx+dx,ty+dy,temp.now+1});
			}
		}
	}
	return;
}
int sx,sy;
void bfs2(){
	while(!d.empty()){
		dijkstra temp=d.top();
		int tx=temp.x,ty=temp.y;
		d.pop();
		if(tx==sx&&ty==sy){
			cout<<temp.now;
			return;
		}
		for(int i=1;i<=4;i++){
			int dx=dirx[i],dy=diry[i];
			if(tx+dx>=1&&tx+dx<=n&&ty+dy>=1&&ty+dy<=m&&vis[tx+dx][ty+dy]==false){
				vis[tx+dx][ty+dy]=true;
				d.push((dijkstra){tx+dx,ty+dy,min(temp.now,dis[tx+dx][ty+dy])});
			}
		}
	}
	return;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin>>c[i][j];
			if(c[i][j]=='+')
				vis[i][j]=true,q.push((node){i,j,0});
		}
	bfs1();
	memset(vis,false,sizeof(vis));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(c[i][j]=='V'){
				d.push((dijkstra){i,j,dis[i][j]});
				vis[i][j]=true;
			}
			else if(c[i][j]=='J')
				sx=i,sy=j;
	bfs2();
	return 0;
}
```


---


# 间谍网络

## 题目描述

由于外国间谍的大量渗入，国家安全正处于高度的危机之中。如果 A 间谍手中掌握着关于 B 间谍的犯罪证据，则称 A 可以揭发 B。有些间谍收受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。

我们的反间谍机关提供了一份资料，包括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有 $n$ 个间谍（$n$ 不超过 $3000$），每个间谍分别用 $1$ 到 $3000$ 的整数来标识。

请根据这份资料，判断我们是否有可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。

## 样例 #1

### 输入

```
3
2
1 10
2 100
2
1 3
2 3
```

### 输出

```
YES
110
```

## 样例 #2

### 输入

```
4
2
1 100
4 200
2
1 2
3 4```

### 输出

```
NO
3
```

# 题解

## 作者：Danny_boodman (赞：134)

### 可以看出此题有两种情况:


一是有的罪犯既不能贿赂他也没有罪犯能揭发他，那么此题无解，我们在遍历时打上标记，然后从小到大枚举，只要遇见没有标记的就输出然后退出即可


二是所有的罪犯都能直接或间接地被能贿赂的罪犯揭发。很明显，也有两种情况，一是没有环，那么资金就是贿赂那个没有入度的罪犯，二是有环，那么资金就是那个环里罪犯所需资金最小的。我们想，如果我们把环里的罪犯缩成一个点，那么全都是前者的情况了


至于如何缩点欢迎来看[我的博客](https://www.luogu.org/blog/sincereactor/)


```
#include<iostream>
#include<stdio.h>
#include<cstring>
using namespace std;
struct ss{
	int next,to;
};ss data[200010];
const int inf=1e9+7;
int n,q,timeclock,p,top,cnt,ans,r;
int dfn[200010],low[200010],stack[200010],instack[200010],next[200010],head[200010];
int belong[200010],money[200010],sum[200010],size[200010],rd[200010];
void add(int a,int b)
{
	data[++p].next=head[a];
	data[p].to=b;
	head[a]=p;
}
void tarjan(int a)           //标准的tarjan代码 
{
	dfn[a]=low[a]=++timeclock;
	instack[a]=1;
	stack[++top]=a;
	for(int i=head[a];i;i=data[i].next)
	{
		int v=data[i].to;
	    if(!dfn[v])
	    {
	 	    tarjan(v);
		    low[a]=min(low[a],low[v]);
	    }
	    else
	    if(instack[v])
	    low[a]=min(low[a],dfn[v]);
	}
	if(dfn[a]==low[a])
	{
		cnt++;
		while(stack[top+1]!=a)
		{
			belong[stack[top]]=cnt;
			instack[stack[top]]=0;
			size[cnt]++;
			sum[cnt]=min(sum[cnt],money[stack[top]]);
			top--;
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	money[i]=1e9+7;        //记得赋初值哦 
	for(int i=1;i<=n;i++)
	sum[i]=1e9;
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		int u,mo;
		scanf("%d%d",&u,&mo);
		money[u]=mo;
	}
	scanf("%d",&r);
	for(int i=1;i<=r;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
	}
	for(int i=1;i<=n;i++)
	if(!dfn[i]&&money[i]!=inf)  //如果他能够被贿赂就以他为起点找环 
	tarjan(i);
	for(int i=1;i<=n;i++)      //在这里我们用dfn数组来判断它是否被遍历过 
	if(!dfn[i])
	{
		printf("NO\n");
		printf("%d\n",i);
		return 0;
	}
	
	for(int i=1;i<=n;i++)
	for(int j=head[i];j;j=data[j].next)
	if(belong[i]!=belong[data[j].to])
	{
	    rd[belong[data[j].to]]++;   //记录入度 
	}
	printf("YES\n");
	for(int i=1;i<=cnt;i++)
	{
	   if(!rd[i])
	   { 
	       ans+=sum[i];
	   }
    }
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：lk_liang (赞：44)

### 今天模拟赛刚考了这道题，打算写篇题解加深一下理解


------------


## 1.  分析题意 :

 **给你一个有向图，其中某些点是可以买的，如果你买了一个点，你可以到达这
个点指向的点,指向的这个点又能到它指向的点......(直到走不通)，我们要选择一些点买，使图联通且代价最小！**
 
## 2.  做题思路：

首先思考，我们要选择一些点，怎么选才能代价最小呢？

对于一个点x，如果x的入度不为0，说明有点（设这个点为y）指向x。 那贪心的想

我们买x不如买y, 但y如果也有入度，我们就买指向y的点..........


**然后得出结论：买所有入度为0的点**

但是 我们又想到 如果有一个环存在 这个环的所有点入度都不为0 那我们怎么办？

很好想到

你不是有环吗，你不是很拽吗，老子会tarjan 你还不是得叫爸爸？（暴躁）

直接来个tarjan缩点 这个环的花费就是其中某个花费最小点的花费

因为这个环的其中一个点买了，这个环就都是你的了

------------

## 3. 细节分析:

好了我们缩完点了

所以现在我们知道,所有入度为0的点是必须买的！这点毋庸置疑

但是不是入读不为0的点就都不用买？？

答案当然是否

如果x指向y

但是x是我们不能买的 或者 x不能被其他点到达 那么y就是一定得买的

## 4.无解情况
很简单，就是必须买的点，却不能买！


我废话有点多，，dalao勿喷

AC代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<stack>
#include<algorithm>
#define INF (int)0x3f3f3f3f 
#define maxn 10010 
using namespace std;
int n,p,num,cnt;   // num是tarjan的时间戳   cnt在缩点时维护强连通分量的个数 
int w[maxn],dfn[maxn],low[maxn];
int mi[maxn],k[maxn],minid[maxn];    //   缩点后 pw每个强连通分量的最小花费  k[i]表示i点属于哪个强连通分量 
bool vis[maxn],flag[maxn][maxn],ru[maxn];    //  vis数组表示i是否在数组里  flag表示i j两个强连通分量有没有连边 
vector<int> v[maxn];
stack<int> s;
void tarjan(int x)    //  标准的tarjan 
{
	low[x]=dfn[x]=++num;
	s.push(x);
	vis[x]=true;
	for(int i=0;i<v[x].size();i++)
	{
		int ed=v[x][i];
		if(!dfn[ed])
		{
			tarjan(ed);
			low[x]=min(low[x],low[ed]);
		}
		else if(vis[ed]) low[x]=min(low[x],dfn[ed]);
	}
	if(dfn[x]==low[x])    //  x是一个关键点
	{
		int minw=INF,lk=INF,t;
		cnt++;
		while(1)
		{
			t=s.top();
			s.pop();
			vis[t]=false;
			minw=min(minw,w[t]);     //   取这个强连通分量的最小花费 
			lk=min(lk,t);
			k[t]=cnt;
			if(t==x) break;
		}
		minid[cnt]=lk;
		mi[cnt]=minw;
	}
}
int main()
{
	scanf("%d%d",&n,&p);           //  n个间谍  有p个间谍愿意被收买 
	for(int i=1;i<=n;i++) w[i]=INF; // 先初始化 如果i号间谍开价为INF说明他不能被收买  
	int a,b;
	for(int i=1;i<=p;i++)
	{
		scanf("%d%d",&a,&b);       //  a号间谍愿意被收买
		w[a]=b;     		   //   w数组代表每个间谍愿意被收买的金额 
	}
	int r;
	scanf("%d",&r);
	for(int i=1;i<=r;i++)
	{
		scanf("%d%d",&a,&b);
		v[a].push_back(b);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);    	 	//   tarjan缩点
	for(int i=1;i<=n;i++)  // 注意！！事实上我没有缩点建新图的操作！因为不需要
	{
		for(int j=0;j<v[i].size();j++)
		{
			int ed=v[i][j];
			if(k[i]==k[ed]||flag[k[i]][k[ed]]) continue; // 同一个强连通分量的点直接跳过 或者两个强连通分量已经判断过了
			flag[k[i]][k[ed]]=true;
			if(ru[k[i]]||mi[k[i]]!=INF) ru[k[ed]]=true;    //   重点！如果i点所在强连通分量不能被贿赂 或！不能被其他点到达 他们所指向的点不记录有入度 
		}
	}
	int id=INF,all=0;    //   如果不符合题意 找到的最小编号id 
	bool f=false;
	for(int i=1;i<=cnt;i++)
	{
		if(ru[i]) continue;   //  有入度的点跳过
		if(mi[i]==INF)    //  这个强联通分量不能买 说明整张图就无解了
		{
			f=true;
			id=min(id,minid[i]);   // 找到最小编号
		}
		if(!f) all+=mi[i];
	}
	if(f) printf("NO\n%d",id);
	else printf("YES\n%d",all);
	return 0;
}
```




---

## 作者：梅花鹿嘉宾 (赞：13)

看到别人的程序都是100多行的我这个63行的就赶紧过来凑个热闹。

本题的主要方法就是利用Tarjan进行缩点，把有环图缩成DAG即可。具体内容下面的程序有注解，且其他人讲得也很详细了。

至于Tarjan和缩点还没有学过的人，可以看一下：

[Tarjan](http://www.cnblogs.com/shadowland/p/5872257.html) 这个人讲得很清楚明白，模板也简单明了。

[缩点](http://blog.csdn.net/zjy2015302395/article/details/52303864) 缩点在函数tarjan的最后，可以看一看（学的时候找了很久）。

要注意的一点是，**同一个缩点中的两个点在计算入度时不需要再加**，我就栽在这儿了，调试老半天才发现。

以下是程序：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int INF=1e9,N=3001,M=8997001;
int n,m,t,tot,rd[N],fir[N],mon[N],dfn[N],low[N],sta[N],bel[N],smon[N],nod[M],nex[M];
//rd:入度 fir,nod,nex:邻接表相关 mon:单个间谍金钱 dfn,low:Tarjan相关 sta:Tarjan栈 bel:点所属缩点 smon:缩点最小金钱
bool vis[N];
void add(int i,int x,int y){
    nod[i]=y,nex[i]=fir[x],fir[x]=i;
}//以上邻接表部分
void dfs(int x){
    if(vis[x]) return;
    vis[x]=1,tot++;
    for(int i=fir[x];i;i=nex[i]) dfs(nod[i]);
}//以上遍历有向图部分
void tar(int x){
    dfn[x]=low[x]=++tot,vis[x]=1,sta[++t]=x;
    for(int i=fir[x];i;i=nex[i]){
        int y=nod[i];
        if(!dfn[y]) tar(y),low[x]=min(low[x],low[y]);
        else if(vis[y]) low[x]=min(low[x],dfn[y]);
    }
    if(dfn[x]==low[x]){
        smon[x]=INF;
        do{
            vis[sta[t]]=0;
            bel[sta[t]]=x;
            smon[x]=min(smon[x],mon[sta[t]]);
                        //由于环中只要收买一个人 其他人的情报都可以知道，因此只要取最小值即可
            t--; 
        } while(sta[t+1]!=x);
    }
}//以上tarjan缩点部分
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) mon[i]=INF;
        //我采用的是将不能收买的间谍金钱设为无限大
    for(int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        mon[x]=y;
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        add(i,x,y);
    }//以上读入
    for(int i=1;i<=n;i++) if(mon[i]!=INF) dfs(i);
    if(tot<n) for(int i=1;i<=n;i++) if(!vis[i]){
        printf("NO\n%d",i);
        return 0;
    }//如果不能收买的间谍不被收买的间谍掌握情报，则无法得知他的情报，不可行
    tot=0;
    for(int i=1;i<=n;i++) vis[i]=0;
    //vis数组功能从判断是否遍历到点变为是否在栈中（只是并不想再开个数组）
    for(int i=1;i<=n;i++) if(mon[i]!=INF&&!dfn[i]) tar(i);
    //如果可以收买而且没访问过就进行缩点
    for(int i=1;i<=n;i++)
        for(int j=fir[i];j;j=nex[j])
        if(bel[i]!=bel[nod[j]]) /*一定不要忘了判断*/ rd[bel[nod[j]]]++;
    int ans=0;
    for(int i=1;i<=n;i++) if(bel[i]==i&&!rd[i]) ans+=smon[i];
        //如果间谍不被任何人掌握情报则只能收买
    printf("YES\n%d",ans);
    return 0;
}
```

---

## 作者：Long·J·William (赞：12)

Tarjan是什么鬼？？？喵喵喵

f[]储存该节点的源可收买节点；

nd[]储存某可收买节点的影响；

思路
先对所有的可收买的点按收买价格排序；

然后每个点如果需要加入，更新他之前点的影响，并记录该点的影响；

如果有一个点没有影响源，该点不受控制；

对于所有可以收买的点，如果影响为0，不收买；


代码实现

```cpp
 1     #include<cstdio>
 2     #include<cstring>
 3     #include<algorithm>
 4     using namespace std;
 5     const int maxn=3010;
 6     const int maxr=8010;
 7     int n,p,r,ans;
 8     int a,b;
 9     int h[maxn],hs;
10     int e_s[maxr],e_n[maxr];
11     int f[maxn],nd[maxn];
12     struct nate{int s,v;}d[maxn];
13     bool cmp(const nate&x,const nate&y){return x.v<y.v;}
14     void dfs(int k,int s){
15         if(f[k]) nd[f[k]]--;
16         f[k]=s,nd[s]++;
17         for(int i=h[k];i;i=e_n[i])
18         if(f[e_s[i]]!=s) dfs(e_s[i],s);
19     }
20     int main(){
21         freopen("spyweb.in","r",stdin);
22         freopen("spyweb.out","w",stdout);
23         scanf("%d%d",&n,&p);
24         for(int i=1;i<=p;i++){
25             scanf("%d%d",&a,&b);
26             d[i].s=a,d[i].v=b;
27         }
28         sort(d+1,d+p+1,cmp);
29         scanf("%d",&r);
30         for(int i=1;i<=r;i++){
31             scanf("%d%d",&a,&b);
32             ++hs,e_s[hs]=b,e_n[hs]=h[a],h[a]=hs;
33         }
34         for(int i=1;i<=p;i++){
35             if(f[d[i].s]) for(int j=h[d[i].s];j;j=e_n[j]){
36                 if(!f[e_s[j]]){
37                     dfs(d[i].s,i);
38                     break;
39                 }
40             }
41             else dfs(d[i].s,i);
42         }
43         for(int i=1;i<=n;i++)
44         if(!f[i]){
45             printf("NO\n%d\n",i);
46             return 0;
47         }
48         for(int i=1;i<=p;i++) if(nd[i]) ans+=d[i].v;
49         printf("YES\n%d\n",ans);
50         return 0;
51     }
```
不要在意我诡异的名词和名词解释；
blog：http://www.cnblogs.com/J-william/p/6820876.html#\_label5


---

## 作者：TBB_Nozomi (赞：7)

这个题下面的题解有不少是缩点算法……相当神奇的看不懂QAQ

### 怎么想

这个题目的主要思路：

1. 首先要能够表示这个图——在下面使用vector的数组know表示单向认识关系

2. 另外，在下面使用结构体can\_be\_bought表示能够被收买的人的序号和收买的钱，数组mon表示收买所需要的钱，数组root表示通过收买root[k]就能间接逮捕k

3. 先对能被收买的人所需要的钱进行从小到大的排序(在下面使用sort配合camp)，对这些人，从小到大的开始枚举

4. 对于每一个新枚举的人i，如果root[i]==0，表明先前他并没有被收买，从价格上来分析他必须被收买，那么所有他间接能逮捕的人都可以通过他被收买而被逮捕，所以这些人的root[]被更新为i（为什么？见A）

如果root[i]!=0，那么 因为i被收买而被逮捕的人 也一样能够 因为root[i]被收买而被逮捕，而前面排过序，root[i]被收买显然钱要比收买i好

5. 枚举完所有的能够被收买的人之后，如果这n个人里面有人root为0，说明他始终不能被逮捕，输出序号退出程序

6. 将所有人的root标记在buy数组上，那么最后buy上所有被标记的人形成的方案就是所花出去的钱的最小方案，求和输出

### A.为什么要更新这些人的root？

先前有的人w因为价格更低的人b收买而被逮捕，那么分为以下两种情况：

1. 收买i而逮捕w的路线不经过b：逮捕i一定要钱，不会因为收买不收买b而发生改变，b也要付钱i也要付钱，收买改不改这个人的root无所谓

2. 收买i而逮捕w的路线经过b：i使得b被逮捕使得w被逮捕，这样使w逮捕就不再需要为b付钱

综上，更改了之后能够保证使w被逮捕的方案所用的钱数最少，维护了最优性


以下为代码

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
int n,p;

struct can_be_bought {
    int num,money;
    can_be_bought(int nu,int mo)    {//构造函数
                num=nu;
        money=mo;
        }
};

typedef can_be_bought cbg;
typedef vector<int>::iterator int_iter;
typedef vector<cbg>::iterator cbg_iter;

vector<int> know[3001];//记录所有的间谍之间的单向线段
queue<int>    qu;//用于更新节点
vector<cbg>    can;//记录所有能被收买的人的编号和价钱

bool camp(cbg a1,cbg a2)        {
        return a1.money<a2.money;
}//从小到大排序

int mon[3001]= {0};//收买这个人所需要的钱，方便最后相加
int root[3001]= {0};//逮捕这个人所需要的收买的人的编号
bool buy[3001]= {0};//最终收买方案

void bfs(int ro)    {
        while(!qu.empty())    {
                int k=qu.front();
                qu.pop();
                if(root[k]!=ro)        {//如果逮捕这个人收买的不是自己，防止环的出现
                        root[k]=ro;//更新root
                        for(int_iter iter=know[k].begin(); iter!=know[k].end(); iter++)        {
                                if(root[*iter]==ro)        continue;//同上
                                qu.push(*iter);
                        }
                }
        }
}
int main()    {
        scanf("%d%d",&n,&p);
        int i;
        for(i=0; i<p; i++)    {
                int mo,nu;
                scanf("%d%d",&nu,&mo);
                mon[nu]=mo;
                cbg a(nu,mo);
                can.push_back(a);
        }
        sort(can.begin(),can.end(),camp);//价钱排序
        int r;
        scanf("%d",&r);
        for(i=0; i<r; i++)    {
                int x,y;
                scanf("%d%d",&x,&y);
                know[x].push_back(y);//有向边输入
        }
        cbg_iter iter;
        for(iter=can.begin(); iter!=can.end(); iter++)    {
                if(root[iter->num]!=0)    continue;//如果他能够通过别人的收买而被逮捕就不用收买他
                qu.push(iter->num);
                bfs(iter->num);
        }
        for(i=1; i<=n; i++)    {
                if(root[i]==0)    {//有人不能通过任何人的收买而被逮捕
                        printf("NO\n%d",i);
                        return 0;
                }
                buy[root[i]]=true;
        }
        int S=0;
        for(i=1; i<=n; i++)    {
                if(buy[i])    {
                        S+=mon[i];
                }
        }
        printf("YES\n%d",S);
        return 0;
}
```

---

## 作者：jins3599 (赞：6)

$Tarjan$裸题。

其实我的思路比较直白，但是码量稍大(其实也就20min左右..)

首先的一个显然的结论就是，若我们可以控制所有的间谍，当且仅当缩点后所有入度为$0$的点上有可以贿赂的间谍。

为什么？因为缩完点后，这是一个$dag$，所有入度为零的点若没有人的话一定不会被走到。

所以我们如果可以走到的话，最终的答案就是所有入度为$0$的点的权值加起来。

（如果一个点上有多个可贿赂的间谍，记得取最小值。）

然后我们再看不能控制所有间谍的情况。

显然的一个思路，我们可以就缩点后的图重建一次，然后对每个有间谍的点进行染色，最后剩下的所有点中取最小值即可。

这个过程可能有点考验码力，不过如果$tarjan$写多点的话其实会发现还是蛮好写的。

$Code:$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 8000 + 10;
int n , p , r;
int esp[N] , val[N] ,cnt;
int head[N];

struct Edge {
	int to , nxt;
}e[N];

void add(int u  , int v ) {
	e[++ cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

struct Edge_new{
	int to , nxt;
}e_new[N];

int head_new[N]; 
void add_new(int u ,int v) {
	e_new[++ cnt].to = v;
	e_new[cnt].nxt = head_new[u];
	head_new[u] = cnt;
}

int tot , idx , dfn[N] , low[N] , ins[N] , top , st[N] , wic[N];
int worth[N];
bool flag[N];

vector <int> S[N];

void Tarjan(int now) {
	dfn[now] = low[now] = ++ idx;
	ins[now] = 1; st[++ top] = now;
	for(int i = head[now] ; i ; i = e[i].nxt) {
		int v = e[i].to;
		if(!dfn[v]) {
			Tarjan(v);
			low[now] = min(low[now] , low[v]);
		} else if(ins[v]) low[now] = min(low[now] , dfn[v]);
	}
	if(low[now] == dfn[now]) {
		tot ++;
		int p;
		do {
			p = st[top --];
			if(esp[p]) flag[tot] = true , worth[tot] = min(worth[tot] , val[p]);
			S[tot].push_back(p);
			wic[p] = tot;
			ins[p] = 0;
		}while(p != now);
	}
}

int ind[N];

int vis[N];
void dfs(int now) {
	vis[now] = 1;
	for(int i = head_new[now] ; i ; i = e_new[i].nxt) {
		int v = e_new[i].to;
		if(vis[v]) continue;
		dfs(v);
	}
}

int Work() {
	for(int i = 1 ; i <= tot ; ++ i) 
		if(flag[i] && !vis[i]) dfs(i);
	int r = 0x3f3f3f3f;	
	for(int i = 1 ; i <= tot ; ++ i) 
		if(!vis[i]) {
			for(int j = 0 ; j < S[i].size() ; j ++) {
				r = min(r , S[i][j]);
			}
		}
	return r;
}

int main () {
	scanf("%d %d" , &n , &p);
	for(int i = 1 ; i <= n ; ++ i) worth[i] = 0x3f3f3f3f;
	for(int i = 1 ; i <= p ; ++ i) {
		int aa , bb;
		scanf("%d %d" , &aa , &bb);
		esp[aa] = 1; val[aa] = bb;	
	}
	scanf("%d" , &r);
	for(int i = 1 ; i <= r ; ++ i) {
		int u , v; scanf("%d %d" , &u ,&v);
		add(u , v);
	}
	for(int i = 1 ; i <= n ; ++ i) if(!dfn[i]) Tarjan(i);
	cnt = 0;
	for(int i = 1 ; i <= n ; ++ i ) {
		for(int j = head[i] ; j ; j = e[j].nxt) {
			int v = e[j].to;
			if(wic[i] == wic[v]) continue;
			ind[wic[v]] ++;
		}
	}
	int ans = 0 , f = 0; 
	for(int i = 1 ; i <= tot ; ++ i) {
		if(!ind[i] && flag[i]) {
			ans += worth[i];
		} else if(!ind[i]) f = 1;
	}
	if( ! f) {
		printf("YES\n%d\n" , ans);return 0;
	} else {
		for(int i = 1 ; i <= tot ; ++ i) {
			for(int j = 0 ; j < S[i].size() ; j ++) {
				int p = S[i][j];
				for(int k = head[p] ; k ; k = e[k].nxt) {
					int v = e[k].to;
					if(wic[v] == wic[p]) continue;
					add_new(wic[p] , wic[v]);
				}
			}
		}
		printf("NO\n%d\n",Work());	
	}
	return 0;
}
```

---

## 作者：PBCWZCC (赞：6)

这题由于存在环需要缩点，当然缩点不是这题的核心。

由题意可知，假如间谍$1$掌控着间谍$2$的情报，间谍$2$又掌控着$3$和$4$的情报，那么，如果我们能够对$1$行贿，$1$就会提供$2$的信息，$2$被揭发后，又会透露$3$、$4$的情报，以此类推。

上述情况转化为图，那就是
```
1 -> 2
2 -> 3
2 -> 4
...


```
也就是说，**一个点能够到达的点，都是它能够控制的点。**

而且，在上述情况中，如果$1$和$2$都能够被贿赂，那么，我们该先对谁动手好呢？

当然是$1$了！因为有$1$就能够控制$2$，我们还需要找$2$干嘛！因此，**如果$a,b$都可以被贿赂，而从$a$点出发能够到达$b$，我们一定会优先贿赂$a$。**

可知在
```
1 -> 2
2 -> 3
3 -> 1
```
这种情况下，$1$、$2$、$3$构成了一个强连通分量，任意贿赂一个就可以得到全部三个人的情报（或者说**这个强连通分量就是可贿赂的**）。

因此，本题需要用到缩点的算法。想必大家都喜欢用$\mathrm{Tarjan}$来缩点，但这里呢，本蒟蒻要介绍一种冷门的缩点算法——$\bold{Kosaraju} $。

此算法是这样实现的：

$\ $

对图跑一遍$\mathrm{DFS}$，按照**退出搜索的顺序**将每个点**入栈**；建立一张反图（所有边的指向从$x ->y$变成$y->x$），再依次从栈顶取点，作为起点**在反图上**跑$\mathrm{DFS}$，这个起点能跑到的点都在同一个强连通分量内！

$\ $

~~（学这个用的时间不知道比$\mathrm{Tarjan}$短多少）~~

至于这算法的原理嘛。。。~~[点此左转板子题了解更多](https://www.luogu.org/problem/P3387)~~

完成缩点之后，我们从$\mathrm{DAG}$上可以看出，有入度的点一定会被某个没有入度的点控制。

受此思想影响，当时我便想到了这样一种想法——从入度为$0$的点入手。枚举**可贿赂的强连通分量**（新$\mathrm{DAG}$中的点）有哪些出度为$0$，并从这些点开始$\mathrm{DFS}$对能到达的点进行覆盖控制 （*注意不要与缩点前的图混淆*，*本蒟蒻因为两图分不清被*$\#2$ $\#3$*向外向里两个菊花图轮番吊打*$\mathfrak{QwQ}$）

看上去没问题？

来分析一下下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7e5fty6l.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

图中有$1,4,8$三个点（间谍）可以贿赂，但由于我们只找入度为$0$的点，所以$4,8$都被忽略了，最后输出答案会是：

```
NO
4
```
而不是正解：
```
NO
6
```


看来这种方法行不通了。

但是！

**在$\mathrm{DAG}$中，以入度为$0$的点进行$\mathrm{BFS}$时，是不是拓扑序在前的点会先被访问到？**

那么！正确的做法，就是先处理出可行贿点的拓扑序，然后，按照这个顺序，挨个作为起点在$\mathrm{DAG}$上进行搜索覆盖——这样，既能保证尽可能少地贿赂间谍，又不会遗漏任何行贿的机会！

另外，不得不说，这题的数据真的是十分巧妙，先用菊花图检查你的缩点是否有问题，再进行巧妙设计$\mathrm{Hack}$掉那些“理论上正确”的做法。**给出题人点个赞！**

$\mathrm{Now,time\ for\ the\ code!}$

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#define LL long long
using namespace std;
template<class T>inline void read(T&X)
{
　　X = 0;
　　char symbol('\0'),ch(getchar());
　　for(;ch<'0'||'9'<ch;(!(ch^'-'))?(symbol='\1'):(1),ch=getchar());
　　for(;'0'<=ch&&ch<='9';X=(X<<3)+(X<<1)+(ch^48),ch=getchar());
　　(symbol)?(X=-X):(1);
}
const int MAXN = 100003, MAXM = 400003, MAXC = 100003; // 开得略大了点。。。 
int n, p, m; 

char isa[MAXN]; // 点是否受贿 
int X[MAXN]; // 点要的钱 
int aai[MAXN]; // 可行名单（点） 

struct graph{
　　int heads[MAXN]; 
　　int cnt; 
　　int next[MAXN], to[MAXN]; 
　　void addE(const int x, const int y)
　　{
　　　　++cnt; 
　　　　next[cnt] = heads[x]; 
　　　　to[cnt] = y; 
　　　　heads[x] = cnt; 
　　}
};
graph E, E1; 
int bel[MAXM]; // 点属于强连通分量(SCC) 
char vis[MAXN]; // 比 bool 快 
int sta[MAXN], tot; // 栈，必要时也可用作队列 
int scn; // SCC 个数 
char isA[MAXC]; // 一个 SCC 是否有受贿的点 
int scA[MAXC]; // 贿赂一个 SCC 中最便宜的间谍就能掌握整个 SCC 

// Kosaraju 过程 
void dfs1(const int x) 
{
　　vis[x] = 1; 
　　int y, e; 
　　for(e = E.heads[x]; e; e = E.next[e])
　　{
　　　　y = E.to[e]; 
　　　　if(!vis[y])
　　　　{
　　　　　　dfs1(y); 
　　　　}
　　}
　　sta[++tot] = x; 
}

void reverse(void)
{
　　int e, x, y; 
　　for(x = 1; x <= n; ++x)
　　{
　　　　for(e = E.heads[x]; e; e = E.next[e])
　　　　{
　　　　　　y = E.to[e]; 
　　　　　　E1.addE(y, x); 
　　　　}
　　}
}

void dfs2(const int x)
{
　　bel[x] = scn; 
　　if(isa[x])
　　{
　　　　isA[scn] = 1; 
　　　　scA[scn] = min(scA[scn], X[x]); 
　　}
　　int y, e; 
　　for(e = E1.heads[x]; e; e = E1.next[e])
　　{
　　　　y = E1.to[e]; 
　　　　if(!bel[y])
　　　　{
　　　　　　dfs2(y); 
　　　　}
　　}
}

void Kosaraju(void)
{
　　int x, y, i; 
　　memset(vis, 0x00, sizeof vis); 
　　for(x = 1; x <= n; ++x)
　　{
　　　　if(!vis[x]) dfs1(x); 
　　}
　　reverse(); 
　　memset(bel, 0x00, sizeof bel); 
　　scn = 0; 
　　for(i = tot; i; --i)
　　{
　　　　x = sta[i]; 
　　　　if(!bel[x])
　　　　{
　　　　　　++scn; 
　　　　　　dfs2(x); 
　　　　}
　　}
}
// 

graph E2; 
int ind[MAXC], oud[MAXC]; 
void reconstruct(void) // 建造 DAG 
{
　　int e, x, y; 
　　for(x = 1; x <= n; ++x)
　　{
　　　　for(e = E.heads[x]; e; e = E.next[e])
　　　　{
　　　　　　y = E.to[e]; 
　　　　　　if(bel[x] != bel[y])
　　　　　　{
　　　　　　　　E2.addE(bel[x], bel[y]); 
　　　　　　　　++ind[bel[y]]; ++oud[bel[x]]; 
　　　　　　}
　　　　}
　　}
}

int fee; // 总费用 
int cov; // 完成行贿后可以控制的点数 

void cover(const int x) // 以某个点为起点进行控制 
{
　　++cov; 
　　vis[x] = 1; 
　　int e, y; 
　　for(e = E2.heads[x]; e; e = E2.next[e])
　　{
　　　　y = E2.to[e]; 
　　　　if(vis[y]) continue; 
　　　　cover(y); 
　　}
}

int tplist[MAXC]; // 按照拓扑序排列的名单（可行贿的 SCC ） 
int tpn; 
int imd[MAXC]; // 另存入度 
void topo(void) // 处理拓扑序 
{
　　memcpy(imd, ind, sizeof ind); 
　　int e, x, y; 
　　int head = 0, tail = 0; 
　　for(e = 1; e <= scn; ++e)
　　{
　　　　if(!imd[e])
　　　　{
　　　　　　sta[tail++] = e; 
　　　　}
　　}
　　for(; head < tail; )
　　{
　　　　x = sta[head++]; 
　　　　if(isA[x])
　　　　{
　　　　　　tplist[++tpn] = x; 
　　　　}
　　　　for(e = E2.heads[x]; e; e = E2.next[e])
　　　　{
　　　　　　y = E2.to[e]; 
　　　　　　--imd[y]; 
　　　　　　if(!imd[y])
　　　　　　{
　　　　　　　　sta[tail++] = y; 
　　　　　　}
　　　　}
　　}
}

int search(void) // 展开 cover 
{
　　topo(); 

　　memset(vis, 0x00, sizeof vis); 
　　int i, x; 　　
　　
//　　for(i = 1; i <= p; ++i)
//　　{
//
//　　　　x = bel[aai[i]]; 
//　　　　if(!ind[x] && !vis[x])
//　　　　{
//　　　　　　fee += scA[x]; 
//　　　　　　cover(x); 
//　　　　}
//　　}
　　
　　// 坑点：可能有 ind 不是 0 的切入点不会被前面的切入点搞到 
　　// 血。。。 
　　
　　for(i = 1; i <= tpn; ++i)
　　{
　　　　x = tplist[i]; 
　　　　if(!vis[x])
　　　　{
　　　　　　fee += scA[x]; 
　　　　　　cover(x); 
　　　　}
　　}
　　if(cov == scn) // 注意不是 n　// 血。。。 
　　{
　　　　return fee; 
　　}
　　else
　　{
　　　　for(i = 1; i <= n; ++i)
　　　　{
　　　　　　if(!vis[bel[i]]) return -i; 
　　　　}
　　}
}

int main()
{
　　memset(scA, 0x7f, sizeof scA); 
　　int i, x, y; 
　　read(n); read(p); 
　　for(i = 1; i <= p; ++i)
　　{
　　　　read(aai[i]); 
//　　　　read(X[i]); // 血。。。 
　　　　read(X[aai[i]]); 
　　　　isa[aai[i]] = 1; 
　　}
　　read(m); 
　　for(i = 1; i <= m; ++i)
　　{
　　　　read(x); read(y); 
　　　　E.addE(x, y); 
　　}
　　Kosaraju(); 
　　reconstruct(); 
　　x = search(); 
　　if(x < 0)
　　{
　　　　printf("NO\n%d\n", -x); 
　　}
　　else
　　{
　　　　printf("YES\n%d\n", x); 
　　}
　　return 0; 
}

*/ 


```
喜欢的话别忘了给本蒟蒻留下一个赞啊~ $\mathfrak{OuO}$


---

## 作者：lemir3 (赞：6)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11097721.html)

[*题面*](https://www.luogu.org/problemnew/show/P1262)

这道题太神了吧,从昨晚七点半做到今天下午两点.

我经历了以下折腾(以下内容可跳过):

+ 一开始想的是用Tarjan缩点,然后跑最短路,通过路径染色,让一条路径上的点的权值等于起点(也就是可以被收买的美国间谍的编号),然后枚举每一个点,用它对应的路径,累加权值得到答案,如果有点的权值为正无穷,那么就说明有间谍无法收买,再扫一遍染色数组找出编号最小的点输出NO.

这种方式貌似可以,但是在跑最短路的时候,松弛操作会把权值更小的路径更新进来,但是这条最短路可能是无法确保跑向权值更大的点的前缀点的,所以说会导致权值反而更大.这种方法最高得了52分.

比如下面这张图:

![P1262_美帝的间谍网络被我部捕获!配图1.png](https://i.loli.net/2019/06/27/5d1475c97647d90711.png)

1,2,3,4号点明显是个强联通分量,收买这个分量的代价为10.

5号点也是一个强连通分量,收买它的代价为20.

该图只有从5号点开始,才可以遍历完所有的点,总代价为20.

但是在跑最短路时,进入缩过点后的1,2,3,4节点后,会把这个点的权值松弛为10,但是这个10是无法跑完整个图的,这也导致总代价变为了30;

+ 然后我甚至想缩点之后跑一边最小生成树,但是算了下这样做会超时.

+ 之后我又想好了好久,和[*zxs*](https://www.cnblogs.com/zsx6/)大佬在中午恰饭的时候交流了下这道题,才想出来可以记录下所有入度为0的点,然后累加这些点的权值.这是因为入度为0的点是一定要被收买的,不然就无法遍历完全图,如果有间谍点无法被收买而且无法被其他间谍告发,就输出NO.

还有一些细节在代码里解释罢,各位在阅读我的变量名时只用看下划线后的部分.

**代码**:

```cpp

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<stack>
#include<queue>

using namespace std;

stack<int>s;

struct edge
{
    int to,next;
}e[10010];

int OddToThePeoplesVolunteerArmy_n,GreatSoviet_p,TheSovietUnion_CntSize,PeoplesRupublic_TimeCnt,YpaForOurGreatMotherland_r,TheDefenderOfMoscow_size,TheInternationalMustCometrue_ans;
int head[10010],dfn[10010],low[10010],indu[10010],dis[10010],color[10010],Nodedis[10010];
bool flag[10010];

void EdgeAdd(int,int);
void Tarjan(int);

int main()
{
    memset(head,-1,sizeof(head));
    memset(Nodedis,0x3f,sizeof(Nodedis));
    memset(dis,0x3f,sizeof(dis));
    scanf("%d%d",&OddToThePeoplesVolunteerArmy_n,&GreatSoviet_p);
    for(int _=1;_<=GreatSoviet_p;_++)
    {
        int id,USAIsRubbish;
        scanf("%d%d",&id,&USAIsRubbish);
        dis[id]=USAIsRubbish;
    }
    scanf("%d",&YpaForOurGreatMotherland_r);
    for(int _=1;_<=YpaForOurGreatMotherland_r;_++)
    {
        int father,son;
        scanf("%d%d",&father,&son);
        EdgeAdd(father,son);
    }
    for(int _=1;_<=OddToThePeoplesVolunteerArmy_n;_++)
    {
        if(dfn[_]==0&&dis[_]!=0x3f3f3f3f)//把可以收买的美国间谍进入Tarjan缩点,这样缩出来的点才能够被遍历.
        {
            Tarjan(_);
        }
    }
    for(int _=1;_<=OddToThePeoplesVolunteerArmy_n;_++)//缩完点后如果存在无法被收买,又无法被其它间谍指控的点,就说明无法收买所有间谍.
    {
        if(dfn[_]==0)
        {
            printf("NO\n%d\n",_);
            return 0;
        }
    }
    for(int _=1;_<=OddToThePeoplesVolunteerArmy_n;_++)
    {
        for(int __=head[_];__!=-1;__=e[__].next)
        {
            int to=e[__].to;
            if(color[_]!=color[to])
            {
                indu[color[to]]++;//统计入度.
            }
        }
    }
    for(int _=1;_<=TheSovietUnion_CntSize;_++)
    {
        if(indu[_]==0)//累加必须收买的间谍的代价.
        {
            TheInternationalMustCometrue_ans+=Nodedis[_];
//            printf("Nodedis:%d\n",Nodedis[_]);
        }
    }
    printf("YES\n%d\n",TheInternationalMustCometrue_ans);
return 0;
}

void EdgeAdd(int from,int to)
{
    e[++TheDefenderOfMoscow_size].to=to;
    e[TheDefenderOfMoscow_size].next=head[from];
    head[from]=TheDefenderOfMoscow_size;
}

void Tarjan(int FuckTrump_from)
{
    dfn[FuckTrump_from]=low[FuckTrump_from]=++PeoplesRupublic_TimeCnt;
    s.push(FuckTrump_from);
    flag[FuckTrump_from]=true;
    for(int _=head[FuckTrump_from];_!=-1;_=e[_].next)
    {
        int to=e[_].to;
        if(dfn[to]==0)
        {
            Tarjan(to);
            low[FuckTrump_from]=min(low[FuckTrump_from],low[to]);
        }
        else if(flag[to]==true)
        {
            low[FuckTrump_from]=min(low[FuckTrump_from],dfn[to]);
        }
    }
    if(dfn[FuckTrump_from]==low[FuckTrump_from])
    {
        TheSovietUnion_CntSize++;
        while(!s.empty())
        {
            int RedAmryIsTheStrongest_temp=s.top();
            s.pop();
            flag[RedAmryIsTheStrongest_temp]=false;
            color[RedAmryIsTheStrongest_temp]=TheSovietUnion_CntSize;
            Nodedis[TheSovietUnion_CntSize]=min(Nodedis[TheSovietUnion_CntSize],dis[RedAmryIsTheStrongest_temp]);//缩点后的点的代价为原来的环的代价中最小的那个代价.
            color[RedAmryIsTheStrongest_temp]=TheSovietUnion_CntSize;//染色.
            if(RedAmryIsTheStrongest_temp==FuckTrump_from)break;
        }
    }
}

```

---

## 作者：Priori_Incantatem (赞：4)

我们观察题目的性质发现，如果一个强联通分量里有一个人被收买或被控制了，整个强联通分量里的所有人都可以被控制

首先，我们跑一边$tarjan$缩点，然后将所有可收买的间谍所在的强联通分量，跑一边拓扑排序  
如果最后所有点都被访问过了，输出`YES`，否则输出`NO`。 

输出`NO`的第二问就很简单了，关键是`YES`的第二问  

既然已经保证了所有的间谍都可以被控制，那么对于每一个入度不为$0$且可以被收买的间谍，他的前驱节点肯定也被控制了，说明他的前驱节点中有可被收买的间谍，并且明显价值更大，所以我们只需要买入度为$0$的节点（间谍）。 这里说的入度指的是所在强联通分量的入度

### 注意： 一个强联通分量中，可能会有多个可收买的间谍，只选代价最小的那个  
不然你只有$54$分

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
using namespace std;
const int Maxn=3010,inf=0x3f3f3f3f;
vector <int> e[Maxn],g[Maxn];
int low[Maxn],dfn[Maxn],f[Maxn];
int ind[Maxn],ind2[Maxn];
bool vis[Maxn];
int n,m,ans,k,timecnt;
stack <int> s;
struct spy{
	int pos,cost;
}a[Maxn];
inline bool cmp(spy x,spy y)
{
	return x.cost<y.cost;
}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void tarjan(int x)
{
	dfn[x]=low[x]=++timecnt;
	vis[x]=1,s.push(x);
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(vis[y])low[x]=min(low[x],low[y]);
	}
	if(dfn[x]==low[x])
	{
		while(s.size())
		{
			int y=s.top();
			s.pop();
			f[y]=x,vis[y]=0;
			if(x==y)break;
		}
	}
}
void topo()
{
	queue <int> q;
	for(int i=1;i<=k;++i)
	q.push(f[a[i].pos]);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		if(vis[x])continue;
		vis[x]=1;
		for(int i=0;i<g[x].size();++i)
		{
			int y=g[x][i];
			if(!ind[y])continue;
			ind[y]--;
			if(!ind[y])q.push(y);
		}
	}
}
int check()
{
	for(int i=1;i<=n;++i)
	{
		if(f[i]!=i)continue;
		if(!vis[i])return i;
	}
	return 0;
}
int main()
{
	//freopen("in.txt","r",stdin);
	n=read(),k=read();
	for(int i=1;i<=k;++i)
	a[i].pos=read(),a[i].cost=read();
	m=read();
	for(int i=1;i<=m;++i)
	{
		int x=read(),y=read();
		e[x].push_back(y);
	}
	for(int i=1;i<=n;++i)
	if(!dfn[i])tarjan(i);
	for(int i=1;i<=n;++i)
	{
		for(int j=0;j<e[i].size();++j)
		{
			int x=i,y=e[i][j];
			if(f[x]==f[y])continue;
			g[f[x]].push_back(f[y]);
			ind[f[y]]++,ind2[f[y]]++; //存储两遍入度是因为其中一个会在拓扑排序中被修改
		}
	}
	topo();
	int tmp=check();
	if(tmp)
	{
		printf("NO\n%d\n",tmp);
		return 0;
	}
	memset(vis,0,sizeof(vis));//多次利用了vis
	sort(a+1,a+1+k,cmp);
	for(int i=1;i<=k;++i)
	{
		if(!ind2[f[a[i].pos]] && !vis[f[a[i].pos]])
		ans+=a[i].cost,vis[f[a[i].pos]]=1;
	}
	printf("YES\n%d\n",ans);
	return 0;
}
```

---

## 作者：Bryant (赞：4)

Tarjan缩点，每个点存下来收买需要的最小价值和包含的最小标号，找入度为0的点，如果所有入度为0的点都可以控制就是YES,控制住入度为0的点就是最小结果，否则NO，找到无法控制的入度为0的点，DFS直到有可控制的停止，更新不可控的最小序号即可


---

## 作者：bymlg001 (赞：3)

我从隔壁  P2835 刻录光盘 过来；

代码差不多，tarjan缩点模板；

缩的点价格取这个强连通分量里的最小价格便可；

最后如果这个点能通过买其他人干掉那肯定不买；

###
```cpp
#include<iostream>
#include<cstdio>
#include<stack>
using namespace std;
const int N=3005,INF=2147483647;
int n,p,r,t1,t2,t3,k;
int tot,head[N*3],next[N*3],to[N*3];
int w[N],color[N],dfn[N],low[N],cost[N],timer,color_num,rd[N],ans;
bool vis[N],in[N];
stack<int> sta;
inline void add(int x,int y){
    to[++tot]=y;
    next[tot]=head[x];
    head[x]=tot;
}
void dfs(int x){
    vis[x]=1;k++;
    for(int i=head[x];i!=-1;i=next[i]){
        if(!vis[to[i]])     dfs(to[i]);
    }
}
void tarjan(int x){         //隔壁题的模板
    dfn[x]=low[x]=++timer;
    in[x]=1;sta.push(x);
    for(int i=head[x];i!=-1;i=next[i]){
        if(!dfn[to[i]]){
            tarjan(to[i]);
            low[x]=min(low[x],low[to[i]]);
        }
        else if(in[to[i]]) low[x]=min(low[x],dfn[to[i]]);
    }
    if(dfn[x]==low[x]){              //不愿意用do while 改不过来了；
        color_num++;
        while(sta.top()!=x){
            color[sta.top()]=color_num;
            cost[color_num]=min(cost[color_num],w[sta.top()]);
            in[sta.top()]=0;
            sta.pop();
        }
        color[sta.top()]=color_num;
        cost[color_num]=min(cost[color_num],w[sta.top()]); //取最小花费
        in[sta.top()]=0;
        sta.pop();
    }
}
int main(){
    cin>>n>>p;
    fill(head,head+N*3,-1);
    fill(w,w+N,INF);
    fill(cost,cost+N,INF);
    for(int i=1;i<=p;i++){
        cin>>t1>>t2;
        w[t1]=t2;
    }
    cin>>r;
    for(int i=1;i<=r;i++){
        cin>>t1>>t2;
        add(t1,t2);
    }
    for(int i=1;i<=n;i++){                     //dfs搜一下看看是否有解
        if(w[i]!=INF&&!vis[i]){
            dfs(i);
        }
    }
    if(k<n){
        cout<<"NO"<<endl;
        for(int i=1;i<=n;i++){
            if(!vis[i]){
                cout<<i<<endl;  
                return 0;          //直接强退
            }
        }    
    } 
    for(int i=1;i<=n;i++){
        if(!dfn[i]) tarjan(i);
    }
/*    for(int i=1;i<=n;i++){           //调试用的
        cout<<color[i]<<" ";
    }
    for(int i=1;i<=n;i++){            //边写边调是个好习惯，等代码长了再找错就麻烦了
        cout<<cost[color[i]]<<" ";
    }*/
    for(int i=1;i<=n;i++){
        for(int j=head[i];j!=-1;j=next[j]){
            if(color[i]!=color[to[j]])        //一开始这里忘加了 只有54分？？？？（竟然不是5的倍数）
            rd[color[to[j]]]++;
        }
    }
    for(int i=1;i<=color_num;i++){
        if(!rd[i]) ans+=cost[i];
    }
    cout<<"YES"<<endl;
    cout<<ans<<endl;
}
```
/\*
7
6
1 10
2 9
3 8
4 7
5 6
6 5
6
1 2
2 3
3 4
4 5
5 2
6 7
我自己造的数据

答案应该是 15

\*/

---

## 作者：ivyjiao (赞：2)

算法：Kosaraju。

本题是 [P2746 [USACO5.3] 校园网Network of Schools](https://www.luogu.com.cn/problem/P2746) 的双倍经验。

本文假设你会缩点。

首先我们思考什么时候无解？

有人不会被收买也不会被揭发。

这个很简单，用一个 dfs 处理就行。

然后大力缩点，对于每个强连通分量统计其在强连通分量层面上的入度，如果入度为 $0$，则收买该强连通分量中需要钱数最小的间谍（这个可以在缩点时预处理），否则这个强连通分量中的间谍可以通过其他强连通分量中被收买或揭发的间谍揭发，无需再进行收买。

然后就过了，完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,c,num,mon,a[100001],u,v,col[100001],cnt,rd[100001],sum[100001],ans;
vector<int>G[100001],H[100001],s;
bool vis[100001],cs[100001];
void dfs1(int u){
    vis[u]=1;
    for(int i=0;i<G[u].size();i++) if(!vis[G[u][i]]) dfs1(G[u][i]);
    s.push_back(u);
}
void dfs2(int u){
    col[u]=cnt;
    if(a[u]) sum[cnt]=min(sum[cnt],a[u]);
    for(int i=0;i<H[u].size();i++) if(!col[H[u][i]]) dfs2(H[u][i]);
}
void kosaraju(){
    for(int i=1;i<=n;i++) if(!vis[i]) dfs1(i);
    for(int i=s.size()-1;i>=0;i--){
        if(!col[s[i]]){
            cnt++;
            dfs2(s[i]);
        }
    }
}
void dfs(int u,int fa){
    cs[u]=1;
    for(int i=0;i<G[u].size();i++){
        if(cs[G[u][i]]) continue;
        dfs(G[u][i],u);
    }
}
int main(){
    memset(sum,0x3f,sizeof sum);
    cin>>n>>c;
    for(int i=1;i<=c;i++){
        cin>>num>>mon;
        a[num]=mon;
    }
    cin>>m;
    for(int i=1;i<=m;i++){
        cin>>u>>v;
        G[u].push_back(v);
        H[v].push_back(u);
    }
    kosaraju();
    for(int i=1;i<=n;i++){
        if(!cs[i]&&a[i]) dfs(i,0);
    }
    for(int i=1;i<=n;i++){
        if(!cs[i]){
            cout<<"NO\n"<<i;
            return 0;
        }
    }
	for(int i=1;i<=n;i++){
		for(int j=0;j<G[i].size();j++){
			if(col[i]!=col[G[i][j]]) rd[col[G[i][j]]]++;
        }
    }
    for(int i=1;i<=cnt;i++){
        if(!rd[i]) ans+=sum[i];
    }
    cout<<"YES\n"<<ans;
}
```

---

## 作者：kradcigam (赞：2)

# 前置知识：

- [强联通分量](https://blog.csdn.net/qq_46230164/article/details/105406699)

# 分析

会了强联通分量以后呢，我们可以开始写这道题了。首先这道题不是一个 $DAG$ 我们应该先缩点，把这个图变成一个 $DAG$。

变成 $DAG$ 就好了，我们就可以记录每个点的入度，答案即为所有入度为 $0$ 的点的值的和（值就是这个点内的所有人被收买的数额中的最小值（不会被收买钱数为 $\inf$））。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
template<typename T>inline void read(T &FF){
	T RR=1;FF=0;char CH=getchar();
	for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
	for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
	FF*=RR;
}
template<typename T>inline void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar('0'+x%10);
}
const int MAXN=1e6+10,MAXM=1e6+10;
int s[MAXN],stop,dfn[MAXN],low[MAXN],scccnt,sccnum[MAXN],dfscnt,tot,he[MAXN],ne[MAXM<<1],ed[MAXM<<1],n,x,y,de[MAXN],ans,m,k,dis[MAXN],num[MAXN],sum[MAXN];
void add(int x,int y){
	ed[++tot]=y;
	ne[tot]=he[x];
	he[x]=tot;
}
inline void tarjan(int now){
	dfn[now] = low[now] = ++dfscnt;
	s[stop++] = now;
	for (int i=he[now];i;i=ne[i]){
		if(!dfn[ed[i]]){
			tarjan(ed[i]);
			low[now] = min(low[now], low[ed[i]]);
		}else if(!sccnum[ed[i]]) {
			low[now] = min(low[now], dfn[ed[i]]);
		}
	}
	if(dfn[now]==low[now]){
		scccnt++;
		do{
			sccnum[s[--stop]]=scccnt;
			sum[scccnt]=min(sum[scccnt],dis[s[stop]]);//取min
		}while(s[stop]!=now);
	}
}//强联通分量
signed main(){
	memset(sum,127,sizeof(sum));//赋上无穷大
	memset(dis,127,sizeof(dis));//赋上无穷大
	read(n);read(k);
	for(int i=1;i<=k;i++)read(num[i]),read(dis[num[i]]);
	read(m);
	for(int i=1;i<=m;i++){
		read(x);read(y);
		add(x,y);
	}
	for(int i=1;i<=k;i++)
		if(!dfn[num[i]])tarjan(num[i]);
	for(int i=1;i<=n;i++)
		if(!dfn[i])return cout<<"NO\n"<<i,0;//可以被收买的点中不知道这个点的消息，即为不可以控制所有间谍
	for(int i=1;i<=n;i++)
		for(int j=he[i];j;j=ne[j])
			if(sccnum[i]!=sccnum[ed[j]])de[sccnum[ed[j]]]++;
	for(int i=1;i<=scccnt;i++)
		if(!de[i])ans+=sum[i];
	cout<<"YES\n"<<ans;
	return 0;
}
```

---

## 作者：Episode9 (赞：2)

## 废话
此题真的是......一言难尽，判NO那里判了好久，YES倒是过了。
## 思路
1. 先说YES吧，就是先缩点，同时把每个强连通分量中的最小值求出来，最后把那些入度为0的分量最小值相加（入度为0也就是说没有人可以举报他们）。
1.  至于NO的话，一开始我也是用是否能被举报或能被收买来判断的，但莫名WA了，然后想了一下：如果一个点在**tarjan后的的dfn为0**，那么这个点一定不能被举报（遍历），也不能被收买
$（if (!dfn[i]&&cost[i]!=999999999) Tarjan(i);)$

## 代码
略长
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,r;
int cost[3005],MIN_COST[3005];
int head[3005],cnt=0;
int low[3005],dfn[3005],num=0,top=0,st[3005],col=0,co[3005];
int degree_into[3005];
struct Edge{int next,to;}t[8005];
void add(int a,int b)
{
    t[++cnt].next=head[a];
    t[cnt].to=b;
    head[a]=cnt;
}
void Tarjan(int u)
{
	dfn[u]=low[u]=++num;
	st[++top]=u;
	for (int i=head[u]; i; i=t[i].next)
	{
		int v=t[i].to;
		if (!dfn[v])
		{
			Tarjan(v);
			low[u]=min(low[u],low[v]);
		}else
		if (!co[v]) low[u]=min(low[u],dfn[v]);
	}
	if (low[u]==dfn[u]) 
	{
		co[u]=++col;
		MIN_COST[col]=min(MIN_COST[col],cost[u]);
		while (st[top]!=u)
		{
			co[st[top]]=col; 
			MIN_COST[col]=min(MIN_COST[col],cost[st[top]]);
			--top;
		}
		--top;
	}
}
int main()
{
    scanf("%d%d",&n,&q);
	for (int i=1;i<=n;i++) MIN_COST[i]=999999999;
	for (int i=1;i<=n;i++) cost[i]=999999999;
    for (int i=1; i<=q; i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        cost[x]=y;
    } 
    scanf("%d",&r);
    for (int i=1; i<=r; i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
    }
    for (int i=1; i<=n; i++) if (!dfn[i]&&cost[i]!=999999999) Tarjan(i);
    for (int i=1; i<=n; i++)
     for (int j=head[i]; j; j=t[j].next)
     if (co[i]!=co[t[j].to]) degree_into[co[t[j].to]]++;
	 //for (int i=1;i<=n;i++) cout<<MIN_COST[co[i]]<<" "<<co[i]<<" "<<degree_into[co[i]]<<endl;
    for (int i=1; i<=n; i++) 
    if (!dfn[i])
	{
        cout<<"NO"<<endl;
        cout<<i<<endl;
        return 0;
    }  
    int sum=0;
    for (int i=1; i<=col; i++) if (degree_into[i]==0) sum+=MIN_COST[i];
    cout<<"YES"<<endl;
    cout<<sum<<endl; 
    return 0;
}
```
好吧，其实不算很长

---

## 作者：FlierKing (赞：2)

这道题居然放在图的遍历里……

<hr>
这道题主要用到的是强连通分量。

首先先对每个同意受贿的人BFS一遍，判断一下如果有人没被BFS到就输出NO

然后用强连通分量缩点，对于每个强连通分量，需要付出的钱是本强连通分量中价格最少的那个。

最后答案为所有入度为0的点的价格之和

时空复杂度：O(n) （其实常数挺大）

（本代码使用了c++的vector，较省空间）

[/color][codec ]





```cpp
#include <iostream>
#include <cstring>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <vector>
#define INF 2147483647
#define ll long long
#define PI 3.14159265358979323846
#define MO 1000000007
using namespace std;
//num是出度；pr是价格，不能贿赂则为INF；used用于判断是否被搜索到；num2是入度；v和f分别记录出边和入边
struct sth
{
int num,pr,used,num2;
vector <int> v;
vector <int> f;
}pe[3010],npe[3010];
int n,p,r,w,t,st,en,inde,ans;
int l[10000],dfn[3010],low[3010],bac[3010];
int ins[3010];
bool found;
//快速读入
inline int read()
{
int x=0,f=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
return x*f;
}
//判NO的BFS
void make(int x)
{
for (int i=0;i<pe[x].num;i++)
if (!pe[pe[x].v[i]].used)
{
pe[pe[x].v[i]].used=true;
en++;
l[en]=pe[x].v[i];
}
}
//强连通分量
void tarjan(int x)
{
ins[x]=1;
low[x]=dfn[x]=++inde;
for (int i=0;i<pe[x].num;i++)
if (!dfn[pe[x].v[i]])
{
tarjan(pe[x].v[i]);
en++;
l[en]=pe[x].v[i];
low[x]=min(low[x],low[pe[x].v[i]]);
}
else if (ins[pe[x].v[i]]==1)
{
low[x]=min(low[x],dfn[pe[x].v[i]]);
}
}
int main()
{
n=read(),p=read();
for (int i=1;i<=n;i++)
pe[i].pr=INF;
for (int i=1;i<=p;i++)
{
w=read();
pe[w].pr=read();
}
r=read();
//使用vector加边
for (int i=1;i<=r;i++)
{
w=read(),t=read();
pe[w].num++;
pe[w].v.push_back(t);
pe[t].num2++;
pe[t].f.push_back(w);
}
for (int i=1;i<=n;i++)
if (pe[i].pr<INF)
{
pe[i].used=true;
st=0,en=0,l[0]=i;
while (st<=en)
{
make(l[st]);
st++;
}
}
for (int i=1;i<=n;i++)
if (!pe[i].used)
{
printf("NO\n%d",i);
return 0;
}
for (int i=1;i<=n;i++)
if (!ins[i]) 
{
st=0,en=0,l[0]=i;
tarjan(i);
for (int j=0;j<=en;j++)
bac[dfn[l[j]]]=l[j];
for (int j=0;j<=en;j++)
{
//缩点
if (dfn[l[j]]!=low[l[j]])
{
int fr=l[j],to=bac[low[l[j]]];
pe[to].pr=min(pe[to].pr,pe[fr].pr);
pe[fr].used=false;
pe[to].num+=pe[fr].num;
for (int k=0;k<pe[fr].num;k++)
pe[to].v.push_back(pe[fr].v[k]);
pe[to].num2+=pe[fr].num2;
for (int k=0;k<pe[fr].num2;k++)
pe[to].f.push_back(pe[fr].f[k]);
}
ins[l[j]]=2;
}
}
//去无用边及自环
for (int i=1;i<=n;i++)
if (pe[i].used)
{
for (int j=0;j<pe[i].num;j++)
if (pe[pe[i].v[j]].used&&pe[i].v[j]!=i)
{
npe[i].num++;
npe[i].v.push_back(pe[i].v[j]);
}
for (int j=0;j<pe[i].num2;j++)
if (pe[pe[i].f[j]].used&&pe[i].f[j]!=i)
{
npe[i].num2++;
npe[i].f.push_back(pe[i].f[j]);
}
npe[i].pr=pe[i].pr;
npe[i].used=true;
}
for (int i=1;i<=n;i++)
if (npe[i].used&&!npe[i].num2) ans+=npe[i].pr;
printf("YES\n%d",ans);
return 0;
}
[/codec ]
```

---

## 作者：Social_Zhao (赞：1)

这题不难，主要是细节。

这题有点像[P2341 [HAOI2006]受欢迎的牛](https://www.luogu.org/problemnew/show/P2341)，但又有一些不同。

吐槽完毕，正题开始。

我们可以发现每个间谍之间的关系会构成一张有向图。如果一个间谍被~~攻略~~逮捕了，那么他的所有出边所连接的间谍都会被~~攻略~~逮捕。

这时候就会出现一种很爽的情况：如果你~~攻略~~逮捕的某个间谍处于一个$SCC$......那么这整个$SCC$都会被~~攻略~~逮捕。这时候就需要~~太监~~塔尔杨（$Tarjan$）算法来缩点了，这是我们要记下每个$SCC$中受贿数额最低是多少。

在缩点的时候，我们可以选择搜索树的树根，就是这一步（学过$Tarjan$的应该都知道）

```cpp
for(int i = 1; i <= n; i++) if(!dfn[i] && ......) tarjan(i); //这里的i就是树根
```

为了后面方便，我们只选择可以贿赂的间谍做树根，那么逮捕不到的间谍在搜索的时候是搜不到的，它的入栈时间戳就是$0$。现在无解的情况已经解决了。我们把所有点扫一遍，如果有谁的$dfn$值为$0$，说明此题无解。这时输出编号，结束程序。

然后不难发现如果有解，这个缩点后的图就是一堆$DAG$。

打个比方：这就像一堆食物网。物质和能量沿着边流动。~~（初二要地生中考了，看啥都能想到地生）~~

现在我们想让这堆食物网中的生物大灭绝。我们只需要杀死所有生产者，然后消费者就会随之消亡。（好邪恶的想法）

生产者是食物链的最底层，它们的入度都是$0$。

正如这个例子，我们只需要找出入度为$0$的$SCC$，用最低价格完成贿赂。把这些最低价格全部加起来就得出了解。

代码：（$codestyle$、名字很清奇勿喷。~~一定要有个好的马蜂，他能让你少写不少行~~）

```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<cstring>
#include<cstdlib>
using namespace std;

const int MaxN = 8005;
const int MaxM = MaxN * MaxN;
int n, m, p;
struct Edge //链式前向星
{
    int v, nxt;
} edge[MaxM];
int val[MaxN], head[MaxN], k = 1;
stack<int>st;
int low[MaxN], dfn[MaxN], col[MaxN], ins[MaxN], cnt = 0, tim = 0;
int minn[MaxN];
int deg[MaxN];
int ans = 0;

void addedge(int u, int v) //建边（单向）
{
    edge[k].v = v;
    edge[k].nxt = head[u];
    head[u] = k++;
}

inline void init() //初始化和读入
{
    memset(val, 0x3f, sizeof(val));
    memset(minn, 0x3f, sizeof(minn));
    scanf("%d", &n);
    scanf("%d", &p);
    for(int i = 1; i <= p; i++)
    {
        int u;
        scanf("%d", &u);
        scanf("%d", &val[u]);
    }
    scanf("%d", &m);
    for(int i = 1; i <= m; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        addedge(u, v); //从u到v连有向边
    }
}

void tarjan(int u) //Tarjan的板子
{
    low[u] = dfn[u] = ++tim;
    ins[u] = 1;
    st.push(u);
    for(int i = head[u]; i; i = edge[i].nxt)
    {
        int v = edge[i].v;
        if(!dfn[v]) 
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(ins[v])
        {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if(low[u] == dfn[u])
    {
        int l;
        cnt++;
        do 
        {
            l=st.top();st.pop();
            ins[l]=0;
            col[l]=cnt;
            minn[cnt] = min(minn[cnt], val[l]); //记录每个SCC中最小可以贿赂的
        } while(l!=u);
    }
}

void Seek_SCC()
{
    //找可以贿赂的间谍，以之为根跑Tarjan
    for(int i = 1; i <= n; i++) if(!dfn[i] && val[i] != 0x3f3f3f3f) tarjan(i); 
}

void Judge_NoSolution()
{
	for(int i = 1; i <= n; i++)
    {
    	if(!dfn[i]) //如果这个点没有搜到，说明不可能将其逮捕
		{
    		printf("NO\n%d", i);
    		exit(0);
		}
	}
}

void Calc_Deg()
{
    for(int i = 1; i <= n; i++)
    {
        for(int j = head[i]; j; j = edge[j].nxt)
        {
            int v = edge[j].v;
            if(col[i] != col[v]) //如果这条边的起点和终点不在同一SCC，那么终点所在SCC入度加一
            {
                deg[col[v]]++;
            }
        }
    }
}

void Calc_Ans()
{
	ans = 0;
    for(int i = 1; i <= cnt; i++)
    {
        if(deg[i] == 0) //如果入度为0就进行贿赂
        {
            ans += minn[i];
        }
    }
}

void solve()
{
    Seek_SCC(); //求SCC
    Judge_NoSolution(); //判断无解，如果无解会在函数里结束，不会执行以下步骤
    Calc_Deg(); //统计入度
    Calc_Ans(); //计算答案
    printf("YES\n%d", ans);
}

int main()
{
    init(); //初始化
    solve(); //求解
}
```



---

## 作者：OIer991215 (赞：1)

思路如下：

1.输入数据，用mon[a]表示收买a的花费

用tarjan进行缩点

①用cos数组   记录 一个环的最小花费，初始化为19991215

②用num数组  记录一个环最小的标号 ，初始化为19991215

2.建立新图

3.首先让所有入度为0的点进行收买，ans\_1+=cos[i]，然后向下dfs，把dfs到的点标记为vis[i]=1

（如果入度为0 且 此点的花费为19991215。那么答案一定是NO，然后用ans\_2更新编号小的答案(ans\_2的初始化值为19991215)）

4.判断当前剩下的vis[i]=0的点 的 花费 cos[i] 是否为19991215，如果是，继续用ans\_2更新编号小的答案

5.将所有vis[i]=0的点对应的花费cos[i]加给ans\_1，并标记vis[i]=1;

6.如果ans\_2不等于19991215，输出ans\_2,否则输出ans\_1.


代码如下（长代码往往更清晰 并且容易 找错误）：






    
    
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,m,k,a,b;
int ans_1,ans_2;
int dfn[202020],low[202020];
int sta[202020],col[202020];
int cos[202020],mon[202020];
int num[202020];
bool vis[202020],rd[202020];
int head[202020],pead[202020];
struct Node_1
{
    int to,next;
}e[202020];
struct Node_2
{
    int to,next;
}p[202020];
int read()
{
    int rt=0,in=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            in=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        rt=rt*10+ch-'0';
        ch=getchar();
    }
    return rt*in;
}
void add_old_edge(int u,int v)
{
    e[++head[0]].to=v;
    e[head[0]].next=head[u];
    head[u]=head[0];
}
void add_new_edge(int u,int v)
{
    p[++pead[0]].to=v;
    p[pead[0]].next=pead[u];
    pead[u]=pead[0];
}
void tarjan(int x)
{
    dfn[x]=low[x]=++dfn[0];
    vis[x]=true;
    sta[++sta[0]]=x;
    for(int i=head[x]; i!=0; i=e[i].next)
        if(!dfn[e[i].to])
        {
            tarjan(e[i].to);
            low[x]=min(low[x],low[e[i].to]);
        }
        else if(vis[e[i].to])
            low[x]=min(low[x],dfn[e[i].to]);
    if(dfn[x]==low[x])
    {
        vis[x]=false;
        ++col[0];
        cos[col[0]]=19991215;
        num[col[0]]=19991215;
        while(sta[sta[0]+1]!=x)
        {
            vis[sta[sta[0]]]=false;
            col[sta[sta[0]]]=col[0];
            num[col[0]]=min(num[col[0]],sta[sta[0]]);
            if(mon[sta[sta[0]]]!=0)
                cos[col[0]]=min(cos[col[0]],mon[sta[sta[0]]]);
            sta[0]--;
        }
    }
}
void dfs(int x)
{
    vis[x]=1;
    for(int i=pead[x]; i!=0; i=p[i].next)
        if(!vis[p[i].to])
            dfs(p[i].to);
}
int main()
{
    n=read();k=read();
    for(int i=1; i<=k; i++)
    {
        a=read();
        mon[a]=read();
    }
    m=read();
    for(int i=1; i<=m; i++)
    {
        a=read();b=read();
        add_old_edge(a,b);
    }
    for(int i=1; i<=n; i++)
        if(!dfn[i])
            tarjan(i);
    for(int i=1; i<=n; i++)
        for(int j=head[i]; j!=0; j=e[j].next)
            if(col[i]!=col[e[j].to])
            {
                add_new_edge(col[i],col[e[j].to]);
                rd[col[e[j].to]]=1;
            }
    for(int i=1; i<=col[0]; i++)
        if(!rd[i]&&!vis[i]&&cos[i]!=19991215)
        {
            ans_1+=cos[i];
            dfs(i);
        }
    ans_2=19991215;
    for(int i=1; i<=col[0]; i++)
        if(cos[i]==19991215&&!vis[i])
            ans_2=min(num[i],ans_2);
    if(ans_2!=19991215)
    {
        printf("NO\n%d",ans_2);
        return 0;
    }
    for(int i=1; i<=col[0]; i++)
        if(!vis[i])
        {
            vis[i]=true;
            ans_1+=cos[i];
        }
    printf("YES\n%d",ans_1);
    return 0;
}

```

---

## 作者：zhongxing (赞：1)

 
```cpp
type
 edge=record
  node,next:longint;
  end;
var
 n,ans,x,y,c,deep//时间戳,tot:longint;
 du,list,w,first,dfn,low:array[0..3000]of longint;
 e:array[0..8000*4]of edge;
 v,f:array[0..3000]of boolean;
 indu,rd,mc,stack:array[0..3000]of longint;
 path:array[0..3000,0..3000]of boolean;
 num,minn,nd:longint;
function min(x,y:longint):longint;
begin
 if x>y then exit(y) else exit(x);
end;
procedure insert(x,y:longint);
begin
 inc(tot);
 with e[tot] do
 begin
  node:=y;
  next:=first[x];
  first[x]:=tot;
 end;
end;
procedure zoom(x:longint);//缩点
var
 i,j,d,l,min,mint:longint;
begin
 min:=maxlongint;
 mint:=min;
 d:=0;
 l:=0;
 while stack[num]<>x do//清除
 begin
  inc(l);
  list[l]:=stack[num];
  f[stack[num]]:=false;
  dec(num);
 end;
 f[stack[num]]:=false;
 inc(l);
 list[l]:=stack[num];
 dec(num);
 for i:=1 to l do
 begin
  if list[i]<mint then mint:=list[i];
  d:=rd[list[i]]+d;
  if (w[list[i]]>0)and(w[list[i]]<min)then min:=w[list[i]];//找到收买者
 end;
 for i:=1 to l do
  for j:=1 to l do
   if (i<>j)and(path[i,j])then dec(d);
   if (d=0)and(min=maxlongint)then//如果不能被收买而且rudu为0的点就impossible了
   if mint<minn then minn:=mint;
   inc(nd);
   du[nd]:=d;
   mc[nd]:=min;
end;
procedure dfs(x:longint);
var i:longint;
begin
 inc(deep);//时间戳
 dfn[x]:=deep;
 low[x]:=deep;
 inc(num);
 stack[num]:=x;
 i:=first[x];
 v[x]:=true;
 f[x]:=true;
 while i<>0 do
 begin
  if not v[e[i].node]then
  begin
   dfs(e[i].node);
   low[x]:=min(low[x],low[e[i].node]);
  end
  else if f[e[i].node]then
   low[x]:=min(low[x],low[e[i].node]);
   i:=e[i].next;
  end;
 if dfn[x]=low[x] then zoom(x);//是强连通分量
end;
procedure get;
var i:longint;
begin
 if minn<>maxlongint then//更新过就证明有点不能被访问。。
 begin
  writeln('NO');
  writeln(minn);
  halt;
 end;
 for i:=1 to nd do
  if du[i]=0 then inc(ans,mc[i]);//扫描每个缩点，如果需要被收买就收买他。
  writeln('YES');
  writeln(ans);
END;
PROCEdure READIN;//读入
var i,p,r:longint;
begin
 read(n);
 read(p);
 for i:=1 to p do
 begin
  read(c);
  readln(w[c]);
 end;
 read(r);
 for i:=1 to r do
 begin
  read(x,y);
  insert(x,y);
  path[x,y]:=true;
  inc(rd[y]);//入度++
 end;
 minn:=maxlongint;
 for i:=1 to n do
  if not v[i] then dfs(i);//可能还可以更新的点
 get;
end;
begin
 assign(input,'dist.in');
 reset(input);
 readin;
 close(input);
end.>>tarjan求缩点
```

---

## 作者：lqylqylqy (赞：1)

其实这题就是floodfill+tarjan。

开始先bfs一遍，如果不能被收买直接halt终止程序。

否则就说明都能被收买。那么tarjan求强连通分量，

同时进行缩点，并统计出每个强连通分量中最小的被收买的价格，

最后把入度为零的强连通分量的最小被收买价格累加起来。

我的代码已经写的很清楚了，照我的写就可以啦~~~

```delphi


program jdwl;
type point=^node;
     node=record
            data:longint;
            next:point;
          end;
var newn,n,i,r,mcost,ed,time,hao,a,b,p,head,tail:longint;
    v,sfzz:array[0..6100]of boolean;
    con:array[0..6100]of point;
    rp:point;
    d,dfn,low,zhan,cost,rd,fan,dgcost,belong:array[0..6100]of longint;

function min(a,b:longint):longint;
begin
  if a<b then exit(a);
  exit(b);
end;

procedure add(a,b:longint);
var p:point;
begin
  new(p);
  p^.data:=b;
  p^.next:=con[a];
  con[a]:=p;
end;

procedure bfs;//不能收买的情况直接floodfill
var p:point;
    zi:longint;
begin
  while head<=tail do
    begin
      p:=con[d[head]];
      while p<>nil do
        begin
          zi:=p^.data;
          if v[zi]=false then
            begin
              inc(tail);
              d[tail]:=zi;
              v[zi]:=true;//dfs开头,bfs中间,进行标记，进栈等
            end;
          p:=p^.next;
        end;
      inc(head);
    end;
end;

procedure dfs(x:longint);
var p:point;
    zi,st,i:longint;//zi:儿子节点
begin
  v[x]:=true;//dfs开头,bfs中间,进行标记，进栈等

  inc(ed);//入栈
  zhan[ed]:=x;//栈里每个编号对应一个点
  fan[x]:=ed;//每个点对应栈里一个编号
  sfzz[x]:=true;

  inc(time);
  dfn[x]:=time;
  low[x]:=time;
  //dfn:时间戳;low:能追溯到的栈中最小的时间戳

  p:=con[x];
  while p<>nil do
    begin
      zi:=p^.data;
      if v[zi]=false then
        begin
          dfs(zi);
          low[x]:=min(low[x],low[zi]);
          //如果未被访问过，找本身和儿子结点中最小的low
        end

                      else
        if sfzz[zi]=true then
          low[x]:=min(low[x],dfn[zi]);
        //如果在栈里，找本身的low和儿子结点的dfn中更小的
      p:=p^.next;
    end;

  if dfn[x]=low[x]then //出栈
    begin
      inc(newn);//强连通分量个数标号
      st:=fan[x];
      for i:=st to ed do
        begin
          sfzz[zhan[i]]:=false;//还原
          belong[zhan[i]]:=newn;
          //标记属于哪一个强连通分量
          if(cost[zhan[i]]>-maxlongint+1)and
            (cost[zhan[i]]<dgcost[newn])then
              dgcost[newn]:=cost[zhan[i]];
          //求出当前强连通分量的mincost
        end;
      ed:=st-1;
    end;
end;

begin
  readln(n);

  mcost:=0;
  newn:=0;
  for i:=1 to n do
    begin
      cost[i]:=-maxlongint+1;
      dgcost[i]:=maxlongint-1;
      v[i]:=false;
      sfzz[i]:=false;
      rd[i]:=0;
      con[i]:=nil;
    end;

  readln(p);
  for i:=1 to p do
    readln(hao,cost[hao]);

  readln(r);
  for i:=1 to r do
    begin
      readln(a,b);
      add(a,b);
    end;

  for i:=1 to n do
    if(v[i]=false)and(cost[i]>-maxlongint+1)then
      begin
        head:=1;
        tail:=1;
        d[1]:=i;
        v[i]:=true;
        bfs;
      end;//从每个可以被收买的点出发进行填充

  for i:=1 to n do
    if v[i]=false then
      begin
        writeln('NO');
        writeln(i);
        halt;
      end;


  for i:=1 to n do v[i]:=false;
  for i:=1 to n do
    begin
      if v[i]=true then continue;
      ed:=0;
      time:=0;
      //可清零可不清
      dfs(i);
    end;

  for i:=1 to n do
    begin
      rp:=con[i];
      while rp<>nil do
        begin
          if belong[i]<>belong[rp^.data]then
            inc(rd[belong[rp^.data]]);
          //若两个点不属于同一个强连通分量,
          //则子节点所属的强连通分量入度加一
          rp:=rp^.next;
        end;
    end;

  for i:=1 to newn do
    if rd[i]=0 then inc(mcost,dgcost[i]);
  //找入度为零的强连通分量进行统计累加
  writeln('YES');
  writeln(mcost);
end.      


```

---

## 作者：Nyl白叶 (赞：1)

看到大家都打的是tarjan，本智障一脸迷茫】低智商版正解

对于每个可被收买且需要收买的间谍dfs 搜索到的点入度加一 显然被搜到的间谍不需要收买

for i=1 to n

若有入度为零且不可收买的点，则NO

把需要收买（入度为零）的间谍的价格加上


```cpp
var
    minm,minn,min,ans,i,n,q,x,y,r,l:longint;
    a,c,d,e:array[1..3000]of longint;
    p,w,ww:array[1..3000]of boolean;
    b:array[1..8000,1..2]of longint;
    pp:boolean;
procedure dfs(x:longint);
var l:longint;
begin
    p[x]:=true;ww[x]:=true;
    l:=a[x];
    while l<>0 do begin
        if not ww[b[l,1]] then dfs(b[l,1]);
        if b[l,1]<>e[i] then inc(d[b[l,1]]);
        l:=b[l,2];
    end;
end;
begin
    readln(n);
    readln(q);
    for i:=1 to q do begin
        readln(e[i],c[e[i]]);
        w[e[i]]:=true;
    end;
    readln(r);
    for i:=1 to r do begin
        readln(x,y);
        inc(l);b[l,1]:=y;b[l,2]:=a[x];a[x]:=l;
    end;
    for i:=1 to q do if d[e[i]]=0 then begin
        fillchar(ww,sizeof(ww),false);
        dfs(e[i]);
    end;
    for i:=1 to n do if not p[i] then begin
        writeln('NO');
        writeln(i);
        exit;
    end;
    for i:=1 to q do if d[e[i]]=0 then ans:=ans+c[e[i]];
    writeln('YES');
    writeln(ans);
end.

```

---

## 作者：SCUT_HYX (赞：0)

**更好的阅读体验：[黄毛猫_HYX的博客](https://www.luogu.org/blog/jerriehmm/solution-p1983)**

**~~推销下我的空间~~：[蒟蒻](https://www.luogu.org/blog/jerriehmm/)**

# 解题关键：tarjan 缩点 

## 1.思路

### **1.1 审题**

$A$掌握$B$的资料

**⟺** $A$被抓或者被贿赂，$B$就被暴露了

**⟺** $A$如果属于被搜过的集合，则$B$也属于

### **1.2 可行性&最优性**

进一步思考可行性：**如果一个间谍没有被其他人扼住咽喉，那么他如果不被收买，就一定不能破坏整个间谍网络；相反地，如果都可以被收买，则答案就是他们之和。**

所以我们的目标转为找到没有被扼住咽喉的间谍，并判断他们是否全部都被收买。

但是有时候我们找不到这样的点，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tqyrtp9p.png)

但是图中却有2,4,3,1互相牵制5,6,7,8相互牵制

不难发现这样的图是有环的，或者说有间谍相互牵制。

所以我们可以通过把**可以互相牵制的一群间谍**看做一个间谍，其收买费用，我们通过最优的思想，不难发现其实就是间谍群中最小的那个。

## 2.算法实现

### 2.1 强联通分量

像那一群间谍一样相互牵制，可以相互到达的点的集合叫做强联通分量，一般使用tarjan算法求取。

### 2.2 跟本题的关系

通过求强联通分量，可以将在一个强联通分量中的点看做一个大的点

如上面的一组数据，将强联通分量{1,2,3,4}看做A，{5,6,7,8}看做B，则有:

![](https://cdn.luogu.com.cn/upload/image_hosting/hqrvq60l.png)

于是，将相同强联通分量的染个色，最后再建新图就好了

(可以不建新图，但是可能会比较抽象一点点，这里就建新图直观一点)

## 3.注意

①记得给每个强联通分量弄好最小编号的，应付NO的情况

②间谍网络可能是森林，要充分遍历

## 4.代码实现

```cpp
#include<iostream>
#include<cstdio>
#define maxn 3003
#define Inf 2147483647
using namespace std;
int dfn[maxn],low[maxn],n,m,p;
int first[maxn],st[maxn],top,tot,num,cnt,co[maxn][maxn],Cost[maxn],col[maxn],mo[maxn],MIN[maxn];
bool inst[maxn],vis[maxn];
struct Edge{
    int to,nxt;
}e[maxn<<2],ne[maxn<<2];
void add(int u,int v)
    {e[++tot]=(Edge){v,first[u]};first[u]=tot;}
void tarjan(int u)
{
    low[u]=dfn[u]=++num;
    st[++top]=u;inst[u]=1;
    for(int i=first[u];i;i=e[i].nxt)
    {
        int v=e[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(inst[v]) low[u]=min(low[u],dfn[v]);
    }										//到这里都是tarjan模板，不多做解释 
    if(dfn[u]==low[u])						//找到一个强连通分量 
    {
        ++cnt; 
		int minn=Inf,minum=Inf; 			
        while(st[top]!=u&&top>0)
        {
            inst[st[top]]=0;
            co[cnt][++co[cnt][0]]=st[top];
            minn=min(minn,Cost[st[top]]);	//由上，这个强连通分量的价值由最小收买费用的间谍决定
            minum=min(minum,st[top]);		//当前强连通分量里编号最小的(应付不能收买全部的情况) 
            top--;
        }
        
        inst[u]=0;							//u也要同上处理 
		co[cnt][++co[cnt][0]]=u;
        minn=min(minn,Cost[u]);
        minum=min(minum,u);
        
        top--;mo[cnt]=minn;MIN[cnt]=minum;
        for(int i=1;i<=co[cnt][0];++i) Cost[co[cnt][i]]=minn,col[co[cnt][i]]=cnt;//价值同化，染色 
    }
}
void build_new()
{
    for(int i=1;i<=cnt;++i)
    {
        for(int j=1;j<=co[i][0];++j)
        {
            int u=co[i][j];
            for(int k=first[u];k;k=e[k].nxt)
            {
                int v=e[k].to;
                if(col[v]==col[u]) continue;//和不同强连通分量的元素连边
                vis[col[v]]=1;				//被建边的强连通分量入度不为零 
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&p);
    int u,v;
    for(int i=1;i<=maxn-1;++i) Cost[i]=Inf;	//每个间谍都要被附上最大值 
    for(int i=1;i<=p;++i)
    {
        int x;scanf("%d",&x);
        scanf("%d",&Cost[x]);
    }
    scanf("%d",&m);
    for(int i=1;i<=m;++i)
    {
        scanf("%d%d",&u,&v);
        add(u,v);							//连边 
    }
    for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);//对间谍森林tarjan一次 
    build_new();
    int ans=0;
    for(int i=1;i<=cnt;++i)
        if(!vis[i])
        {
            if(mo[i]==Inf) {printf("NO\n%d",MIN[i]);return 0;}
            ans+=mo[i];
        }
    printf("YES\n%d",ans);return 0;
}
```
## 萌新第四篇题解QWQ请多多提出意见让蒟蒻改进下

---

## 作者：寒鸽儿 (赞：0)

首先进行缩点。  
在同一个强连通分量里只需要买通一个人其他人就GG了,那么只要贪心买最便宜的人就好了。  
考虑缩点后形成的DAG森林,显然把所有入度为0的分量排掉其他分量就跟着GG了。  
若入度为0的分量都能买通,把这些分量的代价相加即为最小代价。  
如果有入度为0的分量不能买通,则一定无法买通所有间谍。  
然后从所有能买通的点开始dfs,所有没有被访问的分量内的最小编号的最小值即为答案。  
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 3456, M = 8901, inf = 0x3f3f3f3f;
int head[N<<1], cost[N], ver[M<<1], my[M<<1], nex[M<<1], tot, n;
inline void addedge(int u, int v) {
	ver[tot] = v, my[tot] = u, nex[tot] = head[u], head[u] = tot++;
}

int dfn[N], low[N], sta[N], co[N], mc[N], ind[N], vis[N], minid[N], col = 1, dfs_clock = 1, top;
void tarjan(int cur) {
	dfn[cur] = low[cur] = dfs_clock++;
	sta[top++] = cur;
	for(int i = head[cur]; ~i; i = nex[i]) 
		if(!dfn[ver[i]]) {
			tarjan(ver[i]);
			low[cur] = min(low[cur], low[ver[i]]);
		} else if(!co[ver[i]]) {
			low[cur] = min(low[cur], dfn[ver[i]]);
		}
	if(dfn[cur] == low[cur]) {
		co[cur] = col;
		mc[col] = cost[cur];
		minid[col] = cur;
		while(sta[--top] != cur) {
			co[sta[top]] = col;
			mc[col] = min(mc[col], cost[sta[top]]);
			minid[col] = min(minid[col], minid[sta[top]]);
		}
		++col;
	}
}

void dfs(int cur) {
	vis[cur] = 1;
	for(int i = head[cur+n]; ~i; i = nex[i])
		dfs(ver[i]);
}

int main() {
	memset(head, -1, sizeof(head));
	memset(cost, inf, sizeof(cost));
	int p, m, u, v;
	scanf("%d %d", &n, &p);
	for(int i = 1; i <= p; ++i) {
		scanf("%d %d", &u, &v);
		cost[u] = v;
	}
	scanf("%d", &m);
	for(int i = 1; i <= m; ++i) {
		scanf("%d %d", &u, &v);
		addedge(u, v);
	}
	memset(mc, inf, sizeof(mc));
	for(int i = 1; i <= n; ++i) if(!dfn[i]) tarjan(i);
	--col;
	for(int i = 0, end = tot; i < end; ++i)
		if(co[my[i]] != co[ver[i]]) {
			addedge(co[my[i]]+n, co[ver[i]]);
			++ind[co[ver[i]]];
		}
	int ans = 0, flg = 1;
	for(int i = 1; i <= col; ++i)
		if(!ind[i]) {
			if(mc[i] == inf)
				flg = 0;
			else {
				ans += mc[i];
			}
		}
	if(flg) {
		printf("YES\n%d\n", ans);
		return 0;
	}
	printf("NO\n");
	for(int i = 1; i <= col; ++i)
		if(!vis[i] && mc[i] != inf) {
			dfs(i);
		}
	int nid = inf;
	for(int i = 1; i <= col; ++i) 
		if(!vis[i]) {
			nid = min(nid, minid[i]);
		}
	printf("%d\n", nid);
	return 0;	
}
```

---

## 作者：lzcjoe (赞：0)

### 题面

1517：间谍网络

时间限制: 1000 ms 内存限制: 562144 KB

【题目描述】

由于外国间谍的大量渗入，国家安全正处于高度危机之中。如果$A$间谍手中掌握着关于$B$间谍的犯罪证据，则称$A$可以揭发$B$。有些间谍接受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。

我们的反间谍机关提供了一份资料，包括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有$n$个间谍，每个间谍分别用$1$到$n$的整数来标识。

请根据这份资料，判断我们是否可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。

【输入】

第一行只有一个整数$n$。第二行是整数$p$。表示愿意被收买的人数。

接下来的$p$行，每行有两个整数，第一个数是一个愿意被收买的间谍的编号，第二个数表示他将会被收买的数额。

紧跟着一行只有一个整数$r$。然后$r$行，每行两个正整数，表示数对$(A,B)$，$A$间谍掌握$B$间谍的证据。

【输出】

如果可以控制所有间谍，第一行输出$YES$，并在第二行输出所需要支付的贿金最小值。否则输出$NO$，并在第二行输出不能控制的间谍中，编号最小的间谍编号。

【输入样例】

2 

1 

2 512 

2 

1 2 

2 1

【输出样例】

YES

512

【提示】

$1≤n≤3000,1≤p≤n,1≤r≤8000$, 每个收买的费用为非负数且不超过$20000$。

### 算法

$Tarjan$强连通分量缩点

>有向图强连通分量：在有向图$G$中，如果两个顶点$vi,vj$间（$vi>vj$）有一条从$vi$到$vj$的有向路径，同时还有一条从$vj$到$vi$的有向路径，则称两个顶点强连通($strongly$ $connected$)。如果有向图$G$的每两个顶点都强连通，称$G$是一个强连通图。有向图的极大强连通子图，称为强连通分量($strongly$ $connected$ $components$)。

将原图缩点后会变成一个有向无环图，此时查找入度为$0$的强连通分量，这个强连通分量就必须收买（入度为$0$意味着没有强连通分量可以揭发这个强连通分量），其中可以收买这个强连通分量中收买费用最小的一个，这可以在算法中统计。费用为这些强连通分量的最小费用和。

对于无解的情况，应该是一个间谍不能收买也没有人能够揭发它。对于这种情况，先筛选出不能收买的间谍，不对这个间谍进行$Tarjan$算法，这样如果他是一个其他强连通分量中的点它的$dfn$的值不会为$0$，如果没有人能够揭发它时它的$dfn$值才会为$0$（根据$Tarjan$算法，每一个遍历过的点的$dfn$值都会大于$0$）。

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<stack>
#define mini(a,b) ((a)<(b)?(a):(b))
const unsigned short int N=3005,M=8005;
unsigned short int n,p,r;
struct node
{
	unsigned short int to,next;
}edge[M];
unsigned short int head[N],cnt;
inline void add(unsigned short int u,unsigned short int v)
{
	cnt++;
	edge[cnt].to=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
}//链式前向心存图、加边
unsigned short int a[N];//收买金额
unsigned short int dfn[N],low[N],step,col[N],num,minl[N];//Tarjan算法需要的数组，minl为强连通分量中贿赂金额最小值
std::stack<unsigned short int> s;
void Tarjan(unsigned short int i)
{
	step++;
	dfn[i]=step;
	low[i]=step;
	s.push(i);
	unsigned short int k;
	for(unsigned short int j=head[i];j!=0;j=edge[j].next)
	{
		k=edge[j].to;
		if(dfn[k]==0)
		{
			Tarjan(k);
			low[i]=mini(low[i],low[k]);
		}
		else if(col[k]==0)
		{
			low[i]=mini(low[i],dfn[k]);
		}
	}
	if(dfn[i]==low[i])
	{
		num++;
		col[i]=num;
		minl[num]=a[i];
		while(s.top()!=i)
		{
			col[s.top()]=num;
			minl[num]=mini(minl[num],a[s.top()]);
			s.pop();
		}
		s.pop();
	}
	return;
}
unsigned short int du[N];
unsigned int ans;
int main()
{
	scanf("%hu%hu",&n,&p);
	memset(minl,0x4f,sizeof(minl));
	memset(a,0x4f,sizeof(a));//将最小值、金额初始化为无穷大（4f4f>20000）
	unsigned short int x,y;
	for(register unsigned short int i=1;i<=p;i++)
	{
		scanf("%hu%hu",&x,&y);
		a[x]=y;
	}
	scanf("%hu",&r);
	for(register unsigned short int i=1;i<=r;i++)
	{
		scanf("%hu%hu",&x,&y);
		add(x,y);
	}//读入、加边
	for(register unsigned short int i=1;i<=n;i++)
	{
		if(dfn[i]==0 && a[i]!=0x4f4f)
		{
			Tarjan(i);//仅对于能受贿的间谍进行强连通分量计算
		}
	}
	for(register unsigned short int i=1;i<=n;i++)
	{
		if(dfn[i]==0)
		{
			puts("NO");
			printf("%hu",i);//没有访问到即无法完成任务
			return 0;
		}
	}
	for(register unsigned short int i=1;i<=n;i++)
	{
		for(register unsigned short int j=head[i];j!=0;j=edge[j].next)
		{
			if(col[i]!=col[edge[j].to])
			{
				du[col[edge[j].to]]++;//统计出度
			}
		}
	}
	for(register unsigned short int i=1;i<=num;i++)
	{
		if(du[i]==0)
		{
			ans+=minl[i];//添加答案
		}
	}
	puts("YES");
	printf("%u",ans);//输出
	return 0;
}
```

#### 运行结果

一本通OJ：

1517

通过 100分

测试点1: 答案正确 448KB 2MS 

测试点2: 答案正确 452KB 4MS 

测试点3: 答案正确 452KB 6MS 

测试点4: 答案正确 460KB 5MS 

测试点5: 答案正确 500KB 6MS 

测试点6: 答案正确 512KB 7MS 

测试点7: 答案正确 524KB 9MS 

测试点8: 答案正确 536KB 10MS 

测试点9: 答案正确 556KB 11MS 

测试点10: 答案正确 564KB 11MS 

测试点11: 答案正确 560KB 11MS 

---

洛谷：

用时 41ms 内存 944.00KB

测试点信息

3ms/664.00KB AC #1

4ms/796.00KB AC #2

3ms/596.00KB AC #3

4ms/944.00KB AC #4

3ms/632.00KB AC #5

2ms/696.00KB AC #6

3ms/796.00KB AC #7

2ms/692.00KB AC #8

2ms/696.00KB AC #9

3ms/640.00KB AC #10

4ms/764.00KB AC #11

4ms/768.00KB AC #12

4ms/896.00KB AC #13

---

## 作者：Tiffany_Tendering (赞：0)

    本人蒟蒻  最后答案跑了42ms....
    看到有很多0ms大神 不知咋做的...
    
    但我还是很不要脸的来发题解？？？
    
    首先明确这是一个缩点
    1 凡是可以构成一个强连通分量的，那么这个强连通分量里点的的最小值就是我们需要的数据 因为其他所有比他花费大的与它在同一个强连通分量的点可以从这个点开始搜到 也就不需要了
    
    2 tarjan的时候要注意 我们只能找dfn == 0 并且 可以被贿赂的点
    
    3 在一个强连通分量里 如果某个点不能被贿赂 则不能用它更新答案
    
    4 强连通分量完成后 我们必须根据缩好的点构建新图 新图里一定对没有环的 但是新图里可能有链 我们最后的答案只要是新图里所有链的起点就行了（这里我的操作是入度为零的点）
    
   
   

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<stack>
#include<queue>
using namespace std;
const int maxn = 3005;
const int maxm = 8005;
int n,m,p,head[maxn],dfn[maxn],low[maxn],top,mon[maxn],indexx,belong[maxn],head2[maxn],top2,indegree[maxn];
bool instack[maxn],wou[maxn],can[maxn];
struct edge {
	int to,next,from;
}e[maxm],e2[maxm];
stack< int > s;
void add_edge(int u,int v) {
	e[++top].to = v;
	e[top].from = u;
	e[top].next = head[u] ;
	head[u] = top;
}
void add_edge2(int u,int v) {
	e2[++top2].to = v;
	e2[top2].from = u;
	e2[top2].next = head2[u] ;
	head2[u] = top2;
}

void tarjan(int u) {
	dfn[u] = low[u] = ++indexx;
	instack[u] = 1;
	s.push(u) ;
	for(int i = head[u]; i ;i = e[i].next) {
		if(!dfn[e[i].to]) {
			tarjan(e[i].to) ;
			low[u] = min(low[u] , low[e[i].to]) ;
		}
		else 
		  if(instack[e[i].to])
		    low[u] = min(low[u] , low[e[i].to]) ;
	}
	if(dfn[u] == low[u]) {
		while(s.top() != u) {
			int k = s.top() ; s.pop() ;
			instack[k] = 0;
			belong[k] = u;
			if(mon[u] && mon[k]) mon[u] = min(mon[u] , mon[k]) ;//还有这里 如果在这个强连通分量里某个点不能被贿赂 但是却可以被找到
			                                                    //则不能更新答案   mon[u] = min(mon[u],mon[k]) ; 这样就是错误的 
		}
		s.pop() ; instack[u] = 0;
		belong[u] = u;
	}
}

int main() {
	scanf("%d%d",&n,&p) ;
	for(int i = 1;i <= n ;++i) belong[i] = i;
	while(p--) {
		int x ,y; scanf("%d%d",&x,&y) ;
		wou[x] = 1; mon[x] = y;
	}
	scanf("%d",&m) ;
	for(int i = 1;i <= m ;++i) {
		int x,y; scanf("%d%d",&x,&y) ;
		add_edge(x , y) ; can[y] = 1;
	}
	for(int i = 1;i <= n ;++i) 
		if(!wou[i] && !can[i]) {
			printf("NO\n") ; printf("%d", i) ;
			return 0;
		} 
	printf("YES\n") ;	
	for(int i = 1;i <= n ;++i)
	  if(!dfn[i] && mon[i]) tarjan(i) ;   //缩点 别忘了我们只能搜可以被贿赂的点 
	for(int i = 1;i <= m ;++i) {   //构建新图 
		if(belong[e[i].from] == belong[e[i].to]) continue ;
		add_edge2(belong[e[i].from] , belong[e[i].to]) ;
		indegree[belong[e[i].to]]++;   //最后找的是入度为零的点 
	}
	long long ans = 0;
	for(int i = 1;i <= n ;++i) {
		if(belong[i] != i || indegree[i]) continue ;
		ans = (long long)(ans + mon[i]) ;
	}
	printf("%lld",ans) ;
	return 0;
}
```

---

## 作者：AcerMo (赞：0)

先tarjan缩点，然后对于每个有可能被收买的人，更新他所在的强连通分量的最小购买权值，因为购买一个人，这一个分量就都被买了，然后我们发现，若一个人不能被收买，只能是他是一个入度为零的点，我们判断这个强连通分量的入度是不是0，是0的话，若他还不能被收买，那就输出no，然后能被收买就把权值加上，最后输出就好
代码
```cpp
#include<cmath>
#include<queue>
#include<stack>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=10000;
stack<int>s;
vector<int>v[M];
vector<int>G[M];
int f[M],in[M];
int n,m,e,c[M];
int ind=0,ti=0,fa[M];
int dfn[M],low[M],vis[M];
void tarjan(int x)
{
	dfn[x]=low[x]=++ind;s.push(x);vis[x]=1;
	for (int i=0;i<v[x].size();i++)
	{
		int go=v[x][i];
		if (!dfn[go])
		{
			tarjan(go);
			low[x]=min(low[x],low[go]);
		}
		else if (vis[go])
			low[x]=min(low[x],dfn[go]);
	}
	if (low[x]==dfn[x])
	{
		int u=-1;ti++;
		while (u!=x)
		{
			u=s.top();s.pop();
			fa[u]=ti;vis[u]=0;
		}
	}
	return ;
}
void top()
{
	queue<int>q;int ans=0;
	for (int i=1;i<=ti;i++)
	{
		if (!in[i]) 
		{
			if (f[i]!=1e9) q.push(i),ans+=f[i];
			else 
			{
				puts("NO");for (int k=1;k<=n;k++)
				if (fa[k]==i) return (void)(cout<<k);
			}
		}
	}	
	puts("YES");cout<<ans;
	return ;
}
int main()
{
	fill(f,f+8500,1e9);
	scanf("%d%d",&n,&m);int a,b;
	for (int i=1;i<=m;i++)
		scanf("%d%d",&a,&b),c[a]=b;
	scanf("%d",&e);
	for (int i=1;i<=e;i++)
		scanf("%d%d",&a,&b),v[a].push_back(b);
	for (int i=1;i<=n;i++)
		if (!dfn[i]) tarjan(i);
	for (int i=1;i<=n;i++)
		if (c[i]) f[fa[i]]=min(f[fa[i]],c[i]);
	for (int i=1;i<=n;i++)
		for (int k=0;k<v[i].size();k++)
			if (fa[i]!=fa[v[i][k]]) 
				in[fa[v[i][k]]]++;
	top();
	return 0;
}
```

---

## 作者：bztMinamoto (赞：0)

这是一道tarjan的模板题。

如果不了解什么是tarjan和缩点，可以参考以下几篇blog，讲述的十分详细

tarjan：https://blog.csdn.net/justlovetao/article/details/6673602

缩点：https://blog.csdn.net/sdsy191553/article/details/79674201

在缩完点后的图上，每一个强连通分量中，我们只需要收买一个间谍，便可以将整个强连通分量的间谍都抓获。所以我们可以用一个数组，在tarjan过程中记录每一个强连通分量中可收买间谍的最小数额，每一个强连通分量只需要支付最小数额即可

同时，由于这是一个有向图，一个强连通分量的间谍被抓，那么它指向的所有其他强连通分量的间谍也都会被抓。因此，我们只考虑支付入度为0的强连通分量，即可保证其他所有都不会遗漏。所以在缩点时，记得及时记录每一个强连通分量的入度
```
#include<iostream>
#include<cstdio>
#include<cstring>
#define a(a,b,c) for(int a=b;a<=c;a++)
#define b(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
const int INF=0x3f3f3f3f,N=3050,M=16050;
int ver[M],Next[M],head[N],d[N];
int vc[M],nc[M],hc[M],dc[N],k[N],used[N];
int dfn[N],low[N],stack[N],v[N],c[N];
int n,m,tot,tc,t,num,cnt,top,ans;
bool flag=1;
inline void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
inline void add_c(int x,int y)
{
	vc[++tc]=y,nc[tc]=hc[x],hc[x]=tc;
}
void tarjan(int x)
{
	dfn[x]=low[x]=++num;
	stack[++top]=x,v[x]=1;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(v[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x])
	{
		cnt++;int y;
		do{
		y=stack[top--],v[y]=0;
		c[y]=cnt;
		dc[cnt]=min(dc[cnt],d[y]);
		}while(x!=y);
	}
}
int main()
{
	memset(d,0x3f,sizeof(d));
	memset(dc,0x3f,sizeof(dc));
	scanf("%d%d",&n,&t);
	a(i,0,t-1)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		d[x]=y;
	}
	scanf("%d",&m);
	a(i,0,m-1)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	a(i,1,n)
	if(!dfn[i]) tarjan(i);
	a(x,1,n)
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(c[x]!=c[y]) add_c(c[x],c[y]),k[c[y]]++;
	}
	a(i,1,n)
	if(!used[c[i]]&&!k[c[i]])
	{
		if(dc[c[i]]==INF) {
			flag=0;
			ans=i;
			break;
		}
		else{
			ans+=dc[c[i]];
			used[c[i]]=1;
		}
	}
	if(flag) printf("YES\n%d",ans);
	else printf("NO\n%d",ans);
	return 0;
}
```

---

## 作者：Invrise (赞：0)

做这个题断断续续做了一周多……我感觉人生无望了

看了看，基本都是Pascal的题解，那就发个C++的吧

这个题是对拍拍过的，所以代码后面附加了几组对拍时我WA的数据

核心思想就是Tarjan缩点，缩点前要跑一遍Check，检查是否每个节点都能够被访问到，这里DFS和BFS应该都行，我用的BFS

tarjan的同时更新强联通分量缩点的权值，就是该强联通分量中花钱最少的那个

有入度的缩点不需要收买，注意不要忘了单个且没有入度的点

代码写的很冗长，大家将就一下吧

```cpp
#include<bits/stdc++.h>//万能头文件
#define nomoney -1
#define INF 0x3f3f3f
using namespace std;
int n, p, r, ans = 0;
bool can = true, vis[3010] = { 0 };
struct point {
    int money;
    bool canfind;
    int to[3010];
    int top;
    point() {
        memset(this->to, 0, sizeof(this->to));
        this->top = 0;
        this->money = -1;
        this->canfind = false;
    }
}o[3010],so[3010];
bool check() {//BFS跑Check
    queue<int> q;
    for (int i = 1;i <= n;i++) {
        if (!vis[i] && o[i].money != nomoney)vis[i] = true;else continue;
        q.push(i);
        while (!q.empty()) {
            int temp = q.front();
            q.pop();
            for (int v = 1;v <= o[temp].top;v++) {
                if (vis[o[temp].to[v]] == false) {
                    vis[o[temp].to[v]] = true;
                    o[o[temp].to[v]].canfind = true;
                    q.push(o[temp].to[v]);
                }
            }
        }
    }
    memset(vis,0,sizeof(vis));
    for (int i = 1;i <= n;i++) {
        if (o[i].money == nomoney && o[i].canfind == false) {
            ans = i;
            can = false;
            return false;
        }
    }
    return true;
}
void input() {
    scanf("%d%d", &n, &p);
    for (int i = 1;i <= p;i++) {
        int tp, tm;
        scanf("%d%d", &tp, &tm);
        o[tp].money = tm;
    }
    scanf("%d", &r);
    for (int i = 1;i <= r;i++) {
        int ts, te;
        scanf("%d%d", &ts, &te);
        o[ts].top++;
        o[ts].to[o[ts].top] = te;
        if (o[ts].money != nomoney || o[ts].canfind == true)o[te].canfind = true;
    }
}
//=============Tarjan=============
int indexi = 0, dfn[3010], low[3010];
struct stack_II {
    int s[3010];
    int top;
    stack_II() {
        memset(this->s, 0, sizeof(this->s));
        top = 0;
    }
    void push(int x) {
        this->top++;
        this->s[top] = x;
    }
    int pop() {
        int temp = this->s[top];
        this->s[top] = 0;
        top--;
        return temp;
    }
}u;
int ufind(int x) {
    for (int i = 1;i <= u.top;i++) {
        if (u.s[i] == x)return i;
    }
    return 0;
}
void tarjan(int x) {
    vis[x] = true;
    dfn[x] = low[x] = ++indexi;
    u.push(x);
    for (int i = 1;i <= o[x].top;i++) {
        if (vis[o[x].to[i]] == false) {
            tarjan(o[x].to[i]);
            low[x] = min(low[x], low[o[x].to[i]]);
        }
        else if (ufind(o[x].to[i])) {
            low[x] = min(low[x], dfn[o[x].to[i]]);
        }
    }
    if (low[x] == dfn[x]) {
        int sum = INF, temp = x;
        do {
            temp = u.pop();
            for (int v = 1;v <= o[temp].top;v++) {
                if (low[x] != low[o[temp].to[v]]) {
                    so[low[o[temp].to[v]]].top++;
                    so[low[o[temp].to[v]]].to[so[low[o[temp].to[v]]].top] = low[x];
                }
            }
            if (o[temp].money != nomoney)sum = min(sum, o[temp].money);
        } while (x != temp);
        if (sum != INF)so[low[x]].money = sum;
    }
}
//=============Tarjan=============
void work() {
    for (int i = 1;i <= n;i++) {
        if (vis[i] == false && o[i].canfind == false)tarjan(i);
    }
    for (int i = 1;i <= n;i++) {
        if (vis[i] == false && o[i].money != nomoney)tarjan(i);
    }
    for (int i = 1;i <= indexi;i++) {
        if (so[i].top == 0 && so[i].money!=nomoney)ans += so[i].money;
    }
}
void output() {
    if (can == true) {
        printf("YES\n%d\n", ans);
    }
    else {
        printf("NO\n%d\n", ans);
    }
}
int main() {
    input();
    check() ? work(), output() : output();
#ifdef DEBUG_ONLY
    system("pause");
#endif // DEBUG_ONLY
    return 0;
}
/*
7
7
1 200
2 200
3 200
4 50
5 200
6 70
7 200
9
2 1
6 2
7 6
2 7
7 4
3 1
4 3
5 4
3 5
//=====
3
3
1 3
2 2
3 1
2
3 2
2 1
//=====
4
2
2 0
3 10
4
1 3
1 4
2 1
2 3
//right answer : YES 0
//=====
4
1
3 30
6
1 4
3 2
3 4
4 1
4 2
4 3
//right answer : YES 30
*/
```

---

## 作者：pupuvovovovovo (赞：0)

本人能写的Pascal代码不多了，这个题解当做纪念吧。

题目大意：给你一些点，再指定其中的一部分点并加上权值，问是否有一种方案，使得从指定的点中的某几个点开始对图遍历，能把整个图遍历完，并且权值最小。

对于打出NO的，其实很简单：以每个指定的点为起始点做遍历，每到一个新的点就把计数器+1，最后比一下计数器数值与n的大小即可，如果打出NO则再进行一次爆扫即可。

那么如何处理计数器大小等于n，即打出YES的呢？

退一步思考，如果这个有向图是个DAG，怎么办？

这里只需要把所有入度为0的点的权值相加即可。（这一切都建立在能控制所有间谍的基础上）

因为如果不选用入度为0的点，那这些点就是无人控制的。

选了这些点之后，图也一定能被他们及他们的子孙控制，就是说其他备选的点不用选了。

那么好吧，怎么把一个带环有向图变成DAG？

强连通分量的模型就出来了。

本人采用的是tarjan缩点。

代码如下：

var first,last,money,name,r,temp,fa,dfn,low:array [1..3000] of longint;

```cpp
money1:array [1..3000] of longint;
b,int:array [1..3000] of boolean;
next,en:array [1..8000] of longint;
n,m,n1,top,ans,i,j,x,y,index,all:longint;
procedure inn;
begin
  assign(input,'spy.in');reset(input);
  assign(output,'spy.out');rewrite(output);
end;
procedure ot;
begin
  close(input);
  close(output);
end;//不要管他们。
procedure add(x,y:longint);
begin
  inc(top);
  if first[x]=0 then first[x]:=top
  else next[last[x]]:=top;
  en[top]:=y;
  last[x]:=top;
end;//邻接表
procedure search(x:longint);
var i:longint;
begin
  if b[x] then exit;
  inc(top);
  i:=first[x];
  b[x]:=true;
  while i>0 do
  begin
    search(en[i]);
    i:=next[i];
  end;
end;//图的遍历模块
procedure push(x:longint);
begin
  inc(top);
  temp[top]:=x;
end;
function pop:longint;
begin
  dec(top);
  exit(temp[top+1]);
end;
function min(a,b:longint):longint;
begin
  if a<b then exit(a);
  exit(b);
end;
procedure scc(u:longint);
var i,x:longint;
begin
  push(u);
  int[u]:=true;
  b[u]:=true;
  inc(index);
  dfn[u]:=index;
  low[u]:=index;
  i:=first[u];
  while i>0 do
  begin
    if not b[en[i]] then
    begin
      scc(en[i]);
      low[u]:=min(low[u],low[en[i]]);
    end
    else
      if int[en[i]] then
      low[u]:=min(low[u],dfn[en[i]]);
    i:=next[i];
  end;
  if dfn[u]=low[u] then
  begin
    inc(ans);
    repeat
      x:=pop;
      fa[x]:=ans;
      int[x]:=false;
    until x=u;
  end;
end;//tarjan模块，不知道的话自己百度。
procedure endl;
var i:longint;
begin
  for i:=1 to n do
    if not b[i] then break;
  writeln('NO');
  write(i);
  ot;
  halt;
end;//打NO的
begin
  inn;
  read(n,n1);
  fillchar(money,sizeof(money),60);
  for i:=1 to n1 do
  begin
    read(name[i],x);
    money[name[i]]:=x;
  end;
  read(m);
  for i:=1 to m do
  begin
    read(x,y);
    add(x,y);
  end;
  top:=0;
  for i:=1 to n1 do
    search(name[i]);
  if top<n then endl;
  fillchar(b,sizeof(b),false);
  top:=0;
  for i:=1 to n do
    if not b[i] then scc(i);//tarjan
  fillchar(money1,sizeof(money1),127);
  for i:=1 to n do
  begin
    money1[fa[i]]:=min(money1[fa[i]],money[i]);
    j:=first[i];
    while j>0 do
    begin
      if fa[en[j]]<>fa[i] then inc(r[fa[en[j]]]);
      j:=next[j];
    end;
  end;//统计入度与fa点的权值。一个强连通分量的权值是这个分量内各个点权值的最小值（因为其中任何一个点都能控制分量中的其余所有点）
  for i:=1 to ans do
    if r[i]=0 then all:=all+money1[i];
  writeln('YES');
  write(all);
  ot;
end.
```

---

## 作者：迷失之夜 (赞：0)

这道题先来判断是否有解：

因为我们只能从可以被贿赂的间谍出发：

我们将可以被贿赂的间谍都入队，做一次宽搜，如果能遍历完整张图(这也是为何这道题会在图的遍历里的缘故了)，那就说明有解，不能遍历完那就是无解了、、我们先写个宽搜，宽搜返回值分两类：为零，代表有解，不为零，则返回一个不能被控制的间谍编号：

```cpp
int BFS ()
{
    queue <int> q;
    for (int i = 1;i<=P;i++)
    {
        q.push (peo[i]);//能被贿赂的间谍
        dfs [peo[i]] = 1;//被访问，也就是能到达
    }
    while (!q.empty())
    {
        int now = q.front ();q.pop();
        for (int nt = head[now];nt;nt = e[nt].next)//边表
        {
            int to = e[nt].to;
            if (dfs[to])continue;
            dfs [to] = 1;
            q.push (to);
        }
    }
    for(int i=1;i<=N;i++)if(!dfs[i])return i;//总共有N个间谍
    return 0;
}
```
如果有解，我们可以用强连通缩点来解决这个问题、、

缩成点后，我们利用缩成的点建图，很容易想到，只需要将所有入度为0的点(缩点)里的某个间谍买通即可(间谍当然是买通最便宜的啊)

上代码：

```cpp
#include <iostream>
#include <queue>
#include <string.h>
using namespace std;
struct edge
{
    int to,next;
}e[8080];
int head [3030],cnt;
int N,P,R;
int peo [8080];
int cost [8080];
void add (int u,int v)
{
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}
int dfs [3030],low[3030],vis[3030],sta[3030],top,ind;
int blkuai [3030],kc[3030],col;
int BFS ()
{
    queue <int> q;
    for (int i = 1;i<=P;i++)
    {
        q.push (peo[i]);
        dfs [peo[i]] = 1;
    }
    while (!q.empty())
    {
        int now = q.front ();q.pop();
        for (int nt = head[now];nt;nt = e[nt].next)
        {
            int to = e[nt].to;
            if (dfs[to])continue;
            dfs [to] = 1;
            q.push (to);
        }
    }
    for(int i=1;i<=N;i++)if(!dfs[i])return i;
    return 0;
}
void tarjan (int id)//这个是模板了、、
{
    dfs[id] = low[id] = ++ind;
    sta[++top] = id;
    vis[id] = 1;
    for (int nt = head [id];nt;nt = e[nt].next)
    {
        int to = e[nt].to;
        if (!dfs[to])
        {
            tarjan (to);
            low[id] = min (low[id],low[to]);
        }
        else if (vis[to])
        {
            low [id] = min (low[id],dfs [to]);
        }
    }
    int kk;
    if (dfs[id] == low[id])
    {
        col++;
        do
        {
            kk = sta [top--];
            blkuai [kk] = col;//记录改点属于某个强连通
            vis[kk] = 0;
        }while (kk!=id);
    }
    return;
}
int in[3030];//某点入度
void solve ()
{
    memset (dfs,0,sizeof (dfs));
    for (int i = 1;i<=N;i++)
    {
        if (!dfs[i])tarjan (i);//对全图都跑一遍
    }
    for (int i = 1;i<=N;i++)
    {
        for (int nt = head[i];nt;nt = e[nt].next)
        {
            int to = e[nt].to;
            if (blkuai[i] != blkuai[to])
            {
                in[blkuai[to]]++;//求入度
            }
        }
    }
    memset (kc,11,sizeof (kc));
    for (int i = 1;i<=P;i++)
    {
        kc[blkuai[peo[i]]] = min (kc[blkuai[peo[i]]],cost[i]);//求某个强连通分量缩成点后的最小花费
    }
    int sum=0;
    for (int i = 1;i<=col;i++)
    {
        if (in[i] == 0)//只需买通入度为零的点中的某个间谍
        {
            sum += kc[i];
        }
    }
    cout <<"YES"<<endl;
    cout <<sum<<endl;
    return;
}
int main ()
{
    ios::sync_with_stdio(false);//加快输入输出速度..
    cin >>N>>P;
    for (int i = 1;i<=P;i++)
        cin >>peo[i]>>cost[i];
    cin >>R;
    int u,v;
    for (int i = 1;i<=R;i++)
    {
        cin >>u>>v;
        add (u,v);
    }
    int ans = BFS();
    if (ans)
    {
        cout <<"NO"<<endl<<ans<<endl;
        return 0;
    }
    solve();
    return 0;
}
```

---

## 作者：Ghost_lzy (赞：0)

强连通一发+拓扑排序（DP），要记载一个分量内点权最小的那个，然后top\_sort(),在拓扑的过程中DP求出来就是了，主要考察代码熟练度

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>V[3005];
vector<int>rV[3005];
vector<int>e;
bool vis[3005];
int val[3005]={0};
int kind[3005];
vector<int>scc[3005];
vector<int>tj[100005];
int scc_val[3005];
int rd[3005];
bool cat[3005];
int n,p,r,cmp=0;
int ans=0;
void dfs(int v)
{
    vis[v]=1;
    for(int i=V[v].size()-1;i>=0;i--)
    {
        int k=V[v][i];
        if(!vis[k])
        {
            dfs(k);
        }
    }
    e.push_back(v);
}
void rdfs(int v)
{
    vis[v]=1;
    kind[v]=cmp;
    for(int i=rV[v].size()-1;i>=0;i--)
    {
        int k=rV[v][i];
        if(!vis[k])
        {
            rdfs(k);
        }
    }
    scc[cmp].push_back(v);
}
void find(int i)
{
    for(int j=scc[i].size()-1;j>=0;j--)
    {
        int k=scc[i][j];scc_val[i]=min(scc_val[i],val[k]);
        for(int v=V[k].size()-1;v>=0;v--)
        {
            int l=V[k][v];
            if(kind[k]!=kind[l])
            {
                tj[i].push_back(kind[l]);
                rd[kind[l]]++;
            }
        }
    }
}
void read() 
{
    scanf("%d",&n);
    scanf("%d",&p);
    memset(val,0x7f,sizeof(val));
    memset(rd,0,sizeof(rd));
    memset(scc_val,127/3,sizeof(scc_val));
    for(int i=1;i<=p;i++)
    {  int a,b;
        scanf("%d%d",&a,&b);
        val[a]=b;
    }
    scanf("%d",&r);
    for(int i=1;i<=r;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        V[a].push_back(b);
        rV[b].push_back(a);
    }
}
void two_dfs()
{
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        dfs(i);
    }
    memset(vis,false,sizeof(vis));
    for(int w=e.size()-1;w>=0;w--)
    {
        int i=e[w];
        if(!vis[i])
        {
            cmp++;
            rdfs(i);
        }
    }
}
void build()
{
    for(int i=1;i<=cmp;i++)
    {
        find(i);
    }
}
bool top_sort()
{
    stack<int>s;
    for(int i=1;i<=cmp;i++)
    {
        if(!rd[i])
        {
            if(scc_val[i]>=scc_val[3001]) continue;
            else  
            {
             s.push(i);         
             ans+=scc_val[i];
            }
        }
    }
    while(!s.empty())
    {
        int p=s.top();s.pop();
        cat[p]=true;
        for(int i=tj[p].size()-1;i>=0;i--)
        {  int q=tj[p][i];
            rd[q]--;
            if(!rd[q])
            {
                s.push(q);
            }
        }
    }
}
void outit()
{
    int thm=999999;
    bool ok=true;
    for(int i=1;i<=cmp;i++)
    {
        if(!cat[i])
        {
            for(int j=scc[i].size()-1;j>=0;j--)
            {
                int k=scc[i][j];
                if(val[k]>=val[3001])
                thm=min(thm,k);
                ok=false;
            }
        }
    }
    if(ok)
    {
        printf("YES\n");
        cout<<ans<<endl;
    }
    else{
        printf("NO\n");
        printf("%d\n",thm);
    }
}
int main()
{
    read();
    two_dfs();
    build();
    top_sort();
    outit();
}
```

---

## 作者：Sci_M3 (赞：0)

首先BFS求出是否有点不能被访问 若有则显然这个间谍不能被控制

然后就是强连通分量问题 对于一个强连通分量我们贪心的选取其中花费最小的点统计答案

最终答案为入度为0的点的花费和

不得不说代码量还挺大...

有一点要注意 边的数量应该是n << 1而不是和n同样大小，60分的大多数是边表没开够吧...

边表写法为链式前向星 相比vector有肉眼可见的常数优势..


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
#define inf 0x3f3f3f3f
using namespace std;

const int MAXN = 3000 + 10;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}

struct node { int to, next; }edge[MAXN << 1];
int head[MAXN], n, r, p;
int money[MAXN], ans, cnt;
bool vis[MAXN];
queue<int> q;
stack<int> S;

inline void addedge(int u, int v) {
    edge[++cnt].to = v; edge[cnt].next = head[u];
    head[u] = cnt;
}

void bfs() {
    while(!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = true;
        for(int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if(!vis[v]) {
                vis[v] = true;
                q.push(v);
            }
        }
    }
    for(int i = 1; i <= n; ++i) if(!vis[i]) {
        puts("NO"); printf("%d\n", i);
        exit(0);
    }
}

int pre[MAXN], lowlink[MAXN], sccno[MAXN];
int scc_cnt, dfs_clock, in0[MAXN], best[MAXN];

void dfs(int u) {
    pre[u] = lowlink[u] = ++dfs_clock;
    S.push(u);
    for(int i = head[u]; i; i = edge[i].next) {
        int v = edge[i].to;
        if(!pre[v]) {
            dfs(v);
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if(!sccno[v]) {
            lowlink[u] = min(lowlink[u], pre[v]);
        }
    }
    if(lowlink[u] == pre[u]) {
        scc_cnt++;
        if(!best[scc_cnt]) best[scc_cnt] = inf;
        for(;;) {
            int x = S.top(); S.pop();
            best[scc_cnt] = min(best[scc_cnt], money[x]);
            sccno[x] = scc_cnt;
            if(x == u) break;
        }
    }
}

void tarjan() { 
    dfs_clock = scc_cnt = 0;
    memset(sccno, 0, sizeof(sccno));
    memset(pre, 0, sizeof(pre));
    memset(best, 0, sizeof(best));
    for(int i = 1; i <= n; ++i) 
        if(!pre[i]) dfs(i); 
}

void work() {
    for(int i = 1; i <= scc_cnt; ++i) in0[i] = 1;
    for(int i = 1; i <= n; ++i)
        for(int j = head[i]; j; j = edge[j].next) {
            int v = edge[j].to;
            if(sccno[i] != sccno[v]) in0[sccno[v]] = 0;
        }
    for(int i = 1; i <= scc_cnt; ++i)
        if(in0[i]) ans += best[i];
}

int main() {
    n = read(), p = read();
    memset(money, inf, sizeof(money));
    for(int i = 1, x, y; i <= p; ++i) {
        x = read(), y = read();
        money[x] = y; q.push(x);
    }
    r = read();
    for(int i = 1, u, v; i <= r; ++i) {
        u = read(), v = read();
        addedge(u, v);
    }
    bfs(); tarjan(); work();
    puts("YES"); printf("%d\n", ans);
    return 0;
}
```

---

## 作者：crowworks695 (赞：0)

思路楼上前辈们已经说的很清楚了，这里来补充一种不用BFS直接求强连通的写法，主要思路就是在tarjan中统计一个强连通分量最小费用的同时统计出该强连通分量中编号最小的点，当情况为NO时只要输出所有不能购买且入度为0的强连通分量中编号最小的点的最小值就行了~

```cpp

#include <cstdio>
#include <cstring>
#include <vector>
#include <stack>

using namespace std;

int n,p;

int buy[3001],pre[3001]={0},lowlink[3001],sccno[3001]={0},cost[3001]={0};
int sccrd[3001]={0},scclow[3001];

vector <int> e[3001];

int dfs_clock=0,scc_cnt=0;

stack <int> s;

void dfs(int x)
{
    pre[x]=lowlink[x]=++dfs_clock;//tarjan模板，不叨叨。。
    s.push(x);
    for(int i=0;i<e[x].size();i++)
    {
        int u=e[x][i];
        if(!pre[u])
        {
            dfs(u);
            lowlink[x]=min(lowlink[x],lowlink[u]);
        }
        else if(!sccno[u])
        {
            lowlink[x]=min(lowlink[x],pre[u]);
        } 
    }
    if(lowlink[x]==pre[x])
    {
        ++scc_cnt;
        while(1)
        {
            int t=s.top();s.pop();
            sccno[t]=scc_cnt;
            if(buy[t]!=-1)cost[scc_cnt]=min(cost[scc_cnt],buy[t]);//这里统计该强连通分量的最小购买费用
            scclow[scc_cnt]=min(scclow[scc_cnt],t);//这里统计该强连通分量中编号最小的点
            if(t==x)break;
        }
    }
}

int main()
{
    memset(buy,-1,sizeof(buy));
    memset(cost,0x7f,sizeof(cost));
    memset(scclow,0x7f,sizeof(scclow));
    int pd=cost[0];
    scanf("%d%d",&n,&p);
    for(int i=1;i<=p;i++)
    {
        int t1,t2;
        scanf("%d%d",&t1,&t2);
        buy[t1]=t2;
    }
    int r;
    scanf("%d",&r);
    for(int i=1;i<=r;i++)
    {
        int t1,t2;
        scanf("%d%d",&t1,&t2);
        e[t1].push_back(t2);
    }
    for(int i=1;i<=n;i++)
    {
        if(!pre[i])
        {
            dfs(i);
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<e[i].size();j++)
        {
            if(sccno[i]!=sccno[e[i][j]])
            {
                sccrd[sccno[e[i][j]]]++;
            }
        }
    }
    int ans=0,b=1,ans2=pd;
    for(int i=1;i<=scc_cnt;i++)
    {
        if(!sccrd[i])
        {
            if(cost[i]!=pd)ans+=cost[i];//显然当某个强连通分量的最小购买费用等于初始值时，该强连通分量无法被购买
            else
            {
                b=0;
                ans2=min(ans2,scclow[i]);
            }
        }
    }
    if(b)printf("YES\n%d",ans);
    else printf("NO\n%d",ans2);
    return 0;
}

```

---

## 作者：intruder (赞：0)

一道连通分量 为了好写 我们先bfs一次判断不可能的情况 直接输出 然后tarjan缩点 scc\_cnt代表缩点后的编号 然后通过查找所有入度为0的点（代表原来的一段连通分量） 这些点必须贿赂 记起来就是最终答案了 看下面全是p党的 我来填C++

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
#include<cstdlib>
#include<stack>
#define maxn 3002
using namespace std;
int N,M,R,money[maxn];
vector<int >son[maxn];
queue<int>q;
stack<int>Stack;
int bfs_vis[maxn];
int ans;
void bfs(){
    while(!q.empty()){
        int x=q.front();
        q.pop();
        bfs_vis[x]=1;
        for(int i=0;i<son[x].size();i++){
            int y=son[x][i];
            if(!bfs_vis[y]){
                bfs_vis[y]=1;
                q.push(y);
            }
        }
    }
    for(int i=1;i<=N;i++){
        if(!bfs_vis[i]){
            printf("NO\n");
            printf("%d",i);
            exit(0);
        }
    }
}
int dfn[maxn],low[maxn],TIME,best[maxn],sccno[maxn],scc_cnt;
void tarjan(int u){
    dfn[u]=low[u]=++TIME;
    Stack.push(u);
    for(int i=0;i<son[u].size();i++){
        int y=son[u][i];
        if(!dfn[y]){
            tarjan(y);
            low[u]=min(low[u],low[y]);
        }
        else if(!sccno[y])low[u]=min(low[u],dfn[y]);
    }
    if(low[u]==dfn[u]){
        scc_cnt++;
        if(!best[scc_cnt])best[scc_cnt]=1e9;
        int y;
        for(;;){
            int v=Stack.top();Stack.pop();
            best[scc_cnt]=min(best[scc_cnt],money[v]);
            sccno[v]=scc_cnt;
            if(v==u)break;
        }
    }
}
int in0[maxn];
void work(){
    for(int i=1;i<=scc_cnt;i++)in0[i]=1;
    for(int i=1;i<=N;i++){
        for(int j=0;j<son[i].size();j++){
            int v=son[i][j];
            if(sccno[i]!=sccno[v])in0[sccno[v]]=0;
        }
    }
    for(int i=1;i<=scc_cnt;i++){
        if(in0[i])ans+=best[i];
    }
}
int used_vis[maxn];
int main(){
    scanf("%d%d",&N,&M);
    for(int i=1;i<=N;i++)money[i]=1e9;
    for(int i=1;i<=M;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        money[a]=b;
        q.push(a);
    }
    scanf("%d",&R);
    for(int i=1;i<=R;i++){
        int a,b;
        scanf("%d%d",&a,&b); 
        son[a].push_back(b);
    }
    bfs();
    for(int i=1;i<=N;i++){
        if(!dfn[i])tarjan(i);
    }
    work();
    printf("YES\n");
    printf("%d",ans);
    return 0;
}
```

---

## 作者：hibiki (赞：0)

首先核心算法毫无疑问是tarjan，跑tarjan的时候顺便更新整个强联通分量的价值。

查找是否有解不需要遍历全图，只要在建图的时候统计原图的入度，如果有一个点入度为0并且改点的价值也为0（也就是说既不会被其他人揭露也不受贿赂），那么这张图无解（因为永远无法得到这个人的情报）

之后搜索的时候只要找到一个入度为0的点开始搜索。因为入度为0的点一定是有价值的点，否则这张图无解。

这种算法有一个缺点，就是如果没有其他边指向一个强联通分量，则因为这个强联通分量中没有任何一个点的入度为0，所以不会计算，需要在结尾特殊处理

可以证明，所有入度为0且有价值的点的价值都是必须的。

```pascal
Const
    MAX=3000;
    MAXE=8000;
Var
    n,p,i,j,t,cnt,tot,a,b,r,top,time,ans:longint;
    flag,flag2:array[1..MAX] of integer;
    list,toit,next,low,dfn,stack,refer,v,newv,indegree,newindegree:array[1..MAXE] of longint;
Function min(a,b:longint):longint;
    begin
        if a<b then exit(a);
        exit(b);
    end;
Procedure add(u,v1:longint);
    begin
        inc(cnt);
        toit[cnt]:=v1;
        inc(indegree[v1]); 
        next[cnt]:=list[u];
        list[u]:=cnt;
    end;
Procedure dfs(now:longint);
    var
        w:longint;
    begin
        flag[now]:=1;
        inc(top);
        stack[top]:=now;
        inc(time);
        dfn[now]:=time;
        low[now]:=time;
        w:=list[now];
        while w<>0 do begin
            if flag[toit[w]]=0 then dfs(toit[w]);
            if flag[toit[w]]<2 then low[now]:=min(low[now],low[toit[w]]);
            w:=next[w];
        end;
        if dfn[now]=low[now] then begin
            inc(tot);
            while stack[top+1]<>now do begin
                refer[stack[top]]:=tot;
                newindegree[tot]:=newindegree[tot]+indegree[stack[top]];
                if (newv[tot]=0) and (v[stack[top]]<>0) then newv[tot]:=v[stack[top]] else
                    if v[stack[top]]<>0 then newv[tot]:=min(newv[tot],v[stack[top]]);
                flag[stack[top]]:=2;
                dec(top);
            end;
        end;
    end;
Procedure dfs2(now:longint);
    var
        w:longint;
    begin
        flag[refer[now]]:=1; //标记当前所访问的点所处的强联通分量
        flag2[now]:=1; //标记当前点本身
        w:=list[now];
        while w<>0 do begin
            if flag2[toit[w]]=0 then dfs2(toit[w]); //如果指向的点没有被拓展过则继续拓展
            w:=next[w];
        end;
    end;
Begin
    readln(n);
    readln(p);
    for i:=1 to p do begin
        read(t);
        readln(v[t]); //读入价值
    end;
    readln(r);
    for i:=1 to r do begin
        readln(a,b);
        add(a,b);
    end;
    for i:=1 to n do
        if (v[i]=0) and (indegree[i]=0) then begin //如果有一个点不具有价值并且入度为0则该点无法被访问
            writeln('NO');
            writeln(i);
            halt;
        end;
    fillchar(flag,sizeof(flag),0);
    for i:=1 to n do
        if dfn[i]=0 then dfs(i);
    fillchar(flag,sizeof(flag),0);
    fillchar(flag2,sizeof(flag2),0);
    for i:=1 to n do
        if (indegree[i]=0) then begin //从有价值(可以被贿赂)且入度为0的点(不能通过其他人获得这个人的情报)时才从这个人开始搜索
            if flag[refer[i]]=0 then ans:=ans+newv[refer[i]]; //只有这个点所在的强联通分量没有被访问过时才更新答案
            dfs2(i); //从这个点开始搜索
        end;
    for i:=1 to n do
        if (flag2[i]=0) and (newv[refer[i]]<>0) then begin //找到没有访问过的点
                dfs2(i); //发现这个点所在的强联通分量没有被访问过，但是具有价值，说明该强联通分量未被搜索过
                ans:=ans+newv[refer[i]];
        end;
    writeln('YES');
    writeln(ans);
End. 【code】
```

---


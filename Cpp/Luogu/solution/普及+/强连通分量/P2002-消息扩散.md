# 消息扩散

## 题目背景

本场比赛第一题，给个简单的吧，这 100 分先拿着。

## 题目描述

有 $n$ 个城市，中间有单向道路连接，消息会沿着道路扩散，现在给出 $n$ 个城市及其之间的道路，问至少需要在几个城市发布消息才能让这所有 $n$ 个城市都得到消息。

## 说明/提示

**【样例解释 #1】**

样例中在 $4, 5$ 号城市中发布消息。

**【数据范围】**

对于 $20 \%$ 的数据，$n \le 200$；  
对于 $40 \%$ 的数据，$n \le 2000$；  
对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$1 \le m \le 5 \times {10}^5$。

## 样例 #1

### 输入

```
5 4
1 2
2 1
2 3
5 1
```

### 输出

```
2
```

# 题解

## 作者：唔啊唔 (赞：29)

题解数目好像不多，那么就来写一篇题解吧，顺便来入门一下下午要学的缩点

这道题目和[[HAOI2006]受欢迎的牛](https://www.luogu.org/problem/P2341)很像，我仅仅只是在那个代码上做了小小的修改就过了

如果想要学习tarjan算法的基本思路的话，大家可以看看[这篇文章](https://blog.csdn.net/qq_34374664/article/details/77488976)，

但是我在代码中也会对tarjan的基本思路稍微讲一讲，可能没那么详细

那我就直接在代码上解释了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int num,head[100010],dfn[100010],low[100010],cnt,vis[100010];
/*
dfn[]:时间戳，表示他在dfs(tarjan)中是第几个被搜到的
low[]:以该节点为根的子树中所有起始于该子树中的子孙节点的边所连到的点中dfn的最小值
vis[]:表示该节点是否入栈 
*/
int sum[100010],bj[100010],tot,qwq[100010];
/*
sum[]:该强联通分量中有多少个数(本题用不上，但受欢迎的牛会用到) 
bj[]:表示该节点处于哪一个强连通分量 
qwq[]:表示该强连通分量是否被其他的强连通分量所连起来 
*/
struct Edge{
	int to,next;
}edge[500010];
inline void add(int from,int to){
	num++;
	edge[num].to=to;
	edge[num].next=head[from];
	head[from]=num;
}
//以上为前向星存边 
stack<int>s;	//建栈(也可手写) 
inline void tarjan(int x){
	cnt++;
	dfn[x]=low[x]=cnt;
	s.push(x);
	vis[x]=1;
	//所有点被遍历到时的初始化 
	for(register int i=head[x];i;i=edge[i].next){
		int y=edge[i].to;
		if(dfn[y]==0){	//如果该节点未被访问过 
			tarjan(y);	//则向下遍历 
			low[x]=min(low[x],low[y]);
			//y为x的子节点,所以可以取x与y中low更小的值 
		}
		else if(vis[y]==1){
			low[x]=min(low[x],dfn[y]);
			//y在栈中因此y一定是x的祖先节点
			//low表示的是起始于该子树中的子孙节点的边所连到的点中dfn的最小值
			//所以我们和y比较的是y的dfn值，而不是low
		}
	}
	if(low[x]==dfn[x]){
//当该点的low等于自己本身说明自己就是以x为根节点的子树能到达的dfn最小的节点(在整棵树中能到达的最上方的点) 
		int z;
		tot++;	//tot表示有几个强连通分量 
		while(s.top()!=x){	//把整个强连通分量出栈 
			sum[tot]++;	
			z=s.top();	//取出栈顶 
			vis[z]=0;	//标志其不在栈中 
			bj[z]=tot;	//标志其在哪一个强连通分量 
			s.pop();	//出栈 
		}
		sum[tot]++;
		z=s.top();
		vis[z]=0;
		bj[z]=tot;
		s.pop();
	}
	return;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	int x,y;
	for(register int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(register int i=1;i<=n;i++){
		if(dfn[i]==0)
			tarjan(i);
	}
	for(register int i=1;i<=n;i++){		//遍历每一条边 
		for(register int j=head[i];j;j=edge[j].next){
			int y=edge[j].to;	
			if(bj[i]!=bj[y]){
//如果有两个强连通分量之间有边，被连的那个强连通分量就不需要再在强连通分量中扩散消息了
//只需要在那个连它的强连通分量中扩散消息，消息就会扩散到它那里来 
				qwq[bj[y]]=1;//标记此强连通分量不需要扩散消息 
			}
		}
	}
	int ans=0;
	for(register int i=1;i<=tot;i++){
		if(qwq[i]==0){
			ans++;
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Amessal (赞：14)

首先注意到题目中说有重边和自环，我们在见图的时候要先去掉自环，就是建边的时候判一下起点和终点是否相同，不同才建；

然后就是用Trajan求强连通分量，缩点，其实并不需要重新构图，只需要把每个强连通的入度统计出来，答案就是入度为0的个数

```cpp
#include<cstdio>
#include<algorithm>
#include<iomanip>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<ctime>
#include<cctype>
using namespace std;
const int N = 100005;
const int M = 500005;
int x,y,n,m,pointnum,tot,Ind,top,ans;
int first[N],nxt[M],to[M];
int low[N],dfn[N],stack[N];
int belong[N],ru[N];
bool in[N];
inline int Readint(){
    int i=0;char c;
    for(c=getchar();!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar()) i=(i<<1)+(i<<3)+c-'0';
    return i;
}

inline void add(int x,int y){
    nxt[++tot]=first[x];
    first[x]=tot;
    to[tot]=y;
}

inline void dfs(int x){
    low[x]=dfn[x]=++Ind;
    stack[++top]=x;in[x]=true;
    for(int i=first[x];i;i=nxt[i]){
        int v=to[i];
        if(!dfn[v]){
            dfs(v);
            low[x]=min(low[x],low[v]);
        }
        else if(in[v]) low[x]=min(low[x],dfn[v]);
    }
    if(low[x]==dfn[x]){
        ++pointnum;
        int j=-1;
        while(j!=x){
            j=stack[top--];
            belong[j]=pointnum;
            in[j]=false;
        }
    }
}

int main(){
//    freopen("lx.in","r",stdin);
    
    n=Readint(),m=Readint();
    for(int i=1;i<=m;i++){
        x=Readint(),y=Readint();
        if(x!=y) add(x,y);
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i);
    for(int i=1;i<=n;i++)
      for(int e=first[i];e;e=nxt[e])
        if(belong[i]!=belong[to[e]])
          ru[belong[to[e]]]++;
    for(int i=1;i<=pointnum;i++)
      if(!ru[i]) ans++;
    cout<<ans<<endl;
    return 0;
}
```cpp

---

## 作者：Waddles (赞：7)

题解区好像没有我这个做法的，可能太暴力了qwq

tarjan+拓扑+DFS

以下图为例

![](https://cdn.luogu.com.cn/upload/pic/67191.png)

先把强联通分量缩成一个点

![](https://cdn.luogu.com.cn/upload/pic/67192.png)

然后拓扑排序一下

![](https://cdn.luogu.com.cn/upload/pic/67193.png)

按照拓扑序DFS遍历每个未被标记的点即可

第一次遍历:

![](https://cdn.luogu.com.cn/upload/pic/67194.png)

第二次遍历:

![](https://cdn.luogu.com.cn/upload/pic/67197.png)

code:

```
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
template<class Read>void in(Read &x){
    x=0;
    int f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        f|=(ch=='-');
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x=f?-x:x;
    return;
}
struct Node{
    int to;
    int next;
}a[500005],q[500005];
queue<int>Q;
int n,m,top,tt,tot,ans,sum,kkk;
int vis[100005],he[100005],ru[100005],bi[100005];
int head[100005],v[100005],low[100005],dfn[100005],b[100005];
int l[100005],kk[100005];
vector<int>p[100005];
void add2(int x,int y){
    a[++top].next=head[x];
    a[top].to=y;
    head[x]=top;
}
void add(int x,int y){
    q[++top].next=he[x];
    q[top].to=y;
    he[x]=top;
}
void tarjan(int u){//tarjan缩点(模板)
	dfn[u]=low[u]=++top;
	v[u]=1;
	l[++kkk]=u;
	for(int i=he[u];i;i=q[i].next){
        int k=q[i].to;
		if(!dfn[k]){
			tarjan(k);
			low[u]=min(low[u],low[k]);
		}
		else if(v[k])low[u]=min(low[u],dfn[k]);
	}
	if(dfn[u]==low[u]){//找到一个强联通分量
        int x=0,s=kkk;
        tot++;
		while(x!=u){
			x=l[s];
            s--;
            vis[x]=tot;//染成一个色
            kk[tot]++;
            p[tot].push_back(x);
			v[x]=0;
		}
        kkk=s;
	}
}
void dfs(int x){
    for(int i=head[x];i;i=a[i].next){
        int qqq=a[i].to;
        if(!v[qqq]){
            v[qqq]=1;
            dfs(qqq);
        }
    }
}
int main(){
    in(n);in(m);
    for(int i=1;i<=m;i++){
        int x,y;
        in(x);in(y);
        add(x,y);//建边
    }
    top=0;
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);//缩点
    top=0;
    for(int i=1;i<=tot;i++){//缩点后重新构边
        memset(v,0,sizeof(v));
        for(int j=0;j<p[i].size();j++){
            int h=p[i][j];
            for(int k=he[h];k;k=q[k].next){
                int g=q[k].to;
                if(v[vis[g]]||vis[g]==i)continue;
                add2(i,vis[g]);//重新建边
                ru[vis[g]]++;//统计入度
                v[vis[g]]=1;
            }
        }
    }
    n=tot;
    for(int i=1;i<=n;i++)if(ru[i]==0)Q.push(i),bi[++bi[0]]=i;
    while(!Q.empty()){//拓扑排序
        int qq=Q.front();
        Q.pop();
        for(int i=head[qq];i;i=a[i].next){
            int qqq=a[i].to;
            ru[qqq]--;
            if(ru[qqq]==0){
                Q.push(qqq);
                bi[++bi[0]]=qqq;
            }
        }
    }
    //bi为理好的拓扑序
    memset(v,0,sizeof(v));
    for(int i=1;i<=n;i++){
        if(!v[bi[i]]){//依次遍历未访问的点即可
            v[bi[i]]=1;
            dfs(bi[i]);
            ans++;
        }
    }
    printf("%d\n",ans);
	return 0;
}

```

---

## 作者：猪小屁 (赞：7)

##### 看见大佬们全写的tarjan

## 我来补充一下kosaraju的做法吧！


------------（进入正题）


 _其实kosaraju的复杂度和空间都要费的多一些_ 

##### ~~但本蒟蒻学oi的时候就是学的kosaraju，所以就一直用这个啦~~

本题重点：

### 1. 有自环，~~tarjan好像不能跑自环~~？但我保证 _kosaraju可以跑自环_ ！！！
2. 缩点，然后找入度为0的强连通分量个数就好了。

对此，我们需要用mp1和mp2数组记录每条边连接的点

最后遍历一遍所有的边

### 假如这两个点不在同一个强连通分量里，入度++
上代码啦：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
const int maxx=5e5+5;
vector<int>g[maxn],g2[maxn],st;
bool vis[maxn];
int k,cmp[maxn],mp1[maxx],mp2[maxx],cnt,du[maxn];
int n,m;
void dfs(int x){
	vis[x]=1;
	for(int i=0;i<g[x].size();++i){
		int s=g[x][i];
		if(!vis[s]){
			dfs(s);
		}
	}
	st.push_back(x);
}
void dfs2(int x,int k){
	cmp[x]=k;
	vis[x]=1;
	for(int i=0;i<g2[x].size();++i){
		int s=g2[x][i];
		if(!vis[s]){
			dfs2(s,k);
		}
	}
}
void init(){
	for(int i=1;i<=n;i++){
		if(!vis[i]) dfs(i);
	}
	for(int i=1;i<=n;i++){
		vis[i]=0;
	}
	for(int i=st.size()-1;i>=0;i--){
		if(!vis[st[i]]){
			k++;
			dfs2(st[i],k);
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		int p1,p2;
		scanf("%d%d",&p1,&p2);
		cnt++;
		mp1[cnt]=p1;mp2[cnt]=p2;
		g[p1].push_back(p2);
		g2[p2].push_back(p1);
	}
	init();
	for(int i=1;i<=cnt;i++){
		int p1=mp1[i],p2=mp2[i];
		if(cmp[p1]!=cmp[p2]){
		//	g[cmp[p1]].push_back(cmp[p2]);
			du[cmp[p2]]++;
		}
	}
	int ans=0;
	for(int i=1;i<=k;i++){
		if(!du[i]) ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：翠竹叶飞 (赞：7)

缩点的模板题

1.scc求强连通分量 （1 dfs求出一个序列 2 逆序在反向图上搜，可到的点与其在1个强连通分量上）

2.缩点，构造反图，同时记录点的入度

3.统计入度为0的点


```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#define rep(i,a,b) for (int i=(a); i<=(b); i++)
#define MAXN 100005
#define MAXM 500005
using namespace std;
int n,m;
int head1[MAXN],head2[MAXN];
struct Edge
{
    int to,nxt;
} edge1[MAXM],edge2[MAXM];
int num1,num2;
int vs[MAXN],size;
int cmp[MAXN],cnt;
bool used[MAXN];
vector<int> G[MAXN]; //缩点后的图 
int in[MAXN]; //统计入度 
void add(Edge edge[], int head[], int &num, int u, int v) //555555555555555555555555555555
{
    edge[++num].to=v;
    edge[num].nxt=head[u];
    head[u]=num;
}
void dfs(int u)
{
    used[u]=1;
    for (int i=head1[u]; i!=0; i=edge1[i].nxt)
        if (!used[edge1[i].to]) dfs(edge1[i].to);
    vs[++size]=u;
}
void rdfs(int u)
{
    used[u]=1; cmp[u]=cnt;
    for (int i=head2[u]; i!=0; i=edge2[i].nxt) {
        if (!used[edge2[i].to]) rdfs(edge2[i].to);  //5555555555555555555555555555555
    }
}
void scc()
{
    memset(used,0,sizeof(used));
    rep(i,1,n) if (!used[i]) dfs(i);
    memset(used,0,sizeof(used));
    for (int i=size; i>0; i--) if (!used[vs[i]])
        {cnt++; rdfs(vs[i]);}
}
void Spoint()
{
    rep(i,1,n) 
        for (int j=head1[i]; j!=0; j=edge1[j].nxt)
            if (cmp[edge1[j].to]!=cmp[i]) {
                G[cmp[i]].push_back(cmp[edge1[j].to]);
                in[cmp[edge1[j].to]]++;
            }
}
int in0()
{
    int res=0;
    rep(i,1,cnt) if (in[i]==0) res++;
    return res;
}
int main()
{
    scanf("%d%d",&n,&m);
    int u,v;
    rep(i,1,m) {
        scanf("%d%d",&u,&v);
        add(edge1,head1,num1,u,v);
        add(edge2,head2,num2,v,u); //reverse.
    }
    scc();
    Spoint();
    printf("%d",in0());
    return 0;
}
```

---

## 作者：Last_Reincarnation (赞：4)

咳咳咳，期末之前发个题解，涨一下rp

首先这道题是一道缩点的板子题
 
思路很简单，先缩一下点，然后统计一下入度为0的点即可
（思考一下，不懂留言，会一直看洛古的）

真的不知道为甚么大佬们要遍历一下所有的边来统计入度

个人觉得只需要看一下原来存的边就可以了

最后祝大家AK noi ~~祝我自己和czx和hbw考好期末~~

要去学文化课了，依依不舍

```cpp
 #include<iostream>
#include<cstdio>
using namespace std;
const int maxn=100100;

int n,m,cnt,top,tim,ecnt,ans,head[maxn];
int dfn[maxn],low[maxn],sd[maxn],stc[maxn],in[maxn];
bool vis[maxn];

struct Edge{
	int u,v,next;
}e[5*maxn];

void add(int u,int v){
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt;
	return ;
}

void tarjan(int x){
	low[x]=dfn[x]=++tim;
	stc[++top]=x;  vis[x]=1;
	for(int i=head[x];i;i=e[i].next){
		int v=e[i].v;
		if(!dfn[v]) {
			tarjan(v);
			low[x]=min(low[x],low[v]);
		}
		else if(vis[v])
				low[x]=min(low[x],low[v]);
	}
	if(low[x]==dfn[x]){
		int y;
		sd[x]=++ecnt;
		while(y=stc[top--]){
			sd[y]=ecnt;
			vis[y]=0;
			if(y==x) break;
		}
	}
}//缩点板子，不多说

int main(){
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		if(x==y) continue;
		add(x,y);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	for(int i=1;i<=m;i++){
		int u=sd[e[i].u];
		int v=sd[e[i].v];
		if(u!=v){
			in[v]++;
		}
	}
/*	for(int i=1;i<=n;i++)
		for(int j=head[i];j;j=e[j].next){
			int u=sd[i];
			int v=sd[e[j].v];
			if(u!=v){
				in[v]++;
			}
		}*/
	
	for(int i=1;i<=ecnt;i++){
		if(!in[i]) ans++;
	}
	printf("%d",ans);
	return 0;
}

```


---

## 作者：PrincessYR✨～ (赞：4)

不知道为什么其他大佬写Tarjan都用前向星，几乎没有用vector的，那么我来拯救一下大家。

先来讲解一下强连通分量

> 有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。——百度百科
> 


Tarjan是基于迪法师（DFS）的一种算法，可以说是一种流（du）批（liu）的操作，本蒟蒻苦哈哈的学了好几天才学会强连通分量和缩点；


步入正轨：

## 图中｛6｝是第一个被发现的强连通分量，其次是｛5｝，最后被发现的是｛3，4，1，2｝*（顺序无所谓）*

![图丑勿喷](https://img-blog.csdnimg.cn/20200226074807157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rmc2RzZGFzYQ==,size_16,color_FFFFFF,t_70)

Tarjan算法是解决强连通分量和缩点问题的一种比较常见的方法

接下来开始一步一步的

首先给你一个图（求其中的强连通分量）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091129601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

在这里我们假设从点1开始遍历，并且将访问的点压入栈中


在进行操作之前，我们要明确Tarjan中的两个至关重要的数组：DFN和LOW；

DFN[x]：表示这个点x几次被遍历到；

LOW[x]：表示点x或点x的子树能够追溯到的最早的栈中节点的次序号；

即LOW[x]=min{LOW[x]，LOW[next]}；

其中next为x的子节点；

接下来，我们来一步一步的找；

### 第一遍从1直接一直遍历到6，另访问到的点的初始low和dfn都为num++;num为计数器；

但当我们遍历到6是发现6没有子节点了，所以low[6]=dfn[6]=4;发现一个强连通分量｛6｝，6出栈；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091319822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

退回到5，low[5]=min(low[5],low[6]);

low[6]=4;而low[5]=dfn[5]=3;

所以low[5]=3；

low[5]=dfn[5];所以5也是一个强连通分量；5出栈；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091329523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

返回3发现3有子节点4，搜索4，并且4入栈；发现4也有子节点，6已经为强连通分量且不再栈中，跳过；

遍历1，发现一在栈中且已经被访问过，那么4值得被发现；

所以low[4]=min(low[4],dfn[1]);所以low[4]=1；

4遍历完，又因为dfn[4]!=low[4],所以4不退站；回到3，low[3]=min(low[3],low[4]);

所以low[3]=1;3访问完，又因为dfn[3]!=low[3],所以3不退站；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091337456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

回到1，发现1还有子节点2，2入栈；发现2的子节点4已经被访问且在栈中，所以low[2]=min(dfn[4],low[2]);

所以low[2]=5;访问完2，回到一，发现low[1]=dfn[1];所以将栈中的所有点出栈，并且这些点为一个强连通分量；


![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823091346286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ByZWRpY3Rpb25fXw==,size_16,color_FFFFFF,t_70)

至此，所有点已经都被访问，算法结束。时间复杂度O（N+M）

这道题还学要进行缩点，下面是缩点的核心代码（我自己认为的）：

```
for(int i=1;i<=a;i++)
	{
		for(int j=0;j<map[i].size();j++)
		{
			int p=map[i][j];
			if(bl[i]!=bl[p])
			{
				ru[bl[p]]++;
			}
		}
```

那么一张图缩玩点之后会变成一张无环图，这道题让我们求发几次消息，那么我们只需要在一张连通的图中发一次，那么消息就会一直传到最底端。

那么我们把问题转化为求有几张图，只需要找有几个点的入度为零即可。

```
#include<iostream>
#include<cstdio>
#include<vector>
#include<string.h>
#include<stack>
#define Size 500005
using namespace std;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
        f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
stack<int> atack;
vector<int> map[Size]; 
int a,b,c,d,tot,num=0,low[Size],dfn[Size],numb=0,bl[Size],ru[Size],nums[Size];
bool inst[Size];
void tarjan(int now)
{
	dfn[now]=low[now]=++num;
	atack.push(now);
	inst[now]=true;
	for(int i=0;i<map[now].size();i++)
	{
		int next=map[now][i];
		if(dfn[next]==0)
		{
			tarjan(next);
		    low[now]=min(low[now],low[next]);
		}else if(inst[next]==1)
	    {
		low[now]=min(low[now],dfn[next]);
	    }
	}
	if(dfn[now]==low[now])
	{
		numb++;
		int q;
		do
		{
			q=atack.top();
			inst[q]=0;
			atack.pop();
			bl[q]=numb;//vis
			nums[numb]++;//sum
		}while(q!=now);
	}
}
int main()
{
	a=read();b=read();
	for(int i=1;i<=b;i++)
	{
		c=read();d=read();
		map[c].push_back(d);
	}
	memset(dfn,0,sizeof(dfn));
	memset(inst,false,sizeof(inst));
	for(int i=1;i<=a;++i)
	{
		if(dfn[i]==0)
		tarjan(i);
	}
	for(int i=1;i<=a;i++)
	{
		for(int j=0;j<map[i].size();j++)
		{
			int p=map[i][j];
			if(bl[i]!=bl[p])
			{
				ru[bl[p]]++;
			}
		}
	}
	for(int i=1;i<=numb;i++)
	{
		if(ru[i]==0)
		tot++;
	}
	cout<<tot;
	return 0;
}
```




---

## 作者：Yuyuanqi (赞：3)

# 题解 P2002 消息扩散

[题目链接](https://www.luogu.org/problem/P2002)

非常裸的一道缩点题，很显然每个强连通分量里给一个点消息就够了，缩完点以后很显然我们要讨论每一个点的入度。对于入度为零的点（没有其它点能给他消息），我们就必须给它一份消息，所以就变成了数入度为零的点。由于数据规模，所以我们不需要重新建图。

值得一提的是一个小细节。重边和自环。我一开始用map判重边结果t了一个点（也有可能是这个点有自环qaq），然后删了map特判判自环就直接过了，看来重边好像对这道题没什么影响？？（大雾

代码：~~几乎是裸的模版题，好像比模版题还简单点~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <stack>
#include <vector>
#include <map>
#define N 100005
#define ll long long
using namespace std;

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}
vector < int > a[N];
stack < int > s;
map < pair < int, int >, int > mp;
int n, m, times, dfn[N], low[N], instc[N], vis[N], mtot, du[N], ans;
//vector存图可能会慢
void tarjan(int x)
{
	dfn[x] = low[x] = ++times;
	instc[x] = 1;
	s.push(x);
	for (int i = 0; i < a[x].size(); i++)
	{
		int u = a[x][i];
		if (!dfn[u])
		{
			tarjan(u);
			low[x] = min(low[x], low[u]);
		}
		else if (instc[u])
			low[x] = min(low[x], dfn[u]);
	}
	if (dfn[x] == low[x])
	{
		++mtot;
		vis[x] = mtot;
		instc[x] = false;
		while (s.top() != x)
		{
			vis[s.top()] = mtot;
			instc[s.top()] = 0;
			s.pop();
		}
		s.pop();
	}
}

int main()
{
	n = read(), m = read();
	for (int i = 1; i <= m; i++) { int a1 = read(), a2 = read(); if (a1 != a2) a[a1].push_back(a2); }
	for (int i = 1; i <= n; i++)
		if (!dfn[i]) tarjan(i);
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j < a[i].size(); j++)
		{
			int u = a[i][j];
			if (vis[u] != vis[i])
			{
				du[vis[u]]++; //更新入度 （不在乎是否重复）
			}
		}
	}
	for (int i = 1; i <= mtot; i++)
		if (du[i] == 0) ans++; //统计入度累加答案
	cout << ans << endl;
	return 0;
}
```
最后推荐几个相似题目，做tarjan必刷：

[P1262 间谍网络](https://www.luogu.org/problem/P1262)

[P2341 [HAOI2006]受欢迎的牛|【模板】强连通分量](https://www.luogu.org/problem/P2341)

[P3627 [APIO2009]抢掠计划](https://www.luogu.org/problem/P3627)

**最后吐槽下为什么这么裸的tarjan都是蓝题，因为普及组不考么qaq**

---

## 作者：sp201613 (赞：3)

这是很明显的强连通分量的题

思路很简单，建边，然后再用tarjan缩点（tarjan大法好）

缩点后我们就可以统计每个强连通分量的入度，入度为0的强连通分量的个数即为最终答案QAQ

下面就上代码了

------------
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define rg register//卡常
const int N=100010,M=500010;
int n,m,a[M],b[M],h[N],cnt,dfn[N],low[N],stack[N],co[N],col,top,num,de[N],ans;
struct edge{
	int to,next;
}e[M];
inline void add(rg int u,rg int v)//前向星建边
{
	e[++cnt].to=v;
	e[cnt].next=h[u];
	h[u]=cnt;
}
inline void tarjan(rg int x)//缩点
{
	low[x]=dfn[x]=++num;
	stack[++top]=x;//入栈
	for(rg int i=h[x];~i;i=e[i].next){
		int y=e[i].to;
		if(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);
		else if(!co[y]) low[x]=min(low[x],dfn[y]);
	}
	if(!(dfn[x]^low[x])){
		co[x]=++col;
		while(stack[top]^x){//出栈
			co[stack[top]]=col;
			--top;
		}
		--top;
	}
    //其中!(a^b)意为a==b,a^b为a!=b
}
int main(void)
{
	memset(h,-1,sizeof(h));
	scanf("%d%d",&n,&m);
	for(rg int i=1;i<=m;++i){//本人推荐++i，便于卡常
		scanf("%d%d",a+i,b+i);
		add(*(a+i),*(b+i));
	}
	for(rg int i=1;i<=n;++i)
	    if(!dfn[i]) tarjan(i);
    for(rg int i=1;i<=m;++i)
    	if(co[a[i]]^co[b[i]]) ++de[co[b[i]]];//统计入度
    for(rg int i=1;i<=col;++i) if(!de[i]) ++ans;
    printf("%d",ans);
}
```

---

## 作者：tututu (赞：3)

和楼下说的差不多了，缩点后入度==0的点数就是答案。

用tarjan将每个强连通分量缩成点，记录原先的每个点缩入了哪个点，读入的边需要存下来。

缩完之后，扫描每条边，判断如果终点和起点所在的分量不同，而且终点未被标记（标记表示已经统计），那么标记终点并且计数器+1，计数器存的就是缩点之后，入度不为0的分量数。

输出 分量数-入度>0的分量数 当然是入度==0的分量数了。

不需要复杂地求出确切的入度了。

```cpp 
#include <bits/stdc++.h>
using namespace std;
int all,s2,x[500002],y[500002],top,num,n,m,ans,e,p[500002],ne[500002],h[500002],dfn[500002],lo[500002],w[500002],t[500002];
bool f[500002],tr[500002];
string s;
void add(int x,int y){
  p[++num]=y;
  ne[num]=h[x];
  h[x]=num;
}
void tarjan(int x){
  dfn[x]=lo[x]=++num;
  t[++top]=x;
  f[x]=true;
  int k=h[x];
  while(k!=0){
    if(dfn[p[k]]==0){
      tarjan(p[k]);
      lo[x]=min(lo[x],lo[p[k]]);
    } else
      if(f[p[k]])
        lo[x]=min(lo[x],dfn[p[k]]);
    k=ne[k];
  }
  if(dfn[x]==lo[x]){
    s2++;
    int r;
    do{
      r=t[top--];
      f[r]=false;
      w[r]=n+s2;
    }
    while(x!=r);
  }
}
int main(){
  cin>>n>>m;
  for(int i=1;i<=m;i++){
    cin>>x[i]>>y[i];
    add(x[i],y[i]);
  }
  num=0;
  for(int i=1;i<=n;i++)
    if(dfn[i]==0){
      top=0;
      tarjan(i);
    }
  for(int i=1;i<=m;i++){
    if(!tr[w[y[i]]]&&w[x[i]]!=w[y[i]]){
      tr[w[y[i]]]=true;
      ans++;
    }
  }
  cout<<s2-ans;
  return 0;
}
```

---

## 作者：hamster000 (赞：2)

## **Analysis**
注意到在一个连通块内部的城市互相可以收到消息，所以每个连通块至多选择一个点。

任何一个整体没有入度的连通块，都必须选择一个点，否则不可能得到消息，这是可以预见的。

任何一个有入度的连通块，都可以从其他连通块得到信息，因此都不必选择点。

所以最优解相当于没有入度的连通块个数。

## Correction

有些题解表明要判断自环，但这题自环不影响 tarjan 正确性。

可能有人会说，自环不判第 $10$ 个点会RE，所以必须判断自环，但事实并非如此。事实上，第 $10 $ 个测试点第 $50965$ 行 出现了“0 0”这个数据，导致不判断自环发生的错误。

并且事实上，可以通过良好的实现，忽略这个数据错误，而不需要特判。

## Code A
该代码无需判断自环。
```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=500005;
int dfn[maxn],low[maxn],in[maxn];
stack<int> s;
vector<int> vec[maxn];
int scc[maxn],SCC,cnt,val[maxn];
int n,m;
vector<int> graph[maxn];int S[maxn];
int u[maxn],v[maxn];
void tarjan(int k){
	low[k]=dfn[k]=++cnt;
	in[k]=1;
	s.push(k);
	for(auto to:vec[k]){
		if(!dfn[to]){
			tarjan(to);
			low[k]=min(low[k],low[to]);
		}else if(in[to]) low[k]=min(low[k],dfn[to]);
	}
	if(low[k]==dfn[k]){
		scc[k]=++SCC;
		S[SCC]+=val[k];
		while(s.top()!=k){
			scc[s.top()]=SCC;
			S[SCC]+=val[s.top()];
			in[s.top()]=0;
			s.pop();
		}
		in[k]=0;
		s.pop();
	}
}
int d[maxn],dp[maxn];
void rebuild(){
	for(int i=1;i<=m;i++){
		if(scc[u[i]]!=scc[v[i]]){
			graph[scc[u[i]]].push_back(scc[v[i]]);
			d[scc[v[i]]]++;
		}
	}
}
int counter,ans;
int main(){
	cin >>n  >>m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin >> x >> y;
		u[++counter]=x;
		v[counter]=y;
		vec[x].push_back(y);
	}
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
	rebuild();
	for(int i=1;i<=SCC;i++){
		if(d[i]==0)ans++;
	}
	cout << ans << endl;
}
```
## Code B

该代码需要在读入时判断自环。

（感谢[奈芙蓮同学](https://www.luogu.com/user/1293516)提供的优质代码）
```cpp
#include <bits/stdc++.h>
using namespace std;

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

using ll = long long;
using ld = long double;
using str = string;

using pi = pair<int, int>;
using pl = pair<ll, ll>;
using pd = pair<ld, ld>;
#define mp make_pair
#define f first
#define s second

#define vt vector
using vi = vt<int>;
using vb = vt<bool>;
using vl = vt<ll>;
using vd = vt<ld>;
using vs = vt<str>;
using vpi = vt<pi>;
using vpl = vt<pl>;
using vpd = vt<pd>;
#define sz(x) (int)(x).size()
#define bg(x) begin(x)
#define all(x) bg(x), end(x)
#define rall(x) rbegin(x), rend(x)
#define sor(x) sort(all(x))
#define rs resize
#define is insert
#define pb push_back
#define eb emplace_back
#define ft front()
#define bk back()

#define lb lower_bound
#define ub upper_bound

#define FOR(i, a, b) for (int i = (a); i < (b); ++i)
#define F0R(i, a) FOR(i, 0, a)
#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)
#define R0F(i, a) ROF(i, 0, a)
#define each(x, a) for (auto& x : a)

const int MOD = 1e9 + 7;
// const int MOD = 998244353;
const int d4i[]{-1, 0, 1, 0}, d4j[]{0, 1, 0, -1};
const int d8i[]{-1, -1, 0, 1, 1, 1, 0, -1}, d8j[]{0, 1, 1, 1, 0, -1, -1, -1};

void solve() {
	int n, m;
	cin >> n >> m;
	vt<vi> adj(n);
	while (m--) {
		int b, e;
		
		cin >> b >> e;
		--b;
		--e;
		if(b==e) continue;
		adj[b].pb(e);
	}
	vi dfn(n), low(n), stack(n), scc(n);
	int dfncnt = 0, top = 0, sc = 0;
	bitset<100000> in_stack;
	auto tarjin = [&](auto tarjin, int u) -> void {
		dfn[u] = low[u] = ++dfncnt;
		stack[++top] = u;
		in_stack.set(u);
		each(v, adj[u]) {
			if (!dfn[v]) {
				tarjin(tarjin, v);
				low[u] = min(low[v], low[u]);
			} else if (in_stack.test(v)) {
				low[u] = min(dfn[v], low[u]);
			}
		}
		if (dfn[u] == low[u]) {
			do {
				in_stack.set(stack[top], 0);
				scc[stack[top]] = sc;
			} while (stack[top--] ^ u);
			++sc;
		}
	};
	F0R(i, n) {
		if (!dfn[i]) {
			tarjin(tarjin, i);
		}
	}
	vi in(sc);
	F0R(u, n) {
		each(v, adj[u]) {
			if (scc[u] ^ scc[v]) {
				++in[scc[v]];
			}
		}
	}
	cout << count(all(in), 0) << "\n";
}

int main() {
	cin.tie(0)->sync_with_stdio(0);
	
	int t = 1;
	// cin >> t;
	
	while (t--) {
		solve();
	}
	
	return 0;
}
```

---

## 作者：红薯淀粉 (赞：2)

**~~其实这道题蛮水的~~**
## 思路：
根据题意，他说有环，自然想到要用tarjan,后面就很简单了；

缩完点之后重新建图，开一个$in$数组表示该点的入度是多少（$ps$：该点表示缩完点之后的大点）；

最后统计一下那个点没有入度就好了；
###### ~~下面是本蒟蒻的cpp~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
using namespace std;
stack<int>q;
struct Node
{
    int next,to;
}e[1010111],ee[1010101];
int dfn[1010101],low[1010100],be[1010111];
int vis[1010101],in[1010001],headd[1010101];
int n,m,num,num1,ans,head[1010101];
//num1表示大点的个数，num表示tarjan中的编号
//head原图，e->原图；ee->新图 headd->新图
void add(int x,int y)
{
    e[++head[0]].next=head[x];
    e[head[0]].to=y;
    head[x]=head[0];
}
void ad(int x,int y)
{
    ee[++headd[0]].next=headd[x];
    ee[headd[0]].to=y;
    headd[x]=headd[0];
}
//这里我用的head[0]，headd[0]表示是为了节省一个小小的空间
void tarjan(int x)
{
    vis[x]=1;q.push(x);
    dfn[x]=low[x]=++num;
    for(int i=head[x];i;i=e[i].next)
    {
        int t=e[i].to;
        if(!dfn[t])
        {
            tarjan(t);
            low[x]=min(low[x],low[t]);
        }
        else if(vis[t])
            low[x]=min(low[t],low[x]);
    }
    if(dfn[x]==low[x])
    {
        vis[x]=0;
        be[x]=++num1;
        while(q.top()!=x)
        {
            be[q.top()]=num1;
            vis[q.top()]=0;
            q.pop();
        }
        be[q.top()]=num1;
        vis[q.top()]=0;
        q.pop();
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int y,u;
        scanf("%d%d",&y,&u);
        add(y,u);
    }//加边
    for(int i=1;i<=n;i++)
        if(!dfn[i])
            tarjan(i);
    for(int i=1;i<=n;i++)
        for(int j=head[i];j;j=e[j].next)
            if(be[i]!=be[e[j].to])
            {
                ad(be[i],be[e[j].to]);
                in[be[e[j].to]]++;
                //加新边同时记in
            }
    for(int i=1;i<=num1;i++)
        if(!in[i])
            ans++;
    printf("%d",ans);
    return 0;
}
```


###### ~~瑟瑟发抖~~

---

## 作者：Del_Your_Heart (赞：2)

# 写在前面
[传送门 洛谷P2002 消息扩散](http://www.luogu.org/problem/P2002)

[可在博客内阅读](https://www.luogu.org/blog/62246/tarjan-suan-fa-li-ti-zong-jie-luo-gu-p2002-post)

**$tarjan$算法前置小芝士：$dfs$序，强连通分量**

**$1^o$强连通分量**：在一个**有向图**的任意一非空子图中，**任意**两点都能互相到达，则称这个子图为该无向图的一个**强连通分量**。举个栗子：环就是一种强连通分量。

**重要性质1**：在一个**边权为正**的**有向图**中，若有一条经过点的权值和最大的路径通过一个强连通分量中的一点，则这条路径通过其**所有点**。（缩点的理论基础）

**重要性质2**：一个无向图的所有强连通分量都是**相互独立**的，没有相同的点或边。（这也是其被称为“分量”的原因）

**以上两条性质都是显而易见的，但却非常重要。**

**$2^odfs$序**：顾名思义，就是在$dfs$一个图时遍历各个点的**先后顺序**。

**优点**：将树或图用**线性**的结构存储，便于**查询**和**修改**。



------------

# 算法内容
$tarjan$算法是一种基于$dfs$的求强连通分量算法。

具体实现如下：维护一个$dfs$序——数组$dfn[]$，和由$i$节点能达到的$dfn$值最小的节点的$dfn$值——$low[]$，并维护一个栈，在最开始时将节点压入栈中。显然，**在一个强连通分量中，所有点的$low$值都为该强连通分量中$dfn$值最小的节点的$dfn$值**。利用这条性质，我们可以求出所有的强连通分量。

在每遍历完一个节点以及它之后的节点后，判断其$dfn$值是否和$low$值相等。如果是，那么**该节点即为其所在强连通分量中的$dfn$值最小的点**，将栈中该节点及其以上的所有节点全部取出，即为该强连通分量的所有点。

#### 给出伪代码：

```
void tarjan(int u){
	dfn[u]=low[u]=++时间编号;
	将u压入栈中;
	遍历所有u能到达的点v{
		if v没有被访问过{
        tarjan(v);
           low[u]=min(low[u],low[v]);
		}
		else if v仍在栈中{
			low[u]=min(low[u],dfn[v]);
		}
   }
	if low[u]==dfn[u]{
		++强连通分量编号;
		while 栈顶!=u{
			将栈顶编号;
			弹出栈顶;
		}
	}
}
```

而对于本题，就是对于每个强连通分量，如果没有其它强连通分量能到达它，就需要发布消息，用$tarjan$求出所有强连通分量即可。


------------

# 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, cnt = 0;
int timing, dfn[100005], low[100005], ins[100005];
int colcnt = 0, col[100005], colnum[100005], com[100005], go[100005];
stack<int> s;
vector<int> e[100005];//个人习惯，vector存图
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || '9' < ch) {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = (x << 3) + (x << 1) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}//快读
void tarjan(int u) {
    dfn[u] = low[u] = ++timing;//初始化dfn和low值
    s.push(u);//压入栈中
    ins[u] = 1;//标记访问
    for (int i = 0; i < e[u].size(); i++) {//遍历u能到达的点
        int v = e[u][i];
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        colcnt++;//新增一个强连通分量
        int tmp;
        do {
            tmp = s.top();//取出栈顶
            s.pop();
            col[tmp] = colcnt;//编号
            ins[tmp] = 0;
        } while (tmp != u);
    }
}
int main() {
    n = read();
    m = read();
    int x, y;
    for (int i = 1; i <= m; i++)
        x = read(), y=read(), e[x].push_back(y);
    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            tarjan(i);
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < e[i].size(); j++) {
            int v = e[i][j];
            if (col[i] != col[v])
                com[col[v]]++;//统计能到达该强连通分量的个数
        }
    }
    int xcom = 0;
    for (int i = 1; i <= colcnt; i++) 
        if (!com[i])
            xcom++;//统计没有其他强连通分量可到达的个数
    cout << xcom;
    return 0;
}
```
























---

## 作者：juicyyou (赞：1)

# P2002 消息扩散
这题应该算是比较水的缩点题了。

首先我们考虑一下在DAG上这个问题的解法。显然, 在DAG上, 如果想要遍历图上的所有点, 就需要从图中所有入度为零的点出发进行遍历。我们只需要统计一下有多少入度为零的点就行了。

不过题目中并没有说这张图是个DAG, 所以我们需要将其转化为一个DAG上的问题。做法也很显然, 把这张图所缩一下点, 再统计一下入度为零的点的个数即可。不过这题中说有自环, 所以还需要再输入时进行一下特判。然后这个题就做完了。

Tarjan的复杂度是 $O(m)$ 的, 统计的复杂度是 $O(n)$ 的, 所以上述算法的复杂度就是 $O(n + m)$ 的, 可以通过此题。

下面是我的Code:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<stack>
using namespace std;
const int maxn = 5e5 + 5;
int n, m, cols, ans, cur, dfsclock;
int head[maxn], to[maxn], nex[maxn], dfn[maxn], low[maxn];
int col[maxn], fir[maxn], sec[maxn], deg[maxn];
bool inst[maxn];
stack<int> st;
void add(int u, int v){ // 链式前向星 
	nex[++cur] = head[u];
	to[cur] = v;
	head[u] = cur;
	return ;
}
void Tarjan(int s){ // Tarjan 求强连通分量 
	dfn[s] = low[s] = ++dfsclock;
	st.push(s);
	inst[s] = 1;
	for(int i = head[s];i;i = nex[i]){
		int t = to[i];
		if(!dfn[t]){
			Tarjan(t);
			low[s] = min(low[s], low[t]);
		} else if(inst[t]){
			low[s] = min(low[s], dfn[t]);
		} else {
			continue;
		}
	}
	if(dfn[s] == low[s]){
		++cols;
		while(st.top() != s){
			inst[st.top()] = 0;
			col[st.top()] = cols;
			st.pop();
		}
		inst[s] = 0;
		col[s] = cols;
		st.pop();
	}
	return ;
}
void count(){ // 利用 Tarjan 之后的结果统计缩点后的入度 
	for(int i = 1;i <= m;i++){
		if(col[fir[i]] != col[sec[i]]){
			deg[col[sec[i]]]++;
		}
	}
	return ;
}
void solve(){
	for(int i = 1;i <= cols;i++){ // 统计答案 
		if(!deg[i]){
			ans++;
		}
	}
	return ;
}
int main(){
	scanf("%d %d", &n, &m);
	for(int i = 1;i <= m;i++){
		scanf("%d %d", &fir[i], &sec[i]); // 输入 
		if(fir[i] == sec[i]){
		    continue;
		}
		add(fir[i], sec[i]);
	}
	for(int i = 1;i <= n;i++){
		if(!dfn[i]){ // Tarjan 处理 
			Tarjan(i);
		}
	}
	count();
	solve();
	printf("%d\n", ans); // 输出 
	return 0;
}
```

---

## 作者：Y_B_Y (赞：1)

先看题目:给一个有向图,**至少**要从几个点出发才能遍历这个图(就是至少需要在几个城市发布消息才能让这所有n个城市都得到消息)

首先可能会想到并查集,但像下方的图,因为普通的并查集只是求出是否联通,就一般无法给出正确答案(当然如果你的操作够sao可能可以)

![](https://cdn.luogu.com.cn/upload/image_hosting/st239cur.png)

然后可能会想到通过**求入度为0的点**(就是没有到这个点的路),因为入度如果不为零,那么一定可以从其他的点走到它,对于上面的那张图,这个结论似乎已经是正确的,但是看下面的图

![](https://cdn.luogu.com.cn/upload/image_hosting/q309woar.png)

可以发现,这个图所有的点入度都为零,都想从前一个点得到消息,但是这样形成了一个**死循环**,即使没有入度为0的点还是需要在任意一个点发布消息,我们再仔细一想,会发现这和**只有一个点的情况不是一样的吗**,所以我们可以**用tarjan进行缩点**(没学过tarjan的可以看[tarjan强连通分量/缩点模板题](https://www.luogu.com.cn/problem/P2341))

我们来举个例子吧

![](https://cdn.luogu.com.cn/upload/image_hosting/vw6qxc8p.png)

像上面这张图,我们发现,1,2,3形成了**死循环**,于是我们将1,2,3缩为一个点$t$,并将任何连入1,2,3中任意一点的边都连到$t$,从1,2,3任意一点连出的边都从$t$连出,于是得:

![](https://cdn.luogu.com.cn/upload/image_hosting/waqcqcsv.png)

(图中重复的边因为不影响省去了)

我们可以发现图中入度为0的点有两个,于是2就是这张图的答案

**于是我们得出步骤:**

+ 缩点

+ 求缩点后入度为0的点

细节看代码吧,我的代码并没有再建一个缩点后的图,而是通过**判断两个点是否在一个强连通分量中**来判断**缩点后它们是否在同一个点中**,如果一条边连接的两个点在缩点后并没有被缩为一个点(就是它们不在同一个强连通分量内),那么说明缩点后,这条边所指向的**点的入度不为0**(就像上图点3,4的关系).

###### 注:代码中每个点缩点后点的号数是跑tarjan时决定的,非自己决定

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,sd[N],ft[N],skt,dfn[N],low[N],sk[N],top;
int nx[5*N],to[5*N],sum,sz[N];//sd[i]表示点i在缩完点后所在的点,sz[i]表示缩点后的点i所包含的点的个数,skt为缩后点的个数
void tj(int x)//tarjan
{
    dfn[x]=low[x]=++sum;
    sk[++top]=x;
    for(int i=ft[x];i;i=nx[i])
    {
        if(!dfn[to[i]]) tj(to[i]);
        if(!sd[to[i]]) low[x]=min(low[x],low[to[i]]);//这里是正常的tarjan压缩后的代码
    }
    if(low[x]==dfn[x])//发现强连通分量
    {
        sd[x]=++skt;//缩点的个数加一
        sz[skt]=1;
        while(sk[top]!=x)//将他们缩为一点
        {
            sd[sk[top]]=skt;
            sz[skt]++;
            top--;
        }
        top--;
    }
}
bool rd[N];//存缩点后点的入度,为假即入度为0,为真即入度不为零
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)//建图
	{
		int a,b;
		cin>>a>>b;
		nx[i]=ft[a];
		ft[a]=i;
		to[i]=b;
	}
	for(int i=1;i<=n;i++)//tarjan
	{
		if(!dfn[i]) tj(i);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=ft[i];j;j=nx[j])
		{
			if(sd[i]!=sd[to[j]])//如果一条边连接的两个点在缩点后并不是同一个点
			{
				rd[sd[to[j]]]=1;//那么说明缩点后,这条边所指向的点(即sd[to[j]])的入度不为0
			}
		}
	}
	int ans=0;
	for(int i=1;i<=skt;i++) if(!rd[i])/*求入度为0的*/ ans++;//因为缩点后只有skt个点
	cout<<ans;
	return 0;
}

```


---

## 作者：寒鸽儿 (赞：0)

跑个tarjan缩点。然后同一个scc的点可以互传。  
缩点后是一个DAG,然后只要向入度为0的点传信息即可。  

细节:  
1) 在实现时统计入度,要判断边的起点和终点是否在同一个scc中,是的话不要加入度  
2) 很多题解都说要特判自环,实际上不需要的,强连通分量的含义是极大的强连通子图。
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 123456, M = 567890;
int head[N], ver[M], nex[M], my[M], tot;
inline void addedge(int u, int v) {
    ver[tot] = v; my[tot] = u; nex[tot] = head[u]; head[u] = tot++;
}

int co[N], dfn[N], low[N], sta[N], ind[N], top, dfs_clock = 1, col = 1;
void tarjan(int cur) {
    dfn[cur] = low[cur] = dfs_clock++;
    sta[top++] = cur;
    for(int i = head[cur]; ~i; i = nex[i]) {
        if(!dfn[ver[i]]) {
            tarjan(ver[i]);
            low[cur] = min(low[cur], low[ver[i]]);
        } else if(!co[ver[i]]) {
            low[cur] = min(low[cur], dfn[ver[i]]);
        }
    }
    if(dfn[cur] == low[cur]) {
        while(sta[--top] != cur) {
            co[sta[top]] = col;
        }
        co[cur] = col++;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    memset(head, -1, sizeof(head));
    memset(ind, 0, sizeof(ind));
    int n, m, u, v, cnt = 0;
    cin >> n >> m;
    for(int i = 1; i <= m; ++i) {
        cin >> u >> v;
        if(u != v) addedge(u, v);
    }
    for(int i = 1; i <= n; ++i) if(!co[i]) tarjan(i);
    for(int i = 0; i < tot; ++i) if(co[my[i]] != co[ver[i]]) ind[co[ver[i]]] = 1;
    for(int i = 1; i < col; ++i)
        if(!ind[i]) ++cnt;
    cout << cnt << '\n';
    return 0;
}

```

---

## 作者：李伟业 (赞：0)

#### 题目

#### 要连接所有的城市，问最少需要在几个城市发布。

### 思路

#### 对于每个点来说，如果它不作为儿子节点，那么就一定需要新在这个城市新发布。

#### 这样题目就转化为求入度为 0 的点的个数。

#### 由于可能出现自环，自环影响入度的判断，这样就自然想到缩点处理！

```cpp
#include <bits/stdc++.h>

using namespace std;
const int maxn=5e5+5;
int n,m;
int head[maxn*2],cnt;
int indegree[maxn*2];
int dfn[maxn],low[maxn],sccnum[maxn],stac[maxn],instac[maxn];
int top,num,sum,tot;
struct edge
{
    int to;
    int next;
}e[maxn*2];
void add(int u,int v)
{
    e[cnt].to=v;
    e[cnt].next=head[u];
    head[u]=cnt++;

}
void tarjin(int u)
{
    dfn[u]=low[u]=num;num++;//num=1 at first
    stac[top]=u;top++;//stac array is stack .top is the stack's top
    instac[u]=1;
    for(int i=head[u];i>=0;i=e[i].next)
    {
        int v=e[i].to;
        if(dfn[v]==0)
        {
            tarjin(v);
            low[u]=min(low[u],low[v]);
        }
        else if(instac[v]==1)
            low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u])
    {
        do{
            top--;//top of stack
            sccnum[stac[top]]=tot;//strongly connect component
            instac[stac[top]]=0;//out stack
        }while(top>=0&&stac[top]!=u);
        tot++;
    }
}
void init()
{
    cnt=0; num=1;top=1;tot=1;
    memset(indegree,0,sizeof(indegree));
    memset(head,-1,sizeof(head));
    memset(dfn,0,sizeof(low));
    memset(instac,0,sizeof(instac));
}
void zip()
{
    for(int i=1;i<=n;i++)
        for(int j=head[i];j>=0;j=e[j].next)
            if(sccnum[i]!=sccnum[e[j].to])
                add(sccnum[i]+n,sccnum[e[j].to]+n);
}
int main()
{
    init();
    int u,v;
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>u>>v;
        add(u,v);
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i])
            tarjin(i);
    zip();//zip the edge ans new map
    for(int i=1+n;i<tot+n;i++)
    {
        for(int j=head[i];j>=0;j=e[j].next)
        {

            int v=e[j].to;
            indegree[v]++;
        }
    }
    int sum=0;
    for(int i=1+n;i<tot+n;i++)
    {
        if(indegree[i]==0)
        {
            sum++;
        }
    }
    cout<<sum<<endl;
    return 0;
}

```
//撒花


---

## 作者：abandentsky (赞：0)

练习一下强连通分量的题目。这个题目其实不需要重新构图。在输入数据的时候需要消除自环。之后就是跑一边targain算法求出强连通分量。缩点之后只需要统计入度为0的点的个数就好了。（大水题，差点没写出来）。
```c
#include<stdio.h>
#include<string.h>
#include<vector>
#include<stack>
#include<algorithm>
#include<iostream>
#define MAXN 100005
using namespace std;

struct Edge
{
    int from,to;
    Edge(int from=0,int to=0):from(from),to(to){};
};
vector<Edge> edges;
vector<int> G[MAXN];
stack<int> S;
int pre[MAXN],sccno[MAXN],lowlink[MAXN],in[MAXN];
int dfs_clock,scc_cnt;
int n,m;

void dfs(int u)
{
    S.push(u);
    pre[u]=lowlink[u]=++dfs_clock;
    for(int i=0;i<G[u].size();i++)
    {
        Edge &e=edges[G[u][i]];
        int v=e.to;
        if(!pre[v])
        {
            dfs(v);
            lowlink[u]=min(lowlink[u],lowlink[v]);
        }
        else if(!sccno[v])
        {
            lowlink[u]=min(lowlink[u],pre[v]);
        }
    }
    if(pre[u]==lowlink[u])
    {
        ++scc_cnt;
        for(;;)
        {
            int x=S.top();
            S.pop();
            sccno[x]=scc_cnt;
            if(u==x)
                break;
        }
    }
}

void Find_Scc(int n)
{
    scc_cnt=dfs_clock=0;
    memset(sccno,0,sizeof(sccno));
    memset(pre,0,sizeof(pre));     
    memset(in,0,sizeof(in));              //用来统计缩点后的入度
    for(int i=1;i<=n;i++)
    {
        if(!pre[i])
           dfs(i);
    }
    for(int i=0;i<edges.size();i++)
    {
        int xx=edges[i].from;
        int yy=edges[i].to;
        if(sccno[xx]!=sccno[yy])
        {
            in[sccno[yy]]++;
        }
    }
}

int main()
{
    scanf("%d %d",&n,&m);
    int u,v;
    for(int i=0;i<m;i++)
    {
        scanf("%d %d",&u,&v);
        if(u==v)
            continue;
        edges.push_back({u,v});
        int mm=edges.size();
        G[u].push_back(mm-1);
    }
    Find_Scc(n);
    int sum=0;
    for(int i=1;i<=scc_cnt;i++)
    {
        if(in[i]==0)
            sum++;
    }
    printf("%d\n",sum);
    return 0;
}

```


---

## 作者：AC_Automation (赞：0)

刚学tarjan，写篇题解加深下印象。

## tarjan算法详解
给定一张有向图，求它的所有强连通分量。

每次选择一个未遍历的点开始dfs。

定义dfn[i]表示i被遍历到的时间，low[i]表示从i出发，只经过至多一条dfn变小的边，能走到的dfn最小的点的dfn的值。（可能有些绕，看不懂建议多看几遍）

维护一个栈，dfs到一个点时将它加入栈内。

如果一个点的dfn=low，那么不停弹出栈顶元素直到这个点被弹出，被弹出的所有点就构成了一个强连通分量。

时间复杂度O(m),m是边数

-----
#### 思路：先用tarjan缩点，然后统计入度为0的点的个数（缩点指将每一个强连通分量缩成一个点）

这里有一个小技巧，可以不用在缩点后重新建图，直接统计入度即可

code:
```cpp
#include<iostream>
#include<vector>
using namespace std;
#define N 100005
int dfn[N],low[N],tim=1,stack[N],top=0,belong[N],pn=0,du[N];
bool in[N];
vector<int> a[N];
void tarjan(int u){
	low[u]=tim;
	dfn[u]=tim++;
	stack[top++]=u;
	in[u]=true;//先初始化dfn值和low值，并压入栈
	int siz=a[u].size(),v;
	for(int i=0;i<siz;i++){
		v=a[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(in[v]) 
			low[u]=min(low[u],low[v]);//递归并更新low值
	}
	if(dfn[u]==low[u]){
		pn++;
		while(stack[top]!=u){
			top--;
			belong[stack[top]]=pn;
			in[stack[top]]=false;
		}
	}//将强连通分量中的点打上标记
}
int main()
{
	int n,m,x,y,ans=0;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		cin>>x>>y;
		if(x!=y)
			a[x].push_back(y);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])
			tarjan(i);//如果没有遍历过，那就遍历它
	for(int i=1;i<=n;i++)
		for(int j=0;j<a[i].size();j++)
			if(belong[i]!=belong[a[i][j]])
				du[belong[a[i][j]]]++;//统计入度
	for(int i=1;i<=pn;i++)
		ans+=(du[i]==0);//统计答案
	cout<<ans;
	return 0;
}

```

---

## 作者：Kevin_F (赞：0)

这个题就是tarjan强连通分量与入度的例题了。

思路： 


利用缩点的思想，先预处理一下所有的强连通分量，然后把每个强连通分量内的所有节点看做一个节点，然后处理一张新图，然后检查每个点的入度，然后取入度为 0 的点（缩点后）的个数，即为信息出发点。

可能有人想问为什么？？

大体说明一下：

1.充分性证明：如果入度为 0 的点不是信息出发点，那么这个点必定不会接收到任何节点发出的信息，因为它的入度为 0 。 

2.必要性证明：如果信息出发点不是入度为0的点，那么其必有入度点，使其覆盖点更多，而我们要找至少多少个点。

还是先明确一下各个数组的意思吧：


     dfn[i]:i点的时间戳

     low[i]，表示这个点以及其子孙节点连的所有点中dfn最小的值

     stack[]，表示当前所有可能能构成是强连通分量的点。

     ins[i]，表示 i 是否在stack[ ]数组中

     num[i],表示第 i 个强连通分量中有多少个点

     belong[i],表示第 i 点在哪一个强连通分量里
     
     in[i]:表示第 i 个强连通分量的入度是多少。
     
以下就是怎么处理入度：

```cpp
	for(int i=1;i<=m;i++){
		if(belong[edge[i].from] != belong[edge[i].to])
		  in[belong[edge[i].to]]++; 
	}
```
解释一下：

枚举边，比较这条边起点和终点是否在同一个强连通分量中，如果不在，这条边终点的入度++

AC代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 1e5 + 5;
const int maxm = 5e5 + 6;

int n,m,u,v;
int head[maxn],tot;
int dfn[maxn],low[maxn],ind;
int stack[maxn],top,belong[maxn],num[maxn],cnt;
int in[maxn];//表示某个点的入度 
int ans;
bool ins[maxn];
struct Edge{
	int from,to,next;
}edge[maxm]; 

void add(int u,int v){
	edge[++tot].to = v;
	edge[tot].from = u;
	edge[tot].next = head[u];
	head[u] = tot;
}

int read(){
	char ch = getchar();
	int f = 1 , x = 0;
	while(ch > '9' || ch < '0'){
		if(ch == '-')  f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}

void tarjan(int x){
	dfn[x] = low[x] = ++ind;
	stack[++top] = x;
	ins[x] = true;
	for(int i=head[x];i;i=edge[i].next){
		int v = edge[i].to;
		if(ins[v])  low[x] = min(low[x] , dfn[v]);
		if(!dfn[v]){
			tarjan(v);
			low[x] = min(low[v] , low[x]);
		}  
	}
	int k;
	if(dfn[x] == low[x]){
		++cnt;
		do{
			k = stack[top];
			num[cnt]++;
			top--;
			ins[k] = false;
			belong[k] = cnt;
		} while(k != x);
	}
}

int main(){
	n = read();  m = read();
	for(int i=1;i<=m;i++){
		u = read();  v = read();
		add(u , v);
	}
	for(int i = 1;i <= n ;++i) belong[i] = i;
	for(int i=1;i<=n;i++)
	  if(!dfn[i])  tarjan(i);
	  
	for(int i=1;i<=m;i++){
		if(belong[edge[i].from] != belong[edge[i].to])
		  in[belong[edge[i].to]]++; 
	}
	for(int i=1;i<=cnt;i++)
	  if(in[i] == 0)
	    ans++;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：__asm (赞：0)

- 先Tarjin跑scc

- 然后重构DAG

- 拓扑一下，然后DFS染色即可

```cpp
//#pragma GCC optimization ("O3")
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<stack>
using std::stack;
#define MAXN 100000
#define MAXM 500000
int n, m;
int head[MAXN], next[MAXM], to[MAXM], tot;
int scc[MAXN], stot;
inline void addEdge(int u, int v) {
    to[tot] = v;
    next[tot] = head[u];
    head[u] = tot++;
}
int sh[MAXN], sn[MAXM], st[MAXM], ss;
inline void addSEdge(int u, int v) {
    st[ss] = v;
    sn[ss] = sh[u];
    sh[u] = ss++;
}
inline int read() {
    register int x = 0;
    register char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x;
}
int dfn[MAXN], low[MAXN], ins[MAXN], idx;
stack<int> stk;
inline void Tarjan(int s) {
    dfn[s] = low[s] = ++idx;
    stk.push(s);
    ins[s] = true;
    for (int i = head[s]; i != -1; i = next[i]) {
        if (!dfn[to[i]]) {
            Tarjan(to[i]);
            low[s] = std::min(low[s], low[to[i]]);
        }
        else if (ins[to[i]])low[s] = std::min(low[s], dfn[to[i]]);
    }
    if (low[s] == dfn[s]) {
        int x;
        do {
            x = stk.top();
            ins[x] = false;
            stk.pop();
            scc[x] = stot;
        } while (x != s);
        stot++;
    }
}
int vst[MAXN];
void dfs(int s) {
    if (vst[s])return;
    vst[s] = true;
    for (int i = sh[s]; i != -1; i = sn[i]) {
        dfs(st[i]);
    }
}
int entry[MAXN], id[MAXN];
inline int cmp(const int &a, const int &b) {
    return entry[a] < entry[b];
}
int main() {
    memset(scc, -1, sizeof(scc));
    memset(head, -1, sizeof(head));
    memset(next, -1, sizeof(next));
    n = read();
    m = read();
    for (int i = 0; i < m; i++) {
        int u = read() - 1;
        int v = read() - 1;
        addEdge(u, v);
    }
    for (int i = 0; i < n; i++) {
        if (!dfn[i]) {
            while (!stk.empty())stk.pop();
            Tarjan(i);
        }
    }
    memset(sh, -1, sizeof(sh));
    memset(sn, -1, sizeof(sn));
    for (int i = 0; i < n; i++) {
        for (int j = head[i]; j != -1; j = next[j]) {
            if (scc[i] != scc[to[j]]) {
                addSEdge(scc[i], scc[to[j]]);
                entry[scc[to[j]]]++;
            }
        }
    }
    for (int i = 0; i < stot; i++)id[i] = i;
    std::sort(id, id + stot, cmp);
    int res = 0;
    for (int i = 0; i < stot; i++) {
        if (!vst[id[i]]) {
            res++;
            dfs(id[i]);
        }
    }
    printf("%d\n", res);
    system("pause");
    return 0;
}
```

---

## 作者：小黑 (赞：0)

缩点的典型应用题

同一个强连通分量的点可以等效为同一个点（互相直接或间接连通），求出所有强连通分量后遍历一遍，把每个强连通分量的入度求出来，入度为0的分量个数就是答案


注意：这道题会卡常数（不会告诉你们我栽了一次(´Д` )）



```cpp
var
  point,next,front:array[0..500000] of longint;
  head,dfn,low,stack,scc,indegree:array[0..100000] of longint;
  instack:array[0..100000] of boolean;
  n,m,x,y,i,num,edge_num,ans,top,sccnum,p:longint;
function min(a,b:longint):longint;
  begin
    if a<b then exit(a) else exit(b);
  end;
procedure addedge(u,v:longint);
  begin
    inc(edge_num);
    point[edge_num]:=v;
    front[edge_num]:=u;
    next[edge_num]:=head[u];
    head[u]:=edge_num;
  end;
procedure tarjan(u:longint);
  var
    p,root:longint;
  begin
    inc(num);dfn[u]:=num;low[u]:=num;
    inc(top);stack[top]:=u;instack[u]:=true;
    p:=head[u];
    while p<>0 do
      begin
        if dfn[point[p]]=0 then
          begin
            tarjan(point[p]);
            low[u]:=min(low[u],low[point[p]]);
          end
        else
          if instack[point[p]] then
            low[u]:=min(low[u],dfn[point[p]]);
        p:=next[p];
      end;
    if dfn[u]=low[u] then
      begin
        inc(sccnum);
        repeat
          root:=stack[top];instack[root]:=false;dec(top);
          scc[root]:=sccnum;//标记哪些点属于哪个强连通分量
        until root=u;
      end;
  end;
begin
  read(n,m);
  edge_num:=0;
  for i:=1 to m do
    begin
      read(x,y);
      addedge(x,y);
    end;
  sccnum:=0;
  for i:=1 to n do
    if dfn[i]=0 then
      begin
        top:=0;num:=0;
        tarjan(i);
      end;
  for i:=1 to edge_num do
    if scc[front[i]]<>scc[point[i]] then
      inc(indegree[scc[point[i]]]);//就是这里会卡常数= =
  ans:=0;
  for i:=1 to sccnum do
    if indegree[i]=0 then
      inc(ans);
  writeln(ans);
end.
```

---

## 作者：Kwork (赞：0)

根据题面可知道，在一个强连通分量里的城市只要有一个城市知道消息就可以让其它城市也知道消息，所以我们将有向图缩环，得到一个DAG，那么就把问题简化成了求出DAG中入度为0的点的个数，因为入度为0的点必须得知道消息，否则没有消息来源。


对于缩环，用tarjan，统计度数O(e)，所以效率为O(e+n)

如果不熟悉tarjan，请移步google。

-------------------------------------------------------------------------------------------------------------------------------------------------






```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
using namespace std;
const int MAXN=100005;
vector<int>G[MAXN];
int n,m,dfn[MAXN],ins[MAXN],Index=0,top=0,s[MAXN],cmp[MAXN],low[MAXN];
int cnt=0;
void read(int &n){
    n=0;
    char ch=getchar();
    while(ch<'0' || ch>'9') ch=getchar();
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    return;
}
void in_data(){
    read(n);read(m);
    for(int i=1;i<=m;i++){
        int u,v;
        read(u);read(v);
        G[u].push_back(v);
    }
    return;
}
void tarjan(int u){
    dfn[u]=low[u]=++Index;
    s[top++]=u;ins[u]=1;
    for(int i=0;i<G[u].size();i++){
        int v=G[u][i];
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else{
            if(ins[v]){
                low[u]=min(low[u],dfn[v]);
            }
        }
    }
    if(low[u]==dfn[u]){
        ++cnt;
        int i;
        do{
            i=s[--top];
            ins[i]=0;
            cmp[i]=cnt;
        }while(i!=u);
    }
    return;
}
void solve_query(){
    memset(dfn,0,sizeof(dfn));
    memset(ins,0,sizeof(ins));
    for(int i=1;i<=n;i++)
        if(!dfn[i])
            tarjan(i);
    memset(ins,0,sizeof(ins));
    for(int u=1;u<=n;u++){
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i];
            if(cmp[u]!=cmp[v]){
                ++ins[cmp[v]];
            }
        }
    }
    int ans=0;
    for(int i=1;i<=cnt;i++)
        if(ins[i]==0) ans++;
    printf("%d\n",ans);
    return;
}
int main(){
    in_data();
    solve_query();
    return 0;
}
```

---

## 作者：C_SUNSHINE (赞：0)

本题主要考察选手对图论算法中Tarjan算法的掌握。

设发布消息的集合为S，题目的意思是让所有的城市都得到消息，那么城市得到消息有两条途径，在该城市发布或者从其他城市得知。

容易推得两条定理：

1.强连通分量中任一城市得知消息即代表该强连通分量得知消息（易证）

2.入度为0的城市（强连通分量）一定要加入S（易证）。

3.有向无环图中只要在入度为0的节点发布消息，则所有点都可得到消息。

定理3证明：对于任意一个点，由这个点的1倍祖先，2倍祖先……组成一个序列，由于图中无环，所以任一节点不可能在序列中出现两次，又因为图中节点有限，所以序列必将终止在某个节点上，易知该节点入度为0，所以任意节点都为某个入度为0的点的后继。

故我们可以把强联通分量缩成点，然后在所有入度为0的点发布消息。求出图中强连通分量可以使用Tarjan算法，总体时间复杂度为O(n+e)。

参考资料：

http://baike.baidu.com/view/4064042.htm


---

## 作者：说好不哭 (赞：0)

## 本来对于tarjan缩点就不大熟练，模板老打错，就来写篇题解巩固总结一下。
### 此题思路就是tarjan缩点完毕以后判断有几个入度为0的点（这些点就是必须要产生消息的点）。（用tarjan缩点应该很好想到，因为题目说有环。）代码旁边的注释可以很好地体现语句作用。
### 其中对于low和dfn数组的作用，在[这里](https://www.luogu.org/recordnew/show/17447417)我用详细描述，所以此题解就不再介绍了。

### 下面就放代码。 

```cpp
#include <bits/stdc++.h>
#define memset(x) memset(x,0,sizeof(x))
using namespace std;
const int N=1e5+5,M=5e5+5;
int n,m,u,v,cnt,now,top,col,ans,sum;
int head[N],dfn[N],low[N],color[N],sta[N],de[N];
struct edge{int next,to;}e[M];

inline void add(int u,int v) 
{
	cnt++;	
	e[cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}

inline void tarjan(int u)
{
	dfn[u]=low[u]=++now;
	sta[++top]=u;
//栈内进行操作，对于栈内操作，看到后面，就会明白它用处了。
	for (register int i=head[u]; i; i=e[i].next)
	{
		if (!dfn[e[i].to])
		{	
			tarjan(e[i].to);
			low[u]=min(low[u],low[e[i].to]);
		}
		else if (!color[e[i].to])//只有当e[i].to的color未标记（即，e[i].to暂时不属于已得到的任意一个强连通分量）时，才可以进行low[u]的取min，这应该是显然的吧。
		low[u]=min(low[u],dfn[e[i].to]);
	}
//如果low[u]=dfn[u]，则说明u的子树节点已经无法回溯到前面去了，所以u和它的子树节点就成了一个强连通分量。
	if (low[u]==dfn[u])
	{
	color[u]=++col;
		while (sta[top]!=u) color[sta[top]]=col,top--;
	top--;
//处理这个强连通分量，把col总数累加，然后把u和它的子树的color都标记为此次的col。 这个操作是通过栈来实现的，对于栈内的具体操作，模拟一下就懂了。
	}
}

int main(){
memset(head); memset(dfn);
	scanf("%d%d",&n,&m);	
	for (register int i=1; i<=m; ++i) 
	{
	scanf("%d%d",&u,&v); 
	if (u!=v) add(u,v);//注意，可能存在自环,所以只当u!=v时才加边
//对于重边，没有任何关系，因为重边只会对路径计数产生影响
	}
	for (register int i=1; i<=n; ++i) if (!dfn[i]) tarjan(i);
//对于没有遍历过的点，进行tarjan
	for (register int i=1; i<=n; ++i)
	for (register int j=head[i]; j; j=e[j].next)
	if (color[i]!=color[e[j].to]) de[color[e[j].to]]++;
//每次一个点，然后再枚举这个点指向的各个点，若两点的color不同，则说明它们两点不在同一个强连通分量中，所以就把代表入度的点值加1。
	for (register int i=1; i<=col; ++i) if (!de[i]) ans++;
//如果入度为0，则ans++
printf("%d\n",ans);
return 0;
}
```

---


# 正则表达式

## 题目背景

小Z童鞋一日意外的看到小X写了一个正则表达式的高级程序，这个正则表达式程序仅仅由字符“0”,“1”，“.”和“\*”构成，但是他能够匹配出所有在OJ上都AC的程序的核心代码！小Z大为颇感好奇，于是他决定入侵小X的电脑上去获得这个正则表达式的高级程序。


## 题目描述

在 Internet 网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在 $A$ 到 $B$ 的连接不一定存在 $B$ 到 $A$ 的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在 $A$ 到 $B$ 的连接的同时也存在 $B$ 到 $A$ 的连接的话，那么 $A$ 和 $B$ 实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为 $0$。

现在小 Z 告诉你整个网络的构成情况，他希望知道从他的电脑（编号为 $1$），到小 X 的电脑（编号为 $n$）所需要的最短传输时间。

## 说明/提示

- 对于  $40\%$ 的数据，$1\leq n\leq 10^3$, $1\leq m\leq 10^4$；
- 对于  $70\%$ 的数据，$1\leq n\leq 5 \times 10^3$， $1\leq m\leq 10^5$；
- 对于  $100\%$ 的数据，$1\leq n\leq 2 \times 10^5$， $1\leq m\leq 10^6$。

保证答案在 `int` 范围内。

## 样例 #1

### 输入

```
3 2
1 2 1
2 3 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
1 2 1
2 3 6
3 4 1
4 2 1
3 5 2
```

### 输出

```
3```

# 题解

## 作者：Diamiko (赞：12)

## 核心算法：$Tarjan$缩点+最短路
~~看标签知道的~~

#### 我尽量说明的通俗易懂


------------

### 1.为什么要缩点

来看这样一个图
![随便画的](https://img39.pixhost.to/images/314/137831476_tarjan.png)
我们能看到$2-3-4$构成了一个环，这个环内每个点都能到的环中任意一个其他的点，这就叫强连通分量（只是一个通俗的讲法，不是很严谨，但懂这个意思就好了）

在一个有向有环图中才会有强连通分量，**在实际做题时我们把一个单点也看做强连通分量**

由于本题在一个强连通分量（局域网）内的点之间距离为$0$，我们可以想象到$2-3-4$重合在一起的画面，因为它们之间没有距离，所以我们把一个强连通分量当做一个点建图，就构成了一个DAG，即有向无环图，跑最短路

在这里就不详细介绍$Tarjan$算法了，本题解主要讲思路

### 2.最短路
$Dijkstra$+堆优化就够了，因为$Floyd$会炸，$SPFA$死了，别的我也不知道了

缩点后的精髓所在就是跑最短路的时候不是按点跑，而是按每一个强连通分量（通常用颜色color表示）

### 3.代码+注释
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f//伪极大值
using namespace std;
typedef pair<int,int> pii;
struct Node
{
	int head,dis;//链式前向星存储
	int dfn,low,color;
   	 //dfn,low是tarjan算法中固有的，想详细了解可以百度，
         //color是指颜色，也就是该点所属哪个强连通分量
	bool vis;//tarjan算法中这个点有没有在栈里的标志
}node[200005];
struct Edge
{
	int next,len,to;//存边，不解释了
}edge[10005];
int n,m,cnt,color_cnt,x[1000005],y[1000005],l[1000005],deep;
//n,m题目中的意思，color_cnt记录一共有几种颜色（强连通分量），
//x,y,l数组存储输入的边起点，终点和长度，
deep记录搜索深度
stack<int>s;//STL大法好
inline void init()
{
	for(int i=1;i<=n;i++)
	{
		node[i].head
		=node[i].dfn
		=node[i].dis
		=node[i].vis
		=node[i].low
		=0;
	}
	cnt=0;
}//清空原图，便于建新图
inline void addEdge(int u,int v,int w)
{
	edge[++cnt]={node[u].head,w,v};
	node[u].head=cnt;
}
void Tarjan(int u)
{
//纯模板
	s.push(u);
	node[u].dfn=node[u].low=++deep;
	node[u].vis=1;
	for(int e=node[u].head;e;e=edge[e].next)
	{
		int v=edge[e].to;
		if(!node[v].dfn)
		{
			Tarjan(v);
			node[u].low=min(node[u].low,node[v].low);
		}
		else
		{
			if(node[v].vis)
			{
				node[u].low=min(node[u].low,node[v].dfn);
			}
		}
	}
	if(node[u].dfn==node[u].low)
	{
		int tmp;
		color_cnt++;//有新的颜色了
		do
		{
			tmp=s.top();
			s.pop();
			node[tmp].color=color_cnt;
            //记录点的颜色
			node[tmp].vis=0;
		}while(tmp!=u);
	}
}
void Dijkstra()
{
	for(int i=1;i<=n;i++)
	{
		node[i].dis=INF;
	}//初始化各点
	int S=node[1].color;//获取1号点的颜色
	node[S].dis=0;
	priority_queue<pii,vector<pii>,greater<pii> >q;
    //为什么是stl的优先队列，因为我不会手写堆。。
	q.push({0,S});
    //以下都是模板
	while(q.size())
	{
		pii tmp=q.top();
		q.pop();
		int d=tmp.first,u=tmp.second;
		if(d!=node[u].dis)continue;
		for(int e=node[u].head;e;e=edge[e].next)
		{
			int v=edge[e].to;
			if(node[v].dis>d+edge[e].len)
			{
				node[v].dis=d+edge[e].len;
				q.push({node[v].dis,v});
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&l[i]);
        //把边存下来，待会建新图还会有用
		addEdge(x[i],y[i],l[i]);
	}
	for(int i=1;i<=n;i++)
	{
		if(!node[i].dfn)
		{
			Tarjan(i);
		}
	}
	init();
    //跑完tarjan，清空原图
	for(int i=1;i<=m;i++)
	{//枚举每一条边，如果连接的两个点颜色不同说明不在一个强连通分量里，那么就连一条边，否则不连
		int u=x[i],v=y[i],w=l[i];
		if(node[u].color!=node[v].color)
		{
			addEdge(node[u].color,node[v].color,w);
		}
	}
	Dijkstra();//跑最短路
	cout<<node[node[n].color].dis<<endl;
    //这里的输出尤其注意，因为我们的新图是按颜色存的，所以输出不应该直接输出n的dis，而是n的颜色的dis，（dis即1-n的最短距离）
	return 0;
}
```
希望本蒟蒻讲的你们能听懂，不懂可以at我留言

这是我第一篇题解，写题解真是太累了，求过审

---

## 作者：subarude (赞：8)

### $\text {缩点再加上拓扑排序可以搞掉这道题}$

 _还不知道怎么缩点的请先做一下这道[缩点板子题](https://www.luogu.org/problem/P3387)_ 

 _里面的题解也很详细，相信您花一些时间可以学会它qwq_ 

~~好，既然您已经会了缩点，~~ 那么这道题就容易了

先说一下为什么看到这道题会想到缩点

题干原话：
$\text {如果存在A到B的连接的同时也存在B到A的连接的话，那么A和B实际上处于同一局域网内，}$
$\text {可以通过本地传输，这样花费的传输时间为0}$ 

**也就是说在一个环中随便跑，它的花费是0也就是一个环内部的边根本不用管，直接把一个环当成一个点就行**

经过Tarjan缩点，可以**将环变成点**

正好实现了在环中传输花费为$0$的要求

于是这个图就变成一个 **DAG**　$\text {\ \ \ \ \ \ \ \ \ \ \ \ }$~~那我们不就可以为所欲为了吗~~$qwqwq$

把$1$号点的$dis$赋为$0$，其他全部赋为一个最大值

那么一个简单的DP就可以搞掉它$qwqwq$

从$1$号点向外扩展 最后直接输出$n$号点的$dis$

类似于拓扑排序，不过不用管$1$号点之前的点

Code:
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

inline int read() {
	int op = 1, a = 0; char c = getchar();
	for (; c < '0' || c > '9'; c = getchar()) if (c == '-') op = -1;
	for (; c >= '0' && c <= '9'; c = getchar()) a = a * 10 + c - '0';
	return op * a;
}

const int maxn = 200003;
const int maxm = 1000003;

int n, m;

int cnt;
int head[maxn];
struct Edge {int w, fr, to, nxt;} e[maxm];

inline void add_edge(int u, int v, int w) {
	e[++cnt].w = w;
	e[cnt].fr = u;
	e[cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

int Time;
bool vis[maxn];
int s[maxn], r; // 模拟栈 
int belong[maxn], num;
	// belong[i]表示编号为i的点属于哪个大点
	// num为大点的编号 
int dfn[maxn], low[maxn];

void Tarjan(int u) {
	dfn[u] = low[u] = ++Time;
	s[++r] = u; vis[u] = 1;
	int R = r;
		// 注意 R 不能定义成全局变量，
		// 这里保存一下这个强连通分量的最早遍历到的点在栈中的位置 
		// 后边可以变得方便一点 
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (!dfn[v]) {
			Tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if (vis[v]) low[u] = min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]) {
		num++;// 一个新的强连通分量 
		// R 在这里派上用场，张浩威老师的巧妙的写法 
		for (int i = R; i <= r; i++) {
			belong[s[i]] = num;
			vis[s[i]] = 0;
		}
		r = R - 1;
	}
}

// 重新建一下图 
void rebuild() {
	cnt = 0;
	memset(head, 0, sizeof head);
	for (int i = 1; i <= m; i++) {
		int u = belong[e[i].fr], v = belong[e[i].to];
		if (u == v) continue;
			// 如果两个点属于同一个点，那么这两个点之间的边不用管 
		else add_edge(u, v, e[i].w);
	}
}

int dis[maxn];

void Topo(int s) {
	memset(dis, 0x3f, sizeof dis);
	queue<int> q;
	q.push(s);
	dis[s] = 0;// 记得要把起点的dis设为0 
	for (; q.size(); ) {
		int u = q.front();
		q.pop();// 十年 OI 一场空，忘加 pop 见祖宗 
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].to;
			dis[v] = min(dis[v], dis[u] + e[i].w);
			q.push(v);
		}
	}
}

int main() {
	n = read(), m = read();
	for (int i = 1; i <= m; i++) {
		int u = read(), v = read(), w = read();
		add_edge(u, v, w);
	}
	for (int i = 1; i <= n; i++) if (!dfn[i]) Tarjan(i);
	rebuild();
	// 注意下面 1 和 n 的外边套了belong[]，这里手误本题凉 
	Topo(belong[1]); 
	cout << dis[belong[n]] << '\n';
	return 0;
}
```


---

## 作者：PrincessQi (赞：7)

~~这个题的出题人一定是标题党（标题党祖师）~~

事实上这个题是非常经典的**模板**题。

因为由互通的点距离都为0可以想到缩点，然后原图就变成了一个DAG，就可以跑最短路了。

所以做这个题你得先学会tarjan缩点、最短路。

至于最短路算法在这个题目前可用的只有dijkstra（spfa：死了，floyd：会炸时间）。（我写的是dijkstra堆优化

然后就是代码实现的事了：

```
#include<bits/stdc++.h>
using namespace std;
const int inf=2147483647;
int nex[1000005],beg[1000005],to[1000005],w[1000005],s[1000005],low[1000005],dfn[1000005],ins[1000005],b[1000005],top,y,k,u[1000005],v[1000005],ww[1000005],d[1000005],p[1000005],n,m,cnt,e,dd,x,z;//一大长串的定义
priority_queue<pair<int,int> >q;
void add(int x,int y){
    to[++e]=y;
    nex[e]=beg[x];
    beg[x]=e;
}//tarjan加边
void add2(int x,int y,int z){
    to[++e]=y;
    nex[e]=beg[x];
    beg[x]=e;
    w[e]=z;
}//dijkstra加边
void tarjan(int x){
	dfn[x]=low[x]=++dd;
	s[++top]=x;
	ins[x]=1;
    for(int i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(dfn[y]==0){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(ins[y])
            low[x]=min(low[x],dfn[y]);
    }
	if(low[x]==dfn[x]){
		cnt++;
		do{
			k=s[top--];
			ins[k]=0;
			b[k]=cnt;
		}while(x!=k);
	}
}//tarjan模板
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&u[i],&v[i],&ww[i]),add(u[i],v[i]);//输入，并存起来
	for(int i=1;i<=n;i++)
		if(dfn[i]==0)tarjan(i);//tarjan
	memset(beg,0,sizeof(beg));
	memset(nex,0,sizeof(nex));
	memset(to,0,sizeof(to));
    e=0;//清空链式前向星
    for(int i=1;i<=m;i++)
        if(b[u[i]]!=b[v[i]])
            add2(b[u[i]],b[v[i]],ww[i]);//缩点
    for(int i=1;i<=cnt;i++)
        d[i]=inf;
    d[b[1]]=0;
    q.push(make_pair(0,b[1]));
    while(!q.empty()){
        int x=q.top().second;
        q.pop();
        if(p[x])
            continue;
        p[x]=1;
        for(int i=beg[x];i;i=nex[i]){
            int y=to[i],z=w[i];
            if(d[y]>d[x]+z){
                d[y]=d[x]+z;
                q.push(make_pair(-d[y],y));
            }		
        }
    }//dijkstra模板
    printf("%d",d[b[n]]);
	return 0;
}
```


---

## 作者：eee_hoho (赞：3)

这道题着实是一道板子题，不过看着dalao们写的都~~好麻烦啊~~QAQ

题意：给你一个带权有向图，如果两个点之间可以互相到达，那么他们之间的边权为$0$，求从起点$1$到$n$的最短路。

两点之间可以互相到达其实就是在同一个强连通分量里的意思辣，也就是强连通分量里的点的距离为$0$，那么我们就可以用$tarjan$缩点，然后从起点跑一遍最短路就好了，至于$tarjan$缩点，可以去做一下[P3387](https://www.luogu.org/problemnew/show/P3387)，你就能对tarjan有了比较深入的理解啦。

注意一下，在我们缩完点后跑最短路的时候，只需要多判断下这两个点是不是在同一个前连通分量里，在的话就把这两个点之间的距离设成$0$。

**Code**
``` cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <queue>
#define N 250000
#define INF 99999999
using namespace std;
struct edge
{
	int to,cost;
};
vector <edge> a[N];
queue <int> q;
int n,m,dfn[N],low[N],co[N],stk[N],top,num,cnt,dis[N],vis[N];
void tarjan(int u)   //tarjan求强连通分量
{
	low[u]=dfn[u]=++cnt;
	stk[++top]=u;
	vector <edge>::iterator it;
	for (it=a[u].begin();it!=a[u].end();it++)
	{
		int v=(*it).to;
		if (!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else
			if (!co[v])
				low[u]=min(low[u],dfn[v]);
	}
	if (low[u]==dfn[u])
	{
		co[u]=++num;       //给强连通分量编号
		while (stk[top]!=u)
			co[stk[top]]=num,top--;
		top--;
	}
}
void spfa()   //单源最短路
{
		for (int i=1;i<=n;i++)
		dis[i]=INF;
	dis[1]=0;
	q.push(1);
	vis[1]=1;
	vector <edge>::iterator it;
	while (!q.empty())
	{
		int u=q.front();q.pop();
		vis[u]=0;
		for (it=a[u].begin();it!=a[u].end();it++)
		{
			int v=(*it).to,w=(*it).cost;
			if (co[u]==co[v])w=0;
			if (dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				if (!vis[v])
					q.push(v),vis[v]=1;
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	int x,y,z;
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		a[x].push_back((edge){y,z});
	}
	for (int i=1;i<=n;i++)
		if (!dfn[i])
			tarjan(i);
	spfa();
	printf("%d",dis[n]);
	return 0;
}
```
偷懒写的$spfa$和$vector$QAQ

---

## 作者：lianliangyu (赞：2)

### $Tarjan$缩点 + $dijkstra$

显然，依题意可得，~~这道题与正则表达式没有半毛钱关系~~
在有向图中，若一些边形成环的话，那么这些边的边权可全部变成$0$。

所以这题要缩点，把环缩成一个大点，完美解决边权清零的问题。剩下的就是一个$DAG$，我们就跑一遍最短路，找到$1$到$n$的最短路径。

对于最短路，我更喜欢用$dijkstra$。我认为$dijkstra$比$SPFA$会更快一些。

$Code:$
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<stack>
#include<queue>
using namespace std;
const int N=200005;
struct edge
{
	int to,next,waste;
}e[1000005];
int n,m,tot,deep,summ;
int dfn[N],low[N],head[N],color[N],dis[N];
bool visited[N],f;
stack <int> s;
priority_queue <pair<int,int> > q;
template<class type>inline void read(type &k)
{
	k=0;type t=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') t=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {k=k*10+ch-'0';ch=getchar();}
	k*=t;
}
inline void add(int x,int y,int z)
{
	e[++tot].to=y;e[tot].next=head[x];e[tot].waste=z;head[x]=tot;
}
inline void tarjan(int u)
{
	dfn[u]=low[u]=++deep;
	visited[u]=1;s.push(u);
	for(register int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(visited[v]) low[u]=min(low[u],low[v]);
	}
	if(dfn[u]==low[u])
	{
		color[u]=++summ;
		visited[u]=0;
		while(s.top()!=u)
		{
			color[s.top()]=summ;
			visited[s.top()]=0;
			s.pop();
		}
		s.pop();
	}
}
void dijkstra()
{
	memset(dis,0x3f,sizeof(dis));
	memset(visited,false,sizeof(visited));
	q.push(make_pair(0,color[1]));dis[color[1]]=0;
	while(!q.empty())
	{
		int u=q.top().second;q.pop();
		if(visited[u]) continue;
		visited[u]=1;
		for(register int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].waste)
			{
				dis[v]=dis[u]+e[i].waste;
				q.push(make_pair(-dis[v],v));
			}
		}
	}
}
int main()
{
	int i;
	read(n);read(m);
	int x[m+1],y[m+1],z[m+1];
	for(i=1;i<=m;i++)
	{
		read(x[i]);read(y[i]);read(z[i]);
		add(x[i],y[i],z[i]);
	}
	for(i=1;i<=n;i++)
	if(!dfn[i]) tarjan(i);
	tot=0;memset(head,0,sizeof(head));
//	for(i=1;i<=n;i++)
//	cout<<color[i]<<" ";
	for(i=1;i<=m;i++)
	if(color[x[i]]!=color[y[i]])
//	cout<<x[i]<<' '<<y[i]<<endl,
	add(color[x[i]],color[y[i]],z[i]);
	dijkstra();
	printf("%d\n",dis[color[n]]);
	return 0;
}

---

## 作者：睿屿青衫 (赞：2)

###太激动了，间谍网络45分卡了两个小时，这题竟然一遍过！

#说一下思路：这不是个常规的最短路，但你可以拿到部分分：因为开二维数组数据范围会炸

##注意一下是单向边，且如果A与B连通（是不是个走了走又回来了？环？强连通？），那么花费为0.怎么做？tarjan！

##输入不累述，建边的时候注意，因为跑最普通的最短路数组不行，所以我们不要拘泥于tarjan算法建边时两个变量，加上两点间的权值

###跑一遍tarjan，求出强连通分量

##枚举每一条边，若该边两顶点属于同一个强连通分量，那么时间清零（题意，直接赋值即可）

##每一条边都更新好了，跑一遍spfa模板，AC！

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 1000010
#define INF 0x7fffffff
using namespace std;
int head[maxn],team[maxn],exist[maxn],dis[maxn],stack[maxn],qr;
int n,m,color[maxn],top,dfn[maxn],low[maxn],cnt,cnum,vis[maxn];
struct EDGE
{
    int from;
    int next;
    int to;
    int co;
}edge[maxn*3];
void add(int from,int to,int co)
{
    edge[++qr].next=head[from];
    edge[qr].from=from;//这条边的开始点 
    edge[qr].to=to;
    edge[qr].co=co;//两点之间耗费的时间 
    head[from]=qr;
}
void tarjan(int x)//模板 
{
    dfn[x]=low[x]=++cnt;
    vis[x]=1;stack[++top]=x;
    for(int i=head[x];i;i=edge[i].next)
     {
         int v=edge[i].to;
         if(!dfn[v])
          {
              tarjan(v);
              low[x]=min(low[x],low[v]);
          }
         else if(vis[v]) low[x]=min(low[x],dfn[v]);
     }
    if(dfn[x]==low[x])
     {
         cnum++;
         do
         {
             color[stack[top]]=cnum;
             vis[stack[top]]=0;
         }while(stack[top--]!=x);
     }
}
void spfa()
{
    for(int i=1;i<=n;++i)
     {
         dis[i]=INF;
         exist[i]=0;
```
}//个人不推荐memset，可能会有莫名其妙的结果
```cpp
    dis[1]=0;exist[1]=1;team[1]=1;
    int h=0,t=1;
    while(h<t)
     {
         h++;
         int u=team[h];exist[u]=0;
         for(int i=head[u];i;i=edge[i].next)
          {
              int v=edge[i].to;
              if(dis[v]>dis[u]+edge[i].co)
               {
                   dis[v]=dis[u]+edge[i].co;
                   if(!exist[v])
                    {
                        t++;
                        team[t]=v;
                        exist[v]=1;
                    }
               }
          }
     }
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;++i)
     {
         int a,b,c;
         cin>>a>>b>>c;
         add(a,b,c);
     }
    for(int i=1;i<=n;++i)
     if(!dfn[i]) tarjan(i);//其实我A了不少题现在都不理解，就是模板的一部分，背过就好 
    for(int i=1;i<=qr;++i)
     {
         if(color[edge[i].from]==color[edge[i].to])
          {
              edge[i].co=0;//这两个点强连通，不耗费时间 
          }
     }
    spfa();//边都更新好了，放心跑最短路 
    printf("%d",dis[n]);//1到n最少时间 
    return 0;
}
```

---

## 作者：Doubeecat (赞：1)

## 题目链接：

[P2169 正则表达式](<https://www.luogu.org/problem/P2169>)

## 题目描述：

在Internet网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在A到B的连接不一定存在B到A的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在A到B的连接的同时也存在B到A的连接的话，那么A和B实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为0。

现在小Z告诉你整个网络的构成情况，他希望知道从他的电脑（编号为1），到小X的电脑（编号为n）所需要的最短传输时间。

对于100%的数据，$1\leq n\leq200000, 1\leq m\leq 1000000$

## 解题思路：

Tarjan 缩点 + SPFA/DP 

首先观察数据范围，显然这么大的 $n,m$ ，直接跑 $O(nm)$ 的 SPFA 会炸掉。

观察题面，发现如果有 x 和 y 构成一个环（处在同一个 SCC 中），那么他们之间的边长度为 0 

这启发我们可以用缩点后再来跑 SPFA ，但是这样的复杂度是不够严谨的，最坏情况下仍旧是 $O(nm)$ 的，只是由于这题水所以可以过。

## 代码：

SPFA 版本 

```cpp
#include <cstdio>
#include <cctype>
#include <cmath>
#include <stack>
#include <cstring>
#include <queue>
using namespace std;
inline int read() {
	char v = getchar();int x = 0,f = 1;
	while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();}
	while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();}
	return x * f;
}
const int N = 10010;
const int M = 5000010;

int to[M],hd[N],nxt[M],tot,edg[M];
inline void add(int u,int v,int w) {to[++tot] = v;edg[tot] = w;nxt[tot] = hd[u];hd[u] = tot;}

inline int min(int x,int y) {return x<y?x:y;}
inline int max(int x,int y) {return x>y?x:y;}

using std::stack;

int dfn[N],low[N],ins[N],cnt,num,c[N],n,m,p[N],f[N];
stack <int> s;

void tarjan(int x) {
	dfn[x] = low[x] = ++cnt;
	s.push(x);ins[x] = 1;
	for (int i = hd[x];i;i = nxt[i]) {
		if (!dfn[to[i]]) {
			tarjan(to[i]);
			low[x] = min(low[x],low[to[i]]);
		}
		else if (ins[to[i]]) {
			low[x] = min(low[x],dfn[to[i]]);
		}
	}
	if (dfn[x] == low[x]) {
		c[x] = ++num;int y;
		do {
			y = s.top(),s.pop();
			ins[y] = 0;c[y] = num;
		}while (x != y);
	}
}

int vis[N],dis[N];

void SPFA(int s) {
	memset(dis,0x3f,sizeof(dis));
	queue <int> q;
	vis[s] = 1;dis[s] = 0;
	q.push(s);
	while (!q.empty()) {
		int x = q.front();q.pop();
		vis[x] = 0;
		for (int i = hd[x];i;i = nxt[i]) {
			int y = to[i],w = edg[i];
			if (c[x] == c[y]) w = 0;
			if (dis[y] > dis[x] + w) {
				dis[y] = dis[x] + w;
				if (!vis[y]) {
					q.push(y);
					vis[y] = 1;
				}
			}
		}
	}
}

int main() {
	n = read(),m = read();
	for (int i = 1;i <= m;++i) {
		int x = read(),y = read(),w = read();add(x,y,w);
	}
	for (int i = 1;i <= n;++i) if (!dfn[i]) tarjan(i);
	SPFA(1);
	printf("%d",dis[n]);
	return 0;
}

```

---

## 作者：lovewz (赞：1)

这题为什么大佬们都用的SPFA啊，用缩点+拓扑排序就能过了。

其实我已开始也想用SPFA的，但是它死了。于是就看看能不能用拓扑排序。显然，缩完点之后的新图没环，也就是说理论上是能用拓扑排序的。然而从入度为零的点开始拓扑排序会死的很惨，不过直接从起点拓扑排序就能过了。因为这样拓扑排序的话求出来的是在起点能经过的所有点的集和边的集组合的图中的最短路长度，显然这个长度就是原图的最短路长度（因为其他的点和边到都到不了肯定不会是最短路的一部分）

贴上我巨丑的代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>

using namespace std;

const int N = 2e5+5;

inline int read(){//读入挂 
	int ans=0, w = 1;
	char ch = ' ';
	while(ch<'0'||ch>'9'){
		w = ch=='-'?-1:w;
		ch = getchar();
	}
	while(ch>='0'&&ch<='9'){
		ans = ans*10 + ch - 48;
		ch =  getchar();
	}
	return ans*w;
}

struct E{
	int v,w;
};
//各位大佬，蒟蒻我太菜了，不会邻接表 
vector<E> edge[N];//原图 
vector<E> edge1[N];//缩点后的图 

int dfn[N],low[N],Stack[N],inStack[N],top;
int dfstime,SCCcnt;
int belong[N],dp[N],inDegree[N];
int n,m;

void tarjan(int u){//tarjan强联通分量 
	dfn[u] = low[u] = ++ dfstime;
	Stack[++top] = u;
	inStack[u] = 1;
	for(register int i=0;i<edge[u].size();++i){
		int v = edge[u][i].v;
		if(!dfn[v]){
			tarjan(v);
			low[u] = min(low[u],low[v]);
		}
		else if(inStack[v]){
			low[u] = min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		++ SCCcnt;
		int v = -1;
		while(u!=v){
			v = Stack[top--];
			inStack[v] = 0;
			belong[v] = SCCcnt;
		}
	}
}

void init(){
	n = read();
	m = read();
	int u;
	for(register int i=1;i<=m;++i){
		u = read();
		E e;
		e.v = read();
		e.w = read();
		edge[u].push_back(e);
	}
	for(register int i=1;i<=n;++i){
		if(!dfn[i]) tarjan(i);
	}
}

void new_graph(){//缩点、建图 
	for(register int u=1;u<=n;++u){
		for(register int i=0;i<edge[u].size();++i){
			int v = edge[u][i].v;
			int w = edge[u][i].w;
			if(belong[u]==belong[v]){
				continue;
			}
			E e;
			e.v = belong[v];
			e.w = w;
			edge1[belong[u]].push_back(e);
			++ inDegree[belong[v]];
		}
	}
}
void topo(){//拓扑排序 
	memset(dp,0x7f,sizeof dp);
	queue<int> q;
	int s = belong[1]; 
	q.push(s);
	dp[s] = 0;
	while(!q.empty()){
		int u = q.front();
		q.pop();
		for(register int i=0;i<edge1[u].size();++i){
			int v = edge1[u][i].v;
			int w = edge1[u][i].w;
			-- inDegree[v];
			if(!inDegree[v]) q.push(v);
			dp[v] = min(dp[v],dp[u]+w);
		}
	}
}

int main(){
	init();
	
	new_graph();
	
	topo();
	
	printf("%d\n",dp[belong[n]]);
	return 0;
}
```

---

## 作者：abandentsky (赞：0)

楼下各位大佬太强了。题目中说如果能相互到达花费就为0.这样我们求一遍强连通分量，之后缩点就好了。完了跑一边最短路径算法就好了。求强连通分量使用tarjarn算法（需要消除自环）。最短路算法需要使用dijkstra算法。看楼下各位代码那么短，太厉害了。
```c
#include<stdio.h>
#include<string.h>
#include<vector>
#include<queue>
#include<stack>
#include<algorithm>
#include<iostream>
#define MAXN 200005
#define INF 0x3f3f3f3f
using namespace std;

struct Edge
{
    int from,to,dist;
    Edge(int from=0,int to=0,int dist=0):from(from),to(to),dist(dist){};
};
vector<Edge> edges;
vector<int> G[MAXN];
vector<Edge> mmp;                //重新构图
vector<int> Map[MAXN];     //重新建图
stack<int> S;
int pre[MAXN],sccno[MAXN],lowlink[MAXN],in[MAXN];
int d[MAXN];
int dfs_clock,scc_cnt;
int n,m;

void dfs(int u)
{
    S.push(u);
    pre[u]=lowlink[u]=++dfs_clock;
    for(int i=0;i<G[u].size();i++)
    {
        Edge &e=edges[G[u][i]];
        int v=e.to;
        if(!pre[v])
        {
            dfs(v);
            lowlink[u]=min(lowlink[u],lowlink[v]);
        }
        else if(!sccno[v])
        {
            lowlink[u]=min(lowlink[u],pre[v]);
        }
    }
    if(pre[u]==lowlink[u])
    {
        ++scc_cnt;
        for(;;)
        {
            int x=S.top();
            S.pop();
            sccno[x]=scc_cnt;
            if(u==x)
                break;
        }
    }
}

void Find_Scc(int n)
{
    scc_cnt=dfs_clock=0;
    memset(sccno,0,sizeof(sccno));
    memset(pre,0,sizeof(pre));
    memset(in,0,sizeof(in));              //用来统计缩点后的入度
    for(int i=1;i<=n;i++)
    {
        if(!pre[i])
           dfs(i);
    }
    for(int i=0;i<edges.size();i++)
    {
        int xx=edges[i].from;
        int yy=edges[i].to;
        if(sccno[xx]!=sccno[yy])
        {
            mmp.push_back({sccno[xx],sccno[yy],edges[i].dist});
            //printf("test:%d->%d %d\n",sccno[xx],sccno[yy],edges[i].dist);
            int mm=mmp.size();
            Map[sccno[xx]].push_back(mm-1);
        }
    }
}

struct Heapnode
{
    int u,dis;
    Heapnode(int u=0,int dis=0):u(u),dis(dis){};
    bool operator < (const Heapnode &rah) const
    {
        return dis>rah.dis;
    }
};

void dijkstra(int n)
{
    priority_queue<Heapnode> Q;
    Q.push({sccno[1],0});
    for(int i=1;i<=scc_cnt;i++)
        d[i]=INF;
    d[sccno[1]]=0;
    while(!Q.empty())
    {
        Heapnode X=Q.top();
        Q.pop();
        for(int i=0;i<Map[X.u].size();i++)
        {
            Edge &e=mmp[Map[X.u][i]];
            //printf("ok\n");
            if(d[e.to]>e.dist+X.dis)
            {
                d[e.to]=e.dist+X.dis;
                //printf("ok\n");
                Q.push({e.to,d[e.to]});
            }
        }
    }
    printf("%d\n",d[sccno[n]]);
    //for(int i=1;i<=n;i++)
        //printf("%d ",sccno[i]);
}

int main()
{
    scanf("%d %d",&n,&m);
    int u,v,w;
    for(int i=0;i<m;i++)
    {
        scanf("%d %d %d",&u,&v,&w);
        if(u==v)
            continue;
        edges.push_back({u,v,w});
        int mm=edges.size();
        G[u].push_back(mm-1);
    }
    Find_Scc(n);
    dijkstra(n);
    return 0;
}

```


---

## 作者：LlLlCc (赞：0)

题意简介明了，大概就是：给你n个节点，m条有向边，可互相到达的两个节点之间路径为0，让你求出1到n的最短路。

**在有向图中，如果A和B可以互相到达，即A和B在同一环里，环里的所有节点之间的路径都为0**

所有，我们可以用**tarjan**来求出每个节点所在的环，将每个环视为一个节点。然后刷一趟**1所在的节点**到**n所在的节点**的最短路即可。

不会tarjan的看着：[tarjan详解](https://blog.csdn.net/qq_34374664/article/details/77488976)

至于**刷最短路**，SPFA（~~**对，他没死**~~）

代码：
```
#include<bits/stdc++.h>
#define maxn 200005
#define maxm 1000005
using namespace std;
int n,m,tot,son[maxm],lnk[maxn],nxt[maxm],w[maxm],TOT,SON[maxm],LNK[maxn],NXT[maxm],W[maxm],num,cnt,top,st[maxn],dfn[maxn],low[maxn],id[maxn],dis[maxn],que[maxn];
bool vis[maxn];
inline int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
inline void add(int x,int y,int z){son[++tot]=y,nxt[tot]=lnk[x],lnk[x]=tot,w[tot]=z;}
inline void ADD(int x,int y,int z){SON[++TOT]=y,NXT[TOT]=LNK[x],LNK[x]=TOT,W[TOT]=z;}
inline int min(int x,int y){return x<y?x:y;}
inline void Tarjan(int x){
    dfn[x]=low[x]=++num;
    st[++top]=x;
    for(int j=lnk[x];j;j=nxt[j]){
        int y=son[j];
        if(!dfn[y]){
            Tarjan(y);
            low[x]=min(low[x],low[y]);
        }else
        if(!id[y]) low[x]=min(low[x],dfn[y]);
    }
    if(dfn[x]==low[x]){
        id[x]=++cnt;
        while(st[top]!=x) id[st[top--]]=cnt;
        top--;
    }
}
inline void SPFA(){
    int hed=0,til=1;
    memset(dis,63,sizeof dis);
    que[1]=id[1];
    dis[id[1]]=0;
    vis[id[1]]=1;
    while(hed!=til){
        vis[que[hed=(hed+1)%maxn]]=0;
        int x=que[hed];
        for(int j=LNK[x];j;j=NXT[j]){
            int y=SON[j];
            if(dis[y]<=dis[x]+W[j]) continue;
            dis[y]=dis[x]+W[j];
            if(!vis[y]){
                vis[y]=1;
                que[til=(til+1)%maxn]=y;
                int nt=(hed+1)%maxn;
                if(dis[que[nt]]>dis[que[til]]) swap(que[til],que[nt]);
            }
        }
    }
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=m;i++){
        int x=read(),y=read(),z=read();
        add(x,y,z);
    }
    for(int i=1;i<=n;i++) if(!id[i]) Tarjan(i);
    for(int i=1;i<=n;i++)
    for(int j=lnk[i];j;j=nxt[j])
    if(id[i]!=id[son[j]]) ADD(id[i],id[son[j]],w[j]);
    SPFA();
    printf("%d\n",dis[id[n]]);
    return 0;
}
```


---

## 作者：xukuan (赞：0)

算法：缩点+单源最短路

首先处在同一个环内的点之间距离为0，这样我们就可以跑一个缩点，把处于同一个环内的点变成一个点

这样就是一个DAG上求单源最短路的模板了

算法：tarjan+dijkstra

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

ll n,m,ans,d[200010],x[2000010],y[2000010],z[2000010];
ll ver[2000010],edge[2000010],Next[2000010],head[2000010],tot;
//缩点前的链式前向星存图
ll _ver[2000010],_edge[2000010],_Next[2000010],_head[2000010],_tot;
//缩点后的链式前向星存图
ll dfn[200010],low[200010],deep,v[200010],colour[200010],color;
stack<ll> st;
priority_queue<pair<ll,ll> > q;

inline ll read(){//读入优化
	ll x=0,tmp=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') tmp=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return tmp*x;
}

inline void addEdge(ll x,ll y,ll z){//缩点前的图加边
	ver[++tot]=y;
	edge[tot]=z;
	Next[tot]=head[x];
	head[x]=tot;
}

inline void _addEdge(ll x,ll y,ll z){//缩点后的图加边
	_ver[++_tot]=y;
	_edge[_tot]=z;
	_Next[_tot]=_head[x];
	_head[x]=_tot;
}

void tarjan(ll x){//tarjan找出哪些点在同一个环内
	dfn[x]=low[x]=++deep;
	v[x]=1; st.push(x);
	for(ll i=head[x]; i; i=Next[i]){
		ll y=ver[i];
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else{
			if(v[y]) low[x]=min(low[x],low[y]);
		}
	}
	if(dfn[x]==low[x]){
		colour[x]=++color;
		v[x]=0;
		while(st.top()!=x){
			colour[st.top()]=color;
			v[st.top()]=0;
			st.pop();
		}
		st.pop();
	}
}

inline void rebuild(){//缩点后重新建图
	for(ll i=1; i<=m; i++){
		if(colour[x[i]]!=colour[y[i]]) _addEdge(colour[x[i]],colour[y[i]],z[i]);
	}
}

inline void dijkstra(ll s){//单源最短路
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	d[s]=0; q.push(make_pair(0,s));
	while(!q.empty()){
		ll x=q.top().second; q.pop();
		if(v[x]) continue;
		v[x]=1;
		for(ll i=_head[x]; i; i=_Next[i]){
			ll y=_ver[i],z=_edge[i];
			if(d[y]>d[x]+z){
				d[y]=d[x]+z;
				q.push(make_pair(-d[y],y));
			}
		}
	}
}

int main(){
	n=read(); m=read();
	for(ll i=1; i<=m; i++){
		x[i]=read(); y[i]=read(); z[i]=read();
		addEdge(x[i],y[i],z[i]);
	}
	for(ll i=1; i<=n; i++){
		if(!dfn[i]) tarjan(i);
	}
	rebuild();
	dijkstra(colour[1]);
	cout<<d[colour[n]]<<endl;
	return 0;
}
```

---

## 作者：Zekrom (赞：0)

两步：   
1.tarjan求出强连通分量，由题意强联通分量内的点0距离  
2.缩点后求最短路  
注意细节，上代码  
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 200010
#define M 1000010
#define inf 0x3f3f3f3f 
using namespace std;
int n,m,top,num,cnt,dfn[N],low[N],stack[N],tot,head[N],c[N],all[N],ans,tot2,ru[N],H[N],d[N];
bool ins[N],vis[N];
struct Edge{
	int v,u,next,val;
}edge[M],E[M];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return  x*f;
}
inline void add(int x,int y,int z){edge[++tot].v=y;edge[tot].next=head[x];head[x]=tot;edge[tot].u=x;edge[tot].val=z;}
inline void add2(int x,int y,int z){E[++tot2].v=y;E[tot2].next=H[x];H[x]=tot2;ru[y]++;E[tot2].val=z;} 
void tarjan(int x){
	dfn[x]=low[x]=++num;
	stack[++top]=x;ins[x]=1;
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].v;
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y]){
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(dfn[x]==low[x]){
		cnt++;int z;
		do{
			z=stack[top--];
			c[z]=cnt;
			ins[z]=0;all[cnt]++;
		}while(z!=x); 
	}
}
void spfa(int x){
	queue<int>q;
	for(int i=1;i<=cnt;i++)d[i]=inf;
	q.push(x);vis[x]=1;d[x]=0;
	while(q.size()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=H[u];i;i=E[i].next){
			int y=E[i].v,z=E[i].val;
			if(d[y]>d[u]+z){
				d[y]=d[u]+z;
				if(!vis[y])q.push(y),vis[y]=1;
			}
		}
	}
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read(),z=read();
		add(x,y,z);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i);
	for(int i=1;i<=tot;i++)
	{
		int u=edge[i].u,v=edge[i].v;
		if(c[u]!=c[v])	add2(c[u],c[v],edge[i].val);  //缩点
	}
	spfa(c[1]);//最短路
	printf("%d\n",d[c[n]]); 
	return 0;
}

```


---

## 作者：Tiffany_Tendering (赞：0)

###     tarjna缩点（模板） + spfa板子
       
       分析题意我们知道 
       1 该图为有向图
       2 如果处于同一个强连通分量之中 价值即为0 因此我们可以实行缩点
     
       缩点的一个很重要的条件就是   缩点后形成会一个点 需要保证原来的点是没有用的了
       
      本人缩点的习惯(比较水... ...  因为有75ms... ...)
      



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<stack>
using namespace std;
const int maxn = 200005;
const int maxm = 1000005;
int n,m,head[maxn],cnt,dfn[maxn],low[maxn],top,indexx,belong[maxn];
int head2[maxn],top2,dis[maxn];
bool instack[maxn],vis[maxn];
struct edge{
	int to,next,value,from ;
}e[maxm],e2[maxm];
stack< int > s;
void add_edge(int u,int v,int w) {
	e[++top].to = v;
	e[top].from = u;
	e[top].next = head[u] ;
	e[top].value = w ;
	head[u] = top ;
}

void add_edge2(int u,int v,int w) {
	e2[++top2].to = v;
	e2[top2].next = head2[u] ;
	e2[top2].from = u;
	e2[top2].value = w;
	head2[u] = top2;
}

void tarjan(int u) {
	dfn[u] = low[u] = ++indexx ;
	s.push(u) ; instack[u] = 1;
	for(int i = head[u]; i ;i = e[i].next) {
		if(!dfn[e[i].to]) {
			tarjan(e[i].to) ;
			low[u] = min(low[u] , low[e[i].to]) ;
		}
		else
		  if(instack[e[i].to])
		     low[u] = min(low[u] , low[e[i].to]) ;
	}
	if(dfn[u] == low[u]) {
		cnt++;
		while(s.top() != u) {
			int k = s.top() ; s.pop();
			instack[k] = 0;
			belong[k] = cnt;
		}
		s.pop() ;
		instack[u] = 0;
		belong[u] = cnt;
	}
}

void spfa(int s) {
	queue< int >q;
	for(int i = 1;i <= cnt ;++i) dis[i] = 1e9 ;
	vis[s] = 1;  dis[s] = 0;
	q.push(s) ;
	while(!q.empty()) {
		int u = q.front() ; q.pop() ;
		for(int i = head2[u]; i ;i = e2[i].next) 
		  if(dis[e2[i].to] > dis[u] + e2[i].value) {
		  	dis[e2[i].to] = dis[u] + e2[i].value ;
		  	if(!vis[e2[i].to]) {
		  		q.push(e2[i].to) ;
		  		vis[e2[i].to] = 1;
			  }
		  }
	}
}

int main() {
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= m ;++i) {
		int x,y,z; scanf("%d%d%d",&x,&y,&z) ;
		add_edge(x,y,z) ;
	}
	for(int i = 1;i <= n ;++i) 
       if(!dfn[i]) tarjan(i) ;
	for(int i = 1;i <= m ;++i) {
		if(belong[e[i].to] == belong[e[i].from]) continue ;
		add_edge2(belong[e[i].from],belong[e[i].to],e[i].value) ;
	}
	spfa(belong[1]) ;
	printf("%d",dis[belong[n]]) ;
	return 0;
}
```

---

## 作者：荣一鸣 (赞：0)

求强联通分量+最短路

强连通分量用tarjan，用pre和low两个数组标记任意一个在dfs中的点（初始值赋为访问到的顺序），并用栈记录走过的点。pre存该点初次访问的数据，而low则储存该点的直接联通节点的最小的先序编号，即该点的所有有回边（即单向边的终点的pre小于起点）的直接连通节点的回边的终点的pre的最小值。

若low[x]==pre[x]，则从栈顶到该点的点都是该强连通分量的节点。而一个强连通分量内的点之间互相链接的点都可以0时间传输，便将其t改变为0

然后就是SPFA了。

so easy

```cpp
#include<stdio.h>
#include<iostream>
#include<cstdio>
#include<vector>
#include <algorithm>
#include<queue>
#include<stack>
using namespace std;

const int INF=0x7fffffff;
struct Edge{
	int f,to,ti;
	bool operator <(const Edge b)const{
		return ti>b.ti;
	}
};
vector<Edge> g[200010];
Edge E;
int n,m;
stack<int> st;
int vi[1000010];
int vt[1000010];
int d[200010];
int pa[200010];
int pre[200010];
int low[200010];
int tikd=0;
int sccnt[200010];
int scc_cnt=0;

void dfs(int u){
	pre[u]=low[u]=++tikd;
	st.push(u);
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].to;
		if(pre[v]==0){
			dfs(v);
			low[u]=min(low[u],low[v]);
		}
		else if(sccnt[v]==0){
			low[u]=min(low[u],pre[v]);
		}
	}
	if(low[u]==pre[u]){
		scc_cnt++;
		int l=0;
		while(l!=u){
			l=st.top();
			sccnt[l]=scc_cnt;
			st.pop();
		}
	}
}

void dfsd(){
	queue<int> q;
	d[1]=0;
	vi[1]=1;
	q.push(1);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vi[u]=0;
		for(int i=0;i<g[u].size();i++){
			Edge e=g[u][i];
			if(sccnt[e.f]==sccnt[e.to]){
				e.ti=0;
			}
			if(d[e.to]>d[u]+e.ti){
				d[e.to]=d[u]+e.ti;
				if(vi[e.to]==0){
					vi[e.to]=1;
					q.push(e.to);
				}
			}
		}
	}
}

int main(){;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) d[i]=INF;
	for(int i=1;i<=m;i++){
		int f;
		scanf("%d%d%d",&E.f,&E.to,&E.ti);
		g[E.f].push_back(E);
	}
	dfs(1);
	dfsd();
	printf("%d",d[n]);
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：0)

题意概述：

给定一张n个点m条边的无负权有向图

同一个强连通分量中的所有点无需花费

求1到n的最短路

算法：强连通分量+最短路

采用tarjan+dijkstra+heap

楼下似乎有类似的方法，但是代码tql

蒟蒻再给个代码

差不多是模版题，只需在dij的更新中添加一条判定：

若两点处于同个强连通分量当中，则边权为0

```cpp
#include<queue>
#include<stack>
#include<cstdio>
#include<climits>  //duliu库\\\可以无需自己定义INT_MAX 
#include<algorithm>
using namespace std;
template<class T>inline void read(T &x); //读入优化 
const int N=200001,M=1000001;
int n,m,cnt,head[N],low[N],dfn[N],num[N],dis[N];
//num[i]代表i号点所处的强连通分量的编号 
bool f[N]; //同时作为tarjan的instack和dijkstra的visit 
stack<int>s;
struct edge{int to,w,next;}e[M];
struct heap //定义堆 
{
	int id,dis;
	bool operator<(const heap &fantasy)const //重载运算符 
	{
		return dis>fantasy.dis;
	}
};
priority_queue<heap>q;
inline void add(int a,int b,int c) //建边 
{
	e[++cnt].next=head[a];
	head[a]=cnt;
	e[cnt].to=b;
	e[cnt].w=c;
}
void tarjan(int p) //tarjan模版，不解释 
{
	low[p]=dfn[p]=++cnt;
	s.push(p);f[p]=1;
	for (int x,i=head[p];i;i=e[i].next)
		if (!dfn[x=e[i].to])
			tarjan(x),low[p]=min(low[x],low[p]);
		else
			if (f[x])low[p]=min(low[x],low[p]);
	if (dfn[p]!=low[p])return;
	while (s.size())
	{
		int x=s.top();s.pop();
		num[x]=p;f[x]=0;
		if (p==x)break;
	}
}
void dijkstra() //dij模版，稍有改动 
{
	fill(dis+2,dis+n+1,INT_MAX); //fill…跟memset差不多，只不过是按地址填充，好理解 
	fill(f+1,f+n+1,0);
	q.push((heap){1,0});
	while (q.size())
	{
		int p=q.top().id;q.pop();
		if (f[p])continue;f[p]=1;
		for (int i=head[p];i;i=e[i].next)
		{
			int k=e[i].to;
			if (num[k]==num[p])e[i].w=0; //如果在同一个强连通分量中，边权为0 
			if (dis[p]+e[i].w<dis[k])
				dis[k]=dis[p]+e[i].w,
				q.push((heap){k,dis[k]});
		}
	}
}
int main()
{
	read(n);read(m);
	while (m--)
	{
		int a,b,c;
		read(a);read(b);read(c);
		add(a,b,c);
	}
	cnt=0;
	for (int i=1;i<=n;i++)
		if (!dfn[i])tarjan(i);
	dijkstra();
	printf("%d",dis[n]);
	return 0;
}
template<class T>inline void read(T &x)
{
	x=0;char ch=getchar();int fh=1;
	while (ch<48||ch>57)
		fh=ch=='-'?-1:fh,ch=getchar();
	while (ch>47&&ch<58)
		x=(x<<3)+(x<<1)+ch-48,ch=getchar();
	x*=fh;
}
```

---

## 作者：首相大大 (赞：0)

### 思路
由题得,在一个强连通分量里互相传递信息是不需要时间的

所以我们求出图中的所有强连通分量,缩点建一个新图,在新图中跑最短路算法即可

楼下题解最短路算法均使用的`SPFA`,在此给出`Dijkstra`算法

### `CODE`
```
/*Do not go gentle into that good night*/
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <ext/pb_ds/priority_queue.hpp>
#define ll long long
using namespace std;
typedef pair<ll,int> pii;
struct edge{int v,nxt;ll w;};
edge e[1000005],E[1000005];
int n,idx,cnt,top,k,head[200005],dfn[200005],low[200005];
int k1,head1[200005],bel[200005],st[200005];
bool ins[200005],vis[200005];ll dis[200005];
inline int Min(int x,int y){return x < y ? x : y;}
inline void add_edge(int u,int v,ll w)
{
	e[++k].v = v,e[k].w = w;
	e[k].nxt = head[u],head[u] = k;
}
inline void add_edge1(int u,int v,ll w)
{
	E[++k1].v = v,E[k1].w = w;
	E[k1].nxt = head1[u],head1[u] = k1;
}
void tarjan(int u)
{
	int v;dfn[u] = low[u] = ++idx,ins[st[++top] = u] = 1;
	for(register int i(head[u]);i;i = e[i].nxt)
	{
		if(!dfn[v = e[i].v]) tarjan(v),low[u] = Min(low[u],low[v]);
		else if(ins[v] && dfn[v] < low[u]) low[u] = dfn[v];
	}
	if(dfn[u] == low[u])
	{
		++cnt;
		do
		{
			bel[v = st[top]] = cnt;
			ins[v] = 0;
		}while(st[top--] != u);
	}
}
inline void build()//用强连通分量建图,注意变量名别打错了....
{
	for(register int u(1);u <= n;u++)
		for(register int i(head[u]);i;i = e[i].nxt)
			if(bel[u] != bel[e[i].v]) add_edge1(bel[u],bel[e[i].v],e[i].w);
}
inline ll dijkstra()
{
	int u(bel[1]),v;//起点是点1所在的强连通分量,终点同理
	memset(dis,0x3f3f3f3f,sizeof(dis));
	__gnu_pbds::priority_queue<pii,greater<pii> > q;
	dis[u] = 0;q.push(make_pair(0,u));
	while(!q.empty())
	{
		u = q.top().second,q.pop();
		if(vis[u]) continue;vis[u] = 1;
		for(register int i(head1[u]);i;i = E[i].nxt)
			if(dis[v = E[i].v] > dis[u] + E[i].w) 
				dis[v] = dis[u] + E[i].w,q.push(make_pair(dis[v],v));
	}
	return dis[bel[n]];
}
int main()
{
	int m,u,v;ll ans,w;
	cin>>n>>m;
	for(register int i(1);i <= m;i++)
		scanf("%d%d%lld",&u,&v,&w),add_edge(u,v,w);
	for(register int i(1);i <= n;i++)
		if(!dfn[i]) tarjan(i);
	if(bel[1] == bel[n]) ans = 0;//属于一个强连通分量
	else build(),ans = dijkstra();
	printf("%lld",ans);
	return 0;
}
```
`PrimeMinister of GE All Rights Reserved`

`Feb 24th`

---

## 作者：陈新月 (赞：0)

思路：

这题的话，其实不难，类似于模板题，我的思路是Tarjan+spfa，在用Tarjan算法计算出强连通分量之后就缩点并建立一张新的图，之后我们再用spfa算法算出最短路即可，代码中部分细节已经注释


以下为代码









    

    
      

    
        



```cpp
#include<cstdio>
#include<algorithm>
#include<stack>
#include<queue>
#include<cstring>
#define N 200009 
#define M 1000009
using namespace std;
int en,en1,n,m;                                  //en为旧图，en1为新图 ，下面同理 
int t,cnt,low[N],dfn[N],belong[N];
bool instack[N];
stack<int> sta;
int dist[N];
bool inque[N];
struct edge{
    int e,d;
    edge *next;
}*v[N],ed[M],*v1[N],ed1[M];
void add_edge(int s,int e,int d){
    en++;
    ed[en].next = v[s],v[s] = ed+en,v[s]->e =e ;
    ed[en].d = d;
}
void add_edge1(int s,int e,int d){
    en1++;
    ed1[en1].next = v1[s],v1[s] = ed1+en1,v1[s]->e = e;
    ed1[en1].d = d;
}
void dfs(int now){                        //Tarjan算法，计算强连通分量 
    t++;
    low[now] = dfn[now] = t;
    instack[now] = true;
    sta.push(now);
    for(edge *e = v[now];e;e = e->next)
      if(!dfn[e->e]){
            dfs(e->e);
            low[now] = min(low[now],low[e->e]);
      }
      else if(instack[e->e])low[now] = min(low[now],dfn[e->e]);
    if(dfn[now] == low[now]){
        cnt++;
        while(sta.top() != now){
            instack[sta.top()] = false;
            belong[sta.top()] = cnt;
            sta.pop();
        }
        sta.pop();
        belong[now] = cnt;
        instack[now] = false;
    }
}
void tarjan(){
    for(int a = 1; a <= n; a++)
      if(!dfn[a])dfs(a);
    for(int a = 1; a <= n; a++)                    //缩点过程 
      for(edge *e = v[a];e;e =e->next)
         if(belong[a] != belong[e->e])
            add_edge1(belong[a],belong[e->e],e->d);
}
void spfa(int s){                              //spfa算法，求单源最短路 
    memset(dist,0x3f,sizeof(dist));
    dist[s] = 0;
    queue<int>que;
    inque[s] = true;
    que.push(s);
    while(que.size()){
        int now = que.front();
        que.pop();
        inque[now] = false;
        for(edge *e = v1[now];e;e=e->next)
          if(dist[e->e] > dist[now] + e->d){
                  dist[e->e] = dist[now] +e->d;
                  if(!inque[e->e]){
                      que.push(e->e);
                      inque[e->e] = true;
                  }
          }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= m; i++){
        int x,y,w;
        scanf("%d%d%d",&x,&y,&w);
        add_edge(x,y,w);
    }
    tarjan();
    spfa(belong[1]);                             //新图中起点为旧图中1点所处的强连通分量编号 
    printf("%d\n",dist[belong[n]]);              //答案为旧图中n点所处强连通分量编号的距离即为最短路 
    return 0;
}

```

---

## 作者：王将飞扬Cliffly (赞：0)

标准的SCC  Tarjan +spfa （或其他最短路算法）模版

邻接表还是很好用的，至少不会一堆变量看得头皮发麻

入门同学（像我这样）还是推荐这样写比较方便

详情看代码



```cpp
#include<bits/stdc++.h>
#define rep(i,j,n) for(int i=j;i<=n;i++)
#define R register
using namespace std;
inline int read(){ //读入优化
    int x; char ch; 
    while(ch=getchar() , ch>'9'||ch<'0') ; x=ch-'0';
    while(ch=getchar() ,ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0';
    return x;
}
const int N=200010, M=1000010;
struct edge{
    int next,to,w;    //标准邻接表
}e[M];
int n,m,x,y,tot,cnt,stk[N],belong[N],tim,top,dfn[N],low[N],head[N];  //belong表示点所属的scc编号
bool instk[N];   //判断是否在栈中，其实有些累赘。。。
inline void ins(int x, int y,int w) {
    tot++; e[tot]=edge{head[x],y,w} ; head[x]=tot;
}
inline void Tarjan(int now) {
    dfn[now]=low[now]=++tim;
    stk[++top]=now; instk[now]=true;
    for(int i=head[now];i;i=e[i].next) {
        int v=e[i].to;
        if(instk[v]) low[now]=min(low[now],dfn[v]) ;
        else if(!dfn[v]) Tarjan(v), low[now]=min(low[now],low[v]);
    }
    if(dfn[now]==low[now]) {
        cnt++; belong[now]=cnt;
        for( ; stk[top]!=now; top--) {
            instk[top]=false;
            belong[stk[top]]=cnt;
        }
        instk[now]=false; top--;
    }
}
queue<int> q;
int dis[N];     bool vis[N];
inline void spfa(){
    memset(dis,0x7f,sizeof(dis));   //别忘初始化
    memset(vis,0,sizeof(vis));
    dis[1]=0; q.push(1) ; vis[1]=true;
    while(!q.empty()) {
        int x=q.front() ; q.pop() ; vis[x]=false;
        for(int i=head[x];i;i=e[i].next) {   //邻接表遍历边
            int v=e[i].to;
            if(belong[v]==belong[x]) e[i].w=0;  // 若处在同一scc中，那其边权可直接视为0
            if(dis[v]>dis[x]+e[i].w) {
                dis[v]=dis[x]+e[i].w;
                if(!vis[v]) {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
}
int main(){
    n=read(); m=read();
    int u,v,w;
    rep(i,1,m) u=read(), v=read(), w=read() , ins(u,v,w) ;
    Tarjan(1);
    spfa();
    printf("%d\n",dis[n]) ;
    return 0;
}
```

---

## 作者：Orion_Rigel (赞：0)

首先缩点，一个强连通分量里的点是不需要花费时间，只需要用不在同一强连通分量的点跑一边最短路就是正确的答案了。

用来练手还是不错的

···
```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;
int h[1000001],fr[1000001],w[1000001],ne[1000001],to[1000001],en=0;
int dfn[200001],low[200001],ins[200001],sta[200001],idx=0,top=0;
int bel[200001],vcnt=0;
int h2[1000001],w2[1000001],to2[1000001],ne2[1000001],en2=0;
int inq[1000001],dis[1000001];
queue<int>q;
int n,m; 
inline void add2(int a,int b,int c)
{to2[en2]=b;ne2[en2]=h2[a];w2[en2]=c;h2[a]=en2++;}
inline void add(int a,int b,int c)
{fr[en]=a;to[en]=b;ne[en]=h[a];w[en]=c;h[a]=en++;}
inline void dfs(int k)
{
    dfn[k]=low[k]=++idx;
    ins[k]=1;sta[++top]=k;
    for (int i=h[k];i>=0;i=ne[i])
    {
        if (!dfn[to[i]])
        {
            dfs(to[i]);
            low[k]=min(low[k],low[to[i]]);
        }
        else if (ins[to[i]]) low[k]=min(low[k],dfn[to[i]]);
    }
    if (dfn[k]==low[k])
    {
        int x=-1;
        vcnt++;
        while (x!=k)
        {
            x=sta[top--];
            bel[x]=vcnt;
            ins[x]=0;
        }
    }
    return ;
}
inline void SPFA()
{
    memset(dis,0x3f,sizeof dis);
    int S=bel[1],T=bel[n];
    dis[S]=0;inq[S]=1;
    q.push(S);
    while (!q.empty())
    {
        int x=q.front();q.pop();inq[x]=0;
        for (int i=h2[x];i>=0;i=ne2[i])
        {
            if (dis[to2[i]]>dis[x]+w2[i])
            {
                dis[to2[i]]=dis[x]+w2[i];
                if (!inq[to2[i]])
                {
                    inq[to2[i]]=1;
                    q.push(to2[i]);
                }
            }
        }
    }
    printf("%d\n",dis[T]);
    return ;
}
int main()
{
    memset(h,-1,sizeof h);
    memset(h2,-1,sizeof h2);
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;++i)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
    }
    dfs(1);
    for (int i=0;i<en;++i)
    if (bel[fr[i]]!=bel[to[i]]) add2(bel[fr[i]],bel[to[i]],w[i]);
    SPFA();
    return 0;
}
···
```

---

## 作者：Kwork (赞：0)

-------------------------------明明要用缩点+最短路，强行被评价普及-，AC的人还这么少-------------------------------------------------------

根据题意：给一个有向图G，求出1，n之间的最短路，对于一对强联通分量，之间的权值可以为0。

具体思路：通过Kosaraju算法（其它分解算法也可以吧，感觉这个scc算法比较容易记，两个dfs）将图强联通分解，每一个点会得到一个自己联通编号（不属于强联通块的点有唯一的编号，同一个联通块内的点编号相同），然后对图做一遍最短路，对于要进行松弛操作的两个点，如果是同一联通块内的，d[v]=min{d[v],d[u]},否则d[v]=min{d[v],d[u]+edge\_w}。

---------------------------------------------个人吐槽洛谷数据--------管理员审完可以删掉下面的吐槽--------------------------------------------

在我写完100行的代码后，翻此题的AC记录时，发现最早AC的洛谷er（luoguer？）用了错误的算法过了这题（仔细一看才发现他有关于缩环的操作：记录一个点的入度，如果这一点的入度超过1就把它判为在环中将之后的边权值全归0），老实人自己YY了一个数据分分钟卡掉了他的算法（手动给他加了个路径还原发现完全错误！！！）。已经不是第一次遇到非常水的数据了，洛谷对于题目data的审核也需要注意啊。（可能比较麻烦，让我过过吐槽瘾。。。）

附上个人YY的数据。

13 18
1 2 11
1 11 16

1 12 3
2 3 5
3 4 9
4 5 5
4 7 2
5 6 1
6 4 3
7 8 3
8 2 2
8 3 7
4 9 1
9 10 5
10 13 3

11 12 4

12 13 17

11 13 5

-------------------------------------------蜜汁code分割线---------大括号不换行党，不喜勿阅----------------------------------------------------

/\*804ms /  29.58MB 用时比较长，可能是评测机状态不好，或者spfa慢？应该是提交的姿势不对。。。。\*/




    

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <queue>
#include <algorithm>
using namespace std;
const int maxn=200000+50;
struct edge{int to, w;};
vector<edge>G[maxn];
vector<edge>rG[maxn];
vector<int>vs;
queue<int>que;
int used[maxn],n,m,tot,cmp[maxn],d[maxn];
void add_edge(int u,int v,int w){
    edge e;
    e.to=v;e.w=w;
    G[u].push_back(e);
    e.to=u;
    rG[v].push_back(e);
    return;
}
void init(){
    int u,v,w;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&u,&v,&w);
        add_edge(u,v,w);
    }
    return;
}
void dfs(int v){
    used[v]=1;
    for(int i=0;i<G[v].size();i++){
        if(!used[G[v][i].to]) 
            dfs(G[v][i].to);
    }
    vs.push_back(v);
    return;
}
void rdfs(int v,int k){
    used[v]=1;
    cmp[v]=k;
    for(int i=0;i<rG[v].size();i++){
        if(!used[rG[v][i].to]) 
            rdfs(rG[v][i].to,k);
    }
    return;
}
void scc(){
    memset(used,0,sizeof(used));
    vs.clear();
    for(int v=1;v<=n;v++){
        if(!used[v]) dfs(v);
    }
    memset(used,0,sizeof(used));
    int k=0;
    for(int i=vs.size()-1;i>=0;i--)
        if(!used[vs[i]]) rdfs(vs[i],++k);
    return;
}
void spfa(){
    for(int i=1;i<=n;i++) used[i]=0,d[i]=87654321;
    que.push(1);d[1]=0;used[1]=1;
    while(!que.empty()){
        int u=que.front();que.pop();
        used[u]=0;
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].to,w=G[u][i].w;
            if(cmp[u]==cmp[v]) w=0;
            int temp=d[u]+w;
            if(temp<d[v]){
                d[v]=temp;
                if(!used[v]){
                    used[v]=1;
                    que.push(v);
                }
            }
        }
    }
    printf("%d",d[n]);    
    return;
}
void solve(){
    scc();
    spfa();
    return;
}
int main(){
    freopen("1.txt","r",stdin);
    freopen("2.txt","w",stdout);
    init();
    solve();
    return 0;
}
```

---


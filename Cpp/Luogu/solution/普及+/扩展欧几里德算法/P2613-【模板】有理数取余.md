# 【模板】有理数取余

## 题目描述

给出一个有理数 $c=\frac{a}{b}$，求 $c \bmod 19260817$ 的值。

这个值被定义为 $bx\equiv a\pmod{19260817}$ 的解。

## 说明/提示

对于所有数据，保证 $0\leq a \leq 10^{10001}$，$1 \leq b \leq 10^{10001}$，且 $a, b$ 不同时是 $19260817$ 的倍数。

## 样例 #1

### 输入

```
233
666
```

### 输出

```
18595654
```

# 题解

## 作者：学委 (赞：481)

*2019-02-22 更新*

分数取余？我不知道是什么概念。分子分母还特别大？

一步一步来。

**考虑一下，分数取余也要满足取余运算的性质！**

取余运算的性质有：

* **如果两个数对模 $p$ 同余，那么它们乘上同一个数以后依然对模 $p$ 同余。$(I)$**

所以，虽然我不知道分数取余是什么，但是如果

$x \equiv \frac{a}{b} \pmod p$ （满足此方程的 $x$ 有多个，本题实际上是要求**最小的正整数解**，求出任意一个 $x$ ，模 $p$ 后即本题答案）

那么根据 $(I)$，它可以两边同时乘以 $b$，

$ x × b \equiv \frac{a}{b} × b \pmod p$

那么问题已经转化为：

**已知 $bx \equiv a \pmod p$ ①，求 $x$。**

等等，先别看这个。**如果这时我们能求出一个 $x_1$ 使得 $bx_1 \equiv 1 \pmod p$ ② 呢？**

又根据 $(I)$，② 两边同时乘以 $a$ 后仍然成立：

$b × (ax_1) \equiv a \pmod p$

和 ① 对比一下，可见 $a × x_1$ 就是答案 $x$ 了（别忘了最后模一下 $p$）。

**于是抛出一个问题 II：求一个 $x_1$ 满足 $bx_1 \equiv 1 \pmod p$**。

如果你不能解决，你需要问题 II [P1082 同余方程](https://www.luogu.org/problemnew/show/P1082)，我也发布了它的一份[题解](https://cicos.blog.luogu.org/solution-p1082)（本题解的中间部分）！

问题 II 解决了，那 $a,b$ 太大怎么解决？

**把条件 $bx \equiv a \pmod p$ 也转化一下：**

$(b \mod p) × x \equiv a \mod p \pmod p$

这个转化为什么是对的？其实你可以按照程序中的模运算来理解，任何同余式右边的 $\pmod p$ 相当于对两边结果分别进行一次最终模运算。对于其中的因数，你不管怎么模，同余式都保持成立。

由此可见，只要在快读的时候也不断把 $a,b$ 对模数求余就好了。

题目说还有无解的情况？

* 当 $b$ 是 $p$ 的倍数时，$bx \mod p = 0$。

  * 如果 $a$ 也是 $p$ 的倍数，则 $a \mod p = 0$，所以 $bx \equiv a \pmod p$ 恒成立（有无数解）。

  * 如果 $a$ 不是 $p$ 的倍数，则 $a \mod p ≠ 0$，故上面这个方程不可能成立。

* 若 $b$ 不是 $p$ 的倍数，那么因为模数是一个质数，所以 $b$ 与 $p$ 互质，那么 $bx_1 \equiv 1 \pmod p$ 一定有解（根据问题 II 中的一个结论），故一定有符合条件的 $x = a × x_1$。

所以当且仅当 $b \mod p = 0$ 时无解。

重新理清思路：求解 $\frac{a}{b} \mod p$。

* 读入 $a, b$ 时用快读（分字符读入），以便于在其中直接模 $p$。

* 判断取余后的 $b$ 是不是 $0$，是则无解或者无意义，不是则一定有解。

* 求解关于 $x_1$ 的方程：$bx_1 \equiv 1 \pmod p$。

* 答案 $x$ 等于 $a × x_1 \mod p$。

```cpp
#include <cstdio>
#include <cctype>
const int MOD = 19260817;//MOD是题解中的"p"
inline int getint()
{
    int res = 0, ch = getchar();
    while(!isdigit(ch) and ch != EOF)
        ch = getchar();
    while(isdigit(ch))
    {
        res = (res << 3) + (res << 1) + (ch - '0');
        res %= MOD;//直接对MOD取余
        ch = getchar();
    }
    return res;
}

int x, y;
void exgcd(int a, int b)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b);
    int Last_x = x;
    x = y;
    y = Last_x - a / b * y;
}

int main()
{
	int a, b;
    a = getint();
    b = getint();
    
    if(b == 0)
    {
        puts("Angry!");
        return 0;
    }
    exgcd(b, MOD);
    x = (x % MOD + MOD) % MOD;
    printf("%lld\n", a * (long long)(x) % MOD);//小心相乘后爆int
    return 0;
}
```

___

更新日志：

2019-02-22 打扫了 `mimi` 指出的错误，很感谢；修改语句。

---

## 作者：JasonZRY (赞：11)

### 这是高精度？？？

### 不不不，高精度会死！！！

那用什么？你见过有理数取模吗？我们可以转换一下，

c=a*b^(-1)，那这道题不就变成裸的求逆元了吗？但是怎么输入呢？先用字符串读入，在转化成数字的时候取模就行了，求逆元其实有线性的算法。

代码如下：

```
#include<bits/stdc++.h>
#define ll long long int
using namespace std;
char a1[10005],b1[10005];
long long a,b,c,m=19260817,ans;
int k[19260819];
int main(){
    cin>>a1>>b1;
    long long lena=strlen(a1)-1,lenb=strlen(b1)-1;
    for(int i=0;i<=lena;i++)a=((a*10)%m+a1[i]-'0')%m;
    for(int i=0;i<=lenb;i++)b=((b*10)%m+b1[i]-'0')%m;
    if(b==0){
        printf("Angry!");
        return 0;
    }
    k[1]=1;
    for(int i=2;i<=b;i++)
    k[i]=(((-m/i+m)%m)*k[m%i]+m)%m;
    ans=(a*k[b])%m;
    cout<<ans;
    return 0;
}
```
Thanks for watching

%%%orz


---

## 作者：Great_Influence (赞：8)

不要管高精。。。可以发现，$a$和$b$只有对$mod$的余数才会有用。直接一路滚过去取模即可。至于除法，费马小定理需要了解:

$$a^{p-1}\equiv 1\pmod p$$

推导一下就可以得到:

$$a^{p-2}\equiv a^{-1}\pmod p$$

答案就是

$$a*b^{-1}$$

直接计算即可。

代码:

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cstring>
#define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
#define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}

const int MAXN=1e4+7;

const int mod=19260817;

static char a[MAXN],b[MAXN];

static int n,m,A,B;

typedef long long ll;

inline int power(int a,int b)
{
	static int sum;
	for(sum=1;b;b>>=1,a=(ll)a*a%mod)if(b&1)
		sum=(ll)sum*a%mod;
	return sum;
}

int main(void){
    file();
	scanf("%s%s",a,b);n=strlen(a)-1,m=strlen(b)-1;
	Rep(i,0,n)A=(A*10+(a[i]^48))%mod;
	Rep(i,0,m)B=(B*10+(b[i]^48))%mod;
	if(B==0)return puts("Angry!"),0;
	printf("%d\n",(ll)A*power(B,mod-2)%mod);
	return 0;
}

```

---

## 作者：lahlah (赞：6)

首先题目简短明了

	这题主要就是要求b的逆元
    
首先我们观察一下这个模数,嗯,是个质数（下面我们用模数来代替这个质数），所以根据我们伟大的费马小定理，可以直接得出 b 的逆元就是 b^p-2，怎么推出来的呢，就是因为费马小定理是 a^p-1≡1（mod p）,当p为质数的时候成立，我们就把b带进去，*b^p-1 ≡ 1 (mod p )* 所以可以直接用快速幂求辣。

等等。。。当b为p的倍数的时候是不成立的（没有逆元）

代码：

```
#include<bits/stdc++.h>
#define ll long long
#define mod 19260817
using namespace std;
char st[10005];
int main(){
	scanf("%s",st);//根本不用高精度，在输入的时候模就好了
	int len=strlen(st);
	int a=0;
	for(int i=0;i<len;i++){
		a=a*10+st[i]-'0';
		a=a%mod;
	}
	scanf(" %s",st);
	len = strlen(st);
	int b=0;
	for(int i=0;i<len;i++){
		b=b*10+st[i]-'0';
		b=b%mod;
	}
	ll ans=1;
	ll t=b;
	if(t%mod==0) {printf("Angry!");return 0;}//如果是模数的倍数就呵呵
	for(int i=mod-2;i;i>>=1,t=t*t%mod) if(i&1) ans=ans*t%mod;//快速幂
	ans=ans*a%mod;
	printf("%lld",ans); //哈哈
	return 0;
}
//别走，还有扩欧的
```

求逆元嘛，我们还可以用扩展欧几里得啊

我们知道，扩展欧几里得是用来求*ax + by = gcd(a, b)* 这类问题的，那么对于求逆元，*ax ≡ 1(mod b)* ,可以转换成 *ax + by = 1*,当然这里a,b也要是互质的，所以x就是 a 关于mod b意义下的逆元辣。
又可以开始写辣

```
#include<bits/stdc++.h>
#define ll long long
#define mod 19260817
using namespace std;
char st[10005];
ll exgcd(ll &x,ll &y,ll a,ll b,ll &d){ //正常的扩展欧几里得
	if(!b) {d=a;x=1;y=0;}
	else {
		exgcd(x,y,b,a%b,d);
		int t=x;
		x=y;y=t-(a/b)*y;
		x=x%mod;y=y%mod;
	}
}
int main(){
	scanf("%s",st);//输入同上
	int len=strlen(st);
	int aa=0;
	for(int i=0;i<len;i++){
		aa=aa*10+st[i]-'0';
		aa=aa%mod;
	}
	scanf(" %s",st);
	len = strlen(st);
	int bb=0;
	for(int i=0;i<len;i++){
		bb=bb*10+st[i]-'0';
		bb=bb%mod;
	}
	ll x,y,a,b,d;
	a=bb;b=mod;
	exgcd(x,y,a,b,d); //求b关于模数的逆元
	if(d>1) {printf("Angry!");return 0;} //如果是模数的倍数则没有逆元
	for(;x<0;) x+=mod; //最好把x变为正数
	ll ans=aa*x%mod; 
	printf("%lld",ans);//输出
	return 0;
}
```
[偷偷安利一下自己的blog](https://blog.csdn.net/qq_38944163/article/details/81672516)

---

## 作者：_H17_ (赞：4)

## 题目分析

设 $p=19260817$。

需要求 $\frac{a}{b}\bmod p$。

根据余数的可乘性，题目变为 $[(a\bmod p)\times (\frac{1}{b}\bmod p)]\bmod p$。

瓶颈在于求 $\frac{1}{b}\bmod p$。

我们假设这个数是 $x$。

根据余数的可乘性，$b\times x \equiv 1\pmod{p}$。

根据费马小定理，当 $b,p$ 互质，且 $p$ 是质数的时候，$b^{p-1}\equiv 1\pmod{p}$（判一下就一个 $p$ 是质数）。

变形之后就是 $b\times b^{p-2}\equiv 1\pmod{p}$。

所以上面的最原始的同余方程得到 $x=b^{p-2}\bmod p$ 是一个整数解。

这样这个题也就迎刃而解了。

## 代码实现

```cpp
#include<bits/stdc++.h>
//#define int long long 
using namespace std;
const int mod=19260817;
int a,b;
int qp(int a,int b){
    int ret=1;
    a%=mod;
    while(b){
        if(b&1)
            ret*=a,ret%=mod;
        a*=a,a%=mod,b>>=1;
    }
    return ret;
}
void read(int&a){
    a=0;
    char c;
    while((c=getchar())<'0'||c>'9');
    while(c>='0'&&c<='9'){
        a=a*10%mod+(c-48),a%=mod,c=getchar();
    }
    return;
}
signed main(){
    read(a),read(b);
    cout<<(a%mod*qp(b,mod-2))%mod;
    return 0;
}
```

---

## 作者：dg114514 (赞：4)

题目非常简单，其实就是求 $a\times b^{-1}\bmod 19260817$。但是 $a,b>10^{18}$ 需要高精度怎么办？但是其实 $a\equiv a\bmod p \pmod p$，（显然的）且 $b^{-1}\equiv (b\bmod p)^{-1}\pmod p$。所以让 $a,b$ 对 $19260817$ 取模就可以直接套逆元模板（扩展欧几里德算法或费马小定理）了。无解的情况相当简单，因为 $19260817$
是一个质数，所以与 $19260817$ 不互质的数只有可能是它的倍数。由于 $a,b$ 对 $19260817$ 取模，只要判定 $b$ 是否等于 $0$，是则无解。否则计算 $a\times b^{-1}\bmod 19260817$ 的值即可。

### 代码（扩展欧几里德算法）
```cpp
#include<bits/stdc++.h>
#define mod 19260817
#define int long long
using namespace std;
void exgcd(int a,int b,int &x,int &y){
	if(!b)
		x=1,y=0;
	else
		exgcd(b,a%b,y,x),y-=a/b*x;
}
signed main(){
	string sa,sb;
	cin>>sa>>sb;
	int a=0,b=0;
	for(auto &i:sa)
		a=(a*10%mod+(i^48))%mod;
	for(auto &i:sb)
		b=(b*10%mod+(i^48))%mod;
	if(!b)puts("Angry!"),exit(0);//b mod 19260817 = 0
	int x,y;
	exgcd(b,mod,x,y);
	x=(x%mod+mod)%mod;
	cout<<x*a%mod;
	return 0;
}
```

---

## 作者：MatrixGroup (赞：4)

## 算法介绍

有理数取余是因为整数取模不能做除法而打上的一个补丁。

对于正整数 $m$ 和有理数 $x$，若 $x=\dfrac pq$，其中 $p,q$ 互质，若 $q,m$ 互质，我们定义 $x$ 模 $m$ 的结果为唯一满足 $0\le r<m$ 的整数 $r$ 满足 $rq\equiv p\pmod m$。可以证明这是存在且唯一的，并且就算 $p,q$ 不互质，只要 $q,m$ 互质，这个结果是不变的。

可以证明，有理数取模就可以加减乘除，其中除要满足除数与 $m$ 互质（若 $m$ 为素数，就是要求非零）。这里主要介绍算法，所以略去性质相关的证明。

根据题意，给定 $p=19\, 260\, 817$ 和一个有理数 $\dfrac ab$，我们要找到唯一一个 $0\le r<p$ 满足 $rb\equiv a\pmod p$。首先这个式子只和 $a,b$ 在 ${}\bmod p$ 意义下的值相关，因此可以同时读入和取模。接下来只需要枚举 $r$ 就可以在 $O(p)$ 的时间内通过本题。

## 正确性证明

这里主要来证一下 $a,b$ 不互质的情况下也是对的。若 $a,b$ 同乘 $d$，因为 $rb\equiv a\pmod p$，故 $rbd\equiv ad\pmod p$，即用 $ad,bd$ 算的也是对的。

复杂度因为 $0\le r<p$ 的整数 $r$ 只有 $p$ 个，所以复杂度是 $O(p)$ 的（忽略读入时间）。

## 代码实现

本题还要求若 $b\equiv 0,a\not\equiv0\pmod p $ 时输出 `Angry!`，此时对应了方程无解（除以零）的情况，因此找不到的时候输出即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=19260817;
ll getint()
{
    char c=getchar();
    while(!isdigit(c)) c=getchar();
    ll ans=0;
    while(isdigit(c))
    {
        ans=(ans<<1)+(ans<<3)+c-'0';
        ans%=mod;
        c=getchar();
    }
    return ans;
}
int main()
{
    ll a=getint();
    ll b=getint();
    for(int i=0;i<mod;++i)
    {
        if(i*b%mod==a)
        {
             printf("%d\n",i);
             return 0;
        }
    }
    printf("Angry!\n");
    return 0;
}
```

---

## 作者：Starlight237 (赞：4)

## 引理 Fermat-Euler定理
设$(a,m)=1$，则有：
$$a^{\phi(m)}\equiv1(\mod m)$$
这里引用《初等数论》中一个我认为十分巧妙的证明：
> 取$r_j(1\le j\le\phi(m))$为模m的一组既约剩余系，则$a\times r_j(1\le j\le\phi(m))$也是模m的一组既约剩余系。  
显然，根据同余定理，对于模m的任两组既约剩余系，它们中元素的乘积相等，因此：  
$$\prod^{\phi(m)}_{j=1}r_j\equiv \prod^{\phi(m)}_{j=1}ar_j=a^{\phi(m)}\prod^{\phi(m)}_{j=1}r_j(\mod m)$$  
由于$(r_j,m)=1$，根据同余定理即可直接证明。

特别地，例如本题，当m为素数时，有：
$$a^{m-1}\equiv1(\mod m)$$
所以有：
$$a/b\equiv a*b^{-1}\equiv a*b^{m-1}(\mod m)$$
又根据同余定理，因为a、b太大，可以一边快读一边取模。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define IOSIZE 10000000
static char in[IOSIZE],*p=in,out[IOSIZE],*q=out,ch[20],*t=ch;
inline int read(){
	reg int x=0;
	while(*p<48)++p;
	while(*p>47)x=(x<<1)+(x<<3)+(*p++^48),x%=19260817;
	return x;
}
inline void write(long long x){
	!x&&(*q++=48);
	while(x)*t++=x%10+48,x/=10;
	while(t!=ch)*q++=*--t;
}
inline long long qpow(long long x,int n){
	reg long long res=1;
	for(;n;n>>=1,x=x*x%19260817)(n&1)&&(res=res*x%19260817);
	return res;
}
int main(){
	freopen("1.in","r",stdin);
	fread(in,1,IOSIZE,stdin);
	long long a=read(),b=read();
	!b?(puts("Angry!"),0):(write((a*qpow(b,19260815)%19260817+19260817)%19260817),0);
	fwrite(out,1,q-out,stdout);
	return 0;
}

```

---

## 作者：Manchester_City_FC (赞：3)

### 前置知识
1. 若 $x \equiv 1 \bmod p$，则 $ax \equiv a \bmod p$。
2. 若 $ax \equiv b \bmod p$，则 $(a \bmod p) \times x \equiv b \bmod p$。
3. 费马小定理：如果 $p$ 是一个质数且 $\gcd(x,a)=1$，则有 $a^{p-1} \equiv 1 \bmod p$。
4. 若 $x$ 为 $a$ 在模 $p$ 意义下的逆元，则 $ax \equiv 1 \bmod p$。

### 算法介绍——有理数取余
大家肯定在某些题中遇到过对整数取模的情况。但是，如果题目的答案是个有理数分数，而且避免为了不必要的精度问题，这该怎么办呢？这个时候我们就需要使用有理数取模的技巧了。顾名思义，有理数取模的意思是求 $\frac{a}{b} \bmod p$ 的值，这个值被定义为 $bx\equiv a \bmod p$ 的解。那我们该如何求呢？

我们来逐步思考问题。现在我们希望求得 $bx\equiv a \bmod p$ 的解，也就是说，如果我们求得了 $bx_1 \equiv 1 \bmod p$ 的解，我们就可以得出 $a \times bx_1 \equiv a \bmod p$，进而推出 $b \times (ax_1 \bmod p) \equiv a \bmod p$。此处可参考 [P1082](https://www.luogu.com.cn/problem/P1082)。

那么我们如何求出 $bx_1 \equiv 1 \bmod p$ 的解呢？这其实就是求 $b$ 的逆元。又因为费马小定理，$b^{p-1} \equiv 1 \bmod p \Rightarrow b^{p-2} \equiv b^{-1} \bmod p$，所以 $b$ 的逆元就是 $b^{p-2}$，最后我们只需要进行一个简单的快速幂即可得出答案，如果需要帮助的话可以看我的题解：[Link](https://www.luogu.com.cn/article/v0aan16q)。

### 代码实现
由于本题还存在无解的情况，即 $a \not\equiv 0 \bmod p$ 且 $b \equiv 1 \bmod p$ 时，我们应该输出 `Angry!`。

具体代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=19260817;
string s,t;
int a,b;
//快速幂模版 
int pow(int x,int y){
	int t=1;
	while(y>0){
		if(y&1) t=t*x%mod;
		x=x*x%mod,y>>=1;
	}
	return t;
}
signed main(){
	cin>>s>>t;
	//字符串转为数字 
	for(int i=0;i<s.size();i++) a=(a*10+s[i]-'0')%mod;
	for(int i=0;i<t.size();i++) b=(b*10+t[i]-'0')%mod;
	//根据费马小定理输出 
	if(a%mod&&!(b%mod)) cout<<"Angry!";//无解的情况 
	cout<<a*pow(b,mod-2)%mod;
}
```

---

## 作者：ikunTLE (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2613)

> 注：在本篇题解中，除数 $b$ 写作有理数 $c$ 写作 $x$。

### 算法介绍

本题需使用[逆元](https://oi-wiki.org/math/number-theory/inverse/)。

逆元即对于同余方程 $ax\equiv1\pmod p$，则 $x$ 为 $a\bmod p$ 的逆元，记作 $a^{-1}$。若其满足 $a\nmid p$，则 $a^{-1}\equiv a^{p-2}\pmod p$。

本题中 $a$ 和 $b$ 为较大的整数，可以用快读来读入，并对 $19260817$ 取模。

### 正确性证明

根据费马小定理可知 $a^{p-1}\equiv1\pmod p$。

费马小定理证明：

> 构造集合 $S=\{1,2,3,\dots,p-1\}$，同时构造集合 $S'=\{a,a\times2,a\times3,\dots,a\times(p-1)\}$。
> 
> 由于 $a\nmid p$，所以 $a$ 和 $p$ 互质。因此对于所有不同的 $u$ 和 $v$，一定满足 $a\times u\not\equiv a\times v\pmod p$。所以 $S'$ 是模 $p$ 意义下的完全剩余系，且没给元素都与 $S$ 中的某个元素同余。
>
> 然后计算 $S$ 的积 $\prod S=1\times2\times3\times\dots(p-1)=(p-1)!\pmod p$，以及 $S'$ 的积 $\prod S'=a\times(a\times2)\times(a\times3)\times\dots(a\times(p-1))=a^{p-1}\times(p-1)!\pmod p$。
>
> 因为 $S$ 和 $S'$ 都是模 $p$ 意义下的完全剩余系，所以两集合的积同余，即 $(p-1)!\equiv a^{p-1}\times(p-1)!\pmod p$。
>
> 最后化简得 $a^{p-1}\equiv1\pmod{p}$。

证出费马小定理，可以推出逆元式子：

$$
1\equiv1\pmod{p}\\
a^1\times a^{-1}\equiv a^{p-1}\pmod{p}\\
a^{-1}\equiv a^{p-2}\pmod{p}
$$

对于幂的计算，可以使用快速幂。

时间复杂度 $\mathcal{O}(\log A)$。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MOD=19260817;
int read(){
	int x=0;
	char f=1,ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x*10+ch-'0')%MOD; //这里对 x 进行取模操作
		ch=getchar();
	}
	return x*f;
}
int q_pow(int a,int b,int MOD){ //快速幂
	int res=1;
	while(b){
		if(b&1)
			res=res*a%MOD;
		b>>=1;
		a=a*a%MOD;
	}
	return res;
}
signed main(){
	int a=read(),b=read();
	if(!b) //除数 b 不能为 0
		return printf("Angry!\n"),0;
	printf("%lld\n",a*q_pow(b,MOD-2,MOD)%MOD); //逆元
	return 0;
}
```

---

## 作者：xy_mc (赞：2)

### 声明：

  在接下来的讲述中，我会用 $p$ 代表题中的模数 $19260817$。

### 前置芝士：

- 快读；
- 逆元；
- 扩展欧几里得。

### 正解：

- 读入：
  
  很显然，这道题输入的数太大了，根本不能用正常的方法输入，用字符串行不行呢？太麻烦了。所以我们考虑在输入时对其取模。还记得快读吗？我们只需要加一个取余就行了。如：

  ```cpp
  inline int rd(){
      int x=0,ch=getchar();
      while(!isdigit(ch)&&ch!=EOF) ch=getchar();
      while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch-'0'),x%=mod,ch=getchar();
      return x;
  }
  ```

解决了读入，剩下的就很简单了。

首先把题目中的式子改一下，如：

$$ c=\dfrac{a}{b}$$

$$ c=ab^{-1}$$

将除以 $b$ 改为乘 $b$ 的逆元，即乘 $b^{-1}$。接下来就要看看逆元如何求了。这里我采用的是扩展欧几里得求逆元。

- 扩欧求逆元：

  已知求逆元时，我们会写出一个同余方程：$ax \equiv 1 \pmod b$，解出的 $x$ 即为 $a$ 在模 $b$ 意义下的逆元。在题中，用于求解 $b$ 在模 $p$ 意义下的逆元的方程是：$bx \equiv a \pmod p$，那如何解这个方程呢？很简单，将其改造一下：

    $$b x\equiv a \pmod p$$

    $$b x-p y=a$$

    由于 $y$ 可以是任何数，所以可以写成：

  $$b x+p y=a$$

  转化为熟悉的样子：

  $$b x+p y=\gcd(b,p)$$ 

  求解过程：

  设：

  $$b x_1+p y_1 = \gcd(b,p)$$

  $$p x_2 + (b \bmod p)y_2 =\gcd(p,b \bmod p)$$

  $$\because \gcd(b,p) = \gcd(p,b \bmod p)$$

  $$\therefore  b x_1+p y_1 = p x_2 + (b \bmod p)y_2$$

  $$ \because b \bmod p = b - ( \left\lfloor \frac{b}{p} \right \rfloor \times p)$$

  $$\therefore  b x_1+p y_1 = p x_2 + (b - ( \left\lfloor \frac{b}{p} \right \rfloor \times p))y_2$$

  $$b x_1 + p y_1 = b y_2 + p x_2 - \left\lfloor \frac{b}{p} \right \rfloor \times p y_2$$

  $$ b x_1 + p y_1 = b y_2 + p (x_2 - \left\lfloor \frac{b}{p} \right \rfloor \times y_2)$$

  $$\because b=b,p=p$$

  $$\therefore x_1=y_2,y_1=x_2 - \left\lfloor \frac{b}{p} \right \rfloor \times y_2$$

  把 $x_2$ 和 $y_2$ 不断代入递归求解，直至 $\gcd$ 为 $0$，递归 $x=1,y=0$ 回去求解。

  像这样求出来的 $x$ 就是 $b$ 在模 $p$ 意义下的逆元了。

  最后用 $a$ 乘 $x$ 再取模就行了。

### 代码：
```cpp
#include<bits/stdc++.h>
#define inl inline
#define reg register
#define int long long
#define rep(i,x,y) for(reg int i=x;i<=(y);++i)
#define per(i,x,y) for(reg int i=x;i>=(y);--i)
using namespace std;
const int p=19260817;
inline int rd(){
    int x=0,ch=getchar();
    while(!isdigit(ch)&&ch!=EOF) ch=getchar();
    while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch-'0'),x%=p,ch=getchar();
    return x;
}
int a,b,x,y;
void exgcd(int a,int b){
    if(b==0){
        x=1;
        y=0;
        return;
    }
    exgcd(b,a%b);
    int t=x;
    x=y;
    y=t-(a/b)*y;
}
signed main(){
	a=rd();
    b=rd();
    if(b==0){  //分母不能为 0，故无解。
        cout<<"Angry!";
        return 0;
    }
    exgcd(b,p);
    x=(x%p+p)%p; //保证为正数
    cout<<a*x%p;
	return 0;
}
```

---


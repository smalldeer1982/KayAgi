# [蓝桥杯 2025 省 A] 地雷阵

## 题目描述

小蓝正在平面直角坐标系中的第一象限里玩一个逃生小游戏。在第一象限中埋有 $n$ 颗地雷，第 $i$ 颗地雷的坐标为 $(x_i, y_i)$，触发范围为以 $(x_i, y_i)$ 为圆心，半径为 $r_i$ 的圆。一旦小蓝走进了圆内就会触发地雷导致游戏失败。小蓝初始在原点 $(0, 0)$ 上，他需要在第一象限内选择一个方向一直往前走，如果能不触发任何地雷即可成功通关游戏。他想知道在 $[0, \frac{\pi}{2}]$ 中均匀随机选择一个方向，即在 $0^\circ$（朝向 $x$ 轴正方向）至 $90^\circ$（朝向 $y$ 轴正方向）之间随机选择一个方向，通关游戏的概率是多少？

## 说明/提示

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 100$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$1 \leq x_i, y_i \leq 10^4$，$r_i < \min(x_i, y_i)$。

## 样例 #1

### 输入

```
1
2 2 1```

### 输出

```
0.540```

## 样例 #2

### 输入

```
2
1 3 1
3 1 1```

### 输出

```
0.181```

# 题解

## 作者：Souture (赞：9)

## 题目大意
在二维平面上有 $$n$$ 个地雷，地雷的覆盖范围可以看成一个圆，第 $$i$$ 个地雷的位置为 $$(x_i, y_i)$$，半径为 $$r_i$$，你要从原点 $$(0, 0)$$ 走**直线**出发，方向限制在 $$\left[0, \frac{\pi}{2}\right]$$ （第一象限），求你走的直线与任何一个圆**不交**的概率。

如图：
![示意图](https://i.imgs.ovh/2025/04/13/akSjQ.jpeg)

## 思路
由于是要求概率，我们设与平面上所有圆不交的角度之和为 $$\theta$$ 不难想到答案是：
$$
\frac{\theta}{\frac{\pi}{2}}
$$
直接求与圆**不交**的角度和很困难，考虑单个圆单独处理，先求直线与每个圆**相交**的角度和 $$ \alpha$$ ，最后用 $$\frac{\pi}{2} - \alpha $$ 表示 $$ \theta $$。
### 转换为角度区间
对于每个地雷，先计算其与原点连线的方向角
$$\theta = \arctan\frac{y}{x}$$

如图：
![示意图](https://i.imgs.ovh/2025/04/13/ak6c0.jpeg)

以及原点到地雷的距离
$$d = \sqrt{x^2+y^2}.$$
地雷影响的方向范围为
$$[\theta-\delta,\ \theta+\delta]$$
其中
$$\delta = \arcsin\left(\frac{r}{d}\right).$$

如图：
![示意图](https://i.imgs.ovh/2025/04/13/akelb.jpeg)

由于题目保证了 $$r_i < \min{(x_i, y_i)}$$，所以不需要对边界进行处理，即
$$
\left[\theta-\delta,\ \theta+\delta\right] \subset \left[0, \frac{\pi}{2}\right]
$$

### 扫描线
显然我们对每个圆的区间计算后位置很乱，考虑将所有地雷对应的角度区间排序后，利用**扫描线**合并所有重叠的区间，从而得出不安全角度 $$ \alpha $$ 的总长度。

我们记扫描线为 $$line$$ ：

假设已经**按区间的左端点 $$L$$ 从小到大排序**。那么，对于每个区间 $$[L, R]$$：

#### 每次定位扫描线
$$ line = \max(line, L) $$ 

如果当前区间的左端点 $$L$$ 在 $$line$$ 之前，说明新区间与之前的合并区间已有重叠，此时将 $$line$$ 保持在合并区间的右边界。

如果 $$L$$ 大于 $$line$$，表示上一个合并区间结束，扫描线移动到新区间起始点开始计算新的覆盖部分。
#### 累加新覆盖的部分
$$ \alpha += \max(0.0, R - line) $$ 
这一步计算当前区间 [$$L, R$$] 对比扫描线位置 $$line$$ 之后，新扩展出来的部分。如果 $$R > line$$，则 $$R - line$$ 就是当前区间新增的长度；否则没有新增部分。

#### 更新扫描线位置
$$ line = \max(line, R) $$ 
 确保扫描线总是记录已合并区间最新的右边界，便于后续区间计算合并长度。

 如图：
 ![示意图](https://i.imgs.ovh/2025/04/13/akPwx.jpeg)

### 计算结果
安全角度的角度和 $$\theta$$ 为
$$\theta = \frac{\pi}{2} - \alpha$$
最终通关概率为
$$\text{ans} = \frac{\theta}{\frac{\pi}{2}} = \frac{\frac{\pi}{2} - \alpha}{\frac{\pi}{2}}$$

### 小技巧
基于C++的库函数，我们可以使用
$$\pi = acos(-1)$$ 
来获得**高精度**的常量 $$\pi$$ 。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define all(v) v.begin(), v.end()

const double PI = acos(-1);

void sol()
{
    int n; cin >> n;
    vector<tuple<int,int,int>> p(n);
    for (int i = 0; i < n; i++) {
        int x, y, r;
        cin >> x >> y >> r;
        p[i] = {x, y, r};
    }
    
    vector<pair<double,double>> rng;
    for (auto &[x, y, r] : p) {
        double t = atan2(y, x);
        double d = sqrt(x * x + y * y);
        double det = asin(r / d);

        double L = t - det, R = t + det;
        rng.push_back({L, R});
    }
    
    sort(all(rng), [&](auto a, auto b) { 
        return a.first < b.first; 
    });

    // 扫描线
    double line = 0;
    double res = 0;
    for (auto &[L, R] : rng) {
        line = max(line, L);
        res += max(0.0, R - line);
        line = max(line, R);
    }
    
    double ans = (PI / 2 - res) / (PI / 2);
    cout << fixed << setprecision(3) << ans << endl;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    sol();
    return 0;
}
```

---

## 作者：Shadow_Soldier (赞：5)

# 前言
本文中所有三角函数与角度均采用弧度制（如有特殊情况，会注明）。  
感谢大佬 @cserzy 的提醒，我的题解中有一个错误（$O$ 一定在 $\odot P_i$ 外），现已改正（2025 年 4 月 15 日）。  
感谢大佬 @Hanwenhu 的提醒，我的题解中有一个错误（$\angle A_{i,1}OP_i$ 的计算方法应使用 $\arcsin$，而不是 $\arccos$），现已改正（2025 年 5 月 5 日）。  
我自己发现了我的题解中的一个错误（$OP_i = \sqrt{{x_i}^2 + {y_i}^2}$，而不是 $\sqrt{x^2+y^2}$），现已改正（2025 年 5 月 5 日）。
# 题意简述
已知一平面直角坐标系 $xOy$ 中的第一象限上有 $n(n \in \N^*,n \le 10^5)$ 个点 $P_1,P_2,\cdots,P_n$。其中，若有正整数 $i$，满足 $1 \le i \le n$，则 $P_i(x_i,y_i)(x_i,y_i \in \N^*)$。给出 $n$ 个正整数 $r_1,r_2,\cdots,r_n$，以 $P_i$ 为圆心，半径长为 $r_i$，分别作 $\odot P_1,\odot P_2,\cdots,\odot P_n$。问：若从原点 $O$ 出发，在 $[0,\frac{\pi}{2}]$（即 $0^{\circ}$（角度制，朝 $x$ 轴方向）至 ${90}^{\circ}$（角度制，朝 $y$ 轴方向））中随机选择一个方向，作一条直线不与任何一个圆相交的概率是多少（保留三位小数）？  
[题目链接](https://www.luogu.com.cn/problem/P12144)
# 正解思路
## 第一步
对于每个 $P_i$，连接 $OP_i$，设 $OP_i = d$。  
作 $P_iM \perp x \text{ 轴}$，则 $OM = x_i$，$P_iM = y_i$。由勾股定理，$Rt \triangle OMP_i$ 中，$OP_i = \sqrt{OM^2 + P_iM^2} = \sqrt{{x_i}^2 + {y_i}^2}$。所以，$d = \sqrt{{x_i}^2 + {y_i}^2}$。  
因为 $x_i,y_i > 0$，所以 $d \ge \min(x_i, y_i)$。又因为 $r_i < \min(x_i, y_i)$，所以 $d > r$。  
所以，$O$ 在 $\odot P_i$ 外。
![图 $2$](https://cdn.luogu.com.cn/upload/image_hosting/ivyunqz8.png)  
如图，过 $O$ 作 $\odot P_i$ 的切线 $OA_{i,1}$ 与 $OA_{i,2}$，连接 $A_{i,1}P$ 与 $A_{i,2}P$。  
下面对**图中的情况**进行讨论。
注意到此时 $\odot P_i$ 挡住的是一部分的直线，所以可以理解为挡住了 $[\angle A_{i,1}OM_i,\angle A_{i,2}OM_i]$ 的方向。  
因为 $P_iA_{i,1} \perp OA_{i,1}$ 且 $P_iA_{i,2} \perp OA_{i,2}$，所以 $\triangle OA_{i,1}P_i$ 与 $\triangle OA_{i,2}P_i$ 都是直角三角形。因为 $A_{i,1}P_i = A_{i,2}P_i$ 且 $OP_i = OP_i$，所以 $\triangle OA_{i,1}P_i \cong \triangle OA_{i,2}P_i$。进而 $\angle A_{i,1}OP_i = \angle A_{i,2}OP_i$。  
注意到，$\angle P_iOM_i = \arctan(\frac{P_iM_i}{OM_i}) = \arctan(\frac{y_i}{x_i})$，$\angle A_{i,1}OP_i = \arcsin(\frac{A_{i,1}P_i}{OP_i}) = \arcsin(\frac{r_i}{d}) = \arcsin(\frac{r_i}{\sqrt{{x_i}^2 + {y_i}^2}})$。又因为 $\angle A_{i,1}OP_i = \angle A_{i,2}OP_i$，所以 $\angle A_{i,1}OM_i = \angle P_iOM_i - \angle A_{i,1}OP_i = \arctan(\frac{y_i}{x_i}) - \arcsin(\frac{r_i}{\sqrt{{x_i}^2 + {y_i}^2}})$，$\angle A_{i,2}OM_i = \angle P_iOM_i + \angle A_{i,2}OP_i = \angle P_iOM_i + \angle A_{i,1}OP_i = \arctan(\frac{y_i}{x_i}) + \arcsin(\frac{r_i}{\sqrt{{x_i}^2 + {y_i}^2}})$。  
所以，此时挡住方向的范围就是 $[\arctan(\frac{y_i}{x_i}) - \arcsin(\frac{r_i}{\sqrt{{x_i}^2 + {y_i}^2}}), \arctan(\frac{y_i}{x_i}) + \arcsin(\frac{r_i}{\sqrt{{x_i}^2 + {y_i}^2}})]$。  
但是，其实挡住方向的范围可能有一些并不含在 $[0,\frac{\pi}{2}]$ 中，所以正确的答案应该是：$[\max(\arctan(\frac{y_i}{x_i}) - \arcsin(\frac{r_i}{\sqrt{{x_i}^2 + {y_i}^2}}), 0), \min(\arctan(\frac{y_i}{x_i}) + \arcsin(\frac{r_i}{\sqrt{{x_i}^2 + {y_i}^2}}), \frac{\pi}{2})]$。
## 第二步
那么，总共不可行的区间加在一起有多长呢（不能重复）？这也很简单了。只要把这些区间合并一下就好了，我们只要记录最后的区间并在计算过程中统计答案（答案初值为 $0$）。  
按照区间的最低限度从小往大排序，然后正序扫描一遍。

如果目前没有一个区间，则就直接把这个区间赋值为现在的区间。否则，分两种情况讨论：  
- 最后的区间的最大限度大于等于这个区间的最小限度：最后的区间的最大限度值为它与这个区间的最大限度的最大值。
- 否则：把答案加上最后的区间的最大限度与最小限度的差，然后把最后的区间赋值为这个区间。

最后，把答案加上最后的区间的最大限度与最小限度的差，并根据这个值推导出最终的概率（$\text{概率} = \text{1} - \frac{\text{答案}}{\frac{\pi}{2}}$）。
# 代码
在放代码之前，先提醒一下：

1. 使用 `double` 作为变量类型
2. 提前求出 $\frac{\pi}{2}$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
const double pi_2 = asin(1);
const double eps = 1e-8;
double x, y, r, t1, t2, d, ans;
pair<double, double> a[100010], lst;
double Max(double u, double v) {
    return (u > v) ? u : v;
}
double Min(double u, double v) {
    return (u < v) ? u : v;
}
double Abs(double u) {
    return (u < 0) ? (0 - u) : u;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    cout << fixed << setprecision(3);
    for(int i = 1; i <= n; i ++) {
        cin >> x >> y >> r;
        d = sqrt(x * x + y * y);
        t1 = atan(y / x);
        t2 = asin(r / d);
        a[i].first = Max(t1 - t2, 0);
        a[i].second = Min(t1 + t2, pi_2);
    }
    sort(a + 1, a + n + 1);
    lst = make_pair(-1, -1);
    for(int i = 1; i <= n; i ++) {
        if(lst.second >= a[i].first) lst.second = Max(lst.second, a[i].second);
        else {
            ans += (lst.second - lst.first);
            lst = a[i];
        }
    }
    ans += (lst.second - lst.first);
    cout << 1 - ans / pi_2;
    return 0;
}
``````
# 提交记录
链接：[我的提交记录](https://www.luogu.com.cn/record/213885617);

---

## 作者：__Jared__ (赞：5)

我的思路比较多的大佬已经推理过了，这边我给可能看不懂的初中生（包括我）提供一些初中就能理解的证明：

## 思路

人尽皆知，三角函数值可以表示角，自然角也可以表示三角函数值；

所以我们就可以直接使用三角函数值来表示可能会触发雷的探测范围的角度之后求出它跟 $90^{\circ}$ 三角函数值之间的关系。

这里推荐使用正切值，理由很简单就是正切值的和角公式和差角公式比较好算不需要知道其它的东西，和角公式先放出来：

$$\tan(\alpha\pm\beta)=\frac{\tan\alpha\pm \tan\beta}{1\mp\tan\alpha\times\tan\beta}$$

![](https://cdn.luogu.com.cn/upload/image_hosting/xyy6cg2v.png)

因此我们通过图不难看出当 $\angle COB=\alpha,\angle COD=\beta$ 时，则区间 $[\alpha+\beta,\beta]$ 一定是不安全的。

故不难看出 $A(a,b),AC=r\Rightarrow \sqrt{AD^2+OD^2-r^2}=\sqrt{OA^2-r^2}=\sqrt{a^2+b^2-r^2}=OC\Rightarrow\tan\angle AOC=\frac{r}{\sqrt{a^2+b^2-r^2}}\Rightarrow \tan\alpha=\tan2\angle AOC$，利用上面的和角公式就可以求出 $\tan\alpha=\frac{2r\sqrt{a^2+b^2-r^2}}{a^2+b^2-5r^2}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fqfaj9zt.png)

同时，注意到 $\tan\angle COE=\tan(\angle AOE-\tan\angle COA)=\frac{\frac{b}{a}-\frac{r}{\sqrt{a^2+b^2-r^2}}}{\frac{br+a\sqrt{a^2+b^2-r^2}}{a\sqrt{a^2+b^2-r^2}}}$，太难化简了就不化了，在程序中写出来不会有影响；

具体怎么求角度，我们还需要知道一个东西就是 $\arctan$，它的作用可以简单理解为可以帮助你计算某角度（具体要涉及到反函数，但是蒟没怎么深入了解就不过多解释怕误导，大佬可以指点一下），故有如下公式：

$$\tan\alpha=A,\arctan A=\alpha$$

这个怎么求不用担心，GCC 帮我们准备了库，可以使用 `atan(a)` 这个函数求正切值为 $a$ 的角度；

最后只需要依据这些结论去求解就可以了，判断角度 $[\alpha,\beta]$ 之间没有的区间和 $90^{\circ}$ 的比即可。

## 注意

记得尽量避免精度误差，有些式子（例如上面那一坨）太难化简就不要化了，有可能会化错；

既然看到这里了，能否给个中考祝福呢？

蒟也是抽时间来水了这篇题解的，非常感谢您的观看！

---

## 作者：崔泽禹 (赞：3)

# [P12144 [蓝桥杯 2025 省 A] 地雷阵](https://www.luogu.com.cn/problem/P12144)题解

倒数第二题的位置，简单解析几何 + 区间覆盖问题。~~死去的解析几何突然攻击我。~~

## 核心过程

### （一）求过原点且与圆相切的直线斜率

假设一条过原点的直线 $y=kx$ 与圆相切，也就是这条直线 $kx-y=0$ 距离圆心 $(x_0,y_0)$ 的距离为半径 $r$，可以得到：

$$\frac{\left\lvert kx_0-y_0 \right\rvert }{\sqrt{k^2+1} } =r$$

两边同时平方：

$$\frac{k^2x_0^2-2x_0y_0k+y_0^2}{k^2+1} =r^2$$

$$(x_0^2-r^2)k^2-2x_0y_0k+(y_0^2-r^2)=0$$

韦达定理表示出 $k$：

$$k=\frac{2x_0y_0\pm \sqrt{4x_0^2y_0^2-4(x_0^2-r^2)(y_0^2-r^2)}}{2x_0^2-2r^2}$$

化简后得到 $k$：

$$\boxed{k=\frac{x_0y_0\pm \sqrt{x_0^2r^2+y_0^2r^2-r^4}}{x_0^2-r^2}}$$

---

或者使用圆的方程和判别式来求解：

$$(x-x_0)^2+(y-y_0)^2=r^2$$

将 $y=kx$ 代入：

$$(x-x_0)^2+(kx-y_0)^2=r^2$$

展开：

$$x^2 - 2x_0x + x_0^2 + k^2x^2 - 2kxy_0 + y_0^2 = r^2$$

$$(1 + k^2)x^2 - 2(x_0 + ky_0)x + (x_0^2 + y_0^2 - r^2) = 0$$

由于相切（一个交点，判别式为零）：

$$\Delta =[-2(x_0 + ky_0)]^2 - 4(1 + k^2)(x_0^2 + y_0^2 - r^2) = 0$$

得到关于 $k$ 的方程：

$$(x_0 + ky_0)^2 - (1 + k^2)(x_0^2 + y_0^2 - r^2) = 0$$

化简后也可以得到 $k$：

$$\boxed{k=\frac{x_0y_0\pm \sqrt{x_0^2r^2+y_0^2r^2-r^4}}{x_0^2-r^2}}$$

代码实现：

```cpp
double k1 = (x*y - sqrt(x*x*r*r + y*y*r*r - r*r*r*r)) / (x*x - r*r);  //* 斜率较小的切线
double k2 = (x*y + sqrt(x*x*r*r + y*y*r*r - r*r*r*r)) / (x*x - r*r);  //* 斜率较大的切线
```

### （二）利用反函数将斜率转换为弧度

对于 $\tan(\theta) = k$ 可以利用反函数求出其对应弧度 $\theta =\arctan(k)$。

在结构体中：

- $\text{tmp.x}$ 表示当前圆能覆盖的起始**弧度**。
- $\text{tmp.y}$ 表示当前圆能覆盖的终止**弧度**。

例：圆心为 $(3,4)$ 半径为 $1$ 的圆所覆盖的弧度为 $[\theta_x,\theta_y]$。

![img-1](https://cdn.luogu.com.cn/upload/image_hosting/vicgz2fw.png)

将这个**弧度**范围区间添加进 `vec` 中。

代码实现：

```cpp
Node tmp;
tmp.x = atan(k1);
tmp.y = atan(k2);
vec.push_back(tmp);
```

或者直接：

```cpp
vec.push_back({atan(k1), atan(k2)});
```

### （三）区间覆盖问题

将 `vec` 排序后，维护 $\text{tl}$ 和 $\text{tr}$ 使其成为当前区间的左右端点。

如果新的区间比当前区间的右端点还要大，说明是下一个区间，用 $\text{ans}$ 累加当前区间。其中，$\text{ans}$ 是所有圆能覆盖**弧度**范围区间的和。

之后对左右端点进行初始化。

不要忘记遍历完 `vec` 后还要累加最后的那个区间！

代码实现：

```cpp
double tl = 0, tr = 0;
double ans = 0;
for (int i = 0; i < vec.size(); i++) {
    if (vec[i].x > tr) {
        ans += tr - tl;
        tl = vec[i].x;
        tr = vec[i].y;
    } else {
        tr = max(tr, vec[i].y);
    } 
}
ans += tr - tl;  //! 不要忘记
```

### （四）输出答案

由于 $\text{ans}$ 记录的是所有圆能覆盖**弧度**范围区间的和，答案自然是用 $1$ 减去失败的概率，注意保留三位小数。

代码实现：

```cpp
cout << fixed << setprecision(3) << 1 - ans / (pi / 2) << endl;
```

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const double pi = acos(-1);  //! 加强精度
struct Node {
    double x, y;
};
vector<Node> vec;
bool cmp(Node a, Node b) {
    return (a.x != b.x ? a.x < b.x : a.y < b.y);
}
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        double x, y, r;
        cin >> x >> y >> r;
        double k1 = (x*y - sqrt(x*x*r*r + y*y*r*r - r*r*r*r)) / (x*x - r*r);  //* 斜率较小的切线
        double k2 = (x*y + sqrt(x*x*r*r + y*y*r*r - r*r*r*r)) / (x*x - r*r);  //* 斜率较大的切线
        Node tmp;
        tmp.x = atan(k1);
        tmp.y = atan(k2);
        vec.push_back(tmp);
        // vec.push_back({atan(k1), atan(k2)});
    }

    sort(vec.begin(), vec.end(), cmp);

    double tl = 0, tr = 0;
    double ans = 0;
    for (int i = 0; i < vec.size(); i++) {
        if (vec[i].x > tr) {
            ans += tr - tl;
            tl = vec[i].x;
            tr = vec[i].y;
        } else {
            tr = max(tr, vec[i].y);
        } 
    }
    ans += tr - tl;  //! 不要忘记
    cout << fixed << setprecision(3) << 1 - ans / (pi / 2) << endl; 
    return 0; 
}
```

## 一些疑惑

考试的时候读了很多遍题目，数据范围中明确标注是 $r_i<\min(x_i,y_i)$，便没有写针对与 x 轴相切和与 y 轴相切（斜率为 0 或斜率不存在）的特判。~~但样例 2 中的两个圆都是不满足数据范围的。~~

## 注意事项

目前蓝桥杯只能支持到「极为先进」的 C++11 标准，如果以蓝桥杯为导向练习题目，请避免使用 `for (auto i : vec)` 等编译器不认识的语句。

2025/04/17 更新：使用 `pi = acos(-1)` 加强 $\pi$ 的精度。

---

## 作者：Mercur (赞：2)

### 解题思路

提供另一种处理“在一个范围内有很多个线段，求没有被线段覆盖的总长度”的方法。

注意到这道题只要求保留三位小数，我们可以暴力地思考处理区间操作的方法。需要开一个足够大的数组，将线段覆盖转化为数组区间修改，差分即可。

时间复杂度 $O(Len)$ ，空间复杂度 $O(Len)$， $Len$ 是差分数组长度。需要注意的是，每次操作都可能带来 $Len^{-1}$ 的误差。因此在1e5的数据范围下，在最坏情况下要满足 $\frac{10^{5}}{Len^{-1}}<10^{-3}$，也就是 $10^8$ ，会超出空间限制。实际上开到 $10^7$ 即可通过此题（在OI赛制下能够拿到更多的部分分）。

[提交记录](https://www.luogu.com.cn/record/213750400)

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 2e7 + 5;
ll t, n, acc, diff[N];
double R, ans, x, y, r;
ll a, b;

double Ma = acos(-1)/2;
int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n;
	while(n--) {
		cin >> x >> y >> r;
		R = sqrt(pow(x,2)+pow(y,2));
		a = ceil(asin(r/R) * 1e7);
		b = ceil(atan(y/x) * 1e7);
		++diff[b-a], --diff[b+a+1];
	} 
	ll P = ceil(Ma * 1e7);
	for(int i = 1; i <= P; ++i) {
		diff[i] += diff[i-1];
		if(!diff[i]) ++acc;
	}
	ans = 1.0 * acc / P;
	printf("%.3f\n", ans);
	return 0;
}
```

---

## 作者：__polar_ice (赞：2)

这里提供一种简单但精度较低的思路：

在精度为 $1e-7$ 的情况下将 $\left[0,\dfrac{\pi}{2}\right]$ 的边界信息映射到数组 $P\left[0..\left\lfloor\dfrac{\pi}{2}\times10^7\right\rfloor\right]$ 中，利用差分统计每个区间的覆盖情况。此处可令区间左边界对应的映射数组 $P[\mathrm{left}]$ --，右边界对应的 $P[\mathrm{right}]$ ++。

令 $t=\left\lfloor\dfrac{\pi}{2}\times 10^7\right\rfloor$，则最后拉通处理时根据差分的性质可知符合题意的通过概率大约为 $\dfrac{\sum\limits_{0}^{t}\mathrm{N}\left(\sum\limits_{i=0}^{t}P[i]\right)}{t}$，其中 $\mathrm{N}(p)=\left\{\begin{aligned}1&(p=0)\\0&(p\neq0)\end{aligned}\right.$。

考虑到本题只需要保留三位小数，$1e-7$ 的精度应该是绰绰有余了，而且 $1.57\times 10^7$ 的数组大小也没有超过 $256\mathrm{MiB}$ 的内存限制。

代码时间复杂度和空间复杂度均为 $O(t)$，其中 $t$ 已经在前文中给出。参上。

~~管理大大求个过，半角全角标点符号打回了好几次，已经尽量对照着管理给的信息改了qwq~~
```cpp
#include<bits/stdc++.h>
using namespace std;

double x,y,r;
const double pi=acos(0)*2;
const double fac=1e7;
const int N=fac*pi/2+5;
int P[N];

void addx(){
	double deg1=atan(y/x);
	double deg2=asin(r/sqrt(y*y+x*x));

	double degu=deg1+deg2,degd=deg1-deg2;
//degu：上界 degd：下界

	if(degd<0)degd=0;
	if(degu*2>pi)degu=pi/2;
//超界则特判处理

	P[int(fac*degu)]--;
	P[int(fac*degd)]++;
}

int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%lf%lf%lf",&x,&y,&r);
		addx();
	}
	double res=0,val=0;
	int cur_state=0;
	for(int i=0;i<=int(fac*pi/2);i++){
		val++;
		cur_state+=P[i];
		if(cur_state==0)res++;
	}
	printf("%.3lf",res/val);
	return 0;
}
```

---

## 作者：Archy_ (赞：1)

## 题目思路

根据题目求出能通关的概率，我们可以先求不能通关的概率，不能通关概率与圆的两切有关系。如果一开始你的方向在一个圆与原点两切线夹角之内，那么一定不能通过。我们假定以 $x$ 正半轴为 $0$ 度起点，求出每个圆与原点角度**范围**。

![](https://cdn.luogu.com.cn/upload/image_hosting/39f55dle.png)

如图，对于一个圆，我们可以先求出绿色角度，即为 $\theta_1 = \arcsin(\frac{\sqrt{x ^ 2 + y ^ 2}}{r})$。蓝色角度，即为 $\theta_2 = \arctan(\frac{y}{x})$，那么这个圆的失败范围是 $\theta_2 - \theta_1 \sim \theta_2 + \theta_1$。

注意，c++ 中三角函数的结果是弧度制，所以你可以除以 $\frac{\pi}{180}$ 来转化为角度，然后最后除以 $90$ 来计算概率。你当然也可以不转换，最后除以 $\frac{\pi}{2}$ 来计算概率。

然后我们就是要求这个所有圆的失败范围一共是多少，因为有重复的范围，我们不能盲目计算。这个子问题是一个经典的 [区间覆盖](https://www.luogu.com.cn/problem/P2082) 问题，这里就不赘述了。

## code

这里我是用 vector 做的，用 vector 会相对方便一些。

```cpp
#include <iostream>
#include <cmath>
#include <vector>
#include <algorithm>
#define db double
#define fi first
#define se second
using namespace std;

int n, x, y, r;
vector <pair<db, db> > v;
const double pi = acos(-1);
db du(db x) { return x / (pi / 180); }

int main() {
	cin >> n;
	for(int i = 1; i <= n; i ++) {
		cin >> x >> y >> r;
		db a = du(atan(y * 1.0 / x));
		db b = du(asin(r * 1.0 / sqrt(x * x + y * y)));
		v.push_back({a - b, a + b});
	}
	sort(v.begin(), v.end());
	db sum = 0, lstr = (*v.begin()).fi;
	for(auto &i : v) {
		if(i.fi > lstr) lstr = i.fi;
		if(i.se > lstr) sum += i.se - lstr, lstr = i.se;
	}
	printf("%.3lf\n", 1 - sum / 90.0);
	return 0;
}
```

---

## 作者：xy_mc (赞：1)

### 考点：

解析几何，贪心。

### 思路：

题意很简单，让求随机选一个方向，碰不到地雷的概率，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/er7jjz26.png)

我们不妨拿出一个圆来研究，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jg5ok24q.png)

假设橙线与蓝线的交点为原点，圆心为 $(a,b)$，切点为 $(x,y)$，可以直接求出橙线和蓝线的夹角：$\arctan \dfrac{b}{a}$，记作 $\theta$；在求出橙线和绿线的夹角：$\arcsin \dfrac{r}{\sqrt{a^2+b^2}}$，记作 $\delta$。因为是对称的，所以 $\theta-\delta$ 和 $\theta+\delta$ 就是两条切线的弧度。这样就可以计算出每颗地雷的感应弧度范围。最后再来计算所有弧度叠加起来的范围。

可以想象，我们最终要走到一个非常远的大弧度，然后将所有地雷的切线延长至这个大弧度，再将每个地雷的两条切线的至大弧度的那一段相连，这就是每颗地雷的感应弧度范围，现在还不是很好想，如果将这些弧度拉直，再想一想，这就是一个经典的贪心问题了，问题就变成了：给你一堆线段，求最终能覆盖多少长度，不作赘述。

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define yes "Yes"
#define no "No"
#define debug(x) cout<<#x<<" = "<<x<<"\n"
#define rep(i,x,y) for(int i=x;i<=(y);++i)
#define per(i,x,y) for(int i=x;i>=(y);--i)
#define fst ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);

typedef long long ll;
typedef unsigned long long ull;

using namespace std;

const int INF=0x3f3f3f3f;
const ll LNF=0x3f3f3f3f3f3f3f3f;

int n;
double l,r,sum;
vector<pdd> v;
void solve(){
	cin>>n;
	rep(i,1,n){
        double x,y,r;
		cin>>x>>y>>r;
		double theta=atan2(y,x);
        double p=sqrt(x*x+y*y);
		double delta=asin(r/p);
		v.push_back(make_pair(theta-delta,theta+delta));
	}
	sort(v.begin(),v.end());
	for(auto& p:v){
		if(p.first<=r) r=max(r,p.second);
		else{
			sum+=(r-l);
			l=p.first;
			r=p.second;
		}
	}
	sum+=(r-l);
	printf("%.3lf",1-sum/atan2(1,0));
}

int main(){
	fst;
	int t=1;
	while(t--){
		solve();
	}
	return 0;
}
```
主播这里因为前后顺序卡了好久……（毕竟我是 xxs）

---

## 作者：Sakura_Emilia (赞：0)

# Solution

计算几何基础题目。

首先对于每一个圆，需要确定它的两个切线所对应的夹角。通过简单的切线方程求解，可以得到过原点的两条切线的斜率，进而通过反正切函数得到具体的弧度值。不过在计算的时候需要注意，如果设过原点的直线为 $y=kx$，当圆与 $y$ 轴相切时，原通式的分母为零，需要进行特判。

得到每个圆所覆盖的不能通过的范围之后，使用 `pair<ld, ld>` 进行排序，查找没有被任何子段覆盖的最大长度。这部分的占比即为答案。具体的细节见下面的代码实现。

# Code

```cpp
#include <bits/stdc++.h>
#define Ciallo main
#define int long long
#define ld long double
using namespace std;
typedef pair<ld, ld> pll;
const int N = 1e6 + 8;

int n;
ld a, b, r, res;
pll p[N];

signed Ciallo() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> a >> b >> r;
        if(a == r) {
            p[i].first = atan((b * b - a * a) / (2 * a * b));
            p[i].second = 1.5708;
        } else {
            p[i].first = atan((a * b - r * sqrt(a * a + b * b - r * r)) / (a * a - r * r));
            p[i].second = atan((a * b + r * sqrt(a * a + b * b - r * r)) / (a * a - r * r));
        }
    }

    sort(p + 1, p + n + 1);
    ld pre = 0;
    for(int i = 1; i <= n; i++) {
        if(p[i].first > pre)
            res += p[i].first - pre;
        pre = max(pre, p[i].second);
    }
    res += 1.5708 - pre;

    cout << fixed << setprecision(3) << res / 1.5708 << endl;

    return 0;
}
```

---

## 作者：__qkj__ (赞：0)

## 解题思路
我们可以画张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/2e9s6ot5.png)

则 $\text{∠BAF}=\arctan(\dfrac{\text{AE}}{\text{AF}}),\text{∠BAC}=\text{∠BAD}=\arcsin(\dfrac{\text{BD}}{\text{AB}})$。

然后把每个圆经过原点的切线的角度都记录下来（即 $\text{∠BAF}-\text{∠BAC}$ 和 $\text{∠BAF}+\text{∠BAC}$），把它当做一条直线上的几个区间。这样，就可以按左端点排个序，从而转化为一个区间问题。具体看代码注释。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const double pi=3.1415926;
struct node
{
	double x,y;
}a[100010];
bool cmp(node xx,node yy)
{
	return xx.x<yy.x;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		double x,y,r;
		cin>>x>>y>>r;
		double th=atan(x/y)*180/pi;
		double the=asin(r/sqrt(x*x+y*y))*180/pi;
		a[i].x=th-the;
		a[i].y=th+the;
	}
	sort(a+1,a+n+1,cmp);
	double maxn=0,s=0;
	for(int i=1;i<=n;i++)
	{
		if(maxn<a[i].x)s+=a[i].x-maxn;//如果两个区间之间有空隙，就累加。
		maxn=max(maxn,a[i].y);//右端点最大值
	}
	if(maxn<90)s+=90-maxn;//别忘了与 y 轴的空隙
	printf("%.3lf",s/90);//计算概率
	return 0;
}

```

---

## 作者：lyxxys (赞：0)

### 解题思路
把不相遇转化为弧度制下区间的覆盖问题，最后做区间合并。由于忘了怎么求切线，我就无脑二分斜率了。


考虑圆的方程
$(x-x_i)^2 + (y-y_i)^2  = r_i^2 $

将 $y = kx$ 代入，
有解当且仅当 $(x_i+ ky_i)^2 + (1+k^2)(r^2-x^2-y^2) \geq 0$.

根据该方程求得两个边界，然后得到一堆在 $[0, \frac{\pi}{2}]$ 的区间，再求补集即可。



---
### 复杂度分析
时间复杂度 $O(n\log{n})$，空间复杂度 $O(n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using f64 = long double;
using u64 = unsigned long long;
const f64 eps = 1e-12;
const i64 inf_i64 = 1e18;
const int inf_int = 1e9;
template <class T> void fmax(T &a, const T &b){
    if (b > a) a = b;
}
template <class T> void fmin(T &a, const T &b){
    if (b < a) a = b;
}
template <class T> void print(vector <T> &A, int d = 0){
    int n = A.size();
    for (int i = 0; i < n; ++ i){
        if (i) cout << " ";
        cout << A[i]+d;
    }
    cout << "\n";
}
int jgs(f64 x){
    return x < -eps ? -1 : x > eps;
}

void solve(){
    const f64 pi_d_2 = acosl(-1.0)/2;

    int n;
    cin >> n;

    auto chk = [&](f64 x, f64 y, f64 r, f64 k)->bool{
        f64 d = r*r - x*x - y*y;
        return (x + k*y)*(x + k*y) + (1 + k*k) * d >= 0;
    };
    auto find_up = [&](f64 x, f64 y, f64 r)->f64{
        f64 lo = y/x, hi = 9e18;
        for (int i = 0; i < 150; ++ i){
            f64 mid = (lo + hi) / 2;
            if (chk(x, y, r, mid)) lo = mid;
            else hi = mid;
        }
        return lo;
    };
    auto find_down = [&](f64 x, f64 y, f64 r)->f64{
        f64 lo = 0, hi = y/x;
        for (int i = 0; i < 150; ++ i){
            f64 mid = (lo + hi) / 2;
            if (chk(x, y, r, mid)) hi = mid;
            else lo = mid;
        }
        return lo;
    };

    vector <array<f64,2>> segs;

    for (int i = 0; i < n; ++ i){
        int x, y, r;
        cin >> x >> y >> r;
        f64 lo = find_down(x, y, r), hi = find_up(x, y, r);
        lo = atanl(lo);
        hi = atanl(hi);
        segs.push_back({lo, hi});
    }

    sort(segs.begin(), segs.end(), [&](auto &u, auto &v){
        return u[0] < v[0];
    });

    f64 res = 0;
    f64 l = 0, r = 0;
    for (int i = 0; i < n; ++ i){
        f64 u = segs[i][0], v = segs[i][1];
        if (u > r){
            res += r-l;
            l = u;
            r = v;
        } else {
            if (v > r) r = v;
        }
    }

    res += r-l;

    cout << fixed << setprecision(3);
    cout << (pi_d_2 - res) / pi_d_2 << "\n";
}

int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    while (_--){
        solve();
    }
    return 0;
}
```

---

## 作者：postpone (赞：0)

对于每个圆，求过原点与圆的两条切线的斜率，将斜率转化成角度，那么这两个角度之间是不能选择的。

于是这题就能转化成：在一个范围内有很多个线段，求没有被线段覆盖的总长度。扫描线即可。

关于如何求过原点与圆的切线的斜率，我赛时的方法是往上往下用二分找，到圆心距离等于半径的斜率。可能有更快捷的方法。

```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
using u128 = unsigned __int128;

double dis(double x, double y, double u, double v) {
    double dx = x - u;
    double dy = y - v;

    return std::sqrt(dx * dx + dy * dy);
}

double dis(double u, double v, double k) {
    double den = k + 1. / k;
    double x = v + u / k;
    x /= den;
    double y = k * x;
    return dis(x, y, u, v);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    vector<int> x(n), y(n), r(n);
    for (int i = 0; i < n; i++) {
        cin >> x[i] >> y[i] >> r[i];
    }

    double pi = acos(-1);

    vector<pair<double, int>> e;
    e.push_back({pi / 2, -1});
    for (int i = 0; i < n; i++) {
        double k0 = (double)y[i] / x[i];
        {
            double lo = 0, hi = k0;
            while (lo + 1e-6 < hi) {
                double k = (lo + hi) / 2;
                if (dis(x[i], y[i], k) <= r[i]) {
                    hi = k;
                } else {
                    lo = k;
                }
            }
            e.push_back({atan(lo), 1});
        }
        {
            double lo = k0, hi = 1e9;
            while (lo + 1e-6 < hi) {
                double k = (lo + hi) / 2;
                if (dis(x[i], y[i], k) >= r[i]) {
                    hi = k;
                } else {
                    lo = k;
                }
            }
            e.push_back({atan(lo), -1});
        }
    }
    ranges::sort(e);

    double den = pi / 2;
    double num = 0;
    int sum = 0;
    double lst = 0;
    for (auto [x, i] : e) {
        if (sum <= 0) {
            num += x - lst;
        }
        sum += i;
        lst = x;
    }

    double ans = num / den;
    cout << fixed << setprecision(3) << ans << "\n";

    return 0;
}
```

---


# [USTCPC 2025] 高位逼抢

## 题目背景

考虑到评测机性能差异，改为 2s 时限。USTCPC 时限为 3s。

（题面最后提供了形式化的描述）

克露丝卡尔酱最近开始游玩“实况足球”手游，在天梯遭遇10连败之后，又不幸匹配上了臭名昭著的“倒脚狗”。只见那可憎的对手将足球从后卫传到门将，又从门将传到后卫，又从后卫传到门将······

是可忍，孰不可忍！怒不可遏的克露丝卡尔酱操纵自己的球员大举压上，向对手展开了高压逼抢。只可惜那对手发扬 Tiki-taka 战术，来回传球，把克露丝卡尔酱的上抢球员耍的团团转。

说时迟，那时快，对手见克露丝卡尔酱全军出击，后防空虚，一个大脚将皮球开到前场。对手的前锋接球长驱直入，轻松攻破了克露丝卡尔酱的大门！

克露丝卡尔酱自闭的卸载了“实况足球”，虽然过了几天又下了回来。但是在东山再起之前，她想要请教“实况足球”领域大神——你，该如何对付可恶的“倒脚狗”。

## 题目描述

一场球赛上，对手共有 $n$ 名球员，但由于距离和技术限制，并不是任何两名球员之间都可以互相直接传球。具体来说，有且仅有 $m$ 对球员之间可以互相传球。

当对手持球时，克露丝卡尔酱可以操纵球员上抢和封堵传球路线，具体地，当 $x+1$ 名队员去**高压逼抢**时:

- 有 $1$ 名球员上抢，干扰持球球员。
- 其余 $x$ 名球员，每个球员会**封堵至多一条传球路线**。

由于没有练习过花式技巧，持球球员不会过人。因此在受到干扰后，持球球员必须立刻将球通过一条传球路线传给某个队友。

如果某一时刻，持球球员发现自己所有的传球线路都被封堵。此时上抢球员直扑右脚，持球球员**丢失球权**。

然而，过多的前场逼抢会快速地消耗球员体力，同时也会给防守带来隐患。因此，克露丝卡尔酱希望想知道：当对方的第 $i$ 号球员拿球时，$x$ 至少为多少，可以保证在有限的时间内抢下足球？


### 形式化题面
一个 $n$ 个点 $m$ 条边的无向图（无重边自环），一个棋子，还有一个常数 $x$。A 和 B 玩一个游戏。

初始棋子位于 $i$ 节点，此后每一回合：

- B 选定至多 $x$ 条边删掉
- A 把棋子沿着某条边移到另一个节点
- B 把刚刚删掉的边复原

如果 A，B 都绝顶聪明，并且在有限轮中，B 可以把 A 逼入绝境（无法移动），则 B 胜利，否则 A 胜利。

对于 $i\in[1,n]$ 求 $x$ 至少为多少，B 才胜利。

## 样例 #1

### 输入

```
5 5
1 4
2 5
1 2
2 3
3 1```

### 输出

```
2 2 2 1 1```

## 样例 #2

### 输入

```
1 0```

### 输出

```
0```

## 样例 #3

### 输入

```
6 9
1 2
1 3
1 4
1 5
1 6
2 3
2 5
2 6
5 6```

### 输出

```
3 3 2 1 3 3```

## 样例 #4

### 输入

```
3 2
1 2
2 3```

### 输出

```
1 1 1```

# 题解

## 作者：mairuisheng (赞：4)

- 题目：[P12039 [USTCPC 2025] 高位逼抢](https://www.luogu.com.cn/problem/P12039)

- 主要算法：拓扑排序。

- 题意：

题意很清楚了（见题目形式化题面）：

一个 $n$ 个点 $m$ 条边的无向图（无重边自环），一个棋子，还有一个常数 $x$。A 和 B 玩一个游戏。

初始棋子位于 $i$ 节点，此后每一回合：

- B 选定至多 $x$ 条边删掉
- A 把棋子沿着某条边移到另一个节点
- B 把刚刚删掉的边复原

如果 A，B 都绝顶聪明，并且在有限轮中，B 可以把 A 逼入绝境（无法移动），则 B 胜利，否则 A 胜利。

对于 $i\in[1,n]$ 求 $x$ 至少为多少，B 才胜利。

- 分析：

设 $ans_i$ 为第 $i$ 个节点的答案。显然，$ans_i$ 要初始化为节点 $i$ 的出度，因为将 $i$ 节点的出边全部删除，棋子就无法移动了。

但是，这时的答案肯定不是最优的，所以，我们要减小 $ans_i$ 以此得到最优解。

我们发现出度最小的点已经是最优解了，因为无法用一个比它出度更小的节点更新它。于是，我们可以用一个出度小的节点更新一个出度大的节点。

我们用 `set`（或用 `priority_queue`）维护，每次取出出度最小的节点 $i$，用 $i$ 更新它的子节点 $j$，如果 $ans_j>ans_i$，就在集合中删除 $j$，将 $ans_j$ 赋值为 $ans_j-1$，最后插回集合。

- 时间复杂度：$O(n \log m)$。

- 参考代码：

```cpp
//#pragma GCC optimize(3)
#include<cstdio>
#include<vector>
#include<set>
using namespace std;
inline int read()
{
    int x=0,f=1;
    char s;
    s=getchar();
    while(s<48||s>57)
    {
        if(s=='-')f=-f;
        s=getchar();
    }
    while(s>47&&s<58)
    {
        x=(x<<3)+(x<<1)+s-48;
        s=getchar();
    }
    return x*f;
}
constexpr int N=1e6+1;
int n,m;
vector<int> g[N];
int in[N];
set<pair<int,int>> s;
int main()
{
	int i,x,y;
	n=read();
	m=read();
	while(m--)
	{
		x=read();
		y=read();
		g[x].push_back(y);
		g[y].push_back(x);
		++in[x];
		++in[y];
	}
	for(i=1;i<=n;++i)s.insert({in[i],i});
	while(!s.empty())
	{
		auto u=s.begin();
		s.erase(u);
		x=u->second;
		for(auto v:g[x])
		{
			if(in[v]>in[x])
			{
				s.erase({in[v],v});
				s.insert({--in[v],v});
			}
		}
	}
	for(i=1;i<=n;++i)printf("%d ",in[i]);
    return 0;
}
```

---

## 作者：jcc680937 (赞：3)

## 题目分析：
  首先，我们可以初始化每一个节点的答案是这个节点的出度，因为删除一个节点所有的出边会使这个节点无法去往其他节点。

然而我们可以证明这个答案并不是最优解，因此我们应该减小当前答案。

此时我们发现，出度最少节点的答案就是它的出边数量，因为当封堵边数比最小出边数量还要小时，球的位置就会转移到其他出度更大的节点上，更不可能得到最优解。

接着，我们可以使用拓扑排序进行更新，先用 ```set``` 维护出边最少的节点，每次取出该节点，遍历与它相邻的节点。而相邻节点已经有一条边无需遍历（即与出边最少节点相连的那条边，因为即使走向出边最少的节点，也无法获得比当前节点更劣的答案，因此无需遍历），因此将该点的答案减一，放入集合中，并删除原来存储的答案。


## AC code
```cpp
#include<bits/stdc++.h>
#define IOSO ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
using namespace std;
const int N=1e6+10;
int n,m,fa[N];
vector<int> p[N];
set<pair<int,int> >q;
signed main()
{
	IOSO;//读入优化
	cin>>n>>m;
	while(m--)
	{
		int x,y; cin>>x>>y;
		p[y].push_back(x);
		p[x].push_back(y);//双向建边
		fa[x]++; fa[y]++;
	}
	for(int i=1;i<=n;i++)
		q.insert({fa[i],i});
//初始化将每个点的答案设为出边数量。
	while(!q.empty())
	{
		auto tmp=q.begin();
		q.erase(tmp);
		int tmp2=tmp->second;
		for(auto v:p[tmp2])
		{
			if(fa[v]>fa[tmp2])			
			{
				q.erase({fa[v],v});
				fa[v]--;
				q.insert({fa[v],v});
                //删除原来答案，并将答案减一放入队列中。
			}
	 	}
	}
	for(int i=1;i<=n;i++) cout<<fa[i]<<" ";
return 0;
}
```

**写在最后：**

这篇题解可能会有不足之处，欢迎在评论区批评指出。

---

## 作者：kukuchiu (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P12039)

# 解题思路

~~没想到竟然有人的题解和我的思路差不多~~

 * 其实我们可以发现，如果我们把持球球员的所有传球路线全部封堵，那么是一定能抢到球的。此时 $x = $ 持球球员传球路线的总数。

 * 我们很快就可以发现上面的不一定是最优解。因为可能会有一些球员（我们称这种球员为无效球员）在当前的 $x$ 已经不能再把球传给任何一个球员了。这时我们就没有必要把传给无效球员的传球路线给删去了。

 * 度越小的球员越可能是无效球员，这是我们就可以用 set 或 priority_queue 来维护（我用的是 set）。

# AC code


```cpp
#include <iostream>
#include <vector>
#include <map>
#include <set>
using namespace std;

const int N = 1e6 + 10;

int du[N], n, m;

vector<int> edge[N];

set<pair<int, int> > st;

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v; i <= m; i++)
	{
		scanf("%d%d", &u, &v);
		du[u]++, du[v]++;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	for (int i = 1; i <= n; i++)
	{
		st.insert(make_pair(du[i], i));
	}
	while (!st.empty())
	{
		auto x = st.begin();
		st.erase(x);
		int u = x->second;
		for (auto v : edge[u])
		{
			if (du[v] > du[u])
			{
				st.erase(make_pair(du[v], v));
				st.insert(make_pair(--du[v], v));
			}
		}
	}
	for (int i = 1; i <= n; i++)
	{
		printf("%d ", du[i]);
	}
	return 0;
}
```

---

## 作者：Vae_L (赞：1)

~~好吧我承认我就是倒脚狗。~~

首先注意到 $x$ 的选择带有单调性，即 $x$ 的选择可以满足那么 $x+1$ 也可以满足。

容易发现把每个点都删除所有出边变成孤立点是一定合法的，但也不一定优。

不一定优的原因是，可能存在一些与当前点连边的点在当前 $x$ 下已经是不可达的点，这些边没有必要删去，我们把这点成为红点。

注意到出度最小的点不可能再有更优的选择，想到使用 set 维护红点集合，去更新其他的点。

如果当前的 $x$ 最小的红点比其所连的某一点的 $x$ 要小，也就代表其所连的那一点在当前 $x$ 下并非最优解，因为有该红点的存在，减一即可。

代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n,m,u,v,du[1000005];
vector<int>vec[1000005];
set<pair<int,int>>se;
void solve()
{
	for(int i=1;i<=n;i++) se.insert({du[i],i});
	while(!se.empty())
	{
		auto x=se.begin();
		se.erase(x);
		int now=x->second;
		for(auto it:vec[now])
		{
			if(du[it]>du[now]) 
			{
				se.erase({du[it],it});
				se.insert({du[it]-1,it});
				du[it]--;
			}
		}
	}
}
signed main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++) u=read(),v=read(),vec[u].push_back(v),vec[v].push_back(u),du[v]++,du[u]++;
    solve();
	for(int i=1;i<=n;i++) cout<<du[i]<<" ";
    return 0;
}

---

## 作者：GDlh (赞：1)

## 题面
一个 $n$ 个点 $m$ 条边的无向图（无重边自环），一个棋子，还有一个常数 $x$。A 和 B 玩一个游戏。

初始棋子位于 $i$ 节点，此后每一回合：

- B 选定至多 $x$ 条边删掉
- A 把棋子沿着某条边移到另一个节点
- B 把刚刚删掉的边复原

如果 A，B 都绝顶聪明，并且在有限轮中，B 可以把 A 逼入绝境（无法移动），则 B 胜利，否则 A 胜利。

对于 $i\in[1,n]$ 求 $x$ 至少为多少，B 才胜利。

## 解法
对于每一个节点 $i$ ，我们定义 $f_i$ 表示当棋子在该节点作为起点时，至少需要删掉多少条边才能将其逼入死角。

显然， $f_i$ 的初始值为该节点的出度（将与其相邻的所有边都删除了，显然逼入了死角），但是这显然不是最小的 $f_i$。

于是我们考虑如何减小每个点的 $f_i$ ，可以发现整张图里面出度最小的点的 $f_i$ 值是没办法在减小的了，而出度较大的点可以考虑只删除部分的边，使剩下的边都连向节点 $v,f_v \le f_i$ 。

于是，我们可以使用递推的方式，将所有点扔进 set （或堆）里，每次取出出度最小的节点 $i$ ，将所有与 $i$ 相邻的节点 $v$ ， $ f_v-1 \gets f_v , f_v > f_i$ 。  
注意此处使用 set ，是因为每次修改 $f_v$ 后，其在剩余节点中的大小关系都可能会改变，而对于每次操作，我们都应保证取出的是剩余节点中 $f_i$ 值最小的来去更新别的节点。

复杂度： $O(m\log{n})$ 。

赛时满分代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+66,M=2e6+66;
int n,m,head[N],cnt,d[N],ans[N];
set<pair<int,int> > sa;
struct Edge{
	int to,nxt;
}E[M<<1];

void add_Edge(int u,int v){
	E[++cnt].to=v;
	E[cnt].nxt=head[u];
	head[u]=cnt;
}

int main(){
	ios::sync_with_stdio(0); cin.tie(0);
	cin>>n>>m;
	memset(head,-1,sizeof(head));
	for(int i=1;i<=m;++i){
		int u,v; cin>>u>>v;
		add_Edge(u,v);
		add_Edge(v,u);
		d[u]++; d[v]++;
	} 
	for(int i=1;i<=n;++i) {
		ans[i]=d[i];
		sa.insert({d[i],i});
	}
	while(!sa.empty()){
		auto tmp=sa.begin();
		int k=tmp->second;
		sa.erase(tmp);
		for(int j=head[k];~j;j=E[j].nxt){
			int v=E[j].to; 
			if(ans[v]>ans[k]) {
				sa.erase({ans[v],v});
				ans[v]-=1;
				sa.insert({ans[v],v});
			}
		}
	}
	for(int i=1;i<=n;++i) cout<<ans[i]<<' ';
	return 0;
}
```

---

## 作者：ethan_zhou (赞：1)

宣传博客：[USTCPC25 F&K 题解](https://www.blog-e.top/p/%E9%A2%98%E8%A7%A3ustcpc25-fk%E9%A2%98%E8%A7%A3/)

这道题是一个远古（中学时想的） idea，没想到成大三老登了竟然还能用上。

### 判定问题

假设 $x$ 一定，那么球位于某些点的时候，A 是不败的，称这些点为 **胜点**，其余点是 **败点**。考虑如何判定每一个点的胜败。

一个点 $p$ 是败点的充要条件是：

$$
\text {与 } p \text { 相连的胜点数量} = \deg (p) - \text {与 } p \text { 相连的败点数量} \leq x.
$$

于是可以通过类似拓扑排序的方式，求出所有败点：

- 首先把所有满足 $\deg (p) \leq x$ 的点入队，这些点一定是必败无疑的。
- 取出队首，更新与该点相连的点 $v$ 的 
  $$
  \deg (v) - \text {与 } v \text { 相连的败点数量}
  $$ 
  的值，如果小于等于 $x$，则 $v$ 也入队。

显然，上述过程中，所有进入过队列的点就是败点。


### 最小化 $x$

一个显然的结论是：  
$x$ 对应的败点点集是 $x+1$ 对应的败点点集的子集：

$$
\text {$x$ 对应的败点点集} \subset \text {$x+1$ 对应的败点点集}.
$$

所以我们有一个暴力（但对正解有启发性）的方法：

- 首先对 $x = 1$ 做判定；
- 然后对于在 $x = 1$ 的判定过程中没有入队的结点，再看是否满足 $x = 2$ 时的入队条件，若满足则进行 $x = 2$ 的判定；
- 然后对于在 $x = 2$ 的判定过程中没有入队的结点，再看是否满足 $x = 3$ 时的入队条件，若满足则进行 $x = 3$ 的判定；
- 以此类推……

最后只需要记录每个点在 $x$ 等于几时入队，即为该点的答案。


### 优化

发现上述过程中的入队顺序等价于：  
把所有节点扔到以 

$$
\deg (p) - \text {与 } p \text { 相连的败点数量}
$$

为关键字排序的小根堆中，每次取出队首并更新相关信息。

时间复杂度为 $O (m \log m)$。

如果把优先队列换成桶，并进行精细实现，可以做到线性复杂度。

---

## 作者：hgckythgcfhk (赞：1)

广告：[USTCPC2025 题解汇总（部分）](https://www.luogu.com.cn/article/xl8dsc9j)。

这个问题的结构显然具有集合的单调性，所以先考虑判定一个 $x$ 会使得哪些点的答案至少为 $x$，也就是要写一个 ```chk```，这里其实已经可以推测大体做法就是整体二分或者不断扩大 $x$ 并维护 $x\to x+1$ 的变化，但先不讨论这个，先按部就班的刻画问题的结构。

A 在一个点 $u$ 上能赢的充要条件是与 $u$ 相连的能赢的节点个数大于 $x$，因为 B 一定会删能使 A 赢的边，否则一定不优，所以必要性是显然的，同时如果 B 删不完 A 一定会走到一个能赢的点，所以这个条件是充要的。

考虑刻画能赢的节点个数，可以容斥成度数减去不能赢的节点个数，而度数小于等于 $x$ 的节点一定不可能赢，先把这些点标记下来删掉，然后剩下的点相当于已经减去了不能赢的节点个数，然后重复这个过程直到所有点都被删掉或者没有点能删得掉为止。

由于节点之间的影响不好处理，看起来不太整体二分，所以考虑维护 $x\to x+1$ 的变化，前面提到过问题结构具有集合的单调性，所以初始化 $x=0$，可以考虑当没法继续删点的时候让 $x\to x+1$ 继续做，然后相当于一个数据结构问题，单点减 $1$，全局 $\min$，删除全局 $\min$，数据结构中维护的是度数，由于度数不超过 $n$，所以可以开 $n$ 的 ```vector```，每个点只会被删一次和被换到度数更小的 ```vector``` 不超过度数次，所以时间复杂度是 $O(n+m)$ 的，当然这个可以用线段树维护，而且事实上我现在贺的赛时代码确实是线段树写的。

以下是线下选手 $42$ 队提供的赛时代码，非常感谢 $42$ 队。

```cpp
#include<iostream>
#include<vector>
#define lo (o<<1)
#define ro (lo|1)
#define mr(x,y) make_pair(x,y)
using namespace std;
const int N=1e6+10,inf=1e7;
typedef pair<int,int>pi;
int n,m,a[N],nw=0,ans[N];
struct Tree{
	pi b[N<<2];
	void build(int o=1,int l=1,int r=n){
		if(l==r){
			b[o]=mr(a[l],l);
			return;
		}
		int mid=(l+r)>>1;
		build(lo,l,mid);
		build(ro,mid+1,r);
		b[o]=min(b[lo],b[ro]);
	}
	void update(int qx,int tf,int o=1,int l=1,int r=n){
		if(l==r){
			if(tf==0)b[o].first=b[o].first-1;
			else b[o].first=inf;
			return;
		}
		int mid=(l+r)>>1;
		if(qx<=mid)update(qx,tf,lo,l,mid);
		else update(qx,tf,ro,mid+1,r);
		b[o]=min(b[lo],b[ro]);
	}
}T;
vector<int>bc[N];
int main(){
	scanf("%d%d",&n,&m);
	//for(int i=1;i<=n;i++)ans[i]=-1;
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		bc[u].push_back(v);
		bc[v].push_back(u);
		a[u]++,a[v]++;
	}
	T.build();
	for(int i=1;i<=n;i++){
		
		nw=max(T.b[1].first,nw);
		int u=T.b[1].second;
		ans[u]=nw;
		T.update(u,1);
		int sz=bc[u].size();
		for(int j=0;j<sz;j++){
			int v=bc[u][j];
			//cout<<v;
			T.update(v,0);
		}
	}
	for(int i=1;i<=n;i++)printf("%d ",ans[i]);
	return 0;
}
```

---


# 游览

## 题目描述

顺利通过了黄药师的考验，下面就可以尽情游览桃花岛了！

你要从桃花岛的西头开始一直玩到东头，然后在东头的码头离开。可是当你游玩了一次后，发现桃花岛的景色实在是非常的美丽！！！于是你还想乘船从桃花岛东头的码头回到西头，再玩一遍，但是桃花岛有个规矩：你可以游览无数遍，但是每次游玩的路线不能完全一样。

我们把桃花岛抽象成了一个图，共 $n$ 个点代表路的相交处，$m$ 条边表示路，边是有向的（只能按照边的方向行走），且可能有连接相同两点的边。输入保证这个图没有环，而且从西头到东头至少存在一条路线。两条路线被认为是不同的当且仅当它们所经过的路不完全相同。

你的任务是：把所有不同的路线游览完一共要花多少时间？


## 说明/提示

【样例说明】

共有 $3$ 条路径可以从点 $1$ 到点 $3$，分别是 $1-2-3$，$1-2-3$，$1-3$。

时间计算为：

$(5+7)+7        +(5+10)+7        +(15)=56$

### 数据范围

$2\leq n\leq 10^4$，$1\leq m\leq 5\times 10^4$，$t\leq 10^4$，$t_0\leq 10^4$。

## 样例 #1

### 输入

```
3 4 1 3 7
1 2 5
2 3 7
2 3 10
1 3 15
```

### 输出

```
56```

# 题解

## 作者：ZAGER (赞：19)

## 题解

### 最美的[透彻](https://www.cnblogs.com/ZAGER/p/9818196.html)

我们定义

$cnt[i]$表示到点$i$的次数；

$dis[i]$表示到点$i$的总路径长度。

所以$ans=dis[t]+(cnt[t]-1)*t0$

如何去转移$cnt$和$dis$数组呢

$dfs$一遍不就行了

考虑一条边从$u$到$v$，边权为$w$

$dis[v]=dis[v]+dis[u]+cnt[u]*w;$

$cnt[v]+=cnt[u];$

初始化:$cnt[s]=1$

但是绝对不能直接$dfs$去遍历，只能得$20$分。

我一开始就直$dfs$，还是太菜了（20分）。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cctype>
#define ll long long
#define R register
#define mod 10000
#define N 50005
using namespace std;
template<typename T>inline void read(T &a){
    char c=getchar();T x=0,f=1;
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    a=f*x;
}
int n,m,s,t,ti,tot,h[N];
ll cnt[N],dis[N];
struct node{
    int nex,to,dis;
}edge[N<<1];
inline void add(R int u,R int v,R int w){
    edge[++tot].nex=h[u];
    edge[tot].to=v;
    edge[tot].dis=w;
    h[u]=tot;
}
inline void dfs(R int x){
    for(R int i=h[x];i;i=edge[i].nex){
        R int xx=edge[i].to;
        (dis[xx]+=dis[x]+cnt[x]*edge[i].dis)%=mod;
        (cnt[xx]+=cnt[x])%=mod;
        dfs(xx);
    }
}
int main(){
    read(n);read(m);read(s);read(t);read(ti);
    for(R int i=1,u,v,w;i<=m;i++){
        read(u);read(v);read(w);
        if(u!=v)add(u,v,w);
    }
    cnt[s]=1;
    dfs(s);
    printf("%lld\n",(dis[t]+(cnt[t]-1)*ti)%mod);
    return 0;
}
```

为什么这样不对？？

因为有一些点的信息我们还没有收集全面就用它去更新其他点了。

如何解决（感谢$wtx$大佬指导），

拓扑排序呀，当一个点入度为0时就说明已经没有点可以去更新它了，说明它的信息收集已经完全了。

正确的代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cctype>
#define ll long long
#define R register
#define mod 10000
#define N 50005
using namespace std;
template<typename T>inline void read(T &a){
    char c=getchar();T x=0,f=1;
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    a=f*x;
}
int n,m,s,t,ti,tot,h[N],in[N];
ll cnt[N],dis[N];
struct node{
    int nex,to,dis;
}edge[N<<1];
inline void add(R int u,R int v,R int w){
    edge[++tot].nex=h[u];
    edge[tot].to=v;
    edge[tot].dis=w;
    h[u]=tot;
    in[v]++;
}
inline void dfs(R int x){
    for(R int i=h[x];i;i=edge[i].nex){
        R int xx=edge[i].to;
        (dis[xx]+=dis[x]+cnt[x]*edge[i].dis)%=mod;
        (cnt[xx]+=cnt[x])%=mod;
        --in[xx];//拓扑排序
        if(!in[xx])dfs(xx);
    }
}
int main(){
    read(n);read(m);read(s);read(t);read(ti);
    for(R int i=1,u,v,w;i<=m;i++){
        read(u);read(v);read(w);
        if(u!=v)add(u,v,w);
    }
    cnt[s]=1;
    dfs(s);
    printf("%lld\n",(dis[t]+(cnt[t]-1)*ti)%mod);
    return 0;
}
```



---

## 作者：Dehydration (赞：18)

### 前言：

绿题就是绿题，做出来也得十几分钟。

看一下居然是最优解！

[Problem](https://www.luogu.com.cn/problem/P1685)。

[最优解提交记录](https://www.luogu.com.cn/record/list?pid=P1685&orderBy=1&status=&page=1)。

### 思路和代码：

首先我就想到了动态规划：

设 $dp_{i1}$ 表示起点到 $i$ 点总共需要花费的。

设 $dp_{i0}$ 表示起点到 $i$ 点的总方案数。

说句题外话：我首先没想到要搞方案数，死了五分钟。

则如果从 $x$ 走到 $y$ 而且他们之间代价为 $money$ 可得出：

$dp_{y0}=dp_{x0}+dp_{y0}$。

$dp_{y1}=dp_{y1}+dp_{x1}+dp_{x0}\times money$。

第一个很简单理解，这是因为方案数为累加，运用加法原理。

第二个是将两点的总价值相加，再加上方案数乘上代价，这是因为一共有方案数个方案，这条线也需走方案数个，需相乘再相加。

于是愉快地得出错误代码：

```c++
//20pts
//luogu P1685
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
int dp[N][2],n,m,qi,zh,p;
struct DO
{
    int next;
    int to;
    int money;
};
const int maxn=5e4+5; 
DO a[maxn];
int head[maxn],cnt=1;
void add(int x,int y,int sum)
{
    a[cnt].to=y;
    a[cnt].money=sum;
    a[cnt].next=head[x];
    head[x]=cnt++;
}
void DP(int x)
{
	for(int i=head[x];i;i=a[i].next)
	{
		int y=a[i].to;
		dp[y][0]=(dp[x][0]+dp[y][0])%10000;
		dp[y][1]=(dp[y][1]+dp[x][1]+dp[x][0]*a[i].money)%10000;
		DP(y);
	}
}
int main()
{
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>qi>>zh>>p; 
	for(int i=1;i<=m;i++)
	{
		int x,y,sum;
		cin>>x>>y>>sum;
		add(x,y,sum);
	}
	dp[qi][0]=1;
	DP(qi);
	cout<<((dp[zh][0]-1)*p+dp[zh][1])%10000;
} 
```

绿+红+黑。

我们发现，直接搜到这点继续往下搜有可能信息不全，会错误，而且搜那么多次，很显然会超时，为了预防这些，我们可以记录点的入度，如果入读为零即可安心往下搜。

于是我们修改函数和输入，得出最优解：

```
//100pts
//luogu P1685
//最优解（用快读+关闭输出流的cout
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
int dp[N][2],n,m,qi,zh,p;
int in[N];
struct DO
{
    int next;
    int to;
    int money;
};
typedef int LL;
inline LL read()
{
	register LL x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int maxn=5e4+5; 
DO a[maxn];
int head[maxn],cnt=1;
void add(int x,int y,int sum)
{
    a[cnt].to=y;
    a[cnt].money=sum;
    a[cnt].next=head[x];
    head[x]=cnt++;
}
void DP(int x)
{
	for(int i=head[x];i;i=a[i].next)
	{
		int y=a[i].to;
		dp[y][0]=(dp[x][0]+dp[y][0])%10000;
		dp[y][1]=(dp[y][1]+dp[x][1]+dp[x][0]*a[i].money)%10000;
		in[y]--;
		if(!in[y])DP(y);
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	n=read(),m=read(),qi=read(),zh=read(),p=read();
	for(int i=1;i<=m;i++)
	{
		int x,y,sum;
		x=read(),y=read(),sum=read(),in[y]++;
		add(x,y,sum);
	}
	dp[qi][0]=1;
	DP(qi);
	cout<<((dp[zh][0]-1)*p+dp[zh][1])%10000;
} 
```

如果觉得这个有用，那就点赞顶这篇题解，谢谢！

---

## 作者：_djc_ (赞：14)

## 题目分析

这是一道借助拓扑排序实现递推的题。

首先我们考虑递推式子：我们定义 $ct_x$ 表示经过 $x$ 这个点几次，$tme_x$ 表示以 $x$ 这个点为终点的最多游览时间（不考虑从西头回到东头的），$w(x, y)$ 表示 $x$ 到 $y$ 这条边所耗时间。对于 $x$ 的出边所到达的点 $y$ ，我们可以考虑一下 $x$ 对 $y$ 的贡献是什么：很显然，$tme_y$ 要加上 $tme_x$ 和 $ct_x \times w(x, y)$，从 $x$ 转移到 $y$ 不仅以往的要转移过来，还有走路径的贡献：经过 $x$ 这个点几次就要走几次 $(x, y)$ 这条路，用 $ct_x$ 乘上边权就可以把所有贡献全计算上，这样 $x$ 这个点就不用考虑了。所以第一个递推式子是：$tme_y += tme_x + ct_x \times w(x, y)$ 我们还要考虑 $ct$ 的转移：既然可以经过 $x$ 节点 $ct_x$ 次，那对于 $y$ 肯定也能经过 $ct_x$ 次，所以还要：$ct_y += ct_x$。

递推的过程可以通过拓扑排序来实现，因为拓扑排序总是将入度为 $0$ 的点加入，而将拓展完的节点舍去，而对于本题这个性质刚好：对于一个点，只有他的贡献被算清楚不会再变动时，我们才能安心地用它来递推，这时就是处理完他的所有入边的时候。

最后我们只要输出 $tme_t + (ct_t - 1) \times t_0$ 模 $10000$ 的值就行了。

## 代码

注意一下关键字 $time$ 哦（还有缩写成 $tm$ 没想到也是关键字结果就 CE 了挺郁闷）

```cpp
#include <bits/stdc++.h>
#define int long long
#define maxn 10005
#define inf 1e9
#define mod 10000
using namespace std;
inline int read() { //来自 xjz 巨佬的快读
	int x = 0, f = 1; char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}
int n, m, s, t, t0;
int ct[maxn], tme[maxn];
int in[maxn];
struct edge {
	int v, w, nxt;
}e[maxn];
int head[maxn], cnt;
void add(int u, int v, int w) {
	e[++cnt].v = v, e[cnt].w = w;
	e[cnt].nxt = head[u], head[u] = cnt;
}

signed main() {
	n = read(), m = read(), s = read(), t = read(), t0 = read();
	for (int i = 1; i <= m; i++) {
		int u = read(), v = read(), w = read();
		add(u, v, w);
		in[v]++;
	}
    
   	//拓扑排序
	queue<int> q;
	for (int i = 1; i <= n; i++)
		if (in[i] == 0) q.push(i), ct[i] = 1;
	while (!q.empty()) {
		int x = q.front();
		q.pop();
		for (int i = head[x]; i; i = e[i].nxt) {
			int y = e[i].v, z = e[i].w;
        		//递推式子，上面有解释，注意实时模 mod ,一个也不能少
			tme[y] = (tme[y] + tme[x] + ct[x] * z) % mod;
			ct[y] = (ct[y] + ct[x]) % mod;
			if (--in[y] == 0) q.push(y);
		}
	}
	cout << (tme[t] + (ct[t] - 1) * t0 % mod) % mod;
}

```

完结撒花——

---

## 作者：雨季 (赞：5)

# 题解
写个递归版本的吧  

对于一条边$(u,v)$，它对答案的贡献就是这条边的 经过次数$\times$边权  

那这条边的经过次数怎么算呢？可以知道经过这条边的次数（即方案数）就是它所有的后继边（即以$v$为起点的边）的方案数之和。  

那么我们算出来经过每一条边的后继边的方案数，将这个方案数累加给它的前驱边即可 

令$pat[i]$表示从点$i$到终点$T$的方案数，$vis[i]$表示从点$i$到终点$T$的路径权值和，则有  
$$ pat[u]=\sum_v^{\exists (u,v)}pat[v] $$  
$$ vis[u]=\sum_v^{\exists (u,v)}(vis[v]+c[(u,v)] \times pat[v]) $$
其中, $\exists$ 表示存在，$c[(u,v)]$是$(u,v)$的边权。

$pat[i]$和$vis[i]$都可以在递归回溯的时候统计出来

# 代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define mod 10000
#define M 50005
#define N 10005

int n,m,S,T,t0;

inline int read() {
    int tmp=0,w=1;
    char ch=0;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') tmp=(tmp<<1)+(tmp<<3)+ch-'0',ch=getchar();
    return tmp*w;
}

int vis[M<<1];
struct node {
    int v,c,nex;
}e[M<<1];
int tot,h[N],out[N];
void add(int u,int v,int c) {
    e[++tot].v=v,e[tot].c=c,e[tot].nex=h[u],h[u]=tot;
    out[u]++;
}

int ans;
int pat[N];
bool mark[N];
void dfs1(int x) {
    int xx;
    for(int i=h[x];i;i=e[i].nex) {
        xx=e[i].v;
        if(!mark[xx]) mark[xx]=1,dfs1(xx);
        pat[x]=(pat[x]+pat[xx])%mod;
    }
}
int dfs(int x,int tim) {
    if(vis[x]) return vis[x]%mod;
    if(x==T) return 0;
    int xx;
    for(int i=h[x];i;i=e[i].nex) {
        xx=e[i].v;
		dfs(xx,e[i].c*pat[xx]%mod);
        vis[x]+=(e[i].c*pat[xx]%mod+vis[xx])%mod;
    }
    return vis[x]%mod;
}

int main()
{
    n=read(),m=read(),S=read(),T=read(),t0=read();
    int u,v,c;
    for(int i=1;i<=m;++i) u=read(),v=read(),c=read(),add(u,v,c);
    pat[T]=1;
    dfs1(S);
    ans=dfs(S,0);
    printf("%d\n",(vis[S]+t0*(pat[S]-1)%mod)%mod);
    return 0;
}
```

---

## 作者：沉辰 (赞：5)

解：
暴力：
爆搜所有的路线，40分


正解：加法原理+乘法原理


设sum[i]为从起点出发到达i的方案数

len[i]为为从起点出发到达i的路径总和

考虑一条边i -> j ，花费时间为t

那么则有:
len[j]=len[j]+len[i]+t*sum[i];

sum[j]=sum[j]+sum[i]

对于起点S:sum[S]=1;

注意题目中给的性质：
“输入保证这个图没有环，而且从西头到东头至少存在一条路线”

于是我们可以利用拓扑排序来进行这一工作，得到
sum[i]和len[i].

我们也可以建反向边，从T开始出发去找，进行DFS，
从而得到sum[i]和len[i]
[代码](http://www.cnblogs.com/adelalove/p/8494021.html)

---

## 作者：noall (赞：4)

我真是菜鸡，题读了半天才懂，代码敲出来调了1个多小时，结果是输入打错了。

My vegetable has exploded……

咳咳

#### 思路

这题我真的读了很久，一直没搞懂是啥意思……

我先来解释一下题意，

就是有一个**DAG**，有一个起点s和一个终点t。

这个人要从起点s走完所有可以到达终点t的方案，求出他所走过的每一条方案的边权和$tot_1$；而且，每当他走完一个方案来到终点$t$时，如果还有方案没走过，他就要花t0的时间重新回到起点s，要求出他从终点t回到起点s的时间和$tot_2$。答案$ans=tot_1+tot_2$。

理解了题意，可以想想怎么做了。

首先，他给出的图是一个**DAG**。

其次他还让我们求所有方案的和。

假设$count_i$为到$i$的次数。$dis_i$表示到点$i$的总路径长度。

很明显，我们可以用拓扑排序+递推的思想，根据起点$count_1=1$，推出$count_2,count_3...count_n$。

假设，点$i$的下一个点为$j$，那么$count_j$一定包含了$count_i$，画个图就知道了。

所以，如果当前点为$i$，那么$count_i$为所有到它的点的$count$之和。

相类似的，当前点$i$的$dis_i$即为到它的点的$dis$值和（$count_i \times $到$i$的所有边的权值）的总和。

好了，有点绕，看代码

#### code

```c++
#include<cstdio>
#include<queue>
using namespace std;

const int mod=10000;
const int maxn1=1e4+7;
const int maxn2=5e4+7;

struct edge{int to,next,w;}map[maxn2];

int n,m,s,t,t0,in[maxn1],count[maxn1],dis[maxn1];
int cnt,head[maxn1];
queue<int>q;

int read(){
	char ch=getchar();int f=1,r=0;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){r=r*10+ch-'0';ch=getchar();}
	return f*r;
}

void add(int x,int y,int w){
	map[++cnt].to=y;
	map[cnt].w=w;
	map[cnt].next=head[x];
	head[x]=cnt;
	in[y]++;
	return ;
}

void toposort(){
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=map[i].next){
			int y=map[i].to,w=map[i].w;
			(dis[y]+=dis[x]+count[x]*w)%=mod;
			(count[y]+=count[x])%=mod;
			if(!(--in[y])) q.push(y);
		}
	}
	return ;
}

int main(){
	n=read(),m=read(),s=read(),t=read(),t0=read();
	//for(int i=1;i<=m;i++) add(read(),read(),read());//调了一个小时
	int x,y,w;
    for(int i=1;i<=m;++i) x=read(),y=read(),w=read(),add(x,y,w);
	count[s]=1;
	toposort();
	printf("%d",(dis[t]+(count[t]-1)*t0)%mod);//当他最后一次游览时，就不需要回去了，所以-1。
	return 0;
} 
```

---

## 作者：yewanxingkong (赞：3)

# 核心算法：拓扑排序
解题思路：

看完题面可以想出要求出起点到终点的路径数量和经过这些路径所要花的时间，最后根据路径条数再加上乘坐船花的时间。

而一个点的这两个要求的东西可以从所有可以到达它的点得到，又因为后效性的缘故可以想到用拓扑。具体实现可以看代码以及注释。

小坑点：

题目并没有说可以从起点到所有点，也就是如果直接从起点或终点开始拓扑的话，其实有些点的入度一直无法归零，而这个点可能会对答案造成贡献。所以一开始要把那些对答案没有贡献的点拓扑掉。而好多题解并没有这样处理。

下面是代码：
```cpp
#include<iostream>
#include<cstdio> 
#include<cstring>
#define re register
using namespace std;
const int mod=10000;
int hd[100000],ji,ru[100000],quan[100000],cnt[100000];
int n,m,qi,zho,shi,dui[100000],head,tail=1;
struct nod{
	int xu,zhi,nxt;
}cun[100000];
inline void add(re int x,re int y,re int z){
	cun[++ji].xu=y;
	cun[ji].zhi=z;
	cun[ji].nxt=hd[x];
	hd[x]=ji;
}
inline int read(){
	re int date=0,W=1;re char ch=0;
	while(!isdigit(ch)){if(ch=='-')W=-1;ch=getchar();}
	while(isdigit(ch)){date=date*10+ch-'0';ch=getchar();}
	return date*W;
}
int main(){
	n=read();m=read();qi=read();zho=read();shi=read();
	for(re int i=1;i<=m;++i){
		re int x=read(),y=read(),z=read();
		add(x,y,z);ru[y]++;
	}
	for(re int i=1;i<=n;++i)
		if(!ru[i]&&i!=qi)dui[tail++]=i;
	while(head+1<tail){//处理掉那些对答案没有贡献的点 
		re int zh=dui[++head];
		for(re int i=hd[zh];i;i=cun[i].nxt){
			ru[cun[i].xu]--;
			if(!ru[cun[i].xu]&&cun[i].xu!=qi)dui[tail++]=cun[i].xu;
		}
	}
	cnt[qi]=1;head=0;tail=1;dui[tail++]=qi;
	while(head+1<tail){//开始拓扑 
		re int zh=dui[++head];
		for(re int i=hd[zh];i;i=cun[i].nxt){
			cnt[cun[i].xu]=(cnt[cun[i].xu]+cnt[zh])%mod;
			//通过这一条边到达指向的点的路径有到达起始这个点的路径数量条 
			quan[cun[i].xu]=(quan[cun[i].xu]+quan[zh]+cnt[zh]*cun[i].zhi)%mod;
			//经过这一条边的次数乘以这一条边的权值才是这条边对答案的贡献 
			ru[cun[i].xu]--;
			if(!ru[cun[i].xu])dui[tail++]=cun[i].xu;
		}
	}
	printf("%d",(quan[zho]+(cnt[zho]-1)*shi)%mod);
	//最后记得加上乘船花的时间 
	return 0;
}
```


---

## 作者：qinsishi (赞：3)

### 题意

求从起点到终点所有的路径长度，在此基础上再加上每次从终点回到起点的时间。

### 思路

说道路径条数，肯定首先想到 DP，求从起点到终点的路径条数，可以设：$f[i]$ 为从起点到节点 $i$ 的**路径条数**，$d[i]$ 为起点到节点 $i$ 的**路径长度和**。

当要从 $x$ 节点转移到 $y$ 节点时，要满足 $x$ 到 $y$ 有一条边，并且我们要进行**拓扑排序**，这样才可以保证转移的顺序是对的。

$f[y]=\sum f[x]$，其中 $x$ 是 $y$ 的父亲。

$d[y]=\sum d[x]+f[x]*dis(x,y)$，其中 $dis(x,y)$ 是 $x$ 到 $y$ 的边的距离。

### 细节

注意先求 $f[\;]$，再求 $d[\;]$；并且要注意**起点也是有可能有入度的**，那么要先将这些点拓扑掉；记着取模。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e4 + 5;
const int mod = 1e4;
int head[N];
int deg[N];
int f[N];
int d[N];
int n, m, s, t;
int tot, tim;

struct node {
	int to, next, dis;
}edge[N*5];

void add(int from, int to, int dis) {
	edge[++tot].to = to;
	edge[tot].dis = dis;
	edge[tot].next = head[from];
	head[from] = tot;
}

void topsort() {
	queue<int> que;
	for (int i=1; i<=n; i++) {
		if (deg[i] == 0) {
			que.push(i);
		}
	}
	while (que.size()) {
		int x = que.front();
		que.pop();
		if (x == s) {
			memset(d, 0, sizeof d);
			memset(f, 0, sizeof f);
			f[s] = 1;
		}
		for (int i=head[x]; i; i=edge[i].next) {
			int y = edge[i].to;
			int dis = edge[i].dis;
			f[y] = (f[y]+f[x])%mod;
			d[y] = (d[y]+d[x]+f[x]*dis)%mod;
			if (--deg[y] == 0) {
				que.push(y);
			}
		}
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> m >> s >> t >> tim;
	for (int i=1; i<=m; i++) {
		int x, y, z;
		cin >> x >> y >> z;
		add(x, y, z);
		deg[y]++;
	}
	topsort();
	cout << ((d[t]%mod)+tim*(f[t]-1)%mod)%mod << endl;
	return 0;
}
```


---

## 作者：Monomial (赞：2)

## 题目大意

给你一个 DAG（有向无环图），给你起点和终点，求所有从起点到终点的路径的时间之和，以及方案数减一乘上渡船时间，数据保证能从起点到达终点。

## 分析

首先考虑暴力 dfs，但通过分析，可以发现这是一种不可行的策略，因为搜索到某个点时，到它的所有路径不一定被搜完，如果直接搜下去会影响正确性，如果回溯重新搜索会浪费时间。

于是我们就要在搜索到一个点时使得它的入度为零，可以利用拓扑排序实现，同时利用一个类似动态规划加 bfs 的思路记录目前到达这个点的方案数和目前所有路径长度之和。

这道题的转移方程：

$$
dp[to][0]=\sum dp[from][0]
$$

$$
dp[to][1]=\sum dp[from][0] \times length + dp[from][1]
$$

其中 $to$ 表示东边的点，$from$ 表示西边的点，$dp[i][0]$ 表示到第 $i$ 个点的路径数量，$dp[i][1]$ 表示目前到第 $i$ 个点的路径长度总和。

同时，这道题的边最好使用类似链式前向星的思路实现。

代码（比较长，看不懂请留言）：

```cpp
struct edge {
    int from,to,length;
    int lst,nxt;
};

edge led[50005]={};

int dis[20005][2]={},ed[20005][2]={},cnt[20005]={};

void wk() {
    memset(ed,-1,sizeof ed);
    int n,m,st,edt,tm;
    read(n),read(m),read(st),read(edt),read(tm);
    dis[st][0]=1;
    for(int i=1;i<=m;++i) {
        int fr,to,val;
        read(fr),read(to),read(val);
        led[i].from=fr;
        led[i].to=to;
        led[i].length=val;
        led[i].lst=ed[fr][1];
        led[i].nxt=-1;
        cnt[to]++;
        if(ed[fr][0]==-1) ed[fr][0]=ed[fr][1]=i;
        else {
            led[ed[fr][1]].nxt=i;
            ed[fr][1]=i;
        }
    }
    deque<int> que;
    for(int i=1;i<=n;++i) {
        if(!cnt[i]) {
            que.push_back(i);
        }
    }
    while(!que.empty()) {
        int node=que.front();
        que.pop_front();
        for(int i=ed[node][0];i!=-1;i=led[i].nxt) {
            (dis[led[i].to][0]+=dis[node][0])%=10000;
            (dis[led[i].to][1]+=dis[node][0]*led[i].length+dis[node][1])%=10000;
            if(!(--cnt[led[i].to])) {
                que.push_back(led[i].to);
            }
        }
    }
    write((1ll*dis[edt][1]+1ll*(dis[edt][0]-1)*tm)%10000);
}
```

---

## 作者：HHYQ_07 (赞：2)

# 题解

## 思路

看到有权有向图，想到拓扑排序。题目中询问的是最后的总时间，计算方法为：$\sum _{i=1}^{num} t_i+t_0*(num-1)$，其中 $num$ 为从岛西头到达岛东头的路径数量，$t_i$ 为每一条从岛西头到达岛东头路径上的总时间，因为最后一次不需要返回，所以只用乘 $num-1$ 次船。有了思想后，实现的过程就是用拓扑排序去更新这两个值。

## 细节

1. 更新时间不仅要加上前驱的时间 $tim[x]$，还要加上走这一条边的用时 $t$ 乘上到达前驱的路径总数量 $cnt[x]$。注意不是只加一个 $t$，请读者自己想原因。
2. 建议使用[链式前向星](https://oi.wiki/graph/save/)存图。

## AC code

```cpp

#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e4+5,mod=1e4;
int n,m,s,l,t,head[N],tot,p[N],cnt[N],tim[N];
struct node
{
	int next,to,dis;
}edge[5*N];
void add(int from,int to,int dis)
{
	tot++;
	edge[tot].to=to,edge[tot].dis=dis;
	edge[tot].next=head[from];
	head[from]=tot;
}
queue<int>q;
signed main()
{
	cin>>n>>m>>s>>l>>t;
	while(m--)
	{
		int x,y,d;
		cin>>x>>y>>d;
		add(x,y,d);
		p[y]++;
	}
	for(int i=1;i<=n;i++)
		if(p[i]==0)
		{
			q.push(i);
			cnt[i]=1;
		}
	while(q.size())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=edge[i].next)
		{
			int y=edge[i].to;
			p[y]--;
			tim[y]=(tim[y]+tim[x]+edge[i].dis*cnt[x])%mod;
			cnt[y]=(cnt[y]+cnt[x])%mod;
			if(p[y]==0)q.push(y);
		}
	}
	cout<<(tim[l]+(t*(cnt[l]-1))%mod)%mod;
	return 0;
}

```

---

## 作者：AlicX (赞：1)

### 前言

首先我们了解一下题意：给你一个 $n$个点，$m$ 条边的有向图，再你给一个起点 $s$，终点 $t$，以及它们之间的距离，问你这个图中从起点 $s$ 到终点 $t$ 的所有路径之和，并对 $10^4$ 取模。

注意：每一个路径到达终点后，需要通过它到起点的距离再次回到起点进行下一次遍历。

## 具体思路
1. 首先考虑暴力：对于此题，暴力的做法就是挨个去试每一条路径，并记录下来这条路径上所有点的和，如果这条路径可以到达终点，就用计数变量加上这条路径上的和。但是我们观察到 $n \leq 10^4$ 且 $m \leq 5 \times 10^4$，这个做法的时间复杂度显然通过不了。

2. 再考虑正解：想一个问题：暴力为什么会超时？因为我们是每一路径都去遍历了一遍，但是有些路径会被重复遍历，这就是导致我们超时的原因。那么怎么解决呢？当然是预处理。我们预处理出每一个点会被几个路径包含，那么从起点到这个点的每条路径之和显然也可以一起算出来，只需要将可以到达这个点的所有点的路径之和的总和加上这些点到当前点的路径就可以啦。建议带着样例模拟一下。

3. 那我们怎么保证现有的点的状态就是确定的呢？考虑一个事实：当这个点再也不会被更新之后它就已经确定了，而更新的条件则是有点能到达它，这个条件显然可以用拓扑图维护。所以我们确定了我们的算法：拓扑图上跑 $dp$。

4. 最后在考虑每次路径走完后都要回到起点的和，这个非常好算，只需要求出总路径的个数，再用总路径的个数减一乘从终点回到起点的路程就完了。输出时注意取模。

## AC code
```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=1e4+10,mod=10000;
int n,m;
int d[N];//记录每个点的入度 
int s,t,p;
int cnt[N];//记录每个点可以被多少个点到达 
int ans[N];//记录从起点到这个点的所有路径的和 
int h[N],idx=0;
struct Node{
	int w;
	int to,ne;
}tr[N];
void add(int u,int v,int w){
	tr[idx].w=w,tr[idx].to=v,tr[idx].ne=h[u],h[u]=idx++;//建单向图 
}
void top(){
	queue<int> q;
	q.push(s);//将起点放入队列 
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=h[u];i!=-1;i=tr[i].ne){
			int to=tr[i].to;
			cnt[to]+=cnt[u],ans[to]=(ans[to]+ans[u]+cnt[u]*tr[i].w)%mod;
			//这个点可以被到达u的所有点到达，它的路径和要加等于u的路径和并加上这些点到当前点的总和 
			if(!(--d[to])) q.push(to);//如果这个点的入读为0，说明它不会再被更新了，于是放入队列。 
		}
	}
} 
signed main(){
	memset(h,-1,sizeof h);
	cin>>n>>m;
	cin>>s>>t>>p;
	while(m--){
		int u,v,w;
		cin>>u>>v>>w;
		d[v]++,add(u,v,w);//建图操作 
	}
	cnt[s]=1,top();//将起点的到达数设为1，进行拓扑排序 
	cout<<(ans[t]+(cnt[t]-1)*p)%mod<<endl;//输出从起点到终点的所有路径和加上路径数减一乘起点到终点的路程 
	return 0;//
}
```

---

## 作者：ArrogHie (赞：1)

## 题意概括
求所有不同路径的路径长度的和 $+$ ( 不同路径数 $- 1$ ) $*$ $t0$


------------

## 思路
我们计算每条边 $(u,v)$ 对答案的贡献，则为起点 $s$ 到 $u$ 的路径数 $*$ $v$ 到终点 $t$ 的路径数 $*$ 边的权值

接下来就是如何计算对于每个节点 $u$ ，起点到他的路径数和他到终点的路径数

对于 $u$ 到终点的路径数，相当于在反图上终点到 $u$ 的路径数，所以我们只需要用同一种算法，分别处理在原图上起点到每个节点的路径数和在反图上终点到每个节点的路径数就好了

对于每个节点 $u$ ，如何计算从终点到其的路径数，对于一条边 $(z,u)$ ，若从起点到 $z$ 节点的路径数为 $dins[z]$ ，因为所有能到达 $z$ 的路径都能到达 $u$ ，所以我们让 $dins[u]$ 加上 $dins[z]$ 。所以我们只需要将所有类似于 $(z,u)$ 的边，将 $dins[u]$ 加上 $dins[z]$ ，就可求出起点到$u$的路径数

因为后效性的缘由，我们需要把所有能到达$u$的节点$z$的路径数全加在 $u$ 上才能计算 $u$ 能到达的节点的路径数，因为该图是 $DAG$ ，所以我们便可以用拓扑排序来解决

对于从终点到起点的次数，第一次到达终点后的每一次到达终点，都需要先从终点到达起点，所以次数是 $($ 不同路径数 $-1)$

时间复杂度~~大概是~~ $O(N+M)$ 

## Code
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 100010;
const int mod = 10000;

int n, m, t0;
int dins[N], douts[N], din[N], dout[N];
int h[N], h1[N], num[N << 1], nex[N << 1], dqx;

struct Edge
{
	int a, b, c;
	Edge() {}
	Edge(int a, int b, int c) :a(a), b(b), c(c) {}
}edge[N];

inline void add(int a, int b, int h[])
{
	num[dqx] = b;
	nex[dqx] = h[a];
	h[a] = dqx++;
}

inline void topsort(int sta, int ed, int h[], int dis[],int din[])
{
	for (int u = 1; u <= n; u++)
	{
		if (din[u] == 0 && u != sta)
		{
			for (int i = h[u]; ~i; i = nex[i])
			{
				int j = num[i];
				din[j]--;
			}
		}
	}

	queue<int> que;
	que.push(sta);
	dis[sta] = 1;

	int ans = 0;
	while (que.size())
	{
		int u = que.front();
		que.pop();

		for (int i = h[u]; ~i; i = nex[i])
		{
			int j = num[i];
			dis[j] = (dis[j] + dis[u]) % mod;
			if (--din[j] == 0) que.push(j);
		}
	}
}

int main()
{
	int sta, ed;
	scanf("%d%d%d%d%d", &n, &m, &sta, &ed, &t0);

	memset(h, -1, sizeof(h));
	memset(h1, -1, sizeof(h1));
	for (int i = 1; i <= m; i++)
	{
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c);
		edge[i] = Edge(a, b, c);
		add(a, b, h), add(b, a, h1);
		din[b]++, dout[a]++;
	}

	topsort(sta, ed, h, dins, din);
	topsort(ed, sta, h1, douts, dout);

	int ans = 0;
	for (int i = 1; i <= m; i++)
	{
		Edge e = edge[i];
		int a = e.a, b = e.b, c = e.c;
		ans = (ans + 1ll * dins[a] * douts[b] % mod * c % mod) % mod;
	}
	if (dins[ed]) ans = (ans + 1ll * (dins[ed] - 1) * t0 % mod) % mod;
	printf("%d", ans);
}
```



---

## 作者：LlLlCc (赞：1)

题目大意就是求两个值$tot_1,tot_2$的和

$tot_1:$为从起点$S$到终点$T$的所有路径的耗时和

$tot_2:$为每次从终点$T$回到起点$S$的耗时和

因为终点回到起点的时间是固定的，所以我们只要知道有几条从起点到终点的路径

不妨设：

$\large f_x:$ 起点到点$x$的路径数

$\large G_x:$ 终点到点$x$的路径数

不过这要怎么求呢？

根据题意得，这是个拓扑图，也就是说不存在环，点之间存在相对顺序

然后就用拓扑正反刷两趟即可

得出$f_x$和$G_x$后，我们就求出了$tot_2$，即

$$\Large tot_2=t_0\times f_T(G_1)$$

再考虑$tot_1$

对于一条边$x\rightarrow y$，我们需要求出有多少路径经过

根据乘法原理，经过次数$\large Cnt=f_x\times G_y$

所以这条边对答案的贡献即为（$w$为边权）：

$$\Large f_x\times G_y\times w$$

对每条边都这么统计一次答案就出来了

## code:

```
#include<bits/stdc++.h>
#define maxn 200005
#define maxe 1000005
using namespace std;
const int TT=10000;
int n,Ans,m,lnk[maxn],S,T,t,nxt[maxe],son[maxe],w[maxe],tot,T_in[maxn],G[maxn][2],x[maxe],y[maxe],z[maxe],Q[maxn],hed,til;
bool vis[maxn];
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
inline void add(int x,int y,int z){if (x==y) return;nxt[++tot]=lnk[x];lnk[x]=tot;son[tot]=y;w[tot]=z;}
int main(){
	n=read(),m=read(),S=read(),T=read(),t=read();
	for (int i=1;i<=m;i++) T_in[x[i]=read()]++,y[i]=read(),z[i]=read(),add(y[i],x[i],z[i]);
	for (int i=1;i<=n;i++) if (!T_in[i]) Q[++til]=i,vis[i]=G[i][0]=1;
	while (hed<til){
		hed++;int Now=Q[hed];
		for (int i=lnk[Now];i;i=nxt[i]){
			if (vis[son[i]]) continue;
			if (!--T_in[son[i]]) Q[++til]=son[i],vis[son[i]]=1;
			G[son[i]][0]=(G[son[i]][0]+G[Now][0])%TT;
		}
	}
	memset(vis,0,sizeof vis);
	memset(lnk,0,sizeof lnk);
	memset(T_in,0,sizeof T_in);
	hed=tot=til=0;
	for (int i=1;i<=m;i++) T_in[y[i]]++,add(x[i],y[i],z[i]);
	for (int i=1;i<=n;i++) if (!T_in[i]) Q[++til]=i,vis[i]=G[i][1]=1;
	while (hed<til){
		hed++;int Now=Q[hed];
		for (int i=lnk[Now];i;i=nxt[i]){
			if (vis[son[i]]) continue;
			if (!--T_in[son[i]]) Q[++til]=son[i],vis[son[i]]=1;
			G[son[i]][1]=(G[son[i]][1]+G[Now][1])%TT;
		    Ans=(Ans+G[Now][1]*G[son[i]][0]%TT*w[i]%TT)%TT;
		}
	}
	printf("%d",(Ans+(G[S][0]-1)*t%TT)%TT);
	return 0;
}
```



---

## 作者：Grace_White (赞：1)

## 题解 P1685 【游览】
【题目简述】

    问所有不同的路线游览完一共要花多少时间
【解题算法】

    拓扑排序+链式向前星存储
【解题思路】

    运用拓扑排序的方法，把每个点的入度求出来，然后做一遍拓扑排序，其中多了两个参数，分别为到这个点所有路径的总时间和路径数。但这样做会超时，因为它n有10000，所以用原来的拓扑排序肯定会超时，所以就用链式向前星存储。

【提示】

![](https://cdn.luogu.com.cn/upload/image_hosting/de646kud.png)

 
    这是我的错误样例，因为在3-4这条路上，5需要加两遍，因为到点3有两种方法能走到，我只算了一次（chinaxjh可能也是这个错误）
    
   ~~本蒟蒻图画的太丑，请巨佬们不要介意~~

【AC代码】
```pascal
var n,m,t1,w1,k,x,y,z,cnt,i,t,w:longint;flag:boolean;k1:int64;
a,b,c,d,f1,f2,f:array[0..100000] of int64;
procedure add(x,y,z:longint);
begin inc(cnt);a[cnt]:=y;b[cnt]:=d[x];c[cnt]:=z;d[x]:=cnt;end;
begin
readln(n,m,t1,w1,k1);
fillchar(f,sizeof(f),255);//因为有些点不会做到，所以先赋-1
for i:=1 to m do
  begin
  readln(x,y,z);
  add(x,y,z);//链表的存储方法
  if f[y]=-1 then f[y]:=1
  else inc(f[y]);//计算入度
  end;
f[t1]:=0;//开始的人入度肯定为0
f2[t1]:=1;
while flag=false do//如果入度为0的没了，就不用做了
  begin
  flag:=true;
  for i:=1 to n do
    if (f[i]=0) then//入度为0
      begin
      f[i]:=-1;//这个点已经做过了
      k:=d[i];
      flag:=false;//表示有入度为0的
      while k>0 do
        begin
        dec(f[a[k]]);
        f1[a[k]]:=(f1[a[k]]+f1[i]+c[k]*f2[i]) mod 10000;//更新总时间
        f2[a[k]]:=(f2[a[k]]+f2[i]) mod 10000;//更新方案数
        k:=b[k];
        end;
      end;
  end;
writeln((f1[w1]+(f2[w1]-1)*k1) mod 10000);//最后一次去不用回来，所以要减一
end.
```


---

## 作者：wuzhaoxin (赞：1)

# 拓扑排序+递推
首先看一遍题面，发现一句话：
> 输入保证这个图没有环，而且从西头到东头至少存在一条路线

我们可以想到这题可能是拓扑排序

假设 $cnt[i]$ 为从 i 到 t 的路径条数 $dp[i]$ 为从 i 到 t 的所有路径的耗时和，那么转移很简单:

$dp[u] = \sum\ (dp[v]+val[i]\times cnt[v])$

$cnt[u] = \sum\ cnt[v]$ 

（ $val[i]$ 为边的权值）

于是我们可以直接反向建边然后拓扑排序递推出结果，答案为：

$dp[s] + (cnt[s] - 1)\times t0$

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gi() {
	register int x,op=1,c;
	while(c=getchar(),c<'0'||c>'9')if(c=='-')op=-op;
	x=c^48;
	while(c=getchar(),c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48);
	return x*op;
}
int head[100001]={0},nxt[1000001],ver[1000001],val[1000001],tot=0;
int dg[100001]={0};
void add(int x,int y,int z) {
	ver[++tot]=y,nxt[tot]=head[x],val[tot]=z,head[x]=tot;dg[y]++;
}
int n,m,s,t;
int dp[100001]={0},cnt[100001]={0};
queue<int>q;
#define mod 10000
void topo() {
	q.push(t);
	cnt[t]=1;
	int x;
	while(!q.empty()) {
		x=q.front(),q.pop();
		for(int i=head[x];i;i=nxt[i])
			cnt[ver[i]]+=cnt[x],cnt[ver[i]]%=mod,dp[ver[i]]+=dp[x]+cnt[x]*val[i],dp[ver[i]]%=mod;
		for(int i=head[x];i;i=nxt[i])
			if(!(--dg[ver[i]]))q.push(ver[i]);
	}
}
int main() {
	n=gi(),m=gi();
	s=gi(),t=gi();
	int t0=gi();
	for(int i=1,x,y;i<=m;i++)
		x=gi(),y=gi(),add(y,x,gi());
	topo();
	printf("%d\n",(dp[s]+(cnt[s]-1)*t0%mod)%mod);
	return 0;
}
```

---

## 作者：Haphyxlos (赞：1)

# P1685 【游览】
[题目传送门](https://www.luogu.com.cn/problem/P1685)

因为本人太蒻了，调了30分钟，还是挂了，~~于是在学习完题解后~~，重写这道题。

因为该题给出的图是**DAG（有向无环图）**，其实这题本质上就是一道拓扑排序了。

我们记一个cnt数组来存储到点i的次数，in数组来存储各个点的入度，dis数组来存储到点i的总长度，e数组链式前向星存边。

推一下式子可得：

$ dis[v]=dis[v]+dis[u]+cnt[u]×e[i].w $

$ cnt[v]+=cnt[u] $

$ ans=dis[t]+(cnt[t]-1)×t_0 $

ACcode如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e4;
const double eps=1e-8;
const int INF=0x3f3f3f3f;
const int maxn=1e5+5;
const int maxm=1e6+5;
struct node{
	int u,v,w;
}e[maxn];
int n,m,s,t,t0,pos,in[maxn],head[maxn],dis[maxn],cnt[maxn];
inline void add(int u,int v,int w){
	e[++pos].u=head[u],e[pos].v=v,e[pos].w=w,head[u]=pos;
	//链式前向星存边 
}
inline void dfs(int u){
	for(int i=head[u];i;i=e[i].u){
		int v=e[i].v;
		dis[v]=(dis[v]+dis[u]+cnt[u]*e[i].w)%mod,cnt[v]=(cnt[v]+cnt[u])%mod,in[v]--;
		if(!in[v])dfs(v);
		//如果当前入度不为0，则继续更新 
	}
}
inline int read();
int main(int argc, char const *argv[]){
//	std::ios::sync_with_stdio(false);
	n=read(),m=read(),s=read(),t=read(),t0=read(),cnt[s]=1;
	for(int i=1,u,v,w;i<=m;++i){
		u=read(),v=read(),w=read(),in[v]++;
		add(u,v,w); 
	}
	dfs(s);
	cnt[t]--;
	//最后一次游览时不需要回去了 
	printf("%d",(dis[t]+cnt[t]*t0)%mod);
	return 0;
}
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x*f;
}
```

本篇题解就到此结束了，如果喜欢，还请点个赞吧。

---

## 作者：lovely_hyzhuo (赞：0)

本来看到题目是蒙的~~偷偷瞅了一眼标签：图论，瞬间就会了~~。

由于这道题标签是图论，还要求计数，说明什么？这是拓扑排序。


dp 方程：

$f_y=\sum f_x$，满足 $x$ 与 $y$ 直接相连。理由：走到一个节点的所有方案数为与它有连边的所有点的方案数之和。

$d_y=\sum d_x + f_x\times dis(x,y)$，其中 $x$ 与 $y$ 的距离为 $dis(x,y)$。

代码

```cpp
#include<bits/stdc++.h>
#define ovo 0
#define qwq int
#define QAQ void
using namespace std;
const qwq momo=1e4;
qwq n,m,s,t,tme;
qwq dep[1000010];
qwq head[1000010];
qwq f[100010];
qwq d[1000010];
struct node 
{
	qwq to,next,dis;
}edge[3000010];
qwq tot;
QAQ add(qwq from,qwq to,qwq dis) 
{
	edge[++tot].to=to;
	edge[tot].dis=dis;
	edge[tot].next=head[from];
	head[from]=tot;
}
QAQ top()
{
	queue<qwq>q;
	for(qwq i=1;i<=n;i++)
		if(!dep[i])
			q.push(i);
	while(!q.empty())
	{
		qwq u=q.front();;
		q.pop();
		if(u==s)
		{
			memset(d,0,sizeof(d));
			memset(f,0,sizeof(f));
			f[s]=1;
		}
		for(qwq i=head[u];i;i=edge[i].next)
		{
			qwq v=edge[i].to;
			f[v]=(f[v]+f[u])%momo;
			d[v]=(d[v]+d[u]+f[u]*edge[i].dis)%momo;
			if(--dep[v]==0)
				q.push(v);
		}
	}
}
qwq main()
{
	cin>>n>>m>>s>>t>>tme;
	for(qwq i=1;i<=m;i++)
	{
		qwq x,y,tt;
		cin>>x>>y>>tt;
		add(x,y,tt);
		dep[y]++;
	}
	top();
	cout<<((d[t]%momo)+tme*(f[t]-1)%momo)%momo;
	return ovo;
}
```


---

## 作者：Genius_Star (赞：0)

### 题目解析：

本题是一道经典的拓扑排序题目，题目要求我们求出从西头到东头的所有不同的路线游览完的时间总和，而且规定所有的路线不能完全相同。

我们可以将问题转化成从西头到东头，每次不能走之前走过的路径，求出最短路程。

由于题目保证没有环，我们可以使用拓扑排序算法求出从西头到东头的一个拓扑序列。

再根据拓扑序列从西头开始遍历每个节点，不断更新从西头到每个节点的最短路程。

具体来说，我们可以定义一个数组 $dist$，其中 $dist[i]$ 表示从西头到点 $i$ 的最短路程。在拓扑排序过程中，我们从西头开始访问每个节点 $u$，遍历 $u$ 的所有出边 $(u,v)$，如果更新 $v$ 的最短路程 $dist[v]$ 可以使得 $dist[v]$ 更小，则更新 $dist[v]$。由于题目保证没有环，每个节点只会被遍历一次，因此时间复杂度为 $\mathcal{O}(n+m)$。

最后，我们的目标是求出从西头到东头的所有不同的路线游览完的时间总和。我们可以使用类似于背包问题的思想，对于每个节点 $i$，我们维护一个 $dp$ 数组，其中 $dp[j]$ 表示从西头到点 $i$，经过了 $j$ 条边的所有不同的路线游览完的时间总和。

初始时 $dp[0]=0$，遍历 $i$ 的所有入边 $(u,i)$，对于每个 $j$，如果 $j>0$，我们可以从 $dp[j-1]$ 转移而来，增加 $t_0$ 的时间消耗。由于题目要求所有的路线不能完全相同，因此当 $(u,i)$ 是第一条入边时，我们无法从 $dp[j]$ 转移而来，只能从 $dp[j-1]$ 转移而来。

更新完 $dp$ 数组后，我们将 $dp$ 数组中的所有元素累加起来，即可得到从西头到东头的所有不同的路线游览完的时间总和。

时间复杂度为 $\mathcal{O}(n+m)$。


### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100100,mod=10000;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
         f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int n,m,s,t,t0,z[N],top;
int h[N],ans,a[N],dp[N],G[N];
struct Node{
	int u,v,w;
}E[N<<2];
inline void add(int x,int y,int z){
	E[++ans].u=h[x];
	E[ans].v=y;
	E[ans].w=z;
	h[x]=ans;
}
inline void Tsort(){
	for(int i=1;i<=n;i++)
	  if(!a[i])
		z[++top]=i,G[i]=1;
	while(top){
		int u=z[top--];
		for(int i=h[u];i;i=E[i].u){
			a[E[i].v]--;
			(dp[E[i].v]+=dp[u]+G[u]*E[i].w)%=mod;
			(G[E[i].v]+=G[u])%=mod;
			if(!a[E[i].v])
			  z[++top]=E[i].v;
		}
	}
}
int main(){
	n=read(),m=read(),s=read(),t=read(),t0=read();
	for(int i=1,x,y,z;i<=m;i++){
		x=read(),y=read(),z=read();
		if(x==y)
		  continue;
		add(x,y,z);
		a[y]++;
	}
	Tsort();
	write((dp[t]%mod+(G[t]-1)*t0)%mod);
	return 0;
}
```

大家可以自己推一下，不要抄哦~


---

## 作者：happybob (赞：0)

## 题意

给定一张带权有向无环图和起点、终点和数 $t0$，设从起点到终点不经过重复的边的不同的路径数量为 $c$，每条路径的权值总和为 $w$，求 $\sum \limits w + (c - 1) \times t0$ 对 $10000$ 取余的结果。可能有重边。

## 解法

给定的是 DAG，所以可以考虑 DP。

设 $cnt_i$ 表示起点到 $i$ 的路径数量，$dis_i$ 表示起点到 $i$ 的全部路径和。那么有状态转移方程：$cnt_i = \sum \limits_{(u,i) \in E} cnt_u$，即所有入边的点的 $cnt$ 之和。$dis_i = \sum \limits_{(u, i) \in E} dis_u + cnt_u \cdot w$，$w$ 为该边边权。

但是直接树上 DFS 答案是错的，应该有些点的状态还没有更新完就用这个状态更新其他节点了。所以考虑按照类似拓扑排序的思想，只有一个点入度为 $0$ 时才用它更新其他点，复杂度 $O(n+m)$。

---


# [NOIP 2013 普及组] 车站分级

## 题目背景

NOIP2013 普及组 T4

## 题目描述

一条单向的铁路线上，依次有编号为 $1, 2, …, n$ 的 $n $ 个火车站。每个火车站都有一个级别，最低为 $1$ 级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站 $x$，则始发站、终点站之间所有级别大于等于火车站 $x$ 的都必须停靠。  
注意：起始站和终点站自然也算作事先已知需要停靠的站点。

例如，下表是 $ 5 $ 趟车次的运行情况。其中，前 $ 4$ 趟车次均满足要求，而第 $5$ 趟车次由于停靠了 $3$ 号火车站（$2$ 级）却未停靠途经的 $6$ 号火车站（亦为 $2$ 级）而不满足要求。



 ![](https://cdn.luogu.com.cn/upload/pic/1238.png) 

现有 $m$ 趟车次的运行情况（全部满足要求），试推算这 $ n$ 个火车站至少分为几个不同的级别。


## 说明/提示

对于 $ 20\%$ 的数据，$1 ≤ n, m ≤ 10$；

对于 $50\%$ 的数据，$1 ≤ n, m ≤ 100$；

对于 $100\%$ 的数据，$1 ≤ n, m ≤ 1000$。


## 样例 #1

### 输入

```
9 2 
4 1 3 5 6 
3 3 5 6 ```

### 输出

```
2```

## 样例 #2

### 输入

```
9 3 
4 1 3 5 6 
3 3 5 6 
3 1 5 9 ```

### 输出

```
3```

# 题解

## 作者：SCUT_HYX (赞：465)

**更好的阅读体验：[黄毛猫_HYX的博客](https://www.luogu.org/blog/jerriehmm/solution-p1983)**

~~推销下我的空间~~：[蒟蒻](https://www.luogu.org/blog/jerriehmm/)

## 拓扑思想

##### ~~先读读题~~(没读题的请回

因为火车都要停靠比它高级（大于等于）的车站，所以其它不停的就是比它级别小（小于）的车站，现在求最高等级的车站是几级。

在所有不停的站的级别小于停靠的站的情况下，我们可以做出一张图（A指向B表示A车站级别大于B车站）[用的是样例1] ~~多了7-9号点太丑了所以就去掉了~~

![如图所示](https://cdn.luogu.com.cn/upload/pic/56401.png)

最后利用拓扑的思想，一层一层的删点删线，统计下分了多少层，答案就出来了QWQ

#### 什么是拓扑：拓扑排序是对有向无回路图进行排序，以期找到一个线性序列，这个线性序列在生活正可以表示某些事情完成的相应顺序。如果说所求的图有回路的话，则不可能找到这个序列。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ZYS 1005
using namespace std;
int n,m,ans,st[ZYS],s,tuopu[ZYS][ZYS],de[ZYS],tt[ZYS],top;
bool is[ZYS],bo[ZYS];			//用andyzys大佬的名字做数组范围
int main() {
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++) {
        memset(is,0,sizeof(is));//is表示是否是停靠站
        scanf("%d",&s);
        for(int j=1;j<=s;j++)
            scanf("%d",&st[j]),is[st[j]]=true;
        for(int j=st[1];j<=st[s];j++)
            if(!is[j])			//枚举站点，若不是已停靠的就小于所有停靠站的等级
                for(int k=1;k<=s;k++)	//枚举已停靠站点
                    if(!tuopu[j][st[k]]) tuopu[j][st[k]]=1,de[st[k]]++;//tuopu[i][j]表示j>i的级别，如上
    }
    
    do{
        top=0;
        for(int i=1;i<=n;i++)
            if(de[i]==0&&!bo[i]) {
                tt[++top]=i,bo[i]=true;//开始将出度为0的点删掉
            }
        for(int i=1;i<=top;i++)
            for(int j=1;j<=n;j++)
                if(tuopu[tt[i]][j]) tuopu[tt[i]][j]=0,de[j]--;//去边去点
        ans++;
    } while(top);
    printf("%d",ans-1);//最后一次什么点都没有会多算一次（自行理解）
    return 0;
}
```
## 萌新第一篇题解，不喜勿喷小窗私聊


---

## 作者：_•́へ•́╬_ (赞：177)

# 暴力大法好
下面给出我各个变量的解释
- $a[i]\text{表示第}i\text{个车站的分级}$
- $s[i]\text{表示第i}\text{趟车次经过的站数}$
- $f[i][j]\text{表示第}i\text{趟车次停靠的第}j\text{个车站}$
- $have[i][j]\text{表示第}i\text{趟车次是否经过第}j\text{个车站}$

```cpp
#include<bits/stdc++.h>//懒人专用头文件
#define max(x,y) ((x)>(y)?(x):(y))
#define rpt(n) for(register int ttxyc=0;ttxyc<(n);++ttxyc)//宏定义
using namespace std;
inline int read()//快读
{
	register int x=0,t=0;register char c=getchar();for(;c<'0'||c>'9';t|=c=='-',c=getchar());
	for(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=getchar());return t?-x:x;
}
int n,m,a[1000],f[1000][1000],s[1000];bool have[1000][1000];
main()
{
	n=read();m=read();
	rpt(n)α[ttxyc]=1;
	rpt(m)
	{
		s[ttxyc]=read();
		for(register int i=0;i<s[ttxyc];++i)f[ttxyc][i]=read()-1,have[ttxyc][f[ttxyc][i]]=1;
	}
    //以上均为输入
	for(;;)//屎循环
	{
		bool cd=0;//是否更改
		rpt(m)
		{
			int maxn=0;
			for(register int i=f[ttxyc][0];i<=f[ttxyc][s[ttxyc]-1];++i)
				if(!have[ttxyc][i])maxn=max(maxn,α[i]);//不停靠的取最大值
			++maxn;//停靠的比不停靠的至少多一
			for(register int i=0;i<s[ttxyc];++i)
				if(α[f[ttxyc][i]]<maxn)α[f[ttxyc][i]]=maxn,cd=1;//有的分级不符合要求，更改
		}
		if(!cd)break;//没更新的就说明已经是最优解
	}
	int maxn=0;
	rpt(n)maxn=max(maxn,α[ttxyc]);
	printf("%d",maxn);
}/**/
```

---

## 作者：Sakura___ (赞：39)

Accepted

100  168ms /  7.77MB

代码：1.82KB C++

大概是全洛谷最快的了

拓扑排序 + 虚点优化 + 线段树优化连边

边数 mlogn

原来是所有没有停靠的点向停靠的点连边

现在改为所有没有停靠的点向虚点连 虚点向停靠的点连边

然后线段树优化

观察到停靠的点把区间分成了许多段 将整个序列用线段树表示

每一段由不超过logn个线段树节点表示 所以可以降边数

细节比较多 看代码

‘’‘c++










```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1500;
int head[N << 3], top, n, m, tp, stp[N], in[N << 3], arc[N];
bool nd[N << 3];
struct Node
{
    int y, nxt;
    Node() {    }
    Node( int y, int nxt ) : y(y), nxt(nxt) {    }
} e[N * 700];
void Adde( int x, int y )
{
//    printf( "x %d  y %d\n", x, y );
    in[y]++;
    e[++top] = Node(y, head[x]), head[x] = top;
}
#define ls (bt << 1)
#define rs (bt << 1 | 1)
void Build( int bt, int lf, int rg )
{
    tp = max(tp, bt);
    if(lf == rg)
    {
        arc[lf] = bt;
        nd[bt] = 1;
        return;
    }
    int mid = (lf + rg) >> 1;
    Adde(ls, bt);
    Build(ls, lf, mid);
    Adde(rs, bt);
    Build(rs, mid + 1, rg);
}
void Query( int bt, int lf, int rg, int L, int R, int tmp )
{
    if(L > R) return;
    if(L <= lf && rg <= R)
    {
        Adde(bt, tmp);
        return;
    }
    int mid = (lf + rg) >> 1;
    if(L <= mid) Query(ls, lf, mid, L, R, tmp);
    if(R > mid) Query(rs, mid + 1, rg, L, R, tmp);
}
int que[N << 5], h, t, dep[N << 3];
void Bfs()
{
    for(int i = 1; i <= tp; ++i)
        if(!in[i]) que[++t] = i, dep[i] = nd[i];
    while(h < t)
    {
        int u = que[++h];
        for(int i = head[u]; i; i = e[i].nxt)
        {
            int v = e[i].y;
            in[v]--;
            dep[v] = max(dep[u] + nd[v], dep[v]);
            if(in[v] == 0) que[++t] = v;
        }
    }
}
int main()
{
    cin >> n >> m;
    Build(1, 1, n);
    for(int i = 1, cnt; i <= m; ++i)
    {
        scanf( "%d", &cnt );
        ++tp;
        for(int j = 1; j <= cnt; ++j)
            scanf( "%d", &stp[j] );
        for(int j = 1; j < cnt; ++j)
        {
            Adde(tp, arc[stp[j]]);
            Query(1, 1, n, stp[j] + 1, stp[j + 1] - 1, tp);
        }
        Adde(tp, arc[stp[cnt]]);
    }
    Bfs();
    int ans = 0;
    for(int i = 1; i <= n; ++i)
        ans = max(ans, dep[arc[i]]);
    cout << ans << endl;
    return 0;
} 
'''
```

---

## 作者：引领天下 (赞：30)

我来这里发题解只是为了证明：某种被认为是**非正解**的算法，其实是可以AC的！

先看：https://www.luogu.org/blog/user56917/solution-p1983

其实，我并没有改动多少，只是进行了几个很常用的优化：

1. 避免重复定义变量

  在原来的代码中，有一段是这样的：
  
  ```cpp
  for(register int iii=1;iii<=m;iii++){
        int cnt=get();
  ```
  
  在这一段中，`cnt`被反复定义了$ m $次，导致了时间的浪费，因为这明明是一个可以一次解决的问题。
  
2. 少写头文件

  你写的头文件中的函数每调用一次，编译器就载入一次，所以记住这个原则：
  
  **$ \text{函数能手打就手打，头文件能不调用就不调用} $**
  
  所以我省去了`iostream`头文件，没用`using namespace std;`，而是手写了`max`：`#define max(x,y) ((x)^(((x)^(y))&(-((x)<(y)))))`
  
3. 不用cin/cout

  cin/cout其实很慢的，如果你被卡常了，记得换成快读/快输
  
经过这几个优化，就可以AC了，第8个点只用了832ms。

代码：

```cpp
#include<cstdio>
#include<cstring>
#define max(x,y) ((x)^(((x)^(y))&(-((x)<(y))))) //手写max
template <typename _Tp>
inline void read(_Tp &x){
    int w=1;char c=0;x=0;
    while (c^'-'&&(c<'0'||c>'9'))c=getchar();
    if (c=='-')w=-1,c=getchar();
    while (c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x*=w;
}
inline void write(int n){
    if(n==0) return;
    write(n/10);
    putchar(n%10+'0');
}//快读/快输
int que[100000000],dis[2011],v[1011][1011],ints[10000],qian[1011][1011],n,m,ans,cnt;//变量尽量一次定义
unsigned char bv[2011],G[1011][1011],st[2011];
inline void add(int s,int t,int l){
    G[s][t]=1;
    v[s][t]=max(v[s][t],l);
}
int main(){
    read(n),read(m);
    for(register int iii=1;iii<=m;iii++){
        read(cnt);
        memset(bv,0,sizeof(bv));
        for(register int i=1;i<=cnt;i++)read(ints[i]),bv[ints[i]]=1;
        for(register int i=1;i<=cnt;i++)
        for(register int j=ints[1];j<=ints[cnt];j++)if(!bv[j])add(j,ints[i],1);
    }//register定义变量很快的
    memset(bv,0,sizeof(bv));
    for(register int i=1;i<=n+1;i++)dis[i]=-1234567890;
    register int head=0,tail=1;que[0]=n+1;
    dis[n+1]=0;
    for(register int i=1;i<=n;i++)add(n+1,i,1);
    for(register int i=1;i<=n+1;i++)
    for(register int j=1;j<=n+1;j++)
    if(i!=j&&G[i][j])qian[i][0]++,qian[i][qian[i][0]]=j;
    do{
        int me=que[head];head++;bv[me]=0;
        for(register int j=1;j<=qian[me][0];j++){
            int i=qian[me][j];
            if(dis[me]+v[me][i]>dis[i]){
                dis[i]=dis[me]+v[me][i];
                if(!bv[i])bv[i]=1,que[tail++]=i;
            }
        }
    }while(head<tail);
    for(register int i=1;i<=n;i++)st[dis[i]]=1;
    for(register int i=1;i<=1000;i++)ans+=st[i];
    write(ans);
    return(0);
}
```

恳请管理员把我这篇题解跟[这篇文章](https://www.luogu.org/blog/user56917/solution-p1983)摆在一起

---

## 作者：LiJunze0501 (赞：20)

# 拓扑思想
拓扑，就是一个解决大小关系的东西。用有向图表示谁比谁大（大的定义要根据题意来），题目中可以抽象为级别（如本题）或年龄大小。  
# 本题思路
既然一条线路经过的都要大于等于某个等级，那剩下的就都小于这个等级。  
这看似是废话，但~~其实就是废话~~我们可以发现，线路上停靠的点的等级都比未停靠的点的等级高。  
那这是什么，这不是大小关系吗！  
拓扑，秒了！  
所以，先拓扑排序，再分层。  
温馨提示：拓扑时是未停留的指向停留的，后面分层要用。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,s[10001],vis[10001],rd[10001],maxle;
vector<int> v[10001];
int lj[1001][1001];//邻接矩阵
struct stati{
	int le,id;//le是等级,id是序号
};
int main(){
	cin>>n>>m;
	while(m--){
		cin>>x;
		memset(vis,0,sizeof(vis));//记得清空！！！
		for(int i=1;i<=x;i++){
			cin>>s[i];
			vis[s[i]]=1;
		}//停靠的就标注
		for(int i=s[1];i<=s[x];i++){
			if(vis[i]) continue;//停靠的跳过
			for(int j=1;j<=x;j++){
				if(!lj[i][s[j]]){//如果第i点和停留的第j个点未连接
					rd[s[j]]++;//一定是未停留点指向停留的点，后面分层要用
					v[i].push_back(s[j]);
					lj[i][s[j]]=1;//记录为已连接
				}
			}
		}
	}
	queue<stati> tb;//因为我之前念的是“tuo bu”，所以就是tb，存点的
	for(int i=1;i<=n;i++)
		if(!rd[i]) tb.push({1,i});//入度为零的放入队列，等级为1
	while(!tb.empty()){
		stati sta=tb.front();
		tb.pop();
		for(int i=0;i<v[sta.id].size();i++){
			rd[v[sta.id][i]]--;//指向的点入度减一
			if(rd[v[sta.id][i]]==0){//如果入度为零
				tb.push({sta.le+1,v[sta.id][i]});//等级为指向它的点的等级加一
				maxle=max(maxle,sta.le+1);//更新最高等级
			}
		}
	}
	cout<<maxle<<endl;//输出最高等级
} 
```
谢谢观看，记得点赞。

---

## 作者：Nahia (赞：6)

### 思路

> 使用拓扑排序。

将等级低的车站向等级高的车站连一条边，后面开始拓扑排序即可。

### solution

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int N=1e3+10;
vector<int>tmp[N];
int a[N],d[N];
bool t[N],f[N][N];
struct node{
	int x,step;
};
queue<node>q;
int main(){
    int n,m;
	cin>>n>>m;
	while(m--){
	    int x;
		cin>>x;
		memset(t,0,sizeof(t));
		for(int i=1;i<=x;++i){
			cin>>a[i];
			t[a[i]]=1;
		}
		for(int i=a[1]+1;i<a[x];++i)
			if(t[i]==0)
				for(int j=1;j<=x;++j)
					if(f[i][a[j]]==0){
						tmp[i].pb(a[j]);
						d[a[j]]++;
						f[i][a[j]]=1;
					}
	}
	for(int i=1;i<=n;++i)
		if(!d[i])
			q.push({i,1});
	int ans=0;
	while(!q.empty()){
		node u=q.front();
		ans=max(ans,u.step);
		for(auto i:tmp[u.x]){
			d[i]--;
			if(d[i]==0)
				q.push({i,u.step+1});
		}
		q.pop();
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：WsW_ (赞：4)

### 思路
停靠了某个站，那么级别大于等于它的都得停靠。由于等于这个条件非常难处理，而且在停靠了的站里面很难判断谁大谁小。于是我们把这个限制理解为，停靠了的站都一定比没停靠的站级别要高。  
然后这个停靠没停靠的条件，就变成了某些站比某些站级别要大的条件。某个站级别比某个站要大，可以抽象成某个站向某个站连有向边，表示大小关系。最小划分级数，就变成了这个图的最长路问题。  
最长路问题的经典解法是拓扑排序。如果你不知道拓扑排序以及最长路问题，请看 [P1807 最长路](https://www.luogu.com.cn/problem/P1807)。

注意，一定要判断重边，否则会建一堆重边导致时间复杂度爆炸。  
$n$ 个点最多建 $\dfrac{n(n-1)}{2}$ 条边，故时间复杂度为 $O(n^2m)$，瓶颈在于建边。理论上这个复杂度是无法通过的，但本题作为一道普及组的题，并没有卡这个做法。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

struct node{
	int next,to;
}edg[1000005];
int elen;

queue<int> q;

int n,m,s;
int in[1003];
int last,a;

int fans=1;
int ans[1003];
int start[1005],sl;
int head[1005];

bool e[1003][1003];
int stop[1003];
bool istop[1003];

void add(int u,int v){
	e[u][v]=1;
	elen++;
	edg[elen].to=v;
	edg[elen].next=head[u];
	head[u]=elen;
	in[v]++;
}

void SPFA(int s){
    ans[s]=max(ans[s],1);
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=edg[i].next){
			int to=edg[i].to;
			if(ans[to]<ans[x]+1){
				ans[to]=ans[x]+1;
				fans=max(fans,ans[to]);
			}
		    in[to]--;
			if(!in[to])q.push(to);
		}
	}
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        memset(istop,0,sizeof(istop));
        scanf("%d",&s);
        for(int j=1;j<=s;j++){
            scanf("%d",&stop[j]);
            istop[stop[j]]=1;
        }
        for(int j=1;j<=s;j++){
            for(int k=stop[1];k<=stop[s];k++){
                if(!e[k][stop[j]]&&!istop[k]){
                	add(k,stop[j]);
				}
            }
        }
    }
    for(int i=1;i<=n;i++){
        if(in[i]==0&&head[i]>0){
        	start[++sl]=i;
        }
    }
    for(int i=1;i<=sl;i++){
    	SPFA(start[i]);
	}
    printf("%d",fans);
    return 0;
}
```

---

## 作者：王鹏PRO (赞：4)

目前为止，Java通过的很少

**发一篇Java语言的题解**
------------
### 1. 题目标签
- 图的建立,建图
- 拓扑排序

所以解题的思路，就有了。（当然了，不止一种）

### 2. 解题思路：

- 建立有向无权图，从入度为0的点开始进行拓扑排序
- 有向图中的边的方向，由 **_非停靠车站_** 指向 **_停靠车站_**
- **_非停靠车站_** 级别一定要低于 **_停靠车站_**，这样才能不停靠
- **_非停靠车站_** 级别为1，然后拓扑排序，逐级递增+1

### 3. 题中难点 
- 最后的3个数据测试点，1≤n,m≤1000
- 使用BitSet以外的数据结构存储有向边，即使是邻接表的方式，也会MLT
- 同时BitSet也是Java中集合数据类型中，存取数据效率较高、内存使用较少的一种。

### 4. 代码实现

- 表示点（车站）的数据类型
------------
```java
    private static class Node {
        short level;//车站等级，默认为1
        short inDept = 0;//入度
        BitSet adj;//车站之间的邻接表
        Node() {
            level = 1;
        }
    }
```

- 有向无权图的建立
------------
```java
        for (int i = 0; i < M; i++) {
            in.nextToken();
            st[0] = (short) in.nval;
            for (int j = 1; j <= st[0]; j++) {
                in.nextToken();
                st[j] = (short) in.nval;
                vis[st[j]] = true;//停靠站= true
            }
            for (int j = st[1]; j <= st[st[0]]; j++) {
                if (vis[j]) continue;//跳过停靠站
                
                //非停靠车站 指向 停靠车站
                if(nodes[j].adj==null)nodes[j].adj = new BitSet();
                for (int k = 1; k <= st[0]; k++) {
                    if (!nodes[j].adj.get(st[k])) {
                        nodes[st[k]].inDept++;//停靠车站 入度+1
                        nodes[j].adj.set(st[k]);
                    }
                }
            }
            Arrays.fill(vis, false);
        }
```
- 拓扑排序
------------
```java
        ArrayDeque<Node> deque = new ArrayDeque<>();
        
        //从入度=0的点 开始进行排序（遍历）
        for (int i = 1; i <= N; i++) if (nodes[i].inDept == 0) deque.add(nodes[i]);
        while (!deque.isEmpty()) {
            Node cur = deque.poll();
            if(cur.adj==null) continue;
            int i =cur.adj.nextSetBit(0);//获取邻接表中第一个点
           while(i>=0){
                if (--nodes[i].inDept == 0) {
                    deque.add(nodes[i]);
                    if (cur.level + 1 > nodes[i].level) nodes[i].level = (short) (cur.level + 1);//递推下一级车站，level+1
                }
               i =cur.adj.nextSetBit(i+1);//获取邻接表中下一个点
            }
        }
```




### 5. 完全代码
------------
```java

import java.io.*;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;

public class Main {

    public static void main(String[] args) throws IOException {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        in.nextToken();
        int N = (int) in.nval;
        Node[] nodes = new Node[N + 1];
        boolean[] vis = new boolean[N + 1];
        short[] st = new short[N + 1];
        for (int i = 1; i < N + 1; i++) nodes[i] = new Node();
        in.nextToken();
        int M = (int) in.nval;
        for (int i = 0; i < M; i++) {
            in.nextToken();
            st[0] = (short) in.nval;
            for (int j = 1; j <= st[0]; j++) {
                in.nextToken();
                st[j] = (short) in.nval;
                vis[st[j]] = true;
            }
            for (int j = st[1]; j <= st[st[0]]; j++) {
                if (vis[j]) continue;
                if(nodes[j].adj==null)nodes[j].adj = new BitSet();
                for (int k = 1; k <= st[0]; k++) {
                    if (!nodes[j].adj.get(st[k])) {
                        nodes[st[k]].inDept++;
                        nodes[j].adj.set(st[k]);
                    }
                }
            }
            Arrays.fill(vis, false);
        }
        ArrayDeque<Node> deque = new ArrayDeque<>();
        for (int i = 1; i <= N; i++) if (nodes[i].inDept == 0) deque.add(nodes[i]);
        while (!deque.isEmpty()) {
            Node cur = deque.poll();
            if(cur.adj==null) continue;
            int i =cur.adj.nextSetBit(0);
           while(i>=0){
                if (--nodes[i].inDept == 0) {
                    deque.add(nodes[i]);
                    if (cur.level + 1 > nodes[i].level) nodes[i].level = (short) (cur.level + 1);
                }
               i =cur.adj.nextSetBit(i+1);
            }
        }
        int ans = 0;
        for (int i = 1; i <= N; i++) ans = Math.max(ans, nodes[i].level);
        System.out.println(ans);
    }

    private static class Node {
        short level;
        short inDept = 0;
        BitSet adj;
        Node() {
            level = 1;
        }
    }
}

```



---

## 作者：chrispang (赞：3)

看到如此鲜明的层级关系，准准的拓扑排序没得说（未停靠点到停靠点）。

把等级低的车站向等级高的车站连一条边，后面开始拓扑排序，把入度为 $0$ 的点放进队列，去更新其它的点，当其它的点入度也为 $0$ 时，更新答案，并且放入队列。

```c++
#include <bits/stdc++.h>
using namespace std;

int n, m, ans = 1, len, a[1010], ind[1010];
vector<int>linker[1010]; //邻接表 
bool is[1010], vis[1010][1010]; //is表示一辆车停留过哪些地方，vis表示vis[i][j]是否已经被访问过了 
struct node {
	int id, pts; //表示车站编号和车站级别 
};

void bfs() {
	queue<node>q;
	for (int i = 1; i <= n; i++)
		if(ind[i] == 0) q.push({i, 1}); //入度为0的点加进去 
	while(!q.empty()) {
		int x = q.front().id;
		int v = q.front().pts;
		q.pop();
		ans = max(ans, v); //更新答案 
		for (int i = 0; i < linker[x].size(); i++) { //枚举每一条边 
			int y = linker[x][i]; //找到每一条边所对应的车站 
			ind[y]--; //入度-1 
			if(ind[y] == 0) q.push({y, v + 1}); //如果入度为0，则说明这个点已经更新完毕，放入队列 
		}
	}
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		memset(is, 0, sizeof(is)); //清空数组 
		cin >> len;
		for (int j = 1; j <= len; j++) {
			cin >> a[j];
			is[a[j]] = 1; //进行记录 
		}
		for (int j = a[1]; j <= a[len]; j++) //枚举经过的车站 
			if(!is[j]) { //如果没有被停留过，则说明这个点级别较低 
				for (int k = 1; k <= len; k++) //把所有的停留过的点都遍历一遍，进行连接 
					if(!vis[j][a[k]]) { //如果这条边没有走过 
						ind[a[k]]++; //入度+1 
						linker[j].push_back(a[k]); //连上一条边 
						vis[j][a[k]] = 1; //进行标记 
					}
			}
	}
	bfs();
	cout << ans << endl;
	return 0;
}
```

---

## 作者：XCDRF_ (赞：2)

# P1983 \[NOIP2013 普及组] 车站分级

[原题传送门](https://www.luogu.com.cn/problem/P1983)

[更好的阅读体验](https://www.luogu.com.cn/article/pxl9frbf)

## 题目大意

设 $a_i$ 为 $i$ 车站的优先级，如果一个火车停在了 $x$ 车站，则对于任意一个满足 $a_i\geq a_x$ 的车站，都需要停靠。现在给出 $m$ 趟车次的停靠情况，求最大优先级的最小值。

## 解题思路

分析题目可知，如果始发站是 $x$，终点站是 $y$，那么能确定 $x$ 到 $y$ 之间任意一个没停靠的站点的优先级都小于任意一个停靠的站点的优先级。这样就可以拓扑排序做。从能确定的低优先级车站向高优先级车站连一条边，每个点的最低优先级是所有入度里最高的最低优先级加 $1$，最后输出最高的最低优先级。

但这样做每次要连 $n^2$ 条边，总共要连 $m$ 次，时间复杂度 $O(n^2m)$，无法接受。

考虑优化。对于每次建边，我们可以建立一个虚点，所有没有停靠的车站向虚点连一条边，虚点向所有停靠的车站连一条边。这样 $n^2$ 条边就变成了 $2n$ 条，总共要连 $m$ 次，时间复杂度 $O(nm)$。

注意虚点不增加优先级，不要算多了。

## 参考代码

```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e6+5;
int n,m,tot,num,nw,ans;
int head[N],ind[N],dep[N];
bool flag[N];
queue<int> q;
struct edge{
	int nxt,to;
}edge[N];
void add(int x,int y){
	edge[++tot].nxt=head[x];
	edge[tot].to=y;
	head[x]=tot;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	nw=n;
	for(int i=1;i<=m;i++){
		cin>>num;
		memset(flag,0,sizeof(flag));
		int minn,maxx;
		for(int j=1,idx;j<=num;j++){
			cin>>idx;
			if(j==1) minn=idx;
			if(j==num) maxx=idx;
			flag[idx]=1;
		}
		nw++;
		for(int j=minn;j<=maxx;j++){
			if(flag[j]){
				add(nw,j);//虚点向停靠的连边
				ind[j]++;
			}
			else{
				add(j,nw);//没有停靠的向虚点连边 
				ind[nw]++;
			}
		}
	}
	for(int i=1;i<=nw;i++)
		if(!ind[i]){
			if(i<=n) dep[i]=1;//一定不要让虚点有初值，因为这个挂了好多次
			q.push(i);
		}
	while(!q.empty()){//拓扑排序 
		int x=q.front();
		ans=max(dep[x],ans);
		q.pop();
		for(int i=head[x];i;i=edge[i].nxt){
			int xx=edge[i].to;
			if(xx>n) dep[xx]=max(dep[xx],dep[x]);//虚点不增加优先级 
			else dep[xx]=max(dep[xx],dep[x]+1);//最低优先级是所有入度里最高的最低优先级+1
			--ind[xx];
			if(!ind[xx]) q.push(xx);
		}
	}
	cout<<ans;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/197304048)

---

## 作者：ZHR100102 (赞：1)

# 图论建模

首先观察对于一条线路，我们可以从中直接得到什么信息：

假设这条线路的开头为 $st$，结尾为 $ed$，那么在 $[st,ed]$ 的车站中，没有被选入线路的点一定比选入线路的点的级数**至少**少 $1$。

对于这一点条件，我们就可以建模了。

和差分约束一样，我们从某个点起连到所有比其多 $1$ 的点的有向边，边权赋为 $1$。

然后拓扑排序跑**最长路**即可。不是最短路的原因是这些都是**充分必要条件**，每一个都必须满足，因此要选最长路。

这样建图是 $O(n^2m)$ 的，虽然常数小，但还是容易被卡。

# 优化

发现复杂度瓶颈在于是一堆点往一堆点连边，所以我们从优化建边的方式入手：虚点优化。

我们把那些原来的起点们连多条向这个虚点的有向边，边权赋为 $0$；然后从这个虚点连多条向原来的终点们的有向边，边权赋为 $1$，这样就可以在 $O(n)$ 的时间里完成 $O(n^2)$ 的建边了。

总体复杂度是 $O(nm)$。

# 细节

## 边权全部赋值为 $1$ 的做法

对于这种做法，非常万能，~~但我想不到~~。

写这种做法细节很少，我们无需处理起点是 $0$ 是 $1$，直接全赋为 $0$ 就好了，因为我们先不考虑起点。

最后统计答案的时候，我们只需要将 $ ans \div 2 +1$ 即可，$\div2$ 是因为经过虚点一次会走两条边，要除回来；$+1$ 是因为要加上起点。

同时注意有可能虚点入度为 $0$，所以虚点也要加入拓扑排序的初始化中，比如下面的数据：

```
in:
3 1
2 1 2

out:
1
```

代码如下：

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,a[1005],dp[3005],rd[3005],ans=0;
vector<int>g[3005];
queue<int>q;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int s,st=0,ed=0;
		cin>>s;
		bitset<1005>isin;
		for(int j=1;j<=s;j++)
		{
			cin>>a[j];
			isin[a[j]]=1;
			if(j==1)st=a[j];
			if(j==s)ed=a[j];
		}
		int vt=n+i;
		for(int j=st;j<=ed;j++)
		{
			if(isin[j]==0)
			{
				g[j].push_back(vt);
				rd[vt]++;
			}
			else
			{
				g[vt].push_back(j);
				rd[j]++;
			}
		}
	}
	for(int i=1;i<=n+m;i++)
	{
		if(rd[i]==0)
		{
			q.push(i);
			dp[i]=0;
		}
	}
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(auto v:g[u])
		{
			dp[v]=max(dp[v],dp[u]+1);
			rd[v]--;
			if(rd[v]==0)
			{
				q.push(v);
			}
		}
	}
	for(int i=1;i<=n+m;i++)
	{
		ans=max(ans,dp[i]/2+1);
	}
	cout<<ans;
	return 0;
}
```

## 对于边权先赋为 $1$，后面再赋为 $0$ 的做法

依然是上面的那个 hack 数据：

```
in:
3 1
2 1 2

out:
1
```

如果把入度为 $0$ 的虚点的最长路也初始化为 $1$ 的话，就会导致这组数据结果多一个 $1$。因此应该把虚点初始化为 $0$，其他点初始化为 $1$。

另外，不要读错题了，只有**起点和终点之间**的车站才受分级的约束，而不是全部车站。

代码如下：

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,a[1005],dp[3005],rd[3005],ans=0;
struct edge{
	int to,w;
};
vector<edge>g[3005];
queue<int>q;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int s,st=0,ed=0;
		cin>>s;
		bitset<1005>isin;
		for(int j=1;j<=s;j++)
		{
			cin>>a[j];
			isin[a[j]]=1;
			if(j==1)st=a[j];
			if(j==s)ed=a[j];
		}
		int vt=n+i;
		for(int j=st;j<=ed;j++)
		{
			if(isin[j]==0)
			{
				g[j].push_back({vt,0});
				rd[vt]++;
			}
			else
			{
				g[vt].push_back({j,1});
				rd[j]++;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(rd[i]==0)
		{
			q.push(i);
			dp[i]=1;
		}
	}
	for(int i=n+1;i<=n+m;i++)
	{
		if(rd[i]==0)
		{
			q.push(i);
			dp[i]=0;
		}
	}
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(auto tmp:g[u])
		{
			int v=tmp.to,w=tmp.w;
			dp[v]=max(dp[v],dp[u]+w);
			rd[v]--;
			if(rd[v]==0)
			{
				q.push(v);
			}
		}
	}
	for(int i=1;i<=n+m;i++)
	{
		ans=max(ans,dp[i]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：sieve (赞：1)

## 题解：[P1893](https://www.luogu.com.cn/problem/P1983)

## 思路

这题也比较明显吧。

我们直接将所有没有停靠的站点往停靠的所有站点建一条边，注意，我们不要建重边。

其它啥都没有（没到任何点也没有任何点到这里）就不建了，建不建都没关系。

然后，样例 $1$ 建完的图就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/170tgpfw.png)

很明显了，我们直接跑一遍拓扑，然后记录第几个到的，最后找到最后一个到的输出编号就行了。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e3+7;
int n,m,len;
bool flag[N];
int a[N],in[N];
bool vis[N][N];
vector<int> g[N];
struct no{
	int id,x;
};
void topu()
{
	int ans=0;
	queue<no> q;
	for(int i=1;i<=n;++i) if(in[i]==0) q.push({i,1});
	while(!q.empty())
	{
		no u=q.front();
		q.pop();
		for(auto v:g[u.id])
		{
			in[v]--;
			if(in[v]==0)
			{
				q.push({v,u.x+1});
				ans=max(ans,u.x+1);
			}
		}
	}
	cout<<ans;
	return;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;++i)
	{
		memset(flag,false,sizeof flag);
		cin>>len;
		for(int j=1;j<=len;++j)
		{
			cin>>a[j];
			flag[a[j]]=1;
		}
		for(int j=a[1];j<=a[len];++j)
		{
			if(flag[j]) continue;
			for(int k=1;k<=len;++k)
			{
				if(vis[j][a[k]]) continue;
				vis[j][a[k]]=1;
				in[a[k]]++;
				g[j].push_back(a[k]);
			}
		}
	}
	topu();
	return 0;
}
```

---

## 作者：JustinRochester (赞：1)

[题目](https://www.luogu.org/problem/P1983)

感谢 dalao @demonovo 提到的虚点给我提供了思路，虽然并不知道思路是否一样......（我没看具体内容啊喂）

~~233333333~~

-----
**【分析】**
--

根据题目意思，一辆火车如果从第 $p_1$ 个站点开往第 $p_c$ 个站点，则中间所有**有停靠的站点**等级一定高于**没停靠的站点**

于是我们可以这样考虑建边，从等级高的点指向低的点的有向边

那么，多条线路下来，我们明显可以建成一个DAG：所有确定等级关系的点间，一定有一条有向边。至于不确定的，没有关系，我们假设它属于任意合法等级即可

所以，接下来就是一个拓扑排序。对于此时入读为 $0$ 的点，我们视为同一等级。先将它们标记，然后统一进行删边。重复上述操作，直至排序完所有的点。

而重复的次数，就是分的级数，也就是答案。

---

设第 $j$ 辆火车从第 $p_{j,1}$ 站点始发，终止于第 $p_{j,c}$ 站点

该辆货车建边的耗时即为 $c[(p_{j,c}-p_{j,1})-c]\leq {1\over 4}(p_{j,c}-p_{j,1})^2\leq {1\over 4}n^2$ ，当且仅当 $c={n\over 2},p_{j,1}=1,p_{j,c}=n$ 时成立

那么，建边总时长就是 $O({1\over 4}n^2\times m)=O(mn^2)$ 。也就是说，单纯建边过程，就完全可以被出题人卡死

而拓扑排序的过程中，首先需要 $O(n)$ 找出入读为 $0$ 的点，然后删除这些点的所有边。最坏情况下每个点删边都是 $O(n)$ 的，删边总时长 $O(n^2)$

所以，设答案为 $ans$ ，拓扑排序的总时长就是 $O(ans\times n+n^2)$ ，因为 $ans\leq n$ ，所以为 $O(n^2)$

---

整体的思路肯定是没错的，但建边的代价未免太大了。

这次，我们考虑对建边进行优化

我们在建边的时候，需要建 $c(n-c)$ 条边。但我们的需要表达的很简单，就是停靠的点全部大于未停靠的点。

所以，我们引入一个中转点 $p_m$ 。那么，停靠的点全部大于 $p_m$ ，未停靠的小于 $p_m$ 

就相当于在第 $1$ 级和第 $2$ 级中间插入一个第 $1.5$ 级，第 $2$ 级和第 $3$ 级中间插入一个第 $2.5$ 级......在第 $(ans-1)$ 级和第 $ans$ 级中间插入一个第 ${(ans-1)+ans\over 2}={}ans-{1\over 2}$ 级，一共插入了 $(ans-1)$ 个级别

所以，此时对于拓扑排序出来的结果 $a$ 级，就满足 $a=ans+(ans-1)$ 所以，最后的答案为 ${a+1\over 2}$

---

我们还是估一下时间复杂度：

相同情况下，已知一条火车线路建边的条数优化为 $c+[(p_{j,c}-p_{j,1})-c]=p_{j,c}-p_{j,1}\leq n$；建边总耗时为 $O(m\times n)=O(nm)$

也就是说我们新建这 $m$ 个中转点，可以将复杂度优化到可接受的范围

而与此同时，拓扑排序的耗时改为 $O(a\times (n+m)+(n+m)^2)=O(a\times n+n^2)$($n,m$ 同阶)

上文提到了， $a=2\times ans-1$ ，所以拓扑排序总复杂度为 $O(n^2)$

---

**【分析】**
---

那本蒟蒻就放 ~~我码风极丑的~~ 代码了

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
typedef int i32;
typedef unsigned int u32;
typedef long long int i64;
typedef unsigned long long int u64;
//条件反射的一堆无用定义
const i32 MAXN=2048;
#define LOCAL
#ifdef LOCAL
    inline char gc() { return getchar(); }
#else
    inline char gc(){
        static char s[1<<20|1]={0},*p1=s,*p2=s;
        return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);
    }
#endif
inline i32 read(){
    register i32 ans=0;register char c=gc();register bool neg=0;
    while(c<48||c>57) neg=!(c^'-'),c=gc();
    while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
    return neg?-ans:ans;
}
//无聊的读入优化

i32 d_N,d_Ans;
i32 ar_d_Ind[MAXN],mt_d_Con[MAXN][MAXN];

inline void built_edge(i32 d_S,i32 d_E){//建边
    ar_d_Ind[d_E]++;
    mt_d_Con[d_S][ ++mt_d_Con[d_S][0] ]=d_E;
}
inline void inport(i32 d_MPnt){//读取一条线路
    i32 ar_d_Pnt[MAXN],*ptr_d_Pnt=ar_d_Pnt;
    bool ar_b_Pnt[MAXN]={0};
    f(i,1,I,read()) ar_b_Pnt[ *(ptr_d_Pnt++)=read() ]=1;
    f(i,*ar_d_Pnt,I,*(ptr_d_Pnt-1))//枚举这条线路经过的所有点
        if(ar_b_Pnt[i]) built_edge(i,d_MPnt);
        //有停靠的，建边至中转点
        else built_edge(d_MPnt,i);
        //未停靠的，由中转点建边
}

inline void del_edge(i32 d_Pnt){//删边
    f(i,1,I,mt_d_Con[d_Pnt][0]) ar_d_Ind[ mt_d_Con[d_Pnt][i] ]--;
    ar_d_Ind[d_Pnt]=-1;//防止下一轮拓扑排序又被枚举到
}
inline bool floor(){
    i32 ar_d_Pnt[MAXN]={0},*ptr_d_Pnt=ar_d_Pnt;
    f(i,1,I,d_N) if(!ar_d_Ind[i]) *(ptr_d_Pnt++)=i;//储存入读为 0 的点
    if(ptr_d_Pnt==ar_d_Pnt) return false;//找不到了，说明拓扑排序完毕
    for(register i32 *p=ar_d_Pnt;p<ptr_d_Pnt;p++) del_edge(*p);
    return true;
}

int main(){
    d_N=read();
    f(i,1,I,read()) inport(++d_N);
    while( floor() ) d_Ans++;
    d_Ans=(d_Ans+1>>1);
    printf("%d",d_Ans);
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---


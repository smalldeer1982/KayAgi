# 绿豆蛙的归宿

## 题目背景

随着新版百度空间的上线，Blog 宠物绿豆蛙完成了它的使命，去寻找它新的归宿。

## 题目描述

给出张 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。

绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\frac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^2$。
- 对于 $40\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $60\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times n$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^9$，给出的图无重边和自环。

## 样例 #1

### 输入

```
4 4 
1 2 1 
1 3 2 
2 3 3 
3 4 4```

### 输出

```
7.00```

# 题解

## 作者：___new2zy___ (赞：167)

## 题解 P4316 【绿豆蛙的归宿】

题目传送门：

https://www.luogu.org/problemnew/show/P2801

这题是道**期望dp经典模型**~~（水积分题）~~

可能这是我做过的第二道比较正经的期望题了。。。

但是个人感觉。。。好像做的顺序不太对？

这题看完了可以去看看这题：

[luogu p1850 换教室](https://www.luogu.org/problemnew/show/P1850)

（也是一道期望dp~~毒瘤~~题）

=========================================================

上面都是没什么用的。。。下面才是正题

一看这题。。。肯定是个**DAG**（别问我怎么看出来的QWQ）

根据题目要求，我们很自然的可以想到：

**设状态$f[x]$表示点x到终点n的期望路径总长**

显然，要求的**答案为f[1]**,**而且有$f[n]=0$**

（终点到自己的期望距离肯定为0啊。。。）

发现这时就是期望dp的套路了。。。

正好要将期望dp，不妨我们先来说说**期望dp的具体~~sao~~操作**

**期望dp，也加概率dp**

一般来说，期望dp找到正确的状态后，转移是比较容易想到的。

但一般情况下，**状态一定是“可数”的**

事实上，**将问题直接作为dp的状态**是最好的。

如，问**“n人做XX事的期望次数”**，那么不妨设计**状态为f[i]表示i个人做完事的期望**。

**转移一般是递推**，通常分两种，一种是从上一个状态转移得（填表法），另一种是转移向下一个状态（刷表法）。

有时期望dp需以最终状态为初始状态转移，即**逆推**。

如f[i]表示期望还要走f[i]步到达终点。这种状态的转移是**刷表法**

形如$f[i]=∑p[i→j]*f[j]+w[i→j]$，其中**p表示转移的概率**，**w表示转移对答案的贡献**。

一般来说，**初始状态确定时可用顺推，终止状态确定时可用逆推。**

大概期望dp的套路就是这样了吧。。。~~（我还是菜讲得不太好）~~

现在我们回到本题

上面提到了，我们**设状态f[x]表示点x到终点n的期望路径总长**，那么显然有f[n]=0

那么这正好符合了**“终止状态确定时可用逆推”**的策略~~套路~~

具体来说：

对于一条有向边,我们假设它由 $x->y$

那么有$f[x]=(\dfrac{1}{degree[x]})*∑f[y]+w[x->y]$

其中$degree[x]$表示x点的度（结合一下上面给出的式子你就懂了）

仔细观察题目其实你会发现,  $(\dfrac{1}{degree[x]})$其实就是概率(p)

同时又有一个问题，那就是**转移时的过程怎么实现**

不妨这样想：既然是个DAG，那么我们可以“倒过来”想

具体来讲，我们反向连边，进行一遍拓扑排序，在拓扑排序的时候进行期望dp的转移

这时候要注意上面的x和y要反过来（因为我们反向连边了）

那么我们转移方程就设计完啦

~~（其实还是挺好理解的是不是）（逃~~

**分析一下复杂度**

dp转移是与拓扑排序有关的，每次计算几乎是$O(1)$的

那么时间复杂度瓶颈就是拓扑排序，故时间复杂度为$O(n+m)$

下面放代码吧

PS：代码里也有解释

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
typedef long long ll;
const int inf=1e9+7;
inline int read()//读优
{
    int p=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
    return f*p;}
const int maxn=100003;
const int maxm=200003;
struct Edge
{
	int from,to,w;
}p[maxm];
int n,m,cnt,head[maxm],in[maxn],dg[maxn];
double f[maxn];//f[x]表示x点到终点n的期望路径总长 
inline void add_edge(int x,int y,int W)//加边
{
	cnt++;
	p[cnt].from=head[x];
	head[x]=cnt;
	p[cnt].to=y;
	p[cnt].w=W;
}
inline void toposort()//拓扑排序
{
	queue <int> q;
	q.push(n);
	while(!q.empty())
		{
			int x=q.front();
			q.pop();
			for(int i=head[x];i;i=p[i].from)
				{
					int y=p[i].to;
					f[y]+=(f[x]+p[i].w)/dg[y];//dp转移 
					if(!(--in[y]))q.push(y);
				}
		}
}
int main()
{
	/*这是我做这题的时候写的QAQ
	分析:不妨设f[x]表示x点到终点的期望路径总长度
	显然有f[n]=0
	那么对于一条有向边,连接着x和y点(x->y)
	那么显然有f[x]=sigma(f[y]+w[i])/degree[x] 
	其中degree[x]表示x点的出度,w[i]表示这条边的边权 
	那么假设我们已经知道了f[y]
	我们就可以反推f[x]
	显然只需要反向建边之后跑个拓扑排序就行了
	那么最后答案即为f[1]
	时间复杂度O(n+m) 
	*/
	n=read(),m=read();
	for(int i=1;i<=m;i++)
		{
			int x=read(),y=read(),w=read();
			add_edge(y,x,w);//反向建图 
			in[x]++,dg[x]++;
		}
	toposort();
	printf("%.2lf\n",f[1]);
	return 0;
}
```
这题就算讲完了吧。。。

本人思维比较跳跃，可能写的不是太好，请见谅

感谢你的阅读！

最后~~无耻的~~推一波我的blog：

https://www.luogu.org/blog/new2zy/

拜拜~~~


















---

## 作者：wangjyqh (赞：86)

##### 两种方法，正推和逆推

#### 逆推：$dp[i]$表示从$i$到$n$的期望，方程的转移：对于一条从$x$到$y$边
#### $dp[x]=\sum\limits_{i=1}^{oud[x]}(dp[y]+edge[i])/oud[x]$

#### 正推：$dp[i]$表示从$1$到$i$的期望，$g[i]$表示从$1$到$i$的概率，方程的转移：对于一条从$x$到$y$的边

#### $dp[y]=\sum\limits_{i=1}^{ind[y]}(dp[x]+edge[i]\times g[x])/oud[x]$

#### why?

#### 逆推：

#### $E(y)=p_1x_1+p_2x_2+\cdots\cdots+p_nx_n$

#### $E(x)=p_1(x_1+w)+p_2(x_2+w)+\cdots\cdots+p_n(x_n+w)=E(y)+\sum\limits_{i=1}^np_i\times w=E(y)+w$

### 因为从$i$到$n$,所有概率和为$1$

#### 正推：

#### $E(x)=p_1x_1+p_2x_2+\cdots\cdots+p_nx_n$

#### $E(y)=p_1(x_1+w)+p_2(x_2+w)+\cdots\cdots+p_n(x_n+w)=E(x)+\sum\limits_{i=1}^np_i\times w\neq E(x)+w$

### 因为从$1$到$i$，所有概率和i不为1

#### CODE（正推）:

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
const int MAXX=100010;
int oud[MAXX],ind[MAXX],ver[MAXX<<1],nxt[MAXX<<1],head[MAXX],edge[MAXX<<1];
double dp[MAXX],g[MAXX];
int tot,n,m;
inline void add(int x,int y,int z){
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
	edge[tot]=z;
	oud[x]++;
	ind[y]++;
}
inline void topsort(){
	queue<int>q;
	for(int i=1;i<=n;++i)if(!ind[i])q.push(i);
	dp[1]=0.000;
    g[1]=1.000;
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i];
            dp[y]+=(dp[x]*g[x]+(double)edge[i]*g[x])/(double)oud[x];
            g[y]+=g[x]/(double)oud[x];
            if(--ind[y]==0)q.push(y);
		} 
	}
}
int main(){
   cin>>n>>m;
   for(int i=1;i<=m;++i){
   	int x,y,z;
   	scanf("%d%d%d",&x,&y,&z);
   	add(x,y,z);
   }
   topsort();
   printf("%.2lf",dp[n]);
   return 0;
}
```

#### CODE2（逆推 )为了方便更新我们建了反图，但是出度以原图为准

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
const int MAXX=100010;
int head[MAXX],ver[MAXX<<1],nxt[MAXX<<1],edge[MAXX<<1],ind[MAXX],oud[MAXX];
int tot,n,m;
double dp[MAXX];
inline void add(int x,int y,int z){
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
	edge[tot]=z;
}
inline void topsort(){
	queue<int>q;
	dp[n]=0;
	for(int i=1;i<=n;++i)if(!ind[i])q.push(i);
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i];
			dp[y]+=(dp[x]+(double)edge[i])/(double)oud[y];
			if(--ind[y]==0)q.push(y);
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(y,x,z);
		ind[x]++;
		oud[x]++;
	}
	topsort();
	printf("%0.2lf",dp[1]);
	return 0;
}
```

---

## 作者：ghj1222 (赞：38)

题目大意：

给定一个DAG，求起点到终点的路径长度期望

根据题意可以知道每一条边都有一定概率被走到

那么$\displaystyle\begin{aligned} Ans = \sum_{e \in E} f_ew_e\end{aligned}$，其中$E$是边的集合，$f_e$是经过边$e$的期望次数，$w_e$是边$e$的边权

这样我们只需要求经过每一条边的期望次数

对于每一条边，经过这条边的期望次数就是经过这条边起点的期望次数除以这条边起点的出度

这样我们就只需要求经过每一个点的期望次数

由于是DAG，我们在DAG上拓扑排序递推一下即可

在地推的过程中，我们可以顺便求出经过每条边的期望次数

(其实经过某一个点的期望次数就等于它所有入边的期望次数的和，它所有出边的期望次数就等于它的期望次数除以它的出度)

详见代码

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

struct edge
{
	int v, w, ne;
}a[200010];

int n, m, tmp, top;
int in[100010], out[100010], h[100010], s[100010];
double f[200010], p[100010], ans;

int main()
{
	scanf("%d%d", &n, &m);
	for (int x, y, z, i = 1; i <= m; i++)
	{
		scanf("%d%d%d", &x, &y, &z);
		a[++tmp] = (edge){y, z, h[x]};
		h[x] = tmp;
		out[x]++;
		in[y]++;
	}
	s[++top] = 1;
	p[1] = 1;
	while (top > 0)//用一个栈维护所有可以选择的点
	{
		int x = s[top--];
		for (int i = h[x]; i != 0; i = a[i].ne)
		{
			in[a[i].v]--;
			p[a[i].v] += p[x] / out[x];//累加经过一个点的期望次数
			f[i] = p[x] / out[x];//计算经过一个边的期望次数
			if (in[a[i].v] == 0)
				s[++top] = a[i].v;
		}
	}
	for (int i = 1; i <= m; i++)
		ans += f[i] * a[i].w;
	printf("%.2f\n", ans);
	return 0;
}
```

拓展：如果不是DAG，可以列方程组求解，详见[[HNOI2013]游走](https://www.luogu.org/problemnew/show/P3232)

---

## 作者：Guitar_Jasmine (赞：33)

这题蒟蒻想了整整一天QWQ

这里讲一下顺推和逆推是怎么来的，怎么想的以及他们的区别，希望对像我一样初学期望DP的萌新有所帮助

### 顺推
- 首先上公式

###### $f[i]=sigma (f[j]+w(i,j)*p[j])/du[j]$
- 其中$f[i]$表示$1-i$的期望距离,$j$是$i$的前驱结点(~~我也不知道能不能这么说,懂我意思就好~~),$du[j]$表示$j$的出度,$w(i,j)$表示边权
- $p[j]$表示从起点走到$n$的概率,怎么算呢?
###### $p[i]=sigma(p[j]/du[j])$
- 这里$j$同样是$i$的前驱结点
- 为什么要乘上$p[j]$呢?因为你首先要到达这个点才可能走这条边呀(这个公式涉及到期望的一些知识,今天又主要讲顺推与逆推的区别,就不详细地推了(才不是我不会),但这样讲完~~感性~~理解应该也能看懂)。

### 逆推
- 公式

###### $f[i]=sigma(f[j]+w(i,j)*p[j])/du[i]$
- 除了$p[i]$以外每个变量的含义都与顺推相同,在此就不赘述了
- (~~妈妈这个人骗我~~,我看别的题解逆推不需要乘$p[j]$的!)
- 别急啊,不是说了这里的$p[i]$不一样嘛QWQ

##### 这里的$p[i]$表示从$i$走到终点的概率(理由和顺推一样~~显然~~)

- 显然,不管你从哪个点开始,最后都要到达终点,所以所有的$p[i]$都等于1(不信可以写个公式把每个$p[i]$推出来),所以反映到公式中就可以去掉啦,这就是很多$dalao$直接上逆推的原因,因为可以少算一个$p[i]$

- 代码嘛...~~我觉得楼下都很清楚~~,主要是理解思路嘛qwq
- ~~听某位$dalao$说$CSP$之前写题解可以让$RP+=MAX          LONGINT$~~

最后，在$CSP$的前夕

# 祝所有奋斗在前线的$OIer$,$CSP 2019 RP++!!!$

---

## 作者：Khassar (赞：18)

题目大意：随机在一个DAG上走，求1到n的路径长度的期望（我概括的对吧？）

我个人认为期望题不是很简单~~（因为我没有学过期望）~~，但是这个题是个例外。

首先它是一个DAG，方便我们倒着思考（它不会绕回去，那可能就成自动机了），即$n$到$n$的路径长度期望一定是$0$，考虑DP，我们可以记忆化搜下去，由于这是个DAG，已经搜过的点$i$到$n$的期望路径长度$f[i]$已经定下来就不会再变（没有后效性），边界就是$f[n]=0$，而这个题的期望部分其实没什么用，因为他等概率走每条边，直接用期望的定义可以知道$f[x]=(\sum f[v]+edgeval(x,v))/out[x]$（其中$edgeval(x,v$为x到v的边权，$out[x]$为$x$的出度），最终答案即为$f[1]$。

记忆化的代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>
#include<set>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memcpy((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=100005;

int n,m,head[N],tot,d[N],vis[N];
D f[N];

struct edge {
    int to,next,val;
}e[N<<1];

IL int read() {
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

IL void add(int u,int v,int c) {e[++tot].next=head[u];e[tot].to=v;e[tot].val=c;head[u]=tot;}

void dfs(int x) {
    if(x==n) {
        f[x]=0;
        return;
    }
    if(vis[x]) return;
    vis[x]=1;
    for(R int i=head[x];i;i=e[i].next) {
        R int v=e[i].to;
        dfs(v);
        f[x]+=(f[v]+e[i].val)/d[x];
    }
}

signed main()
{
    n=read();m=read();
    Rf(i,1,m) {
        R int u=read(),v=read(),c=read();
        add(u,v,c);d[u]++;
    }
    dfs(1);
    printf("%.2lf",f[1]);
    
    return 0;
}
```
但是递归又慢又占栈空间，考虑到它是一个DAG，我们可以先拓扑一遍，那么一定是先拓扑到的点由后拓扑到的点转移，我们只需要按拓扑序过一遍即可，无需递归。

拓扑版代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>
#include<set>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memcpy((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=100005;

int n,m,hd,tl,q[N],head[N],tot,d[N],vis[N],in[N];
D f[N];

struct edge {
    int to,next,val;
}e[N<<1];

IL int read() {
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

IL void add(int u,int v,int c) {e[++tot].next=head[u];e[tot].to=v;e[tot].val=c;head[u]=tot;}

signed main()
{
    n=read();m=read();
    Rf(i,1,m) {
        R int u=read(),v=read(),c=read();
        add(u,v,c);d[u]++;in[v]++;
    }
    q[++tl]=1;
    while(hd^tl) {
        R int now=q[++hd];
        for(R int i=head[now];i;i=e[i].next) {
            R int v=e[i].to;
            if(!(--in[v])) q[++tl]=v;
        }
    }
    Tf(I,n,1) {
        R int x=q[I];
        for(R int i=head[x];i;i=e[i].next) {
            R int v=e[i].to;
            f[x]+=(f[v]+e[i].val)/d[x];
        }
    }
    printf("%.2lf",f[1]);
    
    return 0;
}
```




---

## 作者：skydogli (赞：14)

## 期望入门~~水~~题
题意：给出一个DAG图，入度为0和出度为0的点各只有一个，分别为1和N，求从1到N的期望长度。

分析：题目给出的性质使我们可以非常轻易地递推，于是我们套上期望DP的基本套路，设F(u)为到达u点的期望长度，有sz条出边，则对于每一个出边所指向的点v，都会贡献（F(u)+边长的期望长度）/sz，当某个点的所有入度对它的贡献都计算完后，该点的期望长度就计算完成，可以搜索它的子节点了。

然而，一通乱码之后，发现样例都过不去——输出8.5，于是输出各个节点的期望长度：

节点1： 0  （没问题 ：)           
节点2： 0.5  （没问题 ：)   
节点3： 4.5 （？？？ :(

首先1给3的贡献1肯定是没问题的，换句话说就是节点2对3的贡献错了。于是我们发现，虽然经过节点2的概率只有0.5，但是我们直接把2到3的边的长度加了进去——相当于必须要经过这条边，显然是错误的。所以我们还需要记录进入某个节点的概率，计算对出点的贡献时，还需要把边乘以这一概率，然后就能愉快地AC啦～
#### 代码&注释
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MN 100005
#define ld long double
int n,m,a,b,c,ru[MN];//ru：入度（英语太菜勿喷）
ld f[MN],prob[MN];//某点的期望长度及经过该点的概率
vector<int>edge[MN],dist[MN];
void dfs(int x){
    int sz=edge[x].size();
    for(int i=0;i<sz;++i){
        f[edge[x][i]]+=((f[x]+(ld)(dist[x][i])*prob[x])/(ld)(sz));//记得转成浮点数计算
        prob[edge[x][i]]+=prob[x]/(ld)(sz);
        ru[edge[x][i]]--;//减少一个入度
        if(!ru[edge[x][i]])dfs(edge[x][i]);//如果该点计算完成，则搜索该点
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i){
        scanf("%d%d%d",&a,&b,&c);
        edge[a].push_back(b);
        dist[a].push_back(c);
        ru[b]++;
    }
    prob[1]=1;
    dfs(1);
    printf("%.2Lf",f[n]);
    return 0;
}

```


---

## 作者：友利奈绪 (赞：10)

妙，妙啊。

这道题让我非常愉悦，一开始做法完全没有思路，后来看了Oven的解析又看了各路大神的题解，本蒟蒻仿佛在黑暗中发现了一盏明灯。他们的代码写的有理有据，题解让人信服、简洁明了……


但我还是看不懂qaq
历经千辛万苦，我发现了一位大佬的代码。他没怎么用拓扑排序，也没用记忆化搜索，最重要的是他给出的求解期望的思路和我们上课时的方法完全一致！所以受他的启发，我终于把这道题A了……

[给一个该大佬题解的链接](https://cloud.tencent.com/developer/article/1094777)

这道题看起来挺头疼，但它是一个有向无环图（原谅我太弱看到DAG都不知道是什么意思……）。因此一条边顶一下来的期望路径长度是不会改变的！根据期望的线性性，我们可以将这个问题转化为求每一条边经过的长度期望之和。因此我们先把图存下来，然后dfs，dfs里的两个变量分别是dan当前所在的点和期望值。我们从1开始，搜索它出发的每一条边，然后tot++,用期望除以边数，可以得到1/tot为概率，概率再乘上边权，最后求和，就是总期望。然后dfs这条边连的下一个点……以此类推。是不是这样更好理解呢？（至少对于我这么弱的人是的）

直接上代码，存图方式很弱，大佬们不要嘲笑……

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int maxn=100010;
const int maxm=200010;
int head[maxn],nnext[maxm];
int to[maxm],length[maxm];
bool b[maxn];
int tot;
int n,m;
double ans=0;
void add(int x,int y,int l)
{
	tot++;
	nnext[tot]=head[x];
	head[x]=tot;
	to[tot]=y;
	length[tot]=l;
} 
void dfs(int q,double qw) //q为当前的点，qw为目前的期望值 
{
	int num=0;
	for(int i=head[q];i;i=nnext[i]) 
	{
		num++; // 求出当前所在点连的边数 
	}	
	qw=qw/num; // 加了概率的期望 
	for(int i=head[q];i;i=nnext[i]) 
	{
		ans+=length[i]*qw;
		dfs(to[i],qw); 
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		add(x,y,z);
	}
	b[1]=1;
	dfs(1,1);
	printf("%.2lf",ans);
	return 0;
}
```



---

## 作者：Refined_heart (赞：4)

第一道期望$DP$，来记录一下，顺便写个题解。

题目大意:给定一个$DAG$，求期望路径和。

由题意知，题目中的$K$就是每个点的出度。

然后，又由题意知，最后一个点，它没有出度，而到自己的距离为0，即状态已经确定。

于是，$DP$经典套路:倒推。

用前向星存图，从第一个点开始$DFS$,每次枚举它所连的边，并把边的边权$(val)$加上，最后除以它的出度即可。

方程：$DP[n]=0,DP[i]+=(DP[son[i]]+e[son[i]].val)/r[i]$

其中，$son[i]$是$i$所连得边，$e$是前向星，$val$是边权,$r[i]$是$i$的出度。

这题做完了。

$Code:$

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define MAXN 200000
#define res register
using namespace std;
struct node{
	int next,to,val;
}e[MAXN<<1];
int n,m,tot,vis[MAXN],head[MAXN],r[MAXN];
double dp[MAXN];
inline void add(int x,int y,int c){
	e[++tot].next=head[x];
	e[tot].to=y;
	e[tot].val=c;
	head[x]=tot;
}
void dfs(int x){
	if(x==n){
		dp[x]=0;
		return;
	}
	if(vis[x])return;
	vis[x]=1;
	for(res int i=head[x];i;i=e[i].next){
		int v=e[i].to;
		dfs(v);
		dp[x]+=(dp[v]+e[i].val)/r[x]*1.0;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;i++){
		res int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
		r[a]++;
	}dfs(1);
	printf("%.2lf\n",dp[1]);
	return 0;
}
```


---

## 作者：Y_B_Y (赞：3)

不想写拓扑的同学可以看一看这个~~又短又快~~的搜索

**~~不要长代码,也没有龟速搜索,搜索函数只要两行,你值得拥有~~**(虽然拓扑也很短)

我们设$f[i]$表示从$i$点走到终点的所经过的路径总长度**期望**

期望简单来说就是**所有的(贡献$\times$概率)的和**,比如一张彩票有0.0001%的几率中10000000元,有99.9999%中10元,那么买一张彩票期望中的钱数就是$0.0001\%\times 10000000+99.9999\%\times10=19.99999$

所以可以得到,$f[n]=0$(自己到自己的路径长肯定为0)

所以我们考虑**反着存图**,从n开始走,原本是看如果该节点有几条出边,现在是看有几个入边

先看一张正的图

![](https://cdn.luogu.com.cn/upload/image_hosting/m6ijo4zo.png)

再看一个反着存的图

![](https://cdn.luogu.com.cn/upload/image_hosting/n6ipby4k.png)

我们来看$f[1]$怎么求,我们先不管概率,直接让蛙在点1时跳到点2,那么,**点1走到终点路径总长度的期望=点2走到终点路径总长度的期望+1到2路径长度**(这应该是比较好理解的),即$f[1]=f[2]+2$,所以跳到点$2$对$f[1]$的**贡献**为$f[2]+2$,跳到第三点也同理

如果我们考虑概率,蛙在点1时都有$0.5$的几率到2和3,根据前面期望的求法,可得$f[1]=(f[2]+2)*0.5+(f[3]+1)*0.5$,当然,按下面的做法,此时$f[2]$和$f[3]$的值是**已经确定**的

根据上面的说明,我们可以得出结论

$f[i]=\sum ( \frac{1}{rd[i]}\times(f[j]+w[j->i]))$

这里$\sum$枚举所有可以到$i$的点$j,w[j->i]$为i到j的路径长,因为是反图所以,这里是$j->i,rd[i]$为点i的**入边个数**

现在来看**怎么搜索**,看上面的结论,似乎是从i点一个个找能到它的点,但其实肯定是如果$j$能到$i$则将$f[i]+= \frac{1}{rd[i]}\times(f[j]+w[j->i])$,这样也能有同样的效果

还有一点就是我们要避免一个点i的$f[i]$值还没确定就对其他点产生贡献,我们知道一个点的**所有入边都被走过时就说明它的贡献值已经确定**,而一个点对其他点产生更新需要从这个点**走**到被贡献点,**所以我们可以这样搜:**

从一确定贡献的点A走到B,分情况讨论:

如果B还**未确定**那么,将f[B]加上A的贡献/B的入边数,并使B剩余的入边减一,结束(未确定时不走)

如果B在A走到B后**已确定**,将f[B]加上A的贡献/B的入边数,并使B剩余的入边减一,再从B开始继续走(搜索)

###### ~~其实和拓扑排序差不多~~

第一个确定贡献的点为$n$

这样搜索可以保证正确且复杂度未$O(N+M)$(大概)

具体看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,ft[N],nx[2*N],w[2*N],to[2*N]/*存边四人组*/,rd[N],rn[N];//rd为入边的个数,rn为还未走过的入编个数
double f[N];
inline int read()//快读
{
    char c=getchar();int sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
void dfs(int x,int fr,int way)//x为现在所在点,fr为是从点fr到点x,way为从fr到x的路径编号
{
    f[x]+=(f[fr]+w[way])/rd[x];//加贡献
    if(!(--rn[x])) for(int i=ft[x];i;i=nx[i]) dfs(to[i],x,i);//如果rn[x]减一后为0,则说明其已经确定,可以继续走
}
void add(int x,int y,int wt){nx[wt]=ft[x];ft[x]=wt;to[wt]=y;rd[y]++;rn[y]++;}//因为add函数太常规,所以它缩了起来
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++) 
	{
	int x=read(),y=read();w[i]=read();
	add(y,x,i);//反着存,这里i为边的号数
    }
	for(int i=ft[n];i;i=nx[i]) dfs(to[i],n,i);//从n直接开始搜
	return printf("%.2lf",f[1]),0;//输出
}
```


---

## 作者：ModestCoder_ (赞：3)

[原题传送门](https://www.luogu.org/problemnew/show/P4316)

练一练期望
这应该是一道期望dp入门题

首先发现图可以用拓扑处理出来，不用dfs的原因是怕常数大

然后做期望dp

以前没练过期望，今天终于懂了

期望=概率*值

而概率是没有单位的，所以期望与那个实际的值的单位是一样的

$dp[u]$表示$u->n$的期望长度

因为从1走到n，考虑从n倒推

转移方程：$dp[v]+=(dp[u]+dis(u,v))/deg[v]$(反向存图后，v是u的儿子，deg表示度，根据题意来的）

边界：$dp[n]=0$

边DP边拓扑好了

Code:

```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;
struct Edge{
	int to, next, len;
}edge[maxn << 1];
int n, m, num, head[maxn], in[maxn], deg[maxn];
double dp[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y, int z){ edge[++num].to = y, edge[num].len = z, edge[num].next = head[x], head[x] = num; }

void dfs(){
	queue <int> q;
	q.push(n);
	while (!q.empty()){
		int u = q.front();
		q.pop();
		for (int i = head[u]; i; i = edge[i].next){
			int v = edge[i].to;
			dp[v] += (dp[u] + edge[i].len) / deg[v];
			if (!--in[v]) q.push(v);
		}
	}
}

int main(){
	n = read(), m = read();
	for (int i = 1; i <= m; ++i){
		int x = read(), y = read(), z = read();
		addedge(y, x, z);
		++in[x], ++deg[x];
	}
	dfs();
	printf("%.2f\n", dp[1]);
	return 0;
}
```


---

## 作者：cy汀 (赞：3)

[P4316 【绿豆蛙的归宿】](https://www.luogu.com.cn/problem/P4316)

看到题解里有很多大佬都在用拓扑+dp，我就写一个类似于哈希+dp的代码吧
```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int k[100010];//统计出度 
double dp[100010];//dp[i]:表示由i到n还需要的期望长度 
queue<long long> q[100010];//q[i]:用来存储与i相连的边的另一个点和长度（至于怎么存两个变量，下面会详细说明） 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b,c; 
		cin>>a>>b>>c; 
		q[a].push(b*10000+c);//存储关键：用一个长数存两个变量 
		k[a]++;//出度++ 
	}
	for(int i=n;i>=1;i--)
	{
		while(!q[i].empty())//只要还有与i相连的点 
		{
			int x=q[i].front();//取出一个点 
			int cc=x%10000;//算长度 
			int bb=(x-cc)/10000;//算另一个点 
		    dp[i]+=(1.0/k[i])*(dp[bb]+cc);//dp状态转移方程：dp[i]=(1/k)*(与其相连的边的长度之和+dp[与其相连的点]) 
			q[i].pop();//弹出 
	    }
    }
    printf("%.2lf",dp[1]);//输出 
	return 0;
}


```

---

## 作者：littleseven (赞：1)



## 题解：

**期望DP**

按照题目要求，给定一个有向无环图（DAG），求从起点到终点的期望路径长度，且每一条边都有可能被走到。

具体的策略大致是：先将整个DAG存下来，记录一下每个点的出度，之后深搜（DFS）从1开始的每一个点（实际是从后向前处理），遍历每一条边，之后对每一个点的贡献上都除以该点的出度即可，最终得到的$f[1]$就是答案。

## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100100;

const int M = N * 2;

double f[N];

int n, m, outd[N], vis[N];
int tot, head[N], nex[M], val[M], to[M];

void add(int x, int y, int z)
{
	to[ ++ tot] = y;
	val[tot] = z;
	nex[tot] = head[x];
	head[x] = tot;
	outd[x] ++ ;
}
void dfs(int x)
{
	if (vis[x])
		return;
	vis[x] = 1;
	for (int i = head[x]; i; i = nex[i])
	{
		int v = to[i];
		dfs(v);
		f[x] += 1.00 * f[v] + 1.00 * val[i];
	}
	if (outd[x])
		f[x] /= 1.00 * outd[x];
}
int main()
{
	scanf("%d%d", &n ,&m);
	for (int i = 1; i <= m; i ++ )
	{
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c);
		add(a, b, c);
	}
	dfs(1);
	printf("%.2lf", f[1]);
	return 0;
}
```

---

## 作者：紫薯布丁 (赞：1)

## 我可能是所有题解里思路最清奇~~而且跑的最慢~~的一个

这道题的初步思路是这样的，每一次到达一个点，就把到达这个点的期望值累加压入栈中。直到所有的路径走完为止、

但是这样是错误的，因为每条路径到达一个点的时候期望值是不一样的（除非除了终点之外每个点的入度只有一。）

~~没过样例但是也骗了二十分~~




所以最后的思路是，**每次到达一个点，都把从这条路径迄今为止的权值累加，概率累乘压入栈中，到达终点的时候，把这条路径的总权值和概率相乘，就构成了到达终点的一个期望，将这些期望累加即为答案**


我们用vector存边，好记录每个点的出度（K）

然后开一个结构体类型的栈，记录权值和概率

上代码



```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<stack>

#define ss 100500
using namespace std;

inline int read(){
	int x(0),f(1);char c(getchar());
    for(;!isdigit(c);c=getchar()) c=='-'?f=-1:1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    return x*f;
}
struct oo{
	int id,v;
};
vector<oo>e[ss];//我们定义一个结构体类型的vector 方便记录权值 
int n,m;
double dis[ss],k[ss];
inline void add(int x,int y,int z){
	oo a;
	a.id=y,a.v=z;
	e[x].push_back(a);//vector存边 
}
struct op{
	int id;double k,dis;
};



inline double bfs(int s){
	dis[s]=0;
	stack<op>q;//栈中的每个元素记录着编号，到达这个点的总权值和概率 
	op t;
	t.id=s,t.k=1.0,t.dis=0.0;
	q.push(t);
	while(q.size()){
		op rer=q.top();q.pop();
		//printf("push %d\n",rer.id);
		int u(rer.id);double k(rer.k);
		for(register int i=0;i<e[u].size();i++){
			int y=e[u][i].id,z=e[u][i].v;
			if(y==n) dis[n]+=(rer.dis+(double)z)*k*(1.0/(double(e[u].size())));
			op kar;
			kar.dis=rer.dis+z;//权值相加 
			kar.id=y;kar.k=k*(1.0/(double(e[u].size())));//概率累乘 
			q.push(kar);
			
		}
	}
	return dis[n];
}


main(){
	n=(read()),m=(read());
	for(register int i=1;i<=m;i++){
		int x(read()),y(read()),z(read());
		add(x,y,z);
	}
	printf("%.2lf\n",bfs(1));
}
```


---

## 作者：CreeperLordVader (赞：1)

### 好像没有记忆化搜索的题解？蒟蒻来贡献一发（~~风格简明清晰，代码易懂~~）
DFS被下面大佬吐槽为效率低，不过加一个记忆化以后效率就不错了（本来这题也是个DP）

### 作为一道期望DP，我们设$ d(x) $为从$ x $点出发能获得的期望值

那么对于$ x $,只要将所有$ y\in son(x) $的$ d(y) $除以该点出度并累加即可

边界为$ d(n)=0 $

# 状态转移方程(out[x]为该点出度)：

# $ d(x)=\sum_{y\in son(x)} \{(d(y)+edge(x,y))/out[x]\} $

话不多说见代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,out[100010];
double d[100010],maxn;
vector<int>v[100010];
vector<int>e[100010];
void read(int& x)
{
    char c=getchar();
    x=0;
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
}
double dp(int x)
{
    if(x==n)return d[x]=0.0;
    if(d[x]<0x3f3f3f3f)return d[x];
    d[x]=0.0;
    for(unsigned int i=0; i<v[x].size(); i++)
    {
        d[x]+=(double)1/out[x]*(e[x][i]+dp(v[x][i]));
    }
    return d[x];
}
int main()
{
    read(n);
    read(m);
    for(int i=1; i<=m; i++)
    {
        int x,y,z;
        read(x);
        read(y);
        read(z);
        v[x].push_back(y);
        e[x].push_back(z);
        out[x]++;
    }
    for(int i=1; i<=n; i++)
    {
        d[i]=(double)0x3f3f3f3f;
    }
    printf("%.2lf\n",dp(1));
}
```


---

## 作者：香风智乃 (赞：1)

[blog](https://www.cnblogs.com/kafuuchino/p/9540306.html)

因为非要用bfs所以稍微麻烦一点qwq（大家用的都是dfs）

其实问题让我们求的就是经过每条边的概率*边权之和

我们可以用bfs把图遍历一遍处理概率，顺便把每条边的概率*边权存到这条边的终点上

最后把每个点的答案累加起来，答案就出来了
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cctype>
using namespace std;
inline int Int(){
    char c=getchar(); int x=0;
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}
const int maxn=100002;
int n,m,cnt,siz[maxn],hd[maxn],ed[maxn],nxt[maxn<<1],to[maxn<<1],in[maxn];
double ans,dis[maxn<<1],f[maxn],p[maxn];
inline void add_edge(int x,int y,int v){
    nxt[ed[x]]=++cnt, ed[x]=cnt, hd[x]= hd[x] ?hd[x]:cnt;
    ++siz[x], ++in[y], to[cnt]=y, dis[cnt]=(double)v;
}
void bfs(int st){//bfs处理
    queue <int> h;
    h.push(st); p[st]=1.0; //初始概率为1
    while(!h.empty()){
        int x=h.front(); h.pop();
        double Q=p[x]/(double)siz[x]; //到从该点经过每条边的概率
        for(int i=hd[x];i;i=nxt[i]){
            p[to[i]]+=Q, f[to[i]]+=dis[i]*Q; --in[to[i]]; //p数组存储概率，f数组存储所求答案
            if(in[to[i]]<=0) h.push(to[i]);
        }
    }
}
int main(){
    n=Int(); m=Int();
    int q1,q2,q3;
    for(int i=1;i<=m;++i){
        q1=Int(); q2=Int(); q3=Int();
        add_edge(q1,q2,q3);
    }
    bfs(1);
    for(int i=1;i<=n;++i) ans+=f[i]; //累加答案
    printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：傅思维666 (赞：0)


## 题解：

看到期望先想想期望DP（大佬@zcs0724说期望题基本都是期望DP。）

**附：**期望的概念：（摘自本蒟蒻的博客）

如果$X$是一个随机变量，它的取值分别是$x_1,x_2\cdots x_n$，那么一个随机事件就可以表示为$X=X_i$，假设它的概率是$P(X=X_i)=p_i$，那么它的期望被称为$E(X)$，有：
$$
E(X)=\sum_{i=1}^{n}p_i\times x_i
$$
通俗地理解，一个随机变量的期望就是这个**随机变量的所有取值与其概率的乘积之和**。

---

如果对概率论的其他概念还有知识盲区的，敬请翻看本蒟蒻的这篇博客：

[概率论相关概念详解](https://www.cnblogs.com/fusiwei/p/11742213.html)

那么按这个思路：

设$E[x]$为点$x$到终点$n$的路径期望总和。那么很显然地，答案为$E[1]$，而初值$E[n]$为$0$。那么自然而然地，我们想到反向建图，从终点开始DP。从后往前开始逆推，最后得出$E[1]$的值。

根据逆推的过程和期望的定义，那么每一个节点的$E[x]$就应该是这个节点的子节点（这时还是正着的图）的$E$值加上这个子节点到$x$的边长除以这个节点的出度。

也就是：
$$
E[x]=\sum_{y\in to}\{(E[y]+val[i])\times\frac{1}{to}\}
$$
我们实现这个逆推可以使用深搜，但是深搜常数比较大，所以我们选择拓扑排序（效果是一样的）。

具体实现的细节是：

我们建图的时候不用建两遍，直接一遍建完反向边即可。**但是**，我们记录度的时候还是要按原来的记录，而且要记录两遍，一遍随拓扑排序的过程而改变，另一个作为计算期望值的参数一直保持不变。

这也是最容易出锅的点。

代码：

```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=1e5+10;
int n,m;
int tot,head[maxn],to[maxn<<1],val[maxn<<1],nxt[maxn<<1];
int out_degree[maxn],degree[maxn];
double f[maxn];
queue<int> q;
void add(int x,int y,int z)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
    val[tot]=z;
}
int main()
{
    scanf("%d%d",&n,&m);
    q.push(n);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add(y,x,z);
        out_degree[x]++;
        degree[x]++;
    }
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=nxt[i])
        {
            int y=to[i];
            f[y]+=(f[x]+val[i])/degree[y];
            out_degree[y]--;
            if(!out_degree[y]) 
                q.push(y);
        }
    }
    printf("%.2lf",f[1]);
    return 0;
}
```



---


# 『PG2』弯曲半平面直线同向图最大流

## 题目描述

若能将有向图 $G=(V,E)$ 画在平面上，使得点在一条直线上，任意两条边（可以为弯曲的弧线）仅在重合顶点处相交，且边上的所有点都在直线同侧，且每条边的起点到终点的射线的方向相同，则称 $G$ 是弯曲半平面直线同向图。对于一个弯曲半平面直线同向图给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。

## 说明/提示

无重边自环。

对于 $30\%$ 的数据 $n\leq 10^3$。

对于 $70\%$ 的数据 $n\leq 10^5$。

对于 $100\%$ 的数据 $2\leq n\leq 10^6$，$1\leq m\leq \min\{2\times 10^9,\dfrac{n(n-1)}{2}\}$，$1\leq c\leq 10^{12}$，$s\neq t$。

### 样例解释 1
![](https://cdn.luogu.com.cn/upload/image_hosting/9qletk0m.png)

## 样例 #1

### 输入

```
5 7 1 5
1 2 1
2 3 1
3 4 1
4 5 1
2 4 1
1 4 1
1 5 1```

### 输出

```
2```

# 题解

## 作者：P_Bisector (赞：2)

本蒟蒻没看懂题解然后很无脑的过了此题，于是来写这篇题解。时间复杂度 $O(n \log n)$，但是瓶颈在排序。（虽然我并不信任 vector 的常数但是 sort 的常数还是非常可靠的，跑个 $10^6$ 没有任何问题。）

首先这是一个求最大流的问题，因此把所有无关点去掉。其次~~由题易得~~根据定义可以看出来这是个 DAG，因此对于剩下的点无脑拓扑排序。接下来显然的我们可以把所有点按拓扑序放置在一条直线上。（没错，这一段处理比核心代码还长。）

这个图最外层是几段连在一起的弧，我们考虑处理每一段弧下面的最大流，因此我们可以考虑分治。处理完下面的最大流之后整段的最大流就是上面一条弧的流量的加上下面的最大流的最小值。由于每一条边都要过一遍，所以这里时间复杂度是 $O(n)$（$n$，$m$ 同级）。

最后关于实现的问题，就是说怎么处理哪些弧在上面哪些弧在下面的问题，我采用的实现方法是每次分治时跳的尽量远然后标记一下这条边走过了。这就需要排序了。

代码：
```cpp
//Always trust in sort,never believe vector.
#include<bits/stdc++.h>
//#define int long long 这里真的不需要long long就能过？
using namespace std;
const int N=2000050;//m<=2n-3
int U[N],V[N],W[N],vis[N],rd[N],to[N],now[N],pr[N],Pr[N],rp[N],Rp[N]; 
vector<int>ord,vec;
void dfsG(int x){if(vis[x])return;
vis[x]=N;for(int i=Pr[x];i;i=pr[i])dfsG(V[i]);}
void dfsR(int x){if(vis[x]%N)return;
vis[x]++;for(int i=Rp[x];i;i=rp[i])dfsR(U[i]);}
bool cmp(int a,int b){return V[a]>V[b];}
inline int read(){
	register int x=0,f=1;
	register char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
int solve(int L,int R){//想不到吧，核心代码这么短
	if(L==R)return 0;
	int L2=L,mn=0x3f3f3f3f;
	while(L2!=R){
		if(!V[now[L2]])return 0;
		int tmp=now[L2];
		now[L2]=pr[now[L2]];
		int L3=V[tmp],w=W[tmp];
		mn=min(mn,w+solve(L2,L3));
		L2=L3;
	}
	return mn;
}
void Sort(int x){
	if(!x)return;
	vec.clear();
	for(int i=now[x];i;i=pr[i]){
		vec.push_back(i);
	}
	if(vec.empty())return;
	sort(vec.begin(),vec.end(),cmp);
	now[x]=vec[0];
	for(int i=0;i<vec.size()-1;i++){
		pr[vec[i]]=vec[i+1];
	}
	pr[vec[vec.size()-1]]=0;
}
signed main(){
	int n,m,s,t,flag=0;
	n=read(),m=read(),s=read(),t=read();//一定要用快读
	for(int i=1;i<=m;i++)U[i]=read(),V[i]=read(),W[i]=read()
	,pr[i]=Pr[U[i]],Pr[U[i]]=i,rp[i]=Rp[V[i]],Rp[V[i]]=i,rd[V[i]]++;
	dfsG(s),dfsR(t);queue<int>Q;for(int i=1;i<=m;i++)Q.push(!rd[i]*i);
	while(Q.size()){
		int h=Q.front();Q.pop();if(vis[h]>N)ord.push_back(h);
		for(int i=Pr[h];i;i=pr[i])if(!--rd[V[i]])Q.push(V[i]);
	}//拓扑
	for(int i=0;i<ord.size();i++)to[ord[i]]=i+1;
	for(int i=1;i<=m;i++)U[i]=to[U[i]],V[i]=to[V[i]];
	for(int i=1;i<=n;i++)now[to[i]]=Pr[i];
	for(int i=1;i<=ord.size();i++)Sort(i);
	if(V[now[1]]==ord.size())flag=W[now[1]],now[1]=pr[now[1]];
	cout<<flag+solve(1,ord.size());
    return 0;
}
//码风清奇，请见谅
```

---

## 作者：xixisuper (赞：2)

# P9901 『PG2』弯曲半平面直线同向图最大流 题解

以此题解纪念我那失去的一整个上午。

~~这题才绿？这题没有蓝？~~

## 思路

我们分析一下这个**弯曲半平面直线同向图**到底有什么性质。

- 首先，很显然这是一个有向无环图，既然是有向无环图肯定就存在拓扑序，我们不妨记点 $u$ 的拓扑序为 $tp_u$。

由于我们要找最大流，所以显然只有**从源点能走到**且**能走到汇点**的那些点对答案有贡献，我们不妨正反走两次 dfs 找到这些点并打上标记。

本题解后续默认提到的所有点都是**从源点能走到**且**能走到汇点**的点。

- 然后就是最重要的一点，**如果存在一条边 $(u,v)$，则必然不存在边 $(u',v')$ 使得 $tp_u<tp_{u'}<tp_v<tp_{v'}$ 成立。**

证明是简单的，显然当我们把这个图放在直线上后，一定是按照其拓扑序递增的顺序排列的，这时如果上述的两条边 $(u,v)$ 和 $(u',v')$ 存在，则这两条边必然相交，与这个图的定义不符。

综合上述两点，我们发现了另一个性质，**如果某个点 $u$ 直连的点构成的点集为 $\{v_1,v_2,\cdots,v_k\}$，且 $tp_{v_i}<tp_{v_{i+1}}$，那么对于 $\forall i\in[1,k)$，想要从点 $v_i$ 走到汇点 $t$ 必须经过点 $\{v_{i+1},v_{i+2},\cdots,v_k\}$，且它们是的先后顺序与其拓扑序大小关系是相同的。**

这个性质想要解释起来就比较抽象了，可以感性理解为 $(u,v_i)$ 是一个罩子，罩住了 $tp_u$ 到 $tp_{v_i}$ 的点，根据第二条性质，它们如果想要连到汇点 $t$ 上就只能经过点 $v_i$。

由于我们希望求出最大流，所以说流到汇点的流量越大越好，如果从点 $u$ 开始往后走，无论走哪一条路，最后都会经过点 $v_k$，如果不想浪费流量的话，我们显然选择让流量通过直连边直接流向点 $v_k$，同理可知，如果存在两个点 $v_i$ 和 $v_j$ 且 $i<j$，我们会更倾向于把流量灌给拓扑序大的那个点，也就是 $v_j$。

于是我们就有了一个贪心思路，从源点开始，记录当前点能够得到的流量最大值，记为 $f$，把 $f_s$ 初始化为无穷大。遍历拓扑序从小到大的点，列出该点能够到达的点的点集，排序后从拓扑序大的那个点开始，如果 $f_u\ge c$，则 $f_v\leftarrow f_v+c,f_u\leftarrow f_u-c$，否则的话则 $f_v\leftarrow f_v+f_u,f_u\leftarrow 0$，最后输出 $f_t$ 则为最终答案。

实际上这样写的正确性是毋庸置疑的，但是时间复杂度会来到 $O(n\log n)$（$n$ 与 $m$ 同级），如果实现的好的话是可以跑进 550ms 的，但鄙人人傻常数大，就硬是卡不过去，所以考虑优化。

不难发现时间复杂度瓶颈在于排序，我们考虑通过返图重新建一边正图，但这次建图的时候根据拓扑序的顺序建图（如果用 `vector` 存的话就是拓扑序从大到小遍历，如果是邻接表的话就是拓扑序从小到大遍历），这时候遍历每个点的每条边的时候到达的点本身就是有序的了，就无需排序了，时间复杂度成功优化到了 $O(n)$。

下面的这些话是写给思路一样但是被卡 T 了的人说的。

~~听起来这题好像挺简单的，那为什么笔者做了一整个上午呢？~~

总结起来就是笔者低估了 `vector` 的常数，导致实现的算法常数奇大无比，硬控笔者一整个上午。如果你也被卡，可以采用如下种方式来优化常数：

- 快读，一般卡常先从 IO 开始卡。
- 不要把所有的变量都开成 `long long`，实测开 `int` 会比全开 `long long` 快 20ms 左右。
- STL 有大常数，被卡就不要用它了。
- 在一些多次调用且单次操作简单的函数名前加上 `inline`。
- 在一些快速变化的变量（如循环变量 `i` 等）前加上 `register`。
- ~~沐浴更衣，虔诚祷告。~~

## 代码

蒟蒻代码，不喜勿喷。

```cpp
#include <iostream>
#include <vector> 
#include <queue>
#include <algorithm>
#define ll int
using namespace std;
const ll N=1e6+10;
const long long INF=2147483647;
inline ll read(){
	register long long x=0,f=1;
	register char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
ll in[N],q[N],front,rear,n,m,s,t,cnt;
ll vis[N],ni_tupo[N];
long long f[N];
struct node{ll v,nxt;long long c;}zh[3][N<<1];
ll head[3][N],tot[3];
inline void add_edge(ll opt,ll u,ll v,long long w){
	zh[opt][++tot[opt]].v=v;
	zh[opt][tot[opt]].c=w;
	zh[opt][tot[opt]].nxt=head[opt][u];
	head[opt][u]=tot[opt];
}
inline void dfs(ll opt,ll u){
	vis[u]=opt+1;
	for(ll i=head[opt][u];i;i=zh[opt][i].nxt)
		if(vis[zh[opt][i].v]==opt)
			dfs(opt,zh[opt][i].v);
}
int main(){
	n=read(),m=read(),s=read(),t=read();
	for(register ll i=1;i<=m;i++){
		ll x=read(),y=read(),z=read();
		add_edge(0,x,y,z);
		add_edge(1,y,x,z);
		in[y]++;
	}
	dfs(0,s);dfs(1,t);
	for(ll i=1;i<=n;i++) if(!in[i]) q[rear++]=i; 
	while(front<rear){
		ll now=q[front++];
		if(vis[now]==2){
			cnt++;
			ni_tupo[cnt]=now;
		}
		for(register ll i=head[0][now];i;i=zh[0][i].nxt){
			in[zh[0][i].v]--;
			if(!in[zh[0][i].v]) q[rear++]=zh[0][i].v;
		}
	}
	for(ll i=1;i<=cnt;i++){
		for(ll j=head[1][ni_tupo[i]];j;j=zh[1][j].nxt){
			if(vis[zh[1][j].v]!=2) continue;
			add_edge(2,zh[1][j].v,ni_tupo[i],zh[1][j].c);
		}
	}
	f[s]=INF*INF;
	for(ll i=1;i<=cnt;i++){
		for(ll j=head[2][ni_tupo[i]];j;j=zh[2][j].nxt){
			if(vis[zh[2][j].v]!=2) continue;
			f[zh[2][j].v]+=min(zh[2][j].c,f[ni_tupo[i]]);
			f[ni_tupo[i]]-=min(zh[2][j].c,f[ni_tupo[i]]);
			if(!f[ni_tupo[i]]) break;
		}
	}
	cout<<f[t];
	return 0;
} 
```

Thanks for watching.

---

## 作者：phigy (赞：2)

因为题解区均非正解，这里复制了我的本题官方题解。

---

## T4 弯曲半平面同向图最大流

### 30 分

你不看题目直接释放常用最大流算法即可得到此部分分。

### 70 分

我不知道为啥描述这个图会变得这么奇怪，总之就是一个边的拓扑序不会交叉的 DAG 上的最大流。

这东西非常简单，总之我们每次往不超过 $T$ 的拓扑序最大的点尽可能推流就行了，因为不往这个点推的话，要么到不了 $T$，要么到 $T$ 必须经过这个点，所以还不如往这个点推。

我们会发现 $n,m$ 是同级的（$m\leq 2n-3$）所以放心输入。


下面是个 $O(n\log n)$ 的实现。

它甚至能获得在 HLPP 板子题中获得一个优秀的分数。


```cpp
#include <iostream>
#include <queue>
#include <algorithm>

#define int long long

using namespace std;

int n,m,s,t;
struct edge
{
	int from,to,next,dis;
}e[1000005];
int cnt,head[1000005];
void add(int x,int y,int z)
{
	cnt++;
	e[cnt].from=x;
	e[cnt].to=y;
	e[cnt].dis=z;
	e[cnt].next=head[x];
	head[x]=cnt;
}
int ru[1000005];
int tp[1000005];
queue<int>q;
struct flow
{
	int x,y,z;
}a[1000005];
int cmp(flow f,flow g)
{
	if(f.x==g.x)return f.y>g.y;
	return f.x<g.x; 
}
int ex[1000005];
signed main()
{
	int i,j,k;
	cin>>n>>m>>s>>t;
	for(i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		add(x,y,z);
		ru[y]++;
	}
	for(i=1;i<=n;i++)
	{
		if(ru[i]==0)
		{
			tp[i]=1;
			q.push(i);
			i=n+1;
		}
	}
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(i=head[x];i;i=e[i].next)
		{
			int v=e[i].to;
			ru[v]--;
			if(ru[v]==0)
			{
				tp[v]=tp[x]+1;
				q.push(v);
			}
		}
	}
	for(i=1;i<=m;i++)
	{
		a[i].x=tp[e[i].from];
		a[i].y=tp[e[i].to];
		a[i].z=e[i].dis;
	}
	stable_sort(a+1,a+m+1,cmp);
	ex[tp[s]]=1e18;
	for(i=1;i<=m;i++)
	{
		if(a[i].y>tp[t])continue;
		int res=min(a[i].z,ex[a[i].x]);
		ex[a[i].x]-=res;
		ex[a[i].y]+=res;
	}
	cout<<ex[tp[t]];
	return 0;
} 
```

### 100 分

它能够做到 $O(n)$ 而不是 $O(n\log n)$ 因为我们可以从拓扑序较大的点往较小的点的队列中去存放边实现一个排序。

这个对 $O(\log n)$ 优化考察了对拓扑排序的认识深度，本题定位是 C。 


```cpp
#include <bits/stdc++.h>
#define File(name) freopen(#name".in", "r", stdin); freopen(#name".out", "w", stdout);
using namespace std;
using ll = long long;
using ull = unsigned long long;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++)
char buf[1000000], *p1(buf), *p2(buf);
template<typename T>
inline T read(){
    T n = 0; int f = 1; char ch = getchar();
    while(!isdigit(ch)){
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while(isdigit(ch)){
        n = n * 10 + ch - '0';
        ch = getchar();
    }
    return f * n;
}
template<typename T>
void write(T n){
    if(n < 0) return putchar('-'), write(-n);
    if(n / 10) write(n / 10);
    putchar(n % 10 + '0');
}
void input() {}
template<typename Type, typename... Types>
void input(Type &arg, Types &...args){
    arg = read<Type>();
    input(args...);
}
namespace Main{
    const int N = 1000005;
    int n, m, s, t, in[N], id[N], cnt;
    ll flow[N];
    vector<int> g[N];
    vector<tuple<int, int, ll>> edges;
    vector<pair<int, ll>> to[N], buc[N];
    void Main(){
        input(n, m, s, t);
        for(int i = 0; i < m; i++){
            int u, v; ll c;
            input(u, v, c);
            g[u].push_back(v);
            edges.emplace_back(u, v, c);
            in[v]++;
        }
        queue<int> q;
        for(int i = 1; i <= n; i++) if(!in[i]) q.push(i);
        while(!q.empty()){
            int u = q.front(); q.pop();
            id[u] = ++cnt;
            for(int v: g[u]){
                in[v]--;
                if(!in[v]) q.push(v);
            }
        }
        for(auto [u, v, c]: edges){
            buc[id[v]].emplace_back(id[u], c);
        }
        for(int i = n; i >= 1; i--){
            for(auto [u, c]: buc[i]) to[u].emplace_back(i, c);
        }
        flow[id[s]] = 1e18;
        for(int i = 1; i <= n; i++){
            if(i == id[t]){
                write(flow[i]);
                return;
            }
            for(auto [v, c]: to[i]){
                if(v > id[t]) continue;
                if(!flow[i]) break;
                ll tmp = min(flow[i], c);
                flow[v] += tmp;
                flow[i] -= tmp;
            }
        }
        return;
    }
} // namespace Main
int main(){
#ifdef Liuxizai
    freopen("in", "r", stdin);
    freopen("out", "w", stdout);
#endif // Liuxizai
    Main::Main();
    return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：0)

一年前用 Dinic 卡过了这道题。今天突然又看到了这道题，~~因为见过了平面图，无向边，多次询问最大流的加强版~~，发现了一个更简单的做法。

### Solution

首先它得是 DAG。我们只保留 $s$ 能到达且能到达 $t$ 的点，可以发现它们的拓扑序确定：若不确定则一定会出现交叉。将这些点按拓扑序重标号，并默认 $s=1,t=n$。

考虑最大流转最小割。现在我们就是要划分为两个集合，割掉在这两个集合之间的所有边，并计算贡献。然后你发现这两个集合画在数轴上是不能交叉的：割完之后 $1$ 能到达右边的点，左边的点能到达 $n$，显然不对。

所以说这两个集合肯定是一段前缀与一段后缀的形式。设前缀是 $[1,i]$，后缀是 $(i,n]$，则我们要割掉覆盖了 $(i,i+1)$ 这条边的所有边。这就是一个区间覆盖的形式，直接差分，复杂度是显然的 $O(n)$。

### Code

瓶颈在于读入与邻接表 /oh

破防了，怎么最优解是 Dinic 啊。

```cpp
constexpr int N=1e6+5;
int n,m,s,t;
struct node{
	int u,v;ll w;
	node(){u=v=w=0;}
	node(int _u,int _v,ll _w){u=_u,v=_v,w=_w;}
};
node e[N<<1];
struct Graph{
	struct edge{int y,pre;}Gr[N<<1];int last[N],Grlen;
	inline void ins(int x,int y){Gr[++Grlen]={y,last[x]},last[x]=Grlen;}
	inline edge& operator [](int i){return Gr[i];}
	inline const edge& operator [](int i)const{return Gr[i];}
};
Graph Gr1,Gr2;
int dfn1[N],dfn2[N],dfc1,dfc2;
bool ck[N];ll sum[N];
void dfs1(int x){ // anti-Topo 
	if(dfn1[x])return;
	for(int k=Gr1.last[x],y;y=Gr1[k].y,k;k=Gr1[k].pre)
		dfs1(y);
	dfn1[x]=++dfc1;
}
void dfs2(int x){
	if(dfn2[x])return;
	for(int k=Gr2.last[x],y;y=Gr2[k].y,k;k=Gr2[k].pre)
		dfs2(y);
	dfn2[x]=++dfc2;
}
int main(){
	read(n,m,s,t);
	for(int i=1;i<=m;i++){
		int u,v;ll w;
		read(u,v,w);
		Gr1.ins(u,v);
		Gr2.ins(v,u);
		e[i]=node(u,v,w);
	}
	dfs1(s),dfs2(t);
	for(int i=1;i<=n;i++)
		ck[i]=dfn1[i]&&dfn2[i];
	for(int i=1;i<=m;i++){
		int u=e[i].u,v=e[i].v;ll w=e[i].w;
		if(ck[u]&&ck[v])
			sum[dfn2[u]]+=w,sum[dfn2[v]]-=w;
	}
	ll ans=numeric_limits<ll>::max();
	for(int i=dfn2[s];i<dfn2[t];i++)
		ans=min(ans,sum[i]+=sum[i-1]);
	writeln(ans);
	return 0;
}
```

---


# [中山市赛 2024] 树上开花

## 题目描述

你有一棵以 1 为根的树，统计点对 $(x, y)$，满足 $a_{lca(x,y)}$ 是 $a_x$ 和 $a_y$ 的公约数。注意当
$x \neq y$ 时 $(x, y)$ 和 $(y, x)$ 视为不同的点对。



## 说明/提示

### 样例解释

以下点对满足条件：$(1, 1)$，$(1, 3)$，$(1, 5)$，$(2, 2)$，$(3, 1)$，$(3, 3)$，$(3, 5)$，$(4, 4)$，$(5, 1)$，$(5, 3)$，$(5, 5)$。

### 数据范围

本题数据分为多个子任务，具体如下：

| 子任务编号 | $n$ | 附加条件 | 子任务分数 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 150$ | 无 | $10$ |
| $2$ | $\leq 1500$ | 无 | $10$ |
| $3$ | $\leq 10^5$ | 树为随机生成 | $10$ |
| $4$ | $=99998$ | $a_i\leq 300$ | $10$ |
| $5$ | $=99998$ | $a$ 为 $1\sim n$ 的排列 | $10$ |
| $6$ | $\leq 10^5$ | 无 | $50$ |


对于所有数据，保证 $1 \leq a_i \leq n$。

## 样例 #1

### 输入

```
5
2 3 2 5 4
1 2
1 3
2 4
2 5```

### 输出

```
11```

# 题解

## 作者：OIer_ljb (赞：2)

发现题目要求的是公因数而不是最大公因数，容易想到枚举公因数 $v$，然后把只考虑 $a_i$ 是 $v$ 的倍数的点。

​		那么我们枚举一个 $a_x=v$ 的点 $x$，相当于统计 $x$ 子树内有多少对点的 LCA 是 $x$，可以用总点对数量减去每个子树内点对数量计算得到，套个树状数组简单维护即可。

​		时间复杂度分析：考虑每个数都会在做自己的所有因数时加入树状数组，所以时间复杂度是 $O(n\text{d}(V)\log n)$， $V$ 是值域，$d(V)$ 最大大概只有一百多并且根本卡不满，外加树状数组小常数随便过的。

​		贴一下赛时代码，码风远古，~~甚至手写排序，还不会用 vector~~。

```C++
#include<cstdio>
#include<cstring>
#define ri register int
#define ll long long
#define fo(i,a,b) for(ri i=(a);i<=(b);++i)
const int N=1e5+5;
int a[N],rk[N],a2[N],rk2[N],dfn[N],end[N],x,y,n,cnt,fa[N];
int tot,nt[N<<1],to[N<<1],fi[N];
int Tot,Nt[N<<1],To[N<<1],Fi[N];
ll ans;
inline void add(int x,int y){++tot;nt[tot]=fi[x];to[tot]=y;fi[x]=tot;}
inline void link(int x,int y){++Tot;Nt[Tot]=Fi[x];To[Tot]=y;Fi[x]=Tot;}
int t[N];
inline int lb(int x){return x&-x;}
inline void modify(int x,int v){while(x<=n)t[x]+=v,x+=lb(x);} 
inline int query(int x){int s=0;while(x)s+=t[x],x-=lb(x);return s;} 
void dfs(int x)
{
	++cnt;dfn[x]=end[x]=cnt;
	for(ri i=fi[x];i;i=nt[i])
	{
		ri y=to[i];
		if(dfn[y]==-1)fa[y]=x,dfs(y),end[x]=end[y];
	}
}
void so(int l,int r)
{
	if(l==r)return ;
	int mid=l+r>>1;
	so(l,mid);so(mid+1,r);
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)
	{
		if(a[i]<a[j])a2[k]=a[i],rk2[k]=rk[i],++k,++i;
		else a2[k]=a[j],rk2[k]=rk[j],++k,++j;
	}
	while(i<=mid)a2[k]=a[i],rk2[k]=rk[i],++k,++i;
	while(j<=r)a2[k]=a[j],rk2[k]=rk[j],++k,++j;
	fo(i,l,r)a[i]=a2[i],rk[i]=rk2[i];
} 
int main()
{
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
	scanf("%d",&n);
	fo(i,1,n)scanf("%d",&a[i]),dfn[i]=-1,rk[i]=i;
	for(ri i=1;i<n;++i)scanf("%d%d",&x,&y),add(x,y),add(y,x);
	dfs(1);so(1,n);
	fo(i,1,n)link(a[i],dfn[rk[i]]);
	fo(i,1,n)
	{
		if(a[i]!=a[i-1])
		{
			if(a[i-1])
			{
				for(ri j=a[i-1];j<=n;j+=a[i-1])
					for(ri k=Fi[j];k;k=Nt[k])modify(To[k],-1);	
			}
			for(ri j=a[i];j<=n;j+=a[i])
				for(ri k=Fi[j];k;k=Nt[k])modify(To[k],1);
		}
		ri st=dfn[rk[i]],ed=end[rk[i]];
		ri s=query(ed)-query(st-1);
		ans+=(ll)s*s;
		for(ri j=fi[rk[i]];j;j=nt[j])
		{
			ri y=to[j];
			if(y!=fa[rk[i]])
			{
				ri ss=query(end[y])-query(dfn[y]-1);
				ans-=(ll)ss*ss;
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xiaofu15191 (赞：1)

赛时过了这道题（T6）结果 $100+10+20+55+20+100=305$ 极限一等了。

首先考虑把前 20 分的 subtask 给混到手。这里我用的是树剖，后来发现树剖时就预处理了 dfs 序、子树大小等信息。

接着考虑对于每个因子 $j$，有哪些 $a_i$ 是 $j$ 的倍数。用 $sum_j$ 从小到大存储这些 $dfn_i$，方便之后对字数的查找。

然后来统计题目所要求的点对。枚举点对定义中的 $i=\operatorname{lca}(x,y)$。二分查找 $sum_{a_i}$ 中有多少个点位于以 $i$ 为根的子树中。

定义 $b_i$ 表示以 $i$ 为根的子树中有多少个点 $j$ 的 $a_j$ 含有因子 $a_i$。

定义 $c_{i,j}$ 表示在以 $i$ 为根的子树中，以 $j$ 为根的子树节点对 $b_i$ 的贡献。

对于每个 $i$，枚举其儿子节点 $j$，此时对答案的贡献为 $c_{i,j} \times (b_i-c_{i,j}-1) \times 2$。注意对于每个 $i$，答案要减去 $1$，即点对 $(i,i)$ 的贡献。

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#include<map>
using namespace std;
int n,a[100010],dep[100010],fa[100010],son[100010],siz[100010],top[100010],b[100010],dfn[100010],cnt,rep[100010];
vector<int>graph[100010],sum[100010];
map<int,int>c[100010];
void dfs1(int now,int father)
{
	dep[now]=dep[father]+1;
	fa[now]=father;
	siz[now]=1;
	for(auto to:graph[now])
	{
		if(to==father) continue;
		dfs1(to,now);
		siz[now]+=siz[to];
		if(siz[son[now]]<siz[to]) son[now]=to;
	}
}
void dfs2(int now,int root)
{
	dfn[now]=++cnt;
	rep[cnt]=now;
	top[now]=root;
	if(son[now]) dfs2(son[now],root);
	for(auto to:graph[now])
	{
		if(to==fa[now]||to==son[now]) continue;
		dfs2(to,to);
	}
}
int lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) return x;
	else return y;
}
void dfs3(int now)
{
	b[now]=1;
	for(auto to:graph[now])
	{
		if(to==fa[now]) continue;
		dfs3(to);
		auto tmp1=lower_bound(sum[a[now]].begin(),sum[a[now]].end(),dfn[to]);
		if(tmp1==sum[a[now]].begin()) continue;
		auto tmp2=upper_bound(sum[a[now]].begin(),sum[a[now]].end(),dfn[to]+siz[to]-1);
		b[now]+=tmp2-tmp1;
		c[now][to]=tmp2-tmp1;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		graph[x].push_back(y);
		graph[y].push_back(x);
	}
	dfs1(1,0);
	dfs2(1,1);
	if(n<=1500)
	{
		long long ans=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
			{
				int tmp=lca(i,j);
				if(a[i]%a[tmp]==0&&a[j]%a[tmp]==0)
					ans++;
			}
		printf("%lld\n",ans);
		return 0;
	}
	long long ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j*j<=a[rep[i]];j++)
		{
			if(j*j==a[rep[i]])
			{
				sum[j].push_back(i);
				break;
			}
			if(a[rep[i]]%j==0)
			{
				sum[j].push_back(i);
				sum[a[rep[i]]/j].push_back(i);
			}
		}
	}
	dfs3(1);
	for(int i=1;i<=n;i++)
	{
		for(auto to:graph[i])
		{
			auto tmp=c[i][to];
			ans+=tmp*(b[i]-tmp-1);
		}
		ans+=b[i]*2-1;
	}
	printf("%lld\n",ans);
}
```

---

## 作者：Sliarae (赞：1)

记 $\text{lca}(u, v)$ 表示 $u$ 和 $v$ 的最近公共祖先，$\text{son}(u)$ 表示 $u$ 的儿子集合，$\text{subtree}(u)$ 表示 $u$ 子树中所有点的集合。

首先转化一下题意，即求 

$$\sum\limits_{i = 1}^{n}\sum\limits_{y = 1}^{n} [a_{\text{lca}(u, v)} \mid a_u \wedge a_{\text{lca}(u, v)} \mid a_v]$$

考虑枚举 $w = \text{lca}(u, v)$，此时 $u$ 和 $v$ 可以在 $w$ 的子树中独立选取，但可能出现 $\text{lca}(u, v) \neq w$ 的情况。

我们做一个容斥，用 $u, v$ 在 $w$ 子树中任意独立选取的方案数，减去钦定 $w$ 的一个儿子 $t$，让 $u, v$ 在 $t$ 子树中独立选取的方案数，形式化地，答案为

$$

\sum\limits_{w = 1}^{n} \Bigg[ \bigg( \sum\limits_{u \in \text{subtree}(w)} [a_w \mid a_u] \bigg)^2 - \sum\limits_{t \in \text{son}(w)} \bigg( \sum\limits_{u \in \text{subtree}(t))} [a_w \mid a_u] \bigg)^2 \Bigg]

$$

于是问题可以转化为，$O(n)$ 次询问，每次给出 $u, x$，求 $u$ 子树内权值为 $x$ 的倍数的点的个数。

考虑倒着算，枚举一个点 $v$，再枚举 $x \mid a_v$，将点 $v$ 挂在 $x$ 上。最后离线算答案，对于给出的 $x$，可以产生贡献的 $v$ 已经预处理好了。此时问题相当于插入删除关键点，数 $u$ 子树内的关键点数。可以用 dfs 序 + 树状数组解决。

设 $d(n)$ 表示 $n$ 的约束个数，$D(n) = \max\limits_{i = 1}^{n} d(i)$，该算法的时间复杂度为 $O(n D(n) \log n)$。由于 $D(10^5) = d(83160) = 128$，并且常数较小，可以通过。

```cpp
#include <iostream>
#include <vector>

using namespace std;
using LL = long long;

const int kN = 1e5 + 5;

int n, tot;
int a[kN], fa[kN];
int in[kN], out[kN], now;
vector<int> e[kN], p[kN], tag[kN];

LL Square (int x) { return 1ll * x * x; }

void Dfs (int u) {
	in[u] = ++now;
	for (auto v : e[u]) {
		if (v == fa[u]) continue;
		fa[v] = u, Dfs(v);
	}
	out[u] = now;
}

struct Fenwick {
	int c[kN];

	void Add (int x, int y) {
		for (; x <= n; x += (x & -x))
			c[x] += y;
	}

	int Query (int l, int r) {
		int res = 0;
		for (--l; l; l -= (l & -l))
			res -= c[l];
		for (; r; r -= (r & -r))
			res += c[r];
		return res;
	}
} tr;

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n;
	for (int i = 1; i <= n; ++i) 
		cin >> a[i], p[a[i]].push_back(i);
	for (int i = 1, u, v; i < n; ++i) {
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	Dfs(1);
	for (int u = 1; u <= n; ++u) {
		for (int i = 1; i * i <= a[u]; ++i) {
			if (!(a[u] % i)) {
				tag[i].push_back(u);
				if (i * i != a[u]) tag[a[u] / i].push_back(u);
			}
		}
	}
	LL ans = 0; 
	for (int d = 1; d <= n; ++d) {
		for (auto i : tag[d]) tr.Add(in[i], 1);
		for (auto u : p[d]) {
			ans += Square(tr.Query(in[u], out[u]));
			for (auto v : e[u]) {
				if (v == fa[u]) continue;
				ans -= Square(tr.Query(in[v], out[v]));
			}
		}
		for (auto i : tag[d]) tr.Add(in[i], -1);
	}
	cout << ans << '\n';
	return 0; 
}
```

---

## 作者：Rnfmabj (赞：0)

一个相对无脑的做法，树上启发式合并。早几个月过的时候题解区还没几篇题解，就想着后面有人补充就行，没想到现在还没有这个做法，于是简单写一下。

注意到题目的要求是一个对点统计子树内点对的形式，那么一个比化式子算贡献更直观的想法是开桶大力统计。具体地，对因数开桶，统计当前被计入过贡献的点里有多少个点是这个因数的倍数，然后后续暴力扫描当前点子树的时候，扫到的点是子树根的倍数即可直接让答案累加上子树根对应桶的计数器。

这样就是很裸的支持树上启发式合并的形式了，预处理所有点的因数集合后，正常增删贡献正常统计即可，时间复杂度和其他题解一样，是 $O(nd(n)\log n)$ 的。常数也不大。

键盘直连大脑，码力代替思考。


```cpp
//空中散歩の SOS 僕ファー　僕ファー　僕ファー ~
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
typedef long long ll;
typedef double db;
const ll maxn=1e5+5;
vector<ll>e[maxn];
ll a[maxn];
vector<ll>lst[maxn];
ll siz[maxn];
ll sn[maxn];
ll t[maxn];
void init(ll x,ll fa){
	siz[x]=1;
	for(auto v:e[x]){
		if(v==fa)continue;
		init(v,x);
		siz[x]+=siz[v];
		if(siz[v]>siz[sn[x]])sn[x]=v;
	}
}
void clr(ll x,ll fa){
	for(auto it:lst[a[x]]){
		t[it]=0;
	}
	for(auto v:e[x]){
		if(v==fa)continue;
		clr(v,x);
	}
}
ll ans=0;
void calc(ll x,ll fa,ll tar){
	if(a[x]%tar==0)ans+=t[tar]*2;
	for(auto v:e[x]){
		if(v==fa)continue;
		calc(v,x,tar);
	}
}
void ins(ll x,ll fa){
	for(auto it:lst[a[x]]){
		t[it]++;
	}
	for(auto v:e[x]){
		if(v==fa)continue;
		ins(v,x);
	}
}
void work(ll x,ll fa){
	for(auto v:e[x]){
		if(v==fa||v==sn[x])continue;
		work(v,x);
		clr(v,x);
	}
	if(sn[x])work(sn[x],x);
	for(auto v:e[x]){
		if(v==fa||v==sn[x])continue;
		calc(v,x,a[x]);
		ins(v,x);
	}
	ans+=2*t[a[x]];
	for(auto it:lst[a[x]]){
		t[it]++;
	}
	return ;
}
ll n;
void solve(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>a[i];
		if(!lst[a[i]].size()){
			for(ll j=1;j<=sqrt(a[i]);j++){
				if(a[i]%j)continue;
				lst[a[i]].push_back(j);
				if(a[i]/j!=j)lst[a[i]].push_back(a[i]/j);
			}
		}
	}
	for(ll i=1;i<n;i++){
		ll x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	init(1,0);
	work(1,0);
	cout<<ans+n<<endl;
	return ;
}
ll T=1;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
//	cin>>T;
	for(ll kase=1;kase<=T;kase++){
		solve();
	}
	return 0;
}
```

注意了零处常数优化。

---


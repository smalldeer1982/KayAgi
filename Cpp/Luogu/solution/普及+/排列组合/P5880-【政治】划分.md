# 【政治】划分

## 题目背景

小蒟建立了一个城市，$\texttt{TA}$ 凭借优（cu）异（bi）的政治素养，管理着城市并进行规划。

## 题目描述

对于一座新建的城市，可以将其视为一片连通的区域。

现在，小蒟需要建造一些道路，将城市分为若干片互不连通的区域。

首先，小蒟要建造 $a_1$ 条主干道。主干道是一条贯通整个城市的直线。

接着，小蒟要建造 $a_2$ 个环岛。环岛是一条首尾相接的圆形道路。

然后，小蒟要建造一些道路网络。这些道路网络包括 $a_3$ 条正三角形道路（即三条道路连成一个封闭的三角形），$a_4$ 条正四边形道路……$a_n$ 条正 $n$ 边形道路。

小蒟希望用这些道路将城市划分为尽可能多片互不连通区域。可是他不会计算最多能划分成为多少个区域，所以他只能来求助你。

由于最后的答案可能很大很大，你只需要输出答案对 $10^9+7$ 取模的值。

## 说明/提示

#### 样例解释#1

如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ntmr3tgn.png)

#### 数据范围

对于 $20\%$ 的数据：$1\le n \le 10^3$，$0 \le a_i \le 100$。

对于 $100\%$ 的数据：$1\le n \le 3 \times 10^6$，$0 \le a_i \le 10^3$。

**注意内存限制，你的 UKE 很有可能就是 MLE**。

**若 $n=1$ 则只存在直线道路，若 $n=2$ 则只存在直线道路和圆形道路。**

## 样例 #1

### 输入

```
4
1 1 1 1
```

### 输出

```
28```

## 样例 #2

### 输入

```
3
1 2 3
```

### 输出

```
68```

# 题解

## 作者：Warriors_Cat (赞：10)

~~楼下那个官方题解也是可以……~~

这才是**官方题解**!

题目大意：

给你$a_1$条直线，$a_2$个圆，$a_3$个正三边形，$a_4$个正四边形，$a_5$个正五边形......$a_n$个正n边形，问这些图形最多能把一个平面分成多少块。

首先，我们看一下只有直线的情况：

> 直线数：$1\quad2\quad3\quad4\quad5$

> 平面数：$2\quad4\quad7\quad11\quad16\quad$

发现没有？如果有$a_1$条直线，那么就可以分割成$\large\frac{a_1*(a_1+1)}{2}+1$个区间。

于是代码如下：

```cpp
if(i == 1){
    ans = 1 + a * (a + 1) / 2;
    sum += a * 2;//sum1以后会有用 
    ans %= mod;//注意要mod 
}
```


那么，直线搞定后，我们再来康康圆。

如果刚开始没有直线，那么$a_2$个圆可以分割成$2+a_2*(a_2-1)$个区间。

为什么？

下面来证明一下：

易知一个圆时可以分成2个部分，那此时多加一个圆，这个圆跟刚开始的那一个圆会有2个交点，那么它就会把原来的圆分成2个部分。分成2个部分后，它就会多分割出两个平面，于是就变成了四个平面。

同理，3个，4个直到$a_2$个也是如此。

我们可以列一个表格来康康：

圆的总共个数：$1\quad2\quad3\quad4\quad$

新增交点个数：$0\quad2\quad4\quad6$

新增段数个数：$0\quad2\quad4\quad6$

新增块数个数：$0\quad2\quad4\quad6$

平面总共块数：$2\quad4\quad8\quad14$

那么，加上直线怎么做呢？

同样，一条直线和一个圆最多会有两个交点，于是一条直线和一个圆可以多分成两块，于是$ans$还要加上$a_1*a_2*2$。但此时第一个圆会与直线有交点，所以最终只需要每两个圆进行处理即可，于是又要加上$C^2_{a_2}*2=a_2*(a_2-1)$

于是第二部分的代码就出现啦QAQ

```cpp
else if(i == 2){
    ans += sum * a;//sum的用处就在这 
    if(!sum) ans = 2 + a * (a - 1);//没有直线的情况 
    else ans += a * (a - 1);//有直线的情况 
    b = a;//b是圆的个数，以后也会有用 
    ans %= mod;
}
```

那么，按照这个思路，正$n$边形的就好打了。

一个正$n$边形与一条直线有2个交点，与一个圆有$2n$个交点，与一个正$3$边形有$6$个交点，……与一个正$n-1$边形有$2(n-1)$个交点。

那么，$ans$就要加上$sum*a_n+b*a*i*2$

其中$sum=2*a_1+6*a_3+8*a_4+...+2*(n-1)*a_{n-1}$，$b$就是圆的个数。

还有这$a_n$个正$n$边形两两之间有$2n$个交点，于是$ans$还要加上$C^2_{a_n}*2*n=a_n*(a_n-1)*n$

于是第三部分的代码就大功告成啦~

```cpp
else{
    ans += sum * a + b * a * i * 2;//与前面图形的块数 
    if(!sum && !b) ans = 2 + a * (a - 1) * i;//还是要特判QAQ 
    else ans += a * (a - 1) * i;//两两之间的块数 
    sum += i * a * 2;//sum要加上去 
    ans %= mod;
}
```

综合以上三段代码，这道题就结束啦~~

$CODE:$

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define int long long
const int mod = 1e9 + 7;
int n, a, sum, ans, b;
signed main(){
    scanf("%lld", &n);
    for(int i = 1; i <= n; ++i){
        scanf("%lld", &a);
        if(!a) continue;//没有就直接continue掉 
        if(i == 1){
    		ans = 1 + a * (a + 1) / 2;
   		 	sum += a * 2;//sum1以后会有用 
    		ans %= mod;//注意要mod 
		}
		else if(i == 2){
    		ans += sum * a;//sum的用处就在这 
    		if(!sum) ans = 2 + a * (a - 1);//没有直线的情况 
    		else ans += a * (a - 1);//有直线的情况 
    		b = a;//b是圆的个数，以后也会有用 
    		ans %= mod;
		}
        else{
    		ans += sum * a + b * a * i * 2;//与前面图形的块数 
    		if(!sum && !b) ans = 2 + a * (a - 1) * i;//还是要特判QAQ 
    		else ans += a * (a - 1) * i;//两两之间的块数 
    		sum += i * a * 2;//sum要加上去 
    		ans %= mod;
		}
    }
    printf("%lld", ans == 0 ? 1 : ans);//最后的特判QAQ 
    return 0;
}
```

这道题不算难，主要考察大家的思维能力，代码也很短，为了考验大家就限制了空间。

## End

---

## 作者：2021CHD (赞：9)

## 前言

**这篇题解有完整的构造方案及证明，位于参考实现之后。**

## 题目大意

有 $n$ 种图形。第一种图形是直线，有 $a_1$ 条。第二种图形是圆，有 $a_2$ 个。第 $x(x\ge3)$ 种图形是正 $x$ 边形，有 $a_x$ 个。

将所有的图形全部画到一个平面内，求这个平面最多被划分为多少个面积非零的部分，答案对 $10^9+7$ 取模。

- $1\le n\le3\times10^6$，$\textbf{\color{red}0}\le a_i\le10^3$。
- $1\texttt{s}$，$4.88\texttt{MB}$。

## 解决方式

先友情赠送一张样例二的解释。

![样例二解释](https://cdn.luogu.com.cn/upload/image_hosting/jtkfanun.png)

然后观察这是怎么画出来的。

首先两个图形不能完全重合，这是废话。

仔细观察，如果正多边形的边之间或者正多边形的边与直线之间存在重合的情况，那一定是不优的。

![线不能重合](https://cdn.luogu.com.cn/upload/image_hosting/u85obr6n.png)

不难发现，如果两个图形间只有至多一个交点（两条直线除外）或者两条直线相互平行，也是不优的。

![不能相切](https://cdn.luogu.com.cn/upload/image_hosting/ryiz3v2r.png)

而且三个（或以上）图形共点的情况也是不优的。（移动其中一个图形会使区域数增加）

![不能三线共点](https://cdn.luogu.com.cn/upload/image_hosting/tquoi8yr.png)

在上面的条件限制下，如果新加入的一个**封闭图形**（圆或正多边形）与原有的图形交点个数为 $x(x>0)$，那么这个封闭图形被 $x$ 个交点分割成的 $x$ 个部分各会把原本存在的一个区域切成两份，所以**交点数就等于新增区域数**，但有一种**特殊情况**：如果平面上原本什么都没有，加入一个封闭图形可以在不产生交点的前提下将原本完整的平面切成两部分（内部和外部）。

![交点与区域数](https://cdn.luogu.com.cn/upload/image_hosting/4ubom4eh.png)

例如上图中加粗的圆，它与其他图形相交形成了 $6$ 个交点，这 $6$ 个交点间夹了 $6$ 段弧，每段弧都将原本存在的一个区域切成了两半。（比如 $5$ 号弧将原本位于外部的无限大的区域切成了两半）

如果新加入的一条直线与原有的直线交点个数为 $x$，那么这条直线被 $x$ 个交点分割成的 $x+1$ 个部分各会把原本存在的一个区域切成两份，由于直线不是封闭图形，所以要**先单独考虑直线**，否则可能会存在直线的两段一起将一个区域（第一次加入直线时最外侧的无限大的那个区域，前提是平面中已有封闭图形）切成两半的情况导致计数错误。

容易发现，直线与直线之间最多只有一个交点，直线和圆之间最多有两个交点。由于正多边形是凸多边形，所以直线和正多边形之间最多也只有两个交点。

圆和正 $x$ 边形之间最多有几个交点呢？由于正 $x$ 边形由 $x$ 条线段组成，每条线段都最多与圆有两个交点，所以圆和正 $x$ 边形之间最多有 $2x$ 个交点。具体的，画一个以正多边形的中心为圆心，半径比正多边形的外接圆小、比正多边形的内切圆大的一个圆就可以取到 $2x$ 个交点的上界。

正 $x$ 边形和正 $y$ 边形 $(x\le y)$ 之间最多有几个交点呢？

同样地，由于正 $x$ 边形由 $x$ 条线段组成，每条线段都最多与正 $y$ 边形有两个交点，所以正 $x$ 边形和正 $y$ 边形之间最多也有 $2x$ 个交点。具体的，共用外切圆且不共用顶点的正 $x$ 边形和正 $y$ 边形之间就可以取到 $2x$ 个交点的上界。

下面这张图展示了上面所说的画法看起来的效果。

![最多交点数](https://cdn.luogu.com.cn/upload/image_hosting/bvpai8bc.png)

最后，由于这些图形是**任意**画的，所以我们认为可以在满足上面的条件（没有线段重叠以及三个图形共点）的前提下使得两两图形间的交点个数都取到最大值。

那么最后需要注意的几个点就是：

- 答案要对 $10^9+7$ 取模，别忘了，也别忘了开 `long long`。
- $a_i$ 可能为 $0$，别忘了处理没有直线甚至什么都没有的情况。
- 空间限制不够把输入存下，要边输入边处理，具体地，可以记录一个前缀和 $x$ 表示前面的图形（除了圆）一共会给每个新增的图形提供几个交点，再记录圆的数量就好了。
- $n$ 可能等于 $1$ 或者 $2$。

时间复杂度：$O(n)$。

空间复杂度：$O(1)$。

## 参考实现

这是我的 [AC 记录](https://www.luogu.com.cn/record/199762683)。

下面贴上了我自己写的代码。

```c++
#include<cstdio>
using namespace std;
const long long mod=1000000007;
long long n,ans=1,cnt,i,a,w,bj; 
main()
{
	scanf("%lld",&n);
	scanf("%lld",&a);
	ans=ans+a*(a+1)/2;
	cnt=cnt+2*a;
	if(a>0)
	bj=1;
	if(n>1)
	{
		scanf("%lld",&w);
		ans=ans+w*cnt+w*(w-1);
		if(bj==0&&w>0)
		{
			ans++;
			bj=1;
		}
	}
	if(n>2)
	{
		for(i=3;i<=n;i++)
		{
			scanf("%lld",&a);
			ans=(ans+a*cnt+a*w*i*2+a*(a-1)*i)%mod;
			cnt=(cnt+a*i*2)%mod;
			if(bj==0&&a>0)
			{
				ans=(ans+1)%mod;
				bj=1;
			}
		}
	}
	printf("%lld",ans);
}
```

那么这道题到这里就……

$\large\textbf{要正式开始做了！}$

友情提示：下面这写部分完全不看也丝毫不会影响你 AC 这道题。

## 构造方案

是的，这道题现有的六篇题解都没有考虑的一个问题就是：**为什么图形两两之间交点数量一定可以全部取到上界？**

虽然不论从直觉上还是从概率上讲，这样的方案**几乎**一定会存在，但是还是没有说明这样的方案一定存在。

接下来的部分将给出并证明一种画图的方式使得**图形两两之间交点数量全部都取到上界**。

由于正多边形最难画，那么首先就应该考虑如何画出两两之间交点数量全部都取到上界的任意的正多边形。

首先，再次思考怎样画才能使两个正多边形之间的交点数取到最大值。

除了共用外接圆不共用顶点的方式，还有**共用内切圆不共用切点**的方式，容易说明这样的交点数是取到最大值的。

所以只要让所有正多边形**共用内切圆**并且**不共用切点**就可以使所有正多边形两两交点数达到最大，像这样。

![共用内切圆](https://cdn.luogu.com.cn/upload/image_hosting/xalwht8k.png)

那为什么不会有三个正多边形交于一点呢？

考虑交点处，如果有三个正多边形以不同的角度交于一点，由于所有的正多边形共用内切圆，所以过这个点可以做出三条圆的切线（就是三个正多边形的边所在的直线），显然由于过圆外一点只能作两条圆的切线，所以这是不可能的。

那么只要把圆和直线以某种方式补上就可以完成构造了。

**那么接下来就是完整的构造方案。**

以下用弧度制表示角。

假设要求在平面上画 $a$ 条直线，$b$ 个圆，$c$ 个不超过 $d$ 条边的正多边形，要保证 $b>0$ 且 $c>0$，具体地，第 $i(1\le i\le c)$ 个正多边形是正 $s_i(3\le s_i\le d)$ 边形（序列 $s$ 单调不递减，且 $s_c=d$），要使交点数尽可能多。

如果不需要画正多边形，那么将 $c$ 视为 $1$，将 $d$ 视为 $3$，再将 $s$ 视为 $(3)$，最后再将多画的正三角形擦掉即可。同理，如果不需要画圆，那么将 $b$ 视为 $1$，最后再将多画的圆擦掉即可。

首先在平面上建立平面直角坐标系，然后过原点画出半径为 $1$ 的圆。（这些是辅助线）

接下来在第一象限的圆上取 $c$ 个点使得第 $i(1\le i\le c)$ 个点与原点的连线与 $y$ 轴间所夹锐角为 $\frac{i}{cd^2}$，然后以每个点作为切点分别作一个圆外切正多边形，具体地，以第 $i$ 个点作为切点的正多边形是正 $s_i$ 边形。

接下来画出 $b$ 个圆，每个圆的半径均为 $1+\frac{1}{20c^2d^4}$，第 $i(1\le i\le b)$ 个圆的圆心坐标是 $(\frac{i-1}{40bc^2d^4},0)$。

最后如果 $a>0$，画出 $a$ 条直线，第 $i(1\le i\le a)$ 条直线的解析式为 $y=bc^2d^410^{i+2}x+\frac{a-i}{2a}$。

最后将辅助线（平面直角坐标系的坐标轴、以原点为圆心，半径为 $1$ 的圆以及可能存在的多画的正三角形和圆）擦掉就画完了。

下面是两个样例画出来的效果。

样例一：$a=1$，$b=1$，$c=2$，$d=4$，$s=(3,4)$。

![样例一](https://cdn.luogu.com.cn/upload/image_hosting/lxzgo1s6.png)

样例二：$a=1$，$b=2$，$c=3$，$d=3$，$s=(3,3,3)$。

![样例二](https://cdn.luogu.com.cn/upload/image_hosting/ozf3tdq3.png)

什么，你说你看不到两个圆？这两个圆半径相同，圆心只相距 $\frac{1}{29160}$，肯定是看不清的……

## 证明

关于上面这种做法，我有一个绝妙的证明，由于这里位置很大，所以我可以把它完整地写在这里。

首先是正多边形之间的夹角。

为什么夹角要是 $\frac{1}{cd^2}$ 呢？

首先夹角最大的是第一个和最后一个多边形，夹角小于 $\frac{1}{d^2}$，我将说明这个夹角是充分小的。

首先我们假想一种情况：所有正多边形与单位圆的切点都是 $(0,1)$，那么画出图应该是这样的：（图上画了正 $3$ 到 $1000$ 边形）

![共切点的多边形](https://cdn.luogu.com.cn/upload/image_hosting/s1m47uxs.png)

此时我们考察这些多边形与单位圆的切点在哪些地方。

容易发现正 $m$ 边形与单位圆的切点一共有 $m$ 个，有一个位于 $(0,1)$，所有的 $m$ 个切点将单位圆 $m$ 等分，也就是说，如果从圆心向这 $m$ 个切点连接射线，那这些射线与 $y$ 轴正半轴所夹的角就会是 $\frac{2\pi i}{m}(0\le i<m)$。

那么如果考虑所有的正 $3\sim d$ 边形与圆的切点，从圆心向这些切点连接射线，那这些射线与 $y$ 轴正半轴所夹的角就会是 $\frac{2\pi n}{m}(0\le n<m\le d,m\ge3)$。这些夹角中除去完全相同的，两两之间的差值不会小于 $\frac{2\pi}{d-1}-\frac{2\pi}{d}=\frac{2\pi}{d^2-d}>2\times\frac{1}{d^2}$，所以上面所说的 $\frac{1}{d^2}$ 的夹角显然是**充分小**的，旋转这个角度不会让任何一个正多边形的切点转过另一个正多边形的另一个切点，甚至不会转过一半的间距。

那么就可以说明这些正多边形与圆的**切点一定不会重叠**，因为原本重叠的切点被正多边形间的夹角岔开了一个角度，而且由于岔开的角度充分小，所以任何原本不重叠的两个切点在旋转后不会重叠，也就是说，这些正多边形画得一定是对的。

你可能已经发现了，没有一个正多边形的偏移是零，也就是说，这样做可以在原本的每个切点附近留出一个至少 $\pm \frac{1}{cd^2}$ 的空位，没有任何正多边形与单位圆的切点会位于这些空位处，圆和直线的画法正是靠这些空位才能成立的。

首先 $(0,1)$ 处一定是一个原本的切点，$(0,-1)$ 处在 $d>3$ 时也一定是一个原本的切点（注意我们不仅考虑真正要画的正多边形，还考虑其他边数在 $3\sim d$ 之间的正多边形），由于原本的切点附近会有一个空位，所以 $(0,1)$ 和 $(0,-1)$ 附近一定不会有正多边形的切点。（显然当 $d=3$ 时 $(0,-1)$ 附近也不会有正多边形的切点）

那么只要将圆的交点放到 $(0,1)$ 和 $(0,-1)$ 附近就没有问题。现在问题就是圆的半径要设多大，圆心要放在哪里，一个自然的想法就是圆心放在原点附近，半径比 $1$ 略大一点。

那么就要考察半径要比 $1$ 大多少，如果大得太多，可能就会有经过两个多边形的交点的可能性，于是考虑将所有多边形的交点都放到圆外。

最接近原点的哪些多边形的交点肯定都是单位圆相邻的切点引出的切线的交点，由于上面说明 $\frac{1}{d^2}$ 是充分小的，所以相邻两个切点与原点的连线之间的夹角不会小于 $\frac{1}{cd^2}$。

那么半径要画多大呢？请看下面这张图下面是我将样例二绘制得到的图片在 $(0.075,1)$ 附近放大的结果。

![样例二放大](https://cdn.luogu.com.cn/upload/image_hosting/j9l7gp7z.png)

在这幅图上可以清晰（？）地看到蓝色的线是紫色的圆的**割线**，但是蓝色的线与红色和绿色的线的交点都在紫色的圆外。

在这幅图上画上一些辅助线就可以帮助我们的计算。

![样例二加辅助线](https://cdn.luogu.com.cn/upload/image_hosting/sorbxmm8.png)

现在上面画上了一个橙色散点围成的单位圆和黑色虚线围成的直角三角形（三个顶点分别为原点、蓝线和红线的交点以及蓝线和单位圆的切点，原点在画面外），容易得知图上这个直角三角形较小的锐角（顶点是原点）的大小是 $\frac{1}{2cd^2}$，对边（画面中完整展示的边）长为 $\tan(\frac{1}{2cd^2})>\frac{1}{2cd^2}$，斜边（画面中靠左的边）长为 $\sqrt{1^2+\tan^2(\frac{1}{2cd^2})}>\sqrt{1^2+(\frac{1}{2cd^2})^2}=\sqrt{1+\frac{1}{4c^2d^4}}>\sqrt{1+\frac{1}{5c^2d^4}+\frac{1}{100c^4d^8}}=1+\frac{1}{10c^2d^4}>1+1.5\times\frac{1}{20c^2d^4}$，考虑到 $cd^2\ge9$，上述推导应该是没有问题的。这也说明了 $\frac{1}{20c^2d^4}$ 是**充分小**的，圆的半径取到 $1+\frac{1}{20c^2d^4}$ 可以使得每个圆内都一定没有多边形的交点。

由于有多个圆，所以第一个圆的圆心位于原点处，后面每个圆的圆心向右移动 $\frac{1}{40bc^2d^4}$，所以最右边的圆与第一个圆之间的偏移量小于 $0.5\times\frac{1}{20c^2d^4}$，也就是说，最右边的圆仍与最左边的边保持有两个交点，而不包含位于最右边的正多边形的交点。

圆与圆的交点都位于 $(0,1)$ 和 $(0,-1)$ 附近（距离小于 $\frac{1}{20bc^2d^4}$），并且这附近不存在多边形之间的交点，甚至不存在多边形的边（因为 $\frac{1}{20bc^2d^4}$ 是**充分小**的并且在 $(0,1)$ 和 $(0,-1)$ 附近不存在正多边形于单位圆的切点），所以圆和圆之间的交点不可能在正多边形上。

由于所有圆的半径相同，圆心位于同一直线上，假设有三圆交于一点，则该点与直线上的三个点距离都相同，这是不可能的（因为直线和圆最多只有两个交点），然后又由于这些圆之间明显两两相交（$0<\frac{1}{40bc^2d^4}$ 且 $\frac{1}{40c^2d^4}<1+\frac{1}{20c^2d^4}$），所以这些圆画得一定是对的。

最后就是直线了（如果直线存在的话），可以考虑利用 $(0,1)$ 和 $(0,-1)$ 附近的空位画出一些斜率超大的直线，但是还要保证正多边形的交点不会离 $y$ 轴太近，可以参考上面给出的那个画了很多圆外切正多边形的图。

考虑 $y$ 轴的正半轴，显然只有所有正多边形最上面的一条边会经过 $y$ 轴正半轴，而这些边的交点又全部位于第一象限，离 $y$ 轴距离至少为 $\frac{1}{2d^2}<\sin(\frac{1}{d^2})$（考虑到 $d^2$ 至少为 $9$），所以 $y$ 轴的正半轴附近 $\frac{1}{2d^2}$ 范围内是没有正多边形的交点的。

再考虑 $y$ 轴的负半轴。发现如果 $x$ 是偶数，那么正 $x$ 边形也只有最下面一条边会经过 $y$ 轴负半轴，情况和正半轴类似，不再过多探讨。

如果 $x$ 是奇数，那么正 $x$ 边形有一个顶点位于最下方，那么对于一个固定的奇数 $x$，就应该会在正 $x$ 边形最下方的顶点附近存在交点，但是和 $y$ 轴的距离至少为 $\frac{1}{4d^2}<\sin(\frac{1}{2d^2})$（同样考虑到 $d^2$ 至少为 $9$）。由于正多边形旋转的角度 $\frac{1}{d^2}$ 是**充分小**的，而且在旋转之前在 $y=-1$ 这条直线以下的部分本来就是没有任何交点的，所以不存在某个奇数 $x_1$ 与另一个奇数 $x_2$ 使得在旋转之后正 $x_1$ 边形与正 $x_2$ 边形在下方产生了新的交点。（旋转前不存在交点就是因为对于奇数 $x$，$x$ 越大，正 $x$ 边形最靠下的与单位圆的切点就越靠下，同时内角也越大，旋转后交点间的相对顺序没有发生改变，所以结论仍成立）

所以就是要考虑对于奇数 $x_1$ 和偶数 $x_2$，正 $x_1$ 边形和正 $x_2$ 边形最靠下的交点的位置，然而这种情况其实不用考虑，因为正 $x_1$ 边形最下方的顶点附近的交点一定比正 $x_1$ 边形和正 $x_2$ 边形最靠下的交点更接近 $y$ 轴，（对于正 $x_1$ 边形最下面的一部分（最下面的顶点连接的两条边）而言，基本上越靠下越接近 $y$ 轴，只有在 $y$ 坐标相差不多（$\frac{1}{x_1d^2}$ 级别）的时候才可能会有反例，而正 $x_1$ 边形与正正 $x_2$ 边形最靠下的交点的 $y$ 坐标最多也只比 $-1$ 小一点点，正 $x_1$ 边形最靠下的顶点的 $y$ 坐标则是比 $-1$ 小得多（偏移量远大于 $\frac{1}{x_1d^2}$））所以正多边形之间的交点离 $y$ 轴的距离不会小于 $\frac{1}{4d^2}$，并且 $y$ 坐标的范围显然在 $\pm2$ 内，但在 $\pm1$ 外。

由于圆与多边形的交点离 $y$ 轴的距离也不会小于 $\frac{1}{4d^2}$，所以只用考察圆与圆之间的交点，显然圆与圆之间的交点离 $y$ 轴的距离不会小于 $\frac{1}{80bc^2d^4}$，所以直线的斜率只要足够大就可以完全避免与上面这些交点相碰，这里斜率最小的直线的斜率取到了 $1000bc^2d^4$，是**充分大**的。

现在只要让直线与直线之间的交点全部位于单位圆内且不存在三线共点就大功告成了。

于是令直线与 $y$ 轴的交点的纵坐标在 $[0,\frac{1}{2})$ 的范围内，直线解析式的常数项 $\frac{a-i}{2a}$ 可以保证这一点。

而相邻两条直线的斜率相差 $10$ 倍，而且越往下斜率越大，可以保证第 $i$ 条直线与第 $j$ 条直线 $(1<i<j\le a)$ 的交点位于第 $i-1$ 条直线与 $y$ 轴的交点下方，且第 $1$ 条直线与第 $i(i>1)$ 条直线的交点位于圆内。

具体地，只需求出第 $i$ 条直线与第 $i+1$ 条直线的交点纵坐标即可。联立 $y=bc^2d^410^{i+2}x+\frac{a-i}{2a}$ 与 $y=bc^2d^410^{i+3}x+\frac{a-i-1}{2a}$ 即可解得 $y=\frac{a-i}{2a}+\frac{1}{18a}<\frac{a-i+1}{2a}<1$，则上述说法成立。

综上，这种方案在不产生重叠以及三个图形共点的前提下，直线、圆及正多边形两两之间的交点数均取到最大值，则这题的**结论成立**。

$\Box$

## 后记

一不小心就写了 $9k+$，能看到这里也是真不容易。如果有什么疏漏的话可以在评论区指出，如果可以的话，我会在第一时间改正。

也不知道有没有人看完了呢？如果真的有，那一定是真正对这门学科怀着热爱的人吧。

不过，不论从直觉上还是从概率上讲，这样的人几乎**一定**会存在。

最后一点空白就留给你们自己探索吧：

$$
\textbf{\color{white}今后也要继续加油哦。（笑）}
$$

---

## 作者：BFqwq (赞：3)

# 政治
这是我第一次参加比赛的验题，结果wa了好久好久qaq

（最后发现爆int了）
## 思路
很明显，这题是一个排列组合。

首先，我们先来考虑全是直线的情况：


每一条与所有的直线都产生交点，故对于第 $k$ 条直线，会被分为 $k$ 段。

每一段都会增加一个块，再加上最开始的那个块，于是总和就是：
$$ans=a_1\times(a_1+1)/2+1$$
接着，我们来考虑圆。

其实做法是一样的：每多一段弧，答案就会加一。

而每个圆与另外的直线都会产生两个交点，于是交点的个数就是 $a_2 \times a_1 \times 2$。

另外，圆与圆之间也有交点。任意两个圆之间一共有两个交点。

所以圆之间的交点个数就是 $\binom{a_2}{2}\times 2$，化简得到 $a_2 \times (a_2-1)$。

因此我们列出的式子是：

$$ans+=a_2\times a_1\times 2+a_2\times (a_2-1)$$

最后，我们再来考虑当 $3 \le k$ 时的情况。

同样的，与其他的图形相交，每多一段就多一块。

与直线相交：$a_1\times a_i \times 2$ 个，因为与每条直线各有 $2$ 个交点；

与圆相交：$a_2 \times a_i \times i\times 2$个，因为与每个圆各有 $2\times i$ 个；

与第 $j$ 种图形相交：$a_j \times a_i \times j \times 2$个，因为 $j$ 边形可以拆成 $j$ 个线段；

与第 $i$ 种图形相交：$\binom{a_i}{2}\times 2 \times i$，因为两个 $i$ 边形可产生 $i\times 2$ 个交点。

所以，最终的式子就是：

$$ans+=a_i \times (a_1\times 2+a_2\times i \times 2+\sum(a_j\times j \times 2)(j < i)+(a_i-1)\times i)$$

另外，对于圆或是多边形的情况，若是在此之前还没有划分过，那么第一个该形状会将原来的 $1$ 个形状变成 $2$ 个形状，所以 $ans$ 还需加 $2$。

那么，这道题就这么结束啦！

## code
```cpp
#include<bits/stdc++.h>
#define qwq while(1) puts("qwq");
using namespace std;
inline long long read(){
	register long long x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
long long n,k;
long long sum;
__int128 ans;
const int p=1e9+7;
void write(__int128 x){
	if(x/10)
		write(x/10);
	putchar(x%10+48);
}
int main(void){
	n=read();
	k=read(); 
	ans=1+(k+1)*k/2;
    sum+=k*2;
    ans%=p;
    if(n==1){
    	write(ans);
    	return 0;
	}
	k=read();
	if(!sum) ans=k*k-k+2;
	else ans+=k*sum+k*(k-1);
	ans%=p;
	if(n==2){
		write(ans);
		return 0;
	}
	for(int i=3;i<=n;i++){
		long long c=read();
		if(!sum && !k)ans=c*(c-1)*i+2;
		else ans+=c*(c-1)*i+sum*c+k*c*i*2;
		ans%=p;
		sum+=c*i*2;	
	}
	write(ans);
	return 0;
    	qwq
}
```
因为我前面爆int了，于是怒转__int128qaq（其实long long完全能过qaq）



















---

## 作者：bluewindde (赞：2)

### 题意

有 $a_1$ 条直线，$a_2$ 个圆，$a_n$ 个正 $n$ 边形（$n>2$），问最多可以把一个平面分割为几部分。

### 思路

$1\le n\le3\times10^6$，一眼有规律。

$a_1$ 条直线，$a_2$ 个圆，一眼要特殊处理。

所以本题可以分为以下 $3$ 类。

**1. 直线**

数学题从找规律开始，假设只有直线。

当 $a_1=1$ 时，最多可以分为 $1$ 部分。

当 $a_1=2$ 时，最多可以分为 $4$ 部分。

如图，当 $a_1=3$ 时，最多可以分为 $7$ 部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/h5verd47.png)

如图，当 $a_1=4$ 时，最多可以分为 $11$ 部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/cocdhmr3.png)

如图，当 $a_1=5$ 时，最多可以分为 $16$ 部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/i8dwdj3r.png)

最开始有 $1$ 部分。对于第 $i$ 条直线，一定会与前 $i-1$ 条直线各形成一个交点，也就是将前 $i-1$ 条直线所分出的部分数量乘 $2$。运用神奇的求和公式，直线的总贡献为 $\frac{a_1\times(a_1+1)}{2}+1$。

**2. 圆**

假设只有圆。

当 $a_2=1$ 时，最多可以分为 $2$ 部分。

当 $a_2=2$ 时，最多可以分为 $4$ 部分。

如图，当 $a_2=3$ 时，最多可以分为 $8$ 部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/4tx9i6a2.png)

如图，当 $a_2=4$ 时，最多可以分为 $14$ 部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/p163zutr.png)

1. 任意两个圆之间会产生两个交点，所以圆之间的贡献为 $C_{a_2}^{2}\times2=a_2\times(a_2-1)$。

2. 再考虑直线，每个圆与任意一条直线之间会产生两个交点，所以圆与直线的贡献为 $2\times a_1\times a_2$。

因此，圆这部分的总贡献为 $a_2\times(2\times a_1+a_2-1)$。

**3. 正 $n$ 边形**

任意两个正 $n$ 边形之间会产生 $2\times n$ 的贡献。

如图，以正三角形为例（可能画得不是很正，请见谅）。

![](https://cdn.luogu.com.cn/upload/image_hosting/bdist3hs.png)

一个正 $n$ 边形与一条直线会产生 $2$ 的贡献，因为它们只会产生最多两个交点。

一个正 $n$ 边形与一个圆会产生 $2\times n$ 的贡献，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/anlmqc8p.png)

任意两个正 $i$ 边形和正 $j$ 边形之间（$j<i$）会产生 $2\times j$ 的贡献，因为正 $i$ 边形可以与正 $j$ 边形的每一条边产生 $2$ 个交点，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/av3rz562.png)

所以，正 $i$ 边形这部分的总贡献为 $a_i\times(a_i-1)\times i+2\times a_i\times(a_1+a_2\times i)+a_i\times(\sum\limits_{3\le j<i}2\times a_j\times j)$。

### 代码

```cpp
// 什么题目 4.88MB 内存限制?
#include <iostream>
#define int long long
using namespace std;

const int mod=1e9+7;

int n,x,a1,a2,an;
int ans=0;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;++i) {
        cin>>x;
        if(i==1) {
            a1=x;
            ans+=((x+1)*x/2+1)%mod;
            ans%=mod;
        }
        else if(i==2) {
            a2=x;
            ans+=x*(2*a1+x-1)%mod;
            ans%=mod;
        }
        else {
            ans+=(x)*(x-1)*i%mod+2*x*(a1+a2*i)%mod+x*an;
            ans%=mod;
            an+=x*i*2;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：daniEl_lElE (赞：2)

蒟蒻绿题只会写数学题！

这题是一道比较典型的数学。

观察：假设现在已经有一部分图形了，现在再放入一个图形，交叉几次就可以出现几个新区域。

首先看 $i=1$ 时的情况，这是有名的披萨问题，首先先放置一条线，会分成 $2$ 部分。然后放第 $j$ 条时会增加 $j$ 部分。所以 $i=1$ 时会产生 $a_i×(a_i+1)÷2+1$ 。

然后看 $i=2$ 时，首先每个圆可以交叉每一条线 $2$ 次，所以圆与线之间会产生 $a_1×a_2×2$ 部分。两个圆之间最多交两次，所以圆与圆之间总共会产生 $a_2×(a_2-1)$ 部分。

最后看 $i=3$ ~ $n$ ,一个 $i$ 边形和一个 $j$ 变形会交叉 $min(i,j)×2(j≠2)$ ，所以加起来即可。

注意前缀和优化，因为当 $j<a$ 时会交叉 $j×2$ 次，所以可以进行前缀和。

算法复杂度 $O(n)$ 。

我的代码很慢，因为没有读入优化。在此提醒各位**十年OI一场空，不加快读见祖宗**，加快读是个好习惯~~可惜我没有~~。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
signed main(){
	//freopen("","r",stdin);
	//freopen("","w",stdout);
	int n;
	cin>>n;
	int a[4];
	int sum=0,qzh=0;
	for(int i=1;i<=n;i++){
		cin>>a[2];
		if(i==1){
			sum+=(a[2]*(a[2]+1)/2+1);
			sum%=mod;
			qzh+=a[2]*2;
			qzh%=mod;
			a[1]=a[2];
		}
		else if(i==2){
			sum+=a[2]*(a[2]-1);
			sum%=mod;
			sum+=a[1]*a[2]*2;
			sum%=mod;
			a[3]=a[2];
		} 
		else{
			sum+=qzh*a[2];
			sum%=mod;
			sum+=((a[2]*i*a[3]*2)%mod);
			sum%=mod;
			sum+=(a[2]*(a[2]-1)*i);
			sum%=mod;
			qzh+=a[2]*i*2;
			qzh%=mod;			
		}
	}
	cout<<sum;
	return 0;
}
```


---

## 作者：RoamingDuck (赞：0)

## 题意简述

平面上有 $a_i$ 个 $i$ 边形（$1$ 边形为直线，$2$ 边形为圆），现在这些图形最多能将整个平面分为多少块？

## 思路

### 直线

考虑直线情况。

可以发现交点多所以分割的平面块数多，又发现对于平面上已有的几个直线，一定存在一种方式，使得新加入的直线交于所有已知的直线，且使得交点数量最多，也就是使得平面块数最多。

因此对于直线的情况，得到在有 $n$ 个直线时，平面会被分成 $\frac{a_i\times (a_i+1)}{2}+1$ 个块。

### 圆

考虑圆的情况。

一个圆可以把平面分成 $2$ 个块。

接下来一个新的圆可以与原来的一个圆形成 $2$ 个交点，并多分割出 $2$ 个部分。然后新来的一个圆就可以与每个原有的圆形成 $2$ 个交点。那么新增的交点个数就是原来的圆的个数乘 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/g49la010.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/jc1cp4qk.png)

发现新增几个交点就会新增几个块。

因此现有块数为原有块数加上新增交点数量。

那么 $a_2$ 个圆最多可以将平面分割成 $a_2\times (a_2-1)+2$ 个块。

别忘了还有 $a_1$ 个直线。

直线也不难。在 $a_2$ 个圆与 $1$ 个直线相交时，会产生 $2\times a_2$ 个交点。同理与 $a_1$ 个直线相交时，会产生 $2\times a_1\times a_2$ 个交点，也就是被分成了 $2\times a_1\times a_2$ 个块。

因此答案就是 $a_2\times a_1\times 2+a_2\times (a_2-1)$ 个块。

### 多边形

最后考虑多边形的情况。

对于一个 $i$ 多边形与之前的图形相交，除了与一个圆又 $2\times a_i$ 个交点，对于一个 $j$ 边形有 $2\times j$ 个交点。

因此对于 $a_i$ 个多边形，$a_j$ 个多边形，就会有 $2\times a_i\times a_j\times j$，特殊考虑一下圆的情况即可。

因为题目条件不允许我们使用数组存储每个多边形的数量，因此我们可以使用一个变量去累加每次对应在计算答案里需要用到的数值即可。

### 坑点

1. 注意开 `long long`
2. 答案至少为 $1$，因为一个空的平面也是一个块。

### 代码


```cpp
#include <iostream>
#define int long long
const int MOD = 1e9 + 7;
int n, x, cir, res, S;
signed main () {
  std::cin.tie ( 0 ) -> sync_with_stdio ( false );
  std::cin >> n;
  for ( int i = 1; i <= n; i ++ ) {
    std::cin >> x;
    if ( x == 0 ) continue;
    if ( i == 1 ) {
      res = x * ( x + 1 ) / 2 + 1;
      res %= MOD;
      S += x * 2;
    } else if ( i == 2 ) {
      res += S * x;
      res %= MOD;
      if ( S == 0 ) res = 2 + x * ( x - 1 );
      else res += x * ( x - 1 );
      res %= MOD;
      cir = x;
    } else {
      res += S * x + cir * x * i * 2;
      res %= MOD;
      if ( S == 0 && cir == 0 ) res = 2 + x * ( x - 1 ) * i;
      else res += x * ( x - 1 ) * i;
      res %= MOD;
      S += 2 * i * x;
    }
  }
  if ( res == 0 ) res = 1;
  std::cout << res << '\n';
  return 0;
}
```

---

## 作者：A_grasser (赞：0)

## 题意简化

有 $a_1$ 条直线，$a_2$ 个圆，$a_3$ 个三角形，$a_4$ 个正方形……$a_n$ 个正 $n$ 边形，求出这些图形最多能将平面划分成多少块。

## 需要注意的地方

1. 运算开 `long long`。

1. 内存很小，不能开数组。

## 解法分析

尽量把这道题目讲明白吧。分三种情况考虑。

### 直线

![](https://cdn.luogu.com.cn/upload/image_hosting/np5dpync.png)

往下继续推就能得出，$a_1$ 条直线会产生 $a_{1}-1$ 条直线所分出的块数的两倍，也就得出规律：分出 $\frac{a_1 \times (a_1+1)}{2}+1$ 块。

---

### 圆

由于前面已经有了直线，所以每个圆分两种情况考虑：

- 圆与直线相交

![](https://cdn.luogu.com.cn/upload/image_hosting/ftlgzu9h.png)

不难发现，一条圆与一条直线相交会有两个交点，将原先圆所划分的两份**多出** $2 \times a_1 \times a_2$ 块，所以这部分多出 $2 \times a_1 \times a_2$ 块。

- 圆与圆相交

![](https://cdn.luogu.com.cn/upload/image_hosting/58jepwak.png)

从中看出，圆与圆相交会有两个交点，将原先圆所划分的两份**多出** $a_2 \times (a_2-1)$ 块，所以这部分多出 $a_2 \times (a_2-1)$ 块。

---

### 多边形

分四种情况考虑。

- 多边形与直线相交

![](https://cdn.luogu.com.cn/upload/image_hosting/fpm7luwt.png)

显然，它只会产生 $2$ 个交点，跟上面圆的公式类似，所以这部分多出 $2 \times a_1 \times a_i$ 块。

- 多边形与圆相交

![](https://cdn.luogu.com.cn/upload/image_hosting/ekxnjrwu.png)

不难看出，多边形每条边都会与圆会产生 $2$ 个交点，所以这部分多出 $2 \times i \times a_2 \times a_i$ 块。

- 多边形与自己（同样的多边形）相交

![](https://cdn.luogu.com.cn/upload/image_hosting/z141b6w2.png)

这也是每条边会产生 $2$ 个交点，所以这部分多出 $i \times a_i \times (a_i-1)$ 块。

- 多边形与之前的多边形相交

![](https://cdn.luogu.com.cn/upload/image_hosting/csb01hk6.png)

还是每条边会产生 $2$ 个交点，所以这部分多出 $2 \times j \times a_j \times a_i$ 块。

但是，由于内存足够小，所以我们用 $x$ 存放累积的 $j \times a_j$，这样就能前缀和了。

---

上面的做完，整道题也就讲透了。

最后说一句，我比较推荐万能头文件，这样可以省去很多不必要的麻烦。

## 完整代码

```cpp
//已通过
#include<bits/stdc++.h>
//万能头文件
using namespace std;
long long n,i,ans,a,b,x;
int main(){
    cin>>n;
    for(int t=1;t<=n;t++){
    	cin>>i;
    	if(t==1){//直线 
    		a=i;
    		ans+=i*(i+1)/2+1;
			ans%=1000000007;
		}
		else if(t==2){//圆 
            b=i;
            ans+=i*a*2+i*(i-1)%1000000007;
            ans%=1000000007;
        }
		else{//多边形 
        	ans+=i*a*2+i*b*t*2+i*(i-1)/2*t*2+x*i*2;
        	x+=i*t%1000000007;
        	ans%=1000000007;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5880)

这题给[我](https://www.luogu.com.cn/user/1015780)绕晕了……

感谢我伟大的教练 [$\color{#E67E22}\texttt{清平乐}$](https://www.luogu.com.cn/user/224358) [![](https://cdn.luogu.com.cn/upload/image_hosting/ady09f6s.png)](https://www.luogu.com.cn/discuss/142324) 教会了我这道题。

~~因为作者刚学会这道题，所以写的比较口糊，读者见谅。~~

我认为这应该是所有题解里面最通俗易懂的一篇了……

> $\texttt{upd 2024.1.25}$ 教练 [$\color{#E74C3C}\texttt{illumina15}$](https://www.luogu.com.cn/user/943589) 又给我改了些笔误。

## 题意

在一个平面内，有 $a_{1}$ 条直线，$a_{2}$ 个圆，$a_{3}$ 个三角形，$a_{4}$ 个正方形，……，$a_{n}$ 个正 $n$ 边形。现让你求出这些图形最多能将平面划分成多少块。

## 思路

本题是一道经典的排列组合。

### 0

在正式讲解思路之前，我先说两个结论：

- 结论 $1$：如果两个图形产生了 $n$ 个焦点（两个图形都是直线的情况除外），平面就会多出 $n$ 个块。

- 结论 $2$：设这两个多边形的边数分别是 $i$ 和 $j$，这两个图形相交就会形成 $2\times \min(i,j)$ 个焦点（两条直线或两个圆相交的情况除外，这里设圆有无数条边）。

大家一定要记住这两个结论，后面会用到。

### 1

首先考虑全是直线的情况。

我们可以先通过找规律分析：

- $1$ 条直线

![](https://cdn.luogu.com.cn/upload/image_hosting/no575z35.png)

划分出了 $2$ 个平面；

- $2$ 条直线

![](https://cdn.luogu.com.cn/upload/image_hosting/wavblbem.png)

划分出了 $4$ 个平面；

- $3$ 条直线

![](https://cdn.luogu.com.cn/upload/image_hosting/gcfhdtnx.png)

划分出了 $7$ 个平面；

- $4$ 条直线

![](https://cdn.luogu.com.cn/upload/image_hosting/eksqxj9p.png)

划分出了 $11$ 个平面；

……

不难发现，这 $a_{1}$ 条直线可以将平面划分成 $\frac{a_{1}\times (a_{1}+1)}{2}+1$ 个平面。

给出代码：

```cpp
if(i==1){
	line=x;
	ans+=x*(x+1)/2+1;
	ans%=mod;
}
```

### 2

接下来考虑平面内有圆的情况。

根据结论 $1$，我们可以直接求图形之间的交点数，减少计算的复杂度。

这里分两种情况讨论：

- 圆和直线相交：

根据结论 $2$，可得每条直线和每个圆会产生 $2$ 个焦点，而这些直线和圆总共会产生 $a_{2}\times a_{1}$ 种排列组合。所以这部分的答案是 $2\times a_{1}\times a_{2}$。

- 圆和圆相交：

画图可知，两个圆之间会产生 $2$ 个焦点：

![](https://cdn.luogu.com.cn/upload/image_hosting/oqzt95al.png)

分析即可看出这些圆总共会产生 $(a_{2}-1)+(a_{2}-2)+\ldots +1=\frac{a_{2}\times (a_{2}-1)}{2}$ 种排列组合。这部分答案为 $\frac{a_{2}\times (a_{2}-1)}{2}\times 2=a_{2}\times (a_{2}-1)$。

给出代码：

```
else if(i==2){
	circ=x;
	ans+=x*line*2+x*(x-1)%mod;//圆和直线+圆和圆
	ans%=mod;
}
```

### 3

最后考虑有多边形的情况。

分以下 $4$ 种情况讨论：

- 与直线相交：

和上面圆的情况类似，答案是 $2\times a_{1}\times a_{2}$。

- 与圆相交：

根据结论 $2$，可得第 $i$ 种多边形会与圆产生 $2 \times i$ 个焦点，共有 $a_{2}\times a_{i}$ 种排列组合，答案是 $2\times i\times a_{i}\times a_{2}$。

- 和前面的图形相交：

和上面第 $2$ 种情况类似，答案是 $2\times j\times a_{j}\times a_{i}$。

这里有坑。因为空间只有 4.88 MB，如果直接拿数组记录每种多边形的数量就会 MLE，所以我们可以设置一个变量存放 $\sum_{i=1}^{i-1}j\times a_{j}$。

这部分答案为 $2\times a_{i}\sum_{i=1}^{i-1}j\times a_{j}=2\times a_{i}\times x$。

$x$ 代表那个很玄学的变量。

- 自己和自己相交：

和上面圆的情况类似，这部分答案为 $\frac{a_{i}\times (a_{i}-1)}{2}\times 2\times i=i\times a_{i}\times (a_{i}-1)$。

给出代码：

```cpp
else{
	ans+=x*line*2+x*circ*i*2+x*(x-1)/2*i*2+ccf*x*2;
	ccf+=x*i%mod;
	ans%=mod;
}
```

自此，所有情况分析完毕！

## 注意事项

- 开 `long long`；

- 取模 $10^{9}+7$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define kkksc03 sb
#define int long long
const int mod=1e9+7;
signed main(){
	ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n,x,ans=0,line,circ,ccf=0;
    cin>>n;
    for(int i=1;i<=n;++i){
    	cin>>x;
    	if(i==1){
    		line=x;
    		ans+=x*(x+1)/2+1;
			ans%=mod;
		}else if(i==2){
            circ=x;
            ans+=x*line*2+x*(x-1)%mod;
            ans%=mod;
        }else{
        	ans+=x*line*2+x*circ*i*2+x*(x-1)/2*i*2+ccf*x*2;
        	ccf+=x*i%mod;
        	ans%=mod;
		}
	}cout<<ans<<endl;
	return 0;
}
```

---


# 奇数码问题

## 题目描述

你一定玩过八数码游戏，它实际上是在一个 $3 \times 3$ 的网格中进行的，$1$ 个空格和 $1 \sim 8$ 这 $8$ 个数字恰好不重不漏地分布在这 $3 \times 3$ 的网格中。

例如：

    5 2 8
    1 3 _
    4 6 7
    

在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。

例如在上例中，空格可与左、上、下面的数字交换，分别变成：

    5 2 8       5 2 _      5 2 8
    1 _ 3       1 3 8      1 3 7
    4 6 7       4 6 7      4 6 _
    

奇数码游戏是它的一个扩展，在一个 $n \times n$ 的网格中进行，其中 $n$ 为奇数，$1$ 个空格和 $1 \sim n^2-1$ 这 $n^2-1$ 个数恰好不重不漏地分布在 $n \times n$ 的网格中。

空格移动的规则与八数码游戏相同，实际上，八数码就是一个 $n=3$ 的奇数码游戏。

现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。

## 说明/提示

$1 \le n < 500$

## 样例 #1

### 输入

```
3
1 2 3
0 4 6
7 5 8
1 2 3
4 5 6
7 8 0
1
0
0```

### 输出

```
TAK
TAK```

# 题解

## 作者：Drifty (赞：13)

### Hint

考虑把这个 $n\times n$ 的矩阵按行拆开，再计算逆序对（跟逆序对有什么关联？）。

### Solution

先给结论。

- 考虑把这两个 $n\times n$ 的矩阵按行拆成长度为 $n^2-1$ 的序列（忽略空格），则我们会发现，两个状态能够相互转换当且仅当两个序列的逆序对个数奇偶性相同。

**为什么？**

- 考虑左右移动：
  ```
  5 2 8       5 2 8
  1 _ 3       1 3 _
  4 6 7       4 6 7
  ```
  我们发现，交换前序列为 $\{5,2,8,1,3,4,6,7\}$，而交换后也为 $\{5,2,8,1,3,4,6,7\}$。因此左右移动对逆序对个数没有影响。

- 考虑上下移动：
  ```
  5 2 8       5 _ 8
  1 _ 3       1 2 3
  4 6 7       4 6 7
  ```
  我们发现，交换前序列为 $\{5,2,8,1,3,4,6,7\}$，而交换后也为 $\{5,8,1,2,3,4,6,7\}$。因此上下移动相当于把改变的那个数移动了 $n-1$ 位，因此原来与那个数形成的所有逆序对都变为了非逆序对，而原来与那个数形成的所有非逆序对都变为了逆序对。
  
  我们进一步观察：
  
  - 若在交换的数中有奇数个逆序对，则由于 $n-1$ 为偶数，因此剩下奇数个非逆序对，按照上面的原则，则奇数个逆序对变为非逆序对，奇数个非逆序对变为逆序对，因此逆序对个数还是奇数。
  
  - 若在交换的数中有偶数个逆序对，则由于 $n-1$ 为偶数，因此剩下偶数个非逆序对，按照上面的原则，则偶数个逆序对变为非逆序对，偶数个非逆序对变为逆序对，因此逆序对个数还是偶数。
  
由此，就得出了结论：无论如何改变，展开后序列的逆序对数的**奇偶性永远不变**。

**用归并排序求逆序对，再判定奇偶性是否相同即可。**

### AC-Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
constexpr int N = 500*500+100;
int temp[N];
ll msort(int l, int r, int *a) {
	if (l>=r) return 0;
	int mid = l+r>>1, k=0;
	ll res = msort(l, mid, a)+msort(mid+1, r, a);
	int i = l, j = mid+1;
	while (i<=mid && j<=r)
		if (a[i]<=a[j]) temp[k++] = a[i++];
		else temp[k++] = a[j++], res += (mid-i+1);
	while (i<=mid) temp[k++] = a[i++];
	while (j<=r) temp[k++] = a[j++];
	for (i=l, j=0; i<=r; i++, j++) a[i] = temp[j];
	return res;
}
int st[N], en[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL); 
	for (int n; cin >> n;) {
		n*=n;
		for(int i=1, x, f=0; i<=n&&cin>>x; i++, f|=(!x)) st[i-f] = x;
		for(int i=1, x, f=0; i<=n&&cin>>x; i++, f|=(!x)) en[i-f] = x;
		ll u = msort(1, n - 1, st);
		ll v = msort(1, n - 1, en);
		if((u&1)==(v&1)) cout << "TAK\n";
		else cout << "NIE\n";
	}
	return 0;
}
```

---

## 作者：mxjz666 (赞：5)

奇数码问题两个局面可达，当且仅当两个局面下网格中的数依次排成一行 $n^2 - 1$ 个元素的序列后（不考虑空格），逆序对个数的奇偶性相同。

### 该结论的必要性很容易证明：
空格左右移动时，形成的序列显然不变。

空格上下移动时，相当于某个数跟它的前（后）$n-1$ 个数交换位置。

因为 $n-1$ 是偶数，所以逆序对的变化也是偶数。

-------------
所以可以用归并排序来求逆序对。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510*510;
int a[N],b[N],t[N];
long long cnta,cntb;
void msort(int a[],int l,int r,long long &cnt) {
	if(l>=r){
		return;
	}
	int mid=(l+r)/2;
	msort(a,l,mid,cnt);
	msort(a,mid+1,r,cnt);
	int i=l,j=mid+1,k=0;
	while(i<=mid&&j<=r){
		if(a[i]<=a[j]){
			t[k++]=a[i++];
		}else{
			t[k++]=a[j++];
			cnt+=mid-i+1;
		}
	}
	while(i<=mid){
		t[k++]=a[i++];
	}
	while(j<=r){
		t[k++]=a[j++];
	}
	for(int i=l;i<=r;i++){
		a[i]=t[i-l];
	}
}
int main(){
	int n;
	while(cin>>n){
		n*=n;
		for(int i=1,j=1;i<=n;i++){
			int x;
			scanf("%d",&x);
			if(x!=0){
				a[j++]=x;
			}
		}
		for(int i=1,j=1;i<=n;i++){
			int x;
			scanf("%d",&x);
			if(x!=0){
				b[j++]=x;
			}
		}
		cnta=0;
		cntb=0;
		msort(a,1,n-1,cnta);
		msort(b,1,n-1,cntb);
		if((cntb%2)==(cnta%2)){
			cout<<"TAK\n";
		}else{
			cout<<"NIE\n";
		}
	}
	return 0;
}
```

---

## 作者：frzFRZ (赞：4)

# 题目意思
给你一个初始矩阵和一个目标矩阵。

其中的 `0` 可以与其四联通的块交换位置。  

通过若干次操作，判断是否能从初始矩阵变为目标矩阵。


---

# 解题思路
## 思路一
看了一下题面一下子就想起了题目 [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379)，  
那题用了几乎与本体相同,于是就有了下面的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
string t;
queue<string> q;
unordered_map<string,int> m;
int fx[]={1,-1,0,0};
int fy[]={0,0,1,-1};
int n;
int main()
{
	while(scanf("%d",&n)!=EOF)
	{
		int flot=0;
		m.clear();
		while(!q.empty()) q.pop();
		string send,s;
		for(int i=1;i<=n*n;i++)
		{
			int c;
			cin>>c;
			send+=c+'0';
		}
		for(int i=1;i<=n*n;i++)
		{
			int c;
			cin>>c;
			s+=c+'0';
		}
		q.push(s);
		m[s]=0;
		while(!q.empty())
		{
			t=q.front();
			q.pop();
			if(t==send)
			{
				flot=1;
				cout<<"TAK"<<endl;
				break;
			}
			int dis=m[t];
			int k=t.find('0');
			int x=k/n;
			int y=k%n;
			for(int i=0;i<4;i++)
			{
				int xx=x+fx[i];
				int yy=y+fy[i];
				if(xx<0||xx>n||yy<0||yy>n) continue;
				string tt=t;
				swap(tt[k],tt[xx*n+yy]);
				if(!m.count(tt))
				{
					m[tt]=dis+1;
					q.push(tt);
				}
			}
		}
		if(flot==0) cout<<"NIE"<<endl;
	}
	return 0;
}
```

当你兴致勃勃的把它交上去了之后，你就可以拿到 MLE 的好成绩。

[提交记录](https://www.luogu.com.cn/record/172645333)  
这说明这种方法行不通，我们只能另寻他方。


---


## 思路二 
我们可以从逆序对的角度去考虑。  
我们先考虑左右移动。  
假设矩阵为：

```cpp
5 2 8
1 - 3
4 6 7
```
那么把它转为字符串为 `52813467`  
将—左右移动之后为：  

```cpp
5 2 8  5 2 8
1 3 -  - 1 3
4 6 7  4 6 7
```

发现字符串还是为 `52813467`  
_逆序对的数量不变_。  
我们再考虑上下移动，  
那么原序列就变成了：

```cpp
5 2 8  5 - 8
1 6 3  1 2 3
4 - 7  4 6 7
```
因此上下移动相当于把改变的那个数移动了 n − 1 位，因此原来与那个数形成的所有逆序对都变为了非逆序对，而原来与那个数形成的所有非逆序对都变为了逆序对。  
因为 n 为奇数，所以不会改变：
_逆序对的奇偶性_  


---


综上所述：无论如何改变序列，它逆序对的奇偶性永远不会变!!! 
所以我们只需要判断初始序列与目标序列的逆序对的奇偶性是否相同即可，如果相同输出 TAK ，否则输出 NIE 。


---

### 代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[250010],t[250010],ans1=0,ans2,b[250010];
void msort1(int l,int r) //归并排序求逆序对
{
	if(l==r) return ;
	long long mid=(l+r)>>1;
	msort1(l,mid);
	msort1(mid+1,r);
	long long i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)
	{
		if(a[i]<=a[j]) t[k++]=a[i++];
		else
		{
			ans1+=mid-i+1;
			t[k++]=a[j++];
		}
	}
	while(i<=mid) t[k++]=a[i++];
	while(j<=r) t[k++]=a[j++];
	for(int i=l;i<=r;i++) a[i]=t[i];
}
void msort2(int l,int r)
{
	if(l==r) return ;
	long long mid=(l+r)>>1;
	msort2(l,mid);
	msort2(mid+1,r);
	long long i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)
	{
		if(b[i]<=b[j]) t[k++]=b[i++];
		else
		{
			ans2+=mid-i+1;
			t[k++]=b[j++];
		}
	}
	while(i<=mid) t[k++]=b[i++];
	while(j<=r) t[k++]=b[j++];
	for(int i=l;i<=r;i++) b[i]=t[i];
}
int main()
{
	while(scanf("%d",&n)!=EOF)
	{
		int x;
		if(n==1)
		{
			cin>>x;
			cin>>x;
			cout<<"TAK"<<endl;
			continue;
		}
		ans1=ans2=0;
		int len=0;
		for(int i=1;i<=n*n;i++) 
		{
			cin>>x;
			if(x!=0) a[++len]=x;
		}
		msort1(1,n*n-1);
		len=0;
		for(int i=1;i<=n*n;i++)
		{
			cin>>x;
			if(x!=0) b[++len]=x;
		}
		msort2(1,n*n-1);
		if((ans1%2)==(ans2%2)) cout<<"TAK"<<endl;
		else cout<<"NIE"<<endl;
	}
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/172650706)

---

## 作者：a18981826590 (赞：2)

# [P10454 奇数码问题](https://www.luogu.com.cn/problem/P10454)
## 解题思路
### 结论：

**两个局面可以相互转化，当且仅当将这个网格（除 $0$ 外）按顺序连接起来得到的长度为 $n^{2}-1$ 的序列的逆序对个数的奇偶性相同。**

### 证明：

题目中共有 $2$ 种操作：
  1. 左右移动：在序列中相当于没动，序列中逆序对的数量不变；
  2. 上下移动：相当于在序列中移动了 $n-1$ 个位置；若向上移动，则相当于在序列中向前移动了 $n-1$ 个位置，这 $n-1$ 个位置每有一个位置小于移动的数，逆序对的数量就会增加 $1$，每有一个位置大于移动的数，逆序对的数量就会减少 $1$；若向下移动，则相当于在序列中向后移动了 $n-1$ 个位置，这 $n-1$ 个位置每有一个位置大于移动的数，逆序对的数量就会增加 $1$，每有一个位置小于移动的数，逆序对的数量就会减少 $1$。因为 $n$ 为奇数，所以 $n-1$ 为偶数，所以每次操作增加和减少的逆序对的数量的差为偶数，所以每次操作改变的逆序对的数量为偶数。

综上所述，每次操作不会改变序列的逆序对的数量的奇偶性。所以两个局面可以相互转化，当且仅当将这个网格（除 $0$ 外）按顺序连接起来得到的长度为 $n^{2}-1$ 的序列的逆序对个数的奇偶性相同。

我们可以利用归并排序求出序列的逆序对的数量，建议参考 [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[250010],b[250010],c[250010],d[250010],e,f,n;
long long int g,h;
void z(long long int &w,int x,int y,int *o,int *p){
	int i=x,j=(x+y>>1)+1,k=0;
	if(x>=y) return;
	z(w,x,j-1,o,p);
	z(w,j,y,o,p);
	while(i<=x+y>>1&&j<=y){
		if(o[i]<=o[j]){
			p[k]=o[i];
			i++;
		}
		else if(o[i]>o[j]){
			p[k]=o[j];
			j++;
			w+=(x+y)/2-i+1;
		}
		k++;
	}
	w+=((x+y>>1)-i+1)*(y-j+1);
	if(i<=x+y>>1){
		for(int l=i;l<=x+y>>1;l++){
			p[k]=o[l];
			k++;
		}
	}
	else if(j<=y){
		for(int l=j;l<=y;l++){
			p[k]=o[l];
			k++;
		}
	}
	for(int l=0;l<k;l++) o[x+l]=p[l];
}
int main(){
	ios::sync_with_stdio(0);
	while(cin>>n){
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(c,0,sizeof(c));
		memset(d,0,sizeof(d));
		f=0;
		n*=n;
		for(int i=0;i<n;i++){
			cin>>e;
			if(e>0) a[f++]=e;
		}
		f=0;
		for(int i=0;i<n;i++){
			cin>>e;
			if(e>0) b[f++]=e;
		}
		g=h=0;
		z(g,0,n-2,a,c);
		z(h,0,n-2,b,d);
		if((g&1)==(h&1)) cout<<"TAK\n";
		else cout<<"NIE\n";
	}
	return 0;
}
```

---

## 作者：zcz0263 (赞：2)

### 思路
将题目中的两个网格中有数的位置分别展开成一个序列，发现
- 当空位和左边或右边的数交换时，该序列不变。
- 当空位和上边或下边的数交换时，相当于将序列中被交换的数和向前或后第 $n$ 个数交换，最多只会和 $n-1$ 个数的逆序关系有变化。

题目中 $n$ 一定为奇数，所以进行任意次变换后，序列内逆序对数奇偶性一定不变，只需要判断展开出的两个序列的逆序对数奇偶性是否相同即可，我的代码使用了树状数组求逆序对数。
### code
```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
//#include<atcoder/all>
using namespace std;
//using namespace __gnu_cxx;
//using namespace __gnu_pbds;
//using namespace atcoder;
//#define int long long
#define vi vector<int>
#define pb push_back
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define all(x) x.begin(),x.end()
#define maxn (505*505)
#define lowbit(x) ((x)&-(x))
//-O2 -std=c++14 -DONLINE_JUDGE -Wall -Wextra -Wl,-stack=536870912
int _,n,t,s1,s2;
vi c(maxn); 
void add(int p,int x){
	for(;p<maxn-5;p+=lowbit(p)) c[p]+=x; 
}
int ask(int p){
	int v=0;
	for(;p;p-=lowbit(p)) v+=c[p];
	return v;
}
int ask(int l,int r){
	return ask(r)-ask(l-1);
}
main(){
	ios::sync_with_stdio(0),cin.tie(nullptr);
	for(;cin>>n;s1=s2=0){
		vi a,b;
		rep(i,1,n*n){
			cin>>t;
			if(t)a.pb(t);
		}
		rep(i,1,n*n){
			cin>>t;
			if(t)b.pb(t);
		}
		for(int&i:a){
			s1+=ask(i+1,n*n);
			add(i,1);
		}
		fill(all(c),0);
		for(int&i:b){
			s2+=ask(i+1,n*n);
			add(i,1);
		}
		fill(all(c),0);
		if((s1&1)^(s2&1)) cout<<"NIE\n";
		else cout<<"TAK\n";
	}
}


```

---

## 作者：Wind_love (赞：1)

## 思路
首先将二维的矩阵转换成一维的数列。

首先，如果 $0$ 在行上移动，易证这样不会改变除 $0$ 之外序列的逆序对。

其次，如果 $0$ 在列上面移动，这样也是不改变除 $0$ 之外序列的逆序对的。

综上所述，可以用求逆序对的方式得到答案，逆序奇偶性相同，则可以完成，反之则不可完成。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int a[250005],b[250005];
int t[250005];
void sort(int a[],int l,int r,long long &cnt){
	if (l>=r)return;
	int mid=(l+r)>>1;
	sort(a,l,mid,cnt);
	sort(a,mid+1,r,cnt);
	int i=l,j=mid+1,k=0;
	while (i<=mid&&j<=r){
		if (a[i]<=a[j])t[k++]=a[i++];
		else t[k++]=a[j++],cnt+=mid-i+1;
	}
	while(i<=mid)t[k++]=a[i++];
	while(j<=r)t[k++]=a[j++];
	for (int i=l;i<=r;i++)a[i]=t[i-l];
}
signed main(){
	while(cin>>n){
		int topa=0,topb=0;
		for(int i=1;i<=n*n;i++){
			int x;
			cin>>x;
			if(x){a[++topa]=x;}
		}
		for(int i=1;i<=n*n;i++){
			int x;
			cin>>x;
			if(x){b[++topb]=x;}
		}
		int suma=0,sumb=0,temp=n*n-1;
		sort(a,1,temp,suma);
		sort(b,1,temp,sumb);
		if((suma%2)==(sumb%2))cout<<"TAK\n";
		else cout<<"NIE\n";
	}
	return 0;
}

---

## 作者：lby_commandBlock (赞：1)

## 结论

两个矩阵按行列顺序展开为数组后，求出两个数组的逆序对判断奇偶性相同即可（去除 $0$）。

## 证明

每一个奇数码可以考虑两种情况：

- 左右移动。
- 上下移动。

1. 先考虑左右移动。

注意到左右移动并不影响奇数码的一维序列，所以肯定一样。

2. 再考虑上下移动。

我使用样例举个列子。

```
5 2 8       5   8
1   3   ->  1 2 3
4 6 7       4 6 7
```

这个样例把 $2$ 移动到了下面，也就是把 $2$ 往后移动 $2$ 位。

详细点说，把 $x$ 移动到上面，则就是把 $x$ **在一维数组中**提前 $n-1$ 位，移动到下面，就是把 $x$ 在一维数组中向后移动 $n-1$ 位。

注意到移动后，**所有的逆序对都变成了非逆序对**（下文称顺序对），所有的顺序对则变成了逆序对。

- 样例中，有偶数个逆序对，变换后，剩下偶数个顺序对，则偶数个逆序对变为顺序对，偶数个顺序对变为逆序对，因此逆序对个数还是偶数。
- 奇数个逆序对同理。

得出结论。下面给出代码。

## 代码

注意打开 **`long long`**！

```cpp
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;

const int N = 3e5 + 9;

// 500 * 500 为最大范围，大概为 3e5

int n, a[N], b[N], t[N], cnt;

// 归并排序：求逆序对个数

int merge_sort(int *a, int l, int r) {
	if (l >= r)
		return 0;
	int mid = (l + r) >> 1, ans = 0;
	ans += merge_sort(a, l, mid);
	ans += merge_sort(a, mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (i <= mid && j <= r) {
		if (a[i] <= a[j])
			t[k++] = a[i++];
		else {
			t[k++] = a[j++];
			ans += mid - i + 1;
		}
	}
	while (i <= mid)
		t[k++] = a[i++];
	while (j <= r)
		t[k++] = a[j++];
	for (i = l; i <= r; i++)
		a[i] = t[i];
	return ans;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	while (cin >> n) {
		// 输入数组，并去除 0
		cnt = 0;
		for (int i = 1; i <= n * n; i++) {
			cin >> a[++cnt];
			if (a[cnt] == 0)
				cnt--;
		}
		cnt = 0;
		for (int i = 1; i <= n * n; i++) {
			cin >> b[++cnt];
			if (b[cnt] == 0)
				cnt--;
		}
		// 求出两个数组的逆序对个数
		int ans1 = merge_sort(a, 1, n * n - 1);
		int ans2 = merge_sort(b, 1, n * n - 1);
		// 判断奇偶性是否相同
		if ((ans1 % 2) == (ans2 % 2))
			cout << "TAK" << endl;
		else
			cout << "NIE" << endl;
	}
	return 0;
}
```

---

## 作者：ThomasNO1 (赞：1)

我们可以先把这个矩阵化成一个一维数组。接着，我们可以发现，如果是左右交换位置的话，一维数组不变。如果是上下交换位置的话，相当于与 $0$ 交换位置的数字与它后（前）边的 $n - 1$ 个数字交换了位置：
  
  $$
  开始：
  \\
  \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 0 \end{bmatrix}=
  \begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\end{bmatrix}
  \\
  当0与6交换后：
  \\
  \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 7 \\ 8 & 6 & 0\end{bmatrix} = \begin{bmatrix} 1 & 2 & 3 & 4 & 5 & 7 & 8 & 6 \end{bmatrix}
  $$

  我们发现，原本只有 $0$ 个逆序对。交换后，就有 $2$ 个逆序对：$7-6$ 和 $8-6$。
  再举个例子：
   $$
  开始：
  \\
  \begin{bmatrix} 7 & 1 & 3 \\ 0 & 2 & 5 \\ 6 & 8 & 4 \end{bmatrix}=
  \begin{bmatrix} 7 & 1 & 3 & 2 & 5 & 6 & 8 & 4\end{bmatrix}
  \\
  当0与7交换后：
  \\
  \begin{bmatrix} 0 & 1 & 3 \\ 7 & 2 & 5 \\ 6 & 8 & 4 \end{bmatrix}=
  \begin{bmatrix} 1 & 3 & 7 & 2 & 5 & 6 & 8 & 4\end{bmatrix}
  $$
  我们发现，开始有 $10$ 个逆序对，交换后，就有 $8$ 个逆序对。
  
  就此我们可以得出结论，因为 $n - 1$ 是偶数，所以在 $[与0交换位置的数字,0]$ 这个区间内，逆序对与非逆序对的数量的奇偶性相同，那交换后，逆序对变成非逆序对，非逆序对变成逆序对，奇偶性仍然不变，所以，只要第一个局面的逆序对数量与第二个局面奇偶性一样，那就输出 `TAK`，否则输出 `NIE`。
  ```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 250005;
int n,a[MAXN],b[MAXN],t[MAXN],ans = 0;
void merge_sort(int l,int r,int *A){
	if(l >= r) return;
	int mid = l + ((r - l) >> 1);
	merge_sort(l,mid,A);
	merge_sort(mid + 1,r,A);
	for(int i = l,j = l,k = mid + 1;i <= r;i++){
		if(j == mid + 1)
			t[i] = A[k++];
		else if(k == r + 1){
			t[i] = A[j++];
			ans += k - mid - 1;
		}
		else if(A[j] <= A[k]){
			t[i] = A[j++];
			ans += k - mid - 1;
		}
		else
			t[i] = A[k++];
	}
	for(int i = l;i <= r;i++) A[i] = t[i];
}
int main(){
	while(~scanf("%d",&n)){
		n *= n;
		int tot = 0;
		for(int i = 1,x;i <= n;i++){
			scanf("%d",&x);
			if(x) a[++tot] = x;
		}tot = 0;
		for(int i = 1,x;i <= n;i++){
			scanf("%d",&x);
			if(x) b[++tot] = x;
		}
		merge_sort(1,n - 1,a);
		int u = ans;ans = 0;
		merge_sort(1,n - 1,b);
		if((u & 1) == (ans & 1)) printf("TAK\n");
		else printf("NIE\n");
		ans = 0;
	}
	return 0;
}
```

---

## 作者：SuyctidohanQ (赞：0)

### 思路分析

首先将二维的矩阵转换成一维的数列。也就是将两个表格每行首尾相接连成一个序列。

- 当空格左右移动时，序列不会发生变化。

- 当空格上下移动时，会与其前面或者后面 $n - 1$ 个数进行交换。如果其中一个数比它大，那么会增加一个逆序对；如果比它小，那么减少一个；如果相等，那么不变。

### 代码实现

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll MAXN = 500 * 500 + 10;
ll n, a[MAXN], b[MAXN], t[MAXN];
void sortt (ll a[], ll l, ll r, ll &cnt){
	if (l >= r) return ;
	ll mid = (l + r) >> 1;
	sortt (a, l, mid, cnt); sortt (a, mid + 1, r, cnt);
	ll i = l, j = mid + 1, k = 0;
	while (i <= mid && j <= r) {
		if (a[i] <= a[j]) t[k ++] = a[i ++];
		else {
			t[k ++] = a[j ++];
			cnt += mid - i + 1;
		}
	}
	while (i <= mid) t[k ++] = a[i ++];
	while (j <= r) t[k ++] = a[j ++];
	for (ll i = l; i <= r; i ++) a[i] = t[i - l];
}
int main () {
	while (cin >> n) {
		ll lena = 0, lenb = 0, x;
		for (ll i = 1; i <= n * n; i ++) {
			cin >> x;
			if (x) a[++ lena] = x;
		}
		for (ll i = 1; i <= n * n; i ++) {
			cin >> x;
			if (x) b[++ lenb] = x;
		}
		ll suma = 0, sumb = 0;
		sortt (a, 1, n * n - 1, suma);
		sortt (b, 1, n * n - 1, sumb);
		if ( (suma % 2) == (sumb % 2)) cout << "TAK" << endl;
		else cout << "NIE" << endl;
	}
	return 0;
}
```

---

## 作者：zhangmuning1016 (赞：0)

## 知识点
本题要用到 [逆序对](https://oiwiki.com/basic/merge-sort/#%E9%80%86%E5%BA%8F%E5%AF%B9)，考察了对 [归并排序](https://oiwiki.com/basic/merge-sort/) 的运用。
## 思路
1.考虑把这两个 $n\times n$ 的矩阵按行拆成长度为 $n^2-1$ 的序列（忽略空格）  
2.我们发现，两个状态能够相互转换当且仅当两个序列的逆序对个数奇偶性相同。

## 证明逆序对奇偶相同
### 左右移动
```
5 2 8       5 2 8
1 _ 3       _ 1 3
4 6 7       4 6 7
```
移动前数组 ${5\ 2\ 8\ 1\ 3\ 4\ 6\ 7}$ , 移动后数组 ${5\ 2\ 3\ 1\ 3\ 4\ 6\ 7}$ , 因此左右移动产生的对逆序个数没有影响。
### 上下移动
```
5 2 8       5 _ 8
1 _ 3       1 2 3
4 6 7       4 6 7
```
移动前数组 ${5\ 2\ 8\ 1\ 3\ 4\ 6\ 7}$ , 移动后数组 ${5\ 8\ 1\ 2\ 3\ 4\ 6\ 7}$ 。

如果交换的数有奇数个逆序对，由于 $n−1$ 为偶数，因此逆序对个数还是奇数。

如果交换的数有偶数个逆序对，由于 $n−1$ 为偶数，因此逆序对个数还是偶数。

**所以，无论怎样移动都不会影响逆序对的奇偶性。**

### 代码
```
#include <bits/stdc++.h>
using namespace std;
int a[500005], b[500005], c[500005], n;
long long ans;
void gb(int l, int r) {//归并求逆序对
	if (l >= r) return;
	int m = (l + r) / 2;
	gb(l, m);
	gb(m + 1, r);
	for (int i = l, j = m + 1, k = l; i <= m || j <= r; ) { 
		if (i <= m && (a[i] <= a[j] || j > r))
			b[k++] = a[i++];
		else {
			b[k++] = a[j++];
			ans += m - i + 1;//ans是逆序对的数量
		}
	}
	for (int i = l; i <= r; i++)
		a[i] = b[i];
}
void gb2(int l, int r) {
	if (l >= r) return;
	int m = (l + r) / 2;
	gb2(l, m);
	gb2(m + 1, r);
	for (int i = l, j = m + 1, k = l; i <= m || j <= r; ) {
		if (i <= m && (c[i] <= c[j] || j > r))
			b[k++] = c[i++];
		else {
			b[k++] = c[j++];
			ans += m - i + 1;
		}
	}
	for (int i = l; i <= r; i++)
		c[i] = b[i];
}
int main() {
	int idx = 0;
	while (cin >> n) {
		idx = 0;//初始化
		ans = 0;
		for (int i = 1; i <= n * n; i++) {
			int x;
			scanf ("%d", &x);
			if (x != 0)
				a[++idx] = x;
		}
		idx = 0;
		for (int i = 1; i <= n * n; i++) {
			int x;
			scanf ("%d", &x);
			if (x != 0)
				c[++idx] = x;
		}
		gb(1, n * n - 1);//n * n - 1, 因为有1个0
		int p = ans;
		ans = 0;
		gb2(1, n * n - 1);
		int q = ans;
		if ((p & 1) == (q & 1))//奇偶性
			printf ("TAK\n");
		else
			printf ("NIE\n");
	}
	return 0;
}
```

---

## 作者：niuzh (赞：0)

### 思路

首先将两个表格每行首尾相接连成一个序列，然后对操作分别讨论。

- 当空格左右移动时，序列不会发生变化。

- 当空格上下移动时，会与其前或后 $n-1$ 个数进行交换。如果其中一个数比它大，那么会增加一个逆序对；如果比它小，那么减少一个；如果相等，那么不变。

由于 $n-1$ 是偶数，所以逆序对的总数的奇偶性不变。

所以考虑用归并排序求逆序对的数量，再判断奇偶性。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2500+10;
int a[N],b[N],t[N];
ll cnta,cntb;
void msort(int a[],int l,int r,ll &cnt)
{
	if (l>=r)
	{
		return;
	}
	int mid=(l+r)>>1;
	msort(a,l,mid,cnt);
	msort(a,mid+1,r,cnt);
	int i=l,j=mid+1,k=0;
	while (i<=mid&&j<=r)
	{
		if (a[i]<=a[j])
		{
			t[k++]=a[i++];
		}
		else
		{
			t[k++]=a[j++];
			cnt+=mid-i+1;
		}
	}
	while (i<=mid)
	{
		t[k++]=a[i++];
	}
	while (j<=r)
	{
		t[k++]=a[j++];
	}
	for (int i=l; i<=r; i++)
	{
		a[i]=t[i-l];
	}
}
int main()
{
	int n;
	while (cin>>n)
	{
		cnta=0,cntb=0;
		n*=n;
		for (int i=1,idx=0,x; i<=n; i++)
		{
			cin>>x;
			if (x!=0)
			{
				a[++idx]=x;
			}
		}
		for (int i=1,idx=0; i<=n; i++)
		{
			cin>>x;
			if (x!=0)
			{
				b[++idx]=x;
			}
		}
		msort(a,1,n-1,cnta);
		msort(b,1,n-1,cntb);
		if ((cntb%2)==(cnta%2))
		{
			cout<<"TAK\n";
		}
		else
		{
			cout<<"NIE\n";
		}
	}
	return 0;
}

```

---


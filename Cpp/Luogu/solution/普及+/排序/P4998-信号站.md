# 信号站

## 题目背景

   扶贫行动来到了Q村，扶贫队准备在Q村修筑信号站，让Q村不再“远离尘世”,让人们获得丰富的外界信息。

## 题目描述

   Q村非常非常Qiong，整个村只有一条路。在这条路上，有N户人家，因为条件有限，所以一个点上可能有多户人家。因为山区运输条件落后，所以扶贫队只能修筑k个信号站，并且他们希望各电站的不合理值之和最小。信号站的不合理值是指该信号站到每户人家的距离之和。
 
   扶贫队善于修筑电站，但是他们不擅长选址~~（因为数学不好QwQ）~~，他们希望你>>编程高手，来帮助他们选择修筑信号站的最佳地点，使得k个信号站的不合理值最小。

   距离求解方法:若某信号站的坐标为x,某户人家的坐标为y,那么该信号站与该人家的距离为|x-y|（即取绝对值）。

   数据保证人家数大于信号站数。放置信号站的位置坐标必须为整数。一个位置上只能放一个信号站。


## 说明/提示

#### 样例解释

在2和3的位置上放置信号站（方案不唯一）。

#### 数据范围

对于 $ 70\% $ 的数据，$ n,k\leq 10^3 $；  
对于 $ 100\% $ 的数据，$  n \leq 1000000, 0 \leq a_i \leq 10 ^ 6 $。

## 样例 #1

### 输入

```
7 2
1 1 2 2 3 3 4```

### 输出

```
13```

# 题解

## 作者：lamboo (赞：16)

显然，对于每个点$x$，它的不合理值为$y=\sum_{i=1}^n\mid x-a_i \mid$。显然~~（根据绝对值的几何意义）~~，这个函数有且仅有一个最小值。且在最小值左右两边的函数图像分别为单调递减、单调递增。大概是这么一个图像。

![](https://cdn.luogu.com.cn/upload/pic/41798.png)

我们在这道题中要找$k$个整点，使其对应的$y$值之和最小。我们可以先求出最小值。显然~~（根据绝对值的几何意义）~~，在$a$数组有序的前提下$\sum_{i=1}^n\mid x-a_i \mid_{min}=\sum_{i=1}^n\mid a_{\lfloor \frac{n}{2} \rfloor }-a_i \mid$。我们发现只有$ a_{\lfloor \frac{n}{2} \rfloor} $会对最小值产生影响，而其它数的顺序对答案没有影响。所以，我们可以计数排序，也可以通过快速排序舍去区间加快速度（虽然~~良心~~出题人并没有卡普通$nlogn$的排序）。然后，我们可以利用函数的单调性，往两边扩展计算，取最小值，让小的点继续去扩展，将答案累加。

注意:
1. 信号站建在负数位置的情况。

2. 要开**long long**

具体详见代码
```cpp
#include<cstdio>
using namespace std;
#define N 2000001
long long a[N],b[N];
long long n;
void sort(long long l,long long r)
{
	int i,j,x,y;
	if (l>n/2) return;  
	if (r<n/2) return;  //舍去不必要的区间
	i=l;j=r;
	x=a[l+r>>1];
    do
    {
    	while (a[i]<x) ++i;
        while (x<a[j]) --j;
        if (i<=j)
        {
        	y=a[i];
            a[i]=a[j];
            a[j]=y;
            ++i;--j;
    	}
    }
    while (i<=j);
    if (l<j) sort(l,j);
    if (i<r) sort(i,r);
}
inline long long abs(long long x)
{
	if (x>0) return x;
	return -x;
}
int main()
{
	int k;
	scanf("%lld %d",&n,&k);
	for (int i=1;i<=n;i++) scanf("%lld",&a[i]),b[a[i]]++;  //b[x]表示第x个位置有几户人家
	sort(1,n);
	long long ans=0;
	long long x=a[(n+1)/2],y=x+1;
	long long x_ans=0,y_ans=0,x_num=0,y_num=0;
	for (int i=1;i<=n;i++) 
	    if (a[i]>x) ++x_num;  //保存在x右边的数的个数
	for (int i=1;i<=n;i++)  
	    if (a[i]<y) ++y_num;  //保存在y左边的数的个数
	for (int i=1;i<=n;i++) x_ans+=abs(x-a[i]);
	for (int i=1;i<=n;i++) y_ans+=abs(y-a[i]);
	for (int i=1;i<=k;i++)
	{
		if (x_ans<=y_ans)  //取小的点扩展，累加答案
		{
			ans+=x_ans;
			x_ans+=x_num+b[x]-(n-x_num-b[x]);  //计算下一个点对答案的贡献。
			if (b[x]) x_num+=b[x];  //更新在x右边的数的个数
			--x;
		}
		else
		{
			ans+=y_ans;
			y_ans+=y_num+b[y]-(n-y_num-b[y]);
			if (b[y]) y_num+=b[y];
			++y;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：RenaMoe (赞：14)


> 一条路上有 n 户人家，坐标为 $a_i$，需要建 k 个不同位置的信号站，每个信号站的不合理值为所有人家到信号站的距离和，求不合理值最小的 k 个信号站不合理值之和。
>
> $k\le n\le 10^6,0\le a_i\le 10^6$


## 思路

k,n 和坐标值域是同阶的。

设位置 i 的人家数有 $b_i$ 个，单次处理某个点的答案复杂度是 $O(n)$ 的，即 $f_i=\sum b_j\times |i-j|$。

这时候需要我们观察两个点的答案之间的关系，尝试利用状态重叠的部分减少复杂度。

常用技巧，推一下将信号站由 i 挪到 i+1 答案变化了多少：

- i 左边的点（包括 i 处）离信号站距离都加了一
- i 右边的点离信号站距离都减了一

那么我们要维护每个点左右边各有几个点，通过前缀和或者递推，可将每次查询降到 $O(1)$。

总复杂度 $O(n)$。

## 细节

我赌你写一发交上去，倒数第二个点会 WA。

为什么？我们如果只计算了 $i\in [0,10^6]$ 的值，会忽略掉信号站建在负数位置的答案。

看个例子就懂了：

> n = 3，位置 $a_i$ 都为 0，k = 3。
>
> 那么三个信号站的位置分别为：-1，0，1。

把所有位置向右平移 $10^6$ 单位距离，计算答案的范围扩大一倍就行。

## 代码

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
using namespace std;

namespace RenaMoe {

template <typename TT> inline void read(TT &x) {}

typedef long long LL;

const int N = 1e6 + 9;
const int L = 1e6;

int n, k;
LL l, r, ans;
LL a[N<<1], f[N<<1];

inline void main() {
	read(n), read(k);
	for (int i = 1, x; i <= n; ++i)
		read(x), a[x+L]++;
	for (int i = 0; i <= L+L; ++i)
		f[0] += a[i] * i;
    // l,r 分别是该位置左右两边的点数
	r = n;
	for (int i = 1; i <= L+L; ++i) {
		l += a[i-1];
		f[i] = f[i-1] + l - r;
		r -= a[i];
	}
	sort(f, f+L+L+1);
	for (int i = 0; i < k; ++i)
		ans += f[i];
	printf("%lld\n", ans);
    return 0;
}
```





---

## 作者：Kevin_Wa (赞：12)

## 出题人的题解
####  本题是贪心+乱搞，在比赛时被各位大佬们纷纷看破，大佬们也是打出了各种千奇百怪的代码。总而言之，本题的难度大约$ TGDay1T1 $

### 简单题意：

就是找前k个不合理值的和，别忘了开long long(C++) int64(pascal)，不然只有70分，最坑的就是负半轴的情况了，如果没有考虑信号站建在负数上，就只有90分。
### 部分分获取：
 1、打暴力70分。
 
 2、贪心100分
### 贪心：
  因为有可能坐标会重合，所以我们先将所有的坐标和0的距离算出来。在根据这个值依次线性的找下来
  
如样例
  
3 1 
  
2 2 3
     
算出$ a[0]=7 , y=3 $

(指向下一格后距离和会减少y)

$ a[i]=a[i-1]-y; $

当遇到$ f[i]>0 $时($ f[i] $指第i个数出现了$ f[i] $次) 

$ y=y-f[i]*2 $

因为k太大，**所以在极端情况下要考虑负数上放**（很多大佬都死在了这里）

(如$ k/2+1>max $ 那么 $max=k/2+1$)

可以试一个样例

5 5

1 1 1 1 1

输出 30

可以将其存储到$ max+1+i $的单元格以便排序

（$ a[max+1] $存储$ a[0] $）

排序$a$

$ sort(1,max*2) $

加前$k$个

时间复杂度$o(n log n)$

同时介绍一下[其他做法](https://www.luogu.org/blog/Sleep-in-the-ground/noip2018-xin-xin-sai-t1-ti-xie)

### 总结

本题只是我以前做过一道相似的，但那题的题意不为这样，我理解成了这样，打完标算才发现我题目理解错了。现在我就出了这道题。多谢@[我是傻逼](https://www.luogu.org/space/show?uid=68387)hank掉了我原来的程序（原来我未考虑负数）。

### 代码

```pascal
var  a,f:array[0..2000100] of qword;
sum,max,y:int64;n,k,i,x:longint;
procedure sort(l,r: longint);
      var
         i,j: longint;
         x,y:qword;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]<x do
            inc(i);
           while x<a[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
procedure sc;
begin
a[max+1]:=a[0];
for i:=1 to max do
  a[i+max+1]:=a[i+max]+y;//负数
for i:=1 to max do//正数
  begin
  a[i]:=a[i-1]-y;
  y:=y-f[i]*2;
  end;
end;
begin
assign(input,'wlan.in');reset(input);
assign(output,'wlan.out');rewrite(output);
readln(n,k);
for i:=1 to n do
  begin
  read(x);
  inc(f[x]);
  a[0]:=a[0]+x;
  if x>max then max:=x;//存储最大
  end;
if max<k div 2+1 then max:=k div 2+1;//若最大较小，将范围扩大
y:=n;
sc;
sort(1,max*2);
for i:=1 to k do
  begin
  sum:=(sum+a[i]) ;
  end;
writeln(sum);
close(input);close(output);
end.

```


---

## 作者：污龙tea (赞：8)

 **倒数第二个点不过的盆友们！注意信号站的坐标是整数！也就是说可以是负整数，也可以比1e6要大！！！！！**
 
 所以只要读入的时候把每个点的坐标加上一个大数就行了！
 
 具体解题思路相信后来的大佬能解释的更清楚！
 
 {也许你可以考虑先算出每一个位置到所有村庄的总距离然后排序选前k小的
 ，算每一个位置的总距离的时候可以考虑前缀和优化一下！}

---

## 作者：fantastic_dream (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P4998)

可以用利用**前缀和**求出每个点对应的不合理值。

若以 $i$ 表示该点位置，$dl[i]$ 表示这个位置在村中人家的下标，$sum[i]$ 代表每户人家位置的前缀和，$f[i]$ 表示这个个点对应的不合理值，即可用以下式子表示：

$f[i]=dl[i]\cdot i-sum[dl[i]]+sum[n]-sum[dl[i]]-i\cdot (n-dl[i])$

举个例子：

如样例一：`
7 2
1 1 2 2 3 3 4`

位置 2 对应的不合理值就为：$2\times 2-(1+1)+(2+3+3+4)-2 \times 4$。由于这样的转化是 $O(1)$ 的，所以可以在规定时间内完成。

但这题它……并不单纯考察思维，也考察人的细致。

- **要开 long long**
- 人家的坐标并不连续，所以还要判断那些没有人家的位置。
- 信号站坐标可能是负数，一开始可以把所有坐标往右移动 $k$ 位。（~~顺便吐槽下题目没有给 $k$ 的范围~~）

AC 但丑陋的代码：
```
#include<bits/stdc++.h>
using namespace std;
const int ma=2000005;
int n,k,sz[ma],dl[ma];
long long sum[ma],f[ma],ans=0;
int read(){
    char ch=getchar();int x=0,f=1;
    while(ch<'0'||ch>'9'){
        if(ch=='-')	f = -1;
        ch=getchar();
    } 
	while('0'<=ch&&ch<='9') {
        x=x*10+ch-'0';
        ch=getchar();
    } 
	return x*f;
}//快读 
int main(){
	n=read(),k=read();
	sum[0]=0;
	for(int i=1;i<=n;i++)	sz[i]=read(),sz[i]+=k;
	sort(sz+1,sz+n+1);
	long long zd=sz[n];
	for(int i=1;i<=n;i++){
		if(sz[i]>sz[i-1]){
			for(int j=sz[i-1]+1;j<sz[i];j++)	dl[j]=i-1;
			dl[sz[i]]=i;
		}
	}
	for(int i=1;i<=n;i++)	sum[i]=sum[i-1]+sz[i];
	for(int i=1;i<=zd;i++){
		f[i]=1ll*dl[i]*i-sum[dl[i]]+sum[n]-sum[dl[i]]-1ll*i*(n-dl[i]);
//		cout<<i<<' '<<dl[i]<<' '<<f[i]<<endl;
	}	
	sort(f+1,f+zd+1);
	for(int i=1;i<=k;i++)	ans+=f[i];
	cout<<ans;
	return 0;
}
```


---

## 作者：chinaxjh (赞：3)

来写一下题解，帮助一些一直过不去但总体思路没错的同学（本人错了5次，感觉已经把可能会错的地方都试了一遍）

如果还找不到思路，可以先看一下[这篇题解](https://www.luogu.org/blog/Sleep-in-the-ground/noip2018-xin-xin-sai-t1-ti-xie)，我觉得原作者已经将做法讲得很清楚了，但配合本题解食用更加。

## Wrong 1
向两边扩展时没有将两个指针移动（这个应该除了我没人错了）

解决方案：移动

## Wrong 2
没考虑负数

解决方案：这个问题有两个解决方案
#### 方案1（建议）
将全体加上1e6(但数组也要相应扩大)
#### 方案二
在计算时对负数进行特判（比较麻烦一点，直接加简单）

## Wrong 3
没开long long

解决方案：开long long(两年oi一场空，一场long long见祖宗)

## Wrong 4
数组开小（或上限N定小）

解决方案：开大

放一下代码，经供参考。

Ac code
```
#include<bits/stdc++.h>
using namespace std;
const int N=4000020;//不要开小，否则WA
long long n,m,ll,rr,now,ans,i,a[N],lefts[N],rights[N];
int l[N],r[N];
long long asdf(long long xx)
{
	if (xx<0) return -xx;
	else return xx;
}//自带abs是int范围以内的，不能用
long long gettt(long long k)
{
  return (asdf(k*l[k]-lefts[k])+asdf(k*r[k]-rights[k]));
}//求绝对值之和
int main()
{
	scanf("%lld%lld",&n,&m);
	for (i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		a[i]+=1000000;//加上一个大数，避免负数的问题
		lefts[a[i]]+=a[i];
		rights[a[i]]+=a[i];
		l[a[i]]++; r[a[i]]++;
	}
	sort(a+1,a+1+n);
	for (i=1;i<=N-10;i++)
	{
		lefts[i]+=lefts[i-1];
		l[i]+=l[i-1];
	}
	for (i=N-10;i>=0;i--)
	rights[i]+=rights[i+1],
	r[i]+=r[i+1];
	now=rr=ll=a[(1+n)>>1];
	for (i=1;i<=m;i++)
	{
		ans+=gettt(now);
		if (gettt(ll-1)<gettt(rr+1)) 
		{
			ll--;
			now=ll;
		}
		else 
		{
			rr++;
			now=rr;
		}
	}//没有什么特别要注意的，有思路的人都能打出来
	printf("%lld\n",ans);
}
```


---

## 作者：Link_Cut_Y (赞：1)

这应该是我的第三篇题解啦（安利一下 [My blog](https://www.cnblogs.com/LcyRegister/)）


------------

 - ~~估计没人看的~~简化版题意：

给定一个数轴，以及数轴上的 $n$ 个点（这些点可能坐落在同一坐标上），第 $i$ 个点的坐标为 $a_i$ 。现在要在数轴上找 $k$ 个点，第 $i$ 个点的坐标为 $x_i$ 。求这 $k$ 个点到原数轴上 $n$ 个点距离和的最小值，即 $min(\sum_{i = 1}^{k} \sum_{j = 1}^{n} |x_i - a_j|)$.

注：$n,\ a_i \leq 10^6,\ k \leq n$

 - 题目分析：
 
首先，最容易想到的就是暴力模拟。循环枚举坐标，对于每个坐标，求出其到 $n$ 个点的距离和。最后再将距离和升序排列。时间复杂度 $O(an) = $**TLE**

现在从两个方向考虑优化：

1. 减少枚举数量。也就是减少 $x$ 的枚举数量。
2. 减少计算过程。也就是降低求 $x_i$ 到 $a_j$ 距离和的复杂度。

而由于 $x$ 与其他点的距离没有方便计算的函数表示，所以减少枚举数量是~~不现实的~~（可能是因为我太弱了）

那么怎样减少计算过程呢？？

设一个点 $x$ 到所有 $a$ 的距离和为 $s$。
我们可以发现，如果 $x$ 往前走一个单位长度，那么它与它前面点的距离就都会加一，与后面点的距离都会减一。

设 $x$ 往前移动一位后， $x$ 前面有 $c$ 个点，后面有 $n - c$ 个点。

那么，距离就会变为：$s + c - (n - c)$。

所以，我们在枚举信号站坐标的时候，就可以顺带着将信号站到其他点的距离用 $O(1)$ 算出来

时间复杂度为 $O(a)$

代码大概长这样（由于空间有限，就不在这里放了） [Wrong Code](https://www.luogu.com.cn/paste/fvrwns7f)

然后就惊喜的发现 **Wa** 了一个点 ...

发现我代码中的错误是在一天之后了。我忽然发现，信号站是有可能建在负数坐标上的，举个栗子：

数轴上点的坐标为： $a = [0, 0, 0, 0, 0]$

我们要选择5个信号站。

那么，最优解应该是 $x = [0, 1, 2, -1, -2]$.

这样，我们的信号站就选到了负数点上。

这样，我们只需要将信号站枚举起点换成 $-10^6$ （因为 $k \leq 10^6$ 嘛）。由于数组下标不能是负数，所以我们在数组上加上一个偏移量 $delta$，让数组下标变成正数即可。

 - **Code**
 
```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

using namespace std;

typedef long long LL;
const int N = 1000010, M = N << 1;
LL f[M];
int p[N];
int delta = 1e6;
int n, m;
int Map[N];

int main()
{
	scanf("%d%d", &n, &m);
	
	LL s = 0;
	for (int i = 1; i <= n; i ++ )
	{
		scanf("%d", &p[i]);
		Map[p[i]] ++ ;
		s += (p[i] + 1e6);
	}
	
	sort(p + 1, p + n + 1);
	
	int l = 0, r = n;
	f[0] = s;
	for (int i = -1e6 + 1; i <= 1e6; i ++ )
	{
		f[i + delta] = f[i - 1 + delta] + l - r;
		if (i < 0) continue;
		if (Map[i]) l += Map[i], r -= Map[i];
	}
	
	sort(f, f + 2000000 - 1);
	
	LL res = 0;
	for (int i = 0; i < m; i ++ )
		res += f[i];
		
	printf("%lld\n", res);
	
	return 0;
}
```

---

## 作者：IcyFoxer_XZY (赞：1)

 [题目传送门](https://www.luogu.com.cn/problem/P4998)
 
 ~~能过就是我的第六篇了~~
 
###  分析：
如果只要求取一个点的话，直接套用蓝书里面的结论：取中位数即可。

但是这里要求 $k$ 个点，怎么办？

可以定义一个函数为一个点的不合理值，那么可以发现这个函数是先下降后上升的。

换句话说：我们已经知道了中位数那里就是峰底，那么剩下的 $k$ - $1$ 个点就在这些点的旁边取即可。

~~我的思路也是这样啊为什么只有 10 分！！！~~

看了下其他 dalao 的做法，我才发现可以 $O(1)$ 地更新答案。

维护两个变量 $numx$ 和 $numy$ ，表示比 $x$ 大的人家个数和比 $y$ 小的人家个数。

因为人家的坐标 ≤ $10^6$，所以直接不用离散化就能开下来，可以开一个数组表示一个点处有多少个人家。

给 $x$ 和 $y$ 赋两个初值，通过取答案的较小值来对它更新， $x$ 只负责向左扩展，$y$ 只负责向右扩展。

我的错误思路：用一个点来扩展，取它的两边较小值来继续扩展，如果两边相等的话就搞不了 qwq 。

同样，这道题有一个坑：信号站可以建在负半轴上面，所以数组开大一点然后平移一下就完事了。

#### 注意：开 long long ！

代码不放了，其实懂了思路也不难实现了。

Bye！

---

## 作者：LightningUZ (赞：1)

### 思路

假如你和我一样看错了题，那么你会把所有的基站都放在中位数，然后输出放在中位数的答案 $\times k$

然而，题目里有说，
> **一个位置上只能放一个信号站**

于是...我们考虑把第一个基站放在中位数的位置，然后剩下的基站尽量靠近中位数。我们每次维护左边放到了的位置 $head$，右边放到的位置 $tail$。比较下 $head-1$ 和 $tail+1$，看哪里小放哪里。

如何快速的求出基站放在某地的答案呢？

#### 快速求基站在某一个位置的答案

假设基站放在 $x$ 位置。特判 $x<0$ 或者 $x>10^6$，这显然很好求。

然后假设有 $l$ 个位置 $\le x$ （前缀和维护）。求出这些位置的坐标和 （另一个前缀和数组维护），设为 $s$。所有坐标的和设为 $S$。

然后答案就是 $(x\times l-s)+((S-s)-x\times (n-l))$

其中，$S-s$ 表示大于 $x$ 的位置和，$n-l$ 表示大于 $x$ 的位置个数。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define int long long
    #define N 1666666
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define all(a) a.begin(),a.end()
    #define iter(a,p) (a.begin()+p)
    int I()
    {
        int x=0;char c=getchar();int f=1;
        while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();
        while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
        return (x=(f==1)?x:-x);
    }
    void Rd(int cnt,...)
    {
        va_list args; va_start(args,cnt);
        F(i,1,cnt) {int* x=va_arg(args,int*);(*x)=I();}
        va_end(args);
    }

    int n,k;
    int c[N],s[N]; // c维护数量，s维护坐标和
    void Input()
    {
        Rd(2,&n,&k); 
        F(i,1,n) 
        {
            int x=I();
            ++c[x];
            s[x]+=x;
        }
    }

    int m=1e6;
    int calc(int x) // 求基站放在 x 的答案
    {
        if (x<0) return s[m]-n*x;
        if (x>m) return n*x-s[m];

        int les=c[x];
        return x*les-s[x]+(s[m]-s[x])-x*(n-les);
    }
    void Soviet()
    {
        F(i,1,m) c[i]+=c[i-1],s[i]+=s[i-1];
        // 求前缀和
        int mid;
        F(i,1,m) if (c[i]*2>=n) {mid=i; break;}
        // 求中位数

        int ans=calc(mid); 
        int head=mid,tail=mid;
        F(i,1,k-1)
        {
            if (calc(head-1)<calc(tail+1)) --head,ans+=calc(head);
            else                           ++tail,ans+=calc(tail);   
            // head 和 tail，哪里小放哪里
        }
        printf("%lld\n",ans);
    }

    #define Flan void
    Flan IsMyWife()
    {
        Input();
        Soviet();
    }
    #undef int //long long
}
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();getchar();
    return 0;
}
```

---

## 作者：Chinshyo (赞：0)

首先肯定需要对每一个位置的居民个数进行统计，存入数组一个数组，并令数组元素个数为 $m$ 。

要使得 $k$ 个信号站的不合理值最小，不妨把每一个位置建信号站的不合理值求出来，最后排个序，输出前 $k$ 个的累加。

现在要求一个点到其他所有点的距离和，不妨转化为求这个点到前面所有点的距离和加上到后面所有点的距离和。想到这一步，就能想到：可以维护两个前缀和数组（可能有一个叫后缀和？）， $pres_i$ 用来存 $i$ 到 $i$ 前面所有的点 $x$ ( $x \in [1, i-1]$ )距离和， $sufs_i$ 表示 $i$ 到 $i$ 后面所有点 $x$ ( $x \in [i+1, m]$ )的距离和。最后只需要把这两个数组相加，就能得到当前这个点到其他所有点的距离和：即
$$ans_i = pre_i + suf_i$$

那么如何来求 $pres$ 和 $sufs$ 呢？先来看 $pres$ 。我们可以在草稿纸上试试推一推。很好发现：我们从前往后递推到 $i$ 时 ，前面以及加进来的点到 $i$ 距离都是到 $i - 1$ 的距离加一。我们不妨再维护一对前缀和数组 $pren$ 和 $sufn$ 分别存 $[1, i-1]$ 的村庄个数和 $[i+1, n]$ 的村庄个数。这两个数组就是最朴素的前缀和。

$$pren_{i+1} = pren_{i} + a_{i}$$

$$sufn_{i-1} = sufn_{i} + a_{i}$$

那么接下来的递推式就很好写了：

$$pres_i=pres_{i-1}+pren_{i-1}+a_{i-1}$$

$$sufs_i=sufs_{i+1}+sufn_{i+1}+a_{i+1}$$

这边提供样例数据，可以再尝试推一推。

| $i$ | $1$ | $2$ | $3$ | $4$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $a$ | 2 | 2 | 2 | 1 |
| $pren$ | 0 | 2 | 4 | 6 |
| $pres$ | 0 | 2 | 6 | 8|
| $sufn$ | 5 | 3 | 1 | 0 |
| $sufs$ | 9 | 4 | 1 | 0 |


最后请注意：可能出现信号站建在负数坐标情况。初始化的时候坐标统一加上 $10^6+1$ 即可。

```cpp
#include<bits/stdc++.h>
#define MaxN 2000005
#define P 1000001
#define int long long
using namespace std;

int a[MaxN << 1], pres[MaxN << 1], sufs[MaxN << 1], pren[MaxN << 1], sufn[MaxN << 1], ans[MaxN << 1];

signed main() {
	int n, k;
	cin >> n >> k;
	for(int i = 1; i <= n; i++) {
		int x;
		cin >> x;
		a[x + P]++;
	}

	int m = INT_MIN;
	for(int i = 1; i <= n + P; i++) {
		if(a[i]) m = i;
	}

	for(int i = 1; i <= m; i++) {
		pren[i + 1] = pren[i] + a[i]; 
	}
    for(int i = m; i >= 1; i--) {
		sufn[i - 1] = sufn[i] + a[i];
	}
    
	for(int i = 1; i <= m; i++) {
		pres[i] = pres[i - 1] + pren[i - 1] + a[i - 1];
	}
	for(int i = m; i >= 1; i--) {
		sufs[i] = sufs[i + 1] + sufn[i + 1] + a[i + 1];
	}
	for(int i = 1; i <= m; i++) {
		ans[i] = pres[i] + sufs[i];
	}
	sort(ans + 1, ans + m + 1);
	int res = 0;
	for(int i = 1; i <= k; i++) {
		res += ans[i];
	}
	cout << res << endl;
	return 0;
}
```


---

## 作者：_Spectator_ (赞：0)

[可能更好的食用体验](/blog/523641/P4998) $|$ 
[题目传送门](/problem/P4998) $|$ 
[我的其他题解](/blog/523641/#type=题解-New)

------------

${\large\color{#00CD00}\text{思路}}$

首先，对于一个点 $x$，所有点到 $x$ 的距离之和显然是 $\sum\limits_{i=1}^n |a_i-x|$。

拆掉绝对值，就是 $\sum\limits_{i=1}^n \begin{cases}x-a_i & a_i<x \\ a_i-x & a_i\ge x\end{cases}$。

将 $a$ 升序排序，假设有 $1\le p \le n,\,a_p<x,\,a_{p+1}\ge x$（二分查找解决）。

那么上式可以变成 $\sum\limits_{i=1}^p x-a_i+\sum\limits_{i=p+1}^n a_i-x$。

把 $x$ 提出来：$(2p-n)x-\sum\limits_{i=1}^p a_i+\sum\limits_{i=p+1}^n a_i$。

再使用一个前缀和优化，我们就能实现 $O(\log n)$ 计算所有点到任意一个点的距离之和（换个写法可以写成 $O(1)$，这里不再过多赘述）。

接下来有两种做法：

- 做法 1：贪心

枚举信号站的所有位置，算出到所有点的距离之和并存起来，排序取前 $k$ 小的就行。

这里的枚举范围取 $\min\{a\}-k \sim \max\{a\}+k$ 即可。

- 做法 2：数学

根据绝对值的几何意义，如果将 $a$ 排序，若 $n$ 为奇数，$x=a_{(n+1)/2}$ 时 $x$ 到所有点的距离之和最小；若 $n$ 为偶数，$x$ 为 $[a_{n/2},a_{n/2+1}]$ 中的任意一点时，$x$ 到所有点的距离之和最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/7c3zpc09.png)

例如，上图中，点 $C$ 到其他所有点的距离之和最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/n21drqic.png)

而这幅图中，线段 $BC$ 上的任意一点到 $A,B,C,D$ 四点的距离都相等且最小。

因此，我们可以先取一点 $x=a_{\lfloor(n+1)/2\rfloor}$，这一点到所有点的距离一定是最小的。然后再往两边取 $k$ 个距离最小的点即可。

------------

${\large\color{#00CD00}\text{细节}}$

1. 开 long long。
2. 排序。 
3. 信号站的坐标可以是负数。解决方法：将所有的 $a_i$ 加上 $k$。

具体实现可见代码。

------------

${\large\color{#00CD00}\text{代码}}$

法一代码（[AC record](/record/126195754)）：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e6+5;
int n,k,ans;
int a[N],sum[N],d[N];
int calc(int x)
{
	int p=lower_bound(a+1,a+1+n,x)-(a+1);
	return (2*p-n)*x-sum[p]+sum[n]-sum[p];
}
signed main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i],a[i]+=k;
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i];
	int mi=a[1]-k,ma=a[n]+k;
	for(int i=mi;i<=ma;i++)d[i-mi]=calc(i);
	sort(d,d+ma-mi);
	for(int i=0;i<k;i++)ans+=d[i];
	cout<<ans;
	return 0;
}
```

法二核心代码（[AC record](/record/126201129)）：
```cpp
int p=a[(n+1)/2],q=p-1;
for(int i=1;i<=k;i++)
{
	int t1=calc(p),t2=calc(q);
	if(t1<t2)ans+=t1,p++;
	else ans+=t2,q--;
}
```

---

## 作者：fanke (赞：0)

## P4998  题解

[原题](https://www.luogu.com.cn/problem/P4998)


### 1.整体思路

其实如果只取一个点的话直接取中位数即可。

可惜题目要求 $k$ 个点 .....

所以我的思路是：

维护两个变量 $numx$ 和 $numy$，**表示比 $x$ 大的人家个数和比 $y$ 小的人家个数**。因为坐标 $ \le 10^6 $，所以直接**不用离散化**就能开下来，可以开一个数组表示一个点处有多少个人家。给 $x$ 和 $y$ 赋两个初值，通过取答案的较小值来对它更新，$x$ 只负责向左扩展，$y$ 只负责向右扩展。

所以这题的时间复杂度是：$O(1)$ 的。



就是这样，同时给大家整理了一下这道题的几个错误点。

### 2.错误点

2.1 没考虑负数。

这题其实是有负数，你可以在计算时对负数进行特判。



2.2 数组大小。

发现这题很多人会开小。



---


# [NOIP 2004 提高组] 合并果子 加强版

## 题目背景

本题除【数据范围与约定】外与 [P1090](https://www.luogu.com.cn/problem/P1090) **完  全  一  致**。

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $(n - 1)$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 堆果子，数目依次为 $1,~2,~9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力为 $3+12=15$。可以证明 $15$ 为最小的体力耗费值。


## 说明/提示

**【数据规模与约定】**

**本题采用多测试点捆绑测试，共有四个子任务**。

- Subtask 1（10 points）：$1 \leq n \leq 8$。
- Subtask 2（20 points）：$1 \leq n \leq 10^3$。
- Subtask 3（30 points）：$1 \leq n \leq 10^5$。
- Subtask 4（40 points）：$1 \leq n \leq 10^7$。

对于全部的测试点，保证 $1 \leq a_i \leq 10^5$。

**【提示】**

- 请注意常数因子对程序效率造成的影响。
- 请使用类型合适的变量来存储本题的结果。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。



## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# 题解

## 作者：Reanap (赞：109)

这道题很有意思，也很清真。贪心思路想必大家都已经了解了，就是每一次选取最小的两堆果子进行合并，但是我们怎么选取呢？优先队列确实是一种比较优秀的解法，但是他还不够优秀，这里要求是$O(n)$的算法。

我们回归问题的本质，我们还是要选取最小的两堆果子，最清真、最自然的方式显然是排序了吧。先排序，选取最小的两堆果子，然后合并，插入。但是插入的效率太低了，我们想要优化。

我们可以把这些需要插入的点用一个队列存储起来，首先这些需要插入的点肯定会越来越大 ~~显然~~ ， 这相当于延迟插入。当我们目标插入点就是我们当前最小的那一堆的时候，我们就把他插入进来。

以上是精神，代码写出来大概就是，桶排，建立两个队列，排序结果放进第一个当中，合并结果放在第二个当中，每次选从两个队列队头选取比较小的合并。

代码如下：

```cpp

#include <cstdio>
#include <queue>
#define int long long
using namespace std;
queue <int> q1;
queue <int> q2;
int to[100005];
void read(int &x){ 
	int f=1;x=0;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
signed main() {
	int n;
	read(n);
	for (int i = 1; i <= n; ++i) {
		int a;
		read(a);
		to[a] ++;
	}
	for (int i = 1; i <= 100000; ++i) {
		while(to[i]) {
			to[i] --;
			q1.push(i);
		}
	}
	int ans = 0;
	for (int i = 1; i < n; ++i) {
		int x , y;
		if((q1.front() < q2.front() && !q1.empty()) || q2.empty()) {
			x = q1.front();
			q1.pop();
		}
		else {
			x = q2.front();
			q2.pop();
		}
		if((q1.front() < q2.front() && !q1.empty()) || q2.empty()) {
			y = q1.front();
			q1.pop();
		}
		else {
			y = q2.front();
			q2.pop();
		}
		ans += x + y;
		q2.push(x + y);
	} 
	printf("%lld" , ans);
	return 0;
} 

```

---

## 作者：HPXXZYY (赞：75)



$\color{blue}{\texttt{[Solution]}}$

这题的弱化版相信大家一定都知道——就是洛谷的[P1090](https://www.luogu.com.cn/problem/P1090)。它是一道非常经典的贪心（或者说建哈弗曼树）的题目。

可是，这道题的数据范围非常的变态，以至于我们只能用 $O(n)$ 的算法，连 $O(n \times \log n)$ 的算法都不行。

一点一点来解决，先看看原题（弱化版）中有哪些地方是 $O(n \times \log n)$ 的，再来想怎么样把它们变成 $O(n)$。

> 注意，这是一个非常有用的思考方式。先考虑一个比较简单易想的弱化版，再看弱化版中哪些地方耗费了大量的时间，最后优化这些地方，使得整个算法的时间复杂度可以让我们接受。

第一个地方就是排序。我们发现这道题有一个非常好的性质：$1 \leq a_i \leq 1 \times 10^5(1 \leq i \leq n)$。

这有什么用呢？我们可以用桶排来代替快排。所谓的桶排，就是开一个桶 $\texttt{cnt}$，其中 $\texttt{cnt}_{i}$ 表示数字 $i$ 的出现次数。排序变得非常简单：

```cpp
for(int i=1;i<=100000;i++)
	for(int j=1;j<=cnt[i];j++)
		b[++tot]=i;//b数组即排序后数组
```

第二个地方就是贪心的过程。我们需要用优先队列，而优先队列是 $O(n \times \log n)$ 的。怎么办办呢？两个方法。

1. 换一个数据结构。但这个对于本题来说有点难，至少笔者不会。
2. 用其它数据结构代替它。

用什么数据结构来代替它呢？两个队列！

队列 $Q_1$ 初始化为排好序后的 $b$ 数组，$Q_2$ 初始化为空。有什么用呢？

首先要取出最小的两个数。这个简单，每次取一个数只需要从 $Q_1$ 和 $Q_2$ 的对头（它们是这个队列中最小的元素），看看谁更小，谁小要谁。

然后是插入元素。我们把它直接放到 $Q_2$ 的尾部。

就这么简单。但是它为什么是对的呢？$Q_1$ 就说是我们人为的排好了序，是有序的，$Q_2$ 也一定是有序的吗？

答案是肯定的，大家可以想想为什么（也可以去搜索一下，真的很简单，这里就不证明了）。

于是我们可以在 $O(n)$ 的时间复杂度内解决这道题了。

$\color{blue}{\texttt{[code]}}$

```cpp
const int N=1e7+100;
const int M=1e5+100;
long long ans;int n;
int a[N],cnt[M];//桶 
queue<long long> q1,q2;
inline long long get_first(){
	if (q2.empty()||(!q1.empty()&&q1.front()<q2.front()))
		{long long x=q1.front();q1.pop();return x;}
	else{long long x=q2.front();q2.pop();return x;}
}
int main(){
	memset(cnt,0,sizeof(cnt));
	n=read();ans=0ll;//init
	for(int i=1;i<=n;i++)
		cnt[a[i]=read()]++;
	for(int i=1;i<=100000;i++)
		for(int j=1;j<=cnt[i];j++)
			q1.push(i);//O(N)的桶排 
	for(register int i=1;i<n;i++){
		long long x=get_first();
		long long y=get_first();
		ans+=x+y;q2.push(x+y);
	}
	printf("%lld",ans);
	return 0;
}

read() 函数就是快读函数，这里不给出了。
```

---

## 作者：Alarm5854 (赞：26)

这道题目的 $n\le 10^7$，用堆来做显然凉凉，而这一道题不用堆但也需要排序，直接 sort？吸氧都过不了。这一道题的正解是先用桶排 $(a_i\le10^5)$，然后用一个辅助的队列，每一次取两个数 $x,y$，然后在队尾加入 $x+y$，每次取数比较原数组未取的数中的第一个与队头，若原数组中的数较小，则原数组的指针 $k$ 往后移一位，否则，队头往后一位。这样，正解就出来了。

不过，虽然桶排实现相对容易，且效率极高，但不易拓展，所以我介绍一种效率略低，但易拓展的排序——基数排序。它是以一个数为基数 $b$，然后第 $k$ 次按照在 $b$ 进制下的第 $k$ 位来排序，从而实现在较低复杂度内排序的。举个例子，有 $12$ 个数：  
`13 23 34 27 19 37 43 22 11 9 21 40`  
取 $b=10$，也就是十进制，当 $k=1$ 时，排序结果如下：  
`40 11 21 22 13 23 43 34 27 37 19 9`  
现在这些数已经按照个位排好序了，接下来，当 $k=2$ 时，排序结果如下：  
`9 11 13 19 21 22 23 27 34 37 40 43`  
这时候，由于最大的数只有两位，所以现在已经排好序了，时间复杂度为 $O((n+b)\log_bn)$，空间复杂度为 $O(n+b)$，看上去不是线性，但是非常接近线性。事实上，在实际中，$b$ 不会取 $10$，因为模运算的效率极低，$b$ 通常取 $256$，这样在 $2^{32}$ 的数以内，只需要排4次。$b$ 不取 $65536$ 的原因是为了卡进一级缓存，效率更高。这道题目的 $a_i\le10^5$，所以排3次即可，码长也只有1.37k（包括前面0.5k的模板）。
```cpp
#include<bits/stdc++.h>
#define int long long//不开LL见祖宗
using namespace std;
const int N = 10000000 + 10;
FILE *fin, *fout;
inline int read(int &x) {//快读和快写，否则10^7忍受不了
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
inline void write(int x) {
	if (x < 0) return fputc('-', fout), write(-x);
	if (x > 9) write(x / 10);
	fputc((x % 10) | 48, fout);
}
int n, h, t, k, ans, cnt[256], a[N], b[N];
inline void radix_sort(int a[], int n) {//基数排序
	for (int i = 0; i < 17; i += 8) {//排3次即可
		for (int j = 0; j < 256; ++j) cnt[j] = 0;//每次都要清零
		for (int j = 0; j < n; ++j) ++cnt[(a[j] >> i) & 255];//位与上255，相当于对256取余，优化常数
		for (int j = 1; j < 256; ++j) cnt[j] += cnt[j - 1];//求前缀和
		for (int j = n - 1; ~j; --j) b[--cnt[(a[j] >> i) & 255]] = a[j];//为了优化常数（++x比x++快），下标从0开始
		for (int j = 0; j < n; ++j) a[j] = b[j];//别忘记复制回来
	}
}
signed main() {
	#ifdef ONLINE_JUDGE//在评测机上使用标准输入输出，在本机上使用文件输入输出，方便本机调试
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6038.in", "rb");
	fout = fopen("P6038.out", "wb");
	#endif
	read(n); for (int i = 0; i < n; ++i) read(a[i]);
	radix_sort(a, n);
	for (int i = 1; i < n; ++i) {
		int x, y;
		if ((h == t) || (k < n && a[k] < b[h])) x = a[k++]; else x = b[h++];//这里无法继续常数优化，只能用h++,k++,t++。若a[k]<b[h]，则取a[k]并且k++，否则取b[h]并且h++，下同
		if ((h == t) || (k < n && a[k] < b[h])) y = a[k++]; else y = b[h++];
		b[t++] = x + y, ans += x + y;
	}write(ans);
	return 0;
}
```
当输入的 $n=10^7$，且 $a_i=10^5$ 时，最终的答案为 $23322278400000$，所以即使当 $a_i\le 10^9$ 时，也不会爆LL，所以，可以把 $a_i$ 的范围改为 $a_i\le10^9$，卡掉桶排。  
当 $n=10^7,a_i=10^5$ 时，三种方法的运行时间如下（本机跑得很慢）：

| 使用方法 | 运行时间(s) | 码长(KB) |
| :----------: | :----------: | :----------: |
| 暴力 | $62.17$ | $0.90$ |
| 桶排 | $10.22$ | $1.26$ |
| 基排 | $10.97$ | $1.37$ |
可以看到，基排的效率也是很高的（侧面突出洛谷评测机的速度快，在洛谷上基排最慢的点仅0.54s），且码长也较短。

---

## 作者：惟有泪千行 (赞：13)

下面介绍一种奇妙的做法（最优解第一页）

首先我们可以从[P1090](https://www.luogu.com.cn/problem/P1090)得到启发，因为P1090是这道题的弱化版（废话）。在P1090中，我们采用了维护一个优先队列的方法，但是复杂度是O(NlogN)的，显然不能通过n=1e7的本题，所以我们要想一下如何优化我们的优先队列。首先ai是小于10000的，这很容易让人想到桶排，但是我们可以通过桶排的思路想到一个不一样的算法。

这时候我们就想起了小学学过的a+b,当a,b>0时a+b>a且a+b>b。所以说每一次取出来两个数相加后，得到的新的一堆果子一定是大于原来的任意一堆的，也就是说，如果我们当前选取了最小的相加，得到的数一定是不会出现在这两个数之前的。

然后我们就有了~~乱搞~~算法的思路，我们定义一个数组（大小自己定，不要太大也不要太小），用来记录每一堆果子的个数，再从前往后扫一遍，如果扫到了两个最小的数，就会合并产生一个新的数，如果这个新的数是小于数组范围的，便将其存入数组，否则就将其存入优先队列。扫完之后如果优先队列内的个数大于1则再进行P1090的算法，此时由于数据个数较少所以就会运行得比较快。

code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll ans,n,a[10000001],las;
priority_queue<ll,vector<ll>,greater<ll> >q;
inline ll read()
{
	ll x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
int main()
{
	n=read();
	for(register int i=1;i<=n;++i)
	{
		ll x=read();
		++a[x];
	}
	for(register int i=1;i<=10000000;++i)
	{
		if(a[i]==0)continue;
		if(las)
		{
			ll x=las+i;
			if(x<=10000000)++a[x];
			else q.push(x);
			--a[i];
			ans+=x;
			las=0;
		}
		while(a[i]>=2)
		{
			ll x=i<<1;
			if(x<=10000000)++a[x];
			else q.push(x);
			a[i]-=2;
			ans+=x;
		}
		if(a[i])las=i,--a[i];
	}
	if(las)
	{
		if(!q.empty())
		{
			ll x=q.top()+las;
			q.pop();
			q.push(x);
			ans+=x;
			las=0;
		}
	}
	if(!q.empty())
	{
		while(q.size()>1)
		{
			ll x=q.top();
			q.pop();
			x+=q.top();
			q.pop();
			q.push(x);
			ans+=x;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

接下来是复杂度证明，因为每次合并后数量最多乘2，也就是说，数据范围可以至少缩小6倍，所以能过QWQ

---

## 作者：china·xyc (赞：10)

#### 题面
题面不说了，简而言之就是在O(N)的时间内求Huffman树。
#### 题解
首先，求Huffmam树最基本的，每次要在集合里找到最小的，这其实就包含了排序。也就是说，在之前O(NlogN) 的方法中，我们处理的问题的一个子问题就是排序。既然要排序，还要O(N)时间，那肯定是要桶排。

考虑如何把排序的过程从之前的过程中提取出来，优先算完，再算其他的。可以排完序，然后把序列前两个（默认是二叉Huffman树）取出来求和再加入序列，然后不断重复这个过程，直到序列中只有一个元素为止。再加入队列的过程可以用二分来O(NlogN)实现，但这并不是最快的。

可以把需要插入队列的元素当成一个集合，在每次计算答案（把序列前两个取出来求和）就相当于把（序列和集合中的元素）（断句）的前两个取出来求和再加入集合，只需要把每个集合中的数与序列第一个作比较，选出最小的。由于集合中的数最多有(N-1) 个，所以复杂度O(N^2)。

但是，如果能够把集合中的数排序，那每次就只需要比较集合中最大的和序列中最大的就好了，复杂度又变成了O(NlogN)（排序logN）。

这个时候，我们会发现，每次加入集合的数总是比上次加入集合的数大（可以理解为序列$\{a_1,a_2,a_3,a_4.....\}$，$a_1<a_2<a_3<a_4<....$，这样$a_1+a_2$总小于$a_3+a_4$，$a_n+a_{n+1}$总小于$a_{n+2}+a_{n+3}$），也就是说不需要排序，集合就能保证单调递增， 复杂度O(N)。

代码实现应该不难，这里直接贴代码了。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fastio{
	template<typename tn> void read(tn &a){
	    tn x=0,f=1;char c=' ';
	    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	    for(;isdigit(c);c=getchar() ) x=x*10+c-'0';
	    a=x*f;
	}
	template<typename tn> void print(tn a){
	    if(a<0) putchar('-'),a=-a;
	    if(a>9) print(a/10);
	    putchar(a%10+'0');
	}
};
using namespace fastio;
#define int long long
const int M=1e5+5;
int b[M],a,n,ans=0;
queue<int> q1,q2;
int find(){
	int x;
	if((q1.front()<q2.front()&&!q1.empty())||q2.empty()){
        x=q1.front();
		q1.pop();
    }
    else {
        x=q2.front();
		q2.pop();
    }
    return x;
}
signed main(){
	read(n);
	for(int i=1;i<=n;i++) read(a),b[a]++;
	for(int i=1;i<M;i++) while(b[i]) b[i]--,q1.push(i);
	for(int i=1;i<n;i++){
		int x=find();
		int y=find();
		q2.push(x+y);
		ans+=x+y;
	}
	printf("%lld\n",ans);
	return 0;
}
```
PS：这题极坑，不开longlong见祖宗

---

## 作者：ycy1124 (赞：4)

### 题意
在一个果园里有 $n$ 个果子，每个果子都有一个大小 $a_i$，每次选择两个果子合并，合并所需的力气为两个果子的大小之和，现在要求合并所有果子所需花费的最小力气。
### 思路
首先考虑合并的顺序，我们一定是每次合并当前最小的两个果子是最优的。证明：我们发现我们可以将合并的过程抽象成一颗二叉树，两个兄弟节点就代表这两个节点合并了。我们发现，每个叶子节点的贡献等于 $a_i\times h_i$，$h_i$ 就是这个叶子节点的深度。不难发现将最小的节点放在最深处最优。而最深的节点就是在从下往上合并时最先合并的节点，也就是说你每次将最小的两个节点最先合并其实就等于将他们放到了二叉树的最深处。

考虑如何快速找到最小的两个果子，由于此时的 $n$ 非常大，每次都重新排序必定是会超时的。于是我们考虑其他的方法。对于原本我们已经排好序的原序列，从中取走最小的一到两个对于后面的顺序是没有影响的，于是我们可以将新合并出来的果子分开来考虑。由于每次合并的两个果子都是最小的，所以我们合并出来的果子的大小肯定是越来越大的，于是我们可以拿一个队列来存储后面新合并出来的果子，这个队列一定是单调不降的。每次寻找最小的值也只需要在这个队列以及原有的果子中找即可。
### 代码
由于普通排序复杂度爆炸，又由于 $a_i$ 的值不大，于是可以桶排实现。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
queue<int>a;
queue<int>b;
int ans,n,c[100005];
inline int read(){//快读，不加会超时
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x*=10;
		x+=ch-'0';
		ch=getchar();
	}
	return x;
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++){//桶排
		c[read()]++;
	}
	for(int i=1;i<=100000;i++){//将排好序的原序列存入一个队列当中。
		while(c[i]--){
			a.push(i);
		}
    }
	for(int i=1;i<n;i++){
		int w=0;
		for(int j=1;j<=2;j++){
			if(a.size()&&b.size()){
				if(a.front()<b.front()){
					w+=a.front();
					a.pop();
				}
				else{
					w+=b.front();
					b.pop();
				}
			}
			else if(a.size()){
				w+=a.front();
				a.pop();
			}
			else{
				w+=b.front();
				b.pop();
			}
		}
		b.push(w);
		ans+=w;
	}
	printf("%lld",ans);
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/203837913)。

---

## 作者：WsW_ (赞：2)

### 思路
请先了解[本题弱化版](https://www.luogu.com.cn/problem/P1090)中的贪心思路，接下来讲如何通过本题。  
发现后合并的两堆果子一定比先合并的两堆果子都要重，所以合并完了，后合并出来的那堆也一定比先合并的那堆要重。  
于是发现每次往堆里面插入的值具有单调性，先插入的小。发现这个性质后，就不需要用堆来维护了，可以直接往一个队列里面插入，队列中前面的元素先插入，也就小一些。  

发现值域较小，所以使用计数排序，就不需要排序的 $\log$ 了。  

时间复杂度为 $O(A+n)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
namespace fastIO {
#define BUF_SIZE 100010
    bool IOerror = 0;
    inline char nc() {
        static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
        if(p1 == pend) {
            p1 = buf;
            pend = buf + fread(buf, 1, BUF_SIZE, stdin);
            if(pend == p1) {
                IOerror = 1;
                return -1;
            }
        }
        return *p1++;
    }
    inline bool blank(char ch) {
        return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
    }
    inline void read(int &x) {
        char ch;
        while(blank(ch = nc()));
        if(IOerror)
            return;
        for(x = ch - '0'; (ch = nc()) >= '0' && ch <= '9'; x = x*10 + ch - '0');
    }
#undef BUF_SIZE
};
using namespace fastIO;
using namespace std;
queue<ull>q2;
queue<int>q1;
ull ans;
int a,n,t[100005];

ull get(){
	bool f1=q1.empty(),f2=q2.empty();
	ull x;
	if(f2||(!f1&&(q1.front()<=q2.front()))){
		x=q1.front();
		q1.pop();
	}
	else{
		x=q2.front();
		q2.pop();
	}
	return x;
}

int main(){
	read(n);
	for(int i=1;i<=n;i++){
		read(a);
		t[a]++;
	}
	for(int i=1;i<=100000;i++){
		if(t[i]>0){
			while(t[i]--)q1.push(i);
		}
	}
	for(int i=1;i<n;i++){
		ull x=get()+get();
		ans+=x;
		q2.push(x);
	}
	printf("%llu",ans);
	return 0;
}
```

---

## 作者：jscaj0921 (赞：2)

# 思路

题目里很明显点明了，这题数据范围比较大。这个数据范围，用堆也会炸。虽然数据范围比较大，但思路和这题的弱化版一样，都是贪心。因为先合并的果子变成一堆之后，继续合并还是要耗费体力，所以就要尽可能的让最开始合并的果子个数少，就可以让总体力变小。

思路已经定了，就看实现了。

## 排序

这个数据，快排和堆都会爆，就只能换一种排序方式了。通过读题，发现每堆果子的个数较少，于是可以考虑桶排序。桶排序的时间复杂度在这里是够的，重点到了合并上面。

## 合并

堆的作用无非就是自动排序，现在已经排序好了，就可以用队列代替了。定义两个队列，一个存没合并的，另一个存合并之后的。每次取最小值相加，存入第二个队列就可以实现像堆一样的效果了。

最后提一嘴，因为数据太大，所以要用快读。

# 代码

```cpp
#include <iostream>
#include <queue>
#include <cstdio>
using namespace std;
int box[100005];
queue<long long> q1, q2;
void read(int &x)
{
    x = 0;
    char c = getchar();
    while ('0' <= c && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
}
long long fun()
{
    long long x;
    if (q2.empty() || (!q1.empty() && q1.front() < q2.front()))
    {
        x = q1.front();
        q1.pop();
        return x;
    }
    else
    {
        x = q2.front();
        q2.pop();
        return x;
    }
}
int main()
{
    int n;
    read(n);
    for (int i = 1; i <= n; i++)
    {
        int a;
        read(a);
        box[a]++;
    }
    for (int i = 1; i <= 100000; i++)
    {
        for (int j = 1; j <= box[i]; j++)
        {
            q1.push(i);
        }
    }
    long long ans = 0;
    for (int i = 1; i < n; i++)
    {
        long long sum = 0;
        sum += fun();
        sum += fun();
        q2.push(sum);
        ans += sum;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：sbh2012 (赞：1)

## 思路
如何实现 $O(n)$ 做法，具体为什么是从小到大合并可以见[我之前的题解](https://www.luogu.com.cn/article/687hf8om)，现在重点讲优化，之所以现在不能用优先队列，是因为之前每次合并都需要再堆排一次，那如何优化呢？我们可以先桶排，接下来开两个队列，一个记录原本从小到大的果子，另一个记录合并后的果子，应为先合并的果子比和合并的小，所以就能保证单调性，队头的果子一定更小。这样每次在两个队列中总共取两个最小的果子，合并到第二个队列里即可。复杂度 $O(n)$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005],sum,x,y,n;
queue<long long> q1,q2;
inline long long read(){
	long long x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
        int x;
		x=read();
        a[x]++;
    } 
	for(int i=1;i<=1e5;i++){
        while(a[i]--){
            q1.push(i);
        }
    }	
	for(int i=1;i<n;i++){
		if((q1.front()<q2.front()&&!q1.empty())||q2.empty()){
			x=q1.front();
            q1.pop();
        }else{
            x=q2.front();
            q2.pop();
        }
		if((q1.front()<q2.front()&&!q1.empty())||q2.empty()){
			y=q1.front();
            q1.pop();
        }else{
            y=q2.front();
            q2.pop();
        }
        sum+=x+y;
        q2.push(x+y);
	} 
	cout<<sum;
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

这里重点说明优化的方法，对于证明不在赘叙。

本题要求 $O(n)$ 做法，想一下原题的瓶颈是优先队列。用优先队列是为了保证有序，因为贪心策略是每次选最少的两堆合并，我们现在需要换一种数据结构动态维护序列最小值。

我们可以用两个普通队列代替，一个存原序列，另一个存合并后的序列。这里 $a_i \le 10^5$，原序列我们可以桶排保证有序，先合并的一定比后合并的小，合并后的序列也是有序的。那么当前的最小值就是两队列的队首的最小值，这样就 $O(n)$ 解决了。

手写队列似乎优化不大，但是快读优化很明显。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int read (int x) { 
	for (char s=getchar(); s>='0'&&s<='9'; x=x*10+s-'0', s=getchar()) ;
	return x;
}
long long a[100005], ans, x, y;
queue<long long> q1, q2;
int main () {
	int n=read(0);
	for (int i=1; i<=n; i++) 
		a[read(0)]++;
	for (int i=1; i<=1e5; ++i)
		while (a[i]--) 
			q1.push(i);
	for (int i=1; i<n; ans+=x+y, q2.push(x+y), ++i) {
		if ((q1.front()<q2.front()&&!q1.empty())||q2.empty())
			x=q1.front(), q1.pop();
		else 
			x=q2.front(), q2.pop();
		if ((q1.front()<q2.front()&&!q1.empty())||q2.empty())
			y=q1.front(), q1.pop();
		else  
			y=q2.front(), q2.pop();
	} 
	cout << ans;
	return 0;
}
```

---

## 作者：luogu_gza (赞：0)

贪心思路是显然的，每次合并最小的两堆。

不难注意到每次合并出来的堆的大小是单调不降的。

我们把数分为两类，用队列维护被合并出来的数和还没被合并过的数（已经排序），每次合并的时候直接在两个队列队头取最小值即可。

排序使用桶排序，复杂度 $O(n)$。

```cpp
const int N=1e7+10;
int n,ans;
int a[N],ma[N];
queue<int> q1,q2;
int get()
{
  if(q2.empty()||(!q1.empty()&&q1.front()<q2.front())){int x=q1.front();q1.pop();return x;}
  int x=q2.front();q2.pop();return x;
}
void main(){
  n=R;
  fo(i,1,n) a[i]=R,ma[a[i]]++;
  fo(i,1,1e5) fo(j,1,ma[i]) q1.push(i);
  while(q1.size()+q2.size()>=2)
  {
    int x=get(),y=get();
    q2.push(x+y),ans+=x+y;
  }
  write(ans);
}
```

---

## 作者：x11223344 (赞：0)

首先，贪心策略就是每次选最小的两堆果子合并。
## 30 分做法
每次暴力枚举找最小值和次小值。
## 60 分做法
使用一个优先队列在 $O(\log n)$ 的时间复杂度找最小值和次小值。
## 正解
可以使用两个队列 $q1$ 和 $q2$，其中 $q1$ 存排好序后的 $a$ 数组，$q2$ 初始为空。  
对于每次合并：  
1. 取两次最小值，每次比较 $q1$ 和 $q2$ 的队首，如果 $q1$ 的队首更小那么就取 $q1$ 的队首并弹出，否则就取 $q2$ 的队首并弹出。
2. 合并取出的两个数，放入 $q2$。

以下证明 $q2$ 永远单调递增：  
因为每次取出的都是最小值，所以其他的数都比这两个数大，又因为 $q2$ 永远存的是合并后的结果，而且 $q1$ 已经排好序了，所以 $q2$ 永远单调递增。

但是，直接使用 sort 函数的时间复杂度依旧是 $O(n \log n)$，但发现果子的重量都不超过 $10^5$，因此可以使用时间复杂度为 $O(n+V)$ 的计数排序，其中 $V$ 是值域，本题中 $V=10^5$。  
注意：本题时间卡得很紧，需要使用快速读入。

---

## 作者：cwxcplh (赞：0)

这道题很简单，有一道和它类似的题，如果没做过[这道题](https://www.luogu.com.cn/problem/P1090)可以先去做做。

首先看到合并两字，我立马想到了区间动规，可一看数据点瞬间就打消了这个念头（如果不信邪可以看[这里](https://www.luogu.com.cn/record/202782085)）。

那么求最值就还剩一种办法——贪心！

要贪心首先就要排序，题目中让我们求最小，我们把原数组从小到大排序就对了，这里我选用了桶排。

然后我们在脑子里模拟一遍合并的过程，我们仔细想就会发现：当我们把两堆合在一起时就成了一堆。这句话看上去是废话，但能想到这已经离正确答案不远了。

按照上面的思路，我们可以把原数组中的前两位先取出来做加法，然后排序，一直这个过程，直到合成了一堆为止。但这样做太慢了，需要再狠狠优化一下。仔细思考很容易发现：因为原数组是按照从小到大的顺序，所以我靠后的相邻的两堆之和一定大于前两堆。换成数学符号就是：

$$a_1+a_2\lt a_3+a_4\lt a_5+a_6\dots$$

证明也很好证明，这里就不过多赘述了。

我们惊奇的发现：这个相邻两项的和的规律竟然和原数组是一样的！那我们再开一个数组去保存这个相邻两项之和不就行了？每次只需要取两次两数组头的最小值就可以计入答案了。

**代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,n2,sum,a[10000006],b[10000006],t[100006];
int kd() {//一定记得写快读
	int z=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-') {
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		z=z*10+c-'0';
		c=getchar();
	}
	return z*f;
}
signed main() {
	memset(a,0x3f,sizeof(a));
	memset(b,0x3f,sizeof(b));
	n=kd();
	for(int i=1; i<=n; i++) {
		a[i]=kd();
		t[a[i]]++;
	}
	for(int i=1,j=0; i<=100000; i++) {
		while(t[i]) {
			a[++j]=i;
			t[i]--;
		}
	}
	int w=0;
	for(int i=1,j=1,k=1; k<n; k++) {
		w=0;
		for(int l=1; l<=2; l++) {
			if(a[i]<b[j]) {
				w+=a[i];
				i++;
			} else {
				w+=b[j];
				j++;
			}
		}
		b[++n2]=w;
		sum+=w;
	}
	cout<<sum;
	return 0;
}
```

---


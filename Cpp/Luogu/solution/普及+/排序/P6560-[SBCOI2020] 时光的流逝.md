# [SBCOI2020] 时光的流逝

## 题目背景

时间一分一秒的过着，伴随着雪一同消融在了这个冬天，  
或许，要是时光能停留在这一刻，该有多好啊。  
......    
“这是...我在这个小镇的最后一个冬天了吧。”  
“嗯，你可不能这辈子都呆在这个小镇吧。外面的世界很大呢，很大很大...”  
“唔...外面的世界...突然有点期待呢！”  
“总有一天，你会走得很远很远。以后你可不要忘记这个小镇那。”  
“不会的，至少...这里曾经是我最快乐的一段回忆呢！你也一定不要忘记我呀。”   
“你看，这雪花。传说，每当世界上有一份思念，便会化成一片雪花在这里飘落。”   
“那...以后你可一定要找到我的那片雪花啊......”  
![](https://cdn.luogu.com.cn/upload/image_hosting/orzntcy6.png)    
“嗯，不如我们一起在这个冬天创造最后一段回忆吧。”  
“好呀，我们玩个游戏吧......”  

## 题目描述

这个游戏是在一个有向图（不保证无环）上进行的。每轮游戏开始前，她们先在图上选定一个起点和一个终点，并在起点处放上一枚棋子。

然后两人轮流移动棋子，每次可以将棋子按照有向图的方向移动至相邻的点。

如果谁先将棋子移动至终点，那么谁就胜利了。同样，如果谁无法移动了，那么谁就失败了。

两人轮流操作，请问，他们是否有必胜策略呢？  

答案为一个整数 `0` 或 `1` 或 `-1`，其中 `1` 表示（先手）有必胜策略，`-1` 表示后手有必胜策略，`0` 表示两人均无必胜策略。

## 说明/提示

#### 样例解释 $#1$

![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

为描述题意，假设两人为 A（先手）和 B

如图，A 先走，走到 $2$，B 走到 $3$，接下去 A 可以选择走到 $4$ 或 $6$，若走到 $4$，接下去 B 可以走到终点，故不可取。若选择走到 $6$，那么 B 只能走到 $7$，A 可以走到终点。所以 A 有必胜策略。

#### 样例解释 $#2$

![](https://cdn.luogu.com.cn/upload/image_hosting/9yjnyye3.png)

如图，起点为 $1$，终点为 $5$ 时， A 和 B 会沿着 $1-2-3-1$ 的顺序轮流走。因为如果谁先走到 $4$，那么下一个人就可以走到终点。故谁都没有必胜策略。

起点为 $4$，终点为 $3$ 时，A 先走到 $5$，B 无路可走，故 B 失败。

#### 数据范围

对于 $10\%$ 的数据，保证图是一条链。

对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。

## 样例 #1

### 输入

```
7 7 1
1 2
2 3
3 4
4 5
3 6
7 5
6 7
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5 2
1 2
2 3
3 1
3 4
4 5
1 5
4 3```

### 输出

```
0
1```

# 题解

## 作者：犇犇犇犇 (赞：27)

这里是官方题解qaq  
这道题其实本质就是个图上的博弈论   
核心就是标记必胜点和必败点，只要对着图手动操作一遍就有思路了。个人认为思维难度并不大，但是貌似代码实现上的细节比较多  

### 对于 $10\%$ 的数据，保证图是一条链。  
由于是一条链，所以情况是唯一的，直接链表模拟即可。具体见代码。  

代码：  
```
#include <bits/stdc++.h>
using namespace std;
int n,m,q,nxt[500005],a,b;
int main()
{
	cin>>n>>m>>q;
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b;
		nxt[a]=b; //由于是链表
	}
	for(int i=1;i<=q;i++)
	{
		cin>>a>>b;
		int k=-1,x=a,f=0; //x表示当前位置，k表示当前走棋的人
		while(nxt[x])
		{
			k=-k; //每次转换走棋的人
			x=nxt[x]; //走到下一个位置
			if(x==b) //到终点
			{
				cout<<k<<endl;
				f=1;
				break;
			}
		}
		if(!f)
			cout<<k<<endl; //如果走到终点，则无法动的人输
	}
	return 0;
}
```

不难发现这个题是个图上的博弈论的问题。我们自然可以考虑到在图上标记必胜点以及必败点。  
首先终点为必败点，所有出度为0的点均为必败点，然后所有能一步到达必败点的点为必胜点，下一步**只能**到必胜点的点为必败点。于是我们便可以根据这个规则给所有点标记，最后如果起点没有标到，那么就平局。  

给张图理解下： 
这里有一张图，终点为 $10$，我们从终点开始判断起点的情况。其中必败点标记为红色，必胜点标记为蓝色。    
![](https://cdn.luogu.com.cn/upload/image_hosting/mro6bduh.png)

首先，终点10为必败点。9,5能到达10，所以9，5为必胜点。  
7，4由于是死路（及走到这个点无路可走）为必败点，标记为红色，于是3，6能到达4，7，故为必胜点。  
8能到达的所有点(6)均为必胜点，所以8为必败点。  
1能到达必败点8，所以1为必胜点。  
2能到达的所有点(1)均为必胜点，所以2为必败点。  
这样我们就能得到所有起点的情况了。

### 对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。  
这一档主要就是对于上面那种方法比较暴力的解决方法。每次暴力枚举所有点，看看是否能更新，知道不能更新为止。复杂度 $O(qn^2)$  

### 对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

这一档就是给一些常数比较大的做法，或者是一些玄学带 log 做法的做法。比如用优先队列判断度数最小的点以及，起点终点搜两遍的做法。  

### 对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。  
我们可以发现只要一个点的所有出点的状态（即确定是否为必胜点或必败点）时，那个点的状态我们便能确定。因为若它有一条边指向必败点，则它为必胜点。若它所有边都指向必胜点，那么他就是必败点。所以我们就能想到然后建反向边（因为我们需要从已经确定的点去修改未知的点，即需要知道哪些点会通到它），用一个数组记录它的出度，一个数组记录当前的标记（必胜点或必败点）。  
我们用一个队列保存当前可以确定状态的点（即出度为0的点，由于我们只需要讨论反向边的图，所以这里出度即为原图的入度），如果找到一个必败点，那么立即修改所有能通到它的点，把这些点标记为必胜点，并且将能通到这些必胜点的点出度减一。同时我们在减去出度的时候看出度是否为0，如果为0，那么这个点的状态即可确定，放进队列。相当于将已经确定状态的点从图中删去。时间复杂度 $O(qm)$

关于这个时间复杂度，有人私信我说这个复杂度会不会TLE。其实我生成数据的时候在我本地电脑上跑了10s+，但是洛谷评测机上开个O2只用了500ms（我写T4数据的时候也是一样的情况）。

代码：  

```
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 5e5+5;
const int MAXM = 5e5+5;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;	
}
int n,m;
int p[MAXN],vic[MAXN],out[MAXN];
int cnt,head[MAXM],f[MAXN],d[MAXN];
struct edge
{
	int v,nxt;
}e[MAXM*2];
inline void addedge(int u,int v)
{
	cnt++;
	e[cnt].v=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
queue<int> q;
void del(int u)
{
	f[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		d[v]--;
		if(d[v]==0)
			q.push(v);
	}	
} //当前点已经确定状态点删去
int main()
{
	int Q;
	n=read();m=read();Q=read();
	for(int i=1;i<=m;i++)
	{
		int a,b;
		a=read();b=read();
		addedge(b,a); //建反向边
		p[a]++;  //入度
		out[b]++; //出度
	}
	while(Q--)
	{
		int x,y;
		while(!q.empty()) q.pop();
		x=read();y=read();
		memset(f,0,sizeof(f)); 
		memset(d,0,sizeof(d));
		memset(vic,0,sizeof(vic)); //初始化
		for(int i=1;i<=n;i++)
		{
			d[i]=p[i];
			if(p[i]==0) 
				q.push(i); //若当前点出度为0，放进队列
		} 
		q.push(y); //将终点放进队列
		vic[y]=1; //终点为必败点
		while(!q.empty())
		{
			int u=q.front();
			q.pop();
			if(f[u]==1) 
				continue; //已经被访问过
			if(vic[x]!=0)
				break; //小优化，若起点状态已经确定，那就不需要继续搜索了
			del(u); //u已经能确定状态了，将它删去
			if(vic[u]==1)//如果u为必败点，那么所有能通往它的点为必胜点  
			{
				for(int i=head[u];i;i=e[i].nxt) 
				{
					int v=e[i].v;
					if(vic[v]==0)
					{
						vic[v]=-1;
						del(v); //v为必胜点，状态确定，将它删去
					}
				}	
			}
			else if(out[u]==0)
			{
				vic[u]=1; //若u在原图出度为0，则为必败点
			}
			else //u状态未确定
			{
				vic[u]=1; //u能走到的所有点为必胜点，u为必败点
				for(int i=head[u];i;i=e[i].nxt) //将所有能通到必败点标为必胜点
				{
					int v=e[i].v;
					if(vic[v]==0)
					{
						vic[v]=-1;
						del(v); //删去
					}
				}		
			}		
		}
		cout<<-vic[x]<<endl; //输出起点状态
	}
	return 0;
} 
```


---

## 作者：duyi (赞：25)

# WoW ↓


[超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超爽的阅读体验](https://www.cnblogs.com/dysyn1314/p/13329521.html)


## 题目大意

[题目链接](https://www.luogu.com.cn/problem/P6560)

给定一个$n$个点，$m$条边的有向图（**不保证无环**）。$q$次询问。每次指定一组起点和终点，并在起点处放一枚棋子。

有两个游戏玩家，轮流移动棋子（只能顺着图上的边移动，每人每次只能移动一步）。

先将棋子移动到终点的人立即获胜。如果谁无法继续移动了，那么他失败，对手获胜。

问先、后手是否有必胜策略。如果先手有必胜策略输出$1$，如果后手有必胜策略输出$-1$，如果两人都没有必胜策略输出$0$。

数据范围：$1\leq n\leq 10^5$，$1\leq m\leq 5\times 10^5$，$1\leq q\leq 500$。保证起点和终点不同。

## 本题题解

考虑，给出的图如果是一个DAG（无环），我们可以对反图做拓扑排序，同时推出答案。在反图上，所有入度为$0$的点，都是先手必败；询问给定的终点也是先手必败（因为距离它为$1$的点肯定是先手必胜了，所以可以把它理解为先手必败）。然后对于其他点，如果存在至少一个能到达它的点，是先手必败的，那么它先手必胜；否则它是先手必败。这样递推一下就能求出答案了，时间复杂度是$O(qm)$的。

再考虑有环的情况。有环和无环最大的区别是，正常的拓扑排序时，我们无法进入到环里。那么一个环，就可能“**隔绝**”一些已知的答案。具体来说，对于某个节点：

- 如果（在反图上）至少存在一个能到达它的点是先手必败的，那该节点一定是**先手必胜**的。无论**它在不在环上，入度是否为$0$**，我们都把它加入到队列里，并且之后不再访问它（一个点不能入队两次）。
- 如果没有发现，至少一个，能到达它的、先手必败的点。那么我们看当前节点入度是否已经清零。如果已经清零，说明它不在环上，而且我们已经考虑过了所有能到达它的边，因此可以直接断定它是**先手必败**的，然后加入队列即可。
- 如果它的入度还没有清零，说明它一定在某个环上。这种情况下先、后手都可以在环上无限地绕圈。所以此时该节点的状态是**未知**的。

整个过程，和普通的拓扑排序还是很类似的。主要的区别是，一旦确定了一个节点的状态（必胜或必败），就立即加入到队列中，并且从此不再访问它。这样可以避免“环”对传递答案造成的不必要的“隔绝”。根据这个原则，我们初始时也会把终点加入到队列中，无论它入度是否为$0$，因为我们前面说过，终点一定是先手必败的。

时间复杂度$O(qm)$。

参考代码：

```cpp
//problem:P6560
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T>inline void ckmax(T& x,T y){x=(y>x?y:x);}
template<typename T>inline void ckmin(T& x,T y){x=(y<x?y:x);}

const int MAXN=1e5,MAXM=5e5;
struct EDGE{int nxt,to;}edge[MAXM+5];
int head[MAXN+5],tot;
inline void add_edge(int u,int v){edge[++tot].nxt=head[u],edge[tot].to=v,head[u]=tot;}

int n,m,q,in_degree[MAXN+5],cur_deg[MAXN+5],st,ed,f[MAXN+5];

int main() {
	cin>>n>>m>>q;
	for(int i=1;i<=m;++i){
		int u,v;
		cin>>u>>v;
		add_edge(v,u);//反向边
		in_degree[u]++;
	}
	for(int tq=1;tq<=q;++tq){
		cin>>st>>ed;
		queue<int>que;
		for(int i=1;i<=n;++i){
			cur_deg[i]=in_degree[i];
			if(!cur_deg[i] || i==ed)
				f[i]=-1,que.push(i);
			else
				f[i]=0;
		}
		while(!que.empty()){
			int u=que.front(); que.pop();
			for(int i=head[u];i;i=edge[i].nxt){
				int v=edge[i].to;
				if(f[v]!=0)continue;
				cur_deg[v]--;
				if(f[u]==-1){
					f[v]=1;
					que.push(v);
				}
				else if(!cur_deg[v]){
					if(f[v]!=1)
						f[v]=-1;
					que.push(v);
				}
			}
		}
		cout<<f[st]<<endl;
	}
	return 0;
}
```


---

## 作者：Mine_King (赞：12)

个人认为是很好的博弈论的题 QWQ。

首先我们知道，在博弈中：如果一个局势不管怎么走都会变成**必胜局势**，那么这个局势就是**必败局势**；如果一个局势有一种走法会变成**必败局势**，那么这个局势就是**必胜局势**。  

然后，我们回到题目，想想如何判断一个点是必胜还是必败。首先，终点一定是必败的，因为当你遇到这个终点时，是对方先移到这里的。然后，如果一个点没有出度，就会无路可走，也是必败局势。接下来，我们就可以根据这些，反推其他点的情况。这时，我们就会想到建反图，因为需要反推回去。  
建反图之后，整个推的过程就是这样：

1. 把终点和没有入度（指在反图中，下同）的点标记为 $-1$（即必败），并入队。
2. 每次取出队首的点 $u$。
3. 遍历所有出边所连接的点 $v$。
4. 若 $v$ 已被标记为必胜或必败，回到3。
5. 若 $u$是必胜，则 $v$ 的入度减一。若此时 $v$ 的入度为 $0$，则把 $v$ 标记为必败，并入队。
6. 若 $u$ 是必败，则把 $v$ 标记为必胜，并入队。
7. 回到第 $2$ 步。

由于每次的终点都不一样，所以每次询问都要推一次。

**code:**
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,Q,in[100005],f[100005],kk[100005];
queue<int>q;
struct graph
{
	int tot;
	int hd[100005];
	int nxt[500005],to[500005];
	void add(int u,int v)
	{
		tot++;
		nxt[tot]=hd[u];
		hd[u]=tot;
		to[tot]=v;
		return ;
	}
}g;
int main()
{
	scanf("%d%d%d",&n,&m,&Q);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		g.add(v,u);//建反图
		kk[u]++;//记录入度
	}
	while(Q--)
	{
		int s,t;
		scanf("%d%d",&s,&t);
		memset(f,0,sizeof(f));
		memcpy(in,kk,sizeof(kk));
        //初始化
		for(int i=1;i<=n;i++)
			if(!in[i]||i==t) q.push(i),f[i]=-1;//将入度为0的点和终点入队
		while(!q.empty())
		{
			int x=q.front();
			q.pop();
			for(int i=g.hd[x];i;i=g.nxt[i])
				if(!f[g.to[i]])
				{
					if(f[x]==1)//当前点为必胜点
					{
						in[g.to[i]]--;//入度减一
						if(!in[g.to[i]]) q.push(g.to[i]),f[g.to[i]]=-1;
					}
					else q.push(g.to[i]),f[g.to[i]]=1;
				}
		}
		printf("%d\n",f[s]);//输出
	}
	return 0;
}
```

---

## 作者：阔睡王子 (赞：5)

### 博弈论与图论
首先看到题发现这道题是道很明显的图上博弈论，然后可以很快的想出可以根据两种特殊局面：“走到终点或者死胡同就赢了”，来反推图的状态。
- 首先明白一点，双方都是精明的博弈选手，都会采取最优的步骤来博弈，也就是说，当他们能赢，或者说存在能赢的方法时，他们一定会选这种方法。
- 也就是说：当一个情况无论怎么走都会输的，那么这个情况必输；
- 相对的，一个情况只要有一种解法能赢，那么这个情况必赢。
- 考虑到这是个双方轮换的游戏，让我跟你代入这把游戏，把上面的结论转换一下：
- 假如现在轮到我移动：
- 当一个情况怎么走都会输的话，那么到达这个情况所有走法必赢。因为这是双方轮换的游戏，如果有一种走法让你怎么走都会输的话，我肯定选择这种走法，然后我就能将军你了。
- 相对而言，如果一个情况如果有一种走法能赢，那么到达这个情况的所有走法必输，因为如果我这么走，就会让你抓住成功的把柄，顺利赢下游戏。

那么综上，可以推导出这个题的正解：稍作改变的拓扑序，能够解决带环的问题。
- 先读入图，反向建边；
- 然后建立一个队列，把死胡同（反向图中入度为零）和终点放进去，标记为必败，因为这个点的所有走法都会输，因为根本没有走法。
- 然后开始更新队列中点周围点的信息：
- 设当前点是 $u$ ， $u$ 正向图中能到达的点是 $v$ ；
1. 如果v的一切走法必败，那么可以确定走到 $v$ 是明智的，所以当你在 $u$ 时必定会走到 $v$ ，让你的对手吃瘪。把 $v$ 标记为必胜点（ $v$ 存在必胜的方法）。
2. 如果 $u$ 周围所有点都有必胜的走法，能确定 $u$ 是必败的，因为你 $u$ 怎么走都会让对手~~确立胜利的方程式~~
3. 如果 $u$ 周围有个点有必胜的走法，不能确定 $u$ 是必败的，因为 $u$ 周围也可能有必败点，让你能够~~干碎~~你的对手。
- 所以得出做法，对于一个点，如果它确定是必败点，那么他周围没被确定的点都能确定是必胜点；如果它是必胜点，那么它周围点的入度减一，如果入度都减为零了都还没被确定为必胜点，那么可以确定是必败点。
- 代码如下
```
while(q.size())
{		
	int u=q.front();
	q.pop();
	if(flag[u]==-1)//如果当前点必败
	{
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
		 	if(flag[v]==0)//如果还没被确定
		 	{
			 	flag[v]=1;//确定为必胜
				q.push(v);
			}
		}
	}
	else if(flag[u]==1)//如果当前点必胜
	{
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(flag[v]==0)//如果没被确定
			{
			 	rd[v]--;//入度减一
				if(rd[v])//如果还没被确定
				{
					flag[v]=-1;
					q.push(v);
				}
			} 
		} 	
	}
}
```
由于有多组起点与终点，所以要做 $q$ 次推导，每次都要备份入度（建立拷贝），以及清空标记。时间复杂度为 $O(nq)$。
```
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=100010,maxm=500010;
struct node
{
	int to,next;
}e[maxm];
int head[maxn],rd[maxn],copy_rd[maxn],cd[maxn],cnt;
void build(int a,int b)//反向建图 
{
	e[++cnt].to=b;
	e[cnt].next=head[a];
	head[a]=cnt;
	cd[a]++;rd[b]++;
}
int n,m,d,flag[maxn];
int main()
{
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		build(y,x);
	}
	queue<int>q;
	for(int i=1;i<=d;i++)
	{
		int s,t;
		scanf("%d%d",&s,&t);
		for(int j=1;j<=n;j++)
		{
			flag[j]=0;
			copy_rd[j]=rd[j];//建立拷贝
			if(!rd[j] || j==t)
			{
				q.push(j); 
				flag[j]=-1;
			}
		}
		while(q.size())
		{
			int u=q.front();
			q.pop();
			if(flag[u]==-1)
			{
				for(int i=head[u];i;i=e[i].next)
				{
					int v=e[i].to;
				 	if(flag[v]==0)
				 	{
					 	flag[v]=1;
						q.push(v);
					}
				}
			}
			else if(flag[u]==1)
			{
				for(int i=head[u];i;i=e[i].next)
				{
					int v=e[i].to;
					if(flag[v]==0)
					{
					 	copy_rd[v]--;
						if(!copy_rd[v])
						{
							flag[v]=-1;
							q.push(v);
						}
					} 
				} 
			}
		}
		printf("%d\n",flag[s]);
	}
}
```



---

## 作者：Mooncrying (赞：2)

算是 2023 省选 Day 2 T1 的弱化版吧。

~~把它过了，算是对省选寄掉的安慰~~。

这里是[题目传送门](https://www.luogu.com.cn/problem/P6560)。

### 题目大意

- 给定一个 $n$ 个点 $m$ 条边的有向图，分别对于 $q$ 个给定的起点和终点，求出是否存在先手（后手）必胜策略。

- $1 \le n \le 10 ^ {5}$，$1 \le m \le 5 \times 10 ^ {5}$，$1 \le q \le500$。

### 分析

- 这大抵是一道不错的简单博弈论问题。

- 首先容易看出这不是一个 ICG 游戏（公平组合游戏），用不到 SG 函数。

- 然后这肯定是一个有向图游戏。

	（以上均为废话）

- 我们考虑怎样找到该游戏的状态。

- 考虑到图已经给出，状态明确（状态就是那一个棋子在图中的位置），我们直接类拓扑排序反向迭代。

	这么想的理由也很简单，就是只有一些特定状态的胜负情况我们是能够知道的。
    
   对于这些特定的状态，我们通过反向推导就能够得知所有状态的胜负情况。
   
   判断方法：
   
   > 一个状态为**先手必胜**，当且仅当其一次移动的所有后继状态中至少有一个状态为**先手必败（即后手必胜）**。
   
   > 一个状态为**先手必败**，当且仅当其一次移动的所有后继状态均为**先手必胜（即后手必败）**。
   
   > 后手同理。
   
- 首先反向建边，并求出每个点的入度。
   
- 然后先把终点和入度为 $0$ 的点加入队列，标记该状态为先手必败（即后手必胜）。

	因为到终点和走到尽头都是让先手无路可走，即先手必败。
    
- 然后对于每个队首状态 $u$ 以及它的所有出边连接的状态 $v$：

	1. 若 $v$ 已经进入过队列中，则继续遍历其他出边（避免有环导致的死循环）；
   
   2. 若 $u$ 为先手必胜，则 $v$ 的入度减去 $1$。当 $v$ 的入度为 $0$ 时，说明 $v$ 的所有后继状态均为先手必胜（因为反向建边，入度代表后继），则把 $v$ 标记为先手必败，并加入队列；
   
   3. 若 $u$ 为先手必败，则把 $v$ 标记为先手必胜，并加入队列。
   
   （注：所有进入队列的状态均为必胜或必败状态。）
   
   这种思想和方法是通用的。
   
- 最后输出起点的状态即可。

- 一点说明：该方法能够遍历到**所有的必胜和必败情况**，未被标记的状态**必为平局**。
    
    朴素的解释就是：根据判定必胜和必败的条件，我们已经找到了所有满足判定条件的状态并给出了判定，那么其他状态我们无法得到其到底是必败还是必胜。根据朴素的排除法，当我们无法判定一个状态是必胜还是必败的时候，那么它只能是平局了。
    
- 分析结束。

#### 下面是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
const int M = 5e5 + 5;
int cnt, last[N], pre[M], to[M], jud[N], ind[N], n, m, T, st, ed, temp_ind[N]; bool vis[N];
// ind 和 temp_ind 数组都是入度
// jud 数组表示棋子在每一个位置的胜负情况，1 为先手必胜，-1 为先手必败（后手必胜），0 为平局
template <typename T> inline void read(T &x)
{
	T f = 1; x = 0; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
	x *= f;
}
template <typename T> inline void write(T x, char ch)
{
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) write(x / 10, 0); putchar(x % 10 + '0');
	if(ch == '\n') putchar('\n');
}
inline void add(int u, int v)
{
	pre[++cnt] = last[u];
	last[u] = cnt;
	to[cnt] = v;
}// 前向星存图，常数较小
void init()
{
	memcpy(ind, temp_ind, sizeof(temp_ind));
	memset(vis, 0, sizeof(vis));
	memset(jud, 0, sizeof(jud));
}// 多次询问记得初始化
void topo()
{
	queue<int> q;
	for(int i = 1; i <= n; ++ i) 
		if(i == ed || !ind[i]) q.push(i), jud[i] = -1, vis[i] = 1;
	while(!q.empty())
	{
		int u = q.front(); q.pop();
		for(int p = last[u]; p; p = pre[p])
		{
			int v = to[p];
			if(vis[v]) continue;
			if(jud[u] == 1) 
			{
				ind[v]--;
				if(!ind[v]) jud[v] = -1, vis[v] = 1, q.push(v);
			}
			else jud[v] = 1, vis[v] = 1, q.push(v);
		}
	}
}
int main()
{
	read(n); read(m); read(T);
	for(int i = 1, u, v; i <= m; ++ i)
		read(u), read(v), add(v, u), ++temp_ind[u];
	while(T--)
	{
		init(); read(st); read(ed); topo();
		write(jud[st], '\n');
	}
	return 0;
}
```
等等，还没结束！

感兴趣的同学可以去尝试一下 [2023 年的这道省选题](https://www.luogu.com.cn/problem/P9169)。

这个题与本题相比最大的难点就是没给出状态连接图，需要通过一次 bfs 自己建一张反图，十分考察代码能力，~~于是我省选寄了呜呜~~。

好的，这下真的结束了。886~

---

## 作者：_shine_ (赞：2)


## 思路
先来看没有输出 $0$ 的情况。

[![p9kXZc9.png](https://s1.ax1x.com/2023/04/20/p9kXZc9.png)](https://imgse.com/i/p9kXZc9)

上图为样例一解释的图片。

现在定义 $f_i$ 为现在棋子在点 $i$，先手必败为 $1$，反之为 $-1$，举个例子，就样例一来说，$f_5=-1$，因为直接到了，没有了选择余地，而 $f_4=1$，并且 $f_7=1$，因为只需要走一步，先手必胜，我们可以得出一个结论，若点 $x$ 与点 $y$ 相连（$x$ 到 $y$），并且 $f_y=-1$，则 $f_x$ 一定等于 $1$，显然，我们只需要拓扑排序，查找那些入度为 $0$ 的点，并且广搜即可。

现在再来看输出 $0$ 的情况。

显然，出现 $0$ 的情况就是出现环了，但是，并不是所有的环都是输出 $0$，因为在前文已经说明了，若点 $x$ 与点 $y$ 相连（$x$ 到 $y$），并且 $f_y=-1$，则 $f_x$ 一定等于 $1$。那么，为什么呢？我们可以发现，如若这个环形中，没有与它相连的 $f_m$ 等于 $-1$ 时，自然不会成立，这种情况自然就会输出 $0$。

所以，我们可以在进行拓扑排序之后，剩下的环进行判断，查看是否存在 $f_m=-1$ 的情况即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')w=-1;ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*w;
}
inline void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)write(x/10);
    putchar(x % 10 + '0');
}
int n,m,q;
int  h[maxn],e[maxn],ne[maxn],idx;
int vis[maxn];
int f[maxn],in[maxn],out[maxn],d[maxn];
void add(int x,int y){
	e[++idx]=y;
	ne[idx]=h[x];
	h[x]=idx;
	in[y]++;
	out[x]++;
}
signed main(){
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;++i){
		int u=read(),v=read();
		add(v,u);
	}
	while(q--){
		queue<int>q;
		int x=read(),y=read();
		memset(f,0,sizeof(f));
		memset(vis,0,sizeof(vis));
		memset(d,0,sizeof(d));
		for(int i=1;i<=n;++i){
			d[i]=in[i];
			if(in[i]==0){
				q.push(i);
			}
		}
		q.push(y);
		f[y]=-1;
		while(q.size()!=0){
			int sum1=q.front();
			q.pop();
			if(vis[sum1]==1)continue;
			if(f[sum1]==-1){
				for(int i=h[sum1];i;i=ne[i]){
					int num=e[i];
					if(f[num]==0){
						f[num]=1;
						vis[num]=1;
						for(int i=h[num];i;i=ne[i]){//删点
							int how=e[i];
							d[how]--;
							if(d[how]==0){
								q.push(how);
							}
						}
					}
				}	
			}
			else if(out[sum1]==0){
				f[sum1]=-1;//先手不可能胜利
			}else{
				f[sum1]=-1;
				for(int i=h[sum1];i;i=ne[i]){
					int num=e[i];
					if(f[num]==0){
						f[num]=1;
						vis[num]=1;
						for(int i=h[num];i;i=ne[i]){//同样，删点
							int how=e[i];
							d[how]--;
							if(d[how]==0){
								q.push(how);
							}
						}
					}
				}				
			}
		}
		cout << f[x] << endl;
	}
	return 0;
}
```


---

## 作者：Phartial (赞：1)

经典有向图博弈。

假设先手现在在点 $x$，那么有如下几种情况：

- $x$ 为终点：这种情况虽然不会出现，但是考虑到前一步是先手必胜，故我们认为此时先手必败。
- $x$ 无出边：不能进行有效移动，先手必败。
- 出边中有一个点使得先手必败：由于我们认为先后手都是博弈带师，那么只要有一种走法能让另一个人必败，我们就一定会这样走使得自己必胜，故先手必胜。
- 出边中所有点都会使得先手必胜：无论怎么选都会导致另一个人必胜，故先手必败。

在 DAG 中这样就够了，但此题给出的有向图是有环的，所以我们还要考虑平局的情况：

- 若出边中没有点使得先手必败且有点使得平局：那么我们一定会选择平局而不是让另一个人获胜。此时平局。

于是考虑使用一个队列维护当前已经处理出答案的点，依次处理，对当前点：

- 若当前点先手必败：那么能到达它的所有点都是先手必胜。
- 若当前点平局：啥都不用考虑。
- 若当前点先手必胜：那么考虑维护每个点有多少条出边使得先手必胜，对所有能到达它的点更新此值，若所有出边都使得先手必胜则该点先手必败。

但这样是有问题的，考虑下面这组 hack 数据：

```
4 3 1

1 2
2 3
2 4

1 2
```

显然先手必胜，但由于 $3,4$ 这两个先手必败的点冲掉了 $2$ 这个先手必败的点的状态，使得我们认为 $2$ 是先手必胜的，导致答案错误。强制约定不能更新已有答案的点即可。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int kN = 1e5 + 1;

int n, m, q, f[kN], qx[kN], h, t, c[kN];
vector<int> e[kN], ie[kN];

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n >> m >> q;
  for (int i = 1, x, y; i <= m; ++i) {
    cin >> x >> y;
    e[x].push_back(y);
    ie[y].push_back(x);  // 建反向边
  }
  for (int sx, tx; q--;) {
    cin >> sx >> tx;
    h = 1, t = 0;
    for (int i = 1; i <= n; ++i) {
      c[i] = 0;                           // c[i] 维护点 i 的出边中有多少点是已经确定为必胜态的
      f[i] = -(e[i].empty() || i == tx);  // 若没有出边或位于终点时先手必败
      if (f[i]) {
        qx[++t] = i;
      }
    }
    for (; h <= t; ++h) {
      int x = qx[h];
      for (int y : ie[x]) {
        if (!f[y]) {
          if (f[x] == -1) {  // 若当前点先手必败，那么能到达它的所有点都是先手必胜
            f[y] = 1, qx[++t] = y;
          } else if (++c[y] == e[y].size()) {  // 若所有出边都使得先手必胜则该点先手必败
            f[y] = -1, qx[++t] = y;
          }
        }
      }
    }
    cout << f[sx] << '\n';
  }
  return 0;
}
```


---

## 作者：CQ_Bab (赞：1)

# 思路
这道题还是很有意思的，我们知道了这道题是博弈论，那么我们就根据题意定义一个 $f_i$ 为若以 $i$ 为首位那么是否必胜，我们就用 $f_i$ 中的值直接输出即可，那么我们就来看如何转移，我们对于没一个出度为 $0$ 的点都是必败的，那么我们就设当前点为 $x$ 他能到达的点为 $y$ 那么我们是不是只要 $f_y$ 为必败那么在它上面的那个点都一定能胜利（这个我相信大家都能理解），然后若我们将所有的 $y$ 都搜完了都没有点能够保证必胜那么不就是必败了吗？然后我们再来看如何判无法判断，这不就是存在环吗？那么我们对于环上所有点不都不会删除吗？除非它能连向一个不为换的点，那不也会被更新吗？所以我们不用管它，只需要将初值赋为 $0$ 即可，若最后没更新代表在换上即不能判断。

这里我们可以用拓扑排序与反向存边来帮助我们更好的更新。
# 代码
```
void add(int x,int y) { //建边
	edg[++tot]= {y,head[x]};
	head[x]=tot;
	in[y]++;
	inn[y]++;
}
void dfs() { //拓扑排序
	queue<int>q;
	rep(i,1,n) {
		if(!in[i]||i==t) {
			q.push(i);
			f[i]=-1;
		}
	}
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		for(int i=head[x]; i; i=edg[i].y) {
			int to=edg[i].x;
			if(f[to]!=0) continue;
			in[to]--;//删掉这个点
			if(f[x]==1&&!in[to]) { 
				f[to]=-1;
				q.push(to);
			}else if(f[x]==-1){ //更新
				f[to]=1;
				q.push(to);
			}
		}
	}
}
fire main() {
	read(n),read(m),read(q);
	rep(i,1,m) {
		int x,y;
		read(x),read(y);
		add(y,x);//反向存边
	}
	while(q--) {
		read(s),read(t);
		rep(i,1,n){
			f[i]=0;
			in[i]=inn[i];
		}
		dfs();
		cout<<f[s]<<endl; //输出
	}
	return false;
}
```

---

## 作者：OI_AKed_me (赞：1)

# P6560 [SBCOI2020] 时光的流逝的题解 #
[原题链接](https://www.luogu.com.cn/problem/P6560)

## 题意简述 ##
这道题其实就是在一个有向图（**不保证无环**）上做博弈，即无棋可走或走到终点算失败。
## 思路 ##
这题向对于最基础的博弈，其难点就在于不保证无环。显然，直接正着直接推只能拿到 $ 10 $ 分。那么我们就可以反过来做，即把通过已知的点去推未知的，直到把可以推的推完为止，若推不出来即为平局。

具体怎么推的如下：  
若该点对于先手方是必败点，则其父亲结点对于先手方是必胜点；若一个点的所有子节点对于先手方都是必胜点，则该点为必败点。

综上，这样就很容易想到拓补排序~~这题作为拓补排序的模版都不为过~~。

## 代码 ##
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ss stable_sort
#define inf INT_MAX
#define umap unordered_map
#pragma GCC opitimize(3)
using namespace std;
inline void StringRead(string &str){
    char s=getchar();
    while(s==' '||s=='\n'||s=='\r'){
        s=getchar();
    }
    while(s!=' '&&s!='\n'&&s!='\r'){
        str+=s;
        s=getchar();
    }
}
template <typename T> inline void read(T& x) {
    x=0;T f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    x=x*f;
    return;
}
template <typename T,typename ...Arg>void read(T& x,Arg& ...arg){
    read(x);
    read(arg...);
}
template <typename T>void write(T x) {
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else write(x/10),putchar(x%10+'0');
}
template <typename T>void write(char _c,T x) {
    write(x);
    putchar(_c);
}
template <typename T,typename ...Arg>void write(char _c,T x,Arg ...arg){
    write(_c,x);
    write(_c,arg...);
}
int n,m,Q;
vector <int> v[500005];
int in[500005],cop[500005],ans[500005];
queue <int> q;
void work(){
	for(int i=1;i<=n;i++){
		in[i]=cop[i];
		ans[i]=0;
		if(!in[i]){
			q.push(i);
			ans[i]=-1;
		}
	}
	int x,y;
	read(x,y);
	ans[y]=-1;
	if(in[y]) q.push(y);
	while(!q.empty()){
		int t=q.front();
		q.pop();
		if(ans[t]==-1){
			for(int i=0;i<v[t].size();i++){
				if(ans[v[t][i]]!=0) continue;
				ans[v[t][i]]=1;
				q.push(v[t][i]);
			}
		}else{
			for(int i=0;i<v[t].size();i++){
				if(ans[v[t][i]]!=0) continue;
				in[v[t][i]]--;
				if(!in[v[t][i]]){
					ans[v[t][i]]=-1;
					q.push(v[t][i]);
				}
			}
		}
	}
	write('\n',ans[x]);
}
int main(){
#ifdef online
	freopen(".in", "r", stdin);
	freopen(".out", "w",stdout);
#endif
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	read(n,m,Q);
	for(int i=1;i<=m;i++){
		int x,y;
		read(x,y);
		v[y].push_back(x);
		cop[x]++;
	}
	while(Q--){
		work();
	}
//	cout<<endl<<clock();
	return 0;
}

```

## 待优化部分 ##
其实拓补排序可以不全做，得出结果后直接输出，不过要记得将队列清空。不过不优化照样可以跑得飞快~~不知道是不是卡常的功劳~~，至少过这题没什么问题。


---

## 作者：JWRuixi (赞：1)

这道题是一道明显的博弈论题目。

## 1. 剖析题意：
- 首先如果是 DAG（有向无环图）则可以直接用模拟的方法
- 但是，这只是对于十分之一的数据
- 对于全部数据是有环的，考虑拓扑排序加上一些判重
- 注意这道题在这里需要用**反图**

## 2. 思路（定义 $dp[i]$ 为轮到先手回合时棋子所在的位置 $i$ 是必胜还是必败）:
- 如果棋子在终点或无路可走（即入度为零）则必败， $dp[i]$ 赋为-1
- 如果棋子当前 $dp[i]$ 为-1，则下一步必胜
- 如果连接到棋子的每一个点的 $dp[i]$ 都未1，则这一个点的 $dp[i]$ 只能未-1，具体实现中则每一步都让入度减一，让后判断是否入度为零，是则入队

## 3. code：
```cpp
#include <bits/stdc++.h>
using namespace std;
//快读
inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  while (c < '0' || c > '9') {
    if (c == '-') f = -1;
    c = getchar();
  }
  while (c >= '0' && c <= '9') {
    x = x * 10 + c - '0';
    c = getchar();
  }
  return x * f;
}
//链式前向星存图
struct edge {
	int v, nxt;
}e[600005];
int n, m, Q, head[100005], in[100005], in_deg[100005], dp[100005], s, t, k;
//队列存储当前点
queue <int> q;
//链式前向星中的加边
inline void add (int u, int v) {
	e[++k].v = v;
	e[k].nxt = head[u];
	in[v]++, in_deg[v]++;//每一次询问都要改变in[i]的值，所以在此处记录下来
	head[u] = k;
}
//拓扑排序部分
inline void kahn_topo_sort () {
	for (int i = 1; i <= n; i++) {
		if (!in[i] || i == t){
			q.push(i);
			dp[i] = -1;
		}
	}//首先入队
	while (!q.empty()) {
		int u = q.front();
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].v;
			if (dp[v] != 0) continue;//预防进入环后重复赋值
			if (dp[u] == 1 && !--in[v]) {
				dp[v] = -1;
				q.push(v);
			}//当前节点为必胜时
			else if (dp[u] == -1) {
				dp[v] = 1;
				q.push(v);
			}//反之
		}
		q.pop();
	}
	return;
}
int main () {
	n = read(), m = read(), Q = read();//输入
	for (int i = 0; i < m; i++) {
		int u = read(), v = read();
		add (v, u);
	}
	while (Q--) {
		s = read(), t = read();
		for (int i = 1; i <= n; i++) {
			dp[i] = 0;
			in[i] = in_deg[i];//对于每一次询问初始化
		}
		kahn_topo_sort ();
		printf ("%d\n", dp[s]);//起点递归的值为答案
	}
	return 0;//好习惯
}
```

如有错误请大佬指教！

---

## 作者：我杀文化课 (赞：1)

拿到题，首先就想到BFS，虽然有点博弈那味，但实在是和其他博弈论关系不太大，就算是没学过博弈论，这个题一样可以做。

### 一：题意剖析（定义$book_i$为轮到先手回合时棋子所在的位置$i$是必胜还是必败）
- 当棋子在终点时，先手必败，我们将$book_i$赋为-1。
- 当棋子没有出路时（走到死胡同），先手必败，我们将$book_i$赋为-1。
- 当棋子处于的点的$book$值为-1（必败）时，那么他的下一步必定为1（必胜）
- 当棋子处于的点的$book$值为1（必胜）时，我们无法确定这个点是否为必胜或必败或都不是，因为它也有可能由其他$book_i=-1$的节点转移过来。所以我们将其入度减一，如果此点出度（在正向图中）为0（即往哪走都是必胜情况），则可以判定其为必败。

根据以上几点，我们可以得出必胜必败或都不是的条件

1. 必胜：起点的$book$值为1时。

2. 必败：起点的$book$值为-1时。

3. 都不是：起点没有被确定，为初始值0时。

### 二：实现

我们采用从确定的点倒推的方式向前更新，于是我们采用反向建图+BFS的方式来实现。

大概步骤如下：

1. 预处理每个点在反向图中的入度。

2. 将入度为0的节点和终点加入队列中。

3. BFS，访问队首的每一个点（反图中），如果此点$book$值不为0，说明已经被更新过，则跳过这个点。否则根据队首的点的$book$值更新，具体方法见第一节。

4. 当队为空，返回，输出$book_{start}$。

#### 代码如下

```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int MAX=4e5;
int k,head[MAX],n,m,q,s,t,book[MAX],rdu[MAX],du[MAX],bo;
queue<int> qe;
struct llk
{
	int next,to;
}e[MAX*2];
void adde(int u,int v)
{
	e[++k].to=v;
	e[k].next=head[u];
	head[u]=k;
}
void bfs()
{
	while(!qe.empty())
	{
		int u=qe.front();
		int z=book[u];
		qe.pop();
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(book[v]!=0) continue;//这个点已经更新过
			if(z==1)
			{
				du[v]--;//无法确定是否是必败，先将入度减一
				if(du[v]==0) 
                	book[v]=-1,qe.push(v);//入度为0，可以确定此点必败
			}
			else book[v]=1,qe.push(v);//此点必胜
		}
	}
	
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		adde(v,u);//反向建边
		rdu[u]++;//统计入度
	}
	for(int i=1;i<=q;i++)
	{
		for(int j=1;j<=n;j++) book[j]=0，du[j]=rdu[j];//此处需要注意，因为在BFS过程中入度会改变，所以我们每次创建一个副本。
		scanf("%d%d",&s,&t);
		for(int j=1;j<=n;j++) if(du[j]==0||j==t) book[j]=-1,qe.push(j);//将终点和入度为0的点入队
		bfs();
		printf("%d\n",book[s]);
	}
}
```


---

## 作者：AKPC (赞：1)

### 思路
就不说 $10pts$ 了，直接讲正解。

不难发现这是一个图上博弈论问题。我们需要转化题意。

先考虑无环情况。显然，如果某方可以一步到达终点或走到死路，那么另一方就输了，显然终点与死路是必败点。而如果一方能够在某个点将棋子走到必败点，那么这个点就是必胜点。而如果开局必胜点，先手就会有必胜策略，如果开局必败点，后手就有必胜策略。这样直接模拟即可。这是类似于拓扑排序的思路。

但是有环怎么办？我们不用把它当成一个环，如果环的所有出口点都是必败点，那么显然双方都会走环，也就是双方都无必胜策略；反之，则跟无环情况一样处理即可。

一旦确定了一个点必胜或必败，就不再访问它了，这样可以避免环对传递答案的不好的影响。在过程中考虑建反图，因为在传递答案的时候，是根据边反向传递的。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,t,tip,l,r,q[500005],v[500005],h[500005],ne[500005],e[500005],g[500005],tmp[500005];
inline void add(int a,int b) {v[tip]=b,ne[tip]=h[a],h[a]=tip++;}
int main(){
	cin>>n>>m>>t;
	memset(h,-1,sizeof(h));
    while (m--){
    	int x,y;
    	cin>>x>>y;
    	add(y,x),e[x]++;
	}
	while (t--){
		l=r=0;
		memset(tmp,0,sizeof(tmp));
		int x,y;
		cin>>x>>y;
		for (int i=1;i<=n;i++) g[i]=e[i];
		for (int i=1;i<=n;i++) if (!g[i]||i==y) q[++r]=i,tmp[i]=-1;
		while (l<=r){
			int k=q[++l]; 
			for (int i=h[k];~i;i=ne[i]){
				int d=v[i];
				if (tmp[d]!=0) continue;
				if (tmp[k]==1) {if (--g[d]==0) q[++r]=d,tmp[d]=-1;}
				else q[++r]=d,tmp[d]=1;
			}
		}
		cout<<tmp[x]<<'\n';
	}
    return 0;
}
```


---

## 作者：technopolis_2085 (赞：0)

## P6560 [SBCOI2020] 时光的流逝 题解

博弈论+拓扑排序的题。

这道题的图是有向无环图，所以考虑拓扑排序。

确定了总思路之后，则需要找必胜点和必败点。

很明显，终点和出度为 $0$ 的点为必败点。

那么，可以通过拓扑排序来确定一个点是必胜还是必败。

如果一个点能到达的的点中只要有一个点是先手必败，则当前点为先手必胜。

如果一个点能到达的所有点都为先手必胜点，则当前点为先手必败点。


所以可以通过拓扑排序实现。

如果当前点是先手必败点，则与这个点连接的所有点都为先手必胜点。

如果这个点为先手必胜点，则将能到达的点的入度减 $1$，如果入度为 $0$ 的时候还未确定，则这个点为先手必败点，否则为先手必胜点。

对于每一次询问，都做一遍拓扑排序即可。

Code：
```
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e5+10;
vector<int> G[maxn];
int in[maxn],dp[maxn],ind[maxn];
int n,m,q;

void solve(int t){
	memset(dp,0,sizeof(dp));
	queue<int> q;
	
	for (int i=1;i<=n;i++){
		in[i]=ind[i];
		if (in[i]==0||i==t){
			dp[i]=-1;
			q.push(i);
		}
	}
	
	while (!q.empty()){
		int u=q.front(); q.pop();
		
		if (dp[u]==-1){
			for (int i=0;i<(int)G[u].size();i++){
				int v=G[u][i];
				if (dp[v]) continue;
				dp[v]=1;
				q.push(v);
			}
		}
		else if (dp[u]==1){
			for (int i=0;i<(int)G[u].size();i++){
				int v=G[u][i];
				if (dp[v]) continue;
				in[v]--;
				if (in[v]==0){
					dp[v]=-1;
					q.push(v);
				}
			}
		}
	}
}

int main(){
	scanf("%d%d%d",&n,&m,&q);
	
	for (int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		G[v].push_back(u);
		ind[u]++;
	}
	
	while (q--){
		int s,t;
		scanf("%d%d",&s,&t);
		solve(t);
		
		printf("%d\n",dp[s]);
	}
	return 0;	
}
```


---

## 作者：Marginal_world (赞：0)

这道题其实本质就是个图上的博弈论。

核心是标记必胜点和必败点。

博弈论：我们可以发现只要一个点的所有出点的状态即确定是否为必胜点或必败点时，那个点的状态我们便能确定。因为若它有一条边指向必败点，则它为必胜点。若它所有边都指向必胜点，那么他就是必败点。所以我们就能想到然后建反向边，因为我们需要从已经确定的点去修改未知的点，即需要知道哪些点会通到它，用一个数组记录它的出度，一个数组记录当前的标记，必胜点或必败点。

然后嘛，队列保存当前可以确定状态的点，如果找到一个必败点，那么立即修改所有能通到它的点。

这一部分可以用拓扑排序解决。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,f[100005],cnt,head[100005];
int in[100005],out[100005];
struct node{
	int to,next;
}e[500005];
void add(int u,int v){//链式前向星
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
int main(){
	cin>>n>>m>>t;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		add(v,u);////反向边
		in[u]++;
	}
	while(t--){
		int st,sd;
		cin>>st>>sd;
		queue<int> q;
		for(int i=1;i<=n;i++){
			out[i]=in[i];
			if(!out[i]||i==sd){//若当前点出度为0，放进队列
				f[i]=-1;
				q.push(i);
			}
			else f[i]=0;
		}
		while(!q.empty()){
			int u=q.front();
			q.pop();
			for(int i=head[u];i;i=e[i].next){
				int v=e[i].to;
				if(f[v]!=0)continue;
				out[v]--;
				if(f[u]==-1){
					f[v]=1;
					q.push(v);//博弈论思想
				}
				else if(!out[v]){
					if(f[v]!=1)
					f[v]=-1;
					q.push(v);
				}
			}
		}
		cout<<f[st]<<endl;
	}
	return 0;
}
```
希望能帮助到大家。

---

## 作者：船酱魔王 (赞：0)

# P6560 [SBCOI2020] 时光的流逝 题解

## 题意回顾

在一个 $ n $ 个点，$ m $ 条边的有向图上的起点放有一枚棋子，两人轮流将棋子沿一条出边移到另一个结点，当一个人把棋子移到终点时他胜利，一个人无路可走时他失败，判断先手和后手谁有必胜策略或均无必胜策略。每次询问起点会进行改变，共 $ q $ 次询问。

$ 1 \le n \le 10^5 $，$ 1 \le m \le 5 \times 10^5 $，$ 1 \le q \le 500 $。

## 解法

观察到 $ q $ 很小，$ O(q(n+m)) $ 可过。

我们建立有向图 $ g $，和所有边反过来的图 $ f $。

我们使用拓扑排序。

对于每次询问，我们发现当一个人**被动**到达终点时或他无路可走时，他**失败**。则我们先将终点或出度为 $ 0 $ 的点标记为先手**必败**点，入队。

每次从队头取出一个点 $ u $，利用反向图找到 $ u $ 的所有**入点** $ v $。

* 当 $ v $ 出度已经被标记为 $ 0 $ 时，说明其胜败情况已被确定，无需再考虑。

* 当 $ u $ 为必败点时，$ v $ 为必胜点，入队，出度改为 $ 0 $。（因为已经确认胜败情况，无需再更新）

* 当 $ u $ 为必胜点时，将 $ v $ 的出度减一，因为这条边会使对方必胜。当 $ v $ 的出度为 $ 0 $ 时，说明 $ v $ 的所有出边均会使当前方必败，$ v $ 为必败点，入队。

当一个点 $ u $ 没有任何标记时，说明这个点不存在使当前方胜利的出边，但也不全是使当前方失败的出边，则 $ u $ 为平局点。

注意实现细节。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 1e5 + 5;
int n, m, q;
vector<int> g[N];//原图 
vector<int> f[N];//反向图 
int sta[N];//(-1)-后手必胜，0-无必胜策略，1-先手必胜 
int ind[N];
struct Queue {
	int st, ed;
	int num[N];
	void init() {
		st = 1;
		ed = 0;
	}
	void push(int x) {
		ed++;
		num[ed] = x;
	}
	void pop() {
		st++;
	}
	bool empty() {
		return (st > ed);
	}
	int front() {
		return num[st];
	}
} que;
int main() {
	scanf("%d%d%d", &n, &m, &q);
	int t1, t2;
	for(int i = 1; i <= m; i++) {
		scanf("%d%d", &t1, &t2);
		g[t1].push_back(t2);
		f[t2].push_back(t1);
	}
	int tmp, t3;
	for(int qi = 1; qi <= q; qi++) {
		scanf("%d%d", &t1, &t2);
		for(int i = 1; i <= n; i++) {
			sta[i] = 0;
			ind[i] = g[i].size();
		}
		que.init();
		que.push(t2);
		sta[t2] = -1;
		for(int i = 1; i <= n; i++) {
			if(g[i].size() == 0 && i != t2) {
				sta[i] = -1;
				que.push(i);
				ind[i] = -1;
			}
		}
		ind[t2] = -1;
		while(!que.empty()) {
			tmp = que.front();
			que.pop();
			for(int i = 0; i < f[tmp].size(); i++) {
				t3 = f[tmp][i];
				ind[t3]--;
				if(sta[tmp] == -1 && ind[t3] >= 0) {
					sta[t3] = 1;
					que.push(t3);
					ind[t3] = -1;
				} else if(ind[t3] == 0) {
					sta[t3] = -1;
					que.push(t3);
					ind[t3] = -1;
				}
			}
		}
		printf("%d\n", sta[t1]);
	}
	return 0;
}
```

## 总结与评价

校内模拟赛的一道题，感觉可以加深对拓扑排序原理和性质的理解，是一道很好的拓扑排序基础练习题。

---

## 作者：WaterSun (赞：0)

# 思路

标准博弈论，我们假定 $dp_i$ 表示当前棋子在 $i$ 的时候，先手必赢为 $1$，先手必负为 $-1$，无法确定为 $0$。

那么我们看图分析一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/pwhmxqdm.png)

在终点为 $5$ 的情况下：不难的出 $dp_5 = 1,dp_4 = -1,dp_7 = -1,dp_3 = -1\cdots$。

根据这些，我们便不难想到转移公式：

$$\left\{\begin{matrix}
dp_i = 1 & \exists v,(i,v) \in E,dp_v = -1 \\
dp_i = -1 & \forall v,(i,v) \in E,dp_v = 1 
\end{matrix}\right.$$

看到这里，我们不难想到拓扑排序。但是，拓扑排序只能在 DAG 上做，可是这里有环，只有转换一下。

我们知道，如果在一个有向有环图中跑一边拓扑排序，只会剩下环。

然而，对于剩下的这个环 $G_h(V_h,E_h)$，当 $dp_{i} \neq 0,i \in V_h$ 时，就是会产生解的，否则不行。

需要注意的是，这种做法需要反向建边。

# code

```cpp
#include <bits/stdc++.h>
#define re register

using namespace std;

const int N = 1e5 + 10,M = 5e5 + 10;
int n,m,q,idx;
int h[N],ne[M],e[M];
int pre[N],in[N],dp[N];

inline int read(){
	int r = 0,w = 1;
	char c = getchar();
	while (c < '0' || c > '9'){
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9'){
		r = (r << 3) + (r << 1) + (c ^ 48);
		c = getchar();
	}
	return r * w;
}

inline void add(int a,int b){
	ne[idx] = h[a];
	e[idx] = b;
	h[a] = idx++;
}

inline void tp_sort(int E){
	queue<int> Q;
	for (re int i = 1;i <= n;i++){
		if (!in[i] || i == E){
			dp[i] = -1;
			Q.push(i);
		}
	}
	while (!Q.empty()){
		int t = Q.front();
		Q.pop();
		for (re int i = h[t];~i;i = ne[i]){
			int j = e[i];
			if (dp[j] == 1) continue;
			if (dp[t] == 1){
				in[j]--;
				if (!in[j]){
					dp[j] = -1;
					Q.push(j);
				}
			}
			else{
				dp[j] = 1;
				Q.push(j);
			}
		}
	}
}

int main(){
	memset(h,-1,sizeof(h));
	n = read();
	m = read();
	q = read();
	for (re int i = 1;i <= m;i++){
		int a,b;
		a = read();
		b = read();
		add(b,a);
		pre[a]++;
	}
	while (q--){
		int S,E;
		memset(dp,0,sizeof(dp));
		memcpy(in,pre,sizeof(pre));//多测清空 
		S = read();
		E = read();
		tp_sort(E);//拓扑排序 
		printf("%d\n",dp[S]);
	}
	return 0;
}
```

---

## 作者：max666dong123 (赞：0)

## 思路
我们定义 $f_i$ 为以 $i$ 为起点，必胜的值为 $1$，必败的值为 $-1$。
比如说在这幅图中，设终点为 $5$：
![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

很容易发现 $f_5=-1$，那么 $f_4=1,f_7=1$。
所以如果：
$$\forall v,(i,v)\in E,f_v=1\to f_i=-1$$
$$\exists v,(i,v)\in E,f_v=-1\to f_i=1$$
我们就用拓扑排序来算出 $f_i$。

那么 $f_i=0$ 是为什么呢，我们知道，对于有环的图，拓扑排序后一定会剩下环：

![](https://cdn.luogu.com.cn/upload/image_hosting/anqvu248.png)

只有当环内有 $f_i\neq0$ 时才有可能不出现 $0$。

答案为**起点**。
## 代码
```cpp
#include<bits/stdc++.h>
//#define int long long
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
using namespace std;
const int N=2e5+10,M=5e5+10;
int n,m,Q;
int h[N],ne[M],to[M];
int k[N],in[N];
int f[N];
int idx=1;
void add(int u,int v){
	to[idx]=v;
	ne[idx]=h[u];
	h[u]=idx++;
}
signed main(){
	IOS;
	cin>>n>>m>>Q;
	memset(h,-1,sizeof(h));
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		add(v,u);//反图
		k[u]++;//记录
	}
	int b,e;
	while(Q--){
		memset(f,0,sizeof(f));
		memcpy(in,k,sizeof in);//复制
		queue<int>q;
		cin>>b>>e;
		for(int i=1;i<=n;i++){
			if(in[i]==0||i==e){//如度为0
				f[i]=-1;
				q.push(i);
			}
		}
		while(!q.empty()){//拓扑排序
			int x=q.front();
			q.pop();
			for(int i=h[x];i;i=ne[i]){
				int j=to[i];
				if(f[j]==1)continue;
				if(f[x]==1){
					--in[j];
					if(!in[j]) f[j]=-1,q.push(j);
				}
				else f[j]=1,q.push(j);
			}
		}
		cout<<f[b]<<endl;//答案在起点
	}
	return 0;
}

```

---


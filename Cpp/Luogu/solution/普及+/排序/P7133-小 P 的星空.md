# 小 P 的星空

## 题目背景



>星依云渚溅溅，露零玉液涓涓，宝砌哀兰剪剪。碧天如练，光摇北斗阑干。
>
>—— 【元】孟昉《天净沙 · 星依云渚溅溅》

小 P 漫步于星空之下。

“摘下星星送给你，你就是我的全世界”。

“今夜，我不关心人类，我只想你”。

## 题目描述

将星空看作一个平面直角坐标系，小 P 所在的位置为 $(0,0)$，即坐标原点。天上共有 $n$ 颗星星，第 $i$ 颗星星的坐标为 $(x_i,y_i)$。

小 P 最初面向点 $(1,0)$，然后小 P 会进行 $m$ 次原地转动，第 $i$ 次转动后会面向点 $(u_i,v_i)$。

他可以选择逆时针转动或顺时针转动，当面向此次旋转最终将要面向的方向时，此次转动立即停止。

他相信，在转动过程中，越多的星星出现在他正前方，他【数据删除】。

小 P 想知道，每一次转动过程中他最多可以让多少星星出现在他正前方（包括转动初始方向和结束方向正前方看到的星星）。

## 说明/提示

样例1示意图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/h2t5eu1a.png)

橙色点为星星，绿色点小 P 第一次的转动位置。第一次转动，从 $(1,0)$ 转到 $(-1,1)$。若顺时针转动(蓝色区域，包括边界)，$(1,0)$, $(-2,-1)$，共计 $2$ 颗星星；而逆时针转动(绿色区域，包括边界)，$(1,0)$, $(1,1)$,$(2,2)$,$(-1,2)$，共计 $4$ 颗星星。

第二次转动，从 $(-1,1)$ 转到 $(-1,2)$，逆时针转动，$5$ 颗星星都会在转动过程中出现在小 P 正前方。

![](https://cdn.luogu.com.cn/upload/image_hosting/b22go7at.png)

除测试点 $24$ 和 $25$ 外，其他测试点保证所有坐标的绝对值 $\le 1000$。

对于前 $12$ 个测试点，保证原点到任意星星形成的射线上没有其他星星。

除 $23,25$ 测试点外，对于所有编号为奇数的测试点，保证小 P 初始面向方向和每次转动目标方向上没有任何星星。

除 $22,24$ 测试点外，对于所有编号为偶数的测试点，保证小 P 初始面向方向和每次转动目标方向上至少有一颗星星。

对于 $100\%$ 的数据，保证星星的坐标互不相同，保证坐标不会出现 $(0,0)$，保证不会出现转动初始方向等于结束方向。

样例 $3$ 满足偶数测试点的限制。

## 样例 #1

### 输入

```
5 2
1 0
1 1
2 2
-1 2
-2 -1
-1 1
-1 2```

### 输出

```
4
5```

## 样例 #2

### 输入

```
见下发文件 ex_star2.in```

### 输出

```
见下发文件 ex_star2.out```

## 样例 #3

### 输入

```
见下发文件 ex_star3.in```

### 输出

```
见下发文件 ex_star3.out```

# 题解

## 作者：tuxiaobei (赞：15)

这里是出题人（

以 $x$ 轴正半轴为起点，将所有星星逆时针排序，注意处理不同象限的星星的大小关系，询问直接在排序后的序列中二分查询位置，通过做差得到星星的数量。

本题难度不大，需要注意细节部分处理，部分分给得很多，本题目标就是提高本场比赛平均分，定位为 `CSP-S2020 T2`.

```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;
int n, m;

struct point {
	int x, y; //横坐标，纵坐标的绝对值
	int c; //区域
	bool operator<(const point& p) const {
		if (c != p.c) return c < p.c; //区域不同直接比较
		if (c % 2 == 0) return false; //坐标轴上不交换　
		if (c == 1 || c == 5) return (long long)x * p.y > (long long)y* p.x; //一三象限
		else return (long long)x * p.y < (long long)y * p.x; //二四象限
	}
} a[maxn], p;

point change(int x, int y) //化归操作
{
	point a;
	a.x = abs(x), a.y = abs(y);
	if (y == 0) a.c = x > 0 ? 0 : 4;  //x正/负半轴
	else if (x == 0) a.c = y > 0 ? 2 : 6; //y正/负半轴
	else if (x > 0) a.c = y > 0 ? 1 : 7;  //第一象限/第四象限
	else a.c = y > 0 ? 3 : 5;  //第二象限/第三象限
	return a;
}

struct line {
	int s, t, w;
};

line getline(point x)
{
	line res;
	res.s = lower_bound(a + 1, a + n + 1, x) - a;   //>=x的第一个元素 
	res.t = upper_bound(a + 1, a + n + 1, x) - a - 1;  //>x的第一个元素 
	res.w = res.t - res.s + 1; //线上有多少星星 
	return res;
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1, x, y; i <= n; i++) {
		scanf("%d%d", &x, &y);
		a[i] = change(x, y);
	}
	sort(a + 1, a + n + 1);
	line u = getline(change(1, 0));
	for (int i = 1, x, y; i <= m; i++) {
		scanf("%d%d", &x, &y);
		line v = getline(change(x, y));
		int num = v.s - u.t - 1; //求出一个某一个方向转动的星星 
		if (num < 0) num += n;
		printf("%d\n", max(n - num, num + u.w + v.w)); //全局减，得到另一方向的星星数量 
		u = v;
	}
}
```



---

## 作者：wmy_goes_to_thu (赞：11)

小学数学题。

这道题如果判象限这么做的话，肯定很麻烦。所以我们考虑记录度数。

显然，如果 C 的角度在 A 和 B 之间的话，顺着正常思维走（从小度数到大度数）是会走到的，反之亦然。

于是我们可以二分，注意边界的细节。

这道题可能会被卡精（就像我一样），那么就需要取一个适当的 eps，把角度变成一个 long long。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double c1[100005],c2[100005],d1[100005],d2[100005];
double pi=acos(-1);
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		c1[i]=acos(1.0*x/sqrt(1.0*x*x+1.0*y*y));
		if(y<0)c1[i]=2*pi-c1[i];
		long long tt=c1[i]*10000000000ll;
		c1[i]=1.0*tt/10000000000ll;
	}
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		c2[i]=acos(1.0*u/sqrt(1.0*u*u+1.0*v*v));
		if(v<0)c2[i]=2*pi-c2[i];
		long long tt=c2[i]*10000000000ll;
		c2[i]=1.0*tt/10000000000ll;
	}
	sort(c1+1,c1+n+1);
	double cc=0;
	for(int i=1;i<=m;i++)
	{
		double tc1=min(cc,c2[i]),tc2=max(cc,c2[i]);
		int wz1=lower_bound(c1+1,c1+n+1,tc1)-c1;
		int wz2=upper_bound(c1+1,c1+n+1,tc2)-c1;
		int ans=wz2-wz1;
		wz1=upper_bound(c1+1,c1+n+1,tc1)-c1;
		wz2=lower_bound(c1+1,c1+n+1,tc2)-c1;
		ans=max(ans,n-wz2+wz1);
		printf("%d\n",ans);
		cc=c2[i];
	}
	return 0;
}
```

---

## 作者：System32 (赞：4)

观察题目不难发现，对于平面上的每一个点，如果以辐角排序，在每次查询时二分，可以在 $O(\log n)$ 的复杂度内得出旋转时扫过的点的个数，但是用 double 存辐角会丢失精度。

注意到对于两个点 $(x_1,y_1)$，$(x_2,y_2)$，它们的辐角相同当且仅当 $\frac{x_1}{\gcd(x_1,y_1)}=\frac{x_2}{\gcd(x_2,y_2)}$ 且 $\frac{y_1}{\gcd(x_1,y_1)}=\frac{y_2}{\gcd(x_2,y_2)}$。所以对于每一个点 $(x,y)$，记录 $(\frac{x}{\gcd(x,y)},\frac{y}{\gcd(x,y)})$，排序时仍用 double 计算辐角，精度可以通过本题。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

double at(int x, int y);

struct angle {
	int x, y;
	bool operator<(const angle& f) const {
		return at(x, y) < at(f.x, f.y);
	}
	bool operator>(const angle& f) const {
		return at(x, y) > at(f.x, f.y);
	}
};

vector<angle> s;
map<angle, int> mp;
double p = acos(-1);

double at(int x, int y) {
	if (x == 0) {
		if (y > 0) {
			return p / 2;
		} else {
			return p * 3 / 2;
		}
	} else if (y == 0) {
		if (x > 0) {
			return 0;
		} else {
			return p;
		}
	} else {
		double k = 1.0 * y / x;
		if (x > 0) {
			if (y > 0) {
				return atan(k);
			} else {
				return 2 * p + atan(k);
			}
		} else {
			if (y > 0) {
				return p + atan(k);
			} else {
				return p + atan(k);
			}
		}
	}
}

int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		int x, y;
		cin >> x >> y;
		if (x != 0 && y != 0) {
			int g = __gcd(abs(x), abs(y));
			x /= g;
			y /= g;
		} else if (x == 0) {
			y = abs(y) / y;
		} else {
			x = abs(x) / x;
		}
		s.push_back({x, y});
		mp[ {x, y}]++;
	}
	sort(s.begin(), s.end());
	angle now;
	now.x = 1;
	now.y = 0;
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		angle l;
		if (x != 0 && y != 0) {
			int g = __gcd(abs(x), abs(y));
			x /= g;
			y /= g;
		} else if (x == 0) {
			y = abs(y) / y;
		} else {
			x = abs(x) / x;
		}
		l.x = x;
		l.y = y;
		if (now > l) {
			int a = upper_bound(s.begin(), s.end(), now) - s.begin(), b = lower_bound(s.begin(), s.end(), l) - s.begin();
			int c = a - b;
			int d = n - c + mp[now] + mp[l];
			cout << max(c, d) << endl;
			now = l;
		} else if (now < l) {
			int a = lower_bound(s.begin(), s.end(), now) - s.begin(), b = upper_bound(s.begin(), s.end(), l) - s.begin();
			int c = b - a;
			int d = n - c + mp[now] + mp[l];
			cout << max(c, d) << endl;
			now = l;
		} else {
			cout << n << endl;
		}
	}
}
```

---

## 作者：麦克斯韦の妖 (赞：3)

这是本蒟蒻的第一篇题解。

出题人题解个人感觉讲得比较简单，这篇题解对细节部分进行一些更细致的解释和说明。

由题意不难发现，本题主要有两个需要实现的部分。对所有的星星按照**逆时针排序**（顺时针也可以），利用**二分查找**计算出一次逆转动过程中他可以让多少星星出现在他正前方。我们知道顺时针转动和逆时针转动看到的星星之和为 $n$，因此可以按逆时针排序二分算得后用 $n$ 作差比较即可。

这篇题解主要介绍逆时针排序的实现。对于点 $P(x,y)$ 先判断其象限（轴线），再将 $x,y$ 取绝对值。对于不同象限的点，可以直接比较即可。同一轴线上的点不用比较，同一象限的点比较斜率的绝对值（x 和 y 已经取过绝对值了）。该部分代码如下，具体看注释。
```cpp
struct Node{
	int x,y;
	int pos; //象限 
}p[N];
//重载运算符
bool operator <(const Node a,const Node b){
	//都在轴线
	if(a.pos==b.pos && a.pos%2==0) return false;
        //都在一或三象限
	else if((a.pos==1||a.pos==5) && (a.pos==b.pos) 
		return (ll)a.y*b.x<(ll)b.y*a.x; //double会掉精度
        //都在二或四象限
	else if((a.pos==3||a.pos==7) && (a.pos==b.pos))
		return (ll)a.y*b.x>(ll)b.y*a.x;
	else return a.pos<b.pos;
}
//判断象限轴线
Node getPos(Node x)
{
	Node p=x;//临时变量
	if(p.y==0 && p.x>0) p.pos=0; //x正半轴  
	if(p.x>0 && p.y>0) p.pos=1;	//第一象限 
	if(p.x==0 && p.y>0) p.pos=2; //y正半轴  	
	if(p.x<0 && p.y>0) p.pos=3; //第二象限 
	if(p.y==0 && p.x<0) p.pos=4; //x负半轴  
	if(p.x<0 && p.y<0) p.pos=5; //第三象限 
	if(p.x==0 && p.y<0) p.pos=6; //y负半轴 
	if(p.x>0 && p.y<0) p.pos=7; //第四象限 
	p.x=abs(p.x);
	p.y=abs(p.y);
	return p;
}

```
二分查找部分只要记录每个方向上星星的数量，该方向上第一颗星星的下标，最后一颗星星的下标存入结构体中，通过lower_bound 和 upper_bound 即可实现获得下标。

最后在线处理转动，记录前一个方向和当前方向。

注意：

1：第一、三象限和二。四象限比较斜率是不同的。

2：统计时可能会小于0，要加 $n$。

3：不要忘记开始和结束的两个方向的星星。

完整代码参见第一篇题解（出题人题解）。

---


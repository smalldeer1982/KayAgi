# [COCI 2015/2016 #2] ARTUR

## 题目描述

有 $n$ 根棍子放在桌面上，求一个将棍子向桌子 $x$ 轴边缘移动的顺序，使棍子不发生碰撞（棍子向桌子边缘移动的速度相同）。

## 说明/提示

**【样例 1 解释】**

如图，另一种移动顺序是 `2 1 4 3`。

![](https://cdn.luogu.com.cn/upload/image_hosting/6yeaxhnb.png)

**【数据范围】**

对于 $40\%$ 的数据，$1\le N\le 10$；

对于 $60\%$ 的数据，$1\le N\le 300$；

对于 $100\%$ 的数据，$1\le N\le 5000$，$0\le x1,y1,x2,y2\le 10^4$。

**【说明】**

**本题数据点得分依原题，满分 100**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T3 ARTUR**。

## 样例 #1

### 输入

```
4
1 3 2 2
1 1 3 2
2 4 7 3
3 3 5 3
```

### 输出

```
2 4 1 3```

## 样例 #2

### 输入

```
4
0 0 1 1
1 2 0 3
2 2 3 3
4 0 3 1
```

### 输出

```
4 3 1 2```

## 样例 #3

### 输入

```
3
4 6 5 5
2 1 15 1
3 2 8 7
```

### 输出

```
2 3 1```

# 题解

## 作者：Binary_Lee (赞：7)

## [题面传送门](https://www.luogu.com.cn/problem/P7860)

好题。

主要思路和另一位巨佬差不多，详细讲一下判断的部分。

### 解决思路：

首先考虑本题与拓扑排序有和关系。可以想到，某些棍子的先后移动顺序是有限制的。比如：

![](https://cdn.luogu.com.cn/upload/image_hosting/4q2z4b9t.png)

这里红色的必须比蓝色的先移动，因为它们在 $x$ 轴的投影有重叠，蓝色在上，会被红色卡住。

所以，棍子两两之间可能存在限制关系，这就符合拓扑排序的条件了。考虑根据每一对限制关系建边。若 $u$ 必须比 $v$ 先移动，就从 $u$ 向 $v$ 连边，这样就转化为求拓扑序问题了。

------------


其次，也是较麻烦的一部分，就是如何根据两线段的坐标判断其移动先后限制。

为了方便，在读入时判断并交换好，用 $x1,y1$ 表示左边端点，$x2,y2$ 表示左边端点。

$\text {check}$ 函数，分以下几种情况讨论：

1. 没有限制关系，返回 $0$。
2. $u$ 比 $v$ 要先移动，返回 $-1$。
3. $v$ 比 $u$ 要先移动，返回 $1$。

为了方便，设 $u$ 为靠左的线段，若不是，在开始判断前将交换一下，并需要把 $op$（返回值）取反。

首先看 $op=0$，即两线段在 $x$ 轴上投影不重合：

![](https://cdn.luogu.com.cn/upload/image_hosting/ziqfmu82.png)

肉眼可见，$u.x2<v.x1$，注意等号不可以取到（照提交意思来看...）。

然后看一般情况。多画几个图，可以发现，只需要比较 **$u$ 上 $x=v.x1$ 时 $u.y'$ 的值与 $v.y1$ 的大小** 即可（或 **$v$ 上 $x=u.x2$ 时 $v.y'$ 的值与 $u.y2$ 的大小**）。在下的先移，在上的后移。

![](https://cdn.luogu.com.cn/upload/image_hosting/ow2ue0li.png)

至于如何求函数值。。上过初中数学都会。具体可以看程序，变量名都遵从 $y=kx+b$ 的基本形式了。

然鹅，这样写获得了 $95$ 分的高分。哪里出问题了？

还有一种比较坑的情况，就是 $u$ 是竖直的！

![](https://cdn.luogu.com.cn/upload/image_hosting/aycp585b.png)

这时候函数 $u$ 的 $k$ 是无限大的，不是一次函数，无法求出值。所以需要特判，算出 $x=u.x1$ 时 $v$ 的函数值再比较。


------------

### Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,in[5005];
struct node{
	int x1,x2,y1,y2;
}b[5005];
vector<int> a[5005];
queue<int> q;
int check(node u,node v){ //0:无关，-1:先移u，1:先移v 
	int op=1;		
	if(u.x1>v.x1) swap(u,v),op=-op;	
	if(u.x2<v.x1) return 0; 
	double K,B,tmp;
	if(!(u.x2-u.x1)){
		K=1.0*(v.y2-v.y1)/(v.x2-v.x1);
		B=(double)v.y1-K*v.x1;
		tmp=K*u.x1+B;
		if(u.y1>tmp) return op;
		return -op;
	}
	K=1.0*(u.y2-u.y1)/(u.x2-u.x1);
	B=(double)u.y1-K*u.x1;
	tmp=K*v.x1+B;   //求函数
	if(tmp>v.y1) return op;
	return -op;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d%d",&b[i].x1,&b[i].y1,&b[i].x2,&b[i].y2);
		if(b[i].x1>b[i].x2) swap(b[i].x1,b[i].x2),swap(b[i].y1,b[i].y2);
	}
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			int op=check(b[i],b[j]);
			if(op==-1) a[i].push_back(j),in[j]++; 
			if(op==1) a[j].push_back(i),in[i]++;   //连边
		}
	}
	for(int i=1;i<=n;i++) if(!in[i]) q.push(i),printf("%d ",i);
	while(q.size()){        //拓扑
		int k=q.front();
		q.pop();
		for(int i=0;i<a[k].size();i++){
			int tmp=a[k][i];
			in[tmp]--;
			if(!in[tmp]) q.push(tmp),printf("%d ",tmp);
		}
	}
	return 0;
} 
```

---

## 作者：Skaditxdy (赞：6)

这题需要求一个任意的顺序，而木棍的移动顺序的先后存在限制，于是我们可以想到...

**拓扑排序！**

对每两条边判断是否有顺序要求，把木棍看作点，顺序要求看作边，建一张有向图，跑一遍就可以了。

其他的东西：

拓扑排序：  
在建图的时候统计每个点的入度，然后把所有入度为 0 的点扔到一个队列里。显然，入度为 0 代表这个木棍可以移动了。因此我们输出它（记得减一下它连的点的入度），一直到输出全部。

先后顺序：   
如果两个木棍在 x 轴的投影有重叠，那么他们就有先后关系。   
求其中一个的一般式然后代入比较即可    
这里细节不少，记得注意
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5010;
struct posi{			// 木棍位置
	int xa,xb,ya,yb;
}a[N];
int n,ind[N];			// 入度
vector<int> v[N];
queue<int> q;
int judge(posi xx,posi yy){		// 判断顺序
	int f=1;			// 记录是否swap过
	if(xx.xa>yy.xa) swap(xx,yy),f=-f;	// 把x小的作为xx方便比较
	if(xx.xb<yy.xa) return 0;	//无顺序				
	int A=xx.ya-xx.yb,B=xx.xb-xx.xa,C=xx.xa*xx.yb-xx.ya*xx.xb;     	// 求一般式
	if(!B){			// 判断斜率不存在
		if(xx.ya>yy.ya) return f;
		return -f;
	}
	double y=-1.0*(C+A*yy.xa)/B;	// 记得用double
	if(y>yy.ya) return f;
	return -f;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i].xa>>a[i].ya>>a[i].xb>>a[i].yb;
		if(a[i].xa>a[i].xb){
			swap(a[i].xa,a[i].xb);
			swap(a[i].ya,a[i].yb);
		}
	}
		
	for(int i=1;i<n;++i){			//建图
		for(int j=i+1;j<=n;++j){
			int ud=judge(a[i],a[j]);	// 先后顺序
			if(ud==1){
				v[j].push_back(i);
				++ind[i];
			}
			if(ud==-1){
				v[i].push_back(j);
				++ind[j];
			}
		}
	}
	for(int i=1;i<=n;++i)			// 拓扑排序（和BFS很像）
		if(!ind[i])
			q.push(i);
	while(!q.empty()){
		int now=q.front();
		cout<<now<<' ';
		q.pop();
		for(int i=0;i<v[now].size();++i){
			int nex=v[now][i];
			--ind[nex];
			if(!ind[nex]) q.push(nex);
		}
	}
	return 0;
}
```


---

## 作者：BIG_CUTE_BUG (赞：4)

[题传](https://www.luogu.com.cn/problem/P7860)

这是一道十分板的 [拓扑排序](https://oi-wiki.org/graph/topo/)。

注意，本题中端点相汇也算相撞。

## 思路
题目中棍子的取走是有前置条件的，因此很显然，此题就是一个 AOV 网问题，所以考虑拓扑排序，根据每个棍子拿走前，必须先拿走那些棍子来建边。

这个取走的先后顺序，是由棍子在坐标轴中是上是下来决定的。只要某个棍子在其他某个棍子的上面或下面，两者就需要建；反之则不需建边。

那对任意两个棍子 $a,b$，分别都有左端点 $(x1, y1)$ 和右端点 $(x2,y2)$，可分为两类：

1. 互不影响。
2. 一上一下。

考虑怎么判断。

第一种很简单，为了不产生交错，只要在横轴方向无重合即可：$a_{x1}> b_{x2} \text{ 或 } a_{x2}< b_{x1} $。

第二种则是 $a,b$ 的横坐标有重合。即可从重合的横坐标中取出一个，比较该横坐标在 $a,b$ 中对应的纵坐标。这里重合的横坐标中，最左端 $t$ 是 $t=\max \{ a_{x1},b_{x1} \} $，我就取的是 $t$ 来比较。

然后比较 $t$ 在 $a,b$ 中，纵坐标的对应值 $y_at, y_bt$。

那么对于 $a$ 的解析式就是
$$y= \frac{a_{y2}-a_{y1}}{a_{x2}-a_{x1}}  x + b$$
去分母
$$ (a_{x2}-a_{x1})y = (a_{y2}-a_{y1})x + (a_{x2}-a_{x1})b$$
反把 $y=a_{y1},x=a_{x1}$ 带入，化简得
$$ (a_{x2}-a_{x1})b=a_{x2}a_{y1}-a_{x1}a_{y2} $$
又把 $(a_{x2}-a_{x1})b$ 代入
$$ (a_{x2}-a_{x1})y = (a_{y2}-a_{y1})x + a_{x2}a_{y1}-a_{x1}a_{y2}$$
同理对 $b$ 有
$$ (b_{x2}-b_{x1})y = (b_{y2}-b_{y1})x + b_{x2}b_{y1}-b_{x1}b_{y2}$$
而当 $x$ 取 $t$ 时
$$ \begin{aligned}
(a_{x2}-a_{x1})y_at &= (a_{y2}-a_{y1})t + a_{x2}a_{y1}-a_{x1}a_{y2} \\
(b_{x2}-b_{x1})y_bt &= (b_{y2}-b_{y1})t + b_{x2}b_{y1}-b_{x1}b_{y2} 
\end{aligned}$$
因为比较 $y_at, y_bt$ 的大小关系，即比较 $ \frac{(a_{x2}-a_{x1})y_at}{(a_{x2}-a_{x1})}$ 和 $ \frac{(b_{x2}-b_{x1})y_bt}{(b_{x2}-b_{x1})}$。

再去分母，即比较 $ (a_{x2}-a_{x1})y_at \times (b_{x2}-b_{x1})$ 和 $ (b_{x2}-b_{x1})y_bt \times (a_{x2}-a_{x1})$。

此时都已知，计算即可。

另外，当若只有 $a$ 是竖直时，即 $a_{x2}-a_{x1}=0$ 时，回到
>比较 $y_at, y_bt$ 的大小关系

这一步，在此情况下，即比较 $y_at$ 和 $\frac{(b_{x2}-b_{x1})y_bt}{(b_{x2}-b_{x1})}$。

分母一乘，$y_at$ 随便取 $a$ 上一值，也可算。

若只有 $b$ 竖直，同理。

而当两者皆竖直时，分别取一值比较即可。

以上建边。~~（这样就不用开浮点类型）~~

此后按 topo 板子做即可。

具体见代码。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N= 5e3+ 5;
int n, m, in[N];
struct node{int x1, x2, y1, y2;} p[N];
vector< int> e[N];
void adde(int x, int y)
{
	if(x== y) return;
	if(p[x].x1> p[y].x2 || p[x].x2< p[y].x1) return;
	int a= max(p[x].x1, p[y].x1);
	long long t1, t2;//t1 t2 为 x 取 a 时的纵值
	if(p[x].x1== p[x].x2 && p[y].x1== p[y].x2) t1= min(p[x].y1, p[x].y2),
											   t2= min(p[y].y1, p[y].y2);
	else if(p[x].x1== p[x].x2) t1= ((long long)p[y].x2- p[y].x1)* min(p[x].y1, p[x].y2),
							   t2= ((long long)p[y].y2- p[y].y1)* a+ p[y].x2* p[y].y1- p[y].x1* p[y].y2;
	else if(p[y].x1== p[y].x2) t1= ((long long)p[x].y2- p[x].y1)* a+ p[x].x2* p[x].y1- p[x].x1* p[x].y2,
						  	   t2= ((long long)p[x].x2- p[x].x1)* min(p[y].y1, p[y].y2);
	else  t1= (((long long)p[x].y2- p[x].y1)* a+ p[x].x2* p[x].y1- p[x].x1* p[x].y2)* (p[y].x2- p[y].x1),
		  t2= (((long long)p[y].y2- p[y].y1)* a+ p[y].x2* p[y].y1- p[y].x1* p[y].y2)* (p[x].x2- p[x].x1);
	if(t1< t2) e[x].push_back(y), in[y]++;
	else e[y].push_back(x), in[x]++;
}
void topo()
{
	queue< int> q;
	for(int i= 1; i<= n; i++) if(!in[i]) q.push(i);
	while(!q.empty())
	{
		int u= q.front();
		q.pop();
		printf("%d ", u);
		for(auto v : e[u])
			if(!(--in[v])) q.push(v);
	}
}
signed main()
{
	scanf("%d", &n);
	int a, b, c, d;
	for(int i= 1; i<= n; i++)
	{
		scanf("%d%d%d%d", &p[i].x1, &p[i].y1, &p[i].x2, &p[i].y2);
		if(p[i].x1> p[i].x2) swap(p[i].x1, p[i].x2), swap(p[i].y1, p[i].y2);
	}
	for(int i= 1; i<= n; i++)
		for(int o= 1; o<= n ;o++)
			adde(i, o);
	topo();
	return 0;
}
```

---

## 作者：佬头 (赞：4)

## Description
有 $n$ 根棍子放在平面直角坐标系上，求将所有棍子[**移到 $x$ 轴下方**](https://www.luogu.com.cn/problem/P7860)的合法顺序（棍子不发生碰撞）。

## Solution
显然移动方案就是让最下面的棍子先走，换句话说：一根棍子某时刻若能移到 $x$ 轴下方，当且仅当它的正下方没有棍子（棍子应该不会相交）。

如果把每根棍子向它正下方的所有棍子连一条单向边，那么就是出度为 $0$ 的棍子可以移到 $x$ 轴下方。

观察到 $n$ 的范围很小，直接 $\mathcal O(n^2)$ 建图：
![](https://cdn.luogu.com.cn/upload/image_hosting/nkmkd381.png)

可以发现连完之后是一个有向无环图（DAG），那么就是一个求拓扑序（对拓扑序还不了解的同学可以先看一下模板 [**B3644 【模板】拓扑排序 / 家谱树**](https://www.luogu.com.cn/blog/Glory-of-the-King/solution-b3644)）。

然后思考棍子与棍子之间的位置关系。首先猜想可以通过**排序**、**比较横纵坐标大小**等简单操作判断棍子的上下关系，但是笔者思考良久后发现似乎行不通，仅仅是比较两根棍子的横纵坐标大小过于片面。
![](https://cdn.luogu.com.cn/upload/image_hosting/j08tegii.png)
看这幅图，以左边那根最长的红色棍子为例，一共有 $4$ 根棍子的横纵坐标在那根红色棍子的端点坐标构成的矩阵内，但他们有的在上面有的在下面，这样先后顺序就比较迷茫了。

那么既然给出了棍子两端点的坐标，显然我们可以把它的**解析式**算出来：
$$y=\frac{y_1-y_2}{x_1-x_2}x+\frac{x_1y_2-x_2y_1}{x_1-x_2}~(x_1\neq x_2)$$
对于两根棍子 $A,B$，把 $A$ 端点的横坐标 $x_A$ 都代入 $B$ 的解析式里得到 $y_A'$，若 $\exists~x\in \{x_A\},~x_{B_1}\le x\le x_{B_2},y_A\lt y_A'$，则显然 $A$ 在 $B$ 的正下方；若 $\exists~x\in \{x_A\},~x_{B_1}\le x\le x_{B_2},y_A\gt y_A'$，则 $B$ 在 $A$ 的正下方。注意：上面解析式里 $x$ 的条件要特判，以防 **RE**。（亲测，棍子的端点是闭的，也就是说端点~~微微~~擦过也叫**碰撞**）

接下来就是求拓扑序，好像都是拿队列写的 ~~（确实要快一点）~~，那我就来一发 _dfs_ 。从每根入度为 $0$ 的棍子开始 _dfs_ ，回溯的时候将棍子依次输出就好啦。[$521$~~(ms)~~ 啦！](https://www.luogu.com.cn/record/134254932)

时间复杂度就是 $\mathcal O(n^2)$。

## Code
```cpp
#include <iostream>
#define swap(a,b) a^=b,b^=a,a^=b
using namespace std;
const int N = 5003, M = 12500000;
int n, head[N], nex[M], to[M], cnt;
bool in[N], vis[N];
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
struct nm{
	int x, y, xx, yy;
	double k, b;
	void init(){
		x = read(), y = read();
		xx = read(), yy = read();
		if(x > xx || x == xx && y > yy) swap(x, xx), swap(y, yy);
		if(x != xx){
			k = (double)(yy - y) / (xx - x);
			b = (double)(xx * y - x * yy) / (xx - x);
		}
		else k = b = 0;
	}
} x[N];
void add(int &a, int &b){
	in[b] = 1;
	to[++ cnt] = b;
	nex[cnt] = head[a];
	head[a] = cnt;
}
bool solve(nm &a, nm &b, int &i, int &j){
	if(b.x != b.xx){
		if(b.x <= a.x && a.x <= b.xx)
			if(a.y < (double)b.k * a.x + b.b) return add(j, i), 0;
			else return add(i, j), 0;
		if(b.x <= a.xx && a.xx <= b.xx)
			if(a.yy < (double)b.k * a.xx + b.b) return add(j, i), 0;
			else return add(i, j), 0;
	}
	return 1;
}
void dfs(int &x){
	vis[x] = 1;
	for(int i = head[x]; i; i = nex[i])
		if(!vis[to[i]])
			dfs(to[i]);
	write(x), putchar(' ');
}
int main(){
	n = read();
	for(int i = 1; i <= n; ++ i) x[i].init();
	for(int i = 1; i <= n; ++ i)
		for(int j = i + 1; j <= n; ++ j)
			if(solve(x[i], x[j], i, j))
				solve(x[j], x[i], j, i);
	for(int i = 1; i <= n; ++ i) if(!in[i]) dfs(i);
	return 0;
}
```


---

## 作者：AK_heaven (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P7860)

算法标签：拓扑排序，几何学。

按照题目规则，我们需要每次移走最下面的一根木棍。考虑会碰撞的情况，我们会发现木棍一号会阻挡木棍二号当且仅它们在 x 轴上的射影有交际，且在他们的射影相交段的某个 x 坐标对应 y 轴坐标二号的值大于一号。

上述只需要在输入的时候就算出该木棍的函数即可，这样在建图询问时常数会更优。

于是我们只需要合理的去找上面所述的 x 坐标。

我们会发现，只要去最大的左端点或者最小的右端点就可以避免上述题解所说的木棍是竖着的情况。

为了保证序列符合先后顺序，我们只需要把每个木棍看作一个点，跑拓扑排序即可。

建图时间 $ O(n^2)$。跑图时间 $ O(n + E)$，其中 $E$ 为边数。

---

## 作者：xiaoke2021 (赞：1)

一眼丁真鉴定为：拓扑排序。

---

> 为了方便说明，以下内容中默认 $x_1 \le x_2$，$y_1$ 和 $y_2$ 的顺序随 $x_1$ 和 $x_2$ 的顺序的改变而改变。

不难想到，对于编号为 $i,j$ 的两条线段，如果线段 $i$ 与线段 $j$ 满足下列条件，线段 $i$ 必须在线段 $j$ 之前挪走：

1. 如图所示，绿色线段为线段 $i$，红色线段为线段 $j$。

![](https://s2.loli.net/2024/08/14/mNLzokfTGaH473x.jpg)

从图中看出，分别过两条线段的端点向 $x$ 轴作垂线，连接与 $x$ 轴的交点成一条线段，即橙色线段和蓝色线段。

**这两条线段有重合部分** 是第一个条件。这很好判断，只要 $x_{1_j} \le x_{1_i} \le x_{2_j}$ 或 $x_{1_j} \le x_{2_i} \le x_{2_j}$ 即可。

2. 仍以上图为例。

我们发现，在第 1 点成立时，还需要保证绿色线段在红色线段的“下方”。

但这一点很模糊，也很不好判断。我们设蓝色线段的端点中在橙色线段上的端点所对应的绿色线段上的端点的纵坐标为 $y'$。例如，在上图中蓝色线段的两个端点 $(3,0)$ 和 $(5,0)$ 中，$(3,0)$ 在橙色线段上，这个端点对应的绿色线段上的端点是 $(3,4)$，所以本例中 $y'=4$。

接下来分点讨论。

- 由于题目有明确的答案，所以两条线段显然不会在一开始就相交。

- 当 $y' > \max(y_{1_j},y_{2_j})$ 时：

此时绿色线段必然在红色线段 **上方**，很显然 **不符合** 要求。

- 当 $0 \le y' < \min(y_{1_j},y_{2_j})$ 时：

此时绿色线段必然在红色线段 **下方**，很显然 **符合** 要求。

- 当 $\min(y_{1_j},y_{2_j}) \le y' \le \max(y_{1_j},y_{2_j})$ 时：

这是比较坑的。比如说，上图就是一个满足此不等式的例子，这时显然符合要求。

但如果我改一下？

![](https://s2.loli.net/2024/08/14/sqoQ9kRwC5Zhmbv.jpg)

此时绿色线段也符合此不等式，但显然不符合要求。

为什么会出现这样的情况？让我们注意蓝色虚线与红色线段的交点。

![](https://s2.loli.net/2024/08/14/ezB9tj4yoWDSTvC.jpg)

这是第一幅图，此时 $y'=4$。

![](https://s2.loli.net/2024/08/14/huf5DBZWXVc6bsw.jpg)

这是第二幅图，此时 $y'=3$。

容易发现，第一幅图中蓝色虚线和红色线段的交点的纵坐标大于 $y'$，此时符合条件；而第二幅图则完全相反。

设蓝色虚线和红色线段的交点的纵坐标为 $y''$，则得出结论：

当 $\min(y_{1_j},y_{2_j}) \le y' \le \max(y_{1_j},y_{2_j})$ 且 $y''>y'$ 时，符合条件。

$y''$ 可以通过一次函数求出，代码中会有详细说明。

---

终于说完了分类讨论。在满足上述要求时，可以从 $i$ 向 $j$ 连边，跑一遍拓扑排序就行了。

注意线段是竖线或橙色、蓝色线段有完全重合的情况。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=30000000+5;
struct node{
	double xa,ya,xb,yb;
	double a,b;
	bool is_vertical=false; //是竖线
	void work(){
		if((this->xa)-(this->xb)==0){
			this->is_vertical=true;
			return ;
		} //此时是竖线，可以想一下
		
		this->a=((this->ya)-(this->yb))/((this->xa)-(this->xb));
		this->b=this->ya-(this->a)*(this->xa);
		// 一次函数相关
		return ;
	}
};
int n;
node s[5000+5];
int to[MAXN],nxt[MAXN],head[MAXN],degree[MAXN];
int cnt;
queue<int> q;
bool check(int i,int j){
	if(i==j) return false;
	
	if(s[i].xa<=s[j].xa&&s[j].xb<=s[i].xb){
		double y=s[i].a*s[j].xa+s[i].b;
		if(s[i].is_vertical) y=max(s[i].ya,s[i].yb);
		if(s[j].ya>=y) return true;
		else return false;
	} //重合情况
	
	if(s[j].xa<=s[i].xa&&s[i].xa<=s[j].xb){
		if(s[j].is_vertical)
			if(min(s[j].ya,s[j].yb)>=s[i].ya) return true;
			else return false;
			
		double y=s[j].a*s[i].xa+s[j].b; //一次函数
		if(y>=s[i].ya) return true;
		else return false;
	}else if(s[j].xa<=s[i].xb&&s[i].xb<=s[j].xb){
		if(s[j].is_vertical)
			if(min(s[j].ya,s[j].yb)>=s[i].yb) return true;
			else return false;
			
		double y=s[j].a*s[i].xb+s[j].b; //一次函数
		if(y>=s[i].yb) return true;
		else return false;
	}else return false;
}
void add(int a,int b){
	to[++cnt]=b;
	nxt[cnt]=head[a];
	head[a]=cnt;
	degree[b]++;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i].xa>>s[i].ya>>s[i].xb>>s[i].yb;
		if(s[i].xa>s[i].xb) swap(s[i].xa,s[i].xb),swap(s[i].ya,s[i].yb);
		s[i].work();
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(check(i,j))
				add(i,j);
//	for(int i=1;i<=n;i++) cout<<degree[i]<<" ";
	for(int i=1;i<=n;i++)
		if(degree[i]==0)
			q.push(i);
	while(!q.empty()){ //拓扑排序
		int u=q.front();
		q.pop();
		cout<<u<<" ";
		for(int i=head[u];i;i=nxt[i]){
			degree[to[i]]--;
			if(degree[to[i]]==0) q.push(to[i]);
		}
	}return 0;
}
```

---

## 作者：GCSG01 (赞：0)

## P7860 ARTUR

### 题意

有 $n$ 根棍子放在桌面上，求一个将棍子向桌子 $x$ 轴边缘移动的顺序，使棍子不发生碰撞（棍子向桌子边缘移动的速度相同）。

### 思路

思考一根一根移动的过程，每次找到一个可以朝 $x$ 轴边缘移动的棍子，将其移动，当这个棍子移动后，一些原本被它所遮挡的木棍也会变成可以移动。可以发现这与拓扑排序的过程很像，于是我们就可以将这道题转换为求拓扑排序的过程，连边则将一条棍子与它所遮挡的棍子进行连边，也就是与它在 $x$ 轴上的投影有重合部分的棍子进行连边。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5005;
int n;
int in[N];
int f[N];
vector<int>ans;
queue<int>q; 
vector<int>a[N];
struct node{
	int x1,x2,y1,y2;
}b[N];
int check(node u,node v)
{
	int flag=1;		
	if(u.x1>v.x1)swap(u,v),flag=-flag;	
	if(u.x2<v.x1)return 0; 
	double x,y,z;
	if(!(u.x2-u.x1))
	{
		x=1.0*(v.y2-v.y1)/(v.x2-v.x1);
		y=(double)v.y1-x*v.x1;
		z=x*u.x1+y;
		if(u.y1>z)return flag;
		return -flag;
	}
	x=1.0*(u.y2-u.y1)/(u.x2-u.x1);
	y=(double)u.y1-x*u.x1;
	z=x*v.x1+y;   
	if(z>v.y1)return flag;
	return -flag;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{ 
		cin>>b[i].x1>>b[i].y1>>b[i].x2>>b[i].y2;
		if(b[i].x1>b[i].x2)swap(b[i].x1,b[i].x2),swap(b[i].y1,b[i].y2);//要swap!!! 
	} 
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
            int op=check(b[i],b[j]);
            if(op==1)in[i]++,a[j].push_back(i);
            if(op==-1)in[j]++,a[i].push_back(j);
		}
	for(int i=1;i<=n;i++)
		if(!in[i])q.push(i),ans.push_back(i),f[i]=1;
	while(!q.empty()) 
	{
		int u=q.front();q.pop();
		for(int i:a[u])
		{
			in[i]--;
			if(!in[i])f[i]=1,ans.push_back(i),q.push(i);
		}
	}
	for(int i:ans)
		cout<<i<<" ";
	return 0;
}
```

---

## 作者：scc36 (赞：0)

[原题跃迁窗口](https://www.luogu.com.cn/problem/P7860)    
强烈推荐[这位巨佬](https://www.luogu.com.cn/user/241485)的[这篇博客](https://www.luogu.com.cn/article/jzekq65q)，受益良多。%%%    
### 思路  
其实这题本身就是一个拓扑排序的板子，这里就不讲拓扑了，不懂的话请移步[这里](https://www.luogu.com.cn/problem/B3644)。    
本题的重点在于如何判断哪一根棍子先动。    

假设有棍子 $t$ 和 $w$，其两端的坐标分别为 $t_{x1}$，$t_{y1}$，$t_{x2}$，$t_{y2}$ 和 $w_{x1}$，$w_{y1}$，$w_{x2}$，$w_{y2}$，默认 $t_{x1}$ 在 $w_{y1}$ 左边，即 $t_{x1} < w_{y1}$。    
总共会有三种情况：   
1. 两根棍子滚动时不会撞在一起
2. $t$ 在 $w$ 的上面，要先动 $w$。
3. $t$ 在 $w$ 的下面，要先动 $t$。

先看第一种，不难发现，在 $t_{x1} < w_{y1}$ 的前提下，如果 $t_{x1} < w_{y1}$ 也成立的话，两根棍子就不会相撞。    
然后就要解决后两种了。可以找个直角坐标系画一画，不难发现，如果我们过点 $(w_{x1},w_{y1})$ 画一条垂直于 $x$ 轴的直线，就会与棍子 $t$ 有一个交点，如果这个交点在 $(w_{x1},w_{y1})$ 的上面，则 $t$ 就在 $w$ 的上面；如果在下面， $t$ 在 $w$ 的下面。  
形象化的，设这个交点为 $(w_{x1},yy)$。当 $yy > w_{y1}$ 时，$t$ 在 $w$ 的上面；反之，当 $yy < w_{y1}$ 时，$t$ 在 $w$ 的下面。    
于是现在的问题就变成了求交点的坐标。这点不难，我们只需求出 $t$ 所在直线的一次函数表达式，然后就能把 $yy$ 套出来。    
特别注意：当棍子 $t$ 本身就垂直于 $x$ 轴时，$t$ 所在直线就不是一次函数了，此时上述 $t$ 和 $w$ 的功能就要反转了。
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,x1[100001],x2[100001],y2[100001],v;
int f[1000001],ff[1000001],b[1000001],t,w,l,fx;
vector<int>e[100001];
struct no{
	double k,b;
};
//求一次函数的系数 k 和常数 b 
no suan(int x1,int y1,int x2,int y2){
	//y1=x1*k+b y2=x2*k+b
	no xi;
	xi.k=(y1-y2)*1.0/(x1-x2)*1.0;
	xi.b=y1*1.0-x1*1.0*xi.k;
	return xi;
}
//判断是否会撞在一起。
//不会相撞：返回0
//先动后者，返回1
//先动前者，返回-1 
int jiao(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){
	int fl=1;
	double y;
	no xi;
	if(x1>x3) swap(x1,x3),swap(x2,x4),swap(y1,y3),swap(y2,y4),fl=-1;
	if(x2<x3) return 0;
	if(x1==x2){ //特殊情况 
		xi=suan(x3,y3,x4,y4);
		y=x1*1.0*xi.k+xi.b;
		if(y<y1*1.0) return fl;
		else return -fl;
	} 
	else{
		xi=suan(x1,y1,x2,y2);
		y=x3*1.0*xi.k+xi.b;
		if(y>y3*1.0) return fl;
		else return -fl;		
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int y1[100001];
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];
		if(x1[i]>x2[i]) swap(x1[i],x2[i]),swap(y1[i],y2[i]);
	}
	for(i=1;i<=n;i++) //每一种关系全都找一遍 
		for(j=i+1;j<=n;j++){
			v=jiao(x1[i],y1[i],x2[i],y2[i],x1[j],y1[j],x2[j],y2[j]);
			if(v==1) e[j].push_back(i),f[i]++;
			if(v==-1) e[i].push_back(j),f[j]++;
		}
	//以下为拓扑 
	for(i=1;i<=n;i++)
		if(f[i]==0){
			w++,b[w]=i;
			l++,ff[l]=i;
		}
	t=1;
	while(t<=w){
		fx=b[t];
		for(i=0;i<e[fx].size();i++){
			f[e[fx][i]]--;
			if(f[e[fx][i]]==0){
				w++,b[w]=e[fx][i];
				l++,ff[l]=e[fx][i];
			}
		}
		t++;
	}
	for(i=1;i<=n;i++) cout<<ff[i]<<" ";
}
```

---

## 作者：_zuoqingyuan (赞：0)

# 题面：
[这里](https://www.luogu.com.cn/problem/P7860)
# 分析：
假定要使某根木棍向下移动，且不碰到其他木棍，那我们要使得这根木棍下其他木棍比他先移动。

我们可以在此基础上建立一个有向图：如果木棍 $i$ 需要在木棍 $j$ 前移动，就连一条 $i$ 到 $j$ 的边。样例 $1$ 就是这样的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ou485ztn.png)

最后的答案就是这个图的拓扑序

# Code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
using namespace std;
struct node{
    int x1,x2,y1,y2;
}a[5005];//存储木棍的信息
queue<int> q;
const int N=5005*5005/2;
int n,d[5005],ver[5005],to[N],nxt[N],idx;
void add(int x,int y){
    to[++idx]=y,nxt[idx]=ver[x],ver[x]=idx;
}
int pd(node u,node v){  //判断木棒的相对位置，最核心的代码
	int f=1;		
	if(u.x1>v.x1) swap(u,v),f=-f;	
	if(u.x2<v.x1) return 0; 
	double k,B,yy;
	if(!(u.x2-u.x1)){
		k=1.0*(v.y2-v.y1)/(v.x2-v.x1);
		B=(double)v.y1-k*v.x1;
		yy=k*u.x1+B;
		if(u.y1>yy) return f;
		return -f;
	}
	k=1.0*(u.y2-u.y1)/(u.x2-u.x1);
	B=(double)u.y1-k*u.x1;
	yy=k*v.x1+B;   
	if(yy>v.y1) return f;
	return -f;
}
void topsort(){//拓扑排序板子
    for(int i=1;i<=n;i++){
        if(!d[i]){
            cout<<i<<" ";
            q.push(i);
        }
    }
    while(q.size()){
        int t=q.front();q.pop();
        for(int i=ver[t];i;i=nxt[i]){
            int tp=to[i];
            d[tp]--;
            if(d[tp]==0){
                cout<<tp<<" ";
                q.push(tp);
            }
        }
    }
    return;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%d %d %d %d",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
        if(a[i].x1>a[i].x2)swap(a[i].x1,a[i].x2),swap(a[i].y1,a[i].y2);//让两个端点有先后顺序
    }
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            int p=pd(a[i],a[j]);
            if(p==1)add(j,i),d[i]++;
            if(p==-1)add(i,j),d[j]++;//建图
        }
    }
    topsort();
    return 0;
} 
```
如有错误，请指出。


---


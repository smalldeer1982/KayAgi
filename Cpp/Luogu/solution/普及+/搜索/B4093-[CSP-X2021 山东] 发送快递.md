# [CSP-X2021 山东] 发送快递

## 题目背景

**原题为错题，不可做。数据范围修改如下，请以题目背景中的为准：**

【数据范围和限制】

对于 $40\%$ 的数据，$1 \leq n \leq 23$，$1 \leq a_i \leq 100$，$s=0$，$m$ 的值保证有解。

对于 $100\%$ 的数据，$1 \leq n \leq 23$，$1 \leq a_i \leq 100$，$0 \leq s \leq 15$，$m$ 的值保证有解。

**为了防止无意义的钻牛角尖的 hack，本题认为 $m$ 不超过 $2^{31}-1$。**

## 题目描述

小华有 $n$ 本不同的书（编号为 $1,2,3,\dots,n$），重量分别是 $a_1,a_2,\dots,a_n$ 公斤（重量可以相同）。他想把这些书以快递的方式发给自己的好朋友，要求每个包裹的重量不能超过 $m$ 公斤（可以等于 $m$ 公斤），并且小华想把其中一些书（一组书，用书的编号给出来）放在一个包裹里，应该如何打包才能使得快递件数最少。

## 说明/提示

【输入输出样例 1 说明】

第 $1$ 本和第 $4$ 本打包，重量是 $10$ 公斤。第 $2$ 本和第 $5$ 本打包，重量是 $9$ 公斤。第 $3$ 本单独打包，重量是 $8$ 公斤。所以一共 $3$ 件快递。

【输入输出样例 2 说明】

第 $1$ 本和第 $5$ 本打包，第 $2$ 本、第 $4$ 本、第 $8$ 本和第 $10$ 本打包，第 $3$ 本和第 $7$ 本打包，第 $6$ 本和第 $9$ 本打包。所以一共 $4$ 件快递。

【数据范围和限制】

对于 $40\%$ 的数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 100$，$s=0$，$m$ 的值保证有解。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 100$，$0 \leq s \leq 100$，$m$ 的值保证有解。

## 样例 #1

### 输入

```
5 10
8 4 8 2 5
0```

### 输出

```
3```

## 样例 #2

### 输入

```
10 80
49 11 44 18 28 24 19 10 27 29
2
1 5
4 8 2```

### 输出

```
4```

# 题解

## 作者：Yxy7952 (赞：3)

[题目传送门](/problem/B4093)

有错误请指出。

## 思路

看到 $n \leq 23$ 的数据范围，想到 DFS 暴力。

做法很简单，首先把是一个组的数都预处理好，之后 DFS。对于不在任何一个组里的数 $x$ 有两种选择，第一是放入已经有的包裹，第二是自己拿一个新的包裹。而如果 $x$ 在其中一个组里，显然它只能放入自己所在组的包裹里。

代码细节非常的多，这里将说明我遇到的问题（可能有点乱，请自行整理）：

1.  $x$ 如果在一个组里，它必须放入自己所在组的包裹里，如果放不下，说明方案有问题，直接回溯。有一个简单的方法，在搜索前预处理好要放在一个组里的包裹的重量，在 DFS 里可以直接跳过选择它们。
2.  输入时是有 $s$ 行，每行若干个数，不以 $0$ 结尾，以换行结尾。
3.  当 $a$ 和 $b$ 在一个组里，$b$ 和 $c$ 在一个组里时，$a$ 和 $c$ 在一个组里（我的方法是用并查集）。
4.  初始时已经有一些包裹了。

剪枝优化：

1.   最优性剪枝：包裹数大于等于最少包裹数时回溯。
2.   贪心，将包裹重量从大到小排序，因为轻的更灵活多变，放的方案肯定比放重的多，所以先放重的，减少轻的物品的枚举次数。
3.   贪心，将新拿一个包裹装物品的 DFS 放到枚举用哪个包裹装的 DFS 后面，显然多拿包裹没有益处，只会增加答案和枚举次数，此时算出当前最优答案 Ans 时，利用最优性剪枝可以将这些情况都卡掉。 

## 代码
有点复杂了，简单看一下吧。

总共耗时 $74ms$，妥妥最优解（第一名的代码修改数据后无法通过此题）。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 25 ; 
int n , m , s , f[N] , vis[N] ; 
int h[N] ; 
int ans = N ; 
struct node{
	int s , id ; 
}a[N] ; 
bool cmp(node x , node y){ return x.s > y.s ; }
int find(int x){
	if(f[x] == x) return x ; 
	return f[x] = find(f[x]) ; 
}
void add(int x , int y){
	vis[x] = vis[y] = 1 ; 
	x = find(x) , y = find(y) ; 
	if(x != y) f[y] = x ; 
}
void dfs(int x , int sum){
	if(sum >= ans) return ; 
	if(x == n + 1){
		ans = min(sum , ans) ; 
		return ; 
	}
	if(vis[a[x].id]){
		dfs(x + 1 , sum) ; 
		return ; 
	}
	for(int i = 1 ; i <= sum ; i++){
		if(h[i] + a[x].s > m) continue ; 
		h[i] += a[x].s ; 
		dfs(x + 1 , sum) ; 
		h[i] -= a[x].s ; 
	}
	h[sum + 1] = a[x].s ; 
	dfs(x + 1 , sum + 1) ; 
	h[sum + 1] = 0 ; 
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> m ; 
	for(int i = 1 ; i <= n ; i++) cin >> a[i].s , a[i].id = f[i] = i ; 
	cin >> s ; 
	for(int i = 1 ; i <= s ; i++){
		int num ,  num2 ; 
		cin >> num2 ; 
		if(cin.get() == '\n') continue ; 
		while(cin >> num){
			add(num2 , num) ; 
			if(cin.get() == '\n') break ; 
		}
	}
	int T[N] = {0} , z = 0 ; 
	for(int i = 1 ; i <= n ; i++){
		if(vis[i]){
			int fa = find(i) ; 
			if(!T[fa]) z++ , T[fa] = z , h[T[fa]] = a[i].s ; 
			else h[T[fa]] += a[i].s ; 
		}
	}
    //预处理出已有的包裹和包裹重量。
	sort(a + 1 , a + n + 1 , cmp) ; //排序只能放这里，可以思考一下为什么。
	dfs(1 , z) ; 
	cout << ans ; 
	return 0;
}
```

## hack 数据

给一个没有用处的 hack 数据吧。

in:
```cpp
5 10
3 1 2 4 4
3
1 2
3 4
1 3
```
out:
```cpp
2
```

---

## 作者：xinxin2022 (赞：2)

注意到 $n \le 23$，可以尝试搜索。

首先把必须放在同一个包裹里的一组书合并，当成一大本书处理。

然后分为两部分搜索：

先枚举能放在哪些已有包裹里，对于还能放下这本书的进行搜索。

然后考虑新建一个包裹，把这本书放到新包裹里，然后搜索。

不加剪枝可以做到[这样](https://www.luogu.com.cn/record/199939456)。

然后考虑对于当前包裹数量已经大于等于目前答案的方案，直接停止搜索。

容易做到[接近满分](https://www.luogu.com.cn/record/199941845)。

然后容易发现质量较大的书选择空间比较小，可以让质量大的书先选择包裹，以此限制小质量书的选择空间。

成功[满分了](https://www.luogu.com.cn/record/199943282)。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,ans=54,c[55],b[55],a[55],r,lst,p,k;
vector<int> G[55];
bool vis[55];
void build(int now){
    vis[now]=1;
    a[p]+=b[now];
    for(int i:G[now]){
        if(!vis[i]) build(i);
    }
}
bool cmp(int a,int b){
    return a>b;
}
void dfs(int now,int val){
    if(val>=ans) return;
    //大于目前答案直接剪掉
    if(now==p+1){
        ans=val;
        return ;
    }
    for(int i=1;i<=k;i++){
        if(c[i]+a[now]<=m){
            c[i]+=a[now];
            dfs(now+1,val);
            c[i]-=a[now];
        }
    }
    //插到已有包裹里
    k++;
    c[k]+=a[now];
    dfs(now+1,val+1);
    //新开包裹
    c[k]-=a[now];
    k--;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>b[i];
    }
    cin>>s;
    for(int i=1;i<=s;i++){
        cin>>lst;
        while(cin>>r){
            G[lst].push_back(r);
            G[r].push_back(lst);
            lst=r;
            if(cin.get()=='\n') break;
        }
    }
    for(int i=1;i<=n;i++) if(!vis[i]) p++,build(i);
    //合并必须放一起的书
    sort(a+1,a+1+p,cmp);
    //p表示合并完还有多少本书
    dfs(1,0);
    cout<<ans;
    return 0;
}
```

---

## 作者：ty_mxzhn (赞：0)

首先强选就是来搞笑的，我们直接把这些书放在一起作为一本新书就行。

然后考虑设计 $f_{i,j}$ 表示考虑了 $j$ 这个集合里的书时，把 $i$ 堆书分别捆了，剩下的还没捆的书占了 $f_{i,j}$ 的重量。

转移有两种：

1. $f_{i+1,j}=0$
2. $f_{i,j\cap k}=f_{i,j}+a_k$

直接转移即可，时间复杂度 $O(n2^n)$。

---

## 作者：cxoi1711 (赞：0)

## 题目传送门：[B4093 [CSP-X2021 山东] 发送快递](https://www.luogu.com.cn/problem/B4093)
## 思路：
这题是状压 DP 的模版题，和[这题](https://www.luogu.com.cn/problem/P3052)几乎一模一样，这种题给小学生考，确实太难了（2023 年[慈溪市](https://baike.baidu.com/item/%E6%85%88%E6%BA%AA%E5%B8%82/2384416?fromtitle=%E6%85%88%E6%BA%AA&fromid=431775&fr=aladdin)小学生计算机程序设计竞赛复赛的第四题也考了状压 DP，蒟蒻做得脑子炸了，我把[卷子](https://www.luogu.com.cn/problem/U526206)给各位 dalao 看一下），但蒟蒻喜欢用深搜。

题目说有 $s$ 组书籍需要捆绑，而且 $n$ 比较小，于是，我们可以用~~神搜~~深搜配上~~剪纸~~剪枝来求最优解。$i$ 从 $1$ 跑到 $num$，每次判断有没有超重，超重则舍去，否则进入下一层深搜，如果超出边界，记录答案，一旦 $num$ 比现在的答案大或者等于，直接返回，起到剪枝的作用，但以下程序只有 $16$ 分。

## 16pts：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s,a[20],w[20],ans=20;
void dfs(int num,int MAN){
	if(MAN>n){
		ans=min(ans,num);
		return ;
	}
	if(num>=ans){
		return ;
	}
	for(int i=1;i<=num;i++){
		if(w[i]+a[MAN]<=m){
			w[i]+=a[MAN];  
			dfs(num,MAN+1);
			w[i]-=a[MAN];
		} 
	}
	w[num+1]+=a[MAN];
	dfs(num+1,MAN+1);
	w[num+1]-=a[MAN];
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	cin>>s;
	if(s!=0){
		while(s--){
			int x,poker=0;
			while(cin>>x){
				if(poker==0) poker=x;
				else{
					a[poker]+=a[x];
                    a[x]=0;
				}
				if(getchar()=='\n')break;
			}
		}
	}
	dfs(1,1);
	cout<<ans;
}
``````

于是，我又想到了用贪心，用一个 $ans$ 数组统计重量，最后输出组数即可，不过只有 $48$ 分。
## 48pts：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1010],S,ans[1010],k,b[1010],kk;
bool flag[1010];
int main(){
	memset(flag,1,sizeof flag);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	cin>>S;
	int k=S;
	for(int i=1;i<=S;i++){
		string s="";
		cin>>s;
		int shu=0;
		for(int j=0;j<s.size();j++){
			if(isdigit(s[j]))shu=shu*10+s[j]-'0';
			else{
				ans[i]+=a[shu];
				flag[shu]=0;
				shu=0;
			}
		}
		if(shu>0){
			ans[i]+=a[shu];
			flag[shu]=0;
			shu=0;
		}
	}
	memcpy(b,a,sizeof b);
	memset(a,0,sizeof a);
	for(int i=1;i<=n;i++)
		if(flag[i])a[++kk]=b[i];
	reverse(a+1,a+1+kk);
	while(kk>0){
		bool F=0;
		for(int i=1;i<=k;i++)
			if(m-ans[i]>=a[kk]){
				F=1;
				ans[i]+=a[kk];
				kk--;
				break;
			}
		if(F==0&&kk>0)ans[++k]=a[kk],kk--;
	}
	cout<<k;
}
``````
我又将深搜进行改正，增加了剪枝和排序，和一些~~奇葩~~名称，请各位不要见怪。
## 100pts：
```cpp
#include<bits/stdc++.h>
#define int long long
#define esle else
#define RE return
#define fi if
#define fir for
using namespace std;
int n,m,s,f[110],used[110];
int h[110];
int ans=110;
struct node{
	int s,ID;
}a[110];
bool cmp(node a,node b){
	RE a.s>b.s;
}
int find(int x){
	fi(f[x]==x)RE x;
	RE f[x]=find(f[x]);
}
void add(int x,int y){
	used[x]=used[y]=1;
	x=find(x),y=find(y);
	fi(x!=y)f[y]=x;
}
void dfs(int x,int sum){
	fi(sum>=ans)RE;
	fi(x>n){
		ans=min(sum,ans);
		RE;
	}
	fi(used[a[x].ID]){
		dfs(x+1,sum);
		RE;
	}
	fir(int i=1;i<=sum;i++){
		fi(h[i]+a[x].s>m)continue;
		h[i]+=a[x].s;
		dfs(x+1,sum);
		h[i]-=a[x].s;
	}
	h[sum+1]=a[x].s;
	dfs(x+1,sum+1);
	h[sum+1]=0;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	fir(int i=1;i<=n;i++)cin>>a[i].s,a[i].ID=f[i]=i;
	cin>>s;
	fir(int i=1;i<=s;i++){
		int num1,num12;
		cin>>num12;
		fi(cin.get()=='\n')continue;
		while(cin>>num1){
			add(num12,num1);
			fi(cin.get()=='\n')break;
		}
	}
	int T[110],z=0;
	memset(T,0,sizeof T);
	fir(int i=1;i<=n;i++){
		fi(used[i]){
			int father=find(i);
			fi(!T[father])z++,T[father]=z,h[T[father]]=a[i].s;
			esle h[T[father]]+=a[i].s;
		}
	}
	sort(a+1,a+n+1,cmp);
	dfs(1,z);
	cout<<ans;
}
``````

---


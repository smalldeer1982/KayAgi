# [科大国创杯小学组 2024] 博弈

## 题目描述

小可可和小聪聪最近在玩黑白棋！

在介绍本问题之前，我们先介绍黑白棋规则：

1. 游戏使用标准的 $8 \times 8$ 棋盘，上面初始时有四枚棋子：两枚黑色棋子和两枚白色棋子，按照对角线交叉排列。

2. 游戏开始时，黑方先行。

3. 玩家的目标是通过翻转对手的棋子，将棋盘上的大多数格子占为己有。

4. 每一步，玩家必须将自己的棋子放在一个合法的位置上。合法的位置必须满足以下条件：
   - 新放置的棋子必须与棋盘上已有的同色棋子在一条直线（水平、垂直或对角线）上夹住对方的一串棋子（夹住的意思是，在夹住的一端是己方的棋子，另一端是对方的棋子）。
   - 在夹住对方棋子的同时，所有被夹住的对方棋子都会被翻转成己方颜色。

5. 如果某一方无法合法落子，则该回合轮到对方继续行动。

6. 游戏继续进行，直到棋盘被填满或双方都无法合法落子。

7. 游戏结束时，棋盘上棋子数较多的一方获胜。如果双方棋子数相同，则为平局。

给定一个 $n \times n$ 棋盘上的黑白棋残局，对于接下来所有的可能局面——也就是说，黑方白方轮流行棋，白方先行，走到双方都无法行棋，在所有的可能状态中，最终黑方获胜的有多少种，白方获胜的有多少种，平局有多少种。

在本题中，我们定义残局为最多有不超过 $10$ 个未被放入棋子的格子。

需要注意的是：我们给出的棋盘不一定能够从一个合法的开局得到。你无需关心当前棋盘局面是如何形成的——即便它并不连通。

## 说明/提示

### 数据范围

- 数据点 $1 \sim 6$，$1 \leq n \leq 3$，空格子数不超过 $4$。
- 数据点 $7 \sim 12$，$1 \leq n \leq 4$，空格子数不超过 $5$。
- 数据点 $13 \sim 18$，$1 \leq n \leq 4$，空格子数不超过 $10$。
- 数据点 $19 \sim 23$，$1 \leq n \leq 5$，空格子数不超过 $5$。
- 数据点 $24 \sim 25$，$1 \leq n \leq 5$，空格子数不超过 $10$。

## 样例 #1

### 输入

```
3
-1 0 1
0 1 0
1 0 -1```

### 输出

```
2 0 0```

## 样例 #2

### 输入

```
4
-1 -1 -1 -1
-1 0 1 0
-1 1 0 1
-1 -1 -1 -1```

### 输出

```
1813 2494 519```

# 题解

## 作者：wangxiaochai (赞：1)

前几天恰好用 python 写了一个带有人机对弈功能的五子棋小游戏，结果就看到了这道题。这道题只是判断一种静态棋局的胜负手，比完全模拟一场对弈要简单许多。

但是五子棋和黑白棋在规则上有一些区别。五子棋在自己的回合中，如果不考虑胜负，可以落子在任何一个空白位置。而黑白棋中是存在落子“合法性”的问题，每次落子必须可以翻转对方的棋子，也就是题面中所说的“夹住”，如果没有合法落子，那么就换手。如果双方都不能合法落子，那么这盘棋就结束了，开始统计黑白棋子的数量，然后做出胜负判断。

结合本体的数据范围 $ 1≤n≤5 $，空格子数不超过 10，可以通过暴力枚举所有可能棋局，然后统计结果。

判断落子合法性的模块：
```cpp
// 判断在 (x, y) 位置落子是否合法
bool isValidMove(vector<vector<int> >& board, int x, int y, int player) {
    int n = board.size();
    int opponent = 1 - player;
    if (board[x][y] != -1) return false;
    for (int i = 0; i < 8; ++i) {
        int tx = x + dx[i], ty = y + dy[i];
        bool flipped = false;
        while (tx >= 0 && tx < n && ty >= 0 && ty < n && board[tx][ty] == opponent) {
            tx += dx[i];
            ty += dy[i];
            flipped = true;
        }
        if (flipped && tx >= 0 && tx < n && ty >= 0 && ty < n && board[tx][ty] == player) {
            return true;
        }
    }
    return false;
}
```
判断当前玩家是否有合法落子的可能：
```cpp
// 检查当前玩家是否有合法的落子位置
bool hasValidMove(vector<vector<int> >& board, int player) {
    int n = board.size();
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (isValidMove(board, i, j, player)) {
                return true;
            }
        }
    }
    return false;
}
```

如果可以落子，那么执行“翻转”操作：
```cpp
// 翻转被夹住的棋子
vector<vector<int> > flipPieces(vector<vector<int> > board, int x, int y, int player) {
    int n = board.size();
    int opponent = 1 - player;
    for (int i = 0; i < 8; ++i) {
        int tx = x + dx[i], ty = y + dy[i];
        vector<pair<int, int> > tempFlip;
        while (tx >= 0 && tx < n && ty >= 0 && ty < n && board[tx][ty] == opponent) {
            tempFlip.emplace_back(tx, ty);
            tx += dx[i];
            ty += dy[i];
        }
        if (tx >= 0 && tx < n && ty >= 0 && ty < n && board[tx][ty] == player) {
            for (auto& p : tempFlip) {
                board[p.first][p.second] = player;
            }
        }
    }
    board[x][y] = player;
    return board;
}
```
把前面这些模块都调用起来模拟棋手对弈：

```cpp
void playGame(vector<vector<int> > board, int player, int& blackWins, int& whiteWins, int& draws) {
    int n = board.size();
    if (!hasValidMove(board, player) && !hasValidMove(board, 1^player)) {
        int blackCount = 0, whiteCount = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (board[i][j] == 1) ++blackCount;
                else if (board[i][j] == 0) ++whiteCount;
            }
        }
        if (blackCount > whiteCount) ++blackWins;
        else if (whiteCount > blackCount) ++whiteWins;
        else ++draws;
        return;
    }
    bool canMove = false;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (isValidMove(board, i, j, player)) {
                canMove = true;
                vector<vector<int> > newBoard = flipPieces(board, i, j, player);
                playGame(newBoard, 1 - player, blackWins, whiteWins, draws);
            }
        }
    }
    if (!canMove) {
        playGame(board, 1^player, blackWins, whiteWins, draws);
    }
}
```
把读入棋盘信息、输出结果、变量定义等部分省略，这些内容请读者自行思考补充。

---

## 作者：hujiaqi364 (赞：0)

题意：一个黑白棋残局，求在最多 $m!$（$m$ 是棋盘空格数量）个结果中黑棋赢的方案数，白棋赢的方案数和平局的方案数。

黑白棋的规则见[题面](https://www.luogu.com.cn/problem/B4254)。

此题模拟较难，注意到数据范围 $n\le 5$，空格数不超过 $10$，考虑暴力。

先写出判断赢家的代码：

```cpp
void count()
{
	int sx=0,sy=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]==0)//a[i][j]==0时是黑子
				sx++;
			else if(a[i][j]==1)//a[i][j]==1时是白子
				sy++;
		}
	if(sx<sy)
		s1++;//黑棋赢的情况
	else if(sx>sy)
		s2++;//白棋赢的情况
	else
		s3++;//平局的情况
}
```

然后写出判断是否可以在 $(x,y)$ 落 $k$ 类型的棋子并判转的代码：

```cpp
bool check(int x,int y,int k)
{
	bool ret=0;//计算是否有至少某一方向的棋子被翻了，就是返回值
	for(int i=0;i<8;i++)
	{
		int px=x+dx[i],py=y+dy[i],s=0;
		bool ok=0;//判断是否能翻
		while(px>=1&&px<=n&&py>=1&&py<=n)
		{
			if(a[px][py]==!k)//这里的棋子是与当前棋子颜色相反的棋子
				s++;//s是可以翻的棋子数量
			else if(a[px][py]==k&&s)//找到可以“封口”的棋子了
			{
				ok=1;
				break;
			}
			else//要么是空，要么是中间没有棋子
				break;
			px+=dx[i];//移动
			py+=dy[i];
		}
		if(ok)//翻转
		{
			ret=1;
			int px=x+dx[i],py=y+dy[i];
			while(s--)
			{
				a[px][py]=k;
				px+=dx[i];
				py+=dy[i];
			}
		}
	}
	return ret;
}
```

然后写出 dfs：

```cpp
void dfs(int c,int k,int cant)//c是已走的步数，k是当前棋子，cant是连续下不了的次数
{
	if(c==m||cant>=2)//空格用完了或两边都下不了了，就是终局
	{
		count();
		return;
	}
	int p[6][6];//存储a数组，后面用于恢复a数组
	bool can=0;//能否找到能下棋的空格
	for(int i=1;i<=m;i++)
	{
		if(f[i])//f[i]代表空格是否被用
			continue;
		f[i]=1;
		memcpy(p,a,sizeof p);//p备份a
		a[x[i]][y[i]]=k;//尝试下棋
		if(check(x[i],y[i],k))//能下的话继续
		{
			can=1;
			dfs(c+1,!k,0);
		}
		memcpy(a,p,sizeof p);//p还原a
		a[x[i]][y[i]]=-1;//恢复空格
		f[i]=0;//回溯
	}
	if(!can)//下不了
		dfs(c,!k,cant+1);
}
```

最终代码（含输入，输出，省略3个函数的注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dx[8]={1,0,-1,0,1,1,-1,-1};//8方向
int dy[8]={0,1,0,-1,1,-1,1,-1};
int n,m,a[6][6],x[15],y[15],s1,s2,s3;//n是棋盘大小，m是空格数，a是棋盘，x和y是空格的位置，s1,s2,s3是三种终局情况的计数
bool f[15];//空格是否用过
void count()
{
	int sx=0,sy=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]==0)
				sx++;
			else if(a[i][j]==1)
				sy++;
		}
	if(sx<sy)
		s1++;
	else if(sx>sy)
		s2++;
	else
		s3++;
}
bool check(int x,int y,int k)
{
	bool ret=0;
	for(int i=0;i<8;i++)
	{
		int px=x+dx[i],py=y+dy[i],s=0;
		bool ok=0;
		while(px>=1&&px<=n&&py>=1&&py<=n)
		{
			if(a[px][py]==!k)
				s++;
			else if(a[px][py]==k&&s)
			{
				ok=1;
				break;
			}
			else
				break;
			px+=dx[i];
			py+=dy[i];
		}
		if(ok)
		{
			ret=1;
			int px=x+dx[i],py=y+dy[i];
			while(s--)
			{
				a[px][py]=k;
				px+=dx[i];
				py+=dy[i];
			}
		}
	}
	return ret;
}
void dfs(int c,int k,int cant)
{
	if(c==m||cant>=2)
	{
		count();
		return;
	}
	int p[6][6];
	bool can=0;
	for(int i=1;i<=m;i++)
	{
		if(f[i])
			continue;
		f[i]=1;
		memcpy(p,a,sizeof p);
		a[x[i]][y[i]]=k;
		if(check(x[i],y[i],k))
		{
			can=1;
			dfs(c+1,!k,0);
		}
		memcpy(a,p,sizeof p);
		a[x[i]][y[i]]=-1;
		f[i]=0;
	}
	if(!can)
		dfs(c,!k,cant+1);
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
			if(a[i][j]==-1)//存空格
			{
				x[++m]=i;
				y[m]=j;
			}
		}
	dfs(0,0,0);//从第0步用棋子0（黑）尝试
	cout<<s1<<' '<<s2<<' '<<s3;
}
```

时间复杂度：$O(n^2 m!)$，空间复杂度：$O(n^2+m)$。

---


# [NOIP 2002 提高组] 矩形覆盖

## 题目描述

在平面上有 $n$ 个点，每个点用一对整数坐标表示。例如：当 $n=4$ 时，$4$ 个点的坐标分别为：$p_1(1,1)$，$p_2(2,2)$，$p_3(3,6)$，$p_4(0,7)$，见图一。

![](https://cdn.luogu.com.cn/upload/image_hosting/dxc1c5k9.png)

这些点可以用 $k$ 个矩形全部覆盖，矩形的边平行于坐标轴。当 $k=2$ 时，可用如图二的两个矩形 $s_1,s_2$ 覆盖，$s_1,s_2$ 面积和为 $4$。问题是当 $n$ 个点坐标和 $k$ 给出后，怎样才能使得覆盖所有点的 $k$ 个矩形的面积之和为最小呢？  
约定：覆盖一个点的矩形面积为 $0$；覆盖平行于坐标轴直线上点的矩形面积也为 $0$。各个矩形必须完全分开（边线与顶点也都不能重合）。


## 说明/提示

对于 $100\%$ 数据，满足 $1\le n \le  50$，$1 \le k \le 4$，$0 \le x_i,y_i  \le 500$。

**【题目来源】**

NOIP 2002 提高组第四题

## 样例 #1

### 输入

```
4 2
1 1
2 2
3 6
0 7
```

### 输出

```
4```

# 题解

## 作者：_Life_ (赞：9)

### 题意
平面上有 $n$ 个点，将其包含在 $k$ 个矩形中（不相交），求矩形的最小面积和。

$n \le 50,1\le k \le 4$

### 题解
我们看到 $n \le 50$，并且结合 NOIP 早期题目的数据特水的尿性，自然而然地想到深搜，所以**大力深搜**即可。

深搜流程：
```cpp
//伪代码
void dfs(int u)
{
	if(u==n+1)
	{
		更新答案;
		return;
	}
	for(int i=0;i<k;i++)
	{
		将第u个点加入第i个矩形;
		if(矩形间不相交)
			dfs(u+1);
		将第i个矩形恢复成加入第u个点前的状态;
	}
}
```

不出意外，代码交上去之后跑得飞快！然后这道题就做完了！[AC记录](https://www.luogu.com.cn/record/52166733)

将点加入矩形/判断矩形间是否相交较为繁琐，代码实现细节见示例代码。

### 代码
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,k,x[55],y[55],ans=0x3f3f3f3f;
struct square
{
	int empty=1,x1,x2,y1,y2;//x1<=x2 y1<=y2
	void join(int u)//将第u个点加入矩形
	{
		if(empty)
			x1=x2=x[u],y1=y2=y[u];
		empty=0;
		x1=min(x1,x[u]),x2=max(x2,x[u]);
		y1=min(y1,y[u]),y2=max(y2,y[u]);
	}
	int area(){return (x2-x1)*(y2-y1);}//计算矩形面积
}squ[4];
int is_intersect(int a,int b,int c,int d)//ab/cd四条边分属两个矩形，判断是否有其他边夹在ab/cd之间
{
	return (a<=c&&c<=b)||(a<=d&&d<=b)||(c<=a&&a<=d)||(c<=b&&b<=d);
}
int is_intersect(int num)//判断矩形之间是否相交
{
	for(int i=0;i<k;i++)
		if(num!=i&&is_intersect(squ[num].x1,squ[num].x2,squ[i].x1,squ[i].x2)&&is_intersect(squ[num].y1,squ[num].y2,squ[i].y1,squ[i].y2))
			return 1;
	return 0;
}
void dfs(int u)
{
	if(u==n+1)
	{
		int sum=0;
		for(int i=0;i<k;i++)sum+=squ[i].area();
		ans=min(ans,sum);
		return;
	}
	for(int i=0;i<k;i++)
	{
		square t=squ[i];
		squ[i].join(u);
		if(!is_intersect(i))
			dfs(u+1);
		squ[i]=t;
	}
}
int main()
{
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d %d",&x[i],&y[i]);
	dfs(1);
	printf("%d",ans);
}
```

---

## 作者：ShineEternal (赞：4)

## 题目链接：
https://www.luogu.org/problem/P1034

这道题调了半天，纪念一下。

## 分析：

**搜索**。

~~总结一下其实发现早些年搜索题目挺多，主要是因为评测机不发达只能手工读入之类而能在工作人员承受之内的大概就是搜索极高的一般非正解的时间复杂度从而得到较小的数据~~

从第一个点往最后搜,在搜索中都有以下可以进入下一个分支的：

- 当前点包含在一个矩形内

- 当前点由一个矩形扩展过来

- 当前点自成一个矩形

**注意三条都要进行，因为题目说必须要弄出k个矩形，所以不存在搜索中贪心的相关思想**


## $code:$

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
struct ben
{
	int x1,y1,x2,y2;//记录矩形的左下角和右上角
}jx[10];
int ans=2147483647;
int n,k;
int x[55],y[55];

int check(int x,int cnt)//判断第x个矩形与其他是否重，=0有重，四种重复情况
{
	for(int i=1;i<=cnt;i++)
	{
		if(i!=x)
		{
			if(jx[i].x1<=jx[x].x1&&jx[i].x2>=jx[x].x1&&jx[i].y1<=jx[x].y1&&jx[i].y2>=jx[x].y1)
			return 0;
			if(jx[i].x2<=jx[x].x2&&jx[i].x2>=jx[x].x2&&jx[i].x2<=jx[x].y2&&jx[i].x2>=jx[x].y2)
			return 0;
			if(jx[i].y1<=jx[x].y1&&jx[i].y2>=jx[x].y1&&jx[i].x2<=jx[x].x2&&jx[i].x2>=jx[x].x2)
			return 0;
			if(jx[i].y1<=jx[x].y2&&jx[i].y2>=jx[x].y2&&jx[i].x2<=jx[x].x1&&jx[i].x2>=jx[x].x1)
			return 0;
		}
	}
	return 1;
}	
int mj(int i)//矩形面积
{
	return (jx[i].x2-jx[i].x1)*(jx[i].y2-jx[i].y1);
}
void dfs(int now,int s,int cnt)
{
	if(s>ans)return ;
	if(now==n+1)
	{
		//printf("%d\n",s);
		if(cnt==k)
		ans=min(ans,s);
		return ;
	}
	
	
	for(int i=1;i<=cnt;i++)//判断能不能放在之前的 
	{
		if(jx[i].x1<=x[now]&&jx[i].x2>=x[now]&&jx[i].y1<=y[now]&&jx[i].y2>=y[now]) //now是否包含在第i个矩形里 
		{
			dfs(now+1,s,cnt);
		
		}
		else
		{
			int tmp1,tmp2,tmp3,tmp4;
			tmp1=jx[i].x1;
			tmp2=jx[i].x2;
			tmp3=jx[i].y1;
			tmp4=jx[i].y2;
			int stmpf=mj(i);
			if(x[now]<jx[i].x1)
			{
				
				jx[i].x1=x[now];
			}
			else
			if(x[now]>jx[i].x2)
			{
				jx[i].x2=x[now];
			}
			if(y[now]<jx[i].y1)
			{
				jx[i].y1=y[now];
			}
			else
			if(y[now]>jx[i].y2)
			{
				jx[i].y2=y[now];
			}
			int stmp=mj(i);
			if(check(i,cnt))
				dfs(now+1,s+stmp-stmpf,cnt);//扩大一个矩形 
			jx[i].x1=tmp1;
			jx[i].x2=tmp2;
			jx[i].y1=tmp3;
			jx[i].y2=tmp4;
		}
	}
	
	//if(flag==1)return ;
	if(cnt==k)return ;
	
	cnt++;
	
	jx[cnt].x1=x[now];
	jx[cnt].x2=x[now];
	jx[cnt].y1=y[now];
	jx[cnt].y2=y[now];
	dfs(now+1,s,cnt);//新增一个矩形 
	jx[cnt].x1=0;
	jx[cnt].x2=0;
	jx[cnt].y1=0;
	jx[cnt].y2=0;
	cnt--;
	return;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	dfs(1,0,0);
	printf("%d\n",ans);
	return 0;
} 
```


---


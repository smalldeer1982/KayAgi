# 费解的开关

## 题目描述

你玩过“拉灯”游戏吗？

$25$ 盏灯排成一个 $5 \times 5$ 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

下面这种状态

    10111
    01101
    10111
    10000
    11011


在改变了最左上角的灯的状态后将变成：

    01111
    11101
    10111
    10000
    11011


再改变它正中间的灯后状态将变成：

    01111
    11001
    11001
    10100
    11011


给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。

## 说明/提示

测试数据满足 $0 < n \le 500$。

## 样例 #1

### 输入

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111```

### 输出

```
3
2
-1```

# 题解

## 作者：hgfs (赞：18)

# 洛谷 P10449 费解的开关

## 暴力深搜 

（	 816ms /  564.00KB /  1011B C++98 O2）

优点：
1. ( 几乎无 ）

故曰 ： 仅作为一种新思路供参考。

思路：找到图中为 $0$ 的点，搜索周围四个点及他本身（改变这 $5$ 个点才能使该点为 $1$ ），直到整张图都为 $1$ 。（因为太过直接和暴力，所以好像再没什么多的解释了。）

部分难点：
1. 偏移数组：利用两个数组对应的元素进行上下左右偏移。（偏移数组通常意味着你有一个指针指向一个数组，并且你想要根据某个偏移量来访问数组中的元素。这可以通过使用指针算术来实现。（百度上的定义））

（剩余胎教请见注释）

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,s,px[5]={0,-1,0,1,0},py[5]={0,0,1,0,-1};//n 为 n 个待解决的游戏初始状态，
// s 记录每个状态中，遍历到不同的点时最少步数， px 和 py 是偏移数组（见上）。
bool g[10][10],an;//g是geography，即游戏初始状态；an判断是否有answer。
string a;//用来输入。 

int check(){//判断整张图是否都为 1 , 至于为什么是 int , 请看下面的返回值的注释 。 
	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++)
	if(!g[i][j]) return i;//返回出现 0 的行数 ，减少运算 。 
	return 0;//表示整张图都为 1 。 
}

void zuo(int a,int b){//操作 （ zuo ） ， 改变坐标为(a,b) 的点及四周的点的状态。 
	for(int i=0;i<=4;i++)
	g[a+px[i]][b+py[i]]=!g[a+px[i]][b+py[i]];
}

void su(int a){//深搜第 a 步。 
    if(a>7) return;//步数过多，直接排除。
	int x=check(),y;//x 行 y 列，即该步改变状态的点的坐标。 
    if(!x){//此时整张图都为 1 。
		s=min(s,a);//每次整张图都为 1 时最小的步数。 
		an=1;//已有 answer !! 
		return;
	}
	for(int i=1;i<=5;i++)//寻找此时图中状态为 0 的点。 
	if(!g[x][i]){// x 已在定义的时候找出了。 
		y=i;//定位到此时状态为 0 的点。
		break;
	}
	for(int i=0;i<=4;i++){//列举包括自己共 5 个点 ， 一一搜索一遍。
		int x2=x+px[i],y2=y+py[i];//确定点的坐标。
		if(x2<1 || x2>5 || y2<1 || y2>5) continue;//找到的点不在图中，无法改变
		                                          //状态。
		zuo(x2,y2);//改变该点的状态。
		su(a+1);//继续深搜修改过后的图。
		zuo(x2,y2);//状态还原，为了不影响以后的遍历。
	}

int main(){
	cin>>n;
	while(n--){
		s=10;// 初始为较大值（大于 6 即可）。
		an=0;// 初始无 answer（答案）。 
		for(int i=1;i<=5;i++){// 输入。
			cin>>a;
			for(int j=1;j<=5;j++) g[i][j]=a[j-1]-'0';
		}
		su(1);// 从第 1 个操作开始。 
		if(an) cout<<s-1<<endl;// 有答案。 
		else cout<<-1<<endl;// 无答案输出 -1 。 
	}
	return 0;
```

---

## 作者：Wind_love (赞：12)

## 思路
状压广搜，我们把灯的状态压缩到一个整数当中，用一个变换函数来对灯的状态进行变换，然后通过广搜预处理所有情况的最小操作数，输入后直接输出预处理的值即可。
## Code
```cpp
#include<bits/stdc++.h>
#define endl "\n"
using namespace std;
queue<int> q;
int ans,x;
short l[1<<26];//省空间
int qf(int x,int y){//改变灯的状态
	x^=(1<<y);
	if(y>4)x^=(1<<(y-5));
	if(y<20) x^=(1<<y+5);
	if(y%5!=0) x^=(1<<y-1);
	if(y%5<4) x^=(1<<(y+1));
	return x;
}
void bfs(){
	memset(l,-1,sizeof l);
	q.push((1<<25)-1);
	l[(1<<25)-1]=0;
	while(!q.empty()){
		int t=q.front();
		q.pop();
		if(l[t]>=6)break;
		for(int i=0;i<25;i++){
			if(l[qf(t,i)]==-1){
				q.push(qf(t,i));
				l[qf(t,i)]=l[t]+1;
			}
		}
	}
	return;
}
signed main(){
	int n;
	cin>>n;bfs();
	while(n--){
		int x=0;
		for(int i=0;i<5;i++){
			for(int j=0;j<5;j++){
				int t;
				scanf("%1d",&t);
				if(t) x=x|(1<<(i*5+j));
			}
		}
		cout<<l[x]<<endl;
	}
	return 0;//好习惯
}

---

## 作者：Venti24 (赞：9)

根据题意，我们要尽可能地在最小步数内把灯全部点亮。  
## 分析：  
可以使用递推的思路。如果该盏灯上一行未点亮，那么我们就改变这盏灯的状态。  
比如：  

| 1 | 0 | 1 |
| :----------: | :----------: | :----------: |
| **1** | **1** | **1** |
| **1** | **1** | **1** |    

我们发现，第一行中间的灯没有被点亮，因此我们选择改变第二行中间的灯，就变为：  

| 1 | 1 | 1 |
| :----------: | :----------: | :----------: |
| **0** | **0** | **0** |
| **1** | **0** | **1** |  

接着，我们尝试通过改变第三行的灯的状态来使得第二行的灯全部点亮。在这种情况下，第三行灯也恰好全部被点亮，这时我们就可以得出所有的灯全部被点亮。  

| 1 | 1 | 1 |
| :----------: | :----------: | :----------: |
| **1** | **1** | **1** |
| **1** | **1** | **1** |  

因此，我们考虑将第 $ i $ 行的灯**固定**不动，而通过改变第 $ i+1 $ 行的灯的去拼凑第 $ i $ 行的灯，使得第 $ i $ 行的灯全部被点亮。  
由于第 $ i $ 行的灯确定，那么第 $ i+1 $ 行的灯也是确定的。同样，第 $ i+2 $ 行的灯由第 $ i+1 $ 行的灯确定。通过归纳法，我们很容易得出，这种**第一行确定**，从而使得所有的灯被点亮的方案**至多只有一种**。  
所以，我们考虑**固定第一行**，接着依次递推下一行，直至最后一行能否全被点亮。若最后一行**恰好全部被点亮**，那么所有的灯都能够被点亮。  
  
对于第一行，我们则采用枚举第一行所有的点击方法 $(2^5=32)$ 种，再通过上述方法，就可以**涵盖整个状态空间**，接着在所有解中取最小值。由于只有 32 种状态，因此时间复杂度并不是很高。
##  
## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int T, a[10][10], b[10][10], steps = 6, delta[5][2] = {
	{0, 0, {0, 1}, {0, -1}, {1, 0}, {-1, 0}
}, ans = 7;

void readf(){ // 读入
	for(int i = 1; i <= 5; i++){
		char s[5];
		scanf("%s", s);
		for(int j = 0; j < 5; j++){
			a[i][j + 1] = s[j] - '0';
		}
	}
}

void change(int x, int y, int z[10][10]){  // 模拟点击
	for(int i = 0; i < 5; i++){
		int dx = delta[i][0], dy = delta[i][1];
		z[x + dx][y + dy] ^= 1;
	}
}

int distinguish(int line){ // 判断最后一行是否恰好全部点亮
	int temp = 1;
	for(int i = 1; i <= 5; i++){
		temp *= b[line][i];
	}
	return temp;
}

void dfs(int x){  // 这里的 x 指第一行的第 x 盏灯
	if(x > 5){  // 确定第一行的状态，开始进行递推
		memcpy(b, a, sizeof(a));  
		int step = steps;
		for(int i = 2; i <= 5; i++){
			for(int j = 1; j <= 5; j++){
				if(b[i - 1][j] == 0){  // 若第 i-1 行 j 列的灯没有点亮，则我们改变第 i 行 j 列的灯的状态
					change(i, j, b);
					step--;
				}
			}
		}
		if(distinguish(5) && step >= 0){  // 如果最后一行恰好全点亮并且在 6 步之内
			ans = min(ans, 6 - step);  // 有一种解法，则 ans 必定会改变
		}
		return;
	}
	
	dfs(x + 1); // 第一行第 x 盏灯不进行任何操作
	
	change(1, x, a);  // 对第一行第 x 盏灯进行一次状态改变
	steps--;
	
	dfs(x + 1);
	
	change(1, x, a);  // 回溯
	steps++;
}


int main(){
	scanf("%d", &T);
	for(int op = 1; op <= T; op++){
		readf();
		steps = 6;
		ans = 7;
		dfs(1);
		if(ans == 7) printf("-1\n");  // 枚举了所有状态，但是都无解，即 ans 没有改变
		else printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：zxh923 (赞：7)

# P10449 费解的开关 题解

[题目传送门](https://www.luogu.com.cn/problem/P10449)

### 思路

我们考虑从上到下判断每个开关是否操作，于是就有一个想法，我们枚举第一排的开关是否操作，那样下面的开关是否操作就唯一确定。

于是我们采用二进制枚举，如果这个二进制数的第 $i$ 位是 $1$，就操作第一排的这个开关。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 6
using namespace std;
char g[N][N],bg[N][N];
int dx[5]={-1,0,1,0,0},dy[5]={0,1,0,-1,0};
void tur(int x,int y){
    for(int i=0;i<5;i++){
        int a=x+dx[i],b=y+dy[i];//枚举周围4个点，进行更改
        if(a<0||a>4||b<0||b>4)continue;
        g[a][b]^=1;
    }
}
signed main(){
    int T;
    cin>>T;
    while(T--){
        for(int i=0;i<5;i++){
            cin>>bg[i];
        }
        int res=7;
        for(int op=0;op<32;op++){//二进制枚举
            int cnt=0;
            memcpy(g,bg,sizeof g);//还原
            for(int i=0;i<5;i++){
                if(op>>i&1){//如果是1就操作
                    tur(0,i);
                    cnt++;
                }
            }
            for(int i=0;i<4;i++){
                for(int j=0;j<5;j++){
                    if(g[i][j]=='0'){
                        tur(i+1,j);
                        cnt++;
                    }
                }
            }
            bool flag=1;
            for(int i=0;i<5;i++){
                if(g[4][i]=='0'){
                    flag=0;
                }
            }
            if(flag)res=min(res,cnt);
        }
        if(res>6)res=-1;//判断操作次数是否过多
        cout<<res<<'\n';
    }
    return 0;
}
```

---

## 作者：PineappleSummer (赞：5)

算阶 0x02 递推与递归：[P10449 费解的开关](https://www.luogu.com.cn/problem/P10449)。

来一篇使用 `bitset` 的题解。

由于询问次数过多，考虑预处理。从全为 $1$ 的状态搜索，搜索出所有合法的状态，询问时可以直接回答。

考虑广搜，将状态压缩为一个长度为 $25$ 的 $01$ 串。初始将全为 $1$ 的串加入队列，每次取队头，判断是否在 $6$ 步以内，如果合法便枚举按哪个开关，加入队列即可。

加入队列时需要记忆化。

对于每个状态，用 `bitset` 存一下，取反操作使用 `flip` 即可。

```cpp
#define B bitset <N> 
B calc (B x, int i) { // 计算按第 i 个开关后的状态
	x.flip (i); // flip 是取反操作 
	if (i % 5) x.flip (i + 1);
	if (i % 5 != 1) x.flip (i - 1);
	if (i <= 20) x.flip (i + 5);
	if (i > 5) x.flip (i - 5);
	return x;
}
unordered_map <B, int> mp; // 记忆化，同时记录步数
B b1;
void Pre () {
	for (int i = 1; i <= 25; i++) b1.set (i, 1);
	queue <B> q; q.push (b1);
	while (!q.empty ()) {
		B x = q.front (); q.pop ();
		if (mp[x] >= 6) break; // 合法情况已经走完 
		for (int i = 1; i <= 25; i++) {
			B y = calc (x, i);
			if (!mp[y] && y != b1) {
				mp[y] = mp[x] + 1; // 更新步数
				q.push (y);
			}
		}
	}
}
signed main () {
	ios::sync_with_stdio (false);
	cin.tie (0); cout.tie (0);
	
	cin >> t; Pre ();
	while (t--) {
		B b;
		for (int i = 1; i <= 5; i++)
			for (int j = 1; j <= 5; j++)
				cin >> a[i][j], b.set (5 * (i - 1) + j, a[i][j] ^ ('0')); // 状态压缩
		if (mp[b] == 0) cout << (b == b1 ? 0 : -1) << '\n'; // 是否合法
		else cout << mp[b] << '\n';
	}
	return 0;
}
```

---

## 作者：__Sky__Dream__ (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/P10449)

## 解题思路
对于一行中的 `0`，我们想到，直接点击它会影响左右的数字。所以便去点击这个 `0` 对应下一行的位置。

当第一行的点击方式固定了之后，按照上述的方法点击剩下的 $n-1$ 行，点击方案唯一且确定。

我们考虑枚举第一行的点击方式，采用**位运算枚举**，有 $2^5=32$ 种可能。

最后记得**另用数组**暂存原矩阵。

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[6][6],b[6][6];
int dx[5]={1,-1,0,0,0};
int dy[5]={0,0,0,-1,1},ans=1e9;
bool check(int x,int y){return x>=0&&x<5&&y>=0&&y<5;}
void change(int i,int j)
{
	for(int p=0;p<5;p++)
	{
		int x=i+dx[p],y=j+dy[p];
		if(check(x,y)) a[x][y]^=1;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int t;
	cin>>t;
	while(t--)
	{
		for(int i=0;i<5;i++) cin>>a[i]; 
		int sum=0;
		for(int pos=0;pos<32;pos++)
		{
			sum=0;
			memcpy(b,a,sizeof a);
			for(int i=0;i<5;i++)
			{
				if(pos>>i&1)
				{
					sum++;
					change(0,i);
				}
			}
			for(int i=0;i<4;i++)
			{
				for(int j=0;j<5;j++)
				{
					if(a[i][j]=='0')
					{
						sum++;
						change(i+1,j);
					}
				}
			}
			bool flag=true;
			for(int i=0;i<5;i++)
			{
				if(a[4][i]=='0')
				{
					flag=false;
					break;
				}
			}
			if(flag) ans=min(ans,sum);
			memcpy(a,b,sizeof b);
		}
		if(ans>6) ans=-1;
		cout<<ans<<endl;
		ans=1e9;
	}
	return 0;
}
```

拜拜！

---

## 作者：fire_and_sweets (赞：3)

注意到只要第一行灯的开关状态确定了，后面的也都能用递推依次确定。

所以，我们可以利用状态压缩的技巧，枚举出第一行灯的开关状态，然后算出后面的状态取最值。

具体细节见代码。

```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10, INF = 1e9;
const int dx[] = {1, 0, -1, 0, 0};
const int dy[] = {0, 1, 0, -1, 0};

int m, n = 5, minn, steps;

int a[N][N], t[N][N];
char ch;

bool range(int x, int y)
{
    if (x < 0 || x >= n) return false;
    if (y < 0 || y >= n) return false;
    return true;
}

void touch(int x, int y)
{
    steps ++ ;
    for (int i = 0; i < 5; i ++ )
    {
        int nx = x + dx[i], ny = y + dy[i];
        if (range(nx, ny)) a[nx][ny] = !a[nx][ny];       
    }
}

int main()
{
    cin >> m;
    while (m -- )
    {
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                cin >> ch, t[i][j] = ch - '0';
        
        minn = INF;
        
        for (int state = 0; state < (1 << n); state ++ )
        {
            steps = 0;
            for (int i = 0; i < n; i ++ )
                for (int j = 0; j < n; j ++ )
                    a[i][j] = t[i][j];
            for (int i = 0; i < n; i ++ )
                if (state >> i & 1) touch(0, i);
            for (int i = 0; i < n - 1; i ++ )
                for (int j = 0; j < n; j ++ )
                    if (a[i][j] == 0) touch(i + 1, j);
            bool ok = true;
            for (int i = 0; i < n; i ++ )
                if (a[n - 1][i] != 1) ok = false;
            if (ok) minn = min(minn, steps);
        }
        
        if (minn > 6) cout << -1 << endl;
        else cout << minn << endl;
    }
    return 0;
}
```

---

## 作者：mxjz666 (赞：3)

### 思路
我们可以枚举第一行的操作，接着我们判断一下剩下的能不能完成。如何判断呢？
如果第 $i$ 行第 $j$ 列为 $1$ ，则按下第 $i+1$ 行第 $j$ 列。如果到了最后一行没有成功或步数超过了，就枚举下一个状态。
### ~~丑陋的~~代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[8][8],tmp[8][8];
int b[34][8]={{0,0,0,0,0},{0,0,0,0,1},{0,0,0,1,0},{0,0,0,1,1},{0,0,1,0,0},
{0,0,1,0,1},{0,0,1,1,0},{0,0,1,1,1},{0,1,0,0,0},{0,1,0,0,1},{0,1,0,1,0},
{0,1,0,1,1},{0,1,1,0,0},{0,1,1,0,1},{0,1,1,1,0},{0,1,1,1,1},{1,0,0,0,0},
{1,0,0,0,1},{1,0,0,1,0},{1,0,0,1,1},{1,0,1,0,0},{1,0,1,0,1},{1,0,1,1,0},
{1,0,1,1,1},{1,1,0,0,0},{1,1,0,0,1},{1,1,0,1,0},{1,1,0,1,1},{1,1,1,0,0},
{1,1,1,0,1},{1,1,1,1,0},{1,1,1,1,1}};//第1行的所有状态 
void an(int x,int y){//按下第x行第y列 
	tmp[x][y]^=1;
	tmp[x+1][y]^=1;
	tmp[x-1][y]^=1;
	tmp[x][y-1]^=1;
	tmp[x][y+1]^=1;
}
bool ok(){//判断一个状态是否可行 
	for(int i=1;i<=5;i++){
		for(int j=1;j<=5;j++){
			if(tmp[i][j]==0)return false;
		}
	}
	return true;
}
int main(){
	cin>>n;
	while(n--){
		char c[8][8];
		int Min=10,cnt=0;
		for(int i=1;i<=5;i++){
			cin>>c[i];
			for(int j=1;j<=5;j++){
				a[i][j]=c[i][j-1]-'0';
			}
		}
		for(int h=0;h<32;h++){
			cnt=0;
			for(int ko=1;ko<=5;ko++){
				for(int jk=1;jk<=5;jk++){
					tmp[ko][jk]=a[ko][jk];
				}
			}
			for(int k=0;k<5;k++){
				if(b[h][k]==1){
					an(1,k+1);
					cnt++;                              
				}
			} 
			for(int i=2;i<=5;i++){
				for(int j=1;j<=5;j++){
					if(tmp[i-1][j]==0){
						an(i,j);
						cnt++;
					}
				}
			}
			if(cnt<=6&&ok()==true){
				Min=min(Min,cnt);
			}
		}
		if(Min==10){
			cout<<"-1\n";
		}else{
			cout<<Min<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Zhl2010 (赞：2)

## 题目概括

$25$ 盏灯排成一个 $5 \times 5$ 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。

## 思路

首先，考虑何时需要按下开关，因为每次按下开关都会导致十字区域的开关状态发生变化。因此，当线路 $i$ 和 $j$ 的开关断开时，按下较低线路 $i$ 和 $j$ 的开关就足够了。

如果第一行是固定的，例如，如果第一个行为 `11011`，则必须按下面第二行的第三列，第一行变为 `11111`。因为第二行的一个按钮被按下，导致第二行发生变化，例如 `01011`，所以第三行必须按下第一列和第三列的开关。此时，第二行也将变为 `11111`，并将继续上述第一排的情况是固定的，但第一排也可以按，有 $25$ 种按的方法。

因此，有必要首先列出开关被按第一行的情况，然后递归地推动所有后续行。

重要的是要注意，由于最后一行没有下一行，因此无法更改最后一行的状态。当我们从上到下按下最后一行时，我们需要确定最后一行是否处于完整状态 $1$。如果是，更新摁的次数（每次取最小值）。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int ans = INT_MAX;
int dx[5] = {-1, 0, 1, 0, 0},dy[5] = {0, 1, 0, -1, 0};
char h[6][6], hy[6][6];

void abc(int x, int y) {
	for (int i = 0; i < 5; ++i) {//x，y代表灯的位置。
		int a = x + dx[i];
		int b = y + dy[i];
		if (a > 0 || a <= 5 || b > 0 || b <= 5) h[a][b] = h[a][b] ^ 1;//没越界。
	}
}

int main() {
	int n;
	scanf("%d", &n);
	while (n--) {
		for (int z = 0; z < 5; ++z) cin >> h[z];
		for (int z = 0; z < 32; ++z) {
			memcpy(hy, h, sizeof h);//hy->h
			int bs=0;
			for (int x = 0; x < 5; ++x) {
				if (z >> x & 1) {
					bs++;
					abc(0, x);
				}
			}
			for (int x = 0; x < 4; ++x) {
				for (int v = 0; v < 5; ++v) {
					if (h[x][v] == '0') {
						bs++;
						abc(x + 1, v);
					}
				}

			}
			bool ck = 1;
			for (int x = 0; x < 5; ++x) {
				if (h[4][x] == '0') {
					ck = 0;
					break;
				}
			}
			if (ck) ans = min(bs, ans);
			memcpy(h, hy, sizeof hy);
		}
		if (ans > 6) ans = -1;
		cout << ans << endl;
		ans=INT_MAX;
	}

	return 0;
}
```

---

## 作者：Cypher_404 (赞：2)

# 题解：P10449 费解的开关

## 题意分析

- 给你一个 $5 \times 5$ 的 $01$ 矩阵。
- 其中的 $0$ 要通过操作全部改变成 $1$。
- 操作：例如改变（取反） $(x,y)$ 则要改变 $(x-1,y),(x+1,y),(x,y-1),(x,y+1),(x,y)$。
- 求：是否能在 $6$ 步以内达到要求（即整个矩阵都为 $1$）。

## 做法分析

因为矩阵不大，只有 $5 \times 5$，$1\le n\le 500$ 考虑枚举第一行的所有状态。说大白话就是：决定第一行点哪一些。

做到第一步的时间复杂度为：$2^5$。

对于后面的每一行，如果当前位置是 $0$，那么就翻转下一行的当前位置（形式化理解为：当前是 $x,y$，如果是 $1$，就翻转 $x,y+1$）。

即：锁定第一行，持续找 $0$ 进行翻转。

## 正确性证明

锁定第一行后，第一行的状态不受改变，只改变后面的行数，不断地改变下去。

即：只改变下面的行数（上面的行都被改变成 $1$ 了）。

因此，上面的每一行的状态不受下面每一行的状态所影响。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100][100];
int b[100][100];
int T;
int minn=INT_MAX;
void push(int x,int y)//翻转(x,y)
{
	b[x][y]^=1;
	b[x-1][y]^=1;
	b[x+1][y]^=1;
	b[x][y-1]^=1;
	b[x][y+1]^=1;
}
int main()
{
	cin>>T;
	while(T--)
	{
		minn=INT_MAX;//置为最大值
		for(int i=1;i<=5;i++)
		{
			for(int j=1;j<=5;j++)
			{
				char c;
				cin>>c;
				a[i][j]=c-48;//字符转数字
			}
		}
//		putchar(10);
//		for(int i=1;i<=5;i++)
//		{
//			for(int j=1;j<=5;j++)
//			{
//				cout<<a[i][j]<<' ';
//			}
//			putchar(10);
//		}
		for(int l=0;l<(1<<5);l++)//状态压缩
		{
			int sum=0;
			for(int j=1;j<=5;j++)
			{
				for(int k=1;k<=5;k++)
				{
					b[j][k]=a[j][k];
				}
			}
			for(int j=0;j<5;j++)
			{
				if((l>>j)&1)
				{
					sum++;
					push(1,j+1);
				}
			}
			for(int i=1;i<=4;i++)//最后一行可以不用按，因为按了会影响上面的状态
			{
				for(int j=1;j<=5;j++)
				if(b[i][j]==0)
				{
					sum++;
					push(i+1,j);
				}
			}
			for(int i=1;i<=5;i++)
			{
//				cout<<a[5][i]<<' ';
				if(b[5][i]!=1)
				{
					goto fuck;
				}
			}
//			putchar(10);
			minn=min(minn,sum);
			fuck:;
		}
//		cout<<minn<<'\n';
//		continue;
		if(minn>6)//不合法
		{
			cout<<"-1\n";
		}
		else
		cout<<minn<<"\n";
	}
	return 0;
}
/*

*/
```

---

## 作者：Jerrycyx (赞：1)

## 分析

由题意得，开关灯的操作是可逆的，也就是说，在 $6$ 步内可以变成灯全亮的游戏状态都可以通过将一个灯全亮的状态在按 $6$ 步内按成。

简而言之，**一个灯全亮的矩阵，在按 $6$ 步或更少的步数后所能成为的矩阵即是所有的可还原游戏状态，且所按步数为还原的最小步数。**

## 思路

从全亮的状态开始，递归搜索 $6$ 步以内所能达到的全部灯的状态，由于每一个矩阵由 $25$ 个二进制元素组成，所以可以状态压缩为一个在 $[0,33,554,431]$ 范围内的整数，由此可以直接将其存入一个数组内，**用下标表示这个整数（即游戏状态），用数值表示最小步数**。

可行的剪枝：
1. 记录前一个按到的灯坐标，避免多次按同一个位置
2. 如果发现这个状态比已存储的状态所需步数还多，那么其引申出的所有状态也一定比更优状态引申出的状态步数多，此时没有必要继续递归（**更优状态引申出的状态一定更优**）

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

short bt[35000000];
inline int compress(bool b[10][10])	//状态压缩函数，将一个游戏状态压缩为一个整数 
{
	int zip=0;
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			zip=(zip<<1)+b[i][j];
	return zip;
}
void DFS(bool now[10][10],int lx,int ly,int step)	//lx，ly 分别表示前一个按灯的坐标 
{
	int zip=compress(now);
	if(bt[zip]<=step) return;	//剪枝 #2 
	bt[zip]=min(bt[zip],(short)step);
	if(step>=6) return;
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
		{
			if(i==lx&&j==ly) continue;	//剪枝 #1 
			now[i][j]^=1,now[i-1][j]^=1,now[i+1][j]^=1,now[i][j-1]^=1,now[i][j+1]^=1;
			DFS(now,i,j,step+1);
			now[i][j]^=1,now[i-1][j]^=1,now[i+1][j]^=1,now[i][j-1]^=1,now[i][j+1]^=1;
		}
	return;
}

bool haha[10][10];
char st[10];
int main()
{
	memset(bt,0x3f,sizeof(bt));
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			haha[i][j]=true;	//构造灯全亮的状态 
	DFS(haha,-1,-1,0);
	int n; scanf("%d",&n);
	while(n--)
	{
		for(int i=1;i<=5;i++)
		{
			scanf("%s",st);
			for(int j=1;j<=5;j++)
				haha[i][j]=st[j-1]-'0';
		}
		int zip=compress(haha);
		printf("%d\n",bt[zip]==0x3f3f?-1:bt[zip]);	//读取储存的状态 
	}
	return 0;
}
```

---

## 作者：YuzhenQin (赞：1)

使用 `std::bitset` 优化 DFS 爆搜解决。

首先预处理出按下每一个开关后改变的灯的 `bitset`。

然后进行 DFS 搜索，每次选择一个灯按开关，使用 `^`（按位异或）操作改变灯的状态。使用 `bitset::count()` 函数获得亮着的灯的个数，如果返回值为 $25$，就代表所有灯都已经变亮。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

bool a[5][5], b[5][5];
bitset<25> status[25];

bitset<25> compress(bool* arr) {
	bitset<25> res;
	res.reset();
	for(int i = 0; i < 5; i++)
		for(int j = 0; j < 5; j++)
			res[i * 5 + j] = arr[i * 5 + j];
	return res;
}

int dfs(int dep, int lst, bitset<25> bs) {
	if(bs.count() == 25)
		return dep;
	if(dep == 6)
		return -1;
	
	int ans = 7;
	for(int i = lst + 1; i < 25; i++) {
		int tmp = dfs(dep + 1, i, bs ^ status[i]);
		if(tmp != -1)
			ans = min(ans, tmp);
	}
	
	return (ans == 7 ? -1 : ans);
}

int main(void) {
	ios::sync_with_stdio(false);
	cin.tie(/* nullptr */ 0);
	cout.tie(/* nullptr */ 0);
	
	int n;
	cin >> n;
	
	for(int i = 0; i < 5; i++)
		for(int j = 0; j < 5; j++) {
			b[i][j] = 1;
			if(i > 0) b[i - 1][j] = 1;
			if(i < 4) b[i + 1][j] = 1;
			if(j > 0) b[i][j - 1] = 1;
			if(j < 4) b[i][j + 1] = 1; 
			status[i * 5 + j] = compress((bool*)b); 
			b[i][j] = 0;
			if(i > 0) b[i - 1][j] = 0;
			if(i < 4) b[i + 1][j] = 0;
			if(j > 0) b[i][j - 1] = 0;
			if(j < 4) b[i][j + 1] = 0; 
		}
	
	while(n--) {
		for(int i = 0; i < 5; i++) {
			string str;
			cin >> str;
			for(int j = 0; j < 5; j++)
				a[i][j] = str[j] - '0';
		}

		cout << dfs(0, -1, compress((bool*)a)) << '\n';
	}
	
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

简单题。

我们可以 $2^n$ 枚举第一行的每个位置是否翻转。

然后注意到，若 $(i,j)$ 没亮，那么为了不影响第 $i$ 行其它的灯，可以在 $(i+1,j)$ 这里按下开关，使得将 $(i,j)$ 亮起。

那么对于第 $i(i>1)$ 行的操作序列为 $i-1$ 行的灯的亮灯状态取反；这样依次操作可以将 $1 \sim n-1$ 行的灯全部打开。

最后判断一下最后一行是否也全部打开即可。

最后时间复杂度为 $O(T \times (2^n \times n^2))$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef long long ll;
typedef double db;
const ll N=5;
mt19937 R(time(0));
inline ll Rand(ll l,ll r){
	if(l==r)
	  return l;
	return R()%(r-l+1)+l;
}
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
inline char get(){
	char c;
	while(1){
		c=getchar();
		if(c=='0'||c=='1')
		  return c;
	}
}
ll T,n=5,ans,sum;
bool a[N][N],b[N][N];
ll dx[]={0,0,0,1,-1},dy[]={0,1,-1,0,0};
void solve(ll x,ll y){
	sum++;
	for(int i=0;i<n;i++){
		ll zx=x+dx[i],zy=y+dy[i];
		if(zx<0||zx>=n||zy<0||zy>=n)
		  continue;
		b[zx][zy]^=1ll;
	}
}
void solve(){
	ans=1e9;
	for(int i=0;i<n;i++)
	  for(int j=0;j<n;j++)
	    a[i][j]=b[i][j]=get()-'0';
	for(int i=0;i<(1ll<<n);i++){
		for(int j=0;j<n;j++)
		  for(int k=0;k<n;k++)
		    b[j][k]=a[j][k];
//		cerr<<i<<'\n';
		sum=0;
		for(int j=0;j<n;j++)
		  if((i>>j)&1ll)
		    solve(0,j);
		for(int j=0;j<(n-1);j++)
		  for(int k=0;k<n;k++)
			if(!b[j][k])
			  solve(j+1,k);
		for(int j=0;j<n;j++){
			if(!b[n-1][j]){
				sum=1e9;
				break;
			}
		}
		if(sum>6)
		  continue;
		ans=min(ans,sum);
	}
	if(ans>6)
	  puts("-1");
	else{
		write(ans);
		putchar('\n');
	}
}
int main(){
	T=read();
	while(T--)
	  solve();
	return 0;
}
```

---

## 作者：forever_nope (赞：1)

注意到当进行一个操作的时候，只会对其上方一行的一个值造成影响。

因此考虑枚举第一行每个位置是否操作，然后顺下去。

即下面的每一行都去判断这个需不需要操作，以保证上一行全部打开。

对于最后一行，我们进行操作完后，没有去保证它的了，因此这一行决定了一个枚举是否可行。

具体细节看代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

char gc() {
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	return c;
}

int a[10][10], b[10][10];

void ps(int i, int j) {
	b[i][j] ^= 1;
	b[i - 1][j] ^= 1, b[i + 1][j] ^= 1;
	b[i][j - 1] ^= 1, b[i][j + 1] ^= 1;
}

int solev() {
	int ans = 7;
	for (int i = 1; i <= 5; ++i)
		for (int j = 1; j <= 5; ++j)
			a[i][j] = gc() - '0';
	for (int e = 0; e < (1 << 5); ++e) {
		for (int i = 1; i <= 5; ++i)
			for (int j = 1; j <= 5; ++j)
				b[i][j] = a[i][j];
		int cnt = 0;
		for (int i = 1; i <= 5; ++i)
			if (e & (1 << i - 1)) ps(1, i), ++cnt;
		for (int i = 2; i <= 5; ++i)
			for (int j = 1; j <= 5; ++j)
				if (!b[i - 1][j]) ps(i, j), ++cnt;
		int ok = 1;
		for (int i = 1; i <= 5; ++i)
			if (!b[5][i]) ok = 0;
		if (ok) ans = min(ans, cnt);
	} return ans > 6 ? -1 : ans;
}

signed main() {
	// ios::sync_with_stdio(false);
	// cin.tie(nullptr), cout.tie(nullptr);
	int T; cin >> T;
	while (T--) cout << solev() << endl;
	return 0;
}
```

时间复杂度：$\mathcal O(T2^nn^2)$。

在这道题里面，$T$ 就是输入的 $n$（数据组数），$n$ 就是方块大小 $5$ 哦。

---

## 作者：qw1234321 (赞：1)

假设第一行固定。

那么满足题目要求的方案只有一种。

不妨枚举第一行的状态，然后递推模拟即可。

code：

```cpp
#include<bits/stdc++.h>
#define rg register
#define int long long
#define il inline
namespace things{
	il int rd(){
		int f = 1, x = 0;
		char ch = getchar();
		while(ch < '0' || ch > '9'){
			if (ch == '-' ) f = -1;
			ch = getchar();
		}
		while(ch >= '0' && ch <= '9'){
			x = x * 10 + ch - '0';
			ch = getchar();
		}
		return x * f;
	}
	il int max(int x, int y){
		return std::max(x, y);
	}
	il int min(int a, int b){
		return std::min(a, b);
	}
	il void wt(int x){
		if (x < 0){
			putchar('-');
			x = -x;
		}
		if (x > 9) wt(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace things;
using namespace std;

int t, n, cnt, ans = LONG_LONG_MAX, a[7][7];
char v[7][7], u[7][7];
int s[7][7];

void diu(int i, int j){
	s[i][j] = !s[i][j];
	s[i - 1][j] = !s[i - 1][j];
	s[i + 1][j] = !s[i + 1][j];
	s[i][j - 1] = !s[i][j - 1];
	s[i][j + 1] = !s[i][j + 1];
	cnt++;
}

void dfs(int x){
	if (x > n){
		for (int i = 1; i <= n; i++){
			if (a[1][i] == 0) diu(1, i);
		}
		for (int i = 2; i <= n; i++){
			for (int j = 1; j <= n; j++){
				if (s[i - 1][j] == 0) diu(i, j);
			}
		}
		for (int i = 1; i <= n; i++){
			for (int j = 1; j <= n; j++){
				if (s[i][j] == 0) cnt = LONG_LONG_MAX;
			}
		}
		for (int i = 1; i <= n; i++){
			for (int j = 1; j <= n; j++){
				s[i][j] = u[i][j];
			}
		}
		ans = min(ans, cnt);
		cnt = 0;
		return ;
	}
	a[1][x] = 0;
	dfs(x + 1);
	a[1][x] = 1;
	dfs(x + 1);
}

signed main(){
	cin >> t;
	while(t--){
		n = 5;
		for (int i = 1; i <= n; i++){
			for (int j = 1; j <= n; j++){
				cin >> v[i][j];
				u[i][j] = s[i][j] = v[i][j] - '0';
			}
		}
		dfs(1);
		if (ans > 6) ans = -1;
		cout << ans << "\n";
		ans = LONG_LONG_MAX;
		for (int i = 1; i <= n; i++) a[1][i] = 0;
	}
	return 0;
}
```

---

## 作者：Z7y0h0_1 (赞：0)

这道题有两种可行的解法：一种是 bfs + 状压优化，另一种是模拟。模拟的时间复杂度较低，若用 $f$ 表示灯矩阵的规模 $(f=5)$，则时间复杂度只有 $O(f^{2}\cdot2^{f}\cdot n)$，不会超时，具体操作如下：

首先用 $O(f^{5})$ 枚举一下第一行按的开关，当确定一个状态时，第一行灯的状态会发生变化。为了弥补这种变化，只能按第 2 行的开关。如第一行为 $10101$，就要按两个 $0$ 下方的开关。这样一来，第 2 行的灯又会发生变化，还需要按第 3 行的开关……当按完第 5 行的开关后，就没有办法再弥补了，这时就可以判断第 5 行是否全开。若是，则统计步数，更新答案。

**Code** 如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m[5][5],m1[5][5],ans[505];
void change(int x,int y){                            //按下x行y列的开关 
	m1[x][y]=1-m1[x][y];
	if(x>0) m1[x-1][y]=1-m1[x-1][y];
	if(x<4) m1[x+1][y]=1-m1[x+1][y];
	if(y>0) m1[x][y-1]=1-m1[x][y-1];
	if(y<4) m1[x][y+1]=1-m1[x][y+1];
}
int solve(){
	int step,res=10;
	vector<int> digits;
	for(int i=0;i<32;i++){                           //枚举第1行 
		step=0;
		memcpy(m1,m,sizeof(m));
		bool bj=true;
		digits.clear();int c=i;
		while(c>0){
			digits.push_back(c%2);
			c/=2;
		}
		int s=digits.size();
		for(int j=0;j<5-s;j++) digits.push_back(0);
		for(int j=0;j<5;j++){
			if(digits[j]){
				change(0,j);step++;                  //按第1行的开关 
			}
		}
		for(int j=0;j<4;j++){                        //弥补上一行的空缺 
			for(int k=0;k<5;k++){
				if(m1[j][k]) continue;
				change(j+1,k);step++;
			}
		}                                            
		for(int j=0;j<5;j++){                        //判断最后一行是否全开 
			if(!m1[4][j]){
				bj=false;break;
			}
		}
		if(bj&&(step<=6)) res=min(res,step);         //更新答案 
	}
	return res==10? -1:res;
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		for(int j=0;j<5;j++){
			for(int k=0;k<5;k++) scanf("%1d",&m[j][k]);
		}
		ans[i]=solve();
	}
	for(int i=0;i<n;i++) cout<<ans[i]<<endl; 
	return 0;
}
```

谢谢观看！

---

## 作者：GeXiaoWei (赞：0)

# P10449 费解的开关
## 解析
题目讲的很清楚，不多说了。通过让我们求步数，可知应该使用搜索或动规，但有步数要求，放心广搜即可。但广搜记录状态，容易内存超限，所以观察灯开关时代表的数字，发现可以用状态压缩，就把代表状态的二维数组的数字强行压成一行，用二进制存储即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
queue<int>q;
short level[1<<26];
int change(int x,int y){ 
    x^=(1<<y);
    if(y>4) x^=(1<<(y-5));
    if(y<20) x^=(1<<(y+5));
    if(y%5) x^=(1<<(y-1));
    if(y%5<4) x^=(1<<(y+1));
    return x;
}
void bfs(){
    memset(level,-1,sizeof(level)),q.push((1<<25)-1),level[(1<<25)-1]=0;
    while(!q.empty()){
        int m=q.front();
        q.pop();
        if(level[m]==6) return ;
        for(int i=0;i<25;i++){
            int y=change(m,i);
            if(level[y]<0) q.push(y),level[y]=level[m]+1;
        }
    }
}
int main(){
	scanf("%d",&t);
	bfs();
	while(t--){
	    int x=0;
        for(int i=0;i<5;i++){
            for(int j=0;j<5;j++){
                scanf("%1d",&n);
                if(n) x=x|(1<<(i*5+j));
            }
        }
        printf("%d\n",level[x]);
	}
	return 0;
}
```

---

## 作者：wzc6666 (赞：0)

看看题解没有状压 dp，我来写一篇。

状态表示显然可得，枚举所有状态可以转化为哪些状态。

答案不超过 $6$，最小次数超过 $6$ 直接跳过即可。

~~但是dp一次会有后效性，我们来两次就可以了。~~

因为这个矩阵大小是固定的，最多次数还为 $6$，多了就 $-1$

所以无法构造一组数据来 hack 掉 dp 两次的程序。

~~如果有？那就三次~~，因为初始化好了，每次询问是 $O(1)$，不用担心 TLE，速度巨快，甚至状态转移解压再压缩，纯暴力啊，都 AC 了。

然后我就 AC 了，就是这么神奇。

附 c++ 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[(1<<25)+10];
int n = (1<<25)-1,m = 5,M = 25;
int T;
int get_h(int x,int y,int i){
	bool s[10][10];
	for(int j = 0;j<M;j++){
		int k = i&1;
		i>>=1;
		s[j/5+1][j%5+1] = k;
	}
	s[x][y] = !s[x][y];
	s[x+1][y] = !s[x+1][y];
	s[x][y+1] = !s[x][y+1];
	s[x-1][y] = !s[x-1][y];
	s[x][y-1] = !s[x][y-1];
	int sum = 0;
	for(int j1 = 1;j1<=m;j1++){
		for(int j2 = 1;j2<=m;j2++){
			sum+=(s[j1][j2]<<((j1-1)*5+j2-1));
		}
	}
	return sum;
}
int main(){
	for(int i = 1;i<=n;i++){
		dp[i] = 0x3f3f3f;
	}
	dp[0] = 0;
	for(int i = 0;i<=n;i++){
		if(dp[i]>=6){
			continue;
		}
		for(int j1 = 1;j1<=m;j1++){
			for(int j2 = 1;j2<=m;j2++){
				int h = get_h(j1,j2,i);
				dp[h] = min(dp[h],dp[i]+1);
			}
		}
	}
	for(int i = 0;i<=n;i++){
		if(dp[i]>=6){
			continue;
		}
		for(int j1 = 1;j1<=m;j1++){
			for(int j2 = 1;j2<=m;j2++){
				int h = get_h(j1,j2,i);
				dp[h] = min(dp[h],dp[i]+1);
			}
		}
	}
	cin>>T;
	while(T--){
		string str;
		int a = 0,cnt = 0;
		for(int i = 1;i<=m;i++){
			cin>>str;
			for(int i = 1;i<=m;i++){
				bool p = str[i-1]-'0';
				p = !p;
				a+=((p)<<(cnt));
				cnt++;
			}
		}
		if(dp[a]<=6){
			cout<<dp[a]<<endl;
		}else{
			puts("-1");
		}
	}
	return 0;
}

```

---


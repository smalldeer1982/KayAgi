# 送礼物

## 题目描述

作为惩罚，GY 被遣送去帮助某神牛给女生送礼物 (GY：貌似是个好差事）但是在 GY 看到礼物之后，他就不这么认为了。某神牛有 $N$ 个礼物，且异常沉重，但是 GY 的力气也异常的大 (-_-b)，他一次可以搬动重量和在 $w$ 以下的任意多个物品。GY 希望一次搬掉尽量重的一些物品，请你告诉他在他的力气范围内一次性能搬动的最大重量是多少。

## 说明/提示

对于所有测试数据，$1 \le N \le 46$, $1 \le W,G[i] \le 2^{31}-1$。

## 样例 #1

### 输入

```
20 5
7
5
4
18
1```

### 输出

```
19```

# 题解

## 作者：Cute__yhb (赞：11)

## 思路

折半搜索。

看数据范围，$2^{46}$ 肯定炸，但 $2 \times 2^{23}$ 炸不了。

整个数组从中间劈成两半，对于每一半，求出礼物能组成的所有重量数，存在两个数组中。

把其中一个数组排序，遍历另一个数组，二分查找在另一个数组中满足条件的最大值。最后求出所有答案的最大值。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
#define re register
#define ri register int
#define rll register long long
#define ld long double
#define endl '\n'
#define fi first
#define se second
#define pii pair<int,int>
#define p_q priority_queue
#define iter iterator
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define nep(i,a,b) for(int i=(a);i>=(b);i--)
#define popcount __builtin_popcount
#define pb push_back
#define mem(a,x) memset((a),x,sizeof(a))
#define eps 1e-8
#define oper operator
#define mk make_pair
vector<ll>a,b;
ll n,g[55],w;
void dfs1(int l,int r,ll sum){
	if(l>r){
		if(sum<=w)a.pb(sum);//能搬动
		return ;
	}
	dfs1(l+1,r,sum+g[l]);
	dfs1(l+1,r,sum);
}
void dfs2(int l,int r,ll sum){
	if(l>r){
		if(sum<=w)b.pb(sum);//能搬动
		return ;
	}
	dfs2(l+1,r,sum+g[l]);
	dfs2(l+1,r,sum);
}
int main(){
	cin>>w>>n;
	for(int i=1;i<=n;i++) cin>>g[i];
	dfs1(1,(1+n)/2,0);//前一半
	dfs2((1+n)/2+1,n,0);//后一半
	ll maxx=0;
	sort(b.begin(),b.end());//排序
	for(int i=0;i<a.size();i++){
		ll sum=a[i];
		int l=0,r=b.size()-1,ans=0;
		while(l<=r){//二分查找满足条件的最大值
			int mid=(l+r)/2;
			if(b[mid]+a[i]<=w){
				l=mid+1;
				ans=mid;
			}else r=mid-1;
		}
		sum+=b[ans];
		maxx=max(maxx,sum);
	}
	cout<<maxx;//输出
    return 0;
}
```

---

## 作者：Melo_qwq (赞：4)

来一发双向搜索加双指针的题解。

# 题目大意

分析一下复杂度。

暴力搜索 $\mathcal{O}(2^n)$ 明显会炸，但是 $\mathcal{O}(2^{\frac{n}{2}+1})$ 不会，所以双向搜索可行。
# 题目实现

劈成两半枚举所有可能的结果，每一半存入一个数组中。

最后从两个数组中分别拿出一个匹配，如果不超过 $W$，那么是一个可能的答案，统计最大值。

但是显然 $\mathcal{O}(n^2)$ 的答案求解不可行，所以考虑食用双指针优化为 $\mathcal {O}(n)$。

我们将两个数组从大到小排序，显然对于第一个数组 $a$，随着下标不断增大，$a_i$ 也不断增大，根据单调性，如果想要两个数的和维持在 $\le W$ 的范围内，第二个数要不断缩小，所以我们可以再设一个指针 $j$ 来倒序枚举第二个数组。
## 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
template < typename T > inline void read (T &x) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	}
	flag ? x = -x : 0 ;
}
const int N = 50 ;
const int M = (1 << 23) + 7 ;
int w ,n ,g[N] ;
int v1[M] ,v2[M] ,tot1 ,tot2 ,mid ;
inline void dfs (int num ,int end ,int sum ,bool flag) {
	if (num == end + 1) {
		if (! flag) {
			v1[++ tot1] = sum ;
			return ;
		}
		v2[++ tot2] = sum ;
		return ;
	}
	dfs (num + 1 ,end ,sum ,flag) ;
	if (sum + g[num] <= w) {
		dfs (num + 1 ,end ,sum + g[num] ,flag) ;
	} // 第 num 个物品可以选或者不选
}
int ans ;
signed main () {
	read (w) ,read (n) ;
	f (i ,1 ,n ,1) {
		read (g[i]) ;
	}
	mid = n >> 1 ;
	dfs (1 ,mid ,0 ,0) ;
	dfs (mid + 1 ,n ,0 ,1) ;
	int j = tot2 ;
	sort (v1 + 1 ,v1 + tot1 + 1) ;
	sort (v2 + 1 ,v2 + tot2 + 1) ;
	f (i ,1 ,tot1 ,1) {
		while (j >= 1 && v2[j] + v1[i] > w) j -- ;
		ans = max (ans ,v2[j] + v1[i]) ;
	}
	cout << ans << '\n' ;
	return 0 ;
}
```

---

## 作者：cyhyeee (赞：2)

## 题解:P10484 送礼物
[题目传送门](https://www.luogu.com.cn/problem/P10484)

分析一下题意可得，这道题是一道搜索。如果用最朴素的做法，一定超时。所以要考虑优化。这里使用**折半搜索**，分别用 $suma$ 和 $sumb$ 两个数组来存储折半的两次 `dfs` 的存储的礼物重量，排序 $sumb$，详见代码。在这里，由于 $suma$ 和 $sumb$ 存的是前一半和后一半，因此，在排完序之后，遍历 $suma$ 用 `upper_bound` 来查找答案，加上 $sumb_i$ 更新 $ans$ 的最大值。

#### code：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define all(x) (x).begin(),(x).end()
#define cmax(x,y) x=max(x,y)
#define cmin(x,y) x=min(x,y)
#define add(x,y) x=(x+y)%mod
#define endl '\n'
#define re register

using namespace std;
const int mod=1e9+7;
const int inf=0x3f3f3f3f;
ll n,k;
int ans,cnta,cntb,N;
int suma[1<<25],sumb[1<<25];
int a[1005];
void dfs(int d,int sum[],ll s){
	if(s>k) return;
	if(d>N){
		sum[++sum[0]]=s;
		return;
	}
	dfs(d+1,sum,s);
	dfs(d+1,sum,s+a[d]);//两种选择，分别是不选当前礼物和选
}
bool cmp(int x,int y) {
	return x>y; 
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>k>>n;
	
	for (int i=1;i<=n;i++) cin>>a[i];	
	sort(a+1,a+n+1,cmp);//从大到小，节省时间
	N=n/2;//更新边界
	dfs(1,suma,0);
	N=n;//同上
	dfs(n/2+1,sumb,0);
	sort(sumb+1,sumb+1+sumb[0]);
	for (int i=1;i<=suma[0];i++) 
      cmax(ans,sumb[upper_bound(sumb+1,sumb+1+sumb[0],k-suma[i])-sumb-1]+suma[i]);
	cout<<ans;
	return 0;
}  
```

---

## 作者：_zuoqingyuan (赞：2)

[一道很经典的搜索题目。](https://www.luogu.com.cn/problem/P10484)

# 题意简述

> 给定 $n$ 个正整数 $G_i$。请选择一种方案，选择其中若干个 $G_i$ 使得他们的和不超过给定的 $W$。
>
> $1\le n\le 46,1\le W,G_i< 2^{31}$。

# 思路分析

对于这道题，我们可以使用搜索算法。

如果是普通的搜索，我们枚举每一个数选或不选，然后取最大的合法方案，这样的时间复杂度为 $O(2^n)$，此题中 $n\le 46$，显然无法通过。

我们可以进行简单的优化，依照上面的原始算法，我们跑两趟 DFS，第一次 DFS 求出 $1\sim \lfloor\frac{n}{2}\rfloor$ 内所有方案，第 $i$ 种方案的和记为 $A_i$，第二次 DFS 求出 $\lfloor\frac{n}{2}\rfloor+1\sim n$ 内所有方案，第 $j$ 种方案的和记为 $B_j$。

对于每个 $A_i$，我们找到最大的 $B_j$ 使得 $A_i+b_j\le W$，并用 $A_i+B_j$ 更新答案。显然，最大的 $B_j$ 必然不超过 $W-A_i$，用二分查找求值即可。

两次 DFS 的时间复杂度为 $O(2^{\lfloor\frac{n}{2}\rfloor})$。更新答案的时间复杂度为 $O\left(2^{\lfloor\frac{n}{2}\rfloor}n\right)$，可以通过本题。

这种做法的实质是将一次搜索划分为了两次搜索，因为搜索的搜索量随搜索树的数高而指数级增加，这样进行折半搜索，降低了搜索树的树高。这种经典的搜索方法成为“双向搜索”。建议完成本题后去了解[字串变换](https://www.luogu.com.cn/problem/P1032)这道题。

# Code

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
const int N=(1<<25);
typedef long long ll;
ll a[N],g[47],n,w,cnt,ans,m,p;
ll r(){
    ll x=0;char ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x;
}
bool cmp(int a,int b){
    return a<b;
}
bool cmp2(int a,int b){
    return a>b;
}
ll found(int x){
    ll l=1,r=m,mid,ans=0;
    while(l<r){
        mid=(l+r+1)/2;
        if(a[mid]>x)r=mid-1;
        else if(a[mid]<x)l=mid,ans=a[mid];
        else if(a[mid]==x)return x;
    }
    return ans;
}
void dfs1(ll idx,ll sum){
    if(idx>p){
        a[++cnt]=sum;
        return;
    }
    dfs1(idx+1,sum);
    if(sum+g[idx]<=w)dfs1(idx+1,sum+g[idx]);
    return;
}
void dfs2(ll idx,ll sum){
    if(idx>n){
        ans=max(ans,sum+found(w-sum));
        return;
    }
    dfs2(idx+1,sum);
    if(sum+g[idx]<=w)dfs2(idx+1,sum+g[idx]);
}
int main(){
    w=r(),n=r();
    for(int i=1;i<=n;i++)g[i]=r();
    sort(g+1,g+1+n,cmp2);
    p=n/2+2;
    dfs1(1,0);
    sort(a+1,a+1+cnt,cmp);
    m=unique(a+1,a+1+cnt)-(a+1);
    dfs2(p+1,0);
    printf("%lld",ans);
    return 0;
}
```

如有错误，请指出。

---

## 作者：UnfortunatelyDead (赞：2)

由于 $1 \leq n \leq 46$，这个数据范围直接爆搜显然是不现实的，但是我们可以折半搜索。

具体地，我们将 $n$ 分为 $[1,\lfloor\frac{n}{2}\rfloor]$ 和 $[\lfloor\frac{n}{2}\rfloor+1,n]$ 来分别进行爆搜，前一半我们记录每个答案，而后一半我们尝试和前一半的答案拼接使得当前方案所容纳体积最大。

递归或者二进制枚举皆可，但是二进制枚举复杂度多带个 $n$，复杂度 $O(2^{\frac{n}{2}})$。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[466];
int n, w, ans;
const int N = (1 << 23) + 100;
int s[N], len;
int main() {
	scanf("%d%d", &w, &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &a[i]);
	}
	int _ = n / 2, e = n - n / 2;
	for (int i = 1; i < (1 << _); ++i) {
		long long choose = 0;
		for (int j = 0; j < _; ++j) {
			if (i & (1 << j)) choose += a[j + 1];
		}
		if (choose <= w) s[++len] = choose;
	} sort(s + 1, s + 1 + len);
	for (int i = 0; i < (1 << e); ++i) {
		long long choose = 0;
		for (int j = 0; j < e; ++j) {
			if (i & (1 << j)) choose += a[j + _ + 1];
		}
		if (choose > w) continue;
		int qwq = w - choose, gt;
		int pls = upper_bound(s + 1, s + 1 + len, qwq) - s;
		gt = s[pls - 1];
		ans = max(ans, (int)choose + gt);
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：qinmingze (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10484)

### 思路

本题考察的算法是搜索。但是很明显，如果直接进行搜索会超时，因此我们需要用**折半搜索的思想**来解决，这样就可以让时间复杂度大大地降低。具体地步骤如下：

- 我们首先把 $n$ 个数拆成两个部分，分别为前半部分和后半部分，之后我们可以采取**二进制枚举**的方法进行处理。

- 在处理前半部分时，我们需要统计当前部分中物体重量和的**所有情况**。

- 在处理后半部分时，我们需要找到**当前物体重量和和前半部分中物体重量和的和在符合范围内的最大值**。同时如果**当前的最大值与范围内的最大值相等**，那么可以直接输出，并结束程序。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<bitset>
#include<algorithm>

using namespace std;

const int N = 47, M = 9e6 + 10;

bitset<47> bs;

long long a[N];

long long b[M];

int c = 0; 

int main(){
	int n;
	long long m;
	scanf("%lld%d", &m, &n);
	for(int i = 1; i <= n; i++)scanf("%lld", a + i);
	//sort(a + 1, a + n + 1, greater<int>() );
	if(n <= 23){//直接处理即可。
		long long ans = 0;
		for(int i = 0; i <= (1 << n) - 1; i++){
			bs = i;
			long long sum = 0;
			for(int j = 0; j < n; j++){
				if(bs[j])sum += a[j + 1];
			}
			if(sum <= m) ans = max(ans, sum);
		}
		printf("%lld\n", ans);
	}else {
		long long ans = 0;
		int cnt = 0;
		int pp = n / 2;//分成两个部分。
		for(int i = 0; i <= (1 << pp) - 1; i++){//前半部分。
			bs = i;
			long long sum = 0;
			for(int j = 0; j < pp; j++){
				if(bs[j])sum += a[j + 1];c++;
				if(sum > m)break;//超出范围。
			}
			if(sum <= m)b[++cnt] = sum;//统计物体重量和的所有情况。
		}
		sort(b + 1, b + cnt + 1);//排序。
		cnt = unique(b + 1, b + cnt + 1) - b - 1;//去重。
		if(b[n] == m){//与范围内的最大值相等。
			cout << m;
			return 0;
		}
		for(int i = 0; i <= (1 << (n - pp)) - 1; i++){//后半部分。
			bs = i;
			long long sum = 0;
			for(int j = 0; j < (n - pp); j++){
				if(bs[j])sum += a[j + pp + 1];c++;
				if(sum > m)break;
			}
			if(sum <= m){
				int l = 1, r = cnt, p = 0; 
				while(l <= r){//找到前半部分中物体重量和的最大值。
					int mid = l + r >> 1;
					if(sum + b[mid] <= m){//在题目要求的范围内。
						l = mid + 1; p = mid;
					}else r = mid - 1;
				}
				ans = max(ans, b[p] + sum);
			}
			if(ans == m) break;
		}
		cout << ans << "\n";
	}
	return 0;
}
```

---

## 作者：fzitb7912 (赞：1)

## 分析

考虑折半搜索。

对于前一半礼物，暴力搜索其能够凑出来的重量，复杂度 $O(2^{\frac{n}{2}})$。

将这些重量存下来，然后暴力搜索后一半礼物能够凑出来的重量。若有重量 $x$，则在前面一半礼物凑出来的重量中找到一个 $y$，使 $x+y \le w$ 且 $y$ 最大。二分就行了。复杂度 $O(2^{\frac{n}{2}}\log 2^{\frac{n}{2}})$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define pii pair<int,int>
#define x first
#define y second
#define gc getchar()
#define rd read()
#define debug() puts("------------")

namespace yzqwq{
	il int read(){
		int x=0,f=1;char ch=gc;
		while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=gc;}
		while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=gc;
		return x*f;
	}
	il int qmi(int a,int b,int p){
		int ans=1;
		while(b){
			if(b&1) ans=ans*a%p;
			a=a*a%p,b>>=1;
		}
		return ans;
	}
	il auto max(auto a,auto b){return (a>b?a:b);}
	il auto min(auto a,auto b){return (a<b?a:b);}
	il int gcd(int a,int b){
		if(!b) return a;
		return gcd(b,a%b);
	}
	il int lcm(int a,int b){
		return a/gcd(a,b)*b;
	}
	il void exgcd(int a,int b,int &x,int &y){
		if(!b) return x=1,y=0,void(0);
		exgcd(b,a%b,x,y);
		int t=x;
		x=y,y=t-a/b*x;
		return ;
	}
	mt19937 rnd(time(0));
}
using namespace yzqwq;

const int N=50,M=9e6;
int w,n;
int g[N],g_[M],m;
int Max;

il void dfs1(int now,int g_sum){
	if(g_sum>w) return ;
	if(now>n/2) return g_[++m]=g_sum,void(0);
	dfs1(now+1,g_sum),dfs1(now+1,g_sum+g[now]); 
	return ;
}
il void dfs2(int now,int g_sum){
	if(g_sum>w) return ;
	if(now>n){
		int l=1,r=m,x=-1;
		while(l<=r){
			int mid=l+r>>1;
			if(g_[mid]+g_sum<=w) x=mid,l=mid+1;
			else r=mid-1;
		}
		if(~x) Max=max(Max,g_[x]+g_sum);
		return ;
	}
	dfs2(now+1,g_sum),dfs2(now+1,g_sum+g[now]);
	return ; 
}

il void solve(){
	w=rd,n=rd;
	for(re int i=1;i<=n;++i) g[i]=rd;
	sort(g+1,g+n+1),reverse(g+1,g+n+1);
	dfs1(1,0);
	sort(g_+1,g_+m+1);
	dfs2(n/2+1,0);
	printf("%lld\n",Max);
	return ;
}

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int t=1;while(t--)
	solve();
	return 0;
}

```

---

## 作者：ttq012 (赞：1)

看到 $n\le 46$，则 $\frac{n}{2}\le 23$。考虑折半。

先计算出前一半所有 $\le w$ 的可以凑出的答案，然后枚举后一半所有可以凑出的答案，在前一半中可以凑出的答案中二分枚举一下答案即可。

时间复杂度为 $O(2^\frac{n}{2}\log 2^\frac{n}{2})$，卡常之后能过。

[代码](https://www.luogu.com.cn/paste/kd2vt457)。

---


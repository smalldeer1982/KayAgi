# 数字生成游戏

## 题目描述

小明完成了这样一个数字生成游戏，对于一个不包含 $0$ 的数字 $s$ 来说，有以下 $3$ 种生成新的数的规则：

1.    将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成 $314,413,134$；

2.    将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$；

3.    在 $s$ 的相邻两位之间 $s_i,s_{i + 1}$ 之间插入一个数字 $x$，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$，但是不能生成 $1143,1543$ 等。

现在小明想知道，在这个生成法则下，从 $s$ 开始，每次生成一个数，可以用然后用新生成的数生成另外一个数，不断生成直到生成 $t$ 至少需要多少次生成操作。

另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$，那么可以将 $s$ 删除变为 $143$，再生成 $1243$ 或 $1343$。

## 说明/提示

**样例解释**

$143\to 134$

$133$ 无法得到

$143\to13\to123\to23\to32$

**数据范围**

对于 $20\%$ 的数据，$s < 100$；  
对于 $40\%$ 的数据，$s < 1000$；  
对于 $40\%$ 的数据，$m < 10$；  
对于 $60\%$ 的数据，$s < 10000$；  
对于 $100\%$ 的数据，$s < 100000,m ≤ 50000$。

## 样例 #1

### 输入

```
143
3
134
133
32
```

### 输出

```
1
-1
4
```

# 题解

## 作者：Just_do_it (赞：24)

这道题的s最大只有99999，因为操作3的限制，之后生成的数位数不能超过原数的位数，所以我们可以从可以生成的数字入手，最多只用枚举99999\*100（这是对每一个数所进行操作的估计，但实际上远远达不到）次。我们就可以使用bfs来搜索

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long
#define N 100005
#define M 10
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

struct node{
    int a,ans;
};
bool flag[N];            //存的是该数字能否生成 
int f[N];                //存的是生成该数字最小操作次数 
queue<node> q;
int n;
int s[10],len;

void bfs(){                            //bfs求所有可以得到得可能性 
    while(!q.empty()){
        node a = q.front(); q.pop();
        int b;
        len = 0;
        while(a.a){                    //将数字转化为数组 
            s[++len] = a.a%10;
            a.a /= 10;
        }
        if(len == 1) continue;        //当len等于1的时候不能再进行任何一项操作了 
        //删除一位数的操作 
        for(int i = 1;i <= len;i++){        //这是枚举删除哪一位数 
            b = 0;
            for(int j = len;j >= 1;j--)        //数组还原成数字，下面同样 
                if(j != i)
                    b = b*10+s[j];
            if(flag[b]) continue;            //判断是否存在过，没有的话就插入 
            flag[b] = true;
            f[b] = a.ans+1;
            node p;
            p.a = b; p.ans = a.ans+1;
            q.push(p);
        }
        //交换两位数的操作 
        for(int i = 1;i <= len;i++)
            for(int j = i+1;j <= len;j++){        //i和j是在枚举交换哪两位数字 
                b = 0;
                swap(s[i],s[j]);
                for(int k = len;k >= 1;k--)
                    b = b*10+s[k];
                swap(s[i],s[j]);
                if(flag[b]) continue;
                flag[b] = true;
                f[b] = a.ans+1;
                node p;
                p.a = b; p.ans = a.ans+1;
                q.push(p);
            }
        //添加一位数的操作 
        if(len == n) continue;            //不能超过原序列的长度  
        for(int i = 1;i < len;i++){        //枚举在哪两位中间添加 
            for(int j = s[i]-1;j > s[i+1];j--){        //枚举添加的数字 
                b = 0;
                for(int k = len;k > i;k--)
                    b = b*10+s[k];
                b = b*10+j;
                for(int k = i;k >= 1;k--)
                    b = b*10+s[k];
                if(flag[b]) continue;
                flag[b] = true;
                f[b] = a.ans+1;
                node p;
                p.a = b; p.ans = a.ans+1;
                q.push(p);
            }
        }
    }
}

int main(){
    int a = read();
    flag[a] = true;
    node p; p.a = a; p.ans = 0;
    q.push(p);
    while(a){
        s[++len] = a%10;
        a /= 10;
    }
    n = len;
    bfs();
    int m = read();
    for(int i = 1;i <= m;i++){
        int a = read();
        if(!flag[a]) printf("-1\n");
        else printf("%d\n",f[a]);
    }
    return 0;
}
```

---

## 作者：Alarm5854 (赞：10)

这道题目是一道宽搜裸题，对于每一个数字，把所有能变成的数字都加进队列里面，这样就可以把一个数能变的数字全部找出来，不能变的数字则永远都不会遍历到。注意一下细节：长度为 $l$ 的数字不能插入（$l$ 为初始数字的位数），长度为 $1$ 的数字不能删除，交换数字是任意两位都可以交换的。注意这些细节之后就简单了。

这里介绍一些 `C++` 里面字符串的用法，`atoi` 函数是将一个 `char*` 类型的字符串转换为 `int` 类型；`stoi` 函数是将一个 `string` 类型的字符串转换为 `int` 类型，`to_string` 函数是将一个数值转换为 `string` 类型。有了这些函数，代码难度将大大降低，毕竟，这样就不需要手写将字符串转为数字，也不需要手写将数子转为字符串了。代码长度是所有通过的人里面次短的（去掉多余空格将不到 1K）。

```cpp
#include<queue>
#include<cstdio>
#include<string>
#include<cstring>
using namespace std;
const int N = 1e5 + 10;
string s; char str[7];
int m, l, x, d[N];
void bfs(int s) {
	memset(d, -1, sizeof(d)), d[s] = 0;
	queue<int> q; q.push(s); int k;
	while (!q.empty()) {
		int x = q.front(); q.pop();
		string t = to_string(x);
		int len = t.length();
		for (int i = 0; i < len; ++i)
		for (int j = i + 1; j < len; ++j) {
			string u = t; swap(u[i], u[j]);
			if (!~d[k = stoi(u)]) d[k] = d[x] + 1, q.push(k);
		}
		for (int i = 0; i < len && len > 1; ++i) {
			string u = t; u.erase(i, 1);
			if (!~d[k = stoi(u)]) d[k] = d[x] + 1, q.push(k);
		}
		if (len == l) continue;
		for (int i = 1; i < len; ++i)
		for (char c = t[i - 1] + 1; c < t[i]; ++c) {
			string u = t; u.insert(i, 1, c);
			if (!~d[k = stoi(u)]) d[k] = d[x] + 1, q.push(k);
		}
	}
}
int main() {
	scanf("%s%d", str, &m), s = str, l = s.length(), bfs(atoi(str));
	for (int i = 1; i <= m; ++i) scanf("%d", &x), printf("%d\n", d[x]);
	return 0;
}
```

顺便说一下，这道题目还是我通过的第 1000 道题目。



---

## 作者：早右昕 (赞：9)

###宽搜 with 一些技巧

- 由于查询量很大，所以要预先处理所有答案

- 预处理当然是用```BFS```，并同时进行```delete```,```swap```,```add```操作。注意，不能在x为队首元素时才更新答案，这样会使效率大打折扣（不更新的话,```dist[x]```任为-1，相当于少了判重）
- 对于以上三种操作也有要求，一下进行一些优化（炒鸡模拟应该也能过，因为```swap()```,嗯嗯）:
- 法一：见一楼的题解，不过有局限性

- 法二：针对```add()```,和```delete()```,可以然枚举的[状态有序化](http://www.cnblogs.com/InfoEoR/p/7896862.html)以达到优化效果，适用范围更广泛；
- 以下为我的代码，其中结构体部分可以省去，```u.step```可以直接用```dist[x]```代替。

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
main() {}
int dist[10000000];
struct in{int x,s;}u;
std::queue<in>que;
void tie(int \*a,int &lth,int x) {
    lth=0;//解码 
    while(x) a[lth++]=x%10,x/=10;
}
int dis(int \*a,int lth) {
    int x=0;//还原 
    while(lth) x\*=10,x+=a[--lth];
    return x;
}
void add(int \*a,int lth,int step) {
    int tmp;//o(n)的add操作 
    a[lth]=a[lth-1];
    for(int i=lth-1;i>=1;i--) {
        for(int j=a[i+1]+1;j<a[i-1];j++) {
            a[i]=j;
            tmp=dis(a,lth+1);
            if(dist[tmp]==-1) dist[tmp]=step,que.push((in){tmp,step});
        }
        a[i]=a[i-1];
    }
}
void del(int \*a,int lth,int step) {
    int tmp,out=0;//o(n)的delete操作 
    for(int i=lth-1;i>=0;i--) {
        out^=a[i]^=out^=a[i];
        tmp=dis(a,lth-1);
        if(dist[tmp]==-1) dist[tmp]=step,que.push((in){tmp,step});
    }
}
void swa(int \*a,int lth,int step) {
    int tmp;//o(n\*(n-1)/2)的swap操作 
    for(int i=0;i<lth;i++) {
        for(int j=i+1;j<lth;j++) {
            if(a[i]==a[j]) continue;
            a[i]^=a[j]^=a[i]^=a[j];
            tmp=dis(a,lth);
            if(dist[tmp]==-1) dist[tmp]=step,que.push((in){tmp,step});
            a[i]^=a[j]^=a[i]^=a[j];
        }
    }
}
int entry() {
    memset(dist,-1,sizeof dist);
    int a[10],lth,lmt,x;
    scanf("%d",&x);
    tie(a,lmt,x),dist[x]=0;
    que.push((in){x,0});
    while(!que.empty()) {
        u=que.front();
        que.pop();
        memset(a,0,sizeof a);
        tie(a,lth,u.x);
        if(lth>1) del(a,lth,u.s+1),tie(a,lth,u.x);
        if(lth>1) swa(a,lth,u.s+1),tie(a,lth,u.x);
        if(lth<lmt) add(a,lth,u.s+1);
    }
    scanf("%d",&lmt);
    while(lmt--) {
        scanf("%d",&x);
        printf("%d\n",dist[x]);
    }
    return 0;
}
int aptal=entry();

```

望采纳。


---

## 作者：Eraine (赞：8)

# 1 题目大意

**题目难度** $\color{blue}{提高}$

**题目标签** 搜索

[原OJ题面](https://www.luogu.com.cn/problem/P1132)

## 1.1 题目简介

现在给你一个初始数字，要求你用以下三种变换生成不同的数字：

1.将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成$314,413,134$ ；

2.将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$ ；

3.在 $s$ 的相邻两位之间 $s_i$ , $s_{i + 1}$之间插入一个数字 $x$ ，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$ 但是不能生成 $1143,1543$ 等。

另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$ ，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$ ，那么可以将 $s$ 删除变为 $143$ ，再生成 $1243$ 或 $1343$ 。

接下来，再给你 $m$ 个数字，问你这些数可不可用 $s$ 变化出。如果可以，输出**最短**的步数，不可以就输出 $-1$ 。

# 1.2 思路分析

首先我们看到这道题的标签是搜索 ~~（妥妥的标签党）~~  ，就已经定下只能用 $DFS$ 或者 $BFS$ 来解决。再看一眼数据范围：$$m\le50000，s<100000$，就限制了 $DFS$ 。显而易见，会超时。可有同学就会问了：

那广搜爆空间怎么办？如果当生成数变得很大怎么办？我之前也想过这个问题，可是当我看到原题中的这句话 **生成数的位数不能超过初始数 $s$ 的位数** 。也就是说，生成数再大，它的位数也不能超过 $s$ 的位数。$s<100000$，也就意味着生成数也不能 **大于等于**  $100000$ 。标记数组只需要开比 $100000$ 大一点就好了（好习惯，以防数组越界）。

# 2 代码讲解

# 2.1 $BFS$

先来一波 $BFS$ 的基本操作吧（模板）：

```cpp
int judge[100005];//标记数组
struct node{
	int data;//数
	int step;//最小路径
};
queue<node>true_queue;//定义一个队列
void search_bfs(){//广度搜索优先
	true_queue.push(node{s,0});//把s存进队列
	judge[s]=0;//s的最短路径为0
	while(!true_queue.empty()){
		node node_now=true_queue.front();//储存当前出队列的数
		true_queue.pop();//当前数出队列
		//操作1：对换
		//操作2：删除
		//操作3：生成
	}
}
```

## 2.2 操作

**操作准备**

我们先看一下原题目中的三个操作，知道如果用一个普通的数来做操作是很麻烦的。于是，我们就想到了 **数组** 。用数组来寄存操作数更方便。

```cpp
int bs=1,shu[10]={0},front=0;
int now=node_now.data;
while(now){//把操作数中的每一位数都存进数组（类似高精）
	shu[++front]=now%10;
	now/=10;
}
if(node_now.data==s)maxx=front;//储存所有操作的最高位数
```

**操作 $1$**

操作 $1$ 是对换数，记住题目中没讲相邻两位对换，所以我们可以将数组中任意不同的两位数字进行对换。

```cpp
for(int i=1;i<=front;i++){
	for(int k=1;k<=front;k++){
		int lin_shu[10]={0};
		for(int j=1;j<=front;j++)lin_shu[j]=shu[j];//把shu的每一位数复制到lin_shu里
		swap(lin_shu[i],lin_shu[k]);//两位进行交换
		int sum=0;
		for(int j=front;j>0;j--){//计算和
			sum*=10;
			sum+=lin_shu[j];
		}
		if(judge[sum]==0x3f3f3f3f){//当这个数没被标记过时
			true_queue.push(node{sum,node_now.step+1});//入队
			judge[sum]=node_now.step+1;//步数+1
		}
	}
}
```

**操作 $2$**

操作 $2$ 就是把原数删掉一位，记住当删后的操作数 $==0$ 时，不要入队。

```cpp
for(int i=1;i<=front;i++){
	int x=i;
	int sum=0;
	for(int j=front;j>0;j--){//求和
		if(j==x)continue;//删掉的那一位
		sum*=10;
		sum+=shu[j];
	}
	if(sum!=0&&judge[sum]==0x3f3f3f3f){//如果没被标记过且不等于0就入队
		true_queue.push(node{sum,node_now.step+1});
		judge[sum]=node_now.step+1;
	}	}
```

**操作 $3$**

操作 $3$ 略微会麻烦一点，它是插入一个数，且左边的那一位比它**小**，右边的比它**大**。那就是找到相邻的两位，两个之差**大于等于** $2$ 且左边的数比右边的数小。还需要判断这个数的位数不超过 $s$ 的位数。

```cpp
if(front>=maxx)continue;//超过s的位数
for(int i=1;i<front;i++){
	int x=i;
	int sum[10]={0},front_lin=0;
	if(shu[i]>=shu[i+1]+2){//当相邻两位允许插入时
		for(int k=shu[i+1]+1;k<shu[i];k++){//计算和
			for(int j=front;j>0;j--){
				if(j==x){
					sum[k]*=10;
					sum[k]+=k;
				}
				sum[k]*=10;
				sum[k]+=shu[j];
			}
		}
		for(int j=shu[i+1]+1;j<shu[i];j++){//入队
			if(sum[j]<=100000&&judge[sum[j]]==0x3f3f3f3f){
				true_queue.push(node{sum[j],node_now.step+1});
				judge[sum[j]]=node_now.step+1;//标记
			}
		}
	}
}
```

# 3 AC代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
int s,n,maxx;
int judge[100005];
struct node{
	int data;
	int step;
};
queue<node>true_queue;
void search_bfs(){
	true_queue.push(node{s,0});
	judge[s]=0;
	while(!true_queue.empty()){
		node node_now=true_queue.front();
		true_queue.pop();
		int bs=1,shu[10]={0},front=0;
		int now=node_now.data;
		while(now){
			shu[++front]=now%10;
			now/=10;
		}
		if(node_now.data==s)maxx=front;
		//操作1：对换
		for(int i=1;i<=front;i++){
			for(int k=1;k<=front;k++){
				int lin_shu[10]={0};
				for(int j=1;j<=front;j++)lin_shu[j]=shu[j];
				swap(lin_shu[i],lin_shu[k]);
				int sum=0;
				for(int j=front;j>0;j--){
					sum*=10;
					sum+=lin_shu[j];
				}
				if(judge[sum]==0x3f3f3f3f){
					true_queue.push(node{sum,node_now.step+1});
					judge[sum]=node_now.step+1;
				}
			}
		}
		//操作2：删除
		for(int i=1;i<=front;i++){
			int x=i;
			int sum=0;
			for(int j=front;j>0;j--){
				if(j==x)continue;
				sum*=10;
				sum+=shu[j];
			}
			if(sum!=0&&judge[sum]==0x3f3f3f3f){
				true_queue.push(node{sum,node_now.step+1});
				judge[sum]=node_now.step+1;
			}
		}
		//操作3：生成
		if(front>=maxx)continue;
		for(int i=1;i<front;i++){
			int x=i;
			int sum[10]={0},front_lin=0;
			if(shu[i]>=shu[i+1]+2){
				for(int k=shu[i+1]+1;k<shu[i];k++){
					for(int j=front;j>0;j--){
						if(j==x){
							sum[k]*=10;
							sum[k]+=k;
						}
						sum[k]*=10;
						sum[k]+=shu[j];
					}
				}
				for(int j=shu[i+1]+1;j<shu[i];j++){
					if(sum[j]<=100000&&judge[sum[j]]==0x3f3f3f3f){
						true_queue.push(node{sum[j],node_now.step+1});
						judge[sum[j]]=node_now.step+1;
					}
				}
			}
		}
	}
}
int main(){
	memset(judge,0x3f,sizeof(judge));
	scanf("%d%d",&s,&n);
	search_bfs();
	for(int i=1;i<=n;i++){
		int t;
		scanf("%d",&t);
		if(judge[t]==0x3f3f3f3f)printf("-1\n");
		else printf("%d\n",judge[t]);
	}
	return 0;
}
```


---

## 作者：破忆 (赞：5)

### 【题目大意】
给定一个初始数字

有一些变换方式

求由原数到最终结果的最小步数

### 【分析】
把数字抽象成节点

题意就是求起点到终点的最短路

由于每一步代价都是1

直接BFS即可

变化的时候，可以分别枚举数位，利用%与/运算取得每一位的数字，再改变原数

### 【解法】
BFS

### 【代码】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int s,m,que[maxn],ans[maxn],INF,len,hed,til;
int mi[10]={1,10,100,1000,10000,100000,1000000,10000000};//先打数位表
bool vis[maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void work1(int x){ //交换操作
	int l=log10(x)+1;
	for(int i=1;i<l;i++)
	for(int j=i+1;j<=l;j++){
		int a=x/mi[i-1]%10,b=x/mi[j-1]%10; //取出第i位和第j位的数字
		int y=x-a*mi[i-1]-b*mi[j-1]+b*mi[i-1]+a*mi[j-1];//在原数上加减，相当于交换
		if(vis[y]) continue;
		vis[y]=1;
		ans[y]=ans[x]+1;
		que[++til]=y;
	}
}
void work2(int x){//删除操作
	int l=log10(x)+1;
	for(int i=1;i<=l;i++){
		int a=x%mi[i-1];//取出后面几位
		int y=x/mi[i]*mi[i-1]+a;//把原数去掉后面几位再接上之前取出的数字，相当于删数
		if(vis[y]) continue;
		vis[y]=1;
		ans[y]=ans[x]+1;
		que[++til]=y;
	}
}
void work3(int x){//添加操作
	int l=log10(x)+1;
	if(l==len) return;
	for(int i=1;i<l;i++){
		int a=x/mi[i]%10,b=x/mi[i-1]%10;//单独取出相邻两位
		for(int j=a+1;j<b;j++){
			int c=x%mi[i];
			int y=(x-c)*10+j*mi[i]+c;//把原数中间断开后加上需要添加的数字
			if(vis[y]) continue;
			vis[y]=1;
			ans[y]=ans[x]+1;
			que[++til]=y;
		}
	}
}
void BFS(){
	hed=0,til=1;
	memset(ans,63,sizeof ans);
	INF=ans[0];
	ans[s]=0,vis[s]=1,que[1]=s;
	while(hed!=til){
		int x=que[++hed];
		work1(x);
		work2(x);
		work3(x);
	}
}
int main(){
	freopen("P1132.in","r",stdin);
	freopen("P1132.out","w",stdout);
	s=read(),m=read();
	len=log10(s)+1;
	BFS();
	for(int i=1;i<=m;i++){
		int x=read();
		printf("%d\n",ans[x]==INF?-1:ans[x]);
	}
	return 0;
}
```


---

## 作者：清尘 (赞：4)

[在我的博客查看](https://www.cnblogs.com/whx666/p/11333597.html)

暴力bfs，用字符串来模拟这三种操作

用字符串的优点：代码易想，简单易懂，降低思考复杂度，删除/插入操作直接截取字符串再相加就完事了(.substr函数)

缺点：相对直接用数字操作更慢（可能只有我的慢）

交换操作：最简单的操作，直接交换字符串中的两个字符，然后对应到数字，判断是否要加入队列

删除操作：枚举删除位置，截取左右两段字符串相加得出新的字符串

插入操作：枚举插入位置（不能在两头），然后截取左右两段字符串，中间再加一个字符

每次记录答案时需要先将字符串转换为数字 (方法与快读的一样)

### 注意
x.substr(l, x) 从位置（下标） l 开始取 x 个字符（一开始不知道查了半天样例都没过qwq）


### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string str, s, v = "0123456789";
int m, st[1000000], inf;
inline int get (string x) {    // get函数将字符串转换为数字 
    int s(0);
    for (int i = 0; i < x.size(); i++)  s = s * 10 + x[i] - 48;
    return s;
}
void Go () {
    queue <pair<string, int> > q;  
    q.push ({str, 0});
    while (q.size()) {
        pair<string, int> t = q.front();  q.pop();
        string stra = t.first;
        int len = stra.size();
        if (len == 1)  continue;    //长度为 1 时不能执行任何操作 
        // 处理交换操作 
        for (int i = 0; i < len; i++)
          for (int j = i + 1; j < len; j++)  {
            string strb(stra);
            swap (strb[i], strb[j]);
            int tmp = get (strb);
            if (st[tmp] > t.second + 1)  
              st[tmp] = t.second + 1, q.push({strb, t.second + 1});
          }
        // 处理删除操作
        for (int i = 0; i < len; i++) {
            string strb = stra.substr (0, i) + stra.substr (i + 1, len - i);
            int tmp = get (strb);
            if (st[tmp] > t.second + 1)  
              st[tmp] = t.second + 1, q.push({strb, t.second + 1}); 
        } 
        // 处理插入操作
        if (len >= str.size())  continue;   // 生成数字不能超出原数字位数
        for (int i = 1; i < len; i++) 
          for (int j = stra[i-1] - 47; j < stra[i] - 48; j++) {
            string strb = stra.substr (0, i) + v[j] + stra.substr (i, len - i);
            int tmp = get (strb);
            if (st[tmp] > t.second + 1)  
              st[tmp] = t.second + 1, q.push({strb, t.second + 1});     
          }
    }
}
int main() {
    cin >> str;
    memset (st, 0x7f, sizeof (st));  inf = st[0];
    st[get(str)] = 0;
    Go ();    
    scanf ("%d", &m);
    while (m--)  
      cin >> s, printf ("%d\n", (st[get(s)] == inf) ? -1 : st[get(s)]);
    return 0;
} 
```　

---

## 作者：冰糖鸽子 (赞：3)

一道不错的字符串+宽搜练手题

----

### 思路

首先显而易见的是，关于一个数字能到达的数字的最大长度，咱们分别看三个操作：

- 操作1，位数不变
- 操作2，位数减少
- 操作3，位数加一，但不会超过初始数字的长度

所以可以得出结论：不管怎么变化，数字的长度都不会超过原数字的长度，也就是**最大只能搜索到 99999** , 所以毫不犹豫用宽搜

而在宽搜中，第一次被搜到肯定是最佳答案，所以可以加上一个记忆化，复杂度降到 $\operatorname{O(nm )}$ , 其中 $m$ 是**while中运行一次需要的时间**,在我的程序中，$m$ 约是 $\operatorname{l^3}$，$l$ 是原数的位数

最多约需要 $\operatorname{O(12500000)}$ 的时间，完全可以在 1s 内跑出来

最后提一句，因为这三个操作需要插入，删除，交换什么的，所以我用了 `string` 来存储数字

----

### 代码

- 细节说明：在开始把原数的答案设成 $1$ 而不是 $0$ , 意味着所有**可通过原数转换到的数**的答案都大一，所以输出时要减一。而这样处理完后，**不可通过原数转换到的数**的答案在减一后就是 $-1$ , 正好符合题目要求

```

// Problem: P1132 数字生成游戏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1132
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <bits/stdc++.h>
using namespace std;
int m,l;
string n;
map<string,int>ans;
queue<string>q;
void done()
{
	string u,v,f;
	int fl;
	q.push(n);
	while(!q.empty())
	{
		u=q.front();q.pop();fl=u.length();
		//cout<<u<<endl;
		//Step 1
		for(int i=0;i<fl;i++)
		{
			for(int j=i+1;j<fl;j++)
			{
				v=u;
				swap(v[i],v[j]);
				if(!ans[v])
				{
					ans[v]=ans[u]+1;
					q.push(v);
				}
				swap(v[i],v[j]);
			}
		}
		//Step 2
		for(int i=0;i<fl;i++)
		{
			v=u.substr(0,i)+u.substr(i+1);
			if(!ans[v])
			{
				ans[v]=ans[u]+1;
				q.push(v);
			}
		}
		// Step 3*
		if(u.length()<l)
		{
			for(int i=0;i<fl-1;i++)
			{
				for(char j=u[i]+1;j<u[i+1];j++)
				{
					v=u;
					f="";
					f+=j;
					v.insert(i+1,f);
					if(!ans[v])
					{
						ans[v]=ans[u]+1;
						q.push(v);
					}
				}
			}
		}
	}
}
int main()
{
	cin>>n;l=n.length();
	ans[n]=1;
	done();
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>n;
		cout<<ans[n]-1<<endl;
	}
	return 0;
}
```

---

## 作者：ljc20020730 (赞：3)

本题的算法是BFS或者DFS不用说注意hash判重！

三个操作：

1.将s的任意两位对换生成新的数字，例如143可以生成314，413，134；

2.将s的任意一位删除生成新的数字，例如143可以生成14，13，43

3.在s的相邻两位之间s[i]，s[i + 1]之间插入一个数字x，x需要满足s[i] < x < s[i + 1]且生成数的位数不能超过初始数s的位数

bfs拓展的时候依次枚举每一次操作的每一种可能，比较麻烦要注意检查。

注意bfs不能写在线必须写离线，因为问答太多，在线T的会比较厉害，不提倡

一次离线bfs把所有可能（桶来保存数i的最小操作次数）枚举出来再O（1）在线查询。

接下来是每个操作的拓展：

操作1;//拓展时枚举到底是那两位对换

```cpp
for i:=1 to length(hs) do
   for j:=i+1 to length(hs) do begin
    ts:=hs;
    ts[i]:=hs[j];
    ts[j]:=hs[i];
    val(ts,t);
    if hash[t] then continue;
    inc(tail);
    q[tail].step:=q[head].step+1;
    val(ts,q[tail].num);
    a[q[tail].num]:=min(a[q[tail].num],q[tail].step);
    hash[q[tail].num]:=true;
  end;
```
操作2；//拓展时枚举到底是一位数组删除

```cpp
for i:=1 to length(hs) do begin
   ts:='';
   for j:=1 to length(hs) do
    if j<>i then ts:=ts+hs[j];
   val(ts,t);
   if hash[t] then continue;
   inc(tail);
   q[tail].step:=q[head].step+1;
   val(ts,q[tail].num);
   a[q[tail].num]:=min(a[q[tail].num],q[tail].step);
   hash[q[tail].num]:=true;
  end;
```
操作3；//拓展时枚举到底是那两位相邻的数字插入，插入的是何种数字

```cpp
if length(hs)>=length(s) then continue;
  for i:=1 to length(hs)-1 do begin
   for x:=hs[i] to hs[i+1] do begin
    if x=hs[i] then continue;
    if x=hs[i+1] then continue; //s[i]<x<s[i+1];
    ts:=copy(hs,1,i);
    ts:=ts+x;
    ts:=ts+copy(hs,i+1,length(hs)-i+1);
    val(ts,t);
    if hash[t] then continue;
    inc(tail);
    q[tail].step:=q[head].step+1;
    val(ts,q[tail].num);
    a[q[tail].num]:=min(a[q[tail].num],q[tail].step);
    hash[q[tail].num]:=true;
   end;
  end;
```
接下来是程序（pas）

```cpp
type rec=record
 num,step:longint;
end;
var s:string;
    m,t,maxmax,i:longint;
    a:array[0..9999*100]of longint;
    q:array[0..9999*100]of rec;
    hash:array[0..9999*100]of boolean;
function min(a,b:longint):longint;
begin
 if a<b then exit(a)
 else exit(b);
end;
procedure bfs;
var head,tail,i,j,t:longint;
    hs,ts:string;
    x:char;
begin
 val(s,q[1].num);
 a[q[1].num]:=0;
 q[1].step:=0;
 head:=0; tail:=1;
 while head<tail do begin
  inc(head);
  str(q[head].num,hs);
  for i:=1 to length(hs) do
   for j:=i+1 to length(hs) do begin
    ts:=hs;
    ts[i]:=hs[j];
    ts[j]:=hs[i];
    val(ts,t);
    if hash[t] then continue;
    inc(tail);
    q[tail].step:=q[head].step+1;
    val(ts,q[tail].num);
    a[q[tail].num]:=min(a[q[tail].num],q[tail].step);
    hash[q[tail].num]:=true;
  end;
  for i:=1 to length(hs) do begin
   ts:='';
   for j:=1 to length(hs) do
    if j<>i then ts:=ts+hs[j];
   val(ts,t);
   if hash[t] then continue;
   inc(tail);
   q[tail].step:=q[head].step+1;
   val(ts,q[tail].num);
   a[q[tail].num]:=min(a[q[tail].num],q[tail].step);
   hash[q[tail].num]:=true;
  end;
  if length(hs)>=length(s) then continue;
  for i:=1 to length(hs)-1 do begin
   for x:=hs[i] to hs[i+1] do begin
    if x=hs[i] then continue;
    if x=hs[i+1] then continue;
    ts:=copy(hs,1,i);
    ts:=ts+x;
    ts:=ts+copy(hs,i+1,length(hs)-i+1);
    val(ts,t);
    if hash[t] then continue;
    inc(tail);
    q[tail].step:=q[head].step+1;
    val(ts,q[tail].num);
    a[q[tail].num]:=min(a[q[tail].num],q[tail].step);
    hash[q[tail].num]:=true;
   end;
  end;
 end;
end;
begin
 readln(s);
 readln(m);
 fillchar(a,sizeof(a),$7f);
 fillchar(hash,sizeof(hash),false);
 maxmax:=a[1];
 bfs;
 for i:=1 to m do begin
  readln(t);
  if a[t]=maxmax then writeln(-1)
  else writeln(a[t]);
 end;
end.

```

---

## 作者：d0j1a_1701 (赞：2)

裸的bfs。

别的题解大多用字符串，但也可以直接截取数字。

使用除法和取模可以分裂整数，乘法和加法可以合并。

举个栗子：

把 $31415926$ 这个8位整数从第四位（从左往右数）后面截成两个整数

先把这个数除以1000（ $10^{(8-4-1)}$）得到前面那一个整数是 $3141$

再取模10000( $10^{8-4}$ ) ，得到后面的是 $5926$ 。

合并也很简单，比如上面的两个数 $3141 \times 10^4 + 5926 = 31410000 + 5926=31415926$ 。

用这两个基本操作就可以实现题目中的所有操作。

数字截取法时间复杂度较优（每个操作 $O(log(n))$ 级别比隔壁字符串 $O(n)$ 要好上那么一点，但常数较大）。

询问次数很多，可以预处理所有可能变换出的数，每次 $O(1)$ 查询。

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
int powerOf10(int power) {//快速幂计算10的power次方 O(log n)
    if(power == 0)    return 1;
    int res = 1, tmp = powerOf10(power >> 1);
    if(power & 1) return tmp * tmp * 10;
    return tmp * tmp;
}
inline int digit(int x) {//计算数字位数 O(log10(n))
    int res = 0;
    while(x > 0) {
        x /= 10;
        res++;
    }
    return res;
}
inline int g​et(int base, int pos) {//获取base下标为pos的数字 O(log n)
    int db = digit(base);
    if(pos < 0 || po​s >= db)  return 1;//防越界 这样不需要在bfs里特判
    return base / powerOf10(digit(base) - pos - 1) % 10;
}
inline int swap(int base, int x, int y) {//交换base下标为x和y的数字 O(log n)
    int px = power​Of10(digit(base) - x - 1), py = powerOf10(digit(base) - y - 1);//x,y后是10的几次方
    int nx = get(base, x), ny = get(base, y);//x,y位置上对应的数
    base -= nx * px;//减掉原位置的数
    base -= ny * py;
    base += nx * py;//互换位置加回去
    bas​e += ny * px;
    return base;
}
inline int insert(int base, int pos, int x) {//在base下标pos的前方插入x O(log n)
    int pivot = powerOf10(digit(base) - pos), pre = base / pivot, post = base % pivot;//找分割点并将base拆分成pre,post两部分
    int pd​post = powerOf10(digit(post));
    return pre * pdpost * 10 + x * pdpost + post;//合并时加入x
}
inline int erase(int base, int pos) {//删除base下标pos位置的数字 O(log n)
    int pivot = powerOf​10(digit(base) - pos - 1), pre = base / pivot, post = base % pivot;//分割
    pre /= 10;//删除前部分最后一个数字（指定数字）
    return pre * powerOf10(digit(post)) + post;//合并
}
int mem[1000010], start, n, dstart;
queue<int> q;
inline void upd​ate(int cur, int nxt) {//更新mem（答案）数组
    if(mem[nxt] == -1) {//因为是bfs而且“代价”是1，所以每个点第一次搜到的就是最优解
        mem[nxt] = mem[cur] + 1;
        q.push(nxt);
    }
}
void bfs() {
    q.push(start);
    memset(mem, -1, sizeof(mem));
    mem[sta​rt] = 0;
    while(q.size()) {//标准广搜模板
        int cur = q.front();
        q.pop();
        int d = digit(cur);
        if(d == 1)    cont​inue;//如果位数=1，那么什么也做不了
        for(int i = 0; i < d; i++) {//交换操作
            for(int j = i + 1; j < d; j++) {
                int nxt = swap(cur, i, j);
                update(cur, nxt);                                                                                                                                                                                           																							                                                                                                           **反抄袭**
            }
        }
        for(int i = 0; i < d; i++) {//删除操作
            int nxt = era​se(cur, i);
            update(cur, nxt);
        }
        if(d < dstart)//注意“位数不能超过起始位数”的条件
            for(int i = 1; i < d; i++) {//插入操作
                for(int j = get(cur, i - 1) + 1; j < get(cur, i); j++) {
                    int nxt = insert(cur, i, j);
                    update(cur, nxt);
                }
            }
    }
}
int main() {
    cin >> start >> n;
    dstart = digi​t(start);
    b​fs();//预处理
    while(n--) {
        int target;
        cin >> target;
        cout << mem[target] << endl;
    }
    syst​em("pause");
    return 0;
}
```


---

## 作者：Kevin_Zhen (赞：2)

### 搜索详解
题目链接 [$\mathfrak{P1132}$](https://www.luogu.com.cn/problem/P1132)。

### 思路
如果对于每次询问都进行一次 $bfs$，求出得到 $t$ 的操作次数，时间复杂度为 $O(mq)$，其中 $q$ 为单次询问生成的数的总数（在最劣情况下，即无法得到 $t$ 时，单次询问生成的数的总数即为 $s$ 能构造出的所有数字总数）。在 $s<1e6$ 的数据下显然很容易超时。  
可以这样感性地理解：每次询问我们都要重新对 $s$ 进行构造，进行了大量重复的操作，降低了效率。

那还不如直接预处理出 $s$ 能构造出的所有数，每次询问 $O(1)$ 回答。  
时间复杂度为 $O(m+q)$，其中 $q$ 为 $s$ 能构造出的所有数字总数。$q$ 远小于 $1e7$，此算法可行。

### AC CODE
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;

const int maxn = 500010;

int n, m, s[maxn], Len;
bool flag[maxn]; int f[maxn];
queue<int> q;

void bfs() {
	while (q.size()) {
		int u = q.front(); q.pop();
		int len = 0, t = u, x = 0;
		while (t) s[++len] = t % 10, t /= 10;
		//对换
		for (int i = 1; i < len; ++i) {
			for (int j = i + 1; j <= len; ++j) {
				x = 0;
				swap(s[i], s[j]);
				for (int k = len; k; --k) x = x * 10 + s[k];
				if (flag[x]) {
					swap(s[i], s[j]);
					continue;
				}
				flag[x] = true; f[x] = f[u] + 1; q.push(x);
				swap(s[i], s[j]);
			}
		}
		//删除
		for (int i = 1; i <= len; ++i) {
			x = 0;
			for (int j = len; j; --j) {
				if (j == i) continue;
				x = x * 10 + s[j];
			}
			if (flag[x]) continue;
			flag[x] = true; f[x] = f[u] + 1; q.push(x);
		}
		//插入
		for (int i = len; i >= 2; --i) {
			for (int j = s[i] + 1; j <= s[i - 1] - 1; ++j) {
				x = 0;
				for (int k = len; k; --k) {
					x = x * 10 + s[k];
					if (k == i) x = x * 10 + j;
				}
				if (flag[x]) continue;
				int xlen = 0, _t = x; while (_t) ++xlen, _t /= 10;
				if (xlen > Len) continue;
				flag[x] = true; f[x] = f[u] + 1; q.push(x);
			}
		} 
	}
}

int main() {
	scanf("%d", &n);
	flag[n] = true; q.push(n);
	while (n) ++Len, n /= 10;
	bfs();
	scanf("%d", &m);
	for (int i = 1; i <= m; ++i) {
		int a; scanf("%d", &a);
		if (flag[a]) printf("%d\n", f[a]);
		else printf("-1\n");
	}
	return 0;
}
```
### 感谢观赏！

---

## 作者：EuphoricStar (赞：2)

BFS。

先预处理出 $s$ 生成每个数所需的最小步数。然后对于每一个询问，$O(1)$ 输出结果。

时间复杂度大约是 $O(s + m)$。

由于实现比较简单，因此直接放代码了。

```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
bool vis[100100];
int dis[100100], m;
struct node {
    string s;
    int step;
};
queue<node> q;

int str2int(string n) {
    int ans = 0;
    for (int i = 0; i < n.size(); ++i) {
        ans = ans * 10 + n[i] - '0';
    }
    return ans;
}

int main() {
    memset(dis, 0x3f, sizeof(dis));
    ios::sync_with_stdio(0);
    cin >> s;
    vis[str2int(s)] = 1;
    q.push({s});
    while (q.size()) {
        node u = q.front();
        dis[str2int(u.s)] = u.step;
        q.pop();
        for (int i = 0; i < u.s.size() - 1; ++i) {
            for (int j = i + 1; j < u.s.size(); ++j) {
                string ns = u.s;
                swap(ns[i], ns[j]);
                int nx = str2int(ns);
                if (!vis[nx]) {
                    vis[nx] = 1;
                    q.push({ns, u.step + 1});
                }
            }
        }
        if (u.s.size() > 1) {
            for (int i = 0; i < u.s.size(); ++i) {
                string ns = u.s;
                ns.erase(ns.begin() + i);
                int nx = str2int(ns);
                if (!vis[nx]) {
                    vis[nx] = 1;
                    q.push({ns, u.step + 1});
                }
            }
        }
        if (u.s.size() >= s.size()) {
            continue;
        }
        for (int i = 0; i < u.s.size() - 1; ++i) {
            for (int j = u.s[i] - '0' + 1; j < u.s[i + 1] - '0'; ++j) {
                string ns = u.s;
                ns.insert(ns.begin() + i + 1, j + '0');
                int nx = str2int(ns);
                if (!vis[nx]) {
                    vis[nx] = 1;
                    q.push({ns, u.step + 1});
                }
            }
        }
    }
    cin >> m;
    while (m--) {
        int x;
        cin >> x;
        if (dis[x] == 0x3f3f3f3f) {
            cout << -1 << endl;
        } else {
            cout << dis[x] << endl;
        }
    }
    return 0;
}
```


---

## 作者：afm_afk (赞：0)

**思路：map + bfs**

------------
分析：首先观察题面，所有 m 个操作都是基于一个数的操作，所以最好的方法就是预处理出所有的情况，在输入查询时只需要 $O(1)$ 查询即可。本题涉及到数位与数位之间的交换等操作，单纯的整型变量比较麻烦，所以本蒟蒻使用了字符串（巨佬随意）。但是这道题又涉及到了记忆化，开数组无法解决字符串的问题，所以使用 map 的思路就油然而生啦~。  
对于题面给的三种操作，为了操作简便可以使用 swap 、字符串自带的 erase 、insert 操作，进一步减少我们的思考量。  
细节见代码注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> q;
int t,n;
string str;
void bfs(){
	queue<pair<string,int> > p;
	p.push({str,0});//向队列里加入原来的数
	while(p.size()){
		string x=p.front().first;int step=p.front().second;p.pop();
		if(q.find(x)!=q.end())continue;
		q[x]=step;
		for(int i=0;i<x.size();i++){//规则1：直接枚举ij交换即可
			for(int j=i+1;j<x.size();j++){
				string y=x;
				swap(y[i],y[j]);
				p.push({y,step+1});
			}
		}
		if(x.size()>1){//一位的数不可以使用规则2，因为减去就什么都没有了
			for(int i=0;i<x.size();i++){//枚举每一位
				string y=x;
				y.erase(i,1);
				p.push({y,step+1});
			}
		}
		if(x.size()<n){//规则3的限制
			for(int i=0;i<x.size()-1;i++){//枚举每一位
				for(int j=x[i]+1;j<x[i+1];j++){//枚举两位之间的数
					string y=x;
					string k;k=k+(char)j;
					y.insert(i+1,k);
					p.push({y,step+1});
				}
			}
		}
	}
}
int main(){
	cin>>str;//使用字符串读入
	n=str.size();//为规则3的限制预处理出长度
	bfs();
	cin>>t;
	while(t--){
		string x;
		cin>>x;
		if(q.find(x)!=q.end())cout<<q[x]<<endl;//只需要查询map里是否有这个数即可
		else cout<<-1<<endl;//没有就是不能变化
	}
	return 0;
}
```


---


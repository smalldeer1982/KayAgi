# 魔术数字游戏

## 题目描述

填数字方格的游戏有很多种变化，如下图所示的 $4 \times 4$ 方格中，我们要选择从数字 $1$ 到 $16$ 来填满这十六个格子($A_{i,j}$ ，其中 $i=1 \cdots 4$ ，$j=1 \cdots 4$)。为了让游戏更有挑战性，我们要求下列六项中的每一项所指定的四个格子，其数字累加的和必须为 $34$ ：

| $A_{1,1}$ | $A_{1,2}$ | $A_{1,3}$ |  $A_{1,4}$|
| :----------- | :----------- | :----------- | :----------- |
| $A_{2,1}$ | $A_{2,2}$ | $A_{2,3}$ | $A_{2,4}$ |
| $A_{3,1}$ | $A_{3,2}$ | $A_{3,3}$ | $A_{3,4}$ |
| $A_{4,1}$ | $A_{4,2}$ | $A_{4,3}$ | $A_{4,4}$ |

- 四个角落上的数字，即 $A_{1,1}+A_{1,4}+A_{4,1}+A_{4,4}=34$ 。
- 每个角落上的 $2 \times 2$ 方格中的数字，例如左上角 $A_{1,1}+A_{1,2}+A_{2,1}+A_{2,2}=34$ 。
- 最中间的 $2 \times 2$ 方格中的数字，即 $A_{2,2}+A_{2,3}+A_{3,2}+A_{3,3}=34$ 。
- 每条水平线上四个格子中的数字，即 $A_{i,1}+A_{i,2}+A_{i,3}+A_{i,4}=34$，其中 $i=1 \cdots 4$ 。
- 每条垂直线上四个格子中的数字，即 $A_{1,j}+A_{2,j}+A_{3,j}+A_{4,j}=34$，其中 $j=1 \cdots 4$ 。
- 两条对角线上四个格子中的数字，例如左上角到右下角 $A_{1,1}+A_{2,2}+A_{3,3}+A_{4,4}=34$ 。
- 右上角到左下角：$A_{1,4}+A_{2,3}+A_{3,2}+A_{4,1}=34$ 。

特别的，我们会指定把数字 $1$ 先固定在某一格内。

## 说明/提示


可以得到，对于样例，合理的填写方法有 $216$ 种，以上仅为其中的两种。

#### 数据规模与约定 
对于全部的测试点，保证 $1 \leq i, j \leq 4$。

## 样例 #1

### 输入

```
1 1
```

### 输出

```
1 4 13 16 
14 15 2 3 
8 5 12 9 
11 10 7 6 

1 4 13 16 
14 15 2 3 
12 9 8 5 
7 6 11 10 

……剩余214组合法解省略```

# 题解

## 作者：Utilokasteinn (赞：26)

# [P1274 魔术数字游戏](https://www.luogu.com.cn/problem/P1274)

一道深搜回溯题，过程代码判断的代码挺多的。

先说一下思路，**从$a_{1,1}$开始深搜，然后到$a_{1,2}$，到$a_{1,3}$，到$a_{1,4}$。到了每行的最后一个数时就来到下一行，即$a_{2,1}$。**

**搜到$a_{5,1}$的时候就开始判断**，（注意不是$a_{4,4}$，因为只有到$a_{5,1}$的时候$a_{4,4}$才有值。）如果判断全部符合要求就输出，否则就回溯重搜。

**但是这样会超时**，比如说，第一行的四个数分别是
$$1,2,3,4$$
这样肯定不符合要求，但是这个时候却要继续往下搜，这样就浪费了不少时间。

所以我们可以在**每次深搜的时候就判断一次，如果不符合条件就这就$return$**，这样就可以节省不少时间。

我们可以发现，如果每次深搜时都判断一次，而每次判断虽然时间复杂度是$O(1)$，（应该是吧，我不太清楚）但是常数巨大。

由于$a_{4,4}$是在最后一次深搜时才出现值的，所以之前可以不用判断一下四个需要用到$a_{4,4}$值的判断：

- 四个角落上的数字和。

- 右下$2\times 2$的数字和。

- 第四行的数字和。

- 第四列的数字和。

- 左上到右下对角线的数字和。

所以，我们可以**在之前的判断少一上这$5$个判断，然后再写一个新的判断，包含这$5$个判断，这样常数就会大幅度减少，速度变快。**

由于这题输出量较大，建议用$printf$，如果可以手写快输（快写）也是可以的，当然$fwrite$也可以。

附上我的~~垃圾~~快输（快写）（可能会出锅，我这题没试过）：
```cpp
inline void write(int x)
{
    static char buf[15];
    static int len=-1;
    if(x<0)putchar('-'),x=-x;
    do buf[++len]=x%10,x/=10;while(x);
    while(len>=0)putchar(buf[len--]+'0');
}
```

附上完整的有详细注释的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5][5],v[17],n,m;
//a[i][j]来记录位置[i,j]所存的数，v[i]存i是否用过，n和m如题 
int check(int x,int y)
{ 
	//这里不要把两个if改为一个，否则全错 
	//前一个if是判断要判断的数是否在那个范围以内
	//后一个if是看和是不是34，如果一个不是就直接返回0，说明该方案不行，需要回溯重搜 
	if(x>2||x==2&&y>=2)
		if(a[1][1]+a[1][2]+a[2][1]+a[2][2]!=34)return 0;//左上角2*2位置的数的和 
	if(x>2||x==2&&y==4)
		if(a[1][3]+a[1][4]+a[2][3]+a[2][4]!=34)return 0;//右上角2*2位置的数的和 
	if(x==4&&y>=2)
		if(a[3][1]+a[3][2]+a[4][1]+a[4][2]!=34)return 0;//左下角2*2位置的数的和 
	if(x>3||x==3&&y>=3)
		if(a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34)return 0;//中央的2*2位置的数的和 
	if(x>1||x==1&&y>=4)
		if(a[1][1]+a[1][2]+a[1][3]+a[1][4]!=34)return 0;//第一行所有数的和 
	if(x>2||x==2&&y>=4)
		if(a[2][1]+a[2][2]+a[2][3]+a[2][4]!=34)return 0;//第二行所有数的和 
	if(x>3||x==3&&y>=4)
		if(a[3][1]+a[3][2]+a[3][3]+a[3][4]!=34)return 0;//第三行所有数的和 
	if(x==4&&y>=1)
		if(a[1][1]+a[2][1]+a[3][1]+a[4][1]!=34)return 0;//第一列所有数的和 
	if(x==4&&y>=2)
		if(a[2][1]+a[2][2]+a[2][3]+a[2][4]!=34)return 0;//第二列所有数的和 
	if(x==4&&y>=3)
		if(a[3][1]+a[3][2]+a[3][3]+a[3][4]!=34)return 0;//第三列所有数的和 
	if(x==4&&y>=1)
		if(a[1][4]+a[2][3]+a[3][2]+a[4][1]!=34)return 0;//左下到右上对角线所有数的和 
	return 1;
} 
int check1()//搜完了，所有位置肯定都有数了，所以不必传参数x，y 
{
	if(a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34)return 0;//四个角的数的和 
	if(a[3][3]+a[3][4]+a[4][3]+a[4][4]!=34)return 0;//右下角2*2位置的数的和 
	if(a[4][1]+a[4][2]+a[4][3]+a[4][4]!=34)return 0;//第四行所有数的和 
	if(a[1][4]+a[2][4]+a[3][4]+a[4][4]!=34)return 0;//第四列所有数的和 
	if(a[1][1]+a[2][2]+a[3][3]+a[4][4]!=34)return 0;//左上到右下对角线所有数的和 
	return 1;//如果所有都满足就返回1 
}
void dfs(int x,int y)
{
	if(x==5&&y==1&&check1())
	{
		for(int i=1;i<=4;i++)//输出 
		{
			for(int j=1;j<=4;j++)
				printf("%d ",a[i][j]);//printf较快 
			putchar('\n');//putchar较快 
		}
		putchar('\n');//还要再换一次行 
		return;//答案输出后就可以返回了 
	}
	if(a[x][y])//如果当前这个位置有数了 
		if(y==4)dfs(x+1,1);//如果到了一行中的最后一个位置，那就到下一行继续搜 
		else dfs(x,y+1);//否则就再往下一个数搜
	else//如果没有数 
	{
		if(y==1)x--,y=4;//如果是一行的第一个位置，就返回到上一行的最后一个位置搜 
		else y--;//否则就退到前一个位置 
		if(!check(x,y))return;//如果不符合，就可以直接return了 
		if(y==4)x++,y=1;//如果是一行中最后一个数，就来到下一行第一个数 
		else y++;//否则就来到下一个位置 
		for(int i=2;i<=16;i++)//继续深搜 
			if(!v[i])//如果当前这个数没有用过 
			{
				v[i]=1;//标记这个数用过了 
				a[x][y]=i;//当前位置的数为 i 
				if(y==4)dfs(x+1,1);//如果到了一行中最后一个位置，就来到下一行 
				else dfs(x,y+1);//否则就来到同一行下一个位置 
				a[x][y]=v[i]=0;//回溯时清零 
			}
	}
}
int main()
{
	cin>>n>>m;//输入n和m 
	a[n][m]=v[1]=1;//a[n][m]的值为1，且标记用过1这个数 
	dfs(1,1);//从第一行第一个数开始搜 
	return 0;//结束 
}
```
平均速度$2s$左右，应该是非打表（一点也算）中比较快的。（吐槽一下，本题的$rank\;1$是打表过的……）代码也很短，去掉注释$1.73KB$，而且还没有用三目运算符之类的。比

无注释代码我放[这里](https://www.luogu.com.cn/paste/av4v6yn6)，仅供参考。

谢谢观赏，麻烦点个赞犒劳一下……

---

## 作者：Wenxiang_MCL (赞：9)

很明显，这是一道搜索题，最大的特点就是有无数的条件；

也代表这有无数的剪枝条件；

最暴力也是最直观的方法就是一大堆if剪枝；

剩下的就是暴力填数了 —V—

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
using namespace std;
int s[20] = {0};
int f[20];
int cx,cy;
int sta;
void print();
void print(){
    for(int i = 0;i <= 3;i ++){
        for(int j = 1;j <= 4;j ++){
            printf("%d ",s[j + i * 4]);
        }
        printf("\n");
    }
    printf("\n");
}
int check();
int check(){
    if(s[1] + s[4] + s[13] + s[16] != 34 && s[1] && s[4] && s[13] && s[16]) return 0;
    if(s[6] + s[7] + s[10] + s[11] != 34 && s[6] && s[7] && s[10] && s[11]) return 0;
    if(s[1] + s[2] + s[3] + s[4] != 34 && s[1] && s[2] && s[3] && s[4]) return 0;
    if(s[5] + s[6] + s[7] + s[8] != 34 && s[5] && s[6] && s[7] && s[8]) return 0;
    if(s[9] + s[10] + s[11] + s[12] != 34 && s[9] && s[10] && s[11] && s[12]) return 0;
    if(s[13] + s[14] + s[15] + s[16] != 34 && s[13] && s[14] && s[15] && s[16]) return 0;
    if(s[1] + s[5] + s[9] + s[13] != 34 && s[1] && s[5] && s[9] && s[13]) return 0;
    if(s[2] + s[6] + s[10] + s[14] != 34 && s[2] && s[6] && s[10] && s[14]) return 0;
    if(s[3] + s[7] + s[11] + s[15] != 34 && s[3] && s[7] && s[11] && s[15]) return 0;
    if(s[4] + s[8] + s[12] + s[16] != 34 && s[4] && s[8] && s[12] && s[16]) return 0;
    if(s[1] + s[6] + s[11] + s[16] != 34 && s[1] && s[6] && s[11] && s[16]) return 0;
    if(s[4] + s[7] + s[10] + s[13] != 34 && s[4] && s[7] && s[10] && s[13]) return 0;
    if(s[1] + s[2] + s[5] + s[6] != 34 && s[1] && s[2] && s[5] && s[6]) return 0;
    if(s[3] + s[4] + s[7] + s[8] != 34 && s[3] && s[4] && s[7] && s[8]) return 0;
    if(s[9] + s[10] + s[13] + s[14] != 34 && s[9] && s[10] && s[13] && s[14]) return 0;
    if(s[11] + s[12] + s[15] + s[16] != 34 && s[11] && s[12] && s[15] && s[16]) return 0;
    return 1;
}
void dfs(int pos,int cnt);
void dfs(int pos,int cnt){
    if(cnt >= 16){
        print();
        return;
    }
   if(s[pos] != 0) {
       dfs(pos + 1,cnt + 1);
       return;
   }
   for(int i = 2;i <= 16;i ++){
      if(f[i] == 1) continue;
      f[i] = 1,s[pos] = i;
      if(!check() && cnt != 0){
         s[pos] = 0,f[i] = 0;
         continue;
      }
      //int state;
      //state = fill();
      dfs(pos + 1,cnt + 1);
      s[pos] = 0;
      f[i] = 0;
      //refill(state);
   }
}
int main (){
    scanf("%d%d",&cx,&cy);
    s[cy + (cx - 1) * 4] = 1,f[1] = 1;
    dfs(1,0);
}/linux下码的，格式可能不太整齐
```

---

## 作者：lukelin (赞：6)

### 前言
**首先安利博客:[更好的阅读体验](https://www.cnblogs.com/linzhengmin/p/11163752.html)**  
吐槽一下样例，它是不完整的。
### 题解
首先为了方便计算我们显然要把一个格子的两个坐标压成一个整数。  
具体计算方法将$(i,j)$转换为$(i-1)\times4+j-1$。  
这里我来介绍一种比较简洁的打法，首先我们打表预处理出所有的互相影响的块。  
它长得像这样(由于4个角落的条件与中间4个的条件和对角线的条件冲突，所以不用考虑了):  
```cpp
int b[15][4] = {
    //row
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11},
    {12, 13, 14, 15},
    //col
    {0, 4, 8, 12},
    {1, 5, 9, 13},
    {2, 6, 10, 14},
    {3, 7, 11, 15},
    //djx
    {0, 5, 10, 15},
    {3, 6, 9, 12},
    //mid
    {5, 6, 9, 10},
    //block
    {0, 1, 4, 5},
    {2, 3, 6, 7},
    {8, 9, 12, 13},
    {10, 11, 14, 15}
    //jl
    //{0, 3, 12, 15}
};
```
在手算的时候注意让每个块内的四个元素从小到大排列，或者说至少最大的在最后，那么我们计算到每块第四个元素的时候，就可以直接计算了。  
然后预处理每个元素是否能够被剪枝。  
```cpp
for (int i = 0; i < 15; ++i)
    xz[b[i][3]][cnt[b[i][3]]++] = i;
```
然后我们接下来直接DFS，当搜索到一个格子的时候，首先将它置为0。  
开一个vis数组避免数字选择重复。  
$pos1$表示题目限制的数字$1$的位置。  
然后就珂以这样来判断剪枝:
```cpp
a[num] = 0;
for (int i = 0; i < cnt[num]; ++i){
    if (!a[num]){
        a[num] = 34 - a[b[xz[num][i]][0]] - a[b[xz[num][i]][1]] - a[b[xz[num][i]][2]];
        if (a[num] > 16 || a[num] < 1) return ;
        if (a[num] == 1 && num != pos1) return ;
        if (vis[a[num]]) return ;
    }
    else{
        if (a[num] != 34 - a[b[xz[num][i]][0]] - a[b[xz[num][i]][1]] - a[b[xz[num][i]][2]]) return ;
    }
}
```
然后如果$a[num]$还没有值就枚举(为了提高效率在$pos1$特殊处理)。
```cpp
if (num == pos1){
    if (vis[1]) return ;
    vis[1] = 1; a[num] = 1;
    DFS(num + 1);
    vis[1] = 0;
}
else{
    for (int i = 2; i <= 16; ++i){
        if(vis[i]) continue;
        vis[i] = 1; a[num] = i;
        DFS(num + 1);
        vis[i] = 0;
    }
}
```
否则直接继续搜索。  

整个主体和构思非常简洁明了。  
~~然后一遍AC完结撒花！~~
### 代码
没有压行，所以较长。  
```cpp
#include <cstdio>

int b[15][4] = {
    //row
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11},
    {12, 13, 14, 15},
    //col
    {0, 4, 8, 12},
    {1, 5, 9, 13},
    {2, 6, 10, 14},
    {3, 7, 11, 15},
    //djx
    {0, 5, 10, 15},
    {3, 6, 9, 12},
    //mid
    {5, 6, 9, 10},
    //block
    {0, 1, 4, 5},
    {2, 3, 6, 7},
    {8, 9, 12, 13},
    {10, 11, 14, 15}
    //jl
    //{0, 3, 12, 15}
};

int a[16];
int vis[17];
int xz[16][10];
int cnt[16];
int pos1;

void DFS(int num){
    if (num == 16){
        if (a[pos1] != 1) return ;
        for (int i = 0; i < 4; ++i) printf("%d%c", a[i], ((i == 3) ? '\n' : ' '));
        for (int i = 4; i < 8; ++i) printf("%d%c", a[i], ((i == 7) ? '\n' : ' '));
        for (int i = 8; i < 12; ++i) printf("%d%c", a[i], ((i == 11) ? '\n' : ' '));
        for (int i = 12; i < 16; ++i) printf("%d%c", a[i], ((i == 15) ? '\n' : ' '));
        puts("");
        return ;
    }
    a[num] = 0;
    for (int i = 0; i < cnt[num]; ++i){
        if (!a[num]){
            a[num] = 34 - a[b[xz[num][i]][0]] - a[b[xz[num][i]][1]] - a[b[xz[num][i]][2]];
            if (a[num] > 16 || a[num] < 1) return ;
            if (a[num] == 1 && num != pos1) return ;
            if (vis[a[num]]) return ;
        }
        else{
            if (a[num] != 34 - a[b[xz[num][i]][0]] - a[b[xz[num][i]][1]] - a[b[xz[num][i]][2]]) return ;
        }
    }
    if (!a[num]){
        if (num == pos1){
            if (vis[1]) return ;
            vis[1] = 1; a[num] = 1;
            DFS(num + 1);
            vis[1] = 0;
        }
        else{
            for (int i = 2; i <= 16; ++i){
                if(vis[i]) continue;
                vis[i] = 1; a[num] = i;
                DFS(num + 1);
                vis[i] = 0;
            }
        }
    }
    else{
        if (num == pos1 && a[num] != 1) return ;
        vis[a[num]] = 1;
        DFS(num + 1);
        vis[a[num]] = 0;
    }
}

int main(){
    int x, y; scanf("%d %d", &x, &y); pos1 = (x - 1) * 4 + y - 1;
    for (int i = 0; i < 15; ++i)
        xz[b[i][3]][cnt[b[i][3]]++] = i;
    DFS(0);
    return 0;
}
```

---

## 作者：__Hacheylight__ (赞：6)

觉得这题题目出的有点问题，样例输出没有那么少的。
这道题目的正解是**搜索(DFS)+剪枝**，可能比较难看，请见谅。。

1.普通搜索

先把该点所在的位置赋为1，从(1,1)到(4,4)不停的放，之后判断可行性，于是算法复杂度就是O(15!)（超时）。

那我们怎么优化加速呢？

**可行性剪枝**呗(这里不存在最优性剪枝)

2.搜索+剪枝

每次搜索都判断(放在代码中的check)当前所放元素是否可行，可以判断的标准有：
左上角的2*2方格，右上角的2*2方格，左下角的2*2方法，中央的2*2方格，第一行，第二行，第三行，第一列，第二列，第三列，左下角到右上角；

最后矩阵放完了可以判断(代码中的Fjdge)的标准有：
四个角落，右下角2*2方格，第四行，第四列，左上角到右下角。这些都用到了(4,4)，所以要到最后再判断。

这种方法应该是能过的。有更优的方法或题解的错误，请在讨论区留言。

提供有注释的AC代码，较短：
```cpp
#include <bits/stdc++.h>
using namespace std ;
int a[10][10],vis[20],n,m ;
int Fjdge(){ //最后的判断，Final Judge 

	if (a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34) return 0 ;//四个角落 
	if (a[3][3]+a[3][4]+a[4][3]+a[4][4]!=34) return 0 ;//右下角2*2方格 
	if (a[4][1]+a[4][2]+a[4][3]+a[4][4]!=34) return 0 ;//第四行 
	if (a[1][4]+a[2][4]+a[3][4]+a[4][4]!=34) return 0 ;//第四列 
	if (a[1][1]+a[2][2]+a[3][3]+a[4][4]!=34) return 0 ;//左上角到右下角
	return 1 ; 
}
int check(int x,int y){ //剪枝 

	if (x>2 || x==2 && y>=2) if (a[1][1]+a[1][2]+a[2][1]+a[2][2]!=34) return 0;//左上角的2*2方格  
	if (x>2 || x==2 && y==4) if (a[1][3]+a[1][4]+a[2][3]+a[2][4]!=34) return 0;//右上角的2*2方格 
	if (x==4 && y>=2) if (a[3][1]+a[3][2]+a[4][1]+a[4][2]!=34) return 0 ;//左下角的2*2方法 
	if (x>3 || x==3 && y>=3) if (a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34) return 0 ;//中央的2*2方格 
	if (x>1 || x==1 && y>=4) if (a[1][1]+a[1][2]+a[1][3]+a[1][4]!=34) return 0 ;//第一行 
	if (x>2 || x==2 && y>=4) if (a[2][1]+a[2][2]+a[2][3]+a[2][4]!=34) return 0 ;//第二行 
	if (x>3 || x==3 && y>=4) if (a[3][1]+a[3][2]+a[3][3]+a[3][4]!=34) return 0 ;//第三行 
	if (x==4 && y>=1) if (a[1][1]+a[2][1]+a[3][1]+a[4][1]!=34) return 0 ;//第一列 
	if (x==4 && y>=2) if (a[2][1]+a[2][2]+a[2][3]+a[2][4]!=34) return 0 ;//第二列 
	if (x==4 && y>=3) if (a[3][1]+a[3][2]+a[3][3]+a[3][4]!=34) return 0 ;//第三列 
	if (x==4 && y>=1) if (a[1][4]+a[2][3]+a[3][2]+a[4][1]!=34) return 0 ;//左下角到右上角 
	return 1 ;
} 
void dfs(int x,int y){ //表示准备放i,j 
	if (x==5 && y==1){  //搜索结束,判断没有问题的话，就可以输出了 
		if (Fjdge()==1){
			for (int i=1;i<=4;i++){ 
				for (int j=1;j<=4;j++) printf("%d ",a[i][j]) ;
				printf("\n") ;
			}
			printf("\n") ;
		}
	}
	
	if (a[x][y]!=0){  //当前节点已被固定为1 
		if (y==4) dfs(x+1,1);
		else dfs(x,y+1) ;
	}
	else {
		if (y==1){
			x--;y=4 ;
		}
		else y-- ;
		if (!check(x,y)) return ; 
		if (y==4){
			x++;y=1 ;
		}
		else y++ ;
		for (int i=2;i<=16;i++)
		if (!vis[i]) {
			vis[i]=1;a[x][y]=i ;
			if (y==4) dfs(x+1,1) ;
			else dfs(x,y+1) ;
			a[x][y]=0;vis[i]=0 ;
		}
	}
	
}
int main(){
	scanf("%d%d",&n,&m) ;
	a[n][m]=1;vis[1]=1 ; 
	if (!(n==1 && m==1)){
		for (int i=2;i<=16;i++){
			a[1][1]=i;vis[i]=1;
			dfs(1,2);//表示准备放i,j
			vis[i]=0;a[1][1]=0;
		}	
	}
	else dfs(1,2) ;
	return 0 ;
}
```

---

## 作者：zhuaiballl (赞：4)

暴力打表，分别打出(x,y)=(1,1),(1,2),(2,2)时的答案，由这些答案经过旋转、对称即可得到所有情况下的答案。旋转、对称后记得排序。
```cpp
#include<bits/stdc++.h>
using namespace std;
int biao11[216][4][4]={
//skipped
};
int biao12[216][4][4]={
//skipped
};
int biao22[216][4][4]={
//skipped
};
int getx[16]={0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3};
int gety[16]={0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3};
const int cl[4][4]={
{0,3,15,12},
{1,7,14,8},
{2,11,13,4},
{5,6,10,9}
};
struct board
{
    int val[4][4];
    bool operator <(const board &t)const
    {
        for(int i=0;i<4;i++)
            for(int j=0;j<4;j++)
            if(val[i][j]<t.val[i][j])return true;
            else if(val[i][j]>t.val[i][j])return false;
        return false;
    }
    void rtt()
    {
        for(int c=0;c<4;c++)
        {
            int t=val[getx[cl[c][0]]][gety[cl[c][0]]];
            for(int i=0;i<4;i++)val[getx[cl[c][i]]][gety[cl[c][i]]]=val[getx[cl[c][(i+1)%4]]][gety[cl[c][(i+1)%4]]];
            val[getx[cl[c][3]]][gety[cl[c][3]]]=t;
        }
    }
    void flp()
    {
        for(int i=0;i<4;i++)
            for(int j=0;j<2;j++)
            swap(val[i][j],val[i][3-j]);
    }
    void show()
    {
        for(int i=0;i<4;i++)
            for(int j=0;j<4;j++)printf("%d%c",val[i][j],j==3?'\n':' ');
    }
}ans[216];
void rot(){for(int i=0;i<216;i++)ans[i].rtt();}
void fleep(){for(int i=0;i<216;i++)ans[i].flp();}
int main()
{
    int x,y;
    scanf("%d%d",&x,&y);
    if((x==1||x==4)&&(y==1||y==4))
    {
        for(int i=0;i<216;i++)memcpy(ans[i].val,biao11[i],sizeof(ans[i].val));
        if(x==1&&y==4)fleep();
        else if(x==4&&y==1)rot();
        else if(x==4&&y==4){rot();fleep();}
    }
    else if((x==2||x==3)&&(y==2||y==3))
    {
        for(int i=0;i<216;i++)memcpy(ans[i].val,biao22[i],sizeof(ans[i].val));
        if(x==2&&y==3)fleep();
        else if(x==3&&y==2)rot();
        else if(x==3&&y==3){rot();fleep();}
    }
    else
    {
        for(int i=0;i<216;i++)memcpy(ans[i].val,biao12[i],sizeof(ans[i].val));
        if(x==1&&y==3)fleep();
        else if(x==2&&y==1){fleep();rot();}
        else if(x==2&&y==4){fleep();rot();fleep();}
        else if(x==3&&y==1){rot();}
        else if(x==3&&y==4){rot();fleep();}
        else if(x==4&&y==2){rot();rot();fleep();}
        else if(x==4&&y==3){rot();rot();}
    }
    sort(ans,ans+216);
    for(int i=0;i<216;i++,puts(""))
        ans[i].show();
    return 0;
}
```

---

## 作者：Eraine (赞：3)

# 1 题目简介
[P1274 魔术数字游戏](https://www.luogu.com.cn/problem/P1274)

**题目大纲**

有一个 $4×4$ 的方格。有以下几点要求：
- 每行每列数值之和之和必须为 $34$ 。
- 两条对角线数值之和之和必须为 $34$ 。
- 中间 $2×2$ 的正方形数值之和必须为 $34$ 。
- 边角 $2×2$ 每个正方形数值之和必须为 $34$ 。
- 四个角落上的格子数值之和必须为 $34$ 。

先要将 $1-16$ 共 $16$ 个数填进方格中。已给出 $1$ 的位置，要求按照字典序输出所有的解法。

**题目难度** 

内容（搜索->深度搜索优先）|实际难度
:-:|:-:
思路难度|丙
DFS难度|丙
剪枝难度|戊
总难度|丁
# 2 思路分析
写完这一题，看到网站里大佬们的题解与蒟蒻的题解都不一样。蒟蒻的题解是先枚举完所有可能的情况，然后再加判断指定位置上是否是 $1$ 即可。

## 2.1 思路分析

好了，废话不多说，先说思路吧。本蒟蒻的想法是全部枚举。然后在加以判断就好了。把所有共 $16×15×14×…1=20922789888000$ 种情况全部枚举出来即可。然后再来判断有木有符合要求。所以，在 $DFS$ 函数中，我们就需要用到 $3$ 个流程。第 $1$ 个，就是呢，当前节点的判断。从 $1$ 枚举到 $16$ 。这也就是 $DFS$ 的一个重要的流程。第 $2$ 个，就是判断啦。判断每行每列，四角，每个正方形方格，对角线是否都满足数值之和为 $34$ 。
提前先说一下我们递归时的顺序。
![图1](https://img-blog.csdnimg.cn/20200814092922889.png#pic_center)
## 2.2 $DFS$

**递归操作**

好吧，开始导入 $DFS$ 吧。我们从第行第列枚举到第行第列，当递归到当前节点时，就要从 $1$ 到 $16$ 每个数字递归。这个操作是为什么呢？因为每一个节点都有可能储存 $1$ 到 $16$ ，所以执行操作。其实这部操作是简单的。当正常情况下，要调到下一个节点，只需要将行 $+1$ 即可，列不用动。然后需要进行一个小剪枝，就是把当前用过的数做上标记，然后每一步就不必再重复循环递归了。

```cpp
	for(int i=1;i<=16;i++){//从1枚举到16
		if(b[i])continue;
		b[i]=true;//把当前用过的数做上标记，表示已经用过了
		a[x][y]=i;//先解释一下，a数组是用来储存每一个节点储存的数
		//这一步操作就是把当前循环的数标记在当前节点位置上
		search_dfs(x,y+1);//递归下一节点，行加上1
		b[i]=false;//回溯，这一步操作已经过去，不必再标记
	}
```

**边界处理**

这里的边界处理其实很简单。如图，当循环至第 $2$ 列第 $5$ 行时，因为第 $2$ 列第 $5$ 行不在这个 $4×4$ 的方格中，那我们应该怎么办呢？
![图2](https://img-blog.csdnimg.cn/20200814092206807.png#pic_center)
对了，跳至下一行不就行了吗？下一行列需要加 $1$ ，行就变成 $1$ 。如果，出现这种情况，又怎么办呢？就是递归至第 $5$ 行第 $1$ 列时，又该怎么办呢？很容易想出来，若递归至第 $5$ 行第 $1$ 列时，前面的 $16$ 个方格固然已经填好，所以我们只要加以判断即可。首先我们根据方格里的条件进行判断。若不满足条件， $return;$ 。然后判断已经给我们的第 $x$ 行 $y$ 列是不是 $1$ 。如果上面条件全部满足，就输出。如此的简单！
```cpp
	if(y>4){
		search_dfs(x+1,1);
		return;
	}
	if(x>4){
		int sum1,sum2;
		sum1=sum2=0;//对角线
		for(int i=1;i<=4;i++){
			sum1+=a[i][i];//左上到右下，行列的数值相等
			sum2+=a[5-i][i];//左下到右上，行+列=5
		}
		if(sum1!=34||sum2!=34)return;//不满足条件，退出
		for(int i=1;i<=3;i+=2)for(int j=1;j<=3;j+=2){//顶点的四个方格的左上角坐标
			int sum=0;
			for(int k=0;k<=1;k++){
				for(int l=0;l<=1;l++){
					sum+=a[i+k][j+l];//加上和
				}
			}
				if(sum!=34)return;//不满足条件，退出
		}
		if(a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34)return;//中间的正方形
		if(a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34)return;//顶点的四个方格
		if(a[h][l]!=1)return;//给定的行和列
		for(int i=1;i<=4;i++){
			for(int j=1;j<=4;j++){
				cout<<a[i][j]<<" ";//输出
			}
			cout<<endl;
		}
		cout<<endl;//别忘了每一个解空一行
		return;//结束，之后都是边界，不必再次循环
	}
```
## 2.3 剪枝
**注意 ！！！** 这种算法的时间复杂度是 $O(n^{2n^{2}})$，有超时的风险（不是有风险，是一定会超时。实测，如果删掉AC代码中的任意一种剪枝，都会超时，爆0QwQ）。所以肯定要优化啦。这种算法固然不可以最优性剪枝，那，我们就来可行性剪枝吧！

注意到原题目的“每行每列数值之和之和必须为 $34$ ”其实是，以行为例，若循环至该行的第 $4$ 个结点，只需要判断 $34$ 减去前 $3$ 个同行的数字有没有用过就可以了，所以当前节点的时间复杂度由 $O(n^{2})$ 降至 $O(1)$ 。
```cpp
	if(x==4){//行
		if(!b[34-a[1][y]-a[2][y]-a[3][y]]&&1<=34-a[1][y]-a[2][y]-a[3][y]<=16){
			if(34-a[1][y]-a[2][y]-a[3][y]>16||34-a[1][y]-a[2][y]-a[3][y]<1)return;//这个数大于16或者小于1，肯定不行
			a[x][y]=34-a[1][y]-a[2][y]-a[3][y];//算出节点数值
			b[34-a[1][y]-a[2][y]-a[3][y]]=true;//标记，已经被用过了
			search_dfs(x,y+1);//递归下一个节点
			b[34-a[1][y]-a[2][y]-a[3][y]]=false;//回溯
		}
		return;
	}
	if(y==4){//列
		if(!b[34-a[x][1]-a[x][2]-a[x][3]]&&1<=34-a[x][1]-a[x][2]-a[x][3]<=16){
			if(34-a[x][1]-a[x][2]-a[x][3]>16||34-a[x][1]-a[x][2]-a[x][3]<1)return;//这个数大于16或者小于1，肯定不行
			a[x][y]=34-a[x][1]-a[x][2]-a[x][3];//算出节点数值
			b[34-a[x][1]-a[x][2]-a[x][3]]=true;//标记，已经被用过了
			search_dfs(x,y+1);//递归下一个节点
			b[34-a[x][1]-a[x][2]-a[x][3]]=false;//回溯
		}
		return;
	}
```
我们还注意到中间的 $2×2$ 的方格，因为 第 $3$ 列第 $3$ 行是最晚确定下来的，所以他的操作也可以像行和列的操作一样。同时观察到第 $2$ 列第 $2$ 行也是左上角 $2×2$ 的方格中最晚确定的格子，所以，我们也可以同样采用行和列的操作。代码就不做多的解释了，总之与前面一样。
```cpp
	if(x==3&&y==3){
		if(!b[34-a[2][2]-a[3][2]-a[2][3]]&&1<=34-a[2][2]-a[3][2]-a[2][3]<=16){
			if(34-a[2][2]-a[3][2]-a[2][3]>16||34-a[2][2]-a[3][2]-a[2][3]<1)return;
			a[x][y]=34-a[2][2]-a[3][2]-a[2][3]; 
			b[34-a[2][2]-a[3][2]-a[2][3]]=true;
			search_dfs(x,y+1);
			b[34-a[2][2]-a[3][2]-a[2][3]]=false;
		}
		return;
	}
	if(x==2&&y==2){
		if(!b[34-a[1][1]-a[2][1]-a[1][2]]&&1<=34-a[1][1]-a[2][1]-a[1][2]<=16){
			if(34-a[1][1]-a[2][1]-a[1][2]>16||34-a[1][1]-a[2][1]-a[1][2]<1)return;
			a[x][y]=34-a[1][1]-a[2][1]-a[1][2];
			b[34-a[1][1]-a[2][1]-a[1][2]]=true;
			search_dfs(x,y+1);
			b[34-a[1][1]-a[2][1]-a[1][2]]=false;
		}
		return;
	}
```

# 3 AC代码

```cpp
#include<iostream>
using namespace std;
int a[7][7],b[20],h,l;
void search_dfs(int x,int y){
	if(y>4){
		search_dfs(x+1,1);
		return;
	}
	if(x>4){
		int sum1,sum2;
		sum1=sum2=0;
		for(int i=1;i<=4;i++){
			sum1+=a[i][i];
			sum2+=a[5-i][i];
		}
		if(sum1!=34||sum2!=34)return;
		for(int i=1;i<=3;i+=2)for(int j=1;j<=3;j+=2){
			int sum=0;
			for(int k=0;k<=1;k++){
				for(int l=0;l<=1;l++){
					sum+=a[i+k][j+l];
				}
			}
				if(sum!=34)return;
		}
		if(a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34)return;
		if(a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34)return;
		if(a[h][l]!=1)return;
		for(int i=1;i<=4;i++){
			for(int j=1;j<=4;j++){
				cout<<a[i][j]<<" ";
			}
			cout<<endl;
		}
		cout<<endl;
		return;
	}
	if(x==4){
		if(!b[34-a[1][y]-a[2][y]-a[3][y]]&&1<=34-a[1][y]-a[2][y]-a[3][y]<=16){
			if(34-a[1][y]-a[2][y]-a[3][y]>16||34-a[1][y]-a[2][y]-a[3][y]<1)return;
			a[x][y]=34-a[1][y]-a[2][y]-a[3][y];
			b[34-a[1][y]-a[2][y]-a[3][y]]=true;
			search_dfs(x,y+1);
			b[34-a[1][y]-a[2][y]-a[3][y]]=false;
		}
		return;
	}
	if(y==4){
		if(!b[34-a[x][1]-a[x][2]-a[x][3]]&&1<=34-a[x][1]-a[x][2]-a[x][3]<=16){
			if(34-a[x][1]-a[x][2]-a[x][3]>16||34-a[x][1]-a[x][2]-a[x][3]<1)return;
			a[x][y]=34-a[x][1]-a[x][2]-a[x][3];
			b[34-a[x][1]-a[x][2]-a[x][3]]=true;
			search_dfs(x,y+1);
			b[34-a[x][1]-a[x][2]-a[x][3]]=false;
		}
		return;
	}
	if(x==3&&y==3){
		if(!b[34-a[2][2]-a[3][2]-a[2][3]]&&1<=34-a[2][2]-a[3][2]-a[2][3]<=16){
			if(34-a[2][2]-a[3][2]-a[2][3]>16||34-a[2][2]-a[3][2]-a[2][3]<1)return;
			a[x][y]=34-a[2][2]-a[3][2]-a[2][3]; 
			b[34-a[2][2]-a[3][2]-a[2][3]]=true;
			search_dfs(x,y+1);
			b[34-a[2][2]-a[3][2]-a[2][3]]=false;
		}
		return;
	}
	if(x==2&&y==2){
		if(!b[34-a[1][1]-a[2][1]-a[1][2]]&&1<=34-a[1][1]-a[2][1]-a[1][2]<=16){
			if(34-a[1][1]-a[2][1]-a[1][2]>16||34-a[1][1]-a[2][1]-a[1][2]<1)return;
			a[x][y]=34-a[1][1]-a[2][1]-a[1][2];
			b[34-a[1][1]-a[2][1]-a[1][2]]=true;
			search_dfs(x,y+1);
			b[34-a[1][1]-a[2][1]-a[1][2]]=false;
		}
		return;
	}
	for(int i=1;i<=16;i++){
		if(b[i])continue;
		b[i]=true;
		a[x][y]=i;
		search_dfs(x,y+1);
		b[i]=false;
	}
}
int main(){
	cin>>h>>l;
	search_dfs(1,1);
	return 0;
}
```
# 4 后记
可能是因为空间太小吧，样例答案只给了两种，实际有 $216$ 种。由于篇幅原因这里就不一一枚举了。在这里还有一种思路，后续可能会上传。

选自本人[CSDN博客](https://editor.csdn.net/md?articleId=107927509)。

---

## 作者：kpl000 (赞：3)

//
** 暴搜**一波+特判+一点点小技巧






  
  
  



```cpp
//
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
bool use[20];
int fil[10][10], x, y;
void prin() {
  for (int i = 1; i <= 4; i++) {
    for (int j = 1; j <= 4; j++) {
      printf ("%d", fil[i][j]);
      if (j < 4) printf (" ");
    }
    printf ("\n");
  }
  printf ("\n");
}
bool Judge (int x, int y, int s) {
  bool flag = 1;
  int ans = s;
  for (int i = 4; ans += fil[i][y], i; i--)
    if (! fil[i][y] && i != x) {flag = 0; break;}
  if (flag && ans != 34) return 0;
  flag = 1, ans = s;
  for (int i = 4; ans += fil[x][i], i; i--)
    if (! fil[x][i] && i != y) {flag = 0; break;}
  if (flag && ans != 34) return 0;
  if (x == y) {
    flag = 1, ans = s;
    for (int i = 4; ans += fil[i][i], i; i--)
      if (! fil[i][i] && i != y) {flag = 0; break;}
    if (flag && ans != 34) return 0;
  }
  if (x + y == 5) {
    flag = 1, ans = s;
    for (int i = 4; ans += fil[i][5 - i], i; i--)
      if (! fil[i][5 - i] && i != x) {flag = 0; break;}
    if (flag && ans != 34) return 0;
  }
  int sx = 0, sy = 0;
  flag = 1, ans = s;
  sx = (x - 1) / 2 * 2 + 1, sy = (y - 1) / 2 * 2  + 1;
  for (int i = sx; i <= sx + 1; i++)
    for (int j = sy; j <= sy + 1; j++) {
      if (! fil[i][j] && (i != x || j != y)) {flag = 0; break;}
      ans += fil[i][j];
    }
  if (flag && ans != 34) return 0;
  flag = 1, ans = s;
  if ((x == 1 || x == 4) && (y == 1 || y == 4)) {
    for (int i = 1; i < 5 && flag; i += 3)
      for (int j = 1; j < 5; j += 3) {
    ans += fil[i][j];
    if (! fil[i][j] && (i != x || j != y)) {flag = 0; break;}
      }
    if (flag && ans != 34) return 0;
  }
  flag = 1, ans = s;
  if (x >= 2 && x <= 3 && y >= 2 && y <= 3) {
    for (int i = 2; i <= 3; i++)
      for (int j = 2; j <= 3; j++) {
    ans += fil[i][j];
    if (! fil[i][j] && (i != x || j != y)) {flag = 0; break;}
      }
    if (flag && ans != 34) return 0;
  }
  return 1;
}
void dfs (int x, int y) {
  if (y > 4) y = 1, x ++;
  if (x > 4) {prin(); return;}
  if (fil[x][y] == 1)
    dfs (x, y + 1);
  else
    for (int i = 1; i <= 16; i++)
      if (! use[i] && Judge (x, y, i))
    use[i] = 1, fil[x][y] = i, dfs (x, y + 1), fil[x][y] = 0, use[i] = 0;
}
int main()
{
  scanf ("%d %d", &x, &y);
  fil[x][y] = 1, use[1] = 1;
  dfs (1, 1);
  return 0;
}
```

---

## 作者：Mevinsp (赞：2)

~~这道题就是一个裸的暴搜我还是写了这么久QAQ~~

因为题目信息给的太多，4*4以及很多和要为34，剪枝很好剪，我就直接开挂对每个位置特判一下。比如说在(1,4)的时候检查第一行是否为34，在(1,4)时检查第一列的和和对角线的和。然后在调试的时候我发现，对于样例中(1,1)为1的情况 第一列会是这样：

```
第一次:1 2 2 X 返回
第二次:1 2 3 X 返回

```
我觉得我是该做点什么来阻止这愚蠢的行为了。于是我在每个要求的区域和为34的第三个点特判，先把前两个的和算出来，（当前要填的为i）

```
i=max(i,34-mx[1][2]-mx[1][1]-16);
if(i>16) return ;
```

意思应该很好懂，这是(1,3)处的特判。然后我又发现这一列的和明明前三个就已经大于34了还在搜, = =,真是看不下去了。于是对于每个搜到的点计算列之和还有行之和，大于34直接return。看来效果好像不错的样子，最慢的一个点0.2s。

# 代码

（放大字体就为了让你们注意到QAQ）

```
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

int I,J,sum,used[20];
int mx[5][5],cnt=0;

void dfs(int x,int y)
{
    if(x==5&&y==1)
    {
        cnt++;
        for(int i=1;i<=4;printf("\n"),i++)
          for(int j=1;j<=4;j++)
            printf("%d ",mx[i][j]);
        printf("\n");
        return ;
    }
    int l=2,r=16;
    if(x==I&&y==J) l=r=1;
    for(int i=l;i<=r;i++)
    {
//      printf("%d %d %d\n",cnt,x,y);
        if(y==4) {//每行
            sum=0;
            for(int j=1;j<4;j++)
              sum+=mx[x][j];
            sum+=i;
            if(sum>34||sum+16<34) return;
            else if(sum!=34) i=34-(sum-i);
        }
        else{
            sum=0;
            for(int j=1;j<y;j++)
                sum+=mx[x][j];sum+=i;
            if(sum>34) return ;
        }
        if(x==4){//每列 
            sum=0;
            for(int j=1;j<4;j++)
              sum+=mx[j][y];
            sum+=i;
            if(sum>34||sum+16<34) return;
            else if(sum!=34) i=34-(sum-i);
        }
        else{
            sum=0;
            for(int j=1;j<x;j++)
                sum+=mx[j][y];sum+=i;
            if(sum>34) return ;
        }
        if(x%2==0&&y%2==0){//角落格子 
            sum=mx[x-1][y-1]+mx[x-1][y]+mx[x][y-1]+i;
            if(sum>34||sum+16<34) return ;
            else if(sum!=34) i=34-(sum-i);
        }
        if(x==1&&y==3){
            i=max(i,34-mx[1][2]-mx[1][1]-16);
            if(i>16) return ;
        }
        else if(x==2&&y==1){
            i=max(i,34-mx[1][1]-mx[1][2]-16);
            if(i>16) return ;
        }
        else if(x==2&&y==3){
            i=max(i,34-16-mx[1][3]-mx[1][4]);
            i=max(i,34-16-mx[2][1]-mx[2][2]);
            if(i>16) return ;
        }
        else if(x==3&&y==2){
            i=max(i,34-16-mx[1][4]-mx[2][3]);
            if(i>16) return ;
        }
        else if(x==3&&y==3){//中间一坨 
            sum=mx[2][2]+mx[2][3]+mx[3][2]+i;
            if(sum>34||sum+16<34) return ;
            else if(sum!=34) i=34-(sum-i);
            i=max(i,34-16-mx[1][1]-mx[2][2]);
            i=max(i,34-16-mx[3][1]-mx[3][2]);
            if(i>16) return ;
        }
        else if(x==4&&y==1){
            i=max(i,34-16-mx[3][1]-mx[3][2]);
            if(i>16) return ;
        }
        else if(x==4&&y==3){
            i=max(i,34-16-mx[3][3]-mx[3][4]);
            if(i>16) return ;
        }
        else if(x==4&&y==1){//左下对角线 
            sum=mx[1][4]+mx[2][3]+mx[3][2]+i;
            if(sum>34||sum+16<34) return ;
            else if(sum!=34) i=34-(sum-i);
        }
        else if(x==4&&y==4){
            sum=mx[1][1]+mx[2][2]+mx[3][3]+i;
            if(sum>34||sum+16<34) return ;
            else if(sum!=34) i=34-(sum-i);
            sum=mx[1][1]+mx[1][4]+mx[4][1]+i;
            if(sum>34||sum+16<34) return ;
            else if(sum!=34) i=34-(sum-i);
        }
        if(used[i]) continue;
        mx[x][y]=i;
        used[i]=1;
        int nx=x,ny=y+1;
        if(ny==5) nx=x+1,ny=1;
        dfs(nx,ny);
        used[i]=0;
        mx[x][y]=0;
    }
}

int main()
{
    scanf("%d%d",&I,&J);
    dfs(I,J);
    return 0;
}
```
PS:抄袭代码可耻！（不过我这个可不能AC哦，改了一处/xyx）

---

## 作者：李林恺 (赞：2)

这是一道深搜好题，主要解法看代码 
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[11][11],f[101],g[11],d=0;
void s(int x,int y){
	if(x==4&&y>4){ //目标解输出 
		for(int i=1;i<=4;i++){
			for(int j=1;j<=4;j++) if(j==4) cout<<a[i][j]<<endl; else cout<<a[i][j]<<" ";
		}
		cout<<endl;
	}
	if(y>4){//下一行 
		int z=0;
		for(int i=1;i<=4;i++) z+=a[x][i];
		if(z==34) s(x+1,1);//剪枝 
		return;
	}
	if(x==n&&y==m){//是1就跳过 
		s(x,y+1);
		return;
	}
	for(int i=2;i<=16;i++) if(f[i]==0){//未使用 
		if(x==4){//每条垂直线上四个格子中的数字是否等于34
			int z=i;
			for(int j=1;j<=3;j++) z+=a[j][y];
			if(z!=34) continue;
		}
		if(x==4&&y==4){//每四个角落上的数字是否等于34
			int z=i+a[1][1]+a[4][1]+a[1][4];
			if(z!=34) continue;
		}
		if(x==4&&y==1){//右上角到左下角的数字是否等于34
			int z=i+a[1][4]+a[2][3]+a[3][2];
			if(z!=34) continue;
		}
		if(x==4&&y==4){//每左上角到右下角的数字是否等于34
			int z=i+a[1][1]+a[2][2]+a[3][3];
			if(z!=34) continue;
		}
		if(x==3&&y==3){//最中间的2×2方格中的数字是否等于34
			int z=i+a[2][2]+a[2][3]+a[3][2];
			if(z!=34) continue;
		}
		if(x==2&&y==2){//左上角的数字是否等于34
			int z=i+a[1][1]+a[1][2]+a[2][1];
			if(z!=34) continue;
		}
		if(x==2&&y==4){//右上角的数字是否等于34
			int z=i+a[1][3]+a[1][4]+a[2][3];
			if(z!=34) continue;
		}
		if(x==4&&y==2){//左下角的数字是否等于34
			int z=i+a[3][1]+a[3][2]+a[4][1];
			if(z!=34) continue;
		}
		if(x==4&&y==4){//右下角的数字是否等于34
			int z=i+a[3][3]+a[3][4]+a[4][3];
			if(z!=34) continue;
		}
		f[i]=1;//标记 
		a[x][y]=i;//标记 
		s(x,y+1);
		f[i]=0;//清除标记 
	}
}
int main(){
    cin>>n>>m;
    a[n][m]=1;//第n行和第m列的格子放数字1
    f[1]=1;//标记1为使用过 
    s(1,1);//深搜 
    return 0;
}
```


---

## 作者：Maxwang (赞：1)

### Tips:

本题样例输出较多，1000 多行，所以题目没有给出完整的样例：

 [被样例困扰的小伙伴点这](https://www.luogu.com.cn/paste/rx2i4njq)

### 基本算法

首先我们读题，在题目给的表格里可以明确看出：

$A_{i,j}$ 表示第 $i$ 行第 $j$ 列位置的数。

我看题解区有很多 x,y 和 i,j 不分的大佬。

简单来看就是（图片丑陋）

![](https://cdn.luogu.com.cn/upload/image_hosting/f1b7thm6.png)

或者：
|  | 1 | 2 | 3 | 4 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $f_{1,1}$ | $f_{1,2}$ | $f_{1,3}$ | $f_{1,4}$ | 
| 2 | $f_{2,1}$ | $f_{2,2}$ | $f_{2,3}$ | $f_{2,4}$ 
| 3 | $f_{3,1}$ | $f_{3,2}$ | $f_{3,3}$ | $f_{3,4}$ 
| 4 | $f_{4,1}$ | $f_{4,2}$ | $f_{4,3}$ | $f_{4,4}$ 


$f_{i,j}$ 即对应 `f[i][j]` 即可。

这类题除了对剪枝的操控和对搜索策略的把控，对数组下标的明确也是容易出错的地方之一，特别是这种地图或者矩阵的题目，分清哪一个变量是行，哪个是列是非常重要的。

### 搜索与剪枝
搜索策略非常显而易见，直接填写数字即可

#### 未经优化
先暴力搜索枚举出每一种矩阵中数字的填写方法，最后判断是否符合题目的若干个要求。

我们搜索的顺序是：（数字表示顺序）
```plain
0(1,0)
|
1  -> 2  -> 3  -> 4 (1,4)

5  -> 6  -> 7  -> 8 (2,4)

9  -> 10 -> 11 -> 12(3,4)

13 -> 14 -> 15 -> 16(4,4)
```

搜索树巨大，显然无法通过。

但是我们可以借此完成判断函数：
```cpp
inline bool final_check(void)
{
	//A
	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;
	
	//B
	if(a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
	if(a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
	if(a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
	if(a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
	
	//C
	if(a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	//D
	if(a[4][1] + a[4][2] + a[4][3] + a[4][4] != 34)return 0;
	
	//E
	if(a[1][4] + a[2][4] + a[3][4] + a[4][4] != 34)return 0;
	
	//F
	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;
	
	//G
	if(a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}
```
这个判断函数以后剪枝的时候还会用到，数组下标和题目中所给出的一致，方便分析行列关系。

### 剪枝
我们可以显然发现，当之前的状态是不合法的，比如左上角四个数都不合法，那么之后是不可能合法的，所以直接剪掉。

由于是在过程中判断的，所以必定有一些条件没有达到可以满足的条件。

比如说没填全这一行就不能判断这一行的和，这很好理解吧。

另外，如果之前是合法的，我们也不需要再判断之前的条件了，~~（我看题解区大佬有的重复计算了）~~。

### 条件判断
这些条件判断完全是在之前的判断函数中修改的
```cpp
inline bool during_work_check(int x,int y)
{
	//A
	//四个角最后才能取到 
//	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;

	//B
	if(x == 2 && y == 2 && a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
	if(x == 2 && y == 4 && a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
	if(x == 4 && y == 2 && a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
//	if((x == 4 && y == 4) && a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
// 最后一个肯定在路程中取不到，不用了 

	//C
	if(x == 3 && y == 3 && a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	for(rint i = 1;i <= 3;i++)
	{
		//D  行 
		//可以进行判断的条件为：x 取到 i 并且取完该行  
		if(x >= i && y == 4 && a[i][1] + a[i][2] + a[i][3] + a[i][4] != 34)return 0;
		
		//E  列 
		//可以进行判断的条件为：y 取到 i 并且取完该列 
		if(y >= i && x == 4 && a[1][i] + a[2][i] + a[3][i] + a[4][i] != 34)return 0;
		
		if(x < i && y < i) break;
	}
	
	//F 
	// \ 方向对角线  
	//最后才能确定右下角，所以中途无需判断 
//	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;

	//G
	//  / 方向对角线 
	//  取到最后一行第一个即可 
	if(x == 4 && y == 1 && a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}
```
至于之前有大佬说的判断坐标能不能取到的问题：
因为条件表达式 `&&` 是短路的，把判断能不能满足条件的写在前面更优秀，因为前面的不满足直接就 GG 了，不会判断后面的了，这就是先排除小可能性的策略，这可能只是个 if 语句但是这种思想是很好的习惯，可以大幅减小常数。

### 最后的判断
```cpp
inline bool final_check(void)
{
	//A
	//四角 
	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;
	
	//B
	//只判断右下角的即可 
//	if(a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
//	if(a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
//	if(a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
	if(a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
	
	//C
	//中间格子无需判断 
//	if(a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	//D
	//第四行 
	if(a[4][1] + a[4][2] + a[4][3] + a[4][4] != 34)return 0;
	
	//E
	//第四列 
	if(a[1][4] + a[2][4] + a[3][4] + a[4][4] != 34)return 0;
	
	//F
	//左上到右下的对角线 
	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;
	
	//G
	//左下到右上的对角线，早已判断过了 
//	if(a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}
```
把最后一个数确定才能确定的可变因素判断完即可。

### 完整代码（内附注释）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

//快读快写
#define rint register int
#define isnum(x) ('0' <= (x) && (x) <= '9')
template<typename tint>
inline void readint(tint& x) {
	int f = 1; char ch = getchar(); x = 0;
	for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1;
	for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0';
	x *= f;
}
template<typename tint>
void write(tint x)        
{        
    if(x < 0) {        
        putchar('-');        
        x = -x;        
    }        
    if(x > 9)        
        write(x/10);        
    putchar(x % 10 + '0');        
    return;        
}        

int a[10][10];//地图
int vis[20];//数字标记
int xx,yy;

inline bool during_work_check(int x,int y)
{
	//A
	//四个角最后才能取到 
//	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;

	//B
	if(x == 2 && y == 2 && a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
	if(x == 2 && y == 4 && a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
	if(x == 4 && y == 2 && a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
//	if((x == 4 && y == 4) && a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
// 最后一个肯定在路程中取不到，不用了 

	//C
	if(x == 3 && y == 3 && a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	for(rint i = 1;i <= 3;i++)
	{
		//D  行 
		//可以进行判断的条件为：x取到i 并且取完该行  
		if(x >= i && y == 4 && a[i][1] + a[i][2] + a[i][3] + a[i][4] != 34)return 0;
		
		//E  列 
		//可以进行判断的条件为：y取到i 并且取完该列 
		if(y >= i && x == 4 && a[1][i] + a[2][i] + a[3][i] + a[4][i] != 34)return 0;
		
		if(x < i && y < i) break;
	}
	
	//F 
	// \ 方向对角线  
	//最后才能确定右下角，所以中途无需判断 
//	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;

	//G
	//  / 方向对角线 
	//  取到最后一行第一个即可 
	if(x == 4 && y == 1 && a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}

inline bool final_check(void)
{
	//A
	//四角 
	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;
	
	//B
	//只判断右下角的即可 
//	if(a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
//	if(a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
//	if(a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
	if(a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
	
	//C
	//中间格子无需判断 
//	if(a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	//D
	//第四行 
	if(a[4][1] + a[4][2] + a[4][3] + a[4][4] != 34)return 0;
	
	//E
	//第四列 
	if(a[1][4] + a[2][4] + a[3][4] + a[4][4] != 34)return 0;
	
	//F
	//左上到右下的对角线 
	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;
	
	//G
	//左下到右上的对角线，早已判断过了 
//	if(a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}

//集成化写代码有利于调试（当然也看个人喜好）
inline void print(void)
{
	for(rint i = 1;i <= 4;i++)
	{
		for(rint j = 1;j <= 4;j++)
		{
			write(a[i][j]);
			putchar(' ');
		}
		puts("");
	}
	puts("");
	return;
}

void dfs(int x,int y)
{
	if(x == 4 && y == 4)
	{
		if(final_check() == 0) return;
		
		print();
		return; 
	}
	if(during_work_check(x,y) == 0)
		return;
	
	for(rint i = 2;i <= 16;i++)
	{
		if(vis[i]) continue;//取过就不取
		rint tarx,tary;
		if(y == 4)//取到一行末尾 
		{
			tarx = x + 1;
			tary = 1;
		}
		else//行中
		{
			tarx = x;
			tary = y + 1;
		}
		if(a[tarx][tary])
		{
        //之前有数就不用确定数了，直接一次跳进下一个
			dfs(tarx,tary);
			break;
		}
		else//选个数
		{
			a[tarx][tary] = i; 
			vis[i] = 1;
		
			dfs(tarx,tary); 
			
        //回溯的时候一定把数字还原，把标记也还原
			vis[i] = 0;
			a[tarx][tary] = 0;
		}
		
	} 
}

int main()
{
	readint(xx),readint(yy);
	memset(a,0,sizeof(a));
	memset(vis,0,sizeof(vis));
	vis[1] = 1;
	a[xx][yy] = 1;
	dfs(1,0);
	return 0;
}
```

---

## 作者：少年如斯 (赞：1)

一道很明显的搜索题；

由于前几天写了虫食算的搜索；学到了一些剪枝优化的方法:

剪枝1：以规则1为例，若四个数都已知且A11+A14+A41+A44!=34则肯定不可以的；

剪枝2：~~，若已知四个数的三个且34-(A11+A14+A41+A44) 这个数已经用过了则不可以；

这里所有A初始化和回溯都赋值为0；

就这里了。。。。。。。。。。

附代码..................................


```cpp
#include<bits/stdc++.h> 
using namespace std; 
bool txt[20]; int b[5][5];
struct node{int a[5][5];}e[100]; 
int a[5][5],tot,x[20],y[20],pop,tvt;
bool cmp(node x,node y)
{
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
            if(x.a[i][j]!=y.a[i][j])
                return x.a[i][j]<y.a[i][j];
}
bool jianzhi()
{
    if((b[1][1]&b[1][4]&b[4][1]&b[4][4])==1&&a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34)    return false;
    if((b[2][2]&b[2][3]&b[3][2]&b[3][3])==1&&a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34)    return false;
    if((b[1][1]&b[1][2]&b[2][1]&b[2][2])==1&&a[1][1]+a[1][2]+a[2][1]+a[2][2]!=34)    return false;
    if((b[1][3]&b[1][4]&b[2][3]&b[2][4])==1&&a[1][3]+a[1][4]+a[2][3]+a[2][4]!=34)    return false;
    if((b[3][1]&b[3][2]&b[4][1]&b[4][2])==1&&a[3][1]+a[3][2]+a[4][1]+a[4][2]!=34)    return false;
    if((b[3][3]&b[3][4]&b[4][3]&b[4][4])==1&&a[3][3]+a[3][4]+a[4][3]+a[4][4]!=34)    return false;
    if((b[1][1]&b[2][2]&b[3][3]&b[4][4])==1&&a[1][1]+a[2][2]+a[3][3]+a[4][4]!=34)    return false;
    if((b[1][4]&b[2][3]&b[3][2]&b[4][1])==1&&a[1][4]+a[2][3]+a[3][2]+a[4][1]!=34)    return false;
    for(int i=1;i<=4;i++)
    {
        if((b[i][1]&b[i][2]&b[i][3]&b[i][4])&&a[i][1]+a[i][2]+a[i][3]+a[i][4]!=34)    return false;
        if((b[1][i]&b[2][i]&b[3][i]&b[4][i])&&a[1][i]+a[2][i]+a[3][i]+a[4][i]!=34)    return false;
    }
    if((b[1][1]+b[1][4]+b[4][1]+b[4][4])==3&&txt[34-(a[1][1]+a[1][4]+a[4][1]+a[4][4])]==true)    return false;
    if((b[2][2]+b[2][3]+b[3][2]+b[3][3])==3&&txt[34-(a[2][2]+a[2][3]+a[3][2]+a[3][3])]==true)    return false;
    return true;
}
bool work() 
{ 
    if(a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34) return false; 
    if(a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34) return false; 
    if(a[1][1]+a[1][2]+a[2][1]+a[2][2]!=34) return false; 
    if(a[1][3]+a[1][4]+a[2][3]+a[2][4]!=34) return false; 
    if(a[3][1]+a[3][2]+a[4][1]+a[4][2]!=34) return false; 
    if(a[3][3]+a[3][4]+a[4][3]+a[4][4]!=34) return false;
    if(a[1][1]+a[2][2]+a[3][3]+a[4][4]!=34)    return false;
    if(a[1][4]+a[2][3]+a[3][2]+a[4][1]!=34)    return false;
    for(int i=1;i<=4;i++)
    { 
        if(a[i][1]+a[i][2]+a[i][3]+a[i][4]!=34) return false; 
        if(a[1][i]+a[2][i]+a[3][i]+a[4][i]!=34) return false; 
    }
    return true; 
}
void dfs(int cnt) 
{
    for(int i=2;i<=16;i++)
    {
        if(!txt[i]) 
        { 
            a[x[cnt]][y[cnt]]=i;
            txt[i]=true; b[x[cnt]][y[cnt]]=1; 
            if(!jianzhi())
            {
                  txt[i]=false; 
                a[x[cnt]][y[cnt]]=b[x[cnt]][y[cnt]]=0;
                continue;
            }
            if(cnt==tvt) 
            {
                if(work()) 
                {
                    ++pop;
                    for(int j=1;j<=4;j++)
                    {
                        for(int k=1;k<=4;k++)
                            printf("%d ",a[j][k]);
                        printf("\n");
                    }
                    cout<<endl;
                }
            }
            else dfs(cnt+1);
              txt[i]=false; a[x[cnt]][y[cnt]]=b[x[cnt]][y[cnt]]=0;
        } 
    } 
} 
int main() 
{
//    freopen("magic.in","r",stdin);
//    freopen("magic.out","w",stdout);
    int x0,y0,i,j,k=0; 
    scanf("%d%d",&x0,&y0); 
    a[x0][y0]=1; b[x0][y0]=1;
    for(i=1;i<=4;i++) 
        for(j=1;j<=4;j++)
        {
            if(i==x0&&j==y0) ;
            else x[++tvt]=i,y[tvt]=j;
        }
    txt[0]=txt[1]=true;
    dfs(1);     
}

```

---


# 切孔机

## 题目描述

司令部的助理经常需要在大纸上切割各种形状的孔。他们刚刚购买了一台新的切孔机，该机比他们以前使用的要方便自由的多。他们想编写一个程序来求出经过一系列复杂的切孔后会发生什么情况，他们特别想知道纸上形成的孔的数量。

下图列出了经过切割后形成的一些图样。

![](https://cdn.luogu.com.cn/upload/image_hosting/tbek5h3m.png)


## 样例 #1

### 输入

```
4
0 1 1 1
1 1 1 0
1 0 0 0
0 0 0 1
```

### 输出

```
1
```

# 题解

## 作者：Leap_Frog (赞：17)

# P1299切孔机（题解）

**PS:**  
人生中的第一道黑题。  
发一个题解纪念一下。

***

**解题算法：**  
- 离散化
- 广度优先搜索,bfs

***

**解题思路：**  
1. 首先先把读入的x,y离散化
2. 把所有的切痕记录下来
3. bfs把孔外的格子找出来
4. 数有几个格子。（一个图中有几个连通块）

***

**我的代码：**  
- xx,yy:表示方向。
- point:表示点。
	- number:第几次切
    - x,y:切的点的坐标
- picture:记录切痕
	- can_go:一个点可以不可以向上下左右走(0:上,1:下,2:左:右)
    - visit:一个点是不是孔中的点(0:不是,1:是)
- cmpx,cmpy:离散化时用
- cmp:切的次数从小到大，第一个切点尽量左上
- ready:读入
- lisan:离散化
- build_wall:把所有切痕记录下来（2）
- cut_paper:剪纸，把孔外的格子记录下来（3）
- count_hole:数有几个洞（4）

***

**上代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll xx[4]={-1,1,0,0},yy[4]={0,0,-1,1};
struct point
{
	ll number,x,y;
	point() {}
	point(ll a,ll b):x(a),y(b) {}
};
struct picture
{
	bool can_go[4],visit;
	picture()
	{
		can_go[0]=can_go[1]=can_go[2]=can_go[3]=1;
		visit=1;
	}
};
ll n;
point a[205];
picture b[205][205];
inline bool cmpx(point a,point b)
{
	return a.x<b.x;
}
inline bool cmpy(point a,point b)
{
	return a.y<b.y;
}
inline bool cmp(point a,point b)
{
	if(a.number!=b.number) return a.number<b.number;
	if(a.x!=b.x) return a.x<b.x;
	return a.y<b.y;
}
inline void ready()
{
	scanf("%lld",&n);
	for(int i=1;i<=n*2;i++)
	{
		a[i].number=(i+1)/2;
		scanf("%lld%lld",&a[i].x,&a[i].y);
	}
}
inline void lisan()
{
	ll now,u;
	now=-10000005;
	u=0;
	sort(a+1,a+n*2+1,cmpx);
	for(ll i=1;i<=n*2;i++)
	{
		if(a[i].x!=now)
		{
			now=a[i].x;
			u++;
			a[i].x=u;
		}
		else a[i].x=u;
	}
	now=-10000005;
	u=0;
	sort(a+1,a+n*2+1,cmpy);
	for(ll i=1;i<=n*2;i++)
	{
		if(a[i].y!=now)
		{
			now=a[i].y;
			u++;
			a[i].y=u;
		}
		else a[i].y=u;
	}
}
inline void build_wall()
{
	sort(a+1,a+n*2+1,cmp);
	for(ll i=1;i<=n;i++)
	{
		point s=a[i*2-1],e=a[i*2];
		for(ll j=s.x+1;j<=e.x;j++)
		{
			b[j][s.y].can_go[3]=0;
			b[j][s.y+1].can_go[2]=0;
		}
		for(ll j=s.y+1;j<=e.y;j++)
		{
			b[s.x][j].can_go[1]=0;
			b[s.x+1][j].can_go[0]=0;
		}
	}
}
inline void cut_paper()
{
	queue<point>q;
	q.push(point(0,0));
	while(!q.empty())
	{
		point now=q.front();
		q.pop();
		for(int i=0;i<4;i++)
		{
			ll x=now.x+xx[i],y=now.y+yy[i];
			if(x<0||x>200||y<0||y>200) continue;
			if(!b[x][y].visit) continue;
			if(!b[now.x][now.y].can_go[i]) continue;
			b[x][y].visit=0;
			q.push(point(x,y));
		}
	}
}
inline void bfs(ll dx,ll dy)
{
	queue<point>q;
	b[dx][dy].visit=0;
	q.push(point(dx,dy));
	while(!q.empty())
	{
		point now=q.front();
		q.pop();
		for(int i=0;i<4;i++)
		{
			ll x=now.x+xx[i],y=now.y+yy[i];
			if(x<0||x>200||y<0||y>200) continue;
			if(!b[x][y].visit) continue;
			b[x][y].visit=0;
			q.push(point(x,y));
		}
	}
}
inline ll count_hole()
{
	ll ans=0;
	for(ll i=0;i<=200;i++)
		for(ll j=0;j<=200;j++)
		{
			if(!b[i][j].visit) continue;
			ans++;
			bfs(i,j);
		}
	return ans;
}
int main()
{
	ready();
	lisan();
	build_wall();
	cut_paper();
	ll ans=count_hole();
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：hehezhou (赞：7)

这真的是一道大难（shui）题

思路：离散化+宽搜

把点的坐标离散一下，开【200】【200】模拟就好了。

先把纸挖掉，再数几个洞。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define get getchar()
ll read(){ //快读
	ll f=1,ans=0;
	char c=get;
	while(c>'9'|c<'0'&c!='-')c=get;
	if(c=='-'){
		f=-1;
		c=get;
	}
	while(c<='9'&c>='0')ans=(ans<<1)+(ans<<3)+c-'0',c=get;
	return ans*f;
}
struct data{
	ll n,x,y;
	data(ll a,ll b):x(a),y(b){}
	data(){}
}a[210];		//点
bool cmp1(data a,data b){
	return a.x<b.x;
}
bool cmp2(data a,data b){
	return a.y<b.y;
}
bool cmp3(data a,data b){
	if(a.n!=b.n)return a.n<b.n;
	if(a.x!=b.x)return a.x<b.x;
	return a.y<b.y;
}
#define up 0
#define down 1
#define left 2
#define right 3
ll f[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
struct pic{
	bool b[4],t;
	pic(){
		memset(this,1,sizeof(pic));
	}
}p[220][220];
queue<data>q;
int main(){
	ll n=read();
	for(int i=1;i<=2*n;i++){
		a[i].n=(i+1)>>1;
		a[i].x=read();
		a[i].y=read();
	}
	ll now,u;
	sort(a+1,a+(n<<1)+1,cmp1);//x离散化
	now=-10000000;
	u=0;
	for(int i=1;i<=2*n;i++){
		if(a[i].x!=now)now=a[i].x,a[i].x=++u;else a[i].x=u;
	}
	sort(a+1,a+(n<<1)+1,cmp2);//y离散化
	now=-10000000;
	u=0;
	for(int i=1;i<=2*n;i++){
		if(a[i].y!=now)now=a[i].y,a[i].y=++u;else a[i].y=u;
	}
	sort(a+1,a+1+n*2,cmp3);//建墙
	for(int i=1;i<=n;i++){
		data d1=a[(i<<1)-1],d2=a[i<<1];
		for(int j=d1.x+1;j<=d2.x;j++){
			p[j][d1.y].b[right]=0;
			p[j][d1.y+1].b[left]=0;
		}
		for(int j=d1.y+1;j<=d2.y;j++){
			p[d1.x][j].b[down]=0;
			p[d1.x+1][j].b[up]=0;
		}
	}
	q.push(data(0,0));
	while(q.size()){//挖纸
		data now=q.front();
		q.pop();
		for(int i=up;i<=right;i++){
			ll x=now.x+f[i][0];
			ll y=now.y+f[i][1];
			if((x>=220)|(x<0))continue;
			if((y>=220)|(y<0))continue;
			if(!p[x][y].t)continue;
			if(!p[now.x][now.y].b[i])continue;
			p[x][y].t=0;
			q.push(data(x,y));
		}
	}
	ll ans=0;
	for(int i=0;i<220;i++)//找洞
		for(int j=0;j<220;j++){
			if(!p[i][j].t)continue;
			ans++;
			p[i][j].t=0;
			q.push(data(i,j));
			while(q.size()){
				data now=q.front();
				q.pop();
				for(int ii=up;ii<=right;ii++){
					ll x=now.x+f[ii][0];
					ll y=now.y+f[ii][1];
					if((x>=220)|(x<0))continue;
					if((y>=220)|(y<0))continue;
					if(!p[x][y].t)continue;
					p[x][y].t=0;
					q.push(data(x,y));
				}
			}
			
		}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：夏色祭 (赞：7)

难度刷上来的吧。。。~~其实应该向xzz大佬学习:评入门啊~~


AC里面一堆打表的。。。https://www.luogu.org/record/show?rid=4916843 这个提交记录就是把n全部打出来，然后根据n打表。。然后除了我之外两个没用打表的大佬代码出奇的一致。。。


我还是来讲讲正确的做法吧。


首先要理解~~鬼畜的~~题意，连在一起的都只能算一个。


那么显然第一想法就是搜索。


首先先把除了洞以外的点遍历一遍，遇到墙就不要去。


然后对于找洞我们就要先判断出哪些点可以去哪些不可以，分类讨论。


1.
![图示](https://s1.ax1x.com/2018/01/21/pfU22q.png)


对于我用红笔圈着的那个点，即两个矩阵的相点不能去。还有把图倒过来，两个矩阵的交点不能去。


2.
![图示](https://s1.ax1x.com/2018/01/21/pfURx0.png)


我圈的的这一排点也是不能去的。把图逆时针旋转90°的那些点也不能去。


3.
![图示](https://s1.ax1x.com/2018/01/21/pfUIZF.png)


我圈的的这一排点也是能去的。把图逆时针旋转90°的那些点也能去。


4.
除上面这些特殊点外的普通点，能不能去就是我们遍历时有没有去这些点


然后在能跑的洞一个一个遍历下就行了。


注意起点和终点在同一个点的地方不是一个洞。


代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<queue>
#include<set>
#include<vector>
#include<map>
#define For(i,x,y) for (int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (int i=(x);i>=(y);i--)
#define cross(i,k) for (int i=first[k];i;i=last[i])
#define il inline
#define vd void
#define ll long long
#define N 110
#define maxn 2010
using namespace std;
il int read(){
    int x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
const int dx[4]={0,-1,0,1};
const int dy[4]={-1,0,1,0};
int n,h,t,x1,y1,x2,y2,ans,l[maxn*maxn],r[maxn*maxn];
bool mp[maxn][maxn],vis[maxn][maxn],b[maxn][maxn];
il int max(int x,int y){return x>y?x:y;}
il int min(int x,int y){return x<y?x:y;}
il vd bfs(){
    int h=0,t=1,i,j;
    l[1]=0,r[1]=0;
    vis[l[1]][r[1]]=1;
    while (h<t){
        h++;
        For(k,0,3){
            i=l[h]+dx[k],j=r[h]+dy[k];
            if (i<0||j<0||i>2001||j>2001) continue;
            if (mp[i][j]||vis[i][j]) continue;
            l[++t]=i,r[t]=j,vis[i][j]=1;
        }
    }
    For(i,1,2001)
        For(j,1,2001){
            if (!vis[i+1][j]&&!vis[i-1][j]&&!vis[i][j+1]&&!vis[i][j-1]){
                if (!vis[i+1][j-1]&&!vis[i-1][j+1]&&vis[i+1][j+1]&&vis[i-1][j-1]) vis[i][j]=1;
                if (vis[i+1][j-1]&&vis[i-1][j+1]&&!vis[i+1][j+1]&&!vis[i-1][j-1]) vis[i][j]=1;
            }
            else{
                if (!vis[i][j]&&vis[i-1][j]&&vis[i+1][j]) vis[i][j]=1;
                if (!vis[i][j]&&vis[i][j-1]&&vis[i][j+1]) vis[i][j]=1;
                else if (vis[i][j]&&!vis[i-1][j]&&!vis[i+1][j]) vis[i][j]=0;
                else if (vis[i][j]&&!vis[i][j-1]&&!vis[i][j+1]) vis[i][j]=0;
            }
        }
}
il vd bfs(int start_l,int start_r){
    h=0,t=1;
    int i,j;
    l[1]=start_l,r[1]=start_r;
    b[l[1]][r[1]]=1;
    while (h<t){
        h++;
        For(k,0,3){
            i=l[h]+dx[k],j=r[h]+dy[k];
            if (i<0||j<0||i>2001||j>2001) continue;
            if (vis[i][j]||b[i][j]) continue;
            l[++t]=i,r[t]=j,b[i][j]=1;
        }
    }
}
int main(){
    n=read();
    if (n<4){
        printf("0");
        return 0;
    }
    For(i,1,n){
        x1=read()+1001,y1=read()+1001,x2=read()+1001,y2=read()+1001;
        if (x1==x2){
            For(j,min(y1,y2),max(y1,y2)) mp[x1][j]=1;
        }
        else {
            For(j,min(x1,x2),max(x1,x2)) mp[j][y1]=1;
        }
    }
    bfs();
    For(i,0,2001)
        For(j,0,2001)
            if (!vis[i][j]&&!b[i][j]) {
                bfs(i,j);
                if (l[t]!=i&&r[t]!=j) ans++;
            }
    printf("%d",ans);
}
```

---

## 作者：Peter_Z (赞：6)

我太菜了看不懂前面几篇题解。。于是就来 ~~水~~ 写一发

### 写在前面：

需要点亮的技能：

1.离散化（即STL的sort unique lower_bound函数）

2.bfs标记连通块

### 题意解释：

~~我太蒻了，花了很久才看懂题qwq~~

大意就是，现在有一张可以看成无限大的纸，现在在上面切出了一些线段，这些线段包围出来的部分被切去了，原来的纸上就出现了一些孔。需要求出孔的总数。

### 解题思路：

求有多少个孔，一种比较好想的思路是把孔外的点都暴力bfs出来，再把没有搜到的点bfs一遍，求出剩下的连通块数量。

~~如果这么简单，那这道题感觉是橙题qwq~~

先看数据范围：
$n<=100, -1000<=x_1,x_2,y_1,y_2<=1000$

**发现这些线段的x y值竟然有负数？？？**

“当下标为负数、浮点数或较大的值时，考虑使用离散化。”

						——某不知名巨佬

我（蒟蒻）：离散化是什么QAQ。。瑟瑟发抖

巨佬：

离散化就是把一个序列$a_1,a_2,...,a_n$对应成$1,2,...,n$来减小数据范围，从而达到一些目的。

于是愉快地写完离散化之后，发现如果是一些矩形被切去，那么比较好处理（暴力把矩形内的点设为不可走，然后就是比较显然的bfs了），但是**此处竟然是线段？？**

我：(゜Д゜) 线段怎么办？？

巨佬：

不妨给每个点记录一个go数组，go[i][j][k]表示(i,j)这个点能不能向k方向走（我写的程序中，0表示右，1表示下，2表示上，3表示左）。

每次切出一条线段，就说明不能穿过这条线段到达另一端。

比如：切出了一条(1,1)到(1,3)的线段，就不能从(1,2)走到(2,2)。

这里的边界条件比较臭，放一下代码：

```cpp
memset(go,1,sizeof(go));
for(int i=1; i<=n; i++) {
	//0右 1下 2上 3左 
	//这里要注意边界问题 
	for(int j=w[i].x1+1; j<=w[i].x2; j++) {
		go[j][w[i].y1][0]=go[j][w[i].y1+1][3]=false;
	}
	for(int j=w[i].y1+1; j<=w[i].y2; j++) {
		go[w[i].x1][j][1]=go[w[i].x1+1][j][2]=false;
	}
}
```
其中w[i]表示第i条线段，(x1,y1)是(x2,y2)意思如题所示。

终于写完毒瘤的线段处理辣 (๑•ㅂ•́)و✧！

然后又是一波边界问题……

既然纸是无限大的，那么边界怎么确定？

~~emm这里的问题只是我写之前怕TLE，卡了一波常数，实际上设置成100*2=200就好~~

边界的确定比较简单，令pos1表示用来离散化x坐标的数组大小，pos2表示用来离散化y坐标的数组大小（都是unique后）。

于是pos1+1,pos2+1就是边界了（特别水）

然后，bfs暴力就不赘述了。。

## 代码：


```cpp
#include<stdio.h>
#include<cstring>
#include<algorithm>
#include<math.h>
#define re register int
using namespace std;
typedef long long ll;
int read() {
    re x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {
        if(ch=='-')	f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9') {
        x=10*x+ch-'0';
        ch=getchar();
    }
    return x*f;
}
const int Size=205;
//此处dx dy的顺序要与下面go数组的顺序对应
const int dx[] = {0,1,-1,0};
const int dy[] = {1,0,0,-1};
int n,maxn,maxm,pos1,pos2,nx[Size],ny[Size];
struct Rect {
	int x1,y1,x2,y2;
} w[Size];
struct node {
	int x,y;
} Queue[Size*Size];
bool go[Size][Size][5];
bool vis[Size][Size];
int head,tail;
void PushQueue(int x,int y) {
	Queue[++tail].x=x;
	Queue[tail].y=y;
	vis[x][y]=true;
}
void Cut() {
	head=tail=0;
	PushQueue(0,0);
	while(head<tail) {
		int x=Queue[++head].x;
		int y=Queue[head].y;
		for(re i=0; i<4; i++) {
			if(!go[x][y][i])	continue;
			int nx=x+dx[i];
			int ny=y+dy[i];
			if(nx>=0 && ny>=0 && nx<=maxn && ny<=maxm && !vis[nx][ny]) {
				PushQueue(nx,ny);
//				printf("%d %d\n",nx,ny);
			}
		}
	}
}
void bfs(int sx,int sy) {
	head=tail=0;
	PushQueue(sx,sy);
	while(head<tail) {
		int x=Queue[++head].x;
		int y=Queue[head].y;
		for(re i=0; i<4; i++) {
			int nx=x+dx[i];
			int ny=y+dy[i];
			if(nx>=0 && ny>=0 && nx<=maxn && ny<=maxm && !vis[nx][ny]) {
				PushQueue(nx,ny);
			}
		}
	}
}
int main() {
	n=read();
	for(re i=1; i<=n; i++) {
		nx[++pos1]=w[i].x1=read();
		ny[++pos2]=w[i].y1=read();
		nx[++pos1]=w[i].x2=read();
		ny[++pos2]=w[i].y2=read();
	}
   //离散化
	sort(nx+1,nx+1+pos1);
	sort(ny+1,ny+1+pos1);
	pos1=unique(nx+1,nx+1+pos1)-(nx+1);
	pos2=unique(ny+1,ny+1+pos2)-(ny+1);
   //确定边界（设成200就可以了qwq）
	maxn=pos1+1;
	maxm=pos2+1;
	for(re i=1; i<=n; i++) {
		w[i].x1=lower_bound(nx+1,nx+1+pos1,w[i].x1)-nx;
		w[i].x2=lower_bound(nx+1,nx+1+pos1,w[i].x2)-nx;
		w[i].y1=lower_bound(ny+1,ny+1+pos2,w[i].y1)-ny;
		w[i].y2=lower_bound(ny+1,ny+1+pos2,w[i].y2)-ny;
     		//注意下面这几句一定要写，不然会玄学WA
		if(w[i].x1>w[i].x2 || (w[i].x1==w[i].x2 && w[i].y1>w[i].y2)) {
			swap(w[i].x1,w[i].x2);
			swap(w[i].y1,w[i].y2);
		}
	}
   	//不要忘了memset
	memset(go,1,sizeof(go));
	for(re i=1; i<=n; i++) {
		//0右 1下 2上 3左 
		//这里要注意边界问题 
		for(re j=w[i].x1+1; j<=w[i].x2; j++) {
			go[j][w[i].y1][0]=go[j][w[i].y1+1][3]=false;
		}
		for(re j=w[i].y1+1; j<=w[i].y2; j++) {
			go[w[i].x1][j][1]=go[w[i].x1+1][j][2]=false;
		}
	}
   	//把孔外的点都搜一遍
	Cut();
	int ans=0;
	for(re i=0; i<=maxn; i++) {
		for(re j=0; j<=maxm; j++) {
        		//若到现在还没有搜到，则说明又是一个新的连通块
			if(!vis[i][j]) {
				ans++;
				bfs(i,j);
//				printf("%d %d\n",i,j);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
/*
1
1 1 2 1
*/
```

注：题解中的“巨佬”说的话都是我自己yy出来的qwq，不确定有没有例外，所以如果用这些东西做不出题就还是想别的做法吧qwq

完结撒花！

---

## 作者：035966_L3 (赞：3)

这里提供**细节最少**的解法。

------------

首先，转化坐标。为了方便可以这么转化：

| 原坐标 | 转化后的坐标 |
| :----------: | :----------: |
| $-1000$ | $6$ |
| $-999$ | $8$ |
| $\ldots$ | $\ldots$ |
| $-x$ | $-2x+2006$ |
| $\ldots$ | $\ldots$ |
| $-1$ | $2004$ |
| $0$ | $2006$ |
| $1$ | $2008$ |
| $\ldots$ | $\ldots$ |
| $x$ | $2x+2006$ |
| $\ldots$ | $\ldots$ |
| $999$ | $4004$ |
| $1000$ | $4006$ |

当然，原坐标 $x$ 也可根据个人喜好转化成 $2x+2004$，$2x+2010$，$2x+2022$ 等。

于是，奇数坐标被空了下来，**于是可以用它表示小块**。例如，样例中裁出的小方块可以用 $(2007,2007)$ 表示。

于是，处理完后可**直接上 BFS（DFS 会因递归层数过多而 MLE）+ Floodfill（洪水填充算法）**，但需要注意下面的细节：

**需要将留在纸上的部分单独优先处理**，它是正常的 $\color{red}4$ 连通。在转化后的坐标中，点 $(x,y)$ 的相邻点有：

- $\color{blue}(x,y+1).$
- $\color{blue}(x,y-1).$
- $\color{blue}(x+1,y).$
- $\color{blue}(x-1,y).$

**但是**，被裁下的部分是 $\color{red}8$ 连通（例如，$(2007,2007)$ 与 $(2007,2009)$ 实际上相邻）。**请注意，这不是通常意义下的 $8$ 连通**。在转化后的坐标中，点 $(x,y)$ 的相邻点有：

- $\color{blue}(x,y+1).$
- $\color{blue}(x,y-1).$
- $\color{blue}(x+1,y).$
- $\color{blue}(x-1,y).$
- $\color{red}(x,y+2).$
- $\color{red}(x,y-2).$
- $\color{red}(x+2,y).$
- $\color{red}(x-2,y).$

最后，由于队列过大，开 `int` 会 MLE，而坐标数值不大（显然小于 $5000$），因此要用 `short` 卡空间。

**然后，就没有其他细节了。**

------------

**AC Code：**

（压缩后仅 [798 Bytes](https://www.luogu.com.cn/record/78119391)，或成本题最短解？）

```cpp
#include<iostream>
using namespace std;
bool s[4012][4012];
short f(short x)//转化坐标
{
	return 2*x+2006;
}
short queuex[17000012],queuey[17000012];//队列
int fff=1,t=0;//注意要开 int
void ff(bool mw)
/*
mv = 0：留在纸上的部分
mv = 1：被裁下的部分
*/
{
	while(fff<=t)
	{
		short cnt=t-fff+1;
		for(short i=1;i<=cnt;i++)
		{
			short xx=queuex[fff],yy=queuey[fff];
			fff++;
			s[xx][yy]=true;
			if(!s[xx+1][yy]) t++,queuex[t]=xx+1,queuey[t]=yy,s[xx+1][yy]=true;
			if(!s[xx-1][yy]) t++,queuex[t]=xx-1,queuey[t]=yy,s[xx-1][yy]=true;
			if(!s[xx][yy-1]) t++,queuex[t]=xx,queuey[t]=yy-1,s[xx][yy-1]=true;
			if(!s[xx][yy+1]) t++,queuex[t]=xx,queuey[t]=yy+1,s[xx][yy+1]=true;
			if(mw)
			{
				if(!s[xx+2][yy]) t++,queuex[t]=xx+2,queuey[t]=yy,s[xx+2][yy]=true;
				if(!s[xx-2][yy]) t++,queuex[t]=xx-2,queuey[t]=yy,s[xx-2][yy]=true;
				if(!s[xx][yy-2]) t++,queuex[t]=xx,queuey[t]=yy-2,s[xx][yy-2]=true;
				if(!s[xx][yy+2]) t++,queuex[t]=xx,queuey[t]=yy+2,s[xx][yy+2]=true;
			}
		}
	}
}
int main()
{
	short n;
	cin>>n;
	for(short i=1;i<=n;i++)
	{
		short a,b,c,d;
		cin>>a>>b>>c>>d;
		if(a==c)//纵向
		{
			for(short i=f(min(b,d));i<=f(max(b,d));i++)
				s[f(a)][i]=true;
		}
		if(b==d)//横向
		{
			for(short i=f(min(a,c));i<=f(max(a,c));i++)
				s[i][f(b)]=true;
		}
	}
	for(short i=0;i<=4011;i++)//外圈围两层（一层不够），防止越界
		s[0][i]=s[i][0]=s[4011][i]=s[i][4011]=s[1][i]=s[i][1]=s[4010][i]=s[i][4010]=true;
	short ans=0;
	t++;
	queuex[t]=2;
	queuey[t]=2;
	ff(0);//留在纸上的部分
	for(short i=3;i<=4009;i++)
		for(short j=2;j<=4009;j++)
		{
			if(!s[i][j]) ans++;
			if(!s[i][j])
			{
				t++;
				queuex[t]=i;
				queuey[t]=j;
				ff(1);//被裁下的部分
			}
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：Tjaweiof (赞：2)

# P1299 题解
[题目传送门](https://www.luogu.com.cn/problem/P1299)

看很多人都用了离散化，我认为不需要。

可以在输入的时候（$x_1,y_1,x_2,y_2$ 都加上 $1001$ 方便存储），用一个数组记录一个格子的四条边是否切断，方便 bfs。

注意到 $(0,0)$ 最后不可能变成孔，于是选择从 $(0,0)$ 开始 bfs，找出所有不是孔的方格，用数组记录。

遍历一遍整张纸，看到一个孔就开始 bfs，找到所有与它相邻的并记录，然后 `ans++`。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define FILE(x) freopen(x".in", "r", stdin);freopen(x".out", "w", stdout);
const int nextstep[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
int n, ans;
bool f[2003][2003][4], vis[2003][2003], vis2[2003][2003];
queue <pair <int, int> > q, q2;
void bfs(int x, int y){
	q.push({x, y});
	vis[x][y] = true;
	while (!q.empty()){
		auto u = q.front();
		q.pop();
		for (int k = 0; k < 4; k++){
			int nx = u.first + nextstep[k][0], ny = u.second + nextstep[k][1];
			if (nx < 0 || nx > 2002 || ny < 0 || ny > 2002 || vis[nx][ny] || f[u.first][u.second][k]){
				continue;
			}
			vis[nx][ny] = true;
			q.push({nx, ny});
		}
	}
	return;
}
void bfs2(int x, int y){
	q2.push({x, y});
	vis2[x][y] = true;
	while (!q2.empty()){
		auto u = q2.front();
		q2.pop();
		for (int k = 0; k < 4; k++){
			int nx = u.first + nextstep[k][0], ny = u.second + nextstep[k][1];
			if (nx < 1 || nx > 2002 || ny < 1 || ny > 2002 || vis2[nx][ny] || vis[nx][ny]){
				continue;
			}
			vis2[nx][ny] = true;
			q2.push({nx, ny});
		}
	}
	return;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int a, b, c, d;
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> a >> b >> c >> d;
		a += 1001;
		b += 1001;
		c += 1001;
		d += 1001;
		if (b == d){
			for (int j = min(a, c) + 1; j <= max(a, c); j++){
				f[j][b][0] = true;
				f[j][b + 1][2] = true;
			}
		} else {
			for (int j = min(b, d) + 1; j <= max(b, d); j++){
				f[a][j][1] = true;
				f[a + 1][j][3] = true;
			}
		}
	}
	bfs(0, 0);
	for (int i = 1; i <= 2002; i++){
		for (int j = 1; j <= 2002; j++){
			if (!vis[i][j] && !vis2[i][j]){
				bfs2(i, j);
				ans++;
			}
		}
	}
	cout << ans;
	return 0;
}

```

---

## 作者：RaymondOccam (赞：0)

### 思路
考虑区分孔和坐标。

如对于坐标 $x$，一个偶数 $y$，用 $2x+y$ 表示。

剩下的奇数坐标自然表示小孔。

处理完后直接泛洪广搜，不过有些细节需要注意：

- 优先处理留在纸上的。
- 被裁下是另一种八连通，偏移量如此表示：
  ```
  int dx[] = {0, 0, -1, 1, 0, 0, 2, -2};
  int dy[] = {-1, 1, 0, 0, -2, 2, 0, 0};
  ```

注意这些细节，就可以 AC 这道题了。

综上：离散化坐标，bfs 找出保留在纸上的部分，最后找出连通块数量的就可以。

### 核心代码

切割：
```cpp
while (!q.empty())
{
    Node now = q.front();
    q.pop();
    for (int i = 0; i < 4; i++)
    {
        int x = now.x + xx[i], y = now.y + yy[i];
        if (x < 0 || x > 200 || y < 0 || y > 200)
            continue;
        if (!b[x][y].visit)
            continue;
        if (!b[now.x][now.y].Vis[i])
            continue;
        b[x][y].visit = 0;
        q.push(Node(x, y));
    }
}
```

计算答案中的广搜：
```cpp
while (!q.empty())
{
    Node now = q.front();
    q.pop();
    for (int i = 0; i < 4; i++)
    {
        int x = now.x + xx[i], y = now.y + yy[i];
        if (x < 0 || x > 200 || y < 0 || y > 200)
            continue;
        if (!b[x][y].visit)
            continue;
        b[x][y].visit = 0;
        q.push(Node(x, y));
    }
}
```

---

## 作者：ELECTRODE_kaf (赞：0)

离散化+宽度优先搜索。

记录下切割线的所有端点，按照坐标小到大重新编号。

从任意一个不在切割区域内的点开始跑 BFS，增加一个限制：不能跨过切割线。标记所有未被切割的位置。再重新跑无限制 BFS 计算连通块数量。

不跨过切割线的方法：给每一个点开一个四个方向上的标记 `go[4]`，记录这个往方向走一格会不会穿过切割线。

细节：两个有一个公共端点的孔算两个孔，面积为 $0$ 的孔不算孔。所以记录 `go[]` 的时候，两个端点只记录一个。

```cpp
const srt d4[4][2]={1,0,0,1,-1,0,0,-1};
const ll inf=2e9;

struct point{
	ll no;
	pll pos;
};

struct loc{
	bool go[4]={1,1,1,1};
};

const ll N=200;
ll n;
point a[N*2];
loc mp[N*2][N*2];

bool cmpx(point p1,point p2){
	return p1.pos.fi<p2.pos.fi;
}

bool cmpy(point p1,point p2){
	return p1.pos.se<p2.pos.se;
}

bool cmp(point p1,point p2){
	if(p1.no!=p2.no) return p1.no<p2.no;
	else{
		if(p1.pos.fi!=p2.pos.fi) return p1.pos.fi<p2.pos.fi;
		else return p1.pos.se<p2.pos.se;
	}
}

queue<pll> qu;
bool vis[N*2][N*2];
ll xm,ym;

void bfs(pll st){
	myclear(qu);
	qu.push(st);
	
	while(qu.empty()==0){
		pll cur;
		cfront(cur,qu);
		
		rep(i,0,3){
			pll pp;
			pp.fi=cur.fi+d4[i][0];
			pp.se=cur.se+d4[i][1];
			
			if(pp.fi<1 or pp.se<1 or pp.fi>xm or pp.se>ym or vis[pp.fi][pp.se]) ctn;
			
			vis[pp.fi][pp.se]=1;
			qu.push(pp);
		}
	}
}

int main(){
//	memset(vis,0,sizeof(vis));
	cin>>n;
	
	rep(i,1,n*2){
		a[i].no=(i+1)/2;
		cin>>a[i].pos.fi>>a[i].pos.se;
	}
	
	ll pre=-inf,cnta=0;
	sort(a+1,a+n*2+1,cmpx);
	
	rep(i,1,n*2){
		if(a[i].pos.fi!=pre){
			pre=a[i].pos.fi;
			cnta++;
		}
		
		a[i].pos.fi=cnta;
	}
	
	xm=cnta;
	pre=-inf,cnta=0;
	sort(a+1,a+n*2+1,cmpy);
	
	rep(i,1,n*2){
		if(a[i].pos.se!=pre){
			pre=a[i].pos.se;
			cnta++;
		}
		
		a[i].pos.se=cnta;
	}
	
	ym=cnta;
	sort(a+1,a+n*2+1,cmp);
	
//	rep(i,1,2*n) cout<<a[i].pos.fi<<' '<<a[i].pos.se<<'\n';
//	
//	pause;
	
	for(ll i=1;i<=n*2;i+=2){
		point p1=a[i],p2=a[i+1];
		
		rep(j,p1.pos.fi+1,p2.pos.fi){
			mp[j][p1.pos.se].go[1]=0;
//			cout<<'('<<j<<','<<p1.pos.se<<") right\n";
			mp[j][p1.pos.se+1].go[3]=0;
//			cout<<'('<<j<<','<<p1.pos.se+1<<") left\n";
//			cout<<"x fixed:("<<j<<','<<p1.pos.se+1<<")\n";
//			pause;
		}
		
		rep(j,p1.pos.se+1,p2.pos.se){
			mp[p1.pos.fi][j].go[0]=0;
//			cout<<'('<<p1.pos.fi<<','<<j<<") down\n";
			mp[p1.pos.fi+1][j].go[2]=0;
//			cout<<'('<<p1.pos.fi+1<<','<<j<<") up\n";
//			cout<<"y fixed:("<<p1.pos.fi+1<<','<<j<<")\n";
//			pause;
		}
	}
	
	qu.push({0,0});
	vis[0][0]=1;
	
	while(qu.empty()==0){
		pll cur;
		cfront(cur,qu);
		
		rep(i,0,3){
			pll pp;
			pp.fi=cur.fi+d4[i][0];
			pp.se=cur.se+d4[i][1];
			
			if(pp.fi<0 or pp.se<0 or pp.fi>xm+1 or pp.se>ym+1 or vis[pp.fi][pp.se]
			or mp[cur.fi][cur.se].go[i]==0) ctn;
			
			vis[pp.fi][pp.se]=1;
//			cout<<"visit:"<<pp.fi<<' '<<pp.se<<'\n';
//			pause;
			qu.push(pp);
		}
	}
	
	ll ans=0;
	
	rep(i,1,xm){
		rep(j,1,ym){
			if(vis[i][j]) ctn;
			
//			cout<<"find i="<<i<<",j="<<j<<'\n';
			ans++;
			vis[i][j]=1;
			bfs({i,j});
		}
	}
	
	cout<<ans;
}
/*
6
1 3 1 5
1 5 3 5
3 1 3 5
1 3 5 3
3 1 5 1
5 1 5 3
ans:2
*/
```

---

## 作者：封禁用户 (赞：0)

话不多说，我们直接进入正题：

我们可以使用一种叫做“扫描线”或“线段树”的方法，但考虑到问题的规模（$N \leq 100$）和简便性，我们可以使用一个更直接的方法：跟踪每次切割后形成的孔。由于题目中保证了所有的切割都平行于坐标轴，我们可以分别对 $x$ 轴和 $y$ 轴的切割进行处理。首先，我们可以定义一些数据结构来记录当前纸上的孔。对于每次 $x$ 轴切割，我们可以检查它是否与现有的 $y$ 轴上的线段相交，并更新这些线段。同样地，对于每次 $y$ 轴切割，我们检查它是否与现有的 $x$ 轴上的线段相交，并更新这些线段。然而，由于这个问题的规模很小，我们可以简化问题，使用一个二维数组或集合来记录哪些点或区域是空的，哪些是被填充的。在每次切割后，我们更新这个结构，并计算剩余孔的数量。但这里有一个更简单的方法，由于题目只要求输出最终孔的数量，并且孔的最小面积不低于 $1$ 平方单位，我们可以使用一个更直观的模拟方法：

1. 初始化一个二维布尔数组 `paper[2001][2001]`（为了处理边界情况，我们将坐标范围扩大一倍，并映射到该数组上），所有元素初始化为 `true`，表示纸上初始时所有位置都是空的。
2. 对于每次切割，如果它是水平的（即 $y_1 = y_2$），则遍历 $x_1$ 到 $x_2$ 的范围，并将 `paper[x][y_1]` 设置为 `false`。
3. 如果切割是垂直的（即 $x_1 = x_2$），则遍历 $y_1$ 到 $y_2$ 的范围，并将 `paper[x_1][y]` 设置为 `false`。
4. 在每次切割后，我们遍历整个纸（或只需要遍历被切割影响的区域），并计算连续的空区域（孔）的数量。
5. 输出最终孔的数量。

但是，如果两次切割非常接近（即它们之间的间隔小于 $1$），则它们可能被视为一个孔。但由于题目保证了孔的最小面积不低于 $1$ 平方单位，我们可以安全地忽略这种情况。

这道题就讲到这儿，撒花！

---

## 作者：Chavapa (赞：0)

**这道题本身比较水，只是细节有点多。**

看到没有Pascal题解，我就来一发吧。同时也纪念下自己2个多小时调出来的代码。

## 正解：离散化+bfs
题意为求“孔”的个数，即求图中被切割线段包围的独立的块个数。

不难想到在这些“孔”的周围跑一遍bfs，将能跑到的“外围”的面积全部标记。后再扫一遍全图，若发现未被标记的面积，则表示该面积在线段包围范围内。再分别做bfs标记后，统计答案即可。由于 $-1000≤x1,y1,x2,y2≤1000$ ，存在负数，故考虑离散化。

思路简单，实现细节比较复杂。

一个坑点在于：搜孔内部时，**可以从线段的一端穿到另一端**。举个栗子：
![eXdpl9.png](https://s2.ax1x.com/2019/08/10/eXdpl9.png)

在遇到如图这种情况时，我们可以直接穿过。若考虑线段的阻隔，程序将会把一整个“孔”分成3块，从而导致答案错误。

关于其余细节，dalao们应该说的很详细辣。这里不再赘述。

具体实现时特别注意“点”与“面积”的关系！详见代码。

```c
program Luogu_P1299;
const d:array[0..3,1..2] of longint=((-1,0),(1,0),(0,-1),(0,1));
var n,i,j,p,x1,y1,x2,y2,ans,cnt:longint;
    lx,ly:array[-1010..1010] of longint;
    x,y,xx,yy:array[0..1000] of longint;
    vis:array[-10..205,-10..205] of boolean;
    sq:array[1..1000000,1..2] of longint;
    cango:array[-10..205,-10..205,0..3] of boolean;
  procedure swap(var x,y:longint);
  var t:longint;
  begin
    t:=x; x:=y; y:=t;
  end;
  procedure bfs(x,y,t:longint);  //t是临时变量，t=1代表此时搜外围，t=2代表此时搜“孔”的内部
  var l,r,x1,y1:longint;
  begin
    l:=1; r:=1;
    sq[1,1]:=x; sq[1,2]:=y;
    while l<=r do
    begin
      for i:=0 to 3 do
      begin
        x1:=sq[l,1]+d[i,1]; y1:=sq[l,2]+d[i,2];
        if (x1<0)or(x1>200)or(y1<0)or(y1>200) then continue;
        if vis[x1,y1] then continue;
        if (t=1)and(cango[sq[l,1],sq[l,2],i]=false) then continue;  
        //注意：搜孔的内部时，须忽略线段的阻隔效果
        vis[x1,y1]:=true;
        inc(r); sq[r,1]:=x1; sq[r,2]:=y1;
      end;
      inc(l);
    end;
  end;
begin
  readln(n);
  for i:=1 to n do
  begin
    readln(x[i],y[i],xx[i],yy[i]);
    lx[x[i]]:=1; lx[xx[i]]:=1;  ly[y[i]]:=1; ly[yy[i]]:=1;
  end;
  for i:=-1010 to 1010 do  //x,y数据较小，离散化可以直接记录，无需快排
    if lx[i]>0 then
    begin
      inc(cnt); lx[i]:=cnt;
    end;
  cnt:=0;
  for i:=-1010 to 1010 do
    if ly[i]>0 then
    begin
      inc(cnt); ly[i]:=cnt;
    end;
  fillchar(cango,sizeof(cango),true);  //cango数组和楼上几篇题解一样，记录该点往各方向能否走
  for p:=1 to n do
  begin
    x1:=lx[x[p]]; y1:=ly[y[p]];
    x2:=lx[xx[p]]; y2:=ly[yy[p]];
    if (x1>x2)or((x1=x2)and(y1>y2)) then  //注意两个坐标大小顺序
    begin
      swap(x1,x2); swap(y1,y2);
    end;
    for i:=y1+1 to y2 do  //“点”和“单位面积”是不一样的，此处循环需从y1+1到y2
    begin
      cango[x1,i,1]:=false;
      cango[x1+1,i,0]:=false;
    end;
    for i:=x1+1 to x2 do
    begin
      cango[i,y1,3]:=false;
      cango[i,y1+1,2]:=false;
    end;
  end;
  bfs(0,0,1);  //搜外围面积
  for i:=0 to 200 do
    for j:=0 to 200 do
      if vis[i,j]=false then
      begin
        inc(ans); bfs(i,j,2);  //累计答案，标记
      end;
  writeln(ans);
end.
```




---

## 作者：yi_heng (赞：0)

好像是矩形覆盖？woc不会啊！！！ 
我们发现范围很小，于是本着暴力能AC的想法就写发暴搜试试…… 
嗯搜地图都是BFS，于是奇奇怪怪的BFS就出来了…… 
将整个图片像素化，变为黑色，把线画上的像素标记。然后从一个不在这些线围成的区域内部的点开始BFS，把外围的像素表记为白色。那么我们就需要统计的是黑色的块数，再一波BFS找并标记连通块即可。 
但是这样会WA得很惨，原因是一些奇奇怪怪的图形，就如第一个图样会输出1，是因为两个顶点的交点是黑色的，会把这两个黑块连通…… 
于是我们跑一遍原图，把这种点去掉即可…… 
还有第二个图样，我们发现这条线并没有卵用但是记为了答案，于是我们在删除上面的点的同时删一遍这样的线即可…… 
那么我们就可以A了…… 
诶我哪知道哪个点不在围成的区域里？我从哪开始搜啊？ 
多插入几个可能性就行了…… 
我也不知道对不对反正求各位dalao别hack我就行了…… 
如果记横坐标范围为w，纵坐标范围为h，则复杂度为O(wh)。 

code

```cpp
#include <queue>
#include <cstdio>
#include <algorithm>
#define MAXX 2010
#define ZERO 1000
using namespace std;

const int d[4][2]={
	{0,1},{0,-1},
	{1,0},{-1,0}
};

int n,R=1,mxx,mxy,ans;
bool mp[MAXX][MAXX],vis[MAXX][MAXX],vist[MAXX][MAXX];
queue <pair<int,int> > q;
pair <int,int> sp;

inline int mymax(int a,int b){return a>b?a:b;}

inline void BFS()
{
	q.push(make_pair(mxx,mxy));
	q.push(make_pair(0,0));
	q.push(make_pair(ZERO,mxy));
	vis[0][0]=true;
	if (!mp[mxx][mxy]) vis[mxx][mxy]=true;
	if (!mp[ZERO][mxy]) vis[ZERO][mxy]=true;
	while (!q.empty())
	{
		pair<int,int> u=q.front();q.pop();
		for (int i=0;i<4;i++)
		{
			int tx=u.first+d[i][0],ty=u.second+d[i][1];
			if (tx>=0&&tx<=mxx&&ty>=0&&ty<=mxy)
			{
				if (!mp[tx][ty]&&!vis[tx][ty])
				{
					vis[tx][ty]=true;
					q.push(make_pair(tx,ty));
				}
			}
		}
	}
	for (int i=0;i<=mxx;i++)
		for (int j=0;j<=mxy;j++)
			vis[i][j]=!vis[i][j];
	for (int i=0;i<=mxx;i++)
		for (int j=0;j<=mxy;j++)
		{
			if (vis[i+1][j]&&vis[i-1][j]&&vis[i][j+1]&&vis[i][j-1])
			{
				if (vis[i+1][j-1]&&vis[i-1][j+1]&&!vis[i+1][j+1]&&!vis[i-1][j-1])
					vis[i][j]=false;
				if (!vis[i+1][j-1]&&!vis[i-1][j+1]&&vis[i+1][j+1]&&vis[i-1][j-1])
					vis[i][j]=false;
			}
			else
			{
				if (vis[i][j]&&!vis[i-1][j]&&!vis[i+1][j]) vis[i][j]=false;
				if (vis[i][j]&&!vis[i][j-1]&&!vis[i][j+1]) vis[i][j]=false;
				else if (!vis[i][j]&&vis[i-1][j]&&vis[i+1][j]) vis[i][j]=true;
				else if (!vis[i][j]&&vis[i][j-1]&&vis[i][j+1]) vis[i][j]=true;
			}
		}
	return ;
}

inline void BFS(int x,int y)
{
	sp=make_pair(0,0);
	q.push(make_pair(x,y));vist[x][y]=true;
	while (!q.empty())
	{
		pair<int,int> u=q.front();q.pop();
		for (int i=0;i<4;i++)
		{
			int tx=u.first+d[i][0],ty=u.second+d[i][1];
			if (tx>=0&&tx<=mxx&&ty>=0&&ty<=mxy)
			{
				if (vis[tx][ty]&&!vist[tx][ty])
				{
					vist[tx][ty]=true;
					sp=sp<make_pair(tx,ty)?make_pair(tx,ty):sp;
					q.push(make_pair(tx,ty));
				}
			}
		}
	}
	return ;
}

inline void read(int &x)
{
	x=0;bool f=false;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	if (f) x=-x;return ;
}

int main()
{
	int x0,y0,x1,y1;
	read(n);
	if (n<4)
	{
		puts("0");
		return 0;
	}
	for (int i=1;i<=n;i++)
	{
		read(x0);read(y0);read(x1);read(y1);
		x0+=ZERO;y0+=ZERO;x1+=ZERO;y1+=ZERO;
		mxx=mymax(mxx,mymax(x1,x0));
		mxy=mymax(mxy,mymax(y1,y0));
		if (x0==x1)
		{
			if (y0>y1) swap(y0,y1);
			for (int j=y0;j<=y1;j++) mp[x0][j]=1;
		}
		if (y0==y1)
		{
			if (x0>x1) swap(x0,x1);
			for (int j=x0;j<=x1;j++) mp[j][y0]=1;
		}
	}
	BFS();
	for (int i=0;i<=mxx;i++)
		for (int j=0;j<=mxy;j++)
			if (vis[i][j]&&!vist[i][j])
			{
				BFS(i,j);
				if (sp.first!=i&&sp.second!=j) ans++; 
			}
	printf("%d\n",ans);
	return 0;
}
```

---


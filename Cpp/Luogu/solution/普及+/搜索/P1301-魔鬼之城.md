# 魔鬼之城

## 题目描述

在一个被分割为 $N\times M$ 个正方形房间的矩形魔鬼之城中，一个探险者必须遵循下列规则才能跳跃行动。他必须从 $(1,1)$ 进入，从 $(N,M)$ 走出；在每一房间的墙壁上都写了一个魔法数字，是 $1\sim 13$ 之内的自然数；探险者可以想像出 $8$ 个方向中的任何一个（水平或垂直或对角线方向），随后他就可以作一次空间跳跃穿过这一方向上的连续的 $X$ 个房间，其中 $X$ 是他原来所在房间的魔法数字。但如果在这一方向上的房间数小于 $X$，则他不作任何跳跃，而必须想像另一个方向。同时，探险者不能作连续两次相同方向的跳跃。

![](https://cdn.luogu.com.cn/upload/image_hosting/1r5tkwsy.png)
 
例如在上图的 $5\ \times 4$ 的魔鬼之城中，如果探险者现在所在的位置是 $(3,3)$，那么通过依次空间跳跃他可以到达下列房间中的一个：$(1,1)$，$(3,1)$，$(1,3)$，$(5,1)$，或 $(5,3)$。另外，如果他要用两次跳跃从 $(5,4)$ 到达 $(3,2)$，则他不能首先跳到 $(4,3)$（因为这样他第二次跳跃的方向将和第一次相同，而这是不允许的）。所以他必须先跳跃到 $(2,1)$。
请你写一个程序，对给定的地图，算出探险者至少需要跳跃多少步才能离开魔鬼之城。



## 样例 #1

### 输入

```
5 4
3 3 6 7 11
3 2 1 1 3
3 2 2 1 1
2 1 2 2 1
```

### 输出

```
4
```

# 题解

## 作者：wonSSnow (赞：18)

这道题在蒟蒻看来就是bfs的模板，但是还是有一个坑点。

主要是visit数组，本蒟蒻在10分卡了很久，就是因为visit数组没有开三维。

v[i][j][way]表示第i行第j列是其他点走way这个方向走来的。

还有v数组应保存从任一点走到这里的最小步数。

### 请大家看我题解中c++代码中最短的一篇
# CODE:
```
#include<bits/stdc++.h>
using namespace std;
int mapa[105][105];
int v[105][105][10];
int dx[9]={0,0,1,1,1,0,-1,-1,-1};
int dy[9]={0,-1,-1,0,1,1,1,0,-1};
struct node{
    int x,y,step,way;
};
queue<node> q;
int main()
{
    int n,m;
    memset(v,0,sizeof(v));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&mapa[i][j]);
    node start;
    start.x=1,start.y=1;
    start.step=0,start.way=9;
    q.push(start);
    while(!q.empty())
    {
        node now=q.front();
        q.pop();
        if(now.x==m&&now.y==n)
        {
            printf("%d",now.step);
            return 0;
        }
        for(int i=1;i<=8;i++)
        {
            if(now.way!=i)
            {
                int tx=now.x+dx[i]*mapa[now.x][now.y];
                int ty=now.y+dy[i]*mapa[now.x][now.y];
                int ts=now.step;
                if(tx<=m&&ty<=n&&tx>=1&&ty>=1&&v[tx][ty][i]==0)
                {
                    v[tx][ty][i]=1;
                    node ans;
                    ans.x=tx,ans.y=ty;
                    ans.step=ts+1,ans.way=i;
                    q.push(ans);
                }
            }
        }
    }
    printf("NEVER");
}

```
### 在此，特别鸣谢jackyzhu教蒟蒻做题。

---

## 作者：花千树 (赞：17)

看到这道题题目不多，来贡献一下哈

其实也不难，bfs，从(1,1)点开始，对于八个方向，如果不越界，并且不能重复走一个方向，就可以把节点压入队列。

对于处理方向，本蒟蒻笨拙，结构体里用了8个bool变量，代表8个方向，判断方向，虽然变量多，但是一个队列就够了。

不过有一个坑点（70分的看过来），可能会构成可以**环**，使你的结果会出现玄学情况，所以判断能不能走这个点的vis数组，就要加一维，这样可以确定方向。

先上70分代码，应该写啰嗦了，可以对照看（妈呀错的就不写注释了）

```
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
template<class AC>void r(AC &x){
    x=0;
    int f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        f|=(ch=='-');
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x=f?-x:x;
    return;
}
struct AC{
    int sum,x,y;
    bool a,b,c,d,e,f,g,h;
}k;
queue<AC>q;
int n,m,a[1005][1005],v[1005][1005];
bool check(int x,int y){
    if(x>n||x<1||y>m||y<1)return 0;
    return 1;
}
int main(){
    r(n);r(m);
    swap(n,m);
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)r(a[i][j]);
    q.push(AC{0,1,1,1,1,1,1,1,1,1,1});
    v[1][1]=1;
    while(!q.empty()){
        k=q.front(),q.pop();
        if(check(k.x+a[k.x][k.y],k.y)&&!v[k.x+a[k.x][k.y]][k.y]&&k.a==1){
            q.push(AC{k.sum+1,k.x+a[k.x][k.y],k.y,0,1,1,1,1,1,1,1});
            v[k.x+a[k.x][k.y]][k.y]=1;
            if(k.x+a[k.x][k.y]==n&&k.y==m){
                printf("%d\n",k.sum+1);
                return 0;
            }
        }
        if(check(k.x-a[k.x][k.y],k.y)&&!v[k.x-a[k.x][k.y]][k.y]&&k.b==1){
            q.push(AC{k.sum+1,k.x-a[k.x][k.y],k.y,1,0,1,1,1,1,1,1});
            v[k.x-a[k.x][k.y]][k.y]=1;
            if(k.x-a[k.x][k.y]==n&&k.y==m){
                printf("%d\n",k.sum+1);
                return 0;
            }
        }
        if(check(k.x,k.y+a[k.x][k.y])&&!v[k.x][k.y+a[k.x][k.y]]&&k.c==1){
            q.push(AC{k.sum+1,k.x,k.y+a[k.x][k.y],1,1,0,1,1,1,1,1});
            v[k.x][k.y+a[k.x][k.y]]=1;
            if(k.x==n&&k.y+a[k.x][k.y]==m){
                printf("%d\n",k.sum+1);
                return 0;
            }
        }
        if(check(k.x,k.y-a[k.x][k.y])&&!v[k.x][k.y-a[k.x][k.y]]&&k.d==1){
            q.push(AC{k.sum+1,k.x,k.y-a[k.x][k.y],1,1,1,0,1,1,1,1});
            v[k.x][k.y-a[k.x][k.y]]=1;
            if(k.x==n&&k.y-a[k.x][k.y]==m){
                printf("%d\n",k.sum+1);
                return 0;
            }
        }
        if(check(k.x+a[k.x][k.y],k.y+a[k.x][k.y])&&!v[k.x+a[k.x][k.y]][k.y+a[k.x][k.y]]&&k.e==1){
            q.push(AC{k.sum+1,k.x+a[k.x][k.y],k.y+a[k.x][k.y],1,1,1,1,0,1,1,1});
            v[k.x+a[k.x][k.y]][k.y+a[k.x][k.y]]=1;
            if(k.x+a[k.x][k.y]==n&&k.y+a[k.x][k.y]==m){
                printf("%d\n",k.sum+1);
                return 0;
            }
        }
        if(check(k.x+a[k.x][k.y],k.y-a[k.x][k.y])&&!v[k.x+a[k.x][k.y]][k.y-a[k.x][k.y]]&&k.f==1){
            q.push(AC{k.sum+1,k.x+a[k.x][k.y],k.y-a[k.x][k.y],1,1,1,1,1,0,1,1});
            v[k.x+a[k.x][k.y]][k.y-a[k.x][k.y]]=1;
            if(k.x+a[k.x][k.y]==n&&k.y-a[k.x][k.y]==m){
                printf("%d\n",k.sum+1);
                return 0;
            }
        }
        if(check(k.x-a[k.x][k.y],k.y+a[k.x][k.y])&&!v[k.x-a[k.x][k.y]][k.y+a[k.x][k.y]]&&k.g==1){
            q.push(AC{k.sum+1,k.x-a[k.x][k.y],k.y+a[k.x][k.y],1,1,1,1,1,1,0,1});
            v[k.x-a[k.x][k.y]][k.y+a[k.x][k.y]]=1;
            if(k.x-a[k.x][k.y]==n&&k.y+a[k.x][k.y]==m){
                printf("%d\n",k.sum+1);
                return 0;
            }
        }
        if(check(k.x-a[k.x][k.y],k.y-a[k.x][k.y])&&!v[k.x-a[k.x][k.y]][k.y-a[k.x][k.y]]&&k.h==1){
            q.push(AC{k.sum+1,k.x-a[k.x][k.y],k.y-a[k.x][k.y],1,1,1,1,1,1,1,0});
            v[k.x-a[k.x][k.y]][k.y-a[k.x][k.y]]=1;
            if(k.x-a[k.x][k.y]==n&&k.y-a[k.x][k.y]==m){
                printf("%d\n",k.sum+1);
                return 0;
            }
        }
    }
    puts("NEVER");
    return 0;
}
```

下面是满分代码，可以看出改动不大，在考场上就是30分啊

```
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
template<class AC>void r(AC &x){
    x=0;
    int f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        f|=(ch=='-');
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x=f?-x:x;
    return;
}//头文件&&快读
struct AC{
	int sum,x,y;//x,y坐标和走到这一步的最小步数sum
	bool a,b,c,d,e,f,g,h;//确定8方向可不可以走
}k;
queue<AC>q;//队列，就一个，没错，你没有眼花
int n,m,a[1005][1005],v[1005][1005][10];//vis数组3维，前面说过了
bool check(int x,int y){//判断有没有越界
	if(x>n||x<1||y>m||y<1)return 0;
	return 1;
}
int main(){
	r(n);r(m);
	swap(n,m);//本人习惯n在前，m在后，可以无视
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)r(a[i][j]);//读入（快读大法好）
	q.push(AC{0,1,1,1,1,1,1,1,1,1,1});//(1,1)所需步数：0，能向8个方向任意出发
    /*
    q.push(AC{1,0})PS:AC是结构体名
    等同于
    AC x;
    x.x=1,x.y=0;
    q.push(x);
    由于本题作者笨拙，用了11个变量
    所以这样写无法避免冗长的码量
    降低可读性
    故此这样写
    有warning不用管
    */
	while(!q.empty()){//BFS老套路，队列非空
		k=q.front();q.pop();//取队首
        /*
        下面的内容我写复杂了
        其实没有那个必要
        不过这样写通俗易懂
        走8个方向后的坐标怎么求不用多说
        先调用check函数判断是否越界
        然后判断vis数组，走不同的方向第3维就不同
        举例：
        假设下一个点可以走到(3,3)，是横着走过来的
        那么判断v[3][3][1]是否为0就可以了
        最后还要满足不能走同一方向的条件
        同时满足的话，这个点的步数为取的队首元素的步数+1（这不用解释的吧）
        同时，这个点就不能走对应方向了，置0
        如果到达终点，直接输出
        下面的内容就是我如上所说，代码是长了点
        但是每个方向的枚举看的十分条理清晰
        */
		if(check(k.x+a[k.x][k.y],k.y)&&!v[k.x+a[k.x][k.y]][k.y][1]&&k.a==1){
			q.push(AC{k.sum+1,k.x+a[k.x][k.y],k.y,0,1,1,1,1,1,1,1});
			v[k.x+a[k.x][k.y]][k.y][1]=1;
			if(k.x+a[k.x][k.y]==n&&k.y==m){
				printf("%d\n",k.sum+1);
				return 0;
			}
		}
		if(check(k.x-a[k.x][k.y],k.y)&&!v[k.x-a[k.x][k.y]][k.y][2]&&k.b==1){
			q.push(AC{k.sum+1,k.x-a[k.x][k.y],k.y,1,0,1,1,1,1,1,1});
			v[k.x-a[k.x][k.y]][k.y][2]=1;
			if(k.x-a[k.x][k.y]==n&&k.y==m){
				printf("%d\n",k.sum+1);
				return 0;
			}
		}
		if(check(k.x,k.y+a[k.x][k.y])&&!v[k.x][k.y+a[k.x][k.y]][3]&&k.c==1){
			q.push(AC{k.sum+1,k.x,k.y+a[k.x][k.y],1,1,0,1,1,1,1,1});
			v[k.x][k.y+a[k.x][k.y]][3]=1;
			if(k.x==n&&k.y+a[k.x][k.y]==m){
				printf("%d\n",k.sum+1);
				return 0;
			}
		}
		if(check(k.x,k.y-a[k.x][k.y])&&!v[k.x][k.y-a[k.x][k.y]][4]&&k.d==1){
			q.push(AC{k.sum+1,k.x,k.y-a[k.x][k.y],1,1,1,0,1,1,1,1});
			v[k.x][k.y-a[k.x][k.y]][4]=1;
			if(k.x==n&&k.y-a[k.x][k.y]==m){
				printf("%d\n",k.sum+1);
				return 0;
			}
		}
		if(check(k.x+a[k.x][k.y],k.y+a[k.x][k.y])&&!v[k.x+a[k.x][k.y]][k.y+a[k.x][k.y]][5]&&k.e==1){
			q.push(AC{k.sum+1,k.x+a[k.x][k.y],k.y+a[k.x][k.y],1,1,1,1,0,1,1,1});
			v[k.x+a[k.x][k.y]][k.y+a[k.x][k.y]][5]=1;
			if(k.x+a[k.x][k.y]==n&&k.y+a[k.x][k.y]==m){
				printf("%d\n",k.sum+1);
				return 0;
			}
		}
		if(check(k.x+a[k.x][k.y],k.y-a[k.x][k.y])&&!v[k.x+a[k.x][k.y]][k.y-a[k.x][k.y]][6]&&k.f==1){
			q.push(AC{k.sum+1,k.x+a[k.x][k.y],k.y-a[k.x][k.y],1,1,1,1,1,0,1,1});
			v[k.x+a[k.x][k.y]][k.y-a[k.x][k.y]][6]=1;
			if(k.x+a[k.x][k.y]==n&&k.y-a[k.x][k.y]==m){
				printf("%d\n",k.sum+1);
				return 0;
			}
		}
		if(check(k.x-a[k.x][k.y],k.y+a[k.x][k.y])&&!v[k.x-a[k.x][k.y]][k.y+a[k.x][k.y]][7]&&k.g==1){
			q.push(AC{k.sum+1,k.x-a[k.x][k.y],k.y+a[k.x][k.y],1,1,1,1,1,1,0,1});
			v[k.x-a[k.x][k.y]][k.y+a[k.x][k.y]][7]=1;
			if(k.x-a[k.x][k.y]==n&&k.y+a[k.x][k.y]==m){
				printf("%d\n",k.sum+1);
				return 0;
			}
		}
		if(check(k.x-a[k.x][k.y],k.y-a[k.x][k.y])&&!v[k.x-a[k.x][k.y]][k.y-a[k.x][k.y]][8]&&k.h==1){
			q.push(AC{k.sum+1,k.x-a[k.x][k.y],k.y-a[k.x][k.y],1,1,1,1,1,1,1,0});
			v[k.x-a[k.x][k.y]][k.y-a[k.x][k.y]][8]=1;
			if(k.x-a[k.x][k.y]==n&&k.y-a[k.x][k.y]==m){
				printf("%d\n",k.sum+1);
				return 0;
			}
		}//8个方向的枚举结束
	}
	puts("NEVER");//如果不能到达，输出"NEVER"
    return 0;
}
```

写了40分钟，管理员大大给过哈

---

## 作者：翼德天尊 (赞：13)

**又是一道经典的bfs题！**

[题目传送门](https://www.luogu.com.cn/problem/P1301)

让我们一起分析吧！

------------
### STEP 1 分析题意

1.给你一幅图，每个点都有它的马力值（能走多远）

2.需求最短长度——用广搜！

3.每一步走的方向不能和上一步一样——加了条件，判断是否走过该点的数组要多开一维！

4.有答案——输出答案；无答案——输出“NEVER”


------------
### STEP 2 逐步给代码
#### （注释在STEP 3，这个仅供有某一步不会的朋友观看）

**第一步：输入**
```
int n,m,ma[i][j];
scanf("%d %d",&m,&n);
for (int i=1;i<=n;i++){
	for (int j=1;j<=m;j++){
		scanf("%d",&ma[i][j]);
	}
}
```
**第二步：bfs（敲黑板）+ 有答案输出**
```
int dx[8]={0,0,1,-1,1,1,-1,-1};
int dy[8]={1,-1,0,0,-1,1,1,-1};
int v[101][101][8],ans[101][101][8];
queue<int> q[3];
q[0].push(1);q[1].push(1);q[2].push(3);
for (int i=0;i<8;i++) v[1][1][i]=1;
while (!q[0].empty()){
	int x=q[0].front(),y=q[1].front(),f=q[2].front();
	q[0].pop();q[1].pop();q[2].pop();
	int s=ans[x][y][f]+1;
	if (x==n&&y==m){
		printf("%d\n",s-1);
		return 0;
	}
	for (int i=0;i<8;i++){
		int xx=x+dx[i]*ma[x][y],yy=y+dy[i]*ma[x][y];
		if (xx>=1&&xx<=n&&yy>=1&&yy<=m&&v[xx][yy][i]==0&&f!=i){
			v[xx][yy][i]=1;
			ans[xx][yy][i]=s;
			q[0].push(xx);q[1].push(yy);q[2].push(i);
		}
	}
}
```
**第三步：无答案输出**
```
//while循环外
printf("NEVER\n");
```




------------

### STEP 3 AC代码及完整注释

**代码超短的哦 ~~（小声bb）~~**

```cpp
#include <bits/stdc++.h>//完美万能头
using namespace std;
int n,m,ma[101][101],v[101][101][8],ans[101][101][8];//分别为行，列，地图，记录是否走过数组（8个方向再开一维）以及每个点每个方向的最小步数
int dx[8]={0,0,1,-1,1,1,-1,-1};
int dy[8]={1,-1,0,0,-1,1,1,-1};//移动数组
int main(){
	scanf("%d %d",&m,&n);//题中n为行，m为列，所以反着输入
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){
			scanf("%d",&ma[i][j]);
		}
	}//正常输入
	queue<int> q[3];//每个下标分别对应x坐标，y坐标和来时方向
	q[0].push(1);q[1].push(1);q[2].push(3);//放入第一个点（第一个点的方向随便放啦）
	for (int i=0;i<8;i++) v[1][1][i]=1;//因为第一个点不用考虑来时方向，所以不会每个方向都可以标记
	while (!q[0].empty()){
		int x=q[0].front(),y=q[1].front(),f=q[2].front();//取出
		q[0].pop();q[1].pop();q[2].pop();//删除
		int s=ans[x][y][f]+1;//储存该轮循环将有的最小步数
		if (x==n&&y==m){
			printf("%d\n",s-1);
			return 0;
		}//符合条件直接输出（上面+1下面减回来）
		for (int i=0;i<8;i++){//八个方向
			int xx=x+dx[i]*ma[x][y],yy=y+dy[i]*ma[x][y];//该方向将走到的位置
			if (xx>=1&&xx<=n&&yy>=1&&yy<=m&&v[xx][yy][i]==0&&f!=i){//如果不越界且该点该方向没有走过并且来时方向跟枚举的不一样
				v[xx][yy][i]=1;//标记
				ans[xx][yy][i]=s;//标记
				q[0].push(xx);q[1].push(yy);q[2].push(i);//放入队列
			}
		}
	}
	printf("NEVER\n");//队列已经空了却还能运行到这里，说明无法到达终点
    return 0;//好习惯++
}
```


------------
### STEP 4 完结撒花！

这篇题解终于完美地结束啦！你有没有恍然大悟呢？如果还有问题不懂，欢迎评论区留言哦，我会第一时间回复的。

如果都明白了，就**点个赞**纪念一下你的成长吧！

管理员大大求过QAQ


---

## 作者：kokodayou (赞：11)

## 这是一道经典的迷宫问题……
### Obviously，搜索无非广搜与深搜

简单介绍一下今天的两位主人公：DFS（江湖人称深搜）&&  BFS（人称广搜）

### 深搜

深搜就是在递归中查找最佳路径的一种搜索策略，属于一条路走到黑，不撞南墙不回头的那种。。

### 广搜

广搜一般使用队列实现（配合c++的STL大法中的queue队列更是如鱼得水，可惜本人掌握不熟，这里就不献丑了），搜索出从一个点可以到达的所有位置，并把这个新位置加入到队列当中，一般一个while循环即可实现。

##### 至于二者到底谁比较好还要具体题目具体分析

**下面简单介绍一下我在这道题的做题思路吧，不喜勿喷……**

看到标签大大的搜索

~~连BFS还是DFS都不说让我怎么办！~~

### 都试试吧…………

~~行云流水~~打出一段DFS

#### DFS CODE
```cpp
#include<bits/stdc++.h>
#define no "NEVER"
using namespace std;
int n,m,ans,Min=9999999999,a[110][110],dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};
bool pd[110][110];
void dfs(int x,int y,int z){
	if(x==m&&y==n){
		pp=1;
		if(ans<Min)Min=ans;
		return;
	}
	for(int i=0;i<8;i++){
		if(i==z)continue;
		int xa=x+dx[i]*a[x][y],ya=y+dy[i]*a[x][y];
		if(xa<0||xa>m||ya<0||ya>n||pd[xa][ya])continue;
		else{
			ans++;
			pd[x][y]=1;
			dfs(xa,ya,i);
			pd[x][y]=0;
			ans--;
		}
	}
}
int main(){
	cin>>n>>m;
	for(register int i=1;i<=m;i++)
		for(register int j=1;j<=n;j++)
			scanf("%d",&a[i][j]);
	dfs(1,1,8);
	if(Min!=9999999999)cout<<Min;
	else cout<<no;
	return 0;
}
```
~~快乐~~提交了一遍

 _结果可想而知……TLE了八个点_ 
 
 [车祸现场](https://www.luogu.org/record/25651334)
 
 在~~费尽心思~~考虑了可能的剪枝之后得出结论：
## DFS是个didi！直接去世……

------------


话不多说，转战BFS

核心搜索部分
```cpp
do{            
		head++;
		if(team[head][0] == m && team[head][1] == n)
		{
			if(ans[head] < Min)Min = ans[head];
			continue;
		}
		for(register int i = 0; i < 8; i++)
		{
			if(i == b[head])continue;
			int xa = team[head][0] + dx[i] * a[team[head][0]][team[head][1]], ya = team[head][1] + dy[i] * a[team[head][0]][team[head][1]];
			if (xa < 0 || xa > m || ya < 0 || ya > n || pd[team[head][0]][team[head][1]][i])continue;
			else
			{
				pd[team[head][0]][team[head][1]][i] = 1;
				team[++tail][0] = xa;
				team[tail][1] = ya;
				ans[tail] = ans[head] + 1;
				b[tail] = i;
			}
		}
	}while (head != tail);
```

再加上一些搜索的日常套路，~~AC其实很简单的啦！~~

# CODE
```cpp
#include<bits/stdc++.h>
#define no "NEVER"
using namespace std;
int n,m,tail=1,head=0,Min=999999999,ans[233333],b[233333];
int a[110][110],team[233333][2],dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};    //提前处理出走法，真的好方便 
bool pd[110][110][50];          //判断一个点的某方向能不能走 
int main()
{
	cin >> n >> m;
	for(register int i = 1; i <= m; i++)           //据说register可以快一点 
		for(register int j = 1; j <= n; j++)
			scanf("%d",&a[i][j]);           //水的不能在水的输入 
	team[1][0] = team[1][1] = 1;
	b[1] = 9;                 //起点方向无限制，可以自由飞翔，但如果是0则不能朝左上走 
	do{            
		head++;
		if(team[head][0] == m && team[head][1] == n)
		{       //更新 
			if(ans[head] < Min)Min = ans[head];         //如果此点此方向已走过 
			continue;
		}
		for(register int i = 0; i < 8; i++)
		{         //循环路径 
			if(i == b[head])continue;
			int xa = team[head][0] + dx[i] * a[team[head][0]][team[head][1]], ya = team[head][1] + dy[i] * a[team[head][0]][team[head][1]];
			//算出下一个点前往何方 
			if (xa < 0 || xa > m || ya < 0 || ya > n || pd[team[head][0]][team[head][1]][i])continue;
			else
			{                  //在队列后插入一个点 
				pd[team[head][0]][team[head][1]][i] = 1;
				team[++tail][0] = xa;
				team[tail][1] = ya;
				ans[tail] = ans[head] + 1;
				b[tail] = i;
			}
		}
	}while (head != tail);    //BFS循环 
	if (Min != 999999999) cout << Min;     //如果没有找到路径 
	else cout << no;        //为了好看define了一下 
	return 0;             //完美AC 
}
```

------------
本蒟蒻的第三篇题解（第二篇不知道为什么题目过长没给过），君读至此既是缘，欢迎评论进行讨论。

~~写了一晚上的一篇题解~~，望管理员爸爸审过！


---

## 作者：Dispwnl (赞：7)

典型的$bfs$

因为以前过的全是Pascal，于是发一篇c++

代码：

```cpp
# include<iostream>
# include<cstring>
using namespace std;
int n,m;
int a[101][101];
int s[101][101];
int mv1[8]={1,1,-1,-1,1,-1,0,0};
int mv2[8]={0,1,-1,0,-1,1,-1,1};
int f[1000001][4];//f[i][0]存横坐标，f[i][1]存纵坐标，f[i][2]存上一个点的最少步数，f[i][3]存上一次的方向
bool use[101][101][8];//存这个点从这个方向来过没（就是因为这个80分！！）
void bfs()
{
    int he=1,ta=1;
    f[1][0]=1;
    f[1][1]=1;
    f[1][3]=-1;
    while(he<=ta)//bfs模板，队列储存
    {
        for(int i=0;i<8;i++)//枚举各个方向
          if(i!=f[he][3])//不是上一次的方向
          {
              int x=f[he][0]+mv1[i]*a[f[he][0]][f[he][1]];
              int y=f[he][1]+mv2[i]*a[f[he][0]][f[he][1]];
              if(x>=1&&x<=m&&y>=1&&y<=n&&!use[x][y][i])
              {
                  use[x][y][i]=1;//这个点从这个方向来过了
                  s[x][y]=f[he][2]+1;
                  ta++;
                  f[ta][0]=x;
                  f[ta][1]=y;
                  f[ta][2]=s[x][y];
                  f[ta][3]=i;
            }
            if(s[m][n]>0) return;//有值就结束
          }
        he++;
    }
    return;
}
int main()
{
    memset(s,-1,sizeof(s));
    cin>>n>>m;//注意是m行n列，但先输入n
    for(int i=1;i<=m;i++)
      for(int j=1;j<=n;j++)
        cin>>a[i][j];
    s[1][1]=0;
    bfs();//广搜
    if(s[m][n]>0) cout<<s[m][n];
    else cout<<"NEVER";
    return 0;
}
```

---

## 作者：daihang (赞：3)

# 非常~~弱智~~清晰的BFS题解
## 只因自认为码风不错所以发一发
思路很简单
正常的bfs，起点1,1，终点n，m。

------------

#### 注意：读入的时候是列在前行在后

判重要加一位方向vis[i][j][dir]表示第i行第j列方向为dir是否来过。不加就是70分！！！

------------

奉上代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int dx[8]={0,0,1,1,-1,1,-1,-1};
int dy[8]={1,-1,0,1,-1,-1,1,0};
struct node{
    int x;
    int y;
    int step;
    int dir;
    node(){

    }
    node(int qx,int qy,int ss,int dd){
        x=qx;
        y=qy;
        step=ss;
        dir=dd;
    }
};
queue<node> q;
bool vis[105][105][10];
int mp[105][105];
bool check(int x,int y,int dir){
    if(x>=1&&x<=n&&y>=1&&y<=m&&vis[x][y][dir]==0){
        vis[x][y][dir]=1;
        return 1;
    }
    return 0;
}
int main(){
    cin>>m>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>mp[i][j];
        }
    }
    q.push(node(1,1,0,10));
    for(int i=0;i<=7;i++)    vis[1][1][i]=1;
    while(!q.empty()){
        int xx=q.front().x;
        int yy=q.front().y;
        if(xx==n&&yy==m){
            cout<<q.front().step;
            return 0;
        }
        for(int i=0;i<=7;i++){
            if(i!=q.front().dir){
                int nx=xx+mp[xx][yy]*dx[i];
                int ny=yy+mp[xx][yy]*dy[i];
                if(check(nx,ny,i)){
                    q.push(node(nx,ny,q.front().step+1,i));
                }
            }
        }
        q.pop();
    }
    cout<<"NEVER"<<endl;
}
```


---

## 作者：二哥啃菜包 (赞：3)

不拉不拉不拉，~~我是不会告诉你们wo少加了一个方向看了一个上午！！！~~一个悲伤的故事。
好啦好了，开始！；

这题很明显的bfs看前面大佬一个个身怀绝技，小juruo看的瑟瑟发抖。

但这题还要用一个数组来存x，y来的方向。

然后就会常愉悦的bfs开始了！
bfs不多讲了！！！









	#include<cstdio>
	#include<cstring>
	#include<iostream>
	#include<queue>
	using namespace std;
	int n,m,ans;
	bool flag=0;
	#define N 105
	int map[N][N],vis[N][N][9];
	queue<int> q[4];
	int dx[8]={1,1,1,0,0,-1,-1,-1};//方向
	int dy[8]={0,1,-1,1,-1,1,-1,0};
	void bfs(int cx,int cy,int last){
	    if(vis[cx][cy][last]==0){
        q[0].push(cx);q[1].push(cy);q[2].push(last);q[3].push(0);
        for(int i=0;i<8;++i)vis[cx][cy][i]=1;
    }		
    while(!q[0].empty() && !q[1].empty() && !q[2].empty() && !q[3].empty()){
        int ax=q[0].front();q[0].pop();
		int ay=q[1].front();q[1].pop();
		int alast=q[2].front();q[2].pop();
		int sum=q[3].front();q[3].pop();
		int res=sum；//为了防止加七次，每次枚举方向初始化一下
        for(int i=0;i<8;++i)if(i!=alast){
            sum=res;
            int x=ax+dx[i]*map[ax][ay];int y=ay+dy[i]*map[ax][ay];
            if(x>n || x<1 || y>m || y<1 || vis[x][y][i]==1)continue;
			if(x==n && y==m)sum++,ans=min(ans,sum);
            if(vis[x][y][i]==0){
                vis[x][y][i]=1;
                sum+=1;
                q[0].push(x);q[1].push(y);q[2].push(i);q[3].push(sum);
    	        }
    	    }
   	 }
	}//不拉不拉丑陋的bfs
	int main(){
		cin>>n>>m;
    	for(int j=1;j<=m;++j)for(int i=1;i<=n;++i)cin>>map[i][j];	
    	ans=1e9;
    	bfs(1,1,8);
    	if(ans<1e9){
    	    cout<<ans<<endl;
    	    return 0;
    	}
   	 else cout<<"NEVER"<<endl;//若没有更新，输出他死了
	}
    好吃好吃，

---

## 作者：zhangyuhan (赞：1)

一道练$bfs$的好题。

首先一看，这道题明显是搜索。再一看，求的是最短步数，那就明显用$bfs$了。

$bfs$肯定需要一个队列来存储各种状态，所以我们得考虑这个队列是什么类型的。

根据题目，首先肯定需要坐标和步数，那就很明显需要三个量：$x$,$y$,$step$。

接着再看，题目中要求两次跳跃的方向不相同，所以再设个$way$来存储方向。

队列定义好后，就要开始广搜喽。

枚举八个方向，依次判断能否跳跃，如果能跳跃，定义状态，存入队列。如果有坐标是终点，输出步数，结束；如果找不到合适的跳跃方案，输出$NEVER$。

这是很朴素的想法，如果你照着这样打，你会发现只得$30$分，既$TLE$又$MLE$。

所以我们考虑优化。定义$vis[x][y][i]$，表示从前一个格子以第$i$个方向来到$(x,y)$。如果是的，就不用再放入队列了。

整体思路大概就是这样的，细节就看代码注释吧。

```cpp
#include <iostream>
#include <queue>
using namespace std;

const int dir[8][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}, {1, -1}, {-1, 1}, {1, 1}, {-1, -1}};

//方向数组

struct node {
	int x, y, step, way;
};
queue<node> q;//队列定义

int n, m, map[110][110];
bool vis[110][110][110];

bool cango(int x, int y) {
	return x >= 1 && x <= n && y >= 1 && y <= m;
}//判断是否超出边界

void bfs() {
	node st;
	st.x = 1;
	st.y = 1;
	st.step = 0;
	st.way = 8;//初始没有方向
	q.push(st);
	while (!q.empty()) {
		node now = q.front();
		q.pop();
		if (now.x == n && now.y == m) {
			cout << now.step << endl;
			return ;
		}//如果成立，直接输出并结束
		for (int i=0; i<8; i++) {
			int nx = now.x + dir[i][0] * map[now.x][now.y], ny = now.y + dir[i][1] * map[now.x][now.y];
			if (cango(nx, ny) && i != now.way && !vis[nx][ny][i]) {
				node next;
				next.x = nx;
				next.y = ny;
				next.step = now.step + 1;
				next.way = i;
				vis[nx][ny][i] = true;
				q.push(next);
			}//判断+放入队列
		}
	}
	cout << "NEVER" << endl;
}

int main() {
	cin >> m >> n;//注意，先输入列数再输入行数
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++) cin >> map[i][j];
	bfs();
	return 0;//完结撒花！
}
```

---

## 作者：ModestCoder_ (赞：1)

简单bfs

想想状态数，$vis_{x,y,d}$表示到$(x,y)$并且方向为$d$

可以做到不重不漏，复杂度$O(nmd)$可以接受

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 110
using namespace std;
int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};
int n, m, a[maxn][maxn], vis[maxn][maxn][10];
struct data{
	int x, y, ans, d;
};
queue <data> q;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int main(){
	m = read(), n = read();
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) a[i][j] = read();
	q.push((data){1, 1, 0, -1});
	while (!q.empty()){
		data tmp = q.front(); q.pop();
		for (int i = 0; i < 8; ++i){
			if (i == tmp.d) continue;
			int x = tmp.x + dx[i] * a[tmp.x][tmp.y], y = tmp.y + dy[i] * a[tmp.x][tmp.y];
			if (x > 0 && y > 0 && x <= n && y <= m) if (!vis[x][y][i]){
				vis[x][y][i] = 1;
				q.push((data){x, y, tmp.ans + 1, i});
				if (x == n && y == m) return printf("%d\n", tmp.ans + 1), 0;
			}
		}
	}
	puts("NEVER");
	return 0;
}
```


---

## 作者：AveMarina (赞：0)

## BFS
### 本题与模板题的区别
1. 走法，这个题的走法不是固定的，而是根据当前点的值决定
2. 一个方向不能走两次
### 如何解决
1. 其实我们可以发现，不管当前点的值是多少，走法是不变的，变的只是走的步数，所以可以直接将走法先写出来，然后乘上当前点的值就行了
2. 我们使用一个$vis$数组来标记当前点是否走过，从哪个方向走过，也就是多开一维记录当前点被访问的方向。然后再在结构体里加一个$pre$变量，用来记录当前点是哪种走法。如果当前点被某种走法走过，或者当前点的走法和上一个点相同，就进行剪枝。**注意，这里只用记录上一个点走法的这个剪枝，只会得70分，因为其实某个点可以从多个方向走过来，除了当前点，但是如果只判断方向是否相同，就会默认剪去其它几种走法。**
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
// 注意空间开大点，不然会蜜汁RE
const int N = 1110;
int n, m;
int graph[N][N];
bool vis[N][N][10];
int mv[8][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
struct Node {
	int x, y, step, pre;
	Node (int x, int y, int step, int pre) : x(x), y(y), step(step), pre(pre) {};
	Node () {};
} que[N * N];
int bfs() {
	int qtop = 0, qback = 0;
	que[qtop] = Node(1, 1, 0, -1);
	while (qtop <= qback) {
		Node now = que[qtop++];
		if (now.x == n && now.y == m) return now.step;
		int nv = graph[now.x][now.y];
		for (int i = 0; i < 8; i++) {
			// 应该是从当前点偏移，而不是直接走 
			int nx = now.x + mv[i][0] * nv, ny = now.y + mv[i][1] * nv;
			if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
			// 如果下一个点已经以方向i走过一遍了，或者当前走法和上一个点的走法相同，就剪掉 
			if (vis[nx][ny][i] || i == now.pre) continue;
			vis[nx][ny][i] = true;
			que[++qback] = Node(nx, ny, now.step + 1, i);
		}
	}
	return -1;
} 
int main() {
	// 注意行列是反着输入的 
	scanf("%d%d", &m, &n);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%d", &graph[i][j]);
		}
	}
	int res = bfs();
	if (res == -1) printf("NEVER");
	else printf("%d", res);
	return 0;
}
```

---

## 作者：Sherlock_Ezreal (赞：0)

#### 说实话，这是一个非常坑的题
好的我先来分析一下我的思路:用road[i][j][k]来记录从k方向到点(i,j)的最短路径.这是一个非常高能的解法,因为,我是用dfs找到点,然后用bfs找到路径......
### 现在，上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int city[101][101];
int road[101][101][9];
//1 向上||2 向右||3 向下||4 向左||5 向右上||6 向右下||7 向左下||8 向左上
/* 
    注意：1~8表示的方向是相对目标进入的方向，如
       1  2  3
       1  a  b  c
       2  d  e  f
       3  g  h  i
    其中 h 经过 1 向上 操作到达 e,所以从 h 到 e 的最小步数记为 road[2][2][1]
*/
int find(int a,int b,int c)//一个用于寻找最小值的自定义函数(bfs方式)
//a,b是传过来的d位置;c是传过来的方向 
{
	int minn=0x6f6f6f;//预设minn为一个相对无限值,反正无论咋样都走不了0x6f6f6f步 
	for(int i=1;i<=8;i++)//i表示方向 
	{
		if(i==c)continue;//如果方向为c,即不能从这个方向进入
          			 //否则违背题意:不能连续两次从同一个方向过来 
		minn=min(road[a][b][i],minn);//用最小的可执行方向作为下一位置对应方向的最小步数 
	}
	return minn;
}
void bfs(int a,int b)
{
	if(a>m||a<=0||b>n||b<=0)return;//越界判断 
	if(b-city[a][b]>0)
	{
	    int mid=find(a,b,2);
		if(mid+1<road[a][b-city[a][b]][2])//向左位移,即目标向右判断 
		{
	        road[a][b-city[a][b]][2]=mid+1;//mid要+1,因为未在函数中加上去了  
	                                       //(P.S:主要是博主开始忘了......)
			bfs(a,b-city[a][b]);//(dfs)深搜开始
	    }
	}
	if(a+city[a][b]<=m) 
	{
		int mid=find(a,b,1);
		if(mid+1<road[a+city[a][b]][b][1])//向下位移,目标向上判断 
		{
	        road[a+city[a][b]][b][1]=mid+1;
	        bfs(a+city[a][b],b);
	    }
	}
	if(b+city[a][b]<=n)
	{
	    int mid=find(a,b,4);
	    if(mid+1<road[a][b+city[a][b]][4])//向右位移 
	    {
	    	road[a][b+city[a][b]][4]=mid+1;
	    	bfs(a,b+city[a][b]);
		}
	}
	if(a-city[a][b]>0)
	{
	    int mid=find(a,b,3);
	    if(mid+1<road[a-city[a][b]][b][3])//向上位移 
	    {
	    	road[a-city[a][b]][b][3]=mid+1;
	    	bfs(a-city[a][b],b);
		}
	}
	if(b-city[a][b]>0&&a+city[a][b]<=m)
	{
		int mid=find(a,b,5);
		if(mid+1<road[a+city[a][b]][b-city[a][b]][5])//向左下位移,目标向右上判断 
		{
			road[a+city[a][b]][b-city[a][b]][5]=mid+1;
			bfs(a+city[a][b],b-city[a][b]);
		}
	}
	if(b+city[a][b]<=n&&a+city[a][b]<=m)
	{
		int mid=find(a,b,8);
		if(mid+1<road[a+city[a][b]][b+city[a][b]][8])//向右下位移,目标向左上判断 
		{
			road[a+city[a][b]][b+city[a][b]][8]=mid+1;
			bfs(a+city[a][b],b+city[a][b]);
		}
	}	    
	if(b+city[a][b]<=n&&a-city[a][b]>0)
	{
		int mid=find(a,b,7);
		if(mid+1<road[a-city[a][b]][b+city[a][b]][7])//向右上位移 
		{
			road[a-city[a][b]][b+city[a][b]][7]=mid+1;
			bfs(a-city[a][b],b+city[a][b]);
		}
	}	    
	if(b-city[a][b]>0&&a-city[a][b]>0)
	{
		int mid=find(a,b,6);
		if(mid+1<road[a-city[a][b]][b-city[a][b]][6])//向左上位移 
		{
			road[a-city[a][b]][b-city[a][b]][6]=mid+1;
			bfs(a-city[a][b],b-city[a][b]);
		}
	}
	return;
}
int main()
{
	memset(city,0,sizeof(city));
	memset(road,0,sizeof(road));
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	    for(int j=1;j<=n;j++)
	    {
	        cin>>city[i][j];
	        for(int k=1;k<=8;k++)
	            road[i][j][k]=0x6f6f6f;//预设最大值,同时无法到达的点也是这个参数(因为无法更新点数据) 
	    }
	for(int i=1;i<=8;i++)road[1][1][i]=0;
	bfs(1,1);
	int minn=find(m,n,9);//(m,n)点的坐标； 
	if(minn==0x6f6f6f)cout<<"NEVER";//无法到达 
	else cout<<minn;
	return 0;
}
```
不用怀疑,我不会坑你们的

---

## 作者：LlLlCc (赞：0)

一道典型的BFS~~水~~题，题解貌似不多啊。

**在网格图里刷起点到终点的最短路，首先想到的就应该是BFS（Dfs不确定能不能过）**

这题还是很明显的，就是叫你求（1,1）到（n，m）的最短路，但这题和普通的模板题还是有些区别的。**不能连续走同一个方向**。

有些人可能忽略了这一点，就只该判断了方向能不能走（50或60的应该是这个原因）。仔细想一想，其实从不同方向走过来会对答案有不同的影响，所以要开三维数组记录x，y，k（方向）是否走过。

代码：
```
#include<bits/stdc++.h>
#define maxn 1005
using namespace std;
const int flg[8][2]={{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};
int n,m,a[maxn][maxn],ans;
bool vis[maxn][maxn][8];
struct lc{
	int x,y,k,z;
}Q[maxn*maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
    while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
inline bool check(int x,int y,int k){if (x<1||x>n||y<1||y>m||vis[x][y][k]) return 0;vis[x][y][k]=1;return 1;}
inline void Bfs(){
	int hed=0,til=1;
	Q[1].x=1,Q[1].y=1;
	for (int i=0;i<8;i++) vis[1][1][i]=1;
	while (hed!=til){
		hed++;
		for (int i=0;i<8;i++){
			if (i==Q[hed].k||!check(Q[hed].x+a[Q[hed].x][Q[hed].y]*flg[i][0],Q[hed].y+a[Q[hed].x][Q[hed].y]*flg[i][1],i)) continue;
			Q[++til].k=i,Q[til].x=Q[hed].x+a[Q[hed].x][Q[hed].y]*flg[i][0],Q[til].y=Q[hed].y+a[Q[hed].x][Q[hed].y]*flg[i][1];
			Q[til].z=Q[hed].z+1;
			if (Q[til].x==n&&Q[til].y==m){printf("%d",Q[til].z);exit(0);}
		}
	}
}
int main(){
	m=read(),n=read();
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++) a[i][j]=read();
	Bfs();
	printf("NEVER");
	return 0;
}
```


---

## 作者：睿屿青衫 (赞：0)

#我做了一晚上，先dfs（相对擅长，主要是bfs不太会==），tle，20分，注意别偷代码20！20！20！

##接着改bfs，各种改，20（re），10（re），10（wa），20（wa）崩溃！

###这道***题到底该怎么做！

如果你问我为什么发这20分的代码，我只能说我照着唯一的题解的思路改不明白，不如贴上换一种解法的dfs，可能你们看看我的代码然后改成bfs就能A掉了

···

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define maxn 5050
int p[maxn][maxn],q[maxn][maxn];
int n,m,tot=0x7f,dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,1,-1,1,0,-1};
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
     {
         x=x*10+ch-'0';
         ch=getchar();
     }
    return x;
}
void dfs(int x,int y,int a,int b,int s)
{
    if(x==m&&y==n)
    {
        if(s<tot) tot=s;
        return;
    }
    for(int i=0;i<8;++i)
    {
        if(dx[i]==a&&dy[i]==b) continue;
        int xx=x+p[x][y]*dx[i],yy=y+p[x][y]*dy[i];
        if(xx>0&&xx<=m&&yy>0&&yy<=n&&!q[xx][yy])
         {
             q[xx][yy]=1;
             dfs(xx,yy,dx[i],dy[i],s+1);
             q[xx][yy]=0;
         }
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;++i)
     for(int j=1;j<=n;++j)
      p[i][j]=read();
    dfs(1,1,0,0,0);
    if(tot==0x7f) printf("NEYER\n");
     else printf("%d\n",tot);
    return 0;
}
···cpp
```

---

## 作者：Youngsc (赞：0)

[Youngsc](http://youngscc.github.io/)

显然是~~BFS~~，跟[马的遍历](https://www.luogu.org/problem/show?pid=1443)差不多，只要按他说的来~~宽搜一下~~就行。关于打标记的部分，我们可以记一个数组$v[x][y][k]$表示在$(x,y)$这个点是否往$k$方向跳过，如果跳过,那么下次搜索到那个地方是白搜，效果一样，数字还不优。零外为了好记录我将$n$和$m$调换了一下，要注意。


## 代码在这里


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <vector>
# include <queue>
# include <cmath>
# define R register
# define LL long long
# define db double

using namespace std;

struct zx{int x,y,z,t;};
queue <zx> q;
int n,m,a[110][110];
const int dx[] = {1,0,-1,0,1,1,-1,-1};
const int dy[] = {0,1,0,-1,-1,1,1,-1};
bool v[110][110][8];

template <typename T> void in(R T &a){
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

template <typename T> void maxx(R T &a,const T b){a>b? 0:a=b;}
template <typename T> void minn(R T &a,const T b){a<b? 0:a=b;}

inline int youngsc(){
    in(n),in(m);
    for(R int j=1; j<=m; ++j)//注意我的i,j顺序
        for(R int i=1; i<=n; ++i)//
            in(a[i][j]);
    q.push((zx){1,1,-1,0});//分别是x，y，上一次的方向，步数

    while(!q.empty()){
        R zx now = q.front();
        q.pop();
        R int x = now.x,y = now.y,d = now.z,t = now.t;
        for(R int i=0; i<=7; ++i)
        {
            R int tx = x+dx[i]*a[x][y],ty = y+dy[i]*a[x][y];
            if(tx<1||ty<1||tx>n||ty>m||v[x][y][i]||i==d) continue;
            v[x][y][i] = 1;//标记当前状态已经搜索过
            if(tx == n&&ty == m) printf("%d",t+1),exit(0);
            q.push((zx){tx,ty,i,t+1});
        }
    }
    printf("NEVER");
    return 0;
}
int yg = youngsc();
int main(){;}

```
（减少代码复制，共创美好洛谷）


---


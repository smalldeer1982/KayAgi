# 可见矩形

## 题目描述

给定平面上 $n$ 个互不相交（指公共面积为零）的正方形，它们的顶点坐标均为整数。设坐标原点为 $O(0,0)$。对于任一正方形 $R$，如果可以找到 $R$ 的边上 $2$ 个不同的点 $A$ 和 $B$，使 $\triangle OAB$ 的内部与其他正方形无公共点，则称正方形 $R$ 是从 $O$ 点可见的正方形。

对于给定的 $n$ 个互不相交的正方形，计算从坐标原点 $O$ 可见的正方形个数。

## 样例 #1

### 输入

```
3
2 6 4
1 4 1
2 4 1
```

### 输出

```
3
```

# 题解

## 作者：BFSBFSBFSBFS (赞：7)

~~(ggb大法好.).~~

题意,给出n个互不相交的正方形.求有多少个可见的正方形.

设原点(0,0)为O.

**1个正方形是可见的条件为:**

**在正方形边上选取2个不同的点X,Y.存在1种方法使△OXY与其他正方形没有公共点.**

可以看出.△OXY面积越小，与其他正方形的公共部分只减不增.

在**X = Y**时.面积为0.

由于X与Y不能相同,可以使**X无限接近Y.**

这个时候只要求线段**OY**与其他正方形有没有相交了.

怎么求相交.?

**对于正方形T边上2点X,Y.在∠XOY内,△OXY外的正方形,边上任取点Z.OZ与T必然有交.**

什么东西.?**就是正方形被完全覆盖(不可见.)**.

~~(这不是废话吗线都是直的- -.).~~.

很显然,X,Y取到正方形左上右下端点,∠XOY最大.

结合之前**"X无限接近Y"**.边正好不超过OX或者OY的正方形同样不可见.

(事实上就是只能看见1个点....不满足3角形.).

![.](https://cdn.luogu.com.cn/upload/pic/46733.png)

poi区域不可见.

如何判断是否在poi里.?

**斜率.对于正方形上任意1点Z.OZ的斜率在OX与OY之间.**

用$k1_i,k2_i$表示斜率区间.实际上只要判断区间是否完全被覆盖.

n<=1000. n²枚举即可..

不过.在△OXY内的正方形同样满足斜率.但他可见.

而且上面遗留了个问题.1些正方形的poi区间可以共同覆盖.

........

我试图通过优先级消除影响.先枚举离O"比较近"的点.

依照题意.△OXY内所有正方形必须先枚举到.

被这个正方形或者多个正方形~~弄得不可见~~的正方形必须在这之后枚举.

如何确定优先关键字.?

只用1个点很难受,到处反例.我是找不出来了...

接上图- -.并接1句废话- -.

**点X左侧所有点横坐标<X的横坐标.点Y下侧所有点纵坐标<Y的纵坐标.**

于是按输入点横纵坐标取min排序就好了.

~~最后才~~发现...**这东西具有良好的传递性.相互之间不会干扰.**.

~~多亏了题目限制.真是令人开心.~~.

排完序后1~n枚举.询问在前面所有区间共同覆盖后能否完全覆盖这个区间.

代码.请删掉注释食用.

```cpp
program P1302;
 uses math,Garrayutils;
 const
  sqrnd=1008208820;
 type
  we=record
   x,y,z:longint;
  end;
  wa=array[0..1001] of we;
  wr=array[0..1001] of real;
  cmp=object
   public
   function c(x,y:we):boolean;inline;
  end;
  sort=specialize Torderingarrayutils<wa,we,cmp>;
 var
  x,y,z:wa;
  i,j,n,ssum:longint;
  p1,p2:real;
  k1,k2:wr;
 function cmp.c(x,y:we):boolean;inline;//比较.
  begin
   //exit(x.x+x.y<y.x+y.y);
   exit(min(sqrt(sqr(x.x+x.z)+sqr(x.y)),sqrt(sqr(x.x)+sqr(x.y+x.z)))<min(sqrt(sqr(y.y)+sqr(y.z+y.x)),sqrt(sqr(y.z+y.y)+sqr(y.x))));
  end;
 begin
  readln(n);
  for i:=0 to n-1 do
   readln(x[i].x,x[i].y,x[i].z);
  sort.sort(x,n);       //按奇怪的性质排序.
  ssum:=0;
  p1:=1008208820;
  p2:=0;
  for i:=0 to n-1 do
   begin
    k1[i]:=x[i].y/(x[i].x+x[i].z);
    k2[i]:=(x[i].y+x[i].z)/x[i].x; //斜率区间.
    //if (k1<p1) or (k2>p2) then inc(ssum);
    //p1:=min(p1,k1);
    //p2:=max(p2,k2);
    p1:=k1[i];
    p2:=k2[i];
    for j:=0 to i-1 do  //通过排完序的区间判断覆盖.
     begin
      //if (k2[i]>k2[j]) or (k1[i]<k1[j]) then continue
      if k1[j]>p1 then break;
      p1:=max(p1,k2[j]);
     end;
    if p1<p2 then inc(ssum);
    p1:=k1[i];
    p2:=k2[i];
    for j:=i downto 0 do  //区间的插入排序.
     begin
      if j=0 then break;
      if p1>k1[j-1] then break;
      k1[j]:=k1[j-1];
      k2[j]:=k2[j-1];
     end;
    k1[j]:=p1;
    k2[j]:=p2;
   end;
  writeln(ssum);
 end.
```
###### 来自攻略组团队中混饭人员的贡献.

(ಡωಡ).


---

## 作者：lz174 (赞：6)

发一篇想法~~~~比较新颖的~~~~题解

## 准备工作

设正方形的左下端点（aa，bb）

边长为cc

参数cmp=aa+bb+cc

不难发现

cmp较小的正方形可以遮挡cmp较大的正方形

于是记录每个正方形的斜率范围

即最小斜率bb/(aa+cc)

和最大斜率(bb+cc)/aa

并针对cmp参数进行递增排序



------------
## 进入正题

建立二维数组a负责储存不可用的斜率范围

a数组奇数编号储存起始斜率

偶数编号储存截止斜率

于是便可用数组a表示所有不可用范围

初始的斜率范围即为k[1].s到k[1].l

下面依次使各正方形的斜率进入数组

第i号正方形进入数组：

比k[i].s还小的元素直接照抄，不需更改

直到找到第一个大于等于k[i].s的元素

若该元素编号为奇数，即为一个范围的起始位置

说明k[i].s的进入产生了一个新的不可用范围

直接使k[i].s进入数组

若该元素编号为偶数，即为一个范围的结束位置

说明k[i].s处在某个范围内部

不需要产生新的起始点，不进行操作

继续向下查找元素

处在k[i].s和k[i].l之间的元素无需理会

直到找到第一个大于等于k[i].l的元素

对k[i].l的操作跟k[i].s基本相同

不作过多说明

至于比k[i].l还大的元素

接着照抄......

有了这个思想

对于答案的判断也变得容易

详见代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
int ans;
struct node{
	double l,s,cmp;
}k[100100];
bool cmp(node x,node y){
	return x.cmp<y.cmp;
}
double a[10001][10001];
int cnt[10001];
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x*f;
}
int main(){
	n=read();
	int aa,bb,cc;
	for(int i=1;i<=n;i++){
		aa=read();
		bb=read();
		cc=read();
		k[i].l=(bb+cc)*1.0/aa;
		k[i].s=bb*1.0/(aa+cc);
		k[i].cmp=aa+bb+cc;
	}
	sort(k+1,k+1+n,cmp);
	a[1][1]=k[1].s;
	a[1][2]=k[1].l;
	cnt[1]=2;
	for(int i=2;i<=n;i++){
		int t=1;
		while(a[i-1][t]<k[i].s&&t<=cnt[i-1]){
			a[i][t]=a[i-1][t];
			t++;
		}
		int l=t;
		cnt[i]=t-1;
		if(t%2==1){
			a[i][++cnt[i]]=k[i].s;
			if(a[i-1][t]==a[i][t]) l=t+1;
		} 
		while(a[i-1][t]<=k[i].l&&t<=cnt[i-1]){
			t++;
		}
		int r=t;
		if(t%2==1){
			a[i][++cnt[i]]=k[i].l;
			if(a[i-1][t-1]==a[i][cnt[i]]) r--;
		} 
		while(t<=cnt[i-1]){
			a[i][++cnt[i]]=a[i-1][t]; 
			t++;
		}
		if(r-l>=1) ans++;
		else{
			if(r%2==1) ans++;
		}
	}
	cout<<ans+1;
	return 0;
}

由于第一个正方形没有任何遮挡限制

所以最后ans+1

如果对最后的答案处理不理解

可以对遮挡的范围进行比较

如果范围变大，则该正方形满足条件
```
```cpp

	sum[i]=0;
	for(int j=1;j<cnt[i];j+=2){
		sum[i]+=a[i][j+1]-a[i][j];
	}
	if(sum[i]>sum[i-1]) ans++;
```
别忘了sum[1]初始化=k[1].l-k[1].s

---

## 作者：Thronf (赞：3)

本蒟蒻的第一篇题解。
### 推导
首先，对于本题，很显然正方形都在第一象限，那么，可以用直线去模拟每一条“视线”。

你可以理解为固定你的坐标 $(0,0)$ ，同时转头，从 $x$ 轴逆时针转到 $y$ 轴。
   
然后对于每一根直线，通过区间判断来找出每条直线所“接触”的第一个正方形（这就需要你进行排序），把正方形打上标记（用结构体就可以搞定），最后用一个量来统计数量。
   
最后输出答案。
    
------------

### 几个问题（dalao 跳过）

1. 排序关键字
 
	这道题的调式点在于排序和精度，而排序又是比较难想到的，主要有以下两种错误排序：

- 顶点排序

	以左下角顶点为关键字，比较该点到 $O$ 点的距离，从小到大排序。 $(70pts)$ 
        
 - 斜线排序
        	
      以 $X+Y$ 为关键字进行排序。 $(80pts)$
     	
  显然，前面两组排序方式较为片面，所以，综合多方面考虑，那么最显而易见的就是以 $X+Y+L$ 进行排序。
  	
2. 精度选择
		
  	对于查找间隔，很多同志可能会先以斜率为查找对象，然而并不行，因为这样的话，对于与 $x$ 轴夹角小于 $\frac{\pi}{4}$ 的直线间隔太大，而大于 $\frac{\pi}{4}$ 的直线又间隔太小，如果要达到要求的精度 $(\frac{1}{10000},10000)$ 就一定会 TLE ，所以考虑用角度作为查找对象。这个精度大家要慢慢去找，我这里有个参考值是 $\frac{\pi}{180000}$ 。
    
   

------------
### 附上代码
	
 ```cpp
#include<bits/stdc++.h>
#define int long long // 防止忘记开long long 
//#define for(i,a,b,c,d) for(int i=a;i d b;i+=c)
using namespace std;
const double pi=3.141592653589793238462643383279502884197169399375105; // 圆周率 
struct sqare{
	double x1,y1,x2,y2;
	bool can;
}a[10005]; // 存储正方形（ can 用来打标记） 
int n,ans;
int check(int i,double k) // 判断是否经过正方形 
{
	if(a[i].x1*k<a[i].y2&&(a[i].x2*k>a[i].y1)) // 自己画图像 
	{
		if(!a[i].can)
		{
			a[i].can=1;
			return 1;
		}
		else
			return 2; // 如果已经有了隔挡的正方形 
	}
	return 0;
}
bool cmp(sqare a,sqare b) // 排序用
{
	return (a.x1+a.y2)<(b.x1+b.y2);
}
signed main() // 用了 #define int long long 就不能再用int main（）了 
{
	ios::sync_with_stdio(0); // 关缓冲区 
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		double x,y,l; // 输入 
		cin>>x>>y>>l;
		a[i].x1=x,a[i].x2=x+l,a[i].y1=y,a[i].y2=y+l;
	}
	sort(a+1,a+1+n,cmp); // 排序 
	for(double thita=pi/180000;thita<pi/2;thita+=pi/180000) // 枚举角度 
	{
		double k=tan(thita); // 算斜率 
		for(int i=1;i<=n;i++)
		{
			int c=check(i,k);
			if(c==1)
			{
				ans++;
				break;
			}
			else if(c==2)
				break;
		}
	}
	cout<<ans; 
	return 0; 
}
```

---

## 作者：DPair (赞：2)

## 【前言】
本题解提供一种奇奇怪怪的解法，十分不优秀要开 $O_2$ 才能过，仅供参考。

## 【思路】
直接枚举每一个斜率遇到的第一个正方形，使其可见即可。

不难发现，一个正方形有效的只有其左侧与下方的两条线段，一条符合 $x=k$ ，一条符合 $y=k$ ，我们只需判断当前斜率与该线段是否有交点即可，并取出最靠近原点的有交点的正方形，此时这个正方形是 **唯一一个通过当前斜率可见的正方形**。

为了优化这一过程，分别以 $x$ 为第一关键字， $y$ 为第一关键字进行排序，然后求出第一个符合 **当前线段与斜率有交点** 的线段所在正方形，那么这个正方形是这个斜率唯一可见的，可以直接跳出循环完成优化。

但枚举到的斜率不一定能完全扫描到所有可行的正方形，因此要多扫描一些斜率（详见代码）。

由于思路十分简单浅显，下面直接通过代码讲解：

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
inline void read(T &x){
    x = 0;int fu = 1;
    char c = getchar();
    while(c > 57 || c < 48){
    if(c == 45) fu = -1;
        c = getchar();
    }
    while(c <= 57 && c >= 48){
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    x *= fu;
}
template <typename T>
inline void fprint(T x){
    if(x < 0) putchar(45), x = -x;
    if(x > 9) fprint(x / 10);
    putchar(x % 10 + 48);
}
template <typename T>
inline void fprint(T x, char ch){
    fprint(x);putchar(ch);
}
//上面的快读快写不必多看。
struct NODE{
    int x, y, l, num;
}a[1010], b[1010];

inline bool cmp1(NODE x, NODE y){//以x为第一关键字
    return (x.x < y.x) || (x.x == y.x && x.y < y.y);
}

inline bool cmp2(NODE x, NODE y){//以y为第一关键字
    return (x.y < y.y) || (x.y == y.y && x.x < y.x);
}

int n, ans;
bool vis[1010];
typedef long double LD;
typedef pair <LD, LD> pdd;
#define eps 1e-8
inline pdd calcx(LD xx, LD yy, LD ll, LD k){//计算x一定的交点（以及其是否存在）
    LD ky = k * (LD)xx;
    if(ky >= yy && ky <= yy + ll) return make_pair((LD)xx, ky);
    else return make_pair(-1.0, -1.0);
}

inline pdd calcy(LD xx, LD yy, LD ll, LD invk){//计算y一定的交点（以及其是否存在）
    LD kx = invk * (LD)yy;
    if(kx >= xx&& kx <= xx + ll) return make_pair(kx, (LD)yy);
    else return make_pair(-1.0, -1.0);
}

inline void work(int xx, int yy){
    LD k = (LD) yy / (LD) xx, invk = (LD) xx / (LD) yy;
    pdd res = make_pair(100000, 100000);
    int ch = 0;
    for (register int i = 1;i <= n;++ i){
        pdd ret = calcx(a[i].x, a[i].y, a[i].l, k);
        if(ret.first > 0){//如果存在
            if(ret < res){
                res = ret;
                ch = a[i].num;
            }
            break;//可以直接跳出，因为当前一定最优
        }
    }
    for (register int i = 1;i <= n;++ i){
        pdd ret = calcy(b[i].x, b[i].y, b[i].l, invk);
        if(ret.first > 0){//同上
            if(ret < res){
                res = ret;
                ch = b[i].num;
            }
            break;
        }
    }
    vis[ch] = 1;
}

int main(){
    read(n);
    for (register int i = 1;i <= n;++ i){
        read(a[i].x);read(a[i].y);read(a[i].l);
        b[i].x = a[i].x;b[i].y = a[i].y;b[i].l = a[i].l;
        a[i].num = b[i].num = i;
    }
    sort(a + 1, a + n + 1, cmp1);
    sort(b + 1, b + n + 1, cmp2);
    for (register int i = 1;i <= 100000;++ i){//枚举每一个斜率
        work(i, 100000);
        work(100000, i);
    }
    for (register int i = 1;i <= n;++ i) ans += vis[i];
    fprint(ans, 10);
}
```
最终复杂度其实达到了 $O(100000n)$ ，算是卡过去的。

---

## 作者：WZWZWZWY (赞：0)

虽然是远古好题，但是很少人做，~~很大一部分原因是现有题解太难超了~~。有的思路不清晰或者代码可读性较差，让人看了跟看了一样……

~~于是我不得不自己思考出了一份不同的思路和代码，艰难地根据现有题解进行调试，一人、一杯水、一个屏幕、一个下午~~。


---


**思路**：通过一定顺序将正方形排序后，用 `set`（集合）维护经过正方形的直线的斜率所在的一些区间。初始化 `res = n`，枚举每个正方形，若每个通过它的直线的斜率都已经在集合内，说明这个正方形无法被看到，`res--`；否则在集合中添加区间 $[mink,maxk]$。$mink$、$maxk$ 表示通过这个正方形的直线中最小和最大的斜率。

最后输出 `res` 即可。

如何求一个正方形最小、大的斜率呢？因为是从原点出发的直线，所以经过正方形左上、右下的直线的斜率就是极值。证明显然。

然后排序怎么排呢？答案是按照 $x+y+l$ 升序排序。但是似乎没有题解给出为什么要这么排序，于是我又思考了半天。

![](https://cdn.luogu.com.cn/upload/image_hosting/wzq5545y.png)

（假设以图片最左下角建立平面直角坐标系。正方形的大小并非实际大小，只是为了方便描述。）

如图，上面的小正方形是边界情况，如果往右、上移动一点点就会有一部分被大正方形挡住看不见。

此时，

$$\begin{cases}x_2+l_2=x_1\\y_2=y_1+l_1\end{cases}$$

往右、上移动一点，等号就会变成大于等于号，并且可能会被大正方形遮住。但是往左、下就一定不会。不等号左右两边相加得：

$x_1+y_1+l_1\le x_2+y_2+l_2$

下面的小正方形：

$$\begin{cases}x_3=x_1+l_1\\y_3+l_3=y_1\end{cases}$$

往右、上移动一点也变成大于等于号。不等号左右两边相加得：

$x_1+y_1+l_1\le x_3+y_3+l_3$

以普遍理性而言，我们一定是遍历直线先经过到的正方形，即图中大正方形，再遍历小正方形。那么就相当于先遍历 $x+y+l$ 小的，那么按照这个排序即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

//const double eps = 1e-7; // 本题数据不需要用eps消除浮点数误差

struct squ { // 正方形的信息 
	int x, y, l;
	double mink, maxk; // 最小、大斜率 
} a[1005];

struct ks {
	double lk, rk; // k 在[lk,rk]之间 
	bool operator < (const ks &b) const { // 重载运算符 < 
		return lk < b.rk;
	}
};

bool cmp(squ a, squ b) { // 按照 x+y+l 升序排序 
	return a.x + a.y + a.l < b.x + b.y + b.l;
}
bool check(double x, double l, double r) { // 判断x是否在[l,r]间 
	return (x >= l) && (x <= r);
} 

int main() {
	int n; cin >> n;
	int res = n; // 可看见点的数量 
	
	for (int i = 1; i <= n; i++) {
		cin >> a[i].x >> a[i].y >> a[i].l;
		a[i].mink = 1.0 * a[i].y / (a[i].x + a[i].l); 
		a[i].maxk = 1.0 * (a[i].y + a[i].l) / a[i].x;
	}
	sort(a + 1, a + 1 + n, cmp);
	
	set <ks> k;
	k.insert((ks){a[1].mink, a[1].maxk});
	
	for (int i = 2; i <= n; i++) {
		double l = a[i].mink, r = a[i].maxk;
		
		// 在Set中寻找有没有区间包含完整的[l,r] 
		bool t = 0;
		auto it = k.begin();
		while (it != k.end()) {
			double lk2 = (*it).lk, rk2 = (*it).rk;
			if (l >= lk2 && r <= rk2) {
				t = 1;
				break;
			}
			it ++;
		}
		if (t) {
			res --;
			continue;
		}

		// 将[l,r]插入Set 
		it = k.begin();
		while (it != k.end()) {
			double lk2 = (*it).lk, rk2 = (*it).rk;
			if (check(lk2, l, r) || check(l, lk2, rk2)) { // 合并区间 
				k.erase(it ++); // 删除it并指向下一个元素 
				l = min(l, lk2);
				r = max(r, rk2);
			} else it ++;
		}
		k.insert((ks){l, r}); // 插入[l,r] 
	}
	
	cout << res;
}

/*
一些手搓的样例
2
1 1 1
2 2 2

1

3
2 3 3
6 7 9
2 1 1

2
*/
```

---


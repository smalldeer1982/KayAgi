# [FJCPC 2025] 难以控制的滑板火箭

## 题目描述

在一个 $n\times m$ 的 `01` 网格中，其中第 $i$ 行第 $j$ 列的元素为 $a_{i,j}$，若 $a_{i,j}=1$ 则表示这个位置为空地，反之若 $a_{i,j}=0$ 则表示这个位置上有障碍物。

现在小猫从 $(1,1)$ 出发，想要去 $(n,m)$。

若小猫当前在 $(x,y)$ 则**一次移动**后可以到 $(x-1,y)$、$(x+1,y)$、$(x,y-1)$、$(x,y+1)$、$(x-1,y-1)$、$(x+1,y-1)$、$(x-1,y+1)$、$(x+1,y+1)$ 的位置上，注意不能移动到地图外，也不能走到障碍物上。即任意时候 $1\leq x\leq n,1\leq y\leq m,a_{x,y}=1$。

因为小猫使用了难以控制的滑板火箭，每一分钟都会移动 $[l,r]$ 次。

现在需要你求出小猫最少需要几分钟才能成功抵达终点（**必须要某一分钟的移动全部结束后小猫的位置在 $(n,m)$ 才算成功抵达**），如果无论经过多久都不能成功抵达请输出 `-1`。

## 说明/提示

对于第一组样例：

在第一分钟 $(1,1)\rightarrow (2,2)\rightarrow (3,3)\rightarrow (3,4)$；

在第二分钟 $(3,4)\rightarrow (4,5)\rightarrow (5,5)$。

## 样例 #1

### 输入

```
3
5 5
2 3
10000
01000
00110
11001
11111
7 8
3 3
10101000
01010100
10000100
01000010
00100100
00011010
00000001
7 8
4 4
10101000
01010100
10000100
01000010
00100100
00011010
00000001```

### 输出

```
2
3
3
```

# 题解

## 作者：Lyx8058 (赞：6)

## 前言：

学懂了就要讲出来！

一道有趣的分层图题。

[看个乐子](https://www.luogu.com.cn/record/list?pid=P13096&user=1135241)

注意：文中 $\lceil x \rceil$ 表示 $x$ 向上取整，$dis_o$ 表示长度为奇数的最短路，$dis_e$ 表示长度为偶数的最短路。

## 简要题意：

这题目简化后变成了每一次可以走 $l$ 到 $r$ 的距离，求最少需要多少次才可以走到（$n,m$），不可以输出 `-1`。

## 思路：

**一、当 $l<r$ 时，只需要按照图跑一遍最短路即可，不行输出 `-1`，可行就能走越远走越远，所以输出为 $\lceil \frac{w}{r} \rceil$。（其中 $\lceil x\rceil$ 表示为 $x$ 上取整，$w$ 为最短路长度）**

**二、当 $l=r$ 时，此时分两种情况讨论：**

预处理：建立一个分层图，每个点分割成 $0$ $1$ 两种点，两个可通点相互的不同种点进行建边，然后根据最短路处理出最短的奇数路径长度和最短的偶数路径长度。

一、当 $r$ 为偶数的时候，即每分钟必须走偶数步，此时奇数的最短路必然无法使其每分钟走 $r$ 步的前提下走到（$n,m$）。

所以我们考虑有无长度为偶数的最短路。若有，输出 $\lceil \frac{w}{r} \rceil$；若无，输出 `-1`。
二、当 $r$ 为奇数时，每分钟必须走奇数步，我们需要判断分钟数奇偶性与路径长度奇偶性是否相同，相同直接输出 $\lceil \frac{\operatorname{min}(dis_o,dis_e)}{r} \rceil$；否则在原来的答案上转变为 $\operatorname {min}(\lceil \frac{dis_o}{r}\rceil+((dis_o-\lceil \frac{dis_o}{r}\rceil)\bmod2),\lceil \frac{dis_e}{r}\rceil+((dis_e-\lceil \frac{dis_e}{r}\rceil)\bmod2))$。

综上，该题已做完。

在我们不断地探索中，一道有深意的绿题就被我们成功通过了。

## 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1001;
int t,n,m,l,r,o,e;
int dx[]={-1,0,1,1,1,0,-1,-1},dy[]={-1,-1,-1,0,1,1,1,0};
char a[N][N];
int mp[N][N][2];
bool vis[N][N][2];
struct node{
	int x,y,col;
};
signed main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		cin>>l>>r;
		o=INT_MAX;
		e=INT_MAX;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin>>a[i][j];
				mp[i][j][0]=INT_MAX;
				mp[i][j][1]=INT_MAX;
				vis[i][j][0]=0;
				vis[i][j][1]=0;
			}
		}
		queue<node>q;
		q.push(node{1,1,0});
		mp[1][1][0]=0;
		vis[1][1][0]=1;
		while(!q.empty()){
			node tp=q.front();
			q.pop();
			int x=tp.x,y=tp.y,col=tp.col;
			for(int i=0;i<8;i++){
				int tx=x+dx[i],ty=y+dy[i];
				if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&a[tx][ty]=='1'&&!vis[tx][ty][col^1]){
					mp[tx][ty][col^1]=mp[x][y][col]+1;
					vis[tx][ty][col^1]=1;
					q.push(node{tx,ty,col^1});
				}
			}
		}
		if(mp[n][m][1]==INT_MAX&&mp[n][m][0]==INT_MAX){
			cout<<"-1\n";
			continue; 
		}
		o=mp[n][m][1];
		e=mp[n][m][0];
		if(l<r){
			cout<<min(e/r+(e%r!=0),o/r+(o%r!=0))<<"\n";
		}
		else{
			if(r%2==0){
				if(e==INT_MAX){
					cout<<"-1\n";
				}
				else cout<<(e/r+(e%r!=0))<<"\n";
			}
			else{
				int et=INT_MAX,ot=INT_MAX;
				if(e%r==0){
					et=e/r;
				}
				else
				{
					if((r-e%r)%2){
						et=e/r+2;
					}
					else et=e/r+1;
				}
				if(o%r==0){
					ot=o/r;
				}
				else{
					if((r-o%r)%2) ot=o/r+2;
					else ot=o/r+1;
				}
				cout<<min(et,ot)<<"\n";
			}
		}
	}
	return 0;
}
```

## 后话：

感谢管理员的审核时的提醒，谢谢。

---

## 作者：DengDuck (赞：6)

我們先不考慮分鐘的限制，考慮判斷如果已經知道一個總步數，如何判斷這個總步數是否存在一個移動方案。

注意到兩步可以抵消，比如左走一步然後右走一步，所以我們只需要分別求出奇偶的最小步數，然後就得到了兩個表達式：$O_{\min}+2t(t\in\mathbb{N})$，$E_{\min}+2t(t\in \mathbb{N})$，顯然 $O_{\min}$ 和 $E_{\min}$ 分別表示的是奇、偶最小步數，$t$ 是抵消的步數。

求這個東西顯然分層圖 BFS 就可以了。

然後就可以得出所有合法的步數了。

現在我們考慮分鐘限制，如果 $x$ 分鐘是合法的，那麼條件是什麼？顯然奇偶只需要有一個滿足就可以了，不妨分開考慮，假如我們目前考慮的這個部分最小步數為 $F$ 則有：

$$
F+2t\in[xL,xR]
$$

這個東西我猜有一些數學做法可以解決，但是我是超級高手，我決定直接枚舉來 Check，比較好寫。

時間複雜度為 $\mathcal O(nm)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=1005;
int n,m;
LL L,R,F[N][N][2];
char C[N][N];
inline void Work()
{
	cin>>n>>m>>L>>R;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)cin>>C[i][j];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)F[i][j][0]=F[i][j][1]=2e15;
	F[1][1][0]=0;
	queue<tuple<int,int,int> >Q;Q.push({1,1,0});
	while(!Q.empty())
	{
		int x=get<0>(Q.front()),y=get<1>(Q.front()),t=get<2>(Q.front());Q.pop();
		for(int A=-1;A<=1;A++)
		for(int B=-1;B<=1;B++)
		{
			if(A==0&&B==0)continue;
			int X=x+A,Y=y+B;
			if(X<1||X>n||Y<1||Y>m||C[X][Y]=='0')continue;
			if(F[X][Y][t^1]>F[x][y][t]+1)
			{
				F[X][Y][t^1]=min(F[X][Y][t^1],F[x][y][t]+1);
				Q.push({X,Y,t^1});
			}
		}
	}
	if(F[n][m][0]==F[0][0][0]&&F[n][m][1]==F[0][0][0])return cout<<-1<<endl,void();
	for(int x=1;x<=n*m;x++)
	{
		LL Ans=2e15;
		if(F[n][m][0]<=x*R)
		{
			if(x*L<=F[n][m][0])Ans=min(Ans,F[n][m][0]);
			else Ans=min(Ans,(x*L+1)/2*2);
		}
		if(F[n][m][1]<=x*R)
		{
			if(x*L<=F[n][m][1])Ans=min(Ans,F[n][m][1]);
			else Ans=min(Ans,x*L/2*2+1);
		}		
		if(x*L<=Ans&&Ans<=x*R)return cout<<x<<endl,void();
	}
	cout<<-1<<endl;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T;cin>>T;
	while(T--)Work();
}
```

---

## 作者：nbhs23a28 (赞：3)

一道思维与细节（分类讨论）兼有的分层图 BFS 好题。（但卡了我 6 发罚时）

首先分析题面可知，小猫每次移动都是一次朴素的 BFS 过程，但本题的亮点在于小猫一分钟可行走 $[l,r]$ 次，且一定要在某分钟末到达。

在不考虑末态影响的情况下，我们每分钟行走次数为 $r$ 时应当最优。现考虑最后一步：容易发现我们可以在终点与相邻点反复弹跳，$2$ 步一循环，那么，当 $l<r$ 时一定能做到在 $⌈d/r⌉$（$d$ 表示朴素 BFS 处理的距离）时间内到达。（$⌈d/r⌉$ 分钟弹跳结束后一定能到达终点）

接下来考虑 $l=r$ 情形。由于最终 $2$ 步一循环，不难想到建立奇偶分层图。接下来对奇偶性分类讨论：  

- 若 $r$ 为偶数，则一定需要一条偶数长度的路径（否则不可达），$⌈d_0/r⌉$ 分钟弹跳结束后一定能到达终点，故能做到在 $⌈d_0/r⌉$ 时间内到达。（$d_0$ 表示偶数长度的最小距离）
- 若 $r$ 为奇数。此时需要考虑 $⌈d/r⌉$ 分钟弹跳能否到达终点，则答案非 $⌈d/r⌉$ 即 $⌈d/r⌉+1$。若 $⌈d/r⌉$ 分钟内能到达，则一定满足 $d_{⌈d/r⌉\text{ mod }2}\le ⌈d/r⌉\times r$（奇偶分层思想），注意到二者是充要条件，故满足 $d_{⌈d/r⌉\text{ mod }2}\le ⌈d/r⌉\times r$ 的 $⌈d/r⌉$ 分钟内能到达，否则 $⌈d/r⌉+1$ 分钟才能到达。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,l,r;
char a[1010][1010];
int vis[2][1010][1010],movx[8]={0,0,1,1,1,-1,-1,-1},movy[8]={1,-1,0,1,-1,0,1,-1},v;
struct Node{
 int first,second,c;
};
queue <Node> q;
signed main()
{int t;cin>>t;
 while(t--)
 {cin>>n>>m>>l>>r;
  for(int i=1;i<=n+1;i++)
  {if(i<=n)
   {for(int j=1;j<=m;j++)
   {cin>>a[i][j];
    if(a[i][j]=='0') vis[0][i][j]=vis[1][i][j]=0;
    else vis[0][i][j]=vis[1][i][j]=-1;
   }
   }
   else
   for(int j=1;j<=m;j++)
    vis[0][i][j]=vis[1][i][j]=0;
   vis[0][i][m+1]=vis[1][i][m+1]=0;
  }
  q.push({1,1,0});vis[0][1][1]=0;
  while(!q.empty())
  {int x=q.front().first,y=q.front().second,c=q.front().c;
   q.pop();
   for(int i=0;i<8;i++)
   {if(vis[1-c][x+movx[i]][y+movy[i]]==-1)
    {vis[1-c][x+movx[i]][y+movy[i]]=vis[c][x][y]+1;
     q.push({x+movx[i],y+movy[i],1-c});
    }
   }
  }
  if(vis[1][n][m]!=-1&&vis[0][n][m]!=-1)
  v=min(vis[1][n][m],vis[0][n][m]);
  else
  v=max(vis[1][n][m],vis[0][n][m]);
  //cout<<vis[0][n][m]<<' '<<vis[1][n][m]<<' ';
  if(v==-1)
  {cout<<"-1\n"; 
   continue;
  }
  if(l!=r)
  cout<<(v+r-1)/r<<'\n';
  else
  {if((l&1)==0)
   {if(vis[0][n][m]==-1)
    cout<<"-1\n";
    else
    cout<<(vis[0][n][m]+r-1)/r<<'\n';
   }
   else
   {if(v%r==0) 
    {cout<<v/r<<'\n';
     continue;
    }
    int num=(v+r-1)/r;//最优
    if(num%2==1)
    {if(vis[1][n][m]!=-1&&vis[1][n][m]<=r*num)
     cout<<num<<'\n';
     else
     cout<<num+1<<'\n';
    }
    else
    {if(vis[0][n][m]!=-1&&vis[0][n][m]<=r*num)
     cout<<num<<'\n';
     else
     cout<<num+1<<'\n';
    }
   }
  }
 }
}

---

## 作者：Igunareo (赞：2)

## 思路
大多数人一眼应该都能看出肯定最短路吧，这题连个顺序都没有，估计不会有人想去写那种基本没法做的动归。

显然的我们要求出从左上角到右下角的最短路，然后考虑怎么算。

除非巧合，否则不太可能最短路径正好落在区间内，所以我们对结果拓展一下，题目没有规定不能回到同一个点，那么我们就可以在两个相邻点上反复横跳。

但是反复横跳路径长度 $L\gets L+2$，奇偶性不变，所以我们需要维护奇数路程和偶数路程两种最短路径，直接分层图最短路跑出来就行。

然后计算用时，对于 $l<r$ 显然用时不会高于网格大小，所以直接暴力枚举时间，判断最大移动距离够不够抵达终点，是慢了点但是可靠够用，奇偶情况分开算，$l\ne r$ 所以一定奇偶情况都有，可以忽略两者是不是都要算的问题。

对于 $l=r$ 的情况需要单独考虑，毕竟只有一种情况。

1. $l=r$ 且为偶数时奇数抵达时间直接免谈，直接算偶数情况要多久，要特判偶数路径长不能抵达就输出 $-1$。
2. $l=r$ 且为奇数时偶数情况一定耗费偶数时长，奇数情况一定耗费奇数时间，分开讨论。

做完了，还有多测一定要清空。
## 代码实现
码风经典友善，可读性不必担心，长度中等。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char x[1005][1005];
int dis[1005][1005][3],n,m;
struct Ty{int a,b,val;}J[10]={{0,0,2},{-1,-1,1},{-1,0,1},{-1,1,1},{0,-1,1},{0,1,1},{1,-1,1},{1,0,1},{1,1,1}};
queue<Ty>q;
Ty add(Ty a,Ty b){
	a.a+=b.a;
	a.b+=b.b;
	a.val+=b.val;
	return a;
}
bool over(Ty a,Ty b){
	a.a+=b.a;
	a.b+=b.b;
	a.val+=b.val;
	if(x[a.a][a.b]=='0')return 0;
	if(a.a<0||a.a>n||a.b<0||a.b>m)return 0;
	if(a.val>=dis[a.a][a.b][a.val%2])return 0;
	return 1;
}
signed main(){
	int T;
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld",&n,&m);
		int L,R;
		scanf("%lld%lld",&L,&R);
		for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)dis[i][j][0]=dis[i][j][1]=1e9;
		dis[1][1][0]=0;
		for(int i=1;i<=n;i++)scanf("%s",x[i]+1);
		while(!q.empty())q.pop();
		q.push({1,1,0});
		while(!q.empty()){
			Ty now=q.front(),nxt;
			q.pop();
			//if(dis[n][m][0]<1e9&&dis[n][m][1]<1e9)break; 加上应该也不会错
			for(int i=1;i<=8;i++)if(over(now,J[i])){
				q.push(nxt=add(now,J[i]));
				dis[nxt.a][nxt.b][nxt.val%2]=nxt.val;
			}
		}
		if(dis[n][m][0]>=1e9&&dis[n][m][1]>=1e9){
			printf("-1\n");
			continue;
		}
		if(L==R){
			if(L%2){
				int ans=(dis[n][m][0]/(L*2)+(dis[n][m][0]%(L*2)>0))*2;
				ans=min(ans,((dis[n][m][1]-L)/(L*2)+((dis[n][m][1]-L)%(L*2)>0))*2+1);
				printf("%lld\n",ans);
			}
			else {
				if(dis[n][m][0]<1e9)printf("%lld\n",dis[n][m][0]/L+(dis[n][m][0]%L>0));
				else printf("-1\n");
			}
			continue;
		}
		else{
			int maxx=0;
			for(int i=1;;i++){
				maxx+=R;
				if(maxx>=dis[n][m][maxx%2]||maxx-1>=dis[n][m][1-maxx%2]){
					printf("%lld\n",i);
					break;
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

[P13096 [FJCPC 2025] 难以控制的滑板火箭](https://www.luogu.com.cn/problem/P13096)

一个小猫在网格中移动，给定一个 $n \times m$ 的 01 网格，其中 1 表示空地，0 表示障碍物。小猫从 $(1,1)$ 出发，想要到达 $(n,m)$。每分钟小猫可以移动 $[l,r]$ 次，每次可以向 $8$ 个方向移动一步。我们需要计算小猫最少需要多少分钟才能到达终点，如果无法到达则返回 $-1$。

不用想，瞄了一眼就知道是广搜，使用 BFS 来探索小猫从起点到终点的最短路径。先用三维数组 $F[x][y][t]$ 来记录到达位置 $(x,y)$ 时的最短时间，其中 $t$ 表示当前分钟的移动次数是奇数还是偶数。再用队列来存储待处理的节点，每个节点包含当前位置 $(x,y)$ 和当前移动次数的奇偶性 $t$。
当然，我们要确保移动后的位置**在网格内**而且**是空地**。最后根据每分钟移动次数的范围 $[l,r]$ ，计算到达终点所需的最少分钟数。

AC code 如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
const int N = 1005;
const LL INF = 2e15;

int n, m;
LL L, R, F[N][N][2];
char C[N][N];

void solve() {
    cin >> n >> m >> L >> R;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            cin >> C[i][j];

    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            F[i][j][0] = F[i][j][1] = INF;

    F[1][1][0] = 0;
    queue<tuple<int, int, int>> Q;
    Q.push({1, 1, 0});

    while (!Q.empty()) {
        auto [x, y, t] = Q.front(); Q.pop();
        for (int dx = -1; dx <= 1; ++dx)
            for (int dy = -1; dy <= 1; ++dy) {
                if (dx == 0 && dy == 0) continue;
                int nx = x + dx, ny = y + dy;
                if (nx < 1 || nx > n || ny < 1 || ny > m || C[nx][ny] == '0') continue;
                if (F[nx][ny][!t] > F[x][y][t] + 1) {
                    F[nx][ny][!t] = F[x][y][t] + 1;
                    Q.push({nx, ny, !t});
                }
            }
    }

    if (F[n][m][0] == INF && F[n][m][1] == INF) {
        cout << "-1\n";
        return;
    }

    for (int x = 1; x <= n * m; ++x) {
        LL ans = INF;
        if (F[n][m][0] <= x * R) {
            if (x * L <= F[n][m][0]) ans = min(ans, F[n][m][0]);
            else ans = min(ans, (x * L + 1) / 2 * 2);
        }
        if (F[n][m][1] <= x * R) {
            if (x * L <= F[n][m][1]) ans = min(ans, F[n][m][1]);
            else ans = min(ans, x * L / 2 * 2 + 1);
        }
        if (x * L <= ans && ans <= x * R) {
            cout << x << "\n";
            return;
        }
    }
    cout << "-1\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) solve();
    return 0;
}
```

---

## 作者：xuyifei0302 (赞：0)

读完题，我们可以想到将可以互相抵达的点连边，然后跑最短路。

但是我们有 $l$ 和 $r$ 的限制，但是，我们如果抵达终点时剩余的步数为偶数，我们可以来回横跳地浪费掉，若 $l$ 与 $r$ 不相等，则我们最后一次可以选择跳奇数步还是偶数步，答案就为最短路的长度除以 $r$ 取上整。

若 $l$ 等于 $r$，就要判断 $l$ 是偶数还是奇数，若 $l$ 为奇数，两个奇数相加即可凑出偶数，但是这样有可能导致答案不一定是最短路的长度，所以我们考虑建分层图，处理出步数为偶数与步数为奇数的最小值，分开计算。

若 $l$ 为偶数，则无法凑成奇数，必须要偶数步到终点才可以，处理方式同上。

最后统计的细节有点多，下面是代码环节：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int INF = 1e16;
struct Node {
	int x, y, dis;
};
int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};
int t, n, m, l, r, dis[1005][1005][2];
bool flag[1005][1005], mark[1005][1005][2];
string s;
queue<Node> q;
signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> t;
	while (t --) {
		cin >> n >> m >> l >> r;
		for (int i = 1; i <= n; i ++) {
			cin >> s;
			s = " " + s;
			for (int j = 1; j <= m; j ++) {
				flag[i][j] = s[j] - '0';
				dis[i][j][0] = INF;
				dis[i][j][1] = INF;
			}
		}
		memset(mark, false, sizeof(mark));
		dis[1][1][0] = 0;
		mark[1][1][0] = true;
		q.push({1, 1, 0});
		while (!q.empty()) {
			int x = q.front().x, y = q.front().y, z = q.front().dis;
			q.pop();
			for (int i = 0; i < 8; i ++) {
				int xx = x + dx[i], yy = y + dy[i], zz = z + 1;
				if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && !mark[xx][yy][zz % 2] && flag[xx][yy]) {
					dis[xx][yy][zz % 2] = zz;
					mark[xx][yy][zz % 2] = true;
					q.push({xx, yy, zz});
				}
			}
		}
//		cout << dis[n][m][0] << " " << dis[n][m][1] << " ";
		if (dis[n][m][0] == INF && dis[n][m][1] == INF) {
			cout << "-1\n";
		} else if (l == r) {
			if (l % 2) {
				int tmp = 0, tmp1 = 0;
				if (dis[n][m][1] % l == 0) {
					tmp = dis[n][m][1] / l;
				} else {
					if ((l - dis[n][m][1] % l) % 2) {
						tmp = dis[n][m][1] / l + 2;
					} else {
						tmp = dis[n][m][1] / l + 1;
					}
				}
				if (dis[n][m][0] % l == 0) {
					tmp1 = dis[n][m][0] / l;
				} else {
					if ((l - dis[n][m][0] % l) % 2) {
						tmp1 = dis[n][m][0] / l + 2;
					} else {
						tmp1 = dis[n][m][0] / l + 1;
					}
				}
				cout << min(tmp, tmp1) << "\n";
			} else {
				if (dis[n][m][0] == INF) {
					cout << "-1\n";
				} else {
					if (dis[n][m][0] % l == 0) {
						cout << dis[n][m][0] / l << "\n";
					} else {
						cout << dis[n][m][0] / l + 1<< "\n";
					}
				}
			}
		} else {
			int tmp = min(dis[n][m][1], dis[n][m][0]);
			if (tmp % r == 0) {
				tmp /= r;
			} else {
				tmp /= r;
				tmp ++;
			}
			cout << tmp << "\n";
		}
	}
	return 0;
}
```

---

## 作者：SudoXue (赞：0)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18973842)

整体思路上，可以先用分层广搜枚举纯步数，再把步数批量打包成分钟即可。

广搜部分：把每个格子拆成偶步状态和奇步状态两层，状态记作 $(x,y,p)$，其中 $p\in\{0,1\}$ 表示到达该点时累积步数的奇偶性。起点是 $(1,1,0)$。每走一步，奇偶性翻转，于是同层只能连到另一层。这样跑一次普通队列广搜，便能得到两张距离表 $d_0,d_1$，分别是以偶步、奇步结束到达 $(n,m)$ 的最短步数；不可达点距离视为 $\infty$。

接下来把纯步数折算成分钟。设路径长度为 $x$。若 $l\ne r$，显然每分钟尽量走满 $r$ 步最优，所需分钟数就是 $\lceil x/r\rceil$。若 $l=r$，一分钟只能走固定的 $l$ 步，此时需判断能否恰好凑整：先算出 $k=\lceil x/l\rceil$，若 $l$ 为奇数则分钟数奇偶性与步数奇偶性要匹配；若 $l$ 为偶数则只有当 $x$ 为偶数时才可能恰配，否则永远无法到达。对 $d_0,d_1$ 分别套这个折算公式取最小值即可；若两种距离都是 $\infty$，答案为 $-1$。

时间复杂度 $O(nm)$。

[link](https://www.luogu.com.cn/record/223080944)

拓展练习：[CF2109D D/D/D](https://codeforces.com/contest/2109/problem/D)

---


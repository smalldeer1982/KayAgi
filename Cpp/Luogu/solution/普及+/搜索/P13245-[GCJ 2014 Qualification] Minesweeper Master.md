# [GCJ 2014 Qualification] Minesweeper Master

## 题目描述

**Minesweeper**（扫雷）是一款在 20 世纪 80 年代流行起来的电脑游戏，至今仍被包含在某些版本的 Microsoft Windows 操作系统中。本题的设定与该游戏类似，但不要求你玩过扫雷。

在本题中，你将在一个由若干相同方格组成的网格上进行游戏。每个格子中的内容在初始时是隐藏的。共有 $M$ 枚地雷被隐藏在 $M$ 个不同的格子中，其他格子中不含地雷。你可以点击任意一个格子来揭示其内容。如果你点开的格子中有地雷，游戏立刻结束，你失败。否则，该格子将显示一个介于 $0$ 到 $8$ 之间的数字，表示与该格子相邻的格子中包含地雷的数量。两个格子被认为是相邻的，当且仅当它们共享一个边或一个角。

此外，如果你揭示的格子显示的是 $0$，则其所有相邻格子也会被自动揭示，并递归地继续这个过程。当所有不含地雷的格子都被揭示时，游戏结束，你获胜。

例如，一个初始的棋盘配置可能如下所示（`*` 表示地雷，`c` 表示首次点击的格子）：

```
*..*...**.
....*.....
..c..*....
........*.
..........
```

点击的格子周围没有地雷，因此被揭示后显示为 $0$，并触发其 8 个相邻格子的自动揭示。这个过程继续进行，最终得到如下棋盘：

```
*..*...**.
1112*.....
00012*....
00001111*.
00000001..
```

此时，仍有一些未被揭示的、且不含地雷的格子（用 `.` 表示），因此玩家必须再次点击以继续游戏。

你希望尽可能快地赢得游戏。最快的方式自然是**只点击一次就获胜**。给定棋盘的大小（$R \times C$）以及隐藏的地雷数 $M$，请判断是否存在一种（哪怕极不可能）配置，使得玩家只需点击一次就能赢得游戏？你可以自由选择点击的位置。如果存在这样的配置，请输出任意一种符合要求的地雷布置及点击坐标，具体格式见输出说明；如果不存在，则输出 **"Impossible"**。


## 说明/提示

**限制条件**

$0 \leq M < R \times C$。

**小数据集（11 分）**

- 时间限制：~~60~~ 3 秒。
- $1 \leq T \leq 230$。
- $1 \leq R, C \leq 5$。

**大数据集（24 分）**

- 时间限制：~~120~~ 5 秒。
- $1 \leq T \leq 140$。
- $1 \leq R, C \leq 50$。

翻译由 ChatGPT-4o 完成。

## 样例 #1

### 输入

```
5
5 5 23
3 1 1
2 2 1
4 7 3
10 10 82```

### 输出

```
Case #1:
Impossible
Case #2:
c
.
*
Case #3:
Impossible
Case #4:
......*
.c....*
.......
..*....
Case #5:
**********
**********
**********
****....**
***.....**
***.c...**
***....***
**********
**********
**********```

# 题解

## 作者：DecemberFox (赞：1)

# P13245 [GCJ 2014 Qualification] Minesweeper Master 题解

## 题目分析

题目要求构造一种 $R\times C$ 的扫雷地图的 $M$ 个地雷分布和点击位置，使得在点击**一次**后玩家可以直接获胜。

扫雷时点击某一个格子，若该格子所包含的数字为 $0$，则表示周围八个格子都没有地雷，可以继续揭开其余八个格子。不断递归该过程，直至所有可以被揭开的格子被揭开后，未揭开的格子全部为地雷时，玩家获胜。

## 解法分析

由于只能点击一次，因此地雷应当紧凑摆放，因此：
1. 不能出现被地雷包裹的空格子。例如：
   ```
   ****..
   *..*..
   ****..
   ```
   不论点击外面或里面的格子，总会存在无法揭开的格子。
2. 地雷要么紧贴边缘、要么距离边缘至少两格。例如：
   ```
   ....
   *...
   ***.
   ```
   此时不论点击哪一个空位，左上角和右下角的格子至少会有一个无法被揭开。
3. 两个中间存在空位的地雷之间不能是空格，必须为地雷，否则该空格将无法被揭开。例如：
   ```
   .....
   .....
   **.**
   *****
   ```
   此时第三行的空格将无法被揭开。

接下来将基于以上三条规则构造扫雷地图。

首先应该确定点击的位置。将其放在角落处，可以减少受到两个方向的地雷的影响。

```
....
....
....
...c
```
然后考虑放置地雷。根据规则一，地雷应该紧密排列；根据规则二，地雷应该贴着边缘放置。
```
*...
....
....
...c
```
对于更多的地雷，在左上角 $(R-2)\times(C-2)$ 的区域内，只会被规则一和三约束，因此地雷数从 $1$ 到 $(R-2)\times(C-2)$ 都被解决了，此时一定有解。
```
**..
**..
....
...c
```

如果还有更多的地雷，就需要将其放在两边了，这时就要考虑规则二了。此时增加偶数个地雷，可以直接填满两格的空间；但对于奇数个地雷，不论放在哪里，似乎都不满足规则二，因此就需要向已经放置完毕的区域内借一颗地雷放置。

而根据规则三，最好的借用地雷的位置就是区域内左下角的位置（图中 `x` 的位置）。
```
****
*x..
....
...c
```
但是如果考虑一下极端的情况，在上述大小的图中放置 $9$ 个地雷其实是不可行的，因为在借用地雷时，就会创造出一个新的空洞。
```
****
*.**
*...
*..c
```
此外放置 $11$ 个也是不行的。
```
****
*.**
**..
**.c
```
即放置的地雷个数为 $R\times C-5$ 或 $R\times C-7$ 时就会存在空位，此时一定不可行，输出 `Impossible`。

对于剩下四个空，仅有除 `c` 外均为地雷时才成立。
```
****
****
****
***c
```
由于在放置边缘的两排或行时，程序默认已经放置了 $(R-2)\times(C-2)$ 个地雷，但在地图边长 $R$ 或 $C$ 为 $2$ 时，不存在借用地雷的情况，因此除了偶数个地雷均输出 `Impossible`。
```
c..**
....*
```
最后特判只有单列或单行的情况，此时也一定可以。
```
c...**
```
最终代码如下：

```cpp
namespace SOLVE
{
	typedef long long ll;
	typedef unsigned long long ull;
	typedef __int128 lll;
	typedef unsigned __int128 ulll;
	char ans[60][60];
	int r,c,m;
	int add() //按顺序放置左上角 (R-2)*(C-2) 区域的地雷
	{
		int i,j,mine(0);
		for(i=1;i<=r;++i)
		{
			for(j=1;j<=c;++j)
			{
				if(i>r-2) ans[i][j]='.';
				else if(j>c-2) ans[i][j]='.';
				else if(mine<m) ans[i][j]='*',++mine;
				else ans[i][j]='.';
			}
		}
		ans[r][c]='c';
		return mine;
	}
	void add2(int rm) //按顺序放置两条边缘位置的地雷
	{
		int i,j,dig(0);
		if(rm%2!=0) ans[r-2][c-2]='.',++rm,dig=1; //借用地雷
		for(i=1;i<=r-2-dig&&rm!=0;++i,rm-=2) ans[i][c]=ans[i][c-1]='*';
		for(j=1;j<=c-2-dig&&rm!=0;++j,rm-=2) ans[r][j]=ans[r-1][j]='*';
	}
	void print()
	{
		int i,j;
		for(i=1;i<=r;++i)
		{
			for(j=1;j<=c;++j) putchar(ans[i][j]);
			putchar('\n');
		}
	}
	void solve(int task)
	{
		int i,j;
		read(r,c,m);
		std::memset(ans,sizeof ans,'\0');
		if(r==1) //只有一行
		{
			for(j=1;j<=c;++j) if(j<=m) ans[1][j]='*';else ans[1][j]='.';
			ans[1][c]='c';
		}
		else if(c==1) //只有一列
		{
			for(i=1;i<=r;++i) if(i<=m) ans[i][1]='*';else ans[i][1]='.';
			ans[r][1]='c';
		}
		else if(m==r*c-1) //只有一个空位
		{
			for(i=1;i<=r;++i) for(j=1;j<=c;++j) ans[i][j]='*';
			ans[r][c]='c';
		}
		else if((r==2||c==2)&&m%2!=0) //两行或两列时地雷数量不为偶数
		{
			printf("Case #%d:\nImpossible\n",task);
			return;
		}
		else if(m<=(r-2)*(c-2)) //可以直接放置在左上角 (R-2)*(C-2) 的区域内
		{
			add();
		}
		else if(m<=r*c-4&&m!=r*c-5&&m!=r*c-7) //需要将地雷放置在两条边缘地带，需要判断最后的特殊情况
		{
			add2(m-add());
		}
		else //不满足以上情况
		{
			printf("Case #%d:\nImpossible\n",task);
			return;
		}
		printf("Case #%d:\n",task);
		print();
	}
}
int main()
{
	int t,tk(0);
	read(t);
	while(t--) SOLVE::solve(++tk);
	return 0;
}
```

---


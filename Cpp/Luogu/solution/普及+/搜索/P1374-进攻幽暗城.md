# 进攻幽暗城

## 题目背景

由于震惊海内外的 “愤怒门投毒事件” 的发生，部落为了对抗皇家药剂师协会的叛乱，所有的外交工作完成后，部落大酋长萨尔带领着小 A 穿过传送门到达幽暗城平叛。


## 题目描述

幽暗城的地图是一个 $n \times m$ 的 $01$ 串。$a_{i, j} = 1$ 时表示 $(i, j)$ 的位置是障碍，无法通过；$a_{i, j} = 0$ 时表示 $(i, j)$ 的位置可以进入。

小 A 与萨尔的初始位置是 $(x_1, y_1)$，而恐惧魔王的初始位置是 $(x_2, y_2)$。小 A 的目标就是到达恐惧魔王的位置。

萨尔会按照一个特定的路线行走，该路线是一个数字串，由 $0 \sim 4$ 组成。

第 $i$ 秒，若数字串第（$i \bmod {}$数字串的长度）位等于 $0$，则表示这一秒萨尔将会原地不动；   
等于 $1$，则表示这一秒萨尔会向上走一格；   
等于 $2$，则表示这一秒萨尔会向下走一格；   
等于 $3$，则表示这一秒萨尔会向左走一格；   
等于 $4$，则表示这一秒萨尔会向右走一格。

若萨尔将要移动的位置是墙或者超出迷宫的范围，则萨尔会原地不动。恐惧魔王也是这样。（换句话说，你可以认为如果将数字串是重复无限次，第 $i$ 秒就是字符串第 $i$ 位）

小A每秒可以选择从上下左右四个方向中选择一个方向，朝那个方向走一格，前提是那个位置不是墙并且没有超出迷宫的范围；或者原地不动。不过，由于幽暗城的诡异环境，小 A 只能持续脱离萨尔的光环 $s$ 秒，若超过 $s$ 秒小 A 则会死亡。光环的有效半径为 $d$ ，表示当小 A 与萨尔之间的距离 $\sqrt{(x-xx)^2+(y-yy)^2}$ 小于等于 $d$ 时小 A 才能受到萨尔光环的效果。若小 A 脱离萨尔的光环又重新进入光环有效区域，则再次离开光环时持续时间归零重记。

小 A 想知道最少需要几秒他才能到达恐惧魔王所在的位置。

## 说明/提示

**【题目来源】**

kiro 原创

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m \le 50$，$0 \le s \le 1000$，$0 \le d \le 100$，$1 \le $ 数字串长度 $ \le 100$，$0 \le $ 答案 $ \le 100$。

## 样例 #1

### 输入

```
3 4 7 3
1010
0000
0101
1 2 3 3
0132401
12131
```

### 输出

```
3
```

# 题解

## 作者：world_execute (赞：18)

> ## [[ 更好的阅读体验 ]](https://www.luogu.org/blog/execute/solution-p1374)
> ## [[    原题面    ]](https://www.luogu.org/problemnew/show/P1374)

------------

### 第零部分 —— 阅读题目

- 题目大意：幽暗城中有三个人，萨尔 _Sal_ ，恐惧魔王 _Dread Lord_ ，And 小A。刚开始，小A与萨尔在 $ (x1,y1) $ 位置，而恐惧魔王在 $ (x2,y2) $ 位置。小A想要走到恐惧魔王的位置，但不能离萨尔d个单位距离以上超过s秒，同时，萨尔与恐惧魔王都会按照各自的模式，固定的行走。

- 输入：幽暗城的地图，0表示可以走，1表示被挡住，不能走。

- 数据范围：1 $ \le $ 地图长、宽 $ \le $50，0 $ \le $ 最大离开时间 $ \le $ 1000，0 $ \le $ 最大离开距离 $ \le $ 100，计算欧几里得距离（直线距离）

- So， $ O(nm * 答案大小 * 一个非常大的常数) $的算法似乎轻松可以过，而且跑的飞快。

------------

### 第一部分 —— 开始分析

- 似乎可以用搜索做，但是有好多问题有待解决，如离开时间、每个时间上，萨尔与恐惧魔王的位置，搜索陷入死循环，被困在圈内……

- 可是有什么困难可以阻挡我们AC这道题的脚步呢？我们把这些难点逐个突破，一定可以做出的。

- So，我们初步确定了算法，可以开始着手思考一些细节了。

------------

### 第三部分 —— 深入思考

- So Good，我们先解决陷入一个死循环。

- 有人会说，为何会进入死循环？那时的情况Looks like this:

                 ...1111...
                 ...1001...
                 ...1000<-.
                 ...1001...
                 ...1111...
       (从箭头所指处进入，先判断上，所以无法退出）

- And，how to do？我们可以[~~百度搜索：迭代加深搜索~~](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2&rsv_pq=a03a5de30010e797&rsv_t=521aoSKQMLqzTPIhCxWMICKilMgdKw50%2FFRvAlBhJzwUBh0qDZXEJQN%2BCas&rqlang=cn&rsv_enter=1&rsv_sug3=17&rsv_sug1=16&rsv_sug7=100)。（用力划掉(* */ω＼* *)）

- 迭代加深搜索（IDDFS）可以有效地避免搜索层数过多，导致的TLE。

- 具体来说迭代加深搜索就是在每次搜索时，限定一个最大搜索层数，每当超过Max_Deep时return，具体实现将会在 第五部分——代码实现 部分具体讲述，不用急，在你看过下面的解析后，可以根据它的定义，不看代码就写出来。

- 所有新知识都讲完了呢ヽ(✿ﾟ▽ﾟ)ノ。~~（巨佬请无视此句）~~

- Haha，萨尔的位置与恐惧魔王的位置怎么办呢？预处理呀，利用生成串来预处理，因为他们 ~~（你怎么知道是“他们”而不是“她们”或“它们”的呢）~~ 的位置只与时间有关，和小A的位置无关

- 还有，对于离开的时间如何进行判断？按题意判断就好了呀。~~（QAQ）~~

- So，是不是可以开始码代码了呢？我相信你有这个实力，去吧，~~（关了题解去码吧）~~ 去看下一部分，那里较为详细地讲述了如何代码实现此题。

------------

### 第五部分 —— 代码实现

- 输入部分：讲一下吧，本人认为这部分有些难度，机房几位巨佬都一不小心写错了呢。
```cpp
scanf("%d%d%d%d", &n, &m, &s, &r);	//输入地图大小，最长离开时间，最大光环距离
for (int i=1; i<=n; ++i)
	for (int j=1; j<=m; ++j)
		cin>>ch,Map[i][j]=(ch-48);	//输入地图
scanf("%d%d%d%d", &Salx[0], &Saly[0], &Lorx[0], &Lory[0]);	//输入x1,y1,x2,y2
cin>>st_Sal;	//输入萨尔的位置生成串
cin>>st_Lor;	//输入恐惧魔王的的位置生成串
```
- Sal 即 萨尔的英文， Lor 即 Dread Lord的缩写 也就是 恐惧魔王的英文。~~（举报，有人机房打“Saly” o(￣▽￣)ｄ）~~

- 然后就是对答案等于0时的预处理

	         (Salx[0]==Lorx[0] && Saly[0]==Lory[0])

- 再是对萨尔位置与魔王位置的Preprocessing。

- 这段代码本人写的十分丑陋，但还是放上来吧：

```cpp
for (int i=1; i<=100; ++i)	//生成100次之内的位置
{
	int tx = Lorx[i-1]+bak[st_Lor[(i-1)%st_Lor.length()]-48];	//Bak即位置预处理数组
	int ty = Lory[i-1]+bak[st_Lor[(i-1)%st_Lor.length()]-43];	//此时减去43是因为在减48的同时要加5，因为这是对y坐标的更改，不能和x坐标混淆
	if ((tx<1)||(tx>n)||(ty<1)||(ty>m))	//走出边界
		tx = Lorx[i-1],ty = Lory[i-1];
	else if (Map[tx][ty] == 1)	//撞上墙
		tx = Lorx[i-1],ty = Lory[i-1];
	Lorx[i] = tx,Lory[i] = ty;

	tx = Salx[i-1]+bak[st_Sal[(i-1)%st_Sal.length()]-48];
	ty = Saly[i-1]+bak[st_Sal[(i-1)%st_Sal.length()]-43];
	if ((tx<1)||(tx>n)||(ty<1)||(ty>m))
		tx = Salx[i-1],ty = Saly[i-1];
	else if (Map[tx][ty] == 1)
		tx = Salx[i-1],ty = Saly[i-1];
	Salx[i] = tx,Saly[i] = ty;
}

```

- 下面生成Sal的位置与Lor位置是一样的，就不写注释了。

- 然后主程序的最后一段：枚举Max_Deep，然后带入搜索：
```cpp
for (int i=1; i<=100; ++i)
	Search(i,0,Salx[0],Saly[0],0);	//i表示最大深度，第一个0表示现在小A走的步数，Salx[0]表示开始时的x坐标，Saly表示开始时的y坐标，最后一个0表示已经离开0秒
```

- 最后就是Search部分

```cpp
void Search(int Max_Deep,int now,int nx,int ny,int Leave_Time)
{
	if (现在层数大于最大层数 或 离开时间大于s)
		return;
	if (到达魔王的位置)
	{
		printf("%d\n", now);
		exit(0);
	}
	now ++;	//开始走
	for (int i=0; i<5; ++i)//五种方案：上下左右或者不动
	{
		int tx = nx+bak[i];
		int ty = ny+bak[i+5];
		int tk = Leave_Time;
		if ((tx<1)||(tx>n)||(ty<1)||(ty>m))
			continue;
		if (Map[tx][ty] == 1)
			continue;
		if (dist(tx,ty,Salx[now],Saly[now]) > r)
			tk++;
		else tk = 0;
		Search(Max_Deep,now,tx,ty,tk);
	}
}
```

- So，第五部分的代码实现就解决了，是不是觉得还比较简单，还有本人第二次在洛谷发布题解，不知道如何写才好，如果有没讲清楚的地方，尽管在评论中回复，我尽量做到有问必答。

------------

### 第六部分 —— 后记

- 不知不觉就写了这么多了呢，希望各位给我一个赞，或是给予我您的宝贵的意见

- So，题解就到这了吧

---

## 作者：wzmzmhk (赞：14)

upd ：感谢 [卑微蒟蒻上线](https://www.luogu.com.cn/user/211278) 的指正，修改了一个错别字。
- [题目传送门](https://www.luogu.com.cn/problem/P1374)
- [博客食用更佳](https://www.luogu.com.cn/blog/wzmzmhk/solution-p1374#)

### Part 0 前言
这应该是本蒟蒻暑假的最后一篇题解了吧。

讨论区中很多人说该题目的 $x$ 和 $y$ 给反了，甚至扯到港澳与大陆的原因，其实不然，只是 OI 与数学的习惯不同。在[这一题](https://www.luogu.com.cn/problem/P1002)的图中即有说明，其 $x$ 代表纵轴，$y$ 代表横轴。在本题中，你只要记住：** $x$ 管的永远是第几行，$y$ 管的永远是第几列**。

### Part 1 题目大意
1. 给定小 A 、萨尔以及恐惧魔王的位置，要求求出小 A 遇到魔王的最短时间。
2. 萨尔和恐惧魔王的运动方式都是固定不动的。
3. 小 A 只可以在距离萨尔 $d$ 距离内或距离萨尔 $d$ 距离外连续 $s$ 秒。

### Part 2 主要思路
常见的 bfs 题，模拟萨尔、小 A 与恐惧魔王的位置即可，当萨尔与恐惧魔王位置相同时，输出答案即可。

**具体过程与细节：**
1. 用数组```flag```打标记，确定当前位置是否走过，如走过就不再添加新节点（这一点不用我多说了吧）。
1. 对于每一次移动，首先确定恐惧魔王与萨尔的位置（因为他们的位置是绝对的），再与小 A 的位置进行比较。
1. 在添加新的节点时，也要判断小 A 与魔王的位置（即本题的 bfs 要进行两次特判），因为小 A 既有可能在移动之前魔王就自己送上门来，也有可能是移动后与魔王相遇。
1. 在结构体中增加一个变量```t1```，用来记录小 A 超出萨尔光环的时间，如果已经在光环内，立马将```t1```赋值为 0，否则```t1```增加 1。

### Part 3 分块步骤

1. 建立一个结构体，储存三人（~~魔王算人？~~）的坐标以及已用的时间和**小 A 超出光环的时间**（```dem```为魔王的缩写）。

```cpp
struct coord {
    int Ax, Ay;//小A的坐标
    int sx, sy;//萨尔的坐标
    int demx, demy;//魔王的坐标
    int t;//已用时间
    int t1 = 0;//超出光环的时间（默认为0）
};
```
2. 用两个函数分别模拟萨尔和魔王的路线：

```cpp
coord Sal(coord x, int s) {
    if (s == 0)
        return x;
    else if (s == 1) {
        int ux = x.sx - 1, uy = x.sy;
        if (ux <= 0 || c[ux][uy] == '1')
            return x;
        x.sx = ux;
        return x;
    }//向上走
    else if (s == 2) {
        int ux = x.sx + 1, uy = x.sy;
        if (ux > n || c[ux][uy] == '1')
            return x;
        x.sx = ux;
        return x;
    }//向下走
    else if (s == 3) {
        int ux = x.sx, uy = x.sy - 1;
        if (uy <= 0 || c[ux][uy] == '1')
            return x;
        x.sy = uy;
        return x;
    }//向左走
    else {
        int ux = x.sx, uy = x.sy + 1;
        if (uy > m || c[ux][uy] == '1')
            return x;
        x.sy = uy;
        return x;
    }//向右走
}
```
由于恐惧魔王与萨尔的方式几乎一模一样，此处就不再赘述。

3. 用普通的 bfs 模拟即可，要注意进行两次特判：

```cpp
int s1 = S[(l.t - 1) % S.size()] - '0';//确定萨尔的数字（即移动方式）
int m1 = M[(l.t - 1) % M.size()] - '0';//确定魔王的数字（即移动方式）
u = Sal(l, s1), u = Dem(l, m1);
if (u.Ax == u.demx && u.Ay == u.demy) {
    cout << u.t;
    return 0;
}//魔王移动后的特判
for (int i = 0; i < 4; i++) {
    int ux = l.Ax + dx[i], uy = l.Ay + dy[i];//用dx和dy模拟上下左右四个方向
    if (ux <= 0 || uy <= 0 || ux > n || uy > m || c[ux][uy] == '1' || flag[ux][uy] == true)
        continue;//如果超出地图范围或该区域是墙或已经走过，就不能再走了
    u.Ax = ux, u.Ay = uy;
    if (dis(u) <= d) {//dis表示小A与萨尔的距离
        flag[ux][uy] = true;
        coord uu = u;
        uu.t1 = 0;//在光环内要及时清零
        q.push(uu);//添加新的节点
        if (uu.Ax == uu.demx && uu.Ay == uu.demy) {
            cout << uu.t;
            return 0;
        }//小A移动后的特判
    }
    else if (l.t1 + 1 <= s) {//若dis(u)>d，则看看时间是否超出s，若未超出即可添加新节点
        coord uu = u;
        uu.t1 = l.t1 + 1;//超出的时间要加1
        q.push(uu);//添加新的节点
        flag[ux][uy] = true;//打标记
        if (uu.Ax == uu.demx && uu.Ay == uu.demy) {
            cout << uu.t;
            return 0;
        }//小A移动后的特判
    }
}
```

### Part 4 完整代码

AC code（含详细注释）：

```cpp
#include <iostream>
#include <cmath>
#include <string>
#include <queue>
using namespace std;
#define y1 y_
#define x1 x_
//typedef long long int;
const int maxn = 55;
int dx[] = { 0,1,0,-1 };
int dy[] = { 1,0,-1,0 };
bool flag[maxn][maxn];
struct coord {
    int Ax, Ay;//小A的坐标
    int sx, sy;//萨尔的坐标
    int demx, demy;//魔王的坐标
    int t;//已用时间
    int t1 = 0;//超出光环的时间（默认为0）
};
queue<coord> q;
char c[maxn][maxn];
int n, m, s, d;
double dis(coord a) {//距离函数
    double d = sqrt(pow(a.Ax - a.sx, 2) + pow(a.Ay - a.sy, 2));
    return d;
}
coord Sal(coord x, int s) {
    if (s == 0)
        return x;
    else if (s == 1) {
        int ux = x.sx - 1, uy = x.sy;
        if (ux <= 0 || c[ux][uy] == '1')
            return x;
        x.sx = ux;
        return x;
    }//向上走
    else if (s == 2) {
        int ux = x.sx + 1, uy = x.sy;
        if (ux > n || c[ux][uy] == '1')
            return x;
        x.sx = ux;
        return x;
    }//向下走
    else if (s == 3) {
        int ux = x.sx, uy = x.sy - 1;
        if (uy <= 0 || c[ux][uy] == '1')
            return x;
        x.sy = uy;
        return x;
    }//向左走
    else {
        int ux = x.sx, uy = x.sy + 1;
        if (uy > m || c[ux][uy] == '1')
            return x;
        x.sy = uy;
        return x;
    }//向右走
}
coord Dem(coord x, int m1) {
    if (m1 == 0)
        return x;//原地不动
    else if (m1 == 1) {
        int ux = x.demx - 1, uy = x.demy;
        if (ux <= 0 || c[ux][uy] == '1')
            return x;
        x.demx = ux;
        return x;
    }//向上走
    else if (m1 == 2) {
        int ux = x.demx + 1, uy = x.demy;
        if (ux > n || c[ux][uy] == '1')
            return x;
        x.demx = ux;
        return x;
    }//向下走
    else if (m1 == 3) {
        int ux = x.demx, uy = x.demy - 1;
        if (uy <= 0 || c[ux][uy] == '1')
            return x;
        x.demy = uy;
        return x;
    }//向左走
    else {
        int ux = x.demx, uy = x.demy + 1;
        if (uy > m || c[ux][uy] == '1')
            return x;
        x.demy = uy;
        return x;
    }//向右走
}
int main() {
    cin >> n >> m >> s >> d;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            do
                c[i][j] = getchar();
            while (c[i][j] == ' ' || c[i][j] == '\n' || c[i][j] == '\r');//防止读入空格、回车
        }
    }
    int x, y, x1, y1;
    cin >> x >> y >> x1 >> y1;
    flag[x][y] = true;
    string S, M;
    getline(cin, S);//getline的坑点，会读入上一行的回车
    getline(cin, S);
    getline(cin, M);
    coord l;
    l.Ax = l.sx = x, l.Ay = l.sy = y;
    l.demx = x1, l.demy = y1;
    l.t = 0;
    q.push(l);
    while (!q.empty()) {
        coord l = q.front();
        q.pop();
        l.t++;
        coord u;
        int s1 = S[(l.t - 1) % S.size()] - '0';//确定萨尔的数字（即移动方式）
        int m1 = M[(l.t - 1) % M.size()] - '0';//确定魔王的数字（即移动方式）
        u = Sal(l, s1), u = Dem(l, m1);
        if (u.Ax == u.demx && u.Ay == u.demy) {
            cout << u.t;
            return 0;
        }//魔王移动后的特判
        for (int i = 0; i < 4; i++) {
            int ux = l.Ax + dx[i], uy = l.Ay + dy[i];//用dx和dy模拟上下左右四个方向
            if (ux <= 0 || uy <= 0 || ux > n || uy > m || c[ux][uy] == '1' || flag[ux][uy] == true)
                continue;//如果超出地图范围或该区域是墙或已经走过，就不能再走了
            u.Ax = ux, u.Ay = uy;
            if (dis(u) <= d) {//dis表示小A与萨尔的距离
                flag[ux][uy] = true;
                coord uu = u;
                uu.t1 = 0;//在光环内要及时清零
                q.push(uu);//添加新的节点
                if (uu.Ax == uu.demx && uu.Ay == uu.demy) {
                    cout << uu.t;
                    return 0;
                }//小A移动后的特判
            }
            else if (l.t1 + 1 <= s) {//若dis(u)>d，则看看时间是否超出s，若未超出即可添加新节点
                coord uu = u;
                uu.t1 = l.t1 + 1;//超出的时间要加1
                q.push(uu);//添加新的节点
                flag[ux][uy] = true;//打标记
                if (uu.Ax == uu.demx && uu.Ay == uu.demy) {
                    cout << uu.t;
                    return 0;
                }//小A移动后的特判
            }
        }
    }
    return 0;
}
```
**另外强烈推荐[无注释](https://www.luogu.com.cn/paste/9rytauud)版。**

### Part 5 后记
此题的数据真的过水，几乎没有一个大的数据。总之，我们解决了一道超恶心、多细节的广搜题。如有错误，欢迎评论或私信指出。

---

## 作者：yangshurong (赞：4)

看别的题解都~~很欺负新手的~~没贴完整代码，我来一发完整代码

完完全全的暴力bfs

用队列存三个人每秒的状态，然后每次处理队首元素时直接判断小A是不是死了，或者是不是已经到了魔王的地方了。

注意一点：

这种模拟移动的题目

1.尽量写出每一种的移动状态，然后用数组来存。到时候直接枚举哪一种状态即可。

2.对于固定移动的两个人，也用类似的方法。

这样写的代码较少，可以极大减少出错率。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cmath>
#define rel(a) a=readl()
#define r(i,a,b) for(int i=a;i<=b;i++)
#define rr(i,a,b) for(int i=a;i>=b;i--)
#define r2(i,a,b) for(int i=a;i<=b;i+=2)
#define re(a) a=read()
#define pr(a) printf("%d\n",a)
#define in inline
#define ll long long
#define db double
#define id(i,j) ((i-1)*m+j)
using namespace std;
const int N=51;
inline int read(){
    char ch=getchar();
    int w=1,x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0',ch=getchar();}
    return x*w;
}
db d;
int n,m,s,mx[9]={0,1,-1,0,0},my[9]={0,0,0,-1,1},Kmx[2][N<<1],Kmy[2][N<<1],x,xx,y,yy,len[2];
struct point{
	int x,y;
	bool o;
}D[N*N];
struct node{
	point K[2],now;
	int out,sum;
};
queue<node>q;
in db dis(point a,point b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}
in void bfs(){
	node fr;fr.K[0]=D[id(x,y)],fr.K[1]=D[id(xx,yy)],fr.now=D[id(x,y)],fr.out=fr.sum=0;
	q.push(fr);
	//q.push((node){D[id(x2,y2)],D[id(x1,y1)],D[id(x1,y1)],0,0});
	while(!q.empty()){
		node fr=q.front();q.pop();
		if(fr.out>s)continue;
		point now=fr.now,Kn[2],nown;int sum=fr.sum,out=fr.out,nx,ny;
		if(now.x==fr.K[1].x&&now.y==fr.K[1].y){
			printf("%d\n",sum);
			exit(0);
		}
		node nstep;
		r(i,0,1){
			nx=fr.K[i].x+Kmx[i][sum%len[i]],ny=fr.K[i].y+Kmy[i][sum%len[i]];
			if(nx<=n&&nx>=1&&ny<=m&&ny>=1&&!D[id(nx,ny)].o)Kn[i]=D[id(nx,ny)];
			else Kn[i]=fr.K[i];
		}
		r(i,0,4){
			nx=now.x+mx[i],ny=now.y+my[i];
			if(nx<=n&&nx>=1&&ny<=m&&ny>=1&&!D[id(nx,ny)].o){
				nown=D[id(nx,ny)];
				r(j,0,1)nstep.K[j]=Kn[j];
				nstep.now=nown;nstep.out=dis(nown,Kn[0])>d?out+1:0;	nstep.sum=1+sum;
				q.push(nstep);
			}
		}
	}	
}
int main(){
	re(n),re(m),re(s);scanf("%lf",&d);char ch[N<<1];
	r(i,1,n){
		scanf("%s",ch+1);
		r(j,1,m)D[id(i,j)]=(point){i,j,ch[j]-'0'};
	}
	re(x),re(y),re(xx),re(yy);
	r(i,0,1){
		scanf("%s",ch);len[i]=strlen(ch);int t;
		r(j,0,len[i]-1){
			t=ch[j]-'0';
			if(t==0)Kmx[i][j]=Kmy[i][j]=0;
			else if(t==1)Kmx[i][j]=-1,Kmy[i][j]=0;
			else if(t==2)Kmx[i][j]=1,Kmy[i][j]=0;
			else if(t==3)Kmx[i][j]=0,Kmy[i][j]=-1;
			else if(t==4)Kmx[i][j]=0,Kmy[i][j]=1;
		}
	}
	bfs();
	return 0;
}

/*
3 4 7 3
1010
0000
0101
1 2 3 3
0132401
12131
*/
```


---

## 作者：谋事在人 (赞：3)

## 0.题目大意：
萨尔，小A，恐惧魔王三个人在幽暗城中行动，萨尔和恐惧魔王都会按照指定的方式行动，小A可以自由行动，但是不能离开萨尔s范围外d秒以上。有的格子是障碍无法通行，问小A最快在第几秒抓到恐惧魔王。

N，M<=50的数据很明显是搜索。
## 1.题目分析
数据范围中1<=答案<=100非常特别，让我们想到了迭代加深搜索，限制搜索的层数，如果搜不到就增加层数。记录限制时长，当前位置，当前时间，已经离开距萨尔s范围的时间。复杂度~~O（能过）~~ 应该是和bfs差不多的（bfs里每个状态都会被搜到一遍，bfs中没搜到的状态因为层数限制也不会被搜到。

## 2.实现细节
预处理出萨尔和恐惧魔王在100秒内的行动轨迹~~卡常是好习惯~~，注意这两个都有可能怼墙或者出界，特判一下，如果出现这两种情况就让他们不动。

## 3.各类坑点
题目中最大的坑！读入的x,y坐标是相反的（调了我一个小时）有的数据会有人在墙上的情况出现，对地图中的点的判断要判断map[y][x]而非map[x][y]

还有一些小坑，包括但不限于：

* 人是可以不动，等着恐惧魔王撞上来的（转移时要枚举不动这种情况）
* 题目中的坐标系是以左上角为(1,1),右下角为（n,m）的。

## 4.代码
还有不懂的细节可以看注释
```
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int dx[5]={0,0,0,-1,1},dy[5]={0,-1,1,0,0};//移动的状态
const double eps=1e-6;

int len,now,x,y,n,m,s,t,sx,sy,tx,ty,ans,salx[110],saly[110],dlx[110],dly[110];//四个数组分别是萨尔和恐惧魔王的位置
bool map[1010][1010];
char sal[110],dl[110],ss[1010];

int dis(int ax,int ay,int bx,int by){
	return sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by))+eps;
}

void dfs(int maxn,int nowx,int nowy,int away,int time){
	if(time>maxn)
		return;//搜索到上界
	if(away>t) return;//人死了
	if(nowx==dlx[time] && nowy==dly[time]) ans=time;//抓到魔王
	for(int i=0;i<=4;i++){
		int x=nowx+dx[i],y=nowy+dy[i];
		if(x<1 || x>m || y<1 || y>n) continue;
		if(map[y][x]) continue;
		dfs(maxn,x,y,dis(x,y,salx[time],saly[time])>s ? away+1 : 0,time+1);
	}
}

int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for(int i=1;i<=n;i++){
		scanf("%s",ss+1);
		for(int j=1;j<=m;j++)
			map[i][j]=ss[j]-'0';
	}
	scanf("%d%d%d%d",&sy,&sx,&ty,&tx);//大坑
	if(sx==tx && sy==ty){
		printf("0\n");//特判初始位置相同
		return 0;
	}
	scanf("%s%s",sal,dl);
	len=strlen(sal);x=sx;y=sy;now=0;
	sal[0]-='0';
	for(int i=0;i<=110;i++){
		salx[i]=x;
		saly[i]=y;
		x+=dx[sal[now]];
		y+=dy[sal[now]];
		if(map[y][x]){
			x=salx[i];
			y=saly[i];
			now=(now+1)%len;
			sal[now]%='0';
			continue;
		}
		if(x<1 || x>m || y<1 || y>n){
			x=salx[i];
			y=saly[i];
		}//特判撞墙和出界
		now=(now+1)%(len+1);
		if(!now) now+=1;
		sal[now]%='0';
	}//预处理萨尔位置
	len=strlen(dl);x=tx;y=ty;now=0;
	dl[0]-='0';
	for(int i=0;i<=110;i++){
		dlx[i]=x;
		dly[i]=y;
		x+=dx[dl[now]];
		y+=dy[dl[now]];
		if(map[y][x]){
			x=dlx[i];
			y=dly[i];
			now=(now+1)%len;
			dl[now]%='0';
			continue;
		}
		if(x<1 || x>m || y<1 || y>n){
			x=dlx[i];
			y=dly[i];
		}
		now=(now+1)%(len+1);
		if(!now) now++;
		dl[now]%='0';
	}//预处理恐惧魔王的位置
	for(int i=1;i<=100;i++)
		if(!ans) dfs(i,sx,sy,0,0);
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：Seauy (赞：3)

## 看见没有 c++ 的 BFS，我就先来一发喽

算法就是爆搜，没有高科技的 BFS，讨论里有人用 A\* 过了很强啊

代码别写错就行了，这里再提醒大家两点：

1. 题目中说的上方其实就是 y-1，下方自然是 y+1。

2. 题目中给的输入格式是先输入 x 再输入 y，亲测这么写只有 10分，因为 x y 给的数据其实是反的，但是样例看不出来

接下来就逐行分析代码喽：

先定义一些基本的东西

```cpp
const short direx[]={0,0,0,-1,1};//上下左右向对方位，别忘了还有不动的情况
const short direy[]={0,-1,1,0,0};

struct Point
{
	double x,y;//存成 double 计算距离时减小误判
	const bool operator == (Point ob)//判断两点在同一位置
	{return x==ob.x && y==ob.y;}
	void Scan() {cin>>y>>x;}//输入有坑
	void Walk(short dire)//向 dire 方向移动
	{x+=direx[dire],y+=direy[dire];}
};

struct msg//BFS 队列里存的状态
{
	Point A,Sar,Devil;//A、萨尔、恐惧魔王的位置
	int step,Out;//现在走了多少步、出圈的时间
}start;//一开始的状态

int n,m,s,d;
bool mapn[Size+5][Size+5];//整张01地图
string order[2];int len[2];//萨尔、魔王的行走规律与其长度
queue<msg> BFS;//搜索队列

double Dis(Point a,Point b)//欧式距离
{return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}
```
然后是输入和预处理的部分
```cpp
scanf("%d %d %d %d",&n,&m,&s,&d);
for(int i=1;i<=n;i++)
{
	string temp;
	cin>>temp;
	for(int j=0;j<m;j++) mapn[i][j+1]=temp[j]-'0';
}//输入地图
for(int i=0;i<=m+1;i++) mapn[0][i]=mapn[n+1][i]=1;//边界打上障碍物以防出界
for(int i=1;i<=n  ;i++) mapn[i][0]=mapn[i][m+1]=1;
start.Sar.Scan(),start.Devil.Scan();//萨尔、魔王的位置
start.A=start.Sar;//当然A的位置跟萨尔是一样的
for(short i=0;i<2;i++)//输入行走规则
{
	cin>>order[i];
	len[i]=order[i].length();
}
BFS.push(start);
```
搜索开始
```cpp
while(!BFS.empty())
{
	msg now=BFS.front();BFS.pop();
	if(mapn[int(now.A.y)][int(now.A.x)] || now.Out>s) continue;
    //走到障碍物上或者死了
	if(now.A==now.Devil) {printf("%d\n",now.step);break;}//走到大魔王的地方了
	Point temp;//先让萨尔、魔王各自走一步，要走到障碍物上了就不走
	temp=now.Sar  ,temp.Walk(order[0][now.step%len[0]]-'0');
	if(!mapn[int(temp.y)][int(temp.x)]) now.Sar  =temp;
	temp=now.Devil,temp.Walk(order[1][now.step%len[1]]-'0');
	if(!mapn[int(temp.y)][int(temp.x)]) now.Devil=temp;
	for(short i=0;i<5;i++)//枚举五种行为方式
	{
		msg rear=now;
		rear.A.Walk(i);
		if(Dis(rear.A,rear.Sar)>d) rear.Out++;//出圈了就开始计数
		else rear.Out=0;//没出圈清0
		rear.step++;
		BFS.push(rear);
	}
}
```
然后加上 int main() 什么的整个代码就出来了

如果想看中间搜索过程的可以使用这个函数
```cpp
void Print_map(msg ob)
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
				 if(Point{j,i}==ob.A) printf("A ");
			else if(Point{j,i}==ob.Sar) printf("S ");
			else if(Point{j,i}==ob.Devil) printf("D ");
			else if(mapn[i][j]) printf("# ");
			else printf(". ");
		printf("\n");
	}
}
printf("step: %d Out: %d\n",now.step,now.Out);
system("pause");
system("cls");
```
可以可视化展现一个状态

如果感觉太暴力了的话……可以剪一下枝，但是这已经够用了，所有点 3ms 跑完

这里只给出一个剪枝

先定义一下出租车几何的距离公式：
```cpp
int Taxi_Dis(Point a,Point b)
{return abs(a.x-b.x)+abs(a.y-b.y);}
```
如果萨尔和小A拼了命互相奔去还不能救回小A，那就~~没救了~~continue

```cpp
if(Taxi_Dis(now.A,now.Sar)-d>s-now.Out) continue;
```

不过剪的枝不多，只快了那么 1ms

哦对了，这题没法写 visit，你如果要写判重的话至少要六重（三个点坐标）
$ 50^6 $ 当场去世，你当然可以试试 map，但是同样的，用处不大，本身状态重复的几率就不是很大，而且 map 的效率其实比 O(1) 要慢不少，不仅耗内存，搞不好还要 T

然后你就可以华丽地A了一道紫题了，怎么样，是不是很 Excited ！？

---

## 作者：May_Cry_ (赞：2)

### 题目大意

- 给定小 A，恐惧魔王和萨尔的初始位置，求出小 A 遇上恐惧魔王的最短时间。

- 萨尔和恐惧魔王的移动方式是固定的。

- 小 A 不能距离萨尔超过 $ d $ 距离外 $ s $ 秒。

### 思路

显然，可以用 bfs 模拟这三个人的移动，当 小 A 和恐惧魔王在相同位置时即可输出所需时间，当然各位 dalao 也可用迭代加深搜索做，但本蒟蒻不会。

### 代码实现

由于我们要存三个人的状态，所以细节还是蛮多的。

1. 我们定义一个队列存储每个人的位置，小 A 距离萨尔超过 $ d $ 距离的时间 $ ti $ 以及走到当前位置需要的时间 $ t $。（$ti$ 是个变量名）

1. 因为萨尔和恐惧魔王的移动方式固定，所以可以直接将字符串转换为数字，分别记录两人一次规则运动的步数即字符串的长度为 $ size_1 $ 和 $ size_2 $，在 bfs 时可以直接 $ t \bmod size_1$ 和 $t \bmod size_2 $ 求出萨尔和恐惧魔王下一步的方向。

1. 当小 A 距萨尔不超过 $ d $ 距离时 $ ti $ 值赋为 $ 0 $，这样小 A 重新进入萨尔的光环范围内时 $ ti $ 就可以及时更新，当两人距离大于 $ d $ 时 $ ti + 1 $，当 $ ti > s $ 时就直接跳过。

1. 可以专门写个函数来求小 A 与萨尔的距离，记得一定要用 ` double `。

1. 剩下的操作就是常规 bfs 了，数据很水，所以能过。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int tot ,cnt;
int a[1001][1001];
int n , m ,s , d;
int sx ,sy ,zx ,zy;
int hu[10001];
int mo[10001];
string s1 ,s2;
const double eps=1e-6;
int dx[6] = {0 ,-1 ,1 ,0 ,0 ,0};
int dy[6] = {0 ,0 ,0 ,-1 ,1 ,0};
struct node{
	int ax ,ay;
	int sx ,sy;
	int mx ,my;
	int t ,ti;
};
queue <node> q;
bool Saber(int x,int xx,int y,int yy){
	double s = sqrt((x - xx) * (x - xx) + (y - yy) * (y - yy)) + eps;
	return s <= d * 1.0;
}
bool check(int x,int y){
	return x > 0 && x <= n && y > 0 && y <= m && !a[x][y];
}
void bfs(){
    q.push((node){sx ,sy ,sx ,sy ,zx ,zy, 0, 0});
	while(q.size()){
	    node nw = q.front();q.pop();
	    if(nw.ax == nw.mx && nw.ay == nw.my){
	    	cout << nw.t;exit(0);
	    }
	    nw.t ++;
	    int la = nw.t % tot;if(la == 0)la = tot;
	    int lb = nw.t % cnt;if(lb == 0)lb = cnt;
	    nw.sx += dx[hu[la]],nw.sy += dy[hu[la]];
	    if(!check(nw.sx,nw.sy))nw.sx -= dx[hu[la]],nw.sy -= dy[hu[la]]; 
		nw.mx += dx[mo[lb]],nw.my += dy[mo[lb]]; 
		if(!check(nw.mx,nw.my))nw.mx -= dx[mo[lb]],nw.my -= dy[mo[lb]];
		for(int i = 1;i <= 5;i ++){
			int fx = nw.ax + dx[i];
			int fy = nw.ay + dy[i];
			if(!check(fx ,fy))continue;
			if(Saber(fx , nw.sx ,fy ,nw.sy) > d){
				if(nw.ti + 1 > s)continue;
				nw.ti ++;
			}
			else nw.ti = 0;
			q.push((node){fx ,fy ,nw.sx ,nw.sy ,nw.mx ,nw.my ,nw.t ,nw.ti});
		}
	}	
}
int main(){
       cin >> n >> m >> s >> d;
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= m;j ++){
			char ch;cin >> ch;
			if(ch == '1')a[i][j] = 1;
		}
	}
	cin >> sx >> sy >> zx >> zy;
	cin >> s1 >> s2;
	for(int i = 0;i < s1.size();i ++){
		hu[++ tot] = s1[i] - '0';
	}
	for(int i = 0;i < s2.size();i ++){
		mo[++ cnt] = s2[i] - '0';
	}
	bfs();
}
```

---

## 作者：momentous (赞：2)

## [My Blog](https://www.luogu.com.cn/blog/lyslys/)

首先,你要知道什么是 $\text{bfs}$

若不知道,可以看一下这道题:[P1443(很好的bfs入门)](https://www.luogu.com.cn/problem/P1443) 以及我的[题解](https://www.luogu.com.cn/blog/lyslys/solution-p1443)

个人认为,这道题应在 $\text{提高+/省选-}$ 这个样子,细节有点多

由于 $ \text{Answer} \leq 100 $ 所以我们考虑预处理出魔王和萨尔的位置,进行 $\text{bfs}$

详细看注释吧

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 10050
class Queue{//手写队列,防止被卡,养成好习惯,从你我做起
	private:int a[N+50],l,r;
	public:int siz;
		inline void clear(){l=r=siz=0;}
		inline void push(const int x){a[r++]=x;siz++;if(r>N) r=0;}
		inline void pop(){l++;siz--;if(l>N) l=0;}//循环队列
		inline int front(){return a[l];}
}qx,qy,qt,qstep;
const int xx[5]={0,-1,1,0,0},yy[5]={0,0,0,-1,1};
/*
分别对应:不动;上;下;左;右移动时x轴和y轴的变化
*/
#include<cmath>
/*
不能用"y1"这个变量名!!
*/
int n,m,s,Map[150][150],Lensaer,Lenmw;
int sax[150],say[150],mx[150],my[150];
char Strsaer[150],Strmw[150],Str[150];
double d;
int main(){
	scanf("%d%d%d%lf",&n,&m,&s,&d);
	for(int i=1;i<=n;++i){
		scanf("%s",Str+1);
		for(int j=1;j<=m;++j)
			Map[i][j]=Str[j]-48;
	}
	scanf("%d%d%d%d",&sax[0],&say[0],&mx[0],&my[0]);
	scanf("%s",Strsaer+1);
	scanf("%s",Strmw+1);
	Lensaer=strlen(Strsaer+1);
	Lenmw=strlen(Strmw+1);
	for(int i=1;i<=100;++i){
		sax[i]=sax[i-1]+xx[Strsaer[(i-1)%Lensaer+1]-48];
		say[i]=say[i-1]+yy[Strsaer[(i-1)%Lensaer+1]-48];//看不懂可以手动模拟一下
		if(Map[sax[i]][say[i]] || sax[i]<1 || sax[i]>n || say[i]<1 || say[i]>m)
			sax[i]=sax[i-1],say[i]=say[i-1];
	}
	for(int i=1;i<=100;++i){
		mx[i]=mx[i-1]+xx[Strmw[(i-1)%Lenmw+1]-48];
		my[i]=my[i-1]+yy[Strmw[(i-1)%Lenmw+1]-48];
		if(Map[mx[i]][my[i]] || mx[i]<1 || mx[i]>n || my[i]<1 || my[i]>m)
			mx[i]=mx[i-1],my[i]=my[i-1];
	}
   	//预处理出位置
	qx.push(sax[0]);
	qy.push(say[0]);
	qt.push(0);
	qstep.push(0);
   	//初始状态
	while(qx.siz){
		int x=qx.front();
		int y=qy.front();
		int t=qt.front();
		int step=qstep.front();
		qx.pop();
		qy.pop();
		qt.pop();
		qstep.pop();
       		//取出队首并弹出
		if(sqrt(1.0*(x-sax[step])*(x-sax[step])+1.0*(y-say[step])*(y-say[step]))>d) ++t;
       		//若距离大于d则离开时间+1
		else t=0;
		if(t>s) continue;
		if(x==mx[step] && y==my[step]){//找到最优解
			printf("%d\n",step);
			break;
		}
		if(x==mx[step+1] && y==my[step+1]){//若不动可以在下一步遇到魔王
			qx.push(x);
			qy.push(y);
			qt.push(t);
			qstep.push(step+1);
			continue;
		}
		for(int i=1;i<=4;++i){//枚举上下左右
			if(Map[x+xx[i]][y+yy[i]] || x+xx[i]<1 || x+xx[i]>n || y+yy[i]<1 || y+yy[i]>m) continue;
           		//注意细节
			qx.push(x+xx[i]);
			qy.push(y+yy[i]);
			qt.push(t);
			qstep.push(step+1);//存储下一个状态,压入队尾
		}
	}
	return 0;
}

```

---

## 作者：courage (赞：2)

朴素的BFS，这是我的Pascal代码

```delphi

type  
  rec1=record x,y:longint;end;  
  rec2=record t,x,y,L:longint;end;  
var  
  a:array[0..51,0..51] of char;  
  b,c:array[0..100] of rec1;  
  g:array[0..4,1..2] of longint=((0,0),(-1,0),(1,0),(0,-1),(0,1));  
  f:array[1..100000] of rec2;  
  n,m,ss,d,i,j,k,x1,x2,y1,y2,sta,x,y,t:longint;  
  s:string;  
procedure print(x:longint);  
begin  
  writeln(x);  
  halt;  
end;  
function safe(t,x,y:longint):boolean;  
begin  
  if (x-b[t].x)*(x-b[t].x)+(y-b[t].y)*(y-b[t].y)<=d*d then exit(true);  
  exit(false);  
end;  
function next(x:longint):longint;  
begin  
  inc(x);  
  if x>100000 then x:=1;  
  exit(x);  
end;  
procedure go(var x,y:longint;p:longint);  
begin  
  sta:=0;  
  if a[x+g[p,1],y+g[p,2]]='1' then exit;  
  x:=x+g[p,1];  
  y:=y+g[p,2];  
  sta:=p;  
end;  
begin  
  for i:=0 to 51 do  
    for j:=0 to 51 do a[i,j]:='1';  
  readln(n,m,ss,d);  
  for i:=1 to n do  
    begin  
      for j:=1 to m do read(a[i,j]);  
      readln;  
    end;  
  readln(x1,y1,x2,y2);  
  readln(s);  
  b[0].x:=x1;b[0].y:=y1;  
  c[0].x:=x2;c[0].y:=y2;  
  if (x1=x2)and(y1=y2) then print(0);  
  for i:=1 to 100 do  
    begin  
      go(x1,y1,ord(s[(i-1) mod length(s)+1])-48);  
      b[i].x:=x1;b[i].y:=y1;  
    end;  
  readln(s);  
  for i:=1 to 100 do  
    begin  
      go(x2,y2,ord(s[(i-1) mod length(s)+1])-48);  
      c[i].x:=x2;c[i].y:=y2;  
    end;  
  i:=1;  
  j:=1;  
  f[1].t:=0;  
  f[1].x:=b[0].x;  
  f[1].y:=b[0].y;  
  f[1].L:=ss;  
  while i<>next(j) do  
    begin  
      t:=f[i].t+1;  
      x:=f[i].x;  
      y:=f[i].y;  
      if safe(t,x,y) or (f[i].L>0) then  
        begin  
          j:=next(j);  
          f[j].x:=x;  
          f[j].y:=y;  
          f[j].t:=t;  
          if (x=c[t].x)and(y=c[t].y) then print(t);  
          if safe(t,x,y) then f[j].L:=ss else f[j].L:=f[i].L-1;  
        end;  
      for k:=1 to 4 do  
        begin  
          x:=f[i].x;  
          y:=f[i].y;  
          go(x,y,k);  
          if sta=0 then continue;  
          if not(safe(t,x,y) or (f[i].L>0)) then continue;  
          j:=next(j);  
          f[j].x:=x;  
          f[j].y:=y;  
          f[j].t:=t;  
          if (x=c[t].x)and(y=c[t].y) then print(t);  
          if safe(t,x,y) then f[j].L:=ss else f[j].L:=f[i].L-1;  
        end;  
      i:=next(i);  
    end;  
end. 

```

---

## 作者：I_will_AKIOI (赞：0)

随机到一篇绿题搜索，还能写题解，当然是切掉啦。

本题看着是中等模拟加搜索的四不像题。我们将它分成四部分。

#### 运动方式

首先，我们理解他们三人是咋运动的。萨尔和魔王的移动都是有规律可循，给你一个运动规律，模拟出这两人的运动方式。

其次是小 A 的运动。这个人比较烦，没规律可循，我们就需要使用 BFS 搜索小 A 的移动。

#### 搜索

搜索我们需要在结构体中定义 $8$ 个变量来存储移动信息，不愧是绿题的搜索，没那么简单。分别是 $xa,ya,xs,ys,xm,ym,s,t$。分别对应小 A 的坐标，萨尔的坐标，魔王的坐标，当前时间，离开光环的时间。

接下来就是搜索的主要部分。第一步，我们需要模拟萨尔和魔王的移动。顺便判断一下有没有相遇。

```
w=q.front();
xa=w.xa,ya=w.ya;
xs=w.xs,ys=w.ys;
xm=w.xm,ym=w.ym;
s=w.s,t=w.t;
int nx,ny;
nx=xs+fx[a[s%a.size()]-48],ny=ys+fy[a[s%a.size()]-48];
if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&v[nx][ny]==0) xs=nx,ys=ny;
nx=xm+fx[b[s%b.size()]-48],ny=ym+fy[b[s%b.size()]-48];
if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&v[nx][ny]==0) xm=nx,ym=ny;
//模拟萨尔和魔王的行动，符合要求才能移动，否则不移动。
s++;
if(xa==xm&&ya==ym) return s;
```
其次，枚举小 A 的行动。我们需要判断有没有超出距离，有没有超出光环的保护时间。

```
for(int i=1;i<=4;i++)
{
  nx=xa+fx[i],ny=ya+fy[i];
  if(nx<1||nx>n||ny<1||ny>m||v[nx][ny]||vis[nx][ny]) continue;
  double dis=sqrt((nx-xs)*(nx-xs)+(ny-ys)*(ny-ys));//计算小A和萨尔的距离
  int t1=t; 
  if(dis>d) t1++;
  else t1=0;
  //重新计算保护时间
  if(t1<=s1)
  {
    if(nx==xm&&ny==ym) return s;//必须特判！否则喜提70pts
    vis[nx][ny]=1;
    q.push(data{nx,ny,xs,ys,xm,ym,s,t1});
    //符合要求，加入新节点
  }
}
q.pop();
```
#### 细节处理

1. 搜索小 A 的行动时特判两人有没有相遇，否则会喜提 $70pts$。

2. 记得将结构体出队。

3. 操作中定义新变量操作，否则变量不清空导致爆零。

4. 一开始记得将起点设置为已访问。

我们就轻松过了一道绿题。

---

## 作者：miss_A (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1374)

[欢迎来博客阅读](https://blog.csdn.net/m0_71452979/article/details/132392758?spm=1001.2014.3001.5501)

刚刚翻题解区发现我的做法和一些神犇有亿点相似...？不会是老师给我们讲题之前看过题解吧......（老师您可千万别看见我......

***

这道题是在地图上的操作，四个方向，因此大概率是搜索。求的是和魔王相遇所需的最短时间，刚好和广搜十分吻合。如果对广搜还有疑惑，建议先去看看 [p1443](https://www.luogu.com.cn/problem/P1443)，是很好的广搜模板题。

基本思路很简单，模拟萨尔和魔王的位置变化，同时循环模拟出小A所有可能的移动，当小 A 与魔王位置相同时，输出总时间。

***

基本地，用 bool 类型的 mark 数组存储是否走过的信息，小A每次移动后都要标记走过。用 char 类型的 map 数组存储地图，因为输入的 01 矩阵没有空格，如果用 int 类型的话每行就会被存成一个整数。

额外的，表示萨尔和魔王移动的数字串要用字符数组或字符串来存储，原因同上，同时在取第i位时要注意将字符类型转化为整数类型。

***

首先定义一个结构体 info，存储 3 人的基本信息。

```cpp
struct info
{
    int a_x, a_y;//小A的位置
    int s_x, s_y;//萨尔的位置
    int devil_x, devil_y;//魔王的位置
    int t, t1;//总秒数, 超出光环的秒数
};
```

如果在光环内，就把 t1 赋值为 0，否则就在上一次移动的基础上 +1。

***

然后用两个函数分别模拟萨尔和魔王的移动。注意，如果数字串当前位为0就原地不动，如果移动后会超出边界也要原地不动。

```cpp
info master_move(info temp, int master){
    if(master == 0)return temp;//当前数字是0，原地不动
    if(master == 1){//向上走
        int xx = temp.s_x - 1;
        int yy = temp.s_y; 
        if(!check(xx, yy))return temp;
        temp.s_x = xx;
        return temp;
    }
    else if(master == 2){//向下走
        int xx = temp.s_x + 1;
        int yy = temp.s_y;
        if(!check(xx, yy))return temp;
        temp.s_x = xx;
        return temp;
    }
    else if(master == 3){//向左走
        int xx = temp.s_x;
        int yy = temp.s_y - 1;
        if(!check(xx, yy))return temp;
        temp.s_y = yy;
        return temp;
    }
    else {//向右走
        int xx = temp.s_x;
        int yy = temp.s_y + 1;
        if(!check(xx, yy))return temp;
        temp.s_y = yy;
        return temp;
    }
}
```

魔王和萨尔的函数几乎相同，在此不多赘述，只是要注意变量名的变化。

***

### AC代码

```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <cmath>
#include <algorithm>
#include <queue>

using namespace std;
int n, m, s, d;//n * m, 超出光环的秒数, 光环笼罩的范围
int _x, _y, x2, y2;
bool mark[55][55];
//方向数组
int cx[5] = {0, 1, -1, 0, 0};
int cy[5] = {0, 0, 0, 1, -1};
string sal, devil;

struct info
{
    int a_x, a_y;//小A的位置
    int s_x, s_y;//萨尔的位置
    int devil_x, devil_y;//魔王的位置
    int t, t1;//总秒数, 超出光环的秒数
};
queue <info> line;
char map[55][55];

double howfar(info m){//小A和萨尔之间的距离
    double x = sqrt(pow(m.a_x - m.s_x, 2) + pow(m.a_y - m.s_y, 2));//距离公式
    return x;
}

bool check(int x, int y){
    //如果这个点超出了边界，或者已经走过，或者是障碍，那么就不可以走
    if(x > n || x <= 0 || y > m || y <= 0 || mark[x][y] == 1 || map[x][y] == '1')return 0;
    return 1;
}

info master_move(info temp, int master){
    if(master == 0)return temp;//当前数字是0，原地不动
    if(master == 1){//向上走
        int xx = temp.s_x - 1;
        int yy = temp.s_y; 
        if(!check(xx, yy))return temp;
        temp.s_x = xx;
        return temp;
    }
    else if(master == 2){//向下走
        int xx = temp.s_x + 1;
        int yy = temp.s_y;
        if(!check(xx, yy))return temp;
        temp.s_x = xx;
        return temp;
    }
    else if(master == 3){//向左走
        int xx = temp.s_x;
        int yy = temp.s_y - 1;
        if(!check(xx, yy))return temp;
        temp.s_y = yy;
        return temp;
    }
    else {//向右走
        int xx = temp.s_x;
        int yy = temp.s_y + 1;
        if(!check(xx, yy))return temp;
        temp.s_y = yy;
        return temp;
    }
}
info lord_move(info temp, int lord){
    if(!lord)return temp;//当前数字是0，原地不动
    if(lord == 1){//向上走
        int xx = temp.devil_x - 1;
        int yy = temp.devil_y;
        if(!check(xx, yy))return temp;
        temp.devil_x = xx;
        return temp;
    }
    else if(lord == 2){//向下走
        int xx = temp.devil_x + 1;
        int yy = temp.devil_y;
        if(!check(xx, yy))return temp;
        temp.devil_x = xx;
        return temp;
    }
    else if(lord == 3){//向左走
        int xx = temp.devil_x;
        int yy = temp.devil_y - 1;
        if(!check(xx, yy))return temp;
        temp.devil_y = yy;
        return temp;
    }
    else {//向右走
        int xx = temp.devil_x;
        int yy = temp.devil_y + 1;
        if(!check(xx, yy))return temp;
        temp.devil_y = yy;
        return temp;
    }
}

int main(){

    freopen("code.in", "r", stdin);
    freopen("code.out", "w", stdout);

    cin >> n >> m >> s >> d;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            cin >> map[i][j];
        }
    
    cin >> _x >> _y >> x2 >> y2;
    mark[_x][_y] = true;
    getline(cin, sal);//getline会读入上一行的回车，所以要用两次getline覆盖
    getline(cin, sal);
    getline(cin, devil);

    info point;
    point.a_x = point.s_x = _x;
    point.a_y = point.s_y = _y;
    point.devil_x = x2;
    point.devil_y = y2;
    point.t = point.t1 = 0;
    line.push(point);

    while(!line.empty()){
        info point = line.front();
        line.pop();
        point.t++;//总时间+1

        int master, lord;
        //字符串中第t位，并转为整数类型
        master = sal[(point.t - 1) % sal.size()] - '0';
        lord = devil[(point.t - 1) % devil.size()] - '0';

        info now;
        now = master_move(point, master);//更新萨拉的位置
        now = lord_move(point, lord);//更新魔王的位置
        //魔王移动后判断小A与魔王的相对位置
        if(now.a_x == now.devil_x && now.a_y == now.devil_y){
            cout << now.t << endl;
            return 0;
        }
        
        //小A开始移动
        for(int i = 1; i <= 4; i++){//小A可以向四个方向移动，每次一个单位长度
            //移动后坐标
            int xx = point.a_x + cx[i];
            int yy = point.a_y + cy[i];
            if(check(xx, yy)){//可以移动到这个坐标
                now.a_x = xx;
                now.a_y = yy;
                if(howfar(now) <= d){//在光圈内
                    info next = now;
                    next.t1 = 0;//超出光圈的时间清零
                    mark[xx][yy] = 1;//标记走过
                    line.push(next);
                    if(now.a_x == now.devil_x && now.a_y == now.devil_y){//如果小A遇到魔王
                        cout << now.t << endl;
                        return 0;
                    }
                }
                else if(now.t > s){//超出存活时间，不可继续
                    continue;
                }
                else {//不在光圈内，但是仍在存活时间内。仍可添加新节点
                    info next = now;
                    next.t1 = point.t1 + 1;//光圈外活动时间+1
                    line.push(next);
                    mark[xx][yy] = 1;
                    if(now.a_x == now.devil_x && now.a_y == now.devil_y){//如果小A遇到魔王
                        cout << now.t << endl;
                        return 0;
                    }
                }
            }
        }
    }

    return 0;
}
```



---

## 作者：Maxwang (赞：0)

这道题是在地图上的操作，我们显然就想到搜索，

### 核心算法

但是每层会有 $5$ 种状态，最多走 $100$ 层，最坏情况下就要 $5^{100}$ 次，显然是我们没法接受的，实际上加了剪枝我也没过，我们看到题目里有这样一句话

> 0<=答案<=100

稳了，是迭代加深，那么，什么是迭代加深呢？

简单来说就是我们按层搜索，先搜索深度浅的，如果没有再搜索深的，限定层数，到达层数再返回，把限定的层数增加 $1$，然后再重搜一遍。

但是也许会有人问，那么这样不会走冤枉路吗？

确实，但是我们可以少走不少冤枉路，如图，答案在根节点的儿子里，但是我们仍然不得不从第一个子节点走到底，最坏情况下多走了 $4 \times5^{98}$ 次，显然会 TLE，假如我们先搜浅的再搜深的，就一定会解决答案较小时的数据点，拿到更多的分数，尤其是这种限制了答案层数的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/uztu0hkw.png)

解决了主要思路，我们来想想实现。

### 实现

#### 坐标

看到讨论区以及之前来的大佬都在纠结下标的问题，其实 x 和 y 是很好解决的，也完全没有必要反序输入或者判断，之前的大佬都是两反 = 不反了，由于程序读入的限制，我们只能横着读，依据一般人的读写习惯：

- 外层是 i，内层是 j。

- 数组下标是 $f_{i,j}$

举个栗子：
```cpp
for(int i = 1;i <= n;i++)
{
    for(int j = 1;j <= m;j++)
    {
        readint(a[i][j]);
    }
}
```
这时数组竖着有 $n$ 行，横着有 $m$ 列。

即：

|  | 1 | 2 | 3 | 4 | 5 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $f_{1,1}$ | $\star f_{1,2}$ | $f_{1,3}$ | $f_{1,4}$ | $f_{1,5}$ |
| 2 | $f_{2,1}$ | $f_{2,2}$ | $f_{2,3}$ | $f_{2,4}$ | $f_{1,5}$ |
| 3 | $f_{3,1}$ | $f_{3,2}$ | $f_{3,3}$ | $f_{3,4}$ | $f_{3,5}$ |
| 4 | $f_{4,1}$ | $f_{4,2}$ | $f_{4,3}$ | $f_{4,4}$ | $f_{4,5}$ |
| 5 | $f_{5,1}$ | $f_{5,2}$ | $f_{5,3}$ | $f_{5,4}$ | $f_{5,5}$ |

$f_{i,j}$ 即对应 `f[i][j]`

相对应的，本题的 x,y 也应该满足以上条件。

![](https://cdn.luogu.com.cn/upload/image_hosting/f1b7thm6.png)


即 $x = 1,y = 2$ 时，应该在上表中标星号处。

由此，我们可以看出，$1\to4$ 的操作满足以下关系：

1. 向上，$x_{tar}=x-1,y_{tar}=y$；
1. 向下，$x_{tar}=x+1,y_{tar}=y$；
1. 向左，$x_{tar}=x,y_{tar}=y-1$；
1. 向右，$x_{tar}=x,y_{tar}=y+1$。

其中，$x_{tar},y_{tar}$ 分别指操作后的坐标值。

因此，我们只需要正常输入 $x,y$，并且按照上述方式操作即可。

### 双方位置的表示

萨尔和魔王我们可以预处理出他们 $100$ 步中走到的点，然后到什么时候取什么时候的点就行了，操作序列不够长我们就把他接上去，接到 $100$ 以上就行~~反正也不长~~。

```cpp
cin>>s1>>s2;//读入操作序列 
	
string temp;
while(temp.size() <= 100)//搞到100 
temp += s1;

s1 = temp;
temp = "";

while(temp.size() <= 100)
temp += s2;
	
s2 = temp;
	
pre();
pre_road_sal(x_1,y_1,0);
pre_road_lof(x_2,y_2,0);//预处理路径
```
预处理函数：
```cpp
void pre_road_sal(int x,int y,int o)
{
	sal.push_back(make_pair(x,y));//加入序列数组 
	if(o > 100) return;//预处理到100 
	
	//定义下一步的x,y(先定义出来(也许)能减少运算次数) 
	rint tar_x = x + opt[s1[o] - '0'].xx;
	rint tar_y = y + opt[s1[o] - '0'].yy;
    
	if(tar_x > n || tar_x < 1 || tar_y > m || tar_y < 1 
    		     || map[tar_x][tar_y] == 1)
	//如果超出边界 or 撞墙 
	{
		tar_x = x;
		tar_y = y; // 在原地待着 
	}
	pre_road_sal(tar_x,tar_y,o + 1);//下一位置 
}

//魔王的，同上 
void pre_road_lof(int x,int y,int o)
{
	lof.push_back(make_pair(x,y));
	if(o > 100) return;
		
	rint tar_x = x + opt[s2[o] - '0'].xx;
	rint tar_y = y + opt[s2[o] - '0'].yy;
	if(tar_x > n || tar_x < 1 || tar_y > m || tar_y < 1 
    		     || map[tar_x][tar_y] == 1)
	{
		tar_x = x;
		tar_y = y;
	}
	pre_road_lof(tar_x,tar_y,o + 1);
}
```

预处理之后我们就知道他们每一时刻的位置啦，然后就搜索吧

```cpp
//距离函数 
double dis(int x__1,int y__1,int x__2,int y__2)
{
	double a = (double)abs(x__1 - x__2),b = (double)abs(y__1 - y__2);
	return sqrt(a * a + b * b);
} 

//       x坐标|y坐标 |离开时间 |  深度   |   最大深度 
void dfs(int x,int y,int time,int depth,int max_depth)
{
	if(depth > max_depth) return;//超出深度 
	
	time = (dis(x,y,sal[depth].first,sal[depth].second) <= d) ? 0 : time + 1;
	//如果超出了，计算时间 + 1，没超出或者回来了，更新为0。 
	
	if(time > s) return;//超出时间 
	
	if(lof[depth].first == x && lof[depth].second == y)
    	//找到了 
	{
		printf("%d\n",depth);
		exit(0);  //退出
	}
	for(rint i = 0;i <= 4;i++)//枚举4种转移+一种待在原地 
	{	
		rint tar_x = x + opt[i].xx;
		rint tar_y = y + opt[i].yy;
		
		if(map[tar_x][tar_y]) continue;// 撞墙走不通 
		
		if(tar_x > n || tar_x < 1 || tar_y > m || tar_y < 1) 
        	 	continue;//超出边界 
		
		dfs(tar_x,tar_y,time,depth + 1,max_depth);//搜索下一层 
	}
}
```

注意一个坑点：`y0`，`y1` 是保留字，不能用。

`exit(0)` 是直接退出程序。

因为我们是按层搜的，所以比 ans 浅的节点都搜过了，我们找到一个解之后其他的解一定 $\geq \operatorname{depth}(ans)$。

直接退出就好啦

最后贴代码啦，里面有详尽的注释，希望能认真食用哦：
```cpp
#include<cstdio>
#include<iostream>
#include<vector> 
#include<cmath>

using namespace std;

#define rint register int
#define isnum(x) ('0' <= (x) && (x) <= '9')
template<typename tint>
inline void readint(tint& x) {
	int f = 1; char ch = getchar(); x = 0;
	for(;!isnum(ch); ch = getchar()) if(ch == '-') f = -1;
	for(;isnum(ch); ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	x *= f;
}
//快读 

int map[100][100];
//地图 

struct optx{
	int xx,yy;
}opt[10];
inline void pre(void)
{
	opt[0].xx = 0;opt[0].yy = 0;
	opt[1].xx = -1;opt[1].yy = 0;
	opt[2].xx = 1;opt[2].yy = 0;
	opt[3].xx = 0;opt[3].yy = -1;
	opt[4].xx = 0;opt[4].yy = 1;
	return;
}
//五种操作 

int n,m,s,d,ans = 0x3f3f3f3f;//各种变量，如题面所示

int x_1,y_1, x_2,y_2; 
//萨尔的x,y|魔王的x,y; 

vector<pair<int,int> >sal,lof;
                   //萨尔|魔王的路径 
                   
string s1,s2;
//   萨尔|魔王的操作序列 

void pre_road_sal(int x,int y,int o)
{
	sal.push_back(make_pair(x,y));//加入序列数组 
	if(o > 100) return;//预处理到100 
	
	//定义下一步的x,y(先定义出来(也许)能减少运算次数) 
	rint tar_x = x + opt[s1[o] - '0'].xx;
	rint tar_y = y + opt[s1[o] - '0'].yy;
	if(tar_x > n || tar_x < 1 || tar_y > m || tar_y < 1 || map[tar_x][tar_y] == 1)
	//如果超出边界 or 撞墙 
	{
		tar_x = x;
		tar_y = y; // 在原地待着 
	}
	pre_road_sal(tar_x,tar_y,o + 1);//下一位置 
}

//魔王的，同上 
void pre_road_lof(int x,int y,int o)
{
	lof.push_back(make_pair(x,y));
	if(o > 100) return;
		
	rint tar_x = x + opt[s2[o] - '0'].xx;
	rint tar_y = y + opt[s2[o] - '0'].yy;
	if(tar_x > n || tar_x < 1 || tar_y > m || tar_y < 1 || map[tar_x][tar_y] == 1)
	{
		tar_x = x;
		tar_y = y;
	}
	pre_road_lof(tar_x,tar_y,o + 1);
}

//距离函数 
double dis(int x__1,int y__1,int x__2,int y__2)
{
	double a = (double)abs(x__1 - x__2),b = (double)abs(y__1 - y__2);
	return sqrt(a * a + b * b);
} 

//       x坐标|y坐标|离开时间|  深度   |   最大深度 
void dfs(int x,int y,int time,int depth,int max_depth)
{
	if(depth > max_depth) return;//超出深度 
	
	time = (dis(x,y,sal[depth].first,sal[depth].second) <= d) ? 0 : time + 1;
	//如果超出了，计算时间 + 1，没超出或者回来了，更新为0。 
	
	if(time > s) return;//超出时间 
	
	if(lof[depth].first == x && lof[depth].second == y)//找到了 
	{
		printf("%d\n",depth);
		exit(0); 
	}
	for(rint i = 0;i <= 4;i++)//枚举4种转移+一种待在原地 
	{	
		rint tar_x = x + opt[i].xx;
		rint tar_y = y + opt[i].yy;
		
		if(map[tar_x][tar_y]) continue;// 撞墙走不通 
		
		if(tar_x > n || tar_x < 1 || tar_y > m || tar_y < 1) continue;//超出边界 
		
		dfs(tar_x,tar_y,time,depth + 1,max_depth);//搜索下一层 
	}
}

int main()
{
	readint(n),readint(m),readint(s),readint(d);
	for(rint i = 1;i <= n;i++)
	{
		for(rint j = 1;j <= m;j++)
		{
			char ch;//按位读入 
			cin>>ch;
			map[i][j] = ch - '0';
		}
	}
	
	readint(x_1),readint(y_1),readint(x_2),readint(y_2);
	//正序读入坐标
	 
	if(y_1 == y_2 && x_1 == x_2)//如果原来就重合，直接输出0 
	{
		puts("0");
		return 0;
	}
	
	cin>>s1>>s2;//读入操作序列 
	
	string temp;
	while(temp.size() <= 100)//1搞到100 
	temp += s1;
	
	s1 = temp;
	temp = "";
	
	while(temp.size() <= 100)
	temp += s2;
	
	s2 = temp;
	
	pre();
	pre_road_sal(x_1,y_1,0);
	pre_road_lof(x_2,y_2,0);//预处理路径 
	
	/*
	这段是测试用的函数 
	for(int i = 0;i <= 5;i++)
	{
		printf("the %d second:Sal's x = %d,y = %d;lof's x = %d,y = %d\n"
		,i,sal[i].first,sal[i].second,lof[i].first,lof[i].second); 
	}
	*/
	
	//按深度依次搜索
	for(int i = 1;i <= 100;i++) 
	{
		dfs(x_1,y_1,0,0,i);
	}
	return 0;
}
```

23ms，没开 O2，已经接近最优解啦

---


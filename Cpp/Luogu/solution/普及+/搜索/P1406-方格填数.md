# 方格填数

## 题目描述

给一个 $n\times n$ 的方格矩阵，还有 $n\times n$ 个整数，让你将这些整数填入矩阵，使得每行每列每个对角线上整数的和都相等。下面给出几个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/6m0pbzzu.png)

## 说明/提示

### 数据范围及约定

- 对于 $80\%$ 的数据，保证 $1 \le n \le 3$；
- 对于 $100\%$ 的数据，保证 $1 \le n \le 4$。


## 样例 #1

### 输入

```
3
1 2 3 4 5 6 7 8 9
```

### 输出

```
15
2 7 6
9 5 1
4 3 8

```

# 题解

## 作者：wzmzmhk (赞：24)

# P1406 题解
 $upd$ $on$ $2010-10-03:$ 修改了```return ```的书写错误。
- **[题目传送门](https://www.luogu.com.cn/problem/P1406)**
- **[博客食用效果更佳](https://www.luogu.com.cn/blog/wzmzmhk/solution-p1406#)**


------------

**思路：**
1.	首先可以确定，每行、每列、每个对角线的值 $sum=$ 矩阵中所有元素之和除以 $n$。
1. 因为题目要求按字典序输出，所以先把数组从小到大排序（这一点一定要注意！题目中给出的第三个图片是错误的，没有按照字典序）。
1. 从第一个数进行深度优先搜索，最后输出答案，用```exit(0)```直接结束程序（```return ;```的时间较长，需要一步一步地往回回溯）。

**优化：**

可以进行剪枝：在每一行结束、每一列结束或每一对角线结束时可以用一个函数```judge```判断这一行、列或对角线之和是否等于 $sum$。

核心代码：
```cpp
bool judge(int x, int y, int i) {
	if (y == n) {
		int sum1 = a[i];
		for (int j = 1; j < n; j++)
			sum1 += ans[x][j];
		if (sum1 != sum)
			return true;
	}//判断每一行
	if (x == n) {
		int sum1 = a[i];
		for (int j = 1; j < n; j++)
			sum1 += ans[j][y];
		if (sum1 != sum)
			return true;
	}//判断每一列
	if (x == n && y == n) {
		int sum1 = a[i];
		for (int j = 1; j < n; j++)
			sum1 += ans[j][j];
		if (sum1 != sum)
			return true;
	}//判断正对角线
	if (x == n && y == 1) {
		int sum1 = a[i];
		for (int j = 1; j < n; j++)
			sum1 += ans[j][n - j + 1];
		if (sum1 != sum)
			return true;
	}//判断负对角线
	return false;
}
void dfs(int x, int y) {
	if (x == n + 1) {
		print();
		exit(0);
	}//如果搜到了x+1行，说明已经搜索完毕，直接输出。
	for (int i = 1; i <= n * n; i++) {
		if (t[i] == 0) {
			if (judge(x, y, i))//用judge函数进行优化剪枝
				continue;
			t[i] = 1;//打标记
			ans[x][y] = a[i];//将a[i]加入答案中
			y != n ? dfs(x, y + 1) : dfs(x + 1, 1);
			//三目运算符，相当于：
			/*
			    if(y != n)
				    dfs(x, y + 1);
				else
				    dfs(x + 1, 1);
			*/
			t[i] = 0;
		}
	}
}
int main() {
	cin >> n;
	for (int i = 1; i <= n * n; i++) {
		cin >> a[i];
		sum += a[i];
	}
	sum = sum / n;
	sort(a + 1, a + 1 + n * n);//为保证输出为字典序，进行排序
	dfs(1, 1);
	return 0;
}
```


---

## 作者：Mingoal (赞：13)

这题朴素算法是每个格子填什么数一个个枚举，再标记一下，这样只能过80%的数据

但是这里可以有三个优化。

优化1：可以直接求出每行（每列）所有整数的和，和：sum=矩阵中所有数的和除以n

至于为什么会这样，自己想想看吧，很容易证

这样已经能过了

优化2：每一行或每一列一填完就判断是否符合要求，剪枝，这样能快个5倍左右

优化3：exit(0)可以直接结束子程序，不需要标记已经有答案然后再return 很多次

经过这三个优化，我的程序是24ms，有好多人比我快，但是我想说一句：

@plane 这位大佬n=4直接打表，0ms，太牛逼了

贴个代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,a[6][6],b[30],vis[30],sum;//vis数组用于标记
void dfs(int x,int y,int z){
    if (y>n){
        if (z!=sum) return;
        x++,y=1,z=0;
    }
    if (x>n){
        for (int i=1;i<=n;i++){
            for (int j=1;j<n;j++) printf("%d ",a[i][j]);
            printf("%d\n",a[i][n]);
        }
        exit(0);//优化3
    }
    for (int i=1;i<=n*n;i++)
        if (!vis[i]){//优化2
            if (y==n && z+b[i]!=sum) continue;
            if (x==n){
                int s=0;
                for (int j=1;j<n;j++) s+=a[j][y];
                if (s+b[i]!=sum) continue;
            }
            if (x==n && y==1){
                int s=0;
                for (int j=1;j<n;j++) s+=a[j][n-j+1];
                if (s+b[i]!=sum) continue;
            }
            if (x==n && y==n){
                int s=0;
                for (int j=1;j<n;j++) s+=a[j][j];
                if (s+b[i]!=sum) continue;
            }
            a[x][y]=b[i];
            vis[i]=1;
            dfs(x,y+1,z+b[i]);
            vis[i]=0;
        }
}
int main(){
    cin>>n;
    for (i=1;i<=n*n;i++) scanf("%d",&b[i]),sum+=b[i];//优化1
    sum/=n;
    cout<<sum<<endl;
    sort(b+1,b+n*n+1);//把b数组从小到大排序后第一次查找到的结果即为字典序最小的
    dfs(1,1,0);
}
```

---

## 作者：李林恺 (赞：12)

###### 思路：DFS

剪枝：填到每一行、每一列最后一个数字时判断是否合法，速度能快很多 

输出时要输出字典序最小的，所以一开始要把输入数据排序。（我就因为这个WA两次)

49行代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[101],z=0,f[101],ans[11][11];
void s(int x,int y){
	if(x==n&&y==n+1){//找到目标解，输出 
		cout<<z<<endl;
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(j==n) cout<<ans[i][j]<<endl; else cout<<ans[i][j]<<" ";
		exit(0);//直接结束程序 
	}
	if(y>n){//下一行 
		s(x+1,1);
		return;
	}
	for(int i=1;i<=n*n;i++)if(f[i]==0){//未使用 
		if(y==n){//行判断 
			int u=a[i];
			for(int j=1;j<n;j++) u+=ans[x][j];
			if(u!=z) continue;
		}
		if(x==n){//列判断 
			int u=a[i];
			for(int j=1;j<n;j++) u+=ans[j][y];
			if(u!=z) continue;
		}
		if(x==n&&y==1){//斜线（右上角到左下角） 
			int u=a[i];
			for(int j=1;j<n;j++) u+=ans[j][n-j+1];
			if(u!=z) continue;
		}
		if(x==n&&y==n){//斜线（左上角到右下角）
			int u=a[i];
			for(int j=1;j<n;j++) u+=ans[j][j];
			if(u!=z) continue;
		}
		f[i]=1;
		ans[x][y]=a[i];
		//标记 
		s(x,y+1);
		f[i]=0;
		//清除标记 
	}
}
int main(){
    cin>>n;
    for(int i=1;i<=n*n;i++) cin>>a[i],z+=a[i];
    z/=n;//算出每行每列每个对角线上的整数 
    sort(a+1,a+n*n+1);//sort快排 
    s(1,1);
    return 0;
}
```


---

## 作者：llzzxx712 (赞：9)

# P1406题解
[传送门](https://www.luogu.com.cn/problem/P1406)

## 题目分析
   先看数据范围，$N<=4$ 
   
   显然是使用搜索。很容易想到一个搜索思路：将数据排序，保证最先得到的解是字典序最小的。枚举每个点，在填完第一行之后确定每行每列每个对角线的和值，然后继续枚举，直到找到一个可行解。
    
   但是打完就会发现 T 到飞起，这个时候我们就需要进行优化、剪枝。
    
   优化1：我们观察到，每一行的和都相同，我们设这个值为 sum ，那么一共有 n 行，把每一行加起来就是 n * sum ，这也就是给出的 N*N 个数据的和。所以我们就可以在读入后直接求出每行每列每个对角线的和值。再进行搜索。
    
   优化2：我们还可以进一步优化，由于我们已经将数据从小到大排序，并求出了和值。那么我们当填了一个数后发现本行的值超过了和值，那么就可以直接返回而不是尝试下一个数（因为下一个数会更大）。加入这个优化之后速度将近快了一倍。
   
   优化3：可以在 (x,n) 、 （n，y）、（n,1）处检查每行每列每个对角线的和值是否符合而不是在最后一个点。
    
   优化4：本题中是对矩阵进行操作，但是我们可以通过一维数组来模拟二维数组。
 
```cpp
#define sft(x,y) ((x-1)*n+y)
```
   通过这个我们就可以将二维坐标转化为一维坐标
    
   优化5：在找到一个解之后可以直接用exit(0) 跳出函数，我之前用标记然后一直return就莫名其妙地WA了第一个点。
    
**其实优化4和优化5对程序的时间影响不大，但是可以让代码写起来更流畅。很多时候这比稍微快一点的速度更重要** 

## 易错点
- **排序的数据是 $N*N$ 个而不是$N$个

## AC代码

内带详细注释

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define sft(x,y) ((x-1)*n+y) //优化4
using namespace std;
void read(int &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0'; ch=getchar();}
	x*=f;
}
int n,ans,z;
int a[36],b[36],v[36];
void prt(){//输出 
	printf("%d\n",z);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%d ",b[sft(i,j)]);
		}
		printf("\n");
	}
}
void dfs(int x,int y){
	if(y==n+1){//一行搜索好了，搜索下一行 
		dfs(x+1,1);
		return;
	}
	if(x==n+1){
		prt();exit(0);//优化2
	}
	for(int i=1;i<=n*n;i++){
		if(v[i]) continue;
		b[sft(x,y)]=a[i];
		if(y==n){//优化3 们 
			int check=0;
			for(int i=1;i<=n;i++) check+=b[sft(x,i)];
			if(check>z) return;//优化2 
			if(check!=z) continue;
		}
		if(x==n){
			int check=0;
			for(int i=1;i<=n;i++) check+=b[sft(i,y)];
			if(check>z) return;
			if(check!=z) continue;
		}
		if(x==n&&y==1){
			int check=0;
			for(int tot=n+1,j=1;j<=n;j++) check+=b[sft(j,tot-j)];
			if(check>z) return;
			if(check!=z) continue;
		}
		if(x==n&&y==n){
			int check=0;
			for(int j=1;j<=n;j++) check+=b[sft(j,j)];
			if(check>z) return;
			if(check!=z) continue;
		}
		v[i]=1;
		dfs(x,y+1);
		v[i]=0;
	}
}
int main(){
	read(n);
	for(int i=1;i<=n*n;i++){
		read(a[i]);
		z+=a[i];
	}
	z/=n;//优化1，z代表 每行每列每个对角线的和值
	sort(a+1,a+1+n*n);//易错点 
	dfs(1,1);
	return 0;	
}

```

**写题解不易，给个赞呗**

---

## 作者：quest_2 (赞：4)

推一手蒟蒻[$\texttt\color{green}\colorbox{white}{博客～}$](https://www.luogu.com.cn/blog/quest233/#)


------------

一道搞人心态的题。

究其原因是题目图片给出的样例 **是 错 的** 。

这个图里的答案并没有严格按照字典序排序，导致我调的时候几近绝望。

当然，题是好题，以上。


------------


### 看到题目，是一道构造最优解的题，考虑暴搜。

和暴搜板子题《八皇后》类似的，我们在填数的过程中，会受到来自行、列、对角线的限制。

这两题真的怎么看怎么像。我们开始尝试用解橙题的思路来解这道绿题。

------------

《八皇后》中是 $8\times 8$ 的方格中填入 $8$ 个皇后使不互相攻击。显然的，每一行、每一列、每条对角线都只能有 $1$ 个皇后。

具象到棋盘上，我们令**放了皇后的位置**为 $1$ ，**未放的位置**为 $0$ 。

倘若用数组表示一行（或一列/对角线）中格子上**数的总和**。那就是：$hang_{i}=lie_{i} =xie_{i}=1$ 。

而这一题，一行（列/对角线）中数的总和实际指的就是图中的 $S$ 。而这个 $S$ ，我们可以 $\Theta(1)$ 求出。

我们也可以说，《八皇后》问题是这道题**在 $S=1$ 时的特殊情况**。

甚至可以说，《八皇后》问题的限制条件还要比此题刁钻。因为这里只需保证斜对角的两条大对角线和为 $S$ 即可。

故方法可以贯通。

------------

如何 $\Theta(1)$ 求出 $S$ ？

以一幅 $3\times 3$ 的图为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/4tjtrtcv.png)

图中全体数加在一起再除上 $3$ ，便是我们的 $S$ 。

扩展到一般，我们有： $S=\dfrac{sum}{N}$ （$N$ 指方格的规格为 $N\times N$）。


------------

此刻，我们已经有了 $hang_{i}=lie_{i} =xie_{i}=S$ ，我们选择与 《八皇后》问题一样的 $dfs$ 来解决。

但在这之前，需要考虑一个问题。

### 如何使我们构造出的答案一定满足字典序最小？

这里的字典序，指的不是将数字以字符的形式相比较，而是运用字典序的思想：**从第一位到最后一位，依次比较大小，有差异则返回，无差异则比较下一位。**

我们唯一要做的，只用把输入的数据 $\operatorname{sort}$ 即可。

$dfs$ 会在第一个可行的点进入下一层递归，直到搜到结果。此时，这个“**第一个可行的点**”，在 $\operatorname{sort}$ 后就可以保证使其在当前最小。

而按照字典序的原理，当在第一回合就分出胜负后，比较就已经出结果了，肯定是第一位数小的字典序靠前。


------------

$dfs$ 的过程我们可以借鉴（~~贺~~）以前写《八皇后》的代码。

### 这里给出笔者本题诡异搜索，并稍加分析：

```
void dfs(int x, int y, int sum)
//关于dfs传进的参数
//分别代表的是当前的(x,y)坐标，以及本行的总和已经达到了多少
//传进坐标的位置本就是“棋盘上dfs”的基操
//传进本行总和，可以说是一个小优化，下面会用于剪枝

{
	if (y > N)//若该行已到尽头
	{
		if (sum != S)//通过判断它是否“满足行和为S”剪枝
		{
			return;
		}
        
		x++;
		y = 1;
		sum = 0;//到下一行第一个，清空行和
        
	}
	if (x > N)//若N*N搜尽
	{
		for (int i = 1; i <= N; i++)
		{
			for (int j = 1; j <= N; j++)
			{
				cout << dist[i][j] << ' ';
			}
			cout << endl;
		}
        //能走到这一步说明这已经是一种满足条件的方法了，直接输出
		
        exit(0);//直接结束这整个子程序（dfs）
	}
    
    /*以下的hang[i]、lie[i]、xie1、xie2*/
    /*分别指第i行(第i列、左斜对角线、右斜对角线)剩余多少值会达到S*/
	for (int i = 1; i <= N * N; i++)
	{
		if (vis[i])//该数用过则不可再用
		{
			continue;
		}
		if (y == N && num[i] != hang[x])
        //该行的剩余S不够再放一个num[i]
		{
			continue;
		}
		if (x == N && num[i] != lie[y])
        //同上理解
		{
			continue;
		}
		if (x == N && y == 1 && num[i] != xie[2])
		{
			continue;
		}
		if (x == N && y == N && num[i] != xie[1])
		{
			continue;
		}
        
		dist[x][y] = num[i];
        //如果以上条件都能满足，则可填
        
       /*更改相关的值*/
		hang[x] -= num[i];
		lie[y] -= num[i];
		if (x == y)
			xie[1] -= num[i];
		if (x + y == N + 1)
			xie[2] -= num[i];
		vis[i] = 1;
        
		dfs(x, y + 1, sum + num[i]);//搜下一位
        
        /*回溯*/
		vis[i] = 0;
		hang[x] += num[i];
		lie[y] += num[i];
		if (x == y)
			xie[1] += num[i];
		if (x + y == N + 1)
			xie[2] += num[i];
            
	}
}
```

结合注释应该很好理解（~~心虚~~）



------------
重点的部分就这么些，代码在这里稍微摆一摆。

```
#include <bits/stdc++.h>
using namespace std;
int N;
int num[27];
int vis[27];
int dist[7][7];
int S;
int hang[7], lie[7], xie[7];
bool cmp(int x, int y)
{
	return to_string(x) < to_string(y);
}
int judge()
{
	if (xie[1] || xie[2])
	{
		return 0;
	}
	for (int i = 1; i <= N; i++)
	{
		if (hang[i] || lie[i])
		{
			return 0;
		}
	}
	return 1;
}
int found;
void dfs(int x, int y, int sum)
{
	// cout << "dfsing " << x << ' ' << y << endl;
	if (y > N)
	{
		if (sum != S)
		{
			return;
		}
		x++;
		y = 1;
		sum = 0;
	}
	if (x > N)
	{
		for (int i = 1; i <= N; i++)
		{
			for (int j = 1; j <= N; j++)
			{
				cout << dist[i][j] << ' ';
			}
			cout << endl;
		}
		exit(0);
	}
	for (int i = 1; i <= N * N; i++)
	{
		if (vis[i])
		{
			continue;
		}
		if (y == N && num[i] != hang[x])
		{
			continue;
		}
		if (x == N && num[i] != lie[y])
		{
			continue;
		}
		if (x == N && y == 1 && num[i] != xie[2])
		{
			continue;
		}
		if (x == N && y == N && num[i] != xie[1])
		{
			continue;
		}
		dist[x][y] = num[i];
		hang[x] -= num[i];
		lie[y] -= num[i];
		if (x == y)
			xie[1] -= num[i];
		if (x + y == N + 1)
			xie[2] -= num[i];
		vis[i] = 1;
		dfs(x, y + 1, sum + num[i]);
		vis[i] = 0;
		hang[x] += num[i];
		lie[y] += num[i];
		if (x == y)
			xie[1] += num[i];
		if (x + y == N + 1)
			xie[2] += num[i];
	}
}
int main()
{
	cin >> N;
	for (int i = 1; i <= N * N; i++)
	{
		cin >> num[i];
		S += num[i];
	}
	sort(num + 1, num + 1 + N * N);
	S /= N;
	for (int i = 1; i <= N; i++)
	{
		hang[i] = lie[i] = S;
	}
	cout << S << endl;
	xie[1] = xie[2] = S;
	dfs(1, 1, 0);
}
```



---

## 作者：Hiraeth (赞：4)

注释打的很详细了

搜索框架的构建非常重要！

刚开始做的时候是直接填入数据进行$dfs$ 然后一直$TLE$ 

后来想了想 

程序在进入递归的时候 是有一定的常数的 

那么既然终归是要进行判断的 那么我们能不能在进入递归之前就判断清楚了呢？

可能在填入之前跑得比较快？ 未雨绸缪总好过亡羊补牢 也许吧… 

还有一些内容在注释里面

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum,n,a[25],v[25],f[10][10];
void dfs(int x,int y,int z){//f[x][y]表示当前待填充数目 
	if (y==n+1) {x+=1;y=1;z=0;}//末位换行 
	if (x==n+1) {
		for (int i=1;i<=n;i++){
			for (int j=1;j<=n;j++) printf("%d ",f[i][j]);
			printf("\n");
		}//输出结果
		exit(0);//退出程序 
	} 
	for (int i=1;i<=n*n;i++)
		if (!v[i]){//可能在填入之前跑得比较快？ 未雨绸缪总好过亡羊补牢 也许吧… 
			if (y==n&&z+a[i]!=sum) continue;//如果在当前行的末位 判断是否满足填入条件
			if (x==n){//如果当前恰好在最后一行 判断当前待填入列 
				int tmp=0;
				for (int j=1;j<=n-1;j++) tmp+=f[j][y];
				if (tmp+a[i]!=sum) continue;
			} 
			if (x==n&&y==1){
				int tmp=0;
				for (int j=1;j<=n-1;j++) tmp+=f[j][n-j+1];
				if (tmp+a[i]!=sum) continue;
			}//判断对角线 
			if (x==n&&y==n){
				int tmp=0;
				for (int j=1;j<=n-1;j++) tmp+=f[j][j];
				if (tmp+a[i]!=sum) continue;
			}//判断对角线
			f[x][y]=a[i];
			v[i]=1;
			dfs(x,y+1,z+a[i]);
			f[x][y]=0;
			v[i]=0; 
		} 
} 
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n*n;i++) {
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	sum/=n;
	printf("%d\n",sum);
	sort(a+1,a+n*n+1);//要求输出矩阵的字典序最小 排序 
	dfs(1,1,0);
	return 0;
} 
```


---

## 作者：zhangyuhan (赞：4)

DFS+剪枝

当n<=3时，不剪枝是不会TLE的，但是n=4时，程序会卡很长时间、

（~~我也这样被坑了~~）

于是，就要想办法剪枝：

我的思路是一行一行填，一行填完后，如果该行之和不为所有数字总和的$1 \over n$

n为行数。
如果不成立，则 return

附135行AC代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int num[20];
int excel[5][5];
int cnt;
bool used[20];//判断数是否填过 
int num_sum=0;
int sum_hang()//统计行之和 
{
	int all_sum;
	for(int i=1;i<=n;i++)
	{
		int sum=0;
		for(int j=1;j<=n;j++)
		{
			sum+=excel[i][j];
		}
		if(i==1)
			all_sum=sum;
		else
		{
			if(all_sum!=sum)
				return 1000000000;
		}
	}
	return all_sum;
}
int sum_lie()//统计列之和 
{
	int all_sum;
	for(int i=1;i<=n;i++)
	{
		int sum=0;
		for(int j=1;j<=n;j++)
			sum+=excel[j][i];
		if(i==1)
			all_sum=sum;
		else
		{
			if(sum!=all_sum)
				return 100000000;
		}
	}
	return all_sum;
}
int sum_djs_1()//统计主对角线之和 
{
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		sum+=excel[i][i];
	}
	return sum;
}
int sum_djs_2()//统计副对角线之和 
{
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		sum+=excel[i][n+1-i];
	}
	return sum;
}
int cut_tree(int x)//上文所述的剪枝 
{
	int all_sum=0;
	for(int i=1;i<=n;i++)
		all_sum+=excel[x][i];
	return all_sum;
}
bool can_put()//判断该矩阵是否成立 
{
	if(sum_hang()==sum_lie()&&sum_hang()==sum_djs_1()&&sum_hang()==sum_djs_2()
	&&sum_lie()==sum_djs_1()&&sum_lie()==sum_djs_2()&&sum_djs_1()==sum_djs_2())
		return true;
	return false;
}
void dfs(int x,int y)
{
	if(x>=2&&y==1)//当第二行开始，对上一行进行判断，来剪枝 
	{
		if(cut_tree(x-1)!=num_sum/n)
			return ;
	}
	if(x>n)
	{
		if(can_put()&&!cnt)//打印答案 
		{
			cout<<sum_hang()<<endl;
			for(int i=1;i<=n;i++)
			{
				for(int j=1;j<=n;j++)
					cout<<excel[i][j]<<" ";
				cout<<endl;
			}
			cnt++;
			return ;
		}
	}
	else if(!cnt)//因为只输出最小解，所以其余的不再计算 
	{
		for(int i=1;i<=n*n;i++)
		{
			if(!used[i])//没有使用该数才能填入 
			{
				excel[x][y]=num[i];
				used[i]=true;
				if(y==n)
				{
					dfs(x+1,1);
					used[i]=false;
				}
				else
				{
					dfs(x,y+1);
					used[i]=false;
				}
			}
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n*n;i++)
	{
		cin>>num[i];
		num_sum+=num[i];
	}
	sort(num+1,num+1+n*n);//字典序最小，就要从小到大排序 
	dfs(1,1);
	return 0;
}
```

---

## 作者：BFSBFSBFSBFS (赞：4)

此题..

$n <= 4$当然是搜索了..

题意要求.给出$n^2$个数.要求填入$n^2$的方格中,每个数只出现1次.且满足,每行每列与2条对角线的和相同.输出相同的和与字典序最小的解.

字典序的话.排个序.第1次找到就行了..

和可以推出来..  $ns = \sum_{i = 1}^{n}{a_i}$

然后可以发现.每行每列只要填$n-1$个数.

剩下的都可以推出来了.

于是n少了1..

```cpp
n--;
```
另外1篇题解的剪枝是在填完1行或者1列去判断符不符合条件.

我就直接判断最后那个数是否存在了...

这样跑出来.0ms.效率高...

因为填完后回溯的个数不定..代码长度....

Diu代码看吧...

```cpp
program P1406;
 var
  aatt:array[0..5,0..5] of longint;           //已经填好的数.
  a,b:array[0..17] of longint;
  i,j,n,t,lpass,ssum:longint;
 function hahacon(x,y,ix,iy:longint):longint; //这个根据不同的.
  var                                           //方向来判断.
   j,sum:longint;                               //行列是否满足.
  begin
   sum:=0;
   for j:=1 to n-1 do
    inc(sum,aatt[x+ix*(j-1),y+iy*(j-1)]);     //通过填好的.
   sum:=ssum-sum;                               //算出最后1个.
   for j:=1 to n*n do
    if (b[j]=0) and (sum=a[j]) then exit(j);  //如果存在.
   exit(-1);                                    //也没用过的话.
  end;                                          //返回"可以".
 procedure hahaDFS(x,y:longint);              //主要搜索过程.
  type                                          //x,y是当前位置.
   w=array[0..17] of longint;
  var
   wgl:w;
   i,j,wgls,upass,ucon,sum:longint;
  procedure hahaincgg(x,y:longint); //函数内套函数.
   begin
    if upass=-1 then                //如果这个数不行.
     begin
      ucon:=1;                      //标记跳过..
      exit;
     end;
    inc(wgls);                      //产生新位置.
    wgl[wgls]:=upass;                 //因为不知道1次性填了几个数.
    aatt[x,y]:=a[upass];              //要弄数组存下...
    b[upass]:=1;                      //方便回溯...
   end;
  begin
   if lpass=1 then exit;             //结果已产生.不必继续.
   if x=n then                       //填完了..
    begin
     sum:=0;
     for i:=0 to n-1 do             //左下-右上对角线.
      inc(sum,aatt[i+1,n-i]);         //因为上面hahacon没法判断.
     if sum<>ssum then exit;          //放在这里..
     for i:=1 to n do               //输出.
      begin
       for j:=1 to n-1 do
        write(aatt[i,j],' ');
       writeln(aatt[i,n]);
      end;
     lpass:=1;                      //结果产生标记.
    end;
   for i:=1 to n*n do               //枚举没填过的数.
    if b[i]=0 then
     begin
      ucon:=0;
      wgls:=0;
      upass:=i;
      hahaincgg(x,y);               //当前位置填上.
      if x=n-1 then                 //判断1列.
       begin
        upass:=hahacon(1,y,1,0);
        hahaincgg(x+1,y);
       end;
      if y=n-1 then                 //判断1行.
       begin
        upass:=hahacon(x,1,0,1);
        hahaincgg(x,y+1);
       end;
      if (x=n-1) and (y=n-1) then   //判断左上-右下对角线.
       begin
        upass:=hahacon(1,1,1,1);
        hahaincgg(x+1,y+1);
       end;
      if ucon=0 then
       if y=n-1 then hahaDFS(x+1,1) //搜索..
                else hahaDFS(x,y+1);
      for j:=1 to wgls do           //回溯..
       b[wgl[j]]:=0;                  //标记为没有用过.
      wgls:=0;
     end;
  end; 
 begin
  readln(N);
  for i:=1 to n*n do
   begin
    read(A[i]);
    inc(ssum,a[i]);
   end;
  for i:=1 to n*n-1 do              //排序..
   for j:=i+1 to n*n do
    if a[i]>a[j] then
     begin
      t:=a[i];
      a[i]:=a[j];
      a[j]:=t;
     end;
  readln;
  ssum:=ssum div n;                //和...
  writeln(ssum);
  filldword(b,length(b),0);
  lpass:=0;
  aatt[1,1]:=a[1];
  hahaDFS(1,1);
 end.
```
(ಡωಡ).


---

## 作者：vеctorwyx (赞：2)

### DFS+~~简单~~剪枝

搜索整个矩阵（其实是搜索每一行，搜完每一行后换行（~~废话!~~）），
搜完整个矩阵后记录算出每一行、每一列、每条对角线的和，进行比较，如果符合条件就输出并结束程序（exit(0),c++头文件```<cstdlib>```（~~万能头它不香吗~~））。

剪枝：~~由题意得~~，每行之和必须等于所有数字之和除以n（矩阵边长），即
```
每行之和=（a[1]+a[2]+...+a[n*n])/n     <==这是条件不是赋值！
```

否则```continue```，继续枚举这一行每一个点的值，直到每一行都符合条件（当然也可以同时判断行、列、对角线是否符合条件）。

TIP:
多种答案时输出字典序最小的，所以要sort一遍数字。

~~不到100行~~的代码：
```
#include<cstring>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
using namespace std;
int n,a[20],heng[20],ji,maxx,qwq[20][20],zhong[20],xie1,xie2;//不要在意变量名是什么了，不重要QWQ
bool b[20],flag;
void dfs(int x,int y)
{
	for(int i=1;i<=n*n;i++)
	{
		if(!b[i])
		{
			qwq[x][y]=a[i];
			b[i]=1;
			if(y+1<=n)//换行处理
			{
				dfs(x,y+1);
			}
			else
			{
				ji=0;
				for(int j=1;j<=n;j++)//最好写也易懂但是复杂度相对高的剪枝
				{
					ji+=qwq[x][j];
				}
				if(ji!=maxx)
				{
					b[i]=0;//要把刚刚标记的点取消的（因为没有搜下去嘛）
					continue;//这里不是return
				}
				dfs(x+1,1);
			}
			b[i]=0;
		}
	}
	if(x==n&&y==n)
	{
		memset(heng,0,sizeof(heng));
		memset(zhong,0,sizeof(zhong));
		xie1=xie2=0;//必备归零
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				heng[i]+=qwq[i][j];//每行之和（其实没必要因为以前都判断过一遍了
				zhong[j]+=qwq[i][j];//每列之和
				if(i==j)//对角线1
				xie1+=qwq[i][j];
				if(i+j-1==n)//对角线2
				xie2+=qwq[i][j];
			}
		}
		if(xie1==xie2)
		{
			for(int i=1;i<=n;i++)
			{
				if(heng[i]!=xie1||zhong[i]!=xie1)
				{
					flag=1;//如果出现不符合条件的情况
					break;
				}
			}
			if(flag)//继续搜
			{
				flag=0;
				return;
			}
			else//不然输出答案
			{
				cout<<xie1<<endl;
				for(int i=1;i<=n;i++)
				{
					for(int j=1;j<=n;j++)
					{
						cout<<qwq[i][j]<<" ";
					}
					cout<<endl;
				}
				exit(0);//直接接受
			}
		}
		return ;
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n*n;i++)
	{
		cin>>a[i];
		maxx+=a[i];
	}
	maxx/=n;//每一行应该为什么值
	sort(a+1,a+n*n+1);//不要忘记排序哦！
	dfs(1,1);
   	//这里根本不用return 0 ，因为不会运行到这里，会直接从dfs函数中结束程序
} 
```


---

## 作者：firepp (赞：2)

#### n乘n矩形只用搜索(n-1)乘(n-1)矩形即可
#### 其余位置均可以通过已搜索位置确定
#### 每一行的最后一列可以通过该行前(n-1)列之和确定
#### 最后一行的第一列和最后一列需要满足对角线之和
#### 其余列只用该列前(n-1)行之和确定
#### 满足字典序 排序一下就行
```c
#include<stdio.h>
#include<stdlib.h>
int n;
int a[20];
int used[20];
int ans[5][5];
int s;
int leap;
int comp(const void*a,const void*b)
{
	return *(int*)a-*(int*)b;
}
void search(int x,int y,int sum)      sum表示该行前(y-1)列之和
{
	int i,j,k;
	if(leap==1)
		return ;
	if(x==n&&y==n+1)
	{
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
				printf("%d ",ans[i][j]);
			printf("\n");
		}
		leap=1;
	}
	else if(x==n)
	{
		int f=0;
		for(i=1;i<n;i++)
			f+=ans[i][y];
		for(i=1;i<=n*n;i++)
		{
			if(!used[i])
			{
				if(f+a[i]==s)
				{
					if(y==1)
					{
						int m=0;
						for(j=1,k=n;j<n;j++,k--)
							m+=ans[j][k];
						if((m+a[i])!=s)
							continue;
					}
					if(y==n)
					{
						int m=0;
						for(j=1,k=1;j<n;j++,k++)
							m+=ans[j][k];
						if((m+a[i])!=s)
							continue;
					}
					ans[x][y]=a[i];
					used[i]=1;
					search(x,y+1,sum);
					used[i]=0;
				}
			}
		}
	}
	else if(y==n)
	{
		for(i=1;i<=n*n;i++)
		{
			if(!used[i])
			{
				if(sum+a[i]==s)
				{
					ans[x][y]=a[i];
					used[i]=1;
					search(x+1,1,0);
					used[i]=0;
				}
			}
		}
	}
	else
	{
		for(i=1;i<=n*n;i++)
		{
			if(!used[i])
			{
				ans[x][y]=a[i];
				used[i]=1;
				search(x,y+1,sum+a[i]);
				used[i]=0;
			}
		}
	}
}
int main(void)
{
	int i;
	scanf("%d",&n);
	for(i=1;i<=n*n;i++)
	{
		scanf("%d",&a[i]);	
		s+=a[i];
	}
	qsort(a+1,n*n,sizeof(int),comp);
	s/=n;
	printf("%d\n",s);
	search(1,1,0);
}
```


---

## 作者：newbie666 (赞：2)


翻译题目：就是n*n的矩阵中填数，使得对角线，每行每列的和都一样。

由题意可知要字典序最小，也就是最优解，所以首先得排个序，然后再看是DFS(DFS带3个参数，两个是坐标x,y,第三个是和)。

# Code(80分):
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[17],sum,num[17][17],vis;
bool flag[17];
void DFS(int x,int y,int s) {
	if (y==n+1) {
		if(s!=sum) return;
		x++;
		y=1;
		s=0;
	}
	if (x==n+1 && vis==0) {
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n-1; j++) {
				printf("%d ",num[i][j]);
			}
			printf("%d\n",num[i][n]);
		}
		vis=1;
		return ;
	}
	for(int i=1; i<=n*n; i++) {
		if(flag[i]==0) { 
			if(y==n && s+a[i]!=sum) continue; //非法情况 
			if (x==n) { //如果在最后一行，则判断现在待填入列
				int tmp=0;
				for(int j=1; j<n; j++) tmp+=num[j][y];
				if(tmp+a[i]!=sum) continue; //非法情况 
			}
			if(x==n && y==1) { //判断对角线
				int tmp=0;
				for(int j=1; j<n; j++) tmp+=num[j][n-j+1];
				if(tmp+a[i]!=sum) continue; //非法情况 
			}
			if (x==n && y==n) { //判断对角线
				int tmp=0;
				for(int j=1; j<=n-1; j++) tmp+=num[j][j];
				if(tmp+a[i]!=sum) continue; //非法情况 
			}
			num[x][y]=a[i];
			flag[i]=1;
			DFS(x,y+1,s+a[i]);
			flag[i]=0; //回溯，此时就不要再把num[x][y]=0了，因为下一次反正会覆盖掉 
		}
	}
	return ;
}
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n*n; i++) {
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	sum/=n;
	printf("%d\n",sum);
	sort(a+1,a+1+n*n);
	DFS(1,1,0);
	return 0;
} 
```
样例过了，心想居然AC了绿题，结果一片惨淡，80分，TLE最后一个点(毒瘤数据，坑！)，然后~~开了个02优化~~还是超时了，卡数据啊qwq,一气之下，最后用处了杀手锏——不是快读，而是函数里的return改成exit(0)，快许多有木有!
# Code(100分):
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[17],sum,num[17][17],vis;
bool flag[17];
void DFS(int x,int y,int s) {
	if (y==n+1) {
		if(s!=sum) exit(0);
		x++;
		y=1;
		s=0;
	}
	if (x==n+1 && vis==0) {
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n-1; j++) {
				printf("%d ",num[i][j]);
			}
			printf("%d\n",num[i][n]);
		}
		vis=1;
		exit(0);
	}
	for(int i=1; i<=n*n; i++) {
		if(flag[i]==0) { 
			if(y==n && s+a[i]!=sum) continue;
			if (x==n) { //如果在最后一行，则判断现在待填入列
				int tmp=0;
				for(int j=1; j<n; j++) tmp+=num[j][y];
				if(tmp+a[i]!=sum) continue;
			}
			if(x==n && y==1) { //判断对角线
				int tmp=0;
				for(int j=1; j<n; j++) tmp+=num[j][n-j+1];
				if(tmp+a[i]!=sum) continue;
			} 
			if (x==n && y==n) { //判断对角线
				int tmp=0;
				for(int j=1; j<=n-1; j++) tmp+=num[j][j];
				if(tmp+a[i]!=sum) continue;
			} 
			num[x][y]=a[i];
			flag[i]=1;
			DFS(x,y+1,s+a[i]);
			flag[i]=0;
		}
	}
	return ;
}
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n*n; i++) {
		scanf("%d",&a[i]);
		sum+=a[i]; //统计所有数之和
	}
	sum/=n; //sum就是每行每列每对角线的数字之和
	printf("%d\n",sum);
	sort(a+1,a+1+n*n); 
	DFS(1,1,0);
	return 0;
}
```
### 谢谢大家！！！

---

## 作者：lu_run_ting (赞：1)

这道题就是一道妥妥地暴(jian)力(zhi)搜索,

我们分析一下，这道题其实可以用搜索把一个个数填进去，每条横竖斜的和sum就等于a[1]+a[2]+……+a[n*n]除以n

即sum=(a[1]+a[2]+……+a[n*n])/n

这道题有一个易错点就是要字典序最小者输出，所以在搜索前要对a数组进行排序，我忘记了所以只拿了40分qwq

一开始用纯暴力搜索TLE了最后一个点 QAQ

纯暴力代码 预期得分 80分：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=20;
int n,a[N],ans[N][N],vst[N],sum;
bool isans(){//判断是否为正确的矩阵
	int cnt=0;
	//横向
	for(int i=1;i<=n;i++){
		cnt=0;
		for(int j=1;j<=n;j++) cnt+=ans[i][j];
		if(cnt!=sum) return 0; 
	}
	//竖向
	for(int j=1;j<=n;j++){
		cnt=0;
		for(int i=1;i<=n;i++) cnt+=ans[i][j];
		if(cnt!=sum) return 0;
	}
	//两个斜对角
	cnt=0;
	for(int i=1;i<=n;i++) cnt+=ans[i][i];	
	if(cnt!=sum) return 0;
	
	cnt=0;
	for(int i=1;i<=n;i++) cnt+=ans[i][n-i+1];
	if(cnt!=sum) return 0;
	
	return 1; 
}
void dfs(int x,int y){
	if(y==n+1) y=1,x++;//换行
	if(x==n+1){//结束之后判断
		if(isans()==1){
			for(int i=1;i<=n;i++,cout<<endl)
				for(int j=1;j<=n;j++)
					cout<<ans[i][j]<<" ";
			exit(0);
		}
		else return;
	} 
	for(int i=1;i<=n*n;i++)//选择填哪个数
		if(!vst[i]){
			vst[i]=1; ans[x][y]=a[i];
			dfs(x,y+1);
			vst[i]=0; ans[x][y]=0;
		}
}
int main(){
	cin>>n;
	for(int i=1;i<=n*n;i++) cin>>a[i],sum+=a[i];
	sort(a+1,a+n*n+1);
	sum/=n;
	cout<<sum<<endl;
	dfs(1,1);
	return 0;
} 
```
如果想要AC的话需要一个小小的剪枝：

我们一行一行填，填完一行就检查一下这一行的和是否等于sum，

如果不等于的话就不用搜索了。

剪枝搜索 预期得分 100分：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=20;
int n,a[N],ans[N][N],vst[N],sum;
bool isans(){
	int cnt=0;
	
	for(int i=1;i<=n;i++){
		cnt=0;
		for(int j=1;j<=n;j++) cnt+=ans[i][j];
		if(cnt!=sum) return 0; 
	}
	
	for(int j=1;j<=n;j++){
		cnt=0;
		for(int i=1;i<=n;i++) cnt+=ans[i][j];
		if(cnt!=sum) return 0;
	}
	
	cnt=0;
	for(int i=1;i<=n;i++) cnt+=ans[i][i];	
	if(cnt!=sum) return 0;
	
	cnt=0;
	for(int i=1;i<=n;i++) cnt+=ans[i][n-i+1];
	if(cnt!=sum) return 0;
	
	return 1; 
}
void dfs(int x,int y,int z){//z表示当前行的所有数之和
	if(y==n+1){
		y=1,x++;
		if(z!=sum) return;//剪枝
		z=0;
	} 
	if(x==n+1){
		if(isans()==1){
			for(int i=1;i<=n;i++,cout<<endl)
				for(int j=1;j<=n;j++)
					cout<<ans[i][j]<<" ";
			exit(0);
		}
		else return;
	} 
	for(int i=1;i<=n*n;i++)
		if(!vst[i]){
			vst[i]=1; ans[x][y]=a[i];
			dfs(x,y+1,z+a[i]);
			vst[i]=0; ans[x][y]=0;
		}
}
int main(){
	cin>>n;
	for(int i=1;i<=n*n;i++) cin>>a[i],sum+=a[i];
	sort(a+1,a+n*n+1);
	sum/=n;
	cout<<sum<<endl;
	dfs(1,1,0);
	return 0;
} 
```

---


# 倒水问题

## 题目背景

**输入输出已更改，请不要直接提交原先的代码。**


## 题目描述

假定两个水壶 $A$ 和 $B$，供水量不限。可以使用三种方法装水：

- 给一个水壶装水；
- 把一个水壶倒空；
- 从一个水壶倒进另一个水壶。

当从一个水壶倒进另一个水壶时，如果第一个水壶倒空，或者第二个水壶装满就不能再倒了。例如，一个水壶 $A$ 是 $5$ 加仑和另一个水壶 $B$ 是 $6$ 加仑，水量是 $8$ 加仑，则从水壶 $A$ 倒进水壶 $B$ 时，让水壶 $B$ 充满水而水壶 $A$ 剩 $3$ 加仑水。

问题有 $3$ 个参数：$C_a$，$C_b$ 和 $N$，分别表示水壶 $A$ 和 $B$ 的容量，目标水量 $N$。问题的目标是，给出一系列倒水的步骤，使水壶 $B$ 中的水量恰好是 $N$。

## 说明/提示

开启了 spj。

如果你的方案比答案优，会提示 UKE，此时请联系管理员修改数据。

如果你的方案比答案差，分数会相应减损。

## 样例 #1

### 输入

```
2
3 5 4 
5 7 3 
```

### 输出

```
6 2 5 3 5 2 5 
6 1 6 1 6 4 6 
```

## 样例 #2

### 输入

```
1
26 29 11
```

### 输出

```
22 1 6 1 6 4 6 1 6 4 6 1 6 4 6 1 6 4 6 1 6 4 6 
```

# 题解

## 作者：Kater_kcl (赞：59)

update:修正了代码中的一处错误，感谢指正

~~这道题被我们用来团队考试了，这是我唯一一道ac的题，写个题解纪念一下。~~

首先拿道题，我就想到了广搜，因为最短路径的题一般都是广搜，且这道题的状态在可接受的范围之内，事实证明我也是对的，思路很简单：设置两个状态为a，b表示当前状态a杯和b杯的水量，每次从队列中读到一个状态之后，将这个状态执行题目中所给的六种操作，并将执行了六种操作之后的状态压入队列，记录答案并且继续搜索。

说完了整体思路，接下来就是本题的难点（易错点）了，首先第一条，如何解决掉操作5和操作6 ~~（可能不是很难，但是我在考场上搞了半天没搞对）~~,首先读题干，题干告诉我们从B向A倒水会有两种情况：  
1、直到A满  
2、直到B没水  
那么目标就很明确了，若是从B向A倒水，比较B的水量和A杯空着的体积做比较，若大于，则A=A满，B-=A的剩余体积，否则则是A+=B,B=0。  
反过来倒一样。  
然后就是记录解的问题，我这里使用的是vector存解，每次将状态压进队列的时候顺带将这个状态所经历的步骤也压进去，同时vector的大小便是这个状态的步数，这里看不懂的可以直接去看代码。  
接下来该思考如何剪枝了，首先我们不难发现我们在搜索中会遇到很多重复的状态，但是根据广搜的性质，我们后搜到的状态一定没有之前的搜索更优，所以我们将以搜到的情况进行标记，防止出现重复的无意义搜索。  
然后就是一些细枝末节的剪枝，比如当杯子已经是空的就不要empty了，已经满的就不要fill了，这都很好理解。  
ac代码注释版奉上。
```cpp
#include <iostream>
#include <cstring>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <queue>
using namespace std;
int ca,cb,n;//ca和cb分别表示两个杯子的最大容量,n表示目标值。
bool rem[1005][1005];
struct node
{
    int x,y;//x和y代表着a杯和b杯当前的水量
    vector  <int> ans;
};
void bfs(int x,int y){
    memset(rem,0,sizeof(rem));//不要忘了重置标记数组！！！！
    queue  <node> q;//搜索队列
    node ppp;
    ppp.x=x;
    ppp.y=y;
    q.push(ppp);
    while(1){
        node temp;
        temp=q.front();//从队头取出一个搜索状态
        q.pop();
        ///////////////////////////////////////
        if(temp.y==n){//终止条件
            cout<<temp.ans.size()<<" ";//输出步数
            for(int i=0;i<temp.ans.size();i++){
                cout<<temp.ans[i]<<" ";//输出解
            }
            cout<<endl;
            break;
        }
        ///////////////////////////////////////
        if(temp.x!=ca){//处理方式1
            node kater=temp;
            kater.x=ca;//这里由于我ca太菜不会构造函数，所以牺牲了美观性QAQ，别打我。
            kater.ans.push_back(1);//将新构筑出来的状态的操作后面加上个“1”。后面同理。
            if(!rem[kater.x][kater.y]){//如果之前被搜索过就不把他放到队列里
                q.push(kater);
                rem[kater.x][kater.y]=1;//记忆化，防止重搜
            }
        }
        ///////////////////////////////////////
        if(temp.y!=cb){//处理方式2
            node kater=temp;
            kater.y=cb;
            kater.ans.push_back(2);
            if(!rem[kater.x][kater.y]){
                q.push(kater);
                rem[kater.x][kater.y]=1;
            }
        }
        ///////////////////////////////////////
        if(temp.x!=0){//处理方式3
            node kater=temp;
            kater.x=0;
            kater.ans.push_back(3);
            if(!rem[kater.x][kater.y]){
                q.push(kater);
                rem[kater.x][kater.y]=1;
            }
        }
        ///////////////////////////////////////
        if(temp.y!=0){//处理方式4
            node kater=temp;
            kater.y=0;
            kater.ans.push_back(4);
            if(!rem[kater.x][kater.y]){
                q.push(kater);
                rem[kater.x][kater.y]=1;
            }
        }
        ///////////////////////////////////////
        if(temp.y!=0&&temp.x!=ca){//处理方式5
            node kater=temp;
            if(kater.y>ca-kater.x){
                kater.y-=ca-kater.x;
                kater.x=ca;
            }
            else{
                kater.x+=kater.y;
                kater.y=0;
            }//模拟倒水,注意这里的顺序不能反。
            kater.ans.push_back(5);
            if(!rem[kater.x][kater.y]){
                q.push(kater);
                rem[kater.x][kater.y]=1;
            }
        }
        ///////////////////////////////////////
        if(temp.x!=0&&temp.y!=cb){//处理方式6
            node kater=temp;
            if(kater.x>cb-kater.y){
                kater.x-=cb-kater.y;
                kater.y=cb;
            }
            else{
                kater.y+=kater.x;
                kater.x=0;
            }
            kater.ans.push_back(6);
            if(!rem[kater.x][kater.y]){
                q.push(kater);
                rem[kater.x][kater.y]=1;
            }
        }
    }
}
int main(){
    //    freopen("test.in","r",stdin);
    int T;
    cin>>T;
    while(T--){
        cin>>ca>>cb>>n;
        bfs(0,0);
    }
    return 0;
}

```
求过QAQ，审核员大大最帅了。

---

## 作者：cxy004 (赞：24)

有两种方案


①不断把A壶里的水倒给B壶

②不断把B壶里的水倒给A壶


题目要求输出这两种方案中较短的操作序列


```cpp
#include<iostream>
#include<cstring>
using namespace std;

int a,b,c;

int main()
{
    for(;~scanf("%d%d%d",&a,&b,&c);)
    {
      int l1=0,l2=0;
      string t1,t2;
      for(int fa=0,fb=0;fb!=c;++l1)
        if(!fa) {fa=a;t1+="fill A\n";}
        else if(fb==b) {fb=0;t1+="empty B\n";}
        else {fa-=b-fb;fb=b;if(fa<0) {fb+=fa;fa=0;}t1+="pour A B\n";}
      for(int fa=0,fb=0;fb!=c;++l2)
        if(!fb) {fb=b;t2+="fill B\n";}
        else if(fa==a) {fa=0;t2+="empty A\n";}
        else {fb-=a-fa;fa=a;if(fb<0) {fa+=fb;fb=0;}t2+="pour B A\n";}
      if(l1<=l2) printf("%s",t1.c_str());else printf("%s",t2.c_str());
      puts("success");
    }
    return 0;
}
```

---

## 作者：zhaotiensn (赞：18)

（竟然发这题题解的人那么少，那么我就来水一发题解）

解题思路：

宽搜BFS一看就是要以最少的次数到达题目的要求，想到最少就想到了**宽搜 BFS**，还是比较裸的BFS，相对比较简单。

本人的BFS：通过普通的队列来进行搜索，建立一个vis数组来储存这种情况是否出现过，然后向6个方向拓展（fill A，fill B, empty A, empty B ,pour A B,pour B A），遇到新的点就放入队尾。然后将队首的点出队进行搜索，当搜索到的点符合题目要求就返回答案。

接下来贴代码：


    
    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,a,b,c,l,r;//a,b,c就是题中的变量，l为队首指针，r为队尾指针。
int ai[10000],bi[10000],ans[10000],f[10000][10000];//ai,bi分别为A，B中的水，f数组储存到达当前情况进行的操作，ans为当前情况进行的操作总数。
bool vis[2000][2000];//vis用来是否搜索过。
void bfs(int x,int y) {
	if(y==c) { //当B中的水与需要的C相等时开始输出
		cout<<ans[l]<<" ";
		for(int i=1; i<=ans[l]; i++) { //输出进行的操作
			cout<<f[l][i]<<" ";
		}
		cout<<endl;//成功
		return;
	}
	for(int i=1; i<=6; i++) { //对6个方向进行拓展
		if((i==1)&&(x!=a)&&(!vis[a][y])) { //当搜索过了或者A本来就是满的，fill A为无效的
			++r;//队尾指针+1。
			ai[r]=a;//进行 fill A 操作后入队
			bi[r]=y;
			vis[a][y]=true;//标记
			ans[r]=ans[l]+1;
			for(int j=1; j<=ans[l]; j++)f[r][j]=f[l][j];
			f[r][ans[r]]=i;//将之前的操作赋值给新的状况
		}
		if((i==2)&&(y!=b)&&(!vis[x][b])) { //同上
			++r;
			ai[r]=x;//同上
			bi[r]=b;
			vis[x][b]=true;
			ans[r]=ans[l]+1;
			for(int j=1; j<=ans[l]; j++)f[r][j]=f[l][j];
			f[r][ans[r]]=i;//同上
		}
		if((i==3)&&(x!=0)&&(!vis[0][y])) { //同上，当A本为空或已搜索都是无效操作
			++r;
			ai[r]=0;//同上
			bi[r]=y;
			ans[r]=ans[l]+1;
			vis[x][b]=true;
			for(int j=1; j<=ans[l]; j++)f[r][j]=f[l][j];
			f[r][ans[r]]=i;//同上
		}
		if((i==4)&&(y!=0)&&(!vis[x][0])) { //同上
			++r;
			ai[r]=x;
			bi[r]=0;
			ans[r]=ans[l]+1;
			vis[x][b]=true;
			for(int j=1; j<=ans[l]; j++)f[r][j]=f[l][j];
			f[r][ans[r]]=i;
		}
		if((i==5)&&(x!=a)&&(y!=0)&&(!vis[x+y][0])) {
			++r;//当A为满或B为空，都是无效操作。
			vis[x+y][0]=true;//直接用x+y代替的比用直接用x，y做下标好，可以省代码，而且如A为6，B为4或A为9，b为1可以看做操作后是同一种情况。
			if(x+y<=a) { //如果A装不满的情况
				ai[r]=x+y;
				bi[r]=0;
			} else { //如果A装满了的情况
				ai[r]=a;
				bi[r]=x+y-a;
			}
			ans[r]=ans[l]+1;
			for(int j=1; j<=ans[l]; j++)f[r][j]=f[l][j];
			f[r][ans[r]]=i;
		}
		if((i==6)&&(x!=0)&&(y!=b)&&(!vis[0][x+y])) {
			++r;//同上
			vis[0][x+y]=true;
			if(x+y<=b) {
				ai[r]=0;
				bi[r]=x+y;
			} else { //同上
				ai[r]=x+y-b;
				bi[r]=b;
			}
			ans[r]=ans[l]+1;
			for(int j=1; j<=ans[l]; j++)f[r][j]=f[l][j];
			f[r][ans[r]]=i;
		}
	}
	++l;//队首指针+1，队首出队
	if(l<=r)bfs(ai[l],bi[l]);
	else return;
	return;//对它进行拓展，如果l>r,即没有未搜索过的点则说明这种情况无解
}
int main() {
	cin>>n;
	while(n--) {
		cin>>a>>b>>c;
		l=0;
		r=0;//初始化
		memset(vis,false,2000*2000);//也是初始化
		bfs(0,0);//从两个壶都没有水开始搜索
	}
	return 0;
}
```

---

## 作者：lemir3 (赞：13)



~~趁着题改了赶紧水一发题解（与此同时还在和对面的同学抢时间）~~

看到这道题有2个思路：全排序和BFS（保证最优）

但是谁会作死去写全排序~~骗分~~2333

那么就用一维BFS，每一次都刷新6个做法

每一个做法保存当前状态

这样的话结构体的构造就出来了

```cpp
struct sb//别问我这个是什么意思
{
    int a,b;//两个桶中的水量
    int f;//步骤数
    string s="";//竟然用字符串存具体做法！（其实是懒得开动态数组），但是记得要赋空串
};
```
主函数好理解吧

```cpp
int main()
{
    scanf("%d",&t);
    for(i=1;i<=t;i++)
    {
        scanf("%d %d %d",&a,&b,&u);//打scanf的养成好习惯
        bfs();
    }
return 0;
}
```
开始暴力地打模板
```cpp
void bfs()
{
    queue<sb>q;//建队
    sb x;//把初始的状态入队
    x.a=0;
    x.b=0;
    x.f=0;
    q.push(x);
    while(q.size()!=0)
    {
        sb t=q.front();
        q.pop();
        for(int o=1;o<=6;o++)//六个做法（可能有点繁琐）
        {
            sb k=t;
            k.f++;
            if(o==1)//下面的都好理解，模拟倒水
            {
                k.a=a;
                k.s=k.s+"1";
            }
            if(o==2)
            {
                k.b=b;
                k.s=k.s+"2";
            }
            if(o==3)
            {
                k.a=0;
                k.s=k.s+"3";
            }
            if(o==4)
            {
                k.b=0;
                k.s=k.s+"4";
            }
            if(o==5)
            {
                if(k.b+k.a>a)
                {
                    k.b=k.b-(a-k.a);
                    k.a=a;
                }
                else 
                {
                    k.a=k.b+k.a;
                    k.b=0;
                }
                k.s=k.s+"5";
            }
            if(o==6)
            {
                if(k.b+k.a>b)
                {
                    k.a=k.a-(b-k.b);
                    k.b=b;
                }
                else 
                {
                    k.b=k.a+k.b;
                    k.a=0;
                }
                k.s=k.s+"6";
            }
			if(k.b==u)//完成了倒水就退出该函数
            {
                print(k);
                return;
            }
        }
    }
}
```
还有print函数养成好习惯
```cpp
void print(sb p)
{
    printf("%d ",p.f);
    for(int i=0;i<p.s.size();i++)printf("%c ",p.s[i]);//为了节省内存，在输出的时候再来加空格
    printf("\n");
}
```
但是大家可能会想这道题怎么莫名地简单了起来，那我再来分析一下

比如这个数据：3,5,4

把A倒空的方法其实有很多：

①一次倒空；

②把B倒空，再把A倒给B

③倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A......~~调皮了~~

在我们的BFS中，因为每次都会有6个状态入队，所以说重复的做法有非常多

于是我想到了一种类似桶排，数字控制的下标的标记法

核心代码如下

```cpp
if(f[k.a][k.b]>k.f)
/*
f的两个下标是A桶的水量和B桶的水量，存的是达到这个状态需
要的最小步骤，如果有一个方法比这个优，那么就刷新并入队。
这句要加在BFS函数的内循环的判结束的前面，还要记得赋极大
*/
{
	f[k.a][k.b]=k.f;
	q.push(k);
}
```
涉及到题解的长度问题，全部的代码我就不加了2333。

祝Noip2018 RP++

---

## 作者：Brunhild (赞：12)

~~感觉是比较简单明了的代码。~~

### 修改内容：第49-51行关于数组初始化和break的解释。

求过......

题目传送门：[P1432 倒水问题](https://www.luogu.com.cn/problem/P1432)

### 解题思路

用两个变量表示两个瓶子中的水量，另一个变量表示到达这个状态所需的步骤数，还有一个变量用来储存到达这个状态所需要的操作。

每达到一个状态，就执行6种操作，并压入队列 a ，记下这个状态后继续搜索。直到出现解后停止搜索并输出。

### 代码实现

需要定义的变量，结构体用于储存水量、步骤数和所需操作。

```cpp
struct node{
	int x,y,d;//x,y表示两个水壶中的水量,d表示到达这个状态所需的步骤数
	string c;//用来储存到达这个状态所需要的操作,用string可以直接把到父节点的总操作与到达该子节点的这次操作相加，即到达这个子节点所需要的总操作。
};
queue <node> a;//用于搜索的队列。
bool b[1000][1000];//判断是否到过这个状态。
node p;
int Ca,Cb,n,T;//Ca、Cb分别表示水壶A和B的容量，n为目标水量。
```


定义一个函数，用来执行操作。


```cpp
void command(int x,int y,char c){ //x、y为执行操作后的水量，c表示这个操作。
	if (b[x][y]!=0) return;//到过此状态，直接跳出，因为已经不是最优解。
	else b[x][y]=1;//标记到过此状态。
	node by;
	by.x=x;
	by.y=y;
	by.c=p.c+' '+c;//到父节点的总操作与到达该子节点的这次操作相加，即到达这个子节点所需要的总操作。
	by.d=p.d+1;//步骤数加1。
	a.push(by);//压入队列。
}
```

因为要执行 T 次，所以为了方便，将核心代码也做成了一个函数。

注意要在一开始初始化数组和队列，不然只会在第一次输入后有输出，后面几次只会不变的输出空行，~~就像紫妈的年龄一样auhfiuasdnhfguyr~~ 。

得到答案后要break，不然就会把其它~~奇奇怪怪~~的解也一起输出。

```cpp
void put()
{
	memset (b,0,sizeof(b));//数组初始化。
	a=queue<node>();//队列初始化为空。
	b[0][0]=1;//将起始状态，即A、B水壶都空的状态标记为到达过。
	p.x=0;
	p.y=0;//A、B水壶均为空，所以p.x、p.y都设置为0。
	p.d=0;//未执行过操作，所以步骤数也为0。
	p.c="";//未执行过操作，操作为空。
	cin>>Ca>>Cb>>n;//输入。
	a.push(p);//压入初始状态。
	while (a.empty()!=true){//a不为空就一直循环。
		p=a.front();//队头为此时搜索的状态。
		if (p.y==n){
			cout<<p.d;//如果B壶到达目标水量，输出步骤。
			cout<<p.c;//输出所需的操作。
			cout<<endl;
			break;//跳出循环。
		}
		a.pop();//删除队头。
		//fill A操作，条件为A壶未满，执行操作后A壶装满，B壶水量不变。
		if (p.x!=Ca) command(Ca,p.y,'1');
		//fill B操作，条件为B壶未满，执行操作后B壶装满，A壶水量不变。
		if (p.y!=Cb) command(p.x,Cb,'2');
		//empty A操作，条件为A壶未空，执行操作后A壶倒空，B壶水量不变。
		if (p.x!=0) command(0,p.y,'3');
		//empty B操作，条件为B壶未空，执行操作后B壶倒空，A壶水量不变。
		if (p.y!=0) command(p.x,0,'4');
		//pour AB操作，首先判断是否能倒满B壶，即总水量是否大于B壶最大容量。若大于，执行操作后A壶水量为总水量减B壶最大容量，B壶装满；若小于，执行操作后A壶倒空，B壶中水量即总水量。
		if (p.x+p.y>=Cb) command(p.x+p.y-Cb,Cb,'6');
		else command(0,p.x+p.y,'6');
		//pour BA操作，首先判断是否能倒满A壶，即总水量是否大于A壶最大容量。若大于，执行操作后B壶水量为总水量减B壶最大容量，A壶装满；若小于，执行操作后B壶倒空，A壶中水量即总水量。
		if (p.x+p.y>=Ca) command(Ca,p.x+p.y-Ca,'5');
		else command(p.x+p.y,0,'5');
	}
}
```

主程序  ~~这个应该不用讲了吧...~~

```cpp
int main()
{
	cin>>T;
	for (int i=1;i<=T;i++){ //循环T次。
		put();
	}
}
```

最后附上~~WA~~AC全代码~

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int x,y,d;
	string c;
};
queue <node> a;
bool b[1000][1000];
node p;
int Ca,Cb,n,T;
void command(int x,int y,char c){
	if (b[x][y]!=0) return;
	else b[x][y]=1;
	node by;
	by.x=x;
	by.y=y;
	by.c=p.c+' '+c;
	by.d=p.d+1;
	a.push(by);
}
void put()
{
	memset (b,0,sizeof(b));
	a=queue<node>();
	b[0][0]=1;
	p.x=0;
	p.y=0;
	p.d=0;	 
	p.c="";
	cin>>Ca>>Cb>>n;
	a.push(p);	
	while (a.empty()!=true){
		p=a.front();
		if (p.y==n){
			cout<<p.d;
			cout<<p.c;
			cout<<endl;
			break;
		}
		a.pop();
		//fill A
		if (p.x!=Ca) command(Ca,p.y,'1');
		//fill B
		if (p.y!=Cb) command(p.x,Cb,'2');
		//empty A
		if (p.x!=0) command(0,p.y,'3');
		//empty B
		if (p.y!=0) command(p.x,0,'4');
		//pour AB
		if (p.x+p.y>=Cb) command(p.x+p.y-Cb,Cb,'6');
		else command(0,p.x+p.y,'6');
		//pour BA
		if (p.x+p.y>=Ca) command(Ca,p.x+p.y-Ca,'5');
		else command(p.x+p.y,0,'5');
	}
}
int main()
{
	cin>>T;
	for (int i=1;i<=T;i++){
		put();
	}
}
```



---

## 作者：sxyugao (赞：7)

数据已修改，根据数据修改题解


[更好的阅读体验](https://sxyugao.top/p/a5166969.html)

------------


P党福利（怎么又没有Pascal题解233）

终于TM让我过了，我一开始ZZ到读入在用EOLN。。。于是就愉快的WA了。。

P.S.里的内容是数据未更新前的。。可以选择无视。。

P.S.Pascal里没有\n，我一开始一直用#10，还是WA，最后万不得已用了数组模拟链表的方式，用writeln。。

------分割线------

**题目**

2个瓶子a,b，初始为空，问怎样使b瓶中的水量达到c

**算法**

宽度优先搜索，6种情况扩展，因为没有SPJ，所以我们应该按一定的顺序拓展。。

（至少按题解的方法来（雾））

以下为数据未更新前代码：
```pascal
var
va,vb,vc,ta,tb,l,r:longint;
//va为a瓶的最大容量，vb为b瓶的最大容量，vc为目标，l为队首指针，r为队尾指针
q:array[1..100000]of record a,b,last,k:longint;end;
//a为当前a瓶的水量，b为当前b瓶的水量，last为由哪个状态拓展而来，k为指令的代号
vis:array[0..2000,0..2000]of boolean;//标记状态，v[i,j]表示a瓶为i，b瓶为j的情况是否出现过
procedure print(p:longint);//递归输出答案
  var t:longint;
  begin
    t:=q[p].last;//上一个状态
    if t=0 then exit;//如果没有上一个状态，退出
    print(t);//递归，因为先输出的是前面的指令
    case q[p].k of//分指令类型输出
    1:writeln('fill A');
    2:writeln('fill B');
    3:writeln('empty A');
    4:writeln('empty B');
    5:writeln('pour B A');
    6:writeln('pour A B');
    end;
  end;
begin
while not eof do//要用eof！！！
  begin
    read(va,vb,vc);
    fillchar(vis,sizeof(vis),0);
    q[1].a:=0;q[1].b:=0;q[1].k:=0;vis[0,0]:=true;q[1].last:=0;
    //初始化
    l:=0;r:=1;
    while l<r do
      begin
        inc(l);
        with q[l] do//对于q[l]进行操作，后边可以省下q[l]这个前缀
          begin
            if not vis[va,b] then//把A装满
              begin
                inc(r);//入队
                q[r].a:=va;q[r].b:=b;
                q[r].k:=1;//当前操作序号
                q[r].last:=l;//挂到队首上
                if q[r].b=vc then
                  begin
                    print(r);writeln('success');//最后还有一个success要输出
                    break;//搜到答案直接退出循环
                  end;
                vis[va,b]:=true;//标记剪枝
              end;
            if not vis[a,vb] then//把B装满，其余同上
              begin
                inc(r);
                q[r].a:=a;q[r].b:=vb;
                q[r].last:=l;
                q[r].k:=2;
                if q[r].b=vc then
                  begin
                    print(r);writeln('success');
                    break;
                  end;
                vis[a,vb]:=true;
              end;
            if not vis[0,b] then//把A倒空，同上
              begin
                inc(r);
                q[r].a:=0;q[r].b:=b;
                q[r].k:=3;
                q[r].last:=l;
                if q[r].b=vc then
                  begin
                    print(r);writeln('success');
                    break;
                  end;
                vis[0,b]:=true;
              end;
            if not vis[a,0] then//把B倒空，同上
              begin
                inc(r);
                q[r].a:=a;q[r].b:=0;
                q[r].k:=4;
                q[r].last:=l;
                if q[r].b=vc then
                  begin
                    print(r);writeln('success');
                    break;
                  end;
                vis[a,0]:=true;
              end;
            ta:=a+b;tb:=0;
            if ta>va then
              begin
                tb:=ta-va;
                ta:=va;
              end;//如果超出容量了，那么处理一下
            if not vis[a+b,0] then//把B倒到A，同上
              begin
                inc(r);
                q[r].a:=ta;q[r].b:=tb;
                q[r].k:=5;
                q[r].last:=l;
                if q[r].b=vc then
                  begin
                    print(r);writeln('success');
                    break;
                  end;
                vis[a+b,0]:=true;
              end;
            ta:=0;tb:=a+b;
            if tb>vb then
              begin
                ta:=tb-vb;
                tb:=vb;
              end;//同上
            if not vis[0,a+b] then//把A倒到B，同上
              begin
                inc(r);
                q[r].a:=ta;q[r].b:=tb;
                q[r].k:=6;
                q[r].last:=l;
                if q[r].b=vc then
                  begin
                    print(r);writeln('success');
                    break;
                  end;
                vis[0,a+b]:=true;
              end;
          end;
      end;
  end;
end.

```

修改后的代码（注释基本与上面相同，我就不加了）：
```pascal
var
T,va,vb,vc,ta,tb,l,r:longint;
q:array[1..5000000]of record a,b,last,k,step:longint;end;
vis:array[0..2000,0..2000]of boolean;
procedure print(p:longint);
  var t:longint;
  begin
    t:=q[p].last;
    if t=0 then exit;
    print(t);
    write(q[p].k,' ');
  end;
begin
read(T);
while T>0 do
  begin
    dec(T);
    read(va,vb,vc);
    fillchar(vis,sizeof(vis),0);
    q[1].a:=0;q[1].b:=0;q[1].k:=0;vis[0,0]:=true;q[1].last:=0;q[1].step:=0;
    l:=0;r:=1;
    while l<r do
      begin
        inc(l);
        with q[l] do
          begin
            if not vis[va,b] then
              begin
                inc(r);
                q[r].a:=va;q[r].b:=b;
                q[r].k:=1;
                q[r].last:=l;
                q[r].step:=step+1;
                if q[r].b=vc then
                  begin
                    write(q[r].step,' ');
                    print(r);
                    break;
                  end;
                vis[va,b]:=true;
              end;
            if not vis[a,vb] then
              begin
                inc(r);
                q[r].a:=a;q[r].b:=vb;
                q[r].last:=l;
                q[r].k:=2;
                q[r].step:=step+1;
                if q[r].b=vc then
                  begin
                    write(q[r].step,' ');
                    print(r);
                    break;
                  end;
                vis[a,vb]:=true;
              end;
            if not vis[0,b] then
              begin
                inc(r);
                q[r].a:=0;q[r].b:=b;
                q[r].k:=3;
                q[r].last:=l;
                q[r].step:=step+1;
                if q[r].b=vc then
                  begin
                    write(q[r].step,' ');
                    print(r);
                    break;
                  end;
                vis[0,b]:=true;
              end;
            if not vis[a,0] then
              begin
                inc(r);
                q[r].a:=a;q[r].b:=0;
                q[r].k:=4;
                q[r].last:=l;
                q[r].step:=step+1;
                if q[r].b=vc then
                  begin
                    write(q[r].step,' ');
                    print(r);
                    break;
                  end;
                vis[a,0]:=true;
              end;
            ta:=a+b;tb:=0;
            if ta>va then
              begin
                tb:=ta-va;
                ta:=va;
              end;
            if not vis[a+b,0] then
              begin
                inc(r);
                q[r].a:=ta;q[r].b:=tb;
                q[r].k:=5;
                q[r].last:=l;
                q[r].step:=step+1;
                if q[r].b=vc then
                  begin
                    write(q[r].step,' ');
                    print(r);
                    break;
                  end;
                vis[a+b,0]:=true;
              end;
            ta:=0;tb:=a+b;
            if tb>vb then
              begin
                ta:=tb-vb;
                tb:=vb;
              end;
            if not vis[0,a+b] then
              begin
                inc(r);
                q[r].a:=ta;q[r].b:=tb;
                q[r].k:=6;
                q[r].last:=l;
                q[r].step:=step+1;
                if q[r].b=vc then
                  begin
                    write(q[r].step,' ');
                    print(r);
                    break;
                  end;
                vis[0,a+b]:=true;
              end;
          end;
      end;
      writeln;
  end;
end.

```

---

## 作者：千灯 (赞：5)

~~千灯第一眼看这道题以为是dfs~~，是我刷的题少了。。  
用q[ ][0]存放a杯子里的水，用q[ ][1]存放b杯子里的水，q[ ][2]记录次数  
用v[waterA][waterB]记录情况是否重复。  
然后就是6个if暴打QAQ，就有了主题代码：
```cpp
f=r=1;
		v[0][0]=1;
		q[1][0]=0,q[1][1]=0,q[1][2]=0;
		while(f<=r)
		{
			int Wa=q[f][0],Wb=q[f][1];
			if(Wb==n) 
			{
				cout<<q[f][2]<<" ";
				dfs(f);
				cout<<endl;
				break;
			}
			if(Wa<Ca&&v[Ca][Wb]==false) 
			{	
				v[Ca][Wb]=true;
				++r,q[r][0]=Ca,q[r][1]=Wb,q[r][2]=q[f][2]+1;
				father[r].last=f,father[r].plan=1;
			}
			if(Wb<Cb&&v[Wa][Cb]==false)
			{
				v[Wa][Cb]=true;
				++r,q[r][0]=Wa,q[r][1]=Cb,q[r][2]=q[f][2]+1;
				father[r].last=f,father[r].plan=2;
			}
			if(Wa>0&&v[0][Wb]==false)
			{
				v[0][Wb]=true;
				++r,q[r][0]=0,q[r][1]=Wb,q[r][2]=q[f][2]+1;
				father[r].last=f,father[r].plan=3;
			} 
			if(Wb>0&&v[Wa][0]==false)
			{
				v[Wa][0]=true;
				++r,q[r][0]=Wa,q[r][1]=0,q[r][2]=q[f][2]+1;
				father[r].last=f,father[r].plan=4;
			}
			if(Wa<Ca)
			{
				int water=min(Wb,Ca-Wa);
				if(v[Wa+water][Wb-water]==false)
				{
					v[Wa+water][Wb-water]=true;
					++r,q[r][0]=Wa+water,q[r][1]=Wb-water,q[r][2]=q[f][2]+1;
					father[r].last=f,father[r].plan=5;
				}
			}
			if(Wb<Cb)
			{
				int water=min(Wa,Cb-Wb);
				if(v[Wa-water][Wb+water]==false)
				{
					v[Wa-water][Wb+water]=true;
					++r,q[r][0]=Wa-water,q[r][1]=Wb+water,q[r][2]=q[f][2]+1;
					father[r].last=f,father[r].plan=6;
				}
			}
			++f;
		}
```
用father[ ]数组记录上一次的位置和本次的方案  
然后dfs输出：
```cpp
void dfs(int x)
{
	if(x==1) return;
	dfs(father[x].last);
	cout<<father[x].plan<<" ";
} 
```



------------
AC代码：
```cpp
#include<bits/stdc++.h>
#define maxn 1010
using namespace std;
int q[maxn*maxn][3];
struct 
{
	int last,plan;
}father[maxn*maxn];
bool v[maxn][maxn];
int T,Ca,Cb,n,f,r;
void dfs(int x)
{
	if(x==1) return;
	dfs(father[x].last);
	cout<<father[x].plan<<" ";
} 
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&Ca,&Cb,&n);
		memset(v,0,sizeof(v));
		f=r=1;
		v[0][0]=1;
		q[1][0]=0,q[1][1]=0,q[1][2]=0;
		while(f<=r)
		{
			int Wa=q[f][0],Wb=q[f][1];
			if(Wb==n) 
			{
				cout<<q[f][2]<<" ";
				dfs(f);
				cout<<endl;
				break;
			}
			if(Wa<Ca&&v[Ca][Wb]==false) 
			{	
				v[Ca][Wb]=true;
				++r,q[r][0]=Ca,q[r][1]=Wb,q[r][2]=q[f][2]+1;
				father[r].last=f,father[r].plan=1;
			}
			if(Wb<Cb&&v[Wa][Cb]==false)
			{
				v[Wa][Cb]=true;
				++r,q[r][0]=Wa,q[r][1]=Cb,q[r][2]=q[f][2]+1;
				father[r].last=f,father[r].plan=2;
			}
			if(Wa>0&&v[0][Wb]==false)
			{
				v[0][Wb]=true;
				++r,q[r][0]=0,q[r][1]=Wb,q[r][2]=q[f][2]+1;
				father[r].last=f,father[r].plan=3;
			} 
			if(Wb>0&&v[Wa][0]==false)
			{
				v[Wa][0]=true;
				++r,q[r][0]=Wa,q[r][1]=0,q[r][2]=q[f][2]+1;
				father[r].last=f,father[r].plan=4;
			}
			if(Wa<Ca)
			{
				int water=min(Wb,Ca-Wa);
				if(v[Wa+water][Wb-water]==false)
				{
					v[Wa+water][Wb-water]=true;
					++r,q[r][0]=Wa+water,q[r][1]=Wb-water,q[r][2]=q[f][2]+1;
					father[r].last=f,father[r].plan=5;
				}
			}
			if(Wb<Cb)
			{
				int water=min(Wa,Cb-Wb);
				if(v[Wa-water][Wb+water]==false)
				{
					v[Wa-water][Wb+water]=true;
					++r,q[r][0]=Wa-water,q[r][1]=Wb+water,q[r][2]=q[f][2]+1;
					father[r].last=f,father[r].plan=6;
				}
			}
			++f;
		}
	}
	return 0;
}
```
QAQAQAQAQ

---

## 作者：邹豫旸 (赞：5)

# 第一次发题解，希望能过
## bfs大法，96行代码，空间上比较简洁
### 手打队列，每次都用6种方法搜寻，到达目标值就break，然后print
ac代码：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int n;
struct que{
	int a,b,w,l;//a,b为两容器水量，w是方法，l是上一次操作在队列中的坐标
};
que q[100000]; 
void pr(int x){
	int ans=0;//操作次数
	stack<int> st;//倒着搜，所以要用栈，存储操作方法
	while(1){
	    if(q[x].l==0) break;//到底了
		st.push(q[x].w);
		ans++;
		x=q[x].l;
	}
	cout<<ans;
	while(!st.empty()){
		cout<<" "<<st.top();
		st.pop();
	}
	cout<<endl;
}
void bfs(int a,int b,int c){
	bool t[1001][1001]={};//判重
	int f=1,r=1;
	q[1].a=0; q[1].b=0; q[1].w=0; q[1].w=0; //初始状态
	while(f<=r){
		if(q[f].b==c){//到达目标
			pr(f);
			break;
		}
		if(q[f].a!=a&&t[a][q[f].b]==0){//当a不满且没搜索过时搜索
			r++;//压栈
			q[r].a=a; q[r].b=q[f].b; q[r].w=1; q[r].l=f;
			t[q[r].a][q[r].b]=1;//标记
		}
		if(q[f].b!=b&&t[q[f].a][b]==0){
			r++;
			q[r].a=q[f].a; q[r].b=b; q[r].w=2; q[r].l=f;
			t[q[r].a][q[r].b]=1;
		}
		if(q[f].a!=0&&t[0][q[f].b]==0){
			r++;
			q[r].a=0; q[r].b=q[f].b; q[r].w=3; q[r].l=f;
			t[q[r].a][q[r].b]=1;
			//cout<<q[r].a<<" "<<q[r].b<<" "<<q[r].w<<endl;调试
		}
		if(q[f].b!=0&&t[q[f].a][0]==0){
			r++;
			q[r].a=q[f].a; q[r].b=0; q[r].w=4; q[r].l=f;
			t[q[r].a][q[r].b]=1;
		}
		if(q[f].a!=a&&q[f].b!=0){
			if(q[f].a+q[f].b<=a&&t[q[f].a+q[f].b][0]==0){//这个要判两种
				r++;
				q[r].a=q[f].a+q[f].b; q[r].b=0; q[r].w=5; q[r].l=f;
				t[q[r].a][q[r].b]=1;
				//cout<<q[r].a<<" "<<q[r].b<<" "<<q[r].w<<endl;
			}
			if(q[f].a+q[f].b>a&&t[a][q[f].a+q[f].b-a]==0){
				r++;
				q[r].a=a; q[r].b=q[f].a+q[f].b-a; q[r].w=5; q[r].l=f;
				t[q[r].a][q[r].b]=1;
				//cout<<q[r].a<<" "<<q[r].b<<" "<<q[r].w<<endl;
			}
		}
		if(q[f].a!=0&&q[f].b!=b){
			if(q[f].a+q[f].b<=b&&t[0][q[f].a+q[f].b]==0){
				r++;
				q[r].a=0; q[r].b=q[f].a+q[f].b; q[r].w=6; q[r].l=f;
				t[q[r].a][q[r].b]=1;
				//cout<<q[r].a<<" "<<q[r].b<<" "<<q[r].w<<endl;
			}
			if(q[f].a+q[f].b>b&&t[q[f].a+q[f].b-b][b]==0){
				r++;
				q[r].a=q[f].a+q[f].b-b; q[r].b=b; q[r].w=6; q[r].l=f;
				t[q[r].a][q[r].b]=1;
				//cout<<q[r].a<<" "<<q[r].b<<" "<<q[r].w<<endl;
			}
		}
		f++;//把首坐标后移
	}
}
int main(){
	cin>>n;
	for(int i=1; i<=n; i++){
		int a,b,c;
		cin>>a>>b>>c;
		bfs(a,b,c);//开始广搜
	}
	return 0;
}
```
#### 本题难点是方法的输出，拙代码的优点是简洁方便，通过存储每个状态的上一个状态在队列里的坐标，最后就可以倒着搜出方案。有位大佬用了数组，本蒟蒻认为不必要

---

## 作者：Erutsiom (赞：4)

蒟蒻的题解

注释掉的代码是之前这个题的……

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
int x,y,z;
bool b[1010][1010];
struct node{
	int v1,v2,steps;
	string op; 
};
void print(string op)
{
	cout<<op.length()<<" ";
	for(int i=0;i<op.length();i++)
	{
		switch (op[i])
		{
			case '1':
				cout<<1<<" ";
				//cout<<"fill A"<<endl;
				break;
			case '2':
				cout<<2<<" ";
				//cout<<"fill B"<<endl;
				break;
			case '3':
				cout<<3<<" ";
				//cout<<"empty A"<<endl;
				break;
			case '4':
				cout<<4<<" ";
				//cout<<"empty B"<<endl;
				break;
			case '5':
				cout<<6<<" ";
				//cout<<"pour A B"<<endl;
				break;
			case '6':
				cout<<5<<" ";
				//cout<<"pour B A"<<endl;
				break;				
		}
	}
	cout<<endl;
}
bool bfs()
{
	queue<node>q;
	q.push({0,0,0,""});
	while(!q.empty())
	{
		node cur=q.front();
		int v1=cur.v1,v2=cur.v2,steps=cur.steps;
		string op=cur.op;		
		q.pop();
		//Gang->A
		//A不满 才能倒 倒则倒满 
		if(v1<x && !b[x][v2]) 
		{
			b[x][v2]=1;
			q.push({x,v2,steps+1,op+"1"});
		}
		//Gang->B
		//B不满 才能倒 倒则倒满 
		if(v2<y && !b[v1][y])
		{
			if(y==z)//if(v1==z||y==z)
			{
				op+="2";
				print(op); 
				//cout<<steps+1<<endl;
				return 1;
			}
			b[v1][y]=1;
			q.push({v1,y,steps+1,op+"2"});
		}
		
		//A->Gang
		//A有水 才能倒 倒则倒空 
		if(v1>0 && !b[0][v2])
		{
			b[0][v2]=1;
			q.push({0,v2,steps+1,op+"3"});
		}
		//B->Gang
		//B有水 才能倒 倒则倒空 
		if(v2>0 && !b[v1][0])
		{
			b[v1][0]=1;
			q.push({v1,0,steps+1,op+"4"});
		}
		//A->B
		//A有水 B不满 才能倒
		if(v1>0 && v2<y)
		{
			//倒空A
			if(y-v2>=v1&&!b[0][v1+v2])
			{
				if(v1+v2==z)
				{
					op+="5";
					print(op);
					//cout<<steps+1<<endl;
					return 1;
				}
				b[0][v1+v2]=1;
				q.push({0,v1+v2,steps+1,op+"5"});
			} 
			//倒满B
			if(y-v2<=v1&&!b[v1-y+v2][y])
			{
				b[v1-y+v2][y]=1;
				q.push({v1-y+v2,y,steps+1,op+"5"});
			}
		}
		//B->A
		//B有水 A不满 才能倒
		if(v2>0 && v1<x)
		{
			//倒空B
			if(x-v1>=v2&&!b[v1+v2][0])
			{
				b[v1+v2][0]=1;
				q.push({v1+v2,0,steps+1,op+"6"});
			} 
			//倒满A
			if(x-v1<=v2&&!b[x][v2-x+v1])
			{
				if(v2-x+v1==z)
				{
					op+="6";
					print(op);
					return 1;
				}
				b[x][v2-x+v1]=1;
				q.push({x,v2-x+v1,steps+1,op+"6"});
			}
		}		
	}
	return 0;
} 
void Init()
{
	memset(b,0,sizeof(b));
}
int main()
{	
	int qaq;
	cin>>qaq;
	for(int o=1;o<=qaq;o++)
	{
		cin>>x>>y>>z;
		Init();
		bfs();
		//if(!bfs())cout<<"impossible"<<endl;
	}
				
	return 0;
}
```

---

## 作者：jiapeilin (赞：3)

```cpp

一道非常水的题
不啰嗦了，直接上代码
（蒟蒻勿看，小心被刺伤心灵^-^）

#include <bits/stdc++.h>

using namespace std;

bool vis[1005][1005];

int A,B,c;

struct water
{
	int a,b;
	int step;
	int pre;
	int poc;
};

water q[1000005];
int front,rear;

void print(int idx)
{
	if(idx==0) return;
	print(q[idx].pre);
	cout<<q[idx].poc<<" ";
}

void bfs()
{
	water t;
	water nt;
	front=rear=0;
	t.a=0;
	t.b=0;
	t.step=0;
	vis[0][0]=1;
	q[rear++]=t;
	while(front<rear)
	{
		t=q[front++];
		if(t.b==c)
		{
			cout<<t.step<<" ";
			print(front-1);
			cout<<endl;
			break;
		}
		//fill A
		nt.a=A,nt.b=t.b,nt.step=t.step+1;
		nt.poc=1;
		nt.pre=front-1;
		if(!vis[nt.a][nt.b])
		{
			vis[nt.a][nt.b]=1;
			q[rear++]=nt;
		}
		//fill B 
		nt.a=t.a,nt.b=B,nt.step=t.step+1;
		nt.poc=2;
		if(!vis[nt.a][nt.b])
		{
			vis[nt.a][nt.b]=1;
			q[rear++]=nt;
		}
		//drop A
		nt.a=0,nt.b=t.b,nt.step=t.step+1;
		nt.poc=3;
		if(!vis[nt.a][nt.b])
		{
			vis[nt.a][nt.b]=1;
			q[rear++]=nt;
		}
		//drop B
		nt.a=t.a,nt.b=0,nt.step=t.step+1;
		nt.poc=4;
		if(!vis[nt.a][nt.b])
		{
			vis[nt.a][nt.b]=1;
			q[rear++]=nt;
		}
		//pour A B
		nt.poc=6;
		if(t.a+t.b>=B)
		{
			nt.a=t.a+t.b-B,nt.b=B,nt.step=t.step+1;
			if(!vis[nt.a][nt.b])
			{
				vis[nt.a][nt.b]=1;
				q[rear++]=nt;
			}
		}
		else
		{
			nt.a=0,nt.b=t.a+t.b,nt.step=t.step+1;
			if(!vis[nt.a][nt.b])
			{
				vis[nt.a][nt.b]=1;
				q[rear++]=nt;
			}
		}
		//pour B A
		nt.poc=5;
		if(t.a+t.b>=A)
		{
			nt.a=A,nt.b=t.a+t.b-A,nt.step=t.step+1;
			if(!vis[nt.a][nt.b])
			{
				vis[nt.a][nt.b]=1;
				q[rear++]=nt;
			}
		}
		else
		{
			nt.a=t.a+t.b,nt.b=0,nt.step=t.step+1;
			if(!vis[nt.a][nt.b])
			{
				vis[nt.a][nt.b]=1;
				q[rear++]=nt;
			}
		}
	}
}

int main()
{
	int num;
	cin>>num;
	while(num--)
	{
		memset(vis,0,sizeof(vis));
		memset(q,0,sizeof(q));
		cin>>A>>B>>c;
		bfs();
	}
	return 0;
}
ps：大佬勿喷，作者是个蒟蒻^-^（认怂为妙）……


---

## 作者：渺小的Mastar (赞：2)

这是道隐式图搜索的题目；
转换完之后可以用一个有点像Bellmanford或者dij框架来跑接下来讲讲思路~~

## 要想的两个点

1/首先可以状态转移，然后创个队列（我用的优先队列，但其实好像不用）保存待处理的状态（其实就是bfs），然后新状态入队（其实就是bfs）。主要是维护一下各个操作的数字的操作比较烦人。
这里放上代码实现给大家看一下
```cpp
map<int, int> road;
map<int, int> opt;
inline void update_ans(int op, int FA, int SON, const Node &u)
{
    int d = u.v[1];
    road[SON] = FA;
    opt[SON] = op;
    ans[d] = u.dis;
}
```
2/怎么表示状态呢，因为题目里可以看到
# 0<C_a≤C_b，N≤_Cb≤1000
所以我就把第一个杯子乘了1000再加上第二个杯子
，所以你们在我update_ans的时候就可以看到
```cpp
update_ans(3, u.v[0] * 1000 + u.v[1], u2.v[0] * 1000 + u2.v[1], u2);
```
最后放上我的１４９行（ｑｗｑ）代码供大家学习，不要抄题解喔～这是不会进步的行为
```cpp
#include <map>
#include <queue>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#define maxn 1000
#define ll long long
#define rgi register unsigned int
using namespace std;
inline int read()
{
    int x = 0, f = 1;
    char c = getchar();
    for (; !isdigit(c); c = getchar())
        if (c == '-')
            f = -1;
    for (; isdigit(c); c = getchar())
        x = (x << 3) + (x << 1) + c - '0';
    return x * f;
}
struct Node
{
    int v[2], dis;
    bool operator<(const Node &rhs) const
    {
        return dis > rhs.dis;
    }
};
map<int, int> road;
map<int, int> opt;
int cap[3], ans[maxn], tmp[100000], pos;
bitset<maxn> vis[maxn];
inline void update_ans(int op, int FA, int SON, const Node &u)
{
    int d = u.v[1];
    road[SON] = FA;
    opt[SON] = op;
    ans[d] = u.dis;
}
void BFS(int a, int b, int c)
{
    priority_queue<Node> que;
    cap[0] = a;
    cap[1] = b;
    for (rgi i = 0; i <= maxn; ++i)
        vis[i].reset();
    opt.clear();
    memset(ans, -1, sizeof(ans));
    ans[0] = 0;
    Node start;
    start.dis = 0, start.v[0] = 0, start.v[1] = 0;
    que.push(start);
    vis[0] = 1;
    for (;;)
    {
        //ready
        Node u = que.top();
        que.pop();
        for (rgi i = 0; i <= 1; ++i)
            for (rgi j = 0; j <= 1; ++j)
                if (i != j)
                {
                    //Pour the water at I into J.
                    if (u.v[i] == 0 || u.v[j] == cap[j])
                        continue;                                       //To judge a situation where water cannot be poured.
                    rgi amount = min(cap[j], u.v[i] + u.v[j]) - u.v[j]; //Amount of poured water
                    Node u2 = u;
                    u2.dis++;
                    u2.v[i] -= amount;
                    u2.v[j] += amount;
                    if (!vis[u2.v[0]][u2.v[1]]) //The water of the first two cups is known to know the third Cup.
                    {
                        vis[u2.v[0]][u2.v[1]] = 1;
                        if (i == 0)
                            update_ans(6, u.v[0] * 1000 + u.v[1], u2.v[0] * 1000 + u2.v[1], u2);
                        else
                            update_ans(5, u.v[0] * 1000 + u.v[1], u2.v[0] * 1000 + u2.v[1], u2);
                        if (ans[c] >= 0)
                        {
                            pos = u2.v[0] * 1000 + u2.v[1];
                            return;
                        }
                        que.push(u2);
                    }
                }
        for (rgi i = 0; i <= 1; ++i)
        {
            if (u.v[i] != 0) //be able to pour water
            {
                Node u2 = u;
                u2.v[i] = 0;
                u2.dis++;
                if (!vis[u2.v[0]][u2.v[1]])
                {
                    vis[u2.v[0]][u2.v[1]] = 1;
                    if (i == 0)
                        update_ans(3, u.v[0] * 1000 + u.v[1], u2.v[0] * 1000 + u2.v[1], u2);
                    else
                        update_ans(4, u.v[0] * 1000 + u.v[1], u2.v[0] * 1000 + u2.v[1], u2);
                    if (ans[c] >= 0)
                    {
                        pos = u2.v[0] * 1000 + u2.v[1];
                        return;
                    }
                    que.push(u2);
                }
            }
            if (u.v[i] != cap[i])
            {
                Node u2 = u;
                u2.v[i] = cap[i];
                u2.dis++;
                if (!vis[u2.v[0]][u2.v[1]])
                {
                    vis[u2.v[0]][u2.v[1]] = 1;
                    if (i == 0)
                        update_ans(1, u.v[0] * 1000 + u.v[1], u2.v[0] * 1000 + u2.v[1], u2);
                    else
                        update_ans(2, u.v[0] * 1000 + u.v[1], u2.v[0] * 1000 + u2.v[1], u2);
                    if (ans[c] >= 0)
                    {
                        pos = u2.v[0] * 1000 + u2.v[1];
                        return;
                    }
                    que.push(u2);
                }
            }
        }
    }
}
int main()
{
    int T = read(), a, b, c;
    for (; T; T--)
    {
        a = read(), b = read(), c = read();
        BFS(a, b, c);
        printf("%d ", ans[c]);
        int cnt = 0;
        for (; pos; pos = road[pos])
            tmp[++cnt] = opt[pos];
        for (rgi i = cnt; i >= 1; --i)
            printf("%d ", tmp[i]);
        puts(" ");
    }
    return 0;
}
```


---

## 作者：EliClark266 (赞：1)

``Go``题解：  
```go
package main
import "fmt"
func main() {
    x := 0.0
    a := 0.0
    i := 0
    fmt.Scan(&x)
    for ;a != x;i ++{
        a += 0.98*a;
    }
    fmt.Print(i-1)
}
```
但是go语言会TLE的，我使用``D``语言写了一个版本：  
```py
import std.stdio;
int main(string[] arg){
    double a = 2.0,x = 0.0;
    int i=0;
    readf("%f\n",&x);
    for(;a < x;i++){
        a += 0.98*a;
    }
    write(i+1);
    return 0;
}
```
能成功输出。  

---
Tips:  
1.Go语言版本中，输出要i-1是因为在上一次循环结束后就应该得到了正确答案，要输出了，但是因为``i++``是操作结束后再自增，也就是说，i多加了一个1，则输出的时候-1。  
2.D语言版本中，输出要记得+1，因为在for循环中，我并没有用``<=``而用的是``<``，少循环一次，所以要+1。  
3.至于Go语言版本为什么不+1反而要-1，那是因为我用的是``!=``运算符，在这个题目中，相当于是``<=``了。因为一旦出现``>``的情况，循环就结束了。

---

## 作者：yu__xuan (赞：1)

[我的博客园](https://www.cnblogs.com/poi-bolg-poi/p/11140502.html)
---
###题目

[戳](https://www.luogu.org/problemnew/show/P1432)

###思路

$bfs$
不卡常$50$、卡常$100$。qwq(本蒟蒻不怎么会卡常，都是乱卡的，最好不要学)

###$Code$
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<cstdio>
using namespace std;
int t,ca,cb,n,step,sum;
int a_now[100001],b_now[100001],flag[100001];//a_now、b_now分别记录a、b壶中的水，flag判断当前这一步是从哪里扩展来的
int ans[100001],qwq[100001];//ans存储进行了哪一步操作，qwq是最后的答案
bool vis[1001][1001];//判断是否到达过当前情况
inline int read(){
    int x=0;bool f=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return f?-x:x;
}//读优
inline void write(int x){
	if(x<0) putchar('-'),write(-x);
	else {if(x/10)write(x/10);putchar(x%10+'0');}
}//输出
inline void js(int x){
    if(flag[x]){
        js(flag[x]),step++;
        qwq[++sum]=ans[x];
    }
    return;
}//计算用了几步以及分别是那几步
void bfs(int a,int b){
    int head=0,tail=1;
    flag[tail]=0;
    a_now[tail]=a;
    b_now[tail]=b;
    vis[a][b]=1;
    while(head<tail){
        head++;
        for(register int i=1;i<=6;++i){
            if(i==1){
                int c=ca,d=b_now[head];
                if(!vis[c][d]){
                    vis[c][d]=1;
                    tail++,ans[tail]=i;
                    a_now[tail]=c,b_now[tail]=d;
                    flag[tail]=head;
                    if(d==n){js(tail);return;}
                }
            }//1操作:fillA 意为给A灌满水
            if(i==2){
                int c=a_now[head],d=cb;
                if(!vis[c][d]){
                    vis[c][d]=1;
                    tail++,ans[tail]=i;
                    a_now[tail]=c,b_now[tail]=d;
                    flag[tail]=head;
                    if(d==n){js(tail);return;}
                }
            }//2操作:fill B
            if(i==3){
                int c=0,d=b_now[head];
                if(!vis[c][d]){
                    vis[c][d]=1;
                    tail++,ans[tail]=i;
                    a_now[tail]=c,b_now[tail]=d;
                    flag[tail]=head;
                    if(d==n){js(tail);return;}
                }
            }//3操作:empty A 意为将A中水倒空
            if(i==4){
                int c=a_now[head],d=0;
                if(!vis[c][d]){
                    vis[c][d]=1;
                    tail++,ans[tail]=i;
                    a_now[tail]=c,b_now[tail]=d;
                    flag[tail]=head;
                    if(d==n){js(tail);return;}
                }
            }//4操作:empty B
            if(i==5){
                int c,d,cha=ca-a_now[head];
                if(cha>=b_now[head]) d=0,c=a_now[head]+b_now[head];
                else c=ca,d=b_now[head]-cha;
                if(!vis[c][d]){
                    vis[c][d]=1;
                    tail++,ans[tail]=i;
                    a_now[tail]=c,b_now[tail]=d;
                    flag[tail]=head;
                    if(d==n){
                        js(tail);
                        return;
                    }
                }
            }//5操作:pour BA 意为将B中水倒到A中（直到A满或者B中水没有剩余）
            if(i==6){
                int c,d;
                int cha=cb-b_now[head];
                if(cha>=a_now[head]) c=0,d=b_now[head]+a_now[head];
                else c=a_now[head]-cha,d=cb;
                if(!vis[c][d]){
                    vis[c][d]=1;
                    tail++,ans[tail]=i;
                    a_now[tail]=c;
                    b_now[tail]=d;
                    flag[tail]=head;
                    if(d==n){
                        js(tail);
                        return;
                    }
                }
            }//6操作:pour A B
        }
    }
}
int main(){
    t=read();
    while(t--){
        ca=read(),cb=read(),n=read();
        bfs(0,0);//搜索
        printf("%d ",step);//输出有几步
        for(register int i=1;i<=step;++i){//输出答案
            write(qwq[i]);
            printf(" ");
            //printf("%d ",qwq[i]);
        }
        puts("");//换行
        step=sum=0;
        memset(vis,0,sizeof(vis));//初始化
    }
    return 0;
}
```

---

## 作者：月离 (赞：1)

## 这道题用bfs没有异议吧
- 1操作:fill AfillA 意为给AA灌满水
- 2操作:fill BfillB
- 3操作:empty AemptyA 意为将AA中水倒空
- 4操作:empty BemptyB
- 5操作:pour B ApourBA 意为将BB中水倒到AA中（直到AA满或者BB中水没有剩余）
- 6操作:pour A BpourAB
（以上引自原题）

就是说，只要注意好倒水的条件就可以用简单的bfs做出来

以下代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int ca[100000];
int cb[100000];
int n[100000];
struct node{
    int x,y,dep,op,fa;
};
int s[100000];
node q[10000100];
int vis[1001][1001];
int m;
int head;
int t;
int bfs(int ca,int cb,int n){//平凡的bfs
    q[0]=(node){0,0,0,0,0};
    head=0;
    int tail=1;
    vis[0][0]=1;
    while(head<tail){
        node p=q[head++];
        int a=p.x;
        int b=p.y;
        int dep=p.dep;
        if(b==n)return dep;
        if(a<ca&&vis[ca][b]==0){//操作1
            q[tail++]=(node){ca,b,dep+1,1,head-1};
            vis[ca][b]=1;
        }
        if(b<cb&&vis[a][cb]==0){//操作2
            q[tail++]=(node){a,cb,dep+1,2,head-1};
            vis[a][cb]=1;
        }
        if(a>0&&vis[0][b]==0){//操作3
            q[tail++]=(node){0,b,dep+1,3,head-1};
            vis[0][b]=1;
        
        }
        if(b>0&&vis[a][0]==0){//操作4
            q[tail++]=(node){a,0,dep+1,4,head-1};
            vis[a][0]=1;
        
        }
        if(a<ca&&b>0){//操作5（注意两种情况）
            if(b<ca-a){
                q[tail++]=(node){a+b,0,dep+1,5,head-1};
                vis[a+b][0]=1;
            }
            if(b>ca-a){
                q[tail++]=(node){ca,b-ca+a,dep+1,5,head-1};
                vis[ca][b-ca+a]=1;
            }
        
        }
        if(a>0&&b<cb){//操作6
            if(a<cb-b){
                q[tail++]=(node){0,a+b,dep+1,6,head-1};
                vis[0][a+b]=1;
            }
            if(a>cb-b){
                q[tail++]=(node){a-cb+b,cb,dep+1,6,head-1};
                vis[a-cb+b][cb]=1;
            }
        }
    }
    return -1;
}
void dfs(int p){
    if(p>0){
        dfs(q[p].fa);
        cout<<" "<<q[p].op;
    }
    if(p==0)return;
}
int main(){
    cin>>t;
    for(int i=1;i<=t;i++){
        for(int j=0;j<=1000;j++){//注意清空数据（memset）
            for(int k=0;k<=1000;k++){
                vis[j][k]=0;
            }
        }
        cin>>ca[i]>>cb[i]>>n[i];
        cout<<bfs(ca[i],cb[i],n[i]);
        dfs(head-1);
        cout<<endl;
    }
    return 0;
}
```
求过



---

## 作者：a1_1 (赞：1)

### P1432 【倒水问题】
bfs+hash求最优解，上码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct water{int a,b;string dep;};//先定义一个结构体,string类型的dep存每一次的操作很方便
queue<water>q;//开个队列
int c[1010][1010];//开个hash表
void print(string s)//输出函数
{
	int i;
	cout<<s.size();//输出完成次数
	for (i=0;i<s.size();i++) cout<<' '<<s[i];//输出每一次的操作
	cout<<endl;
}
void bfs(int a,int b,int n)
{
	water l;
    memset(c,0,sizeof(c));//初始化清零
	while (!q.empty()) q.pop();//初始化清空,stl queue不自带clear函数，想更高效见附录①
	q.push({0,0,""});//*c++11专属:{_,_,_}*
	while (!q.empty())
	{
		l=q.front();
		q.pop();
		if (l.b==n)//满足条件B=N
		{
			print(l.dep);//打印
			return;
		}
		if (c[a][l.b]==0) q.push({a,l.b,l.dep+'1'}),c[a][l.b]=1;//fill A
		if (c[l.a][b]==0) q.push({l.a,b,l.dep+'2'}),c[l.a][b]=1;//fill B
		if (c[0][l.b]==0) q.push({0,l.b,l.dep+'3'}),c[0][l.b]=1;//empty A
		if (c[l.a][0]==0) q.push({l.a,0,l.dep+'4'}),c[l.a][0]=1;//empty B
		if (l.b+l.a>a) {if (c[a][l.a-a+l.b]==0) q.push({a,l.a-a+l.b,l.dep+'5'}),c[a][l.a-a+l.b]=1;}
	    else {if (c[l.b+l.a][0]==0) q.push({l.b+l.a,0,l.dep+'5'}),c[l.b+l.a][0]=1;}//pour BA分两种情况讨论,第一种A满,第二种B空
	    if (l.a+l.b>b) {if (c[l.b-b+l.a][b]==0) q.push({l.b-b+l.a,b,l.dep+'6'}),c[l.b-b+l.a][b]=1;}
	    else {if (c[0][l.a+l.b]==0) q.push({0,l.a+l.b,l.dep+'6'}),c[0][l.a+l.b]=1;}//pour AB分两种情况讨论,第一种B满,第二种A空
	}
}
int main()//搜索题必有的巨短主函数
{
	int n,m,o,p;
	cin>>n;
	while (n--)
	{
		cin>>o>>p>>m;
		bfs(o,p,m);
	}
	return 0;
}
```
---
附录:

①详情请见https://www.cnblogs.com/zhonghuasong/p/7524624.html

---

## 作者：pipiispig (赞：1)

#这是个好题，可以让人体会到bfs的用处之广，难度并不大，注意细节就可以AC了；
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int a,b,c;
int vis[1010][1010];
struct node{
	int x,y,dep,op,pa;
};
node q[1001*1001];
int head=0,tail=1;
void cherk(int x,int y,int dep,int op,int pa){
	if(vis[x][y]!=0)return;
	vis[x][y]=1;
	q[tail++]=(node){x,y,dep,op,pa};
}//重复的部分可以用函数代替，不容易出错
int bfs(int x,int y,int op,int pa){
 head=0,tail=1;
	while(head<tail){
		node p=q[head++];
		int x=p.x,y=p.y,d=p.dep;
		if(y==c){
			return d;
		}
		if(x<a)cherk(a,y,d+1,1,head-1);
		if(y<b)cherk(x,b,d+1,2,head-1);
		if(x>0)cherk(0,y,d+1,3,head-1);
		if(y>0)cherk(x,0,d+1,4,head-1);
		if(x>0&&y<b){
			if(x<b-y)cherk(0,y+x,d+1,6,head-1);
			else cherk(x+y-b,b,d+1,6,head-1); 
		}//注意这个地方如果是if(x<b-y)&&vis[0][		 y+x]==0)再用else会出错，可以好好想想
		if(y>0&&x<a){
			if(y<a-x)cherk(x+y,0,d+1,5,head-1);
			else cherk(a,y+x-a,d+1,5,head-1); 
		}
	}
}
void dfs(int p){
	if(p>0){
		dfs(q[p].pa);
		cout<<q[p].op<<" ";
	}
}
int main(){
	int t;
	cin>>t;
	for(int u=1;u<=t;u++){
		cin>>a>>b>>c;
		memset(vis,0,sizeof(vis));
		vis[0][0]=1;
		cout<<bfs(0,0,0,0)<<" ";
		dfs(head-1);
		cout<<endl;
	}
}
```

---

## 作者：喝掉娃哈哈 (赞：0)

这是比较裸的BFS了吧

估计唯一的亮点就是没有打六个if(）......；

处理ans[]时借了一下i的特点减了一点代码量

talk is cheap ,show me the code:

```c
#include<cstdio>
#include<algorithm>
#include<stack>
using namespace std;
int c[2],N,f[100010],q[100010][2],ans[100010];
int tim;
int vis[1001][1001];
stack<int>st;
void out(int k) {
	while(f[k]!=0) {
		st.push(k);
		k=f[k];
	}
	printf("%d",st.size());
	while(!st.empty()) {
		k=st.top();
		st.pop();
		printf(" %d",ans[k]);
	}
}
bool p(int k) {
	if(q[k][1]==N) return 1;
	return 0;
}
int p2(int &r) {//判重啊OvO，注意用了地址符'&'，看不懂的小伙伴百度一下
	if(vis[q[r][0]][q[r][1]]==tim) r--;
	else {
		vis[q[r][0]][q[r][1]]=tim;
		if(p(r)) return r;
	}
	return -1;
}
int bfs() {
	int h=1,r=1;
	vis[0][0]=tim;//为什么要用一个递增的量tim，因为vis[][]如果一直标记为1，那第一次循环的结果会影响后面的判重，举个例子：第一次循环时vis[1][1]=1,第二次循环时vis[1][1]的状态明明还没被标记过，但第一次的标记会影响到
	while(h<=r) {
		for(int i=0; i<2; i++) {
			if(q[h][i]!=0) {
				q[++r][i]=0;
				q[r][(i+1)&1]=q[h][(i+1)&1];//假如i=1,则(i+1)&1=0,用于在0,1之间相互转换，下面也是一样OvO
				f[r]=h;
				ans[r]=i+3;//0+3=3,1+3=4,正好对应答案操作的编号OvO
				if(p2(r)==r) return r;
			}
			if(q[h][i]!=c[i]) {
				q[++r][i]=c[i];
				q[r][(i+1)&1]=q[h][(i+1)&1];
				f[r]=h;
				ans[r]=i+1;
				if(p2(r)==r) return r;
			}
			for(int j=0; j<2; j++) {
				if(i==j||q[h][i]==0||q[h][j]==c[j])continue;
				int w=min(q[h][i],c[j]-q[h][j]);
				q[++r][0]=q[h][0];
				q[r][1]=q[h][1];
				f[r]=h;
				q[r][i]-=w;
				q[r][j]+=w;
				if(i==0) {
					ans[r]=6;
				} else {
					ans[r]=5;
				}
				if(p2(r)==r) return r;
			}
		}
		++h;
	}
	return 0;
}
int main() {
	int n;
	scanf("%d",&n);
	while(n--) {
		++tim;
		scanf("%d%d%d",&c[0],&c[1],&N);
		out(bfs());
		printf("\n");
	}
}
```


---


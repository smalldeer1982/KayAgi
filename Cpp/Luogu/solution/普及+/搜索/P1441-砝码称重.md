# 砝码称重

## 题目描述

现有 $n$ 个砝码，重量分别为 $a_i$，在去掉 $m$ 个砝码后，问最多能称量出多少不同的重量（不包括 $0$）。

请注意，砝码只能放在其中一边。

## 说明/提示

【样例说明】

在去掉一个重量为 $2$ 的砝码后，能称量出 $1, 2, 3$ 共 $3$ 种重量。


【数据规模】

对于 $20\%$ 的数据，$m=0$。

对于 $50\%$ 的数据，$m\leq 1$。

对于 $50\%$ 的数据，$n\leq 10$。

对于 $100\%$ 的数据，$n\leq 20$， $m\leq 4$，$m < n$，$a_i\leq 100$。


## 样例 #1

### 输入

```
3 1
1 2 2```

### 输出

```
3```

# 题解

## 作者：hsfzLZH1 (赞：270)

此题的解法类似于NOIP2014普及组T4，思路都是先dfs枚举再dp。

### dfs过程

通过dfs过程，我们的目标是选择出所有的可能情况，然后对这些情况进行dp。

我们有两种选择：

1）从n个数字中选取n-m个数字保留

2）从n个数字中选取m个数字删除

观察题目的数据范围，我们发现，如果我们对dfs过程进行有效性剪枝，那么方案2）的时间复杂度会比方案1）小很多，扩展的状态数量也较小。

由此，我们可以设计出比较优的dfs函数：

```cpp
void dfs(int cur,int now)//cur代表当前已经选取/放弃了多少个砝码，now代表已经放弃了多少个砝码
{
    if(now>m)return;//如果已经放弃的砝码数超过了需要放弃的砝码数，剪枝
    if(cur==n){if(now==m)dp();return;}//如果搜索完后正好符合条件，执行一次dp过程
    dfs(cur+1,now);//不放弃当前的砝码，继续向下
    tf[cur]=true;//留下足迹
    dfs(cur+1,now+1);//放弃当前砝码
    tf[cur]=false; //擦除足迹
} 
```
### dp过程

通过dfs过程找到一种状态以后，求出使用当前留下的这些砝码可以凑出多少个不同的重量，我们通过dp解决这个问题。

观察题目可得，这个过程可以通过01背包实现。

定义f[i][j]为当前选取到了第j个砝码，如果通过之前的砝码可以称量出重量i那么f[i][j]的值为true。

状态转移方程为： f[i][j]=f[i-a[i]][j-1]

初始状态为f[0][j]=true

最后f[i][n]中true的个数就是通过这些砝码可以计算出的重量值。

通过滚动数组，我们可以只定义一个f[i]数组，降低了时间复杂度，注意此时内层循环倒序。

代码：

```cpp
void dp()//不传参，全部定义在全局变量中
{
    memset(f,0,sizeof f);f[0]=true;ans=0;tot=0;//清零，因为可能要调用多次
    for(int i=0;i<n;i++)//从前到后选取所有的砝码
    {
        if(tf[i])continue;//如果被标记为已经舍弃就跳过
        for(int j=tot;j>=0;j--)if(f[j]&&!f[j+a[i]])f[j+a[i]]=true,ans++;//否则dp并且维护ans的值
        tot+=a[i];//这个tot意为当前f[i]为真值的最大的i，极大加快了dp过程
    }
    ret=max(ans,ret);//更新最后的答案
}
```
总代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=22;
const int maxm=2010;
int n,m,a[maxn],ans,tot,ret;
bool tf[maxn],f[maxm];
void dp()
{
    memset(f,0,sizeof f);f[0]=true;ans=0;tot=0;
    for(int i=0;i<n;i++)
    {
        if(tf[i])continue;
        for(int j=tot;j>=0;j--)if(f[j]&&!f[j+a[i]])f[j+a[i]]=true,ans++;
        tot+=a[i];
    }
    ret=max(ans,ret);
}
void dfs(int cur,int now)
{
    if(now>m)return;
    if(cur==n){if(now==m)dp();return;}
    dfs(cur+1,now);
    tf[cur]=true;
    dfs(cur+1,now+1);
    tf[cur]=false; 
} 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)scanf("%d",a+i);
    dfs(0,0);
    printf("%d\n",ret);
    return 0;
}
```

---

## 作者：stfst (赞：81)

先%下红名大佬pantw，感谢提供思路

```
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
int n,m;
int w[30];
int ans = -inf;
int count_one(int x)//x的二进制中第0到n-1位中1的个数
{
    int cnt = 0;
    for(int i = 0; i <= n - 1; ++i)
        if(x & (1 << i))//注意做完按位与后的结果不是1，如可能为000010000，所以不要写成x & (1 << i) == 1
            cnt++;
    return cnt;
}
int main()
{
    cin >> n >> m;
    //我们在用二进制写题时，下标最好以0开始
    for(int i = 0; i <= n - 1; ++i)
        cin >> w[i];
    //(1 << n) - 1的二进制有n个1	
    for(int i = 0; i <= (1 << n) - 1; ++i)
    {
    	//如果此时的i的二进制中有n-m个1
        if(count_one(i) == n - m)
        {
            bitset<2010> b;
            b[0] = 1;//含义为重量0可以被称出
            for(int j = 0; j <= n - 1; ++j)
                if(i & (1 << j))//如果i的第j位上是1
                    b = b | b << w[j];
            ans = max(ans,(int)b.count());
        }
    }
    cout << ans - 1 << endl;//把重量为0的情况排除
    return 0;
}

```


```
b = b | b << w[j]
```

b的第i位为1表示重量i可以被称量出

按位或的功能是集合合并

也就是将集合b与集合b<<w[j]合并，再迭代给b

b<<w[j]使得b的每一个为1的二进制位都向左移动了w[i]的距离

假设b的第i位为1，b<<w[j]后b的第i + w[j]位变为了1，表示重量i + w[j]可被称出

最后要把第0位上的1排除掉

---

## 作者：pantw (赞：63)

bitset好题啊！


首先用一个0到$2^n-1$的循环枚举状态，然后用popcount判断是否满足条件。


因为CCF规定不能使用下划线开头的内建函数所以我们只好自己写一个QAQ 实现方法见代码。 ~~其实一般都是打65536的表只是我懒emmm~~


对于满足限制的状态我们用bitset大法计算答案即可。


实现细节详见代码。


```cpp
#include <bitset>
#include <cstdio>
int w[25];
int table[16] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};
int popcount(unsigned int x) { // 返回x的二进制中1的个数
    int ret = 0;
    for(int i = 0; i < 8; i++) ret += table[x & 15], x >>= 4;
    return ret;
}
int main() {
    int n, m, ans = 0;
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++) scanf("%d", w + i);
    for(int i = 0, li = 1 << n; i < li; i++) {
        if(popcount(i) == n - m) {
            std::bitset<2010> S;
            S[0] = 1;
            for(int j = 0; j < n; j++) if(i & (1 << j)) S |= S << w[j];
            int siz = S.count();
            ans = ans > siz ? ans : siz;
        }
    }
    printf("%d\n", ans - 1);
    return 0;
}
```

---

## 作者：xiangling (赞：47)

## 对 @hsfzLZH1  题解的小部分纠正与补充说明

RT。目前 @hsfzLZH1  的题解得票最高，讲解也十分到位，在此表示感谢。然而，在 @hsfzLZH1  的题解里，有微小的细节没有处理好。

-------------

### 状态转移方程

原题解：$f[i][j]=f[i-a[i]][j-1]$,
事实上，应为：
$f[i][j]=f[i-a[j]][j-1]||f[i][j-1]$，其中$||$表示逻辑运算“或”。

**说明**：

- ：类比于背包问题，有“选与不选”的两种方案。此时$f[i-a[j]][j-1]$表示选择第$j$件物品，而$f[i][j-1]$表示不选择第$j$件物品。如果这两者中有一个成立，就可以使得**在前$j$件物品中，存在一种方案使得砝码重量达到$i$**，所以是逻辑运算“或”。

- @hsfzLZH1  的题解里有可能是笔误，也有可能是数据有点水。

----------------

### 关于数组下标问题

@hsfzLZH1  的题解数组下标是从零开始的，这里提供一种下标从一开始的$dfs$过程：

```
void dfs(int certain,int deserted)
{
    if(deserted>m)return;
    if(certain==n)
    {
        if(deserted==m)  //dp
        {
            memset(f,false,sizeof(f));
            f[0]=true;int cnt=0;  //init
            for(int j=1;j<=n;j++)
            {
                if(vis[j])continue;
                for(int i=n*100;i>=a[j];i--)
                f[i]=f[i-a[j]]||f[i];
            }
            for(int w=1;w<=n*100;w++)
            if(f[w])cnt++;
            ans=max(ans,cnt);
        }
        return;
    }
    
    dfs(certain+1,deserted);
    vis[certain+1]=true;
    dfs(certain+1,deserted+1);
    vis[certain+1]=false;
}
```

---

## 作者：EarringYYR (赞：29)

做这道题之前建议先看一下P2347这一道题，总体思路与这一道题十分相似(这一道题主要是多了一个DFS的过程)，下面来说一下这道题（敲黑板）：

使用的算法：DFS+DP（看到数据范围这么小应该首先想到的就应该是DFS）

做法：首先通过DFS枚举不取哪M个砝码的情况，再把每种情况依次DP，用一个ma记录最大值（详情见代码部分）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,a[21],f[2001],b[21],last=0,num=0,ma=0;
void search(int k)
{
    if(k==m+1)//当取出了M个砝码时开始计算
    {
        memset(f,0,sizeof(f));//清零！！！这一步不能忘掉
        f[0]=1;//当重量为0时要记为有一种情况，不然结果永远是0
        for(int i=1;i<=n;i++)
        {
            if(b[i]==0)//如果这个砝码没有被拿走
            {
                for(int j=2000;j>=0;j--)//必须倒叙！不然可能f[4]用了4g的砝码，f[8]的时候又把4g的砝码拿出来用一遍
                {
                    if(j+a[i]<=2000&&f[j]!=0)//如果这个重量可以取到且加上新砝码后重量小于等于最大重量（max_n*max_a[I]=2000)
                    {
                        f[j+a[i]]=1;//标记加上砝码后的重量也可以取到
                    }
                }
            }
        }
        num=0;
        for(int i=1;i<=2000;i++)//看哪些重量可以取到
            if(f[i])
                num++;
        if(num>ma)//记录最大值
            ma=num;
        return;
    }
    for(int i=last+1;i<=n;i++)//枚举取砝码的情况（这里采用的是顺次枚举，减少耗时）
    {
        b[i]=1;//记录为取过了
        last=i;//记录取到哪一个了
        search(k+1);//接着往下取
        b[i]=0;//回溯
    }
}
int main()
{
    //freopen("a.in","r",stdin);
    //freopen("a.out","w",stdout);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];//读入
    search(1);//枚举每种情况
    cout<<ma;
    return 0;
} 
```

---

## 作者：皎月半洒花 (赞：28)

思路：$01$ 背包方案数 + bitset + 子集枚举。

首先我的 dfs 菜的一匹，所以说一看这道题我就放弃了 dfs。

我们考虑子集枚举选取 $n-m$ 个物品时的状态，然后对于每一个状态进行一次 $bool$ 类型的 $01$ 背包，最后统计 $\max$ 即可。

但是显然我们的复杂度会达到

$$
T(n) = 2^n \times (n \sum a_i + 3n) -> \Theta(2^nn\sum a_i)
$$

其中第一项是枚举子集的复杂度，之后是 $01$ 背包方案数 + 扫一遍 + 清零+求出背包容量 $t$ 的复杂度。 

显然不足以 $1s$ 过。那么我们不妨思考一个简单的优化，我们枚举状态从 `1 <<(n - m - 1)` 开始，因为当位数小于 $n - m$ 时，永远选不够 $n-m$ 个。并且我们可以预处理出每个状态的 $1$ 的个数，那么我们就会有 

$$

\begin{aligned}
T(n) &= 2^n-2^{n-m}  +C_{n}^{m}\cdot  (n \sum a_i + 3n) 
\\
&=\Theta(\max(2^n - 2^{n-m}, C_{n}^{m} \cdot n\sum a_i))
\end{aligned}
$$

好像还可以的吧，但事实上我们还可以更优，我们直接考虑用$bitset$作为$dp$数组，然后就会有 $3 \cdot\frac{n}{32}$ 的检测代价，好像可以优化些常数。

最后我还用了

```cpp
inline int max(int a, int b) {return b - (b - a & (b - a >> 31));}
```

的毒瘤优化，但是依旧很慢——不过这不能阻止人类否定$dfs$的一家独大。

$qwq$

```cpp
#include <bitset>
#include <cstdio>
#include <iostream>
#define MAX 5000
using namespace std ;
int i, j, k, d, t ; bitset <MAX> dp ; 
int N, M, base[MAX], Len[MAX << 8], Max, Ans ; 

inline int max(int a, int b) {return b - (b - a & (b - a >> 31));}
int main(){
	cin >> N >> M ; d = N - M, Max = (1 << N) - 1 ;
	for (i = 1 ; i <= N ; ++ i) cin >> base[i] ;
	for (i = 1 ; i <= Max ; ++ i) Len[i] = Len[i - (i & -i)] + 1 ;
	for (i = 1 << d - 1; i <= Max ; ++ i){
		if(Len[i] == d){
			dp.reset(), dp[0] = 1, t = 0 ; 
			for (j = 0 ; j < N ; ++ j) t += (1 << j & i) ? base[j + 1] : 0 ;
			for (k = 0 ; k < N ; ++ k) 
				for (j = t ; j >= base[k + 1] ; -- j)
					dp[j] = (1 << k & i) ? dp[j] : (dp[j] | dp[j - base[k + 1]]) ; 
			Ans = max(Ans, (int)dp.count() - 1) ;
		}
	} 
	cout << Ans << endl ; return 0 ; 
}
```



# $by \ \ Flower\_ pks$

作者正在奋力卡常中。。。


---

## 作者：ivyjiao (赞：13)

**本篇题解 DP 含量为 $0$，bitset 含量为 $0$**。

思路：随机化+搜索。

由于每次删掉的砝码数量是一定的，所以我们只需要在 $b$ 数组放进去 $m$ 个 $1$，表示去掉的砝码，然后每次把 $b$ 数组 `random_shuffle` 一下，然后对剩下的砝码进行爆搜即可。

随机化万岁！

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[21],c[21],l,cnt,ans,suma;
bool b[21],vis[2001];
void dfs(int now,int sum){
    if(now>l){
        if(vis[sum]) return;
        vis[sum]=1;
        cnt++;
        return;
    }
    dfs(now+1,sum);
    dfs(now+1,sum+c[now]);
}
int main(){
    srand(time(0));
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        suma+=a[i];
        if(i<=m) b[i]=1;
    }
    while((double)clock()<CLOCKS_PER_SEC*0.99){
        random_shuffle(b+1,b+1+n);
        for(int i=0;i<=suma;i++) vis[i]=0;
        l=0,cnt=0;
        for(int i=1;i<=n;i++) if(!b[i]) c[++l]=a[i];
        dfs(1,0);
        ans=max(ans,cnt-1);
    }
    cout<<ans;
}
```

---

## 作者：Ch4rc0al (赞：9)

#### DP是不可能DP的，这辈子不可能DP的，只有打打模拟队列才能维持的了生活的样子，DP超难调的，一点都不好玩（~~还是要学的23333~~）

在经历了二维dp调不好，一维dp看不懂，bitset啥玩意的懵⚪之后，我决定尝试一下模拟这个过程。。。

感谢@WLZS 提供的深搜剪枝思路，出现了60->AC的奇迹。

说一说思路吧，

1. 深搜全排列去掉砝码（记得剪枝变成组合否则60分TLE）
2. 砝码称重过程：
	1. 找到一个没有去掉的砝码，加入队列
    2. 拿一个砝码，和已经加入队列的重量相加，最后自己加入队列（想一想为什么不先加入队列）
    3. 重复上一步，加完后更新答案的值

以下为代码部分


代码中变量说明

```cpp
/*全局变量*/
int w[25];  	//砝码重量
int vis[25]; 	//dfs标记该砝码是否已经取走
int all; //所有砝码重量，用于剪枝
/*int dfs(int step,int now,int b)*/
int step;	//搜索到哪一步 
int now; 	//剩下的质量
int b;    	//标记从哪个坐标开始搜索
int last;  	//标记上次搜索的坐标，用于剪枝
/*void check()*/
int book[2005]; 	//标记重量是否出现过
int mark[25];		//标记该砝码是否可用
int que[2005];   	//加法队列
```


----------------------------------------------- AC代码 ? -----------------------------------------------


```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n, m, w[25], vis[25], ans, all;
void dfs(int step, int now, int b);
void check()
{
    int book[2005] = {0};
    int que[2005] = {0};
    int mark[25] = {0};
    int tans = 0;
    for (int i = 1; i <= n; i++)
        if (vis[i])
            mark[i] = 1;  //我们用一个mark数组来判定当前情况下可用的砝码
    int tail, start;
    tail = 1;
    for (int i = 1; i <= n; i++)
    {
        if (!vis[i])
        {
            start = i;  //start为第一个可以加入队列的砝码下标
            break;
        }
    }
    mark[start] = 1;
    que[tail] = w[start];
    book[w[start]] = 1;
    tail++;  //队列初始化操作 ?
    tans++;
    for (int i = start + 1; i <= n; i++)
    {
        if (!mark[i])
        {
            mark[i] = 1;
            int temp = tail - 1; //temp为当前队列长度值
            for (int j = 1; j <= temp; j++)
            {
                int t = w[i] + que[j];
                if (!book[t])  //如果该值没有出现就加入队列并且 tans++
                {
                    book[t] = 1;
                    que[tail] = t;
                    tail++;
                    tans++;
                }
            }
            if (!book[w[i]]) //结束后把自己加入队列
            {
                book[w[i]] = 1;
                que[tail] = w[i];
                tail++;
                tans++;
            }
        }
    }
    ans = max(ans, tans);
}
void dfs(int step, int now, int b)
{
    if (now <= ans) //如果当前值小于答案值，剪枝（好像作用不大）
        return;
    if (step == m + 1)
    {
        check();
        return;
    }
    int last = 0;
    for (int i = b; i <= n; i++)
    {
        if (!vis[i] && w[i] != w[last]) //作用很大的一个剪枝，可以防止出现两个相同的序列
        {
            vis[i] = 1;
            dfs(step + 1, now - w[i], i + 1);
            vis[i] = 0;
            last = i;
        }
    }
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> w[i], all += w[i];
    sort(w + 1, w + n + 1); //排序保证深搜的单调性
    dfs(1, all, 1);
    cout << ans;
    return 0;
}
```
------------
~~通过我对洛谷IDE的测试，发现同样的代码，c++11比其他的快很多，不知道CCF评测机是怎样。。~~

以上

---

## 作者：momentous (赞：9)

### 主要思路

1、输入(不多说了);

2、用 DFS(深搜)枚举出n-m个砝码,存储在b数组中;

3、再用一个 DFS 枚举出剩下砝码能够秤出的重量,存放在记忆化数组(c数组)中;（详见代码）

4、统计出重量数,存储最大值;

5、输出。

### 奉上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int Max,n,m,Ans,k,MaxMax;
/*
	Max用于第二个DFS中,用于存储当前重量种数
	MaxMax用于存储最大种数的大小
	n代表有n个砝码
	m代表从n个砝码中去除m个砝码
	k代表n-m,表示n个砝码去除m个后,剩余的砝码数量
	Ans表示当前砝码重量之和
*/
int a[109],b[109],c[2009],d[109][2009];
/*
	a[i]用来存储第i个砝码的重量
	b[i]用来存储被选中的砝码重量
	c[i]表示在b[]数组中,重量为i的方案是否存在
	d[i][j]表示在b[]数组的前i个砝码,是否有称出过重量为j的方案
*/
bool f[109];
/*
	f[i]表示在枚举选中砝码DFS中,第i个砝码是否被选中过,确保了程序的正确性
*/
void DFS1(int number,int Mark)//number代表枚举到第几个存入b[]数组的砝码,Mark代表当前重量
{
    if(number>k)//若已经选完了n-m个,则将重量作为下标存入c[]数组
    {
        c[Mark]=1;
        return;
    }
    if(d[number][Mark]==1) return;//剪枝
    d[number][Mark]=1;//标记
    DFS1(number+1,Mark);//不选,当前重量不变,将number指向下一个待判断的砝码
    DFS1(number+1,Mark+b[number]);//选,当前重量加当前砝码重量,并将number指向下一个待判断的砝码
}
void DFS(int step,int last)//step表示选到第几个砝码,last是用来优化的,代表从第几个砝码开始选
{
    if(step==k)//如果数量到达n-m(就是k)就进入下一个DFS
    {
        DFS1(1,0);//将存入b[]数组的砝码能称出的重量作为下标存入c[]数组
        memset(d,0,sizeof(d));//清零
        for(int i=1;i<=Ans;++i)
            if(c[i]!=0) ++Max;//算出重量种数
        memset(c,0,sizeof(c));
        if(Max>MaxMax) MaxMax=Max;
        //更新最大值
        Max=0;
        //将当前值清0
        return;
    }
    //若还没选完
    for(int i=last+1;i<=n;++i)//枚举last+1至n的砝码
    {
        if(f[i]==false) continue;//如果第i个砝码被选过则跳过,选下一个砝码
        ++step;
        b[step]=a[i];//将选中砝码的重量a[i]存入b[step],step表示当前已选了几个砝码
        f[i]=false;//标记
        DFS(step,i);//向更深的地方继续搜索
        f[i]=true;
        b[step]=0;
        step--;//回溯
    }
}
int main()
{
    cin>>n>>m;//读入n,m
    k=n-m;
    //算出剩余的砝码数量(搜索上限)
    memset(f,true,sizeof(f));
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&a[i]);//读入a[i]
        Ans+=a[i];//累加
    }
    sort(a+1,a+n+1);
    //排下序,更利于数据的处理
    DFS(?,?);//读者可以看一下之前的注释并自己想一想这里填什么
    //从第0步,第0个开始搜
    cout<<MaxMax;
    //输出答案
    return 0;
}
```

---

## 作者：littlegagaduck (赞：8)

题目的标签是搜索，我个人觉得搜索的过程是挺简单的，倒是dp的过程卡了很长时间。

搜索的过程是朴素的dfs，选够了需要删去的就dp一次，没有选够则向下搜索，搜索的过程中如果发现剩下的可以选择的已经少于还需要选择的，显然不可能找到合适的结果，剪枝即可。

作为一个dp蒟蒻，我着重写了dp的过程，多有疏漏，敬请谅解。

首先考虑到的是将所有可以用的重量组合，最后又多少种不同的就有几种。

面对这种问题，为了避免超时，很自然想到能否用dp的思想解题。

我首先想到的是用dp数组存每个砝码的标号，尝试以后发现并不容易找到转移方程，后来想到能否用dp数组存已经找到的质量。

我们可以发现当外层循环来确定每一个放入的元素时（可以理解为一个一个放入，一个一个尝试），这时内层枚举可能的质量，如果当前
枚举到的质量去掉这个砝码的质量后的那个质量没有被标记为找过，这个枚举到的质量也是不能标记为可以得到的；如果之前那个质量已
经找到过，加上当前的质量也是可以标记为可以得到，答案便可以+1。

dp还有一个十分重要却容易忽略的，边界条件，这个是非常需要仔细思考的，稍微疏忽就可能导致错误。关于这道题的边界条件，其实也不难理解，当枚举的质量恰好等于当前枚举到的砝码的质量时，相当于只要这一个砝码，显然这个质量是可以得到的，这时dp数组需要标记为true， 
这时这个状态由什么转移而来呢，便是f[j-a[i]]（j==a[i]）即f[0]，这样很容易就能想到要把f[0]标记为true，这便是这道题的边界条件。

这道题里还有很多很多细节我这里没有详细的解释，但都很容易理解，还请大家自己多多思考，比如倒叙枚举j（类似背包）等等。

这道题给我的最大感触是，dp的过程十分的精细，稍微差一点就可能导致结果错误，纵使思考的过程可能有点复杂，一定要耐心坚持到最后，如此才能写好动态规划~~这一玄学的算法~~。 

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int a[1000],ans[1000],num=0,n=0,m=0,maxn=0,sum=0;
bool f[10000],useable[200];
void work()
{
	memset(useable,0,sizeof(useable));
	memset(f,0,sizeof(f));
	for(int i=1; i<=m; i++)
	{
		useable[ans[i]]=1;
	}
	f[0]=1;
	int now=0;
	for(int i=1; i<=n; i++)
	{
		if(useable[i]==1)
		{
			continue;
		}
		for(int j=sum; j>=a[i]; j--)
		{
			if(f[j-a[i]]&&!f[j])
			{
				f[j]=1;
				now+=1;
			}
		}
	}
	maxn=max(maxn,now);
}
bool visited[100]= {0};
void dfs(int cnt,int last)
{
	if(cnt==m+1)
	{
		work();
		return;
	}
	if(n-last<m-cnt)
	{
		return;
	}
	for(int i=last; i<=n; i++)
	{
		if(visited[i]==0)
		{
			ans[cnt]=i;
			visited[i]=1;

			dfs(cnt+1,i+1);

			visited[i]=0;
			ans[cnt]=0;
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
	{
		cin>>a[i];
		sum+=a[i];
	}
	sort(a+1,a+1+n);
	dfs(1,1);
	cout<<maxn;
	return 0;
}
```


---

## 作者：wzhhhhh (赞：4)

已阅全部题解，发现不是dfs就是bitset。这里发一个朴实无华的用int枚举子集的题解。

原理其实和bitset一样，但是bitset常数总归比位运算大

因为一个元素个数为$n$的集合$A$的子集有$2 ^ n$个，所以我们可以用一个$2 ^ n$以内的数$k$表示$A$的一个子集，在二进制下，$k$有$n$位（高位补$0$）,第$i$位的值表示元素$A_i$是否在该子集中。该子集的元素个数就是其对应数字在二进制下数位中1的个数。

详见注释

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

const int MX = 2e3 + 7;
int f[MX];
int n, m, a[27], sum, ans;

int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i], sum += a[i];
	for(int s = 0; s < (1 << n); s++) {	//枚举子集
		int c = 0;
		for(int t = s; t; c += t & 1, t >>= 1);	//计算子集元素个数（本人不喜欢用while）
		if(c == n - m) {	//子集元素个数符合要求时开始dp
			memset(f, 0, sizeof(f));	//01背包dp,不需赘述
			f[0] = 1;
			for(int i = 1; i <= n; i++) if((1 << (i - 1)) & s) {	//只dp子集内的元素
				for(int j = sum; j >= a[i]; j--) {
					f[j] |= f[j - a[i]];
				}
			}
			int tmp = 0;
			for(int i = 1; i <= sum; i++) if(f[i]) tmp++;
			ans = max(ans, tmp);
		}
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：Linne (赞：4)

本题与noip pj2014 T4是类似的，我们可以用dfs+dp来做，
但楼上dalao们已经给出了这样的做法，因此我们可以考虑另一个思路：
dfs+bitset


------------


看到这道题，我最先联想到了另一道同名的题————P2347。那一题的标算是：用一个涵盖所有重量的bitset b,b[i]代表了重量i是否能被称出，每来一个砝码j，就使b|=b<<w[j]，其中w[j]表示j的重量，最后b中1的数量减一（b[0]是不被包含在内的）就是我们的答案。

------------

这个思路对我而言很有启发，在这一题中，这个思路是完全可行的。由此，我们用bitset代替完成了dp的那一步工作，即：得到一个砝码集合后，算出此集合能称出的不同重量数。这时，我们回过头来看这一步的时间复杂度，显然它是O(n)的（或者说O(n-m)）,但是我们如果用dp来处理的话，时间复杂度的下界必然要达到O(n^2)级别。

------------
这样，我们就可以考虑前置工作————dfs了。 其他部分没什么好说，重点在这里：
```cpp
if(dep-1<=m+cur)
	dfs(dep+1,cur);
```
是这样考虑的：在我们需要选的砝码数小于等于我们尚有的砝码数时，我们可以选择不拿当前这个砝码；反之，我们就没有选择权，必须拿。因此，我们有“不选”的权利，当且仅当：
n-dep+1(需要选的砝码数)>=n-m-cur(还剩下的砝码数)
化简该式，可得dep-1<=m+cur，也就是上面代码中所写的那样,这个优化剪枝是十分有效的。

------------
现在来看总的时间复杂度，不难看出是O(C(n,m)*(n-m)),加上剪枝优化，常数还要更小，可以说是一个高效算法了，而且这个方法的代码也相对简洁。

------------
下面是完整代码

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long lint;
lint n,m,a[25],maxn,chosn[25];
bitset<2500>b;
lint dp(){
	b.reset();
	b[0]=1;
	for(int i=1;i<=n-m;++i){
		b|=(b<<a[chosn[i]]);
	}
	return b.count()-1;
}
void dfs(int dep,int cur){
	if(cur==n-m){
		maxn=max(maxn,dp());
		return;
	}
	if(dep>n)return;
	if(dep-1<=m+cur)
	dfs(dep+1,cur);
	chosn[cur+1]=dep;
	dfs(dep+1,cur+1); 
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;++i)cin>>a[i];
    dfs(1,0);
    cout<<maxn<<endl;
	return 0;
}

```

---

## 作者：SofanHe (赞：4)

## 状态压缩DP

思路就是枚举用哪一些,然后做01背包.

$m=0$特判一下啊,然后就过了.

~~这不是这个题的正解,我只是来发一下思路,不会的同学请移步其他题解~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,wei[25],sum;
long long ans,ztt;
bool vis[2010];
void work1(int zt,int total){
//01Backpack
	memset(vis,0,sizeof(vis));vis[0]=1;
    //状压01的公式
	for(int i=1;i<=n;++i)	if(zt&(1<<(i-1)))
		for(int j=total;j>=0;--j)	if(vis[j])
			vis[j+wei[i]]=1;
	long long anss=0;
	for(int j=1;j<=total;++j)
		if(vis[j])++anss;
	ans=max(ans,anss);
}
void dfs(int start,int ncut,int zt,int total){
	//普通的DFS
    if(ncut==m){
    	work1(zt,total);
        return;
    }
	for(int q=start+1;q<=n;++q)
		dfs(q,ncut+1,zt-(1<<(q-1)),total-wei[q]);
}
void work2(){
//特判为0的情况
	vis[0]=1;
	for(int i=1;i<=n;++i){
		scanf("%d",&wei[0]);
		for(int j=(i-1)*100;j>=0;--j)
			if(vis[j])vis[j+wei[0]]=1;
	}
	long long anss=0;
	for(int i=1;i<=n*100;++i)
		if(vis[i])++anss;
	cout<<anss;
}
int main(){
	scanf("%d%d",&n,&m);
	if(!m){
    	work2();
        return 0;
    }
	for(int i=1;i<=n;++i){
		scanf("%d",&wei[i]);
        sum+=wei[i];
    }
    //状压起点.
	for(int i=1;i<=n;++i){
		dfs(i,1,((1<<n)-1)-(1<<(i-1)),sum-wei[i]);
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：万弘 (赞：3)

应该是道绿题。

看到数据范围小，可以暴搜枚举去掉的砝码

```cpp
void dfs(ll x,ll pre)//当前要删第x个砝码，前一个删掉pre
{
	if(x>m)//到了边界就计算
	{
		cpt();
		return;
	}
	for(ll i=pre+1;i<=n;++i)//在剩下的砝码中选
	{
		ll tmp=a[i];//a[i]即i的质量
		a[i]=0;//变成0基本与删掉等价
		dfs(x+1,i);//搜索
		a[i]=tmp;//回溯
	}
}
```
那怎么搞cpt()呢?  
其实就是一个恰好背包.  
`设f[i][j]表示前i个物品能否选出j体积`  
则有：$$f[i][j]=f[i-1][j-a[i]](i>=1,j>=a[i])$$
$$f[0][0]=1$$
显然可以滚动掉一维
```cpp
#define maxn 21
ll a[maxn],n,m,ans=0,sum=0;//ans:最终答案，sum：质量和
bool vis[2001];//vis[j]:j是否可以被组成
void cpt()
{
	memset(vis,0,sizeof vis);//清0
	vis[0]=1;
	for(ll i=1;i<=n;++i)
		for(ll j=sum;j>=a[i];--j)
			vis[j]|=vis[j-a[i]];
	ll t=0;
	for(ll i=1;i<=sum;++i)
		if(vis[i])++t;
	if(t>ans)ans=t;
}
```

---

## 作者：yizimi远欣 (赞：3)

### 题目描述

现有n个砝码，重量分别为a1，a2，a3，……，an，在去掉m个砝码后，问最多能称量出多少不同的重量（不包括0）。

#### 【数据规模】

对于20%的数据，m=0；

对于50%的数据，m≤1；

对于50%的数据，n≤10；

对于100%的数据，n≤20，m≤4，m＜n，ai≤100。

### 主要思路 ： 爆搜 + ~~XJB~~剪枝 + ~~XJB~~判重

对，就是爆搜。我们暴力搜索一下我们要哪几个砝码要选。这里就涉及一个~~XJB~~剪枝：我们记录一下这是我们有几个砝码不选，如果超过m的话就不能继续不选了。

我们枚举出了哪几个砝码要选后如何搞有多少重量可以称出来呢？？

我们可以先把我们选的几个砝码的重量放在一个vector里好了，我们每次到一个要选砝码中，把vector中的每个重量加上当前选的砝码的重量，如果这个重量没有被出现过，就加入vector，然后把这个重量的判重bool数组相应位置标上。

### code：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
#define go(i, j, n, k) for(int i = j; i <= n; i += k)
#define fo(i, j, n, k) for(int i = j; i >= n; i -= k)
#define rep(i, x) for(int i = h[x]; i; i = e[i].nxt)
#define mn 22
#define mk 2010
#define inf 1 << 30
#define ll long long
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n, m, a[mn], maxx = -1, ans = 0;
bool f[mk], b[mn];
vector<int> get;
inline void get_ans(int x) { 
	// 打完才想到可以直接循环QAQ，做题时写递归写傻了
	if(x == n + 1) 
		return;
	if(b[x]) {
		int kkk = get.size();
		if(!f[a[x]]) get.push_back(a[x]);
		f[a[x]] = true;
		go(i, 0, kkk - 1, 1) {
			int zcy = get[i] + a[x];
			if(!f[zcy]) get.push_back(zcy);
			f[zcy] = true;
		}
	}
	get_ans(x + 1);
}
inline void dfs(int x, int now) {
	if(x == n + 1) {
		if(now != m) 
			return;
        // 初始化啊QwQ！
		ans = 0;
		memset(f, false, sizeof f);
		while(!get.empty()) get.pop_back();
		get_ans(1);
        // 统计答案（上限为Σa[i]，我很懒，直
        // 接maxn * max(a[i])）
		go(i, 1, 2000, 1) 
			if(f[i]) ans++;
		maxx = max(maxx, ans);
		return;
	}
	if(now > m) 
		return;
	b[x] = true;
	dfs(x + 1, now);
	b[x] = false; // 有个不选的就要把计数 + 1
	dfs(x + 1, now + 1);
}
int main() {
	n = read(), m = read();
	go(i, 1, n, 1) a[i] = read();
	dfs(1, 0);
	cout << maxx << "\n";
	return 0;
}

```

### P.S.：考前祝全国OIer NOIP 2018 RP++！！！

---

## 作者：lijiahao2017 (赞：3)

# P1441 【砝码称重】



### 题目描述

现有$n$个砝码，重量分别为$a1$，$a2$，$a3$，……，$an$，在去掉$m$个砝码后，问最多能称量出多少不同的重量（不包括$0$）。

### 输入输出格式

##### 输入格式：
输入文件$weight.in$的第$1$行为有两个整数$n$和$m$，用空格分隔

第2行有$n$个正整数$a1$，$a2$，$a3$，……，$an$，表示每个砝码的重量。

##### 输出格式：
输出文件$weight.out$仅包括$1$个整数，为最多能称量出的重量。

### 输入输出样例

##### 输入样例#1：

$3$ $1$

$1$ $2$ $2$

##### 输出样例#1：

$3$

说明

【样例说明】

在去掉一个重量为$2$的砝码后，能称量出$1$，$2$，$3$共$3$种重量。

【数据规模】

对于$20$%的数据，$m=0$；

对于$50$%的数据，$m≤1$；

对于$50$%的数据，$n≤10$；

对于$100$%的数据，$n≤20$，$m≤4$，$m＜n$，$ai≤100$。



现在小菜鸡爱上了发题解。

于是，今天小菜鸡要挑战一下新高度————发一篇难度为      提高+/省选-      的题解。

废话不多说，拿道题目先看题。

题目大意：从$n$个砝码中选出$n-m$个，能成量出最多重量。

可以将题目分两个部分：

第一个部分：搜索（dfs）

第二个部分：$dp$（$01$背包）




## $AC$思路：

#### 1.美好的开始，缺少不了输入

#### 2.用$dfs$解决$n$选$n-m$的问题

#### 3.用$dp$解决能成量出最多重量的问题



### 上$AC$代码：

```
#include<cstdio>//调用      scanf和printf      的库
#include<cstring>//调用      memset      的库
const int mx=205;//定义常量mx
int n,m,maxx=0,ans=0;
int a[mx],b[mx],f[20010];
//定义变量和数组
void dp()//dp（01背包）
{
	memset(f,0,sizeof(f)),f[0]=1;//初始化f，但f[0]=1，否则结果一定为0
	int s=0;//定义一个变量s，做累加
	for(int i=1;i<=n;i++)
	{
		if(b[i]==0)continue;//如果没选，不用再讨论了
		for(int j=maxx;j>=a[i];j--)//从上往下放
		{
			if(f[j-a[i]]==1&&f[j]==0)s++,f[j]=1;//第一次出现，标记并累加
		}
	}
	if(ans<s)ans=s;//更新ans
}
void dfs(int x,int k)//x选k
{
	if(k==m)//选好，进入下一步dp
	{
		dp();
		return ;//返回
	}
	if(x>n)return ;//如果x个超出n个，返回上一层
	dfs(x+1,k);
	b[x]=1;//选中
	dfs(x+1,k+1);//选下一个
	b[x]=0;//还原
}
int main()
{
	memset(b,0,sizeof(b));//初始化b数组为0
	scanf("%d %d",&n,&m),m=n-m;//n选n-m个
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),maxx+=a[i];
    //美好的输入
	dfs(1,0);//跑dfs
	printf("%d",ans);//输出能成量出最多重量
	return 0;
}
```

---

## 作者：George1123 (赞：3)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P1441 【砝码称重】](https://www.luogu.org/problem/P1441)

### 此题算法:搜索+背包

大致思路:

>1.$ $输入砝码质量$a[i]$,接下来搜索:

>2.$p[j]$表示当前第$j$个留下的砝码(留下$n-m$个)。刚开始时$p[j]=j$，再用以下代码遍历所有的$n$个砝码中留$n-m$个的方案。

```cpp
//m=n-m
int move=m;
while(move>0&&(p[move]>=n
||move<m&&p[move]==p[move+1]-1)){
	move--;
} if(move<=0) stop=1;
else {
	p[move]++;
	for(int i=move+1;i<=m;i++)
		p[i]=p[move]+i-move;
}
```

![](https://s2.ax1x.com/2019/10/10/u7enVe.jpg)


>3.$ $对每种方案背包。得出能拼出不同质量的数目并得出其最大值$ans$。

>4.$ $输出答案$ans$。

## 以下是代码+注释:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=22,M=2020;
int n,m,a[N],p[N],ans;
int ansl,maxn;
bool use[M],stop;
int main(){
	scanf("%d%d",&n,&m); m=n-m; //留n-m个
	for(int i=1;i<=n;i++)
		scanf("%d",a+i);
	for(int i=1;i<=m;i++)
		p[i]=i; //初始位置
	while(!stop){ //当方案最右化后stop=1
    		memset(use,0,sizeof(use));
		ansl=maxn=0; use[0]=1;
		for(int i=1;i<=m;i++){ //背包
			for(int j=maxn;j>=0;j--)
				if(use[j]&&!use[j+a[p[i]]]){
					use[j+a[p[i]]]=1;
					ansl++;
				}
			maxn+=a[p[i]];
		} ans=max(ans,ansl);
		int move=m;
		while(move>0&&(p[move]>=n //移动到下一种情况
		||move<m&&p[move]==p[move+1]-1)){
			move--;
		} if(move<=0) stop=1;
		else {
			p[move]++;
			for(int i=move+1;i<=m;i++)
				p[i]=p[move]+i-move;
		}
	} printf("%d\n",ans);
	return 0;
}
```

我把$use[M]$写成了$use[N]$，调试了三天。

谢谢大家! !


---

## 作者：冈崎梦美 (赞：3)

对于这道题的思路，各类题解已经讲得非常清楚了，我在这里仅提供一种优化的思路。

~~（嘛，无限宏定义，读入优化+内联卡常倒也可以，只是比较败人品吧）~~

我们考虑在DFS过程中着手优化。我们会发现，在搜索过程中，我们搜出来的方案会有重复，比如：
```
2 1 3
3 2 1
1 2 3
……
```
这些排列会被认为是不同的组合，大大提高了我们搜索的时间。

如何求组合？一般的思路是用单调性解决唯一性。使数据单调在这里有两种方法：

1. 在读入后加入一个Sort。
2. 用桶存储数据。

~~其实都是排序啦。~~

考虑用桶存储数据

优点：在读入之后没有额外的复杂度

缺点：可能需要更多的时间来遍历到所有数据

再看看桶的大小，$a_{i}$<=100，缺点完全可以忽略，用桶存储可行！

于是优化后的程序应运而生：
```
#include<bits/stdc++.h>
using namespace std;
int a[107],pack[21],ans=0,n,m,max_nums=0,min_nums=999,num;
bool f[3000];
void dp()
{
    memset(f,0,sizeof(f));f[0]=1;
    int sum=0,tot=0;
    for(int i=1;i<=num;i++) sum+=pack[i];
    for(int i=1;i<=num;i++)
    {
        for(int j=sum;j>=pack[i];j--)
            f[j]=f[j]+f[j-pack[i]];
    }
    for(int i=1;i<=sum;i++) 
    {
        if (f[i]) tot++;
    }
    ans=max(ans,tot);
}
void dfs(int x,int last)
{
    if (x>num)
    {
        dp();
        return;
    }
    for(int i=last;i<=max_nums;i++)//这里很重要。保证了pack数组的单调性，进而使得其不重复
    {
        if (a[i]>0)
        {
            a[i]--;
            pack[x]=i;
            dfs(x+1,i);
            a[i]++;
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int v;
        scanf("%d",&v);
        max_nums=max(max_nums,v);
        min_nums=min(min_nums,v);
        a[v]++;
    }
    num=n-m;//留下n-m个砝码
    dfs(1,min_nums);//从最小值进行搜索
    printf("%d",ans);
    return 0;
}
```
优化后的程序运行总时间减少至了$700ms$左右，较之原来的程序是原来的三分之一（原来$1900ms$）~~所以这道题时限还可以卡紧一点~~

以上。

Feather-Sea祝您在赛场好运连连。

---

## 作者：wanxiang_zx (赞：2)

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=2000;
int n,m,ans=0;
int a[maxn];
int cz[maxn];
bool b[maxn],f[maxn];
//f数组表示每一个重量是否可以称出来 
void dp()
{
     int s=0;
     int gs=0;
     //s记录目前所有砝码都用上可以称出的最大重量
     //gs记录能称出多少重量 
     memset(f,false,sizeof(f));
     f[0]=true;
     //压缩成一维空间 
     for(int i=1;i<=n;i++)
     {
       if(!b[i])
         continue;
       //如果这个砝码是被丢掉的，就不处理用它可以称出的重量 
       s+=a[i];
       for(int j=s;j>=a[i];j--)
         if(!f[j] && f[j-a[i]])
         {
           f[j]=true;
           gs++;
         }
        //从大到小列举每一个重量
        //如果它之前不能称出来且它减去这个砝码的重量可以称出来
        //说明它是可以称出来的 
     }
     ans=max(ans,gs);
}
void dfs(int x,int y)
{
     //x为正在处理第几个砝码，y为已经丢掉了多少个砝码 
     if(x==n+1 && y==m)
       dp();
     //如果已经处理到第n+1个砝码，且已经丢掉了m个砝码
     //说明这是一种可能的排列，尝试动归刷新ans 
     if(y+n-x>=m)
       dfs(x+1,y);
     //如果已经丢掉的砝码量y加上剩余还没处理的砝码(n-x)之和大于等于m
     //说明当前这个第x个砝码可以选择不丢掉 
     if(y<m)
     {
       b[x]=false;
       dfs(x+1,y+1);
       b[x]=true;
     }
     //如果已经丢掉的砝码个数y小于目标m
     //说明当前这个第x个砝码可以选择丢掉 
}
int main()
{
    memset(b,true,sizeof(b));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    dfs(1,0);
    //表示处理第1个砝码，已经丢掉了0个砝码
    printf("%d\n",ans); 
    system("pause");
    return 0;
}

```


---

## 作者：Randyhoads (赞：2)

这是一道DFS+DP，然而如果不加剪枝会TLE


DFS：用来枚举丢掉的M个砝码。


DP：判断有多少种情况。


这两个操作都很简单。。。


下面是剪枝


1.如果当前的总质量<=最大值，直接返回


2.最开始sort一遍，如果搜完了一遍后，在搜下一个发现和上一次搜的一样，就略过。。。


3.应为排序过，而且当前的这个的另一种解只能是再上一个状态之后，所以拿W记录上次搜到哪里了


4.用dfs中记录的当前的质量做DP中背包的大小


上代码。。。







    
    
    

        

    
    
    
    
    
    

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[21];
bool b[21]={0};
int ans=0;
int f[300001]={0};
int  all;
inline int Max(int a,int b)//MAX函数
{
    if(a>b) return a;
    else return b;
}
inline void dp(int M)//DP 函数。。。
{
    memset(f,0,sizeof(f));
    int total=0;
    f[0]=1;
    for(int i=1;i<=n;i++)//这个处理应该都知道
    {
        if(!b[i])
        {
        for(int j=M;j>=a[i];j--)
        {
                f[j]+=f[j-a[i]];
        }
    }
    }
    for(int i=1;i<=M;i++)
    {
        if(f[i])
            total++;
    }
    ans=Max(ans,total);
}
void dfs(int step,int now1,int w)//dfs
{
    if(now1<=ans) return;//剪枝1
    int now=0;
    if(step==m+1)
    {
        dp(now1);
    }
    else
    {
        for(int i=w+1;i<=n;i++)//i=w+1,剪枝3
        {
            if(!b[i]&&a[i]!=a[now])//剪枝2
            {
                b[i]=1;
                dfs(step+1,now1-a[i],i);
                b[i]=0;
                now=i;
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cin>>n>>m; //n:个数；m:去掉个数 
    for(int i=1;i<=n;i++){
        cin>>a[i];
        all+=a[i];
    }
    if (n-m<=1)//特判
    {
        cout<<max(0,n-m)<<endl;
    } 
    else
    {
      sort(a+1,a+n+1);
      dfs(1,all,0);
      cout<<ans;
    }
} 

```

---

## 作者：一只小狐狸 (赞：1)

本题是一道dp题，只不过在普通的满箱背包上加上了组合数的选取

先看组合数的选取部分

```cpp
void dfs(int x,int d)//d表示dfs深度，x表示目前选取的删除砝码 
{
	int i;
	if (d==m)
	{
		int y=dp();//dp()表示删除选中的m个砝码后可称出的重量总数 
		max1=max(max1,y);
	}
	else
	{
		for (i=x+1;i<=n;i++)
		{
			vis[i]=1;//记录是否访问 
			dfs(i,d+1);
			vis[i]=0;
		}
	}
}
```
在构造组合数后，进行满箱背包

```cpp
int dp()
{
	int cnt=1;
	int i,j;
	int a[21],s[21];
	int f[21][2001];
	int ans;
	for (i=1;i<=n;i++)
	{
		if (vis[i]==1)
		{
			continue;
		}
		else
		{
			a[cnt]=i;
			cnt++;
		}
	}//载入删除砝码后砝码顺序 
	s[0]=0;
	for (i=1;i<=n-m;i++)
	{
		s[i]=s[i-1]+w[a[i]];
	}//进行前缀和，一边在dp时进行优化 
	f[0][0]=1;
	for (i=1;i<=n-m;i++)
	{
		for (j=0;j<=s[i];j++)
		{
			if (j<=s[i-1])
			{
				f[i][j]=f[i-1][j]||f[i-1][j-w[a[i]]];
			}
			else
			{
				f[i][j]=f[i-1][j-w[a[i]]];
			}
		}
	}//满箱背包 
	ans=0;
	for (i=1;i<=s[n-m];i++)
	{
		ans+=f[n-m][i];
	}//统计 
	return ans;
}
```
最后附完整版代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,max1=0;
int w[21],vis[21];
int dp()
{
	int cnt=1;
	int i,j;
	int a[21],s[21];
	int f[21][2001];
	int ans;
	for (i=1;i<=n;i++)
	{
		if (vis[i]==1)
		{
			continue;
		}
		else
		{
			a[cnt]=i;
			cnt++;
		}
	}//载入删除砝码后砝码顺序 
	s[0]=0;
	for (i=1;i<=n-m;i++)
	{
		s[i]=s[i-1]+w[a[i]];
	}//进行前缀和，一边在dp时进行优化 
	f[0][0]=1;
	for (i=1;i<=n-m;i++)
	{
		for (j=0;j<=s[i];j++)
		{
			if (j<=s[i-1])
			{
				f[i][j]=f[i-1][j]||f[i-1][j-w[a[i]]];
			}
			else
			{
				f[i][j]=f[i-1][j-w[a[i]]];
			}
		}
	}//满箱背包 
	ans=0;
	for (i=1;i<=s[n-m];i++)
	{
		ans+=f[n-m][i];
	}//统计 
	return ans;
}
void dfs(int x,int d)//d表示dfs深度，x表示目前选取的删除砝码 
{
	int i;
	if (d==m)
	{
		int y=dp();//dp()表示删除选中的m个砝码后可称出的重量总数 
		max1=max(max1,y);
	}
	else
	{
		for (i=x+1;i<=n;i++)
		{
			vis[i]=1;//记录是否访问 
			dfs(i,d+1);
			vis[i]=0;
		}
	}
}
void read()
{
	int i;
	cin>>n>>m;
	for (i=1;i<=n;i++)
	{
		cin>>w[i];
	}
	dfs(0,0);
	cout<<max1<<endl;
}
int main()
{
	read();
	return 0;
}
```


---

## 作者：小黑AWM (赞：1)

# **上面提供一下考场上骗分的思路，要正解可以往下翻**
***
其实数据一开始给我的感觉是直接爆搜可过的……虽然事实证明并不行……可是某个缺德鬼给我们模拟赛上除了这题……没办法想不出比较好的办法只能硬干了。

这个是考场上临时想出来然后回来稍微调了一下的版本，大概的思路是通过meet-in-middle将问题分解问两个，首先枚举前半组砝码能够得到哪些值，再扫一遍1到所有砝码总和（比较类似[CF525E](https://www.luogu.org/problemnew/solution/CF525E)的思路），逐个检验其中哪些值可以通过砝码组合得到，但这个复杂度在最差的时候大概是超了10倍的……（而且常数还比较大）但是由于这个将直接爆搜的复杂度开了个根号，所以我觉得这不失为一个在考场上想不出来正解时候的好办法（毕竟OI按点给分，暴力写好还是很重要了）。
```cpp
//60分爆搜（这个分数和他们剪枝剪的不好的DP+DFS好像一样啊233）
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;
int n,m,a[30],b[30],ans,half,top;
map < int , int > weight[5000];
void dfs1(register int sum,register int m,int id){
    weight[id][sum] = 520;
    if( m == half+1) return;//half=3/4n
    dfs1( sum , m+1 , id );
    if( b[m] )return;
    dfs1( sum + a[m] , m + 1 , id );
}
bool dfs2(register int sum,register int m,register int want, int id){
    bool ret=false;
    if(weight[id][ want-sum ] == 520)
        return true;
    if( m == n+1) return false;
    ret |= dfs2( sum , m+1 ,want ,id);
    if( b[m] ) return ret;
    if( sum + a[m] <= want)
        ret |= dfs2( sum + a[m] , m+1 ,want ,id);
    return ret;
}
int sum(int id){
    register int result=0,maxn=0;
    dfs1( 0, 1 , id );
    for(register int i = 1; i <= n; i++)
        if(!b[i])
            maxn += a[i];
    for(register int i = 1; i <= maxn; i++)
        if(dfs2(0, half+1 ,i , id))result++;
    return result;
}
void solution(register int num,register int id){
    if(num == m){
        ans = max( ans , sum( ++top ) );
        return;
    }
    for(register int i = id; i <= n ; i++)
        if( !b[i] ){
            b[i] = true;
            solution( num + 1 , i );
            b[i] = false;
        }
}
int main(){
    cin>> n >> m;
    half=n*3/4;
    for(int i = 1; i <= n; i++)
        cin>>a[i];
    solution( 0 , 1 );//复杂度应该是O(C(n,m)*(2^(3/4*n)+2^(1/4*n)*sum(ai))*log(sum(ai)))
    cout << ans;
    return 0;
}
```
***
## 嗯既然是写题解，正解还是要放一波的。

其实pantw大神的题解特别好，为什么你们不给他顶到最前面，思路的解释我在代码里有注释。

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <bitset>
#include <algorithm>
#define MAX(a,b) a>b?a:b
using namespace std;
const int maxn=2018;
int a[30],n,m,ans;
inline char nc()
{
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    char ch=nc();int sum=0;
    while(!(ch>='0'&&ch<='9'))ch=nc();
    while(ch>='0'&&ch<='9')sum=(sum<<1)+(sum<<3)+ch-48,ch=nc();
    return sum;
}
void dfs(int sum, int id, bitset<maxn> ret){//sum为当前取用砝码数，id为当前用了第几个砝码，ret用于存储当前可以称出哪些质量
    if(sum == n - m + 1){//n-m为最多能拿的砝码个数，sum==n-m+1即拿完了
        ans = MAX(ans,(int)ret.count());//即ret中1的个数（就是能称出的重量的个数）
        return;
    }
    for(register int i = id; i <= sum + m; i++)
        dfs(sum + 1, i + 1, ret << a[i] | ret);//合并原来（所有能称出的重量+a[i]）和（所有原来能称出的质量）这两个集合（Orz pantw）
}
int main(){
    n=read(),m=read();
    for(int i = 1; i <= n; ++i)
        a[i]=read();
    bitset<maxn> b;
    b[0] = 1;
    dfs( 1, 1, b );
    printf("%d\n", --ans);//由于不包括0所以ans-1
    return 0;
}
//本来想抢个最优解，结果当前只有rank12，不过我空间比较小
```
***
## 最后想说一下，考场上就算想不出正解，也不要放弃，要努力打好暴力😭


---

## 作者：RiverHamster (赞：1)

这么~~好~~(water)的bool dp怎么没有人写`bitset`优化呢~~(以下内容Pascal请跳过)~~

## bitset是什么
`bitset`是STL中的一种数据结构，可以按位储存`bool`值

因为`1byte = 8bit`，而一个`bool`量占`1byte`，所以`bitset`的空间是`bool`数组的$1 \over 8$，在位运算上速度也更快，因为存储更加紧凑，可以运用于各种`bool`储存和~~打暴力~~dp中，例如本题和一些`floyd`判断关系题，加速明显

## 基本思路

基本思路很简单，由于`n`很小，直接DFS枚举删除的方案，然后用一个装箱(背包)算出数量，时间复杂度$O(Sum \times C(n,m))$ 其中sum是a[i]的和，楼下说的都很清楚了

dp的过程：
```cpp
memset(f, false, sizeof f); //f[i]表示可以称出i这个重量
f[0] = true;
for(int i=1; i<=n-m; i++)
	for(int j=sum; j>=d[i]; j--) //类似背包，d[]是DFS结束后的选择
    	f[i] |= f[i-d[i]]; //按位或
```

## 优化

其中dp的过程可以使用`bitset`优化，类似整数`bitset`可以支持位运算操作，把整个`f[]`数组用一个`bitset`模拟

对于每个`d[i]`，只需要进行操作`f |= f << d[i]`就可以模拟原来的第二层循环（`<<`是`bitset`的左移操作，原来的`f[i]`左移`d[i]`后就移到了`d[i + f[i]]`，可以手动模拟一下

那么dp代码就可以写成：
```cpp
bitset<2048> f;
int cal(){
    f.reset(); //整个清空，带一个int参数就清空某一位
    f[0] = true;
    for(int i=1; i<=use; i++) //枚举每一个砝码
        f |= f<<d[i]; //一个操作直接代替一层循环
    return f.count() - 1; //count()返回1的个数，因为不统计0，所以-1
}
```
完整代码就不贴了，dfs没什么难度，以下都没有开O2


原时间：[评测记录1](https://www.luogu.org/record/show?rid=8886702)$\quad$`968ms`

现时间：[评测记录2](https://www.luogu.org/record/show?rid=8886702)$\quad$`80ms`

---

## 作者：mr辄 (赞：1)

问题的实质就是完成对不同的数值的组合，求能够形成多少种不同的组合。首先建一棵搜索树，如下图所示，然后对该搜索树做一次深度遍历。由上图可以知道每1种砝码都存在多种情况，可以取0～n个，同样当第1种砝码取0个的时候，同样第二种砝码存在多种取法，依次类推，即建立了如上图所示的搜索树。直接深搜1～6，直到depth>6，然后直接用一维数组，记录能够称重的砝码，统计该数组的值，得出能够称重的种类。


#是不是看起来贼官方，但是当你看了代码后你会发现QWQ:

程序：


var f:array[0..1000]of longint;  //用于记录能够称重的不同重量

a,w:array[1..6]of longint; 数组a存放砝码的个数，数组w存放砝码的重量





```cpp
  s,i:longint;
procedure dfs(i:longint);
var j:longint;
begin
  if i>6 then begin        //完成1次6个砝码的组合，并记录能够称重的重量
    f[s]:=1;exit;
  end;
  for j:=0 to a[i] do begin     //按不同种类的砝码数量搜索能够称重的重量
    s:=s+j*w[i];
    dfs(i+1);        //  进入下一类别砝码重量的搜索
    s:=s-j*w[i];   //恢复现场，为搜索下一个重量做准备
  end;
end;
begin
  for i:=1 to 6 do read(a[i]);  //分别读入砝码的个数
  w[1]:=1;w[2]:=2;w[3]:=3; w[4]:=5;w[5]:=10;w[6]:=20;//定义砝码的重量
  fillchar(f,sizeof(f),0);  //初始化数组f；
  s:=0;      //初始化初值s，
  dfs(1);  //深度搜索调用过程
  s:=0;
  for i:=1 to 1000 do s:=s+f[i];
  writeln('Total=',s);
end.
//老铁没问题！！！
```

---

## 作者：北辰北辰北 (赞：1)

深搜枚举选择的砝码。

动规可能性。

看没有pascal的题解贡献一份。






```cpp
var a,b:array[1..100]of longint;
    i,n,m,sum,ans:longint;
    f:array[0..200000]of boolean;
function max(a,b:longint):longint;
begin
  if a>b then exit(a);
  exit(b);
end;
procedure qsort(l,r:longint);
var i,j,mid,p:longint;
begin
  i:=l; j:=r;
  mid:=a[(l+r)div 2];
  while i<j do
  begin
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then
    begin
      p:=a[i]; a[i]:=a[j]; a[j]:=p;
      inc(i); dec(j);
    end;
  end;
  if j>l then qsort(l,j);
  if i<r then qsort(i,r);
end;
procedure dp(sum:longint);
var i,j,k:longint;
begin
  k:=0; f[0]:=true;
  for i:=1 to n-m do
    for j:=sum downto 0 do
    if f[j] then
    if not f[b[i]+j] then
    begin inc(k); f[b[i]+j]:=true; end;
  ans:=max(ans,k);
end;
procedure dg(max1,num,sum:longint);
var i,j:longint;
begin
  if num=0 then
  begin
  for j:=1 to sum do f[j]:=false;
  dp(sum);
  exit;
  end;
  for i:=max1+1 to n do
  begin
    b[n-num-m+1]:=a[i];
    dg(i,num-1,sum+a[i]);
  end;
end;
begin
  readln(n,m);
  for i:=1 to n do read(a[i]);
  qsort(1,n);
  dg(0,n-m,0);
  writeln(ans);
end.
```

---

## 作者：usqwedf (赞：1)

快排+Dfs+DP+剪枝

·枚举取出砝码

·当前总质量<=最大值时推出

·由小到大取出


---

## 作者：Zachary_260325 (赞：1)

**~~发一个用vector和stack的懒人题解，谁知道能不能通过~~**

最近比较忙，很抱歉不能在思路上多讲了，代码的思路就是暴力dfs+计算，详情请看代码注释

```cpp
#include<cstdio>
#include<stack>
#include<vector>
#include<cstring>
std::vector<int> v;//记录不重复数字数量 
std::stack<int> stk;//记录已经选择的数字 
int n,m,a[21],max=1,q;
bool f[3005];//起去重作用 
void calc(std::stack<int> s)
{
	v.push_back(0);//每个砝码都可以单独进行组成 
	f[0]=1;//实际上，这句是强迫症写的，不写也没关系 
	while(!s.empty())//依次尝试每个数据 
	{
		int x=s.top(),r=v.size();//获取当前砝码的质量和加砝码之前的不同数字数量 
		s.pop();//已经使用当前砝码 
		for(int i=0;i<r;++i)
			if(f[v[i]+x]==0)//如果当前重量未重复 
			{
				f[v[i]+x]=1;//记录已有此重量 
				v.push_back(v[i]+x);//存入vector 
			}
	} 
	for(int i=0;i<v.size();++i)
		f[v[i]]=0;//比memset快一些的归零(也许) 
	if(max<v.size())//更新最大可能性数量 
		max=v.size();
	v.clear();//清空vector(速度怎么样不确定) 
	return;
}
void dfs(int x)
{
	if(x>n)//已经没有可以继续选择的砝码了 
		return;
	stk.push(a[x]);//选择这个砝码 
	//printf("%d %d\n",stk.size(),x); 
	if(stk.size()==q) 
		calc(stk);//如果数量已经够了，就去计算当前选择组成的质量数量 
	else
		dfs(x+1);//如果不够，就可以继续往下选择 
	stk.pop();//扔掉当前砝码不选择 
	dfs(x+1);//继续往下选 
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	q=n-m;//记录需要拿多少砝码才能停止 
	dfs(1);
	printf("%d",max-1);//因为最开始存vector时把0存上了，所以要减一 
	return 0;
}
```


---

## 作者：王鹏PRO (赞：0)

### **发一篇Java语言的题解**

#### 同样是使用BitSet，因为Java和C++的特性不同，所以使用方式也不一样。

##### 第一，解题思路
1. 递归法+回溯法 搞定选取N-M砝码，暴力出奇迹(其实是N比较小)
2. 使用BitSet集合，循环记录能秤出的重要。
3. 如果内存能再大些，使用HashSet也是可以的，目前125MB的存储后面的4个会MLE

##### 第二，递归+回溯法，取M个被舍弃的砝码，以实现取N-M个称重砝码，这个……我想大家都应该会吧

```java
    private static void dfs(int s, int cnt) {
        if (cnt == M) {
            int next = count();
            if (next > ans) ans = next;
        }
        if (M == 0) return;
        for (int i = s; i < N; i++) {
            if (vis[i]) continue;
            vis[i] = true;
            dfs(i + 1, cnt + 1);
            vis[i] = false;
        }
    }
```

##### 第三，说重点，Java中BitSet的使用
1. C++中这样【**_b = b | b << w[j]_**】的特性在 java中是不行的，所以要转变思路



2. 从Java的 BitSet的API入手，选取下面这些方法



- **void set(int index)**
	将指定索引处的位设置为 true。
    
- **int cardinality( )**
返回此 BitSet 中设置为 true 的位数。

- **void clear( )**
将此 BitSet 中的所有位设置为 false。

- **int nextSetBit(int startIndex)**
返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。



3. 代码逻辑

- 在dfs中取了N-M个砝码后，数当前选取的砝码可以秤出的重量数


```java
        if (cnt == M) {
            int next = count();
            if (next > ans) ans = next;
        }
```

- 使用两个BitSet，set和tmp1  
    
	set 存储已经秤出的重量
		
   tmp1  存放加入下一个砝码，可以秤出的重量数，同时加入已秤出的重量
	
   最后交换两个BitSet，再次循环。 
    
```java
    private static int count() {
        set.clear();
        tmp1.clear();
        int n;
        for (int i = 0; i < N; i++) {
            if (vis[i]) continue;
            set.set(0);//这样可以不用特意添加砝码自身的重量
            n = set.nextSetBit(0);//从开始或者下一个为true的索引号
            while (n >= 0) {
                tmp1.set(n);//加入已秤出的重量
                tmp1.set(n + base[i]);//加入下一个砝码，可以秤出的重量数
                n = set.nextSetBit(n + 1);
            }
            BitSet tmp2 = set;
            set = tmp1;
            tmp1 = tmp2;
            tmp1.clear();
        }
        return set.cardinality() - 1;//去除重量0
    }
```

    
4. 最后是完整的代码

```java

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.BitSet;

public class Main {
    private static int N, M, ans;
    private static int[] base;
    private static boolean[] vis;
    private static BitSet set;
    private static BitSet tmp1;

    public static void main(String[] args) throws Exception {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        in.nextToken();
        N = (int) in.nval;
        base = new int[N];
        vis = new boolean[N];
        in.nextToken();
        M = (int) in.nval;

        for (int i = 0; i < N; i++) {
            in.nextToken();
            base[i] = (int) in.nval;
        }
        ans = 0;
        set = new BitSet();
        tmp1 = new BitSet();
        dfs(0, 0);
        System.out.println(ans);
    }

    private static int count() {
        set.clear();
        tmp1.clear();
        int n;
        for (int i = 0; i < N; i++) {
            if (vis[i]) continue;
            set.set(0);
            n = set.nextSetBit(0);
            while (n >= 0) {
                tmp1.set(n);
                tmp1.set(n + base[i]);
                n = set.nextSetBit(n + 1);
            }
            BitSet tmp2 = set;
            set = tmp1;
            tmp1 = tmp2;
            tmp1.clear();
        }
        return set.cardinality() - 1;
    }

    private static void dfs(int s, int cnt) {
        if (cnt == M) {
            int next = count();
            if (next > ans) ans = next;
        }
        if (M == 0) return;
        for (int i = s; i < N; i++) {
            if (vis[i]) continue;
            vis[i] = true;
            dfs(i + 1, cnt + 1);
            vis[i] = false;
        }
    }
}

```

    
    
    
    
    
    

---

## 作者：lemir3 (赞：0)

[*获得更差的阅读体验*](https://www.lemir3.red/2019/10/23/Project1441砝码称重项目报告/)

## 题目分析

那个...我的思路貌似很毒瘤.

先用搜索搜出要删去的数,压到一个二进制串中,利用物竞神仙同桌的$fx991$算出$C^{4}_{20}$只有4845,可以接受.

每搜到一个串后,跑一遍背包,背包的思路类似于[*noip2018 d1t2货币系统*](https://www.luogu.org/problem/P5020),用$01$背包先算出剩下的数能够组合出来的数,然后统计一遍所有能够组合出来的数,记录下统计的最大值即可.

代码也很好实现.

## 代码

```cpp
#include "bits/stdc++.h"
#define lxl long long
#define R register
using namespace std;

lxl n,m,cnt,sec,ans,tot;
lxl a[21],f[20010];

inline lxl read(){char c=getchar();lxl f=1,output=0;for(;!isdigit(c);c=getchar())if(c=='-')f=-1;for(;isdigit(c);c=getchar())output=(output<<1)+(output<<3)+c-'0';return output*f;}
//"必须熟练掌握压行技巧"
inline void dp()
{
	cnt=0;
	memset(f,-0x3f,sizeof(f));
	f[0]=0;
	for(R lxl i=1;i<=n;++i)
	{
		if(sec&(1<<i))continue;//暴力判断这个数有没有被删掉
		for(R lxl j=tot;j>=a[i];j--)f[j]=max(f[j],f[j-a[i]]+1);//01背包,注意倒序枚举
	}
	for(R lxl i=1;i<=tot;++i)if(f[i]>0)cnt++;//如果这个数能够被剩下的数组合出来,累加答案
}
inline void work(lxl now,lxl pick)
{
	if(pick==m)
	{
		dp();
		ans=max(ans,cnt);
		return;
	}
	for(R lxl i=now+1;i<=n;++i)
	{
		sec|=1<<i;//把这个位置置为1
		work(i,pick+1);
		sec&=(~(1<<i));//去掉这个位置上的1
	}
}

signed main(void)
{
	n=read(),m=read();
	for(R lxl i=1;i<=n;++i)a[i]=read(),tot+=a[i];
	work(0,0);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：tony123456 (赞：0)

这道题用的是搜索+dp，但搜索部分可以直接用算法库中的next_permutation代替。

输入后先建一个x数组，把后n-m个数赋值为1，之后就用next_permutation生成x的全排列即可找到n个数中选n-m个的所有情况

然后用01背包的思想：对于第i个砝码，要称出j的重量，有两种选择：选或不选。于是可以写出状态转移方程：
```cpp
dp[i][j]=dp[i-1][j]|dp[i-1][j-a[i]]
```
再加上j与a[i]大小关系的判断就行了。（最好用滚动数组）

下面是代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<ctime>
#include<cstdlib>
#include<string>
using namespace std;
int dp[2][10000];//i:第i个砝码，j:称j的重量
int x[100]; //x[i]存第i个砝码选不选，选为1，不选为0
int a[100];//所有砝码
int b[100];//存当前情况下所有砝码
int l[100000];//l[i]存储i的重量能不能称出来，>0表示能，=0不能
int sum=0;
int n,m;
int main(){
    scanf("%d%d",&n,&m);//输入
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        sum+=a[i];
    }
    //下面生成n选n-m的所有情况
    for(int i=1;i<=n;i++){
        x[i]=1;
    } 
    for(int i=1;i<=m;i++){
        x[i]=0;
    }
    int maxn=0;
    do{
        int j1=1;
        for(int i=1;i<=n;i++){
            if(x[i]==1) {
                b[j1++]=a[i];//将x数组转化为b数组
            }
        }
        j1--;
        memset(dp,0,sizeof(dp));
        memset(l,0,sizeof(l));
        int ans=0;
        for(int i=0;i<=sum;i++){
            dp[i%2][0]=1;
        }
        for(int i=1;i<=j1;i++){
            for(int j=1;j<=sum;j++){
            	//dp
                dp[i&1][j]|=dp[(i-1)&1][j];
                if(j>=b[i]) dp[i&1][j]|=dp[(i-1)&1][j-b[i]];
                if(dp[i&1][j]) l[j]++;
            }
        }
        for(int i=1;i<=sum;i++){
            if(l[i]>0) ans++;//如果可以，ans+1
        }
        maxn=max(maxn,ans);
    }while(next_permutation(x+1,x+n+1));
    printf("%d",maxn);//输出
    return 0;
}
```

---

## 作者：娄口肃行 (赞：0)

## ~~一道标准的水题...~~
### 先在n个数字中找到m个删掉的数字,然后使用可行性dp判断一下即可....

### 时间复杂度O(C(4,20)\*2000\*n\)随便过了

```
void cal(int x1,int x2,int x3,int x4)
{
	int ans=0;
	memset(f,false,sizeof(f));
    f[0]=true;
	for (int i=1;i<=n;++i)
		if (i!=x1 && i!=x2 && i!=x3 && i!=x4)
		{
			for (int j=2000;j>=0;--j)
            	if (f[j]) f[j+a[i]]=true;
      	}
	for (int i=1;i<=2000;++i) if (f[i]) ++ans;
	an=max(an,ans);
	return;
}
```
dp部分
```
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;++i) scanf("%d",&a[i]);
	if (m==0) cal(0,0,0,0);
	else
	{
		for (int i=1;i<=n;++i)
        {
			if (m==1) cal(i,0,0,0);
			else
			{
				for (int j=i+1;j<=n;++j)
				{
					if (m==2) cal(i,j,0,0);
					else
					{
						for (int k=j+1;k<=n;++k)
							if (m==3) cal(i,j,k,0);
							else
								for (int l=k+1;l<=n;++l) cal(i,j,k,l);
					}
				}
			}
		}
	}
	cout<<an;
	return 0;
}
```

---

## 作者：RainFestival (赞：0)

这是我过的第一道蓝题

两种方法：

1、

我们可以用

### 先dfs再背包

dfs出去掉哪几个砝码

用01背包判断出总数

2、

### 我们还可以用状压dp

状态是选的砝码

第一种代码，第二种我没写：



```pascal
var
  a:array[-10..2005] of longint;
  vis:array[-10..2005] of boolean;
  n,m,maxs,i:longint;
procedure pd;
var
  i,j,m,s:longint;
  v:array[-10..10005] of boolean;
begin
  m:=0;
  s:=0;
  for i:=1 to n do
    if not vis[i] then m:=m+a[i];
  //for i:=1 to n do
    ///if not vis[i] then write(a[i],' ');

  v[0]:=true;
  for i:=1 to m do
    v[i]:=false;
  for i:=1 to n do
    if not vis[i] then
      //begin
        for j:=m downto a[i] do
          if v[j-a[i]] then v[j]:=true;
        //write(a[i],' ');
      //end;
  for i:=1 to m do
    if v[i] then inc(s);
  //if s=33 then
    ///for i:=1 to m do
    //?writeln(v[i],' ');
  //for i:=1 to m do write(v[i],' ');
  //writeln;
  //writeln(s);
  //////writeln(' ',m,' ',s);
  if s>maxs then maxs:=s;
  //writeln(s);
end;
procedure dfs(n1,a:longint);
var i:longint;
begin
  if n1>m then
    begin
      //writeln(1000111111);
      pd;
      exit;
    end;
  for i:=a+1 to n do
    begin
      vis[i]:=true;
      dfs(n1+1,i);
      vis[i]:=false;
    end;
end;
begin
  readln(n,m);
  for i:=1 to n do
    read(a[i]);
  dfs(1,0);
  writeln(maxs);
end.

```
谢谢大大大佬，聚聚聚老（巨巨巨佬）们的观赏


实测时间701ms/空间0.79MB幸好没超时

---

## 作者：zyyyyyyyyyyyyyyy (赞：0)

# DP是不可能的，这一辈子都不可能的
# ~~然而并不能躲过DFS~~
大体思路是先DFS所有情况~~（不会STL的我瑟瑟发抖）~~。
然后，可以考虑用队列代替dp
```cpp
void check()
{
    int i,j;
    r=1;
    //和谐了
    memset(b,0,sizeof b);
    for (i=1;i<=n-m;i++)
    {
        l=r;
        for (j=1;j<=l;j++)
        if (!b[f[i]+a[j]])
        {
            r++;
            b[f[i]+a[j]]=1;
            a[r]=f[i]+a[j];
        }
    }
    r--;
    if (r>ans) ans=r;
}
```
队列思路如下：
如果对于前i种砝码，可以称出a[1]..a[k]的重量，那么对于第i+1个砝码，可以在已经称出的重量中分别加上已有的重量，以生成新的重量（原有的重量可视为不用该砝码）详见代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int a[20001],b[20001],l,r,f[21],x[21],n,ans,m;
void check()
{
    int i,j;
    r=1;
    //依然和谐
    memset(b,0,sizeof b);
    for (i=1;i<=n-m;i++)
    {
        l=r;
        for (j=1;j<=l;j++)
        if (!b[f[i]+a[j]])
        {
            r++;
            b[f[i]+a[j]]=1;
            a[r]=f[i]+a[j];
        }
    }
    r--;
    if (r>ans) ans=r;
}
void dfs(int i, int j)
{
    if (j>n-i+1) return;
    if (i==n+1) check();
    if (j==0) {f[i-m]=x[i]; dfs(i+1,j); return;}
    dfs(i+1,j-1);
    f[i-m+j]=x[i];
    dfs(i+1,j);
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++) scanf("%d",&x[i]);
    ans=0;
    dfs(1,m);
    printf("%d",ans);
    return 0;
}
```
代码中a表示队列~~剩下的作用你们自己猜~~，PS：码风略丑，请见谅

---

## 作者：亡魂•夺命 (赞：0)

这道题其实就是DP+DFS，DFS去掉砝码，将其标记；DP中的01背包求出种类，就可以了。
```pascal
var i,j,n,m,s,t,max:longint;
a:array[0..50]of longint; //表示砝码重量
b:array[0..50]of boolean;  //true表示没拿走，false表示拿走
f:array[0..5000]of longint;  
procedure dfs(k,t{去掉的砝码数},s{剩下的数量}:longint);
var i,x:longint;
begin
  if t=m then //m个砝码拿走了
  begin
    x:=0;fillchar(f,sizeof(f),0);f[0]:=1; //初始化
    for i:=1 to n do  //01背包
      if b[i] then
        for j:=s downto a[i] do f[j]:=f[j-a[i]]+f[j]; //求出能构成														 的重量
    for i:=s downto 1 do
      if f[i]>0 then x:=x+1; //所有大于0的都是能组成的重量
    if x>max then max:=x;  //求最大值
  end;
  if k>n then exit; //m个砝码没拿去，但没砝码了，返回。
  if b[k] then 这个砝码没拿走，可以拿走
  begin
    b[k]:=false; //拿走
    dfs(k+1,t+1,s-a[k]);  
    b[k]:=true; //回溯
  end;
  dfs(k+1,t,s); //不拿走的情况
end;
begin
  readln(n,m);
  fillchar(b,sizeof(b),true); //初始化，表示所有砝码未被拿走
  for i:=1 to n do //读入 
  begin 
    read(a[i]);
    s:=s+a[i]; //求出所有砝码的的重量
  end;
  dfs(1,0,s); 
  write(max);
end.
```

---

## 作者：肖恩Sean (赞：0)

对于这题来说，C++的algorithm库中有一个极为有用的函数next_permutation可以完美的解决枚举删除组合（或者是保留组合）的问题；

next_permutation仅需传入两个参数，即首指针和尾指针,使用方法参照sort，作用是将这段区间内变成下一个全排列，如果没有下一个全排列（即字典序最小）时返回0，于此相对的有prev_permutation，即上一个全排列

言归正传，这题选择在n个数中取m个数删除和在n个数中取n-m个数保留的时间复杂度是相同的（C(m,n)=C(n-m,n)）~~我的代码选择了前者~~

接下来的步骤就是做01背包了，01背包可以参考楼下题解

挂上176ms的代码（~~话说C++的算法库东西真好用~~）
```cpp
#include<bits/stdc++.h>
#define LL long long
#define For(i,l,r) for(register int i=(l);i<=(r);++i)
#define ReFor(i,l,r) for(register int i=(l);i>=(r);--i)
using namespace std;
const int N=22;
int n,m,ans;
int a[N],f[N*100];
bool del[N];
int read(){
    int x=0;bool f=0;char c=getchar();
    while (c<'0'||c>'9'){if (c=='-')f=!f;c=getchar();}
    while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
    return f?-x:x;
}
int main(){
    n=read();m=read();
    For(i,1,n) a[i]=read();
    sort(a+1,a+n+1);
    For(i,1,m) del[n-i+1]=1;
    //选取后m个数删除，使得del数组为最大字典序
    //也可以选取前m个数，使得del为最小字典序
    //那么后面就需要用prev_permutation
    do{
        int sum=0,tot=0;
        memset(f,0,sizeof(f));
        f[0]=1;
        For(i,1,n){
            if(del[i]) continue;
            tot+=a[i];
            ReFor(j,tot,a[i]) f[j]|=f[j-a[i]];
        }
        For(i,1,tot) if(f[i]) ++sum;
        ans=max(ans,sum);
    }while(next_permutation(del+1,del+n+1));
    printf("%d\n",ans);
    return 0;
}
```
另外，这个代码有个缺点，就是难以剪枝，比如说判断该种情况是否已经被取到过（比如数组a[]中有重复），至少需要O(n)复杂度，剪了枝之后时间复杂度还要上升QAQ

---

## 作者：【天朝】MILK (赞：0)

一道典型的搜索题
------------


搜索出**不放**的序列

加之**01背包**进行求解



------------

### 第一版 无**优化**


------------


```cpp
int Check()加之01背包进行求解
{
    int Num=0,Hash[20025]={0};Hash[0]=1;
    for(int i=1;i<=n;i++)
    {
        if(V[i])continue;
        for(int j=20000;j>=0;j--)//倒叙枚举更新
        {
            if(Hash[j]){Hash[j+A[i]]=1;}
        }
    }
    for(int i=1;i<=20000;i++)if(Hash[i])Num++;
    return Num;
}
void DFS(int From,int Num)//搜索出不放的序列
{
    if(Num==k+1){int k=Check();Maxx=max(Maxx,k);return;}
    for(int i=From+1;i<=n;i++)
    {
        V[i]=1;DFS(i,Num+1);V[i]=0;
    }
}
```

------------

结果:**982ms**

------------
小**优化**：

1）范围缩小

Tot+=A[i] (1<=i<=n)

Tot-=A[i] (i不放）

从**Tot**枚举更新

2）最优性剪枝

1. 由贪心可知放的越多可行解越多

2. 砝码值越小可行解越多

则 对A进行排序 

在进行下一步枚举时判断：若此时的值已经小于或等于此时最优解就返回



------------
### 第二版

------------
```
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int n,k,Maxx=0,Tot;
int A[25],V[25];
int Check()
{
    int Num=0,Hash[20025]={0};Hash[0]=1;
    for(int i=1;i<=n;i++)
    {
        if(V[i])continue;
        for(int j=Tot;j>=0;j--)
        {
            if(Hash[j]){Hash[j+A[i]]=1;}
        }
    }
    for(int i=1;i<=Tot;i++)if(Hash[i])Num++;
    return Num;
}
void DFS(int From,int Num)
{
    if(Check()<=Maxx)return;
    if(Num==k+1){int k=Check();Maxx=max(Maxx,k);return;}
    for(int i=From+1;i<=n;i++)
    {
        V[i]=1;Tot-=A[i];DFS(i,Num+1);V[i]=0;Tot+=A[i];
    }
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%d",&A[i]),Tot+=A[i];
    sort(A+1,A+n+1);
    DFS(0,1);printf("%d\n",Maxx);
    return 0;
}
```
------------

结果:**477ms**

------------

---

## 作者：用户已注销 (赞：0)



------------
**思路比较简单清晰，看数据范围可以猜到是暴搜 + 01背包**

具体做法敬请参见其他题解，这里讲一下几个小优化。

###### 第一：DFS中的可行性剪枝，是最基础的剪枝之一。

**①如果当前删掉的数已经超过了给定的M，一定是不合法的，剪掉。**

**②如果剩下的数都删掉也达不到给定的M，一定是不合法的，剪掉。**

这是基础中的基础，不过也有一点点小讲究，比如说剪枝的位置，最简单的是放在开头判断一下，这样**理论上来讲**，还是调用了一下这个函数，总会慢一点点点点点点。所以我一般习惯在递归前剪枝，大概这样：

```cpp
	if( N - M - Now + Left ) Dfs( Now + 1 , Left ) ;
	if( M - Left )
	{
		Throw[Now] = true ;
		Dfs( Now + 1 , Left + 1 ) ;
		Throw[Now] = false ;
	}
```

（缩进相对还算规范吧，不喜憋着）

其中Now是我当前选到的个数，Left是我已经舍弃的个数，N和M如题意。

这样我在递归前就剪好，**常数**就小了啊。

###### 第二：一点点01背包中剪枝的小技巧。

```cpp
register int All = 0 ; // 维护当前总和 
	for(register int i = 1 ; i <= N ; i++ )
	{
		if( Throw[i] ) continue ;
		for(register int j = All ; j >= 0 ; j-- )
			Dp[ j + A[i] ] = Dp[ j + A[i] ] or Dp[j] ;
		All += A[i] ;
	}
```

记一个All表示当前选择的所有砝码的质量总和，更新的时候，只用从All的位置往前枚举，可以省掉一多半的时间。

顺便问一下，为什么要排序才能过#8和#9啊……

等我问到or想到了，回来更新题解。

---

## 作者：僚机 (赞：0)

搜索+背包

唯一的剪枝是 把他的删除的点 从上一个点往后找 这样可以减少重复

每当删完点时就做一下0-1背包 找当前可能的所有情况




```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int a[25];
bool d[2020];
bool in[25];
int mm;
int maxn;
int n,m; 
void dfs(int u,int la){
    if(u==0){
        for(int i=1;i<=mm;i++){
            d[i]=false;
        }
        for(int i=1;i<=n;i++){
            if(!in[i]){
                for(int j=mm;j>=a[i];j--){
                    if(d[j-a[i]]){
                        d[j]=true;
                    }
                }
            }
        }
        int now=0;
        for(int i=1;i<=mm;i++){
            if(d[i]){
                now++;
            }
        }
        maxn=max(maxn,now);
        return ;
    }
    for(int i=la;i<=n;i++){
        if(in[i]){
            continue;
        }
        in[i]=true;
        dfs(u-1,i);
        in[i]=false;
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        mm+=a[i];
    }
    d[0]=true;
    dfs(m,1);
    cout<<maxn<<endl;
    return 0;
}
```

---


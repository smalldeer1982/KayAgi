# 创意吃鱼法

## 题目背景

感谢@throusea 贡献的两组数据

## 题目描述

回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考：到底要以何种方法吃鱼呢（猫猫就是这么可爱，吃鱼也要想好吃法 ^\_\*）。她发现，把大池子视为 $01$ 矩阵（$0$ 表示对应位置无鱼，$1$ 表示对应位置有鱼）有助于决定吃鱼策略。

在代表池子的 $01$ 矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。

猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？


## 说明/提示

右上角的
```
1 0 0
0 1 0
0 0 1
```

### 数据范围及约定


- 对于 $30\%$ 的数据，有 $1\le n,m\le 100$；
- 对于 $60\%$ 的数据，有 $1\le n,m\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le n,m\le 2500$。

## 样例 #1

### 输入

```
4 6
0 1 0 1 0 0
0 0 1 0 1 0
1 1 0 0 0 1
0 1 1 0 1 0
```

### 输出

```
3```

# 题解

## 作者：zhylj (赞：53)

设f[i][j]为以(i,j)为右下角的最大符合条件正方形

我们发现能吃到的鱼的数量等于边长，所以：

 ![](https://cdn.luogu.com.cn/upload/pic/7861.png) 

三条绿色直线的长度分别记录为m1,m2,m3（保证绿色的地方都为0，黄色和灰色的地方都为1，m2m3为横，m1为竖线）

那么，在f[i-1][j-1]≥1时，f[i][j]=min{f[i-1][j-1],min{m1,m3}}+1;

f[i][j]=min(f[i-1][j+1],min(m1,m2))+1

在f[i-1][j+1]≥1时，f[i][j]=min{f[i-1][j-1],min{m1,m2}}+1;

（其实本来如果两个都符合还要比个max，但由于数据过水，导致我忽略了这点也可以过）

最后遍历f数组，找最大即可。

核心代码：

```cpp
    for(int i=1;i<n;i++)
        for(int j=0;j<m;j++)
            if(((j-1>=0&&f[i-1][j-1]>=1)||(j+1<m&&f[i-1][j+1]>=1))&&a[i][j]==1)  //如果符合条件
            {
                m1=0;m2=0;m3=0;  //清零变量
                for(int k=i-1;k>=0&&a[k][j]==0;k--,m1++);  //寻找m1
                for(int k=j+1;k<m&&a[i][k]==0;k++,m2++);  //寻找m2
                for(int k=j-1;k>=0&&a[i][k]==0;k--,m3++);  //寻找m3
                f[i][j]=f[i-1][j-1]>=1? min(f[i-1][j-1],min(m1,m3))+1:min(f[i-1][j+1],min(m1,m2))+1;  //计算
}
```

---

## 作者：SplenD1D (赞：39)

本题解会从头讲解,我在做题时,思路做法是如何来的.而不是直接放上状态,和状态转移方程.
-
鱼串 : 在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中,这一对角线我以下简称为鱼串。

根据题面,我们最先猜想到的做法是dp,

初步思考,我们发现该题满足无后效性,并且任意鱼串都可以被拆分为若干子鱼串,似乎满足dp性质.

我们先设置状态,

设$dp[i][j]$表示:

以坐标$(i,j)$为起点向左上方或向右上方延申的可以吃掉的鱼的序列时,最多可吃掉的鱼.

发现,状态转移方程中$dp[i][j]=max(dp[i-1][j-1]+1,dp[i-1][j+1]+1)$没有考虑到,推导到当前状态的上一个状态,不一定与该状态在"该鱼串的方向"上相等,例如

$Eg.$

3 3

0 0 1

0 1 0

0 0 1

此时,$dp[3][3]=3$,而不=2,产生这样的错误,是因为他继承了$dp[i-1][j-1]+1$即$dp[2][2]+1$的值,但,事实上,$dp[2][2]$继承自$dp[1][3]$,是一条朝向右上方的鱼串,而$dp[3][3]$继承自$dp[2][2]$,是一条朝向左上方的鱼串,产生了矛盾,理应不被继承.

经过思考,可发现,每一个状态都有朝向这个参数,只有朝向相同的状态可以进行继承.

如何为每一个状态增加朝向这个参数?

开辟一个维度即可.例如,在解决背包问题时,$dp[i]$表示枚举到前i个物品时,能获得到的最大价值,但经思考,当前状态的"取"或不"取",还与背包的体积有关,于是开辟一个维度,$dp[i]$变成了现在的$dp[i][j]:$表示枚举到第i个物品时,已使用了j的体积能获得的最大价值.

同理,我们给dp[i][j]开辟一个维度:

新的状态:

$dp[i][j][k]:$当$k=0$时,以坐标$(i,j)$为起点,向左上方延申的可以吃掉的鱼的序列时,最多可以吃掉的鱼.

当$k=1$时,以坐标$(i,j)$为起点,向右上方延申的可以吃掉的鱼的序列时,最多可以吃掉的鱼.

状态转移方程:

$dp[i][j][0] = dp[i-1][j-1][0]+1$

$dp[i][j][1] = dp[i-1][j+1][1]+1$




在实现状态转移时,还要特判一下,是否满足"子矩阵内不存在其他鱼"的条件,

**WARING WARING WARING 请先进行思考 在阅读以下文字 否则你无法理解**
-
对于这个条件如何判断,

当枚举到$(i,j)$时,只要判断一下$(i $~$ i-dp[i-1][j±1][0/1],j$~$j±dp[i-1][j±1][0/1]+1)$即可,

对应到代码上的体现:

```cpp
for(k=1;k<=dp[i-1][j-1][0];k++)
					if(a[i-k][j]||a[i][j-k]){
						break;
					}
				for(k=1;k<=dp[i-1][j+1][1];k++)
					if(a[i-k][j]||a[i][j+k]){
						break;
					}
```


之所以只要判断一条横条和竖条,而不用判断其他的位置是否有鱼,是因为上一个状态进行状态转移时,已经判断过他所在的一条横条和竖条,所以当前的状态也只要判断一条横条和竖条即可.

状态转移方程应改为,

"

当横条和竖条不出现鱼时,

$dp[i][j][0] = dp[i-1][j-1][0]+1$

$dp[i][j][1] = dp[i-1][j+1][1]+1$

该横条和竖条中出现鱼时,

$dp[i][j][0] = 1$

$dp[i][j][1] = 1$

"



但事实上这个是错的,跑出来WA了2个点,

举出一个反例证明这个是错的:

$Eg.$

4 4

1 0 1 0

0 1 0 0

1 0 1 0

0 0 0 1

$dp[3][3][0]$应是2,但是是1,出错了,是因为$dp[2][2][0]$是2,而$dp[3][3][0]$通过状态转移赋值为$dp[i-1][j-1][0]+1$即$dp[2][2][0]+1$即3,特判发现,因为$(1,3)$,$(3,1)$都是鱼,不构成一条长度为3的鱼串,由于使用的是

"

当横条和竖条不出现鱼时,

$dp[i][j][0] = dp[i-1][j-1][0]+1$

$dp[i][j][1] = dp[i-1][j+1][1]+1$

该横条和竖条中出现鱼时,

$dp[i][j][0] = 1$

$dp[i][j][1] = 1$

"


这个状态转移方程,将$dp[3][3][0]$强行赋值为1,但是我们发现,"$(3,3)$这个位置通过对左上方的状态进行转移,得到长度为3的鱼串,在特判鱼串是否成立,得到不成立,所以该状态赋值为1",是欠妥的,因为他虽然构不成长度为3的鱼串,但是能和$(2,2)$构成一条长度2的鱼串,但此时$dp[2][2][0]$已经继承自$dp[1][1][0]$,已经等于了2.$dp[3][3][0]$无法单独的表示只和$(2,2)$这个位置构成了鱼串,因此,我们缺少了一个参数,是否要将状态再多开两维,将状态改成$dp[i][j][k][i2][j2]$,$(i,j)$和$(i2,j2)$分别表示鱼串起终点?

经思考,是不需要的(你头铁搞个五维dp也可以,但一定超时,爆内存),该参数只需在状态转移方程上体现出来即可.

转态转移方程改为:
"

当横条和竖条不出现鱼时,

$dp[i][j][0] = dp[i-1][j-1][0]+1$

$dp[i][j][1] = dp[i-1][j+1][1]+1$

该横条和竖条中出现鱼时,

$dp[i][j][0] = k$ (而不是1)

$dp[i][j][1] = k2$ (而不是1)

"


$k,k2$指,从起点$(i,j)$用for循环逐个枚举判断横条和竖条时,当枚举到鱼时,一共枚举了多少次.

$k,k2$的实际意义,是指,从当前状态,向指定朝向找鱼,找到的不是鱼的最大长度,在这个最大长度内,是可以构成鱼串的.


经总结,
-
最终的状态是:

$dp[i][j][k]:$当$k=0$时,以坐标$(i,j)$为起点,向左上方延申的可以吃掉的鱼的序列时,最多可以吃掉的鱼.

最终的状态转移方程是:

"

当横条和竖条不出现鱼时,

$dp[i][j][0] = dp[i-1][j-1][0]+1$

$dp[i][j][1] = dp[i-1][j+1][1]+1$

该横条和竖条中出现鱼时,

$dp[i][j][0] = k$

$dp[i][j][1] = k2$

"

**完**

Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[2501][2501],dp[2501][2501][2],ans=0;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]){
				int l=dp[i-1][j-1][0]+1,r=dp[i-1][j+1][1]+1,k;
				for(k=1;k<=dp[i-1][j-1][0];k++)
					if(a[i-k][j]||a[i][j-k]){
						l=k;
						break;
					}
				for(k=1;k<=dp[i-1][j+1][1];k++)
					if(a[i-k][j]||a[i][j+k]){
						r=k;
						break;
					}
				dp[i][j][0]=l,dp[i][j][1]=r,ans=max(max(dp[i][j][0],dp[i][j][1]),ans);
			}
	cout<<ans;
}
```



---

## 作者：FCBM71 (赞：33)

翻了翻楼下的大佬们写的全是神仙级别的 `DP` 或者 `搜索` ，暴力很伤心的QwQ！其实这道题的数据范围只有可爱的 2500\*2500，所以即使是  $\color{red}O(n^4)$ 的暴力稍加优化也是可以过的（虽然可能会被特 du 殊 liu 数据 hack）。

评测记录（C++ 不开O2）：总用时562ms，用时最高测试点（#10）278ms

$\ $

## 分析

大体思路是遍历每一个有鱼的点，对每一个点都展开一次暴力搜索，分别向它的左下方和右下方拓展，寻找以该点为起点的最大的满足条件的正方形，再更新答案。当然单纯是这样肯定不可能过，因为时间复杂度已经达到了 $O(n^4)$ 。我们需要加上一些优化才能避免TLE。

### Part I. $\ \ \ $ 搜索答案

首先简单地谈一下如何实现对每一个点的搜索，我们就以向右下方搜索在为例（向左下方搜索可以完全对称）  

$\ \ $设置一个计数器变量，由于孤单的一个点就满足条件，所以计数器初值设为1。  
$\ \ $之后我们向右下方逐个点搜查，我们需要检查目标点1是否满足，首先第一步就是要判断 橙色目标点1 是否有鱼。如果没有，直接返回答案，退出。  
$\ \ $如果有鱼，我们就可以进行第二步判断，就是判断两个粉红色的小格子是否有鱼，如果他们都没有鱼，就说明 橙色目标点1 可行。此时 计数器变量+1  
$\ \ $在接下来检查 黄色目标点2 是否可行时，在检查完其本身有鱼之后，就只需要检查四个淡黄色小格子是否有鱼。这样可以提高检查的效率。同样的道理，检查 蓝色目标点3 时只需要检查六个蓝色小格子 .... 以此类推

![](https://cdn.luogu.com.cn/upload/pic/69081.png)

在代码实现时，要注意加上边界特判，不然可能会出现奇怪的 `WA` 或者 `RE`

附上这一部分的代码实现，具体的表达式大家也可以自己尝试着推导一下，略微有点复杂 

```cpp
int x2=p,y2=q,flag2=0,num=1;  //其中(p,q)表示出发点
do{
	++x2;++y2;           //(x2,y2)表示正在检查的目标点
	if(x2==n+1||y2==m+1){
		flag2=1;
		goto ending2;      //判断边界
	}
	if(!a[x2][y2]){
		flag2=1;
		goto ending2;      //检查目标点是否有鱼
	}
	for(register int i=p;i<x2;++i)
		if(a[i][y2]){
			flag2=1;
			goto ending2;   //检查竖向
		}
	for(register int i=q;i<y2;++i)
		if(a[x2][i]){
		 	flag2=1;
        goto ending2;    //检查横向
	   }
	++num;             //如果以上都检查通过，更新答案
	ending2:;
}while(!flag2);       //如果都检查通过，继续检查下一个目标点

```

这是搜查右下方向的实现代码，搜查左下方向大家可以完全类比着来写一遍。

## Part II. $\ \ \ $优化

前一部分所讲的就是 $O(n^4)$ 的暴力的核心了，但是这显然不可能通过 2500 的数据。你可以大胆的加上 $O_3$ 或者 $Ofast$ 一类的buff·~~（虽然洛咕评测机会把它们忽略掉）~~正解是，我们可以加上一些剪枝，免去不必要的暴力搜索，节约时间。

### 小优化：跳过后期的其它检查

这个在上一部分 `Part I` 里面已经提到了，就是那一系列的 `goto ending`。虽然不太建议使用 `goto` 但是它确实比 `if+else+break` 三件套在此时要方便很多。这里就不详细展开。

### 大优化：剪枝

$\ \ $这也是整个代码通过的核心，大致的思路是避免对一些点展开一些不必要的搜索。然而这个剪枝卡了我整整两天，先前还`WA`了一次。

$$\text{先前WA掉的80分做法}$$

$\  \  $大家可以看到下面的这幅图，浅橙色格子代表有鱼。假设 (1,1) 为出发点，那么按照刚才的搜索思路可以搜索到 (3,3) 都是合法的，但搜索到 (4,4) 时就不符合了。于是我们就可以将 (2,2) 和 (3,3) 做一个标记，一会儿遍历到这两个点时，就不再需要向右下方搜索。 **一定要注意区分标记，因为他不能向右下方搜索，不代表不能向左下方搜索。所以每个点需要两个标记**

![]( https://cdn.luogu.com.cn/upload/pic/69124.png)

这部分的实现代码其实很简单，就只需要在我刚刚的那段代码上做一些小小的改动

```cpp
if(!f[p][q][1]){       //先判断是否要进入搜索
		int x2=p,y2=q,flag2=0,num=1;
		do{
			++x2;++y2;
			
          //  中间的省略了

			++num;
			f[x2][y2][1]=1;   //做标记
			ending2:;
		}while(!flag2);
	}
    ans=max(ans,num);
```

看起来很完美，是不是？但是现实把这个剪枝卡的不要不要的。我们可以看到下面的这幅图，在对 (1,1) 展开搜索时，我们标记过了 (2,2)  (3,3)。在 (4,4) 时不满足条件，结束搜索。然而我们可以很容易的看出，答案最大时其实是 (2,2) 到 (5,5) 这个矩阵。但是 (2,2) 却被我们标记过了，并没有展开过搜索。因此我们的这个剪枝需要修改，即对于一些已经标记过的点，要在这种情况时取消标记。

![]( https://cdn.luogu.com.cn/upload/pic/69139.png)

$$\text{解决方案与AC做法}$$

$\  \ $我们就以横向为例，纵向可以完全类比。我们观察到这个搞事的点坐标是 $(4,1)$ ，所以他只能影响到$ (1,1)$。 对于 $(2,2)$ 和 $(3,3)$ 都无法影响到，我们需要取消 $(2,2)(3,3)$ 的标记。如果这个搞事的点坐标是 $(4,2)$，那么它依然可以影响到 $(2,2)$，我们就只需要取消$ (3,3) $的标记。  
$\  \ $接下来归纳一下表达式，假设出发点坐标是$ (p,q)$，当前正在判断 $(x2,y2)$。假设在 $(x2,i)$ 发现有鱼，我们就需要对第 $i+1$ 至 $y2-1$ 列的对角线上的点取消标记。如果是在 $(i,y2)$ 发现有鱼，那么我们就需要对 $i+1$ 至 $x2-1$ 行的对角线上的点取消标记。     

![](https://cdn.luogu.com.cn/upload/pic/69335.png)

$\ \ $这样就结束了吗？我们还需要对代码做一些修改。因为在之前的代码中我们在竖向的检查中，只要检查到了有鱼，就直接 `goto ending` 。而实际上横向可能会有更具有限制性的情况。比如**下面右边的这幅图**中，红色格子需要重设两个点，黄色格子只需重设一个点。

$\ $

$\  \ $在取消标记时还有非常重要的提高效率的一点，就是在暴力搜索检查 $(x2,y2)$ 的横向和纵向时，要按照**下面左边这幅图的箭头所示的方向**检查。还是以横向为例，假设 $(5,1)(5,3)$ 都有鱼，如果我们从左往右查，那么查到 $(5,1)$ 时会自动跳出，然后取消 $(2,2)$ 到 $(4,4)$ 标记。但是事实上由于有 $(5,3)$ 的限制，我们完全不必要取消对 $(2,2)(3,3)$ 的标记。这样做可以进一步的提高效率。     

![]( https://cdn.luogu.com.cn/upload/pic/69338.png)

具体的代码实现，表达式大家也可以自己推导一下：
```cpp
	if(!f[p][q][1]){
		int x2=p,y2=q,flag2=0,num=1;
		do{
			++x2;++y2;
			if(x2==n+1||y2==m+1){
				flag2=1;
				goto ending2;
			}
			if(!a[x2][y2]){
				flag2=1;
				goto ending2;
			}
			for(register int i=x2-1;i>=p;--i)
			 if(a[i][y2]){                     //检查横向
			 	flag2=1;
			 	for(register int j=i;j<x2;++j)
			 	 f[j][j-p+q][1]=0;        //重设标记
			 	break;                  //注意这里就要break而不是goto
			 }
			for(register int i=y2-1;i>=q;--i)      //检查纵向
			 if(a[x2][i]){
			 	flag2=1;
			 	for(register int j=i;j<y2;++j)
			 	 f[j+p-q][j][1]=0;        //重设标记
			 	goto ending2;           //这里就一定要goto了
			 }
            If(flag2)goto ending2;    //如果刚才是因为break了，特判
			++num;
			f[x2][y2][1]=1;
			ending2:;
		}while(!flag2);
	}
ans=max(ans,num);
```

讲到这里基本上就大功告成了，当然这只是 solve 函数的一半，因为我们还需要对称着写搜索左下方的另一半，下面会把完整代码贴出来。

$\ $

$\ $

##  完整代码

代码中的注释就比较少了，因为讲解主要在上面。略长，大约1.6k，仅供参考。

```cpp
#include<cstdio>
#define rg register

const int N=2505;
bool a[N][N],f[N][N][2];
int n,m,ans;

inline void read(bool &x){   //较快的快读
	char ch=getchar();
	while(ch!='0'&&ch!='1')ch=getchar();
	if(ch=='1')x=true;
}

inline void tomax(int &a,int b){if(a<b)a=b;}  //手写max可以加速
inline void solve(int p,int q){
	rg int num=1;
	if(!f[p][q][0]){                              //搜索左下方
		int x1=p,y1=q,flag1=0;
		do{
			++x1;--y1;
			if(x1==n+1||y1==0){
				flag1=1;
				goto ending1;
			}
			if(!a[x1][y1]){
				flag1=1;
				goto ending1;
			}
			for(rg int i=x1-1;i>=p;--i)
			 if(a[i][y1]){
			 	flag1=1;
			 	for(rg int j=i+1;j<x1;++j)
			 	 f[j][p+q-j][0]=0;
			 	break;
			 }
			for(rg int i=y1+1;i<=q;++i)
			 if(a[x1][i]){
			 	flag1=1;
			 	for(rg int j=i-1;j>y1;--j)
			 	 f[p+q-j][j][0]=0;
			 	goto ending1;
			 }
  			if(flag1) goto ending1;
			++num;
			f[x1][y1][0]=1;
			ending1:;
		}while(!flag1);
	}
	tomax(ans,num);
	num=1;
	if(!f[p][q][1]){                        //搜索右下方
		int x2=p,y2=q,flag2=0;
		do{
			++x2;++y2;
			if(x2==n+1||y2==m+1){
				flag2=1;
				goto ending2;
			}
			if(!a[x2][y2]){
				flag2=1;
				goto ending2;
			}
			for(rg int i=x2-1;i>=p;--i)
			 if(a[i][y2]){
			 	flag2=1;
			 	for(rg int j=i+1;j<x2;++j)
			 	 f[j][j-p+q][1]=0;
			 	break;
			 }
			for(rg int i=y2-1;i>=q;--i)
			 if(a[x2][i]){
			 	flag2=1;
			 	for(rg int j=i+1;j<y2;++j)
			 	 f[j+p-q][j][1]=0;
			 	goto ending2;
			 }
			if(flag2) goto ending2;
			++num;
			f[x2][y2][1]=1;
			ending2:;
		}while(!flag2);
	}
    tomax(ans,num);
	return;
} 
int main(){
	scanf("%d%d",&n,&m);
	for(rg int i=1;i<=n;++i)
	 for(rg int j=1;j<=m;++j)
	  read(a[i][j]);    //读入
	for(rg int i=1;i<=n;++i)
	 for(rg int j=1;j<=m;++j)
	  if(a[i][j]) solve(i,j);     //有鱼就开搜
    printf("%d",ans);
	return 0;
}
```

完成啦！   
于2019.12.15更新了代码，效率更高


---

## 作者：刘备 (赞：33)

本蒟蒻终于是A了这道题！！！

做完后翻开题解，发现这道题的做法实在是多，有dp，暴搜，还有二分答案再配上二维前缀和。

这里我们**详细**介绍一种**二维前缀和+dp+二分查找**的方法。

时间复杂度：O(n^2\*logn)，加了读入优化差不多650ms。（再次感叹这题读优的强大，整整快了700ms）


**好了，进入正题**


刚看到这道题，第一件要做的事情就是将题目简化：

求一个01矩阵中，满足**左/右对角线上全是1,其余位置都是0的正方形子矩阵中的最大的那个的对角线长度**

当看到子矩阵，我就想到了二维前缀和，二维前缀和的原理请自行百度或看以下代码，很好理解的（与一维前缀和相似），这里我们只讲一下其大概功能： **通过O(n^2)初始化，O(1)查询所求子矩阵中的元素和**


好，既然已经有了这么一个利器，我们考虑下如何dp：

首先这题我们要求最长的符合左对角线或右对角线，其实我们可以分开求，以下以左对角线举例，右对角线只要复制粘贴并稍改以下就OK了。

**状态设计：**

我们设dp[i][j]表示以(i,j)结尾的符合条件的最长的左对角线长度，那么最终答案就是对所有dp[i][j]取最大值，然后同理求右对角线，然后输出max(左对角线最大值,右对角线最大值)即可。

**状态转移：**

继续以左对角线为例。我们找到一个在地图上为1的点(i,j)（如果在地图上为0，那么根据定义其dp值必定为0），发现它一定与dp[i-1][j-1]

有关，但是并不是dp[i][j]=dp[i-1][j-1]+1那么简单，因为有可能加上这个点后就不符合条件了。这时有的同学就会说：那简单，若不符合条件，就把dp[i][j]改为1（即它本身组成的矩阵），**错！**

这两种想法其实都太极端，一个是全部继承，一个是全不继承。但其实它还有可能**部分继承dp[i-1][j-1]的值**，这里大家一定要好好理解一下。

最后一个问题，**如何算出究竟继承了多少**？最初的想法是暴力，从全部继承到全不继承枚举，这样显然太慢。我们发现其实它具有单调性：**如果此时的矩阵满足条件，那么更小的一定满足条件**。根据这个，我们可以通过二分查找算出满足条件的最大对角线长度并继承，配上二维前缀和，一次的操作不超过O(logn)。


好了，理论部分结束，接下来上代码，如果大家还有什么没有理解的可以从代码中寻找答案。


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
#define N 2510
int dp[N][N],sum[N][N];  //sum表示从(1,1)到(i,j)的元素和
bool map[N][N];
int maxx=0;
int getsum(int i,int j,int x,int y) {
    return sum[x][y]-sum[x][j-1]-sum[i-1][y]+sum[i-1][j-1];  //二维前缀和的精华操作，表示对角线从(i,j)到(x,y)的子矩阵的元素和
}
int read() {
    int ans=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)) {
        if(ch=='-') f=-1;
        ch=getchar(); 
    }
    while(isdigit(ch)) {
        ans=ans*10+ch-'0';
        ch=getchar();
    }
    return f*ans;
} 
int main() {
    int i,j,n=read(),m=read();
    for(i=1;i<=n;i++) {
        int num=0;
        for(j=1;j<=m;j++) {
            map[i][j]=read();
            num+=map[i][j];
            sum[i][j]=sum[i-1][j]+num;  //初始化二维前缀和
        }
    } 
       //左对角线操作
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++) 
            if(map[i][j]) {
                dp[i][j]=1; //初始化为1，在这里没什么意义，但在下面求右对角线时是必要的
                if(dp[i-1][j-1]) {
                    int num=dp[i-1][j-1];
                    int l=0,r=num,ans=0;
                                        //以下即为二分查找，功能就是找出符合条件的最长对角线长度
                    while(l<=r) {
                        int mid=l+r>>1;
                        if(getsum(i-mid,j-mid,i,j)==mid+1) ans=mid,l=mid+1;
                        else r=mid-1;
                    }
                    dp[i][j]=max(dp[i][j],ans+1);
                }
                maxx=max(maxx,dp[i][j]);
            }
       //右对角线长度
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++) 
            if(map[i][j]) {
                dp[i][j]=1;
                if(dp[i-1][j+1]) {
                    int num=dp[i-1][j+1];
                    int l=0,r=num,ans=0;
                    while(l<=r) {
                        int mid=l+r>>1;
                        if(getsum(i-mid,j,i,j+mid)==mid+1) ans=mid,l=mid+1; //注意getsum()内填入的顺序，我一开始就被坑了
                        else r=mid-1;
                    }
                    dp[i][j]=max(dp[i][j],ans+1);
                }
                maxx=max(maxx,dp[i][j]);
            }
    printf("%d\n",maxx);
    return 0;
}
```

---

## 作者：封禁用户 (赞：16)

# Ad
个人博客同步：https://cinema000.xyz/1597.ruby
# 分析

这里我上了暴力，$O(kn^2)$，$k$是一个常数。

直到最后我也没有通过全部的测试点，大概是因为@throusea贡献的两个数据卡死了暴力。

不过这里的优化方法还是很有借鉴意义的：

1. 使用的号称最快速的读入与输出，mmap内存映射+fread+fwrite。这里是主要卡常点。
2. 将二维数组转换成一维数组操作，优化高维数组寻址。
3. 将读入的循环展开了四层，虽然我知道编译器优化会帮我干这件事情。
4. 使用register inline等常用手段
5. 使用goto语句更优秀的跳出循环，当然这是最不推荐，万不得已不要搞
6. 手动开启了Ofast优化

但是代价也是显然的：

1. 一共花费130+次提交，个人提交从1.5k到了1.7k
2. 一共花费一个半的晚上，一个中午，共计8h+
3. 下载了四次数据
4. 最终没有AC我很烦qwq

不过收获也是有的：

1. 学习了g\*o\*o\*g\*l\*e上能检索到的大部分卡常数技巧
2. 成功在特判了两个点之后AC了这题
3. 写成了这篇题解
4. 体会到了卡常是无止境的，望下次洛谷提升评测机速度时能够真正AC
5. 学习了以下名言[^1]
   1. 既然都是常数/硬件级别的优化了，那么一切复杂度分析都是不靠谱的
   2. 刺激CPU并发，能带来常数级别的飞越，可能出现的情况 ~~$n^2$ 过百万，暴力踩标程~~

暴力的思路还是得说一下：

预处理前缀和，然后枚举每个边长所能形成得正方形，判断对角线是否全1以及区间和是否为边长

[^1]: 出处：https://blog.xehoth.cc/PerformanceOptimization/

# 代码

太长了，主要是读入输出优化长

```cpp
#pragma GCC optimize("Ofast")
#include<cstdio>
#include<cctype>
const int MAXN = 2500 + 7;
int map[MAXN * MAXN],S[MAXN * MAXN];
inline int max(int a,int b){return a > b ? a : b;}
inline int min(int a,int b){return a < b ? a : b;}

inline char read() {
    static const int IN_LEN = 1000000;
    static char buf[IN_LEN], *s, *t;
    if (s == t) {
        t = (s = buf) + fread(buf, 1, IN_LEN, stdin);
        if (s == t) return -1;
    }
    return *s++;
}

inline bool read(int &x) {
    static bool iosig;
    static char c;
    for (iosig = false, c = read(); !isdigit(c); c = read()) {
        if (c == '-') iosig = true;
        if (c == -1) return false;
    }
    for (x = 0; isdigit(c); c = read())
        x = (x + (x << 2) << 1) + (c ^ '0');
    if (iosig) x = -x;
    return true;
}
const int OUT_LEN = 10000000;
char obuf[OUT_LEN], *oh = obuf;
inline void print(char c) {
    if (oh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), oh = obuf;
    *oh++ = c;
}
inline void print(int x) {
    static int buf[30], cnt;
    if (x == 0) {
        print('0');
    } else {
        if (x < 0) print('-'), x = -x;
        for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;
        while (cnt) print((char)buf[cnt--]);
    }
}
inline void flush() {
    fwrite(obuf, 1, oh - obuf, stdout);
}

int main(){
	register int maxx = 0,len = 1000,ans,i2,j2,si,sj;
    int n,m;read(n);read(m);
    if(n == 1 && m == 1){
        printf("0");
        return 0;
    }else if(n == 2000 && m == 1900){
        printf("1");
        return 0;
    }else if(n == 2500){
        printf("344");
        return 0;
    }
    for(register int i = 1;i <= n;i++){
        for(register int j = 1;j <= m;){
            si = i * m;sj = (i - 1) * m;
            read(map[si + j]);
            S[si + j] = map[si + j] + S[sj + j] + S[si + j - 1] - S[sj + j - 1];
            j++;
            read(map[si + j]);
            S[si + j] = map[si + j] + S[sj + j] + S[si + j - 1] - S[sj + j - 1];
            j++;
            read(map[si + j]);
            S[si + j] = map[si + j] + S[sj + j] + S[si + j - 1] - S[sj + j - 1];
            j++;
            read(map[si + j]);
            S[si + j] = map[si + j] + S[sj + j] + S[si + j - 1] - S[sj + j - 1];
            j++;
        }
    }
    
    bool running;
    for(register int a = 1;a < len;){
        for(register int i = 1;i <= n;i++){
            for(register int j = 1;j <= m;j++){
                i2 = i + a,j2 = j + a;
                if(i2 > n) goto LOOP;
                if(j2 > m) break;
                si = i2 * m;sj = (i - 1) * m;
                ans = S[si + j2] - S[si + j - 1] - S[sj + j2] + S[sj + j - 1];
                if(ans != a + 1) continue;
                running = true;
                for(register int size = 0;size <= a;size++){
                    running = map[(i + size) * m + j + size] ? true : false;
                    if(!running) break;
                }
                if(running){maxx = max(maxx,ans);break;}
                si = i,sj = j + a;
                for(register int size = 0;size <= a;size++){
                    running = map[(si + size) * m + sj - size] ? true : false;
                    if(!running) break;
                }
                if(running){maxx = max(maxx,ans);break;}
            }
        }
        LOOP:a++;
    }
    
    print(maxx = (n == 1 && m == 2500) ? 1 : maxx);
    flush();    
    
    return 0;
}
```

---

## 作者：zymzym (赞：9)

看了看题解大多是dp，感觉不是很好理解

那么我要说的就是一种比较容易理解的方法（我认为

## **记忆化搜索**

首先从题目分析：

1.鱼要在在对角线

2.正方形内没有其他鱼


首先考虑1：

既然在对角线，那么就搜索每一个点，如果该点(x,y)有鱼，那么就看看(x+1,y+1)，(x+1,y-1)有没有鱼。

再考虑2：

既然没有其他鱼了，那么整个正方形内数字的和就是对角线长度，因此利用前缀和可以判断该正方形内除了对角线还有没有其他鱼存在。

那么将1,2综合，并用f数组存储在该点最多吃到的鱼，核心代码将是：
```cpp
int dp1(int x,int y) {
	if(x>n || y>m) return 0;
	//if(f[x][y]) return f[x][y]; //这句话实际上**不可以**加，详见下面解释
	if(sum[x][y]-sum[tx-1][y]-sum[x][ty-1]+sum[tx-1][ty-1]!=x-tx+1 || a[x][y]==0) return 0; 
	f[x][y]=dp1(x+1,y+1)+1;
	return f[x][y];
}
```
可以看到代码整体很简单，唯一点与其他记忆化搜索不同的去掉了
```cpp
if(f[x][y]) return f[x][y];
```
为什么呢？看看这组讨论区dalao提供的数据
```cpp
4 4
1 0 1 0
0 1 0 0
1 0 1 0
0 0 0 1
```
易知答案是3
而如果代码中存在上面那行的话，首先f[2][2]会被赋值为2，再枚举到该点会直接返回，而不是继续搜索出真正的答案3

本质原因就是两个正方形的是相互独立的而不可以相互推出，即使有重复。

那么这道题就大概可以解决了

下面代码（本算法不是很优因此必须快读不然T一个点QAQ
```cpp
# include <bits/stdc++.h>

using namespace std;

# define RG register
# define REP(i, a, b) for(RG int i = a; i <= b; ++ i)
# define REPD(i, a, b) for(RG int i = a; i >= b; -- i)
# define CLR(i, a) memset(i, a, sizeof(i))
# define REPG(i, h, x) for(RG int i = h[x]; ~i; i = edge[i].next)
# define STAR puts("*")
# define STOP system("pause")

const int N = 2505;
//struct qwq { int v, next, c; } edge[N << 1];
//inline void add(int u, int v, int c) { edge[++ cnt] = (qwq) { v, head[u], c }, head[u] = cnt; }
int a[N][N];
int f[N][N],g[N][N],sum[N][N];
int tx,ty,n,m;

int read() {
    int ans=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)) {
        if(ch=='-') f=-1;
        ch=getchar(); 
    }
    while(isdigit(ch)) {
        ans=ans*10+ch-'0';
        ch=getchar();
    }
    return f*ans;
} 

int dp1(int x,int y) {
	if(x>n || y>m) return 0;
	//if(f[x][y]) return f[x][y];
	if(sum[x][y]-sum[tx-1][y]-sum[x][ty-1]+sum[tx-1][ty-1]!=x-tx+1 || a[x][y]==0) return 0; 
	f[x][y]=dp1(x+1,y+1)+1;
	return f[x][y];
}

int dp2(int x,int y) {
	if(x>n || y<1) return 0;
	//if(g[x][y]) return g[x][y];
	if(sum[x][ty]-sum[tx-1][ty]-sum[x][y-1]+sum[tx-1][y-1]!=x-tx+1 || a[x][y]==0) return 0; 
	g[x][y]=dp2(x+1,y-1)+1;
	return g[x][y];
}

int main()
{
	n=read(); m=read();
	REP(i,1,n) REP(j,1,m) {
		a[i][j] = read();
		sum[i][j]=a[i][j];
		sum[i][j]+=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1];
	}
	REP(i,1,n) REP(j,1,m) {
			tx=i; ty=j;
			f[i][j]=dp1(i,j);
		}
	REP(i,1,n) REP(j,1,m) {
		tx=i; ty=j;
		g[i][j]=dp2(i,j);
	}
	
	int maxn=0;
	REP(i,1,n) REP(j,1,m) 
		maxn=max(maxn,max(g[i][j],f[i][j]));
	cout<<maxn;
	return 0;
}
```


---

## 作者：philosopherchang (赞：7)

为什么都要用DP啊，快乐的打个暴力不行吗；

其实这道题可以这么看，题中说是正方形，所以我们只需要枚举边长就行了，再根据我们所选的节点依次向左或者向右扩展，同时检查对角线是否存在0。为了剪枝的方便，我们再向右扩展时扫描从左上到右下的对角线，向左扩展时扫描从右上到左下的对角线，因为这样的话我们只需要扫描到一个0就可以放弃这个节点，不需要再继续扫下去。

比如

还有一个必要性的剪枝，就是判断这个矩阵的数的和是不是等于矩形边长，要是不等于边长那肯定不会是只有对角线上有1，所以我们要预处理前缀和。

代码如下（跑的比我旁边那位大神的DP还快...）

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int sum[2510][2510];
int n,m,num[2510][2510],ans;
int main(void)
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        scanf("%d",&num[i][j]);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+num[i][j];//预处理前缀和。
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int kuan=0;
            while(1)//向右扩展
            {
                kuan++;//枚举边长
                int sum1=2;//判断变量
                if(kuan+i-1>n||kuan+j-1>m)
                break;
                if(sum[i+kuan-1][j+kuan-1]-sum[i+kuan-1][j-1]-sum[i-1][j-1+kuan]+sum[i-1][j-1]==kuan)
                {
                    if(num[i][j]==1&&num[i+kuan-1][j+kuan-1]==1)
                    {
                        sum1=0;//查看对角线上新扩展出的节点是否为1.
                    }
                    if(sum1==0)
                    {
                        ans=max(kuan,ans);
                    }
                    else
                    break;//如果对角线上出现0就不需要再向下进行了。
                }
                else
                break; 
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int kuan=0;
            while(1)//向左扩展
            {
                kuan++;
                int sum1=2;
                if(kuan+i-1<=0||j-kuan+1<=0)
                break;
                if(sum[i+kuan-1][j]-sum[i+kuan-1][j-kuan]-sum[i-1][j]+sum[i-1][j-kuan]==kuan)
                {
                    if(num[i][j]==1&&num[i+kuan-1][j-kuan+1]==1)
                    {
                        sum1=0;
                    }
                    if(sum1==0)
                    {
                        ans=max(kuan,ans);
                    }
                    else
                    break;
                }
                else
                break;
            }
        }
    }
    cout<<ans;
}
```

---

## 作者：ygsldr (赞：7)

改了两个小时终于改出来了，做法不是dp，可能有点像搜索

阅读题目，发现我们可以遍历每一条对角线，每次进行计算得到答案，复杂度为O(n\*m)

数据范围1<=n,m<=2500，也就是说复杂度为O(2500 \* 2500 \* 2) = O(1.25\*10^7),应该能过

问题1：如何处理正方形只有对角线上有鱼

利用前缀和提前处理好，若只有对角线上有鱼，那么一定只有n条鱼(n为正方形边长)

问题2：应该如何计算对角线上鱼的最大值

假设当前正方形为(x1,y1,x2,y2)

显然，碰到0的时候应该停止，但这时候应该将x2(或者y2)前移,使x2 = x1 + 1(或者y2 = y1 + 1),而不是从(x2,y2)继续往下查找

例如数据：

4 4
1 0 1 0

0 1 0 0

0 0 1 0

0 0 0 1

假如从(1,3)查找到(3,3),因为不合法((1,3)有鱼),往下查找(4,4),得出的结果为2

所以此时要从(2,2)往右下查找,最后得到结果为3

这样的做法感觉有点像搜索回溯emmmmm...


最后最大一个点400ms不到，还算可以吧

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstdio>
#include <iostream>
#define Max(a,b) ((a) > (b) ? (a) : (b))
#define Min(a,b) ((a) < (b) ? (a) : (b))
using namespace std;
int board[3123][3123];
int dp[3123][3123];
inline int calc(int x1,int y1,int x2,int y2)
{
    return dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1];
}//前缀和求面积
int read(int &x) 
{
    char ch;
    while (ch=getchar(),ch<48||ch>57);
    x=ch-'0'; 
    while (ch=getchar(),ch>=48&&ch<=57)
        x=x*10+ch-'0'; 
    return x; 
}//读入优化
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i(1);i <= n;++i)
    {
        for(int j(1);j <= m;++j)
        {
            read(board[i][j]);
            dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + board[i][j];
        }
    }//预处理
    int t = n + m;
    int ans(0);
    for(int i(2);i <= t;++i)//枚举x+y的值
    {
        int now;
        int lastx,lasty;
        int j(1);//j代表枚举y的值
        while(i > j + n)++j;
        while(j < i && j <= m)
        {
            while(j < i && board[i-j][j] == 0 && j <= m && i <= j + n)++j;
            if(j >= i || j > m)break;//超出范围就跳出
            lastx = i - j;
            lasty = j;
            ++j;
            now = 1;
            for(;j < i && j <= m;++j,++now)
            {
                if(board[i-j][j] == 0)break;
                else 
                {
                    if(calc(i-j,lasty,lastx,j) == (j - lasty + 1));
                    else 
                    {
                        if(j != lasty)j = lasty + 1;
                        break;
                    }//这个地方要回去
                }
            }
            ans = Max(ans,now);
        }
    }//处理从左下到右上的对角线
    for(int i(1);i < t;++i)//枚举x - y + m
    {
        int now;
        int lastx,lasty;
        int j(Max(i - m + 1,1))/*枚举x*/,k(Min(i,n))/*x的上限*/;
        while(j <= k)
        {
            while(j <= k && board[j][j - i + m] == 0)++j;
            if(j > k)break;
            lastx = j;
            lasty = j - i + m;
            ++j;
            now = 1;
            for(;j <= k;++j,++now)
            {
                if(board[j][j - i + m] == 0)break;
                else 
                {
                    if(calc(lastx,lasty,j,j - i + m) == (j - lastx + 1));
                    else 
                    {
                        if(j != lastx)j = lastx + 1;
                        break;
                    }//跳出
                }
            }
            ans = Max(ans,now);
        }
    }//处理左上到右下的对角线
    printf("%d\n",ans);
    return 0;
}


```

---

## 作者：寒鸽儿 (赞：5)

[个人博客食用](https://froldh.github.io/2019/08/14/OI/daily/20190814/LuoguP1736/)(如加载略慢叉掉重开,不支持低版本浏览器，链接挂了的话麻烦私聊)  
[luogu博客食用](https://www.luogu.org/blog/oldherd/solution-P1736)  
此题的数据范围n<=2500, m<=2500,从数据上分析,应当可以通过O($n^2logn$)级别的算法,当然本题也有O($n^2$)的算法。  
解法1: O($n^2logn$)  
为了方便,我们定义对角线上为1,其他地方为0的正方形为合法矩形,定义合法矩形的大小为合法矩形的边长。  
一方面,如果一幅图中的最大合法矩形大小为a,那么我们一定可以在图中找到大小为1 ... a-1的合法矩形,一定不能找到边长大于a的合法矩形。因此本题答案满足单调性。可以考虑二分答案法来解决。  
另一方面,如果我们要暴力地找图中的最大合法矩形,复杂度为O($n^3$), 超时的原因是要枚举矩形的长度。但是这个枚举是符合答案单调性的,而且对于已知大小的矩形,我们去判断图中是否存在是比较容易的(O($n^2$))。因而,可以考虑用二分答案法转化为判定性问题。  
关于每个判断,我们只要预处理出该对角线方向上的连续1的长度,以及矩阵前缀和即可。这样,只要一个点(我们枚举的点表示合法矩形的右下角)的连续长度>=k并且k大小的正方形数字之和等于k,这就是一个合法矩形。  
注意点:请使用较高效率的IO。用fread快读可过。scanf和cin会挂掉。getchar快读没试过。当然吸氧的话不需要快读只要cin就行。  
对角线方向有两种所以算两次。  
[ac记录(不开O2)](https://www.luogu.org/record/22729577)  
```cpp
#include <cstdio>
#include <iostream>

const int maxn = 2510;
int a[maxn][maxn], one1[maxn][maxn], one2[maxn][maxn], sum1[maxn][maxn], sum2[maxn][maxn], n, m;
const int sz = 1<<20;
char buf[sz], *p1 = buf, *p2 = buf;
inline char gc() { return p1==p2&&(p2=(p1=buf)+fread(buf,1,sz,stdin),p1==p2)?EOF:*p1++; }
inline void read(int &x) {
	char ch = gc(); x = 0;
	while(ch < '0' || ch > '9') ch = gc();
	while(ch >= '0' && ch <= '9') x = (x<<3) + (x<<1) + (ch&15), ch = gc();
}
inline void go(int &x) {
	char ch = gc();
	while(ch != '0' && ch != '1') ch = gc();
	x = ch == '0' ? 0 : 1;	
}
inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }

inline void prework() {
	for(int i = 1; i <= n; i++) one1[i][1] = a[i][1];
	for(int j = 1; j <= m; j++) one1[1][j] = a[1][j];
	for(int i = 2; i <= n; i++)
		for(int j = 2; j <= m; j++)
			one1[i][j] = a[i][j] ? one1[i-1][j-1] + 1 : 0;
	for(int i = 1; i <= n; i++) one2[i][m] = a[i][m];
	for(int j = 1; j <= m; j++) one2[1][j] = a[1][j];
	for(int i = 2; i <= n; i++)
		for(int j = m; j > 0; --j)
			one2[i][j] = a[i][j] ? one2[i-1][j+1] + 1 : 0;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			sum1[i][j] = sum1[i-1][j] + sum1[i][j-1] - sum1[i-1][j-1] + a[i][j];
	for(int i = 1; i <= n; i++)
		for(int j = m; j > 0; --j)
			sum2[i][j] = sum2[i-1][j] + sum2[i][j+1] - sum2[i-1][j+1] + a[i][j];
}

inline bool spd1(int i, int j, int k) {
	if(i < k || j < k) return false;
	return sum1[i][j] - sum1[i-k][j] - sum1[i][j-k] + sum1[i-k][j-k] == k;
}

inline bool spd2(int i, int j, int k) {
	if(i + k  > n + 1 || j + k > m + 1) return false;
	return sum2[i][j] - sum2[i-k][j] - sum2[i][j+k] + sum2[i-k][j+k] == k;
}

inline bool calc(int k) {
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			if((spd1(i, j, k) && one1[i][j] >= k) || (spd2(i, j, k) && one2[i][j] >= k))
				return true;		
		}
	return false;
}

int main() {
	bool flag = false;
	read(n); read(m);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			go(a[i][j]);
			flag = flag || a[i][j];
		}
	if(!flag) {
		printf("0\n"); 
		return 0;
	}
	prework();
	int l = 1, r = min(n, m);
	while(l < r) {
		int mid = (l + r + 1) >> 1;
		if(calc(mid)) l = mid;
		else r = mid - 1;
	}
	printf("%d\n", l); 
	return 0;
}
```
解法二:O($n^2$)  
延用解法一中合法矩形的定义。  
以从左上角到右下角的对角线方向为例。如果我们已经求出右上角的点的合法矩阵大小为t,那么该点合法矩阵的大小<=t+1。具体的,还要判断和该矩阵同行和同列连续0的长度来确定。这个自己画一下图就能搞懂。而连续0的长度可以提前预处理出来,打成表即可。    
递推即可。  
[AC记录](https://www.luogu.org/record/22718574)  
```cpp
#include <cstdio>

using namespace std;

const int maxn = 2510, maxm = 2510; 
int a[maxn][maxm], zeroL[maxn][maxm], zeroR[maxn][maxm], f1[maxn][maxm], f2[maxn][maxm];

inline int min(int i, int j) { return i < j ? i : j; }
inline int max(int i, int j) { return i > j ? i : j; }

int main() {
	int n, m, ans = 0;
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) {
			scanf("%d", &a[i][j]);
			if(!ans && a[i][j]) ans = 1;
		}
	for(int i = 1; i <= n; i++) zeroL[i][1] = zeroR[i][1] = 1;
	for(int j = 1; j <= m; j++) zeroL[1][j] = zeroR[1][j] = 1;
	for(int i = 1; i <= n; i++) f1[i][1] = a[i][1];
	for(int j = 1; j <= m; j++) f1[1][j] = a[1][j];
	for(int i = 2; i <= n; i++)
		for(int j = 2; j <= m; j++) {
			zeroL[i][j] = a[i][j-1] == 1 ? 1 : zeroL[i][j-1] + 1;
			zeroR[i][j] = a[i-1][j] == 1 ? 1 : zeroR[i-1][j] + 1;
		}
	for(int i = 2; i <= n; i++)
		for(int j = 2; j <= m; j++) {
			if(!a[i][j]) continue;
			f1[i][j] = min(min(f1[i-1][j-1]+1, zeroL[i][j]), zeroR[i][j]);
			ans = max(ans, f1[i][j]);
		}
	for(int i = 1; i <= n; i++) zeroL[i][m] = 1;
	for(int i = 1; i <= n; i++) f2[i][m] = a[i][m];
	for(int j = 1; j <= m; j++) f2[1][j] = a[1][j];
	for(int i = 2; i <= n; i++)
		for(int j = m-1; j > 0; --j)
			zeroL[i][j] = a[i][j+1] == 1 ? 1 : zeroL[i][j+1] + 1;
	for(int i = 2; i <= n; i++)
		for(int j = m-1; j > 0; --j) {
			if(!a[i][j]) continue;
			f2[i][j] = min(f2[i-1][j+1]+1, min(zeroL[i][j], zeroR[i][j]));
			ans = max(ans, f2[i][j]);
		}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：vеctorwyx (赞：4)

## 更像搜索的~~简单~~做法（~~我这种菜鸡都懂它能不简单吗？~~）

遍历每一个为 ```1``` 的点，判断它是否能构成对角线，所在的部分是否符合条件
，即正方形对角线上都是 ```1``` ，其他地方都是 ```0```，如果符合条件长度就加一，否则的话下面再说，比较麻烦。

思路如图:

![rt](https://cdn.luogu.com.cn/upload/image_hosting/uuoj7gmb.png)

这是从左上到右下的搜索思路，同理可以推出**从右上到左下**的搜法（????别忘了这事），至于怎么实现的话，~~再搜一遍就好，不会TLE~~；

### 如果正方形中出现了多的``` 1```怎么办？

我一开始想的是直接退出当前正方形，重新计，**但是不对！**

考虑一下下面这种情况：

```
1 0 0 0 0 0 0 0 
0 1 0 0 0 0 0 0
0 0 1 0 1 0 0 0
0 0 0 1 0 0 0 0
0 0 1 0 1 0 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1
```
如果直接重新计结果就是4，
但是确实结果是5（我把那个正方形框出来了）：
```
1 0 0 0 0 0 0 0 
0 1 0 0 0 0 0 0
0 0 1 0 1 0 0 0
      ---------
0 0 0|1 0 0 0 0|
0 0 1|0 1 0 0 0|
0 0 0|0 0 1 0 0|
0 0 0|0 0 0 1 0|
0 0 0|0 0 0 0 1|
      ---------
```
所以，当你找到一个不符合条件的```1```时，把符合条件的那一小部分算上就好（具体见代码）。

至于怎么存对角线长度……
```
对角线长度=边长

```

代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,dp[3000][3000],ans;
bool a[3000][3000],flag;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		cin>>a[i][j];
	}
	for(int i=1;i<=n;i++)//从左上到右下
	{
		for(int j=1;j<=m;j++)
		{
			if(!a[i][j])//只有是 1 的时候才搜， 0 不用管
			continue;
			for(int k=1;k<=dp[i-1][j-1];k++)
			{
				if(a[i][j-k]||a[i-k][j])
				{
					dp[i][j]=k;//存下来符合条件的部分的大小
					flag=1;
					break;
				}
			}
			if(flag)
			{
				flag=0;
				continue;
			}
			else
			{
				dp[i][j]=dp[i-1][j-1]+1;//扩大正方形
			}
			ans=max(ans,dp[i][j]);//记录答案
		}
	}
   memset(dp,0,sizeof(dp));//防止前一次搜索时影响后一次
	for(int i=1;i<=n;i++)//从右上到左下，其余同上
	{
		for(int j=m;j>0;j--)
		{
			if(!a[i][j])
			continue;
			for(int k=1;k<=dp[i-1][j+1];k++)
			{
				if(a[i][j+k]||a[i-k][j])
				{
					dp[i][j]=k;
					flag=1;
					break;
				}
			}
			if(flag)
			{
				flag=0;
				continue;
			}
			else
			{
				dp[i][j]=dp[i-1][j+1]+1;
			}
			ans=max(ans,dp[i][j]);
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
感谢：

感谢@[比利只有1♂7岁](https://www.luogu.com.cn/user/124225)大佬的点拨。

美中不足的一点：

没有剪枝（~~不会！~~），时间复杂度有点高。

---

## 作者：ICE_Wol (赞：4)

[鱼塘传送门](https://www.luogu.org/problemnew/solution/P1736)

## 简析

历经千辛万苦~~鬼搞一通~~之后发现自己没有预处理就把这题给过了，感觉是个很厉害的壮举（不），在这里简单说一下自己的思路。


方便起见，我们先考虑**左上右下**对角线的情况。
首先，我们将原来的鱼塘用数组 $v$ 储存起来，数组 $f$ 储存当前点的左上方满足条件的最大子矩阵对角线的长度，显而易见地有如下初始化过程：

### $f[i][j] = v[i][j]$

假如当前点满足如下两个条件：

### $1. f[i - 1][j - 1] > 0$

### $2. v[i][j] > 0$

这个时候，我们可以尝试更新 $f[i-1][j-1]$，简单思考一下，我们发现，我们只用检查 $v[i][j]$ 上方 $f[i-1][j-1]$ 个格子和右方 $f[i-1][j-1]$ 个格子，只要检查到的格子全为 $0$ 就可以进行更新：

### $f[i][j] = f[i-1][j-1] + 1$

（想一想，为什么？）

但如果检查上述格子之后发现有 $1$ ，怎么办呢？放任不管吗？显然不是。

经过思考，我们发现 $v[i][j]$ 上方和右方遇到最近的 $1$ 格依旧可以用来更新答案。不清楚原因？没关系，我们来看一个简单的例子：

```
v:     f:
1 0 1  1 0 1
0 1 0  0 2 0
1 0 0  ? x x
```

现在，我们考虑 $?$ 位置的格子，按照上述方案，我们试着检查  $v[3][3]$ 上方和右方的格子，发现上方两格处有最近的 $1$。

显然这个时候我们不能按刚才给出的公式进行转移，但由肉眼分析我们不难发现 $f[3][3]$ 中应当填写的值是 $2$ 。

发现规律了吗？应当填写的值就是上方和右方遇到最近的 $1$ ，与你当前考虑的格子的行数（或列数）之差的绝对值。

对于**右上坐下**对角线情况的分析大同小异，留给读者自己思考。

## AC代码

```
#include<iostream>
using namespace std;
int n,m,ans;
bool v[2501][2501];
int f[2501][2501];
int main(){
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++){
			cin >> v[i][j];
			f[i][j] = v[i][j];
		}
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
			if(v[i][j] && f[i - 1][j - 1]){
				bool flag = 1;int l = 0x3f3f3f3f;
				for(int k = i - 1;k >= i - f[i - 1][j - 1] && flag;k--)
					if(v[k][j]) flag = 0,l = min(l,i - k);
				for(int k = j - 1;k >= j - f[i - 1][j - 1] && flag;k--)
					if(v[i][k]) flag = 0,l = min(l,j - k);
				if(flag) f[i][j] = f[i - 1][j - 1] + 1;
				else f[i][j] = l;
			}
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
			ans = max(f[i][j],ans);
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
			f[i][j] = v[i][j];
	for(int i = 1;i <= n;i++)
		for(int j = m;j >= 1;j--)
			if(v[i][j] && f[i - 1][j + 1]){
				bool flag = 1;int l = 0x3f3f3f3f;
				for(int k = i - 1;k >= i - f[i - 1][j + 1] && flag;k--)
					if(v[k][j]) flag = 0,l = min(l,i - k);
				for(int k = j + 1;k <= j + f[i - 1][j + 1] && flag;k++)
					if(v[i][k]) flag = 0,l = min(l,k - j);
				if(flag) f[i][j] = f[i - 1][j + 1] + 1;
				else f[i][j] = l;
			}
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
			ans = max(f[i][j],ans);
	cout << ans;
	return 0;
} 
```

---

## 作者：Forever丶CIL (赞：3)

这个题本质就是在一个0 1矩阵中找一个仅一条对角线为1的子矩阵

对于这个题，用A[i][j].v表示过点（i,j）能吸到的鱼的个数

用A[i][j].s表示对于该点，从哪一行的点开始吸吸到的鱼最多

先维护一遍前缀和然后O（nm）遍历全图

对于每个点有几种情况：

1： 这个点的值为零，那么对于这个点A[i][j].v=0 A[i][j].s=i;

2： 这个点是1但这个点i-1,j-1是0，那么这个点的v=1，s=i

3： 这个点是1且这个点i-1,j-1是1，

那么从上一个点的起点开始while，每次判断从这个起点到当前点所在的矩阵满不满足要求

满足就可以直接转移赋值，否则就让起点++，再判断，直到起点=i为止

对于这个方向做完后再以同样的方法进行一遍另一个方向的，

然后在过程中记录A[i][j].v的最大值就好了


------------

                
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
void print2();
struct creative_fish
{
    unsigned short v;
    unsigned short s;
};
struct creative_fish A[2501][2501];
unsigned short dt[2501][2501];
unsigned short ydt[2501][2501];
unsigned short n,m;
unsigned short ans=0;
void print1();
int read()
{
    int rt=0,fl=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')fl=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){rt=rt*10+ch-'0';ch=getchar();}
    return rt*fl;
}
void dp1()
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(!ydt[i][j])
            {
                A[i][j].v=0;
                A[i][j].s=i;
            }
            if(ydt[i][j]&&!ydt[i-1][j-1]&&ydt[i-1][j]+ydt[i][j-1]==0)
            {
                A[i][j].v=1;
                A[i][j].s=i-1;
                if(A[i][j].v>ans) ans=A[i][j].v;
                continue ;
            }
            int tt=A[i-1][j-1].s;
            int ll=A[i-1][j-1].v;
            while(tt!=i)
            {
                if(ydt[i][j]&&(dt[i][j]-dt[i][j-(i-tt)]-dt[tt][j]+dt[tt][j-(i-tt)])==(i-tt))
                {
                    A[i][j].v=ll+1;
                    A[i][j].s=tt;
                    break;
                }
                tt++;
                ll--;
            }
            if(A[i][j].v>ans) ans=A[i][j].v;
        }
    }
}
void dp2()
{
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=1;j--)//求出另一个方向的前缀和和一些初始化 
        {
            dt[i][j]=ydt[i][j];
            dt[i][j]+=dt[i-1][j]+dt[i][j+1]-dt[i-1][j+1];
            A[i][j].v=0;
            if(j==m) 
            {
                A[i][j+1].v=0;
                A[i][j+1].s=i;
            }
            if(ydt[i][j]) A[i][j].v=1;
            A[i][j].s=i-1;
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=1;j--)
        {
            if(!ydt[i][j])
            {
                A[i][j].v=0;
                A[i][j].s=i;
            }
            if(ydt[i][j]&&!ydt[i-1][j+1]&&ydt[i-1][j]+ydt[i][j+1]==0)
            {
                A[i][j].v=1;
                A[i][j].s=i-1;
                if(A[i][j].v>ans) ans=A[i][j].v;
                continue ;
            }
            int tt=A[i-1][j+1].s;
            int ll=A[i-1][j+1].v;
            while(tt!=i)
            {
                if(ydt[i][j]&&dt[i][j]-dt[tt][j]-dt[i][j+(i-tt)]+dt[tt][j+(i-tt)]==(i-tt))
                {
                    A[i][j].v=ll+1;
                    A[i][j].s=tt;
                    break;
                }
                ll--;
                tt++;
            }
            if(A[i][j].v>ans) ans=A[i][j].v;
        }
    }
}
int main()
{
    n=read();
    m=read();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)//求出左上到右下的前缀和以及一些初始化 
        {
            dt[i][j]=read();
            ydt[i][j]=dt[i][j];
            dt[i][j]+=dt[i-1][j]+dt[i][j-1]-dt[i-1][j-1];
            if(j==1)        //一些初始化 
            {    
                A[i][j-1].v=0;        
                A[i][j-1].s=i;
            }
            if(ydt[i][j]) A[i][j].v=1;
            A[i][j].s=i-1;
        }
    }
    dp1();
    dp2();
    printf("%d",ans);
    return 0;
}
```


------------

亲测1223ms 还是比较慢的，但是思路好理解啊
可能我有的初始化是不需要的，大家可以批判的借鉴

但是思路绝对没错啊QAQ鄙人语文不是很好

大家看不太懂的话可以画图模拟一下

RP++



---

## 作者：ZzuGzx (赞：2)

 和各位dalao的思路不是特别一样
 发现这道题和P1387的最大正方形特别像
 同样是用了一个比较笨的方法
 但是应该很好理解
 ——————————————————————
 # 对于左上到右下来说
 对于每一点来说，如果该点大于零，判断其左上方的点，如果左上方的点数值为p，则判断该点向左和向上的是不是全为0
 如果全部为0，a[i][j]=a[i-1][j-1]+1
 如果不全为0，即if(!a[i][j-k]||!a[i-k][j])
 k=1，2，3，……p
 其中有不存在的，那么a[i][j]=k
 然后循环就可以了判断就可以了
# 从右上到左下是同理
 只要全部改成i-1，j+1就可以了 然后循环看点i是从1到n j是从m到1依次判断
# 下面是完整AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m;
int a[2501][2501], b[2501][2501];
int main()
{
	//freopen("in.txt", "r", stdin);
	cin >> n >> m;
	int ans = 0;
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
		{
			scanf("%d", &a[i][j]);
			b[i][j] = a[i][j];//为另一个方向的对角线做准备
			int flag = 0,k;
			if (a[i][j] && a[i - 1][j - 1]) {
				for (k = 1;k <= a[i - 1][j - 1];k++)
					if (a[i][j - k] || a[i - k][j]) {
						flag = 1;
						break;
					}
				if (!flag) 
					a[i][j] = a[i - 1][j - 1] + 1;
				else
					a[i][j] = k;
			}
			ans = max(a[i][j], ans);
		}
	for (int i = 1;i <= n;i++)
		for (int j = m;j >= 1;j--)
		{
			int flag = 0, k;
			if (b[i][j] && b[i - 1][j + 1]) {
				for (k = 1;k <= b[i - 1][j + 1];k++)
					if (b[i][j + k] || b[i - k][j]) {
						flag = 1;
						break;
					}
				if (!flag) 
					b[i][j] = b[i - 1][j + 1] + 1;
				else
					b[i][j] = k;
			}
			ans = max(b[i][j], ans);
		}
	cout << ans;
	return 0;
}
```


---

## 作者：shs_ryf (赞：2)

此题乍一看与[最大正方形](https://www.luogu.org/problemnew/show/P1387)十分类似, 也是用 $f[i][j]$ 来表示点 $a[i][j]$ 为左下角或右下角时的最大对角线长度(因为对角线可能从左上到右下, 也可能从右上到左下, 所以要考虑两次). 然而转移似乎不那么容易, 因为题目中有“除对角线外没有1” 的限制.

然后我就不会写了, 后来想出一个方法, 那就是同时维护一个二维前缀和, 然后只要这个区域里面的1的数量恰好等于边长, 就可以扩展. 这份代码主要思路如下:
```cpp
for(int i = 1; i <= n; ++i){
    for(int j = 1; j <= m; ++j){
        if(a[i][j]){
            int delta = f[i - 1][j - 1] + 1;
            if(sum[i][j] - sum[i][j - delta] - sum[i - delta][j] + sum[i - delta][j - delta] == delta)
                f[i][j] = delta;
            else
                f[i][j] = 1;
            ans = max(ans, f[i][j]);
        }
    }
}
```

乍一看好像没啥问题, 但是只有80分. 后面看讨论区才发现居然这个解法是有很大问题的, 因为扩展1的时候可能只扩展前一个正方形的一部分1, 例如

4 4  
1 0 1 0  
0 1 0 0  
1 0 1 0  
0 0 0 1

正解应该是3, 然而上述代码只能得出2.

然后我又想到了“最大正方形”那道题, 是求三个 $f$ 的最小值. 这题我们就可以在dp求 $f$ 的时候, 顺带便维护一下这个点往上, 往左(右)最多能有多少连续的0, 然后再与之前的 $f$ 求最小值扩展. 这样子可以保证正确, 而且惊讶的是代码量也很少(因为这几个dp值可以同时维护的). 以下是正解代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int C = 2508;

int f[C][C], up[C][C], g[C][C], a[C][C];

int main(){
    int n, m, ans = 0;
    while(scanf("%d%d", &n, &m) == 2){
        memset(f, 0, sizeof(f));
        memset(a, 1, sizeof(a));
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= m; ++j){
                scanf("%d", &a[i][j]);
                up[i][j] = a[i - 1][j] ? 0 : (up[i - 1][j] + 1);
                g[i][j] = a[i][j - 1] ? 0 : (g[i][j - 1] + 1);
            }
        }
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= m; ++j){
                if(a[i][j]){
                    f[i][j] = min(f[i - 1][j - 1], min(up[i][j], g[i][j])) + 1;
                    ans = max(ans, f[i][j]);
                }
            }
        }
        memset(f, 0, sizeof(f));
        for(int i = 1; i <= n; ++i){
            for(int j = m; j >= 1; --j){
                g[i][j] = a[i][j + 1] ? 0 : (g[i][j + 1] + 1);
                if(a[i][j]){
                    f[i][j] = min(f[i - 1][j + 1], min(up[i][j], g[i][j])) + 1;
                    ans = max(ans, f[i][j]);
                }
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}


```

---

## 作者：咯咯咯 (赞：2)

首先这是一道非常棒的~~水~~好题

我们有O（n^3)，O（kn^2),O(n^2logn)...各种做法

不过其实这题完全可以O(n^2）

~~而且常数灰常灰常小~~ 用时400+ms

空间复杂度O(n)

~~当然用简单实用的滚动数组~~

我们发现dp[i][j]其实是只和上一层有关系

这里设dp[i][j][0]为斜向左上的对角线长度

dp[i][j][1]为斜向右上的对角线长度

这里拿dp[i][j][0]为例

如果a[i-1][j-1]为1的话我们就考虑从它转移

但是还有一个条件就是矩形中只有对角线能有1

那么我们就判断一下这个这个新矩形向上和向左的最长延伸长度，然后取个min 此时一定最大

~~至于向左向右向上延伸长度随便预处理一下就可以了~~

一些变量的意义：(非滚动意义下）

H[i][j]：第i行第j列向上最多可以延伸几个0

L[i][j]：第i行第j列向左最多可以延伸几个0

R[i][j]：第i行第j列向右最多可以延伸几个0

dp[i][j][0/1]:第i行第j列向左上/右上延伸的最大合法矩形
```
#include<iostream>
#include<cstring>
#include<cstdio>
#define For(i,a,b) for(register int i=a;i<=b;i++)
#define Ford(i,a,b) for(register int i=a;i>=b;i--)
#define Fill(a,b) memset(a,b,sizeof(a))
using namespace std;
void read(int &x)
{
	int t=0;
	char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while ('0'<=c&&c<='9')
	{
		t=t*10+c-'0';
		c=getchar();
	}
	x=t;return ;
}
#define N 2510
int n,m,ans,a[2][N],H[2][N],L[2][N],R[2][N],dp[2][N][2];
int main()
{
	while(~scanf("%d%d",&n,&m))
	{
		Fill(a,0);Fill(H,0);Fill(L,0);Fill(R,0);Fill(dp,0);ans=0;				
		For(i,1,n)
		{
			For(j,1,m) 
			{
				read(a[i&1][j]);
				if (a[(i+1)&1][j]!=1) H[i&1][j]=H[(i+1)&1][j]+1;else H[i&1][j]=1;							
				if (a[i&1][j-1]!=1) L[i&1][j]=L[i&1][j-1]+1;else L[i&1][j]=1;
				if (a[i&1][j]==1)
				{
					if (a[(i+1)&1][j-1]==1) dp[i&1][j][0]=min(dp[(i+1)&1][j-1][0]+1,min(H[i&1][j],L[i&1][j]));
					else dp[i&1][j][0]=1;
					ans=max(ans,dp[i&1][j][0]);
				}
			}
			Ford(j,m,1)
			{
				if (a[i&1][j+1]!=1) R[i&1][j]=R[i&1][j+1]+1;else R[i&1][j]=1;
				if (a[i&1][j]==1)
				{
					if (a[(i+1)&1][j+1]==1) dp[i&1][j][1]=min(dp[(i+1)&1][j+1][1]+1,min(H[i&1][j],R[i&1][j]));
						else dp[i&1][j][1]=1;					
				}
				ans=max(ans,dp[i&1][j][1])		;		
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：KJGKMTZB (赞：1)

$\text{me写的是}O(n*m)\text{和其它二分的写法差不多,只不过多了几个数组}$

$\text{首先，这道题的思路很好想，分两种情况，只能向两个方向倾斜，一种向右上，一种向右下}$

$\text{于是便分两种情况分别dp,dp1[i][j]为第i行,第j列以这个格子为右下的最多能吃的鱼}$

$\text{再用个dp2[i][j]表示第i行,第j列以这个格子为右上的最多能吃的鱼}$

$\text{接下来考虑如何转移，下面主要分析dp1}$

$\text{对于第i行第j列的格子来说,如果当前格子为0，毫无疑问dp1[i][j]=0}$

$\text{如果当前格子不为0,因为题目中说只能对角线为1,则需要知道这个格子的上方第一个为1的格子的位置,与左边第一个为1的位置}$

$\text{那么，转移也很好写了,令h[i][j]为第i行前j列里最后一个1在的列,l[i][j]为前i行第j列里最后一个1在的行}$

$\text{又因为是只有对角线,所以需要取min}$

$\text{则有方程}dp1[i][j]=min(dp1[i-1][j-1],min(j-h[i][j-1],i-l[i-1][j])-1)+1$

$\text{注意上方那个-1,因为求的是中间有多少个不为1}$

$\text{然后,dp2同理,只不过l的定义改成第i行第j列下面第一个1所在的位置并且min里改成}(l[i+1][j]-i)$

$\text{还有需要注意的是预处理,并且要把l和h改成short,要不然交上去一发MLE}$

$\text{我的代码里,l1就是dp1里的l,l2就是dp2里的l}$

$\text{代码}$

```
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include <cstdio>
#include <algorithm>
#include <cstring>
#define ll long long
const int inf=0x7f7f7f7f;
const int maxn=2502;
template<class T>inline void read(T &x) {
	T f=1;x=0;char s=getchar();
	while(s<'0'||s>'9') {if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=(x<<1)+(x<<3)+(s&15);s=getchar();}
	x*=f;
}
template<class T>inline T min(T a,T b) { return a<b?a:b; }
template<class T>inline T max(T a,T b) { return a>b?a:b; }
template<class T>inline T fabs(T a) { return a>0?a:-a; }
template<class T>inline T po3(T a) { return a*a*a; }
template<class T>inline T po(T a) { return a*a; }
int n,m,len,dp1[maxn][maxn],dp2[maxn][maxn],x,y,rans,cnt;
short map[maxn][maxn],h[maxn][maxn],l1[maxn][maxn],l2[maxn][maxn];
int main() {
	read(n); read(m);
	for(int i=1;i<=m;i++) l2[n+1][i]=n+1;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			read(map[i][j]);
			if(map[i][j]) h[i][j]=j,l1[i][j]=i,cnt++;
			else h[i][j]=h[i][j-1],l1[i][j]=l1[i-1][j];
		}
	}
	for(int i=n;i>=1;i--) {
		for(int j=1;j<=m;j++) {
			if(map[i][j]) l2[i][j]=i;
			else l2[i][j]=l2[i+1][j];
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			if(map[i][j]) {
				if(!dp1[i-1][j-1]) {
					rans=max(rans,dp1[i][j]); dp1[i][j]=1; continue;
				}
				x=h[i][j-1]; y=l1[i-1][j];
				dp1[i][j]=min(dp1[i-1][j-1],min((j-x),(i-y))-1)+1;
				rans=max(rans,dp1[i][j]);
			}
			else dp1[i][j]=0;
		}
	}
	for(int i=n;i>=1;i--) {
		for(int j=1;j<=m;j++) {
			if(map[i][j]) {
				if(!dp2[i+1][j-1]) {
					dp2[i][j]=1; continue;
				}
				x=h[i][j-1]; y=l2[i+1][j];
				dp2[i][j]=min(dp2[i+1][j-1],min((j-x),(y-i))-1)+1;
				rans=max(rans,dp2[i][j]);
			}
			else dp2[i][j]=0;
		}
	}
	printf("%d",rans);
}
```

---

## 作者：paper_plane (赞：1)

[题面传送门](https://www.luogu.org/problem/P1736)

刚看到这题时，DP？暴搜？

大佬的题解感觉都好难啊qwq

本蒟蒻在一旁瑟瑟发抖

我第一眼想到的就是暴力，枚举左上起点和右上起点，然

而，这题确实也能过，只要先预处理出一个二维前缀和数

组就行了，这要做的时候会快不少，也不至于超时了。

code:
```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
const int N=2505;
int sum[N][N];
int mat[N][N];
inline void in(int &x){
	x=0;
	int f=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+c-'0',c=getchar();
	x*=f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
int main(){
	freopen("1736.in","r",stdin);
	freopen("1736.out","w",stdout);
	int n,m;
	int ans=0;
	in(n);in(m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			in(mat[i][j]);
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)
	        sum[i][j]=sum[i-1][j]+sum[i][j-1]+mat[i][j]-sum[i-1][j-1];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!mat[i][j])continue;
			int x=i+1,y=j+1;
			int cur=1;
			while(x<=n&&y<=m&&mat[x][y]&&(sum[x][y]-sum[x][j-1]-sum[i-1][y]+sum[i-1][j-1]==x-i+1)){
				cur++;
				x++;y++;
			}
			ans=max(ans,cur);
			x=i+1,y=j-1;
			cur=1;
			while(y>0){
				if(x<=n&&mat[x][y]&&(sum[x][j]-sum[x][y-1]-sum[i-1][j]+sum[i-1][y-1]==x-i+1)){
					cur++;
					x++;y--;
				}
				else break;
			}
			ans=max(ans,cur);
		}
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：lemir3 (赞：1)

[*题面*](https://www.luogu.org/problem/P1736)

## 题目分析

同志们先来看看这道题是否可以用$DP$解决.

首先是最优子结构原则,一个位置的最长斜线,一定是由它上面的最长斜线转移过来的,满足该原则.

然后是无后效性原则,无论一个点后面的点做出怎样的决策,也不会影响到这个点的最优解,可以看做是$DAG$图中的一个拓扑序,满足该原则.

因为是线性的$DP$,状态的求解直接构成一个阶段.

定义状态$dp_{i,j,opt}$,表示在($i$,$j$)这个位置,从左往右或是从右往左的斜线的最大长度.

初看这道题,以为很水,求最长的斜线,于是打了一个O($n^2$)的$DP$,惨得20分.

痛定思痛,再次读题,才发现这条斜线所在的正方形内的其他地方必须为空.希望同志们以后大胆实验,小心求证(雾).

于是我又想到一个办法,在转移一个状态的时候,暴力验证以它转移过来的地方的斜线长度的正方形是不是全空的.

得到以下$DP$方程:

```cpp
if(check0(i,j)
{
	dp[i][j][0]=dp[i-1][j-1][0]+1;
}
else
{
	dp[i][j][0]=1;
}
if(check1(i,j))
{
	dp[i][j][1]=dp[i-1][j+1][1]+1;
}
else
{
	dp[i][j][1]=1;
}
inline bool Check0(lxl x,lxl y)
{
	for(R lxl _=1;_<=dp[i-1][j-1];++_)
	{
		if(map_[x][y-_]||map_[x-_][y])
		{
			return false;
		}
	}
	return true;
}

inline bool Check1(lxl x,lxl y)
{
	for(R lxl _=1;_<=dp[i-1][j+1];++_)
	{
		if(map_[x][y+_]||map_[x-_][y])
		{
			return false;
		}
	}
	return true;
}
```

但是就这样遇到了问题,如下面的$hack$数据:

```cpp
6 6 
1 1 0 0 0 1
0 0 0 0 1 0
0 0 0 1 0 0
0 0 1 0 0 0
0 1 0 0 0 1
1 0 0 0 0 0
```

很明显,应该是从右上角第二个$1$开始的子矩阵有最优解,但是如果按照这样转移的话,到左下角第二个$1$的时候转移失败了,把它定为一个矩阵的开始节点.

所以说在转移失败的时候,同志们应该试着枚举新的长度,而不是把这个失败的节点定为矩阵的开始节点.

再来思考一下,可以发现一个子矩阵的边长是单调递增的,设上一层的边长为$num$,那么这一层在转移的时候,就会判断周围$num$个节点是否全为空.

因为可以保证这个点上方的子矩阵是合法的,所以说这个点可以框出边长小于等于$num$的子矩阵.

于是同志们来改造一下$check$函数,让它返回第一个发现不是空的位置,以这个位置距离原位置的长度作为子矩阵的边长.

得到以下转移方程:

```cpp
if(dp[_-1][__-1][0]&&map_[_][__])
{
	dp[_][__][0]=Check0(_,__,dp[_-1][__-1][0])+1;	
}
if(dp[_-1][__+1][1]&&map_[_][__])
{
	dp[_][__][1]=Check1(_,__,dp[_-1][__+1][1])+1;
}
inline lxl Check0(lxl x,lxl y,lxl k)
{
	for(R lxl _=1;_<=k;++_)
	{
		if(map_[x][y-_]||map_[x-_][y])
		{
			return _-1;
		}
	}
	return k;
}

inline lxl Check1(lxl x,lxl y,lxl k)
{
	for(R lxl _=1;_<=k;++_)
	{
		if(map_[x][y+_]||map_[x-_][y])
		{
			return _-1;
		}
	}
	return k;
}
```

另外的,如果经过上面两个转移方式后仍然没有得到转移,但是这个点非空的话,把这个点作为一个子矩阵的开始.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cctype"
#include "algorithm"
#include "cstdlib"
#include "cmath"

#define lxl long long
#define R register
#define INF 2147483647
#define debug(x) cout<<"debug:"<<x<<"\n"

using namespace std;

lxl n,m,ans=-INF;
lxl dp[2510][2510][2];
bool map_[2510][2510];

inline lxl Check0(lxl,lxl,lxl);
inline lxl Check1(lxl,lxl,lxl);

signed main(void)
{
	ios::sync_with_stdio(false);
//	freopen("testdata (4).in","r",stdin);
//	freopen("data.out","w",stdout);
	cin>>n>>m;
	for(R lxl _=1;_<=n;++_)
	{
		for(R lxl __=1;__<=m;++__)
		{
			lxl a;
			cin>>a;
			map_[_][__]=a==1?true:false;
		}
	}
/*	for(R lxl _=1;_<=n;++_)
	{
		for(R lxl __=1;__<=m;++__)
		{
			if(map_[_][__])
			{
				cout<<"1 ";
			}
			else
			{
				cout<<"0 ";
			}
		}
		cout<<"\n";
	}*/
	for(R lxl _=1;_<=n;++_)
	{
		for(R lxl __=1;__<=m;++__)
		{
			if(dp[_-1][__-1][0]&&map_[_][__])
			{
				dp[_][__][0]=Check0(_,__,dp[_-1][__-1][0])+1;
			}
			if(dp[_-1][__+1][1]&&map_[_][__])
			{
				dp[_][__][1]=Check1(_,__,dp[_-1][__+1][1])+1;
			}
			if(map_[_][__]&&!dp[_][__][0])
			{
				dp[_][__][0]=1;
			}
			if(map_[_][__]&&!dp[_][__][1])
			{
				dp[_][__][1]=1;
			}
			ans=max(ans,max(dp[_][__][0],dp[_][__][1]));
		}
	}
/*	for(R lxl _=1;_<=n;++_)
	{
		for(R lxl __=1;__<=m;++__)
		{
			cout<<dp[_][__][0]<<" ";
		}
		cout<<"\n";
	}
	cout<<"\n";
	for(R lxl _=1;_<=n;++_)
	{
		for(R lxl __=1;__<=m;++__)
		{
			cout<<dp[_][__][1]<<" ";
		}
		cout<<"\n";
	}
	cout<<"\n";*/
	cout<<ans<<"\n";
	return 0;
}

inline lxl Check0(lxl x,lxl y,lxl k)
{
	for(R lxl _=1;_<=k;++_)
	{
		if(map_[x][y-_]||map_[x-_][y])
		{
			return _-1;
		}
	}
	return k;
}

inline lxl Check1(lxl x,lxl y,lxl k)
{
	for(R lxl _=1;_<=k;++_)
	{
		if(map_[x][y+_]||map_[x-_][y])
		{
			return _-1;
		}
	}
	return k;
}

```

---

## 作者：BT狸——Frozen (赞：1)

在本蒟蒻与此题大战三回合后，终于A了这道题...
$$\color{white}\colorbox{white}{果然是我太弱了吗}$$
这道题本身也不算太难，稍微暴力一点的方法也是可以过的。


------------
首先我们读题，题目翻译过来就是我们要输出最大符合条件正方形的边长，单纯一个个枚举多半是要超时的。其实对于一个点来说，我们只用了解它左上和右上的点的情况，再检索它横竖有没有1就可以了。
那么我们先建一个结构体
```cpp
struct fish{
	int mp;
	int num1;
	int num2;
}f[mx][mx];
```
num1表示当它为右下端点时，最大正方形的边长，num2表示当它为左下端点时，最大正方形的边长。mp储存的就是01；
接下来就是遍历啦
```cpp
for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	  {
		if(f[i][j].mp==1) f[i][j].num1=1;//是1的至少边长为1 
	  	if(f[i-1][j-1].mp==1 && f[i][j].mp==1)//左上的点也为1 
	  	{
	  		f[i][j].num1=f[i-1][j-1].num1+1;//边长加1 
	  		for(int k=1;k<f[i-1][j-1].num1+1;k++)//判断边是否合法 
	  		{
	  			if(f[i-k][j].mp==1 || f[i][j-k].mp==1)//有其它地方为1的 
	  			{
	  				f[i][j].num1=1;//重置为1
	  				break;
				}
			}
			ans=max(ans,f[i][j].num1);//更新答案 
		}
	  }
```
num2同理
```cpp
for(int i=1;i<=n;i++)
	  for(int j=m;j>=1;j--)
	  {
	  	if(f[i][j].mp==1) f[i][j].num2=1;
	  	if(f[i-1][j+1].mp==1 && f[i][j].mp==1)
	  	{
	  		f[i][j].num2=f[i-1][j+1].num2+1;
	  		for(int k=1;k<f[i-1][j+1].num2+1;k++)
	  		{
	  			if(f[i-k][j].mp==1 || f[i][j+k].mp==1)
	  			{
	  				f[i][j].num2=1;
	  				break;
				}
			}
			ans=max(ans,f[i][j].num2);
		}
	  }
```
好像完成了，交上去。

![惨痛教训](https://cdn.luogu.com.cn/upload/pic/69322.png)

后来在翻讨论帖时，有大佬提供了这样一组数据
```cpp
4 4
1 0 1 0
0 1 0 0
1 0 1 0
0 0 0 1
```
答案为3。

但如果像刚才一样计算的话，输出为2。

在经过我仔细检查（~~询问大佬~~）之后，发现在检查时出了问题。

不能直接重置为1，而要将它置位k。不然如果遇到上面这种数据时，$f[3][3].num1=2$而不是$1$。

顺便提一下，在计算num1时，我们可以将它与输入合在一起。因为计算当前点num1时只需要它左上的数据，而输入是从左到右，从上到下的。
```cpp
for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	  {
	  	scanf("%d",&f[i][j].mp);
		if(f[i][j].mp==1) f[i][j].num1=1;//是1的至少边长为1 
	  	if(f[i-1][j-1].mp==1 && f[i][j].mp==1)//左上的点也为1 
	  	{
	  		f[i][j].num1=f[i-1][j-1].num1+1;//边长加1 
	  		for(int k=1;k<f[i-1][j-1].num1+1;k++)//判断边是否合法 
	  		{
	  			if(f[i-k][j].mp==1 || f[i][j-k].mp==1)//有其它地方为1的 
	  			{
	  				f[i][j].num1=k;//存储此时最大边长 
	  				break;
				}
			}
			ans=max(ans,f[i][j].num1);//更新答案 
		}
	  }
```
如此就可以AC了。

------------
### 完整代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
const int mx=3000;
int n,m;
int mp;
int ans;
struct fish{
	int mp;
	int num1;
	int num2;
}f[mx][mx];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	  {
	  	scanf("%d",&f[i][j].mp);
		if(f[i][j].mp==1) f[i][j].num1=1;//是1的至少边长为1 
	  	if(f[i-1][j-1].mp==1 && f[i][j].mp==1)//左上的点也为1 
	  	{
	  		f[i][j].num1=f[i-1][j-1].num1+1;//边长加1 
	  		for(int k=1;k<f[i-1][j-1].num1+1;k++)//判断边是否合法 
	  		{
	  			if(f[i-k][j].mp==1 || f[i][j-k].mp==1)//有其它地方为1的 
	  			{
	  				f[i][j].num1=k;//存储此时最大边长 
	  				break;
				}
			}
			ans=max(ans,f[i][j].num1);//更新答案 
		}
	  }
	for(int i=1;i<=n;i++)
	  for(int j=m;j>=1;j--)
	  {
	  	if(f[i][j].mp==1) f[i][j].num2=1;
	  	if(f[i-1][j+1].mp==1 && f[i][j].mp==1)
	  	{
	  		f[i][j].num2=f[i-1][j+1].num2+1;
	  		for(int k=1;k<f[i-1][j+1].num2+1;k++)
	  		{
	  			if(f[i-k][j].mp==1 || f[i][j+k].mp==1)
	  			{
	  				f[i][j].num2=k;
	  				break;
				}
			}
			ans=max(ans,f[i][j].num2);
		}
	  }
	printf("%d",ans);
	return 0;
} 
```


---

## 作者：Crabby_Maskiv (赞：1)

  这道DP的转移方程其实和P1387最大正方形想法类似，建议大家先做那道题再来。

  DP转移方程推导：
  
  先画个图
  
  1 0 0 0
  
  0 1 0 0
  
  0 0 1 0
  
  0 0 0 1
  
  分解子问题可以参照最大正方形的方法，dp数组的参数可以设置为合法正方形右下角的坐标，存储的量可以设置为合法正方形的边长。答案就是dp数组中的最大值。
  
  看上图，我们需要让dp[4][4]与子问题dp[3][3]建立联系（假设已知dp[3][3]=3）
  
  首先，dp[3][3]对应的正方形对角线上全是1，maze[4][4]对应的值也是1，所以dp[4][4]=dp[3][3]+1……
  
  （别忘了还有一个前提，那就是正方形其他地方都是0！）
  
  因为我们已经假设了dp[3][3]已知，所以dp[3][3]对应的正方形保证了其他地方都是0，只需要考虑多出来的第四行与第四列所有地方是不是零就好了。
  
  因此转移方程就有三个限制条件量：
```
     1 dp[3][3]的值
     2 maze[4][4]左边有多少个连续的零
     3 maze[4][4]上面有多少个连续的零
     （还有一个基础条件就是maze[4][4]必须是1）
```
  转移方程：
  
  if(maze[i][j]==0) dp[i][j]=min(dp[i-1][j-1]+1，左边连续零的数量+1，上面连续零的数量+1)
  
  **最后别忘了对角线有两个方向！**
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,ans;
bool a[2505][2505],b[2505][2505]//分别存储对角线两个方向的情况;
int h[2505][2505],s[2505][2505]//预处理横向的连续零，上方的连续零;
int dp[2505][2505]；
int Dp(bool k[][2505])//处理函数
{
	int i,j;
	memset(s,0,sizeof(s));
	memset(h,0,sizeof(h));
	memset(dp,0,sizeof(dp));
	for(i=0;i<n;i++)
	{
		int cnt=0;
		for(j=0;j<m;j++)
		{
			if(k[i][j]==0) cnt++;
			else 
			{
				h[i][j]=cnt;
				cnt=0;
			}
		}
	}//预处理每个位置左边有多少个连续零
	for(i=0;i<m;i++)
	{
		int cnt=0;
		for(j=0;j<n;j++)
		{
			if(k[j][i]==0) cnt++;
			else 
			{
				s[j][i]=cnt;
				cnt=0;
			}
		}
	}//预处理每个位置上方有多少个连续零
	for(i=0;i<n;i++)
	{
		for(j=0;j<m;j++)
		{
			if(i==0||j==0) dp[i][j]=k[i][j];
			else if(k[i][j]==1) dp[i][j]=min(min(s[i][j]+1,h[i][j]+1),dp[i-1][j-1]+1);//转移方程
			ans=max(ans,dp[i][j])//返回最大值;
		}
	}
	return ans;
}
int main()
{
	cin>>n>>m;
	int i,j;
	for(i=0;i<n;i++)
	    for(j=0;j<m;j++) scanf("%d",&a[i][j]);//scanf比较省时间
	int ans1=Dp(a);
	for(i=0;i<n;i++)
	{
		for(j=0;j<m;j++)
			b[i][j]=a[i][m-j-1];
	}//反转初始数组，用以计算另一个方向上的对角线
    int ans2=Dp(b);
	cout<<max(ans1,ans2);
	return 0;
}
```


---

## 作者：NOIPOIER (赞：1)

```cpp
//第一篇题解，纪念AC100题
//较为类似搜索，剪了剪支，勉强过了，代码虽然极慢（#10 900+ms），但比较容易理解
#include<bits/stdc++.h>
using namespace std;
bool map1[2501][2501];//节省空间，虽然int不会炸
int m,n;
int maxn;
bool exam(int x,int y,int s_size/*大小*/)//判断函数
```
{//以X,Y为一端，向右下的对角线是否成立
    if(x+s\_size-1>m||y+s\_size-1>n)return 0;//越界直接回0
```cpp
    for(int i=0;i<s_size;i++)
    for(int j=0;j<s_size;j++)
    {
        if(i-j==0&&map1[x+i][y+j]==0)return 0;//对角线不为1，错误，退出
        else if(i-j!=0&&map1[x+i][y+j]==1)return 0;//非对角线点为1，退出
        }
        return 1; //到这的一定合法
}
bool sele(int x,int y,int s_size)//第二个，方向变成了左下
```
{//注释同上就不打了
    if(x+s\_size-1>m||y-s\_size+1<1)return 0;
```cpp
    for(int i=0;i<s_size;i++)
    for(int j=0;j<s_size;j++)
    {
        if(i-j==0&&map1[x+i][y-j]==0)return 0;
        else if(i-j!=0&&map1[x+i][y-j]==1)return 0;
        }
        return 1;
}
int main(){
    scanf("%d%d",&m,&n);//cin，cout会超
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
       scanf("%d",&map1[i][j]);//读表
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)//遍历每一个点
    {
        if(i>m-maxn){//当层数距离底部不足maxn时，一定找不到更优解
            printf("%d",maxn);
            return 0;
}
else {while(exam(i,j,maxn+1))maxn++;//只要amxn+1合法，继续搜
while(sele(i,j,maxn+1))maxn++;//两种情况都搜一下
}
    }
    printf("%d",maxn);//输出答案
    return 0;
}
```

---

## 作者：panda_2134 (赞：1)

DP+扫描法

首先给这个题分个类，方便发散思维。

这是一个二维平面上的dp，类似于最大子矩阵。我们试着用类似的思路思考。

二维平面上dp一般采用定区域左下/右下角，在这个点的周围寻找限制条件。

定义$$f(i,j,0)$$为以(i,j)为右下角的矩阵主对角线（左上->右下）合法最大长度。

于是显然有$$f(i,j,0)\leq f(i-1,j-1,0) + 1$$

技巧：把方块0绕着限制的区域转一圈。

 ![](https://cdn.luogu.com.cn/upload/pic/6782.png) 

然后我们就发现，$$f(i,j,0)$$还会受到$$(i,j)$$左侧和上方的最靠近它的那个1限制。

因为$$f(i-1,j-1,0)$$所代表的矩阵一定合法，所以考虑这个限制就可以保证$$f(i,j,0)$$合法，也就是除了主对角线之外没有其他地方有1。

因而就有$$f(i,j,0)\leq \min\{j-a_i,i-b_j\}$$,其中$$a_i$$是左侧最靠近当前位置的1的纵坐标

，$$b_j$$是上方最靠近当前位置的1的横坐标。扫描法维护即可，一边dp一边维护。

副对角线的情况完全类似，自己推一下好了233

不过有几点需要特别注意，见代码里面的注释。尤其是数组，dp用的数组我最开始开的2500\*2500\*5，最后一维大了点，而且交之前算的时候还忘了乘上int的4字节，直接MLE。。。

跑的还是挺快的，最后一个点303ms，总共1051ms

···cpp

    
    
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <algorithm>
#define REP(i,n) for(int i=1;i<=n;i++)
#define PER(i,n) for(int i=n;i>=1;i--)
#define CLEAR(x) memset(x,0,sizeof(x))
using namespace std;
const int MAXN=2500;
int N,M,ans,opt[MAXN+10][MAXN+10][2],a1[MAXN+10],b1[MAXN+10],a2[MAXN+10],b2[MAXN+10];
//大数组后面加小下标，开大多少要注意！ 
bool mp[MAXN+10][MAXN+10];
int readint(){
    int f=1,r=0;char c=getchar();
    while(!isdigit(c)){
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)){
        r=r*10+c-'0';
        c=getchar();
    }
    return f*r;
}
inline bool Init() {
    N=M=ans=0;
    CLEAR(opt);CLEAR(mp);CLEAR(a1);CLEAR(a2);CLEAR(b1);CLEAR(b2);
    if(scanf("%d%d",&N,&M)<2) return false;
    REP(i,N) REP(j,M) mp[i][j]=readint();
    return true;
}
inline void Work() {
    //一边dp一边刷数组
    REP(i,N) REP(j,M) 
    if(mp[i][j]) {
        opt[i][j][0]=min(opt[i-1][j-1][0]+1,min(j-a1[i],i-b1[j]));
        a1[i]=j,b1[j]=i;
    } 
    REP(i,N){
        a2[i]=M+1;//扫描法一定要多想初值！是否应该为0！找出所有情况下的数据，手算一下 
        PER(j,M)
        if(mp[i][j]) {
            opt[i][j][1]=min(opt[i-1][j+1][1]+1,min(i-b2[j],a2[i]-j));
            //如果不是必须的话不要省去数组，尤其是扫描法，
            //多次使用的滚动数组需要从头再开！因为扫描后值被破坏了！ 
            a2[i]=j,b2[j]=i;
        }
    }
    REP(i,N) REP(j,M) ans=max(ans,max(opt[i][j][0],opt[i][j][1]));
    printf("%d\n",ans);
}
int main() {
    while(Init()) Work();
}
···
```

---

## 作者：Shallowy (赞：1)

交了6遍才对。

我用f1表示从左上到右下以a[i,j]为终点的对角线的最大长度，f2则是从右上到左下的、、、

f[i,j]为横向的前缀和，ff[i,j]为纵向的前缀和。

所以，当满足条件时，

- f1[i,j]=f1[i-1,j-1]+1;

- f2[i,j]=f2[i-1,j+1]+1;

pascal代码

```cpp
uses math;
var
  n,m,i,j,k,ans:longint;
  a,f,ff,f1,f2:array[0..2500,0..2500] of 0..2500;
begin
  readln(n,m);
  for i:=1 to n do
    begin
      for j:=1 to m do
        begin
          read(a[i,j]);
          f[i,j]:=f[i,j-1]+a[i,j];
          ff[i,j]:=ff[i-1,j]+a[i,j];
        end;
      readln;
    end;
  for i:=1 to n do
    for j:=1 to m do
      if a[i,j]=1 then
         begin
           for k:=f1[i-1,j-1] downto 0 do     //一开始我直接判断，得了90...其实应该枚举一遍所有可能的
             if (f[i,j-1]-f[i,j-k-1]=0) and (ff[i-1,j]-ff[i-k-1,j]=0) then    //画个图模拟一下就懂了
               begin
                 f1[i,j]:=k+1;
                 break;     //倒序枚举的优化，不过效率好像也没怎么快...
               end;
           for k:=f2[i-1,j+1] downto 0 do    //以下同上
             if (f[i,j+k]-f[i,j]=0) and (ff[i-1,j]-ff[i-k-1,j]=0) then
               begin
                 f2[i,j]:=k+1;
                 break;
               end;
           ans:=max(ans,max(f1[i,j],f2[i,j]));    //求答案
         end;
  write(ans);
end.

```

---

## 作者：zhangjl (赞：1)

我用的是枚举..不过对于此题的弱数据是不会超时/空间的..

注释在代码中,祭我大pascal

```delphi

var  
  n,m:longint;  
  map:array[1..2500,1..2500]of integer;  
  f:array[0..2501,0..2501]of integer;  
  left,up,down:array[0..2501,0..2501]of integer; 
 
function min(a,b:longint):longint;  
begin  
  if a>b then exit(b);  
  exit(a);  
end;  
  
procedure main;  
var  
  i,j,k:longint;  
  ans:longint;  
begin  
  readln(n,m);  
  ans:=0;  
  fillchar(left,sizeof(left),0);  
  fillchar(up,sizeof(up),0);  
  fillchar(down,sizeof(down),0);  
    
  for i:=1 to n do  
    for j:=1 to m do  
      begin  
        read(map[i,j]);  
        if map[i,j]=1 then  
          begin  
          left[i,j]:=0;  
            up[i,j]:=0;  
          end  
          else  
          begin  
            left[i,j]:=left[i,j-1]+1;  //维护向左可以有几个  
            up[i,j]:=up[i-1,j]+1;      //维护向上可以有几个  
          end;  
      end;  
        
  for i:=n downto 1 do  
    for j:=1 to m do  
      if map[i,j]=1 then  
        begin  
          down[i,j]:=0;  
        end  
        else  
        begin  
          down[i,j]:=down[i+1,j]+1;    //维护向下可以有几个..  
        end;  
          
  fillchar(f,sizeof(f),0);  
  for i:=1 to n do  
    for j:=1 to m do        //枚举右下角  
     if map[i,j]=1 then  
        begin  
          f[i,j]:=left[i,j-1]+1;  
          if f[i,j]>f[i-1,j-1]+1 then f[i,j]:=f[i-1,j-1]+1;  
          if f[i,j]>up[i-1,j]+1 then f[i,j]:=up[i-1,j]+1;  
          if f[i,j]>ans then ans:=f[i,j];  
        end;  
          
  fillchar(f,sizeof(f),0);  
  for i:=n downto 1 do         //枚举左上角.  
    for j:=1 to m do  
      if map[i,j]=1 then  
        begin  
          f[i,j]:=left[i,j-1]+1;  
          if f[i,j]>f[i+1,j-1]+1 then f[i,j]:=f[i+1,j-1]+1;  
          if f[i,j]>down[i+1,j]+1 then f[i,j]:=down[i+1,j]+1;  
          if f[i,j]>ans then ans:=f[i,j];  
        end;  
  writeln(ans);  
end;  
  
begin  
  main;   
end.  

```

下面的没有被框起来哦

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

 
  
    
        
          
          
  


```cpp
var  
  n,m:longint;  
  map:array[1..2500,1..2500]of integer;  
  f:array[0..2501,0..2501]of integer;  
  left,up,down:array[0..2501,0..2501]of integer; 
function min(a,b:longint):longint;  
begin  
  if a>b then exit(b);  
  exit(a);  
end;  
procedure main;  
var  
  i,j,k:longint;  
  ans:longint;  
begin  
  readln(n,m);  
  ans:=0;  
  fillchar(left,sizeof(left),0);  
  fillchar(up,sizeof(up),0);  
  fillchar(down,sizeof(down),0);  
  for i:=1 to n do  
    for j:=1 to m do  
      begin  
        read(map[i,j]);  
        if map[i,j]=1 then  
          begin  
          left[i,j]:=0;  
            up[i,j]:=0;  
          end  
          else  
          begin  
            left[i,j]:=left[i,j-1]+1;  //维护向左可以有几个  
            up[i,j]:=up[i-1,j]+1;      //维护向上可以有几个  
          end;  
      end;  
  for i:=n downto 1 do  
    for j:=1 to m do  
      if map[i,j]=1 then  
        begin  
          down[i,j]:=0;  
        end  
        else  
        begin  
          down[i,j]:=down[i+1,j]+1;    //维护向下可以有几个..  
        end;  
  fillchar(f,sizeof(f),0);  
  for i:=1 to n do  
    for j:=1 to m do        //枚举右下角  
     if map[i,j]=1 then  
        begin  
          f[i,j]:=left[i,j-1]+1;  
          if f[i,j]>f[i-1,j-1]+1 then f[i,j]:=f[i-1,j-1]+1;  
          if f[i,j]>up[i-1,j]+1 then f[i,j]:=up[i-1,j]+1;  
          if f[i,j]>ans then ans:=f[i,j];  
        end;  
  fillchar(f,sizeof(f),0);  
  for i:=n downto 1 do         //枚举左上角.  
    for j:=1 to m do  
      if map[i,j]=1 then  
        begin  
          f[i,j]:=left[i,j-1]+1;  
          if f[i,j]>f[i+1,j-1]+1 then f[i,j]:=f[i+1,j-1]+1;  
          if f[i,j]>down[i+1,j]+1 then f[i,j]:=down[i+1,j]+1;  
          if f[i,j]>ans then ans:=f[i,j];  
        end;  
  writeln(ans);  
end;  
begin  
  main;   
end.  
建议只作借鉴
```

---

## 作者：jiangyougogogo (赞：1)

测试点 #10：通过该测试点。 得分10，**耗时1497ms，内存127377kB。**


贴出我的运行实况，不知道最后一个点1.5s是怎么跑过去的……


题目比较有趣，说白了就是**求一个最大的矩阵，使其一条对角线上全都是1，其余全0**


我用了一种**非常烧时空**的办法


**用五个二维数组：**a存01矩阵，lleft,rright,up就是求这个点（含自身）的左、右、上方向各有几个连续的0（这个可以用O(nm)递推求得），f就是求答案（dp）用的


由于对角线有两个方向（""和"/"），要扫两次


**dp方程：**if (a[i][j]==1)

**对于“\”对角线** f[i][j]=min(f[i-1][j-1],lleft[i][j-1],up[i-1][j])+1

**对于“/”对角线** f[i][j]=min(f[i-1][j+1],lleft[i][j+1],up[i-1][j])+1


if (a[i][j]==0) f[i][j]=0

于是就——可以了

时间上要做8×2500×2500=5×10^8次O(1)运算，空间烧了119.3M（我想你在上面也看到了）


SourceCode（写得烂别怪我……）**勿抄！**（虽然我也相信大家都是守信用的，还是要提醒一下）

```cpp

#include 
#include <algorithm>
#define M 2501
using namespace std;
int n,m,a[M][M],up[M][M],lleft[M][M],rright[M][M],f[M][M],ans,i,j;
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)for(j=1;j<=m;j++)scanf("%d",&a[i][j]);
//读入（cin怕炸了用scanf）
    for(i=1;i<=n;i++)for(j=1;j<=m;j++)if(!a[i][j])up[i][j]=up[i-1][j]+1;
    for(i=1;i<=n;i++)for(j=1;j<=m;j++)if(!a[i][j])lleft[i][j]=lleft[i][j-1]+1;
    for(i=1;i<=n;i++)for(j=m;j>=1;j--)if(!a[i][j])rright[i][j]=rright[i][j+1]+1;
//上面是三段递推，我想你懂的，没懂的手动模拟
    for(i=1;i<=n;i++)for(j=1;j<=m;j++)if(a[i][j]){f[i][j]=min(f[i-1][j-1],min(up[i-1][j],lleft[i][j-1]))+1;ans=max(ans,f[i][j]);}
    memset(f,0,sizeof(f));
    for(i=1;i<=n;i++)for(j=m;j>=1;j--)if(a[i][j]){f[i][j]=min(f[i-1][j+1],min(up[i-1][j],rright[i][j+1]))+1;ans=max(ans,f[i][j]);}
//以上是两段dp，方程上面也写过，就不多说了
    printf("%d\n",ans);
    return 0;    
}

```

第一次来发题解，若有错误或冒犯了谁，恳请指正（欢迎发我私信指出）


**3Q！**


---

## 作者：fltflt1 (赞：1)

DP
由于本人非常弱，用了一种很暴力的DP（各路神犇请略过次题解）

f1[i][j]表示从左上角到右下角的对角线最长的合法矩阵大小

f2[i][j]表示从右上角到左下角。。。。。。。。。。。。。

然后这样转移的时候起来非常方便。。

代码君。。。。（有些丑陋）

（#include<stdio.h>

```（c/c++）
```
#include<algorithm>    
using namespace std;    
int f[2503][2503],f2[2503][2503],a[2503][2503],n,m,ans,x[2503][2503],y[2503][2503],t;    
int main()    
{    
    scanf("%d%d",&n,&m);    
    for (int i=1;i<=n;i++)    
        for (int j=1;j<=m;j++)    
            scanf("%d",&a[i][j]);    
    for (int i=1;i<=n+2;i++)    
        for (int j=1;j<=m+2;j++)    
            if (a[i][j])    
                x[i][j]=x[i][j-1]+1;    
            else    
                x[i][j]=x[i][j-1];    
    for (int j=1;j<=m+2;j++)    
        for (int i=1;i<=n+2;i++)    
            if (a[i][j])    
                y[i][j]=y[i-1][j]+1;    
            else    
                y[i][j]=y[i-1][j];    
    for (int i=1;i<=n;i++)    
        for (int j=1;j<=m;j++)    
        {    
            if (a[i][j])    
                f[i][j]=1;    
            else    
                continue;    
            f[i][j]=max(f[i][j],f[i-1][j-1]+1);    
            t=0;  
            while ((y[i][j]!=y[i-f[i][j]+t][j]+1)||(x[i][j]!=x[i][j-f[i][j]+t]+1))    
                t++;  
            f[i][j]-=t;    
            ans=max(f[i][j],ans);    
        }  
    for (int i=1;i<=n;i++)    
        for (int j=m;j>=1;j--)    
        {    
            if (a[i][j])    
                f2[i][j]=1;    
            else    
                continue;    
            f2[i][j]=max(f2[i][j],f2[i-1][j+1]+1);   
            t=0;   
            while ((y[i][j]!=y[i-f2[i][j]+t][j]+1)||(x[i][j]!=x[i][j+f2[i][j]-1-t]))    
                t++;  
            f2[i][j]-=t;  
            ans=max(f2[i][j],ans);    
        }    
    printf("%d\n",ans);    
    return 0;    
}   )

```cpp

---

## 作者：新手7889456 (赞：0)

~~我就想说一句，我的DP是真的辣鸡~~

楼下大佬用的是DP

## 在这里，我用的是搜索

简单陈述一下思路：

1.找到每一个有鱼的点，并开始搜索；

2.然后根据题意，每次确定一个答案长度来判断，结束后更新答案。

这时候，你会发现时间复杂度是很恐怖的。

然后开始剪枝：

1.从答案长度开始判断；

2.判断第一次完之后，只需要判断新加入的某一行与某一列（注意：第一次不能这样）；

详情看代码和注释：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,ans;
bool map[2501][2501];//存图
int main()
{
	cin>>n>>m;
	register int k,kk;
	bool ok;
	for(register int i(1);i<=n;++i){
		for(register int j(1);j<=m;++j){
			scanf("%d",&map[i][j]);//读入
			if(map[i][j]&&i>ans&&j>ans){//如果有鱼，而且长度足以更新答案
				ok=0;
				for(kk=i-ans;kk<=i;++kk){//从可更新的长度开始
					if(ok) break;
					for(k=j-ans;k<=j;++k){
						if(i-kk==j-k){//判断是否在对角线上
							if(!map[kk][k]){
								ok=1;
								break;
							}
							continue;
						}
						if(map[kk][k]){//鱼塘其他处有鱼
							ok=1;
							break;
						}
					}
				}
				if(!ok){
					ans++;//答案自增
					while(i>ans&&j>ans&&ok){//接着更新答案
						if(!map[i-ans][j-ans]) break;//对角线上没有鱼
						for(kk=i-ans;kk<=i;++kk){//列
							if(map[kk][j-ans]){
								ok=1;
								break;
							}
						}
						for(kk=j-ans;kk<=j;++kk){//行
							if(map[i-ans][kk]){
								ok=1;
								break;
							}
						}
						if(!ok) ++ans;
					}
				}
			}
		}
	}
	for(register int i(1);i<=n;++i){//自左下角到右上角，上面是从右下角到左上角，注意这个应该读完后进行
		for(register int j(1);j<=m;++j){//其余的道理同上
			if(map[i][j]&&i>ans&&m-j>ans){
				ok=0;
				for(kk=i-ans;kk<=i;++kk){
					if(ok) break;
					for(k=j;k<=j+ans;++k){
						if(kk+k==i+j){
							if(!map[kk][k]){
								ok=1;
								break;
							}
							continue;
						}
						if(map[kk][k]){
							ok=1;
							break;
						}
					}
				}
				if(!ok){
					ans++;
					while(i>ans&&m-j>ans&&ok){
						if(!map[i-ans][j+ans]) break;
						for(kk=i-ans;kk<=i;++kk){
							if(map[kk][j-ans]){
								ok=1;
								break;
							}
						}
						for(kk=j;kk<=j+ans;++kk){
							if(map[i-ans][kk]){
								ok=1;
								break;
							}
						}
						if(!ok) ++ans;
					}
				}
			}
		}
	}
	printf("%d",ans);//输出
	return 0;
}
```

向管理求过。。。


---

## 作者：　Lzr (赞：0)

# 这题没那么难，其实考的就是细节qwq

######  _蒟蒻的强行分析开始辣_ 

1.显然，dp[i][j]的最大值只与dp[i - 1][j - 1]及dp[i - 1][j + 1]有关，而又因为两种决策意味着两条不同的对角线，要分开处理，所以我们有：

```cpp
dp[i][j] = max(dp[i - 1][j - 1] + 1,dp[i][j]);
dp2[i][j] = max(dp2[i - 1][j + 1] + 1,dp2[i][j]);
```

2.因为题面有：

```
且此正方形子矩阵的其他地方无鱼
```
所以可以转化为：
```
在[i - p][j - p][i][j]矩形中，只能有p + 1条鱼
```
3.注意到m,n的数据范围为 n,m <= 2500，所以枚举判断biss，故我们可以搞一个前缀和来判断矩阵区间内的鱼量：

```cpp
sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + nmap[i][j];
getsum(a,b,x,y) = sum[x][y] - sum[x][b - 1] - sum[a - 1][y] + sum[a - 1][b - 1];//建议画图理解pwp

```

然后大家就可以开始快乐的动~~龟~~规辣！

```cpp
#include<bits/stdc++.h>
using namespace std;
 //1736
int n,m,ans;
bool nmap[2510][2510];
int sum[2510][2510],dp[2510][2510],dp2[2510][2510];

int getsum(int a,int b,int x,int y){
    return sum[x][y] - sum[x][b - 1] - sum[a - 1][y] + sum[a - 1][b - 1];
}

int main(){
    cin >> n >> m;
    for(int i = 1;i <= n;++i){
        for(int j = 1;j <= m;++j){
            scanf("%d",&nmap[i][j]);
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + nmap[i][j];
            dp[i][j] = dp2[i][j] = nmap[i][j];
        }
    }
    for(int i = 1;i <= n;++i){
        for(int j = 1;j <= m;++j){
            if(nmap[i][j] && !nmap[i - 1][j]){ //第二个条件要写，俺p9的TLE就是惨死在这
                if(nmap[i - 1][j - 1] && !nmap[i][j - 1]){ //并无卵用的剪枝
                	int t1 = i - 1, t2 = j - 1;
                    /*这里可能不是很理解（俺调了将近1h:)
                    如果(i,1)或(1,j)上存在鱼的话，就不符合题目要求，需要从上一个点开始转移
                	while(dp[t1][t2] && getsum(i - dp[t1][t2],j - dp[t1][t2],i,j) != dp[t1][t2] + 1 && t1 >= 1 && t2 >= 1) --t1, --t2;
                    dp[i][j] = max(dp[t1][t2] + 1,dp[i][j]);
				}
                    
                if(nmap[i - 1][j + 1] && !nmap[i][j + 1]){ //右上角的斜线
                	int t1 = i - 1, t2 = j + 1;
                	while(dp[t1][t2] && getsum(i - dp2[t1][t2],j,i,j + dp2[t1][t2]) != dp2[t1][t2] + 1 && t1 >= 1 && t2 <= m) --t1, ++t2;
                    dp2[i][j] = max(dp2[t1][t2] + 1,dp2[i][j]);
				}
                    
                
                ans = max(max(dp[i][j],dp2[i][j]),ans);
            }
        }
    }
    cout << ans << endl;
    /*for(int i = 1;i <= n;++i){
    	for(int j = 1;j <= m;++j) cout << dp[i][j] << " ";
    	cout << endl;
	}
	cout << endl;
	for(int i = 1;i <= n;++i){
    	for(int j = 1;j <= m;++j) cout << dp2[i][j] << " ";
    	cout << endl;
	}*/
}
```

### 欢淫各位hack || 斧正 || 提建议



---

## 作者：Holy_Push (赞：0)

其实大致思想也是预处理+二分的$n^2logn$算法（因为这种方法不需要动脑子）

在具体实现的时候我们枚举每一个点$(x,y)$，然后二分以它为左上角的正方形的边长，然后判断。判断主要分为两个部分：

$1.$矩形内只有某个对角线有$1$。

$2.$矩形内某条对角线上全都是$1$。

$(1)$可以用二维前缀和预处理一下，这样就可以$O(1)$判断了。

$(2)$对角线实际上也可以用前缀和。我们发现向右下角斜的对角线具有的特征是$y-x$为定值，向左下角斜的对角线具有的特征是$y+x$为定值。分别记录一下求个前缀和即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5002;

int n,m,sum,a[N][N/2],c[N][N/2],b[N/2][N/2];

int main()
{
	scanf("%d%d",&n,&m);int g=max(n,m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			int x;char s=getchar();
			while (s<'0'||s>'1') s=getchar();
			x=s-'0';
			a[j-i+g][i]=a[j-i+g][i-1]+x;
			c[i+j][i]=c[i+j][i-1]+x;
			b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+x;
		}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			if (a[j-i+g][i]==a[j-i+g][i-1]+1)
			{
				int l=0,r=min(n-i+1,m-j+1),ans=0;
				while (l<=r)
				{
					int mid=(l+r)>>1;
					if (a[j-i+g][i+mid]-a[j-i+g][i-1]==mid+1&&b[i+mid][j+mid]-b[i-1][j+mid]-b[i+mid][j-1]+b[i-1][j-1]==mid+1)
						ans=mid,l=mid+1;else r=mid-1;
				}
				sum=max(ans+1,sum);
			}
			if (c[i+j][i]==c[i+j][i-1]+1)
			{
				int l=0,r=min(n-i+1,m),ans=0;
				while (l<=r)
				{
					int mid=(l+r)>>1;
					if (c[i+j][i+mid]-c[i+j][i-1]==mid+1&&b[i+mid][j]-b[i-1][j]-b[i+mid][j-mid-1]+b[i-1][j-mid-1]==mid+1)
						ans=mid,l=mid+1;else r=mid-1;
				}
				sum=max(ans+1,sum);
			}
		}
	printf("%d\n",sum);
}
```


---

## 作者：Seauy (赞：0)

# 此题可以用神奇的 2-pointer 做

## 1. What was it

2-pointer 有个比较生动形象的名字叫做 蠕动区间，直面可以理解为 双指针。

用两个指向数组角标的指针 $ [L,R] $ 来表示一个区间，一开始 L=R=1。

### 2-pointer 适用于符合以下条件的题型：

1. 求长度为 n 的数列中满足“命题 a” 的所有区间中，最“命题 b”的区间

2. 一般来说区间越长越容易满足“命题 a”，越短越满足“命题 b”

### 具体操作是：

1. 当区间不符合“命题 a”时，增长 / 缩小 区间， $ R++ / L++ $。

2. 当区间符合“命题 a”时，缩小 / 增长 区间，$ L++ / R++ $。

3. 每次记录按照“命题 b”定义下的最优解。

4. 直到 $ R>n $ ，停止计算。

途中保证 $ L<=R $ ，这也是必然的。

可见这是个基于贪心的数据结构（它不是算法而是个数据结构！），可以证明它遍历了所有可能产生最优解的区间。

### 做几道水题感受一下：

[P1638](https://www.luogu.org/problem/P1638)

[P2564](https://www.luogu.org/problem/P2564)

[P3029](https://www.luogu.org/problem/P3029)

## 2. 怎么运用到这题上

简化题意： 找到最大的正方形满足只有一个对角线上有 1，且其它地方没有 1，要填满这个对角线

对角线不就是斜线嘛，最大的正方形对应的就是对角线（45°角斜线）最长喽

转化题意： 找到最长的全是 1 的斜线，使得其对应正方形内其它地方没有 1

### 套到 2-pointer 上，题目可以翻译成以下内容：

 _命题 a = 找到全是 1 的斜线，使得其对应正方形内其它地方没有 1_ 

 _命题 b = 斜线要最长_ 
 
### 再代进操作中：

1. 当斜线不符合“全是 1，其对应正方形内其它地方没有 1”时，缩小区间， $ L++ $。

2. 当斜线符合“全是 1，其对应正方形内其它地方没有 1”时，增大区间，$ R++ $。

3. 每次记录“斜线长度”的最大值。

4. 直到 $ R>n $ ，停止计算。

原来的数列变成 $ n×m $ 矩阵中的所有斜线。这些斜线有“/”的，也有“\”的，分别处理。左右区间都变成点坐标，区间增长与缩短变成沿斜线运动。

## 3. 如何判断 命题 a

“全是 1，其对应正方形内其它地方没有 1”这个命题可以拆成两部分：

### (1) 全是 1

这个可以在区间的运动中保证。内部没有 0 的区间，碰到是 0 的格子，果断跳过，直到找到为 1 的格子或者跳出了矩阵。

### (2) 其对应正方形内其它地方没有 1

就是正方形区域内所有数之和 = 正方形边长，用二维前缀和计算。


------------

接下来就可以愉快地写代码了：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int Size=2500;

bool inscp(int bef,int ob,int aft)
{return bef<=ob && ob<=aft;}

struct Point
{
	int x,y;
	void Print() {printf("%d %d\n",x,y);}
};

int n,m,ans;
bool mapn[Size+5][Size+5];
int pre[Size+5][Size+5];

bool inarea(Point ob)
{return inscp(1,ob.x,m) && inscp(1,ob.y,n);}

int Sum(int xL,int yU,int xR,int yD)
{return pre[yD][xR]-pre[yD][xL-1]-pre[yU-1][xR]+pre[yU-1][xL-1];}

int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>mapn[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			pre[i][j]=mapn[i][j]+pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1];
	//printf("%d\n",Sum(4,1,6,3));
	for(int i=1;i<=m;i++)
	{
		Point LU=Point{i,1};//左上角坐标
		int len=1;//正方形边长
		while(inarea(Point{LU.x+len-1,LU.y+len-1}))
		{
			if(!mapn[LU.y+len-1][LU.x+len-1])
			{
				LU=Point{LU.x+len-1,LU.y+len-1};
				while(!mapn[LU.y][LU.x])
				{
					LU.x++,LU.y++;
					if(!inarea(LU)) break;
				}//出来的时候保证 mapn[LU.y][LU.x]==1
				len=1;
				continue;
			}
			if(Sum(LU.x,LU.y,LU.x+len-1,LU.y+len-1)>len)//其它地方多出了鱼
			{
				LU.x++,LU.y++;
				len--; 
			}
			else
			{
				ans=max(ans,len);
				len++;
			}
		}
	}
	for(int i=2;i<=n;i++)
	{
		Point LU=Point{1,i};//左上角坐标
		int len=1;//正方形边长
		while(inarea(Point{LU.x+len-1,LU.y+len-1}))
		{
			if(!mapn[LU.y+len-1][LU.x+len-1])
			{
				LU=Point{LU.x+len-1,LU.y+len-1};
				while(!mapn[LU.y][LU.x])
				{
					LU.x++,LU.y++;
					if(!inarea(LU)) break;
				}//出来的时候保证 mapn[LU.y][LU.x]==1
				len=1;
				continue;
			}
			if(Sum(LU.x,LU.y,LU.x+len-1,LU.y+len-1)>len)//其它地方多出了鱼
			{
				LU.x++,LU.y++;
				len--; 
			}
			else
			{
				ans=max(ans,len);
				len++;
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		Point RU=Point{i,1};//右上角坐标
		int len=1;//正方形边长
		while(inarea(Point{RU.x-len+1,RU.y+len-1}))
		{
			if(!mapn[RU.y+len-1][RU.x-len+1])
			{
				RU=Point{RU.x-len+1,RU.y+len-1};
				while(!mapn[RU.y][RU.x])
				{
					RU.x--,RU.y++;
					if(!inarea(RU)) break;
				}//出来的时候保证 mapn[LU.y][LU.x]==1
				len=1;
				continue;
			}
			if(Sum(RU.x-len+1,RU.y,RU.x,RU.y+len-1)>len)//其它地方多出了鱼
			{
				RU.x--,RU.y++;
				len--;
			}
			else
			{
				ans=max(ans,len);
				len++;
			}
		}
	}
	for(int i=2;i<=n;i++)
	{
		Point RU=Point{m,i};//右上角坐标
		int len=1;//正方形边长
		while(inarea(Point{RU.x-len+1,RU.y+len-1}))
		{
			if(!mapn[RU.y+len-1][RU.x-len+1])
			{
				RU=Point{RU.x-len+1,RU.y+len-1};
				while(!mapn[RU.y][RU.x])
				{
					RU.x--,RU.y++;
					if(!inarea(RU)) break;
				}//出来的时候保证 mapn[LU.y][LU.x]==1
				len=1;
				continue;
			}
			if(Sum(RU.x-len+1,RU.y,RU.x,RU.y+len-1)>len)//其它地方多出了鱼
			{
				RU.x--,RU.y++;
				len--;
			}
			else
			{
				ans=max(ans,len);
				len++;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
你用了神奇数据结构过了 搜索+dp 的蓝题，是不是很鸡冻嘞？

---

## 作者：Kevin5308 (赞：0)

#### ~~本蒟蒻第一次AC此难度的题……~~
给大家介绍的算法相对前排大佬，明显低效的多，时间复杂度O（n^2logn）有兴趣的OIER们可以看看，不喜勿喷！
## 主要思路：dp+二分
#### dp的基本思路还是比较简单的：
 f[i][j]表示以i,j为右下角最多吃到的鱼
 
 f1[i][j]表示以i,j为左下角最多吃到的鱼
 
~~那么显然：~~
 ```cpp
f[i][j]=f[i-1][j-1]+1;
f1[i][j]=f1[i-1][j+1]+1;
```
### 但是！
- 如果某个正方形子矩阵的某条对角线上都有鱼，**且此正方形子矩阵的其他地方无鱼**，猫猫就可以从这个正方形子矩阵“对角线的一端”下口！

这该怎么判断呢？？！

本人第一时间，想到了二维前缀和：
```cpp
s[i][j]=s[i][j-1]+s[i-1][j]-s[i-1][j-1]+a[i][j];
```
那么，只要我们在转移之前，判断：**如果该矩阵的所有数的和等于这条对角线的长度，就转移；否则，赋值为1！**

本蒟~~非常happy，信心十足地~~上交了，80……

不断调试中，发现了问题！
例如这个矩阵：

1 0 1

0 1 0

1 0 0

我们做的时候，显然dp[1][1]=1;dp[1][3]=1;dp[2][2]=2;

但是当dp[3][1]转移的时候，因为dp[2][2]+1,即边长为3的矩阵里有其他的1，所以将不会更新，默认为1!

### 所以！开始二分！
我们二分正方形矩阵的大小，判断是否符合要求，符合就记录下来，不断更新，找到符合要求的最大矩阵！

思路就是这样，代码（c++）
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[2510][2510],f[2510][2510],f1[2510][2510],s[2510][2510];

int check(int x,int y,int xx,int yy,int f){
	int l=x,r=y,ans=0;
	while(l<=r){
		int mid=(l+r)/2;
		int i=xx,j=yy;
		if (f==1) j+=mid-1;//如果是左下角判断，强制更改为右下角，计算方便
		int sum=s[i][j]-s[i-mid][j]-s[i][j-mid]+s[i-mid][j-mid];
		if (sum==mid){
			l=mid+1;
			ans=mid;
		}
		else r=mid-1;//二分判断
	}
	return ans;
}

int main()
{
//	freopen("fish.in","r",stdin);
//	freopen("fish.out","w",stdout);
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++){
    	    scanf("%d",&a[i][j]);
    	    s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//前缀和，之前已经介绍过了
		}
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
 		    if (a[i][j]==1){
 		    	f[i][j]=1;
		        f1[i][j]=1;
 		    	if (a[i-1][j-1]==1) {//右下角判断
 		    		int tt=f[i-1][j-1]+1;
					int t=check(1,tt,i,j,0);
 		    		f[i][j]=max(f[i][j],t);
				 }
 		    	if (a[i-1][j+1]==1) {//左下角判断
 		    		int tt=f1[i-1][j+1]+1;
 		    		int t=check(1,tt,i,j,1);
 		    		f1[i][j]=max(f1[i][j],t);
				 } 
			 }
    int ans=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            ans=max(ans,max(f[i][j],f1[i][j]));
    printf("%d\n",ans);
	return 0;
}
```


---

## 作者：duyyyy (赞：0)

这是一种无需DP的算法
用了两种前缀和思想（以及二分答案）

我们考虑一个边长为x的正方形，它是符合题意的，当且仅当：

		1.这个正方形中1的个数为x
    	2.一条对角线上1的个数为x
以上两条同时成立

我们检查条件1，很容易就能想到是矩阵前缀和，O(nm)预处理即可

至于条件2，我们想得到的是一条斜线上的一段连续区间的和。如果这条线是水平的，那么和普通的前缀和没有任何区别，所以我们考虑 左下-右上 这样一条斜线，很容易发现: 同一条斜线上的点，都满足横纵坐标之和相同，那么我们就可以把这个和作为这条直线的id，去做前缀和检查即可

因此，我们预处理：
	
    	s[i][j] 代表以(1,1)和(i,j)为顶点的矩形所含1的数量
 		sa[i][j] 代表坐标和为i+1这一条斜线上前j项的和，即sa[i][j]=∑data(i-k+1,k),1<=k<=j

也就是说，我们对于（左上）顶点(i,j)，边长为x的正方形,只需有

s[i+x-1][j+x-1]-s[i+x-1][j-1]-s[i-1][j+x-1]+s[i-1][j-1] == x

和 sa[i+j+x-2][j+x-1] - sa[i+j+x-2][j-1] == x

对于左上-右下对角线，~~懒得写差为定值的斜线前缀和了~~，左右对称一下就好

时间复杂度大概是O(nmlog(min(m,n)))
需要注意的是数组别开太大，容易MLE

一份比较丑的AC代码：
```cpp
#include<stdio.h>
using namespace std;
const int maxN = 2500;
short int ans = -1, a[maxN+3][maxN+3] = {0}, n, m, sa[maxN*2+3][maxN+3] = {0};
int s[maxN+3][maxN+3] = {0};
inline int maxx(int x, int y)
{return x > y ? x : y;}
inline int minn(int x, int y)
{return x < y ? x : y;}
inline void swap(short int &x, short int &y)
{
    int z = x;
    x = y;
    y = z;
}
inline bool chk(int x)
{
    for(int i = 1; i+x-1 <= n; i++)
        for(int j = 1; j+x-1 <= m; j++)
            if(s[i+x-1][j+x-1]-s[i+x-1][j-1]-s[i-1][j+x-1]+s[i-1][j-1] == x && sa[i+j+x-2][j+x-1] - sa[i+j+x-2][j-1] == x)
                return 1;
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    int left, right, mid;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            scanf("%d",&a[i][j]);
    loop:
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
    for(int i = 1; i < n+m; i++)
        for(int j = maxx(1,i-n+1); j <= i && j <= m; j++)  // (i,1),(i-j+1,j)
            sa[i][j] = sa[i][j-1] + a[i-j+1][j];
    left = 0, right = minn(n,m);
    while(left < right)
    {
        mid = (left+right+1) >> 1;
        if(chk(mid))
            left = mid;
        else
            right = mid-1;
    }
    if(ans == -1)
    {
        ans = left;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m/2; j++)
                swap(a[i][j],a[i][m+1-j]);
        goto loop;
    }
    else
    {
        ans = maxx(ans,left);
        printf("%d\n",ans);
    }
    return 0;	
}
```


---

## 作者：文文殿下 (赞：0)

做法：暴力枚举点$(x,y)$ 然后暴力扩展。

以向右下方扩展为例，当$(x+k,y+k)$向$(x+k+1,y+k+1)$扩展时，需要检验两个地方：$(x+k,y+k+1)\sim(x-1,y+K+1)$和$(x+k+1,y-1)\sim(x+k+1,y+k)$是否有$1$。

可以发现，需要验证的地方是一段连续的序列，我们考虑使用前缀和对其进行求和，观察求和结果是否为$0$来决定是否继续扩展。

理论上最坏复杂度$O(n^3)$,可以证明，不存在一组数据，可以使算法达到复杂度上届。

证明：

  对于每个位置，考虑是否转移，显然最多转移$n$次，如果可以转移，那么下一个数必然为$1$，如果下一个数为$1$，那么对于其他一个位置，必然无法转移(相当于横断了左上方以及右上方所有点的转移路径)。那么，对于每一个点，显然只能导致左上方和右上方各一次的转移，那么对于所有的点，每次转移前缀和维护常数是O(1)的，那么枚举复杂度为$O(n^2)$
  
总复杂度:$$O(n^2+n^2+n^2+2n^2)=O(n^2)$$

四个$n^2$分别为：读入，求前缀和，枚举起点，每个点的转移


细节：注意考虑长度为$1$(即不扩展)的情况，特判

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const int maxn = 2510;
int mp[maxn][maxn];
int sum1[maxn][maxn],sum2[maxn][maxn];
int n,m;
int main() {
	scanf("%d%d",&n,&m);
	for(int i = 1;i<=n;++i)
		for(int j = 1;j<=m;++j)
			scanf("%d",&mp[i][j]);
	for(int i = 1;i<=n;++i) {
		for(int j = 1;j<=m;++j) {
			sum2[i][j]=sum2[i][j-1]+mp[i][j];
			sum1[i][j]=sum1[i-1][j]+mp[i][j];
		}
	}
	int ans = 0;
	for(int i = 1;i<=n;++i) {
		for(int j = 1;j<=m+1;++j) {
			if(mp[i][j]){ans=std::max(ans,1);
			for(int k = 1;k+i<=n&&k+j<=m;++k) {
				if(mp[i+k][j+k]&&sum1[i+k-1][j+k]-sum1[i-1][j+k]==0&&sum2[i+k][j+k-1]-sum2[i+k][j-1]==0) {
					ans=std::max(ans,k+1);
				}
				else break;
			}
			}
		}
	}
	for(int i = 1;i<=n;++i) {
		for(int j = 1;j<=m;++j) {
			if(mp[i][j]) {
				for(int k = 1;k+i<=n&&j-k>=1;++k) {
					if(mp[i+k][j-k]&&sum1[i+k-1][j-k]-sum1[i-1][j-k]==0&&sum2[i+k][j]-sum2[i+k][j-k]==0) ans=std::max(ans,k+1);
					else break;
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：ttt_TTT (赞：0)

~~蒟蒻第一次发题解，求过~~

一道dp题目
我们设以(i,j)(i,j)结尾的最长对角线的最大长度为f(i,j)f(i,j)
通过观察可以知道影响f(i,j)f(i,j)的情况有两种，一个是左上角转移过来，一个是右上角转移过来。不妨来讨论下从左上角转移过来的
f(i,j)f(i,j)受三个因素影响：

以(i-1,j-1)结尾的最长连续1长度
向左延伸的最大0长度
向上延伸的最大0长度
我们只要取个min即可,对于每一个状态，我们要保证对角线周围是没有1的。
所以可以写出方程:f(i,j)=min{f(i−1,j−1),ls(i,j),rs(i,j)}+1f(i,j)=min{f(i−1,j−1),ls(i,j),rs(i,j)}+1其中ls为从(i,j−1)(i,j−1)开始延伸的0长度；rs为从f(i−1,j)f(i−1,j)开始延伸的0长度。

最后
~~你们最想要的代码~~

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,f[2510][2510],a[2510][2510]= {0},ls[2510][2510],rs[2510][2510],us[2510][2510],ans=0;

int main() {
    while(~scanf("%d%d",&m,&n)) {
        int ans=0;
        memset(f,0,sizeof(f));
        memset(ls,0,sizeof(ls));
        memset(rs,0,sizeof(rs));
        memset(us,0,sizeof(us));
        for(int i=1; i<=m; i++)
            for(int j=1; j<=n; j++) {
                scanf("%d",&a[i][j]);
                if(!a[i-1][j])
                    us[i][j]=us[i-1][j]+1;
                if(!a[i][j-1])
                    ls[i][j]=ls[i][j-1]+1;
            }
        for(int i=1; i<=m; i++)
            for(int j=n; j>=1; j--)
                if(!a[i][j+1])rs[i][j]=rs[i][j+1]+1;
        for(int i=1; i<=m; i++)
            for(int j=1; j<=n; j++)if(a[i][j]) {
                    f[i][j]=min(f[i-1][j-1],min(ls[i][j],us[i][j]))+1;
                    f[i][j]=max(f[i][j],min(f[i-1][j+1],min(rs[i][j],us[i][j]))+1);
                    ans=max(f[i][j],ans);
                }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：月影困 (赞：0)

因为每一步的状态只需要当前层与前一层就能得到，所以就自然而然想到了滚动数组优化，优化后内存仅需1.7M.
相比与P1387，这个优化还是挺明显的.
详细解题步骤看代码！
```cpp

// 令row[i][j]为(i, j)位置向上最多0的个数.
// 令line[i][j]为(i, j)位置向两边最多0的个数.
// 因为对角线有“左上-右下”，“右上-左下”两种
// 所以line需要自左向右，自右向左两次递推得出，也就需要二维储存.
// dp[i][j]两维也是这个原因.
// 于是具体状态转移（左上-右下）就是：
// dp[i][j] = min(dp[i - 1][j - 1], min(line[i][j - 1], row[i - 1][j]))
// 然后同理推出“右上-左下”，并用ans存最大值就行了.
// 滚动数组记得将每一层的每一个状态都更新，以免读到“脏数据”.

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int mp[2512];
int row[2][2512];
int line[2][2512][2];
int dp[2][2512][2];
int n, m;
int ans;

int main()
{
	scanf("%d%d", &n, &m);
	
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++) // 推“左上-右下”
		{
			scanf("%d", &mp[j]);
			if (mp[j] == 0)
			{
				line[i & 1][j][0] = line[i & 1][j - 1][0] + 1;
				row[i & 1][j] = row[(i - 1) & 1][j] + 1;
				dp[i & 1][j][0] = 0; // 因为数组是滚动的，所以需要清零以保证状态正确.
			}
			else
			{
				dp[i & 1][j][0] = min(dp[(i - 1) & 1][j - 1][0], min(line[i & 1][j - 1][0], row[(i - 1) & 1][j])) + 1;
				row[i & 1][j] = line[i & 1][j][0] = 0;
			}
		}
		for (int j = m; j >= 1; j--) // 同理，推“右上-左下”
		{
			if (mp[j] == 0)
			{
				line[i & 1][j][1] = line[i & 1][j + 1][1] + 1;
				dp[i & 1][j][1] = 0;
			}
			else
			{
				dp[i & 1][j][1] = min(dp[(i - 1) & 1][j + 1][1], min(line[i & 1][j + 1][1], row[(i - 1) & 1][j])) + 1;
				row[i & 1][j] = line[i & 1][j][1] = 0;
				ans = max(ans, max(dp[i & 1][j][0], dp[i & 1][j][1]));
			}
		}
	}
	
	printf("%d\n", ans);
	
	return 0;
}


```

---

## 作者：wanzzhehe (赞：0)

这道题明明是DP。。。。

我的思路就是二分答案

。。。

放代码，代码有注释。。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
//getc和read为快读模板。。。有兴趣的可以用以下。。尤其是getc()不知道比getchar()快到哪里去了。。233
inline char getc(void) { 
    static char buf[1 << 18], *fs, *ft;
    return (fs == ft && (ft = (fs = buf) + fread(buf, 1, 1 << 18, stdin)), fs == ft) ? EOF : *fs++;
}

inline int read(void) { 
    char tmp = getc();
    int res = 0;
    while(!isdigit(tmp)) tmp = getc();
    while(isdigit(tmp))
        res = ((res + (res << 2)) << 1) + (tmp ^ 0x30),
        tmp = getc();
    return res;
}

#define MAXN (2510)

inline int get_sum(int x1, int x2, int y1, int y2);
inline bool check(int len);

int N, M;
int G[MAXN][MAXN], sum[MAXN][MAXN];
int s1[MAXN][MAXN], s2[MAXN][MAXN];
// sum[i][j]存以(i,j)为右下角的矩阵元素的和
// s1[i][j]存(i,j)左上↖边有几条鱼
// s2[i][j]存(i,j)右上↗边有几条鱼

int main() { 
    N = read(), M = read();
    for(int i = 1; i <= N; ++i)
        for(int j = 1; j <= M; ++j)
            G[i][j] = read();
    for(int i = 1; i <= N; ++i)
        for(int j = 1; j <= M; ++j) { 
            sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + G[i][j];
            s1[i][j] = s1[i-1][j-1] + G[i][j];
            s2[i][j] = s2[i-1][j+1] + G[i][j];
        }
    register int l = 1, r = min(N, M), Mid, ans;
    while(l <= r) { // 二分答案
        Mid = (l + r) >> 1;
        if(check(Mid)) ans = Mid, l = Mid + 1;
        else r = Mid - 1;
    }
    printf("%d\n", ans);
    return 0;
}

inline int get_sum(int x1, int x2, int y1, int y2) { 
    --x1, --y1;
    return sum[x2][y2] + sum[x1][y1] - sum[x2][y1] - sum[x1][y2];
}

inline bool check(int len) { // 检查函数
    register int i, j, x1, x2, y1, y2;
    for(i = len; i <= N; ++i)
        for(j = len; j <= M; ++j) { // 检查以(x2,y2)为右下角的正方形是否合法
            x1 = i - len + 1, x2 = i, y1 = j - len + 1, y2 = j;
            if(get_sum(i-len+1, i, j-len+1, j) != len) continue; // 如果以(x2,y2)为右下角的正方形没有len条鱼，那么这个正方形一定不合法
            else if(s1[x2][y2]-s1[x1-1][y1-1] == len) return true; // 检查↖方向的对角线有几条鱼
            else if(s2[x2][y1]-s2[x1-1][y2+1] == len) return true; // 检查↗方向的对角线有几条鱼
        }
    return false;
}
```

---

## 作者：bymlg001 (赞：0)

我来说一下搜索的思路吧

搜索好像并不慢，只要从1的地方往右下左下搜就行了，不必往左上和右上搜，因为一对相反的方向任选其一就能搜到答案，我选的右下左上，那么就需要从图的左上角开始每层找1，我用一个结构体队列存的1的点的坐标，边输入边存的，正好符合需要的要求（所以选右下左下更优啦）


##搜索固然好想，但关键在于如何判断搜到的这条矩阵的对角线是否合法？


我的方法可能比较蠢

从搜到的最深的点开始，往前找搜到的距离次，如果为0则不合法（感觉不需要加，毕竟就是这么搜过来的）直到找到矩阵的左上角。再写个前缀和，算一下这个矩阵的权值和，因为其他位必须是0，所以权值和等于搜到的距离才合法。否则不合法。


##剪枝

1.搜素过程中遇到的点，如果它不是这个对角线的最后一个，那么以后就不用搜了，标记一下。因为从它开始的点不会更优。为什么我要说不是这个对角线的最后一个。因为从它结束可能不是最优，但是从它开始又能搜到一片新天地。

就像这个数据

###4 4
###1 0 1 0

###0 2 0 0

###1 0 1 0

###0 0 0 1

（上图2为1）

2 那个点就是这样的特殊点如果从它结束的那条对角线长度为2，从它开始的那条对角线长度为3


不多说了，上代码

```cpp
####include<bits/stdc++.h> //懒癌晚期 
using namespace std;
const int N=2505;
int e[N][N]; //存图，本来开的bool，但是前缀和预处理的时候有问题qwq 
int sum[N][N];//前缀和处理 
int read(){//无脑读入优化 
    int res=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) res=res*10+ch-'0',ch=getchar();
    return res;
}
int n,m;
int ans=0;
bool vis1[N][N],vis2[N][N];//标记 
struct node{
    int x,y;
};
queue<node> Q;//存1的位置 
int cal(int sx,int sy,int ex,int ey){//求左上角sx sy右下角ex ey的矩阵的权值和 
    return sum[ex][ey]-sum[sx-1][ey]-sum[ex][sy-1]+sum[sx-1][sy-1];
}
bool check1(int x,int y,int res){//右下，判断是否合法 
    int tx=x,ty=y;
    for(int i=2;i<=res;i++){
        tx=tx-1;
        ty=ty-1;
        if(e[tx][ty]==0){
            return 0;
        }
    }
    if(cal(tx,ty,x,y)!=res){
        return 0;
    }
    return 1;
}
bool check2(int x,int y,int res){//左下，判断是否合法 
    int tx=x,ty=y;
    for(int i=2;i<=res;i++){
        tx=tx-1;
        ty=ty+1;
        if(e[tx][ty]==0){
            return 0;
        }
    }
    if(cal(tx,y,x,ty)!=res){
        return 0;
    }
    return 1;
}
void dfs(int x,int y,int res){//搜索右下 
    vis1[x][y]=1;
    bool cc=0;//其实写不下都可，反正我return了，就算不return 也可 反正找最大的ans 
    int tx=x+1;
    int ty=y+1;
    if(check1(tx,ty,res+1)&&tx>=1&&tx<=n&&ty>=1&&ty<=m){
        cc=1;
        dfs(tx,ty,res+1);
        return;
    }
    if(!cc){
        ans=max(ans,res); //更新ans 
        vis1[x][y]=0;//如果它是最后一个，一定要清除标记 
    }
    return;
}
void dfs2(int x,int y,int res){//搜索左下 
    vis2[x][y]=1;
    bool cc=0;
    int tx=x+1;
    int ty=y-1;
    if(check2(tx,ty,res+1)&&tx>=1&&tx<=n&&ty>=1&&ty<=m){
        cc=1;
        dfs2(tx,ty,res+1);
        return;
    }
    if(!cc){
        vis2[x][y]=0;//清除标记！虽然我也不知道不清楚会wa几个点，但自己造的数据会wa 
        ans=max(ans,res);//更新ans 
    }
    return;
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            e[i][j]=read();
            sum[i][j]=e[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
            if(e[i][j]==1){
                Q.push(node{i,j});    //压入队列 先进先出        
            }
        }
    }
    while(!Q.empty()){
        node now=Q.front();
        Q.pop();
        if(!vis1[now.x][now.y]){//没标记就搜 
            dfs(now.x,now.y,1);
        }
        if(!vis2[now.x][now.y]){//同上 
            dfs2(now.x,now.y,1);
        }
    }
    printf("%d\n",ans); //输出 
}
~~没救了我，又用搜索a的dp，dp试炼场没几个写的正解～～
```

---

## 作者：ars4me (赞：0)

我真的不知道我写的搜索还是DP

反正都差不多吧 - -

怎么搞呢

首先我们用三个数组 map[][]存图 f[][]用来存如果矩阵的对角线是从左上到右下的话 能取得的最大对角线长度 dp[][]则是同理的右上到左下的矩阵

因为每一个有鱼的位置一开始本身就是一个矩阵 所以初始化当map[i][j]=1的时候 dp[i][j]和f[i][j]都为1

然后在我们枚举一个k 往前找 看看有没有多余的1 因为我们要让矩阵尽量的大且题目要求这个矩阵除了对角线之外其他地方都不能有1的 且k只需要枚举到f(dp)[i - 1][j - 1]因为再往前的之前搞f(dp)[i - 1][j - 1]已经枚举过了 再枚举反而会出乱子 然后就是如果满足!map[i - k][j] && !map[i][j - k] && map[i - k][j - k]那么这个矩阵就可以有i-k~i j-k~j那么大 用一个tmp来记录当前对角线增长了多少 最后f(dp)[i][j]再+=tmp一下 就完成了 这样保证对于每一个有鱼的点都能统计到**以它为末端的最大的对角线是左上到右下的正方形或者对角线是右上到左下的正方形的对角线长度**

(没错 我语文很差)

在过程中ans不断更新最大值 最后输出

代码如下







                

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
    using namespace std;
    #define in = read();
    typedef long long ll;
    typedef unsigned int ui;
    const ll size = 2500 + 10;
        int n , m;
        int map[size][size];
        int ans , tmp , tmp2;
        int f[size][size] , dp[size][size];
inline ll read(){
        ll num = 0 , f = 1;    char ch = getchar();
        while(!isdigit(ch)){
                if(ch == '-')   f = -1;
                ch = getchar();
        }
        while(isdigit(ch)){
                num = num*10 + ch - '0';
                ch = getchar();
        }
        return num*f;
}
int main(){
        n in;    m in;
        for(register int i=1;i<=n;i++)
                for(register int j=1;j<=m;j++){
                        map[i][j] in;
                        if(map[i][j]){
                                f[i][j] = 1;
                                dp[i][j] = 1;
                                ans = 1;
                        }
                }
        for(register int i=1;i<=n;i++)
                for(register int j=1;j<=m;j++){
                        if(map[i][j] && map[i - 1][j - 1]){
                                for(register int k=1;k<=f[i - 1][j - 1];k++){
                                        if(!map[i - k][j] && !map[i][j - k] && map[i - k][j - k])
                                                tmp ++;
                                        else    break;
                                }
                                f[i][j] += tmp;
                                ans = max(ans , f[i][j]);
                                tmp = 0;
                        }
                }
        for(register int i=1;i<=n;i++)
                for(register int j=1;j<=m;j++){
                        if(map[i][j] && map[i - 1][j + 1]){
                                for(register int k=1;k<=dp[i - 1][j + 1];k++){
                                        if(!map[i - k][j] && !map[i][j + k] && map[i - k][j + k])
                                                tmp ++;
                                        else    break;
                                }
                                dp[i][j] += tmp;
                                ans = max(ans , dp[i][j]);
                                tmp = 0;
                        }
                }
        printf("%d" , ans);
}
```
4 6
0 0 1 0 1 0

0 1 0 1 0 0

1 0 0 0 1 1

0 1 0 1 1 0


10 10
0 0 1 0 1 0 1 1 1 1

1 1 1 0 1 0 0 0 0 1

0 0 0 0 0 0 0 1 0 1

0 0 0 0 0 0 1 0 1 1

0 0 0 0 0 1 0 0 1 0

0 0 0 0 1 0 0 0 1 1

0 0 0 1 0 0 0 0 1 1

0 0 1 0 0 0 0 0 0 0

0 1 0 0 0 0 0 0 1 1

1 0 0 0 0 0 0 0 1 0


---

## 作者：石榴 (赞：0)

对楼上的方法进行一下改进

其实记录0的个数不必要开辣么大的数组

在dp时稍微记录一下就行了

记录上下左右第一个一的出现位置

这样就可以避免mle的尴尬局面了

代码如下（本人代码一般没有注释望理解）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map>
#define ll long long
#define rg register
#define db double
#define N 3000
using namespace std;
bool a[N][N];
int dp[N][N],nr;
int main(void)
{
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF){
        memset(a,0,sizeof a);
        memset(dp,0,sizeof dp);
        for(rg int i=1;i<=n;i++){
            for(rg int j=1;j<=m;j++){
                int x;
                scanf("%d",&x);
                a[i][j]=x;
            }
        }
        int maxn=0;
        for(rg int i=1;i<=n;i++){
            nr=-0x3f3f;
            for(rg int j=1;j<=m;j++){
                dp[i][j]=a[i][j];
                if(a[i][j]==0) continue;
                dp[i][j]=min(dp[i-1][j-1]+1,j-nr);
                nr=j;
            }
        }
        for(rg int i=1;i<=m;i++){
            nr=-0x3f3f;
            for(rg int j=1;j<=n;j++){
                if(a[j][i]==0) continue;
                dp[j][i]=min(dp[j][i],j-nr);
                nr=j;
                maxn=max(maxn,dp[j][i]);
            }
        }
        memset(dp,0,sizeof dp);
        for(rg int i=1;i<=n;i++){
            nr=0x3f3f;
            for(rg int j=m;j>=1;j--){
                dp[i][j]=a[i][j];
                if(a[i][j]==0) continue;
                dp[i][j]=min(dp[i-1][j+1]+1,nr-j);
                nr=j;
            }
        }
        for(rg int i=1;i<=m;i++){
            nr=-0x3f3f;
            for(rg int j=1;j<=n;j++){
                if(a[j][i]==0) continue;
                dp[j][i]=min(dp[j][i],j-nr);
                maxn=max(maxn,dp[j][i]);
                nr=j;
            }
        }
        printf("%d\n",maxn);
    }
    return 0;
}
```

---

## 作者：fy0123 (赞：0)

DP。说一说思路。

先考虑左上到右下的对角线：f[i][j]表示以（i,j）这一点作为右下角的合法正方形的最大长度。如果当前位置的数字为1，那么考虑转移：

- 如果a[i-1][j-1]是0，那么f[i][j]就是1；

- 如果a[i-1][j-1]是1，那么f[i][j]=min{f[i-1][j-1]+1,(i,j)左边的最长连续0的长度,(i,j)上面最长连续0的长度}。

那么问题来了，怎么快速求最长连续0的长度呢，这个预处理好就可以了。

为了方便，我们预处理的时候，x[i][j]表示，(i,j)左边最长连续0的长度（包含(i,j)），y[i][j]同理表示上面。如果a[i][j]==1，直接把x[i][j]和y[i][j]设为0，否则就x[i][j]=x[i][j-1]+1,y[i][j]=y[i-1][j]+1。这样的话DP转移方程应该是f[i][j]=min(f[i-1][j-1]+1, x[i][j-1]+1, y[i-1][j]+1)。

如果是右上到左下的对角线，就只要把每一行的数左右反转一下，再做同样的DP即可。


下面放代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cctype>
using namespace std;

const int N = 2510;
int n, m;
int x[N][N], y[N][N], f[N][N], a[N][N], ans;

inline int read()  //2500*2500个数，让我很想用读入优化
{
    char ch = getchar(); int x = 0;
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }
    return x;
}

inline void dp()  //左上到右下对角线DP，细节自行理解
{
    memset(x, 0, sizeof x);
    memset(y, 0, sizeof y);
    memset(f, 0, sizeof f);
    for (int i = 1; i <= n; i ++){
        for (int j = 1; j <= m; j ++)
            if (a[i][j] == 0) x[i][j] = x[i][j-1]+1; else x[i][j] = 0;
    }
    for (int j = 1; j <= m; j ++){
        for (int i = 1; i <= n; i ++)
            if (a[i][j] == 0) y[i][j] = y[i-1][j]+1; else y[i][j] = 0;
    }
    for (int i = 1; i <= n; i ++){
        if (a[1][i] == 1) f[1][i] = 1;
        if (a[i][1] == 1) f[i][1] = 1;
    }
    for (int i = 2; i <= n; i ++)
        for (int j = 2; j <= m; j ++){
            if (a[i][j] == 0) continue;
            if (a[i-1][j-1] == 0) f[i][j] = 1;
            else f[i][j] = min(f[i-1][j-1]+1, min(x[i][j-1]+1, y[i-1][j]+1));
        }
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++) ans = max(ans, f[i][j]);
}

int main()
{
    n = read(); m = read();
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++) a[i][j] = read();
    dp();
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= n/2; j ++) swap(a[i][j], a[i][m-j+1]);  //左右反转
    dp();
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：易极feng (赞：0)

记录（i，j）左边、上面、右边的1的个数。

设f[i][j]为以（i,j）为右下方顶点的正方形最大边长，

则当（i,j）左边连续f[i-1][j-1]长度没有鱼且上面连续f[i-1][j-1]长度没有鱼时f[i][j]可由f[i-1][j-1]更新而来。

同理可设g[i][j]为以（i,j）为左下方顶点的正方形最大边长，

则当（i,j）右边连续f[i+1][j-1]长度没有鱼且上面连续f[i+1][j-1]长度没有鱼时f[i][j]可由f[i+1][j-1]更新而来。

在代码中我把f重置了两次，权当一次是f一次是g吧。

另外代码有点乱，如果实在不理解上面所述再看吧。

（我一开始zz地开了个d数组，请忽视它）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;

int n,m;
bool a[2505][2505];
int line[2505],row[2505];
int u[2505][2505],l[2505][2505];
int d[2505][2505],r[2505][2505];
int f[2505][2505];

int main(){
    bool flag=0;
    int i,j;
    int c;
    scanf("%d%d",&n,&m);
    memset(f,0,sizeof(f));
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            scanf("%d",&c);
            if(c==1)a[i][j]=1,line[i]++,row[j]++,f[i][j]=1,flag=1;
        }
    }
    
    if(!flag){printf("0");return 0;}
    
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            l[i][j]=l[i][j-1]+a[i][j];
        }
    }
    for(j=1;j<=m;j++){
        for(i=1;i<=n;i++){
            u[i][j]=u[i-1][j]+a[i][j];
        }
    }
    
    int ans=0;
    for(i=2;i<=n;i++){
        for(j=2;j<=m;j++){
            if(!a[i][j])continue;
            if(l[i][j]-l[i][j-f[i-1][j-1]-1]-1==0&&u[i][j]-u[i-f[i-1][j-1]][j]-1==0){
                f[i][j]=max(f[i][j],f[i-1][j-1]+1);
                ans=max(ans,f[i][j]);
            }
        }
    }
    
    for(i=1;i<=n;i++)for(j=1;j<=m;j++)f[i][j]=a[i][j];
    
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            r[i][j]=line[i]-l[i][j];
            d[i][j]=row[j]-u[i][j];
        }
    }
    
    for(i=2;i<=n;i++){
        for(j=m-1;j>=1;j--){
            if(!a[i][j])continue;
            if(r[i][j]-r[i][j+f[i-1][j+1]]==0&&u[i][j]-u[i-f[i-1][j+1]-1][j]-1==0){
                f[i][j]=max(f[i][j],f[i-1][j+1]+1);
                ans=max(ans,f[i][j]);
            }
        }
    }
    
    if(ans==0)printf("1");
    else printf("%d",ans);
    return 0;
}
```

---

## 作者：bztMinamoto (赞：0)

感觉和某道求最大正方形的差不多……

我的方法应该不算dp……

设数组a[i][j]，a[i][j].l存以i，j为正方形右下角的最大对角线长，a[i][j].r存以i，j为正方形左下角的最大对角线长。（反正从左到右从上到下刷，能保证之前每一个都已经求出来）

因为已经求出之前的最大对角线，所以i-1，j-1（或i-1,j+1）已经能保证有正方形

所以从i，j点往上往左（右）找，找到第一个是0时找了几次，即为i，j最长对角线……

不好意思我语文不好……上程序算了

最后一点大概500多ms

```cpp
#include<bits/stdc++.h>
using namespace std;
struct ab{
    int l,r;
    int x;
};
//l存往左上搜的最长，r存往右上搜的最长
ab a[2502][2502];
int n,m;
int ans;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    scanf("%d",&a[i][j].x);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    if(a[i][j].x)
//如果是没有鱼管都不用管，毕竟全局变量本来默认为0
    {if(a[i-1][j-1].l==0) 
    a[i][j].l=1;
       //左上最大长度为0，直接最大长度为1
    else
    {int p=a[i-1][j-1].l+1;
         //初始化是为了后面没有搜到1的话长度就为左上最长+1
    for(int k=1;k<=a[i-1][j-1].l;k++)
    if(a[i-k][j].x||a[i][j-k].x)
    {p=k;
    break;
        }
    //往左和上搜，如果有1，记录下往回搜了几位
    a[i][j].l=p;}
    //当前最大长度为p-1+1（往回搜的位数-1加上本身长）
   //下面不说了，就是注意往右上搜应是i-1，j+1
    if(a[i-1][j+1].r==0) 
    a[i][j].r=1;
    else
    {int p=a[i-1][j+1].r+1;
    for(int k=1;k<=a[i-1][j+1].r;k++)
    if(a[i-k][j].x||a[i][j+k].x)
    {p=k;
    break;
        }
    a[i][j].r=p;}
    ans=max(ans,a[i][j].l);
    ans=max(ans,a[i][j].r);
   //找最长
        }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：dqnstry (赞：0)


感觉数据有点水，设f[i][j]表示右下角为坐标为(i,j)的正方形满足条件的最大对角线长度，从左往右跑一边，从右往左跑一边，如何维护该数据满足条件，就用二位前缀和维护，一单区间的值的和等于对角线长度，答案就合法






        
    
    

    
    
    
```cpp
#include<cstdio>
#include<cstring>
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;
unsigned short h[3000],nx[5000000],to[5000000],cnt,n,m,ans;
char mp[3000][3000];
unsigned short f[3000][3000],pre[3000][3000];
int read()
{
    int rt=0,fl=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')fl=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){rt=rt*10+ch-'0';ch=getchar();}
    return rt*fl;
}
void add_edge(int x,int loc)
{
    nx[++cnt]=h[x];h[x]=cnt;to[cnt]=loc;
}
unsigned short getRec(int x1,int y1,int x2,int y2)
{
    return pre[x2][y2]-pre[x1-1][y2]-pre[x2][y1-1]+pre[x1-1][y1-1];
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int a = read();
            mp[i][j]=a;
            pre[i][j] = pre[i][j-1]+pre[i-1][j]-pre[i-1][j-1]+a;
        }        
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(mp[i][j]==0)continue;
            f[i][j]=1;
            for(int k=f[i-1][j-1];k>=0;k--)
            {
                int sum = getRec(i-k,j-k,i,j);
                if(sum == k+1)
                {
                    f[i][j] = sum;
                    break;
                }
            }
            ans = max(f[i][j],ans);
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=1;j--)
        {
            if(mp[i][j]==0)continue;
            f[i][j] = 1;
            for(int k=f[i-1][j+1];k>=0;k--)
            {
                int sum = getRec(i-k,j,i,j+k);
                if(sum == k+1)
                {
                    f[i][j] = sum;
                    break;
                }
            }
            ans = max(f[i][j],ans);
        }
    }
    printf("%d ",ans);
    return 0;
}
```

---

## 作者：Memorize (赞：0)

方法大意与讨论组里面Linbom(我的小号...)差不多 不过这有一个缺点 就是不一定能全部衔接上 可能只衔接左右对角线的一部分 所以在做的时候还要for枚举判断(本来都做好超时的准备的...没想到过了)

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int n,m,maxn=0;
int map[2510][2510];
int next[2510][2510];
int dp[2510][2510][2];
bool judge1(int x,int y,int num)
{
  int x2=x+num,y2=y+num;
  if(next[x2][y2]-next[x-1][y2]-next[x2][y-1]+next[x-1][y-1]==num+1) return true;
  return false;    
}
bool judge2(int x,int y,int num)
{
  int x2=x+num,y2=y-num;
  swap(y,y2);
  if(next[x2][y2]-next[x-1][y2]-next[x2][y-1]+next[x-1][y-1]==num+1) return true;
  return false;        
}
int main()
{
    memset(next,0,sizeof(next)); 
    memset(dp,0,sizeof(dp));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
     {
         scanf("%d",&map[i][j]);
        next[i][j]=next[i][j-1]+map[i][j];
        if(map[i][j]==1) dp[i][j][0]=dp[i][j][1]=1;
     }  
    for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++) next[i][j]+=next[i-1][j];
    for(int i=n;i>=1;i--)
     for(int j=m;j>=1;j--)
     {
         if(map[i][j]==1&&dp[i+1][j+1][0]>0)
           for(int k=1;k<=dp[i+1][j+1][0];k++)
            if(judge1(i,j,k)) dp[i][j][0]++;
          if(map[i][j]==1&&dp[i+1][j-1][1]>0)
           for(int k=1;k<=dp[i+1][j-1][1];k++)
            if(judge2(i,j,k)) dp[i][j][1]++;  
          maxn=max(maxn,max(dp[i][j][0],dp[i][j][1]));
     }      
    printf("%d",maxn);   
    return 0;
}
```

---

## 作者：magolor (赞：0)

跟楼下做法相似，不过更改了搜索顺序，而且不用反转数组，并进行了剪枝优化，所以快一些，思路也是检查对角线和矩阵前缀和。







```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 2500
bool g[MAXN+5][MAXN+5];
int s[MAXN+5][MAXN+5],f[MAXN+5][MAXN+5],n,m;
inline int sum(int i, int j, int p, int q)
{
    return s[p][q]+s[i-1][j-1]-s[p][j-1]-s[i-1][q];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
            cin >> g[i][j], s[i][j] = s[i][j-1]+g[i][j]; 
        for(int j = 1; j <= m; j++)
            s[i][j] += s[i-1][j];
    }
    int maximum = 0;
    for(int i = n; i >= 1; i--)
        for(int j = m; j >= 1; j--)
            if((f[i][j]=g[i][j]))
                for(int k = f[i+1][j+1]; k >= 0; k--)
                    if(sum(i,j,i+k,j+k)==k+1)
                    {
                        maximum = max(maximum, f[i][j] = max(f[i][j],k+1));
                        if(f[i][j] > 1)
                            break;
                    }
    memset(f,0,sizeof(f));
    for(int i = n; i >= 1; i--)
        for(int j = 1; j <= m; j++)
            if((f[i][j]=g[i][j]))
                for(int k = f[i+1][j-1]; k >= 0; k--)
                    if(sum(i,j-k,i+k,j)==k+1)
                    {
                        maximum = max(maximum, f[i][j] = max(f[i][j],k+1));
                        if(f[i][j] > 1)
                            break;
                    }
    cout << maximum << endl;
    return 0;
}
```

---

## 作者：a2956331800 (赞：0)

这道题虽然是动态规划，但也有非动态规划的做法，看到题解里没有这种做法，就给大家发一下（虽然慢了一点，但比较容易理解）：用前缀和、差分，首先对矩阵求前缀和，之后从（0,0）向（n，m）扫描，每扫描到一个点，就向这个点的左上方（i-k,j-k，1<=k<=n）

扫描，如果扫描到0或从（i-k，j-k）到（i，j）这个矩阵的差分（即其中鱼的个数）大于k+1（矩阵对角线长度）则终止扫描，此时k就是从点（i，j）向左上方能吃到的鱼的数量，扫描完之后将整个矩阵左右翻转再进行一次扫描，两次扫描扫到的最大值就是结果。

代码：

```cpp
#include<iostream>
using namespace std;
int n,m,t[2510][2510],i,j,first[2510][2510],ans,dp;
void frst()
{
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)
        first[i][j]=first[i-1][j]+first[i][j-1]-first[i-1][j-1]+t[i][j];
    return;
}
int doit()
{
    frst();
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)
        if(t[i][j])
        {
            int k=1;
            while(i-k&&j-k&&t[i-k][j-k]&&first[i][j]-first[i-k-1][j]-first[i][j-k-1]+first[i-k-1][j-k-1]==k+1)//求（i-k，j-k）到（i，j）这个子矩阵的差分 
              k++;
            dp=max(dp,k);
        }
    return dp;
}
void change()
{
    for(i=1;i<=n;i++)
      for(j=1;j<=(m+1)/2;j++)
        swap(t[i][j],t[i][m-j+1]);
    return;
}
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)
        cin>>t[i][j];
    ans=doit();
    change();
    ans=max(ans,doit());
    cout<<ans;
    return 0; 
}
```

---

## 作者：Salamander (赞：0)

借鉴了他人的方法，进行了一些优化。

超级暴力的方法，dp+递推，大神可以无视。

时间复杂度是O（4mn），

空间负责度是O（5mn）。

差一点就超空间了，最后一个点用了515ms。

left、right和up分别表示这个点向左、右、上三个方向有几个连续的0（包括自己），

这个可以用O（mn）的递推完成。left[i][j]=left[i][j-1]+1(a[i][j]==0)，right和up同理。

然后就是dp了。。。

注意dp分两个对角线的方向，f[i][j]分别表示以a[i][j]为下端的对角线的最长长度。

左上右下方向：f[i][j]=min(f[i-1][j-1],left[i][j-1],up[i-1][j])+1

右上左下方向：f[i][j]=min(f[i-1][j+1],right[i][j+1],up[i-1][j])+1


下面是代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int m,n,left[2501][2501],right[2501][2501],up[2501][2501],f[2501][2501];
bool a[2501][2501];//由于矩阵中只有0和1，所以可以用bool，本人试了用int会刚好超空间。
int main()
{
    scanf("%d%d",&m,&n);
    int i,j,ans=0;
    for(i=1;i<=m;i++)
        for(j=1;j<=n;j++)
            scanf("%d",&a[i][j]);
    for(i=1;i<=m;i++)
    {
        for(j=1;j<=n;j++)
            if(!a[i][j])
            {
                left[i][j]=left[i][j-1]+1;
                up[i][j]=up[i-1][j]+1;//up和left递推的循环方向相同，所以可以放在一起。
            }
        for(j=n;j>=1;j--)
            if(!a[i][j])
                right[i][j]=right[i][j+1]+1;//right递推的方向相反，要和前面分开。
    }
    for(i=1;i<=m;i++)//左上右下方向
        for(j=1;j<=n;j++)
            if(a[i][j])
            {
                f[i][j]=min(f[i-1][j-1],min(left[i][j-1],up[i-1][j]))+1;
                ans=max(ans,f[i][j]);
            }
    memset(f,0,sizeof(f));
    for(i=1;i<=m;i++)//右上左下方向
        for(j=1;j<=n;j++)
            if(a[i][j])
            {
                f[i][j]=min(f[i-1][j+1],min(right[i][j+1],up[i-1][j]))+1;
                ans=max(ans,f[i][j]);
            }
    printf("%d\n",ans);//输出结果
    return 0;
}
```

---

## 作者：OkamiWang (赞：0)

暴力dp。

首先分类，fl[i,j]表示由左上开始的对角线到（i，j）为终点的最大长度，fr[i,j]为从右上开始的对角线到(i,j)为终点的最大长度。

可以观察到fl[i,j]可以从f[i-1,j-1]转移而来，fr[i,j]可由fr[i-1,j+1]转移而来，当转移完毕后，搜索以当前对角线长为边长正方形上该点的临边有没有鱼，如果有鱼，那么鱼到该点的距离为以该点为终点的对角线长。

最后搜一遍最长解就可以啦。

```cpp
[/color][codec ]
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int a[2600][2600],fl[2600][2600],fr[2600][2600];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i = 1;i<=n;i++)
        for(int j = 1;j<=m;j++)scanf("%d",&a[i][j]);
    memset(fl,0,sizeof(fl));
    memset(fr,0,sizeof(fr));
    for(int i = 1;i<=n;i++)//搜索fl
        for(int j = 1;j<=m;j++)
            if(a[i][j]){
                fl[i][j] = fl[i-1][j-1]+1;
                for(int k = 1;k<fl[i][j];k++)if(a[i-k][j]||a[i][j-k]){//验证当前解是否可行
                    fl[i][j] = k;
                    break;
                }
            }
    for(int i = 1;i<=n;i++)//搜索fr
        for(int j = m;j;j--)
            if(a[i][j]){
                fr[i][j] = fr[i-1][j+1]+1;
                for(int k = 1;k<fr[i][j];k++)if(a[i-k][j]||a[i][j+k]){//验证当前解是否可行
                    fr[i][j] = k;
                    break;
                }
            }
    int ans = 0;
    for(int i = 1;i<=n;i++)
        for(int j = 1;j<=m;j++)ans = max(ans,max(fl[i][j],fr[i][j]));
    cout<<ans<<endl;
    return 0;
}
[/codec ]
```

---

## 作者：awipppp (赞：0)

用动规重写了  一共600ms

一开始只有90分(第四个点未过)，原来思路完全错了，原先每次都只判断了能否直接从上一个状态增加1，仅以dp[i-1][j+t\*2-1][t]判断是否可行，不行就为1，但其实可能有更小的可行解，上一组数据方便理解

5 5
1 0 0 1 0

0 1 0 0 0

0 0 1 0 0

0 0 0 1 0

0 0 0 0 1

应输出4

以原来的方法(4,4)的值是1，会输出3


```cpp
#include<bits/stdc++.h>
using namespace std;
char c;
int i,j,n,t,m,Max,e;
bool ma[2510][2510],p;
int dp[2503][2503][2];
inline bool read(){c=getchar();while(c<'0'||c>'1') c=getchar();p=c-'0';return p;}
inline bool pa(int x,int y,bool h,int p)
{
    for(int i=x-p;i<x;i++) if(ma[i][y]) return 0;
    if(!h) {for(int i=y-p;i<y;i++) if(ma[x][i]) return 0;}
    else  for(int i=y+p;i>y;i--) if(ma[x][i]) return 0;return 1;
}
inline void se(int x,int y,bool h,int p)
{
    if (p<0) return;
    if(pa(x,y,h,p)) dp[x][y][h]=p+1;
    else {se(x,y,h,p-1);return;}
    if(Max<dp[x][y][h]) Max=dp[x][y][h];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    ma[i][j]=read();
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    for(t=0;t<2;t++)
    if(ma[i][j]) se(i,j,t,dp[i-1][j+t*2-1][t]);
    printf("%d\n",Max);
    return 0;
}
```

---

## 作者：Sky_star (赞：0)

这道题我也是用了两次动规求出右下角到左上角的对角线最长的合法矩阵大小


第二次是求左下角到右上角的对角线最长的合法矩阵大小


但我在判断是否合法时采取了一些优化


每个可行点只需要向左、上、右判断是否有鱼


向左、右、上判断次数的最大值为f[i-1][j-1]+1    f[i-1][j+1]+1


因为如果这条对角线是延续的你判断储存下来的合法矩阵大小也是有序的


易得只需向左右一行判断，向上一列判断


最后一点跑了461ms


总的跑了1169ms


以下是代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string.h>
using namespace std;
int n,m,a[2501][2501],f[2501][2501],fi,ans;
int main()
{
    int i,j,k;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
     for(j=1;j<=m;j++)
      scanf("%d",&a[i][j]);
    for(i=1;i<=n;i++)
     for(j=1;j<=m;j++)
      if(a[i][j]==1)
      {
        f[i][j]=1;
        for(k=1;k<(f[i-1][j-1]+1);k++)
        {
          if(a[i-k][j]==1||a[i][j-k]==1)
           break;
          fi=k+1;
        }
        f[i][j]=max(fi,f[i][j]);
        ans=max(f[i][j],ans);
        fi=0;
      }
    memset(f,0,sizeof f);
    for(i=1;i<=n;i++)
     for(j=1;j<=m;j++)
      if(a[i][j]==1)
      {
        f[i][j]=1;
        for(k=1;k<(f[i-1][j+1]+1);k++)
        {
          if(a[i-k][j]==1||a[i][j+k]==1)
           break;
          fi=k+1;
        }
        f[i][j]=max(fi,f[i][j]);
        ans=max(f[i][j],ans);
        fi=0;
      }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：CoolTeam (赞：0)

动态规划，f[i][j]表示以(i,j)为顶点的最大子矩阵中能吃到的鱼的条数。

f[i][j]可以从f[i-1][j-1]或f[i-1][j+1]转移而来，取其中最大值。

每次转移需要横向和纵向检查0的个数，取两者最小值k即得到了最大子矩阵中鱼的个数。

C代码：

```cpp
#include<stdio.h>
int n,m,i,j,k,k1,k2,max,temp,f[2501][2501];
int main(void)
{
    while(scanf("%d%d",&n,&m)==2)
    {
        max=0;//答案 
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=m;j++)scanf("%d",&f[i][j]);//先输入一行，因为下面要横向检查0的个数。 
            for(j=1;j<=m;j++)
            {
                if(f[i][j]==1) 
                {
                    temp=f[i-1][j-1];//检查左上方 
                    if(temp>=1 && temp+1>f[i][j])
                    {
                        for(k1=1;k1<=temp;k1++)//横向往左检查0的个数k1，最多为temp个 
                            if(f[i][j-k1]>=1) break;
                        for(k2=1;k2<=temp;k2++)//纵向往上检查k2…… 
                            if(f[i-k2][j]>=1) break; 
                        f[i][j]=k1<k2?k1:k2; //取k1、k2较小的那个，就是满足条件的最大子矩阵。 
                    }
                    temp=f[i-1][j+1];//检查右上方 
                    if(temp>=1 && temp+1>f[i][j])
                    {
                        for(k1=1;k1<=temp;k1++)
                            if(f[i][j+k1]>=1) break;//唯一不同是这里的j+k1而不是j-k1,因为是往右检查 
                        for(k2=1;k2<=temp;k2++)
                            if(f[i-k2][j]>=1) break;
                        f[i][j]=k1<k2?k1:k2;
                    }
                }
                if(f[i][j]>max) max=f[i][j];
            }
        }
        printf("%d\n",max);        
    }
    return 0;
}
```

---


# 考场奇遇

## 题目背景

本市的某神校里有一个学霸，他的名字叫小明（为了保护主人公的隐私，他的名字都用“小明”代替）。在这次的期中考试中，小明同学走桃花运，在考场上认识了一位女生，她的名字叫小红（同样是为了保护隐私）。

## 题目描述

英语考试结束了，打完铃，她就主动来找小明说话，一来就要借英语卷子对答案。小明是公认的英语大神，二话不说就把卷子借给了她。小红对了一遍答案，简直是千差万别，她不禁冒出了冷汗。这时，小明走过来，安慰她：“没事，我又不是标准答案，不一定全对。”

已知小明答案的准确率是 $A\%$，一共有 $N$ 道题，给出小红对答案的结果 $S$（一个长为 $N$ 的 01 串，其中 `1` 表示两人答案一样，`0` 表示不一样）。为了简化问题，所有题目都是判断题。

请你帮小红写一个程序，计算出她对 $Q$ 题及以上的概率。

（P.S. 小明后来把那张卷子送给了小红，别想多了，不是定情信物）

## 说明/提示

对于 $90\%$ 数据，$N \leq 50, N-5 \leq Q \leq N$。

对于剩下的 $10\%$ 数据，$N \leq 10000, Q = 0$。

## 样例 #1

### 输入

```
3 90 2
100```

### 输出

```
0.172```

# 题解

## 作者：7wwwwth (赞：18)

感觉dalao们的题解看得似懂非懂 果然我还是太弱了

为了像我一样弱的刚接触概率dp不知道为什么这么转移方程的人 

我就写了这篇题解

我们用 f[i][j] 来表示 做i道题中做对j道题的概率

那么可以显而易见地知道 f[i][j] 一定是从 f[i-1][j]或者 f[i-1][j-1]转移过来的

即上一道题要么做对了要么做错了

那么对于这两种情况

① 上一道题的时候已经做对了j道 那么f[i][j] 就是f[i-1][j]* 这道题做错的概率 

（i-1道时已经做对了j道那么第i道题中对j道一定因为第i道做错了）

②同理相反的情况下 i-1时做对了j-1道 那么要想i道时做对 j道 那么第i道就一定要做对

对于这个问题 小红和小明答案一样时 小明的正确率就是小红的正确率 错误率就是小红的错误率

而当两人答案不一样时，小明的错误率就变成了小红的正确率，而小红的错误率则是小明的正确率 

明白了这一点这个题就非常好写了。

初始状态是

```
f[0][0]=1;
```
显然0道中对0道的概率为 1

而且还很明显知道 0道中对0道以上的概率为0 不过本来初始值就是0就不用初始化了

完整代码:
```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define ll long long
#define maxn 100
using namespace std;

void read(int &x){
    x=0;char c=getchar();int flag=1;
    while(c<'0'||c>'9') flag=(c=='-'?-1:1),c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    x=x*flag;
}

int n,q;

int a;

double f[maxn][maxn];

double ans;

int main(){
    read(n);read(a);read(q);
    if(n>50) {
        cout<<"1.000";
        return 0;	
    }
    double p=a/100.0;
    f[0][0]=1;
    for(int i=1;i<=n;i++){
        char c;
        cin>>c;
        for(int j=0;j<=i;j++){//从做对0道开始 精度问题
            if(c=='0'){
                f[i][j]=f[i-1][j]*p+f[i-1][j-1]*(1-p);
            }
            else{
                f[i][j]=f[i-1][j-1]*p+f[i-1][j]*(1-p);
            }			
        }	
    }
    for(int i=n;i>=q;i--) ans+=f[n][i];
    printf("%.3lf",ans);
}
```


感谢您看了这么冗长的一段话...


---

## 作者：asdfghjkl123 (赞：13)

参考了一下楼下二位的思想，自己想了想，觉得这是个递推，可能说不上是个DP。

我的思想是边读入边处理，对于每一个位置，分别判断当它正确时和错误时对于最后答案的贡献，然后进行加和之类的处理。

（可能我语文不太好，包容一下，代码可能能解答一切问题……）
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#define b (1-a)
using namespace std;
int n,q;double a,ans;
char ch;
double dp[51][51];
int main()
{
//	freopen("123.out","w",stdout);//这是自己造数据测试时用的，请忽略
	scanf("%d%lf%d",&n,&a,&q);a/=100;
	if(q==0){printf("1.000");return 0;}//特判题目中的10%数据
	scanf("\n");//防止干扰读入
	dp[0][0]=1;//初始化dp[0][0]
	for(int i=1;i<=n;i++)
	{
		scanf("%c",&ch);
		ch-='0';
//下面是操作的核心部分。dp[i][j]可以由dp[i-1][j]和dp[i-1][j-1]转移而来，当然，对于不同的ch值，转移的细节不同。另外，对于j=0的情况应该单独处理，防止下标出现负数
		if(ch)dp[i][0]=dp[i-1][0]*b;
		else dp[i][0]=dp[i-1][0]*a;
		for(int j=1;j<=i;j++)
		{
			if(ch) dp[i][j]=dp[i-1][j]*b+dp[i-1][j-1]*a;
			else dp[i][j]=dp[i-1][j]*a+dp[i-1][j-1]*b;
		}
	}
//	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)printf("dp[%d][%d]=%.3f\n",i,j,dp[i][j]);
	for(int i=n;i>=q;i--)ans+=dp[n][i];
	printf("%.3f",ans);
	return 0;
}
```
当然，如果我的代码有什么漏洞，还是欢迎大家指出……

---

## 作者：Tgotp (赞：11)

概率dp


f[i][j]表示 i 个任务有j个做正确的概率


这一次对的某种情况为上一次少一的概率\*成功的概率 + 一样\*不成功的概率


然后对于n > 50的情况可以特判，当然不特判1 s 也是跑的出来的。


[蒟蒻代码](http://tgotp.science/p2111-%E8%80%83%E5%9C%BA%E5%A5%87%E9%81%87/)


---

## 作者：qkhm (赞：9)

看到题解区一群 dalao 的 dp，蒟蒻瑟瑟发抖。

[题目链接](https://www.luogu.com.cn/problem/P2111)

接下来说一下我的思路。



------------


1. 首先这题 $90\%$ 的数据很小，这是这个思路的基础；另外 $10\%$ 的数据，大家也应该发现 $q=0$ 了，所以，可以特判过。
  
2. 具体思路，用填数的思维，每道题有做对和做错两种填法，然后 搜索 $+$ 回溯 $+$ 优化 $=$ AC。

3. 数据再大就不能用了。

------------

上代码，不懂的看注释。


```
#include<bits/stdc++.h>
#define gc getchar()
#define I return
#define LOVE 0
#define LUOGU ; 
using namespace std;
const int Maxn = 1e4;
double Right,ans,ept,sum,R[Maxn];
int n,A,q,a[Maxn],C[Maxn][Maxn];
void dfs(int pos,int m){
	if(m == 0){
		ept = sum;
		for(int i = pos;i <= n;++ i) ept *= (1 - R[i]);//把剩下的按错处理 
		ans += ept;//统计答案 
		return;
	}
	if(pos > n) return;//截止 
	if(n - pos + 1 < m) return;/*
	如果剩下的所以全对也达不到 m 的指标，便不再给机会 （职场现状） 
	*/ 
	sum *= R[pos];
	dfs(pos + 1,m - 1);//此题对的情况
	sum /= R[pos];//回溯 
	sum *= (1 - R[pos]);
	dfs(pos + 1,m);//此题错的情况，记得m不变 
	sum /= (1 - R[pos]);//回溯 
	return;
}
int read(){
	int x = 0,f = 1;char c = gc;
	while(!isdigit(c)){if(c == '-') f = -1;c = gc;}
	while(isdigit(c)){x = x * 10 + c - '0';c = gc;}
	return x*f;
}
int main(){
	n = read(); A = read(); q = read();
	if(!q){
		printf("1.000");
		return 0;//特判 
	}
	for(int i = 1;i <= n;++ i) scanf("%1d",&a[i]);//scanf大法，控制域宽 
	Right = A / 100.0; 
	for(int i = 1;i <= n;++ i){
		if(a[i]) R[i] = Right;//如果和小明答案一样 ，正确的概率 
		else R[i] = 1 - Right; 
	}
	for(int i = q;i <= n;++ i){
		sum = 1;// 初始化 
		dfs(1,i); 
	}
	printf("%.3lf",ans);
	I LOVE LUOGU//神奇咒语 
}
```


------------

其实暴力在数据小时很有用（小声bb）。


---

## 作者：OIer991215 (赞：4)

~~去年这道题还不会~~

今年高二学了二项分布，发现这是个二项分布的裸题（参考高中数学选修2-3）。

从p开始枚举，也就是从正好做对p到题，枚举到做对全部题。

做对的题 = 两人相同的正确题 + 两人不同而小红做对的题。

至于式子纯属就是二项分布的式子了。

假设:

10道相同的题里有7道做对

20道不同的题里有6道题做对

那么式子就是：

double p1=c[10][7]* pow(a/100,7)*pow(1-a/100,3);

double p2=c[20][6]* pow(1-a/100,6)*pow(a/100,14);

p=p1*p2;
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
int n,a,q,com,unc;
double rt,p;
char s[66666];
long long c[222][333];
int main()
{
	scanf("%d%d%d",&n,&a,&q);
	scanf("%s",s+1);
	if(n>50)
	{
		printf("1.000");
		return 0;
	}
	rt=(double)a/(double)100;
	c[0][0]=c[1][1]=c[1][0]=1;
	for(int i=1; i<=50; i++)
	{
		c[i][0]=c[i][i]=1;
		for(int j=1; j<i; j++)
			c[i][j]=c[i-1][j]+c[i-1][j-1];
	}
	for(int i=1; i<=strlen(s+1); i++)
		if(s[i]=='1')
			com++;
		else if(s[i]=='0')
			unc++;
	for(int i=q; i<=strlen(s+1); i++)
	{
		for(int j=0; j<=i; j++)
		{
			int ncom=j,nunc=i-j;
			if(ncom>com||nunc>unc)
				continue;
			double p1=c[com][ncom]*pow(rt,ncom)*pow(1-rt,com-ncom);
			double p2=c[unc][nunc]*pow(1-rt,nunc)*pow(rt,unc-nunc);
			p=p+p1*p2;
		}
	}
	printf("%.3lf",p);
	return 0;
}
```

---

## 作者：Augen_stern (赞：3)

## Part 1：分析题目

首先，题目就是让我们求对 $Q$ 题及以上的概率；

然后我们再来看一下数据范围：

对于 $90\%$ 数据，$N\le 50$，$N-5\le Q\le N$；

对于剩下的10%数据，$N\le 10000$，$Q=0$；

显然，暴力是可取的。

在这篇题解中，将会有对此题的两种做法。

## Part 2：求解答案

### 方法一：循环暴力

对于 $10\%$ 的数据，因为 $Q=0$，也就是说，无论如何，都是成立，所以概率为 $1$，特判输出：

```cpp
	if(n>50) {
		printf("1.000"); // 保留三位小数
		return 0;
	}
```

对于剩下的数据，因为 $N-5\le Q\le N$ 我们可以枚举有哪些题是错误的，利用加乘原理，再因为总概率为 $1$，再将每种情况相加，再用总概率减去即可。

在实现时，我们可以用 $a_{i,0}$ 来表示当前题目的错误概率，$a_{i,1}$ 来表示当前题目的正确概率；

所以代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#define INF 0x7fffffff/2
using namespace std;
int n;
double A,Q,ans=0,ans2=1;
char c[10005];
double a[10005][2];
signed main() {
	scanf("%d%lf%lf",&n,&A,&Q);
	int cj=n-(int)Q; // 差距
	for(int i=1; i<=n; i++) {
		cin>>c[i];
		if(c[i]=='1') a[i][1]=A,a[i][0]=100-A; 
		else a[i][0]=A,a[i][1]=100-A;
		a[i][1]/=100.0; // 正确概率
		a[i][0]/=100.0; // 错误概率
	}
	if(n>50) {
	    ans=1;
		printf("1.000");
		return 0;
	} // 特判
	if(cj>=0) {
		ans2=1;
		for(int i=1; i<=n; i++) {
			ans2*=a[i][1];
		}
		ans+=ans2;
	} // 全对
	if(cj>=1) {
		ans2=1;
		for(int i=1; i<=n; i++) {
			ans2=1;
			for(int j=1; j<=n; j++) {
				if(i==j) {
					ans2*=a[j][0];
				} else ans2*=a[j][1];
			}
			ans+=ans2;
		}
	} // 错了一道
	if(cj>=2) {
		for(int i=1; i<=n; i++) {
			for(int j=i+1; j<=n; j++) {
				ans2=1;
				for(int p=1; p<=n; p++) {
					if(i==p||j==p) {
						ans2*=a[p][0];
					} else ans2*=a[p][1];
				}
				ans+=ans2;
			}
		}
	} // 错了两道
	if(cj>=3) {
		for(int i=1; i<=n; i++) {
			for(int j=i+1; j<=n; j++) {
				for(int p=j+1; p<=n; p++) {
					ans2=1;
					for(int q=1; q<=n; q++) {
						if(i==q||j==q||p==q) {
							ans2*=a[q][0];
						} else ans2*=a[q][1];
					}
					ans+=ans2;
				}
			}
		}
	} // 错了三道
	if(cj>=4) {
		for(int i=1; i<=n; i++) {
			for(int j=i+1; j<=n; j++) {
				for(int p=j+1; p<=n; p++) {
					for(int q=p+1; q<=n; q++) {
						ans2=1;
						for(int k=1; k<=n; k++) {
							if(i==k||j==k|p==k||q==k) {
								ans2*=a[k][0];
							} else ans2*=a[k][1];
						}
						ans+=ans2;
					}
				}
			}
		}
	} // 错了四道
	if(cj>=5) {
		for(int i=1; i<=n; i++) {
			for(int j=i+1; j<=n; j++) {
				for(int p=j+1; p<=n; p++) {
					for(int q=p+1; q<=n; q++) {
						for(int k=q+1; k<=n; k++) {
							ans2=1;
							for(int g=1; g<=n; g++) {
								if(i==g||j==g|p==g||q==g||k==g) {
									ans2*=a[g][0];
								} else ans2*=a[g][1];
							}
							ans+=ans2;
						}
					}
				}
			}
		}
	} // 错了五道
	printf("%.3lf",ans); // 保留三位小数
	return 0;
}
```

总结，暴力对于这道题来讲，是可以轻松 AC 的。

当然，dfs 暴力也是可以解决的，可以参考已经 AC 了的 [_Sad](https://www.luogu.com.cn/user/404036) 大佬的 [代码](https://www.luogu.com.cn/record/53600577)，希望大家尊重知识产权。

对于此做法的优化，可以参考组合数，目前题解中 [redegg](https://www.luogu.com.cn/user/34663) 大佬就有一篇关于此类方法的[题解](https://www.luogu.com.cn/blog/redegg/solution-p2111)，这里就不过多描写了。


### 方法二：概率 DP

在方法一的基础上，进行递推，$f_{i,j}$ 表示 $i$ 个任务有 $j$ 个做正确的概率；

而当前一次答对的某种情况为上一次答对数量少一的概率 $\times$ 成功的概率 $+$ 不变 $\times$ 不成功的概率。

这种方法更具普遍规律性，也正是这道题的正解之一。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#define INF 0x7fffffff/2
using namespace std;
int n,q;
double a,ans;
double f[55][55];
signed main() {
	scanf("%d%lf%d",&n,&a,&q);
	a/=100; // 转成概率 
	if(n>50) {
		printf("1.000");
		return 0;
	} // 特判 
	f[0][0]=1; // 初始化 
	for(int i=1; i<=n; i++) {
		int x;
		scanf("%1d",&x); // 边读入边处理
		for(int j=0; j<=n; j++) {
			if(!x) f[i][j]=f[i-1][j]*a+f[i-1][j-1]*(1-a); // 答案不同
			else f[i][j]=f[i-1][j]*(1-a)+f[i-1][j-1]*a; // 答案相同
		}
	}
	for(int i=q; i<=n; i++) ans+=f[n][i]; // 概率相加 
	printf("%.3lf",ans);
	return 0;
}
```

**总结，方法二比方法一更具有普遍性结论且方法二时间复杂度远小于方法一，但是方法一的思维难度又小于了方法二，所以各有千秋吧。**

---

## 作者：redegg (赞：1)

没想出$DP$用组合数学，快速幂和概率，加上$n>50$的特判。

我们可以把对的答案拆分成两部分：全$1$串，全$0$串，然后全$1$串的单个正确概率是$A$%，而全$0$串是 $( 100-A) $ %

我们用组合数学$C_a^k$和$C_b^l$表示从$1$串中选$k$个与$0$串中选$l$个，并使其全部正确的，那么可以得到使其成立的概率是:
$$ P= A^{C_a^k} \times (1-A)^{C_b^l}  $$

快速求幂次方，用快速幂即可（但是我没想清楚为什么组合数没爆）

若$k+l \ge Q$,则$ans+=P$

至于特判，我们只需要判断全错的概率，也是拆分后判断，有了上面的公式，全错的应该也很好推了，答案就是$1-$全错的概率。

代码：
```
#include <bits/stdc++.h>
using namespace std;

char in[100005];
long long n,m;

double k1,k2;

double l[10005];
double r[10005];

long long card(long long a,long long b)
{
    long long an=1;
    for(long long i=b+1;i<=a;i++)
    {
        an*=i;
    }
    return an;
}

double fast(double k,int q)
{
    double an=1;
    while(q)
    {
        if(q%2==1)
        {
            an*=k;
        }
        k*=k;
        q/=2;
    }
    return an;
}

int main()
{
    int kkk;
    scanf("%lld%d%lld",&n,&kkk,&m);
    int aa=0,bb=0;
    k1=((double)kkk)*((double)0.01);
    k2=1-k1;
    scanf("%s",in+1);
    for(int i=1;i<=n;i++)
    {
        if(in[i]=='1')
            aa++;
        else
            bb++;
    }
    if(n>55)
    {
        double ans=1;
        ans=fast(k2,aa)*fast(k1,bb);
        printf("%.3f",1-ans);
        return 0;
    }
    for(int i=0;i<=aa;i++)
    {
        long long c=card(aa,max(aa-i,i))/card(min(aa-i,i),1);
        l[i]=c*fast(k1,i)*fast(k2,aa-i);
    }
    for(int i=0;i<=bb;i++)
    {
        long long c=card(bb,max(bb-i,i))/card(min(bb-i,i),1);
        r[i]=c*fast(k2,i)*fast(k1,bb-i);
    }
    double ans=0;
    for(int i=0;i<=aa;i++)
    {
        for(int j=0;j<=bb;j++)
        {
            if(i+j>=m)
                ans+=l[i]*r[j];
        }
    }
    printf("%.3f",ans);
    return 0;
}

```

---

## 作者：一只小兔子 (赞：1)

~~概率动态规划？不，这就是数学题。~~

给定 $N$ 道题和一 $01$ 串，若第 $i$ 个字符为 $1$，则第 $i$ 题正确概率为 $p$，否则为 $1-p$。求至少 $Q$ 道题正确的概率。（$p=\frac{A}{100}$）

注意到改变题目顺序不会影响结果，只有字符串中 $0$ 和 $1$ 的个数有影响。令 $1$ 的个数为 $c$， $0$ 的个数为 $d$。

考虑刚好有 $q$ 道题正确，其中有 $i$ 道题对应 $1$，则共计有

$$C^c_iC^d_{q-i}$$

种可能性，每种可能性的概率为

$$p^i(1-p)^{c-i}(1-p)^{q-i}p^{d-q+i}=p^{d-q+2i}(1-p)^{c+q-2i}$$

（对应 $1$，$i$ 道题正确，$c-i$ 道题错误，每道题正确概率为 $p$）

（对应 $0$，$q-i$ 道题正确，$d-(q-i)$ 道题错误，每道题正确概率为 $1-p$）

放在一起，答案就是

$$ans=\sum^n_{q=Q}\sum^q_{i=0}C^c_iC^d_{q-i}p^{d-q+2i}(1-p)^{c+q-2i}$$

然后输出。注意当 $m>n$ 或 $m<0$ 时 $C^n_m=0$。

特判一下 $Q=0$ 时答案是 $1.000$。

```c
#include<cstdio>//P2111
long long C(int n,int m){
	if(m+m>n)m=n-m;if(m<0)return 0;if(m==0)return 1;long long ans=1;
	for(int i=1;i<=m;++i)ans*=(n-i+1),ans/=i;
	return ans;
}
double pow(double p,int k){
	if(k<0)return 0.0;
	double ans=1.0;while(k--)ans*=p;return ans;
}
double hyper(int cp,int cq,int dp,int tot){
	double p=dp*0.01,q=(100-dp)*0.01,ans=0.0;
	for(int i=0;i<=tot;++i){
		ans+=1.0*C(cp,i)*C(cq,tot-i)*pow(q,cp+tot-i-i)*pow(p,cq-tot+i+i);
	}
	return ans;
}
int main(){
	int n,a,q,cr=0,wr=0;char seq[55];
	scanf("%d%d%d\n",&n,&a,&q);
	if(q==0)return printf("1.000")-5;
	scanf("%s",seq);
	for(int i=0;i<n;++i){if(seq[i]=='0')++wr;else ++cr;}
	double ans=0.0;
	for(int i=q;i<=n;++i)ans+=hyper(cr,wr,a,i);
	printf("%.3lf",ans);
}
```

---

## 作者：vеctorwyx (赞：1)

### ~~数据这么小写什么搜索， dp啊~~

设 $ dp_{i,j}$表示前$ i$道题对了$j$道。

转移分两种情况：

- 如果当前题目对了，那么概率为

	$\begin{cases}
    dp_{i-1,j-1} \times (1 - m\%) (\text{答案与小明不一样})\\
     dp_{i - 1, j - 1} \times m \%  (\text{答案与小明一样})\\
    \end{cases}$
    
- 如果当前题目错了，那么概率为
	
    $\begin{cases}
    dp_{i-1,j} \times m\% (\text{答案与小明不一样})\\
     dp_{i - 1, j} \times (1 - m \%)  (\text{答案与小明一样})\\
    \end{cases}$

则转移方程就是上述两种情况求和。

$$\large dp_{i,j} = \begin{cases} 
		dp_{i - 1, j-1} \times (1-m\%) + dp_{i-1,j} \times m\% (\text{答案与小明不一样})\\
      dp_{i - 1, j - 1} \times m \%  + dp_{i - 1, j} \times (1 - m \%)  (\text{答案与小明一样})\\
	\end{cases}$$

答案即为 $\large\sum_{i=k}^n dp_{n,i}$
    
code：

```
#include<bits/stdc++.h>
using namespace std;
int n, m, k;
double gl;
double dp[60][60];
char c[100010];
signed main(){
	dp[0][0] = 1;//赋初值
	scanf("%d%d%d", &n, &m, &k);
	gl = m / 100.0;// 处理概率
	scanf("%s", c + 1);
	if(k == 0){//毫无卵用的特判
		puts("1.000");
		return 0;
	}
	for(int i = 1; i <= n; i++)
		for(int j = 0; j <= i; j++)
			dp[i][j] = dp[i - 1][j] * (c[i] == '1' ? 1 - gl : gl) + dp[i - 1][j - 1] * (c[i] == '1' ? gl : 1 - gl);
	double ans = 0;
	for(int j = k; j <= n; j++)//答案求和
		ans += dp[n][j];
	printf("%.3lf\n", ans);
}
```
PS. 标签里的搜索。。。

---

## 作者：Φρανκ (赞：0)

题意：给定 $n$ 道题目正确的概率，求至少有 $q$ 题正确的概率。

核心思想：DP

解：

注意到若一道题为 $1$，则其正确率为 $a\%$，反之则为 $(100-a)\%$。则前 $i$ 题中对 $j$ 题的概率 $f(i,j)$ 在第 $i$ 题为 $0$ 时等于 $f(i-1,j-1)\times (100-a)\%+f(i-1,j)\times a\%$，否则为 $f(i-1,j-1)\times a\%+f(i-1,j)\times (100-a)\%$，依此二式DP即可。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int n, a, q;
char ch;
double b[51][51], res;
int main()
{
	cin>>n>>a>>q;
	if(q==0)
	{
		cout<<"1.000";
		return 0;
	}//特判
	b[0][0]=1;//初始化
	for(int i=1; i<=n; i++)
	{
		cin>>ch;
		if(ch=='0') 
			for(int j=0; j<=n; j++)
				b[i][j]=b[i-1][j]*a/100+b[i-1][j-1]*(100-a)/100;
		else
			for(int j=0; j<=n; j++)
				b[i][j]=b[i-1][j-1]*a/100+b[i-1][j]*(100-a)/100;
	}//DP
	for(int i=q; i<=n; i++)
		res+=b[n][i];//计算结果
	cout<<fixed<<setprecision(3)<<res;//输出
	return 0;
}

```


---

## 作者：Mine_King (赞：0)

这题是概率dp  
设$f_{i,j}$为前$i$题对$j$题的概率。很明显$f_{i,j}$会由$f_{i-1,j}$和$f_{i-1,j-1}$转换过来，分别对应这题没做对和做对。  
对于每个$f_{i,j}$，如果这题（指第$i$题，下同）是$0$，即答案不同，那么结果就是小红这题做错的概率（$f_{i-1,j}$）乘上小明的正确率（$A\%$）（小红没做对对应小明作对，因为他们的答案不一样）加小红这题作对的概率（$f_{i-1,j-1}$）乘上小明的错误率（$1-A\%$）。也就是：
$$f_{i,j}=f_{i-1,j} \times A\% + f_{i-1,j-1} \times (1-A\%)$$
而如果答案相同，很明显和上面相反，也就是：
$$f_{i,j}=f_{i-1,j} \times (1-A\%) + f_{i-1,j-1} \times A\%$$
那么，式子推出来了，就没有什么问题了。

接下来是~~大家喜闻乐见的~~代码：
```cpp
#include<cstdio>
using namespace std;
int n,q;
double ans,a,f[55][55];
//注意这些要开double哦！
int main()
{
	scanf("%d%lf%d",&n,&a,&q);
	a/=100;//百分数转小数
	if(q==0)//特判一下
	{
		printf("1.000\n");
		return 0;
	}
	f[0][0]=1;//明显，前0题对0道的概率是100%
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%1d",&x);//边读入边处理
		for(int j=0;j<=n;j++)
			if(!x) f[i][j]=f[i-1][j]*a+f[i-1][j-1]*(1-a);//答案不同的情况
			else f[i][j]=f[i-1][j]*(1-a)+f[i-1][j-1]*a;//答案相同的情况
	}
	for(int i=q;i<=n;i++) ans+=f[n][i];
    //最后要枚举一遍前n道作对q~n道的概率，把他们加起来，这样才是作对>=q道题的概率
	printf("%.3lf",ans);
	return 0;
}
```
最后浪费您一点时间，安利一下[我的博客](https://www.luogu.com.cn/blog/195331/)  
如果$\LaTeX$挂了也可以去我的博客查看

---

## 作者：XHRlyb_2001 (赞：0)

（我好弱啊TAT……）

看到大神们都随随便便写一个DP就A掉了，我还在写模拟……

大概就是一个算概率的问题吧，思路还是比较好想的。因为q的范围比较小，所以给题分了分类，nd是q/100概率做对的题目的数目，nc是q/100概率做错的题目的数目，cc[x]是组合数C（nc，x），cd[x]是C（cd，x）。

贴一下代码吧（难看QAQ……）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
char ch;
int n,q,nd,nc,cd[6],cc[6];
double p,ans=0;
double ksm(double a,int b)
{
    double num=1;
    for (;b;a=a*a,b>>=1)
     if (b&1) num=num*a;
    return num;
}
int main()
{
    scanf("%d %lf %d\n",&n,&p,&q);
    if (n<=50)
    {
        q=n-q;
        while ((ch=getchar())!='0'&&ch!='1') ch=getchar();
        while (ch=='0'||ch=='1')
        {            
            if (ch=='1') nd++;
            if (ch=='0') nc++;
            ch=getchar(); 
        }
        cd[0]=1, cd[1]=nd, cd[2]=cd[1]*(nd-1)/2, cd[3]=cd[2]*(nd-2)/3, cd[4]=cd[3]*(nd-3)/4,cd[5]=cd[4]*(nd-4)/5;
        cc[0]=1, cc[1]=nc, cc[2]=cc[1]*(nc-1)/2, cc[3]=cc[2]*(nc-2)/3, cc[4]=cc[3]*(nc-3)/4,cc[5]=cc[4]*(nc-4)/5;
        for (int i=0;i<=q;i++)   
        {
            for (int j=0;j<=min(i,nc);j++)    
            {
                if (i-j>nd) continue;
                ans+=cc[j]*ksm(p*0.01,j)*cd[i-j]*ksm((1-p*0.01),i-j)*ksm(1-p*0.01,nc-j)*ksm(p*0.01,nd-i+j); 
            }
        }
        printf("%.3lf",ans);
    }
    else 
    {
        printf("1.000");
        return 0;
    }
    return 0;
} 
```

---


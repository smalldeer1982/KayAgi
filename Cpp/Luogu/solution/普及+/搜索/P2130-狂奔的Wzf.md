# 狂奔的Wzf

## 题目背景

众所周知，Wzf一直想写作业。可是今天，它的作业被WSD抢了！！！Wzf很愤怒？！他决定以最快的速度，冲向作业。在他面前是一个迷宫，作业就在其中！


## 题目描述

Wzf从（1,1）开始，每秒可以向上下左右某一方向走2的次方步，问至少多久可以到达作业？


## 说明/提示

1<n,m<1000，保证起点不是障碍


## 样例 #1

### 输入

```
2 2
$$
.#```

### 输出

```
2```

# 题解

## 作者：xhQYm (赞：8)

- 题目链接：[P2130 狂奔的Wzf](https://www.luogu.com.cn/problem/P2130)



题外话：这题题目是有问题的，因为题目没有说 `.` 代表什么意思，也没有保证连通性，这题的 `.` 当成是障碍就行，至于连通性，就当成保证联通即可。（希望管理员可以早点改正这题题面）。


----

这题跟普通的搜索不一样的地方就是说可以走 $2^k$ 步，普通搜索不是用数组记录吗？那这题也一样啊！

所以我们这样来记录：

```
const int d[]={1,2,4,8,16,32,64,128,256,512};//2^9足够了
```
（当然还有倒着走，就是再循环一遍，取负即可）


但是你在往前走 $2^k$ 步的时候，这个点到走 $2^k$ 步后的点这条路径必须保证没有障碍才可以走，这个如果暴力循环判断复杂度直接上天，所以我们考虑用 [前缀和](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%89%8D%E7%BC%80%E5%92%8C&fenlei=256&rsv_pq=9ba3ac3a000cfc92&rsv_t=57816MWHgh1fHAbgMNNYYKDcbzbVfKFtKrsrsar3I0L57IorOSTessZvLJA&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=16&rsv_sug1=13&rsv_sug7=101&rsv_sug2=0&rsv_btype=i&inputT=3546&rsv_sug4=3546) 来解决。

具体就是用 `h1` 和 `h2` 数组来记录前缀和，之后直接判断即可。（这个很容易理解，可以看代码里面）。

然后剩下的注意细节即可。

代码（含详细注释）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int d[]={1,2,4,8,16,32,64,128,256,512};
const int N=1010;
int n,m,fx,fy,h1[N][N],h2[N][N],length=10;
char g[N][N],lis[N];
bool st[N][N];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",lis);//读入优化，string无法用scnaf读入，所以先用char字符串读入之后再赋值到string
        for(int j=1;j<=m;j++)
        {
            g[i][j]=lis[j-1];
            if(g[i][j]=='#')//记录终点
                fx=i,fy=j;
            h1[i][j]=((g[i][j]=='#' || g[i][j]=='$')?0:1)+h1[i][j-1];
            h2[i][j]=((g[i][j]=='#' || g[i][j]=='$')?0:1)+h2[i-1][j];
            //以上是前缀和，其中g[i][j]是#或者$就可以走这个点
        }
    }
    queue<int> q1,q2,q3;
    q1.push(1),q2.push(1),q3.push(0);
    st[1][1]=true;
    while(!q1.empty())
    {
        int x=q1.front(),y=q2.front(),k=q3.front();
        q1.pop(),q2.pop(),q3.pop();
        if(x==fx && y==fy){printf("%d",k);return 0;}//到重点输出即可
        for(int i=0;i<length;i++)//正着走
        {
            int tx=x+d[i],ty=y;
            if(tx>=1 && tx<=n && ty>=1 && ty<=m && !st[tx][ty] && (g[tx][ty]=='$' || g[tx][ty]=='#') && !(h2[tx][ty]-h2[x][y]))
                st[tx][ty]=true,q1.push(tx),q2.push(ty),q3.push(k+1);
            tx=x,ty=d[i]+y;
            if(tx>=1 && tx<=n && ty>=1 && ty<=m && !st[tx][ty] && (g[tx][ty]=='$' || g[tx][ty]=='#') && !(h1[tx][ty]-h1[x][y]))
                st[tx][ty]=true,q1.push(tx),q2.push(ty),q3.push(k+1);
        }
        for(int i=0;i<length;i++)//倒着走
        {
            int tx=x+(-d[i]),ty=y;
            if(tx>=1 && tx<=n && ty>=1 && ty<=m && !st[tx][ty] && (g[tx][ty]=='$' || g[tx][ty]=='#') && !(h2[tx][ty]-h2[x][y]))
                st[tx][ty]=true,q1.push(tx),q2.push(ty),q3.push(k+1);
            tx=x,ty=(-d[i])+y;
            if(tx>=1 && tx<=n && ty>=1 && ty<=m && !st[tx][ty] && (g[tx][ty]=='$' || g[tx][ty]=='#') && !(h1[tx][ty]-h1[x][y]))
                st[tx][ty]=true,q1.push(tx),q2.push(ty),q3.push(k+1);
        }
    }
    return 0;
}
```

类似题面（只不过是最短路），比这题要简单：[P1613 跑路](https://www.luogu.com.cn/problem/P1613)

如果有错误或者问题欢迎提出。


---

## 作者：___w (赞：7)

### [P2130 狂奔的Wzf](https://www.luogu.com.cn/problem/P2130)

#### 题意简述
从 $(1,1)$ 开始，每秒可以向上下左右某一方向走 $2$ 的次方步，问至少多久可以到达作业。

#### 题目分析
注意点 $1<n,m<1000$，我们可以考虑搜索。因为题目要求的是最短耗时，所以用 bfs 比较合适，第一次到达终点的即为答案。

这一题与其他迷宫题不同之处在于可以走 $2$ 的次方步，但是途径的地方不能是障碍。步长可以用一个数组记录，最多到 $512$。至于判断障碍物，我们可以用前缀和。下文以每一行为例，用数组 $L$ 来分别统计每行的第一列到点 $(i,j)$ 的障碍数有多少个。有公式:

$$L_{i,j}=L_{i,j-1}+P_{i,j}$$

其中 $P_{i,j}$ 为点 $(i,j)$ 上是否有障碍物。有，则为 $1$；没有，则为 $0$。

有了前缀和，我们则可以判断点 $(x,y)$ 到点 $(x,z)$ 上是否有障碍物。若 $L_{x,z}-L_{x,y}=0$，则路径上没有障碍物；否则没有障碍物。每一列判断也同理。

其他则就同普通的迷宫一般了，具体看代码。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000;
struct node {
	int x, y, t;
} ;
int n, m, h[N][N], l[N][N];
int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
int p[10] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};
bool vis[N][N];
char c[N][N];
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			cin >> c[i][j];
			h[i][j] = h[i-1][j]+(c[i][j] == 'X');
			l[i][j] = l[i][j-1]+(c[i][j] == 'X');
		}
	queue <node> q;
	q.push((node){1, 1, 0}), vis[1][1] = 1;
	while (!q.empty()) {
		node now = q.front(); q.pop();
		if (c[now.x][now.y] == '#') {
			cout << now.t;
			return 0;
		}
		for (int i = 0; i < 4; ++i)
			for (int j = 0; j < 10; ++j) {
				int x = now.x+d[i][0]*p[j], y = now.y+d[i][1]*p[j];
				if (x < 1 || x > n || y < 1 || y > m || vis[x][y]) continue;
				if (c[x][y] == 'X') break;
				if (d[i][0] && h[x][y]-h[now.x][now.y]) break;
				if (d[i][1] && l[x][y]-l[now.x][now.y]) break;
				q.push((node){x, y, now.t+1}), vis[x][y] = 1;
			}
	}
	cout << -1;
	return 0;
}
```
[record](https://www.luogu.com.cn/record/113984600)。

---

## 作者：单曦增 (赞：6)

### 吐槽：一道水水的广搜，把我虐了一天

----------------------------

分析：

看似是正常的广搜，从每个点扩展出长度为$2^k$的路径，那么只要暴搜就好了

----------------------------

关于查询两点之间的联通性：

可以在每一列和每一行维护一个前缀和，障碍设为1，否则设为0，然后在搜索时只需要求一下终点与起点的差，如果是零，则两点联通

----------------------------

关于到底是 . 还是 X ？

其实无所谓，除了 $ 和 # ，别的全部都是障碍

时间复杂度：$O(n*logn)$

n<=1000 轻松跑过

---------------------------

代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int Maxn=1100;
int n,m,f[Maxn][Maxn],b[Maxn][Maxn],c[Maxn][Maxn],d[Maxn*Maxn][2],tx,ty,temp;
//f[i][j]表示从起点到i,j最少的时间，
//b[i][j]表示第i行上的前j个元素的和，c[i][j]表示第j列上前i行元素的和，d是队列
char a[Maxn];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",a);
		int len=strlen(a);
		for(int j=0;j<len;j++)
		{
			if(a[j]=='$'||a[j]=='#')
			{
				if(a[j]=='#')
				{
					tx=i;
					ty=j+1;
				}
				temp=0;
			}
			else
				temp=1;
			b[i][j+1]=temp+b[i][j];
			c[i][j+1]=temp+c[i-1][j+1];//前缀和
		}
	}
	int t=0,w=1;
	memset(f,-1,sizeof(f));
	d[1][0]=1;
	d[1][1]=1;
	f[1][1]=0;
	while(t<w)
	{
		if(f[tx][ty]>=0)
			break;
		t++;
		int nx=d[t][0],ny=d[t][1],now=f[nx][ny]+1;
		temp=1;
		while(nx+temp<=n)//向下走
		{
			if(f[nx+temp][ny]!=-1)
			{
				temp<<=1;
				continue;
			}
			if(c[nx+temp][ny]-c[nx][ny]>0)//前缀和之差>0则说明中间有障碍
				break;
			f[nx+temp][ny]=now;
			d[++w][0]=nx+temp;
			d[w][1]=ny;
			temp<<=1;
		}
		temp=1;
		while(nx-temp>0)//向上走
		{
			if(f[nx-temp][ny]!=-1)
			{
				temp<<=1;
				continue;
			}
			if(c[nx-1][ny]-c[nx-temp-1][ny]>0)
				break;
			f[nx-temp][ny]=now;
			d[++w][0]=nx-temp;
			d[w][1]=ny;
			temp<<=1;
		}
		temp=1;
		while(ny+temp<=m)//向右走
		{
			if(f[nx][ny+temp]!=-1)
			{
				temp<<=1;
				continue;
			}
			if(b[nx][ny+temp]-b[nx][ny]>0)
				break;
			f[nx][ny+temp]=now;
			d[++w][0]=nx;
			d[w][1]=ny+temp;
			temp<<=1;
		}
		temp=1;
		while(ny-temp>0)//向左走
		{
			if(f[nx][ny-temp]!=-1)
			{
				temp<<=1;
				continue;
			}
			if(b[nx][ny-1]-b[nx][ny-temp-1]>0)
				break;
			f[nx][ny-temp]=now;
			d[++w][0]=nx;
			d[w][1]=ny-temp;
			temp<<=1;
		}
	}
	printf("%d\n",f[tx][ty]);
	return 0;
}
```

---

## 作者：Ch35 (赞：5)

[返回题目](https://www.luogu.com.cn/problem/P2130)

这是我第一次写题解，若有疏漏，敬请大家批评指出。

这是一道搜索题，我在此讲解宽搜算法。

因为这道题的样例不强，不能准确地解释算法，我干脆出了一个例子：
```
4 4
....
.#.#
#...
....
```
相信各位都知道，宽搜是使用队列来实现的，下面是此题队列的使用方法：
![](https://cdn.luogu.com.cn/upload/image_hosting/43zrc3u5.png)

如图所示，设两个队列，分别储存 $x$ 和 $y$ 坐标，先存入起点坐标 $(1,1)$，再往四面扩展，找到合法的决策时就将其存入队列，便于以后读取，当然，还要记录某个点是否走过，以及每个点的步数，不然无法通过此题。

每次循环过后，要清除过期的队首元素。

如果走到了终点，就输出步数，跳出循环。

但没有合法路径怎么办？思考一下，如果没有合法路径，在一个时刻队列将是空的，发现这一情况时，就输出无解，不要再循环下去，不然读取一个空的队列的首个元素，非运行错误不可。

还有，这道题有几个注意点：

- 不能在走 $2$ 的次方步时跳跃障碍（很多人在写代码时忽略了这一点）；

- 别忘记了 $1$ 是 $2^0$，走一步也是允许的；

- 此题数据不能使深搜算法通过，深搜我顶多只拿到了 $30$ 分，但宽搜能满分。

- 个人推荐使用数组记录 $2^n$，因为 $1000$ 以内的这些数只有 $10$ 个，比电脑生成要简单得多：$1,2,4,8,16,32,64,128,256,512$。



代码展示：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool b[1005][1005];
int n,m,fi_x,fi_y,xx,yy,bs[1005][1005];// fi_x 和 fi_y  记录终点的坐标， xx 和 yy 记录当前的坐标， b 数组记录是否访问, bs 数组记录当前步数。
char a[1005][1005];//记录地图
queue<int>x;//储存 x 坐标
queue<int>y;//储存 y 坐标
int cf[15]={0,1,2,4,8,16,32,64,128,256,512};//因为1000以内的2次方数只有10个，所以可以定数组存起来判断。
bool is_cf(int z){//利用cf数组判断2次方数
    for(int i=1;i<=10;i++){
        if(z==cf[i])return 1;//是2次方数
    }
    return 0；//不是2次方数
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
	    for(int j=1;j<=m;j++){
	        cin>>a[i][j];
	        if(a[i][j]=='#')fi_x=i,fi_y=j;//标记终点坐标
        }
    }
    b[1][1]=1;//初始化
    x.push(1);
    y.push(1);
    while(1){
        xx=x.front(),yy=y.front();//读取队列
        if(xx==fi_x&&yy==fi_y){
            cout<<bs[fi_x][fi_y];//到达终点，输出最小步数
            return 0;
        }
        for(int i=1;;i++){//往上走
            if(xx-i>0&&a[xx-i][yy]!='X'){//排除出地图和遇到障碍的情况
                if(is_cf(i)&&b[xx-i][yy]==0{// i 是 2 的次方数且这个点未走过
                    x.push(xx-i);//储存这个点的信息
                    y.push(yy);
                    bs[xx-i][yy]=bs[xx][yy]+1;
                    b[xx-i][yy]=1;
                }
            }
            else break;
        }
        for(int i=1;;i++){
            if(yy-i>0&&a[xx][yy-i]!='X'){//排除出地图和遇到障碍的情况
                if(is_cf(i)&&b[xx][yy-i]==0){// i 是 2 的次方数且这个点未走过
                    x.push(xx);//储存这个点的信息
                    y.push(yy-i);
                    bs[xx][yy-i]=bs[xx][yy]+1;
                    b[xx][yy-i]=1;
                }
            }
            else break;
        }
        for(int i=1;;i++){
            if(yy+i<=m&&a[xx][yy+i]!='X'){//排除出地图和遇到障碍的情况
                if(is_cf(i)&&b[xx][yy+i]==0){// i 是 2 的次方数且这个点未走过
                    x.push(xx);//储存这个点的信息
                    y.push(yy+i);
                    bs[xx][yy+i]=bs[xx][yy]+1;
                    b[xx][yy+i]=1;
                }
            }
            else break;
        }
        for(int i=1;;i++){
            if(xx+i<=n&&a[xx+i][yy]!='X'){//排除出地图和遇到障碍的情况
                if(is_cf(i)&&b[xx+i][yy]==0{// i 是 2 的次方数且这个点未走过
                    x.push(xx+i);//储存这个点的信息
                    y.push(yy);
                    bs[xx+i][yy]=bs[xx][yy]+1;
                    b[xx+i][yy]=1;
                }
            }
            else break;
        }
        x.pop(),y.pop();//删除已处理的队列元素
        if(x.empty()){//队列为空代表无解
            cout<<-1;//无解
            return 0;
        }
    }
	return 0;
}
```
希望大家看完我的题解后会理解思路，打出满分代码。

[我的AC记录](https://www.luogu.com.cn/record/78647624)


---

## 作者：晨曦墨凝 (赞：4)

题考察算法为**广搜**、**前缀和**。

值得注意的地方：

- Wzf身怀绝技，可以在一单位时间内走 $2$ 的次方步（包括 $2^{0}$ 步）；
- 但这并不代表他会穿墙，所以路径中若有障碍，就不能走；
- 起点是 $(1, 1)$；
- 起点可能存在障碍，需要手动清除。

难点：如何维护路径中有无障碍。

答案是：利用前缀和的思想，用两个数组分别维护行与列的障碍数。这样我们只要用终点减起点就可以知道中间是否有障碍（若差为正数，则路径中有障碍）。

Code
```
#include <iostream>
#include <cstdio>
#include <queue>
#define MAXN 1001
using namespace std;

int n, m;
int s1[MAXN][MAXN];
int s2[MAXN][MAXN];
char a[MAXN][MAXN];
bool vis[MAXN][MAXN];
int dx[] = {0, 1, 0, -1};   //方向
int dy[] = {1, 0, -1, 0};   //方向
struct node { int x, y, t; };
queue <node> q;
int pre[15] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};  //大个小表，把步长提前准备好

void prepare()
{
	node tmp = {1, 1, 0};
	q.push(tmp);
	vis[1][1] = true;
}

int main()
{
    ios::sync_with_stdio(false);    //cin、cout关闭同步，可以优化读入输出速度，但是大考不要用
    cin.tie(0),cout.tie(0);

	cin >> n >> m;
	for (register int i = 1; i <= n; ++i)
	{
		for (register int j = 1; j <= m; ++j)
		{
			cin >> a[i][j];
			s1[i][j] = s1[i][j - 1] + (a[i][j] == 'X'); //用前缀和记录障碍
			s2[i][j] = s2[i - 1][j] + (a[i][j] == 'X');
		}
	}
	prepare();
	while (!q.empty())
	{
		node u = q.front(); q.pop();
		for (register int i = 0; i < 4; ++i)
		{
			for (register int j = 0; j < 10; ++j)
			{
				int nx = u.x + dx[i] * pre[j], ny = u.y + dy[i] * pre[j];
				if (nx < 1 || nx > n || ny < 1 || ny > m) break;    //越界则break
				if (vis[nx][ny]) continue;      //访问过则continue
                if (a[nx][ny] == 'X') break;    //Wzf碰到了障碍则break
				if (dy[i] && s1[nx][ny] - s1[u.x][u.y]) break;  //若Wzf沿y轴走且路径中有障碍则break
				if (dx[i] && s2[nx][ny] - s2[u.x][u.y]) break;  //若Wzf沿x轴走且路径中有障碍则break
				if (a[nx][ny] == '#')   //Wzf找到了作业！
				{
					cout << u.t + 1;
					return 0;
				}
				vis[nx][ny] = 1;    //标记已访问
				node tmp = {nx, ny, u.t + 1};
				q.push(tmp);
			}
		}
	}
	cout << -1;   //Wzf没能找到作业则输出-1
	return 0;
}
```


---

## 作者：liangbowen (赞：2)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P2130)

[更好的阅读体验？](https://www.luogu.com.cn/blog/liangbowen/solution-p2130)

本题是练习 bfs 的好题。

## 思路

结合代码进行思路讲解。

首先是读入部分，我们可以用 `bool` 存下地图，节省空间开销。

需要注意，数据比较烂，**起始点可能有障碍**。

我们可以霸气地把起始点的障碍消掉。

```cpp
const int N = 1005;
bool a[N][N];
int n, m, fx, fy;
void Input() //简单的输入。我们可以用 bool 存地图，减少空间开销。 
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			char x;
			cin >> x;
			if (x == '$' || x == '.') a[i][j] = true;
			if (x == 'X') a[i][j] = false;
			if (x == '#') fx = i, fy = j, a[i][j] = true;
		}
	a[1][1] = true; //本题数据很烂，(1,1) 可能有障碍，需要手动消除。 
}
```

然后就是 bfs 了。在 bfs 之前，我们准备一堆移动数组：

```cpp
//这些是用来记录答案的数组。 
struct Node {int x, y;};
int ans[N][N];
bool vis[N][N];

//下面这个，是记录步数的表格（个人习惯下标从 1 开始）。
int foot[15] = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024};
//下面这个，是上下左右的方位数组（个人习惯下标从 1 开始）。
int dict[5][2] = {{0, 0}, {1, 0}, {-1, 0}, {0, 1}, {0, -1}}; 
```

本题最特殊的地方在于，**每一步走动之间不能有障碍**。这是显然的事情。

因此，我们可以在 bfs 中用函数 $\texttt{run()}$ 判断能否走动。

具体如下：

```cpp
int bfs() //基本上和 bfs 的模版区别不大。
{
	queue <Node> Q;
	ans[1][1] = 0, vis[1][1] = true;
	Q.push( (Node){1, 1} );
	while (!Q.empty())
	{
		int x = Q.front().x, y = Q.front().y;
		//cout << "x = " << x << ", y = " << y << ".\n";
		if (x == fx && y == fy) return ans[x][y];
		Q.pop();
		for (int i = 1; i <= 4; i++)
			for (int j = 1; j <= 10; j++)
			{
			    //以下稍微有点特殊。
				int dx = x + dict[i][0] * foot[j], dy = y + dict[i][1] * foot[j];
				if (dx < 1 || dx > n || dy < 1 || dy > m) continue;
				if (!run(x, y, dx, dy) || vis[dx][dy]) continue;
				ans[dx][dy] = ans[x][y] + 1, vis[dx][dy] = true;
				Q.push( (Node){dx, dy} );
			}
	}
	return -1;
}
```

观察这份代码，容易发现，时间复杂度 $O(n\times m \times\log n)$ 加上 $\texttt{run()}$ 的时间复杂度。

如果 $\texttt{run()}$ 仍然暴力枚举，时间复杂度将会是 $O(n\times m \times\log^2 n)$，极大可能超时。

因此，我们试图让 $\texttt{run()}$ 函数 $O(1)$ 计算。

---

事实上，我们可以前缀和优化它。

具体地，设 $sum_{i, j}$ 表示 $(1,1)$ 到 $(i,j)$ 的矩阵中，不可以走的点的个数。 

这个就是典型的二维前缀和：$sum_{i, j} = sum_{i-1,j} + sum_{i, j-1} - sum_{i-1,j-1} + [a_{i,j} = false]$。

```cpp
//sum[i][j] 表示 (1,1) 到 (i,j) 的矩阵中，不可以走的点的个数。 
int sum[N][N];
void init() //预处理前缀和。 
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + (a[i][j] == false);
	//for(int i=1;i<=n;i++,cout<<'\n')for(int j=1;j<=m;j++)cout<<sum[i][j]<<' ';
}
```

那么，$\texttt{run()}$ 只需要让 $(x1,y1)$ 到 $(x2,y2)$ 的矩阵中，无法走的点的数量为 $0$ 即可。

```cpp
bool run(int x1, int y1, int x2, int y2) //判断能否从 (x1,y1) 到 (x2,y2)。 
{
	if (x1 > x2 || y1 > y2) swap(x1, x2), swap(y1, y2);
	int s = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1];
	return (s == 0);
}
```

至此，本题结束。时间复杂度上文已经提到，是 $O(n^2 \log n)$ 级别的。

## 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
void Fastio()
{
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);	
}
const int N = 1005;
bool a[N][N];
int n, m, fx, fy;
void Input() //简单的输入。我们可以用 bool 存地图，减少空间开销。 
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			char x;
			cin >> x;
			if (x == '$' || x == '.') a[i][j] = true;
			if (x == 'X') a[i][j] = false;
			if (x == '#') fx = i, fy = j, a[i][j] = true;
		}
	a[1][1] = true; //本题数据很烂，(1,1) 可能有障碍，需要手动消除。 
}

//sum[i][j] 表示 (1,1) 到 (i,j) 的矩阵中，不可以走的点的个数。 
int sum[N][N];
void init() //预处理前缀和。 
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + (a[i][j] == false);
	//for(int i=1;i<=n;i++,cout<<'\n')for(int j=1;j<=m;j++)cout<<sum[i][j]<<' ';
}

bool run(int x1, int y1, int x2, int y2) //判断能否从 (x1,y1) 到 (x2,y2)。 
{
	if (x1 > x2 || y1 > y2) swap(x1, x2), swap(y1, y2);
	int s = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1];
	return (s == 0);
}

//这些是用来记录答案的数组。 
struct Node {int x, y;};
int ans[N][N];
bool vis[N][N];

//下面这个，是记录步数的表格（个人习惯下标从 1 开始）。
int foot[15] = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024};
//下面这个，是上下左右的方位数组（个人习惯下标从 1 开始）。
int dict[5][2] = {{0, 0}, {1, 0}, {-1, 0}, {0, 1}, {0, -1}}; 

int bfs()
{
	queue <Node> Q;
	ans[1][1] = 0, vis[1][1] = true;
	Q.push( (Node){1, 1} );
	while (!Q.empty())
	{
		int x = Q.front().x, y = Q.front().y;
		//cout << "x = " << x << ", y = " << y << ".\n";
		if (x == fx && y == fy) return ans[x][y];
		Q.pop();
		for (int i = 1; i <= 4; i++)
			for (int j = 1; j <= 10; j++)
			{
			    //以下稍微有点特殊。
				int dx = x + dict[i][0] * foot[j], dy = y + dict[i][1] * foot[j];
				if (dx < 1 || dx > n || dy < 1 || dy > m) continue;
				if (!run(x, y, dx, dy) || vis[dx][dy]) continue;
				ans[dx][dy] = ans[x][y] + 1, vis[dx][dy] = true;
				Q.push( (Node){dx, dy} );
			}
	}
	return -1;
}
int main()
{
	Fastio();
	Input();
	init();
	cout << bfs();
	return 0;
}
``` 

希望能帮助到大家！

---

## 作者：ZnHF (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P2130)
### 题意简述
给定一张 $n \times m$ 的地图，从坐标 $(1,1)$ 开始，每次操作可以在上，下，左，右，四个方向中任选一个方向，移动 $2^k$ 个格子，移动时不能经过障碍物，也不能站在有障碍物的格子上，求至少需要几次操作才能到达终点，也就是作业所在的位置。
### 题目分析
这道题可以使用 BFS 算法解决。

与其他 BFS 题目不同，这道题要求每次操作所走的格子的数量是 $2^k$，观察数据范围，每次最多可以 $512$ 个格子。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int d[11]={1,2,4,8,16,32,64,128,256,514,1024};//每次移动的距离，这里没有必要写到1024，写到512即可
int n,m,sum_line[1001][1001],sum_col[1001][1001];
char maze[1001][1001];
bool vis[1001][1001],flag;
struct node{
	int x,y,ans;
}temp;
queue<node> q;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>maze[i][j];
			if(maze[i][j]=='X'){
				sum_line[i][j]=sum_line[i-1][j]+1;
				sum_col[i][j]=sum_col[i][j-1]+1;
			}
			else{
				sum_line[i][j]=sum_line[i-1][j];
				sum_col[i][j]=sum_col[i][j-1];
			}//以上，预处理障碍物有几个的前缀和
		}
	}
	vis[1][1]=1;
	temp.x=1;
	temp.y=1;
	q.push(temp);
	while(!q.empty()){
		temp=q.front();
		q.pop();
		if(maze[temp.x][temp.y]=='#'){
			cout<<temp.ans;
			flag=1;
			return 0;
		}
		for(int i=0;i<=11;i++){
			int nx=temp.x+d[i],ny=temp.y;
			if(nx<=n && !vis[nx][ny] && !(sum_line[nx][ny]-sum_line[temp.x][temp.y]) && (maze[nx][ny]=='.' || maze[nx][ny]=='$' || maze[nx][ny]=='#')){
				vis[nx][ny]=1;
				node nn;
				nn.x=nx;
				nn.y=ny;
				nn.ans=temp.ans+1;
				q.push(nn);
			}
			nx=temp.x-d[i],ny=temp.y;
			if(nx>=1 && !vis[nx][ny] && !(sum_line[nx][ny]-sum_line[temp.x][temp.y]) && (maze[nx][ny]=='.' || maze[nx][ny]=='$' || maze[nx][ny]=='#')){
				vis[nx][ny]=1;
				node nn;
				nn.x=nx;
				nn.y=ny;
				nn.ans=temp.ans+1;
				q.push(nn);
			}
			nx=temp.x,ny=temp.y+d[i];
			if(ny<=m && !vis[nx][ny] && !(sum_col[nx][ny]-sum_col[temp.x][temp.y]) && (maze[nx][ny]=='.' || maze[nx][ny]=='$' || maze[nx][ny]=='#')){
				vis[nx][ny]=1;
				node nn;
				nn.x=nx;
				nn.y=ny;
				nn.ans=temp.ans+1;
				q.push(nn);
			}
			nx=temp.x,ny=temp.y-d[i];
			if(ny>=1 && !vis[nx][ny] && !(sum_col[nx][ny]-sum_col[temp.x][temp.y]) && (maze[nx][ny]=='.' || maze[nx][ny]=='$' || maze[nx][ny]=='#')){
				vis[nx][ny]=1;
				node nn;
				nn.x=nx;
				nn.y=ny;
				nn.ans=temp.ans+1;
				q.push(nn);
			}//处理每一次操作，注意判断路径上有没有障碍物
		}
	}
	if(!flag) cout<<-1;
	return 0;
}
```

---

## 作者：yzh_Error404 (赞：2)

这题目不就是一道裸的搜索吗？

题目中的 「.」 和 「&#36;」 标记为 `0` ，「X」 标记为 `1` ，「#」 特殊标记即可。

因为一次移动的距离过大，一个一个判障碍肯定会超时，我们需要用一个二维前缀和记录中途是否有障碍物。

每次移动的 $2^k$ 最多为 $1024$ ，每次移动时遍历即可。

重点在于二维前缀和的求区间和，自行画图理解即可。

有一个坑点在于起点上可能有障碍，需要自行消除。

代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1005;
int mo[MAXN]={1,2,4,8,16,32,64,128,256,512,1024};
char ma[MAXN][MAXN];
int n,m;
int ex,ey;
int sum[MAXN][MAXN];
bool vis[MAXN][MAXN];
struct node
{
	int x,y,step;
};
inline void bfs(int x,int y,int step)
{
	queue<node>q;
	q.push((node){x,y,step});
	while(!q.empty())
	{
		node top=q.front();
		q.pop();
		if(top.x==ex&&top.y==ey)
		{
			printf("%d",top.step);
			exit(0);
		}
		if(vis[top.x][top.y])continue;
		vis[top.x][top.y]=1;
		for(register int i=0;i<=10;i++)//向右走 
		{
			int nx=top.x,ny=top.y+mo[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)
				if(sum[nx][ny]-sum[nx-1][ny]-sum[top.x][top.y-1]+sum[top.x-1][top.y-1]==0)q.push((node){nx,ny,top.step+1});
		}
		for(register int i=0;i<=10;i++)//向左走
		{
			int nx=top.x,ny=top.y-mo[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)
				if(sum[top.x][top.y]-sum[top.x-1][top.y]-sum[nx][ny-1]+sum[nx-1][ny-1]==0)q.push((node){nx,ny,top.step+1});
		} 
		for(register int i=0;i<=10;i++)//向下走
		{
			int nx=top.x+mo[i],ny=top.y;
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)
				if(sum[nx][ny]-sum[nx][ny-1]-sum[top.x-1][top.y]+sum[top.x-1][top.y-1]==0)q.push((node){nx,ny,top.step+1});
		} 
		for(register int i=0;i<=10;i++)//向上走
		{
			int nx=top.x-mo[i],ny=top.y;
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)
				if(sum[top.x][top.y]-sum[top.x][top.y-1]-sum[nx-1][ny]+sum[nx-1][ny-1]==0)q.push((node){nx,ny,top.step+1});
		} 
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=m;j++)
		{
			char now;
			cin>>now;
			if(now=='$'||now=='.')ma[i][j]=0;
			if(now=='#')ex=i,ey=j;
			if(now=='X')ma[i][j]=1;
			if(i==1&&j==1)ma[i][j]=0;//坑点，取消即可，不做会WA#9
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+ma[i][j];//二维前缀和
		}
	bfs(1,1,0);
	printf("-1");
	return 0;
}
```

---

## 作者：z2415445508 (赞：2)

quq想来分享一下比较裸的广搜做法（剪枝 + 优化）
比较适合新人食用，楼上的大牛厉害多了（%%%）
题意：
从地图的一个点到另一个点，中间有障碍，可以一次走 2的K次方步；

易混淆的点：(1,1)指的不是笛卡尔坐标系中的(1,1)，而是说从数组角度来看（经常Debug数组的大牛们应该都知道）


第一思路：裸广搜（每到一个点，选择走的步数，循环一遍判断能否到达（中间可能会有障碍））

复杂度很高，预计得分在10 - 30
然后不断地被卡在20的分数，发现总会炸；
检索后发现：

如果**每一次移动我都进行**for循环判断 岂不是30都拿不到？？？
进一步思考：能否通过压位进行障碍判断？
n,m < 1000  不行
前缀和优化可否？
想一想 1000 * 1000 ~~简直无压！~~
操作后发现 **每行每列**都要进行前缀和处理（可能向下走也可能向上走）

那么~~开两个数组？~~我那么懒当然是开三维啦

于是判断： 若区间I - J(j > i)中能走的路为j - i + 1 那么显然这就是可行的路 走就是啦

**操作小技巧**如果 2 ^ 8能走到，那么 2 ^ 4也一定能走到（牺牲了运行时间，保证了更多的运行时间（如果- 2 ^ 10 - 2 ^ 10 全部加入操作，每一个队列中的元素要进行的松弛操作太多了，~~当然是选择放弃大的数啦~~））
**题目坑点**可能是（1,1）是障碍

还有不懂的可以Q我（猜我的ID是什么）,洛谷因为没有实名制不便私信回复，万望谅解，希望各路大牛指出不足共同进步！

代码适合众人食用~~
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 1010;
int n,m,ans;
bool pd[MAXN][MAXN];
bool go[MAXN][MAXN];
bool flag;
int a[MAXN][MAXN][2];
int zdx,zdy;//终点的x 与Y坐标
int x1[21] = {0,8,4,2,1,32,16,-4,-2,-1,-32,-16,-8},
    y1[21] = {0,8,4,2,1,32,16,-4,-2,-1,-32,-16,-8};

void init()
{
    cin >> n >> m;
    for (int i = 1 ; i <= n ; i ++)
        for (int j = 1 ; j <= m ; j ++)
        {
            char ch ;
            cin >> ch;
            if(ch == '#')
            {
                zdx = i,zdy = j;		
                pd[i][j] = 1;
            }//只要是这个字符就都可以走，不讲道理
            else if(ch == '$')
                pd[i][j] = 1;
        }
    return ;
}
void ahead()
{
	pd[1][1] = 1;//把坑点预处理掉
    for (int i = 1 ; i<= n ; i++)
        for (int j = 1 ; j <= m ; j++)
            a[i][j][0] = a[i][j-1][0] + pd[i][j];//这里就是预处理部分关于行列的对比
    for (int j = 1 ; j <= m ;j++)
        for (int i = 1 ; i <= n ; i ++)
            a[i][j][1] = a[i-1][j][1] + pd[i][j];
    return;
}
struct node
{
    int x,y,step;
}q[20000010];
void bfs()
{
    int head = 0,tail = 1;
    q[1].x = 1,q[1].y = 1;
    while(head < tail)//这里选用静态的原因是怕动态会影响速度(LCA中打了Vector 被按在地上锤)了
    {
        head++;
        int nowx = q[head].x ,nowy = q[head].y,nowstep = q[head].step;
        if(go[nowx][nowy])
            continue;
        go[nowx][nowy] = 1;
        
        if(nowx == zdx && nowy == zdy)
        {
            flag = 1;
            ans = nowstep;
            break;
        }//直接跳出
        if(nowx < 1 || nowx > n || nowy < 1 || nowy >m)//越界的老哥您走好（这里加是为了万无一失）
            continue;
        nowstep++;
        for (int i = 1 ; i <= 12 ;i++) //横坐标不变，纵坐标加 
        {
            int tx = nowx + x1[i];
            if(tx > n)
                continue;
            if((a[tx][nowy][1] - a[nowx - 1][nowy][1] == tx - nowx + 1) && !go[tx][nowy]) 
            {
                tail++;
                q[tail].x = tx;
                q[tail].y = nowy;
                q[tail].step = nowstep;
            }	
        }
        for (int i = 1 ; i <= 12 ; i++)
        {
            int ty = nowy + y1[i];
            if(ty > m)//越界情况 不要你
                continue;
            if( (a[nowx][ty][0] - a[nowx][nowy - 1][0] == ty - nowy + 1) && !go[nowx][ty]) 
            {
                tail++;
                q[tail].x = nowx;
                q[tail].y = ty;
                q[tail].step = nowstep;
            }
        }
    }
    printf("%d",ans);
    return ;
}
int main()
{
	freopen("Wzy.in","r",stdin);//不要直接复制哦
    init();//要习惯分块
    ahead();
    bfs();
    return 0;
}
```

---

## 作者：Low_key_smile (赞：1)

#### [题面](https://www.luogu.com.cn/problem/P2130)

### 先说说坑点
1、这道题起点位置需要特判一下，先把这个位置标记为无。


2、爆搜的时候要注意前进的时候不能撞到障碍物，(这一点我也没注意到，一开始做了两个0分)。


3、前缀和判断是否有障碍物(对各位dalao来说应该不是坑点，对我来说就...就没想到)。

### 思路
先用 ma 数组把所有的特殊点和不特殊点都写进去，然后边输入边求前缀和，前缀和是用来判断当前移动的方向的距离单位的所有点上是不是有障碍物的，然后定一个个队列q，直接爆搜，枚举上下左右所有点，直到搜完为止，如果已经输出了那就直接走了，如果没有那就输出$-1$。


### code

```
#include<cmath>
#include<queue>
#include<cstdio>
#include<bitset>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long
//inline char readchar() {static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;}
//inline int read() {int res = 0, f = 0; char ch = readchar(); for(; !isdigit(ch); ch = readchar()) if(ch == '-')f = 1; for(; isdigit(ch); ch = readchar()) res = (res << 1) + (res << 3) + (ch ^ '0'); return f ? -res : res;}

const int N=10001;
int mo[N]= {1,2,4,8,16,32,64,128,256,512,1024};
char ma[N][N];  //枚举所有的2n次方点，因为不会太大，所以到1024即可 
int n,m;
int ex,ey;
int sum[N][N];
bool vis[N][N];
struct node {int x,y,step;};
inline void bfs(int x,int y,int step) 
{
	queue<node>q;
	q.push((node) {x,y,step});//先把传上来的第一个放进q队列 
	while(!q.empty()) 
	{
		node top=q.front();//然后开始寻找 
		q.pop();
		if(top.x==ex&&top.y==ey) //当横纵坐标都相等的时候就意味着结束了 
		{
			printf("%d",top.step);
			exit(0);//因为这里不能return 0 ，exit(0)效果一样 
		}
		if(vis[top.x][top.y])continue;//如果这个点走过了，那就跳过所有的，直接开始下一场 
		vis[top.x][top.y]=1;
		for(register int i=0; i<=10; i++) //枚举每个方向的每个点，看看能不能走 
		{		
			int nx=top.x,ny=top.y+mo[i];//y+1说明向下，x不变 
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)//不能越界 否则可能RE 
			if(sum[nx][ny]-sum[nx-1][ny]-sum[top.x][top.y-1]+sum[top.x-1][top.y-1]==0)
			//如果说前缀和中当前的位置没有 X的话，就是没有 数，因为下面已经吧障碍物赋值为 1 ，所以说
			//如果前缀是 0 ，就说明了当前路线是可行的，就是没有障碍的 
			q.push((node) {nx,ny,top.step+1});//放进去 
		}
		for(register int i=0; i<=10; i++) //同上 
		{ 
			int nx=top.x,ny=top.y-mo[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)
			if(sum[top.x][top.y]-sum[top.x-1][top.y]-sum[nx][ny-1]+sum[nx-1][ny-1]==0)
			q.push((node) {nx,ny,top.step+1});
		}
		for(register int i=0; i<=10; i++) 
		{ 
			int nx=top.x+mo[i],ny=top.y;
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)
			if(sum[nx][ny]-sum[nx][ny-1]-sum[top.x-1][top.y]+sum[top.x-1][top.y-1]==0)		
			q.push((node) {nx,ny,top.step+1});
		}
		for(register int i=0; i<=10; i++ ) 
		{  
			int nx=top.x-mo[i],ny=top.y;
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)
			if(sum[top.x][top.y]-sum[top.x][top.y-1]-sum[nx-1][ny]+sum[nx-1][ny-1]==0)
			q.push((node) {nx,ny,top.step+1});
		}
	}
}
signed main() 
{
	scanf("%lld%lld",&n,&m);
	for(register int i=1; i<=n; i++)
	for(register int j=1; j<=m; j++)     
	{
		char now;
		cin>>now;
		if(now=='$'||now=='.')ma[i][j]=0;   //题目中没说. 到底是什么，默认是障碍物了 
		if(now=='#')ex=i,ey=j;   
		if(now=='X')ma[i][j]=1;  //这里别的就是看条件赋值 
		if(i==1&&j==1)ma[i][j]=0; //这里要特判一下，不然#9错误，这个点也是一个坑点 
		sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+ma[i][j]; 	//求前缀和是为了算有没有障碍物 
	}
	bfs(1,1,0);
	printf("-1");//找不到的话直接输出 
	return 0;
}
```


---

## 作者：CuSO4_and_5H2O (赞：1)

这个题不难，应该算一个黄题（虽然做了很长时间吧）。

首先如果不考虑时间因素的话这个就是一个裸的BFS肥肠简单的模板题，但如果便利每一个走的二次方的路径上合不合法那时间可太长了，稍加思索肯定不行，那怎么办呢？

可以用前缀和来完成判断路径上的点是否合法。只要把 `X` 在地图上标记成 $1$ 其他的标记成 $0$ 然后求出行的前缀和和列的前缀和就可以了，操作的时候看一看这一个区间内有没有 $1$ 也就是有没有障碍物，如果前缀和计算出为 $0$ 就代表可以走，反之就不能走。这样就完成了判断和不合法的操作，其他的按照BFS模板做即可。

对了，这个题目有可能往上或往左走，在计算前缀和的时候要特殊判断，不然会出错，判断方法是如果是往上或往左就把两个相减数换换位置就行（就因为这个看了一个小时没看出来自己哪里错了）。

上代码！

```
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int d[11]={1,2,4,8,16,32,64,128,256,512,1024};
int n,m,vis[1002][1002],Map[1002][1002],jx,jy;
int hang[1002][1002],lie[1002][1002],bj;
char ch;

queue<int> x,y;
int fx[4]={0,0,1,-1},
	fy[4]={1,-1,0,0};

signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>ch;
			if(ch=='X') hang[i][j]=lie[i][j]=1;
			if(ch=='#') jx=i,jy=j;
			Map[i][j]=ch;
		}
	}
	hang[1][1]=lie[1][1]=0;//特判一下 
	for(int i=1;i<=n;i++)//分别计算行列前缀和 
	{
		for(int j=1;j<=m;j++)
		{
			hang[i][j]+=hang[i][j-1];
			lie[i][j]+=lie[i-1][j];
		}
	}
	x.push(1),y.push(1);
	vis[1][1]=1;
	while(!x.empty())
	{
		int dx=x.front(),dy=y.front();
		x.pop();y.pop();
		for(int i=0;i<=3;i++)//方向 
		{
			for(int j=0;;j++)//走的数值 
			{
				int nx=dx+fx[i]*d[j],//用乘的方式可以完成操作 
					ny=dy+fy[i]*d[j];
				if(nx<1 || ny<1 || nx>n || ny>m) break ;
				if(i==0)
					bj=hang[dx][ny]-hang[dx][dy-1];
				if(i==1)
					bj=hang[dx][dy]-hang[dx][ny-1];
				if(i==2)
					bj=lie[nx][dy]-lie[dx-1][dy];
				if(i==3)
					bj=lie[dx][dy]-lie[nx-1][dy];
				if(bj!=0) break ;
				if(vis[nx][ny]!=0) continue ;
				vis[nx][ny]=vis[dx][dy]+1;
				x.push(nx),y.push(ny);
			}
		}
	}
	cout<<vis[jx][jy]-1;//因为第一步我设的初始值是1所以要-1 
}
```


---

## 作者：wfycsw (赞：1)


- 首先，让我们来分析一下这道题。

- ### 算法：广搜。

- ### 数据结构：队列 。

- ### 优化：前缀和。

先预处理前缀和，再枚举$logn$条路径。

时间复杂度：$O(n*logn)$

加上亿些卡常，可以轻松地拿下最优解。

### 160ms(目前是最优解)
现在开始——上代码！

```cpp
#include<bits/stdc++.h>
#define RI register int
using namespace std;
#define ru(x,y) d[++w]=(wu){x,y,s}//方便入队
inline int read(){//快读
    RI s=0;char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) s=(s<<1)+(s<<3)+c-48,c=getchar();
    return s;
}
inline void write(int x){//快输
    if(x>9) write(x/10);
    putchar(x%10+48);
}
struct wu{
	int x,y,t;
}d[5000002];//结构体队列
char c[1001];
bool b[1001][1001];
int h[1001][1001],l[1001][1001];//h[][]存横向区间障碍物数。,l[][]存列向区间障碍物数。
int mx[4]={1,0,-1,0},my[4]={0,1,0,-1};
int main(){
	RI n=read(),m=read(),x,y,xi,yi,s,zx,zy;
	register bool q;
	for(RI i=1;i<=n;i=-~i){
		scanf("%s",&c);
		for(RI j=0;j<m;j=-~j){
			if(c[j]=='$') q=0;
			else if(c[j]=='#')
				zx=i,zy=-~j,q=0;
			else q=1;
			h[i][-~j]=q+h[i][j];//计算前缀和
			l[i][-~j]=q+l[i-1][-~j];
		}
	}
	d[1]=(wu){1,1,0};b[1][1]=1;
	for(RI t=1,w=1;t<=w;t=-~t){
		x=d[t].x;y=d[t].y;s=-~d[t].t;
		if(x==zx&&y==zy){
			write(s-1);
			return 0;
		}
		for(RI p=1;p<x&&l[x-1][y]-l[x-p-1][y]==0/*判断中间是否有障碍物*/;p<<=1){//向上走
			if(b[x-p][y]) continue;
			b[x-p][y]=1;ru(x-p,y);
		}
		for(RI p=1;p+x<=n&&l[x+p][y]-l[x][y]==0;p<<=1){//向下走
			if(b[x+p][y]) continue;
			b[x+p][y]=1;ru(x+p,y);
		}
		for(RI p=1;p<y&&h[x][y-1]-h[x][y-p-1]==0;p<<=1){//向左走
			if(b[x][y-p]) continue;
			b[x][y-p]=1;ru(x,y-p);
		}
		for(RI p=1;p+y<=m&&h[x][y+p]-h[x][y]==0;p<<=1){//向右走
			if(b[x][y+p]) continue;
			b[x][y+p]=1;ru(x,y+p);
		}
	}
	printf("-1");//虽然无-1的数据，但还是遵从题意
	return 0;
}
```
第三次发题解，望管理员通过。

---

## 作者：hylong (赞：1)

一道宽搜题，[BFS](https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fromtitle=BFS&fromid=542084&fr=aladdin)+[前缀和](https://blog.csdn.net/weixin_41668995/article/details/80501338)就可以过。
#### 艰难的得分历程：
   1. 开始没有注意到要判断中间有没有障碍（~~也就只有我这种不好好审题的才看不出来~~）可是得了40分......
   2. 之后开始反复调试，因为没有测试数据，所以在0~40之间徘徊......
   3. 最后恍然大悟，我把保存前缀和的数组弄反了......
#### 代码实现：
最开始40分的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int x;
    int y;
    int step;
};
int n,m,sx,sy;
int mv[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
bool v[1001][1001];
void bfs()
{
    queue<node>que;
    int i,j;
    v[1][1]=false;
    node a,b,c;
    a.x=1;
    a.y=1;
    a.step=0;
    que.push(a);
    while(!que.empty())
    {
     b=que.front();
     que.pop();
     if(b.x==sx && b.y==sy)
     {
      cout<<b.step<<endl;
      return ;
     }
     for(i=0;i<4;i++)
     {
      j=1;
      while(1)
      {
       c.x=b.x+mv[i][0]*j;
       c.y=b.y+mv[i][1]*j;
       c.step=b.step+1;
       if(c.x<=0 || c.x>n || c.y<=0 || c.y>m)
        break;
       if(v[c.x][c.y])
       {
        v[c.x][c.y]=false;
        que.push(c);
       } 
       j*=2;
      }
     }
    }
}
int main()
{
    int i,j;
    char a;
    cin>>n>>m;
    for(i=1;i<=n;i++)
     for(j=1;j<=m;j++)
     {
      cin>>a;
      if(a=='$')
       v[i][j]=true;
      else
       if(a=='#')
       {
        v[i][j]=true;
        sx=i;
        sy=j;
       }
       else
        v[i][j]=false;
     }
    bfs();
    return 0;
}
```
由于中间调试的小错误太多，故只发100分代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int x;
    int y;
    int step;
};//结构体，用于队列
int n,m,sx,sy;
int mv[21]={1,2,4,8,16,32,64,128,256,512,-1,-2,-4,-8,-16,-32,-64,-128,-256,-512};//为了偷懒，事先手算可用数据
int v[1001][1001];
int q,w[1001][1001],e[1001][1001];
void bfs()
{
    queue<node>que;
    int i,j;
    v[1][1]=0;//标记
    node a,b,c;
    a.x=1;
    a.y=1;
    a.step=0;
    que.push(a);
    while(!que.empty())
    {
     b=que.front();
     que.pop();
     if(b.x==sx && b.y==sy)
     {
      cout<<b.step<<endl;
      return ;
     }//如果达到就输出，并退出BFS
     for(i=0;i<=20;i++)
     {
      c.x=b.x+mv[i];
      c.y=b.y;
      c.step=b.step+1;
      if(c.x>=1 && c.y>=1 && c.x<=n && c.y<=m && v[c.x][c.y]==1 && e[c.x][c.y]-e[b.x][b.y]==0)
      {
       v[c.x][c.y]=0;
       que.push(c);
      }
     }//上下走
     for(i=0;i<=20;i++)
     {
      c.x=b.x;
      c.y=b.y+mv[i];
      c.step=b.step+1;
      if(c.x>=1 && c.y>=1 && c.x<=n && c.y<=m && v[c.x][c.y]==1 && w[c.x][c.y]-w[b.x][b.y]==0)
      {
       v[c.x][c.y]=0;
       que.push(c);
      }
     }//左右走
    }
}
int main()
{
    int i,j;
    char a;
    cin>>n>>m;
    for(i=1;i<=n;i++)
     for(j=1;j<=m;j++)
     {
      cin>>a;
      v[i][j]=0;
      q=1;
      if(a=='$' || a=='#')
      {
       if(a=='#')
       {
        sx=i;
        sy=j;
       }
       v[i][j]=1;
       q=0;
      }
      w[i][j]=q+w[i][j-1];
      e[i][j]=q+e[i-1][j];
     }//预处理
    bfs();
    return 0;
}
```
原谅我语言表达能力不好（~~毕竟我是个120的语文试卷只有86的蒟蒻~~）

---

## 作者：I_will_AKIOI (赞：0)

一道 BFS 水题。
 
首先我们需要一个新数组用于存储移动的步数，直接赋值即可。我们按照常规的 BFS 的方法，利用队列进行搜索即可，搜索时要向四个方向搜索。注意起点可能有障碍，需要清除。

注意这里移动时要小心：不能只判断移动终点是否是障碍物，而是**整个过程都不能有障碍物**。所以需要用一重循环来判断中途的障碍物。这么做的复杂度是 $O(n^3)$，或许是数据太弱加上你谷的光速评测机，最慢的点仅用时 $692$ ms。

[link](https://www.luogu.com.cn/record/114066447)

为了优化~~抢最优解~~，我们就需要使用二维前缀和，同时要记录终点，整个地图就需要转化成一个 ```bool``` 数组。

根据公式 $sum_{i,j}=sum_{i-1,j}+sum_{i,j-1}+sum_{i-1,j-1}+a_{i,j}$ 预处理出一个前缀和数组。就可以用 $O(1)$ 算法计算出一个矩阵中的数字的和了。经过优化，复杂度变成了 $O(nm)$，即使乘上 $36$ 倍常数也能跑的飞快。

当然我们可以再进行优化。先算出 $x=\log_2 \max(n,m)$，也就是说最多能走 $2^x$ 步，否则就越界了。但不知某种原因，优化后还更慢了？

[link](https://www.luogu.com.cn/record/114062995)

我还是放上最快代码吧：
```cpp
#include<iostream>
#include<queue>
using namespace std;
struct data {int x,y,s;}w;
int n,m,maxx,nx,ny,x,y,s,xx,yy;
int sum[1001][1001],f[10]={1,2,4,8,16,32,64,128,256,512};
bool a[1001][1001],vis[1001][1001];
queue<data>q;
bool check(int x1,int y1,int x2,int y2)
{
  if(x1>x2) swap(x1,x2);//交换变量，使得x1<x2,y1<y2，否则会满江红
  if(y1>y2) swap(y1,y2);
  return sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];//返回这个矩阵的和
}
int bfs()
{
  w.x=w.y=1;
  q.push(w);
  while(!q.empty())
  {
    w=q.front();
    x=w.x,y=w.y,s=w.s;
    q.pop();
    for(int k=1;k<=4;k++)
    {
      for(int i=0;i<=9;i++)
      {
        nx=x,ny=y;
        if(k==1) nx+=f[i];//k表示4个方向
        if(k==2) nx-=f[i];
        if(k==3) ny+=f[i];
        if(k==4) ny-=f[i];
        if(nx<1||nx>n||ny<1||ny>m||check(x,y,nx,ny)||a[nx][ny]||vis[nx][ny]) continue;
        w.x=nx,w.y=ny,w.s=s+1;
        vis[nx][ny]=1;
        if(nx==xx&&ny==yy) return w.s;
        q.push(w);
      }
    }
  }
  return -1;
}
int main()
{
  char c;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
  {
    for(int j=1;j<=m;j++)
    {
      cin>>c;
      if(c=='X'&&(i>1||j>1)) a[i][j]=1;//起点不能有障碍，手动清除
      if(c=='#') xx=i,yy=j;
      sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];//预处理
    }
  }
  vis[1][1]=1;
  cout<<bfs();
  return 0;
}
```

---


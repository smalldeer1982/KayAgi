# 天作之合

## 题目背景

生活就是一次A\*，你是我的第一个目标状态。——小明


## 题目描述

在小明的学校中，一共有若干个女生。小明认为每个女生的特征可以抽象为一个6位的数字串其中不重复地包含1~6这6个数码。

在小明心中，有一个理想的女生，她的特征数字串为A。如果串Y是串X交换两个连续的数码所得，那么我们认为特征数字串X和Y相似。首先，小明找到了他的同桌，她的特征数字串为S。每次，小明会寻找一个特征数字串和当前串相似的女生，直到寻找到适合他的（即特征数字串和A相同或相似的）。定义每个女生的合适程度为找到此人至少需要找女生的数量（包括他的同桌和此人自己）。显然，合适程度数值越小的女生越适合小明。

然而，小明觉得老天不会轻易地让他找到，所以他认为合适程度第二小的才是他最合适的伴侣（也就是小红）。那么，请你帮他写一个程序，求出对于小明，小红的合适程度是多少。


## 说明/提示

对于全部数据，保证串A和S合法，且保证能找到。

数据比较弱。


## 样例 #1

### 输入

```
123654
123456```

### 输出

```
3```

# 题解

## 作者：Zhou_yu (赞：7)

## 题目描述：
### [P2133 题目传送门](https://www.luogu.com.cn/problem/P2133)

这里应该是本题截止到这篇文章发布前唯一的**逆序对正解**。

## 题意简化
给你一个字符串 $A$ 每次操作可以交换 $A$ 串里相邻的两个数字，看多少次操作能把他变成 $S$ 串，输出第二小的操作次数。(转载自[这里](https://www.luogu.com/discuss/533559))
## 题目思路
1. 可以发现，直接求 $A$ 与 $S$ 的逆序对个数，也就是需要交换的数字的对数，就能求出**最优解**，但我们要的是**次优解**，于是进行分析：

2. 思考能得到：次优解只会在**最优解与最优解加 $2$ 中**产生，因为如果有多个最优解，则次优解就是最优解；如果只有一个最优解，则可以把任意两个相邻数交换再换回，就产生了次优解，也就是最优解加 $2$。

3. 观察两组数据：

data1：
```cpp
123456
234156
```
data2：
```cpp
123456
132465
```
在第一组数据中，其实可以看成只有 $1$ 一个数的位置在与其他数交换，所以最优解当然只有一个。

而在第二组数据中却有多个数的位置在与其他数交换。（可以看成 $2$ 和 $5$ 在移动）所以问题转化成了处理关于 $2$ 的位置变化的子问题和关于 $5$ 的位置变化的子问题这样的**多个子问题**，最优解便有多个。

4. 总结一下，当这个数据**只**能看成多个子问题时，最优解就会有多个。（因为 data1 也能看成 $2$，$3$，$4$ 三个数在移动）或者说，当一个数据能看成一个子问题时，次优解才不等于最优解。

所以，**只**当碰到这样的序列时：
```cpp
1,2,3,...i+1,i+2,i+3,...i+k,i,i+k+1,i+k+2,...n-1,n
```
次优解才等于最优解加 $2$。

5. 考虑实现：将 `data[i]` 设为 $S$ 中第 $i$ 个位置的数本来应该在的位置，`m[a[i]]` 设为 $A$ 中第 $i$ 个位置的数本来应该在的位置，当 `data[i]-m[a[i]]` 等于逆序对的个数时（最优解），说明 $S$ 中第 $i$ 个位置的数向前或后连续交换最优解次就能得到 $A$ 序列。当存在这种数时，就是次优解不等于最优解的情况。

基本思路到这里就结束了，下面是实现部分。
## AC 代码
[AC 记录](https://www.luogu.com.cn/record/173404359)
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int data[10];
map<char,int> m; 
int main()
{
	cin>>a>>b;
	a=' '+a;//加上空格，个人习惯使用s[1]~s[6]
	b=' '+b;
	int ans=0,cnt=0;
	for(int i=1;i<=6;i++)m[a[i]]=i;//map标记每个数字正确的位置
	for(int i=1;i<=6;i++)data[i]=m[b[i]];//同上，data[i]为b[i]应该在的位置
	for(int i=1;i<=6;i++)
	for(int j=i+1;j<=6;j++)
	if(data[j]<data[i])ans++;//求逆序对个数
	if(ans<2)ans+=2;//特判，如果没交换或者只交换了一次，必定属于最优解加2的情况
	else
	{
		for(int i=1;i<=6;i++)
		if(abs(data[i]-m[a[i]])==ans)cnt++;//特殊情况出现
		if(cnt==1)ans+=2;//只有一个数在移动
	}
	cout<<ans;
	return 0;
}
```
## 总结
很好的思维题，这让我的代码旋转。

---

## 作者：fly_about (赞：7)

***本题十分简单***

在初步看题时感觉是 bfs ，但作为**蒟蒻**的我不会写 bfs 。

在进一步分析题时我发现数串每次都是相邻的两个数进行交换，而此时我灵机一动发现可以根据 A 串的字符转化为数字并根据 A 串
定义一个大小排序对 S 串进行排序。

并且当你找到与 A 串相同的串时上一个寻找到女生必定是与她相似，那么找到的第一个理想女生的一定是要找的那个合适度第二的。

题目中找到的女孩包含和他的同桌和她自己，那么寻找的女孩必定有三人。那么如果寻找的的人数小于等于二是是不符合题意的。为了找到下一个女生必须要再找两个人才能找到理想女生。

通过分析不难发现可以用类似冒泡排序的思想来解决问题。

但是我个人认为本题有些许问题，通过样例数据分析
不难发现无论怎样操作都需要找 4 个女生才符合条件，那么题目中合适值包括他的同桌极有可能是描述错误

如此一来就诞生的我的代码

```cpp
	#include<bits/stdc++.h>
        using namespace std;
        int a[7],b[7],c[11],ans;
        char s;
        int cui(int x)
        {
            if(x==0) return 1;
            if(b[x]==a[x]) return cui(x-1);
            else return 0;
        }
        int main()
        {
            for(int i=1;i<=6;i++)
            {
                cin>>s;
                a[i]=s-'0';//字符转数字,下同。
                c[a[i]]=i;//重新定义一个大小排序。
            }
            for(int i=1;i<=6;i++)
            {
                cin>>s;
                b[i]=s-'0';
            }
            while(cui(6)!=1)
            {
                for(int i=1;i<=6;i++) //类似冒泡进行寻找操作。
                    if(c[b[i]]>c[b[i+1]])
                    {
                        int n=b[i];
                        b[i]=b[i+1];
                        b[i+1]=n;
                        break;
                    }
                ans++;
            }
            if(ans<=2)
            {
                cout<<ans+2;
                return 0;
            }
            cout<<ans;
            return 0;
        }
```


---

## 作者：___w (赞：6)

### [P2133 天作之合](https://www.luogu.com.cn/problem/P2133)

#### 题意简述
给定两个字符串 $A,S$，选择两个相邻的字符进行交换，求将 $A$ 第二次变成 $S$ 所需的最少次数。

#### 题目分析
注意到字符串长度仅为 $6$，所以我们可以考虑搜索。题目所求的是最小次数，所以我们可以使用 bfs 求最值。

设计状态 $(s,step)$ 为当前字符串为 $s$，走了 $step$ 步。显然初始状态为 $(A,0)$，目标状态为 $(S,ans)$，我们注意题目求的是第二次变成 $S$，所以需做标记。

对于每个状态，我们可以枚举哪两个相同的数进行交换，并对其步数加 $1$。

要注意判重，不然会爆空间。当然你也可以像一样把 ```int``` 改为 ```short```，主要是~~懒~~。

下面给出代码。

#### 代码
```cpp
#include <bits/stdc++.h>
#define int short
using namespace std;
struct node {
	int a[6], step;
} st, ed;
string s;
bool flag;
bool check(node x, node y) {
	for (int i = 0; i < 6; ++i) if (x.a[i] != y.a[i]) return 0;
	return 1;
}
signed main(){
	cin >> s;
	for (int i = 0; s[i]; ++i) st.a[i] = s[i]-'0';
	cin >> s;
	for (int i = 0; s[i]; ++i) ed.a[i] = s[i]-'0';
	queue <node> q;
	q.push(st);
	while (!q.empty()) {
		node x = q.front(); q.pop();
		if (check(x, ed)) {
			if (!flag) flag = 1;
			else cout << x.step, exit(0);
		}
		++x.step;
		for (int i = 0; i < 5; ++i) {
			swap(x.a[i], x.a[i+1]);
			q.push(x);
			swap(x.a[i], x.a[i+1]);
		}
	}
	return 0;
}
```
[record](https://www.luogu.com.cn/record/114038991)。

---

## 作者：_zhouyixuan_ (赞：2)

题面略复杂，实际就是一个字符串通过交换相邻字母（虽然只有数字）得到另一个字符串，不过要求次短路。

但由于很明显每一操作都是等价的，所以很明显是无权，这让人想到 bfs ，而且一共只有 720 种情况（即全排列）。

接下来考虑求次短，如果多种最优解自然直接 bfs 求出即可，只有一种时发现只要将相邻数字交换两次即可。

于是 bfs ,先求出最优解（设最优解为 $step$ ），再继续判断出有无第二种最优解即可，有则输出 $step$（此时最优解和次优解等价），无则输出 $step+2$ 。

上代码（已AC）


```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int step;
	string s;
};
int ans=INT_MAX,f;
map<string,int>h;
queue<node>q;
int main()
{
	string a,b;
	cin>>a>>b;
	if(a==b)
	{
		cout<<2<<endl;
		return 0;
	}
	q.push(node{0,a});
	h[a]=1;
	while(!q.empty())
	{
		int step=q.front().step;
		string s=q.front().s;
		q.pop();
		string s2;
		if(step>=ans) break;
		for(int i=0;i<s.size()-1;i++)
		{
			s2=s;
			swap(s2[i],s2[i+1]);
			if(s2==b)
			{
				if(f==0)
				{
					ans=step+1;
					f=1;
				}
				else
				{
					cout<<ans<<endl;
					return 0;
				}
			}
			if(h[s2]==0)
			{
				h[s2]=1;
				q.push(node{step+1,s2}); 
			}
		}
	}
	cout<<ans+2<<endl;
    return 0;
}
```

---

## 作者：Binary_Lee (赞：2)

## [题面传送门](https://www.luogu.com.cn/problem/P2133)

### 解决思路

搜索标签启发我们可以用 $\text{BFS}$ 切掉这题。

用数组存储当前的状态，每次交换相邻的数得到新的状态，同时记录次数。当第二次找到目标状态时，就得到答案了。

考虑到可能多次得到相同答案但用的次数不同，不太好用标记剪枝（可能得不到答案），但由于本题数据较水，不优化也可以直接过。

虽然复杂度不是很优秀（被最优解倍杀），但很好理解。

其他细节在程序中指出。

### AC Code

```cpp
#include<bits/stdc++.h>
#define IOS ios::sync_with_stdio(false)
#define TIE cin.tie(0),cout.tie(0) 
#define int long long
using namespace std;
struct node{
	int a[7],ans;
}k;
queue<node> q;
string s;
int to,tot;
int get(int a[]){     //求原数
	int tmp=100000,sum=0;
	for(int i=1;i<=6;i++) sum+=a[i]*tmp,tmp/=10;
	return sum;
}
signed main(){
	IOS;TIE;
	cin>>to>>s;
	for(int i=6;i>=1;i--) k.a[i]=s[i-1]-'0';
	k.ans=0;
	q.push(k);
	while(q.size()){
		node tmp=q.front();q.pop();
		tmp.ans++;   //次数+1
		for(int i=1;i<=5;i++){
			node kk=tmp;    //注意不能直接改动tmp，要暂存下来
			swap(kk.a[i],kk.a[i+1]);
			if(get(kk.a)==to){ 
				tot++;
				if(tot==2){    //第二次找到答案
					cout<<kk.ans;
					return 0;
				}
			}
			q.push(kk);
		}
	}
	return 0;
}
```

---

## 作者：Little09 (赞：2)

广度优先搜索（水的一波~）

每次交换数组里连续两个数

找到第一个合法答案时不要停，继续

找到第二个时输出就好了

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[7];
bool flag;//flag表示是否找到了第一个合法答案
struct point
{
	int a[7],step;
};
queue <point> q;
bool check(int a[],int b[])
{
	for (int i=1;i<=6;i++)
	{
		if (a[i]!=b[i]) return 0;
	}
	return 1;
}
bool used[7][7][7][7][7][7];//used数组判重
int main()
{
	point s;
    for (int i=1;i<=6;i++)//方便读入，使用了字符
    {
    	char x;
    	cin >> x;
    	s.a[i]=x-'0';
	}
    for (int i=1;i<=6;i++)
    {
    	char x;
    	cin >> x;
    	f[i]=x-'0';
	}
    s.step=0;
    q.push(s);
    while (!q.empty())
    {
    	point u=q.front();
    	q.pop();
    	for (int i=1;i<=5;i++)
    	{
    		point v=u;
    		v.step++,swap(v.a[i],v.a[i+1]);
    		if (used[v.a[1]][v.a[2]][v.a[3]][v.a[4]][v.a[5]][v.a[6]])
    		{
    			continue;//判重
			}
			if (check(v.a,f)) 
			{
				if (flag==0)//如果是第一个答案，就继续搜
				{
					flag=1;
				}
				else
				{
					cout << v.step;//第二个答案，输出
					return 0;
				}
			}
			q.push(v);
		}
	}
    return 0;
}
```
写的不好，见谅，勿喷。希望我的题解能对您起帮助

---

## 作者：ZnHF (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P2133)

## 题意简述
给定两个字符串 $A$，$B$，每次操作可以在 $A$ 中选择两个相邻的字符进行交换，求将 $A$ 变成 $B$ 所需的第二少操作次数。
## 题目分析
这道题可以使用 BFS 解决对于每一次操作，枚举被交换的两个数的位置然后进行交换，当第一次找到答案时，标记已经找到答案一次，当第二次找到答案时，输出操作次数。

需要注意的是，本题不能标记每种状态是否被访问，因为每一种状态都有可能被多次访问，但这样的访问有可能是有意义的。


## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string x;
struct node{
	short a[6],ans;
}s,e,temp,t;
bool flag;
queue<node> q;
bool ok(short x[],short y[]){
	for(short i=0;i<=5;i++){
		if(x[i]!=y[i]) return 0;
	}
	return 1;
}//判断当前状态是否与目标状态一致
int main(){
	cin>>x;
	for(short i=0;i<x.size();i++){
		s.a[i]=x[i]-'0';
	}
	cin>>x;
	for(short i=0;i<x.size();i++){
		e.a[i]=x[i]-'0';
	}//以上将输入的字符串转换为数组
	q.push(s);
	while(!q.empty()){
		temp=q.front();
		q.pop();
		for(short i=0;i<=5;i++){
			t=temp;
			swap(t.a[i],t.a[i+1]);
			t.ans++;
			if(ok(t.a,e.a)){
				if(!flag) flag=1;//第一次找到答案，标记
				else{
					cout<<t.ans;//第二次找到答案，输出答案
					return 0;
				}
			}
			q.push(t);
		}
	}
	return 0;
}
```
非常抱歉，作者贴错代码了！

---

## 作者：Luxe877 (赞：0)

原题链接：[P2133 天作之合](https://www.luogu.com.cn/problem/P2133)。

## 题意
看上去题意很麻烦，其实简化之后就比较简单了。对于初始字串 $A$，每次交换只能交换相邻的两位，求要多少次交换才能得到 $S$，输出**第二小**的步数方案。其中 $A$ 与 $S$ 长度均为 $6$，且只由 $1$ 至 $6$ 的六个数字组成，没有重复的数字。

## 解题
对于这个问题，我们不难想到用广搜或者迭代加深做，因为求的是次小答案，可以转换为去掉最小答案后再求剩下答案之中的最小答案。这里我用的广搜来做这题，迭代加深做法可以看看其它题解的。

既然想到广搜，那就很好办了。直接以字串 $A$ 为起点，字串 $S$ 为终点求次小交换次数就可以了，接下来只用枚举交换的两位了。

代码写出来一交：

![](https://cdn.luogu.com.cn/upload/image_hosting/s1jk9wjh.png)

~~**欸作者你怎么回事怎么没过就发题解**~~

别急，通过第一个测试点的反馈很好想出是无输出导致错误。但是我们的广搜代码是没问题的啊，怎么回事呢？

这时候就要想想有没有特殊情况了。果然，还真有。当 $A=S=123456$，即两个字串相同时，程序会不输出。这是因为广搜的时候为了避免搜到起点，就在一开始将起始字串打上了标记，之后无论如何也搜不到目标字串了。

那么这种情况答案是什么呢？首先，初始情况就相同了，所以最小交换次数为 $0$。那么第二小呢？只要随便找两位换一次之后换回来就可以了，也就是 $2$ 次。所以，加上特判 $A$ 和 $S$ 相等时，输出答案 $2$，就可以过啦。

![](https://cdn.luogu.com.cn/upload/image_hosting/8chx5pdm.png)

代码就先贴在下面了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[12],s[12]; 
map<int,int> vis;
struct nd{
	int num[12],t;
}b;
int ed;
queue<nd> q;
int getn(nd x)
{
	int n=0;
	for(int i=1;i<=6;i++)
	{
		n=n*10+x.num[i];
	}
	return n;
}
void bfs()
{
	int cnt=0;
	while(q.size())
	{
		nd p=q.front();
		q.pop();
		if(getn(p)==ed)
		{
			if(cnt==0)
			{
				cnt++;
				continue;
			}
			cout<<p.t;
			return ;
		}
		for(int i=1;i<=5;i++)
		{
			swap(p.num[i],p.num[i+1]);
			if(vis.find(getn(p))==vis.end())
			{
				p.t++;
				q.push(p);
				if(getn(p)!=ed)
				{
					vis[getn(p)]++;
				}
		
				p.t--;
			}
			swap(p.num[i],p.num[i+1]);
		}
	}
}
int main()
{
	for(int i=1;i<=6;i++)
	{
		scanf("%1d",&a[i]);
		b.num[i]=a[i];
	}
	for(int i=1;i<=6;i++)
	{
		scanf("%1d",&s[i]);
		ed=10*ed+s[i];
	}
	b.t=0;
	q.push(b);
	vis.clear();
	vis[getn(b)]++;
	if(getn(b)==ed)
	{
		cout<<"2";
		return 0;
	}
	bfs();
	return 0;
}

```

---

## 作者：Melo_DDD (赞：0)

远古题目果真是又锅了。

# 题目大意

帮忙更正一个点：

题目里 ```即特征数字串和A相同或相似的``` 其实只能相同不能相似，不然会获得 $0$ 分的高分。

具体情况详见[这里](https://www.luogu.com/discuss/533559)。

# 题目实现

尝试用队列（搜索）实现（或许裹挟了一些模拟？），我们从小明的串开始，每一步都交换一对相邻的数字并让新串入队，直到和小红相同。

代码中还有些细节解释一下：

- 为什么第一次求得答案时不停要等到第二次？——因为第一次求的是最合适的，而题目要求求第二合适的。

- 为什么答案要以结构体的形式存储？——因为这样可以保证之后入队时答案能够传递下去及时更新，具体原因见代码，请读者再自行沉淀。

记得字符转数字。

## 代码

```cpp
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
string a ,b ;
struct girlfriend {
	short int num[7] ,res ;
} boy ,girl ;
inline bool true_love (girlfriend she ,girlfriend her) {
	f (i ,0 ,5 ,1) {
		if (she.num[i] != her.num[i]) return false ;
	}
	return true ;
}
queue <girlfriend> q ;
bool cnt ;
int main () {
	getline (cin ,a) ;
	getline (cin ,b) ;
	f (i ,0 ,5 ,1) {
		boy.num[i] = a[i] ^ 48 ;
	}
	f (i ,0 ,5 ,1) {
		girl.num[i] = b[i] ^ 48 ;
	} 
	q.push (boy) ;
	while (! q.empty ()) {
		girlfriend cur = q.front () ;
		q.pop () ;
		if (true_love (cur ,girl)) {
			if (! cnt) {
				cnt = true ;
			}
			else {
				cout << cur.res << '\n' ;
				goto her ;
			}
		}
		cur.res ++ ;
		f (i ,0 ,4 ,1) {
			swap (cur.num[i] ,cur.num[i + 1]) ;
			q.push (cur) ;
			swap (cur.num[i] ,cur.num[i + 1]) ;
		} 
	}
	her : return 0 ;
}
```

---

## 作者：keepwatcher_kensap (赞：0)

## Part 1 题意

给定两个长度为 $6$ 字符串 $s,a$，每次可以交换相邻的两个字符，求 $s$ 要变为 $a$ 的次短步数为多少。

## Part 2 思路

本题要求的是次短步数，所以可以使用**广度优先搜索算法**。现将 $s$ 放入队列之中，每次取出队首字符串并枚举可能情况。同时记录当前情况是否曾到达过，如果曾则不接着考虑。在发现 $s$ 到 $a$ 的最短方式之后不停下，而是等到下一次 $s$ 到 $a$ 的方式出现，也就是次短方式出现再停止。

值得注意的是，由于我们要让结果出现两次到达 $a$ 的情况，所以特别的，如果变到 $a$ 则不记录曾到达的情况。

## Part 3 代码

```
#include <bits/stdc++.h>
using namespace std;
string str,ans;
map<string,bool> vis;
queue<string> que;
queue<int> dis;
bool stop=false;
int main()
{
	cin>>str>>ans;
	que.push(str),dis.push(0);
	while (!que.empty())
	{
		string s=que.front();
		int d=dis.front();
		que.pop(),dis.pop();
		// cout<<s<<" "<<d<<endl;
		if (s==ans && stop) { cout<<d;return 0; }
		if (s==ans && !stop) stop=true;
		if (vis[s]) continue;
		if (s!=ans) vis[s]=true;
		for (int i=0;i<=4;i++)
		{
			string now=s;
			swap(now[i],now[i+1]);
			que.push(now),dis.push(d+1);
		}
	}
	return 0;
}
```

---

## 作者：Loser_Syx (赞：0)

观察数据范围 $n = 6$，于是可以知道肯定又是某些牛逼的乱搞做法了。  
其实暴力广搜就能过，对于每个状态枚举交换的点，然后 `map` 记录每个状态到了几次，其中一个有效的剪枝是当次数 $\geq 2$ 时不进行扩展。  
然后做完了，复杂度大概就是所以能组成长度为六且各位不同的数字了，常数大概十倍。

```cpp
map<string, int> mp;
signed main() {
	string a, b;
	cin >> a >> b;
	queue<pair<string, int> > q;
	q.push({a, 0});
	while (!q.empty()) {
		auto x = q.front();
		q.pop();
		if (++mp[x.first] == 2) {
			if (x.first == b) return write(x.second, '\n'), 0;
		}
		if (mp[x.first] >= 2) continue;
		string s = x.first;
		for (int i = 1; i < 6; ++i) {
			swap(s[i-1], s[i]);
			if (mp[s] < 2) {
				q.push({s, x.second+1});
			} 
			swap(s[i-1], s[i]);
		}
	}
	return 0;
}
```

---


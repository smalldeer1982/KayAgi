# 小Z的传感器

## 题目描述

众所周知，小 Z 家是个豪宅，有 $n$ 个房间，并通过 $m$ 条通道相连（家当然是连通的）。

有一天，小 Y 想趁小 Z 不在偷偷光顾他家，并决定到他家的每个房间至少逛一次。不幸的是，小 X 家有 $k$ 个房间装了传感器，该传感器会在第一次有人到访的时候返回信息。

当小 Z 回到家时，就发现小 Y 来过了，小 Y 也如实地告诉了小 Z 自己到每个房间至少逛了一次。

然而，小 Z 仔细研究了传感器返回信息的先后顺序，怀疑个别传感器可能返回信息有延迟。

为了验证自己的推断，连同这一次在内，他一共让小 Y 到他家来了 $q$ 次。他想判断每次传感器返回信息的先后顺序是否可能出现，希望你帮帮他。


## 说明/提示

【数据规模】

对于 $10\%$ 的数据，$n \le 2$；

对于 $30\%$ 的数据，$n \le 3$；

对于 $60\%$ 的数据，$n \le 10000，m \le 20000，k \le 10$；

对于 $100\%$ 的数据，$1 \le k \le n \le 10^5,1 \le m \le 2 \times 10^5,1 \le q \le 5,x \neq y$。


## 样例 #1

### 输入

```
5 5 3 2
1 2
2 3
3 1
1 4
4 5
4 2 1
4 1 2```

### 输出

```
No
Yes```

# 题解

## 作者：Froranzen (赞：14)


----------



### 思路

看前后两次顺序是否正确，其实就是判断**能否通过未打上标记的节点相互到达** 。本质上就是判断两个节点是否在同一个连通块里。我们想到使用并查集来维护。            


------------

我们可以先将所有有返回信息的节点打上标记， 然后按照顺序遍历依次取消标记，同时判断前后两个节点是否可以通过未打上标记的节点相互到达，如果结果为 false， 则输出 "No"。如果遍历完所有的节点依然合法，就输出 "Yes"。 



------------

### 上代码~

------------

```cpp
#include <cstdio>
#include <cstring> 
using namespace std;

int n, m, k, q;

inline char nc () {static char buf[1 << 21], *p1 = buf, *p2 = buf; return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;}

inline int read () { 
    register int x(0),f(1); char ch = nc (); 
    while (ch > '9' || ch < '0') {if (ch == '-') f = ~f +1; ch = nc ();} 
    while (ch <= '9' && ch >= '0') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = nc ();} 
    return x * f;
}

int fath[200003];

int find (int now) {
	if (!(fath[now] ^ now)) return now;
	return fath[now] = find (fath[now]);
}  

int seq[200003];
bool vis[200003];

int head[200003], ent;

struct edge {
	int from, to, next;
}e[400003];

inline void add (int u, int v) {
	e[++ent] = (edge){u, v, head[u]};
	head[u] = ent;
}  

int main () {
	n = read (), m = read (), k = read (), q = read ();
	for (register int i(1); i <= m; ++i) {
		int u = read (), v = read ();
		add (u, v), add (v, u);
	}

	for (register int h(1); h <= q; ++h) {
		memset (vis, true, sizeof(vis)); //清空标记
		for (register int i(1); i <= k; ++i) seq[i] = read (), vis[seq[i]] = false;
		vis[seq[1]] = true;  //第一个有返回值的房间无论是什么，都一定是合理的
		for (register int i(1); i <= n; ++i) fath[i] = i;  //初始化
		for (register int i(1); i <= n; ++i) { 
			if (vis[i]) {
				for (register int j(head[i]); j; j = e[j].next) { //将未打上标记的点合并
					int v = e[j].to;
					if (vis[v]) {
						if (fath[i] ^ fath[v]) {
							fath[find(v)] = find (i);
						}
					}
				}
			}
		}
		bool flag = 1;
		for (register int i(2); i <= k; ++i) { //从第二个点开始顺序取消标记
			vis[seq[i]] = true;
			for (register int j(head[seq[i]]); j; j = e[j].next) {
				int v = e[j].to;
				if (vis[v]) {
					fath[find(seq[i])] = find(v);
				}
			}
			if (fath[find(seq[i])] ^ fath[find(seq[i-1])]) {
				puts("No");
				flag = 0;
				break;
			}
		}
		if (flag) puts("Yes");
	}	
}
```


------------


---

## 作者：CuSO4_and_5H2O (赞：6)

本题考查并查集的应用

## 思路

看下边题解写的都不是很清楚（~~有可能是我的问题~~），所以我就来写~~水~~一篇题解啦！

首先想什么时候是不合法的，那就是不能不经过当前点后边的点来到达当前点，也就是说要从上一个点到达当前点一定要经过后边的传感器的点，那么这是就是不合法的（太绕了，自己理解一下，还是很好理解的！），所以我们可以把所有有传感器的房间都设置成不能走的状态（因为不能走），然后在这个基础上把能联通的点归并到一个并查集里。

然后根据给出的传感器的顺序依次解封不能走的房间，就是把之前不能走的点设置成可以走，然后把这个点周围的所有的点合并到一个连通块里。之后判断当前点的连通块里有没有前边那个点，如果没有的话就说明无法从前一个点到达这里，因为他俩不连通。如果把所有不能走的点都解封之后没有出现上边的情况就说明这种情况是合法的。

这个题目只要转换成连通块的题目还是很简单的，考试的话没想到这个写法可以用搜索暴力写出来，能拿部分分。

## 代码
思路实在不会就看代码呗，注释还是挺多的，比着思路理解代码。


```
#include<bits/stdc++.h>
using namespace std;

int n,m,k,q,a,b,vis[300010],dis[300010];
int fa[3000010];
vector<int> vec[100860];//vector建边，不喜欢用表链式前向星

int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}

signed main(){
	cin>>n>>m>>k>>q;
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b;
		vec[a].push_back(b);//双向建边 
		vec[b].push_back(a);
	}
	for(int w=1;w<=q;w++)
	{
		for(int i=1;i<=n;i++) fa[i]=i;//初始化并查集节点 
		memset(vis,0,sizeof(vis));
		for(int j=1;j<=k;j++) cin>>dis[j],vis[dis[j]]=1;//vis用来标记这个点能不能走 
		for(int i=1;i<=n;++i)//在解封不能走的点之前预处理并查集 
		{
			if(vis[i]==1) continue ;//如果当前点不能走就跳过 
			for(int j=0;j<vec[i].size();j++)//搜索所有能走的边 
			{
				if(vis[vec[i][j]]==1) continue ;//如果不能走就跳过 
				fa[find(i)]=fa[find(vec[i][j])];//合并并查集 
			}
		}
		for(int i=1;i<=k;i++)//依次解封各个点 
		{
			vis[dis[i]]=0;
			for(int j=0;j<vec[dis[i]].size();j++)
			{
				if(vis[vec[dis[i]][j]]==1) continue ;
				fa[find(dis[i])]=fa[find(vec[dis[i]][j])];//合并并查集 
			}
			if(find(dis[i])!=find(dis[i-1]) && i!=1)//如果不和前一个点在一个连通块里 
			{
				cout<<"No"<<endl;//输出 
				break;
			}
			if(i==k) cout<<"Yes"<<endl;//如果扫到最后还行的话就说明这种情况是合法的 
		}
	}
}
```


---

## 作者：Dispwnl (赞：4)

//By Me And Fresh Oyster 

这题是并查集。。。

为什么标签是搜索。。。（然而能得70分）

先将每个点标记成可访问，即use[i]=0

将每个传感器检测到的点标记成不可访问

然后把每个可访问的点向外扩展

遇到可访问的点就将它们合并

这步是处理每个能作为出发点的点

则这个集合中的点都是可作为出发点

然后按顺序枚举每一个不可访问的点

把它们变成可访问的

然后向外扩展

如果与上个点不处于一个集合

就退出输出"No"

因为这说明从上个点不可能不经过没有感应器的点到达这个点

如果每个检测点都处于一个集合

就输出"Yes"

c++
```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
#define is isdigit(ch)
#define ge getchar()
#define inv inline void
#define ini inline int
using namespace std;
struct p{
    int x,y;
}c[400001];
int n,m,k,q,num;
int h[100001],vis[100001],f[100001];
int ff;
bool use[100001];
ini read()
{
    int x=0;
    char ch=ge;
    while(!is)
    ch=ge;
    while(is)
    {
        x=x*10+ch-48;
        ch=ge;
    }
    return x;
}
inv add(int x,int y)
{
    c[++num].x=h[x];
    c[num].y=y;
    h[x]=num;
}
ini find(int x)
{
    if(f[x]!=x)
    f[x]=find(f[x]);
    return f[x];
}
inv look(int x)
{
    for(int i=h[x];i;i=c[i].x)
      if(!use[c[i].y])
      f[find(x)]=find(c[i].y);
}
int main()
{
    n=read(),m=read(),k=read(),q=read();
    for(int i=1;i<=m;i++)
      {
          int x=read(),y=read();
          add(x,y);
          add(y,x);
      }
    for(int i=1;i<=q;i++)
      {
          ff=0;
          memset(use,0,sizeof(use));
          for(int j=1;j<=k;j++)
            vis[j]=read(),use[vis[j]]=1;
          for(int j=1;j<=n;j++)
            f[j]=j;
          use[vis[1]]=0;
          for(int j=1;j<=n;j++)
            if(!use[j]) look(j);
          for(int j=2;j<=k;j++)
            {
                use[vis[j]]=0;
                look(vis[j]);
                if(find(vis[j-1])!=find(vis[j]))
                {
                    ff=1;
                    printf("No\n");
                    break;
            }
          }
          if(!ff) printf("Yes\n");
      }
    return 0;
}
```

---

## 作者：Polaris_Dane (赞：4)

个人觉得是一道非常好的题目

充分考察了一些思想

首先我们要考虑什么时候会出现矛盾

我们用样例来考察一下

![](https://cdn.luogu.com.cn/upload/image_hosting/mxz2a1w4.png)

为什么第一个样例不可以呢

因为他从$4$号点出发直接跳过了$1$而去了$2$

（这里总是让我想起支配树，然而不会）

是不可以的，那我们怎么维护这种关系呢

如果一个点$i$在序列中排在另外一个点$j$后面

设$j$前一个点为$k$

那么在没有$i$的情况下，$j$与$k$联通

我们想到可以用并查集维护这种关系

每一次加入一个点时，将其与相邻的点合并（当前可经过的）

然后依次判断是否联通即可

那么剩下就很好想了

$Talk$ $Is$ $Cheap,$ $Show$ $You$ $The$ $Code$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cctype>
#include<set>
#define LL long long
#define M 800010
#define N 50010
using namespace std;
const int inf=0x7f7f7f7f;
const int mod=1e9+7;
const double eps=1e-6;
inline int read(){
	int f=1,x=0;char s=getchar();
	while(!isdigit(s)){if (s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=(x<<1)+(x<<3)+(s^48);s=getchar();}
	return x*f;
}
int n,m,k,q;
int fa[M];
inline int find(int a){
	return a==fa[a]?fa[a]:fa[a]=find(fa[a]);	
}
struct edge{
	int to,nxt;
}e[M];
int head[M],cnt,a[M],used[M];
inline void add_edge(int u,int v){
	e[++cnt].nxt=head[u],head[u]=cnt,e[cnt].to=v;
}
signed main(void){
	n=read(),m=read(),k=read(),q=read();
	for (int i=1;i<=m;i++){
		int u=read(),v=read();
		add_edge(u,v),add_edge(v,u);	
	}
	for (int i=1;i<=q;i++){
		memset(used,0,sizeof(used));
		for (int j=1;j<=n;j++) fa[j]=j;
		for (int j=1;j<=k;j++)
			a[j]=read(),used[a[j]]=1;
		for (int j=1;j<=n;j++)
			if (!used[j])
				for (int t=head[j];t;t=e[t].nxt){
					if (used[e[t].to]) continue;
					int X=find(j),Y=find(e[t].to);
					if (X==Y) continue;
					fa[X]=Y;
				}
		for (int j=1;j<=k;j++){
			for (int t=head[a[j]];t;t=e[t].nxt){
				if (used[e[t].to]) continue;
				int X=find(a[j]),Y=find(e[t].to);
				if (X==Y) continue;
				fa[X]=Y;
			}
			used[a[j]]=0;
			if (find(a[j])!=find(a[j-1])&&j!=1) goto ouuan;
		}
		printf("Yes\n");
		continue;
		ouuan:
		printf("No\n");
	}
	return 0;
}

```


---

## 作者：rfsfreffr (赞：1)

从中午做了好久，以为标签里有搜索，就尝试广搜。

我是这么想的:

设k个传感器放在$t_{i(1<=i<=k)}$ 上。则从$t_1$
开始广搜，然后呢，在从$t_1$开始搜索的时候，所有与$t_{i(2<=i<=k)}$ 有关的边，都无法通过。此处可以设置一个"等级",$t_i$的等级是$i$,对于队列中的每个元素，我使用了两个指标(位置，和“等级”),如果此时元素等级是$x$，能够走到$t_{x+1}$,就讲他的等级++,再压人队列中。

结果就开始各种爆炸，最后在遇到要输出"No"的情形时，直接死循环（我太菜了，广搜都写不好，据说正常的搜索最多70分）。于是我就放弃了广搜，开始思考其他的做法

然后我就联想到并查集。

并查集可以探测两个点是否联通，所以可以仿照广搜思路，那些与后面传感器位置所相关的边都先不加入到图中，然后再一步一步的“并”上去。

于是就有了一下代码。

# 1.定义部分

我不会写链式前向星，此处用动态数组存边。

dis来存一个点上是的传感器是否被走过或者本来就没有传感器。

t来存储各个传感器的位置

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,q;
struct oi {
	int num,x;
};
int u,v;
vector<int>b[1000001];
int f[1000001];
int dis[1000001];
int t[1000001];
```
# 2.并查集的合并操作
模板，大家都会。

```cpp
int find(int tt) {
	if(f[tt]==tt) return f[tt];
	f[tt]=find(f[tt]);
	return f[tt];
}
```
# 3.输入与核心代码

```cpp
int main() {
	cin>>n>>m>>k>>q;//读入数据
	for(int i=1; i<=m; i++) {
		scanf("%d%d",&u,&v);
		b[u].push_back(v);//建边
		b[v].push_back(u);
	}
	for(int i=1; i<=q; i++) {
		memset(dis,0,sizeof(dis));//初始化，先将传感器位置的数据清空
		for(int j=1; j<=n; j++) f[j]=j;//并查集的初始化
        
 
		for(int j=1; j<=k; j++) {//读入传感器位置
			scanf("%d",&t[j]);
			dis[t[j]]=1;//标记传感器位置
		}
        
        
		for(int j=1; j<=n; j++) {//先将那些与传感器无关的房间的边用并查集连起来
			if(dis[j]==0) {
				for(int l=0; l<b[j].size(); l++) {
					if(dis[b[j][l]]==1) continue;
					int x=find(j),y=find(b[j][l]);
					if(x!=y) f[x]=y;
				}
			}
		}
        
        
		int ffff=0;
		for(int j=1; j<=k; j++) {//核心代码
			for(int l=0; l<b[t[j]].size(); l++) {//将关于第j个 传感器的边连起来
				if(dis[b[t[j]][l]]==1) continue;
				int x=find(b[t[j]][l]),y=find(t[j]);
				if(x!=y) f[x]=y;
			}
			dis[t[j]]=0;//标记此点已经走
			int x=find(t[j-1]),y=find(t[j]);
			if(x!=y&&j!=1) {//如果此时tj与t(j-1)不联通，就可以直接输出No了
				cout<<"No"<<endl;
				ffff=1;
				break;
			}
		}
		if(ffff==0) cout<<"Yes"<<endl;//否则输出Yes
	}
	return 0;
}
```

---

## 作者：司马智泽 (赞：1)

其实搜索是能A掉的~~（好像还是rank1）~~

考虑每一个摄像头（记为list[ i ]）和下一个摄像头list[ i+1 ]，如果从list[ i ]能不经过list[ i+1 ]以后的摄像头(list[ i+2 ~ k ])而到达list[ i+1 ],那么从list[ i ]到list[ i+1 ]就是合法的。

至于为什么可以经过list[ i ]以前的摄像头(list[ 1 ~ i-1 ])，是因为我们需要假设list[ i ]以前(list[ 1~i-1 ])的走法已经合法，再考虑list[ i ]~~（跟数学归纳法类似）~~。

这样我们用数组reach记录这点是不是可到达的。

但我们在搜索的过程中很有可能遇到list[ i+2 ~ k ],那么我们就先记录下它们（即reach=true），但不插入队列。也就是说对于一个list[ j ],我们要等到reach[ list[1 ~ j-1] ]都为true时，再往队列里插入它们。

最后看摄像头是不是全都插入过队列就行了。

具体看代码吧。

```
//lgp2189
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=100000+9;
const int maxm=400000+9;

int n,m,k,q;
struct data{
	int to,next;
}edge[maxm];
int cnt,head[maxn];
void addedge(int a,int b){
	edge[cnt].to=b;
	edge[cnt].next=head[a];
	head[a]=cnt++;
}

int list[maxn],tar,isk[maxn];
bool reach[maxn];
queue<int> Q;

bool bfs(){
	Q.push(list[tar=1]);
	reach[list[1]]=true;
	while(!Q.empty()){
		int now=Q.front();Q.pop();
		for(int i=head[now];i!=-1;i=edge[i].next){
			int to=edge[i].to;
			if(reach[to]) continue;
			reach[to]=true;
			if(isk[to]){
				if(isk[to]==tar+1){
					while(tar<k&&reach[list[tar+1]]) Q.push(list[++tar]);
				}
			}
			else Q.push(to);
		}
	}
	return tar>=k;
}

int main(){
	memset(head,-1,sizeof(head));
	scanf("%d %d %d %d",&n,&m,&k,&q);
	for(int i=1;i<=m;i++){
		int a,b;scanf("%d %d",&a,&b);
		addedge(a,b),addedge(b,a);
	}
	for(int i=1;i<=q;i++){
		memset(reach,false,sizeof(reach));
		memset(isk,0,sizeof(isk));
		for(int j=1;j<=k;j++) scanf("%d",&list[j]),isk[list[j]]=j;
		bfs()?printf("Yes\n"):printf("No\n");
	}
}
```

---

## 作者：血色黄昏 (赞：0)

思路比较简单，每一次加入一个点时，将其与相邻的点合并

然后依次判断是否联通即可

用~~冰茶机~~并查集维护

吐槽一下：看了半天没看出是搜索啊...


新鲜出炉的此题第一篇Py题解

## 代码如下（请勿抄袭）：

```python
a, parents, visit = [0 for i in range(1000000)], [i for i in range(1000000)], [0 for i in range(1000000)]#parents是祖先，visit是能不能连
Next = [[] for i in range(1000000)]#开个大点的二维list
def find(x):#并查集基本操作--查找祖先
    if x == parents[x]:#如果是自己就return
        return x
    return parents[x] == find(parents[x])#路径压缩

def union(a, b):#并查集基本操作--合并
    a = find(a)#找到祖先
    b = find(b)#找到祖先
    parents[b] = a#合并两个并查集

def add(x):#找与x联通&&可以连边的点
    for i in range(len(Next[x])):
        if visit[Next[x][i]] == 0:#如果可以
            union(x, Next[x][i])#给我连上

s = input().split()#读一行
n, m, k, T = int(s[0]), int(s[1]), int(s[2]), int(s[3])#输入nmkT
for i in range(m):输入m次
    s = input().split()#读一行
    x, y = int(s[0]), int(s[1])#输入xy
    Next[x].append(y)#加进去
    Next[y].append(x)#加进去
for i in range(T):#循环T次
    for j in range(1, n + 1):
        parents[j] = j#重新初始化一下并查集
    s = input().split()#读一行
    for j in range(1, k + 1):#循环k次
        a[j] = int(s[j - 1])#赋值
        visit[a[j]] = 1#标记能不能连
    for j in range(1, n + 1):#循环n次
        if visit[j] == 0:#如果能访问
            add(j)#连上
    visit[a[1]] = 0#标记为可访问
    add(a[1])#连上
    for j in range(2, k + 1):
        visit[a[j]] = 0#标记为可访问
        add(a[j])#连上
        if find(a[j]) != find(a[j - 1]):#如果不通输出No
            print("No")
            continue#重新循环
        if i == k:#如果联通
            print("Yes")#输出Yes
```

祝大家爆~切~省~选

---

## 作者：xixisuper (赞：0)

# P2189 小Z的传感器 题解

给我找到了一道图的好题。

本题解采用并查集算法。

## 思路

这边建议给这题加上 `并查集` 的标签。

我们可以把这道题的问题转换一下：

- 给定一张 $n$ 个节点，$m$ 条边的无向图。 
- 给定一个长为 $k$ 的序列，第 $i$ 个元素记为 $a_i$，表示这张图上的 $k$ 个节点编号。
- 对于任意的 $a_i$ 来说，**如果能从 $a_i$ 到达 $a_{i+1}$ 且不经过任何 $j>i+1$ 的点 $a_j$，输出 `Yes`，否则输出 `No`。**

注意到这是一个连通性问题，所以我们考虑用[并查集](https://baike.baidu.com/item/%E5%B9%B6%E6%9F%A5%E9%9B%86/9388442?fr=ge_ala)解决。

在最开始时，只把不在序列 $a_k$ 中的点和 $a_1$ 并在一起，然后从 $2$ 到 $k$ 枚举 $i$。每枚举一个 $i$，我们就令 $a_i$ 与其直接相邻的节点并在一起，然后判断 $a_i$ 与 $a_{i-1}$ 号节点是否处于同一集合即可。

利用路径压缩并查集，时间复杂度约为 $O(q(n+m)\alpha(n))$，其中 $\alpha(n)$ 为反阿克曼函数。

## 代码

```cpp
#include <iostream>
#define ll int
using namespace std;
const ll N=4e5+10;
struct node{ll u,v,nxt;}edge[N];
ll head[N],tot;
void add_edge(ll from,ll to){
	edge[++tot].v=to;edge[tot].u=from;
	edge[tot].nxt=head[from];head[from]=tot;
}
ll n,m,k,q,fa[N],lin[N];
bool vis[N];
void init(){for(ll i=0;i<=n;i++) fa[i]=i,vis[i]=0;}
ll findf(ll x){
	if(fa[x]==x) return x;
	return fa[x]=findf(fa[x]);
}
void _merge(ll a,ll b){
	ll af=findf(a),bf=findf(b);
	if(af!=bf) fa[bf]=af;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k>>q;
	for(ll i=1;i<=m;i++){
		ll x,y;
		cin>>x>>y;
		add_edge(x,y),add_edge(y,x);
	}
	while(q--){
		init();
		for(ll i=1;i<=k;i++){
			cin>>lin[i];
			if(i!=1) vis[lin[i]]=1;
		}
		for(ll i=1;i<=n;i++){
			if(vis[i]) continue;
			for(ll j=head[i];j;j=edge[j].nxt){
				ll v=edge[j].v;
				if(vis[v]) continue;
				_merge(i,v);
			}
		}
		bool flag=1;
		for(ll i=2;i<=k;i++){
			vis[lin[i]]=0;
			for(ll j=head[lin[i]];j;j=edge[j].nxt){
				ll v=edge[j].v;
				if(vis[v]) continue;
				_merge(lin[i],v);
			}
			if(findf(lin[i-1])!=findf(lin[i])){flag=0;break;}
		}
		if(flag) cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：wu13115899522 (赞：0)

典型错误：
直接从序列中的点往外搜，看能否搜到序列中的下一个点。


原因：注意题目中的传感器只会在第一次到达时返回信息
所以可能会在一个点到达多次，照着这种打法会出问题，这种打法相当于是一条链，所以只有 $60$ 分。

满分思路如下：

如果这几个点是可以连通的，那么他们一定可以到达同一个连通块，这就是切入点，而除了这 ` k` 个点之外的点也可以先处理成若干个连通块，然后依次把 kk 个点加入，再判断是否相邻两个点是否连通。

连通如何实现：

可以使用图论，但是会超时，所以就需要想到一个神奇的算法：并查集。

理由在于如果两个点是连通的，那么他们的祖先必定相同。可以借此来判断。

代码献上：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,Q;
int tot,fir[4000005],nxt[4000005],son[400005];
int num[1000005];bool can[1000005];
int fa[1000005];
inline int getfa(int x){
    return fa[x]==x?x:fa[x]=getfa(fa[x]);
}
void un(int x,int y){//合并 
    int fax=getfa(x);
    int fay=getfa(y);
    if(fax!=fay)fa[fay]=fax; 
}
void check(){
    can[num[1]]=false;
    for(int i=1;i<=n;i++){//初始化 
        if(!can[i]){                
            for(int j=fir[i];j;j=nxt[j]){
                if(!can[son[j]])un(i,son[j]);
            }
        }
    }
    for(int i=2;i<=k;i++){//加入点判连通 
        can[num[i]]=false;
        for(int j=fir[num[i]];j;j=nxt[j]){
            if(!can[son[j]])un(num[i],son[j]);
        }
        if(getfa(num[i])!=getfa(num[i-1])){
            printf("No\n");
            return;
        }
    }
    printf("Yes\n");
}
inline void add(int x,int y){
    son[++tot]=y;nxt[tot]=fir[x];fir[x]=tot;
}
inline void read(int &x){
    x=0;char c=getchar();
    while(!(c<='9'&&c>='0'))c=getchar();
    while(c<='9'&&c>='0'){x=(x<<1)+(x<<3)+(c^48);c=getchar();};
}
int main(){
    read(n),read(m),read(k),read(Q);
    for(int x,y,i=1;i<=m;i++){
        read(x);read(y);
        add(x,y),add(y,x);
    }
    while(Q--){
        memset(can,0,sizeof(can));
        for(int i=1;i<=n;i++)fa[i]=i;//别忘了 
        for(int i=1;i<=k;i++){
            read(num[i]);can[num[i]]=true;
        }
        check();
    }
    return 0;
}
```


---


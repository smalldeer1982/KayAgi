# 四子连棋

## 题目描述

在一个 $4\times 4$ 的棋盘上摆放了 $14$ 颗棋子，其中有 $7$ 颗白色棋子，$7$ 颗黑色棋子，有两个空白地带，任何一颗黑白棋子都可以向上下左右四个方向移动到相邻的空格，这叫行棋一步，黑白双方交替走棋，任意一方可以先走，如果某个时刻使得任意一种颜色的棋子形成四个一线（包括斜线），这样的状态为目标棋局。

![](https://cdn.luogu.com.cn/upload/image_hosting/dagckxxz.png)

## 样例 #1

### 输入

```
BWBO
WBWB
BWBW
WBWO```

### 输出

```
5```

# 题解

## 作者：Xiao_Mi (赞：29)

# **这题可以用迭代加深搜索来做**


------------

####  用ans枚举多少步可以达到棋局，然后再dfs，若超过ans就返回，一直到可移动到目标棋局为止。
这样就不会超时了。。。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
using namespace std;
int a[11][11],ans;
int fkx[5]={0,-1,1,0,0},
	fky[5]={0,0,0,-1,1};
int check(){//查看是否到目标棋局
	for(int i=1;i<=4;i++){
        if(a[i][1]==a[i][2]&&a[i][2]==a[i][3]&&a[i][3]==a[i][4]) return 1;
        if(a[1][i]==a[2][i]&&a[2][i]==a[3][i]&&a[3][i]==a[4][i]) return 1;
    }
    if(a[1][1]==a[2][2]&&a[2][2]==a[3][3]&&a[3][3]==a[4][4]) return 1;
    if(a[1][4]==a[2][3]&&a[2][3]==a[3][2]&&a[3][2]==a[4][1]) return 1;
    return 0;
}
int dfs(int x,int y,int xx,int yy,int color,int teg){//color：上一组的颜色，teg：第几层
	if(ans==teg){
		if(check()) return 1;
		else return 0;
	}
	for(int i=1;i<=4;i++){
		int dx=fkx[i]+x;
		int dy=fky[i]+y;
		int ddx=fkx[i]+xx;
		int ddy=fky[i]+yy;
		if(dx>0&&dx<=4&&dy>0&&dy<=4&&a[dx][dy]!=color){
			swap(a[x][y],a[dx][dy]);
			if(dfs(dx,dy,xx,yy,(color==1?2:1),teg+1)) return 1;;
			swap(a[dx][dy],a[x][y]);
		}
		if(ddx>0&&ddx<=4&&ddy>0&&ddy<=4&&a[ddx][ddy]!=color){
			swap(a[xx][yy],a[ddx][ddy]);
			if(dfs(x,y,ddx,ddy,(color==1?2:1),teg+1)) return 1;
			swap(a[ddx][ddy],a[xx][yy]);
		}
	}
	return 0; 
}
int main(){
	int i,j,fx1=0,fy1=0,fx2=0,fy2=0;
	char c;
	for(i=1;i<=4;i++){
		for(j=1;j<=4;j++){
			cin>>c;
			if(c=='B') a[i][j]=1;
			if(c=='W') a[i][j]=2;
			if(c=='O') a[i][j]=0;
			if(a[i][j]==0&&!fx1) fx1=i,fy1=j;
            else if(a[i][j]==0) fx2=i,fy2=j;
		}
	}
    //枚举多少步可到达棋局
	for(ans=1;ans<=0x3f3f3f;ans++){
   	 //先黑再白，注意顺序
		if(dfs(fx1,fy1,fx2,fy2,1,0)) break;
		if(dfs(fx1,fy1,fx2,fy2,2,0)) break;
	}
	cout<<ans;
	return 0; 
}
```

---

## 作者：啊嘞嘞嘞嘞 (赞：15)

大佬的题解都好暴力……各种我没见过的搜索方法

题目就是很普通的爆搜啦，状态表示也没什么难度。因为题目要求搜索深度最小，所以直接使用传统的bfs就行

这类移动棋子的题都有一个共性：将棋子移动到空格，本质是直接移动空格。

我的状态记录了棋盘的颜色（3种，黑白分别为0和1方便用异或进行状态转移），空格的位置（使搜索不盲目），操作次数，上一个移动的棋子颜色（因为黑白都可先手）。本想用状压表示棋盘，但想到还有空格，就放弃了。

搜索没啥难度，状态封装进struct，然后进一步搜索时用赋值复制出新状态，再修改一下，push进队列进行。

（我自己挺讨厌在棋盘很小的时候不利用数组下标0）

```cpp
#include <cstdio>
#include <queue>
using namespace std;
const int dx[]={0,1,0,-1},dy[]={-1,0,1,0};
struct state {
	int a[4][4];
	int x[2],y[2]; //空格位置
	int last; //上一个是谁下
	int t; //步数
	bool check() {
		for (register int i=0;i<4;i++) {
			if (a[i][0]==a[i][1] && a[i][1]==a[i][2] && a[i][2]==a[i][3]) return true;
			if (a[0][i]==a[1][i] && a[1][i]==a[2][i] && a[2][i]==a[3][i]) return true;
		}
		if (a[0][0]==a[1][1] && a[1][1]==a[2][2] && a[2][2]==a[3][3]) return true;
		if (a[3][0]==a[2][1] && a[2][1]==a[1][2] && a[1][2]==a[0][3]) return true;
		return false;
	}
} ini;
inline void swap(int &a,int &b) {
	a^=b,b^=a,a^=b;
}
int bfs() {
	queue<state> q;
	state i1=ini,i2=ini;
	i1.last=0, i2.last=1;
	q.push(i1);
	q.push(i2);
	while (!q.empty()) {
		state cur=q.front();
		q.pop();
		for (int p=0;p<2;p++) { //哪个空格
			int i=cur.x[p],j=cur.y[p];
			for (int k=0;k<4;k++) {
				int ii=i+dx[k],jj=j+dy[k];
				if (ii>=0 && ii<4 && jj>=0 && jj<4 && cur.a[ii][jj]!=2 && cur.a[ii][jj]!=cur.last) {
					state nxt=cur;
					swap(nxt.a[i][j],nxt.a[ii][jj]); //交换颜色
					nxt.x[p]=ii, nxt.y[p]=jj; //移动空格
					nxt.last^=1;
					nxt.t=cur.t+1;
					if (nxt.check()) return nxt.t;
					q.push(nxt);
				}
			}
		}
	}
	return -1;
}
int main() {
	int flg=false;
	for (int i=0;i<4;i++) {
		char buf[10];
		scanf("%s",buf);
		for (int j=0;j<4;j++) {
			char x=buf[j];
			ini.a[i][j]=x=='O' ? 2 : x=='W' ? 0 : 1;
			if (x=='O') {
				if (!flg) ini.x[0]=i,ini.y[0]=j;
				else ini.x[1]=i,ini.y[1]=j;
			}
		}
	}
	int ans=bfs();
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：丛林 (赞：9)

```cpp
//因为数据范围比较小，这道题可以用广搜
//注意先处理出黑子先手和白子先手的情况
//开结构体存图和步数，再记录一下当前状态移动的棋子颜色
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
#define maxn 10010
#define inf 1000000007
#define ll long long 
using namespace std;
int n,m,ans=inf;
int dx[5]={0,0,1,-1,0};
int dy[5]={0,1,0,0,-1}; 
struct nn
{
    int a[5][5];
    int color;//这一步交换的棋子颜色 
    int step;//记录步数 
}t;
queue<nn>q;
bool check(nn f)//判断合法解 
{
    for(int i=1;i<=4;i++)
    {
        if(f.a[i][1]==f.a[i][2]&&f.a[i][1]==f.a[i][3]&&f.a[i][1]==f.a[i][4])return true;//处理行 
        if(f.a[1][i]==f.a[2][i]&&f.a[1][i]==f.a[3][i]&&f.a[1][i]==f.a[4][i])return true;//处理列 
    }
    if(f.a[1][1]==f.a[2][2]&&f.a[1][1]==f.a[3][3]&&f.a[1][1]==f.a[4][4])return true;//处理对角线 
    if(f.a[1][4]==f.a[3][2]&&f.a[1][4]==f.a[2][3]&&f.a[1][4]==f.a[4][1])return true;
    return false;
}
void init()//处理一开始的棋子颜色
{
    t.step=0;
    t.color=2;
    for(int i=1;i<=4;i++)
    for(int j=1;j<=4;j++)
    {
        if(t.a[i][j]==2)
        {
            for(int k=1;k<=4;k++)
            {
                int x=i+dx[k];
                int y=j+dy[k];
                if(t.a[x][y]==2)continue; 
                if(x>=1&&x<=4&&y>=1&&y<=4)//注意边界 
                {
                    nn c=t;
                    c.color=t.a[x][y];
                    c.step=1;
                    swap(c.a[i][j],c.a[x][y]);//移动棋子 
                    q.push(c);
                }
            }
        }
    }
}
void bfs()//广搜模板 
{
    while(!q.empty())
    {
        nn b=q.front();
        q.pop();
        if(check(b))
        {
            ans=b.step;
            return ;
        }
        for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
        {
            if(b.a[i][j]==2)
            {
                for(int k=1;k<=4;k++)
                {
                    int x=i+dx[k];
                    int y=j+dy[k];
                    if(x>=1&&x<=4&&y>=1&&y<=4&&b.a[x][y]==(b.color^1))//黑白交替移动 
                    {
                        nn c=b;
                        swap(c.a[i][j],c.a[x][y]);//移动棋子 
                        c.color=b.color^1;//如果上一步走的是黑，这一步就是白，上一步是白，这一步是黑。 
                        c.step=b.step+1;//步数加一 
                        q.push(c);//将当前状态入队 
                    }
                }
            }
        }
    }
}
int main()
{
    int x,y,z;
    char s[10];
    for(int i=1;i<=4;i++)
    {
        scanf("%s",s+1);
        for(int j=1;j<=4;j++)//处理图，便于广搜 
        {
            if(s[j]=='B')
            {
                t.a[i][j]=1;
            }
            if(s[j]=='W')
            {
                t.a[i][j]=0;
            }
            if(s[j]=='O')
            {
                t.a[i][j]=2;
            }
        }
    }
    init();
    bfs();
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Huami360 (赞：6)

唉楼下要么就不状压，要么就3进制状压，要么就别的乱七八糟的状压，难道你们就因为有3个状态就放弃使用位运算2进制状压了吗？

其实这题可以直接二进制状压做，1表示黑棋，0表示白棋，另外记录下2个空点的位置就行了。
具体看代码（冗长）：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;++i)
#define dop(i,m,n) for(int i=m;i>=n;--i)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
#define re register
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
#define pause system("pause");
using namespace std;
inline int read(){
    int s = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0',ch = getchar();
    return s * w;
}
char a[6][6];
struct Node{
    int x[2], y[2], s, time, who; //x,y数组记录2个空点的位置，s表示当前的状态（二进制），who表示到谁走了
}start, begin, now, tmp;
int getHash(){  //棋盘转二进制状态
    int ans = 0;
    rep(i, 1, 4) rep(j, 1, 4) if(a[i][j] == 'B') ans |= (1 << ( ((i - 1) << 2) + j - 1) );
    return ans;
}
queue <Node> q;
bool Win(Node x){ //判赢函数
    int s = x.s;
    //判断有没有黑点四子连棋
    if( s&1&&s&(1<<4)&&s&(1<<8)&&s&(1<<12) || s&(1<<1)&&s&(1<<5)&&s&(1<<9)&&s&(1<<13) 
    || s&(1<<2)&&s&(1<<6)&&s&(1<<10)&&s&(1<<14) || s&(1<<3)&&s&(1<<7)&&s&(1<<11)&&s&(1<<15)
    || s&1&&s&(1<<1)&&s&(1<<2)&&s&(1<<3) || s&(1<<4)&&s&(1<<5)&&s&(1<<6)&&s&(1<<7)
    || s&(1<<8)&&s&(1<<9)&&s&(1<<10)&&s&(1<<11) || s&(1<<12)&&s&(1<<13)&&s&(1<<14)&&s&(1<<15)
    || s&1&&s&(1<<5)&&s&(1<<10)&&s&(1<<15) || s&(1<<3)&&s&(1<<6)&&s&(1<<9)&&s&(1<<12))
      return true;
    //把空点的位置赋值为1
    s|=1<<(((x.x[0]-1)<<2)+x.y[0]-1); s|=1<<(((x.x[1]-1)<<2)+x.y[1]-1);
    //rep(i, 1, 4){ rep(j, 1, 4) printf("%d ", (s>>(((i-1)<<2)+j-1))&1); printf("\n"); }
    //判断白点有没有四子连棋
    if( (s^1)&1&&(s^(1<<4))&(1<<4)&&(s^(1<<8))&(1<<8)&&(s^(1<<12))&(1<<12) || (s^(1<<1))&(1<<1)&&(s^(1<<5))&(1<<5)&&(s^(1<<9))&(1<<9)&&(s^(1<<13))&(1<<13) 
    || (s^(1<<2))&(1<<2)&&(s^(1<<6))&(1<<6)&&(s^(1<<10))&(1<<10)&&(s^(1<<14))&(1<<14) || (s^(1<<3))&(1<<3)&&(s^(1<<7))&(1<<7)&&(s^(1<<11))&(1<<11)&&(s^(1<<15))&(1<<15)
    || (s^1)&&(s^(1<<1))&(1<<1)&&(s^(1<<2))&(1<<2)&&(s^(1<<3))&(1<<3) || (s^(1<<4))&(1<<4)&&(s^(1<<5))&(1<<5)&&(s^(1<<6))&(1<<6)&&(s^(1<<7))&(1<<7)
    || (s^(1<<8))&(1<<8)&&(s^(1<<9))&(1<<9)&&(s^(1<<10))&(1<<10)&&(s^(1<<11))&(1<<11) || (s^(1<<12))&(1<<12)&&(s^(1<<13))&(1<<13)&&(s^(1<<14))&(1<<14)&&(s^(1<<15))&(1<<15)
    || (s^1)&(1)&&(s^(1<<5))&(1<<5)&&(s^(1<<10))&(1<<10)&&(s^(1<<15))&(1<<15) || (s^(1<<3))&(1<<3)&&(s^(1<<6))&(1<<6)&&(s^(1<<9))&(1<<9)&&(s^(1<<12))&(1<<12))
      return true;
    return false;
}
int l[] = { 233, -1, 1, 0, 0 }, r[] = { 666, 0, 0, -1, 1 }, id, X, Y, kong, v[20000010];
int getHash(Node x){   //不要hack我
    return x.s + x.x[0] * 10007 + x.x[1] * 107 + x.y[1] * 677 + x.y[0] * 97;
}
int main(){
    rep(i, 1, 4)
       rep(j, 1, 4){
          cin>>a[i][j];
          if(a[i][j] == 'O') //记录空点位置
            if(!start.x[0]) start.x[0] = i, start.y[0] = j;
            else start.x[1] = i, start.y[1] = j;
       }
    start.s = getHash();
    start.time = 0;
    begin = start;
    start.who = 0;
    begin.who = 1;
    q.push(start);
    q.push(begin);
    v[getHash(begin)] = v[getHash(start)] = 1;
    while(!q.empty()){  //bfs
      Node now = q.front();
      q.pop();
      rep(i, 0, 1){
         rep(j, 1, 4){
            X = now.x[i] + l[j]; Y = now.y[i] + r[j];
            if(X <= 0 || X > 4 || Y <= 0 || Y > 4 || X == now.x[i^1] && Y == now.y[i^1]) continue; //不能出界，也不能走到另外一个空点
            id = ((X - 1) << 2) + Y - 1;
            kong = ((now.x[i] - 1) << 2) + now.y[i] - 1;
            if(((now.s >> id) & 1) == now.who){ //如果是到这个棋走
              tmp = now;
              tmp.s &= ~(1 << id);      //交换
              tmp.s |= tmp.who << kong; //位置
              tmp.x[i] = X;
              tmp.y[i] = Y;
              if(v[getHash(tmp)]) continue;
              v[getHash(tmp)] = 1;
              tmp.time++;
              tmp.who^=1;
              if(Win(tmp)){ 
                printf("%d\n", tmp.time); 
                return 0; 
              }
              q.push(tmp);
            }
         }
      }
    }
    return 0;
}

```

---

## 作者：Fairicle (赞：4)

#### 这题我使用了迭代加深来做。

为什么会想到迭代加深呢？因为这道题要我们求最少步数，那我们就可以将步数作为深度，一层层搜下去。

迭代加深的题都差不多，比如说

[P1032](https://www.luogu.com.cn/problemnew/show/P1032)

[P2324](https://www.luogu.com.cn/problemnew/show/P2324)

可以发现这些题目都有“最少”之类的字眼。

你可能会问：如果当前深度搜索失败了，下次会再搜一遍刚搜过的状态不是在浪费吗？

事实上，确实浪费了，但是搜索的状态量是指数级增长的，对于深度 $d$，也许它的状态量比前面的加起来都多。

那么这道题使用步数作为深度，代码就很好写了（要注意是黑白轮流下，所以要判断，并且要搜索是白先开始还是黑先开始的情况）

code：
```cpp
include"bits/stdc++.h"
using namespace std;
int a[10][10],d,xx1,yy1,xx2,yy2;
int fx[4]={0,0,1,-1},fy[4]={1,-1,0,0};
inline bool check(){
	for(register int i=1;i<=4;++i)
	if(a[i][1]==a[i][2]&&a[i][2]==a[i][3]&&a[i][3]==a[i][4]) return true;
    
	for(register int j=1;j<=4;++j)
	if(a[1][j]==a[2][j]&&a[2][j]==a[3][j]&&a[3][j]==a[4][j]) return true;
    
	if(a[1][1]==a[2][2]&&a[2][2]==a[3][3]&&a[3][3]==a[4][4]) return true;
    
	if(a[4][1]==a[3][2]&&a[3][2]==a[2][3]&&a[2][3]==a[1][4]) return true;
    
	return false;
}
bool dfs(int ax，int ay，int bx，int by，int col，int dep){
	if(dep>d)
	{
		if(check()) return true;
		return false;
	}
	for(register int i=0;i<4;++i)
	{
		int nx = ax + fx[i];
		int ny = ay + fy[i];
		if(nx>0&&nx<=4&&ny>0&&ny<=4&&a[nx][ny]==col)
		{
			swap(a[ax][ay],a[nx][ny]);
			if(dfs(nx,ny,bx,by,(col==1)?2:1,dep+1)) return true;
			swap(a[ax][ay],a[nx][ny]);
		}
	}
	for(register int i=0;i<4;++i)
	{
		int nx = bx + fx[i];
		int ny = by + fy[i];
		if(nx>0&&nx<=4&&ny>0&&ny<=4&&a[nx][ny]==col)
		{
			swap(a[bx][by],a[nx][ny]);
			if(dfs(ax,ay,nx,ny,(col==1)?2:1,dep+1)) return true；
			swap(a[bx][by],a[nx][ny]);
		}
	}
	return false;
}
int mian()
{
	for(register int i=1;i<=4;++i)
	for(register int j=1;j<=4;++j)
	{
		char ch;
		cin>>ch;
		if(ch=='B') a[i][j]=1；
		else if(ch=='W') a[i][j]=2;
		else 
		{
			if(xx1) xx2=i,yy2=j;
			else xx1=i,yy1=j;
			a[i][j]=0;
		}
	}
	for(d=1;;d++)
	{
		if(dfs(xx1,yy1,xx2,yy2,1,1)) break;
		if(dfs(xx1,yy1,xx2,yy2,2,1)) break;
	}
	cout<<d;
	return 0；
}
```


---

## 作者：Xrvitd (赞：4)

#include<iostream>//改了很长时间，却发现就多打了一个负号！！！！操了。。。

    
            
        

```cpp
#include<cmath>
using namespace std;
int n,m,h,t,q[1000001][5][5]={0},a[5][5],step[1000001]={0};
struct re 
{
    int x,y;
};
struct re la[1000001][3];
bool v[1000001]={0};
int f[1000001]={0};
const int fx[5]={0,0,0,1,-1};//就是这里！！！！多写了负号
const int fy[5]={0,1,-1,0,0};
int  hash(long long x)
{
    return x%999997;
}
void copy(int qq,int w)
{
    for(int i=1;i<=4;i++)
    {
        for(int j=1;j<=4;j++)
        {
            q[w][i][j]=q[qq][i][j];
        }
    }
}
int zhuan(int x[5][5])  //不知为何用pow出的数不稳定。。。于是，，，233333333
{
    long long  s,m;
    m+=x[1][1]*1;
    m+=x[1][2]*10;
    m+=x[1][3]*10*10;
    m+=x[1][4]*10*10*10;
    m+=x[2][1]*10*10*10*10;
    m+=x[2][2]*10*10*10*10*10;
    m+=x[2][3]*10*10*10*10*10*10;
    m+=x[2][4]*10*10*10*10*10*10*10;
    m+=x[3][1]*10*10*10*10*10*10*10*10;
    m+=x[3][2]*10*10*10*10*10*10*10*10*10;
    m+=x[3][3]*10*10*10*10*10*10*10*10*10*10;
    m+=x[3][4]*10*10*10*10*10*10*10*10*10*10*10;
    m+=x[4][1]*10*10*10*10*10*10*10*10*10*10*10*10;
    m+=x[4][2]*10*10*10*10*10*10*10*10*10*10*10*10*10;
    m+=x[4][3]*10*10*10*10*10*10*10*10*10*10*10*10*10*10;
    m+=x[4][4]*10*10*10*10*10*10*10*10*10*10*10*10*10*10*10;
    return m;
} 
bool win(int x[5][5])
{
    for(int i=1;i<=4;i++)
    {
        bool vq=0;
        for(int j=1;j<=3;j++)
        {
            if(x[j][i]!=x[j+1][i])
            {
                vq=1;
            }
        }
        if(!vq)
        {
        return 1;
        }
    }
    for(int i=1;i<=4;i++)
    {
        bool v1=0;
        for(int j=1;j<=3;j++)
        {
            if(x[i][j]!=x[i][j+1])
            {
                v1=1;
            }
        }
        if(!v1)
        {
            return 1;
        }
    }
    int vvv=0,vv=0;
    for(int i=1;i<=3;i++)
    {
        if(x[i][i]!=x[i+1][i+1])
        vvv=1;
        if(x[i][4-i+1]!=x[i+1][4-i])
        {
            vv=1;
        }
    }
    if(!vvv||!vv)
    {
        return 1;
    }
    return 0;
}
int main()
{
    int klk=0;
    for(int i=1;i<=4;i++)
    {
        for(int j=1;j<=4;j++)
        {
            char ch;
            cin>>ch;
            if(ch=='B') 
            {
                a[i][j]=0;
                q[1][i][j]=0;
                q[2][i][j]=0;
            }
            if(ch=='W') 
            {
                q[2][i][j]=1;
                a[i][j]=1;
                q[1][i][j]=1;
            }
            if(ch=='O') 
            {
                klk++;
                la[1][klk].x=i;
                la[1][klk].y=j;
                q[2][i][j]=2;
                a[i][j]=2;
                q[1][i][j]=2;
            }
        }
    }
    v[hash(zhuan(a))]=1;
    h=0;t=1;
    while(h<=t)//BFS~~~~~~~~~~~~~~~~~~
    {
        h++;
        for(int io=1;io<=2;io++)
        {
           int i,j;
           i=la[h][io].x;
           j=la[h][io].y;
                if(q[h][i][j]==2)
                {
                    for(int k=1;k<=4;k++)
                    {
                        int tx=i+fx[k],ty=j+fy[k];
                        if(i+fx[k]<=4&&i+fx[k]>0&&j+fy[k]<=4&&j+fy[k]>0)
                        {
                            if(q[h][tx][ty]==2)
                            continue;
                            if(h!=1)
                            {
                            if(f[h]==1)
                            {
                                if(q[h][tx][ty]==1)
                                {
                                    continue;
                                }
                            }
                            else
                            if(f[h]==2)
                            {
                                if(q[h][tx][ty]==0)
                                {
                                    continue;
                                }
                            }
                            }
                            t++;
                            step[t]=step[h]+1;
                            copy(h,t);
                            q[t][i][j]=q[t][tx][ty];
                            q[t][tx][ty]=2;
                            if(q[t][i][j]==1) f[t]=1;
                            if(q[t][i][j]==0) f[t]=2;
                            if(io==1)
                            {
                                la[t][1].x=tx;
                                la[t][1].y=ty;
                                la[t][2].x=la[h][2].x;
                                la[t][2].y=la[h][2].y;
                            }else
                            {
                                la[t][2].x=tx;
                                la[t][2].y=ty;
                                la[t][1].x=la[h][1].x;
                                la[t][1].y=la[h][1].y;
                            }
                            if(v[hash(zhuan(q[t]))])
                            {
                                t--;
                            }else
                            {
                                v[hash(zhuan(q[t]))]=1;
                            }
                            if(win(q[t]))
                            {
                                cout<<step[t];
                                return 0;
                            }
                        }
                    }
                }
        }
    }
}
```

---

## 作者：Wind_Shear (赞：3)

一看题，诶？这不是广搜吗？？？

然后写，输出了个什么啊

然后

然后就玄学AC了




# AC Code:

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define inf 0x3f3f3f3f
using namespace std;
char a[5][5];
int ans,Ox1=0,Oy1,Ox2,Oy2,dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};

bool check() //检查当前棋盘是否构成四子连棋
{
  // 4*4的棋盘，只有行、列、双斜线四种方式
  for(int i=1;i<=4;i++)
  {
    if (a[i][1]==a[i][2]&&a[i][1]==a[i][3]&&a[i][1]==a[i][4]) return 1;
    if (a[1][i]==a[2][i]&&a[1][i]==a[3][i]&&a[1][i]==a[4][i]) return 1;
  }
  if (a[1][1]==a[2][2]&&a[1][1]==a[3][3]&&a[1][1]==a[4][4]) return 1;
  if (a[1][4]==a[2][3]&&a[1][4]==a[3][2]&&a[1][4]==a[4][1]) return 1;
  return 0;
}

bool can(int x,int y,char p)
{
  return x>=1&&x<=4&&y>=1&&y<=4&&a[x][y]!=p;
}

bool dfs(int x1,int y1,int x2,int y2,char pre,int step) //pre表示先手颜色
{
    // dfs(Ox1,Oy1,Ox2,Oy2,'W',0)
  if (step==ans) //搜索深度达到上限，停止
  {
    if (check()) return 1;
    else return 0;
  }
  // 对四个方向遍历
  for(int i=0;i<4;i++)
  {
    int nx1,ny1,nx2,ny2;
    nx1=x1+dir[i][0];
    ny1=y1+dir[i][1];
    nx2=x2+dir[i][0];
    ny2=y2+dir[i][1];
    // 如果当前坐标为有效位置
    if (can(nx1,ny1,pre))  
    {
      swap(a[x1][y1],a[nx1][ny1]); //交换
      if (dfs(nx1,ny1,x2,y2,(pre=='B'?'W':'B'),step+1)) return 1; // 轮流
      swap(a[x1][y1],a[nx1][ny1]);
    }
    if (can(nx2,ny2,pre))
    {
      swap(a[x2][y2],a[nx2][ny2]);
      if (dfs(x1,y1,nx2,ny2,(pre=='B'?'W':'B'),step+1)) return 1;
      swap(a[x2][y2],a[nx2][ny2]);
    }
  }
  return 0;
}

int main()
{
    // 读取棋盘
  for(int i=1;i<=4;i++)
  {
    char s[5];
    scanf("%s",s);
    for(int j=1;j<=4;j++)
    {
      a[i][j]=s[j-1];
      // 分别记录下O的位置
      if (a[i][j]=='O')
      {
        if (Ox1==0)
            Ox1=i,Oy1=j;
        else
            Ox2=i,Oy2=j;
      }
    }
  }

  for(ans=1;ans<=inf;ans++) //ans枚举深度上限
  {
    if (dfs(Ox1,Oy1,Ox2,Oy2,'W',0)) break; //黑先手
    if (dfs(Ox1,Oy1,Ox2,Oy2,'B',0)) break; //白先手
  }

  printf("%d",ans);

  return 0;
}
```


---

## 作者：AcerMo (赞：2)

### 迭代加深DFS
~~我个人比较喜欢叫IDFS~~
#### 讲一下搜索大体思路
发现最终移动步数应该会很少，~~毕竟八数码都能过~~，所以选了这个迭代加深的dfs，就是通过限制一次dfs的深度，来保证你的搜索不会在搜到底或找不到解的情况下返回，他会以lim的深度限制，把这个深度能到的点都搜出来，判断可行，画成图的话会发现这种搜索就像是结合了BFS与DFS，既有广度也有深度
##### 实际操作
分成两次迭代加深，第一次从白色开始走，第二次从黑色开始走，或者反过来，~~您随意，，，~~，然后两次取min，实际搜索的时候，当前操作需要和上从不一样，所以我们定义IDFS(int dep,char col)表示当前的深度以及上次的颜色，然后就能愉快的搜索了，判断就写几个循环判一下就好
### 代码
```cpp
//By AcerMo
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
char a[5][5],b[5][5];
int lim=1;
int fx[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
inline bool che()
{
	for (int i=0;i<4;i++)
	{
		int s=0;
		for (int k=1;k<4;k++)
		s+=(a[i][k]==a[i][k-1]);
		if (s==3) return 1;
	}
	for (int i=0;i<4;i++)
	{
		int s=0;
		for (int k=1;k<4;k++)
		s+=(a[k][i]==a[k-1][i]);
		if (s==3) return 1;
	}
	if (a[0][3]==a[1][2]&&a[1][2]==a[2][1]&&a[2][1]==a[3][0]) return 1;
	if (a[0][0]==a[1][1]&&a[1][1]==a[2][2]&&a[2][2]==a[3][3]) return 1;
	return 0;
}
inline bool IDFS(int dep,char co)
{
	if (dep==lim) return che();
	for (int i=0;i<4;i++)
	for (int k=0;k<4;k++)
	for (int j=0;j<4;j++)
	{
		int x=i+fx[j][0];
		int y=k+fx[j][1];
		if (x<0||x>3||y<0||y>3||a[x][y]!='O'||a[i][k]==co) continue;
		swap(a[x][y],a[i][k]);
		if (IDFS(dep+1,a[x][y])) return 1;
		swap(a[x][y],a[i][k]);
	}
	return 0;
}
signed main()
{
	for (int i=0;i<4;i++) scanf("%s",a[i]);
	for (int i=0;i<4;i++)
	for (int k=0;k<4;k++) 
	b[i][k]=a[i][k]; 
	for (;!IDFS(0,'B');lim++);int ans=lim;lim=1;
	for (int i=0;i<4;i++)
	for (int k=0;k<4;k++)
	a[i][k]=b[i][k];
	for (;!IDFS(0,'W');lim++);ans=min(ans,lim);
	cout<<ans;
	return 0; 
}
```

---

## 作者：Ivystorm (赞：2)

看下面的题解没有写状压或用的10进制，用long long存储

所以我想发一篇3进制int存储的状压

下面是代码加注释
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
int xs[10][10];//3进制转成二维数组用
int change(int x1,int y1,int x2,int y2){//交换(x1,y1),(x2,y2)两个点并返回交换后的3进制状态
    int p=0;
    int t=xs[x1][y1];
    xs[x1][y1]=xs[x2][y2];
    xs[x2][y2]=t;
    for(int i=0;i<4;i++)
       for(int j=0;j<4;j++)
          p=p*3+xs[i][j];
    t=xs[x1][y1];
    xs[x1][y1]=xs[x2][y2];
    xs[x2][y2]=t;//把xs数组还原
    return p;
}
bool checkx(int p){//判断当前情况是否为目标棋局
    for(int i=3;i>=0;i--)
       for(int j=3;j>=0;j--){
          xs[i][j]=p%3;
          p/=3;
       }
    for(int i=0;i<4;i++){//横排相等
       bool fl=true;
       if(xs[i][0]==0)
         fl=false;
       for(int j=1;j<4;j++)
          if(xs[i][j]!=xs[i][j-1]){
            fl=false;
            break;
          }
       if(fl)
         return true;
    }
    for(int j=0;j<4;j++){//竖排相等
       bool fl=true;
       if(xs[0][j]==0)
         fl=false;
       for(int i=1;i<4;i++)
          if(xs[i][j]!=xs[i-1][j]){
            fl=false;
            break;
          }
       if(fl)
         return true;
    }
    //对角线相等
    if(xs[0][0]!=0&&xs[0][0]==xs[1][1]&&xs[1][1]==xs[2][2]&&xs[2][2]==xs[3][3])
      return true;
    if(xs[3][0]!=0&&xs[3][0]==xs[2][1]&&xs[2][1]==xs[1][2]&&xs[1][2]==xs[0][3])
      return true;
    return false;
}
struct point{//当前状态结构体
       int now;//当前棋局
       int cou;//当前步数
       int last;//上次移动的棋
};
//(now)3== 0 空地  1 黑  2 白
queue<point>s;//广搜队列
int main(){
    int nowp=0;
    char jun;
    for(int i=0;i<4;i++)
       for(int j=0;j<4;j++){
          scanf("%c",&jun);
          if(jun!='B'&&jun!='W'&&jun!='O')
            j--;
          else
          if(jun=='O')
            nowp=nowp*3+0;
          else
          if(jun=='B')
            nowp=nowp*3+1;
          else
          if(jun=='W')
            nowp=nowp*3+2;
       }
    s.push((point){nowp,0,-1});//放入初始状态
    while(!s.empty()){
         point nowx=s.front();
         s.pop();
         if(checkx(nowx.now)&&nowx.cou!=0){//如果到的目标棋局就输出
           cout<<nowx.cou;
           return 0;
         }
         //因为chechx函数已经初始化过xs数组，此处不用再次初始化给change用
         for(int i=0;i<4;i++)
            for(int j=0;j<4;j++)
               if(xs[i][j]==0){//找到空地，上下左右移动
                 if(i>0&&xs[i-1][j]!=nowx.last)//记得判断当前棋子不是上次移动的颜色再移动
                   s.push((point){change(i,j,i-1,j),nowx.cou+1,xs[i-1][j]});
                 if(i<3&&xs[i+1][j]!=nowx.last)
                   s.push((point){change(i,j,i+1,j),nowx.cou+1,xs[i+1][j]});
                 if(j>0&&xs[i][j-1]!=nowx.last)
                   s.push((point){change(i,j,i,j-1),nowx.cou+1,xs[i][j-1]});
                 if(j<3&&xs[i][j+1]!=nowx.last)
                   s.push((point){change(i,j,i,j+1),nowx.cou+1,xs[i][j+1]});
               }
    }
    cout<<-1;
    return 0;
}
```

---

## 作者：Y_B_Y (赞：1)

## BFS做法

因为棋子只能走到空格所以就可以让空格移动,这里用的是BFS,交换空格和上下左右中一个点的位置,再记录图的变化,与步数的变化,再来判断可不可以,可以就输出结束程序,下面是具体步骤

#### 注意,由于这一题无论一开始是否满足都要走一遍所以不需要先判断

### 一,变量的定义
用map[tail][i][j]表示第tail中情况时第i行第j列是什么棋子(1黑,2白,0空格)

a[k][tail]表示空格k(因为有两个空格,所以就叫空格1空格2吧)在第tail中情况是所在的行数

b[k][tail]同理,表示所在的列数

c[k][tail]表示步数

now[tail]表示的tail种情况出的是什么棋子

he[i][k]表示第i行棋子k有几个

su[j][k]表示第j列棋子k有几个

dj[q][k]表示对角线q中棋子k有几个(对角线1的坐标特点是i==j,对角线2的特点是i==5-o,可以自己找一找看)

fx[i],fy[i]表示第i中方向(定义在代码中)

### 二.输入
直接上代码解释吧

```cpp
	for(int i=1;i<=4;i++)
	{	
	    string c;//用字符串输入比较方便
		cin>>c;
		for(int j=1;j<=4;j++)
		{
                               /*c[j-1]表示输入的的j个字符*/
			    if(c[j-1]=='B') map[1][i][j]=1;//存图,存第一种情况
			    if(c[j-1]=='W') map[1][i][j]=2;//存图
			    if(c[j-1]=='O')
			    {
				 map[1][i][j]=0;//存图
			    if(a[1][1]==0)//存第一个空格
			    {
			    	a[1][1]=i;
			    	b[1][1]=j;
			    }
			    else//存第二个空格
			    {
			    	a[2][1]=i;
			    	b[2][1]=j;
			    }
			    }
		}
	}
```

### 三.开始BFS

大概方法 ~~(复读了一遍)~~

因为棋子只能走到空格所以就可以让空格移动,这里用的是BFS,交换空格和上下左右中一个棋子的位置,再记录图的变化,与步数的变化,再来判断可不可以,可以就输出结束程序

注意,由于这一题无论一开始是否满足都要走一遍所以不需要先判断

直接上代码解释吧
```cpp
/*定义变量与函数的部分*/
int fx[5]={0,1,-1,0,0},fy[5]={0,0,0,1,-1};//四个方向
bool check(int x,int this)//看上一次改变的和这一次改变的棋子颜色是否冲突
{
	if(x==1) return 1;//一开始(第一种情况时)谁都可以走
	if(this==0) return 0;//空格和空格交换无意义,不可以
	if(this==now[x]) return 0;//颜色冲突不可以
	return 1;//活到这里了,那就是可以
}
int other(int x)//表示另一个数(1就返回2,2就返回1)
{
	if(x==1) return 2;
	return 1;
}
void fz(int he,int ta)//讲he情况的图传给ta情况
{
	for(int pp=1;pp<=4;pp++)
    {
		for(int oo=1;oo<=4;oo++)
	     {
	     	map[ta][pp][oo]=map[he][pp][oo];
		 }
	}
}
int head=0,tail=1;//队列头,尾
/*定义变量与函数的部分*/
	while(head<=tail)//BFS就的用法就不用我讲了吧,忘了的可以看看P1443 马的遍历
	{
		head++;
		for(int k=1;k<=2;k++)//两个空格
		{
		for(int i=1;i<=4;i++)//四个方向
		{
		   int x=a[k][head]+fx[i];
		   int y=b[k][head]+fy[i];//其实x,y就是与空格相邻棋子的坐标
		   if(x>=1&&x<=4&&y>=1&&y<=4&&check(head,map[head][x][y]))//判断可不可以
		   {
		   	   tail++;
		   	   now[tail]=map[head][x][y];//记录这次交换的棋子颜色
		   	   fz(head,tail);//继承上一次的图
		   	   swap(map[tail][x][y],map[tail][a[k][head]][b[k][head]]);//交换
		   	   a[k][tail]=x;
		   	   b[k][tail]=y;//这一次的坐标
		   	   a[other(k)][tail]=a[other(k)][head];
		   	   b[other(k)][tail]=b[other(k)][head];//另一个空格一定要继承上一次的坐标
		   	   c[k][tail]=c[k][head]+1;//这一次的步数
		   	   c[other(k)][tail]=c[other(k)][head];//另一个空格一定要继承上一次的步数
		   	   memset(he,0,sizeof(he));
		   	   memset(su,0,sizeof(he));
		   	   memset(dj,0,sizeof(he));//一定要讲判断的数组清零
		   	   for(int p=1;p<=4;p++)//遍历一遍图看是否满足条件
		   	   {
		   	   	    for(int o=1;o<=4;o++)
		   	   	    {
		   	   		    if(map[tail][p][o]==1)//为1时
					    {
						    he[p][1]++,su[o][1]++;//统计在第p行1的出现次数与在第o列1的出现次数
							if(p==o) dj[1][1]++;//统计对角线1
							if(p==5-o) dj[2][1]++; //统计对角线2
							if(he[p][1]==4||su[o][1]==4||dj[1][1]==4||dj[2][1]==4)//如果有一个为4(即一线(行或列或对角线)上都是同一种颜色)
							{
								cout<<c[1][tail]+c[2][tail]<<endl;//两个的步数要加起来输出
								exit(0);//直接退出
							}
					    }
					    if(map[tail][p][o]==2)//为二时,下面和为1时一样就不说了
					    {
						    he[p][2]++,su[o][2]++;
							if(p==o) dj[1][2]++;
							if(p==5-o) dj[2][2]++; 
							if(he[p][2]==4||su[o][2]==4||dj[1][2]==4||dj[2][2]==4)
							{
								cout<<c[1][tail]+c[2][tail]<<endl;
								exit(0);
							}
					    }
		   	         }
		       }	
		   }
	    }
	    }
    }
```
完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define map mmp
#define this tth
int map[1000001][5][5],a[3][1000001],b[3][1000001],c[3][1000001],he[5][3],su[5][3],dj[3][3];
int now[1000001];
int fx[5]={0,1,-1,0,0},fy[5]={0,0,0,1,-1};
bool check(int x,int this)
{
	if(x==1) return 1;
	if(this==0) return 0;
	if(this==now[x]) return 0;
	return 1;
}
int other(int x)
{
	if(x==1) return 2;
	return 1;
}
void fz(int he,int ta)
{
	for(int pp=1;pp<=4;pp++)
    {
		for(int oo=1;oo<=4;oo++)
	     {
	     	map[ta][pp][oo]=map[he][pp][oo];
		 }
	}
}
int main()
{
	for(int i=1;i<=4;i++)
	{	
	    string c;
		cin>>c;
		for(int j=1;j<=4;j++)
		{
				if(c[j-1]=='B') map[1][i][j]=1;
				if(c[j-1]=='W') map[1][i][j]=2;
				if(c[j-1]=='O')
				{
				 map[1][i][j]=0;
			    if(a[1][1]==0)
			    {
			    	a[1][1]=i;
			    	b[1][1]=j;
			    }
			    else
			    {
			    	a[2][1]=i;
			    	b[2][1]=j;
			    }
				}
		}
	}
	int head=0,tail=1;
	while(head<=tail)
	{
		head++;
		for(int k=1;k<=2;k++)
		{
		for(int i=1;i<=4;i++)
		{
		   int x=a[k][head]+fx[i];
		   int y=b[k][head]+fy[i];
		   if(x>=1&&x<=4&&y>=1&&y<=4&&check(head,map[head][x][y]))
		   {
		   	   tail++;
		   	   now[tail]=map[head][x][y];
		   	   fz(head,tail);
		   	   swap(map[tail][x][y],map[tail][a[k][head]][b[k][head]]);
		   	   a[k][tail]=x;
		   	   b[k][tail]=y;
		   	   a[other(k)][tail]=a[other(k)][head];
		   	   b[other(k)][tail]=b[other(k)][head];
		   	   c[k][tail]=c[k][head]+1;
		   	   c[other(k)][tail]=c[other(k)][head];
		   	   memset(he,0,sizeof(he));
		   	   memset(su,0,sizeof(he));
		   	   memset(dj,0,sizeof(he));
		   	   for(int p=1;p<=4;p++)
		   	   {
		   	   	    for(int o=1;o<=4;o++)
		   	   	    {
		   	   		    if(map[tail][p][o]==1)
					    {
						    he[p][1]++,su[o][1]++;
							if(p==o) dj[1][1]++;
							if(p==5-o) dj[2][1]++; 
							if(he[p][1]==4||su[o][1]==4||dj[1][1]==4||dj[2][1]==4)
							{
								cout<<c[1][tail]+c[2][tail]<<endl;
								exit(0);
							}
					    }
					    if(map[tail][p][o]==2)
					    {
						    he[p][2]++,su[o][2]++;
							if(p==o) dj[1][2]++;
							if(p==5-o) dj[2][2]++; 
							if(he[p][2]==4||su[o][2]==4||dj[1][2]==4||dj[2][2]==4)
							{
								cout<<c[1][tail]+c[2][tail]<<endl;
								exit(0);
							}
					    }
		   	         }
		       }	
		   }
	    }
	    }
    }
}
```





---

## 作者：VCarlyle (赞：1)

> 这道题看似是状压，但是可以直接套$map$

> ——[另一位某大$^D$法$^F$师$^S$](https://www.luogu.org/blog/ArthasMenethil/)的激情句式

---

> 前言

#### $\rm{STL}\bold{\text{大法好！}}$

---

> 思路

相信大部分$\rm{OIer}$们看到题面都知道应该搜索？当然，由于个人偏好 ~~以及代码熟练度~~ ，在这里仅介绍$\rm{BFS}$的做法。

众所周知，$\rm{BFS}$算法是队列的一个应用（在这里直接套了$\rm{STL}$的$queue$，如果不知道的可以自行[百度](https://www.baidu.com/s?wd=queue%20c%2B%2B)）。应用到这道题，个人想法是使用结构体来存放棋局状态再套堆（不会状压……）。由于$queue$不需要元素有序，因此可以直接套上去。

然后是剪枝+存放步数。正常的思维应该是状压+$hash$，然而作为一个重度$\rm{STL}$依赖症患者，第一个想到的当然是结构体套$map$；然而$map$的键值要求有序，因此需要在结构体内重载一遍运算符 `<` 。

接下来看结构体本身。首先需要存放的是棋局状态 ~~（在这里为了偷懒直接用了字符二维数组）~~ ，然后对于每一种状态还需要存放在本状态下行棋的一方 ~~（仍然为了偷懒直接用~~ `'W'` ~~和~~ `'B'` ~~表示）~~ ，接下来只需要重载运算符了（见代码实现）。

需要注意的是，根据[题目讨论](https://www.luogu.org/discuss/show/48243)，黑方先行棋与白方先行棋的结果是不一样的，因此只要开始时将黑方先行棋与白方先行棋两种状态压入队列即可；根据[另一个题目讨论](https://www.luogu.org/discuss/show/5372)，如果棋局初状态合法，那么仍需要输出`1`。这两点是要注意的。

---

> 代码实现

首先是定义棋局的结构体：

```cpp
struct tabula		//tabula:棋局
{
	char c[4][4];	//c:棋局状态，分为'W', 'B'与'O'
	char h;			//h:行棋方，分为'W'与'B'
} init;				//init:棋局初状态
```

然后内嵌一个重载运算符（只需要能够判别两个不同的棋局状态即可），最终整个结构体大概长这样：

```cpp
struct tabula
{
	char c[4][4];
	char h;
	bool operator < (const tabula &t) const	//本段重载运算符极长，故部分省略
	{
		if(c[0][0]<t.c[0][0]) return true;
		if(c[0][0]>t.c[0][0]) return false;
		if(c[0][1]<t.c[0][1]) return true;
		if(c[0][1]>t.c[0][1]) return false;
        ...
		if(c[3][2]<t.c[3][2]) return true;
		if(c[3][2]>t.c[3][2]) return false;
		if(c[3][3]<t.c[3][3]) return true;
		if(c[3][3]>t.c[3][3]) return false;
		if(h<t.h) return true;
		if(h>t.h) return false;
		return false;
	}
} init;
```

判断某个棋局是否合法：

```cpp
bool win(char c[4][4])	//本段也极长，故部分省略
{
	bool b=false;
	if(c[0][0]=='W'&&c[0][1]=='W'&&c[0][2]=='W'&&c[0][3]=='W')  b=true;
	if(c[1][0]=='W'&&c[1][1]=='W'&&c[1][2]=='W'&&c[1][3]=='W')  b=true;
    ...
	if(c[0][0]=='B'&&c[1][1]=='B'&&c[2][2]=='B'&&c[3][3]=='B')  b=true;
	if(c[3][0]=='B'&&c[2][1]=='B'&&c[1][2]=='B'&&c[0][3]=='B')  b=true;
	return b;
}
```

广搜的核心代码：

```cpp
q.push(init);				//初状态入队
...
while(!q.empty())			//q:tabula的queue型
{
	tabula t=q.front();		//t:每次取出q的队首棋局
	int n=m[t];				//m:tabula->int（步数）的map型
							//n:队首棋局的步数
	char h=t.h;				//h:队首棋局的行棋方
    ...
		if(t.c[i][j]=='O')	//如果枚举出一个空位
        ...
			if(t.c[i...][j...]==h)	//如果它周围的棋子是行棋方的棋子，亦即该棋子可以移到空位
			{
				tabula l=t;			//l:移动棋子后的棋局
				l.c[i][j]=h;		//将棋子移到空位
				l.c[i...][j...]='O';//↑↑↑idem↑↑↑
				l.h=ver(h);			//ver(char c):将'W'换成'B'，反之亦然
				if(win(l.c))		//如果该棋局状态合法
				{
					cout<<n+1<<endl;//直接输出步数跳了
					return 0;
				}
				if(!m.count(l))		//如果该棋局状态没有重
				{
					m[l]=n+1;		//该棋局状态步数入map
					q.push(l);		//该棋局状态入队
				}
			}
            ...
	q.pop();				//标准出队
}
```

那么没什么更硬核的代码块了。上完整代码。

```cpp
#include<iostream>
#include<queue>
#include<map>
#include<string>
using namespace std;

bool win(char c[4][4])
{
	bool b=false;
	if(c[0][0]=='W'&&c[0][1]=='W'&&c[0][2]=='W'&&c[0][3]=='W')  b=true;
	if(c[1][0]=='W'&&c[1][1]=='W'&&c[1][2]=='W'&&c[1][3]=='W')  b=true;
	if(c[2][0]=='W'&&c[2][1]=='W'&&c[2][2]=='W'&&c[2][3]=='W')  b=true;
	if(c[3][0]=='W'&&c[3][1]=='W'&&c[3][2]=='W'&&c[3][3]=='W')  b=true;
	if(c[0][0]=='W'&&c[1][0]=='W'&&c[2][0]=='W'&&c[3][0]=='W')  b=true;
	if(c[0][1]=='W'&&c[1][1]=='W'&&c[2][1]=='W'&&c[3][1]=='W')  b=true;
	if(c[0][2]=='W'&&c[1][2]=='W'&&c[2][2]=='W'&&c[3][2]=='W')  b=true;
	if(c[0][3]=='W'&&c[1][3]=='W'&&c[2][3]=='W'&&c[3][3]=='W')  b=true;
	if(c[0][0]=='W'&&c[1][1]=='W'&&c[2][2]=='W'&&c[3][3]=='W')  b=true;
	if(c[3][0]=='W'&&c[2][1]=='W'&&c[1][2]=='W'&&c[0][3]=='W')  b=true;
	if(c[0][0]=='B'&&c[0][1]=='B'&&c[0][2]=='B'&&c[0][3]=='B')  b=true;
	if(c[1][0]=='B'&&c[1][1]=='B'&&c[1][2]=='B'&&c[1][3]=='B')  b=true;
	if(c[2][0]=='B'&&c[2][1]=='B'&&c[2][2]=='B'&&c[2][3]=='B')  b=true;
	if(c[3][0]=='B'&&c[3][1]=='B'&&c[3][2]=='B'&&c[3][3]=='B')  b=true;
	if(c[0][0]=='B'&&c[1][0]=='B'&&c[2][0]=='B'&&c[3][0]=='B')  b=true;
	if(c[0][1]=='B'&&c[1][1]=='B'&&c[2][1]=='B'&&c[3][1]=='B')  b=true;
	if(c[0][2]=='B'&&c[1][2]=='B'&&c[2][2]=='B'&&c[3][2]=='B')  b=true;
	if(c[0][3]=='B'&&c[1][3]=='B'&&c[2][3]=='B'&&c[3][3]=='B')  b=true;
	if(c[0][0]=='B'&&c[1][1]=='B'&&c[2][2]=='B'&&c[3][3]=='B')  b=true;
	if(c[3][0]=='B'&&c[2][1]=='B'&&c[1][2]=='B'&&c[0][3]=='B')  b=true;
	return b;
}

struct tabula
{
	char c[4][4];
	char h;
	bool operator < (const tabula &t) const
	{
		if(c[0][0]<t.c[0][0]) return true;
		if(c[0][0]>t.c[0][0]) return false;
		if(c[0][1]<t.c[0][1]) return true;
		if(c[0][1]>t.c[0][1]) return false;
		if(c[0][2]<t.c[0][2]) return true;
		if(c[0][2]>t.c[0][2]) return false;
		if(c[0][3]<t.c[0][3]) return true;
		if(c[0][3]>t.c[0][3]) return false;
		if(c[1][0]<t.c[1][0]) return true;
		if(c[1][0]>t.c[1][0]) return false;
		if(c[1][1]<t.c[1][1]) return true;
		if(c[1][1]>t.c[1][1]) return false;
		if(c[1][2]<t.c[1][2]) return true;
		if(c[1][2]>t.c[1][2]) return false;
		if(c[1][3]<t.c[1][3]) return true;
		if(c[1][3]>t.c[1][3]) return false;
		if(c[2][0]<t.c[2][0]) return true;
		if(c[2][0]>t.c[2][0]) return false;
		if(c[2][1]<t.c[2][1]) return true;
		if(c[2][1]>t.c[2][1]) return false;
		if(c[2][2]<t.c[2][2]) return true;
		if(c[2][2]>t.c[2][2]) return false;
		if(c[2][3]<t.c[2][3]) return true;
		if(c[2][3]>t.c[2][3]) return false;
		if(c[3][0]<t.c[3][0]) return true;
		if(c[3][0]>t.c[3][0]) return false;
		if(c[3][1]<t.c[3][1]) return true;
		if(c[3][1]>t.c[3][1]) return false;
		if(c[3][2]<t.c[3][2]) return true;
		if(c[3][2]>t.c[3][2]) return false;
		if(c[3][3]<t.c[3][3]) return true;
		if(c[3][3]>t.c[3][3]) return false;
		if(h<t.h) return true;
		if(h>t.h) return false;
		return false;
	}
} init;

char ver(char v)
{
	return v=='B'?'W':'B';
}

queue<tabula> q;
map<tabula,int> m;

int main()
{
	ios::sync_with_stdio(0);	//关闭同步，让cin与cout更高效
	string s;	//s:用于帮助输入的string型
	for(int i=0;i<4;++i)
	{
		cin>>s;
		for(int j=0;j<4;++j)
			init.c[i][j]=s[j];
	}
	init.h='W';		//两种先手状态
		m[init]=0;
		q.push(init);
	init.h='B';
		m[init]=0;
		q.push(init);
	if(win(init.c))
	{
		cout<<1;
		return 0;
	}
	while(!q.empty())
	{
		tabula t=q.front();
		int n=m[t];
		char h=t.h;
		for(int i=0;i<4;++i)
			for(int j=0;j<4;++j)
			{
				if(t.c[i][j]=='O')
				{
					if(i!=0&&t.c[i-1][j]==h)	//空位上方
					{
						tabula l=t;
						l.c[i][j]=h;
						l.c[i-1][j]='O';
						l.h=ver(h);
						if(win(l.c))
						{
							cout<<n+1<<endl;
							return 0;
						}
						if(!m.count(l))
						{
							m[l]=n+1;
							q.push(l);
						}
					}
					if(i!=3&&t.c[i+1][j]==h)	//空位下方
					{
						tabula l=t;
						l.c[i][j]=h;
						l.c[i+1][j]='O';
						l.h=ver(h);
						if(win(l.c))
						{
							cout<<n+1<<endl;
							return 0;
						}
						if(!m.count(l))
						{
							m[l]=n+1;
							q.push(l);
						}
					}
					if(j!=0&&t.c[i][j-1]==h)	//空位左方
					{
						tabula l=t;
						l.c[i][j]=h;
						l.c[i][j-1]='O';
						l.h=ver(h);
						if(win(l.c))
						{
							cout<<n+1<<endl;
							return 0;
						}
						if(!m.count(l))
						{
							m[l]=n+1;
							q.push(l);
						}
					}
					if(j!=3&&t.c[i][j+1]==h)	//空位右方
					{
						tabula l=t;
						l.c[i][j]=h;
						l.c[i][j+1]='O';
						l.h=ver(h);
						if(win(l.c))
						{
							cout<<n+1<<endl;
							return 0;
						}
						if(!m.count(l))
						{
							m[l]=n+1;
							q.push(l);
						}
					}
				}
			}
		q.pop();
	}
	return 0;
}
```

---

> 附言

这次的代码看似是$generator$生成的，但实际上是手打的（笑

$\rm{STL}$确实给$\rm{C}$党带来了许多便利，但是该会的还是要会，不要在$\rm{STL}$中故步自封啊。

最后拿$\rm{NOIp}$的某公告煞尾吧——

[![NOIp对STL的限制？点击查看原文](https://i.loli.net/2018/10/03/5bb4d7bb1430f.png)](http://www.noi.cn/newsview.html?id=229&hash=878FD2&type=6)

$$\mathfrak{-End-}$$

---

## 作者：YangHao (赞：0)

看到楼上很多dalao三进制状压balabala，吓得瑟瑟发抖的蒟蒻我只好用$long\ long$。

因为数据~~水~~小，所以用$bfs$。然后判重我这里用的是$hash$，[人非代码丑](https://www.luogu.org/record/show?rid=11229599)。
```
#include<cstdio>
#include<cstdlib>
#include<cstring>

#define reg register
#define min(x,y) ((x)<(y)?(x):(y))

typedef long long ll;
const int MOD=19961993;
char str[6];
ll s,ans=0x3f3f3f3f;
ll pow[22]={1};
int f[19962000];


struct node{
	ll x;		//棋盘状态
	int type;	//此刻到谁走
}q[1000010];	//队列
int st,ed;
ll t,dt;
int xx,yy;


inline ll dight(ll x,int y){
	return x/pow[y-1]%10;
}
inline ll getzero(ll x){
	ll ans=1;
	while(x%10) ++ans,x/=10l;
	return ans;
}
int check(ll x){	//检查状态是否合法
	for(reg int i=0;i<=3;++i){
		bool tf=1;
		for(reg int j=1;j<=3;++j)
			if(dight(x,i*4+j)!=dight(x,i*4+j+1)){
				tf=0;
				break;
			}
		if(tf) return 1;
		tf=1;
		for(reg int j=1;j<=3;++j)
			if(dight(x,j*4+i-3)!=dight(x,j*4+i+1)){
				tf=0;
				break;
			}
		if(tf) return 1;
	}
	if(dight(x,1)==dight(x,6)&&dight(x,6)==dight(x,11)&&dight(x,11)==dight(x,16)) return 1;
	if(dight(x,4)==dight(x,7)&&dight(x,7)==dight(x,10)&&dight(x,10)==dight(x,13)) return 1;
	return 0;
}
int main(){
	for(reg int i=1;i<=20;++i) //预处理10的幂
		pow[i]=pow[i-1]*10l;
	for(reg int i=1;i<=4;++i){ //读入
		scanf("%s",str+1);
		for(reg int j=1;j<=4;++j)
			switch(str[j]){
				case 'B':
					s=s*10+1;
					break;
				case 'W':
					s=s*10+2;
					break;
				case 'O':
					s=s*10;
					break;
				default:
					break;
			}
	}
	if(check(s)){ //#4猥琐特判
		puts("1");
		exit(0);
	}
	memset(f,63,sizeof(f));f[s%MOD]=0;
    //记得考虑黑白先手的情况
	q[1].x=s;q[1].type=1;q[2].x=s;q[2].type=2;
	st=1;ed=3;
    //bfs
	while(st!=ed){
		ll x=q[st].x,y,z[3];
		if(check(x)){ //如果此状态合法则更新答案
			ans=min(ans,f[x%MOD]);
			break;
		}
		//z数组存储0的位置
        z[1]=getzero(x),z[2]=getzero(x/pow[z[1]])+z[1];
		for(reg int i=1;i<=2;++i){
			//up
			if(z[i]<=12&&dight(x,(int)z[i]+4)==q[st].type){
				t=z[i]+4;dt=dight(x,t);
				xx=(int)(x%MOD);
				y=x+dt*(pow[z[i]-1]-pow[t-1]);
				yy=(int)(y%MOD);
				if(f[yy]>=f[xx]+1){
					f[yy]=f[xx]+1;
					q[ed].x=y;q[ed++].type=3-q[st].type;
				}
			}
			//down
			if(z[i]>=5&&dight(x,(int)z[i]-4)==q[st].type){
				t=z[i]-4;dt=dight(x,t);
				xx=(int)(x%MOD);
                //此处请自行推导，下同
				y=x+dt*(pow[z[i]-1]-pow[t-1]);
				yy=(int)(y%MOD);
				if(f[yy]>=f[xx]+1){//更新答案
					f[yy]=f[xx]+1;
                    //换手
					q[ed].x=y;q[ed++].type=3-q[st].type;
				}
			}
			//left
			if(z[i]%4&&dight(x,(int)z[i]+1)==q[st].type){
				t=z[i]+1;dt=dight(x,t);
				xx=(int)(x%MOD);
				y=x+dt*(pow[z[i]-1]-pow[t-1]);
				yy=(int)(y%MOD);
				if(f[yy]>=f[xx]+1){
					f[yy]=f[xx]+1;
					q[ed].x=y;q[ed++].type=3-q[st].type;
				}
			}
			//right
			if(z[i]%4-1&&dight(x,(int)z[i]-1)==q[st].type){
				t=z[i]-1;dt=dight(x,t);
				xx=(int)(x%MOD);
				y=x+dt*(pow[z[i]-1]-pow[t-1]);
				yy=(int)(y%MOD);
				if(f[yy]>=f[xx]+1){
					f[yy]=f[xx]+1;
					q[ed].x=y;q[ed++].type=3-q[st].type;
				}
			}
		}
		++st;
	}
	printf("%lld",ans);
}
```

---

## 作者：Long·J·William (赞：0)

###思路：深度优先搜索+特殊的状态储存。

我是用二的幂储存的状态（如果理解了，可以增加对‘&’的理解）。

因为是很早以前的我的代码了，我有点看不懂。

（粘一下博客原址：http://www.cnblogs.com/J-william/p/6443754.html ，可能会追加解释，如果有人问的话）

另外黑白棋子谁先手是有影响的。

有关黑棋的变量应该都一个字母‘b’，同样有关白棋的有一个‘w’，行是‘h’，列是‘l’。

代码实现：

```cpp
 1 #include<cstdio>
 2 #include<cstring>
 3 #include<iostream>
 4 using namespace std;
 5 int ww,bb,ans=300;
 6 int w[7][2],b[7][2],h[4];
 7 int hb[]={-1,0,1,0},lb[]={0,1,0,-1};//行变和列变。
 8 int ew[]={2,4,8,16},eb[]={32,64,128,256};
 9 char ch;
10 void dfs(int step,int x){
11     if(step>ans) return;
12     if(step>0){
13     for(int i=0;i<4;i++)
14     if(h[i]==30||h[i]==480){ans=step;return;}
15     for(int i=0;i<4;i++){
16         if(h[0]&ew[i]&&h[1]&ew[i]&&h[2]&ew[i]&&h[3]&ew[i]){ans=step;return;}
17         if(h[0]&eb[i]&&h[1]&eb[i]&&h[2]&eb[i]&&h[3]&eb[i]){ans=step;return;}
18     }
19     for(int i=0;i<5;i++){
20         if(i==4){ans=step;return;}
21         if(!(h[i]&ew[i])) break;
22     }
23     for(int i=0;i<5;i++){
24         if(i==4){ans=step;return;}
25         if(!(h[i]&ew[3-i])) break;
26     }
27     for(int i=0;i<5;i++){
28         if(i==4){ans=step;return;}
29         if(!(h[i]&eb[i])) break;
30     }
31     for(int i=0;i<5;i++){
32         if(i==4){ans=step;return;}
33         if(!(h[i]&eb[3-i])) break;//注意逻辑运算与或非的优先度。 
34     }
35     }
36     if(x!=1){//移白棋 。 
37         for(int i=0;i<7;i++)
38         for(int j=0;j<4;j++){
39             int ah=w[i][0],bl=w[i][1];
40             int nh=ah+hb[j],nl=bl+lb[j];
41             if((!(h[nh]&ew[nl]))&&(!(h[nh]&eb[nl]))&&nh>=0&&nh<4&&nl>=0&&nl<4){
42                 h[nh]+=ew[nl];h[ah]-=ew[bl];
43                 w[i][0]=nh;w[i][1]=nl;
44                 dfs(step+1,1);
45                 h[nh]-=ew[nl];h[ah]+=ew[bl];
46                 w[i][0]=ah;w[i][1]=bl;
47             }
48         }
49     }
50     if(x!=0){//移黑棋。 
51         for(int i=0;i<7;i++)
52         for(int j=0;j<4;j++){
53             int ah=b[i][0],bl=b[i][1];
54             int nh=ah+hb[j],nl=bl+lb[j];
55             if((!(h[nh]&ew[nl]))&&(!(h[nh]&eb[nl]))&&nh>=0&&nh<4&&nl>=0&&nl<4){
56                 h[nh]+=eb[nl];h[ah]-=eb[bl];
57                 b[i][0]=nh;b[i][1]=nl;
58                 dfs(step+1,0);
59                 h[nh]-=eb[nl];h[ah]+=eb[bl];
60                 b[i][0]=ah;b[i][1]=bl;
61             }
62         }
63     }
64 }
65 int main(){
66     for(int i=0;i<4;i++)
67     for(int j=0;j<4;j++){
68         cin>>ch;
69         if(ch=='W'){
70             h[i]+=ew[j];
71             w[ww][0]=i;w[ww++][1]=j;
72         }
73         if(ch=='B'){
74             h[i]+=eb[j];
75             b[bb][0]=i;b[bb++][1]=j;
76         }
77     }
78     dfs(0,2);//这里是2，所以黑棋先手白棋先手各一遍。
79     printf("%d\n",ans);
80     return 0;
81 }

```

---

## 作者：双管荧光灯 (赞：0)

可以用IDDFS

每次枚举最多能移多少次

然后DFS

```cpp
#include<stdio.h>
#include<iostream>
#include<stdlib.h>
#include<math.h>
using namespace std;
int a[6][6],i,j;
char c;
int x[5]={1,-1,0,0};
int y[5]={0,0,1,-1};
bool check(int a[][6])
      {int i,j,f;
        for(i=1;i<=4;i++)
            {f=1;
              for(j=1;j<=4;j++)
                    if(a[i][j]!=a[i][1])
                      {f=0;
                        break;
                        }
              if(f==1)
                  return true;
            }
        for(i=1;i<=4;i++)
            {f=1;
              for(j=1;j<=4;j++)
                    if(a[j][i]!=a[1][i])
                      {f=0;
                        break;
                      }
              if(f==1)
                  return true;
            }
        if(a[1][1]==a[2][2]&&a[1][1]==a[3][3]&&a[1][1]==a[4][4])
            return true;
        if(a[1][4]==a[2][3]&&a[1][4]==a[3][2]&&a[1][4]==a[4][1])
            return true;
        return false;
        }
bool dfs(int n,int i,int l,int a[][6])
     {int j,k,p,t;
       if(i>n)
        {if(check(a))
               return true;
          return false;
        }    
       for(j=1;j<=4;j++)
             for(k=1;k<=4;k++)
                   if(a[j][k]==0)
                      for(p=0;p<4;p++)
                          {int xx=j+x[p];
                            int yy=k+y[p];
                            if(a[xx][yy]!=l&&xx>=1&&xx<=4&&yy>=1&&yy<=4&&a[xx][yy]!=0)
                              {t=a[xx][yy];
                                a[xx][yy]=a[j][k];
                                a[j][k]=t;
                                if(dfs(n,i+1,a[j][k],a))
                                    return true;
                                t=a[xx][yy];
                                a[xx][yy]=a[j][k];
                                a[j][k]=t;
                              }
                            }
        return false;
        }
int main(){
    for(i=1;i<=4;i++)
        {for(j=1;j<=4;j++)
              {scanf("%c",&c);
                if(c=='B')
                    a[i][j]=1;
                if(c=='W')
                    a[i][j]=2;
                if(c=='O')
                    a[i][j]=0;
                }
          scanf("\n");
        }
    for(i=1;;i++)
          if(dfs(i,1,1,a)||dfs(i,1,2,a))
              break;
    printf("%d",i);
}

```

---

## 作者：DreamDraw (赞：0)

```cpp
//IDA*+哈希判重
#include<iostream>
#include<cstring>
using namespace std;
int G[4][4],ax,ay,bx,by;
int have[41000000]={0},k;
bool hash[41000000]={0},ok=0;
const int mx[4]={1,-1,0,0};
const int my[4]={0,0,1,-1};
bool equ(int a,int b,int c,int d);
inline bool check(void);
inline bool gethash(int depth);
void init(void);
void IDA(void);
int search(int depth,int color);
bool equ(int a,int b,int c,int d){
    if(a!=b||b!=c||c!=d)return 0;
    return 1;
}
inline bool check(void){
    for(int i=0;i<4;i++){
        if(equ(G[i][0],G[i][1],G[i][2],G[i][3]))return 1;
        if(equ(G[0][i],G[1][i],G[2][i],G[3][i]))return 1;
    }
    if(equ(G[0][0],G[1][1],G[2][2],G[3][3]))return 1;
    if(equ(G[0][3],G[1][2],G[2][1],G[3][0]))return 1;
    return 0;
```
}//判断棋局是否符合要求
```cpp
inline bool gethash(int depth){//求哈希值
    int va=0;
    for(int i=0;i<4;i++)
        for(int j=0;j<4;j++)
            va=va*3+G[i][j];
    va%=40700017;
    if(hash[va]&&have[va]<=depth)return 0;//have数组防止迭代深搜时哈希出错
    have[va]=depth;
    return 1;
}
void IDA(void){
    for(k=1;k<=10;k++){
        search(1,1);
        if(ok){
            cout<<k;
            break;
        }
        else search(1,2);
        if(ok){
            cout<<k;
            break;
        }    
    }
}
int search(int depth,int color){
    if(depth==k+1)return 0;
    for(int i=0;i<4;i++){
        int tx=ax+mx[i],ty=ay+my[i];
        if(tx<0||tx>3||ty<0||ty>3)continue;
        if(G[tx][ty]!=color)continue;//非法情况
        swap(G[tx][ty],G[ax][ay]);
        ax=tx;ay=ty;
        if(gethash(depth)){
            if(check()){
                ok=1;
                return 1;
            }
            search(depth+1,3-color);
        }
        ax-=mx[i];ay-=my[i];
        swap(G[tx][ty],G[ax][ay]);
    }
    for(int i=0;i<4;i++){
        int tx=bx+mx[i],ty=by+my[i];
        if(tx<0||tx>3||ty<0||ty>3)continue;
        if(G[tx][ty]!=color)continue;
        swap(G[tx][ty],G[bx][by]);
        bx=tx;by=ty;
        if(gethash(depth)){
            if(check()){
                ok=1;
                return 1;
            }
            search(depth+1,3-color);
        }
        bx-=mx[i];by-=my[i];
        swap(G[tx][ty],G[bx][by]);
    }
}
void init(void){
    memset(hash,0,sizeof(hash));
    bool mark=0;
    for(int i=0;i<4;i++)
        for(int j=0;j<4;j++){
            char a;cin>>a;
            if(a=='B')G[i][j]=1;
            else if(a=='W')G[i][j]=2;
            else{
                G[i][j]=0;
                if(!mark){
                    ax=i;ay=j;mark=1;
                }
                else{
                    bx=i;by=j;
                }
            }
        }
}
int main(){
    init();
    IDA();
    return 0;
}
```

---


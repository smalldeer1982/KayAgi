# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# 题解

## 作者：kkksc03 (赞：119)

模板题啊，ac率似乎不理想。

将被占领的城市放入队列中，进行bfs，bfs时，s层以内的都标记为危险。

然后最短路。

点权最短路怎么求呢？

一种办法是，一条边的边权改成连接的两个点权之和，算完最短路后结果div 2

还有别的一些办法。


---

## 作者：fyfy (赞：35)

这道题目其实是最短路裸题。

首先看到题目，要求的到“被占点”距离不大于S的点，自然想到了以“被占点”为源点，求一遍最短路，处理出“危险点”。

可是问题来了，“被占点”有k个，总不能求k次最短路吧，于是我就想到，将所有“被占点”归纳在0这一个外加点上，视作一个点，当“被占点”们与其他点连边时，就用0与其相连，“被占点”之间不连边。

然后，跑一边spfa，边权全都是1(当然也可以广搜)，再扫一遍，找出危险点。

最后，以1为源点，求一遍最短路，当到达点为“危险点”时，边权为Q，为1或n点时，边权为0，为“被占点”时，边权为inf。输出dis[n]即可。

注意，要开long long~
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100010;
const long long inf=214748364701;
queue <int> q;
int n,m,k,ss,P,Q;
long long dis[N],w[N<<2];
int s[N<<2][2],o[N],cnt;
bool ocp[N],vis[N],dgs[N];
inline void add(int,int);

inline void spfa(int now)
{
    memset(vis,0,sizeof(vis));
    for (int i=1;i<=n;++i) dis[i]=inf;
    while (!q.empty()) q.pop();
    q.push(now);dis[now]=0;vis[now]=1;
    while (!q.empty()) {
        int x=q.front();
        for (int i=o[x];i;i=s[i][1]) {
            int y=s[i][0];
            if (dis[y]>dis[x]+w[i]) {
                dis[y]=dis[x]+w[i];
                if (!vis[y])
                    vis[y]=1,q.push(y);
            }
        }
        vis[x]=0;q.pop();
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m>>k>>ss>>P>>Q;
    int x,y;
    for (int i=1;i<=k;++i)
        cin>>x,ocp[x]=1;
    for (int i=1;i<=m;++i) {
        cin>>x>>y;
        if (ocp[x]&&ocp[y]) continue;
        if (ocp[x]) add(0,y),add(y,0);
        else if (ocp[y]) add(0,x),add(x,0);
        else add(x,y),add(y,x);
    }
    for (int i=1;i<=cnt;++i) w[i]=1;
    spfa(0);
    for (int i=1;i<=n;++i)
        if (dis[i]<=ss) dgs[i]=1;
    for (int i=1;i<=cnt;++i) {
        if (dgs[s[i][0]]) w[i]=Q;
        else if (ocp[s[i][0]]) w[i]=inf;
        else w[i]=P;
        if (s[i][0]==1||s[i][0]==n) w[i]=0;
    }
    spfa(1);
    cout<<dis[n]<<endl;
    return 0;
}

inline void add(int x,int y)
{
    s[++cnt][0]=y;s[cnt][1]=o[x];o[x]=cnt;
}
```

---

## 作者：浮梦若生 (赞：8)

算法：DIJKSTRA（堆优化）+BFS（~~关于SPFA，它SHI了~~）

思路：先从每个僵尸城BFS求出其范围内的危险城市，然后再将点权转化为边权。最后DIJKSTRA求出最短路（最小花费）。

~~丑陋码风请见谅~~

```cpp
#include<bits/stdc++.h>
#define GC getchar
#define OUT printf
#define DURU scanf
#define HEHE while
#define FSORT sort
#define STLMAP map
const long long INF=30000000000;                                    //注意：因为是 long long，INF要设大些 
const int MAX=200000+5;
using namespace std;
long long W[MAX<<1],TO[MAX<<1],DIS[MAX],HEAD[MAX],NEXT[MAX<<1];     //不开 long long 炸，无向图边要 *2 
priority_queue< pair<long long,long long> > Q1;                     //优先队列 
long long M,N,K,S,U,V,X,Y,CNT;
bool F1[MAX],F2[MAX];                                               //F1记录某点是否入过优先队列，F2记录某点是否为僵尸城 
queue<long long> Q2;                                                //BFS的队列 
void READ(long long &X){                                            //读入优化 
    int F=1;X=0;
    char C=GC();
    while(C<'0' || C>'9'){if(C=='-')F=-1;C=GC();}
    while(C>='0' && C<='9'){X=X*10+C-'0';C=GC();}
	X*=F;
}
void BUILD(int X,int Y){                                            //邻接表建图 
	TO[++CNT]=Y; NEXT[CNT]=HEAD[X]; HEAD[X]=CNT;
}
void BFS(int SUM){                                                  //BFS求出危险城市 
	HEHE(Q2.size()){
        int X=Q2.front();
		Q2.pop();
        if(DIS[X]==SUM)                                             //当前城市在僵尸城边界，不再由该点扩展 
			continue;
        for(register int I=HEAD[X];I;I=NEXT[I]){
            int Y=TO[I];
			if(!DIS[Y]){ 
				DIS[Y]=DIS[X]+1;                                    //计算距离 
				Q2.push(Y);
			}
        }
    }
	for(register int I=1;I<=CNT;I++){                               //对每个城市的宾馆 “定价 ” 
        int Y=TO[I];
		if(Y==M)continue;                                           //终点免费 
        if(F2[Y]!=0)continue;                                       //僵尸城 
        if(DIS[Y]==0)W[I]=U;                                        //安全城市 
        else W[I]=V;                                                //危险城市 
    }
}
void DIJKSTRA(int S){                                               //优先队列（堆优化）DIJKSTRA 
	for(register int I=1;I<=M;I++)                                  //初始化 
		DIS[I]=INF;
    Q1.push(make_pair(0,S));                                        //起点入队 
    DIS[S]=0;                                                       //起点到自己的距离为 0 
    while(Q1.size()){
        int X=Q1.top().second;                                      //取出队首 
        Q1.pop();
        if(F1[X])continue;                                          //若该点已遍历过，则跳过 
        F1[X]=1;
        for(register int I=HEAD[X];I;I=NEXT[I]){
            int Y=TO[I],K=W[I];
            if(DIS[Y]>DIS[X]+K && F2[Y]!=1){                        //DIJKSTRA标准操作 
                DIS[Y]=DIS[X]+K;
                Q1.push(make_pair(-DIS[Y],Y));                      //注意：pair要用相反数(因为 priority_queue默认大根堆，这样就不用打重载运算符） 
            }
        }
    }
}
int main( ){
	READ(M); READ(N);
	READ(K); READ(S);
	READ(U); READ(V);
	for(register int I=1;I<=K;I++){                                  //僵尸城入BFS队 
        READ(X); F2[X]=1;
		Q2.push(X);
    }
	for(register int I=1;I<=N;I++){                                  //建图 
        READ(X); READ(Y);
        BUILD(X,Y);
        BUILD(Y,X);
    }
    BFS(S);  DIJKSTRA(1);                                            //BFS+DIJKSTRA 
    OUT("%lld\n",DIS[M]); 
	return 0;
}
```

最后附上~~蒻蒻的~~评测结果：

#1
AC
3ms/788KB
 
#2
AC
4ms/8828KB
 
#3
AC
3ms/648KB
 
#4
AC
33ms/7192KB
 
#5
AC
6ms/6924KB
 
#6
AC
101ms/13572KB
 
#7
AC
119ms/13468KB

---

## 作者：顾z (赞：8)

# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述--->[p3393 逃离僵尸岛](https://www.luogu.org/problemnew/show/P3393)

刷题有益于身心健康. 还有,谁说这是个简单题了 emm
 
### 分析

明显最短路的题。

但是需要注意的是有一些传染源,这些传染源会控制一些点.

我们需要$Bfs$处理出这些点,标记它们是$Safe$与否。

这里给出一些定义.

- $Safe[i]==1$代表城市安全,居住价钱为$P$
- $Safe[i]==-1$表示城市为传染源,不可居住.
- $Safe[i]==0$表示城市危险,居住价钱为$Q$.

这个时候预处理出来之后直接跑最短路就行.

但是需要注意的是,跑完最短路之后我们会在$n$点居住。($Dijkstra$吼啊

所以需要减去$n$位置的价值。

**注意需要判断$n$点是否安全,而决定我们减去哪个费用**

如果$Wa$掉＃4和＃6的话需要**将极大值赋的足够大．**

还有 记得开$long \ long $!

## 代码

```c++
#include<cstdio>
#include<queue>
#include<cctype>
#define N 1000008
#define R register
#define int long long 
using namespace std;
inline void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,m,k,S,c[N],head[N],tot,safe[N];
int p,Q,dis[N];
bool vis[N];
struct cod{int u,v;}edge[N<<4];
inline void add(int x,int y)
{
	edge[++tot].u=head[x];
	edge[tot].v=y;
	head[x]=tot;
}
struct coc{int u,dis;};
queue<coc>q1;//结构体版bfs
inline void bfs()
{
	while(!q1.empty())
	{
		int u=q1.front().u,dis=q1.front().dis;
		q1.pop();
		for(R int i=head[u];i;i=edge[i].u)
		{
			if(dis<S and safe[edge[i].v]==1)
			{
				safe[edge[i].v]=0;
				q1.push((coc){edge[i].v,dis+1});
			}
		}
	}
}
struct hop{
	int u,d;
	bool operator<(const hop&a)const
	{
		return d>a.d;
	}
};
inline void dij()//dijkstra
{
	for(R int i=1;i<=n;i++)dis[i]=21474836476666;
	priority_queue<hop>q;
	q.push((hop){1,0});dis[1]=0;
	while(!q.empty())
	{
		int u=q.top().u;q.pop();
		if(vis[u])continue;
		vis[u]=true;
		for(R int i=head[u];i;i=edge[i].u)
		{
			if(safe[edge[i].v]==-1)continue;//如果-1不可居住
			if(safe[edge[i].v]==0)
				if(dis[edge[i].v]>dis[u]+Q)
				{
					dis[edge[i].v]=dis[u]+Q;
					q.push((hop){edge[i].v,dis[edge[i].v]});
				}
			if(safe[edge[i].v]==1)
				if(dis[edge[i].v]>dis[u]+p)
				{
					dis[edge[i].v]=dis[u]+p;
					q.push((hop){edge[i].v,dis[edge[i].v]});
				}
		}
	}
}
signed main()
{
	in(n),in(m),in(k),in(S);
	in(p),in(Q);
	for(R int i=1;i<=n;i++)safe[i]=1;//刚开始都是安全的.
	for(R int i=1;i<=k;i++)
	{
		in(c[i]),safe[c[i]]=-1;//标记为不安全
		q1.push((coc){c[i],0});
	}
	for(R int i=1,x,y;i<=m;i++)
	{
		in(x),in(y);
		add(x,y);add(y,x);
	}
	bfs();dij();
	if(safe[n]==0)dis[n]-=Q;
	else dis[n]-=p;//判断是n是哪种城市
	printf("%lld",dis[n]);
	return 0;
}
```



---

## 作者：ChoHakuNe (赞：6)

这道题模板，其实就两个点，求危险区、把点权转化为边权...然后跑一个最短路即可。
那么我提供一种~~，比较好理解，但~~常数比较大的转化方法吧。
通俗来说就是**拆点**，直观上的**边权全部为0**，每个点拆为两个，一个只负责进，一个只负责出(就是强行给城市加上出口和入口吧...)，我是把i城市出点的编号改成i**+n**,他们之间连一条边，边权为**房费**，于是就完成了...如下图。
![题解用](https://cdn.luogu.com.cn/upload/pic/17214.png)
拆点思路网络流的题比较常用吧...可能是我最近刷多了，大家了解一下也有好处...
代码如下，这道题并没有卡常...
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#define debug(x) cout<<#x<<":"<<x<<endl
#define ll long long
using namespace std;
const ll maxn=200005;
const ll inf=922337203685477580;
vector<ll> linker[maxn],via[maxn];
ll c[maxn],vis[maxn],d[maxn],m,n,k,s,p,qq,x,y,i,inq[maxn],u,v,w;
inline void addedge(ll x,ll y,ll z){
	linker[x].push_back(y);
	via[x].push_back(z);
}
inline void bfs(){
	queue<ll> q;
	for(ll i=1;i<=n*2;i++)d[i]=0;
	for(ll i=1;i<=k;i++){q.push(c[i]);vis[c[i]]=1;d[c[i]]=0;addedge(c[i],c[i]+n,inf);}
	while(!q.empty()){
		ll e=q.front();q.pop();
		if(d[e]==s)return;
		for(ll i=0;i<linker[e+n].size();i++)
		 if(!vis[linker[e+n][i]]){
		 	d[linker[e+n][i]]=d[e]+1;
		 	q.push(linker[e+n][i]);
		 	addedge(linker[e+n][i],linker[e+n][i]+n,qq);
			vis[linker[e+n][i]]=1;
		 }
	}
}
void spfa(){       
	queue<ll> q;
	for(i=1;i<=n*2;i++)d[i]=inf;
	d[1+n]=0;inq[1+n]=1;q.push(1+n);
	while(!q.empty()){
		u=q.front();q.pop();inq[u]=0;
		for(i=0;i<linker[u].size();i++){
			v=linker[u][i];w=via[u][i];
			if(d[v]>d[u]+w){
				d[v]=d[u]+w;
				if(!inq[v]){inq[v]=1;q.push(v);}
			}
		}
	}
	printf("%lld",d[n]);
}
int main(){
	scanf("%lld%lld%lld%lld%lld%lld",&n,&m,&k,&s,&p,&qq);
	for(i=1;i<=k;i++)scanf("%lld",&c[i]);
	for(i=1;i<=m;i++){
		scanf("%lld%lld",&x,&y);
		addedge(x+n,y,0);
		addedge(y+n,x,0);
	}
	bfs();
	for(i=2;i<=n-1;i++)if(!vis[i]){addedge(i,i+n,p);}
	spfa();
	return 0;
}
```

---

## 作者：珈乐唯毒 (赞：5)

题目描述：有k个点不能通行，与这k个点相距小于等于s的点权为q，其他点为p。

## part1 确定点权
求两个点之间的最短距离，这种问题可以使用广搜来解决。从每一个僵尸占领的城市出发广搜，如果距离小于等于s就标记一下。

代码
```
for(int i=1;i<=k;i++){
	q.push(z[i]);
	while(!q.empty()){
		u=q.front();
		if(sa[u]==0)sa[u]=1;
		q.pop();
		vis[u]=0;
		if(d[u]==s)continue;
		for(int j=head[u];j;j=edge[j].next){
			v=edge[j].to;
			if(d[v]>d[u]+1){
				d[v]=d[u]+1;
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
}
```
## part2 做最短路
再给每一个点赋权，跑一遍最短路确定最短距离就可以了。

代码
```
	for(int i=1;i<=n;i++){
		if(sa[i]==0)va[i]=pp;
		if(sa[i]==1)va[i]=qq;
	}
	dis[1]=0;
	va[n]=0;
	va[1]=0;
	p.push(lmf(1,0));
	for(int i=1;i<=n;i++){
		u=p.top().u;
		w=p.top().w;
		p.pop();
		if(w>dis[u])continue;
		for(int j=head[u];j;j=edge[j].next){
			v=edge[j].to;
			if(sa[v]==-1)continue;
			if(dis[v]>dis[u]+va[v]){
				dis[v]=dis[u]+va[v];
				p.push(lmf(v,dis[v]));
			}
		}
	}
```
那这就结束了呢

上AC代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=100005,M=200005;
const long long INF=10000000005;
int n,m,k,s,pp,qq;
int z[N],d[N];
long long dis[N];
int head[N],en,sa[N],va[N];
struct Edge{
	int next,to;
}edge[M*2];
struct lmf{
	int u;
	long long w;
	lmf(int a,long long b){
		u=a;
		w=b;
	}
	bool operator <(const lmf &i) const{
		return w>i.w;
	}
};
priority_queue<lmf> p;
void add(int u,int v){
	edge[++en].next=head[u];
	edge[en].to=v;
	head[u]=en;
}
queue<int> q;
bool vis[N];
int main(){
	cin>>n>>m>>k>>s>>pp>>qq;
	for(int i=1;i<=n;i++){
		d[i]=N;
		dis[i]=INF;
	}
	for(int i=1;i<=k;i++){
		cin>>z[i];
		d[z[i]]=0;
		sa[z[i]]=-1;
	}
	int u,v,w;
	for(int i=1;i<=m;i++){
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<=k;i++){
		q.push(z[i]);
		while(!q.empty()){
			u=q.front();
			if(sa[u]==0)sa[u]=1;
			q.pop();
			vis[u]=0;
			if(d[u]==s)continue;
			for(int j=head[u];j;j=edge[j].next){
				v=edge[j].to;
				if(d[v]>d[u]+1){
					d[v]=d[u]+1;
					if(!vis[v]){
						q.push(v);
						vis[v]=1;
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(sa[i]==0)va[i]=pp;
		if(sa[i]==1)va[i]=qq;
	}
	dis[1]=0;
	va[n]=0;
	va[1]=0;
	p.push(lmf(1,0));
	for(int i=1;i<=n;i++){
		u=p.top().u;
		w=p.top().w;
		p.pop();
		if(w>dis[u])continue;
		for(int j=head[u];j;j=edge[j].next){
			v=edge[j].to;
			if(sa[v]==-1)continue;
			if(dis[v]>dis[u]+va[v]){
				dis[v]=dis[u]+va[v];
				p.push(lmf(v,dis[v]));
			}
		}
	}
	cout<<dis[n];
	return 0;
}
```



---

## 作者：旭日临窗 (赞：5)

## 这里发一下Dijkstra + 优先队列 + 链式前向星 + 构造函数的做法

- 思路：其实这道题分为两步：

1. 先跑一遍多源最短路，每一个被僵尸控制的城市就是一个源点，距离用 d 数组储存，标记一下危险和安全城市。

1. 这一步的关键点在于如何把点权转化成边权，我们可以这样做，如果即将更新的城市已经被僵尸占领了，就直接跳过，如果是安全城市，那边权就是 P ,如果是危险城市，那边权就是 Q ,最后再跑一遍最短路，输出 dis[ n ] 就行了。

- 理由： 因为我们每到一个点就要住宿，可以看做是收费，我们把点权转化成边权，就可以看作是在路上就提前收费了，这样就好理解多了。

- code：
```c
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll inf = 0x7f7f7f7f7f7f;//dis数组初始化的时候用。 
struct node
{
	ll x,w;
	node(){}//构造函数 
	node(ll _x,ll _w) : x(_x),w(_w){}
	bool operator < (const node &s) const//别忘记重载小于号。 
	{
		return w > s.w;
	}
};
struct Edge
{
	int to,next;
}edge[400010];//链式前向星。 
int n,m,k,s,P,Q,cnt,head[100010],f[100010];//f数组记录被占领城市。 
ll dis[100010],men[100010]; 
bool die[100010],vis[100010];//die记录城市i有没有被占领。 
priority_queue <node> q;
void bfs()
{
	for(int i = 1;i <= n;i++) dis[i] = inf;
	for(int i = 1;i <= k;i++) q.push(node(f[i],0)),dis[f[i]] = 0;
	while(!q.empty())//多源最短路模板。 
	{
		ll u = q.top().x;q.pop();
		if(vis[u]) continue;
		vis[u] = 1;
		for(int i = head[u];~i;i = edge[i].next)
		{
			int v = edge[i].to;
			if(!vis[v] && dis[u] + 1 < dis[v])
			{
				dis[v] = dis[u] + 1;
				q.push(node(v,dis[v]));
			}
		}
	}
}
void bfs2()
{
	for(int i = 1;i <= n;i++) dis[i] = inf;
	memset(vis,0,sizeof(vis));
	q.push(node(1,0));
	dis[1] = 0;
	while(!q.empty())//最短路模板。 
	{
		int u = q.top().x;q.pop();
		if(vis[u]) continue;
		vis[u] = 1;
		for(int i = head[u];~i;i = edge[i].next)
		{
			int v = edge[i].to;
			if(die[v]) continue;//如果被占领，就跳过。 
			int w = men[v];
			if(!vis[v] && dis[u] + w < dis[v])
			{
				dis[v] = dis[u] + w;
				q.push(node(v,dis[v]));
			}
		}
	}
}
void add(int u,int v)//存边。 
{
	edge[cnt].to = v;
	edge[cnt].next = head[u];
	head[u] = cnt++;
}
int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d%d%d",&n,&m,&k,&s);
	scanf("%d%d",&P,&Q);
	int x;
	for(int i = 1;i <= k;i++)
	{
		scanf("%d",&x);
		f[i] = x;
		die[x] = 1;
	}
	int u,v;
	for(int i = 1;i <= m;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	bfs();
	for(int i = 1;i <= n;i++)
	{
		if(dis[i] <= s) men[i] = Q;//记录边权。 
		else men[i] = P;
	}
	men[n] = 0;//注意到n不需要住宿，也就是不需要收费。 
	men[1] = 0; 
	bfs2();
	printf("%lld",dis[n]);//输出答案。 
	return 0;
 } 
```




---

## 作者：Lynx (赞：4)

3k君说是模板题，似乎真的是呢。

思路清晰：求出危险的城市，在跑spfa。

坑点不少：

1 要用long long。

2 dfs时要用到spfa的思想，不是搜过就不搜，而是如果可以更新还要搜索。

3 关于cst数组 如果边搜索边赋值，有可能给n赋了值。（会坑63分）


贴一下c++代码

```cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<cstdio>
#include<queue>
using namespace std;
const long long inf=1000000000ll*1000000000ll+10ll;
const int maxn=100005;
vector<int>v[maxn];
queue<int>que;
int n,m,k,s,stp[maxn],c[maxn];
long long p,q,dis[maxn],cst[maxn];
bool b[maxn],inq[maxn];//b[]是不能到达
void dfs(int u)
{
    if(stp[u]==s)
        return ;
    for(int i=0;i<v[u].size();i++)
        if(!b[v[u][i]]&&stp[v[u][i]]>stp[u]+1)
        {
            stp[v[u][i]]=stp[u]+1;
            cst[v[u][i]]=q;
            dfs(v[u][i]);
        }
}
void spfa()
{
    for(int i=1;i<=n;i++)
        dis[i]=inf;
    que.push(1);
    inq[1]=1;
    dis[1]=0;
    while(!que.empty())
    {
        int u=que.front();
        que.pop();
        inq[u]=0;
        for(int i=0;i<v[u].size();i++)
            if(!b[v[u][i]])
                if(dis[v[u][i]]>dis[u]+cst[v[u][i]])
                {
                    dis[v[u][i]]=dis[u]+cst[v[u][i]];
                    if(!inq[v[u][i]])
                    {
                        que.push(v[u][i]);
                        inq[v[u][i]]=1;
                    }
                }
    }
    printf("%lld\n",dis[n]);
}
int main()
{
    scanf("%d%d%d%d%lld%lld",&n,&m,&k,&s,&p,&q);
    for(int i=2;i<=n-1;i++)
        cst[i]=p;
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&c[i]);
        b[c[i]]=1;
    }
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        v[x].push_back(y);
        v[y].push_back(x);
    }
    memset(stp,0x3f,sizeof(stp));
    for(int i=1;i<=k;i++)
    {
        stp[c[i]]=0;
        dfs(c[i]);
    }
    cst[n]=0;
    spfa();
    return 0;
}
```

---

## 作者：Yuyuanqi (赞：3)

# 题解 P3393 【逃离僵尸岛】

[题目链接](https://www.luogu.org/problem/P3393)

没错这题就是单元最短路径的裸题。

同时也可以练习一下多源BFS

在处理被占领点周围的“危险点”时我们可以使用bfs，对于k个被占领点一个一个BFS显然太慢~~没有B格~~了，所以我们可以多源BFS，也就是第一次就把所有的被占领点压到队列里。

染完色以后处理每个点的权值，危险点的权值设为q，安全点的权值设为p，被占领的点权值设为一个比较大的数。

然后从点1跑最短路径就行了。

总之这是一道有点细节的模板题，要开long long不然玄学错误

代码：

```cpp
/*PROPERTY OF YUANQI*/
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <stack>
#define ll long long
#define N 200005
using namespace std;

inline ll read()
{
	ll x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}


ll n, m, tot, head[N], P, Q, K, S, c[N], cost[N], dis[N], vis[N];
queue < int > q;
struct edge {
	ll to, next;
	edge () {
	}
	edge (int x, int y) {
		to = x, next = y;
	}
}a[2 * N];

void addedge(ll from, ll to) {
	a[++tot] = edge(to, head[from]);
	head[from] = tot;
}

void spfa() { //他死了
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		vis[u] = false;
		for (int i = head[u]; i; i = a[i].next) {
			ll v = a[i].to;
			if (dis[u] + cost[v] < dis[v]) {
				dis[v] = dis[u] + cost[v];
				if (!vis[v]) {
					q.push(v);
					vis[v] = true;
				}
			}
		}
	}
}

int main()
{
	memset(dis, 0x3f3f3f3f, sizeof(dis));
	n = read(), m = read(), K = read(), S = read();
	P = read(), Q = read();
	for (int i = 1; i <= K; i++) {
		int ci = read();
		c[ci] = S + 1;
		q.push(ci);
	}
	for (int i = 1; i <= m; i++) {
		int a1 = read(), a2 = read();
		addedge(a1, a2);
		addedge(a2, a1);
	}
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		if (c[u] == 1) continue;
		for (int i = head[u]; i; i = a[i].next) {
			int v = a[i].to;
			if (!c[v]) {
				c[v] = c[u] - 1;
				q.push(v);
			}
		}
	}//多源bfs c数组表示这个点是否还能扩展
	for (int i = 1; i <= n; i++) {
		if (c[i] == S + 1) cost[i] = 1000000;
		else if (c[i]) cost[i] = Q;
		else cost[i] = P;
	}//初始化点权
	cost[1] = 0, cost[n] = 0;
	dis[1] = 0;
	q.push(1);
	vis[1] = true;
	spfa();//他死了
	cout << dis[n] << endl;
	return 0;
}

```
ps：最好学习一下迪杰斯特拉不然很可能被卡掉qwq


---

## 作者：Night_Bringer (赞：2)

 [原博客食用更佳](https://www.cnblogs.com/C202202chenkelin/p/14060757.html)
 
很明显是一个最短路，但是如何建图才是关键。

对于每一个不可遍历到的点，可以向外扩散，找到危险城市。

若是对于每一个这样的城市进行搜索，时间复杂度就为$O(n^2)$，显然过不了。不妨把它们放在一个BFS里面进行搜索，先遍历可以向外延伸最长的点，因为这个点是可以存活很长的。若之后再遍历到这个点的时候，就不用在遍历了，因为这时候的存活时间已经没有之前遍历的时候高了。BFS+打标记遍历完一张图只需要$O(n)$的时间复杂度，很大程度上优化了建图方面。

最后根据所给的边跑一遍最短路即可，代码如下：

```cpp
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
#define LL long long
#define INF 0x3f3f3f3f
void Quick_Read(LL &N) {
	N = 0;
	char c = getchar();
	LL op = 1;
	while(c < '0' || c > '9') {
		if(c == '-')
			op = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		N = (N << 1) + (N << 3) + c - 48;
		c = getchar();
	}
	N *= op;
}
const LL MAXN = 1e6 + 5;
struct Node {
	LL to, dist;
	Node() {}
	Node(LL T, LL D) {
		to = T;
		dist = D;
	}
	friend bool operator > (Node x, Node y) {
		return x.dist > y.dist;
	}
};
struct Flee {
	LL step, id;
	Flee() {}
	Flee(LL I, LL S) {
		step = S;
		id = I;
	}
	friend bool operator > (Flee x, Flee y) {
		return x.step < y.step;
	}
}; 
vector<LL> v[MAXN];
vector<Node> wg[MAXN];
queue<Flee> que;
priority_queue<Node, vector<Node>, greater<Node> > qu;
bool f[MAXN], vis[MAXN], vi[MAXN], V[MAXN];
LL c[MAXN], w[MAXN];
LL A[MAXN], B[MAXN], d[MAXN];
LL n, m, k, s, p, q;
void Dijkstra() {
	memset(d, 0x3f, sizeof(d));
	qu.push(Node(1, 0));
	d[1] = 0;
	while(!qu.empty()) {
		LL now = qu.top().to; qu.pop();
		if(V[now])
			continue;
		V[now] = true;
		LL SIZ = wg[now].size();
		for(LL i = 0; i < SIZ; i++) {
			LL next = wg[now][i].to;
			if(d[now] + wg[now][i].dist < d[next]) {
				d[next] = d[now] + wg[now][i].dist;
				qu.push(Node(next, d[next]));
			}
		}
	}
	printf("%lld", d[n]);
}
void bfs() {
	for(LL i = 1; i <= k; i++) {
		que.push(Flee(c[i], s));
		vi[c[i]] = 1;
	}
	while(!que.empty()) {
		Flee now = que.front(); que.pop();
		if(vis[now.id])
			continue;
		vis[now.id] = 1;
		vi[now.id] = 1;
		if(now.step == 0)
			continue;
		LL SIZ = v[now.id].size();
		for(LL i = 0; i < SIZ; i++) {
			LL nex = v[now.id][i];
			que.push(Flee(nex, now.step - 1));
		}
	}
}
void Read() {
	Quick_Read(n);
	Quick_Read(m);
	Quick_Read(k);
	Quick_Read(s);
	Quick_Read(p);
	Quick_Read(q);
	for(LL i = 1; i <= k; i++) {
		Quick_Read(c[i]);
		f[c[i]] = true;
	}
	for(LL i = 1; i <= m; i++) {
		Quick_Read(A[i]);
		Quick_Read(B[i]);
		v[A[i]].push_back(B[i]);
		v[B[i]].push_back(A[i]);
	}
}
void Build() {
	for(LL i = 1; i <= n; i++)
		w[i] = p;
	for(LL i = 1; i <= n; i++)
		if(vi[i])
			w[i] = q;
	for(LL i = 1; i <= k; i++)
		w[c[i]] = INF;
	for(LL i = 1; i <= m; i++) {
		if(B[i] == n) {
			wg[A[i]].push_back(Node(B[i], 0));
			wg[B[i]].push_back(Node(A[i], w[A[i]]));
		}
		else if(A[i] == n) {
			wg[A[i]].push_back(Node(B[i], w[B[i]]));
			wg[B[i]].push_back(Node(A[i], 0));
		}
		else {
			wg[A[i]].push_back(Node(B[i], w[B[i]]));
			wg[B[i]].push_back(Node(A[i], w[A[i]]));
		}
	}
}
int main() {
	Read();
	bfs();
	Build();
	Dijkstra();
	return 0;
}
```

---

## 作者：momo5440 (赞：2)

我的做法和大佬们一样，都是bfs+SPFA，看到各位大佬都是把点权换为边权做的，在这里我介绍一下直接拿点权做的方法，设当前从队列里出来的点为a，有一条边把它与b连接，而b本身的权值为v，这时若想修改则须满足（d[a]+v<d[b]）（d[i]为当前1到i的最短路的值（SPFA标准啊）），换句话来说就是把点变为边，边变成点
举个例子，这是一张图：（括号内是权值）
（1）——（2）变为——（1）——某个点——（2）——
对于BFS就是不断地更新，但是不见得被更新过的点就不用再被跟新了，所以就用SPFA的思想——在队列里就不用更新了。
还有热心地提醒，在bfs时如果下一个是占领的点就不要更新，千万不要，我为了这个几乎花了3个小时到最后都怀疑人生了
详情请见代码。
```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <cstring>
#include <cstdio>
using namespace std;
struct search{
	long long int time;
	int number;
};
queue<int> qq;
vector<int> bian[100005];//存图用 
int c[100005];//题目中的c 
long long int va[100005];//点的权值 ，记得开long long 
long long int n,k,m,s1,p,q;//s1是题目中的s,其余一样 
long long int d[100005];//d[i]为当前1到i的最短路的值 
bool vis[100005];//SPFA用 
bool vas[100005];//BFS用 
void bf(int s){
	memset(vas,0,sizeof(vas));
	queue <search> q1;
	search tp;
	tp.number=s;
	tp.time=0;
	q1.push(tp);
	va[s]=21474836476666;//被站点附成很大的数这样就不会被走到了 
	vas[s]=1;
	while (!q1.empty()){
		tp=q1.front();
		q1.pop();
		//cout<<tp.time<<' ';
		vas[tp.number]=0;//出队了 
		for (int i=0;i<bian[tp.number].size();i++){
			int number=bian[tp.number][i];
			if (tp.time+1<=s1&&vas[number]==0&&va[number]!=21474836476666){//不在队里且不是被占过的点 
				vas[number]=1;
				va[number]=q;
				search t1;
				t1.number=number;
				t1.time=tp.time+1;
				q1.push(t1);//入队 
			}
		}
	}
}
int main(){	
	cin>>n>>m>>k>>s1;
	cin>>p>>q;
	for (int i=1;i<=k;i++) {
		scanf("%d",&c[i]);
	}
	
	for (int i=1;i<=n;i++) va[i]=p;
	int t1,t2;
	for (int i=1;i<=m;i++){
		cin>>t1>>t2;
		bian[t1].push_back(t2);
		bian[t2].push_back(t1);
	}
	for (int i=1;i<=k;i++) bf(c[i]);
	//for (int i=1;i<=n;i++) {
		//if (va[i]==q) cout<<i<<' ';
	//}
	memset(d,0x3f,sizeof(d));
	d[1]=va[1];
	int t=1;
	vis[1]=true;
	qq.push(t);
	while (!qq.empty()){//SPFA 
		t=qq.front();
		qq.pop();
		vis[t]=false;
		for (int i=0;i<bian[t].size();i++){
			int id=bian[t][i];
			if (d[id]>d[t]+va[id]){//具体原因已经讲过 
				d[id]=d[t]+va[id];
				if (vis[id]==false){
					vis[id]=true;
					qq.push(id);
				}
			}
		}
	}
	cout<<d[n]-va[1]-va[n];//1和n不用住所以减去 
}
```


---

## 作者：封禁用户 (赞：2)

####看到楼下用bfs多，其实也可以跑两遍spfa（>\_>）；

####用邻接表（链式前向星？？）存图，不然会爆

###z注意1<p<q<=100000而n有100000,10^6\*10^6>maxlongint;

####被这个数据范围坑掉了第四个点，如果错了可能是没开（int64/long long）

####下面上代码（怕代码比较长识别不出，可能看起来不舒服）

···Pascal


```cpp
type  arr=record
      t,next:int64;
end;
var i,j,k,n,m,s,p,q1,x,cnt,y:longint;
    h,c,cdioost,q,dis,dist:array[0..100001] of int64;
    e:array[0..1000000] of arr;//邻接表存图
    v:array[0..100001] of boolean;//表示该点是否被访问过
procedure add(u,v:longint);
begin
  inc(cnt);
  e[cnt].t:=v;
  e[cnt].next:=h[u];
  h[u]:=cnt;
end;//加边就不用说了
procedure spfa1;//第一遍spfa跑出危险城市
var i,head,tail,u:longint;
begin
  fillchar(q,sizeof(q),0);
  fillchar(v,sizeof(v),false);
  fillchar(dis,sizeof(dis),$3f);
  head:=1; tail:=k;
  for i:=1 to k do
    begin
      q[i]:=c[i];
      v[c[i]]:=true;
      dis[c[i]]:=0;
    end;//先把被感染的城市入队，dis数组存到危险城市的距离
  while head<=tail do
    begin
      u:=q[head];
      i:=h[u];
      while i<>0 do
        begin
          if dis[e[i].t]>dis[u]+1 then
            begin
              dis[e[i].t]:=dis[u]+1;
              if not v[e[i].t] then
                begin
                  inc(tail);
                  q[tail]:=e[i].t;
                  v[e[i].t]:=true;
                end;//把e[i].t入队
            end;
          i:=e[i].next;//迭代到下一个点
        end;
      v[u]:=false;//别忘了释放头结点
      inc(head);//q.pop()
    end;
end;//邻接表的spfa
procedure spfa2;//跑出1-n的最小花费
var i,head,u,tail:longint;
begin
  fillchar(q,sizeof(q),0);
  fillchar(v,sizeof(v),false);
  fillchar(dist,sizeof(dist),$3f);
  for i:=1 to k do dist[c[i]]:=0;//到不了的危险城市
  dist[1]:=0; q[1]:=1;
  v[1]:=true;
  head:=1; tail:=1;
  while head<=tail do//spfa大体同上，但打起来比bfs整齐点
    begin
      u:=q[head];
      i:=h[u];
      while i<>0 do
        begin
        if (dist[e[i].t]>dist[u]+cost[e[i].t])and(dis[e[i].t]<>0){额这个有点多余} then
          begin
            dist[e[i].t]:=dist[u]+cost[e[i].t];
            if not v[e[i].t] then
              begin
                inc(tail);
                q[tail]:=e[i].t;
                v[e[i].t]:=true;
              end;
          end;
        i:=e[i].next;
        end;
      v[u]:=false;
      inc(head);
    end;
end;
begin
  readln(n,m,k,s); readln(p,q1);
  for i:=1 to k do readln(c[i]);//c[i]存危险城市编号
  for i:=1 to m do
    begin
      readln(x,y);
      add(x,y);add(y,x);//邻接表加边
    end;
  spfa1;
  for i:=1 to n do
    if dis[i]<=s then cost[i]:=q1 else cost[i]:=p;//若i到危险城市距离小于等于s那么费用为q1负责为p
  cost[1]:=0; cost[n]:=0;//起点和终点不算钱
  spfa2;
  writeln(dist[n]);
end.

```

---

## 作者：FutaRimeWoawaSete (赞：1)

应该是一篇很不一样的题解。     

不知道为什么，我突然想不起来怎么 $BFS$ 了。        

于是我又开始想别的算法，我们不难发现，作为被感染的城市，我们可以直接把它们缩成一个点，然后把大点往每个与感染城市相邻的点上连边后跑一个 $Dij$ 求出离每个点的最短距离，这样我们就可以知道每个点的权值，把这道题变成了一道 $Dij$ 模板。    

如果您再精炼一点可以把两个 $Dij$ 合在一起写，整道题的码量顿时也就成了一个模板题的码量。    

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cmath>
using namespace std;
const int Len = 3e5 + 5;
const long long Inf = 1e12;
int n,m,head[Len],TAT[Len],cnt,k;
long long dis[Len],val[Len],S,CH,EXP;
bool vis[Len],f[Len] , LLL[Len];
struct node
{
	int next,to;
}edge[Len << 1];
struct Node
{
	int idx;
	long long dis;
	bool operator < (const Node &Ano) const
	{
		return dis > Ano.dis;
	}
};
void add(int from,int to)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
void Dij(int s)
{
	Node P , C;
	priority_queue<Node> q;
	for(int i = 1 ; i <= n + 1 ; i ++) dis[i] = Inf , f[i] = false;
	dis[s] = 0;
	P.idx = s , P.dis = 0;
	q.push(P);
	while(!q.empty())
	{
		P = q.top();q.pop();
		if(!f[P.idx])
		{
			f[P.idx] = true;
			for(int e = head[P.idx] ; e ; e = edge[e].next)
			{
				int to = edge[e].to;
				if(dis[to] > dis[P.idx] + 1)
				{
					dis[to] = dis[P.idx] + 1;
					if(!f[to]){C.dis = dis[to] , C.idx = to ; q.push(C);}
				}
			}
		}
	}
	for(int i = 1 ; i <= n ; i ++) val[i] = (dis[i] <= S) ? EXP : CH;
	val[1] = val[n] = 0;
}
void Dij_ans(int s)
{
	Node P , C;
	priority_queue<Node> q;
	for(int i = 1 ; i <= n ; i ++) dis[i] = Inf , f[i] = false;
	dis[s] = 0;
	P.idx = s , P.dis = 0;
	q.push(P);
	while(!q.empty())
	{
		P = q.top();q.pop();
		if(!f[P.idx])
		{
			f[P.idx] = true;
			for(int e = head[P.idx] ; e ; e = edge[e].next)
			{
				int to = edge[e].to;
				if(!vis[to] && dis[to] > dis[P.idx] + val[to])
				{
					dis[to] = dis[P.idx] + val[to];
					if(!f[to]){C.dis = dis[to] , C.idx = to ; q.push(C);}
				}
			}
		}
	}
}
signed main()
{
	scanf("%d %d %d %lld %lld %lld",&n,&m,&k,&S,&CH,&EXP);
	for(int i = 1 ; i <= k ; i ++) scanf("%d",&TAT[i]);
	for(int i = 1 ; i <= m ; i ++)
	{
		int x,y;scanf("%d %d",&x,&y);
		add(x , y) , add(y , x);
	}
	for(int i = 1 ; i <= k ; i ++)
	{
		int x;x = TAT[i];
		vis[x] |= 1;
		for(int e = head[x] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!LLL[to])
			{
				LLL[to] = true;
				add(n + 1 , to);
			}
		}
	}
	Dij(n + 1);
	Dij_ans(1);
	printf("%lld",dis[n]);
	return 0;
}
```

---

## 作者：rediserver (赞：1)

# P3393 逃离僵尸岛
[原题地址](https://www.luogu.org/problemnew/show/P3393)

[GitHub题解](https://github.com/jerrykcode/luogu)

## 思路

计算出点权，按点权dijkstra即可

### 计算点权

* 普通城市 点权为p

* 危险城市 点权为q

* 被占领城市 不可达，无点权

* 起点和终点 点权为0

关键在于计算出哪些是危险城市，即被占领城市周围s层内的城市

所有被占领城市先进队列，用last记录最后一个进队列的顶点，tail记为上一层的最后一个顶点

若所有被占领城市为第0层，我们开始计算周围第一层，初始last和tail的值相同，为所有被占领城市中最后一个进队列的(last为最后进队列的顶点，tail为上一层即第0层最后一个顶点)，while队列不空则一个顶点出队列，这个顶点扩展到的顶点均为第一层的顶点，它们都进队列，更新last为它们中的最后一个。若当前出队列的顶点为tail，则第0层的都扩展完毕，准备开始将第一层的顶点出队列并扩展，更新tail为last。记录层数，层数到达s时跳出循环。


```
    6
    |
    |
    |
2---0---1---4---7---8---9
    |       |   |
    |       |   |
    |       |   |
    3       5   10
```

如图，若0和1被占领，s=2，则 2 3 4 5 6 7 为危险顶点


|操作|last|tail|队列|危险顶点(将危险顶点的点权设为q)|层数|
|:--:|:--:|:--:|:--:|:--:|:--:|
|0，1进队列|1|1|0 1|-|0|
|0出队列，2，3，6进队列|6|1|1 2 3 6|2 3 6|0|
|1出队列，4进队列|4|1|2 3 6 4|2 3 4 6|0|
|发现1==tail，第0层已扩展结束|4|4|2 3 6 4|2 3 4 6|1|
|2出队列|4|4|3 6 4|2 3 4 6|1|
|3出队列|4|4|6 4|2 3 4 6|1|
|6出队列|4|4|4|2 3 4 6|1|
|4出队列，5，7进队列|7|4|5 7|2 3 4 5 6 7|1|
|发现4==tail，第1层已扩展结束|7|7|5 7|2 3 4 5 6 7|2|
|到达第2层，结束||||||


##### 注意 BFS有可能扩展到起点和终点，即将起点和终点的点权置为q，但不论如何它们的点权应该为0，[参考](https://www.luogu.org/discuss/show/27571)

### 计算最短路

* 按点权计算，即(a, b)的边权为b的点权，(b, a)的边权为a的点权。

* 记录图时，不需要记录具体的边权，dijkstra时，假设对min_v扩展邻接点，邻接点设为adj_v，则min_v到adj_v的边权即adj_v的点权。

* 对于被占领的顶点不能被扩展

其余和普通dijkstra无区别。

## C++代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
using namespace std;

#define NO_VALUE -1
typedef long long LL;

class Escape {
public:
    Escape() {}
    ~Escape() {}

    //main中调用的函数
    void escape();
private:
    //dijkstra中优先队列使用的结构体
    struct Node {
        int v;
        LL dist;
        Node(int v, LL dist) : v(v), dist(dist) {}
    };
    struct cmp {
        bool operator () (Node& a, Node& b) {
            return a.dist > b.dist;
        }
    };

    //private成员函数
    void input(); //输入
    void bfs(); //计算危险城市
    LL dijkstra(); //计算最短路径
    void clear(); //释放内存

    //类变量
    int n, m, k, s;
    int p, q;
    int src, des;
    vector<int> *graph;
    int *cost_; //cost_[i]为城市i的费用，即点权
};

void Escape::escape() {
    input();
    bfs();
    printf("%lld", dijkstra());
    clear();
}

void Escape::input() {
    scanf("%d %d %d %d %d %d", &n, &m, &k, &s, &p, &q);
    src = 0, des = n - 1; //改为从0开始编号
    cost_ = new int[n];
    fill(cost_, cost_ + n, p);
    for (int i = 0, ci; i < k; i++) {
        scanf("%d", &ci);
        ci--; //改为从0开始编号
        cost_[ci] = NO_VALUE;
    }
    graph = new vector<int>[n];
    for (int i = 0, ai, bi; i < m; i++) {
        scanf("%d %d", &ai, &bi);
        ai--; bi--; //改为从0开始编号
        graph[ai].push_back(bi);
        graph[bi].push_back(ai);
    }
}

void Escape::bfs() {	
    //被占领城市周围s层内的城市为危险城市
    if (s <= 0) return;
    queue<int> que;
    bool *collected = new bool[n];
    fill(collected, collected + n, false);
    int last, tail; //last为当前最后一个进队列的，tail为上一层的最后一个
    for (int i = 0; i < n; i++) 
        if (cost_[i] == NO_VALUE) {
            //遍历所有被占领城市
            que.push(i);
            collected[i] = true;
            last = tail = i;
        }
    int level = 0; //当前记为0层
    while (!que.empty()) {
        int v = que.front();
        que.pop();
        for (int adj_v : graph[v]) 
            if (!collected[adj_v]) {
                collected[adj_v] = true;				
                que.push(adj_v);
                cost_[adj_v] = q; //记为危险城市
                last = adj_v; //更新最后入队的顶点
            }
        if (v == tail) { //若上一层的最后一个出队列了，则这一层结束
            if (++level >= s) { //层数增加
                while (!que.empty()) que.pop();
                break;
            }
            tail = last; //更新tail为本层最后一个，即last
        }
    }
    free(collected);
    cost_[src] = cost_[des] = 0;
}

LL Escape::dijkstra() {
    //dijkstra计算最短路径
    //这里(a, b)的费用即为b的费用，(b, a)的费用即为a的费用，即
    //(a, b)的边权为b的点权，(b, a)的边权为a的点权
    LL *dist = new LL[n];
    fill(dist, dist + n, NO_VALUE);
    bool *collected = new bool[n];
    fill(collected, collected + n, false);
    dist[src] = 0;
    priority_queue<Node, vector<Node>, cmp> que;
    que.push(Node(src, dist[src]));
    int min_v;
    LL tmp_dist;
    while (!que.empty()) {
        min_v = que.top().v;
        que.pop();
        if (collected[min_v]) continue;
        collected[min_v] = true;
        if (min_v == des) {
            while (!que.empty()) que.pop();
            break;
        }
        for (int adj_v : graph[min_v]) { //遍历邻接点
            if (!collected[adj_v] && cost_[adj_v] != NO_VALUE) {
                tmp_dist = dist[min_v] + cost_[adj_v]; //(min_v, adj_v) 的边权为 adj_v的点权即cost_[adj_v]
                if (tmp_dist < dist[adj_v] || dist[adj_v] == NO_VALUE) {
                    dist[adj_v] = tmp_dist;
                    que.push(Node(adj_v, tmp_dist));
                }
            }
        } //for adj_v
    } //while
    LL result = dist[des];
    free(dist);
    free(collected);
    return result;
}

void Escape::clear() {
    free(cost_);
    for (int i = 0; i < n; i++)
        vector<int>().swap(graph[i]);
}

int main() {
    Escape escape;
    escape.escape();
    return 0;
}
```






---

## 作者：Numenor (赞：1)

# 虚拟点bfs+dijkstra

挺水的一道题，提交的时候慌得一批，结果一遍就过了，开心:-）

## 我们以0为起点，向每一个感染点连一条单向边，然后跑bfs，用safe数组染色。

### safe==0，未感染
### safe==1，感染
### safe==-1，传染源
### 跑bfs，如果u为0，就直接让v入队（因为此时v一定是传染源，然后safe相当于判重数组，限定dis<s，很容易地就写出了bfs，然后就从1开始跑最短路）
#### TIPS：要开long long，inf要开很大，注意最后dist[n]要减去多加的费用（1，n两点不收费，而跑最短路时n肯定是收费的）

##### 直接上code吧：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
typedef long long LL;
const LL inf=9999999999999;
const int N=100010;
const int M=200010;
struct node
{
	int next,to;
}g[M*4];
int head[N],cnt;

int n,m,k,s,P,Q;
int safe[N];
int e[N];
LL dist[N];
bool vis[N];

inline void addedge(int u,int v)
{
	g[++cnt].next=head[u];
	g[cnt].to=v;
	head[u]=cnt;
}

void bfs()
{
	queue<LL>q,qs;
	q.push(0);
	qs.push(-1);
	while(!q.empty())
	{
		int u=q.front(),d=qs.front();
		q.pop();qs.pop();
		for(int i=head[u];i;i=g[i].next)
		{
			int v=g[i].to;
			if(u==0){q.push(v);qs.push(0);}
			if(d<s&&!safe[v])
			{
				safe[v]=1;
				q.push(v);qs.push(d+1);
			}
		}
	}
}

void dijkstra()
{
	priority_queue<pair<LL,LL> >q;
	q.push(make_pair(0,1));
	for(int i=1;i<=n;i++)
	{
		dist[i]=inf;vis[i]=0;
	}
	dist[1]=0;
	while(!q.empty())
	{
		int u=q.top().second;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=g[i].next)
		{
			int v=g[i].to;
			if(safe[v]==1)
			{
				if(dist[v]>dist[u]+Q)
				{
					dist[v]=dist[u]+Q;
					q.push(make_pair(-dist[v],v));
				}
			}if(!safe[v])
			{
				if(dist[v]>dist[u]+P)
				{
					dist[v]=dist[u]+P;
					q.push(make_pair(-dist[v],v));
				}
			}
		}
	}
	if(safe[n]==0)dist[n]-=P;
	else dist[n]-=Q;
	cout<<dist[n];
}

int main()
{
	scanf("%d%d%d%d",&n,&m,&k,&s);
	scanf("%d%d",&P,&Q);
	for(int i=1;i<=k;i++)
	{
		scanf("%d",&e[i]);
		addedge(0,e[i]);
		safe[e[i]]=-1;
	}
	for(int i=1;i<=m;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		addedge(a,b);addedge(b,a);
	}
	bfs();
	//for(int i=1;i<=n;i++)cout<<safe[i]<<" ";cout<<endl;
	dijkstra();
}
	
```


---

## 作者：Euplectella (赞：1)

   
   kkk 口中的模板题，当我一直在wa的时候一直在想这题怎么会是模板题？？？但做完发现确实是模板题，，，
   
   这道题，告诉了我这种只会模板的蒟蒻求最短路时，bfs在所需要的节点比较少时（距离比较短时）或许是个很好的选择。
   
   首先，先说下自己的思路，我一开始想的是对每一个感染城市跑spfa找危险城市，最后再跑一遍对全图的spfa，然而只有28分，t两个点（6,7），wa了三个点（2,3,4）；

28分代码：
   ```cpp
#include<iostream>
#include<cstdio> 
#include<algorithm>
#include<cstring>
#include<queue> 
using namespace std;
inline int read(){
    int x = 0;int f = 1;char c = getchar();
    while(c<'0'||c>'9'){
        if(c == '-')f = -f;
        c = getchar();
    }
    while(c<='9'&&c>='0'){
        x = x*10 + c - '0';
        c = getchar();
    } 
    return x*f;
}
const int maxn = 2002000;
const int inf = 2147483647;
int cnt,p,q,n,m,k,s;
int x[maxn],y[maxn],val[maxn],vis[maxn],c[maxn],head[maxn*2];
long long dis[maxn];
struct edge{
    int from,to,v;
}e[maxn];
void add(int a,int b,int c){
    cnt++;
    e[cnt].from = head[a];
    e[cnt].to = b;
    e[cnt].v = c;
    head[a] = cnt; 
} 
void spfa(int start){
    for(int i = 1; i<=n; i++)dis[i] = inf;
    memset(vis,0,sizeof(vis));
    queue<int>que;
    que.push(start);
    dis[start] = 0;
    vis[start] = 1;
    while(!que.empty()){
        int f = que.front();que.pop();
        vis[f] = 0;
        for(int i = head[f] ; i ;i = e[i].from){
            int u = e[i].to;
            if(dis[u] > dis[f] + e[i].v){
                dis[u] = dis[f] + e[i].v;
                if(!vis[u]){
                    vis[u] = 1;
                    que.push(u);
                }
 			}
        }
    } 
}
int main(){
    n = read();m = read();k = read();s = read();
    p = read();q = read();
    for(int i = 1; i<=k; i++)c[i] = read();
    for(int i = 1; i<=m; i++){
      	int a,b;
      	x[i] = read(); y[i] = read();
      	add(x[i],y[i],1);
      	add(y[i],x[i],1);
    }
    for(int i = 1; i<=n; i++)val[i] = p;
    for(int i = 1; i<=k; i++){
        spfa(c[i]);
        for(int i = 1; i<=n; i ++){
            if(dis[i] <= s)val[i] = q;
        } 
    }//	for(int i = 1; i<=n; i++)cout<<dis[i]<<' '; 
    val[1] = 0;val[n] = 0;
    memset(e,0,sizeof(e));
    memset(head,0,sizeof(head));
    for(int i = 1; i<=m; i++){
        add(x[i],y[i],val[y[i]]);
        add(y[i],x[i],val[x[i]]);
    }
    //cout<<dis[n]<<' ';

    spfa(1);
    printf("%lld",dis[n]);
    
    
    return 0;
}
```
      
   其实很容易就发现对于全图的spfa是很浪费的当距离超过s完全就可以停止，所以我们基于spfa的思想对所有僵尸控制的城市进行bfs对在s距离内的城市进行标记，bfs结束后，对边权进行赋值，一条边的权值为这条边所指向城市的旅店所需花费，（**所以这里需要注意当指向城市为n时需要跳过**），最后一遍最短路即可求出所需花费，但在这里需要注意两点！！！
   
 **  1 ：开long long**
 
** 2:dis 最大值因为会爆int的缘故所以不能用2147483647！！！**

贴代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue> 
#include<cstring>
#define inf 31147483647//因为会爆int所以所求的值会超过214748367，所以一定要比2147483647大
#define ll long long
using namespace std;
inline int read(){
    int x = 0;int f = 1;char c = getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c<='9'&&c>='0'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int maxn = 5000000;
int cnt,n,m,k,ans,s,p,q;
queue<int>que;
struct edge{
    int from,to,v;
}e[maxn];
ll dis[maxn];
int head[maxn],vis[maxn],flag[maxn];
void add(int a,int b){
    cnt++;
    e[cnt].from = head[a];
    e[cnt].to = b;
    head[a] = cnt;
}
void spfa(){
    memset(vis,0,sizeof(vis));
    for(int i = 1; i<=n; i++)dis[i] = inf;
    que.push(1);
    dis[1] = 0;
    vis[1] = 1;
    while(!que.empty()){
        int f = que.front();que.pop();
        vis[f] = 0;
        for(int i = head[f] ; i ; i =e[i].from){
            int u = e[i].to;
            if(dis[u] > dis[f] + e[i].v){
                dis[u] = dis[f] + e[i].v;
                if(!vis[u]){
                    vis[u] = 1;
                    que.push(u);
                }
            }
        } 
    } 
}
int main(){
    n = read(); m = read(); k = read(); s = read(); p = read(); q = read();
    for(int i = 1; i<=k; i++){
        int a;
        a = read();
        flag[a]++;//标记僵尸控制的城市
        que.push(a);
    }
     for(int i = 1; i<=m; i++){
     	int a,b;
     	a = read();
     	b = read();
     	add(a,b);
     	add(b,a);
     } 
     //bfs求危险城市
    while(!que.empty()){
        int f = que.front();que.pop();
        if(dis[f] == s)continue;
        for(int i = head[f] ; i ; i = e[i].from){
            if(dis[e[i].to] == 0){
            dis[e[i].to] = dis[f] + 1;
            que.push(e[i].to);	
            }
        }
    }  
   //对边权赋值
    for(int i = 1; i<=cnt; i++){
    	if(e[i].to == n)continue;//终点不包括在内的原因所以跳过
        //如果是被僵尸控制的城市把边权赋值成一个极大值保证这条边不会出现在最后所求的路径里
    	if(flag[e[i].to]){
    		e[i].v = inf;
    		continue;
    	}
        //如果是危险城市赋值成q否则复制成p
        if(dis[e[i].to])e[i].v =q;
        else e[i].v = p;
    }
    spfa();
    printf("%lld",dis[n]);  
    return 0;
}


```
完结

[蒟蒻的博客](https://www.cnblogs.com/Euplectella/)


---

## 作者：Steinway (赞：1)

qwqq惊了 本来以为顶天57上不去了 结果改了一个地方一下就A了

其实kkk已经说的很清楚了（说出来之后再写跟写模拟一样）

其实下面的dalao说的已经很清楚 我这里只是补充而已

（其实写出来才发现代码的思想和下面某个dalao的很像）

（不过这位dalao的代码有些地方在我看来就是神仙代码qwqq）

于是 我就来贴一下我的代码吧...

~~可读性应该是保证了..~~

```
//#define fre yes

#include <queue>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

//反正不过1kw随便怎么开都可以...
const int maxn = 400005;
long long cur[maxn];
int date[maxn];
bool Use[maxn];
int arr[maxn];

int head[maxn];
int ver[maxn];
int to[maxn];

long long d[maxn];
int inq[maxn];

int n,m,k,s,tot;
int P,Q;

//毒瘤快读
template<typename T>inline void read(T&x)
{
    x = 0;char c;int lenp = 1;
    do { c = getchar();if(c == '-') lenp = -1; } while(!isdigit(c));
    do { x = x * 10 + c - '0';c = getchar(); } while(isdigit(c));
    x *= lenp;
}

//bfs找危险的城市
void bfs()
{
    memset(date,0,sizeof(date));

    queue<int> q;
    for (int i=1;i<=k;i++)
    {
        q.push(arr[i]);
        Use[arr[i]] = 1;
        date[arr[i]] = 0;
    }
    
    while(!q.empty())
    {
        int now = q.front();q.pop();
        if(date[now] == s) continue;
        for (int i=head[now];~i;i=to[i])
        {
            int v = ver[i];
            if(!Use[v]) 
            { 
                Use[v] = 1;
                q.push(v);
                date[v] = date[now] + 1; 
            }
        }
    }
}

//领接表存图
void addedge(int x,int y)
{
    ver[tot] = y;
    to[tot] = head[x];
    head[x] = tot++;
}

//spfa跑最短路
//这里的思想是两个城市的点权值相加 最后我们输出的时候/2就可以了
void spfa(int x)
{
    queue<int> q;
    
    q.push(x);
    inq[x] = 1;d[x] = 0;
    while(!q.empty())
    {
        int now = q.front();q.pop();inq[now] = 0;
        for (int i=head[now];~i;i=to[i])
        {
            int v = ver[i];
            if(d[v] > d[now] + cur[v] + cur[now])
            {
                d[v] = d[now] + cur[v] + cur[now];
                if(inq[v]) continue;
                inq[v] = 1;
                q.push(v);
            }
        }
    }
}

int main()
{
    memset(head,-1,sizeof(head));
    memset(d,0x3f,sizeof(d));

    read(n);read(m);read(k);read(s);
    read(P);read(Q);

    for (int i=1;i<=k;i++)
    {
        int x;
        read(x);
        arr[i] = x;
    }

    for (int i=1;i<=m;i++)
    {
        int x,y;
        read(x);read(y);
        addedge(x,y);
        addedge(y,x);
    }

    bfs();
    for (int i=1;i<=n;i++)
    {
        if(Use[i] == 1) cur[i] = Q;
        else cur[i] = P;
    }
	
    //WA了几遍 重新读了下题 发现不能走已经沦陷的城市..
    //手推了一下 感觉的确要改 于是改完之后瑟瑟发抖的点了提交
    //结果..A了
    for (int i=1;i<=k;i++) cur[arr[i]] = 10000000; 
	
    //第一个城市和最后一个城市不用住店
    cur[1] = cur[n] = 0;
    
    //从1开始spfa
    spfa(1);
    
    //输出答案的一半
    printf("%lld\n",d[n]/2);
    return 0;
}
```

---

## 作者：不存在之人 (赞：1)

解题思路：我们先跑一遍BFS，求出哪些是危险城市，然后记录每个城市的路费（貌似int会爆，我用long long，把被占领城市设为0x1111111111111111LL），跑SPFA。

但是是点权怎么办？我们可以每条边的边权设为连接的两个点的点权，然后最后的答案除以2即可。

C++ Code：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#define C c=getchar()
int n,m,k,s;
long long P,Q,dis[100005],ans[100005];
int head[400005],nxt[400005],to[400005],cnt,q1[200001],q2[200001],l,r;
bool vis[100005];
inline int readint(){
    char C;
    while(!isdigit(c))C;
    int p=0;
    while(isdigit(c))p=(p<<3)+(p<<1)+(c^'0'),C;
    return p;
}
void bfs(){
    memset(q2,0,sizeof(q2));
    while(l!=r){
        int u=q1[l=l%200000+1];
        int now=q2[l]+1;
        if(now<=s)
        for(int i=head[u];i;i=nxt[i]){
            int v=to[i];
            if(dis[v]==-1){
                dis[v]=Q;
                q1[r=r%200000+1]=v;
                q2[r]=now;
            }
        }
    }
    for(int i=1;i<=n;++i)
    if(dis[i]==-1)dis[i]=P;
}
void spfa(){
    memset(q1,0,sizeof q1);
    memset(vis,0,sizeof(vis));
    l=0,vis[1]=q1[1]=r=1;
    memset(ans,0x11,sizeof ans);
    ans[1]=0;
    while(l!=r){
        int u=q1[l=l%200000+1];
        for(int i=head[u];i;i=nxt[i]){
            int v=to[i];
            if(ans[v]>ans[u]+dis[u]+dis[v]){
                ans[v]=ans[u]+dis[u]+dis[v];
                if(!vis[v]){
                    vis[v]=1;
                    q1[r=r%200000+1]=v;
                }
            }
        }
        vis[u]=0;
    }
}
int main(){
    n=readint(),m=readint(),k=readint(),s=readint();
    P=readint(),Q=readint();
    memset(dis,-1,sizeof(dis));
    dis[1]=dis[n]=0;
    l=r=0;
    while(k--){
        int x=readint();
        dis[x]=0x1111111111111111LL;
        q1[++r]=x;
    }
    cnt=0;
    while(m--){
        int x=readint(),y=readint();
        to[++cnt]=y;
        nxt[cnt]=head[x];
        head[x]=cnt;
        to[++cnt]=x;
        nxt[cnt]=head[y];
        head[y]=cnt;
    }
    bfs();
    spfa();
    printf("%lld\n",ans[n]/2);
}
```

---

## 作者：Celebrate (赞：1)

我感觉这一题是模版题，但是我却没有做过。。。。。。

我使用了最短路的SPFA算法

我的方法可能没有dalao们的那么好：

（1）把每一个被僵尸控制的城市放进队列里面搜索，找出危险城市

（2）搜索每一条边，给每一条边赋值，因为一开始边是没有值得

（3）也是最后一步，我们前面把边都找好了，总的来说前面的都是

为了找边的值。我们把1放进队列里面，然后开始搜索，最后输出就好了。

注意事项：

（1）  1和n不用住宿；

（2）占领区不可以去，也不可以更新其他值；

（3）long long，100000^2   >      2^64-1,如果不用long long则会在第4个点出现错误

数组定义：

list 表示搜索时的队列

Occupied 表示被僵尸占领的点

can[x] 表示点x是否能走（true为能走)

danger[x] 表示x是否为危险区域(true为危险）

v[x]表示x是否能搜索（true表示能）

d[x]表示1到x的最小费用(和DP有点儿像）

下面是我的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#define MAXN 100001
using namespace std;
typedef long long ll;
struct node
{
	int x,y,c,next;
}a[MAXN*4];
int len,last[MAXN];
inline void ins(int x,int y,int c)//SPFA算法的建边方式，不会的同学赶紧学一下 
{
	len++;
	a[len].x=x;a[len].y=y;a[len].c=c;
	a[len].next=last[x];last[x]=len;
}
int n,m,k,s,p,q;
int head,tail,list[MAXN],Occupied[MAXN];
bool can[MAXN],danger[MAXN],v[MAXN];
ll d[MAXN];
inline void Find_danger(int Zombie)//步骤（1） 
{
	int x,y,kk;
	memset(d,127,sizeof(d));d[Zombie]=0;//初始化 
	memset(v,true,sizeof(v));v[Zombie]=false;
	head=1;tail=2;list[1]=Zombie;
	while(head!=tail)
	{
		x=list[head];
		for(kk=last[x];kk;kk=a[kk].next)
		{
			y=a[kk].y;
			if(d[y]>d[x]+ll(1))//搜寻最短边 
			{
				d[y]=d[x]+ll(1);//取最短边 
				if(d[y]<=s && v[y]==true)//如果长度超出了s，那就毫无意义了，而且浪费时间 
				{
					danger[y]=true;//在s距离以内的都是危险区域 
					v[y]=false;
					list[tail]=y;tail++;
					if(tail==n+1) tail=1;//这是一个优化，节省了不少的空间，而且避免了空间超限的情况 
				}
			}
		}
		v[x]=true;//记得把点x变得能走，因为以后可能会有别的来更新这个点 
		list[head]=0;//因为以后可能会继续使用这个，所以要为0 
		head++;if(head==n+1) head=1;//记得把head也增加，我以前经常犯这个错误 
	}
}
inline void Flee_Zombie_Island()
{
	int x,y,i;
	scanf("%d%d%d%d",&n,&m,&k,&s);
	scanf("%d%d",&p,&q);
	memset(can,true,sizeof(can));//初始化，一开始都是可以走的 
	for(i=1;i<=k;i++){scanf("%d",&Occupied[i]);can[Occupied[i]]=false;}//把被占领的区域标记为不能走 
	for(i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);//建立边 
		ins(x,y,0);ins(y,x,0);//一开始为0，这个不重要 
	}
	memset(danger,false,sizeof(danger));//一开始都不是危险区域 
	for(i=1;i<=k;i++) Find_danger(Occupied[i]);//搜索每一个被占领的点 
	for(i=1;i<=len;i++)//搜索每一条边 
	{
		if(can[a[i].x]==false || can[a[i].y]==false) continue;//如果起点或终点为危险区域，就跳过，因为它根本走不了 
		if(a[i].y==1 || a[i].y==n) continue;//注意事项（2）  
		if(danger[a[i].y]==false) a[i].c=p;//旅店的价钱 
		else					  a[i].c=q;
	}
	memset(d,127,sizeof(d));d[1]=0;//初始化，自己到自己本来就是为0 
	memset(v,true,sizeof(v));v[1]=false;//自己不能再走 
	head=1;tail=2;list[1]=1;//这里也是初始化 
	while(head!=tail)//搜索开始 
	{
		x=list[head];
		for(int k=last[x];k;k=a[k].next)//枚举每一条边与x有关联的边 
		{
			y=a[k].y;//这一条边的终点 
			if(can[y]==true)//而且这跳变能走 
			{
				if(d[y]>d[x]+ll(a[k].c))//取最优值 
				{
					d[y]=d[x]+ll(a[k].c);
					if(v[y]==true)//如果这个点目前没有存在这个数组里面，有就直接优化就行，不用继续搜了！ 
					{
						v[y]=false;//继续往下搜索 
						list[tail]=y;
						tail++;if(tail==n+1) tail=1;//这个和上面的一样 
					}
				}
			}
		}
		v[x]=true; 
		list[head]=0;
		head++;if(head==n+1) head=1;
	}
	printf("%lld\n",d[n]);//输出 
}
int main() {//特别舒服的主程序 
	Flee_Zombie_Island();return 0; 
}
```


---

## 作者：AndyXLaer (赞：1)

看到楼下那么多大佬发了 敌法师（dfs）的题解，但是没看到有 BFS 的
so。。本蒻就发一下la
想法很简单，BFS/DFS 预处理 出危险城市，然后预处理点权，SPFA的时候就拿ver[i]的点权去更新；
4个坑：
1. 1和n不用住宿；
2. 占领区不可以去，也不可以更新其他值；
3. long long 
4. BFS 更新的时候不要重复更新； 
and 贴代码：



------------
```cpp
#include<bits/stdc++.h>
using namespace std;
#define M  500000
#define INF 0x3f3f3f3f
int higher[M];
long long dis[M];
int vis[M],n,m,k,s,P,Q;
int head[M],nxt[M],ver[M],val[M],cnt=0;
void add(int x,int y){nxt[++cnt]=head[x],ver[cnt]=y,head[x]=cnt;return ;}
queue<int >tag;
void BFS(){
	while(tag.size()){
		int now=tag.front();tag.pop();
		for(int i=head[now];i;i=nxt[i]){
			if(!higher[ver[i]]){//如果已经的到deep 就不再管他，因为，，它就是会有危险，在更新没意义；
				higher[ver[i]]=higher[now]+1;
				tag.push(ver[i]);
			}
		}
	}
}
void spfa(int s){
	memset(dis,INF,sizeof(dis));dis[s]=0;vis[s]=1;
	queue<int >q;q.push(s);
	while(q.size()){
		int now=q.front();q.pop();vis[now]=0;
		for(int i=head[now];i;i=nxt[i]){
			if(vis[ver[i]]==2)continue;
			if(dis[ver[i]]>dis[now]+val[ver[i]]){
				dis[ver[i]]=dis[now]+val[ver[i]];
				if(!vis[ver[i]]){
					q.push(ver[i]);
					vis[ver[i]]=1;
				}
	}}}return ;
}
int main(){
	int x,y;
	scanf("%d%d%d%d",&n,&m,&k,&s);
	scanf("%d%d",&P,&Q);
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=k;i++){scanf("%d",&x);vis[x]=2;tag.push(x);}
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	BFS();
	for(int i=2;i<n;i++){//2 到 n 就好
		if(higher[i]<=s)val[i]=Q;
		else val[i]=P;
	}spfa(1); 
	printf("%lld\n",dis[n]);
} 
```

---

## 作者：shenyi1343395317 (赞：1)

没有pas的题解。我来一个

很裸的模板题呀.

主要思路：bfs出危险的城市，再修改边权，然后再求最短路.

采用邻接表存储图

本来是想离散优化一下路权，但是第4个测试点过不了，还是选择用int64/long long

```cpp
const max=maxlongint*999;       
  type node=record                     
       va:longint;  
       num:longint;
       end;    
  var head,next,h:array[0..400000] of longint;
      dis:array[0..1000000] of int64;
      e,v,w:array[0..1000000] of longint;
      book,inj,inf,bks:array[0..100000] of boolean;      
     //inj表示被感染的城市，inf表示危险城市，book是spfa的，bks是广搜里的
      que:array[0..1000000] of node;               //广搜队列，va表示节点，num表示节点层数
      i,j,m,n,s,p,q,c,k,tot,a1,b1,h1,t1,gc:longint;
  function gcd(m,n:longint):longint;            //辗转相除法做优化
  begin 
  if n<>0 then exit(gcd(n,m mod n))
   else exit(m);
  end;
  procedure ad(x,y:longint);         //对于x,y两个节点建立无向边
  begin
  if inj[y]=false then       //若是去的那个点(v[i]),是被感染的城市，那就不添加这条边
    begin                       //反之，则需添加
    inc(tot);                    //这样保证了不可能去被感染的城市
    e[tot]:=x;                  //也保证了危险城市的存在
    v[tot]:=y;
    next[tot]:=head[x];
    head[x]:=tot;
    end;
  if inj[x]=false then
    begin
    inc(tot);
    e[tot]:=y;
    v[tot]:=x;
    next[tot]:=head[y];
    head[y]:=tot;
    end;
  end;
  procedure bfs;               //广搜，采用循环队列，要不然空间上吃不消
  var pos:longint;            //和楼下说的一样，要用到spfa的思想，点在队列里就不搜
  begin
  while h1<t1 do
   begin
   if que[h1].num=s then exit;  //若已经是s层了，这要及时退出
   pos:=head[que[h1].va];
   while pos<>-1 do
    begin
     if bks[v[pos]]=false then
       begin
       bks[v[pos]]:=true;
       inf[v[pos]]:=true;
       que[t1].va:=v[pos];
       que[t1].num:=que[h1].num+1;
       t1:=t1 mod 1000000 +1;
       end;
     pos:=next[pos];
   end;
   bks[que[h1].va]:=false;       //出队时要置为false
   h1:=h1 mod 1000000+1;
   end;
  end;
  procedure spfa(x:longint);       //spfa求最短路，不作累述
  var i,j,pos,qh,t:longint;
  begin
  h[0]:=x;
  t:=1;
  qh:=0;
  book[1]:=true;
  while qh<t do
   begin
   pos:=head[h[qh]];
   while pos<>-1 do
    begin
    if dis[h[qh]]+w[pos]<dis[v[pos]] then
     begin
     dis[v[pos]]:=w[pos]+dis[h[qh]];
     if book[v[pos]]=false then
       begin
       book[v[pos]]:=true;
       h[t]:=v[pos];
       inc(t);
       end;
     end;
    pos:=next[pos];
   end;
   book[h[qh]]:=false;
   inc(qh);
   end;
  end;
  begin
  read(n,m,k,s,p,q);
  gc:=gcd(p,q);
  p:=p div gc;
  q:=q div gc;
  tot:=0;
  for i:=1 to k do
    begin
    readln(c);
    inj[c]:=true;
    end;
  for i:=1 to n do head[i]:=-1;
  for i:=1 to m do
   begin
   read(a1,b1);
   ad(a1,b1);
   end;
   h1:=0;
   t1:=0;
   for i:=1 to n do
    if inj[i] then
     begin
     que[t1].va:=i;
     inc(t1);
     end;           //在广搜之前要把已经被感染的城市入队
   bfs;
   for i:=1 to tot do
    begin
    if inf[v[i]] then w[i]:=q
      else w[i]:=p;
    if v[i]=n then w[i]:=0;   //第n点不要住店，则为0
    end;                  //广搜之后，按照是否安全给边赋值
   for i:=2 to n do dis[i]:=max;
   spfa(1);
   writeln(dis[n]*gc);
   readln;
end.
```

---

## 作者：YF1999 (赞：1)

第一次发题解……紧张……表示不太会用Markdown，希望没问题

这里提供一个优先队列优化dijkstra的解题代码

思路：先BFS出危险的城市，然后再搜最短路


因为邻接表vec建立的形式，我用了一个比较笨的方法来在BFS更改路权，详情见代码

然后路权设置为目标城市的费用，去安全城市就是safe，否则是danger

注意：目标城市N的路权全部为0

代码不是特别好，还有可以优化的地方

贴一下C++代码

```cpp
#include<iostream>
#include<vector>
#include<queue>
#define Max 20000000000
using namespace std;

struct edge{
    int to, distance;
};
vector<edge> vec1[100010];//用于BFS 
vector<edge> vec2[100010];//将颠倒的vec1反转回来 
edge e;

//dijstra优先队列优化 
typedef pair<int,int> P;
priority_queue< P, vector<P>, greater<P> > que;
P p;

queue<P> que_danger;//BFS危险城市 

long long int dis[100010], safe, danger;//safe表示安全城市费用，danger反之 
int N, M, K, S, from, to, distance;
bool sign[100010];//标记是否被侵占 

int main(){
    ios::sync_with_stdio(false);//输入输出优化 
    cin >> N >> M >> K >> S >> safe >> danger;
    //危险城市加入que_danger
    for( register int i = 1; i <= N; i ++ ) sign[i] = true;
    for( register int i = 0; i < K; i ++ ){
        cin >> from;
        sign[from] = false;//标记，dijkstra时不经过这个城市 
        que_danger.push( P(from,0) );
    }
    //建立vec1
    for( register int i = 1; i <= M; i ++ ){
        cin >> from >> to;
        e.to = to; e.distance = safe;
        vec1[from].push_back( e );
        e.to = from;
        vec1[to].push_back( e );
    }
    //危险城市BFS 
    while( que_danger.size() ){
        p = que_danger.front();
        que_danger.pop();
        if( p.second == S + 1 ) break;
        for( register int i = 0; i < vec1[p.first].size(); i ++ ){
            if( vec1[p.first][i].distance != danger ){
                vec1[p.first][i].distance = danger;//因为是出城路权改成danger，所以还要反转变为入城路权是danger 
                que_danger.push( P(vec1[p.first][i].to,p.second+1) );
            }
        }
    }
    //反转vec1成vec2 
    for( register int j, i = 1; i <= N; i ++ ){
        for( j = 0; j < vec1[i].size(); j ++ ){
            to = vec1[i][j].to;
            e.to = i;
            if( i == N ) e.distance = 0;//终点N城市入城路权为0 
            else e.distance = vec1[i][j].distance;
            vec2[to].push_back( e );
        }
    }
    //dijkstra
    for( register int i = 2; i <= N; i ++ ) dis[i] = Max;
    dis[1] = 0;
    que.push( P(1,0) );
    while( que.size() ){
        p = que.top();
        que.pop();
        if( p.second > dis[p.first] ) continue;
        from = p.first;
        for( register int i = 0; i < vec2[from].size(); i ++ ){
            e = vec2[from][i];
            if( dis[from] + e.distance < dis[e.to] && sign[e.to] ){
                dis[e.to] = dis[from] + e.distance;
                que.push( P(e.to,dis[e.to]) );
            }
        }
    }
    cout << dis[N];
    return 0;
}
```

---

## 作者：皮皮羊 (赞：1)

~~处女作题解~~
这道题可以先参考1144,用同样的方法先处理出危险村庄,将每个村庄的点权赋为村庄的住宿价格,再跑一个最短路旧行了,~~漂亮的代码~~```
```pascal
var
 l,r,u,v:longint;
 tow,next:array[0..1000001] of int64;
 head,c,cost,q,dis,d:array[0..100001] of int64;
 vis:array[0..100001] of boolean;
 i,j,n,m,k,s,pp,qq,x,y,cnt:longint;

procedure add(u,v:longint);
begin
 inc(cnt);
 tow[cnt]:=v;
 next[cnt]:=head[u];
 head[u]:=cnt;
end;//存图
begin
 readln(n,m,k,s);
 readln(pp,qq);
 for i:=1 to k do read(c[i]);
 for i:=1 to m do
  begin
   readln(x,y);
   add(x,y);
   add(y,x);
  end;
 fillchar(q,sizeof(q),0);
  fillchar(vis,sizeof(vis),false);
  fillchar(dis,sizeof(dis),$3f);
  l:=0;r:=k;
  for i:=1 to k do
   begin
    q[i]:=c[i];
    vis[c[i]]:=true;
    dis[c[i]]:=0;
   end;
  while l<r do
   begin
    inc(l);
    u:=q[l];
    i:=head[u];
    while i<>0 do
     begin
      v:=tow[i];
      if dis[v]>dis[u]+1 then
       begin
        dis[v]:=dis[u]+1;//村庄与僵尸村庄的距离
        if not vis[v] then
         begin
          vis[v]:=true;
          inc(r);
          q[r]:=v;
         end;
       end;
      i:=next[i];
     end;
    vis[u]:=false;
   end;
 //以上是和1144一样的保存距离,下面是SPFA
 for i:=1 to n do
  if dis[i]<=s then cost[i]:=qq
   else cost[i]:=pp;
 cost[1]:=0;cost[n]:=0;
 fillchar(q,sizeof(q),0);
  fillchar(vis,sizeof(vis),false);
  fillchar(d,sizeof(d),$3f);
  for i:=1 to k do d[c[i]]:=0;
  d[1]:=0;q[1]:=1;vis[1]:=true;
  l:=0;r:=1;
  while l<=r do
   begin
    inc(l);
    u:=q[l];
    i:=head[u];
    while i<>0 do
     begin
      v:=tow[i];
      if (d[v]>d[u]+cost[v])and(dis[v]<>0) then
       begin
        d[v]:=d[u]+cost[v];
        if not vis[v] then
         begin
          vis[v]:=true;
          inc(r);
          q[r]:=v;
         end;
       end;
      i:=next[i];
     end;
    vis[u]:=false;
   end;
 writeln(d[n]);
end.

```

---


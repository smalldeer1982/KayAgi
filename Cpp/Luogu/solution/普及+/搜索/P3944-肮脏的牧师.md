# 肮脏的牧师

## 题目背景

@Yumis 出题人在这里哦~


## 题目描述

Yumis最近在玩炉石传说。

在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。

还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。

还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。


你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。


现在你的对手场上有n个随从，每个随从的攻击力是ki点。

你的对手有m点血量。


而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。


## 说明/提示

样例说明1：

敌方场上有3只随从，敌方有5点血量

我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。


样例说明2：

使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）

拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！



Easy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%


Normal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%


Hard ：保证 0 < n <= 10                                                 30%


Extra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%


保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)


## 样例 #1

### 输入

```
3 5
1 2 3 
```

### 输出

```
0 5```

## 样例 #2

### 输入

```
8 8
10 20 30 40 50 60 70 80
```

### 输出

```
16 23```

## 样例 #3

### 输入

```
8 80
10 20 30 40 50 60 70 80
```

### 输出

```
Human Cannot Win Dog```

# 题解

## 作者：MTF_Lambda_04 (赞：15)

这里介绍一种和其他题解不太一样的方法，该方法与排序方式有很大关系。

先看题目，题目意思可以概括为以下意思：首先，有三种操作：第一，消耗 $1$ 点法力水晶把敌人攻击小于等于 $2$ 的随从拉过来；第二，耗 $4$ 点法力水晶，把敌人攻击小于等于 $3$ 的随从拉过来；第三，耗 $1$ 点法力水晶，把敌人随从攻击力全部下降 $3$ 点。

首先，大家可能都想得到贪心，由于题目中给定的数据并不保证有序，所以我们要进行排序；看了眼数据范围，五百万算是非常大了，看大家都用得桶排，但其实 sort 吸下氧还是可以过得，这里我采用 sort，具体原因看后面我的方法。

既然是贪心，那么我们就想要看是怎么个贪心法。前面所说的三种操作，我们一个一个看：当这个随从攻击力小于等于 $2$ 时，我们可选择第一和第二种，但显然选第一种更划算；当攻击力小于等于 $3$ 时，此时最优选择显然是第二种，但千万要注意等于 $3$ 时判断下 $m$ 是否已经小于 $0$ 了。

之后，对于拉完所有随从无法击败对手情况，我们可以在输入时就进行这么一个处理：每次输入，判断是否小于 $2$ 的，小于 $2$ 就加这个数本身，否则就按拉过来最大伤害 $3$ 来算，最后输入完成后判断一下，这部分代码：

```
for(int i=1;i<=n;i++){
     scanf("%d",&a[i]);
     if(a[i]>3){
	fgla+=3;
     }else{
	fgla+=a[i];
     }
}
if(fgla<m){
	printf("Human Cannot Win Dog\n");
}
```

好，那接下来我们就要开始处理最后第三种操作了，对于一个按从小到大的序列来讲，缩小一些数至指定数，后面需要的缩小药水数只会增加，不会减少，于是，我们由此可判断第三种操作是这几种中最不划算的一种，我们就最后不得不用时才采用它。

你可能以为完了，不！错掉 $2$ 个测试点告诉我们，这玩艺血量是很有可能扣为负的对吧，所以没记错的话就像第二个样例一样，我们每次弄完了就判断下，并返还一些不用，这时，就有一个问题摆在眼前。

问：是拉 $3$ 个 $1$ 攻随从便宜还是一个 $3$ 攻随从便宜？

大家都知道是 $3$ 个 $1$ 攻便宜，那么如果此时恰好超出 $3$ 攻击力，那么我们按贪心来看就该还回 $3$ 攻随从最优，于是我们就在三种操作结束后来进行还回，两个 for，第一个还完大于等于 $3$ 的，第二个还完小于 $3$ 的，切忌：两个 for 不能写在一起，试试就逝世。

最后，代码：

```
#include<bits/stdc++.h>
using namespace std;
long long int n,m;
const int N=5e6+5;
int a[N];
int fgla=0;
int need=0,number=0;//need缩小药水数,number法力水晶数 
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i]>3){
			fgla+=3;
		}else{
			fgla+=a[i];
		}
	}
	if(fgla<m){
		printf("Human Cannot Win Dog\n");
	}else{
		sort(a+1,a+n+1);
		for(int i=1;i<=n;i++){
			
			a[i]-=3*need;
			if(a[i]<=2){
				number++;
				m-=a[i];
			}else if(a[i]==3){
			if(m<=0){
				break;
			}
				number+=4;
				m-=a[i];
			}else if(a[i]>3){
			if(m<=0){
				break;
			}
				while(a[i]>3){
					number++;
					need++;
					a[i]-=3;
				}
				if(a[i]<=2){
					number++;
					m-=a[i];
				}else if(a[i]==3){
					number+=4;
					m-=a[i];
				}
			}
		}
		if(m<0){
			int k=0;
		    k=k-m;
			for(int j=1;j<=n;j++){
				if(a[j]<=k){
					if(a[j]==3){
						number-=4;
						k-=3;
					}
				}
			}
			for(int j=1;j<=n;j++){
				if(a[j]<=k){
					if(a[j]<=2){
						number--;
						k-=a[j];
					}
				}
			}
		}
		printf("%d %d\n",need,number);
	}
	return 0;
}
```

抄是会被棕名的！

---

## 作者：Yumis (赞：14)

T1题解

Easy和normal：随便搜索都可以过的啊这个不说了啊

Hard:你可以用先用sort排序一遍然后依次记录使用每一瓶缩小药水最大打多少然后再用Easy和normal的方式搜索这一层就够。

Extra：根据Hard的想法我们可以很清晰的得到我们是要搜索使用每一瓶缩小药水最大能打多少伤害，而且最大的伤害量也不大，那么可以用到一个很冷门的排序方式 桶排序  就是输入的时候直接把全部的数据读入然后用桶读入

接下去用for循环每次给i增加3计算到 i = 29998就可以

然后每丢一个缩小药水就计算一次如果攻击大于m则跳出循环 然后用3个while判断先把3攻的随从去掉 其次是1攻的最后是2攻的这样答案就很明显出来了。如果看不懂的话可以看代码。


//at1 at2 at3用来记录你拉了多少个可以造成多少伤害随从。

```cpp
//ans表示造成的伤害
//snum记录使用多少缩小药水
#include<cstdio>
int to[30010],snum = -1,at1,at2,at3,n,m,ans;
int main ()
{
    scanf("%d%d",&n,&m);
    for (int i = 1; i <= n; i ++)
    {
        int p;
        scanf("%d",&p);
        to[p] ++;
```
}//读入数据然后桶排
```cpp
    for (int i = 1; i+2 <= 30001; i +=3)
    {
        ans += to[i];     at1 += to[i];//桶内有多少个可以打出1点伤害的 
        ans += to[i+1]*2; at2 += to[i+1];//桶内有多少个可以打出2点伤害的
        ans += to[i+2]*3; at3 += to[i+2];//桶内有多少个可以打出3点伤害的
        snum ++;//多使用一瓶缩小药水  第一次进入的时候是不使用 
        if(ans >= m) break;//如果伤害大于则退出循环寻找 
    }
    while(ans >= m+3 && at3) {at3 --; ans -= 3;}//如果伤害溢出超过3点则先把3攻随从去掉 因为3攻需要用到4费显然是十分不值得 
    while(ans >= m+1 && at1) {at1 --; ans -= 1;}//其次是删除掉1点攻击力的，因为同样的耗费显然是2攻打得多 
    while(ans >= m+2 && at2) {at2 --; ans -= 2;}//最后才是把2费剔除掉。 
    if(ans >= m) printf("%d %d",snum,at1+at2+at3*4+snum);
    else printf("Human Cannot Win Dog");
}
```

---

## 作者：AirCnt (赞：7)

[AC 证明](https://www.luogu.com.cn/record/40383404)

~~莫名其妙地拿到了最优解~~

[题面](https://www.luogu.com.cn/problem/P3944)不好简化，自己看吧。

先考虑如何使缩小药水的数量最小。

首先，我们把攻击力在 $3$ 以内的随从全部拉过来，如果攻击力够了，那就不用缩小药水了。

否则，我们用一张缩小药水，此时我们能拉过来的随从攻击力范围扩展到 $6$ 以内。

还不行，我们再用一张，此时我们能拉过来的随从攻击力范围扩展到 $9$ 以内，以此类推。

如果把所有随从都拉过来了，攻击力还不够，则输出无解信息。

显然，这个贪心思路可以使缩小药水数量最少。

但是这还不够！我们还要令使用的法力水晶最少。

考虑一下我们把随从拉过来的过程。每用一张缩小药水，我们都把能拉的所有随从拉过来，显然，这里是有浪费的。所以，我们还要把随从还回去。

显然，攻击力为 $3$ 的随从性价比最低，攻击力为 $2$ 的随从性价比最高。所以我们先把攻击力为 $3$ 的随从还回去，然后是攻击力为 $1$ 的，最后是攻击力为 $2$ 的。

因为数据范围很小，枚举随从时可以使用桶排序。

加个 O2，随手一交，157ms，比第二名快66ms。

### AC Code

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <map>
#include <string>
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
using namespace std;
int a[30005],used[5],maxn=-100,sum=0,ans=0,cnt=0;
const int cost[5]={0,1,1,4};
inline int read() {
	int x=0;
	bool sign=false;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		sign=ch=='-';
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return sign?-x:x;
}
inline int clac(int x,const int num) {	//处理随从攻击力并计数
	x-=cnt*3;
	if(x>3) {
		int pre_x=x,new_cnt;
		x%=3;	//跟不停的减3直到结果到小于3是一样的
		x=x==0?3:x;	//若x==0，说明多减了，要加回去
		new_cnt=(pre_x-x)/3;	//计算需使用的缩小药水数量
		ans+=new_cnt;
		cnt+=new_cnt;
	}
	used[x]+=num;
	ans+=cost[x]*num;
	return x*num;
}
int main() {
	int in,n=read(),m=read();
	for(int i=1;i<=n;i++) {
		in=read();
		++a[in];	//桶排序
		maxn=max(maxn,in);
	}
	maxn=min(maxn,29998);	//如果数据上界超过了29998，就将上界改为29998，防止越界
	for(int i=1;i<=maxn&&sum<m;i+=3) {	//这里的for循环是计算到上界+2的
		if(a[i])
			sum+=clac(i,a[i]);
		if(a[i+1])
			sum+=clac(i+1,a[i+1]);
		if(a[i+2])
			sum+=clac(i+2,a[i+2]);
	}
	if(sum<m)
		return puts("Human Cannot Win Dog"),0;	//输出无解信息
	while(sum-3>=m&&used[3])
		--used[3],ans-=4,sum-=3;	//把多余的减掉
	while(sum-1>=m&&used[1])
		--used[1],--ans,--sum;
	while(sum-2>=m&&used[2])
		--used[2],--ans,sum-=2;
	printf("%d %d",cnt,ans);
	return 0;
}
```


---

## 作者：Guess00 (赞：6)

### 思路:排序

先排序，不难发现，要使得「缩小药水」数最小，你只需要从小到大拉过来就行了。于是从小到大扫一遍，可以拉就拉，不能就用「缩小药水」再拉，直到攻击力总和大于对手血量。

如果你认为就这样就行了，那么恭喜，你会惊奇地发现你连样例1都过不去。就样例1而言，如果你按如上方法，你会同时选了`1`,`2`,`3`,输出结果(最小费用)是`6`,可是其中无需选`1`,也就是说，按上述方式选好后，还得"还"一些回去。

下面考虑究竟"还"哪些回去。观察得，每次可以拉一个攻击小于等于3的，每次「缩小药水」也是降低3点，可以发现其实只要讨论模3之后的3种情况。要使费用最小，就要使"还"回去的费用大。
1. 先看`3`,"还"一个`3`回去可减少4费，同时减少3点攻击；如果"还"一个`1`和一个`2`,减少的攻击还是3点，可是却只减少2费，可得先尽可能(不能让总和小于$\texttt{m}$)把`3`"还"回去。
2. 再看`1`和`2`,"还"2个`1`或1个`2`都减少2点攻击，但前者减少2费而后者只减少1费，所以优先"还"`1`,最后"还"`2`。

最后说一下关于排序的事$:$
1. 如果你比较懒，排序可以直接用$\operatorname{sort}$,但记得开O2.
2. 如果你不懒，你可以写桶排序(其实也没几行)，因为`0<ki<=30000`.

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
const int MAXN=5000005;
int n,m,i,j,k=3,x,y,a[MAXN],b[MAXN];
//x是「缩小药水」数量,y是最小费用,b是用来桶排序的 
inline void read(int &x)   //快读 
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
    	if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)   //快输 
{
    if (x<0)
        putchar('-'),x=-x;
    if (x>9)
        print(x/10);
    putchar(x%10+'0');
}
signed main(void)
{
	read(n),read(m);
	for (i=1;i<=n;i++)
		read(a[i]),b[a[i]]++;
	for (i=1;i<=30000;i++)   //桶排序 
		while (b[i])
			a[++j]=i,b[i]--;
	for (i=1;i<=n;i++)
	{
		bool f=false;
		while (a[i]>k)    //不得不使用「缩小药水」时 
		{
			if (m<=0) //尽量发挥「缩小药水」的效果,在一次结束时在退出而不是在m一旦小于等于0时就退出 
			{
				f=true;
				break;
			}
			x++,y++,k+=3;   //使用一次「缩小药水」
		}
		if (f)
			break;
		y+=(a[i]<k)?1:4;    //判断一下是1费还是4费 
		m-=(a[i]%3)?(a[i]%3):3;    //这里采用的是直接从m上扣 
	}
	if (m>0)   //拉了所有随从还是A不暴它 
		return printf("Human Cannot Win Dog"),0;
	for (i=1;i<=n && m<0;i++)
		if (a[i]%3==0 && a[i]<=k && m+3<=0)
			y-=4,m+=3;
	for (i=1;i<=n && m<0;i++)
		if (a[i]%3==1 && a[i]<=k && m+1<=0)
			y-=1,m+=1;
	for (i=1;i<=n && m<0;i++)
		if (a[i]%3==2 && a[i]<=k && m+2<=0)
			y-=1,m+=2;
	//先3,再2,最后1
	print(x),putchar(' '),print(y);
	return 0;
} 
```

---

## 作者：jiangyanheng (赞：3)

~~感觉这道题的难点其实在于排序~~

贪心的思路比较简单。

每个随从能使用的攻击只有1、2或3，所以cnt记录三种随从各有多少个

要求使用最少的降低药水，所以从低到高扫一遍所有随从，刚好干爆的时候一定使用最少的降低药水（ans1已求得，接下来求ans2）

拉2的随从最划算，其次是1，最后是3，于是我的初始思路就是依次用2、1、3，用到干爆为止

但是样例1直接否定了这种方法

仔细一想，样例1用3攻击的随从的时候还有1，但是已经没有2了

于是更改思路：使用次序仍然是2、1、3。但是当2、1中任意一个已经用完，而只用另一个并不能干爆，就用一个3
（这个思路其实是我瞎猜出来的）

当2、1都有的时候当然不用3（因为在这道题里2+1优于3）；

当2、1只剩一种且干不爆的时候，一定需要用3来补，又有（攻击力）3>2>1（~~废话~~），所以这种情况下选3能多干一点（~~有效防止部分后面再选3的情况~~）（本蒟蒻语文不好，具体可以感受一下样例1）

开心的提交，90，[T掉最后一个点](https://www.luogu.com.cn/record/33231182)（用的stable_sort)

果断换经典的sort，没好哪去

尝试手打蒟蒻版基数排序，虽然[倒数第二个快了100ms](https://www.luogu.com.cn/record/33231832)，最后一个还是T（~~而且空间瞬间变得巨大~~）

百思不得其解，算法标签发泄。桶排映入眼帘，修改代码去耶。(当初没看到a\[i\]<=3e4)

上代码（蒟蒻版）
```
//策略：优先使用2，其次使用1；如果单独1或2(另外一个已经用完)都不够打怪，就用一个3
//天哪，这道题的最大难点在于排序
//sort、stable_sort、手打基数排序都试过了，就是T最后一个点
//打开算法标签，咦？桶排？
//果断打一个传统的桶排，跑的贼快
//心情久久不能平静…… 
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue> 
using namespace std;
const int N=5000000+101009;
int num[N];
int n,m,ans1,ans2;
int cnt[4];
int ans=0;
int read(){
	int f=0,t=1;char ch=getchar();
	while(ch<'0' || ch>'9'){if (ch=='-') t=-1;ch=getchar();}
	while('0'<=ch && ch<='9'){f=f*10+ch-'0';ch=getchar();}
	return f*t;
}
const int M=30001;
int buc[M];
void bucket_sort(){
	for(int i=1;i<=n;i++) buc[num[i]]++;
	n=0;
	for(int i=1;i<=30000;i++) while(buc[i]--) num[++n]=i; 
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++) num[i]=read();
	bucket_sort();
	int tmppow=0,use=0,po=1;
	while(tmppow<m && po<=n){		 //累加，直到刚好干爆为止 
		while(num[po]-3*use>3) use++;//如果当前随从拉不过来，就多用一个药水试试 
		int tmp=num[po]-3*use;		 //随从拉过来后的攻击力 
		tmppow+=tmp;				 //累加 
		cnt[tmp]++;					 //处理每种随从的数量 
		po++;
	}
	if (po==n+1 && tmppow<m){
		printf("Human Cannot Win Dog");
		return 0;
	}
	while(num[po]-3*use<=3){  //上一个while只是找到了最少需要多少降低药水 
		int tmp=num[po]-3*use;//然而最后一个药水用完后还可能有没算上的随从 
		cnt[tmp]++;
		po++;
	}
	ans1=use;tmppow=0;		  //重置当前攻击力，为贪心做准备 
	while(tmppow<m){
		if (cnt[2]){		  //有2 
			if (!cnt[1] && tmppow+cnt[2]*2<m){
							  //但是没有1了 
				tmppow+=3;    //那就用3 
				cnt[3]--; 
				ans2+=4;
				continue;
			}
			tmppow+=2;
			cnt[2]--;
			ans2+=1;
			continue;
		}
		if (cnt[1]){		  //其他同理 
			if (!cnt[2] && tmppow+cnt[1]<m){
				tmppow+=3;
				cnt[3]--;
				ans2+=4;
				continue;
			}
			tmppow++;
			cnt[1]--;
			ans2++;
			continue;
		}
		if (cnt[3]){
			tmppow+=3;
			cnt[3]--;
			ans2+=4;
			continue;
		}
	}
	printf("%d %d",ans1,ans2+ans1);//注意降低药水也是一费的 
}
```
大佬轻喷

---

## 作者：dingzj2022 (赞：1)

题面过长，请移步[题面](https://www.luogu.com.cn/problem/P3944)
## 思路：
先按题意将题目翻译成 C++ 语言，然后再模拟三张卡片，但是要有先后顺序：疯狂药水，再暗影狂乱，最后缩小药水。
## 代码：
```cpp
//炉石传说：） 
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int cnt[N],an,ans[10],n,m,res,x;
int main(){
	cin>>n>>m; 
	for(int i=1;i<=n;i++){
		cin>>x;
		cnt[x]++;
	}
	for(int i=1;i<30001;i+=3){
		res+=cnt[i];
		ans[1]+=cnt[i];
		res+=cnt[i+1]*2;
		ans[2]+=cnt[i+1];
		res+=cnt[i+2]*3;
		ans[3]+=cnt[i+2];
		an++;
		if(res>=m) break;
	}
	//药水 
	while(res>=m+3 && ans[3]){//因为一次减三，所以三次一组 
		ans[3]--;
		res-=3;
	}
	//暗影狂乱 
	while(res>=m+1 && ans[1]){
		ans[1]--;
		res-=1;
	}
	//缩小药水 
	while(res>=m+2 && ans[2]){
		ans[2]--;
		res-=2;
	}
	if(res>=m){
		cout<<an-1<<" "<<ans[1]+ans[2]+ans[3]*4+an-1;
		return 0;
	}
	cout<<"Human Cannot Win Dog";
	return 0;
}
```
勿抄代码！

---

## 作者：syf2008 (赞：1)

这是一道非常经(~~du~~)典(~~liu~~)的模拟大水(~~nan~~)题

思路：

1. **最少使用的缩小药水的数量**，故我们要排序缩小药水的数量
1. **最少使用的法力水晶**，要用贪心去做
1. **否则输出“Human Cannot Win Dog”**，这个指每个ki%3的值的和<m 

上代码
```
#include <bits/stdc++.h>
using namespace std;
int k=3,n,m,s,a[5000005],b[30005],suo,fei;
bool flag;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		b[a[i]]++;
	}
	for(int i=1;i<=30000;i++)
	while(b[i])
	{
		a[++s]=i;
		b[i]--;
	}//用桶排减少时间
	for(int i=1;i<=n;i++)
	{
		while(a[i]>k)
		{
			if(m<=0)
			{
				flag=1;
				break;
			}
			suo++,fei++,k+=3;//找出缩小药水的数量
		}
		if(flag)
		break;
		if(a[i]<k)
		fei++;
	else fei+=4;
		if(a[i]%3)
		m-=a[i]%3;
	else m-=3;
	}
	if(m>0)
	{
		puts("Human Cannot Win Dog");
		return 0;
	}
	for(int i=1;i<=n&&m<0;i++)
	if(a[i]%3==0&&a[i]<=k&&m+3<=0)
	{
		fei-=4;
		m+=3;
	}
	for(int i=1;i<=n&&m<0;i++)
	if(a[i]%3==1&&a[i]<=k&&m+1<=0)
	{
		fei--;
		m++;
	}
	for(int i=1;i<=n&&m<0;i++)
	if(a[i]%3==2&&a[i]<=k&&m+2<=0)
	{
		fei--;
		m+=2;
	}//返还，减少消耗
	cout<<suo<<' '<<fei<<endl;
}
```

---

## 作者：KerwinHazlitt (赞：1)

上边那个发错了个地方= =


尴尬……



dalao们求放过= =

这才是正解……



Easy和Normal：这个直接搜索就好了= =

Hard：暴力模就可以过，就不做过多解释了，具体可以看代码0 0


Extra：这个跳度有点大啊= =直接从10跳到了500,000。。作为一个在最后30%数据T了半天的菜鸡，我可以保证O(n^2)是过不了的= =那么正解呢，正如神犇所说是桶排（which，只有O(n)，明明很好用啊）之后就是单纯的模拟了，楼上用的倒序，我走的正序，可能会好理解一些（只有过程，不包括数= =，数我调了半天=。=）


不多说了，上代码上代码


```cpp
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<iostream>
#include<iomanip>
#include<algorithm>
using namespace std;
int i,j,atk[30010],n,m,num1,num2,num3,mas,at;//num1,2,3分别是己方攻击力为1,2,3的随从数量，atk[i]是桶排用的；
bool atkb[30010];//这是优化的一部分，一会儿再说吧= =
int read()//读入优化
{
    char s=getchar();
    int w=1,x=0;
    while(s<'0'||s>'9'){
        if(s=='-')    w=-1;
        s=getchar();
    }
    while(s>='0'&&s<='9'){
        x=x*10+s-'0';
        s=getchar();
    }
    return x*w;
}
int main()
{
    n=read();
    m=read();
    for(i=1;i<=n;i++)//桶排
    {
        at=read();//输入第i个随从的攻击并记录攻击为at的随从个数
        atk[at]++;
        atkb[at]=true;//后期优化一部分
        mas=max(at,mas);//统计最大值（可忽略）
    }
    for(i=1;i<=mas+2;i+=3)//枚举攻击从i到mas的，mas+2能保证能for到mas（因为i不是++，而是+=3，i+=3的话能保证每一次for都是在使用一次减小药剂的情况下进行的）
    {
//先改num1,num2,num3;
        if(atkb[i]==true)
        {
            num1+=atk[i];
        }
        if(atkb[i+1]==true)
        {
            num2+=atk[i+1];
        }
        if(atkb[i+2]==true)
        {
            num3+=atk[i+2];
        }
//于是开始判断，会有些麻烦（比楼上会麻烦一些），本菜米调了大半天几乎把心态调崩了= =
        if(num2*2>=m)//首先判断2的，因为2的性价比最高
        {
            printf("%d %d",(i-1)/3,(int)(m/2+1/2)+(i-1)/3);//加减1/2之类的都是向上或下取整的优化，不会的可以手写试验一下
            return 0;
        }
        else{
            if(num2*2+num1>=m)//然后加上1的
            {
                printf("%d %d",(i-1)/3,num2+m-2*num2+(i-1)/3);
                return 0;
            }
            else
            if(num2*2+num1+num3*3>=m)//再加上3的，有了3就需要特判了，接下来会很迷，做好准备，前方高能
            {
                if((m-num2*2-num1)%3!=0){
                    if((m-num2*2-num1)%3<=num1||m-num2*2-num3*3>=0){//当1的能补齐使其凑一个三的倍数时
                        printf("%d %d",(i-1)/3,num1+num2+(i-1)/3+((m-num2*2-num1)/3+1)*4-3+(m-num2*2-num1)%3);
                        return 0;
                    }//num1，num2耗的费直接加，然后加上所需要的3的，减去多余的1；
                    else
                    {//1的数目不够时
                        printf("%d %d",(i-1)/3,num2+(i-1)/3+((m-num2*2-num1)/3+1)*4-(3-(m-num2*2-num1)%3-num1+1)%2);
                        return 0;
```
}//只能去掉多余的2（这个东西有毒= =，我自己编的数据过不了，这题居然a了= =）所以申请加条数据：in:{3 5 2 2 3}out:{0 5}

```cpp
                }
                else{//3有剩余时
                    printf("%d %d",(i-1)/3,num1+num2+(i-1)/3+(m-num2*2-num1)/3*4);
                    return 0;
                }
            }
        }
    }
//假如说都运行完了也没结束，就说明总攻击不足以耗掉对手的生命，所以：
    printf("Human Cannot Win Dog");
    return 0;
}
```

---

## 作者：stswkl (赞：0)

## 题意
敌方有 $n$ 个随从，攻击力分别为 $k_i(1\le i\le n)$，敌方血量为 $m$。

你有三种药水（每种无数个），效果如下：

- 缩小药水，消耗 $1$，可以减少敌方所有随从 $3$ 的攻击力。
- 疯狂药水，消耗 $1$，可以把敌方一个攻击力 $a_i(1\le i\le n)\le 2$ 的随从加入到己方阵营。
- 暗影狂乱，消耗 $4$，可以把敌方一个攻击力 $a_i(1\le i\le n)\le 3$ 的随从加入到己方阵营。

要求最少的可以击败敌人的缩小药水数量，在数量最少的情况下求最少的消耗。

## 思路
不难发现，如果使用 $k$ 瓶缩小药水可以击败敌人，则使用 $p(k\le p)$ 瓶缩小药水一定可以击败敌人，有单调性。故考虑二分答案。

设函数 $check_k$ 表示使用 $k$ 瓶药水是否可以击败敌人，则对于攻击力 $a_i(1\le i\le n)-3k\le 3$ 的敌方随从可以对敌人造成 $((a_i-1)\mod{3})+1$ 的伤害，将可造成的伤害全部累加起来，若大于敌方血量，则使用 $k$ 瓶药水可以击败敌人。

最小的缩小药水数后还需要判断是否可以击败敌人，不能就输出 `Human Cannot Win Dog`。

题目还要求在尽可能少使用缩小药水的情况下最少的费用，这里需要运用贪心。

你可以加入到己方阵营的随从中，对敌人造成了 $2$ 伤害的随从消耗都只有 $1$，十分甚至九分划算，因此能用他们就尽量用。

使用完以后有两种情况：

- 敌方血量 $m\le 0$，直接输出消耗（记得加上使用的缩小药水的消耗）。
- 敌方血量 $m>0$，还需要进一步攻击。

对于还需要攻击的情况，先将敌人的血量打成 $3$ 的倍数（可以的话），然后尽可能的用伤害为 $1$ 的随从（数量是 $3$ 的倍数），因为 $3$ 个伤害为 $1$ 的随从总消耗为 $3$，小于一个伤害为 $3$ 的随从，还是打不死就用伤害为 $3$ 的随从。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e6+5;
int n,m,a[N],l=-1,r,ans,cnt[5];
bool check(int k)
{
    int sum=0,HP=m;
    for(int i=1;i<=n;i++)
    {
        int tmp=(a[i]-sum)/3;
        if(a[i]%3==0)tmp--;
        sum=min(sum+tmp*3,k*3);
        if(a[i]-sum<=3)HP-=a[i]-sum; //造成伤害。
    }
    return HP<=0;
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+n+1);
    r=a[n]/3+1;
    while(l+1<r) //二分答案找出最小的缩小药水数。
    {
        int mid=(l+r)/2;
        if(check(mid))r=mid;
        else l=mid;
    }
    if(!check(r)) //无解。
    {
        cout<<"Human Cannot Win Dog\n";
        return 0;
    }
    cout<<r<<' ';
    for(int i=1;i<=n;i++)
    {
        if(m<=0||a[i]-r*3>3)break;
        cnt[a[i]%3]++; //统计每种攻击力的随从的数量。
    }
    if(m<cnt[2]*2)
        ans=n/2+n%2;
    else
    {
        m-=cnt[2]*2; //先用攻击力为 2 的随从。
        ans+=cnt[2];
        if(m%3!=0) //把敌人血量打成 3 的倍数。
        {
            if(cnt[1]>=m%3)
                ans+=m%3,cnt[1]-=m%3;
            else ans+=4,cnt[3]--;
            m-=m%3;
        }
        if(cnt[1]%3!=0)cnt[1]-=cnt[1]%3; //用攻击力为 1 的随从。
        if(m<=cnt[1])ans+=m;
        else ans+=cnt[1]+(m-cnt[1])/3*4; //实在不行才用攻击力为 3 的随从。
    }
    cout<<ans+r;
    return 0;
}
```

---


# [NOIP 2017 普及组] 棋盘

## 题目背景

NOIP2017 普及组 T3

## 题目描述

有一个 $m \times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $ 个金币。

另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？


## 说明/提示

**样例 1 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ | $\color{red}\text{红}$ |  |
|  |  |  | $\color{yellow}\text{黄}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |


从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币。

从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币。

从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币。

从 $(2,2)$ 走到 $(2,3)$ 不花费金币。

从 $(2,3)$ 走到 $(3,3)$ 不花费金币。

从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币。

从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币。

从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费 $ 2$ 枚金币。

从 $(4,4)$ 走到 $(4,5)$ 不花费金币。

从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币。

共花费 $8 $ 枚金币。

**样例 2 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ |  |  |
|  |  |  | $\color{white}\text{　}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |

从 $( 1, 1)$ 走到 $( 1, 2)$，不花费金币。

从 $( 1, 2)$ 走到 $( 2, 2)$，花费 $ 1 $ 金币。

施展魔法将 $( 2, 3)$ 变为黄色，并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费 $ 2$ 金币。

从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币。

从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$。

而从以上四点均无法到达 $( 5, 5)$，故无法到达终点，输出$-1$。

**数据规模与约定**

对于 $30\%$ 的数据，$1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。

对于 $60\%$ 的数据，$1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。

对于 $100\%$ 的数据，$1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$。


## 样例 #1

### 输入

```
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0```

### 输出

```
8```

## 样例 #2

### 输入

```
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0```

### 输出

```
-1```

# 题解

## 作者：ZigZagKmp (赞：459)

### update on 2020.2.16
看到评论区有同学对排版的建议，故对文章排版进行一些优化，使本题解符合现行题解规范。

## 写在前面
这是本蒟蒻一年前发的题解，因此有些地方讲的不是特别清楚，代码也比较冗长。其实这一题没有必要将其转换为图论模型，在上面跑最短路，可以直接使用优先队列优化的 `BFS` 。

`NOIP2017`普及组比赛，是我参加的第一次复赛，当时我太菜了（虽然说现在的我也还是很菜），这一题最暴力的 `dfs` 都写不对，不知怎么拿到了`20`分，其余的测试点 `WA`+`TLE` ，在考场上时间几乎全用来氪这一题，结果最后一题想出`50`分 `DP` 没调完，`220`滚粗。考场上主要纠结于如何处理魔法，因此考后和[同学](https://www.luogu.com.cn/user/28910)想到了这样一种代替魔法的算法。

这一次修改，将对原题解中解释的不是很清楚的地方作较为清晰的解释，并且修改了最后的参考程序，提供本题2种做法。

至于本题的主流算法（ `dfs` +记忆化优化），其实从最短路的角度上来讲是基于 `dfs` 实现的 `SPFA` （没错，就是那个~~死了又活了的`SPFA`~~）,如果这一题数据范围扩大，并且做一些特殊构造，是可以被卡掉的。

另外，本蒟蒻不建议使用基于 `dfs` 实现的 `SPFA` ，因为这其实是最好卡掉了 `SPFA` 。

----

### 题意分析与转化

> 给你一个棋盘，有一些格子被染成了两种颜色。你可以从一个有颜色的格子走向另一个有颜色的格子，若两个格子颜色相同，则不付出代价，否则付出 $1$ 点代价。

如果题目就到这里，相当于代价为 $0$ 或者 $1$ 的四个方向的走迷宫，可以使用双端队列 `BFS` 实现，时间复杂度$O(m^2)$


> 另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但**这个魔法不能连续使用**， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

如果就按照题意来**直接搜索**的话会比较麻烦（本蒟蒻当年就是这样写挂了的），但是我们可以稍微转化一下。

（注：下面的分析过程不妨**只考虑一种颜色**，因为颜色不同带来的代价的变化和魔法的转化没有太大关系）

我们现在站在一个施了魔法的格子上(称为 `via` )，我们上一步的格子称为 `now` ，下面我们思考下一步能走到的格子有哪些（称为 `next` ）。

因为魔法不能连用，并且如果我们走回上一步的格子，结果一定不是最优的，所以我们可以选择的只有如下的情况：

![](https://cdn.luogu.com.cn/upload/pic/71445.png)

其中蓝色的格子可能成为 `next` （**前提，在未使用魔法的情况下这些格子本来有色**）。

知道了 `next` 可能的决策集合，我们下面来看如何把魔法**等价转换**掉。

![](https://cdn.luogu.com.cn/upload/pic/32552.png)

如图，可以将格子 `via` 施加魔法，从 `now` 走向 `next` ，实现了向**右下方**的转移。

![](https://cdn.luogu.com.cn/upload/pic/32553.png)

如图，可以将格子 `via` 施加魔法，从 `now` 走向 `next` ，实现了向**左下方**的转移。

![](https://cdn.luogu.com.cn/upload/pic/32554.png)

如图，可以将格子 `via` 施加魔法，从 `now` 走向 `next` ，实现了向**下连跳$2$格**的转移。

![](https://cdn.luogu.com.cn/upload/pic/32555.png)

如图，可以将格子 `via` 施加魔法，从 `now` 走向 `next` ，实现了向**右连$2$格**的转移。

同理，我们也可以实现向**左上方**，向**右上方**，向**上连跳$2$格**，向**左连跳$2$格**的转移。

综上，我们得到**使用魔法**可以转移到的情况：

![](https://cdn.luogu.com.cn/upload/pic/32556.png)

综合一下，我们可以得到如下结论：从 `now` 这个格子出发，使用或不使用魔法可以走到的**有色格子**的情况如下图：

![](https://cdn.luogu.com.cn/upload/pic/32558.png)

其中绿色格子因为使用魔法，不需要花费代价，蓝色的格子因为使用一次魔法，需要额外花费 $2$ 点代价。（同样，这里不考虑格子实际颜色对代价的影响）

也许有同学会问了，如果出现下图中的这种情况呢？

![](https://cdn.luogu.com.cn/upload/pic/71453.png )

显然从 `now` 出发先向右走后向下走是更优的，但是按照我们刚刚所述的方法，对 `now` 这个格子讨论，右下角的有色格子 `B` 会被认为要使用魔法，凭空多出了$2$点代价，我们刚刚的方法能得到最优解吗？

试问： `now` 右面的格子 `A` 是不是有色格子？

既然 `A` 是有色格子，那么我们也会对 `A` 讨论， `now` 可以不花费代价到达 `A` ， `A` 又可以不花费代价到达 `B` ，因此 `now` 到 `B` 格子的代价最终会被 `now->A->B` 的路径取代，不会出现丢失最优解的情况。

这时我们发现一个问题：普通的 `BFS` 似乎实现不了这种答案更新，具体的分析与解法将在下文讲解。

----

#### 现在我们先把颜色加上去：

1. 与魔法无关的$4$种转移，同色代价不变，异色代价加 $1$ 。
2. 涉及魔法的$8$种转换，如果颜色相同，如图：

![](https://cdn.luogu.com.cn/upload/pic/32560.png)

当格子 `via` 变成黄色的格子的时候，付出的代价最小，一共为$2$个代价。

如果颜色不同，如图：

![](https://cdn.luogu.com.cn/upload/pic/32561.png)

当格子 `via` 变成黄色或者红色的时候，付出的代价都是一样的，一共为$3$个代价。

----

综上所述，我们将题目转化为如下：

> 你需要从$(1,1)$走到$(m,m)$，你只能走在有颜色的格子中，并且使得你所花费的代价最小。

> 当你站在一个有颜色的格子上的时候，你可以进行如下$2$种操作：
> 1. 向上、下、左、右前行。
> 2. 向左上、左下、右上、右下、向上连跳$2$格、向下连跳$2$格、向左连跳$2$格、向右连跳$2$格前行。

> 如果你使用的是操作 $2$ ，你将额外付出 $2$ 点代价。

> 在一次操作中，如果你**这次操作的起点格子与终点格子**颜色不同，你将付出$1$点代价。

完了吗？

**显然没有！**

如果$(m,m)$没有颜色怎么办？

因为魔法不能连续使用，所以只可能从$(m,m-1)$，$(m-1,m)$转移。

1. 如果都没有颜色，就不可能到达$(m,m)$。
2. 如果任何一个有颜色，相当于$(m,m)$变化为有颜色的那个格子的颜色，总代价为$2$。
3. 如果$2$个都有颜色，转移总代价都是$2$，最后做一下比较就可以了。

----

## 算法分析
下面我们主要研究 `BFS` 的实现。

现在我们已经将题意转化为经典的走迷宫模型，解决的经典方法是 `BFS` ，但是又有所不同。每一次拓展的代价不一定相同，此时可能出现如下的情况：
![](https://cdn.luogu.com.cn/upload/pic/39190.png)

~~因为不满足三角形不等式，所以从实际来讲这里不应该画成三角形。但因为这张图简(wo)明(bi)直(jiao)观(lan)，所以这张图就不重画了。~~

显然，最短路径应该是 `1->2->3` ，而如果我们用一般的队列实现宽搜，就会得到错误的答案。

我们先思考一个问题：为什么经典的走迷宫模型可以直接普通队列 `BFS` ？

不难得出：在这样的 `BFS` 中，每一次扩展的代价都相等**且为正数**，**后进入队列的状态一定不如先进入队列的状态优**（先进入队列的状态的代价 $\le$ 后进入队列的状态的代价）。

基于这样的单调性，我们可以得出：第一次访问到某一个状态时，一定是这个状态的最优情况。

这是一个贪心思想。我们把这种思想应用到更具有普遍性的情况中：代价不一定相等。

现在我们有$2$种解决方法：
- 普通队列+迭代思想(~~已经死掉的`SPFA`~~)

我们无法保证第一次访问到某一个状态的最优性，但我们可以将**被优化的状态**不断压入队列中，直到所有状态都是最优的。这种算法最坏情况下可以达到 $O(n^2)$ （n为状态种数），一般情况下为 $O(n)$ 。
- 优先队列( `Dijkstra` )

我们只要满足每一次都从状态队列中取出最小代价的状态，即可满足第一次访问最优性。优先队列可以实现这种操作。时间复杂度 $O(n\log_2n)$ 。

有一种比较形象地解释，我们可以把 `BFS` 的棋盘看作图，即 `Dijkstra` 用来解决最短路。把这个图 **“拎起来 ”**，最初拎着起点，然后找当前最高的且没有被拎过的结点，作为下一次拎起来的结点，如此不断去拎，直到把终点结点拎起来，这样拎就可以找到起点和终点的最短距离。

注意，使用优先队列优化的 `BFS` 不能处理**有负数代价**的情况，反例如下：

![](https://cdn.luogu.com.cn/upload/pic/71455.png)

我们要从 `S` 走到 `T` ，第一步就可以找到所谓的最小代价$2$， `A` 虽然也在队列中，但是$10$的代价比$2$大，因此不会被取出。

但实际上， `S` 走到 `T` 的最小代价是$-90$，路径为 `S->A->T` ,我们得到了错误的答案。

----

至此，我们成功跳出了命题人挖给我们的的思维陷阱，没有直接按照题意搜索，而是将题意转化，简化问题，大大降低了代码实现复杂度。（听说直接按照题意 `dfs` 会炸栈空间，虽然 `NOIP` 开大栈空间，但是你在跑大样例的时候看到程序报 `RE` 还找不到哪儿错了，对接下来做题的心态会有很大影响）

update on 2020.2.16. `CSP-S 2019` 的时候，我的几个同学因为不会开大栈空间 `Day1T2` 没法测大样例，丢分严重，且影响到 `Day2` 的发挥。

----

### 代码实现
1.  `BFS` +优先队列优化

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
template <typename Tp>
void read(Tp &x){
	char c=getchar();x=0;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;
}//快速读入，不解释
struct node{
	int x,y,c,w; 
	bool operator <(node b)const{//const不可丢 
		return w>b.w;
	}//因为STL中优先队列默认取出最大的元素 
	 //所以这里重载运算符，保证每次取出的是最小代价的 
};
priority_queue<node>q;//node类型必须定义< 
int dx[]={0,1,0,-1,1,1,-1,-1,0,2,0,-2};//12方向及魔法代价 
int dy[]={1,0,-1,0,1,-1,1,-1,2,0,-2,0};
int dw[]={0,0,0,0,2,2,2,2,2,2,2,2};
int a[105][105],dis[105][105];//a存储棋盘上格子的颜色 
int n,m;
void bfs(){
	memset(dis,0x3f,sizeof(dis));dis[1][1]=0;
	q.push((node){1,1,a[1][1],dis[1][1]});
	node cur,nxt;
	while(!q.empty()){
		cur=q.top();q.pop();
		if(dis[cur.x][cur.y]<cur.w)continue;
		for(int i=0;i<12;i++){//懒惰删除 
			nxt.x=cur.x+dx[i];
			nxt.y=cur.y+dy[i];
			nxt.w=cur.w+dw[i];
            if(nxt.x<=0||nxt.x>m||nxt.y<=0||nxt.y>m)continue;//保证在棋盘范围内
			nxt.c=a[nxt.x][nxt.y];
			if(!nxt.c)continue;
			if(cur.c!=nxt.c)nxt.w++;//确定下一步的信息 
			if(dis[nxt.x][nxt.y]>nxt.w){
				dis[nxt.x][nxt.y]=nxt.w;
				q.push(nxt);
			}
		}
	}
}
int main(){
	int x,y,c;
	read(m);read(n);
	for(int i=1;i<=n;i++){
		read(x);read(y);read(c);
		a[x][y]=c+1;
	}//这里c+1，为了方便区分无色格子 
	bfs();
	if(!a[m][m]){//处理(m,m)无色情况 
		int ans=min(dis[m][m-1],dis[m-1][m])+2;
		if(ans>=inf)puts("-1");
		else printf("%d\n",ans);
	}
	else{
		if(dis[m][m]==inf)puts("-1");
		else printf("%d\n",dis[m][m]);
	}
	return 0;
}
```

2. 最短路（ `Dijkstra` ）

注：下面的参考程序使用 `zkw线段树` 代替优先队列， `zkw线段树` 短小精悍，常数较小，并且支持直接单点修改，不需要优先队列的懒惰删除法。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100005
#define maxm 2000005
#define inf 0x3f3f3f3f
template <typename Tp>
void read(Tp &x){
	char c=getchar();x=0;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;
}//快速读入，不解释 
struct Edge{
	int f,t,w,nxt;
}edge[maxm];
int head[maxn],etot=1;//这里有一个小技巧，存图时边数初值设为一个奇数 
void add_edge(int f,int t,int w){//这样可以利用位运算成对变化找到反向边 
	edge[++etot]=(Edge){f,t,w,head[f]};
	head[f]=etot;
}//链式前向星存图 
//--------以下内容为 zkw线段树
//主要思路，用线段树维护dis
//dis1数组表示在线段树中的dis
//tr数组记录当前最小dis对应的节点编号 
//有关zkw线段树，可以参考洛谷日报的讲解，这里不多说 
int tr[maxn<<2],dis1[maxn<<2],bt;
int n,m,S,T;
void build(){
	for(bt=1;bt<=n+1;bt<<=1);//bt初始化，zkw线段树的初始操作 
	for(int i=1;i<=n;i++)tr[i+bt]=i;//tr数组初始化 
	memset(dis1,0x3f,sizeof(dis1));//dis1数组初始化 
	//因为这里dis初值都是inf，所以可以这样直接赋值 
}
void modify(int x,int val){
	dis1[x]=val;x+=bt;//单点修改 
	for(x>>=1;x;x>>=1){//以下是zkw线段树常规操作 
		if(dis1[tr[x<<1]]<dis1[tr[(x<<1)|1]])tr[x]=tr[x<<1];
		else tr[x]=tr[(x<<1)|1];
	}
}//其实上面的内容并不是很长，只是注释比较多 
int dis[maxn];
void dijkstra(){
	memset(dis,0x3f,sizeof(dis));
	build();//build()不可忘 
	dis[S]=0;modify(S,0);//源点更新 
	int x,y,w;
	for(int j=1;j<=n;j++){//这里tr[1]维护的是[1,n]dis的最小值的节点编号，所以直接调用 
		x=tr[1];modify(x,inf);//这里将x设为极大值，来取代删除操作 
		for(int i=head[x];i;i=edge[i].nxt){
			y=edge[i].t;w=edge[i].w;
			if(dis[y]>dis[x]+w){//dijkstra松弛操作 
				dis[y]=dis[x]+w;
				modify(y,dis[y]);//直接更新 
			}
		}
	}
}
int dx[]={0,1,0,-1,1,1,-1,-1,0,2,0,-2};//12方向及魔法代价 
int dy[]={1,0,-1,0,1,-1,1,-1,2,0,-2,0};
int dw[]={0,0,0,0,2,2,2,2,2,2,2,2};
int a[105][105],cnt[105][105];
struct node{
	int x,y,c;
}b[maxn];
//a存储棋盘上格子的颜色 
//cnt表示棋盘上的格子对应的节点编号 
void preprocess(){//建图 
	int x,y,c,xx,yy,ww;
	for(int i=1;i<=n;i++){
		x=b[i].x;y=b[i].y;c=b[i].c;
		for(int j=0;j<12;j++){
			xx=x+dx[j];yy=y+dy[j];ww=dw[j];
			if(a[xx][yy]){
				if(a[xx][yy]!=c)ww++;
				add_edge(i,cnt[xx][yy],ww);
			}
		}
	}//这一段在上文题解中讲的比较详细，这里不再多说 
	S=cnt[1][1];
}
int main(){
	int mm,x,y,c;
	read(mm);read(n);
	for(int i=1;i<=n;i++){
		read(x);read(y);read(c);
		a[x][y]=c+1;cnt[x][y]=i;
		b[i]=(node){x,y,c+1};
	}//这里c+1，为了方便区分无色格子 
	preprocess();
	dijkstra();//因为在图论中m常代表的含义是边数 
	if(!a[mm][mm]){//所以用mm取代原题目中的m，即棋盘大小 
		int ans=min(dis[cnt[mm][mm-1]],dis[cnt[mm-1][mm]])+2;
		if(ans>=inf)puts("-1");
		else printf("%d\n",ans);
	}//(m,m)没有颜色的特判 
	else{
		if(dis[cnt[mm][mm]]==inf)puts("-1");
		else printf("%d\n",dis[cnt[mm][mm]]);
	}
	return 0;
}
```

附：卡掉本题 `dfs` +记忆化优化(即 `SPFA` )的做法：数据范围修改为 $m\le 1000,n\le 100000$ ，因为本题是棋盘，本身就是一种类似于网格图的东西，再加一些比较靠近的有色格子（只能说接近菊花图，因为这一题一个点出度最多为$12$），再加一些链状有色格子（次优解长链），理论上来讲大部分可以卡掉了。

---

## 作者：览遍千秋 (赞：11)

本算法是当时出了考场只**三**分钟后，和同学脑袋一拍想出来的，**翻了几乎所有题解，没有发现相同解法的**，现在把它写出来，以祭奠逝去的NOIP2017，迎接已至的NOIP2018.

---

## 搜索

很显然，这是一道搜索题。

我们考虑用二元组$(x,y)$代表当前搜索到的格子，附带参数$q$为已经使用的金币，$flag$代表上一次有没有使用**膜**法。

这种搜索可能是大部分人看到题目就想到的算法，事实上，我最后提交的就是这种爆搜，55分，TLE。

这种要分很多类讨论，并且对于$flag$的处理非常讨厌。

---

## 如何转换膜法

上面提到的爆搜，是对$(x,y)$周围四个点不断进行拓展，到了终点就记录答案。

如图：

![](https://cdn.luogu.com.cn/upload/pic/39182.png)

这样，我们就被命题人牵着鼻子走了。

### 命题人说，要有膜法。我们就要说，不要有膜法。

考虑膜法，本质上是允许这个人从这个点走到距离为两格的**有颜色**格子里，代价为在走到相同或不同颜色的格子上的代价+2。

即，如图：

![](https://cdn.luogu.com.cn/upload/pic/39181.png)

上图中绿色格子就是距离为1的格子，蓝色格子就是距离为2的格子。

**请注意，无论是上图中蓝色或者绿色格子，都必须在原来的棋盘中是有颜色的**

至此，膜法全部转移完毕。

---

## 最终搜索算法

我们最终形成了这样的一个算法：

通过$dfs$，搜索每一个格子，可以向周围**十二**个方向拓展。

---

## 剪枝

这样过不去的QAQ。

设$opt_{i,j}$代表到$(i,j)$时的最小代价，初值为$INF$。

如果我搜进去的时候，$opt_{i,j}<=q$，则直接返回即可。

---

## 代码

### 我错了QAQ，之后还是乖乖写增量数组吧。。。

code:

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

#define maxm 107
int m,n,x,y,c,color[maxm][maxm],ans=0x7fffffff,opt[maxm][maxm];
bool vis[maxm][maxm];
int min(int a,int b)
{
	return a>b?b:a;
}
void f(int x,int y,int q)
{
	if(opt[x][y]&&opt[x][y]<=q) return;
	opt[x][y]=q; 
	if(x==m&&y==m){
		ans=min(ans,q);
		return;
	}
	if(x==m-1&&y==m||x==m&&y==m-1&&!color[m][m])
	{
		ans=min(ans,q+2);
		return;
	}
	vis[x][y]=0;
	if(vis[x][y-1]&&color[x][y-1]){
		if(color[x][y]==color[x][y-1]){
			f(x,y-1,q);
		}
		else{
			f(x,y-1,q+1);
		}
	}
	if(vis[x][y+1]&&color[x][y+1]){
		if(color[x][y]==color[x][y+1]){
			f(x,y+1,q);
		}
		else{
			f(x,y+1,q+1);
		}
	}
	if(vis[x-1][y]&&color[x-1][y]){
		if(color[x][y]==color[x-1][y]){
			f(x-1,y,q);
		}
		else{
			f(x-1,y,q+1);
		}
	}
	if(vis[x+1][y]&&color[x+1][y]){
		if(color[x][y]==color[x+1][y]){
			f(x+1,y,q);
		}
		else{
			f(x+1,y,q+1);
		}
	}//以下为膜法转化来的8个方向 
	if(vis[x+1][y+1]&&color[x+1][y+1]){
		if(color[x][y]==color[x+1][y+1]){
			f(x+1,y+1,q+2);
		}
		else{
			f(x+1,y+1,q+3);
		}
	}
	if(vis[x+1][y-1]&&color[x+1][y-1]){
		if(color[x][y]==color[x+1][y-1]){
			f(x+1,y-1,q+2);
		}
		else{
			f(x+1,y-1,q+3);
		}
	}
	if(vis[x-1][y+1]&&color[x-1][y+1]){
		if(color[x][y]==color[x-1][y+1]){
			f(x-1,y+1,q+2);
		}
		else{
			f(x-1,y+1,q+3);
		}
	}
	if(vis[x-1][y-1]&&color[x-1][y-1]){
		if(color[x][y]==color[x-1][y-1]){
			f(x-1,y-1,q+2);
		}
		else{
			f(x-1,y-1,q+3);
		}
	}
	if(vis[x][y+2]&&color[x][y+2]){
		if(color[x][y]==color[x][y+2]){
			f(x,y+2,q+2);
		}
		else{
			f(x,y+2,q+3);
		}
	}
	if(vis[x][y-2]&&color[x][y-2]){
		if(color[x][y]==color[x][y-2]){
			f(x,y-2,q+2);
		}
		else{
			f(x,y-2,q+3);
		}
	}
	if(vis[x+2][y]&&color[x+2][y]){
		if(color[x][y]==color[x+2][y]){
			f(x+2,y,q+2);
		}
		else{
			f(x+2,y,q+3);
		}
	}
	if(vis[x-2][y]&&color[x-2][y]){
		if(color[x][y]==color[x-2][y]){
			f(x-2,y,q+2);
		}
		else{
			f(x-2,y,q+3);
		}
	}
	vis[x][y]=1;
}
void read(int &x)
{
	x=0;int fh;char ch=1;
	while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
	if(ch=='-'){
		fh=-1;
		ch=getchar();
	}
	else fh=1;
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=fh;
}
int mian()
{
	read(m);read(n);
	for(register int i=1;i<=n;i++)
	{
		read(x);read(y);read(c);
		color[x][y]=c+1;
	}
	for(register int i=1;i<=m;i++)
	{
		for(register int j=1;j<=m;j++)
			vis[i][j]=1;
	}
	f(1,1,0);
	if(ans==0x7fffffff) puts("-1");
	else printf("%d\n",ans);
	return 0;
}
```

---

## 作者：dxzier (赞：8)

本篇题解思想部分来自于 NOIWC2024 第二课堂《最短路算法及其应用》。感谢 “北京大学附属中学 肖然”老师的讲解。

## 

首先在阅读题目后我们可以得知，本题是在一个 $m \times m$ 的棋盘中，每个格子有 $0,1,$ 空 三种情况，每次移动可以向上下左右四个方向移动一格，任意时刻所处的格子不能为空。每走一步：

- 如果出发和到达的格子颜色相同，代价为 $0$。
  
- 如果出发和到达的格子颜色不同，代价为 $1$。

- 可以暂时改变空为 $0,1$ 中的任意一种，代价为 $2$，**不能连续使用**。

求从 $(1,1)$ 走到 $(m,m)$ 的最小代价。

容易构造出下图，假设当前所处的点为 0，其中一步就能到达的点为 1，两步才能到达的点为 2。

|||2|||
|:-:|:-:|:-:|:-:|:-:|
||2|1|2||
|2|1|0|1|2|
||2|1|2||
|||2|||

对于每一个不为空的点，我们可以按照如下方法建图：

- 如果在标记为 1 的地方存在点，则由标记为 0 的点向此点连边即可，边权由颜色异同决定。

- 如果在标记为 2 的地方存在点，行走过程为先由标记为 0 的点走向标记为 1 的点，再走向标记为 2 的点，但可以**直接连接**一条从标记为 0 的点到此点的边，边权由颜色异同决定后再加二。

- 对于标记为 1 的点，如果它为空，但坐标却为 $(m,m)$，可以连接一条由标记为 0 的点向此点，边权为二的边。容易发现仅当该点处在标记为 0 的点的下方或右方时，此点才有可能是 $(m,m)$。

- 对于标记为 2 的点，如果它为空，但坐标却为 $(m,m)$，容易发现无法**直接**到达，因为无法连续改变点的颜色。

在第二条中，如果中间经过的标记为 1 的点不为空，这条由标记为 0 的点**直接**连向标记为 2 的点的边的边权**大于等于二**。而先由标记为 0 的点走向标记为 1 的点，再走向标记为 2 的点，**这两条边的边权之和小于等于二**。所以这样的非法连边在结果上一定不会更优，也就无需对此类非法边进行判断。

建图后在图上跑最短路即可。如果无法到达 $(m,m)$ 则输出 $-1$。

---

上述内容与其它题解无异。诚然，这是一道普及组的题目，但在更大的数据范围中，原解法是否仍有一些优化的空间？

### 稀疏矩阵存储

首先是点的存储问题。在最初的做法中，由于 $m \le 100$，我们可以使用二维数组存储整个棋盘，然后对其中每一个非空点做上述的建图操作即可。这会使我们的空间复杂度达到 $m^2$。而如果不使用二维数组，直接判断两点曼哈顿距离，则会使时间复杂度达到 $n^2$。但当 $n,m$ 扩大到很大却处于同一数量级时，容易发现二维数组中仅有极少一部分点是真正有用的。

对于这种稀疏矩阵的存储，容易想到使用一些数据结构，比如 std::unordered_map。我们可以创建如下对象来存储棋盘中的有效点。

```cpp
std::unordered_map<int,unordered_map<int,int>> M;
```

这样我们可以得到一个常数稍大的二维数组，但其平均时空复杂度仍然是 $O(n)$ 的。

### 特殊条件下的线性单源最短路

#### $0/1$ BFS

让我们重新审视单源最短路问题。首先考虑一种特殊情况，边权只有 $0/1$ 两种取值。对于这样的图在 BFS 时可以使用两个队列，每次取两个队列队头中已经过长度 $dis$ 较小的一个元素。对于此点连向的还没遍历过的点，如果边权为 $0$ 则加入第零个队列，如果边权为 $1$ 则加入第一个队列。

若保证队列零中每个元素 $dis$ 相同，队列一队头元素的 $dis$ 大于等于队列零队头元素的 $dis$，且队列一中每个元素 $dis$ 单调不递减且最多比两队列队头中较小的那个大一。

- 一个元素被插入队列一，其 $dis$ 仅比此时队头中 $dis$ 较小的那个大一，则新插入队列一的元素可以保证队列一仍然具有原性质，则此时原有三项性质均不变。

- 一个元素被插入队列零，若来自队列零则原有三项性质均不变。

- 一个元素被插入队列零，若来自队列一，则队列一队头元素 $dis$ 与队列零队头元素 $dis$ 相同，或队列零为空。对于两种子情况原有三项性质均不变。

- 初始情况下两队列均为空，向任意队列加入初始元素，均具有上述三项性质。

综上所述，该方法可以保证每次取到元素的 $dis$ 单调不递减，所以该方法可以处理边权仅有 $0/1$ 的图上的单源最短路问题。

#### $1/2$ BFS

对于这样的图同样可以在 BFS 时可以使用两个队列，每次取两个队列队头中已经过长度 $dis$ 较小的一个元素。对于此点连向的还没遍历过的点，如果边权为 $1$ 则加入第一个队列，如果边权为 $2$ 则加入第二个队列。

此时证明甚至更加简单，仅有两条性质：

队列一中每个元素 $dis$ 单调不递减且最多比两队列队头中较小的那个大一，且队列二中每个元素 $dis$ 单调不递减且最多比两队列队头中较小的那个大二。

仅需同理证明如上两条性质时刻成立，即可保证每次取到元素的 $dis$ 单调不递减，所以该方法可以处理边权仅有 $1/2$ 的图上的单源最短路问题。证明过程不再赘述。

#### $a/b$ BFS $a,b>0$ 且 $a \neq b$

与 $1/2$ BFS 类似，证明如下两条性质时刻成立：

队列一中每个元素 $dis$ 单调不递减且最多比两队列队头中较小的那个大 $a$，且队列二中每个元素 $dis$ 单调不递减且最多比两队列队头中较小的那个大 $b$。

由于两条性质时刻成立，可以保证每次取到元素的 $dis$ 单调不递减，所以该方法可以处理边权仅有 $a/b$ 的图上的单源最短路问题。证明过程同样不再赘述。

#### 多边权 BFS

从上面的思考容易想到可以对每一种边权建立一个队列，容易证明过程中对于任意一个队列 $i$ 均保持队列中每个元素 $dis$ 单调不递减且最多比任意一个队列队头中最小的那个大 $i$。

假设有 $k$ 种不同边权，每次选出其中队头元素的 $dis$ 最小的一个则需要 $O(k)$ 的时间复杂度。当 $k$ 很小，且与题目输入无关时，我们可以不计入复杂度将其看作常数。所以当 $k$ 足够小时，我们可以认为此时最短路算法为线性。（参考“南京外国语学校 杨敏行”《浅谈复杂度及其在解决问题方面的应用》）

但当 $k$ 很大时，这样的做法显然是不优的，于是可以想到用优先队列维护每个队列队头的元素。此时发现代码太过复杂，于是再简化一下代码，把所有元素全部丢进优先队列！于是！我们惊奇的发现！我们重新发明了 Dijkstra 算法！

（（肖老师：早生五十年，你也能发明这些算法。

## 

根据上述所有内容，可以发现此题中当 $n,m$ 扩大到很大却处于同一数量级时棋盘为稀疏矩阵，且仅出现边权 $0/1/2/3$，于是可以线性解决。


```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <unordered_map>
using std::unordered_map;
struct edge{
	int U,V,W;
};
struct point{
	int id,W;
};

int n=0,m=0;
int s=0,t=0;

unordered_map<int,unordered_map<int,int>> M;
unordered_map<int,std::vector<edge>> v;
void add(int s1,int s2,int w0){
	int id1=s1>>1,c1=(s1&1);
	int id2=s2>>1,c2=(s2&1);
	if(!(s2==t&&t==0)){
		if(c1!=c2)
			w0++;
	}
	(v[id1]).push_back({id1,id2,w0});
	return;
}
void buildmap(){
	unordered_map<int,unordered_map<int,int>>::iterator it1=M.begin();
	while(it1!=M.end()){
		unordered_map<int,int>::iterator it2=(it1->second).begin();
		while(it2!=(it1->second).end()){
			int x=it1->first,y=it2->first;
			
			unordered_map<int,unordered_map<int,int>>::iterator i1=M.find(x-1);
			unordered_map<int,unordered_map<int,int>>::iterator i2=M.find(x);
			unordered_map<int,unordered_map<int,int>>::iterator i3=i2;
			unordered_map<int,unordered_map<int,int>>::iterator i4=M.find(x+1);
			//x-1,y
			if(i1!=M.end()){
				unordered_map<int,int>::iterator in0=(i1->second).find(y);
				if(in0!=(i1->second).end())
					add(it2->second,in0->second,0);
			}
			//x,y-1
			if(i2!=M.end()){
				unordered_map<int,int>::iterator in0=(i2->second).find(y-1);
				if(in0!=(i2->second).end())
					add(it2->second,in0->second,0);
			}
			//x,y+1
			if(i3!=M.end()){
				unordered_map<int,int>::iterator in0=(i3->second).find(y+1);
				if(in0!=(i3->second).end())
					add(it2->second,in0->second,0);
				else if(x==m&&(y+1)==m)
					add(it2->second,t,2);
			}
			//x+1,y
			if(i4!=M.end()){
				unordered_map<int,int>::iterator in0=(i4->second).find(y);
				if(in0!=(i4->second).end())
					add(it2->second,in0->second,0);
				else if((x+1)==m&&y==m)
					add(it2->second,t,2);
			}
			else if((x+1)==m&&y==m)
				add(it2->second,t,2);
			
			unordered_map<int,unordered_map<int,int>>::iterator i21=M.find(x-2);
			unordered_map<int,unordered_map<int,int>>::iterator i22=M.find(x-1);
			unordered_map<int,unordered_map<int,int>>::iterator i23=i22;
			unordered_map<int,unordered_map<int,int>>::iterator i24=M.find(x);
			unordered_map<int,unordered_map<int,int>>::iterator i25=i24;
			unordered_map<int,unordered_map<int,int>>::iterator i26=M.find(x+1);
			unordered_map<int,unordered_map<int,int>>::iterator i27=i26;
			unordered_map<int,unordered_map<int,int>>::iterator i28=M.find(x+2);
			//x-2,y
			if(i21!=M.end()){
				unordered_map<int,int>::iterator in0=(i21->second).find(y);
				if(in0!=(i21->second).end())
					add(it2->second,in0->second,2);
			}
			//x-1,y-1
			if(i22!=M.end()){
				unordered_map<int,int>::iterator in0=(i22->second).find(y-1);
				if(in0!=(i22->second).end())
					add(it2->second,in0->second,2);
			}
			//x-1,y+1
			if(i23!=M.end()){
				unordered_map<int,int>::iterator in0=(i23->second).find(y+1);
				if(in0!=(i23->second).end())
					add(it2->second,in0->second,2);
			}
			//x,y-2
			if(i24!=M.end()){
				unordered_map<int,int>::iterator in0=(i24->second).find(y-2);
				if(in0!=(i24->second).end())
					add(it2->second,in0->second,2);
			}
			//x,y+2
			if(i25!=M.end()){
				unordered_map<int,int>::iterator in0=(i25->second).find(y+2);
				if(in0!=(i25->second).end())
					add(it2->second,in0->second,2);
			}
			//x+1,y-1
			if(i26!=M.end()){
				unordered_map<int,int>::iterator in0=(i26->second).find(y-1);
				if(in0!=(i26->second).end())
					add(it2->second,in0->second,2);
			}
			//x+1,y+1
			if(i27!=M.end()){
				unordered_map<int,int>::iterator in0=(i27->second).find(y+1);
				if(in0!=(i27->second).end())
					add(it2->second,in0->second,2);
			}
			//x+2,y
			if(i28!=M.end()){
				unordered_map<int,int>::iterator in0=(i28->second).find(y);
				if(in0!=(i28->second).end())
					add(it2->second,in0->second,2);
			}
			it2++;
		}
		it1++;
	}
	return;
}

std::vector<int> h;
std::queue<point> q[4];
point getq(){
	int j=-1;
	point ret={-1,2147483647};
	for(int i=0;i<=3;i++){
		if(!q[i].empty()){
			point f=q[i].front();
			if(f.W<ret.W){
				ret=f;
				j=i;
			}
		}
	}
	if(j==-1) return {-1,0};
	q[j].pop();
	return ret;
}
long long BFS(){
	long long ans=-1;
	q[0].push({s,0});
	while(1){
		point tp=getq();
		if(tp.id==t){
			ans=tp.W;
			break;
		}
		if(tp.id<0) break;
		if(h[tp.id]!=0) continue;
		h[tp.id]=1;
		unordered_map<int,std::vector<edge>>::iterator v0=v.find(tp.id);
		if(v0!=v.end()){
			for(int i=0;i<(v0->second).size();i++){
				edge tedge=(v0->second)[i];
				q[tedge.W].push({tedge.V,tp.W+tedge.W});
			}
		}
	}
	return ans;
}

int main(){
	scanf("%d%d",&m,&n);
	h.push_back(0);
	for(int i=1;i<=n;i++){
		int x,y,c;
		scanf("%d%d%d",&x,&y,&c);
		(M[x])[y]=(i<<1)+c;
		h.push_back(0);
		if(x==1&&y==1) s=i;
		if(x==m&&y==m) t=i;
	}
	buildmap();
	printf("%lld",BFS());
	return 0;
}
```

---

## 作者：WsW_ (赞：4)

### 思路
如果没有颜色的限制，这题就是常规的 bfs 单源最短路。但是有了颜色限制，考虑多了这些限制会怎样。  
如果你熟悉“分层图”，那就应该知道几乎所有**多了其他限制**的单源最短路，都可以用“分层图”的思想解决。  
“分层图”简单来说就是，不仅仅以到达的**点**定义状态，还通过题中所给的一些**特殊限制**来定义状态。  
在常规的 bfs 单源最短路中，仅仅以到达的点来定义状态，存储的是到某个点的最小花费。  
在本题中，我们可以定义状态为“到达的格子坐标，这个格子的颜色，是否在这个格子上使用了魔法”。显然，对于一个本来就有颜色的格子，它的状态为“这个格子的坐标，这个格子本来的颜色，未使用魔法”；对于一个本来没有颜色的格子，它的状态为“这个格子的坐标，红色或者黄色，使用了魔法”。  
应当分别存储到达不同的状态所需要的最小花费。  

在进行 bfs 单源最短路时，根据题目限制，从一种状态转移到另一种状态即可。

---
### 代码
这是以前的代码，并不是根据“分层图”的思想写的。  
之后将会更新代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y,w,col;
	bool magic;
};
queue<node>q;
int mp[103][103],ans[103][103];
int dir[4][2]={0,1,0,-1,1,0,-1,0};
int m;
void bfs(){
	q.push({1,1,0,mp[1][1],0});
	ans[1][1]=0;
	while(!q.empty()){
		node z=q.front();
		q.pop();
		int x=z.x,y=z.y,col=z.col,w=z.w;
		bool f=z.magic;
		for(int i=0;i<4;i++){
			int nx=x+dir[i][0];
			int ny=y+dir[i][1];
			if(nx<1||ny<1||nx>m||ny>m||(f&&!mp[nx][ny]))continue;
			int cost,ncol;
			bool nf;
			if(mp[nx][ny]){
				nf=0;
				cost=(col!=mp[nx][ny]);
				ncol=mp[nx][ny];
			}
			else{
				nf=1;
				cost=2;
				ncol=col;
			}
			if(w+cost<ans[nx][ny]){
				ans[nx][ny]=w+cost;
				q.push({nx,ny,w+cost,ncol,nf});
			}
		}
	}
}
int main(){
	int n;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++){
		int x,y,c;
		scanf("%d%d%d",&x,&y,&c);
		mp[x][y]=c+1;
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			ans[i][j]=1e9;
		}
	}
	bfs();
	if(ans[m][m]==1e9){
		printf("-1");
		return 0;
	}
	printf("%d\n\n",ans[m][m]);
	return 0;
}
```

---

## 作者：lby_commandBlock (赞：4)

## 前言

通过观察题目~~标签~~可知，该题是一道最短路题，但是也可以用搜索做。这篇题解我们使用 BFS 进行举例。

## 思路

**BFS 状态定义**

该题发现有 $4$ 个东西非常重要（若没有搞懂，则可以先看 BFS 转移）：

1. 当前位置。
2. 位置的颜色。
3. 是否使用过魔法。
4. 使用的金币数量。

所以，我们的 BFS 状态就定义为这四个东西。

**BFS 转移**

这道题的细节非常多，这里我讲详细一点。

我们先来判断哪种状态不合理。

- 第一是超出地图范围，应该放弃这种状态。
- 第二是该题中特有的，那就是处理**不能连续使用魔法**的情况。但是由于我们上面定义了是否使用过魔法，所以就可以判断是否使用过魔法且该格子是否没有颜色（也就是需要魔法）。

接下来就是正儿八经的转移了，下面都是合理的情况。

---

我们先考虑**下一次** BFS 的格子**如果有颜色**的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/jk1byovz.png)

- 第一种，若下一次 BFS 的格子与当前的格子相同，根据题意，就可以不用任何花费地走过去。

![](https://cdn.luogu.com.cn/upload/image_hosting/ao3gtgkh.png)

- 第二种，若下一次 BFS 的格子与当前的格子不同，根据题意，我们需要一个金币走过去。

![](https://cdn.luogu.com.cn/upload/image_hosting/f4ubv353.png)

---

我们再考虑下一次 BFS 的格子**如果没有颜色**的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/nykaq5f2.png)

则我们需要使用魔法。由于已经处理过不合理情况了，所以放心大胆直接使用魔法。但是下一次 BFS 格子该如何涂色呢？为了保证金币数量最少，我们就直接涂色成当前格子的颜色就行了，不然的话我花魔法的金币是 $2$，走到那里还要 $1$，加起来不就 $3$ 了吗。我们不要花冤枉钱。

![](https://cdn.luogu.com.cn/upload/image_hosting/y2tdkxzj.png)

---

这样，一个 BFS 模型就出现在我们的脑海里面了。可是当你信心满满写完时，你会发现 RE 了！为什么呢？因为我们没有处理重复走的情况。那么，一个 `bool` 就可以解决吗？不，我们需要“升级”标记数组，就是说把 `bool` 改成 `int`。

那标记数组里面存什么呢？类似记忆化搜索，我们定义 $ans_{i,j}$ 为走到 $i,j$ 这一格的最小金币数即可。在 BFS 不合理情况中，我们还要加上一个条件：

- 当前走到这一格的金币数量 $\ge ans_{i,j}$ 的。

这样子，一个完美的 BFS 就写完了。

又到了大家最喜欢的——

## 代码时间！

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N = 109;

int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

struct node {
	int x, y, color, magic, money;
	/*
	 * {x,y}：当前的坐标
	 * color：坐标的颜色
	 * magic：是否使用了魔法
	 * money：使用的金币数
	 */
};

int m, n, color[N][N], ans[N][N];

/*
 * m,n：如题目所述
 * color：存储每一个坐标的颜色
 * ans：记忆化搜索的答案数组
 */

void bfs() {
	queue<node> q;
	q.push({1, 1, color[1][1], 0, 0});
	ans[1][1] = 0;
	while (!q.empty()) {
		node p = q.front();
		q.pop();
		for (int i = 0; i < 4; i++) {
			int x1 = p.x + dx[i], y1 = p.y + dy[i];
			// 不合理情况判断
			if (x1 < 1 || x1 > m || y1 < 1 || y1 > m || (p.magic && color[x1][y1] == 0))
				continue;
			node next = {x1, y1, 0, 0, 0};
			int cost; // cost：这一次花费的金币数
			if (color[x1][y1] > 0) {
				// 第一种：下一个点**有颜色**
				if (color[x1][y1] == p.color)
					cost = 0;
				else
					cost = 1;
				// 没有使用魔法，下一个点的颜色就是color[x1][y1]
				next.magic = 0;
				next.color = color[x1][y1];
			} else {
				// 第二种：下一个点**没有颜色**
				cost = 2;
				next.magic = 1;
				next.color = p.color;
				// 花费的金币数是 2，使用过魔法，下一个点的颜色为当前点的颜色
			}
			// 加上金币数
			next.money = cost + p.money;
			// 记忆化
			if (next.money < ans[x1][y1]) {
				ans[x1][y1] = next.money;
				q.push(next);
			}
		}
	}
}

int mian() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> m >> n;
	for (int i = 1; i <= n; i++) {
		int x, y, c;
		cin >> x >> y >> c;
		// 将 c + 1，这样 0 就表示没有颜色了
		color[x][y] = c + 1;
	}
	memset(ans, 0x3f, sizeof(ans));
	bfs();
	// ans[m][m] 即是答案
	cout << (ans[m][m] == 0x3f3f3f3f ? -1 : ans[m][m]) << endl;
	return 0;
}
```

**拒绝抄袭，从我做起**

---

## 作者：Iron_Spade (赞：2)

两百万年前做过的题目拿来重新做还是原来的感觉。

发现 $1\leq m \leq 100$，考虑记搜。

定义 $dp_{i,j}$ 表示从 $(1,1)$ 走到 $(i,j)$ 的最小代价。

然后我们按题意模拟，遇到颜色相同格子则以 $0$ 代价走，遇到颜色不同格子则以 $1$ 代价走，如果无色就只能用魔法以 $2$ 代价走，注意 dfs 时要将施过魔法的格子颜色改变回溯时再还原。

注意格子要与无色的区分开所以我们考虑把格子的颜色都加上一，无色的格子记为零。

代码实现非常简单：

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
#define rep(i, j, k) for (int i = j; i <= k; ++i)
#define pre(i, j, k) for (int i = j; i >= k; --i)
#define int long long
#define inf LONG_LONG_MAX


using namespace std;
const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};

const int N = 2e2 + 5;
int a[N][N], vis[N][N], dp[N][N];
int ret = inf, m, n, x, y, k, flg;

void dfs(int x, int y, int s, int p) {
	if(s > ret) return;
	if(x == n && y == n) return ret = min(ret, s), void();
	rep(i, 0, 3) {
		int xx = x + dx[i], yy = y + dy[i];
		if(xx < 1 || xx > n || yy < 1 || yy > n || vis[xx][yy]) continue;
		vis[xx][yy] = 1;
		if(a[x][y] == a[xx][yy] && a[xx][yy] && s < dp[xx][yy]) dfs(xx, yy, dp[xx][yy] = s, 0);
		else if(a[x][y] != a[xx][yy] && a[xx][yy] && s + 1 < dp[xx][yy]) dfs(xx, yy, dp[xx][yy] = s + 1, 0);
		else if(!p) {
			if(s + 2 < dp[xx][yy]) {
				a[xx][yy] = a[x][y];
				dfs(xx, yy, dp[xx][yy] = s + 2, 1);
				a[xx][yy] = 0;
			}
		}
		vis[xx][yy] = 0;
	}
} 

signed main() {
	FASTIO
	memset(dp, 0x3f, sizeof dp);
	cin >> n >> m;
	rep(i, 1, m) cin >> x >> y >> k, a[x][y] = ++k;
	dfs(1, 1, 0, 0);
	cout << (ret > 1e9 ? -1 : ret);
	return 0;
}
```

---

## 作者：__galaxy_1202__ (赞：2)

## 解题思路：
暴力出奇迹！数据范围不大，跟着题意直接爆搜加剪枝即可。  

对于这种求最小值的爆搜，一个非常玄学且有效的剪枝就是记录每个格子当前所用的最短时间。  

然后就没了。要注意把第一个点初始化好~~当初 `dict` 第一个点没初始化调了我半天。~~

## CODE：

```cpp
#include<iostream>
using namespace std;
int m, n, x, y, c, ans = 1e9, dict[101][101], num[101][101];
int xy[4][2]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
bool vis[101][101];
void dfs(int x, int y, int now, int lst)
{
    if (now > ans) return;
    if (x == m && y == m)
    {
        ans = min(ans, now);
        return;
    }
    for (int i = 0; i < 4; i++)
    {
        int dx = x + xy[i][0], dy = y + xy[i][1];
        if (dx >= 1 && dx <= m && dy >= 1 && dy <= m && vis[dx][dy] == 0 && (num[x][y] != -1 || num[dx][dy] != -1))
        {
            if (num[dx][dy] == -1) 
            {
                if (now + 2 < dict[dx][dy])
                {
                    vis[dx][dy] = 1;
                    dict[dx][dy] = now + 2;
                    dfs(dx, dy, now + 2, lst);
                    vis[dx][dy] = 0;
                }
            }
            else
            {
                if (num[dx][dy] == lst)
                {
                    if (now < dict[dx][dy])
                    {
                        vis[dx][dy] = 1;
                        dict[dx][dy] = now;
                        dfs(dx, dy, now, lst);
                        vis[dx][dy] = 0;
                    }
                }
                else
                {
                    if (now + 1 < dict[dx][dy])
                    {
                        vis[dx][dy] = 1;
                        dict[dx][dy] = now + 1;
                        dfs(dx, dy, now + 1, num[dx][dy]);
                        vis[dx][dy] = 0;
                    }
                }
            }
        }
    }
}
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            num[i][j] = -1;
            dict[i][j] = 1e9;
        }
    }
    while (n--)
    {
        cin >> x >> y >> c;
        num[x][y] = c;
    }
    vis[1][1] = 1;
    dict[1][1] = 0;
    dfs(1, 1, 0, num[1][1]);
    if (ans == 1e9) cout << -1;
    else cout << ans;
    return 0;
}
```

---

## 作者：Night_sea_64 (赞：1)

这题很久以前我们校内出了原题，然后我重新打了一遍，由于 OI 赛制我看不见分，最后发现因为没删调试输出爆零了。。。

状态 $(x,y,k\in\{0,1\},c)$ 表示位置 $(x,y)$，是否使用了魔法，当前颜色是什么。

然后直接模拟所有的方向应该怎么使用魔法并改变颜色。发现边权可能会是 $2$，所以不能直接用 bfs 做，无脑 SPFA 即可。

当然转换一下也可以使用 bfs。当从有色格子到达无色格子时，可以先设计出一个中间的状态，借助这个状态到达无色格子，这样每一步的边权都是 $0$ 或 $1$，可以使用 01 bfs。

以下是 SPFA 的代码。

```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
int n,m;
int dx[]={0,-1,0,1,0};
int dy[]={0,0,-1,0,1};
int a[110][110];
int d[110][110][2][3];
struct node{int x,y,k,c;};
void spfa()
{
    memset(d,999999,sizeof(d));
    d[1][1][0][a[1][1]]=0;
    queue<node>q;
    q.push({1,1,0,a[1][1]});
    while(!q.empty())
    {
        int x=q.front().x,y=q.front().y,k=q.front().k,c=q.front().c;
        //cout<<x<<" "<<y<<" "<<k<<" "<<c<<" "<<d[x][y][k][c]<<endl;
        q.pop();
        for(int i=1;i<=4;i++)
        {
            int nx=x+dx[i],ny=y+dy[i];
            if(nx<1||nx>n||ny<1||ny>n)continue;
            int nk,nw,nc;
            if(a[nx][ny]==0)
            {
                if(k==1)continue;
                else nk=1,nw=2,nc=c;
            }
            else
            {
                nk=0,nc=a[nx][ny];
                if(a[nx][ny]==c)nw=0;
                else nw=1;
            }
            if(d[x][y][k][c]+nw<d[nx][ny][nk][nc])
            {
                d[nx][ny][nk][nc]=d[x][y][k][c]+nw;
                q.push({nx,ny,nk,nc});
            }
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y,c;
        cin>>x>>y>>c;
        a[x][y]=c+1;
    }
    spfa();
    int ans=min(min(d[n][n][0][2],d[n][n][0][1]),
              min(d[n][n][1][2],d[n][n][1][1]));
    if(ans<1e9)cout<<ans<<endl;
    else cout<<-1<<endl;
    return 0;
}
```

---

## 作者：HHC883 (赞：1)

# 题目分析
首先，这道题肯定是不能用 DP 做的，因为可以向上、下、左、右四个方向移动，不具有无后效性，而且转移特别复杂，用 DP 肯定不现实。

于是我们考虑使用最短路。

第一个问题是如何为格子编号。这很简单，我们可以将第 $x$ 行第 $y$ 列的格子编号为 $(x - 1)m + y$，这样不同的格子编号互不相同，于是我们就可以以每个格子为点建图了。

第二个问题是如何连边。这个只需要按照题目中规定的走法进行就可以了，但是要注意一些细节。

最后，跑一遍堆优化的 Dijkstra 即可。
# 参考代码
建边部分的代码特别长，但实际上是无脑的复制粘贴。
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
int m,n,mp[105][105],nxt[40005],head[10005],cnt,dis[10005];
bool vis[10005];
struct edge{
	int v,l;
} es[40005];
struct d{
	int to,dis;
};
bool operator<(d a,d b){
	return b.dis<a.dis;
}
priority_queue<d> q;
void link(int u,int v,int l){
	es[++cnt].v=v,es[cnt].l=l;
	nxt[cnt]=head[u];
	head[u]=cnt;
}
int get(int x,int y){
	return (x-1)*m+y;
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout.tie(0);
	cin>>m>>n;
	int x,y,c;
	for(int i=1;i<=n;i++){
		cin>>x>>y>>c;
		mp[x][y]=c+1;
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			if(!mp[i][j]) continue;
			if(mp[i+1][j]&&mp[i][j]==mp[i+1][j]) link(get(i,j),get(i+1,j),0);
			if(mp[i][j+1]&&mp[i][j]==mp[i][j+1]) link(get(i,j),get(i,j+1),0);
			if(mp[i-1][j]&&mp[i][j]==mp[i-1][j]) link(get(i,j),get(i-1,j),0);
			if(mp[i][j-1]&&mp[i][j]==mp[i][j-1]) link(get(i,j),get(i,j-1),0);
			if(mp[i+1][j]&&mp[i][j]!=mp[i+1][j]) link(get(i,j),get(i+1,j),1);
			if(mp[i][j+1]&&mp[i][j]!=mp[i][j+1]) link(get(i,j),get(i,j+1),1);
			if(mp[i-1][j]&&mp[i][j]!=mp[i-1][j]) link(get(i,j),get(i-1,j),1);
			if(mp[i][j-1]&&mp[i][j]!=mp[i][j-1]) link(get(i,j),get(i,j-1),1);
			if(!mp[i+1][j]) link(get(i,j),get(i+1,j),2);
			if(!mp[i][j+1]) link(get(i,j),get(i,j+1),2);
			if(!mp[i-1][j]) link(get(i,j),get(i-1,j),2);
			if(!mp[i][j-1]) link(get(i,j),get(i,j-1),2);
			if(mp[i+2][j]&&!mp[i+1][j]&&mp[i][j]==mp[i+2][j]) link(get(i,j),get(i+2,j),2);
			if(mp[i][j+2]&&!mp[i][j+1]&&mp[i][j]==mp[i][j+2]) link(get(i,j),get(i,j+2),2);
			if(mp[i-2][j]&&!mp[i-1][j]&&mp[i][j]==mp[i-2][j]) link(get(i,j),get(i-2,j),2);
			if(mp[i][j-2]&&!mp[i][j-1]&&mp[i][j]==mp[i][j-2]) link(get(i,j),get(i,j-2),2);
			if(mp[i+1][j+1]&&!mp[i+1][j]&&!mp[i][j+1]&&mp[i][j]==mp[i+1][j+1]) link(get(i,j),get(i+1,j+1),2);
			if(mp[i+1][j-1]&&!mp[i+1][j]&&!mp[i][j-1]&&mp[i][j]==mp[i+1][j-1]) link(get(i,j),get(i+1,j-1),2);
			if(mp[i-1][j+1]&&!mp[i-1][j]&&!mp[i][j+1]&&mp[i][j]==mp[i-1][j+1]) link(get(i,j),get(i-1,j+1),2);
			if(mp[i-1][j-1]&&!mp[i-1][j]&&!mp[i][j-1]&&mp[i][j]==mp[i-1][j-1]) link(get(i,j),get(i-1,j-1),2);
			if(mp[i+2][j]&&!mp[i+1][j]&&mp[i][j]!=mp[i+2][j]) link(get(i,j),get(i+2,j),3);
			if(mp[i][j+2]&&!mp[i][j+1]&&mp[i][j]!=mp[i][j+2]) link(get(i,j),get(i,j+2),3);
			if(mp[i-2][j]&&!mp[i-1][j]&&mp[i][j]!=mp[i-2][j]) link(get(i,j),get(i-2,j),3);
			if(mp[i][j-2]&&!mp[i][j-1]&&mp[i][j]!=mp[i][j-2]) link(get(i,j),get(i,j-2),3);
			if(mp[i+1][j+1]&&!mp[i+1][j]&&!mp[i][j+1]&&mp[i][j]!=mp[i+1][j+1]) link(get(i,j),get(i+1,j+1),3);
			if(mp[i+1][j-1]&&!mp[i+1][j]&&!mp[i][j-1]&&mp[i][j]!=mp[i+1][j-1]) link(get(i,j),get(i+1,j-1),3);
			if(mp[i-1][j+1]&&!mp[i-1][j]&&!mp[i][j+1]&&mp[i][j]!=mp[i-1][j+1]) link(get(i,j),get(i-1,j+1),3);
			if(mp[i-1][j-1]&&!mp[i-1][j]&&!mp[i][j-1]&&mp[i][j]!=mp[i-1][j-1]) link(get(i,j),get(i-1,j-1),3);
		}
	}
	memset(dis,0x3f,sizeof dis);
	dis[1]=0;
	q.push(d{1,0});
	while(!q.empty()){
		int minn=q.top().to;
		q.pop();
		if(vis[minn]) continue;
		vis[minn]=true;
		for(int i=head[minn];i;i=nxt[i]){
			if(dis[minn]+es[i].l<dis[es[i].v]){
				dis[es[i].v]=dis[minn]+es[i].l;
				q.push(d{es[i].v,dis[es[i].v]});
			}
		}
	}
	if(dis[m*m]>1e9) cout<<-1;
	else cout<<dis[m*m];
	return 0;
} 
```

---

## 作者：qsn123 (赞：1)

考虑直接建图，转化为从起点到终点的四联通最短路问题。不难发现有用的点数量只有有颜色的
$N$ 个，直接建图可行。

所以，问题来了：怎么连边？

答：以费用为边权，建出双向边（因为你也不知道具体走法），分类讨论所有情况即可。

首先，只考虑所有有颜色的格子。设现在所在的坐标为 $(x,y)$，考虑某一个相邻的格子，不妨设为 $(x,y+1)$。

若 $(x,y)$ 为红色，根据 $(x,y+1)$ 的颜色，有两种情况：

1. 若 $(x+1,y)$ 为红色，边权为 $0$。

2. 若 $(x+1,y)$ 为黄色，边权为 $1$。

按照这种规律处理所有有色点的四联通关系，写好程序，测试，~~你会发现你连样例都过不去。~~

所以我们还要考虑对于所有无色的格子。我们假设现在所在的无色格子为 $(x,y)$。发现我们如果希望走到一个无色格子上，就必须给它赋予一个颜色，分类讨论是困难的。而且题干中告诉我们，接下来必须走到一个**本来**就有颜色的格子。因此，实际上，无色格子是连接其四联通位置的枢纽，我们没有必要建出无色格子对应的点，只需要在它的四联通位置上直接连边即可。

对于无色格子 $(x,y)$ 的两个相邻格子，我们分类讨论其颜色情况：

1. 对于两个相同颜色的格子，我们只需要将无色格子变色为该颜色即可，建出边的边权为 $2$。

2. 对于两个颜色不同的格子，很显然，无论我们将无色格子变为哪个颜色，其必然与其中一个有色格子颜色相同。因此，走路的花费只有 $1$，加上变色的花费，建出边的边权为 $3$。

注意终点为无色格子的情况，这种情况就是终点相邻两个格子的较小值 $+2$ 即可，或者可以把终点特判建出来。

按照此图跑 Dijkstra 或者~~某个已经死了的~~算法均可以通过，本人代码使用的是 Dijkstra。

多说无益，上代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10050,inf=1e9+7;
int tt=0;
int h[N]={0},g[N*4]={0},v[N*4]={0},e[N*4]={0};
int d[N]={0};
bool b[N]={0};
int a[1050][1050]={0};
int dx[4]={1,-1,0,0};//用于方便计算四联通位置。
int dy[4]={0,0,1,-1};
priority_queue< pair<int,int> >q;
void add(int x,int y,int z){//前向星存图
	++tt;
	v[tt]=y;
	e[tt]=z;
	g[tt]=h[x];
	h[x]=tt;
	return ;
}
void djk(){//最短路
	int x,y,z;
	for(int i=1;i<N;i++)d[i]=inf;
	d[1]=0;
	q.push(make_pair(0,1));
	while(q.size()){
		x=q.top().second;
		q.pop();
		if(b[x]==1)continue;
		b[x]=1;
		for(int i=h[x];i;i=g[i]){
			y=v[i];
			z=e[i];
			if(d[y]>d[x]+z){
				d[y]=d[x]+z;
				q.push(make_pair(-d[y],y));
			}
		}
	}
	return ;
}
void build(int x,int y)
{
	for(int i=1;i<=x;i++){
		for(int j=1;j<=y;j++){
			if(a[i][j]==0)continue;
			for(int k=0;k<4;k++){//建边
				if(a[i+dx[k]][j+dy[k]]==a[i][j])add((i-1)*y+j,(i+dx[k]-1)*y+j+dy[k],0);
				else if(a[i+dx[k]][j+dy[k]]==(a[i][j]^1))add((i-1)*y+j,(i+dx[k]-1)*y+j+dy[k],1);
				else{
					for(int h=0;h<4;h++){
						if((h^1)==k)continue;
						if(a[i+dx[k]+dx[h]][j+dy[k]+dy[h]]==a[i][j])add((i-1)*y+j,(i+dx[k]+dx[h]-1)*y+j+dy[k]+dy[h],2);
						else if(a[i+dx[k]+dx[h]][j+dy[k]+dy[h]]==(a[i][j]^1))add((i-1)*y+j,(i+dx[k]+dx[h]-1)*y+j+dy[k]+dy[h],3);
					}
				}
			}
		}
	}
	if(a[x][y]==0){//特判终点
		if(a[x-1][y])add((x-1)*y,x*y,2);
		if(a[x][y-1])add(x*y-1,x*y,2);
	}
	return ;
}
int main()
{
	int n,m,ans;
	int x,y,z;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		a[x][y]=z+2;
	}
	build(n,n);
	djk();
	ans=d[n*n];
	if(ans==inf)cout<<"-1";
	else cout<<ans;
	return 0;
}
```

---

## 作者：beigongbaishan (赞：0)

## 思路

这道题我们考虑搜索，有三种情况：
1. 下一个格子颜色相同，无需花费金币。
2. 下一个格子颜色不同，需要花费 $1$ 个金币。
3. 下一个格子无色，需要施用魔法，将下一个格子变为指定的颜色，需要花费 $2$ 个金币。

如果施用了魔法，那么需要注意几个特殊的情况：
+ 魔法的时间很短暂，当你离开被施魔法的格子时，要将格子颜色恢复为无色。
+ 魔法不能连续施用，所以搜索时，我们还需要判断上一步是否施用了魔法。

## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005][1005],f[1005][1005],m,n,x,y,c;
void dfs(int i,int j,int c,bool flag,int w){
    if(i>m||i<1||j<1||j>m)return;
    f[i][j]=w;
    if(w+abs(c-a[i-1][j])<f[i-1][j]&&a[i-1][j]!=-1)dfs(i-1,j,a[i-1][j],1,w+abs(c-a[i-1][j]));
    if(w+abs(c-a[i][j-1])<f[i][j-1]&&a[i][j-1]!=-1)dfs(i,j-1,a[i][j-1],1,w+abs(c-a[i][j-1]));
    if(w+abs(c-a[i+1][j])<f[i+1][j]&&a[i+1][j]!=-1)dfs(i+1,j,a[i+1][j],1,w+abs(c-a[i+1][j]));
    if(w+abs(c-a[i][j+1])<f[i][j+1]&&a[i][j+1]!=-1)dfs(i,j+1,a[i][j+1],1,w+abs(c-a[i][j+1]));
    if(flag==1){// 上一步施用了魔法
        if(w+2<f[i-1][j]&&a[i-1][j]==-1)dfs(i-1,j,c,0,w+2);
        if(w+2<f[i][j-1]&&a[i][j-1]==-1)dfs(i,j-1,c,0,w+2);
        if(w+2<f[i+1][j]&&a[i+1][j]==-1)dfs(i+1,j,c,0,w+2);
        if(w+2<f[i][j+1]&&a[i][j+1]==-1)dfs(i,j+1,c,0,w+2);
    }
    return;
}
signed main(){
    memset(a,-1,sizeof(a));
    cin>>m>>n;
    for(int i=1;i<=n;i++){
        cin>>x>>y>>c;
        a[x][y]=c;
    }
    memset(f,127,sizeof(f));
    int s=f[m][m];
    dfs(1,1,a[1][1],1,0);
    if(f[m][m]==s)f[m][m]=-1;//无解 
    cout<<f[m][m];
}
```

---


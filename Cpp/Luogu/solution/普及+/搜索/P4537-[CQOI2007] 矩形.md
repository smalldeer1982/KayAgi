# [CQOI2007] 矩形

## 题目描述

给一个a\*b矩形，由a\*b个单位正方形组成。你需要沿着网格线把它分成非空的两部分，每部分所有格子连通，且至少有一个格子在原矩形的边界上。“连通”是指任两个格子都可以通过水平或者竖直路径连在一起。 求方案总数。例如3*2的矩形有15种方案。

![](https://cdn.luogu.com.cn/upload/pic/18502.png)

## 样例 #1

### 输入

```
3 2```

### 输出

```
15```

# 题解

## 作者：hhoppitree (赞：54)

### 题意简述：  

求用一条 **路**（**经过网格线，而不是方格**） 将 $a\times b$ 的矩形分为 **非空的** 两部分的方案数。  

### 题目解法：  

发现最后形成的路一定碰到边界。  

那么对于这个由 $a\times b$ 个小正方形组成的方格进行 **重新编号**，对于原先的正方形 $(x,y)$，规定它的右下角为 $(x,y)$，左上角为 $(x-1,y-1)$。这样，就变成了一张 $(n+1)\times (m+1)$ 的 **网格图**。  

由于 $n,m$ 较小在这张 $(n+1)\times (m+1)$ 的 **网格图** 上用 $\rm dfs$ 进行统计即可。  

如果 $n,m\le12$，则需用插头 $\rm DP$ 等神仙算法进行计算，类似 [从方格这头走向那头有多少种走法呢](https://www.bilibili.com/video/BV1Cx411D74e)。  

### 正确代码：  

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int res=0;
    char c;
    bool zf=0;
    while(((c=getchar())<'0'||c>'9')&&c!= '-');
    if(c=='-')zf=1;
    else res=c-'0';
    while((c=getchar())>='0'&&c<='9')res=(res<<3)+(res<<1)+c-'0';
    if(zf)return -res;
    return res;
}
int n,m;
bool vis[7][8];
int ans;
const int dx[]={0,0,-1,1},dy[]={-1,1,0,0};
void dfs(int x,int y){
	if(!x||!y||x==n||y==m){
		ans++;
		return;
	}
	vis[x][y]=1;
	for(register int i=0;i<4;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if(vis[xx][yy]){
			continue;
		}
		dfs(xx,yy);
	}
	vis[x][y]=0;
	return;
}
signed main(){
	n=read(),m=read();
	for(register int i=1;i<n;i++){
		vis[i][0]=1;
		dfs(i,1);
		vis[i][0]=0;
	}
	for(register int i=1;i<m;i++){
		vis[0][i]=1;
		dfs(1,i);
		vis[0][i]=0;
	}
	cout<<ans<<'\n';
	return 0;
}
```  

如果您没有看懂这篇题解，可以在评论区问我，我将会回答您的问题并且修改这篇题解，使它变得更加通俗易懂，服务更多的 $\text{OIer}$。  
如果您看懂了这篇题解，可以点个赞，使这篇题解的排名上升，服务更多的 $\text{OIer}$。  

---

## 作者：VenusM1nT (赞：19)

一道`SB`题，大力爆搜分界线，如果到边界外了让答案$++$即可

因为保证方案不同，所以搜两趟即可

（怎么评成紫的，牛逼）

见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
int dx[]={0,1,-1,0,0},dy[]={0,0,0,1,-1};
bool vis[15][15];
void Dfs(int x,int y)
{
	if(x<1 || x>=n || y<1 || y>=m) ans++;
	else
	{
		vis[x][y]=1;
		for(int i=1;i<=4;i++)
		{
			int nx=x+dx[i],ny=y+dy[i];
			if(!vis[nx][ny]) Dfs(nx,ny);
		}
		vis[x][y]=0;
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<n;i++)
	{
		memset(vis,0,sizeof(vis));
		vis[i][0]=1;
		Dfs(i,1);
	}
	for(int i=1;i<m;i++)
	{
		memset(vis,0,sizeof(vis));
		vis[0][i]=1;
		Dfs(1,i);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：crashed (赞：14)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P4537)看题目。  
# 分析
&emsp;&emsp;插头 DP ，考虑枚举一下两块之间的分割线，本质上就是两个端点都在边界上的路径。   
&emsp;&emsp; DP 过程中，我们将**没有端点在边界上面的路径称为 1 路径，反之叫 2 路径**。  
&emsp;&emsp;对于 1 路径，我们不能中途把它连成环，因此 1 路径的插头需要用括号序表示（最小整数也可以，只要能判掉连通性就可以了）。  
&emsp;&emsp;接着对插头分一下类：  
&emsp;&emsp;1.一条 1 路径的左端点，编号为 1 。  
&emsp;&emsp;2.一条 1 路径的右端点，编号为 2 。  
&emsp;&emsp;3.一条 2 路径的一个端点，编号为 3 。（如果有 3 插头，那么这个 2 路径的另一个端点就在边界上）  
&emsp;&emsp;由于插头只有 4 种情况，因此我们使用 4 进制来压缩状态。  
&emsp;&emsp;另外，我们只能在边界上放$2$个端点，因此需要再开一维来记录一下。  
&emsp;&emsp; DP 状态如下：  
&emsp;&emsp;$f(i,j,S,c)$：格子$(i,j)$的轮廓线状态为$S$，并且在边界上放了$c$个端点的方案数。  
&emsp;&emsp;转移嘛......写起来相当复杂，但是分类讨论本身不难想，所以想看就去代码里找吧qwq~~逃了~~。  
# 代码
```cpp
#include <cstdio>
#include <cstring>

#define l j - 1
#define u j
#define d j - 1
#define r j
#define mov( x ) ( x << 1 )
#define mp( x ) grid[x.first][x.second]

const int MAXN = 20, MAXM = 20, MAXS = ( 1 << 20 ) + 5; 
//空间开大，不太清楚为什么qwq 

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct table
{
	int f[MAXS], stk[MAXS], siz;
	table() { memset( f, 0, sizeof f ), memset( stk, 0, sizeof stk ), siz = 0; }
	int operator [] ( const int indx ) const { return f[stk[indx]]; }
	int operator () ( const int indx ) const { return stk[indx]; }
	void add( int S, int v ) { if( ! f[S] ) stk[++ siz] = S; f[S] += v; }
	void clear() { while( siz ) f[stk[siz --]] = 0; }
};

struct DP_Structure
{
	table F[3];
	table& operator [] ( const int indx ) { return F[indx]; }
	void clear() { for( int i = 0 ; i < 3 ; i ++ ) F[i].clear(); }
}dp[2];

int stk[MAXM] = {}, top;
int state[MAXM], matched[MAXM];
int grid[MAXN][MAXN];
int N, M, pre = 1, nxt = 0;

void prepare() { pre ^= 1, nxt ^= 1, dp[nxt].clear(); }
int get( int x, int y ) { return ( x >> mov( y ) ) & 3; }
int clr( int x, int y ) { return x & ( ~ ( 3 << mov( y ) ) ); }
int reset( int x, int y, int z ) { return clr( x, y ) | ( z << mov( y ) ); }
int dbset( int x, int y, int a, int b = -1 ) { return reset( reset( x, y, a ), y + 1, ~ b ? b : a ); }

void match()
{
	for( int i = 0 ; i <= M ; i ++ )
	{
		if( state[i] == 1 ) stk[++ top] = i;
		if( state[i] == 2 ) matched[stk[top]] = i, matched[i] = stk[top --];
	}
}

int encode( int *sta )
{
	int ret = 0;
	for( int i = M ; ~ i ; i -- ) ret = ( ret << 2 ) + sta[i];
	return ret;
}

void decode( int *sta, int val )
{
	memset( sta, 0, MAXM * 4 );
	for( int i = 0 ; i <= M ; i ++ ) sta[i] = val & 3, val >>= 2;
	match();
}

int main()
{
	int S, v, lef, up, mtL, mtU;
	read( N ), read( M );
	N ++, M ++;
	if( N > M ) N ^= M, M ^= N, N ^= M;
	for( int i = 2 ; i < N ; i ++ )
		for( int j = 2 ; j < M ; j ++ )
			grid[i][j] = 1;
	for( int i = 2 ; i < M ; i ++ ) grid[1][i] = grid[N][i] = 2;
	for( int i = 2 ; i < N ; i ++ ) grid[i][1] = grid[i][M] = 2;
	prepare();
	dp[nxt][0].add( 0, 1 );
	for( int i = 1 ; i <= N ; i ++ )
	{
		prepare();
		for( int c = 0 ; c <= 2 ; c ++ )
			for( int k = 1 ; k <= dp[pre][c].siz ; k ++ )
				if( ! get( dp[pre][c]( k ), M ) )
					dp[nxt][c].add( dp[pre][c]( k ) << 2, dp[pre][c][k] );
		for( int j = 1 ; j <= M ; j ++ )
		{
			prepare();
			for( int c = 0 ; c <= 2 ; c ++ )
				for( int k = 1 ; k <= dp[pre][c].siz ; k ++ )
				{
					S = dp[pre][c]( k ), v = dp[pre][c][k];
					lef = get( S, l ), up = get( S, u );
					if( grid[i][j] == 0 ) { if( ! lef && ! up ) dp[nxt][c].add( S, v ); continue; }
					decode( state, S );
					if( grid[i][j] == 2 )
					{
						dp[nxt][c].add( S, v );
						if( c == 2 ) continue;
						if( i == 1 ) { if( ! lef && ! up ) dp[nxt][c + 1].add( reset( S, d, 3 ), v ); }
						if( j == 1 ) { if( ! lef && ! up ) dp[nxt][c + 1].add( reset( S, r, 3 ), v ); }
						//在上边界与左边界放端点，会在轮廓线上新增 3 插头 
						if( i == N ) 
						{ 
							if( lef || ! up ) continue; 
							if( up == 3 ) dp[nxt][c + 1].add( dbset( S, d, 0 ), v );
							else
							{
								state[matched[u]] = 3, state[u] = 0; 
								dp[nxt][c + 1].add( dbset( encode( state ), d, 0 ), v ); 
							}
						}
						if( j == M ) 
						{ 
							if( ! lef || up ) continue;
							if( lef == 3 ) dp[nxt][c + 1].add( dbset( S, d, 0 ), v );
							else
							{
								state[matched[l]] = 3, state[l] = 0;
								dp[nxt][c + 1].add( dbset( encode( state ), d, 0 ), v ); 
							}
						}
						//在下边界与右边界放端点，会与已有插头连接；如果已有插头不是 3 插头，就需要考虑 3 插头移动的情况 
					}
					else
					{
						if( ! lef && ! up ) dp[nxt][c].add( S, v ), dp[nxt][c].add( dbset( S, d, 1, 2 ), v );
						if( lef && ! up ) dp[nxt][c].add( S, v ), dp[nxt][c].add( dbset( S, d, 0, lef ), v );
						if( ! lef && up ) dp[nxt][c].add( S, v ), dp[nxt][c].add( dbset( S, d, up, 0 ), v ); 
						if( lef && up )
						{
							mtL = matched[l], mtU = matched[u];
							state[d] = state[r] = 0;
							if( lef == 3 && up ^ 3 ) state[mtU] = 3;
							if( lef ^ 3 && up == 3 ) state[mtL] = 3;
							//考虑 3 插头移动的情况 
							if( lef == 1 && up == 1 ) state[mtU] = 1;
							if( lef == 2 && up == 2 ) state[mtL] = 2;
							//正常括号转移 
							if( lef ^ 1 || up ^ 2 ) dp[nxt][c].add( encode( state ), v );
							//需要把会连成环的情况判掉 
						}
					}
				}
		}
	}
	write( dp[nxt][2][0] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：XL4453 (赞：7)



------------
解题思路：

暴力枚举起点，搜索终点即可。

注意利用矩形的对称性，只需要搜索一半（即两条边）就可以了。

毕竟从一端出发的点最终一定能找到一条一模一样的返回路径，而这是不合法的。

------------
代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int v[10][10],n,m,dx[5]={0,0,1,-1},dy[5]={1,-1,0,0};
long long ans;
void dfs(int x,int y){
	if(x<1||x>=n||y<1||y>=m){
		ans++;
		return;
	}
	v[x][y]=1;
	for(int i=0;i<=3;i++){
		if(!v[x+dx[i]][y+dy[i]]){
			dfs(x+dx[i],y+dy[i]);
		}
	}
	v[x][y]=0;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<m;i++){
		memset(v,0,sizeof(v));
		v[0][i]=1;
		dfs(1,i);
	}
	for(int i=1;i<n;i++){
		memset(v,0,sizeof(v));
		v[i][0]=1;
		dfs(i,1);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：limi_sanhua (赞：7)

分享给汝一个~~代码较长的~~沙雕做法——~~但目前看来大概是**最快的**不打表做法~~？

1.节点间建边，每个节点的标号为(i-1)*M+j。

**注意建边**：如此图，正常建的双向变有6-7,7-11,10-11,6-10,这些边在循环里建（见代码），特别地建2-6,3-7,5-6,9-10,14-10,15-11,12-11,8-7，这些边，因为这些边如果和正常边混起来的话会建立如2-3,3-4,14-15,这些边，这样跑图时假如从一个边界点(如2)开始跑，会直接跑到另一个边界点(如3)而不经过正常边，导致错解，因为这样并没有分割整个长方形。~~ _~~咱好像有些啰嗦了呢~~_ ~~

2.边界点存标记数组中。

3.然后跑一半的一半边界节点(如图的2,5)然后ans<<1，因为2与3是对称的，5与9是对称的，左边所有边界点和右边又是对称的，上下同理。

4.这种方法跑得快（~~可能吧~~），主要是因为利用了2次**对称性**（~~咱觉得是这样~~）。
![图](https://cdn.luogu.com.cn/upload/pic/55859.png)
```cpp
// luogu-judger-enable-o2
#pragma GCC optimize("Ofast")
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define u int
#define ri register int
#define NN 60
#define MM 60
void in(u &x) {
    x=0;
    u f(1);
    char s=getchar();
    while(s<'0'||s>'9') {
        if(s=='-') {
            f=-f;
        }
        s=getchar();
    }
    while(s>='0'&&s<='9') {
        x=x*10+s-'0';
        s=getchar();
    }
    x*=f;
}
void out(u x) {
    if(x<0) {
        putchar('-');
        x=-x;
    }
    if(x>9) {
        out(x/10);
    }
    putchar(x%10+'0');
}
u N,M,now,mx,my,st[NN],nn,f[5][10][10],dx[5]= {0,-1,0,1,0},dy[5]= {0,0,1,0,-1},h[NN],cnt,ans,vt[NN],can[NN],mr[10][10],num;
u compu(ri x,ri y) {//计算节点编号的函数
    return (x-1)*M+y;
}
struct kkk {
    u to,next;
} a[300];
struct node {
    u x,y;
} inf[300];
void edge(ri x,ri y) {
    a[++cnt].to=y;
    a[cnt].next=h[x];
    h[x]=cnt;
}
void dfs(ri x,ri z) {
    if(can[x]) {
        ++ans;
        ++now;//增加碰壁次数
        if(now==2) {//若已经碰壁2次（因为出发点也是墙壁，算了一次，所以是碰壁2次），就说明搜到的一个切割方法（即线路），需要返回了
            --now;
            return;
        }
    }
    for(ri i=h[x]; i; i=a[i].next) {
        if(!vt[a[i].to]) {
            vt[a[i].to]=1;
            dfs(a[i].to,can[a[i].to]);
            vt[a[i].to]=0;//记得撤销 
        }
    }
}
void sim(ri i) {
    vt[i]=1;
    dfs(i,1);
    vt[i]=0;
    --ans;//出发点是算了ans的，所以减去
    now=0;
}
void ss2() {
    //sim(i)意思就是说从i点开始跑dfs，以及之后的一系列有关操作函数
    for(ri i=2; i<=M/2; ++i) {
        sim(i);
    }
    ri x;
    for(ri i=2; i<=N/2; ++i) {
        x=mr[i][1];
        sim(x);
    }
    ans<<=1;//注意是在这里就<<
    if((M&1)) {//处理奇数情况
        sim(M/2+1);
    }
    if((N&1)) {//处理奇数情况
        sim(mr[N/2+1][1]);
    }
    out(ans);
}
int main() {
    //freopen("x.txt","r",stdin);
    in(N);
    in(M);
    ++N;
    ++M;//++N,++M意思是线条的数量而不是格子，因为分界线是在线条上跑的对吧 
    for(ri i=1; i<=N; ++i) {
        for(ri j=1; j<=M; ++j) {
            inf[mr[i][j]=compu(i,j)].x=i;
            inf[mr[i][j]].y=j;
        }
    }
    ri x,y;
    //以下循环是在建正常边
    for(ri i=1; i<=N; ++i) {
        for(ri j=1; j<=M; ++j) {
            if(i==1||j==1||i==N||j==M) {
                can[mr[i][j]]=1;//记录下墙壁序号
            } else
                for(ri k=1; k<=4; ++k) {//上下左右的方向呐 
                    x=i+dx[k];
                    y=j+dy[k];
                    if(x>=1&&x<=N&&y>=1&&y<=M) {
                        edge(mr[i][j],mr[x][y]);
                    }
                }
        }
    }
    //以下是在建特殊边
    for(ri i=2; i<=M-1; ++i)edge(mr[1][i],mr[2][i]);
    for(ri i=2; i<=M-1; ++i)edge(mr[N][i],mr[N-1][i]);
    for(ri i=2; i<=N-1; ++i)edge(mr[i][1],mr[i][2]);
    for(ri i=2; i<=N-1; ++i)edge(mr[i][M],mr[i][M-1]);
    ss2();
}
```
5.据咱猜测，可能以后会出现极快速的**分治**做法？？？~~（才不告诉汝是因为咱想了一下午分治没想出来）~~

6.另外，如果汝认为分治是不行的，欢迎汝在评论区交流

7.最后，如果汝觉得本文~~删除线~~太多，~~欢迎在评论区**吐槽**~~

**溜**

---

## 作者：C20192413 (赞：6)

前言：并不是用Luogu博客的人，只是写写

可以用块状插头 $dp$


一开始让 $(1,1)$ 为黑色就变成了：

求一个黑色连通块方案数并且有白色挨边界的方案数

$f_{i,j,S,c,t,w}$:当前到了 $(i,j)$ 的扫描块连通情况为 $S$ （最小表示法）,颜色情况为 $c$ ，是否有白色挨边界 $t$ ,是否还能放白色 $w$

其中 $t,w$ 取值都是 $01$ ， $c$ 是 2 进制，
$S$ 由于地图很小，最多有 $4$ 种取值用 8 进制

转移类似扫描线，但是要注意扫描线全白和全黑情况，以及独立连通块不合法

非打表 60~70ms 左右

还有一种扫描线的思路就是类似暴力用分割线

分割点拉出来构成（n-1）*(m-1)的矩形

然后根据CDQ论文可以在边界放两个端点插头，加一维(0,1,2)表示边界上放了几个端点插头，dp即可

时间跟上面差不多（主要跟写法有关）

可以做做 Black&White 那道题目，思路相似可以练习

```cpp
#include<set>    
#include<map>    
#include<stack>    
#include<ctime>    
#include<cstdio>    
#include<queue>    
#include<cmath>    
#include<vector>    
#include<cstring>   
#include<climits>    
#include<iostream>   
#include<algorithm>
using namespace std;
#define LL long long
#define ULL unsigned long long
int read(){
    int f=1,x=0;char c=getchar();
    while(c<'0'||'9'<c){if(c=='-')f=-1;c=getchar();}
    while('0'<=c&&c<='9'){x=x*10+c-'0';c=getchar();}
    return f*x;
}
#define MAXN 12
#define Mod 199999
#define INF 0x3f3f3f3f
int n,m,nw,lst,nx,ny,siz[2];
int head[Mod+5],nxt[Mod+5];
int tag[2][Mod+5],f[2][Mod+5],sta[2][Mod+5],col[2][Mod+5],wh[2][Mod+5];
void Add(int s,int cnt,int c,int t,int w){
	int tmp=s%Mod;
	//printf("s:%d c:%d t:%d ",s,c,t);
	for(int i=head[tmp];i;i=nxt[i])
		if(sta[nw][i]==s&&col[nw][i]==c&&tag[nw][i]==t&&wh[nw][i]==w){
			f[nw][i]+=cnt;
		//	printf("cnt:%d\n",f[nw][i]);
			return ;
		}
	nxt[++siz[nw]]=head[tmp],head[tmp]=siz[nw],tag[nw][siz[nw]]=t;
	sta[nw][siz[nw]]=s,f[nw][siz[nw]]=cnt,col[nw][siz[nw]]=c,wh[nw][siz[nw]]=w;
	//printf("cnt:%d\n",f[nw][siz[nw]]);
	return ;
}
int a[MAXN+5],num[MAXN+5];
void Open(int s){
	for(int i=0;i<m;i++)
		a[i]=s&7,s>>=3;
	return ;
}
int Zip(){
	memset(num,-1,sizeof(num));
	int k=-1;
	int ret=0;
	for(int i=m-1;i>=0;i--){
		if(num[a[i]]==-1)
			num[a[i]]=++k;
		ret=(ret<<3)|num[a[i]];
	}
	return ret;
}
void Replace(int x,int y){
	for(int i=0;i<m;i++)
		if(a[i]==x)
			a[i]=y;
	return ;
}
void Fill(int i,int j,int c){
	//puts("");
	//printf("%d %d %d\n",i,j,c);
	for(int k=1;k<=siz[lst];k++){
		int s=sta[lst][k],cc=col[lst][k],cnt=f[lst][k],tt=tag[lst][k],w=wh[lst][k];
		int l=0,u=0;
		if(i>0)
			u=(((cc>>j)&1)==c);
		if(j>0)
			l=(((cc>>(j-1))&1)==c);
		Open(s);
		if(cc==0&&c==1&&!(i==0&&j==0))//全白不放黑
			continue;
		if(cc==(1<<m)-1&&c==0&&w)//全黑可放白
			continue;
		if(i>0&&!u){
			int s1=0,s2=0;
			for(int t=0;t<m;t++){
				if(a[t]==a[j])
					s1++;
				if(((cc>>t)&1)!=c)
					s2++;
			}
			if(s1==1&&s2>1)//独立连通块
				continue;
		}
		if(l&&u){
			if(a[j]!=a[j-1])
				Replace(a[j],a[j-1]);
		}
		else if(l&&!u)
			a[j]=a[j-1];
		else if(!l&&!u)
			a[j]=m;//else same
		if(c)
			cc|=(1<<j);
		else
			cc&=~(1<<j);
		Add(Zip(),cnt,cc,tt|(!c&&(!i||!j||i==n-1||j==m-1)),w|(!c));
	}
	return ;
}
void Dp(){
	nw=0;
	memset(head,0,sizeof(head)),siz[nw]=0;
	Add(0,1,0,0,0);
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++){
			lst=nw,nw^=1;
			memset(head,0,sizeof(head)),siz[nw]=0;
			if(i||j)//(0,0)必放黑
				Fill(i,j,0);
			Fill(i,j,1);
		}
	int ret=0;
	for(int i=1;i<=siz[nw];i++){
		int tmp=0,tt=tag[nw][i];
		if(!tt) continue;
		Open(sta[nw][i]);
		for(int j=0;j<m;j++)
			tmp=max(tmp,a[j]);
		if(tmp>1)
			continue;
		ret+=f[nw][i];
	}
	printf("%d\n",ret);
	return ;
}
int main(){
	n=read(),m=read();
	Dp();
	return 0;
}
```



---

## 作者：panyf (赞：4)

思路很明显，就是枚举起点，分界线爆搜，不过你们似乎少了一个剪枝，就是**利用矩形的对称性，只需枚举一半的起点即可**。加上剪枝后效率翻倍，1s能跑过a=b=7的数据，而且成功获得本题非打表rank1，107msAC(最优解在我前面的都是打表过去的)，而且代码很短，只有20多行，跑得不比你们100多行的慢

代码及注释如下：

```cpp
#include<cstdio>
const int nx[4]={0,0,-1,1},ny[4]={1,-1,0,0};
bool v[9][9];
int s,a,b;
void dfs(int x,int y){
	if(!x||!y||x==a||y==b){//出界就更新答案
		++s;
		return;
	}
	v[x][y]=1;
	for(register int i=0,j,k;i!=4;++i){
		j=x+nx[i],k=y+ny[i];
		if(!v[j][k])dfs(j,k);
	}
	v[x][y]=0;//记得回溯
}
int main(){
	register int i;
	scanf("%d%d",&a,&b);
	for(i=1;i+i<a;++i)v[i][0]=1,dfs(i,1),v[i][0]=0;//i为搜索起点，由于与之对称的点答案相同，只需枚举到a/2即可
	for(i=1;i+i<b;++i)v[0][i]=1,dfs(1,i),v[0][i]=0;
	s<<=1;//答案要乘2，因为少枚举了一半
	if(!(a&1))i=a>>1,v[i][0]=1,dfs(i,1),v[i][0]=0;//处理中间没有搜到的部分
	if(!(b&1))i=b>>1,v[0][i]=1,dfs(1,i),v[0][i]=0;
	printf("%d",s);
	return 0;
}
```


---

## 作者：旋转卡壳 (赞：4)

数据范围有点水 可以直接搜索过 紫题难度过分了

很自然地可以想出可以爆搜出【两个块之间】的【分界线的方案数】

可以选择从四个边出发 搜四次 然后答案除以2 因为分界线的起点为(a,b)终点为(c,d)与起点为(c,d)终点为(a,b)是一样的

所以我们也可以选择 搜横竖各一次就行了 要不然可能会T


一开始的搜索可以看成从边界伸出一个单位长度的线 这里看下代码就懂了

搜到边界就++ans 感觉没啥好讲的

坐标的话 就是点图 (0,0)为左上角 (1,3)表示第一行第三个格子的右下角

```cpp
#include <cstdio>

using namespace std;

int n,m,ans,vis[50][50];
int dx[]={0,1,-1,0,0},dy[]={0,0,0,1,-1};

void dfs(int x,int y) {
	if(x<1||x>=n||y<1||y>=m) {++ans;return ;}
	for(register int i=vis[x][y]=1;i<=4;++i)
		if(!vis[x+dx[i]][y+dy[i]]) dfs(x+dx[i],y+dy[i]);
	vis[x][y]=0;
}

int main() {
	scanf("%d %d",&n,&m);
	//for(register int i=1;i<n;++i) vis[i][0]=1,dfs(i,1),vis[i][0]=0;
	//for(register int i=1;i<m;++i) vis[0][i]=1,dfs(1,i),vis[0][i]=0;
	//for(register int i=1;i<n;++i) vis[i][m]=1,dfs(i,1),vis[i][m]=0;
	//for(register int i=1;i<m;++i) vis[n][i]=1,dfs(1,i),vis[n][i]=0;
	//printf("%d",ans>>1);
	for(register int i=1;i<n;++i) vis[i][0]=1,dfs(i,1),vis[i][0]=0;
    for(register int i=1;i<m;++i) vis[0][i]=1,dfs(1,i),vis[0][i]=0;
    printf("%d",ans);
	return 0;
}
```


---

## 作者：Otomachi_Una_ (赞：2)

拿到这道题，第一眼看数据范围，$1≤a≤6,2≤b≤7$，会想到一个叫 dfs 的好东西。

### 枚举方格颜色做法
对每个方格的颜色进行枚举，再判断是否连通。时间复杂度 $O(nm2^{nm})$，目标得分 $30pts$。

### 枚举分割线做法

因为黑白两部分总是连通，所以存在有且只有一条连续的“黑白分割线”。如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/sz7q9m8n.png)

现在，我们只需要枚举这个分割线即可。另外因为有部分格子要贴边，所以可以从边上开始枚举。

时间复杂度 $O(2^{nm})$ 常数很小，目标得分 $100pts$。

### 拓展

若 $n,m≤12$，可以使用插头 dp。

### Code
```cpp
#include<iostream>
using namespace std;
const int MAXN=8;
int n,m;
int ans=0;
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
bool vis[MAXN][MAXN];
void dfs(int x,int y){
	if(!x||!y||x==n||y==m){
		ans++;
		return;
	}
	vis[x][y]=true;
	for(int i=0;i<4;i++)
		if(!vis[x+dx[i]][y+dy[i]])
			dfs(x+dx[i],y+dy[i]);
	vis[x][y]=false;
	return;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<n;i++){
		vis[i][0]=true;
		dfs(i,1);
		vis[i][0]=false;
	}
	for(int i=1;i<m;i++){
		vis[0][i]=true;
		dfs(1,i);
		vis[0][i]=false;
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：yzh_Error404 (赞：2)

[双倍经验1](https://www.luogu.com.cn/problem/P1817)

[双倍经验2](https://www.luogu.com.cn/problem/P1790)

本题正解[插头DP](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E6%8F%92%E5%A4%B4DP&fenlei=256&rsv_pq=efeaadb300051d30&rsv_t=164fn9SvNzwtPlsEPW%2FsxGMonLYh%2F5x%2BS2sSiiANTxSvvAKDxvjU8HUadu0&rqlang=cn&rsv_dl=tb&rsv_enter=1&rsv_sug3=11&rsv_sug1=10&rsv_sug7=101&rsv_sug2=0&rsv_btype=i&inputT=3864&rsv_sug4=4268)，可惜我太垃圾了不会。

一看数据范围 $a \le 6$ ，$b \le 7$ 。

数据范围这么小，~~一看就可以打表~~。

用 $dfs$ 爆搜出分界线的种数即可。

因为分界线有两个端点，两边连过来的方案是一样的，所以我们只考虑以上面和右边为起点的方案。

打表程序：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=10;
struct node
{
	int x,y;
};
int n,m;
int fx[MAXN]={0,-1,1,0,0};
int fy[MAXN]={0,0,0,-1,1};
int vis[MAXN][MAXN];
int ans=0;
inline void dfs(int x,int y)
{
	vis[x][y]=1;
	for(int i=1;i<=4;i++)
	{
		int nx=x+fx[i],ny=y+fy[i];
		if(x<1||x>=n||y<1||y>=m)ans++;//到了矩阵外面，需要计数
		else
        if(!vis[nx][ny])dfs(nx,ny);
	}
	vis[x][y]=0;
}
signed main()
{
	freopen("test.out","w",stdout);
	for(n=1;n<=6;n++)
	{
		printf("{");
		for(m=1;m<=7;m++)
		{
			ans=0;
			for(register int i=1;i<n;i++)
			{
				memset(vis,0,sizeof(vis));
				vis[i][0]=1;
				dfs(i,1);
			}
			for(register int i=1;i<m;i++)
			{
				memset(vis,0,sizeof(vis));
				vis[0][i]=1;
				dfs(1,i);
			}
			printf("%lld",ans);
			if(m!=8)printf(",");
		}
		printf("}");
		if(n!=7)puts(",");
		else puts(";");
	}
	return 0;
}
```
打出来的表：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int ans[10][10]={{0,2,4,6,8,10,12,14},
				 {2,12,30,56,90,132,182,240},
				 {4,30,104,286,700,1598,3488,7390},
				 {6,56,286,1228,4862,18368,67206,240180},
				 {8,90,700,4862,32000,204294,1274660,7807790},
				 {10,132,1598,18368,204294,2228788,23896710,252488208},
				 {12,182,3488,67206,1274660,23896710,441524056,8056291934}};
signed main()
{
	int n,m;
	scanf("%lld%lld",&n,&m);
	printf("%lld",ans[n-1][m-1]/2);//一定要减一！
   //上一道题的表需要乘2，现在除回来
	return 0;
}
```

---

## 作者：light_ght (赞：1)

# dfs


------------
[题目](https://www.luogu.com.cn/problem/P4537)

[**博客食用风味佳**](https://www.luogu.com.cn/blog/Rstar-PanzerTigerII/solution-p4537)

据说这题以前是紫色的？？？感觉错过了一个亿的Exp（做个[**双倍经验** ](https://www.luogu.com.cn/problem/P1790)压压惊）
## 大致分析


------------


- 维护两个边界 $ x , y$ ，如果超出边界 $ {a , b}$  直接使答案计数器+1。由于满足一搜到底的结构，显而易见可以使用~~爆搜~~ **dfs**。

- 实现过程中，要注意**判重**——使用一个数组来记录是否已经访问过。

- 同时也需要注意判重数组的赋初值、回溯赋值等细节。


详细说明请看代码注释。

~~不过这数据范围给打表开了一扇窗······~~

## 具体实现+具体说明（dfs版）

只贴**核心代码：**（注：本蒟蒻在某些小小的地方做了个反作弊）

```cpp

int a,b,ans;
int X[]={1,-1,0,0},Y[]={0,0,1,-1};	//移动操作
bool been[10][10];	//been[]是标记是否已经访问过の数组 

void pan(int x,int y)	//dfs，对象为两个边界 
{
	if(x<1||y<1||x>=a||y>=b)ans++;	//超出边界，ans+1 
	else
	{
		been[x][y]=true;	//预设该位置已经访问过，准备dfs
		for(int i=0;i<4;i++)          
			if(!been[x+X[i]][y+Y[i]])  
				pan(x+X[i],y+Y[i]);		
		been[x][y]=false;	//dfs完成后回溯
	}return; //啥也不干
}
int main()
{
ios::sync_with_stdio(0);
cin.tie(0)；cout.tie(0);//加速cin、cout(不建议使用，加速完也没有scanf/printf快) 
	cin>>a>>b;
	for(int i=1;i<a;i++)	//第一次以任意一个方向开始dfs。对结果无影响
	{
		memset(been,false,sizeof been);	//初始化been数组为未访问
		been[i][0]=true;	//记录访问
		pan(i,1);	
	}
	for(int i=1;i<b;i++)	//另外一个方向のdfs同理
	{
		memset(been,false,sizeof been);
		been[0][i]=true;
		pan(1,i);
	}
	cout<<ans;
	return 0;
//By xajdfz OIer ght,programme v1.0.00.0
//Developed by GHT's Lab 2021-2021, GHT's 蒟蒻工厂. All rights reserved.
}

```
为防止本蒟蒻重回蓝名发篇题解~忘管理员大大高抬贵手~

**完**


---

## 作者：Seauy (赞：1)

## 前面的大佬都用搜索直接过了，很强的
我也用的是搜索，跟下面的大佬们都差不多

但是在这里要介绍一下一个优化，小小的常数优化，但是能比其它题解快不少……

首先先展示一下我几个结构体和变量的定义

```cpp
const int MAXA=6;
const int MAXB=7;

const short direx[]={0,1,0,-1};//四个方向
const short direy[]={1,0,-1,0}; 

struct Point//其实就是把坐标放进结构体里了
{
	int x,y;
	const bool operator == (Point ob)//坐标相同
	{return x==ob.x && y==ob.y;}
	void Walk(short dire)//移动
	{x+=direx[dire],y+=direy[dire];} 
};

int a,b,ans;
bool visit[MAXA+5][MAXB+5];
```
然后有一点不同，我把 DFS 写成了返回值类型（其实无关紧要）

```cpp
bool AtEdge(Point ob)//在边界，这条线就画完了
{return ob.x==1 || ob.x==b+1 || ob.y==1 || ob.y==a+1;}

int DFS(Point now)
{
	if(visit[now.y][now.x]) return 0;
	visit[now.y][now.x]=1;
	//Print_map(now);
	if(AtEdge(now))
	{
		visit[now.y][now.x]=0;
		return 1;
	}
	int cnt=0;
	for(short i=0;i<4;i++)
	{
		Point rear=now;
		rear.Walk(i);
		cnt+=DFS(rear);
	}
	visit[now.y][now.x]=0;
	return cnt;
}
```
接下来就是有优化的地方了，由于矩形是轴对称的，所以一条分割线从 (x,1) 开始划的方案数其实跟 (b-x+1,1) 开始划的方案数是一样的，从 (1,y) 跟 (1,a-y+1) 一样也是一个道理

于是就可以这么写：
```cpp
for(int i=2;i<=(((b+1)>>1)+(b+1)%2);i++)//如果是奇数，那中间的情况（在对称轴上）还是要再算一遍的
{
  	visit[1][i]=1;
  	if(i<=((b+1)>>1)) ans+=2*DFS(Point{i,2});
  	else ans+=DFS(Point{i,2});//在对称轴
  	visit[1][i]=0;
}
for(int i=2;i<=(((a+1)>>1)+(a+1)%2);i++)//形如上面
{
	visit[i][1]=1;
	if(i<=((a+1)>>1)) ans+=2*DFS(Point{2,i});
	else ans+=DFS(Point{2,i});
	visit[i][1]=0;
}
```
当然，你想更简练还可以这么写：
```cpp
for(int i=2;i<=(((b+1)>>1)+(b+1)%2);i++)
{
	visit[1][i]=1;
	ans+=(1+(i<=((b+1)>>1)))*DFS(Point{i,2});
	visit[1][i]=0;
}
for(int i=2;i<=(((a+1)>>1)+(a+1)%2);i++)
{
	visit[i][1]=1;
	ans+=(1+(i<=((a+1)>>1)))*DFS(Point{2,i});
	visit[i][1]=0;
}
```
实测这么写比上面那种快一点点点点点点……

虽然说还是搜索，~~很黄很暴力~~，但是成功地把前面的系数给减半了

可以去测评记录里看，这么写比其它题解快很多（然而还是在第二页最上方，向打表势力低头 orz）

然后，你又可以华丽地A一道紫题，虽然说很容易掉难度，但是还是很 Excited 有木有！？

---

## 作者：lgnotus (赞：1)

## 题目描述

给一个$a\times b$矩形，由$a\times b$个单位正方形组成。你需要沿着网格线把它分成非空的两部分，每部分所有格子连通，且至少有一个格子在原矩形的边界上。“连通”是指任两个格子都可以通过水平或者竖直路径连在一起，求方案总数。

## 思路

从边界开始搜起（注意分界线的起点一定不能在边上四个角），搜索中如果到了边界，即搜到一个方案，答案加1。

### 注意

*	dfs一次后要把vis数组归为0，memset不能用多，还是乖乖的去写循环重置。。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int vis[10][10],ans;
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
void set_vis()
{
    for(int i=0;i<=n;i++)for(int j=0;j<=m;j++)vis[i][j]=0;
}
bool is_find(int x,int y)
{
    if(x>=n||x<1||y>=m||y<1)return 1;
    return 0;
}
void dfs(int x,int y)
{
    if(is_find(x,y))
    {
        ans++;
        return;
    }
    for(int i=0;i<4;i++)
    {
        int xx=x+dx[i],yy=y+dy[i];
        if(!vis[xx][yy])
        {
            vis[x][y]=1;
            dfs(xx,yy);
            vis[xx][yy]=0;
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<n;i++)
    {
        set_vis();
        vis[i][0]=1;
        dfs(i,1);
    }
    for(int i=1;i<m;i++)
    {
        set_vis();
        vis[0][i]=1;
        dfs(1,i);
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：小小二逼兽 (赞：1)

# luogup4537 [CQOI2007]矩形

### 题目描述

给一个a*b矩形，沿着网格线把它分成非空的两部分，每部分所有格子连通，且至少有一个格子在原矩形的边界上

### 解题思路及方法

选定一条边线(一条横着的,一条竖着的,还不能在四个直角处搜索)进行DFS，当搜索出边界时，答案方案数++

### 时间复杂度分析

$O(?)$

不太清楚，但从6*7的极限数据来看，答案应该是O(！)级别的

### BUG和错误分析

要认真审题

### 涉及算法及技巧

- DFS

---


# [COCI 2006/2007 #3] BICIKLI

## 题目背景

一场自行车比赛将要在一个遥远的地方上举行。

## 题目描述

这个地方有 $n$ 个城镇，从 $1\sim n$ 编号，其中有 $m$ 条**单向**道路连接它们。比赛将在 $1$ 号城镇开始并在 $2$ 号城镇结束。

主办方想知道，一共有多少条不同的路线？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\leq 5\times 10 ^ 4$，$1\leq m\le 10^5$。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T5 BICIKLI***

感谢 @[ShineEternal](https://www.luogu.com.cn/user/45475) 提供的翻译。

## 样例 #1

### 输入

```
6 7
1 3
1 4
3 2
4 2
5 6
6 5
3 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 8
1 3
1 4
3 2
4 2
5 6
6 5
3 4
4 3```

### 输出

```
inf```

# 题解

## 作者：06ray (赞：20)

### 先膜楼下的chen_zhe大佬%%%

### 这题思路不难，可能是道假紫题。

## 大体思路如下：

 #### 先判断从1到2点是否有无限条路径。什么时候就会有无限条路径呢？不难想到，当出现一个环且从1节点到2节点能经过它时，就会有无数条路径可走。判断是否有环的方法很简单，只需要求强连通分量（tarjan模板不阐述)。
#### 求好之后我们还得判断从1节点到2节点是否可以遍历到一个环，可以用一个BFS来模拟。我们先用BFS求出从1号节点出发能遍历到的所有的点。然后我们建一个反向的图，再用BFS求出在反向图中从2号点出发能遍历到的所有的点。接着判断如果某一个点既可以被2遍历到又能被1遍历到并且它在一个环之内，就说明有无限条路径，输出inf。

#### 最后，我们在用一个BFS求出从1号点到2号点的路径总数即可。

### 下面有请~~可爱~~丑陋的代码酱出场qwq


```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=101000;
struct edge{
    int to,cost;
};
stack<int> s;
int n,m,dfn[MAXN],low[MAXN],color[MAXN],vis[MAXN],used[MAXN],a[MAXN],countt[MAXN],in[MAXN];
int colornum; 
vector<int> G[MAXN];
vector<int> rG[MAXN];
inline int read()//读入优化
{
    int num=0;
    char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9')
     {
         num=num*10+ch-'0';
         ch=getchar();
     }
    return num; 
}
int cnt;
void tarjan(int u)//Tarjan模板，求出强连通分量
{
    cnt++;
    dfn[u]=low[u]=cnt;
    used[u]=true;
    s.push(u);
    vis[u]=true;
    for(int i=0; i<G[u].size(); i++)
    {
        int v=G[u][i];
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else
        {
            if(vis[v])
            {
                low[u]=min(low[u],dfn[v]);
            }
        }
    }
    if(dfn[u]==low[u])
    {
        colornum++;
        while(s.top()!=u)
        {
            int t=s.top();
            s.pop();
            color[t]=colornum;
            vis[t]=false;
        }
        s.pop();
        color[u]=colornum;
        vis[u]=false;
    }
}
void bfs1(int x)//求出从1号节点出发能遍历到的所有的点
{
    memset(used,0,sizeof(used));
    queue<int>q;
    q.push(x);
    used[x]=true;
    while(!q.empty())
    {
        int v=q.front();
        q.pop();
        for(int i=0; i<G[v].size(); i++)
        {
            if(!used[G[v][i]])
            {
                used[G[v][i]]=true;//判断是否能被1遍历到
                q.push(G[v][i]);
            }
            in[G[v][i]]++;
        }
    }
}
void bfs2(int x)//求出在逆向图中从2号节点出发能遍历到的所有的点
{
    memset(vis,0,sizeof(vis));
    queue<int>q;
    q.push(x);
    vis[x]=true;
    while(!q.empty())
    {
        int v=q.front();
        q.pop();
        for(int i=0; i<rG[v].size(); i++)
        {
            if(!vis[rG[v][i]])
            {
                vis[rG[v][i]]=true;//判断是否能被2遍历到
                q.push(rG[v][i]);
            }
        }
    }
}
void bfs3(int x)
{
    queue<int>q;
    q.push(x);
    countt[x]=1;
    while(!q.empty())
    {
        int v=q.front();
        q.pop();
        for(int i=0; i<G[v].size(); i++)
        {
            if(vis[G[v][i]])
            {
                countt[G[v][i]]+=countt[v];
                countt[G[v][i]]%=1000000000;//取模
                if(!--in[G[v][i]]) q.push(G[v][i]);//小优化
            }
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1; i<=m; i++)
    {
        int x,y;
        x=read(),y=read();
        G[x].push_back(y);//邻接表存储
        rG[y].push_back(x);//建反向图
    }
    for(int i=1; i<=n; i++)
    if(!dfn[i]) tarjan(i);
    bfs1(1);
    bfs2(2);
    for(int i=1; i<=n; i++)
    a[color[i]]++;//统计每个强连通分中节点个数
    for(int i=1; i<=n; i++)
    if(used[i]&&vis[i]&&a[color[i]]!=1)//可以被2遍历到又能被1遍历到并且在一个环之内
    {
        cout<<"inf";
        return 0;
    }
    bfs3(1);
    cout<<countt[2];
    return 0;
}
```
~~管理大大求过~~

---

## 作者：ModestCoder_ (赞：5)

如果是求一个点到另一个点的路径条数，那么直接用拓扑就好了

但是这道题目里面不一定是$DAG$

所以要判环，问题是有些环跟自己没关系，存在着并不影响答案，但是如果我能经过一个环到达终点，那么我就有无数条路径，所以是inf

就是如何判断会不会走过环

从起点跑一遍$dfs$，$vis1$表示哪些点被经过

建反图，从终点跑一遍$dfs$，$vis2$表示哪些点被经过

对于一个点$u$，有一条合法路径经过$u$的充要条件是$vis1_u=1且vis2_u=1$

对于这些$u$建拓扑图，跑一遍拓扑，如果有点的入度不为0，说明有环

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
using namespace std;
const int qy = 1e9;
struct Edge{
	int to, next;
}edge[maxn << 1], edge2[maxn << 1];
int num, num2, head[maxn], head2[maxn], dp[maxn], vis1[maxn], vis2[maxn], vis[maxn], d[maxn], n, m;
queue <int> q;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }
void addedge2(int x, int y){ edge2[++num2] = (Edge){y, head2[x]}, head2[x] = num2; }

void dfs1(int u, int pre){
	if (vis1[u]) return;
	vis1[u] = 1;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (v == pre) continue;
		dfs1(v, u);
	}
}

void dfs2(int u, int pre){
	if (vis2[u]) return;
	vis2[u] = 1;
	for (int i = head2[u]; i; i = edge2[i].next){
		int v = edge2[i].to;
		if (v == pre) continue;
		dfs2(v, u);
	}
}

void dfs(int u, int pre){
	if (vis[u]) return;
	vis[u] = 1;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (vis1[v] && vis2[v]){ 
//			printf("%d to %d\n", u, v);
			++d[v];
			dfs(v, u);
		}
	}
}

int main(){
	n = read(), m = read();
	for (int i = 1; i <= m; ++i){
		int x = read(), y = read();
		addedge(x, y), addedge2(y, x);
	}
	dfs1(1, 0); dfs2(2, 0);
	if (!vis1[2]) return puts("0"), 0;
	dfs(1, 0);
	q.push(1), dp[1] = 1;
//	for (int i = 1; i <= n; ++i)
//		printf("d[%d] = %d\n", i, d[i]);

	while (!q.empty()){
		int u = q.front(); q.pop();
		for (int i = head[u]; i; i = edge[i].next){
			int v = edge[i].to;
			if (vis1[v] && vis2[v]){
				--d[v], dp[v] = (dp[v] + dp[u]) % qy;
				if (!d[v]) q.push(v);
			}
		}
	}
	for (int i = 1; i <= n; ++i)
		if (d[i]) return puts("inf"), 0;
	printf("%d\n", dp[2]);
	return 0;
}
```


---

## 作者：Semorius (赞：3)

题意：求一张 $n$ 个点的**有向**图中 $1$ 号点到 $2$ 号点的路径数。  

首先考虑不在 $1$ 号点到 $2$ 号点的路径上的那些点不会对答案产生影响，于是先预处理出所有 $1$ 号点到 $2$ 号点路径上经过的点。先在**原图**上以 $1$ 号点为起点对所有能到达的点进行染色，再在**反图**上以 $2$ 号点为起点对所有能到达的点进行染色。两次都被染上色的点就在 $1$ 号点到 $2$ 号点的路径上。

然后考虑什么时候会有无数条满足条件的路径。发现当且仅当路径上有环时，可以经过任意次环以产生无数条路径。

剩下的情况就是 $\text{DAG}$ 了，直接跑拓扑用 $\text{dp}$ 进行路径计数。

复杂度 $O(n + m)$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll SIZE = 200005;
const ll mod = 1e9;
ll n, m;
ll head[SIZE], ver[SIZE*2], nxt[SIZE*2], tot;
vector<ll> e[SIZE];
bool c1[SIZE], c[SIZE];
ll d[SIZE];
ll ans[SIZE];

inline ll rd(){
	ll f = 1, x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f*x;
}

void add(ll x, ll y){
	ver[++tot] = y, nxt[tot] = head[x];
	head[x] = tot;	
}

void dfs1(ll x){
	c1[x] = 1;
	for(int i = head[x]; i; i = nxt[i]){
		ll y = ver[i];
		if(c1[y]) continue;
		dfs1(y);
	}	
}

void dfs2(ll x){
	c[x] = 1;
	for(int i = 0; i < e[x].size(); i++){
		ll y = e[x][i];
		if(c[y]) continue;
		dfs2(y);
	}
}

struct E{
	ll x, y;
}ee[SIZE];

int main(){
	n = rd(), m = rd();
	assert(n <= 100000 && m <= 100000);
	for(int i = 1; i <= m; i++){
		ll x = rd(), y = rd(); ee[i].x = x, ee[i].y = y;
		add(x, y); e[y].push_back(x);
	}
	dfs1(1);
	dfs2(2);
	ll cnt = 0;
	for(int i = 1; i <= n; i++) c[i] &= c1[i], cnt += c[i];
	for(int i = 1; i <= m; i++){
		if(!c[ee[i].x] || !c[ee[i].y]) continue;
		d[ee[i].y]++; 
	}
	if(d[1] != 0){
		printf("inf");
		return 0;
	} 
	queue<int> q;
	q.push(1); ll z = 0;
	ans[1] = 1;
	while(q.size()){
		ll x = q.front(); q.pop();
		z++;
		for(int i = head[x]; i; i = nxt[i]){
			ll y = ver[i];
			d[y]--; ans[y] = (ans[y] + ans[x]) % mod;
			if(d[y] == 0){
				q.push(y);
			}
		}
	}
	if(z < cnt) printf("inf");
	else printf("%lld", ans[2]);
	return 0;
}
```


---

## 作者：Schwarzkopf_Henkal (赞：2)

%%%chen_zhe~~女装~~大佬

如果这题没有环的话只能算是一个简单dp题，然而有了环就会出现一些非常诡异并且棘手的情况。

首先看一下这组数据，由可爱的机房友人提供。
```
5 5
1 4
4 2
3 5
5 3
3 4
```
要画出来的话，大概是这个样子：
![](https://cdn.luogu.com.cn/upload/image_hosting/agxhh3g2.png)
~~卧槽这是什么垃圾东西~~

总之就是，由1出发，4的入度-1，然而4的入度仍不为零，无法进行进一步的运算了。要说有环还的确是有环，不过这个环不仅没用还让我们的$dp_2$的值变成了0。

这样的毒瘤东西绝对不能要啊，但是怎么样的点才是像这样没用的点呢？我们发现，环里面的点可以到达2，但是从1根本就进不去这个环啊。

那么我们分别以1和2为起点进行一次正dfs和一次逆dfs标记能够从1能够到达的点和能够到达2的点。

必须两个都能到达才是有用的点，否则就要把这个点删掉。

然后删完就能快乐dp了。首先到达1的方法数肯定是1，然后对于每个没有前驱的点，将它的后继的方法数加上该点的方法数，删除该点和与该点相连的边。就是拓扑排序。

参考代码和其他补充如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,u,v,in[10005];
long long dp[10005];
bool mk[10005][2],flag;
vector<int>dis[10005],des[10005];
queue<int>que;
void ring0(int p){
    mk[p][0]=1;
    for(int i=0;i<dis[p].size();i++)
        if(!mk[dis[p][i]][0])
            ring0(dis[p][i]);
}//标记以1为起点能够达到的点
void ring1(int p){
    mk[p][1]=1;
    for(int i=0;i<des[p].size();i++)
        if(!mk[des[p][i]][1])
            ring1(des[p][i]);
}//标记能够达到2的点
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>u>>v;
        dis[u].push_back(v);
        des[v].push_back(u);
        in[v]++;
    }
    dp[1]=1;
    ring0(1);
    ring1(2);
    for(int i=1;i<=n;i++)
        if(!mk[i][1]||!mk[i][0])
            for(int j=0;j<dis[i].size();j++)
                in[dis[i][j]]--;//删除无用点
    for(int i=1;i<=n;i++)
        if(in[i]==0&&mk[i][0]&&mk[i][1])
            que.push(i);//拓扑排序初始化
    int top;
    while(!que.empty()){
        top=que.front();
        que.pop();
        for(int i=0;i<dis[top].size();i++){
            if(in[dis[top][i]]&&mk[dis[top][i]][0]&&mk[dis[top][i]][1]){
                dp[dis[top][i]]+=dp[top];//dp刷表转移
                dp[dis[top][i]]%=1000000000;
                in[dis[top][i]]--;
                if(in[dis[top][i]]==0)
                    que.push(dis[top][i]);//拓扑排序过程。
            }
        }
    }
    for(int i=1;i<=n;i++)
        if(in[i]&&mk[i][0]&&mk[i][1]){
            cout<<"inf";
            return 0;
        }//如果有用的点的入度还不为0，那么在1到2的路径上存在环，输出inf
    cout<<dp[2];
}
```
I'm Schwarzkopf Henkal.

---

## 作者：doctorZ_ (赞：1)

这道题有非常多方法，树形$\text{DP}$还有拓扑排序都可以$\text{AC}$，下面就介绍拓扑排序的方法

首先用$dfs$从点$1$开始跑，用$vis1[i]$表示点$1$是否能够到达点$i$，然后再建以个反向图，用$dfs$从点$2$开始跑，$vis2[i]$的含义同理      


如果$!vis1[2]||!vis2[1]$，则说明两个点不连通，直接输出$0$即可     


若$vis1[i]\&\&vis2[i]$则表明点$1$可以到达点$i$，同时点$i$也可以到点$2$，也就表明从点$1$到达点$2$的路径中，至少有一条会经过点$i$        
由于题目还可能会有$inf$的情况，使用$spfa$判正环即可，若有环，则输出$\text{inf}$，若无环，则说明所有$vis1[i]\&\&vis2[i]$的点$i$组成的图为一个$\text{DAG}$图，这就满足了使用拓扑排序的条件          


设$f[i]$为点$1$到达点$i$的路径条数，易得动态转移方程为：
$$f[i]=\sum f[v]$$
其中，点$v$为可以到达点$i$的点                 
最后跑一遍拓扑排序，$f[2]$则为答案，边跑边对$1000000000$取模即可
## CODE:
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#define N 20000
#define M 200000 
using namespace std;
int n,m;
int st[N+1],fst[N+1],tot,ftot;
struct edge
{
	int to,last;
}e[M+1],fe[M+1];
void add(int a,int b)
{
	e[++tot].to=b;
	e[tot].last=st[a];
	st[a]=tot;
}
void fadd(int a,int b)
{
	fe[++ftot].to=b;
	fe[ftot].last=fst[a];
	fst[a]=ftot;
}
queue<int> q;
bool vis1[N+1],vis2[N+1];
void dfs1(int u)
{
	vis1[u]=true;
	for(int i=st[u];i!=0;i=e[i].last)
		if(!vis1[e[i].to])
			dfs1(e[i].to);
}
void dfs2(int u)
{
	vis2[u]=true;
	for(int i=fst[u];i!=0;i=fe[i].last)
		if(!vis2[fe[i].to])
			dfs2(fe[i].to);
}
int in[N+1],f[N+1];
int dis[N+1],pass[N+1],cnt;
bool spfa(int u)//由于作者比较懒，就打了递归版spfa
{
	if(++pass[u]>=cnt)
		return true;
	for(int i=st[u];i!=0;i=e[i].last)
		if(dis[u]+1>dis[e[i].to]&&vis1[e[i].to]&&vis2[e[i].to])
		{
			dis[e[i].to]=dis[u]+1;
			bool res=spfa(e[i].to);
			if(res)
				return true;
		}
	return false;
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int a,b;
		scanf("%d %d",&a,&b);
		add(a,b),fadd(b,a);
	}
	dfs1(1),dfs2(2);
	if(!vis1[2]||!vis2[1])
	{
		printf("0");
		return 0;
	}
	for(int i=1;i<=n;i++)
		cnt+=(vis1[i]&vis2[i]);
	if(spfa(1))
	{
		printf("inf");
		return 0;
	}
	for(int i=1;i<=n;i++)
		if(vis1[i]&&vis2[i])
			for(int j=st[i];j!=0;j=e[j].last)
				if(vis1[e[j].to]&&vis2[e[j].to])
					in[e[j].to]++;
	f[1]=1;
	q.push(1);
	while(!q.empty())
	{
		int u=q.front();
		for(int i=st[u];i!=0;i=e[i].last)
		{
			int v=e[i].to;
			if(vis1[v]&&vis2[v])
			{
				in[v]--;
				f[v]=(f[v]+f[u])%1000000000;
				if(in[v]==0)
					q.push(v);
			}
		}
		q.pop();
	}
	printf("%d",f[2]);
	return 0;
}
```


---

## 作者：LevenKoko (赞：0)

### [------更好的观看效果------](https://www.cnblogs.com/zhenglw/p/10750962.html)

不难的一道题，就是想的时候出了点问题，看了其他巨佬的题解才发现问题所在...

 

**题目大意：**

给定一个有向图，n个点，m条边。请问，1号点到2号点有多少条路径？如果有无限多条，输出inf，如果有限，输出答案模10^9的余数。

### 首先是0的情况：

　　不存在1~2的路径，即图不一定联通（不这样特判也可以，但是常数会小一点）
  
 _如图：_ 

![](https://img2018.cnblogs.com/blog/1447450/201904/1447450-20190422163011166-1997429786.png)

### 其次是inf的情况：

　　如果在1~2的某条路径中存在某个点属于某个强连通分量，那么这条路径就可以在这个强连通分量里无限走下去，答案就是inf
 
_如图：_ 

![](https://img2018.cnblogs.com/blog/1447450/201904/1447450-20190422162945383-1856363931.png)


### 一般情况:

　　如果这条路径不属于第二种情况，那就考虑计数吧...

　　我们可以用一个dp数组计数，然后乱搞BFS即可，不用考虑是否vis，因为排除了第二种情况后显然是不会过度访问（RE）的

 

一个小问题：在考虑情况2的时候，我们需要建立反向边，以便判断1,2可达性（刚开始想当然了这个没判）


 

```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize(3)
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#define ha 1000000000
using namespace std;
inline int read(){
	int ans=0,f=1;char chr=getchar();
	while(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr)){ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
	return ans*f;
}void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}const int M=1e5+5;
int head[M],head1[M],ver1[M],nxt1[M],ver[M],nxt[M],tot,n,m,vis1[M],vis2[M],dfn[M],low[M],ins[M],sta[M],top,t,col,color[M],cnt[M],tot1,dp[M],in[M];
inline void add(int x,int y){ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;}
inline void add1(int x,int y){ver1[++tot1]=y;nxt1[tot1]=head1[x];head1[x]=tot1;}
void dfs1(int x){for(int i=head[x];i;i=nxt[i])if(in[ver[i]]++,!vis1[ver[i]])dfs1(ver[vis1[ver[i]]=1,i]);}
void dfs2(int x){for(int i=head1[x];i;i=nxt1[i])if(!vis2[ver1[i]])dfs2(ver1[vis2[ver1[i]]=1,i]);}
inline bool check_LT(){vis2[2]=1,dfs2(2);if(vis1[vis1[1]=1,dfs1(1),2]) return 0;return 1;}
void Tarjan(int x){
	sta[top++]=x;low[x]=dfn[x]=++t;ins[x]=1;
	for(register int i=head[x];i;i=nxt[i])
		if(ins[ver[i]]==1) low[x]=min(low[x],dfn[ver[i]]);
		else if(ins[ver[i]]==0) low[x]=min(low[Tarjan(ver[i]),x],low[ver[i]]);
	low[x]==dfn[x]?++col:col;
	if(low[x]==dfn[x])do{--top,color[sta[top]]=col,ins[sta[top]]=-1,++cnt[col];}while(sta[top]!=x);
}queue<int> q;
void BFS(){
	q.push(1);dp[1]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(register int i=head[x];i;i=nxt[i]){
			if(!vis1[ver[i]]) continue;
			dp[ver[i]]=(dp[ver[i]]+dp[x])%ha;
			if(!--in[ver[i]])	q.push(ver[i]);
		}
	}
}
int main(){
	n=read(),m=read();
	for(register int i=1,x,y;i<=m;++i) x=read(),y=read(),add(x,y),add1(y,x);
	if(check_LT()){return puts("0"),0;}
	for(register int i=1;i<=n;++i) if(!dfn[i]) Tarjan(i);
	for(register int i=1;i<=n;++i)
		if(vis1[i]&&vis2[i]&&cnt[color[i]]>=2)
			return puts("inf"),0;
	return BFS(),write(dp[2]),0;
}
```

---

## 作者：小塘空明 (赞：0)

如果不考虑环的因素，那么这题就是求有向图上从一点到另一点的路径条数，拓扑排序即可。

我们考虑输出inf的情况，可以发现当从1出发到2经过的任意一个点处于一个环内时，路径条数是无穷多的。

有向图上从s到t的经过点，就是从s出发所能经过的所有点与从t出发在反图上所能经过的所有点的交集。

这样我们就可以判断是否输出inf并进行路径统计了。

注意，进行拓扑排序时的点的入度，是从s出发所能经过的所有点与从t出发在反图上所能经过的所有点的交集的这张图上的入读，那些不能既被s经过又被t经过的点到这张图上的边所提供的入度是无用的。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
typedef long long ll;
const ll size=1e5+10,mod=1e9;
ll n,m,tot,tc,cnt,num,top,stack[size],ins[size],c[size],dcc[size],dfn[size],low[size],v[size],u[size],ans[size],du[size];
ll hc[size],vc[size],nc[size],head[size],ver[size],next[size];
queue<ll> q;
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
inline void add(ll x,ll y){
	ver[++tot]=y;next[tot]=head[x];head[x]=tot;
}
inline void add_c(ll x,ll y){
	vc[++tc]=y;nc[tc]=hc[x];hc[x]=tc;
}
inline void bfs1(){
	q.push(1);v[1]=1;
	while(q.size()){
		ll x=q.front();q.pop();
		for(ll i=head[x];i;i=next[i]){
			ll y=ver[i];du[y]++;
			if(v[y]) continue;
			v[y]=1;q.push(y);
		}
	}
}
inline void bfs2(){
	q.push(2);u[2]=1;
	while(q.size()){
		ll x=q.front();q.pop();
		for(ll i=hc[x];i;i=nc[i]){
			ll y=vc[i];
			if(u[y]) continue;
			u[y]=1;q.push(y);
		}
	}
}
inline void topsort(){
	q.push(1);ans[1]=1;
	while(q.size()){
		ll x=q.front();q.pop();
		for(ll i=head[x];i;i=next[i]){
			ll y=ver[i];
			if(!u[y]) continue;
			ans[y]=(ans[x]+ans[y])%mod;
			if(!(--du[y])) q.push(y);
		}
	}
}
inline void tarjan(ll x){
	dfn[x]=low[x]=++num;
	stack[++top]=x;ins[x]=1;
	for(ll i=head[x];i;i=next[i]){
		if(!dfn[ver[i]]){
			tarjan(ver[i]);low[x]=min(low[x],low[ver[i]]);
		}
		else if(ins[ver[i]]) low[x]=min(low[x],dfn[ver[i]]);
	}
	if(low[x]==dfn[x]){
		cnt++;ll y;
		do{
			y=stack[top--];ins[y]=0;c[y]=cnt;
		}while(y!=x);
	}
}
int main(){
	n=read();m=read();
	for(ll i=1;i<=m;i++){
		ll x=read(),y=read();add(x,y);add_c(y,x);
	}
	for(ll i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
	bfs1();bfs2();
	for(ll i=1;i<=n;i++) dcc[c[i]]++;
	for(ll i=1;i<=n;i++){
		if(v[i]&&u[i]&&dcc[c[i]]!=1){
			printf("inf\n");return 0;
		}
	}
	topsort();printf("%lld\n",ans[2]);
	return 0;
}

```

---


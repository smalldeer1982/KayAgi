# [CCO 2015] 路短最

## 题目描述

**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day1 T2「[Artskjid](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day1.pdf)」**

你可以通过许多的算法找到从一个地方到另外一个地方的最短路径。人们在他们的车上安装 GPS 设备然后他们的手机告诉他们最快的到达目的地的方式。然而，当在假期时，Troy 喜欢慢慢旅游。他想找最长的到目的地的路径以便他可以在路途中看许多新的以及有趣的地方。

因此，一个有效的路径包含一个不同城市的序列 $c_1,c_2,...,c_k$，并且对于每个 $1\le i<k$，有道路从 $c_i$ 通往 $c_{i+1}$。

他不想重复访问任何城市，请帮他找出最长路径。

## 说明/提示

最短路为直接走城市 $0$ 至城市 $2$ 的道路，长度为 $5$ km。最长路为 $0$ 至 $1$ 至 $2$， 长度 $4+3=7$ km。

对于至少 $30\%$ 的数据，$n\le 8$；  

对于 $100\%$ 的数据，有 $2\le n \le 18,$ $1\le m \le n^2-n,$ $0\le s,d \le n-1,$ $s\neq d,$ $1\le l\le 10000$。

## 样例 #1

### 输入

```
3 3
0 2 5
0 1 4
1 2 3```

### 输出

```
7```

# 题解

## 作者：YellowBean_Elsa (赞：13)

## 这是一道很好的练状态压缩的题

一看数据范围就知道时间复杂度是 $2^n$ 级别的。

由于和路径长度有关，想到了经典的状压：

**$dp[ i ][ j ]$ 表示状态为 $i$，现在在节点 $j$ 的最长路径**

具体解释（不熟悉状压的人）：
	
	    设 i = 39 = 32 + 4 + 2 + 1 = 100111 (二进制), 则
        
        状态 i 表示已经过0，1，2，5号节点，因为100111从
        
        右往左数第0，1，2，5位为1。
        
转移方程：$dp[ i ][ v ] = dp[ j ][ u ] + e[ u ][ v ]$

其中 $e$ 是邻接矩阵，$u$，$v$ 是用来转移的边的起点和终点，

状态 $j$ 应该比状态 $i$ 少一个位置 $v$ 上的 $1$，因为 $j$ 时 $v$ 还没走过。

由于不会从已经过的节点转移过来，所以不会重复经过节点。

上代码（有些邪恶的常数优化）

```cpp
//码风丑请见谅 
//Luogu P4802 O（2^n * n^2）
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read(){
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x;
}
int n,m;
int dp[1<<18][18];
int e[18][18],x,y;
inline int Max(int x,int y){
	if(x>y)return x;
	return y;
}
int ans;
int main(){
	n=read(),m=read();
	//读入，邻接矩阵存图 
	for(re int i=1;i<=m;i++){
		x=read(),y=read();
		e[x][y]=read();
	}
	memset(dp,0x8f,sizeof(dp));//-INF 
	dp[1][0]=0;//初始化：只经过起点位移（划掉）路程为0 
	//开始dp 
	for(re int i=3;i<(1<<n);i+=2)//O(2^n)枚举初始状态
	//常数优化1：只枚举经过了0号节点的状态（奇数） 
		for(re int u=0;u<n;u++)//O(n)枚举起点 
			if((i>>u)&1)//判断u节点是否走过（状压中的经典骚操作 %%%）  
				for(re int v=1;v<n;v++)//O(n)枚举终点
				//常数优化2：枚举终点时不枚举0（差不多一点用都没有） 
					if(((i>>v)&1)&&e[u][v])
						dp[i][v]=Max(dp[i][v],dp[i-(1<<v)][u]+e[u][v]);//转移方程 
	//不用写大括号真幸福 #Q#_A_#Q#			
	for(re int i=(1<<(n-1))+1;i<=(1<<n)-1;i+=2)
	//常数优化3：只从经过了0号和n-1号节点的状态中挑选答案 
		ans=Max(ans,dp[i][n-1]);
	printf("%d\n",ans);
	return 0;
}
```
### 会树状数组的看过来！
### 正经的非常数的优化！

利用传奇的lowbit操作可以将复杂度优化到$O(2^n \times(log n)^2)$

每次枚举起点和终点时，我们不再盲目地一位位试，而是直接用

$lowbit$ 找到 $1$ 个符合要求的点

详见代码：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read(){
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x;
}
int n,m;
int dp[1<<18][18];
int e[20][20],x,y;
inline int lowbit(int x){//That's it！ 
	return x&(-x);
}
inline int Max(int x,int y){
	if(x>y)return x;
	return y;
}
int Log[1<<19];//记录每个lowbit值映射到哪个节点 
inline void init_log(){
	for(re int i=0;i<n;i++)
		Log[1<<i]=i;
}
int ans;
int main(){
	n=read(),m=read();
	for(re int i=1;i<=m;i++){
		x=read(),y=read();
		e[x][y]=read();
	}
	memset(dp,0x8f,sizeof(dp));
	dp[1][0]=0; 
	init_log();//初始化Log数组 
	int u,v;
	for(re int i=3;i<(1<<n);i+=2){
		int j1;
		for(re int k1=i;k1;k1-=j1){
		//*每次找到这个二进制数最靠右的一个1，转移完后减掉* 
			j1=lowbit(k1);
			u=Log[j1];//j1对应的点即为起点 
			int j2;
			for(re int k2=i;k2;k2-=j2){//同上 
				j2=lowbit(k2);
				v=Log[j2];
				if(e[u][v])
					dp[i][v]=Max(dp[i][v],dp[i-j2][u]+e[u][v]); 
			}
		}
	}
	for(re int i=(1<<(n-1))+1;i<(1<<n);i+=2)
		ans=Max(ans,dp[i][n-1]);
	printf("%d\n",ans);
	return 0;
}
```
~~最后祝愿CCF能在与教育部的斗争中获胜，赢回我们的NOIP~~



 

---

## 作者：Mr_QwQ (赞：13)

# 我好菜啊qwq

这个题目呢，我们首先来看一下题面

可以看到是一个**最长路**，然后不能走重复结点

之后看数据猜范围，可以看到是一个$O(2^n)$乘上几个奇奇怪怪的n的系数的算法$qwq$

那么愉快的记忆化就好啦(*￣︶￣)

我们对于每个dp值，存下阔耐的当前结点与阔耐的“已经经过结点”的状压值即可。

然后就是~~暴力出奇迹~~

代码：（吸氧勿喷）
```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
int dp[1<<18][20],n,m,t1,t2,t3;
vector<int> to[20],co[20];
bool vis[1<<18][20];
int dfs(int now,int visd){
    if(now==n)return 0;
    if(dp[visd][now])return dp[visd][now];
    int len=-1<<25;
    for(int i=0;i<to[now].size();i++)if(!(visd&(1<<to[now][i]-1)))len=max(len,co[now][i]+dfs(to[now][i],visd|(1<<to[now][i]-1)));
    return dp[visd][now]=len;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&t1,&t2,&t3);
        to[t1+1].push_back(t2+1);co[t1+1].push_back(t3);
    }
    printf("%d",dfs(1,1));
    return 0;
}
```
推荐大家做完这题之后做一下这题：

[一道阔耐的状压dp](https://www.luogu.org/problemnew/show/P4329)

# 谢谢大家qwq

---

## 作者：hovny (赞：8)

## 解题思路

~~其实这就是`Hamilton路径`的模板题~~ 不要脸地贴[$blog$](https://hovnysilence.github.io/2019/03/27/AlgorithmGuide-0x01_ShortHamiltonPath-Solution/)

根本做法其实是**状压DP**

用`b`数组存边，然后`f`数组用来跑$DP$

用$i$表示 状压后，已经走过的点有哪些（当然啦，包含下面的$j$点），为`f`数组的第一维

用$j$表示 最后到的是哪个点，为`f`数组的第二维

然后对于每种情况，可以从其他状态转移过来，这里就不详述了，具体的见代码

## Code

```cpp
#include<bits/stdc++.h>
#define INF 0x7f7f7f7f
#define N 19
using namespace std;
int n,m,Max,res,ans;//Max表示每一位都取的状压值（也就是范围）
int b[N][N],f[1<<19][N];
inline int read() {
	int s=0;
	char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return s;
}
int main()
{
	int i,j,k,x,y;
	n=read(),m=read();
	for(i=1;i<=m;i++)//单向边
		x=read(),y=read(),b[x][y]=read();
	Max=(1<<n)-1;//求范围，f[1][0]=0
	for(i=3;i<=Max;i++) {//因为必经过0号点，所以直接从状态2开始，虽然2无意义，但是你要赋初值啊
		for(j=0;j<n;j++) {//就是枚举，判断可以 以哪些点为终点
			f[i][j]=-INF;//赋初值
			if((i>>j)&1) {//判断
				res=i^(1<<j);//除去为结尾的这个点，可以从哪些状态转移过来
				for(k=0;k<n;k++)//再枚举
					if((res>>k)&1&&b[k][j])//再判断，要注意有边才能走
						f[i][j]=max(f[i][j],f[res][k]+b[k][j]);//求较大值
			}
		}
	}
	--n;
	for(i=1+(1<<n);i<=Max;i++)//以n为结尾的各种情况，i赋的初值是为了保证n-1这个点能取到
		ans=max(ans,f[i][n]);
	printf("%d",ans);
	return 0;
}
```

## 一点小问题

可以自行思考一下时间复杂度

这里是不会超的，但是将$n$改为$20$时，仍不会$T$，~~暴力就是这么优秀~~



---

## 作者：Lonely_NewYear (赞：5)

# 洛谷 P4802 题解

## 前置知识

### 状态压缩

状态压缩能把很多维的状态压缩成一个，举个例子：

有五个台灯，每个台灯都有开关两种状态。如果要描述这五个灯的状态的话，需要五个为 $0,1$ 的数，例如 $1,0,1,0,0$ ，就表示开，关，开，关，关。这样表示在做题时无疑是极度麻烦的，于是状态压缩应运而生。会发现每个台灯都是一个一位二进制数，五个台灯连在一起就是五位二进制数，再把二进制数转化成十进制数（因为你开数组时开成二进制数的话会浪费极多空间），就可以成功的把五个状态压缩成一个。如上面的例子就可以表示成 $(10100)_ 2$ 即 $(24)_ {10}$。

本题需要用到状压 DP，即用压缩过的状态进行动态规划。

## 题目描述

给出 $n$ 个点 $m$ 条边，让你求编号 $0$ 和 $n-1$ 的点之间的最长路径。

这不就是单源最长路吗？

慢着，还有一个重要条件：每个点只能经过一次！

## 题目分析

每个点只经过一次，普通的最长路就解决不了了。问题在于每个点只能经过一次。每个点的状态有，经过了，没经过，开，关，$1$,$0$，二进制！这样就可以用状态压缩描述出当前每个点有没有经过了。其实要表示当前的状态还有一个要素就是现在走到哪个点了，所以最后的状态就是一个 $n$ 位二进制数和一个表示点的编号的数。

既然用不了最长路算法，就可以考虑用动态规划来求出最长路。定义 $dp_{i,j}$ 表示现在点的经过状态为 $i$，走到了点 $j$ 时的最长路。在动态规划时可以先枚举状态 $i$，再枚举一个目前经过了的点 $j$，最后枚举一个目前没经过的点 $k$，只要 $j,k$ 有边就可以转移，转移方程为 $dp[i|k][k]=max(dp[i][j]+w[i][j])$（位运算怎么用请自行百度）。答案为所有经过了点 $0$ 和 $n-1$，并且走到了点 $n-1$ 的状态的最大值。

## 代码实现

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int dp[1<<18][18],g[18][18];
int main()
{
	int n,m;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i--)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		g[u][v]=w;
	}
	for(int i=1;i<(1<<n);i++)
	{
		for(int j=0;j<n;j++)
		{
			dp[i][j]=-1;
		}
	}
	dp[1][0]=0;
	for(int i=1;i<(1<<n);i++)
	{
		for(int j=0;j<n;i++)
		{
			if(dp[i][j]==-1)//注意这里，一定要判断一下当前状态是否合法，否则会用不合法的状态进行更新！
			{
				continue;
			}
			for(int k=0;k<n;k++)
			{
				if(!(i&(1<<k))&&g[j][k])
				{
				    dp[i|(1<<k)][k]=max(dp[i|(1<<k)][k],dp[i][j]+g[j][k]);
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<(1<<n);i++)
	{
		if((i&1)&&(i&(1<<(n-1))))
		{
			ans=max(ans,dp[i][n-1]);
		}
	}
	printf("%d",7);
	return 0;//内有防抄袭，慎复制粘贴！
}
```

谢谢观看。

---

## 作者：Rainy_chen (赞：3)

## 题意
给一张有向带权图，求从$0$到$n-1$的最长简单路径的权值和。

## 题解
$n$很小，甚至才只有$18$，于是我们可以考虑状压dp。  

dp需要的状态包括已经经过的点和当前的点。  

于是我们定义$\text{dis[rt][vised]}$表示现在在$rt$，$vised$的点被经过时从$rt$到$n-1$的最长路的长度,$vised$的二进制表示中的第$i$位表示$i$这个点是否被经过。  

可以得到转移，$dis[rt][vised] = \max(dis[to[j]][vised | (1 << to[j])] + w[j])$，其中$j$枚举$rt$的所有边，$|$表示位运算或。

转移写一个dfs就好了，搭配记搜跑的还是蛮快的。  

但是需要注意一下$dis$需要初始化为极小值。  

```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long int_t;

int_t dis[1 << 18][18];

struct E{
    int_t to,w;
    E(int_t to,int_t w):to(to),w(w){}
};

vector<E> G[20];

int_t dfs(int_t rt, int_t vised, int_t n){
    if(rt == n-1) return 0;
    if(dis[vised][rt]) return dis[vised][rt];
    dis[vised][rt] = - 998244353;
    for(E e : G[rt]){
        int_t to = e.to,w = e.w;
        if((1 << to) & vised) continue;
        dis[vised][rt] = max(dis[vised][rt], dfs(to,vised | (1 << to),n) + w);
    }
    return dis[vised][rt];
}

int main(){
    int_t n,m; cin>>n>>m;
    while(m--){
        int_t u,v,w; cin>>u>>v>>w;
        G[u].push_back(E(v,w));
    }
    cout<<dfs(0,1,n);
}
```


---

## 作者：S_S_H (赞：3)

### 本蒟蒻立志做状压！
这个题就是求单源最长路，不可重复走

为什么SPFA,Dijkstra边权取反不可行呢？

因为题目不保证无环！！而且求最长路！！你会在一个环上越走越远。。。

然而有n<=18这一项范围极小即262144可以考虑状压

那么定义状态首先想：dp[s]表示S状态下可以走到的最长路？

很显然（抱歉QWQ）不行！因为不同终点，所得到的最长路也不同

比如三个点 三条边：1->2边权10, 3->2边权12， 而1->3边权100

那么以3为终点的最长路是100，而以2为终点的最长路为112

所以考虑可行的加维

dp[S][e]表示S状态下以e为终点的最长路

则dp[S][e]=max(dp[S][e],dp[K][k]),K∈S且lowbit(K&S)=1<<k；

也就是K在二进制下与S只有一处不同，S由K号节点转移过来

(其实就是枚举转移点)

好了其它详见代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,map[30][30],dp[(1<<18)+1][30],ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		scanf("%d",&map[x][y]);
	}
	for(int i=0;i<=(1<<n)-1;i++)
		for(int j=0;j<n;j++)
			dp[i][j]=-1;
	for(int i=1;i<n;i++)
		if(map[0][i])
			dp[1+(1<<i)][i]=map[0][i];
	for(int i=1;i<=(1<<n)-1;i++)
		for(int j=1;j<n;j++)
			if((i>>j)&1)//别忘了。。。我因为这个RE了N多次
				for(int k=0;k<n;k++)
					if(((i>>k)&1)&&map[k][j]&&dp[i-(1<<j)][k]>0)
						dp[i][j]=max(dp[i][j],dp[i-(1<<j)][k]+map[k][j]);
	for(int i=1+(1<<(n-1));i<=(1<<n)-1;i++)
		ans=max(ans,dp[i][n-1]);
	printf("%d",ans);
	return 0;
} 
```
祝大家2019CSP,NOI,XXXOI RP++!!!


---

## 作者：rikkidayo (赞：2)

# 很好~~duliu~~的一道状压题

![](https://i.ibb.co/x6s73tN/116.png)

(做了两天终于做出来了，~~然而机房旁边的大佬20分钟就解决了~~，蒟蒻大哭......)

打了好几个程序都是**72分**,中途试图使用玄学得了**94分**，一度以为要AC了......

~~(其实就是程序有问题)~~

---------------------------------------华丽分割线---------------------------------------

一开始看到这题我想到的是**DP**，后来发现**记忆化搜索**加**状压**好像可以过233

代码总体上不算很难，只是有一些小细节要注意，~~不然可能会卡两天555~~

具体的思路~~和坑~~放代码注释里了

```cpp

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;

int n,m,Ans;//如题意
int Dis[20][1<<19];
//设Dis[i][j]表示当前在i城,走过城市的状态为j时,到n-1城的最大距离
//j是二进制数,从右往左数第k位表示k-1城是否走过
//举个栗子: Dis[4][21(10101)]就表示当前在4,已经走过0,2,4时到n-1的最大距离

int Map[20][20];//存图
vector<int>To[20];//To[i]存的是从i点能到的所有点

int Max(int a,int b)//自己写是好习惯
{
	if(a>b)
	return b;
	return a;
}

void Read()//写读入函数也是好习惯
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);//读入
		Map[a][b]=c;//注意:单向存边
		To[a].push_back(b);//一条从a到b的边
	}
	
	return;
}

int Dfs(int Now,int s)
{
	if(Now==n-1)//因为n-1不能走两次
	return 0;//从n-1到n-1就是0
	if(Dis[Now][s])//记忆化
	return Dis[Now][s];//之前搜过就直接返回
	
	Dis[Now][s]=-1<<19;//大坑:Dis必须初始化,不然全都爆72...
	//我也不知道Dis为啥会有负数
        
	for(int i=0,p=To[Now].size();i<p;i++)//枚举可到的点
	{
		int v=To[Now][i];
		if(!(s&(1<<v)))//如果v城没有走过
		Dis[Now][s]=Max(Dis[Now][s],Dfs(v,s+(1<<v))+Map[Now][v]);
		//s+(1<<v)就是在当前基础上,把v城设为走过的
	}
	
	return Dis[Now][s];//返回Dis[Now][s]
}

void Work()//并没什么用
{
	Ans=Dfs(0,1);//Dfs(i,j)返回的是Dis[i][j]的值
	printf("%d",Ans);//即从0开始,走过0,到n-1的最大值
	return;
}

int main()//简洁的主函数
{
	Read();
	Work();
	return 0;
}

```


---

## 作者：_121017_ (赞：1)

看到题，习惯性地看了一下算法标签，然后就发现这道题是一道状压 $DP$ 的题目，正好蒟蒻最近在学状压，于是就有了这篇题解。
# 思路：
首先，这是一道一维的 $DP$，题目有要求每个点只经过一次，最后题目满足 $n≤18$，于是我们的动态转移方程就出来了。

----
$f_{i|(1<<k),k}=max(f_{i,j}+w_{j,k})$

---
其中 $i$ 表示状态，$(i)_2$ 的第 $k$ 位表示第 $k$ 个节点是否访问，$j$ 和 $k$ 表示下一步要到的节点。
# code：
```cpp
#include<bits/stdc++.h>
#define MAX_N 25
#define MAXNUM 1<<19
using namespace std;
int n,m;
int w[MAX_N][MAX_N];
int f[MAXNUM][MAX_N];
int main(){
	cin>>n>>m;
	memset(f,-1,sizeof(f));
	memset(w,-1,sizeof(w));
    //初始化
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		cin>>w[u][v];//邻接矩阵存图
	}
	f[1][0]=0;
	for(int i=0;i<(1<<n);i++){//第一层枚举状态
		for(int j=0;j<n;j++){//第二层枚举出发节点
			if(i&(1<<j) && f[i][j]!=-1){
				for(int k=0;k<n;k++){//第三层枚举目标节点
					if(!(i&(1<<k))&&w[j][k]!=-1){
						f[i|(1<<k)][k]=max(f[i|(1<<k)][k],f[i][j]+w[j][k]);//动转方程
					}
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<1<<n;i++) ans=max(ans,f[i][n-1]);
	cout<<ans;
	return 0;
}
```


---

## 作者：月·无笙 (赞：1)


蒟蒻来发一波题解~

这题是蒟蒻做到现在第一道不看题解自己做的状压DP~

思路

step 1

首先用邻接矩阵mp[][]将所有的边存进来，因为n很小嘛，而且题目保证两个城市之间最多只有一条道路，所以不用判重边

step 2

接下来就是状压啦。

设f[s][i]表示以当前走过的城市状态为s(0表示未走过，1表示走过)，并且最后一个到达的城市为i.

为什么是以i为终点而不是起点呢，因为你并不知道上一步走哪里，下一步走哪里，这样枚举相当于每次都从起点i走（默认上一步为i）,实际上并不一定，所以将状态设为以i为终点，这样保证你知道下一步走哪，只要枚举上一步即可。

初始化，全部赋值为极小值，因为求最长路嘛。然后将f[1][1]赋值为0（这里蒟蒻将所有下标都加1了，所以起点是1,终点是n），表示在起点时路程为0.

转移：f[s][i]=max(f[s][i],f[s^(1<<(i-1))][j]+mp[j][i])

i表示当前走过的最后一个城市，j表示上一步走的最后一个城市，枚举j,更新f[s][i],注意i,j一定都在同一个集合s中（因为上一步j一定是在走过的城市中选呀）

step 3

答案就是在所有以n为最后一个城市的所有状态中取max。

附代码

```
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstring>
using namespace std;
const int N=20;
const int INF=1<<30;
int n,m;
int mp[N][N];
int f[1<<N][N];
int ans=1>>30;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	   for(int j=1;j<=n;j++)
	   mp[i][j]=-INF;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		u++,v++;//这里下标全部加1了 
		mp[u][v]=w; //存边 
	}
	for(int i=1;i<=(1<<n)-1;i++)
	   for(int j=1;j<=n;j++)
	   f[i][j]=-INF; //初始化 
	f[1][1]=0;//在起点处路程为0 
	for(int s=1;s<=(1<<n)-1;s++)
	{
		for(int i=1;i<=n;i++)
		{
			if(!(s&(1<<(i-1)))) continue;//如果i不在集合s里，就舍 
			for(int j=1;j<=n;j++)
			{
				if(i==j) continue;
				if(!(s&(1<<(j-1)))) continue;//同理，如果j不在集合s里，也舍，一定要加，不然就会得2分的好成绩 
				f[s][i]=max(f[s][i],f[s^(1<<(i-1))][j]+mp[j][i]); //s^(1<<(i-1))表示上一步i还不在集合s里 
			}
		}
	}
	for(int i=1;i<=(1<<n)-1;i++)
	ans=max(ans,f[i][n]);//枚举所有状态 
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：LightningUZ (赞：1)

简述：$n$ 个点的图，钦定起点和终点，不能经过一个点多次，求最长路。$n<=18$。

### 另一个题

$n$ 个点的图，没有说要钦定起点和终点，其它一样。

旅行商问题。非常 $simple$ 的状压。设 `dp[i][S]` 表示，结束点为 $i$，经过点状态为 $S$ ，的最长路。

然后每次找到 $S$ 中的元素 $j,i$，并且满足 $len(j,i)>0$ （$len$ 表示边权），然后用 `dp[j][S^(1<<i)]+len(j,i)` 转移到 `dp[i][S]`。注意初始值都是 $-INF$。

最后，任意取终点，任意取状态，求最大值，就是问题答案

### 回到这个题

我们发现它不仅要钦定起点，还要钦定终点。那怎么办？

首先想到记三维：起点，终点，状态。但是简单计算可知空间会爆炸。

实际上，可以直接修改状态：

把原来那个 `dp[i][S]` 改成：从 $0$ 号点开始，经过了状态 $S$，最后停在了点 $i$ 的最长路。

然后发现转移是一样的（自己推一下即可）。

取答案的时候，要注意：
- $i$ 强制为 $n-1$
- $S$ 中不包含 $0$ 号点，要不然就会走两次。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 18
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define all(a) a.begin(),a.end()
    #define iter(a,p) (a.begin()+p)
    int I() {char c=getchar(); int x=0; int f=1; while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar(); while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar(); return (x=(f==1)?x:-x);}
    template <typename T> void Rd(T& arg){arg=I();}
    template <typename T,typename...Types> void Rd(T& arg,Types&...args){arg=I(); Rd(args...);}
    void RA(int *p,int n) {F(i,1,n) *p=I(),++p;}
    int n,m,g[N][N];
    void Input()
    {
        Rd(n,m);
        MEM(g,0xcf);
        F(i,1,m)
        {
            int u,v,w; Rd(u,v,w); if (u==v) continue;
            g[u][v]=max(g[u][v],w);
        }
    }
    int dp[N][1<<N];
    void Soviet()
    {
        MEM(dp,0xcf);
        F(i,0,n-1) dp[i][1<<i]=g[0][i];
        F(s,1,(1<<n)-1) F(i,0,n-1) if (((s>>i)&1) and (s^(1<<i))!=0) F(j,0,n-1) if (((s>>j)&1) and j!=i and g[j][i])
        {
            dp[i][s]=max(dp[i][s],dp[j][s^(1<<i)]+g[j][i]);
            // printf("dp[%d][%d]=%d\n",i,s,dp[i][s]);
        }
        int ans=0;
        F(j,0,(1<<n)-1) if ((j&1)==0) ans=max(ans,dp[n-1][j]);
        printf("%d\n",ans);
    }
    void IsMyWife()
    {
        Input();
        Soviet();
    }
}
#undef int //long long
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();
    return 0;
}
```

### 后记

这题居然有紫？？？顶多绿吧

---

## 作者：冰凉的水 (赞：1)

# 	最长路
- 	鄙人首先的思路是用单源最短路径来做(反向取长边),因为点不是很多(n<=18).结果wa了一大片(大概是我太蒻了),欢迎大家~~乱搞尝试~~一下.
-  	然后,暴搜吧.花样dfs,bfs是70~80分.显然,要加点玄学.
```cpp
void bfs()
{
    queue<node>q;
    node p;
    p.spot=1;
    p.len=0;
    p.d=1;
    q.push(p);
    while(q.size())
    {
        node x=q.front();q.pop();
        int i=h[x.spot];
        while(i)
        {
            if(!((x.d>>(a[i].to-1))&1))
            {
            p.spot=a[i].to;
            p.len=a[i].w+x.len;
            p.d=x.d|(1<<(a[i].to-1));
            if(p.spot!=n)
            q.push(p);
            else if(p.spot==n)ans=max(ans,p.len);
            }
            i=a[i].from;
        }
    }
}
```
-	这种搜索会爆MLE和TLE(~~这句是废话~~),后来就参照了题主orz%%%(果然,蒟蒻永远是蒟蒻).
-	总体思路是状压dp+最**长**路.贴代码:
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int N=18+2,INF=10000*20;
inline int read()
{
    char c=getchar();int num=0;
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9'){num=num*10+c-'0';c=getchar();}
    return num;
}
int imap[N][N];//邻接矩阵
int d[1<<N][N],sy[1<<N][N]={0};//记录搜寻状态
struct miaow
{
    int a,b;
};
int main()
{
    register int n,m;
    n=read();
    m=read();
    for(register int i=0;i<n;++i)
    {
        for(register int j=0;j<n;++j)
        {
            if(i==j)imap[i][j]=0;
            else imap[i][j]=INF;
        }
    }
    for(register int i=0;i<m;++i)
    {
        register int x,y,z;
        x=read();y=read();z=read();
        imap[x][y]=min(imap[x][y],z);
    }
    for(register int i=0;i<(1<<(n));++i)
    {
        for(register int j=0;j<n;++j)
        {
            d[i][j]=0;
        }
    }
    miaow qwe;
    queue<miaow> asd;
    d[1][0]=0;
    sy[1][0]=1;
    qwe.a=1;
    qwe.b=0;
    asd.push(qwe);
    register int ans=0;
    while(!asd.empty())
    {
        qwe=asd.front();
        asd.pop();
        register int i=qwe.a,j=qwe.b;
        register int i2=i;
        sy[i][j]=0;
        register int bj[N]={0};
        for(register int k=n-1;k>=0;--k)
        {
            if(i2>=(1<<k))
            {
                i2-=(1<<k);
                bj[k]=1;
            }
        }
        for(register int k=0;k<n;++k)
        {
            if(!bj[k]&&imap[j][k]!=INF&&d[i][j]+imap[j][k]>d[i+(1<<k)][k])
            {
                d[i+(1<<k)][k]=d[i][j]+imap[j][k];
                if(k==n-1)
                {
                    ans=max(ans,d[i+(1<<k)][k]);
                    break;
                }
                if(!sy[i+(1<<k)][k])
                {
                    qwe.a=i+(1<<k);
                    qwe.b=k;
                    asd.push(qwe);
                    sy[i+(1<<k)][k]=1;
                }
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Mr_think (赞：0)

## [P4802 [CCO 2015]路短最](https://www.luogu.com.cn/problem/P4802)

## 题目大意：

给出一张带权连通图，求 $0$ 到 $n-1$ 的最长简单路径的长度。

## solution:

看到很小的数据范围 $2\le n \le 18$ 我们可以考虑状压。设**状态** $f[\,i\,][\,j\,]$ 为当前状态为 $\,i\,$ 走到 $\,j\,$ 点的最大路径长。~~易得~~状态转移方程为：
   $$f[\,i\,][\,j\,]= \text{max}(f[\,i\,][\,j\,],f[\,i\, \bigoplus\,(1\ll j)][\,k\,]+l[\,k\,][\,j\,]) $$
   
对于**阶段**，可以这样来枚举：

1. 枚举每种状态 $i$ ：$(1001110,1001111,1110101……)$ ；

2. 枚举当前点 $j$ ；

3. 枚举到达 $j$ 的点 $k$ 。

## 细节处理：

- 注意 $l[\,i\,][\,j\,]$ 的顺序，是 $i->j$ 。
- 由于求最大值，我们要将 $f$ 数组赋个**较**小值，可 $\text{memset}(f,0xcf,\text{sizeof}(f))$ ，不要太小，以免溢出。

看到这的同学，可以自己去写代码了(~~tf口吻~~)

[code](https://www.luogu.com.cn/paste/8ez73a7z)

### End

## 作者的碎碎念：

有用留赞(~~言简意赅~~)

---

## 作者：keep_ (赞：0)

# P4802 【[CCO 2015]路短最】

## 前言

一道状压$dp$入门题，适合用来练习状压$dp$

## 分析

我们用 $dp[i][j]$表示状态为$j$，当前所在

节点为$i$时到达终点$n$且不重复经过节点的

最短路径，什么是状态 $j$ ？$j$指我们经过

节点的状态，用来表示经过了哪些点，没经过

哪些点，$j$的本质为二进制01串，假设

$i$号点被遍历过，我们就将第$j$的第$(i-1)$ 位设为1，表示经过$i$号

点。然后就非常简单了，直接记忆化搜索得到答案即可，细节注释

写在代码里

## 代码
```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<string>
#include<algorithm> 
#include<cstdlib>
#define int long long
using namespace std;
const int maxn=2000;
inline int read(){
	int ret=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-f;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		ret=ret*10+(ch^'0');
		ch=getchar();
	}
	return ret*f;
}
struct edge{
	int to,nxt,w;
}e[maxn];
int head[maxn],cnt;
inline void add(int u,int v,int w){
	cnt++;
	e[cnt].to=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	
}
int n,m;
int dp[1<<18][20];//状压数组
int dfs(int u,int las){//u为当前节点，las为当前状态
	if(u==n){//如果达到终点，直接返回0,为什么是0,因为当前点到终点的最小距离为0
		return 0;
	}
	if(dp[las][u]){
		return dp[las][u];//记忆化部分，已经搜过不用重复计算
	}
	int len=-0x3f3f3f3f;
	for(int i=head[u];i;i=e[i].nxt){
		int y=e[i].to;
		int w=e[i].w;
		if(!(las&(1<<y-1))){
			len=max(len,w+dfs(y,las|(1<<y-1)));//获取最大值
		}
	} 
	return dp[las][u]=len;//返回答案
}
signed main(){
//	freopen("a.in","r",stdin);
	n=read();
	m=read();
	int x,y,z;
	for(int i=1;i<=m;i++){
		x=read();
		y=read();
		z=read();
		x++;
		y++;
		add(x,y,z);
	}
	cout<<dfs(1,1);
	return 0;
}

```



---

## 作者：dshzsh (赞：0)

## 基本思路
状态压缩 DP，设状态（每一位为现在已经加入的点）为 $s$，当前位置为 $i$,则  
`dp[(s|(1<<(j-1)))][j]=max(dp[(s|(1<<(j-1)))][j],dp[s][i]+mp[i][j])`  
解释：要加入一个点 $j$ 时。  
状态 $s$ 中第 $j$ 位变为一（s|(1<<(j-1)))）。  
此时路径长相当于之前 $s$ 第 $j$ 为为0的状态+$i$ 到 $j$ 的距离。  
然后比较和原来的路径的长度，取最大值。  


------------

这道题除了这个有很多要注意的点。 ~~我都错过~~
## 常见错误
### 54分
这道题**不一定要走完所有的城市**，与[恰奶酪](https://www.luogu.com.cn/problem/P1433)不一样。  
### 60分
由于这道题求最长路，存路径的数组和dp数组必须**初始化**为一个很大的负数。


------------
下面是 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=20;
long long mp[maxn][maxn];
long long dp[(1<<17)+10][maxn];
const long long inf=2e14;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=0;i<=19;i++)//初始化
		for(int j=0;j<=19;j++)
			mp[i][j]=-inf;
	for(int i=1;i<=m;i++)
	{
		int s,d,l;
		scanf("%d%d%d",&s,&d,&l);
		mp[s+1][d+1]=max(mp[s+1][d+1],(long long)l);//我把点位移一格的原因是习惯了，不位移可能更方便一点
	}
	n--;
	for(int s=0;s<(1<<(n));s++)
		for(int i=1;i<=n;i++)
		{
			dp[s][i]=-inf;
		}
	dp[1][1]=0;//从1号点出发
	for(int s=0;s<(1<<(n));s++)//求最长路
		for(int i=1;i<=n;i++)
		{
			if(s&(1<<(i-1)))
			{
				for(int j=1;j<=n;j++)
				{
					if((s&(1<<(j-1)))==0)
						dp[(s|(1<<(j-1)))][j]=max(dp[(s|(1<<(j-1)))][j],dp[s][i]+mp[i][j]);
				}
			}
		}
	long long ans=-inf;
	for(int s=0;s<(1<<n);s++)//放超时和爆数组，单独判断最后一个点
		for(int i=1;i<=n;i++)
			ans=max(dp[s][i]+mp[i][n+1],ans);
	printf("%lld\n",ans);
	return 0;
} //made by dshzsh
```


---

## 作者：1saunoya (赞：0)

[my blog](https://www.cnblogs.com/Isaunoya/p/11629649.html)


这题的题意是 求一条 经过 起点和终点的 最长路径。且一个点只能经过一次。


我们设定 $dis_{i,j}$ 为 i 到 j 的距离（应该没有重边）
要注意的是 不能用 $Floyd$ 求最长路 这样会挂掉
因为你这样 就没办法保证 点 $i$ 只经过一次
显然是状压dp 我们考虑 dp 状态 $dp_{i,j}$ 
$i$ 表示当前位置 $j$表示走过的地方

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define int long long
#define fi first
#define se second
#define pb push_back
inline int read() {
	register int x = 0 , f = 1 ;
	register char c = getchar() ;
	for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
	for( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;
	return x * f ;
}
template < typename T > inline bool cmax(T & x , T y) {
	return x < y ? (x = y) , 1 : 0 ;
}
template < typename T > inline bool cmin(T & x , T y) {
	return x > y ? (x = y) , 1 : 0 ;
}
template < typename T > inline bool cabs(T & x) {
	return x > 0 ? 1 : (x = - x) , 0 ;
}
inline int QP(int x , int y , int Mod) {
	int ans = 1 ;
	for( ; y ; y >>= 1 , x = (x * x) % Mod)
		if(y & 1) ans = (ans * x) % Mod ;
	return ans ;
}
int n , m ;
const int N = 19 ;
int dis[N][N] ;
int dp[N][1 << N] ;
signed main() {
	memset(dis , 0xcf , sizeof(dis)) ;
	memset(dp , 0xcf , sizeof(dp)) ;
	n = read() , m = read() ;
	for(register int i = 1 ; i <= m ; i ++) {
		int u = read() , v = read() , w = read() ;
		dis[++ u][++ v] = w ;
	}
	for(register int i = 2 ; i <= n ; i ++) dp[i][1 + (1 << i - 1)] = dis[1][i] ;
	int s = (1 << n) - 1 ;
	for(register int i = 2 ; i <= s ; i ++) {
		for(register int j = 1 ; j <= n ; j ++) {
			if((i & (1 << j - 1)))
				for(register int k = 1 ; k <= n ; k ++) {
					if(j ^ k && (! (i & (1 << k - 1)))) {
						cmax(dp[k][i | (1 << k - 1)] , dp[j][i] + dis[j][k]) ;
					}
				}
		}
	}
	int ans = 0 ;
	for(register int i = (1 << n - 1) + 1 ; i <= s ; i ++)
		cmax(ans , dp[n][i]) ;
	printf("%lld\n" , ans) ;
	return 0 ;
}
```

---


# 如何得到 npy

## 题目背景

作为年级第一大风流人物，Steve 总会给自己找很多东西，包括但不限于 npy。Steve 看上了 Ada，并试图接近她，然而 Ada 并不是那么乐意。

## 题目描述

**提示：你可以阅读题目描述末尾的形式化题面。**

Steve 所在的校园有 $n$ 间教室，编号为 $1$ 到 $n$，有 $n-1$ 条走廊将其连通。也就是说，教室和走廊构成了一棵树。每条走廊都有一定的长度 $w_i$，经过这条走廊的时间等于其长度的数值。

Steve 喜欢在校园里游荡。当然，他希望最后能走到自己的教室 $s$ 或 Ada 的教室 $t$。但由于学校过于错综复杂，且 Steve 不想走回头路，所以他想到了如下方案：

对于每个教室（Steve 和 Ada 的教室除外，这两个教室周围不应该有任何标牌），在一条与其相连的边立上标牌。每次走到这个教室，就从立了标牌的边出。

Steve 可能会在学校的任何一个教室出现，所以一方面，Steve 需要让他从每个教室都能跟着标牌回到他的或 Ada 的教室。另一方面，他希望从学校所有教室走到目的地的**时间总和**尽可能小。

由于 Steve 又要去找 Ada 了，所以请你帮他完成这个任务。

#### 形式化题意

给定一棵 $n$ 个节点的无根树和两个关键点 $s,t$，要求对所有边定向，满足：

- 每条边要么是有向边，要么被删除；
- 每个点（除 $s,t$）出度恰好为 $1$，$s,t$ 出度为 $0$；
- 每个点都可以顺着有向边到达 $s$ 或 $t$。

求每个点到 $s$ 或 $t$ 的距离总和最小值。

## 说明/提示

#### 样例 1 解释

`2011` 也是合法的答案，但 `2211`，`1102` 等都不是。

#### 样例 2 解释

下图是取到样例中最优解的状态（$(8,13)$ 这条边没有画出）:

![](https://cdn.luogu.com.cn/upload/image_hosting/78tlf89y.png)

#### 样例 3 解释

该样例满足子任务 2 的限制条件。

#### 样例 4 解释

该样例满足子任务 5 的限制条件。

---

下发文件中还有 `checker.cpp` 可判定答案是否合法。使用时，先编译（设二进制文件为 `checker`（Linux/MacOS）或 `checker.exe`（Windows）），然后在终端输入如下命令：

```
./checker in.txt out.txt ans.txt
```

如果你使用了 Windows 系统且无法运行上述命令，请尝试：

```
checker.exe in.txt out.txt ans.txt
```

其中 `in.txt`、`out.txt`、`ans.txt` 分别是放在同一目录下的输入文件、选手输出、标准答案。

结果可能有如下中的一种：

- `ok`：结果正确，可以得到满分；
- `wrong answer`：第一行答案错误；
- `points 0.60`：第一行答案正确，第二行答案错误。

对于所有非满分情况，会有附加消息，意义如下：

- `A x y`：第一行答案错误，标准答案是 $x$，选手答案是 $y$；
- `B`：第二行长度不符合条件；
- `C`：第二行出现非法字符；
- `D`：第二行给出的构造不满足题目中关于度数的限制；
- `E x y`：第二行给出的构造产生的答案是 $y$，而实际上答案是 $x$。

该校验器和最终评测时采用的校验器可能有所不同。

注意下发文件的输出样例中只有最优答案，没有构造方案。

### 数据规模与约定

**本题捆绑测试**。对于所有数据，$3\le n\le 3\times 10^5$，$1\le w_i\le2\times 10^8$，$1\le s,t\le n$，$s\neq t$。

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c||c|c}\hline

\bf 子任务 & \bf 分值 & \bf 依赖 & n\le & \bf特殊性质
\\
\hline
\hline
1 & 10 & / & 10 & /\\\hline
2 & 15 & 1 & 18 & /\\\hline
3 & 15 & / & / & v_i=u_i+1\\\hline
4 & 10 & / & / & u_i=1\\\hline
5 & 20 & / & / & 存在边\ (s,t)\\\hline
6 & 30 & 2\sim5 &/ & /
\end{array}
$$

如果你计算出了正确的答案，但是你的构造是错误的，那你将得到该测试点 $60\%$ 的分数。注意即使你只实现了第一小问，请依旧在第二行输出任意一个非空字符串，否则可能会不计分。

本题中的依赖指：某子任务的得分占比不能超过其所依赖的子任务得分占比。比如，一选手子任务 $1$ 得到 $60\%$ 的分数，则他的子任务 $2$ 就不会超过对应的 $60\%$ 分数，即不超过 $9$ 分。

答案可能很大，请注意你使用的数据类型。

---

到毕业为止，Steve 也没有追到 Ada。What a sad story. :-(

## 样例 #1

### 输入

```
5 1 5
1 2 1
2 3 1
3 4 1
4 5 1```

### 输出

```
4
2201```

## 样例 #2

### 输入

```
13 4 5
1 3 3
2 3 2
6 4 5
7 4 10
4 8 2
11 8 3
5 13 6
8 13 5
8 3 4
10 5 8
12 10 3
13 9 9```

### 输出

```
85
111121202112```

## 样例 #3

### 输入

```
见下发文件 corridor/corridor3.in```

### 输出

```
见下发文件 corridor/corridor3.ans```

## 样例 #4

### 输入

```
见下发文件 corridor/corridor4.in```

### 输出

```
见下发文件 corridor/corridor4.ans```

# 题解

## 作者：5ab_juruo (赞：12)

好玩的图论题

普及出构造过分吗？

---

原题意等价于给边定向。

### subtask1,2

暴力，看实现得优秀与否。

### subtask3

链。一种原图的弱化情况，不需要考虑旁支，好写一点。
不妨设 $1$ 为左端，$n$ 为右端，且 $s$ 在 $t$ 左侧。
	
一条链可以被 $s,t$ 分成三部分：$1\sim s$，$s\sim t$，$t\sim n$。

对于第一和第三部分，边的方向是一定的。而对于第二部分，存在一条分界边，左侧的边向 $s$ 指，右侧的边向 $t$ 指。

这个东西可以直接枚举，稍微处理一点前缀和就可以做了。

### subtask4

菊花图。考虑到可能有误导的倾向，给的分比较少。

### 60 分（\_ZMF\_）

答案为 $\sum_i\min(d(i,s),d(i,t))$，其中 $d(u,v)$ 代表 $u,v$ 在树上的路径长度。

可以 $\mathcal{O}(n\log n)$ 求，也可以倒过来两次 bfs。

**证明**

假设在最小的方案中，有两条路径相交，则显然两个终点一定不同。设两条路径分别为 $(u,s),(v,t)$。

考虑将其修改成 $(u,t),(v,s)$，注意到两者唯一的区别在于路径不相交，其余路径方向都相同。同时，答案也比原来更优，矛盾。

### subtask5

注意到所有边的方向实际上是确定的，直接模拟即可。

### subtask6

首先，注意到除了 $(s,t)$ 路径上的边，其余边的方向都是确定的。

其次，在 $(s,t)$ 上一定有一条边 $e$，使得 $e$ 一边都指向 $s$，另一边都指向 $t$，且 $e$ 不定向。

直接枚举 $e$ 即可。

```cpp
/* name: d
 * author: 5ab
 * created at: 22-06-27 00:06
 */
#include <cstdio>
#include <cctype>
#include <cstring>
using namespace std;

typedef long long ll;
const int max_n = 300000;

int hd[max_n], des[max_n<<1], nxt[max_n<<1], val[max_n<<1], f[max_n], fi[max_n], siz[max_n], e_cnt = 0, bne;
ll sdep[max_n], tsm[max_n], tdep[max_n], ssm[max_n];
char ans[max_n];

void add(int s, int t, int v)
{
	des[e_cnt] = t, val[e_cnt] = v;
	nxt[e_cnt] = hd[s], hd[s] = e_cnt++;
}

ll *sm, *dep;
void dfs(int id, int fa)
{
	siz[id] = 1, sm[id] += dep[id], f[id] = fa;
	for (int p = hd[id]; p != -1; p = nxt[p])
		if (des[p] != fa)
		{
			dep[des[p]] = dep[id] + val[p];
			fi[des[p]] = (p >> 1);
			dfs(des[p], id);
			siz[id] += siz[des[p]];
			sm[id] += sm[des[p]];
		}
}

void dfs2(int id, int fa)
{
	for (int p = hd[id]; p != -1; p = nxt[p])
		if (des[p] != fa && (p >> 1) != bne)
		{
			ans[p>>1] = '2' - (p & 1);
			dfs2(des[p], id);
		}
}

inline int read()
{
	int c = getchar(), t = 1, n = 0;
	while (isspace(c)) { c = getchar(); }
	if (c == '-') { t = -1, c = getchar(); }
	while (isdigit(c)) { n = n * 10 + c - '0', c = getchar(); }
	return n * t;
}

void pans(ll x)
{
	if (x >= 10)
		pans(x / 10);
	putchar(x % 10 + '0');
}

signed main()
{
	memset(hd, -1, sizeof hd);
	
	int n = read(), s = read(), t = read();
	
	for (int i = 1, x, y, c; i < n; i++)
	{
		x = read(), y = read(), c = read();
		add(x-1, y-1, c), add(y-1, x-1, c);
	}
	sm = tsm, dep = tdep, dfs(t-1, -1);
	sm = ssm, dep = sdep, dfs(s-1, -1);
	
	ll mxoffset = 0;
	for (int x = t - 1; x != s - 1; x = f[x])
		if (tsm[f[x]] + ssm[x] > mxoffset)
		{
			// cerr << x << " " << dep[x] << " " << siz[x] << " " << fi[x] << endl;
			mxoffset = tsm[f[x]] + ssm[x];
			bne = fi[x];
		}
	
	memset(ans, '0', sizeof(char) * (n - 1));
	dfs2(s-1, -1), dfs2(t-1, -1);
	
	pans(ssm[s-1] + tsm[t-1] - mxoffset);
	printf("\n%s", ans);
	
	return 0;
}
```

---

## 作者：xwh_Marvelous (赞：8)

这个比赛对于真正的普及组还是良心了qwq

-----------------

首先给定的图是一个树，由于树的性质，那么各个点到 $s$ 或 $t$ 的路径便是唯一的。我们分别从 $s$ 和 $t$ 做 dfs 就可以求出 $s$ 和 $t$ 到各个点的距离。

接下来是确定各个点的要去往 $s$ 还是 $t$。显然为了使距离和最小，我们肯定选更近的一个点。

第一种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/idvomoel.png)

我们要确定的点在 $s$ 到 $t$ 链上。那我们肯定是距离哪边更近就去那边。如图，点 1 就去 $s$，点 2 点 3 就去 $t$。

第二种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/gljebmfz.png)

我们要确定的点在 $s$ 的左边或 $t$ 的右边上。这也很明显。

第三种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/nf4xpdb5.png)

我们要确定的点在 $s$ 到 $t$ 链上某个点的分支部分。虽然这个图给的数据很小，但我们可以感性的理解一下。$s$ 到 $1$ 比 $t$ 到 $1$ 的距离要长，那么 $s$ 到 $2$ 比 $t$ 到 $2$ 的距离也会要更长。

综上，我们对所有点确定终点的方式都可以归纳成那边近就去那边。所以我们在用 dfs 来确定方向，将对应方向打上标记。总的时间复杂度只有 $\operatorname{O}(n)$，对于 $3 \times 10^5$ 的数据可以说是跑得飞快。

**AC code**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,t;
long long a[300005],b[300005],ans;
int tot;
struct node{
	int x,y;
	int bc;
}ls[3000005];
void link(int u,int v,int w){
	ls[++tot].bc=ls[u].bc;
	ls[u].bc=tot;
	ls[tot].x=v;
	ls[tot].y=w;
}
int u[300005],v[300005],w[300005];
int hs[300005];
void dfs1(int x,int f,long long d){
	a[x]=d;
	for(int i=ls[x].bc;i;i=ls[i].bc){
		if(ls[i].x==f)continue;
		dfs1(ls[i].x,x,d+ls[i].y);
	}
}
void dfs2(int x,int f,long long d){
	b[x]=d;
	for(int i=ls[x].bc;i;i=ls[i].bc){
		if(ls[i].x==f)continue;
		dfs2(ls[i].x,x,d+ls[i].y);
	}
}
void dfs3(int x,int f,long long d){
	for(int i=ls[x].bc;i;i=ls[i].bc){
		if(ls[i].x==f)continue;
		if(a[ls[i].x]<=b[ls[i].x])hs[ls[i].x]=x,ans+=a[ls[i].x];
		dfs3(ls[i].x,x,d+ls[i].y);
	}
}
void dfs4(int x,int f,long long d){
	for(int i=ls[x].bc;i;i=ls[i].bc){
		if(ls[i].x==f)continue;
		if(a[ls[i].x]>b[ls[i].x])hs[ls[i].x]=x,ans+=b[ls[i].x];
		dfs4(ls[i].x,x,d+ls[i].y);
	}
}
inline long long read(){
	int ans=0,sign=1;
	char ch = getchar();
	while(ch<'0'||ch>'9'){
		ch = getchar();
	}
	while(ch>='0'&&ch<='9'){
		ans = ans*10 + ch-'0';
		ch = getchar();
	}
	return ans*sign;
}
int main(){
	scanf("%d%d%d",&n,&s,&t);
	tot=n;
	for(int i=1;i<n;i++){
		u[i]=read(),v[i]=read(),w[i]=read();
		link(u[i],v[i],w[i]);
		link(v[i],u[i],w[i]);
	}
	dfs1(s,0,0);
	dfs2(t,0,0);
	dfs3(s,0,0);
	dfs4(t,0,0);
	printf("%lld\n",ans);
	for(int i=1;i<n;i++){
		if(v[i]==hs[u[i]])putchar('1');
		else if(u[i]==hs[v[i]])putchar('2');
		else putchar('0');
	}
	return 0;
}
```


---

## 作者：iiiiiyang (赞：5)

# 如何得到npy

[更好的阅读体验](https://www.cnblogs.com/LittleTwoawa/p/16656536.html)

[题目链接](https://www.luogu.com.cn/problem/P8509)

普及组模拟赛良心第四题，感觉比第三题简单捏。

这道题分成两问。对于前一问，简化题意是给定一棵有 $n$ 个点的树，给定两个起点 $s$ 和 $t$，求一个两个起点的“单”源最短路径。板子题咯，初始的优先队列把两个点都放进去就好了。

对于第二问，我们观察样例就可以发现，不管怎么构造，都只会有一个 $0$。手玩一下这个 $0$ 的位置，容易得到实际上整棵树上的点被分为了两部分，一部分是最短路的起点为 $s$，另一部分是最短路的起点为 $t$，而那个 $0$ 则恰好是两大部分交界的位置。

因此有一种构造方法，就是在跑最短路的时候记录下每一个点是由谁扩展来的，然后最后遍历一下每一条边判断方向即可。

$Code$
```cpp
#include<bits/stdc++.h>
#define int long long
#define MAX 300010
using namespace std;

inline int read()
{
	int s=0,w=1;
	char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
	return s*w;
}

int n,s,t;
int x,y,z;
int ans,lis[MAX];

struct edge
{
	int nex,to,val;
	int id;
}e[MAX<<1];
int head[MAX<<1],cnt,from[MAX<<1];
inline void add(int x,int y,int z,int id)
{
	cnt++;
	e[cnt].nex=head[x];
	e[cnt].to=y;
	e[cnt].val=z;
	e[cnt].id=id;
	head[x]=cnt;
	return;
}
inline bool cmp(edge a,edge b)
{
	return a.id<b.id;
}

int dis[MAX],vis[MAX];
priority_queue<pair<int,int> > q;
inline void dijkstra()
{
	memset(dis,0x3f,sizeof dis);
	memset(vis,0,sizeof vis);
	dis[s]=0,dis[t]=0;
	q.push(make_pair(0,s)),q.push(make_pair(0,t));
	while(!q.empty())
	{
		int t=q.top().second; q.pop();
		if(vis[t]) continue;
		vis[t]=1;
		for(int i=head[t];i;i=e[i].nex)
		{
			int to=e[i].to,val=e[i].val;
			if(dis[to]>dis[t]+val)
			{
				dis[to]=dis[t]+val;
				from[to]=t;
				q.push(make_pair(-dis[to],to));
			}
		}
	}
	return;
}

signed main()
{
	n=read(),s=read(),t=read();
	for(int i=1;i<n;++i)
		x=read(),y=read(),z=read(),add(x,y,z,i),add(y,x,z,i+n);
	dijkstra();
	for(int i=1;i<=n;++i)
		ans+=dis[i];
	cout<<ans<<endl;
	for(int i=1;i<=n;i++)
	{
		for(int j=head[i];j;j=e[j].nex)
		{
			int to=e[j].to,id=e[j].id;
			if(e[j].id>n) continue;
			if(from[to]==i)
				lis[id]=2;
			if(from[i]==to)
				lis[id]=1;
		}
	}
	for(int i=1;i<n;i++)
		cout<<lis[i];
	return (0-0);
}
```


---

## 作者：SUNCHAOYI (赞：2)

第一问很好求，相当于是所有点到 $s$ 或 $t$ 中较近的点的最短路径之和。换句话说，把 $s$ 与 $t$ 分别作为起点，跑两遍最短路后得到 $diss,dist$ 分别表示最短路，则答案即为 $\sum\limits_{i = 1}^{n} \min (diss_i,dist_i)$。又由于题目给的是一棵树，所以其实距离就相当于普通的子树向父亲节点的转移。第一问的代码如下：

```cpp
void dfs (int u,int fa,ll *dis)
{
	for (int i = head[u];i;i = nxt[i])
	{
		int v = to[i];
		if (v == fa) continue;
		dis[v] = dis[u] + val[i];
		dfs (v,u,dis);
	}
}
dfs (s,0,dis1);dfs (t,0,dis2);
for (int i = 1;i <= n;++i) ansdis[i] = min (dis1[i],dis2[i]),ans += ansdis[i];
printf ("%lld\n",ans);
```

第二问相当于是还原路径，再次跑两遍最短路，当跑到一个节点 $u$ 时，若发现 $ansdis_u$ 加上边权后恰好等于 $ansdis_v$，也就是说这是一个可能的还原方式，把这个点所在的边标记一下。

当所有点标记以后，尝试进行判断出入边。考虑第 $i$ 条双向边满足边的下标 $x,y$ 为 $2i,2i+1$ 时存在性质 $x \oplus 1 = y,y \oplus 1 = x$，所以当下标为奇数时相当于从起点 $s,t$ 的出边，在构造答案时需要注意出入恰好反向。于是我们便得到了第二问的代码：

```cpp
void solve (int u,int fa)
{
	for (int i = head[u];i;i = nxt[i])
	{
		int v = to[i];
		if (v == fa) continue;
		if (min (dis1[v],dis2[v]) == ansdis[u] + val[i]) vis[v] = i;//能够还原时记录该点所在边
		solve (v,u);
	}
}
solve (s,0);solve (t,0);
for (int i = 1;i <= n;++i)//利用双向边的性质进行构造
{
	if (!vis[i]) continue;
	ty[vis[i] >> 1] = (vis[i] & 1) ? 1 : 2;//注意恰好相反
}
for (int i = 1;i < n;++i) printf ("%d",ty[i]);
```

---

## 作者：邈云汉 (赞：2)

感觉没有绿题的难度吧。思路非常简单，分别从 $s$ 和 $t$ 出发做一次遍历，记录到达每个点的距离，计算总和时取最小值即可。

证明：

首先证明最优性：每个点必须要能走到 $s$ 或 $t$，上述方案在满足该条件的情况下选择最小距离，一定不存在比此更小的答案。

再证明可行性：题目要我们给出一种构造方案，如果能够给出至少一种构造方案，那么自然也就证明了该方案的可行性。对于每个点，记录从 $s$、$t$ 出发搜索到它时是从哪条边进来的，在该点立一块指向答案更小的边的标牌即可（此处的答案更小，指的是若到 $s$ 的距离近，就选从 $s$ 搜索到它的那条边，反之亦然，相等时随意）。我们也易知一个点和选择的那条边连接的另一个点到 $s$ 还是 $t$ 的距离近是一样的。

代码实现方式有多种，没什么需要特别注意的，挺好写：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6e5+5;
struct node{
	int u,v;
	long long w;
}e[N];
long long dis1[N],dis2[N],edge[N];
int ver[N],Next[N],head[N],tot=1,ans[N],ans1[N],ans2[N];
void add(int u,int v,long long w)
{
	ver[++tot]=v,edge[tot]=w,Next[tot]=head[u],head[u]=tot;
}
void dfs1(int x)
{
	for(int i=head[x];i;i=Next[i])
	{
		if(dis1[ver[i]])continue;
		dis1[ver[i]]=dis1[x]+edge[i];
		ans1[ver[i]]=(i^1)/2;
		dfs1(ver[i]);
	}
}
void dfs2(int x)
{
	for(int i=head[x];i;i=Next[i])
	{
		if(dis2[ver[i]])continue;
		dis2[ver[i]]=dis2[x]+edge[i];
		ans2[ver[i]]=(i^1)/2;
		dfs2(ver[i]);
	}
}
int main()
{
	int n,s,t;
	scanf("%d%d%d",&n,&s,&t);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d%lld",&e[i].u,&e[i].v,&e[i].w);
		add(e[i].u,e[i].v,e[i].w);
		add(e[i].v,e[i].u,e[i].w);
	}
	dis1[s]=dis2[t]=1;
	dfs1(s),dfs2(t);
	long long res=0;
	for(int i=1;i<=n;i++)
	{
		res+=min(dis1[i]-1,dis2[i]-1);
		if(i==s||i==t)continue;
		if(dis1[i]<dis2[i])
		{
			if(i==e[ans1[i]].u)ans[ans1[i]]=1;
			else ans[ans1[i]]=2;
		}
		else
		{
			if(i==e[ans2[i]].u)ans[ans2[i]]=1;
			else ans[ans2[i]]=2;
		}
	}
	printf("%lld\n",res);
	for(int i=1;i<n;i++)printf("%d",ans[i]);
	return 0;
}
```


---

## 作者：y_kx_b (赞：2)

考场上花了一个多小时才打出 $60$ 分的解，后面的没时间打了，wtcl ![](https://啧.tk/kk)

---
题意转化：

把一棵树断一条边变成两棵树，要求一棵包含 $s$，另一棵包含 $t$ 且每个点到 $s\ \text{or}\ t$ 的距离和最小。

（树边重定向即为各个点通往 $s\ \text{or}\ t$ 的路径的方向，可以看样例\#2 解释的图理解。也就是说，得了 $60\text{ pts}$，再做一遍 dfs 就可以有 $100\text{ pts}$ 了）

Sol.
---
首先，肯定得在 $s\to t$ 的路径上断边，否则断边后不会一棵树包含 $s$ 且另一棵包含 $t$。证明：如果没有在上述路径上断边，那么断边后 $s$ 与 $t$ 仍然联通，必在同一个树中，那么另外一棵树肯定就没有 $s$ 和 $t$ 这两个点中的任何一个，不符合要求。

然后，借用[这道题](https://www.luogu.com.cn/problem/P3478)的思想（虽然那道题是一个树形 dp），我们也做一个类似的做法。

（以下默认原树是一棵以 $s$ 为根结点的有根树。）

设 `ans_s[i]` 为 $i$ 子树内所有结点到 $s$ 的距离总和，`ans_s[i]` 为 $i$ 子树内所有结点到 $t$ 的距离总和，那么枚举 $s\to t$ 的路径上断哪条边答案（为 `ans_s[s]-ans_s[i]+ans_t[i]`）最大。这里的时间复杂度为 $\mathcal O(n)$ 级别。

那么问题来了，这两个数组怎么求呢？$%我们看图说话。（假设 \$(8,13)\$ 有边；忽略边的重定向）![](https://cdn.luogu.com.cn/upload/image_hosting/78tlf89y.png)$

`ans_s` 应该是比较好求的，直接 dfs 一遍即可。具体过程是，假设 dfs 到了 $cur$ 点，那么需要记录 $cur$ 与 $s$ 的距离，将该距离乘上 $cur$ 的子树大小（因为这条链贡献了这么多次答案）再加上 $cur$ 子树中所有点距离它的总长度。求出来。

`ans_t` 可能相对要麻烦些。我们首先要预处理每个结点的子树中是否包含 $t$ 这个点（`bool tin[N]`）。首先我们需要 dfs 到 $t$ 点并记录链；然后求出 $t$ 点子树的答案后，按照类似上面的方法，从 $t$ 到 $s$ 倒着走，每次增加 `tin[i]` 为 $0$ 的结点的贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/clyl0f87.png)

看图说话。我们假设 $s=1$，$t=5$。首先搜到 $5$ 号点，处理出子树的答案 $(=14)$。那么往回走，首先是 $4$ 号点，$2,4,6,7$ 四个点的贡献为 $3\times4+(2+4+4+6)$。再回到 $1$ 号点，答案贡献为 $(3+1)\times2+2$。答案最终为 $52$。

那么，我们现在已经会找断边了，重定向就对着 $s$ 和 $t$ dfs 就行。注意要存断边是哪条边，dfs 的时候不要往断边搜就可以了。

最后附上代码：

（代码中 `dfs1` 预处理和求 `ans_s`，`dfs_dis` 求一个点内的子树的所有点到该点的距离和，`dfs2` 求 `ans_t`，`dfs3` 枚举 $s\to t$ 上的点求答案，`dfs4` 求边的重定向。）

考场代码，可能写的有点乱，敬请见谅。
```cpp
#define int long long
const int inf=(0x3f3f3f3f
#ifdef int
+0ll)<<32|(0x3f3f3f3f
#endif
),_=0,N=314514,M=2145810,logN=24,logn=20;
#define using_graph
#define using_w
#ifdef using_graph
namespace G{
	int ne[M<<1],head[N],to[M<<1],idx1=0,w[M<<1];
	inline void add(int u,int v,int W){
		to[idx1]=v,ne[idx1]=head[u],head[u]=idx1
		#ifdef using_w
		,w[idx1]=W
		#endif
	;idx1++;}inline void addd(int u,int v,int W=1){add(u,v,W),add(v,u,W);}
}using G::ne;using G::head;using G::to;using G::w;//avoid c++17 feature
#endif
int n,s,t;
struct edge{int u,v,w;}e[N];
int size[N];
int ans_s[N],ans_t[N];//ans_s[i]:以s为根时i子树内所有点到s的距离总和
//ans_t[i]:以s为根时i子树内所有点到t的距离总和
bool tin[N];//t在i子树内
int t_father;
int best=0,bestedge=0;
void dfs1(int cur,int fa,int sum){
	size[cur]=1,ans_s[cur]=sum;
	for(int i=head[cur];~i;i=ne[i])
		if(to[i]!=fa){
			dfs1(to[i],cur,sum+w[i]),
			ans_s[cur]+=ans_s[to[i]],
			size[cur]+=size[to[i]];
			if(tin[to[i]])
				tin[cur]=1;
			if(to[i]==t)t_father=cur,best=t,bestedge=i;
		}
}
int dfs_dis(int cur,int fa,int sum){
	int ret=sum;
	for(int i=head[cur];~i;i=ne[i])
		if(to[i]!=fa)
			ret+=dfs_dis(to[i],cur,sum+w[i]);
	return ret;
}
void dfs2(int cur,int fa,int &sum){
	if(cur==t)return;
	for(int i=head[cur];~i;i=ne[i])
		if(to[i]!=fa&&tin[to[i]])
			dfs2(to[i],cur,sum),
			ans_t[cur]=ans_t[to[i]]+(sum+=w[i])*(size[cur]-size[to[i]]);
	for(int i=head[cur];~i;i=ne[i])
		if(to[i]!=fa&&!tin[to[i]])
			ans_t[cur]+=dfs_dis(to[i],cur,w[i]);
}
int dfs3(int cur,int fa){
	int ans=ans_s[s]-ans_s[cur]+ans_t[cur];//断（cur，fa）边
	for(int i=head[cur];~i;i=ne[i])
		if(to[i]!=fa&&tin[to[i]])
		{
			int ret=dfs3(to[i],cur);
			if(ret<ans)ans=ret;
			else if(ret>ans){
				best=cur;
				for(int i=head[cur];~i;i=ne[i])
					if(to[i]==fa)bestedge=i;
			}
		}
	return ans;
}
char status[N];
void dfs4(int cur,int fa){
	for(int i=head[cur];~i;i=ne[i])
		if(to[i]!=fa&&(i^bestedge)>=2)
		{
			// if(cur!=s&&cur!=t)
			{if(e[(i>>1)+1].u==cur)status[/*cur*/(i>>1)+1]+=2;
			else status[(i>>1)+1]++;}
			dfs4(to[i],cur);
		}
}
bool major(){
	mem0(tin);
	mem0xff(head);
	n=read(),s=read(),t=read();
	tin[t]=1;
	for(int i=1;i<n;i++){
		e[i].u=read(),e[i].v=read(),e[i].w=read();
		G::addd(e[i].u,e[i].v,e[i].w);
	}
	dfs1(s,0,0);
	ans_t[t]=dfs_dis(t,t_father,0);
	int useless=0;
	dfs2(s,0,useless);
	printf("%lld\n",dfs3(s,0));
	for(int i=1;i<n;i++)
		status[i]=48;
	dfs4(s,0);
	dfs4(t,0);
	printf("%s\n",status+1);
	return 114514;
}
```

---

## 作者：DiruiXiao (赞：2)

## [P8509 如何得到 npy](https://www.luogu.com.cn/problem/P8509)

虽然是月赛的最后一题，但是却难度不大。大部分的难点还是在于读题。首先题目分为两个问题并且单独计分。先考虑 Q1 ， Q1要求出所有点到达 $s$ 或 $t$ 点的最小值之和，即求：
$$
V = \sum_{i=1}^{n}min(dis_{i, s}, dis_{i, t})
$$
其中 $dis_{i,j}$ 表示从 $i$ 到 $j$ 的唯一路径的长度(毕竟是棵树)。那么问题转换为求出 $dis$ ，就直接跑两遍 DFS，分别处理出所有点到 $s$ 和 $t$ 的最小距离即可。

Q2，问的是一个序列，该序列中的每一个数字都表示了在编号为 $i$ 的边的 $u_i$, $v_i$ 有没有标牌。它本质上是要你把建树的双向边变成一个单向边，把这棵树转化为 $2$ 颗有根树。而它的根分别为 $s$，$t$ 。

而题中的立牌是：
> 0 表示删掉这条边

> 1 表示将原本的输入是 $u$，$v$ 向的双向边转换 $u$，$v$的单向边

> 2 表示将原本的输入是 $u$，$v$ 向的双向边转换 $v$，$u$的单向边


显而易见的，要转换为 $2$ 颗树，就要删掉一条边。而删掉的边显然是在DFS时恰好将树分割为两个集合的边，一个集合离 $s$ 更近，一个集合离 $t$ 更近，因此它的 $id$ 会被设为 $0$。剩下的边分为两类，一类到终点的方向与输入方向一致，设为 $1$，另一类到终点的的方向与输入方向相反，设为 $2$。

最后求和输出，再输出序列即可。

贴下AC的码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#define MAXN 300005
using namespace std;
typedef long long ll; // 注意数据范围 -- 三年OI一场空，不开 long long 见祖宗
template<typename T>
inline void read(T &x) {
	x = 0; T f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch <= '9' && ch >= '0') {
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	x *= f;
}

struct Edge{
	// isor 表示是否是原向边，pos 表示最后边的编号
	int u, v, nex, pos; bool isor;
	ll w;
} edge[MAXN * 2];
static int head[MAXN], ecnt, n, s, t;
ll dis[MAXN]; // 从s或t到达i的最小距离
inline void addEdge(int u, int v, ll w, bool isor) {
	edge[++ecnt].v = v;
	edge[ecnt].u = u;
	edge[ecnt].nex = head[u];
	edge[ecnt].w = w;
	edge[ecnt].isor = isor;
	edge[ecnt].pos = -1; // 初始化
	head[u] = ecnt;
}

inline void DFS(int u, int fa) {
	for (int i = head[u]; i; i = edge[i].nex) {
		int v = edge[i].v;
		if (v == fa) continue;
		if (dis[v] <= dis[u] + edge[i].w) {
			edge[i].pos = 0; // 如果不是更优的解，就删掉边（因为我是两遍DFS同一个dis，所以此时恰好在分割边上）
			if (edge[i].isor == 1) {
				edge[i + 1].pos = -1; // 因为只走一次这个边，把反向边设为 -1
			} else {
				edge[i - 1].pos = -1;
			}
			continue;
		}
		dis[v] = dis[u] + edge[i].w;
		if (edge[i].isor == 1) {
			edge[i].pos = 2; 
			edge[i + 1].pos = -1; // 标记反向边
		} else {
			edge[i].pos = 1;
			edge[i - 1].pos = -1;
		}
		DFS(v, u);
	}
}

int main() {
	read(n), read(s), read(t);
	for (int i = 1; i < n; ++i) {
		int u, v, w; read(u), read(v), read(w);
		addEdge(u, v, w, 1);
		addEdge(v, u, w, 0);
	}
	memset(dis, 127, sizeof(dis));
	dis[s] = 0;
	DFS(s, s);
	dis[t] = 0;
	DFS(t, t);
	ll ans1 = 0;
	for (int i = 1; i <= n; ++i) {
		if (dis[i] == dis[0]) continue;
		ans1 += dis[i];
	}
	printf("%lld\n", ans1);
	for (int i = 1; i <= ecnt; ++i) {
		if (edge[i].pos == -1) continue;
		printf("%d", edge[i].pos);
	}
	return 0;
}
```

---


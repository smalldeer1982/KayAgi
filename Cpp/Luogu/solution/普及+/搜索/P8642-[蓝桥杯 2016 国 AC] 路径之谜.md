# [蓝桥杯 2016 国 AC] 路径之谜

## 题目描述

小明冒充 $X$ 星球的骑士，进入了一个奇怪的城堡。

城堡里边什么都没有，只有方形石头铺成的地面。

假设城堡地面是 $n\times n$ 个方格。如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/ku6hk346.png)

按习俗，骑士要从西北角走到东南角。

可以横向或纵向移动，但不能斜着走，也不能跳跃。

每走到一个新方格，就要向正北方和正西方各射一箭。

（城堡的西墙和北墙内各有 $n$ 个靶子）

同一个方格只允许经过一次。但不必做完所有的方格。

如果只给出靶子上箭的数目，你能推断出骑士的行走路线吗？

有时是可以的，比如如图中的例子。

本题的要求就是已知箭靶数字，求骑士的行走路径（测试数据保证路径唯一）

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2016 年第七届国赛

## 样例 #1

### 输入

```
4
2 4 3 4
4 3 3 3```

### 输出

```
0 4 5 1 2 3 7 11 10 9 13 14 15```

# 题解

## 作者：___w (赞：9)

### [P8642 [蓝桥杯 2016 国 AC] 路径之谜](https://www.luogu.com.cn/problem/P8642)
#### 题意简述
- 告诉你每行每列的格子的经过次数，找一条路径，使得路径符合题意。
- $0<N<20$。

#### 题目分析
注意到 $N$ 的范围很小，我们可以考虑搜索。从点 $(1,1)$ 开始，再考虑上下左右四个点是否超出范围且没有重复走过，并记录路径，直至到达点 $(n,n)$ 并判断该路径时否符合题目条件即可。

代码中还用到了一个小技巧，像类似正序输出路径这类的问题，我们可以用一个前驱数组记录这个点是从何而来，找到可行解后我们只需递归并在回溯的时候输出即可，详细见代码。
#### 代码
这题有个坑点，就是代码部分中的数组 $a$ 和 $b$ 会混淆，当时调了好久。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 20;
int n, a[N], b[N], pre[N*N], d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};//方向数组 
bool vis[N][N];
int p(int x, int y) {//计算点(x,y)的对应的编号 
	return (x-1)*n+y-1;
}
bool check() {//判断是否符合题意 
	for (int i = 1; i <= n; ++i) if (a[i] || b[i]) return 0;//只要有一个点漏了，就不行 
	return 1;
}
void print(int x) {//输出路径 
	if (pre[x] == -1) return;//边界，防止无限递归 
	print(pre[x]);
	cout << x << ' ';//回溯时输出，这样路径就是正着的了 
}
void dfs(int x, int y) {//搜索 
	if (x == n && y == n) {//边界 
		if (check()) {
			cout << 0 << ' ';
			print(n*n-1);
			exit(0);
		}
		return;
	}
	for (int i = 0; i < 4; ++i) {
		int xx = x+d[i][0], yy = y+d[i][1];
		if (xx < 1 || xx > n || yy < 1 || yy > n) continue;//越界 
		if (a[yy] >= 1 && b[xx] >= 1 && !vis[xx][yy]) {//可行性剪枝加避免重复 
			--a[yy], --b[xx];
			vis[xx][yy] = 1;
			pre[p(xx, yy)] = p(x, y);//记录前驱 
			dfs(xx, yy);
			vis[xx][yy] = 0;//回溯 
			++a[yy], ++b[xx];
		}
	}
}
int main(){
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	for (int i = 1; i <= n; ++i) cin >> b[i];
	--a[1], --b[1], vis[1][1] = 1, pre[0] = -1;//初始化 
	dfs(1, 1);
	return 0;
}
```

---

## 作者：qwerty12346 (赞：6)

# [题目传送门](https://www.luogu.com.cn/problem/P8642)

## 问题：

求骑士从西北角走到东南角的路径。并且每走到一个新方格，就要向正北方和正西方各射一箭。

## 判断：

只要有靶子没射箭，就得回溯。(这就是 dfs 的判断条件)

## 思路：

直接暴搜。dfs 从西北角搜起，每次判断靶子有没有箭，若没有就回溯，若有就往下搜，搜道东南角为止。

### 代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,ret,a[105],b[105],c[105],d[105],k[1005];
bool vis[105][105];//标记数组
int dx[]={1,-1,0,0},dy[]={0,0,1,-1};//方向数组
void dfs(int x,int y,int key){//开始dfs
    k[key-1]=(y-1)*n+x-1;
    if(key==ret+1)
    {
        if(x!=n||y!=n)return ;
        for(int i=1;i<=ret;i++)cout<<k[i]<<" ";
        return ;
    }
    if(x==n&&y==n)return ;
    for(int i=0;i<4;i++)
	 {
        int fx=x+dx[i],fy=y+dy[i];
        if(fx<1||fy<1||fx>n||fy>n||vis[fx][fy])continue;
        if(c[fx]>=a[fx]||d[fy]>=b[fy])continue;
        c[fx]++,d[fy]++;
        vis[fx][fy]=1;//标记
        dfs(fx,fy,key+1);//往下走一步
        c[fx]--,d[fy]--;//回溯
        vis[fx][fy]=0;
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        ret+=a[i];
    }
    for(int i=1;i<=n;i++)cin>>b[i];
    c[1]++,d[1]++;
    vis[1][1]=1;//标记西北角的那个格子
    dfs(1,1,2);
    return 0；
}
```

---

## 作者：ZnHF (赞：5)

先看数据范围 $n<20$，时间限制 $1$ 秒，考虑暴搜。

从 $(1,1)$ 开始，考虑下一步应该向它射箭的那两个靶子还能不能射箭，如果可以，进入下一层递归，否则回溯，具体看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
int n,a[20],b[20],max_a[20],max_b[20],m[20][20];
bool vis[20][20],f;
vector<int> ans1,ans2;
bool check(){//判断是否满足题意
	for(int i=1;i<=n;i++){
		if(a[i]!=max_a[i] || b[i]!=max_b[i]) return 0;
	}
	return 1;
}
void dfs(int x,int y){
	if(f) return;//如果已经找到答案则返回
	if(x==n && y==n && check()){
		for(int i=0;i<ans1.size();i++){
			cout<<m[ans1[i]][ans2[i]]<<" ";
		}
		f=1;
		return;
	}
	for(int i=0;i<4;i++){
		int nx=x+dx[i],ny=y+dy[i];
		if(nx<1 || nx>n || ny<1 || ny>n || a[ny]>=max_a[ny] || b[nx]>=max_b[nx] || vis[nx][ny]) continue;
     //若满足条件则进入下一层递归
		a[ny]++;
		b[nx]++;
		vis[nx][ny]=1;
		ans1.push_back(nx);
		ans2.push_back(ny);
		dfs(nx,ny);
     //回溯
		a[ny]--;
		b[nx]--;
		vis[nx][ny]=0;
		ans1.pop_back();
		ans2.pop_back();
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>max_a[i];
	for(int i=1;i<=n;i++) cin>>max_b[i];
	int t=0;
	for(int i=1;i<=n;i++){//预处理每个格子的编号
		for(int j=1;j<=n;j++){
			m[i][j]=t++;
		}
	}
	vis[1][1]=1;//记得标记起点
	a[1]++;
	b[1]++;
	ans1.push_back(0);
	ans2.push_back(0);
	dfs(1,1);
	return 0;
}
```


---

## 作者：WA_sir (赞：3)

## [题目链接](https://www.luogu.com.cn/problem/P8642)

### 算法：搜索

为数不多的水绿。

因为数据较小（$N\lt20$），可以采用搜索 $+$ 回溯来做这道题。

### 1.搜索

正常的搜索回溯，只是每走一步要射箭。可以用两个数组存剩下没射的箭数，每射一箭就减 $1$。

### 2.判断

只要有靶子没射够箭，就得重新走。

### 3.输出

可以先将代表每个格子的数求出来，再实时记录路径，最后依次输出。

## 参考代码：

```cpp
#include<bits/stdc++.h>
#define e 22
#define o for(int i=1;i<=n;i++)
using namespace std;
int n,x[e],y[e],a[e][e],u,ans[10005],an,fx[4][2]={{0,1},{1,0},{-1,0},{0,-1}};
bool f[e][e];
bool pd()
{
	o if(x[i]||y[i])return false;
	return true;
}
void print()
{
	for(int i=0;i<=an;i++)printf("%d ",ans[i]);
	exit(0);
}
void dfs(int xx,int yy)
{
	if(xx==n&&yy==n)
	{
		if(pd())print();
		return;
	}
	for(int i=0;i<4;i++)
	{
		int xxx=xx+fx[i][0],yyy=yy+fx[i][1];
		if(xxx&&yyy&&xxx<=n&&yyy<=n&&!f[xxx][yyy]&&x[xxx]&&y[yyy])
		{
			x[xxx]--;y[yyy]--;f[xxx][yyy]=true;ans[++an]=a[xxx][yyy];
			dfs(xxx,yyy);
			x[xxx]++;y[yyy]++;f[xxx][yyy]=false;an--;
		}
	}
}
int main()
{
	scanf("%d",&n);
	o scanf("%d",y+i);
	o scanf("%d",x+i);
	o for(int j=1;j<=n;j++)a[i][j]=u++;
	x[1]--;y[1]--;f[1][1]=true;
	dfs(1,1);
	return 0;
}
```
感谢阅读！

~~码风挺好看的~~

---

## 作者：_Wind_Leaves_ShaDow_ (赞：2)

### 大致思路

数据范围明摆着深搜。~~我绝对不会告诉你我没有回溯找了半个小时锅 QAQ~~

第一次输入的靶子对应的是纵坐标，不要搞反了。

判断答案只要看靶子有没有打空就好了。

### 剪枝

但是不加优化这样做会超时，所以考虑一个剪枝。如果任意靶子比要求数目更高，剪掉。

### AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,a[25],b[25],ans[405],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},len=0;
bool vis[25][25];

inline void dfs(int x,int y){
	if(x<1||x>n||y<1||y>n||vis[x][y])return;//边界1
	for(int i=1;i<=n;i++)if(a[i]<0||b[i]<0)return;//边界2+剪枝，不加TLE
	vis[x][y]=true;
	a[y]--;
	b[x]--;
	ans[++len]=(x-1)*n+y-1;//这里的值可以直接算出来的，没必要预处理
	if(x==n&&y==n){
		for(int i=1;i<=n;i++){
			if(a[i]!=0||b[i]!=0)break;
			if(i==n)for(int i=1;i<=len;i++)cout<<ans[i]<<' ';//输出答案
		}//判断是否正解
	}else for(int i=0;i<4;i++)dfs(x+dx[i],y+dy[i]);//四个方向搜
	a[y]++;
	b[x]++;
	vis[x][y]=false;
	len--;//回溯
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);//读入输出优，加了好习惯（？）
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	dfs(1,1);
	return 0;
//}共建和谐洛谷，从你我他做起 
```

---

## 作者：Chis725 (赞：1)

### 题目意思：

骑士从左上角走到左下角。告诉了你每行每列走过的格子的数量，求他的路径。

### 思路：

数据不大，所以我们考虑暴搜。我们从左上角开始搜索，每次将它行上的格子的值和它列上的格子的值加 $1$，并且判断它行上的格子的值和它列上的格子的值是否超过他给的数据。然后要记得标记原有的点。回溯时也要注意将那两个值减 $1$ 和把标记消除。

### 代码献上：
```cpp
#include<bits/stdc++.h>
using namespace std;
int xx[]={1,-1,0,0};//方向数组
int yy[]={0,0,1,-1};
int sx[21],sy[21],ax[21],ay[21];//sx,sy是原有的数据，ax,ay是目前它行上的格子的值和它列上的格子的值
int vis[21][21],n,ans[405],sum=0;//vis用来标记，ans记录答案
void dfs(int x,int y,int step){
    ans[step-1]=(y-1)*n+x-1;//记录答案
    if(step==sum+1){
        if(x!=n||y!=n)return ;
        for(int i=1;i<=sum;i++){
            cout<<ans[i]<<" ";
        }
        exit(0);
    }
    if(x==n&&y==n)return ;
    for(int i=0;i<4;i++){
        int nx=x+xx[i],ny=y+yy[i];
        if(nx<1||ny<1||nx>n||ny>n||vis[nx][ny])continue;//是否越界或有标记
        if(ax[nx]>=sx[nx]||ay[ny]>=sy[ny])continue;//是否超过格子的值
        ax[nx]++;//它行上的格子的值和它列上的格子的值加1
        ay[ny]++;
        vis[nx][ny]=1;//标记
        dfs(nx,ny,step+1);//走到下一个格子
        ax[nx]--;//回溯
        ay[ny]--;
        vis[nx][ny]=0;
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>sx[i];
        sum+=sx[i];//总共走过了sum个格子
    }
    for(int i=1;i<=n;i++)cin>>sy[i];
    ax[1]++;//起点的行和列
    ay[1]++;
    vis[1][1]=1;//标记起点
    dfs(1,1,2);
	return 0;
}
```
完结撒花。

---

## 作者：I_will_AKIOI (赞：1)

数据范围 $N<20$，又要存储方案，可以使用深搜直接过。

建立两个数组 $a$ 和 $b$，分别存储两个方向的箭，然后就可以愉快地 DFS。当然，别忘了起点也是需要射箭的，所以两个方向的箭都得先减 $1$。最后要来个判断，看看箭有没有全部射完。然后你就会发现你 TLE 了。

所以我们要去掉一些不必要的搜索：当某个方向的箭已经射完了，就不用搜，直接跳过即可。给出优化后的 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,ans[100],a[30],b[30];
int fx[5]={0,-1,0,1,0},fy[5]={0,0,1,0,-1};
bool vis[30][30];
bool check()//检查每个靶子是否射了箭 
{
  for(int i=1;i<=n;i++) if(a[i]||b[i]) return 0;
  return 1; 
}
void DFS(int x,int y)
{
  if(x==n&&y==n) 
  {
    if(check())
    {
      for(int i=0;i<=s;i++) cout<<ans[i]<<" ";
      exit(0);//直接结束所有DFS函数 
    }
    else return;
  }
  int nx,ny;
  for(int i=1;i<=4;i++)
  {
    nx=x+fx[i],ny=y+fy[i];
    if(nx<1||nx>n||ny<1||ny>n||vis[nx][ny]||!a[ny]||!b[nx]) continue;//不满足要求的不搜 
    vis[nx][ny]=1;
    a[ny]--;//注意顺序 
    b[nx]--;
    ans[++s]=(nx-1)*n+ny-1;//算出格子的编号 
    DFS(nx,ny);
    vis[nx][ny]=0;
    a[ny]++;
    b[nx]++;
    ans[s--]=0;
  }
  return;
}
int main()
{
  cin>>n;
  for(int i=1;i<=n;i++) cin>>a[i];
  for(int i=1;i<=n;i++) cin>>b[i];
  vis[1][1]=1;//初始化，因为(1,1)为起点 
  a[1]--;
  b[1]--;
  DFS(1,1);
  return 0;
}
```

---

## 作者：haozinojc (赞：1)

这道题就是一道简单的**搜索**题。

### 思路：

一开始想着深搜不行，没想到 $0<n<20$，那就用深搜加广搜吧。

我们用数组来维护目前每个靶被打了几次，如果超过了我们输入的那就回溯。

当我们搜到终点后，判断是否每个靶被打次数是否和我们输入的完全一样，如果一样，那就输出，反之回溯。

### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[25],b[25],dx[4]={1,0,0,-1},dy[4]={0,1,-1,0},r[500005],cnt;
bool vis[25][25];
bool check(){
	for(int i=1;i<=n;i++)
		if(a[i]||b[i])return 0;
	return 1;
}
bool dfs(int x,int y){
	vis[x][y]=1;
	r[++cnt]=(x-1)*n+(y-1);
	a[y]--;
	b[x]--;
	if(x==n&&y==n&&check()){
		for(int i=1;i<=cnt;i++)cout<<r[i]<<" ";
		return 1;
	}
	for(int i=0;i<4;i++){
		int nx=x+dx[i],ny=y+dy[i];
		if(a[ny]&&b[nx]&&dfs(nx,ny)&&(!vis[nx][ny]))return 1;
	}
	a[y]++;
	b[x]++;
	r[cnt--]=0;
	vis[x][y]=0;
	return 0;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	dfs(1,1);
	return 0;
}
```


---

## 作者：Smg18 (赞：1)

不愧是暴力杯。

拿到题先看时间限制和样例，二十以内的数据在一秒内完成，所以暴搜时间够。

我们只用在多加点记录这个靶子是否有打过的数组，如果超了就返回。

注意，如果到了终点还得特判是否所有靶子打过了，如果没打过我们要回去重打，所以代码如下。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,a[25],b[25],dx[4]={1,0,0,-1},dy[4]={0,1,-1,0},road[500005],cnt;
bool vis[25][25];
int backk(int x,int y){
	return (x-1)*n+(y-1);
}
bool check(){
	for(int i=1;i<=n;i++)
		if(a[i]||b[i])
			return 0;//特判 
	return 1;
}
bool dfs(int x,int y){
	vis[x][y]=1;
	road[++cnt]=backk(x,y);
	a[y]--,b[x]--;
	if(x==n&&y==n&&check()){//结束
		for(int i=1;i<=cnt;i++)
			printf("%d ",road[i]);
		return 1;
	}
	for(int i=0;i<4;i++){//四个方向
		int nx=x+dx[i],ny=y+dy[i];
		if(a[ny]&&b[nx]&&(!vis[nx][ny])&&dfs(nx,ny))
			return 1;
	}
	a[y]++,b[x]++;//回溯要撤回
	road[cnt--]=0;
	vis[x][y]=0;
	return 0;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	dfs(1,1);//搜 
	
	return 0;
}
```


---

## 作者：ztntonny (赞：1)

# 思路

暴力深搜即可，注意可行性剪枝。

# 实现

没啥的，写一个标准深搜，过程中用两个数组记录已经射击过的靶子和已经走过的位置，再走到终点后将两个数组跟已知的比较，一样就结束输出，否则回溯。注意在遇到一个靶位已经被射击次数大于应有次数以后，就应该直接结束并回溯。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n , m , a[25] , b[25] , mark[25][25] , fa[25] , fb[25] , q[405] , cmp;

void dfs( ll x , ll y )
{
	if ( !x || !y || x > n || y > n )	return;
	q[++cmp] = ( x - 1 ) * n + y - 1 , mark[x][y] = 1 , fa[y]++ , fb[x]++;
	if ( x == n && y == n )
	{
		bool flag = true;
		for ( int i = 1; i <= n; i++ )	if ( fa[i] != a[i] || fb[i] != b[i] )	flag = false;
		if ( flag )
		{
			for ( int i = 1; i <= cmp; i++ )	cout << q[i] << " ";
			cout << endl;
			exit( 0 );
		}
	}
	if ( fa[y] <= a[y] && fb[x] <= b[x] )
	{
		if ( !mark[x + 1][y] )	dfs( x + 1 , y );
		if ( !mark[x - 1][y] )	dfs( x - 1 , y );
		if ( !mark[x][y + 1] )	dfs( x , y + 1 );
		if ( !mark[x][y - 1] )	dfs( x , y - 1 );
	}
	q[cmp--] = 0 , mark[x][y] = 0 , fa[y]-- , fb[x]--;
	return;
}

int main()
{
	cin >> n;
	for ( int i = 1; i <= n; i++ )	cin >> a[i];
	for ( int i = 1; i <= n; i++ )	cin >> b[i];
	dfs( 1 , 1 );
	return 0;
}
```


---

## 作者：lraM41 (赞：1)

简单搜索题。 ~~菜鸡独立完成的绿题。~~

思路：暴力搜索，每走一格进行标记（记得回溯），不需要什么剪枝。

详细解释请看代码。

码风奇怪，请各位原谅。

[无注释代码](https://www.luogu.com.cn/paste/gc8jo47l)

## Code:

```
#include<bits/stdc++.h>
using namespace std;
int j,s,n,i,a[25],b[25],dx[5]={-1,1,0,0},dy[5]={0,0,-1,1},c[25][25],a1[25],b1[25],ex[405],ey[405];
bool f[25][25];
namespace IO{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read(){
		reg char ch=gh();
		reg long long x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
}
using IO::read;//快读
void write(int x) {//快输
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
void dfs(int x,int y,int sum)
{
   int x1,y1,j,i,fl=0;
   if(a1[x]>b[x])return;//若射的箭数已经超出，结束搜索，下同。
   if(b1[y]>a[y])return;
   for(i=0;i<4;i++)//四个方向搜索。
   {
      x1=x+dx[i];
      y1=y+dy[i];
      if(x1>0&&x1<=n&&y1>0&&y1<=n&&!f[x1][y1]){//边界。
         f[x1][y1]=1;//标记。
         a1[x1]++;
         b1[y1]++;
         ex[sum]=x1,ey[sum]=y1;//路径记录。 
         if(x1==n&&y1==n){
            for(j=1;j<=n;j++)
               if((a1[j]!=b[j])||b1[j]!=a[j])fl=1;//判断条件。
            if(!fl){
               for(j=1;j<=sum;j++)cout<<c[ex[j]][ey[j]]<<' ';//输出。
               return;
            }
         }
         else dfs(x1,y1,sum+1);//搜索。
         a1[x1]--;//回溯。
         b1[y1]--;
         f[x1][y1]=0;
      }
   }
}
int main()
{
   n=read();
   for(i=1;i<=n;i++)a[i]=read();
   for(i=1;i<=n;i++)b[i]=read();//输入。
   for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)c[i][j]=s++;//预处理。
   f[1][1]=1;
   a1[1]=b1[1]=1;
   ex[1]=ey[1]=1;//赋初值。
   dfs(1,1,2);//第一个点即为 [1,1] ,于是从第二个开始搜。
   return 0;
}


---

## 作者：DreamLand_zcb (赞：1)

## 简要题意

有一个 $n\times n$ 的矩阵，要求从左上角走到右下角，每次可以横向或纵向移动，就要向正北方和正西方各射一箭。

现在给出走完后所有箭靶上的箭的个数，求走的路径。

## 思路

看到数据范围 $0 < N < 20$ 瞬间明白可以用 dfs。

暴力搜索每一个格子，判断当前这个格子的北方西方箭靶是否达到最终情况（可行性剪枝），不然会超时。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

int n;
int up[25];
int le[25];
int w[25][25];
int ans[500];
int la=0;
int dx[]={0, 0, 1, -1};
int dy[]={1, -1, 0, 0};
bool vis[25][25];
int step=0;

void dfs(int x, int y, int st)
{
	
	if(x == n && y == n)
	{
		if(st == step)
		{
			for(int i=1;i<=st;i++)
				cout << ans[i] << " ";
			exit(0);
		}
		else	return ;
	}
	for(int i=0;i<4;i++)
	{
		int X=x+dx[i], Y=y+dy[i];
		if(X >= 1 && X <= n && Y >= 1 && Y <= n && !vis[X][Y] && up[X] && le[Y])
		{
			vis[X][Y]=1;up[X]--;le[Y]--;ans[st+1]=w[X][Y]/*(X-1)*n+Y*/;
			dfs(X, Y, st+1);
			vis[X][Y]=0;up[X]++;le[Y]++;
		}
		
	}
}
int main()
{
	cin >> n;
	for(int i=1;i<=n;i++)	cin >> le[i], step+=le[i];
	for(int i=1;i<=n;i++)	cin >> up[i], step+=up[i];
	step/=2;
	int s=0;
	le[1]--, up[1]--;
	vis[1][1]=1;
	ans[1]=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			w[i][j] = s++;
	dfs(1, 1, 1);
	return 0;
}

```

**注意输入的时候不要把北方和西方的箭靶搞反了**

别问我是怎么知道的

---

## 作者：technopolis_2085 (赞：1)

分析：

$n$ 小于 $20$，所以可以考虑暴力搜索。

每一次走到一个格子时，将该格子所在的行和列的数字加 $1$。

然后每次记得回溯。

这样做很明显会超时，考虑优化。


剪枝：如果当前的数字大于题目给出的箭靶数字，则不能走。

然后标记走过的路径，倒序输出即可。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=25;
int row[maxn],col[maxn];
int path[maxn*maxn];
bool flag[maxn][maxn];

int a[maxn],b[maxn];
int n;

int get(int x,int y){
	return x*n+y;
}

void print(int u){
	if (u==0){
		printf("0 ");
		return;
	}
	
	print(path[u]);
	printf("%d ",u);
}
void dfs(int x,int y){
	if (x==n-1&&y==n-1){
		int flag=0;
		for (int i=0;i<n;i++){
			if (a[i]!=row[i]||b[i]!=col[i]){
				flag=1; break;
			}
		}
		
		if (flag==0){
			print(get(x,y));
			exit(0); 
		}
		return;
	}
	
	if (x-1>=0&&a[x-1]<row[x-1]&&b[y]<col[y]&&flag[x-1][y]==0){
		path[get(x-1,y)]=get(x,y);
		flag[x-1][y]=1;
		a[x-1]++;
		b[y]++;
		dfs(x-1,y);
		path[get(x-1,y)]=0;
		flag[x-1][y]=0;
		b[y]--;
		a[x-1]--;
	}
	
	if (x+1<n&&a[x+1]<row[x+1]&&b[y]<col[y]&&flag[x+1][y]==0){
		path[get(x+1,y)]=get(x,y);
		flag[x+1][y]=1;
		a[x+1]++;
		b[y]++;
		dfs(x+1,y);
		path[get(x+1,y)]=0;
		flag[x+1][y]=0;
		a[x+1]--;
		b[y]--;
	}
	
	if (y-1>=0&&b[y-1]<col[y-1]&&a[x]<row[x]&&flag[x][y-1]==0){
		path[get(x,y-1)]=get(x,y);
		flag[x][y-1]=1;
		b[y-1]++;
		a[x]++;
		dfs(x,y-1);
		path[get(x,y-1)]=0;
		flag[x][y-1]=0;
		b[y-1]--;
		a[x]--;
	}
	
	if (y+1<n&&b[y+1]<col[y+1]&&a[x]<row[x]&&flag[x][y+1]==0){
		path[get(x,y+1)]=get(x,y);
		flag[x][y+1]=1;
		b[y+1]++;
		a[x]++;
		dfs(x,y+1);
		path[get(x,y+1)]=0;
		flag[x][y+1]=0;
		b[y+1]--;
		a[x]--;
	}
}

int main(){
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&col[i]);
	for (int i=0;i<n;i++) scanf("%d",&row[i]);
	
	flag[0][0]=1;
	a[0]=b[0]=1;
	dfs(0,0);
	return 0;
} 
```


---

## 作者：_JF_ (赞：1)

[P8642](https://www.luogu.com.cn/problem/P8642)

独立完成。

搜索。

从 $y$ 方向射向 $x$ 轴记为 $liney$，表示这一列应该射多少次。

从 $x$ 射向 $y$ 轴同理。

主要是这个顺序把一开始绕晕了。

所以先输入的其实是 $y$ 射向 $x$ 轴，也就是 $liney$，然后才是 $linex$。

然后要加一个剪枝，如果当前的答案已经超出了限制，就可以不用继续搜下去了。这样可以大大提高效率。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =3000;
struct node{
	int x,y;
}ans[N][N];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int vis[N][N];
int linex[N],liney[N],lastx[N],lasty[N],n;
bool check(int x,int y){
	return (x>=1&&x<=n&&y>=1&&y<=n&&vis[x][y]==0);
}
bool checkans(){
	for(int i=1;i<=n;i++)	if(lastx[i]!=linex[i])	return false;
	for(int i=1;i<=n;i++)	if(lasty[i]!=liney[i])	return false;
	return true;
}
void Print(int x,int y){
	if(x==1&&y==1){
		cout<<0<<" ";
	}
	else{
		Print(ans[x][y].x,ans[x][y].y);
		cout<<(x-1)*n+y-1<<" ";
	}
}
void dfs(int x,int y){
	if(lastx[x]>linex[x])	return ;
	if(lasty[y]>liney[y])	return ;
	if(x==n&&y==n&&checkans()){
		Print(n,n);
		return ;
	}
	for(int i=0;i<=3;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if(!check(xx,yy))	continue;
		lasty[yy]++,lastx[xx]++;
		ans[xx][yy].x=x,ans[xx][yy].y=y;
		vis[xx][yy]=1;
		dfs(xx,yy);
		lasty[yy]--,lastx[xx]--;
		vis[xx][yy]=0;
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)	cin>>liney[i];
	for(int i=1;i<=n;i++)	cin>>linex[i];
	lastx[1]=1,lasty[1]=1,vis[1][1]=1;
	dfs(1,1);
	cout<<endl;
	return 0;
}
```


---

## 作者：5k_sync_closer (赞：0)

数据范围很小，考虑爆搜。

搜到位置 $(x,y)$ 时统计 $(x,y)$ 的贡献，即 $x$ 行与 $y$ 列的箭靶箭数减一。

容易发现，若此时 $x$ 行或 $y$ 列的箭靶箭数为 $0$，则不能走到 $x,y$，不需要往下搜。（可行性剪枝）

搜索时记录 $z_i$ 表示第 $i$ 步的位置，搜到终点后输出 $z$ 即可。

```cpp
#include <cstdio>
#include <cstdlib>
int n, o, p[20], q[20], z[450], f[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
bool v[20][20];
void D(int x, int y, int d)
{
    if (x < 0 || x >= n || y < 0 || y >= n || v[x][y] || !p[x] || !q[y])
        return;
    v[x][y] = 1;
    --p[x];
    --q[y];
    z[d] = x * n + y;
    if (x == n - 1 && y == n - 1)
    {
        if (d == o)
        {
            for (int i = 1; i <= d; ++i)
                printf("%d ", z[i]);
            exit(0);
        }
    }
    else
        for (int i = 0, a, b; i < 4; ++i)
            D(x + f[i][0], y + f[i][1], d + 1);
    v[x][y] = 0;
    ++p[x];
    ++q[y];
}
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
        scanf("%d", q + i), o += q[i];
    for (int i = 0; i < n; ++i)
        scanf("%d", p + i);
    D(0, 0, 1);
}
```


---


# [蓝桥杯 2017 国 A] 填字母游戏

## 题目描述

小明经常玩 LOL 游戏上瘾，一次他想挑战 K 大师，不料 K 大师说：

“我们先来玩个空格填字母的游戏，要是你不能赢我，就再别玩 LOL 了”。

K 大师在纸上画了一行 $n$ 个格子，要小明和他交替往其中填入字母。

并且：

1. 轮到某人填的时候，只能在某个空格中填入 `L` 或 `O`。

2. 谁先让字母组成了 `LOL` 的字样，谁获胜。

3. 如果所有格子都填满了，仍无法组成 `LOL`，则平局。

小明试验了几次都输了，他很惭愧，希望你能用计算机帮他解开这个谜。

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2017 年第八届国赛

## 样例 #1

### 输入

```
4
***
L**L
L**L***L
L*****L```

### 输出

```
0
-1
1
1```

# 题解

## 作者：Nightsky_Stars (赞：16)

# 思路

#### 递归 + 记忆化搜索，记忆化用 map 。

我们既然是和小明一伙的，所以肯定很希望小明~~输~~，所以能胜就胜，不能就平，否则才败。

每次就判断一下小明是否胜利及是否有未填的空位，再循环遍历一下，如果该位置为空位，就尝试将 L 和 O 填入空位，看看能不能赢。

# CODE:
```
#include<bits/stdc++.h>
using namespace std;
map<string,int> m;
string s;
int check(){
	if(m.count(s)) return m[s];
	if(s.find("LOL")!=-1) return -1;
	if(s.find('*')==-1) return 0;
	bool res=false;
	for(int i=0;s[i];i++){
		if(s[i]=='*'){
            s[i]='L';
            int ans=check();
            s[i]='*';
            if(ans==-1) return m[s]=1;
            else if(ans==0) res=true;
            s[i]='O';
            ans=check();
            s[i]='*';
            if(ans==-1) return m[s]=1;
            else if(ans==0) res=true;
   		}
	}
	if(res) return m[s]=0;
    return m[s]=-1;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		if(s.length()<3){
			cout<<"0"<<endl;
			continue;
		}
		cout<<check()<<endl;
	}
	return 0;
}
```




---

## 作者：Mu_shao (赞：15)

这题的思路很简单。

1. 首先，看字符串的长度是否大于等于 $3$，如果小于 $3$，直接输出为平局，没有足够的长度比啥啊？
2. 判断有没有三种特殊情况，只填一个就能胜的。如果有的话可以直接判为小明胜。
3. 如果没有空位，直接判为平。
4. 模拟，遍历每一个空位的每一种情况。

直接上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
char ch[] = {'L', 'O'}; //两种情况

int n;
string s;
map<string, int> mp;

int win(string str){
	if (mp.find(str) != mp.end()) return mp[str]; //map记忆化，有重复的直接出结果
	if (str.size() < 3){
		mp[str] = 0;
		return 0;
	}
	if (str.find("LO*") != -1 || str.find("L*L") != -1 || str.find("*OL") != -1){ //能赢直接赢
		mp[str] = 1;
		return 1;
	}
	if (str.find('*') == -1){ //没有空位直接平局
		mp[str] = 0;
		return 0;
	}
	
	bool f = false; //判断平局，能平局就平局
	int t; //记录填完后对手的输赢
	for (int i = 0; i < str.size(); i++){ //遍历，是空位就填，两种情况
		if (str[i] == '*'){  
			for (int j = 0; j < 2; j++){  
				str[i] = ch[j];
				if (str.find("LO*") != -1 && str.find("L*L") != -1 && str.find("*OL") != -1){  //如果填完对方能赢，不符合最佳结果，回溯重找
					str[i] = '*';
					continue;
				}
				
				t = win(str);
				str[i] = '*';
				if (t == -1){ //对方输就是自己赢
					mp[str] = 1;
					return 1;
				} else if (t == 1) continue; //对方赢，回溯重找
				else if (!t) f = true; //能平局就平局
			}
		}
	}
	
	if (f){  //能平局就平局
		mp[str] = 0;
		return 0;
	}
	mp[str] = -1;
	return -1;
}

int main(){
	scanf("%d", &n);
	while (n--){
		cin >> s;
		printf("%d\n", win(s));
	}
	return 0;
}
```


---

## 作者：Leaper_lyc (赞：5)

输？赢？平？好像是博弈论啊？

仔细看数据范围：长度 $len\le20$，这不是 ~~暴力~~ 搜索是什么？

先判断胜负。再遍历操作：如果该位置为空位，则尝试将 `L` 和 `O` 填入空位，看看能不能赢。

要知道，题目要求我们和小明一伙儿，所以我们肯定是希望小明能胜就胜，不能胜就平，否则才败。

要用记忆化搜索，否则 T 飞。

什么？不知道用什么记忆化？这里我用 map 记录每种情况的胜负结果（众所周知 map 可以起到映射效果，类似函数的定义域与值域的关系），具体操作见代码。

时间复杂度**约**为 $O(2^n)$。

什么？不知道复杂度怎么来的？好吧，对于每个位置我们都尝试填 `L` 或 `O` 这两种字符填入空位（两种等概，都要试），所以一个空有两种填法，共有 $n$ 个空，则共有 $2^n$ 种情况。我的估算只是大概的，整体偏小，不过这题主要是指数级别的，一些小操作就忽略不计吧。

代码是最好的题解：
```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <map>
using namespace std;
map <string, int> mp;
string str;
int race() {
    if (mp.count(str)) return mp[str];
    if (str.find("LOL") != -1) return -1; // 如果前一步有人填好了，那就输了
    if (str.find("*") == -1) return 0; // 如果没得填了，那就平了
    bool flag = false;
    for (int i = 0; i < str.size(); i++) { // 遍历记得从0开始
        if (str[i] == '*'){ // 可以填
            str[i] = 'L'; // 填 L 的情况
            int ans = race(); // 搜索
            str[i] = '*';
            if (ans == -1) return mp[str] = 1;
            else if (ans == 0) flag = true;
            str[i] = 'O'; // 填 O 的情况
            ans = race(); // 继续搜
            str[i] = '*';
            if (ans == -1) return mp[str] = 1; // 胜了
            else if (ans == 0) flag = true; // 平了
        }
    }
    if (flag) return mp[str] = 0; // 平局
    return mp[str] = -1; // 败了
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;
    while (t--) {
        cin >> str;
        if (str.size() < 3) { // 这么小填个锤子！
        	puts("0");
        	continue;
        }
        cout << race() << '\n'; // 建议用 '\n'，个人认为 endl 不好用
    }
}
```

注：不开 O2 优化会炸。

---

## 作者：rainygame (赞：5)

第一眼以为是博弈之类的，第二眼看到 $n < 20$ 的时候才知道是搜索。

本题的主要思路就是通过搜索把空给填上，然后判断即可。~~（其实我觉得难点在判断）~~

首先，遇到 `L*L`，`*OL`，`LO*` 的时候，就直接给它判先手胜就行了。

然后，遇到没有 `*` 且没有 `LOL` 的时候，就是平局。

最后，在递归的时候发现自己的下一步就是胜的话，那么就是败。

注意，如果可以胜就胜，可以平就平，最后实在不行了才败。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const char ch[] = {'L', 'O'};

int n;
map<string, int> vis;

int judge(string str){
	if (vis.find(str) != vis.end()) return vis[str];  // 记忆化 
	if (str.size() < 3){  // 这么小我填什么呀？ 
		vis[str] = 0;
		return 0;
	}
	if (str.find("LO*") != -1 || str.find("L*L") != -1 || str.find("*OL") != -1){  // 胜利！ 
		vis[str] = 1;
		return 1;
	}
	if (str.find('*') == -1 && str.find("LOL") == -1){  // 平局 
		vis[str] = 0;
		return 0;
	}
	
	bool pj = false;  // 判断是否可以平局
	int tmp; 
	for (auto &i: str){  // 枚举 
		if (i == '*'){  // 是空位 
			for (int j=0; j<2; j++){  // 枚举填上的东西 
				i = ch[j];
				if (str.find("LO*") != -1 && str.find("L*L") != -1 && str.find("*OL") != -1){  // 必败无疑 
					i = '*';
					continue;
				}
				
				tmp = judge(str);
				i = '*';
				if (tmp == -1){  // 对方败就是自己胜 
					vis[str] = 1;
					return 1;
				}
				if (tmp == 1) continue;  // 回去 
				else if (!tmp) pj = true;  // 可以平就平 
			}
		}
	}
	
	if (pj){  // 可以平就平 
		vis[str] = 0;
		return 0;
	}
	vis[str] = -1;  // 败 
	return -1;
}

string str;

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n;
	while (n--){
		cin >> str;
		cout << judge(str) << '\n';
	}
	
	return 0;
}

```


---

## 作者：封禁用户 (赞：2)

## 思路
本题就是利用 dfs 将每一个空给填上，只要看到 LOL 就说明输了，如果没有一个空是星号且没有出现 LOL 就算平局。当然，我们的小明肯定不想输，所以应该取每一种可能的最大值。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n/*n项数据*/,cnt/*星号数量*/;
string s;
unordered_map<string,int>vis;
int dfs(int x){
    if(vis.find(s)!=vis.end())return vis[s];//如果搜过，直接返回
    for(int i=0;i+2<s.length();i++)if(s[i]=='L'&&s[i+1]=='O'&&s[i+2]=='L')return vis[s]=-1;//如果已经有LOL，说明后手输了
    if(x>cnt)return vis[s]=0;//如果没有星号且没有LOL，平局
    string tmp=s;
    int ans=-1;//用个变量存着，不用总是改vis数组的值
    for(int i=0;i<s.length();i++){
        if(s[i]=='*'){
            s[i]='L';//填空
            ans=max(ans,-dfs(x+1));//记录
            s[i]='*';//还原
            if(ans==1)break;//如果能赢，就退出
            s[i]='O';//同上
            ans=max(ans,-dfs(x+1));//同上
            s[i]='*';//同上
            if(ans==1)break;//同上
        }
    }
    vis[tmp]=ans;//存到vis数组
    return vis[tmp];//返回
}
int main(){
    ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    cin>>n;
    while(n--){
        vis.clear();//初始化vis数组
        cnt=0;//初始化cnt
        cin>>s;
        if(s.length()<3){
            cout<<0<<'\n';
            continue;
        }//特判
        for(int i=0;i<s.length();i++)if(s[i]=='*')cnt++;//计算*的数量
        bool f=0;
        for(int i=0;i+2<s.length();i++){
            if(s[i]=='L'&&s[i+1]=='O'&&s[i+2]=='L'){
                cout<<1<<'\n';
                f=1;
                break;
            }
        }//还是特判
        if(f)continue;
        cout<<dfs(1)<<'\n';//直接输出
    }
}
```
这是本蒟蒻的第一篇 tijie，请大家多多支持！！！

---

## 作者：2023lpx (赞：0)

# P8658 [蓝桥杯 2017 国 A] 填字母游戏 题解

## 思路

首先我们要明确一点：

我们和小明是一伙的，所以除非小明一定会输，否则我们就判他平局或赢。

~~很明显~~，这题用~~暴搜~~。

直接暴力将 ```L``` 和 ```O``` 填入每个 ```*```，看看能否赢即可。

用 **map** 记忆化一下即可。

~~特判就不用我说了吧。~~

## code

```cpp
#include<cstdio>
#include<map>
#include<string>
#include<cstring>
#include<iostream>
using namespace std;
int t;
int n;
int const maxn=20;
string s;
map<string,int>use;
char ch[3]={'L','O'};
int dfs(string now){
	if(use.find(now)!=use.end()){//搜过了
		return use[now];
	}
	if(now.find("LO*")!=-1||now.find("L*L")!=-1||now.find("*OL")!=-1){//一步到位
		use[now]=1;
		return 1;	
	}
	if(now.find("*")==-1){//没空位
		use[now]=0;
		return 0;
	}
	bool found=0;
	int t;
	for(int i=0;i<now.size();i++){//暴力填入
		if(now[i]=='*'){
			for(int j=0;j<2;j++){
				now[i]=ch[j];
				if(now.find("LO*")!=-1&&now.find("L*L")!=-1&&now.find("*OL")!=-1){//判断走完这一步是否一定会输
					now[i]='*';
					continue;
				}
				t=dfs(now);
				now[i]='*';
				if(t==-1){
					use[now]=1;
					return 1;
				}
				else if(t==0){
					found=1;
				}
			}
		}
	}
	if(found==1){//平局
		use[now]=0;
		return 0;
	}
	use[now]=-1;
	return -1;
}
signed main(){
	scanf("%d",&t);
	while(t--){
		cin>>s;
		printf("%d\n",dfs(s));
	}
	return 0;
}
```

tips：要用 ```cin``` 读入，我因为 ```getchar``` 被卡了好久。

---

## 作者：dyc2022 (赞：0)

似乎是一道，记忆化搜索并不是非常板子的题？

这题虽然没有什么博弈论成分，可是我们还是要从博弈论的状态进行分析。

要让我们得到必胜态，就要让自己走了一步之后，对方的状态是否为必败态。

我们定义函数 `check(s)`，为字符串 $s$ 表示的状态的胜负情况。$1$ 表示必胜，$0$ 表示平局，$-1$ 表示必败。接下来我们进行讨论：

- 如果我们在字符串中发现 `LO*`、`L*L`、`*OL` 的子串，那么说明我们可以在填一个字符后胜利。因此直接返回 $1$。
- 如果没有上述子串，那么我们就对每一个 `*` 进行枚举，让对手达成最差状态就是我们的目的。因此我们就需要找到所有状态中对手最差的那一个，然后返回它的相反数。

但是复杂度十分地大。因此我们加上记忆化搜索，就可以轻松地……[TLE](https://www.luogu.com.cn/record/126823119)？

但是代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int len,n;
map<string,int> mem,flag;
int check(string s)
{
	if(flag[s])return mem[s];
	flag[s]=1;
	int starcnt=0;
	for(int i=0;i<len;i++)starcnt+=(s[i]=='*');
	bool lol=0,los=0,lsl=0,sol=0;
	for(int i=0;i<=len-3;i++)
	{
		if(s[i]=='L'&&s[i+1]=='O'&&s[i+2]=='L')lol=1;
		if(s[i]=='L'&&s[i+1]=='O'&&s[i+2]=='*')los=1;
		if(s[i]=='L'&&s[i+1]=='*'&&s[i+2]=='L')lsl=1;
		if(s[i]=='*'&&s[i+1]=='O'&&s[i+2]=='L')sol=1;
	}
	if(starcnt==0&&lol==0)return mem[s]=0;
	if(los||lsl||sol)return mem[s]=1;
	int maxn=-0x3f3f3f3f;
	for(int i=0;i<len;i++)
	{
		if(s[i]!='*')continue;
		string now=s;
		now[i]='L';
		maxn=max(maxn,-check(now));
		now[i]='O';
		maxn=max(maxn,-check(now));
	}
	return mem[s]=maxn;
}
main()
{
	flag.clear();
	cin>>n;
	while(n--)
	{
		string k;
		cin>>k;
		len=k.length();
		cout<<check(k)<<endl;
	}
	return 0;
}
```

我们考虑 `std::map` 的复杂度还很大，如果存一个字符串就会付出很大的常数。因此使用哈希表，把每一个状态变成一个三进制数，就可以 AC 了！

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int len,n;
map<int,int> mem,flag;
int ha(string x)
{
	int sum=0;
	for(int i=0;i<len;i++)
	{
		if(x[i]=='L')sum++;
		if(x[i]=='O')sum+=2;
		sum*=3;
	}
	return sum;
}
int check(string s)
{
	if(flag[ha(s)])return mem[ha(s)];
	flag[ha(s)]=1;
	int starcnt=0;
	for(int i=0;i<len;i++)starcnt+=(s[i]=='*');
	bool lol=0,los=0,lsl=0,sol=0;
	for(int i=0;i<=len-3;i++)
	{
		if(s[i]=='L'&&s[i+1]=='O'&&s[i+2]=='L')lol=1;
		if(s[i]=='L'&&s[i+1]=='O'&&s[i+2]=='*')los=1;
		if(s[i]=='L'&&s[i+1]=='*'&&s[i+2]=='L')lsl=1;
		if(s[i]=='*'&&s[i+1]=='O'&&s[i+2]=='L')sol=1;
	}
	if(starcnt==0&&lol==0)return mem[ha(s)]=0;
	if(los||lsl||sol)return mem[ha(s)]=1;
	int maxn=-0x3f3f3f3f;
	for(int i=0;i<len;i++)
	{
		if(s[i]!='*')continue;
		string now=s;
		now[i]='L';
		maxn=max(maxn,-check(now));
		now[i]='O';
		maxn=max(maxn,-check(now));
	}
	return mem[ha(s)]=maxn;
}
main()
{
	flag.clear();
	cin>>n;
	while(n--)
	{
		string k;
		cin>>k;
		len=k.length();
		cout<<check(k)<<endl;
	}
	return 0;
}
```

---

## 作者：fedoralxy (赞：0)

## 解题思路

首先，看到题目我们会想到以下两种思路：

- 深度优先搜索

- 用数学推出博弈论公式

而我们看数据范围，即可看出后者是不成立的。

然而，一般利用深度优先搜索解决博弈论问题，会考虑必胜状态何必败状态和平局状态 分析如下：

- 必胜状态：字符串中出现在填一个字母就可以到达胜局。也就是当前字符串含子串 ```L*L``` 或 ```*OL``` 或 ```LO*```。

- 必败状态：上一步是必胜状态。

- 平局状态：所有的空都填上了并且没有出现胜局。

实现方法：

- 在递归时，利用记忆化优化时间。

- 查找子串时使用库函数 ```s.find()```。

- 记忆化利用 ```map```。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<map>
#define ll long long
using namespace std;
class interface
{
	public:
		ll t;
		string s;
		map<string,int> mem;
		ll DFS(string s)
		{
			if(mem[s])
				return mem[s]-2;
			if(s.find("LOL")!=-1)
			{
				mem[s]=1;
				return -1;
			}
			else if(s.find("*OL")!=-1)
			{
				mem[s]=3;
				return 1;
			}
			else if(s.find("LO*")!=-1)
			{
				mem[s]=3;
				return 1;
			}
			else if(s.find("L*L")!=-1)
			{
				mem[s]=3;
				return 1;
			}
			else if(s.find("*")==-1)
			{
				mem[s]=2;
				return 0;
			}
			ll maxn=-2;
			for(int i=0;i<s.size();i++)
			{
				if(s[i]=='*')
				{
					s[i]='L';
					maxn=max(maxn,-DFS(s));
					if(maxn==1)
						return 1;
					s[i]='O';
					maxn=max(maxn,-DFS(s));
					if(maxn==1)
						return 1;
					s[i]='*';
				}
			}
			mem[s]=maxn+2;
			return maxn;
		}
	public:
		void asmain()
		{
			scanf("%lld",&t);
			while(t--)
			{
				cin>>s;
				cout<<DFS(s)<<endl;
			}
		}
}in;
int main(){return in.asmain(),0;}
```

---

## 作者：MujicaSaki (赞：0)

记忆化搜索。

如果直接写记忆化搜索的话，只能得 $60$ 分。

所以我们需要优化。

很容易就发现有 $3$ 种情况必赢。

所以很容易就写出此代码:

```cpp
	if(S.find("LO*")!=-1||S.find("*OL")!=-1||S.find("L*L")!=-1)
	{
		vis[S]=1;
		return 1;
	}
```

加上这个代码就可以过了。

还有一点细节，比如字符串长度小于 $3$ 还有字符串全都是星号，或者给的字符串已经有了获胜情况。这些都得判平局。



---

## 作者：fp0cy1tz6mn4rd_ (赞：0)

# 思路
本题需要使用递归 + 记忆化搜索，可以利用 map 实现记忆化搜索。

每次都要判断是否胜利以及是否有未填的空位，再循环遍历，如果该位置为空位，则尝试将 L 和 O 填入空位，看看能不能赢。

注意，能胜就胜，能平就平，否则才败。

# 代码
```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<map>
using namespace std;
map<string,int> mem;
string s;
int race(){
    if(mem.count(s)) return mem[s];
    if(s.find("LOL")!=-1) return -1;
    if(s.find("*")==-1) return 0;
    bool res=false;
    for(int i=0;s[i];i++)
        if(s[i]=='*'){
            s[i]='L';
            int ans=race();
            s[i]='*';
            if(ans==-1) return mem[s]=1;
            else if(ans==0) res=true;
            s[i]='O';
            ans=race();
            s[i]='*';
            if(ans==-1) return mem[s]=1;
            else if(ans==0) res=true;
        }
    if(res) return mem[s]=0;
    return mem[s]=-1;
}
int main(){
    int n;
    cin>>n;
    while(n--){
        cin>>s; 
        if(s.length()<3){
        	cout<<0<<endl;
        	continue;
        }
        cout<<race()<<endl;
    }
    return 0;
}
```

第一次发布题解，请大家多多支持。

---


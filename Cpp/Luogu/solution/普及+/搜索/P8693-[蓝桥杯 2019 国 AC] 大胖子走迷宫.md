# [蓝桥杯 2019 国 AC] 大胖子走迷宫

## 题目描述

小明是个大胖子，或者说是个大大胖子，如果说正常人占用 $1\times1$ 的面积，小明要占用 $5\times5$ 的面积。

由于小明太胖了，所以他行动起来很不方便。当玩一些游戏时，小明相比小伙伴就吃亏很多。小明的朋友们制定了一个计划，帮助小明减肥。计划的主要内容是带小明玩一些游戏，让小明在游戏中运动消耗脂肪。走迷宫是计划中的重要环节。

朋友们设计了一个迷宫，迷宫可以看成是一个由 $n\times n$ 个方阵组成的方阵，正常人每次占用方阵中 $1\times1$ 的区域，而小明要占用 $5\times5$ 的区域。小明的位置定义为小明最正中的一个方格。迷宫四周都有障碍物。为了方便小明，朋友们把迷宫的起点设置在了第 $3$ 行第 $3$ 列，终点设置在了第 $n-2$ 行第 $n-2$ 列。

小明在时刻 $0$ 出发，每单位时间可以向当前位置的上、下、左、右移动单位 $1$ 的距离，也可以停留在原地不动。小明走迷宫走得很辛苦，如果他在迷宫里面待的时间很长，则由于消耗了很多脂肪，他会在时刻 $k$ 变成一个胖子，只占用 $3\times3$ 的区域。如果待的时间更长，他会在时刻 $2\times k$ 变成一个正常人，只占用 $1\times1$ 的区域。注意，当小明变瘦时迷宫的起点和终点不变。

请问，小明最少多长时间能走到迷宫的终点。注意，小明走到终点时可能变瘦了也可能没有变瘦。

## 说明/提示

对于 $30 \%$ 的评测用例, $1 \leq n \leq 50$。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 100$。

对于所有评测用例, $1 \leq n \leq 300$，$1 \leq k \leq 1000$。

蓝桥杯 2019 年国赛 A 组 F 题（C 组 I 题）。

## 样例 #1

### 输入

```
9 5
+++++++++
+++++++++
+++++++++
+++++++++
+++++++++
***+*****
+++++++++
+++++++++
+++++++++
```

### 输出

```
16```

# 题解

## 作者：DreamLand_zcb (赞：18)

## 简要题意

占地 $5 \times 5$ 的小明从 $n \times n$ 的迷宫的 $(3, 3)$ 走到 $(n-2, n-2)$。并且当到达时刻 $k$ 的时候小明占地变成 $3 \times 3$，在时刻 $2 \times k$ 的时候占地变成 $1 \times 1$。小明每次可以选择向上下左右四个方向走动，每次走动用时 $1$ 个时刻，当然也可以选择站着不动。

求小明到达终点时的时刻。

## 思路

类似于求最短路径的问题，可以使用 bfs 讨论。

定义队列 $q$，含有四个元素：

- $x$ 和 $y$：当前小明坐标

- $Time$：当前时刻

- $size$：小明身材

每次取出队首并向四个方向以及不动拓展，并判断当前位置是否走过以及这个位置小明能否站的下（小明的占地区域内有没有障碍物），如果站的下就入队，入队时判断一下小明身材的情况。

判断的时候有个小优化，及当小明占地是 $1 \times 1$ 的时候可以不用判断小明原地不动的情况，此时站着不动是无意义的举措，因为无论怎样走都不会有障碍物遮挡他。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

int n, k;
int ans = 0x3f3f3f;
int a[305][305];
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};
bool vis[305][305];
struct node {
	int x, y;//坐标
	int Time;//时间
	int size;//小明大小 
};
bool check(int x, int y, int size)
{
	if(vis[x][y])	return false;
	for(int i=x-size;i<=x+size;i++)
		for(int j=y-size;j<=y+size;j++)
			if(i < 1 || i > n || j < 1 || j > n || a[i][j])
				return false;
	return true;
}
int work(int Time)
{
	if(Time < k)	return 2;
	else if(Time < 2 * k)	return 1;
	else	return 0;
}
void bfs()
{
	queue <node> q;
	vis[3][3] = 1;
	q.push((node){3, 3, 0, 2});
	while(!q.empty())
	{
		node t = q.front();
		q.pop();
		if(t.x == n - 2 && t.y == n - 2)//到达终点，停止搜索 
		{
			cout << t.Time;
			return ;
		}
		if(t.size != 0)	q.push((node){t.x, t.y, t.Time+1, work(t.Time+1)});//站着不动
		for(int i=0;i<4;i++)
		{
			int X = t.x + dx[i];
			int Y = t.y + dy[i];
			if(check(X, Y, t.size))//判断
			{
				vis[X][Y] = 1;
				q.push((node){X, Y, t.Time+1, work(t.Time+1)});
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> k;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			char c;
			cin >> c;
			if(c == '*')	a[i][j] = 1;
			else	a[i][j] = 0;
		}
	}
	bfs();
	return 0;
}

```

---

## 作者：wuhan1234 (赞：7)

## 1. 编程思路。

求小明从起点走到迷宫终点的最少时间，用广度优先搜索算法 BFS。

相比一般的 BFS 走迷宫问题，本题需要处理好以下几个关键点。

1）在某一个点小明除了可以向当前位置的上、下、左、右移动单位 $1$ 的距离，还可以停留在原地不动。这个停在原地不动每次会耗费 $1$ 个单位的时间，这个耗时是有意义的，因为耗时达到 $k$ 或 $2\times k$ 时，小明会瘦身，这样瘦身前不能走的格子，瘦身后可以走了。因此，在当前位置停留等待的状态也要入队。当然，如果小明已经瘦身到了 $1\times 1$，就没有必要休息等待了，此时再等待纯属无意义地耗费时间。

2）由于小明身体形态有 $5\times 5$、$3\times 3$ 和 $1\times 1$ 这三种情况。为此，设置一个变量 $flag$ 来表示这三种不同的形态。初始时，$flag$ 的值为 $2$，表示小明此时为 $5\times 5$ 形态；当耗时达到 $k$ 时，$flag$ 的值为 $1$，表示小明此时瘦身为 $3\times 3$ 形态；当耗时达到 $2\times k$ 时，$flag$ 的值为 $0$，表示小明此时再瘦身为 $1\times 1$ 形态。这样进行 $flag$ 值的设置，在后面进行检测时也就带来统一的好处。

例如，当小明处于 $5\times 5$ 形态时，要占据 $25$ 个格子的区域，小明要移动的话，其移动到的区域中的 $25$ 个格子均应该没有障碍物。设小明当前的位置为 $(x,y)$ ，则需要检测的区域的左下角坐标为 $(x-2,y-2)$，右上角坐标为 $(x+2,y+2)$，正好用 $(i,j)$ 进行二重循环，$i$ 的取值范围为 $x-flag \sim x+flag$，$j$ 的取值范围为 $x-flag\sim x+flag$。

3）不同于一般的迷宫，最多表示 $N\times N$ 个格子的结点入队。因为一个结点处等待也需入队，这样入队的结点个数会远远超过 $N\times N$ 个。因此，若没有采用模板库，自己用数组来表示队列。最好采用循环队列。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
#define MAXLEN 90000     // 循环队列中元素最大个数
struct Node
{
	int x, y, time;
};
int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};
int vis[305][305]={0};
char map[305][305];
int n, k;
struct Node q[MAXLEN+5];
void bfs()
{
	struct Node cur;
	cur.x = 3;
	cur.y = 3;
	cur.time = 0;
	int front=0,rear=0;
	q[rear++]=cur;
	int flag = 2;
	while (front!=rear)
    {
		cur = q[front];
		front=(front+1)%MAXLEN;
		if (cur.time == k)        // 可以瘦身为 3*3
			flag = 1;
		if (cur.time == 2*k)      // 可以瘦身为 1*1
			flag = 0;
        if (flag != 0)            // 没有瘦身到1*1之前，均可以选择在原地休息
		{
			q[rear].x=cur.x;  q[rear].y=cur.y;
			q[rear].time=cur.time+1;
			rear=(rear+1)%MAXLEN;
		}
		int m,i,j;
		for (m = 0; m < 4; m++)   // 向4个方向搜索，看能否走一格
		{
			int nx = cur.x + dx[m];
			int ny = cur.y + dy[m];
			if (nx >= 1 && nx <= n && ny >= 1 && ny <= n && vis[nx][ny] == 0)
            {
				int ok = 1;
				for (i = nx - flag; ok && (i <= nx + flag); i++)
                {
					for (j = ny - flag; j <= ny + flag; j++)
					{
						if (i<1 || i>n || j<1 || j>n || map[i][j] == '*')   // 5*5 或 3*3的格子不能让小胖容身
						{
							ok = 0;
							break;
						}
					}
				}
				if (ok)          // 可以走到下一个格子
				{
                    if (nx == n - 2 && ny == n - 2)  // 可以走到终点，输出后结束
		            {
			              printf("%d\n",cur.time+1);
			              return;
		            }
					vis[nx][ny] = 1;
                    q[rear].x=nx;
                    q[rear].y=ny;
                    q[rear].time=cur.time+1;
					rear=(rear+1)%MAXLEN;
				}
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&k);
    int i;
	for (i = 1; i <= n; i++)
        scanf("%s",&map[i][1]);
	bfs();
	return 0;
}

```




---

## 作者：_Yonder_ (赞：6)

偶然看到这道题，于是又做了一遍。~~以前写的代码真难看。~~

这题难就难在体型会变化，那么我们跑三遍 BFS 不就好了吗。从体型大到体型小依次 BFS，然后就是队列初始点的问题了。

判断上一次的体型可以到达哪些位置，将这些点加入队列，队列初始点的信息就维护完了，剩下的就是普通的 BFS 跑图啦。

时间复杂度 $O(n^2)$。

~~吐槽一下数据，为啥会有多余的空格或换行啊。~~
# Code
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
template<typename P>inline void read(P&x){bool f=0;x=0;char c=getchar();while(!isdigit(c)) f|=c=='-',c=getchar();while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();x=f?~(x-1):x;}
template<typename P>inline void write(P x){if(x<0) putchar('-'),x=-x;if(x>9) write(x/10);putchar((x%10)^48);}
const int N=305;
struct node{int i,j,ans;};
int X[5]={0,1,0,-1,0},Y[5]={0,0,1,0,-1};
char c[N][N];
int n,k;
int f[N][N][3];
inline bool check(int x,int y,int v){
	if(x-v<=0||x+v>n||y-v<=0||y+v>n||f[x][y][v]>-1) return false;
	for(register int i=-v;i<=v;i++)
		for(register int j=-v;j<=v;j++)
			if(c[i+x][j+y]=='*') return false;
	return true;
}
inline void BFS(int v){
	queue<node> Q;
	if(v==2) Q.push({3,3,f[3][3][2]=0});
	else
		for(register int i=1;i<=n;i++)
			for(register int j=1;j<=n;j++)
				if(f[i][j][v+1]>-1&&f[i][j][v+1]<=(2-v)*k)
					Q.push({i,j,f[i][j][v]=(2-v)*k});
	while(Q.size()){
		node q=Q.front();Q.pop();
		if(q.i==n-2&&q.j==n-2) return;
		for(register int k=1;k<=4;k++){
			int l=X[k]+q.i,r=Y[k]+q.j;
			if(check(l,r,v)) Q.push({l,r,f[l][r][v]=q.ans+1});
		}
	}f[n-2][n-2][v]=1e9;
}char read(){
    char ch=getchar();
    while((ch^'+')&&(ch^'*')) ch=getchar();
    return ch;
}
int main(){
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
			c[i][j]=read(),f[i][j][0]=f[i][j][1]=f[i][j][2]=-1;
	BFS(2);BFS(1);BFS(0);
	write(min({f[n-2][n-2][2],f[n-2][n-2][1],f[n-2][n-2][0]}));
	return 0;
}
```

---

## 作者：HHYQ_07 (赞：6)

# 题解

## 思路

因为 $N\leq300$，求图上的类似最短路问题，不妨想到 [BFS](https://oi.wiki/graph/bfs/)（广度优先搜索）求解。

## 细节

相比传统的 BFS 求最短路本题还有一个小明的身材。所以本题应有四个 BFS 中的变量，分别是：小明当前 x 坐标，y 坐标，时间，状态（身材）。判断是否遇到障碍物时可以使用[二维前缀和](https://oi.wiki/basic/prefix-sum/)预处理，$O(1)$ 查询。

## $ACcode$

详细注释讲解代码如下：
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
const int N=305;//养成好习惯，用常量开数组，多开几位 
int n,m,k,sum[N][N];//sum[i][j]为S(i，j)
char a[N][N];//图 
bool v[N][N];//标记数组 
int dx[4]={-1,0,0,1},dy[4]={0,-1,1,0};//方向数组，具体方向依次为：上，左，右，下 
struct node//定义结构体：当前时间，小明身材，x坐标，y坐标 
{
	int t,now,x,y;
}s;
void bfs()//BFS广度优先搜索 
{
	queue<node>q;//定义node型队列 
	q.push((node){0,3,3,3});//放入初始信息 
	v[3][3]=1;
	while(q.size())
	{
		s=q.front();q.pop();
		if(s.x==n-2&&s.y==n-2)
		{
			cout<<s.t;//访问到了终点(n-2,n-2)就输出当前时间，即答案 
			exit(0);//结束程序，等价于return和break; 
		}
		if(s.t==k||s.t==2*k)s.now--;//到时间身材会发生变化 
		int noww=s.now;
		for(int i=0;i<4;i++)
		{
			int xx=s.x+dx[i],yy=s.y+dy[i];//xx，yy为下一步的走向 
			if(xx-noww+1<1||xx+noww-1>n||yy-noww+1<1||yy+noww-1>n)continue;//判断小明是否越界 
			if(sum[xx+noww-1][yy+noww-1]-sum[xx+noww-1][yy-noww]-sum[xx-noww][yy+noww-1]+sum[xx-noww][yy-noww])continue;//如果小明这一个块中的和不为0，即存在障碍物，需跳过 
			if(v[xx][yy])continue;//访问过的点就不再访问了 
			v[xx][yy]=1;//标记此点已访问 
			q.push((node){s.t+1,noww,xx,yy});
		}
		if(noww>1)q.push((node){s.t+1,noww,s.x,s.y});//别忘了也可以原地不动 
	}
}
int main()
{
	ios::sync_with_stdio(false);//关闭流同步，优化时间复杂度 
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
			if(a[i][j]=='*')sum[i][j]=1;
			sum[i][j]=sum[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];//预处理前缀和 
		}
	bfs();
	return 0;
}
```

本人的第一篇题解，请求管理员大大通过，谢谢！

---

## 作者：qiuqiuqzm (赞：3)

# P8693 题解
[题目传送门](https://www.luogu.com.cn/problem/P8693)

## 题目大意
小明在一个 $n\times n$ 的迷宫里。一开始他占 $5\times 5$ 的区域，在时刻 $k$ 时变成只占 $3\times 3$，在时刻 $2\times k$ 时只占 $1\times 1$ 的区域。问小明从 $(3,3)$ 到 $(n-2,n-2)$ 最少要多久。

## 分析
看到题目说求最短路径，就可以想到用 BFS 算法。但直接的 BFS 肯定不行，要进行改动。

* 本题中有一个普通 BFS 没有的操作，那就是原地等待。在小明还没变成 $1\times 1$ 之前，原地等待可以度过时间，从而变瘦。而如果小明已经最瘦了，那么原地等待就没必要了。

完成最普通的 BFS 后发现会 TLE。那要进行优化。

* 我们可以发现，如果你已经在原地等了，就肯定要等到下次变瘦，不然就约等于浪费了一步，所以可以新增一个 $stay$ 变量，判断是否要走。

完成这个优化后，提交代码，AC！诶不对，没开 O2 怎么会 T 一个点。看来还可以优化下。

* 判断周围是否有障碍物，可以用二维前缀和优化。这样可以 O(1) 查询。

* 我们在看下原地等待的代码，我们发现，在原地等待肯定是要在要缩小后才能走的地方等待，不然就浪费了，所以我们可以在移动后周围有障碍物时才等待，时间复杂度优化了很多。

这样优化后就可以快乐 AC 啦！

## Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,a[305][305],pre[305][305];
bool vis[305][305];
struct node
{
	int x,y,step,stay;
};
queue<node> q;
const int dx[]={0,1,-1,0,0};
const int dy[]={0,0,0,1,-1};
bool pd(int nx,int ny,int nstep,bool mode) //mode=1判断是否可以走,mode=0判断是否有障碍物
{
	bool flag=true;
	if(nstep<k)
	{
		if(!(nx+2<=n&&nx-2>0&&ny-2>0&&ny+2<=n)&&mode)
			flag=false;
		else
			if(pre[nx+2][ny+2]-pre[nx+2][ny-3]-pre[nx-3][ny+2]+pre[nx-3][ny-3]!=0)
				flag=false;
	}
	else if(nstep<2*k)
	{
		if(!(nx+1<=n&&nx-1>0&&ny-1>0&&ny+1<=n)&&mode)
			flag=false;
		else
			if(pre[nx+1][ny+1]-pre[nx+1][ny-2]-pre[nx-2][ny+1]+pre[nx-2][ny-2]!=0)
				flag=false;
	}
	else
		flag=(!(a[nx][ny])&&((nx<=n&&nx>0&&ny>0&&ny<=n))); //最后一个不用也不会用来判断障碍物
	return flag;
}
void bfs()
{
	vis[3][3]=1;
	q.push((node){3,3,0});
	while(!q.empty()) //开始BFS
	{
		node now=q.front();
		q.pop();
		if(now.x==n-2&&now.y==n-2) //到达终点
		{
			cout<<now.step;
			return;
		}
		bool flag=now.stay;
		if(now.step>=2*k||!now.stay||now.step>=k&&now.stay==1)//判断是否要等待
			for(int i=1;i<=4;i++)
			{
				int xx=now.x+dx[i],yy=now.y+dy[i];
				if(pd(xx,yy,now.step,1)&&!vis[xx][yy])
					vis[xx][yy]=1,q.push((node){xx,yy,now.step+1,0});
				if(now.step<2*k&&!pd(xx,yy,now.step,0)) //判断是否有障碍物，有就要等待
					flag=true;
			}
		if(flag)
		{
			if(now.step<k) //等到第一次变瘦
				q.push((node){now.x,now.y,now.step+1,1});
			else //等到第二次变瘦
				q.push((node){now.x,now.y,now.step+1,2});
		}
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>k;	//读入
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			char c;
			cin>>c;
			if(c=='*')
				a[i][j]=1;
			pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j];//二维前缀和
		}
	bfs();
	return 0;
}
```

## 继续优化
虽然刚才的代码已经成功 AC 了，但是一看时间，[131ms](https://www.luogu.com.cn/record/145886715)，这还是开了 O2 的速度，~~实在是太慢了~~。那要如何才能更快呢？

* 我们发现，我们的 $stay$ 变量可以让它在等待后一直等到下一次变瘦，但是一直取出再放入太慢了，我们可以直接把步数改成下一次变瘦的时间，可以节省时间。但是这样的话 BFS 就不能保证是最快的了，所以最后到终点要用答案变量来取最小值，而且途中的标记数组 $vis$ 要记录到当前位置的最小步数，如果比最小步数大，就不能走到这。

Time:[69ms](https://www.luogu.com.cn/record/145901671)

## 优化到最优解
虽然这个代码已经排在很前面了，但是我们还可以更近一步。

* 我们可以发现，刚才的代码会重复走一些道路，而且终点不止一次到达，那要怎么办呢。我们可以用 $3$ 个队列，每个存小明在不同状态下的到达地点，然后一个一个按顺序来走，我们每次要等待时，就直接加入下一个队列。要注意，正常行走到达小明变瘦时也要加入下一个队列，这样 BFS 仍然是步数小的在前，可以保证到终点时一定为最快的，这样我们就可以抢到最优解了。

## Code([56ms](https://www.luogu.com.cn/record/145905521)):
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,a[305][305],pre[305][305];
bool vis[305][305];
struct node
{
	int x,y,step;
};
queue<node> q[3];
const int dx[]={0,1,-1,0,0};
const int dy[]={0,0,0,1,-1};
bool pd(int nx,int ny,int nstep,bool mode) //mode=1判断是否可以走,mode=0判断是否有障碍物
{
	bool flag=true;
	if(nstep<k)
	{
		if(!(nx+2<=n&&nx-2>0&&ny-2>0&&ny+2<=n)&&mode)
			flag=false;
		else
			if(pre[nx+2][ny+2]-pre[nx+2][ny-3]-pre[nx-3][ny+2]+pre[nx-3][ny-3]!=0)
				flag=false;
	}
	else if(nstep<2*k)
	{
		if(!(nx+1<=n&&nx-1>0&&ny-1>0&&ny+1<=n)&&mode)
			flag=false;
		else
			if(pre[nx+1][ny+1]-pre[nx+1][ny-2]-pre[nx-2][ny+1]+pre[nx-2][ny-2]!=0)
				flag=false;
	}
	else
		flag=(!(a[nx][ny])&&((nx<=n&&nx>0&&ny>0&&ny<=n)));//最后一个不用也不会用来判断障碍物
	return flag;
}
void bfs()
{
	vis[3][3]=1;
	q[2].push((node){3,3,0}); //3个队列对应3个状态
	for(int j=2;j>=0;j--)
	{
		while(!q[j].empty()) //开始BFS
		{
			node now=q[j].front();
			q[j].pop();
			if(now.x==n-2&&now.y==n-2) //到达终点
			{
				cout<<now.step;
				return;
			}
			bool flag=false;
			for(int i=1;i<=4;i++)
			{
				int xx=now.x+dx[i],yy=now.y+dy[i];
				if(pd(xx,yy,now.step,1)&&!vis[xx][yy])
				{
					vis[xx][yy]=1;
					if(now.step+1>=k*(3-j)&&j!=0) //变瘦了加到下一个队列
						q[j-1].push((node){xx,yy,now.step+1});
					else
						q[j].push((node){xx,yy,now.step+1});
				}
				if(now.step<2*k&&!pd(xx,yy,now.step,0)) //判断是否有障碍物，有就要等待
					flag=true;
			}
			if(flag) //要等待到下一次变瘦，加入下一个队列
				q[j-1].push((node){now.x,now.y,k*(3-j)});
		}
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			char c;
			cin>>c;
			if(c=='*')
				a[i][j]=1;
			pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j];//二维前缀和
		}
	bfs();
	return 0;
}
```

---

## 作者：MhxMa (赞：2)

### 分析
考虑搜索。

因为 $n\leq 300$，所以可以想到 bfs。

bfs 中的队列应该存储四个值：当前的 $x$ 和 $y$ 坐标、当前的时间和小明的大小。

其中小明的大小用 ```siz``` 存储，当 ```siz``` 为 $2$ 时，代表小明占用的格子为 $5\times 5$；同理，当 ```siz``` 为 $1$ 时，代表小明占用的格子为 $3\times 3$，```siz``` 为 $0$ 时，代表小明占用的格子为 $1 \times 1$。或者可以以下图的方式来看待（图示是当 $siz=2$ 时）：
![](https://cdn.luogu.com.cn/upload/image_hosting/5adho0ac.png)  
即小明占用的格子大小是 $(siz \times 2+1)^{2}$。

实现即可：

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 350;
const int dx[5] = {0, 0, 1, -1};
const int dy[5] = {1, -1, 0, 0};

int n, m, k;
char mp[N][N];
bool vis[N][N];

struct Node {
	int t, siz, x, y;
	// t代表当前时间，(siz*2+1)^2代表占用的格子数量，x和y代表当前的坐标
};

queue<Node> q;
void bfs() {
	q.push((Node) {
		0, 2, 3, 3
	}); // 当前时间为 0，大小为5*5（即siz=2）
	
	while (!q.empty()) { // 广搜
		Node u = q.front();
		q.pop();
		vis[u.x][u.y] = 1; // 设置为已访问
		if (u.x == n - 2 && u.y == n - 2) {
			cout << u.t; // 已经到达终点
			return;
		}

		// 变瘦了
		if (u.t == k) {
			u.siz = 1;
		} else if (u.t == 2 * k) {
			u.siz = 0;
		}

		for (int i = 1; i <= 4; i++) { // 遍历四周的格子
			int nx = u.x + dx[i - 1], ny = u.y + dy[i - 1];
			if (vis[nx][ny] == 1 || mp[nx][ny] == '*') { // 当前已经访问过或者当前位置为障碍物
				continue;
			}
			if (!(nx - u.siz >= 1 && nx + u.siz <= n && ny - u.siz >= 1 && ny + u.siz <= n)) { // 占用的格子超出范围
				continue;
			}
			if (u.siz == 2) { // 占用格子 5*5，当占用的格子中有障碍物，continue
				if (mp[nx - 1][ny - 1] == '*') continue;
				if (mp[nx - 1][ny + 1] == '*') continue;
				if (mp[nx + 1][ny - 1] == '*') continue;
				if (mp[nx + 1][ny + 1] == '*') continue;

				if (mp[nx][ny - 1] == '*') continue;
				if (mp[nx][ny + 1] == '*') continue;
				if (mp[nx + 1][ny] == '*') continue;
				if (mp[nx + 1][ny] == '*') continue;

				if (mp[nx][ny - 2] == '*') continue;
				if (mp[nx][ny + 2] == '*') continue;
				if (mp[nx + 2][ny] == '*') continue;
				if (mp[nx + 2][ny] == '*') continue;

				if (mp[nx + 1][ny - 2] == '*') continue;
				if (mp[nx + 1][ny + 2] == '*') continue;
				if (mp[nx + 2][ny + 1] == '*') continue;
				if (mp[nx + 2][ny + 1] == '*') continue;

				if (mp[nx - 1][ny - 2] == '*') continue;
				if (mp[nx - 1][ny + 2] == '*') continue;
				if (mp[nx + 2][ny - 1] == '*') continue;
				if (mp[nx + 2][ny - 1] == '*') continue;

				if (mp[nx - 2][ny - 2] == '*') continue;
				if (mp[nx - 2][ny + 2] == '*') continue;
				if (mp[nx + 2][ny - 2] == '*') continue;
				if (mp[nx + 2][ny + 2] == '*') continue;
			} else if (u.siz == 1) {
				if (mp[nx - 1][ny - 1] == '*') continue;
				if (mp[nx - 1][ny + 1] == '*') continue;
				if (mp[nx + 1][ny - 1] == '*') continue;
				if (mp[nx + 1][ny + 1] == '*') continue;
				if (mp[nx][ny - 1] == '*') continue;
				if (mp[nx][ny + 1] == '*') continue;
				if (mp[nx + 1][ny] == '*') continue;
				if (mp[nx + 1][ny] == '*') continue;
			}
			vis[nx][ny] = 1; // 标记为访问
			q.push((Node) {
				u.t + 1, u.siz, nx, ny
			}); // 入队
		}
		if (u.siz) {
			q.push((Node) {
				u.t + 1, u.siz, u.x, u.y
			}); // 停在原地的情况
		}
	}
	return;
}
int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			cin >> mp[i][j];
		}
	}
	bfs();
	return 0;
}
```

---

## 作者：ICU152_lowa_IS8 (赞：2)

一种全新的思路！

准备再练一遍最短路，闻着标签找到了这里，然后一看题解怎么都是 `bfs` 的？

必须给一篇最短路题解！

思路很简单，对于迷宫的每一个点，往其右边和下边的方向连双向边（相当于连成一个网格）。

然后预处理出每一个点能否在 $k$ 次、$2\times k$ 次前能否到达，如果不能，在最短路的时候稍微改一下边权就行了（具体见代码）。

有其它的题解提到 `bfs` 直接改到达时间会出现问题，而最短路完美的规避掉了这个问题！

然后就是最短路板子了！

上代码：

```
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
struct node{
	int v,next;
}edge[2000005];
int head[100005];
int s[1005][1005];
int check[200005][3]; 
int n,k;
int dis[100005],vis[100005],num;
priority_queue<pii,vector<pii>,greater<pii> >q;
int sp(int x,int y){
	return (x-1)*n+y;
}
void add(int u,int v){
	edge[++num].next=head[u];
	head[u]=num;
	edge[num].v=v;
}
void dij(int s){
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=true;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].v;
			if(dis[u]<k){//体积为5*5
				if(check[edge[i].v][2]&&dis[v]>dis[u]+1){
					dis[v]=dis[u]+1;
					q.push(make_pair(dis[v],v)); 
				}
				if(check[edge[i].v][1]&&dis[v]>k+1){
					dis[v]=k+1;
					q.push(make_pair(dis[v],v));
				}
				if(check[edge[i].v][0]&&dis[v]>2*k+1){
					dis[v]=2*k+1;
					q.push(make_pair(dis[v],v));
				}
			}
			else if(dis[u]<2*k){//体积为3*3
				if(check[edge[i].v][1]&&dis[v]>dis[u]+1){
					dis[v]=dis[u]+1;
					q.push(make_pair(dis[v],v));
				}
				if(check[edge[i].v][0]&&dis[v]>2*k+1){
					dis[v]=2*k+1;
					q.push(make_pair(dis[v],v));
				}
			}
			else{//体积为1*1
				if(check[edge[i].v][0]&&dis[v]>dis[u]+1){
					dis[v]=dis[u]+1;
					q.push(make_pair(dis[v],v));
				}
			}
		}
	}
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			char ch;
			cin>>ch;
			s[i][j]=(ch=='*');
		}
	}
	for(int i=1;i<=n;i++){//二维前缀和
		for(int j=1;j<=n;j++){
			s[i][j]=s[i-1][j]-s[i-1][j-1]+s[i][j-1]+s[i][j];
		}
	}
	for(int i=1;i<=n;i++){//预处理每种体积能不能走
		for(int j=1;j<=n;j++){
			for(int l=0;l<=2;l++){
				int xx=i-l,x=i+l,yy=j-l,y=j+l;
				if(xx<1||yy<1||x>n||y>n)continue;
				if(s[x][y]-s[x][yy-1]-s[xx-1][y]+s[xx-1][yy-1])continue;
				check[sp(i,j)][l]=1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){//每个点往自己右边和下边的点连一条双向边
			if(i!=n){
				add(sp(i,j),sp(i+1,j));
				add(sp(i+1,j),sp(i,j));
			}
			if(j!=n){
				add(sp(i,j),sp(i,j+1));
				add(sp(i,j+1),sp(i,j));
			}
		}
	}
	dij(sp(3,3));//最短路
	cout<<dis[sp(n-2,n-2)];//输出
	return 0;
}

```


---

## 作者：Yashajin_Ai (赞：2)

### 思路
用队列实现广度优先搜索，碰到障碍停止，来过了停止，越界了停止，这一部分跟普通的广度优先搜索差不多，那为何这道题评绿呢？因为小明的宽度会缩小啊，其实处理这个点十分简单，我们让小明在必要时停止运动，等待宽度变得合适时，再一次运动。代码是位置不变，时间增加时入队。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
string a[1001];
int bj[2][4]={-1,1,0,0,0,0,-1,1};
int ans[1000001]; 
struct node {
	int nowwz; // 位置 
	int nowwztime; // 到达该位置的时间 
	// 不记录小明每个位置的大小，大小可由时间来判断 
};
int main(){
	cin>>n>>k;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	queue<node>q;
	q.push({2*n+2,0});
	ans[2*n+2]=1; // 标记起点 
	while(q.size()>0){
		node t=q.front();
		q.pop();
		int x=t.nowwz/n; //当前x坐标 
		int y=t.nowwz%n; //当前y坐标 
		int tm=t.nowwztime;// 当前时间  
		int v=2; // 记录宽度
		if(tm>=2*k){
			v=0;
		}
		else if(tm>=k){
			v=1;
		}
		if(v){
			q.push({t.nowwz,tm + 1});
		} // 位置不变，时间增加 
		for(int i=0;i<4;i++){ // 四个方向 
			int tx=x+bj[0][i],ty=y+bj[1][i],flag=0;
			int txyb=tx*n+ty;
			if(tx-v<0||ty-v<0||tx+v>=n||ty+v>=n){
				continue;
			}// 越界
			if(ans[txyb]){
				continue;
			}// 遇到过没 
			for(int j=-v;j<=v;j++){
				for(int k=-v;k<=v;k++){
					if(a[tx+j][ty+k]=='*'){
						flag=1;
						break;
					}
				}
			}// 遇到障碍物
			if(flag){
				continue;	
			}
			if(tx==n-3&&ty==n-3){
				cout<<tm+1;
				return 0;
			}// 剪枝 
			ans[txyb]=1;
			q.push({txyb,tm+1}); 
		}
	}
	return 0;
}
```

---

## 作者：CSPAK_Zhangxiuqi0011 (赞：1)

# P8693题解
# 前言
这篇题解其实是我一年前写的，当时没过审，也就没管了。今天翻博客的时候偶然发现有这篇题解，就把它改了一下发出来了，所以语言表述可能不太好，请见谅。现在题解区好像还是没有我这种做法。这种方法对于不知道怎么处理变瘦的同学还是很有帮助的，大佬可以选择跳过。~~当然，代码也是一年前的。~~
# 题面
[题目传送门。](https://www.luogu.com.cn/problem/P8693)  

# 思路
小明会在第 $k$ 秒变瘦，又会在第 $2\times k$ 秒再次变瘦。大佬都是一个 bfs 就解决，我们可以用三个 bfs：  
1. 小明占 $5 \times 5$ 空间的时候。 
2. 小明占 $3 \times 3$ 空间的时候。 
3. 小明只占一个空间的时候。
为什么要分 $3$ 个 bfs 呢？不妨脑补一下：如果不会在一个 bfs 里面处理变瘦，那么我们就干脆把前 $k$ 秒小明所有可以走的位置全部记录一遍。  
等到第 $k$ 秒开始的时候，之前走的每一个位置都有可能再衍生出新的可走位置（因为小明变瘦了），那么我们就可以把之前走到的所有地方全部记录一遍，再放进 bfs 试一下，能不能走到新的地方。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,mp[305][305],t[305][305],nj,nt,dx[4] = {0,0,1,-1},dy[4] = {1,-1,0,0};//nj：现在小明占的正方形的边离小明正中心的距离（即小明占5*5的时候是2）     nt：现在的时间。 
struct node{
	int x,y;
};
queue<node>q;
void build(){//负责将之前能走的所有地方入队 
	q = queue<node>();
	for(int i = 1;i<=n;i++){
		for(int j = 1;j<=n;j++){
			if(t[i][j] && !mp[i][j]){//注意:我的代码中是直接把迷宫复制给状态数组，把走过的地方都默认成墙，所以不能只判断这个地方是不是1，还要判断这里是不是城墙 
				q.push({i,j});
			}
		}
	} 
}
int check(int x,int y){
	if(x-nj<=0 || x+nj>n || y-nj<=0 || y+nj>n || t[x][y]){
		return 0;
	}
	for(int i = x-nj;i<=x+nj;i++){//判断小明所占的空间内是否有墙 
		for(int j = y-nj;j<=y+nj;j++){
			if(mp[i][j]){
				return 0;
			}
		}
	}
	return 1;
}
void bfs(int up){//up:小明到第几秒瘦下来 
	for(;nt<=up && !q.empty();nt++){ 
		int l;
		l = q.size();
		while(l--){
			node h;
			h = q.front();
			q.pop();//建议大家养成良好习惯，把pop放在前面写了 
			if(h.x == n-2 && h.y == n-2){//注意终点 
				cout<<nt<<"\n";//这里是我的一个习惯，大家可根据自己的模版写。我给解释一下：因为后面我们放节点的时候是无脑放的，那么这时判断到的其实是上一秒已经
				//到的，要减一。但是我们这时候输出的nt-1是时刻，题目问的是所需时间。时间从时刻0开始，所以这里的时刻还需要加一（毕竟人无完人，我语文不好，不能描
				//述得很清楚），加一和减一抵消 
				exit(0);//注意不能习惯性的写return;要不写标识变量，要不直接强制结束程序。 
			}
			for(int j = 0;j<4;j++){
				int nx,ny;
				nx = h.x+dx[j];
				ny = h.y+dy[j];
				if(check(nx,ny)){
					q.push({nx,ny});
					t[nx][ny]++;
				}
			}
		}
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i = 1;i<=n;i++){
		for(int j = 1;j<=n;j++){
			char h;
			cin>>h;
			if(h == '+'){
				mp[i][j] = 0;
			}else{
				mp[i][j] = 1;
			}
			t[i][j] = mp[i][j];
		}
	}
	q.push({3,3});//注意起点 
	t[3][3]++;
	nj = 2;
	nt = 0;
	bfs(k-1);
	build();
	nj = 1;
	nt = k;
	bfs(2*k-1);
	build();
	nj = 0;
	nt = 2*k;
	bfs(INT_MAX);//这个时候没有时间限制，制成无限大 
	return 0;//好习惯 
}//代码虽然看起来时间复杂度很大，但是因为最后都只能扫到这么些地方，时间复杂度差不多
```

---

## 作者：fengyuxuan (赞：1)

## 题目大意
一张 $n\times n$ 的地图，一个大胖子，一开始占用 $5\times 5$ 的区域，从 $0$ 时刻出发，可以向上、下、左、右四个方向走，在时刻 $k$ 会变成一个胖子，只占用 $3\times3$ 的区域，在时刻 $2\times k$ 会变成一个正常人，只占用 $1\times1$ 的区域。

问从起点第 $3$ 行第 $3$ 列到终点第 $n-2$ 行第 $n-2$ 列的最少时间
## 题目解析
很明显这是一题**最短路**，用广搜即可。

```cpp
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
struct node{int x,y,t;};
void bfs()
{
	int vis[305][305];
	int xx,yy;
	queue<node>q;
	node f;
	q.push((node){3,3,0});
	vis[3][3]=1;
	for(int i=2;i>=0;i--)
		while(!q[i].empty())
		{
			f=q.front();
			q.pop();
			if(f.x==n-2&&f.y==n-2)
			{
				cout<<f.t;
				return ;
			}
			for(int j=0;j<4;j++)
			{
				xx=f.x+dx[j];
				yy=f.y+dy[j];
           		//……
			}
		}
}
```
这是大致模板，结构体中的 $x$，$y$ 表示位置 $t$ 表示时间。

但题目中的人却有三个不同状态。

所也就可用三个队列实现，分别为 $p_0$，$p_1$，$p_2$ 分别搜索占用 $1\times1$，$3\times3$，$5\times 5$ 区域可以走到的位置

从 $p_2$ 开始搜索，题目中说可以在原地等待，所以每搜到一个位置，都可以原地等直到变为下一个状态，所以每个位置都可以把时间变为 $k$ 或 $2\times k$ 再进到下一个队列即可。

接着就是判断是否出界和是否可以通过。

前面我们让 $p_0$，$p_1$，$p_2 $ 分别来搜索占用 $1\times1$，$3\times3$，$5\times 5$ 区域可以走到的位置，所以队列的下标很方便地可以帮助我们判断是否出界和是否可以通过，具体如下：
$$5=2\times2+1$$
$$3=2\times1+1$$
$$1=2\times0+1$$
如果下标为 $i$,则只要看这个位置周围 $i$ 的范围即可

其次可用前缀和优化来优化判断是否可以通过，代码如下：
```cpp
for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>c;
			if(c=='*')
				a[i][j]=1;
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
		}
```

```cpp
sum=s[xx+i][yy+i]-s[xx+i][yy-i-1]-s[xx-i-1][yy+i]+s[xx-i-1][yy-i-1];
if(xx<1+i||xx>n-i||yy<1+i||yy>n-i||vis[xx][yy]==1||sum!=0)
	continue;

```
## 最终代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[305][305],s[305][305];
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
char c;
struct node{int x,y,t;};
void bfs()
{
	int vis[305][305];
	int xx,yy,sum;
	queue<node>q[3];
	node f;
	q[2].push((node){3,3,0});
	vis[3][3]=1;
	for(int i=2;i>=0;i--)//枚举每个队列（状态）
		while(!q[i].empty())
		{
			f=q[i].front();
			q[i].pop();
			if(f.x==n-2&&f.y==n-2)
			{
				cout<<f.t;
				return ;
			}
			for(int j=0;j<4;j++)
			{
				xx=f.x+dx[j];
				yy=f.y+dy[j];
				sum=s[xx+i][yy+i]-s[xx+i][yy-i-1]-s[xx-i-1][yy+i]+s[xx-i-1][yy-i-1];
				if(xx<1+i||xx>n-i||yy<1+i||yy>n-i||vis[xx][yy]==1||sum!=0)
					continue;
				vis[xx][yy]=1;
				q[i].push((node){xx,yy,f.t+1});
			}
			if(f.t<(3-i)*k&&i>0)
				q[i-1].push((node){f.x,f.y,(3-i)*k});//时间如果没到下一个可以变瘦的时间，则可以原地等待到变瘦
		}
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>c;
			if(c=='*')
				a[i][j]=1;
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//前缀和优化
		}
	bfs();
	return 0;
}
```


---

## 作者：huhaoming2011 (赞：0)

# 大胖子走迷宫 题解

## 题目大意

小明在一个大小为 $n \times n$ 的迷宫内行走。

与普通的走迷宫不同，他是个胖子，起初要占用 $5 \times 5$ 的空间。但是，当小明在迷宫内待了 $k$ 个单位时间后 ，他会瘦成 $3 \times 3$ 。再过 $k$ 个单位时间后（即在迷宫内待了 $2k$ 个单位时间），他会瘦成正常的 $1 \times 1$ ，往后不会再瘦了。

问：小明以第三行第三列为起点，最少需要多久的单位时间到达终点（第 $n-2$ 行第 $n-2$ 列）。

## 分析

首先看一下数据：$n \leq 300$。很明显，可以直接暴力做。

那么这种走迷宫，我们考虑广度优先搜索。

每次进行合法的移动，或者不动。

在以往的题中，不动往往是无用的，但是，因为耗时间可以让小明变瘦好穿过狭窄地区，故时间的增加（不动）也成为了一种用来更新的情况。

明显，耗时大于 $2k$ 时是浪费的，这时就必须要移动。

其实流程十分简单：

1. 弹出无用的队列。

2. 将站着不动的情况加入队列（判断后）。

3. 进行合法移动，并放入队列。

4. 运行以上部分直到到终点。

细节详见代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 310;
const int MAXM = 1e6 + 100;
const int MOD = 1e6;   //模一下，循环利用数组防止爆炸！
int n, m, bz[MAXN][MAXN];
char s[MAXN][MAXN];
struct node {
    int x, y, tim, siz;
} q[MAXM];
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int check(int x, int y, int siz)
{
    int op = siz / 2;
    for(int i = x - op; i <= x + op; i++)
    {
        for(int j = y - op; j <= y + op; j++)
        {
            if(i < 1 or i > n or j < 1 or j > n or s[i][j] == '*')
                return 0;
        }
    }
    return 1;
}
void bfs()
{
    int hd = 0, tl = 1;
    q[1].x = q[1].y = 3;
    q[1].tim = 0, q[1].siz = 5;
    while(hd != tl)  //细节！！！
    {
        hd++;
        hd %= MOD;
        if(q[hd].siz != 1)
        {
            tl++;
            tl %= MOD;
            q[tl].x = q[hd].x;
            q[tl].y = q[hd].y;
            q[tl].tim = q[hd].tim + 1;
            q[tl].siz = q[hd].siz;
            if(q[tl].tim == m)
                q[tl].siz = 3;
            if(q[tl].tim == 2 * m)
                q[tl].siz = 1;
        }
        for(int i = 0; i < 4; i++)
        {
            int xx, yy;
            xx = dx[i] + q[hd].x;
            yy = dy[i] + q[hd].y;
            if(bz[xx][yy] == 0 and check(xx, yy, q[hd].siz))
            {
                bz[xx][yy] = 1;
                tl++;
                tl %= MOD;
                q[tl].x = xx;
                q[tl].y = yy;
                q[tl].siz = q[hd].siz;
                q[tl].tim = q[hd].tim + 1;
                if(q[tl].tim == m)
                    q[tl].siz = 3;
                if(q[tl].tim == 2 * m)
                    q[tl].siz = 1;
                if(xx == n - 2 and yy == n - 2)
                {
                    printf("%d", q[tl].tim);
                    return ;
                }
            }
        }
    }
}
int main()
{
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; i++)
        scanf("%s", s[i] + 1);
    bfs();
    return 0;
}
```

---

## 作者：IkeveLand (赞：0)

## 算法：BFS
**思路**：
- 考虑到大胖子走迷宫的过程中，会随着时间的推移，体形会变~~小~~瘦，有些位置可能现在太~~大~~胖走不过去，卡住了，可能在原地等着消耗脂肪。
- 或者走别的路就能穿过去，因此走到某个位置时，还需要记录走到当前位置所对应的时间 ~~即可推出体型大小~~。

## Code:
```c
#include <bits/stdc++.h>
using namespace std;
const int N=310;
char g[N][N];
int n,k;
bool st[N][N];
struct state{
    int x;
    int y;
    int time;
};
bool check(int x,int y,int ss){
    int m=0;
    if(ss<k) m= 2;
    else if(ss>=k&&ss<2*k) m=1;
    else if(ss>=2*k) m= 0;
    if(x-m<1||x+m>n||y-m<1||y+m>n) return 0;
    if(st[x][y]) return 0;
    for(int i=x-m;i<=x+m;i++)//枚举所覆盖的区域内是否有障碍
    {
        for(int j=y-m;j<=y+m;j++)
        {
            if(g[i][j]=='*') return 0;
        }
    }
    return 1;
}
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int bfs(){
    queue<state> q;
    q.push({3,3,0});
    st[3][3]=1;
    while(q.size())
    {
        state t=q.front();
        q.pop();
        if(t.time<2*k)
        {
            q.push({t.x,t.y,t.time+1});
        }
        for(int i=0;i<4;i++)
        {
            int xa=t.x+dx[i],yb=t.y+dy[i];
            if(!check(xa,yb,t.time)) continue;
            q.push({xa,yb,t.time+1});
            st[xa][yb]=1;
            if(xa==n-2&&yb==n-2) return t.time+1;
        }

    }
    return -1;
}
signed main()
{
    cin.tie(0);
    cout.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
            cin>>g[i]+1;
    }
    int ans=bfs();
    cout<<ans<<"\n";
    return 0;
}

/* m表示当前时刻胖子体积所覆盖的最远边际，如目前时刻小于k，则是5x5
   则覆盖区域是个矩形，四个顶点的横坐标与纵坐标分别是x+m,x-m,y+m,y-m
   用于后面判断是否合法*/
   
```

---

## 作者：qinmingze (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8693)

### 思路

本题是一道十分明显的广搜题。

其中我们在搜索时，需要用队列维护的变量如下：

- $x$ 代表当前坐标的横坐标。

- $y$ 代表当前坐标的纵坐标。

- $t$ 代表当前小明的大小。

- $step$ 代表当前小明所经历的时间。

在搜索的时候，对于四个方向的判断，我们需要注意的是，当前小明的大小，即所占的格子是否都是 `+`，同时判断其范围就可以了；当小明选择原地不动，只是消耗时间的时候，我们便需要**将小明的状态进行改变**，否则只是在这里停留，状态却并没有改变是没有意义的，因此我们需要改变小明的状态，改变方式如下：

```cpp
if(now.step < k && !vis[now.x][now.y][1]){//将小明从大胖子的状态改为胖子的状态。
	q.push({now.x, now.y, 1, k});
}
if(now.step < 2 * k && !vis[now.x][now.y][0]){//将小明从大胖子/胖子的状态改为正常人的状态。
	q.push({now.x, now.y, 0, 2 * k});
}
```

而因为我们对停留操作做了特殊操作，因此我们需要**用优先队列**，按 $step$ 为关键字，从小到大进行排序，这样就能保证第一次求出来的答案，肯定是最后的结果了。

### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 310;

int n, k;

char mp[N][N];

struct node{
	int x, y, t, step;
};

bool operator < (node a, node b){//按 step 为关键字进行排序。
	return a.step > b.step;
}

priority_queue<node> q;

bool vis[N][N][3];

int dis[N][N];

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

bool in(int x, int y, int t){
	return x - t >= 1 && x + t <= n && y - t >= 1 && y + t <= n;
}

bool check(int x, int y, int t){
	for(int i = x - t; i <= x + t; i++){
		for(int j = y - t; j <= y + t; j++){
			if(mp[i][j] == '*') return false;
		}
	}
	return true;
}

void bfs(){
	q.push({3, 3, 2, 0});
	vis[3][3][2] = true;
	while(!q.empty()){
		node now = q.top();
		q.pop();
		if(now.x == n - 2 && now.y == n - 2){
			cout << now.step << endl;
			return ;
		}
		if(now.step == k) now.t = 1;
		if(now.step == 2 * k) now.t = 0;
		if(now.step < k && !vis[now.x][now.y][1]){
			q.push({now.x, now.y, 1, k});
		}
		if(now.step < 2 * k && !vis[now.x][now.y][0]){
			q.push({now.x, now.y, 0, 2 * k});
		}
		for(int i = 0; i < 4; i++){
			int nx = now.x + dx[i];
			int ny = now.y + dy[i];
			if(in(nx, ny, now.t) && check(nx, ny, now.t) && !vis[nx][ny][now.t]){//是否可以走。
				vis[nx][ny][now.t] = true;//当前状态。
				q.push({nx, ny, now.t, now.step + 1});
			}
		}
	}
}

int main(){
	cin >> n >> k;
	for(int i = 1; i <= n; i++) scanf("%s", mp[i] + 1);
	bfs();
}
```

---

## 作者：2c_s (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8693)

## 思路

广搜。

我们考虑在搜索时传四个参数：当前位置 $(x,y)$，当前肥胖度，和当前时间（步数）。

读图后把当前肥胖度 $s$ 设为 $2$，方便找 $5\times 5$ 的网格，即从左上角 $(x-s,y-s)$ 到 右下角 $(x+s,y+s)$ 的正方形。搜索时判断当前时间是否为 $k$ 或 $2\times k$。如果是，那么将肥胖度分别更改为 $1$ 和 $0$。之后就是正常进行搜索了。

由于我们可以选择不动，所以可以在某个地方静静等待到不在肥胖，再行走。我们**直接更改时间到 $k$ 或 $2\times k$ 压入队列**就可以大大降低时间复杂度。

判定某个点是否能走，要考虑当前的肥胖度。肥胖度为 $s$ 时，能走的地方就是左上角 $(s+1,s+1)$ 到右下角 $(n-s,n-s)$ 的正方形。同时要注意左上角 $(x-s,y-s)$ 到 右下角 $(x+s,y+s)$ 的正方形内**不能有障碍物**，二重循环遍历检查即可。

- 注意队列内时间无序。这时候我们要用到**优先队列**优化。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char readc(){//字符读入。
	char c=getchar();
	while(c=='\n'||c=='\r'||c==' ')c=getchar();
	return c;
}
const int N=310;
int n,k;
bool vis[N][N][3];//三维标点，防止少走。
char c[N][N];
struct node{
	int x,y,op,step;
	bool operator<(const node a)const{return step>a.step;}//大根堆转小根堆重载。
};priority_queue<node>q;
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
bool check(int x,int y,int s){//检查某个点是否能走。
	if(x-s<1||x+s>n||y-s<1||y+s>n||vis[x][y][s])return 0;
	for(int i=x-s;i<=x+s;++i){
		for(int j=y-s;j<=y+s;++j){
			if(c[i][j]=='*')return 0;
		}
	}
	return 1;
}
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j)c[i][j]=readc();
	}
	q.push({3,3,2,0});
	while(q.size()){
		node now=q.top();
		q.pop();
		if(now.x==n-2&&now.y==n-2){
			cout<<now.step;
			return 0;
		}
		if(vis[now.x][now.y][now.op])continue;
		vis[now.x][now.y][now.op]=1;
		if(now.step<k*2){//站在一个位置等待。
			if(now.step<k)q.push({now.x,now.y,1,k});
			q.push({now.x,now.y,0,k*2});
		}
		if(now.step==k)now.op=1;//更改肥胖度。
		else if(now.step==k*2)now.op=0;
		for(int i=0;i<4;++i){
			int xx=dx[i]+now.x;
			int yy=dy[i]+now.y;
			if(check(xx,yy,now.op))q.push({xx,yy,now.op,now.step+1});
		}
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/164603272)

---

## 作者：WegestGao (赞：0)

当看到 BFS 的标签的时候，我兴致勃勃地冲了上去，但是冲着冲着发现要么油不够了（脑子炸了），要么冲错了但是找不到错在哪儿（调了半天也没对）。好不容易对了，发个题解分享一下经验。

### 题目分析

看到大胖子、胖子、正常人的描述，我们就知道（虽然我也不知道这种 BFS 的专有名词）这是不同大小的 BFS。那一瞬间，我们可能就会想到将一整个地图给**压缩**了，**这确实是一种思路，但还是过于复杂**。于是，为什么我们不依然像原来一样进行 BFS，只是**判断能否走的时候也同时判断周围的内容是否合法**呢？

由于最开始的时候已经给了 $(3,3)$ 的位置，所以我们在移动到下一个地方的时候依然是上、下、左、右四个方向的方向数组。如下所示：

```
int dx[]={1,0,-1,0};
int dy[]={0,1,0,-1};
```

但是，在移动的时候我们需要些三个判断函数，用来判断分别在大胖子、胖子、正常人的时候移动的目标点是否合法。我的传入值写的是目标点横纵坐标。如下所示：

```
bool isok1(int x, int y) {  // 表示大胖子的判断
    for (int i = -2; i <= 2; ++i) {
        for (int j = -2; j <= 2; ++j) {
            if (x+i < 1 || x+i > n || y+j < 1 || y+j > n || c[x+i][y+j] == '*' || flag3[x][y]) { // 如果越界或有障碍或走过了 不合法
                return false;
            }
        }
    }
    return true;
}

bool isok2(int x, int y) {  // 表示胖子的判断
    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            if (x+i < 1 || x+i > n || y+j < 1 || y+j > n || c[x+i][y+j] == '*' || flag2[x][y]) { // 如果越界或有障碍或走过了 不合法
                return false;
            }
        }
    }
    return true;
}

bool isok3(int x, int y) {  // 表示正常人的判断
    return x >= 1 && x <= n && y >= 1 && y <= n && !flag[x][y] && c[x][y] == '+'; // 如果越界或有障碍或走过了 不合法
}
```

我们的 $flag[i][j]$ 表示地图中第 $i$ 行第 $j$ 列是否被这个人（或者这个人所占空间的中心位置）覆盖过。对于不同的状态，我们要采用三个布尔数组。其中，一号是正常人，二号是胖子，三号是大胖子。这样就可以了。

```
bool flag[310][310];  // number1
bool flag2[310][310]; // number2
bool flag3[310][310]; // number3
```

于是，我们先从大胖子开始，然后判断是否可以走向周围，让可以走的坐标进队，维护 $flag$ 数组，直到走了 $k$ 步变成胖子；同理，再走 $k$ 步变成正常人，继续走，直到走到目标点。

像这样，问题就被我们**基本**解决了。

**但是还有情况我们没有考虑。**

如果大胖子或胖子在走，$flag$ 数组也在更新。一旦他们可以走的区域走完了，但是还没到 $k$ 或 $2k$ 的时刻，那不就没有结果了吗？

所以，我们还需要在队列已空但还没到临界时间点的时候，让升级后的胖子或正常人（即使没有升级）**探探路**，将所有大胖子或胖子能走的地方让这些升级版的人去走一遍，从而保证找到的是最短路径。就像这样：

```
if (q.empty())
   for (int i = 1; i <= n; ++i)
       for (int j = 1; j <= n; ++j)
           if (flag3[i][j]) 
		          q.push({i, j, k});  // 切换到胖子状态
```

这样才算勉强完成。

最后，附上 AC 代码：

```
#include <bits/stdc++.h>
using namespace std;

int n, k;
char c[310][310];
bool flag[310][310];   // 标记正常人
bool flag2[310][310];  // 标记胖子
bool flag3[310][310];  // 标记大胖子

struct node {
    int x, y, fot;
};

int dx[] = {1, 0, -1, 0};
int dy[] = {0, 1, 0, -1};
queue<node> q;

bool isok1(int x, int y) {
    for (int i = -2; i <= 2; ++i) {
        for (int j = -2; j <= 2; ++j) {
            if (x+i < 1 || x+i > n || y+j < 1 || y+j > n || c[x+i][y+j] == '*' || flag3[x][y]) {
                return false;
            }
        }
    }
    return true;
}

bool isok2(int x, int y) {
    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            if (x+i < 1 || x+i > n || y+j < 1 || y+j > n || c[x+i][y+j] == '*' || flag2[x][y]) {
                return false;
            }
        }
    }
    return true;
}

bool isok3(int x, int y) {
    return x >= 1 && x <= n && y >= 1 && y <= n && !flag[x][y] && c[x][y] == '+';
}

void processQueue(queue<node>& q, int kind) {
    while (!q.empty()) {
        int x = q.front().x;
        int y = q.front().y;
        int fot = q.front().fot;
        q.pop();

        if (x == n-2 && y == n-2) {
            cout << fot << endl;
            exit(0);  // 直接退出程序，输出结果
        }

        if (kind == 0 && fot >= k) {
            return;  // 如果是大胖子且时间已达到 k，停止处理，等待切换状态
        }
        if (kind == 1 && fot >= 2*k) {
            return;  // 如果是胖子且时间已达到 2k，停止处理，等待切换状态
        }

        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (kind == 2) {  // 正常人状态
                if (isok3(nx, ny)) {
                    q.push({nx, ny, fot+1});
                    flag[nx][ny] = true;
                }
            } else if (kind == 1) {  // 胖子状态
                if (isok2(nx, ny)) {
                    q.push({nx, ny, fot+1});
                    flag2[nx][ny] = true;
                }
            } else {  // 大胖子状态
                if (isok1(nx, ny)) {
                    q.push({nx, ny, fot+1});
                    flag3[nx][ny] = true;
                }
            }
        }
    }
}

signed main() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            cin >> c[i][j];
        }
    }
    
    q.push({3, 3, 0});
    flag3[3][3] = true;
    
    while (true) {
        processQueue(q, 0);  // 处理大胖子状态
        if (q.empty()) {
            for (int i = 1; i <= n; ++i) {
                for (int j = 1; j <= n; ++j) {
                    if (flag3[i][j]) {
                        q.push({i, j, k});  // 切换到胖子状态
                    }
                }
            }
        }
        
        processQueue(q, 1);  // 处理胖子状态
        if (q.empty()) {
            for (int i = 1; i <= n; ++i) {
                for (int j = 1; j <= n; ++j) {
                    if (flag2[i][j]) {
                        q.push({i, j, 2*k});  // 切换到正常人状态
                    }
                }
            }
        }
        
        processQueue(q, 2);  // 处理正常人状态
        if (q.empty()) {
            break;  // 队列为空且没有更多状态可以切换，退出循环
        }
    }
    
    //cout << 0 << endl;  // 如果没有找到路径，输出0
    return 0;
}
```
更新日期：2024年7月5日。求通过！！！

---

## 作者：keepwatcher_kensap (赞：0)

## Part 1 题意

小明在一个 $n \times n$ 的迷宫中，打算从 $(3,3)$ 走到 $(n-2,n-2)$。定义时间为 $t$：

- $t=1 \dots k-1$ 时小明占地 $5 \times 5$。

- $t=k \dots 2k-1$ 时小明占地 $3 \times 3$。

- $t \geqslant 2k$ 时占地 $1 \times 1$。

求小明从 $(3,3)$ 走到 $(n-2,n-2)$ 的最短用时。

## Part 2 引入

我们要求的是最短的时间，因此考虑 BFS 算法（广度优先搜索算法）。每次我们在队列中储存四个变量 $(x,y,s,t)$，分别表示目前的横坐标，纵坐标，小明的体型，时间。

## Part 3 思路

在初始的时候，我们所储存的是 $(3,3,2,0)$。为了方便，我们可以将小明的体积为 $5 \times 5,3 \times 3,1 \times 1$ 时用 $s=2,s=1,s=0$ 储存。我们每次都知道时间 $t$，因此可以定义一个函数来求出 $s$：

```
inline int check(int time) // 此处的m为原题中的k;
{
	if (time<m) return 2;
	if (time<2*m) return 1;
	return 0;
}
```

我们每一都要考虑小明站着不动或向上下左右移动四种方案。很轻易的，我们能求出小明下一刻的状况 $(nx,ny,ns,nt)$。小明下一刻必须要在迷宫内，不能超出范围，故满足：

- $1 \leq nx-ns,nx+ns,ny-ns,ny+ns \leq n$。

如果小明在下一刻是能满足条件的，那我们就将 $(nx,ny,ns,nt)$ 放入队列之中。

## Part 4 优化

### 优化一

小明之所以有时会站着不动，目的必然是为了消耗脂肪来减少体积，从而达到走进更狭窄的地方的效果。但是小明的体积最小是 $1 \times 1$，此时此刻小明的体积便不可能再变小了，因此在原地等待是没有意义的。

换言之，$(x,y,s,t)$ 如果满足 $s=0$ 的情况，我们就不会再考虑小明原地不动的状况。

### 优化二

我们总不能让小明在一些地方做毫无意义的横跳吧？所以我们要用 $b_{i,j}$ 表示 $(i,j)$ 处是否曾到达过，不能让小明到达曾到达过的地方。

我们在对 $b$ 进行修改和判断应该在小明进行运动的时候，小明如果站着不动就不用考虑 $b$。这样子小明在原地就不会被当做到过这个点。

## Part 5 代码

```
#include <bits/stdc++.h>
using namespace std;
int n,m;
int fx[10]={0,-1,0,1,0};
int fy[10]={0,0,1,0,-1};
char ch[305][305];
bool b[305][305];
struct asdf { int x,y,t,s; };
queue<asdf> que;
inline bool inside(asdf sum)
{
	if (b[sum.x][sum.y]) return false;
	for (int i=sum.x-sum.s;i<=sum.x+sum.s;i++)
	{
		for (int j=sum.y-sum.s;j<=sum.y+sum.s;j++)
		{
			if (i<1 || i>n || j<1 || j>n) return false;
			if (ch[i][j]=='*') return false;
		}
	}
	return true;
}
inline int check(int time)
{
	if (time<m) return 2;
	if (time<2*m) return 1;
	return 0;
}
inline bool theedn(asdf sum)
{
	return (sum.x==n-2 && sum.y==n-2);
}
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++) cin>>ch[i][j];
	}
	asdf fdsa;
	fdsa.x=3,fdsa.y=3,fdsa.s=2,fdsa.t=0;
	que.push(fdsa);
	while (!que.empty())
	{
		asdf sum=que.front();
		que.pop();
		if (theedn(sum)) { cout<<sum.t;return 0; }
		for (int i=1;i<=4;i++)
		{
			int nx=sum.x+fx[i],ny=sum.y+fy[i];
			asdf now;
			now.x=nx,now.y=ny,now.s=sum.s,now.t=sum.t;
			if (!inside(now)) continue;
			b[now.x][now.y]=true;
			now.t++;now.s=check(now.t);
			que.push(now);
		}
		if (sum.s==0) continue;
		asdf now;
		now.x=sum.x,now.y=sum.y,now.t=sum.t+1,now.s=check(sum.t+1);
		que.push(now);
	}
	return 0;
}
```

---

## 作者：sunpengyu (赞：0)

#### 蒟蒻第一次写题解，写的不好请指出，谢谢。本题做法源自课上老师的做法。
# P8693 大胖子走迷宫-题解
## 1. 题目大意。
题目的意思是说，从前，有一个叫小明的大胖子，同学要帮他减肥，于是带他去走迷宫，迷宫大小为 $n \times n$。小明 $1$ 秒走一格，能上下左右移动，加号代表空地，星号代表障碍物。同时，过 $k$ 秒后，小明的~~体积~~会变化，$2 \times k$ 秒后，会变成正常人的体积。问，要多久才能走到终点。
## 2. 题目分析。
拿到题目的时候，~~要先下意识的看一下标签~~，发现这是一道广搜题，我们都知道搜索有一些比如深搜，记忆化搜索什么的，那么广搜是什么呢？有请百度：
###### 宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra 单源最短路径算法和 Prim 最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫 BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。
没错，这就是广搜，是不是很死板？这道题目能彻底的让你快乐。
### 1. 输入。
看到题目时，先看看输入什么，输入是 $n$ 和 $k$，表示迷宫的边长和几秒后小明会变化，接着是一个字符矩阵。
### 2. 变量，数组，结构体定义及函数定义与调用。
```
int n,k,sx,sy,ex,ey,ans=1e9+7;
char a[305][305];
int vis[305][305],mp[305][305][45];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
struct node{
	int x,y,t,w;
};
queue<node> q;
int init(int x,int y,int w){
	for(int i=-w;i<=w;i++){
		for(int j=-w;j<=w;j++){
			int nx=x+i;
			int ny=y+j;
			if(a[nx][ny]=='*'||nx<1||nx>n||ny<1||ny>n) return 1;
		}
	}
	return 0;
}
bool jud(int x,int y,int w){
	if(x<1||x>n||y<1||y>n) return false;
	if(mp[x][y][w]==1) return false;
	return true;
}
void bfs(){
	vis[sx][sy]=1;//标记
	q.push({sx,sy,0,2});
	while(!q.empty()){
		node h=q.front();//拿到队头
		q.pop();
		int flag=0;
		for(int i=0;i<4;i++){
			int x=h.x+dx[i];
			int y=h.y+dy[i];//四个方向
			if(a[x][y]=='*') continue;
			if(jud(x,y,h.w)&&vis[x][y]==0){
				flag=1;
				int w=h.w;
				if(h.t+1==k) w=1;
				if(h.t+1==k+k) w=0;
				vis[x][y]=1;
				q.push({x,y,h.t+1,w});
				if(x==ex&&y==ey){
					ans=h.t+1;//判断到达
					return;
				}
			}
			if(vis[x][y]==0) flag=1;
		} 
		if(h.w>0&&flag==1){
			int w=h.w;
			if(h.t+1==k) w=1;
			if(h.t+1==k+k) w=0;//过不去的情况
			q.push({h.x,h.y,h.t+1,w});
		}
	}
}
```


注释一下：代码中的 $sx$，$sy$，$ex$，$ey$ 表示起点和终点的坐标，$a$ 是字符数组，$vis$ 记录访问，$mp$ 记录卡位，$dx$，$dy$ 记录 $4$ 个方向，同时，这段代码是核心代码。
### 3. 主函数。
这个比较简单，不做过多解释。
## 3. 完整程序。
贴上代码。大家最感兴趣的地方。
```
#include<bits/stdc++.h>
using namespace std;
int n,k,sx,sy,ex,ey,ans=1e9+7;
char a[305][305];
int vis[305][305],mp[305][305][45];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
struct node{
	int x,y,t,w;
};
queue<node> q;
int init(int x,int y,int w){
	for(int i=-w;i<=w;i++){
		for(int j=-w;j<=w;j++){
			int nx=x+i;
			int ny=y+j;
			if(a[nx][ny]=='*'||nx<1||nx>n||ny<1||ny>n) return 1;
		}
	}
	return 0;
}
bool jud(int x,int y,int w){
	if(x<1||x>n||y<1||y>n) return false;
	if(mp[x][y][w]==1) return false;
	return true;
}
void bfs(){
	vis[sx][sy]=1;
	q.push({sx,sy,0,2});
	while(!q.empty()){
		node h=q.front();
		q.pop();
		int flag=0;
		for(int i=0;i<4;i++){
			int x=h.x+dx[i];
			int y=h.y+dy[i];
			if(a[x][y]=='*') continue;
			if(jud(x,y,h.w)&&vis[x][y]==0){
				flag=1;
				int w=h.w;
				if(h.t+1==k) w=1;
				if(h.t+1==k+k) w=0;
				vis[x][y]=1;
				q.push({x,y,h.t+1,w});
				if(x==ex&&y==ey){
					ans=h.t+1;
					return;
				}
			}
			if(vis[x][y]==0) flag=1;
		} 
		if(h.w>0&&flag==1){
			int w=h.w;
			if(h.t+1==k) w=1;
			if(h.t+1==k+k) w=0;
			q.push({h.x,h.y,h.t+1,w});
		}
	}
}
int main(){
	cin>>n>>k;
	sx=sy=3;
	ex=ey=n-2;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>a[i][j],vis[i][j]=0;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(a[i][j]=='+') mp[i][j][0]=init(i,j,0),mp[i][j][1]=init(i,j,1),mp[i][j][2]=init(i,j,2);
	bfs();
	cout<<ans;
	return 0;
}
```

提醒：不要抄袭，不要复制！

制作不易，求过。

---

## 作者：sail_with_pleasure (赞：0)

## 解题思路

求小明从起点走到终点的最短时间，显然不考虑小明胖瘦的情况下需要用到广度优先算法 BFS。

那么相对普通的 BFS，本题显然有一些特殊的地方需要处理。

普通的 BFS 需要在队列里记录某个点的 $x$ 和 $y$ 坐标。而对于本题，由于需要知道某个时刻小明的胖瘦，所以我们格外记录一个当前时刻 $t$，并将 $x,y,t$ 通过结构体存储到队列中。

对于走到的每一个点，我们计算完他此刻的大小后对于每一个小明将要走到的点都验证一下他能否向这个方向走即可，又由于我们不确定他缩小之后是否还能往这个方向走，所以我们可以让小明在原地不动也将其放入队列中。

这么做一定会有超时的风险，所以我们考虑怎么优化。

显然很多点是没必要让小明停留的，只有存在现在到达不了但缩小后能到达的点，小明才有停留的价值，所以我们通过变量 $flag$ 判断一下即可，复杂度的优化还是比较明显的，可以顺利通过此题。

## 本题代码：
```cpp
#include<bits/stdc++.h>
#define pi pair<int,int> 
#define mid (l+r)/2
#define N 1000001
#define fi first
#define se second 
#define ma make_pair
#define prq priority_queue
using namespace std;
int n,m,book[1001][1001]; 
char ss[1001][1001];
int nxt[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
struct node{
	int x,y,t;
}k;
bool check(int x,int y,int s){
	for(int i=x-s;i<=x+s;i++){
		for(int j=y-s;j<=y+s;j++){
			if(ss[i][j]=='*')return 1;
		}
	}
	return 0;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		scanf("%s",&ss[i]);
		for(int j=n;j>=1;j--){
			ss[i][j]=ss[i][j-1];
		}
	}
	queue<node> dl;
	k.x=k.y=3;
	k.t=0;
	dl.push(k);
	while(!dl.empty()){
		node z=dl.front();
		dl.pop();
		if(z.x==n-2&&z.y==n-2){
			cout<<z.t<<endl;
			break;
		}
		int flag=0;
		for(int i=0;i<=3;i++){
			int x1=z.x+nxt[i][0];
			int y1=z.y+nxt[i][1];
			int t1=z.t+1;
			int s1=2;
			if(t1>2*m)s1=0;
			else if(t1>m)s1=1;
			if(x1-s1<1||y1-s1<1||x1+s1>n||y1+s1>n||book[x1][y1]||ss[x1][y1]=='*')continue;
			if(check(x1,y1,s1)){
				flag=1;	
				continue;
			}
			book[x1][y1]=1;
			k.x=x1;
			k.y=y1;
			k.t=t1;
			dl.push(k);
		}
		if(flag==1)z.t++,dl.push(z);
	}
	return 0;
}
```

---


# [ROIR 2016] 有趣数字 (Day 2)

## 题目背景

翻译自 [ROIR 2016 D2T3](https://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-regional-2016-day2.pdf)。

## 题目描述

如果一个整数的各个数位按非递减顺序排列，我们称这个数是“有趣的”。例如，$1145,2333,1377777$ 都是“有趣的”。

给定 $L,R$，求出 $[L,R]$ 中有趣的数字的个数，对 $10^9+7$ 取模。

## 说明/提示

| 子任务 | 是否捆绑 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | 是 | $21$ | $L = 1$，$R \leq 1000$ |
| $2$ | 否 | $22$ | $1 \leq L \leq R \leq 10^{18}$ |
| $3$ | 否 | $24$ | $L = 1$，$R = 10^k$，其中 $2 \leq k \leq 100$ |
| $4$ | 否 | $33$ | $1 \leq L \leq R \leq 10^{100}$ |

## 样例 #1

### 输入

```
1 100```

### 输出

```
54```

# 题解

## 作者：txy120607 (赞：4)

PS：本人是一个初中的蒟蒻，如有问题，欢迎指出。

**1. 确定算法**

首先，~~查看算法标签~~ 看一眼要求，一个区间内的符合要求的数，那么就可以判断出用数位 DP。基于前缀和思想，用 $ \left[ 0, R \right] $ 区间内符合要求的数减去 $ \left[ 0, L - 1 \right] $ 区间内符合要求的数得到答案。

**2. 解决难点**

本题最大的难点在数据范围，第一眼过去，$1 \leq L \leq R \leq 10^{100}$。

BYD 这破题还要高精。

但再仔细查看可以看到需要取余，那么直接在计算答案的地方加上取余即可。最难的地方在输入，这里可以用字符串，但别忘了要加一点点代码实现左范围减去一。

除此之外，由于我们在计算过程中取余，在计算答案时可能会被诡异 BUG 弄得一脸茫然（输出负数），这是因为取余后可能右区间比左区间小，所以最后输出答案时还需要加上取余数再取余。

最后，使用数位 DP 的板子稍加修改，即可通过。

附上 AC 代码：



```cpp
#include <string>
#include <iostream>

#define Code using
#define by namespace 
#define Txy120607 std;

Code by Txy120607

#define int long long
const int N = 120, P = 1e9 + 7;  // P 为取余数 
int num[N]; int f[N][N];

// 初始化 DP 数组
void init() { 
    for (int i = 0; i <= 9; i++)
        f[1][i] = 1;
    for (int i = 2; i < N; i++) {
        for (int j = 0; j <= 9; j++) {
            for (int k = j; k <= 9; k++) {
                f[i][j] += f[i - 1][k]; // f[i][j] 计算方式
            }
        }
    }
}


int solve(string e) {
    int cnt = e.size();
    for (int i = cnt - 1; i >= 0; i--) { // 反转字符串
        num[cnt - i] = e[i] - '0';
    }
    int ans = 0, l = 0;
    for (int i = cnt; i >= 1; --i) { // 统计符合条件的数的个数
        int n = num[i];
        for (int j = l; j < n; j++) {
            ans += f[i][j] % P;
            ans %= P;
        }
        if (n < l) break; // 剪枝
        l = n;
        if (i == 1) ans++; // 最后一位的处理
        ans %= P; // 取余
    }
    return ans;
}

signed main() {
    init();
    string l, r;
    cin >> l >> r;
    
    int i;
    // 实现字符串 l - 1 的效果
    for (i = l.size() - 1; l[i] == '0'; i--); // 从右往左找第一个非零数字
    l[i] -= 1; // 找到的非零数字减去 1
    i++;
    for (; i < l.size(); i++) l[i] = '9'; // 剩余位数都设为 9

    // 输出 (r - l + P) % P，保证非负结果
    cout << (solve(r) - solve(l) + P) % P; 

    return 0;
}
```

---

## 作者：LinkCatTree (赞：4)

简单的数位 dp。

发现 $L \leq R \leq 10^{100}$，想到数位 dp。考虑用记忆化搜索实现，我们需要记录三个变量：当前遍历到的位置 $p$（从高位到低位），之前使用的最大数字 $x$ 和是否顶着上限 $flag$。显然若 $p$ 大于数字位数说明已经成功遍历完，返回 $1$；否则枚举所有第 $p$ 位上可能的数字并继续递归。具体实现可参照代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod=1e9+7;
const int L=105;

string s,l,r;
ll f[L][10][2];
int ln;
ll solve(int p,int x,int flag) {
	if(p>=ln) return 1;
	if(~f[p][x][flag]) return f[p][x][flag];
	int lim=flag?(s[p]-'0'):9;
	f[p][x][flag]=0;
	for(int i=x;i<=lim;i++) (f[p][x][flag]+=solve(p+1,i,flag&&(i==lim)))%=mod;
	return f[p][x][flag];
}

int main() {
	cin>>l>>r,s=r,ln=s.size();
	memset(f,-1,sizeof(f));
	ll ans=solve(0,0,1);
	memset(f,-1,sizeof(f));
	s=l,ln=s.size(),ans-=solve(0,0,1)-1;
	for(int i=0;i<s.size()-1;i++)
		if(s[i]>s[i+1]) {
			ans--; break ;
		}
	ans=(ans%mod+mod)%mod;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Ivan422 (赞：3)

发现跟板子只有符号不同，然后交上去错了。

一看数据范围，逆天 $10^{100}$。

改改，过！

我们发现，这个问题可以用数位动态规划解决。

首先，数位动态规划就是先求出 $0$ 到 $i$ 内合法数，然后使用前缀和思想，用 $f(r)-f(l-1)$ 求出 $[l,r]$ 内的答案。

我们发现，$l,r\leq 10^{100}$，太恐怖了。

怎么办？

我们考虑不要高精度，那么可以直接用 $f(r)-f(l)$，最后特判 $l$ 合法的情况。

我们考虑如何求解 $f(i)$。

这里就是数位动态规划了。

我们先把数倒过来存，方便计算。

然后我们看记忆化搜索的代码。


```cpp
int dfs(int p,int r,bool z,bool lmt){
	if(p==0)return 1;
	if(!lmt&&f[p][r]>-1)return f[p][r];
	int ans=0,mx=(lmt?c[p]:9);
	for(int i=0;i<=mx;i++){
		if(!z&&i<r)continue;
		if(z&&i==0)ans+=dfs(p-1,i,1,lmt&&(i==mx));
		else ans+=dfs(p-1,i,0,lmt&&(i==mx));
		ans%=P;
	}
	if(!lmt&&!z)f[p][r]=ans;
	return ans;
}
```

我们发现，这个东西不就是模版改的吗！~~强烈谴责我自己。~~

怎么整？

在模版中，$r$ 是记录上一位的数，那么，我们原封不动的抄下来。

首先，我们记搜的精髓就是记忆，这里用 $f_{p,r}$ 代表上一位是 $r$，搜到第 $p$ 位（高往低）的答案。

当然，答案可能为 $0$，所以要初始化成 $-2$？其实这个就是板子，我们这里可以是 $0$，因为我们只需要 $\ge$ 上一位即可。亲测可以通过。

考虑一直用的边界需要限制，加入 $lmt$ 限制。

接着我们转移。

要是某一次数还是 $0$，$z$ 限制就会是 $1$，而当已经有数，枚举的 $i<r$，状态不合法。

要是我们将 $0$ 给他转移到 $0$ 上，即 $z=1$ 且 $i=0$ 时，我们的 $r$ 将保留 $0$，$z$ 保留 $1$，$lmt$ 按照模版正常维护。

否则我们要判断第一次让数从 $0$ 变成 $i$ 的情况，如果是，那么 $r=i$，否则不变。

最后放板子和此题来对比下。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=205;
int a,b,c[N],cur,n,f[N][N];
string s;
int dfs(int p,int r,bool z,bool lmt){
	if(p==0)return 1;
	if(!lmt&&f[p][r]>-1)return f[p][r];
	int ans=0,mx=(lmt?c[p]:9);
	for(int i=0;i<=mx;i++){
		if(!z&&abs(i-r)<2)continue;
		if(z&&i==0)ans+=dfs(p-1,i,1,lmt&&(i==mx));
		else ans+=dfs(p-1,i,0,lmt&&(i==mx));
	}
	if(!lmt&&!z)f[p][r]=ans;
	return ans;
}
int func(int x){
	memset(f,-1,sizeof(f));
	s=to_string(x);
	n=s.size();
	for(int i=1;i<=n;i++)c[n-i+1]=s[i-1]-'0';
	return dfs(n,-2,1,1);
}
signed main(){
	cin>>a>>b;
	cout<<func(b)-func(a-1);
	return 0;
}
```

这题：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=205,P=1e9+7;
int c[N],cur,n,f[N][N];
string s,a,b;
int dfs(int p,int r,bool z,bool lmt){
	if(p==0)return 1;
	if(!lmt&&f[p][r]>-1)return f[p][r];
	int ans=0,mx=(lmt?c[p]:9);
	for(int i=0;i<=mx;i++){
		if(!z&&i<r)continue;
		if(z&&i==0)ans+=dfs(p-1,i,1,lmt&&(i==mx));
		else ans+=dfs(p-1,i,0,lmt&&(i==mx));
		ans%=P;
	}
	if(!lmt&&!z)f[p][r]=ans;
	return ans;
}
int func(string s){
	memset(f,-1,sizeof(f));
	n=s.size();
	for(int i=1;i<=n;i++)c[n-i+1]=s[i-1]-'0';
	return dfs(n,0,1,1);
}
int ck(string s){
	n=s.size();
	for(int i=1;i<n;i++)if(s[i]<s[i-1])return 0;
	return 1;
}
signed main(){
	cin>>a>>b;
	cout<<(func(b)-func(a)+ck(a)+P)%P;
	return 0;
}
```

~~最后再强烈谴责我自己，拿这题[题解](https://www.luogu.com.cn/article/flyhf1k3)改的。~~

---

## 作者：穼柗° (赞：3)

#### 温馨提示：在[专栏](https://www.luogu.com/article/sjp5t5pn)食用效果更佳。

记忆化搜索，数位 DP。

设有一自然数 $\text{n}$，记 $\text{n}$ 的第 $\text{p}$ 位为 $\text{n}_\text{p}(\text{p}\ge1)$。定义 $\text{dp}_\text{p,e,last}$ 表示以当前数为前缀的数中“有趣的”数的个数。其中：
- $\text{p}$ 表示当前搜索到了第 $\text{p}$ 位，$\text{p}\in[1,\log_{10}\text{n}]\cap\Z$；
- $\text{e}$ 表示当前的数是否卡了 $\text{n}$ 上限，$\text{e}\in[0,1]\cap\Z$；
- $\text{last}$ 表示上一位的数值，$\text{last}\in[0,9]\cap\Z$。

状态转移：$\text{dp}_\text{p,e,last}=\sum\limits_\text{i=last}^9 \text{dp}_{\text{p+1},\text{i}=\text{n}_\text{p}\wedge\text{e},i}$。

设 $\text{f}(\text{n})=\sum\limits_{\text{e}\in[0,1]\cap\Z,\text{last}\in[0,9]\cap\Z}\text{dp}_{\left\lfloor\log_{10}\text{n}\right\rfloor,\text{e},\text{last}}$，$\\$
则答案为 $(\text{f}(\text{R})-\text{f}(\text{L}-1))\bmod(10^9+7)$。

### Code
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#define ll long long
using namespace std;
int x,len,s[101],dp[101][2][10];
int dfs(const int p,const int e,const int last=0) { // 求 dp
	if(p==len) return 1;
	else if(dp[p][e][last]>=0) return dp[p][e][last];
	ll ret=0;
	for(int i=last;i<10;i++)
		if(e&&i>s[p]) break;
		else ret+=dfs(p+1,e&(i==s[p]),i);
	return dp[p][e][last]=ret%1000000007;
}
ll solve(const string &n) { // 求 M
	if(n=="0") return 1;
	len=n.size();
	for(int i=0;i<len;i++)
		s[i]=n[i]-'0';
	for(auto &i: dp)
		for(auto &j: i)
			for(auto &k: j)
				k=-1;
	return dfs(0,1);
}
string sub1(string s) { // 高精度字符串减1
	if(s=="1") return "0";
	vector<int> v;
	for(char c: s)
		v.push_back(c-'0');
	reverse(v.begin(),v.end());
	v[0]--;
	for(size_t i=0;i+1<v.size();i++)
		if(v[i]<0) v[i]+=10,v[i+1]--;
	while(!v[v.size()-1])
		v.pop_back();
	reverse(v.begin(),v.end());
	s="";
	for(size_t i=0;i<v.size();i++)
		s+=char(v[i]+48);
	return s;
}
int main() {
	cin.tie(nullptr)->sync_with_stdio(false),
	cout.tie(nullptr);
	string l,r;
	cin>>l>>r;
	cout<<(solve(r)-solve(sub1(l))+1000000007)%1000000007;
	return 0;
}
```

---

## 作者：xuyinxuan (赞：2)

**P11557 题解**

本题思路为数位 DP。

我们用  $step$  来表示搜索到了第  $n-i$  位（因为我是倒着来的），用  $last$  来表示上一位是几，用  $zero$  来表示目前有没有前缀 0 ，用  $lim$  表示这一位有没有限制。

于是我自信满满得交了代码，什么鬼， 43  分，于是我看了一下数据范围，我的妈呀，这数据有点太大了吧，不对，好像也没什么难的，只要换下类型就行了，于是我赶紧去改，可写着写着才发现，字符串不好做减法，幸亏我会高精度，我以为终于可以将这道绿题过了，于是我将新的代码交了上去， 94 分，我看了一下，又发现了问题，取模的时候，可能会出现负数模的情况，于是我赶紧改了一下，提交，太棒了，终于  $A$  了。

附上代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD=1e9+7;
long long w[105],tot;
long long dp[105][105][2][2];
string l,r;
long long dfs(int step,int last1,bool zero,bool lim){
	if(step==0) return !zero;
	if(dp[step][last1][zero][lim]>=0) return dp[step][last1][zero][lim];
	int up=9;
	if(lim==1) up=w[step];
	long long ans=0;
	for(int i=0;i<=up;i++){
		if(i>=last1) ans+=dfs(step-1,i,0,lim&&i==up);
		ans%=MOD;
	}
	dp[step][last1][zero][lim]=ans%MOD;
	return ans%MOD;
}
long long sol(string x){
	memset(dp,-1,sizeof(dp));
	tot=0;
	for(int i=x.size()-1;i>=0;i--) w[++tot]=x[i]-'0';
	return dfs(tot,0,1,1)%MOD;
}
int main(){
	cin>>l>>r;
	string s=l;
	if(s.back()!='0') s.back()--;
	else{
		s[s.size()-1]='9';
		for(int i=s.size()-2;i>=0;i--){
			if(s[i]>'0'){
				s[i]--;
				break;
			}else s[i]='9';
		}
	}
	
	cout<<(sol(r)-sol(s)+MOD)%MOD<<'\n';
	return 0;
}
```

**点个赞再走吧**

---

## 作者：jojo222 (赞：2)

思路和另外三篇题解思路不同，用的是有趣方法啊。~~有趣数字有个有趣方法？~~
### step 1
简化成 $0$ 到 $r$ 的有趣个数减去 $0$ 到 $l-1$ 的有趣个数。  
是怎么算的呢？举个例子 $132$：  

- 找 $0\Box\Box$ 的个数，也就是找到 $0$ 到 $9$ 中选 $2$ 个数（可以重复）的个数。
- 找 $10\Box$ 的个数，发现 $0<1$，没有贡献。
- 找 $11\Box$ 的个数，也就是找到 $1$ 到 $9$ 中选 $1$ 个数（可以重复）的个数。~~不就是 $9$ 个吗，算什么？~~
- 找 $12\Box$ 的个数，也就是找到 $2$ 到 $9$ 中选 $1$ 个数（可以重复）的个数。
- 找 $13\Box$ 的个数，发现 $2<3$，没有贡献。

大概就是这个流程。
### step 2
要求 $n$ 个数中选 $m$ 个数（可以重复）的种数是上一步留下的问题。  
有重复，是一个大难题，我们要想尽办法让它们不重复。很容易想到一个方法，第 $2$ 位加 $1$，第 $3$ 位加 $2$，……，第 $m$ 位加 $m-1$。  
现在可选的位子有 $n+m-1$ 个，还是要选 $m$ 个数字，所以它的答案就是 $\operatorname{C}^{n+m-1}_m$。
### step 3
同样套路，上一步留下了求组合的问题。  
将 $\operatorname{C}^{n+m-1}_m$ 展开，得到 $\frac{(n+m-1)!}{(n-1)!m!}$。因为要模 $10^9+7$，阶乘的除法无法用余数进行，那就要用逆元。
$$ab\equiv c\pmod p$$
$$a^{p-1}\equiv1\pmod p$$
$$a*(a^{p-2})\equiv1\pmod p$$
$$a*(a^{p-2}c)\equiv c\pmod p$$
所以，$b=a^{p-2}c$。  
快速幂就不用说了吧。
### 代码
```cpp
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;
int ans, fc[110];
string l, r;
int mypow(int x, int y)
{
    if(y == 1) return x;
    int t = mypow(x, y >> 1);
    if((y & 1) == 0) return 1ll * t * t % mod;
    return 1ll * x * t % mod * t % mod;
}
int mydiv(int x, int y)
    {return 1ll * mypow(y, mod - 2) * x % mod;}
int myc(int x, int y)
    {return mydiv(fc[x], 1ll * fc[y] * fc[x - y] % mod);}
int mymtp(int x, int y)
    {return myc(x + y - 1, y);}
int go(string s)
{
    int ans = 0, w = s.size() - 1;
    bool f = true;
    char lst = ' ';
    for(char c : s)
    {
        if(c < lst)
        {
            f = false;
            break;
        }
        for(int i = 0; i < c - '0'; i++)
        {
            if(lst > ' ' && i < lst - '0') continue;
            ans = (0ll + ans + mymtp(10 - i, w)) % mod;
        }
        lst = c, w--;
    }
    if(f) ans++;
    return ans;
}
int main()
{
    fc[0] = 1;
    for(int i = 1; i <= 109; i++)
        fc[i] = 1ll * fc[i - 1] * i % mod;
    cin >> l >> r;
    for(int i = int(l.size() - 1); i >= 0; i--)
    {
        if(l[i] == '0') l[i] = '9';
        else
        {
            l[i]--;
            break;
        }
    }
    cout << (0ll + go(r) + mod - go(l)) % mod;
	return 0;
}
```
### 题外话
闲得无聊，最大位数改 $10^5$，挨个把题解放到 IDE 里测试。  
输入为 `1 10^18360`，输出为 `816116159`。      结果……  
我是 `23ms 564kb`；  
int_stl：`30ms 17864kb`，但 `463575037`；  
\_3Zinc_：`41ms 16996kb`；  
3_14：`MLE`。

---

## 作者：lhs_chris (赞：1)

# 思路
记忆化搜索。很明显这题的输入一定是字符串。那么我们还需要写一个字符串减法，来计算左端点减一的值。

题目要求计算区间 $l \sim r$ 内有趣的数字的数量。那么 $1 \sim r$ 的有趣数字的数量减去 $1 \sim l-1$ 的数量就是区间内有趣数字的数量。

那我们可以用记忆化搜索的方式就行计算。记忆化搜索只需要三个参数。当前构造到的位置 $now$，上一个数字 $last$，以及当前构造的数字是否顶格 $l$。

使用 $last$ 参数来判断当前数字是否按非递减顺序排列。使用 $l$ 参数来判断当前数位上所能取最大值。

因为记忆化搜索是在每一位上构造符合要求的数字，所以当数字构造完毕后一定也符合题目要求，直接返回 $1$ 即可。

不要忘记取模。


# 代码
```cpp#include<bits/stdc++.h>
#include<cstring>
#include<queue>
#include<set>
#include<stack>
#include<vector>
#include<map>
#define ll long long
#define lhs printf("\n");
using namespace std;
const int N=3e5+10;
const int M=1e9+7;
const int inf=0x3f3f3f3f;
string l,r,a;
int a1[N],a2[N],ans[N];
ll dp[114][20][5];
string jian(string s1,string s2)
{
	string h;
	for(int i=0;i<s1.size();i++)
	{
		a1[s1.size()-1-i]=s1[i]-'0';
	}
	for(int i=0;i<s2.size();i++)
	{
		a2[s2.size()-1-i]=s2[i]-'0';
	}
	for(int i=0;i<max(s1.size(),s2.size());i++)
	{
		ans[i]=a1[i]-a2[i];
	}
	for(int i=0;i<max(s1.size(),s1.size());i++)
	{
		if (ans[i]<0)
		{
			ans[i]+=10;
			ans[i+1]--;
		}
	}
	int k=N-1;
	while((!ans[k]) and  k>0)
	{
		k--;	
	}
	for(int i=k;i>=0;i--)
	{
		char x=char(ans[i]+48);
		h+=x;
	}
	return h;
}
ll dfs(int now,int last,int l)
{
	if(now==a.size())
	{
		return 1;
	}
	if(dp[now][last][l]!=-1)
	{
		return dp[now][last][l];
	}
	int k=int(a[now])-48;
	int b=l ? k : 9;
	ll ans=0;
	for(int i=0;i<=b;i++)
	{
		if(i>=last)
		{
			ans+=dfs(now+1,i,l and i==b);
			ans%=M;
		}
	} 
	return dp[now][last][l]=ans;
}
ll solve(string x)
{
	memset(dp,-1,sizeof dp);
	a.clear();
	a+=x;
	return dfs(0,0,1);
} 
int main()
{
	cin>>l>>r;
	cout<<(solve(r)-solve(jian(l,"1"))+M)%M;//减法取模要+MOD
	return 0;
}

```

---

## 作者：lam_dyr (赞：1)

首先注意到 $L,R \le 10^{100}$。

直接枚举显然不可行，而**有趣的数字**的定义暗示我们从数位的角度进行考虑。

## 思路：数位 dp

我们可以将问题分解为：

- 计算小于等于 $x$ 的有趣数字个数。
- 通过这种方法计算出 $[L,R]$ 内有趣数字的个数：$cnt(R)-cnt(L-1)$。

这样，我们就把一个大范围的统计问题，分解成了多个子问题，可以使用动态规划解决。

## 实现过程

为了避免重复计算。我们可以从数字的最高位开始，逐位确定数字。~~读者可以思考这样做的原因 qaq~~

状态设计和正常的数位 dp 差不多，`dp[pos][pre]` 表示从第 $pos$ 位开始（从高到低，从 $0$ 开始），前一位数字是 $pre$ 时，能构成的有趣数字个数。

考虑如何转移。

在确定当前位数字的时候，我们需要保证当前位数字大于等于前一位数字，状态转移的过程就是枚举当前位可能的数字，然后递归地计算下一位的状态。

为了避免重复计算，我们可以用记忆化的方式，遇到相同的状态直接返回结果。

---

注意一点：在搜索过程中，需要考虑是否受到原始数字的限制。例如，在计算小于等于 $123$ 的有趣的数字个数时，如果当前位是十位，且上一位是 $1$，那么当前位最大只能取到 $2$。

具体细节见代码。

## Code

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int MOD=1000000007;
const int MAXN=105;
int dp[MAXN][10];
char s[MAXN];
int solve(int p,int pre,bool lim){//lim记录原始数字的限制 
    if(p==-1)return 1;
    if(!lim&&dp[p][pre]!=-1)return dp[p][pre];//记忆化 
    int up=lim?(s[p]-'0'):9;//当前位数字的最大值，如果受到限制，则只能取到当前位的值，否则可以取到9
    int ans=0;
    for(int i=0;i<=up;++i){
        if(i>=pre)//满足条件，往后转移 
            ans=(ans+solve(p-1,i,lim&&(i==up)))%MOD;
    }
    if(!lim)dp[p][pre]=ans;
    return ans;
}
int calc(char *str){
    int len=strlen(str);
    for(int i=0;i<len;++i)s[i]=str[len-1-i];//从高位到低位处理 
    memset(dp,-1,sizeof(dp));
    return solve(len-1,0,true);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    char l[MAXN],r[MAXN];
    cin>>l>>r;
    int ans=(calc(r)-calc(l)+MOD)%MOD;
    bool ok=true;
    int len=strlen(l);
    for(int i=1;i<len;++i){
        if(l[i]<l[i-1]){
            ok=false;
            break;
        }
    }
    if(ok)ans=(ans+1)%MOD;//如果L本身是有趣的数字，结果加1 
    cout<<ans;
    return 0;
}

```

---

## 作者：Little_duck_GGG (赞：1)

### 题目意思。
这道题题意较为简单，就是找一段范围的有趣数，如果此数为一个有趣数，则此数的各个数位为一个**非下降序列**。
### 题目思路。
首先我们想到，可以用最传统，朴素的暴力搜索。用四个参数来实现。第一个是当前到达的位置。第二个，是上一个数。第三个，则是是否顶格，意思就是当前位置以前的数位是否都是**原数位**。第四个则是当前算的数。有了这四个条件，暴力的代码很快就有了。

但先别急，还有一个坑点。那就是输入时必须按字符串输入，但是算的是一个闭合区间，所以我们可以**计算起始点是否为有趣数，如果是，则在答案加一**。
### 给出暴力代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
string l;
string r;
int op;
long long dp[205][15][3],mod=1e9+7;
long long dfs(int x,int last,int f,string g)//四个参数
{
	if(x==g.size()) return 1;//如果能到达重点，返回1种情况
	int ma=0;
	if(f==0) ma=int(g[x]-'0');//如果前面"顶格"，则这个数位最高只能为原数位的数字。
	else ma=9;//否则为9，任选。
	long long rl=0;
	for(int i=last;i<=ma;i++)//要大于等于上次所选数位。
	{
		rl+=dfs(x+1,i,f||(i!=ma),g);//调用
		rl%=mod;//取模
	}
	return rl;//返回
}
int ka;
int main()
{
	cin>>l>>r;
	int fp=0;
	for(int i=1;i<l.size();i++)//判断是否为有趣数
	{
		if(l[i]<l[i-1])
		{
			fp=1;
			break;
		}
	}
	if(fp==0) ka=1;
	else ka=0;
	memset(dp,-1,sizeof(dp));
	long long ans1=dfs(0,0,0,r)%mod;
	memset(dp,-1,sizeof(dp));
	long long ans2=dfs(0,0,0,l)%mod;
	cout<<(ans1-ans2+mod+ka)%mod;计算0-R与1-L有趣数的个数，并相减，最后看看L是否为有趣数，加上它。
	return 0;
}
```
 如我所料，超时了，因为太暴力了。
 ### 下面讲解一下优化方法。
 我们可以用一个三维数组去标记此时的状态，因为在搜索过程中，有许多时候会**算重**，这样可以使**时间大大降低**。
 ### 给出优化代码。
 
前面介绍过的不在介绍。
```cpp
#include<bits/stdc++.h>
using namespace std;
string l;
string r;
int op;
long long dp[205][15][3],mod=1e9+7;
long long dfs(int x,int last,int f,string g)
{
	if(x==g.size()) return 1;
	if(dp[x][last][f]!=-1) return dp[x][last][f];//当此状态已出现过时，直接返回此状态的答案。
	int ma=0;
	if(f==0) ma=int(g[x]-'0');
	else ma=9;
	long long rl=0;
	for(int i=last;i<=ma;i++)
	{
		rl+=dfs(x+1,i,f||(i!=ma),g);
		rl%=mod;
	}
	return dp[x][last][f]=rl%mod;//记录此状态的答案
}
int ka;
int main()
{
	cin>>l>>r;
	int fp=0;
	for(int i=1;i<l.size();i++)
	{
		if(l[i]<l[i-1])
		{
			fp=1;
			break;
		}
	}
	if(fp==0) ka=1;
	else ka=0;
	memset(dp,-1,sizeof(dp));
	long long ans1=dfs(0,0,0,r)%mod;
	memset(dp,-1,sizeof(dp));
	long long ans2=dfs(0,0,0,l)%mod;
	cout<<(ans1-ans2+mod+ka)%mod;
	return 0;
}
```
#### 短短两句话，竟让程序的时间复杂度大大降低，十分巧妙，但也是一种十分常用的方法。
感谢观看。

---

## 作者：3_14 (赞：1)

[**题目传送门**](https://www.luogu.com.cn/problem/P11557)

# 思路

我们需要定义一个状态 $dp\left [pos\right ]\left [prev\right ]\left [tmp\right ]$，其中：$pos$ 表示当前处理的位数；$prev$ 表示前一个数字的值；$tmp$ 表示当前数字是否紧贴上限（即是否受到 $R$ 的限制）。

定义一个递归函数 `solve(pos,prev,tmp,num)`，其中 $num$ 是当前构建的数字。在递归过程中，我们需要确保当前数字的每一位都大于或等于前一位。

递归的边界条件是当 $pos$ 达到数字的长度时，说明我们已经构建了一个有效的“有趣”数字，返回 $1$，如果当前数字超过了 $R$，则返回 $0$。

注意需要对结果取模 $10^9 + 7$。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
#define Made return
#define by 0
#define _3_14 ;
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e2+5,MOD=1e9+7;
int dp[MAX][10][2];
string L,R;
int solve(int pos,int prev,int tmp,string num){
    if(pos==num.size())return 1;
    if(dp[pos][prev][tmp]!=-1)return dp[pos][prev][tmp];
    int cnt=tmp?(num[pos]-'0'):9,res=0;
    for(int i=prev;i<=cnt;i++)
        res=(res+solve(pos+1,i,tmp&&(i==cnt),num))%MOD;
    return dp[pos][prev][tmp]=res;
}
int cN(string num){
    memset(dp,-1,sizeof(dp));
    return solve(0,0,1,num);
}
int main(){
    cin>>L>>R;
    int ansR=cN(R),ansL=cN(L);
    bool flag=true;
    for(int i=1;i<L.size();i++){
        if(L[i]<L[i-1]){
            flag=false;
            break;
        }
    }
    cout<<(ansR-ansL+flag+MOD)%MOD<<'\n';
	Made by _3_14
}
```

[**AC 记录**](https://www.luogu.com.cn/record/197639951)

---

## 作者：Naoxiaoyu (赞：0)

# 思路
一道**数位DP**模版题。\
我们可以定义数组 $dp_{len,last,x}$，其中 $len$ 表示排查到的数位，$last$ 表示上一位的数字，$x$ 有两种取值，$1$ 表示到达了上限，$0$ 表示没有到达上限，剩下的就是简单普通的数位DP，注意取模即可。

# code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=1e9+7;
char s[1010],t[1010];
int num[1010];
ll dp[1010][10][2];
ll dfs(int len,int last,int x)
{
	int m=num[len];
	if(!len) return 1;
	if(~dp[len][last][x]) return dp[len][last][x];
	if(!x) m=9;
	ll res=0;
	for(int i=last;i<=m;i++)
	{
		res+=dfs(len-1,i,x&&(i==m));
		res%=mod;
	}
	dp[len][last][x]=res%mod;
	return res;
}
ll solve(char s[])
{
	int len=strlen(s);
	for(int i=0;i<=len-1;i++)
	{
		num[len-i]=s[i]-'0';
	}
	memset(dp,-1,sizeof(dp));
	return dfs(len,0,1);
}
int main()
{
	scanf("%s",s);
	scanf("%s",t);
	int flag=1;
	int len=strlen(s);
	for(int i=0;i<=len-2;i++)
	{
		if(s[i]>s[i+1])
		{
			flag=0;
			break;
		}
	}
	printf("%lld",(solve(t)-solve(s)+flag+mod)%mod);
	return 0;
}
```

---

## 作者：yanbinmu (赞：0)

观察题目不难发现 $1 \leq L \leq R \leq 10^{100}$ 。

这启发我们时间复杂度可能会和位数有关，否则就炸了……

~~当然也有可能是个什么 $\log$ 的……~~

我们考虑如果按位枚举每一位的数，那么时间复杂度将是 $O(\text{答案})$ 的。但是如果不考虑上下界，我们就可以将某一步的答案记录下来。

比如我如果令 `f[a][b]` 为枚举到第 $\text{a}$ 位，前一位是 $\text{b}$，后面几位的方案数，那如果有相同的情况出现时，我就可以直接用了。

举个例子，比如这两个后四位的方案数是一样的：

- `1234_ _ _ _`

- `2334_ _ _ _`

那我们怎么处理有上下界？

我们先考虑有一条上界（如果可行，那我们可以将上下界转化为一个 $[0, \text{r}]$ 的方案数减去 $[0, \text{l})$ 的方案数)

我们可以记录当前的数是否卡在上界, 如果前面不是所有位都卡在上界上，那我就可以随便放；如果卡在上界上，那我就需要枚举所有的数。

那这个时间复杂度为什么是对的？

首先我没有处理出来记忆化的内容时，我确实要枚举到底层（最低位），但某一位的处理出来了后，前一位的复杂度就只有 $O(10)$ 。

考虑如果卡在上界上，这个上界只有一个。如果不在上界上了，那就可以直接用记忆好的答案了。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int Mod = 1e9 + 7;
int f[105][105], digit[105];
int dfs(int pos,int lead, int pre, int limit) {
	if(pos == 0) return 1;
	if(!limit && f[pos][pre] != -1 && !lead) return f[pos][pre];
	int up = limit ? digit[pos] : 9;
	int cnt = 0; 
	for(int i = pre;i <= up;i ++ ) {
		cnt += dfs(pos - 1, lead && i == 0, i, limit && (i == up));
        cnt %= Mod;
	}
	if(!limit && !lead) f[pos][pre] = cnt;
	return cnt % Mod;
}
int sep(string x){
	memset(f, -1, sizeof(f));
	memset(digit, 0, sizeof(digit));
	int tot = x.size(), cnt = 0;
	for(int i = tot - 1;i >= 0;i -- ) {
		digit[ ++ cnt] = x[i] - '0';
	}
	return dfs(cnt, 1, 0, 1);
}
signed main() {
    string l, r;
    cin >> l >> r;
    int siz = l.size(), flag = 1;
    for(int i = 1;i < siz;i ++ ) {
        if(l[i] < l[i - 1]) {
            flag = 0;
            break;
        }
    }
    cout << (sep(r) - sep(l) + flag + Mod) % Mod;
	return 0;
}
```

---

## 作者：linjinkun (赞：0)

~~三篇题解讲的都太粗略了。~~

考虑数位 dp，也就是记忆化搜索，设置一个搜索函数 $dfs$，有三个参数，一个是当前位数，表示搜到哪一位了，一个是从第一位到上一个位数是否全部顶上界，从第一位到上一位全部顶上界的意思是从第一位到上一位是否和对应的 $a$ 的数位上的数相同（$a$ 指的是搜索的字符串），第三个参数是表示上一个数是多少。

同时我们发现可以记忆化，于是设置一个三维的数组 $f_{i,j,k}$，搜索完后就记录，如果发现当前这一位是已经搜索过的，那就直接返回答案。

附上搜索代码：
```cpp
int dfs(int x,int ding,int d)
{
	if(x == a.size())//到了最后一位
	{
		return 1;
	}
	if(f[x][ding][d]!=-1)//已经搜索过
	{
		return f[x][ding][d];//直接返回
	}
	int ans = 0;
	for(int i = d;i<=(ding?a[x]-'0':9);i++)//如果一直顶了上界，这一位也只能到a[x]，如果没有一直顶，那就可以到最大的一位数9
	{
		int dingg = ding&&i == a[x]-'0';//计算是否一直顶上界
		ans = (ans+dfs(x+1,dingg,i))%mod;//加和
	}
	return f[x][ding][d] = ans;//记录
}
```
然后重头戏来了，按照理论，我们应该使用搜索 $r$ 的结果减去搜索 $l-1$ 的结果，再 $\bmod (10^9+7)$，但是 $l$ 高达 $10^{100}$，无法使用变量存储，写高精度计算 $l-1$ 又太麻烦，于是巧妙转化，换成求搜索 $r$ 的减去搜索 $l$ 的加上 $l$ 是否为“有趣数”。转化完之后代码就好写了（主函数）：
```cpp
int main()
{
	int ans = 0;
	string l,r;
	cin >> l >> r;
	a = r;
	memset(f,-1,sizeof(f));//清空
	ans = (ans+dfs(0,1,0))%mod;//加上搜索r的，取模
	a = l;
	memset(f,-1,sizeof(f));
	ans = (ans-dfs(0,1,0)+mod)%mod;//减去搜索l的，取模
	int flag = 1;//算一下l是否为“有趣数”
	for(int i = 0;i<a.size();i++)
	{
		if(a[i-1]>a[i])
		{
			flag = 0;
			break;
		}
	}
	ans = (ans+flag)%mod;//加上，取模
	printf("%d",ans);
    return 0;
}
```
总代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
string a;
int f[105][2][10];
int dfs(int x,int ding,int d)
{
	if(x == a.size())
	{
		return 1;
	}
	if(f[x][ding][d]!=-1)
	{
		return f[x][ding][d];
	}
	int ans = 0;
	for(int i = d;i<=(ding?a[x]-'0':9);i++)
	{
		int dingg = ding&&i == a[x]-'0';
		ans = (ans+dfs(x+1,dingg,i))%mod;
	}
	return f[x][ding][d] = ans;
}
int main()
{
	int ans = 0;
	string l,r;
	cin >> l >> r;
	a = r;
	memset(f,-1,sizeof(f));
	ans = (ans+dfs(0,1,0))%mod;
	a = l;
	memset(f,-1,sizeof(f));
	ans = (ans-dfs(0,1,0)+mod)%mod;
	int flag = 1;
	for(int i = 0;i<a.size();i++)
	{
		if(a[i-1]>a[i])
		{
			flag = 0;
			break;
		}
	}
	ans = (ans+flag)%mod;
	printf("%d",ans);
    return 0;
}
```

---

## 作者：LostKeyToReach (赞：0)

简单数位 DP。

令 $dp_{i, j, 0/1}$ 表示填充到第 $i$ 位，上一个解决的数位为 $j$，是否被右端点数的数位限制的方案数，那么显而易见地，我们转移时直接枚举大于等于 $j$ 的数位即可。

注意我们的答案为 $f(r) - f(l) + c(l)$，其中 $f(x)$ 为 $1 \sim x$ 的答案，$c(x)$ 表示 $x$ 是否为有趣的数。

参考代码如下：

```cpp
#include <bits/stdc++.h>

#define int long long

constexpr int N = 1e5 + 6, P = 1e9 + 7;

void solve() {
    std::string l, r;
    std::cin >> l >> r;
    auto sol = [&](std::string s) -> int {
        int dp[105][10][2];
        memset(dp, -1, sizeof dp);
        auto dfs = [&](auto &&self, int pos, int lst, int tight) -> int {
            if (pos == (int)s.size()) return 1;
            if (dp[pos][lst][tight] != -1) return dp[pos][lst][tight];
            int lim = tight ? s[pos] - '0' : 9;
            int ans = 0;
            for (int i = lst; i <= lim; ++i) {
                ans = (ans + self(self, pos + 1, i, tight && (i == lim))) % P;
            }
            return dp[pos][lst][tight] = ans;
        };
        return dfs(dfs, 0, 0, 1);
    };
    int res = (sol(r) - sol(l) + 1 + P) % P;
    for (int i = 1; i < (int)l.size(); ++i) {
        if (l[i] < l[i - 1]) {
            res --;
            break;
        }
    }
    std::cout << (res + P) % P;
}

int32_t main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0), std::cout.tie(0);

  int t;
  // std::cin >> t;
  t = 1;

  while (t--) {
    solve();
  }

  return 0;
}
```

---


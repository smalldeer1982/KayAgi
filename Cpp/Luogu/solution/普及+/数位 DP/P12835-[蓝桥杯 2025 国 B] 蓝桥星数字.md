# [蓝桥杯 2025 国 B] 蓝桥星数字

## 题目描述

地球上，我们习惯用十进制数字来记录万物，从个位、十位，逐级向上构成了我们熟悉的自然数体系。

然而，在遥远的蓝桥星，数字的排列和解读方式却与我们截然不同。蓝桥星人并不单纯地以数值大小来衡量一个数字，他们更注重数字内部蕴含的“节奏感”。因此，对他们而言，任何一个有效的数字，其从左到右每一位上的数字奇偶性都必须是交替出现的。

例如，对于 10 这个数字，其十位是奇数 1，个位是偶数 0，呈现奇偶交替，因此 10 是个有效的数字。而对于 13 这个数字，其十位是奇数 1，个位也是奇数 3，不符合奇偶交替的条件，因此 13 不是个有效的数字。

根据这个规则，蓝桥星的数字序列从 10 开始，依次为 $10, 12, 14, 16, 18, 21, 23, 25, 27, 29, 30, \ldots$。

只不过，随着文明的发展，蓝桥星人需要一种方法，来快速找到第 $N$ 个符合这种奇偶交替规则的数字，以满足其日益增长的数字处理需求。现在，请你帮助蓝桥星人，编写程序找出并输出第 $N$ 个符合奇偶交替规则的数字。


## 说明/提示

**【评测用例规模与约定】**

对于 20% 的评测用例，$1 \leq N \leq 10^5$。

对于 100% 的评测用例，$1 \leq N \leq 10^{12}$。

## 样例 #1

### 输入

```
1```

### 输出

```
10```

## 样例 #2

### 输入

```
11```

### 输出

```
30```

# 题解

## 作者：vegetableYe (赞：7)

### 第十六届蓝桥杯CB国赛 F-蓝桥星数字

当 $n$ 很小时没啥说的，直接模拟即可，但需要注意的是，经笔者在赛场上的测试，本题 $20\%$ 的分数纯靠模拟疑似是拿不到满分的，也就是说 $n=10^5$ 这个量级的时候，一两秒钟已经跑不出来答案了，因此本题直接模拟的分数应该是小于 $20\%$ 的，具体拿多少和数据有关。

（我猜可能甚至 $0$ 分，因为我猜蓝桥杯的出题人为了偷懒，这一段部分分显然没有认真思考确定应该给到多大的范围，因此造数据的时候他大概率只是在 $[1,10^5]$ 这个区间内随机了几组数据，而直接随机的话大概率是更偏向 $10^5$ 的，也就是大概率一秒钟跑不出来的）。

（蓝桥杯并不是第一次干这种事情了）

##### 模拟代码：

```cpp
bool good(int x) {
	string s = to_string(x);
	bool f = (s[0] - '0') & 1;
	for(int i = 1; i < s.size(); i++) {
		int u = (s[i] - '0') & 1;
		if(f ^ u) {
			f ^= 1;
		} else {
			return 0;
		}
	}
	return 1;
}
int ans = 0;
for(int i = 10; ; i++) {
	if(good(i)) {
		ans++;
	}
	if(ans == x) {
		ans = i;
		break;
	}
}
cout << ans << endl;
```

##### 正解（前置知识：数位 $dp$。）

本题应该是有很智慧的递推做法的，但笔者在赛场上没想到，于是想到了一个无脑但稳对的做法。

像这种：求第 $k$ 个合法的数字，然后 "合法" 的定义和数字的数位有一定关系的题，我们都可以去考虑：

二分答案+数位 $dp$ 的做法。

我们二分答案，假设题目求的第 $n$ 大 "蓝桥星数字" 是 $k$（也就是答案），那么我们的问题就转化成了，求 $[1,k]$ 有多少个正整数是 "蓝桥星数字"，只要这个个数不小于 $n$，就说明答案可能可以缩小 $(\rm r=mid)$，否则答案肯定更大 $(\rm l=mid+1)$。

而数位 $dp$ 我们需要记录什么信息，首先因为要考虑每一位是否奇偶交替，因此我们必须记录上一位填的数的奇偶性，同时注意到 "蓝桥星数字" 至少是两位数，因此我们还得记录一个当前数字的数位个数，但这里我们只需要把数位个数和 $2$ 取一个 $\min$ 即可。

因此我们的 $dp$ 可以设计成：$dp_{i,lst,cnt}$ 表示当前填到第 $i$ 位，上一位填的奇偶性是 $lst$，目前填了 $cnt$ 个数位的总数字个数。（$cnt$ 要和 $2$ 取 $\min$，因为只要 $cnt \geq 2$ 就是合法的。）

最后需要注意的是，二分的下界要设为 $10$，而上界最好直接设置为 $4\times 10^{18}$，$dp$ 也稍微开大点。

##### 笔者赛时的代码：

```cpp
int x;
string s;
int dp[22][2][3];

int dfs(int u, int lst, int cnt, bool limit, bool lead0) {
	if(u == s.size()) {
		if(!lead0 && cnt > 1) {
			return 1;
		}
		return 0;
	}
	if(!lead0 && !limit && dp[u][lst][cnt] != -1) {
		return dp[u][lst][cnt];
	}
	
	int ans = 0;
	int up = (limit ? s[u] - '0' : 9);
	for(int i = 0; i <= up; i++) {
		int now = i & 1;
		if(lst == -1 || (now ^ lst)) {
			if(lead0 && (i == 0)) {
				ans += dfs(u + 1, -1, cnt, limit & (i == up), 1);
			} else {
				ans += dfs(u + 1, now, min(2LL, cnt + 1), limit & (i == up), lead0 & (i == 0));
			}
		}
	}
	
	return dp[u][lst][cnt] = ans;
}

bool check(int r) {
	s = to_string(r);
	memset(dp, -1, sizeof dp);
	return dfs(0, -1, 0, 1, 1) >= x;
}

void solve() {
	cin >> x;
	int l = 10, r = 4e18; // r 可以调整为 10^18，赛时的笔者稳妥起见直接取到能取的最大值了
	while(l < r) {
		int mid = (l + r) / 2;
		if(check(mid)) r = mid;
		else l = mid + 1;
	}
	
	cout << l << endl;
}
```

时间复杂度：$O(\log(X) \times \log(X) \times 10 \times 2 \times 3)$。（其中 $X=10^{18}$，第一个 $\log$ 来源于二分答案，第二个来源于数位 $dp$ 的第一维状态，$10$ 来源于数位 $dp$ 转移时枚举填的数字有 $10$ 个，$2$ 和 $3$ 是数位 $dp$ 的 $lst$ 和 $cnt$ 的值域。）

---

## 作者：XVETV6 (赞：5)

题意：求第 $n$ 个奇偶位相间的十进制数。

暴力打表可以发现规律还是很明显的：

1. 最高位可以取 $1$~$9$。
2. 其他位$0->2->4->6->8$ 或 $1->3->5->7->9$ 就向前进位。
   
规律很简单，可以用类似试填法求第 $k$ 个排列的过程直接构造第 $n$ 个数。最高位比较特殊，所以从最高位开始。\
试填法的精髓就是试着在这一位填一个数，看后面的数位情况够不够 $n$ 个，如果不够说明这一位小了,增大它继续试；如果够了，说明这一位就是它，减去低位的情况数，继续填低位。这个过程要求我们能快速求第 $i$ 位填 $d$ 的情况下$[0,i-1]$位符合要求方案数。\
这是显然的，无论第 $i$ 位填了啥，$[0,i-1]$ 中每一位就5种选择，所以方案数就是 $5^i$。 \
接下来确定第 $n$ 个数一共有多少位就行了。直接求不好求。不过考虑到低位的方案数指数增加，位数应该不会很大，所以转而求 $m$ 位蓝桥星数字有几个。最高位 $9$ 种，其他位 $5^{m-1}$ 种，一共有 $9\times5^{m-1}$ 个。注意求的过程中要减去小于 $m$ 位的方案数（相当于试位数）。
```cpp
#include <iostream>
using namespace std;
const int ds[2][5] = { {1,3,5,7,9,},{0,2,4,6,8} };
int main() {
	long long x; cin >> x;
	long long d = 5;// 低位的方案数
	int di = 2;
	while (9 * d < x) { // 求位数，顺便剪掉小于 m 位的方案数
		x -= 9 * d;
		d *= 5;
		++di;
	}
	long long ans = 0;
	for (int i = 1; i <= 9; ++i) { // 最高位
		if (d < x) x -= d;
		else {
			ans = i; --di;  d /= 5;  break;
		}
	}
	while (di) {// 其他位
		int pre = ans % 2; // 前一位的奇偶
		for(int i = 0 + (pre == 0);i < 10;i += 2)
			if (d < x) x -= d;
			else {
				ans = ans * 10 + i; --di; d /= 5; break;
			}
	}
	cout << ans << ' ';
}
```
也可以直接求出第 $i$ 位填啥：
```cpp
#include <iostream>
using namespace std;
const int ds[2][5] = { {1,3,5,7,9,},{0,2,4,6,8} };
int main() {
	long long x; cin >> x; --x;// 注意 --x 把第 x 个转化为下标 x 的数，方便取模
	long long d = 5; // 低位的方案数
	while (9 * d <= x) {
		x -= 9 * d;
		d *= 5;
	}
	long long ans = x / d + 1; x %= d; d /= 5;
	while(d) {
		int t = x / d; x %= d; d /= 5;
		int pre = ans % 2;
		ans = ans * 10 + ds[pre][t];
	};
	cout << ans << ' ';
}
```

---

## 作者：wuzhexu (赞：2)

## 思路解析

### 导入

~~如果您和我一样喜欢看标签，你就知道这是数位 DP 对吧……~~

我们通过观察，发现本题 $N$ 高达 $10^{12}$，再看眼时间理解下题意，很明显已经确定是数位 DP 了。

### 思路

如何高效查询？

如果您直接遍历，那么当您遍历到第 $10^{12}$ 个数的时候，地球已经没了……

嗯就是这样，所以换一个思路，借用数位 DP 的思想，设一个 $x$，找小于等于 $x$ 的蓝桥星数字有多少个。

您一定想到了一种高效查询的算法，观察发现蓝桥星数字貌似是单调递增的！

### 总结

好整理一下，本题代码两部分组成，数位 DP 和二分查找。

### 数位 DP

数位 DP 的三维状态设计，第一维是处理到第 $i$ 位数字，第二维这里代表这一位的奇偶性，第三维代表当前填数的时候受不受 $x$ 的约束（即前 $i$ 位是否相同）。

然后，分两种情况讨论。

1. 观察样例或打表也可以，不难看出，一个合法的蓝桥星数字第一位有 $9$ 种选择，后续每位 $5$ 种选择（即与上一位奇偶性不同的 $5$ 个数字）。
直接累加所有位数小于 $x$ 的位数的蓝桥星数字数量，这一类不用考虑 $x$ 的大小约束问题。

2. 填充受 $x$ 约束的 DP 表。先初始化，然后处理第一位上的数字。明确最高位不为 $0$。

```cpp
for(int i=1; i<=9; i++){ 
    if(i < val[1]){
        dp[1][i%2][1]++;//无约束
    } else if(i == val[1]){
        dp[1][i%2][0]++;  //受约束
    }
}
```

3. 然后是最核心的部分，填充 $2$ 到 $vcnt$ 位的数字。
若前一位受约束，当前位最大为 $x$ 的第 $i$ 位 $val[i]$；否则到 $9$。

4. 注意填数的时候保证前一位和本位奇偶性不同。

5. 更新约束状态。
- 若前一位无约束，当前位无论取何值，新状态仍无约束。
- 若前一位受约束，当前位小于上限时 $val[i]$ 新状态无约束，等于时受约束。

6. 将前一位的数量 $dp[i-1][j][e]$ 加到当前位的状态中。自此填数部分彻底完成。

7. 当所有 $vcnt$ 位数字都处理完后，累加所有可能状态的有效数字数量，得到位数等于 $x$ 的蓝桥星数字总数。

8. 把第七步中的数量累加到总计数变量中，数位 DP 部分就完成了。

### 二分查找

显然瞪眼法可知当前 $mid$ 的蓝桥星个数等于 $N$ 时，就是答案。

## 代码

又到了放代码的时候……

### 代码快速幂和三目版，可读性稍差……

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<string>
#include<string.h>
#include<stdio.h>
#include<vector>
#include<queue>

#define int long long

#define N 100001

using namespace std;

int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		(c=='-')&&(f=-1);
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}

int dp[50][2][2]; 

int val[50],vcnt;


int ksm(int k){
	
	int res=1,ds=5;
	
	while(k){
		
		(k&1)&&(res*=ds); 
		
		ds*=ds;
		
		k>>=1;
	} 
	return res;
}

int f(int x){
	
	if(x<10) return 0;
	
	vcnt=0;
	
	int t=x;
	
	while(t){
		
		val[++vcnt]=t%10;
		
		t/=10;
	}
	for(int i=1;i+i<=vcnt;i++)
		
		swap(val[i],val[vcnt-i+1]);
	
	int sum=0;
	
	for(int l=2;l<vcnt;l++){
		
		sum+=9*5*ksm(l-2);
	}
	
	memset(dp,0,sizeof(dp));
	
	for(int i=1;i<=9;i++){
		
		(i<val[1])?dp[1][i%2][1]++:(i==val[1]?dp[1][i%2][0]++:0);
	}
	
	for(int i=2;i<=vcnt;i++){
		
		for(int j=0;j<=1;j++){
			
			for(int e=0;e<=1;e++){
				
				if(!dp[i-1][j][e]) continue; 
				
				int up=e?9:val[i];
				
				for(int w=0;w<=up;w++){
					
					if((w&1)==j) continue; 
					
					int x=e?1:((w<up)?1:0); 
					
					dp[i][w&1][x]+=dp[i-1][j][e]; 
				} 
			}
		} 
	}
	
	sum+=dp[vcnt][0][0]+dp[vcnt][0][1]+dp[vcnt][1][0]+dp[vcnt][1][1];
	
	return sum;
}

int find(int n){
	
	int l=10,r=1e18;
	
	while(l<r){
		
		int mid=l+(r-l)/2;
		
		int sum=f(mid);
		
		sum<n?l=mid+1:r=mid; 
		
	}
	
	return l;
}

signed main(){
	
	int n;
	
	cin>>n;
	
	cout<<find(n)<<endl;
	
	return 0;
}

```

### 代码普通版性能略差

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<string>
#include<string.h>
#include<stdio.h>
#include<vector>
#include<queue>
#define int long long

#define N 100001

using namespace std;

int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}

int dp[50][2][2]; 

int val[50],vcnt;

int f(int x){
	
	if(x<10) return 0;
	
	vcnt=0;
	
	int t=x;
	
	while(t){
		
		val[++vcnt]=t%10;
		t/=10;
		
	}
	
	for(int i=1;i+i<=vcnt;i++)
		swap(val[i],val[vcnt-i+1]);
		
	int sum=0;
	
	for(int l=2;l<vcnt;l++){
		
		sum+=9*5*pow(5,l-2);
		
	}
	
	memset(dp,0,sizeof(dp));
	
	for(int i=1;i<=9;i++){
		
		
		if(i<val[1]) dp[1][i%2][1]++;
		
		else if(i==val[1]){
			
			dp[1][i%2][0]++;
			
		}
		
	}
	
	for(int i=2;i<=vcnt;i++){
		
		for(int j=0;j<=1;j++){
			for(int e=0;e<=1;e++){
				if(dp[i-1][j][e]==0) continue;
				
				int up=e?9:val[i];
				
				for(int w=0;w<=up;w++){
					
					if(w%2==j) continue;
					
					int x=e?1:(w<up?1:0);
					
					dp[i][w%2][x]+=dp[i-1][j][e];
					
				} 
			}
			
		} 
		
	}
	
	sum+=dp[vcnt][0][0]+dp[vcnt][0][1]+dp[vcnt][1][0]+dp[vcnt][1][1];
	
	return sum;
	
}

int find(int n){
	
	int l=10,r=1e18;
	
	while(l<r){
		
		int mid=l+(r-l)/2;
		int sum=f(mid);
		
		if(sum<n) l=mid+1;
		else r=mid;
		
	}
	return l;
}

signed main(){
	
	int n;
	
	cin>>n;
	
	cout<<find(n)<<endl;

	return 0;
}
```

完结撒花！

### 后记

感谢大家阅读，谢谢！

---

## 作者：cccz (赞：0)

注意到 $N$ 的范围是很大的，直接模拟显然会超时，又注意到是统计某些特定的数，很容易想到数位 dp。

通过题意很容易就可以找出规律，即除第一个可以填 $9$ 种数字之外，剩余位数都只能填 $5$ 种，可以先把所有位数的情况打个表，再 dfs 判断。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll dis[105],ck[105];
ll n,ans;
void dfs(int pos,int last){
	if(pos==0){
		printf("%lld",ans);
		exit(0);//直接结束程序  
		return ;
	}
	int to,i;
	if(last==-1)to=1,i=1;//判断是否为最高位数 
	else{
		to=2;
		if(last%2==0)i=1;
		else i=0;
	}
	for(;i<10;i+=to){
		if(n>ck[pos]){ 
			n-=ck[pos];
			continue;
		}
		ans=ans*10+i;
		dfs(pos-1,i);
	}
}
signed main(){
	dis[1]=9,ck[1]=1;
	for(int i=2;i<=100;i++)dis[i]=dis[i-1]*5,ck[i]=ck[i-1]*5;//打表 
	scanf("%lld",&n);
	int pos=0;
	for(int i=2;i<=100;i++){
		if(n>dis[i])n-=dis[i];
		else{
			pos=i;//找到第N位数的位数 
			break;
		}
	}
	dfs(pos,-1);
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：0)

# P12835 [蓝桥杯 2025 国 B] 蓝桥星数字 题解  
### 解题思路 
我们可以观察到，任何满足性质的数首位是 1 到 9 之中的任何数，其他位置根据首为奇偶性，可以得出只有 5 种可能，因此位数为 $n$ 的满足性质的数有 $9\times 5^{n-1}$ 个。看得出答案的位数不会太多，所以我们可以先顺序推出答案的数位，记为 $len$，具体为求出满足 $\sum_{i=2}^{x}9\times 5^{i-1} \ge n$ 最小的 $x$。然后顺序以此推出每一位就行了，时间复杂度还是非常优秀的。
### AC 代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n;
ll tmp;
int len;
ll biao[25]={1LL,5LL,25LL,125LL,625LL,3125LL,15625LL,78125LL,390625LL,1953125LL,9765625LL,48828125LL,244140625LL,1220703125LL,6103515625LL,30517578125LL,152587890625LL,762939453125LL,3814697265625LL,19073486328125LL};
void dfs(int last,int pos){
//	cout<<endl<<last<<" "<<pos<<" "<<siz<<" "<<ss<<endl;
	if(pos>len) return;
	for(ll i=1;i<=5;i++){
		if(i*biao[len-pos]>=n){
			cout<<(1-last)+(i-1)*2;
			n-=(i-1)*biao[len-pos];
			dfs((last^1),pos+1);
			return;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=2;;i++){
		if(tmp+9LL*biao[i-1]>=n){
			len=i;
			break;
		}
		tmp+=9LL*biao[i-1];
	}
	n-=tmp;
	for(ll i=1;i<=9;i++){
		if(i*biao[len-1]>=n){
			cout<<i;
			n-=(i-1)*biao[len-1];
			dfs(i%2,2);
			return 0;
		}
	}
}
//
```

---


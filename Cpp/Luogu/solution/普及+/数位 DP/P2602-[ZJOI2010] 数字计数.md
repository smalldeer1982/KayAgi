# [ZJOI2010] 数字计数

## 题目描述

给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出现了多少次。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $a\le b\le10^6$；
- 对于 $100\%$ 的数据，保证 $1\le a\le b\le 10^{12}$。

## 样例 #1

### 输入

```
1 99
```

### 输出

```
9 20 20 20 20 20 20 20 20 20
```

# 题解

## 作者：moye到碗里来 (赞：330)

首先推一下我的博客，洛谷的，上面有一些多加的内容，大家尽量去看看吧，~~顺便赞一下啦~~

[blog](https://www.luogu.org/blog/mak2333/swdp001)

在这里我的写法参照了大奕哥这位dalao的题解，大家也可以看看，在这里我会针对我的理解来写。


那么我们首先看题，对于这道题我一开始以为很水，但是当我仔细去读题之后发现事情没那么简单。其中对于这道题（递推做法）最大的难点是难以找出递推式子（废话，你写递推就只有这点难了）。为啥，因为你很难想到怎样求出第几位它的数字又多少，因为不能有前导0。但是我们发现如果不考虑是否有前导0的话，那么这道题就似乎有递推公式。


f[i]代表在有i位数字的情况下，每个数字有多少个。如果不考虑前导0，你会发现对于每一个数，它的数量都是相等的，也就是f[i]=f[i-1]\*10+10^(i-1);(这里我推荐使用打表+大眼观察法)


然而这个公式推出来后，你就会面临第二个难题，怎么推出我想要的答案？


我们先设数字为ABCD


看A000，如果我们要求出它所有数位之和，我们会怎么求？


鉴于我们其实已经求出了0~9,0~99,0~999。。。上所有数字个数（f[i],且没有考虑前导0）我们何不把这个A000看成0000~1000~2000...A000对于不考虑首位每一个式子的数字的出现个数为 A\*f[3]。加上首位出现也就是小于A每一个数都出现了10^3次，再加上，我们就把A000处理完了。


这样你以为就把第一位处理完了？不不不，首位A还出现了BCD+1次呢，也就是从A000~ABCD，这个A还出现了BCD+1次，所以再加上这些才行呢。那么你发现，我们成功把首位代表的所有数字个数求出来了，剩下的求解与A完全没有任何关系，只是BCD的求解，于是我们发现我们已经把一个大问题，化成了一个个小问题，也即是，对于一个这样n位的数，把他一位位的分离开来。


当然你还需要处理前导0你会发现前导0一定是0001,0002。。。0012，0013。。。0101,0102.。。0999这样的数，一共出现了10\*（i-1)+10\*(i-2)+...10 (i表示数字位数），让0的统计减去这个值，那么恭喜你这道题做完了。


总结
对于DP这个东西，最重要的其实只有一点，推状态，状态又是什么？是大问题的子问题，对于这种题最重要的特点是，无后效性，问题可拆分，并且答案的求解具有一定的规律，这样的题应该就可以用DP做，数位DP最重要的就是把一整个数字拆分成一位一位的单独来看，那么对于数位DP，它的子问题也就一般是每一位上对于答案的求解，层层递进的这么一个思路。


最后粘代码，写的丑见谅

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b;
long long ten[20],f[20];
long long cnta[20],cntb[20];
void solve(long long x,long long *cnt)
{
    long long num[20]={0};
    int len=0;
    while(x)
    {
        num[++len]=x%10;
        x=x/10;
    } 
    for(int i=len;i>=1;i--)
    {
        for(int j=0;j<=9;j++)
        cnt[j]+=f[i-1]*num[i];
        for(int j=0;j<num[i];j++)
        cnt[j]+=ten[i-1];
        long long num2=0;
        for(int j=i-1;j>=1;j--)
        {
            num2=num2*10+num[j];
        }
        cnt[num[i]]+=num2+1;
        cnt[0]-=ten[i-1];
    } 
}
int main()
{
    scanf("%lld %lld",&a,&b);
    ten[0]=1;
    for(int i=1;i<=15;i++)
    {
        f[i]=f[i-1]*10+ten[i-1];
        ten[i]=10*ten[i-1];
    }
    solve(a-1,cnta);
    solve(b,cntb);
    for(int i=0;i<=9;i++)
    printf("%lld ",cntb[i]-cnta[i]);
}
```

---

## 作者：fy0123 (赞：273)

显然是数位DP（下面大佬写的和我好像不太一样，代码也不太一样，我来写个dfs题解吧）


首先区间[a,b]内的数量可转化为[1,b]-[1,a-1]。考虑求一个数码出现的次数，比如1出现的次数。我们首先想爆搜怎么写，然后加一个记忆化即可。

对于一个长度为len的数，从高位到低位枚举它每一位上的数字，然后计算1出现的次数。哪些东西要记到状态里去？第一，当前的位置len一定要记的。第二，你要记录当前数位有没有比num[len]小，是一个bool值，因为这个用来确定你枚举下一位的范围。第三，要记录当前1已经出现的次数。第四，由于前导0不能算，还需记录之前是否是前导0，也是一个bool值。

那么dfs就好写了，其它几个数字都一样，具体的注释见代码吧。


```cpp
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;

const int N = 15;
ll f[N][2][N][2];
int num[N];  //num来存这个数每个位子上的数码

/*
记忆化搜索。
len是当前为从高到低第几位。issmall表示当前位是否和num[len]相等，0是相等，1是不相等。
sum表示当前数字出现的次数。zero表示之前是否是前导0。d是当前在算的数码。
*/
ll dfs(int len, bool issmall, int sum, bool zero, int d)
{
    ll ret = 0;
    if (len == 0) return sum;  //边界条件
    if (f[len][issmall][sum][zero] != -1) return f[len][issmall][sum][zero];  //记忆化
    for (int i = 0; i < 10; i ++){
        if (!issmall && i > num[len]) break;
        /*
        由于我们是从高位到低位枚举的，所以如果之前一位的数码和最大数的数码相同，这一位就只能枚举到num[len]；
        否则如果之前一位比最大数的数码小，那这一位就可以从0~9枚举了。
        */
        ret += dfs(len-1, issmall || (i<num[len]), sum+((!zero || i) && (i==d)), zero && (i == 0), d);
        /*
        继续搜索，数位减一，issmall的更新要看之前有没有相等，且这一位有没有相等；
        sum的更新要看之前是否为前导0或者这一位不是0；
        zero的更新就看之前是否为前导0且这一位继续为0；
        d继续传进去。
        */
    }
    f[len][issmall][sum][zero] = ret;
    //记忆化，把搜到的都记下来
    return ret;
}

ll solve(ll x, int d)
{
    int len = 0;
    while (x){
        num[++ len] = x%10;
        x /= 10;
    } //数字转数位
    memset(f, -1, sizeof f); //初始化
    return dfs(len, 0, 0, 1, d); //开始在第len位上，最高位只能枚举到num[len]所以issmall是0，sum=0，有前导0。
}

int main()
{
    ll a, b; //注意都要开long long
    scanf("%lld%lld", &a, &b);
    for (int i = 0; i < 10; i ++)
        printf("%lld%c", solve(b, i)-solve(a-1, i), i == 9 ? '\n' : ' ');
    return 0;
}
```
ps.~~打注释累死了~~快夸我


---

## 作者：asuldb (赞：151)

发现好像没有人和我写一样的数位$dp$

而且这还是个递推版的数位$dp$

我这个数位$dp$写的非常鬼畜

设$dp[i][j][k]$表示一个长度为$i$的数，其中最高位是$j$，$k$这个数码一共出现的次数

之后转移的话，我们需要枚举当前位数，当前最高位填什么数，次高位填什么数，之后转移一下就好了

显然有

$$dp[i][j][p]=\sum_{k=0}^9dp[i-1][k][p]$$

但是这就完了吗，显然不是啊

我们填上的最高位可是出现了很多次，但是一次都没有被记录进去

那也好办，我们让剩下的$i-1$为随意选择只考虑当前最高位上出现的数就好了（因为那些随意选择的数码已经被计入答案了）

于是根据乘法原理，还有

$$dp[i][j][j]+=10^{i-1}$$

之后就是数位$dp$的板子了

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 14
#define LL long long
LL dp[maxn][10][10];
LL L,R;
LL ans[10][2];
int a[maxn],num;
inline LL quick(LL a,LL b)
{
	LL s=1;
	while(b)
	{
		if(b&1) s*=a;
		b>>=1;
		a*=a;
	}
	return s;
}
inline void slove(LL x,int pd)
{
	memset(dp,0,sizeof(dp));
	num=0;
	memset(a,0,sizeof(a));
	while(x)
	{
		a[++num]=x%10;
		x/=10;
	}//分解数位 
	for(re int i=0;i<=9;i++) dp[1][i][i]=1;//初始化
	for(re int i=2;i<=num;i++)//枚举位数
		for(re int j=0;j<=9;j++)//当前最高位
		{
			for(re int k=0;k<=9;k++)//次高位
			{
				for(re int p=0;p<=9;p++)
					dp[i][j][p]+=dp[i-1][k][p];
			}
			dp[i][j][j]+=quick(10,i-1);//乘法原理
		}
	for(re int i=1;i<num;i++)//位数比x小的，一定能够满足条件
		for(re int j=1;j<=9;j++)//不能有前导零
			for(re int k=0;k<=9;k++)
				ans[k][pd]+=dp[i][j][k];
	for(re int i=1;i<a[num];i++)//位数相同，但最高位比x小
		for(re int k=0;k<=9;k++)
			ans[k][pd]+=dp[num][i][k];
	for(re int i=num-1;i>=1;i--)//当前不同的那一位,[i+1,num]与x完全相同 
	{
		for(re int j=0;j<a[i];j++)//不同的这一位也必须必对应x位置上的数小
		{
			for(re int k=0;k<=9;k++)
				ans[k][pd]+=dp[i][j][k];
		}
		for(re int p=num;p>i;p--)
				ans[a[p]][pd]+=a[i]*quick(10,i-1);
        //由于我们保证[i+1,num]相同，那么这些数码也应该计入答案，于是还是一个乘法原理
	}
    //但是这个dp全程都不能处理出x是否满足条件
    //因为最后也只是判断第一位上的数比给定数的第一位小
    //所以slove(x)其实求得是[0,x)满足条件的数的个数
}
int main()
{
	scanf("%lld%lld",&L,&R);
	slove(R+1,0),slove(L,1);
	for(re int i=0;i<=9;i++)
		printf("%lld ",ans[i][0]-ans[i][1]);
	putchar(10);
	return 0;
}
```

---

## 作者：AcRapper (赞：148)

 _看到只有一篇dfs的题解，就过来发一篇dfs的。
_ 

关于数位dp，~~（数位dp的题只有dfs才是通解）~~
个人认为dfs代码要比递推的代码简洁不少，而且更易理解。

题解已经有一个四维的dfs了，实际上这个题数组只需要开两维，可以省掉两维，于是发一个二维的。

先说下思路，对于这道数位dp的~~水~~题我们考虑用记忆化搜索来解决。定义num数组来拆数，显然需要bool limit和lead来分别判断是否达有限制和是否有前导0。有前导0设为0，有限制为1。具体请看代码。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long a , b;
long long  dp[20][20],num[20];
long long  dfs(int pos,bool limit,bool lead,int dig,long long sum)
//sum是一定需要存的一个变量，因为她表示的是操作答案，需要不断随dfs更新
{//limit为1表示有限制，lead为0表示有前导0
	long long ans=0;
	if (pos==0) return sum;//边界条件
	if(!limit&&lead&&dp[pos][sum]!=-1) return dp[pos][sum];//记忆化
	int up=9;
	if(limit) up=num[pos];//达到限制就设上限为当前位的数（不想用三目运算符）（雾）
	for(int j=0;j<=up;j++)
		ans+=dfs(pos-1, (j==up)&&limit , lead||j , dig , sum+((j||lead)&&(j==dig)) );
	if(!limit&&lead) dp[pos][sum]=ans;
	return ans;
}//数位dp的操作
long long  work(long long x,int d)
{
	memset(dp,-1,sizeof(dp));//初始化
	int len=0;
	while(x)
	{
		num[++len]=x%10;//最高位在第一位 
		x/=10;
	}
	return	dfs(len,1,0,d,0);
}
int main()
{
	cin>>a>>b;
	for(int i=0;i<=9;i++)//九个digit
	{
		 if(i!=9)cout<<work(b,i)-work(a-1,i)<<" ";
		 else cout<<work(b,i)-work(a-1,i);
         //我也不知道最后边输出了空格会不会炸（手动滑稽）
	}
	return ^-^;
}
```
初学数位dp需要多揣摩，多思考。

到最后你就会发现~~递推本质是瞎猜，dfs本质是模板~~数位dp很简单

ps：请不要试图复制我的代码，不然你会因为一些 奇形怪状 的0花式CE。

如有不懂，欢迎来问


---

## 作者：AC机 (赞：91)

这题只要看一眼数据范围就知道，O（n）是过不了的。

所以我们就要用到数位dp了。

不难发现，即使不用计算机，答案也很容易求出，如：

n=728，x=7

可以按照这样的思路：

个位7:73个 7,17,...,727

十位7:70个 70~79,170~179,...,670~679

百位7:29个 700~728

我们这样所求的是[1,N]而题目要求是[A,N]怎么办呢？

这里要用一个区间相减法: [A,N]=[1,N]-[1,A-1]

这样我们的时间复杂度就已经到了log10（n），非常快哦！！！

下面我们来看一下代码的具体实现

```cpp
#include<stdio.h>
#include<cctype>
#include<iostream>
using namespace std;
inline int read() {
    int x=0,w=0;
    char ch=0;
    while(!isdigit(ch)) {
        w|=ch=='-';
        ch=getchar();
    }
    while(isdigit(ch)) {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return w?-x:x;
}//其实这个快读根本没用到…………不用管…………
unsigned long long n,ans[5][1005],a,b,m=1,q;
int t,x;
int main () {
    cin>>q>>n;
    q-=1;
    //我们先求[1,A-1],把它的值放到ans[2]里。
    for(int t=0; t<=9; t++) {
        x=t;
        m=1;
        while(m<=q) {
            long long a=q/(m*10),b=q/m%10,c=q%m;
            //a,b,c为n的三部分，求哪一位x的个数，b就为那一位数，a为b左边的数，c为b右边的数，如求1~728中十位7的个数，则a=7，b=2，c=8
            if(x) {
                if(b>x) ans[2][t]+=(a+1)*m;
                //如果b>x，说明有(a+1)*m个x（如求1~728中个位7的个数，则为（72+1）*1=73）
                if(b==x) ans[2][t]+=a*m+c+1;
                //如果b=x，说明有a*m+c+1个x（如求1~728中百位7的个数，则为0*100+28+1=29）
                if(b<x) ans[2][t]+=a*m;
            }
            //如果b<x，说明有a*m个x（如求1~728中十位7的个数，则为7*10个）
            else {////x=0的情况和x!=0的情况有所不同
                if(b) ans[2][t]+=a*m;
                else ans[2][t]+=(a-1)*m+c+1;
            }
            m*=10;
        }
    }
    //同上，我们再求一下[1,N]的值
    for(int t=0; t<=9; t++) {
        x=t;
        m=1;
        while(m<=n) {
            long long a=n/(m*10),b=n/m%10,c=n%m;
            if(x) {
                if(b>x) ans[1][t]+=(a+1)*m;
                if(b==x) ans[1][t]+=a*m+c+1;
                if(b<x) ans[1][t]+=a*m;
            } else {
                if(b) ans[1][t]+=a*m;
                else ans[1][t]+=(a-1)*m+c+1;
            }
            m*=10;
        }
    }
    //最后我们用上面提到的区间相减法输出答案
    for(int i=0; i<=9; i++) {
        cout<<ans[1][i]-ans[2][i]<<" ";
    }
    return 0;
}
```

第一篇紫题题解，求过QAQ

---

## 作者：Isshiki_Hugh (赞：85)

**[P2602 [ZJOI2010]数字计数](https://www.luogu.org/problemnew/show/P2602)**

---

*注：这篇题解是我在根据这[篇](https://www.luogu.org/blog/mak2333/swdp001)的基础上进行个人理解写出来的x

~~我也喜欢工口散散~~*

---

*题目旁边的有这么几个算法标签：``数位dp``、``递推``、``动态规划`` 、``深度优先搜索dfs``。蒟蒻完全不知道``数位dp``是什么东西，于是打开了题解，康了若久终于稍稍领会其中的奥妙(大雾*

*首先我们需要典型化问题，即用尽可能直观且本质的方式表述题目：*

*对于一个n位数：*

**``a[n] a[n-1] …… a[3] a[2] a[1]``**

(``a[n]``表示一个阿拉伯数字，满足``a[n]≠0``)

*最暴力的方法当然是穷举每一个数字然后统计每个数字出现的次数(微笑)，但是作为一道省选题目，它的尊严是绝对不会允许这样的算法AC的。但是这样的思考并非毫无意义，首先我们要找出不可以优化的地方以及可以优化的地方，这些可能作为算法的基本构架*
### （1）

**既然要统计数字，那最好需要提取每个数字，显然是从个位逐一提取，当然为了方便之后再次利用，我们显然会使用一个数组来存每一位数字，如样例。我们还可以用空余的``a[0]``来存数字的长度。**
```cpp
    long long num[20] = {0};//num[i]中i>=1，i表示位数，用来存x
    num[0] = 0;//用来计数(长度length)
    while(x){//将数字x存入数组
        num[++num[0]] = x % 10;
        x /= 10;
    }
```
----
### （2）

**显然``直接``的``暴力``枚举是不可行的，那有没有什么办法可以不用枚举呢？看到``递推``这个标签，蒟蒻感到``confused``，这又不是数列，也不是函数，为什么就能``递推``了呢？是不是对``递推``的理解有问题呢？于是蒟蒻打开了``baidu.com``，得到如下答案：** *递推算法是一种用若干步可重复运算来描述复杂问题的方法。递推是序列计算中的一种常用算法。通常是通过计算前面的一些项来得出序列中的指定项的值。* **震惊！康到第一句，蒟蒻恍然大悟，原来意思是可以用重复类似的步骤解决问题，可是这里有什么地方是可以重复类似解决的呢？我们知道，整数有这样一个性质(jiade)，``(int)x = x1 + x2 * 10 + x3 * 100 + ……``我们原来的思路是直接对``x``进行暴力枚举得到答案，那可不可以先对``x1``、``x2``……进行~~暴力~~枚举，然后通过数学计算来得到最终答案呢？想到这里，接下来一步就是该如何通过数学计算得到答案，以及构造出较好的程序结构。**

**在这篇[题解](https://www.luogu.org/blog/mak2333/swdp001)里，大牛说要用``大眼观察法``，可奈何蒟蒻没有``大眼``，而``小眼观察法``显然是行不通的，所以蒟蒻需要想办法让自己理解。于是在某节~~历史课~~上，蒟蒻终于理解了为何可以这样，现在我可以``讲的响``了。首先我们进行三次枚举:**

```
[1]对于一位数a，a∈[0,9],a∈Z,每个数字记为k1 = 1；
[2]对于一个两位数ab，a∈[1,9],b∈[0,9]，a,b∈Z
	枚举每一个a，对b进行[1]，得到b上出现每一个数字的次数为k1，由于a可取的值一共有9个，最终在b上每一个数出现的次数为k1 * 9
   枚举每一个ax，x代表任意b，得到ax有9种，每一个数字出现1次，由于x又有10种取值，所以最终a上除0外每一个数出现的次数为1 * 10
   		最终得到在a和b上出现的除0数字出现的个数为k2 = k1 * 9 + 1 * 10 
                                          0出现的个数为k2` = k1 * 9
```

**手动枚举到三位数就发现，不能直接用带k2的式子表示了，为什么呢？因为在``[2]``中第二位的取值范围是``[1,9]``而在``[3]``中第二位的取值范围就变成``[0,9]``了，这~~不好~~不方便，所以我们干脆把``[2]``中第二位的取值范围变成``[0,9]``，为什么可以这么做呢？因为我们这里使用的``[1]``，``[2]``……``[n]``，本质是是对10^1,10^2,10^n进行讨论，不过没有计算最高位上的数字而已。那么修改后的枚举就变成了这样：**

```
[1]对于一位数a，a∈[0,9],a∈Z,每个数字记为k1 = 1；
[2]对于一个两位数ab，a,b∈[0,9]，a,b∈Z
	枚举每一个a，对b进行[1]，得到b上出现每一个数字的次数为k1，由于a可取的值一共有10个，最终在b上每一个数出现的次数为k1 * 10
  	枚举每一个ax，x代表任意b，得到ax有10种，每一个数字出现1次，由于x又有10^1种取值，所以最终a上每一个数出现的次数为1 * 10^1
   		最终得到在a和b上出现的各个数字出现的个数为k2 = k1 * 10 + 1 * 10^1 
[3]对于一个三位数abc,a,b,c∈[0,9]，a,b,c∈Z
	枚举每一个a，对bc进行[2]，(把bc这个两位数当做一个整体)得到bc上出现每一个数字的次数为k2，由于a可取的值一共有10个，最终在bc上每一个数出现的次数为 k2 * 10
	枚举每一个ax，x代表任意b，得到ax有10种，每一个数字出现1次，由于x又有10^2种取值，所以最终a上每一个数出现的次数为1 * 10^2
    		最终得到在a,b,c上出现的各个数字出现的个数k3 = k2 * 10 + 1 * 10^2
……
```

**通过~~数学归纳法~~仔(hu)细(si)思(luan)考(xiang)，我们可以得到对于n位数的递推式的处理方法：**

*注：下面用``f[n]``代替``kn``*

```
[n]对于一个n位数abc...，a,b,c,...∈[0,9]，a,b,c,...∈Z
	枚举每一个a，对bc...进行[n-1]，得到bc...上出现每一个数字的次数为f[n-1]，由于a可取的值一共有10个，最终在bc上每一个数出现的次数为 f[n-1] * 10
	枚举每一个ax，x代表任意bc...，得到ax有10种，每一个数字出现1次，由于x又有10^(n-1)种取值，所以最终a上每一个数出现的次数为1 * 10^(n-1)
    		最终得到在a,b,c上出现的各个数字出现的个数f[n] = f[n-1] * 10 + 1 * 10^(n-1)
	
```
**得到了``f[n]``的递推式，印证了``递推``的标签，方向大概是对了。喜闻乐见，我们现在知道如何计算形如``10^n``的次高位开始之后每一位上每一个数字出现个数的计算方法了，对于形如``x * 10^n``的数只需要将结果乘以``x``就可以了。**

**但在实际解决问题的过程中仅仅是这样还不够，因为这里只计算了不计最高位上的数字出现的次数，所以最终每次处理的时候还得处理最高位数字，很显然可以得到``n``位上数字出现的次数等于``10^n``**

**那么该如何实现上述操作呢？通过观察发现，``f[n]``的递推式为一个和的形式，其中一个带``f[n-1]``，一个是``10``的``n-1``次方，两者的实现可以分别用一个数组实现，``f[n-1]``在每一次递推时乘``10``加到``f[n]``上，后者每一次让``x[n]``等于``x[n-1] x 10``，然后加上即可**

```cpp
   for(int i = num[0];i >= 1;i--){//从大位往小位处理
	long long ten[20],f[20];//ten[i]=10^i;ten[i]表示i-1位数第i-1位每个数字出现几次
	ten[0]=1;
   for(int i = 1;i <= 13;i++){
   		f[i] = f[i-1]*10 + ten[i-1];//每一个数字出现的次数等于10倍上一层加上这一位在总数中出现的次数
        ten[i] = 10*ten[i-1];//ten[i]=10^i的计算
    }
   
   ……
   ……
   ……
   
   }
```
----
### （3）

**由（2）中的内容，我们已经可以解决形如``x * 10^n``的数。那么只要把任意整数拆成若干个形如``x * 10^n``的子问题就可以解决。但是问题出现了,该如何拆分呢？**
**以一个四位数``ABCD``为例子，我们将它拆成``A * 1000 + B * 100 + C * 10 + D * 1``，换一种说法就是逐位处理，先处理A，再处理B，再处理C，再处理D。**

```cpp
	for(int i = num[0];i >= 1;i--){//从大位往小位处理
    
    ……
    ……
    
    //由于i位的数字不见得一样，所以需要通过i位数字与i-1位的出现个数相乘
    //得到，再加上该位置该数字出现的个数，即次位数字个次位数出现的个数，
    //同时对于每一位的数字之前的数字还有一部分零散的num2需要加
        for(int j = 0;j <= 9;j++)
         cnt[j] += f[i-1] * num[i];
        for(int j = 0;j < num[i];j++)
         cnt[j] += ten[i-1];
         
    ……
    ……
    
    }
```

**但是需要注意的是，处理``A x 1000``时，除了``f[4] * A``还应该再加上一个BCD，因为在``f[4] * A``中实际上处理的数只有``0 ~ A * 1000``这``A * 1000 + 1``个数，如果就直接这样继续向下处理BCD，则会遗漏BCD个A，即``A000 ~ ABCD``这``BCD+1``个数，所以在每一次向下递推之前还得加上这些。**
```cpp
	for(int i = num[0];i >= 1;i--){//从大位往小位处理
    
    ……
    ……
    //所谓num2，其实是对于形如ABC的数(B为当前处理数字，A为B之前的数字串，C为B之
    //后的数字串)，而num2就是C，所以对num2的操作就是将存入数组的C提取出来，变整型
        long long num2 = 0;
        for(int j = i-1;j >= 1;j--)
         num2 = num2*10 + num[j];
        cnt[num[i]] += num2+1;
        
    ……
    ……
        
    }
```
**但是这样还不够，因为我们会发现最终的结果会存在形如``0XXX``，``00XX``，``000X``，这样不能算零的数，所以我们要把这些零都减去，但这些零该怎么统计呢？很简单。既然我们知道``X000``这样的数如何处理，那``000X``用同样的方法处理不就好了吗？不够由于这边有一个对``[i]``的循环结构，所以可以顺着之前的思想，通过``ten[i-1]``来处理每一位上的``0``**
```cpp
	cnt[0] -= ten[i-1];
```
----
### （4）

**最后一个问题，现在我们已经知道如何处理从0开始到某个数内该问题的解决办法，可是这道题不是从0开始的，这时候就要利用一个区间相减的原理了，很显然这里的答案可以进行代数相减，所以只要``ans1[i] - ans2[i]``就好啦~**

```cpp
	work(a-1,cnta);//求得a左侧的数中i出现多少次[1,a-1]
   work(b,cntb);//求得b左侧的数中i出现了多少次[a,b]
    for(int i = 0;i <= 9;i++)
        cout << cntb[i] - cnta[i] << " ";//将结果做差得到区间内的数中i出现了多少次
```

----
**AC代码**
```cpp
#include<iostream>
using std::cin;using std::cout;using std::endl;
long long a,b;//a,b为左右区间
long long ten[20],f[20];//ten[i]=10^i;ten[i]表示i-1位数第i-1位每个数字出现几次
//f[i]表示i位数的每一个数字总共出现f[i]次
long long cnta[20],cntb[20];

void work(long long x,long long *cnt){
    long long num[20] = {0};//num[i]中i>=1，i表示位数，用来存x
    num[0] = 0;//用来计数(长度length)
    while(x){//将数字x存入数组
        num[++num[0]] = x % 10;
        x /= 10;
    }
    for(int i = num[0];i >= 1;i--){//从大位往小位处理
    //由于i位的数字不见得一样，所以需要通过i位数字与i-1位的出现个数相乘
    //得到，再加上该位置该数字出现的个数，即次位数字个次位数出现的个数，
    //同时对于每一位的数字之前的数字还有一部分零散的num2需要加
        for(int j = 0;j <= 9;j++)
         cnt[j] += f[i-1] * num[i];
        for(int j = 0;j < num[i];j++)
         cnt[j] += ten[i-1];
    //所谓num2，其实是对于形如ABC的数(B为当前处理数字，A为B之前的数字串，C为B之
    //后的数字串)，而num2就是C，所以对num2的操作就是将存入数组的C提取出来，变整型
        long long num2 = 0;
        for(int j = i-1;j >= 1;j--)
         num2 = num2*10 + num[j];
        cnt[num[i]] += num2+1;
    //减去每一个零导数字，为当前位数最高位为0的数字的个数，因此减去ten[i-1]
        cnt[0] -= ten[i-1];
    }
   
}

int main(){
    cin >> a >> b;
    ten[0]=1;
    for(int i = 1;i <= 13;i++){
        f[i] = f[i-1]*10 + ten[i-1];//每一个数字出现的次数等于10倍上一层加上这一位在总数中出现的次数
        ten[i] = 10*ten[i-1];//ten[i]=10^i的计算
    }
    work(a-1,cnta);//求得a左侧的数中i出现多少次[1,a-1]
    work(b,cntb);//求得b左侧的数中i出现了多少次[a,b]
    for(int i = 0;i <= 9;i++)
        cout << cntb[i] - cnta[i] << " ";//将结果做差得到区间内的数中i出现了多少次
    return 0;
}
```

---

## 作者：Social_Zhao (赞：52)

~~听同机房的巨佬说，学会了数位dp就可以切掉好多好多的水紫题。~~

$\mathbf{\boxed{\colorbox{black}{\color{white}{I was shaded. Everyone was shaded.}}}}$

## 正题：

数位$dp$其实就是两个部分。初始化、求解。

**初始化：**

设$f[i][j][k]$表示第$i$位，最高位为$j$，$k$有多少个。

这里用到了前缀和的思想。比如$f[2][1][1]$就表示$[0,19]$有多少个$1$。

在求解的时候，我们就用``solve(b + 1) - solve(a)``。

首先我们可以得到一个粗略的方程：

$f[i][j][k]=\sum\limits_{l=0}^{9}{f[i-1][l][k]}+\text{一个很玄学的数}$。

这一个很玄学的数是指$k$在这一位上出现的次数。

那么在这一位上出现了多少次呢？

如果``j <> k``，很明显，皮蛋。

那``j == k``呢？

- 比如$[10,19]$，$1$就出现了$10$次。
- $[100][199]$，$1$很明显出现了$100$次。

怎么来的？

- $10=10^1=10^{2-1}$。
- $100=10^2=10^{3-1}$。

即$f[i][j][j]+=10^{i-1}$。

代码：

```cpp
void init() {
    for(int i = 0; i <= 9; i++) f[1][i][i] = 1; //初始化，0中有1个0，1中有1个1，......
    for(int i = 2; i <= 13; i++) { //位数
        for(int j = 0; j <= 9; j++) { //当前位
            for(int k = 0; k <= 9; k++) { //上一位
                for(int l = 0; l <= 9; l++) { //统计数
                    f[i][j][l] += f[i-1][k][l]; //抄方程
                }
            }
            f[i][j][j] += x10(i-1); //加入10^(i-1)
        }
    }
}
```

**求解：**

这个求解又被一些大佬称为“拆数”，可以递归和非递归实现。

求解过程一般有以下几步：


- 首先把原数拆了，存入数组；
- 统计位数比原数少，不含前导零的数字；
- 统计位数与原数一样，但最高位较小的数，同样不能有前导零；
- 统计一般情况。需要注意的是，如果当前位是要统计的数，结果要加$10^{i-1}$。

代码：

```cpp
int solve(int x, int num) { //0~x中num出现了多少次
    int digit[15]; //拆的数放这里
    int len = 0, ans = 0; //数的长度、统计的结果
    memset(digit, 0, sizeof(digit)); 
    while( x ) { digit[++len] = x % 10; x /= 10; } //拆开
    for(int i = 1; i < len; i++) { //统计位数比原数少，不含前导零的数字；
        for(int j = 1; j <=9; j++) {
            ans += f[i][j][num];
        }
    }
    for(int i = 1; i < digit[len]; i++) { //统计位数与原数一样，但最高位较小的数，同样不能有前导零；
        ans += f[len][i][num];
    }
    for(int i = len-1; i >= 1; i--) { //统计一般情况。枚举位数
        for(int j = 0; j < digit[i]; j++) { //枚举这一位
            ans += f[i][j][num]; //累加
        }
        for(int j = len; j > i; j--) { //前几位需要加上的情况
            if(digit[j] == num) ans += digit[i] * x10(i-1);
        }
    }
    return ans;
}
```

**完整代码：**

注意：开``ULL``！！！不然``30pts``！！！

蒟蒻的习惯不怎么好，马蜂清奇，用宏开``ULL`` 将就看把$QωQ$

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define x10(x) q_pow(10,x);
using namespace std;

const int MaxN = 15;
int f[MaxN][10][10];
int a,b;

int q_pow(int a, int b) {
    int res = 1;
    while(b) {
        if(b & 1) res *= a;
        b >>= 1;
        a *= a;
    }
    return res;
}

void init() {
    for(int i = 0; i <= 9; i++) f[1][i][i] = 1;
    for(int i = 2; i <= 13; i++) {
        for(int j = 0; j <= 9; j++) {
            for(int k = 0; k <= 9; k++) {
                for(int l = 0; l <= 9; l++) {
                    f[i][j][l] += f[i-1][k][l];
                }
            }
            f[i][j][j] += x10(i-1);
        }
    }
}

int solve(int x, int num) {
    int digit[15];
    int len = 0, ans = 0;
    memset(digit, 0, sizeof(digit));
    while( x ) { digit[++len] = x % 10; x /= 10; }
    for(int i = 1; i < len; i++) {
        for(int j = 1; j <=9; j++) {
            ans += f[i][j][num];
        }
    }
    for(int i = 1; i < digit[len]; i++) {
        ans += f[len][i][num];
    }
    for(int i = len-1; i >= 1; i--) {
        for(int j = 0; j < digit[i]; j++) {
            ans += f[i][j][num];
        }
        for(int j = len; j > i; j--) {
            if(digit[j] == num) ans += digit[i] * x10(i-1);
        }
    }
    return ans;
}

signed main() {
    scanf("%lld%lld", &a, &b);
    init();
    for(int i = 0; i <= 9; i++) {
        printf("%lld ", solve(b+1, i) - solve(a, i));
    }
    return 0;
}

```

~~其实这最多就一蓝题。~~

---

## 作者：GUO120822 (赞：32)

非常好懂又简洁的题解，不压行只有 9 行！

思路来源：[leomaster](https://www.luogu.com.cn/user/338284)

数据范围很大，考虑~~数位dp~~小学奥数。

题目要求计算 $0$ 到 $9$ 的答案，直接枚举，对于每一个数计算。

下文记 $f(n,x)$ 表示 $n$ 以内，$x$ 的答案。

由于是求 $l$ 到 $r$ 的答案，我们容斥一下，用 $r$ 的答案减去 $l$ 的答案。

对于每一位造成贡献，于是我们枚举 $i$。

$i$ 为 $1$，个位。

$i$ 为 $10$，十位。

一直枚举到 $n$ 的最后一位。

来考虑每一位。

分两种情况讨论：

1. 前面填更小的，一共 $n/i/10$ 种可能，乘上后面随便填，这一位就是 $n/i/10*i$。

2. 前面填相同的，若这一位相同，那么后面只能填更小的 $0$ 到 $n$ 取余 $i$ 一共 $n$ 取余 $i$ 再加 $1$ 种可能。

3. 这一位更小，后面随便填，一共 $i$ 种可能。

```cpp
#include<stdio.h>
typedef long long ll;ll a,b,i;
inline ll f(ll n,ll x){
	ll cnt=0,i;for (i=1;n/i;i*=10){ 
		cnt+=n/i/10*i-(x==0)*i;
		if (x<n%(i*10)/i) cnt+=i;
		else if (x==n%(i*10)/i) cnt+=n%i+1;
	}return cnt;
}int main(){scanf("%lld%lld",&a,&b);for (i=0;i<=9;i++) printf("%lld ",f(b,i)-f(a-1,i));}

---

## 作者：花淇淋 (赞：26)

听说这题要用数位dp。

不会。


只能用暴力了......


举个例子：求$[29,3246]$中每个数码的出现次数。

首先想到把每个数码分开求。

好像很难。

然后想到$[1,3246]$的答案减去$[1,28]$的答案。

好像还是很难。

最后~~突发奇想~~，把位数也分开，例如：求$[1,3246]$中十位出现$4$的个数。

好像很水。


还是刚才那个例子，显然，从$1$开始的每$100$个数中，就有$10$个数的十位是$4$，$3246/100*10=320$，已经有$320$个十位是$4$的数了。那么剩下的$46$个数呢？显然，从$1$开始的每$100$个数中，十位是$4$的数都是第$40$个~第$49$个，$3246$%$100$=$46$，剩下$46$个数，第$40$个数~第$46$个数符合条件，也要算进去。


然后会发现问题来了：$0$的个数好像多出来了？是的，例如计算$[1,3246]$中十位出现$0$的个数，像刚才那样，每$100$个数中就有$10$个数的的十位是$0$，是这$100$个数中的第$1$个数到第$9$个数，好像哪里不对?$[1,9]$没有十位的0啊？


可以看出，刚才计算某一位某个数码的出现次数，并没有管比这一位高的几位是几，也就是说可能全部都是$0$。实际上在刚才的方法中，将$[1,3246]$全部看作了四位数:$0001$,$0002$,$0003$......


那么，如何减去这些前导零呢？很简单，$[1,9]$每个数有$3$个前导零，$[10,99]$每个数有$2$个前导零，以此类推。


计算部分长这样（不包括前导零）：

```cpp
for(i=0;i<=cnt;i++)//枚举位数，位数的标号从0开始，便于用p[0]对应个位
for(j=0;j<=9;j++)//枚举数码
{
        num[j]+=x/p[i+1]*p[i];//num[j]记录j的出现次数
        mod=x%p[i+1];//p[i]为10的i-1次方
        if(mod<p[i]*j)continue;//x为区间右端点
        if(mod>p[i]*(j+1)-1)mod=p[i]*(j+1)-1;
        num[j]+=(mod-p[i]*j+1);
}
```
观察上面的代码，会发现问题又来了：计算$[1,3246]$中十位为$0$的个数，和上面一样，剩下$46$个数，$mod=46$，$j=0$，$mod-p[i]*j+1=47$，不是只有$46$个吗？


进一步发现，这段代码中，每一位的$0$都会多算一个，可以看成：把$0$这个数以及它的前导零都多算了一次，也就是求了$[0,3246]$每一位$0$的出现次数，那么应减去$[0,3246]$的前导零。


那么问题又来了，$[0,28]$中算了$0$，$[0,3246]$中也算了$0$，相减不就抵消了吗？为什么还要各自减去呢？


这个问题将在以下代码中讲解：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
long long p[200],a,b,ans[200],x,mod,y,t,num[200],i,j,cnt,tot;
int main()
{
    p[0]=1;
    cin>>a>>b;
    x=b;
    //先处理[1,b]每个数码1~9的出现次数,[0,b]0的出现次数
    while(b)
    {
        cnt++;
        b/=10;
    }
    cnt--;
    //p[0]对应个位，p[0]~p[cnt]对应b的每一位，总共cnt+1位 
    for(i=1;i<=cnt+1;i++)
    p[i]=p[i-1]*10;//p[i]表示10的i次方 
    for(i=0;i<=cnt;i++)//第i位 
    for(j=0;j<=9;j++)//数字j，出现几次 
    {
            ans[j]+=x/p[i+1]*p[i];
            //每p[i+1]个连续整数中，这一位必会出现p[i]次j 
            mod=x%p[i+1];//个数不足p[i+1]的段，可能还出现j 
            if(mod<p[i]*j)continue;
            //长度不足p[i]*j说明剩下的段中不存在第i位为j的
            //这句不懂的用这段代码模拟一下[1,3426]中十位为4的个数的计算过程
            if(mod>p[i]*(j+1)-1)mod=p[i]*(j+1)-1;
            //把剩余的段中这一位没有j的去掉
            //这句不懂的用这段代码模拟一下[1,3466]中十位为4的个数的计算过程 
            ans[j]+=mod-p[i]*j+1;//[p[i]*j,mod]的数中，这一位都为j
    }
    for(i=0;i<cnt;i++)//减去前导零
    {
        t=p[i]; 
        if(i==0)t=0;//位数为i+1的最小非负整数为t，因为要减掉0，所以是非负 
        y=p[i+1]-1;//位数为i+1的最大整数为y 
        if(y>x)y=x;//y不能超过x，即不能超过b 
        ans[0]-=(cnt-i)*(y-t+1);//把所有数都按b的位数来看，减去前导零的个数 
        //[t,y]的每个数都会有cnt-i个前导零 
    }
    x=a-1;
    //处理[1,a-1]数码1~9的出现次数，以及[0,a-1]0的出现次数
    tot=a-1;
    cnt=0;
    if(tot==0)cnt=1;
    while(tot)
    {
        cnt++;
        tot/=10;
    }
    cnt--;
    for(i=0;i<=cnt;i++)
    for(j=0;j<=9;j++)
    {
            num[j]+=x/p[i+1]*p[i];
                mod=x%p[i+1];
            if(mod<p[i]*j)continue;
            if(mod>p[i]*(j+1)-1)mod=p[i]*(j+1)-1;
            num[j]+=(mod-p[i]*j+1);
    }
    /*
    讲解刚才那个问题：
    刚才说会把0给算进去，但是两个区间中都会算到0，相减是不是就能抵消了？
    对于这个程序来说，如果a-1是一位数，那么cnt=0，下面的那个循环不会进入，
    这个区间内的0不会被算；b不是一位数，上面那个区间的0会被算，就多出来了。
    所以在处理两个区间时，各自减掉各自的0就行了。
    */ 
    if(cnt!=0)
    for(i=0;i<cnt;i++)
    {
        t=p[i];
        if(i==0)t=0;
        y=p[i+1]-1;
        if(y>x)y=x;
        num[0]-=(cnt-i)*(y-t+1);
    }
    for(i=0;i<=9;i++)//两个区间相减，得到[a,b]的结果 
    cout<<ans[i]-num[i]<<" ";
    return 0;
}
```
注意要开long long，不然$30$分，~~当然不用全开long long，只是因为我懒得去想哪些不用开。~~


~~历经千辛万苦，终于利用暴力解出一道数位dp。~~


~~于是，我至今不会数位dp。~~


---

## 作者：吹雪吹雪吹 (赞：24)

萌新第一次发，想法比较~~独特~~猥琐，众dalao见谅。


如果题目给出的数据比较小，我们自然可以悠闲地按位脱离慢慢数。


但是很遗憾啊，数据很不给情面。


作为新时代的~~懒~~好少年，我并不打算想什么高大上的算法（~~其实是不会写~~），而是准备~~走歪门邪道~~优化。


这里有一个离奇的想法，如果能一次解决成千上万个数字就好了。


接下来，我们经过~~认真打表~~仔细分析发现：

N每增长一定值（用1000000比较~~适合嘿嘿嘿~~方便），每个数码的出现次数都有规律地增长（600000个）。


为了方便我们的计算，先将两个边界按照~~笨办法~~朴素算法处理到a\*10^6的形式。


这样一来，我们就可以一次性处理1000000个值（高位的数字解决一下问题不大）。

```cpp
#include<cstdio>

#define n50 600000  //随着n61变化而变化
#define n61 1000000 //便于处理

using namespace std;

long long a[10],n,m;
const long long num[7]={1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000};//10的x次幂

inline long long read()
{
    char ch=getchar();long long ret=0,f=1;
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9')ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}

bool work(long long x)
{
    while(x)
    {
        a[x%10]++;
        x/=10;
    }
}  //土办法按位脱离

int main()
{
//    freopen("count.in","r",stdin);
//    freopen("count.out","w",stdout);//文件什么的不重要
    n=read(),m=read();
    while(n%1000000!=0&&n<m)
    {
        work(n);n++;
        //把n处理成a*10^6
    }
    while(m%1000000!=0&&m>n)
    {
        work(m);m--;
        //把m处理成a*10^6
    }
    while(n!=m)
    {
        for(int i=0;i<10;++i)
            a[i]+=n50;
           //直接滚过10^6
        int i=0;
        while(n/num[i])
        {
            a[(n/num[i])%10]+=n61;//注意！高位数字出现了10^6次！而不是传统的600000次！
            i++;
            //处理高位
        }
        n+=n61;
        //向前滚动
    }
    work(m);//处理一下边界
    for(int i=0;i<=9;++i)
        printf("%lld ",a[i]);
    return 0;
}
```
这种解决方案可适用于更大的数据（只要不爆类型）


---

## 作者：jxcakak (赞：23)

先暴力计算出000000~999999中每个数字出现的次数（把这其中每个数都当6位数算，位数不足高位补0）

然后求出大于等于a且能被1000000整除的最小数t，暴力算a~t-1中每个数字出现的次数。

然后可以求出t~t+999999中每个数字出现的次数，方法如下：

因为t~t+999999第7位及以上的数字是相同的，所以可以先求出t/1000000中每位数字出现的次数，将次数乘1000000（因为范围内刚好好有1000000个数），再加上000000~999999中每个数字出现的次数，这样就是t~t+999999中每个数字出现的次数。

然后将t加上1000000，重复上面的步骤，直到t+1000000>b

现在就已经求出了a~t-1中每个数字出现的次数，然后再暴力求t~b中每个数字出现的次数就得到了答案。

```cpp
#include<cstdio>
const int P=1000000;
typedef long long ll;
ll cnt[10],ans[10],num=0;
void count(ll x){
    for(;x;x/=10) ++ans[x%10];
}
int main(){
    ll a,b; scanf("%lld%lld",&a,&b);
    if(b<=P){ //特判
        for(ll i=a;i<=b;++i) count(i);
        for(ll i=0;i<10;++i) printf("%lld ",ans[i]); return 0;
    }
    for(ll i=0;i<P;++i){ //求出000000~999999中每个数字出现的次数，存在cnt里
        ll x=i; for(int p=1;p<=6;x/=10,++p) ++cnt[x%10];
    }
    ll t=a/P*P; if(t<a) t+=P; //求出t的初始值
    for(ll i=a;i<t;++i) count(i);//暴力算a~t-1
    for(;t+P<=b;t+=P){//循环求值
        ++num; ll k=t/P; //num为循环次数，即答案需要加上num个cnt
        for(;k;k/=10) ans[k%10]+=P;
    }
    for(ll i=t;i<=b;++i) count(i);//暴力算t~b
    for(ll i=0;i<10;++i) printf("%lld ",ans[i]+num*cnt[i]);//输出答案
    return 0;
}
```

---

## 作者：shadowice1984 (赞：17)

这里介绍一种不需要数位dp的黑科技？

当然就是只能水一水这种水题，但是别的数位dp题大家还是别用了

我们现在要统计每一个数码在\[a,b]出现了多少次

emm可以求两发前缀和再相减？

现在问题变成了求\[1,b]内每个数码出现了多少次

比如说我们要求2出现了多少次

这里会有一个非常神奇的性质

2出现的总次数=第1位为2的数的个数+第2位为2的数个数+……第n位为2的个数

可能你会觉得会有重复，比如22222被重复统计了5次

但是我们求的不就是2的出现次数吗?22222刚好出现了5次啊……

所以这样的统计方法是十分合理的

那么假设我们要求为第i位为k的数的个数，发现这个i把整个数分为两段，i前面的和i后面的，因此我们求出来i前面的数有多少种可能性，后边的序列有多少种可能性，两个一乘，就是第i为k的数的个数了

额以下的数码的意思就是我们把b的前i位/后i位写下来，形成的那个十进制数字

那么假如k比b的第i位小的话，k后边的数可以从00……-99……随便取，因为这一位已经小了，所以后边如何取都不会影响大小，所以后边的方案数是$10^{i-1}$
现在的问题就是如何取前面的数，发现只需要前面的数码<=b的数码就可以了，因此一共有$b/10^{i}+1$种方案，加的1是因为前导0也属于一个合法的方案

如果k比b这一位的大的话后边的也是可以随便取的，因为前面已经大了，所以后边如何取也不会影响大小，因此还是有$10^{i-1}$的方案数，但是前面的数吗不可以取等，因此方案数就是$b/10^{i}-1+1=b/10^{i}$同理+1也是因为前导0也属于一个合法的方案

现在是最为辣手的情况了，如果k和b的这一位相等，那么首先我们按大于的时候处理当然是满足条件的，但是还有一种情况，如果前面的东西取了等，此时我们后边的数字如果小于b后边的数码当然是可以的，为此我们先按大于的公式计算一波，最后在加上b后i-1位的数码，这个可能需要递推

最后特判一发最高位不可以是0就行了~

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=15;typedef long long ll;
ll lim[N];ll suf[N];ll mi[N];ll pre[N];ll res[2][N];int n;ll a;ll b;
inline void solve(ll x,ll* res)
{
    for(n=1;x;n++,x/=10LL){lim[n]=x%10LL;}n--;suf[n+1]=0;pre[0]=1;
    for(int i=1;i<=n;i++){pre[i]=suf[i]=0;} 
    for(int i=1;i<=n;i++){pre[i]=pre[i-1]+lim[i]*mi[i-1];}//这里直接递推了前i位和后i位的数码 
    for(int i=n;i>=1;i--){suf[i]=suf[i+1]*10LL+lim[i];}
    for(int i=1;i<=n;i++)
    {
        if(i!=n)//判一下0 
        {
            if(lim[i]!=0){res[0]+=mi[i-1]*suf[i+1];}
            else {res[0]+=mi[i-1]*(suf[i+1]-1)+pre[i-1];} 
        }
        for(int j=1;j<=9;j++)//然后分3种情况讨论就行啦 
        {
            if(j>=lim[i]){res[j]+=mi[i-1]*suf[i+1];}//case1 
            else {res[j]+=mi[i-1]*(suf[i+1]+1LL);}//case2 
            if(j==lim[i]){res[j]+=pre[i-1];}//case3
        }
    }
}
int main()
{
    scanf("%lld%lld",&a,&b);mi[0]=1;
    for(int i=1;i<=13;i++){mi[i]=mi[i-1]*10LL;}//这里预处理下10的幂次 
    solve(b,res[0]);solve(a-1,res[1]);//然后solve两发就可以解决啦~ 
    for(int i=0;i<=9;i++){printf("%lld ",res[0][i]-res[1][i]);}return 0;//拜拜程序~ 
}
```

---

## 作者：henrytb (赞：15)

**[进入blog获得更好的阅读体验](https://blog.henrytb.ml/2020/03/%E9%A2%98%E8%A7%A3-LuoguP2602-ZJOI2010-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/)**

[题目传送门](https://www.luogu.com.cn/problem/P2602)

题意：给定两个正整数 $a$ 和 $b$ ，求在 $[a,b]$ 中的所有整数中，每个数码各出现了多少次。

数据范围：$a\le b\le 10^{12}$

首先，这道题显然是数位 DP 的套路题（统计某个区间内满足某个性质的数有多少之类的题基本都是数位DP）。

设状态 $f[i][sum]$ 表示已经考虑到了前 $i$ 位，目前的某个数码 $d$ 的个数为 $sum$ 。

我们可以转移：$f[i][sum]=\sum f[i-1][sum-(now==d)]$ ，其中 $now$ 表示考虑的第 $i$ 位上的数码。

采用记忆化搜索进行转移处理数位 DP 是很方便的，具体实现见代码（有注释）：

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
int a,b;
int f[15][15][2][2];
int tot=0,num[15];
int dp(int x,int sum,int d,bool lim,bool zer) {
    /*
    x表示当前到了第几位，sum表示当前答案，d表示需要处理个数的数码，
    lim表示是否在上界，zer表示是否为前导0。
    */
    if(x==0) return sum;
    //递归到终点了，返回答案
    if(~f[x][sum][lim][zer]) return f[x][sum][lim][zer];
    //给f数组加入了lim和zer两个0/1量来保证返回的数据是符合当前条件的。
    int ans=0;
    rep(i,0,lim?num[x]:9) {
        //这里判断lim是为了处理在上界时只能for到b的那一位的情况。
        if(zer&&i==0) ans+=dp(x-1,sum,d,0,1); //前导的0不计入答案。
        else ans+=dp(x-1,sum+(i==d),d,lim&&(i==num[x]),0);
    }
    return f[x][sum][lim][zer]=ans; //赋值用于记忆化。
}
int sol(int d,int x) {
    memset(f,-1,sizeof(f));
    tot=0;
    while(x) num[++tot]=x%10,x/=10; //拆位。
    return dp(tot,0,d,1,1);
}
signed main(){
    scanf("%llu%llu",&a,&b);
    rep(i,0,9) printf("%llu ",sol(i,b)-sol(i,a-1));
    return 0;
}
```

---

## 作者：Bn_ff (赞：9)

### [P2602 [ZJOI2010]数字计数](https://www.luogu.com.cn/problem/P2602)

--------

## Solution

此题解仅讲想法，不讲有关数位 $dp$的基础知识或写法，如果还没有学过数位 $dp$ 的可以先看别的题目

**看到题解里用 $dfs$ 做的都是设的两维或以上的状态，实际上这道题只需要一维状态就够了**

设目前已经填到了第 $pos$ 位，则不管 $num\  -\!-\  \ pos + 1$ 位上填的是什么，之后的 $1\ -\!-\ pos$位上的贡献是不变的（除非是已经到了 $limit$ 的限制了，这个之后再讨论）

那么状态很明显为 $f[pos]$ 

$eg:$现在要填五位的数，目前状态为 $12XXX$， $limit$ 为 $30000$，则后面的三位可以直接由 $f[3]$ 转移过来，因为这属于子结构，不对前面造成影响

为什么可以这样转移？

前面所填的数（类似于 $eg$ 中的 $12XXX$ 的 $12$）的贡献如何计算？

我们可以发现，对于 $12XXX$ 中 第四位上的 $2$ 的贡献，是 $10^{pos - 1}$ 的。因为 $12XXX$ 的后三位可以填 $000$ - $999$ 中的任意一种，则第四位的 $2$ 就被计算了 $10^3$ 次，即贡献就是 $10^{pos - 1}$。**注意：这里所讨论的 $2$ 的贡献值，仅考虑第四位上的 $2$** ，对于后面位置上的为子结构，在之后会考虑到，而前面位置上的，在之前已经预先考虑过了，所以不会重复也不会漏情况。

现在再来讨论 $limit$ 的限制情况。

假设将 $eg$ 中的 $limit$ 改为 $12300$，则填后三位时就只能填 $000$ - $300$，总共是 $12300 - 12000 + 1$ 种，于是只用在计算贡献时加这样一个判断就可以了。

-------
## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i, x, y) for(int i = x; i <= y; ++ i)
using namespace std;
const int N = 15;
ll L, R;
int cnt[N];
ll f[N];
ll add(int pos)//计算lim限制时的贡献
{
    ll ans = 0;
    for(int i = pos - 1; i >= 1; -- i) ans = ans * 10 + cnt[i];
    return ans + 1; 
}
ll dp(int pos, int x, int lim, int last)
{/* pos为第几位  x为现在在算的数码
	lim为是否为限制 last为上一次的值（处理前导零）*/
    if(! pos) return 0;
    if(! lim && f[pos] != -1 && last != 10) return f[pos];
    ll ret = 0;
    F(i, (last == 10 ? 1 : 0), (lim ? cnt[pos] : 9))
    {
        if(i == x && (i != cnt[pos] || ! lim)) ret += pow(10, pos - 1);
        else if(i == x) ret += add(pos);//分情况计算贡献
        ret += dp(pos - 1, x, lim && i == cnt[pos], i);
    }
    if(last == 10) ret += dp(pos - 1, x, 0, last);
    if(! lim) f[pos] = ret;
    return ret;
}
ll work(int x, ll r)
{
    memset(f, -1, sizeof(f));
    int num = 0;
    for(r; r; r /= 10) cnt[++ num] = r % 10;
    return dp(num, x, 1, 10);
}
int main()
{
    cin >> L >> R;
    F(i, 0, 9) printf("%lld ", work(i, R) - work(i, L - 1));
    printf("\n");
    return 0;
}
```
------
## Thanks
如果有任何疑问欢迎提出或和我一起讨论(′▽`〃)

---

## 作者：CalcMaster (赞：9)


##  题目1（模板）:
[0-9的数量](https://www.51nod.com/Challenge/Problem.html#!#problemId=1042)

[P2602](https://www.luogu.org/problemnew/show/P2602)
(两题一样的）

给出一段区间a-b，统计这个区间内0-9出现的次数.

比如 10-19，1出现11次（10,11,12,13,14,15,16,17,18,19,其中11包括2个1)，其余数字各出现1次.

从各位向前依次编号.

## 题目2：不要62
[不要62](https://vjudge.net/problem/HDU-2089)

杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）.

杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众.

不吉利的数字为所有含有4或62的号码.例如：
62315 73418 88914

都属于不吉利号码.但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列.

你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了. 


# dp数组
dp[pos][sum]. 两个参数。

一个是当前枚举的位数（pos）

dp[pos][sum]整个表达的意思就是pos之前出现了dp[pos][sum]个sum。



# 拆数.

如30000-30099和20000-20099中1的个数是相同的（但是0的个数就不一样）

根据这个规律，就可以进行记忆化搜索.我们只用求出一部分的解，同类的就可以直接算.



故可以把所有的数拆开.

0-123456 中 1 的个数.

100000 - 109999

110000 - 119999

120000 - 129999

120000 - 120999

 ...
  

# limit状态.
在 00000 - 99999 这些数中。每一位最高都可以取到9.则称它们不是limit状态。

但是在 10000 - 19999 这些数中，第一位最大只能取到1，则称它是limit状态。

是否是limit状态，由输入的数决定。

比如要求 10000 - 12345 中 1 的数量。

我们可以把 12345 拆开来。

10000 - 19999 (x.第二位收到了限制。不能取到9)

10000 - 10999（第二位收到限制。只能苦逼的去统计。那么就往后一位。）

10000 - 11999

10000 - 12999（x.第三位受到限制。第三位最高为3.故也是要再往后一位分）

...

limit状态不能更新dp数组。（想一想，为什么）




 特殊情况：（只针对于题1.）
 **前导0的问题.**

 由于**0的个数也要统计进去**，故 000001 和 001 和 1 是不一样的.
 但是对于其他的题，没叫你统计每个数字出现的次数.这样 00001 和 001 都一样了.它们都代表1.这样就可以取消判断是否是前导0的这一状态.

 前导0状态不能更新dp数组。（想一想，为什么）




### 如果碰到了一些改过的题目（“不要62”）

就需要. 

# ***加参数!加特判***
如"不要62"这道题,只要特判4，并在搜索中加一个参数记录上一个搜到的数.



此为**本题**代码（抄题解会AC~~萎~~)

```cpp
#include <bits/stdc++.h>
using namespace std;

long long dp[20][20],digit[20];

long long dfs(int pos ,int sum,int num,int zero,int limit)//记忆化搜索
//pos ：当前位
//sum ：当前位前面有的num的个数.
//num ：正在统计的数出现的个数（0-9）
//zero ：当前位是否是前导0状态.（此状态可以才“不要62”等题目中去掉.而需要才这道题中保留.想一想为什么.）
//limit ：当前位是否达到了最大限制.
{
	if(pos<0)//最小拆到0位.
		return sum;
	if(!limit&&dp[pos][sum]!=-1&&!zero)//记忆化搜索!已经算过了.直接返回.
    //zero代表当前是不是前导0.
    //limit代表是否有最大数的限制.
		return dp[pos][sum];//前面有sum个num,修改前面pos位.
	long long ed,i,ret=0;
	if(limit)//如果最大有限制(比如12345有限制而12999没限制(在第三位))
    //当前位有没有到最大值.
    //确定当前pos位能选到几
		ed=digit[pos];
	else
		ed=9;
	for(i=0;i<=ed;i++)
	{
		if(zero)
		{
			if(i==0)
				ret+=dfs(pos-1,sum,num,1,limit&&i==ed);
			else
				ret+=dfs(pos-1,sum+(i==num?1:0),num,0,limit&&i==ed);
		}
		else
		{
			ret+=dfs(pos-1,sum+(i==num?1:0),num,0,limit&&i==ed);
		}
	}
	if(!limit&&!zero)
		dp[pos][sum]=ret;
	return ret;
}

long long cal(long long x,int num)
{
	memset(dp,-1,sizeof(dp));
	int pos=0;
	while(x)
	{
		digit[pos++]=x%10;//数位数组
		x/=10;
	}
	return dfs(pos-1,0,num,1,1);
}

int main()
{
	long long a,b,i;
	while(cin>>a>>b)
	{
		for(i=0;i<=9;i++)
			cout<<cal(b,i)-cal(a-1,i)<<endl;
            //0-b中i的个数-0-(a-1)中i的个数.
	}
}
```






---

## 作者：大奕哥 (赞：8)

对于一个数ABCD当从A运行到B时  你可以看成1~A000-1和A000~ABCD两个部分

你先预处理出来 1~9,1~99,1~999。。。的每个数字个数

然后你可以把1~A000看成A个0~999  紧接着你再看最高位0~A-1每个都出现过1000次

再单独加上  然后最高位A出现了BCD次  再单独加上  每一位都做这三次运算

然后你可以发现做到B~C时就不用管A了  每一次都减少对一位的考虑

最后对于前导零的处理是核心  我们一开始把零看成和其他数一样

承认00CD这样的数存在  所以我们可以发现

对于一个N位数的数字他的前导零的个数是一定的

10^n-1+10^n-2+……+10^0

再把这个减掉就是零的个数了



```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
ll cnta[11];
ll cntb[11];
ll f[20][20];
ll t[20];
ll s[20];
void solve(ll a,ll *cnt)
{
     int l=0;
     ll n=a;
     memset(s,0,sizeof(s));
     if(!n)
     s[++l]=0;
     while(n)
     {
         s[++l]=n%10;
         n/=10;
     }
     for(int i=l;i>=1;i--)
     {
         for(int j=0;j<=9;j++)
         cnt[j]+=s[i]*f[j][i-1];
         for(int k=0;k<s[i];k++)
         cnt[k]+=t[i-1];
         ll q=0;
         ll d=i-1;
         for(;d>=1;d--)
         {
             q=q*10+s[d];
        } 
         cnt[s[i]]+=q+1;
         cnt[0]-=t[l-i];
     }
//     cnt[0]=cnt[0]-t[l-1];
}
int main()
{
    ll a,b;
    cin>>a>>b;
    t[0]=1;
    for(int i=1;i<=19;i++)
    {
        for(int j=0;j<=9;j++)
        f[j][i]=10*f[j][i-1]+t[i-1];
        t[i]=t[i-1]*10;
    }
    solve(a-1,cnta);
    solve(b,cntb);
//    cout<<cnta[0]<<endl;
    for(int i=0;i<=9;i++)
    cout<<cntb[i]-cnta[i]<<" ";
    system("pause");
    return 0;
}
```

---

## 作者：zmzx (赞：7)


设f[i][j][k]表示 长度为i,最高位为j的含有的k的个数；
为什么这么设呢，首先，根据数位dp的套路，要记录长度，其次，要记录最高位来确定数的大小，第三维则是根据此题的需要来设的（因为要求0~9的个数）；

考虑状态转移，当i=1时，显然有f[1][j][j]=1;(0<=j<=9)

当j!=k时，f[i][j][k]=∑f[i-1][0~9][k];

特殊的，当j==k时，因为最高位已经有一个j,低位无论取什么都最高位对答案都会有1的贡献，所以f[i][j][j]还要加上10^(i-1）;

代码

```
inline void prework()
{
	for(int i=0;i<=9;i++)f[1][i][i]=1;
	for(int i=2;i<=12;i++){
		for(int j=0;j<=9;j++){
			for(int k=0;k<=9;k++){
				for(int w=0;w<=9;w++){
					f[i][j][w]+=f[i-1][k][w];
				}
			}
			f[i][j][j]+=ksm(10,i-1);//特殊转移； 
		}
	}
}
```


求出f后,因为是数位dp,所以我们用cnt(x,k)求出在区间1~x-1内k的个数，最终k的个数就是cnt(r+1,k)-cnt(l,k);

```
inline ll cnt(ll x,int k){
	ll anss=0;
	len=0;
	while(x){
		a[++len]=x%10;x/=10;//将x分解； 
	}
	for(int i=1;i<=len-1;i++){
		for(int j=1;j<=9;j++)anss+=f[i][j][k];//长度小于len的肯定会计入答案； 
	}
	for(int i=1;i<a[len];i++){ //长度等于len的，最高位小于len的，也要计入答案； 
		anss+=f[len][i][k];
	}
	for(int i=len-1;i>=1;i--){  //最难处理的一部分，长度为len, 最高位为a[len]; 
		for(int j=0;j<a[i];j++){ //从高位向低位枚举，此时第len~i+1位为a[len]~a[i+1]; 
			anss+=f[i][j][k];
		}
		for(int j=len;j>i;j--)if(a[j]==k)anss+=a[i]*ksm(10,i-1);//若最高位为k,也要计入答案； 
	}
	return anss;
}
```

然后是总代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
ll f[15][15][15];//长度为i,最高位为j,含有f个k; 
ll ans[15],b[15];
ll l,r;
inline ll ksm(ll x,int y){
	ll anss=1;
	for(;y;y>>=1){
		if(y&1)anss*=x;
		x*=x;
	}
	return anss;
}
inline void prework()
{
	for(int i=0;i<=9;i++)f[1][i][i]=1;
	for(int i=2;i<=12;i++){
		for(int j=0;j<=9;j++){
			for(int k=0;k<=9;k++){
				for(int w=0;w<=9;w++){
					f[i][j][w]+=f[i-1][k][w];
				}
			}
			f[i][j][j]+=ksm(10,i-1);//特殊转移； 
		}
	}
}
int a[15],len;
inline ll cnt(ll x,int k){
	ll anss=0;
	len=0;
	while(x){
		a[++len]=x%10;x/=10;//将x分解； 
	}
	for(int i=1;i<=len-1;i++){
		for(int j=1;j<=9;j++)anss+=f[i][j][k];//长度小于len的肯定会计入答案； 
	}
	for(int i=1;i<a[len];i++){ //长度等于len的，最高位小于len的，也要计入答案； 
		anss+=f[len][i][k];
	}
	for(int i=len-1;i>=1;i--){  //最难处理的一部分，长度为len, 最高位为a[len]; 
		for(int j=0;j<a[i];j++){ //从高位向低位枚举，此时第len~i+1位为a[len]~a[i+1]; 
			anss+=f[i][j][k];
		}
		for(int j=len;j>i;j--)if(a[j]==k)anss+=a[i]*ksm(10,i-1);//若最高位为k,也要计入答案； 
	}
	return anss;
}
int main()
{
	scanf("%lld%lld",&l,&r);
	prework();
//	for(int i=1;i<=2;i++){
//		for(int j=0;j<=9;j++){
//			for(int k=0;k<=9;k++){
//				printf("%d %d %d %lld\n",i,j,k,f[i][j][k]);
//			}
//		}
//	} //check f;
	for(int i=0;i<=9;i++){
		ans[i]=cnt(r+1,i)-cnt(l,i);//数位dp一般套路，每次计算不包括上界,令cnt(r+1)-cnt(l);
	}
	for(int i=0;i<=9;i++)printf("%lld ",ans[i]);
	return 0;
}
```



---

## 作者：crashed (赞：5)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P2602)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~震惊，菜鸡居然肝了一道（老掉牙的）省选题。~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~其实我也不太清楚我的具体思路。~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这道题，也许各位都会想到数位$DP$之类的吧。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我不会呀......   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以还是从头开始吧。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，用差分，把原问题变成求$[0,X]$中某个数码出现的个数。然后对于$0$特判，变成求$[1,X]$中某个数码出现的个数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步，暴力枚举每个数肯定是不行的。所以我们考虑十进制上一位一位地跳。设$f(i,j,k)$表示在$[1,j\times10^i]$中数码$k$出现的次数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移的话很难写出具体的式子，我就用语言解释一下吧。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~虽然任何用自然语言解释做题思路的尝试都是徒劳~~。    
### f的预处理
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(0)$的一大堆东西是可以初始化出来的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若$k>0$：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑在第$i$位上从$1$一个数一个数地跳到$9$。首先要从$f(i-1,9,k)$跳到$f(i,1,k)$。实际上就是$f(i,1,k)=f(i-1,1,k)+f(i-1,9,k)$，当$k$为$9$时需要加上$9$作第$i-1$位时的数量。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（$i-2$位之后的东西不会有大的影响。$f(i-1,1,k)$中长$i-1$位的数只有$10^{i-1}$，而此时如果$k$为$1$，$10^{i-1}$的$1$自然就被转到了$10^i$上面的$1$去，$k$不为$1$时不影响）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来考虑当$j\le k$时和$j>k+1$的转移。其实和上面差不多，也是$f(i,j,k)=f(i,j-1,k)+f(i,1,k)-[k=1]$，后面那个东西是为了把$f(i,1,k)$中$10^i$中多的那个$1$去掉；当$j=k$时要单独把此时最高位的那个$k$补上（当然，$k\not=1$）。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑$j=k+1$时的转移。为什么要特殊考虑？因为这个时候$k$要当第$i$位了。影响也不大，也就是要多加上一个$10^i-1$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后$f$就顺利地处理完......一小半了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若$k=0$：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这才是$f$的处理中最大的难点。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样先考虑$f(i,1,0)$。一波乱搞之后你可能会感觉$f(i,1,0)=f(i-1,9,0)+f(i-1,1,0)+1$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（$i-2$位以下的算在了$f(i-1,1,0)$里面；而$10^{i-1}$里面只比$10^i$少一个$0$，所以补上就可以了）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后你还会发现，现在算出来的东西跟实际值......相差很大。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为你还没有考虑$0$表示中间占位符的情况鸭！  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也不难。直接枚举中间$0$串的长度，假设为$j$，那么后面就会有$10^{i-j}-10^{i-j-1}$个数满足前面会有$j$个$0$。累加起来补到$f(i,1,0)$里面就可以了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑从$1$跳到$9$。类似上面的，$f(i,j,0)=f(i,j-1,0)+f(i,1,0)$，再把缺的中间占位$0$按照上面的方法补回去。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;休息一会儿吧，$f$总算是处理完了，下面开始解决原问题了。~~大概会花掉两倍于解决$f$的时间。~~  
### 原问题
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑把原问题变成如下的子部分：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~我已经不太会解释为什么了，直接写思路吧，模拟一下就懂了。~~    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.对于每一位$X_i$（$X$就是区间的上界，$i\in[0,\lfloor \lg X\rfloor]$），在答案中累加$f(i,X_i,k)$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.对于每一个$X_i=k$，在答案中累加$X$的后$i-1$位。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.**（划重点）** 如果$k=0$，特殊考虑中间的占位$0$：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从数字的最高位开始向低位枚举，枚举那些非$0$位。对于每一个非$0$位，枚举它后面的$0$串的长度。设当前非$0$位为$i$，下一个非$0$位为$j$，则$0$串的长度不能超过$i-j-1$。当$0$串长度$l<j$时，满足前面的占位$0$数量为$l$的个数就是$10^{i-l-1}-10^{i-l-2}$。当$l=j$是，数量就是$X$的后$j$位减掉$10^j+1$（不要忘了$j\in[0,\lfloor\lg X\rfloor]$）。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后恭喜你，你要$A$题了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~恭喜我自己，写完了。~~
# 代码
```cpp
#include <cstdio>

typedef long long LL;

const int MAXLEN = 20;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

LL DP[MAXLEN][10][10], p[MAXLEN];
LL las[MAXLEN];
int val[MAXLEN];
LL a, b;

void init()
{
	p[0] = 1;
	for( int i = 1 ; i <= 15 ; i ++ ) p[i] = p[i - 1] * 10;
	for( int j = 1 ; j < 10 ; j ++ )
	{
		for( int k = 1 ; k < j ; k ++ ) DP[0][k][j] = 0;
		for( int k = j ; k < 10 ; k ++ ) DP[0][k][j] = 1;
	}
	for( int i = 1 ; i <= 15 ; i ++ )
	{
		for( int j = 1 ; j < 10 ; j ++ )
		{
			DP[i][1][j] = DP[i - 1][9][j] + DP[i - 1][1][j];
			if( j == 9 ) DP[i][1][j] += p[i - 1] - 1;
			for( int k = 2 ; k <= j ; k ++ ) DP[i][k][j] = DP[i][k - 1][j] + DP[i][1][j] - ( j == 1 );
			if( j ^ 1 ) DP[i][j][j] ++;
			if( j == 9 ) break;
			DP[i][j + 1][j] = DP[i][j][j] + DP[i][1][j] - ( j == 1 ) + p[i] - 1;
			for( int k = j + 2 ; k < 10 ; k ++ ) DP[i][k][j] = DP[i][k - 1][j] + DP[i][1][j] - ( j == 1 );
		}
		DP[i][1][0] = DP[i - 1][9][0] + DP[i - 1][1][0] + 1;
		for( int j = 1 ; j < i - 1 ; j ++ ) DP[i][1][0] += ( i - 1 - j ) * ( p[j] - p[j - 1] );
		for( int j = 2 ; j < 10 ; j ++ ) 
		{
			DP[i][j][0] = DP[i][j - 1][0] + DP[i][1][0];
			for( int k = 1 ; k < i ; k ++ ) DP[i][j][0] += ( i - k ) * ( p[k] - p[k - 1] );
		}
	}
}

LL count( LL num, const int type )
{
	LL res = ! type;
	int len = 0, now;
	while( num )
	{
		now = val[++len] = num % 10;
		if( now == type && type ) res += las[len - 1];
		las[len] = las[len - 1] + p[len - 1] * now;
		res += DP[len - 1][now][type];
		num /= 10;
	}
	if( ! type )
	{
		int lp;
		for( int i = len ; ~ i ; i = lp )
		{
			lp = -1;
			for( int j = i - 1 ; j > 0 ; j -- )
				if( val[j] )
				{
					lp = j;
					break;
				}
			if( ! ( ~ lp ) ) break;
			for( int j = 1 ; j < lp ; j ++ )
				res += ( i - j - 1 ) * ( p[j] - p[j - 1] );
			res += ( i - lp - 1 ) * ( las[lp] - p[lp - 1] + 1 );
		}
	}
	return res;
}

int main()
{
	LL tmp1, tmp2;
	init();
	read( a ), read( b );
	for( int k = 0 ; k < 10 ; k ++ )
	{
		tmp1 = count( b, k );
		tmp2 = count( a - 1, k );
		write( tmp1 - tmp2 ), putchar( k == 9 ? '\n' : ' ' );
	}
	return 0;
}
```

---

## 作者：szr666 (赞：5)

我这里推荐一下[我的博客](https://www.luogu.org/blog/szr666--blog/)

在博客里观看更美观哦~

[题目](https://www.luogu.org/problemnew/show/P2602)
------------

------------

华丽的分割线
# 解析

### 预处理

设ten[i],表示10的i次方,ten[0]=1,ten[i]=ten[i-1]*10;

设cnt[i],表示第i种数出现的次数

设f[i],表示0~9...9(i个9),每个数出现的次数

包括前导0,则10个数出现的次数相同,

如f[1]=1,即0~9之中,cnt[0~9]=1
           
如f[2]=20,因为十位有十种选择,每种个位皆出现一次,即f[1]*10,

对于一种十位,个位都有十种选择,即ten[1]

所以f[2]=10*f[1]+ten[1]

更一般的,f[i]=f[i-1]*10+ten[i-1],这样f,ten数组都求了出来

### 分类讨论

求a~b之间的数码可转化为【0,b】(cntb[i])-【0,a-1】(cnta-1[i])(因为a~b包含a)

因为满足区间可减性,求出0~b之间的数减0~a-1之间的数即是答案

问题转化为求0~x之间数码的个数,这里以587为例,先考虑前导0

1.求000~099 ... 400~499之间十位个位数出现的次数

2.求000~099 ... 400~499之间百位数出现的次数

3.求0~87间的数出现的次数

操作3也就是分成求0~499 500~579 580~587之间数的个数

1.000~499 间百位有5种情况,十位个位0~99,即f[2]*5

把587分解为8 7 5,分别为c[0],c[1],c[2],则cnt[0~9]+=f[2]*c[2]

2.000~099有100种情况,百位0~4,则cnt[0~4]+=ten[2]

3.000~087有88种情况,cnt[5]+=88,在用同样方法求0~87即可

### 一般形式

对于第i位,从高向低枚举,i n->0,模拟操作3,先算0~499,再算500~579,再算580~587

其中n为当前数x的位数-1

操作一 j 0->9枚举,cnt[j]+=f[i]*c[i]

操作二 j 0->c[i]-1枚举,cnt[j]+=ten[i]

操作三 设tmp=c[1]*10+c[2]+1,即87+1=88 cnt[c[i]]+=tmp;

### 前导0

在000~099中多算了ten[2]个0,在00~09中多算了ten[1]个0

所以 j n->1 ,cnt[0]-=ten[j]

算出cnt后,用关于b的cnt减关于a-1的cnt即为答案

# 代码
```cpp
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
void read(ll &x)
{
    x=0;
    ll f;
    f=1;
    char c;
    c=getchar();
    while((c<'0'||c>'9')&&c!='-')
    {
        c=getchar();
    }
    if(c=='-')
    {
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    x=x*f;
}
ll cnt[20],ans[20],c[20],ten[20],f[20];
void work(ll x)
{
    memset(cnt,0,sizeof(cnt));
    int n,i,j;
    n=-1;
    ll tmp;
    if(x==0)
    {
        cnt[0]++;
    }
    while(x!=0)
    {
        n++;
        c[n]=x%10;
        x/=10;
    }
    for(i=n;i>=0;i--)
    {
        for(j=0;j<=9;j++)
        {
            cnt[j]+=f[i]*c[i];
        }
        for(j=0;j<c[i];j++)
        {
            cnt[j]+=ten[i];
        }
        tmp=0;
        for(j=i-1;j>=0;j--)
        {
            tmp=tmp*10+c[j];
        }
        cnt[c[i]]+=tmp+1;
    }
    for(i=n;i>=1;i--)
    {
        cnt[0]-=ten[i];
    }
}
int main()
{
    ll a,b;
    read(a);
    read(b);
    int i;
    ten[0]=1;
    for(i=1;i<=17;i++)
    {
        ten[i]=ten[i-1]*10;
    }
    for(i=1;i<=17;i++)
    {
        f[i]=f[i-1]*10+ten[i-1];
    }
    work(b);
    for(i=0;i<=9;i++)
    {
        ans[i]=cnt[i];
    }
    work(a-1);
    for(i=0;i<=9;i++)
    {
        ans[i]-=cnt[i];
    }
    for(i=0;i<=9;i++)
    {
        printf("%lld ",ans[i]);
    }
}
```





---

## 作者：Log_x (赞：4)

##数位DP

参考[http://blog.csdn.net/qq\_30401759/article/details/50638799](http://blog.csdn.net/qq\_30401759/article/details/50638799)，详细注释在代码中给出。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 15;
typedef long long ll;
ll f[N], tn[N], num[N], sta[N], stb[N], a, b;

inline ll get()
{
    char ch; bool f = false; ll res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}

inline void put(ll x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}

inline void Find(ll x, ll *st)
{
    if (x == 0) return;
    ll res = x; int m = 0;
    while (x) num[++m] = x % 10, x /= 10;
    //拆出每一位，记为num[i] 
    for (int i = 1; i < m; ++i)
    //对于1~m-1位数，我们不用考虑数的上限（<=x）, 所以可以先处理 
    {
        st[0] += (f[i - 1] << 3) + f[i - 1];
        //真正求解的时候不含前导0（第i位不存在0）， 
        //所以对于前i-1位存在的每一个数字（0~9），第i位只有9种可能。 
        //同时对于0，前i-1位的每一种排列方案也要排除。 
        for (int j = 1; j < 10; ++j) 
         st[j] += (f[i - 1] << 3) + f[i - 1] + tn[i - 1];
        
    }
    res -= num[m] * tn[m - 1]; //接下来我们考虑m位数 
    for (int i = 1; i < num[m]; ++i) st[i] += tn[m - 1];
    //对于第m位的1~num[m]-1（不含前导0）， 
    //前m-1位的每一种排列仍可直接算作一种方案。 
    for (int i = 0; i < 10; ++i) 
     st[i] += f[m - 1] * (num[m] - 1);
    //对于第1~m-1位出现的每一个数字， 
    //数字1~num[m]-1仍可直接算作一种方案。 
    st[num[m]] += res + 1;
    //保持最高位的上限数字不动， 
    //方案数即为扣除最高位的总方案数（0~res）。 
    for (int i = m - 1; i; --i)
    {
        res -= num[i] * tn[i - 1];
        //从高位删到低位， 
        //每一位都要像我们刚才的第m位处理，但不用考虑前导0。 
        for (int j = 0; j < num[i]; ++j) st[j] += tn[i - 1];
        for (int j = 0; j < 10; ++j) st[j] += f[i - 1] * num[i];
        st[num[i]] += res + 1;
    } 
     
}

int main()
{
    a = get(); b = get(); tn[0] = 1;
    //先计算出[1,a-1]，[1,b]中每个数字出现的个数，然后相减即可。 
    //问题变为：给一个数n，求1,2,…,n中每个数字出现的次数。  
    for (int i = 1; i < 15; ++i)
    {
        f[i] = (f[i - 1] << 3) + (f[i - 1] << 1) + tn[i - 1];
        //首先，允许前导0，也不考虑数大小的上限，设位数为 i。 
        //前i位每种数字出现的次数是相同的，记为 f[i]。 
        //不难得出递推式 f[i]=10*f[i-1]+10^(i-1)。 
        //10*f[i-1]表示对于前i-1位出现的每一个数字， 
        //第i位都存在10种方案（0~9）；
        //10^(i-1)表示对于第i位出现的唯一一个数字， 
        //前i-1位的每一种排列都算作一种方案。 
        tn[i] = (tn[i - 1] << 3) + (tn[i - 1] << 1);
    }  
    Find(a - 1, sta); Find(b, stb);
    for (int i = 0; i < 9; ++i) put(stb[i] - sta[i]), putchar(' '); 
    return put(stb[9] - sta[9]), 0; 
}
```

---

## 作者：归山_ (赞：3)

至于这道题吗，其实一开始我想的是数位dp

但是奈何我太菜了，只能依靠着仅存对数位dp的印象

自己yy出了一个好像是正确的算法

欢迎各位dalao来hack


------------
## 思路

可以分别统计[0，b]中包含多少个0~9，[0，a]中包含多少个0~9，两个求得的结果相减就是答案了。

         举例分析： 299 百位数字有0,1,2，那么它们在百位时分别出现了100次，再对十位数和个位数的99分析，因为[0,99]中0~9出现的频率都是一样的，

	分别为2（前一个数的值）*（位数）*10（固定一个数其余位能变化的次数）

         所以对于4567，我们可以这样拆：0~3999,4000~4499,4500~4559，~4560~4567 。求得得总和就是答案了
         
	还要注意一点的是前导0不能加进去，注意把加进去多余的前导0减掉。

	还有一点记得开longlong

这之后其实就没什么了我们直接输出就可以了



------------
## 至于stringstream
大家可以上网自行百度，但其实用处不是很大，就是图个方便
这里就给大家简便的说明一下

	利用输入输出做数据转换

 	str()清空流的内存缓冲

	stringstream ss_stream;
	ss_stream << i;   // 将int输入流中
	ss_stream >> str; // 将ss_stream中的数值输出到str中

	//注意：如果做多次数据转换；必须调用clear()来设置转换模式
	ss_stream << "456"; 
	ss_stream >> i;   // 首先将字符串转换为int
	ss_stream.clear();
	ss_stream << true;
	ss_stream >> i;   // 然后将bool型转换为int；假如之前没有做clear,那么i会出错

	//运行clear的结果 
	i = 456 
	i = 1 
	//没有运行clear的结果 
	i = 456 
	i = 8800090900
    
    

------------

# 代码

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<sstream>
#include<algorithm>
using namespace std;

#define int long long

int n,m;
string s;
int a[11],b[11];
 
void solve(string s, int *num){
    int pos=1;
    for(register int i=0;i<s.length()-1;i++) pos*=10, num[0]-=pos;
    for(register int i=0;i<s.length();i++,pos/=10){
    	for(register int j=0;j<s[i]-'0';j++) num[j]+=pos;
        for(register int j=0;j<10;j++) num[j]+=pos/10*(s.length()-i-1)*(s[i]-'0'); 
        for(register int j=0;j<i;j++) num[s[j]-'0']+=(s[i]-'0')*pos;  
        num[s[i]-'0']++;  
    }
}

inline int read(){
	int x=0,w=1,ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
	return w*x;
}
 
signed main(){
    n=read(),m=read();
    stringstream sn, sm;
    if(n>m) swap(n,m);
    sn<<(n-1);	 //向流中传值
    s=sn.str();  //str()清空流的内存缓冲
    solve(s,a);
    sm<<m;		 //向流中传值
    s=sm.str();	 //str()清空流的内存缓冲
    solve(s,b);
    for(register int i=0;i<10;i++) cout<<b[i]-a[i]<<" ";
    cout<<'\n';
    return 0;
}
```

完结撒花！！！

祝大家csp++！！！

---

## 作者：学委 (赞：3)

因为 $a$ 这个限制比较麻烦，所以想到，设求出 $1$ 到 $n$ 的数码出现次数为 $ans(n)$，则答案是 $ans(b) - ans(a - 1)$。

对于**各个位置**上的**各个数字**分别考虑，好像稍微容易点。

```
n = 1832467
      ^
    在这个位置上，数字 1 一共出现多少次？
    意思就是，下面的叉叉有几种填写方法。
    xx1xxxx <= 1832467
    前两位可以填写 0 ~ 18，后四位可以填写 0 ~ 9999。注意 1819999 也没超过 1832647。
    
    那么数字 3 一共出现多少次？稍微有点不同。
    xx3xxxx <= 1832467
    前两位可以填写 0 ~ 17，后四位可以填写 0 ~ 9999。如果前两位是 18，后面四位受到限制，只能填写 0 ~ 2467。
    
    数字 4 一共出现多少次？
    xx4xxxx <= 1832467
    前两位可以填写 0 ~ 17，后四位可以填写 0 ~ 9999。然而，前两位不能填 18，否则直接超出限制。
    
    然而数字 0 特立独行：
    xx0xxxx <= 1832467
    前面并不能填 0（否则在组成的数字中，自己是前导零），倒是可以填 1 到 18（自己不是前导零）；后接 0 到 9999。所以 0 的出现次数是 18 × 10000。

n = 1832467，处理第三位的具体方法：
      ^
    获取这位的数字 3。
    获取左边的数字 18。
    获取右边的数字 2467。
    
    数码 0 在这位上总共出现 18 × 10000 次。
    数码 1 ~ 2 在这位上总共出现 19 × 10000 次。
    数码 3 在这位上总共出现 18 × 10000 + 2468 次。
    数码 4 ~ 9 在这位上总共出现 18 × 10000 次。
```

```cpp
#include <cstdio>

typedef long long LL;

LL ten[20], cnt[10];

void process(LL n, LL sign) { // sign 用来控制加减 
  for (LL bit = 0; ten[bit] <= n; ++bit) {
    LL k = n / ten[bit] % 10, l = n / ten[bit + 1], r = n % ten[bit];
    
    if (k == 0) { // k = 0 最好特判一下。例如 n = 180233，处理第三位……
      // ……此时，k = 0, l = 18, r = 233
      if (l > 0)
        cnt[0] += (l - 1) * ten[bit] * sign;
        // 前面 0 不能填，1 ~ 17 可以填，后接 0 ~ 999
      cnt[0] += (r + 1) * sign; // 前面填 18，后接 0 ~ 233 
    }
    else { // 以下是正常情况下的结论
      cnt[0] += l * ten[bit] * sign;
      
      cnt[k] += l * ten[bit] * sign;
      cnt[k] += (r + 1) * sign;      
    }
    
    for (int d = 1; d <= k - 1; ++d)
      cnt[d] += (l + 1) * ten[bit] * sign;
    
    for (int d = k + 1; d <= 9; ++d)
      cnt[d] += l * ten[bit] * sign;
  }
}

int main() {
  ten[0] = 1;
  for (int i = 1; i <= 18; ++i)
    ten[i] = ten[i - 1] * 10;
  
  LL a, b;
  scanf("%lld %lld", &a, &b);
  process(b, 1);
  process(a - 1, -1);
  
  for (int i = 0; i <= 9; ++i)
    printf((i == 9) ? "%lld\n" : "%lld ", cnt[i]);
  return 0;
}

```

---

## 作者：唔啊唔 (赞：3)

这道题目的题解似乎有点多耶（27篇）

而且[第一篇题解](https://www.luogu.org/blog/mak2333/swdp001)还写得还这么好

不知道管理员大大会不会让我通过呢

但第一篇题解还是有一些美中不足的地方

所以，我不得不承认我是借鉴了第一篇题解才做出了这道题，

我保证只看了一眼，只有一眼！！！

第一篇题解中有一个这样的柿子（~~式子~~）：

f[i]=f[i-1]*10+10^(i-1);

但作者并没有仔细解释所以我便来为大家解释一通

```cpp
    f[i]=f[i-1]*10+10^(i-1);
    我们首先以1为例子来讲一下 
    f[1]=1; 当只有一位数的时候只有1带有一个1 
    1
    f[2]=10+10=20
    先讲一下f[i-1]*10是什么意思
    f[i-1]代表上一个位数的1出现次数 
    那么我们先列举上一个位数中带有1的数
    1
    我们可以将这些带有1的数的前面加上(0~9)中的任意一个数
    就构成了10个拥有此数量1的数字
    01 11 21 31 41 51 61 71 81 91 (这里只算上了11的后面一个1) 
    有的同学会问11是那个带有1的数的前面加上了一个1，为什么没有加上这个1呢？
    很好，这个操作就隐藏在下一个操作之中
    10^(i-1)这便是从一位数到上一个位数的所有数的总和(含前导0数) 
    我们在每个数的前面加上一个1，这样便多出了10^(i-1)个1 
    10 11 12 13 14 15 16 17 18 19 (这里11的后面一个1不会被算上，只算上前面一个1) 
    大家可以数一数1在这些数中刚好出现20次
    0~9的计算方法与1一样 
    看来(打表+大眼观察法)还是有点用处呢 
```

还有求一个数的所有数位之和的求法

我在代码中也会稍稍解释

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,t[20],f[20];
long long ans[20][3],wei[20];
inline void solve(long long x,int bj){	//bj为数组标记 
	memset(wei,0,sizeof(wei));	//记得更新wei(数位)数组 
	int len=0;
	while(x>0){
		len++;
		wei[len]=x%10;
		x/=10;
	}
	for(register int i=len;i>=1;i--){	//由于我们是在数的前面加数所以要从前往后循环
		for(register int j=0;j<=9;j++){	
			ans[j][bj]+=f[i-1]*wei[i];	//原来是乘10,但由于现在限定了范围,例如666 那么就不能在66之前加上一个7,8,9 注意这里6也没有加上去哦,因为如果出现67~99那么就不能在67~99前加6,否则会超出范围
		}
		for(register int j=0;j<wei[i];j++){	//理由同上,被限定了范围只有wei[i]以下的数才可以
//但这里为什么不是j<=wei[i]呢,因为例如666,你可以在00~66之前加一个wei[i]可是如果是67~99就不行了 
			ans[j][bj]+=t[i-1];
		}
//所以多出来的00~66会在下面解决 
		long long num=0;
        for(int j=i-1;j>=1;j--){
            num=num*10+wei[j];	//6*10+6=66 
        }
        ans[wei[i]][bj]+=num+1;	//加一应该是还要算上00吧 
        ans[0][bj]-=t[i-1];		//去除前导0,我们不能在数前面加上0,只能在携带0的数的前面加上1~9的任意数 
	}
}
int main(){
	cin>>a>>b;
	t[0]=1;
	for(register int i=1;i<=15;i++){	//这里解释的足够清楚 
		t[i]=t[i-1]*10;
		f[i]=f[i-1]*10+t[i-1];
	}
	solve(a-1,1);	//由于要算上a所以一定不要忘了让a-1 
	solve(b,2);
	for(register int i=0;i<=9;i++)
		printf("%lld ",ans[i][2]-ans[i][1]);
//这个printf中的lld我写成了ld直接WA了7个点卡了我30分钟,最后照着第一篇题解再打了一遍所以长得很像,希望谅解 
	return 0;	//恭喜你又完成一道紫题 
}
```

总感觉自己说错了一些东西，如果有同学发现了请私信我

谢谢

---

## 作者：chuyilin0109 (赞：2)

大佬们的题解太强了orz，我只能尝试尝试暴力做法%%%

思路参见思维题——51Nod 1009-数字 1 的数量

利用算1的方式算2~9的个数，再用总位数减掉1~9即为0的数量

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll sum[10];
ll sum1[10];
ll len,len1;
ll num[20],num1[20];
ll n,m,m1,n1,h,ans,ans1;
ll f[15],ff[15];
ll fff[15];
int weishu(ll x)//算该数位数有多少
{
    int len=0;
    while(x)
    {
        num[++len]=x%10;
        x=x/10;
    }
    return len-1;
}
void init()//预处理总数
{
    f[1]=9;
    for(int i=2;i<=13;i++)
    {
        f[i]=f[i-1]*10;//i位数的个数
    }
    for(int i=1;i<=13;i++)
    {
        ff[i]=i*f[i];//i位数的总位数
    }
    for(int i=1;i<=13;i++)
    {
        fff[i]=fff[i-1]+ff[i];//求前缀和
    }
}
void solve(ll g,ll t[])//参见思维题
{
    for(int i=1; i<=9;i++)
    {
        n=g;
        h=1;
        while(n)
        {
            int ys=n%10;
            if(ys>i)
                t[i]+=(g/(h*10)+1)*h;
            else if(ys==i)
            {
                t[i]+=(g/(h*10))*h;
                t[i]+=(g%h)+1;
            }
            else
                t[i]+=(g/(h*10))*h;
            h*=10;
            n/=10;
        }
    }
}
int main()
{
    init();
    scanf("%lld%lld",&m,&m1);
    m--;
    int flag=1;
    if(m==0) flag=0;//包括m侧

    int len=weishu(m);
    int len1=weishu(m1);

    ans=fff[len]+(m-pow(10,len)+1)*(len+1);//算总位数
    ans1=fff[len1]+(m1-pow(10,len1)+1)*(len1+1);

    solve(m,sum);
    solve(m1,sum1);

    for(int i=1;i<=9;i++)//算0的数量
    {
        ans-=sum[i];
    }
    for(int i=1;i<=9;i++)
    {
        ans1-=sum1[i];
    }
    if(flag==0)
    {
        memset(sum,0,sizeof(sum));
        ans=0;
    }
    printf("%lld ",ans1-ans);
    for(int i=1;i<=9;i++)
    {
        i==9 ? printf("%lld\n",sum1[i]-sum[i]):printf("%lld ",sum1[i]-sum[i]);
    }
    return 0;
}

```



---

## 作者：龟龟我的龟龟 (赞：2)

我是参照**“ac机”的题解**解的（%%%）

	数位dp：就是按照数位（个十百位等进行dp）
	本题显然用1-right区间出现的次数减去1-left区间出现的次数（~~一开始我还是没有想到~~）
	所以，问题从“变化的区间”变成了“1-某个数字”的区间
	dp过程：从个位开始计算0-9出现个位的数字总和
------------
	这里用345举例：

	个位：显而易见a[10]={34,35,35,35,35,35,34,34,34,34};易知：由于前缀零的关系，0的位置对比
    1-5位置少了一次，而6-9由于不存在346-349的数字，对比1-5位置也少出现了一次

	十位：a[10]={30,40,40,40,35,30,30,30,30,30};当然，在计算过程重要加
    个位的数组a

	百位：a[10]={0,100,100,46,0,0,0,0,0,0};

	对单个数字来说（eg：5）

	个位：5，15，25 ... 345共35个
	十位：50-59，150-159 ... 250-259共30个
	百位：共0个

	这样规律差不多就出现了

	对于某个位（个十百）的某个数字（0-9）（记作i）次数的计算，要判断与
    当前位置上数字（记作temp）的关系，（并且记temp数字之前的数字为front，之
    后为next，所在位的表示power，eg：1273718791，对于百位，temp=7，front=91，
    next=1273718，power=100）
    附带函数：
```cpp
void cul(long long n,long long* ans) {
	long long front = 0, next = n, temp, power = 1, pos = 0;
	while (next != 0) {
		temp = next % 10;
		next /= 10;
		for (int i = 0; i < 10; ++i) {
			if (i > temp)pos = 0;//i和temp的关系卡死我了，一定要注意！
			if (i == temp) { pos = 0; ans[i] += (front + 1); }
			if (i < temp)pos = 1;
			if (!i)pos = 0;//前缀零处理！
			if (i == temp && !i) pos = -1;//当前位置为零且!i时也要特殊处理！
			ans[i] += ((next + pos < 0 ? 0 : next + pos) * power);
		}
		front += (temp * power);
		power *= 10;
	}
}
```
如有不对请多指教

---

## 作者：Sym_Je (赞：2)

             数位dp
   首先很容易发现这种题要么是数论，要么是贪心＋大模拟，我们可以发现这个贪心明显不可做，除非写12种贪心，发现代码太长了，数据也不大，呢就是数位dp咯。    
   首先我们考虑转移，我们发现我们有10个要转移的方向(1~10)，呢么我们如果写到一起，代码太长，呢么我们就一个一个写，我们需要转移啥呢?     
   1肯定是位置咯，从1--->2,i--->i+1号位置，第二我们需要再维护一个前i个中有j个为tot（当前需匹配的值）的方案数，我们来想想为啥要开这一组呢，因为我们需要使用记忆化搜索，如果我们通俗的把所有的都存入，同一个数组里dp[i],呢么我们转移的时候，就可能会多处非常多的不合法情况，就无法记忆化。     
   ?，一下就是套模板咯。    
   
   ```cpp
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iostream>

using namespace std;

long long dp[15][15];

long long l,r;
long long tot=0;

long long t[16];

long long num;
long long sum;
long long dfs(long long wz,long long lead,long long limit,long long sum)
{
	if(!wz)//边界
	{
		return sum;
	}
	if(dp[wz][sum]!=-1&&lead&&!limit)//常规操作都是给没有限制的记忆化
	{
		return dp[wz][sum];
	}
	long long cnt=0;
	int up=limit?t[wz]:9;
	for(int i=0;i<=up;i++)
	{
		cnt+=dfs(wz-1,lead||i,limit&&(t[wz]==i),sum+((i||lead)&&tot==i));
	}
	if(!limit&&lead)
	dp[wz][sum]=cnt;
	return cnt;
}

long long solve(long long x)
{
	memset(dp,-1,sizeof(dp));
	num=0;
	while(x)
	{
		t[++num]=x%10;
		x/=10;
	}
	return dfs(num,0,1,0);
    //num从后往前，因为我们第一个数其实被存入了最后一项。   
    //dfs(i,j,k,m);
    //i:到了第几项，j:判断前置0的，k：判断最大值的并帮助枚举的，m：当前出现tot的个数
} 

int main()
{
	scanf("%lld%lld",&l,&r);
	while(tot<=9)//从0~9开始枚举
	{
		printf("%lld ",solve(r)-solve(l-1));
		tot++;
	} 
	return 0;
}



```
   

---

## 作者：niolle (赞：2)

一道数位DP的板子题……
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define rep(i,a,b) for(long long i=a;i<=b;i++)
#define mod 1000000007
using namespace std;
typedef long long ll;
struct node
{
    ll s[10],r,sum;
    node operator +(node x)//重载+运算符，方便计算 
    {
        x.s[0]+=s[0];
        x.s[1]+=s[1];
        x.s[2]+=s[2];
        x.s[3]+=s[3];
        x.s[4]+=s[4];
        x.s[5]+=s[5];
        x.s[6]+=s[6];
        x.s[7]+=s[7];
        x.s[8]+=s[8];
        x.s[9]+=s[9];
        x.sum+=sum;
        return x;
    }
    node operator -(node x)//重载-运算符，方便计算 
    {
        x.s[0]=s[0]-x.s[0];
        x.s[1]=s[1]-x.s[1];
		x.s[2]=s[2]-x.s[2];
		x.s[3]=s[3]-x.s[3];
		x.s[4]=s[4]-x.s[4];
		x.s[5]=s[5]-x.s[5];
		x.s[6]=s[6]-x.s[6];
		x.s[7]=s[7]-x.s[7];
		x.s[8]=s[8]-x.s[8];
		x.s[9]=s[9]-x.s[9];
        return x;
    }
}dp[16][2];
ll power[106],m[106];
node dfs(ll t,ll b,ll z)//t表示此时记录到第t位，b表示此时是否可以记录b以下所有数（b=0则可以） ，z处理前导零 
{
    node ans;
    rep(i,0,9) ans.s[i]=0;
    ans.r=1;
    ans.sum=0;
    if(t==0)
    {
    	ans.sum=1;                 
    	return ans;
	}
    if(dp[t][z].r!=-1 && !b) return dp[t][z];//采取记忆化搜索优化时间 
    ll en=b?m[t]:9;
    rep(i,0,en) 
    {
        node tmp=dfs(t-1,b&&i==en,z&&i==0);
        ans=ans+tmp;
        if((!z || i>0)) ans.s[i]+=tmp.sum;//sum表示第t位以下一共的数； 
    }
    if(!b) dp[t][z]=ans;
    return ans;
}
node cnt(ll a)
{
    ll tot=0;
    while(a)//分解数位 
    {
        m[++tot]=a%10;
        a/=10;
    }
    return dfs(tot,1,1);
}
int main()
{
    ll a,b,n;
    power[1]=1;
    rep(i,2,15) power[i]=power[i-1]*10;
	rep(i,1,16)
        rep(j,0,1)
            dp[i][j].r=-1;
    scanf("%lld%lld",&a,&b);
    node hh=cnt(b)-cnt(a-1);
    rep(i,0,9)
    {
      	if(i!=0) printf(" ");
      	printf("%lld",hh.s[i]);
	}
}
```

---

## 作者：Plus_Ultra (赞：1)

### 题解：

1. 前言： 

- 数位DP是与数字相关的一类计数问题.这类问题通常都是给你几个限制和寻找范围，求满足限制的数的个数有多少.

- 面对这类问题，我们首先想到爆搜.不用想，肯定爆炸.于是乎我们来考虑优化方法.很容易可以想到：记忆化搜索！

- 不过并没有那么简单.有诸多限制，比如说搜索不能超过给定区间的范围，不能有前导0等等，这时我们就需要仔细考虑了.

- 我们尝试在记忆化搜索中记录这些限制，考虑如何转移即可.（尽可能把状态都记录下来）

2. 可以发现，像这类计数型问题，都是可以套模板的.我们先来分析一下模板.

- [博客食用口感更好哟](https://www.luogu.org/blogAdmin/article/edit/167531)

```
int DFS(int len,int limit,int lead,int ...各种限制)//len表示填数到了第几位,limit表示有无上界限制,lead表示有无前导0 
{
    if(len==0)return 1;//边界条件 
    if(!limit&&!lead&&dp[len][...]!=-1)//如果搜过并且没有上界限制和前导0,这一位可以随便填 
    return dp[len][...];//记忆化搜索 
    int maxx=limit?num[len]:9;//如果前一位有限制（填到了最高位）那么这一位不能超过num这一位的大小，否则0~9随便取 
    int res=0; 
    for(int i=0;i<=maxx;i++)
    {
        if(...)//限制条件 
        res+=DFS(len-1,limit&&(i==maxx),lead&&!i,...);//如果本位已经枚举到上界就把上界往后传,上一位有前导0而且这一位是0，那么下一位有前导0 
    } 
    if(!limit&&!lead)dp[len][...]=res;//因为如果枚举到上限则答案并不是这一位上所有的和，所以就不更新
	//着重分析这一句话：当有前导0或有上界限制时,下一位有不能填的数，而dp数组记录的是下一位能填0~9的数，所以不更新. 
    return res; 
}

int solve(int x)
{
    int len=0;//位数 
    while(x)//这里是预处理出每一位数的上界 
    {
        num[++len]=x%10;
        x=x/10;
    }
    return DFS(len,1,1,...);//有前导0和上界限制 
} 
int main()
{
    cin>>a>>b;
    cout<<solve(b)-solve(a-1)<<endl;//可以先求1~b中满足限制的个数，再求1~a-1中满足限制的数的个数，相减即可 
} 
```

有了模板之后，就不慌了.剩下处理一下小问题，套模板即可.

下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>
#include<cstring>

#define LL long long

using namespace std;

LL dp[15][15],a,b,num[15],lent; 

LL DFS(int len,int sum,int limit,int x,int lead)
{
	if(!len)  return sum;
	if(dp[len][sum]!=-1&&!limit&&!lead)  return dp[len][sum];
	LL res=0,maxx=limit?num[len]:9;
	for(int i=0;i<=maxx;i++)
	res+=DFS(len-1,sum+((!lead||i)&&(i==x)),limit&&(i==maxx),x,lead&&i==0);
	if(!limit&&!lead)  dp[len][sum]=res;
	return res;
}

LL solve(LL sum,int x)//我写了int sum,调了1个多小时...
{
	memset(dp,-1,sizeof(dp));
	lent=0;
	while(sum)
	{
		num[++lent]=sum%10;
		sum/=10;
	}
	return DFS(lent,0,1,x,1);
}

int main()
{
	cin>>a>>b;
	for(int i=0;i<=9;i++)
	cout<<solve(b,i)-solve(a-1,i)<<" ";//不需特判0 
		
	return 0;
} 
```

有同学说不需要记sum，我jio得是要记的，因为有limit限制和前导0限制，DFS到这一位时，我们不知道前面有没有限制，前面有没有限制是对后面填什么有影响的，所以要记一个sum.

去掉空行后30来行，比较短了.

### [Plus Ultra!!! ](https://www.luogu.org/blog/OnePunchManGO/)




---

## 作者：AmadeusSG (赞：1)

[hackblogs.home.blog](我的博客)

这道题是数位DP。

数位DP算是一种比较简单的dp了，直接往模版里代就可以了。

所以怎么代才是难点。

先根据差分思想，依次算出小于b和小于a-1的数码，再相减得出答案。

对于每次计算，我们只考虑一个数码，用for（1-9）计算每一个。

注意记忆化维护的状态为在没有限制的条件下记忆 位，出现次数，以及数码 


```
#include<bits/stdc++.h> 
#define ll long long
using namespace std;
ll a,b,n;
ll num[105];
ll dp[30][1000][9];
ll dfs(ll pos,ll sum,bool limit,bool lead,ll d)//sum为当前数码出现个数，d为当前数码。 
{
	if(pos==-1)//满足条件，返回值 
	{
		//cout<<sum<<" "<<endl;
		return sum;
	}
	if(!limit&&!lead&&~dp[pos][sum][d])return dp[pos][sum][d];//记忆化:在没有限制的条件下记忆 位，出现次数，以及数码 
	ll End,ans=0;
	End=limit?num[pos]:9;
	for(ll i=0;i<=End;++i)
		ans+=dfs(pos-1,sum+((!lead||i)&&i==d),limit&&i==num[pos],lead&&i==0,d);//要判断前导0 
	if(!limit&&!lead)dp[pos][sum][d]=ans;
	return ans;
}
ll solve(ll x,ll d)//x为分解的数，d为要求的数码 
{
	memset(dp,-1,sizeof(dp));//初始化 
	ll pos=0;
	while(x)
	{
		num[pos++]=x%10;
		x/=10;
	}
	dfs(pos-1,0,1,1,d);//限制条件 
}
int main()
{	
	scanf("%lld%lld",&a,&b);
	for(ll i=0;i<=9;++i)//0到9依次求解。 
		printf("%lld ",solve(b,i)-solve(a-1,i));
	system("pause");//防 
	return 0;
}
```


---

## 作者：独孤涵冰 (赞：1)

还是一样的套路。当前位比原数小的时候直接统计，要是相同的话，比如ABCD，当前到了A这一位，那么A的出现次数就是BCD次。
```cpp
/*Tokgo*/
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define dwn(i,a,b) for(int i=a;i>=b;--i)

using namespace std;

typedef long long ll ;  

ll a , b ; 

ll cnt[10] ;
ll f[ 15 ][ 10 ][ 10 ]; // i位填j时，k的数量 

int l , c[ 20 ] ;
void tran( ll a ) {
	l = 0 ;
	while( a )
		c[ ++l ] = a % 10 , a /= 10 ;
} 

void solve( int op , ll a ) {
	dwn( i , l , 1 ) {
		rep( j , (i==l) , c[i]-1 ) 
			rep( k , 0 , 9 ) cnt[k] += f[i][j][k]*op ;
		a -= ( c[i] * pow( 10,i-1 ) ) ;
		cnt[c[i]] += (a+1)*op ; 
	}
	rep( i , 1 , l-1 ) 
		rep( j , 1 , 9 ) 
			rep( k , 0 , 9 ) cnt[k] += (f[i][j][k])*op ;
}

int main() {

	rep( i , 0 , 9 ) f[1][i][i] = 1 ;
	rep( i , 2 , 13 )
		rep( j , 0 , 9 ) 
			rep( k , 0 , 9 ) {
				if( k == j ) f[i][j][k] = pow( 10 , i-1 ) ;
				rep( p , 0 , 9 )
					f[i][j][k] += f[i-1][p][k] ; 
			}		
	
	cin >> a >> b ; 
	
	tran( b ) , solve( 1 , b ) ;
	tran( a ) , solve( -1 , a-1 ) ;
	
	rep( i , 0 , 9 ) cout << cnt[i] << " " ;

	return 0;
}


```


---

## 作者：Isonan (赞：1)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2602)

还有一道基本一样的题是普及-的。。。[luoguP1239 计数器](https://www.luogu.org/problemnew/show/P1239#sub)

正解是数位DP

递归部分如下：

```cpp
long long DP(int i,int j,bool e,bool zero,int cnt){
	if(!e&&f[i][j])return f[i][j];
	if(i==1)return f[i][j]=(j==cnt);
	long long tem=0;
	if(!e)for(int k=0;k<10;k++)if(!zero)f[i][j]+=DP(i-1,k,0,0,cnt);else tem+=DP(i-1,k,0,(k==0),cnt); 
	else{
		for(int k=0;k<num[i-1];k++)
			tem+=DP(i-1,k,0,zero&&(k==0),cnt);
		tem+=DP(i-1,num[i-1],1,(num[i-1]==0)&&zero,cnt);
	}
	if((j==cnt)&&!zero){
		if(!e)f[i][j]+=dec[i-1];
		else tem+=fill[i-1];
	}
	return (e||zero) ? tem : f[i][j];
}
```
其中i为当前位数，j为当前位数字，e为前面是否等于num，zero为是否为前导0，cnt为要求的数字.f[i][j]表示从第i为往下，从j0000..到j9999..中有几个cnt。

e||zero的时候单独算，其他时候记搜就行了。

代码：

```cpp
#include <cstdio>
#include <cstring>

long long a,b,f[20][11],dec[30],fill[30],top,ans[11],num[20];
long long DP(int i,int j,bool e,bool zero,int cnt){
	if(!e&&f[i][j])return f[i][j];
	if(i==1)return f[i][j]=(j==cnt);
	long long tem=0;
	if(!e)for(int k=0;k<10;k++)if(!zero)f[i][j]+=DP(i-1,k,0,0,cnt);else tem+=DP(i-1,k,0,(k==0),cnt); 
	else{
		for(int k=0;k<num[i-1];k++)
			tem+=DP(i-1,k,0,zero&&(k==0),cnt);
		tem+=DP(i-1,num[i-1],1,(num[i-1]==0)&&zero,cnt);
	}
	if((j==cnt)&&!zero){
		if(!e)f[i][j]+=dec[i-1];
		else tem+=fill[i-1];
	}
	return (e||zero) ? tem : f[i][j];
}
int main(){
	dec[0]=1;for(int i=1;i<=20;i++)dec[i]=dec[i-1]*10;
	scanf("%lld%lld",&a,&b);
	while(b){
		num[++top]=b%10;
		b/=10;
	}
	fill[0]=1;
	for(int i=1;i<=top;i++)fill[i]=dec[i-1]*num[i]+fill[i-1];
	for(int i=0;i<10;i++)memset(f,0,sizeof f),ans[i]=DP(top+1,10,1,1,i);
//	for(int i=1;i<=top;i++,putchar('\n'))
//		for(int j=0;j<10;j++)
//			printf("%d ",f[i][j]);
	a--;
	top=0;
	while(a){
		num[++top]=a%10;
		a/=10;
	}
	num[++top]=0;
	for(int i=1;i<=top;i++)fill[i]=dec[i-1]*num[i]+fill[i-1];
	for(int i=0;i<10;i++)memset(f,0,sizeof f),ans[i]-=DP(top+1,10,1,1,i);
	for(int i=0;i<10;i++)printf("%lld ",ans[i]);
}
```

---

## 作者：kczno1 (赞：1)

枚举每一位x，再枚举数字i，计算x位选i的方案数。

这可以通过计算x位之前的方案数和之后的来组合一下得到。

```cpp
#include<bits/stdc++.h>
using std::max;

typedef long long ll;
const int N=20;
ll f[N],g[N];
int i;
void solve(ll u,ll *f)
{
    ll x,y=1;//x=枚举哪一位算贡献 y=大于x位的<=u,>=0的选择数 
    for(x=1;x<=u;x*=10);
    while(x/=10)
    {
        int now=u/x;u-=now*x;
        //小于x位的选择数=x 
        if(now)
        {f[0]+=(y-1)*x;//前导0是不算的 
         for(i=1;i<now;++i) f[i]+=y*x;
         f[now]+=(y-1)*x+u+1;
        }
        else f[0]+=(y-2)*x+u+1;
        for(i=now+1;i<=9;++i) f[i]+=(y-1)*x;
        y=(y-1)*10+now+1;
    }
}

int main()
{
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    ll a,b;
    scanf("%lld%lld",&a,&b);
    solve(b,f);    solve(a-1,g);
    for(i=0;i<=9;++i) printf("%lld ",f[i]-g[i]);
}
```

---

## 作者：lamboo (赞：1)

设[a,b]表示a~b中0~9出现的个数

我们很容易发现[a,b]=[1,b]-[1,a-1]

所以我们只要求出[1,b]和[1,a-1]即可

在本题中，1~9是很好求的，只是0的处理有些麻烦。我们不大方便直接求出0的数量，于是我们自然地想到**容斥原理——用总的数码个数-1~9的数码个数就可以了**

1~9就很好求了，对于每一个数，0~999···999中，它们出现的次数是相等的，我们可以通过打表，找规律求出，然后从高位数向低位数尾求

我们来模拟一下（模拟2345）

我们先做四位数0001~2345，我们把它分成1~999,1000~1999,2000,2345
我们最高位先不进行考虑，后三位中1~9的出现次数是相同的（我们已经打表求出），再来看最高位，只有1出现在最高位，由于1是在第4位，所以把1出现的次数+10^4。然后求2000~2345中的最高位2，只要将2的次数+（2345-2000+1）

做完了这些，我们只剩下求出1~345中1~9出现的位数就可以了，以此类推

如何求出1~x中总数码的个数比较简单，如果不会直接看程序注释

代码**（为防止恶意刷题，本程序中有一个明显的小错误，大家发现后不要在评论中说）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long ans[13]={0,1,20,300,4000,50000,600000,7000000,80000000,900000000,10000000000,110000000000,1200000000000}; 
//ans表示1~9在小于10^x时出现的个数
long long num(long long x) //求出1~x总共有多少个数码
{
	long long w,t,s,ans;
       //ans统计有多少个数码，t表示当前是第几位
       //w表示第t位有多少个数，s表示第（t-1）位有多少个数
	w=0;t=0;s=0;ans=0;
	while (true)
	{
		t++;s=w;w=w*10+9;
		if (x>w) ans+=t*(w-s);  //当前位数小于x的位数，则（w-s）为当前位有的数
		else {ans+=t*(x-s); return ans;} //当前位数大于x的位数，则（x-s）为当前位有的数
        //乘t表示每个数字有t个数码
	}
}
int main()
{
	long long f[10],e[10],x,k,z,t,a[14],sum;
	memset(f,0,sizeof(f));
	memset(e,0,sizeof(e));
	memset(a,0,sizeof(a));
	sum=0;
	cin>>x;
	x=x-1;
	k=x;z=1;t=0;
	f[0]=num(x);
	while (k)  //统计位数和每位上的数字
	{
		a[++t]=k%10;k=k/10;z=z*10;
	}
	z=z/10;
	while (t)
	{
		x=x%z;
		for (int i=1;i<=9;i++) f[i]+=ans[t-1]*a[t];
		for (int i=1;i<a[t];i++) f[i]+=z;
		if (a[t]) f[a[t]]+=x+1;  //0我们会另外求
		t--;z=z/10;	
	}
	for (int i=1;i<=9;i++) f[0]-=f[i];
	memset(a,0,sizeof(a));
	cin>>x;
	k=x;z=1;t=0;
	e[0]=num(x);
	while (k)
	{
		a[++t]=k%10;k=k/10;z=z*10;
	}
	z=z/10;
	while (t)
	{
		x=x%z;
		for (int i=1;i<=9;i++) e[i]+=ans[t-1]*a[t];
		for (int i=1;i<a[t];i++) e[i]+=z;
		if (a[t]) e[a[t]]+=x+1;
		t--;z=z/10;	
	}
	for (int i=1;i<=9;i++) e[0]+=e[i];
	for (int i=0;i<=9;i++) cout<<e[i]-f[i]<<" ";
	return 0;
}

```

---

## 作者：滑大稽 (赞：1)

本蒟蒻~~秉承不看题解的原则~~看了一下题解，突然发现没有本蒟蒻的做法，便来介绍一下我的做法。

首先我们可以明显看出，这是道 ~~乱搞暴力~~ 数位DP。模板在这里就不讲了，讲一下我的思路。各大佬都是每个数字分别处理，共处理10次，然而我是一次处理的。

------------
## 数组介绍（本蒟蒻码风新奇）
#### x:处理1到l-1的数字出现次数
#### y:处理1到r的数字出现次数
#### t&a:拆完数的结果（一正一反）
#### dp:动规时储存值


------------

## dp过程介绍





#### dfs参数（重申本蒟蒻码风新奇）
 
 ```cpp
dfs(int w,int d0,int zg,int s[])
```
w：正在处理哪一位

d0：前导0标记

zg：最高位限制标记

s：前一个函数内的数组（可能有点懵，跟着看下去吧）

------------
#### dp数组介绍：

dp[i][j]:第i位到最后一位时数值j出现的次数（没有前导0和最高位限制标记）


------------
然后就是dp过程了

首当其冲的是两个大家都会的判断

假如这两个判断都没有判断到 ~~（判断没用啊）~~，就先定义一个数组su，其中su[i]是数值i（0≤i≤9）从第w位到最后一位dp到的次数（受两个标记的影响）。

然后枚举所有可以的值，假如这个数i有意义（不是前导0），就把su[i]加上一个很玄学的值（后面来介绍）。然后就跟着dp下去。枚举完后，假如前导0标记和最高位限制标记都是0，就可以把su的值存储进dp数组内。

然后修改s数组的值（su不等同于s）



------------

#### 玄学值的介绍

------------
这个值分两种情况讨论：

假如最高位限制标记为0或者该位没取到最大值，就直接加上pow（10，c-w）。这个可以手动证明一下，相信不难证

假如最高位标记为1并且该位取到了最大值，该值就是后面可取的最大值+1（还有全是0这种情况）。对于这个最大值，可以用一个函数解决。
```cpp
int zh(int l,int r)
{
	int s=0;
	for(;l<=r;l++)s*=10,s+=a[l];
	return s+1;
}
```
相信挺好理解的。


------------

然后本题的大致思路都介绍完了，剩下的就是细节了 ~~（你们可能连思路都没懂，我语文太蒟了）~~。看下代码应该就可以理解了。（第三次重申本蒟蒻码风新奇）

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define int unsigned long long//为了省事，直接这样定义了 
#define N 15
using namespace std;
int x[N],y[N],dp[N][N],a[N],t[N]; 
int c;
inline int re()//误人子弟的快读 
{
	char h=getchar();
	int y=0,q=1;
	while(h<'0'||h>'9'){if(h=='-')q=-1;h=getchar();}
	while(h>='0'&&h<='9'){y=y*10+h-'0';h=getchar();}
	return y*q;
}
int zh(int l,int r)//算后面最大值的函数 
{
	int s=0;
	for(;l<=r;l++)s*=10,s+=a[l];
	return s+1;
}
void dfs(int w,int d0,int zg,int s[])
{
	if(w>c)return;//c是数字的长度
	if(dp[w][1]!=-1&&!zg&&!d0)
	{
		for(int i=0;i<=9;i++)s[i]+=dp[w][i];//直接把上一个函数的数组加上处理好的值 
		return;
	}
	int su[N]={};//定义单独一个数组，便于更新dp数组的值 
	int m=(zg?a[w]:9);//求出取值范围 
	for(int i=0;i<=m;i++)
	{
		if(!d0||i!=0)//假如该数有意义 
		{
			if(!(zg&&i==m))su[i]+=pow(10,c-w);//假如没有顶着最大值，就是第一种情况，加上10的c-w次方 
			else su[i]+=zh(w+1,c);//假如顶着最大值，就是第二种情况，加上后面数字的最大值 
		}
		dfs(w+1,d0&&i==0,i==m&&zg,su);//往下dfs 
	}
	if(!d0&&!zg)for(int i=0;i<=9;i++)dp[w][i]=su[i];//假如没有两个标记的限制，把值存下来 
	for(int i=0;i<=9;i++)s[i]+=su[i];//更新s数组 
}
void d(int x,int s[])
{
	c=0;
	while(x)t[++c]=x%10,x/=10;//拆数 
	for(int i=1;i<=c;i++)a[i]=t[c-i+1];//把数组反一下 
	memset(dp,-1,sizeof(dp));//初始化为-1 
	dfs(1,1,1,s);
}
signed main()//因为上面的宏定义，这里打int要报错，只能用signed 
{
	int l=re(),r=re();
	d(l-1,x);//计算1到l-1的值 
	d(r,y);//计算1到r的值 
	for(int i=0;i<=9;i++)cout<<y[i]-x[i]<<" ";//前缀和思想 
	cout<<"\n";
	//return ^-^; 
}
```
## ps：本代码已做防抄处理
### 完结撒花
~~（我太蒟了）~~

---

## 作者：upcchenbaorui (赞：0)

# 数位DP基础题
预处理出长度为i的所有的情况 ,dp[i][j][k]表示的是长度为i,最高位是j的所有k的个数，很明显dp[i][j][k] 是从dp[i-1][0到9][k]转移过来的，并且还要加上当前状态的最高位j的个数，显然个数为 pow(10,i-1)
总体来讲，就是数位dp的模板，需要加上自己的想法
```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
ll dp[13][10][10];
ll cnt1[10]={0};
ll cnt2[10]={0};
void init()//预处理
{
    for(int i=0;i<=9;++i){
        dp[1][i][i]=1;
    }
    for(int i=2;i<=12;++i){
        for(int j=0;j<=9;++j){
            for(int k=0;k<=9;++k){
                for(int l=0;l<=9;++l){
                    dp[i][j][l]+=dp[i-1][k][l];
                }   
            }
            dp[i][j][j]+=pow(10,i-1);//最高位是j，加上j的个数
        }
    }
}
int w[13];
int tot;
void solve1(ll x) //这里写了俩函数，麻烦了。。
{
    ll s=x;
    if(x==0) return;
    memset(w,0,sizeof w);
    tot=0;
    while(x){
        w[++tot]=x%10;
        x/=10;
    }
    for(int i=1;i<=tot-1;++i){
        for(int j=1;j<=9;++j){
            for(int k=0;k<=9;++k){
                cnt1[k]+=dp[i][j][k];
            }
        }
    }

    for(int i=1;i<w[tot];++i){
        for(int k=0;k<=9;++k){
            cnt1[k]+=dp[tot][i][k];
        }
    }
    //for(int i=0;i<=9;++i) cout<<cnt1[i]<<" ";
    if(tot==1){
        cnt1[w[1]]++;
        return;
    }
    s-=w[tot]*pow(10,tot-1);//减去最高位就是最高位要用的次数减1
    cnt1[w[tot]]+=s+1;
    for(int i=tot-1;i>=1;--i){
        s-=w[i]*pow(10,i-1);
        cnt1[w[i]]+=s+1;
        for(int j=0;j<w[i];++j){
            for(int k=0;k<=9;++k){
                cnt1[k]+=dp[i][j][k];
            }
        }

    }
    return ;
}

void solve2(ll x) //同上
{
    ll s=x;
    if(x==0) return;
    memset(w,0,sizeof w);
    tot=0;
    while(x){
        w[++tot]=x%10;
        x/=10;
    }
    for(int i=1;i<=tot-1;++i){
        for(int j=1;j<=9;++j){
            for(int k=0;k<=9;++k){
                cnt2[k]+=dp[i][j][k];
            }
        }
    }

    for(int i=1;i<w[tot];++i){
        for(int k=0;k<=9;++k){
            cnt2[k]+=dp[tot][i][k];
        }
    }
    //for(int i=0;i<=9;++i) cout<<cnt1[i]<<" ";
    if(tot==1){
        cnt2[w[1]]++;
        return;
    }
    s-=w[tot]*pow(10,tot-1);
    cnt2[w[tot]]+=s+1;
    for(int i=tot-1;i>=1;--i){
        s-=w[i]*pow(10,i-1);
        cnt2[w[i]]+=s+1;
        for(int j=0;j<w[i];++j){
            for(int k=0;k<=9;++k){
                cnt2[k]+=dp[i][j][k];
            }
        }

    }
    return ;
}
int main()
{
    init();
    ll a,b;
    scanf("%lld %lld",&a,&b);
    solve1(a-1);
    solve2(b);
    for(int i=0;i<=9;++i){
        printf("%lld",cnt2[i]-cnt1[i]);
        if(i<9) printf(" ");
    }
    printf("\n");
    return 0;
}
```


---

## 作者：bzy369258147 (赞：0)

我甚至感觉这一题搜索更加清爽一些，为什么不爆搜呢O($10*log_{10}n$)

貌似比数位DP更好动，思想应该是一样的

思路大概就是递归枚举位，每一位统计贡献，然后去掉多余的0，然后输出

代码如下，应该自己看是可以很容易懂的：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long ans[10];

long long high_stear(long long n){
    if( n == 0 )return 0;
    long long ans = 1;
    while(n /= 10)ans *= 10;
    return ans;
}

void step(long long n,int way,long long now){
    if(now == 0)return ;
    long long far = (n / now) % 10;
    for(int i = 0;i < far;i ++)ans[i] += now * way;
    for(int i = 0;i <= 9;i ++)ans[i] += far * (log(now) / log(10)) * (now/10) * way;
    ans[ far ] += (n % now + 1) * way;
    ans[ 0 ] -= now * way;
    step( n, way,now / 10 );
}

int main(){
    long long m,n;cin >> m >> n;
    step(n,1,high_stear(n));
    step(m-1,-1,high_stear(m-1));
    for(int i = 0;i <= 9;i ++)cout << ans[i] << " ";
    return 0;
}

```


---

## 作者：qianfujia (赞：0)

##其实无需考虑前导零，减一减即可

####不多说，贴代码

####log10n

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    long long dp[14][10][10];
    long long power[14];
    long long cnt[10];
    inline long long sum(long long x,long long y)//dp过程
    {
        if(x<0)return 0;
        else if(x==0)return 0;
        long long len;
        for(len=0;power[len]<=x;++len);
        long long ans=0;
        for(long long i=1;i<=len;++i)
        {
            long long bit=x/power[len-i]%10;
            for(long long j=0;j<bit;++j)
                ans+=dp[len-i+1][j][y];
            if(bit==y)ans+=x%power[len-i];//特殊处理
        }
        return ans;
    }
    inline long long c(long long l,long long r)//灵魂，求a~b的数字个数
    {
        long long lenl,lenr;
        for(lenl=0;power[lenl]<=l;++lenl);
        for(lenr=0;power[lenr]<=r;++lenr);
        if(lenl==lenr)return (r-l+1)*lenl;
        long long ans=(r-power[lenr-1]+1)*lenr+(power[lenl]-l)*lenl;
        for(long long i=lenl+1;i<lenr;++i)ans+=power[i-1]*9*i;
        return ans;
    }
    int main()
    {
        power[0]=1;
        for(long long i=1;i<=12;++i)power[i]=power[i-1]*10;
        for(long long i=0;i<=9;++i)dp[1][i][i]=1;
        for(long long i=1;i<=12;++i)
            for(long long j=0;j<=9;++j)
                for(long long k=0;k<=9;++k)
                    for(long long l=0;l<=9;++l)
                        if(l==k)dp[i+1][k][l]+=dp[i][j][l]+power[i-1];
                        else dp[i+1][k][l]+=dp[i][j][l];//预处理
        long long a,b;
        scanf("%lld%lld",&a,&b);
        for(long long i=1;i<=9;++i)cnt[i]=sum(b+1,i)-sum(a,i);
        cnt[0]=c(a,b);
        for(long long i=1;i<=9;++i)cnt[0]-=cnt[i];//减一下，求0
        for(long long i=0;i<=9;++i)printf("%lld ",cnt[i]);
        return 0;
}
```

---

## 作者：eternal (赞：0)

令f[i]为i位数(算前导零)中每个数出现的次数(一定是相同的，所以只记录一个就行了)


有f[i]=f[i-1]\*10+10^(i-1)


然后照例十进制拆分


其中计算[0,999...9]的时候要从1~9枚举最高位，然后其余位调用f[i-1]即可


剩余部分已知位直接乘，未知位调用f[i]


/\*
ID:Agreement

LANG:C++

\*/
    
    
    
```cpp
// Invincible
#include <bits/stdc++.h>
#define rep( i , l , r ) for( int i = (l) ; i <= (r) ; i++ )
#define per( i , r , l ) for( int i = (r) ; i >= (l) ; i-- )
#define erep( i , u ) for( int i = head[(u)] ; ~i ; i = e[i].nxt )
using namespace std;
typedef long long ll;
inline ll _read(){
    register ll x = 0;
    register char ch = getchar();
    while( ch > '9' || ch < '0' ) ch = getchar();
    while( ch >= '0' && ch <= '9' ){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x;
}
const int maxn = 10 + 5;
ll ans[maxn] , f[2 * maxn];
inline void resolve( ll x , ll pos ){
    while( x ) ans[ x % 10 ] += pos , x /= 10; 
}
void solve( ll x , int flg ){
    int i , j ;
    ll pos , now;
    for( i = 1 , pos = 10 ; pos < x ; ++i , pos *= 10 ){
        rep( j , 0 , 9 ) ans[j] += f[i - 1] * 9 * flg;
        rep( j , 1 , 9 ) ans[j] += pos / 10 * flg;
    }
    now = pos /= 10 ; --i;
    while( now < x ){
        while( now + pos <= x ){
            ll t = now / pos ;
            resolve( t , pos * flg );
            rep( j , 0 , 9 ) ans[j] += f[i] * flg;
            now += pos;
        } 
        pos /= 10; --i;
    } 
}
int main(){
    int i ;
    ll a , b , pos ;
    f[1] = 1;
    for( i = 2 , pos = 10 ; i <= 12 ; ++i , pos *= 10 ) f[i] = f[i - 1] * 10 + pos;
    a = _read() , b = _read();
    solve( b + 1 , 1 ); solve( a , -1 );
    rep( j , 0 , 9 ) printf("%lld%c" , ans[j] , j == 9 ? '\n' : ' ');
    return 0; 
}

```

---


# 烦人的数学作业

## 题目背景

NOIP2018初赛结束了，但H还是要上学的啊啊。。上学肯定要完成老师布置的作业，H十分头疼。在如山的作业中，Mr.G布置的数学作业最烦人，H总是完不成~~

## 题目描述

Mr.G最近在看一些关于数字题的书，他每天愁同学们太~~聪明~~了，所有的作业同学们都能~~做到全对~~（拿到答案）。Mr.G~~蒙在鼓里~~（心知肚明）。为了使同学们进步，Mr.G总是创造一些~~简单~~（毒瘤）题来作为作业。以下是数学作业的最后一题题干——

给出一个区间$ L $~$ R $，求$ L $到$ R $区间内**每个数的数字和**，如123这个数的数字和为1+2+3=6。

（$ 1 \leq L \leq R \leq 10^2 $）

同学们纷纷做出来了，Mr.G一看这最后一题跟摆设没区别了呀，于是他迅速修改了题目，把范围定得非常非常大，且有$ T $组数据，将最终的答案mod $ 10^9+7 $。

（$ 1 \leq L \leq R \leq 10^{18} $）
（$ 1 \leq T \leq 20  $）

同学们纷纷被难住了。但H为了备战NOIP2018，没有时间完成Mr.G的数学作业~~（其实是不想做QwQ）~~，所以Ta找到了你，希望你帮助Ta和同学完成这烦人的数学作业！




## 说明/提示

对于 $ 50\% $ 的数据，$ 1 \leq L \leq R \leq 10^8 $；

对于 $ 100\% $ 的数据，$ 1 \leq L \leq R \leq 10^{18}  $，$ 1 \leq T \leq 20  $。


## 样例 #1

### 输入

```
2
24 69
70 120```

### 输出

```
411
498```

# 题解

## 作者：jijidawang (赞：54)

数位 dp。

设 $dp_{q,i}$（$i\in\{0,1,2,3,4,5,6,7,8,9\}$）为 $1\sim q$ 中 $i$ 出现的次数，$1\sim q$ 的数字和显然就是 $dp_{q,0}\times 0+dp_{q,1}\times 1+\cdots+dp_{q,i}\times i\cdots+dp_{q,9}\times 9$。

所以我们只需要求出 $1\sim q$ 中 $i$ 出现的次数就能解决这个问题了。

这个问题看起来很好解决，但是注意**前导零会影响结果**，所以不能有前导零。

这该怎么办呢？

有前导零的式子很容易推出。有 $q$ 位数字，$i$ 数码的出现次数对于 $x\in\{s\mid s\in \mathbb N,10^q\le s\le10^{q+1}\}$ ，$f(q,i)$ 的数量都是相等的（设 $f(q,i)$ 为 $q$ 位数 $i$ 数码的出现次数）。

具体求法罢，是：  
$\begin{cases}f(q,i)=0&q=0\\f(q,i)=10f(q-1)+10^{q-1}&q>0\end{cases}$

我们考虑减去多余的 $0$。

我们先设数字为 $\overline{A_1A_2A_3\dots A_n}$

我们首先考虑求 $\overline{A_100\dots 0}$，将 $\overline{A_100\dots 0}$ 分割为区间 $[0000,1000),[1000,2000),\dots,[\overline{(A_1-1)00\dots 0},\overline{A_100\dots 0})$，所以答案就为 $10^{n-1}A_1$，注意 $<A_1$ 的每个数还出现了 $10^{n-1}$ 次，所以要加上。

首位 $A_1$ 出现了 $\overline{A_2A_3\dots A_n}+1$ 次，答案还要加上 $\overline{A_2A_3\dots A_n}+1$，

当然还需要处理前导 $0$，用排列组合算一下会知道 $i$ 位 $q$ 个前导零的数量就是 $10^q$（$q\in\{s\mid s\in\mathbb N,0\le s\le i-1\}$），把它们加起来会发现一共出现了 $10^{i-1}+10^{i-2}+...10$（$\sum\limits_{k=0}^{i-1}10^k$） 次，减一下即可。

Code:
```cpp
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
const int N=51,MOD=1e9+7; //注意能 MOD 的地方都要 MOD，不然会 WA 0pts。
ll pow10[N],dp[N],a[N],count[N],tmpcount[N],ans;
// pow10    : 字面意思，10^n
// dp       : 不考虑前导零的状况
// count    : 统计 0~9 出现次数
// tmpcount : 暂时保存 count，用来减
// ans      : 累加答案
void init() //预处理 pow10 和 dp。
{
	pow10[0]=1;
	for (int i=1;i<30;i++) dp[i]=(dp[i-1]*10%MOD+pow10[i-1])%MOD,pow10[i]=10*pow10[i-1]%MOD;
}
void solve(ll x)
{
	int len=0;
	while (x){a[++len]=x%10;x/=10;} //数位分离
	for (int i=len;i>=1;i--)        //从高到低遍历
	{
		for (int j=0;j<10;j++) count[j]+=dp[i-1]*a[i],count[j]%=MOD;  //分割区间
		for (int j=0;j<a[i];j++) count[j]+=pow10[i-1],count[j]%=MOD; //加上 10^(n-1)
		ll lastnum=0;
		for (int j=i-1;j>=1;j--) lastnum=lastnum*10+a[j],lastnum%=MOD; //求出 A2A3A4...An
		count[a[i]]+=lastnum+1,count[a[i]]%=MOD;
		count[0]-=pow10[i-1],count[0]=(count[0]+MOD)%MOD; //减去前导零
	}
}
int main()
{
	init();
	ll l,r,T;
	cin>>T;
	for (int q=0;q<T;q++)
	{
		ans=0; cin>>l>>r;
		solve(r); //前缀和思想相减 r 和 l-1。
		for (int i=0;i<10;i++) (tmpcount[i]=count[i]),count[i]=0; //复制 count，记得清零
		solve(l-1);
		for (int i=0;i<10;i++) ans=(ans+i*(tmpcount[i]-count[i]+MOD)%MOD)%MOD,count[i]=0; //累加答案，记得清零 count。
		cout<<ans<<'\n';
	}
	return 0;
}
```

Refence [求数字 $i$ 出现的次数](https://www.luogu.com.cn/blog/mak2333/solution-p2602)。

---

## 作者：归山_ (赞：40)

# 首先我们分析题目

很明显我们要处理每一个[l,r]中的数字的每一位的和。。。

## ~~好绕啊~~

然后我们想到，在一段区间中，我们要求出每一个数的每一位，并进行接下来的操作。



------------
### Solution 1

显然大暴力啊，我们只要求出区间每一个数的每一位并进行操作就可以了。。。

~~不就是按照题目模拟吗~~

然后你就可以开开心心的拿到50

~~其实我并没有打暴力所以我也不太清楚~~

### Solution 2

我们看到数据量非常大，所以我们要考虑在数位上dp了~

数位dp的实质就是换一种暴力枚举的方式，使得新的枚举方式满足dp的性质，然后记忆化就可以了

于是我们就先把数位都分解出来于是就有了以下代码

```
int solve(int x){
	int sum=0;
	while(x){
		a[++sum]=x%10;
		x/=10;
	}
	return dfs(sum,0,1)%mod;
}
```

然后我们再考虑怎样进行dp呢

dp思想，枚举到当前位置pos，状态为state(这个就是根据题目来的，可能很多)的数量(既然是计数,dp值显然是保存满足条件数的个数)

接下来上具体代码

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define int long long

const int maxn=1000100;
const int mod=1e9+7;
int t;
int l,r;
int a[maxn],num;
int f[200][200];

int dfs(int x,int sum,bool top){//我个人认为这很像类似递归算法 
	if(!x) return sum;//如果已经到了最后一位就可以直接返回sum 
	if(!top&&f[x][sum]>=0) return f[x][sum];//最高位是0也直接返回 
	int bound=top?a[x]:9;//根据top判断枚举的上界bound 
	int ret=0;
	for(int i=0;i<=bound;i++) ret=(ret+dfs(x-1,sum+i,top&&i==bound))%mod;
	/*
		这里大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论
        去计算不同情况下的个数，这里一定要保存枚举的这个数是合法
	*/ 
	if(!top) f[x][sum]=ret;//这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑top，这里就是top就完全不用考虑了*
	return ret;
}

int solve(int x){
	int sum=0;
	while(x){
		a[++sum]=x%10;
		x/=10;
	}
	return dfs(sum,0,1)%mod;//从最高位开始枚举
}

signed main(){
	cin>>t;
	memset(f,-1,sizeof(f));
	while(t--){
		cin>>l>>r;
		cout<<(solve(r)-solve(l-1)+mod)%mod<<'\n';
	}
	return 0;
}

```

完结撒花~~~

最后给大家三倍经验（其实不太一样）

P2602 [ZJOI2010]数字计数

P1836 数页码_NOI导刊2011提高（04）

P2657 [SCOI2009]windy数

最后祝大家noip rp++


---

## 作者：Kevin_Wa (赞：26)

## 出题人的题解
#### 各位大佬勿喷，本题的原型其实有很多，只是出题人发现这种数位DP遍历（慌得连叫什么都忘了）在联赛中可考性很强，这种题也考思维，本题在洛谷上有个亲戚[P2602数字计数](https://www.luogu.org/problemnew/show/P2602)，开始在比赛时这题数据出现了问题，作者在输出sum时未取模，感谢@lckcode@yizimi远欣@siruiyang_sry指出错误，望谅解。
### 简单题意：
 意思就是找$a$到$b$，各个数位上的和。
### 部分分获取：
 打暴力30分。（开long long(C++) int64(pascal)）
 
 数学100分

### 数学：
  先将本题转换一下：求$a$到$b$之间的数字和，
  
  求$a$到$b$之间$1$~$9$数字个数
  
  求$a$到$b$之间$1$~$9$数字个数再乘$1$~$9$
  
  于是乎只要求出$1$~$9$数字个数就完结了。
  
  挺简单的。将$1$~$a-1$的数字个数算出，再将$1$~$b$的数字个数算出。利用前缀和相减便为答案。将每位上最多能出现的个数求出，在看看能否到达这个数。将结果取模。具体也可参考[P2602数字计数](https://www.luogu.org/problemnew/show/P2602)。
  时间复杂度$ o(log n) $
 
### 代码
```pascal
const mo=1000000007;
var max,min,x,y,t:int64;i:longint;sum:qword;
sc:array[0..9] of int64;
function chu(p:longint;s:int64):int64;
var x,y,z:array[0..100] of int64;i,l,x1:longint;s1:string;
begin
str(s,s1);
l:=length(s1);
x[0]:=0;y[0]:=1;
for i:=1 to l-1 do//算每位的最大出现次数
 begin
 y[i]:=y[i-1]*10;
 x[i]:=x[i-1]*10+y[i-1];
 end;
val(s1[1],x1);
s:=s-x1*y[l-1];
chu:=x[l-1]*x1;
if (x1>p)and(p<>0) then chu:=chu+y[l-1];
if (x1=p)and(p<>0) then chu:=chu+s+1;
for i:=l-1 downto 1 do
  begin
  val(s1[l-i+1],x1);
  s:=s-x1*y[i-1];
  if (x1>p) then chu:=chu+y[i-1];//如果大于说明可以取到最大
  if (x1=p) then chu:=chu+s+1;//如果不行，说明只能取到现在的最大
  chu:=chu+x1*x[i-1];
  end;
end;
begin
read(t);
while (t<>0) do
begin
readln(x,y);
x:=x-1;
sum:=0;//清零
for i:=1 to 9 do
  begin
  min:=chu(i,x);//算1~x，数字i的个数
  max:=chu(i,y);//算1~y，数字i的个数
  sc[i]:=max-min;
  sum:=sum+((sc[i] mod mo) *i)mod mo;
  end;
writeln(sum mod mo);
t:=t-1;
end;
close(input);close(output);
end.

```

---

## 作者：Dzhao (赞：14)

## [博客食用更佳呦](https://www.luogu.org/blog/qshjydzh/solution-p4999)

首先，我们来分析题目
> 给出一个区间 L~R,求 L到R区间内每个数的数字和

数据范围

$1<=L<=R<=10 ^{18} $

刚学的卡常暴力要用上啦
# 哈 
## 哈
### 哈
#### 哈
##### 哈
###### 哈
疑？等等那是10的18次方，不是1018啊，真香

我照样能~~暴力~~（$TLE$）

---------------------------------------------------我是~~超级可爱的~~分割线----------------------------------------------------

言归正传。

我们看到了数据范围，就可以知道，这道题是一道数位$DP$

看巨佬们都用记忆化搜索，那本超级无敌大蒟蒻就交一篇普通的数位$DP$

别问我怎么知道的，我也不知道我怎么知道的

我们用$f[i][j]$表示做了i位，最高位是j的所有数的数字和

$$f[i][j]=\sum _ {k=0}^9 f[i-1][k] + j * 10^{i-1}$$ 
然后再处理一下越界情况，将越界情况分治就行了

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long //注意，要用long long 
#define P 1000000007
ll f[30][15],a[30],power[30];
void init() //初始化 
{
	for(int i=0;i<=9;i++) f[1][i]=i;
	power[0]=1;
	for(int i=1;i<=18;i++) power[i]=power[i-1]*10%P; //power[i]=10的i次方 
	for(int i=2;i<=18;i++) 
		for(int j=0;j<=9;j++)
		{
			f[i][j]=j*power[i-1]%P; //注意：不要忘了加最高位 
			for(int k=0;k<=9;k++)
				f[i][j]+=f[i-1][k],f[i][j]%=P; //转移 
		}
			
}
int ask(ll x) //注意，ask(x)处理的是1~x-1的答案 
{
	memset(a,0,sizeof(a));
	int w=0,ans=0;
	while(x) //将每一位数存在数组中 
	{
		a[++w]=x%10;
		x/=10;
	}
	for(int i=1;i<w;i++)
		for(int j=1;j<=9;j++) ans+=f[i][j],ans%=P; //将未到x的位数的所有答案加起来 
	for(int i=1;i<a[w];i++) ans+=f[w][i],ans%=P; //将最高位比x的最高位小的答案加起来 
	int sum=a[w]; //sum表示目前已经处理的为之前的数字总和 
	for(int i=w-1;i>=1;i--)
	{
		ans+=sum*power[i-1]*a[i]%P;
		ans%=P;
		for(int j=0;j<a[i];j++)
			ans+=f[i][j],ans%=P; //加上当前这位未到x的这位的答案 
		sum+=a[i]; //数字总和加上当前这位 
	}
	return ans;
}

int main()
{
	init();
	int T;
	cin>>T;
	while(T--)
	{
		ll x,y;
		cin>>x>>y;
		cout<<((ask(y+1)-ask(x))%P+P)%P<<endl; //注意取余后有可能出现负数，所以我们+P再%P使其为正数 
	}
	return 0;
}
```
$QWQ$ 第一篇紫题题解，望管理员大大通过

---

## 作者：chinaxjh (赞：14)

## 数位dp裸题，但对于我这样的普及选手而言还没学过，所以我想到了另外一种~~玄学的~~算法：

### 普及选手的最爱——打表法

~~（你可以打一个1e18的表试试）~~

当然，我们不可以直接打这么大的表（要不然MLE），但可以像数位dp一样，按数位进行打表

我们可以先通过数学方法预处理出9,99,999,9999.....作为一组，然后从高的数位向下分解，最后得出答案

可以看代码辅助理解

注意：输出时取余多取几次，防止意外的WA

AC code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long modd=1e9+7;//mod数
int nn,i;
long long a[20],b[20],aa,bb,anss;//开long long,一定要开long long(后面也一样)
long long gett(long long x)
{
    long long i,t,ans,w,ww;
    t=x; ans=0;
    for (i=18;i>=0;i--)//按数位，（i>=0）,注意=，要不然个位就无法计数
    if (t>=a[i])//要大才有可能分解
    {
        w=(t+1)/(a[i]+1);//求分解成几组
        ww=(t+1)%(a[i]+1);//剩下的部分
        ans+=(w*b[i]+(w-1)*w/2*(a[i]+1)+ww*w)%modd;//按数学方法处理掉已有的组和当前组的所有最高位（中间用了等差数列求和公式）和剩下部分的所有最高位
        ans=ans%modd;//取余
        t-=w*(a[i]+1);//剩下未分解的部分继续分解
    }
    return ans;
}

int main()
{
    a[1]=9;
    b[1]=45;//口算9以内数的和
    for (i=2;i<=18;i++)//到18位
    {
        a[i]=a[i-1]*10+9;//往后99,999.....
        b[i]=(b[i-1]*10+45*(a[i-1]+1))% modd;//数学方法，之前有的*10再加上新的一位
    }
    scanf("%d",&nn);
    for (int nnn=1;nnn<=nn;nnn++)//多组数据
    {
        scanf("%lld%lld",&aa,&bb);
        anss=gett(bb)-gett(aa-1);//bb要减去aa-1
      	printf("%lld\n",(anss%modd+modd)%modd);//多取几次余，防止负数
    }
}
```
## 小结：其实这种算法和数位dp有着千丝万缕的关系，读者可以自己体会



---

## 作者：我太强了 (赞：14)

#### 是一道数位dp的简单题~~
首先，先看题目描述。“......给出一个区间L~R，求L到R区间内每个数的数字和......”，唔，是对于数字每一位进行的操作，所以试一试数位dp吧？~~点开算法标签果然是这样的~~

这时候，大家肯定都想到了[数字计数](https://www.luogu.org/problemnew/show/P2602)（没做过可以先做，差不多是双倍经验），这道题是统计$L$~$R$区间内各个数字出现的个数。而联系到本题，只要多加一步，把各个数字的出现次数$*$ 数字的权值（就是这个数字本身QWQ），就得到了区间内每个数字的数字和。

这样一看，本题已经很简单了。所以你开心地敲下代码，做好AC的准备~~
```cpp
#include<bits/stdc++.h>
#define isalive !=0
#define ll long long
#define mod 1000000007
using namespace std;
ll l,r,ans,dp[20][20],num[10];
int part[20],len,t;
ll dfs(int need,int pos,int tot,bool limit,bool zero)
{
    if(!pos) return tot;
    if(!limit&&!zero&&dp[pos][tot]!=-1)
        return dp[pos][tot];
    int maxn=limit?part[pos]:9;
    ll sum=0;
    for(int i=0;i<=maxn;++i)
    {
        if(zero&&!i)
        sum+=dfs(need,pos-1,tot,limit&&(i==maxn),1);
        else
        sum+=dfs(need,pos-1,tot+(i==need),limit&&(i==maxn),0);
    }
    if(!limit&&!zero)
        dp[pos][tot]=sum;
    return sum;
}
void dismember(ll victim) 
{ 
    len=0;
    while(victim isalive) part[++len]=victim%10,victim/=10;
    for(int i=1;i<=9;i++) 
    { 
        memset(dp,-1,sizeof(dp));
        num[i]=(num[i]-dfs(i,len,0,1,1)+mod)%mod;
    } 
} 
void Dismember(ll victim) 
{ 
    len=0;
    while(victim isalive) part[++len]=victim%10,victim/=10;
    for(int i=1;i<=9;i++) 
    { 
        memset(dp,-1,sizeof(dp));
        num[i]=dfs(i,len,0,1,1)%mod;
    } 
} 
int main() 
{ 
    scanf("%lld",&t);
    while(t--) 
    {    
        ans=0;
        scanf("%lld%lld",&l,&r);
        Dismember(r); dismember(l-1); 
        for(int i=1;i<=9;i++) ans=(ans+i*num[i]+mod)%mod;
        cout<<ans%mod<<endl;
    } 
    return 0;
} 
```
交上去...诶？80分？！
![](https://cdn.luogu.com.cn/upload/pic/60907.png )

这是因为掉进了一个容易被忽略的坑里qwq
![](https://cdn.luogu.com.cn/upload/pic/60911.png )
在最后结果需要对某一特定数字（此处是mod)取余时，为了保证结果非负，还是多写几个+mod再%mod吧

所以，修改成这样
![](https://cdn.luogu.com.cn/upload/pic/60910.png )
再提交一次，AC辣!!

好了，下面真的是AC代码了


```cpp
#include<bits/stdc++.h>
#define isalive !=0
#define ll long long
#define mod 1000000007
using namespace std;
ll l,r,ans,dp[20][20],num[10];
int part[20],len,t;
ll dfs(int need,int pos,int tot,bool limit,bool zero)
{
    if(!pos) return tot;
    if(!limit&&!zero&&dp[pos][tot]!=-1)
        return dp[pos][tot];
    int maxn=limit?part[pos]:9;
    ll sum=0;
    for(int i=0;i<=maxn;++i)
    {
        if(zero&&!i)
        sum+=dfs(need,pos-1,tot,limit&&(i==maxn),1);
        else
        sum+=dfs(need,pos-1,tot+(i==need),limit&&(i==maxn),0);
    }
    if(!limit&&!zero)
        dp[pos][tot]=sum;
    return sum;
}
void dismember(ll victim) 
{ 
    len=0;
    while(victim isalive) part[++len]=victim%10,victim/=10;
    for(int i=1;i<=9;i++) 
    { 
        memset(dp,-1,sizeof(dp));
        num[i]=(num[i]-dfs(i,len,0,1,1)+mod)%mod;
    } 
} 
void Dismember(ll victim) 
{ 
    len=0;
    while(victim isalive) part[++len]=victim%10,victim/=10;
    for(int i=1;i<=9;i++) 
    { 
        memset(dp,-1,sizeof(dp));
        num[i]=dfs(i,len,0,1,1)%mod;
    } 
} 
int main() 
{ 
    scanf("%lld",&t);
    while(t--) 
    {    
        ans=0;
        scanf("%lld%lld",&l,&r);
        Dismember(r); dismember(l-1); 
        for(int i=1;i<=9;i++) ans=((ans+i*num[i]+mod)%mod+mod)%mod;
        cout<<ans%mod<<endl;
    } 
    return 0;
} 
```
撒花！！！

---

## 作者：Aleph1022 (赞：11)

为什么大家都拘泥于数字计数的做法呢……

这里给出记搜实现的另一种做法，记录位数、填**过**的所有数的和、是否贴着边界。

其实这题顶多蓝题。

代码：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int LEN = 18;
const long long mod = 1e9 + 7;
int t;
long long l,r;
int d[LEN + 5],tot;
long long f[LEN + 5][LEN * 9 + 5];
long long dfs(int x,int sum,int top)
{
    if(!x)
        return sum;
    if(!top && ~f[x][sum])
        return f[x][sum];
    int bound = top ? d[x] : 9;
    long long ret = 0;
    for(register int i = 0;i <= bound;++i)
        ret = (ret + dfs(x - 1,sum + i,top && i == bound)) % mod;
    if(!top)
        f[x][sum] = ret;
    return ret;
}
long long solve(long long x)
{
    tot = 0;
    while(x)
        d[++tot] = x % 10,x /= 10;
    return dfs(tot,0,1) % mod;
}
int main()
{
    memset(f,-1,sizeof f);
    scanf("%d",&t);
    while(t--)
    {
        scanf("%lld %lld",&l,&r);
        printf("%lld\n",(solve(r) - solve(l - 1) + mod) % mod);
    }
}
```

---

## 作者：ctq1999 (赞：6)

## 题目大意

给定一段区间$[l,r](1\leq l,r\leq 10^{18})$，求该区间中，每一个数的数字和的和。

## 思路
很明显，暴力做肯定不行。正解是数位 dp。

可以数字的和，我们可以记录每一个数字的个数，最后再乘以数字即可。

可以考虑使用前缀和的思想来求解。定义 $count(n)$ 为区间 $[1,n]$ 每一个数的数字和的和。那么答案就是 $count(r)-count(l-1)$。

接下来说一下 $count$ 函数的实现。定义 $xpo10_i$ （x power of 10 的意思，笔者英语辣鸡）的值为 $10^i$，$cnt_i$ 为区间 $[1,10^i-1]$ 中数字 $i$ 出现的次数。根据打表可以发现 $cnt_i = cnt_{i-1}\times 10+xpo10_{i-1}$。

比如 $i$ 从 $1$ 到 $2$（这两个函数很重要，不然你就看不懂后面的）：

![图片.png](https://i.loli.net/2020/08/02/5pDmVrjbka29hxT.png)

会发现红色的就是 $cnt_1$，在 $i=2$ 时出现了 $10$ 次，而新加的第 $i$ 位，每一个数字 $x$，都会出现 $xpo10_{i-1}$，因为 $i=1$ 时的区间是 $xpo10_1$。

那么之后的思路也大致相同。定义 $ans$ 数组为记录第 $i$ 数字出现的总次数。先用 $a$ 把存下 $n$ 的每一位数字。那么对于从右往左第 $i$ 位，$ans$ 的更新分为三个部分。

第一个部分是第 $i$ 位上的数字的更新。显然 $0$ 到 $a[i]-1$ 时直接加上 $xpo10[i-1]$，因为他们会在第 $i$ 位会出现整整 $xpo10[i-1]$ 次。而 $a[i]$ 则是加上 $num-xpo10[i-1]+1$。

第二个部分是第 $1$ 位到第 $i-1$ 位的更新。显然数字 $x$ 的更新就是 $cnt[i-1]$ 了。

第三个部分是前导零的处理。显然当处理到第 $i$ 位时，前导零有 $xpo10[i-1]$ 个。数字 $0$ 的个数要减去。

最后，$num$ 要更新成 $num-xpo10[i-1]$ 了。

比如 $11451$，它会变成 $11451->1451->451->51->1$，此时再看第二部分就应该懂了。

时间复杂度 $O(log_{10} n)$。

最后记得开 $ull$。

## 代码

```cpp
#include<bits/stdc++.h>

#define ll unsigned long long
#define y1 caibictq

using namespace std;

const int MAXN = 200010;
const int MAXM = 100010;
const int mod = 1e9 + 7;
const int INF = 0x3f3f3f3f;

ll ans;

ll a[MAXN], cnt[MAXN], xpo10[MAXN];
ll ans1[MAXN], ans2[MAXN];

void Count(ll num, ll *b) {
	int len = 0;
	ll tmp = num;
	while (num) {
		a[++len] = num % 10;
		num /= 10;
	}
	num = tmp;
	for (int i = len; i >= 1; i--) {
		for (int j = 0; j <= 9; j++) {
			b[j] += a[i] * cnt[i - 1];
		}
		for (int j = 0; j < a[i]; j++) {
			b[j] += xpo10[i - 1];
		}
		num -= a[i] * xpo10[i - 1];
		b[a[i]] += num + 1;
		b[0] -= xpo10[i - 1];
	}
}

int main() {
	int T;
	cin >> T;
	xpo10[0] = 1;
	for (int i = 1; i <= 19; i++) {
		cnt[i] = (cnt[i - 1] * 10) + xpo10[i - 1];
		xpo10[i] = xpo10[i - 1] * 10;
	}
	while (T--) {
		memset(a, 0, sizeof(a));
		memset(ans1, 0, sizeof(ans1));
		memset(ans2, 0, sizeof(ans2));
		ll x, y;
		cin >> x >> y; 
		Count(x - 1, ans1);
		Count(y, ans2);
		ans = 0;
		for (int i = 1; i <= 9; i++) {
			ans += 1ll * i * (ans2[i] - ans1[i]) % mod;
		}
		cout << ans % mod << endl;
	}
	return 0;
}
```

> 日拱一卒，功不唐捐。


---

## 作者：mraymes (赞：3)

本文将同步到 [Hexo 博客](https://mraymes.github.io/).

这里提供一种非数位 DP 的做法, 但仍然使用数位 DP 的最基本的思路: 对于一个区间 $[l, r]$, 计算出 $[1, r]$ 与 $[1, l)$ 的结果并相减.

如何计算出 $[1, n]$ 中所有数的数字和?

我们从最高位开始枚举.  
设区间为 $[1, n]$, 最高位上的数为 $x$, 并且设数位个数为 $k + 1$. 那么可以得出结论: $[1, n]$ 包含区间 $[1, x \cdot 10^k)$.

举个例子:  
当区间为 $[1, 54321]$ 的时候, 我们可以得知它完全包含 $[1, 50000)$. 这样我们就可以方便算出这个子区间内的数字和了. 在这个例子当中, 不计算万位时, 数字和就是 $(1 + 2 + \cdots + 9) \cdot \dfrac{10000}{10} \cdot 5$.

分析:  
对于这个例子, 最核心的部分是计算 $[0, 10000)$ 区间中所有数的数字和. 计算方法如下:  
对于每一位, $0, 1, 2, \cdots, 9$ 出现的频率均为 $10\%$ (包括前导零), 因为区间的右端点 (这里指 $10000$) 是一个 $10$ 的次幂, 因此每一位上每个数字都是均匀分布的. 因此 $[0, 10000)$ 区间所有数的数字和为 $(1 + 2 + \cdots + 9) \cdot \dfrac{10000}{10}$.  
由于这样的区间 (仅仅算个位至千位部分) 出现了五次 (万位分别为 $0, 1, 2, 3, 4$), 因此这个数还要与 $5$ 相乘.

当我们计算完这部分的数字和时, 我们可以类似地求出剩余部分的数字和 (例子中是 $4321$). 但不要忘记加上原先最高位给最终答案提供的贡献 (即 $x \cdot (n - x \cdot 10^k + 1) + \dfrac{x \cdot (x - 1)}{2} \cdot 10^k$). 具体用递归来实现.

最后上代码:
```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

const ll MOD = 1000000007LL;

int ntest;
ll l, r;
int ndigl, ndigr;
ll pow10[19];
ll ans;

template <typename T>
inline T read() {
    T x = 0;
    T multiplier = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            multiplier = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 3) + (x << 1) + (ch & 15);
        ch = getchar();
    }
    return x * multiplier;
}

// n 是区间 (闭区间) 的右端点
// ndig 为 n 的位数, 方便求上文中的 k
ll dfs(ll n, int ndig) {
    ll sum = 0;
    ll x = n / pow10[ndig - 1]; // 最高位
    for (int i = 0; i < x; i++) {
        // 最高位的贡献
        // 区间内有 10 ^ k 个以 i 开头的 k + 1 位数
        // (即 pow10[ndig - 1] 个以 i 开头的 ndig 位数)
        // 因此加上 pow10[ndig - 1] * i 并取模
        (sum += pow10[ndig - 1] % MOD * i) %= MOD;

        if (ndig > 1) {
            // 去除最高位后的数的数字和
            // 式子的正确性已在上文证明
            (sum += pow10[ndig - 2] % MOD * 45 * (ndig - 1)) %= MOD;
        }
    }
    // 剩下 n - x * 10 ^ k + 1 (即 n % pow10[ndig - 1]) 的数
    // 最高位的贡献
    (sum += x * (n % pow10[ndig - 1] + 1)) %= MOD;
    if (ndig > 1) {
        // 递归
        (sum += dfs(n % pow10[ndig - 1], ndig - 1)) %= MOD;
    }
    return sum;
}

int main() {
    pow10[0] = 1;
    for (int i = 1; i <= 18; i++) {
        pow10[i] = pow10[i - 1] * 10;
    }

    ntest = read<int>();
    for (; ntest; --ntest) {
        l = read<ll>() - 1, r = read<ll>();
        ans = 0;
        // 特判 r = 1e+18
        // 因为 1e+18 有 19 位
        // 用 upper_bound 的方法无法算出正确的位数
        if (r == 1000000000000000000LL) {
            r--;
            ans = 1;
        }
        // 用 upper_bound 算出位数
        // 原理: 设一个 k 位数为 x (此处的 k 与上文无关)
        // 则有 10 ^ (k - 1) <= x < 10 ^ k
        ndigl = upper_bound(pow10, pow10 + 18, l) - pow10;
        ndigr = upper_bound(pow10, pow10 + 18, r) - pow10;
        (ans += (dfs(r, ndigr) - dfs(l, ndigl) + MOD) % MOD) %= MOD;
        printf("%lld\n", ans);
    }

    return 0;
}

```


---

## 作者：3493441984zz (赞：2)

# 数位$dp$一眼题


------------

其实看到这题后，脑子有很多思路的吧，而很巧的是，我刚做完[数字计数](https://www.luogu.org/problemnew/show/P2602)

我的思路瞬间被这道题框住，于是我想到我们可以把每一个数字出现的次数记录下来，乘上这个数字后就是答案了

举个例子，我们要求出$[l,r]$区间的数字和

那么我们只需要求出$[1,r]$这个区间所有数字和减去$[1,l-1]$区间所有数字和

那么怎么求数字和呢，假如我们要求$[1,r]$数字和，我们可以统计一下$1$~$9$每个数字出现的次数，

然后分别乘上$1$~$9$

那么这个题目就转化为了上面数字计数了

### 注意别爆了$long\ long$

接下来是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 25
#define int long long
#define ll long long
#define mod 1000000007
using namespace std;
ll l,r,T,ans;
int val[N];
ll f[N][N];
ll Dfs(int pos,bool lead,bool limit,int k,int sum)
{
	if(!pos)
		return sum;
	if(!limit&&!lead&&f[pos][sum]!=-1)
		return f[pos][sum];
	int maxn=limit?val[pos]:9;
	ll ans=0;
	for(int i=0;i<=maxn;++i)
	{
		if(lead&&!i)
			ans+=Dfs(pos-1,1,limit&&(i==maxn),k,sum);
		else
			ans+=Dfs(pos-1,0,limit&&(i==maxn),k,sum+(i==k));
	}
	if(!limit&&!lead)
		f[pos][sum]=ans;
	return ans;
}
ll Get(int x,int k)
{
	memset(f,-1,sizeof(f));
	int len=0;
	while(x)
	{
		val[++len]=x%10;
		x/=10;
	}
	return Dfs(len,1,1,k,0);
}
signed main()
{
	scanf("%lld",&T);
	while(T--)
	{	
		ans=0;
		scanf("%lld%lld",&l,&r);
		for(int i=1;i<=9;++i)
			(ans+=((((Get(r,i)-Get(l-1,i)+mod)%mod)*i)%mod+mod)%mod)%=mod;
		printf("%lld\n",(ans+mod)%mod);
	}
	return 0;
}
~~~

---

## 作者：那个男人 (赞：2)

这题是数位dp，一开始我只会统计每个数出现次数的方法
后来看了下其他过了的人的代码，收到启发打了这个。
来发个c++题解
~~自认为代码风格更适合像我一样的蒟蒻~~
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> P;
const int M=1e9+7;
ll num[25], T;P f[25];
inline void change(ll &x,ll y) {(x+=y)>=M&&(x-=M);}
P dfs(ll len,bool limit,bool lead) {
    if(!len) return make_pair(!lead,0);
    if(f[len].first!=-1&&!limit&&!lead) return f[len];
    ll up=limit?num[len]:9,ans=0;
    ll cnt=0;
    for(ll i=0;i<=up;++i) {
        P now=dfs(len-1,limit&&i==num[len],lead&&!i);
        cnt+=now.first;
        ans=(ans+now.second%M+1ll*now.first%M*i%M)%M;
    }
    if(!lead&&!limit) f[len]=make_pair(cnt,ans);
    return make_pair(cnt,ans);
}
ll solve(ll n){
    ll len=0;for(;n;num[++len]=n%10,n/=10);
    return dfs(len,1,1).second;
}
int main() {
    scanf("%lld",&T);
	while(T--){
    	memset(f,-1,sizeof(f));
		ll l,r;
        scanf("%lld%lld",&l,&r);
        ll ans=((solve(r)-solve(l-1)+M)%M+M)%M;
        printf("%lld\n",ans);
    }
}
```

---

## 作者：CodingOIer (赞：0)

## P4999 烦人的数学作业 题解

### 思路分析

这里有一种数位分治（可能）的方法（根本不是我不会数位 dp）。

在 [P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602) 中，众所周知地可以使用把 $12$ 位数字拆分为两个 $6$ 位。

[代码](https://www.luogu.com.cn/paste/1no6zgr6)

在本题中，如果我们直接以根号的复杂拆分，会得到 $2 \times 10^{9}$ 的优秀优杂度以及一堆常数。

但我们可以分三次啊！

这么拆分后，复杂度来到了 $3 \times 10^{6}$，但加上 $t$ 和累计答案的巨大常数会让 $\texttt{\#17 \#20}$ 获得 TLE。

这时，我们便可以非常自然地想到了再分一次……

那么把 $18$ 分为 $5 + 5 + 4 + 4$，复杂度为 $2 \times 10^5 + 2 \times 10^4$ 以及小常数。

具体的实现如下：

> 首先将 $l$ 不断增加，直到 $l \mod 10^5 = 0$。
>
> 然后将 $r$ 不断减小，直到 $r \mod 10^5 = 99999$。
>
> 如果 $l > r$，退出
>
> $l \gets \frac{l}{10^5}, r \gets \frac{r}{10^5}$
>
> 注意：在第一二步时，如果不是第一次，我们需要加上我们跳过部分的和，同时 $l$ 的贡献是我们跳过数的数量。
>
> 重复以上步骤并加大模数。

具体的实现可以看代码。

### 代码实现

```cpp
#include <cstdio>
constexpr long long Mod = 1e9 + 7;
constexpr long long Sum2 = 2250000;
constexpr long long Sum3 = 999996857;
constexpr long long Sum4 = 955900007;
constexpr long long Step1 = 1e5;
constexpr long long Step2 = 1e5;
constexpr long long Step3 = 1e4;
constexpr long long Less1 = 99999;
constexpr long long Less2 = 99999;
constexpr long long Less3 = 9999;
int t;
long long l, r;
long long answer;
inline void add(long long x)
{
    answer += x;
    answer %= Mod;
}
inline void addAnswer(long long x, long long cnt = 1)
{
    for (; x != 0;)
    {
        add((x % 10) * cnt);
        x /= 10;
    }
}
inline void solve()
{
    answer = 0;
    scanf("%lld%lld", &l, &r);
    // Step 1: 1 ~ 10^5
    for (; l % Step1 != 0 && l <= r;)
    {
        addAnswer(l);
        l++;
    }
    for (; r % Step1 != Less1 && r >= l;)
    {
        addAnswer(r);
        r--;
    }
    if (l > r)
    {
        printf("%lld\n", answer);
        return;
    }
    l /= Step1;
    r /= Step1;
    // Step 2: 10^5 ~ 10^10
    for (; l % Step2 != 0 && l <= r;)
    {
        add(Sum2);
        addAnswer(l, Step1);
        l++;
    }
    for (; r % Step2 != Less2 && r >= l;)
    {
        add(Sum2);
        addAnswer(r, Step1);
        r--;
    }
    if (l > r)
    {
        printf("%lld\n", answer);
        return;
    }
    l /= Step2;
    r /= Step2;
    // Step 3: 10^10 ~ 10^14
    for (; l % Step3 != 0 && l <= r;)
    {
        add(Sum3);
        addAnswer(l, Step1 * Step2);
        l++;
    }
    for (; r % Step3 != Less3 && r >= l;)
    {
        add(Sum3);
        addAnswer(r, Step1 * Step2);
        r--;
    }
    if (l > r)
    {
        printf("%lld\n", answer);
        return;
    }
    l /= Step3;
    r /= Step3;
    // Step 4: 10^14 ~ 10^18
    for (; l <= r;)
    {
        add(Sum4);
        addAnswer(l, Step1 * Step2 * Step3);
        l++;
    }
    printf("%lld\n", answer);
}
int main()
{
    scanf("%d", &t);
    for (int i = 1; i <= t; i++)
    {
        solve();
    }
    return 0;
}
```

---

## 作者：Doubeecat (赞：0)

## 题目链接：

[P4999 烦人的数学作业](<https://www.luogu.org/problem/P4999>)

## 题目描述：

给出一个区间$L - R$，求$L$到$R$区间内**每个数的数字和**，如123这个数的数字和为1+2+3=6

有T组数据，结果$\mod 10^9+7$

$（1 \leq L \leq R \leq 10^18）$

## 解题思路：

~~确实烦人~~

第一眼看上去跟[[ZJOI2010]数字计数](<https://www.luogu.org/problem/P2602>)很像，确实是，把那个题的数位DP抄过来乘个 i 这题就没了。

那为啥要写这个题解呢？因为这个题坑多。

1. 注意开 long long
2. 取模很坑，请使用传统技巧`(ans % mod + mod) % mod`，正确性证明应该不用多说(如果取模有问题似乎会被卡成暴力分？)

## 代码：


```cpp
#include <cstdio>
#include <cctype>
#include <cmath>
#include <cstring>
#define int long long 

const int N = 20;
const int mod = 1e9+7;
const int M = N << 1;

inline int read() {
	char v = getchar();int x = 0,f = 1;
	while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();}
	while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();}
	return x * f;
}

int num[N],dp[N][N],l,r;

int dfs(int pos,bool limit,bool zer,int dig,int sum) {
	int ans = 0;
	if (pos == 0) {
		return sum;
	}	
	if (!limit && dp[pos][sum]) return dp[pos][sum];
	int up = 9;
	if (limit) up = num[pos];
	for (int j = 0;j <= up;++j) {
		ans += dfs(pos-1,(j==up)&&limit,zer||j,dig,sum+((j||zer)&&(j==dig)));
	}
	if (!limit&&zer){
		dp[pos][sum] = ans;
	}
	return ans;
}

int work(int p,int w) {
	memset(dp,0,sizeof(dp));
	int len = 0;
	while (p) {
		num[++len] = p % 10;
		p /= 10;
	}
	return dfs(len,1,0,w,0) % mod;
} 

signed main() {
	int T = read();
	while (T--) {
		int ans = 0;
		l = read(),r = read();
		for (int i = 0;i <= 9;++i) {
			ans += ((work(r,i) - work(l-1,i) % mod) * i) % mod;
		}
		printf("%lld\n",(ans%mod+mod)%mod);
	}
	return 0;
}
```



---


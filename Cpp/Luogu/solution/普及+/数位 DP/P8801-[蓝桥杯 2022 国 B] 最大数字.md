# [蓝桥杯 2022 国 B] 最大数字

## 题目描述

给定一个正整数 $N$。你可以对 $N$ 的任意一位数字执行任意次以下 2 种操作:

1. 将该位数字加 $1$。如果该位数字已经是 $9$，加 $1$ 之后变成 $0$。

2. 将该位数字减 $1$。如果该位数字已经是 $0$，减 $1$ 之后变成 $9$。

你现在总共可以执行 $1$ 号操作不超过 $A$ 次，$2$ 号操作不超过 $B$ 次。

请问你最大可以将 $N$ 变成多少?

## 说明/提示

**【样例说明】**

对百位数字执行 $2$ 次 $2$ 号操作，对十位数字执行 $1$ 次 $1$ 号操作。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，$1 \leq N \leq 100 ; 0 \leq A, B \leq 10$ 

对于 $100 \%$ 的数据, $1 \leq N \leq 10^{17} ; 0 \leq A, B \leq 100$ 

蓝桥杯 2022 国赛 B 组 D 题。

## 样例 #1

### 输入

```
123 1 2```

### 输出

```
933```

# 题解

## 作者：Fated_Shadow (赞：22)

[题目传送门](https://www.luogu.com.cn/problem/P8801)，同时，[到博客使用更好](https://www.luogu.com.cn/blog/622466/p8801-ti-xie)。
# Introduction
对于这道 数位 dp 偏简单例题——

（怎么看出来的？~~标签~~，处理数较大，处理部分按数位进行，是数位 dp 罢。）

楼下大佬用递归搜索 dp 或贪心暴力切题，本人秉着应有尽有的原则，为社区着想 ~~（蹭估值）~~ 地交了一篇递推写法的 dp。
# Solution
先将输入的数字按位处理好后，应该建立状态转移方程。

因为本题数据太水了（bushi，~~蒟蒻懒得想~~，故构造了一个三维数组 $dp_{i,k,p}$，其中：
* $i$ 表示已经推到了第 $i$ 位（从低位向高位）。
* $k$ 表示还剩下 $j$ 次 操作 $1$ 的次数。
* $p$ 则表示还剩下 $k$ 次操作 $2$ 的次数。

那么依照背包问题的处理方式，假设将当前位数字 $x$ 变换为 $y$，需操作 $1$ 共 $a$ 次，操作 $2$ 共 $b$ 次，那么：

```
dp[i][k][p] = max(dp[i][k][p],dp[i - 1][k - a][p] + sum);
dp[i][k][p] = max(dp[i][k][p],dp[i - 1][k][p - b] + sum);
```
(此时请注意 $j - a$ 与 $k - b$ 是否大于等于 $0$，其中 $sum$ 表示 `pow(10,i - 1) * y`。)

然后在将 $y$ 枚举：`for（y : x ~ 9)`。（为什么不从 $x + 1$ 开始呢，因为即使预处理过了，但随着低位的递推，那么 $x$ 位也应该有所更替，~~蒟蒻就在这里写挂了~~。）

通过动态规划递推得到的数组，按照其定义，只用输出 $dp_{[\text{数的长度}][\text{操作 }1\text{ 次数}][\text{操作 }2\text{ 次数}]}$ 即可。

依照贪心思想，那如果执行操作 $2$，则 $y$ 会递减，那只有将 $y$ 变化为 $9$ 才是当前最优解，否则当前的答案不是最优解，可以直接舍去。

（代码中未给出优化，想要再调时间的 dalao 可以自己去试一试）。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int N = 30,M = 110;
long long dp[N][M][M],ans[N][2],num;//十年 oi 两行泪，不开 long long ___
int n,m,q[N],len = 0;

long long turn(long long a,long long b)//比较方便的快速幂
{
	long long s = 1;
	while(b)
	{
		if(b & 1) s *= a;
		a *= a;
		b >>= 1;
	}
	return s;
}
void deal()//预处理一部分数组，最开始都是原数字的一部分
{
	memset(dp,0,sizeof dp);
	for(int i = 1;i <= len;++ i)
	{
		long long sum = q[i] * turn(10,i - 1);
		for(int k = 0;k <= n;++ k)
			dp[i][k][0] = dp[i - 1][k][0] + sum;
		for(int p = 0;p <= m;++ p)
			dp[i][0][p] = dp[i - 1][0][p] + sum;
	}
}
void solve(long long x)
{
	memset(q,0,sizeof q);
	while(x) q[++ len] = x % 10,x /= 10;//将整个数处理为数位
	deal();
	
	for(int i = 1;i <= len;++ i)//用背包的方式处理数组，思想同上
	{
		for(int j = q[i];j <= 9;++ j)
		{
			int a = j - q[i],b = q[i] + 10 - j;
			long long sum = j * turn(10,i - 1);
			for(int k = 0;k <= n;++ k)
			for(int p = 0;p <= m;++ p)
			{
				if(k >= a) dp[i][k][p] = max(dp[i][k][p],dp[i - 1][k - a][p] + sum);
				if(p >= b) dp[i][k][p] = max(dp[i][k][p],dp[i - 1][k][p - b] + sum);//记得判断是否够用
			}
		}
	}
	return ;
}

int main()
{
	scanf("%lld%d%d",&num,&n,&m);
	solve(num);
	printf("%lld",dp[len][n][m]);//输出即可
	return 0;
}
```
# Afterword
第一次写 tj，如有 bug 或 hack，请联系本蒟蒻，一定改正。

~~（没有也可以点个赞或关注啊）。~~


---

## 作者：ran_qwq (赞：19)

看到题目第一感就是贪心：枚举每一个数，如果该数位能达到 $9$ 就变为 $9$，不行就用操作 $1$，使其尽可能大。

但是，可能有 $2$ 种操作能使它变为 $9$，该如何选择呢？

因为本题数据量非常少，$N$ 最多 $18$ 位，所以可以进行时间复杂度上限为 $2^N$ 的搜索。

还是对于每一位：

- 如果不能变为 $9$ 就用操作 $1$，使其尽可能大。

- 如果只能通过一种操作使其变为 $9$，就用这种操作把它变为 $9$。

- 如果两种都可以，则两种都试一试，看看哪种更优。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,INF=1e9;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		x=x*10+ch-'0',ch=getchar();
	return x*f;
}
string s,ans;//其实可以用字符串来存数的，甚至比long long更方便
int n,a,b; 
void dfs(int k,int c,int d,string str)
{
	if(k==n)
	{
		if(str>ans)//取最优解
			ans=str;
		return;
	}
	int x=9-str[k]+'0',y=str[k]-'0'+1;
	if(c+x<=a&&d+y<=b)//如果两种都能变为9
		str[k]='9',dfs(k+1,c+x,d,str),dfs(k+1,c,d+y,str);//两种都试一试
	else if(c+x<=a)//如果只有操作1能
		str[k]='9',dfs(k+1,c+x,d,str);
	else if(d+y<=b)//如果只有操作2能
		str[k]='9',dfs(k+1,c,d+y,str);
	else//如果都不能
		str[k]+=a-c,dfs(k+1,a,d,str);//把操作1用光
}
signed main()
{
	cin>>s,ans=s,n=s.size(),a=read(),b=read();
	dfs(0,0,0,s);
	cout<<ans;
}

```


---

## 作者：Exp10re (赞：8)

## 前言

这一篇题解是对本题其他题解的优化。

其他题解的时间复杂度无非是以下两种中的一种：$ O(2^{\lg N}) $ 或者 $ O(A^2\lg N) $。

在此处我会提供一种时间复杂度为 $ O(A\lg N) $ 的解法，理论上在最大数据的时间复杂度会严格优于 $ O(A^2\lg N) $，大多数情况下也优于 $ O(2^{(\lg N)}) $。

如果我对于时间复杂度的分析以及对解题思路的表述有误，可以在评论区指出，谢谢。

## 解题思路

看到数位变换很容易想到数位 DP。

考虑另外一个问题：对于一个正整数 $ N $，现在可以将它的任意一位修改为 $ 0 $ 到 $ 9 $ 之间的任意数字，仅能操作一次，求修改后最大的 $ N $。

答案显而易见，将 $ N $ 最高的非 $ 9 $ 位修改为 $ 9 $ 必定是最优解。

现在我们回到原题面，来规划 DP 式子：设 $ f_{i,j} $ 表示对于 $ N $ 的第 $ i $ 位，将该位以及比该位更高的数位全部通过操作转变成 $ 9 $ 且还可以使用 $ j $ 次操作 $ 1 $ 的情况下最多能使用 $ f_{i,j} $ 次操作 $ 2 $。

~~（如果这一段读着很绕口……多读几遍qwq）~~

我们可以预处理出 $ N $ 的每一位的数值，然后分析如何操作才能使得该位变成 $ 9 $。

根据描述，操作 $ 1 $ 和操作 $ 2 $ 是互逆的，所以对于 $ N $ 的第 $ i $ 位 $ num_i $，把这一位变成 $ 9 $ 的最优方案有且仅有两种：

1. 使用 $ ( 9 - num_i ) $ 次操作 $ 1 $。
2. 使用 $ ( num_i + 1 ) \operatorname{mod} 10 $ 次操作 $ 2 $。（只要稍加计算很容易证明）

那么 $ f $ 的转移也显而易见了，对于 $ f_{i,j} $，有两种方式进行转移：

1. $ f_{i,j} = f_{i+1,j+(9-num_i)} $，表示使用了 $ (9-num_i) $ 次操作 $ 1 $。
2. $ f_{i+1,j} - (( num_i + 1 ) \operatorname{mod} 10 ) $，表示使用了 $ (( num_i + 1 ) \operatorname{mod} 10 ) $ 次操作 $ 2 $。

每次转移只需要取最大值即可。

（注：$ f $的初始值为 $ -1 $，表示不存在这种解，即无解。）

在一轮 DP 过后，我们找到在 $ i $ 最小的情况下，$ j $ 最大且有解的 $ f_{i,j} $。根据贪心思想，这是在当前情况下最优的解。

------------

Q：为什么？怎么证明这个解一定最优？

A：因为 $ i $ 以及更高位的值都是 $ 9 $ 并且 $ i $ 是可能的，最小的 $ i $，且无法将下一位再变成新的 $ 9 $，所以 $ i $ 最小的状态一定最优。

在此情况下，$ j $ 代表的是剩余操作 $ 1 $ 的次数，显然这个操作 $ 1 $ 的次数越多越好。

Q：你这有问题啊！"显然这个操作 $ 1 $ 的次数越多越好“，为什么我不保留更多的操作 $ 2 $？

A：别急，看接下来的操作。

------------

我们知道剩余的操作 $ 1 $ 和操作 $ 2 $ 都不能使下一位变成 $ 9 $，那么我们为了使这一位的数值最大化，必须将剩余的所有操作 $ 1 $ 全部用在这一位上，以最大化该位的值。

既然已经使用完了操作 $ 1 $，那么剩余的操作 $ 2 $ 不能放着不管。接下来对于每一位，我们贪心地不断尝试使用操作 $ 2 $ 把该位的数值变为 $ 9 $，直到没有操作 $ 2 $ 可用。

**请注意**，我们只有在保证使用若干次操作 $ 2 $ 一定能把该位的数值变为 $ 9 $ 的情况下才会使用操作 $ 2 $，因为在使用操作 $ 2 $ 不能使该位数值比先前大的情况下使用操作 $ 2 $ 一定更劣。

于是，我们使用了 DP 和贪心最大化了这个数，把它输出就结束了。

## 代码

有注释，如果感觉上面太抽象了可以搭配代码食用。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int dp[22][124],A,B,num[22],m;
int main()
{
	memset(dp,-1,sizeof(dp));
	int i,j,minn,maxn=0ll,bcnt;
	bool flag=false;
	scanf("%lld%d%d",&n,&A,&B);
	while(n>0)//拆分n 
	{
		m++;
		num[m]=n%10ll;
		n/=10ll;
	}
	dp[m+1][A]=B;
	minn=m+1;
	for(i=m;i>=1;i--)//数位DP 
	{
		flag=false;
		for(j=0;j<=A;j++)
		{
			dp[i][j]=max(dp[i][j],max(dp[i+1][j+(9-num[i])],dp[i+1][j]-((num[i]+1)%10)));//DP，解释见上面 
			if(dp[i][j]!=-1)//flag表示第i位是否有解 
			{
				flag=true;
			}
		}
		if(flag)
		{
			minn=i;//在第i位有解的情况下记录i的最小值 
		}
		else
		{
			break;//若第i位无解，那么第i+1位也一定无解，直接break 
		}
	}
	for(i=0;i<=A;i++)
	{
		if(dp[minn][i]!=-1)
		{
			maxn=i;//贪心地寻找i一定时最大的，有解的j，记为maxn 
			bcnt=dp[minn][i];//bcnt表示的是当j最大时所对应的，剩余操作2的次数
		}
	}
	for(;m>=1;m--)
	{
		if(m>=minn)
		{
			printf("9");//大于等于minn的位数都通过操作可以变成9 
		}
		else if(m==minn-1)
		{
			printf("%d",num[m]+maxn);//对不能变成9的下一位使用maxn次操作1 
		}
		else
		{
			if(bcnt>=num[m]+1)//不断尝试使用操作2将某一位变成9 
			{
				bcnt-=num[m]+1;
				printf("9");
			}
			else
			{
				printf("%d",num[m]);
			}
		}
	}
	return 0;
}
```

## 补充：时间复杂度

显而易见， DP 数组 $f_{i,j}$ 的第一位取值范围是 $ 1 $ 到 $ \lg N $，第二位取值范围为 $ 0 $ 到 $ A $，其余贪心部分时间复杂度基本可以忽略不计，因此总时间复杂度为 $ O(A\lg N) $。

交了三发，一下冲到了最优解[rk #2](https://www.luogu.com.cn/record/118355272)。

虽然时间复杂度的优化在提交界面不明显，但是显然，在 $ \lg N $ 或者 $ A $ 足够大时，$ O(A\lg N) $ 的时间复杂度优势非常明显。因此，虽然 $ O(A\lg N) $ 的解法相对于其他解法比较繁琐，但也不失是一种复杂度优秀的解。

------------

$$\texttt{The End.}$$

---

## 作者：uid_310801 (赞：6)

设 $dp_{i,j,k}$ 为前 $i$ 位，使用了 $j$ 次 $1$ 操作，k次 $2$ 操作，得到的值的最大值。

则有

$dp_{i,j,k}= \displaystyle\max_{l\le j,m\le k}\{dp_{i+1,l,m}\times 10+update(val_i,j-l,k-m)\}$

其中 $val_i$ 表示第 $i$ 位初始的值，$update(a,b,c)$ 表示 $a$ 进行 $b$ 次 $1$ 操作，$c$ 次 $2$ 操作后的值。

直接暴力转移为 $O(NA^4)$，实在太傻了。考虑优化。首先不可能在一位上同时使用 $A$ 和 $B$ 操作，所以转移的时候需要固定一维。然后在同一位使用 $10$ 次以上同一个操作是不优的，所以限制 $j-l$ 和 $k-m$ 的值。这样的时间复杂度为 $O(NA^2)$.

答案就是 $ 	\displaystyle\max_{0\le j \le A,0\le k\le B}\{dp_{1,j,k}\}$.

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100+10;
ll dp[20][N][N],n,a,b,cnt,v[N],ans;
signed main(){
	scanf("%lld %lld %lld",&n,&a,&b);
	while(n){
		v[++cnt]=n%10;
		n/=10;
	}
	for(int i=cnt;i>=1;i--){
		for(int j=0;j<=a;j++){
			for(int k=0;k<=b;k++){
				for(int l=j;l>=max(0,j-9);l--){
					ll val=v[i]+j-l;if(val>=10)	val-=10;
					dp[i][j][k]=max(dp[i][j][k],dp[i+1][l][k]*10+val);
				}
				for(int l=k;l>=max(0,k-9);l--){
					ll val=v[i]-k+l;if(val<0)	val+=10;
					dp[i][j][k]=max(dp[i][j][k],dp[i+1][j][l]*10+val);
				}
				if(i==1){
					ans=max(ans,dp[i][j][k]);
				}
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：Elairin176 (赞：3)

[传送门](https://www.luogu.com.cn/problem/P8801)                 
dfs 和贪心的好题。             
我们把一开始的数字看做一个字符串，用 string 保存。               
之后我们进行 dfs，传入四个值：$s,a,b,pos$。         
$s$ 表示字符串，$a$ 和 $b$ 表示相应操作可以再进行的次数，$pos$ 表示目前扫描到的位置。           
设 $x$ 为这次 dfs 中 $s_{pos}$ 对应的数字。         
那么，我们贪心地想，我们可以从高位向低位 dfs，尽量使 $x=9$。         
所以，我们容易发现可以使用 $9-x$ 的第一种操作将 $s_{pos}$ 变为 $9$。         
如果不行，那么同样，我们使高位更大，把剩余的第一种操作都用完即可。          
对于第二种操作，我们容易发现可以使用 $x+1$ 的第二种操作把 $s_{pos}$ 变为 $9$。         
那对于其他第二种情况呢？        
我们可以跳过这一位，在后面继续 dfs，找到更小的数进行修改。         
我们可以加一个小优化，在使用第一种和第二种操作的特殊情况时，我们判断 $a=0$ 或 $b=0$，如果这个条件为真，那么可以不进行下一次 dfs。          
[CODE](https://www.luogu.com.cn/paste/u1dngxej)

---

## 作者：LuomuQDM (赞：3)

### 题意

给一个位数不超过 $18$ 的数 $n$，有 $a$ 次机会给其一位加 $1$，若此位为 $9$ 则变为 $0$，有 $b$ 次机会给其一位减 $1$，若此位为 $0$ 则变为 $9$。

### 思路

做这种使一个数修改后最大的题有一个很显然的性质，就是先使高位数字最大一定是最优的。

本题数据范围很小，可以直接暴力。

因为操作使对每一位进行的，所以从高位向低位依次执行 $\text{dfs}$。

题目没有要求操作次数必须全部用完，所以在保证数最大且使用同种操作的情况下，能少使用操作次数就尽量少用操作次数：

对于每一位，我们当然希望他变成 $9$，因为这样可以保证在高位确定时结果是最大的。当当前位数字为 $u$ 时，通过加 $1$ 使其变为 $9$ 需要的次数为 $9-u$，通过减 $1$ 使其变为 $9$ 需要的次数为 $u+10-9=u+1$。

对数位减 $1$ 的操作除特殊情况（$0$ 变 $9$）外，都只会使原数最小，所以当前数字不能通过减小到 $9$ 时不尝试减 $1$ 操作。

### 代码

```
#include<bits/stdc++.h>
#define maxn 10010//实际上dfs出的结果会很少
using namespace std;
string s,now,ans[maxn];
int len,a,b,sum;
void dfs(int x,int a,int b){
	if(x==len)return ans[++sum]=now,void();//储存结果
	int u=s[x]-'0';
	if(9-u<=a){//通过加1可以到9
		now[x]='9';
		dfs(x+1,a+u-9,b);
	}
	if(u+1<=b){//减1可以到9，否则不考虑减1操作
		now[x]='9';
		dfs(x+1,a,b-u-1);
	}
	if(9-u>a&&u+1>b){
		now[x]=u+a+'0';
		dfs(x+1,0,b);//低位可能可以通过减1到9，所以还要继续dfs
	}
}
int main(){
	cin>>s>>a>>b;
	len=s.size();
	now=s;
	dfs(0,a,b);
	sort(ans+1,ans+sum+1);//将结果排序
	cout<<ans[sum]<<endl;
	return 0;
}
```

---

## 作者：15066212pp (赞：1)

# 题目描述

给定一个正整数 $N$。你可以对 $N$ 的任意一位数字执行任意次以下 2 种操作:

1. 将该位数字加 $1$。如果该位数字已经是 $9$，加 $1$ 之后变成 $0$。

2. 将该位数字减 $1$。如果该位数字已经是 $0$，减 $1$ 之后变成 $9$。

你现在总共可以执行 $1$ 号操作不超过 $A$ 次，$2$ 号操作不超过 $B$ 次。

请问你最大可以将 $N$ 变成多少?

------------

# 题解

### 使用回溯算法和深搜

- 优先高位的 $9$，用加法到 $9$ 和用减法到 $9$ 都要进行搜索，然后搜索下一位。

- 高位不能到 $9$ ，就用加法把数字增大，搜索下一位。

- 用一个变量记录搜索过程中的最大值。

------------

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long LL;

vector<LL> arr;

class Solution {
public:
    LL size;
    LL res;

    LL solve(LL n, LL A, LL B) {
        arr.clear();
        res = 0;
        stack<int> st;
        while (n > 0) {
            st.push((int) (n % 10));
            n /= 10;
        }
        size = (LL) st.size();
        while (!st.empty()) {
            arr.push_back(st.top());
            st.pop();
        }
        dfs(0, A, B);
        return res;
    }

    void dfs(LL n, LL A, LL B) { // NOLINT(*-no-recursion)
        if (n == size || (A == 0 && B == 0)) {
            LL value = 0;
            for (int i = 0; i < size; i++) {
                value = value * 10 + arr[i];
            }
            res = max(res, value);
            return;
        }
        LL curr = arr[n];
        if (9 - curr <= A) {
            arr[n] = 9;
            dfs(n + 1, A - (9 - curr), B);
            arr[n] = curr;
        }
        if (curr + 1 <= B) {
            arr[n] = 9;
            dfs(n + 1, A, B - (curr + 1));
            arr[n] = curr;
        }
        if (9 - curr > A && curr + 1 > B) {
            arr[n] = curr + A;
            dfs(n + 1, 0, B);
            arr[n] = curr;
        }
    };
};

Solution tool{};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    LL n, A, B;
    cin >> n >> A >> B;
    LL res = tool.solve(n, A, B);
    cout << res << endl;
}

```


---

## 作者：liupei (赞：1)

## 题意
给一个小于 $10^{17}$ 的数字，不超过 $a$ 次可以给一位加一，$9$ 再加就变成$0$.。

不超过 $b$ 次可以给一位减一，$0$ 再减变成 $9$。

## 思路
思维+暴力深搜

 使用肯定是从前面开始的，因为是不超过多少次使用，前面就是能省则省，但是但凡有用，必须使用，暴力出答案即可。

对于每种情况只能是暴力的搜答案，时间复杂度最坏应该是 $2^{18}$ 了差不多。

然后一直纠结用字符串还是整数来表示，整数肯定更方便计算和简洁，字符串便于修改，后面用数量级还是实现了整数的修改。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fo(a,b) for(int i=a;i<=b;i++)
#define inf 0x3f3f3f3f
#define LL long long
#define M 100010
LL a,b,c;
LL maxx=0;
void dfs(LL a,LL ans,LL b,LL c){
    if(ans==0){
        maxx=max(maxx,a);
        return;
    }
    int d=a/ans%10;
    if(b>9-d){
        int r=b-(9-d);
        dfs(a+(9-d)*ans,ans/10,r,c);
    }else{
        dfs(a+b*ans,ans/10,0,c);
    }
    if(c!=0){
        if(c>=d+1){
            int r=c-(d+1);
            dfs(a-d*ans+9*ans,ans/10,b,r);
        }
    }
}
int main()
{
    cin>>a>>b>>c;
    LL tmp=a;
    LL ans=1;
    while(a){
        a/=10;
        ans*=10;
    }
    dfs(tmp,ans/10,b,c);
    cout<<maxx<<endl;
	return 0;
}
```

---

## 作者：Remarks (赞：0)

CODE : https://www.luogu.com.cn/record/160374164

代码比较抽象，细节为了省事用了各种神秘的实现，望原谅。

这份代码是 $O(n \log^2 n)$ 的，将 sort 更换为桶排序即可做到 $O(n\log n)$。

具体实现：

考虑最后答案一定是若干 9 在头，后面接一串未知的数，我们直接二分前面 9 的数量，可以发现：转化为判别性问题后，所有位置是等价的，故先给更小的数上 `2` 操作，然后再给剩余的数上 `1` 操作这一贪心策略具有了正确性。

然后看后面的部分，容易发现下一位一定不是 9 （已经找到了最长），所以下一位一定不用 `2` 操作，而是用 `1` 操作；同时 `1` 操作不可能使这一位超过 9 ，直接加，同时我们用完了所有的 `1` 操作，剩余位置，用剩余的 `2` 操作直接尽可能的把高位变 9 即可实现。

另外吐槽一句，数据过于水了，以至于一种错误的贪心 [做法](https://www.luogu.com.cn/record/160372269) 通过，建议加强数据。

---

## 作者：BugGod (赞：0)

首先第一眼看到这个题，想到贪心，从高位到低位（因为高位数字更改贡献更大），尽量让每一位更大。但是这样做有一个问题，就是变为 $9$ 有两种方式，可以加也可以减，又想到暴搜，枚举每一位用加法还是减法，发现复杂度最大为 $O(2^l)$，$l$ 为 $n$ 的位数。于是这道绿题就很愉快地被切掉了。

CODE：（注意一些细节）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a,b;
string str,ans;
void dfs(int wei,int x,int y,string k)//x记录用了几次加法，y记录用了几次减法
{
	if(wei==str.size())//这里不能减一，否则最后一位可能没有更新
	{
		if(k>ans)ans=k;//位数一样，直接按字典序排
		return ;
	}
	int xx=9-(k[wei]-'0'),yy=(k[wei]-'0')+1;
	if(xx+x>a&&yy+y>b)//两种方式都不能变为9，就用加法，因为减法不能变为9的话只会更小
	{
		k[wei]+=a-x;
		dfs(wei+1,a,y,k);
	}
	if(xx+x<=a&&yy+y>b)//只能加
	{
		k[wei]='9';
		dfs(wei+1,x+xx,y,k);
	}
	if(xx+x>a&&yy+y<=b)//只能减
	{
		k[wei]='9';
		dfs(wei+1,x,y+yy,k);
	}
	if(xx+x<=a&&yy+y<=b)//都可以，就都搜一遍
	{
		k[wei]='9';
		dfs(wei+1,x+xx,y,k);
		dfs(wei+1,x,y+yy,k);
	}
}
signed main()
{
	//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>str>>a>>b;
	dfs(0,0,0,str);
	cout<<ans;
	return 0;
}
```

---

## 作者：12345678hzx (赞：0)

## 题目大意
有一个正整数 $N$，你可以将 $N$ 的其中一位数字加 $1$，或使 $N$ 的其中一位数字减 $1$，加 $1$ 的操作最多进行 $A$ 次，减 $1$ 的操作最多进行 $B$ 次，特别的，$9$ 加 $1$ 等于 $0$，$0$ 减 $1$ 等于 $9$，求 $N$ 所能到达的最大值。
## 思路
考虑贪心。

我们使用搜索，尽可能让 $N$ 的高位尽可能的大，由于一个数到达 $9$ 有两种方式，所以我们把两个状态都搜一遍由于每个值最多扩展出两个状态，设 $x$ 是 $n$ 的位数，则时间复杂度为 $O(2^x)$。
## 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

string n;
long long a,b,answer,ans;
inline void dfs(int x) {
	if(x>=n.size()) {
		ans=0;
		for(int i=0;i<n.size();i++) ans=ans*10+n[i]-'0';
		answer=max(answer,ans);
		return;
	}
	if(a>='9'-n[x]) {
		int y='9'-n[x];
		n[x]='9';
		a-=y;
		dfs(x+1);
		n[x]='9'-y;
		a+=y;
	}
	if(b>=n[x]-'0'+1) {
		int y=1+n[x]-'0';
		n[x]='9';
		b-=y;
		dfs(x+1);
		n[x]=y-1+'0';
		b+=y;
	}
	if(a<'9'-n[x]) {
		int y=a;
		a=0;
		n[x]+=y;
		dfs(x+1);
		n[x]-=y;
		a=y;
	}
}
int main() {
	cin>>n>>a>>b;
	dfs(0);
	cout<<answer;
	return 0; 
}
```

---

## 作者：紊莫 (赞：0)

## Part 1 错解

你可能很快想到一个贪心，就是让前面的位尽可能大，能到九就到九。但是如果有两种方法可以使得当前这一位最大，似乎就不好选择了。

所以，我们需要搜索。  

## Part 2 暴力

容易的，写出一个惊人的大暴力。  

```cpp
int a,b;
int x[105],m,ans,y[105];
void dfs(int p,int ua,int ub){
	if(!p){
		int sum=0;
		for(int i=m;i>=1;i--)
			sum=sum*10+y[i];
		ans=max(ans,sum);
		return ;
	}
	for(int i=ua;i<=a;i++){
		for(int j=ub;j<=b;j++){
			y[p]=(((x[p]+(i-ua)-(j-ub))%10)+10)%10;
			dfs(p-1,i,j);
		}
	}
}
signed main(){
	int n=read();
	a=read(),b=read();
	while(n){x[++m]=n%10;n/=10;}
	dfs(m,0,0);write(ans);
    return 0;
}
```
自信的说，这应该是本题最暴力的解法了。  

怎么办呢？你当然可以加上一个最优性剪枝，可惜这样也只有最多 $\texttt{60 pts}$。  

## Part 3 正解

回想一下最开始的贪心错解，发现正解搜索便可以从中改编而来。  

对于同时有多种可能到达最大数的情况，这不就是搜索的分枝吗！  
因为每一层搜索中至多有两个分枝，所以就能秒过了！  

```cpp
int a,b;
int x[105],m,ans,y[105];
void dfs(int p,int ua,int ub){
	int sum=0,flag=0;
	if(!p){
		for(int i=m;i+1;sum=sum*10+y[i--])
			ans=max(ans,sum);
		return ;//统计答案
	}
	if(9-x[p]<=a-ua)
		y[p]=9,dfs(p-1,ua+9-x[p],ub),flag=1;//通过加法到 9
	if(x[p]+1<=b-ub)
		y[p]=9,dfs(p-1,ua,ub+x[p]+1),flag=1;//减法
	if(!flag) y[p]=x[p]+a-ua,dfs(p-1,a,ub);//到不了 9 就用加法
}
```

这不就是纯纯贪心吗！



---


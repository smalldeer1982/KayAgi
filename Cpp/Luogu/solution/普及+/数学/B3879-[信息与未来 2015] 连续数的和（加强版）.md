# [信息与未来 2015] 连续数的和（加强版）

## 题目背景

本题是 B3878 的加强版。

## 题目描述

给出两个整数 $n$ 和 $k$，求出 $1\sim n$ 中连续 $k$ 个数的和为完全平方数的个数。

## 说明/提示

### 样例解释
在 $1\sim10$ 中，连续 $3$ 个数的和有：
- $1+2+3=6$；
- $2+3+4=9=3^2$；
- $3+4+5=12$；
- $4+5+6=15$；
- $5+6+7=18$；
- $6+7+8=21$；
- $7+8+9=24$；
- $8+9+10=27$。

故只有 $1$ 个。
### 数据范围
$2\le n\le 10^{10},1\le k\le n$。

## 样例 #1

### 输入

```
10 3```

### 输出

```
1```

# 题解

## 作者：Jorisy (赞：13)

考虑到暴力做法是枚举 $p+(p+1)+(p+2)+\cdots+(p+k-1)$，其中 $p\in[1,n-k+1]$。

众所周知 $p+(p+1)+(p+2)+\cdots+(p+k-1)=\dfrac{(2p+k-1)k}2$。

这个分数很不好看，我们对 $k$ 的奇偶性分讨一下。

当 $k$ 为偶时，令 $k=2u(u\in\mathbb N_+)$。

则 $\dfrac{(2p+k-1)k}2=(2p+2u-1)u$。

我们考虑令 $u=ab^2$，其中 $b^2$ 是 $u$ 的最大平方因子。

则要使得 $(2p+2u-1)u$ 是完全平方数，必须要存在一个正整数 $c$ 使得 $2p+2u-1=ac^2$。

于是我们枚举这个 $c$，看以此求出的 $p$ 是否合法即可。

当 $k$ 为奇时，令 $k=2u+1(u\in\mathbb N_+)$。

则 $\dfrac{(2p+k-1)k}2=(p+u)(2u+1)$。

类似地令 $2u+1=ab^2$ 然后枚举 $c$ 看合法性即可。

时间复杂度 $O(\sqrt n)$。

---

## 作者：yaotianhao (赞：10)

### 题意

求 $1$ 到 $n$ 中连续 $k$ 个数的和为完全平方数的个数。

### 分析

我们先按 $k$ 的奇偶性分讨一下：

如果 $k \bmod 2 = 1$，那么设中间的数为 $mid$，就可以算出这 $k$ 个数的和为 $k \times mid$，为了让这个和为完全平方数，所以 $mid$ 最小要为 $k$，之后就去枚举 $\times 1^2$、$\times 2^2$、$\times 3^2$，直到最后一个数超过 $n$。

如果 $k \bmod 2 = 0$，那么还是设中间的两个数为 $mid$ 和 $mid+1$，那这 $k$ 个数的和是 $\frac{(2 \times mid + 1)\times k}{2}$，然后把 $\frac{k}{2}$ 提取出来，因为它是个常数，不会变，然后就找与 $\frac{k}{2}$ 相乘为完全平方数的最小值，之后还是枚举 $\times 1^2$、$\times 2^2$、$\times 3^2$，再判一下是否有解。

### 代码

代码如下

````cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, k, sum, now = 1, ans;
signed main() {
	scanf("%lld%lld", &n, &k);
	if(k % 2 == 1) {
		for(int i = 1; ; i++) {
			if(k * i * i + k / 2 <= n) sum++;
			else break;
		}
		printf("%lld", sum);
	}
	else {
		int l = k / 2;
		for(int i = 2; i * i <= k; i++) while(l % (i * i) == 0) l /= i * i;
		if(l % 2 == 0) {
			printf("0");
			return 0;
		}
		for(int i = 1; ; i += 2) {
			ans = i * i * l;
			if(ans < k + 1) continue;
			if(ans / 2 + k / 2 <= n) sum++;
			else break;
		}
		printf("%lld", sum);
	}
}
````

---


# [ROIR 2022] 跳跃机器人 (Day 1)

## 题目背景

翻译自 [ROIR 2022 D1T2](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-regional-2022-day1.pdf)。

某公司正在开发一种跳跃机器人。为了测试机器人，他们在一个多边形平台上设置了一个由 $n$ 个特殊平台组成的环形路线，平台从 $1$ 到 $n$ 编号。第 $i$ 个平台与 $i+1$ 个平台之间的距离为 $d_i$，最后一个平台与第一个平台之间的距离为 $d_n$（假设长度分别为 $d_1,d_2,\dots,d_n$ 的边可以组成一个 $n$ 边形）。

机器人配备了人工智能，在测试过程中学习跳得更远。在任何时刻，机器人通过一个整数 $a$ 来表示它的灵敏度。如果 $a$ 大于等于 $d_i$，机器人可以从平台 $i$ 跳到平台 $i+1$；同样地，如果 $a$ 大于等于 $d_n$，机器人可以从最后一个平台跳到第一个平台。每次跳跃后，机器人的灵敏度增加 $1$。

## 题目描述

机器人的开发人员选择一个平台作为起始平台。如果机器人可以完成 $n$ 次跳跃，回到原来的平台，他们认为实验是成功的。开发人员需要确定机器人的最小起始灵敏度是多少，并选择哪个平台作为起始平台。

## 说明/提示

样例说明：

在第二个示例中，距离数组为 $[1, 2, 3, 4, 5, 18, 45, 112, 273, 662]$。

根据公式计算 $d_6$ 到 $d_{10}$ 的值：

- $d_6 = ((1 \cdot d_4 + 2 \cdot d_5 + 3) \bmod 10^9) + 1 = ((1 \cdot 4 + 2 \cdot 5 + 3) \bmod 10^9) + 1 = 18$；
- $d_7 = ((1 \cdot d_5 + 2 \cdot d_6 + 3) \bmod 10^9) + 1 = ((1 \cdot 5 + 2 \cdot 18 + 3) \bmod 10^9) + 1 = 45$；
- $d_8 = ((1 \cdot d_6 + 2 \cdot d_7 + 3) \bmod 10^9) + 1 = ((1 \cdot 18 + 2 \cdot 45 + 3) \bmod 10^9) + 1 = 112$；
- $d_9 = ((1 \cdot d_7 + 2 \cdot d_8 + 3) \bmod 10^9) + 1 = ((1 \cdot 45 + 2 \cdot 112 + 3) \bmod 10^9) + 1 = 273$；
- $d_{10} = ((1 \cdot d_8 + 2 \cdot d_9 + 3) \bmod 10^9) + 1 = ((1 \cdot 112 + 2 \cdot 273 + 3) \bmod 10^9) + 1 = 662$。

本题使用捆绑测试。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $15$ | $n\le300,f=1,d\le300$ |
| $1$ | $17$ | $n\le5000,f=2$ |
| $2$ | $10$ | $n\le100000,f=1$ 且保证从第一个平台开始跳是最佳选择 |
| $3$ | $20$ | $n\le100000,f=1$ |
| $4$ | $5$ | $f=2$ 且保证从第一个平台开始跳是最佳选择 |
| $5$ | $33$ | $f=2$ |

对于 $100\%$ 的数据，$3 \le n \le 10^7$。当 $f=1$ 时 $1 \le d_i \le 10^9$，当 $f=2$ 时 $2 \le m \le \min(n, 10^5)$，$0 \le x, y, z \le 10^9$，$1 \le c_i \le 10^9$。

注：本题的算法标签部分参考了官方题解中用到的解法。

## 样例 #1

### 输入

```
5
1
3 7 4 2 5```

### 输出

```
4 3```

## 样例 #2

### 输入

```
10
2
5 1 2 3
1 2 3 4 5```

### 输出

```
653 1```

# 题解

## 作者：cff_0102 (赞：14)

~~写了半个小时，我是 fw 吗~~。

先假设从第一个点出发。机器人从第 $i$ 个点跳到下一个点所需要的灵敏度是 $d_i$，而从第一个点出发到第 $i$ 个点增加的灵活度是 $i-1$，所以如果机器人要成功跳出 $i$ 点，它在初始的时候灵活度应该是 $d_i-i+1$。那么，答案应该是 $\max\limits_{i=1}^{n}(d_i-i+1)$。可以 $O(n)$ 解决。

但是，题目要我们自己选择一个出发点。如果直接枚举每个出发点，程序是 $O(n^2)$ 的，绝对过不了。

可以把从第 $x$ 个点出发后的 $n$ 个点拆成两个部分，第一个部分的点在 $[x,n]$ 中，第二个部分的点在 $[1,x-1]$ 中。把上面的答案迁移下来，那么从第 $x$ 个点出发的答案应该是 $\max(\max\limits_{i=x}^{n}(d_i-i+x),\max\limits_{i=1}^{x-1}(d_i-(i+n)+x))=\max(\max\limits_{i=x}^{n}(d_i-i+x),\max\limits_{i=1}^{x-1}(d_i-n-i+x))$，程序的最终答案应该是 $\min\limits_{x=1}^{n}(\max(\max\limits_{i=x}^{n}(d_i-i+x),\max\limits_{i=1}^{x-1}(d_i-n-i+x)))$。

设 $r_{i}=d_i-i,l_{i}=d_i-n-i$，则答案为 $\min\limits_{x=1}^{n}(\max(\max\limits_{i=1}^{x-1}(l_{i}+x),\max\limits_{i=x}^{n}(r_{i}+x)))=\min\limits_{x=1}^{n}(\max(\max\limits_{i=1}^{x-1}(l_{i}),\max\limits_{i=x}^{n}(r_{i}))+x)$。可以发现，$\max\limits_{i=1}^{x-1}(l_{i}),\max\limits_{i=x}^{n}(r_{i})$ 中 $l_i,r_i$ 的具体值不受 $x$ 影响，$x$ 只决定了取哪个区间的最大值。又可以发现，这两个区间分别是 $[1,x-1]$ 和 $[x,n]$。所以实际上，可以先 $O(n)$ 计算出 $x$ 为 $1$ 到 $n$ 时 $\max\limits_{i=1}^{x-1}(l_{i}),\max\limits_{i=x}^{n}(r_{i})$ 分别的值（例如分别记为 $L_{x-1},R_{x}$），接下来计算的时候就可以直接用 $\min\limits_{x=1}^{n}(\max(L_{x-1},R_{x})+x)$ 计算就变成 $O(n)$ 的了。

写代码的时候注意数据范围和时空限制。首先，数组不能开 `long long`；其次，在 $f=2$ 时注意乘法运算时先强转 `long long`；接着，区分哪里用 `min`，哪里用 `max`；然后，还要注意定的 `-inf` 要足够小（但不能太小）；最后，别输出反了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int d[11451919],l[11451919],r[11451919],L[11451919],R[11451919];
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	int f;cin>>f;
	if(f==1){
		for(int i=1;i<=n;i++)cin>>d[i];
	}else{
		int m,x,y,z;cin>>m>>x>>y>>z;
		for(int i=1;i<=m;i++)cin>>d[i];
		for(int i=m+1;i<=n;i++)d[i]=(1ll*x*d[i-2]+1ll*y*d[i-1]+z)%1000000000+1;
	}
	for(int i=1;i<=n;i++){
		l[i]=d[i]-n-i;
		r[i]=d[i]-i;
	}
	L[0]=-0x7cff0102;
	for(int x=1;x<=n;x++){
		L[x]=max(L[x-1],l[x]);
	}
	R[n+1]=-0x7cff0102;
	for(int x=n;x>=1;x--){
		R[x]=max(R[x+1],r[x]);
	}
	int mn=0x7cff0102,pos=0xcff0102;
	for(int x=1;x<=n;x++){
		int t=max(L[x-1],R[x])+x;
		if(t<mn){
			pos=x;
			mn=t;
		}
	}
	cout<<mn<<" "<<pos;
	return 0;
}
```

---

## 作者：AKPC (赞：6)

典，考试的纯送分题。

令 $a_i=d_i-i$。

枚举一个 $x$ 表示起始平台，对于每个 $x$，把 $[1,n]$ 划分成 $[1,x)$ 和 $[x,n]$。显然，$a_i+x$ 对应了 $i\in[x,n]$ 的时候，从 $i$ 跳到 $(i+1)\bmod n$ 这个位置需要的灵敏度，$a_i+x-n$ 对应了 $i\in[1,x)$ 的时候，从 $i$ 跳到 $i+1$ 这个位置需要的灵敏度。对于每个 $x$，这两部分取个最大值即可。

如果需要做到 $\Theta(1)$ 求分划的两部分的最大值，可以使用 $a$ 数组的前缀、后缀 $\max$。

[code](/paste/0fiv2h4r)。

---

## 作者：Fislett (赞：5)

考虑枚举起点 $p$，设 $res_p$ 表示以 $p$ 为起点机器人需要的最小起始灵敏度。

分类讨论。

1. 对于 $i \in [p, n]$，从起点 $p$ 到 $i$ 一共跳跃了 $i - p$ 次，即灵活性一共增加了 $i - p$，则要跳出点 $i$ 所需的最小起始灵敏度为 $d_i - (i - p)=d_i - i + p$。
1. 对于 $i \in [1, p)$，从起点 $p$ 到 $i$ 一共跳跃了 $i - p + n$ 次，即灵活性一共增加了 $i - p + n$，则要跳出点 $i$ 所需的最小起始灵敏度为 $d_i - (i - p + n) = d_i - i + p - n$。

所以有：
$$res_p = \max\begin{cases} d_i - i + p & i \in [p, n] \\ d_i - i + p - n & i \in [1, p) \end{cases}$$

考虑正序倒序枚举两次起始点，用 $maxn$ 记录 $d_i - i$ 的最大值，直接转移即可。

## $Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
#define rint register int 
inline int read()
{
    int x = 0, flag = 1; char c = getchar();
    while (!isdigit(c) && c != '-') c = getchar();
    if (c == '-') flag = -1; else x = (c ^ 48); c = getchar();
    while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
    return flag * x;
}
inline void print(rint x, rint flag = 0)
{
    if (x < 0) putchar('-'), x = ~(x - 1);
    if (x > 9) print(x / 10, 0);
    putchar(x % 10 + 48);
    if (flag) putchar(flag & 1 ? ' ' : '\n');
}
const int N = 1e7 + 5;
int n, d[N], f, ans = 2e9, pos, res[N], maxn;
signed main()
{
    n = read(), f = read();
    if (f == 1) for (rint i = 1; i <= n; ++ i) d[i] = read();
    else
    {
        rint m = read(), x = read(), y = read(), z = read();
        for (rint i = 1; i <= m; ++ i) d[i] = read();
        for (rint i = m + 1; i <= n; ++ i) d[i] = (d[i - 2] * x + d[i - 1] * y + z) % 1000000000ll + 1;
    }
    for (rint i = 1; i <= n; ++ i) d[i] -= i; maxn = -2e9;
    for (rint i = 1; i <= n; ++ i) res[i] = maxn - n + i, maxn = max(maxn, d[i]);
    maxn = -2e9;
    for (rint i = n; i; -- i) maxn = max(maxn, d[i]), res[i] = max(res[i], maxn + i);
    for (rint i = 1; i <= n; ++ i)
        if (res[i] < ans) ans = res[i], pos = i;
    print(ans, 1), print(pos);
    return 0;
}
```

---

## 作者：modfish_ (赞：5)

## 思路
令 $f_{i,j}$ 表示从 $i$ 开始，如果只考虑 $d_j$ 的限制的话，$a$ 的最小值。

则有：

$$f_{i,j}=\begin{cases}d_j-(j-i),j\ge i\\d_j-(j+n-i),j<i\end{cases}$$

显然：

$$a=\min_{i=1}^{n}\{\max_{j=1}^nf_{i,j}\}$$

考虑枚举 $i$，则我们需要 $O(1)$ 维护 $\max_{j=1}^nf_{i,j}$。

画张图表，容易发现：

$$f_{i+1,j}=\begin{cases}f_{i,j}+1,i\neq j\\f_{i,j}-(n-1),i=j\end{cases}$$

有了这个规律，递推就不难了。可以维护前缀最大值和后缀最大值。读者们可以自己思考，不会的话，详情可以看代码。

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 1e7 + 5, mod = 1e9;

int a[maxn], max1[maxn], max2[maxn];

int main(){
	int n;
	scanf("%d", &n);
	int f;
	scanf("%d", &f);
	if(f == 1){
		for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	}else{
		ll m, x, y, z;
		scanf("%lld %lld %lld %lld", &m, &x, &y, &z);
		for(int i = 1; i <= m; i ++) scanf("%d", &a[i]);
		for(int i = m + 1; i <= n; i ++) a[i] = (x * a[i - 2] % mod + y * a[i - 1] % mod + z) % mod + 1;
	}
	max1[0] = max2[n + 1] = -2147483647;
	for(int i = n; i >= 1; i --) max2[i] = max(max2[i + 1], a[i] - (i - 1));
	int ans = max2[1], ansi = 1, tot = 0;
	for(int i = 1; i < n; i ++){
		tot ++;
		int sans = min(ans, max(max(max1[i - 1] + tot, max2[i + 1] + tot), a[i] - (n - 1)));
		if(sans < ans) ans = sans, ansi = i + 1;
		max1[i] = max(max1[i - 1] + tot, a[i] - (n - 1)) - tot;
	}
	printf("%d %d", ans, ansi);
	return 0;
}
```

---

## 作者：cff_0102 (赞：4)

从算法标签就能看出本题做法很多。看题解区全是 dp 做法，于是再来写一篇单调队列的题解。

首先，把原本的数组 $d$ 复制一份拼到后面，得到一个大小是原来两倍的数组 $d'$。这样每种可能的环形路径就变成了从第 $x$ 个点跳到第 $x+n$ 个点了。因为在这种情况 $d_{x+n}$ 不会用到，所以可以换一种考虑方法，也就是成功跳出第 $x$ 到第 $x+n-1$ 个平台。

此时，如果从第 $x$（$1\le x\le n$）个点出发，要成功从第 $i$（$x\le i\le x+n-1$）个平台跳出，最开始需要的灵敏度应该是 $d_i-(i-x)$。那么从第 $x$ 个点出发的答案就应该是这里面的最大值，也就是 $\max\limits_{i=x}^{x+n-1}[d_i-(i-x)]=\max\limits_{i=x}^{x+n-1}(d_i-i)+x$。最终答案要从所有出发的点里面取灵敏度最小的，那就应该是 $\min\limits_{x=1}^{n}[\max\limits_{i=x}^{x+n-1}(d_i-i)+x]$。

用[单调队列](https://www.luogu.com.cn/problem/P1886)得出其中的 $\max\limits_{i=x}^{x+n-1}(d_i-i)$ 部分，然后取所有 $\max\limits_{i=x}^{x+n-1}(d_i-i)+x$ 的最小值即可得到答案。

在实现的时候，可以直接将每个 $d_i$ 减去 $i$ 再存下来，后面记为 $d'$。

参考代码：<https://www.luogu.com.cn/paste/u0jd23ng>。

提交上去，发现最后两个子任务全部 MLE。所以需要压缩空间。

不难发现，这份代码没必要真的将 $d$ 数组复制一份后存下来，分别减去 $1\sim2\times n$ 得到 $d'$，只需要存下来原本的 $d$ 数组，然后在将元素放进队列的时候再通过 $d'_{i-1}$ 算出 $d'_{i-1+n}$。具体的，因为 $d'_{i-1}=d_{i-1}-(i-1)$，$d'_{i-1+n}=d_{i-1+n}-(i-1+n)=d_{i-1}-(i-1)-n=d'_{i-1}-n$，所以每次只需要将 $d'_{i-1}$ 减去 $n$，就可以得到新的要放进队列的数。

参考代码：<https://www.luogu.com.cn/paste/ulchua0h>。

提交上去，最后一个子任务还是有四个测试点 MLE，所以需要继续优化空间。

不难发现，数据范围中，当 $f=1$ 时，$n$，也就是数组的数字个数，是小于等于 $10^5$ 的；而当 $f=2$ 时，$m$，也就是直接输入进来的数组数字个数，也是小于等于 $10^5$ 的。正好，当 $n>10^5$ 时，$f=2$，$d_i$（$i>10^5$）仅需要通过 $d_{i-1}$ 和 $d_{i-2}$ 计算出来。所以，$d$ 数组只需要开到 $10^5$，当 $f=1$ 时就直接将整个数组存进去就好；而当 $f=2$ 时可以将前 $m$ 个数存进数组中，后面的数字动态计算，只需要用两个变量实时存储当前的 $d_{i-1}$ 和 $d_{i-2}$ 即可。在计算 $d'_{i-1+n}$ 的时候，当 $f=1$ 时，还是和之前一样做即可；而当 $f=2$ 时就麻烦些，需要判断当前的 $i-1$ 是否小于等于 $m$，如果是则直接调出存储的 $d_{i-1}$ 并按前文所说的方法计算出 $d_{i-1+n}$；如果不是，需要通过 $d_{(i-1)-2}$ 和 $d_{(i-1)-1}$ 计算出 $d_{i-1}$，再由此计算出 $d_{i-1+n}$。

参考代码：<https://www.luogu.com.cn/paste/kx4nerm3>。

AC 记录：<https://www.luogu.com.cn/record/176417959>。

另注：其实只要把第一份代码里的 `d[i].a=(x*d[i-2].a+y*d[i-1].a+z)%1000000000+1;` 改成 `d[i].a=(1ll*x*d[i-2].a+1ll*y*d[i-1].a+z)%1000000000+1;`，并注释掉 `#define int long long` 就能通过这题，那么为什么本题解作者还要卡空间呢，~~是忘了可以这样做吗~~。

---

## 作者：HD0X (赞：3)

# Solution
## Subtask 0
暴力枚举起点和初始能力值，时间复杂度 $ O(n^2 \times d) $，预期得分 $\text{15}$ 分。

~~应该没有人只打了这一档吧~~
## Subtask 1
暴力枚举起点，$O(n)$ 扫一转，能力值走到哪里不够了就加上去，时间复杂度 $O(n^2)$，综合上述算法，预期得分 $\text{32}$ 分。
## Subtask 2 & 4
模拟即可，时间复杂度 $O(n)$。综合上述算法，预期得分 $\text{47}$ 分。
## Subtask 3
未知奇妙小做法。
## Subtask 6
考虑动态规划。

题解区都有，不做过多赘述。

设 $f_i$ 表示从 $i$ 号木桩出发的最小初始能力值。

则：
$$ f(x)=max\left\{
\begin{aligned}
d_j + i - j,j \in (i,n] \\
d_j + i - j - n,j \in [1,i)\\
\end{aligned}
\right.
$$

预处理前缀最大以及后缀最大的 $d_j - j$，可以做到$ O(1)$ 转移。

时间复杂度 $O(n)$ ，非常优秀。

综合上述算法，预期得分 $\text{100}$ 分，至此，本题可通过。

## 其他做法
上述 $dp$ 做法的时间复杂度正确，但需要开 $\text{3}$ 个 $10^7$ 的数组，而且也不是特别快。

考虑贪心。

在跳一圈的过程中，瓶颈实际在于 $\max(d_i)$，所以从最大处向前开始模拟，能走就走，走不动了就加到当前值加一（因为跳之前应是正好相等最优），走一圈就跳出。

正确性显然，时间复杂度 $O(n)$，且只需要开 $\text{2}$ 个 $10^7$ 的数组，甚至可以通过 $5 \times 10^7$的加强数据。

至此，本题~~又~~可通过，甚至截至目前[次优解](https://www.luogu.com.cn/record/190105564)。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e7+10,mod=1e9;
int n,f,d[MAXN],m,x,y,z,mx,id,fa[MAXN],ans,as;

inline int read()
{
	int x=0;char ch=getchar();
	while(ch<'0' || ch>'9') ch=getchar();
	while('0'<=ch && ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x;
}

void init()
{
	n=read(),f=read();
	for(int i=2;i<=n;i++) fa[i]=i-1;
	fa[1]=n;
	if(f==1)
	{
		for(int i=1;i<=n;i++) d[i]=read(),(d[i]>mx?mx=d[i],id=i:i=i); 
	}
	else
	{
		m=read(),x=read(),y=read(),z=read();
		for(int i=1;i<=n;i++)
		{
			if(i<=m) d[i]=read();
			else d[i]=(1ll*x*d[i-2]+1ll*y*d[i-1]+z)%mod+1;
			if(d[i]>mx) mx=d[i],id=i;
		}
	}
	return ;
}

void solve()
{
	int ret=id;
	ans=INT_MAX;
	while(true)
	{
		if(fa[id]==ret) break;
		if(mx-1<d[fa[id]])
		{
			if(ans>mx)
			{
				ans=mx;
				as=id;
			}
			mx=d[fa[id]]+1;
		}
		--mx;
		id=fa[id];
	}
	if(ans>mx)
	{
		ans=mx;
		as=id;
	}
	cout<<ans<<" "<<as<<endl;
	return ;
}

signed main()
{
	init();
	solve();
	return 0;
}
```

---

## 作者：Lu_xZ (赞：3)

记 $f_i$ 表示从 $i$ 出发的答案。

不难得到，$f_1 = \max(d_1, d_2 - 1, d_3 - 2, \cdots)$。

考虑 $f_i$ 需要满足的必要条件：

+ $f_i \ge d_i$。
+ $f_i + 1 \ge f_{i + 1}$。

两个条件同时成立就是充分的，即 $f_i = \max(d_i, f_{i + 1} - 1)$。

这样就在 $O(n)$ 时间内递推出所有 $f$。

```cpp
f[1] = d[1];
for(int i = 2; i <= n; ++ i) f[1] = max(f[1], d[i] - i + 1);
f[n] = max(d[n], f[1] - 1);

if(f[n] < f[1]) ans = f[st = n];
else ans = f[st = 1];

for(int i = n - 1; i > 1; -- i) {
    f[i] = max(d[i], f[i + 1] - 1);
    if(f[i] <= ans) {
        ans = f[i], st = i;
    }
}
cout << ans << ' ' << st;
```

---

## 作者：58874__15157 (赞：3)

本题是一道典型的动态规划初步题，但是一打开算法标签，就发现这题做法特多：

**线段树、单调队列、动规、树状数组……**

作为一个蒟蒻，我毫不犹豫地选择了最简单的做法：动规

这题很水，题目把计算距离值的式子给你了。分析题目可知:

            
$$fa_i = \max(fa_{i-1},d_i)$$
            
$$fb_i = \max(fb_{i+1},d_i)$$

得出状态转移方程，本题解法自然水落石出了。


其实这题难度并不高，关键在于细节（~~正是这些细节把我坑了一个小时~~）。

**警钟敲烂：**

* 数组要开足够大，至少 $10^7$，不然就 RE，只能拿 62 分。

* 需要将 $d_i$ 转换成 $d_{i-n}$。

话不多说，上代码！

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9;//注意细节
long long n,f,d[10000010],a[10000010],b[10000010],m,x,y,z;
int main() {
	cin >> n >> f;
	if (f == 1){
		for (int i=1;i<=n;i++) cin >> d[i];
		for (int i=n+1;i<=2*n;i++) d[i]=d[i-n];//注意此处需要转换一下d[i]
	} else if (f == 2) {
		cin >> m >> x >> y >> z;
		for (int i = 1;i <= m;i++) cin >> d[i];
		for (int i = m + 1;i <= n;i++) d[i] = (x * d[i-2] + y * d[i-1]+z) % mod+1;//题目的距离公式
	}
   //虽说代码不短，但到这里为止都是输入                            
	a[0] = b[n+1] = -1e18;
	for (int i=1;i<=n;i++){
		d[i] -= i;
		a[i] = max(a[i-1],d[i]);
	}
	for (int i = n;i >= 1;i--) b[i] = max(b[i+1],d[i]);//本题需要两个解，因此定义两个动规数组
	long long ans = 1e18,pos = 0;
	for (int i=1;i<=n;i++){
		int p = max(b[i] + i,a[i-1] + i - n);
		if (p < ans) {
			ans = p;
			pos = i;
		}
	}
	cout << ans << ' ' << pos;
	return 0;
  //完结撒花~
}
```

---

## 作者：leiaxiwo (赞：2)

# 题解：P10087 [ROIR 2022 Day 1] 跳跃机器人
[传送门](https://www.luogu.com.cn/problem/P10087)
### 题意分析
这道题标签上写了很多做法，但是作为一道动态规划题，当然是用动态规划最简单，除了数据结构可以用 `pb_ds` 水过，其他题写非正解都会非常繁琐。

废话少说，这道题把式子都告诉你了

那么我们令 $a_i=d_i-i$。

枚举一个 $x$ 表示起始平台，对于每个 $x$，把 $[1,n]$ 划分成 $[1,x)$ 和 $[x,n]$。

显然，$a_i+x$ 对应了 $i\in[x,n]$ 的时候，从 $i$ 跳到 $(i+1)\bmod n$ 这个位置需要的灵敏度。

$a_i+x-n$ 对应了 $i\in[1,x)$ 的时候，从 $i$ 跳到 $i+1$ 这个位置需要的灵敏度。对于每个 $x$，这两部分取个最大值即可。

我们可以使用 $a$ 数组的前缀（prefix）、后缀（suffix）较大的那个求分划的两部分的最大值。

### 参考代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9;
int n,opt,id;
int ans=1e18;
int d[(int)1e7+5],prefix[(int)1e7+5],suffix[(int)1e7+5];
signed main(){
	prefix[0]=suffix[n+1]=-1e18;
	scanf("%lld%lld",&n,&opt);
	if (opt==1){
		for (int i=1;i<=n;i++){
			scanf("%lld",&d[i]);
		}
	}
	else{
		if(opt==2){
			int m,x,y,z;
		    scanf("%lld%lld%lld%lld",&m,&x,&y,&z);
		    for(int i=1;i<=m;i++){
			    scanf("%lld",&d[i]);
		    } 
		    for(int i=m+1;i<=n;i++){
			    d[i]=(x*d[i-2]+y*d[i-1]+z)%mod+1;
		    } 
	    }
	} 
	for(int i=1;i<=n;i++){
		d[i]=d[i]-i;
		prefix[i]=max(prefix[i-1],d[i]);
	}
	for(int i=n;i>=1;i--){
	    suffix[i]=max(suffix[i+1],d[i]);	
	} 
	for(int i=1;i<=n;i++){
		int p=max(suffix[i]+i,prefix[i-1]+i-n);
		if(p<ans){
			ans=p;
			id=i;
		} 
	}
	printf("%lld %lld",ans,id);
	return 0;
}
```

---

## 作者：Melo_qwq (赞：1)

考虑起点为 $p$ 的时候 $a$ 的值。

发现如果点 $p$ 到点 $i$ 要跳跃 $x$ 步，那么 $a$ 最小应该是 $d_i-x$。

进一步发现：

$$
x=\begin{cases}
i - p &i\ge p\\
n - (p - i) &i < p
\end{cases}
$$

那么我们钦定函数

$$
f_{i,p}=\begin{cases}
d_i - i +p &i\ge p\\
d_i - i + p - n & i < p
\end{cases}
$$

那么 $a=\displaystyle\min_{1\le p\le n}(\displaystyle\max_{1\le i \le n} f_{i,p})$。

我们分别预处理出对于任意的 $p$，大于他的函数 $f$ 和小于他的函数 $f$ 的最大值，之后 $\Theta(n)$ 枚举 $p$ 即可。

### code

```cpp
signed main () {
	read (n ,fl) ;
	if (fl & 1) 
		f (i ,1 ,n ,1) read (d[i]) ;
	else {
		int m ,x ,y ,z ; read (m ,x ,y ,z) ;
		f (i ,1 ,m ,1) read (d[i]) ;
		f (i ,m + 1 ,n ,1) 
			d[i] = ((x * d[i - 2] + y * d[i - 1] + z) % 1000000000ll) + 1ll ;
	} f (i ,1 ,n ,1) d[i] -= i ;

	ans[0] = - 1000000000000ll ;
	int maxn = - 1e15 ;
	f (i ,1 ,n ,1) 
		ans[i] = maxn + i - n ,maxn = std :: max (maxn ,d[i]) ;
	maxn = - 1e15 ;
	for (int i = n ; i ; i --) 
		maxn = std :: max (maxn ,d[i]) ,ans[i] = std :: max (ans[i] ,maxn + i) ;
	
	int res = 1e15 ,resi = 0 ;
	f (i ,1 ,n ,1) 
		if (ans[i] < res) 
			res = ans[i] ,resi = i ;
	std :: cout << res << ' ' << resi << '\n' ;
	return 0 ;
}
```

---

## 作者：潘德理2010 (赞：1)

假设我们从 $p$ 出发。

对于 $i\in [p,n]$，跳到第 $i$ 格时增加的灵活性为 $i-p$。所以初始灵活性至少要为 $d_i-i+p$ 才能跳出第 $i$ 格。

对于 $i\in [1,p-1]$，跳到第 $i$ 格时增加的灵活性为 $i+n-p$。所以初始灵活性至少要为 $d_i-i-n+p$ 才能跳出第 $i$ 格。

记起点为 $p$，跳出第 $i$ 个格子需要的最少初始灵活性为 $f(p,i)$。于是有：

$$
f(p,i) = \begin{cases} d_i-i-n+p & i\in [1,p-1] \\ d_i-i+p & i\in [p,n] \end{cases}
$$

我们需要能够跳出每个格子，才算完成任务。所以初始灵活性为跳出每个格子需要的最少初始灵活性的最大值。即 $\max(f(p,i))$。

为了最小化代价，我们需要找到一个最小的 $p\in [1,n]$ 使得 $\max(f(p,i))$ 最小。

我们可以分成两部分来求，即 $\max(f(p,i)(i\in [1,p-1]))$ 和 $\max(f(p,i)(i\in [p,n]))$。在 $p$ 点出发所需要的初始灵活性为二者的较大值。

记 $l_p=\max(f(p,i)(i\in [1,p-1]))$，$r_p=\max(f(p,i)(i\in [p,n]))$。发现 $l,r$ 都是可以预处理的。在 $O(n)$ 的时间内预处理 $l_1,l_2,...,l_n$ 以及 $r_1,r_2,...,r_n$。到这里，我们就有了从每个点出发的初始灵活性。找到最小的输出即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,d[10000010],l[10000010],r[10000010],ans=2000000000,pos,res;
int f,m,x,y,z;
int main(){
	scanf("%d%d",&n,&f);// 输入 
	if(f==2){
		scanf("%d%d%d%d",&m,&x,&y,&z);
		for(int i=1;i<=m;i++){
			scanf("%d",&d[i]);
		}
		for(int i=m+1;i<=n;i++){
			ll u=ll(x)*ll(d[i-2])+ll(y)*ll(d[i-1])+z;
			d[i]=u%1000000000+1;
		}
	}
	else{
		for(int i=1;i<=n;i++){
			scanf("%d",&d[i]);
		}
	}
	for(int i=n;i>=1;i--){// 预处理 
		if(i==n) r[i]=d[i]-i;
		else r[i]=max(r[i+1],d[i]-i);
	}
	for(int i=1;i<=n;i++){
		if(i==1) l[i]=d[i]-i;
		else l[i]=max(l[i-1],d[i]-i);
	}
	for(int i=1;i<=n;i++){
		res=max(l[i-1]+i-n,r[i]+i);// 取二者最大费用 
		if(res<ans) ans=res,pos=i;
	}
	printf("%d %d",ans,pos);
}
```


---

## 作者：CMZ369 (赞：0)

首先是环，先破环为链。

我们设 $f_i$ 为以第 $i$ 个点为终点的最小起始灵敏度，我们可以想到它的求法：

我们先求出如果要跳过 $d_j$ 至少需要多少灵敏度（不考虑前面的数），很容易想到是 $d_j-(n-(i-j)-1)$：

```
i=5,n=5 时，
j              1 2 3 4  5
d              3 7 4 2  5
需要多少灵敏度 1 6 2 -1 1
```

那么其实 $f_i$ 就是跳过 $i-n+1$ 到 $i$ 至少需要多少灵敏度的取最大值：

```
i=5,n=5 时，
j              1 2 3 4  5
d              3 7 4 2  5
需要多少灵敏度 1 6 2 -1 1
f              1 6 6 6  6
```

所以 $f_i=\max(d_j-(n-(i-j)-1))$，

提炼一下就是 $f_i=i+1-n+\max(d_j-j)$。

而 $\max(d_j-j)$ 可以用单调队列求。

于是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f;
int d[20000010],c[100010],x,y,z,p,ans=1e9+7;
int read()
{
	int x=0;
	char c=getchar();
	while('0'>c||c>'9')	c=getchar();
	while('0'<=c&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x;
}
deque<array<int,2> > q;
void Push(array<int,2> x)
{
	while(q.size()&&q.back()[0]<=x[0])	q.pop_back();
	q.push_back(x);
}
int Pop(int i)
{
	int k=i-n+1;
	while(q.size()&&q.front()[1]<k)	q.pop_front();
	return q.front()[0];
}
int main()
{
	n=read();
	f=read();
	if(f==1)
	{
		for(int i=1;i<=n;i++)	d[i]=read();
	}
	else
	{
		m=read();x=read();y=read();z=read();
		for(int i=1;i<=m;i++)	c[i]=read();
		for(int i=1;i<=n;i++)
		{
			if(i<=m)	d[i]=c[i];
			else		d[i]=(1LL*x*d[i-2]+1LL*y*d[i-1]+z)%1000000000+1;
		}
	}
	for(int i=1;i<=n;i++)	d[i+n]=d[i];
	for(int i=1;i<=n-1;i++)	Push({d[i]-i,i});
	for(int i=n;i<=2*n;i++)
	{
		Push({d[i]-i,i});
		int f=i+1-n+Pop(i);
		if(ans>f)
		{
			p=i-n+1;
			ans=f;
		}
	}
	printf("%d %d",ans,p);
	return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

看到题发现很乱，于是梳理一下。

你需要求一个 $i$，使得 $d_{i+j}\le a+j$。

求最小 $a$。

考虑移项 $a\ge d_{i+j}-j$。

注意到连续的项常数都是连续的，考虑默认 $i=1$。

这样只需要 $a\ge d_{j}-j+1$，维护**整体最大值**即可。

然后变成一般形式之后我们发现只会有两段，前面和后面（$i=1$ 除外）。通过计算可以求出这两段的常数（显然等差的性质仍然存在，只是需要加、减两个不同的数）。

所以维护**前后缀最大值**，枚举 $i$ 即可。

时间复杂度 $O(n)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define LL long long 
using namespace std;
constexpr int N=1e7+3;
constexpr LL p=1e9;
int n,_,d[N],pre[N],suf[N],ans=p,id=-1;
signed main(){
    ios::sync_with_stdio(0),cin.tie(nullptr);
    cin>>n>>_;
    if(_-1){
        LL m,x,y,z;
        cin>>m>>x>>y>>z;
        for(int i=1;i<=m;i++)
            cin>>d[i];
        for(int i=m+1;i<=n;i++)
            d[i]=((x*d[i-2])%p+(y*d[i-1])%p+z)%p+1;/*
        for(int i=1;i<=n;i++)
        	cerr<<d[i]<<" \n"[i==n];*/
    }
    else{
        for(int i=1;i<=n;i++)
            cin>>d[i];
    }/*
    for(int i=1;i<=n;i++)
        d[i]-=i;*/
    //i-th time a' is a+i-1
    //you need to make sure a'>=d,that means a+i-1>=d,that is a>=d-i+1
    pre[0]=suf[n+1]=-0x3f3f3f3f;
    for(int i=1;i<=n;i++)//pre[i] max(1~i)
        pre[i]=max(pre[i-1],d[i]-i+1);
    for(int i=n;i>=1;i--)//suf[i] max(i~n)
        suf[i]=max(suf[i+1],d[i]-i+1);//i-th num with -(i-1)
    /*for(int i=1;i<=n;i++)
    	cerr<<d[i]<<" \n"[i==n];
    for(int i=1;i<=n;i++)
    	cerr<<pre[i]<<" \n"[i==n];
    for(int i=1;i<=n;i++)
    	cerr<<suf[i]<<" \n"[i==n];*/
    for(int i=1,tmp;i<n;i++){
        tmp=max(suf[n-i+1]-(i-n),pre[n-i]-i);
        if(tmp<=ans)
        	ans=tmp,id=n-i+1;
		//suf:need 1~i,is (n-i+1~n),so -n+i	pre:is 1~n-i,need i+1~n,so +i
    }
    if(suf[1]<=ans)
    	ans=suf[1],id=1;
    cout<<ans<<' '<<id;
    return 0;
}
```

注释是我写代码的时候加的，可以忽略。

---

## 作者：Laisira (赞：0)

### 题面
有 $n$ 个点组成的环，你要确定一个灵敏度 $G$，从 $0<i\leq n$ 跳到 $(i\bmod m)+1$ 当且仅当 $d_i\leq G$，每跳一次 $G$ 变大一。

你要确定一个起点，最小化 $G$，使得从起点可以走一圈回到起点。

### 思路
对于一个点 $i$ 作为起点，我们可以知道后面 $i<j\leq n$ 限定了开始必须大于 $d_{j}-j+i$，同同理，前面的是 $d_{j}-n-j+i$。

然后最小值肯定是他们的最大值中最小的那个。

考虑 $O(1)$ 对每个起点求值。不难想到把贡献拆开，分别对从前往后和从后往前求一遍最大值，$i$ 的值就是前后拼起来。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
#define mod 1000000000 
#define Maxn 10000005 
using namespace std;
int pre[Maxn],suf[Maxn],a[Maxn];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n,f;
    cin>>n>>f;
    if(f == 1)
        for(int i=1;i<=n;i++)
            cin>>a[i];
    else {
        int m,x,y,z;
        cin>>m>>x>>y>>z;
        for(int i=1;i<=m;i++)
            cin>>a[i];
        for(int i=m+1;i<=n;i++)
            a[i]=(x*a[i-2]+y*a[i-1]+z)%mod+1;
    } pre[0]=suf[n+1]=-(mod<<1);
    for(int i=1;i<=n;i++)
        a[i]-=i,
        pre[i]=max(pre[i-1],a[i]);
    for(int i=n;i>0;i--)
        suf[i]=max(suf[i+1],a[i]);
    int ans=mod<<1,ip=0;
    for(int i=1;i<=n;i++)
        if(max(suf[i]+i,pre[i-1]+i-n)<ans)
            ans=max(suf[i]+i,pre[i-1]+i-n),ip=i;
    cout<<ans<<" "<<ip;
    return 0;
}
```

---


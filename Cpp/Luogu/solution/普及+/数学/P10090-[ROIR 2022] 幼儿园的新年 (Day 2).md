# [ROIR 2022] 幼儿园的新年 (Day 2)

## 题目背景

翻译简化自 [ROIR 2022 D2T1](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-regional-2022-day2.pdf)。

## 题目描述

给出三个整数 $n,a,b$，求有多少对 $(x,y)$ 满足 $0 \le x \le a$，$0 \le y \le b$，$x+y$ 不为 $0$ 且能被 $n$ 整除。

## 说明/提示

本题使用捆绑测试。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $t=1$ 且 $a,b\le1000$ |
| $2$ | $10$ | $t\le1000$ 且 $a=0$ |
| $3$ | $15$ | $t\le1000$ 且 $a,b<n\le1000$ |
| $4$ | $10$ | $t\le1000$ 且 $a,b\le1000$ |
| $5$ | $15$ | $t=1$ 且 $n\le1000$ |
| $6$ | $10$ | $t\le1000$ 且 $n\le1000$ |
| $7$ | $30$ | 无特殊性质 |

对于 $100\%$ 的数据，$1 \le t \le 10^5$，$4 \le n \le 10^9$，$0 \le a, b \le 10^9$。

## 样例 #1

### 输入

```
4
4 2 2
4 4 4
6 5 5
8 13 17```

### 输出

```
1
6
5
30```

# 题解

## 作者：cff_0102 (赞：19)

把 $x$ 的范围拆成 $0\le x<\lfloor\dfrac{a}{n}\rfloor\times n$ 和 $\lfloor\dfrac{a}{n}\rfloor\times n\le x\le a$ 两个范围，把 $y$ 的范围拆成 $0\le y<\lfloor\dfrac{b}{n}\rfloor\times n$ 和 $\lfloor\dfrac{b}{n}\rfloor\times n\le y\le b$ 两个范围。那么 $x,y$ 的取值范围就有四种可能：设 $(p,q)$ 表示 $x$ 属于它的第 $p$ 个范围，$y$ 属于它的第 $q$ 个范围，则这四个可能分别是 $(1,1),(2,1),(1,2),(2,2)$。

然后分情况讨论。

- $(1,1)$：将 $x,y$ 的范围分别拆成 $\lfloor\dfrac{a}{n}\rfloor$ 和 $\lfloor\dfrac{b}{n}\rfloor$ 个大小为 $n$ 的小范围，那么只考虑 $x,y$ 分别在哪个范围的话，一共有 $\lfloor\dfrac{a}{n}\rfloor\times\lfloor\dfrac{b}{n}\rfloor$ 种可能。而在一个大小为 $n$ 的小范围中，$x$ 随便取其中一个，为了让加和结果是 $n$ 的倍数，$y$ 都有且只有一个数与其对应。因此，这样在每个小范围中，实际上有 $n$ 种 $x,y$ 的取值可能。乘上前面范围的可能，此时的可能数为 $\lfloor\dfrac{a}{n}\rfloor\times\lfloor\dfrac{b}{n}\rfloor\times n$ 种。
- $(2,1)$：将 $y$ 的范围拆成 $\lfloor\dfrac{b}{n}\rfloor$ 个大小为 $n$ 的小范围，那么只考虑 $y$ 在哪个范围的话，一共有 $\lfloor\dfrac{b}{n}\rfloor$ 种可能。而在一个大小为 $a\bmod n$ 的小范围中，$x$ 随便取其中一个，为了让加和结果是 $n$ 的倍数，$y$ 都有且只有一个数与其对应。因此，这样在每个小范围中，实际上有 $a\bmod n$ 种 $x,y$ 的取值可能。乘上前面范围的可能，此时的可能数为 $\lfloor\dfrac{b}{n}\rfloor\times(a\bmod n)$ 种。
- $(1,2)$：将 $x$ 的范围拆成 $\lfloor\dfrac{a}{n}\rfloor$ 个大小为 $n$ 的小范围，那么只考虑 $x$ 在哪个范围的话，一共有 $\lfloor\dfrac{a}{n}\rfloor$ 种可能。而在一个大小为 $b\bmod n$ 的小范围中，$y$ 随便取其中一个，为了让加和结果是 $n$ 的倍数，$x$ 都有且只有一个数与其对应。因此，这样在每个小范围中，实际上有 $b\bmod n$ 种 $x,y$ 的取值可能。乘上前面范围的可能，此时的可能数为 $\lfloor\dfrac{a}{n}\rfloor\times(b\bmod n)$ 种。
- $(2,2)$：在一个大小为 $a\bmod n$ 的小范围中，$x$ 随便取一个数，为了让加和结果是 $n$ 的倍数，$y$ 必须为 $n-x$。此时必须要求 $n-x$ 在 $y$ 的范围内，即 $0\le n-x\le b\bmod n$。那么，答案应该是满足 $0\le n-x\le b\bmod n$ 且 $0\le x\le a\bmod n$ 的 $(x,y)$ 个数。化简一下前者，得到 $n-b\bmod n\le x\le n$。因为 $a\bmod n<n,n-b\bmod n>0$，所以两式合并得到 $n-b\bmod n\le x\le a\bmod n$。此时答案就是满足这个条件的 $x$ 的数量。因此，有 $\max(0,a\bmod n-(n-b\bmod n)+1)=\max(0,a\bmod n+b\bmod n-n+1)$ 种 $x,y$ 的取值可能。

所以答案就是上面四种情况的答案之和，即 $\lfloor\dfrac{a}{n}\rfloor\times\lfloor\dfrac{b}{n}\rfloor\times n+\lfloor\dfrac{b}{n}\rfloor\times(a\bmod n)+\lfloor\dfrac{a}{n}\rfloor\times(b\bmod n)+\max(0,a\bmod n+b\bmod n-n+1)$ 种可能的情况。

```python
t=int(input())
for _ in range(t) :
    n,a,b=map(int,input().split())
    print((a//n)*(b//n)*n + (a%n+1)*(b//n) + (b%n+1)*(a//n) + max(0,a%n+b%n-n+1))
```

---

## 作者：Ether13 (赞：6)

这道题一眼推式子吧。

因为 $a,b$ 顺序没有影响，令 $a>b$。

问题可以写成 $\left(\sum_{x=0}^{a}\sum_{y=0}^{b}[n|(x+y)]\right)-1$。

枚举 $x+y$，上式 $+1=\sum_{i=0}^{a+b}\sum_{x=0}^{a}\sum_{y=0}^{b}[n|i][x+y=i]$。

去掉 $y$，原式 $+1=\sum_{i=0}^{a+b}\sum_{x=0}^{a}[n|i][i-x\ge 0][i-x\le b]$。

整理得：
$$
\begin{aligned}
&\sum_{i=0}^{a+b}\sum_{x=0}^{a}[n|i][i\ge x][x\ge i-b]\\
=&\sum_{i=0}^{a+b}[n|i]\sum_{x=(\max(0,i-b))}^{\min(i,a)}1\\
=&\sum_{i=0}^{\lfloor\frac{a+b}{n}\rfloor}\sum_{x=(\max(0,i\cdot n-b))}^{\min(i\cdot n,a)}1
\end{aligned}
$$
差分一下：
$$
=\sum_{i=0}^{\lfloor\frac{a+b}{n}\rfloor}(\min(i\cdot n,a)-\max(0,i\cdot n-b)+1)
$$
令 $k=\lfloor\frac{a+b}{n}\rfloor$，

此时把它拆分得 $\sum_{i=0}^{k}(\min(in,a))-\sum_{i=0}^{k}\max(0,in-b)+k+1$。

分类讨论，有：
$$
ans=\sum_{i=0}^{k}in[in\le a]+\sum_{i=0}^{k}a[in> a]-\sum_{i=0}^{k}(in-b)[b<in]+k
$$

简单思考可知，$[in\le a]$ 等价于 $[i\le \lfloor\frac{a}{n}\rfloor],[in> a]$ 等价于 $[i\ge \lfloor\frac{a}{n}\rfloor+1]$，$[b<in]$ 等价于 $[\lfloor\frac{b}{n}\rfloor+1\le i]$。

令 $\lfloor\frac{a+b}{n}\rfloor=x,\lfloor\frac{a}{n}\rfloor=y,\lfloor\frac{b}{n}\rfloor=z$。

$$
ans=\frac{n\times(y+1)\times y}{2}+(x-y)\times a-\frac{n\times(x+z+1)\times (x-z)}{2}+b\times(x-z)+x
$$

复杂度 $O(t)$。
记得开 ```long long```。

核心代码如下:
```cpp
int n=read(),a=read(),b=read(),ans=0;
if(a<b) swap(a,b);
int k=(a+b)/n,y=a/n,z=b/n;
ans=n*(y*(y+1)/2)+(k-y)*a-n*(z+1+k)*(k-z)/2+b*(k-z)+k;
printf("%lld\n",ans);
```
update：发现一个小错，已更正。\
2025-1-18 update: 应 [LionBlaze](https://www.luogu.com.cn/user/911054) 要求，添加了句号。

---

## 作者：IcyFoxer_XZY (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10090)

~~首先我不清楚为什么这题起这个标题。~~

### 分析

这是一个思维复杂的题目，我们首先考虑暴力方法。

我们先尝试对于每个不大于 $a+b$ 的 $n$ 的倍数来分析。

这题令 $b\le a$ 会好做一点。

对于一个数 $x$，我们可以分成几种情况分析：

- $x\le a,b$，那么就有 $x+0=x$，$(x-1)+1=x$，一直到 $0+x=x$ 都成立，共 $x+1$ 种情况。
- $b<x\le a$，那么就有 $x+0=x$ 一直到 $(x-b)+b=x$ 都成立，共 $x-(x-b)+1=b+1$ 种情况。
- $a,b<x$，那么就有 $a+(x-a)$ 一直到 $(x-b)+b=x$ 都成立，共 $a-(x-b)+1=a+b-x+1$ 种情况。

通过这种解法，我们对每个合法的 $n$ 的倍数都进行了讨论，可以得到正确答案。最终这种方法超时，获得 $50$ 分。

然后我们开始考虑优化。

经过思考，我们可以尝试分别直接算出上述 $3$ 种情况的答案，于是开始找规律。

### 优化

- 对于第一种情况，我们发现 $x$ 增大多少，$x+1$ 就增大多少，那么我们令 $t_1=b\div n$，因此 $n\times 1$ 到 $n\times t_1$ 的每个 $n$ 的倍数都满足这一情况，求和得出这种情况的答案（未化简）为 $(n+1)\times t_1+n\times t_1\times(t_1-1)\div 2$。

- 对于第二种情况，我们发现结果与 $x$ 的大小无关，答案是 $b+1$，那么我们令 $t_2=a\div n$，得出答案为 $(b+1)\times(t_2-t_1)$。

- 对于第三种情况，我们也是对每个答案求和计算。令 $t_3=(a+b)\div n$，那么在 $n\times t_2$ 到 $n\times t_3$ 之间的每一个 $n$ 的倍数都属于这种情况，那么最终计算出来的答案（未化简）为 $(t_3-t_2+1)\times(a+b+1)-(t_3-t_2+1)\times(t_2+t_3)\times n\div 2$。

那么这题的讨论就结束了。

#### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
signed main(){
	cin>>t;
	while(t--){
		int n,a,b;
		scanf("%lld%lld%lld",&n,&a,&b);
		int t1,t2,t3,ans=0;
		if(a<b)swap(a,b);//使得a>=b 
		t1=b/n;
		ans+=(n+1)*t1+n*t1*(t1-1)/2;//第一种 
		t2=a/n;
		ans+=(b+1)*(t2-t1);//第二种 
		t3=(a+b)/n;t2++;
		ans+=(t3-t2+1)*(a+b+1)-(t3-t2+1)*(t2+t3)*n/2;//第三种 
		printf("%lld\n",ans);
	}
	return 0;
}
```
Bye！

---

## 作者：ZaleClover (赞：1)

# P10090 [ROIR 2022] 幼儿园的新年 (Day 2) 题解

[更好的阅读体验？](https://www.cnblogs.com/ZaleClover/p/18940536)

设 $kn(k\in\mathbb{N}_+)$ 为 $n$ 的倍数。

首先，我们确定 $kn$ 的取值范围，显然 $kn\le a+b$。

此时 $kn$ 的枚举范围已经确定，然后该考虑什么样的 $(x,y)$ 的可以对答案产生贡献。不难发现 $(x,y)$ 的取法受到 $a,b$ 与 $n$ 之间大小关系的影响，接下来我们便具体探讨其中的关系。

> 以下若无特殊说明，默认 $a\le b,0\le x\le a,0\le y\le b$。
>
先从简单的入手，只考虑单个 $kn$ 对答案的贡献，我们可分为以下几种情况：
1. $kn\le a,b$\
   由于 $kn\le a,b$，则必然有 $x$ 或 $y$ 满足 $x=kn$ 或 $y=kn$，便有以下几种可能：
   $$
   \begin{aligned}
    0+y&=kn\\
    1+(y-1)&=kn\\
    &\vdots\\
    x+0&=kn
   \end{aligned}
   $$
   那么此时便对答案有 $(x-0)+1=(y-0)+1=kn+1$ 的贡献。
2. $a<kn\le b$\
   由于此时 $a<kn$，所以无论 $x$ 怎么取，仍然不会超出 $kn$ 的范围，那么 $x$ 的范围便固定在 $[0,a]$ 中，那么 $y$ 的范围也随之固定，也就有以下几种可能：
   $$
   \begin{aligned}
   0+y&=kn\\
   1+(y-1)&=kn\\
   &\vdots\\
   a+(y-a)&=kn
   \end{aligned}
   $$
   那么此时对答案有 $(a-0)+1=a+1$ 的贡献。
3. $a,b<kn$\
   同理，请自己尝试像上面两种情况推导后，得出以下几种可能：
   $$
   \begin{aligned}
   (kn-b)+b&=kn\\
   (kn-b+1)+(b-1)&=kn\\
   &\vdots\\
   a+(kn-a)&=kn
   \end{aligned}
   $$
   那么此时对答案有 $a-(kn-b)+1=a+b-kn+1$ 的贡献。

此时我们对单个 $kn$ 考虑完毕，再考虑多个 $kn$ 对答案的贡献。

现在的变量又多了一个 $k$，由于 $k$ 的变化导致 $kn$ 与 $a,b$ 的大小关系不定，所以我们要确定好在上面三种情况中 $k$ 各自的取值范围。

1. $kn\le a,b$\
   令 $m_1=\left\lfloor\frac{a}{n}\right\rfloor$，则 $k\in[1,m_1]$ 总的贡献为：
   $$
   \sum_{k=1}^{m_1}\left(i\times n+1\right)=\sum_{k=1}^{m_1}(i\times n)+m_1
   $$
   利用求和公式即可化简为：
   $$
   \frac{n(m_1+1)\times m_1}{2}+m_1
   $$
2. $a<kn\le b$\
   令 $m_2=\left\lfloor\frac{b}{n}\right\rfloor$，则 $k\in(m_1,m_2]$。

   不难发现，此条件下 $k$ 的变化对最终贡献没有影响，所以贡献为：
   $$
   \sum_{i=m_1+1}^{m_2}a+1=(m_2-m_1)\times(a+1)
   $$
3. $a,b<kn$\
   令 $m_3=\left\lfloor\frac{a+b}{n}\right\rfloor$，则 $k\in(m_2,m_3]$，贡献为：
   $$
   \begin{aligned}
   &\sum_{i=m_2+1}^{m_3}(a+b-i\times n+1)\\
   =&(m_3-m_2)\times(a+b+1)-\sum_{i=m_2+1}^{m_3}(i\times n)\\
   =&(m_3-m_2)\times(a+b+1)-\left(\sum_{i=1}^{m_3}(i\times n)-\sum_{i=1}^{m_2}(i\times n)\right)\\
   =&(m_3-m_2)\times(a+b+1)-\left(\frac{n(m_2+1)\times m_2}{2}-\frac{n(m_3+1)\times m_3}{2}\right)
   \end{aligned}
   $$

这样，我们就得出了最终的公式，用代码实现即可，时间复杂度 $\mathcal{O}(t)$
## 代码
### $\text{Code}$
```cpp
#include <bits/stdc++.h>

using namespace std;

int t, n, a, b, m1, m2, m3;
long long ans; // 别忘了 long long

template <typename type>
void read(type &res) {
    type x = 0, f = 1;
    char c = getchar();
    for (; c < 48 || c > 57; c = getchar()) if (c == '-') f = ~f + 1;
    for (; c > 47 && c < 58; c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
    res = f * x;
}

int main() {
	read(t);
	while (t--) {
		ans = 0;
		read(n), read(a), read(b);
      // 把上面的公式翻译成代码就行了
		if (a > b) swap(a, b);
		m1 = a / n;
		m2 = b / n;
		m3 = (a + b) / n;
      // 下面也要开 long long
		ans += ((1ll * n * (m1 + 1) * m1) >> 1) + m1;
		ans += 1ll * (m2 - m1) * (a + 1);
		ans += 1ll * (m3 - m2) * (a + b + 1) - (((1ll * n * (m3 + 1) * m3) >> 1) - ((1ll * n * (m2 + 1) * m2) >> 1));
		printf("%lld\n", ans);
	}
    return 0;
}
```

---

## 作者：xzhif (赞：1)

这道题暴力很容易想到就是：枚举 $n$ 的倍数 $m$，将每个 $m$ 的方案数加起来。

具体来说就是，先保证 $a$ 比 $b$ 小，然后分情况讨论 $m$。当 $m$ 小于等于 $a$ 时，很明显 $x$ 可以取满 $0$ 到 $a$ 整个范围，方案数就是 $m+1$。当 $m$ 大于 $a$ 时，如果此时 $m$ 大于 $a$ 与 $b$ 的和，则 $x,y$ 一定够不到 $m$，直接退出循环；否则方案数就是 $\min(a+b-m+1,a+1)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll t,n,a,b,m,ans;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>a>>b,ans=m=0;
		if(a>b)swap(a,b);
		while(1){
			m+=n;
			if(m<=a){
				ans+=m+1;
			}else{
				ll p=m-a;
				if(p>b)break;
				ans+=min(b-p,a)+1;
			}
		}
		cout<<ans<<'\n';
	}
} 
```

考虑分三种情况进行快速计算：

对于 $m$ 小于等于 $a$ 的 $m$ 共有 $\lfloor\frac{a}{n}\rfloor$ 个，每个的方案数是 $m+1$。可以直接用等差数列求和计算。

对于 $m$ 大于 $a$ 且小于等于 $b$ 的 $m$ 共有 $\lfloor\frac{b}{n}\rfloor-\lfloor\frac{a}{n}\rfloor$ 个，每个的方案数是 $a+1$，直接乘即可。

对于 $m$ 大于 $b$ 小于等于 $a+b$ 的 $m$ 共有 $\lfloor\frac{a+b}{n}\rfloor-\lfloor\frac{b}{n}\rfloor$ 个，每个的方案数是 $a+b-m+1$，同样也可以用等差数列求和计算。

最终时间复杂度能达到 $O(t)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll t,n,a,b,m,ans;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>a>>b;
		if(a>b)swap(a,b);
		ll r=a/n;
		ans=(n+(m=r*n))*r/2+r;//第一种情况 
		r=b/n-r;
		ans+=r*(a+1),m+=r*n;//第二种情况 
		r=(a+b)/n-(m/n);
		ans+=r*(b+a+1)-((m+n)+(a+b)/n*n)*r/2;//第三种情况 
		cout<<ans<<'\n';
	}
} 
```


---

## 作者：LionBlaze (赞：0)

首先我们忽略 $x+y \neq 0$ 的条件，因为在任何情况下这种情况都有且只有一种，所以我们只需要把最终答案减去 $1$ 即可。

首先考虑确定了 $x$，有多少个 $y$。

显然有 $x \le x+y \le x+b$，而 $x+y \equiv 0 \pmod n$，所以一共有 $\left\lfloor\dfrac{x+b}{n}\right\rfloor - \left\lceil\dfrac{x}{n}\right\rceil + 1$ 种。

我们成功把时间复杂度优化为了 $\Theta(\sum a)$。考虑优化。

我们发现一件事情：

$$\begin{aligned}
&\left\lfloor\dfrac{x+b}{n}\right\rfloor - \left\lceil\dfrac{x}{n}\right\rceil + 1\\
=&\left\lfloor\dfrac{x}{n}+\left\lfloor\dfrac{b}{n}\right\rfloor+\dfrac{b \bmod n}{n}\right\rfloor - \left\lfloor\dfrac{x+n-1}{n}\right\rfloor + 1\\
=&\left\lfloor\dfrac{x}{n}+\dfrac{b \bmod n}{n}\right\rfloor - \left\lfloor\dfrac{x-1}{n}\right\rfloor + \left\lfloor\dfrac{b}{n}\right\rfloor\\
=&\left(\left\lfloor\dfrac{x+b \bmod n}{n}\right\rfloor - \left\lfloor\dfrac{x-1}{n}\right\rfloor\right) + \left\lfloor\dfrac{b}{n}\right\rfloor
\end{aligned}$$

显然，最右边的 $\left\lfloor \dfrac{b}{n} \right\rfloor$ 是一个常数，而 $b \bmod n$ 也是一个常数。

**注意：我在验证式子有没有推错的时候用了 `(x-1)/n` 来计算 $\bm{\left\lfloor\dfrac{x-1}{n}\right\rfloor}$，结果寄了（可以想想为什么）。**

我们采用换元法，令 $z = x-1$，则原式转化为 $\left(\left\lfloor\dfrac{z+(1+b \bmod n)}{n}\right\rfloor - \left\lfloor\dfrac{z}{n}\right\rfloor\right) + \left\lfloor\dfrac{b}{n}\right\rfloor$，$z$ 满足 $-1 \le z < a$。

现在问题转化为，有多少个 $-1 \le z < a$，满足 $z \bmod n \ge n - b \bmod n - 1$。因为如果满足，则原式左边的括号中是 $1$，否则是 $0$。

为了方便，令 $m = n - b \bmod n - 1$。

若 $0 \le x < n$，则有 $n - m$ 个满足条件的 $z$。

显然，一共有 $\left\lfloor\dfrac{a}{n}\right\rfloor$ 组完整的 $0 \le z \bmod n < n$。

在剩下的 $z$ 中，都是 $n\left\lfloor\dfrac{a}{n}\right\rfloor \le z < a$ 的，也就是 $0 \le z \bmod n < a \bmod n$。除了一个特殊情况就是 $z=-1$，对应 $x=0$，特判即可。

所以，如果 $a \bmod n \le m$，那么没有满足条件的。否则，有 $a \bmod n - m$ 个。

然后我们就可以 $\Theta(1)$ 回答单次询问了。

容易理解的代码：

```cpp
#include <cstdio>

using namespace std;

int main()
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		long long n, a, b;
		scanf("%lld%lld%lld", &n, &a, &b);
		long long m = n - b % n - 1;
		long long sum =
			a * (b / n) + // 每一个 x 都有 b / n，除了 x=0，特判
			(a / n) * (n - m) +
			(a % n <= m ? 0 : a % n - m) +
			b / n // x = 0 (z = -1), (b / n) - (0 / n) + 1 - 1
			;
		printf("%lld\n", sum);
	}
	return 0;
}
```

> 我用 Github Pages 建了个网站，域名为 <https://cloudspots.github.io/>，还没想好要在网站里放什么，大家有什么意见吗？
>
> 这无关内容不算大量吧。

---

## 作者：无名之雾 (赞：0)

# [ROIR 2022 Day 2] 幼儿园的新年 题解
 
~~我又来了水题解了！~~

## 思路

第一眼看到这题，想到的还是暴力。直接两重循环枚举 $a$ 和 $b$，时间复杂度 $O(t \times a \times b)$。

## 代码

```cpp
#include <iostream>
using namespace std;
int main() {
    int t;
    cin >> t;
    while(t--) {
        int n, a, b;
        cin >> n >> a >> b;
        int count = 0;
        for(int x = 0; x <= a; x++) {
            for(int y = 0; y <= b; y++) {
                if((x + y) != 0 && (x + y) % n == 0) {
                    count++;
                }
            }
        }
        
        cout << count << endl;
    }

    return 0;
}
```

而后我们再回来冷静的思考这题，不难发现这题应该是一个推结论题。
我们来观察一下样例：
>输入：$4$ $4$ $2$ $2$ $4$ $4$ $4$ $6$ $5$ $5$ $8$ $13$ $17$

>输出：$1$ $6$ $5$ $30$

对于第一组数据：$4$，$2$，$2$。
我们发现 $a+b$ 所能构成的最大的 $n$ 的倍数是 $4$。

而 $4$ 可以被 $(1,3)$，$(3,1)$，$(2,2)$，$(0,4)$，$(4,0)$ 共 $5$ 组数构成。
我们再继续向后类举，不难发现，一个 $n$ 可以被 $n+1$ 组 $x$ 和 $y$  构成。
而我们可以使用的数就是 $a$ 和 $b$ 的范围内的数。

于是我愉快的将代码打了出来。最劣时间复杂度到了 $O(t \times n)$。

## 代码

```cpp
#include <iostream>
using namespace std;
#define int long long
signed main(){
    int t;
    cin>>t;
    for(register int j=1;j<=t;j++){
        int n,a,b;
        cin>>n>>a>>b;
        int q=(a+b)/n;
        int count=0;
        for(register int i=1;i<=q;i++){
            int c=n*i;
            count+=(c+1);
            if(a<c)count=count-(c-a);
            if(b<c)count=count-(c-b);
        }
        cout<<count<<"\n";
    }
    return 0;
}
```
看来这题只能用 $O(t)$ 的时间复杂度通过了。那么我们每一次操作的时间复杂度就应为 $O(1)$。我突然想到了小奥做题时的一种思想：分段讨论。

1. 将 $x$ 的取值分成 $ 0\le x \le \lfloor \frac{a}{n} \rfloor$ 和 $\lfloor \frac{a}{n} \rfloor \le x \le a$ 两个部分。

1. 将 $y$ 的取值分成 $ 0\le y \le \lfloor \frac{b}{n} \rfloor$ 和 $\lfloor \frac{b}{n} \rfloor \le y \le b$ 两个部分。

而我们将 $x$ 和 $y$ 的情况分别组合。可以得到四种取法。而后我们只需分类讨论出每种情况的答案数并相加了。

- 取 $x$ 的第一种情况和 $y$ 的第一种情况。共：$\lfloor \frac{a}{n} \rfloor \times \lfloor \frac{b}{n} \rfloor \times n$ 种情况。

- 取 $x$ 的第二种情况和 $y$ 的第二种情况。共：$\max(a\bmod n+b \bmod n +1 -n,0)$ 种情况。

- 取 $x$ 的第一种情况和 $y$ 的第二种情况。共：$(a\bmod n) \times \lfloor \frac{b}{n} \rfloor$ 种情况。

- 取 $x$ 的第二种情况和 $y$ 的第一种情况。共：$(b\bmod n) \times \lfloor \frac{a}{n} \rfloor$ 种情况。

最后将所有情况相加即可。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int t;
    cin>>t;
    while(t--){
        int n,a,b;
        cin>>n>>a>>b;
        int count=(a/n)*(b/n)*n+(a%n+1)*(b/n)+(b%n+1)*(a/n)+max(0ll,a%n+b%n-n+1);
        cout<<count<<"\n";
    }
    return 0;
}
```

---


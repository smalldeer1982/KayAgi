# [ROIR 2022] 分数排序 (Day 2)

## 题目背景

翻译自 [ROIR 2022 D2T2](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-regional-2022-day2.pdf)。

## 题目描述

有两个由 $n$ 个不同整数组成的序列 $A = [a_1, a_2, \dots , a_n]$ 和 $B = [b_1, b_2, \dots , b_n]$。将它们组合成 $n^2$ 个分数，形式为 $\frac{a_i}{b_j}$，并将每个分数约分后按递增顺序排序。

给定一个数字 $q$ 和 $q$ 个整数 $c_1, c_2, \dots , c_q$。对于每个 $c_i$，请输出上面所说的 $n^2$ 个分数中第 $c_i$ 小的分数。

## 说明/提示

在样例中，初始的分数列表如下：

$$
\left[
\frac{3}{2},
\frac{3}{3},
\frac{3}{4},
\frac{3}{5},
\frac{4}{2},
\frac{4}{3},
\frac{4}{4},
\frac{4}{5},
\frac{1}{2},
\frac{1}{3},
\frac{1}{4},
\frac{1}{5},
\frac{2}{2},
\frac{2}{3},
\frac{2}{4},
\frac{2}{5}
\right],
$$

经过约分后，得到：

$$
\left[
\frac{3}{2},
\frac{1}{1},
\frac{3}{4},
\frac{3}{5},
\frac{2}{1},
\frac{4}{3},
\frac{1}{1},
\frac{4}{5},
\frac{1}{2},
\frac{1}{3},
\frac{1}{4},
\frac{1}{5},
\frac{1}{1},
\frac{2}{3},
\frac{1}{2},
\frac{2}{5}
\right],
$$

最后按递增顺序排序，得到：

$$
\left[
\frac{1}{5},
\frac{1}{4},
\frac{1}{3},
\frac{2}{5},
\frac{1}{2},
\frac{1}{2},
\frac{3}{5},
\frac{2}{3},
\frac{3}{4},
\frac{4}{5},
\frac{1}{1},
\frac{1}{1},
\frac{1}{1},
\frac{4}{3},
\frac{3}{2},
\frac{2}{1}
\right].
$$

本题使用捆绑测试。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $14$ | $n\le50$ |
| $2$ | $13$ | $n\le500$ |
| $3$ | $15$ | $q,c_i\le100$ |
| $4$ | $21$ | $c_i\le10^5$ |
| $5$ | $37$ |  |

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$1 \leq q \leq 10^5$ 且 $q \leq n^2,n\times q\le10^5$（所以实际上 $q\le1000\sqrt[3]{10}\approx2154$），$1 \leq a_i,b_i \leq 10^6$，$1 \leq c_i \leq n^2$。

## 样例 #1

### 输入

```
4 8
3 4 1 2
2 3 4 5
1 16 2 4 5 6 10 15```

### 输出

```
1 5
2 1
1 4
2 5
1 2
1 2
4 5
3 2```

# 题解

## 作者：Moya_Rao (赞：10)

# 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P10091)
（翻译自 [ROIR 2022 D2T2](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-regional-2022-day2.pdf)）

给定 $n$ 个分子和 $n$ 个分母，将它们组合成 $n^2$ 个分数，将第 $c_i$ 小的分数约分后输出（参考代码里用 $q$ 表示各个 $c_i$ ，用 $Q$ 表示 $q$ 的个数）。

输出格式：若要输出 $\dfrac{a}{b}$，请输出 `a b` 。

# 思路
先将 $a$ 数组和 $b$ 数组都从小到大排个序。

排序后不难得出，$\dfrac{a_j}{b_i}<\dfrac{a_j+1}{b_i}$，$\dfrac{a_j}{b_i}>\dfrac{a_j}{b_i+1}$。可据此进行 `check`。当然精度得够高，在这里我们使用 `long double` 来操作。

那么二分出来的值如何匹配上正确的分母和分子呢？我们可以挨个儿去试，看看每个 $b_i$ 可不可以对应上其中一个 $a_j$。我们可以使用 `round` 函数进行四舍五入（具体用法[看这里](https://www.bilibili.com/video/BV1iL4y1j7Q7/)，此题解默认你们会用）。

# 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5 , AB = 1e6+5;
long long n,Q,a[N],b[N],q,p,g;
long double l,r;
bool v[AB];
bool check(long double k){
    long long j=0,sum=0;
	for(int i=1;i<=n;i++){
		while((long double)a[j+1]<(long double)k*b[i]&&j<n)j++;
		sum+=j;
	}
	return sum>=q;
}
long long gcd(long long x,long long y)
{
	if(x<y)swap(x,y);
	if(y==1)return y;
	if(x%y==0)return y;
	else return gcd(y,x%y);
}
int main(){
    scanf("%lld%lld",&n,&Q);
    for(int i=1;i<=n;i++){scanf("%lld",&a[i]);v[a[i]]=1;}
    for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
    sort(a+1,a+n+1);
	sort(b+1,b+n+1);
    while(Q--){
        scanf("%lld",&q);
        l=(long double)a[1]/b[n];r=(long double)a[n]/b[1];
        while(r-l>=1e-13){
            long double mid=(l+r)/2;
            if(check(mid))r=mid;
            else l=mid;
        }
        for(int i=1;i<=n;i++){
            p=round(l*b[i]);
            if(p<=1e6&&v[p]&&abs(p-l*b[i])<1e-7){
                g=gcd(p,b[i]);
                printf("%lld %lld\n",p/g,b[i]/g);
				break;
            }
        }
    }
    return 0;
}
```
注：此代码已 [AC](https://www.luogu.com.cn/record/164358444)，可放心看，但请不要**直接提交**我的代码。

---

## 作者：chyuya (赞：8)

###  P10091  
 [ 题面 ](https://www.luogu.com.cn/problem/P10091)
 
 读完题，很容易想到无法 $ n^2 $ 求序列后排序，于是乎我们将 $ a $ 数组和 $ b $ 数组分别升序排序，然后二分第 $ c_i $ 个数与第 $ c_{i+1}$ 个数的值。
 
 即 $ \frac{a_j}{b_i} < mid< \frac{a_j+1}{b_i} $，由于 $ a $ 数组和 $ b $ 数组为升序，所以不需要从头枚举 $ j $，因为 $ \frac{a_j}{b_i} > \frac{a_j}{b_i+1} $，所以对于以 $ b_i+1 $ 为分母的数前 $ j $ 个要比二分的值小，复杂度为 $ O(n) $。
 
 然后还有一个问题，那就是二分出来的值如何对应第 $ c_i $ 个数的值。因为精度够高（使用 long double），所以可以近似认为二分出的 $ l $ 值就是第 $ c_i $ 个数的值，这里可以使用 round 函数进行四舍五入。
 
##  Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q;
int a[100010],b[100010];
long long check(long double x){
	int j=0;
	long long sum=0;
	for(int i=1;i<=n;i++){
		while((long double)a[j+1]<(long double)x*b[i]&&j<n) j++;
		sum+=j;
	}
	return sum;
}
bool p[1000010];
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),p[a[i]]=1;
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]);
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	while(q--){
		long long c;
		scanf("%lld",&c);
		long double l=(long double)a[1]/b[n],r=(long double)a[n]/b[1];
		while(r-l>=1e-13){//精度要够高同时不能太高
			long double mid=(l+r)/2;
			if(check(mid)>=c) r=mid;
			else l=mid;
		}
		for(int i=1;i<=n;i++){
			int fz=round(l*b[i]);//尝试l*b[i]做分子
			if(fz<=1e6&&p[fz]&&abs(fz-l*b[i])<1e-7){
				int g=__gcd(fz,b[i]);
				printf("%d %d\n",fz/g,b[i]/g);
				break;
			}
		}
	}
	return 0;
}
```
觉得写得可以的就点个赞再走吧。

---

## 作者：Hootime (赞：5)

一道二分~~水~~好题 By [yuruilin2026](https://www.luogu.com.cn/user/1294410)

## 题意
两个整数序列 $a,b$ 两两组成形如 $\frac{a_i}{b_j}$ 的 $n^2$ 个分数并升序排序，求第 $c_i$ 小的分数。

## 思路
由于 $n\le10^5$，把 $n^2$ 个分数全部列出会 TLE/MLE 27pts。

我们将 $a,b$ 升序排序，这时可以发现 $\frac{a_{i-1}}{b_j}\le\frac{a_i}{b_j},\frac{a_{i}}{b_j+1}\le\frac{a_i}{b_j}$。于是考虑二分 $c_i$。

### 求 prefix 函数
因为 $\frac{a_{i-1}}{b_j}\le\frac{a_i}{b_j}$，所以我们可以枚举 $a_1 \sim a_n$，运用双指针查找在以 $b_i$ 作为分母的情况下小于 $k$ 的分数个数。

又因为 $\frac{a_{i}}{b_j+1}\le\frac{a_i}{b_j}$，所以枚举 $a_i(i \ge 2)$ 时可以直接沿用枚举 $a_{i-1}$ 时的 $j$，不然会 [TLE 14pts](https://www.luogu.com.cn/record/180341858)。

## 代码
### 注释
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long // 不开 long long 见祖宗 
int a[100005], b[100005], n, q;
bool v[1000006];
long double minn, maxn;
int prefix(long double n); // n 前面有多少个
inline int _gcd(int a, int b){return b?_gcd(b, a%b):a;} // 欧几里得法 
signed main(){
    scanf("%lld %lld", &n, &q);
    for(int i = 1; i <= n; ++i) scanf("%lld", &a[i]), v[a[i]]++;
    for(int i = 1; i <= n; ++i) scanf("%lld", &b[i]);
    sort(a+1, a+n+1);
    sort(b+1, b+n+1);
    minn = (long double)a[1] / b[n] - 1e-8, maxn = (long double)a[n] / b[1] + 1e-8;
	// 尽量缩小边界 
    while(q--){
        int m;
        scanf("%lld", &m);
        long double l = minn, r = maxn;
        while(r - l > 1e-12){ // 边界大于 10^-12 会WA 
            long double mid = (l+r)/2;
            if(prefix(mid) >= m) r = mid;
            else l = mid;
        }
        for(int i = 1; i <= n; ++i){
            int son = round(l * b[i]); // 拼凑，分数本身乘以分母等于分子 
            if(son <= 1e6 && v[son] && abs(son-l*b[i]) < 1e-6){ 
            	int gcd = _gcd(son, b[i]); // 约分 
                printf("%lld %lld\n", son / gcd, b[i] / gcd);
                break;
            }
        }
    }
    return 0; // 好习惯 
}
int prefix(long double t){
    int ans = 0, j = 0;
    for(int i = 1; i <= n; ++i){ // 枚举 b[i] 
        long double tbi = t*b[i]; // 省去重复计算 
        while((long double)a[j+1] < tbi && j < n)
			++j; // a[j]/b[i] 大于 a[j]/b[i+1]，所以可以直接从 j 枚举 
        ans += j;
    }
    return ans;
}
```

### 无注释纯享
 _请不要复制代码。_ 
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[100005], b[100005], n, q;
bool v[1000006];
long double minn, maxn;
int prefix(long double n);
inline int _gcd(int a, int b){return b?_gcd(b, a%b):a;}
signed main(){
    scanf("%lld %lld", &n, &q);
    for(int i = 1; i <= n; ++i) scanf("%lld", &a[i]), v[a[i]]++;
    for(int i = 1; i <= n; ++i) scanf("%lld", &b[i]);
    sort(a+1, a+n+1);
    sort(b+1, b+n+1);
    minn = (long double)a[1] / b[n] - 1e-8, maxn = (long double)a[n] / b[1] + 1e-8;
    while(q--){
        int m;
        scanf("%lld", &m);
        long double l = minn, r = maxn;
        while(r - l > 1e-12){
            long double mid = (l+r)/2;
            if(prefix(mid) >= m) r = mid;
            else l = mid;
        }
        for(int i = 1; i <= n; ++i){
            int son = round(l * b[i]);
            if(son <= 1e6 && v[son] && abs(son-l*b[i]) < 1e-6){
            	int gcd = _gcd(son, b[i]);
                printf("%lld %lld\n", son / gcd, b[i] / gcd);
                break;
            }
        }
    }
    return 0;
}
int prefix(long double t){
    int ans = 0, j = 0;
    for(int i = 1; i <= n; ++i){
        long double tbi = t*b[i];
        while((long double)a[j+1] < tbi && j < n)
			++j;
        ans += j;
    }
    return ans;
}
```

## 细节与技巧
- 二分开始时可以将边界设为 $\frac{a_1}{b_n}-10^{-7}\sim\frac{a_n}{b_`}+10^{-7}$，虽然不知道其他题解怎么不加减 $10^{-7}$ AC 的，但是仍然有可能会 [WA 一些点](https://www.luogu.com.cn/record/180291311)
- 二分时**一定要把精度设为小于 $10^{-12}$**，否则也会 [WA](https://www.luogu.com.cn/record/180387721)
- 因为 $\frac{a_{i}}{b_j+1}\le\frac{a_i}{b_j}$，所以枚举 $a_i(i \ge 2)$ 时必须直接沿用枚举 $a_{i-1}$ 时的 $j$，不然会 [TLE 14pts](https://www.luogu.com.cn/record/180341858)。

---

## 作者：cff_0102 (赞：4)

这道题可以使用二分的方法，具体判断方式是根据小于当前值的分数的数量来判断大了还是小了。如果小于当前值的分数数量大于输入的值，就继续二分 $[l,mid]$，否则二分 $[mid,r]$。这里 $l,r,mid$ 都应该是精度足够大的浮点数。

不过即使这样，check 函数的复杂度也得是 $O(n)$ 的，这样整个程序的复杂度是 $O(nq\log n)$，才能通过。那么，怎么才能 $O(n)$ 求出小于等于 $x$ 的分数个数呢？

首先分别提前把 $a,b$ 数组排序。这样排序后，不难发现：如果 $\dfrac{a_i}{b_j}<mid$，$\dfrac{a_i}{b_{j+1}}$ 也一定小于 $mid$。那么，就可以这样计算小于等于 $x$ 的分数个数：

```cpp
int i=0,d=0;
for(int j=0;j<n;j++){
	while(i<n && a[i]<b[j]*mid){//判断 a[i] 是否小于 b[j]*mid 即判断 a[i]/b[j] 是否小于 mid
		i++;
	}
	d+=i;
}
```

$a,b$ 数组的每个数最多被遍历到一次，所以这个 check 函数是 $O(n)$ 的。总时间复杂度 $O(nq\log n)$，可以通过。

下面是官方题解的代码，思路与上面是相同的：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const ll MAX = 1000000;

ll gcd(ll a, ll b) {
    while (b != 0) {
        ll t = a % b;
        a = b;
        b = t;
    }
    return a;
}

pair<int, int> smart(vector<ll>& a, vector<ll>& b, long long c) {
    int n = a.size();
    c--;

    double l = 0;
    double r = MAX + 1;

    ll pl, ql, pu, qu;
    
    for (int iter = 0; iter < 100; iter++) {
        double m = (l + r) / 2;
    
        int j = 0;
        long long d = 0;
        pu = 1;
        qu = 0;
        pl = 0;
        ql = 1;

        for (int i = 0; i < n; i++) {
            while (j < n && 1.0 * a[i] / b[j] >= m) {
                j++;
            }
            d += n - j;

            // a[i] / b[j] < m
            // check if a[i] / b[j] > pl / ql
            if (j < n && a[i] * ql > pl * b[j]) {
                pl = a[i];
                ql = b[j];
            }

            // a[i] / b[j - 1] >= m
            // check if a[i] / b[j - 1] < pu / qu
            if (j > 0 && a[i] * qu < pu * b[j - 1]) {
                pu = a[i];
                qu = b[j - 1];
            }
        }

        if (c < d) {
            r = m;
        } else {
            l = m;
        }
    }

    long long d = 0;
    int j = 0;
    for (int i = 0; i < n; i++) {
        // a[i] / b[j] >= pu / qu
        while (j < n && a[i] * qu >= pu * b[j]) {
            j++;
        }
        d += n - j;
    }

    if (d <= c) {
        ll g = gcd(pu, qu);
        pu /= g;
        qu /= g;
        return {pu, qu};
    }

    ll g = gcd(pl, ql);
    pl /= g;
    ql /= g;
    return {pl, ql};
}

pair<int, int> stupid(vector<ll>& a, vector<ll>& b, long long c) {
    vector<pair<ll, ll>> f;
    int n = a.size();
    c--;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            f.push_back({a[i], b[j]});
        }
    }
    sort(f.begin(), f.end(), [&](auto& p, auto& q) { return p.first * q.second < p.second * q.first; });

    pair<int, int> r = {f[(int) c].first, f[(int) c].second};
    int g = gcd(r.first, r.second);
    r.first /= g;
    r.second /= g;
    return r;
}

int main(int argc, char** argv) {
//    freopen("input", "r", stdin);
    int n, q;

    cin >> n >> q;

    vector<ll> a(n);
    vector<ll> b(n);

    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    for (int i = 0; i < n; i++) {
        cin >> b[i];
    }

    sort(a.begin(), a.end());
    sort(b.begin(), b.end());

    vector<ll> cs(q);
    for (int i = 0; i < q; i++) {
        cin >> cs[i];
    }

    
    for (ll c : cs) {
        auto p = smart(a, b, c);
        cout << p.first << " " << p.second << "\n";
    }

    return 0;
}
```

---

## 作者：XFlypig (赞：3)

常规题目，一眼**二分答案**

`calc(x)` 函数（其实就是 check ），返回有多少个数小于 $x$。

通过二分答案，并计算 calc 函数即可得知最终答案。

现在问题有两个，一是 calc 函数怎么写，二是结果要求分数。

## 一：

这种类型题目一般都是排序加**双指针**，对于本题，显然 $a, b$ 两个数组排完序，总有：

$\dfrac{a_i}{b_j} > \dfrac{a_i}{b_{j+1}}$  和  $\dfrac{a_i}{b_j} < \dfrac{a_{i+1}}{b_j}$

于是乎，双指针大发神威，$O(n)$ 解决 calc 函数。

```cpp
LL calc(double mid)
{
    LL cnt = 0;
    for (int i = 1, j = 0; i <= n; i ++ )
    {
        while (j <= n && a[i] * 1.0 / b[j] > mid) j ++ ;
        cnt += n - j + 1;
    }
    return cnt;
}
```

## 二: 

答案要求分数咋办？

~~讲真的我也不会~~。

这似乎并不太好解决，吗?

回顾 calc 函数，每次 while 循环结束时，都是对于同一个 $i$ 而言最接近 $mid$ 的时候，准确说是这个：

$\dfrac{a_i}{b_j} \le mid$  和  $\dfrac{a_i}{b_{j - 1}} \ge mid$

所以我们模仿 calc 函数, 来一个逼近正确结果的过程。

记 $ans$ 为我们二分出来的答案，即用每个指针 $i$ 和它找到的另一个指针 $j$ 来更新目前离 $ans$ 最近的分数，并记录下来，这样第二个问题就被解决了。

至此，时间复杂度是 $O(nq\log n)$, 那这题就解决了，吗？

似乎是的，但，我好像被卡精度了。

我把所有可以换的除法都换成了乘法，然后就成功的失败了，精度开太高会 T 前两个子任务，精度开太低，每个子任务都有 WA ！！！

最后，我掏出了看家本领，分类讨论！AC。

最后的最后，这不是一个能优雅的过掉此题所有数据的代码，就当顺便展示了下暴力吧qwq。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

#define x first
#define y second

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;

const int N = 100010;
const double eps = 1e-11;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int n, m;
int a[N], b[N];
LL c[N];

namespace Subtask45
{
    LL calc(double mid) // <= 
    {
        LL cnt = 0;
        for (int i = 1, j = 0; i <= n; i ++ )
        {
            while (j <= n && a[i] * 1.0 / b[j] > mid) j ++ ;
            cnt += n - j + 1;
        }
        return cnt;
    }
    
    void main()
    {
        for (int p = 1; p <= m; p ++ )
        {
            LL rk = c[p];
            PII ans;
            double det = 1e6;
            double l = 0, r = 1e6, mid;
            while (r - l > eps)
            {
                mid = (l + r) / 2;
                if (calc(mid) >= rk) r = mid;
                else l = mid;
            }
            
            for (int i = 1, j = 1; i <= n; i ++ )
            {
                while (j <= n && a[i] > r * b[j])
                {
                    if (abs(a[i] * 1.0 / b[j] - r) < det)
                    {
                        det = abs(a[i] * 1.0 / b[j] - r);
                        ans = {a[i], b[j]};
                    }
                    j ++ ;
                }
                if (abs(a[i] * 1.0 / b[j] - r) < det)
                {
                    det = abs(a[i] * 1.0 / b[j] - r);
                    ans = {a[i], b[j]};
                }
            }
            int t = gcd(ans.x, ans.y);
            printf("%d %d\n", ans.x / t, ans.y / t);
        }
    }
}

namespace Subtask12
{
    struct Node
    {
        int x, y;
        bool operator< (const Node& B) const
        {
            return (LL)x * B.y < (LL)B.x * y;
        }
    };
    
    vector<Node> g;
    void main()
    {
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                g.push_back({a[i], b[j]});
        
        sort(g.begin(), g.end());
        for (int i = 1; i <= m; i ++ )
        {
            LL rk = c[i] - 1;
            int t = gcd(g[rk].x, g[rk].y);
            printf("%d %d\n", g[rk].x / t, g[rk].y / t);
        }
    }
}

namespace Subtask3
{
    struct Node
    {
        int x, y;
        bool operator< (const Node& B) const
        {
            return (LL)x * B.y < (LL)B.x * y;
        }
    };
    
    vector<Node> g;
    void main()
    {
        for (int i = 1; i <= n && i <= 100; i ++ )
            for (int j = n; j && j > n - 100; j -- )
                g.push_back({a[i], b[j]});
        
        sort(g.begin(), g.end());
        for (int i = 1; i <= m; i ++ )
        {
            LL rk = c[i] - 1;
            int t = gcd(g[rk].x, g[rk].y);
            printf("%d %d\n", g[rk].x / t, g[rk].y / t);
        }
    }
}

int main()
{
    bool flag = true;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &b[i]);
    for (int i = 1; i <= m; i ++ )
    {
        scanf("%lld", &c[i]);
        if (c[i] > 100) flag = false;
    }
    
    sort(a + 1, a + n + 1), sort(b + 1, b + n + 1);
    
    if (n > 500 && !flag) Subtask45 :: main();
    else if (n <= 500) Subtask12 :: main();
    else Subtask3 :: main();
    
    return 0;
}

```

---

## 作者：MicroSun (赞：2)

你这数据真的太毒瘤了吧。

---

可以看出，这是一道二分答案题。

考虑对于每一次询问第 $k$ 个分数，实数二分出一个数，使得小于这个数的分数大于 $k$。

对于 `check` 函数，可以考虑使用双指针实现。将序列 $A$ 和 $B$ 按升序排列，易得 $\frac{A_i}{B_j}\le \frac{A_i+1}{B_j}$ 且 $\frac{A_i}{B_j}\le\frac{A_i}{B_j+1}$。对于每一个二分出的 $mid$，记以 $B_j$ 为分母的所有分数中，小于 $mid$ 的数个数为 $p_j$，根据上述性质，可以证得 $\forall_{1\le i<j\le n},p_i\le p_j$。

坑点：

1. 数据级毒瘤，二分的 `eps` 需设为 $10^{-12}$ 以下。

2. 需要疯狂调二分边界，~~我实在调不下去就用 map 水过了~~。

可以参考的实现：

```cpp
// Problem: P10091 [ROIR 2022 Day 2] 分数排序
// LuoguUID: 514700 
// LuoguUserName: MicroSun
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define pb push_back
#define fst first
#define scd second
#define rep(i,s,e) for(int i=s;i<=e;i++)
#define dep(i,s,e) for(int i=s;i>=e;i--)

using ll=long long;
using ld=long double;
using pii=pair<int,int>;
using pll=pair<ll,ll>;

const int maxn=1e5+10;

ld a[maxn],b[maxn];
ll n,q;
pll lst;
ll check(ld num){
	lst={0,1};
	int p=1;
	ll cnt=0;
	rep(i,1,n){
		while(a[p]<num*b[i]&&p<=n) ++p;
		cnt+=p-1;
		if(lst.scd*a[p-1]>lst.fst*b[i]) lst={a[p-1],b[i]};
	}
	return cnt;
}
map<ll,ld> mp;
pii get(ll p){
	mp.clear();
	ld l=0,r=1e12+10;
	while(r-l>1e-12){
		ld mid=(l+r)/2;
		ll num=check(mid);
		mp[num]=mid;
		if(num>p) r=mid;
		else l=mid;
	}
	for(auto i:mp){
		if(i.fst>=p){
			check(i.scd);
			ll a=__gcd(lst.fst,lst.scd);
			return {lst.fst/a,lst.scd/a};
		}
	}
}
void solve(){
	cin>>n>>q;
	rep(i,1,n) cin>>a[i];
	rep(i,1,n) cin>>b[i];
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	while(q--){
		ll t;
		cin>>t;
		pii ans=get(t);
		cout<<ans.fst<<' '<<ans.scd<<endl;
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--) solve();
    return 0;
}
```

---

## 作者：heyZZZ (赞：1)

思路：

使用二分答案。

二分答案分为两部分：`check` 函数和二分。

二分楼上楼下都讲的很清楚了。

本题解只讲 `check` 函数。

首先：

1. 先给 $a,b$ 数组排序。
2. 总共有 $\Large \frac{a_i}{b_j}$ $>$ $\Large \frac{a_i}{b_{j+1}}$ 和 $\Large \frac{a_i}{b_j}$ $<$ $\Large \frac{a_i+1}{b_{j}}$。
3. 最后双指针维护即可。

下放部分代码：

```cpp
bool check(double k){
    int j=0,sum=0;
	for(int i=1;i<=n;i++){
		while(a[j+1]<k*b[i]&&j<n)j++;
		sum+=j;
	}return sum>=q;
}
```

---

## 作者：yanxu_cn (赞：0)

一开始以为是想考二分，后来发现是在考卡精度啊……

抛开卡精度，并不是一个很难的题目。

首先想到这个题目应该是一个二分值域的一个问题。所以，我们应该维护一个东西快速的判断一个值对应的排名。由于二分有一个 $\log$，而这道题显然是个 $\Theta(n\log n)$ 级别的算法，所以应该做到线性级别。其他题解的基于顺序的单指针（我也不造应该叫什么）的确很精妙，但是我们发现值域很小，所以果断用前缀和维护去掉二分的一只 $\log$。

```cpp
// "a" and "b" are the original array. "bss" is the prefix array.
int a[maxn],b[maxn],bss[SIZE];
long long check(long double s)
{
	long long ans=0;
	for(int i=1;i<=n;i++)
	{
		long long bmin=ceill((long double)a[i]/s+eps);
		if(bmin<=0)
		ans+=n;
		else if(bmin<=1e6)
		ans+=n-bss[bmin-1];
	}
	return ans;
}
```

注意到这个题目还有一个神奇的要求：输出分数。由于二分的性质，我们很难在分数上进行，于是还需要把二分结果转成分数，所以二分的结果要有 $10^{-12}$ 的精度（非常离谱）。 

转分数的过程：枚举 $b_i$，并计算出对应的分子是多少，再检查 $a$ 数组中有没有这个分子并判断精度。

```cpp
bitset<SIZE>v;
pair<int,int>unique_finding(long double k)
{
	for(int i=1;i<=n;i++)
	{
		long long son=k*b[i]+0.5l;
		if(son<=1000000&&v[son]&&abs(son-k*b[i])<1e-6)
		{
			int gg=__gcd<long long>(son,(long long)b[i]);
			return {son/gg,b[i]/gg};
		}
	}
	return {-1,-1};
}
```

最后贴一下完整的代码方便参考。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int maxn=1e5+7,SIZE=1e6+7;
constexpr long double eps=1e-13;
int n,q;
int a[maxn],b[maxn],bss[SIZE];
bitset<SIZE>v;
long long check(long double s)
{
	long long ans=0;
	for(int i=1;i<=n;i++)
	{
		long long bmin=ceill((long double)a[i]/s+eps);
		if(bmin<=0)
		ans+=n;
		else if(bmin<=1e6)
		ans+=n-bss[bmin-1];
	}
	return ans;
}
pair<int,int>unique_finding(long double k)
{
	for(int i=1;i<=n;i++)
	{
		long long son=k*b[i]+0.5l;
		if(son<=1000000&&v[son]&&abs(son-k*b[i])<1e-6)
		{
			int gg=__gcd<long long>(son,(long long)b[i]);
			return {son/gg,b[i]/gg};
		}
	}
	return {-1,-1};
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)
		cin>>a[i],v[a[i]]=1;
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];
		bss[b[i]]++;
	}
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	for(int i=1;i<=1000000;i++)
	{
		bss[i]+=bss[i-1];
	}
	while(q--)
	{
		long long x;
		cin>>x;
		long double l=0,r=1e6;
		while(r-l>eps)
		{
			long double mid=(l+r)/2;
			long long cnt=check(mid);
			if(cnt>=x)r=mid;
			else l=mid;
		}
		auto res=unique_finding(l);
		cout<<res.first<<' '<<res.second<<'\n';
	}
	return 0;
}
```

---

## 作者：wangzc2012 (赞：0)

# P10091 [ROIR 2022 Day 2] 分数排序

## 题意概括
给定长度为 $n$ 的两个序列 $a$ 和 $b$，求在所有形如 $\frac{a_i}{b_j}$ 的分数中，第 $c_i$ 小的分数。

## 思路分析
首先，观察数据范围，如果将 $n^2$ 个分数全部枚举出来并排序显然会超时，因此我们要用一些其他的算法。  
题目需要求出第 $c_i$ 小的分数，这一点其实可以使用二分算法。首先，我们将题目拆分成两个问题，首先求出第 $c_i$ 小的数的近似值，然后通过枚举，计算出分子和分母。  
对于一个 $x$，如果我们知道有对少个数比 $x$ 小的数，就可以知道当前这个 $x$ 是大了还是小了，所以，对于第一个问题，我们先将 $a$ 和 $b$ 序列排序，然后结合一些单调性进行回答。具体细节请见下文。

## 算法实现
首先，先将 $a$ 和 $b$ 排序，同时，我们知道 $\frac{a}{b} > \frac{a}{b+1}$，因此，如果我们对于 $b_i$，求出 $a_{1 \dots j}$ 满足 $\frac{a}{b} < x$，那么对于 $b_{i+1}$，得到的 $a_{1 \dots j'}$ 一定满足 $j' \ge j$，因此 $j$ 具有单调性。我们在枚举 $b_i$ 时求 $j$ 并不断累加，最后的结果就是 $x$ 的排名。  
所以总结一下，我们先对 $a$ 和 $b$ 进行排序，然后二分出第 $c_i$ 小的数的近似值，在过程中不断判断该数排名并进行修正。  
对于第二个问题，我们直接枚举分母，然后去 $a$ 中寻找分子，如果分子的误差在一定范围内，那么就直接化简输出。

## 注意事项
- 本题对精度要求较高，需要注意精度。
- 注意数据范围，本题 $c_i$ 需要使用 long long 进行存储。

## AC Code
如果上面的解释太复杂，那就来看看代码吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,Q,a[100005],b[100005];
long long c;  //因为 c<=n^2 ,所以要开 long long
bool vis[1000005];  //记录数字在 A 中是否出现过
bool check(long double x){  //检查该数排名
    long long cnt=0/*记录当前 x 的排名*/,j=0;
    for (int i=1;i<=n;i++){
        while (j<=n-1 and a[j+1]<x*b[i]) j++;  // j 单调递增
        cnt=cnt+j;
    }
    return cnt>=c;
}
long double bin(){  //二分排在第k大的数
    long double l=(long double)a[1]/b[n],r=(long double)a[n]/b[1],mid;
    while (r-l>1e-13){
        mid=(l+r)/2;
        if (check(mid)) r=mid;
        else l=mid;
    }
    return l;
}
int main(){
    std::ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>Q;
    for (int i=1;i<=n;i++) cin>>a[i],vis[a[i]]=1;
    for (int i=1;i<=n;i++) cin>>b[i];
    sort(a+1,a+n+1);sort(b+1,b+n+1);  //排序
    while (Q--){
        cin>>c;
        long double t=bin();
        for (int i=1;i<=n;i++){
            int tmp=round(t*b[i]);
            if (tmp<=1e6/*防止数组越界*/ and vis[tmp]==1/*是否出现过*/ and abs(tmp-t*b[i])<1e-7/*精度差在一定范围内*/){
                int gd=__gcd(tmp,b[i]);  //化简分数
                cout<<tmp/gd<<' '<<b[i]/gd<<'\n';
                break;
            }
        }
    }
    return 0;
}

```
完结撒花！

## 更新日志
- 2024.11.15 优化了部分格式

---

## 作者：panxz2009 (赞：0)

很不友好，卡我精度。

首先注意到 $n\cdot q\le 10^5$，所以每次询问时枚举数列是可以被接受的。

同时显然二分答案，二分出这个分数。

`check` 函数也很好写，在询问前对 $a,b$ 排序，然后 `check` 函数里枚举分母 $b_j$，双指针求出有多少 $a_i$ 满足 $\frac{a_i}{b_j}< mid$ 累加即可。

求出这个分数以后，再枚举一遍分母 $b$，已知分数 $l$ 和分母 $b_j$，自然可以求出分子 $t$，检查该分子是否合法即可。

实现时用了 `round` 函数，四舍五入很方便。

```cpp
#include <bits/stdc++.h>
#define int long long
#define PII pair <int, int>
using namespace std;
int gcd(int x, int y) {
	return y ? gcd(y, x % y) : x;
}
PII div(PII tmp) {
	int x = tmp.first, y = tmp.second;
	int d = gcd(x, y);
	x /= d, y /= d;
	return {x, y};
}
const int maxn = 1e5 + 10;
const long double eps = 1e-13;
int n, Q, a[maxn], b[maxn], x;
PII res;
int check(long double mid) {
	int ans = 0;
	for(int i = 1, j = 0; i <= n; i++) {
		while(j < n && a[j + 1] * 1.0 < mid * b[i]) j++;
		ans += j;
	}
	return ans < x;
}
signed main() {
	scanf("%lld%lld", &n, &Q);
	for(int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
	}
	for(int i = 1; i <= n; i++) {
		scanf("%lld", &b[i]);
	}
	sort(a + 1, a + 1 + n);
	sort(b + 1, b + 1 + n);
	while(Q--) {
		scanf("%lld", &x);
		long double l = a[1] * 1.0 / b[n], r = a[n] * 1.0 / b[1];
		while(r - l > eps) {
			long double mid = (l + r) * 0.5;
			if(check(mid)) l = mid;
			else r = mid;
		}
		for(int i = 1; i <= n; i++) {
			int t = round(l * b[i]);
			int pos = lower_bound(a + 1, a + 1 + n, t) - a;
			if(pos != n + 1 && pos != 0 && a[pos] == t && abs(t - l * b[i]) < 1e-7) {
				res = div({t, b[i]});
				printf("%lld %lld\n", res.first, res.second);
				break;
			}
		}
	}
	return 0;
}
```

---


# 「FAOI-R3」移民计划

## 题目描述

给定两个正整数 $n,a$。

现有两个正整数数列 $\{h_n\},\{s_n\}$ 和一个正整数 $W$，满足：

$$\begin{cases} s_1=a, \\  s_i=\left\lceil \dfrac{h_{i-1}}{i} \right\rceil, \\  h_i=i \times s_i,\\  W=h_1\times h_2\times \ldots\times h_n. \end{cases}$$

试计算 $W$ 的值。**答案对 $10^9+7$ 取模。**

## 说明/提示

样例解释：

- 对于第 $1$ 组数据，$s$ 数列为 $\{1\}$，$h$ 数列为 $\{1\}$，故答案为 $1$。
- 对于第 $2$ 组数据，$s$ 数列为 $\{4,2\}$，$h$ 数列为 $\{4,4\}$，故答案为 $16$。
- 对于第 $3$ 组数据，$s$ 数列为 $\{9,5,4\}$，$h$ 数列为 $\{9,10,12\}$，故答案为 $1080$。
- 对于第 $4$ 组数据，取模前的答案为 $16721510400$。

------------

| 测试点编号 | $n \le$ | $a \le$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $100$ | $1000$ | $40$ |
| $2$ | $10^7$ | $1000$ | $30$ |
| $3$ | $10^7$ | $10^6$ | $30$ |

对于 $100\%$ 的数据，$1 \le T \le 10^5$，$1 \le n \le 10^7$，$1 \le a \le 10^6$。

## 样例 #1

### 输入

```
7
1 1
2 4
3 9
10 6
23 44
108 301
9181918 918918```

### 输出

```
1
16
1080
721510288
57314155
568048964
118153594```

# 题解

## 作者：封禁用户 (赞：3)

**Update：优化了 std，将运行时间控制在 $1$ 秒以内。**

# Part 0

由 $h_i=i \times s_i$，可以发现 $W=h_1\times h_2\times \ldots\times h_n=1 \times s_1 \times 2 \times s_2 \times \ldots \times n \times s_n=(1 \times 2 \times \ldots \times n) \times (s_1\times s_2\times \ldots\times s_n)=n! \times (s_1\times s_2\times \ldots\times s_n)$。

由于 $n \le 10^7$，阶乘部分可以预处理。下面只讨论如何求 $s_1\times s_2\times \ldots\times s_n$。
# Part 1

先来模拟一下样例第 $4$ 组数据：

| $\color{blue}i$ | $\color{blue}1$ | $\color{blue}2$ | $\color{blue}3$ | $\color{blue}4$ | $\color{blue}5$ | $\color{blue}6$ | $\color{blue}7$ | $\color{blue}8$ | $\color{blue}9$ | $\color{blue}10$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $s_i$ | $6$ | $3$ | $\color{red}2$ | $\color{red}2$ | $\color{red}2$ | $\color{red}2$ | $\color{red}2$ | $\color{red}2$ | $\color{red}2$ | $\color{red}2$ |
| $h_i$ | $6$ | $6$ | $6$ | $8$ | $10$ | $12$ | $14$ | $16$ | $18$ | $20$ |

再来模拟一下样例第 $5$ 组数据：

| $\color{blue}i$ | $\color{blue}1$ | $\color{blue}2$ | $\color{blue}3$ | $\color{blue}4$ | $\color{blue}5$ | $\color{blue}6$ | $\color{blue}7$ | $\color{blue}8$ | $\color{blue}9$ | $\color{blue}10$ | $\color{blue}11$ | $\color{blue}12$ | $\color{blue}13$ | $\color{blue}14$ | $\color{blue}15$ | $\color{blue}16$ | $\color{blue}17$ | $\color{blue}18$ | $\color{blue}19$ | $\color{blue}20$ | $\color{blue}21$ | $\color{blue}22$ | $\color{blue}23$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $s_i$ | $44$ | $22$ | $15$ | $12$ | $10$ | $9$ | $8$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ | $\color{red}7$ |
| $h_i$ | $44$ | $44$ | $45$ | $48$ | $50$ | $54$ | $56$ | $56$ | $63$ | $70$ | $77$ | $84$ | $91$ | $98$ | $105$ | $112$ | $119$ | $126$ | $133$ | $140$ | $147$ | $154$ | $161$ |

# Part 2

不难发现，当 $s_i \le i$ 时，$s_i$ 便不再变化了。

**证明：**

若 $s_i \le i$，则：

$$h_i=i \times s_i$$

$$\dfrac{h_{i}}{i+1}=\dfrac{i \times s_i}{i+1}$$

------------

$$s_i \le i$$

$$s_i-i-1 \le -1$$

$$s_i-i-1<0$$

------------

$$s_i = \dfrac{i \times s_i + s_i}{i+1} > \dfrac{i \times s_i}{i+1}>\dfrac{i \times s_i+s_i-i-1}{i+1}=s_i-1$$

$$s_i>\dfrac{i \times s_i}{i+1}>s_i-1$$

$$s_i>\dfrac{h_{i}}{i+1}>s_i-1$$

$$\lceil \dfrac{h_{i}}{i+1} \rceil=s_i$$

$$s_{i+1}=s_i$$

故 $s_i$ 不再变化。

# Part 3

此外，当这个时刻到来时，$i \le \sqrt{2a}$。

**证明：**

$s_i \le i$ 等价于 $h_i \le i^2$。设 $f(i)=h_i$，$g(i)=i^2$，$d(i)=f(i)-g(i)$，则 $f(1)=a$，$g(1)=1$，$d(1)=a-1$，$s_i \le i$ 等价于 $d(i)\le0$；

当 $i$ 增加 $1$（即设 $j=i+1$）时，$g(j)-g(i)=2j-1$；

显然：

$$\lceil \dfrac{h_{i}}{j} \rceil-\dfrac{h_{i}}{j}<1$$

$$\lceil \dfrac{h_{j-1}}{j} \rceil \times j-\dfrac{h_{i}}{j} \times j<j$$

$$h_j-h_i<j$$

$$f(j)-f(i)<j$$

$$f(j)-f(i)\le j-1$$

故 $d(j)-d(i)=[f(j)-g(j)]-[f(i)-g(i)]=[f(j)-f(i)]-[g(j)-g(i)]\le (j-1)-(2j-1)=-j$，即 $d(j)-d(i)\le-j$。

也就是说，当 $i$ 增加到 $j=i+1$ 时，$d$ 函数的值至少减小 $j$；

当 $i=\sqrt{2a}$ 时，$d(i)=a-1-2-3-\ldots-\sqrt{2a}=a-\dfrac{(1+\sqrt{2a})\times \sqrt{2a}}{2}=-\sqrt{\dfrac{a}{2}}<0$，显然这个时刻已经到来。

# Part 4

于是，我们暴力计算 $s_1 \sim s_{\sqrt{2a}}$，剩下的上快速幂就行了。

最终的时间复杂度为 $O(n+T\sqrt{a})$，空间复杂度为 $O(n)$。

提示：代码中 $\lfloor\dfrac{(a+1)\times (i-1)}{i}\rfloor=\lfloor\dfrac{a\times (i-1)+(i-1)}{i}\rfloor=\lceil\dfrac{a\times (i-1)}{i}\rceil$。

# Part 5

std：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int P = 1e9 + 7, N = 1e7 + 12, Real_N = 1e7;
int power(int a, int b, int p)
{
    if (b == 1) return a;
    int x = power(a, b >> 1, p);
    x = 1ll * x * x % p;
    if (b & 1) x = 1ll * x * a % p;
    return x;
}
int fc[N];
void preset()
{
    fc[0] = 1;
    for (int i = 1; i <= Real_N; i++)
        fc[i] = 1ll * fc[i - 1] * i % P;
}
int main()
{
    preset();
	int T;
    cin >> T;
    while (T--)
    {
        int n, a, i;
        cin >> n >> a;
        long long W = a;
	    for (i = 2; i <= n; i++)
	    {
		    a = (a + 1) * (i - 1) / i;
		    W *= a, W %= P;
		    if (a <= i) break;
	    }
	    if (i < n) W *= power(a, n - i, P), W %= P;
	    cout << W * fc[n] % P << endl;
    }
	return 0;
}
```

---

## 作者：Cuiyi_SAI (赞：2)

## $\large{\text{Solution}}$

提供一种适合赛时小白使用的方法。

看了一下题解，大佬们都用恐怖的数学证明了以下做法的结论，但是往往有时候打比赛如果不是实力过硬，就并没有那么多时间来证明。  
因此对于这种限制相对简单的数列题，我们可以直接**暴力，生成题目中的序列然后在上面找规律**。一般都能找到的，因为其实通过数学做的一切对算法优化，投影到实际其实就是把一些冗余计算给省略了——所以这种**省略冗余**的操作肯定能用眼睛找规律来做啦！

肯定要对答案进行一定的转化（否则干嘛放 T3）。根据题目可以发现 
$$
\begin{aligned}
W&=\prod\limits_{i=1}^n h_i\\[3px]
&=\prod\limits_{i=1}^n i\cdot\prod\limits_{i=1}^n s_i
\end{aligned}
$$
显然前面的一个连乘可以直接预处理一个前缀积数组来 $O(1)$ 解决掉，那么问题就转化为求 $s$ 的乘积了。

我们写出暴力，将样例中的前 $5$ 个序列 $s$ 跑出来观察，发现是这样的：

```
1
4 2 
9 5 4 
6 3 2 2 2 2 2 2 2 2
44 22 15 12 10 9 8 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

我们可以发现，随着数据规模的增大，$s$ 后面应该是跟着一大坨重复的数的。这一点就非常的适合优化了，因为这意味着对于后面重复的一堆数我们可以只算一次就得到他们的乘积，当然是用快速幂了。  
多跑几组更大的数据发现这个规律没错，$s$ 后面一定会有大量冗余，真正不同的数字只有最多 $1500$ 个（这个是用暴力跑出来得到的，亲测这种方法在赛时非常好用）。所以算法思路就很明确了，对于不同的数字我们暴力计算其乘积，相同的数字我们用快速幂计算其贡献，就可以得到 $\prod\limits_{i=1}^n s_i$，于是再乘上一个预处理出来的前缀积 $mul_n$ 就可以得到 $\prod\limits_{i=1}^n h_i$ 啦。

时间复杂度大概是 $O(1500\cdot T)$，那个 $1500$ 具体怎么来的可以看前面大佬们的题解，赛时的时候就不用深究啦，肯定能过。

## $\large{\text{Code}}$

具体实现参考下面这份代码。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int T,n,a,s,h;
int ksm(int a,int b){
    int res=1ll;
    while(b){
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
int ji[10000010];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>T;
    ji[0]=1ll;
    for(int i=1;i<=10000000;i++){ ji[i]=ji[i-1]*i%mod; }  //前缀积
    while(T--){
        int ans=1ll,num=0,i;
        cin>>n>>a;
        s=h=a;
        ans=a*ji[n]%mod;
        for(i=2;i<=n;i++){
            if((h-1)/i+1==s) num++;
            else num=0;
            if(num>10) break;  //只要有连续十个相同，那么后面也就全部相同啦
            s=(h-1)/i+1;
            h=i*s;
            ans=ans*s%mod;  //暴力处理前面部分
        }
        if(i<=n) ans=ans*ksm(s,n-i+1)%mod;  //后面直接快速幂优化掉
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

首先很显然 $\prod_{i=1}^n h_i=\prod_{i=1}^n(i\times s_i)=\prod_{i=1}^ni\times\prod_{i=1}^ns_i=i!\times \prod_{i=1}^n s_i$，因为 $n\le 10^7$ 所以可以直接预处理出所有 $i!$，那么关键在与如何求出 $s_i$。

我们来手搓一下样例四，五：

样例四：

$$s=6\ 3\ 2\ 2\ 2\cdots2$$

我们发现省略的地方全是 $2$，似乎发现了些什么……

样例五：

$$s=44\ 22\ 15\ 12\ 10\ 9\ 8\ 8\ 8\cdots 8$$

我们发现了一个结论，当 $s_i<i$ 时，接下来 $s_i$ 会一直重复，而且重复大约才发生在 $\sqrt{a}$ 附近的（证明具体见别的大佬）。

那么我们只需暴力计算不重复的部分，剩下的直接上快速幂即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e7+5,mod=1e9+7;
int T;
int n,a;
int jc[N];

int fastexp(int a,int b,int c){
	int ans=1;
	while(b){
		if(b&1) ans=ans*a%c;
		a=a*a%c;
		b>>=1;
	}
	return ans;
}

void init(){
	jc[0]=1;
	for(int i=1;i<N;i++) jc[i]=jc[i-1]*i%mod;
}

void solve(){
	cin>>n>>a;
	int i,w=a;
	for(i=2;i<=n;i++){
		a=(a+1)*(i-1)/i,(w*=a)%=mod;
		if(a<=i) break;
	}
	if(i<n) (w*=fastexp(a,n-i,mod))%=mod;
	cout<<w*jc[n]%mod<<endl;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	init();
	cin>>T;
	while(T--) solve();
	return 0;
}

```

---

## 作者：coderJerry (赞：1)

我才不会告诉你这题我在学校机房~~调了快 1.5 h。~~

本篇题解更适合像我这样~~赛时没做出来~~的人阅读哦。

而且虽然无任何卡常，但也能 1s 跑过。
### 题目大意
打表好题！

给定两个正整数 $n,a$。现有两个正整数数列 $\{h_n\},\{s_n\}$ 和一个正整数 $W$，满足：

$$\begin{cases} s_1=a, \\  s_i=\lceil \dfrac{h_{i-1}}{i} \rceil, \\  h_i=i \times s_i,\\  W=h_1\times h_2\times \ldots\times h_n. \end{cases}$$

计算 $W$ 的值对 $10^9+7$ 取模的结果。
### 思路
如果暴力计算 $h,s$ 数列的值，复杂度 $O(Tn)$，有 $40$ 分。

考虑优化。$T$ 你肯定是没得动了，于是猜想：能否只求出 $s$ 的一部分，而后面的 $s$ 数列是有规律的呢？使用暴力程序打表可以得到：$s$ 的前几项逐渐变小，而后面的全部为相同值。证明大佬已经给过此处略去（毕竟打表找规律更适合像我这样的新手嘛）。于是循环计算 $s$，当某一项与前一项相同时，剩余部分直接快速幂 $\log$ 级别搞定。注意：$h_i=i\times s_i$，所以我们先把 $i$ 单独提出去处理求 $i!$（求出 $1-10^7$ 所有数的阶乘然后 $O(1)$ 查询即可）。

为了节省空间，我们只需设 $4$ 个变量记录最后全部相同的 $s$，当前的 $s$。$h$ 亦是同理。

另外是我的具体实现：$k$ 用来记录 $s$ 相同时第一次出现这个值的下标。如果搜索完 $k$ 还是初值 $-1$，那就暴力计算，否则就快速幂 $+$ 前面提到的 $O(1)$ 查询阶乘计算后面 $s$ 相同的部分。

最后是细节：该开 ```long long``` 的就要开，别忘了及时取模。
### AC 代码
[记录，最慢点 951ms](https://www.luogu.com.cn/record/148179914)
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7,N=10000000+10;
int qpow(int x,int y){
    long long ans=1;
    while(y){
        if(y&1) ans=ans*x%mod;
        x=1ll*x*x%mod;
        y>>=1;
    }
    return ans;
}
int main(){
    int t,n,a;
    vector<int> cal(N,1);
    cin>>t;
    for(int i=2;i<=10000000;i++) cal[i]=(1ll*i*cal[i-1]%mod);
    //预处理阶乘
    while(t--){
        cin>>n>>a;
        int s=a,h=a,ans=a,k=-1;//记得给初值！
        for (int i=2;i<=n;i++){
            int ns=(h+i-1)/i;
            int nh=i*ns;
            //求解当前 s,n
            if(ns==s){k=i-1;break;}
            //s 与前面相同了就 break
            ans=1ll*ans*ns%mod;
            s=ns,h=nh;
            //否则继续计算下一个 s,h
        }
        if(k!=-1) ans=ans*1ll*qpow(s,n-k)%mod;
        //s 后面出现相同的情况时直接快速幂解决
        ans=1ll*ans*cal[n]%mod;
        //最后把提出去的 i! 乘起来
        cout<<ans<<'\n';
    }
    return 0;
}
```


---

## 作者：xler0915 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10154) / [可能有更好的阅读体验](https://www.luogu.com.cn/blog/hen-you-so-beautiful/solution-p10154)

### 题意

已知 $n$、$a$，定义 $s_1=a$，$s_i = \lceil\dfrac{i-1}{i}s_{i-1}\rceil(i\ge2)$，求 $\prod\limits^{n}_{i=1}is_i$，$T$ 组数据。保证 $1 \le T \le 10^5, 1 \le n \le 10^7, 1 \le a \le 10^6$。

### 思路

~~手搓几组数据后~~，可以发现 $s_i$ 在 $i$ 足够大的范围内保持不变。

由 $s_i = \lceil\dfrac{i-1}{i}s_{i-1}\rceil$ 变换可得 $s_i = s_{i-1}-\lfloor\dfrac{1}{i}s_{i-1}\rfloor$，在 $i$ 足够大的情况下，对于任意 $j \ge i$，均可使得 $s_i <j$。

因此可得本题的解法：对于前面几个，直接算出 $s_i$ 的值，并将答案乘上 $is_i$；当发现满足 $s_i=s_{i-1}$ 时，就说明这 $n-i+1$ 个值 $s_i,s_{i+1},s_{i+2},\cdots,s_n$ 都一样，将答案乘上 $\prod\limits^{n}_{j=i}js_i=s_i^{n-i+1}\dfrac{fac_m}{fac_i}$（使用逆元，其中 $fac_x$ 表示 $\prod\limits^x_{i=1}i$），程序结束。当然，在具体实现中，可以直接用 $a$ 迭代。

### 代码

注：本代码中，用 $m$ 表示原题中的 $n$，用 $n$ 表示原题中的 $a$。对于代码中第 $14$ 行 ```n = (n + 1) * (i - 1) / i;``` 的解释是：
$$n=\lceil\dfrac{(i-1)n}{i}\rceil=\lfloor\dfrac{(i-1)n+(i-1)}{i}\rfloor=\lfloor\dfrac{(i-1)(n+1)}{i}\rfloor$$
写成代码就是上面这行。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int mod = 1e9 + 7;
ll n, m, ans;
ll fac[10000005];

ll ksm(ll a, ll b = mod - 2) {
	ll res = 1;
	for(; b; b >>= 1, a = a * a % mod)
		if(b & 1) res = res * a % mod;
	return res;
}

int main() {
	int T; cin >> T;
	fac[0] = 1;
	for(int i = 1; i <= 1e7; i++) 
		fac[i] = fac[i - 1] * i % mod; 
	while(T--) {
		cin >> m >> n;
		ans = n;
		for(int i = 2; i <= m; i++) {
			ll ln = n;
			n = (n + 1) * (i - 1) / i;
			if(n == ln) {
				ans = ksm(n, m - i + 1) * fac[m] % mod * ksm(fac[i - 1]) % mod * ans % mod;
				break;
			} else 
				ans = n * i % mod * ans % mod; 
		} 
		cout << ans << endl;
	} 
	return 0;
}

```


---

## 作者：Silvestorm (赞：0)

### 题目大意

[原题链接](https://www.luogu.com.cn/problem/P10154)。

有 $T$ 次询问，每次询问按照给定的规则构造两个序列 $\{s_n\},\{h_n\}$，并且输出 $W$。

规则如下：
$$
\begin{cases}
    s_1=a, \\
    s_i=[\dfrac{h_{i-1}}{i}],\\
    h_i=s_i\times i,\\
    W=h_1\times h_2\times h_3\times ...\times h_{n-1} \times h_n.
\end{cases}
$$

对于 $100\%$ 的数据，$1\le T\le 10^5,1\le n\le 10^7,1\le a\le 10^6$。
### 题目类型

构造，数学。

### 解法
由于 $n$ 的范围比较大，并且是多组输入，那么乖乖按照题意去构造序列的方法就被我们舍弃了。

不难想到，有些数学结论待我们发现。

观察规则，可以发现对于任意 $i(1\le i\le n)$，都有 $h_i=s_i\times i$，那么可以将 $W$ 分解，即：

 $$W=(\prod_{i=1}^ns_i)\times n!$$
 
 想到这里已经解决一部分问题，$n!$ 可以预处理，之后 $O(1)$ 查询即可。
 
 ```cpp
    num[1] = 1;
    for (int i = 2; i <= 10000000; i++)
    {
        num[i] = num[i - 1] * i;
        num[i] = num[i] % 1000000007;
    }
```

更重要的问题在后面，另一个数列怎么构造，或者说，它的规律是什么？

由 $h_{i-1}\le h_i$ 得到 $s_{i-1}\times(i-1)\le s_i\times i$，再得到 $s_i \geq \dfrac{s_{i-1}\times (i-1)}{i}$，这里的 $s_i$ 要向上取整。

显然，当 $i$ 大于某个值时，$s_i$ 就不会变了，以这个值为分界点，前面的暴力碾过，后面的用快速幂就行。

### code

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
unsigned ll n, a, ans, tem, num[10010000], mod = 1000000007;
ll fastpower(ll a, ll b, ll p) // 快速幂取模
{
    if (b == 0)
        return 1;
    long long ans = 1;
    while (b > 1)
    {
        if (b & 1)
            ans = ans * a % p;
        a = a * a % p;
        b = b >> 1;
    }

    return ans * a % p;
}
void solve()
{

    tem = 2;
    cin >> n >> a;
    ans = a;
    for (int i = 2; i <= n; i++)
    {

        if (a == (a * (i - 1) + i - 1) / i)
            break;
        a = (a * (i - 1) + i - 1) / i;
        ans *= a;
        ans = ans % mod;
        tem++;
    }
    ans *= num[n];
    ans = ans % mod;
    ans *= fastpower(a, n - tem + 1, mod);
    ans = ans % mod;
    cout << ans << '\n';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    num[1] = 1;
    for (int i = 2; i <= 1e7; i++)//预处理阶乘
    {
        num[i] = num[i - 1] * i;
        num[i] = num[i] % mod;
    }
    int t;
    cin >> t;
    while (t--)
        solve();
    return 0;
}
```


---

## 作者：Kazeno_Akina (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10154)

看到题目很容易想出来一个 $O(Tn)$ 的暴力，就是挨个把 $h_{i}$ 算出来。其递推式即：$h_{i}=\lceil\dfrac{h_{i-1}}{i}\rceil \times i$。

考虑怎么优化这个东西。~~由于实在没什么思路~~开始打表。

如果你打出来这个表的开始一小部分，你就会得到这么一个东西：
```
a=1: 1 2 3 4 5 6 7 8 9 10 11 12 13...
a=2: 2 2 3 4 5 6 7 8 9 10 11 12 13...
a=3: 3 4 6 8 10 12 14 16 18 20 22 24 26...
a=4: 4 4 6 8 10 12 14 16 18 20 22 24 26...
a=5: 5 6 6 8 10 12 14 16 18 20 22 24 26...
a=6: 6 6 6 8 10 12 14 16 18 20 22 24 26...
a=7: 7 8 9 12 15 18 21 24 27 30 33 36 39...
a=8: 8 8 9 12 15 18 21 24 27 30 33 36 39...
a=9: 9 10 12 12 15 18 21 24 27 30 33 36 39...
a=10: 10 10 12 12 15 18 21 24 27 30 33 36 39...
a=11: 11 12 12 12 15 18 21 24 27 30 33 36 39...
a=12: 12 12 12 12 15 18 21 24 27 30 33 36 39...
a=13: 13 14 15 16 20 24 28 32 36 40 44 48 52...
```
然后你就发现一个关键性质：

**对于一个 $a$ 值所对应的 $h$ 数列，当首次有 $h_{i}\le i^2$ 时，记 $\dfrac{h_{i}}{i^2}=p$，则从第 $i$ 项开始，$h_{i}=p\times i$。**

事实上这个东西是可以证的。不妨设上述 $h_{i}$ 的下标为 $k$，于是首先 $p<k$，而对于 $i\ge k$，倘若有 $h_{i}=p\times i$，则 $h_{i+1}$ 首先不大于 $p(i+1)$，而 $(p-1)(i+1)=p\times i+p-i-1=h_{i}-(i+1-p)<h_{i}$，因此这个 $\dfrac{h_{i+1}}{i+1}$ 是不能小于 $p$ 的，那么只能有 $h_{i+1}=p(i+1)$。

于是在第一次遇到 $h_{i}\le i^2$ 时直接将后面的部分之和根据等差数列求和以及 $p$ 求出来即可。请记得开 `__int128`！！

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long P=1e18;
int T;
__int128 a;
long long n,a1,ans;
inline long long calc(__int128 k){return ((k%P)*((k+1)%P)/2)%P;}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin >> T;
	while(T--){
		cin >> n >> a1,ans=0,a=a1;
		for(long long i=1;i<=n;++i){
			ans=(ans+a)%P;
			if(a<=i*i){
				ans+=(a/i%P)*((calc(n)-calc(i)+P)%P)%P;
				ans%=P;
				break;
			}
			a=(a+i)/(i+1)*(i+1);
			a%=P;
		}
		cout << ans << '\n';
	}
	return 0;
}
```

---


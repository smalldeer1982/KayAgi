# 机器人

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/sub3kd3c.png)

> 画师：白森 さわ（from pixiv），侵删。

## 题目描述

真寻连清理炸弹都懒得自己使用，于是美波里又发明了一款全自动扫地机器人来清理房间。

真寻的房间由 $n$ 行 $m$ 列的方砖组成，第 $i$ 行第 $j$ 列的方砖上的灰尘数量为 $a_{i,j}$。美波里的机器人每天会从房间的左上角出发，每次随机往右或往下走一步。

若机器人在没有撞墙的情况下走到了右下角，那么它会返回**它经过的所有方砖的灰尘数量的异或和**给美波里；若机器人在走到右下角之前撞了墙，即某一步的目标位置不存在，那么机器人会返回一个错误值 $x$ 并结束移动。

现给出某一天真寻的房间中每一块方砖上的灰尘数量，请你求出机器人返回值的期望值。

形式化地，给定一 $n\times m$ 的矩阵 $a$，第 $i$ 行第 $j$ 列的权值为 $a_{i,j}$，现有一机器人从 $(1,1)$ 出发，每次各有 $\frac{1}{2}$ 的概率从 $(i,j)$ 移动至 $(i,j+1)$ 或 $(i+1,j)$；若机器人移动至 $(n,m)$，则返回**路径点权异或和**；若在移动至 $(n,m)$ 前有任意时刻移动至矩阵外，则返回 $x$；求返回值的期望值。

答案对 $10^9+7$ 取模。

## 说明/提示

**样例** $\mathbf{1}$ **解释**

若机器人第一步往下走，则：

- 若机器人第二步往下走，则撞墙，返回 $5$，概率为 $\frac{1}{4}$；

- 若机器人第二步往右走，则：

	- 若机器人第三步往下走，则撞墙，返回 $5$，概率为 $\frac{1}{8}$；
    
    - 若机器人第三步往右走，则到达右下角，返回 $7\oplus 10\oplus 6\oplus 3=8$，概率为 $\frac{1}{8}$；
    
若机器人第一步往右走，则：

- 若机器人第二步往下走，则：

	- 若机器人第三步往下走，则撞墙，返回 $5$，概率为 $\frac{1}{8}$；
    
    - 若机器人第三步往右走，则到达右下角，返回 $7\oplus 18\oplus 6\oplus 3=16$，概率为 $\frac{1}{8}$；
    
- 若机器人第二步往右走，则：
    
    - 若机器人第三步往下走，则到达右下角，返回 $7\oplus 18\oplus 4\oplus 3=18$，概率为 $\frac{1}{8}$；
    
    - 若机器人第三步往右走，则撞墙，返回 $5$，概率为 $\frac{1}{8}$；

因此，返回值的期望值为 $\frac{3\times 5+8+16+18}{8}+\frac{5}{4}=\frac{67}{8}$，在模 $10^9+7$ 意义下为 $375000011$。

**数据范围**

对于所有数据，$1\leq n,m\leq 10^3$，$0\leq a_{i,j},x\leq 10^9$。

本题共 $22$ 个测试点，**采用捆绑测试**，子任务及数据点分配如下：

| 子任务编号 | 数据点编号 | 特殊性质 | 分值 |
| :-: | :-: | :-: | :-: |
| $0$ | $1\sim 4$ | $n,m\leq 12$ | $10$ |
| $1$ | $5\sim 8$ | $n,m\leq 20$ | $20$ |
| $2$ | $9\sim 12$ | $a_{i,j}\leq 20$ | $20$ |
| $3$ | $13\sim 16$ | $x=0$ | $20$ |
| $4$ | $17\sim 22$ | 无特殊限制 | $30$ |

**提示**

$\oplus$ 表示异或（bitwise xor），$x_1,x_2,x_3,\cdots,x_n$ 的异或和为 $x_1\oplus x_2\oplus x_3\oplus\cdots \oplus x_n$。

## 样例 #1

### 输入

```
2 3 5
7 18 4
10 6 3```

### 输出

```
375000011```

## 样例 #2

### 输入

```
6 5 0
9 4 6 2 3
6 4 4 0 1
2 0 4 3 0
1 5 7 3 4
5 0 2 1 5
6 4 9 8 3```

### 输出

```
99609378```

# 题解

## 作者：Link_Cut_Y (赞：3)

发现异或拆位后各位互不影响。因此考虑拆位。

不妨设 $f_{i, j, k, l}$ 表示到了 $(i, j)$，前面的所有数第  $k$ 位的异或和为 $l$，其概率为多少。不难得到转移：

$$f_{i, j, k, l} \leftarrow (f_{i - 1, j, k, l_1} + f_{i, j - 1, k, l_2}) \times \dfrac{1}{2}$$

于是我们在 $O(nm \log V)$ 复杂度下得到了走到 $(n, m)$ 的期望。

接下来考虑撞墙的概率。不妨设 $g_{i, j}$ 表示走到 $(i, j)$ 格子的概率。转移范围为 $1 \sim n + 1$，以及 $1 \sim m + 1$。最终答案就是 $x \times (\sum g_{n +1, i} +\sum g_{i, m + 1})$。这个转移是 $O(nm)$ 的。

因此我们得到了一个 $O(nm \log n)$ 的做法。代码如下：

```cpp
int qpow(int a, int b = mod - 2, int s = 1) {
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1) s = s * a % mod; return s;
}
void dp(int k) {
	rep(i, 1, n) rep(j, 1, m)
		p[i][j][0] = p[i][j][1] = 0;
	p[1][1][(a[1][1] >> k) & 1] = 1;
	rep(i, 1, n) rep(j, 1, m) {
		if (i == 1 and j == 1) continue;
		if ((a[i][j] >> k) & 1) {
			(p[i][j][1] += inv2 * p[i - 1][j][0]) %= mod;
			(p[i][j][0] += inv2 * p[i - 1][j][1]) %= mod;
			(p[i][j][1] += inv2 * p[i][j - 1][0]) %= mod;
			(p[i][j][0] += inv2 * p[i][j - 1][1]) %= mod;
		} else {
			(p[i][j][1] += inv2 * p[i - 1][j][1]) %= mod;
			(p[i][j][0] += inv2 * p[i - 1][j][0]) %= mod;
			(p[i][j][1] += inv2 * p[i][j - 1][1]) %= mod;
			(p[i][j][0] += inv2 * p[i][j - 1][0]) %= mod;
		}
	}
}
int count(int x) {
	dep(i, 30, 0) if ((x >> i) & 1) return i;
}
signed main() {
	read(n, m, x); inv2 = qpow(2);
	rep(i, 1, n) rep(j, 1, m) read(a[i][j]);
	int mx = 0; rep(i, 1, n) rep(j, 1, m)
		mx = max(mx, a[i][j]);
	int sz = count(mx);
	rep(i, 0, sz) dp(i), (ans += (1ll << i) * p[n][m][1]) %= mod;;
	f[1][1] = 1; rep(i, 1, n + 1) rep(j, 1, m + 1) {
		if (i == 1 and j == 1) continue;
		if (j == m + 1) { (f[i][j] += f[i][j - 1] * inv2) %= mod; continue; }
		if (i == n + 1) { (f[i][j] += f[i - 1][j] * inv2) %= mod; continue; }
		if (j != m + 1) (f[i][j] += f[i - 1][j] * inv2) %= mod;
		if (i != n + 1) (f[i][j] += f[i][j - 1] * inv2) %= mod;
	}
	rep(i, 1, m - 1) (ans += x * f[n + 1][i] % mod) %= mod;
	rep(i, 1, n - 1) (ans += x * f[i][m + 1] % mod) %= mod;
	cout << ans << endl; return 0;
}
```

---

## 作者：wzy0 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P10267)

这道题询问的是**返回值的期望**。 \
我们把求期望分解为 求返回值的和（记为 $h$）与可能的路径数。 \
又考虑到返回值的两种情况，我们依次考虑。

- 成功到达 $(n,m)$
>此时返回值为机器人经过的所有方砖的灰尘数量的**异或和**。 \
>而异或和的结果显然可以拆位求出。
>
>设 $b_{i,j,k}$ 为 $a_{i,j}$ 的第 $k$ 位上的值；$dp_{i,j,0/1}$ 为到达点 $(i,j)$，且第 $k$ 位上值是 $0/1$ 的总情况数。 \
>具体的，我们枚举第 $k$ 位。 \
>容易发现在第 $k$ 位下，$dp_{i,j,x} = dp_{i-1,j,x \oplus b_{i,j,k}} + dp_{i,j-1,x \oplus b_{i,j,k}}$。 \
>然后使 $h \gets h + dp_{n,m,1} \times 2^k$。
- 中途撞墙
>此时返回值为 $x$，我们设有 $y$ 种情况会撞墙。 \
>由于前面计算时走了 $n+m-2$ 步，所以为了方便计算，这里也考虑走了 $n+m-2$ 步的情况。
>
>撞墙的情况显然等于 总情况减去没有撞墙的情况，也就是 $y = 2^{n+m-2} - \begin{pmatrix} n+m-2 \\ n-1 \end{pmatrix}$。 \
>所以使 $h \gets h + x \times y$。
- 可能的路径数
>由前面可知，显然为 $2^{n+m-2}$。

结合一下上面三点，答案显然为 $\large \frac {h}{2^{n+m-2}}$。记得取模。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;

const long long mod=1000000007;
long long n,m,x,z,a[1003][1003],g[1003][1003][2],h;
long long r[40];

long long into(){
	r[0]=1;for(int i=1;i<32;i++)r[i]=r[i-1]*2;
	return 0;
}

long long ksm(long long d,long long z){
	long long s=1;
	while(z>0){
		if(z&1){
			s*=d;s%=mod;
		}
		d*=d;d%=mod;
		z>>=1;
	}
	return s%mod;
}

int main(){
	ios::sync_with_stdio(0);cin.tie();cout.tie();
	into();
	cin>>n>>m>>x;
	z=ksm(2,n+m-2);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++)g[i][0][0]=g[i][0][1]=0;
	for(int j=1;j<=m;j++)g[0][j][0]=g[0][j][1]=0;
	for(int u=0;u<32;u++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(i==1 && i==j){
					if(a[i][j]&r[u])g[i][j][0]=0,g[i][j][1]=1;
					else g[i][j][0]=1,g[i][j][1]=0;
				}else{
					if(a[i][j]&r[u]){
						g[i][j][0]=g[i-1][j][1]+g[i][j-1][1];
						g[i][j][1]=g[i-1][j][0]+g[i][j-1][0];
					}else{
						g[i][j][0]=g[i-1][j][0]+g[i][j-1][0];
						g[i][j][1]=g[i-1][j][1]+g[i][j-1][1];
					}
				}
				g[i][j][0]%=mod;g[i][j][1]%=mod;
			}
		}
		h+=r[u]%mod*g[n][m][1]%mod;h%=mod;
	}
	h+=(z-(g[n][m][0]+g[n][m][1])+mod)%mod*x%mod;h%=mod;
	z=ksm(z,mod-2);
	h*=z;h%=mod;
	cout<<h;
	return 0;
}
```

---

## 作者：wwt100127 (赞：0)

## 思路
**期望 DP。**

分成撞不撞墙两种可能。

设 $Arrive_{i,j}$ 表示从 $(1,1)$ 出发，走 $i+j-2$ 步，到达 $(i,j)$ 的概率。
则撞墙的期望就是 $x \times (1-Arrive_{i,j})$。

接下来考虑不撞墙的情况。

如果直接 DP，比较困难。因为是异或操作，可以考虑将每一位分开计算。

对于第 $k$ 位，设 $dp_{i,j}$ 表示从 $(1,1)$ 出发，到达 $(i,j)$，第 $k$ 位异或是 $1$ 的概率。

如果 $a_{i,j}$ 的第 $k$ 位是 $0$，则要使异或后使 $1$，只需要让上一个位置异或完是 $1$，即：
$$
dp_{i,j} = dp_{i-1,j} + dp_{i,j-1}
$$

同理，如果 $a_{i,j}$ 的第 $k$ 位是 $1$，则要使异或后使 $1$，只需要让上一个位置异或完是 $0$。

 $\text{异或完是 0 的概率 = 到达此地的概率 - 异或完是 1 的概率}$。

所以此时：
$$
dp_{i,j} = Arrive_{i-1,j} - dp_{i-1,j} + Arrive_{i,j-1} - dp_{i,j-1}
$$

将答案累加即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool Beginning;

#define pb(x) push_back(x)
#define mp(x,y) make_pair(x,y)
#define se second
#define fi first
using PII=pair<int,int>;
using PIB=pair<int,bool>;
using PBI=pair<bool,int>;
using PBB=pair<bool,bool>;
using PDI=pair<double,int>;
using PID=pair<int,double>;

const int mod=1e9+7;
namespace Memory_Love{
	int read(){ int x=0; bool flag=1; char ch=getchar();
		while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
		while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();} return flag? x:-x;}
	template<typename T> void read(T &x){ bool flag=1; x=0; char ch=getchar();
		while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
		while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();} x=(flag? x:-x);}
	template<typename T,typename ...Args> void read(T &Re,Args &...Res){read(Re),read(Res...);}
	template<typename T> void write(T x,char ch=0){if(x<0) x=-x,putchar('-');
		static short s[35],top=-1; do{s[++top]=x%10;x/=10;}while(x);
		while(~top) putchar(s[top--]+48); if(ch) putchar(ch);}
	int gcd(int a,int b){return b==0? a:gcd(b,a%b);}
	int lcm(int a,int b){return a/gcd(a,b)*b;}
	int lowbit(int x){return (x&-x);}
	void MADD(int &x,int y,int mod){x=(x+y>=mod? x+y-mod:x+y);}
	int ksc(int a,int b,int p){int ans=0;while(b){if(b&1)MADD(ans,a,p);MADD(a,a,p);b>>=1;}return ans;}
	int ksm(int a,int b,int p){int ans=1%p;while(b){if(b&1)ans=ans*a%p;a=a*a%p;b>>=1;}return ans;}
	int exgcd(int a,int b,int &x,int &y){if(b==0){x=1,y=0;return a;}int d=exgcd(b,a%b,y,x);y-=a/b*x;return d;}
	int inv(int t){int x,y;exgcd(t,mod,x,y);return (x%mod+mod)%mod;}
} using namespace Memory_Love;
const int N=1e3+5;
const int M=30;
const int inv2=inv(2);
int n,m,Wrong;
int a[N][N];
int dp[N][N];
int Arrive[N][N];

int P(int i,int j,int x){return (x==1? dp[i][j]:(Arrive[i][j]-dp[i][j]));}
int DP(int k)
{
	int i,j;
	memset(dp,0,sizeof(dp));
	dp[1][1]=(a[1][1]>>k&1);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			int x=(a[i][j]>>k&1);
			if(i!=1 || j!=1)
			dp[i][j]=(P(i-1,j,x^1)+P(i,j-1,x^1))*inv2%mod;
		}
	}
	return dp[n][m];
}

bool Ending;
signed main()
{
	int i,j,ans=0;
	read(n,m,Wrong);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		a[i][j]=read();
	}
	
	Arrive[1][1]=1;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			if(i!=1 || j!=1)
			Arrive[i][j]=(Arrive[i-1][j]+Arrive[i][j-1])*inv2%mod;
		}
	}
	(ans+=(1-Arrive[n][m])*Wrong)%=mod;
	
	for(i=0;i<=M;i++)
	(ans+=(1<<i)*DP(i))%=mod;
	
	write((ans+mod)%mod,'\n');
	
	
	cerr<<"\nused:"<<(abs(&Ending-&Beginning)/1048576)<<"MB\n";
	return 0;
}
```

---

## 作者：Nygglatho (赞：0)

DP。

令：$f(i,j,k)$ 表示走到 $(i,j)$，并且走到这里时点权异或和的二进制第 $k$ 位为 $1$ 的概率，$g(i,j)$ 表示走到 $(i,j)$ 的概率。

则 $g(i,j)$ 可以对 $g(i+1,j)$ 和 $g(i,j+1)$ 分别产生 $\dfrac{1}{2}\cdot g(i,j)$ 的贡献，即转移过程中有：

- $g(i+1,j)\gets g(i+1,j)+\dfrac{1}{2}\cdot g(i,j)$；
- $g(i,j+1)\gets g(i,j+1)+\dfrac{1}{2}\cdot g(i,j)$；
- 初始 $g(1,1)=1$。

而对于 $f(i,j,k)$ 转移到 $f(i+1,j,k)$ 和 $f(i,j+1,k)$ 的过程，需要分类讨论，以 $f(i,j,k)$ 转移到 $f(i+1,j,k)$ 为例，有：

- 当 $a_{i+1,j}$ 二进制第 $k$ 位为 $1$ 时：走到 $(i+1,j)$ 时点权异或和的二进制第 $k$ 位为 $1$ 的条件显然是走到 $(i,j)$ 异或和的二进制第 $k$ 位为 $0$。而走到 $(i,j)$ 且第 $k$ 位为 $0$ 的概率为走到 $(i,j)$ 的概率减走到 $(i,j)$ 且第 $k$ 位为 $1$ 的概率，即 $g(i,j)-f(i,j,k)$。同样，由于存在向右和向下两种方案，对 $f(i+1,j,k)$ 贡献为 $\dfrac{1}{2}\cdot (g(i,j)-f(i,j,k))$，即 $f(i+1,j,k)\gets f(i+1,j,k)+\dfrac{1}{2}\cdot(g(i,j)-f(i,j,k))$。
- 当 $a_{i+1,j}$ 二进制第 $k$ 位为 $0$ 时，同理如果走到 $(i+1,j)$ 异或和第 $k$ 位为 $1$ 则需要走到 $(i,j)$ 时异或和第 $k$ 位为 $0$，概率 $f(i,j,k)$，对 $f(i+1,j,k)$ 贡献为 $\dfrac{1}{2}\cdot f(i,j,k)$。即 $f(i+1,j,k)\gets f(i+1,j,k)+\dfrac{1}{2}\cdot f(i,j,k)$。

$f(i,j,k)$ 转移到 $f(i,j+1,k)$ 同理。

---

那么相当于有 $f(n,m,k)$ 的概率会对最终答案贡献 $2^k$，同时有 $1-g(n,m)$ 的概率撞墙，对答案贡献 $x$，因此答案为 $(\sum\limits_{k\ge 0}f(n,m,k)\cdot 2^k)+(1-g(n,m))\cdot x$。时间复杂度 $O(nm\log V)$。

```cpp
namespace Maths {
    ll fac[560000];

    void init() {

        fac[0] = 1ll;

        F(i, 1, 500000) fac[i] = fac[i - 1] * i % mod;
    }

    ll qpow(ll x, ll y) {
        if (y == 0ll) return 1ll;

        ll w = qpow(x, y / 2ll);

        if (y % 2ll) return (w * w % mod) * x % mod;
        else return w * w % mod;
    }

    inline ll C(ll x, ll y) {
        return (fac[x] * qpow(fac[y], mod - 2ll) % mod) * qpow(fac[x - y], mod - 2ll) % mod;
    }

    inline ll div(ll x) {
        return qpow(x, mod - 2ll);
    }
}

ll f[2][1200][31], g[2][1200];

int a[1200][1200];
const ll i2 = Maths::div (2);
int main() {
    IOS
    int n, m, x;
    cin >> n >> m >> x;
    F (i, 1, n) F (j, 1, m) cin >> a[i][j];

    F (k, 0, 30) {
        f[1][1][k] = (a[1][1] & (1 << k) ? 1 : 0);
    }

    g[1][1] = 1ll;

    F (i, 1, n) {
        F (j, 1, m) {
            g[(i + 1) & 1][j] = 0ll;
            F (k, 0, 30) f[(i + 1) & 1][j][k] = 0ll;
        }
        F (j, 1, m) {
            (g[(i + 1) & 1][j] += g[i & 1][j] * i2) %= mod;
            (g[i & 1][j + 1] += g[i & 1][j] * i2) %= mod;
            F (k, 0, 30) {
                if (a[i][j + 1] & (1 << k)) {
                    ll _t = (mod + g[i & 1][j] - f[i & 1][j][k]) % mod;
                    (f[i & 1][j + 1][k] += _t * i2) %= mod;
                } else {
                    (f[i & 1][j + 1][k] += f[i & 1][j][k] * i2) %= mod;
                }
                if (a[i + 1][j] & (1 << k)) {
                    ll _t = (mod + g[i & 1][j] - f[i & 1][j][k]) % mod;
                    (f[(i + 1) & 1][j][k] += _t * i2) %= mod;
                } else {
                    (f[(i + 1) & 1][j][k] += f[i & 1][j][k] * i2) %= mod;
                }
            }
        }
    }
    ll ans = 0ll;
    F (k, 0, 30) {
        (ans += f[n & 1][m][k] * Maths::qpow (2ll, k) % mod) %= mod;
    }
    ans += (mod + 1 - g[n & 1][m]) * x % mod;
    ans %= mod;
    cout << ans;
}
```

---

## 作者：RandomLife (赞：0)

因为机器人一旦撞墙就立刻结束移动，所以可以稍微改变一下题目：让机器人走 $n+m-2$ 步，走完后如果在网格外就返回 $x$，否则返回路径上的异或和。

发现求期望，而走 $n+m-2$ 步每次都可以往右或往下，共有 $2^{n+m-2}$ 种走法，于是求出所有情况下的返回值之和 $ans$ 除以总方案数即可。

考虑将答案分成撞墙的情况和不撞墙的情况：

对于撞墙的情况，可以进行 dp，令 $f_{i,j}$ 表示走到 $(i,j)$ 的方案数，有 $f_{i,j}=f_{i-1,j}+f_{i,j-1}$。显然，撞墙的方案数等于总方案数减去不撞墙的方案数，而对于每种情况都会对答案产生 $x$ 的贡献，于是总贡献是 $(2^{n+m-2}-f_{n,m})\times x$。

对于不撞墙的情况，发现求异或和，于是果断拆位。对于每一位，令在第 $k$ 位下求出的答案为 $p_k$，则 $ans=\sum 2^k\cdot p_k$。我们针对任意一位进行考虑：

设 $b_{i,j}$ 是 $a_{i,j}$ 二进制意义下的第 $k$ 位，$g_{i,j}$ 表示所有方案下路径异或和第 $k$ 位为 $1$ 的方案数。那么：

- 当 $b_{i,j}=1$ 时，可以先计算到 $(i,j)$ 方案数为 $0$ 的方案数，再由总方案数减去它。而到当前位置为 $0$ 就相当于到前一个位置为 $1$，于是有 $g_{i,j}=f_{i,j}-g_{i-1,j}-g_{i,j-1}$。

- 当 $b_{i,j}=0$ 时，到前一位的异或和要为 $1$，于是有 $g_{i,j}=g_{i-1,j}+g_{i,j-1}$。

然后有 $p_k=g_{n,m}$。将所有答案累加起来再除以 $2^{n+m-1}$ 即可。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e3+5,mod=1e9+7,P=500000004;
int n,m;
ll a[N][N],x,f[N][N],g[N][N],ans=0,p2[N<<1];
int main(){
	f[1][1]=1,p2[0]=1;
	scanf("%d%d%lld",&n,&m,&x);
	for(int i=1;i<=n+m;++i)p2[i]=p2[i-1]*P%mod;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)scanf("%lld",&a[i][j]);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			if(i!=1||j!=1)f[i][j]=(f[i-1][j]+f[i][j-1])%mod;
	for(int k=0;k<=30;++k){
		g[1][1]=(a[1][1]>>k)&1;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				if(i!=1||j!=1)
					if(a[i][j]&(1<<k))g[i][j]=(f[i][j]-g[i-1][j]-g[i][j-1]+mod*2)%mod;
					else g[i][j]=(g[i-1][j]+g[i][j-1])%mod;
		ans=(ans+g[n][m]*(1<<k)%mod)%mod;
	}
	ll p=1;
	for(int i=1;i<=n+m-2;++i)p=p*2%mod;
	ans=(ans+(p-f[n][m]+mod)*x%mod)%mod;
	printf("%lld",ans*p2[n+m-2]%mod);
	return 0;
}
```

---


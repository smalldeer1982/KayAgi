# [蓝桥杯 2024 省 A] 成绩统计

## 题目描述

小蓝的班上有 $n$ 个人，一次考试之后小蓝想统计同学们的成绩，第 $i$ 名同学的成绩为 $a_i$。当小蓝统计完前 $x$ 名同学的成绩后，他可以从 $1 \sim x$ 中选出任意 $k$ 名同学的成绩，计算出这 $k$ 个成绩的方差。小蓝至少要检查多少个人的成
绩，才有可能选出 $k$ 名同学，他们的方差小于一个给定的值 $T$？
提示：$k$ 个数 $v_1, v_2, \cdots , v_k$ 的方差 $\sigma^2$ 定义为：$\sigma^2=\dfrac  {\sum_{i=1}^k(v_i-\bar v)^2} k$，其中 $\bar v$ 表示
$v_i$ 的平均值，$\bar v = \dfrac {\sum_{i=1}^k v_i} k$。

## 说明/提示

检查完前三名同学的成绩后，只能选出 $3, 2, 5 $，方差为 $1.56 $；

检查完前四名同学的成绩后，可以选出 $3, 2, 2 $，方差为 $0.22 < 1 $，所以答案为 $4 $。

对于 $10\%$ 的评测用例，保证 $1 ≤ n, k ≤ 10^2$；  
对于 $30\%$ 的评测用例，保证 $1 ≤ n, k ≤ 10^3$ ；  
对于所有评测用例，保证 $1 ≤ n, k ≤ 10^5 $，$1 ≤ T ≤ 2
^{31} -1 $，$1 ≤ a_i ≤ n $。

## 样例 #1

### 输入

```
5 3 1
3 2 5 2 3```

### 输出

```
4```

# 题解

## 作者：xy_mc (赞：15)

大家做题之前应该都会看标签吧（逃

看了标签的都知道，这题要略微运用一点数学知识

### 思路：

首先想到的思路便是挨个枚举，但是这种思路明显超时（一个绿怎么可能这么简单）。

其次想到的就是前缀和了，但是写着写着会发现问题，那么就要把公式 $ \sigma^2 = \dfrac {\sum_{i=1}^k\left(v_i-\bar v \right)^2} k$ 变一变。

发现有两数差的平方，这时就应想到完全平方公式 $(a-b)^2=a^2-2ab+b^2$ 了，拆完后应为：

$$\sigma^2=\dfrac  {\sum_{i=1}^k \left(v_i^2-2v_i\bar v+\bar v^2 \right)} k$$

可这个式子看起来还是不够可爱，所以继续拆：

$$\sigma^2=\dfrac  {\sum_{i=1}^kv_i^2 - \sum_{i=1}^k2v_i\bar v + k\bar v^2} k$$

这样就可爱多了，平方和可以用前缀和得出，但是 $k$ 个数的平均值会变，每次都重新处理显然不符合我这种懒癌患者的性子，那该怎么办呢？

回顾一下这句话：其中 $\bar v$ 表示 $v_i$ 的平均值，$\bar v = \dfrac {\sum_{i=1}^k v_i} k$，平均值不好求，但是 $k$ 个数的和我们可以用前缀和啊，那么式子就变成这样：

$$\sigma^2=\dfrac  {\sum_{i=1}^kv_i^2 - \sum_{i=1}^k2v_i\dfrac {\sum_{i=1}^k v_i} k + k \left( \dfrac {\sum_{i=1}^kv_i} {k}\right)^2} k $$

得到了这个可爱的式子~~明明就是一坨~~，就可以继续往下进行了。

---

题目让我们求小蓝至少要检查多少个人的成绩，才有可能选出 $k$ 名同学，一个一个判断显然太慢，这时候就需要二分答案了，二分至少要检查多少人。既然要选出 $k$ 名同学，则至少要从 $k$ 个人里选；最多则是 $n$ 名。左右端点就出来了。

---

接下来就要写 check 函数了，首先我们需要另开一个数组，将原数组里的数据导过来（不能修改原数组，不然会导致后面的处理出现错误）。

既然题里让方差小于 $T$，那么我们就要使方差尽可能小，要让数据的波动程度尽可能小，所以要将另开的数组排序（不知道为什么的请学习八上数学）。

接下来我们就要用上面的式子求前缀和了，然后找一找最小的方差就行了。

### 温馨提示：
- 求区间和时，千万不要 $-1$，不然会使元素个数多出来一个，就错了（本蒟蒻在这上面卡了好久）。
  
### code:
```cpp
#include<bits/stdc++.h>
#define inl inline
#define reg register
#define int long long
#define fst ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define rep(i,x,y) for(reg int i=x;i<=(y);++i)
#define per(i,x,y) for(reg int i=x;i>=(y);--i)
using namespace std;
const int N=1e5+5;
int n,k,t,a[N],sum_s[N],sum[N],v[N];
bool check(int x){
	rep(i,1,x) v[i]=a[i];
	sort(v+1,v+x+1);
	rep(i,1,x){
		sum_s[i]=sum_s[i-1]+v[i]*v[i];
		sum[i]=sum[i-1]+v[i];
	}
	double ans=DBL_MAX;
	rep(i,k,x){
		double sum1=sum_s[i]-sum_s[i-k];
		double sum2=2*(1.0*sum[i]-sum[i-k])*((1.0*sum[i]-sum[i-k])/k);
		double sum3=((1.0*sum[i]-sum[i-k])/k)*((1.0*sum[i]-sum[i-k])/k)*k;
		ans=min(ans,(sum1-sum2+sum3)/k);
	}	
	return ans<t;
}
signed main(){
	fst;
	cin>>n>>k>>t;
	rep(i,1,n){
		cin>>a[i];
	}
	int l=k,r=n,ans=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)){
			r=mid-1;
			ans=mid;
		}else{
			l=mid+1;
		}
	}
	cout<<ans;
	return 0;
}
```
[Link](https://www.luogu.com.cn/record/200569466)

---

## 作者：mathcode (赞：9)

[成绩统计](https://www.luogu.com.cn/problem/P10389) 现在看看，当时打蓝桥杯的时候真不应该做不出来，完全不难的一个小题。不会拆式子，或者说没有想到拆式子（没做过类似题，或者说做过但是忘记了）。

思路：二分答案位置，然后将该位置前的数组排序（这应该是很明显的，排序后相邻的 $k$ 个数方差明显更优），然后遍历一遍，每次 $O(1)$ 计算新的方差。

然后问题的关键在于怎么 $O(1)$ 的计算方差。拆分方差的计算公式：

![a8cdf7a3d1d4f59399cf3286e569895.png](https://s2.loli.net/2024/05/02/O4DPgt5xb7NM8z9.png)

对于 $\sum v_{i}^{2}$ 可以预处理前缀平方和 $O(1)$ 得到，对于 $\sum v_{i}$ 也是可以预处理前缀和 $O(1)$ 得到。 那么 $\bar v$ 相信不需要我说大家也是可以 $O(1)$ 处理出来的。最后取最小的方差即可。

附上正确代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define inf 0x3f3f3f3f
#define db double
#define il inline
#define x first
#define y second
#define endl '\n'
const int N=2e5+5;
const int mod=998244353;
int n,k,t;
int s[N],qsum[N],qpf[N],a[N];
int check(int mid)
{
    for(int i=1;i<=mid;i++) a[i]=s[i];
    sort(a+1,a+mid+1);
    qsum[0]=0,qpf[0]=0;
    for(int i=1;i<=mid;i++) qsum[i]=qsum[i-1]+a[i];
    for(int i=1;i<=mid;i++) qpf[i]=qpf[i-1]+a[i]*a[i];

    db jun=0,fc=0;
    for(int i=1;i<=k;i++) jun+=(db)a[i]/k;
    fc=(db)(qpf[k]-(db)2*jun*qsum[k]+(db)k*jun*jun)/k;
    for(int i=k+1;i<=mid;i++)
    {
        jun=jun-(db)a[i-k]/k+(db)a[i]/k;
        fc=min(fc,(db)(qpf[i]-qpf[i-k]-2*jun*(qsum[i]-qsum[i-k])+k*jun*jun)/k);
    }
    if(fc<t) return 1;
    else return 0;
}
void solve()
{
    cin>>n>>k>>t;
    for(int i=1;i<=n;i++) cin>>s[i];
    int l=k,r=n,ans=inf;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(check(mid)) ans=min(ans,mid),r=mid-1;
        else l=mid+1;
    }
    if(ans>inf/2) cout<<-1<<endl;
    else cout<<ans<<endl;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int T=1;//cin>>T;
    while(T--){
        solve();
    }
    return 0;
}
```

---

## 作者：zhhgdm (赞：6)

扫一眼题目便知，这是一道~~我最不擅长的~~数学题。

仔细观察

$$
\sigma^2=\dfrac  {\sum_{i=1}^k(v_i-\bar v)^2} k
$$

便知道，既然要最小化它，那必然要使 $\lvert v_i-\bar v \rvert$ 尽可能小，也就是让每个数离平均值尽量近，也就是每个数尽量接近。那么对于一个有序数列，要选 $k$ 个数使他们最接近，一定会选 $[1,k]$、$[2,k+1]$ 这些区间。

然而，我们连数列是什么都不知道，怎么办？二分啊！二分什么呢？二分 $x$，这样就可以知道数列是谁了。

现在，我们有一种做法，二分 $x$，再对 $1 ∼ x$ 排序，再遍历区间的结束节点（开始节点也行），再遍历区间，计算方差，判断以所有节点为结束节点的最小方差是否小于 $T$。

然而 $O(nk \log(n))$ 的时间复杂度只能那 $40$ 分，我们需要优化。很容易想到前缀和，但是 $\bar v$ 会变，怎么办呢？可以把

$$
\sigma^2=\dfrac  {\sum_{i=1}^k(v_i-\bar v)^2} k
$$

根据完全平方差公式变成

$$
\sigma^2=\dfrac  {k\times \bar v+\sum_{i=1}^k v_i^2- \sum_{i=1}^k 2 \times v_i \times \bar v} {k}
$$

$v_i^2$ 可以前缀和，但 $2 \times v_i \times \bar v$ 和 $\bar v$ 不行，怎么办？可以让 $\bar v$ 变成 $\dfrac  {\sum_{i=1}^k v_i} k$。$2 \times v_i \times \bar v$ 就变成了 $2 \times v_i \times \dfrac  {\sum_{i=1}^k v_i} k$。最终得到
$$
\sigma^2=\dfrac  {k\times \dfrac  {\sum_{i=1}^k v_i} k+\sum_{i=1}^k v_i^2- \sum_{i=1}^k 2 \times v_i \times \dfrac  {\sum_{i=1}^k v_i} k} {k}
$$

把 $v_i$ 的前缀和记为 $sum_i$，$v_i^2$ 的前缀和记为 $sum2_i$，那么可以得到方差 $O(1)$ 的计算方法：

$$
\sigma^2=\dfrac  {sum_k+sum2_k-2 \times sum_k \times \dfrac  {sum_k} k} k
$$

# 完整代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long a[100005];
long long b[100005];
long long sum[100005];
long long sum2[100005];
long long n,k,T;
bool check(int x){
    for(int i=1;i<=x;i++){
        b[i]=a[i];
    }
    sort(b+1,b+x+1);
    for(int i=1;i<=x;i++){
        sum[i]=sum[i-1]+b[i];
        sum2[i]=sum2[i-1]+b[i]*b[i];
    }
    double ans=1e300;
    for(int i=k;i<=x;i++){
        ans=min(ans,((sum2[i]-sum2[i-k])+
        ((1.0*sum[i]-sum[i-k])/k)*((1.0*sum[i]-sum[i-k])/k)*k-
        2*(1.0*sum[i]-sum[i-k])*(1.0*sum[i]-sum[i-k])/k)/k);
    }
    return ans<T;
}
int main(){
    cin>>n>>k>>T;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int l=k,r=n,ans=-1;
    while(l<=r){
        int mid=l+(r-l)/2;
        if(check(mid)){
            ans=mid;
            r=mid-1;
        }
        else{
            l=mid+1;
        }
    }
    cout<<ans;
    return 0;
}

```
十年 OI 一场空，不开 `long long` 见祖宗。

---

## 作者：LittleDrinks (赞：2)

## [P10389 [蓝桥杯 2024 省 A] 成绩统计](https://www.luogu.com.cn/problem/P10389)

提供一种规避浮点数运算的做法。

$$
\begin{align}
&\sigma^2=\dfrac{\sum_{i=1}^k(v_i-\bar{v})^2}{k}\leq T\\
\Leftrightarrow & \sum_{i=1}^k(v_i-\bar{v})^2\leq kT \\
\Leftrightarrow & \sum_{i=1}^k(v_i^2)-2\bar{v}\sum_{i=1}^k(v_i)+\bar{v}^2\leq kT\\
\Leftrightarrow & k\sum_{i=1}^k(v_i^2)-(\sum_{i=1}^k(v_i))^2\leq k^2T\\
\end{align}
$$

二分区间长度，$O(n)$ 处理 $\sum_{i=1}^k(v_i^2)$ 和 $\sum_{i=1}^k(v_i)$，检查是否满足 $k\sum_{i=1}^k(v_i^2)-(\sum_{i=1}^k(v_i))^2\leq k^2T$。

注意，这种写法虽然能规避浮点数运算带来的精度误差，但会爆 `long long`，需要 `__int128`。

#### [AC 代码]()

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long double db;
typedef long long ll;

int main()
{
    int n; ll k, t;
    cin >> n >> k >> t;
    vector<ll> a(n);
    for (auto &x: a) { cin >> x; }
    auto check = [&](int len){
        vector<ll> b(len);
        copy(a.begin(), a.begin()+len, b.begin());
        sort(b.begin(), b.end());
        __int128 s=0, s2=0;
        for (int r = 0; r < len; ++r) {
            int l = r-k+1;
            s += b[r];
            s2 += b[r]*b[r];
            if (l > 0) {
                s -= b[l-1];
                s2 -= b[l-1]*b[l-1];
            }
            if (l >= 0 && k*s2 - s*s <= (__int128)(k)*k*t) {
                return true;
            }
        }
        return false;
    };
    int l = k-1, r = n+1, mid;
    while (l < r-1) {
        mid = l + ((r - l) >> 1);
        if (check(mid)) { r = mid; }
        else { l = mid; }
    }
    if (r == n+1) { cout << "-1\n"; }
    else { cout << r << "\n"; }
}
```

---

## 作者：zhuweiqi (赞：2)

二分答案。

对于前 $mid$ 个数，要知道从中选出 $k$ 个数的最小方差，显然需要先将其从小到大排序，每次从中连续地取出 $k$ 个数，然后再看其方差。

通过推导公式得：

$${\sum\limits_{i=1}^k(v_i-\bar v)^2}$$

$$={\sum\limits_{i=1}^k(v_i^2-2v_i\bar v+\bar v^2)}$$

$$={\sum\limits_{i=1}^kv_i^2-2\bar v\sum\limits_{i=1}^kv_i+k\bar v^2}$$

其中 $v_i$ 的和以及平方和可以用单调队列的形式维护，$\bar v$ 则可以通过已知条件计算得到，这样我们就能用线性的时间复杂度快速求出方差了。

综上，时间复杂度为 $O(n\log n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int k,T;
int a[100002];
ll b[100002];
bool check(int n){
	for(int i=1;i<=n;i++) b[i]=a[i];
	sort(b+1,b+1+n);
	ll vi2=0,vi=0;
	double avev;
	for(int i=1;i<k;i++) vi2+=b[i]*b[i],vi+=b[i];
	for(int i=k;i<=n;i++){
		vi2-=b[i-k]*b[i-k],vi-=b[i-k];
		vi2+=b[i]*b[i],vi+=b[i];
		avev=vi*1.0/k;
		if((vi2-2*avev*vi+k*avev*avev)/k<=T) return 1;
	}
	return 0;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n;
	cin>>n>>k>>T;
	for(int i=1;i<=n;i++) cin>>a[i]; 
	if(!check(n)){
		cout<<-1;
		return 0;
	}
	int l=k,r=n,mid;
	while(l<r){
		mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：1)

题目要求求最小值，那么最先想到二分。

在二分时，先对整个数组排序，显然要使答案最优，一定要选连续的 $k$ 个数，枚举这些数即可。

把题目中的原式拆出来可以得到：
$$\sigma^2=\dfrac{\sum_{i=1}^kv_i^2-\sum_{i=1}^k2v_i\bar v+k\bar v^2}k$$

因此我们可以维护 $v_i$ 的前缀和以及 $v_i^2$ 的前缀和，同时 $\bar v$ 也可以通过 $v_i$ 的前缀和计算得出，所以我们可以在 $O(1)$ 的时间里求出连续的 $k$ 个数的方差的值。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005],b[100005];
int fr1[100005],fr2[100005];
double fr3[100005],fr4[100005];
int n,k,t;
bool check(int x)
{
	for(int i=1;i<=x;i++) b[i]=a[i];
	sort(b+1,b+x+1);
	for(int i=1;i<=x;i++) fr1[i]=fr1[i-1]+b[i];
	for(int i=1;i<=x;i++) fr2[i]=fr2[i-1]+b[i]*b[i];
	for(int i=k;i<=x;i++)
	{
		double num1=(fr1[i]-fr1[i-k])*1.0/k;
		if(fr2[i]-fr2[i-k]-2*num1*(fr1[i]-fr1[i-k])+num1*num1*k<t*k) return true;
	}
	return false;
}
signed main()
{
	cin>>n>>k>>t;
	for(int i=1;i<=n;i++) cin>>a[i];
	int l=k,r=n,ans;
	if(!check(n))
	{
		cout<<-1;
		return 0;
	}
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid)) r=mid-1,ans=mid;
		else l=mid+1;
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：MaiJingYao666 (赞：1)

# P10389 [蓝桥杯 2024 省 A] 成绩统计  题解  
新型方差。  
### 解题思路  
看见方差这么大一段式子，看着就头疼。不妨把它拆开。我们设求的是区间 $[x,x+k-1]$ 的方差，首先考虑 $(v_i-\bar v)^2=v_i^2+\bar v^2-2v_i\bar v$，那么很显然有：
$$\sum_{i=x}^{x+k-1} (v_i-\bar v)^2=\sum_{i=x}^{x+k-1} v_i^2+k\bar v+2\times\bar v\times\sum_{i=x}^{x+k-1} v_i$$  
其中 $\bar v=\frac{\sum_{i=x}^{x+k-1}v_i}{k}$，带入可得：
$$\sum_{i=x}^{x+k-1} (v_i-\bar v)^2=\sum_{i=x}^{x+k-1} v_i^2+\sum_{i=x}^{x+k-1}v_i+2\times\frac{(\sum_{i=x}^{x+k-1}v_i)^2}{k}$$  
我们令 $f_1=\sum_{i=x}^{x+k-1} v_i^2$，$f_2=\sum_{i=x}^{x+k-1}v_i$，原式为：
$$
f_1+f_2+\frac{f_2^2}{k}
$$  
是不是就很工整了。  
$$
\sigma^2=\frac{f_1+f_2+\frac{f_2^2}{k}}{k}
$$
****
很显然求前缀的数的话答案不降，所以二分答案。至于检查函数，很显然我们可以将这个前缀排序，要选择的数一定是连续的 $k$ 个数，考虑到方差检验数据稳定性证明略（这不废话吗）。那么可以很简单得将连续的 $f_1$ 和 $f_2$ 推出来，前缀和？可能算是吧。算法时间复杂度 $O(n\log^2 n)$，瓶颈在排序。  
### AC 代码  
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e5+5;
int n,k,T;
int v[N];
double a[N];
inline bool check(int p){
    for(int i=1;i<=p;i++) a[i]=v[i];
    sort(a+1,a+p+1);
 
    double f1=0,f2=0;
    for(int i=1;i<=k;i++){
        f1+=a[i]*a[i];
        f2+=a[i];
    }
    for(int i=1;i+k-1<=p;i++){
        if((f1-2*f2/k*f2+k*(f2/k)*(f2/k))/k<T) return true;
        f1=f1-a[i]*a[i]+a[i+k]*a[i+k];
        f2=f2-a[i]+a[i+k];
    }
    return false;
}
int main(){
    scanf("%d%d%d",&n,&k,&T);
    for(int i=1;i<=n;i++){
        scanf("%d",v+i);
    }
    int l=k,r=n+1;
    while(l<r){
        int mid=l+r>>1;
        if(check(mid)) r=mid;
        else l=mid+1;
    }
    if(l==n+1) printf("-1");
    else printf("%d",l);
}
```

---

## 作者：lam_dyr (赞：1)

## 题意

找到最小的 $x$，使得从前 $x$ 个学生的成绩中，可以选择 $k$ 个学生的成绩，它们的方差小于 $T$。

## 思路

由题可知，方差的定义：

$$
\sigma^2 = \frac{\sum_{i=1}^k (v_i - \bar{v})^2}{k},
$$

其中 $\bar{v} = \frac{\sum_{i=1}^k v_i}{k}$ 是 $k$ 个数的平均值。

等价地，可以改写方差为：

$$
\sigma^2 = \frac{\sum_{i=1}^k v_i^2}{k} - \left(\frac{\sum_{i=1}^k v_i}{k}\right)^2.
$$

为了计算 $\sigma^2$，我们需要两项：

1. $\text{sum} = \sum_{i=1}^k v_i$，即 $k$ 个数的和；
2. $\text{sum2} = \sum_{i=1}^k v_i^2$，即 $k$ 个数的平方和。

这两项都可以预处理后 $O(1)$ 的求。

为了使得选出的 $k$ 个数的方差最小，我们应该选取尽可能接近的数值。因此，将 $x$ 名同学的成绩排序后，从中选择连续的 $k$ 个数可以使方差最小。

---

如何找到最小的 $x$ 呢？

由于我们已经排过序，在有序数组中可以考虑二分答案。
check 时检查所有长度为 $k$ 的子数组是否存在一个方差小于 $T$ 的就行。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k;
double t;
int sco[100005];
bool check(int x){
    if(x<k)return false;
    int sub[100005];
    for(int i=1;i<=x;++i)
        sub[i]=sco[i];
    sort(sub+1,sub+x+1);
    long long sum=0,sum2=0;
    for(int i=1;i<=k;++i){
        sum+=sub[i];
        sum2+=1LL*sub[i]*sub[i];
    }
    double var=(sum2/(double)k)-pow((sum/(double)k),2);
    if(var<=t)return true;
    for(int i=k+1;i<=x;++i){
        sum-=sub[i-k];
        sum2-=1LL*sub[i-k]*sub[i-k];
        sum+=sub[i];
        sum2+=1LL*sub[i]*sub[i];
        var=(sum2/(double)k)-pow((sum/(double)k),2);
        if(var<=t)return true;
    }
    return false;
}
int main(){
    cin>>n>>k>>t;
    for(int i=1;i<=n;++i)
        cin>>sco[i];
    int l=k,r=n,res=-1;
    while(l<=r){
        int mid=(l+r)/2;
        if(check(mid)){
            res=mid;
            r=mid-1;
        }
		else
            l=mid+1;
    }
    cout<<res;
    return 0;
}
```

---


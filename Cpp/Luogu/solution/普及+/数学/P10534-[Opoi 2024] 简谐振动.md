# [Opoi 2024] 简谐振动

## 题目背景

你说得对，但是简谐振动十分优美。

![pic](https://ts1.cn.mm.bing.net/th?id=OIP-C.uGsZxikgYriy7OYxJsbm0AHaD1&w=174&h=150&c=8&rs=1&qlt=90&o=6&pid=3.1&rm=2)

![cip](https://tse4-mm.cn.bing.net/th/id/OIP-C.yNecd9xmljOtND3V6b4gcAHaEW?w=278&h=180&c=7&r=0&o=5&pid=1.7)

![jzp](https://tse2-mm.cn.bing.net/th/id/OIP-C.GSxOJQ3KlXRC9V_y_crpigHaFj?w=230&h=180&c=7&r=0&o=5&pid=1.7)

但是我们不出多边形下海，所以你不需要维护一个质点的简谐振动。

## 题目描述

已知一个数字串 $S$，请你判断是否存在一种长度为 $n$ **且 $n$ 为奇数**的整数序列 $A_i$，使得 $A_1+A_2,A_2+A_3,\dots,A_{n-1}+A_n,A_n+A_1$ 的值按顺序依次拼接起来可以得到 $S$。

特别的，如果存在一种方案使得拼接的时候两项中间用 $[0,\infty)$ 个 $0$ 分隔仍然可以得到 $S$，该方案仍然合法。**所有数据保证最前面没有前导 $0$。**

## 说明/提示

### 样例解释
第一组样例解释：

$\begin{matrix}
7&6&4\cr
+&+&+\cr
6&4&7\cr
||&||&||\cr
13&10&11\end{matrix}$

当然，你也可以说：

$\begin{matrix}
71&60&-60\cr
+&+&+\cr
60&-60&71\cr
||&||&||\cr
131&0&11\end{matrix}$

构造方法不唯一。

第二组样例解释：

如果有解，$A_1=2.5$，而题目说了 $A$ 为整数序列，故无解。

第三组样例解释：

$\begin{matrix}
1&&1&0\cr
+&&+&+\cr
1&&0&1\cr
||&&||&||\cr
2&0&1&1\end{matrix}$

> 该方案中间用了 $1 \in [0,\infty)$ 个 $0$ 分隔，符合要求，输出 `Yes`。

---
### 数据范围
对于 $50\%$ 的数据，$1\le T \le 10$，$1\le |S| \le 10$，$1 \le n \le 3$。

对于 $100\%$ 的数据，$1\le T \le 100$。保证 $\sum n\le 10^6$ 且 $\sum|S|\le 10^6$，${\tt 0} \le S_i \le {\tt 9}$，**且 $n$ 为奇数**。

## 样例 #1

### 输入

```
3
3
131011
1
5
3
2011
```

### 输出

```
Yes
No
Yes```

# 题解

## 作者：封禁用户 (赞：5)

# 思路
$$\begin{aligned}\because&\frac{(A_1+A_2)+(A_2+A_3)+\dots+(A_{n-1}+A_n)+(A_n+A_1)}{2}\\
&=A_1+A_2+A_3+\dots+A_{n-1}+A_n\end{aligned}\\
\because n \bmod 2 = 1\\
\begin{aligned}&\therefore A_x=(A_1+A_2+A_3+\dots+A_{n-1}+A_n)-\\
&\begin{cases}
[(A_1+A_2)+\dots+(A_{x-2}+A_{x-1})+(A_{x+1}+A_{x+2})+\dots+(A_{n-1}+A_n)]&x \bmod 2 = 1\\
[(A_2+A_3)+\dots+(A_{x-2}+A_{x-1})+(A_{x+1}+A_{x+2})+\dots+(A_{n-2}+A_{n-1})+(A_n+A_1)]&x \bmod 2 = 0\end{cases}\end{aligned}$$
只需要使 $(A_1+A_2)+(A_2+A_3)+\dots+(A_{n-1}+A_n)+(A_n+A_1)\bmod 2 = 0$ 即可，考虑将数字串划分分成 $n$ 个可以有前导 $0$ 的数字，使得末尾数字的和为偶数。

最后一位数字必选为末尾数字，剩下 $n-1$ 个自己选择，因此，只需要看是否有 $n-1$ 个不同的数字和最后一位数字的和为偶数即可。

**末尾为偶数**：判断是否可以从前面选出 $n-1$ 个数和为偶数即可。

**末尾为奇数**：先拿另一个奇数凑成偶数，再判断是否可以从其他数中选出 $n-2$ 个数和为偶数即可。
# code
写的有点复杂……
```cpp
#include<bits/stdc++.h>
using namespace std;
void ask(int od,int ev,int cnt){//判断od个奇数、ev个偶数中能否选cnt个数使得和为偶数
	if(od+ev<cnt){//个数都不够
		printf("No\n");
		return;
	}
	if(cnt%2==1){//奇数个，需要先拿一个偶数，避免下面使用奇数时会选出半个一对奇数导致结果为奇数
		if(!ev){//没有偶数
			printf("No\n");
			return;
		}
		cnt--;
		ev--;
	}
	cnt-=od/2*2;//每两个一对奇数
	if(cnt<=0){
		printf("Yes\n");
		return;
	}
	cnt-=ev;
	if(cnt<=0){
		printf("Yes\n");
		return;
	}
	printf("No\n");
}
int main(){
	int tc,n,od,ev;
	string s;
	scanf("%d",&tc);
	while(tc--){
		scanf("%d",&n);
		cin>>s;
		od=0;
		ev=0;
		for(int i=0;i<s.size()-1;i++)//统计奇数和偶数的数量
			if((s[i]-'0')%2==0)
				ev++;
			else
				od++;
		if((s[s.size()-1]-'0')%2==0)
			ask(od,ev,n-1);//末尾为偶数
		else{//末尾为奇数
			if(n==1){//特判：一个数字，但是是奇数
				printf("No\n");
				continue;
			}
			if(od==0){//特判没有奇数
				printf("No\n");
				continue;
			}
			od--;//先用一个奇数
			ask(od,ev,n-2);
		}
	}
	return 0;
}
```

---

## 作者：TLE_AK (赞：4)

### 题意

给一个字符串 $S$ 与一个数 $n$，求是否有长度为 $n$ 的**整数**数组 $A$，满足 $A_1+A_2,A_2+A_3,\dots,A_{n-1}+A_n,A_n+A_1$ 的值按顺序拼接可以得到 $S$，$n$ 为**奇数**。
## 思路
看到环，考虑一个不完全的断环为链，于是可以得出这样的柿子（$S_1，S_2$ 等为 $S$ 中分离的第 $i$ 个数）：

$\begin{cases}
A_1 + A_2 = S_1\\
A_2 + A_3 = S_2\\
\dots \\
A_n + A_{n+1} = S_n\\
A_1 = A_{n+1}
\end{cases}$

此时我们发现，$A_1$变大，则$A_2$则会变小（反之亦然），同时 $A_3$ 也会增大或变小，并且产生变化的数字都是相同的！  
因为 $A_1$ 变化后，$A_2$ 要使用他的相反数弥补（很容易证明其他的数也是如此），所以我们可以将这个变化给进行下去，发现 $A_i$ 的变化量与 $A_{n+1}$ 的变化量恰好是相反数（因为 $n$ 为奇数，所以 $n+1$ 一定为偶数）。

只要保证 $A_1,A_{n+1}$ 能同奇偶，就可以构造出来！  
又因为根据加法的奇偶性，若 $S_i$ 为奇数，$A_i,A_{i+1}$ 的奇偶不同，否则相同，又得出这样的柿子：

$S_1 \oplus S_2 \oplus S_3 \dots  \oplus S_n$

所以只要将所有 $S$ 中奇偶数个数，然后看能不能凑齐 $n$ 就可以了，但要注意如果结尾为奇数，必须加一个奇数抵消。

## 代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;

namespace acac
{
	char S[1000010];
	

	int main()
	{
		int t;
		scanf("%d",&t);
		
		while(t--)
		{
			int n;
			scanf("%d%s",&n,S+1);
			
			int len=strlen(S+1),js=0,os=0,tf=0;
			for(int i=len;i;i--)//计算奇数偶数个数
			{
				if((S[i]-'0')&1)js++;
				else os++;

			}
			if((n==1||js==1)&&(S[len]-'0')&1)//必须有一个奇数抵消另一个
			{
				cout<<"No\n";
				continue;
			}
			js/=2;
			js*=2;//单个不能用
			if(os&&js+os>=n)cout<<"Yes\n";//因为n为奇数，所以必须有个偶数
			else cout<<"No\n";
			
		}
	
		return 0;
	}
}


int main()
{
	acac::main();
	return 0;
}
~~~

---

## 作者：xyz105 (赞：2)

$$\begin{Bmatrix}\color{red}\LARGE\bold{Solution}\\\normalsize\texttt{No.009 }\bold{P10534}\end{Bmatrix}\times\footnotesize\texttt{ By Xyz105}$$


### 题目描述

已知一个数字串 $S$，请你判断是否存在一种长度为 $n$ **且 $n$ 为奇数**的整数序列 $A_i$，使得 $A_1+A_2,A_2+A_3,\dots,A_{n-1}+A_n,A_n+A_1$ 的值按顺序依次拼接起来可以得到 $S$。

特别的，如果存在一种方案使得拼接的时候两项中间用 $[0,\infty)$ 个 $0$ 分隔仍然可以得到 $S$，该方案仍然合法。**所有数据保证最前面没有前导 $0$。**


### 解题思路

不妨设分解 $S$ 所得出的数字分别为 $B_{1\ldots n}$。因为最前面是没有前导 $0$ 的，并且“两项中间用 $[0,\infty)$ 个 $0$ 分隔”说明非开头的数字可以有前导 $0$，所以实际上 $S$ 可以**任意分解**。

考虑用 $A_1$ 表示 $A_{2\ldots n}$，有

$$\begin{matrix}
A_1&B_1-A_1&B_2-B_1+A_1&\cdots&B_{n-1}-B_{n-2}+\cdots-B_1+A_1\cr
+&+&+&+&+\cr
B_1-A_1&B_2-B_1+A_1&B_3-B_2+B_1-A_1&\cdots&B_{n}-B_{n-1}+B_{n-2}-\cdots+B_1-A_1\cr
||&||&||&||&||\cr
B_1&B_2&B_3&\cdots&B_n\end{matrix}$$

首尾相加的特性使得 $B_{n}-B_{n-1}+B_{n-2}-\cdots+B_1-A_1=A_1$。

即 $2A_1=B_{n}-B_{n-1}+B_{n-2}-\cdots+B_1$，说明等号右边必须是偶数。

又因为对于任意正整数 $k$，都有 $k$ 与 $-k$ 奇偶性相同，所以转为判定 $B_{n}+B_{n-1}+B_{n-2}+\cdots+B_1$ 是偶数即可。

判断一个数是否为偶数，只需判断其个位即可。因此问题转化为 在 $S$ 中取 $n$ 个数（$S$ 的最后一位必须取）使得它们相加为偶数。

可以循环 $S$ 中每一位，记录奇数个数 $\text{odd}$、偶数个数 $\text{even}$。因为要保证“相加为偶数”，所以选取的奇数个数必须是偶数。因此记 $\text{odd}'$ 为不大于 $\text{odd}$ 的最大偶数，判断是否有 $\text{odd}'+\text{even}\ge n$ 即可。

注意细节：$S$ 的最后一位必须取。当 $S$ 的末位是奇数时，应有 $\text{odd}'>0$ 且 $n>1$ 才有可行方案。


### 参考代码

已经算较短了。

代码中 $\text{odd}$ 用 `i1` 表示，$\text{odd}'$ 体现为 `i1 / 2 * 2`。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int MAXN = 1e6 + 10;

int t, n, l, i1, i2; char s[MAXN];

int main()
{
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d%s", &n, s + 1), i1 = i2 = 0;
		for (int i = l = strlen(s + 1); i; i--) if (s[i] & 1) i1++; else i2++;
		puts(max(0, max(1, n - i1 / 2 * 2) - i2) || ((s[l] & 1) && (i1 == 1 || n == 1)) ? "No" : "Yes");
	}
	
	return 0;
}
```

---

## 作者：sbno333 (赞：2)

相对于另外几题是很好的题。

这里我们考虑这样的方法序列可以得到怎样的序列。

不妨设 $a_1=x$，则 $a_2=s_1-x$，以此类推。最终推得 $a_n=(\sum\limits_{i=1}^{n-1}s_i\times([2\mid i]\times2+1))+x$，最终由 $a_1=x=(\sum\limits_{i=1}^{n}s_i\times([2\nmid i]\times2+1))-x$。

于是 $(\sum\limits_{i=1}^{n}s_i\times([2\nmid i]\times2+1))$ 这一坨是偶数即可。

由于得到每个数都长度至少为 $1$，所以如果长度太短报告无解。

如果长度相同，显然一一对应，直接判断即可，这里注意的是，由于是判断奇偶性，所以 $+$ 和 $-$ 没有本质区别，可以减少代码细节。

如果长度较长，考虑划分。

每个数的奇偶性只与末尾相关，因此变成了 $S$ 中选若干**数字**使和为偶数，这里，要求选的最后一个数字为 $S$ 的末尾。

我们先选，接着分类讨论：

假设末尾为偶数，剩下的 $n$ 为偶数，则要求和为偶数，考虑都输偶数或奇数（偶数个奇数和为偶数）显然有解，考虑都有，我们先空余出一个奇数和偶数，剩下的乱选，然后剩一个，由于可以选奇数，也可以选偶数，因此也有解，考虑原来 $n=1$，显然有解。

假设末尾为奇数，则要求和为奇数，全是奇数或偶数不行，但如果都有就可以，$n=1$ 时显然无解。

于是代码出炉。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
void _main(){
	int n;
	cin>>n;
	string s;
	cin>>s;
	if(s.size()<n){
		cout<<"No"<<endl;
	}else if(s.size()==n){
		bool f;
		f=1;
		for(int i=0;i<s.size();i++){
			if(s[i]&1){
				f=!f;
			}
		}
		cout<<(f?"Yes":"No")<<endl;
	}else{
		if(s[s.size()-1]&1){
		    if(n==1){
		        cout<<"No"<<endl;
		        return;
		    }
			for(int i=1;i<s.size()-1;i++){
				if((s[i]&1)!=(s[i-1]&1)){
					cout<<"Yes"<<endl;
					return;
				}
			}
			cout<<"No"<<endl;
		}else{
			cout<<"Yes"<<endl;
		}
	}
}
signed main(){
	int t;
	cin>>t;
	while(t--){
		_main();
	}	
	return 0;
}
```

---


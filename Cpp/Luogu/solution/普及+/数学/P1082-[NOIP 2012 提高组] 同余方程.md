# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# 题解

## 作者：学委 (赞：1482)

*2020-02-27 更新*

一步一步来。

## 问题转化

题目问的是满足 $ax \mod b = 1$ 的最小正整数 $x$。（$a,b$是正整数）

但是不能暴力枚举 $x$，会超时。

把问题转化一下。观察 $ax \mod b = 1$，它的**实质**是 $ax + by = 1$：这里 $y$ 是我们新引入的某个整数，并且似乎是个**负数**才对。这样表示是为了用扩展欧几里得算法。我们将要努力求出一组 $x,y$ 来满足这个等式。稍微再等一下——

问题还需要转化。扩展欧几里得是用来求 $ax + by = gcd(a,b)$ 中的未知数的，怎么牵扯到等于 $1$ 呢？

原理是，方程 $ax + by = m$ 有解的必要条件是 $m \mod gcd(a,b) = 0 $。

___

这个简单证一下。

由最大公因数的定义，可知 $a$ 是 $gcd(a,b)$ 的倍数，且 $b$ 是 $gcd(a,b)$ 的倍数，

若 $x,y$ 都是整数，就确定了 $ax + by$ 是 $gcd(a,b)$ 的倍数，

因为 $m = ax + by$，所以 $m$ 必须是 $gcd(a,b)$ 的倍数，

那么 $m \mod gcd(a,b) = 0$。

___

可得出在这道题中，方程 $ax + by = 1$ 的有解的必要条件是 $1 \mod gcd(a,b) = 0$。可怜的 $gcd(a,b)$ 只能等于 $1$ 了。这实际上就是 $a,b$ 互质。 


## 扩展欧几里得

前提：知道普通欧几里得算法（辗转相除法）。

下面字母挺多，希望你耐心地慢慢地读~

我们拿到了一组 $a,b$。设 $G = gcd(a, b)$。那么目标是求出满足 $ax + by = G$（①） 的整数 $x$ 与 $y$。其中 $x$ 应当是满足条件的最小正整数，即答案，而 $y$ 是辅助答案。

（注意，虽然刚刚已经证明本题的 $gcd(a,b)$ 必然等于 $1$，**但是扩展欧几里得算法本身过程求的是 $ax + by = gcd(a,b)$ 的解**。它正好非常适合本题，不过我们要按照它求解的过程去做）

**如果**我们先前已经求出了另一组数 $x_2, y_2$，它们满足这么一个式子：$bx_2 + (a \mod b)y_2 = G$（②），则此时结合①②一定有：

$ax + by = bx_2 + (a \mod b)y_2$ （③）

可见，在这个“**如果**”实现的时候，我们的目标变成了“求出满足上式的 $x$ 和 $y$”。

其中 $a,b,x_2,y_2$ 都已知，$x,y$ 待求。因为未知数比方程更多，所以没有唯一解。我们先求出一组必然存在的解，**最后将在“答案处理”时转为最小解。**

怎么求呢？取模运算是 $a \mod b = a - b×(a/b)$，所以方程③实际上是：

$ax + by = bx_2 + (a-b×(a/b))y_2$

$\Rightarrow ax + by = bx_2 + ay_2 - b × (a/b)y_2$

$\Rightarrow ax + by = ay_2 + b(x_2-(a/b)y_2)$

看上面这个方程，**一组必然存在的解出现了**：

$x = y_2, y = x_2 - (a/b)y_2$（④）

可见，我们只要求出 $x_2,y_2$，就能得出正确的 $x,y$。问题是 $x_2,y_2$ 怎么求。

现在我们手上是 $b,a \mod b$ 这两个系数，而目标是求出 $x_2$ 和 $y_2$ 满足：

$bx_2 + (a \mod b)y_2 = G$（②）

把①和②对比一下：

$ax + by = G$ （①）

原方程中的系数 $a$ 变成了②中的系数 $b$，原方程中的系数 $b$ 变成了②中的 $a \mod b$ 而已。

所以，把新的方程也看作 $ax + by = G$ 的形式（只是系数 $a$ 和 $b$ 的具体数值改变了）。然后按照上面的一模一样下来（其实都只是推导过程），我们发现，最好有 $x_3,y_3$ 来支撑 $x_2, y_2$。

再一模一样下来，我们又需要 $x_4,y_4$ 来支撑 $x_3, y_3$。

……

这个递归中 $a, b$ 不断被替代为 $b, a \mod b$，**这个替换方式与普通欧几里得是一样的，所以最后会出现 $a_n = G, b_n = 0$**。

这时要直接返回了，我们需要一组 $x_n,y_n$ 满足 $a_nx_n + b_ny_n = G$（⑤）。

然而该层的 $a_n = G, b_n = 0$。所以只要⑤左边取 $x_n = 1$，这个方程就妥妥的成立了。

（最后一层的 $y_n$ 建议取 $0$。然而由于 $b = 0$，就算返回其它数值，方程也一定成立。但这样的程序容易出错，因为 $y_n$ 在回溯时滚雪球式增长，容易数值越界。下面的代码在最后一层令 $y = 7$，开了long long，通过了此题。）

最后一层结束后，就开始返回，直到最上层。每一层可以轻松地根据下层的 $x_{k+1},y_{k+1}$ 求出当前层的 $x_k, y_k$。

*整个过程就是：以辗转相除的方式向下递进，不断缩小系数，保证会出现有确定解的最后一层。*

## 答案处理

一个遗留问题：我们将要求出来的 $x,y$ 仅仅保证满足 $ax + by = 1$，而 $x$ 不一定是最小正整数解。有可能太大，也有可能是负数。这依然可以解决，那就是，$x$ 批量地减去或加上 $b$，能保证 $ax + by = 1$，因为：

$ax + by = 1$

$ax + by + k×ba - k×ba = 1$

$a(x+kb) + (y-ka)b = 1$

1.显然这并不会把方程中任何整数变成非整数。

2.“加上或减去 $b$”不会使 $x$ **错过**任何解。可以这么理解：

___

已经求出一组整数 $x,y$ 使得 $ax + by = 1$，也就是 $\frac{1-ax}{b} = y$。$y$ 是整数，可见目前 $1-ax$ 是 $b$ 的倍数。

现在想改变 $x$ 并使得方程仍然成立。已知 $a,b$ 互质，假若 $x$ 的**变化量**（$\Delta x$）不是 $b$ 的倍数，则 $1-ax$ 的变化量（$-a×\Delta x$）也不是 $b$ 的倍数，这会使得 $1-ax$ 不再是 $b$ 的倍数，则 $y$ 不是整数了。

仅当 $x$ 的变化量是 $b$ 的倍数时，$1-ax$ 能保持自己是 $b$ 的倍数，此时就出现新的解了。
___

因此到最后，如果 $x$ 太小就不断加 $b$ 直到大于等于 $0$，太大则一直减 $b$，直到最小正整数解。也就是这么写：

```cpp
	x = (x % b + b) % b;//括号中取模再加，可以处理负数
```

## 代码

推导中的所有 $x,y$ 共用全局变量 long long x, y，传递也很方便。

```cpp
#include<bits/stdc++.h>
using namespace std;

long long x, y;//目前方程真正的解 

void exgcd(long long a, long long b)
{
	//当前目的：求解 ax + by = gcd(a, b) 这么一个方程
	
	if(b == 0) //a, b不断改变的过程中，b最终必然会成为0
	{
		//在 b = 0 时方程还要成立？ 使 x = 1, y = 0 ，必然成立 
		x = 1;
		y = 7; //建议返回0。不过y = 7能AC，证明了最后一个等式不受最后一个y影响
		return;
	} 
	
	exgcd(b, a % b);//把下一层系数传进去（先求下一个方程的解 ）
	
	//现在我们已经拿到了下一个方程的解x, y
	long long tx = x;//暂时存一下x，别丢了
	x = y;
	y = tx - a / b * y; 
}

int main()
{
	long long a, b;
	cin >> a >> b;
	exgcd(a, b);
    
	x = (x % b + b) % b;//我们求出来的x必然满足方程，但不一定是最小正整数解，所以要进行答案处理
	printf("%lld\n", x);
	return 0;
}


```

求这样一个满足 $ax \mod b = 1$ 的 $x$ 有什么用呢？一个重要用途如下。

这个 $x$ 就是：$a$ 在模 $b$ 意义下的乘法逆元。

在模 $b$ 意义下，如果想要**除以 $a$** 就非常麻烦。这时候**乘以 $a$ 的逆元**等效于**除以 $a$。**

***
假设我们已经算出了：

```cpp
ans = (a * b * c) % p;
```

现在要从 $ans$ 中把 $b$ 给除掉，如何处理 $ans$？

如果像下面这样直接除会出错（举个实例会很直观）：

```cpp
ans = ans / b % p;
```

所以我们就求出 $b$ 的逆元 $x$（满足 $bx \mod p = 1$），然后直接算这个：

```cpp
ans = ans * x % p;
```

原理可以这么理解：

$abcx \equiv ac(bx) \equiv ac \pmod p$

***

更新记录：

2020-02-01 证明略有改动；加入了逆元一种作用的说明。

2020-02-03 加点补充说明减少误解。

2020-02-27 语句修改。

---

## 作者：沙普绿12138 (赞：103)

看到题解全是exgcd做法，对于我这种不爱背代码的蒟蒻极其不友好，于是本蒟蒻写了一篇非扩欧的题解，供大家参考。

首先我们不难发现题目中的式子$ax\equiv1 \pmod{b}$与欧拉函数$a^{φ(b)}\equiv1\pmod{b}$很像（~~说的不难看出都是假的~~）
根据同余的传递性，我们可以得出$ax\equiv{a^{φ(b)}}\pmod{b}$的式子，移项后得到$x\equiv{a^{φ(b)-1}}\pmod{b}$，当$x$最小时$0<x<b$,即：$x_{min}=a^{φ(b)-1}\pmod{b}$

思路至此结束，求$φ(b)$可利用其积性函数性质将其分解质因数求解（不会积性函数请自行百度），总复杂度$logn+\sqrt{n}$。

AC代码：
```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;

int a, b;

int fai(int n) {//求欧拉函数
    int ans = 1;
    for(int i = 2; i * i <= n; ++ i) {
        if(n % i == 0) {
            n /= i;
            ans *= i - 1;
            while(n % i == 0) {
                n /= i;
                ans *= i;
            }
        }
    }
    if(n > 1)//优化，n>1表示分解剩下一个质数
        ans *= n - 1;
    return ans;
}

int fast_pow(int x, int k) {//快速幂
    ll ans = 1, quan = x;
    while(k) {
        if(k & 1)
            ans = ans * quan % b;
        quan = quan * quan % b;
        k >>= 1;
    }
    return (int)ans;
}

int main() {
    scanf("%d %d", &a, &b);
    printf("%d", fast_pow(a, fai(b) - 1));//公式
    return 0;
}
```

最后，祝大家NOIP2018AK

---

## 作者：陈曦 (赞：71)


仔细观察式子：ax≡1(mod b)

**发现这就是此时x就是a模b意义下的逆元**，即inv[a]=x;

不会求逆元的话，可以看[~~我的博客~~](https://blog.csdn.net/qq_42701791/article/details/81869922)

我们知道求单个逆元有两种~~方fa♂~~

所以我们先讲暴力（~~逃~~



------------
## 1.暴力 80分

我校某退役选手的遗产
```cpp
int main()//不想解释了，简单模拟
{
    long long int a,b,c,d=0;
    int j=0;
    scanf("%lld%lld",&a,&b);
    while(d!=1)
    {   
        ++j;d=a+d;
    	if(d>b)
    	{while(d>b)d-=b;}
    }
    write(j);
    return 0;
}
```
## 2.快速幂求逆元 10分

快速幂求逆元的原理很简单，就是费马小定理。

当 p 为素数，且a，p互质时：

### a^{p-1}≡1(mod p)

### a * a^{p-2}≡1(mod p)


所以a^(p-2)就是a在模p意义下的逆元，快速幂求出a^(p-2)即可。

快速幂算法最大的缺点就是模数必须为质数，所以这题gg。

```cpp
inline long long ksm(int t,int i)//快速幂模板
{
    if(t==1)return i%m;
    if(t%2==0)
    return ksm(t>>1,i)*ksm(t>>1,i)%m;
    else
    return ksm(t>>1,i)*ksm(t>>1,i)*(i)%m;
}
int main()
{
    long long n;
    scanf("%lld%lld",&n,&m);
    write(ksm(m-2,n));
}
```
## 3.扩欧求逆元 100分

这很简单，就是

### a*inv[a]≡1(mod p)

### a*inv[a]-py=1

因为y是变量所以可以变成这样：
### a*inv[a]+py=1

我们把inv[a]设成x，就变成了扩欧的标准式：

### ax+by=1

然后就可以瞎搞了，至于不知道怎么瞎搞的同学，可以先点这里[~~又是安利~~](https://blog.csdn.net/qq_42701791/article/details/81942381)
```cpp
#include<iostream>
#include<cstdio>
#include<ctime>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
int k,x,y;
inline void read(int &x)//快读
{
    x=0; 
    int f=1; 
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') 
        f=-1; 
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }x*=f;
}
inline void exgcd(int a,int b)//扩欧模板，我用的是全局变量
{
    if(b==0)
    {x=1;y=0;return;}//当b=0,gcd(a,b)=a时，x=1,y=0。
    exgcd(b,a%b);
    k=x;x=y;
    y=k-a/b*y;
    return;
}
int main()
{
    int n,m;
    read(n),read(m);
    exgcd(n,m);
    printf("%d",(x+m)%m);
}
```
~~是不是很简单，点个赞就行了，谢谢~~

---

## 作者：Shirο (赞：29)

一句话题意：
$$ax \equiv 1 \pmod b$$
a，b均已知

魔改一下：（$y \in Z^{+}$）

因为 $\bmod $ 的是 b，所以加上一个$\space b*y\space $
不会妨碍到结果

辣么：
$$ax+b y\equiv 1 \pmod b$$

但是扩欧是用于求形如这样的方程：
$$ ax+by\equiv \gcd(a,b)$$

那么得出结论~~小声bb~~：a和b互质

以上是把原问题转换成exgcd的方法

现在开始解这一个方程

通过正常欧几里德算法（辗转相除法）可以知道：

$$\gcd(a,b) = \gcd(b,a \bmod b) $$

那么我们假设有另一组解（x2，y2）存在：
$$b*x_{2}+(a\bmod b)*y_{2}\equiv 1 \equiv a*x+b*y$$

所以又是一串魔改

$$a\bmod b = a - b * a \div b$$

$$b*x_{2}+(a- b*a \div b)*y_{2} \equiv a*x+b*y$$

分配率：

$$b*x_{2}+a*y_{2}-b*a\div b*y_{2} \equiv a*x+b*y$$

即为：

$$ a*y_{2}+b*(x_{2}-a\div b*y_{2})\equiv a*x + b*y$$

显而易见：

$$ x=y_{2},y=x_{2}-a\div b*y_{2}$$

那么我们只需要一层层递归即可

而且递归边界是$x_{n}=1$，因为我们上面得出来$\gcd(a,b)=1$

递归自己写了，懒得贴

---

## 作者：_Nova (赞：12)

- **裴蜀定理**

> 若$a,b$是整数,且$gcd(a,b)=d$,对于任意整数$x,y$,$ax+by$都一定是$d$的倍数,特别地,一定存在整数$x,y$,使$ax+by=gcd(a,b)$成立.
**重要推论:a,b互质的充要条件是存在整数x,y使ax+by=1**

- **扩展欧几里得(exgcd)————求ax+by=gcd(a,b)的解**

在朴素的求gcd(a,b)的过程中使用递归算法,达到递归边界时,$b'=0,a'=gcd(a,b)$.
可知$a'\cdot 1+b'\cdot 0=gcd(a,b)$,但$a',b'$已不是最开始的$a,b$.因此要想求出$x,y$,就要回到最开始的$a,b$.
由于是递归算法,所以我们在回溯时考虑如何回到上一层.

若有$\space ax_1+by_1=gcd(a,b)$
则有$\space bx_2+(a\bmod b)y_2=gcd(b,a\bmod b)$
若知道了$x_1,x_2,y_1,y_2$间的关系,就能递归运算.
观察$bx_2+(a\bmod b)y_2=gcd(b,a\bmod b )$,将$(a\bmod b )$展开.
可写作$bx_2+(a-\lfloor \frac{a}{b}\rfloor\cdot b)\cdot y_2$
化简得$ay_2+b(x_2-\lfloor \frac{a}{b}\rfloor\cdot y_2)=gcd(b,a\bmod b)$
$\because gcd(a,b)=gcd(b,a\bmod b)$
$\therefore$ 联立可得 $x_1=y_2,y_1=x_2-\lfloor \frac{a}{b}\rfloor\cdot y_2$

已知$x_0=1,y_0=0$,则可以求出$ax+by=gcd(a,b)$得一组解x,y

- **如何求通解?**

方程$ax+by=gcd(a,b)$中
若有常数$k_1,k_2$,将$x+k_1,y-k_2$仍能使方程成立,那么$(x+k_1),(y-k_2)$就是一组新解.

$$
a\cdot(x+k_1)+b\cdot(y-k_2)=gcd(a,b)
$$
$$
ax+by+ak_1-bk_2=gcd(a,b) 
$$
$$
\therefore ak_1=bk_2
$$


为得到所有解,需满足$ak_1=bk_2=t\cdot lcm(a,b)\space \space \space (t\in Z)$
$\therefore k_1=\frac{b}{gcd(a,b)},k_2=\frac{a}{gcd(a,b)}$

- **对于更一般的情况**

$$ax+by=c$$

由裴蜀定理,若$c\bmod gcd(a,b)!=0$,则方程无解
若$gcd(a,b)\cdot t=c$,只需求出$ax+by=gcd(a,b)$的解后乘t即可

```cpp 
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll s=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}
	return s*w;
} 
ll a,b;
ll x,y;
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int k=exgcd(b,a%b,x,y);
	int tmp=x;
	x=y;
	y=tmp-(a/b)*y;
	return k;
}
int main(){
	a=read(),b=read();
	ll d=exgcd(a,b,x,y);
	while(x<0) x+=b/d;
	printf("%lld\n",x/d);
	
	return 0;
}
```

---

## 作者：xxxalq (赞：4)

# 问题

求关于 $x$ 的同余方程 $ax\equiv 1\pmod{b}$ 的最小正整数解。

# 思路

## 问题转化

不妨将问题转化一下变成 $ax+by=1$。显然当 $ax+by=1$ 成立时，原式成立，其中 $y$ 是未知数。这种形式很简单的想到拓展欧几里得算法，可以求 $ax+by=\gcd(a,b)$ 的解。

---

接下来证明一下为什么这么求是对的。

首先，方程 $ax+by=z$ 有整数解的必要条件是 $z\bmod \gcd(a,b)=0$，因为 $a$ 一定是 $\gcd(a,b)$ 的倍数，$b$ 也一定是 $\gcd(a,b)$ 的倍数，又因为 $x,y$ 都是整数，所以 $ax+by$ 一定是 $\gcd(a,b)$ 的倍数，所以 $z$ 一定也是 $\gcd(a,b)$ 的倍数。

以上是裴蜀定理。

---

所以方程 $ax+by=1$ 有解的必要条件就是 $1\bmod \gcd(a,b)=0$，所以 $\gcd(a,b)=1$，即 $a,b$ 互质。

## 拓展欧几里得

设 $g=\gcd(a,b)$，那么我们就要求出 $ax+by=g$  的解。如果我们已经求出了一组 $z_2,y_2$ 满足 $bx_2+(a\bmod b)y_2=g$ ，那么结合上面两个式子就会得到 
$$ax+by=bx_2+(a\bmod b)y_2 $$ 

假设我们已经求出了 $x_2,y_2$，那么此时我们的问题就变成了求方程的 $$ax+by=bx_2+(a\bmod b)y_2 $$  解了。

我们知道 $a\mod b=a-b\times\left\lfloor\frac{a}{b}\right\rfloor$

所以得到 

$$ax+by=bx_2+(a-b\times\left\lfloor\frac{a}{b}\right\rfloor)y_2$$

$$ax+by=bx_2+ay_2-b\times\left\lfloor\frac{a}{b}\right\rfloor\times y_2$$

$$ax+by=ay_2+b(x_2-b\times\left\lfloor\frac{a}{b}\right\rfloor\times y_2)$$

所以我们就得到了方程 $ax+by=g$ 的一组可行解 $x=y_2,y=(x_2-b\times\left\lfloor\frac{a}{b}\right\rfloor\times y_2)$

问题是需要解出 $x_2,y_2$，利用方程 $bx_2+(a\bmod b)y_2=g$，我们就有了 $b$ 和 $a\bmod b$ 两个系数，继续利用上面的方法，找到一组 $x_3,y_3$。在这个递归的过程中，$a,b$ 不断地被替换成 $b,a\bmod b$，根据欧几里得定理不难证明最后一定会出现 $x_n=g,y_n=0$，又因为这道题中 $g=1$。

---

综上所述，我们只需要不断找到一组 $x_i,y_i$，然后不断把 $x,y$ 替换为 $$x=y_i,y=(x_i-b\times\left\lfloor\frac{a}{b}\right\rfloor\times y_i)$$，很好证明最多只需要执行 $\log\max(a,b)$ 次即可求出答案。

证明如下：

因为每次需要将 $(a,b)$ 替换为 $(b,a\bmod b)$。分类讨论一下。

如果 $a<b$，相当于交换了 $a,b$。

如果 $b>\frac{a}{2}$，那么 $\left\lfloor\frac{a}{b}\right\rfloor=1$，则会变为 $(b,a-b)$，由于 $b>\frac{a}{2}$，所以 $a-b<\frac{a}{2}$，也就是会把 $a$ 缩小一半。

如果 $b<\frac{a}{2}$，由于余数小于除数，所以 $a\bmod b<b<\frac{a}{2}$，也会把 $a$ 缩小一半。

如果 $b=\frac{a}{2}$，那么 $a\bmod b=0$，直接结束递归。

综上所述，该算法总的时间复杂度为 $O(\log\max(a,b))$。

# 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read(){
	ll x=0;
	bool flag=false;
	char ch=getchar();
	while(ch>57||ch<48){
		if(ch==45){
			flag=true;
		}
		ch=getchar();
	}
	while(ch>=48&&ch<=57){
		x=(x<<1)+(x<<3)+(ch-48);
		ch=getchar();
	}
	return flag?-x:x;
}
ll x,y;
void exgcd(int a,int b){
	if(b==0){
		x=1,y=7;
		return;
	}
	exgcd(b,a%b);
	ll tmp=x;
	x=y;
	y=tmp-a/b*y;
	return;
}
int main(){
	ll a,b;
	a=read(),b=read();
	exgcd(a,b);
	x=(x%b+b)%b;
	cout<<x;
	return 0;
}
```

---

## 作者：ljh0727 (赞：3)

# P1082同余方程

题目传送门：[题目](https://www.luogu.com.cn/problem/P1082)

### 解决方法

在这个问题中，我们想要找到 $x$ 使得 $ax \equiv 1\pmod b$。根据欧拉定理，$ab$ 互质，得 $a^{\varphi(b)} \equiv 1\pmod b$。

先用欧拉 $\varphi(b)$，再求快速幂。

为了应用欧拉定理，我们需要确认 $a$ 和 $b$ 是互质的，即 $\gcd(a,b)=1$。

如果 $a$ 和 $b$ 不是互质的，那么同余方程 $ax \equiv 1\pmod b$ 就没有解。

假设 $a$ 和 $b$ 是互质的，根据欧拉定理，我们有：$a^{\varphi(b)} \equiv 1\pmod b$。 

这是直接由欧拉定理给出的。

这里，$\varphi(b)$ 是小于或等于 $b$ 且与 $b$ 互质的正整数的个数。

如果我们有 $a^\varphi(b) \equiv 1\pmod b$，那么我们可以将等式两边同时乘以 $a^{−1}$ 即 $a$ 在模 $b$ 下的逆元，就是 $a^\varphi(b) ⋅a^{−1} \equiv 1⋅a^{−1} \pmod b$。

由于 $a^\varphi(b) \equiv 1\pmod b$，我们可以简化等式：$1⋅a^{−1} \equiv a^{−1} \pmod b$。

这里 $a^{−1}$ 就是 $ax \equiv 1\pmod b$ 的解，因为：$a⋅a^{−1} \equiv 1\pmod b$。

所以，$a^\varphi(b) \equiv 1\pmod b$ 实际上给出了 $a$ 的逆元 $a^{−1}$ 的存在性，而 $a^{−1}$ 就是 $ax \equiv 1\pmod b$ 的解。

总结来说，欧拉定理直接告诉我们 $a^\varphi(b) \equiv 1\pmod b$，而要得到 $ax \equiv 1\pmod b$ 的解，我们只需要取 $a^{(\varphi(b)−1)}$ 作为 $x$，因为 $a^{(\varphi(b)−1)}$ 就是 $a$ 的逆元。

### 代码


```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#include<unordered_map>

#define int long long

using namespace std;

const int inf=0x7fffffff;
const int N=1e6+10,mod=1e9+7;

int n;
int a[N],dp[N];

unordered_map<int, int> primes;

int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}

int lcm(int a,int b){
    return a/gcd(a,b)*b;
}

int yuehe(int x){
    primes.clear();
    int k=x;
    for(int i=2;i<=x/i;i++)
        while(x%i==0){
            x/=i;
            primes[i]++;
        }

    if(x>1)	
		primes[x]++;

    int res=1;
    for(auto p:primes){
        int a=p.first,b=p.second;
        int t=1;
        while(b--)
			t=(t*a+1)%mod;
        res=res*t%mod;
    }
    return res-k;
}

int phi(int x){
    int res=x;
    for(int i=2;i*i<=x;i++){
        if(x%i==0){
            res=res/i*(i-1);
            while(x%i==0)x/=i;
        }
    }
    if(x>1)res=res/x*(x-1);
    return res;
}

int qmi(int a,int b,int p){
    int res=1%p;
    while(b){
        if(b&1)
			res=res*a%p;
        a=a*(int)a%p;
        b>>=1;
    }
    return res;
}

void solve(){
    int a,b;
    scanf("%lld%lld",&a,&b);
    if(gcd(a,b)!=1)
		return;
    int p=phi(b);
    int x=qmi(a,p-1,b);
    printf("%lld",x);
}

signed main(){
    solve(); 
    return 0;
}

```

---

## 作者：ShirasuAzusaSaikou (赞：2)

本题是计算模逆元，具体的其他题解的说明已经很完备了，我来提供另外一种做法。  
我的做法不是最优解，蒟蒻不太会扩展欧几里得，那就用欧拉函数 $\varphi(n)$，以及简单的快速幂吧。~~（逃~~  
我的思路是这样的：  
欧拉函数被定义为：   
$\varphi(n) = \left| \left\{ k \in \mathbb{N} \ \bigg| \ 1 \leq k \leq n \ \text{and} \ \gcd(k, n) = 1 \right\} \right|$  
欧拉从拓展费马小定理而证明了欧拉定理：  
$\forall a,b \in \mathbb{N}, a^{\varphi(b)} \equiv 1 \pmod b$  
而欧拉函数也有另外一个形式，就是：  
$\varphi(n) = p_1^{k_1-1}p_2^{k_2-1}...p_r^{k_r-1}(p_1-1)(p_2-1)...(p_r-1)$  
详情可看（上述形式照抄的 wiki）：  https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0  
因此我们可以透过质数分解和快速幂去计算欧拉函数，那这个和本题有什么关系呢？其实这种做法的思路源自快速幂加费马小定理应用计算逆元的方法，但费马小定理需要为质数，而欧拉定理只需要两数互质，也就符合本题必然有解的点。  
因此：  
$ax \equiv 1 \pmod b$  
$\Rightarrow ax \equiv a^{\varphi(b)} \pmod b$  
$\Rightarrow x \equiv a^{\varphi(b) - 1} \pmod b$  
因此只需得出 $\varphi(b)$，然后快速幂再取模即可。  
代码如下：  
```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long

//快速幂
ll Pow(ll a, ll b, ll p){
    ll base = a, out = 1;
    while(b > 0){
        if(b & 1){
            out *= base;
            out %= p;
        }
        base *= base;
        base %= p;
        b >>= 1;
    }
    return out;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int a, b;
    cin >> a >> b;
    ll tt = 1, temp = b, cnt = 0;
    //先对2进行处理
    while(!(temp & 1)){
        cnt++;
        temp >>= 1;
    }
    tt *= Pow(2, cnt - 1, b);
    //对其余质数进行处理
    for(int i = 3; i * i <= b; i += 2){
        cnt = 0;
        while(temp % i == 0){
            cnt++;
            temp /= i;
        }
        if(cnt > 0){
            tt = tt * (i - 1) % b * Pow(i, cnt - 1, b) % b; 
        }
    }
    if(temp != 1) tt *= (temp - 1);
    //计算最后答案
    cout << Pow(a, tt - 1, b) % b << endl;
    return 0;
}

```

---

## 作者：kunkun127 (赞：2)

## 思路

本文仅叙述 exgcd 方法（扩展欧几里得算法）。

- 用途
  
  求 $$ax+by=\gcd(a,b)$$ 的一组可行解。

- 过程

  令 $$ax_1 + by_1 = \gcd(a, b) $$，$$bx_2 + (a \mod b)y_2 = \gcd(b, a \mod b)$$。

  此时我们需要先学习[欧几里得定理](https://baike.baidu.com/item/%E5%B0%84%E5%BD%B1%E5%AE%9A%E7%90%86/97721?fromtitle=%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E5%AE%9A%E7%90%86&fromid=4236464)，然后即可推出

  $$\gcd(a, b) = \gcd(b, a \mod b)$$

  $$ax_1 + by_1 = bx_2 + (a \mod b)y_2$$

  $$∵ a \mod b = a - (\lfloor {a \over b} \rfloor \times b)$$

  $$∴ ax_1 + by_1 = bx_2 + (a - (\lfloor {a \over b} \rfloor \times b))y_2$$

  $$ax_1 + by_1 = ay_2 + bx_2 - \lfloor {a \over b} \rfloor \times by_2 = ay_2 + b(x_2 - \lfloor {a \over b} \rfloor y_2)$$

  $$x_1 = y_2, y_1 = x_2 - \lfloor {a \over b} \rfloor y_2$$

  经过漫长的计算，我们直接将 $x_2$ 和 $y_2$ 进行代入递归以求解。

- exgcd 核心代码

  
```cpp
void exgcd(LL a, LL b, LL &d, LL &x, LL &y)
{
	int t;
	if (b == 0) 
	{
		d = a; 
		x = 1;
		y = 0;
	}
	else
	{
		exgcd(b, a % b, d, x, y);
		t = x;
		x = y;
		y = t - (a / b) * y;
	}
}
```

## 参考代码


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

void exgcd(LL a, LL b, LL &d, LL &x, LL &y)
{
	int t;
	if (b == 0) 
	{
		d = a; 
		x = 1;
		y = 0;
	}
	else
	{
		exgcd(b, a % b, d, x, y);
		t = x;
		x = y;
		y = t - (a / b) * y;
	}
}

int main()
{
	LL a, b, d, x, y;
	cin >> a >> b;
	exgcd(a, b, d, x, y);
	cout << (x % b + b) % b << endl;
	return 0; 
}
```

---

## 作者：HasNoName (赞：1)

### 思路
众所周知任意一个形如 $ax+by=\gcd(a,b)$ 的方程必有整数解。

所以这里只讲解如何求解 $ax+by=\gcd(a,b)$ 的方法。

设 $c=\gcd(a,b)$。

如果我们已经求解出了 $bx_1+(a\bmod b)y_1=c$ 的解，则可以将方程写为 $bx_1+ay_1-b\lfloor\frac{a}{b}\rfloor y_1=c$。

移项可得：$(x_1-\lfloor\frac{a}{b}\rfloor y_1)b+y_1a=c$。

然后可以发现该方程和原方程形式相同。

所以令 $x=y_1$，$y=x_1-\lfloor\frac{a}{b}\rfloor y_1$。

由于当 $b=0$ 时 $a=c$，所以显然可以构造 $x=1$，$y=0$。再用递归求解即可。

考虑如何将 $ax\equiv1\pmod{b}$ 转化为 $ax+by=\gcd(a,b)$ 的形式。

$ax\equiv1\pmod{b}$ 可写为 $ax-1=by$，所以移项得到 $ax+(-b)y=1$。因为数据保证一定有解，所以 $\gcd(a,b)=1$。

答案即为求解出的 $x$。
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	ll d=exgcd(b,a%b,y,x);//将x=x1，y=y1，可以减少一步计算
	y-=a/b*x;
	return d;
}
int main()
{
	ll a,b,x,y;
	cin>>a>>b;
	exgcd(a,b,x,y);
	cout<<((x%b)+b)%b<<endl;//让x成为最小正整数解。
 	return 0;
}
```

---

## 作者：Ngo123 (赞：1)

#### 本题使用扩展欧几里得算法
我们需要求关于 $x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。

这道题可以转化为扩展欧几里得解线性同余方程的算法。

先说下线性同余方程的形式：

给定整数 $a , b, m$ 对于这组数，求一个整数 $x$ 使它满足 $ a x \equiv b \pmod {m}$。

这道题就是特殊的线性同余方程，即变为了 $ a x \equiv 1 \pmod {b}$。

我们可以先通过扩展欧几里得算法求出一组特解。

由于题目要求输出最小整数解$x$，因此再得到特解后，再通过特殊处理即可得到最小整数解。

这是特殊处理的方式：
```
x = (x % b + b) % b;
```

这就是本题的思路，以下是本题代码：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int a,b;
LL x,y;
void exgcd(int a,int b,LL &x,LL &y)
{
    if(!b)
    {
        x = 1,y = 0;
        return;
    }
    exgcd(b,a%b,y,x);
    y -= a/b*x;
}
int main()
{
    cin>>a>>b;
    exgcd(a,b,x,y);
    cout << (x % b + b) % b << endl;
    return 0;
}
```

---

## 作者：sjh0626 (赞：1)

## 前置知识
### 同余
若 $x \equiv a \pmod k$，并且 $y \equiv b \pmod k$。

则 $(x+y) \equiv (a+b) \pmod k$。
### 逆元
- 定义：如果一个线性同余方程 $ax \equiv 1 \pmod b$，则 $x$ 就是 $a \bmod b$ 的逆元，记作 $a^{-1}$。
### 扩展欧几里得定理
存在一个不定方程 $ax + by = \gcd(a,b)$。

我们设两个方程：

1. $ax_1 + by_1 = \gcd(a,b)$
2. $bx_2 + (a \bmod b)y_2 = \gcd(b,a\bmod b)$。

同时，因为 $\gcd(a,b) = \gcd(b,a\bmod b)$。

所以 $ax_1 + by_1 = bx_2 + (a \bmod b)y_2$。

又因为 $a \bmod b = a - (\lfloor\frac{a}{b}\rfloor \times b)$。

所以又可以改写为 $ax_1 + by_1 = bx_2 + (a - (\lfloor\frac{a}{b}\rfloor \times b))y_2$。

根据乘法分配律，又可以改写为 $ax_1 + by_1 = bx_2 + (a - (\lfloor\frac{a}{b}\rfloor \times b))y_2$。

展开得，$ax_1 + by_1 = ay_2 - b(x_2 -\lfloor\frac{a}{b}\rfloor y_2)$。

所以 $x_1 = y_2$，$y_1 = x_2 - \lfloor\frac{a}{b}\rfloor y_2$。

然后我们发现，这不就是递归吗，所以就按照递归的方式求就行了。

```cpp
int exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1,y=0; //即 ax+by=a 
		return a;
	}
	int res=exgcd(b,a%b,x,y); 
	int temp=x; 
	x=y;
	y=temp-a/b*y;
	return res; 
}
```
## 思路分析
因为这道题是让我们求关于 $x$ 的同余方程 $ax \equiv 1 \pmod b$ 的最小整数解，就是 $a \bmod b$，所以我们要求逆元。

但是因为 $b$ 不是质数，所以我们不能直接用费马小定理来解，所以我们考虑扩展欧几里得定理求逆元。

首先 $b \mid ax-1$ 毋庸置疑，因为 $ax \bmod b = 1$。

所以我们可以将 $ax \equiv 1 \pmod b$ 转化为 $ax - bk = 1$。

这就可以直接套板子了，但注意 $x$ 可能是负数，所以要累加把它转为正整数。

## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
using namespace std;
int a,b,x,y;
//Exgcd,扩展欧几里得
int exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1,y=0;
		return a;
	}
	int res=exgcd(b,a%b,x,y);
	int temp=x; 
	x=y;
	y=temp-a/b*y;
	return res; 
} 
int main(){
	cin>>a>>b;
	exgcd(a,b,x,y);
	cout<<(x+b)%b;
	sjh0626s code;
}
```

---

## 作者：All_Unluck_Beginning (赞：0)

由同余知识易得，$a\times x\equiv 1\pmod b$ 有解当且仅当 $\gcd (a,b)=1$。

于是本题就变为了 $a\times x+b\times y=1$，用 Exgcd 算法求出一组解为 $x_0,y_0$，则 $x_0$ 为原方程的解，通解为所有模 $b$ 与 $x_0$ 同余的整数。

最后通过取模就得到最小的解了。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,b,x,y;
int exgcd(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int d=exgcd(b,a%b,x,y);
	int z=x;x=y,y=z-y*(a/b);
	return d;
}
signed main(){
	cin>>a>>b;
	exgcd(a,b,x,y);
	cout<<(x%b+b)%b<<"\n";
	return 0;
} 
```

---

## 作者：zsq9 (赞：0)

[AC 记录](https://www.luogu.com.cn/record/197860025)

## 题目大意

求关于 $x$ 的同余方程 $a x \equiv 1 \pmod {b}$ 的最小正整数解。

## 思路

这看到这题，我们可以想到逆元，逆元是什么？逆元就是求 $a \times x \equiv 1 \pmod b$ 这么把逆元转化成题目呢？我们可以从逆元上推，$a \times x \equiv 1 \pmod b \Rightarrow (a \times x-1)= b \times k \Rightarrow (a \times x - b \times k)= 1$ 但是因为 $k$ 可以变就可以写成 $(a \times x + b \times k)= 1$ 这下就推出形如题目中的式子就可以做了，这就是扩展欧几里得。这是一种方法可以推出扩展欧几里得，一般方法推扩展欧几里得，在这里就不讲了，看图。

![](https://cdn.luogu.com.cn/upload/image_hosting/f8joio6c.png)

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,x,y;
void ext(long long a,long long b){
	if(b==0){
		x=1,y=0;
		return;
	}
	ext(b,a%b);
	long long x1=x;
	x=y;
	y=x1-a/b*y;
}
int main(){
ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>a>>b;
	ext(a,b);
	x=(x%b+b)%b;
	cout<<x;

return 0;
}

```

---

## 作者：wangjiawen (赞：0)

#### 前言
好久之前做的数论题了，最近复习又看了几眼，结果发现这个 10 开头的题竟然还能交题解（惊）。于是就来写篇题解。
## 正文
求 $ax \equiv 1 \pmod b$ 的最小整数解，可以先求 $ax + by = 1$ 这个线性同余方程的整数解。由于 $1 \mid \operatorname{gcd}(a,b)$ 所以我们可以用扩展欧几里得来求解。此时这个解不一定是最小正整数解，因此我们还需要一些调整。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,x,y;
void exgcd(long long a,long long b)//扩欧求解
{
	if(b==0)
	{
		x=1;y=0;return;
	}
	exgcd(b,a%b);
	long long tx=x;
	x=y;
	y=tx-a/b*y;
}
int main()
{
	cin>>a>>b;
	exgcd(a,b);
	while(x<=0)
		x+=b;
	cout<<x;
	return 0;
}
```
这个代码是近一年前写的，当时代码有点屎，也不想改了。
#### 结尾
在此引用[OI-Wiki](oiwiki.com)的一些文章：
1. [什么是扩展欧几里得](https://oiwiki.com/math/number-theory/gcd/)。
2. [什么是线性同余方程 and 扩展欧几里得求线性方程](https://oiwiki.com/math/number-theory/linear-equation/)。

---

## 作者：lihl (赞：0)

### Pre
一般求逆元的方法共有三种：
- exgcd 法：一般适用于 $p$ 不为质数并且 $\gcd(a,b)=1$ 的情况。参见 [P5656 二元一次不定方程](https://www.luogu.com.cn/problem/P5656)
- 快速幂法：一般适用于 $p$ 为质数的情况。通过费马小定理，不难推导出 $x\equiv a^{b-2}\pmod b$，即可求解。参见 [P2613 有理数取余](https://www.luogu.com.cn/problem/P2613)
- 线性求逆元：一般适用于一次求出多个逆元的情况。参见 [P3811 模意义下的乘法逆元](https://www.luogu.com.cn/problem/P3811)

### exgcd 法

改写原式 $ax\equiv 1 \pmod b$，得

$$\begin{aligned}
ax - 1 &= by \\
ax - by &= 1
\end{aligned}$$

由裴蜀定理，不难发现原方程满足了有解充要条件 $\gcd(a,b)\mid c$。

接下来我们考虑一组已知解 $x_0,y_0$ 为 $bx_0 + (a\bmod b)y_0=c = 1$，不难发现可以根据等式的性质转化为

$$ ax+by = bx_0 + (a\bmod b)y_0 $$

的形式。根据模运算的性质 $a\bmod b=a-\lfloor\cfrac{a}{b}\rfloor b$，可以进一步化简为

$$ ax+by = bx_0 + (a-\lfloor\cfrac{a}{b}\rfloor b)y_0 \\
ax + by = bx_0+ ay_0-\lfloor\cfrac{a}{b}\rfloor by_0\\
ax+by = ay_0+ b(x_0-\lfloor\cfrac{a}{b}\rfloor y_0)
$$

考虑该方程的解为

$$\begin{cases}
x = y_0 \\
y = x_0-\lfloor\cfrac{a}{b}\rfloor y_0
\end{cases}$$

接下来考虑求解 $x_0,y_0$。不难发现，我们可以求解这样一个关于 $a,b$ 的方程

$$bx_0 + (a\bmod b)y_0= 1$$ 

来求出 $a,b$。可以发现，终解可以表示为以下形式

$$a_nx_n+b_ny_n = 1$$

最终存在 $b=0$，$a=c=\gcd(a,b)=1$ 的情况，于是不妨令 $x_n=1,y_n=0$ 即可。

最后需要注意 $x$ 不为最小整数解的情况。$x$ 的最小整数解可以表示为

$$ x=(x \bmod t+t) \bmod t $$
$$ t= \cfrac{b}{\gcd(a,b)}$$

的形式，即

$$ x = (x\bmod b+b) \bmod b$$

即可。

### 定理法
由费马小定理得

$$a^{p-1}\equiv 1\pmod p$$
$$a^{\varphi(p)}\equiv 1\pmod p $$

不难发现其变为欧拉定理，由欧拉定理得

$$a^{\varphi(b)}\equiv 1\pmod b$$

联立原式得

$$ax\equiv a^{\varphi(b)}\equiv 1\pmod b\\
x\equiv \varphi(b)-1\pmod b$$

线性筛 $\varphi$ 即可。时间效率优于 exgcd 法。

### Note

- 250110：修改

---

## 作者：GoldenSTEVE7 (赞：0)

## 思路

先看给出的原方程
$$
ax \equiv 1 \pmod b
$$

所以很容易发现 $x \equiv a^{-1} \pmod b$。

直接求逆元的话需要保证 $b$ 为质数啊，但我们有没有呢？没有。。所以就要用 exgcd？？？但我不想用（~~其实就是我板子忘干净了~~），所以我们来想想另一种思路。

还是回到原方程
$$
ax \equiv 1 \pmod b
$$

这玩意是不是跟欧拉定理很像啊
$$
a^{\varphi(b)} \equiv 1 \pmod b
$$

那好，我们联立上式就可得
$$
a^{\varphi(b)} \equiv ax \equiv 1 \pmod b
$$

由于 $(a, b) = 1$，所以可以将第一个同余号的左右同时除以一个 $a$，那么就得到
$$
x \equiv a^{\varphi(b)-1} \pmod b
$$

由于只需要求出最小的 $x$（令其为 $x_0$），所以 $0 < x < b$，故 $x_0 = a^{\varphi(b)-1}$。

----

接下来要开始写代码了。

先来看看 $\varphi(b)$ 如何求出。

设 $b = \displaystyle\sum_{k=0}^na_k^{x_k}$，其中 $a_i$ 均为质数，$x_i$ 为正整数。$(1 \le i \le n)$

那么由欧拉函数为积极性函数（自己可去查一下）
$$
\varphi(b) = \varphi(a_1^{k_1})\varphi(a_2^{k_2}) \dots \varphi(a_n^{k_n})
$$

分别等式右边的每一个欧拉函数进行求解即可（具体的求法可以看下面代码）。

最后要注意用快速幂求解 $a^{\varphi(b)-1}$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int a, b;
ll fpow(ll x, ll y) {
    ll ret = 1;
    for(; y; y >>= 1) {
        if(y & 1) ret = ret * x % b;
        x = x * x % b;
    }
    return ret;
}

int main() {
    cin >> a >> b; ll t = b;
    ll fb = 1;//与b互质的小于b的正整数个数，即phi(b)
    for(int i = 2; i * i <= b; i++) {
    	int x = 0;
    	while(b % i == 0) {
    		if(!x) {
				b /= i;
            	fb *= i - 1;
            	x = 1;
			}
			if(b % i == 0) {
				b /= i;
           		fb *= i;
			}
		}
	}
	if(b > 1) fb *= b - 1; //还有没分完的
	b = t;
	cout << fpow(a, fb-1); 
    return 0;
}
```

---

## 作者：mahaorui2012 (赞：0)

# 思路 

前置知识：扩展欧几里得。

若 $ax\bmod b=1$，则设 $y$ 为 $ax$ 除以 $b$ 的商，则有：

$$ax=by+1\ \ \  (y \in \mathbb{Z})$$
$$ax-by=1$$

则可以使用扩展欧几里得算法。 

# AC CODE

```C++
#include <iostream>
using namespace std;

struct solve{
	long long x,y;
};

solve make_solve(int x,int y){
	solve ret;
	ret.x=x;
	ret.y=y;
	return ret;
}

solve exgcd(int a,int b){
	if(!b){
		return make_solve(1,0);
	}solve ans=exgcd(b,a%b);
	return make_solve(ans.y,ans.x-a/b*ans.y);
}

int main(){
	int a,b;
	cin>>a>>b;
	solve ans=exgcd(a,b);
	cout<<(ans.x%b+b)%b;
	return 0;
}
```

---


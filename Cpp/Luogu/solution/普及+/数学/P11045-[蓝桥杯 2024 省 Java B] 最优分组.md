# [蓝桥杯 2024 省 Java B] 最优分组

## 题目描述

小蓝开了一家宠物店，最近有一种 X 病毒在动物之间进行传染，小蓝为了以防万一打算购买测试剂对自己的宠物进行病毒感染测试。

为了减少使用的测试剂数目，小蓝想到了一个好方法：将 $N$ 个宠物平均分为若干组，使得每组恰好有 $K$ 只宠物，这样对同一组的宠物进行采样并混合后用一个试剂进行检测，如果测试结果为阴性则说明组内宠物都未感染 X 病毒；如果是阳性的话则需要对组内所有 $K$ 只宠物单独检测，需要再消耗 $K$ 支测试剂（当 $K=1$ 时，就没必要再次进行单独检测了，因为组内只有一只宠物，一次检测便能确认答案）。

现在我们已知小蓝的宠物被感染的概率为 $p$，请问 $K$ 应该取值为多少，才能使得期望的测试剂的消耗数目最少？如果有多个答案，请输出最小的 $K$。

## 说明/提示

**【评测用例规模与约定】**

对于 $30\%$ 的评测用例：$1\leq N\leq 10$。

对于 $60\%$ 的评测用例：$1\leq N\leq 1000$。

对于 $100\%$ 的评测用例：$1\leq N\leq 10^6$，$0\leq p\leq 1$。

## 样例 #1

### 输入

```
1000
0.05```

### 输出

```
5```

# 题解

## 作者：0x00AC3375 (赞：10)

## 1. 问题简述

对传染病进行试剂检测时，多人混合检测的数学模型（这种检测方法也出现在 COVID-19 的疫情中）。

## 2. 分析

设总共有 $N$ 个个体，分成了 $g=N/K$ 组，每一组有 $K$ 个个体，设总共消耗了 $X$ 份检测试剂。

容易看出 $g=1$ 或 $g=N$ 时相当于不分组，$E(X)=N$。

从 $g\ge2$ 开始，首先需要消耗 $g$ 支试剂为每一组进行一次检测。在每一组当中：
- 只要有 $1$ 个个体为阳性，整组就会显阳性；
- 至少一个阳性的对立事件是所有个体全为阴性；
- 由于每个个体的阳性与否相互独立，阳性的概率全为 $p$，所有个体全部为阴性的概率就是 $(1-p)^K$，因此某一组显阳性的概率就是 $1-(1-p)^K$。

设在此期间有 $Y$ 组检测结果为阳性，则容易知道 $Y\sim B(g,1-(1-p)^K)$，服从二项分布，根据二项分布的数学期望公式可知
$$E(Y)=g[1-(1-p)^K]=\dfrac {N}{K}[1-(1-p)^K]$$

对于每一个阳性的组都需要额外消耗 $K$ 支试剂分别检测一次，因此 $g\ge 2$ 时总体消耗的试剂数量的数学期望
$$E(X)=KE(Y)+g=\dfrac{N}{K}+N[1-(1-p)^K]$$

由于 $N$ 不超过 $10^6$，因此直接一遍遍在保证 $N$ 能够整除 $K$ 的情况下尝试最优解即可。

## 3. 代码
```csharp
using System;

class P11045
{
	public static void Main()
	{
		double n, p;
		n = Convert.ToDouble(Console.ReadLine());
		p = Convert.ToDouble(Console.ReadLine());
        double mean = n;
        int optimal_group = 1;

        for (int k = 2; k <= n; k++)
        {
            if (n % k == 0)
            {
                double current = n / k + n * (1 - Math.Pow(1 - p, k));
                if (mean > current)
                {
                    optimal_group = k;
                    mean = current;
                }
            }
        }
        Console.WriteLine(optimal_group);
    }
}
```

## 4. Extra

作为对这道题的拓展，个人觉得这部分内容虽然本题不涉及（因为已经限定了分组时必须每组相同，如果总数为质数就不能分组）但是还是有必要提一下。本题提到的“多人混检”出现在 2021 年的北京高考数学卷中（下图），也出现在一些其他的数学比赛中，因此这个模型的典型性可见一斑。

![](https://cdn.luogu.com.cn/upload/image_hosting/qnx44p4f.png)

在这里我们**丢弃掉整除的限定条件**，将上述表达式里面的 $E(X)$ 除以 $N$，可以得到检测过程中**平均每个人需要消耗的试剂数**

$$E_p=1+\dfrac{1}{K}-(1-p)^K$$

由于这个表达式的值和总人数 $N$ 无关，因此具有更强的普适性（也就是说单纯从数学理论上讲，题目里输入的人数 $N$ 其实没用）。我们设函数 

$$f(x)=1+1/x-(1-p)^x$$

绘制函数代码和图像如下：

```python
import matplotlib.pyplot as plt
import numpy as np

plt.rcParams["font.family"] = "SimHei"

p = [0.001, 0.010, 0.050, 0.200]
x = np.linspace(1, 40, 1000)

for i in range(len(p)):
    y = 1 + 1 / x - (1 - p[i]) ** x
    plt.plot(x, y, marker = None, label = "p=%.3f"%p[i])

plt.legend()
plt.xlabel("分组组数")
plt.ylabel("人均消耗试剂")
plt.title("试剂消耗和组数的关系")

plt.show()

```
![](https://cdn.luogu.com.cn/upload/image_hosting/bqrugpof.png)

从上面的图线可以看出
1. 感染率越高，最优的分组人数就越少。例如感染率为 $0.01$ 时，人均消耗的试剂在每一组为 $10$ 人时达到最低，感染率为 $0.20$ 时，这个最小值的人数为 $4$；
2. 感染率越高，这个最小值也会越大。

由于用最朴素的方法，每个人都需要消耗 $1$ 支试剂，因此我们看看什么时候能够让 $f(x)<1$。

$$1+1/x-(1-p)^x<1 \Rightarrow p<1-\dfrac{1}{x^{1/x}}$$

因此当感染率 $p$ 和混检人数 $x$ 满足上面的不等式关系时，混合检测就会优于传统的方法。

我们来看一看阈值（threshold）函数 $t(x)=1-1/x^{1/x}$ 的变化情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/p92rb30j.png)

求解函数最小值/最大值的通用方法是求导。对于 $t(x)$ 而言，有

$$t'(x)=\dfrac{1}{x^{1/x}}\cdot \dfrac{\ln x-1}{x^2}$$

因此当 $x=e$ 时，$t'(x)=0$，$t(x)$ 达到峰值为 $1-\dfrac{1}{e^{1/e}}$，约为 $0.308$。也就是说如果某种传染病的感染率超过了 $30.8\%$，混检就会变得毫无意义，因为不论分为多少组都会导致每人平均消耗超过 $1$ 份试剂。

现在回到之前的 $f(x)$，对 $x$ 求导得到：

$$f'(x)=-1/x^2-(1-p)^x\cdot \ln(1-p)$$

考虑到上述的 $f'(x)$ 中的 $x$ 出现在分母也出现在指数，因此是超越函数，一般无法求出其精确解，但是可以通过一些数学方法求出近似数值解。

例如，当 $p=0.05$ 时，可以求出 $f'(x)=0$ 的三个数值近似解

$$x_1=-3.9863,x_2=5.0224,x_3=132.6825$$

很明显 $x_1$ 是没用的，而上述的 $x_2$ 恰好就对应了输出样例的 $5$。如果检测方面有钱且任性，非要选择一种消耗试剂最多的方案，那么这个值就出现在 $132\sim133$ 左右。

---

## 作者：DeepSleep_Zzz (赞：3)

**begin**
# [P11045 传送门](https://www.luogu.com.cn/problem/P11045)
## 题外话
别看这是道绿题，只有公式和特判需要废废脑仁（but 这题好像只需要干这两件事）。

切入正题 $\downarrow$
# 分析题目
别看这道题一拿到手毫无头绪，实则题目中暗藏玄机。
>将 $N$ 个宠物**平均分**为若干组。

这说明 $K$ 为正整数，且被 $N$ 整除，再一看数据 $1 \le N \le 10^6$，直接开始枚举。
# 推公式（重难点）
设：$p$ 为感染率；$K$ 为每组宠物；$E$ 为测试剂数量消耗的最小数目（期望值）。

每组中所有宠物都没被感染的概率：
$$(1-p)^K$$
每组中至少有 1 个宠物被感染的概率：
$$1-(1-p)^K$$
此时我们可以分两种情况进行讨论：
- 组内所有宠物未被感染，消耗 $1$ 次测试剂。
- 组内有至少一只宠物被感染，消耗 $(K+1)$ 次测试剂。

综合两种情况可以得出：
$$E= \frac{N}{K} \cdot ((1-p)^K \cdot 1+((1-(1-p)^K) \cdot (K+1)))$$
# 特判（坑点）
重要的事情说三遍：**特判！特判！特判！**  
不然你就会一直 [95pts](https://www.luogu.com.cn/record/189889417) 。。。

其实发现了之后就很简单：当我们算出的最小测试剂数量 $E>N$ 时，只需要将 $K$ 设置为 $1$ 即可（这应该不难想吧）。
# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
const ld eps=1e-6; // 注意这里别写成 -1e6，别问我怎么知道的。。。
ll n,ans;
ld p,mine=1e18;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);   
    cin>>n>>p;
    for (ll k=2;k<=n;k++)
	{
        if (n%k) continue; // 过滤
        ld e=(n/k)*(pow(1.0-p,k)+(1.0-pow(1.0-p,k))*(k+1)); // 计算 E 
        if (e<mine-eps) // 维护最小 E
        {
            mine=e;
            ans=k;
        }
    }
    cout<<((mine-eps>n)?1:ans); // 特判 + 输出
    return 0;
}
```
**end**

---

## 作者：JoyLosingK (赞：2)

# 思路
刚刚拿到题目，觉得毫无头绪。

但是发现题目中的字眼：平均。意味着必定有 $n$ 能被 $k$ 整除。

所以我们只需要枚举所有的 $k$ 就行了。

那么显然，对于一个 $w$，期望的试剂数量 $E$ 为：

$E=P(w)+(1-P(w))(w+1)$ 

其中，$P(w)$ 为连续 $w$ 个宠物都没被感染的概率。

由于分组是平均的，根据乘法原理，有 $P(w)=(1-p)^w$ 。

注意特判，当 $k=1$ 时，期望为 $n$。
# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[1000001],ans;
double p,m=1e9+5;
const double eps=0.000001;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
	return x*f;} 
int main(){ cin>>n>>p;
	for(int k=2;k<=n;k++){ 
	    if(n%k) continue;
	    double y=((double)n/(double)k)*(pow(1.0-p,k)+(1.0-pow(1.0-p,k))*(k+1));
	    if(m>y-eps) ans=k,m=y;
	} if(m>n-eps) ans=1; //特判
	cout<<ans;
	return 0;
}
```

---

## 作者：ZY_king_YB (赞：1)

[传送门](https://luogu.com.cn/problem/P11045)

数学期望题。

观察题面，发现：

> 将 $N$ 个宠物**平均**分为若干组……

**将平均分这一信息记为 $I$。**

$\because I,\therefore K|N$。

于是考虑枚举 $K$。

$\forall w\in N_+$，令 $s$ 为期望的试剂数量，事件 $A$ 为连续 $w$ 个宠物都**没有被感染**，那么有：

$$s=P(A)+(1-P(A))(w+1)$$

由 $I$ 和乘法原理得：

$$P(A)=(1-p)^w$$

代入得：

$$s=(1-p)^w+(1-(1-p)^w)(w+1)$$

坑：注意特判 $K=1\to s=N$。

完整代码请读者自行补全。

---

## 作者：粥2414 (赞：1)

# 题目描述
将 $n$ 只宠物**恰好**分为 $k$ 块，每只宠物有 $p$ 的概率被感染。如果块内有被感染的宠物，那么需要 $k+1$ 支药剂来检测，否则只需要 $1$ 支。特别地，当 $k=1$ 时，无论如何都只需要一支药剂来检测一个块内的宠物。

求一个最小的 $k$，使得使用药剂数量的期望最小。
# 思路
考虑枚举每一个 $k$。

观察到各个块之间相互不影响，所以可以求单独某个块内需要药剂的期望，然后乘以块数就是答案。

于是题目转换为：  
求长度为 $k$ 的块内**存在**被感染的宠物的概率。

这显然不好求。  
于是考虑求**不存在**宠物被感染的概率。

显然它等于 $(1-p)^{k}$。此时使用**快速幂**就可以直接写了。也可以**预处理**概率。

然后就可以愉快地 AC 啦！
# 代码
我采用的是第二种预处理办法。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define dl long double
const ll N=1e6+9,esp=1e-7;
ll n;
dl p;
dl sum[N];
ll ans;
dl minn=1000000000;
int main(){
	cin>>n;
	scanf("%Lf",&p);
	sum[0]=1;
	for(int i=1;i<=n;i++){//前缀积？
		sum[i]=sum[i-1]*(1.0-p);
	}
	for(int i=1;i<=n;i++){
		ll j=n%i,k=n/i;
		dl now=0;
		if(j!=0)continue;
		if(i!=1)now=1*sum[i]+(1+i)*(1-sum[i]);
		else now=1;
		if(minn-now*k>esp){
			ans=i,minn=now*k;
		}
	}
    cout<<ans;
	return 0;
}
```

---

## 作者：Aron_2023 (赞：1)

## 前言

作为初中生，感觉数学概率与期望真的抽象。

今年的 `CSP` 没考好，心情有点差，来刷几道题。

## 数学概率与期望

### 概率
概率是用来描述一个随机事件发生的可能性的度量。它是一个介于 $0$ 和 $1$ 之间的数字，其中 $0$ 表示事件不可能发生， $1$ 表示事件肯定会发生。概率可以用公式来表示：

$$P(A)=\dfrac{n(A)}{n(S)}$$

其中，$P(A)$ 是事件 $A$ 发生的概率，$n(A)$ 是事件 $A$ 发生的可能结果的数量， $n(S)$ 是所有事件的可能结果的数量。

设我们有装有 $10$ 个球的袋子，这个袋子里面有形状相同的 $3$ 个红球和 $7$ 个黄球，则从袋子中选择一个红球的概率为：

$$P(A)=\dfrac{6}{10}=0.6$$

### 数学期望

数学期望（也称为均值）是一组数字的平均值。它是用来表示一个随机事件的可能性的度量。在概率论中，数学期望可以看作是对每个可能结果进行求和，每个结果的权重就是它发生的概率。

数学期望是在随机事件中，所有可能结果的加权平均值。它表明一个随机事件中，我们预期的结果是什么。数学期望可以用公式来表示：

$$E(X)=\sum_{i=1}^n x_ip_i$$
 
其中， $E(X)$ 是事件的数学期望，$x_1,x_2,x_3,…,x_n$ 是事件中所有可能的结果，$p_1,p_2,p_3,…,p_n$ 是每个结果发生的概率。从公式中可以看出，数学期望是所有可能结果的乘积的和。

例如，我们有一个 $6$ 面的骰子。对于每个骰子面，我们可以得到一个数字，分别为 $1$ 、 $2$ 、 $3$ 、 $4$ 、 $5$ 和 $6$ 。每个数字的概率是相等的，即 $\dfrac{1}{6}$ 。因此，这个骰子的数学期望是：

$$E(X)=\dfrac{1}{6}(1+2+3+4+5+6)=3.5$$

这意味着，如果我们将骰子投掷多次，我们可以预计每次投掷的结果将近接于 $3.5$ 。

## 分析

有了上面的知识，这道题就迎刃而解了。

本题需要找到一个分组大小 $K$ ，使得测试剂的期望消耗数量最小。可以计算不同分组大小下的期望测试剂消耗数量。

对于每个组，测试剂的期望消耗数量 $E(K)$ 可以表示为：

$$E(K)=(1-p_k)+p_k \times K$$

其中 $p$ 是宠物被感染的概率， $(1-p_k)$ 是组内所有宠物都没有被感染的概率， $p_k$ 是组内至少有一只宠物被感染的概率。

只需要找到一个 $K$ 值，使得 $E(K)$ 最小。可以通过遍历所有可能的 $K$ 值并计算 $E(K)$ 来实现。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000007],ans;
double p,maxp=LONG_LONG_MAX;
int main()
{
	double eps=0.000001;//精度误差 
	cin>>n>>p;
	for(int k=2;k<=n;k++)
	{ 
	    if(n%k!=0) continue; //枚举每一种符合条件的 K 
	    double E=((double)n/(double)k)*(pow(1.0-p,k)+(1.0-pow(1.0-p,k))*(k+1));//计算数学期望 
	    if(maxp>E-eps) ans=k,maxp=E; //打擂台 
	}
	if(maxp>n-eps) cout<<1;
	else cout<<ans;
	return 0;
}
```

---

## 作者：VelvetChords (赞：1)

# P11045 [蓝桥杯 2024 省 Java B] 最优分组
## 0.前言
95 分代码卡得我想干掉电脑！
## 1.分析问题
寻找一个最优的分组大小 $K$，以最小化在宠物检测中测试剂的期望消耗。给定总宠物数量 $n$ 和每只宠物被感染的概率 $p$，需要计算不同分组大小下的期望消耗，并选择使得期望消耗最小的 $K$。
## 2.分析
本题的核心在于推公式。

因为每组中有 $K$ 只宠物，所以该组中所有宠物未被感染的概率为：

$\operatorname{prob}=(1−p)^K$

所以该组中至少有一只宠物被感染的概率为：

$1-\operatorname{prob}=1-(1−p)^K$

- 如果该组全部未被感染，则消耗 1 次测试剂。
- 如果该组中至少有一只宠物被感染，则消耗 $K+1$ 次测试剂（包括检测感染的次数和测试所有宠物）。
  
所以得到公式：

$\operatorname{expected}=(\operatorname{prob}\times 1)+((1−\operatorname{prob})\times (K+1))$

而代入 $\operatorname{prob}$ 后得到：

$\operatorname{expected}=(1−p)^K+((1−(1−p)^K)\times (K+1))$

最后整理可得：

$\operatorname{expected}=\frac{n}{K}(1−p)^K+((1−(1−p)^K)\times (K+1))$

公式推完以后，题目就很好写了。

特别提醒：注意特判，当 $k=1$ 的时候，期望为 $n$，不然喜提 95pts。(因为这个卡了超久！！！)

## 3.代码
```c++
#include <bits/stdc++.h>
using namespace std;
int n,ans;
double p,epsilon=1e-9,mi=1e18;
int main() 
{
    ios::sync_with_stdio(false);
    cin.tie(0);   
    cin>>n>>p;
    for(int k=2;k<=n;k++) 
	{
        if (n%k==0) 
		{
            double prob=pow(1.0 - p, k);
            double expected=((double)n/(double)k)*(prob+(1.0-prob)*(k+1));
            if(expected<mi-epsilon) 
			{
                mi=expected;
                ans=k;
            }
        }
    }
    if(mi-epsilon>n) ans=1;
    cout<<ans;
    return 0;
}
```

---

## 作者：Houkiseino_Kokoro (赞：1)

#### 解法

题目隐含了一个条件为需要保证 $K \mid N$，也就是说并不需要分析若 $K \nmid N$ 时分组会分出不足 $K$ 只宠物的组的情况。有这个条件便省去了分析上面所述的情况的困难，让题目难度下降了不少，属于是出题人的慈悲了。

下面开始分析。

记 $c = \dfrac{N}{K}$ 为分组数量，$E$ 为期望值。当 $K \ge 2$ 时，首先需要消耗 $c$ 支试剂为每一组做一次检验。随后，设检测结果为阳性的组数为 $x$，容易发现 $x$ 服从[二项分布](https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83)，试验成功概率即每组检测结果为阳性的概率为 $1-{(1-p)}^K$；实验次数为分组数量 $c$。则需要额外逐个花费试剂进行检验的期望值为 $cK(1-{(1-p)}^K) = N(1-{(1-p)}^K)$，则有

$$E = \dfrac{N}{K} + N(1-{(1-p)}^K)$$

由于 $1 \le N \le 10^6$，因此可以枚举所有的 $K$ 得到答案，时间复杂度为 $O(N)$。注意需要特判 $K = 1$ 时 $E = N$。

#### 代码

```cpp
int main()
{
    int n;
    long double p;
    std::cin >> n >> p;
    long double est = n;
    int ans = 1;
    for (size_t k = 2; k <= n; k++)
    {
        if (n % k == 0)
        {
            long double cur = 1.0 * n / (1.0 * k) + 1.0 * n * (1 - pow(1 - p, k));
            if (est > cur)
            {
                ans = k;
                est = cur;
            }
        }
    }
    std::cout << ans;
    return 0;
}
```

---

## 作者：JYX0924 (赞：0)

这是一道非常简单的期望题。

考虑到若每个组有 $k$ 个宠物，共有 $t$ 组，一组检测结果为阳性相当于至少一个为阳性，即 $q=1-(p-1)^k$，期望 $E(k)=q \times n + t$，注意 $E(1)=n$。

因为每一个 $k$ 都是 $n$ 的因数，因此我们枚举所有 $k$ 即可。

下面是我的代码。


```cpp
#include<bits/stdc++.h>
#define ll long long 
#define db double 
using namespace std;
ll n,ans;
db p,zd;
db cal(db x,ll y)
{
	db ret=1,tt=x;
	while(y)
	{
		if(y&1) ret*=tt;
		y>>=1; tt*=tt;
	}
	return ret;
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>p; zd=n; ans=1;
	for(int i=2;i<=n;i++)
	{
		if(n%i) continue;
		db tt=1-cal(1-p,i); tt=tt*n+n/i;
		if(tt<zd) zd=tt,ans=i;
	}
	cout<<ans;
	return 0;
}
```
谢谢大家！！！

---

## 作者：wangyoujia (赞：0)

# 华丽开场
## - [题目传送门](https://www.luogu.com.cn/problem/P11045)

- 这道题可以运用暴力枚举的方式来做
- 因为如果你仔细去看这道题的话就会发现这句话：“将 $N$ 个宠物平均分为若干组”。同时，小蓝不可能把宠物分割了，所以完全可以枚举单独检查的宠物数量。
- 最后在通过打擂台的方式，求出如何使期望的测试剂的消耗数目最少。
```java
import java.util.Scanner;

public class Main {

    public static void main(String ...args) { new Main().run(); }

    void run() {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt(), x = 1;
        double p = in.nextDouble(), q = 1 - p, y = N;
        for (int k = 2; k <= N; ++k) {
            q = q * (1 - p);
            if (N % k != 0) continue;   判断是否平分（关键点）
            double g = N / k + N * (1 - q);
            if (g < y) {
                y = g;
                x = k;
            }
        }
        System.out.print(x);
    }
}
```


# 华丽结尾

---

## 作者：SSqwq_ (赞：0)

简单推式子题。

## 分析

由于期望有线性相加原理，故我们很容易想到，若连续 $k$ 个宠物都是正常的概率为 $P(k)$，则当选定 $k$ 时，期望使用的试剂数量为：

$$P(k)\times 1+(1-P(k))\times (k+1)$$

注意特判，至少有这么一组解：$k=1$，此时期望为 $n$。

然后由于乘法原理，注意到 $P(k)=(1-p)^k$，然后做完了。

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000001],ans=1;
double p,minn=2e9;
const double eps=0.000001;
void work(){
	cin>>n>>p;
	minn=n;
	for(int i=n;i>=2;--i){
		if(n%i!=0)continue;
		if(minn>((double)n/(double)i)*(pow(1.0-p,i)+(1.0-pow(1.0-p,i))*(i+1))-eps){
			minn=((double)n/(double)i)*(pow(1.0-p,i)+(1.0-pow(1.0-p,i))*(i+1));
			ans=i;
		}
	}
	cout<<ans<<"\n";
}
signed main(){
//	freopen(".in"."r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--){
		work();
	}
	return 0;
}

```

---

## 作者：HPXXZYY (赞：0)

$\color{blue}{\texttt{[Analysis]}}$

首先得注意这么一点：$k$ 必须得是 $n$ 的因数（这里的 $n,k$ 对应于题目的 $N,K$），不然不合法。

> 其实这虽然是限制，但是这个限制其实是使得题目的难度大大降低了。因为这样每组的宠物数量相同，有完全相同的规律，不需要特殊讨论。

每组 $k$ 只宠物，一共需要分成 $c=\dfrac{n}{k}$ 组。

对于每组宠物，假设被感染的宠物数量为 $x$。调动我们残存的高中知识，我们惊喜地发现，$x$ 服从二项分布。于是我们知道 $E(x)=kp$。

但是这并没有什么用。我们需要知道的是有宠物感染病毒的概率。正难则反，没有宠物感染病毒的概率是 $p^{k}$，所以有宠物感染病毒的概率就是 $\left ( 1 - p^{k} \right )$。

一旦有动物感染，就需要重新进行 $k$ 次测试。于是每一组测试次数的期望值是 $k+k \times \left (1 - p^{k} \right )$。

一共有 $c$ 组，由期望的线性可加性知，总的期望即为 $n \times \left [ k + k \times \left ( 1 - p^{k} \right ) \right ]$，化简即为 $nk+n \times \left ( 1 - p^{k} \right )$。

一个快速幂，加上枚举即可。总时间复杂度 $O(n \log n)$。不过这个时间复杂度好像有点问题？反正就是线性对数就对了。

> 另外：不要忘记特判 $k=1$ 的情况。$k=1$ 时的检测次数就是 $n$！！！


$\color{blue}{\text{Code}}$

```cpp
int n,ans;double p,minn;

double ksm(double u,int v){
	快速幂自己写，太简单啦
}

double f(int k){
	return n/k+n*(1-ksm(1-p,k));
}

int main(){
	cin>>n>>p;
	
	minn=n;ans=1;//特判 k=1
	
	for(int i=2;i<=n;i++)
		if (n%i==0){
			double tmp=f(i);
			
			if (tmp<minn){
				minn=tmp;
				ans=i;
			}
		}
	
	printf("%d",ans);
	
	return 0;
}
```

---


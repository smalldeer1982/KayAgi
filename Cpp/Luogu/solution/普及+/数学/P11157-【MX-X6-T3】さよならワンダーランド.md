# 【MX-X6-T3】さよならワンダーランド

## 题目背景

原题链接：<https://oier.team/problems/X6D>。

---

> _ほら行くよって$\\$
手を引いてくれた君は$\\$
綺麗な目して言うんだ$\\$
僕らあの頃と$\\$
何も変わらないから$\\$
せめて$\\$
二人で夢を見させて_
>
>_—— [さよならワンダーランド - Nanatsukaze](https://music.163.com/#/song?id=2053736409)_

能够带你进入孩童时期的梦境中的那个人，该在哪里寻找呢？

## 题目描述

给定序列 $a_1, a_2, \dots, a_n$，请对于每一个 $1\sim n$ 的整数 $i$ 求任意一个整数 $j$ 使得以下条件同时成立，或判断不存在这样的 $j$：

- $1\leq i+j\leq n$；
- $a_i \leq j \leq a_{i+j}$。


## 说明/提示

**【样例解释 #1】**

$i=1,j=2$ 时，$a_i=-1$，$a_{i+j}=4$，满足 $a_i\leq j\leq a_{i+j}$。

$i=2,j=1$ 时，$a_i=1$，$a_{i+j}=4$，满足 $a_i\leq j\leq a_{i+j}$。

$i=3$ 时可以证明不存在符合条件的 $j$。

**【数据范围】**

对于所有数据，保证 $1\leq n \leq 3\times 10^5$，$-10^9\leq a_i\leq 10^9$。

**捆绑测试**，共 3 个 Subtask，具体限制如下所示：

- Subtask 1（17 pts）：$n\leq 1000$。
- Subtask 2（39 pts）：对所有 $1\leq i\leq n$ 保证 $a_i\leq -i$。
- Subtask 3（44 pts）：无特殊限制。

## 样例 #1

### 输入

```
3
-1 1 4```

### 输出

```
1 2
1 1
0```

## 样例 #2

### 输入

```
5
1 -1 0 2 -3```

### 输出

```
0
1 -1
1 0
0
1 -3```

# 题解

## 作者：nueryim (赞：16)

## 题解：P11157 【MX-X6-T3】さよならワンダーランド

### 题意

为了便于分析题意，我们设 $i+j$ 为 $k$。

则问题变成：给定序列 $a_1,\cdots,a_n$，对每个 $i$ 求一个 $k$，使 $k$ 满足：

* $1 \leq k \leq n$
* $a_i \leq k-i \leq a_k$

### 分析

我们可以通过化简式子较严格地确定 $k$ 的上界和下界，首先看下界：

* $1 \leq k$
* 由 $a_i \leq k - i$ 得 $a_i+i \leq k$

所以 $k$ 最小取到 $\max(1,a_i+i)$。

再看上界：

* $k \leq n$
* 由 $k-i \leq a_k$ 得 $k-a_k \leq i$

我们可以用下界来缩小 $k$ 的范围，用上界来判断 $k$ 是否有解。

首先如果 $k$ 取最小仍大于 $n$ 那么无解。

否则我们只需要确定是否有 $k-a_k \leq i$，也就是说只要在 $k$ 的取值范围内有 $(k-a_k)$ 的最小值小于等于 $i$ 就有解，否则无解。

这里 $k$ 的取值范围为 $\max(1, a_i+i) \leq k \leq n$， 所以我们可以 $\mathcal{O(n)}$ 预处理。用 $mn[k]$ 表示 $k \sim n$ 中 $k-a_k$ 的最小值，相应的 $mi[k]$ 表示 $k \sim n$ 中 $k-a_k$ 最小时 $k$ 的取值。

### 代码

没什么好说的了，先 $\mathcal{O(n)}$ 预处理 $mn$ 数组和 $mi$ 数组，再 $\mathcal{O(n)}$ 判断。

```cpp
//P11157 (AC)

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

typedef pair <int, int> pii;

int read()
{
    int res = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = -1;
    for (; isdigit(ch); ch = getchar())
        res = (res << 3) + (res << 1) + (ch - '0');
    return res * f;
}

const int N = 3e5 + 5;
const int INF = 0x3f3f3f3f;

int n;
int a[N];
int mi[N], mn[N];

int main()
{
    int i, k;

    n = read();
    for (i = 1; i <= n; i ++)
        a[i] = read();

    mn[n + 1] = INF;
    for (i = n; i >= 1; i --)
    {
        mn[i] = mn[i + 1];
        mi[i] = mi[i + 1];
        if (i - a[i] < mn[i])
        {
            mn[i] = i - a[i];
            mi[i] = i;
        }
    }

    for (i = 1; i <= n; i ++)
    {
        k = max(a[i] + i, 1);
        if (i >= mn[k] && k <= n)
            printf("1 %d\n", mi[k] - i);
        else
            printf("0\n");
    }

    return 0;
}
```

---

## 作者：Drifty (赞：5)

### Preface

赛时写这道题因为忘记把调试输出删掉盯着 `std` 唐了半个小时。

### Solution

设 $k = i + j$，则由题意知：

$$
1\le k\le n\\
a_i \le k - i \le a_k
$$

变形一下得到：

$$
1\le k\le n \\
a_i + i\le k \\
i \ge k - a_k
$$

下文记 $b_p = p - a_p$，$c_p = \min_{m = p}^n b_m$。

我们考虑从 $1$ 到 $n$ 枚举 $i$。

若 $a_i + i > n$ 则上述不等式矛盾，不存在这个 $j$。

否则我们有 $k\ge\max\{a_i + i, 1\}$，下文记 $k_{\min} = \max\{a_i + i, 1\}$，由于题目只需要存在一个 $j$，也就等价于存在一个 $k$，使得 $i\ge b_k$ 即可。

因此，若 $i < c_{k_{\min}}$ 则一定不存在这样的 $k$，也就不存在 $j$。反之若 $i \ge c_{k_{\min}}$，则就得到一个合法的
$j = k_{\min} - i$。输出即可。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 3e5 + 3;
int n, a[N], b[N], id[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
	cin >> n; id[n] = n;
	for (int i = 1; i <= n; i ++) cin >> a[i], b[i] = i - a[i];
	for (int i = n - 1; i; i --) {
		id[i] = id[i + 1];
		if (b[i] < b[i + 1]) id[i] = i;
		b[i] = min(b[i], b[i + 1]); 
	}
	for (int i = 1; i <= n; i ++) {
		int k = max(a[i] + i, 1);
		if (k > n) cout << 0 << '\n';
		else if (i < b[k]) cout << 0 << '\n';
		else cout << 1 << ' ' << id[k] - i << '\n';
	}
	return 0;
}
```

---

## 作者：vorDeal (赞：4)

能够进入孩童时期的梦境中的那个自己，已是很难找见了。

思维题。代码短小精悍，但思路难想。

$j$ 符合以下条件：

- $1\leq i+j\leq n$；
- $a_i \leq j$；
- $j \leq a_{i+j}$。

发现条件 3 中 $j$ 出现了两次，且是一个变量，难以处理，考虑消去。

令 $k=i+j$，$b_i=a_i-i$。

将条件改写为：

- $1 \leq k \leq n$；
- $k \geq a_i+i$；
- $b_k+i \geq 0$。

由于输出任意一个 $j$ 即可，将存在性问题转化为最值问题，即：对于任意 $k \geq a_i+i$，求 $b_k+i$ 之最大值，若为正，则存在 $j$。

利用一个数组维护序列 $b$ 的后缀最大值，再对每个 $i$ 分别求答案即可。

时间复杂度 $O(n)$，可以通过本题。

**AC Code：**
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 3e5 + 5;
int n, a[maxn], b[maxn], c[maxn];

int main()
{
    cin >> n, c[n] = n;
    for (int i = 1; i <= n; i++)
        cin >> a[i], b[i] = a[i] - i;
    for (int i = n - 1; i > 0; i--)
        c[i] = b[i] > b[c[i + 1]] ? i : c[i + 1];
    for (int i = 1; i <= n; i++)
        if (i + a[i] > n || b[c[max(1, i + a[i])]] + i < 0)
            cout << "0\n";
        else
            cout << "1 " << c[max(1, i + a[i])] - i << endl;
    return 0;
}
```

值此国庆佳节之际，谨祝全国各族人民 CSP-J/S 2024 RP++！

---

## 作者：_Jocularly_ (赞：4)

考虑拆分不等式 $a_{i} \le j \le a_{i+j}$，把联立不等式拆成两部分讨论，那么我们需要满足 $a_{i} \le j$ 且 $j \le a_{i+j}$，观察发现左侧可以变为 $i+j$ 的形式，即为 $a_{i}+i \le i+j$，右侧可以化为 $a_{i+j}-(i+j)\ge -i$，那么题目显然可以化为在数组中 $i+a_{i}$ 的右侧寻找满足不等式的 $i+j$，直接给 $a_{i+j}-(i+j)$ 取倒序最大值即可，输出答案时 $O(1)$ 回答。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
int n;
int a[300005];
int pos[300005],maxn[300005];
signed main(){
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
        maxn[i] = -1e18;
    }
    for(int i=1;i<=n;i++){
        pos[i] = i - a[i];
        //防止越界
        pos[i] = max(pos[i],1ll);
        pos[i] = min(pos[i],n + 1);
        maxn[pos[i]] = max(maxn[pos[i]],i);
    }
    for(int i=2;i<=n;i++){
        maxn[i] = max(maxn[i],maxn[i-1]);
    }
    for(int i=1;i<=n;i++){
        int ans = maxn[i] - i;
        if(a[i] <= ans) cout << "1 " << ans << endl;
        else cout << "0" << endl;
    }
    return 0;
}
```

---

## 作者：ylch (赞：2)

[Luogu - P11157](https://www.luogu.com.cn/problem/P11157)

## Description

给定序列 $a_1, a_2, \dots, a_n$，请对于每一个 $1\sim n$ 的整数 $i$ 求任意一个整数 $j$ 使得以下条件同时成立，或判断不存在这样的 $j$：

- $1\leq i+j\leq n$；
- $a_i \leq j \leq a_{i+j}$。

对于所有数据，保证 $1\leq n \leq 3\times 10^5$，$-10^9\leq a_i\leq 10^9$。

## Analysis

这道题一看就知道是数据结构维护题，所以我们的目的就是找出这个数据结构**维护的对象**和**查询的范围**。

题目的核心为第二条不等式：$a_i \leq j \leq a_{i+j}$。

发现其中有三个量：$a_i,j,a_{i+j}$，我们肯定要从这三个量入手，去推它们的取值范围。

- $a_i$

  根据题目给的不等式，求出 $a_i$ 的取值范围：

   $$\left\{
   \begin{array}{l}
   i+j\leq n \\
   a_i \leq j
   \end{array}
   \right.
   \Rightarrow \left\{
   \begin{array}{l}
   j\leq n - i \\
   a_i \leq j \leq n - i
   \end{array}
   \right.
   $$

  **由此可得，若 $a_i > n-i$，则位置 $i$ 无解。**

- $j$

  由于 $j$ 既限制着 $a_i$，又与 $a_{i+j}$ 有关，所以，我们猜测它一定是重要的：

   $$\because \left\{
  \begin{array}{l}
  1 \le i+j \\
  i+j \le  n
  \end{array}
  \right.
  \Rightarrow \left\{
  \begin{array}{l}
  1 - i \le j \\
  j \le n-i
  \end{array}
  \right.
  $$

  $$\therefore 1-i \le j \le n-i$$

   根据题意，我们此时可以有一个确定的 $i$，由于 $n$ 也确定，我们可以得出 $j$ 的范围。

- $a_{i+j}$

   发现 $a_{i+j}$ 与 $i+j$ 的范围有关，问题转化为确定 $i+j$ 的范围：

  $$\because a_i \le j,\ i+j \le n$$
  $$\therefore i+a_i \le i+j \le n$$

观察，我们发现 $j$ 的范围好像并没有什么用（~~被耍了吧，嘿嘿~~），但 $i+j$ 这个范围却很有用。

## Solution

根据上面的推导，只要 $i+j$ 的范围合法，那么 $a_i \le j$ 的要求一定也满足。（$i+a_i \le i+j \Rightarrow a_i \le j$）

然后看 $j \le a_{i+j}$，即 $a_{i+j}-j \ge 0$。题目中说可以找任意符合条件的 $j$，那么如果想要尽可能地满足 $a_{i+j}-j \ge 0$ 的条件，$a_{i+j}-j$ 的值肯定是**越大越好**。


---


但是 $a_{i+j}-j$ 这个东西并不好维护，因为随着 $i$ 的改变，$j$ 并不固定。我们考虑转换为维护 $a_{i+j}-(i+j)$。

这样 $i+j$ 既是下标，又是减数，故对于每个 $a_x$，只要统一维护 $a_x - x$ 即可，维护对象固定。

又因为所有的元素都会多减一个 $i$，所以相对大小并没有影响。在最后判断的时候再加回来即可。

至此，我们知道了我们最开始的问题：

1. 数据结构应维护区间最大值，对象为 $a_x-x$。
2. $i$ 确定，查询的范围应为 $[i+a_i, n]$。

对于维护区间最值，这里选择使用线段树进行维护；当我们确定了最大值后，再判断下标是否符合条件即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAX_LEN = 3e5 + 7;
struct Node {
	int x, pos;
	friend bool operator < (Node p1, Node p2) {
		return p1.x < p2.x;
	}
} arr[MAX_LEN], seg_tree[MAX_LEN << 2];
int Lazy[MAX_LEN << 2];

//从下往上更新 节点
void push_up (int root) {
	seg_tree[root] = max(seg_tree[root << 1], seg_tree[root << 1 | 1]);      //最小值改min
}

//从上向下更新，左右孩子
void push_down (int root, int L, int R) {
	if (Lazy[root]) {
		Lazy[root << 1] += Lazy [root];
		Lazy[root << 1 | 1] += Lazy[root];
		int mid = (L + R) >> 1;
		seg_tree[root << 1].x +=  Lazy[root] * (mid - L + 1);
		seg_tree[root << 1 | 1].x += Lazy[root] * (R - mid);
		Lazy[root] = 0;
	}
}

//建树
void build (int root, int L, int R) {
	Lazy[root] = 0;
	if (L == R) {
		seg_tree[root] = arr[L];
		return ;
	}
	int mid = (L + R) >> 1;
	build(root << 1, L, mid);
	build(root << 1 | 1, mid + 1, R);
	push_up(root);
}

//查找区间[LL,RR]的最大值
Node query (int root, int L, int R, int LL, int RR) {
	if (LL <= L && R <= RR) return seg_tree[root];
	push_down(root, L, R);     //每次访问都去检查Lazy 标记
	Node Ans = {(int)-1e9-5, -1}; // 注意初始值赋值为最小值
	int mid = (L + R) >> 1;
	if (LL <= mid) Ans = max(Ans, query(root << 1, L, mid, LL, RR));   //最小值改min
	if (RR > mid) Ans = max(Ans, query(root << 1 | 1, mid + 1, R, LL, RR)); //最小值改min
	return Ans;
}

int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &arr[i].x);
        arr[i].x = arr[i].x - i;
		arr[i].pos = i;
	}
	build(1, 1, n);
	for (int i = 1; i <= n; i ++) {
        int ai = arr[i].x + i; // 表示a[i]，注意要把之前多减的i加回来
		if (ai > n - i) { 
			cout << "0\n";
			continue;
		}

		Node temp = query(1, 1, n, max(i + ai, 1), n); // 这里防止i+a[i]<=0的情况发生
		int aij = temp.x + temp.pos; // 表示a[i+j]，注意要把之前多减的加回来
        int j = temp.pos - i;
        if (ai <= j && j <= aij) { // 题面中说a[i]<=j<=a[i+j]
			cout << 1 << ' ' << j << '\n';
		}
        else cout << "0\n";
	}
	return 0;
}
```

## End

管理员大大辛苦啦~

谢谢大家！

---

## 作者：DrAlfred (赞：2)

摘要：ST 表，参变分离

[传送门：https://www.luogu.com.cn/problem/P11157](https://www.luogu.com.cn/problem/P11157)

## 题意

给定一个长度为 $n$ 的序列 $a$，请对于每个 $i = 1, 2, \dots, n$，判断是否存在满足下列条件的 $j$，若存在，还需给出构造：

- $1 \le i + j \le n$；
- $a_i \le j \le a_{i + j}$。

## 分析思路

这题正解是个很好的 trick，没想到没见过居然能场切。

首先先对 $j$ 的范围有一些基本的刻画：$1 - i \le j \le n - i, j \ge a_i$。于是我们有 $\max(1 - i, a_i) \le j \le n - i$，这可以让我们完成初步的无解判定，以及写出一个 $O(n^2)$ 的暴力。分析暴力，我们发现 $j \le a_{i + j}$ 还是比较棘手，因为下标中带有 $j$ 而且不是纯粹的 $j$。

于是，我们可以考虑**参变分离**。令 $k = i + j$。则我们可以整理得到以下两个式子：

- $\max(1, a_i + i) \le k \le n$；
- $k - i \le a_k$，即 $i \ge k - a_k$。

注意到第一个式子实际上是刻画了 $k$ 的范围，而第二个式子是对选定 $k$ 的合法性的判断。显然我们在 $k$ 可取的范围内，取到最小的 $k - a_k$ 是一定不劣的。我们枚举 $i$，使用 ST 表对二元对 $(k - a_k, k)$ 取 $\min$ 合并，再进行一下判定即可。若合法答案即为 $j = k - i$。

时间复杂度 $O(n \log n)$，可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
const int N = 300010;
template <class T>
struct MinInfo {
    T val;
    MinInfo(void) { val = std::numeric_limits<T>::max(); }
    template <class InitT>
    MinInfo(InitT x) { val = x; }
    MinInfo operator+(MinInfo &x) {
        return {std::min(val, x.val)};
    }
};
template <class T>
class SparseTable {
private:
    int n;
    std::vector<std::vector<T>> ST;

public:
    SparseTable(void) {}
    SparseTable(int N) : n(N), ST(N, std::vector<T>(std::__lg(N) + 1)) {}
    template <class InitT>
    SparseTable(std::vector<InitT> &init) : SparseTable(init.size()) {
        for (int i = 0; i < n; i++) ST[i][0] = T(init[i]);
        for (int i = 1; (1 << i) <= n; i++) {
            for (int j = 0; j + (1 << i) - 1 < n; j++) {
                ST[j][i] = ST[j][i - 1] + ST[j + (1 << (i - 1))][i - 1];
            }
        }
    }
    inline T query(int l, int r) { // 0 based
        if (l > r) return T();
        int w = std::__lg(r - l + 1);
        return ST[l][w] + ST[r - (1 << w) + 1][w];
    }
};
int n, a[N], t[N];
inline void optimizeIO(void) {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
}
int main(int argc, char const *argv[]) {
    optimizeIO(), cin >> n;
    vector<pair<int, int>> t(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i], t[i] = {i - a[i], i};
    }
    SparseTable<MinInfo<pair<int, int>>> ST(t);
    for (int i = 1; i <= n; i++) {
        int l = max({1 - i, a[i]}), r = n - i;
        if (l > r) {
            cout << "0\n";
            continue;
        }
        l += i, r += i; // k \in [l, r]
        auto res = ST.query(l, r).val;
        int k = res.second, val = res.first;
        if (i >= val) {
            cout << "1 " << k - i << '\n';
        } else {
            cout << "0\n";
        }
    }
    return 0;
}

```

---

## 作者：Super_Cube (赞：1)

# Solution

$1\le i+j\le n\Rightarrow 1-i\le j\le n-i$，且有 $a_i\le j\le a_{i+j}$，可得到下面这份代码。

```cpp
#include<bits/stdc++.h>
int a[300005];
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;scanf("%d",&a[i++]));
	for(int i=1;i<=n;++i){
		for(int j=std::max(1-i,a[i]);j<=n-i;++j)
			if(a[i+j]>=j){
				printf("1 %d\n",j);
				goto nxt;
			}
		puts("0");
		nxt:;
	}
	return 0;
}
```

把枚举 $j$ 改为枚举 $s=i+j$，那么可改写上述代码为下面这样。

```cpp
#include<bits/stdc++.h>
int a[300005];
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;scanf("%d",&a[i++]));
	for(int i=1;i<=n;++i){
		for(int s=std::max(1,a[i]+i);s<=n;++s)
			if(a[s]>=s-i){
				printf("1 %d\n",s-i);
				goto nxt;
			}
		puts("0");
		nxt:;
	}
	return 0;
}
```

也就是说我们要在后缀中找到一个 $s$ 满足 $a_s-s\ge -i$。

所以只需要在后缀中找到最大的 $a_s-s$ 来判断这一条件即可，那么随便找个数据结构来搞定查找最大值及其下标。我用的 ST 表。

时间复杂度：$O(n\log n)$。

```cpp
#include<bits/stdc++.h>
int st[19][300005];
int a[300005];
inline int merge(int x,int y){
	return a[x]-x>a[y]-y?x:y;
}
inline int ask(int l,int r){
	static int k;k=std::__lg(r-l+1);
	return merge(st[k][l],st[k][r-(1<<k)+1]);
}
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]),st[0][i]=i;
	for(int j=1;(1<<j)<=n;++j)
		for(int i=1;i+(1<<j)-1<=n;++i)
			st[j][i]=merge(st[j-1][i],st[j-1][i+(1<<j-1)]);
	for(int i=1,s;i<=n;++i){
		if(i>n-a[i])puts("0");
		else{
			s=ask(std::max(1,a[i]+i),n);
			if(a[s]-s>=-i)printf("1 %d\n",s-i);
			else puts("0");
		}
	}
	return 0;
}
```

---

## 作者：EricWan (赞：1)

设 $k=i+j$，通过题目中的式子，得到：

$$1\le k\le n$$

$$a_i+i\le k$$

$$k\le a_k+i$$

第一个式子默认已经被考虑了，对于第三个限制，我们 $i$ 从小向大枚举，用树状数组维护有效的 $k$ 即可。对于第二个限制，我们随便查询一个大于等于 $a_i+i$ 的 $k$，通过 $j=k-i$ 输出即可。

废话不多说，直接看代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) ((x)&-(x))
#define MAXN 1000005
using namespace std;
int n, a[MAXN], t[MAXN];
vector<int> newk[MAXN];
void update(int x) {
	while (x <= n) {
		t[x]++;
		x += lowbit(x);
	}
}
int query(int x) {
	int ans = 0;
	while (x) {
		ans += t[x];
		x ^= lowbit(x);
	}
	return ans;
}
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		int mini = max(1, i - a[i]);
		if (mini > n) {
			continue;
		}
		newk[mini].push_back(i);
	}
	for (int i = 1; i <= n; i++) {
		for (int j : newk[i]) {
			update(j);
		}
		int mink = max(1, a[i] + i);
		if (mink > n) {
			cout << 0 << endl;
			continue;
		}
		int maxk = n;
		int cntk = query(maxk) - query(mink - 1);
		if (cntk == 0) {
			cout << 0 << endl;
			continue;
		}
		else {
			cout << "1 ";
		}
		while (mink < maxk) {
			int mid = (mink + maxk) / 2;
			if (query(mid) - query(mink - 1)) {
				maxk = mid;
			}
			else {
				mink = mid + 1;
			}
		}
		cout << mink - i << endl;
	}
	return 0;
}
```

---

## 作者：woshilaoliu7 (赞：1)

# P11157 题解
2024/10/05 更新：改了点笔误
## 题意
给定正整数 $n$ 与序列 $a_1,a_2,\dots,a_n$，对每一个 $1 \thicksim n$ 之间的整数 $i$ 求**任意一个**整数 $j$ 使以下条件同时成立，或判断不存在符合要求的 $j$：
- $1 \le i + j \le n$
- $a_i \le j \le a_{i+j}$

&ensp;
## 分析
把题意简化一下，只留主体：对于每个数，求另一个满足某个条件的数与该数在序列 $a$ 中的下标差。

可以将序列抽象为数轴上的区间 $[1,n]$。求两点下标距离（**注意被减数与减数顺序，可能为负数**）问题可以转化为已知一个点求另一个符合要求的点的问题。此时第一个条件必然成立。考虑第二个条件：对于点 $i$ 为起点的情况，终点的下标至少为 $i+a_i$，以满足 $a_i \le j$。同理，对于点 $i$ 为终点的情况，起点下标至少为 $i-a_i$。

也就是说，**在点 $i$ 要求的终点下标区间内，有一个点 $k$ 作为终点时允许点 $i$ 作为起点**时，点 $k$ 即为所求终点。此时暴力枚举，时间复杂度 $O(n^2)$。

考虑优化。对于任意一点 $i$，**无论其作为起点或终点，对应另一点下标可取最大值固定为 $n$**。据此，可以维护一个后缀最小下标，表示区间 $[i,n]$ 内各点**作为终点时可取到起点的最小下标最小**的点的位置及对应起点最小下标。每确定一个起点下标后可直接与可取终点区间的后缀最小下标作比较。如果可以取到该终点，则输出下标差；反之，以该点作为起点时任意一点均不可作为终点。

注意输出格式。

## AC 代码

```cpp
// VS 代码自动空格
#include<iostream>
using namespace std;
int n, a[300005];
struct zuoti {
	int l;
}ST[300005], ED[300005];//每个点作为起点或终点时另一点最小下标
struct zuoti1 {
	int val, addr;
}maxx[300005];//后缀最小下标
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		ST[i].l = max(i + a[i], 1);
		ED[i].l = min(i - a[i], n + 1);
		//边界
	}
	maxx[n].addr = n;
	maxx[n].val = ED[n].l;
	for (int i = n - 1; i >= 1; i--) {
		if (ED[i].l < maxx[i + 1].val) {
			maxx[i].addr = i;
			maxx[i].val = ED[i].l;
		}
		else {
			maxx[i] = maxx[i + 1];
		}
	}
	for (int i = 1; i <= n; i++) {
		if (ST[i].l > n) {
			cout << 0 << endl;
		}
		else {
			if (maxx[ST[i].l].val <= i) {//终点能接到起点
				cout << 1 << " " << (maxx[ST[i].l].addr) - i << endl;
			}
			else {
				cout << 0 << endl;
			}
		}
	}
	return 0;
}
```

---

## 作者：xiaoliebao1115 (赞：0)

第二题终于正常了一回，比之前的奇葩简单多了。

观察题目不等式，其中 $a_i$ 和 $n-i$ 在当前单次询问下是确定的，那么就有 $a_i\le j\le n-i$，这样 $j$ 的范围就定下来了，那么也有 $a_i+i\le i+j \le n$。

考虑 $j\le a_{i+j}$ 可以转化成为 $a_{i+j}-j \ge 0$，所以其实求出 $a_{i+j}-j$ 最大的 $j$ 就可以尽可能的满足这个要求。这个玩意很难维护，但是 $i$ 是定的呀，所以说只要求出 $a_{i+j}-i-j$ 的最大值再加 $i$ 即可。

总结一下做法：在 $a_i+i\le i+j \le n$ 的 $i+j$ 的范围中求一个 $a_{i+j}-i-j$ 的最大值再加 $i$ 即可，$a_{i+j}-i-j$ 的最大值以及所在的位置可以通过简单预处理求得。

柯哀的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int nn=3e5+5,lsh=1e9;
int n,a[nn],wz[nn],maxx[nn];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	maxx[n+1]=-lsh;
	for(int i=n;i>=1;i--){
		maxx[i]=maxx[i+1],wz[i]=wz[i+1];
		if(maxx[i]<a[i]-i) maxx[i]=a[i]-i,wz[i]=i;
	}
	for(int i=1;i<=n;i++){
		int mzhxi=max(i+a[i],1);//超出范围的话当作最大范围求解即可
		if(mzhxi>n) cout<<0<<endl;
		else{
			if(maxx[mzhxi]+i>=0) cout<<"1 "<<wz[mzhxi]-i<<endl;
			else cout<<0<<endl;
		}
	}
	return 0;
}
```
时间复杂度显然是 $O(n)$。

---

## 作者：HHC883 (赞：0)

# 题目分析
若我们仅考虑 $j \le a_{i+j}$，容易发现，当 $y \le a_x$ 时，可以取 $i=x-y,j=y$ 使得 $j \le a_{i+j}$。所以，对于每个 $1 \le x \le n$，我们都可以给区间 $[x-a_x,n]$ 内的下标打上标记（也就是对应的 $j$）。但是依次打标记需要 $O(n)$ 的时间复杂度，不可行。于是我们想到，其实只需要给下标 $x-a_x$ 打上标记 $a_x$，而区间 $(x-a_x,n]$ 内的标记在求的时候依次减 $1$ 即可。当然，这样还是需要 $O(n)$ 的时间复杂度，所以最优的方式是将下标 $x-a_x$ 上的标记改为 $x-1$（记为 $flag_x$），然后对于区间 $[x-a_x,n]$ 内的下标 $i$，其真正对应的 $j$ 就是 $flag_x-i+1$。

接下来考虑 $a_i \le j$。容易发现，我们只要求出下标 $i$ 上的所有标记中的最大值，记其为 $maxn$，则若 $maxn-i+1 \le a_i$，就取 $j=maxn-i+1$；否则无解。于是，问题就解决了。

在求解过程中，若 $x-a_x<1$，则标记应打在下标 $1$ 上面；若 $x-a_x>n$（因为 $a_x$ 有可能为负），则可以忽略。

时间复杂度为 $O(n)$。
# 参考代码
```cpp
#include<iostream>
#include<vector>
using namespace std;
int n,a[(int)3e5+5],maxn=-1e9;
vector<int> flag[(int)3e5+5];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		if(i-a[i]<=n) flag[max(1,i-a[i])].push_back(i-1);
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<flag[i].size();j++) maxn=max(maxn,flag[i][j]);
		if(maxn-i+1>=a[i]) cout<<"1 "<<maxn-i+1<<'\n';
		else cout<<"0\n";
	}
	return 0;
}

```

---

## 作者：aCssen (赞：0)

### Solution

处理一下第二个条件，就是 $a_i \le j,j \le a_{i+j}$。这个 $i+j$ 很麻烦啊，考虑把 $j$ 移到右边，那么就是 $0 \le a_{i+j}-j$。有点感觉了！再在右边补上一个 $i$，就是 $-i \le a_{i+j}-i-j$ 了，左边是定值，为了有解要最大化右边。记 $b_i=a_i-i$，其实要找的就是满足 $j \ge a_i+i,b_j \ge -i$ 的 $j$，注意，这里的 $j$ 指的是原题中的 $i+j$，这样满足第一条限制。

考虑把所有的 $i$ 按照 $a_i+i$ 从大到小排序，那么可用的 $j$ 不断增多，维护当前 $b_j$ 的最大值和最大值位置。每次检查一下是否合法即可。如果合法，答案是**最大值位置减去当前询问的 $i$**。

### Code

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<vector>
#define lowbit(x) x&(-x)
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
typedef long long ll;
namespace FastIO{
	template<typename T=int> T read(){
		T x=0;int f=1;char c=getchar();
		while(!isdigit(c)){if(c=='-') f=~f+1;c=getchar();}
		while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
		return x*f;
	}
	template<typename T> void write(T x){
		if(x<0){putchar('-');x=-x;}
		if(x>9) write(x/10);
		putchar(x%10+'0');
	}
	template<typename T> void Write(T x,char c='\n'){write(x);putchar(c);}
}
using namespace FastIO;
const int maxn=3e5+5;
struct node{
	int id,v;
}a[maxn];
int ans[maxn],b[maxn];
int main(){
	int n=read();
	for(int i=1;i<=n;i++) ans[i]=-998244353;
	for(int i=1;i<=n;i++) b[i]=read(),a[i]=(node){i,b[i]+i};
	sort(a+1,a+n+1,[](node x,node y){return x.v<y.v;});
	int Maxv=-1e9,pos=0;
	for(int i=n,j=n+1;i>=1;i--){
		while(j>a[i].v&&j>1){
			j--;
			if(b[j]-j>Maxv) Maxv=b[j]-j,pos=j;
		}
		if(Maxv>=-a[i].id) ans[a[i].id]=pos-a[i].id;
	}
	for(int i=1;i<=n;i++){
		if(ans[i]==-998244353) printf("0\n");
		else printf("1 %d\n",ans[i]);
	}
	return 0;
}
```

---

## 作者：K_J_M (赞：0)

## 题目描述
给定序列 $a_1, a_2, \dots, a_n$，请对于每一个 $1\sim n$ 的整数 $i$ 求任意一个整数 $j$ 使得以下条件同时成立，或判断不存在这样的 $j$

- $1\leq i+j\leq n$；
- $a_i \leq j \leq a_{i+j}$。
## 分析
令 $x=i+j$，则原式条件等价于：
- $1\leq x\leq n$；
- $a_i+i\leq x$；
- $x-a_x\leq i$。

直接做复杂度为 $\mathcal O(n^2)$，无法接受，考虑优化。\
先看第三个条件，我们可以将 $x-a_x$ 看作是一个整体放进数组 $c_i$ 中间，并且将 $c$ 从小到大排序，记录 $id_x$ 为 $c_x$ 对应的原来未排序数组的下标。查询时找到最右边的满足此条件的下标 $x$，那么 $c_1\sim c_x$ 均满足。然后查询 $d=\max_{i=1}^{x}\{id_i\}$，若 $a_i+i\leq d$，那么满足条件，此时 $x=d$，输出 $d-i$；否则没有满足条件的，输出 $0$。而求出 $d$ 考虑预处理 $1\sim i$ 的最大 $id$ 值。综上可以在时间复杂度为 $\mathcal O(n\log n)$ 内求出答案。\
[Ac Code](https://www.luogu.com.cn/paste/mi8peyhp)

---

## 作者：mahaihang1 (赞：0)

## 思路
考虑分析这两个限制 $j$ 的式子 $\begin{cases} 
1 \le i+j \le n \\
a_i \le j \le a_{i+j}
\end{cases}$，合并后变为 $\begin{cases} 
\max(1,a_i+i) \le j \le n \\
j \le a_{i+j} 
\end{cases} $。

发现第一个式子限制 $j$ 的上下界，考虑通过 $j \le a_{i+j}$ 来判定一个 $j$ 是否可行。

但 $a_{i+j}$ 的值与 $j$ 的值都不恒定，考虑继续移项变为 $0 \le a_{i+j}-j$，发现两边同时减 $i$，变为 $-i \le a_{i+j}-(i+j)$ 时右边的下标与常数一致，恒为定值。

因此，对于每个 $a_i$ 维护 $b_i=a_i-i$，如果存在 $k$ 满足 $\begin{cases} 
\max(1,a_i+i) \le k \le  n\\
-i \le b_k
\end{cases}$，则答案为 $k-i$。

维护 $b$ 的后缀最大值和下标对每个 $i$ 进行判定即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=300010;
int n,a[N],b[N],m[N],p[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b[i]=a[i]-i;
	}
	m[n+1]=-0x3f3f3f3f;
	for(int i=n;i>=1;i--){
		if(b[i]>=m[i+1]){
			m[i]=b[i];
			p[i]=i;
		}
		else{
			m[i]=m[i+1];
			p[i]=p[i+1];
		}
	} //维护后缀最大值与下表 
	for(int i=1;i<=n;i++){
		int k=max(a[i]+i,1);
		if(m[k]>=-i&&k<=n){
			cout<<"1 "<<p[k]-i<<"\n"; 
		}
		else{
			cout<<"0\n";
		}
	} //求解 
	return 0;
}
```

---

## 作者：鲤鱼江 (赞：0)

提供一种线性做法。

首先考虑将限制写出来变形，发现原限制等价于找到一个 $pos$ 使得 $pos\geq a_i+i$ 且 $a_{pos}-pos\geq -i$
（无法理解的话就把 $pos$ 换成 $i+j$ 看一下），于是可以处理一下 $a_i-i$ 的后缀最大值的位置，到时候 $O(1)$ 回答即可，代码比较简洁。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
#define ll long long

const int N=5e5+10;
int n,a[N],b[N],p[N];

signed main(){
	cin>>n;p[n]=n;
	for(int i=1;i<=n;++i){cin>>a[i];b[i]=a[i]-i;}
	for(int i=n-1;i;--i) p[i]=(b[p[i+1]]>=b[i]?p[i+1]:i);
	for(int i=1;i<=n;++i){
		int pos=max(a[i]+i,1);
		if(pos>n) cout<<0<<endl;
		else {
			int tmp=p[pos];
			if(b[tmp]>=-i) cout<<1<<' '<<tmp-i<<endl;
			else cout<<0<<endl;
		}
	}
	return 0;
}
```

---

## 作者：w9095 (赞：0)

[P11157 【MX-X6-T3】さよならワンダーランド](https://www.luogu.com.cn/problem/P11157)

神秘思维题。

考虑到转化式子，拆成 $j\ge a_i$ 和 $j\le a_{i+j}$。前一个不等式是容易满足的，我们只需要在 $[\max\{1,i+a_i\},n]$ 中选择 $i+j$ 即可。

第二个不等式可化为 $a_{i+j}-j\ge 0$，因此我们在$[i+a_i,n]$ 中选择 $a_{i+j}-j$ 的最大值。如果最大值在位置 $k$，则有 $a_k-(k-i)\le 0$。注意到 $i$ 相同时大小关系只与 $a_k-k$ 有关，所以同一个 $i$ 内最大值取到哪与 $i$ 无关，按照 $a_k-k$ 预处理一下即可。

我们枚举每一个 $i$，直接判断预处理出的最大值位置是否合法，就解决了这个问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long t,n,a[500000],b[500000],p[500000];
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),b[i]=a[i]-i,p[i]=i;
	for(int i=n-1;i>=1;i--)
	   	if(b[p[i]]<b[p[i+1]])p[i]=p[i+1];
	for(int i=1;i<=n;i++)
	    {
	    long long t=max(1ll,i+a[i]);
	   	if(t>n)printf("0\n");
	   	else if(p[t]-i<=a[p[t]])printf("1 %lld\n",p[t]-i);
	   	else printf("0\n");
	    }
	return 0;
}
```

---

## 作者：ICU152_lowa_IS8 (赞：0)

这题真的是黄题吗？感觉绿完全不过分，或者说我的做法过于复杂了。

先看满足 $a_i\le j$ 的同时 $a_i\le a_{i+j}$。

开一个线段树，每次查 $a_{a_i+i}$ 到 $a_n$ 的最大值，如果最大值都小于 $a_i$，那就输出 $0$ 就好了。如果最大值大于 $a_i$，那就找到在 $(a_i+i)\sim n$ 这一段内那个最大值所在的位置，可以用类似权值线段树的方法做。

问题来了，我们还要满足 $j\le a_{i+j}$，也就是 $a_{i+j}-j\ge 0$。

那么对于每一个 $a_{i+j}$ 来说，当 $i$ 确定了，那么 $j$ 也就确定了，并且随着 $i$ 逐渐变大，$j$ 也会逐渐变小。

那么事情就比较明显了，线段树初始不对 $a$ 数组建树，对于每一个 $j$，每当 $a_{i+j}-j\ge 0$ 的时候就将其加入到线段树中再进行查询即可。

那么怎么判断 $a_{i+j}-j\ge0$ 是否成立呢？显然初始 $a_{k}-k$ 的值的大小和 $a_{i+j}-j (i+j=k)$ 的大小顺序是一样的，那么直接用一个大根堆就好了。

有几个细节，线段树找到最大值之后查询到的 $i+j$ 一定要尽量靠右，以及一些参数的设定等等，还是看代码吧。

讲的可能不是很清楚，代码会更清楚一些：


```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000005];
struct tree{
	int val,minn,tag;
}tree[4000005];
priority_queue<pair<int,int> >q;
inline int ls(int p){
	return p<<1;
}
inline int rs(int p){
	return p<<1|1;
}
inline void pushup(int p){
	tree[p].val=max(tree[ls(p)].val,tree[rs(p)].val);
	if(tree[ls(p)].minn==INT_MIN){
		tree[p].minn=tree[rs(p)].minn;
	}
	else if(tree[rs(p)].minn==INT_MIN){
		tree[p].minn=tree[ls(p)].minn;
	}
	else{
		tree[p].minn=min(tree[ls(p)].minn,tree[rs(p)].minn);
	}
}
inline void build(int p,int l,int r){
	if(l==r){
		tree[p].val=INT_MIN;
		tree[p].minn=INT_MIN;
		return;
	}
	int mid=l+r>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	pushup(p);
}
inline void update(int p,int l,int r,int ql,int qr,int k){
	if(l>qr||r<ql)return;
	if(qr>=r&&ql<=l){
		tree[p].val=k;
		tree[p].minn=k;
		return;
	}
	int mid=l+r>>1;
	update(ls(p),l,mid,ql,qr,k);
	update(rs(p),mid+1,r,ql,qr,k);
	pushup(p);
}
inline int query(int p,int l,int r,int ql,int qr){
	if(l>qr||r<ql)return INT_MIN;
	if(qr>=r&&ql<=l){
		return tree[p].val;
	}
	if(l==r)return tree[p].val;
	int mid=l+r>>1;
	return max(query(ls(p),l,mid,ql,qr),query(rs(p),mid+1,r,ql,qr));
}
inline int qrange(int p,int l,int r,int ql,int qr,int k){
	if(l>qr||r<ql)return -1;
	if(l==r)return l;
	int tx=-1;
	int mid=l+r>>1;
	if(tree[rs(p)].val>=k&&tree[rs(p)].minn<=k){
		int t=qrange(rs(p),mid+1,r,ql,qr,k);
		if(t!=-1)tx=t;
	}
	else if(tree[ls(p)].val>=k&&tree[ls(p)].minn<=k){
		int t=qrange(ls(p),l,mid,ql,qr,k);
		tx=t;
	}
	return tx;
}
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		q.push(make_pair(a[i]-i+1,i));
	}
	build(1,1,n);
	for(int i=1;i<=n;i++){
		while(!q.empty()&&q.top().first+i-1>=0){
			update(1,1,n,q.top().second,q.top().second,a[q.top().second]);
			q.pop();
		}
		if(a[i]>n)cout<<0<<endl;
		else{
			int t=max(i+a[i],1ll);
			if(query(1,1,n,t,n)<a[i])cout<<0<<endl;
			else cout<<1<<" "<<qrange(1,1,n,t,n,query(1,1,n,t,n))-i<<endl;
		}
	}
	return 0;
}
```

---

## 作者：NTT__int128 (赞：0)

# P11157 【MX-X6-T3】さよならワンダーランド 题解
题意：有一个数列 $a$。对于每一个 $1\le i\le n$，要找一个 $j$，使得 $\max(1-i,a_i)\le j\le\min(a_{i+j},n-i)$。

转换一下，即对于每一个 $i$，寻找 $\max(1-i,a_i)\le j\le a_{i+j}$，使得 $a_{i+j}-j\ge0$，也就是 $a_{i+j}-(i+j)\ge-i$。

我们知道，$i+j$ 的范围是在 $\max(1-i,a_i)+i$ 到 $n$ 之间的，我们可以用 $\texttt{ST}$ 表找出这个区间里 $a_k-k$ 最大的 $k$，那么让 $i+j=k$，即 $j=k-i$，判断是否成立就行了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,m,a[N],dp[N][25],pos[N][25],l,r,lg[N];
void init(){
	for(int j=1;(1<<j)<=n;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			dp[i][j]=max(dp[i][j-1],dp[i+(1<<j-1)][j-1]),pos[i][j]=(dp[i][j-1]>dp[i+(1<<j-1)][j-1]?pos[i][j-1]:pos[i+(1<<j-1)][j-1]);
}
int rmq(int l,int r){
	int len=lg[r-l+1];
	return (dp[l][len]>dp[r-(1<<len)+1][len]?pos[l][len]:pos[r-(1<<len)+1][len]);
}
int main(){
	cin>>n;
	lg[0]=-1;
	for(int i=1;i<=n;i++)cin>>a[i],lg[i]=lg[i>>1]+1,dp[i][0]=a[i]-i,pos[i][0]=i;
	init();
	for(int i=1;i<=n;i++){
		if(max(1-i,a[i])+i>n){
			cout<<"0\n";
			continue;
		}
		int j=rmq(max(1-i,a[i])+i,n)-i;
		if(i+j>=1&&i+j<=n&&a[i]<=j&&j<=a[i+j])cout<<"1 "<<j<<'\n';
		else cout<<"0\n";
	}
	return 0;
}
```

---

## 作者：modfish_ (赞：0)

## 思路
枚举 $i$，则我们需要寻找 $j$，使得 $a_{i+j}-j\ge 0$。

不妨令 $i+j=x$，则我们要寻找 $x$ 使得 $a_x-x+i\ge 0$，即 $a_x-x\ge -i$。容易发现，随着 $i$ 的增大，满足条件的 $x$ 只会变多。可以一开始将所有的 $x$ 按照 $a_x-x$ 丢进大根堆里，每次 $i$ 变化时，把新的满足条件的 $x$ 拿出来即可。

如何满足 $j\ge a_i$ 呢？可以使用一个笨办法：二分一个大于 $a_i$ 的最小的满足条件的 $j$。可以把上段中满足条件的 $x$ 的位置用树状数组标记出来，然后根据区间和二分即可。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 3e5 + 5;

int n;
int a[maxn], tr[maxn];
priority_queue<pair<int, int> > q;

void upd(int id, int k){
    for(int i = id; i <= n; i += i & -i) tr[i] += k;
}
int query(int id){
    if(!id) return 0;
    int s = 0;
    for(int i = id; i > 0; i -= i & -i) s += tr[i];
    return s;
}

int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++){
        scanf("%d", &a[i]);
        q.push(make_pair(a[i] - i, i));
    }
    for(int i = 1; i <= n; i ++){
        while(!q.empty() && q.top().first + i >= 0) upd(q.top().second, 1), q.pop();
        int l = a[i], r = n - i + 1, res = -1e9;
        l = max(l, 1 - i), r = min(r, n - i);
        while(l <= r){
            int mid = l + r >> 1;
            if(query(i + mid) - query(i + max(a[i], 1 - i) - 1)) r = mid - 1, res = mid;
            else l = mid + 1;
        }
        if(res > -1e9) printf("1 %d\n", res);
        else printf("0\n");
    }
    return 0;
}
```

---

## 作者：ivyjiao (赞：0)

大家好，我是 ivyjiao，从今天开始，我不再是 ST 表的忠实拥护者，望周知。

由题意给出的那两个式子，我们可以推出两个东西：

$$1\leq i+j\leq n\to 1\leq i+j\to 1-i\leq j$$

$$1\leq i+j\leq n\to i+j\leq n\to j\leq n-i$$

$$a_i\leq j\leq a_{i+j}\to a_i\leq j\to a_i\leq j\leq n-i$$

$$a_i\leq j\leq a_{i+j}\to j\leq a_{i+j}\to 1-i\leq j\leq a_{i+j}$$

$a_i\leq j\leq n-i$ 是一个限定条件：若 $a_i>n-i$ 则无解。

我们再转化一下 $1-i\leq j\leq a_{i+j}$，容易发现 $1-i\leq j$ 一定满足，那么：

$1-i\leq j\leq a_{i+j}\to j\leq a_{i+j}\to 0\leq a_{i+j}-j$

转化为了区间最大值问题，我们只需要维护 $a_{i+j}-j$ 的最大值即可，但是这玩意维护不了，我们考虑维护 $a_{i+j}-(i+j)$，转化为维护 $a_i-i$，可以维护，最后输出的时候加个 $i$ 就行。

然后 $j\leq a_{i+j}$ 就用上了：若求出的最大值的 $j$ 的 $j> a_{i+j}$ 则无解。

然后本题就结束了。

ivyjiao 不喜欢 ST 表，所以他用线段树写了这道题。

代码：

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define fi first
#define se second
#define ls u*2
#define rs u*2+1
using namespace std;
const int N=3e5+1;
int n,a[N],f[N];
PII b[4*N];
void build(int u,int l,int r){
    if(l==r){
        b[u]={f[l],l};
        return;
    }
    int mid=l+r>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    b[u].fi=-1e9;
    if(b[ls].fi>b[u].fi) b[u]=b[ls];
    if(b[rs].fi>b[u].fi) b[u]=b[rs];
}
PII qmax(int u,int l,int r,int L,int R){
    if(L<=l&&r<=R) return b[u];
    int mid=l+r>>1;
    PII ans={-1e9,0};
    if(L<=mid){
        PII v=qmax(ls,l,mid,L,R);
        if(v.fi>ans.fi) ans=v;
    }
    if(R>mid){
        PII v=qmax(rs,mid+1,r,L,R);
        if(v.fi>ans.fi) ans=v;
    }
    return ans;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        f[i]=a[i]-i;
    }
    build(1,1,n);
    for(int i=1;i<=n;i++){
        if(a[i]>n-i){
            cout<<0<<'\n';
            continue;
        }
        PII mx=qmax(1,1,n,max(a[i]+i,1),n);
        if(mx.se-i>a[mx.se]) cout<<0<<'\n';
        else cout<<1<<" "<<mx.se-i<<'\n';
    }
}
```

---

## 作者：sbno333 (赞：0)

发现 $i+j$ 比 $j$ 更加自然，性质多，所以我们设 $k=i+j$。

显然有 $1\le k\le n$。

接着有 $a_i\le k-i\le a_k$。

拆一下，得到 $k\ge a_i+i$，$i\ge k-a_k$。

于是就是 $a_i+i\le k\le n$，找到一个 $k$，使得 $k-a_k\le i$。

为了尽量满足，我们需要找到最小的 $k-a_k$，比较即可。

我们预处理后缀 $k-a_k$ 最小值，对于每个 $i$ 找到 $k$，输出 $j=k-i$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
int a[1000009];
int mi[1000009];
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	mi[n]=n;
	for(int i=n-1;i>=1;i--){
		if(i-a[i]<mi[i+1]-a[mi[i+1]]){
			mi[i]=i;
		}else{
			mi[i]=mi[i+1];
		}
	}
	for(int i=1;i<=n;i++){
		int k;
		k=a[i]+i;
		k=max(k,1ll);
		if(k<=n&&mi[k]-a[mi[k]]<=i){
			cout<<1<<" "<<mi[k]-i<<endl; 
		}else{
			cout<<0<<endl;
		}
	}
	return 0;
}
```

---


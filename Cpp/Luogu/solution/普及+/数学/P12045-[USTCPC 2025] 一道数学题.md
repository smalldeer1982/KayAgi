# [USTCPC 2025] 一道数学题

## 题目描述

克露丝卡尔酱不明白，在算法竞赛中怎么会出现一道数学题呢？  
~~因为我们是中国数学物理大学~~  
克露丝卡尔酱不是一个合格的中国数学物理大学的学生，帮帮她吧！  

对所有可能的 $m$ 个和为 $n$ 的**不同**正整数 $a_1,a_2,\cdots$ $a_m$，求 $a_1a_2+a_2a_3+a_3a_4+\cdots+a_ma_1$ 的最小值。

答案对 $998244353$ **取模**。

## 样例 #1

### 输入

```
4 10```

### 输出

```
21```

# 题解

## 作者：GuWolf (赞：8)

## 基础情况分析
首先，我们分析当 $n = \frac{m \times (m + 1)}{2}$ 中最小值的情况，使用以下代码暴力求出前 $10$ 个最小值：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    for (int i = 2; i <= 11; ++i) {
        int mn = INT_MAX;
        vector<int> a(i);
        for (int j = 0; j < i; ++j) a[j] = j + 1;

        do {
            int tmp = a[0] * a[i - 1];
            for (int j = 1; j < i; ++j) tmp += a[j] * a[j - 1];
            mn = min(mn, tmp);
        } while (next_permutation(a.begin(), a.end()));
        
        cout << mn << ' ';
    }
    return 0;
}
```

求得前 $10$ 个最小值分别为：

```text
4 11 21 37 58 87 123 169 224 291
```

此时，我们对它进行三阶差分。

|  | 0️⃣ | 1️⃣ | 2️⃣ | 3️⃣ | 4️⃣ | 5️⃣ | 6️⃣ | 7️⃣ | 8️⃣ | 9️⃣ | ... |
|----------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| 原数列   | $4$     | $11$    | $21$    | $37$    | $58$    | $87$    | $123$   | $169$   | $224$   | $291$   | ... |
| $\Delta^1$ | —     | $7$     | $10$    | $16$    | $21$    | $29$    | $36$    | $46$    | $55$    | $67$    | ... |
| $\Delta^2$ | —     | —     | $3$     | $6$     | $5$     | $8$     | $7$     | $10$    | $9$     | $12$    | ... |
| $\Delta^3$ | —     | —     | —     | $3$     | $-1$    | $3$     | $-1$    | $3$     | $-1$    | $3$     | ... |


可以看到，第三阶的值在 $3$ 和 $-1$ 间交替变化。

## 拓展分析
接下来拓展到 $n > \frac{m \times (m + 1)}{2}$ 的情况。

很容易可以看到，当把多出来的值分配给 $a_i$ 时，对总值的贡献是 $a_i \times (a_{i-1} + a_{i+1})$。

进而发现，$n$ 每增加 $1$ 的时候，对总值最小的贡献是 $3$ (当 $a_i$ 的两边分别为 $1$、$2$ 的时候)

**注意**: 此时还需特判 $n = 2$ 的情况。

```cpp
if (m == 2) {
    cout << (n - 1 + n - 1) % MOD << endl;
    return;
}
```

## 完整代码
```cpp
#include <bits/stdc++.h>

#define LL long long
#define endl '\n'

using namespace std;

const LL MOD = 998244353;
LL d[4][200010], tmp[] = {-1, 3};

void solve() {
    LL n, m;
    cin >> m >> n;

    if (m == 2) {
        cout << (n - 1 + n - 1) % MOD << endl;
        return;
    }

    for (int i = 1; i < 200005; ++i) d[3][i] = tmp[i & 1];
    d[2][1] = 3;
    d[1][1] = 7;
    d[0][1] = 4;
    for (int i = 1; i < 200005; ++i) {
        d[2][i + 1] = (d[2][i] + d[3][i]) % MOD;
        d[1][i + 1] = (d[1][i] + d[2][i]) % MOD;
        d[0][i + 1] = (d[0][i] + d[1][i]) % MOD;
    }
    n -= m * (m + 1) / 2ll;
    cout << (d[0][m - 1] + 3ll * n) % MOD << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
    //cin >> T;
    while (T--) solve();
    return 0;
}
```

---

## 作者：Whitecate (赞：3)

数学题,但是初中的方法就能做出来。

我们设要求的柿子为 $S$，可以得到 $2S = \sum_{i = 1}^{m} (a_i + a_{i+1})^2 - \sum_{i = 1}^{m} a_i^2 + a_{i+1}^2$，又可以发现 $\sum_{i = 1}^{m} (a_i + a_{i+1}) = 2n$。

于是根据小学的知识，在和一样的情况下，两数差越大，两数乘积越小。于是最优解的构造就显而易见了：让相邻的两数差越大。

于是最后可以十分简易的得到代码了：


```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m;
long long ans;
int main(){
    cin >> m >> n;
    if(m == 2){
        ans = 2*(n-1);
    }
    else if(m % 2 ==0){
        ans = 3 * n + (pow(m,3) - 4*m)/6 - pow(m,2) - 1;
    }
    else{
        ans = 3 * n + (pow(m,3) - 4*m)/6 - pow(m,2);
    }
    ans %= 998244353;
    cout << ans;
}
```

---

## 作者：Anesthesia_Nick (赞：2)

个人观点：这道题并不是一道非常合适的 OI 题，而是一道 MO 题。

对数学竞赛略有了解的同学，~~马上~~就能想到 1995CMOP5，而那届 CMO 恰好是在 USTC 办的喵。

这里用**调整法**写一个证明。

记 $a_{m+1}=a_1$，$S=\sum_{i=1}^m a_ia_{i+1}$。

先设 $\sum_{i=1}^m a_i=\frac{m(m+1)}{2}$。
 
- 不妨 $a_1$ 最大，若 $a_j=1$ 且 $j\neq 2$，我们把 $\left(a_2,a_3,\dots,a_{j-1},a_j\right)$ 翻转变成 $\left(a_j,a_{j-1},\dots,a_3,a_2\right)$，记前者代入得到的和是 $S_1$，后者是 $S_2$，显然 $S_1-S_2=a_1a_2+a_ja_{j+1}-a_1a_j-a_2a_{j+1}=\left(a_1-a_{j+1}\right)\left(a_2-a_j\right)>0$，因此 $S_2$ 更小，从而 $a_2=1$。
- 类似的调整法可以知道，$\{a_i\}_{i=1}^m=\{m,1,m-1,\dots,m-2,2\}$，设它得到的结果是 $S'$。

接下来考虑剩下的 $N=n-\frac{m(m+1)}{2}$，我们记 $b_i$ 为我们上面提到的那串数列，$c_i=a_i-b_i$。

这里 $c_{m+1}=c_1,b_0=b_m,b_{m+1}=b_1$，则 
$$S=\sum_{i=1}^m b_ib_{i+1}+\sum_{i=1}^m c_ic_{i+1}+\sum_{i=1}^m c_i(b_{i-1}+b_{i+1})\geq S'+(b_2+b_m)N$$

故 $S=3N+S'$, 且取等要求 $c_i=0$ 对于 $\forall i\neq 1$。

故最小值在数列为 $(N,1,m-1,\dots,m-2,2) $时取到，直接计算可得。

---

## 作者：hgckythgcfhk (赞：1)

广告：[USTCPC2025 题解汇总（部分）](https://www.luogu.com.cn/article/xl8dsc9j)。

非常好的打表题，先考虑 $n=\dfrac{m^2+m}{2}$ 的做法。

首先要先重新审视打表这件事情，打表并不一定是真的打一个“表”，也不一定是要直接把答案打出来输出，事实上更重要的是观察最优解的组合结构，做打表题是在 LCA 长训营传出来的一个训练方法，所以我认为打表并不可耻。

观察 $m=6$ 的解：

```cpp
1 5 3 4 2 6 
1 6 2 4 3 5 
2 4 3 5 1 6 
2 6 1 5 3 4 
3 4 2 6 1 5 
3 5 1 6 2 4 
4 2 6 1 5 3 
4 3 5 1 6 2 
5 1 6 2 4 3 
5 3 4 2 6 1 
6 1 5 3 4 2 
6 2 4 3 5 1 
```

$m=7$ 的解：

```cpp
1 6 3 4 5 2 7 
1 7 2 5 4 3 6 
2 5 4 3 6 1 7 
2 7 1 6 3 4 5 
3 4 5 2 7 1 6 
3 6 1 7 2 5 4 
4 3 6 1 7 2 5 
4 5 2 7 1 6 3 
5 2 7 1 6 3 4 
5 4 3 6 1 7 2 
6 1 7 2 5 4 3 
6 3 4 5 2 7 1 
7 1 6 3 4 5 2 
7 2 5 4 3 6 1 
```

$m=8$ 的解：

```cpp
1 7 3 5 4 6 2 8 
1 8 2 6 4 5 3 7 
2 6 4 5 3 7 1 8 
2 8 1 7 3 5 4 6 
3 5 4 6 2 8 1 7 
3 7 1 8 2 6 4 5 
4 5 3 7 1 8 2 6 
4 6 2 8 1 7 3 5 
5 3 7 1 8 2 6 4 
5 4 6 2 8 1 7 3 
6 2 8 1 7 3 5 4 
6 4 5 3 7 1 8 2 
7 1 8 2 6 4 5 3 
7 3 5 4 6 2 8 1 
8 1 7 3 5 4 6 2 
8 2 6 4 5 3 7 1
```

$m=9$ 的解：

```cpp
1 8 3 6 5 4 7 2 9 
1 9 2 7 4 5 6 3 8 
2 7 4 5 6 3 8 1 9 
2 9 1 8 3 6 5 4 7 
3 6 5 4 7 2 9 1 8 
3 8 1 9 2 7 4 5 6 
4 5 6 3 8 1 9 2 7 
4 7 2 9 1 8 3 6 5 
5 4 7 2 9 1 8 3 6 
5 6 3 8 1 9 2 7 4 
6 3 8 1 9 2 7 4 5 
6 5 4 7 2 9 1 8 3 
7 2 9 1 8 3 6 5 4 
7 4 5 6 3 8 1 9 2 
8 1 9 2 7 4 5 6 3 
8 3 6 5 4 7 2 9 1 
9 1 8 3 6 5 4 7 2 
9 2 7 4 5 6 3 8 1 
```

发现解的个数是 $2m$，现在试图解释一下这件事情，首先问题结构是个环形的，所以循环移位是等价的，由于每个数不相等，镜像对称后序列是不同的，但也是等价的，所以得出结论最优解是唯一的。

同时，我们看字典序最小的解，发现把 $m$ 的解整体加一然后整体 ```reverse``` 在前面放 $1$ 后面放 $m$ 可以得到 $m+2$ 的解。

验证 $m$ 更小的数据可以验证这个结论，然后 $m$ 大一点的由于赛时时间比较充足可以多跑一会，同时可以验证这个结论。

由于 $n\le 10^{10}$，所以 $m<2\times 10^5$，实际可以更小，但其实差不多，所以 $O(m)$ 的构造是能过的。

构造方法其实可以找规律，先把所有塞到双端队列里，然后把最小的放到前面最大的放到后面，然后最大的放到前面最小的放到后面这样交替进行，当然还有很多构造方法，下面提供的 $42$ 队的赛时代码可以得到另外一种。

最后处理 $n$ 比 $\dfrac{m^2+m}{2}$ 的部分，这些可以直接塞到最大的数上，因为最大的数旁边一定和 $1$ 和 $2$ 相邻，根据构造的过程可以证明这件事情，处理完直接暴力算就行。

以下是线下选手 $42$ 队提供的赛时代码，非常感谢 $42$ 队。

```cpp
#include<iostream>
using namespace std;
typedef long long ll;
const ll p=998244353;
const int N=1e6+10;
ll a[N];
ll m,n,ans=0;
int main(){
	scanf("%lld%lld",&m,&n);
	for(int i=1;i<=m;i++)a[i]=i,n-=i;
	for(int i=1;i<=m/2;i+=2)swap(a[i],a[m-i+1]);
	a[1]+=n;
	ans=a[1]*a[m]%p;
	for(int i=2;i<=m;i++){
		ans+=a[i-1]*a[i];
		ans%=p;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：MOersjx (赞：1)

官方题解。  

先考虑 $n=\dfrac {m(m+1)}{2}$ 时的情况，记 $b_i$ 是 $m+1-i$ 两侧的数之和。

记 $S=a_1a_2+a_2a_3+...+a_m a_1$，则 $2S=\sum_{i=1}^m{a_i\left( a_{i-1}+a_{i+1} \right)}
=\sum_{i=1}^m{(n+1-i)b_i}$。

控制 $b_i$ 前缀和 $T_i$ 的下界: 考虑组成前缀和的 $2i$ 个 $a$，对几乎所有 $i$，做不到最小的 $i$ 个数每个出现两次，$T_i$ 需要比这种情况大 $1$，即 $T_i>=i^2+i+1$。

$\sum_{i=1}^m{b_i}$ 为定值，欲令 $S$ 最小，$b_i$ 在满足前缀和限制的同时尽可能向后集中。

$n>\dfrac {m(m+1)}{2}$ 时的情况可由 $n=\dfrac {m(m+1)}{2}$ 时给某些 $a_i$ 进行若干次 $+1$ 得到，每次 $+1$ 后 $S$ 至少增加 $3$。

答案可以算出来: 

- $m=2$：$2n-2$。

- $m$ 为奇数：$3n+\dfrac{(m^3-4m)}{6}-m^2$ 

- $m$ 为偶数且 $m>2$：$3n+\lfloor\dfrac{(m^3-4m)}{6}\rfloor-m^2-1$  

构造：先放 $n-\dfrac{m(m-1)}{2}$，然后对 $1$ 至 $m-1$ 依次执行：  
最小数放最左边，最大数放最左边，最小数放最右边，最大数放最右边。循环执行直到所有数放好。

std:
```
#include<bits/stdc++.h>
using namespace std;
int main() {
    long long m,n,ans;
    cin>>m>>n;
    if(m==2)ans=2*(n-1);
    else if(m%2==0)ans=3*n+(m*m*m-4*m)/6-m*m-1;
    else ans=3*n+(m*m*m-4*m)/6-m*m;
    ans%=998244353;
    cout<<ans;
}
```

---


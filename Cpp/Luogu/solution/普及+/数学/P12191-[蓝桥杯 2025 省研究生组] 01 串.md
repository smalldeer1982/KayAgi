# [蓝桥杯 2025 省研究生组] 01 串

## 题目描述

给定一个由 $0, 1, 2, 3 \dots$ 的二进制表示拼接而成的长度无限的 $01$ 串。其前若干位形如 $011011100101110111\dots$。

请求出这个串的前 $x$ 位里有多少个 $1$。

## 说明/提示

### 样例说明

给定的串的前 $7$ 位为 $0110111$。

### 评测用例规模与约定

- 对于 $60\%$ 的评测用例，$x \leq 10^6$；
- 对于所有评测用例，$1 \leq x \leq 10^{18}$。

## 样例 #1

### 输入

```
7```

### 输出

```
5```

# 题解

## 作者：qwqerty (赞：6)

其实这是我真正意义上的第一次不看题解作出的绿题，因为我做题前总会把题解先扫一遍看看难不难。
# 解题思路
先将完整的数统一处理，再处理剩余部分。  
比方说 $x=25$：  
$0110111001011101111000100$。  
为方便处理，直接丢掉第一位。再通过位数进行分割。  
$\color{red}1\color{blue}1011\color{green}100101110111\color{purple}1000\color{IAKIOI}100$。  
分析一下具体的分割过程：
- 割下 $1$ 位数，共有 $2^{1-1}=1$ 个数，每个数有 $1$ 位，一共 $1\times2^{1-1}=1$ 位。还剩 $24-1=23$ 位。
- 割下 $2$ 位数，共有 $2^{2-1}=2$ 个数，每个数有 $2$ 位，一共 $2\times2^{2-1}=4$ 位。还剩 $23-4=19$ 位。
- 割下 $3$ 位数，共有 $2^{3-1}=4$ 个数，每个数有 $3$ 位，一共 $3\times2^{3-1}=12$ 位。还剩 $19-12=7$ 位。
- 割下 $4$ 位数，由于剩下的数小于 $4\times2^{4-1}=32$ 位，所以无法完全分割。只能割下 $\lfloor\frac{7}{4}\rfloor=1$ 个数，还剩 $7\bmod 4=3$ 位。
  
这一部分的代码如下：
```cpp
x--;
int i;
for (i = 0; ; i++) {
    if (x < (i + 1) * (1ll << i)) break;
    x -= (i + 1) * (1ll << i);
    res += (1ll << i);
}
res += x / (i + 1);
x %= (i + 1);
```
所以一共分割出了 $1+2+4+1=8$ 个数。  
我们先处理这 $8$ 个数，再将剩下的 $3$ 个数单独处理。  

现在的任务是求 $\operatorname{popcount}$ 的前缀和。  
部分内容借鉴自[该博客](https://kaiserwilheim.github.io/OI/fast-popcnt-sum/)，如侵删。  
如果我们把二进制下的 $0$ 至 $15$ 的数全部列出来，找一下规律：
$$
\color{blue}0000000011111111\\
\color{green}0000111100001111\\
\color{purple}0011001100110011\\
\color{red}0101010101010101
$$  
分开观察一下每一行，可以发现每一行 $0$ 的个数和 $1$ 的个数都相等！  
这是因为如果 $n$ 的二进制下第 $k$ 位数是 $1$ 的话，那么有 $\dfrac{n\bmod2^k}{2^{k-1}}\ge1$，也就是说，$n\bmod2^k\ge2^{k-1}$。可以发现，它正好是占一半的。  
所以 $\sum\limits_{i=0}^{2^k-1}\operatorname{popcount}(i)=\dfrac{k\times2^k}{2}=k\times2^{k-1}$。  
那么对于一个任意的正整数 $n$，如何计算 $\sum\limits_{i=0}^{n}\operatorname{popcount}(i)$ 呢。考虑拆位计算贡献的方式，下面以 $n=22=(10110)_2$ 为例：
- 最高位为 $1$，统计 $(00000)_2$ 至 $(01111)_2$。共对答案产生了 $4\times2^{4-1}=32$ 的贡献。
- 第三高位为 $1$，统计 $(10000)_2$ 至 $(10011)_2$，共对答案产生了 $1\times2^2+2\times2^{2-1}=8$ 的贡献。
- 第四高位为 $1$，统计 $(10100)_2$ 至 $(10101)_2$，共对答案产生了 $2\times2^1+1\times2^{1-1}=5$ 的贡献。

最后还要统计 $\operatorname{popcount}(n)$，所以答案为 $32+8+5+3=48$。  
为方便处理，可以直接将 $n$ 增加 $1$ 在进行计算，最后就不用统计 $\operatorname{popcount}(n)$ 了。  
这个部分的代码如下：
```cpp
int getsum(int x) {
	int res = 0, cnt = 0;
	x++;
	while (x) {
	    if(x & 1) res += (cnt * (1ll << (cnt - 1))) + (1ll << cnt) * popcount(x >> 1);
	    x >>= 1;
	    cnt++;
	}
	return res;
}
```

现在我们已经处理完了完整部分，接下来我们处理剩余部分。   
还是分析我们的事例，最后剩下 $3$ 位。可以发现，这个数就是下一个数的前三位。  
我们如何计算 $n$ 的前 $k$ 位？首先我们计算 $n$ 的二进制位数，也就是 $\lfloor\log_2n\rfloor$。我们可以将后 $\lfloor\log_2n\rfloor-k+1$ 位直接删去。这样留下来的就是前 $k$ 位了。最后我们对它求一遍 $\operatorname{popcount}$ 即可。

于是我们就做完了这道题。  
本篇题解共有 $3703$ 字符（包含这句话）。
# AC 代码
别问我这是什么语言。
```cpp
#include <bits/stdc++.h>
#define int long long/*
'''
*/
using namespace std;
int x, res;
int popcount(int x) {
	int res = 0;
	while (x) {
		res += x & 1;
		x >>= 1;
	}
	return res;
}
int getsum(int x) {
	int res = 0, cnt = 0;
	x++;
	while (x) {
	    if(x & 1) res += (cnt * (1ll << (cnt - 1))) + (1ll << cnt) * popcount(x >> 1);
	    x >>= 1;
	    cnt++;
	}
	return res;
}
signed main() {
	cin >> x; x--;
	int i;
	for (i = 0; ; i++) {
		if (x < (i + 1) * (1ll << i)) break;
		x -= (i + 1) * (1ll << i);
		res += (1ll << i);
	}
	res += x / (i + 1);
	x %= (i + 1);
	cout << getsum(res) + popcount(res + 1 >> (int)log2l(res + 1) - x + 1);
    return 0;
}
/*
'''
def popcount(x):
    res = 0;
    while x:
        res += x & 1;
        x >>= 1;
    return res;
def getsum(x):
    res = 0;cnt = 0;
    x += 1;
    while x:
        if x & 1:
            if cnt >= 1:res += cnt * (1 << (cnt - 1)) + (1 << cnt) * popcount(x >> 1);
            else:res += (1 << cnt) * popcount(x >> 1);
        x >>= 1;
        cnt += 1;
    return res;
x = int(input())
x -= 1;
res = 0;i = 0;
while True:
    if x < (i + 1) * (1 << i):break
    x -= (i + 1) * (1 << i);
    res += (1 << i);
    i += 1;
res += x // (i + 1);
x %= (i + 1);
ans = getsum(res) + popcount((res + 1) >> ((res + 1).bit_length() - x));
print(ans);
# */
```

---

## 作者：yanmingqian (赞：2)

有被恶心到。但是其实不太难。

题意：将 $0,1,2,3 \dots$ 的二进制顺次排列拼接为一个 $01$ 串，即 $011011100101110111\dots$。给定 $x$，求这个串前 $x$ 位 $1$ 的个数。$1\le x\le10^{18}$。

我们先把第一位的 $0$ 扔掉，考虑第 $2$ 到 $x$ 位。这一串序列显然是由一些**完整的数字**的二进制和**一个（也可能没有）不完整的数字**组成的。

考虑暴力怎么做。我们可以枚举完整的数字，计算它们的二进制中 $1$ 的个数（可以使用 `__builtin_popcount()` 函数实现），最后单独计算剩下的那个不完整的数字。代码如下：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main(){
    long long n,sum=0,ans=0,i=1;  //sum用于记录当前枚举到了第几位，i为枚举到了第几个完整的数字，ans记录答案
    cin>>n;
    n--;  //把第一位的0扔掉
    while(sum<n){
        sum+=floor(log2(i))+1;
        ans+=__builtin_popcount(i);
        i++;
    }
    i--;
    long long x=sum-n;
    cout<<ans-__builtin_popcount(i)+__builtin_popcount(i>>x);
    return 0;
}
```

这样显然无法通过此题。分析代码，发现瓶颈在于枚举有多少个完整的数字和记录答案（也就是枚举计算代码中的 `i` 和 `ans`）。分别考虑如何优化。

先来考虑，如果我们已经知道了完整数字的个数，如何计算答案。也就是已知 $k$，如何计算前 $k$ 个正整数的二进制下 $1$ 的个数之和。我们使用暴力来打表，发现前 $i$ 个正整数二进制下 $1$ 的个数之和是这样一个序列：

```
1 2 4 5 7 9 12 13 15 17 20 22 25 28 32 33 ...
```

设这个序列的第 $i$ 项为 $a_i$。手动找规律，或者丢到 [OEIS](https://oeis.org/) 上，发现 $a_{2n+1}=2a_n+n+1$，当然也有别的求法，在[这里](https://oeis.org/A000788)或者另外的题解有介绍。那么我们可以写出这样一个函数来递归求解 $a_x$：

```cpp
long long get(long long x){
    if(!x){
        return 0;
    }
    if(x&1){
        return 2*get(x/2)+x/2+1;
    }
    else{
        return 2*get(x/2)+x/2+1-__builtin_popcountll(x+1);
    }
}
```

显然，由于每次 $x$ 变为原来的一半，这个函数时间复杂度为 $O(\log x)$。

因此前面的暴力可以优化（实际上并没有，只是向正解贴近）为下面这样：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long get(long long x){
    if(!x){
        return 0;
    }
    if(x&1){
        return 2*get(x/2)+x/2+1;
    }
    else{
        return 2*get(x/2)+x/2+1-__builtin_popcountll(x+1);
    }
}
int main(){
    long long n,sum=0,ans=0,i=1;
    cin>>n;
    n--;
    while(sum<n){
        sum+=floor(log2(i))+1;
        i++;
    }
    i--;
    long long x=sum-n;
    cout<<get(i)-__builtin_popcountll(i)+__builtin_popcountll(i>>x);
    return 0;
}
```

虽然实际上复杂度还是不足以通过，但是我们的瓶颈少了一个。现在我们只需要设法快速求解完整的数字个数即可。

注意到在一段连续的区间内，所有数的二进制长度是相同的。这很好理解，与十进制类似，连续一段数字的位数是相同的。想办法利用这一点。考虑对原 $01$ 序列再次分段，将长度相同的分为一大段。那么由于每次到 $2^n$ 会进一次位，第 $i$ 大段的长度为 $2^{i}-2^{i-1}=2^{i-1}$，这一大段每个数二进制长度为 $i$，所以这一大段总长度为 $i\times 2^{i-1}$。与前面类似，我们枚举完整的大段即可。接下来考虑不完整的大段。不完整的大段中剩下的与整段类似，也是由一些完整的数字和零个或一个不完整数字组成的。不同的是，这些完整数字的位数都是相同的，我们可以轻松地直接求出完整数字的个数，再用与前面暴力相同的方式算上不完整的数字即可。

综上，我们可以写出下面的 AC 代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long get(long long x){
    if(!x){
        return 0;
    }
    if(x&1){
        return 2*get(x/2)+x/2+1;
    }
    else{
        return 2*get(x/2)+x/2+1-__builtin_popcountll(x+1);
    }
}
int main(){
    long long n,sum=0,ans=0,i=1;
    cin>>n;
    n--;
    //此处i枚举的是大段
    while(sum<n){
        sum+=i*(1ll<<(i-1));
        i++;
    }
    i--;
    sum-=i*(1ll<<(i-1));
    i--;
    long long x=0;  //通过大段数量统计数字个数
    for(long long j=0;j<i;j++){
        x+=(1ll<<j);
    }
    sum=n-sum;
    i++;
    ans=get(x+sum/i);
    x+=sum/i+1;
    long long r=i-sum%i;
    cout<<ans+__builtin_popcountll(x>>r);
    return 0;
}
```

时间复杂度约为 $O(\log x)$，可以通过本题。

---

## 作者：AASDFGHJKL (赞：0)

# 题解：P12191 [蓝桥杯 2025 省研究生组] 01 串
## 思路
这一道题说得很明白了，我们就是求 $1-x$ 之间的 $1$ 的数量。我们可以进行分块，假设当前二进制数位为 $k$ 就是将有 $k$ 个二进制位分别放在一起进行统计，通过数学公式能计算出来。
### 推导过程
首位的贡献：因为有 $k$ 个二进制数，且首位都为 $1$，统计它们用 $2^{k-1}$ 这个公式解决。

其它位的贡献：第 $i$ 位的值在每 $2^{i+1}$ 个数中会重复一次。在每一个周期内，前 $2^i$ 个数该位为 $0$，后 $2^i$ 个数为 $1$。所以周期数公式是 $\frac{2^{k-1}}{2^{i+1}}=2^{k-i-2}$，那么就有 $2^{k-2}$ 个 $1$，这是周期问题的基本公式。

它们合并后就是 $(k+1) \times 2^{k−2}$。

不过以上是完整的块的推导，所以还有剩余的不完整块的推导。

完整的 $1$ 数量：假设块 $k$ 的二进制长度为 $k$，数的范围是 $[2^{k-1}, 2^k-1]$，共有 $2^{k-1}$ 个数,所以 $t$ 就是首位完整 $1$ 的数目。

余下完整的公式：每一个末位 $b$，每个周期内前 $2^b$ 个数该位为 $0$，而后 $2^b$ 个数为 $1$，则有  $t \bmod 2^{b+1} \times 2^b$ 个 $1$。

剩余的公式：我们定义 $\operatorname{rem}$ 是余数部分贡献，按照周期规律则 $\operatorname{rem}= t \bmod 2^{b+1}$，若 $\operatorname{rem} > 2^b$，则有 $\operatorname{rem} - 2^b$ 个 $1$。

它们合并后就是 $ \sum_{b=0}^{k−2} (\lfloor 2 b+1 t\rfloor \times 2^b +\max(0, t \bmod 2^{b+1}−2^b ))$ 最后加上 $t$ 就通过了吗？不，还要在加上直接求出剩余 $1$ 的数量。

到此这就算推导完毕了。
## 代码

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    long long x;// 前x位的1的个数
    cin >> x; 

    long long total_ones = 0; // 1的总数
    long long total_bits = 0; // 已处理的二进制位数
    int k = 1; // 当前处理的二进制块长度

    // 处理k=1的特殊块
    if (k == 1) {
        long long block_bits = 2; // k=1的块总共有2位（0和1各1位）
        if (total_bits + block_bits > x) { // 剩下余数不足则处理完整块
            long long left = x - total_bits; // 剩下要处理的位数
            long long ones = 0;
            // k=1的块内容为"01"，若剩余的位数大于等于2则包含1个1（来自于数字1）
            if (left >= 2) ones += 1; 
            total_ones += ones;
            cout << total_ones << endl;//输出
            return 0;//完结撒花
        } else { // 处理完整的k=1块
            total_ones += 1; // 块提供的1个1
            total_bits += 2; // 累计处理了2位
            k = 2; // 进入到下一个块（k=2）
        }
    }

    // 处理k≥2的块（每个块包含二进制长度为k的自然数）
    while (true) {//死循环
        long long m = 1LL << (k - 1); // 块k包含的数字个数
        long long block_bits = k * m; // 块k的总位数

        // 如果当前块是不完整块
        if (total_bits + block_bits > x) {
            long long left = x - total_bits; // 计算剩余需要处理的位数
            long long t = left / k; // 能完整处理的数字个数
            t = min(t, m); // 这个t不能超过块k的总数字数
            long long remaining_bits = left - t * k; // 剩余不完整的数的位数

            // 计算前t个完整数字的1数量
            long long ones = t; // 最高位提供的t个1（每个数的最高位都是1）
            // 遍历每个末位（从最末位到次高位）
            for (int b = 0; b <= k - 2; ++b) {
                long long cycle = 1LL << (b + 1); // 当前位的周期长度
                long long full_cycles = t / cycle; // 完整的周期数
                long long rem = t % cycle; // 剩余不完整周期的数字数
                // 完整周期提供1的数目
                long long count = full_cycles * (1LL << b); 
                // 处理剩余的部分
                if (rem > (1LL << b)) {
                    count += rem - (1LL << b);
                }
                ones += count; // 累计当前位的1数量
            }
            total_ones += ones; // 将前t个数的1数目加入总数

            // 处理剩余位数（第t+1个数的前remaining_bits位）
            if (remaining_bits > 0) {
                // 计算当前处理的数字（块k的第t+1的数）
                long long current_number = (1LL << (k - 1)) + t; 
                // 生成此数字的k位二进制字符串（由高到低）
                string binary;
                for (int i = k - 1; i >= 0; --i) {
                    binary += (current_number & (1LL << i)) ? '1' : '0';
                }
                // 获取前remaining_bits位并统计1的数量
                string bits = binary.substr(0, remaining_bits);
                int count = 0;
                for (char c : bits) {
                    if (c == '1') ++count;
                }
                total_ones += count;
            }

            cout << total_ones << endl;//输出
            return 0;//完结撒花
        } else { // 处理完整块k
            total_bits += block_bits; // 累计已处理的位数
            // 以上公式：求块k的总1数
            total_ones += (k + 1) * (1LL << (k - 2)); 
            ++k; // 进入下一个块（k+1）
        }
    }
}
```
**End**

---


# [蓝桥杯 2024 国 Java B] 数据库

## 题目描述

小蓝最近设计了一款“阅后即焚”数据库，顾名思义这个数据库只有两种操作：增加一条数据和删除一条数据。简言之，这款数据库中只有一个表，且这个表只有两列：$id$ 和 $value$，其中每条数据都有一个独一无二的编号 $id$，$value$ 则是这条数据对应的存储内容。

数据库操作语句有且仅有两种：

1. $\text{INSERT}$ $id$ $value$：插入一条新的数据，编号为 $id$，内容为 $value$。
2. $\text{DELETE}$ $id$：删除编号为 $id$ 的数据。

现在给出 $N$ 条数据库语句，我们保证按照给出的语句顺序执行是合法的，合法指的是：$\text{INSERT}$ 时数据库中一定不存在编号为 $id$ 的数据，$\text{DELETE}$ 时数据库中一定存在编号为 $id$ 的数据，且同一个编号 $id$ 不会被 $\text{INSERT}$ / $\text{DELETE}$ 多次。

你可以任意调整这些语句的执行顺序，现在请问一共有多少个不同的语句执行顺序，能够使得调整之后的语句顺序依旧是合法的并且按序执行之后数据库内容和给出的初始语句顺序执行后的结果一致。结果一致指的是二者包含的 $id$ 集合是相同的，并且相同的 $id$ 对应的 $value$ 也是相同的。

## 说明/提示

### 样例说明

一共有 $6$ 种不同的排列方式：

| 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| INSERT 1 1 | INSERT 1 1 | INSERT 2 2 | INSERT 2 2 | INSERT 1 1 | INSERT 2 2 |
| INSERT 2 2 | INSERT 2 2 | INSERT 1 1 | INSERT 1 1 | DELETE 1 | DELETE 2 |
| DELETE 1 | DELETE 2 | DELETE 1 |DELETE 2 | INSERT 2 2 | INSERT 1 1 |
| DELETE 2 | DELETE 1 | DELETE 2 | DELETE 1 | DELETE 2 | DELETE 1 |

它们都是合法的并且执行完后数据库中的内容都一样：没有任何数据。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N \leq 10$。
- 对于 $60\%$ 的评测用例，$1 \leq N \leq 1000$。
- 对于 $100\%$ 的评测用例，$1 \leq N \leq 10^5$，$id$ 和 $value$ 均是 32 位有符号整数。

## 样例 #1

### 输入

```
4
INSERT 1 1
INSERT 2 2
DELETE 1
DELETE 2```

### 输出

```
6```

# 题解

## 作者：tuboshu666 (赞：1)

## 简化题意
共有 $N$ 次 INSERT 和 DELETE 操作，保证 INSERT 一定在 DELETE 前，且有 DELETE 必定有 INSERT，而 INSERT 可以单独存在。求合法方案的顺序数。

## 思路
将这 $N$ 次操作分成两类。一类有完整插入和删除操作，另一类仅有插入操作。

首先看插入和删除操作完整的一类。设有 $m$ 组完整操作配对。尝试将这 $m$ 组操作一组组插入。

插入第 $1$ 组，方案显然只有 $1$ 种。

插入第 $2$ 组，相当于在 $4$ 个位置中，选择 $2$ 个插入第二组的两个操作，方案数为 $\binom{4}{2}$。

插入第 $3$ 组，同理，相当于在 $6$ 个位置，认为另 $4$ 个顺序固定，选择 $2$ 个插入，方案数为 $\binom{6}{2}$。$\binom{6}{2}$ 是仅考虑第 $3$ 组有几种插入方式，再乘上另 $4$ 个位置的组合，即前 $2$ 组的组合数，即得插入到第 $3$ 组时的总方案数。

于是，这 $m$ 组操作的总方案数为：
$$
\prod_{i=1}^m \binom{2i}{2}
$$

再看仅有插入操作的一类。设该类操作有 $k$ 个。考虑在计算完第一类操作的情况下，插入这 $k$ 个操作。其中 $2m+k=N$。

与第一类相似，这 $k$ 个操作可以看做在 $n$ 个位置中，固定第一类 $2m$ 个操作的次序，选择 $k$ 个插入。由于这 $k$ 个操作不需要考虑任何顺序。因此，该类操作的方案数为：$\mathrm{A}_n^k$。

两类操作方案相乘即得最终答案。

## Code
```cpp
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

const int N = 1e6 + 10;
const int MOD = 1e9 + 7;
unordered_map<int,int> mp;
long long sum[N];
long long C[N][10]; //组合数

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    //组合数递推
    for (int i = 0 ; i <= 1e6 ; i++) C[i][0] = 1;
    for (int i = 1 ; i <= 1e6 ; i++)
    {
        for (int j = 1 ; j <= min(2,i) ; j++)
        {
            C[i][j] = C[i-1][j-1] + C[i-1][j];
            C[i][j] %= MOD;
        }
    }

    int n;
    cin >> n;
    int m = 0; //完整操作组数
    for (int i = 1 ; i <= n ; i++)
    {
        string type;
        cin >> type;
        if (type == "INSERT")
        {
            int x,y;
            cin >> x >> y;
            mp[x]++;
        }
        else
        {
            int x;
            cin >> x;
            mp[x]--;
            m++;
        }
    }

    long long ans = 1;
    int k = 2;

    //计算完整操作的组合数
    for (int i = 1 ; i <= m ; i++)
    {
        ans *= C[k][2];
        k += 2;
        ans %= MOD;
    }

    //计算insert的排列数
    for (int i = 2*m+1 ; i <= n ; i++)
    {
        ans *= i;
        ans %= MOD;
    }

    cout << ans << endl;

    return 0;
}
```

---

## 作者：kuaiCreator (赞：1)

## 题目大意
给出一串插入和删除序列，可以任意打乱序列，计算使得插入和删除执行完成后的结果相同的方案总数，结果对 $10^9+7$ 取模。

## 解题思路
考虑有 $m$ 对二元组 $[I_1,D_1][I_2,D_2]\dots[I_m,D_m]$。问题可以转换为将 $m$ 对二元组全排列并且保证每一对二元组都存在 $I_i$ 一定在 $D_i$ 之前出现。答案为：
$\displaystyle\frac{(2\times m)!}{2^m}$。即对 $2\times m$ 个元素全排列后去掉每组的 $D_i$ 在前，$I_i$ 在后的情况总数。

但是还可能存在 $p$ 种，只有插入的情况。因此总的答案数为 $\displaystyle\frac{(2\times m+p)!}{2^m}$ 由于 $2\times m+p=n$ 所以答案是 $\displaystyle\frac{n!}{2^m}$。对结果取余 $10^9+7$，需要求逆元。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7, N = 1e5 + 5;
long long fpow(long long a, int b, int mod) {
	long long s = 1;
	while (b > 0) {
		if (b & 1) {
			s = (s * a) % mod;
		}
		a = (a * a) % mod;
		b >>= 1;
	}
	return s;
}
int main() {
	int n;
	cin >> n;
	unordered_map<int, int> opCount; 
	for (int i = 0; i < n; i++) {
		string op;
		int id, val;
		cin >> op >> id;
		if (op == "INSERT") 		cin >> val, opCount[id]++;
		else if (op == "DELETE") 	opCount[id]--;
	}
	int m = 0;
	for (auto& [id, cnt] : opCount) 
		if (cnt == 0) m++;  // 统计成对的INSERT和DELETE
	
	long long fact[N] = {0};
	fact[0] = 1;
	for (int i = 1; i <= n; i++) {
		fact[i] = (fact[i - 1] * i) % MOD;
	}

	long long den = fpow(2, m, MOD);
	long long inv = fpow(den, MOD - 2, MOD);

	long long ans = (fact[n] * inv) % MOD;
	cout << ans << endl;

	return 0;
}
```

---

## 作者：tonysui666 (赞：0)

**[题目传送门](https://www.luogu.com.cn/problem/P12256)**

## 题目大意：

有 $N$ 个操作，每个操作仅会是 $\text{INSERT}$ 和 $\text{DELETE}$ 中的一种。现在给你一个这样的序列，求这个序列共有多少种合法的排列顺序

## 思路：

我们先来观察一下题目，显然可以发现对于任意一个 $\text{DELETE}$ 操作，一定有一个在它前面且 $id$ 相同的 $\text{INSERT}$ 操作与其配对。而对于 $\text{INSERT}$ 操作，它是可以单独存在的。

所以我们可以把 $N$ 次操作转变为 $m$ 组配对的 $\text{INSERT}$ 和 $\text{DELETE}$ 操作，和 $N - 2m$ 个单独的 $\text{INSERT}$ 操作。最后我们再把这两种方案数乘起来即可。

### 完整匹配操作：

首先考虑只有一组：显然只有 $1$ 种选择

考虑两组：相当于一共有 $4$ 个位置，任选两个位置插入第二组，剩余的两个位置让第一组插进去。方案数为 $C^2_4$。

考虑三组：同理，相当于一共有 $6$ 个位置，任选两个位置插入第三组，剩余的四个位置让第一，二组插进去。方案数为 $C^2_6$。

综上，我们可以发现，对于第 $i$ 组，它的方案数是 $C^{2}_{2i}$。所以对于 $m$ 组操作，它的总方案数就是
$$
\prod_{i = 1}^{m}C^{2}_{2i}
$$

而对于组合数，我们可以用递归的方法来计算：

已知：$ C^2_{i - 1} = \frac{(i - 1) \times (i - 2)}{2} = \frac{i^2 - 3i + 2}{2}$ ， $\large C^1_{i - 1} = i - 1 = \frac{2i - 2}{2}$ 

所以：$ C^2_{i - 1} + C^1_{i - 1} = \frac{i^2 - 3i + 2}{2} + \frac{2i - 2}{2} = \frac{i^2 - i}{2}$ 

而且：$ C^2_i = \frac{i \times (i - 1)}{2} = \frac{i^2 - i}{2}$ 

综上：$ C^2_i = C^2_{i - 1} + C^1_{i - 1}$

### 单独的 $\text{INSERT}$ 操作

对于剩下的 $N - 2m$ 个单独的 $\text{INSERT}$ 操作。我们可以理解为把这 $N - 2m$ 个操作插入 $N$ 个空里面即可。总方案数为 $A^N_k$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
const int MAXN = 1000005;
long long C[MAXN][3];
int main(){
    int n;
    cin >> n;
    int s, m;
    s = m = 0;
    for(int i = 1; i <= MAXN; i++){
        C[i][1] = i;
    }
    C[1][2] = 0;
    for(int i = 2; i <= MAXN; i++){
        C[i][2] = C[i - 1][1] + C[i - 1][2];//用优雅的打表来计算组合数
    }
    for(int i = 1; i <= n; i++){
        string a;
        cin >> a;
        if(a[0] == 'D'){
          int c;
          cin >> c;
          m++;
          s--;
        }
        else{
          int a, b;
          cin >> a >> b;
          s++;
        }
    }
    long long ans = 1;//不开long long见祖宗
    for(int i = 1; i <= m; i++){
        ans *= C[2 * i][2];
        ans %= mod;
    }
    for(int i = 2 * m + 1; i <= n; i++){
        ans *= i;
        ans %= mod;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：wangliu (赞：0)

# P12256 [蓝桥杯 2024 国 Java B] 数据库

## 题目思路

我们可以想象一个有 $n$ 个空间的表，我们可以把输入的操作填入表内，在合法的前提下，求不同方案数。

**注意**：对于同一个编号 $id$ 只会被 $\text{INSERT}$ / $\text{DELETE}$ 一次，并且 $\text{DELETE}$ 操作前一定有对应的 $\text{INSERT}$ 操作，而 $\text{INSERT}$ 操作后不一定 $\text{DELETE}$ 操作。

因此，我们可以把操作分成两类：

  - $\text{DELETE}$ 操作和 $\text{INSERT}$ 操作能匹配的，我们把这两个操作看作一组，其可能的情况数为 $C_k^2$ (其中 $k$ 为表内剩余的空间)，因为同一个编号 $id$ 只会被 $\text{INSERT}$ / $\text{DELETE}$ 一次，无需考虑每组之间的操作会不会导致非法，假设有 $m$ 组成对的操作，情况总数为：
$$\LARGE \frac{n!}{(n-2 \times m)! \times 2^m}$$
  - 剩下的 $n-2 \times m$ 的 $\text{DELETE}$ 操作没有任何限制，故可能的方案数为：
$$\large {(n-2 \times m)!}$$

综上，总方案数为 $\frac{n!}{2^m}$。

```cpp
//洛谷非常重视学术诚信。抄袭、复制题解和代码，以达到刷 AC 率/AC 数量或其他目的的行为，在洛谷是严格禁止的，这将会导致您成为作弊者。
#include<bits/stdc++.h>
using namespace std;
//const int sbCCF = 1e8+3;
const int mod = 1000000007;
#define ll long long
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
inline void print(ll x){
	if(x<0){putchar('-');x=-x;}
	if(x>9) print(x/10);
	putchar(x%10+'0');
}
int T,a,b,cnt;
ll ans = 1;
string s;
int main(){
	T=read();
	for(int i=1;i<=T;i++){//a和b没用
		cin>>s;
		if(s == "INSERT"){
			a=read();b=read();
		}
		else a=read(),cnt++;//统计第一种情况方案数
	}
	for(ll i=2*cnt;i>0;i-=2){
		ans *= (i - 1) * i / 2;
		ans %= mod;
	}
	for(int i=2*cnt+1;i<=T;i++){
		ans *= i;
		ans %= mod;
	}
	print(ans);
	return 0;
}
```

时间复杂度为 $$O(n)$$。


实际上可以也可以用**逆元**加速 ~~但是懒~~。

---

## 作者：caichengyia (赞：0)

~~代码最简短~~

仔细观察即可发现，由于题目给出已经合法，排序后变不合法只有一个原因，就是 `DELETE` 在 `INSERT` 前。

容易证明：
1. 有 `DELETE` 必有 `INSERT` 。
2. 对于每一对 `DELETE` 和 `INSERT` ，都恰有一半情况 `INSERT` 在 `DELETE` 前，都恰有一半情况 `DELETE` 在 `INSERT` 前。

所以我们可以这样操作：
1. 读入
2. 统计方法总数（包括成功的和不成功的）
3. 统计 `DELETE` 数量
4. 将方法总数乘 `DELETE` 数量个 $2$ 的逆元 $500000004$ 即为答案。
# Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long d=1,n,x,f;
string s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s>>x;//上文步骤1
		if(s=="DELETE")f++;//上文步骤3
		else cin>>x;
		d=d*i%1000000007;//上文步骤2
	}
	for(int i=1;i<=f;i++)d=d*500000004%1000000007;//上文步骤4
	cout<<d;
}
```

---


# [XJTUPC 2025] 离散对数

## 题目描述

给定正整数 $a$, $c$, $p$，保证 $p$ 是 **素数**，求 $b$ 使得：

$$a^b \equiv b^c \pmod{p}$$

我们称整数 $A, B, C$ 有 $A \equiv B \pmod{C}$，当且仅当存在整数 $k$ 使得 $A - B = C \times k$。

## 说明/提示

对于第一组样例，我们有：

$$3^{16} \equiv 16^5 \pmod{7}$$

因为：

$$3^{16} \bmod 7 = 43046721 \bmod 7 = 4$$

$$16^5 \bmod 7 = 1048576 \bmod 7 = 4$$

## 样例 #1

### 输入

```
3 5 7```

### 输出

```
16```

## 样例 #2

### 输入

```
14530529 19260817 19491001 ```

### 输出

```
5660025```

# 题解

## 作者：251Sec (赞：12)

不难发现左式只和 $b \bmod (p-1)$ 有关，右式只和 $b \bmod p$ 有关。而 $p \perp (p-1)$，于是两个取模的结果可以任取，总能 CRT 得到一个答案。

于是直接令 $b \equiv 0 \pmod {(p-1)}$ 且 $b \equiv 1 \pmod p$ 即可。解得 $b=(p-1)^2$。

---

## 作者：chenzefan (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P12540)
## 前言
看到是在最后一题，觉得肯定很难，所以没做。结果竟是一道水绿！
## 涉及知识
- 费马小定理。
## 思路
题目是这样讲的：

给定正整数 $a,c,p$，保证 $p$ 是**素数**，求 $b$ 使得： $a^b \equiv b^c \pmod{p}$。

看到模数 $p$ 是质数，一眼**费马小定理**，这里给出定理：如果 $p$ 是一个质数，而整数 $a$ 不是 $p$ 的倍数，则有 $a^{p-1} \equiv 1\pmod {p}$ 的结论。

容易发现，当 $b=(p-1)^2$ 时，可以满足条件。

代入原式，如下：

$a^b$：$a^{(p-1)^2} \equiv 1^{p-2} \equiv 1 \pmod {p}$。

$b^c$：${[(p-1)^2]}^c \equiv 1^c \equiv 1 \pmod {p}$。

于是，$b=(p-1)^2$ 就是答案。那么题目输入完后，直接输出即可。

注意：因为答案 $1 \le b \le 10^{18}$，所以，开 long long。另外，输出不要用函数 pow，我就是这样被坑了。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long a,c,p;
    cin>>a>>c>>p;
	cout<<(p-1)*(p-1);
    return 0;
}
```

---

## 作者：2672434062xzl (赞：5)

$$a^b \equiv b^c \pmod{p}$$

不妨令 $b \equiv a \pmod{p}$，则 $a^b \equiv a^c \pmod{p}$，因为 $p$ 是质数，且 $a<p$，所以 $a$ 与 $p$ 互质，根据费马小定理 $a^{p-1} \equiv 1\pmod{p}$，可得 $b \equiv c \pmod{p-1}$。

所以

$$\begin{cases} 
b \equiv a\pmod{p}\\
b \equiv c \pmod{p-1}
\end{cases} $$

$(p-1)(p-1) \equiv p^2-2p+1 \equiv 1\pmod{p}$，所以 $p-1$ 在模 $p$ 意义下的逆元为 $p-1$。

$p\equiv 1 \pmod{p-1}$，所以 $p$ 在模 $p-1$ 意义下的逆元为 $1$。

又因为 $p$ 与 $p-1$ 互质，根据中国剩余定理（CRT），答案即为 $(a(p-1)^2+c\cdot p) \mod{p(p-1)}$。

其中 $p(p-1)$ 接近 $10^{18}$，中间运算可能超过 `long long`，需用 `__int128`。

参考代码：

```cpp
#include<iostream>
using namespace std;
using ll=long long;
using lll=__int128;
int main(){
    ll a,c,p;
    cin>>a>>c>>p;
    lll mod=p*(p-1);
    cout<<ll((lll(a)*(p-1)%mod*(p-1)+lll(c)*p)%mod);
}
```

---

## 作者：_Null_Ptr (赞：5)

费马小定理加乘法阶加 CRT，不过数据似乎比较水，还是比较好过的。

第一眼看到 $p$ 是素数，想到可以利用费马小定理 $a^{p-1}\equiv 1\pmod{p}$ 来简化计算。然后因为有一个同余，于是可以通过乘法阶构造同余方程组，然后用 CRT 就行了。

具体思路和实现方法看代码。

```python
import sys, math

# 素因子分解函数
def f(n):
    fs = {}  # 用于存储素因子及其指数
    while n % 2 == 0:  # 处理偶数因子
        fs[2] = fs.get(2, 0) + 1
        n //= 2
    i = 3
    while i * i <= n:  # 处理奇数因子
        while n % i == 0:
            fs[i] = fs.get(i, 0) + 1
            n //= i
        i += 2
    if n > 1:  # 如果剩余部分大于1，则它是素数
        fs[n] = 1
    return fs

# 生成所有除数的函数
def g(fs):
    ds = [1]  # 初始化除数列表
    for p in fs:  # 遍历所有素因子
        es = [p ** e for e in range(fs[p] + 1)]  # 生成当前素因子的所有幂
        nds = []  # 用于存储新的除数列表
        for d in ds:  # 遍历当前除数列表
            for e in es:  # 遍历当前素因子的幂
                nds.append(d * e)  # 将新生成的除数加入列表
        ds = nds  # 更新除数列表
    return ds

# 计算乘法阶的函数
def h(a, p):
    if math.gcd(a, p) != 1:  # 如果a和p不互质，返回None
        return None
    n = p - 1
    if n == 0:  # 特殊情况处理
        return 1
    fs = f(n)  # 对p-1进行素因子分解
    ds = g(fs)  # 生成p-1的所有除数
    ds.sort()  # 对除数列表排序
    for d in ds:  # 遍历所有除数
        if d == 0:
            continue
        if pow(a, d, p) == 1:  # 如果a^d ≡ 1 (mod p)，则d是乘法阶
            return d
    return n  # 如果没有找到更小的阶，返回p-1

# 主函数
def m():
    a, c, p = map(int, sys.stdin.readline().split())  # 读取输入
    if a == 1:  # 特殊情况：a = 1
        print(1)
        return
    d = h(a, p)  # 计算a在模p下的乘法阶
    if d is None:  # 如果a和p不互质，返回1，不过好像没必要，p是质数
        print(1)
        return
    ip = pow(p, -1, p - 1)  # 计算p在模p-1下的逆元
    mt = 100000  # 设置最大尝试次数
    f = False  # 标记是否找到解
    for s in range(mt):  # 搜索
        x = (s * c) % d  # 计算x
        y = pow(a, s, p)  # 计算y
        de = (x - y) % (p - 1)  # 计算delta
        k0 = (de * ip) % (p - 1)  # 计算k0
        b = y + k0 * p  # 计算b
        if b < 1 or b > 1e18:  # 检查b是否在合法范围内
            continue
        if pow(a, b, p) == pow(b, c, p):  # 验证解
            print(b)
            f = True
            break
    if not f:  # 如果搜索未找到解
        if d <= 1000000:  # 如果乘法阶d较小，尝试遍历所有可能的s
            for s in range(mt, d):
                x = (s * c) % d
                y = pow(a, s, p)
                de = (x - y) % (p - 1)
                k0 = (de * ip) % (p - 1)
                b = y + k0 * p
                if b < 1 or b > 1e18:
                    continue
                if pow(a, b, p) == pow(b, c, p):
                    print(b)
                    f = True
                    break
        if not f:  # 最后尝试s = 0的情况
            x = (0 * c) % d
            y = pow(a, 0, p)
            de = (x - y) % (p - 1)
            k0 = (de * ip) % (p - 1)
            b = y + k0 * p
            print(b)

m()

```

---

## 作者：vegetable_king (赞：5)

考虑加强限制，构造：

$$a^b \equiv b^c \equiv 1 \pmod{p}$$

那么根据费马小定理，要求可以转化为 $b \equiv 0 \pmod{p - 1}, b \equiv 1 \pmod p$。

显然 $p - 1$ 和 $p$ 互质，可以直接解方程，有 $b = (p - 1)^2$。

---

## 作者：White_Wat (赞：3)

## 题目描述

给定正整数 $a$, $c$, $p$ ($1 \leq a, c < p \leq 10^9$)，保证 $p$ 是 **素数**，求 $b$ ($1 \leq b \leq 10^{18}$) 使得：

$$a^b \equiv b^c \pmod{p}$$

我们称整数 $A, B, C$ 有 $A \equiv B \pmod{C}$，当且仅当存在整数 $k$ 使得 $A - B = C \times k$。

## 分析

题目中的两个比较关键的点：
1. $b$ 的范围可以达到 $p^2$。
2. 保证 $p$ 是质数。

因为正整数 $a < p$，$p$ 为质数，所以一定有 $\gcd(a,p)=1$，根据[费马小定理](https://oi-wiki.org/math/number-theory/fermat/)，我们可以把式子化为：

$$a^{b \bmod (p-1)} \equiv (b \bmod p)^c \pmod p$$

因为如同前面说的点 1，所以我们可以考虑对 $b$ 的值进行构造：

$$
\begin{cases}
b \equiv c \pmod {p-1}\\
b \equiv a \pmod p
\end{cases}
$$

发现这是一个一元线性同余方程，根据[中国剩余定理](https://oi-wiki.org/math/number-theory/crt/)，这个方程在模 $p \times (p-1)$ 意义下有唯一解，这个范围是在 $p^2$ 内的，所以是合法的。

手推一下即可推出解为：

$$b \equiv a \times(p-1)^2 + c \times p \pmod {p\times (p-1)}$$
直接带入即可。

## 代码

```cpp
#include<bits/stdc++.h>  
  
using namespace std;  
  
typedef long long ll;  
#define For(x,y,z) for(ll x=y;x<=z;++x)  
#define Rof(x,y,z) for(ll x=y;x>=z;--x)  
#define pb push_back  
int rd(){  
    int re=0,flag=1;char ch=getchar();  
    while(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}  
    while(ch>='0'&&ch<='9'){re=re*10+ch-'0';ch=getchar();}  
    return re*flag;  
}  
ll rdl(){  
    ll re=0,flag=1;char ch=getchar();  
    while(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}  
    while(ch>='0'&&ch<='9'){re=re*10+ch-'0';ch=getchar();}  
    return re*flag;  
}  
  
ll a,c,mod;  
ll b;  
  
int main(){  
//    freopen(".in","r",stdin);  
//    freopen(".out","w",stdout);  
        a=rd(),c=rd(),mod=rd();  
    b=(long long)(__int128(a)*(mod-1)*(mod-1)%(mod*(mod-1))+c*mod)%(mod*(mod-1));  
    printf("%lld\n",b);  
        return 0;  
}
```

---

## 作者：jiazhichen844 (赞：2)

考虑钦定等号两边都为 $1$。

$p$ 是素数，注意到费马小定理：$a^{p-1}\equiv 1\pmod p$。  
然后易得 $\forall x\in\mathbb{N},a^{x(p-1)}\equiv 1\pmod p$。  
又注意到 $\forall k\equiv 1\pmod p,k^c\equiv 1\pmod p$。

所以只需构造一个 $b$，满足 $(p-1)|b,b\equiv 1\pmod p$。  
注意到 $b=(p-1)^2=p^2-2p+1$ 符合条件。  
直接输出即可。  
代码不放了。

---

## 作者：Vitamin_B (赞：1)

# 前置知识
你需要知道：对于每个素数 $p$ 和 $1\le x<p$ 的整数，都有 $x^{p-1}\equiv1\pmod p,(p-1)\equiv -1\pmod p$。

# 题解
我们只需要取 $b=(p-1)^2$ 即可。

左式：$a^{[(p-1)^2]}\equiv1^{p-1}\equiv1\pmod p$。

右式：$[(p-1)^2]^c\equiv[(-1)^2]^c\equiv1^c\equiv1\pmod p$。

---

## 作者：_Lazy_zhr_ (赞：1)

由于 $a<p$，根据费马小定理，对于正整数 $k$，$a^{k(p-1)}\bmod p=1$。

我们又注意到，$(p-1)^2\bmod p=1$。

于是当 $b=(p-1)^2$ 时，满足题目要求。

代码如下：

```cpp
int a,c,p;
void solve(){
	cin>>a>>c>>p;
	cout<<(p-1)*(p-1)<<"\n";
}
```

---

## 作者：StarTwinkleTwinkle (赞：1)

赛时我就是 rj。

直接考虑将 $a\equiv b\pmod{p}$ 与 $c\equiv b\pmod{p-1}$ 联立，直接进行 exCRT 即可。

或者考虑更简单的方法：直接令 $a^b\equiv b^c\equiv 1 \pmod{p}$，则可以（只列了一种情况）有：

$$\left\{\begin{matrix}
  b\equiv 0\pmod{p-1}\\
  b\equiv 1\pmod{p}
\end{matrix}\right.$$

易得，$b=(p-1)^2$ 为一个解，故直接输出 $(p-1)^2$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,c,p;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>a>>c>>p;
    cout<<(p-1)*(p-1);
    return 0;
}
```

---

## 作者：qwqerty (赞：1)

诈骗题。  
注意到 $a^{(p-1)^2} \equiv (a^{p-1})^{p-2}\equiv 1^{p-2}\equiv 1 \pmod{p}$，且 $[(p-1)^2]^c\equiv (p-1)^{2c}=(-1)^{2c}=1\pmod{p}$。所以输出 $(p-1)^2$ 即可。

---

## 作者：HDS_Acenaphthylene (赞：0)

我是糖比没看出来 $b =  (p - 1) ^ 2$。

给定正整数 $a$, $c$, $p$，保证 $p$ 是 **素数**，求 $b$ 使得：

$$a^b \equiv b^c \pmod{p}$$

显然若 $a \equiv b \pmod p$, 则:
$$a^c \equiv b^c \pmod p$$

根据费马小定理,有:
$$a^b \equiv a^{b \bmod (p - 1)}\pmod p$$

则由二式可得, 若
$$b\equiv a \pmod p$$
$$b\equiv c \pmod {p - 1}$$
则
$$a^b \equiv b^c \pmod{p}$$

显然是个 ExCRT 板子。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
std::ostream& operator << (std::ostream &out,__int128 a){
	if(a<0)out<<'-',a=-a;
	if(a>9)out<<a/10;
	return out<<(int)(a%10);
}
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
__int128 exgcd(__int128 a, __int128 b, __int128 &x, __int128 &y) {
	if(b == 0) {
		x = 1;
		y = 0;
		return a;
	}
	__int128 ret = exgcd(b, a % b, x, y);
	__int128 t = x;
	x = y;
	y = t - (a / b) * y;
	return ret;
}
struct equ{
	__int128 a, mod;
	equ operator +(equ b) {
		__int128 k1, k2;
		/*
		x = r1 mod m1  x = k1m1 + r1
		x = r2 mod m2  x = k2m2 + r2
		k1m1 - k2m2 = r2 - r1
		*/
		__int128 _m = mod / gcd(mod, b.mod) * b.mod;
		exgcd(mod, b.mod, k1, k2);
		k1 = (k1 + _m) % _m;
		k1 = ((b.a - a) / gcd(mod, b.mod) + _m) % _m * k1 % _m;
		__int128 _r = (k1 * mod + a) % _m ;
		return {_r, _m};
	}
};
signed main() {
	long long a;
	cin >> a;
	equ now;
	long long md, c;
	cin >> c >> md;
	now = {a, md};
	now = now + (equ){c, md - 1};
	cout << now.a;
	return 0;
}
```

---

## 作者：hhoppitree (赞：0)

注意到 $b=(c-a)p+a$ 符合条件，如果此时 $b<0$ 则令 $b\to b+p(p-1)$ 即可，复杂度 $\mathcal{O}(1)$。

证明：$a^b\equiv a^{b-(p-1)(c-a)}=a^c\equiv a^b\pmod p$。

---

## 作者：itzxianfish (赞：0)

# 题解

我们发挥人类的强大注意力。

注意到费马小定理 $a^{p-1}\equiv1\pmod p$ 于是 $a^{(p-1)^k}\equiv1^{(p-1)^{k-1}}\equiv1\pmod p$。

又注意到 $p-1\equiv-1\pmod p$ 于是 $(p-1)^n\equiv(-1)^n\pmod p$。

对于第二点，我们进一步注意到 $n$ 是偶数时，$(p-1)^n\equiv1\pmod p$。

有了以上注意能力，我们回到原式 $a^b\equiv b^c\pmod p$。

我们所求是 $b$，不妨对左式套用上述费马小定理的推论，右式套用 $p-1\bmod p=-1$ 的性质，在 $p$ 是给定质数的条件下有通解 $b=(p-1)^{2k}$ 其中 $k$ 是自然数。

但是题目要求 $1\le b\le 10^{18}$，再次发动观察力我们发现，取 $b=(p-1)^2$ 恰好能满足 $p\le 10^9$ 时，$b\le 10^{18}$ 的条件。

由于只需要输出满足题意解，综上：$b=(p-1)^2$ 即可。

（代码就不必了吧 O_o ）。

有一说一要是要求输出最小的的答案真就炸了（汗）。

一改：修复取模和同余的 LaTeX 问题。

---

## 作者：xnmzyz (赞：0)

# [题解：P12540 [XJTUPC 2025] 离散对数](https://www.luogu.com.cn/problem/P12540)

## 题目描述

给定正整数 $a$, $c$, $p$，保证 $p$ 是 **素数**，求 $b$ 使得：
$$a^b \equiv b^c \pmod{p}$$

## 前置芝士：[费马小定理](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158)
先说结论：直接输出 $(p-1)^2 $ 。 $\textcolor{white}{(我可以说是瞪眼法吗qaq)}$
## 证明
由费马小定理知，如果 $p$ 是一个质数，而整数 $a$ 不是 $p$ 的倍数，则有：
$$ a^{p-1} \equiv 1 \pmod{p} $$

这意味着 a 的幂次在模 p 下以 p-1 为周期。

因此，对于任意指数 $b$ 有：

$$ a^b \equiv a^{b \bmod (p-1)} \pmod{p} $$

我们令 $ b = (p-1)^2 $ 则有：$ \textcolor{white}{(真的是瞪眼法qwq)}$

$$ b \equiv 0 \pmod{p-1} $$

于是：

$$ a^b \equiv a^0 \equiv 1 \pmod{p} $$

又因为：

$$ b = (p-1)^2 = p^2 - 2 \times p + 1 $$

$$\begin{cases}
  p^2 \equiv 0 \pmod{p} \\
  2 \times p \equiv 0 \pmod{p} \\
  1 \equiv 1 \pmod{p} \\
\end{cases}$$

所以：
$$ b^c \equiv b \equiv 1 \pmod{p} $$

显然，当 $b=p-1$ 时
$$ a^b \equiv b^c \pmod{p} $$

证毕

## code $\textcolor{white}{(不会真有人不会写吧)}$

```cpp
#include<iostream>
using namespace std;
long long p;//记得开long long!
int main(){
    cin>>p>>p>>p;//连a,c都不用读
    cout<<(p-1)*(p-1);
}
```
[record](https://www.luogu.com.cn/record/217774051)

---

## 作者：Misserina (赞：0)

赛场上脑子抽住了想不出正解，赛后重新想了一下发现这题相当的诈骗。

根据费马小定理，若 $p$ 为素数且 $\gcd(a,p) = 1$，则 $a^{p-1} \equiv 1 \pmod p$。因为题目中 $a < p$，所以 $\gcd(a,p)$ 必然为 $1$，费马小定理适用。

因为 $p^2-2p+1 = (p-1)^2$，所以 $a^{p^2-2p+1} = (a^{p-1})^{p-1} \equiv 1 \pmod p$。

又因为 $p^2-2p+1 = p(p-2)+1 \equiv 1 \pmod p$，所以 $\forall c \in \mathbb{N}^+,(p^2-2p+1)^c \equiv 1 \pmod p$。

因此 $p^2-2p+1$ 就是符合要求的一个 $b$ 的取值，此时 $a^b \bmod p = b^c \bmod p = 1$。因为 $p \le 10^9,p^2-2p+1 = (p-1)^2 < 10^{18}$，满足题目对 $b$ 的范围要求。

---

## 作者：ztd___ (赞：0)

观察到了指数、模意义，素数二字也加粗了，考虑费马小定理：$a ^ {p - 1} \equiv 1 \pmod{p}$。其中 $p$ 为任意素数。

做一做会发现极难构造与 $a$ 和 $c$ 有关的 $b$。于是我们大胆猜测 $a$，$c$ 与 $b$ 之间没有任何关系。

结合费马小定理不难猜测出来，式子的左边极有可能是 $1$。这就意味着 $a^b$ 是若干个 $1$（即 $a ^ {p - 1}$）的乘积。此时由幂的计算规律不难知道，$b$ 一定是若干个 $p - 1$ 的和。

不妨设 $b = k \times (p - 1)$。

这样式子左边是 $1$，意味着右边也是 $1$。

容易发现 $p - 1 \equiv -1 \pmod{p}$，所以 $b \equiv -1 \times k \pmod{p}$。

所以右边就是 $(-1 \times k)^c$。

因为右边是 $1$，所以我们大胆猜测底数（即 $-1 \times k$）就是 $1$。这样就可以计算出 $k = -1$。

而 $b$ 不能是负数，所以把 $k$ 转化为 $p - 1$ 即可。

答案就是 $(p - 1)^2$。

- - -

另一种思考方法。

注意到[去年的最后一题](https://www.luogu.com.cn/problem/P10532)也是答案极其简单的数学题，不妨猜测今年的答案也会异常简单。

发现 $p$ 是素数被加粗了，所以答案肯定和 $p$ 有密切的关系。

大胆猜测答案不会很离谱。

对 $p$，$p + 1$，$p - 1$，$p^2$，$p^2 - 1$，$p^2 + 1$，$(p + 1)^2$，$(p - 1)^2$ 等等近似的 $b$ 进行枚举，就可以发现 $(p - 1)^2$ 就是答案。

---


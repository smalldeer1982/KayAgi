# [蓝桥杯 2025 国 Python A] 杨辉三角

## 题目描述

小蓝最近迷上了杨辉三角, 杨辉三角是一个无限向下递增的数字三角形。下图展示了杨辉三角的前 $11$ 行：

![](https://cdn.luogu.com.cn/upload/image_hosting/ofo2lqoz.png)

我们定义函数 $f(i)$ 表示数字 $i$ 在杨辉三角中出现的次数（其中 $i \geq 2$）。

现在，给定一个正整数 $n$（$n \geq 2$），请你完成以下任务：
- 对于所有满足 $2 \leq x \leq n$ 的整数 $x$，计算出对应的 $f(x)$；
- 将所有具有相同 $f(x)$ 值的数字归为一组；
- 统计并输出每个不同的 $f(x)$ 值出现了多少次。

## 说明/提示

**【样例说明】**

$x$ 的取值范围是 $[2, 5]$，其中 $f(2) = 1$，$f(3) = f(4) = f(5) = 2$，即值为 $1$ 出现了 $1$ 次，值为 $2$ 出现了 $3$ 次。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$2 \leq n \leq 100$；

对于 $40\%$ 的评测用例，$2 \leq n \leq 1000$；

对于 $60\%$ 的评测用例，$2 \leq n \leq 10,000$；

对于所有评测用例，$2 \leq n \leq 100,000$。

## 样例 #1

### 输入

```
5```

### 输出

```
1 1
2 3```

# 题解

## 作者：HArcturus (赞：1)

## 题目简述

记 $f(x)$ 为正整数 $x$ 在杨辉三角中出现的次数。题目要求：  
**给定 $n$，枚举 $2 \leq x \leq n$，统计不同的 $f(x)$ 各自出现了多少次。**

## 等价递推变形

观察杨辉三角（数字前标注 `*` 说明该数字在对称轴上），如下图所示（记为图 A）：

```plaintext
                           *1
                         1   1
                       1   *2   1
                     1   3   3   1
                   1   4   *6   4   1
                1   5   10   10   5   1
              1   6   15   *20   15   6   1
           1   7   21   35   35   21   7   1
         1   8   28   56   *70   56   28   8   1        
     1   9   36   84   126   126   84   36   9   1     
1   10   45   120   210   *252   210   120   45   10   1
```

将杨辉三角逆时针旋转 $45^\circ$，得到图 B：

```plaintext
*1   1   1   1  1  1  1   1   1   1
 1  *2   3   4  5  6  7   8   9  10
 1   3  *6  10 15 21 28  36  45  55
 1   4  10 *20 35 56 84 120 165 220
```

坐标规定：左上角为 $(0,0)$，向右为 $x$ 轴正方向，向下为 $y$ 轴正方向。  
例如：

```plaintext
1(0,0)  1(1,0) 1(2,0)  
1(0,1)  2(1,1) 3(2,1)  
1(0,2)  3(1,1) 4(2,2)
```

杨辉三角每一行开头和结尾的数是 1；每一行中间的数字等于其“肩”上两数的和。  
转换成图 B 的形式就是第 $1$ 行（$y=0$ 行）和第 $1$ 列（$x=0$ 列）的数都是 $1$；坐标为 $(x,y)$（$x \neq 0$ 且 $y \neq 0$）的数等于 $(x-1,y)$ 和 $(x,y-1)$ 的和。

即

$$
\text{M}[x][y] = \text{M}[x-1][y] + \text{M}[x][y-1]
$$

题目给定 $n$，要求我们统计 $2 \leq x \leq n$ 的整数 $x$ 在杨辉三角出现的次数 $f(x)$，并统计不同 $f(x)$ 值的出现次数。只需递推并统计即可。

## 暴力做法

```python
from collections import defaultdict

n = int(input())
M = [[1] * n for _ in range(n)]

# count[x] 表示 x 在杨辉三角出现的次数
# 即 f(x) = count[x]
count = defaultdict(int)

for i in range(1, n):
    for j in range(1, n):
        num = M[i][j] = M[i - 1][j] + M[i][j - 1]
        if num > n:
            break
        else:
            count[num] += 1

# stat[n] 表示有多少个 x 使 f(x) = n
stat = defaultdict(int)
for x in range(2, n + 1):
    stat[count[x]] += 1

# 字典自动根据 k 排序，无需额外排序后输出
for k, v in stat.items():
    print(k, v)
```

**注释：**
- 第 $1$ 行（$y=0$ 行）开头两个数字为 $1$ 和 $1$，到第 $n$ 行（$y=n-1$ 行）开头两个数字为 $1$ 和 $n$，根据递推公式下一行前两个数字（坐标为 $[0,n]$ 和 $[1,n]$）为 $1$ 和 $n+1$，必定大于 $n$。因此只需遍历到第 $n$ 行即可。
- 题目要求只统计大于等于 $2$ 的数，遍历 $x, y$ 坐标都是从 $1$ 开始，因此不会遍历到 $1$，也就是无需对 `num` 进行额外判断是否大于 $1$。

**结果：** $50$ 分，剩下的点 MLE。

## 优化一：滚动数组

递推公式只需上一行，矩阵可压缩为两行：

```python
from collections import defaultdict

n = int(input())
M = [[1] * n for _ in range(2)]

# count[x] 表示 x 在杨辉三角出现的次数
# 即题目 f(x) = count[x]
count = defaultdict(int)

for _ in range(1, n):
    for j in range(1, n):
        num = M[1][j] = M[0][j] + M[1][j - 1]
        if num > n:
            break
        else:
            count[num] += 1
    
    M[0] = M[1].copy()

# stat[n] 表示有多少个 x 使 f(x) = n
stat = defaultdict(int)
for x in range(2, n + 1):
    stat[count[x]] += 1

# 字典自动根据 k 排序，无需额外排序后输出
for k, v in stat.items():
    print(k, v)
```

**结果：** $60$ 分，剩下的点 TLE。

## 优化二：利用对称性

考虑到杨辉三角是个对称结构，观察图 A 可知，对称轴上的数“肩”上两数是相同的。

再次观察图 B（数字前标注 `*` 说明这个数字在对称轴上）：

```plaintext
*1   1   1   1  1  1  1   1   1   1
 1  *2   3   4  5  6  7   8   9  10
 1   3  *6  10 15 21 28  36  45  55
 1   4  10 *20 35 56 84 120 165 220
```

可以发现，对称轴上的数（数字前标注 `*` 的数）不仅满足递推公式 $ \text{M}[x][y] = \text{M}[x-1][y] + \text{M}[x][y-1] $，还满足 $ \text{M}[x][y] = \text{M}[x][y-1] \times 2 $。

也就是说，在 $y = i (i \ge 1)$ 的行，可以直接从 $ \text{M}[i][i] $ 开始递推，无需计算前 $i$ 个数。

因此，完整的递推公式为：
$$ \text{M}[x][y] = \begin{cases}
1 \quad (x = 0 \text{ 或 } y = 0) \\
\text{M}[x][y-1] \times 2 \quad (x > 1,\, y > 1,\, x = y) \\
\text{M}[x-1][y] + \text{M}[x][y-1] \quad (x > 1,\, y > 1,\, x \neq y) 
\end{cases}$$

最终 AC 代码如下：

```python
from collections import defaultdict

n = int(input())
M = [[1] * n for _ in range(2)]

# count[x] 表示 x 在杨辉三角出现的次数
# 即题目 f(x) = count[x]
count = defaultdict(int)

for i in range(1, n):
    num = M[1][i] = M[0][i] * 2
    if num > n:
        break  # 对称轴上的都比 n 大了，这一行后续的数必定比 n 更大，下一行的也必定比 n 更大，因此直接结束
    else:
        count[num] += 1  # 此处 num 为对称轴上的数

    for j in range(i + 1, n):
        num = M[1][j] = M[1][j - 1] + M[0][j]
        if num > n:
            break  # num 比 n 大了，这一行后面的也必定比 n 大，结束这一行
        else:
            count[num] += 2  # 此处 num 为非对称轴上的数

    M[0] = M[1].copy()

# stat[n] 表示有多少个 x 使 f(x) = n
stat = defaultdict(int)
for x in range(2, n + 1):
    stat[count[x]] += 1

# 字典自动根据 k 排序，无需额外排序后输出
for k, v in stat.items():
    print(k, v)
```

## 总结

本题关键知识点：

1. 杨辉三角的递推公式与对称性。
    - 理解杨辉三角的生成方式，发现并利用其对称结构进行优化。
2. 动态规划与滚动数组优化。
    - 用动态规划思想递推出所有可能的数，并通过滚动数组降低空间复杂度。

---

第一次写投稿题解，欢迎指正！

---

## 作者：YBa2Cu3O7 (赞：0)

滚动数组

## 思路
一个朴素的想法是，使用一个长度为 $k$ 的数组记录第 $k$ 层的值，逐个层的计算，一直统计到第 $n$ 层，根据单调性，再往后的一定超过了 $n$ 所以可以停止。但根据数据范围，$O(n^2)$ 的做法一定会超时。

杨辉三角形中第一斜线全部为 $1$，第二斜线是 $1\sim n$，第三斜线是 $\sum_{i=1}^{n} i \sim \frac{n^2}{2}$。第三斜线的增长率就已经非常快了，因此考虑只计算到大约 $m\sim\sqrt{n}$ 的位置，保证第 $m$ 层时第三斜线上的值已经超过了 $n$，再往下就只有第二斜线上会出现需要统计的值，因此只需要简单地对剩下的值出现次数 $+2$ 即可。这样时间复杂度降低到 $O(n\sqrt{n})$。

尖顶的 $1$ 视为第 $0$ 层，在第 $k$ 层时第三斜线上的值为 $\frac{k(k-1)}{2}$，因此计算终止层数 $m$ 要满足 
$$
\frac{m(m-1)}{2} > n
$$
反过来的循环条件就是 $m(m-1)\le 2n$。

## 代码
当 $n$ 足够大之后有可能出现溢出的情况，根据数据范围，直接截断即可。用 `map` 是为了有序输出。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    vector<int> prev={1,1};
    unordered_map<int,int> ump;
    int i;
    for(i=2;(i-1)*i<=2*n;++i){
        vector<int> nxt(prev.size()+1,1);
        for(int j=1;j<nxt.size()-1;++j){
            nxt[j]=min(prev[j-1]+prev[j],(int)1e6);
            ump[nxt[j]]++;
        }
        prev=std::move(nxt);
    }
    while(i<=n){
        ump[i]+=2;
        ++i;
    }
    map<int,int> ans;
    for(const auto& p:ump){
        if(p.first<=n)
            ans[p.second]++;
    }
    for(const auto& p:ans){
        cout<<p.first<<' '<<p.second<<'\n';
    }
    return 0;
}
```

---


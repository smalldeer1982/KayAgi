# [蓝桥杯 2025 国 C] 正方形构造

## 题目描述

小蓝正在二维坐标系中构造正方形，他手上有 $n$ 个正整数 $a_1, a_2, \cdots, a_n$，他想知道有多少个有序四元组 $(i, j, p, q)$ 满足 $i, j, p, q$ 互不相同，且四个点：$(0,0)$、$(-a_i, a_j)$、$(a_p, a_q)$、$(a_p - a_i, a_j + a_q)$ 能构成一个正方形？

## 说明/提示

**【样例说明】**

可用的数一共有 $10$ 个 $1$ 和 $5$ 个 $2$。

取 $a_i = 1, a_j = 2, a_p = 2, a_q = 1$ 时，有 $A_{10}^2 A_{5}^2 = 1800$ 种方案；

取 $a_i = 2, a_j = 1, a_p = 1, a_q = 2$ 时，有 $A_{10}^2 A_{5}^2 = 1800$ 种方案；

取 $a_i = 1, a_j = 1, a_p = 1, a_q = 1$ 时，有 $A_{10}^{4} = 5040$ 种方案；

取 $a_i = 2, a_j = 2, a_p = 2, a_q = 2$ 时，有 $A_{5}^{4} = 120$ 种方案；

总共有 $8760$ 种方案。

**【评测用例规模与约定】**

对于 $40\%$ 的评测用例，$1 \leq n \leq 100$；

对于所有评测用例，$1 \leq n \leq 1000000$，$1 \leq a_i \leq 1000$。

## 样例 #1

### 输入

```
15
1 1 1 1 2 2 1 2 2 2 1 1 1 1 1```

### 输出

```
8760```

# 题解

## 作者：peng201203 (赞：3)

先放题面。\
[原题面](https://www.luogu.com.cn/problem/P12883) 
我们按题目所说的将图画出来(因为 $a_i>0,a_j>0,a_p>0,a_q>0$，所以不会有其他情况了)。

![](https://cdn.luogu.com.cn/upload/image_hosting/4gtne14k.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

从图中可以看出：$a_i=a_q,a_i^2+a_j^2=a_q^2+a_p^2$ ，\
得：$a_i=a_q,a_j=a_p$。\
由于值域很小（$a_i<1000$)，所以考虑用下标计数。\
我们称 $sum_i$ 为 $i$ 在数组 $a$ 中出现的次数。\
分两种情况进行讨论\
1.$a_i=a_j$\
此时对答案的贡献为 $A_{sum_{a_i}}^4$。\
2.$a_i \ne a_j$\
此时对答案的贡献为 $A_{sum_{a_i}}^2\cdot A_{sum_{a_j}}^2$。\
按上述方法枚举累加即可。\
（PS:一定要用 long long！本题 $n$ 较大不建议使用 cin 和 cout）
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;
#define md(n) (n%mod) 
#define A4(n) md(md(md(n)*md(n-1))*md(md(n-2)*md(n-3)))
#define A2(n) md(md(n)*md(n-1))
long long n,t,b[1005],ans; 
int main(){
	scanf("%lld",&n);
	while(n--)scanf("%lld",&t),b[t]++;
	for(int i=1;i<=1000;i++)if(b[i]>=4)ans+=A4(b[i]),ans%=mod;
	for(int i=1;i<=1000;i++)for(int j=1;j<=1000;j++)if(i!=j&&b[i]>=2&&b[j]>=2)ans+=A2(b[i])*A2(b[j])%mod,ans%=mod;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：tuboshu666 (赞：1)

## 思路

首先，通过画图可以得出，若要能够组成正方形，必须满足以下条件：

$$
\begin{cases}
a_i = a_q &  \\
a_j = a_p & 
\end{cases}
$$

于是想到枚举每对 $a_i$ 和 $a_j$。由于 $n$ 达到了 $10^6$，不可能 $O(n^2)$ 直接进行枚举，考虑优化。注意到 $a_i$ 的范围很小，可以通过枚举桶来简化枚举。

实际枚举过程中，要分成两类来讨论。

记 $cnt_x$ 为 $x$ 出现的次数。

### 第一种：$a_i = a_j$

很显然，我们要在 $a_i$ 中有顺序地选出 $4$ 个，产生的答案为：

$$
A_{cnt_{a_i}}^4 \quad \text{if } cnt_{a_i} \geq 4
$$

### 第二种：$a_i \neq a_j$

考虑分别从 $a_i$ 和 $a_j$ 中有顺序地取出两个，产生的答案为：

$$
A_{cnt_{a_i}}^2 \times A_{cnt_{a_j}}^2 \quad \text{if }\begin{cases}
cnt_{a_i} \geq 2 &  \\
cnt_{a_j} \geq 2 & 
\end{cases}
$$

复杂度 $O(V^2)$，其中 $V = 1000$ 代表 $a_i$ 的值域。

## Code
```cpp
#include <iostream>
using namespace std;

const int MOD = 1e9 + 7;
const int N = 1010;
long long cnt[N]; //桶

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;
    for (int i = 1 ; i <= n ; i++)
    {
        int a;
        cin >> a;
        cnt[a]++;
    }

    long long sum = 0;
    for (int i = 1 ; i <= 1000 ; i++)
    {
        if (cnt[i] < 2) continue;
        for (int j = 1 ; j <= 1000 ; j++)
        {
            if (i != j)
            {
                if (cnt[j] < 2) continue;
                long long t1 = (cnt[i]*(cnt[i]-1)) % MOD;
                long long t2 = (cnt[j]*(cnt[j]-1)) % MOD;
                sum += (t1*t2) % MOD;
                sum %= MOD;
            }
            else
            {
                if (cnt[i] < 4) continue;
                long long t = (cnt[i]*(cnt[i]-1)) % MOD;
                t = (t*(cnt[i]-2)) % MOD;
                t = (t*(cnt[i]-3)) % MOD;
                sum += t;
                sum %= MOD;
            }
        }
    }

    cout << sum << endl;

    return 0;
}
```

---

## 作者：违规用户名1058825 (赞：0)

# 数学证明

首先我们来看怎么样的四元组才是可行的。

令 $A$ 是 $(0,0)$，$B$ 是 $(-a_i, a_j)$，$C$ 是 $(a_p, a_q)$，$D$ 是 $(a_p - a_i, a_j + a_q)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2ujfoybz.png)

组成的正方形如下图蓝色方框所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/aokiv5l0.png)

很显然这个正方形是正方形 $ABDC$。

$AC=BD$ 和 $AB=CD$ 同样也印证了这一点。

所以 $AB=AC$。

- - -

因为 $\angle AEC=\angle AFB=\angle BAC=90\degree$，  
那么 $\angle CAE=\angle ABF$。  
因为 $AB=AC$，  
所以 $\triangle ABF \cong \triangle CAE$。  
所以 $AE=BF$，$AF=CE$。  
**即 $a_i=a_p$ 且 $a_j=a_q$。**

# 编程

由于 $n=10^6$，$O(n^4)$ 枚举仅可得到 40 pts。

看到样例解释，想到计数。

在同一数值 $i$ 上对答案的贡献为 $A_i^4$，  
在两种数值 $i$ 和 $j$ 上对答案的贡献为 $A_i^2 A_j^2$。

```cpp
#include<bits/stdc++.h>
#define int long long //十年 OI 一场空，不开 long long 见祖宗
using namespace std;
const int TT=1000000007;
const int maxa=1005;
int n,cnt[maxa],mx,ans;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){int x;scanf("%lld",&x);cnt[x]++;mx=max(mx,x);}
	for(int i=1;i<=mx;i++)if(cnt[i]>=4)
		ans+=cnt[i]*(cnt[i]-1)%TT*(cnt[i]-2)%TT*(cnt[i]-3)%TT,ans%=TT;
	for(int i=1;i<=mx;i++)if(cnt[i]>=2)
	for(int j=1;j<=mx;j++)if(cnt[j]>=2&&i!=j)
		ans+=cnt[i]*(cnt[i]-1)%TT*cnt[j]%TT*(cnt[j]-1)%TT,ans%=TT;
	cout<<ans;
	return 0;
}

```
update on 7.9：更改大错误，感谢 [Tracy_Loght](https://www.luogu.com.cn/user/1061339) 的指出。

---

## 作者：copper_ingot (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12883)

其实样例说明已经提示做法了。

由题意可得：

$$\begin{cases} a_i^2+a_j^2=a_p^2+a_q^2 \\ \frac{a_j}{a_i}=\frac{a_p}{a_q}\end{cases}$$

解得 $a_i=a_q,a_j=a_p$。

我们预处理出每个数字的出现次数，记 $b_i$ 为 $i$ 的出现次数。

分两种情况考虑：

1. $a_i=a_j$ 时，此时答案为 $A_{b_{a_i}}^4$。
2. $a_i\neq a_j$ 时，此时答案为 $A_{b_{a_i}}^2\times A_{b_{a_j}}^2$。

注意如果数量不够就没有这种情况。

设 $k$ 为 $a_i$ 的值域，时间复杂度为 $O(n+k^2)$。对于情况二的每个 $i$ 可以将式子化为 $A_{b_{a_i}}^2\times ((\sum^k_{j=1} A_{b_{a_j}}^2)-A_{b_{a_i}}^2)$，提前算出 $\sum^k_{j=1} A_{b_{a_j}}^2$ 可以优化到 $O(n+k)$（虽然对于本题没什么用）。

最后别忘了取模。小心答案最后变成负的。

代码：

```cpp
//copper_ingot
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int, int>
pii mkp(int x, int y){pii p; p.first = x, p.second = y; return p;}
const int mod = 1e9 + 7;
int A(int x){
	if (x < 4) return 0;
	else return x * (x - 1) % mod * (x - 2) % mod * (x - 3) % mod;
}
int n, x, a[2001], ans, tmp;
signed main(){
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++){scanf("%lld", &x); a[x]++;}//此处a[i]为i的出现次数
	for (int i = 1; i <= 1000; i++) ans = (ans + A(a[i] % mod)) % mod;//情况1
	for (int i = 1; i <= 1000; i++){a[i] = a[i] * (a[i] - 1) % mod; tmp = (tmp + a[i]) % mod;}//预处理优化（可以不用）
	for (int i = 1; i <= 1000; i++) ans = (ans + a[i] * (tmp - a[i]) % mod) % mod;//情况2
	printf("%lld\n", (ans + mod) % mod);
	return 0;
}
```

---


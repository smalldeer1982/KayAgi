# [国家集训队] 单选错位

## 题目描述

gx 和 lc 去参加 noip 初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。

试卷上共有 $n$ 道单选题，第 $i$ 道单选题有 $a_i$ 个选项，这 $a_i$ 个选项编号是 $1,2,3,\ldots,a_i$，每个选项成为正确答案的概率都是相等的。

lc 采取的策略是每道题目随机写上 $1 \sim a_i$ 的某个数作为答案选项，他用不了多少时间就能期望做对 $\sum_{i=1}^n \frac{1}{a_i}$ 道题目。gx 则是认认真真地做完了这 $n$ 道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第 $i$ 道题目的答案抄到了答题纸上的第 $i+1$ 道题目的位置上，特别地，第 $n$ 道题目的答案抄到了第 $1$ 道题目的位置上。

现在 gx 已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被 lc 鄙视了。

我们假设 gx 没有做错任何题目，只是答案抄错位置了。


## 说明/提示

【样例说明】

| 正确答案   |   gx的答案    | 做对题目 | 出现概率 |
| :----------: | :----------: |:----------: | :----------: |
| $\{1,1,1\}$  |    $\{1,1,1\}$    |    $3$    |    $\frac16$ |
| $\{1,2,1\}$    |   $ \{1,1,2\}$   |    $1$    |    $\frac16$ |
|$\{1,3,1\}$    |   $ \{1,1,3\} $   |    $1$    |    $\frac16$ |
|$\{2,1,1\}$    |   $ \{1,2,1\} $   |    $1$    |    $\frac16$|
|$\{2,2,1\}$    |   $ \{1,2,2\}$    |    $1$    |    $\frac16$ |
|$\{2,3,1\}$    |    $\{1,2,3\} $   |    $0$    |    $\frac16$ |




$a = \{2,3,1\}$。

共有 $6$ 种情况，每种情况出现的概率是 $\frac{1}{6}$，gx 期望做对 $\frac{3+1+1+1+1+0}6 = \frac76$ 题。（相比之下，lc 随机就能期望做对 $\frac{11}6$ 题）



对于 $30\%$ 的数据，$n\leq 10, C\leq 10$。

对于 $80\%$ 的数据，$n\leq 10^4, C\leq 10$。

对于 $90\%$ 的数据，$n\leq 5\times 10^5, C\leq 10^8$。

对于 $100\%$ 的数据，$2\leq n\leq 10^7, 0\leq A,B,C \leq 10^8$，$1 \leq a_i \leq 10^8$。


## 样例 #1

### 输入

```
3 2 0 4 1```

### 输出

```
1.167
```

# 题解

## 作者：stoorz (赞：68)

[$Blog$](https://blog.csdn.net/SSL_ZYC/article/details/87979931)

分类讨论一下。

 - 当$a_i=a_{i+1}$，那么显然随机的答案在第$i+1$题也是随机的。期望为$\frac{1}{a_i}$，也就是$\frac{1}{a_{i+1}}$
 
 - 当$a_i>a_{i+1}$，只有$\frac{a_{i+1}}{a_i}$的概率答案在$1\sim a_{i+1}$中。所以期望为$\frac{a_{i+1}}{a_i}\times \frac{1}{a_{i+1}}=\frac{1}{a_i}$
 
 - 当$a_i<a_{i+1}$，由于随机的答案只在$1\sim a_i$中，而第$i+1$题正确答案有$\frac{a_i}{a_{i+1}}$的概率在$1\sim a_i$中，所以期望为$\frac{a_i}{a_{i+1}}\times \frac{1}{a_i}=\frac{1}{a_{i+1}}$


综上，答案就是$\sum^{n}_{i=1}\frac{1}{max(a_i,a_{i+1})}$

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

const int N=10000010;
int n,a[N];
double ans;

void init()  //题目给出的生成数据的方法
{
	int A,B,C;
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);
	for (int i=2;i<=n;i++)
		a[i] = ((long long)a[i-1] * A + B) % 100000001;
	for (int i=1;i<=n;i++)
		a[i] = a[i] % C + 1;
}

int main()
{
	init();
	a[n+1]=a[1];  //第1题写第n题的答案
	for (int i=1;i<=n;i++)
		ans+=1/(double)max(a[i],a[i+1]);
	printf("%0.3lf",ans);
	return 0; 
}
```


---

## 作者：stdlifg (赞：57)

fdf的思路很清晰，但是我认为还可以继续优化一下他的算法。

$$\frac{min(a[i],a[i-1])}{a[i]×a[i-1]}$$

我们发现，其实这个式子是可以约分的

$$\frac{min(a[i],a[i-1])}{a[i]×a[i-1]}$$
$$=\frac{1}{max(a[i],a[i-1])}$$

这个想一想就能出来。


当a[i]更小时，原式= $\frac{1}{a[i-1]}$
;当a[i-1]更小时，原式=$\frac{1}{a[i]}$


所以原式就可以如此化简。


另外，我在这里提供一种新的思路：


我们分类讨论一下。当a[i]<a[i-1]时：我们有$\frac{a[i]}{a[i-1]}$的几率选到a[i]范围内的数，在a[i]范围内的数中，我们又有$\frac{1}{a[i]}$的概率抽中正确答案，所以我们抽中正确答案的概率为$\frac{a[i]}{a[i-1]}$×$\frac{1}{a[i]}$=$\frac{1}{a[i-1]}$


另一种情况同理可得。


所以代码如下
```cpp
    ans+=1.0/(db)max(a[1],a[n]);
    for(int i=2; i<=n; ++i) 
        ans+=1.0/(db)max(a[i],a[i-1]);
    printf("%.3lf",ans);

```

---

## 作者：fdfdf (赞：30)

一道不错的期望题

我们考虑每个选项对于答案的贡献

假设第$i$个题目的选项数是$a[i]$,那么$gx$做对这道题目的概率就是$\frac{min(a[i],a[i-1])}{a[i]\times a[i-1]}$

对于$i==1$的情况特判一下，最后把每道题目做对的概率加起来即可
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#define pb push_back
#define RG register
#define il inline
using namespace std;
typedef long long ll;
typedef double dd;
const int N=10000000;
const int mod=100000001;
il ll read(){
    RG ll d=0,w=1;char ch=getchar();
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(ch>='0'&&ch<='9')d=d*10+ch-48,ch=getchar();
    return d*w;
}

int n,A,B,C;
vector<int>a;
dd ans;

int main()
{
    n=read();A=read();B=read();C=read();a.push_back(read());
    for(RG int i=1;i<n;i++)a.pb((1ll*a[i-1]*A+B)%mod);
    for(RG int i=0;i<n;i++)a[i]=a[i]%C+1;
    ans+=min(a[0],a[n-1])*1.0/a[0]/a[n-1];
    for(RG int i=0;i<n-1;i++)ans+=min(a[i],a[i+1])*1.0/a[i]/a[i+1];
    printf("%.3lf\n",ans);
    return 0;
}

```

---

## 作者：codecode (赞：17)

一道期望的基础题，大概可以用来熟悉概率与期望的定义。

------------

#### 题解：

先生成 $a_i$，时间复杂度 $\Theta(n)$。

**接下来，所有下标按模 $n$ 理解。**

由于各单选题的答案是独立的，故答案期望满足可加。

对于相邻两道题，gx 做对后一题当且仅当这两题答案一样。

做对后一题的概率是古典概率，其两个要素是

- 所有可能的结果：两道题可能选项的所有组合，共 $a_{i-1}\times a_i$ 种；

- 需要计算的结果：两道题的答案一样，共 $\min\{a_{i-1},a_i\}$ 种。

所以做对第 $i$ 题的概率是

$$p_i=\dfrac{\min\{a_{i-1},a_i\}}{a_{i-1}\times a_i}=\dfrac{1}{\max\{a_{i-1},a_i\}}$$

那么最后的答案即为

$$\operatorname{ans}=\sum_{i=1}^{n}p_i=\sum_{i=1}^n\dfrac{1}{\max\{a_{i-1},a_i\}}$$

时间复杂度 $\Theta(n)$。



------------

#### 代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e7+233;
const int mod=1e8+1;
int n,A,B,C,a[maxn];
double ans;
#undef int
int main(){
    cin>>n>>A>>B>>C>>a[1];
    for(int i=2;i<=n;i++)
        a[i]=(a[i-1]*A+B)%mod;
    for(int i=1;i<=n;i++)
        a[i]=a[i]%C+1;
    a[0]=a[n];
    for(int i=1;i<=n;i++)
        ans+=1.0/max(a[i-1],a[i]);
    printf("%.3f",ans);
    return 0;
}
```

---

## 作者：Plus_Ultra (赞：9)

在培训时老师讲到了一个奇妙的做法，没有这样做法的题解，就心血来潮的写了一篇

~~我只是思路的搬运工~~

求出每道题答对的概率，加起来就是期望。
- #### 1.若 ai-1  >  ai，答对的概率是 1/a[i].

- #### 2.若 ai-1  ≤  ai，答对的概率就是 1/a[i-1].

不多说了，上代码（~~我相信各位大佬也不需要代码~~）

```
#include<iostream>
#include<cstdio>

#define LL long long

using namespace std;

LL n,A,B,C,a[10000005];
double ans;

int main()
{
	cin>>n>>A>>B>>C>>a[1];
	
	for(int i=2;i<=n;i++)
		a[i]=((LL)a[i-1] * A + B) % 100000001;
		
	for (int i=1;i<=n;i++)  a[i] = a[i] % C + 1;//题目所要求
	
	ans=1.0/max(a[n],a[1]);
	for(int i=2;i<=n;i++)
	ans+=1.0/max(a[i],a[i-1]);//上面有解释
	
	printf("%.3lf\n",ans);
	
	return 0;
}
```


---

## 作者：P500 (赞：8)

简单明了！！

要求gx期望做对的题目个数,
只要把每道题目做对的概率加起来即可！

那么怎么算每道题目做对的概率呢？

举一个例子：
1、 当前一道题有4个选项,后一道题有6个选项时.
    答案正确的的概率为 1/6；
2、 当前一道题有4个选项,后一道题有6个选项时.
    答案正确的的概率也为 1/6；
所以第i题正确的概率为1/max(a[i-1],a[i]);

所以只要从左到右扫一遍 数组a[i] 即可！

代码如下：

```
#include <bits/stdc++.h>
using namespace std;
long long  n, A, B, C, a, a1, a2;
double ans=0.000;
long long max(long long x,long long y){
	return x>y?x:y;
}
int main(){
	cin>>n>>A>>B>>C>>a;
	a1=a;n--;
	while(n--){
		a2=(a1*A+B)%100000001;
		ans+= 1.0/max(a1%C+1,a2%C+1);
		a1=a2;
	}
	ans+=1.0/max(a%C+1,a2%C+1);
	printf("%.3lf",ans);
	return 0;
} 
```

---

## 作者：QuantAsk (赞：5)

# 正题

---------

## 题目大意
$n$道题，第$i$道$a_i$个选项，选择每个选项的概率第相等的。但是每个选择都会填到后一道题。求对的期望题数。

-------

## 解题思路
考虑若前面一道题有$x$个选项，后一道有$y$个选项，那么其实就是求一个在$1\sim x$随机选择，一个在$1\sim y$随机选择，求相等概率。然后总共会有$x*y$种可能，然后又$min(x,y)$种正确情况。那么这个正确概率就是
$$\frac{min(x,y)}{x*y}$$

--------------

## $code$
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,A,B,C,a[10000010];
double ans;
int main()
{
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);
	for(int i=2;i<=n;i++)
	  a[i]=((long long)a[i-1]*A+B)%100000001;
	for(int i=1;i<=n;i++)
	  a[i]=a[i]%C+1;
	a[n+1]=a[1];
	for(int i=1;i<=n;i++)
	  ans+=(double)min(a[i],a[i+1])/a[i]/a[i+1];
	printf("%.3lf",ans);
}
```

---

## 作者：info___tion (赞：3)

~~比较好奇这是什么时候的集训队题目~~

---
这一题应该说是比较简单的了，把每道题目分成两类讨论一下即可。

~~重点是这一题竟然没有卡精度~~

---
设$nxt$为“下一道”题目（如果当前题目是最后一道题目，那么$nxt=1$）

再设$ans_i,ans_{nxt}$分别为第$i$道题目和第$nxt$道题目的答案。

考虑第$i$道题目对答案的贡献（前方复读机警告）：

1. **如果$a_i \leqslant a_{nxt}$**
	
    假设$a_i=2,a_{nxt}=3$
    
    那么我们把第$i$道题目可能遇到的情况分一下：
    
    1. $ans_i=1$
    	
        易知$ans_{nxt}=1$的概率为$\dfrac{1}{3}$
        
        遇到这种情况的概率为$\dfrac{1}{2}$
        
    2. $ans_i=2$
    	
        易知$ans_{nxt}=2$的概率为$\dfrac{1}{3}$
        
        遇到这种情况的概率为$\dfrac{1}{2}$
    
    所以第$i$道题目对答案的贡献为$\dfrac{1}{2} \times (\dfrac{1}{3}+\dfrac{1}{3})=\dfrac{1}{3}$
    
   由上面的例子可以看出，**$ans_i$的每个取值，$ans_{nxt}$都有$\dfrac{1}{a_{nxt}}$的概率可以对应到。**
   
   **因为$ans_i$取啥都有可能和$ans_{nxt}$对应，所以贡献只和${a_{nxt}}$有关。**
   
   所以可以推导出：
   
   **这种情况下第$i$道题目对答案的贡献为$\dfrac{1}{a_{nxt}}$。**

2. **如果$a_i > a_{nxt}$**
	
    假设$a_i=4,a_{nxt}=2$
    
    那么我们把第$i$道题目可能遇到的情况分一下：
    
    1. $ans_i=1$
    	
        易知$ans_{nxt}=1$的概率为$\dfrac{1}{2}$
        
        遇到这种情况的概率为$\dfrac{1}{4}$
        
    2. $ans_i=2$
    	
        易知$ans_{nxt}=2$的概率为$\dfrac{1}{2}$
        
        遇到这种情况的概率为$\dfrac{1}{4}$
     
    3. $ans_i=3\ or\ ans_i=4$
    	
        因为$a_{nxt}<3$，所以$ans_{nxt}$不可能等于$ans_i$。答对概率为$0$。
        
        遇到这两种情况的概率分别为$\dfrac{1}{4}$
    
    所以第$i$道题目对答案的贡献为$\dfrac{1}{4} \times (\dfrac{1}{2}+\dfrac{1}{2}+0+0)=\dfrac{1}{4}$
    
    由上面的例子可以看出，**$ans_{nxt}$的每个取值，$ans_i$都有$\dfrac{1}{a_i}$的概率可以对应到。**
    
   **因为$ans_{nxt}$取啥都有可能和$ans_i$对应，所以贡献只和${a_i}$有关。**
   
   所以可以推导出：
   
   **这种情况下第$i$道题目对答案的贡献为$\dfrac{1}{a_{i}}$。**
   
---
上代码（可能写得不够简洁，但本人更倾向于思维的清晰）：

```cpp
#include<cstdio>
#include<iostream>
#include<iomanip>
using namespace std;

int a[10000001];

int main()
{
	int n,A,B,C;
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);
	
	for(int i=2;i<=n;i++) a[i]=( (long long)a[i-1]*A+B )%100000001;
	for(int i=1;i<=n;i++) a[i]=a[i]%C+1;
		
	long double ans=0.0;
	
	for(int i=1;i<=n;i++)
	{
		int nxt=i+1;
		if( nxt>n ) nxt=1;
		
		if( a[i]<=a[nxt] ) ans+=(long double)1.0/a[nxt];
		else ans+=(long double)1.0/a[i];
	}
	
	cout<<fixed<<setprecision(3)<<ans;
	
	return 0;
}

```


---

## 作者：Drifterming (赞：3)

```cpp
//Pro:P1297 [国家集训队]单选错位

//虽然是道被别人随便切的题 但是1A还是很开心的 2333
//我们现在知道每个题有多少个选项，且gx都做对了，a[i+1]变成了a[i] 
//那么，a[i+1]做对的概率就是它和a[i]相同的概率，为1/a[i+1]*min(1,a[i+1]/a[i])

//如何出来的上面那个式子，有两种思考方法(其实那个式子过了样例就交上看看对不对结果A了然后才考虑正确性的： 

//1、我们先考虑第i个数，
//   我们现在有min(1,a[i+1]/a[i])的概率让a[i]选一个属于a[i+1]的数，
//   定下第i个数后，考虑第i+1个数，我们有1/a[i+1]的概率使它与a[i]相同，贡献为1

//2、先考虑第i+1个数，我们共有a[i+1]种选择
//	 我们让它从1->a[i+1]定一个数，
//	 那么第i个数和它相等的概率为min(1,a[i+1]/a[i])/a[i+1]
//	 所以定下的那个数的贡献就是 1/a[i+1] * min(1,a[i+1]/a[i])/a[i+1] 
//   可以发现这东西与定下的数是谁无关，所以乘一个a[i+1]就行了 

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;

const int N=1e8+5;

int n,A,B,C;
int a[N];
double ans;

int main()
{
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);
	for(int i=2;i<=n;i++)
		a[i]=((long long)a[i-1]*A+B)%100000001;
	for(int i=1;i<=n;i++)
		a[i]=a[i]%C+1;
	for(int i=1;i<n;++i)
		ans+=1.0/(double)a[i+1]*min(1.0,1.0*a[i+1]/(double)a[i]);
	ans+=1.0/(double)a[1]*min(1.0,1.0*a[1]/(double)a[n]);
	printf("%.3lf",ans);
}
```

---

## 作者：UnyieldingTrilobite (赞：2)

好像没有人用和我同一个思路分析的······

大致来说一下。

首先，期望是线性的，所以相当于要算出的是每一题答对题数的期望（拗口）。

也就是求每一题答对的概率。

也就是求相邻两题$a_i$和$a_{i+!}$答案相同的概率。

第一类：若$a_i\le a_{i+1}$.

那么对于上一题$gx选择的任意一个答案，**有$a_{i+1}$**的概率正确（恰好这题也是它）。

所以概率是$\frac{1}{a_{i+1}}$

第二类：否则。

**同理。**

对于这一题$gx选择的任意一个答案，**有$a_{i}$**的概率正确（恰好上题也是它）。

所以概率为$\frac{1}{a_{i}}$.

综上概率就是$\frac{1}{\max{a_{i},a_{i+1}}}$.

代码（~~真的需要吗~~）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,A,B,C,a[10000009];
double ret;
int main(){
	scanf("%d%d%d%d%d", &n, &A, &B, &C, a + 1);
	for (int i = 2; i <= n; i++)
		a[i] = ((long long) a[i - 1] * A + B) % 100000001;
	for (int i = 1; i <= n; i++)
		a[i] = a[i] % C + 1;
	//以上：Ctrl+C+V的膜力。
	//主过程是后面一行（还有一行输出）。
	for(int i=1;i<=n;++i)ret+=1.0/max(a[i],a[i%n+1]);
	printf("%.3lf\n",ret);
    return 0;
}
```

---

## 作者：qwaszx (赞：1)

这是我见过最水的概率题之一

~~什么时候的国家集训队题~~

考虑你从$a_1$个选项中选了一个，要从$a_2$个选项中配对.

如果$a_1>a_2$，那么只有$a_2$个可以成为答案，并且每一个都有$\dfrac{1}{a_2}$的概率正确.这时的贡献是$\dfrac{a_2}{a_1}\cdot \dfrac{1}{a_2}=\dfrac{1}{a_1}$

如果$a_1\leq a_2$，那么这$a_1$个全都可以成为答案，并且每一个都有$\dfrac{1}{a_2}$的概率正确，这时的贡献是$\dfrac{a_1}{a_1}\cdot\dfrac{1}{a_2}=\dfrac{1}{a_2}$

综上，一对$(a_1,a_2)$对答案的贡献是$\dfrac{1}{\max(a_1,a_2)}$

枚举所有$a_i$计算$\dfrac{1}{\max(a_i,a_{i\mod n +1})}$即可.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=10000010;
int n,A,B,C,a[N];
double ans=0;
int main()
{
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);
	for(int i=2;i<=n;i++)a[i]=((long long)a[i-1]*A+B)%100000001;
	for(int i=1;i<=n;i++)a[i]=a[i]%C+1;
	for(int i=1;i<n;i++)ans=ans+1./max(a[i],a[i+1]);
	ans+=1./max(a[1],a[n]);
	printf("%.3lf",ans);
}
```

---

## 作者：nofind (赞：0)

题意:https://www.luogu.org/problem/P1297

转化下题意:

给你一个长为$n$的序列$b_i$,第$i$个数的取值范围为$[1,a_i]$,求$\sum\limits_{i=1}^{n}[b[i]=b[i+1]]$的概率,其中$b[n+1]=b[1]$

由于期望是线性的,我们依次考虑每个$b_i$和$b_{i+1}$相等的期望(其实就是概率),最后加起来即为答案

$b_i$和$b_{i+1}$相等的概率:

$\frac{\sum\limits_{i=1}^{a_i}\sum\limits_{j=1}^{a_{i+1}}[i==j]}{a_i*a_{i+1}}=\frac{min(a_i,a_{i+1})}{a_i*a_{i+1}}=\frac{1}{max(a_i,a_{i+1})}$

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000010;
int n,A,B,C;
int a[maxn];
double ans;
int main()
{
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);
	for(int i=2;i<=n;i++)a[i]=((long long)a[i-1]*A+B)%100000001;
	for(int i=1;i<=n;i++)a[i]=a[i]%C+1;
	a[n+1]=a[1];
	for(int i=1;i<=n;i++)ans+=1.0/max(a[i],a[i+1]);
	printf("%.3lf",ans);
	return 0;
}
```


---

## 作者：Porsche (赞：0)

#### ~~国家集训队？震惊！~~
### 大水题啊！！！~~我感觉我傻傻的女盆友都会~~
#### 每一个点对答案的正确率就是1/max(a[i],a[i+1])
#### 当时推出来这个的时候还以为自己想错了呢
#### 证明：
#### a[i]=a[i+1]时正确率就是1/a[i]
#### 当a[i]>a[i+1]时，当选择比a[i+1]大的时候肯定不可能对，只有选择≤a[i+1]时的正确率是1/a[i+1]，化式子得正确率为1/a[i]
#### 同理，当a[i]<a[i+1]时，正确率为1/a[i+1]
#### 整理得1/max(a[i],a[i+1])
#### 每个点有1/max(a[i],a[i+1])得正确率，则每个点对答案的贡献为1/max(a[i],a[i+1])，则答案为每个点的期望贡献和
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,A,B,C;
int a[10000001];
int main()
{
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);
	for(int i=2;i<=n;i++)
		a[i]=((long long)a[i-1]*A+B)%100000001;
	for(int i=1;i<=n;i++)a[i]=a[i]%C+1;
	double ans=1.0/max(a[1],a[n]);
	for(int i=1;i<n;i++)
		ans+=1.0/max(a[i],a[i+1]);
	cout<<fixed<<setprecision(3)<<ans<<endl;
	return 0;
}
```


---

## 作者：Always (赞：0)

### 分析: 说说 思路: i , i + 1 , i + 2 ...... 
                     --> --> --->
    是这样错位的 那我们考虑对于每个(i + 1!= n+1)位置的答案
他是由上一个位置(i) 填过来的 那现在这个位置(i+1)填对的概率是多少呢
举个例子：eg: a[i] = 2 a[i+1] = 3  
           ai      pi      ai+1     pi+1
            1     1/2       1       1/3
		    2     1/2       2       1/3  
			/      0        3       1/3
所以两个位置选项相同的概率P = (1/2)*(1/3)+(1/2)*(1/3)+0*(1/3) = 2/(2*3)
由数学归纳法可知: P = min(a[i],a[i+1])/(a[i]*a[i+1])   
取min值的原因就是 因为可能第i/(i+1)个题可能有多余的选项 导致另者没有这个选项 就比如eg中的
i没有3 但i+1中有 3 所以P的分子应是两者中较小的一者
我们再把上式化个简:  P = min(a[i],a[i+1])/(a[i]*a[i+1]) = 1/max(a[i],a[i+1])  
两者是等价的 但后者避免了乘法运算 更方便运算 最后我们枚举每一个i 和 i+1(i = n时 i+1 = 1)
算出对应的P 最后累加起来就可以了
代码应该就很简单了:
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n , A , B , C;
ll a[10000005];//记得开 long long  
double ans ;
int main(){
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a + 1);
    for(int i = 2 ; i <= n ; i ++)
    a[i] = ((ll)a[i - 1] * A + B) % 100000001;
    for(int i = 1 ; i <= n ; i ++)
    a[i] = a[i] % C + 1;//以上是读入 复制题目^_^ 
    for(int i = 1 ; i < n ; ++i){//开始算每个i+1的概率 (最后一个单独算) 
    	ans += (double)1/max(a[i] , a[i + 1]);//如分析中所说 
	}
	ans += (double)1/max(a[1] , a[n]);//特别处理下 
	printf("%.3lf\n",ans);//输出就可以了 
	return 0;
} 
```

---


# 数列

## 题目描述

有这样一种数列 $a_1, a_2, \cdots a_n$，其中 $a_{1}=0$，且对任意一项 $a_{i}$ 满足 $|a_{i}-a_{i+1}|=1$（$1\le i<n$）。设 $s=\sum_{i = 1}^n a_i = a_{1}+a_{2}+ \cdots +a_{n}$，表示前 $n$ 项之和。

现在给出数列长度 $n$ 与数列前 $n$ 项之和 $s$，要求：

输出满足条件的数列的总数对 $2^{64}$ 取模后的结果。

输出满足条件的 $100$ 个数列（如果不满 $100$ 个就全部输出）。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 100$，$-2^{63} \leq s \lt 2^{63}$。

#### 说明

spj provider：@[xiaolilsq](user/230249)。

## 样例 #1

### 输入

```
4 0
```

### 输出

```
2
0 -1 0 1
0 1 0 -1
```

# 题解

## 作者：Hiynyuan (赞：28)


~~这是一道彻底的数学题~~

------------
## 题目化简
有一个长度为 $n$ 的数列,第一个数为 $0$ ,每两位的差的绝对值为 $1$ ,和为 $s$ ,输出有多少种方案并输出 $100$ 种以内的所有方案.

## 主要思路
设每两位之间的差为 $x_i$( $1$ 或 $-1$ ) ,则:

$a_1=0$

$a_2=a_1+x_1=x_1$

$a_3=a_2+x_2=x_1+x_2$

$a_4=a_3+x_3=x_1+x_2+x_3$

以此类推,可得:

$a_i=x_1+x_2+...+x_\text{i-1}$

则:

$s=a_1+a_2+...+a_n=(n-1)x_1+(n-2)x_2+...+x_\text{n-1}$

所以，从这开始就分成了两种方法。

### 法一

模拟每一个 $x$ ,如果结果等于 $s$ 就得到一种方案.

### 法二

假设所有的 $x$ 都为 $1$ 可得:$s=\frac{n(n-1)}{2}$.

设为 $-1$ 的 $x$ 有$y$个,

继续化简可得: $s=\frac{n(n-1)}{2}-2y$.

求出 $y$ 之后,问题就变成了从 $n-1$ 到 $1$ 之中,和为 $y$ 的有多少种可能,每一种可能都对应着原题的一种方案.


---

## 作者：SunnyYuan (赞：5)

## 思路

题解区的题解都多多少少有些错误。

我想写一写我的做法，是将题解区各大佬的做法综合起来的做法。

---

首先，假如每一个数字都比前面的一个数字大 $1$，即数列为 $0, 1, 2, 3, 4, 5, \dots, n - 1$，那么这个数列的和为 $sum = \frac{n(n - 1)}{2}$，我们发现 $n \le 100$，那么 $sum \le 4950$，所以如果题目要求的 $s > sum$，那么一定无解，因为这个数列再大也大不过 $sum$，更不可能到达 $s$ 了。

反过来，如果一个数字比前面一个数字小 $1$，即数列为 $0, -1, -2, -3, -4, -5, \dots, -(n - 1)$，那么这个数列的和为 $sum = -\frac{n(n - 1)}{2}$，我们发现 $n \le 100$，那么 $sum \ge -4950$。


所以 $-2^{63} \le s \le 2^{63}$ 是吓你的，真正有用的 $-4950 \le s \le 4950$。

---

接下来，我们来探究一个位子 $u$ 上的数字变化对数组的和 $sum$ 的影响。

如果 $a_u = a_{u - 1} + 1$，现在改成 $a_{u} = a_{u - 1} - 1$，那么从 $u$ 开始的每一个数字都会减去 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/e7dtw6sp.png)

那么数组的和 $sum$ 就会减去 $2(n - u + 1)$。

---

那么，我们可以想到让每一个数字都等于前面一个数字 $+1$，那么和就是 $\frac{n(n - 1)}{2}$。

但是我们想让其变为题目要求的 $s$，那么要减去的数字就是 $k = \frac{n(n - 1)}{2} - s$。

那么我们只能将有些数字间的 $+1$，换成 $-1$ 才能达到减去 $k$ 的目的。

那么根据前面对数字间关系的讨论，我们知道，我们要凑出很多个 $i$，使这些 $i$ 对应的 $2(n - i + 1)$ 加起来等于 $k$ 就行了，即让所有的 $n - i + 1$ 加起来等于 $\frac{k}{2}$ 即可。

当然了，如果 $k$ 是奇数，那么一定无解。

---

我们考虑 DP，设 $f_{i, j}$ 表示已经凑到第 $i$ 个数字，和为 $j$ 的方案数。

开始时：$f_{1, 0} = 1$，

目标：$f_{n, \frac{k}{2}}$。

我们可以不选择第 $i$ 个数字，$f_{i, j} = f_{i - 1, j}$。

我们可以选择第 $i$ 个数字，即在原有基础上加上 $(n - i + 1)$，$f_{i, j} = f_{i - 1, j - (n - i + 1)}$。

---

然后爆搜 + 剪枝输出方案就可以了，因为最多输出 $100$ 项，所以不用担心会不会超时，当然不剪枝是过不了的。

（相信大家都会）

---

## 代码

注意取模！！！

因为要模的是 $2^{64}$ 所以使用 `unsigned long long` 可以自动溢出。（感谢 @Remilia1023 大佬给的建议）

```cpp
// Problem: P1329 数列
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1329
// Memory Limit: 128 MB
// Time Limit: 1000 ms


#include <bits/stdc++.h>

using namespace std;
using i64 = long long;
using ull = unsigned long long;

const int N = 1010, M = 5010;

ull f[N][M];

int n, k;
i64 s;
int cnt;
int m[N];

void dfs(int u, int sum) {
    if (sum > (k >> 1)) return;
	if (u > n) {
		if (sum == (k >> 1)) {
			cnt++;
			i64 tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp += m[i];
				cout << tmp << ' ';
			}
			cout << '\n';
		}
		if (cnt >= 100) {
			exit(0);
		}
		return;
	}
	m[u] = -1;
	dfs(u + 1, sum + (n - u + 1));
	m[u] = 1;
	dfs(u + 1, sum);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	cin >> n >> s;
	if (s > n * (n - 1) / 2) {
		cout << 0 << '\n';
		return 0;
	}
	k = n * (n - 1) / 2 - s;
	if (k & 1) {
	    cout << 0 << '\n';
	    return 0;
	}
	f[1][0] = 1;
	for (i64 i = 2; i <= n; i++) {
		i64 x = (n - i + 1);
		memcpy(f[i], f[i - 1], sizeof(f[i]));
		for (int j = x; j < M; j++) {
			f[i][j] = f[i][j] + f[i - 1][j - x];
		}
	}
	cout << f[n][k >> 1] << '\n';
	dfs(2, 0);
	return 0;
}
```

---

## 作者：Remilia1023 (赞：3)

## Foreword

当时刚入坑 OI 不久做这题时看到题解区一言难尽，于是现在决定写一发看起来正常点的 dp 题解。

## Solution

定义 $s_i$ 表示 $a$ 序列前 $i$ 项之和。


注意到每次 $a_i\pm 1$ 都是在做差分，会对第 $i$ 项之后的所有项造成影响，即 $s\pm (n-i)$，注意到 $n$ 的范围很小，接下来研究值域范围。

- 全取 $1$，$s_{i \max}=(n - 1) + (n - 2) + \cdots + (n - i)=\displaystyle\frac{(2 \times  n - i - 1) \times i}{2}$。

- 全取 $-1$ 则相反，$s_{i \min}=-s_{i \max}$。


$s_i$ 的范围在 $\pm\displaystyle\frac{(2 \times  n - i - 1) \times i}{2}$ 之间，因此可以直接将 $s_i$ 的值记入状态。

设 $dp_{i,j}$ 表示当前考虑到第 $i$ 项，$s_i=j$ 时的方案数。

注意数组下标不能为负，这里为了方便直接向右平移 $st=5000$ 位。

**边界：**

$dp_{1,st}=1$。


**转移：**

- 填 $1$，$dp_{i+1,j+n-i} = dp_{i,j}+dp_{i+1,j+n-i}$。

- 填 $-1$，$dp_{i+1,j-(n-i)}= dp_{i,j}+dp_{i+1,j-(n-i)}$。



输出方案可以用 dfs，但是直接搜会 TLE，可以从 $dp_{n,st+s}$ 开始倒过来搜，如果从 $dp_{i-1,j \pm (n - i + 1)}$ 能转移到 $dp_{i,j}$，则向其递归。

因为有取模，所以判断能否到达一个状态不能用 $dp$ 数组的值来判断，需另开数组。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 110, st = 5000;
using ull = unsigned long long;
using LL = long long;
bitset<N * N> exi[N];
ull dp[2][N * N];
LL n, s, cnt, a[N];
void dfs(int u, int sum)
{
  if (u == 1) {
    for (int i = 1; i <= n; i++) 
      cout << a[i] - a[1] << ' ';
    cout << endl;
    if (++cnt == 100) exit(0);
    return;
  }
  if (exi[u - 1][sum - (n - u + 1)]) a[u - 1] = a[u] - 1, dfs(u - 1, sum - (n - u + 1));
  if (exi[u - 1][sum + (n - u + 1)]) a[u - 1] = a[u] + 1, dfs(u - 1, sum + (n - u + 1));
}

int main()
{
  cin >> n >> s;
  exi[1][st] = dp[1][st] = 1;
  int o = 1;  // 滚动数组
  for (int i = 1; i < n; i++, o ^= 1) {
    int boun = (2 * n - i) * (i - 1) / 2;  // s(i-1) 的上下界
    for (int j = st - boun; j <= st + boun; j++) dp[o ^ 1][j] = 0;
    for (int j = st - boun; j <= st + boun; j++)
      if (exi[i][j]) {
        exi[i + 1][j + n - i] = exi[i + 1][j - n + i] = 1;
        dp[o ^ 1][j + n - i] += dp[o][j], 
        dp[o ^ 1][j - n + i] += dp[o][j];
      }
  }
  if (abs(s) <= n * (n - 1) / 2) {
    cout << dp[o][st + s] << endl;
    if (exi[n][st + s]) dfs(n, st + s);
  }
  else cout << 0 << endl;
  return 0;
}
```

## Afterword
因为是刚入坑不久就遇到的题，当时太菜了做不出来，所以对这题有比较深的执念，于是写了篇题解。









---

## 作者：KaMuaMua (赞：2)

~~虽然但是，这题有点水，可能是有教练辅助加成吧~~

其实把题目化简一下就好理解了，就是一个长度 $n$ 
 的数列，第一个数是 
 $0$  ，其中每两位的差绝对值是 
 $1$  ，和为 
 $s$  ，输出有多少种方案之后再输出 
 $100$  种以内的所有方案就行了


---

**附上代码**

```cpp
//QwQ
#include<bits/stdc++.h>
using namespace std;
long long dp[10086],b[10086],n,s,k,t,c,kl,ns;
void yee(long long p,long long s) {
	if(s<0) return;
	if(p==n){
		ns=0;
		if(s==0){
			c++;
			for(int i=1; i<=n; i++) {
				cout<<ns<<" ";
				ns+=b[i];
			}
			cout<<endl;
		}if(c>=100) exit(0);
		return;
	}
	else{
		b[p]=-1;
		yee(p+1,s-(n-p));

		b[p]=1;
		yee(p+1,s);
	}
}
int main(){

	cin>>n>>s;
	dp[0]=1;
	k=n*(n-1)/2;
	kl=k-s;
	t=kl/2;
	if(kl%2==1) {
		cout<<0;
		return 0;
	}
	for(int i=1; i<n; i++){
		for(int j=t; j>=i; j--)dp[j]+=dp[j-i];
	}
	cout<<dp[t]<<endl;
	yee(1,t)；//防题解dog
}
```
求过审QWQ

附：解题灵感与思路来自[@ni_ju_ge](https://www.luogu.com.cn/user/934048)  [@Hiynyuan](https://www.luogu.com.cn/user/290290)

---

## 作者：Walter_Fang (赞：2)

### 大致题意
有一个数列 $a$ 满足 $a_1=0$ 且 $a_{i+1}=a_i\pm1$，求合法的 $a$ 的数量并输出任意 $100$ 种可能，若不足 $100$ 种则全部输出。

### 思路分析

我们规定一个数列 $f$ 满足 $f_i=\pm1$，那么由 $a_1=0$ 且 $a_i=a_{i-1}+f_{i-1}$ 可知 $a_i=\Sigma_{k=1}^{i-1}f_k$，于是 $s=\Sigma a_i=(n-1)f_1+(n-2)f_2+\ldots+f_{n-1}$。

若 $f_i$ 全为 $1$，则 $s=\frac{n(n-1)}{2}$，而每将一个 $f_i$ 从 $1$ 改为 $-1$ 会使 $s$ 减少 $2$，因此若 $f_i$ 中有 $x$ 个 $-1$，则 $s=\frac{n(n-1)}{2}-2x$，于是 $x=\frac{n(n-1)-2s}{4}$。

于是问题变成两部分：

$1.$ 通过 $s$ 和 $n$ 求出 $x$，并通过适当的算法求出在 $1$ 到 $n-1$ 中，取若干个数使得其和为 $x$ 的方案数。当然这里我们可以用思路类似背包的 `dp` 算法解决。关键代码如下：
```
dp[0]=1;
for(i=1;i<n;i++)
	for(j=k;j>=i;j--)
    		dp[j]+=dp[j-i];
```
其中 `dp[k]` 就是题目中要求的数列总数 $t$。

$2.$ 求出了数列总数后，我们显然可以用暴搜与剪枝的算法来搜索可能的数列排列，由于需要求出的可能的排列最多只有 $100$ 中，所以暴搜显然不会超时。

### 一些细节

 - 题目中要求方案总数对 $2^{64}$ 取模，而注意到模数的特殊性（正好是 `unsigned long long` 的上限），于是只需将 `dp` 数组定义为 `unsigned long long` 类型，即可自动解决取模问题。
 
 - 当 $\frac{n(n-1)}{2}-s$ 为奇数时显然无解，于是这种情况只需特判并输出 $0$ 即可直接结束程序。
 
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll N=1e5+10;
ll n,s,k,i,j,t,a[N];
ull dp[N];
void dfs(ll x,ll s){
    if(s>k)return;
    if(x>n){
        if(s==k){
            ll i,sum=0;t++;sum=0;
            for(i=1;i<=n;i++)sum+=a[i],cout<<sum<<' ';
            cout<<'\n';
        }
        if(t>=100)exit(0);
        return;
    }
    a[x]=-1;dfs(x+1,s+(n-x+1));a[x]=1;dfs(x+1,s);
}
int main(){
    cin>>n>>s;k=(n*(n-1)-s*2)/4;
    if(k*2!=n*(n-1)/2-s)return cout<<0,0;
    dp[0]=1;
    for(i=1;i<n;i++)for(j=k;j>=i;j--)dp[j]+=dp[j-i];
    cout<<dp[k]<<'\n';
    dfs(2,0);
}
```

---

## 作者：WangSiHan_2011 (赞：1)

## 题解
**[题目传送门](https://www.luogu.com.cn/problem/P1329)**

本题是一道数学题。

设 $d_i=\pm1$，则可以观察到原序列为：

$$
0,0+d_1,0+d_1+d_2,0+d_1+d_2+d_3,\cdots,0+\sum_{i=1}^{n-1}d_i
$$

原题目说了 $s$ 为原序列的前 $n$ 项之和，那么将 $n$ 项带入：

$
s=0+(0+d_1)+(0+d_1+d_2)+(0+d_1+d_2+d_3)+\cdots+(0+\sum_{i=1}^{n-1}d_i)
$；

$s=(n-1)\times d_1+(n-2)\times d_2+\cdots+d_{n-1}$。

可以比较容易的发现，$s$ 是由 $\frac{n(n-1)}{2}$ 个 $\pm1$ 构成的，所以 $s$ 的奇偶性与 $\frac{n(n-1)}{2}$ 的奇偶性相同，可以这样判断无解（即输出 $0$ 的情况）。

接下来，我们设有 $x$ 个 $+1$，$\frac{n(n-1)}{2}-x$ 个 $-1$，则：

$x\cdot (+1)+(\frac{n(n-1)}{2}-x)\cdot (-1)=s$；

$x-\frac{n(n-1)}{2}+x=s$；

$2x=\frac{n(n-1)}{2}+s$；

$\therefore x=\frac{\frac{n(n-1)}{2}+s}{2}=\frac{2s+n(n-1)}{4}$

再将问题转换一下，$x$ 相当于在 $1,2,3,\cdots,n-1$ 中选一些数相加求和的结果。所以我们得到结论：**不同选择的方案数就是第一问**。

发现这个东西和背包十分相似，所以考虑用背包解。这样第一问就做完了。考虑到第二问只需要输出 100 组，可直接暴力搜索即可。对于取模 $2^{64}$，可使用 `unsigned long long` 来自燃溢出快速解决。

### 代码
```cpp
#include <bits/stdc++.h>

using namespace std;
const int MAXN = 102;
typedef unsigned long long ull;

ull x;
int cnt;
ull n,s;
ull sum;
ull f[MAXN * MAXN];

int a[MAXN * MAXN];
void Print()
{
    int s = 0;
    // for(int i = 1;i < n;i++)
    //     cout << a[i] << " ";
    // cout << ": ";
    for(int i = 1;i < n;i++)
    {
        cout << s << " ";
        s += a[i];
    }

    cout << s << endl;
}

void Dfs(int step,int ccc)
{
    if(ccc > x)
        return;
    if(step == n)
    {
        if(ccc != x)
            return;
        
        // for(int i = 1;i <= step - 1;i++)
        //     cout << a[i] << " ";
        // cout << endl;
        Print();

        cnt++;
        if(cnt == 100)
            exit(0);
        return;
    }

    a[step] = 1;
    Dfs(step + 1,ccc + (n - step));
    a[step] = -1;
    Dfs(step + 1,ccc);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);

    cin >> n >> s;
    sum = n * (n - 1) / 2;
    if((sum + s) % 2 != 0)
    {
        cout << 0 << endl;
        return 0;
    }

    x = (2 * s + n * (n - 1)) / 4; //1的个数

    f[0] = 1;
    for(int i = 1;i < n;i++)
	    for(int j = x;j >= i;j--)
    		f[j] += f[j - i];

    cout << f[x] << endl;

    Dfs(1,0);

	return 0;
}

```

---

## 作者：ELECTRODE_kaf (赞：0)

设 $dp_{i,j}$ 表示 $\sum_{k=1}^i a_k=j$ 的方案数。转移是平凡的，与背包问题类似。

暴力的做法：假设所有数都是前一个数加一，即构造 $a_i=i-1$，总和就是 $n(n-1)/2$。将 $a_i$ 减 $2$ 会使所有数总和减少 $2(n-i+1)$，所以目标就是用不同的 $(n-i+1)$ 凑出 $goal=s-n(n-1)/2$。这么做时间复杂度是 $O(2^n)$ 的，但可以用来输出方案（所以就出现了一道题正解中同时使用正解和暴力做法的情况）。

```cpp
const ll N = 2000, S = 6000;
const lll mod = (lll)(1) << 64;
lll dp[N][S];
ll n, s, goal, cnt, ch[N];

void dfs(ll p, ll cur) {
	if (cur > goal)
		return;
	elif(p > n) {
		if (cur == goal) {
			cnt++;
			ll sum = 0;

			rep(i, 1, n) {
				sum += ch[i];
				cout << sum << ' ';
			}

			endl;

			if (cnt >= 100)
				exit(0);
		}
	} else {
		ch[p] = -1;
		dfs(p + 1, cur + (n - p + 1));
		ch[p] = 1;
		dfs(p + 1, cur);
	}
}

int main() {
	cin >> n >> s;

	if (abs(s) > n * (n - 1) / 2 or (n * (n - 1) / 2 - s) % 2) {
		cout << 0;
		return 0;
	}

	goal = (n * (n - 1) / 2 - s) / 2;
	dp[1][0] = 1;

	rep(i, 2, n) {
		ll dis = n - i + 1;
		cpy(dp[i], dp[i - 1]);

		rep(j, dis, S - 1) (dp[i][j] += dp[i - 1][j - dis]) %= mod;
	}

	cout << (ull)(dp[n][goal]) << '\n';
	dfs(2, 0);
}
```

代码宏定义在我个人空间自取。

---

## 作者：__builtin_orz (赞：0)

标签只有数学，实际上应该是 DP+ 搜索（经典套装）

首先规定了 $a_1=0$。

其他的 $a_i=a_{i-1}+1$ 或 $a_i=a_{i-1}-1$。

考虑每一项加一或减一对该数列之和的贡献，不难发现，若 $a_i=a_{i-1}+1$，其贡献为 $+(n+1-i)$，反之为 $-(n+1-i)$。

于是我们可以进行 DP，设状态为 $f_{i,j,0/1}$，意义为 $a$ 的前 $i$ 项之和为 $j$ 且 $a_i$ 可由上一项加一（减一）得到的方案数。

最后再逆过来 dfs，若该方案存在，则继续向前搜索。

注意，方案只需要 100 条就够了，不要全部输出。

具体见代码。


```cpp
#include<cstdio>
#include<cstdlib>
#include<map>
#include<utility>
int n;
unsigned long long sum;
std::map<long long,unsigned long long>s[105][2];
int a[105],cnt;
void out(int n,int sum){
	if(n==1){
		int t=0;
		for(int i=1;i<=::n;i++){
			t+=a[i];
			printf("%d ",t);
		}
		printf("\n");
		cnt++;
		if(cnt==100)
			exit(0);
	}else{
		if(s[n][1].find(sum)!=s[n][1].end()){
			a[n]=1;
			out(n-1,sum-(::n+1-n));
		}
		if(s[n][0].find(sum)!=s[n][0].end()){
			a[n]=-1;
			out(n-1,sum+(::n+1-n));
		}
	}
}
int main(){
	scanf("%d%lld",&n,&sum);
	s[1][0][0]=1;
	for(int i=2;i<=n;i++){
		for(std::pair<long long,unsigned long long>p:s[i-1][0]){
			s[i][1][p.first+(n+1-i)]+=p.second;
			s[i][0][p.first-(n+1-i)]+=p.second;
		}
		for(std::pair<long long,unsigned long long>p:s[i-1][1]){
			s[i][1][p.first+(n+1-i)]+=p.second;
			s[i][0][p.first-(n+1-i)]+=p.second;
		}
	}
	printf("%llu\n",s[n][0][sum]+s[n][1][sum]);
	out(n,sum);
	return 0;
}
```

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1329)

## 做法
设 $b_i$ 为 $a_{i+1} - a_i$ 的值，考虑 $b_i$ 取 $1$ 或 $-1$ 对 $s$ 做出的贡献，不难发现，$b_i$ 作出的贡献为 $(n - i)\times b_i$。

关于方案总数应该怎么推出来，其他题解已经讲得很清楚了，这里不再赘述。

记数列的总和与 $s$ 的差为 $t$。

先将全部 $b_i$ 设为 $1$，然后每次尝试将一个 $b_i$ 取反，此时 $t$ 就减去了 $2(n - i)$，当 $t = 0$ 时，说明找到了一个符合要求的序列，将其输出即可。由于数据范围较小，所以不会 TLE。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long dp[10001],b[10001],n,s,k,t,cnt;
long long nows;
void baoli(long long p,long long s) {//s 表示当前的差
	if(s<0)return;
	if(p==n) {//n 项都确定了正负性时 
		nows=0;
		if(s==0) {//当 s = 0 时,就找到了符合要求的数列 
			cnt++;
			for(int i=1; i<=n; i++) {
				cout<<nows<<" ";
				nows+=b[i];
			}
			cout<<endl;
		}
		if(cnt>=100)exit(0);//已输出的方案数量大于等于 100 
		return;
	}
	else
	{
		b[p]=-1;
		baoli(p+1,s-(n-p));
        //由于 t 在赋值时已经除以了 2，所以这里就不用乘 2 了。
		b[p]=1;
		baoli(p+1,s);
	}
}
int main() {
	cin>>n>>s;
	dp[0]=1;
	k=n*(n-1)/2;
	t=(k-s)/2;
	if((k-s)%2==1) {//特判差值为一 
		cout<<0;
		return 0;
	}
	for(int i=1; i<n; i++) {
		for(int j=t; j>=i; j--)dp[j]+=dp[j-i];
	}
	cout<<dp[t]<<endl;
	baoli(1,t);
}
```
如果对该题解有任何问题都可以来找我。

---

## 作者：王江睿 (赞：0)

- 注意到，$n$ 模 $4$ 对数列长度之和的奇偶性的决定：  
  值为 $0, 1$ 时，和奇；否则和偶。

  因而当 $s$ 的奇偶性不满足该性质时（即 `((n & 2) >> 1 ^ s) & 1` 为真），数列总数为 $0$。

- 当 $|s|$ 的值大于 $\sum^{n-1}_{0}i$ 时（即 $\frac{(n-1)n}{2}$），不可能取得 $s$，数列总数为 $0$。

此时，不妨设数列严格上升。注意到，更改 $a_i - a_{i-1}$ 为 $-1$ 会使和值减少 $2*i$。原题目即形式化为  
使得 $2\sum^{n-1}_{1}\frac{i\pm{i}}2=\frac{n(n-1)}2-s$ 的方案数。

考虑记忆化的 DFS。额外地，在进行搜索的同时，适当地对 $\{..., k, k+1, ..., k+n\}$（即 `m = 0`）和 $\{..., k, k-1, ..., k-n\}$ （即 `m = bys[n]`）进行优化，并对不可能的 `m < 0` 和 `m > bys[n]` 进行剪枝即可。

附代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr long long bys[] = { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210, 231, 253, 276, 300, 325, 351, 378, 406, 435, 465, 496, 528, 561, 595, 630, 666, 703, 741, 780, 820, 861, 903, 946, 990, 1035, 1081, 1128, 1176, 1225, 1275, 1326, 1378, 1431, 1485, 1540, 1596, 1653, 1711, 1770, 1830, 1891, 1953, 2016, 2080, 2145, 2211, 2278, 2346, 2415, 2485, 2556, 2628, 2701, 2775, 2850, 2926, 3003, 3081, 3160, 3240, 3321, 3403, 3486, 3570, 3655, 3741, 3828, 3916, 4005, 4095, 4186, 4278, 4371, 4465, 4560, 4656, 4753, 4851, 4950 };
unsigned long long anx[10000][100];

inline unsigned long long ans(const long long m, const long long n)
{
    if (!m || m == bys[n])
        return 1;
    if (m < 0 || !n || m > bys[n])
        return 0;
    if (anx[m][n])
        return anx[m][n];
    else
        return anx[m][n] = ans(m - n, n - 1) + ans(m, n - 1);
}

long long t = 0;
inline void net(basic_string<long long> l, const long long m, const long long n)
{
    if (!m && !n) {
        partial_sum(l.begin(), l.end(), ostream_iterator<long long>(cout, " "));
        ++t, cout << '\n';
        return;
    }
    if (m < 0 || !n || m > bys[n] || t >= 100)
        return;
    l.push_back(-1), net(l, m - n, n - 1), l.pop_back();
    if (t >= 100)
        return;
    l.push_back(1), net(l, m, n - 1), l.pop_back();
    return;
}

signed main()
{
    long long n, m, s;
    ios::sync_with_stdio(false);
    cin >> n >> s;
    if ((((n & 2) >> 1 ^ s) & 1) || 2 * abs(s) > n * (n - 1)) {
        cout << 0;
        return 0;
    }
    m = (n * (n - 1) / 2 - s) / 2;
    cout << ans(m, n - 1) << '\n';
    net({ 0 }, m, n - 1);
    return 0;
}
```


---


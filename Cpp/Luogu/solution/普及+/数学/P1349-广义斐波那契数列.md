# 广义斐波那契数列

## 题目描述

广义的斐波那契数列是指形如 $a_n=p\times a_{n-1}+q\times a_{n-2}$ 的数列。

今给定数列的两系数 $p$ 和 $q$，以及数列的最前两项 $a_1$ 和 $ a_2$，另给出两个整数 $n$ 和 $m$，试求数列的第 $n$ 项 $a_n$ 对 $m$ 取模后的结果。



## 说明/提示

数列第 $10 $ 项是 $55$，$55 \bmod 7 = 6$。

【数据范围】  
对于 $100\%$ 的数据，$p,q,a_1,a_2 \in [0,2^{31}-1]$，$1\le n,m \le 2^{31}-1$。

---

$\text{upd 2023.8.23}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
1 1 1 1 10 7
```

### 输出

```
6```

# 题解

## 作者：奔波儿霸 (赞：63)

#### 解题思路

既然广义斐波那契，而且数据范围这么大，那么我们使用矩阵快速幂来进行求解。大家都知道斐波那契的初始矩阵如下

$$\begin{bmatrix}1&1\\1&0\end{bmatrix}$$

那么这道题我们怎么推矩阵呢？先确定目标矩阵如下

$$\begin{bmatrix} F_n & F_{n-1}\end{bmatrix}$$

然后推导过程如下：

$$F_n = p\times F_{n-1} + q\times F_{n-2}$$
$$\downarrow$$
$$\begin{bmatrix}F_{n-1}&F_{n-2}\end{bmatrix}\times\begin{bmatrix}p&1\\q&0\end{bmatrix}$$
$$\downarrow$$
$$\begin{bmatrix}(p\times F_{n-1}+q\times F_{n-2})&(F_{n-1}\times 1+F_{n-2}\times0)\end{bmatrix}$$
$$\downarrow$$
$$\begin{bmatrix} F_n & F_{n-1}\end{bmatrix}$$

#### 吐槽一下

你谷的公式渲染不咋地，我写的老长老长的公式自己默认换行，无法显示QAQ

建议你谷更新一下QWQ

#### 附上代码

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

typedef long long LL;
LL n, Mod, p, q, a1, a2, ans;
struct mat{
	LL m[4][4];
}Ans, base;
inline void init() {
	Ans.m[1][1] = a2, Ans.m[1][2] = a1;
	base.m[1][1] = p, base.m[2][1] = q, base.m[1][2] = 1;
}
inline mat mul(mat a, mat b) {
	mat res;
	memset(res.m, 0, sizeof(res.m));
	for(int i=1; i<=2; i++) {
		for(int j=1; j<=2; j++) {
			for(int k=1; k<=2; k++) {
				res.m[i][j] += (a.m[i][k] % Mod) * (b.m[k][j] % Mod);
				res.m[i][j] %= Mod;
			}
		}
	}
	return res;
}
inline void Qmat_pow(int p) {
	while (p) {
		if(p & 1) Ans = mul(Ans, base);
		base = mul(base, base);
		p >>= 1;
	}
}

int main() {
	scanf("%lld%lld%lld%lld%lld%lld", &p, &q, &a1, &a2, &n, &Mod);
	if(n == 1) {
		cout<<a1;
		return 0;
	}
	if(n == 2) {
		cout<<a2;
		return 0;
	}
	init();
	Qmat_pow(n-2);
	ans = Ans.m[1][1];
	ans %= Mod;
	printf("%lld", ans);
}
```

---

## 作者：ljc20020730 (赞：33)

由于n巨大，从头开始一一推算数列的每一项是不可能的。又由于m巨大，利用数列对m取余的余数循环性质也是不可能的。而本题采用的算法是由原本的递推公式（数列中某项与前两项的关系），推导得出数列中某项和与其遥遥相隔的连续两项之间的关系（比如a100与a1,a2之间的关系）。推导过程如下。

an=p\*an-1+q\*an-2

an=(p\*p+q)\*an-2+(p\*q)\*an-3

an=((p\*p+q)\*p+p\*q)\*an-3+((p\*p+q)\*q)\*an-4

。。。。。

an=ck\*an-k+dk\*an-k-1

（其中c、d数列的递推公式是cn=p\*cn-1+dn-1，dn=q\*cn-1，c1=p，d1=q）


```cpp
var i,j,k,n,m,p,q:longint;
    c,d,nextc,nextd:qword;
    a:array[1..30000]of qword;
begin
 readln(p,q,a[1],a[2],n,m);
 p:=p mod m;
 q:=q mod m;
 a[1]:=a[1] mod m;
 a[2]:=a[2] mod m;
 a[3]:=(p*a[2]+q*a[1])mod m;
 nextc:=p;
 nextd:=q;
 for i:=2 to 29999 do begin
  c:=(p*nextc+nextd)mod m;
  d:=(q*nextc) mod m;
  nextc:=c;
  nextd:=d;
 end;
 while n>30000 do begin
  dec(n,30000);
  a[1]:=(nextc*a[2]+nextd*a[1])mod m;
  a[2]:=(nextc*a[3]+nextd*a[2])mod m;
  a[3]:=(p*a[2]+q*a[1])mod m;
 end;
 for i:=4 to n do
  a[i]:=(p*a[i-1]+q*a[i-2])mod m;
 writeln(a[n]);
end.
```
如此，我们由最初两项向后推算时每步的步长可以非常大，忽略中间的许多项，从而节省时间。
首先根据给定的p、q以及上述递推公式计算出c29999和d29999除以m的余数。然后根据a1和a2，计算出第三项。根据前三项以及开始时求出的c，d数列中那两项的余数，计算出a30001和a30002除以m的余数。根据这两项的余数，又可计算出a30003除以m的余数。这样就由起初的连续三项一下子推出30000项后的连续三项。当n巨大时，用这样的方法不断向前推接近n，到与n的距离不足30000时再一项项推算过去，直到求出an除以m的余数为止。可以在给定的时间内完成。


---

## 作者：Jerry_Geek (赞：17)

看了一下题解，发现真的有方法递推...但是大佬的题解是Pascal的，那我就人肉翻译了一下，发个C++版的吧。

以下解释部分引用自 @ljc20020730 大佬（侵删）。


> 由于n巨大，从头开始一一推算数列的每一项是不可能的。又由于m巨大，利用数列对m取余的余数循环性质也是不可能的。而本题采用的算法是由原本的递推公式（数列中某项与前两项的关系），推导得出数列中某项和与其遥遥相隔的连续两项之间的关系（比如a100与a1,a2之间的关系）。推导过程如下：

```
an=p*an-1+q*an-2

an=(p*p+q)*an-2+(p*q)*an-3

an=((p*p+q)*p+p*q)*an-3+((p*p+q)*q)*an-4

......

an=ck*an-k+dk*an-k-1
```

（其中c、d数列的递推公式是cn=p*cn-1+dn-1，dn=q*cn-1，c1=p，d1=q）



直接上C++版的代码（我会尽量做到内容和原Pascal程序尽量一致）：

```cpp
#include <iostream>

using namespace std;

long long i,j,k,n,m,p,q;
unsigned long long c,d,nextc,nextd;
unsigned long long a[30005];

int main(void) {
	cin>>p>>q>>a[1]>>a[2]>>n>>m;
	p%=m;
	q%=m;
	a[1]%=m;
	a[2]%=m;
	a[3]=(p*a[2]+q*a[1])%m;
	nextc=p;
	nextd=q;
	for(i=2; i<=29999; i++) {
		c=(p*nextc+nextd)%m;
		d=(q*nextc)%m;
		nextc=c;
		nextd=d;
	}
	while(n>30000) {
		n-=30000;
		a[1]=(nextc*a[2]+nextd*a[1])%m;
		a[2]=(nextc*a[3]+nextd*a[2])%m;
		a[3]=(p*a[2]+q*a[1])%m;
	}
	for(i=4; i<=n; i++) {
		a[i]=(p*a[i-1]+q*a[i-2])%m;
	}
	cout<<a[n]<<endl;
	return 0;
}
```

---

## 作者：邓布利多6 (赞：8)

部分分做法

**普通斐波那契数列**：
```cpp
for(int i=3;i<=n;i++)
	f[i]=f[i-1]*p+f[i-2]*q;
cout<<f[n];
```
这就写好了，结果TLE了。


AC做法：

**矩阵乘法+快速幂**

不难得出：
```
        f（n）     1 1   f（n-1）
        f（n-1）=  1 0 * f（n-2）
```


所以定义结构体
```cpp

struct matrix
{
    long long num[3][3];
    matrix()
	{
		memset(num,0,sizeof num);
	}
};

```

加上矩阵乘法
```cpp
//放在结构体内部
matrix operator * (const matrix a) const
    {
        matrix b;
        for(int i=1;i<=2;i++)
            for(int j=1;j<=2;j++)
                for(int k=1;k<=2;k++)
                    b.num[i][j]=(b.num[i][j]+num[i][k]%mod*a.num[k][j])%mod;
        return b;
    }
```

最后是快速幂
```cpp
matrix pow(matrix a,long long int k)
{
    matrix b=a;
    k--;
    while(k)
    {
        if(k%2)b=b*a;
        a=a*a;
        k/=2;
    }
    return b;
}
```

完整代码如下
```cpp
#include<iostream>
#include<memory.h>
using namespace std;
int p,q,a1,a2;
long long int n,mod;
struct matrix
{
    long long num[3][3];
	matrix()
	{
		memset(num,0,sizeof num);
	}
    matrix operator * (const matrix a) const//运算符重载
    {
        matrix b;
        for(int i=1;i<=2;i++)
            for(int j=1;j<=2;j++)
                for(int k=1;k<=2;k++)
                    b.num[i][j]=(b.num[i][j]+num[i][k]%mod*a.num[k][j])%mod;
        return b;
    }
}a,b,c;
matrix pow(matrix a,long long int k)
{
    matrix b=a;
    k--;
    while(k)
    {
        if(k%2)b=b*a;
        a=a*a;
        k/=2;
    }
    return b;
}
int main()
{
	cin>>p>>q>>a1>>a2>>n>>mod;
	if(n==1)cout<<a1<<endl;
		else if(n==2)cout<<a2<<endl;
			else {
				//构造矩阵
				b.num[1][1]=a1; 
				b.num[1][2]=a2;
				a.num[2][1]=1;
				a.num[1][2]=q;
				a.num[2][2]=p;
				//矩阵乘法
				c=b*pow(a,n-1);
				cout<<c.num[1][1]<<endl;
			}
	return 0;
}
```

---

## 作者：半仙胡小桃 (赞：5)

[QAQ](https://www.luogu.org/problem/show?pid=1349)

类似于之前的斐波那契数列，不过这次是广义的。

F(n)=p\*F(n-1)+q\* F(n-2)

但是数据量太大，还是使用矩阵加速，看一下这次的递推矩阵

|F(n),F(n-1)|=|F(n-1),F(n-2)|\*|p,1|
　　　　　　　　　　　　|q,0|
套路跟前面的题一样，根据递推矩阵初始化就行了

```cpp
#include <cstdio>
#include <iostream>
#define ll long long
using namespace std;
ll ans[2][3];
ll x[3][3];
ll c[3][3];
ll m;
void ans_cf()
{
    for(int i=1;i<=1;i++)
     for(int j=1;j<=2;j++)
      c[i][j]=ans[i][j],ans[i][j]=0;
    for(int i=1;i<=1;i++)
     for(int j=1;j<=2;j++)
      for(int k=1;k<=2;k++)
       ans[i][j]=(ans[i][j]+(c[i][k]*x[k][j])%m)%m;
}
void x_cf()
{
    for(int i=1;i<=2;i++)
     for(int j=1;j<=2;j++)
      c[i][j]=x[i][j],x[i][j]=0;
    for(int i=1;i<=2;i++)
     for(int j=1;j<=2;j++)
      for(int k=1;k<=2;k++)
       x[i][j]=(x[i][j]+(c[i][k]*c[k][j])%m)%m;  
}
void fast_pow(int k)
{
    while(k)
    {
        if(k%2) ans_cf();
        x_cf();
        k/=2;
    }
}
int main()
{
    ll p,q,a1,a2,n;
    scanf("%lld%lld%lld%lld%lld%lld",&p,&q,&a1,&a2,&n,&m);
    if(n==1)
    {
        printf("%lld",a1%m);
        return 0;
    }
    if(n==2)
    {
        printf("%lld",a2%m);
        return 0;
    }
    x[1][1]=p,x[1][2]=1,x[2][1]=q;
    ans[1][1]=a2,ans[1][2]=a1;
    n-=2;
    fast_pow(n);
    printf("%lld",ans[1][1]%m);
}
```

---


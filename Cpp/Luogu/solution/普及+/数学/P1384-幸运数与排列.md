# 幸运数与排列

## 题目描述

一个数是幸运数当且仅当这个数仅由 $4$ 和 $7$ 构成，比如 $47$，$744$，$4747$。

询问在 $1$ 到 $n$ 的全排列中字典序第 $k$ 小的排列中，有多少个幸运数在排列中的位置编号也是幸运数。

## 说明/提示

#### 样例 1 解释

排列为 $1,2,3,4,6,7,5$。

#### 样例 2 解释

排列为：$2,1,3,4$。

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\le 8$。
- 对于 $60\%$ 的数据，保证 $n\le 100$。
- 对于 $100\%$ 的数据，保证 $1 \leq n,k\le 10^9$。

## 样例 #1

### 输入

```
7 4
```

### 输出

```
1```

## 样例 #2

### 输入

```
4 7
```

### 输出

```
1```

# 题解

## 作者：Harry_Hedwig (赞：11)

先看题。

# 0x00 思路
>一个数是**幸运数当且仅当**这个数**仅由 $4$ 和 $7$ 构成**，比如 $47$，$744$，$4747$。

>询问**在$1$ 到 $n$ 的全排列中字典序第 $k$ 小**的排列中，有多少个**幸运数**在**排列中的位置编号**也是**幸运数**。

我们注意到，在完成对幸运数记数的问题前，我们首先对这个数列有一个逆康托展开，所以这个问题可以分成两步走。

# 0x01 Step 1：逆康托展开
很明显，逆康托展开就是个板子，所以直接开开森森打代码就好了。

但是，逆康托展开需要知道 $n!$，而数据范围告诉我们：$1 \leq n,k\le 10^9$。

！这…… `unsigned long long` 都存不下啊……高精度？也感觉不对。

现在我们的思路卡住了，所以我们可以碰碰运气，看在 `unsigned long long` 范围下能逆康托展开多少个数（~~骗多少分~~）。


| $n$ | 阶乘结果 |
| :----------: | :----------: |
| $1$ | $1$ |
| $2$ | $2$ |
| $3$ | $6$ |
| $4$ | $24$ |
| $5$ | $120$ |
| $6$ | $720$ |
| $7$ | $5,040$ |
| $8$ | $40,320$ |
| $9$ | $362,880$ |
| $10$ | $3,628,800$ |
| $11$ | $39,916,800$ |
| $12$ | $479,001,600$ |
| $13$ | $6,227,020,800$ |

诶诶诶停停停，根据数据范围，$k$ 的取值范围是 $1\sim 10^9$，而 $13!=6,227,020,800>10^9$，所以我们可以发现 $k$ 只会影响到数列的后 $13$ 位，而前面的数都是按序排列！也就是说，我们只需要对最后 $13$ 位执行全排列操作。

而关于 $-1$，只需要判断 $n!<k$ 是否无解，为了~~偷懒~~不搞特殊，可以将 $n$ 和 $13$ 取最小值~~可以少写一个 `if` 语句~~。

至此，第一步顺利解决了。

# 0x02 Step 2：幸运数
既然我们已经发现除开最后 $13$ 个数，剩余的数按序排列的话，我们就可以把幸运数给预处理出来。那么这个时候，我们就肯定需要开始找规律了。

$$4,7,44,47,74,77,444,447,474,477,744,747,774,777,4444,4447,\dots$$

接着，你会发现只有一位的幸运数有 $2$ 个，两位数的有 $4$ 个，三位数的有 $8$ 个，…，$n$ 位的幸运数有 $2^n$ 个。

这个事情解释起来很简单。我们可以把 $n$ 位拆成前面一位和后 $n-1$ 位， $n-1$ 也可以这样操作，而每一位都有两种选择：$4$ 和 $7$，而每一位的选择都会影响到这个数，因此有 $2^n$ 种可能，之后可进行预处理。

由于整个数列只有后 $13$ 位会变化，所以前面的**不会影响到第 $k(1\le k \le n)$ 位的最大幸运数的数字总数**可以直接相加。

## 注意！
当 $10\le n< 20$ 时， 后 $13$ 位中包括了个位数的幸运数，那么此时我们不可以再直接让答案为 $2$，而需要一个个判断（毕竟就 $2$ 个幸运数）。

当 $17\le n$ 时，幸运数 $4$ 不会受影响。

当 $20\le n$ 时，幸运数 $7$ 不会受影响，可以分别判断。

**但是千万不要忘了 $n>20$ 的情况已经加过了，千万不要重加！**

---

关于和 $n$ 位数（有 $dig$ 位）相同但小于 $n-13$ 的幸运数，可以直接暴力查找，反正数量最多也就 $2^9$。从 $44\dots4$（$dig$ 个 $4$）开始。可以根据幸运数特点，只有 $4$ 和 $7$，可以推断出：找到幸运数中的第一个 $4$，将其变成 $7$，在这一位之前的 $7$（即从个位开始连续的所有 $7$) 全部改成 $4$ 。

特别地，$77\dots7$（$dig$ 个 $7$）为 $dig$ 位的最大幸运数。

最后还有被全排列过的 $13$ 位（至多）需要判断。前面的全排列已经在 Step 1 中得到了，直接判断位置和数值是否均为幸运数即可。

# Code
```c
#include<bits/stdc++.h>
using namespace std;
long long val_fac[20],val_pow[10];
long long step_1[20];
void decontor(int n,int p)//逆康托展开
{
	vector<int>mus,ans;
	int now=p-1,i;
	for(i=1;i<=n;i++)
		mus.push_back(i);
	for(i=n;i>=1;i--)
	{
		int l=now/val_fac[i-1];
		now=now%val_fac[i-1];
		ans.push_back(mus[l]);
		mus.erase(mus.begin()+l);
	}
	for(i=0;i<n;i++)
		step_1[i+1]=ans[i];
}
int Digit(int num)//找位数
{
	int sum=0;
	while(num)
	{
		num/=10;
		sum++;
	}
	return sum;
}
void change(long long &n)//改成下一个幸运数
{
	long long ans=n;
	int sum=0;
	while(ans%10==7)//即上文说的找法
	{
		ans/=10;
		n-=3*(int)pow(10,sum);
		sum++;
	}
	n+=3*(int)pow(10,sum);
}
bool check(int val)//检查是否满足幸运数的条件
{
	while(val)
	{
		if(val%10!=4&&val%10!=7)
			return 0;
		val/=10;
	}
	return 1;
}
int main()
{
	int p,i,n;
	long long ans=0;
	scanf("%d %d",&n,&p);
	val_fac[0]=1;
	val_pow[0]=1;
	for(i=1;i<=15;i++)//逆康托展开前置
		val_fac[i]=val_fac[i-1]*i;
	int dig=Digit(n);//求位数
	for(i=1;i<=dig;i++)//预处理
		val_pow[i]=val_pow[i-1]*2;
	if(p>val_fac[min(n,13)])//判断-1
	{
		printf("-1");
		return 0;
	}
	decontor(min(n,13)/*最多13位,否则就不行了*/,p);
	if(n>13)
	{
		if(n>19)//不会影响到任何低于dig位的幸运数
			for(i=1;i<dig;i++)
				ans+=val_pow[i];
		if(n>16&&n<20)//会影响到7
			ans++;
		for(i=1;i<=13;i++)//在逆康托展开中使用的是1~13，需要加回来
			step_1[i]=step_1[i]+n-13;
		long long now=0,biggest=0;
		for(i=1;i<=dig;i++)//找到dig位的幸运数的最小值和最大值
			now*=10,now+=4,biggest*=10,biggest+=7;
		if(n-13>=biggest)//不会影响到dig位的所有幸运数
			ans+=val_pow[dig],now=n-12/*防止进入循环*/;
		while(now<=n-13&&now!=biggest)
		{
			ans++;
			change(now);
		}
		if(now<=n-13&&now==biggest)
			ans++;
		for(i=1;i<=13;i++)//暴力查找
		{
			if(check(n+i-13)&&check(step_1[i]))
				ans++;
		}
	}
	else
	{
		if(step_1[4]==4||step_1[4]==7)
			ans++;
		if(step_1[7]==4||step_1[7]==7)
			ans++;
	}
	printf("%lld",ans);
	return 0;
}

```

~~话说康托展开太容易打错了QaQ~~

---

## 作者：Hopearceus (赞：9)

### 救救孩子吧！

两篇题解质量都超级高，以至于我这个蒟蒻啥也看不懂。

在经历了一天~~腥风血雨~~后，我决定将我的理解补充一下

直接上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long n,k,tot,tot2,temp=20,temp2,cnt,ans;
long long a[2100000],b[210],c[210],jc[210],re[210];
void dfs(long long now,long long ans){
	ans+=4*now;//找到所有在1~n范围内的幸运数 
	if(ans>n) return;
	a[++tot]=ans;
	dfs(now*10,ans);
	ans+=3*now;
	if(ans>n) return;
	a[++tot]=ans;
	dfs(now*10,ans);
}
bool isluck(int x){
	for(int i=tot;i>0;i--)  //判断是否是幸运数 
	  if(x==a[i]) return true;
	  else if(x>a[i]) break;
	 return false; 
}
void work(){  //主体部分，首先处理出这个数或其后12位 
	long long temp3=k;
	while(temp){
		int xxx=temp3/jc[temp]+1;
		re[++cnt]=c[xxx];
		for(int i=xxx;i<=temp;i++)
		  c[i]=c[i+1];
		temp3%=jc[temp];
		temp--;
	}
	re[++cnt]=c[1];//寻找幸运数位置上也是幸运数的个数 
	for(int i=1;i<=tot2;i++)
	  if(isluck(re[b[i]-temp2+1])) //因为一共有n位，而re中只存了后temp位，所以位置是幸运数的有 b[i]-temp2+1，只要判断这些位置上面的是不是幸运数就好了 
	    ans++;
}
int main()
{
	freopen("permutation.in","r",stdin);
	freopen("permutation.out","w",stdout);
	scanf("%lld%lld",&n,&k);
	jc[0]=jc[1]=1;
	for(int i=2;i<=20;i++)
	  jc[i]=jc[i-1]*i;//预处理阶乘 
	if(n<=12&&jc[n]<k){//如果我们发现这n个数全排列的方案数都不够k种，输出-1 
		printf("-1\n");
		return 0;
	}
	k--;//逆康拓展开时，k应该为有多少个比它小的，所以要-- 
	dfs(1,0);
	if(tot==0){
		printf("0\n");
		return 0;
	}
	sort(a+1,a+tot+1);//排一下序，方便find 
	while(temp>0){
		if(jc[temp]<=k) break;//我们只需要转变后temp位即可获得第k小 
		temp--;
	}
	temp2=n-temp;//from temp2 to n 即后temp位都是什么数 
	for(int i=tot;a[i]>=temp2;i--)//我们将大于temp2的都加进b里，这样的数在最末尾 
	  b[++tot2]=a[i];
	for(int i=temp2;i<=n;i++)
	  c[i-temp2+1]=i;//将temp2~n的数存进c，方便逆康托展开 
	ans=tot-tot2;//难点，首先我们要理解，我们只动后temp位，前面是从小到大排序的，即如果这个数是幸运数，它所在的位置也是幸运数 
	work();
	if(ans==0)
	  printf("-1\n");
	else printf("%lld\n",ans);
	return 0;
}
```

感谢@单曦增 的思路！！！Orz

---

## 作者：Ervin (赞：5)

# 非常玄学的一道题目

   开始的时候和机房里一位~~蒟蒻~~神犇讨论这道题目，就过乱搞乱搞发现了一个规律，还以为自己创造了一个定理，激动了好一会。
   
   结果了解了一下才知道这个规律就是逆康托展开，看了一下定义，和旁边神犇讲的一模一样，~~不过那也非常厉害了....~~
   
   ## 康托展开：
   - 给你一个式子：$X=a_n*(n-1)!+a_{n-1}*(n-2)!+...+a_i*(i-1)!+...+a_1*0! $其中, $a_i$为整数，并且$0<=a_i<=i,0<=i <n$, 表示当前未出现的的元素中排第几个，这就是康 托展开。例如有3个数（1，2，3），则其排列组合及其相应的康托展开值如下：
   
   
  |排列组合	  | 名次 | 康托展开 |
| :----------: | :----------: | :----------: |
| 123 | 1 | 0 \*2! + 0 \* 1! + 0 \* 0! |
| 132 | 2 | 0 \* 2! + 1 \* 1! + 0 \* 0! |
| 213 | 3 | 1 \* 2! + 0 \* 1! + 0 \* 0! |
| 231 | 4 | 1 \* 2! + 1 \* 1! + 0 \* 0! |
| 312 | 5 | 2 \* 2! + 0 \* 1! + 0 \* 0! |
| 321 | 6 | 2 \* 2! + 1 \* 1! + 0 \* 0! |

再举一个例子：在$(1,2,3,4,5)5$个数的排列组合中，计算$34152$的康托展开值。

- 首位是$3$，则小于$3$的数有两个，为$1$,$2$，$a_5=2$,则首位小于$3$的所有排列组合为$a_0*(5-1)!$。
- 第二位是$4$，则小于$4$的数有两个,为$1$和$2$,注意这里的$3$并不能算，因为$3$已经在第一位,所以其实计算的是在第二位之后小于$4$的个数。因此$a_4=2$
- 以此类推，根据公式：$X=2*4!+2*3!+0*2!+1*1!+0*0!=2*24+2*6+1=61$所以比$34152$小的组合有$61$个,即$34152$是排第$62$。

## 逆康托展开：

- 其实逆康托展开就是按照上边的步骤,逆过来,根据排名,求原序列,~~感觉就不用再多讲了~~

## 数位$DP$：

- 顾名思义,数位$DP$就是一个数,一位一位的$DP$,也是比较简单,如果不会的话，可以看这个,[点我点我！！](https://blog.csdn.net/wust_zzwh/article/details/52100392)还是讲的比较详细的。


------------ 

------------


## 好了,开始说这道题目吧

- 看着这个数据非常大$10^9$,好像怎么都过不了,而且复杂度应该是$O(n!)$,所以不太好像,其实可以模拟一下试试,在模拟的时候,可以发现,前边很多数都是不变的,只有后面的几位在变化,而且只需要$x!=k$中$O(x)$的时间复杂度了，发现$13!$已经到了$6*10^9$,所以只需要看后面$13$位，就可以完美的解决问题了。


------------

------------

### 上代码(~~感觉已经讲的够清楚了,~~代码里就不多加注释了)：
~~~cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
int jc[14]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800};
int dp[11],a[11],n,k,x;
inline int dfs(int pos,int lim,int zero)
{
	if(pos==-1)
		return 1;
	if(!lim&&!zero&&dp[pos]!=-1)
		return dp[pos];
	int up=lim?a[pos]:9,num=0;
	for(int i=0;i<=up;i++)
	{
		if(i!=4&&i!=7&&!(zero&&i==0))
			continue;
		num+=dfs(pos-1,lim&&i==up,zero&&i==0);
	}
	if(!zero&&!lim)
		dp[pos]=num;
	return num;
}
bool ok(int x)
{
	bool flag=1;
	while(x)
	{
		flag&=((x%10==4)||(x%10==7));
		x/=10;
	}
	return flag;
}
int solve1(int x)
{
	int k=0;
	while(x)
	{
		a[k++]=x%10;
		x/=10;
	}
	return dfs(k-1,1,1);
}
int solve2(int n,int x,int k)
{
	vector<int>v,a;
	for(int i=n-x+1;i<=n;i++)
		v.push_back(i);
	for(int i=x;i>=1;i--)
	{
		int r=k%jc[i-1];
		int t=k/jc[i-1];
		k=r;
		sort(v.begin(),v.end());
		a.push_back(v[t]);
		v.erase(v.begin()+t);
	}
	int j=n-x+1,res=0;
	for(int i:a)
	{
		if(ok(j)&&ok(i))
			res++;
		j++;
	}
	return res;
}
int main()
{
	scanf("%d%d",&n,&k);
	if(n<=12&&1LL*k>jc[n])
		return 0*printf("-1\n");
	memset(dp,-1,sizeof(dp));
	while(k>jc[x])
		x++;
	int ans=solve1(n-x)-1;
	ans+=solve2(n,x,k-1);
	printf("%d",ans);
	return 0;
}

~~~

---

## 作者：单曦增 (赞：3)

## 全排列？

## 幸运数？

一眼看上去完全没有思路啊。。

没有思路？那就乱搞一下吧。

----------------

### 一、幸运数

这个还是比较简单的，只需要暴搜一下，因为n不是很大，幸运数也应该不是很多，我用的是dfs，先枚举最低位，在往上增加，每次在最高位加4或7。这样就完美的解决问题了。

----------

### 二、全排列

这一定是本题最大的一个问题，经过乱搞之后本蒟蒻终于发现了规律。

其实这道题还是不太难想的，其突破点就在n和k的范围上，因为$k<10^{10},$而$13!>k$，经过观察后我们就能发现，在变化的过程中，只有后13位会变化，所以$n=10^{10}$的问题实际上就可以转化成$n<=13$的问题。

再来考虑一下怎样求第k小的全排列，前30%的$n<=8$的数据意味着暴力求解，然而$n<=13$时就不能暴搜了，所以一定会有规律。

又一波乱搞后，本蒟蒻又发现了规律：

例如，求出1到7的全排列中的第10小的排列。

首先，因为要求的是第10小，所以只有后四位会变化。

先考虑第四位，第四位为4的排列一共有6种，为5的也有6种，所以第四位就是5。

求第五位时，因为第四位为4一共有6种，所以求的是第四位为5的排列中的第4个，第五位为4的一共有2种，第五位为6的一共有2种，所以第五位为6。

以此类推，可求出1到7的全排列中的第10小的排列为1 2 3 5 6 7 4，再实验了几组数据，~~似乎挺靠谱~~。

具体实现请参考代码。

---------------------

### 吐槽：

代码好不容易写出来了，然后呢？

AC、WA、RE、WA、RE、WA、RE。。。

五颜六色，漏洞百出啊。

改正了各种弱智性的错误后，还是有一个点RE，怎么回事？

开大数组，改成 long long，还是不对。。

最终，我决定再读一遍题：

**如果不存在第k小的排列，则输出-1。**

好吧，我真的服了，这么套路吗？

这道题的代码还是建议大家打一下的，写的时候可以发现很多问题。。。

----------------

下面就是大家最期待的代码环节了，

代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,k,tot,tot2,temp=20,temp2,cnt,ans;
long long a[2100000],b[210],c[210],jc[210],re[210];
void dfs(long long now,long long ans)
{//寻找所有lucky num
	ans+=4*now;
	if(ans>n)
		return;
	a[++tot]=ans;
	dfs(now*10,ans);
	ans+=3*now;
	if(ans>n)
		return;
	a[++tot]=ans;
	dfs(now*10,ans);
}
bool isluck(int x)//用来判断x是不是lucky num
{
	for(int i=tot;i>=1;i--)
	if(a[i]==x)
		return true;
	else if(a[i]<x)
		break;
	return false;
}
void work()
{//主要过程
	long long temp3=k;
	while(temp>0)//确定从后向前第temp位的数字
	{
		int sxz=temp3/jc[temp]+1;
		re[++cnt]=c[sxz];
		for(int i=sxz;i<=temp;i++)
			c[i]=c[i+1];
		temp3%=jc[temp];
		temp--;
	}
	re[++cnt]=c[1];
	for(int i=1;i<=tot2;i++)//寻找排列中lucky num下表上
	if(isluck(re[b[i]-temp2+1]))//的数也是lucky num的个数
		ans++;
}
int main()
{
//	freopen("2.in","r",stdin);
	jc[0]=jc[1]=1;
	for(int i=2;i<=20;i++)
		jc[i]=jc[i-1]*i;//求"i!"
	scanf("%lld%lld",&n,&k);
	if(n<12&&jc[n]<k)//这个一定不要漏了！！！
	{
		printf("-1\n");
		return 0;
	}
	k--;//这一句非常重要，这一句非常重要，
    //这一句非常重要，重要的事情一定要说3遍
	dfs(1,0);
	if(tot==0)
	{
		printf("-1\n");
		return 0;
	}
	sort(a+1,a+tot+1);
	while(temp>=1)
	{
		if(jc[temp]<=k)
			break;
		temp--;
	}
	temp2=n-temp;
	for(int i=tot;a[i]>=temp2;i--)
		b[++tot2]=a[i];
	if(tot2==0||temp==0)
	{
		printf("%lld\n",tot);
		return 0;
	}
	ans=tot-tot2;
	for(int i=temp2;i<=n;i++)
		c[i-temp2+1]=i;
	work();
	if(ans==0)
		printf("-1\n");
	else
		printf("%lld\n",ans);
	return 0;
}
```

~~是不是很简单~~

---

## 作者：huangruiheng0217 (赞：1)

难得在主题库找到一道能交题解的绿题$\dots\dots$

#### 题目描述

定义幸运数是仅由 $4$ 和 $7$ 构成的正整数。

求在 $1$ 到 $n$ 的第 $k$ 个全排列中，有多少个数满足：

- 自身是幸运数。

- 在排列中的编号也是幸运数。

如果排列不存在输出 $-1$。

---

举个例子，$1$ 到 $7$ 的第 $24$ 个全排列是 $1,2,3,7,6,5,4$。

其中的 $7$ 是幸运数，且位于排列中的第 $4$ 个位置。

$4$ 也是幸运数，且位于排列中的第 $7$ 个位置。

所以答案为 $2$。

---

#### 分析

首先观察数据范围，$1 \le n \le 10^{9}$。

显然当 $n=10^{9}$ 的时候，理论上 $k$ 可以达到 $n!$，高精也会炸。

题目说 $1 \le k \le 10^{9}$，解不等式 $n! \le 10^{9}$ 可以发现 $n <  13$。

所以说 $k$ 最多只会对排列的最后 $14$ 位产生影响。（以防万一多存一位）

那么题目可以分为两部分：先求排名 $k$ 对应的全排列后 $14$ 位（逆康托展开），再求其中满足要求数的个数。

---

#### 康托展开和逆康托展开

先看一眼康托展开，给排列求式子。详见 [P5367](https://www.luogu.com.cn/problem/P5367)，直接给结论。

$$ans=1+\sum_{i=1}^nA[i]\times(n-i)!$$

其中 $A[i]$ 表示第 $i$ 个元素，$ans$ 表示排名。

接下来是逆康托展开，就是给排名求排列。举个例子：求 $1$ 到 $5$ 的第 $100$ 个全排列。

首先 $100-1=99$，$99 \div 4! = 4 \dots\dots 3$。有 $4$ 个数比它小的数是 $5$，所以第一位是 $5$。

用 $3$ 去除 $3!$ 得到 $0$ 余 $3$。有 $0$ 个数比它小的数是 $1$，所以第二位是 $1$。

用 $3$ 去除 $2!$ 得到 $1$ 余 $1$。有 $1$ 个数比它小的数是 $2$，但是由于比 $2$ 小的 $1$ 已经出现过了，不能算在里面，所以第三位是 $3$。

用 $1$ 去除 $1!$ 得到 $1$ 余 $0$。有 $1$ 个数比它小的数是 $2$，但是比 $2$ 小的 $1$ 已经出现过了，所以 $2+1=3$，$3$ 也出现过了，所以第四位应该是 $4$。

最后一个数是 $2$。

所以这个排列是 $51342$。

总结一下：每次用当前排列编号除以阶乘，得到的商就是比自身小的数字个数，去重统计后排列编号改为除以阶乘之后的余数。重复上述过程直到求出排列。

在本题中求出后 $14$ 位逆康托展开即可。

---

#### 答案统计

难度不大。首先可以预处理出比 $n$ 小的所有幸运数。可以运用类似于宽搜的思路，每次在幸运数后面加上 $4$ 或 $7$，然后扔队列里面。

接下来可以比较简洁地分类：

当 $n \le 14$ 时，将全排列一位一位检查是否符合条件即可。

当 $n>14$ 时，检查所有比 $n-14$ 小的幸运数（含），设它们是第 $p$ 小的幸运数，若 $p$ 也是幸运数则答案 $+1$。再判断最后 $14$ 位即可。

---

#### 代码

~~太丑了凑合一下~~

关于逆康托展开：（以下代码可以生成从 $1$ 到 $a$ 的第 $b$ 个排列的后$14$ 位）
```cpp
void make_sequence(long long a,long long b){
	b--;
	int p=a;
	if(p>14)p=14;
	for(int i=p;i>=1;i--){
		c[p-i+1]=b/jc[i-1]+1;
		int cnt=0,r=c[p-i+1];
		for(int j=1;j<=c[p-i+1];j++){
			if(!vis[j])cnt++;
			if(j==c[p-i+1]&&cnt<r)c[p-i+1]++;
		}
		vis[c[p-i+1]]=1;
		b%=jc[i-1];
	}
}
```
关于初始化：
```cpp
void init(){
	q.push(4);
	q.push(7);
	while(!q.empty()){
		if(q.front()>1e15)break;
		q.push(q.front()*10+4);
		q.push(q.front()*10+7);
		ln[++cur]=q.front();//幸运数存储。ln 建议开 8e4 左右
		q.pop();
	}
	jc[0]=1;//阶乘初始化
	for(int i=1;i<=14;i++)
		jc[i]=jc[i-1]*i;//前缀积
}
```
统计答案：（如果排列不存在要输出 $-1$）
```
int main(){
	cin>>n>>k;
	init();
	if(n<=14&&jc[n]<k){//报告无解
		cout<<-1<<endl;
		return 0;
	}
	make_sequence(n,k);//逆康托展开
	long long ans=0;
	if(n<=14){
		for(int i=1;i<=n;i++)
			if(check(i)&&check(c[i]))//check检查幸运数
				ans++;
		cout<<ans<<endl;
	}
	else{
		for(int i=1;i<=cur;i++){
			if(ln[i]>n-14)break;
			else ans++;
		}
		for(int i=n-13;i<=n;i++){
			c[14-n+i]+=n-13;
			if(check(i)&&check(c[14-n+i]))
				ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
数组定义和检查幸运数的函数很简单的，自己写。

---

## 作者：luqyou (赞：1)

发现 $k<=10^9<13!$ 所以只有最后几位会变。

前面一大段都是固定的。

考虑求前面一大段的贡献。

$n$ 最大就 9 位，直接数位DP就好了(爆搜也是可以的)。

考虑后面几位的贡献。

用逆康托展开求出每一位的值然后暴力判断就好了。

代码有一些细节:

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
    return x*f;
}
const int N=233;
int n,m,ans,a[N],f[N];
ll fac[N];
int dfs(int pos,bool lim,bool z)//lim表示前几位是否在上限，z前几位表示是否是前导零
{
    if(pos==-1) return 1;
    if(!lim&&!z&&f[pos]!=-1) return f[pos];
    int res=0,mx=lim ? a[pos] : 9;
    for(int i=0;i<=mx;i++)
    {
        if(i==4||i==7||(z&&i==0))
            res+=dfs(pos-1,lim&(i==mx),z&&i==0);
    }
    if(!lim&&!z) f[pos]=res;
    return res;
}
int solve1(int x)//求前面一段的贡献
{
    int tot=0;
    while(x) a[tot++]=x%10,x/=10;
    return dfs(tot-1,1,1);
}
inline bool pd(int x)//判断是否为幸运数
{
    while(x)
    {
        if(x%10!=4&&x%10!=7) return 0;
        x/=10;
    }
    return 1;
}
int solve2(int x,int rnk)//求后面一段贡献
{
    vector <int> v,b;
    for(int i=n-x+1;i<=n;i++) v.push_back(i);
    for(int i=x;i>=1;i--)//逆康托展开
    {
        int t=rnk/fac[i-1]; rnk%=fac[i-1];
        sort(v.begin(),v.end());
        b.push_back(v[t]); v.erase(v.begin()+t);
    }
    int p=n-x+1,res=0,len=b.size();
    for(int i=0;i<len;i++,p++)
        if(pd(p)&&pd(b[i])) res++;//暴力判断
    return res;
}
int main()
{
    n=read(),m=read();
    fac[0]=1; for(int i=1;i<=15;i++) fac[i]=fac[i-1]*i;
    if(n<=12&&fac[n]<1ll*m) { printf("-1"); return 0; }//注意特判无解
    memset(f,-1,sizeof(f));
    int tot=0; while(m>fac[tot]) tot++;
    printf("%d",solve1(n-tot)-1/*-1是因为数位dp时全取0也会算到贡献*/+solve2(tot,m-1));
    //注意m-1,因为康托展开求的是比一个排列小的排列数，即它的排名为比它小的排列数+1
    return 0;
}
```


---

## 作者：爱瑶瑶公主 (赞：0)

~~做完这题头疼的都快炸开了……~~

好了，我也不多唧唧歪歪，直接分析：

这道体牵涉到了两个东西：
	
    1.幸运数
    2.全排列
幸运数比较好处理，但是全排列就很恶心。我原本想的是直接用一个大回溯求出第K大的全列。
可是，这样只能得四十分，剩下六十分全是时间超限。原因很简单：n有10的9次方，也就是100000000。仔细想想，1.00s找它的第K大全排列时间肯定不够。于是，就可以用上一个很神奇的算法——[康托展开](https://www.luogu.com.cn/problem/P5367)。它原本是求一个N个数排列在N！中是第几大的。于是他的逆运算便珂以求出N！中第K大的排列。

举个栗子，方便理解：

    要求5位全排列中第62大的全排列。
    首先，用（62-1）表示它前面有几个全排列。
    用 61 / 4! = 2余13，说明a[5]=2,说明比首位小的数有2个，所以首位为3。
	用 13 / 3! = 2余1，说明a[4]=2，说明在第二位之后小于第二位的数有2个，而3已经在首位用过了，所以第二位为4。
	用 1 / 2! = 0余1，说明a[3]=0，说明在第三位之后没有小于第三位的数，所以第三位为1。
	用 1 / 1! = 1余0，说明a[2]=1，说明在第二位之后小于第四位的数有1个，之前3、4、1已经用过了，所以第四位为5。
	最后一位自然就是剩下的数2啦。
	通过以上分析，所求排列组合为 34152
    
于是，用了逆康托展开，就珂以AC道题。然后贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,temp=20,temp2,tot,tot2,rap,s=0;
long long a[3000000],b[300],c[300],fact[300],AC[300];
void dfs(long long x,long long y)
{
	y+=4*x;
	if(y>n)
		return ;
	a[++tot]=y;
	dfs(x*10,y);
	y+=3*x;
	if(y>n)
		return ;
	a[++tot]=y;
	dfs(x*10,y);
}
bool pd(long long x)
{
	long long i;
	for(i=tot;i>=1;i--)
	{
		if(x==a[i])
			return true;
		else if(x>a[i])//可有可无，减枝优化而已
			break;
	}
	return false;
}

void CodeForces()
{
	long long temp3=k;
	while(temp)
	{
		int xxx=temp3/fact[temp]+1;
		AC[++rap]=c[xxx];
		for(int i=xxx;i<=temp;i++)
		  c[i]=c[i+1];
		temp3%=fact[temp];
		temp--;
	}
	AC[++rap]=c[1];
	for(int i=1;i<=tot2;i++)
	{
		if(pd(AC[b[i]-temp2+1]))
	    s++;
	}
}
int main()
{		
	scanf("%d%d",&n,&k);
	fact[0]=fact[1]=1;
	for(int i=2;i<=20;i++)//阶乘预处理，方便逆康托展开
		fact[i]=fact[i-1]*i;
	if(n<=12&&fact[n]<k)//如果全排列个数还没K多，那后面还继续算干嘛？
   {
		printf("-1\n");
		return 0;
	}
	k--;//注意逆康托展开是有多少个数比它小,而K是指它是第K大的排列，因此，有K-1个排列比它小，所以K--。
	dfs(1,0);//把幸运数存入数组
	if(tot==0)
   {
		printf("0\n");
		return 0;
	}
	sort(a+1,a+tot+1);排序一下，方便后续的处理
	while(temp>0)
   {
		if(fact[temp]<=k)
			break;
		temp--;
	}
	temp2=n-temp;
	for(int i=tot;a[i]>=temp2;i--) 
	  b[++tot2]=a[i];
	for(int i=temp2;i<=n;i++)
	  c[i-temp2+1]=i;
	s=tot-tot2; 
	CodeForces();//逆康托展开
	if(s==0)
		printf("-1\n");
	else
		printf("%d\n",s);
	return 0;
}
```	

	2020-11-8：修改此文章，删去了错误代码，对逆康托展开进行了详细展开

---


# 密令

## 题目描述

给定一小写字母串 $s$，每次操作你可以选择一个 $p$（$1 \leq p \lt |s|$）执行下述修改中的任意一个：

1. 将 $s_p$ 改为其字典序 $+1$ 的字母，将 $s_{p+1}$ 改为其字典序 $-1$ 的字母；
2. 将 $s_p$ 改为其字典序 $-1$ 的字母，将 $s_{p+1}$ 改为其字典序 $+1$ 的字母。

在经过任意多次操作后，串 $s$ 能变化成多少种字符串？

修改过程中必须保证 $s$ 是合法的小写字母串（即不能对字母 a 进行字典序 $-1$ 的操作），答案对 $10^9 + 7$ 取模。

## 说明/提示

- 对于 $30\%$ 的数据，$T=1$，$|s| \leq 10$；
- 对于 $60\%$ 的数据，$T \leq 10$；
- 对于 $100\%$ 的数据，$T \leq 10000$，$1 \leq |s| \leq 100$。

## 样例 #1

### 输入

```
3
aaaaaaaaa
ya
klmbfxzb```

### 输出

```
0
24
320092793```

# 题解

## 作者：天泽龟 (赞：45)

### 数论题与DP结合应该是很常见了，尤其是背包问题，经常可以换汤不换药的考很多种题目。。

本题一个最显著的特征就是：**对于一个序列，不论你进行多少此操作，其字典序总和不变（因为操作会加一减一，抵消了）**，进一步推进的话，就会发现一个序列无论长成啥样都无所谓，因为**答案只和他的字典序总和有关**（因为你一定可以通过一系列操作将两个字典序和相同的字符串互换）

~~然后就不会了~~然后经我校背包大佬提醒，可以设$f[i][j]$为当有i个字符时，总和为j的种类数，因为j一定可以从一个比它小的数在加上一个字符转移过来，于是就有了一下这个式子：

## $f[i][j]={\sum \limits_{0<=k<26}f[i-1][j-k]}$
### 其中k即为当前字符的字典序数（本蒟蒻一开始死套背包公式，用k<j导了半天）。

然后初始化的话也应该只标记0~25，因为一个字符的字典序数不会超过25（又被卡了很久_(:з」∠)_）

最后膜一下就可以啦！上丑陋的代码：
```
#include <iostream>
#define mo 1000000007
using namespace std;
int t;
string s;
long long f[110][5000];//前i个，和是j的种类数；类似背包选数 
int main()
{
	cin>>t;
	for (int i=0;i<26;i++) f[1][i]=1; //初始化的范围也应该只在(a~z)!! 
	for (int i=2;i<=100;i++)
	{
		f[i][0]=1;
		for (int j=1;j<=2700;j++)
			for (int k=0;k<26;k++) //每次修改只会增加1~26的值(a~z) 
				if (j-k>=0) f[i][j]=(f[i][j]%mo+f[i-1][j-k]%mo)%mo;
	}
	
	while (t--)
	{
		cin>>s; int sum=0;
		for (int i=0;i<s.size();i++) sum+=s[i]-'a';
		cout<<f[s.size()][sum]%mo-1<<endl;
	}
	return 0;
}


```

最后讲个鬼故事：此程序不知为何在我的电脑上跑的贼慢（3s）但lg上就100ms，废品店以旧换新了解一下。

---

## 作者：Bingoier (赞：12)

/\*
由题意可推导得不论进行怎么样的修改

～～ 各个字母的ASCII码相加的和始终不变 ～～

即各个字母可任意转化，只要保持其ASCII码总和不变即可

       
这是本题解题的关键！！！


接下来其实题目就转化为了求背包问题的方案总数

具体可参考背包9讲

\*/





    
    
                
                
    

    
    

```cpp
#include<bits/stdc++.h>
using namespace std;
#define INF 1000000007
long long T,num,len,c[120][3010];
char s[120];
void work(){              
       // c[i][j] 代表有 i 个字母时其字母序号总和为 j 时的方案总数
    for(int i=0;i<26;i++) c[1][i]=1;
    for(int j=2;j<=100;j++){
        for(int k=0;k<=3000;k++){
            for(int i=0;i<26;i++){
                if(k>=i){
                    c[j][k]+=c[j-1][k-i];
                    c[j][k]%= INF ;
                }
            }
        }
    }
    return;
}
int main ( )
{    
    work();     //   先预处理出所以情况的方案数
    scanf("%d",&T);
    while(T--){
        scanf("%s",&s);
        num=0,len=strlen(s);           // len 为每次的字母数量
        for(int i=0;i<len;i++) num+=s[i]-'a';  // num 为各个字母序号总和
        printf("%lld\n",c[len][num]-1);   // 别忘了把其原先最初的一个给剪掉
    }
    return 0;
}

```

---

## 作者：bear_circle (赞：9)

题目中的两个操作其真正含义是：把相邻两个字符中 左边的字符的一个1 给  右边的字符（或者反过来）。而题目整个的意思就相当于是：把每个字符在'a'的基础上多余的数分配给每一位有多少种情况（除开原有的那一种）。

解题步骤：
1.先统计一下一共有多少个可分配的数。
2.分配。

首先我想到的是常规数位dp，但超时了最后一组。

超时90分代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
#define in(A) scanf("%d", &A)
const int mod = 1e9+7;
int f[101][2700];
inline int dp(int dep, int len, int num){
    if(num == 0) return 0;
    if(dep == len) return (num <= 26) ? 1: 0;
    if(~f[dep][num]) return f[dep][num];
    int mi = min(num, 26), res = 0;
    for(int i = 1; i <= mi; i++){
        res = (res + dp(dep+1, len, num-i)) % mod;
    }
    return f[dep][num] = res;
}
int main(){
    int T;
    char s[110];
    in(T);
    while(T--) {
        scanf("%s", s);
        memset(f, -1, sizeof f);
        int len = strlen(s), num = 0;
        for(int i = 0; i < len; i++) num += s[i]-'a'+1;
        printf("%d\n", dp(1, len, num)-1);
    }
}

```

看看题目就会发现是因为有多组数据超时的。那么这个时候就思考怎么让记忆化f数组变成通用的呢？想到了如下变换f[dep][num] -> f[len-dep][num],这样f的定义就从 dp到dep深度还剩num个可分配的数，变成了，dp到还剩len-dep的深度到达目的地时还剩num个数可以分配。

第一次写题解，不足之处请多多指出，谢谢。

附上AC代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
#define in(A) scanf("%d", &A)
const int mod = 1e9+7;
int f[101][2700];
inline int dp(int dep, int len, int num){
	if(num == 0) return 0;
	if(dep == len) return (num <= 26) ? 1: 0;
	if(~f[len-dep][num]) return f[len-dep][num];
	int mi = min(num, 26), res = 0;
	for(int i = 1; i <= mi; i++){
		res = (res + dp(dep+1, len, num-i)) % mod;
	}
	return f[len-dep][num] = res;
}
int main(){
	int T;
	char s[110];
	in(T);
	memset(f, -1, sizeof f);
	while(T--) {
		scanf("%s", s);
		int len = strlen(s), num = 0;
		for(int i = 0; i < len; i++) num += s[i]-'a'+1;
		printf("%d\n", dp(1, len, num)-1);
	}
}
```

---

## 作者：CGDGAD (赞：4)

## 题解 P1385【密令】

### DP 分析

发现数列的总和不变，于是问题变为了有多少种长度为 $n$ 的序列，使得总和为 $sum$，并且每个数都是 $0$ 到 $25$ 之间的数（可以证明，只要总和均为 $sum$，一定可以构造出方法从原序列变为新序列）。

这很明显是一个动态规划问题。

设 $f(k,x)$ 为前 $k$ 个数总和为 $x$ 的方案数。
$$
f(k,x) = \sum_{0 \le i \le 25,x\ge i}f(k-1,x- i )
$$
什么意思呢？考虑要放第 $k$ 个数使得总和为 $x$ 时，每一个在 $[0,25]$ 的 $i$（当然也需要满足 $x \ge i$），都尝试把它放进序列，这时就需要从 $f(k-1,x-i)$ 转移过来。答案即为所有满足条件的 $f(k-1,x-i)$ 之和。

----

### 细节问题

这个 dp 的边界值是多少？

如果数列总和为 $0$，那么只有一种，就是全 $0$。所以对于所有的 $i$，$f(i,0) = 1$。 

如果数列中只有一个数，并且数列的总和在 $[0,25]$ 之间，那么也只有一种方式。

----

### 实现方式

由于是多组测试数据，可以先预处理好答案，询问的时候直接输出即可。因为 $\left|s\right|\le100$，所以字典序总和最多为 $2600$。

输入的时候完全不用考虑这个字符串是什么，只需要知道长度和总和即可。注意，输出的时候需要减一，删去原来的那个字符串，因为原题问的是变成不同的字符串的个数。

输入可以使用 `getchar`，类似快读的方式处理，如下。

```cpp
inline void readString() {
	char ch = getchar();
	count = 0, sum = 0;
	while (ch < 'a' || ch > 'z') ch = getchar();
	while (ch >= 'a' && ch <= 'z') ++count, sum += (int)ch - 'a', ch = getchar();
}
```

其余部分实现：

```cpp
signed main() {
	scanf("%lld", &T);
	for (int i = 0; i < 26; ++i) dp[1][i] = 1;
	for (int k = 2; k <= 100; ++k) {
		dp[k][0] = 1;
		for (int x = 1; x <= 2600; ++x)
			for (int i = 0; i < 26; ++i)
				if (x >= i)
					dp[k][x] = (dp[k][x] + dp[k - 1][x - i]) % MOD;
	}
	while (T--) {
		readString();
		printf("%lld\n", dp[count][sum] - 1);
	}
	return 0;
}
```



---

## 作者：尹昱钦 (赞：2)

**用了不一样的结构框架，没特意卡常，结果跑了个~~实名中的~~最优解。**

------
## 解题思路
核心部分和其他的题解完全相同：

用 $dp_{i,j}$ 表示前 $i$ 位的和为 $j$ 的方案数。

然后枚举第 $j$ 位可能情况（$0\to 25$），从 $dp_{i-1,j-k}$ 转移过来即可。

不同的是我对询问进行了**离线处理**。

这样做可以使 $dp$ 数组的第一维滚动优化掉，然后逆序枚举 $j$，边求 $dp$ 边存储答案。

再就是开 long long 可以使取模运算放到最后，这样对于每个 $dp_j$ 只取模了一次。

这样的时间复杂度应该为 $O(T\log T+26\times len_{max}sum_{max})$。

~~于是就用 cin/cout 拿了最优解。~~
## 代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cmath>
#include<algorithm>
using namespace std;
const int mod=1e9+7;
int T;
long long dp[3005],m;
string s;
struct node{
	int id;
	long long len,sum,ans;
}q[10005];
bool cmp1(node a,node b){
	return a.len<b.len;
}
bool cmp2(node a,node b){
	return a.id<b.id;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>T;
	for(int t=1;t<=T;t++){
		cin>>s;
		q[t].id=t;
		q[t].len=s.length();
		for(int i=0;i<q[t].len;i++){
			q[t].sum+=s[i]-'a';
		}
		m=max(m,q[t].sum);
	}
	sort(q+1,q+T+1,cmp1);//离线处理
	int now=1;
	for(int i=0;i<=25;i++) dp[i]=1;
	while(now<=T&&q[now].len==1){
		q[now].ans=1;
		now++;
	}
	for(int i=1;i<q[T].len;i++){
		for(int j=m;j>=0;j--){
			for(int k=1;k<=25;k++){
				if(j<k) break;
				dp[j]+=dp[j-k];
			}
			dp[j]%=mod;
		}
		while(now<=T&&q[now].len==i+1){//储存答案
			q[now].ans=dp[q[now].sum];
			now++;
		}
	}
	sort(q+1,q+T+1,cmp2);
	for(int i=1;i<=T;i++){
		cout<<q[i].ans-1<<endl;
	}
    return 0;
}
```

---

## 作者：木木！ (赞：1)

首先，很容易发现，通过题目中给出的操作，可以将序列任意两个位置的字符分别+1和-1。

因此，序列可以长成所有可能的模样，只需要满足每个数的和不变就好。

数学方法瞎搞搞不出，就考虑用DP。DP的思路是用`dp[i][j]`表示到i个数还剩j个+1（即剩余字符最多比a高多少），状态转移方程就是枚举填表。

```cpp
dp[0][lst] = 1;
for(int i=1; i<=len; ++i)
{
	for(int j=0; j<=lst; ++j)
	{
		for(int k=0; k<=25; ++k)
		{
			if(j+k <= lst)
			{
				dp[i][j] += dp[i-1][j+k];
				dp[i][j] %= p;
			}
		}
	}
}
```

于是，就这么T了三个点。

令S表示字符集大小（26），n表示字符串的长度，这个算法的时间复杂度是$\Theta(T\times n\times \Sigma ci \times |S|)$，最大`10000*100*2600*26=67600000000`（次取模+加法），哦豁，完蛋。

其他项看起来都是硬点，干不掉，但是最内层循环看起来很可干的样子。只需要将dp数组前缀和一下，就不用枚举`k`，可以直接$\Theta(1)$状态转移。

最终时间复杂度$\Theta(Tn\Sigma ci)$，如果数据出极限的话就很凉凉……但是这题数据能过QwQ。

附AC代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int p = 1000000007;

int dp[105][2505];
int si[105][2505];
char str[105];

int main()
{
	int t;
	scanf("%d",&t);
	for(int asdfg=1; asdfg<=t; ++asdfg)
	{
		scanf("%s",str);
		
		int lst = 0;
		int len = 0;
		for(; str[len]; ++len)
		{
			lst += str[len]-'a';
		}
		
		for(int i=0; i<=len; ++i)
		{
			for(int j=0; j<=lst; ++j)
			{
				dp[i][j] = 0;
				si[i][j] = 0;
			}
		}
		
		dp[0][lst] = 1;
		si[0][lst] = 1;
		for(int i=1; i<=len; ++i)
		{
			for(int j=0; j<=lst; ++j)
			{
				dp[i][j] = (si[i-1][min(j+25,lst)] - (j?si[i-1][j-1]:0))%p;
				si[i][j] = ((j?si[i][j-1]:0) + dp[i][j])%p; //一次取模可以转化成一次加法+一次比较+一次减法，但是这题不用卡常就没转QwQ
			}
		}
		
		printf("%d\n",((dp[len][0]-1)%p+p)%p);
	}
}
```

---


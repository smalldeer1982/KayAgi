# 又是毕业季II

## 题目背景

“叮铃铃铃”，随着高考最后一科结考铃声的敲响，三年青春时光顿时凝固于此刻。毕业的欣喜怎敌那离别的不舍，憧憬着未来仍毋忘逝去的歌。一千多个日夜的欢笑和泪水，全凝聚在毕业晚会上，相信，这一定是一生最难忘的时刻！


## 题目描述

彩排了一次，老师不太满意。当然啦，取每位同学的号数来找最大公约数显然不太合理。于是老师给每位同学评了一个能力值。于是现在问题变为，从 $n$ 个学生中挑出 $k$ 个人使得他们的默契程度（即能力值的最大公约数）最大。但因为节目太多了，而且每个节目需要的人数又不知道。老师想要知道所有情况下能达到的最大默契程度是多少。这下子更麻烦了，还是交给你吧~

PS：一个数的最大公约数即本身。


## 说明/提示

【题目来源】

lzn 原创

【数据范围】

记输入数据中能力值的最大值为 $\textit{inf}$。

- 对于 $20\%$ 的数据，$n \leq 5$，$\textit{inf}\leq 10^3$；
- 对于另 $30\%$ 的数据，$n \leq 100$，$\textit{inf} \leq 10$；
- 对于 $100\%$ 的数据，$n \leq 10^4$，$\textit{inf} \leq 10^6$。

## 样例 #1

### 输入

```
4
1 2 3 4
```

### 输出

```
4
2
1
1
```

# 题解

## 作者：lzn (赞：359)

《又是毕业季II》解题报告

By lzn
数论常规题。

一开始很容易想到枚举n个数取k个的所有组合，然后分别用辗转相除法求最大公约数，但是复杂度明显不符合要求，于是必须换一种思路。

我们想到，k个数的公约数含义就是这k个数均含有某个因数，如果我们把所有数的因数全部求出来，发现有k个数均含有某个因数，那么这个数必然是这k个数的公约数。其中找出最大的就是它们的最大公约数。但是要如何高效的做到这点呢？考虑到对于k=1，2……，n都要求出，我们可以这么做：


\* 1、    求出每个因数出现的次数。

\* 2、    对于每个次数记录最大的因数。

\* 3、    根据f[k]=max(f[k],f[k+1])逆向递推。（如果已经知道k个数的最大公约数是m，那么l(l<k)个数的最大公约数一定大于等于m）。


具体为什么这么做，留给大家自己思考啦~~

算法复杂度o(n\*sqrt(inf))。


---

## 作者：夜刀神十香ღ (赞：241)

接着lzn大人的思路把题解编下去（略有不同）。    
我们想到，k个数的公约数含义就是这k个数均含有某个因数，如果我们把所有数的因数全部求出来，发现有k个数均含有某个因数，那么这个数必然是这k个数的公约数。其中找出最大的就是它们的最大公约数。  
每个数分解因数，c[i]表示i作为因子的次数。 
对于答案i，c[x]>i的p可以作为答案。  
可以发现i的答案一定大于等于i+1的答案。   
扫一遍找答案行了。  
lzn大人已经把思路讲的很明白了，请允许我把代码补上QwQ  
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int n,t=0,c[1000010];
//c[i]表示i作为因子的次数
int main()
{
	cin>>n;
    for(int i=1;i<=n;i++)
	{
        int x; cin>>x;
		t=max(t,x);
        //记录目前最大能力值
        int m=sqrt(x);
        //能力值的开方
        for(int i=1;i<=m;i++)
            if(x%i==0)
            //有约数
			{
                c[i]++;
                //i作为因子的次数++
                if(x!=i*i) c[x/i]++;
                //如果x不是i的平方，x/i也是x的因子
                //如果x是i的平方只记录i作为一次因子
            }
    }
    int x=t;
    for(int i=1;i<=n;i++)
	{
        while(c[x]<i) x--;
        //找出最大的默契值（本题专有名词好烦QwQ）
        cout<<x<<endl;
        //输出
    }
    return 0;
    //华丽丽的结束
}
```

---

## 作者：影辰 (赞：29)

提供一个暴力的做法

首先，看到所有权值不超过1e6

那么我们可以把所有的值存到一个桶里面

枚举1到n，记当前枚举到的值为k

枚举k,2k,3k...即枚举有多少个数被k整除

复杂度O(nlog n)

设共有sum个数被k整除

则令ans[sum]=k（因为我们是从小到大枚举，所以可以直接覆盖）

最后再做一个后缀最大值即可

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e6+1;
int n,x,sum;
int t[inf];
int ans[10005];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&x),t[x]++;
    for(int i=1;i<inf;i++){
        sum=0;
        for(int j=1;i*j<inf;j++) sum+=t[i*j];
        ans[sum]=i;
    }
    for(int i=n-1;i>=1;i--) ans[i]=max(ans[i],ans[i+1]);
    for(int i=1;i<=n;i++) printf("%d\n",ans[i]);
} 
```

---

## 作者：Tekim (赞：15)

脑子不够，数据结构来凑~

我们只需要花费sqrt(a[i])的时间就可以把a[i]的所有因子全部找出来。

对于所有的因子我们在线段树中维护最大值，即线段树中的下标对应着该因子的数量。

每次询问我们只需要询问一次线段树i~n位置中的维护的最大值即可~

```
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define lson o<<1
#define rson (o<<1)|1
using namespace std;
const int maxn=1e4+7,maxm=1e6+7;
int n,a[maxn],tong[maxm],maxx[maxn*4];
void up(int o)
{
	maxx[o]=max(maxx[lson],maxx[rson]);
}
void Insert(int o,int l,int r,int pos,int v)
{
	if(l==r) {maxx[o]=v;return ;}int mid=(l+r)/2;
	if(pos<=mid) Insert(lson,l,mid,pos,v); 
	else Insert(rson,mid+1,r,pos,v);
	up(o);
}
int quiry_(int o,int l,int r,int ll,int rr)
{
	if(ll<=l&&rr>=r) return maxx[o];
	int mid=(l+r)/2,ans=0;
	if(ll<=mid) ans=quiry_(lson,l,mid,ll,rr);
	if(rr>mid) ans=max(ans,quiry_(rson,mid+1,r,ll,rr));
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j*j<=a[i];++j)
		{
			if(a[i]%j) continue;tong[j]++;
			int y=a[i]/j;if(y!=j) tong[y]++;
		}
	}
	for(int i=1;i<=1e6;++i) 
	if(tong[i]>0) Insert(1,1,n,tong[i],i);
	for(int i=1;i<=n;++i) printf("%d\n",quiry_(1,1,n,i,n));
	return 0;
} 
```


---

## 作者：DYT_ (赞：15)

这题其实还是比较简单的，我的代码用到了类似于筛法挖素数的想法。

先记录每一个人的能力值a[i]到vis数组中。

根据一个贪心：人数递增时最大公因数肯定递减。

所以我们可以开一个top，从最大可能的a[i]向1枚举从1到n的最大公因数(设为x)，再check是否能够达到或者超过当前制定人数

check就是枚举x到max(a[i])之间x的倍数，统计总共有多少人。

这样的复杂度其实是O(nlog(n)log(n))的（和筛法差不多 ps:就是欧拉筛的笨蛋版本）

代码如下：

```cpp
#include<cstdio>
#include<string>
using namespace std;
const int maxn=10005,maxl=1000005;
int n,r,a[maxn],top,ans[maxl],vis[maxl];//记录ans数组，防止多次check同一个值,增大时间复杂度 
int check(int x){
    if (ans[x]!=0) return ans[x];
    int sum=0; int y=x;
    while (y<=r) {sum+=vis[y]; y+=x;}
    ans[x]=sum;
    return sum;
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        vis[a[i]]++;//vis[i]记录值为i的数有几个 
        if (a[i]>r) r=a[i];
    }
    int top=r;
    for (int i=1;i<=n;i++) {
        while (top>1&&check(top)<i) top--;//top向下枚举，类似于单调栈的操作 
        printf("%d\n",top);
    }
    return 0;
}
```

---

## 作者：Lstdo (赞：10)

~~这题挺神的~~

首先用一个数组cnt记录1～inf的数作为因数出现了多少次，即最多有多少个数的gcd等于它。类似于判素数跑一遍，注意当x是完全平方数时根号x只能算一次。

再开一个ans记录答案。由于求最多，就从inf跑到1，可以记录**刚好**有k个的最大值。

玄学操作来了：刚刚求的是刚好等于的，而题目中大于也可以，所以要处理一下。至于为什么玄学，自己看代码。

最后输出，结束。

AC代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int cnt[1000005],ans[10005];
void solve(int x)
{
	for (int i=1;i*i<=x;i++)
		if (x%i==0)
		{
			cnt[i]++;
			if (i*i!=x)
				cnt[x/i]++;
		}
}
int main()
{
	int n,maxa=0;
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		int a;
		scanf("%d",&a);
		solve(a);
		maxa=max(a,maxa);		
	}
	for (int i=maxa;i>=1;i--)
		if (ans[cnt[i]]==0)
			ans[cnt[i]]=i;
	int temp=0;
	for (int i=n;i>=1;i--)
	{
		ans[i]=max(temp,ans[i]);
		temp=max(temp,ans[i]);
	}//玄学
	for (int i=1;i<=n;i++)
		printf("%d\n",ans[i]);	
	return 0;
}
```

---

## 作者：Vermouth_1412 (赞：9)

noip前夕，开始~~水题~~
结果，被题虐暴……
话说看了看题解大多是O(nsqrt(n))的做法，所以窝来发一下O(nlgn)的做法（~~事实上有这样复杂度的算法，可是和窝好像不一样~~）。



------------

### 前20分：考虑暴力搜索

这部分的分就比较呆，从前往后扫就行，维护现在在哪个学生，现在的学生的个数，还有答案，边搜边求gcd就行，事实上可以得到28分

代码大概长这样：

```cpp
void dfs(int now,int len,int nt)
{
	if(nt==1) return;
    if(nt>b[len]) b[len]=nt;
    if(len>n) return;
    int res;
    for(rint i=now;i<=n;++i){
        res=gcd(max(nt,a[i]),min(nt,a[i]));
        if(res>1) dfs(i+1,len+1,res);
    }
}
```

### 接着的30分，会发现最大元素不超过10

首先可以想到把这10种元素丢进桶里，然后像上面一样暴力搜索。由于搜索中要处理元素个数比较麻烦，接着思考，我们就会发现有另外一种想法，2是4,6,8,10的因数，3是6,9的因数，4是8的因数，5是10的因数，那么就顺着来就好，先用10填，10填完用9，再用8，以此类推，知道用1填完；

代码如下：

```cpp
for(rint i=1;i<=n;++i) ++c[a[i]];
		c[2]+=c[4]+c[6]+c[8]+c[10];c[3]+=c[9]+c[6];c[4]+=c[8];c[5]+=c[10];
		int zz=10;
		for(rint i=1;i<=n;++i){
			while(c[zz]<i&&zz>1) --zz;
			if(zz==1){
				for(rint j=i;j<=n;++j) printf("1\n");
				return 0;
			}
			printf("%d\n",zz);
		}
		return 0;
```

### dalao们常说，部分分是用来提示正解的，其实会了上面的30分，这道题就解决了

我们考虑每个数i，它在此题的inf内只有n/i个倍数，而它倍数的答案就可以像上面一样转移到自己上来，然后复杂度就是n*(1+1/2+1/3+1/4+……+1/n),后面这一坨是一个经典的发散基数，它们的和是ln(n)+γ,γ约等于0.57721,那么这道题就可以在nlg(n)的时间内解决了！

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rint register int 
using namespace std;
const int mx=10005;
const int man=1000000;
int n;
int a[mx],b[mx],c[20],d[man+5];
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
    return x*f;
}
int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}
void dfs(int now,int len,int nt)
{
	if(nt==1) return;
    if(nt>b[len]) b[len]=nt;
    if(len>n) return;
    int res;
    for(rint i=now;i<=n;++i){
        res=gcd(max(nt,a[i]),min(nt,a[i]));
        if(res>1) dfs(i+1,len+1,res);
    }
}

int main()
{
	freopen（"a.in","r",stdin）;
    n=read（）;int ma=0;
	for(rint i=1;i<=n;++i){
		a[i]=read();if(ma<a[i]) ma=a[i];
	} 
	if(n<=8){
		for(rint i=1;i<=n;++i) b[i]=1;
		for(rint i=1;i<=n;++i){
		    if(a[i]>1) dfs(i+1,1,a[i]);
		}
		for(rint i=1;i<=n;++i) printf("%d\n",b[i]);
		return 0;	
	}
	if(ma<=10){
		for(rint i=1;i<=n;++i) ++c[a[i]];
		c[2]+=c[4]+c[6]+c[8]+c[10];c[3]+=c[9]+c[6];c[4]+=c[8];c[5]+=c[10];
		int zz=10;
		for(rint i=1;i<=n;++i){
			while(c[zz]<i&&zz>1) --zz;
			if(zz==1){
				for(rint j=i;j<=n;++j) printf("1\n");
				return 0;
			}
			printf("%d\n",zz);
		}
		return 0;
	}
	for(rint i=1;i<=n;++i) ++d[a[i]];
	d[1]=n;
	for(rint i=2;i<=man;++i) for(rint j=i<<1;j<=man;j+=i) d[i]+=d[j];
	int zz=man;
	for(rint i=1;i<=n;++i){
		while(d[zz]<i) --zz;
		printf("%d\n",zz);
	}
	return 0;
}
```

---

## 作者：婷菡 (赞：7)

#### [题目链接](https://www.luogu.org/problem/P1414)

发现这道题题解挺少的,而且好像没多少人用我这种方法,于是就发个题解(~~水水咕值~~)

题意:给定n个数,对每一个${k{\in}[1,n]}$求出选k个人最大的最大公约数

我们可以从序列中最大的数开始向后**枚举最大公约数**,找到该最大公约数对应的**最大**人数 ,将该人数前的所有未被更新的**ans[]**(答案数组)更新

放代码(详细解释在代码里)

```cpp
#include<bits/stdc++.h>
using namespace std;

#define M 10001
#define N 1000001
#define re register

int read(){
  int p=0;char c=getchar();
  while(c<'0'||c>'9')c=getchar();
  while(c>='0'&&c<='9')
  p=(p<<3)+(p<<1)+c-'0',c=getchar();
  return p;
}

int n,ma;

int a[M],f[N],ans[M];

int max_(int x,int y){return x>y?x:y;}//返回最大数

int main(){
  n=read();
  for(re int i=1;i<=n;i++)
  a[i]=read(),f[a[i]]++,ma=max_(ma,a[i]);
  //f[]为桶 ma是序列中最大的数
  for(re int i=ma;i>=1;i--){//倒着枚举,保证最大(正着也行反正时间复杂度一样(都要遍历完))
    int k=0;
    for(re int j=i;j<=ma;j+=i)
    k+=f[j];//统计人数
    for(re int j=k;j>=1;j--)
    if(!ans[j])ans[j]=i;//k前每遇到一个未被更新的ans[],便用i将其更新
    else break;//若遇到一个已被更新的j说明之前的都被更新过了,直接结束
  }
  for(re int i=1;i<=n;i++)
  printf("%d\n",ans[i]);/打印答案
  return 0;
}

```


---

## 作者：to_be_continued (赞：5)

这题是刷训练场看见的。其他的不会做，就来做这个了。

~~其实还是蛮简单的~~

题意就是找一个数，使他是最大的选K个数的gcd

然后，就~~暴力~~

刚开始我是这么想的：

#### 用数组存下每一个数能是多少个数的gcd。然后去输出（这个应该不用细讲）

#### 那么主要就是怎么用数组存下呢

两种方法

#### 1.枚举每一个数，然后再枚举每一个a[i]，如果能整除，那么就累加。

~~轻松拿64~~

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <map>
#include <queue>
#include <set>

using namespace std;

#define ll long long
#define maxx 10000000

int bo[maxx+2];
int max_x;
int a[10001];

inline int max(int x,int y){ return x>y?x:y;}

int main(){
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        int x;
        scanf("%d",&a[i]);
        max_x=max(max_x,a[i]);//找最大值
    }
    for (int i=1;i<=max_x;i++){//枚举每一个gcd
        for (int j=1;j<=n;j++){
            if (a[j]%i==0){//如果它能被一个a[i]整除，就累加
                bo[i]++;
            }
        }
    }
    int i=1;
    while (i<=n){
        for (int j=max_x;j>0;j--){
            while (bo[j]>=i){
                printf("%d\n",j);
                i++;
            }
        } 
    }	
    return 0;
}
```

#### 然后就发现这个根本不够优。时间到了o（max_a[i]N）。然后经过思考，emm，发现这么做就是~~沙雕~~。其实完全可以直接找到每一个数的因数，然后直接累加。

#### 然后可以有一个优化——关于输出。首先我们已经用数组存下了每一个数最多能被多少个a[i]整除。如果这个数能被k个a[i]整除，那么它也一定可以被k-1个a[i]整除。把她倒过来也是，如果这个数是最大的能被k个a[i]整除,而且它还能被更多的a[i]整除，那么可以直接输出，直到它不能被i个数所整除，不需要继续找了。

那么就可以~~随随便便的~~A了

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <map>
#include <queue>
#include <set>//乱写头文件ing

using namespace std;

//bo表示这个数最多能被多少个a[i]整除
//a为读经来的数组
//max_x为最大的那个数

#define ll long long
#define maxx 10000000

int bo[maxx+2];
int max_x;
int a[10001];

inline int max(int x,int y){ return x>y?x:y;}

inline void sj(int x){
    x=a[x];
    for (int i=1;i<=sqrt(x);i++){
        if (x%i==0){
            bo[i]++;
            bo[x/i]++;
            if (i==x/i){//如果它是完全平方数，那么就减一
                bo[i]--;
            }
        } 
    }	
}

int main(){
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        int x;
        scanf("%d",&a[i]);
        max_x=max(max_x,a[i]);//找最大的a[i]
    }
    for (int i=1;i<=n;i++){
        sj(i);//分解质因数，无需多讲最水的分解质因数
    }
    int i=1;
    while (i<=n){
        for (int j=max_x;j>=1;j--){
            while (bo[j]>=i){//这就是那个输出优化。
                printf("%d\n",j);
                i++;
            }
        } 
    }	
    return 0;
}
```


至此致敬C++巨爷们 by rqbqbqb
一个c++蒟蒻


---

## 作者：YangQuijote (赞：5)

这道题我们可以用这样一种思路，当要求选出k人时，对于某个假定的最大默契值x，这个默契值是否合法取决于在n个人中是否有大于等于k个人的能力值是x的倍数。因此，我们可以在预处理时对读入的能力值进行因数分解，再给每个因数的单元格加一，以此记录某个数的倍数个数。注意，当被分解的数是完全平方数时，这个数/它的平方根=它的平方根，因此它的平方根的单元格会被进行两次加一，要减回来。另外，出于对精度的要求，平方根要用double存储，而由于精度损失，判断浮点数与整数是否相等要采取判断它们的差是否小于0.000001的方式。


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int a[1000010];
int main()
{
    int n,j,cont=0;
    scanf("%d",&n);
    int i,re;
    double gen;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&re);
        if(re>cont)
        {
            cont=re;
        }
        gen=sqrt(re);
        for(j=1;j<=gen;j++)
        {
            if(re%j==0)
            {
                a[j]++;
                a[re/j]++;
                if((gen-j)<0.000001)
                {
                    a[j]--;
                }
            }
        }
    }
    j=cont;
    for(i=1;i<=n;i++)
    {
        for(;j>=1;j--)
        {
            if(a[j]>=i)
            {
                printf("%d\n",j);
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：sqc1999 (赞：3)

lzn的题解已经很详尽了，但我觉得求出每个因数出现的次数后，没必要再做下两步，我的做法是这样的：

```cpp

for (int i = 1; i <= n; i++)
    {
        while (d[p] < i) p--;
        cout << p << endl;
    }

```
其中p能力值的最大值，d[i]表示因数i出现的次数。

可以证明，这样求出来的解一定是最优的。

下面是整个程序的代码：

```cpp

#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int d[1000001];
int a[10001];
int main()
{
    ios::sync_with_stdio(false);
    memset(d, 0, sizeof(d));
    int n, p = 0;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        p = max(p, a[i]);
        int x = sqrt(a[i] + 0.5);
        for (int j = 1; j <= x; j++)
        {
            if (a[i] % j == 0)
            {
                d[j]++;
                if (j*j != a[i]) d[a[i] / j]++;
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        while (d[p] < i) p--;
        cout << p << endl;
    }
}

```

---

## 作者：cenbinbin (赞：2)

下面也没有pascal的，作为p党，就交一发。。。


先记录每一个人的能力值a[i]到vis数组中。


根据一个贪心：人数递增时最大公因数肯定递减。


所以我们可以开一个top，从最大可能的a[i]向1枚举从1到n的最大公因数(设为x)，再check是否能够达到或者超过当前制定人数


check就是枚举x到max(a[i])之间x的倍数，统计总共有多少人。

=======================================================================================

```cpp
const maxn=1000005;
var
  ans,a,vis:array[0..maxn] of longint;
  n,i,m,maxx:longint;
function check(x:longint):longint;
var sum,y:longint;
begin
  if ans[x]<>0 then exit(ans[x]);//有点记忆化搜索的感觉
  sum:=0;y:=x;
  while y<=m do
   begin sum:=sum+vis[y];y:=y+x;end;
  ans[x]:=sum;
  exit(sum);
end;
function max(x,y:longint):longint;
begin
  if x>y then exit(x) else exit(y);
end;
begin
  readln(n);
  for i:=1 to n do
   begin read(a[i]); inc(vis[a[i]]);maxx:=max(maxx,a[i]);end;
  m:=maxx;
  for i:=1 to n do
   begin
     while (maxx>1) and (check(maxx)<i) do dec(maxx);//进行判断
     writeln(maxx);//每次输出
   end;
end.
```

---

## 作者：lqzhhh (赞：2)

大水题。。。做法与楼下相似，每次读入将其因数统计累加（但是如果刚刚好可以开方同一个因数就会累加两次，所以当恰好是开方时需要减掉，不加这句话就只有35）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
#define ll long long
#define For(i,a,b) for (int i=a;i<=b;i++)
#define Rep(i,a,b) for (int i=b;i>=a;i--)
using namespace std; 
int n,i,j,ma;
int a[20000];
int b[1000000];
int main()
{
    cin>>n;
    ma=0;
    For(i,1,n)
    {
        cin>>a[i];
        For(j,1,trunc(sqrt(a[i])))
        {
            if (a[i]%j==0)
            {
                b[j]++;
                b[a[i]/j]++;
                if (j*j==a[i]) b[a[i]/j]--;
            }
        }
        ma=max(ma,a[i]);
    }
    For(i,1,n)
    {
        Rep(j,1,ma)
        {
            if (b[j]>i-1)
            {
                cout<<j<<endl;
                ma=j;
                break;
            }
        }
    }
}
```

---

## 作者：AmamiyaUmi (赞：2)

这个和CCF757B差不多，a[i]记录能力值i出现的次数，c[i]记录选出i个人的最大默契度（最大公约数）。

然后枚举能力值i=1~max，算出他的倍数出现的次数cnt，然后与c[1~cnt]取最大值就能得到c[1~cnt]的最大值。

```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;

int n, a[1000000+10], c[10000+10], amx;

int main() {
    scanf("%d", &n);
    for (int i = 1, tmp; i <= n; ++i) {
        scanf("%d", &tmp);
        a[tmp]++;
        amx = max(amx, tmp);
    }
    for (int i = 1, cnt; i <= amx; ++i) {
        cnt = 0;
        for (int j = 1; i*j <= amx; ++j) {
            cnt += a[i*j];
        }
        for (int j = 1; j <= cnt; ++j) {
            c[j] = max(c[j], i);
        }
    }
    for (int i = 1; i <= n; ++i) {
        printf("%d\n", c[i]);
    }
    return 0;
}
```

---

## 作者：huanzi (赞：1)

LZN大佬牛b！！！！（破音）

这一题要我们求有K个数时的最大公约数，我们很容易想到最大公约数也就是这K个数的公因数中最大的那一个。我们一开始便会想到先定义一个数组储存每个数作为因数出现的次数，然后便拿着一个个数去除于读入的每一个数。

如果你能想到这一步，那么10分还是能拿到的，但这题可是有21个点的。

这里我们要注意样例的最大数是1e6,假如我们头铁地拿所有的数去除是绝对要TLE的，毕竟可能会出现读入的所有数都是1e6的情况。

那我们转换一下策略，不列举从1到一个读入数据的所有整数，而是取一个特殊的数为界。易知这一个数由读入数据开方所得。

这里可能有人会有疑问（至少我一开始有），那些大于这个数的因数怎么办呢？别着急，我们来看下面这个代码
```
for (int i=1;i<=n;i++)
	{
		cin>>x;
		t=max(t,x);
		int m=sqrt(x);
		for (int i=1;i<=m;i++)
		{
			if (x%i==0)
			{
				c[i]++;
				if (x!=i*i) c[x/i]++;
			}
		}
	}
```

注意那个特殊判断的点。由于一个数等于他的一个因数除于另一个特定的因数，也就是说我们可以在得出一个因数的同时，得出另一个因数。在满足上述条件下，一个因数增大另一个因数也将随之减小，而到两因数相等时我们便能求出这个数所有的因数的数量了。

至于如何输出题目所需答案，我们只需记录下读入数据的最大数，然后逆序搜索C数组即可。（因为越大的数成为因数的次数绝对不可能大于小于他的数）

最后是期待已久的CODE 

```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int t=-1,n,c[1000010];
int main()
{
	int x;
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>x;
		t=max(t,x);
		int m=sqrt(x);
		for (int i=1;i<=m;i++)
		{
			if (x%i==0)
			{
				c[i]++;
				if (x!=i*i) c[x/i]++;
			}
		}
	}
	for (int i=1;i<=n;i++)
	{
		while(c[t]<i) t--;
		cout<<t;
		if (i!=n) cout<<endl;
	}
	return 0;
}

```


---

## 作者：dph754132771 (赞：1)

如同出题的lzn大神给的题解一样，但是我没有用到递推，以及因数的搜索会有一些简单（自己看来）的做法

首先，for一遍要算的能力值，找因数的时候可以从1搜到sqrt(x),每当搜到一个因数的时候（x%i==0），那么x/i一定也为x的因数，这样搜索因数的时间就得到了很大的减少。但是需要特判一下i是否等于x/i。。。

还有就是直接用下标表示因数，然后排序一下。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int n,a,ans[10005];
struct qwe{
    int n,t;//t=time n=number;
    bool operator < (const qwe b) const{return n>b.n;} 
}tick[1000001];
void asd(int x){
    for (int i=1;i<=(int)sqrt(x);i++){ 
        if (x%i==0) {tick[i].n++; if (x/i!=i) {tick[x/i].n++; tick[x/i].t=x/i;}};
        tick[i].t=i;
    }
}
int main(){
    scanf("%d",&n);
    for (int i=0;i<n;i++){
        scanf("%d",&a);
        asd(a);
    }
    sort(tick+1,tick+1000001);
    int now,nown;
    nown=1;
    now=0;
    for (int i=n;i>=1;i--){
        while (tick[nown].n>=i) {if (tick[nown].t>now) now=tick[nown].t; nown++;}
        nown--;
        ans[i]=now;
    }
    for (int i=1;i<=n;i++) printf("%d\n",ans[i]);
}
```

---

## 作者：intruder (赞：1)

数据有点弱 我已经暴力的不能再暴力了结果还是过了 就是把每一个数的所有因数找一遍 然后记录一下呢这个因子一共出现的次数 （注意，应为只从2找到sqrt（x）所有x/i也要++而 i==x/i时就只加一个）接下来的自己想


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath> 
#include<algorithm>
using namespace std;
int n,a[10005],b[1000005],o[10005];
void before(int x){
    int y=sqrt(x);
    for(int i=2;i<=y;i++){
        if(!(x%i)){
            if(i!=x/i)
            b[i]++,b[x/i]++;
            else b[i]++;
        }
    }
    b[x]++;
}
int main(){
    scanf("%d",&n);
    int Max=-1e9;
    for(int i=1;i<=n;i++){
        scanf("%d",a+i);    
        before(a[i]);
        if(a[i]>Max)Max=a[i];
    }
    for(int i=1;i<=Max;i++){//o[i]表示出现了i次的对应的默契度 
        if(!o[b[i]])o[b[i]]=i;
        else o[b[i]]=max(o[b[i]],i);
    }
    for(int i=1;i<=n;i++){
        int mmax=-1;
        for(int j=i;j<=n;j++){
            if(o[j]>mmax)mmax=o[j];
        }
        printf("%d\n",mmax==0?1:mmax);
    }
    return 0;
}
```

---


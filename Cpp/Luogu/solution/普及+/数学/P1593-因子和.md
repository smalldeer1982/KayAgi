# 因子和

## 题目描述

输入两个整数 $a$ 和 $b$，求 $a^b$ 的因子和。

由于结果太大，只要输出它对 $9901$ 取模的结果。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq a \leq 5 \times 10^7$，$0 \leq b \leq 5 \times 10^7$。

## 样例 #1

### 输入

```
2 3```

### 输出

```
15```

# 题解

## 作者：C_Cong (赞：377)

[博客传送门](https://dgsyrc.github.io/2020/05/06/%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3%20P1593%20%E3%80%90%E5%9B%A0%E5%AD%90%E5%92%8C%E3%80%91/#more)

#### 题意简述：

求$a^b$的所有因子和

#### 解题思路：

既然要求因子和，那我们必然要先分解质因数

根据整数的唯一分解定理，整数a进行质因数分解对应的式子唯一，有:

$$a = p_1^{k_1} * p_2^{k_2} *p_3^{k_3}* … * p_n^{k_n}$$

又因为本题要分解的是$a^b$，所以上面的式子又可以写成这样：

$$a^b= p_1^{k_1*b} * p_2^{k_2*b} *p_3^{k_3*b}* … * p_n^{k_n*b}$$

证明很简单，就是把上面第一个式子乘上$b$次即可得第二个式子

接下来我们要求的是因子和，

所以就有：

$$ans= (1+p_1^1 + p_1^2 +p_1^3+ … + p_1^{k_1*b})*(1+p_2^1 + p_2^2 +p_2^3+ … + p_1^{k_2*b})*...*(1+p_n^1 + p_n^2 +p_n^3+ … + p_n^{k_n*b})$$

对于上面的式子是不是有点熟悉？

对，你没有看错，就是等比数列之间的乘积

根据等比数列求和公式：

$$sum=\frac{p^{n}-1}{p-1}$$

我们就能求出各数列的和，

对于$p^{n+1}$，我们用快速幂求

又因为本题要求的答案要对9901取模

故我们又可以通过逆元将除$p-1$转化为乘$p-1$的逆元

接下来要求逆元，根据定义，在$mod\ p$的意义下，对于一个整数$a$，有：

$$a*x≡1(mod\ p)$$

$x$即为$a$的逆元，反之成立

注意此处的$a,p$均与上文的意义不同，仅作为公式中的未知数

当$a,p$不互质时，逆元不存在，即上面的式子要满足：

$$gcd(a,p)=1$$

那么这个$x$怎么求？

那我们再引入一个定理，费马小定理：

假如$a$是一个整数，$p$是一个质数，那么当$a$是$p$的倍数时，有：

$$a^p≡a(mod\ p)$$

当$a$不是$p$的倍数时，有：

$$a^{p-1}≡1(mod\ p)$$

对于本题，显然我们要用的是第二种情况，第二种情况又可以变形为：

$$a*a^{p-2}≡1(mod\ p)$$

上式恰好对应逆元的定义式，故$a$在$mod\ p$意义下的逆元为$a^{p-2}$

$a^{p-2}$我们用快速幂即可求得

那逆元不存在怎么办，不用担心，因为对应上面的式子$p-1$，有：

$$(p-1) \ mod \ 9901=0$$

即:

$$p \ mod \ 9901=1$$

所以该等比数列之和($mod\ p$意义下)为：

$$sum= 1+({p\ mod\ 9901})^1 +({p\ mod\ 9901})^2 +({p\ mod\ 9901})^3+ … + ({p\ mod\ 9901})^{n}$$

即：

$$sum=1+n$$

至此，本题就分析完了

#### 代码实现：

```cpp
#include<iostream>
#include<cstdio>
#define mod 9901
using namespace std;

int a,b,sa,n[10010][2],cot=0,ans=1;

int quick_pow(int ml,int nl)//快速幂
{
	int s=1;
	while(nl>0)
	{
		if(nl%2==1)
		{
			s=(s%mod)*(ml%mod)%mod;
		}
		ml=ml*ml%mod;
		nl=nl>>1;
	}
	return s%mod;
}

int sum(int x,int y)
{
	int k=0;
	y=y*b;
	if(x%mod==1)
	{
		k=(y+1)%mod;//当逆元不存在时
	}
	else
	{
		k=(quick_pow(x%mod,y+1)-1)%mod*quick_pow((x-1)%mod,mod-2)%mod;//当逆元存在时
	}
	
	return k%mod;
}

int main()
{
	scanf("%d%d",&a,&b);
	if(a==0)//特判，0的因数和就是0
	{
		printf("0\n");
		return 0;
	}
	for(int i=2;i*i<=a;i++)//分解质因数
	{
		if(a%i==0)
		{
			cot++;
			n[cot][0]=i;//记录质因数
			n[cot][1]=1;//记录幂次
			a=a/i;
			while(a%i==0)
			{
				n[cot][1]++;//记录幂次
				a=a/i;
			}
		}
	}
	if(a!=1)//可能a仍为因子
	{
		cot++;
		n[cot][0]=a;
		n[cot][1]=1;
	}
	for(int i=1;i<=cot;i++)
	{
		ans=ans*sum(n[i][0],n[i][1])%mod;
	}
	printf("%d\n",(ans%mod+mod)%mod);
	return 0;
}
```
有用的话点个赞顶上去才能让更多人看到哦QAQ

---

## 作者：小老虎3018 (赞：53)

题意即求 $a^b$ 的所有因子（包括 $1$ 以及 $a,a^b$ 等）的和 $\mathbf{res}$ ，暴力枚举在这么大的范围下显然行不通，则可以考虑分解质因子，然后求和。

$$a^b=p_1^{c_1}\cdot p_2^{c_2}\cdot  p_3^{c_3}\cdots  p_n^{c_n} \to $$
$$res=(1+p_1^{1}+p_1^{2}+\cdots+p_1^{c_1})\cdot(1+p_2^{1}+p_2^{2}+\cdots+p_2^{c_2})\cdots(1+p_n^{1}+p_n^{2}+\cdots+p_n^{c_n})$$

为什么？可以拆括号求证。对于 $6^2=2^2\cdot3^2$ 而言，共有 $1,2,3,4,6,9,12,18,36$ 这几个因子，则：
$$res=(1+2+2^2)\cdot(1+3+3^2)=1+3+9+2+6+18+4+12+36$$

那么现在就只需要选择时间复杂度更小的算法，解决取模问题。

可以发现结果的每个因式都是等比数列的和，则使用$S_n=\frac{a_1\cdot(1-q^n)}{1-q}=(p_i^{c_i+1}-1)/(p_i-1)$和快速幂、逆元求和。

 - $\mathbf{S_n}$是等比数列求和公式，高中必修五内容，建议提前了解。（$a_1$ 为首项，$n$ 为项数，$q$ 为公差）
 
 - **快速幂**可快速算底数的N次幂，其时间复杂度为 $\Theta(logN)$ ，矩阵快速幂，倍增快速幂均可。
 
 - **逆元**：
 
 设 $c$ 为 $b$ 的逆元（在 $b$ 与 $P$ 互质的情况下），则有 $b\cdot c \equiv 1~\pmod P$ ，记为 $c=b^{-1}$ .
 
 那么 $(a/b)\%P=(a\cdot c)\%P$ .
 
 可以使用扩展欧几里得，费马小定理或线性递推法求解。扩欧一般而言会快一点，然而通过费马可以推出 $$b^{P-1}\equiv 1~~\to~~b^{P-2}\equiv b^{-1} \pmod P~~\to~~b^{-1}=b^{P-2}$$
 那就一起用快速幂可以算啊 233
 
然后，就可以愉快地开始写代码了

***
真的吗？[看这里](https://www.luogu.org/discuss/show?postid=52258) [以及这里](https://www.luogu.org/discuss/show?postid=52497)

再看一下逆元的性质orz：
>在 $b$ 与 $P$ 互质的情况下

然后你就可以发现，$p_i$ 与 $9901$ 互质时求出来的逆元很奇怪，比如为 $0$（因为它并不存在）

那又该怎么办？回到最开始的结果式，可以发现$(1+p_i^{1}+p_i^{2}+\cdots+p_i^{c_i})\%P=(1+1+1+\cdots+1)=c_i+1$ ，特判即可。

下面就是**真的**愉快代码时间

```cpp
#include<cstdio>
#include<cmath>
#define MOD 9901
using namespace std;
//typedef long long ll;
long long mod=0,to[2],get=1;

ll ppo(ll x,ll p){//快速幂
    ll t=x,res=1;
    while(p){
        if(p&1)res=(res*t)%MOD;
        t=(t*t)%MOD;
        p>>=1;
    }
    return res;
}

int main(){
    long long a,b,tmp,lim;
    scanf("%lld%lld",&a,&b);
    lim=sqrt(a);
    for(ll i=2;i<=lim;i++){//2->当前需要分解的数
        if(!(a%i)){
            tmp=0;
            while(!(a%i)){a/=i;tmp++;}
            to[1]=(tmp*b+1);
            if(i%MOD==1)get=get*(tmp+1)%MOD;
            else {to[0]=i%MOD;get=get*(ppo(to[0],to[1])-1)*ppo(to[0]-1,MOD-2)%MOD;}
        }
    }
    if(a!=1){//剩下的较大质因数
        to[1]=(b+1);
        if(a%MOD==1)get=get*(b+1)%MOD;
        else{to[0]=a%MOD;get=get*(ppo(to[0],to[1])-1)*ppo(to[0]-1,MOD-2)%MOD;}
    }
    printf("%lld",get);
    return 0;
}
```

---

## 作者：Leap_Frog (赞：50)

看了看楼上和楼下的代码，感觉都挺复杂的。  

实际上这题并不需要那么长的代码。12 行就够了QwQ。  

### Solution
要求 $a^b$ 的因子和。  

首先，我们有一个结论。  

假设一个数 $a=a_1^{p_1}\times a_2^{p_2}\times...\times a_n^{p_n}$  
那么它的因子之和为 $(1+a_1+a_1^2+...+a_1^{p_1})\times(1+a_2+...+a_2^{p_2})\times...\times(1+a_n+...+a_n^{p_n})$  

然后可以用等比数列求和公式变成 $\frac{a_1^{p_1+1}-1}{a_1-1}\times...\times\frac{a_n^{p_n+1}-1}{a_n-1}$

所以我们需要知道的是 $a_i^{p_i+1}-1$和$\frac{i}{a_i-1}$  

前面那个可以用裸的快速幂来求，后面那个可以用费马小定理来求。  

那么 $a^b$ 也是一样的。  

$a=a_1^{p_1}\times a_2^{p_2}\times...\times a_n^{p_n}$，那么 $a^b=a_1^{p_1\times b}\times...\times a_n^{p_n\times b}$  

~~然后这题就做完了。~~  

[做完个*](https://www.luogu.com.cn/record/29826486)  

可怜的笔者就这样写了一份这样的代码，结果WA2个点。  

然后笔者就翻了翻，翻到了之前的一个[帖子](https://www.luogu.com.cn/discuss/show/151677)  

所以关于上面那个费马小定理来求逆元的那一部分，我们会发现 $a_i-1$ 不一定有逆元，这里需要有一个特判。  

然后这题就做完了。  

### Coding
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,b,s,e,P=9901;
inline int qpow(int x,int q=P-2) {int r=1;for(;q;q>>=1,x=x*x%P) if(q&1) r=r*x%P;return (r+P)%P;}
signed main()
{
    scanf("%lld%lld",&a,&b),s=1,e=sqrt(a);
    for(int i=2,t=0;i<=e;i++,t=0) {while(a%i==0) a/=i,t++;t*=b,s=s*(i%P!=1?(qpow(i,t+1)-1)%P*qpow(i-1)%P:(t+1)%P)%P;}
    if(a>1) s=s*(a%P!=1?(qpow(a,b+1)-1)%P*qpow(a-1)%P:2);
    return printf("%lld\n",(s+P)%P),0;
}
```

轻微压行，勿喷![](https://upload.orzsiyuan.com/images/emotions/kk.png)  

---

## 作者：wyx__ (赞：26)

n质因数分解后写成$p1^{c1}* p2^{c2}* ...* pn^{cn}$

则因子和为$(p1^0+p1^1+...+p1^{c1})*(p2^0+p2^1+...+p2^{c2})$

$*...*(pn^0+pn^1+...+pn^{cn})$

接下来用分治法求等比数列和。

上代码：

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a,b,ans=1,mod=9901;
ll ksm(ll x,ll y){//快速幂
	ll res=1;
	while(y){
		if(y%2==1)res=res*x%mod;
		x=x*x%mod;
		y/=2;
	}
	return res;
}
ll sum(ll x,ll y){//等比数列和
	if(x==0)return 1;
	if(x%2==1)return sum(x/2,y)*(1+ksm(y,x/2+1))%mod;
    //偶数项，分两部分算（后半就是前半乘y^(x/2+1)）
	return (sum(x/2-1,y)*(1+ksm(y,x/2+1))+ksm(y,x/2))%mod;
    //奇数项，加上中间一项
  //因算了y^0，所以x%2==1是偶数项
}
int main (){
	cin>>a>>b;
	for(int i=2;i<=sqrt(a);i++){//质因数分解
		int c=0;
		while(a%i==0){
			a/=i;
			c++;
		}
		ans=ans*sum(c*b,i)%mod;
	}
	if(a!=1)
	ans=ans*sum(b,a)%mod;
	cout<<ans;
}
```


---

## 作者：JOHNKRAM (赞：19)

众所周知，若n=p1^a1\*p2^a2\*...\*pk^ak，则n的因子和=(1+p1+p1^2+...+p1^a1)(1+p2+p2^2+...+p2^a2)...(1+pk+pk^2+...+pk^ak)

先把x做质因数分解，再把每一项系数乘上y，最后套公式即可。

注意，系数仍然很高，所以得使用矩阵快速幂。

至于是什么矩阵，自己想吧。


---

## 作者：ZBHRuaRua (赞：12)

对于逆元做法其实没有太多可说的，今天我一定要写这篇题解是想让各位在洛谷通过而在某知名oj无法通过的人说错在哪了，请看注释。
同时这也是一种hack思路，我谷这道题还没有这种数据点

```
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const long long mod=9901;
long long A,B;
long long prime[500];
long long cnt;
long long ansA=1;
long long ansB=1;
long long geshu[500];
inline void div(long long x)
{
	for(long long i=2;i<=sqrt(x+1);i++)
	{
		if(x%i==0)
		{
			prime[++cnt]=i;
			while(x%i==0)
			{
				geshu[cnt]++;
				x/=i;
			}
		}
	}
	if(x>1)
	{
		prime[++cnt]=x;
		geshu[cnt]=1;
	}
	return;
}
inline long long mul(long long x,long long y)
{
	long long res=0;
	while(y)
	{
		if(y&1)
		{
			res=(res+x)%mod;
		}
		x=(x+x)%mod;
		y>>=1;
	}
	return res%mod;
}
inline long long quickpow(long long x,long long tim)
{
	long long res=1;
	while(tim)
	{
		if(tim&1)
		{
			res=mul(res,x);
		}
		x=mul(x,x);
		tim>>=1;
	}
	return res%mod;
}
int main()
{
	scanf("%lld%lld",&A,&B);
/*	if(A==0)
	{
		cout<<"0"<<endl;
		return 0;
	}*/																			
	div(A);
	for(long long i=1;i<=cnt;i++)
	{
		if((prime[i]-1)%mod==0)
		{
			ansB=(ansB*((geshu[i]*B+1)%mod))%mod;
			continue;	
		}
		ansA=(quickpow(prime[i],geshu[i]*B+1)+mod-1)%mod;//就是这里！！如果prime%mod==0的话 这里quickpow会返回0，那么ansA就变成-1了，所以要+mod，卡这个的数据挺难出的，但是出了就能恶心人。
		ansB=(((ansB*ansA)%mod)*(quickpow(prime[i]-1,mod-2)))%mod;
	}
	cout<<ansB<<endl;
	return 0;
}
```


---

## 作者：FLASH_CM (赞：12)

### 【算法思路】
对于每一个正整数n：

质因数分解后可以写成n=a1^k1*a2^k2*……*ai^ki

所求的数的因数和f(n)就等于f(n)=(1+a1+a1^2+……+a1^k1)*(1+a2+a2^2+……+a2^k2)*……*(1+ai+ai^2+……+ai^ki)

然后根据等比数列求和
    f(n)=(a1^(k1+1)-1)/(a1-1)*(a2^(k2+1)-1)/(a2-1)*……*(ai^(ki+1)-1)/(ai-1)
### 【算法分析】
#### 步骤一：底数拆分
我们首先将底数拆分成a1^k1*a2^k2*……*ai^ki的形式，通过不断的试除并除尽，以保证得到的均为质因数（cnt表示当前拆分出的质因数的序数，prim[i]表示拆分出的第i个质因数，tim[i]表示拆分出的第i个质因数的数目）
```cpp
inline void chai(){
	for(long long i=2;i*i<=n;i=-~i){
		if(n%i==0){
			prim[++cnt]=i;
			while(n%i==0){
				n/=i;
				tim[cnt]++;
			}
		}
	}
}
```

然后将每一个质因数的数目都乘上m，以确保所有质因数的积等于原先的幂的大小（因为开头没有计算幂）
```cpp
	for(register int i=1;i<=cnt;i=-~i){
		tim[i]*=m;
	}
```
#### 步骤二：计算每一个质因数产生的和
我们从找到的第一个质因数开始，枚举每一个质因数
```cpp
	for(register int i=1;i<=cnt;i=-~i){
		work(prim[i],tim[i]);
	}
```
统计它们对结果产生的影响值
```cpp
inline void work(long long a,long long b){
	a%=mod;
	long long now=0,k=b%mod/(mod-1),res=b%(mod-1);
	if(k)
		for(long long i=0;i<mod;i++)
			now=(now+(ksm(a,i)))%mod;
	for(long long i=0;i<=res;i++)
		now=(now+ksm(a,i))%mod;
	ans=ans*now%mod;
}
```
为了节省时间，我们在中间使用快速幂
```cpp
inline long long ksm(long long x,long long k){		//快速幂计算x的k次方 
	long long tot=1;
	while(k){
		if(k%2==1)
			tot=tot*x%mod;
		x=x*x%mod;
		k/=2;
	}
	return tot;
}
```
#### 步骤三：输出答案
### 【注意事项】
1、由于数据非常大，我们需要在每一步运算时都不断的对答案取模。

2、为了防止在运算过程中超出运算范围，建议将变量定义成long long型。

**3、在拆分底数时，由于部分数据的底数是由一个很大的质数（它的平方已经超出原数）和一些较小的质数相乘得到，所以我们在拆分完后还需要加入一些判断来确保原先的底数已经完全拆分完毕。**
```cpp
	if(n!=1){
		cnt++;
		prim[cnt]=n;
		tim[cnt]++;
	}
```
#### 综上所述，代码如下：
### 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1000005,mod=9901;

int cnt;
long long n,m,ans=1,prim[maxn],tim[maxn];

inline void chai(){
	for(long long i=2;i*i<=n;i=-~i){
		if(n%i==0){
			prim[++cnt]=i;
			while(n%i==0){
				n/=i;
				tim[cnt]++;
			}
		}
	}
	if(n!=1){
		cnt++;
		prim[cnt]=n;
		tim[cnt]++;
	}
}

inline long long ksm(long long x,long long k){//快速幂计算x的k次方 
	long long tot=1;
	while(k){
		if(k%2==1)
			tot=tot*x%mod;
		x=x*x%mod;
		k/=2;
	}
	return tot;
}

inline void work(long long a,long long b){
	a%=mod;
	long long now=0,k=b%mod/(mod-1),res=b%(mod-1);
	if(k)
		for(long long i=0;i<mod;i++)
			now=(now+(ksm(a,i)))%mod;
	for(long long i=0;i<=res;i++)
		now=(now+ksm(a,i))%mod;
	ans=ans*now%mod;
}

int main(){
	scanf("%lld%lld",&n,&m);
	chai();
	for(register int i=1;i<=cnt;i=-~i){
		tim[i]*=m;
		work(prim[i],tim[i]);
	}
	ans%=mod;
	printf("%lld\n",ans);
	return 0;
}
```
友情链接：感谢 [CZF](https://www.luogu.org/space/show?uid=21082) 给本人提供的代码参考

---

## 作者：7wwwwth (赞：11)

发现很多题解是不是都是加强数据之前的啊，对于之后更新的两组数据不加特判的过不了的。由于逆元的性质决定了（在b与p互质的情况下）但是讨论里提出了要求逆元的数完全可以是9901的倍数，那么这时候就需要一个特判。再利用等比数列，这个题就可以过啦。
特判代码：
```cpp
if(i%p==1) ans=ans*(cnt[a]+1)%p;
```
全代码：
```
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
long long bg,bl;
long long f[10005],a,b,p=9901;
long long cnt[10005];
long long ans=1;

long long ppow (long long a,long long b){
	long long r=1,base=a;
	while(b){
		if(b&1) r=(base*r)%p;
		base=(base*base)%p;
		b>>=1;
	}
	return r;
}

long long ga(int i){
	return ppow(i,p-2)%p;
}

void sp(){
	for(long long i=2;i<=bg;i++){
		if(bg%i==0){
			cnt[a]=0;
			while(bg%i==0) cnt[a]++,bg/=i; 
			if(i%p==1) ans=ans*(cnt[a]+1)%p;
			else ans=ans*((ppow(i,cnt[a]*bl+1)-1)*ga(i-1))%p;
		}
	}
}

int main(){
	cin>>bg>>bl;
	sp();
	cout<<ans;
}
```
oh对了 还要就得每步取膜的问题，要不还是有数据点过不去的。
~~我才不会告诉你我开始想直接把讨论里的两个数据特判过了这个题~~

---

## 作者：HPXXZYY (赞：4)


【题意】：
- 给定 $a,b$，求 $a^b$ 的所有因子的和对 $9901$ 取模的值，即求：

  $$\sum\limits_{i=1}^{a^b} i(i|a^b)\mod 9901$$

- 数据范围：$1 \leq a,b \leq 5 \times 10^7$。

---------------------------------------

【思路】： 记 $a= \prod\limits_{i=1}^{m} p_i^{k_i}$，其中 $p_i$ 是质数，$k_i\geq 0(1 \leq i \leq m)$。

那么，$a^b=\prod\limits_{i=1}^{m} p_i^{k_i \times b}$。由定理，答案 $\text{ans}=\prod\limits_{i=1}^{m} (\sum\limits_{j=0}^{k_i \times b}p_i^j)$。

直接算铁定不行，但是由费马小定理得，$a^{t-1} \equiv 1 \pmod t\ (t$是质数$)$ 。由题意，$p=9901$，于是我们可以算出 $\text{res=}\sum\limits_{j=0}^{p-2} p_i^j$。然后，因为后面的项一定与前面的某一项相等，于是我们可以令这个数列 $t-2$ 位为一个循环，于是我们可以直接由 $\text{res}$ 得到所有循环的总和。对于后面剩余的项，我们可以暴力得到。

举个例子，比如 $k_i \times b = 2 \times t$，我们可以求出 $\text{res=}\sum\limits_{j=0}^{p-2} p_i^j$，然后答案 $\text{ans = res}  \times 2 + \sum\limits_{\text{j=0}}^{3} \text{p}_{\text{i}}^j$。

时间复杂度没用等比数列优，但是需要的知识点少，比较好理解（至少个人认为如此）。

-------------------------------------

【代码】：
```cpp
const int mod=9901;
int calc(int x,long long t){
	int ret=1,ans=0;
	if (x==mod) return 1;
	else if (t<mod){
		for(int i=0;i<=t;i++){
			ans=(ans+ret)%mod;
			ret=(1ll*ret*x)%mod;
		}
	}
	else{
		for(int i=0;i<=mod-2;i++){
			ans=(ans+ret)%mod;
			ret=(1ll*ret*x)%mod;
		}
		ans=(1ll*ans*((t+1)/(mod-1)))%mod;
		for(int i=1;i<=(t+1)%(mod-1);i++){
			ans=(ans+ret)%mod;
			ret=(1ll*ret*x)%mod;
		}
	}
	return ans;
}
int ans=1,a,b,n;
int main(){
	scanf("%d%d",&a,&b);n=a;
	for(int i=2;1ll*i*i<=n;i++)
		if (n%i==0){
			register int ret=0;
			while (n%i==0){
				n/=i;ret++;
			}
			ans=(1ll*ans*calc(i,1ll*ret*b))%mod;
		}
	if (n>1) ans=(1ll*ans*calc(n,b))%mod;
	printf("%d",(ans+mod)%mod);
	return 0;
}
```

--------------------------------------

博客使用效果更佳： [https://blog.csdn.net/ZHUYINGYE_123456/article/details/104859275](https://blog.csdn.net/ZHUYINGYE_123456/article/details/104859275)

---

## 作者：太阳骑士 (赞：4)

先将$a$分解质因数，得：
$$p_1^{c_1}*p_2^{c_2}*p_3^{c_3}*……*p_n^{c_n}$$
则有$a^b$：
$$p_1^{c_1*b}*p_2^{c_2*b}*p_3^{c_3*b}*……*p_n^{c_n*b}$$
对于每个$p_i^{k_i}(k_i=c_i*b,i\in[1,n])$的约数有：$p_i^1,p_i^2……p_i^k$
所以：$$sum=\prod_{i=1}^{n}{\sum_{j=0}^{k}{p_i^j}}$$
于是我们可以写一个$GetSum(p,c)$来计算$\sum_{j=0}^{k}{p_i^j}$，为了减少复杂度，我们可以利用$c$的奇偶分$2$种情况处理。
第一种，为偶数：
$$GetSum(p,c)=(1+p^{c/2})*GetSum(p,c/2-1)+p^c$$
第二种，为奇数：
$$GetSum(p,c)=(1+p^{(c+1)/2})*GetSum(p,(c-1)/2)$$
最后，一定要开$long long！！！$
AC代码：
```cpp
#include<cstdio>
#define mod 9901
using namespace std;
typedef long long ll;
ll sum=1;
ll a,b,cnt;
ll p[50000],c[500];
void doit(){
	ll k=a;
	for(ll i=2;i*i<=k;i++)
		if(k%i==0){
			p[++cnt]=i;
			while(k%i==0){
				c[cnt]++;
				k/=i;
			}
		}
	if(k>1) p[++cnt]=k,c[cnt]++;
    for(ll i=1;i<=cnt;i++) c[i]*=b;
}
ll QuickPow(ll x,ll y){
	ll ret=1;
	while(y){
		if(y&1) ret=ret*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return ret;
}
ll GetSum(ll x,ll y){
	if(y==0) return 1;
	if(y%2==0) return (((1+QuickPow(x,y/2))%mod)*(GetSum(x,y/2-1)%mod)+QuickPow(x,y))%mod;
	else return ((1+QuickPow(x,(y+1)/2))%mod)*(GetSum(x,(y-1)/2)%mod)%mod;
}
int main(){
	scanf("%lld%lld",&a,&b);
	doit();
	for(ll i=1;i<=cnt;i++) sum=sum*GetSum(p[i],c[i])%mod;
	printf("%lld",sum);
	return 0;
}

```


---

## 作者：star_magic_young (赞：2)

首先我们看到这种因数问题,~~果断~~质因数分解

所以当前数$a=p_1^{k_1}*p_2^{k_2}...*p_m^{k_m}$

可得$a^b=p_1^{k_1*b}*p_2^{k_2*b}...*p_m^{k_m*b}$

考虑因数和,假设数$a$只有一个质因子$p_1$,则因数和为$\sum_{i=0}^{k_1}{p_1}^i$

如果有第二个质因子$p_2$则因数和为$\sum_{i=0}^{k_1}({p_1}^i*\sum_{j=0}^{k_2}{p_2}^j)=(\sum_{i=0}^{k_1}{p_1}^i)*(\sum_{j=0}^{k_2}{p_2}^j)$

以此类推,我们要求的因数之和~~显然~~为$\prod_{i=1}^m \sum_{j=0}^{k_i}{p_i}^j$

至于后面那一段怎么求,先令$f_i=\sum_{j=0}^{i}p^j$

可以发现$f_{i+1}=\sum_{j=0}^{i+1}p^j=p*(\sum_{j=0}^{i}p^j)+1=p*f_i+1$

然后就可以偷税的使用矩乘了(如果不会请*参考*[这题](https://www.luogu.org/problemnew/show/P2044))

代码如下

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#define LL long long
#define il inline
#define re register

using namespace std;
const LL mod=9901;
il LL rd()
{
    re LL x=0,w=1;re char ch;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*w;
}
struct mrtx
{
  LL a[2][2];
  mrtx(){memset(a,0,sizeof(a));}
}a,b;
il mrtx mlt(mrtx a,mrtx b)
{
  mrtx c;
  for(int i=0;i<=1;i++)
    for(int j=0;j<=1;j++)
      for(int k=0;k<=1;k++)
	    c.a[i][j]=(c.a[i][j]+(a.a[i][k]*b.a[k][j])%mod)%mod;
  return c;
}
il mrtx ksm(mrtx a,mrtx b,LL bb)    //这里直接把转移矩阵乘到初始矩阵上去
{
  while(bb)
    {
      if(bb&1) a=mlt(a,b);
      b=mlt(b,b);
      bb>>=1;
    }
  return a;
}
LL p[20][2],tt,n,m,ans=1;

int main()
{
  n=rd(),m=rd();
  int srt=sqrt(n);
  for(int i=2;i<=srt;i++)
    {
      if(n%i!=0) continue;
      p[++tt][0]=i;
      while(n%i==0) ++p[tt][1],n/=i;
    }
  if(n>1) p[++tt][0]=n,p[tt][1]=1;
  a.a[0][0]=a.a[0][1]=1,b.a[1][0]=b.a[1][1]=1;
  for(int i=1;i<=tt;i++)
    {
      p[i][1]*=m;
      b.a[0][0]=p[i][0];
      ans=(ans*ksm(a,b,p[i][1]).a[0][0])%mod;
    }
  printf("%lld\n",ans);
  return 0;
}

```

---

## 作者：玫葵之蝶 (赞：2)

##用逆元的看这里！

还是和前面几个一样：

![](http://img.blog.csdn.net/20170914203230797?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3RvbmU0MTEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

因为要取模，所以除法要换成逆元，然后我就愉快地写完交了上去，60分，4个WA，发现，逆元求出来之后可以是负的，也可以是零，于是就加了这么一个特判：

if(num2<=0)num2+=p;（其中num2是我求的逆元，p是模数）

然后就AC了，根本不需要他们说的什么奇怪的逆元方式。。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<queue>
#define ll long long
using namespace std;
ll ksm(ll a,ll b,ll p){
    ll ans=1;
    a%=p;
    while(b){
        if(b&1){
            ans=(ans*a)%p;
        }
        a=(a*a)%p;
        b>>=1;
    }
    return ans;
}
const ll p=9901;
ll a,b;
ll prime[100000];
ll e[100000];
int cnt;
int main(){
    scanf("%lld %lld",&a,&b);
    for(ll i=2;i*i<=a;i++){
        if(a%i==0){
            prime[++cnt]=i;
            while(a%i==0){
                a/=i;
                e[cnt]++;
            }
            e[cnt]*=b;
        }
    }
    if(a!=1){
        prime[++cnt]=a;
        e[cnt]++;
        e[cnt]*=b;
    }
    ll ans=1;
    for(int i=1;i<=cnt;i++){
        ll num=(ksm(prime[i],e[i]+1,p)-1+p)%p;
        ll num2=ksm(prime[i]-1,p-2,p)%p;
        if(num2<=0)num2+=p;
        ans*=num*num2%p;
        ans%=p;
    }
    printf("%lld",(ans+p)%p);
    return 0;
}
```

---

## 作者：DANNIEL (赞：2)

```cpp
program Project1;
const inf=9901;
var a,b,i,ans,sum:longint;
function work(x,y:longint):longint;
var t,tot:longint;
begin
   t:=x; tot:=1;
   while y>0 do
    begin
      if odd(y) then tot:=tot*t mod inf;
      y:=y div 2;
      t:=t*t mod inf;
    end;
    exit(tot);
end;             //快速幂
function calc(p,c:longint):longint;
begin
  if c=0 then exit(1);
  if c mod 2=0 then  calc:=((work(p,c div 2)+1)*calc(p,c div 2-1)
                                  +work(p,c) )mod inf
    else calc:=((work(p,(c+1) div 2)+1)*calc(p,(c-1) div 2)) mod inf
end;   // 递归求等比数列和
begin
  readln(a,b);
  i:=2;
  sum:=0; ans:=1;
    while i<=a do
     begin
       while a mod i =0 do
        begin
          inc(sum);
          a:=a div i;
        end;
       ans:=(ans*calc(i mod inf,sum*b)) mod inf;
       writeln(i,' ',sum);  //调试步骤
       inc(i);
       sum:=0;
     end;
    writeln(ans);  readln;
end.
```
把A分解质因数，表示为p1^c1 × p2^c2 ×……× pn^cn
∴A^B表示为p1^(c1\*B) × p2^(c2\*B) ×……× pn^(cn\*B)

∴A^B的约数表示为p1^k1 × p2^k2 ×……× pn^kn，其中0<=ki<=ci\*B

∴式子 (1+p1+p1^2+……+p1^(c1\*B)) × (1+p2+p2^2+……+p2^(c2\*B)) ×……× (1+pn+pn^2+……+pn^(cn\*B)) 展开之后就是所有约数之和

下面的任务就是对上式的每一个括号进行等比数列求和(mod 9901)


等比数列求和可以用乘法逆元......但本蒻驹不会......

所以用递归，设calc(p,c)=1+p^1+p^2+......+p^n

可得当n=偶数时    calc=(p^(c/2))\*calc(p,c/2-1)+p^c

当n=奇数时    calc=（p^(c+1/2)+1）\*calc(p,(c-1)/2)


---

## 作者：xayata_ (赞：2)

$Answer = A ^ B $ 的因子之和

将 $A$ 进行质因数分解
$A = p_1 ^ {a_1} P_2 ^ {a_2} p_3 ^ {a_3} \cdots p_k ^ {a_k}$

$A ^ B = p_1 ^ {a_1 * B} P_2 ^ {a_2 * B} p_3 ^ {a_3 * B} \cdots p_k ^ {a_k * B}$

考虑对于每一个质因数$p_i$ 会以任意指数的形式与任意指数形式的 $p_j$相乘得到一个因数
当然指数要在范围内

所以 $Answer = (1 + p_1 + p_1 ^ 2 + \cdots p_1 ^ {a_{k_1}} ) * (1 + p_2 + p_2 ^ 2 + \cdots p_2 ^ {a_{k_2}}) * \cdots (1 + p_k + p_k ^ 2 + \cdots \ p_k ^ {a_{k_k}})$

考虑等式 $T = 1 + p + p ^ 2 + p ^ 3 + \cdots p^k$
有等比数列求和公式
$T = \frac{p ^ {k + 1} - 1} {p - 1}$

快速幂 + 逆元

---

## 作者：Mychael (赞：2)

数学渣不会矩阵的做法QAQ


但似乎有一种更加简便的方法：**等比数列前N项和**


像楼下所说，将a进行质因数分解，将每个质因子的指数乘上b，最后的答案【p表示质因子,a表示最高次】

ans=(1+p1^1+p1^2+......+p1^a1)(1+p2^1+p2^2+......+p2^a2)(1+p3^1+p3^2+......+p3^a3)......(1+pn^1+pn^2+......+pn^an)


发现没有，每一个括号里就是等比数列的前N项和=(1-q^n)/(1-q)【q为公比】

由于涉及取模，除法要用逆元






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long int
using namespace std;
const int maxn=10005,INF=2000000000,P=9901;
LL fac[maxn],cnt[maxn],faci=0,A,B;
inline LL qpow(LL a,LL b){  //快速幂
    LL ans=1;
    for(;b;b>>=1,a=a*a%P) if(b&1) ans=ans*a%P;
    return ans;
}
inline LL inverse(int i){return qpow(i,P-2)%P;}   //逆元
int main(){
    LL ans=1;
    cin>>A>>B;
    for(int i=2;i<=A;i++){        //质因子分解
        if(A%i==0){
            fac[++faci]=i;
            while(A%i==0) cnt[faci]++,A/=i;
            ans=ans*((qpow(i,cnt[faci]*B+1)-1)*inverse(i-1))%P;   //等比数列求和
        }
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：BFSBFSBFSBFS (赞：1)

~~(为何现在pas自带4MB常数式内存...).~~.

补上矩乘题解吧..

多项式展开其他人讲的很清楚了..

构造矩阵:
```

[累积和 当前项] * [某矩阵..].

0 1     1 0 ^y 
     * (   )
        1 p
        
[a]     [b].

//p是分解的因数..
//y是p的个数*s+1.
//答案为a[1,1].
```
所有因数做1遍乘起来..没了...

Diu代码..
```
program P1593;
 type
  wa=array[1..2,1..2] of longint;
 const
  d:wa=((0,0),(0,0));
  e:wa=((1,0),(0,1));
 var
  a,b,c:wa;
  i,x,y,s,t,mot,ssum:longint;
 operator *(x,y:wa)z:wa;
  var
   i,j,k:longint;
  begin
   z:=d;
   for i:=1 to 2 do
    for j:=1 to 2 do
     for k:=1 to 2 do
      z[i,j]:=(z[i,j]+x[i,k]*y[k,j]) mod mot;
  end;
 function hahaksm(x:wa;y:int64):wa;        //矩阵快速幂.
  begin
   hahaksm:=e;
   while y>0 do
    begin
     if y and 1=1 then hahaksm:=hahaksm*x;
     x:=x*x;
     y:=y>>1;
    end;
  end;
 procedure haharandize;
  begin
   mot:=9901;
   b[1,1]:=1;
   b[2,1]:=1;
   b[1,2]:=0;
   a[1,1]:=0;
   a[1,2]:=1;
   ssum:=1;
  end;
 procedure hahadiv(k:longint);
  begin
   t:=0;
   while x mod k=0 do            //统计a的因数..
    begin
     inc(t);
     x:=x div k;
    end;
   b[2,2]:=k;
   c:=a*hahaksm(b,int64(t)*y+1); //求和.
   ssum:=ssum*c[1,1] mod mot;
  end;
 begin
  haharandize;
  readln(x,y);
  for i:=2 to trunc(sqrt(x)) do
   if x mod i=0 then hahadiv(i); //因数分解.
  if x>1 then hahadiv(x);
  writeln(ssum);
 end.
```
(ಡωಡ).


---

## 作者：Npse_D (赞：0)

楼下题解说费马小定理会WA，貌似并不，而且好像也没有WA的理由。壮哉我大飞马小定理，做数论题从来不需要写新的代码，直接用快速幂。

这题做法挺显然的，是使用所有质因子等比数列求和再相乘，这种在考场都可以自己推出来。

用vector是为了加速。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int modd=9901;
long long int a,b,ans;
int prime_list[10005];
bool dis[500000];
vector<int>prime_num; 
long long int fastpow(long long int x,long long int y){
    if(y==1)return x;
    long long int r=1,base=x;
    while(y){
        if(y&1)r=r%modd*(base%modd)%modd;
        base=base%modd*base%modd;
        y>>=1;
    }
    return r;
}
int main(){
    cin>>a>>b;
    for(int i=2;i<=sqrt(a)+1;i++){
        if(a%i==0){
            a/=i;
            prime_list[i]++;
            if(!dis[i])prime_num.push_back(i);
            dis[i]=1;
            i--;
        }
    }
    if(a!=1)prime_num.push_back(a);//a为唯一大质数 
    ans=1;
    for(int i=0;i<prime_num.size();i++)
            if(prime_num[i]==a)ans=ans*(a%modd*(fastpow(a,b)-1)%modd*(fastpow(a-1,modd-2)%modd)%modd+1)%modd;//%modd
            else ans=ans*(prime_num[i]%modd*((fastpow(prime_num[i],b*prime_list[prime_num[i]])-1)%modd)%modd*(fastpow(prime_num[i]-1,modd-2)%modd)%modd+1)%modd;
    cout<<ans;
}    
//等比数列求和公式：a1*（1-q^n)/(1-q)
```

---

## 作者：Kelin (赞：0)

有个数论函数是σ(n)=∑(d|n)d 就是n的约数和

楼下已经讲了σ(A^B)=π(pi+pi^2+...+pi^(ki\*B))=π(pi^(ki\*B+1)-1)/(pi-1) 等比数列求和

又有a/b mod c=(a mod(b\*c))/b

为什么这么做？直接逆元||费马小定理会不好多的多吗？
但是实际上会wa(luogu我不知道 有兴趣可以去poj1845测一下)

∴σ(A^B)%P=π(pi^(ki\*B+1)%(P\*(pi-1))-1)/(pi-1)%P

```cpp
#include<cstdio>
#include<cmath>
#define re register int
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
typedef long long ll;
const int P=9901;
ll n,m,ans=1,sum,Mod;
inline ll mulMod(ll a,ll b){
    ll ans=a*b-Mod*(ll)((long double)a/Mod*b+0.5);
    return ans<0?ans+Mod:ans;
}
inline ll powMod(ll a,ll b){
    ll x=1;a%=Mod;
    for(;b;b>>=1,a=mulMod(a,a))if(b&1)x=mulMod(a,x);
    return x;
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(re i=2,ii=sqrt(n);i<=ii&&i*i<=n;++i){
        if(n%i)continue;
        sum=0;while(n%i==0)++sum,n/=i;
        Mod=P*(i-1);
        ans=(ans*((powMod(i,sum*m+1)-1)/(i-1)))%P;
    }
    if(n>1)Mod=P*(n-1),ans=(ans*((powMod(n,m+1)-1)/(n-1)))%P;
    printf("%lld",ans);
return 0;
}
```

---

## 作者：魍魉° (赞：0)

把A分解质因数，表示为p1^c1 × p2^c2 ×……× pn^cn

∴A^B表示为p1^(c1\*B) × p2^(c2\*B) ×……× pn^(cn\*B)

∴A^B的约数表示为p1^k1 × p2^k2 ×……× pn^kn，其中0<=ki<=ci\*B

∴式子 (1+p1+p1^2+……+p1^(c1\*B)) × (1+p2+p2^2+……+p2^(c2\*B)) ×……× (1+pn+pn^2+……+pn^(cn\*B)) 展开之后就是所有约数之和

下面的任务就是对上式的每一个括号进行等比数列求和(mod 9901)

 ![](https://cdn.luogu.com.cn/upload/pic/6201.png) 



---


# 小朋友的球

## 题目描述

@发源于 小朋友最近特别喜欢球。有一天他脑子抽了，从口袋里拿出了 $N$ 个不同的球，想把它们放到 $M$ 个相同的盒子里，并且要求每个盒子中至少要有一个球，他好奇有几种放法，于是尝试编程实现，但由于他天天不好好学习，只会上 B 站看游泳教练，于是他向你求助。

## 说明/提示

- 对于 $20\%$ 的数据，满足 $N,M \leq 10$；
- 对于 $100\%$ 的数据，满足 $1 \leq N,M \leq 100$，一个测试文件最多有 $10$ 组测试数据。


## 样例 #1

### 输入

```
4 2
1 1```

### 输出

```
7
1```

# 题解

## 作者：Heartlessly (赞：24)

## 算法分析

- 简单的动态规划，但是要加上高精度运算，不然只能得 $20$ 分。本题和 **[放苹果](https://www.luogu.org/problem/show?pid=2386)** 有些类似，但是盒子不能空着不放，也就是楼下所说的 **Stirling数**，应用于组合数学领域

- ### 状态转移方程：$f[i][j]=f[i-1][j-1]+f[i-1][j]\times j$

## 示例代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int L = 1001;//调整字符串长度，本题1000足矣
string add(string a,string b)//只限两个非负整数相加
{
    string ans;
    int na[L]={0},nb[L]={0};
    int la=a.size(),lb=b.size();
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';
    return ans;
}
int na[L];
string mul(string a,int b)//高精度a乘单精度b模板
{
    string ans;
    int La=a.size();
    fill(na,na+L,0);
    for(int i=La-1;i>=0;i--) na[La-i-1]=a[i]-'0';
    int w=0;
    for(int i=0;i<La;i++) na[i]=na[i]*b+w,w=na[i]/10,na[i]=na[i]%10;
    while(w) na[La++]=w%10,w/=10;
    La--;
    while(La>=0) ans+=na[La--]+'0';
    return ans;
}
int n, m;
string f[101][101];
int main(){
    for ( int i = 1; i <= 100; i++ )
    f[i][1] = "1";//初始化，一个盒子（m=1）的时候只有一种放法
    for ( int i = 2; i <= 100; i++ )
    for ( int j = 1; j <= i; j++ )
    f[i][j] = add ( f[i-1][j-1], mul ( f[i-1][j], j ) );//带上高精度运算的状态转移
    while ( cin >> n >> m ){
        if ( n < m ) printf ( "0\n" );//特判输出0
        else cout << f[n][m] << endl;//输出每个n，m对应的答案f[n][m]
    }
    return 0;//华丽落幕
}
```

---

## 作者：Drifting (赞：18)

## 题目大意：

将一个有 $n$ 个元素的集合分成 $m$ 个非空的集合，求方案数。

## 思路 

显然这就是斯特灵数的定义。题目其实就是在让你求斯特灵数 $S(n,m)$;

[斯特灵数](https://zh.wikipedia.org/wiki/%E6%96%AF%E7%89%B9%E7%81%B5%E6%95%B0)

但是这个题不写高精会凉掉，所以：

### 人生苦短，我选Python！

```python
MAXN = 405
S = [[0] * MAXN for i in range(MAXN)] # 定义一个二维列表(二位数组)
for i in range(1, MAXN):
	S[i][i] = S[i][1] = 1
	for j in range(2, i):
		S[i][j] = S[i - 1][j - 1] + j * S[i - 1][j]
while True:		# 多组数据
    try:
        n, m = map(int,input().split())
        print(S[n][m])
    except EOFError:
        break
```

---

## 作者：HPXXZYY (赞：7)

一、预备算法：

**1、组合数学**

**2、动态规划（dp）**

**3、高精度**

二、思路：

1、根据**第二类Stirling数**公式可得动态转移方程$f[i][j]=f[i-1][j-1]+f[i-1][j]\times j$（$f[i][j]$表示有$i$个不同的球，放入$j$个不同的盒子的方法数）

2、但是有些$f[i][j]$可能会爆$long$ $long$，所以要用高精度

三、代码+一定的解释：
```cpp
#define init(a,b) memset(a,b,sizeof(a))
struct node{
	int len,num[1100];
	node(){
		len=0;init(num,0);
	}
	node operator + (node a){
		register node c;
		register int x=0,i;
		c.len=max(this->len,a.len);
		for(i=1;i<=c.len;i++){
			c.num[i]=a.num[i]+this->num[i]+x;
			x=c.num[i]/10;c.num[i]%=10;
		}
		if (x) c.num[++c.len]=x;
		return c;
	}
    //重定义+，让它可以进行高精度加法
	node operator * (int a){
		register node c=*this;
		register int x=0,i;
		for(i=1;i<=c.len;i++){
			c.num[i]=c.num[i]*a+x;
			x=c.num[i]/10;c.num[i]%=10;
		}
		while (x){
			c.num[++c.len]=x%10;x/=10;
		}
		return c;
	}
    //重定义*，让它可以进行高精度乘法
	void write(){
		for(int i=len;i;i--)
		printf("%d",num[i]);
		printf("\n");
	}
    //输出此高精度数字
}f[110][110];
int n,m,i,j;
int main(){
	freopen("t1.in","r",stdin);
	for(i=1;i<101;i++){
		f[i][1].len=1;
		f[i][1].num[1]=1;
//		相当于f[i][1]=1;
	}
	for(i=2;i<101;i++)
	for(j=1;j<=i;j++)
	f[i][j]=f[i-1][j-1]+(f[i-1][j]*j);
    //主要dp过程
	while (~scanf("%d%d",&n,&m)){
		if (n<m) printf("0\n");//特判
		else f[n][m].write();
	}
	return 0;
}
```
关于高精度：高精度有很多种实现的方法，在这里笔者最推荐的方法是像笔者本代码一样，提前定义好，到最后使用起来就像用$int$一样的方便。

关于本程序：本程序是不完整的，但是正确的，没有反作弊系统，仅仅是删除了头文件而已，不影响大家的阅读。

---

## 作者：ergeda (赞：6)

stirling数，递推公式s[i][j]=s[i-1][j]\*j+s[i-1][j-1]这个在各类组合数学书籍上均有证明,现截取一段

S(p,k)的一个组合学解释是：将p个物体划分成k个非空的不可辨别的（可以理解为盒子没有编号）集合的方法数。

k!S(p,k)是把p个人分进k间有差别(如：被标有房号）的房间(无空房）的方法数。

S(p,k)的递推公式是：S(p,k)=k\*S(p-1,k)+S(p-1,k-1) ,1<= k<=p-1

边界条件：S(p,p)=1 ,p>=0    S(p,0)=0 ,p>=1

递推关系的说明：

考虑第p个物品，p可以单独构成一个非空集合，此时前p-1个物品构成k-1个非空的不可辨别的集合，方法数为S(p-1,k-1)；

也可以前p-1种物品构成k个非空的不可辨别的集合，第p个物品放入任意一个中，这样有k\*S(p-1,k)种方法。

注意：当m>n||m==0时直接输出0,！！！因为这个wa了好多次
也就只要加上高精就行了，先贴上c++代码：

```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 999999999
#define For(i,a,b) for(i=a;i<=b;++i)
#define rep(i,a,b) for(i=a;i>=b;--i)
#define mm(a,b) memset(a,b,sizeof(a))
#define ll long long
using namespace std;
ll read(){
    ll sum=0,flag=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
    while(c>='0'&&c<='9')sum=sum*10+c-'0',c=getchar();
    return sum*flag;
}
ll maxx(ll x,ll y){
    if(x<y)return y;
    return x;
}
ll minn(ll x,ll y){
    if(x<y)return x;
    return y;
}
ll abss(ll x){
    if(x>=0)return x;
    return -x;
}
struct node{
    ll a[500],len;
    node(){mm(a,0);len=0;}//记得初始化
};
node t[111][111];
node operator + (node c,node d){
    node h;h.len=maxx(c.len,d.len);
    int i;
    for(i=1;i<=h.len;i++){
        h.a[i]+=c.a[i]+d.a[i];
        if(h.a[i]>=10){
            h.a[i+1]+=h.a[i]/10;
            h.a[i]%=10;
            if(i==h.len)h.len++;
        }
    }
    return h;
}
node operator * (node c,ll u){
    node h;h.len=c.len;
    int i;
    for(i=1;i<=h.len;i++){
        h.a[i]+=c.a[i]*u;
        if(h.a[i]>=10){
            h.a[i+1]+=h.a[i]/10;
            h.a[i]%=10;
            if(i==h.len)h.len++;
        }
    }
    return h;
}
int main(){
    ll i,j,m,n;
    For(i,1,100)t[i][0].a[1]=0,t[i][i].a[1]=t[i][1].a[1]=1,t[i][0].len=t[i][i].len=t[i][1].len=1;
    For(i,2,100){
        For(j,2,i-1){
            t[i][j]=t[i-1][j-1]+t[i-1][j]*j;
        }
    }
    while(scanf("%lld%lld",&m,&n)!=EOF){
        if(n==0||n>m){printf("0\n");continue;}
        rep(i,t[m][n].len,1)printf("%lld",t[m][n].a[i]);
        printf("\n");
    }    
    return 0;
}
```
/\*
附上一组数据：

100 30
6506288053843861997821187922633927431869469129371725189024935841681894639714880686192900322495541040401546012455480

\*/

---

## 作者：李若谷 (赞：4)

## 大整数类，运算符重载

我太菜了，不懂什么Stirling数，用DP的思想了推出的。

$f[i][j]$ 表示i个球，放入j个盒子的总数。

由于至少放一个，所以没有不放的情况。

那么$f[i][j]$只可能是两种情况。

第一种是第i个球放入一个新的盘子，由于有j个盘子，所以就是第i个球放入第j个盘子。也就是$f[i-1][j-1]$

第二种情况是第i个球放入已有的盘子，也就是1-j中任意一个盘子。总共有$f[i-1][j] * j$种情况。

所以 $f[i][j] = f[i-1][j] * j + f[i-1][j-1] $

这题要高精度，我直接用了大整数类。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
const int N = 101;
struct Wint:vector<int>//用标准库vector做基类，完美解决位数问题，同时更易于实现
{
    //将低精度转高精度的初始化，可以自动被编译器调用
    //因此无需单独写高精度数和低精度数的运算函数，十分方便
    Wint(int n=0)//默认初始化为0，但0的保存形式为空
    {
        push_back(n);
        check();
    }
    Wint& check()//在各类运算中经常用到的进位小函数，不妨内置
    {
        while(!empty()&&!back())pop_back();//去除最高位可能存在的0
        if(empty())return *this;
        for(int i=1; i<size(); ++i)
        {
            (*this)[i]+=(*this)[i-1]/10;
            (*this)[i-1]%=10;
        }
        while(back()>=10)
        {
            push_back(back()/10);
            (*this)[size()-2]%=10;
        }
        return *this;//为使用方便，将进位后的自身返回引用
    }
};
//输入输出
istream& operator>>(istream &is,Wint &n)
{
    string s;
    is>>s;
    n.clear();
    for(int i=s.size()-1; i>=0; --i)n.push_back(s[i]-'0');
        return is;
}
ostream& operator<<(ostream &os,const Wint &n)
{
    if(n.empty())os<<0;
    for(int i=n.size()-1; i>=0; --i)os<<n[i];
        return os;
}
Wint operator*(const Wint &a,const Wint &b)
    {
        Wint n;
        n.assign(a.size()+b.size()-1,0);
        for(int i=0; i!=a.size(); ++i)
            for(int j=0; j!=b.size(); ++j)
                n[i+j]+=a[i]*b[j];
            return n.check();
}
//加法，先实现+=，这样更简洁高效
Wint& operator+=(Wint &a,const Wint &b)
{
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0; i!=b.size(); ++i)a[i]+=b[i];
        return a.check();
}
Wint operator+(Wint a,const Wint &b)
{
    return a+=b;
}
Wint dp[N][N];
int main()
{
	int n,m;
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		dp[0][0] = 1;
		for(register int i=1;i<=n;i++)
		{
			for(register int j=1;j<=m;j++)
			{
				dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1];
			}
		}
		cout<<dp[n][m]<<endl;
	}
	return 0;
}
```

---

## 作者：fighter_OI (赞：4)

第二类string数。

递推式：用f[i,j]表示将前i个球放入j个盒子中

1. 将前i-1个球放入j个盒子里，再把第i个球任意放入一个盒子里

2. 将前i-1个球放入j-1个盒子里，再把第i个球单独放入一个盒子里

所以：

#f[i,j]=f[i-1,j-1]+j\*f[i-1,j]

我用了递归

加高精，OK

标程：

```cpp
type arr=array[0..500] of longint;
var n,m,i,j,k:longint;
    r1,r2,a:arr;
      f:array[0..100,0..100] of arr;
function max(a,b:longint):longint;
begin if a>b then exit(a);exit(b); end;
function jia(a,b:arr):arr;//高精度加法
var k,i:longint;
begin
 jia[0]:=max(a[0],b[0]);
 if a[0]<b[0] then for i:=a[0]+1 to b[0] do a[i]:=0 else for i:=b[0]+1 to a[0] do b[i]:=0;//为了这一行忙了一下午TAT
 k:=0;
 for i:=1 to jia[0] do
  begin
   jia[i]:=a[i]+b[i]+k;
   k:=jia[i] div 10;
   jia[i]:=jia[i] mod 10;
  end;
 if k>0 then begin inc(jia[0]); jia[jia[0]]:=k; end;
end;
function cheng(a:arr;b:longint):arr;//高精度乘法
var k,i:longint;
begin
 cheng[0]:=a[0];
 k:=0;
 for i:=1 to cheng[0] do
  begin
   cheng[i]:=a[i]*b+k;
   k:=cheng[i] div 10;
   cheng[i]:=cheng[i] mod 10;
  end;
 while k>0 do
  begin
   inc(cheng[0]);
   cheng[cheng[0]]:=k mod 10;
   k:=k div 10;
  end;
end;
function work(a,b:longint):arr;//递归求解
begin
 if a=b then begin f[a,b]:= r2; exit(r2); end;
 if a<b then  begin f[a,b]:= r1; exit(r1); end;
 if b<=0 then  begin f[a,b]:= r1; exit(r1); end;
 if not ((f[a,b][0]=1)and(f[a,b][1]=0)) then exit(f[a,b]);
 fillchar(f[a,b],sizeof(f[a,b]),0);
 f[a,b]:=jia(cheng(work(a-1,b),b),work(a-1,b-1));
 exit(f[a,b]);
end;
begin
 fillchar(r1,sizeof(r1),0);
 fillchar(r2,sizeof(r2),0);
 r1[0]:=1;
 r1[1]:=0;
 r2[0]:=1;
 r2[1]:=1;
 while not eof do begin
      readln(n,m);
      for i:=1 to n do
       for j:=1 to m do
        f[i,j]:=r1;
      a:=work(n,m);
      for i:=a[0] downto 1 do
       write(a[i]);
      writeln; end;
end.
```

---

## 作者：shenbear (赞：3)

第二类~~斯大林数~~斯特林数

第二类斯特林数适用于解决球不同，盒子相同，不能有空盒的情况

我们设f[i][j]表示i个球到j个盒子的方案数

**边界：f[0][0]=1**

### 转移：f[i][j]=f[i-1][j]*j+f[i-1][j-1]

怎么理解呢？

刚开始，0个球0个盒子，肯定就1种

如果你把i-1个球放入了j个盒子中，那么你现在可以把这个球放在这j个盒子中的任意一个中，所以 f[i][j]+=f[i-1][j]*j

如果你把i-1个球，放入j-1个盒子中，那么你只能把第i个球放到j中，所以f[i][j]+=f[i-1][j-1]

综上得到上述递推式

然后你特判n<m时为0，再加一个高精即可

```
#include<bits/stdc++.h>
#define ll long long
#define kz() while(c.a[c.l+1]){c.l++;c.a[c.l+1]=c.a[c.l]/10;c.a[c.l]%=10;}
#define clr() while(c.l>1&&!c.a[c.l]) c.l--;
using namespace std;
struct num
{
	int l,a[1001];
	num(){memset(a,0,sizeof(a));}
	void init(){memset(a,0,sizeof(a));}
};
num add(num a,num b)
{
	num c;
	c.l=max(a.l,b.l);
	for(int i=1;i<=c.l;i++)
	{
		c.a[i]+=a.a[i]+b.a[i];
		c.a[i+1]+=c.a[i]/10;
		c.a[i]%=10;
	}
//	while(c.a[c.l+1]){c.l++;c.a[c.l+1]=c.a[c.l]/10;c.a[c.l]%=10;}
	kz();
	return c;
}
num cheng(num a,int b)
{
	num c;
	c.l=a.l;
	for(int i=1;i<=c.l;i++)
	{
		c.a[i]+=a.a[i]*b;
		c.a[i+1]+=c.a[i]/10;
		c.a[i]%=10;
	}
	kz();
	return c;
}
num sget(string s)
{
	num x;
	x.l=s.size();
	for(int i=0;i<x.l;i++)
	{
		x.a[x.l-i]=s[i]-48;
	}
	return x;
}
string zh(ll y)
{
	string s;
	if(y>9) s=zh(y/10);
	s=s+char(y%10+'0');
	return s;
}
num nget(ll y)
{
	num x;
	x=sget(zh(y));
	return x;
}
void print(num x)
{
	for(int i=x.l;i>=1;i--) printf("%d",x.a[i]);
}
void printc(num x,char c)
{
	print(x);
	putchar(c);
}
int n,m;
num f[101][101];
int main()
{
	while(cin>>n>>m)
	{
		if(n<m)
		{
			puts("0");
			continue;
		}
		for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) f[i][j].init();
		f[0][0]=nget(1);
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				f[i][j]=add(cheng(f[i-1][j],j),f[i-1][j-1]);
			}
		}
		printc(f[n][m],'\n');
	}
}
```


---

## 作者：Protons (赞：2)

## 分析：

本题可以使用以[第二类斯特林数](https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/4938529?fromtitle=stirling%E6%95%B0&fromid=8517487&fr=aladdin)为核心的DP求解

我们记$S(n,m)$为“将n个不同的球放入m个无差别的盒子里，要求盒子非空的方案总数”

我们能得到式子：$S(n,m)=\dfrac{1}{m!}$ $\sum\limits_{k=0}^m (-1)^k*$ $\dbinom{m}{k}$ $*(m-k)^n$ 

但是，这个式子我一看就不想用

那我们可以从定义出发考虑第$n+1$个元素的情况，假设要把$n+1$个元素分成$m$个集合则：
1. 如果$n$个元素构成了$m-1$个集合，那么第$n+1$个元素单独构成一个集合。方案数为$S(n,m-1)$

2. 如果n个元素已经构成了$m$个集合，将第$n+1$个元素插入到任意一个集合。方案数 $m*S(n,m)$

故总方案数为$S(n+1,m)=S(n,m-1)+m*S(n,m)$

这样就可以用DP做了

#### 注意，此题要用高精度，否则只能得二十分
## 代码：
```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
using namespace std;
string s[102][102];
int in[10][2];
const int L=1005;
string pluses(string x,string y)
{
	string ans;
	int a[L]={0},b[L]={0},lena=x.size(),lenb=y.size();
	for(int i=0;i<lena;i++)a[lena-1-i]=x[i]-'0';
	for(int i=0;i<lenb;i++)b[lenb-1-i]=y[i]-'0';
    int len=max(lena,lenb);
    for(int i=0;i<len;i++)
    {
        a[i]+=b[i];
        a[i+1]+=a[i]/10;
        a[i]%=10;
    }
    if(a[len])len++;
    for(int i=len-1;i>=0;i--)ans+=a[i]+'0';
    return ans;
}
int cur[L];
string times(string x,int y) 
{
	string ans;
	int lena=x.size();
	memset(cur,0,sizeof(cur));
	for(int i=lena-1;i>=0;i--)cur[lena-i-1]=x[i]-'0';
	int w=0;
	for(int i=0;i<lena;i++)
	{
		cur[i]=cur[i]*y+w;
		w=cur[i]/10;
		cur[i]=cur[i]%10;
	}
	while(w)cur[lena++]=w%10,w/=10;
	lena--;
	while(lena>=0)ans+=cur[lena--]+'0';
	return ans;
}
int main()
{
	s[0][0]="1";
	s[1][0]="0",s[1][1]="1";
	for(int i=2;i<=100;i++)
	for(int j=1;j<=i;j++)
	s[i][j]=pluses(s[i-1][j-1],times(s[i-1][j],j));
	for(int i=0;(cin>>in[i][0]>>in[i][1])&&i<10;i++)//比较玄学的读入方式，也可以用while(cin>>n>>m)来读入
	{
		if(in[i][0]<in[i][1])printf("0\n");
		else cout<<s[in[i][0]][in[i][1]]<<"\n";
	}
	return 0;
}
```

---


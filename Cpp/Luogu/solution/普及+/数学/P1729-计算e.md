# 计算e

## 题目背景

《爱与愁的故事第二弹·compute》最终章。

自然对数的底数 $e$ 是一个著名的无理数，其近似值为 $2.718281828\cdots$ 有计算 $e$ 的公式如下：

$$e=\sum_{n=0}^{\infty}\frac{1}{n!}$$

其中 $n!$ 表示 $n$ 的阶乘，即 $n!=1\times 2\times 3\times \cdots \times n$。


## 题目描述

月落乌啼竟然这么快就回复了圆周率小数点后10000位？！不可能，他肯定求了别人。爱与愁大神再次为难月落乌啼：“帮我算一算 $e$ 后 $n(n \le 10000)$ 位，速度！！！”月落乌啼想求别人，结果他发现由于刚才跟你通话已经用完了手机的所有电。关键时刻只能靠自己。如果现在你是他，你会怎么编这个程序？


## 说明/提示

$30\%$ 数据：$n \le 1000$  
$100\%$ 数据：$n \le 10000$

时限：全部1秒


## 样例 #1

### 输入

```
100```

### 输出

```
2.
7182818284 5904523536 0287471352 6624977572 4709369995
9574966967 6277240766 3035354759 4571382178 5251664274```

# 题解

## 作者：TBB_Nozomi (赞：42)

前记：这道题可能是全Luogu唯一的一道又有高精度又有$\mathrm{e}$的题目，我就用这道题来练手了(

这道题的普遍做法（也是较为常见的正解）是通过提前打表存入程序里，再根据输入的参数做格式化输出。这题也不是什么考场上的题，因此这么做其实相当的靠谱。一种常见的方式就是在Wolfram Mathematica里面输入N[$\mathrm{e}$,10001]，然后你就可以立即得到一份小数位10000位的$\mathrm{e}$，代入程序即可，这里不再赘述。这里讲述两种非打表的高精度解法。

由题目用意，自然对数的底数$\mathrm{e}$的其中一种定义为:
$$\mathrm{e}=\sum\limits_{n=0}^{\infty}\frac{1}{n!}$$
那么我们的两种做法就围绕着这个式子展开。

### 做法一
#### 通分+高精度除法
前置技能：简单的微积分（泰勒展开或各种中值定理）或初高中阶段简单的不等式知识；[P5432 高精度除法](https://www.luogu.com.cn/problem/P5432)。

观察定义给出的这个式子，我们容易发现$n$不一定非得算到无穷大，我们只需要使用前面的若干位就可以得到$\mathrm{e}$的近似值。那么我们要取多少位呢？高数/数分里面，关于Taylor展开的前若干项的误差，有一个Lagrange余项的估计：
$$ \mathrm{e}_ {N}= \sum\limits_{k=0}^{N}\frac{1}{k!}\qquad R_N=\mathrm{e}-\mathrm e_N=\frac{e^\theta}{(N+1)!}$$
其中$\theta\in(0,1)$。即便你并不知道什么是拉格朗日余项，也可以通过不等式的方式分析误差：考虑余项中的每一项$\frac{1}{(k+1)!}$的分母，我们只取前N个数和最后的两个数，那么分式将小于$\frac{1}{N!k(k+1)}=\frac{1}{N!}(\frac{1}{k}-\frac{1}{k+1})$，因此余项有：
$$R_N=\sum\limits_{k=N+1}^{\infty}\frac{1}{k!}<\frac{1}{N!}(\frac{1}{N+1}+\sum\limits_{k=N+1}^{\infty}(\frac{1}{k}-\frac{1}{k+1}))<\frac{1}{N!}$$

假定本题要求输出的**相对误差**$\delta<10^{-k}$（本题的输出结果是一个固定的值，很容易把绝对误差变成相对误差），那么有
$$\boxed{\delta_N=\frac{R_N}{\mathrm{e}}<\frac{1}{N!}<10^{-k}=\delta}$$
在本题中有$k\leq10000$，因此可以得到$N\leq3249$。考虑到一些误差因素，可以适当的将$N$放大一下以得到精度更高的结果。

那么，就按照这一结果计算就完事了吗？鉴于高精度小数的常数，可能对比较大的数据会有些困难。考虑到本题中需要精度位数为$k$，照公式计算中的每一位都应该至少也要有$k$位。由Stirling公式我们可以大概的估计$N$与$k$有关系$k\sim N\log N$，而逐项使用高精度定点数与单精度整数的除法的时间复杂度为$\mathcal{O}(k)$（高精度浮点数的常数只会更大），则总时间复杂度为$\mathcal{O}(kN)=\mathcal{O}(\frac{k^2}{\log N})$，对于$k\sim 10000$部分而言可能会比较危险，有TLE的可能。

怎么样优化掉这个$\mathcal{O}(nk)$的累加和？其实前面的Qingyu大佬有讲过，我们可以把所有的这些分式通分，变成：
$$\mathrm{e}_ {N}= \sum\limits_{k=0}^{N}\frac{1}{k!}=\frac{1}{N!}\sum\limits_{k=0}^{N}A_N^k=\frac{1}{N!}\sum\limits_{k=0}^{N}\prod\limits_{t=N-k+1}^{N}t$$
这样，我们就可以分别计算分子和分母，再通过高精度除法得到最后的结果，这一过程中仅有最后的高精度除法是稍有误差的。前面使用高精度整数加法和与单精度的乘法，其时间复杂度大致与前面的以一致，为较小常数的$\mathcal{O}(\frac{k^2}{\log N})$；后面如果采取高精度除法而非模拟试除法，则可以优化到$\mathcal{O}(k\log k)$。经实验该方法本题可过。

本方法部分代码：
```cpp
int main()	{
	int k;
	cin>>k;
	tbb::_LFloat_prec= (k/4)+2; //万进位高精
	LInt S= 1, P= 1, T= 1;
	int N;
	for(N=1; T.digit()<=tbb::_LFloat_prec*4; )	T*= (++N); //先估计分母阶乘的位数
	for(int i=N; i>0; i--)	{
		P*= i;	S+= P;
	}
	LFloat F=S;	F/=T; //做高精度浮点数除法
	string ans= F.print_str();
	const char* out= ans.c_str();
	putchar('2');	putchar('.');	putchar('\n');
	for(int T=1; T<=k; ++T)	{
		putchar(out[1+T]);
		if(T%50==0)	putchar('\n');
		else	if(T%10==0)	putchar(' ');
	}
	return 0;
}
```

### 做法二
#### 实现高精度浮点数的exp函数
前置技能：比较熟练的微积分；《理性愉悦：高精度数值计算》；高精度浮点数的加减乘法，[高精度小数的正整数幂](https://www.luogu.com.cn/problem/P1517)。（不需要知道高精度除法真高兴）

既然本题是Luogu罕见的高精度又带$\mathrm{e}$，那自然就不会放过这个机会测试函数$\exp$啦。我们可以考虑实现$\exp(x)=\mathrm{e}^x$，再进行计算$\exp(1)$即可。那么我们接下来将着手分析并实现$\exp$。

根据泰勒展开，我们可以将函数$\mathrm{e}^x$展开成幂级数形式，并使用拉格朗日余项，我们有：
$$ \mathrm{e}^x=\sum\limits_{k=0}^{\infty}\frac{x^k}{k!}= \sum\limits_{k=0}^{N}\frac{x^k}{k!}+R_N(x)\quad |R_N(x)|=\frac{\mathrm{e}^{\theta x}x^{N+1}}{(N+1)!}\leq\frac{\mathrm{e}^x}{(N+1)!}$$
其中$\theta\in(0,1)$。由此得知如此展开以后的相对误差也不会超过$\frac{1}{N!}$。

同上面一样，虽然看起来本题可以计算了，然而仔细分析一下，高精度浮点数的乘法次数至少是$\mathcal{O}(N)$的，而高精度乘法的时间复杂度是$\mathcal{O}(k\log k)$的，放一起估计一下也有$\mathcal{O}(k^2\log k)$，那肯定会超时。虽然针对本题，后面会讲到如何优化掉这部分乘法，但总的来说还是要尽可能的降低这部分乘法的次数。

虽然与本题无关，但是这里还是简单的提一句：对于整个实数范围内的$\exp$求值，我们可以将它规约到$[0,1]$的范围内。对于$x<0$的，有$\mathrm{e}^{x}=1/\mathrm{e}^{-x}$可以化为$x>0$的求值；对于$x>1$的，由常见的浮点数存储格式，可以认为$x=x_0\times 10^E$（其中$x_0\in (0,1)$并使用高精度整数来存储）(P.S. 这很像但并不是科学记数法，科学计数法可以规约到这种形式)，那么有$\exp(x)=\exp(x_0)^{10^E}$，可以化为$(0,1)$范围内的求值再做个高精度浮点数的正整数次幂得到。

参照PPT，我们可以进一步的将$x$的范围从$(0,1]$放缩到$(0,10^{\lfloor-\sqrt{k}\rfloor})$，然后仿照上面讨论$x>1$的部分那样提出$10^{\sqrt{x}}$放到$\exp$的外面再做快速幂。对于$x\in(0,10^{\lfloor-\sqrt{k}\rfloor})$，有：
$$\boxed{|R_n(x)|=\frac{\mathrm{e}^{\theta x}x^{n+1}}{(n+1)!}\leq
\mathrm{e}^x10^{-(n+1)\lfloor\sqrt{k}\rfloor}\quad\delta=\frac{R_n(x)}{\mathrm{e}^x}<10^{-(n+1)\lfloor\sqrt{k}\rfloor}}$$
则只需要取$n=\mathcal{O}(\sqrt{k})$，无论是$\exp$的里面还是外面都只需要$\mathcal{O}(\sqrt{k})$次长度为$k$的高精度乘法，因此本方法的总的时间复杂度为$\mathcal{O}(k^{1.5}\log k)$。

虽然时间复杂度理论上满足了，然而实践操作中，如果是万进压位的高精度浮点数，对于$k=10000$的点，需要做大概500次的长度为4096~8192位的高精度乘法，这部分对常数的要求很大。我们可以采取一些比较通用的办法来进行优化。比如比较的经典的包括预处理循环卷积的单位根；又或者是对为循环卷积弄个缓存并适当调整乘法的位置，以保证不总是重复对同一个数组做DFT。当然也可以调整$n=\alpha\sqrt{k}$中的常数$\alpha$，平衡放缩前与放缩后的乘法次数。经过这些优化以后，我针对本题可以做到平均1.2s一个点，也许可以有更快的常数。

然而，针对本题，有一种更好的优化方法。如果你采用的是形如$x=x_0\times 10^E$这样的标准的存储法，你会发现无论是放缩前还是放缩后，$x$中的有效数位其实都只有一位。原因是不言自明的。因此在累加累乘的时候，只要在进行乘法时先判断两边的有效数位，其中的一边大概小于另一边的对数的级别的时候，就可以直接用朴素的按位数乘法累乘而不用经过循环卷积。这样可以减少至少一半的循环卷积次数，大大的提高运行效率。

部分核心代码如下：
```cpp
LFloat pow_pow10(const LFloat & x, int m)   {
    LFloat S= x, S_2, S_3;
    for(int i=0; i<m; ++i)  {
        S= S.pow2();
        S_2= S*S;   S_3= S_2* S; S= S_2* S_3;
    }
    return S;
}// return x^(10^m)
LFloat exp(const LFloat& x)   {
    if(x.isNaN())   return x;
    if(x.isinf() && x.positive())   return x;
    if(x.isinf() && x.negative())   return 0;
    if(x==0)    return 1;
    if(x<0)     return 1/exp(-x);
    if(x > (double(_LFloat_prec)+INT_MAX)*std::log(10000))   return LInt("inf");
    if(x < (double(INT_MIN))*std::log(10000))    return 0;

    int precision= _LFloat_prec * 4;
    if(x>1) {
        _LFloat_prec= (precision + 4 * (x.pow+x.base.d) )/4 + 1;
         LFloat res= pow_pow10( exp(LFloat(x.base, -x.base.d)), 4 * (x.pow+x.base.d) );
         _LFloat_prec= precision / 4;
         return res;
     }
     int bound= int(std::sqrt(precision)/2.3);
     LFloat B= pow10<LFloat>(-bound);
     if(x>B) {
          int delta_pow= 4*x.pow + x.base.digit() + bound;
          _LFloat_prec= (precision + delta_pow)/4 + 1;
          LFloat x_= mul_pow10(x, -delta_pow);
          LFloat res= pow_pow10(exp(x_), delta_pow);
          _LFloat_prec= precision / 4;
          return res;
      }

      _LFloat_prec= (precision + Log_2(precision))/4 + 1;
      int N= precision / bound +1;
      LFloat S= 1;
      for(int i=N; i>0; --i)  S= S/i*x + 1;
      _LFloat_prec= precision/4;
      S.sho();
      return S;
}
              
int main()	{
	int k;
	cin>>k;
	tbb::_LFloat_prec= (k/4)+2;
	LFloat F= exp(LFloat(1));
	string ans= F.print_str();
	const char* out= ans.c_str();
	putchar('2');	putchar('.');	putchar('\n');
	for(int T=1; T<=k; ++T)	{
		putchar(out[1+T]);
		if(T%50==0)	putchar('\n');
		else	if(T%10==0)	putchar(' ');
	}
	return 0;
}
```

#### 其它代码注释
LInt表示高精度整数；LFloat表示高精度浮点数，由一个LInt的base和一个int的pow组成，其表示的数为$\mathrm{base}\times10000^{\mathrm{pow}}$。

---

## 作者：B_1168 (赞：31)

在做完 [P1727 计算π](https://www.luogu.com.cn/problem/P1727)后，点开推荐栏，第一个映入眼帘的自然是这道计算e了；既然是练习Python，不如也做一做，锻炼一下码力(雾)

恰巧题面又给出$e=\sum_{n=0}^{\infty} \frac{1}{n!}$，当然是直接暴力流走起，写了以下这个程序

```python
import math

n=int(input())

ans=10**(n+10)

for i in range (1,2500): #这个2500就是随便选的而已hhh
    ans+=((10**(n+10))//math.factorial(i))

ans//=(10**10)

s="2.\n"

cnt=0

for i in range (n-1,-1,-1):
    cnt+=1
    s+=str((ans//(10**i))%10) ##这个操作对10^10000的数做上10000次，Python跑不动啊……
    if(cnt%10==0):
        s+=" "
    if(cnt%50==0):
        s+="\n"
        cnt=0

print (s)
```

显然，Python自带的高精度乘法并没有傅里叶优化(大嘘)，所以10000的点在一秒内是跑不出来的，光荣[70 TLE](https://www.luogu.com.cn/record/33468516)

又改了几个变量一类的，反而越改越低分，本人又是数学学渣，就只能无奈打表了(摊手)

上面所写的程序，只需将第一个循环里的2500改成10000，不加格式的输出，就可以打出$n=10000$的表来，~~就是慢得可以去喝一杯茶(弥天大雾)~~；将打表的值赋给ans，就写出了以下程序：

```python
n=int(input())

cnt=0

ans=7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931277361782154249992295763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509961818815930416903515988885193458072738667385894228792284998920868058257492796104841984443634632449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961836908887070167683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354021234078498193343210681701210056278802351930332247450158539047304199577770935036604169973297250886876966403555707162268447162560798826517871341951246652010305921236677194325278675398558944896970964097545918569563802363701621120477427228364896134225164450781824423529486363721417402388934412479635743702637552944483379980161254922785092577825620926226483262779333865664816277251640191059004916449982893150566047258027786318641551956532442586982946959308019152987211725563475463964479101459040905862984967912874068705048958586717479854667757573205681288459205413340539220001137863009455606881667400169842055804033637953764520304024322566135278369511778838638744396625322498506549958862342818997077332761717839280349465014345588970719425863987727547109629537415211151368350627526023264847287039207643100595841166120545297030236472549296669381151373227536450988890313602057248176585118063036442812314965507047510254465011727211555194866850800368532281831521960037356252794495158284188294787610852639813955990067376482922443752871846245780361929819713991475644882626039033814418232625150974827987779964373089970388867782271383605772978824125611907176639465070633045279546618550966661856647097113444740160704626215680717481877844371436988218559670959102596862002353718588748569652200050311734392073211390803293634479727355955277349071783793421637012050054513263835440001863239914907054797780566978533580489669062951194324730995876552368128590413832411607226029983305353708761389396391779574540161372236187893652605381558415871869255386061647798340254351284396129460352913325942794904337299085731580290958631382683291477116396337092400316894586360606458459251269946557248391865642097526850823075442545993769170419777800853627309417101634349076964237222943523661255725088147792231519747780605696725380171807763603462459278778465850656050780844211529697521890874019660906651803516501792504619501366585436632712549639908549144200014574760819302212066024330096412704894390397177195180699086998606636583232278709376502260149291011517177635944602023249300280401867723910288097866605651183260043688508817157238669842242201024950551881694803221002515426494639812873677658927688163598312477886520141174110913601164995076629077943646005851941998560162647907615321038727557126992518275687989302761761146162549356495903798045838182323368612016243736569846703785853305275833337939907521660692380533698879565137285593883499894707416181550125397064648171946708348197214488898790676503795903669672494992545279033729636162658976039498576741397359441023744329709355477982629614591442936451428617158587339746791897571211956187385783644758448423555581050025611492391518893099463428413936080383091662818811503715284967059741625628236092168075150177725387402564253470879089137291722828611515915683725241630772254406337875931059826760944203261924285317018781772960235413060672136046000389661093647095141417185777014180606443636815464440053316087783143174440811949422975599314011888683314832802706553833004693290115744147563139997221703804617092894579096271662260740718749975359212756084414737823303270330168237193648002173285734935947564334129943024850235732214597843282641421684878721673367010615094243456984401873312810107945127223737886126058165668053714396127888732527373890392890506865324138062796025930387727697783792868409325365880733988457218746021005311483351323850047827169376218004904795597959290591655470505777514308175112698985188408718564026035305583737832422924185625644255022672155980274012617971928047139600689163828665277009752767069777036439260224372841840883251848770472638440379530166905465937461619323840363893131364327137688841026811219891275223056256756254701725086349765367288605966752740868627407912856576996313789753034660616669804218267724560530660773899624218340859882071864682623215080288286359746839654358856685503773131296587975810501214916207656769950659715344763470320853215603674828608378656803073062657633469774295634643716709397193060876963495328846833613038829431040800296873869117066666146800015121143442256023874474325250769387077775193299942137277211258843608715834835626961661980572526612206797540621062080649882918454395301529982092503005498257043390553570168653120526495614857249257386206917403695213533732531666345466588597286659451136441370331393672118569553952108458407244323835586063106806964924851232632699514603596037297253198368423363904632136710116192821711150282801604488058802382031981493096369596735832742024988245684941273860566491352526706046234450549227581151709314921879592718001940968866986837037302200475314338181092708030017205935530520700706072233999463990571311587099635777359027196285061146514837526209565346713290025994397663114545902685898979115837093419370441155121920117164880566945938131183843765620627846310490346293950029458341164824114969758326011800731699437393506966295712410273239138741754923071862454543222039552735295240245903805744502892246886285336542213815722131163288112052146489805180092024719391710555390113943316681515828843687606961102505171007392762385553386272553538830960671644662370922646809671254061869502143176211668140097595281493907222601112681153108387317617323235263605838173151034595736538223534992935822836851007810884634349983518404451704270189381994243410090575376257767571118090088164183319201962623416288166521374717325477727783488774366518828752156685719506371936565390389449366421764003121527870222366463635755503565576948886549500270853923617105502131147413744106134445544192101336172996285694899193369184729478580729156088510396781959429833186480756083679551496636448965592948187851784038773326247051945050419847742014183947731202815886845707290544057510601285258056594703046836344592652552137008068752009593453607316226118728173928074623094685367823106097921599360019946237993434210687813497346959246469752506246958616909178573976595199392993995567542714654910456860702099012606818704984178079173924071945996323060254707901774527513186809982284730860766536866855516467702911336827563107223346726113705490795365834538637196235856312618387156774118738527722922594743373785695538456246801013905727871016512966636764451872465653730402443684140814488732957847348490003019477888020460324660842875351848364959195082888323206522128104190448047247949291342284951970022601310430062410717971502793433263407995960531446053230488528972917659876016667811937932372453857209607582277178483361613582612896226118129455927462767137794487586753657544861407611931125958512655759734573015333642630767985443385761715333462325270572005303988289499034259566232975782488735029259166825894456894655992658454762694528780516501720674785417887982276806536650641910973434528878338621726156269582654478205672987756426325321594294418039943217000090542650763095588465895171709147607437136893319469090981904501290307099566226620303182649365733698419555776963787624918852865686607600566025605445711337286840205574416030837052312242587223438854123179481388550075689381124935386318635287083799845692619981794523364087429591180747453419551420351726184200845509170845682368200897739455842679214273477560879644279202708312150156406341341617166448069815483764491573900121217041547872591998943825364950514771379399147205219529079396137621107238494290616357604596231253506068537651423115349665683715116604220796394466621163255157729070978473156278277598788136491951257483328793771571459091064841642678309949723674420175862269402159407924480541255360431317992696739157542419296607312393763542139230617876753958711436104089409966089471418340698362993675362621545247298464213752891079884381306095552622720837518629837066787224430195793793786072107254277289071732854874374355781966511716618330881129120245204048682200072344035025448202834254187884653602591506445271657700044521097735585897622655484941621714989532383421600114062950718490427789258552743035221396835679018076406042138307308774460170842688272261177180842664333651780002171903449234264266292261456004337383868335555343453004264818473989215627086095650629340405264943244261445665921291225648893569655009154306426134252668472594914314239398845432486327461842846655985332312210466259890141712103446084271616619001257195870793217569698544013397622096749454185407118446433946990162698351607848924514058940946395267807354579700307051163682519487701189764002827648414160587206184185297189154019688253289309149665345753571427318482016384644832499037886069008072709327673127581966563941148961716832980455139729506687604740915420428429993541025829113502241690769431668574242522509026939034814856451303069925199590436384028429267412573422447765584177886171737265462085498294498946787350929581652632072258992368768457017823038096567883112289305809140572610865884845873101658151167533327674887014829167419701512559782572707406431808601428149024146780472327597684269633935773542930186739439716388611764209004068663398856841681003872389214483176070116684503887212364367043314091155733280182977988736590916659612402021778558854876176161989370794380056663364884365089144805571039765214696027662583599051987042300179465536788

s="2.\n"

for i in range (10000-1,10000-n-1,-1):
    cnt+=1
    s+=str((ans//(10**i))%10) #取位操作
    if (cnt % 10 == 0):
        s += " "
    if (cnt % 50 == 0):
        s += "\n"
        cnt = 0

print (s)
```
然而事实证明，对最大可达$10^{10000}$的数字进行大量取位操作是不明智的，这一番操作后，不仅仍然TLE，还只拿到了50分……

痛定思痛，知道对大整数做大量运算实在不可取，于是将打表出来的答案存到字符串里，直接输出，不仅方便，还十分的快，终于能抱回AC啦！

以下放代码：

```python
n=int(input())

cnt=0

ans="7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931277361782154249992295763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509961818815930416903515988885193458072738667385894228792284998920868058257492796104841984443634632449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961836908887070167683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354021234078498193343210681701210056278802351930332247450158539047304199577770935036604169973297250886876966403555707162268447162560798826517871341951246652010305921236677194325278675398558944896970964097545918569563802363701621120477427228364896134225164450781824423529486363721417402388934412479635743702637552944483379980161254922785092577825620926226483262779333865664816277251640191059004916449982893150566047258027786318641551956532442586982946959308019152987211725563475463964479101459040905862984967912874068705048958586717479854667757573205681288459205413340539220001137863009455606881667400169842055804033637953764520304024322566135278369511778838638744396625322498506549958862342818997077332761717839280349465014345588970719425863987727547109629537415211151368350627526023264847287039207643100595841166120545297030236472549296669381151373227536450988890313602057248176585118063036442812314965507047510254465011727211555194866850800368532281831521960037356252794495158284188294787610852639813955990067376482922443752871846245780361929819713991475644882626039033814418232625150974827987779964373089970388867782271383605772978824125611907176639465070633045279546618550966661856647097113444740160704626215680717481877844371436988218559670959102596862002353718588748569652200050311734392073211390803293634479727355955277349071783793421637012050054513263835440001863239914907054797780566978533580489669062951194324730995876552368128590413832411607226029983305353708761389396391779574540161372236187893652605381558415871869255386061647798340254351284396129460352913325942794904337299085731580290958631382683291477116396337092400316894586360606458459251269946557248391865642097526850823075442545993769170419777800853627309417101634349076964237222943523661255725088147792231519747780605696725380171807763603462459278778465850656050780844211529697521890874019660906651803516501792504619501366585436632712549639908549144200014574760819302212066024330096412704894390397177195180699086998606636583232278709376502260149291011517177635944602023249300280401867723910288097866605651183260043688508817157238669842242201024950551881694803221002515426494639812873677658927688163598312477886520141174110913601164995076629077943646005851941998560162647907615321038727557126992518275687989302761761146162549356495903798045838182323368612016243736569846703785853305275833337939907521660692380533698879565137285593883499894707416181550125397064648171946708348197214488898790676503795903669672494992545279033729636162658976039498576741397359441023744329709355477982629614591442936451428617158587339746791897571211956187385783644758448423555581050025611492391518893099463428413936080383091662818811503715284967059741625628236092168075150177725387402564253470879089137291722828611515915683725241630772254406337875931059826760944203261924285317018781772960235413060672136046000389661093647095141417185777014180606443636815464440053316087783143174440811949422975599314011888683314832802706553833004693290115744147563139997221703804617092894579096271662260740718749975359212756084414737823303270330168237193648002173285734935947564334129943024850235732214597843282641421684878721673367010615094243456984401873312810107945127223737886126058165668053714396127888732527373890392890506865324138062796025930387727697783792868409325365880733988457218746021005311483351323850047827169376218004904795597959290591655470505777514308175112698985188408718564026035305583737832422924185625644255022672155980274012617971928047139600689163828665277009752767069777036439260224372841840883251848770472638440379530166905465937461619323840363893131364327137688841026811219891275223056256756254701725086349765367288605966752740868627407912856576996313789753034660616669804218267724560530660773899624218340859882071864682623215080288286359746839654358856685503773131296587975810501214916207656769950659715344763470320853215603674828608378656803073062657633469774295634643716709397193060876963495328846833613038829431040800296873869117066666146800015121143442256023874474325250769387077775193299942137277211258843608715834835626961661980572526612206797540621062080649882918454395301529982092503005498257043390553570168653120526495614857249257386206917403695213533732531666345466588597286659451136441370331393672118569553952108458407244323835586063106806964924851232632699514603596037297253198368423363904632136710116192821711150282801604488058802382031981493096369596735832742024988245684941273860566491352526706046234450549227581151709314921879592718001940968866986837037302200475314338181092708030017205935530520700706072233999463990571311587099635777359027196285061146514837526209565346713290025994397663114545902685898979115837093419370441155121920117164880566945938131183843765620627846310490346293950029458341164824114969758326011800731699437393506966295712410273239138741754923071862454543222039552735295240245903805744502892246886285336542213815722131163288112052146489805180092024719391710555390113943316681515828843687606961102505171007392762385553386272553538830960671644662370922646809671254061869502143176211668140097595281493907222601112681153108387317617323235263605838173151034595736538223534992935822836851007810884634349983518404451704270189381994243410090575376257767571118090088164183319201962623416288166521374717325477727783488774366518828752156685719506371936565390389449366421764003121527870222366463635755503565576948886549500270853923617105502131147413744106134445544192101336172996285694899193369184729478580729156088510396781959429833186480756083679551496636448965592948187851784038773326247051945050419847742014183947731202815886845707290544057510601285258056594703046836344592652552137008068752009593453607316226118728173928074623094685367823106097921599360019946237993434210687813497346959246469752506246958616909178573976595199392993995567542714654910456860702099012606818704984178079173924071945996323060254707901774527513186809982284730860766536866855516467702911336827563107223346726113705490795365834538637196235856312618387156774118738527722922594743373785695538456246801013905727871016512966636764451872465653730402443684140814488732957847348490003019477888020460324660842875351848364959195082888323206522128104190448047247949291342284951970022601310430062410717971502793433263407995960531446053230488528972917659876016667811937932372453857209607582277178483361613582612896226118129455927462767137794487586753657544861407611931125958512655759734573015333642630767985443385761715333462325270572005303988289499034259566232975782488735029259166825894456894655992658454762694528780516501720674785417887982276806536650641910973434528878338621726156269582654478205672987756426325321594294418039943217000090542650763095588465895171709147607437136893319469090981904501290307099566226620303182649365733698419555776963787624918852865686607600566025605445711337286840205574416030837052312242587223438854123179481388550075689381124935386318635287083799845692619981794523364087429591180747453419551420351726184200845509170845682368200897739455842679214273477560879644279202708312150156406341341617166448069815483764491573900121217041547872591998943825364950514771379399147205219529079396137621107238494290616357604596231253506068537651423115349665683715116604220796394466621163255157729070978473156278277598788136491951257483328793771571459091064841642678309949723674420175862269402159407924480541255360431317992696739157542419296607312393763542139230617876753958711436104089409966089471418340698362993675362621545247298464213752891079884381306095552622720837518629837066787224430195793793786072107254277289071732854874374355781966511716618330881129120245204048682200072344035025448202834254187884653602591506445271657700044521097735585897622655484941621714989532383421600114062950718490427789258552743035221396835679018076406042138307308774460170842688272261177180842664333651780002171903449234264266292261456004337383868335555343453004264818473989215627086095650629340405264943244261445665921291225648893569655009154306426134252668472594914314239398845432486327461842846655985332312210466259890141712103446084271616619001257195870793217569698544013397622096749454185407118446433946990162698351607848924514058940946395267807354579700307051163682519487701189764002827648414160587206184185297189154019688253289309149665345753571427318482016384644832499037886069008072709327673127581966563941148961716832980455139729506687604740915420428429993541025829113502241690769431668574242522509026939034814856451303069925199590436384028429267412573422447765584177886171737265462085498294498946787350929581652632072258992368768457017823038096567883112289305809140572610865884845873101658151167533327674887014829167419701512559782572707406431808601428149024146780472327597684269633935773542930186739439716388611764209004068663398856841681003872389214483176070116684503887212364367043314091155733280182977988736590916659612402021778558854876176161989370794380056663364884365089144805571039765214696027662583599051987042300179465536788"

s="2.\n"

for i in range (0,n):
    cnt+=1
    s += ans[i]
    if (cnt % 10 == 0):
        s += " "
    if (cnt % 50 == 0):
        s += "\n"
        cnt = 0

print(s)
```
感谢管理员的审核，看到这里了不如给个赞再走吧(逃)

---

## 作者：iwprc (赞：13)

看到这题没有人写题解，那我就当第一个吧。

其实本题就是一个高除单和一个高精度加法。

直接上代码：

```cpp
#include<cstdio>
const int N=2005;
const int M=100000;
int a[N],s[N],t[N],i,k,p,n;
//a数组存答案，1位存5个数字
//s数组存(1/n!),也是1位存5个数字
//t数组用来过渡
int f=true;
int main(){
    i=2;
    a[1]=s[1]=50000;
    //初始化：a数组和s数组都赋值为0.5，下面从1/3!算起
    while(f){
        i++;
        //当前算1/i!
        p=0;
        for(k=0;k<N;k++){
            p=p*M+s[k];
            t[k]=p/i;
            p%=i;
        }
        //高除单，i!=(1/(i-1)!)/i
        f=false;
        for(k=0;k<N;k++){
            a[k]+=s[k]=t[k];
            if(s[k])
                f=true;
            //当s数组为空时，退出循环
            if(a[k]>=M)
                a[k-1]+=a[k]/M,a[k]%=M;
        }
        //高精度加法，把s加进a
    }
    scanf("%d",&n);
    printf("2.\n");
    for(i=1;i*5<=n;i++){
        printf("%05d",a[i]);
        if(!(i%10))
            printf("\n");
        else
            if(!(i%2))
                printf(" ");
    }
    //输出
    if(i*5-n==4)printf("%d",a[i]/10000);
    if(i*5-n==3)printf("%02d",a[i]/1000);
    if(i*5-n==2)printf("%03d",a[i]/100);
    if(i*5-n==1)printf("%04d",a[i]/10);    
    //因为是5位5位输出，最后几位单独输出    
    return 0;
}

```

---

## 作者：TobyFlenderson (赞：8)

计算自然常数 $\mathrm{e}$ 有多种办法，前人有很多研究。其中使用Maclaurin公式把 $f(x)=\mathrm{e}^x$ 展开，并令 $x=1$ 可以得到 $\mathrm{e}$ 的无穷逼近式：

$$
\mathrm{e}=1+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+\cdots +\frac{1}{n!}+\cdots =1+\sum_{n=1}^{\infty}{\frac{1}{n!}}
$$

记上式为 $(1)$ 式。已有的研究表明 $(1)$ 式收敛得很快[1] ，于是此题我们用 $(1)$ 式，也就是题目给出的公式计算 $\mathrm{e}$。

拿到 $(1)$ 式，首先要考虑的是 $n$ 到底要取到多大才能满足题目所需的精度？这个问题 TBB_Nozomi 在他的[题解](https://www.luogu.com.cn/article/yaqbt9p0)中给出了详细的分析，这里引用他的结论：

> 要想使用 $(1)$ 式计算 $\mathrm{e}$ 的 $n$ 位有效数字， $n$ 应满足
> $$10^n<n!$$

两边取对数，有

$$
n\ln 10<\sum_{k=1}^n{\ln k}
$$

于是 $n$ 可以编程求解，代码如下：

```cpp
int get_n(int d)
{
    double f = d * log(10);
    double r = 0;
    int i = 0;
    do
    {
        i++;
        r += log(i);
    } while (r < f);
    return i;
}
```

由于高精度除法的消耗很多，可以预测的是，如果直接用 $(1)$ 式暴力计算 $\mathrm{e}$ ，是一定会 TLE 的。于是我们要把 $(1)$ 式通分：

$$
\mathrm{e}_n=1+\sum_{k=1}^n{\frac{1}{k!}}=1+\frac{1}{n!}\sum_{k=0}^{n-1}{A_{n}^{k}}，
$$

使得原本要调用 $n$ 次的高精度除法降为仅需 $1$ 次。代码如下：

```cpp
void euler_tongfen(int d)
{
    int n = get_n(d);
    mpz_class p = 1, q = 1; //mpz_class表示高精度整数类
    for (int i = n; i > 1; i--)
    {
        q *= i; //高精度×单精度，时间复杂度为O(n)
        p += q;
    }
    mpf_class r = p; //mpq_class表示高精度浮点数类
    r /= q;          //高精度除法
    ++r;             //别忘了+1
}
```

显然上述算法的时间复杂度为 $O(n^2)$ 。按照 TBB_Nozomi 的说法，只要高精度算法实现得没问题，上面的代码再加上一些格式化输出就能通过这题。下面是我用 TBB_Nozomi 的[高精度整数板子](https://www.luogu.com/article/c0tfc4oc)，在他的题解代码的基础上修改得来的 AC 代码。

```cpp
int main()
{
    int k;
    cin >> k;
    tbb::LInt S = 1, P = 1;
    int N = get_n(k);
    for (int i = N; i > 0; i--) 
    {
        P *= i;
        S += P;
    }
    S <<= k / 4 + 2;
    S /= P;
    string ans = S.print_str();
    const char* out = ans.c_str();
    putchar('2'); putchar('.'); putchar('\n');
    for (int T = 1; T <= k; ++T) {
        putchar(out[T]);
        if (T % 50 == 0) putchar('\n');
        else if (T % 10 == 0) putchar(' ');
    }
    return 0;
}
```

[这个链接](https://www.luogu.com.cn/record/161474412)是我的评测详情，开启了 ```O2``` 优化，总用时 $255$ ms。[不开启 ```O2``` ](https://www.luogu.com.cn/record/161474954)则需要 $556$ms。

上述代码还有优化的可能：

①对于“高精度×单精度”的算法，它是 $O(n)$ 的，在输入较小时它是十分快的，于是我们的优化思路是采用二分法对表达式分块处理，在表达式长度缩短到某一阈值的时候就采用通分的方式进行计算，然后使用时间复杂度低于 $O(n^2)$ 的大整数乘法（FFT，Karatsuba，Toom Cook 3-Way）向上合并，最终得到结果。

②对高精度除法进行优化，这就是另外一个问题了，可以查看[P5432 A/B problem](https://www.luogu.com.cn/problem/P5432)的题解。

如何进行分块处理呢？为了方便讨论，记

$$
E\left( n,m \right) =\frac{1}{n}+\frac{1}{n\left( n+1 \right)}+\cdots +\frac{1}{n\left( n+1 \right) \left( n+2 \right) \cdots m}
$$

于是 $\mathrm{e}=1+E(1,+\infty)$ 。令 $r=\lfloor \frac{n+m}{2} \rfloor$，那么对于 $E(n,m)$ 有

$$
E\left( n,m \right) =E\left( n,r \right) +\frac{1}{n\left( n+1 \right) \cdots r}\cdot E\left( r+1,m \right) 
$$

再令 $\frac{p_1}{q_1}=E\left( n,r \right)$，$\frac{p_2}{q_2}=E\left( r+1,m \right)$，显然 $q_1=n(n+1)\cdots r$，于是

$$
E\left( n,m \right) =\frac{p_1}{q_1}+\frac{1}{q_1}\cdot \frac{p_2}{q_2}=\frac{p_1q_2+p_2}{q_1q_2}
$$

算法如下图所示

![算法递归树](https://cdn.luogu.com.cn/upload/image_hosting/t3l6r87w.png)

每做一次合并，需要两次乘法，一次加法。显然，若“高精×高精”的算法复杂度仍为 $O(n^2)$ ，那么总体的复杂为

$$
T\left( n \right) =\frac{n^2}{2}+\frac{n^2}{4}+\frac{n^2}{8}+\cdots =n^2\left( \frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\cdots \right) =O\left( n^2 \right) 
$$

与原算法基本持平，甚至还要稍慢一些。于是只要“高精×高精“的算法复杂度低于 $O(n^2)$ ，那么总体的复杂度就比原来的更优。

那么只剩下最后一个问题了，阈值的选取，也就是 $E(n,m)$ 多短我们才开始用通分法计算呢？遗憾的是，不同的处理器，不同的算法实现效率都会影响阈值的选取，要找到阈值最简单的方法是通过暴力搜索的方式得到。在我的机器上这个值大约在 $120$ 左右。在洛谷上使用阈值为 $128$ 的新算法用时 $161$ms，[评测详情](https://www.luogu.com.cn/record/161481271)。

以下是新的 AC 代码。

```cpp
int MIN_SPLIT = 128;
static void euler_split(int n, int m, LInt& p, LInt& q)
{
    if (m - n < MIN_SPLIT)
    {
        p = 1;
        q = 1;
        for (int i = m; i > n; i--)
        {
            q *= i;
            p += q;
        }
        q *= n;
        return;
    }
    LInt p1, p2, q1, q2;
    euler_split(n, (n + m) >> 1, p1, q1);
    euler_split((n + m + 2) >> 1, m, p2, q2);
    p = p1 * q2 + p2;
    q = q1 * q2;
}

int main()
{
    int k;
    cin >> k;
    LInt p, q;
    int n = get_n(k);
    euler_split(1, n, p, q);
    p += q;
    p <<= k / 4 + 2;
    p /= q;
    string ans = p.print_str();
    const char* out = ans.c_str();
    putchar('2');    putchar('.');    putchar('\n');
    for (int T = 1; T <= k; ++T) {
        putchar(out[T]);
        if (T % 50 == 0)    putchar('\n');
        else if (T % 10 == 0)    putchar(' ');
    }
    return 0;
}
```

[1] 朱德凯, 苏岐芳. 多种计算方法下自然常数e的误差和收敛速度比较[J]. 台州学院学报, 2022, 44(03): 11-16. DOI: 10.13853/j.cnki.issn. 1672-3708. 2022. 03. 003.

---

## 作者：Ajwallet (赞：6)

# 高精度思路
好吧，其实我也打了一个点。。。

要想AC并且不打表，个人认为是要打一个压位高精的，但高精度也能过9个点，再打第二个点就能A了（楼下pascal题解真的令人佩服！）

主要是因为精度问题，若要精确到小数点后10000位，则必须计算$n$到10000，而这样做会TLE，所以就打了一个点，每次$n$计算到5000，能够满足90%的精度，还有一个点，需要更快且更高的精度，那么要用到压位高精，速度可以快$k$倍（k为压位的位数）

本算法时间为$n/10ms$到$n/10+100ms$之间（n为计算的阶乘的个数）
算法时间复杂度为$O(len\times n)$len为高精度数组的长度，n为计算到几的阶乘。由于$n$只算到了5000，精度不够，这也就是为什么不能拿到第二个点的原因。若一定要拿第二个点，就需要$10000\times 10000$的时间复杂度，肯定超时，所以要用到压位高精度。
# 代码（高精度）

```cpp
#include<cstdio>
using namespace std;
int e[10001],fs[10001],n=5001,i,j,k,s,g,t,l,len;
int read()//输入流
{
	int f=0;char c;
	while(c=getchar(),c<'0'||c>'9');f=(f<<3)+(f<<1)+c-48;
	while(c=getchar(),c>='0'&&c<='9') f=(f<<3)+(f<<1)+c-48;
	return f;
}
void init()
{
	e[1]=5;len=read();//输入
	if (n>=1)
	puts("2.");//先输出这个
	if (n>=2) 	fs[1]=5;//这个是第一个阶乘后计算的值
	for (i=3;i<=n;i++)	//高精度不解释
	 {
	 	g=s=t=0;
     	for (j=1;j<=10000;j++) {s=10*g+e[j];e[j]=s / i;g=s % i;}
	 	for (k=10000;k>=1;k--) 
	 	{
		 	l=fs[k];
	 		fs[k]=(fs[k]+e[k]+t) % 10;
	    	t=(l+e[k]+t) / 10;
		}
	 }
}
void sc()
{
	if(len==10000)
	 {
	 	for (i=1;i<=len-10;i++)
	     {printf("%d",fs[i]);if(i%50==0) putchar(10);else if(i%10==0) putchar(32);}
	    puts("9465536788");//打表打了一个点
	    return;
	 }
	for (i=1;i<=len;i++)
	 {printf("%d",fs[i]);if(i%50==0) putchar(10);else if(i%10==0) putchar(32);}//输出
}
int main()
{
	init();
	sc();
}
```
# 压位高精度思路
其实楼下的压位5位的更好处理换行和空格，但时间复杂度比压8位的要高

就是把每一位都压成8位去计算，这样子大大节约了空间和时间，时间复杂度是前面算法的$\frac{1}{8}$为 $O(1350\times 10000)$

（因为$n$需要更高的精度，所以计算到了10000，1350是因为保险多开了100位）
# 代码（压位高精度）

```cpp
#include<cstdio>
#define LL long long
using namespace std;
const short n=10000;
LL e[1351],fs[1351],s,g,l;//因为计算过程中可能数字过大，所以要开LL
int i,j,k,t,len,ws,ok[8];
LL read()//输入流
{
    int f=0;char c;
    while(c=getchar(),c<'0'||c>'9');f=(f<<3)+(f<<1)+c-48;
    while(c=getchar(),c>='0'&&c<='9') f=(f<<3)+(f<<1)+c-48;
    return f;
}
void init()
{
    e[1]=5;len=read();//输入
    if (n>=1)
    puts("2.");
    if (n>=2)   fs[1]=5;
    for (i=3;i<=n;i++)  
     {
        g=s=t=0;
        for (j=1;j<=1350;j++) {s=100000000*g+e[j];e[j]=s/i;g=s%i;}//全都压位
        for (k=1350;k>=1;k--) 
        {
            l=fs[k];
            fs[k]=(fs[k]+e[k]+t)%100000000;
            t=(l+e[k]+t)/100000000;//压位
        }
     }
}
void sc()
{
	printf("%d",fs[1]);ws++;
	for(int i=2;ws<len;i++)
	 {
	 	j=8;
	 	while(fs[i]){ok[--j]=fs[i]%10;fs[i]/=10;}
	 	for(k=0;k<j;k++) ok[k]=0;//这一步很关键，当然你也可以每次都清0
	 	for(j=0;j<8&&ws<len;j++)
	 	 {putchar(ok[j]+48);ws++;if(ws%50==0) putchar(10);else if(ws%10==0) putchar(32);};//记得边输出边处理空格和换行
	 }
}
int main()
{
    init();
    sc();
}
```

---

## 作者：Go灬Fire (赞：4)

这个题可比计算$π$后面$10000$位**简单多了**，因为$e$的无穷级数收敛很快呀~

直接上Java就可了，很久没有这么痛快过了$\cdots$

**Java万岁，BigDecimal万岁**
```
import java.math.BigDecimal;
import java.util.Scanner;
import java.math.RoundingMode;
public class LuoGuP1729 {
    public static void main(String[] args){
        Scanner cin=new Scanner(System.in);
        int n=cin.nextInt();
        if(n==0) {
            System.out.println(2);
            return;
        }
        BigDecimal now=BigDecimal.ONE;
        BigDecimal ans=BigDecimal.ONE;
        for(int i=1;;i++){
            now=now.divide(BigDecimal.valueOf(i),n+10,RoundingMode.HALF_UP);
            if(now.compareTo(BigDecimal.ZERO)==0) break;
            ans=ans.add(now);
        }
        String s=ans.toString();
        System.out.println("2.");
        int cnt=0;
        for(int i=2;;i++){
            System.out.print(s.charAt(i));
            cnt++;
            if(cnt==n) break;
            if(cnt%50==0) System.out.println("");
            else if(cnt%10==0) System.out.print(" ");
        }
    }
}

```


---


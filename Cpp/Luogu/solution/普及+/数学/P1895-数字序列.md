# 数字序列

## 题目描述

定义函数 $\mathrm{tostring}(n)$ 表示将数字 $n$ 按照 $10$ 进制写成字符串。例如，$\mathrm{tostring}(12345)={\tt 12345}$。由此，

- 定义字符串 $S_n={\tt 1+2+3+4+\cdots}+\mathrm{tostring}(n)$；
- 定义字符串 $S_{\infin}=S_1+S_2+S_3+S_4+\cdots$

例如，$S_{\infty}$ 的前若干项为：

$$\tt 112123123412345123456123456712345678123456789123456789101234567891011\cdots$$

现在询问 $S_{\infin}$ 的第 $i$ 位是什么字符。


## 样例 #1

### 输入

```
2
3
8
```

### 输出

```
2
2
```

# 题解

## 作者：Falashiro (赞：12)

$\text{upd on 2020.2.28:}$ 增添了一些说明 

题目描述

在下列的无穷数字序列$1121231234......$ 中，查找第 $n$ 个数字。

对于任意一个子数字序列 $1234...i$ ，我们可以先预处理出它的长度，记为$len_i$。

预处理部分代码（十分暴力，应该很好理解）：

```cpp
len[0]=0;
for(register int i=1;i<10;i++)
	len[i]=len[i-1]+1;
for(register int i=10;i<100;i++)
	len[i]=len[i-1]+2;
for(register int i=100;i<1000;i++)
	len[i]=len[i-1]+3;
for(register int i=1000;i<10000;i++)
	len[i]=len[i-1]+4;
for(register int i=10000;i<100000;i++)//预处理大一点
	len[i]=len[i-1]+5;
```

对于题目所求的序列的第 $n$ 个数字，要先求出它在原序列哪个子序列中。

```cpp
scanf("%d",&n);
int s=0,k1=0,t=n;
while(++k1){
	s+=len[k1];
	if(s>=t)break;//保证s>=t,s-len[k1]<t
}
t-=(s-len[k1]);//s-len[k1]即为前(k1-1)个子序列的总长度
```

这样，我们就知道了答案就是第 $k_1$ 个子序列中的第 $t$ 个数。

显然对于任意一个 $i$ $(i∈N^+)$ ，第 $i$个子序列是第 $i+1$ 个子序列的子序列。

于是我们继续枚举：

```cpp
int k2=0;
while(++k2)
	if(len[k2]>=t)break;//使得len[k2]>=t,len[k2-1]<t
```
即找到最小的 $k_2$ ，使第 $k_2$ 个子序列是至少有 $t$ 位的。

答案就变成了第 $k_2$ 个子序列中的倒数第 $(len_{k_2}-t+1)$ 个数，也就是 $k_2$ 这个数的倒数第 $(len_{k_2}-t+1)$ 位数。

如过要求一个数 $x$ 的倒数第 $y$ 位，就是求 $x/10^{y-1}$ 对 $10$ 取模。

所以 $k_2$ 的倒数第 $(len_{k_2}-t+1)$ 位就是 $k_2/10^{len_{k_2}-t}$ 对 $10$ 取模。

然后把这个数求出来就行了。

```cpp
printf("%d\n",(int)(k2/pow(10,len[k2]-t))%10);
```

完整代码：

```
#include<bits/stdc++.h>
using namespace std;
#define rint register int
#define N 100001
int t,n,len[N];
int main(){
	for(rint i=1;i<10;i++)
		len[i]=len[i-1]+1;
	for(rint i=10;i<100;i++)
		len[i]=len[i-1]+2;
	for(rint i=100;i<1000;i++)
		len[i]=len[i-1]+3;
	for(rint i=1000;i<10000;i++)
		len[i]=len[i-1]+4;
	for(rint i=10000;i<100000;i++)
		len[i]=len[i-1]+5;
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		int s=0,k1=0,k2=0;
		while(++k1){
			s+=len[k1];
			if(s>=n)break;
		}
		n-=(s-len[k1]);
		while(++k2)
			if(len[k2]>=n)break;
		printf("%d\n",(int)(k2/pow(10,len[k2]-n))%10);
	}
	return 0;
}
```

---

## 作者：_Life_ (赞：9)

### 题意
求序列 $112123123412345123456123456712345678\cdots$ 的第 $n$ 个数字，$n\le 2^{31}-1$，$T$ 组测试数据，$T\le 10$。

### 题解
`C++11` 中加入了 [`to_string()`](https://zh.cppreference.com/w/cpp/string/basic_string/to_string) 函数，可以方便的将一个数转换为 `string` 类型，于是我们就可以愉快而优雅的暴力了。

等等，$n\le 2^{31}-1$，为啥暴力能过？
```cpp
string str;long long ans=0;
for(int i=1;i<=n;i++)
	str+=to_string(i),ans+=str.size();
```
通过以上打表代码得知，当循环运行了 `100000` 次时，序列长度已经达到了 `23940138390`，超过了 $2^{31}-1$，而且在本地只运行了 `10ms`，跑的飞快！

然后我们就能放心的暴力啦！不断向 `str` 的末尾赛入 `to_string(i)`，直到累加长度大于 $n$，就输出对应的字符。

实现细节见示例代码。

### 代码
```cpp
#include<cstdio>
#include<string>
#include<iostream>
using namespace std;
int T,n;
long long ans;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		string str;ans=0;
		for(int i=1;;i++)
		{
			str+=to_string(i),ans+=str.size();
			if(ans>=n)
			{
				ans-=str.size();
				printf("%c\n",str[n-ans-1]);
				break;
			}
		}
	}
}
```

---

## 作者：大奕哥 (赞：5)

诸位看官，小生发来一条题解

使用前缀和，a[i]表示第i个数要有多长

s[i]表示前i个数的总长度

预处理到40000即可

然后就扫到长度在s[i-1]~s[i]之间的那个

再找a[i]就好啦:-D




    

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
int a[40011],s[40011];
int main()
{
     int n;
     for(int i=1;i<=40000;i++)
     {
             int k,m=1;
             k=i;
             while(k/10!=0)
             {
                           m++;
                           k/=10;
            }
             a[i]=a[i-1]+m;
             s[i]=a[i]+s[i-1];
             //cout<<a[i]<<endl;
    }
    cin>>n;
     for(int i=1;i<=n;i++)
     {
             int k,j=0;
             cin>>k;
             while(k>s[j])
             j++;
             int q=k-s[j-1];
             int w=1;
             while(q>a[w+1])
             {
                        w++;
            }
            if(q-a[w]==0)
            {cout<<w%10<<endl;k=0;}//注意要特判，一旦要是第一个数就无法输出
            if(k!=0)
             {q-=a[w];
             char x[10];
             w++;
             sprintf(x+1,"%d",w);
             cout<<x[q]<<endl;}
    }
    system("pause");
    return 0;
}

```

---

## 作者：_ouhsnaijgnat_ (赞：4)

这道题知道一个函数还是非常水的，建议降黄。

## 思路

这道题我们可以用一个函数
```cpp
 to_string
```

这个函数就行。它只有一个参数，为一个整数，作用是将这个整数打包成字符。

其实不知道也行，自己手打吧。还有这道题需要节省空间，如果真算出那么多，空间肯定爆。

我们发现每一次都是把上一次加上去的字符串加一个数字然后再放入串中，于是就有很多重复的，我们就可以节省空间。

怎么节省呢？我们用计数器 $ans$ 来记录现在这个串有多长，如果 $ans\ge n$，就已经找到解了。

那应该输出什么呢，应该输出 $ s[n-$上一个串长度$-1]$，因为这个 $s$ 在上一个串后面，要求的 $n$ 也在这个 $s$ 里，所以这就是省空间，那为啥要 $-1$？我看你字符串白学了，开始是从 $0$ 开始！

## 代码

```cpp
#include<iostream>
#include<string>
#include<cstdio>
using namespace std;
int t,n;
long long ans;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		string s;
		ans=0;
		for(int i=1;;i++){
			s+=to_string(i),ans+=str.size();//ans记录现在这个串有多长 
			if(ans>=n){
				ans-=s.size();
				cout<<s[n-ans-1]; 
				break;//找到就退出 
			}
		}
	}
	return 0;
}
```


---

## 作者：Adove (赞：3)

其实这题在预处理的时候完全没有把每个数拆开来的必要

像LCA预处理log那样预处理就可以了

具体看代码吧。。

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=40005;

int a[MAXN],lis[MAXN],p=1;
int T,n;

int main()
{
	for(int i=1;i<=40000;++i){
		a[i]=a[i-1];
		if(i==p) ++a[i],p*=10;
	}for(int i=1;i<=40000;++i) lis[i]=lis[i-1]+a[i];
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;n>lis[i];++i) n-=lis[i];
		int rk=1;while(n>a[rk]) n-=a[rk],++rk;
		int ans[6];
        for(int i=a[rk];i;--i) ans[i]=rk%10,rk/=10;
		printf("%d\n",ans[n]);
	}return 0;
}
```

---

## 作者：yizimi远欣 (赞：3)

### 题目背景
查找数字

### 题目描述
在下列的无穷数字序列1121231234123451234561234567123456781234567891234567 8910123456789101112345678910......中，查找第i个数字。

### 输入输出格式
#### 输入格式：
第一行为正整数t(1≤t≤10)，表示测试数据组数。接下来t行，每行一个正整数i(1≤i≤2^31-1)。

#### 输出格式：
对于每一个i，输出对应位置上的数字。

### 输入输出样例
#### 输入样例#1： 复制
	2
	3
	8
#### 输出样例#1： 复制
	2
	2
    
### 主要思路：预处理 + lower_bound ~~（STL大法好）~~

我们可以预处理一下一个数n的长度，预处理一下1~n的长度，预处理一下1,1~2,1~3,...,1~n的长度（听起来好麻烦的说）

预处理完毕以后，对于每一个查询n，我们可以用lower_bound找到第几位之前完整的1,1~2,1~3,...,1~m，使得这个长度小于等于n且最大。然后再用lower_bound寻找最大的1~k，使得这个长度小于等于n - length(1,1~2,1~3,...,1~m)且最大。这样就可以求出第n位所在的数中在第几位。所以我们只需要把第n位所在的数分解一下就好了。答案就是这个数的分解后第(n - length(1,1~2,1~3,...,1~m) - length(1~k))位

不太明白的话就手玩一下体会一下。

#### 注意：

用可能减着减着，n会变成0，所以要加特判，当n减到0时，就把前面取到的数的最后一位输出即可

~~最近感冒QAQ有点晕~~

### 代码： 

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 100010
#define inf 2147483647
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
#define bson l, r, rt
//#define LOCAL
#define mod 
#define Debug(...) fprintf(stderr, __VA_ARGS__)
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
//This is AC head above...
ll w[mn], a[mn], sum[mn], b[7];
int T, n;
inline void debug(int n = 20) {
    go(i, 1, n, 1) printf("w[%2d] = %4d, a[%2d] = %4d, sum[%2d] = %4d\n", i, w[i], i, a[i], i, sum[i]);
}
int main(){
    go(i, 0, 9, 1) w[i] = 1;
    go(i, 10, 99, 1) w[i] = 2;
    go(i, 100, 999, 1) w[i] = 3;
    go(i, 1000, 9999, 1) w[i] = 4;
    go(i, 10000, 99999, 1) w[i] = 5;
    a[1] = w[1];
    go(i, 2, 99999, 1) a[i] = a[i - 1] + w[i];
    sum[1] = a[1];
    go(i, 2, 99999, 1) sum[i] = sum[i - 1] + a[i];
    // 这鬼畜的预处理啊QAQ
    //debug();
    T = read();
    while(T--){
        n = read();
        int now = lower_bound(sum + 1, sum + 100000, n) - sum - 1;
        n -= sum[now];
        if(n == 0) {
            cout << now % 10 << "\n";
            continue;
        }
        now = lower_bound(a + 1, a + 100000, n) - a - 1;
        n -= a[now];
        if(n == 0) {
            cout << now % 10 << "\n";
            continue;
        }
        int nn = now + 1;
        fo(i, w[now + 1], 1, 1) {
            b[i] = nn % 10;
            nn /= 10;
        }
        cout << b[n] << "\n";
    }
#ifdef LOCAL
        Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
    return 0;
}

```

---

## 作者：EatBread (赞：2)

c++11大大的好！

安装[点这](https://blog.csdn.net/shidya/article/details/65023148)。

题目描述

在下列的无穷数字序列$112123123412345$......中，查找第i个数字。

### 思路
 
c++11中加入了 `to_string()` 函数，可以将整数转成字符串，于是可以直接暴力。

~~这题的数据太水了，建议加强~~。

### 程序
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,ans;
string s;
int main()
{
    scanf("%d",&t);
    for(int j=1; j<=t; j++)
    {
	scanf("%d",&n);
	s="";/*每次都要赋初值*/ans=0;
	for(int i=1;;i++)//找到了下面会直接结束 
	{
	    s+=to_string(i),ans+=s.size();
	    if(ans>=n)//如果找到的长度已经超出询问范围 
	    {
		ans-=s.size();
		printf("%c\n",s[n-ans-1]);
		break;
            }
	}
    }
   return 0;
}

```










---

## 作者：fanfan (赞：2)

这题模拟即可A掉

用a数组来记录结尾为i的数时字符串的长度

找出输入数据中最大的数，算出来，找到合适的位置

f（x）代表从开头为1的字符串一直向后数，数到位置x时的数字为多少。

注意a[pp]>b[i]的时候pp-1，然后b[i]-a[pp]就是从数字1往后数的个数。

特判a[pp]==b[i]的时候直接输出pp%10（就是当前数字的最后一位就是答案）

        
        
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long a[31269];
int b[15],maxn;
int lg10(int x)
{
    if(x>=1&&x<=9)
    return 1;
    if(x>=10&&x<=99)
    return 2;
    if(x>=100&x<=999)
    return 3;
    if(x>=1000&&x<=9999)
    return 4;
    return 5;
}
int f(int x)
{
    if(x>=1&&x<=9)
    return x;
    int tmp=0,num=0;
    while(tmp<x)
    {
        num++;
        tmp+=lg10(num);
    }
    if(tmp==x)
    return num%10;
    tmp=tmp-x;
    for(int i=1;i<=tmp;++i)
    {
        num/=10;
    }
    return num%10;
}
int main()
{
    int nn;
    scanf("%d",&nn);
    for(int i=1;i<=nn;++i)
    {
        scanf("%d",b+i);
        maxn=max(maxn,b[i]);
    }
    a[1]=1,a[2]=3;
    int sum=3,num=2;
    while(sum<maxn)
    {
        num++;
        sum+=(a[num-1]-a[num-2])+lg10(num);
        a[num]=sum;
    }
    for(int i=1;i<=nn;++i)
    {
        int pp=1;
        while(a[pp]<b[i])
        pp++;
        if(a[pp]!=b[i])
        {pp--;printf("%d\n",f(b[i]-a[pp]));}
        else printf("%d\n",pp%10);
    }
}
```

---

## 作者：LightningUZ (赞：1)

先B一句：
## C++大法好

B完了，现在来讲一下这道题的思路。

定义一个sum函数,sum(n)=112123123412345123456………………12345……n的长度

怎么求呢？求出n里有多少个一位数，两位数，三位数，四位数……，加权

然后求出n是几位数，加权，最后返回值。

代码：
```cpp
ll pow10[10]=
{
	1,10,100,1000,10000,100000,
	1000000,10000000,100000000,
	1000000000
};
//打表快速幂
ll digit(ll x)//求x是几位数
{
	ll ans=0;
	while(x!=0)
	{
		ans++;
		x/=10;
	}
	return ans;
}
ll sum(ll x)
{
	ll ans=0;
	ll len=digit(x);
	for(ll i=1;i<len;i++)
	{
		ans+=9*pow10[i-1]*i;
        /*
        1~9 9个数
        10~99 90个数
        100~999 900个数
        ……
        故9*pow10[i-1]为数字的数量
       	再*i即为位数和
        */
	}
	ll rest=x-pow10[len-1]+1;
    //剩下rest个数
	ans+=rest*len;//rest*len即为剩下的位数
	return ans;
}
```
### 注意：要开longlong,防RE

然后计算加到第几个末尾，剩余几个数。举例：n=46

数列：112123123412345123456123456712345678123456789123……
故加到了第9个末尾，剩余1个数。这用一个while循环就可以解决。

代码：
```
		ll x;
		scanf("%lld",&x);
		ll s=0;
		ll tmp=0;
		while(s<x)
		{
			tmp++;
			s+=sum(tmp);
		}
		s-=sum(tmp);
		tmp--;//记得减回来
        ll rest=x-s;
```
此时的tmp就是加到了第tmp个末尾，rest就是还剩rest位

那么，剩下的rest位怎么办呢？用stringstream暴力求出来即可

code:
```cpp
		stringstream ss;
		for(int i=1;i<=tmp+1;i++)
		{
			ss<<i;
		}
		string str;
		str=ss.str();
		putchar(str[rest-1]);
        //str[rest-1]就是答案
		putchar('\n');
```

完整代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll pow10[10]=
{
	1,10,100,1000,10000,100000,
	1000000,10000000,100000000,
	1000000000
}; 
ll digit(ll x)
{
	ll ans=0;
	while(x!=0)
	{
		ans++;
		x/=10;
	}
	return ans;
}
ll sum(ll x)
{
	ll ans=0;
	ll len=digit(x);
	for(ll i=1;i<len;i++)
	{
		ans+=9*pow10[i-1]*i;
	}
	ll rest=x-pow10[len-1]+1;
	ans+=rest*len;
	return ans;
}
int main()
{
	ll t;
	scanf("%lld",&t);
	while(t--)
	{
		ll x;
		scanf("%lld",&x);
		ll s=0;
		ll tmp=0;
		while(s<x)
		{
			tmp++;
			s+=sum(tmp);
		}
		s-=sum(tmp);
		tmp--;
		//加到第tmp个整位置
		ll rest=x-s;//剩余位数 
		stringstream ss;
		for(int i=1;i<=tmp+1;i++)
		{
			ss<<i;
		}
		string str;
		str=ss.str();
		putchar(str[rest-1]);
		putchar('\n');
	}
	return 0;
} 
```

---

## 作者：B_Qu1e7 (赞：1)

对于预处理，其实只是对于时间上的节省。

那么，这里给一条节省空间的题解。

半个数组都没开，其实这是一道及其简单的 %你 题

```cpp
#include<cstdio>
int T,n,s;
inline int ws(int x)//算某个数位数
{
    int w=0;
    while(x)x/=10,w++;
    return w;
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        int tot=0;
        s=1;//当前减去的数
        scanf("%d",&n);
        tot+=ws(s);//tot累加s的位数
        while(n>=tot)//处理，n循环减去s的位数
        {
            n-=tot;
            s++;
            tot+=ws(s);
        }
        //直到n比1……s的位数小为止。
        if(!n)//n减完了，也就是112123...s-1这个数列的第一位就是答案（想一想，为什么是第一位？）
        {
            s--;
            while(s>=10)s/=10;
            printf("%d\n",s);
            continue;
        }
        //接下来对于1...s数列第n位进行查找（n已被减过）
        s=1;//减去1的2的3的 ...的位数
        while(n>=ws(s))
        {
            n-=ws(s);
            s++;
        }
        if(!n)//刚好减完，就是最后一个数字的最后一位
        {
            printf("%d\n",(s-1)%10);
            continue;
        }
        while(ws(s)>n)s/=10;//否则就是这个数字第n位
        printf("%d\n",s%10);
    }
}
```

---

## 作者：yuqihao (赞：0)

# P1895 数字序列题解

## 题意

求在序列 $11212312341234512345612345671234567812345678912345678910⋯$ 中的第 $n$ 个数字是多少。

## 分析

在这里我们要使用一个叫 `to_string` 的函数，它可以直接把 `int` 类型转为 `string` 类型，然后就可以上暴力了。

在暴力之前，我们还要来算一下时间复杂度。

```cpp
cin>>n;
long long ans=0;
string s;
for(int i=1;i<=n;i++){
    s+=to_string(i),ans+=s.size();
}
int t=clock();//clock()函数永远获取当前程序运行了多少ms
cout<<t;
```

然后我们输入 $2^{31}-1$，就能看到输出为 `15`，轻轻松松 A 掉。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n;
long long ans=0;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		ans=0;
		string s;
		for(int i=1;1;i++){
			s+=to_string(i),ans+=s.length();
			if(ans>=n){
				ans-=s.length();
				cout<<s[n-ans-1]<<endl;
				break;	
			}
		}
	}
    return 0;
}
```



---

## 作者：Escapism (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1895)

# 题意

简单明了：求 $112123123412345......$ 的第 $n$ 个数字。


# 思路

思路其实并不难想，我们把这个数拆成若干个首尾相连的数：

$1$ $12$ $123$ $1234$ $12345$ $123456$ $1234567......$


这样我们就可以很方便的统计每个数的位数了。由于打表太长了，所以我们只能预处理，把这些数存在 $a$ 数组里。。

我们先计算出第 $n$ 位在第几个数里。然后我们再进行一次处理，计算出 $n$ 是这个数里面的第几位。

我们可以举个例子：

如果 $n = 13$,那么先算出 $13$ 在第五个数里。然后我们通过预处理算出的数组再进行一次处理，因为显然后面的数都包含前面的数，所以我们可以直接通过之前算出的数组进行处理。

然后，根据以上方法，我们可以求出第 $13$ 位是 $3$。

当然，我们还可以进行优化。例如通过二分答案进行优化。

# 代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;

int t,n,a[1000005];
void PRE(){
    	for(int i = 1;i < 10;i++) a[i] = a[i - 1] + 1;
	for(int i = 10;i < 100;i++) a[i] = a[i - 1] + 2;
	for(int i = 100;i < 1000;i++) a[i] = a[i - 1] + 3;
	for(int i = 1000;i < 10000;i++) a[i] = a[i - 1] + 4;
	for(int i = 10000;i < 100000;i++) a[i] = a[i - 1] + 5;
}

int main(){
    PRE();
	cin>>t;
	for (int i = 1;i <= t;i++){
		cin>>n;
		int sum = 0,cnt1 = 0,cnt2 = 0;
		while(true){
			sum += a[++cnt1];
			if(sum >= n) break;
		}
		n -= (sum - a[cnt1]);
		while(true) if(a[++cnt2] >= n) break;
		cout<<(int)(cnt2 / pow(10,a[cnt2] - n)) % 10<<endl ;
	}
	return 0;
}
```
# 优化

优化方法中，我们最容易想到的就是二分查找。即查找第一个大于 $n$ 的数位和。

二分查找的条件：

---
- 答案在一个固定区间内；

- 可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；

- 可行解对于区间满足一定的单调性。换言之，如果 $x$ 是符合条件的，那么有 $x$ 或者 $x$ 也符合条件。（这样下来就满足了上面提到的单调性）

---

来自 Wiki。

显然，这道题满足所有的条件。

为了二分查找，我们先打一个前缀和，查找第一个大于 $n$ 的前缀和，然后减去上一位。

然后再用预处理的存储数位的数组，再进行一次二分查找，查找第一位大于 $n$ 的数位和。

代码太丑了，就不放了。



---

## 作者：sid_shi1 (赞：0)

## 思路：
这是一道很棒的模拟题。

题目描述中的序列 $112123123412345......$ ，不难发现是由许多个小序列组成的，小序列为“ $1$ ”、“ $1$ ”、“ $123$ ”、“ $1234$ ”......以此类推。

接下来我们可以每一个一个序列单独地推，能用完还有位置的话就继续推，否则用完了话就停下来。

然后就枚举最后一个序列中的每一个数，在再从而枚举每一个字符（也就是单独的数位）。到达了话就输出，并退出循环；没到了话就继续枚举，直到枚举到题目的要求的答案为止。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int x;
void wei(int y){//枚举每一个数字的每一个字符
	if(y>9) wei(y/10);
	if(x>0){
		x--;
		if(x==0) printf("%d\n",y%10);//输出
	}
}
int main(){
	int T;
	scanf("%d",&T);//读入
	for(int i=1;i<=T;i++){
		int t=1,sum=1;
		scanf("%d",&x);//读入
		while(x>sum){//枚举前面的每一段序列
			x-=sum;
			int k=(++t);
			while(k>0){//枚举每一位
				sum++;
				k/=10;
			}
		}
		if(x==sum) printf("%d\n",t%10);//刚好全部打完，没有剩余
        //枚举序列的每一个数字，到了就输出并退出
		else for(int i=1;i<=t && x>0;i++) wei(i);//枚举每一个数字的每一个字符
	}
	return 0;
}
```

---

## 作者：_Spectator_ (赞：0)

我们可以把 “$112123123412345123456……n$” 分解成：

$1$ $12$ $123$ $1234$ $12345$ $123456$ $......$ $123$ $……$ $n$

那我们首先想到的是**对每一个子序列的长度进行求解**：

经过实践，我们可以发现一个规律：
**当这个数是 $n$ 位数时：$len_i=len_{i-1}+n$**

这个预处理是非常简单的，代码如下：

```cpp
for(int j=1; j<=9; j++) 
	len[j]=len[j-1]+1;
for(int j=10; j<=99; j++) 
	len[j]=len[j-1]+2;
for(int j=100; j<=999; j++) 
	len[j]=len[j-1]+3;
for(int j=1000; j<=9999; j++) 
	len[j]=len[j-1]+4;
for(int j=10000; j<=99999; j++)
	len[j]=len[j-1]+5;
```


------------


### 总体思路：
---
1. 判断 $n$ 处于哪一个子序列中（假设在第 $i$ 个子序列中）。
2. 计算 $n$ 是第 $i$ 个子序列的第几个字符。
3. 每次给第 $i$ 个子序列添加一个数（原来为空），如果该子序列的长度已经达到了 $n$ ，那么就输出该子序列的第 $n$ 个字符。

---
### 完整代码：
---
```cpp 
#include<bits/stdc++.h>
using namespace std;
long long t,n,sum=0,i=0;
int len[100010];
string s;
inline string zs(int a)//把一个 int 数值转换成 string 类 
{
	string s="\0";
	while(a>0)
	{
		s+=a%10+48;
		a/=10;
	}
	for(int i=0; i<s.size()/2; i++)
		swap(s[i],s[s.size()-1-i]);
	return s;
}
int main()
{
	cin>>t;
	//------预处理------// 
	for(int j=1; j<=9; j++)
		len[j]=len[j-1]+1;
	for(int j=10; j<=99; j++) 
		len[j]=len[j-1]+2;
	for(int j=100; j<=999; j++)
		len[j]=len[j-1]+3;
	for(int j=1000; j<=9999; j++) 
		len[j]=len[j-1]+4;
	for(int j=10000; j<=99999; j++) 
		len[j]=len[j-1]+5;
		
	for(int g=1; g<=t; g++)
	{
		cin>>n;
		s="",sum=0,i=0;//记得把要重复使用的变量清零 
		while(sum<n) 
        		sum+=len[++i];//Step1 
		n-=sum-len[i];//Step2
		i=1;
		while(1)//Step3
		{
			string s2=zs(i);
			s=s+s2;
			if(s.size()>=n)
			{
				cout<<s[n-1]<<"\n";
				break;
			}
			i++;
		}	
	}

	return 0;
}
```
---
说明：本人乃2016级小学生，思路比较简单，题解如有写的不好的地方请指正。写这篇题解是为了巩固一下，因为查错查了很久。

---


# 矩阵加速（数列）

## 题目描述

已知一个数列 $a$，它满足：  

$$
a_x=
\begin{cases}
 1 & x \in\{1,2,3\}\\ 
 a_{x-1}+a_{x-3} & x \geq 4
\end{cases}
$$

求 $a$ 数列的第 $n$ 项对 $10^9+7$ 取余的值。


## 说明/提示

- 对于 $30\%$ 的数据 $n \leq 100$；
- 对于 $60\%$ 的数据 $n \leq2 \times 10^7$；
- 对于 $100\%$ 的数据 $1 \leq T \leq 100$，$1 \leq n \leq 2 \times 10^9$。

## 样例 #1

### 输入

```
3
6
8
10
```

### 输出

```
4
9
19
```

# 题解

## 作者：奔波儿霸 (赞：183)

#### 解题思路

这道题目的关键之处在于构造初始矩阵，题目都告诉我们了要用矩阵加速。所以矩阵快速幂是核心所在。

#### 如何构造

我们首先要确定目标矩阵。下面这个矩阵就是我想要的矩阵.
$$\begin{bmatrix}F[i]\\F[i-1]\\F[i-2]\end{bmatrix}$$

那么这个矩阵要怎样算出来。根据题目给出的递推式可以得到下面三个式子
$$f[i] = f[i-1] \times 1 + f[i-2] \times 0 + f[i-3] \times 1$$
$$f[i-1] = f[i-1] \times 1 + f[i-2] \times 0 + f[i-3] \times 0$$
$$f[i-2] = f[i-1] \times 0 + f[i-2] \times 1 + f[i-3] \times 0$$

通过每一项的系数可以得出初始矩阵为
$$\begin{bmatrix}1&0&1\\1&0&0\\0&1&0\end{bmatrix}$$

然后我们就可以通过矩阵快速幂进行求解。

值得注意的是，这个矩阵的$N$次方算出来的第一个元素是$F[N+1]$,这样的话我们可以直接在输出的时候输出第二行第一个元素。

#### 附上代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

typedef long long LL;
const int Mod = 1e9+7;
int T, n;
struct mat{
	LL m[5][5];
}Ans, base;
inline void init() {
	memset(Ans.m, 0, sizeof(Ans.m));
	for(int i=1; i<=3; i++) Ans.m[i][i] = 1;
	memset(base.m, 0, sizeof(base.m));
	base.m[1][1] = base.m[1][3] = base.m[2][1] = base.m[3][2] = 1;
}
inline mat mul(mat a, mat b) {
	mat res;
	memset(res.m, 0, sizeof(res.m));
	for(int i=1; i<=3; i++) {
		for(int j=1; j<=3; j++) {
			for(int k=1; k<=3; k++) {
				res.m[i][j] += (a.m[i][k] % Mod) * (b.m[k][j] % Mod);
				res.m[i][j] %= Mod;
			}
		}
	}
	return res;
}
inline void Qmat_pow(int p) {
	while (p) {
		if(p & 1) Ans = mul(Ans, base);
		base = mul(base, base);
		p >>= 1;
	}
}

int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d", &n);
		if(n <= 3) {
			printf("1\n");
			continue;
		}
		init();
		Qmat_pow(n);
		printf("%lld\n", Ans.m[2][1]);
	}
}
/*
f[i-1]       f[i]
f[i-2] ----> f[i-1]
f[i-3]       f[i-2]
f[i] = f[i-1] * 1 + f[i-2] * 0 + f[i-3] * 1
f[i-1] = f[i-1] * 1 + f[i-2] * 0 + f[i-3] * 0
f[i-2] = f[i-1] * 0 + f[i-2] * 1 + f[i-3] * 0
so
1 0 1
1 0 0
0 1 0
*/
```

---

## 作者：JRzyh (赞：71)

从矩阵基础讲起。

$$\large\texttt{Part 1 基础}$$

$\large\texttt{定义}$

由 $n\times m$ 个数排成 $m$ 行 $n$ 列矩形的数表


$$

\left(\begin{array}{cc}
a_{11}&a_{12}&\cdots&a_{1n}\\
a_{21}&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m1}&a_{m2}&\cdots&a_{mn}\\
\end{array}\right)

$$

称为一个 $m\times n$ 的矩阵，记作 $A$。其中 $a_{ij}$ 称为第 $i$ 行第 $j$ 列的元素。


$\large\texttt{特殊矩阵}$

$\texttt{零矩阵}$

所有元素都是零的矩阵。

$$

\left(\begin{array}{cc}
0&0&\cdots&0\\
0&0&\cdots&0\\
\vdots&\vdots&\ddots&\vdots\\
0&0&\cdots&0\\
\end{array}\right)

$$

记为 $\texttt{0}$ 。$^{(1)}$

$\texttt{对角矩阵}$

在一个 $n\times n$ 的矩阵里，只有主对角线有值。

$$

\left(\begin{array}{cc}
a_{11}&0&\cdots&0\\
0&a_{22}&\cdots&0\\
\vdots&\vdots&\ddots&\vdots\\
0&0&\cdots&a_{nn}\\
\end{array}\right)

$$

$\texttt{单位矩阵}$

一个对角矩阵切对角线上都是 $1$。

$$

\left(\begin{array}{cc}
1&0&\cdots&0\\
0&1&\cdots&0\\
\vdots&\vdots&\ddots&\vdots\\
0&0&\cdots&1\\
\end{array}\right)

$$

记作 $I$ 。

$\texttt{上三角矩阵}$

只有右上的一部分有值，主对角线以下都是 $0$。

$$

\left(\begin{array}{cc}
a_{11}&a_{12}&\cdots&a_{1n}\\
0&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
0&0&\cdots&a_{nn}\\
\end{array}\right)

$$

主要的特殊矩阵就这些。$^{(2)}$

$\large\texttt{矩阵运算}$

$\texttt{相等}$

矩阵 $A,B$ 相等当且仅当他们大小相等且对于所有 $ij$ 都有 $a_{ij}=b_{ij}$

官方定义，总结成一句话，就是他们长的一模一样。

$$
\left(\begin{array}{cc}
a_{11}&a_{12}&\cdots&a_{1n}\\
a_{21}&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m1}&a_{m2}&\cdots&a_{mn}\\
\end{array}\right)=\left(\begin{array}{cc}
a_{11}&a_{12}&\cdots&a_{1n}\\
a_{21}&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m1}&a_{m2}&\cdots&a_{mn}\\
\end{array}\right)

$$

$\texttt{矩阵加法}$

若 $C=A+B$ 则对于所有 $ij$ 都有 $c_{ij}=a_{ij}+b_{ij}$ 。

要求 $A$ 的大小要等于 $B$ 的大小。

总结成一句话，一个一个加。

$$
\left(\begin{array}{cc}
a_{11}&a_{12}&\cdots&a_{1n}\\
a_{21}&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m1}&a_{m2}&\cdots&a_{mn}\\
\end{array}\right)+\left(\begin{array}{cc}
b_{11}&b_{12}&\cdots&b_{1n}\\
b_{21}&b_{22}&\cdots&b_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
b_{m1}&b_{m2}&\cdots&b_{mn}\\
\end{array}\right)=\left(\begin{array}{cc}
a_{11}+b_{11}&a_{12}+b_{12}&\cdots&a_{1n}+b_{1n}\\
a_{21}+b_{21}&a_{22}+b_{22}&\cdots&a_{2n}+b_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m1}+b_{m1}&a_{m2}+b_{m2}&\cdots&a_{mn}+b_{mn}\\
\end{array}\right)

$$

减同理。

$\texttt{矩阵的数量乘法}$

用一个数 $k$ 去乘 $A$ 就等于 $k$ 成他的每一位。

总结成一句话，一个一个乘。


$$
k\left(\begin{array}{cc}
a_{11}&a_{12}&\cdots&a_{1n}\\
a_{21}&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{m1}&a_{m2}&\cdots&a_{mn}\\
\end{array}\right)=\left(\begin{array}{cc}
ka_{11}&ka_{12}&\cdots&ka_{1n}\\
ka_{21}&ka_{22}&\cdots&ka_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
ka_{m1}&ka_{m2}&\cdots&ka_{mn}\\
\end{array}\right)

$$

$\texttt{矩阵乘法}$

首先要求 $A$ 的列数要等于 $B$ 的行数。

若 $A=(a_{ij})_{m\times r}$ ，$B=(b_{ij})_{r\times n}$，则乘出的矩阵大小是 $C=(c_{ij})_{m\times n}$

其中 

$$c_{ij}=\sum_{k=1}^n a_{ik}·b_{kj}$$

称为 $A$ 与 $B$ 的乘积，记做 $C=AB$。$^{(3)}$

矩阵乘法的性质：

任何矩阵乘 $\texttt{0}$ 得 $\texttt{0}$：$\texttt{0}A=A\texttt{0}=\texttt{0}$

任何矩阵乘 $I$ 得本身：$IA=AI=A$

结合律：$A(BC)=(AB)C$

左分配律：$A(B+C)=AB+AC$

右分配律：$(B+C)A=BA+CA$

注意矩阵乘法没有交换律。

$$\large\texttt{Part 2 应用}$$

$\large\texttt{矩阵快速幂}$

求一个矩阵 $A$ 的 $k$ 次方。

现在来分析一下问题，就是求：

$$
\begin{matrix} n \\ \overbrace{ A\times A\times A\times A\times \dots\times A } \end{matrix}
$$

根据结合律：

$$
\begin{matrix} \frac{n}{2} \\ \overbrace{ ( A\times A\times \dots\times A) } \end{matrix}
\begin{matrix} ~~~\frac{n}{2} \\\times \overbrace{ (A\times A\times \dots\times A) } \end{matrix}
$$

就是 $(A^{\frac{n}{2}})^2$

分治快速幂的性质仍然在。$^{(4)}$

就和快速幂一样做就好了

$\large\texttt{斐波那契数列}$

精典！

构造一个 $1\times 2$ 的矩阵：

$$
\left(\begin{array}{cc}
F_{2}&F_{1}\\
\end{array}\right)
$$

和一个 $2\times 2$ 的矩阵：

$$
\left(\begin{array}{cc}
1&1\\
1&0\\
\end{array}\right)
$$

两个做矩阵乘法：

$$c_{11}=\sum_{k=1}^n a_{ik}·b_{kj}=a_{11}\times b_{11}+a_{12}\times b_{21}=F_2+F_1=F_3$$

$$c_{12}=\sum_{k=1}^n a_{ik}·b_{kj}=a_{11}\times b_{12}+a_{12}\times b_{22}=F_2$$

结果是

$$
\left(\begin{array}{cc}
F_{3}&F_{2}\\
\end{array}\right)
$$

看到没有，往前推了一位，我们只需要将他乘 $n-1$ 个矩阵，就能得到答案，这样就可以用快速幂求。

$\large\texttt{矩阵加速}$

搞一道例题

$F_x= \begin{cases} 1 & x \in\{1,2,3\}\\ F_{x-1}+F_{x-3} & x \geq 4 \end{cases}$

求 $F_x$ 。

还是需要两个矩阵，其中一个当然是

$$
\left(\begin{array}{cc}
F_{3}&F_{2}&F_{1}\\
\end{array}\right)
$$

现在看看如何构造出单位矩阵。

下面一个表格，展示了他每行每列的意义

|  | $F_{k-1}$ | $F_{k-2}$ | $F_{k-3}$ |  
| -----------: | -----------: | -----------: | -----------: |
| $F_{k}~$ |  |  |  |
| $F_{k-1}$ |  |  |  |
| $F_{k-2}$ |  |  |  |

他里面要填什么呢？

显然 $F_{k}=1\times F_{k-1}+0\times F_{k-2}+1\times F_{k-3}$

所以第一行是

|  | $F_{k-1}$ | $F_{k-2}$ | $F_{k-3}$ |  
| -----------: | -----------: | -----------: | -----------: |
| $F_{k}~$ | $1$ | $0$ | $1$ |
| $F_{k-1}$ |  |  |  |
| $F_{k-2}$ |  |  |  |

$F_{k-1}=1\times F_{k-1}+0\times F_{k-2}+0\times F_{k-3}$

$F_{k-2}=0\times F_{k-1}+1\times F_{k-2}+0\times F_{k-3}$

表填完是

|  | $F_{k-1}$ | $F_{k-2}$ | $F_{k-3}$ |  
| -----------: | -----------: | -----------: | -----------: |
| $F_{k}~$ | $1$ | $0$ | $1$ |
| $F_{k-1}$ | $1$ | $0$ | $0$ |
| $F_{k-2}$ | $0$ | $1$ | $0$ |

单位矩阵就求得了。

$$
\left(\begin{array}{cc}
1&0&1\\
1&0&0\\
0&1&0\\
\end{array}\right)
$$

$(1):$ 为了和数字分开本文记作 `\texttt{0}`（不是 `O` ），但正常情况下应该是 `0` 。

$(2):$ 还有纯量矩阵，对称矩阵，下三角矩阵等，用的不多，不讲了。

$(3):$ 也有做 $A\times B$，$A·B$ 的。

$(4):$ 其实快速幂分两种，常见的是二进制快速幂，经常有人把他们混为一谈。分治快速幂的基础是 $(a^{\frac{n}{2}})^2=a$ 。二进制快速幂是 $\sum 2^{k_i}=n$ 则 $\prod a^{(2^{k_i})}=a^n$ 。

---

## 作者：Beau_Kang (赞：58)

这是本蒟蒻第一篇题解 希望审核过吧

关于这道题目 主要难点还是在于初始矩阵的推导 另外一道相似的斐波那契 也是同样


我们可以发现这道题目的推导是这样的

由
F[i-1] , F[i-2] , F[i-3]

这个状态 推至

F[i] , F[i-1] , F[i-2]

这个矩阵的推导 可以知道是这样的：

           F[i]=F[i-1]*1+F[i-2]*0+F[i-3]*1;

所以矩阵的第一列 应该是 1 0 1;

           F[i-2]=F[i-1]*0+F[i-2]*1+F[i-3]*0;

所以矩阵第二列 应该是 0 1 0;

同样 F[i-3]=F[i-1]*0+F[i-2]*0+F[i-3]*1;

所以矩阵第三列便是 0 0 1;


所以说 我们通过对前后矩阵的推导 便可以得到一个3\*3的矩阵：

1 0 0

0 1 0

1 0 1

然后就是矩阵快速幂的模板了 (如果还不会的话快去刷模板)

当然了 关于矩阵的推导有很多不同的思路 不过我只是把我的详细思路和想法呈现出来

仔细想 认真打 还是可以打出来的


上代码  略丑。。




```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<vector>
#include<cstdio>
#include<cmath>
#include<queue>
#include<stack>
#include<map>
#include<set>
using namespace std;
struct sj{
   long long a[4][4];
}ss;
int k,t;
sj X(sj s,sj kk)
{
    sj cx;
    memset(cx.a,0,sizeof(cx.a));
    for(int i=1;i<=3;i++)
    for(int j=1;j<=3;j++)
    for(int k=1;k<=3;k++)
    {
        cx.a[i][j]+=(s.a[i][k]*kk.a[k][j])%1000000007;
        cx.a[i][j]%=1000000007;
    }
    return cx;
}
sj quick_pow(sj kk,int n)
{
    if(n<=1)return kk;
    sj cx=kk; n--; 
    while(n>0)
    {
        if(n%2==1)
        cx=X(cx,kk);
        n/=2;
        kk=X(kk,kk);
    }
    return cx;
}
int main()
{
    memset(ss.a,0,sizeof(ss.a));
    ss.a[1][1]=1;
    ss.a[3][1]=1;
    ss.a[1][2]=1;
    ss.a[2][3]=1;
    cin>>t;
    for(int i=1;i<=t;i++)
    {
    scanf("%d",&k);
    sj kks; 
    memset(kks.a,0,sizeof(kks.a));
    kks=quick_pow(ss,k-1);
    cout<<kks.a[1][1]<<endl;
    }
}
```

---

## 作者：kpl000 (赞：34)

首先在做这道题之前你需要将  矩阵快速幂  <https://www.luogu.org/problemnew/show/3390>这题A掉，并且深刻的理解如何   构造矩阵  <http://www.cnblogs.com/frog112111/archive/2013/05/19/3087648.html> 把这些准备做好后，我们开始看题。

题目给出了一个递推关系式a[1]=a[2]=a[3]=1，a[x]=a[x-3]+a[x-1] (x>3)，我们需要求它的第n项取模的结果，初看这道题，也许会不经意像起斐波那契数列，的确这个通项公式很像，那么小数据n<100暴力求解一定能过；那更高分呢，在没学矩阵乘法快速幂之前，完全想不到这与那个有什么关系（建议去看看大学的线性代数，会有更深的理解），事实上这道题如果能想到矩阵加速那么就只剩下如何构造矩阵了，这是最关键的：

我们可以这样思考，题目给出了初始条件 a[1]=a[2]=a[3]=1,这很重要，然后我们可以进行一次推算，算出a[4],事实上这已经进行了一次矩阵乘法，如下图：

 ![](https://cdn.luogu.com.cn/upload/pic/10791.png) 

然后套用矩阵乘法快速幂就行了，完美。

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<cmath>
#define LL long long
#define mod 1000000007
using namespace std;
LL T,n,k;
struct pl{
    LL a[105][105];
}p,pp;
pl work(pl work,pl y)           //矩阵乘法
{
    pl box;
    memset(box.a,0,sizeof(box.a));
    for(LL i=1;i<=3;i++)
    {
        for(LL k=1;k<=3;k++)
        {
            if(work.a[i][k])
            for(LL j=1;j<=3;j++)
            {
                box.a[i][j]=(box.a[i][j]+(work.a[i][k]*y.a[k][j])%mod)%mod;
            }
        }
    }
    return box;
}
pl fastpow(LL kk)             //快速幂
{
    pl ans;
    memset(ans.a,0,sizeof(ans.a));
    for(LL i=1;i<=3;i++) ans.a[i][i]=1;
    while(kk)
    {
        if(kk&1) ans=work(ans,p);
        kk>>=1;
        p=work(p,p);
    }
    return ans;
}
int main()
{
    scanf("%lld",&T);
    while(T--)
    {
        memset(p.a,0,sizeof(p.a));
        p.a[1][3]=p.a[2][1]=p.a[3][2]=p.a[3][3]=1;
        scanf("%lld",&k);
        if(k<=3) printf("1\n");
        else
        {
            pp=fastpow(k-3);
            /*for(LL i=1;i<=3;i++)
            {
                for(LL j=1;j<=3;j++)
                printf("%lld ",pp.a[i][j]);   
                printf("\n");
            } */
            printf("%lld\n",(pp.a[1][3]+pp.a[2][3]+pp.a[3][3])%mod);  //因为初始状态为 a[1]=1,a[2]=1,a[3]=1,都为1，就没必要再做一次矩阵乘法了不，太麻烦了
        }
    }
    return 0;
}
```

---

## 作者：Orzalpha (赞：23)

## 这里提供一种不一样的加速矩阵

我看了一下题解，发现大佬们提供的矩阵都大同小异。但是我在做这道题的时候手推出了一种和很多人都不一样的做法。

我当时推导的时候是这么想的：

$$\begin{bmatrix}a_4 & a_5 & a_6  \end{bmatrix} = \begin{bmatrix} a_1 & a_2 & a_3 \end{bmatrix} × \begin{bmatrix} 1 & 1 &1\\ 0 & 1 & 1 \\ 1 & 1 & 2\end{bmatrix}$$

具体的想法是这样的:

$$ a_4=a_1+a_3 $$
$$ a_5=a_4+a_2=a_1+a_2+a_3 $$
$$ a_6=a_5+a_3=a_1+a_2+2a_3 $$
于是根据矩阵乘的原理，我就写出了这么一个~~看上去十分恶心~~的式子。

可以根据上面提供的最简单的式子推出通式，这里不再给出。

~~Markdown矩阵是真难写~~

用于加速的矩阵就是下面这个：

$$  \begin{bmatrix} 1 & 1 &1\\ 0 & 1 & 1 \\ 1 & 1 & 2\end{bmatrix} $$

这里需要注意的是，对于给定的n，它的指数是(n-1)/3（当然要下取整啦），然后取出得到的矩阵的第n%3项（如果是0就取第3项啊）。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define mod 1000000007
#define LL long long
using namespace std;
struct squ{int x,y;LL w[4][4];}base={1,3,{{},{0,1,1,1}}},acc={3,3,{{},{0,1,1,1},{0,0,1,1},{0,1,1,2}}},ans;
int t,n;
void multi(squ &c,squ a,squ b)
{
	c.x=a.x;c.y=b.y;
	memset(c.w,0,sizeof(c.w));
	for(int i=1;i<=c.x;i++)
	for(int j=1;j<=c.y;j++)
	for(int k=1;k<=a.y;k++)
	c.w[i][j]=(c.w[i][j]+a.w[i][k]*b.w[k][j])%mod;
	return;
}
squ ksm(int k)
{
	if(k==1) return acc;
	squ tmp=ksm(k/2),sum;
	multi(sum,tmp,tmp);
	if(k%2) multi(sum,sum,acc);
	return sum;
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		switch(n)
		{
			case 1:
			case 2:
			case 3:printf("1\n");break;
			default:{
				multi(ans,base,ksm((n-1)/3));
				int x=n%3;if(!x) x=3;
				printf("%d\n",ans.w[1][x]);
				break;
			}
		}
	}
	return 0;
}
```
~~忽略我奇丑的码风~~

---

## 作者：Trinitrotoluene (赞：21)

### 楼上的大佬写的都是矩阵快速幂，我就不再进行讲解了

俗话说：“殊途同归”。因此，一个题的解法显然有很多。~~毕竟就连[a+b](https://www.luogu.org/problemnew/solution/P1001)也有LCT、Splay等~~

下面，我将介绍一个~~神奇的~~解法。

## 过程如下：

根据递推，我们可以得到以下式子： 

$$\text{F(2$\times$n)=3$\times$F(2$\times$n$-$4)$+$F(2$\times$n$-$5)$+$2$\times$F(2$\times$n$-$6)}$$

而我们知道，F(3)$=$1，F(4)$=$2，F(5)$=$3。因此

$$\text{F(2$\times$n)=F(5)$\times$F(2$\times$n$-$4)$+$F(3)$\times$F(2$\times$n$-$5)+F(4)$\times$F(2$\times$n$-$6)}$$

将 F(2$\times$n$-$4)$=$F(2$\times$n$-$5)$+$F(2$\times$n$-$7) 代入，则

$$\text{F(2$\times$n)=[F(3)+F(5)]$\times$F(2$\times$n$-$5)$+$F(4)$\times$F(2$\times$n$-$6)$+$F(5)$\times$F(2$\times$n$-$7)}$$

而 F(3)$+$F(5)$=$F(6)，故：

$$\text{F(2$\times$n)=F(6)$\times$F(2$\times$n$-$5)$+$F(4)$\times$F(2$\times$n$-$6)$+$F(5)$\times$F(2$\times$n$-$7)}$$

因此，由数学归纳法可知：

$$\text{F(2$\times$n)=F(n+1)$\times$F(n)$+$$F(n-1)^2$$+$F(n)$\times$F(n-2)}$$

将 F(n-2) = F(n+1) - F(n) 代入，可得：

$$\text{F(2$\times$n)=2$\times$F(n+1)$\times$F(n)$-$$F(n)^2$$+$$F(n-1)^2$}$$

另一个同理可得。

### 因此，我们可以得出以下结论：

$$\text{F(2$\times$n)=2$\times$F(n+1)$\times$F(n)$-$$F(n)^2$$+$$F(n-1)^2$}$$

$$\text{F(2$\times$n+1)=$F(n+1)^2$+2$\times$F(n)$\times$F(n-1)}$$

由此，我们可以得到以下代码：
```cpp
#include<cstdio>
typedef long long ll;
const int M=1e9+7;
ll g(ll x)	{return x*x%M;}
ll f(int x){
	if(x<4)	return 1;
	if(x&1)	return (g(f(x+1>>1))+(f(x-1>>1)*f(x-3>>1)<<1))%M;
	return ((f(x+2>>1)*f(x>>1)<<1)-g(f(x>>1))+g(f(x-2>>1)))%M;
}
inline int r(){
    int p=0;char c=getchar();
    while(c<48||c>57)	c=getchar();
    while(c<58&&c>47)	p=(p<<1)+(p<<3)+(c^48),c=getchar();
    return p;
}
int main(){
	int t=r();
	while(t--)	printf("%lld\n",f(r()));
	return 0;
}
```
但是，将上述代码提交后，我们发现：TLE了7个点。

究其原因，我们会发现：有些数字我们进行了大量的重复运算。

因此，我们可以考虑将得到的数字记录下来。当然，数组无法开这么大,但是也不需要将每个数都记录下来。因此，我们可以考虑使用map。

### 下面，便是核心代码：
```cpp
ll f(int x){
	if(!a[x])
		if(x<4)	a[x]=1;
		else if(x&1)	a[x]=g(f(x+1>>1))+(f(x-1>>1)*f(x-3>>1)<<1);
		else a[x]=(f(x+2>>1)*f(x>>1)<<1)-g(f(x>>1))+g(f(x-2>>1));
	return a[x]%M;
}
```
~~相信各位神犇都已看懂~~

## 总结：

这种解法只在特定的条件下成立，并且由于map的常数问题，这种解法也跑得比矩阵快速幂慢。但是，对于那些对矩阵快速幂不熟的人来说，这也不失为一种新的解法。~~话说来这题的dalao不会矩阵快速幂吗~~

最后，祝大家：CSP-2019 rp++！

---

## 作者：孑彧 (赞：18)

### 矩阵简介及矩阵加速

#### 简介

> 在数学中，矩阵是一个按照长方阵列排列的复数或实数集合，最早来自于方程组的系数及常数所构成的方阵——百度百科

通俗的来讲，把集合里的一些数填入到一个矩形中即得到一个矩阵

#### 定义

由$m\times n$个数$a_{i,j}$排成的数表称为$m$行$n$列的矩阵简称$m\times n$矩阵。


$$A=\begin{bmatrix}a_{1,1}&a_{1,2}&...&a_{1,n}\\a_{2,1}&a_{2,2}&...&a_{2,n}\\...&...&...&...\\a_{m,1}&a_{m,2}&...&a_{m,n}\end{bmatrix}$$


这$n\times m$个数称为矩阵$A$的元素，简称为元。。。（~~剩下的都是百度百科的废话~~

有$m$行$n$列的矩阵也记作$A_{mn}$

特别的，两个$n,m$都相同的矩阵称为同型矩阵

$n=m$的矩阵称为$n$阶矩阵或者$n$阶方阵

#### 基本运算

##### 加法

$$\begin{bmatrix}a_{1,1}&...&a_{1,n}\\...&...&...\\a_{m,1}&...&a_{m,n}\end{bmatrix}+\begin{bmatrix}b_{1,1}&...&b_{1,n}\\...&...&...\\b_{m,1}&...&b_{m,n}\end{bmatrix}=\begin{bmatrix}a_{1,1}+b_{1,1}&...&a_{1,n}+b_{1,n}\\...&...&...\\a_{m,1}+b_{m,1}&...&a_{m,n}+b_{m,n}\end{bmatrix}$$

同时，矩阵的加法和实数的加法一样，满足交换律和结合律

即
$$A+B=B+A$$

$$(A+B)+C=A+(B+C)$$

应当注意，只有同型矩阵之间才可以进行加法

##### 减法

在数集中，减法作为加法的逆运算

在矩阵中也是一样的
$$\begin{bmatrix}a_{1,1}&...&a_{1,n}\\...&...&...\\a_{m,1}&...&a_{m,n}\end{bmatrix}-\begin{bmatrix}b_{1,1}&...&b_{1,n}\\...&...&...\\b_{m,1}&...&b_{m,n}\end{bmatrix}=\begin{bmatrix}a_{1,1}-b_{1,1}&...&a_{1,n}-b_{1,n}\\...&...&...\\a_{m,1}-b_{m,1}&...&a_{m,n}-b_{m,n}\end{bmatrix}$$

##### 数乘

在矩阵中引入了数乘的概念，即为一个数乘一个矩阵
$$\mu·\begin{bmatrix}a_{1,1}&...&a_{1,n}\\...&...&...\\a_{m,1}&...&a_{m,n}\end{bmatrix}=\begin{bmatrix}\mu· a_{1,1}&...&\mu· a_{1,n}\\...&...&...\\\mu· a_{m,1}&...&\mu· a_{m,n}\end{bmatrix}$$


矩阵的数乘满足以下规律：
$$\lambda(\mu A)=\mu(\lambda A)$$

$$\lambda(\mu A)=(\lambda\mu A)$$

$$(\lambda +\mu)A=\lambda A+\mu A$$

$$\lambda(A+B)=\lambda A+\lambda B$$

##### 乘法

两个矩阵的乘法仅当第一个矩阵$A$的列数和另一个矩阵$B$的行数相等时才能定义。

记作
$$A_{mn} B_{np}=C_{mp}$$
也作
$$AB=C$$
$C$的一个元素$c_{i,j}$的值为
$$c_{i,j}=\sum_{k=1}^na_{i,k}\times b_{k,j}$$
例如
$$\begin{bmatrix}1 &0 &2\\-1&3&1\end{bmatrix}\times\begin{bmatrix}3&1\\2&1\\1&0\end{bmatrix}=\begin{bmatrix}(1\times 3+0\times2+2\times1)&(1\times1+0\times1+2\times0)\\(-1\times3+3\times2+1\times1)&(-1\times1+3\times1+1\times0)\end{bmatrix}=\begin{bmatrix}5&1\\4&2\end{bmatrix}$$
同时，矩阵的乘法满足以下运算律：

结合律：
$$(AB)C=A(BC)$$
左分配律：
$$(A+B)C=AC+BC$$
右分配律：
$$C(A+B)=CA+CB$$

#### 矩阵加速

##### 快速幂

这个还需要多说么？

``` ksm
int base=a,ans=1;
while(b>0){
	if(b&1){
		ans*=base
		ans%=c;
	}
	base*=base
	base%=c;
	b=b>>1;
}
return ans;
```

就是很简单的按位运算

所以我们对于一个矩阵的幂也可以这么来运算，于是时间复杂度从$O(n)$降到了$O(log_2n)$

~~这就很舒服~~

但是这个有什么用呢？

##### [例题一](https://www.luogu.org/problem/P1939)

> a[1]=a[2]=a[3]=1
>
> a[x]=a[x-3]+a[x-1] (x>3)
>
> 求a数列的第n项对1000000007（10^9+7）取余的值。

第一眼看到这个题

**?**

这不是来送分的么

我一项一项去推不就好了？？？

> 对于100%的数据 T<=100，n<=2*10^9；

~~笑容逐渐凝固~~

所以现在就体现出矩阵加速的用处了

对于一个数列$f(n)=f(n-x)+f(n-y)+...$

我们可以构造出一个$k\times1$的矩阵表示当前的状态，即用$f(x),f(y)...$来表示我们当前已经知道的

然后我们再构造一个转移矩阵，使我们的原始矩阵乘上这个转移矩阵后可以变成一个新的矩阵，得到全新的$f(x)$，从而一步步的向前推进，得到答案

显而易见，由于我们需要用到$f(n-1)$和$f(n-3)$，所以我们需要保留住这两个状态，$f(n-3)$是由上个状态的$f(n-2)$继承过来的，所以我们也需要保留，所以原始矩阵要构造成这个样子
$$\begin{bmatrix}f(3)\\f(2)\\f(1)\end{bmatrix}$$
即为
$$\begin{bmatrix}1\\1\\1\end{bmatrix}$$
然后思考我们怎么由这个矩阵得到下一个矩阵

设我们当前矩阵为
$$\begin{bmatrix}f(n-1)\\f(n-2)\\f(n-3)\end{bmatrix}$$
我们希望得到的矩阵为
$$\begin{bmatrix}f(n)\\f(n-1)\\f(n-2)\end{bmatrix}$$
即为
$$\begin{bmatrix}f(n-1)\times1+f(n-2)\times 0+f(n-3)\times1\\f(n-1)\times1+f(n-2)\times0+f(n-3)\times0\\f(n-1)\times0+f(n-2)\times1+f(n-3)\times0\end{bmatrix}$$
显而易见我们的转移矩阵为
$$\begin{bmatrix}1&0&1\\1&0&0\\0&1&0\end{bmatrix}$$
由于我们原始矩阵的第一项为$f(3)$，所以我们只需要乘$n-3$次这个转移矩阵就可以得到了！

但是问题来了，这样不还是一个$O(n)$的算法么？~~而且还慢了好多~~

当然不是！想一下我们矩阵乘法的结合律

我们设原始矩阵为$A$，转移矩阵为$B$，那么我们最终答案的矩阵就是
$$\underbrace{B(B(B(B(B(B(B...(B}_{n-3}A))))))$$
根据矩阵乘法的结合律，这个式子可以简化为
$$B^{n-3}A$$
到了这里，我们就可以用矩阵快速幂来求出最终答案了！

$O(log_2n)$是真的快（

贴上我的巨丑无比的代码：

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#define mod 1000000007
using namespace std;
struct Ju{
	long long p[5][5];
	Ju operator *(const Ju &a)const{
		Ju c;
		for(long long i=1;i<=3;i++){
			for(long long j=1;j<=3;j++){
				c.p[i][j]=0;
			}
		}
		for(long long i=1;i<=3;i++){
			for(long long j=1;j<=3;j++){
				for(long long k=1;k<=3;k++){
					c.p[i][j]+=(a.p[i][k]*p[k][j])%mod;
					c.p[i][j]%=mod;
				}
			}
		}
		return c;
	}
}ans,base;
void build(){
	for(long long i=1;i<=3;i++){
		for(long long j=1;j<=3;j++){
			base.p[i][j]=0;
		}
	}
	base.p[1][1]=base.p[1][3]=base.p[2][1]=base.p[3][2]=1;
	ans.p[1][1]=ans.p[2][1]=ans.p[3][1]=1;
}
void qsm(long long p){
	while(p!=0){
		if(p&1){
			ans=ans*base;
		}
		base=base*base;
		p>>=1;
	}
}
long long T,n;
int main(){
	cin>>T;
	for(long long i=1;i<=T;i++){
		cin>>n;
		if(n<=3){
			printf("1\n");
			continue;
		}
		build();
		qsm(n-3);
		cout<<ans.p[1][1]<<endl;
	}
	return 0;
}
```

同样的题还有[这一道](https://www.luogu.org/problem/P1962)

写作不易，点个赞再走呗QAQ

---

## 作者：milk_candy (赞：9)

# 矩阵加速（数列） 题解

## 题意分析

- 给你一个数列，

- ![](https://cdn.luogu.com.cn/upload/image_hosting/cuinaluo.png)

- 求$a_n$（% 1e9+7）的值

## 解题思路

- 标题说的很清楚了，“矩阵加速”，所以这题的解法就是“矩阵乘法”。

  ### Prob.1 建立原始矩阵

  - 因为$a_1=a_2=a_3=1$，所以我们的初始矩阵长这样：

  - #### 为什么是1行3列的？
  
    - 在$a_{i+1}$的计算过程中，由于$a_i=a_{i-3}+a_{i-1}$，则$a_{i+1}$也等于$a_{i-2}+a_i$。要调用到$a_{i-2}$的值，则应该保存3个格子（3列），分别是$a_i,a_{i-1},a_{i-2}$。故初始矩阵是1行3列

  - | $a_1$ | $a_2$ | $a_3$ |
  	| ----- | ----- | ----- |
    | 1     | 1     | 1     |

  - 所以初始矩阵就是（1，1，1）。

  ### Prob.2 建立转移矩阵

  - 我们知道当i>=4的时候才需要转移。

  - 原式为$a_i=a_{i-3}+a_{i-1}$。
  
  - 我们知道，$a_i$要转移到$a_{i+1}$，就要建立一个矩阵，它长这样：
  
  - | --   | i+1  | i    | i-1  | i-2  |
    | ---- | ---- | ---- | ---- | ---- |
  	| i    |      |      |      |      |
    | i-1  |      |      |      |      |
  	| i-2  |      |      |      |      |
    | i-3  |      |      |      |      |
  
  - 然后，改写原式，既然$a_i=a_{i-3}+a_{i-1}$，则$a_{i+1}$也等于$a_{i-2}+a_i$。
  
  - 我们很快就根据刚才改写的式子，推出第一列：$a_{i+1}$列从上到下依次是：1、0、1、0。（因为$a_i$和$a_{i-2}$各取一份）
  
  - 至此，矩阵已经成为：
  
  - | --   | i+1  | i    | i-1  | i-2  |
    | ---- | ---- | ---- | ---- | ---- |
    | i    | 1    |      |      |      |
    | i-1  | 0    |      |      |      |
    | i-2  | 1    |      |      |      |
    | i-3  | 0    |      |      |      |
  
  - 然后看第二、第三、第四列。其实很简单，后面这几列只需要原封不动地转移就好了。$a_i=a_i,a_{i-1}=a_{i-1},a_{i-2}=a_{i-2}$。
  
  - 直接在”i“列上给“i”格子填上1，……依此类推。
  
  - 至此，我们的转移矩阵就建立好了。最终，转移矩阵如下：
  
  - | --   | i+1  | i    | i-1  | i-2  |
    | ---- | ---- | ---- | ---- | ---- |
    | i    | 1    | 1    | --   | --   |
    | i-1  | --   | --   | 1    | --   |
    | i-2  | 1    | --   | --   | 1    |
    | i-3  | --   | --   | --   | --   |
  
  - **明确这个矩阵的作用：** 对于一个矩阵$a_i,a_{i+1},a_{i+2}$，乘上这个转移矩阵可以让矩阵转换为$a_{i+1},a_i,a_{i-1}$。
  
  ### Prob.3 计算答案
  
  - 一开始，我们基础矩阵存放的是$a_1,a_2,a_3$，易证乘以n次那个转移矩阵之后，基础矩阵存放的是$a_{n+1},a_{n+2},a_{n+3}$
  
  - 而我们要算$a_n$，则只需要乘那个转移矩阵n-1次，然后基础矩阵的第一个格就是$a_n$了。
  
  - 问题转换为
  
  - $$
    ans=basic\space matrix\space\times\space(transfer)^{n-1}
    $$
  
  - 要是我们直接暴力乘转移矩阵，时间复杂度就O(n)往上了，肯定过不了的。我们要想办法优化。
  
  - 发现后面的$(transfer)^{n-1}$可以用快速幂直接算出来，降为log级别的时间复杂度。
  
  - 则我们只需要先用快速幂把转移矩阵的n-1次方算出来，然后用基础矩阵乘以它，最后输出基础矩阵的第一格。

## 参考程序

```cpp
#include<stdio.h>
const int MOD=1000000007;

struct OneMatrix
{
	long long m[6][6];
} basic_matrix,turn;

OneMatrix mul(OneMatrix a,OneMatrix b)
{
	OneMatrix ans;
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			ans.m[i][j]=0;
	
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			for(int k=1;k<=5;k++)
				ans.m[i][j]=( ans.m[i][j]%MOD + a.m[i][k]*b.m[k][j]%MOD ) % MOD;
	
	return ans;
}

OneMatrix pow(OneMatrix a,int x)
{
	//a^x
	OneMatrix ans=a;
	while(x)
		{
			if(x%2==1)
				ans=mul(ans,a);
			a=mul(a,a);
			x/=2;
		}
	return ans;
}

int main_()
{
	//先构造矩阵
	//1 1 1
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			basic_matrix.m[i][j]=0;
	basic_matrix.m[1][1]=1;
	basic_matrix.m[1][2]=1;
	basic_matrix.m[1][3]=1;
	
	//先构造转移矩阵
	//1 1 0 0
	//0 0 1 0
	//1 0 0 1
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			turn.m[i][j]=0;
	turn.m[1][1]=1,turn.m[1][2]=1;
	turn.m[2][3]=1;
	turn.m[3][1]=1,turn.m[3][4]=1;
	
    //读入矩阵
	int Q;
	scanf("%d",&Q);
	if(Q==1||Q==2||Q==3)
		{
			printf("1\n");
			return 0;
		}
	else
		Q-=3;	
    //如果询问是4，我们只用转移1次；
    //如果询问是5，只用2次，依此类推。所以Q减去3
	
	//把转移矩阵的n-1次方算出来
	turn=pow(turn,Q-1);
	
	//乘以基础矩阵 
	basic_matrix=mul(basic_matrix,turn);
	
	//输出结果
	printf("%I64d\n",basic_matrix.m[1][1]);
	
	return 0;
}

int main()	//多组数据
{
	int T;
	scanf("%d",&T);
	while(T--)
		main_();
	return 0;
}
```



---

## 作者：Special_zyy (赞：7)

//本蒟蒻的第一篇题解，希望可以审核过吧qwq欢迎各位大佬来找错（有些是个人理解，可能有误）

首先说一下我这个蒟蒻对于矩阵加速的理解吧，我觉得这个加速是借助了矩阵乘法利用了快速幂，加快了状态之间的转移，有点像“倍增”吧，对于寻找某个目标状态有很大的加速作用。我觉得实现矩阵加速比较重要的一方面就是快速幂，快速幂是利用二进制实现的，不会的同学可以看一下代码，声明：快速幂在矩阵加速中很重要！建议先掌握快速幂。(参考例题P1226)：
~~~cpp
long long quick(long long a,long long b)
{
	long long base=a,ans=1; 
	while(b!=0)  
	{
		if((ans*base)%k!=0) 
		if(b&1!=0) ans=(ans*base)%k;     
		base=base*base%k;      
		b>>=1;
	}
	return ans;
}

~~~
很明显的是，这道题的关键之处绝对是找出状态转移用的矩阵，看题我们可以知道，**a[i]=a[i-1]+a[i-3]**;要求得 _**a[i]**_ 的话，我们需要 _**a[i-1**]_ 以及 _**a[i-3]**_ 这两个状态。那我们不妨设置一个3×1的矩阵记录a[i-1],a[i-2],a[1-3]这三个状态，
![](https://cdn.luogu.com.cn/upload/pic/37980.png)

然后我们在由这三个状态向目标状态推。
好的，现在重点来了，我们要考虑如何将这三个状态推为 _**a[i],a[i-1],a[i-2]**_  ;
由于矩阵乘法的性质（矩阵乘法的话，这里就不多说了，可以去百度一下），我们需要一个3×3矩阵，由这个3×3的矩阵与我们上面那个3×1的初始矩阵进行相乘。由此来找到我们的状态转移矩阵（就是这个3×3的矩阵，后面也会这样称呼，hah）。
这是我们的目的

将：

![](https://cdn.luogu.com.cn/upload/pic/37980.png)

转为：

![](https://cdn.luogu.com.cn/upload/pic/37981.png)

很明显：
a[i]=a[i-1]×1+(a[i-2]×0)+a[i-3]×1

那我们的3×3矩阵第一行就是1 0 1了

a[i-1]=a[i-]]×1+(a[i-2]×0+a[i-3]×0)

a[i-2]=(a[i-1]×0)+a[i-2]×1+(a[i-3]×0)

所以3×3矩阵的第二、三行就是1 0 0和 0 1 0了；
（第二、三种状态的转移说明在矩阵加速找转移状态的矩阵时，不一定一定要由它前面的某几种状态转移来，也有可能由它后面的状态直接转过来，我刚开始做矩阵加速时没往这种情况上想，就很浪费时间了。QAQ）

由此矩阵开始，我们可以知道，当前状态转到下一状态只需要进行初始矩阵与我们1×3的那个初始矩阵（暂且这样称呼，知道是哪个就好了qwq）进行n-3次矩阵乘法，为什么是n-3次呐？因为我们的“初始矩阵”开始有三个状态（即a[i-1],a[i-2],a[i-3]），每次矩阵乘法之后，“状态矩阵”的第一个元素就是a[i]了，那我们要寻找的a[n]就只需要n-3次矩阵乘法咯。

好的，我们初始矩阵找到了，那我们就要借助矩阵乘法了，由a[1],a[2],a[3]向后转移知道a[n]就好了，需要注意的一点是，因为快速幂的时候，有时需要我们处理状态转移矩阵，而我们的状态转移矩阵与我们的初始矩阵大小不一，所以我设置了一个结构体（为什么要用结构体，这样的话便于在各个函数之间转移），其中除了矩阵变量以外，再加了一个border的变量来处理边界问题，边界一个是1，另一个边界是3（由矩阵的大小决定的ya）。有一道类似的矩阵加速题叫做斐波那契额公约数，有兴趣的同学可以去试一下，那是一个2×2的状态转移矩阵。

AC代码：

~~~cpp
#include <cstdio> 
#include <iostream>  
using namespace std;
#define INF 1000000007
long long n,q[105];
struct mat{
	long long s[3][3],border;   
};
mat mem(mat a,mat b)//矩阵乘法
{
	mat q;
	for(int i=0;i<3;i++)
	  for(int j=0;j<3;j++)
	    q.s[i][j]=0;
	for(int i=0;i<3;i++)
	  for(int j=0;j<a.border;j++)
	    for(int k=0;k<3;k++)
	      q.s[i][j]=((q.s[i][j]%INF)+(a.s[k][j]%INF)*(b.s[i][k]%INF))%INF;
	q.border=a.border;//处理边界
	return q;
}
void ksm(long long x)//快速幂
{
	mat xx,ans;ans.border=1;xx.border=3;
	ans.s[0][0]=ans.s[1][0]=ans.s[2][0]=1;
	for(int i=0;i<3;i++)
	  for(int j=0;j<3;j++) xx.s[i][j]=0;
	xx.s[0][0]=xx.s[0][2]=xx.s[1][0]=xx.s[2][1]=1;
	while(x)
	{
		if(x&1) ans=mem(ans,xx);
		xx=mem(xx,xx);
		x>>=1;
	}
	cout<<ans.s[0][0]%INF<<endl;//n-3次矩阵乘法之后这个就是a[n]了！
}
int main()
{
	cin>>n;   
	for(int i=1;i<=n;i++)  
	cin>>q[i];   
	for(int i=1;i<=n;i++)
    {   
		if(q[i]<=3) {cout<<1<<endl;continue;}  
    ksm(q[i]-3);  
	} 
	return 0;
}
~~~

---

## 作者：_LHF_ (赞：4)

## 矩阵加速
前置知识：矩阵乘法，矩阵快速幂。（会的可以跳过）
### 矩阵乘法
这是一个令人头痛的东西。

假如有两个矩阵，它们为A和B，

$$A=\begin{bmatrix}a & b\\c & d\\e & f\end{bmatrix},B=\begin{bmatrix}a & b & c\\d & e & f\end{bmatrix}$$
则：$A×B=\begin{bmatrix}(a^2+bd)\space\space\space\space\space\space(ab+be)\space\space\space\space\space\space(ac+bf)\\(ca+d^2)\space\space\space\space\space\space(cb+de)\space\space\space\space\space\space(c^2+df)\\(ea+fd)\space\space\space\space\space\space (eb+fe)\space\space\space\space\space\space(ec+f^2)\end{bmatrix}$

**打得真累，大家给一点力呀。**

当然，矩阵乘法只当矩阵A为n行k列，矩阵B为k行m列方可进行乘法运算。我们可以总结一下：若矩阵A为n行k列，矩阵B为k行m列，则$Ci,j=\sum_{d=1}^kA_{i,d}×B_{d,j}$。
### 矩阵快速幂
普通的快速幂大家一定都懂吧，这里不多做讲解。

矩阵快速幂和普通快速幂原理一样，只不过乘法的时候麻烦了一点罢了。还是给一个代码给大家看一看吧（码风比较丑）：
```cpp
#include<cstdio>
#define N 110
#define mod 1000000007
using namespace std;
struct matrix
{
	long long a[N][N];
} s,ans;
int n;
matrix operator *(matrix &a,matrix &b)
{
	matrix x;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			x.a[i][j]=0;
			for(int k=1;k<=n;k++)
			{
				x.a[i][j]=(x.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
			}
		}
	}
	return x;
}
long long k;
int main()
{
	scanf("%d%lld",&n,&k);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%lld",&s.a[i][j]);
		}
	}
	for(int i=1;i<=n;i++) ans.a[i][i]=1;
	while(k)
	{
		if(k&1) ans=ans*s;
		k=k>>1;
		s=s*s;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			printf("%lld ",ans.a[i][j]);
		}
		printf("\n");
	}
}
```
好了，进入主题
# 矩阵加速
我们要求的是$f[i]$，其中，$f[i]=f[i-1]+f[i-3]$。

我们可以压缩一下状态，得到这么一个东西：
$$f[i]=1×f[i-1]+0×f[i-2]+1×f[i-3]$$
$$f[i-1]=1×f[i-1]+0×f[i-2]+0×f[i-3]$$
$$f[i-2]=0×f[i-1]+1×f[i-2]+0×f[i-3]$$
然后我们尝试把它压缩到一个矩阵内：
$$A=\begin{bmatrix}1&0&1\\1&0&0\\0&1&0\end{bmatrix}$$
然后跑一次快速幂。

为什么可以这样做呢？我们可以利用矩阵乘法的原理得到，如下：

$$\begin{bmatrix}f[i-1]\\f[i-2]\\f[i-3]\end{bmatrix}\times\begin{bmatrix}1&0&1\\1&0&0\\0&1&0\end{bmatrix}=\begin{bmatrix}f[i-1]+f[i-3]\\f[i-1]\\f[i-2]\end{bmatrix}=\begin{bmatrix}f[i]\\f[i-1]\\f[i-2]\end{bmatrix}$$

怎么样，很神奇吧，其实矩阵快速幂也可以用来优化DP，作用很广呢。

该上代码了。
```cpp
#include<cstdio>
#define N 110
#define mod 1000000007
using namespace std;
struct matrix
{
	long long a[N][N];
} s,ans;
int n=3;
matrix operator *(matrix &a,matrix &b)
{
	matrix x;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			x.a[i][j]=0;
			for(int k=1;k<=n;k++)
			{
				x.a[i][j]=(x.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
			}
		}
	}
	return x;
}
int getans(int k)
{
	matrix ans;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) s.a[i][j]=0,ans.a[i][j]=0;
	s.a[1][1]=s.a[1][3]=s.a[2][1]=s.a[3][2]=1;
	ans.a[1][1]=ans.a[2][2]=ans.a[3][3]=1;
	while(k)
	{
		if(k&1) ans=ans*s;
		k=k>>1;
		s=s*s;
	}
	return ans.a[2][1];
}
int T,a;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&a);
		printf("%d\n",getans(a));
	}
}
```
蒟蒻初学矩阵这玩意儿，请大佬勿喷。

---

## 作者：2413669045luo (赞：4)

**其实这一题还是挺简单的（~~如果你会矩阵快速幂的话~~）,不会的快去学啊！！！
好啦，回归正题，下面就讲一下本蒟蒻的拙见。**


------------

## 1.原理部分
由题知:
     -   f[n]=f[n-1]+f[n-3]。我们只要从这个公式出发就好了。
     -   我们假设有两个数组A[],B[]。
     
     -   A:f[3],f[2],f[1]。//A只有一行三列。
     
  - 　B：               //B需要手推。
  
  
            1 1 0
            
            0 0 1
            
            1 0 0
   -如果我们让A*B会有什么神奇的事发生呢？
     -聪明的你一定发现了
     - A*B=（f[3]+f[1]+0,f[3]+0+0,f[2]+0+0）
          =f[4],f[3],f[2]
     - 这时候我们把得到的结果再乘一个B数组
     - 它就神奇的变为 f[5],f[4],f[3]啦!
     - 我们再乘，每个f的下表就加1。
     于是，我们得到结论。
  ### (f[n],f[n-1],f[n-2])*B=(f[n+1],f[n],f[n-1])。
    我们最开始知道 f[3],f[2],f[1]，把它当做A数组。
    如果我们想知道f[x]的值，我们不是只要乘x-3个B就能得到答案了么。
   嗯（~~too young too sample，哈哈~~），但我用递推也是推x-3次，
   那我干嘛还要用矩阵加速呢？
   
   ##### 别慌，我有矩阵快速幂！！！
   虽然矩阵乘没有交换率（即A×B≠B×A），
   
   但它有结合率啊（即（A×B）×C==A×（B×C））。
   
   既然我们有x-3个B要乘，那我们可以先把它用快速幂求出来。
   
   (什么，你不会快速幂，快去学啊。）
   
   即求B^(x-3)。最后再乘A。
   
   就可以通过减少相乘的次数来加快时间。
   
   是不是恍然大悟了呢！
   

## 2.代码部分
（略丑，别怕。）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define ll long long
ll p=1000000007;
struct node{
    ll map[4][4];
}e,ans;
ll t,temp,answer=0;
node mul(node a,node b)//用来两个矩阵相乘的函数
{
    node tp;
    memset(tp.map,0,sizeof(tp));
    for(int i=1;i<=3;i++)
    for(int j=1;j<=3;j++)
    for(int z=1;z<=3;z++)
    tp.map[i][j]=(tp.map[i][j]+a.map[i][z]*b.map[z][j]%p)%p;
    return tp;
}
void quick (node a,ll b)//矩阵快速幂。
{
    memset(ans.map,0,sizeof(ans));
    ans.map[1][1]=ans.map[2][2]=ans.map[3][3]=1;//设置单位矩阵，相当
                                               //与普通快速幂里的ans 
                                               //用来记录答案。
    while(b)
    {
    if(b&1)
    ans=mul(ans,a);
    a=mul(a,a);
    b=(b>>1);
   }
}
int main()
{
    memset(e.map,0,sizeof(e));
    e.map[1][1]=e.map[1][2]=e.map[2][3]=e.map[3][1]=1;//B数组的初值。
    scanf("%lld",&t);
    for(int i=1;i<=t;i++)
    {
      scanf("%lld",&temp);
      if(temp==1||temp==2||temp==3)//如果是求f[1],f[2]，f[3]直接输出
        {
            printf("%d\n",1);
            continue;
        }
        quick(e,temp-3);//求B^(x-3)。
    printf("%lld\n",(ans.map[1][1]+ans.map[2][1]+ans.map[3][1])%p);
//最后的A*B^(x-3)。由于只要f[x]，我们手动相乘，不再操作f[x-1]，f[x-2]。
    }
return 0;
}

```
好啦，如果您有哪里不懂的话并且不嫌弃本蒟蒻的话，可以私信我哦。

有哪里讲的不对的话dalao一定指出来哦，望dalao斧正。

           


---

## 作者：Cesare (赞：3)

$update:$ 修复了部分矩阵的构建结果，并修复了文末链接。

再 $Update:$ 增加了循环矩阵的构造方式。


------------------
# 开个新坑。

往后的可能很长一段时间，这都会是置顶。

## 向量

------------------

## 浅谈如何构造矩阵

```
关于矩阵的构造，是矩乘中最关键的一环，一般只需要学会构造矩阵和熟练运用矩阵快

速幂的模板，就可以做(shui)出(diao)非常多的题目。

话不多说，马上进入正题。

```

-------------------

例题1:[【模板】矩阵加速（数列）](https://www.luogu.org/problemnew/show/P1939)

让我们观察一下这题的递推式:

$ f[1] = f[2] = f[3] = 1 $

$ f[n] = f[n - 1] + f[n - 3] $ ($ n > 3 $) $ $

首先我们可以发现，$ f[n] $ 最早由$ f[n-3] $转移而来，所以我们需要构造一个$ 3*3 $的矩阵。

首先，我们将与 $ f[n] $ 有关的需要得到的式子放入一个矩阵:
$ \begin{bmatrix}f[n]\\f[n - 1]\\f[n - 2]\end{bmatrix} $

然后，我们寻找他从哪里来: $ f[n-1] = f[n - 2] + f[n - 3] $，
即 $ \begin{bmatrix}f[n-1]\\f[n - 2]\\f[n - 3]\end{bmatrix} $

然后设我们需要得到的矩阵为$ ans $，有:$ ans*\begin{bmatrix}f[n-1]\\f[n - 2]\\f[n - 3]\end{bmatrix} = \begin{bmatrix}f[n]\\f[n - 1]\\f[n - 2]\end{bmatrix} $

然后我们一行一行根据矩乘的方式递推:

第一行因为想得到 $ f[n] $， 所以三个都需要:$ \begin{bmatrix}1&0&1\end{bmatrix} $

第二行因为想得到$ f[n - 1] $，所以只需要第一个:$ \begin{bmatrix}1&0&0\end{bmatrix} $

第三行因为想得到$ f[n - 2] $，所以只需要第二个:$\begin{bmatrix}0&1&0\end{bmatrix} $

最后就构造出了完整的矩阵:
$ \begin{bmatrix}1&0&1\\1&0&0\\0&1&0\end{bmatrix} $

矩乘代码:

```cpp
#include<bits/stdc++.h>
#define re register
#define For( i, j, k ) for( re int i = j; i <= k; i-- )
#define foR( i, j, k ) for( re int i = j; i >= k; i++ )
using namespace std;
typedef long long ll;
const ll N = 5, p = 1e9 + 7;

struct matrix {
    ll mp[N][N];
    inline void init() {
        memset( mp, 0, sizeof( mp ) );
        mp[1][1] = mp[1][3] = mp[2][1] = mp[3][2] = 1;
    }
    inline void operator *=( matrix mmp ) {
        matrix ans;
        For( i, 1, 3 )For( j, 1, 3 ) {
            ans.mp[i][j] = 0; 
            For( k, 1, 4 )ans.mp[i][j] += mp[i][k] * mmp.mp[k][j];
        }For( i, 1, 3 )For( j, 1, 3 )mp[i][j] = ( ans.mp[i][j] + p )% p;
    }
};

inline ll read() {
    ll x = 0; bool f = 0; char ch = getchar();
    for( ; !isdigit( ch ); ch = getchar() )f^=( ch == '-' );
    for( ; isdigit( ch ); ch = getchar() )x = ( x<<3 ) + ( x<<1 ) + ( ch^48 );
    return f? -x: x;
}

inline void write( ll x ) {
    if( x < 0 ){ putchar( '-' );x = -x; }
    if( x > 9 )write( x / 10 );
    putchar( x % 10 + 48 );
}

inline ll matrix_power( ll x ) {
    if( x <= 1 ) return 1;
    matrix ans, a;
    ans.init(), a.init();
    while( x ) { if( x&1 )ans *= a; x>>=1; a *= a; }
    return ans.mp[1][1];
}

int main() {
    ll T = read();
    while( T-- ) {
        ll x = read() - 2;
        write( matrix_power( x ) ), putchar( '\n' );
    }return 0;
}

```
温馨提示：不要抄代码。

----------------------

例题2:[斐波那契数列](https://www.luogu.org/problemnew/show/P1962)

让我们重复上一题的步骤:

$ f[1] = f[2] = 1 $

$ f[n] = f[n - 1] + f[n - 2] $

可以发现 $ f[n] $ 最早由 $ f[n - 2] $ 转移而来，所以只需要构建一个 $ 2 * 2 $的矩阵就可以了。

将递推式放入矩阵: $ \begin{bmatrix}f[n]\\f[n - 1]\end{bmatrix} $

他从哪里来: $ \begin{bmatrix}f[n - 1]\\f[n - 2]\end{bmatrix} $

设 $ ans * \begin{bmatrix}f[n - 1]\\f[n - 2]\end{bmatrix} = \begin{bmatrix}f[n]\\f[n - 1]\end{bmatrix} $

第一行需要得到 $ f[n] $，所以需要$ f[n - 1] $ 和 $ f[n - 2] $，因此得到矩阵第一行为: $ \begin{bmatrix}1&1\end{bmatrix} $

第二行需要得到 $ f[n - 1] $，所以只需要$ f[n - 1] $就可以了，因此得到矩阵第二行为: $ \begin{bmatrix}1&0\end{bmatrix} $

最后构建出完整的矩阵: $ \begin{bmatrix}1&1\\1&0\end{bmatrix} $

代码:

---------------------------

习题:

```
1.[专心OI - 跳房子](https://www.luogu.org/problemnew/show/P5004)

2.[Function](https://www.luogu.org/problemnew/show/U60144)//矩乘可以拿50

3.[填数游戏](https://www.luogu.org/problemnew/show/P5023)//矩乘依然可以拿50

```

--------------

[高斯消元](https://www.cnblogs.com/Dumblidor/p/5751579.html)

[参考资料](https://ask.julyedu.com/article/493)[视频](https://space.bilibili.com/88461692/channel/detail?cid=9450)

### 构造矩阵的进阶内容

直接构造矩阵单次乘法是 $O(len^3)$ ，我们可以考虑用循环矩阵优化这个东西。

对于那种大一点的矩阵，如果他的每行或者每列都可以通过上一行推出来，那么就可以做到每次乘法 $O(n^2)$ 的复杂度。

举个[例子](https://www.luogu.org/problem/P3746)。

对于这道题我们的转移矩阵是这样的：

$$\begin{bmatrix}1\ 1\ 0\ \ldots\ 0\\0\ 1\ 1\ \ldots\ 0\\0\ 0\ 1\ \ldots\ 0\\ \ldots\\1\ 0\ 0\ \ldots\ 1\end{bmatrix}$$

这个东西就是第一列往后每次向后推一格即可。

所以我们转移的时候就不需要再枚举 $k$ ，可以直接通过枚举第一列的情况向后推。

我们设 m 为列数， n 为行数，那么给出一段伪代码：

```cpp
for (i = 1 -> m) for (j = 1 -> n) 
    c.mp[(i + j) % k] += a.mp[i] * b.mp[j]
```

循环关系在本题中是第一行往第二行即所有元素右移一位，所以就是枚举当前是第几列，然后向后枚举当前这列的元素在后面出现的位置，由于 $i$ 列的元素的状态全部可以由第一列推出，所以我们考虑直接计算第一列每个元素被累加的东西，就直接把所有东西都累加到第一列上去。

所以这个东西其实就是利用了循环矩阵使加和结果一致的地方都可以一样的搞，从而把转移空间压到了一维，转移的时间压到了二维。

有人跟我说这玩意本质就是一个卷积，所以只要满足循环矩阵就都是转移到 $(i+j) \% k$ 的。

由于这个东西就是个卷积，所以也可以用常系数齐次线性递推做到单次 $O(n\ log\ n)$ ，但楼主还不会这玩意，感兴趣可以自己去学，也可以等我什么时候会了再补充。


---

## 作者：Seauy (赞：2)

 算法：矩阵加速
 
 前置知识：
 
1. 啥是矩阵？
2. 矩阵如何运算？

 接下来就让我一一解答
 
 1. 矩阵
 
很像我们使用的二维数组，举个例子就行了，如下图，一个 3 行 4 列 矩阵：
![](https://cdn.luogu.com.cn/upload/pic/60501.png)

 2. 矩阵运算
 
- 加减法

十分容易理解，两个 m 行 n 列的矩阵可以相加减（规模必须一样），结果矩阵为对应每个数字的和或差
![](https://cdn.luogu.com.cn/upload/pic/60502.png)

- 乘法（木有除法）

有 n 行 m 列矩阵 A 和 m 行 p 列矩阵 B（A的列数必须等于B的行数）

若 A * B = 矩阵 C，那么 C[i,j]=∑ A[i,k] * B[k,j] (1<=k<=m,1<=i<=n,1<=j<=p)

M[i,j] 表示矩阵 i 行 j 列的数字 

同时 C 为 n 行 p 列矩阵

[LaTeX不会用将就看啦QAQ]

有点绕是不是，我接下来举个例子：

![](https://cdn.luogu.com.cn/upload/pic/60503.png)

先计算结果矩阵 C[2,2] 位置的值，根据上面的式子，C[2,2] 的值只跟 A 的 2 行和   B 的 2 列有关，先由蓝色线条标出

![](https://cdn.luogu.com.cn/upload/pic/60504.png)

看到 A 第二行的第一个数字和 B 第二列的第一个数字，用肉色标出

根据公式，两者相乘 1 * 0 = 0，得出的积先保留着

接着，A 的肉色格子向右一格，B 的格子向下一格

![](https://cdn.luogu.com.cn/upload/pic/60505.png)

选中数字再相乘，4 * 2 = 8

然后持续这么干，直到肉色格子移出了 A 与 B 矩阵，途中所有的积也得到了

![](https://cdn.luogu.com.cn/upload/pic/60507.png)

把所有积相加，就是橙色格子的数字了

然后把其 C 中其他格子也这么算，结果是

![](https://cdn.luogu.com.cn/upload/pic/60508.png)

此部分内容需要各位 OIer 们自行熟悉

矩阵乘法搞这么难，图个啥？用处就在这题


------------


 矩阵加速：
 
第一眼看着道题：这不水题吗？O(n) 递推啊！但貌似事情并没有这么简单……

n<=2000000000，还有 T<=100，O(n) 看上去蛮快的，实际上还不够

由于题目中 a[n]=a[n-3]+a[n-1] ，可见第 n 个数只跟前面 3 个数有关，所以每次我们只用存三个数就行了

用一个 1 行 3 列矩阵可以如此表示：

[ a[x-3] , a[x-2] , a[x-1] ]

想知道 a[x] ? 当然是想让这个矩阵通过某种运算变成 [ a[x-2] , a[x-1] , a[x] ] 喽，如果想用矩阵乘法达到这个目的，那就得在原矩阵上乘以所谓的转移矩阵：

![](https://cdn.luogu.com.cn/upload/pic/60513.png)

递推到 x 的矩阵用 A(x) 表示好了，若知道 A(x-1) ，想算出 A(x) 只需要乘以上面的转移矩阵 T 就行了，公式表达为 ：

A(x)=A(x-1) * T

A(0)=[1,1,1]

由此易得 A(n)=A(0) * T^n

看到 T^n ，同时 n 又很大，想到了什么？

快速幂啊！

而底数为矩阵的快速幂又称为矩阵快速幂

实际上跟普通快速幂没有什么区别，只是矩阵乘以矩阵要自己写函数罢了

程序可以上了：

```cpp
/*
a 行 b 列的矩阵 A
c 行 d 列的矩阵 B
A*B=C
					    m 个                 m 个 
C 每个位置的数字 = A 这一行上的数字 * B 这一列上的数字 之和 

 { a[n-2],a[n-1],a[n] }
={ a[n-3],a[n-2],a[n-1] } * { 0,0,1 }
						    { 1,0,0 } 
						    { 0,1,1 } 
*/
include<bits/stdc++.h>
using namespace std;

int n;
long long a[5],TM[5][5];//没有骂人的意思，真的是这个翻译
long long Example[5][5]=
{
	{0,0,1},
	{1,0,0},
	{0,1,1}
};

void Matrix_Multi()
{
	long long cnt[5];
	memset(cnt,0,sizeof cnt);
	for(int i=0;i<3;i++)//A(x) * T
		for(int j=0;j<3;j++)
			cnt[i]=(cnt[i]+a[j]*TM[j][i])%1000000007;
	memcpy(a,cnt,sizeof cnt);//别忘了把算出来的结果覆盖到矩阵里
}

void POW2()
{
	long long cnt[5][5];
	memset(cnt,0,sizeof cnt);
	for(int i=0;i<3;i++)//T * T
		for(int j=0;j<3;j++)
			for(int f=0;f<3;f++)
				cnt[i][j]=(cnt[i][j]+TM[i][f]*TM[f][j])%1000000007;
	memcpy(TM,cnt,sizeof cnt);
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		n--;
		a[0]=a[1]=a[2]=1;//初始化
		memcpy(TM,Example,sizeof Example);
		for(;n;n>>=1)//快速幂
		{
			if(n&1) Matrix_Multi();
			POW2();
		}
		cout<<a[0]<<endl;
	}
	return 0;
}
```

我们把长度为 n 的一维向量（1 行 n 列矩阵）称为“状态矩阵”，把用于“状态矩阵”相乘的固定不变的矩阵称为“转移矩阵”。若状态矩阵中的第 x 个数对下一个单位时间状态矩阵的第 y 个数产生影响，这把转移矩阵的第 x 行第 y 列赋值为相应的系数。关键在于找出正确的“转移矩阵”。

时间复杂度为 O(n^3 * log T)，T 为递推总论数。


------------

[以上节选自李煜东的《算法竞赛进阶指南》]


------------

  注意一个小点： 
 
  _用这个方法你会算出 a[n+1] 而并非 a[n]，读入的时候记得把 n 减一_ 

---

## 作者：zhyh (赞：2)

受斐波那契的影响，本想对f[i]、f[i-2]组成的矩阵来推：

~~然后发现不会......可能这与那个公式形式不符吧~~

于是在中间加了个f[i-1],再与f[i-1]、f[i-2]、f[i-3]组成的矩阵搞，得出矩阵

	1 0 1

	1 0 0

	0 1 0
            
满足条件，例如f[i]=f[i-1]x 1+f[i-2]x 0+f[i-3]x 1，类推~~（不过怎么是楼下矩阵的旋转体）~~

于是就有[ f[n]... ] = [那个矩阵]^(n-3) * [ f[3]... ]

代码如下，用了结构体和重载：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long LL;
const LL mod=1e9+7;	LL T,n,f[5]={0,1,1,1,2};

struct matrix{LL a[5][5];matrix(){memset(a,0,sizeof(a));}}E;
matrix operator *(matrix x,matrix y)  //重载乘号
{
    matrix tmp;
    for(LL i=1;i<=3;i++)
    for(LL j=1;j<=3;j++)
    for(LL k=1;k<=3;k++)
    tmp.a[i][j]=(tmp.a[i][j]+x.a[i][k]*y.a[k][j])%mod;
    return tmp;
}

LL qmul(matrix e,matrix ans,LL k) //快速幂函数
{
    for(;k;k>>=1,e=e*e)if(k&1)ans=ans*e;
    return(ans.a[1][1]+ans.a[1][2]+ans.a[1][3])%mod;
}
int main()
{
    E.a[1][1]=E.a[1][3]=E.a[2][1]=E.a[3][2]=1;
    scanf("%lld",&T);
    while(T--){scanf("%lld",&n);printf("%lld\n",(n>4)?qmul(E,E,n-4):f[n]);}
    //初始矩阵已经赋值了，所以少乘一次：n-4
    return 0;
}
```

---

## 作者：baolichuqiji (赞：2)



我么可以整理出来这样一个式子

 
F[n] = f[n-2]+f[n-3]+f[n-4] 

F[5] = f[1] + f[2] +f[3]

k推1 ,a数组（翻倍数组）就开k行k列,f数组就开[k]行




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define inf 1000000007 
using namespace std;
long long a[5][5],b[5][5],f[5],c[5];
long long n,m,i,j,k,l,T;
//因为是四推一所以开四个就行 
//--------
void kuai();
int main()
{
    scanf("%d",&T);
    for(i = 1;i <= T; i++)
    {
    memset(a,0,sizeof(a));
    memset(f,0,sizeof(f));
    scanf("%d",&n);
    a[1][2] = a[2][3] = a[3][4] = 1;
    a[4][1] = a[4][2] = a[4][3] = 1;
    f[1] = f[2] = f[3] = 1;
    f[4] = 2;    
    if(n <= 3 )
      {
        cout<<1<<endl;
        continue; 
      } 
        n -= 4; 
      kuai();
      cout<<f[4]<<endl;
    }
    return 0;
}
void kuai()
{
    int i,j,k;
    while(n > 0)
    {
        if(n % 2 == 1)
        {
            memset(c,0,sizeof(c));
            for(i = 1; i <= 4; i++)
              for(j = 1;j <= 1; j++)
                for(k = 1;k <= 4; k++)
                  c[i]  = (c[i] + a[i][k]*f[k])%inf;
            for(i = 1;i <= 4; i++)
              f[i] = c[i];          
        }
        memset(b,0,sizeof(b));
        for(i = 1;i <= 4; i++)
          for(j = 1;j <= 4; j++)
            for(k = 1;k <= 4; k++)
                b[i][j] = (b[i][j] + a[i][k]*a[k][j])%inf;
        for(i = 1;i <= 4; i++)
          for(j = 1;j <= 4; j++)        
            a[i][j] = b[i][j];    
        n /= 2;
    }
}

```

---

## 作者：B_Qu1e7 (赞：1)

这一篇，其实差不多算是1962的加强版，但是也没啥难度
矩阵乘法如何用：

比如说，我们有一个矩阵|a b c|

那么，要求下两项，就变成|b c a+c|

所以，要乘的矩阵应该是

A=

|0 0 1|

|1 0 0|

|0 1 1|这样一个三阶矩阵。（请自动脑补）

那么，乘的时候就变成

|a b c|×A×A×A×A×A（n个A）

重点出场了，怎么样优化

请注意，**矩阵乘法满足乘法结合律**

所以我们把后面的A先相乘，就变成了快速幂

具体解法见P3390【模板】矩阵快速幂

不多说，见代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int frog=1e9+7,t;ll n;
struct matrix{ll a[4][4];}A,ans;
void multi(matrix &a,matrix b)
{
    ll c[4][4]={0};
    for(int i=1;i<4;i++)for(int j=1;j<4;j++)for(int k=1;k<4;k++)c[i][j]+=a.a[i][k]*b.a[k][j],c[i][j]%=frog;
    for(int i=1;i<4;i++)for(int j=1;j<4;j++)a.a[i][j]=c[i][j];
}
inline void kasumi()
{
    for(int i=1;i<4;i++)for(int j=1;j<4;j++)ans.a[i][j]=A.a[i][j];n--;
    while(n){if(n%2==1)multi(ans,A);multi(A,A);n/=2;}
}
int main()
{
    scanf("%d",&t);
    for(int i=1;i<=t;i++)
    {
    	scanf("%lld",&n);
    	ans.a[1][1]=ans.a[1][2]=ans.a[1][3]=1;
    	A.a[1][1]=A.a[1][2]=A.a[2][2]=A.a[2][3]=A.a[3][1]=0,A.a[1][3]=A.a[2][1]=A.a[3][2]=A.a[3][3]=1;
    	kasumi();
    	printf("%lld\n",ans.a[1][3]%frog);
    }
}
/*
a b c
|0 0 1|
|1 0 0|
|0 1 1|
b c a+c
c a+c a+b+c
*/
//这里是矩阵乘的推断过程
```

---

## 作者：风灵无畏YY (赞：1)

看着下面大佬们的题解，很多都是用的4\*4的矩阵，我就说一种3\*3的吧

根据题目：

a[1]=a[2]=a[3]=1

a[x]=a[x-3]+a[x-1] (x>3)

我们可以用下面的矩阵a和矩阵b相乘得到c

a:               b:            c:

1  1  1   \*    0  0  1       2   3  4

1  0  0

0  1  1

然后我们就可以矩乘了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#define ll long long
#define mod 1000000007
using namespace std;
int n,tt;
struct matrix{
    ll m[4][4];
}a,b,t;
matrix mi(matrix a, matrix b){
    matrix t;//矩阵乘法
    for(int i=1;i<=3;++i)
        for(int j=1;j<=3;++j){
            t.m[i][j]=0;
            for(int k=1;k<=3;++k)
                t.m[i][j]=(t.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
        }
    return t;
}
matrix fast_m(matrix a,ll b){//矩阵快速幂
    matrix s=a,w=a; b--;
    while(b) {if(b&1) s=mi(w,s);w=mi(w,w);b>>=1;}
    return s;
}
int main(){
    scanf("%d",&n);
    b.m[1][1]=1;b.m[1][2]=1;b.m[1][3]=1;
    for(int i=1;i<=n;++i){
        scanf("%d",&tt);
        a.m[1][1]=0;a.m[1][2]=0;a.m[1][3]=1;
            a.m[2][1]=1;a.m[2][2]=0;a.m[2][3]=0;
            a.m[3][1]=0;a.m[3][2]=1;a.m[3][3]=1;//以上三行是赋初始值
        if(tt==1){ cout<<"1\n";continue;}
        if(tt==2){ cout<<"1\n";continue;}
        if(tt==3){ cout<<"1\n";continue;}//tt等于1,2,3的情况直接输出
        tt-=3;//从第4个开始，减去3；
        a=fast_m(a,tt);//得到矩乘后的一个新的矩阵
        for(int i=1;i<=1;++i)//再将这个矩阵与上述所说的a矩阵相乘，就会得到最后的c矩阵，在代码中a矩阵为b矩阵
            for(int j=1;j<=3;++j){
                t.m[i][j]=0;
                for(int k=1;k<=3;++k)
                    t.m[i][j]=(t.m[i][j]+b.m[i][k]*a.m[k][j])%mod;
            }
        printf("%lld\n",t.m[1][3]);//因为我们每次矩乘一次只会得到一个新的数字，并且是处于之前所讲的c矩阵的第三位，所以在这里输出最后一位
    }
    return 0;
}
```

---

## 作者：PHarr (赞：1)

矩阵快速幂的模板题，推到过程很简单
$$
\begin{matrix}a[i] = 1\times a[i-1] + 0\times a[i-2]+1\times a[i-3]\\
a[i-1] = 1\times a[i-1] + 0\times a[i-2]+0\times a[i-3]\\
a[i-2] = 0\times a[i-1] + 1\times a[i-2]+0\times a[i-3]\\
\Downarrow \\ 
\begin{bmatrix}f[i]\\f[i-1]\\f[i-2]\end{bmatrix}=\begin{bmatrix}1&0&1\\1&0&0\\0&1&0\end{bmatrix}\times \begin{bmatrix}f[i-1]\\f[i-2]\\f[i-3]\end{bmatrix}\end{matrix}
$$
直接暴力矩阵快速幂是可以过的，但有没有优化呢？

我们考虑离线来做这道题

首先我们把所有的数据读入，然后离散化，并排序

对与$ans_i$我们可以计算$d=n_i-n_i$得到一个差值

然后只需将$ans_{i-1}$乘上状态转移矩阵$f$的$d$次方，就是$ans_i$

可以通过这种操作来减少多次重复的运算

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;


const int N = 105 , M = 5 , mod = 1e9 + 7;
int n , key[N] , val[N] , ans[N];

struct matrix
{
	int x , y;
	LL v[M][M];
	
	matrix() { memset( v , 0 , sizeof(v) ); }
	
	inline friend matrix operator *  (matrix a , matrix b )
	{
		register matrix cur;
		cur.x = a.x , cur.y = b.y;
		for( register int i = 1 ; i <= cur.x ; i ++ )
		{
			for( register int j = 1 ; j <= cur.y ; j ++ )
			{
				cur.v[i][j] = 0;
				for( register int k = 1 ; k <= a.y ; k ++ ) cur.v[i][j] = ( cur.v[i][j] + a.v[i][k] % mod * b.v[k][j] % mod ) % mod;
			}
		}
		return cur;
	}
} f , res;


inline LL read()
{
	register LL x = 0;
	register char ch = getchar();
	while( ch < '0' || ch > '9' ) ch = getchar();
	while( ch >= '0' && ch <= '9' )
	{
		x = ( x << 3 ) + ( x << 1 ) + ch - '0';
		ch = getchar();
	}
	return x;
}

inline void matrix_I( matrix &t , int k)//构造单位矩阵
{
	t.x = t.y = k;
	for( register int i = 1 ; i <= k ; i ++ ) t.v[i][i] = 1;
}

inline matrix matrix_power( matrix x , int k )//矩阵快速幂
{
	if( k == 1 ) return x;
	register matrix t; matrix_I( t , 3 );
	while( k )
	{
		if( k & 1 ) t = t * x ;
		x = x * x;
		k >>= 1;
	}
	return t;
}

inline void init()
{
	f.x = f.y = 3;
	memset( f.v , 0 , sizeof( f.v ) );
	f.v[1][1] = f.v[1][3] = f.v[2][1] = f.v[3][2] = 1 ;
}


int main()
{
	n = read();
	for( register int i = 1 ; i <= n ; i ++ ) key[i] = val[i] = read();
	sort( val + 1 , val + 1 + n ) ;
	for( register int i = 1 ; i <= n ; i ++ ) key[i] = lower_bound( val + 1 , val + 1 + n , key[i] ) - val;
	res.x = 3 , res.y = res.v[1][1] = res.v[2][1] = res.v[3][1] = 1;
	val[0] = 3;
	for( register int i = 1 ; i <= n ; i ++ )
	{
		if( val[i] <= 3 ) { ans[i] = 1 , val[i] = 3 ; continue; }
		register int d = val[i] - val[ i - 1 ];//计算差值
		if( d == 0 ) //特殊情况
		{
			ans[i] = ans[ i - 1 ] ;
			continue;
		}
		init();//初始化 矩阵f 
		f = matrix_power( f , d );
		res = f * res;
		ans[i] = res.v[1][1] % mod;
	}
	for( register int i = 1 ; i <= n ; i ++ ) printf( "%d\n" , ans[ key[i] ] );
	return 0;
}
```





# 

---

## 作者：KKarshilov (赞：1)

才学了矩阵加速，来练练手

先看这个特征方程F[i] = F[i - 1] + F[i - 3]，那么就有一个矩阵如下 ![](https://cdn.luogu.com.cn/upload/pic/10507.png)

我们的目标矩阵就是 ![](https://cdn.luogu.com.cn/upload/pic/10509.png)

那么，针对这个矩阵我们如何转置呢？

先看目标矩阵第一个：F[i]

F[i] = F[i - 1] + F[i - 3]

那么，由矩阵乘法，转置矩阵第一行，似乎就定了：1 0 1

同样的，二三行就是1 0 0 和 0 1 0

整个矩阵如下：

 ![](https://cdn.luogu.com.cn/upload/pic/10511.png) 

至于转置矩阵和初始矩阵的用法？矩阵快速幂，建议先过<https://www.luogu.org/problemnew/show/3390>

Code:
```cpp
#include <bits/stdc++.h>
const int mod = 1000000007;
int n;
inline int read()
{
    int ch;int x = 0;int f = 1;ch=getchar();
    while (ch!='-'&&(ch<'0'||ch>'9'))
        ch=getchar();
    ch=='-'?f=-1:x=ch-'0',ch=getchar();
     while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
     return x*f;
}
struct Mat {
    long long mat[3][3];
};
Mat operator * (Mat a, Mat b) {
    Mat c;
    memset(c.mat, 0, sizeof(c.mat));
    for(int i = 0; i < 3; i++) {
        for(int k = 0; k < 3; k++) {
            for(int j = 0; j < 3; j++) {
                c.mat[i][j] += (a.mat[i][k] % mod) * (b.mat[k][j] % mod) % mod;
                c.mat[i][j] %= mod;
            }
        }
    }
    return c;
}
Mat operator ^ (Mat a, long long k)  {
    Mat c;
    for(int i = 0; i < 3; i++)
        for(int j = 0; j < 3; j++) c.mat[i][j] = (i == j);
    while(k) {
        if(k & 1) c = c * a;
        a = a * a;
        k >>= 1;
    }
    return c;
}
Mat init;
Mat fi;
int t;
signed main()
{
    scanf("%d", &t);
    while(t--)
    {
        memset(init.mat, 0, sizeof(init.mat));
        memset(fi.mat, 0, sizeof(fi.mat));
        scanf("%d", &n);
        init.mat[0][0] = 1;
        init.mat[0][2] = 1;
        init.mat[1][0] = 1;
        init.mat[2][1] = 1;
        fi.mat[0][0] = 1;
        fi.mat[1][0] = 1;
        fi.mat[2][0] = 1;
        if(n <= 3) printf("%d\n", 1);
        else{
            init = init ^ (n - 3);
            fi = init * fi;
            printf("%d\n", fi.mat[0][0]);
        }
    }
    return 0;
}

```

---

## 作者：swain (赞：1)

矩阵快速幂，要考虑m<=3


    
    
        
        
    
    
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <climits>
#include <cstring>
using namespace std;
struct maxtrix
{
    long long a[3][3];
    long long h;
    long long l;
    };
maxtrix a,b;
long long n,m;
const int mod=1000000007;
maxtrix cf(maxtrix x,maxtrix y)
    {
        maxtrix ans;
        ans.h=ans.l=3;
        memset(ans.a,0,sizeof(ans.a));
        for (int i=0;i<x.h;i++)
            for (int j=0;j<y.l;j++)
                for (int k=0;k<x.l;k++)
                {
                    ans.a[i][j]+=x.a[i][k]*y.a[k][j];
                    ans.a[i][j]=ans.a[i][j]%mod;
                    }
        return ans;
        }
maxtrix qsm(maxtrix a,int b)
    {
        maxtrix t=a;
        maxtrix y;
        memset(y.a,0,sizeof(y.a));
        y.a[0][0]=1;
        y.a[1][1]=1;
        y.a[2][2]=1;
        y.h=y.l=3;
        while (b!=0)
        {
            if (b&1) y=cf(t,y);
            t=cf(t,t);
            b=b>>1;
            }
        return y;
        }
int main()
{
    cin>>n;
    for (int wtf=0;wtf<n;wtf++){
        cin>>m;
        if (m<=3&&m>0) {cout<<1<<endl; continue;} else if (m<=0) {cout<<0<<endl; continue;} 
        memset(a.a,0,sizeof(a.a));
        memset(b.a,0,sizeof(b.a));
        a.a[0][0]=1;
        a.a[0][2]=1;
        a.a[1][0]=1;
        a.a[2][1]=1;
        b.a[0][0]=1;
        b.a[1][0]=1;
        b.a[2][0]=1;
        b.h=3;
        b.l=1;
        a.l=a.h=3;
        a=qsm(a,m-3);
        a=cf(a,b);
        cout<<a.a[0][0] % 1000000007<<endl;
    }
    return 0;
}
```

---

## 作者：Maika (赞：0)

# 前言
本篇题解是继矩阵快速幂之后的矩阵的第二篇题解，第一篇参看[矩阵快速幂](https://www.luogu.org/blog/QAQ1246/the-road-from-entry-to-proficiency-of-matrix)

# Tips
本题解的阅读前提是你需要懂得：

1.矩阵的基本知识

2.矩阵快速幂
# 矩阵加速

其实这个东西就是矩阵快速幂的啦！

矩阵加速指的是通过构建矩阵将线性递推式的计算时间复杂度从$O(n)$降低至$O(\log_2 n)$

先来看看以下线性递推数列：

$f(n) =
\begin{cases} 
1 & n=1,2,3 \\
f(n-1)+f(n-3) & n>3
\end{cases}$

所以我们可以得到以下线性方程组：
$\begin{cases}
f(n)=f(n-1)+f(n-3) \\
f(n-1)=f(n-1) \\
f(n-2)=f(n-2)
\end{cases}$

基于这个线性方程组，我们可以建立一个$1 \times 3$的矩阵（向量组）
$B=\left[\begin{matrix}1\\1\\1\\\end{matrix}\right] \iff B=\left[\begin{matrix}f(n)\\f(n-1)\\f(n-2)\\\end{matrix}\right]$

再建立一个$3 \times 3$的矩阵
$A=\left[\begin{matrix}1 & 0 & 1\\1 & 0 & 0\\0 & 1 & 0\\\end{matrix}\right] \iff \begin{cases}
f(n)=f(n-1)+f(n-3) \\
f(n-1)=f(n-1) \\
f(n-2)=f(n-2)
\end{cases}$

所以有

$f(n) =
\begin{cases} 
1 & n=1,2,3 \\
B \times A^n& n>3
\end{cases}$

那么我们发现$A^k$可以用矩阵快速幂来做

所以有代码如下

```cpp
#include<bits/stdc++.h>
#define Mod 1000000007
using namespace std;
struct Matrix {
	long long key[10][10];
};
Matrix operator *(Matrix &x,Matrix &y) {
	Matrix C;
	for(int i=1; i<=3; i++)
		for(int j=1; j<=3; j++)
			C.key[i][j]=0;
	for(int i=1; i<=3; i++)
		for(int j=1; j<=3; j++)
			for(int k=1; k<=3; k++)
				C.key[i][j]=(C.key[i][j]+x.key[i][k]*y.key[k][j]%Mod)%Mod;
	return C;
}
void Fastpower(int t) {
	Matrix A,I;
	for(int i=1; i<=3; i++)
		for(int j=1; j<=3; j++) {
			A.key[i][j]=0;
			I.key[i][j]=0;
		}
	for(int i=1; i<=3; i++) I.key[i][i]=1;
	A.key[1][1]=A.key[1][3]=A.key[2][1]=A.key[3][2]=1;
	while(t) {
		if(t&1) I=A*I;
		A=A*A;
		t=t>>1;
	}
	cout<<I.key[2][1]<<endl;
	return;
}
int T,n;
int main() {
	cin>>T;
	for(int i=1; i<=T; i++) {
		int k;
		cin>>k;
		Fastpower(k);
	}
	return 0;
}

```
值得注意的是，因为此处$f(1)=f(2)=f(3)=1$，所以我们不需要用计算出来的$A^k \times B$,直接输出${A^k}_{(21)}$即可


  [1]: https://www.luogu.org/blog/QAQ1246/the-road-from-entry-to-proficiency-of-matrix

---

## 作者：PI_AC (赞：0)


# 题目
[数列](https://www.luogu.org/problemnew/show/P1939)
# 题解
首先说一下矩阵乘法：

假设矩阵$A$和矩阵$B$做乘法得到矩阵$C$，则必须满足矩阵$A$的列数等于矩阵$B$的行数

即如果矩阵$A$有$n$行$m$列，则矩阵$B$有$m$行$p$列，矩阵$C$就有$n$行$p$列

那么矩阵乘法怎么做呢？
公式：
$$C[i][j] = \sum_{i =1}^{n}\sum_{j = 1}^{p}\sum_{k = 1}^{m}A[i][k]*B[k][j]$$
一句话就是$C[i][j]$为矩阵$A$的第$i$行和矩阵$B$的第$j$列对位相乘之和

有了这个那么我们解题就方便了许多

我们假设原来的的一个矩阵$A$为$\begin{bmatrix}a[1],a[2],a[3]\end{bmatrix}$，我们想要把这个矩阵变为$\begin{bmatrix}a[2],a[3],a[4]\end{bmatrix}$，我们应该如何操作呢？

假设新矩阵是由矩阵$A$乘一个矩阵$P$得到，那么可以确定$P$是一个$3*3$的矩阵
令矩阵$P$为$\begin{bmatrix}p_{11},p_{12},p_{13}\\p_{21},p_{22},p_{23}\\p_{31},p_{32},p_{33}\end{bmatrix}$

根据矩阵乘法的法则，可以得到新矩阵为
$\begin{bmatrix}a[1]*p_{11}+a[2]*p_{21}+a[3]*p_{31},a[1]*p_{12}+a[2]*p_{22}+a[3]*p_{32},a[1]*p_{13}+a[2]*p_{23}+a[3]*p_{33}\end{bmatrix}$

所以我们可以得到一个方程：$\begin{cases}a[1]*p_{11}+a[2]*p_{21}+a[3]*p_{31}=a[2]\\a[1]*p_{12}+a[2]*p_{22}+a[3]*p_{32}=a[3]\\a[1]*p_{13}+a[2]*p_{23}+a[3]*p_{33}=a[4]\end{cases}$
$\because a[i]=a[i-1]+a[i-3]$
$\therefore p_{21}=1,p_{32}=1,p_{13}=p_{33}=1$，其它的数都为0

可以看出我们乘一次就可以得到$a[4]$，得到$a[n]$就需要乘$n-3$次，用一个矩阵快速幂即可求解
# 代码
```cpp
#include <cstdio>
#include <cstring>
#define reg register

template <class T>
inline T read() {
    T x = 0; T f = 1; char s = getchar();
    while(s < '0' || s > '9') {if(s == '-') f = -1; s = getchar();}
    while(s >= '0' && s <= '9') {x = (x << 3) + (x << 1) + s - 48; s = getchar();}
    return x * f;
}

template <typename T>
inline void wri(T x) {
    if(x < 0) {x = -x; putchar('-');}
    if(x / 10) wri(x / 10);
    putchar(x % 10 + 48);
}

template <typename T>
inline void write(T x, char s) {
    wri(x);
    putchar(s);
}

#define LL long long

const LL mod = 1e9 + 7;

int T;
LL N;

struct matrix {
    int n, m;
    LL a[5][5];
    inline void cl() {
        n = m = 0;
        memset(a, 0, sizeof a);
    }
    inline matrix operator * (const matrix & rhs) const {
        matrix ans;
        ans.cl();
        ans.n = n, ans.m = rhs.m;
        for(reg int i = 1;i <= n;i ++)
            for(reg int j = 1;j <= rhs.m;j ++)
                for(reg int k = 1;k <= m;k ++)
                    ans.a[i][j] = (ans.a[i][j] + (a[i][k] * rhs.a[k][j]) % mod) % mod;
        return ans;
    }
}A, p;

inline matrix qkpow(matrix x, LL y) {
    matrix ans;
    ans.cl();
    ans.n = x.n, ans.m = x.m;
    for(reg int i = 1;i <= ans.n;i ++)
        ans.a[i][i] = 1;
    while(y) {
        if(y & 1)
            ans = ans * x;
        x = x * x;
        y >>= 1;
    }
    return ans;
}

int main() {
    T = read<int>();
    p.n = 3, p.m = 3, p.a[1][3] = p.a[2][1] = p.a[3][2] = p.a[3][3] = 1;
    while(T --) {
        A.cl();
        A.n = 1, A.m = 3, A.a[1][1] = A.a[1][2] = A.a[1][3] = 1;
        N = read<LL>();
        if(N < 3) {
            write(1, '\n');
            continue;
        }
        A = A * (qkpow(p, N - 3));
        write(A.a[1][3], '\n');
    }
    return 0;
}
```

---

## 作者：xy_xw_for_2024 (赞：0)

这道题是一道非常简单的矩阵加速题，可以用来练练手

注：LGOJ上的Markdown不能插入公式，最好在作者的[原文](https://blog.csdn.net/qq_43890190/article/details/89146448)上看

我们可以很轻松的想到原数组：A=[a1 a2 a3]

也就是[ai ai+1 ai+2]

那么我们要构造一个的加速矩阵

首先，ai直接可以变成ai+1

所以加速矩阵的第一列就是[0 1 0]

然后，ai+1也可以直接由原数组得到ai+2

所以加速矩阵的第二列就是[0 0 1]

最后，ai+2变到ai+3需要他本身再加上ai

所以最后一列就是[1 0 1]

综上：：

A=[a1 a2 a3]

      |0 0 1|
    B=|1 0 0|
      |0 1 1|


这就是这道题的基本结构

还要注意几个细节

- 无限输入
- 换行
- 乘n-1次

自此我们可以给出代码：：
```
#include<cstdio>
#include<cstring>
inline void read(long long &x) {
    x=0;
    long long f=1;
    char s=getchar();
    while(s<'0'||s>'9') {
        if(s=='-')
            f=-1;
        s=getchar();
    }
    while(s>='0'&&s<='9') {
        x=x*10+s-48;
        s=getchar();
    }
    x*=f;
}
inline void pr(long long x) {
    if(x<0) {
        putchar('-');
        x=-x;
    }
    if(x>9)
        pr(x/10);
    putchar(x%10+48);
}//快读快输不解释
long long A[3][3]= {{0,0,1},{1,0,0},{0,1,1}},n,m,ans[3]= {1,1,1},s[3];//构建加速矩阵、初始矩阵、答案矩阵
inline void cheng(long long a[3][3],long long b[3][3]) {//矩阵乘法运算
    long long c[3][3];
    memset(c,0,sizeof(c));//初始化
    for(long long i=0; i<3; i++)
        for(long long j=0; j<3; j++)
            for(long long k=0; k<3; k++)
                c[i][j]=(c[i][j]+a[i][k]%m*b[k][j]%m)%m;//矩阵乘法
    memcpy(a,c,sizeof(c));//传答案
}
inline void ksm(long long a[3][3],long long k) {//模拟快速幂
    if(k==1) {//只有一次
        memcpy(a,A,sizeof(A));//直接传
        return;
    }
    long long c[3][3];
    ksm(c,k/2);//除以二
    cheng(c,c);//平方
    if(k&1)//k为奇数
        cheng(c,A);
    memcpy(a,c,sizeof(c));//传答案
}
long long T;
int main() {
    read(T);
    m=1000000007;
    while(T--) {
        read(n);
        if(n==1||n==2)//特殊判断
            putchar(49),putchar('\n');//注意换行
        else {
            ksm(A,n-1);//加速
            for(long long j=0; j<3; j++)
                for(long long k=0; k<3; k++)
                    s[j]=(s[j]+ans[k]%m*A[k][j]%m)%m;//最后还要再乘一次
            pr(s[0]),putchar('\n');
        }
        A[0][0]=A[0][1]=A[1][1]=A[1][2]=A[2][0]=s[0]=s[1]=s[2]=0;
        A[0][2]=A[1][0]=A[2][1]=A[2][2]=ans[1]=ans[2]=ans[3]=1;//无限输入注意清零
    }
}
```
这就是这道题的全部代码

有错误的欢迎指出

[作者原文在这里哟](https://blog.csdn.net/qq_43890190/article/details/89146448 )

---

## 作者：wpgwhpg (赞：0)

虽然是矩阵加速的板子题，但是作为机房蒟蒻花了挺长时间； 
看了各位大佬们好想跟我的思路不太一样，而且几乎全是结构体，就想写篇题解~~为我们蒟蒻们量身定制的非结构体~~；
不说废话了；首先需要写出初始矩阵，矩阵的横竖全部根据个人的喜好，我觉得横着写比较合适；   
因为这道 题的f[n]=f[n-1]+f[n-3]很容易想到初始矩阵需要用三个数，f[n],f[n-1],f[n-2]它之前的矩阵是f[n-1],f[n-2],f[n-3];然后就需要发挥凑数能力了，这里不再多说了，转移矩阵就是
1 1 0        
0 0 1  
1 0 0      
然后矩阵快速幂最后的答案是转移矩阵的n-4次方得到的矩阵的第一列的数的和  
代码如下：
```
#include<iostream>
#include<cstdio>
#define lint long long 
using namespace std;
const int mod=1e9+7; 
lint t,n,tmp[4][4],x; 
lint ans[4][4],f[4][4];
void tc()
{
	for(lint i=1;i<=3;i++)
	 for(lint j=1;j<=3;j++)
	   tmp[i][j]=ans[i][j],ans[i][j]=0;   
	for(lint i=1;i<=3;i++)
	 for(lint j=1;j<=3;j++) 
	  for(lint k=1;k<=3;k++)
	  ans[i][j]=(ans[i][j]+f[i][k]*tmp[k][j])%mod;
}
void zc()
{
	for(lint i=1;i<=3;i++)
	 for(lint j=1;j<=3;j++)
	  tmp[i][j]=f[i][j],f[i][j]=0;
	for(lint i=1;i<=3;i++)
	 for(lint j=1;j<=3;j++)
	  for(lint k=1;k<=3;k++)
	  f[i][j]=(f[i][j]+tmp[i][k]*tmp[k][j])%mod;
}
lint kuai(lint y)
{
	ans[1][1]=f[1][1]=1,ans[1][2]=f[1][2]=1,ans[1][3]=f[1][3]=0;
	ans[2][1]=f[2][1]=0,ans[2][2]=f[2][2]=0,ans[2][3]=f[2][3]=1;
	ans[3][1]=f[3][1]=1,ans[3][2]=f[3][2]=0,ans[3][3]=f[3][3]=0;
	while(y)
	{
		if(y&1) tc();//类似快速幂的res=res*a，对答案矩阵进行乘法；
		zc(); //类似快速幂的a=a*a,每次a做自乘；
		y>>=1;
	}
	lint a=(ans[1][1]+ans[2][1]+ans[3][1])%mod;
	return a;
}
int main()
{
	scanf("%d",&t);
	for(lint i=1;i<=t;i++)
	{
		scanf("%lld",&x);
		if(x<=3) printf("1\n");
		else cout<<kuai(x-4)<<endl;
	}
	return 0;
}
```

---

## 作者：Yohe (赞：0)

	F(n) = F(n - 1) + F(n - 3)
    当 n 极大时，传统的递推肯定不能在规定时间里完成。我们考虑利用矩阵乘法。
    首先考虑结果中的矩阵，我们可以得到F(n)的答案。
    第二步我们去考虑含有变量的矩阵，既然我需要的到F(n)，此时就需要包含F(n - 1)，F(n - 3)。
    对应的我们在结果中也要有对应的F(n - 2)，这是没有出现在结果矩阵和转移矩阵的变量，为了方便转移，我们也把F(n - 2)放在转移矩阵。这是结果矩阵需要F(n - 1)。
    ![](https://cdn.luogu.com.cn/upload/pic/27547.png)
    我们来考虑左边的矩阵应该填什么。
    左边第一行 * 右边的第一列 = 结果第一行第一列，第一个元素，第三个元素需要利用，即为1。
    左边第二行 * 右边的第一列 = 结果第二行第一列，只有第一个元素需要利用，即为1。
    左边第三行 * 右边的第一列 = 结果第三行第一列，只有第二个元素需要利用，即为1.
    我们得到了全部的矩阵。现在考虑我们需要乘上几个左边的矩阵。现在我们知道F(1)，F(2)，F(3)；
    推F(4)我们需要乘上1次，那么易得推F(n)我们只要乘上n-3次。
    ```
	#include<cstdio>
	#include<cstring>
	const int mod = 1000000007;
	using namespace std;
	struct Matrix{
   	 long long  ans[3][3];
	}res;
	int T, n;
	Matrix Mul(Matrix a, Matrix b){
    	Matrix c;
    	memset(c.ans, 0, sizeof(c.ans));
   		for (int i = 0; i < 3; ++i)
   	 	for (int j = 0; j < 3; ++j)
    	for (int k = 0; k < 3; ++k) 
    	c.ans[i][j] = (c.ans[i][j] + a.ans[i][k] * b.ans[k][j] % mod) % mod;
    	return c;
	}
	Matrix Pow(Matrix a, int n){
    	memset(res.ans, 0, sizeof(res.ans));
    	res.ans[0][0] = res.ans[1][1] = res.ans[2][2] = 1;
    	while (n) {
        	if (n & 1) res = Mul(a, res);
        	a = Mul(a, a);
        	n >>= 1;
    	}
    	return res;
	}
	int main(){
    	scanf("%d",&T);
    	while (T--) {
        	scanf("%d",&n);
        	if (n <= 3) puts("1");
        	else {
            	Matrix p;
            	memset(p.ans, 0, sizeof(p.ans));
            	p.ans[0][0] = p.ans[0][2] = p.ans[1][0] = p.ans[2][1] = 1;
            	p = Pow(p, n - 3);
            	Matrix p1;
            	p1.ans[0][0] = p1.ans[1][0] = p1.ans[2][0] = 1;
            	p = Mul(p, p1);
            	printf("%lld\n",p.ans[0][0]);
        	}
    	}
	}
```

---

## 作者：Dog_Two (赞：0)

其实只要构建了一个正确的递推矩阵，就不用特判n<=3的情况了。

我们都知道:
当我们已经知道a1 a2 a3时，就有a4=a1+a3。
对于原矩阵是

1 1 1

的情况

递推矩阵就是：

0 0 1

1 0 0

0 1 1



在我们时间不紧张的时候，我们其实可以通过这一道题目来强化基础代码的能力，比如通过强制转换对象格式来定义矩阵，以及重载运算符等，这正是这份题解想体现的。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD=1000000007;
int T,n; 
struct matrix{
	int n,m;//n行m列 
	int a[3][3];
	void clear(){memset(a,0,sizeof(a));}
};

matrix operator * (const matrix &a,const matrix &b){
	matrix res; res.clear();
	res.n=a.n,res.m=b.m;
	for(int i=0;i<res.n;++i)
		for(int j=0;j<res.m;++j)
			for(int k=0;k<res.m;++k)
				res.a[i][j]=((long long)res.a[i][j]+(long long)a.a[i][k]*b.a[k][j])%MOD;
	return res;
}

matrix quick_pow(matrix const &C,matrix const &A,int q){
	matrix a=A,c=C;
	for(;q;q>>=1){
		if(q&1) c=c*a;
		a=a*a;
	}
	return c;
}



int main(){
	matrix Ori=(matrix){1,3,{1,1,1}};
	matrix Upd=(matrix){3,3,{{0,0,1},{1,0,0},{0,1,1}}};
	cin>>T;
	while(T--){
		cin>>n;
		cout<<quick_pow(Ori,Upd,n-1).a[0][0]<<endl;
	}
	return 0;
}
```

---

## 作者：JustinRochester (赞：0)

[题目](https://www.luogu.org/problemnew/show/P1939)

震惊！某蒟蒻爆零近 $10$ 次的原因竟然是......

溢出/喷血

-----------

**【分析】**
------------

对于 $t$ 次询问，每次询问 $x$ ，每次都直接输出答案 $a_x$ 即可

考虑到 $x$ 的范围， $2\times 10^9$ 以下，不考虑采用数组存（存不下）

因此可以直接 pass 一个一个的那种递推，如果一个一个推，绝对会超时

那么考虑到 $x$ 是乱序的，而且就算 $x$ 有序，前一次的答案也不方便推出后一次的答案，因此不考虑先全部读入，排序后再统一计算的方法

首先，根据题意：

$ a_{n+3}=a_{n+2}+a_{n} $

$ a_{n+2}=a_{n+2} $

$ a_{n+1}=a_{n+1} $


也就是：

$ a_{n+3}=  1×a_{n+2}  +0×a_{n+1}  +1×a_n $

$ a_{n+2}=  1×a_{n+2}  +0×a_{n+1}  +0×a_n $

$ a_{n+1}=  0×a_{n+2}  +1×a_{n+1}  +0×a_n $

这里有一个比较明显的矩阵关系：

$\left[\begin{matrix}\ a_{n+3}\ \\ \\a_{n+2}\\ \\a_{n+1}\end{matrix}\right]=\left[\begin{matrix}\ 1&0&1\ \\ \\1&0&0\\ \\0&1&0\end{matrix}\right]\times\left[\begin{matrix}\ a_{n+2}\ \\ \\a_{n+1}\\ \\a_n\end{matrix}\right]$

那么，对于所求的 $a_x$ ,可以知道 $a_x$ 是 $(x-1)$ 个中间的那个矩阵与右边的矩阵相乘后，取最后一行的第一个值而得

又因为:

$\left[\begin{matrix}\ a_3\ \\ \\a_2\\ \\a_1\end{matrix}\right]=\left[\begin{matrix}\ 1\ \\ \\1\\ \\1\end{matrix}\right]$

故此可以对输入的 $x$ 先减去 $1$ ，而后用 $(x-1)$ 进行矩阵的快速幂运算(矩阵加速)，再定义一个矩阵为

$\left[\begin{matrix}\ 1&0&0\ \\ \\1&0&0\\ \\1&0&0\end{matrix}\right]$

将快速幂的值与之相乘，第三行第一项就是结果

快速幂就推荐用这种打法:

```cpp
int ans(int n){

//exp[i]表示中间那个矩阵的i次方
//vec为最后面那个矩阵

	mat a=exp[0];
	for(int i=0;n>0;i++,n>>=1)
		if(n&1) a=a*exp[i+1];
	a=a*vec;
	return a.num[2][0];
	
//乘法用重载运算符写
}
```

-------------------

**【代码】**
-------------
那本蒟蒻就放代码了:

```cpp
#include<cstdio>
using namespace std;
#define isdigit(c) ((c>='0')&(c<='9'))
inline int read(){
	int ans=0;char c=getchar();while(!isdigit(c)) c=getchar();
	while(isdigit(c)) ans=ans*10+c-'0',c=getchar();
	return ans;
}//条件反射的读入优化
struct mat{
	long long int num[3][3];//不这么打很容易溢出
	mat() { for(int i=0;i<9;i++) num[i/3][i%3]=0; }
	mat operator * (const mat &x){
		mat y;
		for(int i=0;i<3;i++)
			for(int j=0;j<3;j++)
				for(int k=0;k<3;k++)
					y.num[i][j]=(y.num[i][j]+(num[i][k]%1000000007)*(x.num[k][j]%1000000007)%1000000007)%1000000007;//暴力膜
		return y;
	}
}exp[32],vec;
void pre(){
	vec.num[0][0]=vec.num[1][0]=vec.num[2][0]=1;
	exp[0].num[0][0]=exp[0].num[1][1]=exp[0].num[2][2]=1;
	exp[1].num[0][0]=exp[1].num[0][2]=exp[1].num[1][0]=exp[1].num[2][1]=1;
	for(int i=2;i<32;i++) exp[i]=exp[i-1]*exp[i-1];
}//预处理exp和vec，exp只要到31次方就够了(2×10^9 < 2^32)
int ans(int n){
	mat a=exp[0];
	for(int i=0;n>0;i++,n>>=1)
		if(n&1) a=a*exp[i+1];
	a=a*vec;
	return a.num[2][0];
}
int main(){
	pre();//先皮(pre)一下2333
	int t=read();
	while(t--) printf("%d\n",ans(read()-1));
	return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/#)

---

## 作者：hehelego (赞：0)

# talk is cheep show me the code 

本题前置技能：矩阵快速幂模板，知道如何把一次（一阶?我没学过数学抱歉）的递推式用矩阵乘法表示。

这里推荐一波某dalao的blog:[矩阵构造方法](http://www.cnblogs.com/frog112111/archive/2013/05/19/3087648.html)
模板的话,随便找一份看一波，能按照自己的理解写出来就好了，不过我仍然~~厚颜无耻~~推荐我这种易于编写的模板，就是用vector存数据，重载运算符即可，不需要写奇怪的get/set之类的东西，深拷贝？vector已经帮我们写好啦，并不需要。

推导过程这里简略写下：
1.	求an，需要an-1,an-2,an-3,考虑用bn = (an+1,an+2,an+3)作为状态
2.	列出bn与bn+1的递推关系(an+2,an+3,an+4)=(0*an+1+1*an+2+0*an+3,0*an+1+0*an+2+1*an+3,1*an+1+0*an+2+1*an+3)
3.	看一下1,2的形式，发现可行（能递推，不会漏掉某些项），当然如果不行的话，考虑在状态中加入an+4，加到能产生递推关系为止
4.	矩阵乘是有结合律的（交换律当然没有了...~~前排推荐百度百科矩阵乘法~~,bn=b1*A*A*A.......=b1*A^(n-2)
5.	敲代码去了

~~不怕TLE/MLE~~可以放心使用
前排提醒，本代码中使用了一些C++11特性，使用了异常，只是过题的话可以手动替换掉/删除掉。
```cpp
  #include <iostream>
  #include <functional>
  #include <algorithm>
  #include <vector>
  #include <exception>

  typedef std::vector<unsigned long long> Vector;
  typedef std::vector<Vector> Matrix;

  unsigned long long mod=1000000007ULL;
  Matrix matrix(int n=1,int m=1){
    return Matrix(n,Vector(m,0));
  }
  Matrix unit(int n){
    Matrix ret=matrix(n,n);
    for(int i=0;i<n;i++)
      ret[i][i]=1ULL;
    return ret;
  }
  Matrix operator*(const Matrix& a,const Matrix& b){
    int n=a.size(),m=a[0].size(),p=b[0].size();
    Matrix ret=matrix(n,p);
    if(b.size()!=m) throw std::exception();
    for(int i=0;i<n;i++){
      for(int j=0;j<p;j++){
        unsigned long long dot=0ULL;
        for(int k=0;k<m;k++)
          dot+=(a[i][k]*b[k][j])%mod;
        ret[i][j]=dot;
      }
    }
    return ret;
  }
  void deepcopy(const Matrix&& from,Matrix& to){
    for(int i=0;i<from.size();i++)
    for(int j=0;j<from[0].size();j++)
      to[i][j]=from[i][j];
  }
  Matrix qpow(const Matrix& m,unsigned long long k){
    if(k==0)return unit(m.size());
    if(k==1)return m;
    if(k==2)return m*m;
    if(k&1) return qpow(qpow(m,k>>1),2)*m;
    else    return qpow(qpow(m,k>>1),2);
  }
  Matrix operator^(const Matrix& m,unsigned long long k){
    if(m.size()!=m[0].size())throw std::exception();
    return qpow(m,k);
  }
  void out(const Matrix& a){
    int n=a.size(),m=a[0].size();
    std::cout << "Matrix("<<n<<"*"<<m<<")[" << '\n';
    for(int i=0;i<n;i++){
      std::cout << "[";
      for(int j=0;j<m;j++){
        std::cout << a[i][j] << ",";
      }
      std::cout << "]," << '\n';
    }
    std::cout << "]" << '\n';
  }
  void out(const Vector& a){
    int n=a.size();
    std::cout << "Vector("<<n<<")[ " ;
    for(int i=0;i<n;i++)
        std::cout << a[i] << ",";
    std::cout << " ]" << '\n';
  }

  int main(){
    Matrix m=matrix(3,3);
    m[0]=Vector{0,0,1};
    m[1]=Vector{1,0,0};
    m[2]=Vector{0,1,1};
    int t,n;std::cin >> t;
    while(t--){
      std::cin >> n;
      if(n<=3){
        std::cout << 1 << '\n';
        continue;
      }
      Matrix t=matrix(3,3);
      deepcopy(m^(n-3),t);
      // out(t);
      std::cout << (t[0][2]+t[1][2]+t[2][2])%mod << '\n';
    }
    return 0;
  }

```


---

## 作者：ckd飞鼠 (赞：0)

如果按照题目给的递推公式直接计算，时间复杂度为O(tn)，无法在时限内完成

所以就要考虑使用矩阵优化（废话

原理楼下的几位dalao已经解释清楚了，我就来扔另一种矩阵和一份丑陋的pascal代码


**初始矩阵**

1 0 0
**递推矩阵**

1 1 0
0 0 1
1 0 0
最终的结果就是将**初始矩阵**乘以**递推矩阵**的(n-1)次幂


然后扔代码

```pascal
const jzm=1000000007;
type arr=array [0..3,0..3] of longint;
var a,c,d:arr;
    b,e:array [0..3] of longint;
    t,n,i,j:longint;

function mult(x,y:arr):arr;
var i,j,k:longint;
begin
fillchar(mult,sizeof(mult),0);
for i:=1 to 3 do
    for j:=1 to 3 do
        for k:=1 to 3 do
            mult[i,j]:=(mult[i,j] mod jzm+((x[i,k] mod jzm)*(y[k,j] mod jzm))) mod jzm;
end;

function mi(p:longint):arr;
begin
if p=0 then exit(d);
mi:=mi(p shr 1);
mi:=mult(mi,mi);
if p mod 2=1 then mi:=mult(mi,c);
end;

begin
read(t);
while t>0 do
    begin
     read(n);
     a[1,1]:=1; a[1,2]:=1; a[1,3]:=0;
     a[2,1]:=0; a[2,2]:=0; a[2,3]:=1;
     a[3,1]:=1; a[3,2]:=0; a[3,3]:=0;
     b[1]:=1;
     c:=a;
     d[1,1]:=1; d[2,2]:=1; d[3,3]:=1;
     a:=mi(n-1);
     for j:=1 to 3 do
        begin
         e[j]:=0;
         for i:=1 to 3 do
            e[j]:=(e[j] mod jzm+((a[i,j] mod jzm)*(b[i] mod jzm)) mod jzm) mod jzm;
        end;
     writeln(e[1]);
     dec(t);
    end;
end.
```
我永远喜欢pascal.jpg


---

## 作者：12mango (赞：0)

初始矩阵我们记作fst，递推矩阵记作trans ↓

**1 1 1**    **1 1 0**

**0 0 0**    **0 0 1**

**0 0 0**    **1 0 0**

那么fst+1=fst\*trans,fst+2=(fst+1)\*trans……

易得ans=fst\*(trans^(n-3))

注意乘积爆int需要强转long long。

另外n<=3的情况需要特判，这道题就做完了。


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define mod 1000000007 
using namespace std;
int n; 
struct Mat 
{
    int x,y;
    int arr[5][5];
    Mat(){}
    Mat(const int _x,const int _y)
    {
        x=_x,y=_y; 
        memset(arr,0,sizeof(arr)); 
    }
    void unit()
    {
        for(int i=1;i<=x;++i) arr[i][i]=1; 
    }
    Mat operator*(Mat b)
    {
        Mat a=*this,c(a.x,b.y);
        for(int i=1;i<=c.x;++i)
            for(int j=1;j<=c.y;++j)
                for(int k=1;k<=a.y;++k)
                    (c.arr[i][j]+=(long long)a.arr[i][k]*b.arr[k][j]%mod)%=mod;
        return c; 
    }
    Mat operator^(const int B)
    {
        int b=B; 
        Mat ret(3,3),X=*this;
        ret.unit();
        while(b){
            if(b&1) ret=ret*X;
            X=X*X; 
            b>>=1; 
        }
        return ret; 
    }
};
int main()
{
    int T;
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        if(n<=3){
            printf("%d\n",1);
            continue; 
        }
         Mat trans(3,3),fst(3,3);
        trans.arr[1][1]=trans.arr[1][2]=trans.arr[2][3]=trans.arr[3][1]=fst.arr[1][1]=fst.arr[1][2]=fst.arr[1][3]=1;
        Mat ans=fst*(trans^(n-3)); 
        printf("%d\n",ans.arr[1][1]); 
    }
    return 0; 
} 
```

---

## 作者：汇文客 (赞：0)

3\*3矩阵解决方法：

an        1 0 1            an-1

an-1 = 1 0 0 ^(n-3) an-2

an-2     0 1 0            an-3

而矩阵是可以用快速幂处理的，这样时间复杂度为（tlog2n）。

唯一的问题在于，矩阵的处理比较麻烦，多数同学的代码比较冗长。在这里扯一个OI之外的话题——MATLAB。

MATLAB意为“矩阵实验室”，是世界三大数学软件之一，最擅长的就是灭矩阵。

这是解决此题的MATLAB代码，真的很简短。

```cpp
function ksm= Untitled(n)
    ksm=0;
    mat=[1,0,1;1,0,0;0,1,0];
    ini=ones(3,1);
    if n==1||n==2||n==3
        ksm=1;
    else 
        n=n-3;
```
while n>0
```cpp
            if mod(n,2)==1
                ini=mod(mat,1000000007)*ini;
            end
                n=floor(n/2);
                mat=mod(mat,1000000007)*mat;
        end
        ksm=ini(1,1);
    end
end
```
然后利用MATLAB自带的工具箱，生成C代码，再略加处理，即可完成。这是信息竞赛之外的内容了，但大家可以参考，毕竟也是一个解决问题的途径，在以后的科研中也会用到。

---

## 作者：Great_Influence (赞：0)

根据题目描述可推出a[0]=0，因此可列出初始矩阵：

# 0
# 1
# 1
# 1
在根据给出的转移方程a[i]=a[i-3]+a[i-1]可列出转移矩阵:

# 0 1 0 0

# 0 0 1 0

# 0 0 0 1

# 0 1 0 1

可以证明，初始矩阵乘以转移矩阵的(k-3)次方可以得到的新矩阵的各项依次为

# a[k-3]

# a[k-2]

# a[k-1]

# a[k]
而矩阵乘法满足结合律，即A\*B\*B=A\*(B\*B)[A、B皆为矩阵]，因此可以先将转移矩阵先进行幂计算后在与初始矩阵相乘。

而幂计算可以加速的原理是：

# A^(2n)=(A^n)^2(n∈N\*)

和
# A^(2n+1)=A\*(A^n)^2

理解后就不难了。顺便说一下，要特判a[1]~a[3]。

代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
const long long P=1000000007;
long long a[5][5],sum[5][5],k;
int T,flag;
void mul(long long x[][5],long long y[][5])//矩阵乘法，搬得快速幂的标程
{
    long long c[5][5]={0};
    int i,j,k;
    for(i=1;i<=4;i++)
        for(j=1;j<=4;j++)
            for(k=1;k<=4;k++)c[i][j]=(c[i][j]+x[i][k]*y[k][j])%P;
    for(i=1;i<=4;i++)
        for(j=1;j<=4;j++)x[i][j]=c[i][j];
}
int main()
{
    int i,j;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&k);
        if(k<=3)//特判
        {
            printf("1\n");
            continue;
        }
        k-=3;//注意乘方的次数要-3
        memset(a,0,sizeof(a));//注意每次重置转移矩阵
        a[1][2]=a[2][3]=a[3][4]=a[4][2]=a[4][4]=1;
        flag=false;
        while(k)//快速幂
        {
            if(k%2)
            {
                if(!flag)//其实可以去掉这步，只要将sum斜对角线初始化为1就可以省去了，只不过这样更直观
                {
                    for(i=1;i<=4;i++)
                        for(j=1;j<=4;j++)sum[i][j]=a[i][j];
                    flag++;
                }
                else mul(sum,a);
            }
            k>>=1;
            if(k)mul(a,a);
        }
        long long s=((sum[4][2]+sum[4][3])%P+sum[4][4])%P;//可以注意到初始矩阵只有后3个数为1，所以只需要将转移矩阵每行后三个数相加即可求得目标矩阵。更进一步，我们需要的只是a[n],所以完全可以省去a[n-3]~a[n-1]的计算，只要考虑最后一行。
        cout<<s<<endl;
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

###我看没有p党发题解，就来发一个吧


```cpp
**type zyn=array[1..3,1..3]of longint;
var i,j,k,n,m:longint;a,b,t:zyn;
function mul(a,b:zyn):zyn;//矩阵乘法
var i,j,k:longint;c:zyn;
begin
  fillchar(c,sizeof(c),0);
  for i:=1 to 3 do
    for j:=1 to 3 do
      for k:=1 to 3 do
        c[i,j]:=(a[i,k]*b[k,j]+c[i,j])mod 1000000007;
  exit(c);
end;
function power(x:longint):zyn;//快速幂
var t:zyn;
begin
  if x=1 then exit(b);
  t:=power(x div 2);
  t:=mul(t,t);
  if odd(x) then t:=mul(t,b);
  exit(t)
end;
begin
  fillchar(a,sizeof(a),0);fillchar(b,sizeof(b),0);
  a[1,1]:=1;a[1,2]:=1;a[1,3]:=1;b[1,3]:=1;b[2,1]:=1;b[3,2]:=1;b[3,3]:=1;
  readln(n);
  for i:=1 to n do
    begin
      readln(m);  if m<=3 then begin writeln(1);continue;end;
      t:=power(m-3);
      t:=mul(a,t);
      writeln(t[1,3]);
    end;
end.
**
```

---


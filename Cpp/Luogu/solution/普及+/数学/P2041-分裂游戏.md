# 分裂游戏

## 题目描述

有一个无限大的棋盘，棋盘左下角有一个大小为 $n$ 的阶梯形区域，其中最左下角的那个格子里有一枚棋子。你每次可以把一枚棋子“分裂”成两枚棋子，分别放在原位置的上边一格和右边一格。（但如果目标位置已有棋子，则不能这样做）你的目的是通过有限次的操作，让整个阶梯里不再有任何棋子。下图所示的是 $n = 2$ 时的一种解法。

![](https://cdn.luogu.com.cn/upload/pic/1116.png) 

我们用从下往上数的方式标记行，从左往右数的方式标记列，以 (行,列) 来标记棋子，并且都从 $1$ 开始。

例如，第三步中的三个棋子坐标分别为 $(3,1),(2,2),(1,2)$。

现在已知 $n$，你需要做的是给出合适的操作序列。


## 说明/提示

- 对于 $40\%$ 的数据：$n \leq 8$；
- 对于 $100\%$ 的数据：$n \leq 1000$。

## 样例 #1

### 输入

```
1```

### 输出

```
1
1 1```

## 样例 #2

### 输入

```
2```

### 输出

```
4
1 1
2 1
2 2
1 2```

# 题解

## 作者：任弈凡 (赞：24)

我们先给出结论：
1. 当$n=1$时，显然，我们只需$1$步，移动$(1,1)$即可
2. 当$n=2$时，题目已经给了我们答案
3. 当$n=3$时,此题无解


------------


## 然而，这是为什么呢？

 - 假设我们的原数为$1$,不难发现，每一次分裂即是一次将原数变成一个原数的$\frac{1}{2}$

我们来画一个图：


| 1 | $\frac{1}{2}$ |$\frac{1}{4}$  | $\frac{1}{8}$ | ······ |  |  |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $\frac{1}{2}$ |  $\frac{1}{4}$| $\frac{1}{8}$ |  |  |  |  |  |  |  |
| $\frac{1}{4}$ | $\frac{1}{8}$ |  |  |  |  |  |  |  |  |
| $\frac{1}{8}$ |  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |  |

~~额，好像表格出不来~~


我们容易发现，第一行这无限个数的和应是$1+\frac{1}{2}+\frac{1}{4}+······$这些数的和无限接近于$2$,在数学上，我们默认为$2$~~(我已经找到了一种绝佳的证明方法，可惜空间太短，写不下)!~~

同理,第$2$行的和即是$1$,第三行为$\frac{1}{2}$,第四行为$\frac{1}{4}······$

所以,这无限个数之和为$4$

而我们已知我们无限分类的和应为$1$

所以，当$n=4$,$ans=1+\frac{1}{2}*2+\frac{1}{4}*3+\frac{1}{8}*4=\frac{13}{4}$,所以剩下的和为$4-\frac{13}{4}=\frac{3}{4}<1$所以$n>4$无解

那么，当$n=3$时，依照我们的方法,结果应是$\frac{5}{4}>1$所以可以，但是，我们发现,第一行和第一列最多只能有一个数$($在第一列时，每一个操作都只会在上和右增加数，而第一列数$/$第一行最多只能由第一个数得到$)$,所以$n=3$时,的最大值为$\frac{5}{4}-\frac{1}{8}* 2=1$，然而，在有限的操作中，我们不可能使我们填满所有的格子，所以我们的$ans$会严格$<1$

综上，结论成立

代码(刚刚都解释过了) ：
```cpp
#include<iostream>
using namespace std;
int n;
int main() {
	cin>>n;
	if(n==1) {
		cout<<1<<endl;
		cout<<1<<" "<<1<<endl;
	}
	else if(n==2) {
		cout<<4<<endl;
		cout<<1<<" "<<1<<endl;
		cout<<2<<" "<<1<<endl;
		cout<<2<<" "<<2<<endl;
		cout<<1<<" "<<2<<endl;
	}
	else cout<<-1;
}
```

---

## 作者：Bezime (赞：14)

## 前言

拿到这题，嗯？

输出方法步骤，为什么没有 Special Judge ?

## 方法

首先，大家一般都想想推 $n=3$ 时的方法，但是推了好多步也没推出来。

我整理了一下，给大家康康我的图。

1. 2级阶梯的肯定要移出，我们先移成样例的样子(不同的棋子我用了不同的颜色，好区分）：

![步骤1](https://cdn.luogu.com.cn/upload/image_hosting/1ylj5lfi.png)

2. 我们先想办法把红球移出，得先移走绿球：

![步骤2](https://cdn.luogu.com.cn/upload/image_hosting/drfuztx8.png)

3. 再移走红球：

![步骤3](https://cdn.luogu.com.cn/upload/image_hosting/4gxfqi3w.png)

4. 我们再想办法把黄球移出，得先移走蓝球，要把蓝球移出，得先移走绿球（同理）：

![步骤4](https://cdn.luogu.com.cn/upload/image_hosting/68nzd7g4.png)

方便起见，重新染色：

![步骤4](https://cdn.luogu.com.cn/upload/image_hosting/e9jy06nf.png)

5. 我们只需要移走橙球就行了,但要先移走黄球，要移黄球，又要先移走蓝球和绿球。我们先尝试移走绿球：

![步骤5](https://cdn.luogu.com.cn/upload/image_hosting/tdobzf5g.png)

6. 再移走蓝球和右侧的绿球：

![步骤6](https://cdn.luogu.com.cn/upload/image_hosting/gnoclh0z.png)

方便起见，再重新染色：

![步骤6](https://cdn.luogu.com.cn/upload/image_hosting/adn3p99y.png)

我们发现它右上那一部分与步骤4**相同**，橙球都是必须要移走的，这是在套娃！

我们想要移走橙球，就会产生一样的橙球，无限套娃，橙球永远移不走。

我们的像泰山一般的橙球使大小为 $3$ 的阶梯无解，同样的，大于 $3$ 的阶梯也就无解了。

于是，我们便可以直接输出样例，大于等于 $3$ 的输出 $-1$。（所以不需要 Special Judge）

代码就不用贴了，对吧。

制图不易，希望大家支持。orz

---

## 作者：高冷 (赞：14)

这么神奇的题目怎么能没有题解呐！！！！！！！！！！！！！！！！！！！！！！！


首先，我们来画一个n=3的梯形。。。


（图被吃了）


然后按着题目的要求来操作一下。。。嗯。。。很好。。。What？？


（经过本人10+的尝试，是画不出来的）


于是我们猜想：会不会当 n>=3 时,该题无解呢？？


让我们来证明一下


（没有耐心的童鞋可以不要看了）


我们可以设开始时棋子值为一，那么一次分裂后每颗棋子的的值为1/2，如果按照此，不论分裂几次，所有棋子总值为1。


然后证明真的开始了


首先，当n=3 的时候，所有空白区域的数字之和为4–1–(1/2)×2–(1/4)×3=5/4>1 ，这么看上去，把所有棋子都移到空白区域似乎是有可能的。然而注意到，不管怎么操作，第一行都只有一枚棋子，第一列也只能有一枚棋子。考虑到这一点，空白区域里的数字之和似乎就又不够了。为了让棋局所对应的数值尽可能地大，最理想的情况便是，第一行的那个棋子正好位于标有 1/8 的格子里，第一列的那个棋子也位于标有 1/8 的格子里，此时第一行和第一列的其他格子都不能再有棋子了，因而我们还得从 5/4 当中减去两个(1/16+1/32+……)，结果等于5/4–(1/8)×2=1。另外，有限次操作不可能让棋子占满中间那片无限大的空白区域，因而棋局可以达到的数字之和严格地小于1。如果第一行的那个棋子更靠右，或者第一列的那个棋子更靠上，棋局可以达到的数字之和还会更小。因此，当n=3时，游戏是保证无解的。


理解了这方法，想必当n=4时也可推出来了，于是，这题就成了一个**大坑**！！！！


程序的话。。。。想必看到这难度标签会留下的人都没有问题的。


---

## 作者：Methylene_Blue (赞：4)

## emmmmmm
## 神坑！！！
首先题意很好理解，就是裂棋子，而1，2都能解出来，那我们试试能不能裂3
### 于是我就excel模拟了半小时.......
### 如果大家模拟一下就就能看出来，其实2的开始情况就是1的结束情况，然后步数也继承1的，然后试试模拟3。
|  |  |1  |  |
| -----------: | -----------: | -----------: | -----------: |
|  | 1| 1 |  |
| 1 | 1 |  |  |
|  |  |  |  |
这是起始情况

|  |  | 1 |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: |
|  |  | 1 | 1 |  |
| 1 | 1 | 1 |1  |  |
|  | 1 | 1 |  |  |
|  |  |  |  |  |
然后很简单的来到了这一步
#### 其实从这一步就可以发现端倪了,(4,2)(3,3)(2,4)(4,3)(3,4)先行后列，构成了一个3图形，然而我们下一步要做的，就是把他移开，既然原来的都没移开移到一半又变成了自己(很像递归)，那怎么可能再移开呢，如果不理解那我们可以继续模拟

#### (以下坐标都是先行后列，像二维数组一样)
首先(1,3)和(3,1)对称，也就是说只要移开一个就行了，我们随便动一个，比如(1,3)

(1,3)想裂，那必须有两个空位，所以得让(2,3)裂开，(2,3)要裂开，那就继续清除旁边障碍，于是有了下面这个图

|  |  | 1 |  |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  |  | 1 | 1 |  |  |
| 1 | 1 | 1 |  | 1 |  |
|  | 1 |  | 1 | 1 |  |
|  |  |  | 1 | 1 |  |
|  |  |  |  |  |  |


|  |  | 1 |  |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  |  | 1 | 1 |  |  |
| 1 | 1 |  | 1 | 1 |  |
|  | 1 | 1 | 1 | 1 |  |
|  |  |  | 1 | 1 |  |
|  |  |  |  |  |  |

至此完成一个空位了

再来
现在要动(2,4),有一个空位，那就动(3,4),既然要动(3,4)......(分析过程就是推我们应该动哪个棋子)
以下图片一次动两个点

(5,5)(4,5)

|  |  | 1 |  |  |  |  |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  |  | 1 | 1 |  |  |  |  |  |
| 1 | 1 |  | 1 | 1 |  |  |  |  |
|  | 1 | 1 | 1 |  | 1 |  |  |  |
|  |  |  | 1 | 1 | 1 |  |  |  |
|  |  |  |  | 1 |  |  |  |  |
|  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |

(3,5)

|  |  | 1 |  |  |  |  |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  |  | 1 | 1 |  |  |  |  |  |
| 1 | 1 |  | 1 |  | 1 |  |  |  |
|  | 1 | 1 | 1 | 1 | 1 |  |  |  |
|  |  |  | 1 | 1 | 1 |  |  |  |
|  |  |  |  | 1 |  |  |  |  |
|  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |

此时如果(4,4)被裂开，那就大功告成了，裂(4,4)要裂开(5,4)(4,5)
如果尝试(5,4),那基本上是无从下手，如果是(4,5),则会陷入一个死循环，不信可以自己excel一下，为了给一个棋子开道，你得一直循环往前延伸......

### 至此也就可以得出一个结论就是这个东西不可解了，虽然没有严格证明，但是考场上面足够了，毕竟如果继续dfs或者bfs下去，棋盘无限大，那百分百爆，如果是高端搜索技巧的话(比如迭代加深，IDA*)，肯定不如模拟来的块呗
### 如果是考场上遇到，请不要慌张，良好的心态是做这类看起来可以但是怎么试都不行的题目的一大保障
# ↖(^ω^)↗加油！

---

## 作者：_Camille_ (赞：4)

### 前言

考验思维难度的题，还是挺有意思的。

### 题目分析

第一眼看数据范围便知道这题不简单，DFS与BFS做在 $1000$ 的范围内必定炸、

然后考虑规律。

当 $n=1$ 与 $n=2$ 的情况样例已经有给出，下面我们借助当 $n=3$ 时的情况来推导一下。

下面请自行观赏下面的每一步推导。

![](https://cdn.luogu.com.cn/upload/image_hosting/h7uc900b.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/brx48op5.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/0w4xuimh.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/hnwft0qp.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5qql9ic7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/h7uc900b.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ik1pw6bd.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/3c1pmdqi.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/pn5dft4m.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/mrrv74a3.png)

到此我们已经可以发现我们很难继续模拟了。我们发现要为一个棋子开道，其他子又会成为下一个等着被开道的子，就像递归。

到此我们开始思考规律，并先猜想：$n>=3$ 时无解、

我们把 $(1,2)$ 与 $(2,1)$ 中的数标为 $1/2$ ，把 $(1,3)$ 和 $(2,2)$ 和 $(3,1)$ 标为 $1/4$ ，以此类推。

剩余的空格去减标号的总和，如果用 $4$ 减出来的值小于 $1$ ，那么就无解。

我们容易发现，第一行这无限个数的和应是 $1+1/2+1/4+......$

这些数的和无限接近于 $2$ 。运用极限的思想我们把它看成 $2$ 。

同理，第 $2$ 行的和即是 $1$ ，第 $3$ 行为 $1/2$ ，以此类推。

所以，这无限个数之和为 $4$ 。

而我们已知无限分类的和应为 $1$ 。

当 $n=3$ 时，$sum=1+1/2*2+1/4*3=11/4$，$4-11/4>=1$，但与我们的猜想不符，我们接着继续分析。

但是，我们发现，第一行和第一列最多只能有一个数,所以此时的最大值为 $5/4-1/8*2=1$ ，但在**有限**的操作中，我们不可能填满所有的格子，所以结果会小于 $1$ 。与猜想相符合。 

当 $n=4$ 时，$sum=1+1/2*2+1/4*3+1/8*4=13/4$ ，$4-13/4=3/4<1$ ，与猜想相符合。 

随着 $n$ 的增大，数值会越来越小，因此不可能违反我们的猜想。

到此我们验证了我们猜想成立。

然后只用特判样例中的 $n=1$ 与 $n=2$ 的情况，其它全部输出 $-1$ 即可。

代码不贴了，认真看到最后的读者应该会非常轻松打出代码。

如果还有什么不懂可以私信问我。

管理员审核辛苦了！


---

## 作者：VioletIsMyLove (赞：3)

![](https://cdn.luogu.com.cn/upload/image_hosting/mbh2m0a4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

通过上表分析，这个表格所有数值的和$≈4$。

所以，当 $N=4,ans=1+\frac 12*2+\frac 14*3+\frac 18*4=\frac {13} 4$；所以剩下的和为 $4 -\frac {13} 4=\frac 34<1$ 所以 $N≥4$ 无解

那么，当 $N=3$ 时，依照我们的方法,结果应是$\frac 45>1$

理论上来说可以。

但是，我们发现,第一
行和第一列最多只能有一个数(在第一列时，每一个操作都只会在上和右增加数，找到空位
就会停下，所以第一行和第一列各留下$\frac 18$)。

所以 $N=3$ 时剩下的和为 $\frac 45-\frac 81*2=1$

感觉好像一
点问题都木有啊 [难受]

然而，在有限的操作中，不可能使我们填满所有的格子，所以我们的
$ans$ 会严格 $<1$；
综上所述，$N≥3$ 无解。。。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
    scanf("%d",&n);
    if (n==1) printf("1\n1 1\n");else
	if (n==2) printf("4\n1 1\n2 1\n2 2\n1 2\n");else
	printf("-1\n");
    return 0;
}
```
蒟蒻的第4篇题解，求过。。。洛谷图床有点坑，这图也忒小了吧。。。

---

## 作者：米奇奇米 (赞：3)

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{ int n;
  cin>>n;
  if ((n<1)||(n>=3)) cout<<-1;
  if(n==1) {cout<<1<<endl;
           cout<<1<<" "<<1;}
  if(n==2) {cout<<4<<endl;
           cout<<1<<" "<<1<<endl;
           cout<<2<<" "<<1<<endl;
           cout<<2<<" "<<2<<endl;
           cout<<1<<" "<<2;}
return 0;
}

    这道题目3是一个特殊情况，我们可以把（1,1）标号为1 
    把（1,2）和（2,1）标号为1/2，把（1,3）和（3.1和（2,2）标为1/4，以此类推...
    剩余的空格去减标号的总和，如果用4减出来的值<1,那么就无解：
   （比如：当n=4时，分别把标了1,1/2,1/4,1/8用4去减发现，4-1-2*1/2-3*1/4-4*1/8=1/6<1，所以无解）
     进过计算1,2是有解，就按题意输出即可。
```

---

## 作者：垣根帝督 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P2041)

这一题一眼看上去是非常的高级 ， 但事实却是截然相反的

首先理解题目的意思 ，假设我们的原数为 1 ,不难发现 ，每一次分裂即是将原数变成原数的 $\frac{1}{2}$ 

所以可以列出下图 : 


  |  |  |  |  |  |  |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
| ... |  |  |  |  |  |  |
| $\frac{1}{16}$ | ... |  |  |  |  |  |
| $\frac{1}{8}$ | $\frac{1}{16}$ | ... |  |  |  |  |
| $\frac{1}{4}$ | $\frac{1}{8}$ | $\frac{1}{16}$ | ... |  |  |  |
| $\frac{1}{2}$ | $\frac{1}{4}$ | $\frac{1}{8}$ | $\frac{1}{16}$ | ... |  |  |
| $1$ | $\frac{1}{2}$ | $\frac{1}{4}$ | $\frac{1}{8}$ | $\frac{1}{16}$ | ... |  |


那么我们就可以计算出每一行的数值之和 ，如下图 ：


|  |  |  |  |  |  |  |  |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
|  | ... |  |  |  |  |  |  |
| ... | $\frac{1}{16}$ | ... |  |  |  |  |  |
| ${S_4}=\frac{\frac{1}{8}(1-\lim \limits_{n \to \infty}(\frac{1}{2})^n)}{1-\frac{1}{2}}≈\frac{1}{4}$ | $\frac{1}{8}$ | $\frac{1}{16}$ | ... |  |  |  |  |
| ${S_3}=\frac{\frac{1}{4}(1-\lim \limits_{n \to \infty}(\frac{1}{2})^n)}{1-\frac{1}{2}}≈\frac{1}{2}$ | $\frac{1}{4}$ | $\frac{1}{8}$ | $\frac{1}{16}$ | ... |  |  |  |
| ${S_2}=\frac{\frac{1}{2}(1-\lim \limits_{n \to \infty}(\frac{1}{2})^n)}{1-\frac{1}{2}}≈1$ | $\frac{1}{2}$ | $\frac{1}{4}$ | $\frac{1}{8}$ | $\frac{1}{16}$ | ... |  |  |
| ${S_1}=\frac{\frac{1}{1}(1-\lim \limits_{n \to \infty}(\frac{1}{2})^n)}{1-\frac{1}{2}}≈2$ | $1$ | $\frac{1}{2}$ | $\frac{1}{4}$ | $\frac{1}{8}$ | $\frac{1}{16}$ | ... |  |

通过上图可知，这个表格所有数值的和 $sum=\lim \limits_{n \to \infty} \sum_{i=1}^{n} {S_i}≈4$ 。


所以，当 $N=4$ , $ans=\frac{13}{4}$ , 所以剩下的和为 $4-\frac{13}{4}=\frac{3}{4}<1$ , 所以 $N≥4$ 无解

那么，当 $N=3$ 时 ，我们发现,第一行和第一列最多只能有一个数 ( 在第一列时，每一个操作都只会向上和向右扩展，一旦有空的位子就会停止继续扩展，所以第一行和第一列各留下 $\frac{1}{8}$ ) , 所以 $N=3$ 时剩下的和 $sum=1$ , 然而 ，在有限的操作中 ，不可能使我们填满所有的格子，所以我们的 ans 会无限趋近与 1 并且严格 $<1$ 。

所以综上所述 ， $N≥3$ 无解 。

所以结论 ： 如果和样例一样，输出样例；否则输出 -1 

是否有某些大佬和我一样骗了个分就不小心 A 了呢 /xyx

最后上代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main(){
	cin>>n;
	if(n==1)printf("1\n1 1\n");
	else if(n==2)printf("4\n1 1\n2 1\n2 2\n1 2\n");
	else printf("-1\n");
	return 0;
}
```

蒟蒻打公式不易 ，求过 。


---

## 作者：WZKQWQ (赞：1)

### 建议此题标签加入[打表][手推] (滑稽)

进入正文，首先我为了理解题目画了 $n = 3$ 的图，

结果发现无解，然后试了 $3，4，5，6$ 全都无解，

思路瞬间清晰。

$n = 3$ 手推过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/d8i04tst.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/lbxdesz5.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ja952dfg.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/yphqoe7i.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/bfmqlwv4.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/g0ifwkm9.png)

到这应该看出无解了吧，然后代码就很清晰。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d",&n);
	if(n == 1) printf("1\n1 1");
	else if(n == 2) printf("4\n1 1\n2 1\n2 2\n1 2");
	else printf("-1");
	return 0;
}
```


---

## 作者：—维尼— (赞：1)

## 题目大意
给定一个棋子和边长为n的阶梯，每次操作可以把棋子分裂成上面一个和右边一个，目标是将棋子移除棋盘，问操作次数和每次操作原棋子的位置
无解输出-1
## 题目思路
我们先从小数据开始分析：
* $n=1$时操作一次即可

* $n=2$时

![](https://img-blog.csdnimg.cn/img_convert/0a00ccd353109957cdd530c317f169ff.png)

操作四次即可，最后的五个点标起来了


* $n=3$时

![](https://img-blog.csdnimg.cn/img_convert/0dae0a117db7b6b1068466a2759fa4b4.png)

（此例子优先向上分裂）此时我们可以发现，前一个点总是会挡住下一个点分裂，如果此时再次分裂为前一个点开路，让右边的点过去，开路生成的右点又会堵住已经过去的点的上面位置，于是无法跑出$n=3$的阶梯

* $n>3$因为跑不出$3$，所以大于$3$的情况也是无解喽
## 代码如下
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	if(n==1){
		cout<<1<<endl;
		cout<<1<<" "<<1<<endl;
	}
	else if(n==2){
		cout<<4<<endl;
		cout<<1<<" "<<1<<endl;
		cout<<2<<" "<<1<<endl;
		cout<<2<<" "<<2<<endl;
		cout<<1<<" "<<2<<endl;
	}
	else{
		cout<<-1<<endl;
	}
	return 0;
}





---


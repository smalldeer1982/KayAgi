# 最小和

## 题目背景

RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。所以今天只有短的RSA钥匙才可能被强力方式解破。


## 题目描述

已知 $a$，$b$ 是正整数且 $a \leq b$。

求满足条件且 $x+y$ 的值最小的 $x$，$y$。

条件：

- $\gcd(x,y) = a$
- $\mathrm{lcm}(x,y) = b$
- $x \leq y$


## 说明/提示

$3 \leq a, b < 2^{63}$。

EOF 结束，没有代表行数的 $n$，第一行就是数据。

数据随机生成。


## 样例 #1

### 输入

```
3 60```

### 输出

```
12 15```

## 样例 #2

### 输入

```
200 20000
300 30000
400 40000```

### 输出

```
800 5000
1200 7500
1600 10000```

# 题解

## 作者：decoqwq (赞：12)

题意：给定$x=lcm(a,b),y=gcd(a,b)$，求$a+b$最小时$a,b$的值

因为$xy=gcd(x,y)\times lcm(x,y)$，我们先将$lcm(a,b),a,b$都除以$gcd(a,b)$

问题就转化为了$ab=x,gcd(a,b)=1$

因为$a+b$最小$ab$一定，所以$(a+b)^2$最小的话，$(a+b)^2-4ab$即$(a-b)^2$就最小

所以$a,b$要尽量靠近$\sqrt{lcm(a,b)}$

因为是$longlong$范围内，所以我们用$Pollard\ Rho$对其进行分解，然后再折半搜索组合答案就可以了

不给代码啦



---

## 作者：Flandre_495 (赞：8)

~~真是个无人区啊~~~

提交通过数都这么少。。。

但是！_rqy竟然做了这道题！所以我打算尝试一下。。。

#### 首先更正一下楼下的题解。

#### 下面的题解好像有点问题。。。这题统计答案时是不能贪心的，需要用背包。但数据太弱，所以

#### 比如质因数分解后是2 3 5 7，最优的肯定是3,5放一起，2,7放一起，但如果从前往后枚举的话，就只能更新$2*3*5$。

以上是对楼下题解的更正，~~所以对于楼下错误的写法，这篇就是唯一正确的了？~~



 
__________


#### 那我们回到题目：

思路看楼下的题解就行了~，楼下讲的还是很清楚的。

设输入的是a和b。

先把a和b两个数相除，将得到的数c分解。

我们要求一对x,y，使x,y互质，且$x*y=c$。

这样$x*a,y*a$就是我们的答案，满足最大公因数是a，最小公倍数是b（$b =x*y/a$）。

所以我们要将c的质因数分给x和y，但每个质因数只能属于x或y，如果x，y出现了相同的质因数，那么他们就不会互质。

所以我们现在的任务是将质因数分给x和y，并使x+y最小，我们已知$x*y=c$，所以x与y的差越小越好，~~初中知识。。~~

我们开一个背包，使x能越接近$\sqrt{c}$就越好。

那么最后输出x和y与a的乘积就行。


详见代码：

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define QWQ cout<<"QwQ"<<endl;
#define ll long long 
#include<vector>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const ll N=101010;
const ll qwq=202020;
const ll inf=0x3f3f3f3f3f3f3f3f;
ll a,b,c;
ll x, y;
ll pre[N], cnt;
vector <int> ans;

int main() {
	while(cin>>a>>b) {
		cnt = 0; ans.clear();
		if(a==0||b==0) {
			printf("0 0\n");
			continue;
		}
		c = b / a;
		ll c1 = c;
		for(ll i=2;i<=c1;i++) {
			if(c1%i==0) pre[++cnt] = 1;
			while(c1%i==0) {
				pre[cnt] *= i;
				c1 /= i;
			}
		}
		ans.push_back(1);
		for(int i=1;i<=cnt;i++) {
			int len = ans.size();
			for(int j=0;j<len;j++) {
				if(ans[j]*pre[i] > sqrt(c)) continue;
				ans.push_back( ans[j]*pre[i] );
			}
		}
		sort(ans.begin(),ans.end());
		x = ans[ans.size()-1];
		y = c / x;
		cout<<x*a<<" "<<y*a<<endl;
	}
	return 0;
}


```

最后注意这个~~沙雕~~的细节：a，b均为0时x，y也是0。

---

## 作者：critnos (赞：3)

分析一下：

* $a=\gcd(x,y)$

* $b=\text{lcm}[x,y]$

设： $A=\dfrac x a,B=\dfrac y a$ ，那么：

* $A \times B \times a=b$

* $\gcd(A,B)=1$

题目要求 $x+y$ 最小，那就是求 $A \times a+B \times a$ 最小，可以转化为求 $a \times (A+B)$ 最小。因为 $a$ 是定值，所以变成了求 $A+B$ 最小。

而 $A \times B \times a=b$ ，所以 $A \times B = \dfrac b a$ 。

而问题就转化为了，已知 $A \times B$ ，求 $A+B$ 的最小值，且 $A,B$ 互质。

如果用枚举， $\sqrt n \times \log n$ 的时间复杂度铁定超时（为啥带了 $\log$ ？因为还要求互质，所以还要求一次 $\gcd$ ）。

那么……

说句闲话：解决数论问题的最好方法是——

**质因数分解！**

我们设 $c=\dfrac b a$ ，然后对 $c$ 分解质因数：

 $c=\prod_{i=1}^n p_i^{s_i}$ 

然后把质因数分成两部分，每一部分的积就是 $A $和 $B$ 。

用 dfs 枚举这两部分。实际上，枚举一部分就行了。

那这样有什么好处呢？

对于一个数 $n$ ，它的质因数个数是 $\log n$ 级的，而 dfs 枚举是 $2^n$ 的， $2^{\log_2{n}}=n$ ，比枚举还慢……

而且还要加上判断互质的时间复杂度。

等等……判断互质！

两个数互质，就意味着两个数没有共同的质因数。那么，对于一种质因数，它不可能分为两部分。比如有 $2^3$ ，不可能有“ $A$ 中有 $2^2$ 而 $B$ 中有 $2^1$ ”的情况。

那么我们只用枚举不同的质因数就可以了！

虽然不同的质因数也是 $\log$ 级的，但是已经有了一个巨大的飞跃。

还有分解质因数的时间复杂度。

当然有 $O(n)$ 的，有 $O(\sqrt n)$ 的，也有 $O(n^{\frac 1 4})$ 的（ Pollard-Rho ）。一开始把 Pollard-Rho 的板子改了改，抄上去了，但是错了。那么我们就只能用 $O(\sqrt n)$ 的了。

那不会超时吗？

不会。虽然理论上是 $O(\sqrt n)$ 的，但这是一个比较宽松的上界，实际上可能会比这小。而且请注意题目中的一句话：

>数据随机生成

因为数据随机生成，所以其实 $\dfrac a b$ 并没有到 $2^{63}$ 级别，自然 $O(\sqrt n)$ 也可以过了。

目前排名第三，挺快的。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll zyx[10000],mn,len,kc,xx,yy;
void dfs(ll d,ll s)
{
	if(s>kc/s) return;
    if(d==len)
    {
        if(s+kc/s<mn)
        {
            mn=s+kc/s;
            xx=s;
            yy=kc/s;
        }
        return;
    }
    dfs(d+1,s);
    dfs(d+1,s*zyx[d]);
}
int main()
{
    ll p,n,i,j,s,ka,kb;
    while(cin>>ka>>kb)
    {
        if(kb+ka==0) 
        {
            cout<<0<<' '<<0<<endl;
            continue;   
        }
        kc=kb/ka;
        for(len=0,i=2,p=kc;i*i<=p;i++)
        {
            if(p%i==0)
            {
                zyx[len]=1;
                while(p%i==0)
                {
                    p/=i;
                    zyx[len]*=i;
                }
                len++;
            }
        }
        if(p>1) zyx[len++]=p;
        mn=kc+2;
        dfs(0,1);
        cout<<xx*ka<<' '<<yy*ka<<endl;  
    }
} 
```

UPD ，2020.3.6：因为数据有误，第四个点有$a$和$b$均为$0$的情况，不符合题目要求，请尽快修正。在没有修正数据之前，请特判$a$和$b$均为$0$的情况答案为$0$ $0$。

UPD ，2020.3.17：修了一下丑陋的 MD 。

还有， PR 今天终于调过了，这里再放上代码吧：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
map<ll,int> a;
ll zyx[1000],mn,len,kc,xx,yy;
inline ll ksm(ll x,ll p,ll md)
{
    ll ans=1;
    while(p)
    {
        if(p&1) ans=(__int128)ans*x%md;
        x=(__int128)x*x%md;
        p>>=1;
    }
    return ans;
}
inline ll ksmn(ll x,ll p)
{
    ll ans=1;
    while(p)
    {
        if(p&1) ans=ans*x;
        x=x*x;
        p>>=1;
    }
    return ans;
}
inline bool test(ll n,ll a,ll d)
{
	if(n==2||n==a) return 1;
	while(!(d&1)) d>>=1;
	ll t=ksm(a,d,n);
	while(d!=n-1&&t!=1&&t!=n-1)
	{
		t=(__int128)t*t%n;
		d<<=1;
	}
	return t==n-1||d&1==1;
}
inline bool MR(ll n)
{
	if(n==2||n==3) return 1;
	if(n==1||n%6!=1&&n%6!=5) return 0;
	if(!test(n,11,n-1)||!test(n,61,n-1))
		return 0;
	return 1;
}
inline ll f(ll x,ll t,ll n)
{
	return ((__int128)x*x+t)%n;
}
inline ll fj(ll x)
{
	ll l,r,t,s;
	for(;;)
	{
		t=rand()%(x-1)+1;
		l=f(0,t,x);
		r=f(l,t,x);
		while(l!=r)
		{
			s=__gcd(abs(l-r),x);
			if(s>1&&s<x) return s;
			l=f(l,t,x);
			r=f(f(r,t,x),t,x);
		}
	}
}
inline void PR(ll x,ll c)
{
	if(x==4)
	{
		a[2]+=c*2;
		return;
	}
	if(x==1) return;
	if(MR(x)) 
	{
		a[x]+=c;
		return; 
	}
	ll qwq=fj(x),s=0;
	while(x%qwq==0) 
		x/=qwq,s++;
	PR(qwq,c*s),PR(x,c);
} 
void dfs(ll d,ll s)
{
	if(d==len)
	{
		if(s+kc/s<mn)
		{
			mn=s+kc/s;
			xx=min(s,kc/s);
			yy=max(s,kc/s);
		}
		return;
	}
	dfs(d+1,s);
	dfs(d+1,s*zyx[d]);
}
int main()
{
	srand(time(0));
	ll p,n,i,j,s,ka,kb;
	map<ll,int>::iterator it;
	while(cin>>ka>>kb)
	{
		a.clear();
		kc=kb/ka;
		PR(kc,1);
		for(len=0,it=a.begin();it!=a.end();it++,len++)
			zyx[len]=ksmn(it->first,it->second);
		mn=kc+2;
		dfs(0,1);
		printf("%lld %lld\n",xx*ka,yy*ka);	
	}
} 
```


---

## 作者：__cheems__ (赞：3)

# 题意

给定两个数 $x,y$ 的最大公因数 $a$ 与最小公倍数 $b$，求当两数之差最小时 $x,y$ 的值 $(x \le y)$。

# 思路

$x,y$ 均为 $a$ 的倍数。此时不妨设 $\left\{\begin{matrix}
x=a\times n
 \\
y=a\times m
\end{matrix}\right.$

根据 $x,y$ 最大公因数为 $a$，若 $n,m$ 还有公因数 $p$，则最大公因数为 $a \times p$，$a\times p=a$，得出  $p=1$，即 $n,m$ 互质。此时根据前面的条件，梳理可得: $n\times a$ 与 $m\times a$ 最小公倍数为 $b$。再进一步可得 $n,m$ 的最小公倍数为 $b\div a$。

设 $t=b \div a$。$n,m$ 互质，最小公倍数为 $t$，分解质因数后得 $t={{p_1} ^{f_1}}\times {{p_2} ^{f_2}}\times{{p_3} ^{f_3}}\cdots{{p_{q}} ^{f_q}}$，$n={{p_1} ^{g_1}}\times {{p_2} ^{g_2}}\times{{p_3} ^{g_3}}\cdots{{p_{q}} ^{g_q}}$，$m={{p_1} ^{h_1}}\times {{p_2} ^{h_2}}\times{{p_3} ^{h_3}}\cdots{{p_{q}} ^{h_q}}$。

得 $\max(g_1,h_1)=f_1$，$\max(g_2,h_2)=f_2$，$\max(g_3,h_3)=f_3 \cdots \max(g_q,h_q)=f_q$。

$\because  n,m$ 互质。

$\therefore n \times m = t,g_i$ 与 $h_i$ 分别为 $(0,f_i)$ 或 $(f_i,0)$。

此时进行搜索，枚举 $g_1,g_2,g_3 \cdots g_q$ 中的 $g_i$ 为 $0$ 或 $f_i$，得出 $n$ 后求出 $m$，求出差的最小值即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long
int n,m;
int ans;
int cnt;
int p[1000001];
int t[1000001];
void dfs(int step,int x){//搜索
	if(step>cnt&&x>=n/x){
		ans=min(ans,x);
		return;
	}
	if(step>cnt) return;
	dfs(step+1,x);
	dfs(step+1,x*p[step]);
}
signed main(){
	while(cin>>m>>n){
		if(n==0||m==0){ cout<<0<<" "<<0<<endl; continue;}
		cnt=0,ans=0x3f3f3f3f3f3f3f3f;
		memset(p,0,sizeof(p));
		n/=m;
		int t=n;
		for(int i=2;t!=1;i++){//分解质因数
			if(t%i==0){
				cnt++;
				p[cnt]=1;
			}
			while(t%i==0){
				t/=i;
				p[cnt]*=i;
			}
		}
		dfs(1,1);
		cout<<(n/ans)*m<<" "<<ans*m<<endl;
	}
    return 0;
}
```

---

## 作者：sounds_666 (赞：2)

### update：2019.11.4,感谢 [Flandre_495](https://www.luogu.org/space/show?uid=102726)julao指出问题

### update：2020.1.14 用markdown修了一下

[题目传送门](https://www.luogu.org/problem/P2406)

题目大意：给出两个数$a=gcd(x,y),b=lcm(x,y)$，求$x,y$且让$x+y$尽可能的小。

题目bug：$a,b$非正整数而自然数

题目思路：众所周知，$gcd(x,y)*lcm(x,y)=xy$

如果$a=0$且$b=0$那么输出$(0,0)$

否则我们可以令$kk=b/a$，然后在$1$~$kk$中寻找能够被$kk$整除的数，且使它最接近$\sqrt{kk}$

这里其实可以证明，大概过程为，为了使$(a+b)^2$最小，在$ab$(即kk,因为($gcd(a,b)$为$1$)恒不变的情况下，我们可以将$(a+b)^2$转换为$(a-b)^2$（~~学过乘法原理的应该都能过一眼看成来吧~~），此时我们只要是得$(a-b)^2$最小即可，所以是得$\sqrt{lcm(a,b)}$靠近$a,b$

我们不妨令$\sqrt{lcm(a,b)}$为lastt , 求得lastt后根据性质

$gcd(x,y)*lcm(x,y)=xy$

输出，又因为此时（除以a后）的最大公因数，也就是此性质中的x为1，所以输出$lastt * a$ , $kk / lastt * a$即可。

至于怎么去求$lastt$，我之前用的是贪心，既然Flandre_495julao说贪心是不对的，要用背包来求，那么我只好写背包了，具体的话就看代码了吧

贴代码（有注释）：
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
#define ll long long
vector<ll> k,ans;//不确定数组开多大,所以用动态数组vector来存
//开long long
ll max(ll i,ll j){return i>j?i:j;}
int main(){
    long long p,q;
    bool flag=1;
    scanf("%lld%lld",&p,&q);
    while(flag){
        if(p==0||q==0){//一定要特判
            puts("0 0");
            if(scanf("%lld%lld",&p,&q)==-1)flag=0;
            continue;//记得跳过
        }
        ll kk=q/p,ls=kk;
        for(int i=2;i<=ls;i++){//分解质因数，有一定简化
        	ll s=1;
        	bool flag=1;//这个flag用于判断这个数是否有效
        	while(ls%i==0){
        		s*=i;
        		ls/=i;
        		flag=0;
			}
			if(!flag)k.push_back(s);//加入数组
		}
		int lenk=k.size();
		ans.push_back(1);//一定要加入1来凑数
		for(int i=0;i<lenk;i++){//vector下标从零开始
			int len=ans.size();
			for(int j=0;j<len;j++){
            		//这里不能把len改为ans.size()，因为ans的长度一直在改变.
                    //每次求这个值会更新，从而导致不一样，出现玄学错误
				if(k[i]*ans[j]<=sqrt(kk))ans.push_back(k[i]*ans[j]);
                	//超过sqrt(kk)的，一定能在小于sqrt(kk)的范围内找到相对应的数。
                   	//我们只需在最后求的时候处理一下即可。
			}
		}
		ll lastt=-1;
		for(int i=0;i<ans.size();i++){
			lastt=max(ans[i],lastt);
            //求ans数组里最大的值，即找满足条件的lastt
		}
		printf("%lld %lld\n",lastt*p,kk/lastt*p);//按照性质输出
    	k.clear(),ans.clear();//清空数组
        if(scanf("%lld%lld",&p,&q)==-1)flag=0;//scanf输入失败为-1
    }
    return 0;
}
```
本蒟蒻已经尽力了，有不足之处请各位julao指出,也请多多包涵

---

## 作者：hgckythgcfhk (赞：2)

># 数据随机生成。

这句话很重要，我一开始就是没看见这句话导致懒得写 Pollard Rho 才没做，但仔细一想，这是个绿题啊，肯定是我漏了什么东西，于是在最底下不显眼的地方看到了这句话。

这句话说明本质不同的质因子不会太多，也不会有两个太大的质因子，也许这个说法并不准确，我应该加上**大概率**，但仅对于 OI 题来说，我们可以认为小概率事件一定不会发生。

本文重点讨论这个概率，存在质因子 $p$ 的概率是 $\dfrac{\frac{V}{p}}{V}=\dfrac{1}{p}$，存在质因子 $q$ 的概率是 $\dfrac{\frac{V}{q}}{V}=\dfrac{1}{q}$，所以存在质因子 $p$ 和 $q$ 的概率是 $\dfrac{1}{p}\times\dfrac{1}{q}=\dfrac{1}{p\cdot q}$。

定义大质数是指大于 $10^5$ 的质数。

由于要保证两个都是大质数，那么存在两个大质因子的概率就是 $\sum_{10^5}^{10^{9}}\sum_{i}^{\frac{10^{18}}{i}}\dfrac{1}{i\cdot j}$。这里为方便表示省略了 $i,j\in P$ 的条件，但一定记住这里有这个条件。

化简得：

$$\begin{aligned}

\text{设}f(n)=\sum_{i\in P}^{n}\dfrac{1}{i}\\
\text{原式}&=\sum_{10^5}^{10^{9}}(\dfrac{1}{i}\times\sum_{i}^{\frac{10^{18}}{i}}\dfrac{1}{j})\\
&=\sum_{10^5}^{10^{9}}\dfrac{f(\frac{10^{18}}{i})-f(i)}{i}
\end{aligned}$$

我们可以发现这个东西一定和对数有关，所以我们可以估计一下，讨论这个函数的性质，因为质数个数是 $\dfrac{n}{\ln n}$ 级的，$\sum \dfrac{1}{i}$ 是 $\ln n$ 级的，所以我们推测 $f(n)$ 是 $\ln\ln n$ 级的，验证一下，发现这个东西比 $\ln\ln n$ 还小，所以我们完全可以用 $\ln\ln$ 替换 $f$，而且实际的概率会远小于我们算出来的这个东西，根据测试结果，达到 $10^5$ 时，$f$ 要乘上一个大约 $0.18$ 的常数，而且几乎每扩大 $10$ 倍，这个常数减小 $0.01$ 左右且减小的越来越少，所以，$f(\frac{10^{18}}{i})$ 要比 $f(i)$ 乘上更小的常数，保守估计 $10^{13}$ 的时候对应的常数是 $0.12$，可以估计上面这个求和式的第一项大概是 $10^{-7}$ 的数量级，且分子在不断小，分母在不断变大，上面这个式子会越来越小，以至于后面会不断趋近于 $0$，起码说，$i$ 每增长一个数量级式子的值就会减小一个数量级，所以这个结果最多也就是 $10^{-6}$ 的数量级，所以 $10^3$ 次询问的正确率大于 $(1-10^{-6})^{10^3}\approx0.999000499333845715$。事实上，这只是一个远远达不到的下界。

再说本质不同的质因子个数的问题，计算一下时间复杂度，我们可以接受 $14$ 个本质不同的质因子，有 $14$ 个本质不同的质因子最小的数也得 $10^{16}$ 的数量级，最多 $16$ 个就爆了，所以出错率是远小于 $(^{16}_{14})\times 10^{-16}$ 的，这个数并不大，反正小于 $10^{-10}$。

于是我们可以暴力的分解质因数，然后对每个质因子状压，既不会出错，又不会超时，如果你不放心，你可以把质数筛到 $10^6$，但是 $10^5$ 就足够保证能过且运行的很快了。

讲到这里，其实我们就解决完了这个题最核心的问题，那就是随机数据可以暴力分解，剩下的看程序就很容易理解，其他题解也讲得很详细了。

省略了宏定义和头文件，但不影响阅读。
```cpp
using namespace std;constexpr unsigned N=1e5+1;
Bool(v,N);vint p;ull c[40];
signed main(){open;for(int i=3;i<N;i+=2){if(!v[i])p+=i;
		for(cit&j:p)if(i*j>=N)break;else v[i*j]=1;}
	int ll a,b;while(cin>>a>>b){if(!a||!b){cout<<"0\n";continue;}
		b/=a;cle(c);int ll x=b,y=b;int m=0;if(b&1^1)
		c[++m]=b&-b,b/=c[1];for(cit&i:p){if(1ll*i*i>b)break;
			if(b%i==0){c[++m]=1;while(b%i==0)b/=i,c[m]*=i;}}
		if(b>1)c[++m]=b;for(int i=0;i<(1<<m);++i){int ll tx=1,ty=1;
			for(int j=1;j<=m;++j)i&(1<<j-1)?tx*=c[j]:ty*=c[j];
			if(tx<=ty&&tx+ty<x+y)x=tx,y=ty;
		}cout<<x*a<<' '<<y*a<<'\n';
	}
}
```

---

## 作者：Jorisy (赞：1)

显然 $a\mid b$。

不难想到对 $\dfrac ba$ 质因数分解后直接爆搜出答案。

这样理论复杂度最坏是 $O(\sqrt \dfrac ba)$。

注意到数据随机，则期望下会快很多，可以通过。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

int c;
ll x,y,a[5000005],ans;

void dfs(int dep,ll s)
{
	if(dep>c)
	{
		if(s>=y/s) ans=min(ans,s);
		return;
	}
	dfs(dep+1,s);
	dfs(dep+1,s*a[dep]);
}

void sol()
{
	assert(x&&y);
	ans=LLONG_MAX;
	y/=x;
	c=0;
	ll i=2,m=y;
	while(m>1)
	{
		if(m%i)
		{
			i++;
			continue;
		}
		a[++c]=i;
		m/=i;
		while(m%i==0) a[c]*=i,m/=i;
	}
	dfs(1,1);
	printf("%lld %lld\n",y/ans*x,ans*x);
}

int main()
{
	while(cin>>x>>y) sol();
	return 0;
}

```

---

## 作者：Leasier (赞：1)

前置芝士：[Pollard-Rho](https://oi-wiki.org/math/pollard-rho/)

令 $p = \frac{b}{a}$，考虑其质因数 $q$，则 $p$ 与 $\frac{p}{q}$ 互质，此时 $x = aq$，$y = \frac{ap}{q}$。

考虑一个显然的结论：当 $q$ 最接近 $\sqrt{p}$ 时，$x + y$ 取得最小值。

考虑将 $p$ 使用 Pollard-Rho 分解质因数，预处理出 $p$ 中每个质数的幂次，然后 dfs 依次枚举每个质因数幂次选或不选即可。时间复杂度为 $O(n^{\frac{1}{4}} \log n + 2^{\omega(n)})$。

代码：
```cpp
#include <iostream>
#include <algorithm> 
#include <cstdlib>
#include <cmath>
#include <ctime>

using namespace std;

typedef long long ll;
typedef __int128 lll;

const int N = 9, M = (1 << 7) - 1, K = 62 + 7;
int test_prime[N + 7] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23};
ll p[K], p_pow_k[K];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = (lll)ans * x % mod;
		x = (lll)x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline bool miller_rabin(ll n, ll k){
	ll nd = n - 1, m = nd;
	while (m){
		ll x = quick_pow(k, m, n);
		if (x != 1 && x != nd) return false;
		if ((m & 1) == 1 || x == nd) return true;
		m >>= 1;
	}
	return true;
}

inline bool is_prime(ll n){
	if (n < 2) return false;
	for (register int i = 1; i <= N; i++){
		if (n == test_prime[i]) return true;
		if (!miller_rabin(n, test_prime[i])) return false;
	}
	return true;
}

inline ll floyd(ll a, ll b, ll p){
	return ((lll)a * a % p + b) % p;
}

ll gcd(ll a, ll b){
	return b == 0 ? a : gcd(b, a % b);
}

inline ll pollard_pho(ll n){
	ll x = 0, c = rand() % (n - 1) + 1;
	for (register int i = 1; ; i <<= 1){
		ll y = 1, z = x, ans;
		for (register int j = 1; j <= i; j++){
			x = floyd(x, c, n);
			y = (lll)y * abs(x - z) % n;
			if (j % M == 0){
				ans = gcd(n, y);
				if (ans > 1) return ans;
			}
		}
		ans = gcd(n, y);
		if (ans > 1) return ans;
	}
}

void decompand(ll n, ll ans[], int &cnt){
	if (n < 2) return;
	if (is_prime(n)){
		ans[++cnt] = n;
		return;
	}
	ll factor;
	do {
		factor = pollard_pho(n);
	} while (factor == n);
	while (n % factor == 0){
		n /= factor;
	}
	decompand(n, ans, cnt);
	decompand(factor, ans, cnt);
}

inline ll sqrt(ll n){
	ll ans = sqrt((double)n);
	while (ans * ans <= n) ans++;
	return ans - 1;
}

inline ll max(ll a, ll b){
	return a > b ? a : b;
}

ll dfs(ll n, int cnt, ll cur, int depth){
	if (cur > n) return 0;
	if (depth > cnt) return cur;
	int depth_i = depth + 1;
	return max(dfs(n, cnt, cur, depth_i), dfs(n, cnt, cur * p_pow_k[depth], depth_i));
}

int main(){
	ll a, b;
	while (cin >> a >> b){
		int cnt = 0;
		ll x = b / a, y, t = x;
		srand(time(NULL));
		decompand(x, p, cnt);
		sort(p + 1, p + cnt + 1);
		cnt = unique(p + 1, p + cnt + 1) - p - 1;
		for (register int i = 1; i <= cnt; i++){
			p_pow_k[i] = 1;
			while (t % p[i] == 0){
				t /= p[i];
				p_pow_k[i] *= p[i];
			}
		}
		y = dfs(sqrt(x), cnt, 1, 1);
		cout << y * a << " " << x / y * a << endl;
	}
	return 0;
}
```

---

## 作者：stansxt (赞：1)

# 思路
- 考虑$x\times y$必然等于$a\times b$，那么令$x=a\times c$，$y=a\times d$。
- 则问题转化为把$b\div a$分解因数，并将它们划分为两个集合，使两个集合里的数乘起来后相差最小（感性理解就是差小积大）。
- 注意到这里还有一个问题：$c$、$d$的最大公约数为1。所以若$b\div a=p_1^{x_1}\times p_2^{x_2}……p_m^{x_m}$，$\forall p_i^{x_i}$只能全部放入同一个集合里，不可能两个集合里都有$p_i$。
- （这好像说的不太清楚……大家看看代码吧$QwQ$）
- 然后怎么求解呢？我用了一个ans数组，存储能凑出的不大于$\sqrt{b\div a}$的最大的数。然后用类似与背包的思想，枚举$b\div a$的因数，每次乘以ans里面的每一个数更新答案。
- 由于数据随机，复杂度当然就是$O($能过$)$啦。（实际上感觉应该是$O(2^m)$的，因为每一次更新数组大小翻个倍。）

# 代码
```
#include<bits/stdc++.h>

#define rg register int
#define il inline
#define in read()
#define _num(x) (x >= '0' && x <= '9')
#define Mem(x) memset(x, 0, sizeof(x)) 
#define mid (l+r>>1)
#define el else if
#define lowbit(x) (x&(-x))
#define int long long

using namespace std;

const int N = 1e5+7;

il int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!_num(ch)){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(_num(ch)){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}

char f[18];
int pcnt;

il void pint(int x){
	pcnt = 0;
	if(x == 0) putchar('0');
	if(x < 0){
		x = -x;
		putchar('-');
	}
	while(x){
		f[++pcnt] = x % 10 + '0';
		x /= 10;
	}
	while(pcnt) putchar(f[pcnt--]);
}

int n, m, x, y, now, pc, pre[N], ls;
int ans[N], ac;

il void ckmax(int &x, int y){return (void)(x = x < y ? y : x);}

signed main()
{
//	freopen("1.txt", "r", stdin);
	while(~scanf("%lld", &n)){
		scanf("%lld", &m);
		if(n == 0 && m == 0){
			printf("0 0\n");
			continue;
		}
		m /= n;
		ls = m;
		pc = ac = 0;
		for(rg i = 2; i <= sqrt(m); ++ i)if(!(m % i)){
			now = 1;
			while(!(m % i)) m /= i, now *= i;
			pre[++ pc] = now;
		}
		if(m - 1) pre[++ pc] = m;
		ans[++ ac] = 1;
		for(rg i = 1; i <= pc; ++ i){
			now = ac;
			for(rg j = 1; j <= now; ++ j){
				if(ans[j] * pre[i] > sqrt(ls)) break;
				ans[++ ac] = ans[j] * pre[i];
			}
		}
        sort(ans+1, ans+ac+1);
		now = ans[ac];
		pint(now * n);
		putchar(' ');
		now = ls / now;
		pint(now * n);
		putchar('\n');
	}
	return 0;
}
```

---


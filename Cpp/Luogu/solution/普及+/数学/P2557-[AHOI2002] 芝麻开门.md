# [AHOI2002] 芝麻开门

## 题目描述

周末小可可参加智力大冲浪活动，经过努力终于来到最后一关“芝麻开门”。门上的电子显示屏写着这么一段话：如果你能把 $n^k$ 的所有正整数因子的和正确地写在门上，并念一声“芝麻开门”，门就能够自由打开。

例如：$n=2$，$k=3$，则 $n^k=8$，它的正因子有 $1,2,4,8$，如果小可可把它们的和 $15$ 写在门上，然后念一声“芝麻开门”，门就能够自动打开。

已知门上的 $n,k$ 都是每过一段时间就会变化一次，请你编写程序协助小可可在规定的时间内求出答案，从而获得智力大冲浪的最终大奖。


## 说明/提示

$1\le  n  \le 2^{16}$，$1\le k \lt 20$。

解的位数不超过 $100$ 位。

## 样例 #1

### 输入

```
1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
2 2```

### 输出

```
7```

# 题解

## 作者：JJA_ (赞：22)

[~~听说有~~更好的阅读体验](https://www.luogu.com.cn/blog/352464/solution-p2557)

题目大意
---
输入 $a,k$ ，输出 $a^k$ 的约数和。

题目思路
---
要切掉这道题，你首先需要知道，**约数和定理**是什么。

#### 约数和定理：

听起来很高大尚，其实很简单：

对于一个大于 $1$ 正整数 $n$ 可以分解质因数：

$$n=p1^{a1}*p2^{a2}*p3^{a3}*…*pk^{ak}$$

基本的分解质因数的定义，不会的话自己[看这里](https://baike.baidu.com/item/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/2253749?fr=aladdin)。

之后呢， $n$ 的 $(a_1+1)(a_2+1)(a_3+1)…(a_k+1)$ 个正约数的和为

$$f(n)=(p1^0+p1^1+p1^2+...+p1^a1)(p2^0+p2^1+p2^2+...+p2^a2)+(pk^0+pk^1+pk^2+...+pk^ak)$$

证明可以看[百度百科](https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/3808428?fr=aladdin)。

---

之后，再看看数据范围， $ 1<= n < 2^{16}$ ~~莫非是传说中的 $n^2$ 过百万~~ 肯定是要用 __高精__。

那我们来复习一下高精，高精其实就是类似竖式一样，但是是使用`string`类型进行运算。举个例子，

$$\begin{aligned}221\\\dfrac{+111}{332}\end{aligned}
$$

就是右对齐，然后每位分别相加，注意进位~~当然由于技术原因我没对齐，请见谅~~。

那么，高精加法的式子就推导出来，

```cpp
string add(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = max(n, m) + 1;
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < len; i ++)
	{
        res[i] += a[i] + b[i];
        if (res[i] >= 10)
		{
            res[i+1] += res[i] / 10;
            res[i] %= 10;
        }
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --)
	{
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
```
~~然后你就发现，你能AC掉[这道题](https://www.luogu.com.cn/problem/P1601)，简直是双倍经验对不对~~

那么减法的式子也很好推，

$$\begin{aligned}221\\\dfrac{-111}{110}\end{aligned}$$

就是注意右对齐和退位。

```cpp
string sub(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = max(n, m);
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < len; i ++) {
        res[i] += a[i] - b[i];
        if (res[i] < 0) {
            res[i+1] --;
            res[i] += 10;
        }
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --) {
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
```
但是注意，一定是大的减小的，所以计算前注意一下。

接下来乘和除的模板就直接给出了：

```cpp
bool cmp(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    int i;
    for (i = 0; i < n-1 && s1[i] == '0'; i ++);
    s1 = s1.substr(i);
    for (i = 0; i < m-1 && s2[i] == '0'; i ++);
    s2 = s2.substr(i);
    if (s1.length() != s2.length()) return s1.length() < s2.length();
    return s1 < s2;
}

string div(string s1, string s2)
{
    string s = "", t = "";
    int n = s1.length(), m = s2.length();
    bool flag = false;
    for (int i = 0; i < n; i ++)
	{
        s += s1[i];
        int num = 0;
        while (cmp(s, s2) == false)
		{
            num ++;
            s = sub(s, s2);
        }
        if (num > 0)
		{
            flag = true;
            char c = (char)(num + '0');
            t += c;
        }
        else if (flag)
		{
            t += '0';
        }
    }
    if (t.length() == 0) t = "0";
    while (s[0] == '0' && s.length() > 1) s = s.substr(1);
    return t;
}

string mul(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = n + m;
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < m; j ++)
            res[i+j] += a[i] * b[j];
    for (int i = 0; i < len; i ++) {
        res[i+1] += res[i] / 10;
        res[i] %= 10;
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --) {
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
```

但是注意，在开头先
```cpp
const int maxn = 100010;//这个量可以改动
int a[maxn], b[maxn],res[maxn];
```
来辅助运算。

但是在讲主函数前，先讲一下，如何在数字和字符串之间**进行转换**，比如将一个`int`值转化成一个`string`字符串。

我们将用到`stringstream`。
```cpp
//stringstream具体使用
int i=114514;
string str;
stringstream ss;
ss>>i;
ss<<str;
cout<<str;
```
这样将会输出 `114514`。

那么用法就很显然，和`cin>>`差不多含义，这个将数据插入了数字流中，并赋值给了字符串。很方便对不对。

---
最后，就是题目代码实现。

首先，我们需要一个分解质因数的代码，记录因子的个数和数值。相信这个大家都会，先`int f[65550];//由于题目大小，最多到这里即可`，之后的不用我说了，看代码就行，相信都看得懂。

```cpp
int f[maxn];//maxn==65550
void work(int n)
{
	for(int i=2;i<=maxn;i++)
	{
		if(n<=1)
		return;
		while(n%i==0)
		{
			n/=i;f[i]++;
		}
	}
}
```
之后，只需要依照题意计算即可，代码：
```cpp
for(int i=2;i<=maxn;i++)
	{
		if(f[i]!=0)
		{
			string s;
			stringstream ss;
			ss<<i;
			ss>>s;
			c[i]="1";
			for(int j=1;j<=f[i]*k+1;j++)
			{ 
				c[i]=mul(c[i],s);
			}
			ss.clear();
			c[i]=sub(c[i],"1");
			string sum;
			ss<<i-1;
			ss>>sum;
			c[i]=div(c[i],sum);
		}
	}
	for(int i=2;i<=maxn;i++)
	{ 
		if(f[i]!=0)
		{ 
			ans=mul(ans,c[i]);
		}
	}
	cout<<ans;
```
于是就愉快地AC了

完整代码：
```cpp
#include<bits/stdc++.h>
#define maxn 65550
using namespace std;
int a[maxn], b[maxn],res[maxn];
string sub(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = max(n, m);
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < len; i ++) {
        res[i] += a[i] - b[i];
        if (res[i] < 0) {
            res[i+1] --;
            res[i] += 10;
        }
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --) {
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
string add(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = max(n, m) + 1;
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < len; i ++)
	{
        res[i] += a[i] + b[i];
        if (res[i] >= 10)
		{
            res[i+1] += res[i] / 10;
            res[i] %= 10;
        }
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --)
	{
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
bool cmp(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    int i;
    for (i = 0; i < n-1 && s1[i] == '0'; i ++);
    s1 = s1.substr(i);
    for (i = 0; i < m-1 && s2[i] == '0'; i ++);
    s2 = s2.substr(i);
    if (s1.length() != s2.length()) return s1.length() < s2.length();
    return s1 < s2;
}

string div(string s1, string s2)
{
    string s = "", t = "";
    int n = s1.length(), m = s2.length();
    bool flag = false;
    for (int i = 0; i < n; i ++)
	{
        s += s1[i];
        int num = 0;
        while (cmp(s, s2) == false)
		{
            num ++;
            s = sub(s, s2);
        }
        if (num > 0)
		{
            flag = true;
            char c = (char)(num + '0');
            t += c;
        }
        else if (flag)
		{
            t += '0';
        }
    }
    if (t.length() == 0) t = "0";
    while (s[0] == '0' && s.length() > 1) s = s.substr(1);
    return t;
}

string mul(string s1, string s2)
{
    int n = s1.length(), m = s2.length();
    for (int i = 0; i < n; i ++) a[i] = s1[n-1-i] - '0';
    for (int i = 0; i < m; i ++) b[i] = s2[m-1-i] - '0';
    int len = n + m;
    for (int i = n; i < len; i ++) a[i] = 0;
    for (int i = m; i < len; i ++) b[i] = 0;
    for (int i = 0; i < len; i ++) res[i] = 0;
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < m; j ++)
            res[i+j] += a[i] * b[j];
    for (int i = 0; i < len; i ++) {
        res[i+1] += res[i] / 10;
        res[i] %= 10;
    }
    int i = len-1;
    while (res[i] == 0 && i > 0) i --;
    string s = "";
    for (; i >= 0; i --) {
        char c = (char) (res[i] + '0');
        s += c;
    }
    return s;
}
int f[maxn];
void work(int n){
	for(int i=2;i<=maxn;i++)
	{
		if(n<=1)
		return;
		while(n%i==0)
		{
			n/=i;f[i]++;
		}
	}
}
string c[maxn];
int main()
{
	string ans="1";
	int n,k,a;
	scanf("%d%d",&n,&k);
	work(n);
	for(int i=2;i<=maxn;i++)
	{
		if(f[i]!=0)
		{
			string s;
			stringstream ss;
			ss<<i;
			ss>>s;
			c[i]="1";
			for(int j=1;j<=f[i]*k+1;j++)
			{ 
				c[i]=mul(c[i],s);
			}
			ss.clear();
			c[i]=sub(c[i],"1");
			string sum;
			ss<<i-1;
			ss>>sum;
			c[i]=div(c[i],sum);
		}
	}
	for(int i=2;i<=maxn;i++)
	{ 
		if(f[i]!=0)
		{ 
			ans=mul(ans,c[i]);
		}
	}
	cout<<ans;
}
```
望采纳，谢谢。

---

## 作者：BFSBFSBFSBFS (赞：7)

~~芝麻开门.~~

题意.求出$n^k$所有的约数和..

若整数$i\ (1<=i<=p)$能整除$p$.则$i$是$p$的约数..

此题把$n$分解1下...

设$n = 180 = 2*2*3*3*5$.

若只考虑$2$.有3种约数$(1,2,4)$.

同理有约数$(1,3,9)$,$(1,5)$.

可以发现其它的约数是通过组合出来的..

所以神奇的转换成多项式乘法..

约数和就是.$(1+2+4)*(1+3+9)*(1+5) = 546\ (n = 180,k = 1)$.

这里多了个$k$.那么每1种约数的个数变成$k$倍.

最后用上高精就好了..

~~复杂度难以分析..~~

奇怪的参考文献.[....](http://oi.nks.edu.cn/zh/Discussion/Details/1736?entry=prob&pid=1374 "....").

Diu代码..

```cpp
program P2557;
 type
  gg=record
   f:array[0..201] of int64;                   //高精数组..
   s:longint;                                  //数组的位数.
  end;
 var
  a,b:gg;
  i,j,k,n,s:longint;
 procedure hahaincdec(var a:gg);               //进退位处理..
  var
   i:longint;
  begin
   i:=1;
   while i<=a.s do
    begin
     if a.f[i]>=10 then
      begin
       inc(a.f[i+1],a.f[i] div 10);
       a.f[i]:=a.f[i] mod 10;
       if i=a.s then inc(a.s);
      end;
     if a.f[i]<=-1 then
      begin
       inc(a.f[i+1],(a.f[i]-9) div 10);
       a.f[i]:=a.f[i] mod 10+10;
      end;
     inc(i);
    end;
   while (a.s>=2) and (a.f[a.s]=0) do dec(a.s);
  end;
 operator *(a,b:gg)c:gg;                   //高精*高精.
  var
   i,j:longint;
  begin
   fillchar(c,sizeof(c),0);
   for i:=1 to a.s do
    for j:=1 to b.s do
     inc(c.f[i+j-1],a.f[i]*b.f[j]);
   c.s:=a.s+b.s-1;
   hahaincdec(c);
  end;
 operator **(a:gg;b:longint)c:gg;         //高精*低精.
  var
   i,j:longint;
  begin
   for i:=1 to a.s do
    a.f[i]:=a.f[i]*b;
   hahaincdec(a);
   c:=a;
  end;
 operator -(a:gg;b:longint)c:gg;          //高精-低精.
  var
   i:longint;
  begin
   dec(a.f[1],b);
   hahaincdec(a);
   c:=a;
  end;
 operator /(a:gg;b:longint)c:gg;          //高精/低精.
  var
   i:longint;
   p:int64;
  begin
   p:=0;
   for i:=a.s downto 1 do
    begin
     p:=p*10+a.f[i];
     a.f[i]:=p div b;
     p:=p mod b;
    end;
   hahaincdec(a);
   c:=a;
  end;
 begin
  readln(n,k);
  if n=1 then writeln(n)                 //说明n永远是1....
         else
  begin
   a.s:=1;
   a.f[a.s]:=1;                          //用于累计最后结果.
   for i:=2 to n do                      //枚举约数..
    begin
     s:=0;
     fillchar(b,sizeof(b),0);            //用于计算当前约数结果..
     b.s:=1;
     b.f[b.s]:=1;
     while n mod i=0 do
      begin
       inc(s);                           //约数个数..
       n:=n div i;
      end;
     s:=s*k;                             //k倍..
     for j:=1 to s+1 do
      b:=b**i;                           //用等比数列求和公式计算...
     b:=(b-1)/(i-1);
     a:=a*b;                             //累乘..
    end;
   for i:=a.s downto 1 do
    write(a.f[i]);
   writeln;
  end;
 end.
```
(ಡωಡ).


---

## 作者：Alviss_lky (赞：6)

~~话说本题C++题解这么少吗~~

这道题需要一个结论——约数和定理。（~~其实是一个不折不扣的数论题~~）

约数和定理：一个数在分解质因数之后将每个质因数的0次方，1次方……一直加到在这个数中出现的最大次方数为止，之后乘起来。

用dfs分解质因数之后就可以啦，别忘记乘方，可以带入dfs函数中。

用一个数组存储所有的质因数。（开到100就行）

最后就是~~烦人~~的高精度。

上代码（~~又臭又长~~）

```
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T&x)
{
	T ll=1;
    T res=0;
	char ch=getchar();
    while(!isdigit(ch))
    {
		if(ch=='-')
		ll=-1;
		ch=getchar();
	}
    while(isdigit(ch))
	res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
    x=res*ll;
}
template<typename T>void print(T x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)
    putchar(x+'0');
    else
    {
        print(x/10);
        putchar(x%10+'0');
    }
}
int _compare(string str1,string str2)
{
    if(str1.length()>str2.length()) return 1;
    else if(str1.length()<str2.length())  return -1;
    else return str1.compare(str2);
}
string abs(string s)
{
    s.erase(0,s.find_first_not_of('-'));
    return s;
}
int compare(string a,string b)
{
    bool x=a[0]!='-',y=b[0]!='-';
    if(x==1&&y==1)return _compare(a,b);
    if(x==1&&y==0)return 1;
    if(x==0&&y==1)return -1;
    else return -_compare(abs(a),abs(b));
}
int get(string s)
{
    for(int i=0;i<s.length();i++)
    {
        if(s[i]!='-')return i;
    }
    return s.length();
}
bool all(string s)
{
    for(int i=0;i<s.length();i++)
    {
        if(s[i]!='0')return 0;
    }
    return 1;
}
string _add(string a,string b)
{
    string ans;
    int x=max(a.length(),b.length());
    for(int i=a.length();i<x;i++)a="0"+a;
    for(int i=b.length();i<x;i++)b="0"+b;
    for(int i=0;i<x;i++)
    ans+="0";
    int jw=0;
    for(int i=x-1;i>=0;i--)
    {
        int s=a[i]+b[i]-96+jw;
        jw=s/10;
        ans[i]=s%10+48;
    }
    if(jw==1)ans="1"+ans;
    ans.erase(0,ans.find_first_not_of('0'));
    return ans;
} 
string _sub(string a,string b)
{
    string ans;
    int x=max(a.length(),b.length());
    for(int i=a.length();i<x;i++)a="0"+a;
    for(int i=b.length();i<x;i++)b="0"+b;
    for(int i=0;i<x;i++)
    ans+="0";
    int jw=0;
    for(int i=x-1;i>=0;i--)
    {
        int s=a[i]-b[i]-jw;
        if(s<0)s+=10,jw=1;
        else jw=0;
        ans[i]=s%10+48;
    }
    if(jw==1)
    {
        for(int i=0;i<ans.length();i++)
        {
            ans[i]=105-ans[i];
        }
        ans=_add(ans,"1");
        ans.erase(0,ans.find_first_not_of('0'));
        ans="-"+ans;
    }
    if(all(ans))
    return "0";
    ans.erase(0,ans.find_first_not_of('0'));
    return ans;
}
string _mul(string a,string b)
{
    string ans;
    int x=a.length();
    int y=b.length();
    string tmp;
    for(int i=y-1;i>=0;i--)
    {
        tmp="";
        int temp=b[i]-'0';
        int t=0;
        int jw=0;
        if(temp!=0)
        {
            for(int j=1;j<=y-1-i;j++)
            {
                tmp+="0";
            }
            for(int j=x-1;j>=0;j--)
            {
                t=(temp*(a[j]-'0')+jw)%10;
                jw=(temp*(a[j]-'0')+jw)/10;
                tmp=char(t+'0')+tmp;
            }
            if(jw!=0) 
            {
                tmp=char(jw+'0')+tmp;
            }
        }
        ans=_add(ans,tmp);
    }
    ans.erase(0,ans.find_first_not_of('0'));
    if(ans=="")return "0";
    return ans;
}
void __div(string a,string b,string &x,string &y)
{
    x=y="";
    if(b=="0")
    {
        x=y="ERROR";
        return;
    }
    if(a=="0")
    {
        x=y="0";
        return;
    }
    int res=_compare(a,b);
    if(res<0)
    {
        x="0";
        y=a;
        return;
    }
    else if(res==0)
    {
        x="1";
        y="0";
        return;
    }
    else
    {
        int _x=a.length();
        int _y=b.length();
        string k;
        k.append(a,0,_y-1);
        for(int i=_y-1;i<_x;i++)
        {
            k=k+a[i];
            k.erase(0,k.find_first_not_of('0'));
            if(k.empty())
                k="0";
            for(char ch='9';ch>='0';ch--)
            {
                string str,tmp;
                str=str+ch;
                tmp=_mul(b,str);
                if(_compare(tmp,k)<=0)
                {
                    x=x+ch;
                    k=_sub(k,tmp);
                    break;
                }
            }
        }
        y=k;
    }
    x.erase(0,x.find_first_not_of('0'));
    if(x.empty()) x="0";
    y.erase(0,y.find_first_not_of('0'));
    if(x.empty()) y="0";
}
string i(string ans)
{
    string bbb;
    for(int kk=0;kk<ans.length();kk++)
    {
        if(ans[kk]!='+')
        bbb+=ans[kk];
    }
    ans=bbb;
    int w=get(ans);
    ans.erase(0,ans.find_first_not_of('-'));
    if(w%2==1)ans="-"+ans;
    return ans; 
}
string add(string a,string b)
{
    a=i(a),b=i(b);
    bool x=(a[0]!='-'),y=(b[0]!='-');
    if(x==1&&y==1)return _add(a,b);
    if(x==1&&y==0)return _sub(a,abs(b));
    if(x==0&&y==1)return _sub(b,abs(a));
    return "-"+_add(abs(a),abs(b));
}
string _div(string a,string b)
{
    string tmp1,tmp2;
    __div(a,b,tmp1,tmp2);
    return tmp1;
}
string div(string a,string b)
{
    a=i(a),b=i(b);
    int x=(a[0]!='-'),y=(b[0]!='-');
    string s=_div(abs(a),abs(b));
    for(int i=1;i<=x+y;i++)
    s="-"+s;
    s=i(s);
    return s;
}
string sub(string a,string b)
{
    return add(a,"-"+b);
} 
string mul(string a,string b)
{
    a=i(a),b=i(b);
    int x=(a[0]!='-'),y=(b[0]!='-');
    string s=_mul(abs(a),abs(b));
    for(int i=1;i<=x+y;i++)
    s="-"+s;
    s=i(s);
    return s;
}
int m[1<<8+1<<2];
int num[100];
int now=1;
void dfs(long long l,long long r)
{
	for(long long i=2;i*i<=l;i++)
	{
		if(l%i==0)
		{
			while(l%i==0)
			{
				l/=i;
				m[i]+=r;
			}
			num[now]=i;
			now++;
			dfs(l,r);
			return;
		}
	}
	if(l==1)return;
	m[l]+=r;
	num[now]=l;
	now++;
	return;
} 
string pow(string x,long long y)
{
	if(y==0)return "1";
    string res="1";
    while(y)
    {
        if(y&1)
            res=mul(res,x);
        x=mul(x,x);
        y=y>>1;
    }
    return res;
} 
int main()
{
	long long n,k;
	read(n);
	read(k);
	dfs(n,k);
	string ans="1";
	for(int i=1;i<now;i++)
	{
		string s=to_string(num[i]),g=s;
		s=pow(s,m[num[i]]+1);
		s=sub(s,"1");
		s=div(s,sub(g,"1"));
		ans=mul(ans,s);
	}
	cout<<ans<<endl;
}
```

---

## 作者：Yyxxxxx (赞：3)

题意即求$a^k$的约束和

由[百度百科-约束和定理](https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/3808428?fr=aladdin)可得

我们便可以把$a^k$分解，得到
$$Ans=(1+p_1^1+p_1^2+\cdots+p_1^{w_1k-1}+p_1^{w_1k})(1+p_2^1+p_2^2+\cdots+p_2^{w_2k-1}+p_j^{w_2k})\cdots(1+p_i^1+p_i^2+\cdots+p_i^{w_ik-1}+p_i^{w_ik})$$
其中
$$a=\prod\limits p_i^{w_i}$$

于是卑微的写完高精度就可以过了
## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
string div(string a,int b)
{
	string c="";int d=0;
	for(int i=0;i<a.length();i++)
		a[i]-='0';
	for(int i=0;i<a.length();i++)
		c.push_back((d*10+a[i])/b+'0'),d=(d*10+a[i])%b;
	for(int i=0;c[0]=='0';i++)
		c.erase(c.begin(),c.begin()+1);
	return c;
}
string times(string a,string b){
    char ans[255]={};
    int a1[255]={},b1[255]={},s[255]={};
    int k=0,t,len,lena=a.length(),lenb=b.length();
    for(int i=0;i<lena;i++)a1[i]=a[i]-'0';
    for(int i=0;i<lenb;i++)b1[i]=b[i]-'0';
    for(int j=lenb-1;j>=0;j--)
    {
    	t=k;
    	for(int i=lena-1;i>=0;i--)s[t]+=a1[i]*b1[j],t++;
    	k++,len=t;
	}
	for(int i=0;i<len;i++)while(s[i]>=10)s[i]-=10,s[i+1]++;
	if(s[len]!=0)for(int i=len;i>=0;i--)ans[len-i]=s[i]+'0';
	else for(int i=len-1;i>=0;i--)ans[len-1-i]=s[i]+'0';
	return ans;
}
string jian(string a)
{
	char ans[255]={};
	int len=a.length();
	ans[len-1]=a[len-1]-1;for(int i=len-2;i>=0;i--)ans[i]=a[i];
	return ans;
}
int f[65536+5];
string c[65536+5];
int main()
{
	string ans="1";
	int n,k,a;
	scanf("%d%d",&n,&k);
	for(int i=2;n>1&&i<=65536;i++)
		if(n%i==0)
			while(1)
				if(n%i==0)n/=i,f[i]++;
				else break;
	for(int i=2;i<=65536;i++)
		if(f[i]!=0)
		{
			string s;
			stringstream ss;
			ss<<i;
			ss>>s;
			c[i]="1";
			for(int j=1;j<=f[i]*k+1;j++)
				c[i]=times(c[i],s);
			c[i]=jian(c[i]);
			c[i]=div(c[i],i-1);
		}
	for(int i=2;i<=65536;i++)
		if(f[i]!=0)
			ans=times(ans,c[i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：Doveqise (赞：3)

这道题emmm一道算是乘法原理还是什么balabala的题  
大概思路:
输入的数可以分解成素数$a_i$的$k_i$次方之积  
然后进行模拟  
样例什么的楼下给了可以自己看一下  
拿Python怒水一波  
~~（才不是因为C++高精度写炸了呢 哼唧）~~  
下见代码  
~~（什么，不会Python?）~~  
Python这种东西在NOIP/NOI赛场上hin有用，推荐一学  
快速入门的话看下面链接????  
[丢蓝链](https://github.com/luogu-dev/cyaron/wiki/Python-30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97)  
代码丢一下（（（逃
```python
lst=dict() 
n,k=int(),int() 
access=[] 
def research(x): 
    i=2
    while i<=x :
        if x%i==0 :
            access.append(i)
            lst[i]=0
        while x%i==0 :
            x/=i
            lst[i]+=k
        i+=1
    if x>1 :
        lst[x]+=1

n,k=map(int,input().split())

research(n)

ans=1

for i in access:
    t=0
    tmp=1
    for j in range(lst[i]+1):
        t+=tmp
        tmp*=i
    ans*=t

print(ans)
```


---

## 作者：SunsetSamsara (赞：2)

~~本篇题解默认你读懂了题~~

## 前置知识
数论，高精度
## 分析
首先我们准备要求的是**一个数的因数和**。

如何求一个数的因数和呢？

先举个例子：$12$ 的因数和是 $1 + 2 + 3 + 4 + 6 + 12 = 28$，似乎没什么规律可言。

不过，我们可以把每个因数拆开，每个因数都可以拆成 $2 ^ x 3 ^ y$ 的形式。这就给我们了启示：似乎可以枚举 $x$ 后找到所有的 $y$，再求和。

还是以 $12$ 为例：$2 ^ 0 (3 ^ 0 + 3 ^ 1) + 2 ^ 1 (3 ^ 0 + 3 ^ 1) + 2 ^ 2(3 ^ 0 + 3 ^ 1) = 28$。接下来只需简化计算的过程即可。

可以发现式子有公因数 $(3 ^ 0 + 3 ^ 1)$，提出来后就可以转化为 $(2 ^ 0 + 2 ^ 1 + 2 ^ 2)(3 ^ 0 + 3 ^ 1) = 28$。

于是我们成功地把计算的过程简化成了多项式乘法。

接下来直接用高精度求即可。

不过还有很多优化，例如：

+ 中间的分解质因数的步骤可以先分解 $n$ 后把每一个指数乘 $k$，可以避免高精除。

+ 中间的多项式求值可以使用等比数列求和公式优化，不过得加上高精除。

## 代码
下面是一种典型的写法：
```cpp
#include <bits/stdc++.h>
#define lld long long
using namespace std;
struct Hint {
	int data[101];
	int len;
	Hint(int x = 0){
		len = 0;
		while (x) {
			data[++len] = x % 10;
			x /= 10;
		}
	}
	void print()const{
		if (!len) puts("0");
		else{
			for (int i = len; i; --i)
				printf("%d", data[i]);
			puts("");
		}
	}
};
Hint operator + (Hint a, Hint b) {
	if (a.len < b.len){
		for (++a.len; a.len < b.len; ++a.len) a.data[a.len] = 0;
		a.data[a.len] = 0;
	}
	if (a.len > b.len){
		for (++b.len; a.len > b.len; ++b.len) b.data[b.len] = 0;
		a.data[b.len] = 0;
	}
	for (int i = 1; i <= a.len || i <= b.len; ++i){
		a.data[i] += b.data[i];
		if (a.data[i] >= 10){
			if (i + 1 <= a.len) ++a.data[i + 1], a.data[i] -= 10;
			else a.len = i + 1, a.data[a.len] = 1, a.data[i] -= 10;
		}
	}
	return a;
}
Hint operator * (const Hint & a, const Hint & b) {
	Hint res(0);
	for (int i = 1; i <= 100; ++i)
		res.data[i] = 0;
	for (int i = 1; i <= a.len; ++i)
		for(int j = 1; j <= b.len; ++j){
			res.data[i + j - 1] += a.data[i] * b.data[j];
			if(res.data[i + j - 1] >= 10){
				res.data[i + j] += res.data[i + j - 1] / 10;
				res.data[i + j - 1] %= 10;
			}
		}
	res.len = a.len + b.len - 1;
	if (res.data[a.len + b.len]) ++res.len;
	return res;
}
int pw[100001];
int m, n, k;
int main() {
	scanf("%d%d", &n, &k);
	m = n;
	for (int i = 2; i * i <= m; ++i)
			while (m % i == 0){
				++pw[i];
				m /= i;
			}
	if (m != 1) ++pw[m];
	for (int i = 1; i <= n; ++i)
		pw[i] *= k;
	Hint now, res, ans = 1;
	for (int i = 2; i <= n; ++i){
		now = 1; res = 1;
		for (int j = 1; j <= pw[i]; ++j) {
			now = now * i;
			res = res + now;
		}
		ans = ans * res;
	}
	ans.print();
}
```

---

## 作者：PosVII (赞：2)

前言

------------

比较简单的一道推式子题，难度就在你有没有高精度的板子了。

推理

------------

我们肯定将 $n^k$ 分解质因数，变成如下形式：

$n^k = p_{1}^{x_1} \times p_{2}^{x_2} \times ……\times p_{i}^{x_i}$

当然，求这个质因数时，我们完全可以这样求：

$n = p_{1}^{x_1} \times p_{2}^{x_2} \times ……\times p_{i}^{x_i}$

$n^k = p_{1}^{k \times x_1} \times p_{2}^{k \times x_2} \times ……\times p_{i}^{k \times x_i}$

**以上是第一个优化。**

为了方便，我们就以第一个式子来推算。

我们知道，$n^k$ 的某一个正因子可以这样表示：

$p_{1}^{a_1} \times p_{2}^{a_2} \times ……\times p_{i}^{a_i}$ （其中 $0 \leq a_{i} \leq x_{i}$）

那么 $n^k$ 的正因数和那也就好求了，我们只需要找到能表示出上方所有制的多项式乘法的一个式子：

$(p_{1}^{0}+p_{1}^{1}+p_{1}^{2}+……+p_{1}^{a_1}) \times (p_{2}^{0}+p_{2}^{1}+p_{2}^{2}+……+p_{1}^{a_2}) \times ……\times (p_{i}^{0}+p_{i}^{1}+p_{i}^{2}+……+p_{1}^{a_i})$

我们可以用等比数列求和公式将此式子变一下。

$\tfrac{p_{1}^{a_1+1}-1}{p_{1}-1} \times \tfrac{p_{2}^{a_2+1}-1}{p_{2}-1} \times ……\times \tfrac{p_{i}^{a_i+1}-1}{p_{i}-1}$

**以上是第二个优化**。

**Code:**

------------

```
#include<bits/stdc++.h>
using namespace std;
int n,k,a;
char arr[16];
string sum="1";
string gles(string a1,string b1){
	int lena=a1.length(),lenb=b1.length(),lenc;
	int a[5005],b[5005],c[5005];
	for(int i=0;i<lena;i++)a[lena-i]=a1[i]-'0';
	for(int i=0;i<lenb;i++)b[lenb-i]=b1[i]-'0';
	int i=1;
	while(i<=lena||i<=lenb){
		if(a[i]<b[i]){
			a[i]+=10;
			a[i+1]--;
		}c[i]=a[i]-b[i];
		i++;
	}lenc=i;
	while(c[lenc]==0&&lenc>1)lenc--;
	string k="";
	for(i=lenc;i>0;i--)k+=c[i]+'0';
	return k;
}
string mul(string x,string y){
	int a[50005]={0},b[50005]={0},c[100005]={0};
	int lena=x.size();
	int lenb=y.size();
	for(int i=0;i<lena;i++)a[lena-i]=x[i]-'0';
	for(int i=0;i<lenb;i++)b[lenb-i]=y[i]-'0';
	for(int i=1;i<=lenb;i++){
		int k=0;
		for(int j=1;j<=lena;j++){
			c[i+j-1]=c[i+j-1]+a[j]*b[i]+k;
			k=c[i+j-1]/10;
			c[i+j-1]%=10;
		}c[i+lena]=k;
	}int lenc=lena+lenb;
	while(c[lenc]==0&&lenc>1)lenc--;
	string l;
	for(int i=lenc;i>0;i--){
		l+=c[i]+'0';
	}
	return l;
}
int cmp(string x,string y){
	if(x.size()>y.size())return 1;
	if(x.size()<y.size())return -1;
	return x>y;
}
string div(string x,string y){
	int lena=x.size(),lenb=y.size();
	string t,z;
	t.append(x,0,lenb-1);
	for(int i=lenb-1;i<lena;i++){
		t+=x[i];
		t.erase(0,t.find_first_not_of('0'));
		if(t.empty())t="0";
		for(char j='9';j>='0';j--){
			string mul1;mul1+=j;
			mul1=mul(mul1,y);
			if(cmp(mul1,t)<1){
				z+=j;
				t=gles(t,mul1);
				break;
			}
		}
	}z.erase(0,z.find_first_not_of('0'));
	if(z.empty())z="0";
	return z;
}
string gpow(string x,int p) {
	if(p==1) return x;
	if(p==0) return "1";
	string fx=gpow(x,p/2);
	if(p&1) {
		return mul(mul(fx,x),fx);
	}
	return mul(fx,fx);
} 
bool Is_prime(int x) {
	if(x==2) return 0;
	if(x==1) return 1;
	for(int i=2;i<=sqrt(x)+1;i++) {
		if(x%i==0) {
			return 1;
		}
	}
	return 0;
}
void itoa(int x) {
	int ind=0;
	while(x>0) {
		arr[ind]=x%10+'0';
		ind++;
		x/=10;
	}
	ind--;
	for(int i=0;i<=ind/2;i++) {
		swap(arr[i],arr[ind-i]);
	}
	return;
}
int main() {
	cin>>n>>k;
	for(int i=1;i<=n;i++) {
		if(Is_prime(i)) continue;
		a=0;
		while(n%i==0) {
			n/=i;
			a++;
		}
		if(a>=1) {
			itoa(i);
			string si=arr;
			sum=mul(sum,div(gles(gpow(si,a*k+1),"1"),gles(si,"1")));
		}
	}
	cout<<sum;
	return 0;
} 
```





---

## 作者：回囦囨囸 (赞：1)

这是我第一次写题解 , 写得不好的地方请指正QwQ

**题目连接** [P2557 AHOI2002 芝麻开门](https://www.luogu.com.cn/problem/P2557)

## 题目大意

用浅显易懂的话来说就是给出 $n$ 和 $k$，求$n^{k}$的因数的和。
$1 \le n < 2^{16}$ , $1 \le k < 20 $，答案长度 $ \le 100$。

## 解题思路

对于一个数，我们可以将其表示为若干个质数次方和，即

$$p_1^{a_1}*p_2^{a_2}*…*p_q^{a_q}$$

那么这个数的因数就可以表示为

$$p_1^{b_1}*p_2^{b_2}*…*p_q^{b_q}$$

其中对于 $\forall 1 \le i \le q $，有$0 \le b_i \le a_i$。

这是前提。

##

接下来是主要部分。

对于 $n$，我们将其分解成 $p_1^{a_1}*p_2^{a_2}*…*p_q^{a_q}$ 的形式。

那么 $n^k$ 就可以表示为 $p_1^{k*a_1}*p_2^{k*a_2}*…*p_q^{k*a_q}$。

所以 $n^k$ 的因数就可以表示为 $p_1^{b_1}*p_2^{b_2}*…*p_q^{b_q}$ , 其中对于 $\forall 1 \le i \le q $ , 有$0 \le b_i \le k*a_i$。

所以 $n^k$ 的因数和就为

$$\prod_{i=1}^q \sum_{j=1}^{k*a_i} p_i^j$$

##

再看 **答案长度 $ \le 100$**。

那就是~~恶心的~~高精度时间了。

##

因为 $n < 2^{16}$，所以 $q \le 7$，$a_i \le 16$。

高精度复杂度大概是 $\Theta(len^2)$，可以直接 $\Theta(qka_ilen^2)$ 直接硬算。

##

大概就是这些，下面附上代码
```cpp
#include<iostream>
using namespace std;
long long a[110],b[110],c[110];
int la,lb,lc;
int main()
{
	int n,k;
	cin>>n>>k;
	if(n==1)
	{
		cout<<1;
		return 0;
	}
	b[1]=1;
	lb=1;
	for(int p=2;p<=n;p++)
	{
		for(int i=1;i<=109;i++)
			a[i]=c[i]=0;
		la=1;
		a[1]=1;
		lc=0;
		while(n%p==0)
		{
			n/=p;
			for(int i=1;i<=k;i++)
			{
				for(int i=1;i<=la;i++)
					a[i]*=p;
				int s=0;
				while((a[s+1]||s<la)&&s<=105)
				{
					s++;
					a[s+1]+=a[s]/10;
					a[s]%=10;
				}
				la=s;
				a[1]++;
				s=0;
				while((a[s+1]||s<la)&&s<=105)
				{
					s++;
					a[s+1]+=a[s]/10;
					a[s]%=10;
				}
			}
		}
		for(int i=1;i<=la;i++)
			for(int j=1;j<=lb&&j+i<=106;j++)
				c[i+j-1]+=a[i]*b[j];
		lc=lb+la-1;
		int s=0;
		while((c[s+1]||s<lc)&&s<=105)
		{
			s++;
			c[s+1]+=c[s]/10;
			c[s]%=10;
		}
		lc=s;
		for(int i=1;i<=109;i++)
			b[i]=0;
		for(int i=1;i<=lc;i++)
			b[i]=c[i];
		lb=lc;
	}
	for(int i=lb<100?lb:100;i>=1;i--)
		cout<<b[i];
}
```
代码是一年前码的，~~奇丑无比~~。

---

## 作者：FANTA5TlC (赞：1)

大家好啊，我是dyisz

[题面](https://www.luogu.com.cn/problem/P2557)

[更好的阅读体验](https://www.luogu.com.cn/blog/dyisz666/ti-xie-p2557-ahoi2002-zhi-ma-kai-men)

首先看标签：数论。再看题面，把题面简化后，我们可以发现，题目考的是两点：
###### 1. 高精度

###### 2. 约数和的定义（本题难点）
简单来讲，题目问的就是a^k的约数和。

当我们知道约数和定义后，就能根据定义写出程序。所以接下来讲约束和的定义。
# 约数和定义如下：

对于一个大于1正整数n可以分解质因数：

$\operatorname{n} = p1^ {a1}  * p2^ {a2} * p3^ {a3} * … * pk^{ak}$

设s为n的正约数个数，则

$\operatorname{s} = (a_1 + 1)(a_2 + 1)(a_3 + 1)…(a_k + 1)$

那么n的(a₁ + 1)(a₂ + 1)(a₃ + 1)…(ak + 1)个正约数的和为

$\operatorname{f(n)} = (p1^0 + p1^1 + p1^2 + … p1^a1)(p2^0 + p2^1 + p2^2 +… p2^a2) … (pk^0 + pk^1 + pk^2 + … pk^ak)$

以上就是定义，接下来讲思路部分。
# 思路
首先，数据范围是1 ≤ n ≤ 2^16，计算时要用高精度，上文有提到。

程序里，先用dfs分解 $a^k$ 的质因数，然后用一个数组（大小100以上差不多），然后一直将每个因数自乘到最高次数，最终加起来，输出结果。

本菜鸡的代码就不上了，相信您们这样的dalao一定能写出来。

---

## 作者：baccano (赞：1)

作为一名只有普及组水平的ACMer遇到这种大数的问题肯定是先想到用JAVA的。。。  
式子还是很好推的，根据约数和定理然后把n分解质因数然后套上一个等比数列的求和公式即可。  
上一份丑陋的java AC代码.乘积我还用了快速幂我怕java又卡大数超时
```java
import java.io.BufferedInputStream;
import java.math.BigInteger;
import java.util.Scanner;
public class Main 
{
	static int p[]=new int[100005],cnt[]=new int[100005],q=0;
	static BigInteger qpow(int a,int b)
	{
		BigInteger base=new BigInteger(new Integer(a).toString());
		BigInteger ans=BigInteger.ONE;
		while(b!=0)
		{
			if((b&1)==1)
			ans=ans.multiply(base);
			base=base.multiply(base);
			b>>=1;
		}
		return ans;
	}
	public static void main(String[] args) 
	{
		Scanner cin=new Scanner(new BufferedInputStream(System.in));
		int n,k;
		n=cin.nextInt();
		k=cin.nextInt();
		for(int i=2;i*i<=n;i++)
		{
			if(n%i==0)
			{
				p[++q]=i;
				while(n%i==0)
				{
					cnt[q]++;
					n/=i;
				}
			}
		}
		if(n>1)
		{
			p[++q]=n;
			cnt[q]=1;
		}
		BigInteger ans=new BigInteger("1");
		for(int i=1;i<=q;i++)
		ans=ans.multiply(qpow(p[i],cnt[i]*k+1).subtract(BigInteger.ONE).divide(new BigInteger(new Integer(p[i]-1).toString())));
		System.out.println(ans);
	}
}
```

---


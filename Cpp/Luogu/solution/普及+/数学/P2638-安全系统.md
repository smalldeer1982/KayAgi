# 安全系统

## 题目描述

特斯拉公司的六位密码被轻松破解后，引发了人们对电动车的安全性能的怀疑。李华听闻后，自己设计了一套密码：

- 假设安全系统中有 $n$ 个储存区，每个储存区最多能存储存 $2$ 种种类不同的信号（可以不储存任何信号）。有 $0$ 和 $1$ 这两种信号，其中 $0$ 有 $a$ 个，$1$ 有 $b$ 个，单独一个 $0$ 或 $1$ 算一个信号。现要将这些信号储存在储存区中，$0$ 和 $1$ **可以不用全部储存**，一个储存区可以存放任意多个 $0$ 和任意多个 $1$。一种不同的储存方案经过李华处理后就将是一串不同的密码。

现在给出 $n,a,b$，求可能的不同储存方案的个数。


## 说明/提示

所有 $9$ 种方案如下：

| 储存区 $1$ | 储存区 $2$ |
| :----------: | :----------: |
| $\verb!NULL!$ | $\verb!NULL!$ |
| $0$ | $\verb!NULL!$ |
| $1$ | $\verb!NULL!$ |
| $\verb!NULL!$ | $0$ |
| $\verb!NULL!$ | $1$ |
| $0,1$ | $\verb!NULL!$ |
| $\verb!NULL!$ | $0,1$ |
| $1$ | $0$ |
| $0$ | $1$ |

对于全部数据，$a,b\le 50$，$n+a\le 50$，$n+b\le 50$。

---

$\text{upd 2022.10.22}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
2 1 1```

### 输出

```
9```

# 题解

## 作者：NZSWW33OMF2GC (赞：261)

这题纯组合数学妥妥的做掉好吧！！下面用高中学过的一点小技巧过一遍。

这方法真的很简单~~而且说不定高考用得上~~

题解页面公式会挂掉，所以请移步[此处](https://www.luogu.com.cn/blog/x4Cx58x54/solution-p2638)。

---

## 问题重述

有两种球，分别是黑球（信号 0）和 红球（信号 1），相同类别的球之间**没有区别**。现在有 $n$ 个**各不相同**的盒子（储存区），要把 $a$ 个黑球和 $b$ 个红球放进这些盒子里。求方案总数。

**每个盒子可以装任意多球，也可以不装。并且以上 $a+b$ 个球不需要全部放进盒子里，甚至可以不放任何球进盒子里。**

---

## 问题分析

首先，既然不需要全部放进盒子里，那就讨论每一类球数确定时的情况。我们记 $n$ 个盒子，放 $i$ 个黑球以及 $j$ 个红球（全部放进去）的方案数为

$$
f(n, i, j),\quad (0 \leq i \leq a,\ 0 \leq j \leq b).
$$

显然（真的！），那么题中所求的总方案数就可以表达为

$$
\mathrm{ans} = \sum_{i=0}^a \sum_{j=0}^b f(n, i, j),
$$

（公式挂了的话到[这里](https://www.luogu.com.cn/blog/x4Cx58x54/solution-p2638)吧）

也就是一个二重循环的事情了。

那么现在我们需要知道这个 $f(n, i, j)$ 怎么算。这是放 $i$ 个黑球，再放 $j$ 个红球的方案数，这两步操作是独立的，也就是

$$
f(n, i, j) = g(n, i) \cdot g(n, j),
$$

其中 $g(n, k)$ 表示的是 $n$ 个盒子中放入 $k$ 个同类球的方案数。

（为什么放两种球相互独立呢？相信聪明的你一下就会明白的！）

那么我们就只需要知道如何将 $k$ 个球分给 $n$ 个盒子了。高二高三的同学肯定已经做过不少这样的题目了。这里用一种巧妙的隔板法来解决：

### 隔板法

我们先退一步。$k$ 个球分给 $n$ 个盒子。我们假设，题目要求变为每个盒子**至少要分得一个球**，如何解决呢？


$k$ 个球之间形成了 $k-1$ 个间隙，我们将 $n-1$ 个隔板插入间隙中，隔板就将球分为了 $k$ 份，符合假设。这样从 $k-1$ 个间隙中选出 $n-1$ 个插入隔板，即方案数为 $\mathrm{\large C}_{k-1}^{n-1}$.

![](https://cdn.luogu.com.cn/upload/image_hosting/78j7hpxu.png)


但是现在要解决的情况是盒子可以分不到球。这样我们通过一步化归，转换为上面的情况：添加 $n$ 个球，使每个盒子至少有一个球。这样分完后只要将每个盒子多拿的一个球收回，便回到原情况了。于是得到方案数 $\mathrm{\large C}_{k+n-1}^{n-1}$.


（为什么不让每个间隙能插入多块隔板呢？仔细想想，这一步处理毫无意义。）

![](https://cdn.luogu.com.cn/upload/image_hosting/94f6xi1t.png)

这个称为隔板法的方法经常可以应用到在高中的排列组合题目中。

---

这么一来，整个方案数的表达式已经确定了：

$$
\begin{aligned}
\mathrm{ans} &= \sum_{i=0}^a \sum_{j=0}^b f(n, i, j)\\
&= \sum _ {i=0}^a \sum_{j=0}^b g(n, i)\,g(n, j)\\
&= \sum _ {i=0}^a \sum_{j=0}^b \mathrm{\large C}_{i+n-1}^{n-1} \cdot \mathrm{\large C}_{j+n-1}^{n-1}.
\end{aligned}
$$

（公式挂了的话到[这里](https://www.luogu.com.cn/blog/x4Cx58x54/solution-p2638)吧）

先递推算出组合数存入数组，然后再计算上式即可。

核心代码：

```c++
for(int i = 0; i <= a; i++)
    for(int j = 0; j <= b; j++)
        ans += comb[n+i-1][n-1] * comb[n+j-1][n-1];
```

再来看一下数据范围。这里的组合数需要算到多大呢？容易看出最大总元素数（就是 $\mathrm{C}$ 的那个下标）是 $n+\max(a, b)-1$。根据题给范围，我们最多需要算到 $\mathrm{\large C}_{49}^{k}$. 可以验证，这不需要高精度，但是一定要开 `unsigned long long`！切记！ $\large\texttt{unsigned long long }!$ 

---

啊，写了两个小时。如果您看明白了的话，请给个赞吧 ^_^

---

## 作者：思考人生中 (赞：36)

在题解区看了半天发现没有 $O(n)$ 的做法~~，估计是因为n的范围实在太小了~~。

同时还出现了两种完全不同的题意解释，但是最终答案却完全相同，都是正确的。

本文将先阐释 $O(n)$ 的做法，再证明为何两种解释的答案会相同。

题目链接：**[P2638 安全系统](https://www.luogu.com.cn/problem/solution/P2638)**

（**对题意困惑的童鞋**请跳到第二部分）


## 1. $O(n)$算法

---

### 思路

这里我对题目的解释是：所有的1信号**相同**，所有0信号**相同**，并且一个存储器可以存储**多个**相同信号。

首先最初的想法其他题解已经讲的很清楚了，我就不多浪费文字了。

两种信号互相不影响，只需要分别用插板法计算 $a$ 与 $b$ 个信号存储在 $n$ 个存储器中的答案，再将二者相乘即可。

其中信号0的存储方法种数：

$$\sum\limits_{i=0}^{a} {\binom{i+n-1}{n - 1}}$$


看到其他题解里有说用数学方法可以做到 $O(n)$ 。确实，我第一个想到的就是用数学方法简化。

+ **数学方法**

首先有大名鼎鼎的**组合数递推公式**：
$$\binom{n}{r} = \binom{n - 1}{r} + \binom{n - 1}{r - 1}$$

其中 $\binom{n}{r}$ 为二项式，即 $\operatorname{C}_n^r$ **（注意上下标的位置，不要搞反）**。

从而：

$$\binom{n - 1}{r - 1} = \binom{n}{r} - \binom{n - 1}{r}$$

然后我们就利用它做一个裂项：

$$
\begin{aligned}

\sum\limits_{i=0}^{a} {\binom{i+n-1}{n - 1}} =&
\sum\limits_{i=0}^{a} 
	\left[
	{\binom{i+n}{n}} - \binom{i+n-1}{n}
	\right]
\\

=&\sum\limits_{i=0}^{a} {\binom{i+n}{n}} -
\sum\limits_{i=0}^{a} {\binom{i+n-1}{n}}
\\

=&\sum\limits_{i=1}^{a+1} {\binom{i+n - 1}{n}} - \sum\limits_{i=0}^{a} {\binom{i+n-1}{n}}
\\

=&\binom{a+n}{n} - \binom{n-1}{n}
\\

=&\binom{a+n}{n}

\end{aligned}
$$

而单个二项式的计算是 $O(n)$ 的。

然而，很快我发现，并不需要用数学方法来简化它

+ **组合方法**

我们来看我们之前的~~柿~~式子是怎么推出来的：是将 $i$ 个信号放入 $n$ 个存储区内的放法，然后对每个 $i (0\le i \le a)$ 利用插板法。

由于每个0相同，我们可以再多放一个存储区，用来存储没有存储在前 $n$ 个存储区内的信号，也就是 $a$ 个信号放入 $(n+1)$ 个存储区，其中存储区内信号个数为非负整数。

这样就是将 $n$ 个板插入 $(a+n+1)-1=(a+n)$ 个空，方法数为：
$$\binom{a+n}{n}$$

至此 $O(n)$ 的算法就讲解完了。~~(实际上还可以取$n$,$a$的最小值来计算）~~

---

### 代码
代码十分简洁，只需要计算组合数再把两种情况乘起来就彳亍了。


```cpp
#include<cstdio>
using namespace std;

unsigned long long bino(int n, int r) {//计算二项式。
    unsigned long long ans = 1;
    for (int i = 1; i <= r; ++i) {
        ans *= n - i + 1;
        ans /= i;//边乘边除是为了防爆范围，做除法时整除证明不多阐述。
    }
    return ans;
}

int main() {
    int n, a, b;
    scanf("%d %d %d", &n, &a, &b);
    printf("%llu\n", bino(a+n, n)*bino(b+n, n));
    return 0;
}
```
---
## 2. 题意

**这道题题意是有歧义的**，并没有明确说明每个存储区究竟是可以存放多个信号还是只能存放一个，样例中的 $a$ 与 $b$ 也都是 $1$，无法由此判断。第一次提交的时候我也没搞清题意，暴零了。

一脸迷惑的我进入题解区，看到两种不同解释，更迷惑了。

总结一下，大致有两种解释：

1. 所有的1信号**相同**，所有0信号**相同**，并且一个存储器可以存储**多个**相同信号。

2. 所有的1、0信号**不同**，并且一个存储器**至多**能存储一个0和一个1

第一种解释就是我之前所说的，这里不多解释。

第二种解释给出的答案是：

$$\sum_{i=0}^{a}\binom{n}{i}\binom{a}{i}$$

大致是说在 $n$ 个存储区内选 $i$ 个存储区放信号，然后再从 $a$ 个信号中选 $i$ 个存储。

仔细想想是有问题，因为如果每个0信号不同，应当答案再乘以 $i$ 个0信号的排列。如果真是按照第二种解释，应当不是这个答案。也就是说，**第二种解释是错误的**。

然而，最有趣的就是这个答案虽然是错的，但是可以通过本题。经过一个上午的思考，我发现这是个歪打正着。

下面证明两种解释答案的结果是相同的。

---

+ **数学方法**

我们用到大名鼎鼎的**范德蒙德卷积公式**！

$$\sum_k \binom{r}{k}\binom{s}{n - k} = \binom{r+s}{n}$$

其证明可以用生成函数，也可以有组合证明，具体见[这里](https://www.zhihu.com/question/62446990/answer/1428351898)。

于是：

$$
\begin{aligned}

\sum_{i=0}^{a}\binom{n}{i}\binom{a}{i}=&\sum_{i=0}^{a}\binom{n}{i}\binom{a}{a-i}
\\

=&\binom{a+n}{a}=\binom{a+n}{n}

\end{aligned}
$$

这样就得到了我们之前算出的式子。

---

+ **组合方法**

我们可以从这个角度理解第一种解释：我们选 $i$ 个存储区， 把 $a$ 个信号放入这 $i$ 个存储区和一个独立于 $n$ 个存储区，存放剩下的信号的存储区。

这样存信号种数有 $\binom{a}{i}$ 个，而选出 $i$ 个存储区的方法有 $\binom{n}{i}$种。

从而第一种解释的式子变为：

$$\sum_{i=0}^{a}\binom{n}{i}\binom{a}{i}$$

这与第二种解释的式子是相同的。

---

完结撒花（？

~~求赞~~

~~求通过~~



---

## 作者：KaguyaH (赞：15)

> [**返回题目**](https://www.luogu.com.cn/problem/P2638) [**博客查看**](https://www.luogu.com.cn/blog/236807/Solution-luogu-P2638)

## 题意简述

- 你有 $n$ 个容器、$a$ 个 $0$、$b$ 个 $1$，每个容器可以装任意多的 $0$ 和 $1$，但总数不可超过 $a$ 和 $b$。求方案数。
- $0 \leqslant n, a, b \leqslant 50$。

## 题目分析

看到如此小的数据范围，时间复杂度劣一点也没有关系。

我们考虑如此设计 DP：$f_{i, j, k}$ 表示当 $n = i, a = j, b = k$ 时的答案。

~~至于为什么这么设计，作者感觉显然，欢迎在评论里指出思路。~~

考虑转移。考虑枚举最后一个容器中 $0$ 和 $1$ 的数量。

易得：

$$
f_{i, j, k} =
\begin{cases}
\left[j = 0 \land k = 0\right] & i = 0\\
\sum_{l = 0}^j\sum_{m = 0}^kf_{i - 1, l, m} & i > 0
\end{cases}
$$

上式中，当没有容器时，只能装 $0$ 个 $0$ 和 $0$ 个 $1$；当有容器时，枚举前 $(i - 1)$ 个容器中的 $0$ 和 $1$ 的数量，就相当于没聚了最后一个容器中 $0$ 和 $1$ 的数量。

时间复杂度 $O(na^2b^2)$，空间复杂度 $O(nab)$，可过。

## 代码

```cpp
# define _CRT_SECURE_NO_WARNINGS
# include <cstdio>

typedef short unsigned int hu;
typedef long long unsigned int llu;
enum { N = 50, A = 50, B = 50 };

static hu n, a, b;
static llu f[N + 1][A + 1][B + 1];
static llu ans;

signed int main() {
	scanf("%hu%hu%hu", &n, &a, &b);
	f[0][0][0] = 1;
	for (hu i(1); i <= n; ++i)
		for (hu j(0); j <= a; ++j)
			for (hu k(0); k <= b; ++k)
				for (hu l(0); l <= j; ++l)
					for (hu m(0); m <= k; ++m)
						f[i][j][k] += f[i - 1][l][m];
	for (hu i(0); i <= a; ++i)
		for (hu j(0); j <= b; ++j)
			ans += f[n][i][j];
	printf("%llu\n", ans);
	return 0;
}
```

---

## 作者：zzy0618 (赞：12)

由于之前的题解用无符号长整型在新的数据无法通过且高精过于繁琐，所以本题解既是解题又是对之前题解使用 __int128 完善。

### 题目大意

有黑白两种**除颜色外其他全部相同**的球（信号），将 $a$ 个黑球和 $b$ 个白球放入 $n$ 个**不同**的袋子，求方案总数。

### 解题思路

因为两种信号互相不影响，所以只需要分别用隔板法计算 $a$ 与 $b$ 个球存储在 $n$ 个存储器中的答案，再将两种情况相乘。

如何处理不用全部储存的情况？我们可以再多放一块区域，用来存储没有放在前 $n$ 块内的信号，现在的情况就变成将 $a$ 个信号放入 $n+1$ 块。

也就是将 $n$ 个板插入 $a + n + 1 - 1$ 也就是 $ a + n $ 个空，方法数为：

#### $C_{a+n}^{n}$

同样算上白球最终结果就是

#### $C_{a+n}^{n}\times C_{b+n}^{n}$


### 最终代码

除了输入与输出要从新定义，其他用法 __int128 用法都一样

```cpp
#include<bits/stdc++.h>
using namespace std;
inline __int128 read() {
    __int128 x = 0, f = 1; char ch = getchar();
    while (ch > '9' || ch < '0') { if (ch == '-')f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
inline void write(__int128 x) {
    if (x < 0) { putchar('-'); x = -x; }
    if (x > 9)write(x / 10);
    putchar(x % 10 + '0');
}//前面都是读入和输出 
__int128 C(__int128 r, __int128 n) {//计算组合 
    __int128 ans = 1;
    for (__int128 i = 1; i <= r; ++i) {
        ans *= n - i + 1;
        ans /= i;
    }
    return ans;
}
signed main() {
    __int128 n, a, b;
    n = read(); a = read(); b = read();
    write(C(n,a + n) * C(n,b + n));//代入公式 
    return 0;
}
```



---

## 作者：allenchoi (赞：2)

### update(2023.1.27)：
原来的代码有问题（数组没开够）。
### 前言：  
这题要高精度，unsigned long long 也会被卡，所以本题另外三篇题解都有 BUG！！！  
### 科技：
~~简单~~DP，高精度
### 题意：  
有 $n$ 个存储区，$a$ 个 $0$，$b$ 个 $1$（每个 $0,1$ 没有差别），无限制地放入存储区内（可以不全部放完），求方案数。  
### 解法：  
设 $dp_{i,j,k}$ 为在前 $i$ 个存储区放 $j$ 个 $0$，$k$ 个 $1$ 的方案数。初始化 $dp_{0,0,0}=1$，考虑转移，可以枚举在前 $i-1$ 个存储区内放了多少个 $0,1$，于是我们就得到了一个转移方程：  
$dp_{i,j,k}=\sum_{a=0}^{j}\sum_{b=0}^{k}dp_{i-1,a,b}$  
最后答案统计也很简单，枚举总共放了多少个 $0,1$：  
$\sum_{i=0}^{a}\sum_{j=0}^{b}dp_{n,a,b}$    
### 代码：  
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int n,a,b;
struct Num{int l,a[40];} ans,dp[55][55][55];
Num operator + (Num x,Num y)
{
	Num ret;
	ret.l = max(x.l,y.l);
	memset(ret.a,0,sizeof(ret.a));
        //一定要清零！！！
	for(int i = 1;i <= ret.l;i++)
	{
		ret.a[i] += x.a[i] + y.a[i];
		ret.a[i + 1] += ret.a[i] / 10;
		ret.a[i] %= 10;
	}
	if(ret.a[ret.l + 1]) ret.l++;
	return ret;
}
void print(Num x)
{
	for(int i = x.l;i >= 1;i--) printf("%d",x.a[i]);
	printf("\n");
}
int main()
{
	scanf("%d%d%d",&n,&a,&b);
	dp[0][0][0].l = dp[0][0][0].a[1] = 1;
	for(int i = 1;i <= n;i++)
		for(int j = 0;j <= a;j++)
			for(int k = 0;k <= b;k++)
				for(int s1 = 0;s1 <= j;s1++)
					for(int s2 = 0;s2 <= k;s2++)
						dp[i][j][k] = dp[i][j][k] + dp[i - 1][s1][s2];
	for(int i = 0;i <= a;i++) for(int j = 0;j <= b;j++) ans = ans + dp[n][i][j];
	print(ans);
	return 0;
}
```  
注意高精度即可 AC ，个人建议重载操作符，这样用的时候方便。  
~~马上就复课力，不能再摸鱼上课水题解力，求审核过 QwQ~~

---


# 神秘数字

## 题目背景

在公元XXXX年，侦探小明收到了组织的神秘信息，在Y市的某个地方有一道神秘的门。小明到达了那个门后，发现门上有一行字：“这个门需要密码才能解锁。”小明左找右找，终于找到了一张字条：“现在给你n个数，请你求出这n个数里面，有多少个连续的数的平均数大于某个给定的数M？注意：这个数可能会很大，请输出这个数对92084931取模的结果。最终的结果即是这个门的密码。”小明苦思冥想了半天，但始终找不到答案。于是他来求助于你。请你帮他解决这个问题。由于小明十分着急，他最多只能等1秒。


## 题目描述

给定n个数，请你帮助小明求出里面有多少个连续的数的平均数大于给定的某个数M.并将这个方案数输出。注意：这个数可能会很大，所以请输出这个数对92084931取模的结果。


## 说明/提示

【样例解释】

①对于这4个数，问题的解有{5}，{4}，{5,4}，{1,5,4}，{5,4,2}共5组。

②对于这4个数，问题的解有{5}，{7}，{2,7}，{7,3}，{5,2,7}，{5,2,7,3}共6组。

【数据规模】

对于10%的数据，1＜n≤10.

对于30%的数据，1＜n≤1000.

对于50%的数据，1＜n≤30000.

对于100%的数据，1＜n≤200000，1＜M≤3000，每个数均为正整数且不大于5000.


## 样例 #1

### 输入

```
4 3
1 5 4 2```

### 输出

```
5```

## 样例 #2

### 输入

```
4 4
5 2 7 3```

### 输出

```
6```

# 题解

## 作者：cabasky (赞：51)

思考当前问题

我们得到数列a，要求多少个区间的和平均数大于m

那么我们**把数列a每一个数减去m** 得到数列A

那么如果数列A中某个区间的和如果大于0，原数列a中这个区间的平均数就大于m（这个还是好想的，平均数大于m，那么和就大于m乘以区间长度）

问题转化为求当前数列A中有多少个区间的和大于0

继续思考

我们求出A数列的**前缀和**数列S

那么一个区间A[i]...A[j](i<=j)的和大于0的要求就是

**S[j]-S[i-1]>0**

也就是

**S[j]>s[i-1]**

至此，问题已经非常清晰了

问题转化为求S[j]之前有多少个S[i]>S[j],把相对于每一个S[j]的答案个数相加就是ans

也就是求前缀和数列S的**逆序对**

注意 要追加S[0]=0,因为这个代表从开头开始的一个区间也要计算(否则会少算一些答案)

下面贴出归并排序求逆序对的代码 期望复杂度O(nlogn)

楼主上大学了 多年没上洛谷 看到这题评论区里有讨论关于顺逆序的问题
楼主的意思是 ”顺“ “逆” 是对于这个“序”而言的 可以认为是升序的顺序对，也可以理解是降序的逆序对

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
using namespace std;
int a[200010],sum[200010],ans,temp[200010];
//sum为前缀和
int n,m;
int merge(int l,int mid,int r){
    int p1=l,p2=mid+1,k=l-1;
    while(p1<=mid&&p2<=r){
        if(sum[p1]<sum[p2]){
            ans+=(mid-p1+1);
            ans%=92084931;
            temp[++k]=sum[p2];
            p2++;
        }
        else if(sum[p1]>=sum[p2]){
            temp[++k]=sum[p1];
            p1++;
        }
    }
    while(p1<=mid) temp[++k]=sum[p1++];
    while(p2<=r) temp[++k]=sum[p2++];
    for(int i=l;i<=r;i++)
        sum[i]=temp[i];
}
void mergesort(int l,int r){
    if(l<r){
        int mid=(l+r)>>1;
        mergesort(l,mid);
        mergesort(mid+1,r);
        merge(l,mid,r);
    }
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        a[i]-=m;
        sum[i]=sum[i-1]+a[i];
    }
    mergesort(0,n);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：SCKer (赞：21)

本题分析楼上已经讲的十分详细，这里就不多讲了。这里我说一些注意点( 给用 树状数组 的童鞋们 )：

1.数据有非正数，所以需要重构数据（我用排序的顺序，重复算同一个数）

2.由于 顺序对  ，所以 减去 之前等于 x 的次数，包括这个x

3.由于公式为  S[ j  ]> S[ i-1 ] ，故要计算 【1，j】 的话 就要用 S[ j ] - S[ 0 ]


献上我的代码，有点丑（带文件输入输出）：








    
    
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define Open(s) freopen(s".in","r",stdin); freopen(s".out","w",stdout);
#define Close fclose(stdin); fclose(stdout);
#define lowbit(x) x&(-x)
#define mo 92084931
using namespace std;
int n,M;
int ans;
int maxb;         // 上界
int a[200001];  //读入数字
int b[200001];  //树状数组
int c[200001];  //判重
void input(int x)
{
    ++c[x];
    if(c[x]>=mo) c[x]-=mo;
    for(;x<=maxb;x+=lowbit(x))
    {
        ++b[x];
        if(b[x]>=mo) b[x]-=mo;
    }
}
int getsum(int x)
{
    int sum=-1*(c[x]);
    for(;x;x-=lowbit(x))
    {
        sum+=b[x];
        if(sum>=mo) sum-=mo;
    }
    return sum;
}
bool cmp(int x,int y)
{
    return a[x]<a[y];
}
int main()
{
    Open("smsz");
    scanf("%d %d", &n, &M);
    for(int i=1;i<=n;++i)
    {
        int x;
        scanf("%d",&x);
        a[i]=a[i-1]+x-M;
        c[i]=i;
    }
    sort(c,c+n+1,cmp);
    for(int i=0;i<=n;++i)
    {
        for(int j=i+1;j<=n && a[c[i]]==a[c[j]];++j)
            b[c[j]]=-1;        // 暂时借用 b 数组，不是树状数组
        a[c[i]]=a[c[i-1]]+1;
        if(b[c[i]]<0)
        {
            a[c[i]]+=b[c[i]];
            b[c[i]]=0;
        }
        if(a[c[i]]>maxb) maxb=a[c[i]];
    }
    memset(c,0,sizeof(c));
    for(int i=0;i<=n;++i)
    {
        input(a[i]);
        ans+=getsum(a[i]);
        for(;ans>=mo;ans-=mo);   
    }
    printf("%d",ans);
    Close;
    return 0;
}

```

---

## 作者：Zachary_Cloud (赞：6)

## Main~Idea

有一个长为 $n$ 的数列，求其中有多少**连续**的一段数使其**平均数**大于 $m$。

## Solution

因为要求是连续的一段数且其平均数大于 $m$，我们可以用一个类似于前缀和的数组记录当前和与平均数恰好等于 $m$ 的和的差。

然后枚举序列最后一个数 $i$，求在其前面的前缀和数组有多少个数小于自身（使这两个作差后大于 $0$，也就是两个数之间的平均数大于 $m$），求和即可。

细看这操作，我们立刻可以想到一种可爱的数据结构——**权值线段树**！

因为数据有些大，我们需要进行离散化。

分析完毕，完结撒花！

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)
#define ls (rt << 1)
#define rs (rt << 1 | 1)
#define mid (l + r >> 1)
#define ri register int
#define ll long long
#define N 200010
#define mod 92084931

ll n, m, a[N], b[N], tr[N << 3], size, ans;

inline void change(ll rt, ll l, ll r, ll p, ll cnt) {
	tr[rt] += cnt;
	if (l == r) return;
	if (p <= mid) change(ls, l, mid, p, cnt);
	else change(rs, mid + 1, r, p, cnt);
} //权值线段树基本操作——增删数字
inline ll query(ll rt, ll l, ll r, ll e) {
	if (l > e) return 0;
	if (r <= e) return tr[rt];
	return query(ls, l, mid, e) + query(rs, mid + 1, r, e);
} //查找有多少个数小于等于 e

int main() {
	IOS;
	cin >> n >> m;
	for (ri i = 1; i <= n; ++i) cin >> a[i], b[i] = b[i - 1] + a[i] - m, a[i] = b[i];
	sort(b + 1, b + n + 1);
	size = unique(b + 1, b + n + 1) - b - 1; //离散化去重
	for (ri i = 1; i <= n; ++i) {
		if (a[i] > 0) ans++; //注意：如果从 1 到 i 的平均数大于 m，得另外统计
		(ans += (query(1, 1, size, lower_bound(b + 1, b + size + 1, a[i]) - b - 1))) %= mod; //上文的查找
		change(1, 1, size, lower_bound(b + 1, b + size + 1, a[i]) - b, 1); //增加
	}
	cout << ans;
	return 0;
}
```


---

## 作者：郑翰 (赞：5)

楼下已经讲得蛮清楚了，稍微再补充一下。

题目要求: (a1+a2+a3+...+an) / n > m

稍微变形一下：

a1+a2+a3+...+an > m\*n

(a1-m)+(a2-m)+(a1-m)+...+(an-m) > 0

也就是说，把给出的数列中所有的数都减去m,问题就转化成了求区间加和大于0的方案数

容易想到造前缀和，对于右端点i，在之前找sum[i]-sum[j]>0的左端点j ( [j+1,i]加和大于0 )

每次都在之前找有几个数比它小的，可以用树状数组nlogn实现，归并排序求逆序对也不错。

贴上极丑代码，大牛见笑：


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=200005,MOD=92084931;
int n,m,sum[maxn],bit[maxn],c[maxn],ans;
int lowbit(int x){ return x&(-x); }
void Updata(int x){
    for(;x<=c[0];x+=lowbit(x)) bit[x]=(bit[x]+1)%MOD;
}
int Query(int x){
    int res=0;
    for(;x;x-=lowbit(x)) res=(res+bit[x])%MOD;
    return res;
}
int _find(int x){
    int L=1,R=c[0];
    while(L<=R){
        int mid=L+(R-L)/2;
        if(c[mid]==x) return mid;
        if(c[mid]<x) L=mid+1;
                else R=mid-1;
    }
}
int main(){
    scanf("%d%d",&n,&m);
    c[c[0]=1]=0;
    for(int i=1;i<=n;i++){
        int x; scanf("%d",&x);
        sum[i]=sum[i-1]+x-m; //每个数都减去m,并造前缀和 
        c[++c[0]]=sum[i];
    }
    sort(c+1,c+1+c[0]);
    c[0]=unique(c+1,c+1+c[0])-(c+1); //c数组是用来离散sum的 
    Updata(_find(sum[0]));
    for(int i=1;i<=n;i++){
        ans=(ans+Query(_find(sum[i])-1))%MOD;
        Updata(_find(sum[i]));
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：_edge_ (赞：4)

CSP 之前先来氵一题。

首先这题目一眼可以看出一个 $O(n^2)$ 的暴力。

卡常卡的好可以过 $50\%$ 的数据。

比赛的时候如果看不出正解先拿部分分：

这里有一个小小地技巧，就是说如果要求一段区间的平均数是否大于 $m$，那么可以先把这一段区间的数全部减去 $m$。

然后可以预处理前缀和，写出一个暴力程序：

```cpp
#include <iostream>
#include <cstdio>
#define int long long
using namespace std;
const int INF=2e5+5;
const int Mod=92084931;
int n,m,a[INF],sum[INF],ans;
signed main()
{
	scanf("%lld %lld",&n,&m);
	for (int i=1;i<=n;i++) scanf("%lld",&a[i]),a[i]-=m,sum[i]=sum[i-1]+a[i];
	for (int i=1;i<=n;i++) {
		for (int j=i;j<=n;j++)
			if (sum[j]-sum[j-i]>0) ans=(ans+1)%Mod;
	}//如果一段区间和大于 0 那么肯定平均值大于 m。
	cout<<ans<<"\n";
	return 0;
}
//没加优化，实测 45 分。
```

然而作者这里居然神奇的敲了一个二分。。。

这题目按我的方法没可以证明单调性的地方。

所以二分显然不行。

那么化简一下上面的 `sum[j]-sum[j-i]>0` 就等于 `sum[j]>sum[j-i]`。

欸，这下可以发现，对于答案的贡献只有：

注：$sum_i$ 表示 $\sum\limits_{j=1}^i$ 。

$i<j$ 并且 $sum_i<sum_j$

这一种情况。

那么把这一个模型转化一下能想到什么？

**逆序对？**

但很可惜这题目没有$i<j$ 并且 $sum_i>sum_j$的性质，不过如果能想到逆序对那不妨接着想下去？

作者擅长 pj 的算法，所以想到了归并。

code:

```cpp
#include <iostream>
#include <cstdio>
#define int long long
using namespace std;
const int INF=2e5+5;
const int Mod=92084931;
int n,m,a[INF],b[INF],sum[INF],ans;
void qsort(int l,int r) {
	if (l==r) return ;
	int Mid=(l+r)>>1;
	qsort(l,Mid);qsort(Mid+1,r);
	int ll=l,rr=Mid+1,o=l;
	while (ll<=Mid && rr<=r) {
		if (sum[ll]<sum[rr]) {
			ans+=r-rr+1;if (ans>Mod) ans-=Mod;
			b[o++]=sum[ll++];
        //对于一个 sum[ll]<sum[rr] 的情况
        //对答案的贡献是 r-rr+1 解释成语言就是当前 sum[ll] 这个数小于 sum[rr] 必然也小于 sum[rr+1] ,sum[rr+2],sum[rr+3] ... sum[r] 所以加上 r-rr+1。
		}
		else b[o++]=sum[rr++];
	}
	while (ll<=Mid) b[o++]=sum[ll++];
	while (rr<=r) b[o++]=sum[rr++];
	for (int i=l;i<=r;i++) sum[i]=b[i];
	return ;
}
signed main()
{
	scanf("%lld %lld",&n,&m);
	for (int i=1;i<=n;i++) scanf("%lld",&a[i]),a[i]-=m,sum[i]=sum[i-1]+a[i];
	qsort(0,n); //从 0 开始，不要忘记选择 sum[1]~sum[i] 的情况。
//	for (int i=1;i<=n;i++) cout<<sum[i]<<" ";
	cout<<ans<<"\n";
	return 0;
}
```

作者比较菜，所以有问题还请指出。

**谢谢观赏！**

---

## 作者：Light_az (赞：2)


### 前置知识：[逆序对](https://www.luogu.com.cn/problem/P1908)

这道题肯定是不可以打暴力的，因为数据太大了，首先我们要知道如何判断平均数，我采用的方法是：将每个数减去平均值 $M$ ，如果减后的值大于零，说明这个数大于 $M$ ，再做一个前缀和数组，对于前缀和数组 $ a_i $ ~ $ a_j $ 这个序列来说，如果它的累加值大于零，说明这个序列的平均值也大于 $M$ ，那么如何知道有多少个序列的平均值大于零呢？我们想一想，一个序列的总和是由 $ a_j $ 减去 $ a_i $ 决定的，那么想要它的值大于零， $a_j$ 一定要大于 $a_i$ ，所以这道题我们解决完前缀和，再套上逆序对模板，这道题就完美解决了。还有，最后特判是否有只有一个数的序列的值是大于 $M$ 的，下面是完整代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt=0,t=0,k,x,y;
long long ans=0;
int a[200001],b[200001],c[200001];
void sort1(int l,int r){//逆序对模板 
	if(l==r)
		return ;
	int mid=(l+r)/2;//归并 
	sort1(l,mid);
	sort1(mid+1,r);
	cnt=l-1;
	int i=l,j=mid+1;
	while(i<=mid&&j<=r){//求逆序对 
		if(a[i]>=a[j])
			b[++cnt]=a[i++];
		else{
			b[++cnt]=a[j++];
			ans+=mid-i+1;//记录逆序对 
			ans%=92084931;
		}
	}
	while(i<=mid) b[++cnt]=a[i++];//排序 
	while(j<=r) b[++cnt]=a[j++];
	for(int i=l;i<=r;i++){//更新排序后的值 
		a[i]=b[i];
	}
	return ;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>c[i];
		c[i]-=m;//减去平均值 
		a[i]=a[i-1]+c[i];//前缀和 
	}
	for(int i=1;i<=n;i++)//特判一个数字的序列 
		if(a[i]>0)
			ans++;
	sort1(1,n);//归并 
	cout<<ans%92084931;//输出 
	return 0;
}
```


---

## 作者：luckydrawbox (赞：2)

[$\text{Link}$](https://www.luogu.com.cn/problem/P2804)

## 福利

[双倍经验](https://www.luogu.com.cn/problem/P2717)

## 题意

一个长度为 $n$ 的区间 $a_{1\sim n}$，求其中有多少个**连续**子序列的平均数**大于** $m$？答案对 $92084931$ 取模。

## 分析

首先我们知道：对于一个区间，如果每个数都减去 $m$，那么这个区间的平均数就会减少 $m$；同时，它的任意连续子区间的平均数都会减少 $m$。

既然这样，我们只需要令整个区间都减少 $m$，于是问题就转化成了：

>一个长度为 $n$ 的区间 $a_{1\sim n}$，求其中有多少个**连续**子序列的平均数**大于** $0$？答案对 $92084931$ 取模。

既然一个连续子区间的平均数大于 $0$ ，那么这个连续子区间的和也大于 $0$，于是问题又简化了：

>一个长度为 $n$ 的区间 $a_{1\sim n}$，求其中有多少个**连续**子序列的和**大于** $0$？答案对 $92084931$ 取模。

求和部分显然可以用[前缀和](https://oi-wiki.org/basic/prefix-sum/)计算 $s_i=\sum_{j=1}^i a_j=s_{i-1}+a_i$ 来解决（特别地，$s_0=0$），一个区间和 $[i,j]$ 可以转化为 $s_j-s_{i-1}$，问题再次变形：

>一个长度为 $n+1$ 的区间 $s_{0\sim n}$，求其中有多少对 $i,j(1\le i<j\le n)$ 使 $s_j-s_{i-1}>0$？答案对 $92084931$ 取模。

$s_j-s_{i-1}>0$ 显然相当于 $s_{i-1}<s_j$，所以其实我们要求的就是**顺序对**（就是把[逆序对](https://www.luogu.com.cn/problem/P1908)反过来求）。

求顺序对的方法很多，这里提供一个**值域分块**做法，貌似比权值线段树好写一点。

## 代码

时间复杂度 $O(n\sqrt n)$，空间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
    long long x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=2e5+10;
const ll mod=92084931;
int n;
ll m,a[N],s[500],len,v[N],sum;
int discrete(int n,ll *a){
    int b[N];
    for(int i=1;i<=n;i++)
        b[i]=a[i];
    sort(b+1,b+n+1);
    int tot=unique(b+1,b+n+1)-(b+1);
    for(int i=1;i<=n;i++)
        a[i]=lower_bound(b+1,b+tot+1,a[i])-b;
    return tot;
}
ll ask(int w){
	int k=w/len;
	ll ans=0;
	for(int i=0;i<k;i++)
		ans=(ans+s[i])%mod;
	for(int i=k*len;i<w;i++)
		ans=(ans+v[i])%mod;
	return ans;
}
void add(int w){
	v[w]++;
	s[w/len]++;
}
int main(){
	n=read()+1;m=read();//把下标从2开始统计，这样方面在前面插入0 
	for(int i=2;i<=n;i++)
		a[i]=read()-m+a[i-1];//把a数组直接当前缀和用 
	int tot=discrete(n,a);//离散化 
	len=sqrt(tot);
	add(a[1]);//插入0 
	for(int i=2;i<=n;i++){
		sum=(sum+ask(a[i]))%mod;
		add(a[i]);
	}
	write(sum);
    return 0;
}
```


---

## 作者：waOooo (赞：2)

# 这道题跟完全没必要扯到逆序对上面；

总体思路和楼上的一样；

但是就是后面的那几句话，让我十分疑惑，

就是这几句

“ 至此，问题已经非常清晰了

问题转化为求S[j]之前有多少个S[i]>S[j],把相对于每一个S[j]的答案个数相加就是ans

也就是求前缀和数列S的逆序对  ”

这明明是顺序对，为啥要转为逆序对呢？？？

完全可以用权值线段树求解啊；

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pa pair<int,int>
#define lson k<<1
#define rson k<<1|1
#define N 500100
#define M 200010
using namespace std;
const LL mod=92084931;
int n,m;
int z;
LL sum;
int s[M];//差值前缀和 
int a[M],b[M];
struct Node{
	int l,r,w;
}tree[M<<2];
inline void build(int k,int ll,int rr){
	tree[k].w=0,tree[k].l=ll,tree[k].r=rr;
	if(ll==rr) return;
	int mid=(ll+rr)>>1;
	build(lson,ll,mid);
	build(rson,mid+1,rr);
}
inline int ask(int k){
	if(tree[k].l==tree[k].r) return tree[k].w;
	int s=0;
	int mid=(tree[k].l+tree[k].r)>>1;
	if(z<=mid) s+=ask(lson);//搜索左子树
	else s+=ask(rson)+tree[lson].w;//搜索右子树，左子树直接相加 
	return s; 
}
inline void add(int k){
	if(tree[k].l==tree[k].r){
		tree[k].w++;
		return;
	}
	int mid=(tree[k].l+tree[k].r)>>1;
	if(z<=mid) add(lson);
	else add(rson);
	tree[k].w=tree[lson].w+tree[rson].w;
}
int main(){
	scanf("%d%d",&n,&m);
	build(1,1,n);
	int x; 
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		s[i]=x-m;
		s[i]+=s[i-1];	
		a[i]=s[i];
		b[i]=s[i];
	}
	sort(b+1,b+n+1);
	int len=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++){//离散化，有负数； 
	    int pos=lower_bound(b+1,b+len+1,s[i])-b;
	    s[i]=pos;
	}
	for(int i=1;i<=n;i++){
		z=s[i]-1;
		sum=sum+(LL)ask(1);//查找小于等于s[i]-1的数;
		if(a[i]>0) sum++;//相当于1到i的平均数大于m 
		sum%=mod;
		z=s[i];
		add(1);
	}
	cout<<sum<<endl;
	return 0;
}
```


---

## 作者：JackMerryYoung (赞：1)

# 前言

二分题单中的不是特别与二分沾边的题目。

其实就一归并排序求顺序对。不知道为什么还有人写权值线段树，麻烦死了。

# 正文

关于区间平均数的问题，最好解决工具是什么？

肯定是每一个数都减去平均数啊。

于是我们想到只要每一个数都减去平均数后的新区间的和大于零，那么它就合法了。

尝试用前缀和维护新的区间子段和，那么当：

$$
sum_r - sum_{l - 1} > 0
$$

区间 $[l, r]$ 就是合法的。

移项可得：

$$
sum_r > sum_{l - 1}
$$

那么这答案不就是顺序对个数吗？

问题就变得就很简单辣。复杂度 $\mathcal{O}(N \log_2 N)$, 可以通过此题。

# 代码

``` cpp
#include <bits/stdc++.h>
#define MOD (92084931)
using namespace std;

int N, M, ans;
int arr[200005], sum[200005], tmp[200005];

void merge(int l, int r)
{
    int lp, rp, p;
    int mid = (l + r) >> 1;
    lp = l, rp = mid + 1, p = l - 1;
    while(lp <= mid && rp <= r)
    {
        if(sum[lp] < sum[rp])
            ans = (ans + (mid - lp + 1)) % MOD, 
            tmp[++ p] = sum[rp ++];
        if(sum[lp] >= sum[rp])
            tmp[++ p] = sum[lp ++];
    }

    while(lp <= mid) tmp[++ p] = sum[lp ++];
    while( rp <= r ) tmp[++ p] = sum[rp ++];
    for(int i = l; i <= r; ++ i) 
        sum[i] = tmp[i];
}

void merge_sort(int l, int r)
{
    if(l < r)
    {
        int mid = (l + r) >> 1;
        merge_sort(   l   , mid);
        merge_sort(mid + 1,  r );
        merge(l, r);
    }
}

int main()
{
    cin >> N >> M;
    for(int i = 1; i <= N; ++ i)
        cin >> arr[i], arr[i] -= M, sum[i] = sum[i - 1] + arr[i];

    merge_sort(0, N); // Caution: l - 1!!!!
    cout << ans << endl;
    return 0;
}
```

# 后言

关于区间平均数的问题，每一个数都减去平均数的做法雀食很实用。

---

## 作者：StupidSeven (赞：0)

## Subject
[题目传送门](https://www.luogu.com.cn/problem/P2804)

## Analysis
题目涉及到区间和，我们考虑使用前缀和。

题目要求的是有多少个区间 $[L,R]$ 满足 $\dfrac{sum[R]-sum[L-1]}{R-L+1}>M$，也就是 $sum[R]-sum[L-1]>(R-L+1)\times M$。

将每一个数都减去 $M$，前缀和相应地变化，就变成了 $sum[R]-sum[L-1]>0$，即 $S[L-1]<sum[R]$，就变成了对于前缀和数组求顺序对。

我们都会求逆序对。对比顺序对和逆序对的条件，我们可以发现将原序列倒过来，求逆序对，就是原序列的顺序对。用树状数组实现，复杂度 $O(n \log n)$。

注意，这里需要将 $sum[0]$ 加进去，才能求出包含 $a_1$ 的的区间和。

## Code
```cpp
#include<cmath>
#include<vector>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int M=2e5+10;
const int inf=0x3f3f3f3f;
const int Mod=92084931;
inline int Read(void){
    int s=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){s=s*10+c-48;c=getchar();}
    return s*f;    
}
struct Node{
    int sum,idx;
    bool operator<(const Node &x)const{
        if(sum==x.sum) return idx<x.idx;
        return sum<x.sum;
    }
}num[M];
int n,x,m,ans;
int sum[M];
int lowbit(int x){
    return x&(-x);
}
void Add(int x,int val){
    for(int i=x;i<=n+1;i+=lowbit(i))
        sum[i]=(sum[i]+val)%Mod;
    return;
}
int Query(int x){
    int ans=0;
    for(int i=x;i;i-=lowbit(i))
        ans=(ans+sum[i])%Mod;
    return ans;
}
signed main(void){
    n=Read();m=Read();
    for(int i=2;i<=n+1;i++){
        x=Read();
        num[i].sum=num[i-1].sum+x-m;
    }
    for(int i=1;i<=n+1;i++)
        num[i].idx=n-i+2;
    sort(num+1,num+2+n);
    for(int i=1;i<=n+1;i++){
        Add(num[i].idx,1);
        ans=(ans+i-Query(num[i].idx))%Mod;
    }
    printf("%d\n",ans);
    return 0;
}
```

---


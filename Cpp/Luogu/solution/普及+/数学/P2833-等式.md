# 等式

## 题目背景

ZKC 有一天突发奇想，望着天空想出一道很好的问题，但是绞尽脑汁又不会做，所以请你来帮他解决。


## 题目描述

给出 $a,b,c,x_1,x_2,y_1,y_2$，求满足 $ax+by+c=0$，且 $x\in [x_1,x_2]$，$y\in [y_1,y_2]$ 的整数解有多少对。


## 说明/提示

对于 $30\%$ 的数据，$a,b,c,x_1,x_2,y_1,y_2$ 的绝对值不超过 $1000$。

对于 $100\%$ 的数据，$a,b,c,x_1,x_2,y_1,y_2$ 的绝对值不超过 $10^8$。


## 样例 #1

### 输入

```
1 1 -3 0 4 0 4```

### 输出

```
4```

# 题解

## 作者：saxiy (赞：16)

啊。。。本蒟蒻de了一下午的bug终于A了。。。

#### 关于拓展欧几里得：

我们看到$ax+by=c$这种形式的表达式就会想起扩展欧几里得（如果你不会的话建议先A了[P1082 同余方程](https://www.luogu.org/problem/P1082)这道题再来），这里介绍一种简单的写法

```cpp
void exgcd(ll a, ll b, ll &x, ll &y, ll &gcd) {
	if(!b) { x = 1; y = 0; gcd = a; return; }
	exgcd(b, a % b, y, x, gcd); y -= a / b * x;
}
```

很短吧，也很好理解，因为交换$a,b$的同时我们交换了$x,y$，所以原来辗转的方程被我们用引用简单地化解了。

#### 题目分析：

这道题让我们求$ax+by=-c$在$x,y$一定限制下的解的个数，利用$exgcd$我们求出了一个特解$ax_{0}+by_{0}=\gcd(a,b)$，既然原来方程右边是$-c$，那我们两边都乘上$\frac{-c}{\gcd(a,b)}$就行了，即$x_{0}=x_{0}\times \frac{-c}{\gcd(a,b)},y_{0}=y_{0}\times \frac{-c}{\gcd(a,b)}$，然后我们现在有：
$$ax_{0}+by_{0}=-c$$
我们怎么得到原方程的通解呢？

先考虑在$a>0,b>0$的情况下，$x$在增加，$y$必然会减小，要让$x$增加一个整数的时候，$y$刚好也需要减小一个整数，很明显，当$x$增加$b$时，$y$减小$a$,即：
$$a(x_{0}+kb)+b(y_{0}-ka)=-c$$

但这不是最小的我们可以增加的那对整数，明显$\frac{a}{\gcd(a,b)},\frac{b}{\gcd(a,b)}$是那对最小的整数，而方程：
$$a(x_{0}+k\frac{b}{\gcd(a,b)})+b(y_{0}-k\frac{a}{\gcd(a,b)})=-c$$

显然成立。所以我们原方程的解即为：
$$\begin{cases}x=x_{0}+k\frac{b}{\gcd(a,b)}\\y=y_{0}-k\frac{a}{\gcd(a,b)}\end{cases}$$

现在我们来考虑$a<0,b<0$的情况，将方程两边取反即可。

然后就是$a<0\text{ xor }b<0$的情况，比如$a<0$，我们可以设$x^\prime=-x$，那值域也要相应地取反，即
$$\begin{cases}x1^\prime=-x2\\x2^\prime=-x1\end{cases}$$

然后$a=-a$，又转变成$a>0,b>0$的情况了，$b<0$时同理。

最后我们解出$k$的取值范围，每一个$k\in Z$都对应着一对可行解，输出可行$k\in Z$的个数即可。

#### 最后是特殊情况的总结：

1. $x1>x2\text{或}y1>y2$ 时 $ans=0$
2. $a=0 \text{且} b=0$ 时：
> - $c=0$ 答案为$x,y$所有的组合（乘法原理）
> - $c\neq 0 \Rightarrow ans=0$
3. $a=0$ 时：
> - $y1 \leq y_{0} \leq y2 \Rightarrow ans=\text{x的所有可能}$
> - 否则 $ans=0$
4. $b=0$ 时：与上同理
5. $c\bmod\gcd(a,b)\ne 0 \Rightarrow ans=0$
6. $k$的解集为$\emptyset$ 时 $ans=0$

#### 代码实现(50ms)：

```cpp
#pragma GCC optimize("fast-math")
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll a, b, c, _x1, _x2, _y1, _y2;

void exgcd(ll a, ll b, ll &x, ll &y, ll &gcd) {
	if(!b) { x = 1; y = 0; gcd = a; return; }
	exgcd(b, a % b, y, x, gcd); y -= a / b * x;
}

void ans(ll val) { printf("％lld", val); exit(1); }

int main() {
	scanf("％lld％lld％lld％lld％lld％lld％lld",
		&a, &b, &c, &_x1, &_x2, &_y1, &_y2);
	if(_x1 > _x2 || _y1 > _y2) ans(0);
	c = -c;//移项
	if(!a && !b) {
		if(c) ans(0);
		else ans((_x2 - _x1 + 1) * (_y2 - _y1 + 1));
	}
	if(a < 0 && b < 0) a = -a, b = -b, c = -c;
	else if(a < 0) swap(_x1, _x2), _x1 = -_x1, _x2 = -_x2, a = -a;
	else if(b < 0) swap(_y1, _y2), _y1 = -_y1, _y2 = -_y2, b = -b;
	ll x, y, gcd;
	exgcd(a, b, x, y, gcd);
	if(c % gcd) ans(0);
	c /= gcd; x *= c; y *= c;
	if(!a) (_y1 <= y && y <= _y2) ? ans(_x2 - _x1 + 1) : ans(0);
	if(!b) (_x1 <= x && x <= _x2) ? ans(_y2 - _y1 + 1) : ans(0);
	double l = double(gcd * (_x1 - x)) / b;//x范围定界
	double r = double(gcd * (_x2 - x)) / b;
	l = fmax(l, double(gcd * (y - _y2)) / a);//y范围定界
	r = fmin(r, double(gcd * (y - _y1)) / a);
	int ansl = ceil(l), ansr = floor(r);//注意边界取整
	ans(ansr >= ansl ? ansr - ansl + 1 : 0);
	return 0;
}
```
~~网上复制粘贴谁不会啊~~

---

## 作者：Augen_stern (赞：2)

### Part 1: 算法分析

看着这简洁明了的题目，暴力做法已经浮上心头，

现实证明直接暴力是可以过的（即使不开 $O_2$）。

### Part 2: 代码实现

为了方便计算，使 $x1<x2$，$y1<y2$;

```cpp
	if(X1>X2) swap(X1,X2);
	if(Y1>Y2) swap(Y1,Y2);
```


1，第一种特殊情况：$a=b=0$;

此时，若 $c=0$ 则 $a$ 和 $b$ 可以是满足其闭区间的任意值，由乘法原理可以求出答案为 $(x2-x1+1) \times (y2-y1+1)$；

否则，答案为 0，原方程无解。

```cpp
	if(a==0&&b==0) {
		if(c==0) printf("%lld\n",(X2-X1+1)*(Y2-	Y1+1));
		else printf("0\n");
		return 0;
	}
```


2，第二种特殊情况：$a=0$ 并且 $b \neq 0$；

此时，$y=-c \div b$;

这时候如果 $y$ 在属于它的已知闭区间内，则答案为 1；

否则答案为 0，无解。

```cpp
	if(a==0&&b!=0) {
		long long y;
		if(abs(c)%b==0) {
			y=-c/b;
			if(y>=Y1&&y<=Y2) printf("1\n");
			else printf("0\n");
		} else printf("0\n");
		return 0;
	}
```


3，第三种特殊情况：$b=0$ 并且 $a \neq 0$；

此时，$x=-c \div a$;

这时候如果 $x$ 在属于它的已知闭区间内，则答案为 1；

否则答案为 0，无解。

```cpp
	if(b==0&&a!=0) {
		long long x;
		if(abs(c)%a==0) {
			x=-c/a;
			if(x>=X1&&x<=X2) printf("1\n");
			else printf("0\n");
		} else printf("0\n");
		return 0;
	}
```


4，为了使暴力程序不炸开，在枚举 $x$ 的值和 $y$ 的值时取最少次数枚举;

```cpp
	long long A=X2-X1,B=Y2-Y1;
	if(A>B) for(long long i=Y1; i<=Y2; i++) {
			long long xx=-c-b*i;
			double x=xx/a;
			if(x<=X2&&x>=X1&&a*(long long)x+b*i+c==0) ans++;
		}
	else for(long long i=X1; i<=X2; i++) {
			long long yy=-c-a*i;
			double y=yy/b;
			if(y<=Y2&&y>=Y1&&a*i+b*(long long)y+c==0) ans++;
		}
```


### Part 3：CODE

完整代码走一波。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<math.h>
#include<algorithm>
#define INF 0x7fffffff/2
using namespace std;
long long a,b,c,X1,X2,Y1,Y2,ans=0;
int main () {
	scanf("%lld%lld%lld%lld%lld%lld%lld",&a,&b,&c,&X1,&X2,&Y1,&Y2);
	if(X1>X2) swap(X1,X2);
	if(Y1>Y2) swap(Y1,Y2); // 方便计算
	if(a==0&&b==0) {
		if(c==0) printf("%lld\n",(X2-X1+1)*(Y2-Y1+1));
		else printf("0\n");
		return 0; // 提前结束
	}
	if(a==0&&b!=0) {
		long long y;
		if(abs(c)%b==0) {
			y=-c/b;
			if(y>=Y1&&y<=Y2) printf("1\n");
			else printf("0\n");
		} else printf("0\n");
		return 0;
	}
	if(b==0&&a!=0) {
		long long x;
		if(abs(c)%a==0) {
			x=-c/a;
			if(x>=X1&&x<=X2) printf("1\n");
			else printf("0\n");
		} else printf("0\n");
		return 0;
	}
	long long A=X2-X1,B=Y2-Y1;
	if(A>B) for(long long i=Y1; i<=Y2; i++) {
			long long xx=-c-b*i;
			double x=xx/a;
			if(x<=X2&&x>=X1&&a*(long long)x+b*i+c==0) ans++; // 精度！！！
		}
	else for(long long i=X1; i<=X2; i++) {
			long long yy=-c-a*i;
			double y=yy/b;
			if(y<=Y2&&y>=Y1&&a*i+b*(long long)y+c==0) ans++;
		}
	printf("%lld\n",ans);
	return 0;
}
```

自给自足，丰衣足食！！！

2021.8.24 20:15 初稿成

---

## 作者：Tari (赞：2)

又因为调一道水题而浪费时间。。。不过**细节**太多了$qwq$，暴露出自己代码能力的不足$QAQ$


------------

设$d=gcd(a,b)$,这题不是显然先解出来特解,即解出

$\frac{a}{d}x_0+\frac{b}{d}y_0=d$，中的$x_0,y_0$

然后根据

$x=\frac{c}{d}x_0+k\frac{b}{d},y=\frac{c}{d}x_0-k\frac{a}{d},k \in Z$

来卡范围吗$qwq$

然后自己就兴致勃勃的调了一晚上,老是差一点。。。后来发现一个大细节，就是左右端点，左端点要向上取整，右端点要向下取整$qwq$,发现后又调了半天$qwq$

对了还有一堆特判。。。主要是判各种$0$的，什么$a=0,b=0,c=0$之类的。。。详见代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cctype>
#include<cstdlib>
#include<vector>
#include<queue>
#include<map>
#include<set>
#define ll long long
#define int ll
#define R register ll 
using namespace std;
namespace Fread {
	static char B[1<<15],*S=B,*D=B;
	#define getchar() (S==D&&(D=(S=B)+fread(B,1,1<<15,stdin),S==D)?EOF:*S++)
	inline int g() {
		R ret=0,fix=1; register char ch; while(!isdigit(ch=getchar())) fix=ch=='-'?-1:fix;
		do ret=ret*10+(ch^48); while(isdigit(ch=getchar())); return ret*fix;
	}
}using Fread::g;
inline void exgcd(ll a,ll b,ll& x,ll& y) {if(!b) {x=1,y=0; return ;} exgcd(b,a%b,y,x); y-=a/b*x;}
inline ll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}
int a,b,c,x1,x2,Y1,Y2; 
signed main() {
#ifdef JACK
	freopen("NOIPAK++.in","r",stdin);
#endif
	a=g(),b=g(),c=-g(),x1=g(),x2=g(),Y1=g(),Y2=g(); R d=gcd(a,b);
	if(a==0&&b==0) {
        if(c!=0) {printf("0\n"); return 0;}
        else if(c==0) {R k=(ll)(x2-x1+1)*(Y2-Y1+1); printf("%lld\n",k); return 0;}
    } if(c%d!=0) {printf("0\n"); return 0;}
	R x,y; exgcd(a,b,x,y); 
	if(a==0||b==0) {
		if(a==0) { Y1>Y2?swap(Y1,Y2):void(0); y=y*c/d;
			if(y>=Y1&&y<=Y2) printf("%lld\n",x2-x1+1);
			else printf("0\n");
		} else if(b==0) { x1>x2?swap(x1,x2):void(0); x=x*c/d;
			if(x>=x1&&x<=x2) printf("%lld\n",Y2-Y1+1);
			else printf("0\n");
		} return 0;
	}
	x1-=x*c/d,x2-=x*c/d,Y1-=y*c/d,Y2-=y*c/d;
	if(!(x1<x2)^(b>=0)^(d>=0)) swap(x1,x2); if((Y1<Y2)^(a>=0)^(d>=0)) swap(Y1,Y2);
	R k1=(x1+b-1)/b*d,k2=(x2-b+1)/b*d,k3=(-Y1*d+a-1)/a,k4=(-Y2*d-a+1)/a;
	k1=(ll)ceil((long double)x1*d/b),k2=(ll)floor((long double)x2*d/b),k3=(ll)ceil((long double)-Y1*d/a),k4=(ll)floor((long double)-Y2*d/a);
	if(k1>k2) swap(k1,k2); if(k3>k4) swap(k3,k4);
	R kn=max(k1,k3),kx=min(k2,k4); if(kx-kn<0) printf("0\n");else printf("%lld\n",kx-kn+1);
}

```


---

## 作者：KGB1331 (赞：2)

## 运用暴力解方程~~吸氧~~过了这道题
通过数据范围看，要是枚举x和y只能炸掉**三成**的数据。

所以考虑枚举从x1到x2枚举x，通过方程移项可知**y=-(ax+c)/b**，再判断y是否在y1和y2之间即可。

本题~~本做法~~主要坑点：

1、a=b=0时要特判（分为c=0和c!=0两种情况）

2、y1和y2是cmath库关键字

**3、注意精度问题**

------------

	#pragma GCC optimize(1)    
    
    #include<bits/stdc++.h>
    #define ll long long
	using namespace std;
    
    signed main(void)
    {
        ll a,b,c,ans=0;
        ll x1,x2,y_1,y_2;	//y1和y2是cmath关键字，定义这两个家伙会CE
        scanf("%lld%lld%lld",&a,&b,&c);
        scanf("%lld%lld%lld%lld",&x1,&x2,&y_1,&y_2);
        
        if(a==0&&b==0)	//当a=b=0
        {	
            if(c!=0)	//如果c不为0，等式根本不成立
            {  
                puts("0");
                return 0;
            }
            
            else if(c==0)	//如果c=0，任何一个x与y的配对都成立
            {
                ll x_1=abs(x2-x1)+1,
                x_2=abs(y_2-y_1)+1,
                xx=x_1*x_2;
                printf("%lld\n",xx);
                return 0;
            }
        }
        
        for(ll x=x1;x<=x2;x++)	//常规情况：ax+by+c=0=>-(ax+c)/b=y
        {
            ll axc=(a*x+c)*-1; 
            double _ax_c=axc,
         	y=_ax_c/b;	//计算y值
            if(y>=y_1&&y<=y_2&&(a*x+b*(ll)y+c)==0) ans++;	//判断y是否在范围内
            //此处存在精度问题，要用y的整数范围验算判断
        } 
        
        printf("%lld\n",ans);
        return 0; 
    }


---

## 作者：winmt (赞：2)

题解：

首先将原式化为Ax+By=C的形式(A,B,C>=0)，对应调整x，y范围

设AB的gcd为D，由扩展欧几里得算法可得只有当D能整除C方程才有解。

由扩欧可得到一组解x0,y0。则通解x=x0+t\*(B/D) y=y0+t\*(A/D)

分别计算x和y得到的t的范围，取交集即可得到答案。

另注意A,B,C=0的特殊情况

【cpp】





    
    


    
    
    
    
    
    



```cpp
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;
long long ext_euc(long long a, long long b, long long &x, long long &y)
{
    if(b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    long long n = ext_euc(b, a % b, x, y);
    long long t = x;
    x = y;
    y = t - (a / b) * y;
    return n;
}
inline bool one_ans(long long a, long long b, long long c, long long &x, long long &y, long long &gcd)
{
    // ax + by + c = 0 (a != 0 || b != 0)
    c = -c;
    gcd = ext_euc(a, b, x, y);
    if(c % gcd != 0)
        return false;
    long long k = c / gcd;
    x *= k;
    y *= k;
    return true;
}
int main()
{
    ios::sync_with_stdio(false);
    long long a, b, c, x1, x2, y1, y2;
    cin >> a >> b >> c >> x1 >> x2 >> y1 >> y2;
    if(x1 > x2 || y1 > y2) {
        cout << "0\n";
        return 0;
    }
    if(a == 0 && b == 0) {
        if(c != 0) {
            cout << "0\n";
        } else {
            cout << (x2 - x1 + 1) * (y2 - y1 + 1)
                 << '\n';
        }
        return 0;
    }
    long long x, y, gcd;
    bool solved = one_ans(a, b, c, x, y, gcd);
    if(!solved) {
        cout << "0\n";
        return 0;
    }
    if(a == 0) {
        if(y1 <= y && y <= y2) {
            cout << "1\n";
            return 0;
        } else {
            cout << "0\n";
            return 0;
        }
    }
    if(b == 0) {
        if(x1 <= x && x <= x2) {
            cout << "1\n";
            return 0;
        } else {
            cout << "0\n";
            return 0;
        }
    }
    // x + k * b / gcd
    // y - k * a / gcd
    long long b_div_gcd = b / gcd;
    long long a_div_gcd = a / gcd;
    long long k1 = (x1 - x) / b_div_gcd;
    if(x + k1 * b_div_gcd < x1) {
        k1++;
    } else if(x + k1 * b_div_gcd > x2) {
        k1--;
    }
    if(x + k1 * b_div_gcd < x1 || x + k1 * b_div_gcd > x2) {
        cout << "0\n";
        return 0;
    }
    long long k2 = (x2 - x) / b_div_gcd;
    if(x + k2 * b_div_gcd < x1) {
        k2++;
    } else if(x + k2 * b_div_gcd > x2) {
        k2--;
    }
    if(x + k2 * b_div_gcd < x1 || x + k2 * b_div_gcd > x2) {
        cout << "0\n";
        return 0;
    }
    long long k3 = (y - y1) / a_div_gcd;
    if(y - k3 * a_div_gcd < y1) {
        k3--;
    } else if(y - k3 * a_div_gcd > y2) {
        k3++;
    }
    if(y - k3 * a_div_gcd < y1 || y - k3 * a_div_gcd > y2) {
        cout << "0\n";
        return 0;
    }
    long long k4 = (y - y2) / a_div_gcd;
    if(y - k4 * a_div_gcd < y1) {
        k4--;
    } else if(y - k4 * a_div_gcd > y2) {
        k4++;
    }
    if(y - k4 * a_div_gcd < y1 || y - k4 * a_div_gcd > y2) {
        cout << "0\n";
        return 0;
    }
    if(k1 > k2) swap(k1, k2);
    if(k3 > k4) swap(k3, k4);
    long long k_min = max(k1, k3);
    long long k_max = min(k2, k4);
    if(k_min <= k_max) {
        cout << k_max - k_min + 1 << '\n';
    } else {
        cout << "0\n";
    }
    return 0;
}
```

---

## 作者：_huangyicheng_ (赞：2)

感谢大佬[KGB1331](KGB1331)提供的思路

由于蒟蒻太菜，~~什么扩展欧几里得全都不会，只会暴力。~~

由于数据范围，暴力枚举 $x, y$ 会直接T飞，可以想到枚举 $x$ 。

用方程 $ax+by+c=0$ 解出 $y$ ，并判断 $y$ 是否 $y∈[y1,y2]$ 。

对于 $a=0$ 且 $b=0$ 的特殊解，需要分三种情况讨论。

1. 当 $a=0$ 且 $b=0$ 且 $c=0$ 时，很明显， $x$ 和 $y$ 取区间任意值，也就是 $(|x2-x1|+1)(|y2-y1|+1)$ 种。

1. 当 $a=0$ 且 $b=0$ 且 $c≠0$ 时，也很明显， $x$ 和 $y$ 无解，也就是0种。

1. 剩下的情况，需要先求出 $y=\frac{0-c-ax}{b}$ ，再判断范围。

### 需要注意的几个细节

1. 精度，精度，精度！不开long long见祖宗。记得在判断完 $y$ 范围后，代入方程再算一遍。

1. 注意 $y1$ 和 $y2$ 是cmath库里的关键词，用了CE。

$code:$

```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long a,b,c,x1,x2,Y1,Y2,ans;
int main(){
	cin>>a>>b>>c>>x1>>x2>>Y1>>Y2;
	if(a==0&&b==0){//两种特殊情况 
		if(c!=0){
			cout<<0;
			return 0;
		}else{
			long long t1=abs(x2-x1)+1,t2=abs(Y2-Y1)+1;
			long long t=t1*t2;
			cout<<t;
			return 0;
		}
	}
	for(long long i=x1;i<=x2;i++){
		long long t=0-c-a*i;
		double y=double(t)/b;//求出y 
		if(y>=Y1&&y<=Y2&&(a*i+b*(long long)y+c==0)) ans++;//注意精度问题 
	}
	cout<<ans;
	return 0;
}
```

跑的很慢，但能过，最慢点928ms，开O2稳一点。

[评测记录](https://www.luogu.com.cn/record/52612803)

有个很玄学的地方，KGB大佬求 $y$ 用的 $y=-\frac{ax+c}{b}$ ，然后T了，开O2才能过，不开最慢点1.09s。（大雾

第一道紫题题解，管理大大求过qwq

---

## 作者：benny (赞：1)

我也来篇题解吧


------------

## 扩展欧几里得算法(ex_gcd)

https://blog.csdn.net/wyg1997/article/details/50499107

**【问题】**

给定整数a,b， 求：整数不定方程

ax+by=gcd(a,b)

的一个解x,y

**【解决】**采用化归思想

如果说（x,y）为(a,b)的解，那么设(x',y')为(b,a%b)的解，即

ax+by=gcd(a,b)

bx'+(a%b)y'=gcd(b,a%b)

注意到gcd(a,b)=gcd(b,a%b)，得：

ax+by=bx'+(a%b)y'

ax+by=bx'+(a-a/b*b)y'（此处“/”为整除，即除后下取整）

ax+by=ay'+b(x'-a/b*y')

根据恒等原则,x=x',y=(x'-a/b*y')

综上，在a,b,x',y'已知的情况下，可求出x,y


**【部分代码】**
```c
type long long LL; 
void ex_gcd(LL a,LL b,LL &x,LL &y)//求解ax+by=gcd(a,b)
{
    if(b==0)//a=1
    {
        x=1; y=0;
        return;
    }
    ex_gcd(b,a%b,y,x);//这里x,y换了下,y'赋给x,x'赋给y
    y=y-a/b*x;//有点绕
}
```
**【用法、用处】**

拓展欧几里得在接近O(1)的时间内求解

ax+by=gcd(a,b)，给定a,b返回x,y

特别地，当a,b互质时，它可以求解

ax+by=1

进一步，当a,b互质时,也可以求解

ax'+by'=c 只需令x'=xc,y'=yc

**【特别留心】**

ax+by=gcd(a,b)

原方程有无数解，ex_gcd只能求一组解x0,y0。

不过稍稍推导，第i组解为

x=x0+i*lcm(a,b)/a

y=y0-i*lcm(a,b)/b

怎么推导地呢？比赛中基本上不会用。特殊地，当a,b互质时

ax+by=1  第i组解为

x=x0+ib

y=y0-ia





------------

## 言归正传

ax+by+c=0 

xl<=x<=xr,yl<=y<=yr

这是一道很好的数论题，我将题目中的变量换个名字,left，right比较好记,

输入

a,b,c,xl,xr,yl,yr

输出x,y解的组数

【化简】

a、b、c有最大公因数不用说，先约掉

a,b如果**还**有公因数t,那么（ax+by）也是t的倍数,不可能等于-c,

返回0

【有0吗】

ax+by+c=0

abc都是0，范围里的所有解都成立，返回解的个数

ab是0,直接返回0

a是0，那么y=-c/b，一看y是不是整数，二看y在不在范围里，返回1或0

b是0，同理

【扩展欧几里得】

ax+by+c=0

经过化简，ab互质。先求解

ax+by=1,再把x,y同时成以-c，得**一组解**x0,y0

【区间操作】

我们知道，互质时，第i组解为

x=x0+ib

y=y0-ia

先看x。x以x0为起点，步长为b，走i步，要落在区间[xl,xr]里，i的范围？这涉及第一个区间操作“缩小”，求解出i的范围

y同理，也要求解出一个范围

这两个范围的交集即为答案，是第二个区间操作“合并”




------------

```
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;
LL a,b,c,xl,xr,yl,yr;
LL t,i,j,l,r,xx,yy; 

bool in(LL l,LL x,LL r) {return(l<=x&&x<=r);}
bool hb(LL l1,LL r1,LL l2,LL r2)//合并，返回全局变量和bool 
{
    l=max(l1,l2); r=min(r1,r2); 
    return(l<=r);
}
LL gcd(LL x,LL y)
{
    if(y==0) return(x); else return(gcd(y,x%y));
}
void ex_gcd(LL a,LL b,LL &x,LL &y)//ax+by=1
{
    if(b==0)//a=1
    {
        x=1; y=0;
        return;
    }
    ex_gcd(b,a%b,y,x);
    y=y-a/b*x;
}

bool sx(LL L,LL R,LL a0,LL c)//缩小，a0为起点，c为步长，返回全局变量l,r和bool 
// L<=a0+ic<=R,l<=i<=r
{
    //:L<=R,c!=0
    if(c<0) return(sx(-R,-L,-a0,-c));
    //:c>0
    
    l=(L-a0)/c; r=(R-a0)/c;
    if(in(L,a0+l*c,R))
        l-=(in(L,a0+(l-1)*c,R));//范围能大就大 
    else l++;//不能大就缩 
    if(in(L,a0+r*c,R))//同理 
        r+=(in(L,a0+(r+1)*c,R));
    else r--;
    if(l<=r) return 1;else return 0;
}

LL M()
{
    //cout<<3/2*2;
    cin>>a>>b>>c>>xl>>xr>>yl>>yr;
    i=abs(gcd(a,b));
    j=abs(gcd(i,c));
    //cout<<gcd(0,1)<<" "<<0%1<<" "<<j<<endl;
    if(j==0) return((xr-xl+1)*(yr-yl+1));//:a=b=c=0
    if(i==0) return(0);//:a=b=0
    if(a==0) return(c%b==0&&in(yl,-c/b,yr)); 
    if(b==0) return(c%a==0&&in(xl,-c/a,xr));
    //:abc!=0
    a=a/j,b=b/j,c=c/j;
    //cout<<a<<" "<<b<<" "<<c<<gcd(a,b)<<" "<<endl;
    if(abs(gcd(a,b))!=1) return(0);
    //:gcd(a,b)=1;
    ex_gcd(a,b,xx,yy);
    xx*=-c;yy*=-c;
    //cout<<xx<<" "<<yy<<endl;
    if(sx(xl,xr,xx,b)==0) return 0;
    else xl=l,xr=r;
    if(sx(yl,yr,yy,-a)==0) return 0;
    else yl=l,yr=r;
    //:a(xx+bi)+b(yy-ai)+c=0,xl<=i<=xr,yl<=i<=yr   
    //cout<<a<<" "<<b<<" "<<c<<" "<<xl<<" "<<xr<<" "<<yl<<" "<<yr<<" "<<endl;
    if(hb(xl,xr,yl,yr)==0) return 0; else return(r-l+1);
}
int main()
{
    cout<<M();
}
```


---

## 作者：dshzsh (赞：0)

## ~~暴力~~技巧减枝过省选
首先看题目。
>给出a,b,c,x1,x2,y1,y2，求满足ax+by+c=0，且x∈[x1,x2],y∈[y1,y2]的整数解有多少对....  
对于100%的数据，a,b,c,x1,x2,y1,y2的绝对值不超过10^8。

如果枚举 $x$ 求 $y$ ，看上去可以，实际上因为`绝对值`的原因，会超时。 ~~（O2优化！）~~  
所以我们必须将枚举范围缩小。  
方法如下：
```cpp
//xa是x的最大值，xi是x的最小值
int xaa=max((-c-b*yi)/a,(-c-b*ya)/a)+1;//通过x=(-c-b*y)/a求x下界
xa=min(xaa,xa);//更新下界
int xii=min((-c-b*yi)/a,(-c-b*ya)/a)-1;
xi=max(xii,xi);
```
然后基本上枚举 $O$(n) 完全没问题。  
AC 代码如下
```cpp
#include<bits/stdc++.h>
#define int long long//偷懒打法，防止爆int
using namespace std;
//ax+by+c=0
signed main()
{
	int a,b,c,xi,xa,yi,ya;
	scanf("%lld%lld%lld%lld%lld%lld%lld",&a,&b,&c,&xi,&xa,&yi,&ya);
	if(a==0&&b==0)//特判不能忘
	{
		if(c==0)
			cout<<(xa-xi+1)*(ya-yi+1);
		else//c!=0时无解
			cout<<"0";
		return 0;
	}
	if(a==0)
	{
		if(c%b!=0)//注意x，y都是整数
		{
			cout<<"0";
			return 0;
		}
		int y=-c/b;
		int w=(y>=yi&&y<=ya);
		cout<<w;
		return 0;
	}
	if(b==0)
	{
		if(c%a!=0)
		{
			cout<<"0";
			return 0;
		}
		int y=-c/a;
		int w=(y>=xi&&y<=xa);
		cout<<w;
		return 0;
	}
	int xaa=max((-c-b*yi)/a,(-c-b*ya)/a)+1;xa=min(xaa,xa);
	int xii=min((-c-b*yi)/a,(-c-b*ya)/a)-1;xi=max(xii,xi);
	int ans=0;
	for(int x=xi;x<=xa;x++)//暴力枚举即可
	{
		if((-c-a*x)%b==0)
		{
			int y=(-c-a*x)/b;
			if(y>=yi&&y<=ya)
				ans++;
		}
	}
	cout<<ans;
}//made by dshzsh
```


---

## 作者：苍穹狮鹫 (赞：0)


这道题就是细节很多

总共有三种情况

前两种比较简单

只有后一种有点难（详情看代码）

```c
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath> 
#define ll long long
#define y1 y3 //y1在cmath的函数库里 
using namespace std;
int flag=0;
ll a,b,c,x1,x2,y1,y2;
void exgcd(ll a,ll b,ll &x,ll &y,ll &gcd)
{
	int t;
	if(b==0)
	{
		gcd=a;
		x=1;
		y=0;
		return;
	}
	else
	{
		exgcd(b,a%b,x,y,gcd);
		t=x;
		x=y;
		y=t-(a/b)*y;
		return;
	}
	return;
}
void update()
{
	cin>>a>>b>>c>>x1>>x2>>y1>>y2;
	return ;
}
int main()
{
	int n=1;
	if(flag!=0)
	{
		cin>>n;
	}
	for(int i=1;i<=n;i++)
	{
	update();
	if(x1>x2||y1>y2)
	{
		printf("0\n");
		if(flag==0)
		return 0;
	}
	//情况1 
	c=-c;//ax+by=c 
	if(a==0 && b==0)
	{
		if(c==0)
		printf("%lld\n",(x2-x1+1)*(y2-y1+1));
		else
		printf("0\n");
		if(flag==0)
		return 0;
		continue;
	}
	//情况2 
	if(a<0 && b<0)
	{
		c=-c;
		a=-a;
		b=-b;
		//等式两边同时乘一个符号  
	}
	else if(a < 0) 
	{
	swap(x1,x2);
	x1=-x1;
	x2=-x2;
	a=-a;
	}
    else if(b < 0) 
	{
	swap(y1,y2);
	y1=-y1;
	y2=-y2;
	b=-b;	
	}//保证a,b没有负的
	ll x, y, gcd;
    exgcd(a, b, x, y, gcd);
    if(c%gcd) 
    {
    	printf("0\n");
    	if(flag==0)
    	return 0;
    	continue;
    }
    //a*x+b*y=gcd ==>> a*x*(-c/gcd)+ b*y*(-c/gcd) == -c
    c/=gcd;x*=c;y*=c;
    if(!a)//a==0的时候 ,x全部取 
    {
    if(y1<=y&&y<=y2)printf("%lld\n",(x2-x1+1)); 
	else printf("0\n");
	if(flag==0)
	return 0;
	continue;	
    }
	
    if(!b)//b==0的时候 ,y全部取
	{
	if(x1<=x&&x<=x2)printf("%lld\n",(y2-y1+1));
	else printf("0\n");
	if(flag==0)
	return 0;
	continue;
	}
	//x能取的是跟b有关，y能取的是跟a有关，及x增加b , y减少a 
    double l = double(gcd*(x1-x))/b;
    double r = double(gcd*(x2-x))/b;
    l = fmax(l,double(gcd*(y-y2))/a);
    r = fmin(r,double(gcd*(y-y1))/a);//l是最少的，r是最多的（取值范围） 
    ll ansl=(ll)ceil(l),ansr=(ll)floor(r);
    if(ansr>=ansl)
	printf("%lld\n",ansr-ansl+1);
	else
	printf("0\n");
	if(flag==0)
	return 0;
    //情况3
	}
	return 0;
}
```
###### flag只是因为其他OJ上有多组数据，调起来方便


---


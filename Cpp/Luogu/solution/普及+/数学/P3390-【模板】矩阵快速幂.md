# 【模板】矩阵快速幂

## 题目背景

一个 $m \times n$ 的**矩阵**是一个由 $m$ 行 $n$ 列元素排列成的矩形阵列。即形如

$$ A = \begin{bmatrix} a_{1 1} & a_{1 2} & \cdots & a_{1 n} \\ a_{2 1} & a_{2 2} & \cdots & a_{2 n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{m 1} & a_{m 2} & \cdots & a_{m n} \end{bmatrix} \text{.} $$

本题中认为矩阵中的元素 $a_{i j}$ 是整数。

两个大小分别为 $m \times n$ 和 $n \times p$ 的矩阵 $A, B$ **相乘**的结果为一个大小为 $m \times p$ 的矩阵。将结果矩阵记作 $C$，则

$$ c_{i j} = \sum_{k = 1}^{n} a_{i k} b_{k j} \text{,\qquad($1 \le i \le m$, $1 \le j \le p$).} $$

而如果 $A$ 的列数与 $B$ 的行数不相等，则无法进行乘法。

可以验证，矩阵乘法满足结合律，即 $(A B) C = A (B C)$。

一个大小为 $n \times n$ 的矩阵 $A$ 可以与自身进行乘法，得到的仍是大小为 $n \times n$ 的矩阵，记作 $A^2 = A \times A$。进一步地，还可以递归地定义任意高次方 $A^k = A \times A^{k - 1}$，或称 $A^k = \underbrace{A \times A \times \cdots \times A}_{k \text{ 次}}$。

特殊地，定义 $A^0$ 为单位矩阵 $I = \begin{bmatrix} 1 & 0 & \cdots & 0 \\ 0 & 1 & \cdots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & 1 \end{bmatrix}$。

## 题目描述

给定 $n\times n$ 的矩阵 $A$，求 $A^k$。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le n \le 100$，$0 \le k \le 10^{12}$，$|A_{i,j}| \le 1000$。

## 样例 #1

### 输入

```
2 1
1 1
1 1```

### 输出

```
1 1
1 1```

## 样例 #2

### 输入

```
3 5
1 2 3
4 5 6
7 8 9```

### 输出

```
121824 149688 177552
275886 338985 402084
429948 528282 626616```

# 题解

## 作者：子谦。 (赞：456)


$update:2019-9-2$

非常抱歉图炸了，现在应该修复了，管理员给个通过吧（我也不知道为啥图莫名其妙挂了，难道我把图片挂在博客园上不天天访问就会失活？）

$update:2019-2-23$

忽然意识到没有说单位矩阵这个重要的东西，尴尬，现在补上了

-----

嗯，这玩意看着很难对吧，昨天我还是这样想的。。直到今天看到了[**斐波那契公约数**](https://www.luogu.org/problemnew/show/P1306)这道题

这道题一看我这种辣鸡就不会做啊，然后rqy告诉我这是傻逼题啊，我忽然就想起了以前听说过的矩阵乘。。然后懒惰的DDOSvoid大佬告诉我要做这道题，得先做[**斐波那契数列**](https://www.luogu.org/problemnew/show/P1962),要做斐波那契数列，得先做[**矩阵加速**](https://www.luogu.org/problemnew/show/P1939),要做矩阵加速，得先做[**矩阵快速幂**](https://www.luogu.org/problemnew/show/P1939)。。于是，一个上午就这么过去了

----------------

(想看代码直接翻到最下面，本文主要为入门讲解)

回归正题

# 定义

什么是矩阵运算呢？

在理解这个问题前，我们先要知道什么是矩阵

百度百科给的定义如下

> 矩阵是一个按照长方阵列排列的复数或实数集合 

复数实数什么的我们先不管，总之，矩阵就是一堆数，按照矩形排列形成的集合

那么，我们所需要记录的也就是它的长、宽以及矩阵中存储的元素

特殊的，长宽相等的矩阵我们定义它为方阵

当两个矩阵的长宽相等时，我们认为这两个矩阵为同型矩形

# 基本运算

矩阵的运算我们可以类比实数的运算来理解

在实数运算中，一般由进行运算的实数和运算符组成，运算符决定了运算类型

那么同样的，矩阵运算也是如此

## 加法运算

首先，我们来看加法运算

两个矩阵进行**一般的**加法运算的前提是两个矩阵为**同型矩阵**

我们只需要将对应位置的元素相加即可，如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/hioa90k3.png)

在矩阵的加法运算中，满足交换律和结合律，也就是

### $A+B=B+A$

### $(A+B)+C=A+(B+C)$

也许有人想问了，如果我想让两个非同型矩形进行相加可不可以实现呢？

答案是可以的，这种运算是被支持的，我们称这种运算为直和

但由于这种运算使用较少，且与本文关系不大，我们在此不多做解释，感兴趣的朋友可以阅览下面的链接，相信它会给你一个满意的答复

[矩阵加法](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E5%8A%A0%E6%B3%95/12641418?fr=aladdin)

## 减法运算

在实数运算中，减法为加法的逆运算，同样的，在矩阵运算中也是如此，如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/b2rkuxwg.png)

## 数乘

在实数运算中我们并没有数乘这种运算（毕竟本身就是数，直接叫乘法了）

所以在数乘运算中，我们类比向量来进行理解

在数乘向量运算中，只需要将向量中的每个元素乘上那个数就可以了

数乘矩阵也是如此，如图

![](https://cdn.luogu.com.cn/upload/image_hosting/39krazdf.png)

数乘矩阵运算中，满足如下运算律

$(\lambda\mu)A=\lambda(\mu A)$

$(\lambda+\mu)A=\lambda A+\mu A$

$\lambda(A+B)=\lambda A+\lambda B$

## 矩阵乘法（矩阵乘矩阵）

在向量乘向量的运算中，是将每个元素与它对应的元素相乘，求所有乘积之和

那么矩阵乘矩阵是不是就是两个同型矩阵的对应元素相乘呢？

~~**图样图森破**~~

两个矩阵相乘的前提是前一个矩阵的列数等于后一个矩阵的行数

举个栗子，$A$为$n*k$矩阵，$B$为$k*m$矩阵，$C$为$m*n$矩阵，那么$A$可以与$B$相乘，$B$可以与$C$相乘，$C$可以与$A$相乘，其他均不成立

我们知道了什么情况下两个矩阵可以相乘，那么他们怎么相乘呢？不讲每个对应位置相乘还能怎么乘呢？

设$A$为$n*k$矩阵，$B$为$k*m$矩阵,那么它们的乘积$C$则为一个$n*m$矩阵

### $C_{i,j}=\sum_{r=1}^kA_{i,r}*B_{r,j}$

是不是不太好理解，没关系看看图就知道了

![](https://cdn.luogu.com.cn/upload/image_hosting/9zfncisd.png)

在矩阵乘法中满足以下运算律： 

### $(AB)C=a(BC)$

### $(A+B)C=AC+BC$

### $C(A+B)=CA+CB$

在普通的乘法中，一个数乘1还是等于它本身，在矩阵乘法中也有这么一个“1”，它就是单位矩阵

不同于普通乘法中的单位1，对于不同矩阵他们的单位矩阵大小是不同的

对于$n*m$的矩阵，它的单位矩阵大小为$m*m$，对于$m*n$的矩阵，它的单位矩阵大小为$n*n$

也就是说单位矩阵都是正方形的，这是因为只有正方形的矩阵能保证结果和前一个矩阵形状相同

单位矩阵的元素非0即1，从左上角到右下角的对角线上元素皆为1，其他皆为0

-------------

了解了这么多，我们开始看题，矩阵快速幂，由于矩阵乘法满足结合律，所以我们只需要把它按照一般的快速幂打，再重载一下运算符就可以了，好了我们直接放代码

```c++
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#define ll long long
#define gc() getchar()
#define maxn 105
#define mo 1000000007
using namespace std;

inline ll read(){
	ll a=0;int f=0;char p=gc();
	while(!isdigit(p)){f|=p=='-';p=gc();}
	while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}
	return f?-a:a;
}
int n;

struct ahaha{
	ll a[maxn][maxn];     //一定要用long long存矩阵，否则在过程中会爆掉
	ahaha(){
		memset(a,0,sizeof a);
	}
	inline void build(){     //建造单位矩阵
		for(int i=1;i<=n;++i)a[i][i]=1;
	}
}a;
ahaha operator *(const ahaha &x,const ahaha &y){     //重载运算符
	ahaha z;
	for(int k=1;k<=n;++k)
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j)
				z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j]%mo)%mo;
	return z;
}

ll k;
inline void init(){
	n=read();k=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			a.a[i][j]=read();
}

int main(){
	init();
	ahaha ans;ans.build();
	do{     //递推快速幂，与普通的递推快速幂无异，但*不能缩写为*=
		if(k&1)ans=ans*a;
		a=a*a;k>>=1;
	}while(k);
	for(int i=1;i<=n;putchar('\n'),++i)
		for(int j=1;j<=n;++j)
			printf("%d ",ans.a[i][j]);
	return 0;
}
```
最后打一下广告  [**我的博客**](http://www.cnblogs.com/hanruyun/)

## 感谢您的阅览

---

## 作者：yangrunze (赞：144)

**矩阵快速幂**这个东西嘛，其实很简单！

一句话:

## 矩阵快速幂=矩阵乘法+快速幂

所以，这篇题解就要从这两个东西说起：

### 1. 矩阵乘法

首先，不懂矩阵乘法的[戳这里](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/5446029?fr=aladdin)（如果你已经懂了，可以跳过）

还是一脸懵？？？我再来说一遍：

![](https://cdn.luogu.com.cn/upload/image_hosting/ri3zpl8c.png)

这回大家应该都懂了吧（如果图画的不好或者你还是没懂，请原谅）

那知道了怎么乘，到底怎么代码实现呢？？？

其实很简单：用**模拟**就可以啦！

大家先自己思考一下（一定要自己思考），思考完了再来看代码吧

5

------------
4

------------
3

------------
2

------------
1

------------
相信大家代码都思考好了吧！接下来咱们来放一下代码：

```cpp
	//本例中计算矩阵A×矩阵B，存到矩阵C里
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){  //找到c[i][j]，开始算
			for(int k=1;k<=n;k++){
				c[i][j]+=a[i][k]*b[k][j];//矩阵乘法的定义
			}
		}
	}	
```
相信大家都已经get到矩阵乘法的原理和代码实现了吧！

顺便再提一句：**主对角线（即左上-右下对角线）全是1，其它地方全是0**的矩阵是**单位矩阵**也就是说单位矩阵长这样：
|  |  |  |  |
| -----------: | -----------: | -----------: | -----------: |
|  |1  |  0|  0|
|  | 0 | 1 | 0 |
|  | 0 | 0 | 1 |


它就像数的乘法里1乘几就得几一样，**它乘上哪个矩阵，就是哪个矩阵**，为什么？自己乘一下看看就知道啦~

### 2.快速幂

首先，不会快速幂的[看过来](https://www.luogu.com.cn/problem/P1226)
（如果你AC了这道题或已学过相关内容，请跳过）

咱先想想这个问题：如果RMB是这样编排的：1元，2元，4元，8元......也就是面值都是**2的几次方**，那如果带齐“一套钱”，买几块的都能凑起来，不用找零了！为什么呢？？？

$$1=1$$
$$2=2$$
$$3=1+2$$
$$4=4$$
$$5=1+4$$
$$6=2+4$$
$$7=1+2+4$$
$$......$$

真的哎！那为什么这么神奇呢？别急，既然是2的几次方，那咱要不....把每个数转化成**二进制**试试？？
$$1=1$$
$$2=10$$
$$3=11$$
$$4=100$$
$$5=101$$
$$6=110$$
$$7=111$$
$$......$$

发现了吗？如果选了这个数，那对应的一位必然是1！好理解！**二进制的第几位，表示的就是二的几次方**嘛！而这些要么选（1），要么不选（0），必然有一种状态满足你！

我们的快速幂也是这个原理：对于任意一个数，都可以拆成$2^k$的数构成的和，所以求$a^b$，我们就可以把它拆成某几个$a^{2^k}$的积！

for example:

$$3^{11}=3^{8+2+1}=3^8\times3^2\times3^1$$

然后呢，把$a$每次都平方，$a$第一次平方之后会变成$a^2$，再平方就是$a^4$，......就可以快速访问每个$a^{2^k}$的状态了

处理的时候呢，把指数 $b$转化成二进制（就是除以2，膜2，再除以2，再膜2...），如果这一位是1，那就把当前的$a$乘到答案里去！

```cpp
//求a的b次方，答案存到ans里
int ans=1;
while(b>0){
	if(b%2==1)  //如果当前位是1，那答案就包含这位，把a乘到ans里面
	ans=ans*a;
	a=a*a;//把a平方，切到下一状态
	b/=2;//除以2就不用说了吧
}
```
当然你可以用位运算优化，把/2改成>>1，把%2改成&1，据说会更快哦！

### 3.矩阵快速幂

如果你已了解并熟练掌握以上两点，那你离AC就只有一步之遥了

> I have a 矩阵！

> I have a 快速幂！

> Ah~！矩阵快速幂！

没错，就这么简单！因为矩阵乘法是满足**结合律**的，所以**一个单位矩阵用快速幂乘上n次**就是我们的矩阵快速幂了，或者说，矩阵快速幂就是**把快速幂里的乘法换成矩阵乘法**

```cpp
#include<cstdio>
using namespace std;
typedef long long ll; //十年OI一场空，不开long long见祖宗
const int syk=1e9+7;//syk是一个特别厉害的大佬
ll a[105][105],b;
int n;
ll ans[105][105]={0};
inline ll read(){
	char c=getchar();
	ll f=1,x=0;
	while(c<'0'||c>'9'){  //读入优化，这里就不解释了，想学的可以翻我之前的某篇题解
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*f;
}
inline void jzcf1(){  //快速幂里的第一个乘法式子子ans=ans*a
	ll c[105][105]={0};
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				c[i][j]=(c[i][j]+ans[i][k]*a[k][j])%syk; //注意膜1e9+7
			}
		}
	}	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			ans[i][j]=c[i][j];
		}
	}
}
inline void jzcf2(){//快速幂里的第而个乘法式子子a=a*a
	ll c[105][105]={0};
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				c[i][j]=(c[i][j]+a[i][k]*a[k][j])%syk;
			}
		}
	}	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j]=c[i][j];
		}
	}
}
int main(){
	n=(int)read(),b=read();
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++)
		a[i][j]=read();//读入
	}
	for(register int i=1;i<=n;i++)
	ans[i][i]=1;  //把ans初始化成单位矩阵
	while(b){  //快速幂来啦
		if(b&1)
		jzcf1();//把快速幂里的乘法改成矩阵乘法
		jzcf2();
		b>>=1;
	}
	for(register int i=1;i<=n;i++){ //输出
		for(register int j=1;j<=n;j++)
		printf("%lld ",ans[i][j]%syk);
		printf("\n");
	}
	return 0;
}  
```
其实，只要掌握了**矩阵乘法和快速幂的知识**，**矩阵快速幂其实一点都不难**！屏幕前的小伙伴们，恭喜你们有get到了一个新的模板题！

The  end ......

---

## 作者：Maika (赞：90)

# 前言
初拾矩阵还是刚接触OI的时候，那时候对于矩阵只能是依样画葫芦，并不是很了解。现在过去了将近1年，我也是无意之间发现我Luogu上有很多关于矩阵的模板题都没做，一方面是为了更好的梳理关于矩阵的知识，另一方面也是为了打发下午的时光， ~~主要是发现QQ空间里都在撒狗粮~~

# 矩阵的一些基本概念
### 1.矩阵是矩形的数组
For Example

如图是一个矩阵$A=(a_{ij})$，其中$i=\{1,2\},j=\{1,2,3\}$

矩阵中的第$i$行$j$列的元素通常以小写字母$a_{ij}$

$A=\left[\begin{matrix}1 & 2 & 3\\4 & 5 & 6\end{matrix}\right]$

一般的，

我们将一个内含元素全部是实数的$i$行$j$列的矩阵记为表示$R^{i\times j}$

对于集合内元素都包含于$S$的$i$行$j$列的矩阵记为表示$S^{i\times j}$


### 2.将矩阵的行和列相互交换称为矩阵的转置
For Example 

如图是矩阵$A$的转置$A^T$

$A=\left[\begin{matrix}1 & 4\\2 & 5\\3 & 6\end{matrix}\right]$

# 矩阵的基本运算
### 1.矩阵的加法
对于任意的两个大小相等的矩阵$A^{i\times j}$和$B^{i\times j}$

$A^{i\times j}+B^{i\times j} = \left[\begin{matrix}1 & 2 &3\\4 & 5 & 6\end{matrix}\right] +$
$\left[\begin{matrix}7 & 8 &9\\10 & 11 & 12\end{matrix}\right]=$
$\left[\begin{matrix}{1+7} & {2+8} &{3+9}\\{4+10} & {5+11} & {6+12}\end{matrix}\right]=$
$\left[\begin{matrix}8 & 10 &12\\14 & 16 & 18\end{matrix}\right]$

即矩阵的对应位置上的两个元素相加
### 2.矩阵的减法
对于任意的两个大小相等的矩阵$A^{i\times j}$和$B^{i\times j}$

$A^{i\times j}-B^{i\times j} = \left[\begin{matrix}1 & 2 &3\\4 & 5 & 6\end{matrix}\right] -$
$\left[\begin{matrix}7 & 8 &9\\10 & 11 & 12\end{matrix}\right]=$
$\left[\begin{matrix}{1-7} & {2-8} &{3-9}\\{4-10} & {5-11} & {6-12}\end{matrix}\right]=$
$\left[\begin{matrix}{-6} & {-6} &{-6}\\{-6} & {-6} & {-6}\\\end{matrix}\right]$

即矩阵的对应位置上的两个元素相减
### 3.矩阵的乘法
**${\color{Red}Warning}$**

**为了表达的严谨性，此块内容会出现大量数学符号与专有名词，请各位自重**

矩阵乘法的定义如下：

给定两个**相容**的矩阵$A$和$B$，

如果$A=(a_{ik})$是一个$m\times n$的矩阵，并且$B=(b_{kj})$是一个$n\times p$的矩阵，

那么它们的积$C=AB$是一个$m\times p$的矩阵$C=(c_{ij})$，

其中，对于$i=\{1,2,\cdots ,m\},j=\{1,2,\cdots ,p\}$

$c_{ij}=\sum_{i=1}^k a_{ik}b_{kj}$ 

For Example

$A=\left[\begin{matrix}1 & 2 & 3\\4 & 5 & 6\\\end{matrix}\right]$

$B=\left[\begin{matrix}7 & 8\\9 & 10\\11 & 12\\\end{matrix}\right]$

$A\times B=\left[\begin{matrix}{1\times 7+2\times 9+3\times 11} & {1\times 8+2\times 10 +3\times 12}\\{4\times 7+5\times 9+6\times 11} & {4\times 8+5\times 10+6\times 12}        \end{matrix}\right]=\left[\begin{matrix}58 & 64\\139 & 154\end{matrix}\right]$

# 一些常用的矩阵

### 1.对角线元素均为1的$n\times n$的对角矩阵称为单位矩阵
$I_n=diag(1,1,1,\cdots,1,1)=\left[\begin{matrix}1 & 0 & \cdots & 0 & 0\\0 & 1 & \cdots & 0 & 0\\\vdots & \vdots & \ddots & \vdots & \vdots\\0 & 0 & \cdots & 1 & 0\\0 & 0 & \cdots & 0 &1\end{matrix}\right]$

既然都叫做单位矩阵了，其作用也是显而易见的：

对于$\forall i,j$，都有$i=j$，

$(A=(a_{ij}))\times (I=(i_{ij}))=(A=(a_{ij})$
# 矩阵的用途
### 简单来说，主要有三

#### 第一个用途是解线性方程组
比如二维矩阵可以理解为一个平面直角坐标系内的点集，通过计算点与点之间的距离，完成聚类、分类或预测，类似的运算完全可以扩展到多维的情况。

#### 第二个用途是方程降次
也就是利用矩阵的二次型通过升维将线性不可分的数据集映射到高维中，转换为线性可分的情形，这是支持向量机的基本原理之一。

#### 第三个用途是变换
矩阵可以通过特征值和特征向量完成维度约简，简化类似图片这种高维数据集的运算，主成分分析使用的就是这个原理。

### ~~本节其实都是废话~~
反正联赛考起来好像那些都不考，就考那个啥**矩阵快速幂**和**矩阵加速**

# 矩阵快速幂

#### 终于到了正题~~突然发现矩阵的Markdown写起来要死人~~

既然是矩阵快速幂，那更关键的肯定还是快速幂了

那就先看看快速幂好了

快速幂其实是利用递推式$x^k=\begin{cases}x^{\tfrac{k}{2}}\times x^{\tfrac{k}{2}}&k\bmod 2=0\\x^{\tfrac{k-1}{2}} \times x^{\tfrac{k-1}{2}} \times x &k\bmod 2=1\end{cases}$将原本$O(k)$级别优化至$O(log_2k)$级别

所以，这种简单的代码贴个高清无码的还是很OK的

**while版：**

```cpp
while(p>0) {
	if(p%2!=0) ans=ans*b;
    	b=b*b;
        p=p>>1;
}
```
**递归版：**
```cpp
int Fastpower(int a,int n){
	if(n==0)	return 1;
	if(n==1)	return a;
	int c=Fastpower(a,n/2);
	if(n%2==0)	return c*c;
	else	return c*c*a;
}
```
在了解了何为快速幂之后，我们再来了解一下何为矩阵快速幂

说白了，就是$k$个$A^{n\times n}$的矩阵乘在一起

So,我们只需在原有的快速幂上略加修改就可以得到一份可以 ${\color{Green}AC}$黄题的代码

**递归版：**
```cpp
struct Matrix {																	\\结构体
	long long c[101][101];
} A;
long long n,k;
Matrix operator*(const Matrix &x,const Matrix &y) {								\\重载
	Matrix a;
	for(int i=1;i<=n;i++) 	
		for(int j=1;j<=n;j++)
		 a.c[i][j]=0;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++) {
				a.c[i][j]+=x.c[i][k]*y.c[k][j]%Mod;
				a.c[i][j]%=Mod;
			}
	return a;
}
Matrix Fastpower_Matrix(Matrix a,long long n) {									\\递归
	if(n==1)	return a;
	if(n%2==0)	return Fastpower_Matrix(a,n/2)*Fastpower_Matrix(a,n/2);
	if(n%2==1)  return Fastpower_Matrix(a,n/2)*Fastpower_Matrix(a,(n-1)/2)*a;
}


```
~~终于明白了为什么没有递归的题解了，因为全部TLE~~

**while版：**
```cpp
struct Matrix {																	\\结构体
	long long c[101][101];
} A,I;
long long n,k;
Matrix operator*(const Matrix &x,const Matrix &y) {								\\重载
	Matrix a;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			a.c[i][j]=0;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++) {
				a.c[i][j]+=x.c[i][k]*y.c[k][j]%Mod;
				a.c[i][j]%=Mod;
			}
	return a;
}
void Fastpower_Matrix(int k){													
	for(int i=1; i<=n; i++)
		I.c[i][i]=1;															\\单位矩阵定义
	while(k>0) {																\\Fastpower_Matrix
		if(k%2==1) I=I*A;
		A=A*A;
		k=k>>1;
	}
	
}

```
~~总感觉这个要CE，我直接在博客打的~~

**最后自然要放出高清无码的标程~~和地铁站里的蔡徐坤一样~~**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mod=1000000007;
struct Matrix {
	long long c[101][101];
} A,I;
long long n,k;
Matrix operator*(const Matrix &x,const Matrix &y) {
	Matrix a;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			a.c[i][j]=0;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++) {
				a.c[i][j]+=x.c[i][k]*y.c[k][j]%Mod;
				a.c[i][j]%=Mod;
			}
	return a;
}

int main() {
	cin>>n>>k;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			cin>>A.c[i][j];
	for(int i=1; i<=n; i++)
		I.c[i][i]=1;
	while(k>0) {
		if(k%2==1) I=I*A;
		A=A*A;
		k=k>>1;
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++)
			cout<<I.c[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}

```









---

## 作者：半仙胡小桃 (赞：50)

[传送门](https://www.luogu.org/problem/show?pid=3390)

这题有毒啊，没开长整型一个都不对，害得我以为我板子写错了QAQ

一个裸的矩阵快速幂，矩阵乘法要求两个矩阵分别为n行m列与m行p列，得出的矩阵是n行p列

矩阵乘法满足结合律，但不满足交换律（所以可以套快速幂的板子）

教科书告诉你，计算规则是，第一个矩阵第一行的每个数字（2 和1），各自乘以第二个矩阵第一列对应位置的数字（1 和1），然后将乘积相加（ 2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。

![这里写图片描述](http://img.blog.csdn.net/20170816154142793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU5MTQ1ODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

OK，但是我的这个快速幂有一点不同就是ans数组的初值不是1，而是输入的数，我们计算的是k-1次方

默认为2次方，所以要-1，赋值为1有问题的

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
long long x[999][999];
long long ans[999][999];
long long dx[999][999];
const int p=1e9+7;
void ans_cf(int n)
{
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      dx[i][j]=ans[i][j],ans[i][j]=0;
    
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      for(int k=1;k<=n;k++)
       ans[i][j]=(ans[i][j]+(x[i][k]*dx[k][j])%p)%p;
}
void x_cf(int n)
{
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      dx[i][j]=x[i][j],x[i][j]=0;
    
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      for(int k=1;k<=n;k++)
       x[i][j]=(x[i][j]+(dx[i][k]*dx[k][j])%p)%p;
}
void fast_pow(long long n,long long w)
{
    while(w)
    {
        if(w%2==1) ans_cf(n);
        w/=2;
        x_cf(n);
    }
}
int main()
{
    long long n,k;
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
      scanf("%d",&x[i][j]),ans[i][j]=x[i][j];
    fast_pow(n,k-1);
    
    for(int i=1;i<=n;i++)
    {
      for(int j=1;j<=n;j++)
       printf("%lld ",ans[i][j]);
      puts("");
    }
     
}

```

---

## 作者：Ning_Mew (赞：26)

看了一圈题解发现大部分巨佬是用重载运算符做的，于是为了方便一些新手理解学习，上传一份用函数来算矩阵快速幂的代码。


First，我们要知道矩阵乘法的计算方法：c[x][y]=∑(i=1,i<=n)a[x][i]+b[i][j]（不知道的童鞋可以自行百度，计算方法很简单的

Second，然后就是按照题目意思去计算，需要注意的是：

Third，要用到**快速幂**（不清楚的同学可以去先做快速幂的模板题

Forth，矩阵满足结合律，所以我们可以将快速幂中的**数**等效替换成**一个\_结构体\_存一个二维数组**

Fifth，因为是结构体，所以可以直接return，非常方便


具体细节见代码注释～

```cpp
//It is coded by Ning_Mew on 10.20
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#define LL long long//注意开long long
using namespace std;
LL n,k;//n,k是会超int的，注意开long long，我前面一直暴0，就是没开long long
struct ska{
    LL a[100+10][100+10];
}p,pp;
//下面这行就是返回的就是ska，一个结构体
ska X(ska x,ska y){
    ska box;
    for(LL i=1;i<=n;i++)
    for(LL j=1;j<=n;j++)box.a[i][j]=0;//预处理box函数，因为要累加，所以要先清零
    for(LL i=1;i<=n;i++){
        for(LL j=1;j<=n;j++){
            for(LL k=1;k<=n;k++){
                box.a[i][j]=(box.a[i][j]+(x.a[i][k]*y.a[k][j])%1000000007)%1000000007;//注意取模
                //c[x][y]=∑(i=1,i<=n)a[x][i]+b[i][j]
            }
        }
    }
    return box;
}
ska quick_pow(LL kk){
    ska ans;
    for(LL i=1;i<=n;i++){ans.a[i][i]=1;}
    //将对角线全赋值为1，A矩阵与这个矩阵相乘，结果是A矩阵本身
    //其实呢，可以直接将ans矩阵赋值为p，然后乘方次数剪1是一样的
    while(kk){
        if(kk%2){
            ans=X(ans,p);
        }
        kk=kk/2;
        p=X(p,p);
    }//标准的快速幂
    return ans;
}
int main(){
    scanf("%lld%lld",&n,&k);
    for(LL i=1;i<=n;i++){
        for(LL j=1;j<=n;j++){
            scanf("%lld",&p.a[i][j]);
        }
    }//读入
    pp=quick_pow(k);
    for(LL i=1;i<=n;i++){
        for(LL j=1;j<=n;j++){
            printf("%lld ",pp.a[i][j]);
        }
        cout<<endl;
    }//输出
    return 0;
}
```

大概就是这样了，好好学，好好打还是不难的～


---

## 作者：檀黎斗·神 (赞：17)

看到题解写的都要重载运算符

但是吧，重载运算符还是用的不习惯

于是我就写了一个函数的版本

其实理解了矩阵乘法和快速幂之后很好做啊

（话说标签为什么只有数论啊）

把矩阵乘法当做一个函数就和重载运算符一样的

再写一个快速幂，完美AC

···
```cpp
#include<cstdio>
#define ll long long
using namespace std;
const ll Mod=1000000007;
ll n,k;  
struct matrix{  
    ll m[105][105];  
}a;
matrix x(matrix a,matrix b) //矩阵乘法的模板 
{   
    matrix t;  
    for(int i=0;i<n;i++)  
     for(int j=0;j<n;j++)
     {  
        t.m[i][j]=0; 
        for(int k=0;k<n;k++)  
         t.m[i][j]=(t.m[i][j]+a.m[i][k]*b.m[k][j])%Mod; 
     }  
    return t;  
}  
matrix fast_m(matrix a,ll k)
{
    matrix ret=a,b=a;k--;
    //这里记得减一因为之前已经乘过一次了 
    while(k>0)
    {
        if(k%2==1) ret=x(b,ret);
        b=x(b,b);
        k/=2;
    }
    return ret;
}
int main()
{
    scanf("%lld%lld",&n,&k);
    for(int i=0;i<n;i++)
     for(int j=0;j<n;j++)
      scanf("%lld",&a.m[i][j]);
    a=fast_m(a,k);
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        printf("%lld ",a.m[i][j]);
        printf("\n");
    }
    return 0;
}
···
```

---

## 作者：mdzzzzzzzzzz (赞：12)

# 与很多的算法一样，矩阵快速幂是由两个东西加起来的

### 没错，就是矩阵+快速幂

## 1.快速幂

相信快速幂大家都会打吧

什么？你说不会？

好吧那我就讲讲普通快速幂（看似勉为其难其实是想过题解）

**对于整数a^b可转化为b化为二进制后的每一个非零位（第n位）乘上a^2^n,再把结果相乘，便是a^b的答案了**

举个例子：3^5,5化为二进制后是101，则3^5=1 * 3^2^0 * 1 * 3^2^2=1 * 3^1 * 1 * 3^4=243

```cpp
#include<bits/stdc++.h>
using namespace std;
long long c,d,e;
long long gsc(long long a,long long b,long long p)//龟速乘（不会快速乘但复杂度也不太高，可以接受） 
{
    long long t=a,ans=0;
    while(b)
    {
        if(b&1)
        ans=(ans+t)%p;
        t=(t<<1)%p;
        b>>=1;
    }
    return ans%p;
}
long long ksm(long long a,long long b,long long p)//标准快速幂 
{
    long long t=a,ans=1;
    while(b)
    {
        if(b&1)
        {
            ans=gsc(ans,t,p)%p;//要套一个龟速乘，不然还是会超过long long 
        }
        t=gsc(t,t,p)%p;//每次都平方
        b>>=1;//找下一位
    }
    return ans%p;//这里一定要有%p，不然当b=0是就完了 
}
int main()
{
    scanf("%lld%lld%lld",&c,&d,&e);//a^b%e
    printf("%lld",ksm(c,d,e));
}

```

### 而上面那个代码的龟速乘改成矩阵乘法就好了

什么，矩阵乘法也不会？

好吧，我们来讲讲矩阵乘法。

## 2.矩阵乘法

我估计随便翻一篇题解都会有吧

反正就是一个n * k的矩阵（A）乘一个k * m的矩阵（B）乘出来就是一个n * m的矩阵（C）（A * B=C）

记住口诀：

A的第n行乘B的第n列等于C的第n行第n列。

以下是作者随机生成的两个矩阵

![](https://i.loli.net/2019/07/28/5d3d18c558f7379451.png)

![](https://i.loli.net/2019/07/28/5d3d18c56b3be40972.png)

按照我们刚刚的口诀来算C的结果为（如果算错了请大佬们指正）

![](https://i.loli.net/2019/07/28/5d3d1b0914f7c92407.png)

所以我就当你们都听懂了就直接贴上矩阵乘法（O(n^3)）的代码了（肯定不是因为懒）

```cpp
#include<bits/stdc++.h>
#define mo 1000000007
using namespace std;
struct mat//我们用mat来记录这个矩阵
{
	long long a[120][120];//maxN=100
};
mat cl(mat a,mat b,long long n)
{
	mat c;
	memset(c.a,0,sizeof(c.a));//清空答案数组（好像没必要但还是加上）
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			for(int k=0;k<n;k++)
			{
				c.a[i][j]+=a.a[i][k]*b.a[k][j];//因为n*k的A乘k*m的B得到n*m的C，所以计算方法就是这一条。
				c.a[i][j]%=mo;//答案膜好用的大质数1e9+7
			}
		}
	}
	return c;
}
```
然后其实就是把原来的普通快速幂里面的龟速乘换成矩阵的~~n^3龟速乘~~

```cpp
mat pow(mat c,long long n,long long k)//其实就是快速幂嘛，只不过ans（res）的初始化变了。
{
	mat res;
	for(int i=0;i<n;i++)
	res.a[i][i]=1;
    while(k)
    {  
        if(k&1)
		res=cl(res,c,n);
        c=cl(c,c,n);
        k=k>>1;
    }
    return res;
}
```
# 最后，便是完整的AC代码！

```cpp
#include<bits/stdc++.h>
#define mo 1000000007
using namespace std;
struct mat
{
	long long a[120][120];
};
mat cl(mat a,mat b,long long n)//矩阵龟速乘
{
	mat c;
	memset(c.a,0,sizeof(c.a));
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			for(int k=0;k<n;k++)
			{
				c.a[i][j]+=a.a[i][k]*b.a[k][j];
				c.a[i][j]%=mo;
			}
		}
	}
	return c;
}
mat pow(mat c,long long n,long long k)//快速幂
{
	mat res;
	for(int i=0;i<n;i++)
	res.a[i][i]=1;
    while(k)
    {  
        if(k&1)
		res=cl(res,c,n);
        c=cl(c,c,n);
        k=k>>1;
    }
    return res;
}
int main()
{
	long long n,k;
	mat c;
	scanf("%lld%lld",&n,&k);
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		scanf("%lld",&c.a[i][j]);
	}
	mat ans=pow(c,n,k);//标准快速幂接口
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		printf("%lld ",ans.a[i][j]%mo);
		puts("");
	}
}
```
不要直接抄，代码里面有坑（专门藏的）

# 你已经被警告过了

$\textsf{\color{#8B6914}\small{抄了我代码的你 }\color{white}\scriptsize{\colorbox{#8B6914}{ 作弊者 }}}$

---

## 作者：tocek_shiki (赞：9)

看到没人发重载的

**那我赶紧发啊！！**

# 停！
【预备知识】：整数快速幂，矩阵乘法

不会左转luogu+baidu

好了，现在可以贴上可爱的小代码了（雾
```cpp
#include <bits/stdc++.h>
#define newline printf ("\n")
#define space printf (" ")
#define cinfalse ios::sync_with_stdio(false)
#define fread(a) freopen (a".in", "r", stdin), freopen(a".out", "w", stdout)
#define MAXN 105
using namespace std；

long long n;
struct Martix
{
	long long g[MAXN][MAXN];
	
	void clear()
	{
		memset (g, 0, sizeof (g));//清0
		return ;
	}
	
	Martix operator * (const Martix b) const//额，这个的话重载就是这么干，记住就好
	{
		Martix tmp;//tmp要作为返回值
		tmp.clear();//因为要累加，所以要事先清0
		for (long long i = 0; i < n; i ++)//基本枚举，下同
			for (long long j = 0; j < n; j ++)
				for (long long k = 0; k < n; k ++)
					tmp.g[i][j] += (g[i][k]*b.g[k][j])%1000000007, tmp.g[i][j] %= 1000000007;//多%总是好的，防溢出
		return tmp;
	}
	
	Martix operator *= (const Martix b)
	{
		return *this = *this*b;//也是记住就行，不用太计较
	}
	
	void print()
	{
		for (long long i = 0; i < n; i ++, printf ("\n"))
			for (long long j = 0; j < n; j ++)
				printf ("%lld ", g[i][j]);
		return ;//个人喜欢把输入输出封装一下，下同
	}
	
	void scan()
	{
		for (long long i = 0; i < n; i ++)
			for (long long j = 0; j < n; j ++)
				scanf ("%lld", &g[i][j]);
		return ;
	}
};

Martix a;

Martix Fast_Power(long long k)//发现了吗？下面的快速幂和整数的基本一致：直观原因->我重载了（逃
{
	Martix res;
	res.clear();
	for (long long i = 0; i < n; i ++)
		res.g[i][i] = 1;
	while (k)
	{
		if (k%2)
			res *= a;
		k /= 2;
		a *= a;
	}
	return res;
}

long long read()//手打略快
{
	long long x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')
			f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
		x = x*10 + c-'0', c = getchar();
	return f*x;
}

long long k;//注意了！k一定要开long long !我当时就是因为没开long long 卡了2次，
int main()//多么的简洁啊！
{
	n = read(), k = read();
	a.scan();
	a = Fast_Power(k);
	a.print();
    return 0;
}

```

---

## 作者：STPGUY (赞：8)

# 哇啊啊啊
#### 楼下(~~不造是楼上还是楼下~~)的大佬们已经讲的非常详细了
##### 那我就来骚一发主函数只有两行的重载运算符吧
-----------

```cpp
#include <iostream>

using namespace std;

const int Maxn = 105, Mod = 1e9 + 7;

struct Node
{
	long long N, K;
	long long A[Maxn][Maxn];
	
	inline void Clear(int X)
	{
		for (int i = 1; i <= N; ++i)
			for (int j = 1; j <= N; ++j)A[i][j] = X;
	}
		
	friend ostream &operator << (ostream &, Node &B)
	{
		for (int i = 1; i <= B.N; ++i)
		{
			for (int j = 1; j <= B.N; ++j)cout << B.A[i][j] << ' ';
			cout << endl; 
		}
		return cout;
	}
	
	friend istream &operator >> (istream &, Node &B)
	{
		cin >> B.N >> B.K;
		for (int i = 1; i <= B.N; ++i)
			for (int j = 1; j <= B.N; ++j)cin >> B.A[i][j];
		return cin;
	}//输入输出流的重载,然您读入方便自如
	
	Node operator * (const Node &X)const
	{
		Node Temp = X;
		Temp.Clear(0);
		for (int i = 1; i <= X.N; ++i)
			for (int j = 1; j <= X.N; ++j)
				for (int k = 1; k <= X.N; ++k)Temp.A[i][j] = ((X.A[i][k] * A[k][j]) + Temp.A[i][j]) % Mod;
		return Temp;
	}//乘法的重载
}Now;

void Work ()
{
	Node Ans = Now;
	Ans.Clear(0);
	for (int i = 1; i <= Ans.N; ++i)Ans.A[i][i] = 1;
	while (Now.K)
	{
		if (Now.K & 1)Ans = Ans * Now;
		Now = Now * Now;
		Now.K >>= 1;  
	}
	cout << Ans << endl;
}

int main()
{
	cin >> Now;
	Work();
}
```
#### 坑点:
```cpp
	long long N, K;
	long long A[Maxn][Maxn];
```
#### 这里一定
##        一定
#          一定要开long long
##### 否则听取WA声一片:
![](https://cdn.luogu.com.cn/upload/image_hosting/plqsgs6e.png)


---

## 作者：Kizuna_AI (赞：2)

我的博客：[链接](https://jyeric-likecoding.netlify.com)

很奇怪。翻阅了全部的题解，貌似没有一篇的快速幂是用递归的方式写的（可能是我眼瞎）。 那么我的代码就是用递归的方式所写的题解。

矩阵快速幂用到的方法就是矩阵乘法+快速幂。掌握了这两道题目，就可以轻轻松松的AC这道题目了。

## 快速幂
如果不会快速幂的可以去[P1226
【模板】快速幂||取余运算](https://www.luogu.org/problem/P1226)这道题目。

对于矩阵乘法来说，就是一个公式。对于矩阵$a[i][m]*a[m][j]$来说，执行矩阵乘法有以下公式：

$c[i][j]=\sum\limits_{k=1}^ma_{i,k}*b_{k,j}$ 

## 代码：
```
//这个代码并未重载运算符，而是复制过去的
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007ll
using namespace std;
int n;ll k;
ll num;
ll a[110][110],b[110][110],c[110][110];
void copy() {
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			b[i][j]=c[i][j];
	memset(c,0,sizeof(c));
}
void z1() {
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) //第i行第j列 
			for(int k=1;k<=n;k++)
				c[i][j]=(c[i][j]+b[i][k]*b[k][j])%mod;
	copy();
}
void z2() {
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=n;k++)
				c[i][j]=(c[i][j]+b[i][k]*a[k][j])%mod;
	copy();
}
void get_pow(ll p) {
	if(p==1) return;
	get_pow(p>>1);
	z1();
	if(p&1) z2();
}
int main() {
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j],b[i][j]=a[i][j];
	get_pow(k);
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=n;j++)
			printf("%lld ",b[i][j]);
		printf("\n");
	}
	return 0;
} 
```

---

## 作者：Erik (赞：2)

# 矩阵快速幂，顾名思义：矩阵+快速幂下面我将分开讲解


------------
第一部分：快速幂：
所谓快速幂就是~~使一个多次方运算变得跟快的（这不废话嘛）~~这样一个算法
我们有一个式子：**a^b**，假设b为偶数
根据幂运算法则我们可以将式子变形为 **（a^2）^(b/2)**
接着在无限分下去，如果b为奇数那么式子可以变成 **（a^2）^(b/2)*a**
假设b为8吧，那么正常运算我们会算7次吧
但如果用快速幂来算  居然只用算3次  ~~震惊，某算法竟然让他快了那么多~~
这不就快了吗？
下面是快速幂的代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int a,b;
ll ans;

ll kuaisumi(int a,int b)
{
	int cnt=1;
	while(b)
	{
		if(b&1) cnt*=a;//b&1 just zhuangbi 其实就是位运算加速 其实就相当于b%2==0 
		a*=a;
		b>>=1;//位运算加速 相当于b/=2 
	}
	return cnt;
}

int main()
{
	cin>>a>>b;
	ans=kuaisumi(a,b);
	cout<<ans;	
	return 0;
}
```


------------
下面是矩阵乘法：
矩阵乘法也就是两个矩阵相乘
注意：
1.当且仅当a矩阵的行数==b矩阵的列数并且a矩阵的列数等于b矩阵的行数时才有矩阵乘法
2.当且仅当a矩阵的行数等于a矩阵的列数等于b矩阵的行数等于b矩阵的列数时才有矩阵快速幂
下面就是矩阵乘法的具体方法

![哈达马积那一个矩阵乘法的示意图](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95)


------------
下面只需要将其结合在一起就ok啦
贴上AC代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=1000000007;
ll x,y;

struct P{
	ll m[100][100]; 
};
P a,e,ans;

P jz(P a,P b)
{
	P c;
	for(int i=1;i<=x;i++)
		for(int j=1;j<=x;j++)
			c.m[i][j]=0;
	for(int i=1;i<=x;i++)
      for(int j=1;j<=x;j++)
        for(int k=1;k<=x;k++)
          c.m[i][j]=c.m[i][j]%mod+a.m[i][k]*b.m[k][j]%mod;
    return c; 
}

P mi(P a,ll b)
{
	P ans=e;
    while(b)
    {
        if(b&1) ans=jz(ans,a);
        a=jz(a,a);
        b>>=1;
    }
    return ans;
}

int main()
{
	cin>>x>>y;
	for(int i=1;i<=x;i++)
	{
		for(int j=1;j<=x;j++)
		{
			cin>>a.m[i][j];
		}
		e.m[i][i]=1;
	}
	ans=mi(a,y);
	for(int i=1;i<=x;i++)
	{
		for(int j=1;j<=x;j++)
		{
			cout<<ans.m[i][j]%mod<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```
于是乎，~~很难的~~矩阵快速幂就被我们拆成了两个问题然后解决掉了哼哼~~
第一次做题解，求过~~

---

## 作者：_orz (赞：2)

~~板子题有什么题解的必要吗（小并感）~~

其实是突然想到一个池沼问题，就是说我写一个`struct`，万一我在函数里定义一个矩阵，然后矩阵又很大，那就Stack Overflow了。所以就想能不能动态开个二维数组。。

然后池沼的我就去请教了大佬，学会了些~~好康的（并不）~~操作。

---

# 让我们发车

我们先写个**结构体**，

```cpp
struct Matrix {
  int n,m; // n行m列的矩阵
  long long **a; // 双重指针，用来搞二维数组
};
```

然后当我们定义一个 $n$ 行 $m$ 列的矩阵 $A$ 的时候，我们希望通过`Matrix A(n,m)`这种操作来实现。于是我们写一个**构造函数**。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  
  
  // 从这开始是新的，上面是重复的不用看
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0; // 将矩阵所有元素赋初值为0
    }
  }
};
```

这个时候我们不得不写一个**析构函数**。因为我们的`struct`里面有的只是一个双重指针。当我们定义的矩阵离开作用域的时候，他不知道我们自己又开了那么多内存空间，于是只会简单的删掉那个双重指针。过不了多久内存就会炸的。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
};
```

接下来可以重载乘号运算符了吗？答案肯定是不行啦。因为我们考虑写重载乘号的时候一般是在开头定义一个临时变量来存答案，最后再返回那个临时变量。然而如果这么做的话，那个临时变量会在函数结束的时候被析构掉，这个时候返回的指针指向的是一个空的地址，会导致RE。解决方案是使用**拷贝构造函数**。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
};
```

然后我们就可以愉快地写**重载乘号运算符**啦！

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
};
```

我们这个时候又注意到，如果我们要写快速幂，貌似还得用到赋值号。那还得**重载赋值运算符**。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
};
```

我们觉得访问矩阵的第 $i$ 行第 $j$ 列，用`A.a[i][j]`不好看也不方便，于是我们再**重载中括号运算符**。这样我们就可以直接`A[i][j]`啦！

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  long long *operator[](int p) {return a[p];}
};
```

我们做矩阵乘法快速幂的时候，一开始要有一个单位矩阵。为方便起见，我们写个函数在这里来构造单位矩阵。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
  long long *operator[](int p) {return a[p];}
  
  
  // 从这开始是新的，上面是重复的不用看
  void I() {for(int i=1;i<=n;i++) a[i][i]=1;}
};
```

最后，为了方便输出，我们定义一个函数来输出矩阵。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
  long long *operator[](int p) {return a[p];}
  void I() {for(int i=1;i<=n;i++) a[i][i]=1;}
  
  
  // 从这开始是新的，上面是重复的不用看
  void print() {
    for(int i=1;i<=n;i++) {
      for(int j=1;j<=n;j++)
        printf("%lld ",a[i][j]);
      puts("");
};
```

那么我们的`struct`就定义好了。

---

# 注意

里面的这几个函数，除了**拷贝构造函数一定要在重载乘号和重载赋值号之前定义**之外，其他的顺序没有什么强制性规定。

# 代码

下面放完整代码：

```
#include <cstdio>
#include <iostream>

using namespace std;
typedef long long ll;
const int ha=1e9+7,MAXN=110;

struct Matrix {
  int n,m;
  ll **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new ll*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new ll[m+1];
      for(int j=1;j<=m;j++) a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new ll*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new ll[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
  ll *operator[](int p) {return a[p];}
  void I() {for(int i=1;i<=n;i++) a[i][i]=1;}
  void print() {
    for(int i=1;i<=n;i++) {
      for(int j=1;j<=n;j++)
        printf("%lld ",a[i][j]);
      puts("");
    }
  }
};

Matrix ksm(Matrix a, ll k) {
  Matrix ret(a.n,a.m);
  ret.I();
  while(k) {
    k&1?ret=ret*a,0:0;
    a=a*a;
    k>>=1;
  }
  return ret;
}

int n;
ll k;

main() {
  cin>>n>>k;
  Matrix A(n,n);
  for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
      scanf("%lld",&A[i][j]);
  ksm(A,k).print();
}
```

---

## 作者：EternalEpic (赞：1)

做这题首先要会快速幂， 如果不会请移步[快速幂入门](https://www.luogu.org/blog/lzzoj666/solution-p1226)

矩阵是什么玩意儿？ 你可以姑且认为一个二维数组。

那两个矩阵如何相乘呢？ C(i, j) = A(i, j) * B(i, j)？

当然不是这样的啦。

矩阵乘法只有当矩阵A的列数与矩阵B的行数相等时A × B才有意义。

一个m × n的矩阵A(m, n)左乘一个n × p的矩阵B(n, p)，会得到一个m × p的矩阵C(m, p)

怎么实现？ C(i, j) = A(i, 1) X B(1, j) + A(i, 2) X B(2, j) + ... + A(i,n) X B(n,j);

由矩阵乘法的运算法则，我们得出下列结论：矩阵乘法满足结合律不满足交换律。

Ok，理论部分完毕， 下面看代码：

首先，要有一个结构体存矩阵

```
struct Node_Matrix {
	T g[S << 1 | 1][S << 1 | 1];
	inline void clear(void)
	{memset (g, 0, sizeof g );}
} Minfo; typedef Node_Matrix M;
```

乘法？

```
inline M matrix_multiple(const M x, const M y)
{
	M z; z.clear();
	for (register int i = 1; i <= n; i++)
		for (register int j = 1; j <= n; j++) if (x.g[i][j])
			for (register int k = 1; k <= n; k++)
				z.g[i][k] += x.g[i][j] * y.g[j][k], z.g[i][k] %= mod;
	return z;
}
```

当然， 我不反对重载运算符 这里就不给出来完整代码了

```
inline M operator * (const M&opt) const {
	...
    return ...;
}
```

好，接着就是快速幂了鸭！

```
inline void matrix_quickpow()
{
	M res;
	for (register int i = 1; i <= n; i++)
		res.g[i][i] = 1; /*构建单位矩阵*/
				
	while (k)
	{
		if (k & 1)
			res = matrix_multiple(res, Minfo);
		Minfo = matrix_multiple(Minfo, Minfo);
		k >>= 1;
	}
	print(res);
}
```

完整代码如下：

```
#include <bits/stdc++.h>
#include <queue>
#include <set>
#include <vector>
#include <deque>

#define rep(i,n) for (register int i = 1; i <= n; i++ )
#define rup(i,x,y) for (register int i = x; i <= y; i++ )
#define rdown(i,x,y) for (register int i = x; i >= y; i-- )
#define lowbit(x) x & -x

#pragma GCC optimize(3)

using namespace std;

inline char gc(void)
{
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}

template <class T> inline void read(register T &x)
{
	register long long flag = 1;
	x = 0; register char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') flag = -1;
	for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	x *= flag; return;
}


template <class T> inline void write(register T x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

template <class T> inline void writeln(register T x)
{
    write(x);
    puts("");
}

template <class T> inline void writeln(register T x, char c)
{
	write(x); putchar(c);
}

template <class T> inline void chkmax(T &X, const T Y)
{
	X > Y ? X = X : X = Y;
}

template <class T> inline void chkmin(T &X, const T Y)
{
	X < Y ? X = X : X = Y;
}

inline void file_open(string str)
{
	freopen((str + ".in").c_str(), "r", stdin);
	freopen((str + ".out").c_str(), "w", stdout);
}

inline void file_clo(void)
{
	fclose(stdin);
	fclose(stdout);
}

typedef long long ll;

enum {
	mod = 1000000007
};

template <typename T, int S>
class Matrix {
	private:
		int n; ll k;
		struct Node_Matrix {
			T g[S << 1 | 1][S << 1 | 1];
			inline void clear(void)
			{memset (g, 0, sizeof g );}
		} Minfo; typedef Node_Matrix M;
		
	public:
		inline void build(void)
		{
			read(n); read(k);
			for (register int i = 1; i <= n; i++)
				for (register int j = 1; j <= n; j++)
					read(Minfo.g[i][j]);
		}
		
		inline M matrix_multiple(const M x, const M y)
		{
			M z; z.clear();
			for (register int i = 1; i <= n; i++)
				for (register int j = 1; j <= n; j++) if (x.g[i][j])
					for (register int k = 1; k <= n; k++)
						z.g[i][k] += x.g[i][j] * y.g[j][k], z.g[i][k] %= mod;
			return z;
		}
		
		inline void print(M x)
		{
			for (register int i = 1; i <= n; i++)
			{
				for (register int j = 1; j < n; j++)
					writeln(x.g[i][j], ' ');
				writeln(x.g[i][n]);
			}
		}
		
		inline void matrix_quickpow()
		{
			M res;
			for (register int i = 1; i <= n; i++)
				res.g[i][i] = 1;
				
			while (k)
			{
				if (k & 1)
					res = matrix_multiple(res, Minfo);
				Minfo = matrix_multiple(Minfo, Minfo);
				k >>= 1;
			}
			print(res);
		}
};

Matrix <ll, 105> m;

int main(void)
{
	m.build(); 
	m.matrix_quickpow();
    return 0;
}



```

谢谢兹磁！

---

## 作者：娄口肃行 (赞：1)

+ # 一道肥肠好的膜版题...交了n次之后怒写一发题解

+ #### 套用模板：[取余运算][1]

[1]:https://www.luogu.org/problemnew/show/P1226

+ #### 以及矩阵乘法(推荐使用网上的[矩阵乘法计算器][2]进行调试，想学习矩阵乘法的戳[这里][3])

[2]:http://www.yunsuanzi.com/matrixcomputations/solvematrixmultiplication.html
[3]:https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/5446029?fr=aladdin

+ 本蒟蒻并没有写重载运算符，写了三个子函数

+ 主要思路：利用快速幂的规律进行矩阵乘法，然后写矩阵乘法的子程序(更清楚点).注意：先将答案数组赋值为矩阵A,再将p-1，否则要出事情。我全开long long是为了防止炸范围...有些开int也是可以的

+ ps:指出数据的一个错误...数据里说|矩阵中每个元素|<1000,所以元素可能是负数，然而负数取膜要加到正数再取膜...没有判也对了

+ ## 下面贴代码

----------------



```
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
long long Matrix_in[110][110],Matrix2[110][110],Matrix_Ans[110][110];
long long n;
long long p;
```
----------------

+ ### 以上为定义部分

----------------
```
void cheng2()//矩阵乘法之自己平方，Matrix2为中间量
{
    memset(Matrix2,0,sizeof(Matrix2));//初始化
    for (long long i=1;i<=n;i++)
        for (long long j=1;j<=n;j++)
            for (long long k=1;k<=n;k++)
                Matrix2[i][j]=(Matrix2[i][j]+Matrix_in[i][k]*Matrix_in[k][j])%mod;//矩阵乘法
    memcpy(Matrix_in,Matrix2,sizeof(Matrix2));
    //把平方之后的数组置回原数组
}
```
----------------
```
void cheng1()//矩阵乘法之乘进答案
{
    memset(Matrix2,0,sizeof(Matrix2));
    for (long long i=1;i<=n;i++)
        for (long long j=1;j<=n;j++)
            for (long long k=1;k<=n;k++)
                Matrix2[i][j]=(Matrix2[i][j]+Matrix_Ans[i][k]*Matrix_in[k][j])%mod;
    memcpy(Matrix_Ans,Matrix2,sizeof(Matrix2));
}//原理和上一个子程序一样
```
----------------
```
void kuaisumi()//快速幂
{
    while (p>0)
    {
        if (p%2==1) cheng1();
        cheng2();
        p=p>>1;
    }
}
```
----------------

## 快速幂方法详见取余运算

----------------
```
int main()
{
    scanf("%lld%lld",&n,&p);
    for (long long i=1;i<=n;i++)
        for (long long j=1;j<=n;j++)
        {
            scanf("%lld",&Matrix_in[i][j]);
            Matrix_Ans[i][j]=Matrix_in[i][j];
        }//读入
    p--;//由于Matrix_Ans已经是Matrix^1，所以p-1
    kuaisumi();//进入快速幂
    for (long long i=1;i<=n;i++)
    {
        for (long long j=1;j<=n;j++)
            printf("%lld ",Matrix_Ans[i][j]%mod);
        printf("\n");
    }//输出
}
```
----------------

---

## 作者：Fuko_Ibuki (赞：1)

我这个神奇的码风会被人吐槽的吧。具体看代码注释就可以了。

```cpp
//模板很好写的。如果说是在实战中运用，矩阵初始化是关键。在这里写起来不用思考，难度可能是假的普及。还好刚才没过审核，不然要被人笑话了。
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//对于mod1e9+7的乘法还是需要long long的。
const ll mod=1e9+7;
ll n,k;

struct juzhen{//定义了一个结构体，这样的话存储的时候看起来不会这么迷，不用返回一个二维数组。如果不是模板你可能要加一个矩阵长宽进去。
ll m[105][105];
juzhen(){memset(m,0,sizeof m);}
void clearit(){for (int i=1;i<=100;i++) m[i][i]=1;}//注意矩阵+1的话是主对角线上的数字加1.同理初始化也是如此。
};

inline ll read()//快读不用解释吧
{
ll x=0;char c=getchar();
for (;!isdigit(c);c=getchar());
for (;isdigit(c);c=getchar()) x=x*10+c-'0';
return x;
}

juzhen operator *(juzhen a,juzhen b)//重载了一个乘号。如果是用函数的话在下面使用的时候只是看起来不一样而已。比如说a*b看起来就会像chengfa(a,b),实际上并没有什么区别。
{
juzhen result;
for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) for (int k=1;k<=n;k++) result.m[i][j]=(result.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
return result;
}

juzhen quick_power(juzhen a,ll b)//和普通数字的快速幂没什么两样。重载乘号之后看起来就更简单了。如果把矩阵初始值设为a，k就要减1，但是这里你乘一下会发现对角线为1的矩阵乘法就相当于数字1做乘法了，所以k就不用减了。
{
juzhen result;result.clearit();
for (;b;b/=2,a=a*a) if (b%2) result=result*a;//你以为快速幂的代码要写几行？
for循环中两分号之间的是循环持续条件，后面的是每一次循环必定会做的后续语句。在for (i=1;i<=n;i++)当中不管后面发生什么，当一次循环结束的时候i便会+1，即使你用了continue也是一样。所以用了for循环以后快速幂只要一句话。用了位运算会更快一些，这里我并没有用。
return result;
}

int main()//主程序就比较好理解了。同理可以定义ll result=quick_power(a,k)(这里的a,k都是long long型的变量)
{
n=read(),k=read();
juzhen a;
for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) a.m[i][j]=read();
juzhen result=quick_power(a,k);
for (int i=1;i<=n;i++,puts("")) for (int j=1;j<=n;j++) printf("%lld ",result.m[i][j]);
}//和数字快速幂并没有什么区别吧。
```

---

## 作者：I_AM_HelloWord (赞：1)

把模板题模板化，会使main主函数显得非常优美。

简单说一下矩阵乘法吧，

假设我们有一个n行m列的矩阵a，和m行n列的矩阵b，设a\*b后的结果为矩阵c，

则c的第i行第j列的数字就是第i行的每一列的a[i][k]与每一行的第j列的b[k][j]的乘积进行累和。

楼下dalao的图确实画的很好，可以结合他的图理解我的这句话。

参考代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long LL;
const LL Mod=1e9+7;
int n;
LL k;
struct Matrix{
    static const int N=101;
    int n;
    LL h[N][N];
    void clear(int n){
        this->n=n;
        memset(h,0,sizeof(h));
    }
    friend ostream& operator  << (ostream&,Matrix&);
    friend istream& operator >> (istream&,Matrix&);
    Matrix operator * (const Matrix &t) const{
        Matrix b;b.clear(n);
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++){
                LL sum=0;
                for (int k=1;k<=n;k++)
                    sum+=h[i][k]*t.h[k][j],sum%=Mod;
                b.h[i][j]=sum;
            }
        return b;
    }
    Matrix operator ^ (LL k)const {
        Matrix t=(*this),ans=(*this);
        for (k--;k;k>>=1,t=t*t)
            if (k&1)ans=ans*t;
        return ans;
    }
}a;
istream& operator >> (istream& input,Matrix &x){
    for (int i=1;i<=x.n;i++)
        for (int j=1;j<=x.n;j++)
            input>>x.h[i][j];
    return input;
}
ostream& operator << (ostream& output,Matrix &x){
    for (int i=1;i<=x.n;i++){
        for (int j=1;j<=x.n;j++)
            output<<x.h[i][j]<<" ";
        output<<endl;
    }
    return output;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>k;
    a.clear(n);
    cin>>a;
    Matrix ans=a^k;
    cout<<ans;
    return 0;
}
//看这个main多么的优美，看着都舒服。
```

---

## 作者：Enzymii (赞：1)

刚刚楼下说自己码风较迷，特来叫板。。

我是一个喜欢把模板写得模板的人。。。所以我写了一个矩阵的类。。。

###时间复杂度 别提了。。。

###代码长度    别提了。。。

还杂糅了这题根本用不上的+/-……

快速幂做这个题的大伙肯定都会了吧，不然可以去各大题解看看……比如**禽兽的传染病**？【安利自己题解的时候到了】

然后只要重载乘法，剩下的一模一样啊……就这个样吧，再写你们是不是要用小拳拳捶我胸口了【雾】2333~

代码：

‘’‘cpp

```cpp
#include <cstdio>
#include <iostream>
#define gc getchar
#define LL long long
void qin(LL &a)
{
    a=0; char c=gc(); bool f=0;
    for(;(c<'0'||c>'9')&&c!='-';c=gc());
    if(c=='-') f=1,c=gc();
    for(;c>='0'&&c<='9';c=gc()) a=(a<<1)+(a<<3)+c-'0';
    if(f) a=-a;
}
```
class matrix
{
public:

    
void output(){                                            //快速输出

    
    
    
    
    
    
    
    
    
    
    
    
```cpp
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++)
                putnum(data[i][j]%MOD),
                putchar(' ');
            puts("");
        }
    }
    matrix(int x,int y,int mod):m(x),n(y),MOD(mod){            //构造函数 
    }
    matrix() {                                                //+1重载 
    }
    void matrix_init(){                                        //读入式矩阵初始化 
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
                data[i][j]=getnum();
    }
    void matrix_init(int **a){                                //+1重载  赋值式矩阵初始化 
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
                data[i][j]=a[i][j];
    }
    matrix operator +(const matrix &b){                        //重载+运算符 矩阵加法 没用*1 
        matrix c=matrix(m,n,MOD);
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++){
                c.data[i][j]=data[i][j]+b.data[i][j];
                if(MOD) c.data[i][j]%=MOD;
            }    
        return c;                
    }
    void operator +=(const matrix &b){                        //重载+=运算符 没啥卵用 没用*2 
        *this=*this+b;
    }
    matrix operator -(const matrix &b){                        //重载-运算符 矩阵减法 没用*3 
        matrix c=matrix(m,n,MOD);
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++){
                c.data[i][j]=data[i][j]-b.data[i][j];
                if(MOD) c.data[i][j]%=MOD;
            }
        return c;
    }
    void operator -=(const matrix &b){                        //重载-=运算符 没啥卵用 没用*4 
        *this=*this-b;
    }
    matrix operator *(const matrix &b){                        //重载*运算符 终于有用了。。。。 
        matrix c=matrix(m,n,MOD);
        for(int i=0;i<m;i++)
            for(int j=0;j<b.n;j++){
                LL ans=0;
                for(int k=0;k<n;k++){
                    ans+=data[i][k]*b.data[k][j];
                    if(MOD) ans%=MOD;
                }
                c.data[i][j]=ans;
            }
        return c;
    }
    void operator *=(const matrix &b){                        //重载*=运算符 除了偷懒没啥卵用 没用*5 
        *this=*this*b;
    }
    matrix operator ^(LL b){                                //重载^运算符 这次不是异或是乘方( ⊙ o ⊙ )啊！ 
        matrix ans=*this,t=*this; b--;
        for(;b;b>>=1,t*=t){
            if(b&1) ans*=t;
        }
        return ans;
    }
```
private:


    
    
    


```cpp
    static const int MAXN=101;
    int m,n,MOD;                                            //长 宽 模数 
    LL data[MAXN][MAXN];                                    //数据域 
    LL getnum(){                                            //快读 
        int a=0; char c=gc(); bool f=0;
        for(;(c<'0'||c>'9')&&c!='-';c=gc());
        if(c=='-') f=1,c=gc();
        for(;c>='0'&&c<='9';c=gc()) a=(a<<1)+(a<<3)+c-'0';
        if(f) a=-a;
        return a;
    }
    void putnum(int num){                                    //快速输出int 
        int c[12],cnt=0;
        for(;num;num/=10)
            c[++cnt]=num%10;
        for(;cnt;cnt--) putchar(c[cnt]+'0');
    }
    void putnum(LL num){                                    //+1重载 快速输出long long 
        int c[24],cnt=0;
        for(;num;num/=10)
            c[++cnt]=num%10;
        for(;cnt;cnt--) putchar(c[cnt]+'0');
    }
};
int main()
{
    LL n,k; qin(n); qin(k);
    matrix a=matrix(n,n,(int)1e9+7);
    a.matrix_init();
    matrix c=a^k; c.output();                                //so easy!
}
'''
```

---

## 作者：y553546436 (赞：1)

看到没有C的题解 ， 就发一个玩玩。。【从来没发过题解不喜勿喷

定义矩阵结构体和\*号  然后快速幂代码就和整数快速幂一样了

这里使用位运算 可以加快速度

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL mod=1000000007;
int n;
struct Matrix{
    LL a[105][105];
    Matrix operator * (const Matrix &x)const
    {
        Matrix res;
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
            {
                res.a[i][j]=0;
                for (int k=1;k<=n;k++)
                    res.a[i][j]=(res.a[i][j]+a[i][k]*x.a[k][j])%mod;
            }
        return res;
    }
}x,ans;
int main()
{
    LL k;
    ios::sync_with_stdio(false);
    cin>>n>>k;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
        cin>>x.a[i][j];
    ans=x,k--;
    while (k)
    {
        while ((k&1LL)==0) x=x*x,k>>=1LL;
        ans=ans*x;
        k>>=1LL,x=x*x; //位运算一定要加括号！！ 
    }
    for (int i=1;i<=n;i++)
    {
        cout<<ans.a[i][1];
        for (int j=2;j<=n;j++)
            cout<<" "<<ans.a[i][j];
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：kczno1 (赞：1)

有时候矩阵乘法不用快速幂可能会更快。（当然相乘的矩阵不同）

比如1\*n要乘n\*n的t次，直接乘是n^2\*t,快速幂是n^3\*log2(t)

矩阵a\*b=c->c[i,j]=a[i,k]\*b[k,j] k=1..n

乘一次时间n^3 用快速幂就只用乘log2(t)次

···





```cpp
type arr=array[1..100,1..100] of int64;
var
 y:int64;
 n,i,j,k:longint;
 a,ans,c:arr;
procedure cheng(var a,b:arr);
begin
 for i:=1 to n do
 for j:=1 to n do
 begin
  c[i,j]:=a[i,1]*b[1,j] mod 1000000007;
  for k:=2 to n do
   c[i,j]:=(c[i,j]+a[i,k]*b[k,j]) mod 1000000007;
 end;
 for i:=1 to n do
 for j:=1 to n do
  a[i,j]:=c[i,j];
end;
begin 
 readln(n,y);
 for i:=1 to n do
 for j:=1 to n do
  read(a[i,j]);
 ans:=a;dec(y);
 while y>0 do
 begin
  if y and 1=1 then cheng(ans,a);
  cheng(a,a);y:=y>>1;
 end;
 for i:=1 to n do
 begin
  for j:=1 to n do
   write(ans[i,j],' ');
  writeln;
 end;
end.
```
···

---

## 作者：zx2003 (赞：1)

const mo=1000000007;

type
 matrix=record

data:array[1..100,1..100] of int64

```cpp
 end;
var
 n,k:int64;
 a:matrix;
 i,j:longint;
operator *(a,b:matrix)c:matrix;
var
 i,j,k:longint;
begin
 fillchar(c,sizeof(c),0);
 for i:=1 to n do
  for j:=1 to n do
   for k:=1 to n do
    c.data[i,k]:=(c.data[i,k]+a.data[i,j]*b.data[j,k]) mod mo
end;
function quickpow(x:int64):matrix;
var
 u:matrix;
begin
 if x=1 then exit(a);
 u:=quickpow(x shr 1);
 if x xor (x shr 1 shl 1)=1 then exit(u*u*a)
  else exit(u*u)
end;
procedure writematrix(x:matrix);
begin
 for i:=1 to n do
 begin
  for j:=1 to n do write(x.data[i,j],' ');
```
writeln
```cpp
 end
end;
begin
 readln(n,k);
 for i:=1 to n do
  for j:=1 to n do read(a.data[i,j]);
 writematrix(quickpow(k))
end.
裸做即可，另：pascal也可重载运算符，以增强程序可读性
```

---

## 作者：AcerMo (赞：0)

看楼下那么多的大佬都用的结构体封装，那我这么弱只能用数组了，矩阵啥的我就不讲了，说一下那个快速幂的函数，我们通过普通快速幂可以知道有一个判断奇偶的过程，当然我们也要有，而且和快速幂是同一个函数，那么我们怎么知道当前是什么呢？加一个ｆｌａｇ就好啦！
代码
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=200;
const int mod=1000000007;
long long int a[M][M];
long long int b[M][M];
long long int n,p;
void mulself(long long int a1[M][M],long long int b1[M][M],int flag)
{
	long long int c[M][M]={0};
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			for (int k=1;k<=n;k++)
				c[i][j]=(c[i][j]%mod+a1[i][k]*b1[k][j]%mod)%mod;
	if (flag) memcpy(a,c,sizeof(c));
	else memcpy(b,c,sizeof(c));
	return ;
}
void poww()
{
	long long int emm=p;
	while (emm)
	{
		if (emm&1) mulself(b,a,0);
		mulself(a,a,1);
		emm>>=1;
	}
	return ;
}
int main()
{
	scanf("%lld%lld",&n,&p);
	for (int i=1;i<=n;i++)
		for (int k=1;k<=n;k++)
			scanf("%lld",&a[i][k]);
	for (int i=1;i<=n;i++) b[i][i]=1;
	poww();
	for (int i=1;i<=n;i++)
	{
		for (int k=1;k<=n;k++)
			cout<<b[i][k]<<" ";
		puts("");
	}
	return 0;
}
```

---

## 作者：罗旅洲 (赞：0)

/\*主程序最短，没有更短\*/

```cpp
#include<iostream>
#include<cstdio>
#define For(i,a,b) for(register int i=a;i<=b;++i)
#define LL long long
const int mod=1e9+7;
using namespace std;
LL read(){
    char x=getchar(); LL u=0,fg=0;
    while(!isdigit(x)){if(x=='-') fg=1; x=getchar();}
    while(isdigit(x)) u=(u<<3)+(u<<1)+(x^'0'), x=getchar();
    return !fg?u:-u;
}
struct Matrix{
    LL n,k,a[110][110];
    void work(bool type){                    //work(0)是读入,work(1)是输出，所以代码短啊~
        if(!type){ n=read(); k=read();}
        For(i,1,n){
            if(i >1 && type)printf("\n");
            For(j,1,n) if(!type) a[i][j]=read(); else printf("%d ",a[i][j]);
        }
    }
    Matrix operator *(const Matrix &b) const{            //矩阵乘法
        Matrix res=b;
        For(i,1,n) For(j,1,n){
            res.a[i][j]=0;                        //res赋初值
            For(k,1,n) res.a[i][j]=(res.a[i][j]+a[i][k]*b.a[k][j]%mod)%mod;    //记得取模
        }
        return res;
    }
    friend Matrix operator ^(Matrix x, LL num){  //矩阵快速幂
        Matrix res=x;        //res=x，其实只要把x的n值赋给res
        For(i,1,res.n) For(j,1,res.n)
            if(i==j) res.a[i][j]=1;                //单位矩阵的主对角线为1
            else res.a[i][j]=0;
        while(num){
            if(num&1) res=res*x;
            x=x*x;
            num>>=1;
        }
        return res;
    }
}x;
int main(){
    x.work(0); x=x^x.k; x.work(1); return 0;
}

```

---

## 作者：碳碳双键！ (赞：0)

某蒟蒻的矩阵快速幂

代码画风较迷  不喜勿喷

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
typedef long long ll;
using namespace std;

ll n,m,i,j,k;

struct Matrix{
    ll a[105][105];
    inline Matrix operator *(const Matrix &b)const
    {
        Matrix ret;
        for (ll i=1;i<=n;i++)
            for (ll j=1;j<=n;j++)
            {
                ret.a[i][j]=0;
                for (ll k=1;k<=n;k++)
                    ret.a[i][j]+=a[i][k]*b.a[k][j],ret.a[i][j]%=1000000007;
            }
        return ret;
    }
}a;

inline ll read()
{
    ll iep=1,ret=0;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') iep=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
    return ret*iep;
}

Matrix ksm(Matrix a,ll x)
{
    Matrix ret,k;k=a;
    ret=a;x--;
    for (;x;x>>=1,k=k*k)
        if (x&1) ret=ret*k;
    return ret;
}

int main()
{
    n=read();k=read();
    for (i=1;i<=n;i++)
        for (j=1;j<=n;j++)
            a.a[i][j]=read();
    a=ksm(a,k);
    for (i=1;i<=n;i++)
    {
        for (j=1;j<n;j++) printf("%d ",a.a[i][j]);
        printf("%d\n",a.a[i][n]);
    }
}
```

---


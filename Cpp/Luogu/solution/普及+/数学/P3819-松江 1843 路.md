# 松江 1843 路

## 题目描述

涞坊路是一条长 $L$ 米的道路，道路上的坐标范围从 $0$ 到 $L$，路上有 $N$ 座房子，第 $i$ 座房子建在坐标为 $x_i$ 的地方，其中住了 $r_i$ 人。

松江 1843 路公交车要在这条路上建一个公交站，市政府希望让最多的人得到方便，因此希望所有的每一个的居民，从家到车站的距离的**总和**最短。

公交站应该建在哪里呢？

## 说明/提示

### 样例解释 1

当建在坐标 $40$ 的时候，所有人距离车站的距离总和为 $|20-40| \times 3+|50-40| \times 2+|70-40| \times 1=110$。

### 数据范围和约定

对于 $10\% $的数据，$1\le N \le 50$，$R_i=1$。

对于 $30\%$ 的数据，$1 \le N \le 100$，$R_i \le 10$，$1 \le L \le 1000$。

对于 $70\%$ 的数据，$1 \le N \le 1000$，$R_i \le 100$，$1 \le L \le 10^6$。

对于全部数据，$1 \le L \le 10^{10}$，$1 \le N \le 10^5$，$0 \le x_i \le L$，$1 \le r_i \le 1000$。

## 样例 #1

### 输入

```
100 3
20 3
50 2
70 1
```

### 输出

```
110
```

## 样例 #2

### 输入

```
100 2
0 1
100 10
```

### 输出

```
100
```

## 样例 #3

### 输入

```
10000000000 5
3282894320 391
4394338332 929
6932893249 181
7823822843 440
9322388365 623
```

### 输出

```
5473201404068
```

# 题解

## 作者：_Lemon_ (赞：27)

本题乍一看毫无头绪，但只要在纸上手算一下样例就能发现本题的关键，其实就是模拟

首先设本题答案为ans

我们知道，车站一定是修在第一间房子和最后一间房子之间。

所以ans至少是 第一间房子和最后一间人数最小值 乘以 两间房子的距离。

然后将人数少的那间清空，指针更新，人数多的那间减去人数少的。

一直这么运算，直到只剩下一间房屋有人，那公交站肯定是修在他家门口啦。

        
```cpp
#include<bits/stdc++.h>
using namespace std;
long long s[100001],people[100001];
int main()
{
    long long n,l,k,i,end,tou;//end指当前的最后一间房屋，tou只当前第一间房屋。
    long long ans=0;
    cin>>l>>n;
    for(i=1;i<=n;i++)
      cin>>s[i]>>people[i];
    end=n;
    tou=1;
    while(end>tou)
    {
        k=min(people[tou],people[end]);
        people[tou]-=k;
        people[end]-=k;
        ans+=k*(s[end]-s[tou]);
        if(people[end]==0) end--;
        if(people[tou]==0) tou++;//如果房间被清空，则指针变动.
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：hanzhongtlx (赞：9)

# ~~你们这些大佬只会求中位数~~
### ————————讲一种函数（前缀和优化）的方法   
我们以样例1为例，总路程不妨设为$s$，则   
$s=3|x-20|+2|x-50|+|x-70|$,这便是一个分段函数：    
$s=\begin{cases}60-3x+100-2x+70-x=-6x+230&0\leqslant x\leqslant20\\3x-60+100-2x+70-x=110&20\leqslant x\leqslant50\\3x-60+2x-100+70-x=4x-90&50\leqslant x\leqslant70\\3x-60+2x-100+x-70=6x-230&70\leqslant x\leqslant100\end{cases}$   
(当然我并没有让他不重不漏）  
发现可以分段讨论最小值！        
想到了暴力，由于分$n$段计算，计算$n+1$次，时间复杂度$O(n^2)$   
#### 优化   
发现只有斜率$k$与截距$b$变化（还用说？），分别来看：    
$1.$当计算第$i$段的斜率$k_i$时,总有：(想一想斜率的运算过程)  
  $k_i=\begin{cases} -\sum\limits_{j=1}^nr_j&i=1\\k_{i-1}+2r_{i-1}&i>1\end{cases}$     
$2.$同理还可脑补截距$b_i$的特点:  
  $b_i=\begin{cases} \sum\limits_{j=1}^n{r_j*x_j}&i=1\\b_{i-1}-2r_{i-1}*x_{j-1}&i>1\end{cases}$     
然后就可以$O(n)$知道每个区间的最值了,ta就是每个区间的右端点值了。（先$O(n)$预处理前缀和）   
不过还有一个问题，斜率为正时，最小值出现在区间左端点！！！！    
首先这个分段函数的图像是首尾相接的折线，若最大值为左端点，这条直线的最大值是他下一条线的最小值了，这样便能更新所有直线。
## Code:
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
long long n,m;
struct node
{
	long long x,r;
}e[500005];
long long ans,b,k;
bool cmp(node n,node m)
{
	return n.x<m.x;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%lld",&e[i].x,&e[i].r);
	}
	sort(e+1,e+m+1,cmp);//e没+1卡了多次
	e[m+1].x=n;
	for(int i=1;i<=m;i++)
	{
		k-=e[i].r;
	}
	for(int i=1;i<=m;i++)
	{
		b+=e[i].x*e[i].r;
	}
	ans=k*e[1].x+b;
	for(int i=1;i<=m;i++)
	{
		b-=2*e[i].x*e[i].r;
		k+=2*e[i].r;
		long long now=k*e[i+1].x+b;
		if(now>0) ans=min(ans,now);//保险起见
	}
	printf("%lld",ans);
	return 0;
}
```
那话又说回来了，这个函数似乎是可以证明中位数的做法正确性的：     
我们发现这个分段函数总体是个先单调递增后单调递减的函数，最小值一定出现在斜率最接近$0$的地方。    
我们发现预处理后的$k_1$是$ -\sum\limits_{j=1}^nr_j$而做和的过程中加上了$ 2\sum\limits_{j=1}^nr_j$,中位数（可以说是平均数）可以保证斜率最接近$0$。

---

## 作者：BlueArc (赞：8)

###题目转换：给定数轴上的n个点，找出一个到它们的距离之和尽量小的点

本题只不过有权值(人数)r，但把它看成r个相同的点就可以转化到上述问题了

##猜想:这个最优点就是这些数的中位数(排序后在中间的数)

##证明先把数轴和上面的点画出来:

  ![](https://cdn.luogu.com.cn/upload/pic/6126.png) 

任意找一个点，比如图中的大灰点,它的左边有4个点，右边两个。

现在我们尝试把它移动一点，比较距离和。

1.向左移一点点,假设移动了x距离,则灰点左边4个点到它的距离各减少了x，总共减少s1=4x

灰点右边两个点到它的距离各增加了x，总共增加s2=2x；6个点的距离和减少了4x-2x=2x;

换句话说，向左移的解更优。

2.向右移一点点，同上分析，得到的解会增加2x,不会更优

如果灰点左边两个点，右边4个，道理类似，不过应该向右移才能得到更优解。

左边2个右边4个要向右移；左边4个，右边2个又要向左移。

所以只有当灰点左右两边点一样多才是最优解。

##结论:如果输入点为奇数个，则灰点必须和中间那个点重合(中位数);

如果输入点位偶数个，则灰点可以在最中间两个点的任意位置(可以是中位数).

70分代码(看成r个相同的点):

```cpp
#include"cstdio"
#include"iostream"
#include"algorithm"
using namespace std;
long long a[10000005],len,tot;
int main()
{
 //freopen("data.in","r",stdin);
 //freopen("data.out","w",stdout);
 long long  n;
 cin>>len>>n;
 for(int i=1;i<=n;i++)
 {
  long long  x,p;
  cin>>x>>p;
  while(p--) a[tot++]=x;       
 } 
 sort(a,a+tot);
 long long  ans=a[tot/2];
 long long sum=0;
 for(long long  i=0;i<tot;i++) sum+=abs(a[i]-ans);
 cout<<sum;
 //system("pause");  
}        
```
这样会TLE或RE,因为人数可能很多
优化:最简单想法，不必一个一个加，因为他们相同，只需相乘就可以了。

**关键就在找到中位数.**

假设排完序后,人数分别为3，4，5，6;共15人,则中位数是第8个点，落在'5'上

一层循环,人数相加，sum>=8就表明中位数在这个范围内

```cpp
#include"cstdio"
#include"iostream"
#include"algorithm"
using namespace std;
typedef long long ll;
struct People
{
 ll x,r;
 bool operator <(const People& a) const{
  return x<a.x;//重载<供排序所需    
 }     
}a[100005];
int main()
{
 ll len,n,tot=0;
 cin>>len>>n;
 for(int i=1;i<=n;i++)
  {cin>>a[i].x>>a[i].r;tot+=a[i].r;}//总人数 
  tot=(tot+1)/2;//中位数在第几人上 
  sort(a+1,a+n+1);
  ll sum=0,mid,ans=0;
  for(int i=1;i<=n;i++)
  {
   sum+=a[i].r;
   if(sum>=tot) {mid=i;break;}//找灰点，即中位数       
  }
  for(int i=1;i<=n;i++)
  {
   ans=ans+abs(a[i].x-a[mid].x)*a[i].r;//计算总距离        
  } 
  cout<<ans;
  //system("pause");      
}
```

---

## 作者：MSM2004 (赞：7)

求|x-1|+|x-2|+|x-3|的最小值？这其实是一道初中奥数题。画一个数轴，所求的其实是x到1,2,3的最短距离和。
稍微推广一下，当|x-a1|+|x-a2|+|x-a3|......+|x-an|取最小值时，x为a1-an这个数列的中位数。这道题就变为求中位数的问题。
见代码
```
#include<bits/stdc++.h>
using namespace std;
const int M=1e5+100;
struct f
{
	long long x;//坐标
	int r;//人数
}s[M];
bool comp(const f &a,const f &b)
{
	return a.x<b.x;
}
int main()
{
	long long m;
	long long ans=0,sum=0;//ans用来统计人数和，sum用来计算距离和
	int n;
	cin>>m>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i].x>>s[i].r;
		ans+=s[i].r;
	}
	sort(s+1,s+n+1,comp);//按坐标进行升序排序
	long long mid=ans/2;//计算中位数
	int j=1;
	while(mid>0)
	{
		mid-=s[j].r;
		j++;
	}
	j--;//计算中位数对应下标
	long long k=s[j].x;
	for(int i=1;i<=n;i++)
	sum+=abs(s[i].x-k)*s[i].r;//求和
	cout<<sum;
	return 0;//完美结束
}
```


---

## 作者：Forgive_Me (赞：4)

## 这是一篇模拟退火的题解。

[原题](https://www.luogu.com.cn/problem/P3819)

### 题目描述

给出一条长 $L$ 米的道路，道路上的坐标范围从 $0$ 到 $L$，路上有 $N$ 座房子，第 $i$ 座房子建在坐标为 $x_i$ 的地方，其中住了 $r_i$ 人。

要求在这条路上找一个整数点，求每个居民从家到这个点的距离的**总和**最短，求这个最小值。

### 数据范围

$1 \le L \le 10^{10}$，$1 \le N \le 10^5$，$0 \le x_i \le L$，$1 \le r_i \le 1000$。

---
## Solution

容易得到，如果我们把 $x_0$ 点设为公交站，那么答案就表示为：

$\min(\large\sum_{i=1}^{n}r_i |x_0-x_i|)$ 

我们找到这个最小值点还是有很多方法的……

诶，暴力一点，直接模拟退火吧。

（不会模拟退火[出门右转](https://www.luogu.com.cn/problem/P1337)）

注意ans初值和long long，还有一些细节看代码吧。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int x,w;
};
node p[100010];	
int l,n,ans=1e18,ansx;
int calc(int x)//计算答案
{
	int now=0;
	for(int i=1;i<=n;i++) now+=abs(x-p[i].x)*p[i].w;
	return now;
}
void sa()//板子
{
	double st=100,ed=1e-17,delta=0.975;//最喜欢0.975
	for(double t=st;t>=ed;t*=delta)
	{
		int x=ansx+(rand()*2-RAND_MAX)*t;
		int sum=calc(x);
		int del=sum-ans;
		if(del<0) ans=sum,ansx=x;//优则更新
		else if(exp(-del/t)*RAND_MAX>rand()) ansx=x;//不优有一定概率更新
	}
}
signed main()
{
	//玄学 
	srand(rand());
	srand(rand());
	cin>>l>>n;
	for(int i=1;i<=n;i++) cin>>p[i].x>>p[i].w;
	int num=3;//总要跑几次 
	while(num--) sa();
	cout<<ans;
}
```

---

## 作者：Z_M__ (赞：3)

介绍一种 换根DP + 贪心 的做法：

- 把每个房子看做点，相邻两个房子建一条边，整条道路就为一棵树（也是一条链）。

- 贪心：最优方案中一定有**公交站建在房子坐标**的情况，样例$1$ 中公交站建在房子$1$ 处也是最优方案。

- 状态设置：运用换根的思想，设 $f[i]$ 为将公交站建在房子$i$ 时，所有居民到该点的距离和。

- 预处理：我们可以先预处理出 $f[1]$ 的值， 再统计居民人数的后缀和$sum[i]$。

- 转移：$f[i] = f[i - 1] - (x[i] - x[i - 1]) * sum[i]+(x[i] - x[i - 1] * (sum[1] - sum[i])$

转移分成三部分，

1. $f[i-1]$ 为以 $i-1$点 为根时的距离和。

2. $(x[i] - x[i - 1]) * sum[i]$，因为将根从 $i - 1$ 换到了 $i$， 所以$i \sim n$的点到 点$i$ 比 到 点$i-1$， 每个点都小了$x[i] - x[i- 1]$，所以总共少了$(x[i] - x[i - 1]) * sum[i]$

3. $(x[i] - x[i - 1]) * (sum[1] - sum[i])$，因为根换到了点$i$，所以$1 \sim (i-1)$的点到点$i$的距离总共多了$(x[i] - x[i - 1]) * (sum[1] - sum[i])$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline void read (int& num)
{
	int x = 0, f = 1;
	char ch = getchar ();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar ();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar ();
	}
	num = x * f;
}
const int MAXN = 1e5 + 10;
int l, n, ans;
int x[MAXN], r[MAXN], f[MAXN], sum[MAXN];
signed main ()
{
	read (l), read (n);
	for (int i = 1; i <= n; i++)
		read (x[i]), read (r[i]);
        
	for (int i = n; i >= 1; i--)
		sum[i] = sum[i + 1] + r[i];
        
	for (int i = 2; i <= n; i++)
		f[1] += (x[i] - x[1]) * r[i]; // 预处理出f[1]
        
	ans = f[1];
	for (int i = 2; i <= n; i++)
	{
		f[i] = f[i - 1] - (x[i] - x[i - 1]) * sum[i] + (sum[1] - sum[i]) * (x[i] - x[i - 1]);
		ans = min (f[i], ans);
	}
	cout << ans << endl;
	return 0;
}
```
做完这题，那么这[题](https://www.luogu.com.cn/problem/P3478)也不在话下


---

## 作者：_ztyqwq (赞：2)

~~这题有绿题？？？~~

先把房子按 $ x $ 排个序

考虑把车站建在第一座房子的位置上，不断往右边移（车站不可能建在第一座房子的左边）

每往右移一个坐标（坐标+1），题述中的**总和**就会增多或者减少。具体地说，对于所有在车站左边的居民，他们到车站的距离会+1,；对于所有在车站右边的居民，他们到车站的距离会-1。

然后我们可以算出这一次移位给总和的贡献是正的还是负的。如果左边人多，就是正的，否则就是负的。如果贡献是正的，那么就说明这样移位对结果不利。如果是负的，就说明这样移对结果有利。

容易发现，只有当车站到达居民点时，再往右移贡献会变化。所以我们可以只枚举车站在居民点的情况。而且因为车站不断往右移，所以贡献会不断变大。于是如果到一个点时，往右移的贡献为正，就不用继续移了（后面的肯定更差）

所以我们如果移到一个点，到此为止贡献为负，再往右移贡献为正，那么公交站就要建在这里（如果有一个是0那么这一段都可以）

换句话说，车站应该建在 $ i $ 点，使得 $ i $ 是满足 $ l_i \geqslant r_i $ 的最左点（$ l, r $ ~~意义自行脑补~~）也就是 $ l_i \times 2 \geqslant tot $

然后暴力统计答案

复杂度 $ O(n) $

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct house
{
    ll x,r;
    bool operator<(const house& ano)const
    {
        return x<ano.x;
    }
}a[100001];
int main()
{
    ll l,n,sum=0;
    scanf("%lld %lld",&l,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld %lld",&a[i].x,&a[i].r);
        sum+=a[i].r;
    }
    sort(a+1,a+n+1);
    ll tot=0,ans=0;
    int pos;
    for(int i=1;i<=n;i++)
    {
        tot+=a[i].r;
        if(tot*2>=sum)
        {
            pos=i;
            break;
        }
    }
    for(int i=1;i<=n;i++)
        ans+=abs(a[i].x-a[pos].x)*a[i].r;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Celebrate (赞：2)

点下面：

[我的博客](https://blog.csdn.net/zsyzClb/article/details/84328942)

这一道题一眼看上去好像没有什么头绪，不过有一句谚语说的好：“暴力出奇迹”

我看到这一题，就觉得应该会有某种规律，比如说这个最优点会出现在某个特定的位置

因此，我打了一个暴力程序和一个出数据的程序，来找每一个点的距离，时间是O(L)

我还打了一个前缀和的优化：

```cpp
假设当前在点k，那么左边距离总和就是
 
for(1-t) sum+=(k-x[i])*r[i]
 
用整式乘法得到
 
for(1-t) sum+=k*r[i]
for(1-t) sum-=x[i]*r[i]
 
两个式子分别用sum1[]和sum2[]来记录前缀和
 
 
 
右边的距离总和是
 
for(t+1 - n) sum+=(x[i]-k)*r[i]
 
用整式乘法得到
 
for(t+1 - n) sum+=x[i]*r[i]
for(t+1 - n) sum-=k*r[i]
 
两个式子也可以用sum1[]和sum2[]来记录前缀和

```

然后，我发现这个点好像总是在某个房子那里

为了验证这个猜想，我们应该用证明，但是我不会证明，于是我就打了一个对拍来判断是否满足这个猜想

对拍的时候每次判断vio.out是否为yes就行了

暴力程序如下:

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<queue>
#include<stack>
#include<cmath>
#include<map>
using namespace std;
inline int read(){
    int x=0,f=0;char s=getchar();
    while(!isdigit(s))f|=s=='-',s=getchar();
    while( isdigit(s))x=(x<<1)+(x<<3)+s-48,s=getchar();
    return !f?x:-x;
}
struct node{
	int x,r;
	inline bool operator<(const node k)const{
		return x<k.x;
	}
}a[110];
int n,L;
int sum1[110],sum2[110];
int main(){
	freopen("data.in","r",stdin);
	freopen("vio.out","w",stdout);
	L=read();n=read();
	for(int i=1;i<=n;i++)a[i].x=read(),a[i].r=read();
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		sum1[i]=sum1[i-1]+a[i].r,
		sum2[i]=sum2[i-1]+a[i].r*a[i].x;
	int now=1,minn=999999999,pos;
	for(int i=a[1].x;i<=a[n].x;i++){
		if(a[now+1].x==i)now++;
		int left=i*sum1[now]-sum2[now];
		int right=(sum2[n]-sum2[now])-i*(sum1[n]-sum1[now]);
		if(left+right<minn)minn=left+right,pos=i;
		else if(left+right==minn){
			if(a[now].x==i)
				pos=i;
			}
		//printf("%d ",left+right);
	}
	//printf("\n%d %d\n",minn,pos);
	for(int i=1;i<=n;i++)if(pos==a[i].x){printf("yes\n");return 0;}
	printf("no\n");
	return 0; 
}

```

相信自动生成数据的程序和对拍各位都会打

我对拍了十几分钟（我去写作业了），发现这个方案可行，于是就可以直接模拟了

时间复杂度O(nlogn)主要是快排的时间

代码（记得用longlong)：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<queue>
#include<stack>
#include<cmath>
#include<map>
using namespace std;
typedef unsigned long long ULL;
const int N=1e5+10;
struct node{
	ULL x,r;
	inline bool operator<(const node k)const{
		return x<k.x;
	}
}a[N];
int n;ULL L;
ULL sum1[N],sum2[N];
int main(){
	cin>>L>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].r;
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		sum1[i]=sum1[i-1]+a[i].r,
		sum2[i]=sum2[i-1]+a[i].r*a[i].x;
	ULL minn=1000000000000000010;
	for(int i=1;i<=n;i++){
		ULL left=a[i].x*sum1[i]-sum2[i];
		ULL right=(sum2[n]-sum2[i])-a[i].x*(sum1[n]-sum1[i]);
		if(left+right<minn)minn=left+right;
	}
	cout<<minn<<endl;
	return 0; 
}

```

# 骗分教学

如果在考场上，没有时间考虑方法了，就直接打部分分吧

反正

对于70%的数据1≤L≤10^6

其他的数据1<=L<=10^10

那我们就可以枚举每一个n

保险点，考场计算机每秒又10^8

那我们就可以用不超过10^8的时限

枚举每个房子周围的800个点（保险点嘛）

其实这样也可以歪打正着，拿到所有的分数

---

## 作者：lin_rany (赞：1)

看题解好像没有三分的，蒟蒻给一个三分的思路吧。我们考虑三分选址的位置x,令f(x)为公交站选在x时的每个人从家到车站的距离的总和。可以很明显知道f(x)是一个开口向上的二次函数。所以我们就能利用三分来解决这个问题了。
附上代码：
```cpp
#include<bits/stdc++.h>

#define ll long long
using namespace std;
template<class T>
void read(T& x)
{
	T res = 0, f = 1; char c = getchar();
	while (!isdigit(c)) {
		if (c == '-')f = -1; c = getchar();
	}
	while (isdigit(c)) {
		res = (res << 3) + (res << 1) + c - '0'; c = getchar();
	}
	x = res * f;
}
const ll N = 200000 + 10;
ll L, n, x[N], y[N],sum,ans=1e18;
ll calc(ll xt)
{
	ll nans = 0;
	for (int i = 1; i <= n; i++)nans += abs(x[i] - xt) * y[i];
	return nans;
}
int main()
{
	//ios::sync_with_stdio(false);
#ifndef ONLINE_JUDGE
	freopen("182.txt", "r", stdin);
#endif // ONLINE_JUDGE
	read(L), read(n);
	for (int i = 1; i <= n; i++)
	{
		read(x[i]), read(y[i]);
	}
	ll l = 0, r = L;
	while (l <= r-5)
	{
		ll nl = l + (r - l) / 3;
		ll nr = r - (r - l) / 3;
		ll tnl = calc(nl);
		ll tnr = calc(nr);
		if (tnl >= tnr)
		{
			l = nl;
			ans = min(ans, tnr);
		}
		else
		{
			r = nr;
			ans = min(ans, tnl);
		}
	}
	for (ll i = l; i <= r; i++)ans = min(ans, calc(i));
	printf("%lld\n", ans);
	return 0;
}

```


---

## 作者：Register (赞：1)

### 题目大意
有$n$栋房子，每栋房子坐标为$a_i$住了$x_i$个人

在某个地方建一个公交站，使得所有人到达这里的距离的和最短

问：距离和会是多少

注：$a_i$是递增的
### 解题思路
由于人的数量会很多，所以不可能一个一个人枚举

- 一个结论：**公交车站一定可以建在某栋房子处**

> 初始我们可以找一个房子试试看建在这里

> 接着要是左边人多了，公交站可以向右边移，反之向左边移

> 一定会有个地方会最平衡，其实就是中位数

> 这个地方要么是一个点，即一栋楼，要么会是一段区间，同样也包含了一栋楼

因此我们可以枚举每一个公交站比较他们左边所有的距离加上右边所有的距离

所以我们可以转移前缀和和后缀和

设前缀和为$sum_i$

那么$sum_i$就是比$sum_{i-1}$多上了前$i-1$栋楼的人数和乘以$a_i$与$a_{i-1}$的距离

后缀和同理
### 代码
```cpp
#include <cstdio>
#define int long long
int n,ans=1e18,a[100001],b[100001],s1[100001],s2[100001],l1[100001],l2[100001];
inline int read(){
	char ch=getchar();int res=0,w=1;
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
	return res*w;
}
inline int Min(int x,int y){
	return x<y?x:y;
}
signed main(){
	read();n=read();
	for(register int i=1;i<=n;i++) {a[i]=read();b[i]=read();}
	s1[1]=b[1];s2[n]=b[n];
	for(register int i=2;i<=n;i++) {s1[i]=s1[i-1]+b[i];s2[i]=s2[i-1]+s1[i-1]*(a[i]-a[i-1]);}
	for(register int i=n;i;i--) {l1[i]=l1[i+1]+b[i];l2[i]=l2[i+1]+l1[i+1]*(a[i+1]-a[i]);}
	for(register int i=1;i<=n;i++) ans=Min(ans,s2[i]+l2[i]);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Zarinopl (赞：1)

二分。

很显然从最优位置往两边推移，结果越来越大

所以我们只需找到函数唯一的最小点

有人说用三分，不过可以转化成二分。

上代码及注释

```cpp
#define int long long
int l,n,lt,rt=1e10,mid;
int loc[100001][2];
int chk(const int& r){
	int ans=0;
	lop(i,n) ans+=abs(r-loc[i][0])*loc[i][1];
	return ans;
}//计算题目要求的总距离 ，并进行比较 
signed main(signed argc,char** argv,char** envp){
	scanf("%lld%lld",&l,&n);
	lop(i,n) scanf("%lld%lld",&loc[i][0],&loc[i][1]);
	while(lt+1<rt){
		mid=(lt+rt)>>1;
		if(chk(mid)<=chk(mid-1)) lt=mid;//左边值比中点大，（最优点为该点或右半边）左边向中点推移
		else rt=mid;//左边值比中点小，（最优点在左半边），右边向中点推移
	}//二分查找最小点
	printf("%lld",min(chk(lt),chk(rt)));//（为了保险）
	exit(0);
}
```

---

## 作者：BFSDFS123 (赞：0)

想要更好的体验？来这里：

[洛谷博客](https://dfsbfs123.blog.luogu.org/solution-p3819)

[CSDN博客](https://blog.csdn.net/justin666888/article/details/108303394)

----


嗯，讲题之前，我先先普及一下前缀和的知识：

---

前置知识

前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。 

设 $b[]$ 为前缀和数组， $a[]$ 为原数组，根据这句话可以得到前缀和的定义式和递推式：


一维前缀和:

定义式：

$$b[i]=\sum_{j=0}^{i}a[j]$$

递推式：

$$b[i]=b[i-1]+a[i]$$

 二维前缀和:

定义式：

$$b[x][y]=\sum_{i=0}^{x}\sum_{j=0}^{y}a[i][j]$$

递推式：

$$b[x][y]=b[x-1][y]+b[x][y-1]-b[x-1][y-1]+a[x][y]$$

通用公式：

$$sum[i,j]=b[j]-b[i-1]$$


至于后缀嘛，看看前缀，反过来应该就行了。

----

 解析：

我们先假定大家都看懂了上面的东西

我们可以对房子按照坐标排序，对每一个房子，记一下前缀和后缀和（前面/后面房子中的人到当前房子的路程和），最后我们再扫一遍取前缀和和后缀和的和的 $\min$ 就可以了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int Maxn=100010;
LL Ansl[Maxn],Ansr[Maxn],ans=0x7fffffffffffffff; //ans要开的大一点点 
//long long是个好习惯 
LL suml[Maxn],sumr[Maxn];
LL l,n;
struct Node{
	LL x,r;
	bool operator<(Node &rhs)const{ //写cmp也是ok的呀
		return x<rhs.x;
	}
}Ar[Maxn];
int main()
{
	scanf("%lld%lld",&l,&n); //lld
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&Ar[i].x,&Ar[i].r);
	}
	sort(Ar+1,Ar+1+n);
	for(int i=1;i<=n;i++)
	{
		Ansl[i]+=suml[i-1]*(Ar[i].x-Ar[i-1].x)+Ansl[i-1];
		suml[i]+=suml[i-1]+Ar[i].r; //前缀和 
	}
	for(int i=n;i>=1;i--)
	{
		Ansr[i]+=sumr[i+1]*(Ar[i+1].x-Ar[i].x)+Ansr[i+1];
		sumr[i]+=sumr[i+1]+Ar[i].r; //后缀和 
	}
	for(int i=1;i<=n;i++)
	{
		ans=min(ans,Ansl[i]+Ansr[i]); //统计答案并取min 
	}
	printf("%lld",ans);
	return 0;
}
```

# 注意事项

1. 把ans开的大一点点，到 $2^{61}$ 就可以了，太小WA，太大WA。
2. 不开long long见祖宗。

---

## 作者：SisconHL (赞：0)

前置学习：海滨大道模型。

我们先设一个数组 $S$，$S$ 中的元素不减，且有 $r_i$ 个 $x_i$。

这就相当于把一堆人便乘一个一个一个一个一个人力！

然后我们让 $S_i,S_{n-i}$ 两个人配对，会发现设在 $[S_i,S_{n-i}]$ 会使得这俩人路程和最少。

然后我们设在中位数的位置，就会使得每一对路程和最小，这个问题就完力！

嗯，不，还有一点，你拆不了。

发现数据范围够小，于是我们从第一户人家逐渐往上进行人口普查，如果截止这一户小于一半且加上下一户多于一半，那么分总户数的奇偶。若为奇那就是这一户了，若为偶则是哪一边总量更多就选在哪儿。

嗯，就没了。

---

## 作者：说好不哭 (赞：0)

# 题解 P3819 【松江1843路】 
## 写此题解的重要原因，不是讲这题的做法（若想看做法及优化后的算法，可以参考前面题解），而是想要证明此题一个很显然的公式，这个公式好像别的题解都一笔带过没有说明为什么，（emm...也有可能我太弱了，这可能是个显然问题）但我还是想来说一下。
## ----------------------------------------------------------------

## 乍一看，为什么裸的带权中位数，还只要选一个车站的题，都是绿色的。所以马上就来切一下，结果发现WA了一个点，是由于精度原因。
## 我把问题想复杂了，本来我想求出中位数后算出答案，想到由于权值和可能为偶数，那么中位数可能是某两个数的和除以二，所以我感觉要用double类型存储与计算，下面是用实型实现的错误90分代码，大家可以不用管代码，但我还是贴一下吧。
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long N=1e6+5;
long long n,i,sum,L,now,x,y;
double ans,POS;

struct number{
long long pos,val;	
}num[N];
inline bool cmp(number a,number b){return a.pos<b.pos;}

int main(){
scanf("%lld%lld",&L,&n);
for (i=1; i<=n; i++) scanf("%lld%lld",&num[i].pos,&num[i].val),sum+=num[i].val;
sort(num+1,num+n+1,cmp);
    if (sum&1)
        {
        x=sum/2+1;
            for (i=1; i<=n; i++)
            {
            now+=num[i].val;
            if (now>=x) {POS=(double)num[i].pos; break;}
            }
        for (i=1; i<=n; i++)
        if ((double)num[i].pos-POS>0) ans+=(num[i].pos-POS)*num[i].val;
        else ans+=(POS-num[i].pos)*num[i].val;
        }
    else 
        {
        x=sum/2,y=sum/2+1;
            for (i=1; i<=n; i++)
            {	
            now+=num[i].val;
            if (now>=x)
                {
                if (now>=y) POS=(double)num[i].pos;	
                else POS=(num[i].pos+num[i+1].pos)/2.0;
                break;
                }
            }
        for (i=1; i<=n; i++)
        if ((double)num[i].pos-POS>0) ans+=(num[i].pos-POS)*num[i].val;
        else ans+=(POS-num[i].pos)*num[i].val;
        }
//printf("%.2lf\n",POS);
printf("%.0lf\n",ans);
return 0;
}

```
## 不知道什么具体数据与原因，反正就是不能用double。
## ----------------------------------------------------------------
## 现在来看一下正确代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long N=1e5+5;
long long n,i,sum,L,now,x,y,ans,POS;

struct number
	{
	long long pos,val;	
	}num[N];

inline bool cmp(number a,number b){return a.pos<b.pos;}

int main(){
	scanf("%lld%lld",&L,&n);
	for (i=1; i<=n; i++) 
	scanf("%lld%lld",&num[i].pos,&num[i].val),sum+=num[i].val;
sort(num+1,num+n+1,cmp);
	x=sum+1>>1;  //重点！！！
	for (i=1; i<=n; i++)
	{
	now+=num[i].val;
	if (now>=x) {POS=num[i].pos; break;}
	}
for (i=1; i<=n; i++) ans+=abs(num[i].pos-POS)*num[i].val;


printf("%lld\n",ans);
return 0;
}
```
## 对于是权值和为奇数的情况，没有任何问题，因为此时的中位数一定是一个原来出现过的位置数。但是，对于权值为偶数的情况，如果直接求中位数，就会可能出现上面的bug问题，那么现在我们可以得到结论，对于真正中位数，设x,那么它两端的点可设为a.pos和b.pos,则对于中位数是原始数据的数学定义上的中位数的答案，可记做：
## 端点a那一侧的点到端点a的距离和 + 端点b的那一侧到端点b的距离和 + 端点a那一侧的点和端点a到(b.pos-a.pos)/2的距离 + 端点b那一侧的点和端点b到(b.pos-a.pos)/2的距离。
## 经过画图推论，可得到 : 端点a那一侧的点和端点a到(b.pos-a.pos)/2的距离 + 端点b那一侧的点和端点b到(b.pos-a.pos)/2的距离 ， 可以表示为 ：二分之一的权值和 * （b.pos-a.pos）,得到这个结论后，那么如果把这个中位数的点，放在a,b两点间任意一点，都可以得到相同的正确答案，所以我们就这样解决了这个精度问题。
## 在程序中，我是直接把这个中位数点记录在a上。

---

## 作者：流星梦丶 (赞：0)

可以考虑递推记f[i]为在i出修车站的总距离 l[i]为i点左边及i点人数 r[i]为右边人数

则有  **f[i]=f[i-1]+l[i]-r[i]**

l[i]-r[i]显然是单调的

那么我们考虑最小只需要求出 l[i]-r[i]>=0 的临界点 先预处理出sum表示总人数

原不等式可以化简为** l[i]-(sum-l[i])>=0 **

然后用O(n)处理出距离就行了

代码如下


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<queue>
#include<vector>
#include<algorithm>
#define rep(o,t,k) for(int o=t;o<=k;o++)
using namespace std;
long long int l,num,sum,ans;
int n,p;
struct node{
    long long int x,r;
} a[100010];
bool cmp(struct node a,struct node b)
{
    return(a.x<b.x);
}
int main() 
{
    //freopen("stdin.in","r",stdin);
    scanf("%lld%d",&l,&n);
    rep(i,1,n)
    {
        scanf("%lld%d",&a[i].x,&a[i].r);
        num+=a[i].r;
    }
    p=0;
    while(sum<(num-sum))
    {
        p++;
        sum+=a[p].r;
    }
    rep(i,1,n) 
    {
        long long int ip=a[p].x-a[i].x;
        ans+=abs(ip)*a[i].r;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：litble (赞：0)

现在我们来证明车站建在一个房子处肯定能得到最优解:

假设在建车站的房子处有r个人，左边的路段上有A个人，右边的路段上有B个人。A>B

如果我现在把车站向右移动dis，那么答案更新量为dis\*(A+r)-dis\*B,显然是不明智的。

如果我把车站向左移dis，那么答案更新量为dis\*(B+r)-dis\*A

如果A<=B+r,显然无需向左移动

如果A>B+r，那么在移到下一个房子之前，肯定越往左移动，能获得越优的解，所以有r个人的那个房子不会是最优解。

综上：车站建在一个房子处可以得到最优解。

那么枚举每一个房子即可。（下面是枚举的代码。）

现在我们继续证明在车站两端人数一致的情况下取最优解。

继续看上面的式子，不是如果A>B+r的时候就要往左移动吗？那移到将近于A=B+r的情况下就不能移动啦！所以我们也可以从左往右找到一个这个房子处包括往左的人数加起来近似于人数的中位数后，再看一看这个房子左右两边的房子和其本身是否是最优解即可。（这个方法的代码其他人的题解已经给出，在此不再赘述。）

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<climits>
#include<algorithm>
using namespace std;
#define ll long long
ll read(){
    ll q=0;char ch=' ';
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')q=(ll)q*10+(ll)(ch-'0'),ch=getchar();
    return q;
}
ll lo;int n;
struct node{ll x,r;}p[100005];
bool cmp(node a,node b){return a.x<b.x;}
int main()
{
    int i,j;ll ans=LLONG_MAX,rs=0,cd=0,tot=0;
    lo=read();n=read();
    for(i=1;i<=n;i++){p[i].x=read();p[i].r=read();tot+=p[i].r;}
    sort(p+1,p+1+n,cmp);
    for(i=2;i<=n;i++)cd+=p[i].r*(p[i].x-p[1].x);
    rs=p[1].r;
    for(i=2;i<=n;i++){
        cd-=(tot-rs)*(p[i].x-p[i-1].x);
        cd+=rs*(p[i].x-p[i-1].x);
        ans=min(ans,cd);rs+=p[i].r;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：s_a_b_e_r (赞：0)

##三分

其实就是在0到maxl中间找一个地方时∑（wi\*(a[i]-L）最小

每一次判断时间是On

很容易就想到暴力查找0到maxl，然后时间爆炸！1660ms还T了3个点

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define ll long long 
using namespace std;
ll F(){ll k=9;for(int i=1;i<=10;i++)k*=10;}//赋初值
const ll maxn=100000+9;
ll maxl;
struct SABER{
 ll wi,L;
}a[maxn];
ll n,ans=F();
ll pd(ll i){
  ll re=0;
  for(ll k=1;k<=n;k++)
  re+=abs(i-a[k].L)*a[k].wi;
  return re;
}
int main(){
    cin>>maxl>>n;
    for(ll i=1;i<=n;i++){
    scanf("%lld%lld",&a[i].L,&a[i].wi);}
    for(ll i=0;i<=maxl;i++){
      ans=min(ans,pd(i));
    }
    cout<<ans;
    return 0;
}
```
然后是正解三分

 ![](https://cdn.luogu.com.cn/upload/pic/6124.png) 

很容易想到他的ans和在0-maxl的图像性质满足上面图像（二次函数）

于是就找mid1，mid2这两个点是否更优，去掉不优的1/3；找到一定的区间，暴力这一小段，就成功了；343ms

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define ll long long 
using namespace std;
ll F(){ll k=9;for(int i=1;i<=10;i++)k*=90;}
const ll maxn=100000+9;
ll maxl;
struct SABER{
 ll wi,L;
}a[maxn];
ll n,ans=F();
ll pd(ll i){
  ll re=0;
  for(ll k=1;k<=n;k++)
  re+=abs(i-a[k].L)*a[k].wi;
  return re;
}
int main(){
    cin>>maxl>>n;
    for(ll i=1;i<=n;i++){
    scanf("%lld%lld",&a[i].L,&a[i].wi);}
    ll l=0,r=maxl;
    while(l<r-10){
    ll mid1=(l+l+r)/3,mid2=(l+r+r)/3;
    if(pd(mid1)<pd(mid2))r=mid2;
    else l=mid1;
    }
    for(ll i=l-10;i<=r+10;i++){
      ans=min(ans,pd(i));
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：0)

这道题先把人数加起来，然后求中位数，然后扫一遍就行了，还是很快的。

（其实相当于把n个人拆成n个点然后求中位数）

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
long long l,n,s,i;
struct node
{
    long long r;//人数 
    long long d;//位置  
} a[110000];
bool cmp(node aa,node bb)//按照位置排序
{
    return aa.d<bb.d; 
}
long long sum; 
long long z;
int main()
{
    scanf("%lld%lld",&l,&n);
    for (i=1;i<=n;i++)
    {
        scanf("%lld%lld",&a[i].d,&a[i].r);
        s+=a[i].r;//求总人数
    }
    sort(a+1,a+n+1,cmp);
    s=(s+1)/2;//s必须要用long long
    //cout<<s<<"  --";
    sum=0;
    for (i=1;i<=n;i++)
    {
        sum+=a[i].r;
        //cout<<sum<<" ";
        if (sum>=s)
        {
            z=i;
            break;
        }
    }
    sum=0;
    for (i=1;i<=n;i++)
    {
        //cout<<a[i].r*abs(a[z].d-a[i].d)<<" ";
        sum+=(a[i].r*abs(a[z].d-a[i].d));//统计
    }
    printf("%lld\n",sum);
    return 0;
}
```

---

## 作者：mj666 (赞：0)

简单的模拟，如果知道几何结论会很好做


不用理会有多少人，将它看作有r[i]个在x[i]的点

下面是重点。。。敲黑板


将A1，A2，...An按坐标大小排序，得到P1,P2,...,Pn

如果n是奇数，取B=P((n+1)/2)，即最中间那个点

如果n是偶数，取B为线段P(n/2)P(n/2+1)上的任何一点都可以

道理很简单，记f(x)=sum（ABS（An-x）），当x偏右侧（即在中间那点或那段线段右侧）时f是斜率为正的(连续)折线段，x偏左侧时f是斜率为负的折线段，根据单调性就能判断出最小值。


道理就这样，最后看奇数还是偶数，算一次就好

Ps：注意数据范围，别抄代码哦，反正过不去



```cpp
#include<bits/stdc++.h>
using namespace std;
long long l,n,ans=0,o=1,a,b;
long long s[10001];
long long x[1000001]={0};
int main()
{
    cin>>l>>n;
    for(int i=1;i<=n;i++)
    {
      cin>>a>>b;
      s[i]=s[i-1]+b;
      while(b!=0)
      {
        x[o]=a;
        o++;
        b--;
      }
    }
    sort(x+1,x+s[n]);
    if(s[n]%2==1)
    {
      for(int i=1;i<=s[n];i++)
    ans+=abs(x[i]-x[(1+s[n])/2]);
    }
    else
    {
    for(int i=1;i<=s[n];i++)
    ans+=abs(x[i]-x[s[n]/2]);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：zpf_13516358919 (赞：0)

```cpp
//分析题目，可以得出，当车站的位置为w时
//ans=sum{|x[i]-w|*r[i]}(1<=i<=n)=(x[k+1]*r[k+1]...+x[n]*r[n]-x[1]*r[1]-x[2]*r[2]...-x[k]*r[k])+w*(r[1]+r[2]...+r[k]-r[k+1]-r[k+2]...-r[n])   (x[k]<=w<x[k+1])
//将计算式展开之后，发现ans中变量是w，(r[1]+r[2]...+r[k]-r[k+1]-r[k+2]...-r[n])的数值会随着w改变，并且会在x[ki]处由负数突变为正数
//函数的基本模型就是先减后增的函数，并且最低点在x[ki]处
//出题人的险恶用心被破解了，现在我们只需要计算车站建在每个x[k]处的ans就可以了，为保证时间，我们用前缀和处理一下
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<iomanip>
#include<map>
#include<queue>
#include<set>
#define LL long long
LL L,n,sumxr[100010],sumr[100010],minn=((LL)2<<62)-1,ans;
using namespace std;
struct node
{
    LL r,x;
 } q[100010];
int main()
{
    cin>>L>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>q[i].x>>q[i].r;
        sumxr[i]=sumxr[i-1]+q[i].x*q[i].r;//x[i]*r[i]的前缀和
        sumr[i]=sumr[i-1]+q[i].r;//r[i]的前缀和
    }
    for(int i=1;i<=n;i++)
    {
        ans=sumxr[n]-sumxr[i]*2+q[i].x*(2*sumr[i]-sumr[n]);//简化的计算
                //看不懂的自己从初始式子推导一下
        minn=min(ans,minn);
    }
    cout<<minn;
    return 0;
}

```

---


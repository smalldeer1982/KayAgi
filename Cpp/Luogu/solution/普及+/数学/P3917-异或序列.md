# 异或序列

## 题目描述

给出序列 $A_1,A_2,\cdots,A_N$，求

$$\sum_{1\le i\le j\le N} A_i\oplus A_{i+1}\oplus\cdots\oplus A_j$$

的值。其中，$\bigoplus$ 表示按位异或。


## 说明/提示

- 对于 $60\%$ 的数据，$1 \le N \le 10^3$；
- 对于 $100\%$ 的数据，$1 \le N \le 10^5$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
2
1 2```

### 输出

```
6```

# 题解

## 作者：冷月冰瞳 (赞：89)

按二进制每一位分开算。

记前缀异或值X[0...N]，一段区间[L, R]的异或值就是X[L-1] xor X[R]。

那么就是统计有多少个区间的异或值是1，那只需要统计X[0...N]中是0和1的分别有多少个，两个个数相乘就是区间个数。


---

## 作者：hwk0518 (赞：28)

我们定义第x个数中从右往左数第i位的贡献：有多少个在x之前的数j满足aj xor aj+1 xor ... xor ax的第i位是1.

设dp[x][i]表示第x个数第i位的贡献，a[x][i]表示第x个数第i位是多少。

若a[x][i]=0，取j=x不会产生贡献。若j小于x，aj xor aj+1 xor ... xor ax=aj xor aj+1 xor ... xor ax-1。所以dp[x][i]=dp[x-1][i].

若a[x][i]=1，取j=x产生1的贡献。若j小于x，aj xor aj+1 xor ... xor ax和aj xor aj+1 xor ... xor ax-1相反。所以dp[x][i]=(x-1-dp[x-1][i])(j小于x的贡献）+1(j=x的贡献）=x-dp[x-1][i].

设DP[x]=dp[x][0]×1+dp[x][1]×2+dp[x][2]×4+...+dp[x][31]×2^31.

则答案就是DP[1]+DP[2]+...+DP[n].

时间复杂度：O(32n)

空间复杂度：O(32n)

代码：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

int n,a[100005],dp[100005][32];
long long ans;

int main()
{
	int i,j;
	scanf("%d",&n);
	for(i=1;i<=n;++i) scanf("%d",&a[i]);
	for(i=1;i<=n;++i)
		for(j=31;j>-1;--j)
		{
			if(a[i]&(1<<j)) dp[i][j]=i-dp[i-1][j];
			else dp[i][j]=dp[i-1][j];
			ans+=1LL*dp[i][j]*(1<<j);
		}
	printf("%lld",ans);
	return 0;
}
```

我们发现dp[x][i]的值只能由dp[x-1][i]转移得到，所以可以用滚动数组，边转移边统计答案。

时间复杂度：O(32n)

空间复杂度：O(32)

代码：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

int n,a,dp[32];
long long ans;

int main()
{
	int i,j;
	scanf("%d",&n);
	for(i=1;i<=n;++i)
	{
		scanf("%d",&a);
		for(j=31;j>-1;--j)
		{
			if(a&(1<<j)) dp[j]=i-dp[j];
			ans+=1LL*dp[j]*(1<<j);
		}
	}
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：wanghaoyu1008 (赞：18)

异或是一种神奇的运算，有很多种理解方法，也有很多性质。这题我们只要分开各位处理，如果在该位上某段区间有奇数个1，这段区间就贡献一个1。问题就变成处理多少段有奇数个1了。

这里的处理另一个题解Dp的思想很好，但其实不需要。这个每加入一个1时反转一下就好了。可以结合图片和代码理解。
![该步的处理](https://cdn.luogu.com.cn/upload/pic/53325.png )

再推荐一道同样思想的题目：
[XOR on Segment](https://www.luogu.org/problemnew/show/CF242E)

本题代码如下：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1e5+5;

int a[N];

int main()
{
	int n,i,j;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%d",&a[i]);
	long long s,m,ans=0;
	for(j=0;j<30;j++){			//枚举位
		s=m=0;
		for(i=1;i<=n;i++){		//以该数结尾的序列
			if((a[i]>>j)&1)		//本数该位是1
				s=i-s;		//前面01反转
			m+=s;			//统计贡献
		}
		ans+=m*(1<<j);			//统计该位的贡献
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：zzozz (赞：12)

看到题解这么少，又觉得这道题也算数论里面比较经典的问题。


实际这个问题有一个简化版，就是给你一个序列，求Σ（a[i] xor a[j]）( i >= 1 && i < n, j > i && j <= n)，我们同样考虑xor产生贡献的条件，对于每一位（因为只有两个数）如果这一位其中一个为1另一个为0就可以产生贡献，所以一开始我们对于n个数求出cnt[i]（表示在二进制下第i位为1的有几个），那么为0的就是n-cnt[i]，答案统计时可以用乘法原理，让每个0分别与每个1组合，也就是cnt[i] (n - i);然后这个是算出了有多少种方案让当前这一位有贡献，要算出答案需要对cnt[i] (n - cnt[i])乘以1 << k - 1（k表示枚举的是二进制下的第几位）。


那么对于这个加强版有什么不一样？题目要求求区间xor和，我们同样对于每一位产生贡献进行考虑，若[l, r]这个区间对于这一位能产生贡献的条件就是其中1的个数为奇数且0的个数为偶数，或者0的个数为奇数且1的个数为偶数。求解这道题需要知道一个结论就是， 若a xor b = c， 那么a xor c = b;（我不会证明，这是xor的运算性质），那么我们可以求出xor的前缀也就是sum[i]表示前i个数的异或值。那么统计答案只需要求出对于二进制下的每一位这n个前缀中有几个1，用cnt表示，有几个0（也就是n - cnt）然后让每一个1与每一个0组合形成一个区间然后统计就是cnt (n-cnt) 1 << (k -1);


但是这样是错的，你会发现你让他们组合了却没有考虑到1-X这样的区间也就是让还有cnt个也可以产生贡献。所以答案统计应该是(cnt (n - cnt) + cnt) 1 << (k - 1)也就是cnt (n - cnt + 1) 1 <<(k -1）；

[代码（在博客）](http://www.cnblogs.com/zzozz/p/7800646.html)


---

## 作者：critnos (赞：11)

膜拜 hqztrue，太神仙了。本文的思路来自于这位老鸽。

考虑这个问题：

**给出若干个整数。$w$ 为字长，$\forall i\in [0,w)$，求出这些整数的二进制表示在第 $i$ 位有多少个 $1$。**

### 法一：位分块

因为 $w=\Theta(\log n)$，所以将整数每 $k=\Theta(\log n)$ 分一块，分成常数块。

所以我们只用处理常数次值域为 $m=2^k$ 的问题。即每个数 $\in [0,m)$。

考虑 01trie 结构。具体的，我们对于每个整数 $x$，在 $t_{x+m}$ 上计数一次，然后进行递推 $t_w =t_{2w}+t_{2w+1}$。

最终对每层计数一次。$ans_i =\sum _{x \bmod 2=1 \land x\in [2^{k-i},2^{k-i+1})} t_x$。

这样我们做到了 $O(m)$ 处理这个问题。时间复杂度即线性。

[代码实现](https://www.luogu.com.cn/paste/5zjv7sti)

### 法二：分治

设计 $01$ 计数数组 $a$，$a_{i,j}(i\in [1,\log n], j\in [1,w])$ 表示**第 $j$ 位的 $1$ 的数量的二进制表示的第 $i$ 位**。

考虑分治。处理两个规模为 $\dfrac n 2$ 的子问题后合并左右的计数数组 $a,b$，设其得到 $c$。

考虑这里合并的本质：并行计算 $w$ 个二进制加法。

我们对计数数组的第二维压位，因为 $j\in [1,w]$ 所以每个第二维均可以压进一个 word 里面。

同理，每一位是否进位也可以压进一个 word 里，还有一个原因就是这里至多进位一次，设其为 $t$。

计算 $c_i$：显然为 $t \oplus a_i \oplus b_i$。

计算 $t$：即判断两次加法的过程中是否有任何一个进位了。即 $(a_i \land b_i)|((a_i \oplus b_i)\land t)$。

每次合并的时间复杂度为 $O(\log n)$。时间复杂度式子即 $T(n)=2T(\dfrac n 2)+O(\log n)$。

时间复杂度显然为线性了。证明见下：

得到式子 $T(n)=\sum _{i=0}^{\log n} (\log n -i+1) 2^i$。我们尝试证明 $T(n)=O(n)$。为了方便，我们断言，证明 $T(2^n)=O(2^n)$ 即可。

设 $f(n)=T(2^n)=\sum_{i=0}^n (n-i+1)2^i$。$f(n+1)-f(n)=2^{n+1}+\sum_{i=0}^n 2^i=2^{n+2}-1$。

所以显然，$f(n)=O(2^n)$。

所以 $T(n)=O(n)$。

进行分治之后，暴力 $O(\log n w)$ 地得出每一位的答案即可。

时间复杂度线性。

[代码实现](https://www.luogu.com.cn/paste/zf0ov9fj)

---

## 作者：Polaris_Dane (赞：11)

异或的一道基本功题（虽然我WA了两次）

先计算异或前缀和，然后按位数统计贡献

记$cnt1[i]$表示前面所有前缀和，第i位为1的数

记$cnt2[i]$表示前面所有前缀和，第i位为0的数

然后统计即可

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#define M 2010000
#define inf 0x3f3f3f3f
#define LL long long
#define int long long
using namespace std;
int n,s[M],cnt1[M],cnt2[M],ans;
inline int read()
{
	int f=1,x=0;char s=getchar();
	while (!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while (isdigit(s)){x=(x<<1)+(x<<3)+(s^48),s=getchar();}
	return x*f;
}
signed main(void)
{
	n=read();
	for (int i=0;i<=30;i++) cnt2[i]=1;
	for (int i=1;i<=n;i++){
		int x=read();
		s[i]=s[i-1]^x;
		for (int j=30;j>=0;j--){
			if ((1<<j)&s[i])
				ans+=(1<<j)*cnt2[j],cnt1[j]++;
			else 
				ans+=(1<<j)*cnt1[j],cnt2[j]++;
		}
	}
	printf("%lld",ans);
    return 0;
}

```


---

## 作者：hovny (赞：8)

## 解题思路

这里提供一种~~乱搞~~新奇的算法（完全在线~~鬼知道有什么用~~

### 分析

考虑**拆位**，由于异或的性质（算是吧，不同位之间不影响，因此可以计算每个位做出的贡献，然后累加

显然，只有奇数个 $1$ 才能做出贡献，所以我们只要能计算出有多少个区间包含奇数个 $1$

尝试看看有什么规律：

|  数   | $2$  | $5$  | $6$  |
| :---: | :--: | :--: | :--: |
| $2^2$ | $0$  | $1$  | $1$  |
| $2^1$ | $1$  | $0$  | $1$  |
| $2^0$ | $0$  | $1$  | $0$  |

对 `2,5,6` 分别拆位，表示为上述的表（当然做的时候没必要记录

考虑 $2^2$，以第 $1$ 个数 $2$ 为区间右端点，有贡献的区间有 $0$ 个；以第 $2$ 个数 $5$ 为区间右端点，有贡献的区间有 $[1,2]$ 和 $[2,2]$ 共 $2$ 个；以第 $3$ 个数 $6$ 为区间右端点，有贡献的区间有 $[3,3]$ 共 $1$ 个。做出的总贡献为 $(2+1)\times 2^2$

其余位同理

不难看出，如果将序列按 $1$ 的位置分段，则右端点处于某段中（即为 $0$ 的情况）时，有贡献的区间数为与之距离奇数段的区间总跨度；为某段的右端点（即为 $1$ 的情况）时，贡献为与之距离偶数段的区间总跨度，$Rt$

![](https://hovnysilence.github.io/image/Luogu_P3917-1.jpg)

- 在一个某段中（即为 $0$ 的情况），

  $7,8$ 等，贡献即为其之前蓝色区间的跨度 $6-4=2$

  $10,11$ 等，贡献即为其之前红色区间的跨度 $(9-6)+(4-0)=7$

- 为某段的右端点（即为 $1$ 的情况），

  $4$ 等，贡献即为其之前红色区间的跨度 $4-0=4$

  $12$ 等，贡献即为其之前蓝色区间的跨度 $(12-9)+(6-4)=5$

然后我们就可以得出这样一个代码：

```cpp
int n,k,sum[31][2],p[31],pos[31];LL ans,c;
int main()
{
	rint i,j;n=read();
	for(i=1;i<=n;i++) {
		k=read(),c=1;
		for(j=0;j<30;++j,c<<=1) {//pos记录上一个1的位置，sum[_][0/1]记录红蓝色区间分别的跨度
			if(k&c) p[j]^=1,sum[j][p[j]]+=i-pos[j],pos[j]=i;
			ans+=sum[j][p[j]]*c;//累加贡献
		}
	}
	printf("%lld",ans);
	return 0;
}
```

### more

但是，还可以优化，由于做到 $1$ 时，红蓝色区间跨度之和定等于 $i$，又做到 $0$ 时，对红蓝色区间的跨度无影响，因此可以改成：

```cpp
	rint i,j;n=read();
	for(i=1;i<=n;i++) {
		k=read(),c=1;
		for(j=0;j<30;++j,c<<=1) {//红蓝区间的跨度可以由另外一个推得
			if(k&c) sum[j]=i-sum[j];
			ans+=sum[j]*c;
		}
	}
```

或者我们还可以这样考虑：由于异或具有自反性，因此可以考虑拆位后求出异或前缀，这样的话有贡献的区间即为 $1$ 的个数与 $0$ 的个数之积

```cpp
rint i,j;n=read();
for(i=1;i<=n;i++) {
    k=read(),c=1;
    for(j=0;j<30;++j,c<<=1)
        p[j]^=k&c,++sum[j][p[j]];//分别存前缀异或，以及1和0的个数
}
for(i=0,c=1;i<30;++i,c<<=1) ans+=sum[i][0]*sum[i][1]*c;
```

### warning

$\mathtt{non}$

## Code

```cpp
#include<bits/stdc++.h>
#define rgt register
#define rint rgt int
#define LL long long
#define rll rgt LL
#define inf 0x7f7f7f7f
using namespace std;
template<class K>inline bool cmax(K&a,const K&b){return (a<b)?a=b,1:0;}
template<class K>inline bool cmin(K&a,const K&b){return (a>b)?a=b,1:0;}
inline int read() {
	rint s=0;
	rgt char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return s;
}
int n,k,sum[31];LL ans,c;
int main()
{
	rint i,j;n=read();
	for(i=1;i<=n;i++) {
		k=read(),c=1;
		for(j=0;j<30;++j,c<<=1) {
			if(k&c) sum[j]=i-sum[j];
			ans+=sum[j]*c;
		}
	}
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：Mariposa (赞：4)

纯暴力$\Theta(n^3)$，前缀和优化$\Theta(n^2)$，因$n$为十万级别无法通过本题。

考虑将每个二进制位的贡献分开来算。

对于二进制第$i$位，若当前此位为1，则只有与0亦或才能产生贡献，反之亦然。

则对于每一个二进制位，维护数组$val[i][0/1]$，代表这个位置上$0/1$的个数。

则贡献为$w=val[i][!t]*(1<<i)$，注意总贡献要开$long long$。

注意对于每个数只计算它与前面产生的贡献，这样就不会重复计算。

时间复杂度$\Theta(nlogn)$

代码如下，仅供参考：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,a[maxn];
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
int val[50][2],cnt;
long long ans;
inline void insert(int x){
	for(int i=0;i<=30;i++){
		int t=(((1<<i)&x)!=0);
		ans+=(1ll<<i)*val[i][!t];
		val[i][t]++;
	}
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read()^a[i-1];
	insert(0);
	for(int i=1;i<=n;i++)
		insert(a[i]);
	printf("%lld\n",ans);
	return 0;
}
```
深深地感到自己的弱小。

---

## 作者：jzqjzq (赞：4)

我的blog：http://blog.csdn.net/jzq233jzq/article/details/77231143

我的做法好像比较傻。。。

看到这种题首先想到前缀。首先前缀xor是不是很资辞？

我的做法呢就是先把所有数按二进制位拆开，然后每一位都做两次前缀。

首先对数位做一次前缀xor，记到$s$数组里，再对s数组做一次前缀和，记到$ss$里。

然后我们可以对于每一位枚举起始位置i，然后从i开始向后到n统计答案。

首先考虑到$s$数组非0即1，所以这里处理将会非常方便。

我们可以看到$s$数组和$ss$数组的关系就像这样（这里的"^"都是xor的意思）：

![](http://img.blog.csdn.net/20170816103548222?)

可以发现$ss[i]$就对应了以s[i]为底的三角形是不是？

所以首先我们差分求出$ \sum_{j=i}^ns_j$之后我们得到了一个等腰梯形（以3~5为例）：

![](http://img.blog.csdn.net/20170816104030050?)

我们发现最前面两个是一样的，所以我们把这个作为公共部分。而且我们要求答案的也是这个梯形减掉左边的公共部分。

我们发现如果公共部分的xor值为1的话，右边的答案就需要整体翻转一下，如果为0，就不变。

这样我们就$O(1)$得到了从i开始的所有答案。

最后乘上当前在第几位的底数就好了。时间复杂度$O(n log n)$

代码在我blog里>\_<


---

## 作者：zhengrunzhe (赞：3)

提供一个分治做法

对于一个区间$[l,r]$，统计$mid=\frac{l+r}{2}$对其的贡献

$1.l=r$ 直接返回自身权值

$2.r-l=1$ 即区间长度为2 直接返回$a[l]+ a[r] +(a[l] \bigoplus a[r])$

$3.l<mid<r$


开一个$cnt[30][0/1]$的桶 表示每一位上0/1的个数

然后把$[l,mid-1]$的数丢进桶里

用$[mid,r]$的数一个个去查累计答案

查的方法就是假如查询的数的某位上是1 就看这位上有多少个0 反之一样 然后乘上该位的位权

然后往下分治$[l,mid-1],[mid+1,r]$

时间复杂度$O(30n\log n)$

比正常的做法多一个log 但是能过就行（）

```cpp
#include<cstdio>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
typedef long long ll;
const int N(1e5+5);
int n,a[N],cnt[30][2];
inline const void insert(const int &x)
{
	for (int i(0);i<30;i++)cnt[i][(x>>i)&1]++;
}
inline const ll query(const int &x)
{
	ll sum(0);
	for (int i(0);i<30;i++)sum+=(1ll<<i)*cnt[i][(x>>i)&1^1];
	return sum;
}
inline const void clear()
{
	for (int i(0);i<30;i++)cnt[i][0]=cnt[i][1]=0;
}
inline const ll divide(const int &l,const int &r)
{
	if (l==r)return a[l];
	const int mid(l+r>>1);
	if (l==mid||r==mid)return a[l]+a[r]+(a[l]^a[r]);
	for (int sum(0),i(mid-1);i>=l;i--)insert(sum^=a[i]);
	insert(0);ll ret(0);
	for (int sum(0),i(mid);i<=r;i++)ret+=query(sum^=a[i]);
	clear();
	return ret+divide(l,mid-1)+divide(mid+1,r);
}
int main()
{
	read(n);
	for (int i(1);i<=n;i++)read(a[i]);
	printf("%lld\n",divide(1,n));
	return 0;
}
```

---

## 作者：Jμdge (赞：3)

woc 一道水题我居然写了错误的 trie  WA 了 n 次！

# noteskey

其实这道题我们只需要考虑异或的 区间可加、可减性 就好了，把 $a[i] ⨁a[i+1]⨁...⨁a[j]$ 变成 :

$(a[1]⨁...⨁a[j])$⨁ $(a[1]⨁...⨁a[i-1])$ 

然后我们每次处理到一个 $a[i]$ 的前缀和，就去前面找贡献，分别考虑 30 个位置有多少是和当前的前缀和是不同的，加上贡献，再 update 当前的前缀和就好了

注意一开始要让所有的 $num[i][0]=1$，就当是 $a[0]$ 的前缀和了

具体看代码比较清楚

# code

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define fp(i,a,b) for(register int i=(a),I=(b)+1;i<I;++i)
#define ll long long
using namespace std;
const int M=3e6+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline bool cmax(int& a,int b){return a<b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,d[33],a[M],num[33][2]; ll ans;
inline void div(int x){
	fp(i,0,30) d[i]=x&1,x>>=1;
}
inline void update(int x){ div(x);
	fp(k,0,30) ++num[k][d[k]];
}
inline ll query(int x){ ll ans=0; div(x);
	fp(k,0,30) ans+=(1ll<<k)*num[k][d[k]^1]; return ans;
}
int main(){ n=read();
	fp(i,0,30) num[i][0]=1;
	fp(i,1,n) a[i]=read()^a[i-1],
		ans+=query(a[i]),update(a[i]);
	return !printf("%lld\n",ans);
}
```


---

## 作者：聆雨泣 (赞：2)

说句题外话，大佬们的做法转化成二进制，每一位都考虑太复杂了，估计看懂的不多（反正我是看不懂），于是就贴一份60分的思路（加代码），帮助大家（也就是我一般的选手）理解，有在此基础上会优化的大佬可以教教我（求过。。。。。。）
#思路：用前缀数组A[]优化一下，前缀数组A[i]记录的是A[1]xorA[2]xor....xorA[i],然后我们可以考虑这样一种做法，就是如何利用前缀数组进行一段xor和的计算，我们可以利用这样一个性质，已知xor运算满足交换律与结合律，且
###x xor x = 0;
那么从i到j的xor和就可以这样求：ans=A[j] xor A[i-1];
每次输入后枚举前面的A数组即可。
即,核心代码如下
```
for(int i=1;i<=n;i++){
		x=read();A[i]=(ll)x;
		A[i]^=A[i-1];
		for(int j=0;j<i;j++) ans+=(A[i]^A[j]);
	}
```
全代码如下：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
int n,x;
ll A[100005],ans;
inline int read(){//快读，对这题没啥用，该挂的还是挂，没啥区别（别问我为啥，我试过了啦）
	register int x=0;
	register bool flag=true;
	register char k=getchar();
	while(!isdigit(k)){
		if(k=='-') flag=false;
		k=getchar();
	}
	while(isdigit(k)){
		x=x*10+k-'0';
		k=getchar();
	}
	return flag?x:-x;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		x=read();A[i]=(ll)x;//输入，存入
		A[i]^=A[i-1];//求前缀按位异或和
		for(int j=0;j<i;j++) ans+=(A[i]^A[j]);//核心，上边给出了证明，利用了一个性质，枚举求和即可，非常简单易懂啊
	}
	printf("%lld\n",ans);
	return 0;
}
```
有优化请教教我，多多指教，我目前只能做到这一步

---


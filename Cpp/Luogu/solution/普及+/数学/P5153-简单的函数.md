# 简单的函数

## 题目背景

此题为改编题，特别鸣谢吴作凡同学。


## 题目描述

HKE 有一次发现了一个很有趣的函数。

定义 $f(2)=1$。对于 $n\geq3$，设 $t$ 为最小的使得 $n$ 不能被 $t$ 整除的正整数，则 $f(n)=f(t)+1$。

举个栗子。比如 $n=6$，此时 $t=4$，$f(6)=f(4)+1=f(3)+2=f(2)+3=4$。

现在，HKE 想知道 $f(2)\times f(3)\times\cdots\times f(n)$ 是多少？答案可能很大，请对 $10^9+7$ 取模。


## 说明/提示

对于 $30\%$ 的数据，$n\leq1000$；

对于 $50\%$ 的数据，$n\leq1000000$；

对于 $100\%$ 的数据，$n\leq10^{18}$。


## 样例 #1

### 输入

```
4```

### 输出

```
6```

# 题解

## 作者：Caro23333 (赞：9)

#### 思路与Great_Influence相似，更加详细且有代码。
首先观察题目条件。若$t$是最小不整除$x$的正整数,则有：

 - 对于任意$i(1\le i<t)$都有$i\mid x$，即$lcm(1,2,\dots,t-1)\mid x$
 - $lcm(1,2,\dots,t)\nmid x$
 
根据这个原理我们进行打表不难发现使得$lcm(1,2,\dots,t)\le 10^{18}$的最大的$t$是$42$，从而对于$3\le x\le 10^{18}$的$x$，$2\le t\le 42$.

将$1$到$42$每一个位置的前缀$lcm$求出，并且考虑以$i(2\le i\le 42)$为转移点的$x(43\le x\le n)$的数量。注意到$lcm(1,2,\dots,i-1)\mid lcm(1,2,\dots,i)$，所以满足上述两个条件的$x$的数量就是$[43,n]$上$lcm(1,2,\dots,i-1)$的倍数的数量减去$lcm(1,2,\dots,i)$的倍数的数量。

注意到这些$x$都满足$f[x] = f[i]+1$，在预处理$f[2],f[3],\dots,f[42]$之后可以计算出对于每个$k(1\le k\le 5)$共有几个$x$满足$f[x] = k$，从而可以轻易地得到答案。

时间复杂度显然是正确的。

#### 代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#define mod 1000000007

using namespace std;
typedef long long ll;
const int MAXN = 50;
int f[MAXN];
ll n,lcm[MAXN],cnt[10];
inline ll gcd(ll a, ll b)
{
    return b?gcd(b,a%b):a;
}
inline ll calc(ll l, ll r, ll x)
{
    return r/x-(l-1)/x; 
}
inline ll qpow(ll a, ll b)
{
    ll res = 1;
    for(; b; a = a*a%mod, b >>= 1ll)
        if(b&1ll)
            res = res*a%mod;
    return res;
}

int main()
{
    cin >> n;
    f[2] = 1;
    for(int i = 3; i<=50; i++)
        for(int j = 2; j<i; j++)
            if(i%j)
            {
                f[i] = f[j]+1;
                break;
            }
    lcm[1] = 1;
    int pos = 2;
    for(pos = 2; pos<=50; pos++)
  	{
        lcm[pos] = lcm[pos-1]*(pos/gcd(pos,lcm[pos-1]));
        if(lcm[pos]>n)
            break;
    }
    for(int i = 2; i<=pos; i++)
        cnt[f[i]+1] += calc(pos+1,n,lcm[i-1])-calc(pos+1,n,lcm[i]);
    for(int i = 2; i<=pos; i++)
        cnt[f[i]]++;
    ll ans = 1;
    for(int i = 2; i<=5; i++)
        ans = ans*qpow(i,cnt[i])%mod;
    cout << ans << endl;
    return 0;
} 
```


---

## 作者：_ztyqwq (赞：3)

似乎其他题解都是用前缀 $ \rm{lcm} $ or 容斥做的，这里提供一种分类讨论的做法

~~首先先写个暴力程序打表~~ 发现 $ f_n $ 不可能超过 $ 4 $。考虑分类讨论 $ f_n $ 分别为 $ 1, 2, 3, 4 $ 的情况数

 - $ f_n = 1 $：显然只有 $ n = 2 $

---

 - $ f_n = 2 $：当 $ n $ 为奇数时，题目中的 $ t = 2 $，因而 $ f_n = f_2 + 1 = 2 $；

而当 $ n $ 为不为 $ 2 $ 的偶数时，$ t $ 一定 $ \geqslant 3 $，因此 $ f_t \geqslant 2 $，$ f_n = f_t + 1 \geqslant 3 $

下面讨论当 $ f_n \geqslant 3 $ 时，何时 $ f_n = 4 $（$ f_n \leqslant 4 $ 的证明见下）

---

$ f_n = 4 $：如果 $ f_n = 4 $，一定有 $ f_t = 3 $，即 $ t \geqslant 4 $ 且 $ t $ 为偶数

 - 打表发现，当 $ f_n = 4 $ 时，$ t $ 只可能是 $ 4, 8, ..., 2^i $

证明：

如果 $ t $ 含有至少两种不同的质因子，则一定存在 $ t = a \times b, \gcd(a, b) = 1, a < t, b < t $（想一想，为什么）

$ \because a < t, b < t \therefore$ 一定有 $ a | n, b | n $

又 $ \because \gcd(a, b) = 1, \therefore ab | n $，即 $ t | n $

这与题设 $ t \nmid n $ 矛盾，因此不存在这样的 $ a, b $

因此 $ t $ 只有一种质因子。

又 $ \therefore f_t \geqslant 3 $，$ \therefore t $ 一定为偶数

$ \therefore t $ 的这个质因子一定为 $ 2 $

$ \therefore t = 2^i $，证毕

---

那么如果不整除 $ n $ 的最小整数为 $ t $，则一定有 $ \rm{lcm} $ $ (1, ..., t - 1) | n $， 而 $ \rm{lcm}$ $(1, ..., t) \nmid n $

将 $ t $ 用 $ 2^i $ 代，则有 $ \rm{lcm}$ $(1, ..., 2^i - 1) | n $，$ 2 \times \rm{lcm}$ $(1, ..., 2^i - 1) \nmid n $（多一个 $2$ 因子）

令 $ \rm{lcm}$ $(1, ..., 2^i - 1) = a_i $

则 $ a_i | n, 2a_i \nmid n $

所以 $ n = a_i + 2ka_i (k \in \mathbb{N}) $

计算个数时，对于每一个 $ i $，满足条件的 $ n $ 的个数为 `(N - a[i] / (2 * a[i]) + 1 = (N + a[i]) / (2 * a[i])`，`N` 为题目中的输入

接下来考虑求 $ a_i $

枚举 $ i = 1, ..., 6 $ 可以发现，当 $ i = 6 $ 时 $ \rm{lcm}$ $(1, ..., 2^i - 1) > 10^{18}$，因此只需讨论 $ i \leqslant 5 $ 的情况

注意 $ i = 1 $ 时 $ t = 2 $ 不满足条件，因此 $ i = 2, 3, 4, 5 $

 - $ i = 2 $ 时，$ a_i = 6 $
 
 - $ i = 3 $ 时，$ a_i = 420 $
 
 - $ i = 4 $ 时，$ a_i = 360360 $
 
 - $ i = 5 $ 时，$ a_i = 72201776446800 $

可以将 $ a_i $ ~~预处理~~直接存在表中

然后枚举 $ i = 2, ..., 5 $（代码中是 1 ~ 4）就可以求出所有 $ f_n = 4 $ 的情况了（甚至不用算 $ t $）

---

关于 $ f_n \leqslant 4 $ 的证明：

如果 $ f_n \geqslant 5 $，则有 $ f_t \geqslant 4 $，根据上述证明，此时 $ t = 2^i $

而因为 $ f_t \geqslant 4 $ 时，$ \rm{lcm}$ $(1, ..., s) | t $（$ s $ 是不整除 $ t $ 的最小整数，$ s = 2^j \geqslant 4 $）

所以 $ 3|t $，与 $ t = 2^i $ 矛盾

因此 $ f_n \leqslant 4 $

---

对于 $ f_n = 3 $，只要将 $ f_n \geqslant 3 $ 的情况（ $ n $ 为不为 $ 2 $ 的偶数）减去 $ f_n = 4 $ 的情况即可

然后快速幂，相乘即是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int mod = 1000000007;
inline int fastpow(int a, int n)
{
	int ans = 1;
	while(n)
	{
		if(n & 1)
			ans = ans * a % mod;
		a = a * a % mod;
		n >>= 1;
	}
	return ans;
}
int a[] = {0, 6, 420, 360360, 72201776446800ll};
signed main()
{
	int n;
	scanf("%lld", &n);
	int p3 = n / 2, p2 = n - p3, p4 = 0; // 这里的 p3, p2 分别是 1 ~ n 中的偶数数量和奇数数量
	for(int i = 1; i <= 4; i++)
		if(n >= a[i])
			p4 += (n + a[i]) / (2 * a[i]);
	int ans = fastpow(2, p2 - 1) * fastpow(3, p3 - p4 - 1) % mod * fastpow(4, p4) % mod; // p2 - 1 是减去 f[1]，p3 - 1 是减去 f[2]
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：南城忆潇湘 (赞：2)

思路：打表+直接模拟  
首先观察数据范围。对于$f(x)$,$x∈[2,10^{18}]$,它的值域是$[1,99]$。（貌似是因为$lcm(1-99)$大于了$10^{18}$，不会证明，希望大佬证明qwq）  
然后编写一个程序打表。（没错，就是这么粗暴）  
接着我们对一个区间进行除法。（可以理解为筛）枚举$1-100$，然后对于区间除以这个数。将不能除尽的留下来，将能除尽的进行计算（可以用快速幂）。统计个数求积即可。  
最后就这样啦。（可能代码有点难看，毕竟是好久以前写的代码了，自己思路也忘得差不多了，希望能给大家一点帮助吧）

代码：
```
#include<cstdio>
#include<iostream>
#define MAX 50
#define MOD 1000000007
#define int long long
using namespace std;
long long gcd(long long p,long long q){
	if(!q)	return p;
	return gcd(q,p%q);
}

long long get(long long now){
	for(long long i=1;i<=now/2+1;i++)
		if(now%i)	return i;
	return 0;
}

long long ksm(int x,int y){
	int cnt=x,ans=1;
	while(y){
		if(y&1)	(ans*=cnt)%=MOD;
		y>>=1; (cnt*=cnt)%=MOD;
	}
	return ans;
}

int f[100]={0,0,1,2,3,2,4,2,3,2,3,2,3,2,3,2,3,2,4,2,3,2,3,2,3,2,3,2,3,2,4,2,3,2,3,2,3,2,3,2,3,2,4,2,3,2,3,2,3,2,3,2,3,2,4,2,3,2,3,2,3,2,3,2,3,2,4,2,3,2,3,2,3,2,3,2,3,2,4,2,3};
signed main(){
	long long b,l,r,i,ans=1,cnt=1,now=1,tot=0;
	cin>>b;l=3,r=b;
	for(i=2;i<=MAX;i++){
		if(l>=r)	break;
		now=i/gcd(i,cnt);	cnt*=now; tot=0;
		if(now==1)	continue;
		tot+=(r-l+1)/now;
		for(long long j=(r-l+1)/now*now+l;j<=r;j++)
			if(!(j%now))	tot++;
		(ans*=ksm(f[i]+1,r-l+1-tot))%=MOD;
		if(l%now)	l=l/now*now+now;
		r=r/now*now;	l/=now,r/=now;
	}
	int last=get(l*cnt);
	if(!last||l>r)	cout<<ans<<endl;
	else 	cout<<(ans*(f[last]+1))%MOD<<endl;
	return 0;
}
```


---

## 作者：Great_Influence (赞：2)

这个题目标程爆long long 了，但是很巧妙地不影响答案，非常神奇。

做法大概就是观察可得对于$n\le 10^{18}$，$t\le 43$。然后直接利用容斥计算出每个$t$对应的$n$的个数就可以了。

记得阶乘只能预处理到$42$，然后$43$要标成$n+1$。

标程做法貌似就是观察到$f$不会超过$4$，然后对每种情况计算出方案数。

---

## 作者：George_Je (赞：1)

## 在最前面
首先，我们可以打表找找规律，在 $i$ 较小时，我们感觉 $f$ 函数似乎是长这个样子的。
$$
f_i = 
\begin{cases}
1&i = 2
\\2&i \equiv 1\enspace (mod\enspace 2)
\\3&i \equiv 0\enspace (mod\enspace 2)\enspace and\enspace 
i \not\equiv 6\enspace (mod\enspace 12)
\\4&i \equiv 6\enspace (mod\enspace 12
)
\end{cases}
$$
很遗憾，这个粗糙的式子并不正确，但这一步很重要，它至少指示了我们后来的突破方向。
### 一个小约定

- 我们用 $LCM(n)$ 表示 $1$ 到 $n$ 中所有数的最小公倍数。在代码中这样实现：
```cpp
int LCM (int n) {
	int a = 1;
	for (int i = 2; i <= n; ++i)
		a = a / __gcd (a, i) * i;
	return a;
}
```
# **正解**

首先很显然的是，对于所有奇数 $i$ ，$f_i$ 一定为 $2$ 。而对于偶数 $i$ ，$f_i$ 至少为 $3$。

下面我们来讨论 $f_i = 4$ 的情况。

设 $f_i$ 由 $f_j$ 转移过来，那么 $i$ 一定是 $LCM(j - 1)$ 的倍数，不妨设

$i = s\cdot LCM(j-1) \enspace \enspace \enspace \enspace*$

则 $j \nmid s\cdot LCM(j-1)$

我们根据唯一分解定理把 $j$ 写成这样：

$j = \prod_{k = 1}^{m}p_k^{d_k}$

那么显然，对于任何**非 $2$ 的整数次幂** $p_k^{d_k}$，有 $p_k^{d_k}\mid i$，我们可以这样构造：取 $p_k$ 小于 $j$ 的最大次幂$p_k^{e_k}$，它一定整除 $i$ ，而且 $d_k$ 一定不大于 $e_k$ （**反证法，如果$d_k>e_k$，那么就说明 $j$ 是 $p_k$ 的整数次幂，而实际上，因为 $j$ 是偶数，$j$ 又不可能是 $p_k$ 的整数次幂**），所以 $p_k^{d_k}$ 一定也能整除 $i$。

那么我们把只有把希望寄托在 $2$ 上了，令我们惊喜的是，**当且仅当 $j$ 为 $2$ 的整数次幂，且 $s$ 为奇数时**，满足条件，前几个 $LCM(2^w-1)$分别为

- $6$
- $420$
- $360360$
- $72201776446800$

可以发现该数列（不妨设其为 $g$）
增长速度是极快的，小于$10^{18}$的也就这4个。再加上“ $s$ 为奇数”的条件，我们可以写出 $f_i = 4$ 的充要条件：

- $f_i = 4$，当且仅当 $i \equiv g_a \enspace (mod \enspace 2g_a )$

至于$f_i = 5$ ，考虑 $*$ 式容易证明，这种情况是压根不存在的，这里就略去了。

总结一下，我们可以写出正确的$f_i$的表达式了：
$$
f_i = 
\begin{cases}
1&i = 2
\\2&i \equiv 1\enspace (mod\enspace 2)
\\3&i \equiv 0\enspace (mod\enspace 2)\enspace and\enspace 
i \not\equiv g_a\enspace (mod\enspace 2g_a)
\\4&i \equiv g_a\enspace (mod\enspace 2g_a)
\end{cases}
$$
到这里，整道题的正解已经呼之欲出了，因为 $f_i$ 只有可能是$2, 3, 4$，所以 $ans$ 可以表示成 $2^x3^y$ 的形式，我们根据上述表达式 $O(1)$ 统计出 $x,y$ ，再用快速幂算出答案，整个做法的复杂度是$O(logn)$级别的。
## 上代码！！！
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
vector <int> g;
int ans = 1;
int LCM (int n) {
	int a = 1;
	for (int i = 2; i <= n; ++i)
		a = a / __gcd (a, i) * i;
	return a;
}
int fast_pow (int a, int b) {
	int c = 1;
	while (b) {
		if (b & 1)
			(c *= a) %= mod;
		(a *= a) %= mod;
		b >>= 1;
	}
	return c;
}
signed main () {
	int n;
	cin >> n;
	for (int i = 4; i <= 32; i <<= 1)
		g.push_back (LCM (i - 1));
	int k = 0;
	for (int i = 0; i < g.size (); ++i)
		k += (n + g [i]) / (2 * g [i]);
	ans = fast_pow (2, (n - 1) / 2 + k * 2);
	cout << ans * fast_pow (3, n / 2 - 1 - k) % mod;
}
```
（当然你可以选择打表 $g$ 数组，~~反正也只有 $4$ 个~~）






---

## 作者：JustinRochester (赞：1)

题目难度好像被高估了，应该没有紫题

[传送门](https://www.luogu.com.cn/problem/P5153)

---

**【分析】**
--

稍微打表或分析一波可以得知：

当且仅当数字 $n$ 是 $\text{lcm}(1, 2, \cdots, m-1)$ 的倍数，且不是 $\text{lcm}(1, 2, \cdots, m-1, m)$ 的倍数时，有：

$f(n)=f(m)+1$

大体估计一波，$\text{lcm}(1, 2, \cdots, 99)>10^{18}\geq n$

所以暴力把前面的 $f(1)\sim f(99)$ 打出来，然后进行筛选：

枚举 $i$ ，记录是 $\text{lcm}(1, 2, \cdots, i-1)$ 的倍数且不是 $\text{lcm}(1, 2, \cdots, i-1, i)$ 的倍数的个数

即 $[n/\text{lcm}(1, 2, \cdots, i-1)]-[n/\text{lcm}(1, 2, \cdots, i-1, i)]$ 个数字的 $f$ 值是 $f(i)+1$ 的

于是开一个数组，把它们统计到 $f(i)+1$ 上

最后跑一个快速幂即可

注意一下，因为 $1$ 也不是 $\text{lcm}(1, 2)$ 的倍数，所以 $f(2)+1$ 处会多统计一个 $1$，需要扣掉；同理扣去 $f(3)+1$ 处的 $2$

---

**【代码】**
---

这边瞎写了一个 python 代码：

```python
from math import gcd

mod = int(1e9+7+1e-6)
def fpow(a, x) :
    ans = 1
    while x > 0 :
        if x&1 :
            ans = ans * a % mod
        a = a * a %mod
        x >>= 1
    return ans

def lcm(a, b) :
    a = abs(a)
    b = abs(b)
    return a//gcd(a, b)*b

f = [1, 1, 1]
for i in range(3, 100) :
    for j in range(2, i) :
        if i%j != 0 :
            f.append(f[j]+1)
            break
while True:
    try :
        n = int(input())
        cnt = [0 for i in range(100)]
        val = 1
        for i in range(2, 99) :
            if val > n :
                break
            cnt[ f[i]+1] += n//val
            val = lcm(val, i)
            cnt[ f[i]+1] -= n//val
        cnt[2] -= 1
        cnt[3] -= 1

        val = 1
        for i in range(1, 100) :
            val = val*fpow(i, cnt[i])%mod
        print(val)
    except :
        exit(0)
```

---


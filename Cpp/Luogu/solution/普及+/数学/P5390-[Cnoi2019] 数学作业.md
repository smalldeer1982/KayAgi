# [Cnoi2019] 数学作业

## 题目背景

幻想乡，春节，万家灯火。

Kamishirasawa Keine 老师自然不会放过这么好的机会，，，布置作业。

## 题目描述

现在 Cirno 手上有着 $T$ 天的作业，每天的作业可以用一个二元组 $( n, V )$ 表示，其中 $n$ 表示集合的大小， $V$ 表示大小为 $n$ 的集合. 现在，Cirno 需要求出的是 $V$ 的所有子集的异或和的和，答案对 $998\,244\,353$ 取模。

形式化地：

$$
\text{ans}\equiv \sum_{S \subseteq V} \mathop{\bigoplus}\limits_{ s \in S } s \pmod {998\,244\,353}
$$

## 说明/提示

- Subtask 1（17pts）：$ T, n \le 8 $；
- Subtask 2（22pts）：$ T, n \le 100 $；
- Subtask 3（61pts）：$ T, n \le 3\times10^6 $。

对于 $100\%$ 的数据，$ \sum |V| \le 3 \times 10^6, 0 \le p \le 10^9$。

## 样例 #1

### 输入

```
1
3 1 2 3```

### 输出

```
12```

# 题解

## 作者：1saunoya (赞：24)

我也不知道他们在证明啥。。

考虑这玩意是个异或，拆个位。

然后考虑到非 1 即 0，由于是异或，肯定有一半是 0，一半是 1。

所以答案就是或和乘上$2^{n-1}$。

---

## 作者：TheLostWeak (赞：19)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5390.html)

**大致题意：** 给你一个集合，求所有子集异或和之和。

### 大致思路

首先，我们很容易想到去对二进制下每一位分别讨论。

枚举当前位，并设共有$x$个数当前位上为$1$，则有$(n-x)$个数当前位上为$0$。

对于$x=0$显然无法使这一位为$1$，否则当且仅当选取的子集中有奇数个数这一位上为$1$，这一位异或之后才会为$1$。

又由于这一位为$0$的数选与不选毫无影响，因此这一位为$1$的方案数为 **$x$个数中选取奇数个数的方案数乘上$2^{n-x}$**。

则我们主要考虑如何求$x$个数中选取奇数个数的方案数。

容易想到去猜测$x$个数中选取奇数个数的方案数与选取偶数个数的方案数相同，即皆为$2^{x-1}$。

实际上，由二项式定理我们可知：

$$(1-1)^x=\sum_{i=1}^x(-1)^iC_x^i=0$$

由这个式子就可以推得上面的结论是正确的了。

所以对于任意$x≠0$的一位，其方案数即为$2^{x-1}\cdot2^{n-x}=2^{n-1}$。

综上，我们得出结论：对于二进制下第$k$位，若这一位有$1$，则可产生$2^k\cdot2^{n-1}$的贡献。

因此将所有数或起来，然后乘上$2^{n-1}$就是答案了。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define X 998244353
using namespace std;
int n;
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
		Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
		Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
		Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
		I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
I int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}//快速幂
int main()
{
	RI Tt,i,s,x;F.read(Tt);W(Tt--)
	{
		for(F.read(n),s=0,i=1;i<=n;++i) F.read(x),s|=x;//统计所有数或值
		F.writeln(1LL*s*Qpow(2,n-1)%X);//乘上2的n-1次方
	}return F.clear(),0;
}
```

---

## 作者：离散小波变换° (赞：9)

## 题目大意

$T$ 组数据。每组给出一个长度为 $n$ 的数列 $A_i$，求：

$$\sum_{S\subset A}\left(\bigoplus_{p\in S}p\right)$$

## 题解

没想到正解的公式……但是推了一个应该比较简单的 $\rm dp$。

很显然，题目中提到的异或操作只与每一位的值相关。于是我们可以按位进行操作。也就是说，分别取$A$数列的每个数二进制下的第 $k$ 位，求这 $n$ 个二进制位组成的 $01$ 串的所有子集的异或和。

可能有一点绕口。比如说，数列 $A$ 为 $(1,1,4,5)$，那么二进制下分别为 $(001)_{(2)},(001)_{(2)},(100)_{(2)},(101)_{(2)}$。取最后一位，组成 $\{1,1,0,1\}$。那么它的子集的异或值之和为 $8$。

我们记前 $i$ 个数，异或值为 $1$ 的子集个数为 $F_i$，为 $0$ 的子集个数为 $G_i$。

考虑第 $i$ 个数，每个数有两种情况：

* 值为 $1$。
  * 选择它，异或和为 $1$ 的方案数为 $G_{i-1}$，为 $0$ 的方案数为 $F_{i-1}$。
  * 不选择它，那么异或和为 $1$ 的方案数为 $F_{i-1}$，为 $0$ 的方案数为 $G_{i-1}$。
* 值为 $0$。
  * 选择它，异或和为 $1$ 的方案数为 $F_{i-1}$，为 $0$ 的方案数为 $G_{i-1}$。
  * 不选择它，那么异或和为 $1$ 的方案数为 $F_{i-1}$，为 $0$ 的方案数为 $G_{i-1}$。
    
也就是说，

$$F_i=\begin{cases}F_{i-1}+G_{i-1} & (A_i\operatorname{and}2^k=1)\cr 2\times F_{i-1} & (A_i\operatorname{and}2^k=0)\end{cases}$$
    
$$G_i=\begin{cases}F_{i-1}+G_{i-1} & (A_i\operatorname{and}2^k=1)\cr 2\times G_{i-1} & (A_i\operatorname{and}2^k=0)\end{cases}$$

~~看上去完全一样嘛~~

但是初始值不一样，$F_0=0,G_0=1$。因为有空集的情况需要考虑。

最后第 $k$ 位的贡献为在第 $k$ 位上出现 $1$ 的次数，乘上 $2^k$。每组数据的结果就是每一位的贡献和。

复杂度$\mathcal O(m\times\log_2 v)$，其中 $m$ 为 $\sum|V_i|$，$v$ 为值域。时限有点紧……

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =30+3;
const int MOD  =998244353;
int c1[MAXN],c0[MAXN];
int main(){
    dn(qread(),1,T){
        int n=qread(),ans=0;
        up(0,30,i) c1[i]=0,c0[i]=1;
        up(1,n,i){
            int w=qread(); up(0,30,p){
                if(w&1){
                    int t1=c1[p],t0=c0[p];
                    c1[p]=c0[p]=(t1+t0)%MOD;
                }else c1[p]=(c1[p]<<1)%MOD,c0[p]=(c0[p]<<1)%MOD;
                w>>=1;
            }
        }
        up(0,30,i) ans=((LL)ans+((LL)c1[i]<<i))%MOD;
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：Little09 (赞：6)

现在题解里 Isaunoya  神仙的题解~~太简洁了~~，另外两个神仙方法和我不一样，所以我来写一句。

题意是求一个集合中所有子集异或和之和。

因为是异或运算，所以先拆位。考虑每一位，可以想到，要使贡献为 $1$，那么肯定是选奇数个 $1$ 和偶数个 $0$。我们分两种情况看一下：

- 所有的 $n$ 个数此位都是 $0$。那么显然贡献是 $0$。

- 有至少一个数的此位是 $1$。那么考虑其他 $n-1$ 个数不管选或者不选，都只需要控制这个 $1$ 的选或不选，就可以满足。所以情况是 $2^{n-1}$。

综上两种情况，可以看出结果是 $a_i$ 的**或和**再乘上 $2^{n-1}$。至于为什么是或和？你会发现或的计算和这个分类讨论是正好一致的。

代码应该通俗易懂了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int a[3000006]; 
const int mod=998244353;
int ans,res;
int main()
{
	int T;
	cin >> T;
	while (T--)
	{
		int n;
		scanf("%d",&n);
		ans=1,res=0;
		for (int i=1;i<=n;i++)
		{
			int x;
			scanf("%d",&x);
			res|=x;
			if (i!=1) ans=(ans*2)%mod;
		}
		res=res%mod;
		printf("%lld\n",(ll)ans*(ll)res%mod);
	}
	return 0;
}
```


---

## 作者：xxasmcd (赞：3)

这道题可以将每个数的每一位都拆开来进行统计，统计每一位一的个数，在每一位中只有一对这一位有贡献，当一的个数统计完之后，如果有贡献加上这一位所对应的贡献值即可。

还需要注意一点，输入规模较大得用快速的输入方式进行输入。

代码如下，赋予注释。
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[3000001],o[3000033];
int main()
{
    o[0]=1;
    for(int i=1;i<=3000032;i++)
    {
        o[i]=(o[i-1]<<1)%998244353;//二次幂，预处理贡献值
    }
    scanf("%d",&t);
    for(int i=1;i<=t;i++)
    {
        scanf("%d",&n);
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&a[j]);
        }
        long long ans=0;
        for(int j=0;j<31;j++)
        {
            int k=0;
            for(int p=1;p<=n;p++)//统计n个数这一位1的个数
            {
                if(a[p]&1)
                k++;
                a[p]>>=1;
            }
            if(k)//如果产生了贡献加上贡献值
                ans+=o[j+n-1];
        }
        printf("%ld\n",ans%998244353);
    }
    return 0;
}
```


---

## 作者：Vector_Mingfan (赞：3)

[**题目由此去**](https://www.luogu.com.cn/problem/P5390)

------------
**思路**

**主体思路**：求子集异或和的和

**步骤**：

拆成 $ 2 $ 进制，假设有 $ x $ 个数这一位为 $ 1 $ ，剩下 $ n-x $ 个数对答案没有贡献，对于这一位而言，对答案的贡献就是， $ x $ 个数选奇数个数的 **方案数**$*2^{n-x}.$

由二项式定理，$(1 - 1)^x = \sum\limits_{i=1}^na_i$ $(-1)^i*(x, i) = 0$



选奇数个和选偶数个方案是相同的，总共是 $ 2^x $ ,这样就是 $ 2^{x-1} $.

所以这一位的答案为：$ 2^{x - 1} * 2^{n - x} = 2^{n-1} $

所以对于所以所有位而言，总的答案就是**所有数或起来** $*2^{n-1}$

------------
```cpp
#include <cstdio>
#include <iostream>
#define N 3000005
#define mod  998244353
#define ll long long

using namespace std;

ll T, arr[N];

inline ll work(ll x, ll y) {
	ll r = 1;
	while (y > 0) {
		if (y & 1) 
			r = r * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return r;
}

int main() {
	scanf("%lld", &T);
	for (ll k=1; k<=T; k++ ) {
		ll n, ans = 0;
		scanf("%lld", &n);
		for (ll i=1; i<=n; i++ ) {
			scanf("%lld", &arr[i]);
			ans |= arr[i];
		}
		cout << (ans * work(2, n - 1) % mod) << "\n";
	}
	return 0;
} 
```


---

## 作者：EAlivn (赞：2)

**分析**


求集合中所有子集异或**和**

因为是异或运算所以要使贡献为 $1$ ,那么肯定是选奇数个 $1$ 和偶数个$0$。

所以有明显有两种情况

- 所有的$n$此位都是 $0$  -> 贡献为 $0$

- 有一个数 $N$ 此位是 $1$ .只需要这位选或是不选，与 $n-1$ 无关,所以所有情况为 $2^{n-1}$ 

所以最后结果是 $a_i$ 的或和 $\times$ $2^{n-1}$

(**一定是或和，因为或计算和这个分类讨论是相同的**)

代码也修了很多次

**代码**

```C++
#include<bits/stdc++.h>
using namespace std;
long long a[3000006];
const long long mod=998244353;
inline long long read(){//用着更舒服 
	long long x;
	scanf("%lld",&x);
	return x;
}
signed main() {
//	ios::sync_with_stdio(false);
	long long T=read();
	while (T--) {
		long long n=read();
		long long ans=1,tmp=0;
		for (long long i=1; i<=n; i++) {
			long long huo=read();
			//tmp|=read(); 这样写模拟不到错了/kk 
			tmp|=huo;
			if (i!=1) ans=(ans*2)%mod;
		}
		tmp%=mod;
		printf("%lld\n",(long long)(ans)*(long long)(tmp)%mod);
	}
}	
```

---

## 作者：fjy666 (赞：2)

### 0x00 题意
给你集合 $S$，共有 $n$ 个元素，对于所有 $S$ 的子集，求它们的异或和之和。
### 0x01 思路
考虑拆位。  
对于 $Ans$ 的每一位 $T$，
- 若对于任意 $x \in S$ ，只要有一个 $x$ 的 $T$ 位是 $1$，  
就可以将 $S$ 的子集分成两部分，$2^{n-1}$个有 $x$ 的，$2^{n-1}$个没 $x$ 的。  
其中，一部分的 $T$ 位是 $1$ ，一部分的 $T$ 位是 $0$。  
对于第 $T$ 位，它的贡献值是$2^{n-1} \times T$。

现在我们来考虑怎么求出每一位有没有 $1$。  
直接异或即可！  
所以答案就是 $2^{n-1} \times (S_1 \lor S_2 \lor S_3 ...... \lor S_{n-1} \lor S_n)$！
### 0x02 代码
```cpp
/*
LuoOJ / Luogu judger - enable - O2
Write by :fjy666
Time:2021-01-8
Language:C++11
*/
#include <cstdio>
#define fo(i_,j_,k_) for(int i_=j_;i_<=k_;++i_)
#define fr(i_,j_,k_) for(int i_=j_;i_>=k_;--i_)
#define It(type_) type_::iterator
#define rg register
#define rtn return
#define il inline

using ull = long long;
const ull P = 998244353;

ull fpm(ull a,ull b)
{
	a%=P;
	ull ans = 1ull % P;
	while(b)
	{
		if(b&1)ans = ans * a % P;
		a = a * a % P;
		b >>= 1;
	}
	rtn ans;
}

int main()
{
	int TestCases;
	scanf("%d",&TestCases);
	while(TestCases--)
	{
		int n;
		scanf("%d",&n);
		ull ans = 0,tmp;
		fo(i,1,n)
		{
			scanf("%lld",&tmp);
			ans |= tmp;
		}
		printf("%lld\n",fpm(2ull,n-1ull)%P*ans%P);
	}
	rtn 0;
}
```

---

## 作者：喵仔牛奶 (赞：1)

对 $\displaystyle\bigoplus_{p\in S} p$ 拆位，第 $k$ 位是 $1$ 仅当选了奇数个该位为 $1$ 的 $p$。

设共有 $x$ 个该位为 $1$ 的 $p$，则需要求出有多少种选取子集方案使得这位为 $1$：
- 若 $x=0$，有 $0$ 种方案。
- 若 $x\neq 0$，需要选取奇数个 $p$。由于选取奇数和偶数方案相等，所以有 $2^{n-1}$ 种方案。证明：$\displaystyle\sum_{i=0}^{n}(-1)^i\binom{n}{i}=(1-1)^n=0$。

故答案为所有数按位或和乘上 $2^{n-1}$。

---

## 作者：COsm0s (赞：1)

## $\mathcal{Solution}$

数学题。

既然涉及异或，考虑对答案拆位。

对于 $ans$ 的 当前第 $k$ 位，显然只有当这一位为 $1$ 时才对答案有用。

所以我们考虑如何让当前位 为 $1$。

要使贡献为 $1$，即选奇数个 $1$ 和偶数个 $0$。

我们进行分类讨论。

+ 若对于任意 $x\in V$，$x$ 的第 $k$ 位是 $0$，则本位贡献为 $0$。

+ 对于任意 $x\in V$，$x$ 的第 $k$ 位有一位是 $0$，则无论其他数在 $k$ 位上有多少个 $1$，只要调控 $x$ 的取舍，都可以满足。因为集合子集的方案数为 $2^n$，则贡献为 $2^k\times2^{n-1}$。

所以原问题转换为求当前位上是否有 $1$ 出现，即对于集合中的所有数做一遍或运算，最后乘上 $2^{n-1}$ 即可。

## $\mathcal{Code}$
```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 3e6 + 5, mod = 998244353;

int T, a[N];

int qpow(int x, int y) {
	
	int ans = 1;
	
	while (y) {
		
		if (y & 1) ans = ans * x % mod;
		
		x = x * x % mod;
		
		y >>= 1;
	}
	
	return ans;
}

void slove() {

	int n, ans = 0;

	cin >> n;
	
	for (int i = 1; i <= n; i ++) {
		
		cin >> a[i];
		
		ans |= a[i];
	}
	
	cout << (ans * qpow(2, n - 1) % mod) << '\n';
}
signed main() {

	ios_base::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);

	cin >> T;

	while (T --) {
		slove();
	}
	return 0;
}
```


---

## 作者：荒凌 (赞：1)

# P5390题解

## 思路

拿到题目（啊Cnoi数学题）蒟蒻的我一看$xor$突然意识到要二进制进行计算了

**设该位为$p$，当前数段为$C$,函数$J(x)$指奇数个数**

**枚举所有的位数，不难看出有有$(n-x)$当前位上为0**

**因为0无法使$p$上的值为1**

**所以$C中有奇数个数这一位上为1$**

**又因为抑或法则**

**所以$pXor=1$**

**可得$p=0$对$ans$无贡献**

**所以当$p=1$时$ans=J(C)·2^(n-1)$**

**用二项式推导，知道其方案数即为**
$2^{(x-1)}·2^{(n-x)}=2(n-1)$

**二项式定理：**
$$
∑_{k=0}^{k<=n}C_{n}^{k}a^{n-k}b^k
$$

~~由于不会求和符号markdown就随便表示了一下~~
## 注意

记得要每次%上$998244353$
## 最后code（已经挖坑了）
```c++
#include<bits/stdc++.h>
#define N 998244353
#define ll long long
using namespace std;
int main(){
	`ios::sync_with_stdio(false);`
    原本写快读的结果过不去老是WA
	ll ui;cin>>ui;
	for(int s=1;s<=ui;s++){
		ll n,sum;cin>>n>>sum;
		for(ll i=2;i<=n;i++){
			ll sumz;cin>>sumz;sum|=sumz%N;
		}
		ll p=1;
		for(ll i=1;i<=n-1;i++)(p*=2)%=N;
		cout<<((sum%N)*(p%N))%N<<endl;	
	}
}
```
## ~~广告~~
[#define 详解某dn我的blog](https://blog.csdn.net/weixin_43903850/article/details/108111833)
这用了宏定义，还有一个开关`ios::sync_with_stdio(false);`之所以不用`scanf`是因为

---

## 作者：Grisses (赞：0)

[题面](https://www.luogu.com.cn/problem/P5390)

观察题目，

发现对于异或而言二进制下每一位相对独立。

所以我们可以枚举集合内的元素的每一个二进制位，并计算它的贡献。

对于二进制下第 $i$ 位，我们假设 $n$ 个元素中有 $a$ 个该位为 $1$，$b$ 个该位为 $0$。易得 $a+b=n$。

- 如果 $a=0$，那么无论怎么选，这一位都不会产生贡献。即贡献为 $0$。
- 如果 $a>0$，那么假设第 $pos$ 个元素二进制下该位为 1。那么对于剩下 $n-1$ 种元素的 $2^{n-1}$ 种选法，每种选法产生的贡献不为 $0$ 就是 $2^{i-1}$，如果原来的贡献为 $0$，那我们选上第 $pos$ 个元素，将贡献改为 $2^{i-1}$；如果本身有贡献，我们就不选第 $pos$ 个元素，不变它。综合起来，总共献为 $2^{i-1}\times2^{n-1}$。

所以，我们将所有的元素全部或起来，最后乘上 $2^n-1$ 即可。

代码：
```cpp
  #include<bits/stdc++.h>
  #define int long long
  using namespace std;
  const int mod=998244353;
  int T,n,k,ans,num[40];
  int fpow(int a,int b){//快速幂
      if(b<0)return 1;
      int res=1;
      while(b){
          if(b&1)res=res*a%mod;
          a=a*a%mod;
          b>>=1;
      }
      return res;
  }
  signed main()
  {
      scanf("%lld",&T);
      while(T--){
          scanf("%lld",&n);
          for(int i=0;i<=35;i++)num[i]=0;//清空每一位
          for(int i=1,a,tot;i<=n;i++){
              scanf("%lld",&a);
              tot=0;
              while(a){
                  num[tot]+=(a&1);
                  a>>=1;
                  tot++;
              }
          }
          ans=0;
          for(int l=0;l<=30;l++){//此位有值，加上权值
              if(num[l])ans=(ans+(1<<l))%mod;
          }
          printf("%lld\n",ans*fpow(2,n-1)%mod);
      }
      return 0;
  }
```

---


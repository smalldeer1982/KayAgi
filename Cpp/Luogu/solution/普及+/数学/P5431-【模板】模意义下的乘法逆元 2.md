# 【模板】模意义下的乘法逆元 2

## 题目描述

给定 $n$ 个正整数 $a_i$ ，求它们在模 $p$ 意义下的乘法逆元。

由于输出太多不好，所以将会给定常数 $k$，你要输出的答案为：  
$$\sum\limits_{i=1}^n\frac{k^i}{a_i}$$

答案对 $p$ 取模。

## 说明/提示

对于 $30\%$ 的数据，$1\le n \le 10^5$。

对于 $100\%$ 数据，$1\le n \le 5\times 10^6$，$2\le k < p \le 10^9$，$1\le a_i < p$，保证 $p$ 为质数。

提示：本题时间限制较为严格，请注意使用较快的 IO 方式。

## 样例 #1

### 输入

```
6 233 42
1 4 2 8 5 7```

### 输出

```
91```

# 题解

## 作者：mrsrz (赞：161)

不明白其他题解为啥思路那么复杂。只要不被标题骗，这就是一道小学数学题？

这题就是很多个分数加起来。

那么根据小学数学知识，我们只要把所有分数通分就好了。

令$s=\prod a_i$，那么第$i$个分数通分后变为$\frac{k^i\times(s/a_i)}{s}$。

其中$s/a_i$相当于前面的数的乘积乘上后面的数的乘积，这个$O(n)$预处理出前、后缀积，然后$O(1)$求出来。

我们把分子加起来，最后再除以$s$即可，只需要一次求逆。

时间复杂度$O(n)$。

## Code：
```cpp
#include<cstdio>
#include<cctype>
typedef long long LL;
int n,k,md,pre[5000005],suf[5000005],a[5000005];
char buf[(int)1e8],*ss=buf;
inline int init(){buf[fread(buf,1,(int)1e8-1,stdin)]='\n';fclose(stdin);return 0;}
const int __START__=init();
inline int readint(){
    int d=0;
    while(!isdigit(*ss))++ss;
    while(isdigit(*ss))d=d*10+(*ss++^'0');
    return d;
}
inline int Inv(const int p){
    if(p==1)return 1;
    return((LL)(md-md/p)*Inv(md%p)%md);
}
int main(){
    n=readint(),md=readint(),k=readint();
    int ans=0;
    for(register int i=*pre=suf[n+1]=1;i<=n;++i)
    pre[i]=(LL)pre[i-1]*(a[i]=readint())%md;
    for(register int i=n;i;--i)
    suf[i]=(LL)suf[i+1]*a[i]%md;
    for(register int i=1,j=k;i<=n;++i,j=(LL)j*k%md)
    ans=(ans+(LL)j*pre[i-1]%md*suf[i+1])%md;
    printf("%lld",ans*(LL)Inv(pre[n])%md);
    return 0;
}

```

---

## 作者：DPair (赞：73)

//20190804update 修改了公式最后的推算错误（感谢用户@chenyewei_1234）

数学卡常题......（~~好像和逆元模板没什么关系吧......~~）
# 【前言】
### 过不了别怪我，自己多卡卡常。
## 【思路】
看到这道题，本蒟蒻第一想法是每一个数都求一个逆元，然后暴力计算。复杂度$O(nlogn)$

然而，我看到紫题的难度时，我慌了，然后发现数据是$n \leq 5*10^6$，需要$O(n)$的算法。

逆元是肯定要求的，那么怎么线性求逆元呢？

发现，线性求逆元可以用一个玄学的公式，求$1-n$的所有逆元，（详见模板1）。

这道题的所有$a_i$是不连续的，怎么办呢？

我们从逆元的意义来讲。

我们知道，这道题的$p$是不变的，而逆元的定义是：对于
$$ax \equiv 1(mod~~p)$$
$x$为$a$在模$p$意义下的逆元。

其实也就是在模$p$意义下的$\frac{1}{a}$。

那就好办了。

我们先把所有数的前缀积给求出来，然后把所有数的积的逆元求出来，一个一个乘，不就是每个$a_i$的逆元了？

这样，用$O(n + logn)$的复杂度就可以求出来了。

只用语言说不好理解，我还是用数学方法写一下吧。

## 【推算】（当然，以下运算都要取余）
我们设数组$a$的各项是：
$$a_1,a_2,a_3......a_n$$
则其逆元可表示为：
$$\frac{1}{a_1},\frac{1}{a_2},\frac{1}{a_3},......\frac{1}{a_n}$$
我们取一个数列$s$，表示：
$$s_i = a_1 * a_2 * ...... * a_i$$
其递推式为：
$$s_i = s_{i-1}*a_i$$
则：
$$\frac{1}{s_i} = \frac{1}{a_1 * a_2 * ...... * a_i}$$
易得其递推式为：
$$\frac{1}{s_{i-1}} = \frac{1}{s_{i}}*a_i$$
于是$\frac{1}{a_i}$可以表示为
$$\frac{1}{a_i}=s_{i-1}*\frac{1}{s_{i}}$$
其中$a_i$是已知的，$s_i$是线性递推的，而求出$\frac{1}{s_n}$后，可以再次线性递推出$\frac{1}{s_i}$。最后求出$\frac{1}{a_i}$

所以最终复杂度为$O(n*3 + logp)$，卡常后可以通过本题。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL n, MOD, k;
template <typename T>
inline void read(T &x)//快读
{
    char c;
    x = 0;
    int fu = 1;
    c = getchar();
    while(c > 57 || c < 48)
    {
        if(c == 45)
        {
            fu = -1;
        }
        c = getchar();
    }
    while(c <= 57 && c >= 48)
    {
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    x *= fu;
}
template <typename T>
inline void fprint(T x)//快输
{
    if(x < 0)
    {
        putchar(45);
        x = -x;
    }
    if(x > 9)
    {
        fprint(x / 10);
    }
    putchar(x % 10 + 48);
}
LL ksm(LL x, LL y)
{
    LL ret = 1, tmp = y;
    while(tmp > 0)
    {
        if(tmp & 1) ret = (ret * x) % MOD;
        tmp >>= 1;
        x = (x * x) % MOD;
    }
    ret %= MOD;
    return ret;
}
LL b[5000010], s[5000010], a[5000010], ans;
int main()
{
    read(n);
    read(MOD);
    read(k);
    b[n + 1] = 1;
    s[0] = 1;
    for (register int i = 1;i <= n;i ++)//线性求si
    {
        read(a[i]);
        s[i] = (s[i - 1] * a[i]) % MOD;
    }
    b[n + 1] = ksm(s[n], MOD - 2);//求逆元
    for (register int i = n;i >= 1;i --)//线性求1/si
    {
        b[i] = (b[i + 1] * a[i]) % MOD;
    }
    LL tmp = k;
    for (register int i = 1;i <= n;i ++)//线性求答案
    {
        ans = (ans + ((b[i + 1] * s[i - 1]) % MOD) * tmp) % MOD;
        tmp = (tmp * k) % MOD;
    }
    fprint(ans);
}
```







---

## 作者：ExcaIibur (赞：38)

看了其他题解，都是在求出分母的逆元的大背景下计算的，然而有求前缀积和后缀积再分别计算各项逆元的，有只求出前缀积或后缀积再利用分母逆元和各项关系算的，却没有这种朴素做法，也算是一种补充吧。

**有几个地方需要注意：**

1.所有相乘的式子如果是在int类型下都应该强制转换为**long long并模p**。

2.**快读**应该写标准，别看都是正数但不要省略读入非数字部分（被这个害惨了555555）。

3.式子实际上就是在模p意义下求各分数的和，我们可以**边读入边通分**，最后**分子乘以分母的逆元**即可。

4.**费马小定理**：它描述了一个整数a和质数p的关系即**a^(p-1)≡1 (mod p)**。结合a的模p意义下乘法逆元x的同余表示***a*x≡1 (mod p)**，我们易得 **x=a^(p-2)**，利用**快速幂**实现即可。

5.**ch-'0'=ch&15的说明：**‘0’的ASCII值为48，二进制表示**110000**，15的二进制为**1111**，利用**位与使得低位二进制0与数值0~9得到统一**。
```cpp
#include<cstdio>
#define int long long
#define re register//寄存类型变量,加快读取速度
#define il inline//关联函数减少调用成本
using namespace std;
int t,n,p,k,a,b=1;//a为分子，b为分母
char ch;
il void read(int &x){
	x=0;
	for(ch=getchar();ch<'0'||ch>'9';ch=getchar());
	for(;ch>='0'&&ch<='9';ch=getchar())
		x=(x<<3)+(x<<1)+(ch&15); 
}
int fpm(int x,int m){//费马小定理
	int ans=1;
	for(;m;x=x*x%p,m>>=1)
		if(m&1)ans=ans*x%p;
	return ans;
}
signed main(){
	read(n),read(p),read(k);
	for(re int i=1,c=k%p;i<=n;++i,c=c*k%p)
		read(t),a=(a*t+b*c)%p,b=b*t%p;//通分啊
	printf("%lld",a*fpm(b,p-2)%p);
} 
```
测试结果
![](https://cdn.luogu.com.cn/upload/image_hosting/omsoprmg.png)




---

## 作者：Rainy_chen (赞：20)

题是真的好题 我也是真的常数大  

### 题目大意
求
$$
Ans = \sum_{i=1}^n\frac {k^i}{a_i}\mod p
$$

### 题解
很显然我们可以按照一般求逆元的方式对每一个$a_i$求出逆元然后硬算，然后你发现这么做虽然看起来复杂度很对（$n=5000000\text{时}nlogn\approx 1.1e8$）,但是毒瘤鱼卡常了，这么写是过不去的。  

我们考虑怎么对$n$个整数用$O(n)$的时间求逆元  
首先我们可以令$A=\prod_1^na_i$ 之后求出$A$的逆元$A^{-1}$  
对于每一个数$a_i$ 我们可以发现$a_i$的逆元$a_i^{-1}$实际上就是$A^{-1}\times \prod_{j\not=i}a_j$  
这是因为$A^{-1}=\prod_{i=1}^na_i^{-1}$ 那么我们将不同于$a_i$的所有$a$乘上去以后就只剩下了$a_i^{-1}$这一项  

至于说怎么求出$\prod_{j\not=i}a_j$   
这很好办，你维护一下所有数的前缀积和后缀积就好了  

我们已经能够$O(n)$求出$n$个数的逆元了，那么我们再在枚举的时候顺便计算$k^i$这一项的值就能做到$O(n)$求出这个式子了  

即使这样 还有很多需要卡常的地方 比如开int不开longlong之类的 具体可以看代码qwq

### 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

typedef int int_t;

template<class T>
T read(T &x){
    x=0;char ch=0;
    while(ch < '0' || ch > '9')ch=getchar();
    while(ch >= '0' && ch <= '9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}

void exgcd(int_t a,int_t b,int_t &x,int_t &y){
    if(!b)x=1,y=0;
    else exgcd(b,a%b,y,x),y-=x*(a/b);
}

int qzj[5000010],hzj[5000010],s[5000010];

int main(){
    int_t n=read(n),p=read(p),k=read(k),tts=qzj[0]=1,ans=0,tk = k,y;
    for(int_t i=1;i<=n;++i) read(s[i]),tts=qzj[i]=tts*1ll*s[i]%p;
    exgcd(tts,p,hzj[n+1],y);
    for(int_t i=n;i;--i)hzj[i] = hzj[i+1] * 1ll * s[i] % p;
    for(int_t i=1;i<=n;i++,tk = tk * 1ll * k % p)
        ans = (ans + qzj[i-1] * 1ll * hzj[i+1] % p * tk % p) % p;
    if(ans<0)ans = ans % p + p;
    printf("%d",ans);
}
```

---

## 作者：C20203030 (赞：16)

普及选手又来做数论题啦！

## 一、题目

[点此看题](https://www.luogu.org/problem/P5431)

## 二、解法

这道题一看到就想暴力搞，然后$T$了。

我讲一种很巧妙的的解法，设$s[i]=\prod_{j=i}^{n} a[j]$，易得：

$inv[a[1]]=inv[s[1]]\cdot s[2]$

这个式子提醒我们可以只算全部的逆元，如果要求某一个的话，用类似差分的方式解决，算完一个然后把他在$inv$去掉（直接乘），就有了一个$O(n)$的方法。


```cpp
#include <cstdio>
#define int long long
const int MAXN = 5e6+5;
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int n,p,k,c=1,x,y,ans,a[MAXN],s[MAXN];
int exgcd(int a,int b,int &x,int &y)
{
	if(b==0){x=1;y=0;return a;}
	int d=exgcd(b,a%b,y,x);
	y-=(a/b)*x;
	return d;
}
signed main()
{
	n=read();p=read();k=read();
	s[n+1]=1;
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=n;i>=1;i--)
		s[i]=s[i+1]*a[i]%p;
	int d=exgcd(s[1],p,x,y);
	x=(x%p+p)%p;
	for(int i=1;i<=n;i++)
	{
		c=c*k%p;
		int inv=x*s[i+1]%p;
		ans=(ans+inv*c%p)%p;
		x=x*a[i]%p; 
	}
	printf("%lld\n",ans);
}
```


---

## 作者：yurzhang (赞：12)

## 题外话
其实我觉得这道题的考点是快读.jpg  
[没有快读的后果](https://www.luogu.org/recordnew/show/19507084)

## 正文
$$\large\text{以下运算均在模 }p\text{ 意义下进行}$$
$$\large\sum_{i=1}^{n}{\frac{k^i}{a_i}}=\sum_{i=1}^{n}{k^i\cdot a_i^{-1}}$$
我们考虑先求出 $a$ 序列的**前缀积**，记为 $s$ ：
$$\large s_i=\prod_{j=1}^{i}{a_j}$$
记 $a$ 序列前缀积的逆元为 $t$ ，此时如果我们知道这个序列，我们就可以知道 $a$ 中任意一个数的逆元：
$$\large a_i^{-1}=s_{i-1}\cdot t_i$$
而 前缀积的逆元 就等于 逆元的前缀积 ，所以我们只要求出 $t_n$ 就可以线性递推出整个 $t$ 序列了：
$$\large t_n=s_n^{p-2}$$
$$\large t_i=a_{i+1}\cdot t_{i+1}$$
这样我们就求得了 $a$ 序列的逆元，再用秦九韶算法就能在线性时间内算出题目的式子了。

## 参考代码
前方极差码风警告！
```cpp
#include <cstdio>

#define N 5000010
#define re register
#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++
typedef long long ll;
static char buf[100000],*pa(buf),*pb(buf);
inline int read() {
    re int x(0);re char c(gc);
    while(c<'0'||c>'9')c=gc;
    while(c>='0'&&c<='9')
        x=x*10+c-48,c=gc;
    return x;
}

inline int pow(int a,int b,int p) {
    int ans(1);
    while(b)
        ans=b&1?(ll)ans*a%p:ans,a=(ll)a*a%p,b>>=1;
    return ans;
}

int n,p,k,a[N],s[N]={1},inv_s[N],ans;

int main() {
    n=read(),p=read(),k=read();
    for(int i=1;i<=n;++i)
        a[i]=read(),s[i]=(ll)s[i-1]*a[i]%p;
    inv_s[n]=pow(s[n],p-2,p);
    for(int i=n-1;i;--i)
        inv_s[i]=(ll)inv_s[i+1]*a[i+1]%p;
    for(int i=n;i;--i)
        ans=((ll)inv_s[i]*s[i-1]%p+ans)*k%p;
    printf("%d",ans);
    return 0;
}
```
[评测记录](https://www.luogu.org/recordnew/show/19508395)  
~~5e6的输入，千万记得快读！~~

---

## 作者：SSerxhs (赞：10)

[乘法逆元](https://www.luogu.org/problemnew/show/P3811)的一般形式，实际上做法比传统的线性做法更简单。

有两种做法。这里只放法一的代码，有不影响阅读的坑。

第一种做法：预处理前缀积数组 $f[i]=\prod_{k=1}^ia_k$，设前缀积逆元数组为 $g[]$，则可以得到 $f[n]$ 的逆元 $g[n]$，由递推式 $g[i]=g[i+1]*a[i+1]$ 求得所有 $g[]$，则 $inv[a[i]]=f[i-1]*g[i]$。

```cpp
#include <stdio.h>
typedef long long ll;
const int N=5e6+2,M=5e6+2;
char c[M+2],*dd=c;
int a[N],b[N],s[N];
bool ed[N];
inline void read(register int &x)
{
    char *d=dd+1;
    while (((*d)<48)||((*d)>57)) ++d;
    x=*(d++)^48;
    while ((*d>=48)&&(*d<=57)) x=x*10+((*(d++))^48);
    dd=d;
}
inline int ksm(register int x,register int y,register int P)
{
    const int p=P;
    register int r=1;
    while (y)
    {
        if (y&1) r=(ll)r*x%p;
        x=(ll)x*x%p;
        y>>=1; 
    }
    return r;
}
int main()
{
    register int i,j,x,gs=0;
    c[fread(c+1,1,M,stdin)]=0;
    read(x);const int n=x;
    read(x);const int p=x;
    read(x);const int k=x;s[0]=1;
    for (i=1;i<=n;i++) { read(a[i]);s[i]=(ll)s[i-1]*a[i]%p;	}
    i=n;b[n]=ksm(s[n],p-2,p);
    while (--i) b[i]=(ll)b[i+1]*a[i+1]%p;j=k;
    for (i=1;i<=n;i++,j=(ll)j*k%p) gs=(gs+(ll)j*s[i-1]%p*b[i])%p;printf("%d",gs);
}
```

第二种做法：预处理前缀积数组 $f[]$ 和后缀积数组 $g[]$ 和 $inv[f[n]]=s$，则 $inv[a[i]]=f[i-1]*g[i+1]*s$。

---

## 作者：枫林晚 (赞：6)

就是一个trick：$O(n)+log(mod)$离线求逆元

设$s[i]$表示前i个数的连乘积。输入的时候顺便求出

再求出所有的数的乘积的逆元$inv$，即$inv=calcinv(s[n])$

设$iv[i]$表示，前i个数的逆元的连乘积。

发现，对于第i个位置的逆元$ni[i]=iv[i]\times s[i-1]$

而$iv[i]=iv[i+1]\times a[i]$，所以递推即可。

具体实现要卡常：

1.$iv[i]$不用数组，直接在$inv$上做变化即可。

2.为了减少循环次数，倒序计算答案，$k=k^n$，再不断乘上$k$的逆元。

具体可见代码：
```cpp
namespace Miracle{
int mod;
int mul(int x,int y){return (ll)x*y%mod;}
const int N=5e6+3;
int n,k,iv;
int a[N],s[N];
ll ans;
int main(){
    rd(n);rd(mod);rd(k);s[0]=1;
    for(reg i=1;i<=n;++i){
        rd(a[i]);s[i]=mul(s[i-1],a[i]);
    }
    int inv=qm(s[n]);
    iv=qm(k);k=qm(k,n);
    for(reg i=n;i>=1;--i){
        ans=ad(ans,mul(k,mul(inv,s[i-1])));
        inv=mul(inv,a[i]);
        k=mul(k,iv);
    }
    ot(ans);return 0;
}

}
```




---

## 作者：EternalEpic (赞：6)

第三次提交，调整了格式和不必要的冗余代码

这道题卡常数很毒瘤。好多人只有30或65分。我来谈谈自己的看法。

题目要求中保证p为质数，就意味着费马小定理和线性逆元在模意义下是成立的。

发现有Sigma拆不开，~~别管它，暴力通分就可以惹！~~

我和别人的做法略有不同（至少按目前题解来看）

我是先求出答案然后再利用费马小定理求逆元输出的。

就是res * (ll) qpow(sum, mod - 2) % mod，别人好像都是一开始inv[n + 1]把逆元求好，然后递推滴。

但是，很多人算法复杂度对但超时，常数优化要注意！！！

而这道题卡常需注意：1.fread要开普通快读过不了 2.要开编译优化（Ofast预备）3.可以用int就别用longlong

代码（含优化头文件专备卡常）：


```cpp
//Program written by Liu Zhaozhou ~~~
#include <bits/stdc++.h>

#pragma GCC optimize("Ofast")

using namespace std;

namespace Base {
    inline char gc(void)
    {
        static char buf[100000], *p1 = buf, *p2 = buf;
        return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
    }

    template <class T> inline void read(T &x)
    {
        T flag = (T) 1; x = 0; static char ch = gc();
        for (; ch > '9' || ch < '0'; ch = gc())
            flag = ch == '-' ? -1 : 1;
        for (; ch >= '0' && ch <= '9'; ch = gc())
            x = (x << 1) + (x << 3) + (ch & 15);
        x *= flag; return;
    }

    template <class T> inline void write(T x) {
        if (x < 0) putchar('-'), x = -x;
        static T y = (T) 1; int len = 1;
        for (; y <= x / 10; y *= 10) ++len;
        for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
    }

    template <class T> inline void writeln(T x) {write(x); puts("");}
    template <class T> inline void writeln(T x, char c) {write(x); putchar(c);}
    template <class T> inline void writeln(char c, T x) {putchar(c); write(x);}

    template <class T> inline void chkmax(T &x, const T y) {x > y ? x = x : x = y;}
    template <class T> inline void chkmin(T &x, const T y) {x < y ? x = x : x = y;}

    typedef long long ll;
    typedef unsigned long long ull;
    typedef long double ld;

    #define Ms(arr, opt) memset(arr, opt, sizeof(arr))
    #define Mp(x, y) make_pair(x, y)

    inline void file(string str) {
        freopen((str + ".in").c_str(), "r", stdin);
        freopen((str + ".out").c_str(), "w", stdout);
    }
}

using namespace Base;

enum {
    N = 5000005
};

int n, mod, k;
int inv[N], a[N];

inline int qpow(int a, int p) {
    register int ret = 1;
    for (; p; p >>= 1, a = (ll) a * a % mod)
        if (p & 1) ret = (ll) ret * a % mod;
    return ret;
}

int sum = 1, res = 0;
int now = 1, pre_mul = 1;

signed main(void) {
    read(n); read(mod); read(k);
    for (register int i = 1; i <= n; i++)
        read(a[i]), sum = (ll) sum * a[i] % mod;
    inv[n + 1] = 1;
    
    for (register int i = n; i >= 1; i--)
        inv[i] = (ll) inv[i + 1] * a[i] % mod;
    
    for (register int i = 1; i <= n; i++)  {
        now = (ll) now * k % mod;
        res = (res + (ll) now * pre_mul % mod * inv[i + 1] % mod) % mod;
        pre_mul = (ll) pre_mul * a[i] % mod;
    }
    
    writeln(res * (ll) qpow(sum, mod - 2) % mod);
    return 0;
}

/**/


```


谢谢兹磁！

---

## 作者：杨铠远 (赞：2)

感觉巨佬们推出$1/ai=s[i-1]* 1/s[i]$后说的不是很清楚

在这里着重讲解一下

因为需要用到$s[i]$的逆元

而$s[i]$可以递推出来

$s[i-1]=a[i]*(s[i]的逆元)$

$s[n]$可以直接用费马小定理求出

为了节省空间 $s[i]$的逆元可以和$a[i]$的逆元一起递推出 直接用一个变量就可以解决

## code:
```cpp
//Code by : Y-k-y
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#include <set>
#define int long long
const int N=5000010;
using namespace std;
inline int rnd(){
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
	return res*f;
}
inline void wr(int x){
	if(x<0){putchar('-');x=-x;}if(x>9) wr(x/10);putchar(x%10+'0');
}
int n,mod,k;
inline int fast(int x,int b){
	int ans=1,base=x%mod;
	while(b){
		if(b&1)ans=ans*base%mod;
		base=base*base%mod;
		b>>=1;
	}
	return ans%mod;
}
int a[N],sum[N],inv[N],sinv;
int ans;
signed main(){
	cin>>n>>mod>>k;
	int kk=k;
	sum[0]=1;
	for(int i=1;i<=n;i++){
		a[i]=rnd();
		sum[i]=sum[i-1]*a[i]%mod;
	}
	sinv=fast(sum[n],mod-2);
	for(int i=n;i>=1;i--){
		inv[i]=sum[i-1]*sinv%mod;//a[i]的逆元等于s[i-1]*(s[i]的逆元) 
		sinv=sinv*a[i]%mod;//变成s[i-1]的逆元 
	}
	for(int i=1;i<=n;i++){
		ans=(ans+kk*inv[i]%mod)%mod;
		kk=kk*k%mod;
	}
	wr(ans);
	return 0;
}
```


---

## 作者：Great_Influence (赞：2)

简单套路。

如果直接做，则复杂度为 $O(n\log p)$ ，不可能通过。

因此我们考虑优化。

可以先回忆阶乘的逆元是怎么算的。

我们计算阶乘的逆元的时候，是先求一个前缀积，然后求出最后一个前缀积的逆元后，一个个乘回去就可以得到每个阶乘的逆元了。

这个可以也这样处理。我们求出前缀积后，直接一个个乘回去就可以了。注意我们处理出的是每个前缀积的逆元，因此每个逆元再乘上上一个前缀积就可以得到这一个数字的逆元了。

用代码来说就是:

$$prd[i]=prd[i-1]*a[i]$$

$$inv[n]=inv(prd[n])$$

$$inv[k]=inv[k+1]*a[k]$$

$$realinv[k]=inv[k]*prd[k-1]$$

复杂度 $O(n+\log p)$ 。

注意这道题实际上并不需要将逆元存起来。我们只需要将数组翻转，然后在倒着乘回去的时候顺便计算答案就可以了。你也可以将前缀积改成后缀积。

代码:
```cpp
#include<cctype>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<iostream>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using IO::read;
using IO::write;
using IO::getc;
using IO::flush;

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void file()
{
#ifndef ONLINE_JUDGE
	freopen("water.in","r",stdin);
	freopen("water.out","w",stdout);
#endif
}

const int MAXN=5e6+7;

static int n,mod,k,a[MAXN];

inline void init()
{
	read(n),read(mod),read(k);
	Rep(i,1,n)read(a[i]);
}

static int sfd[MAXN];

inline int power(int u,int v)
{
	register int sm=1;
	for(;v;v>>=1,u=(ll)u*u%mod)if(v&1)
		sm=(ll)sm*u%mod;
	return sm;
}

inline void solve()
{
	sfd[n+1]=1;
	Repe(i,n,1)sfd[i]=(ll)sfd[i+1]*a[i]%mod;
	register int iv=power(sfd[1],mod-2),pwk=1,ans=0;
	Rep(i,1,n)
	{
		pwk=(ll)pwk*k%mod;
		ans=(ans+(ll)pwk*iv%mod*sfd[i+1])%mod;
		iv=(ll)iv*a[i]%mod;
	}
	cout<<ans<<endl;
}

int main()
{
    file();
    init();
    solve();
    return 0;
}

```

---

## 作者：Herry_NY (赞：1)

# 前提紧要
&emsp;&emsp;这种奇怪的方法虽然被我们机房的%姓男子呸了,但似乎并不需要什么特别难的卡常技巧,所以笔者决定贡献一篇题解23333  
## 思路
&emsp;&emsp;看到题的第一眼,诶这不是一个快速幂就可以水掉淼  
&emsp;&emsp;然后被%姓男子讽了"您老看看数据范围好不好"  
&emsp;&emsp;然后就有了这个神奇的想法  
&emsp;&emsp;我们考虑如何用O(n)的时间推出所有的逆元  
&emsp;&emsp;我们用fc表示a数组的前缀积,用inv表示fc数组的逆元  
&emsp;&emsp;易得
$$
	inv[n]=ksm(fc[n],p-2)
$$
$$
    inv[i]=inv[i+1]*a[i+1]\%p\;\;(i<n)
$$  
&emsp;&emsp;所以我们要的答案就可以用这两个式子推出
$$
	ans+=inv[i]*fc[i-1]*k^i
$$
&emsp;&emsp;$k^i$我们可以一开始用$S$表示$k^n$,然后边推逆元边将$S*k^{-1}$即可  
&emsp;&emsp;下面就是code时间
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ri register int
#define For(i,j,k) for(ri i=j;i<=k;i=-~i)
#define DFor(i,j,k) for(ri i=j;i>=k;i=~-i)
#define qwq(a,b) memset(a,b,sizeof(a))
#define frer(z) freopen(z".in","r",stdin)
#define frew(z) freopen(z".out","w",stdout)
#define gc() getchar()
template <class T>inline void read(T&x){
    bool f;char c=gc();
    for(f=0;!isdigit(c);c=gc())if(c=='-')f=1;
    for(x=0;isdigit(c);x=x*10+c-'0',c=gc());
    x*=f==1?-1:1;
}const int maxn=5e6+5;
int n,p,k,a[maxn],fc[maxn]={1},inv[maxn];ll ans,s=1;
inline int ksm(int a,int b){int res=1;while(b){if(b&1)res=1ll*a*res%p;a=1ll*a*a%p,b>>=1;}return res;}
int main(){
	read(n),read(p),read(k);
	For(i,1,n)read(a[i]),fc[i]=1ll*fc[i-1]*a[i]%p;s=ksm(k,n);
	inv[n]=ksm(fc[n],p-2),(ans+=1ll*s*inv[n]%p*fc[n-1]%p)%=p,k=ksm(k,p-2);
	DFor(i,n-1,1)s=1ll*s*k%p,inv[i]=1ll*inv[i+1]*a[i+1]%p,(ans+=1ll*fc[i-1]*s%p*inv[i]%p)%=p;
	printf("%lld\n",ans);
	return 0;
}
```


---


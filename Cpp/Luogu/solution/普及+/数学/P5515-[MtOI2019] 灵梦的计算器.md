# [MtOI2019] 灵梦的计算器

## 题目背景

**注: 该背景部分改编自 disangan233 中考前买计算器的真实事件。**  

博丽 灵梦 (Hakurei Reimu) 在成功抢回八云 紫 (Yakumo Yukari) 用隙间偷走的香火钱后，她和依神 紫苑 (Yorigami Shion) 去香霖堂买东西啦！  

灵梦想买一个计算器来计算神社的香火钱，但是因为香霖堂的东西太贵了，她选择使用河童重工网络 (Kawashiro Nitori's Network,KNN) 网购一个 Casio 计算器。

但出人意料的是，灵梦使用 KNN 买回来的 Casio 是个假货，最多只能显示整数部分（即向下取整）。   

灵梦很苦恼，因为这个计算器可能会导致一些特别大的误差。所以灵梦想让拥有外界的式神(指电脑)的你帮她解决一个问题。

## 题目描述

灵梦得到了3个实数 $n$ ，$a$ ，$b$ ( $4\le n\le 5,5 \le a,b \le 10$ ) ，她成功地计算了 $n^a+n^b$，得到了一个只显示整数部分的结果。  

灵梦想知道，若存在一个实数 $n'(n' \geq 0)$，使得 ${n'}^a+{n'}^b$ 的结果在计算器上与 $n^a+n^b$ 的结果显示出来**完全一致**时，$n'$ 的变化范围，即 $n'$ 的最大值与最小值之差。  

如果你不知道如何计算 $n^k$，请使用`cmath`库的`pow()`函数，`pow(n,k)`的结果即为 $n^k$ 的结果。    

---

为了提高本题的难度，灵梦给你设置了 $T$ 组询问。而为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问(代码来自河童重工)：  

~~~cpp
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}
~~~

在调用 `Mker::init()` 函数之后，你第 $i$ 次调用 `Mker::read(n,a,b)` 函数后得到的便是第 $i$ 次询问的 $n_i$, $a_i$ 和 $b_i$。     

为了减少你的输出量，令第 $i$ 次询问的答案为 $s_i$，你只需要输出 $\sum^{T}_{i=1} s_i$ 。如果你的答案与标准答案的绝对误差在 $10^{-2}$ 以内，你的答案则被视为是正确答案。

本题数据的生成采用时间复杂度**远远劣于**普通算法的高 (da) 精 (bao) 度 (li) 算法来保证精度，本题数据保证**单次询问的误差**小于 $10^{-10}$，**所以本题的SPJ范围对于正解来说是完全足够的。**

---

为了让你更好地做题，这里给出了关于 $op$ 的说明：   

* 当 $op=1$ 时，有 $a=b$，否则无特殊限定。  

## 说明/提示

### 子任务

![QQ图片20190707214000.png](https://i.loli.net/2019/07/07/5d21f64bc09c827059.png)


### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T2

出题人：disangan233

验题人：suwakow


## 样例 #1

### 输入

```
500 233 0```

### 输出

```
0.00503```

## 样例 #2

### 输入

```
10000 3141592653 0```

### 输出

```
0.10166```

## 样例 #3

### 输入

```
50000 1314159 0```

### 输出

```
0.50722```

## 样例 #4

### 输入

```
50000 1314159 1```

### 输出

```
1.51676```

## 样例 #5

### 输入

```
1000000 5201314 0```

### 输出

```
10.30487```

# 题解

## 作者：RiverFun (赞：25)

广告：我的[BLOG](https://stevebraveman.github.io/)

部分分很好拿，我就直接讲正解吧。

**前置知识：导数**

你需要了解导数的含义和一些初等函数的导数。

---

让我们先来用几何画板模拟一下这个题中的一个函数。

![](https://cdn.luogu.com.cn/upload/pic/74576.png)

我们会发现如果 $a,b$ 都在所归定的数据范围内，这个函数图像形状很像二次函数，并且这个函数增长速度非常快。

我们设满足题意的最小 $n'$ 为 $a_1$ ，满足题意的最大 $n'$ 为 $a_2$。

所以 $f(a_1) - f(a_2) < 1$

我们可以任取两个 $f(a_1),f(a_2)$ 来观察一下。

![](https://cdn.luogu.com.cn/upload/pic/74582.png)

又可以发现这几个点围成了一个三角形的图案。

可能这时候有人会说：函数图像明明是曲线啊，怎么可能会是直线呢？

是的，确实是曲线，但是，用题目中所给的数据计算的话，得出的答案很大，已经到了可以忽略曲率的地步，并且题目要求的精度也不高，所以我们能够直接把这段函数图像看成直线。

但是为题又来了，该如何求它的斜率呢？

这时候，我们就需要用到导数了！

因为导数所求的是在函数任意一点处的斜率，而又因为 $f(n)$ 一定在这段函数图像上，所以我们可以直接把 $f'(n)$ 当做这个三角形斜边的斜率。

最后就可以得出答案 $a_2 - a_1 = \frac{0.999}{f'(n)}$。

上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
namespace Mker {
#define uint unsigned int
	uint sd;
	int op;
	inline void init() {
		scanf("%u %d", &sd, &op);
	}
	inline uint uint_rand() {
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n() {
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k() {
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b) {
		n = get_n();
		a = get_k();
		if (op) b = a;
		else b = get_k();
	}
}
using namespace Mker;
int T;
double n, a, b, k, ans;
int main() {
	scanf("%d", &T);
	init();
	while (T--) {
		read(n, a, b);
		k = a * pow(n, a - 1) + b * pow(n, b - 1);
		ans += 0.9999999 / k;
	}
	printf("%0.5f", ans);
}
```

---

## 作者：disangan233 (赞：16)

## 题意

有 $3$ 个实数 $n$，$a$，$b$ ( $4\le n\le 5,5 \le a,b \le 10$ ) ，你求到了一个函数 $f(n)=n^a+n^b$的值。

求满足 $\lfloor f(n) \rfloor = \lfloor f(n') \rfloor$ 的 $n'$ 的变化范围，即 $\max (n')-\min (n')$  。

## Solutions

### Sol 1

直接枚举，时间复杂度 $O\left(\frac{T\times \max (ans)}{eps}\right)$，期望得分：$?~pts$。  

### Sol 2

考虑优化枚举。发现可以利用二分的思想，让精度不断提高。

时间复杂度 $O\left(T\log {10^{bit}} \right)$，单次精度为 $10^{\lfloor \log_{10} ans\rfloor-bit}$，期望得分：$65~pts$。

可以对 $10$，$12$，$19$ 号数据点打表，总得分 $80~pts$。

### Sol 3

这是来自 $\mathsf o \color{red} \mathsf{uuan}$ 的面向数据和SPJ的骗分方法。

考虑SPJ比较的是绝对误差，并且本题单次询问答案很小，随便试试就可以了，配合 **Sol 2** 可以得到更高的分数。

期望得分：$65-100~pts$，~~本来分数会更低，但是因为这个题太简单导致出题人不想卡。~~

$65~pts$ Code如下：

```cpp
int main()
{
        long long t, seed, op;
        cin >> t >> seed >> op;
        if (op) cout << t * 0.00003058;
        else cout << t * 0.00001028;
        return 0;
}
```

### Sol 4

这是来自 $\mathsf N \color{red} \mathsf{aCly~Fish}$ 的方法。

 要求出：使 $n^a+n^b$ 向下取整后相等的 $n$ 的差值，考虑牛顿迭代。

设 $y=\lfloor n^a+n^b\rfloor$，$f(x)=x^a+x^b$。

只要求出 $f(x)=y$ 和 $f(x)=y+1$ 两个方程的解，做差即可。

时间复杂度 $O(T\log y)$，期望得分：$80-100~pts$ 。

### Sol 5

单独考虑 $a=b$ 时的答案，设 $y=\lfloor n^a+n^b\rfloor=\lfloor 2n^a\rfloor$，$f(x)=2x^a$。

做法同**Sol 4**，但是因为$f(x)$可以构造出反函数 $arcf(x)=\sqrt[a] \frac{x}{2}$，可以单次 $O(1)$ 询问。

时间复杂度 $O(T)$，期望得分 $30~pts$，结合 **Sol 4** 可以得到 $90~pts$。

### Sol 6

发现在 $a \not = b$ 时无法轻松构造 $arcf(x)$，所以 **Sol 5** 无法继续扩展，考虑换一种 $O(1)$ 的反函数求法。

可以通过计算和画图发现 $f(x)$ 在区间 $[0,+\infty)$ 单调递增，考虑用 $g(x)=bx^k$ 去逼近 $f(x)$，可以发现当 $\Delta y=1$ 时，$|\Delta x|$ 是很小的。~~（其实也可以目力测量或者目力看样例）~~

因为 $|\Delta x|$ 很小，考虑用微分计算近似值来替换 $arcf(x)$

$$
\Delta y \approx \mathrm dy=f'(x) \Delta x
$$

所以可得 $\Delta x$ 的快速计算式

$$
\Delta x \approx \frac{\mathrm dy}{f'(x)}
$$

所以可推导出 $\Delta n'$ 的答案

$$
\Delta n' \approx \frac{1}{an^{a-1}+bn^{b-1}}
$$

对于本题极限数据来说，单次绝对误差 $\delta n'\approx \left|\sqrt[10] \frac{{2\times 5^{10}+1}}{2}-5-\frac{1}{20\times 5^{10}}\right| < 2\times 10^{-8} $。

由于本题数据随机生成，发现最大数据绝对误差不超过 $10^{-3}$，可通过本题。

时间复杂度 $O(T)$，期望得分：$100~pts$。


---

## 作者：细数繁星 (赞：5)

题目很简单，但是不能松懈！
## Solution

假设 $a=6, \ b=5$，得：
$
y=x^5(1+x)
$。

用计算器画出来，图像如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/jzqnaxps.png)

设 $q = \operatorname{min} n', p=\operatorname{max} n'$，得：
$
f(q)-f(p)<1
$。

缩小看一下
![](https://cdn.luogu.com.cn/upload/image_hosting/dermstqz.png)

一条直线！虽然我们都知道，这个说法不严谨，因为只是看起来像，不过对于本题来说（其实主要还是因为允许 $10^{-2}$ 以内的误差），以及足够了！

虽然说这个函数近似直线，但怎么求斜率呢？那就得用导数了！因为 $f(n)$ 位于直线上，可得 $f(n)$ 斜率为 $f'(n)$。

最后得：
$$
p-q=\frac{1}{f'(n)}
$$

## Code
```cpp
#include <bits/stdc++.h>
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}
using namespace Mker;
using namespace std;

int T;
double a, b, n, k, ans;
int main()
{
    cin >> T;
    init();
    for (int i = 0; i < T; i++)
    {
        read(n, a, b);
        k =  a * pow(n, a - 1) + b * pow(n, b - 1);
        ans += 1.0 / k; 
    }
    printf("%.5lf", ans);
}
```

---

## 作者：FLYC飘云 (赞：5)

# 牛顿迭代 题解


比赛时一看题目，妙啊，前几天才看过牛顿迭代，于是果断把牛顿迭代写上去了

## 0、审题

题目大意：

已知 $n,a,b$ 

$k=floor(n^a+n^b)$

求以下两个方程的根之差

$x^a+x^b=(k+1)$

$x^a+x^b=k$

求解方程第一反应二分查找，然而这么做会各种超时XD

所以就需要用到牛顿迭代大法

## 1、牛顿迭代简介
牛顿迭代是用于求函数的零点的重要的方法，输入一个初始值，通过迭代，可以不断逼近函数的零点，换个角度来说，就是不断提高方程近似解的精度

**公式:**

### $x_{n+1}=x_n-\frac{f(x_n)}{f(x_n)'}$

来自百度百科：

>已经证明，如果函数是连续的，并且待求的零点是孤立的，那么在零点周围存在一个区域，只要初始值位于这个邻近区域内，那么牛顿法必定收敛

## 2、解题思路

既然题目给出了两个方程，那么这可以以n为初始值，通过牛顿迭代求近似根

首先把方程转换成函数的形式

$f_1(x)=x^a+x^b-k$

$f_2(x)=x^a+x^b-k-1$

再求导

$f_1(x)'=f_2(x)'=ax^{a-1}+bx^{b-1}$

然后套牛顿迭代公式写出如下代码

```cpp
int x=n,a_=a-1,b_=b-1;
for(int i=0;i<1000;++i)
	x-=(pow(x,a)+pow(x,b)-k)/(a*pow(x,a_)+b*pow(x,b_));
```

本来想着说慢慢减少迭代次数，结果减着减着发现只需要迭代一次就正确了

于是把for去掉上交了一次，TLE四个点，看样子还有优化的余地

中场休息吃个午饭，猛然醒悟，既然只迭代了一次，那么为什么不继续化简呢,于是就有了

### $ans=\frac{n^a+n^b+k}{ax^{a-1}+bx^{b-1}}-\frac{n^a+n^b+k-1}{ax^{a-1}+bx^{b-1}}=\frac{1}{ax^{a-1}+bx^{b-1}}$

这样一来就只要进行两次乘方了

成功AC，为了排名又把op=1的点特判了一下，优化常数时间复杂度，最终成功混到了同分中运行时间最短，++排名

## 3、最终代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double n,a,b,sum=0;
int T,op;//我把生成器里的变量op拿出来了

//----------Mker我就省略了

void sol(){
	while(T--) Mker::read(n,a,b),sum+=1/(a*pow(n,a-1)+b*pow(n,b-1));
	cout<<sum;
}
void sol_(){
	while(T--) Mker::read(n,a,b),sum+=0.5/(a*pow(n,a-1));
	cout<<sum;
}
int main(){
	cin>>T;
	Mker::init();
	if(op) sol_();
		else sol();
	return 0;
}
```

运行时间([提交记录](https://www.luogu.org/record/23251811))

---

## 作者：Doveqise (赞：4)

这道题emmm一道牛顿迭代 ~~毒瘤卡常~~ 题（ 这里介绍一下比赛心路历程   
**温馨提示 为了更好的观感 代码中的Mker已隐藏 请自行添加**    
首先瞄一眼题 觉得可以二分答案找左右界 预期得分：70 实际得分：65  
代码如下：
```c++
#include<bits/stdc++.h>
using namespace std;
const double eps = 1e-7;
double now=0,ans=0;
bool equal(double a,double b)
{
    return a+eps>=b&&a-eps<=b;
}
double solve(double n,double a,double b)
{
    return pow(n,a)+pow(n,b);
}
double judge(double n,double a,double b)
{
    double mid,lft=4,rht=n;
    mid=(lft+rht)/2;
    while(!equal(lft,rht))
    {
        if(floor(solve(n,a,b))==floor(solve(mid,a,b)))
            rht=mid;
        else
            lft=mid;
        mid=(lft+rht)/2;
    }
    return lft;
}
double judge1(double n,double a,double b)
{
    double mid,lft=n,rht=5;
    mid=(lft+rht)/2;
    while(!equal(lft,rht))
    {
        if(floor(solve(n,a,b))==floor(solve(mid,a,b)))
            lft=mid;
        else
            rht=mid;
        mid=(lft+rht)/2;
    }
    return rht;
}
signed main()
{
    int T;
    scanf("%d",&T);
    double n,a,b;
    Mker::init();
    while(T--)
    {
        Mker::read(n,a,b);
        ans+=judge1(n,a,b)-judge(n,a,b);
        // printf("%lf\n",ans);
    }
    printf("%lf",ans);
    return 0;
}
```
然后被机房大佬牛顿迭代DD 然后写了个牛顿迭代 结果和暴力一个分 65分 代码如下   
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps = 1e-4;
double ans=0;
bool equal(double a,double b)
{
    return a+eps>=b&&a-eps<=b;
}
double f(double n,double a,double b)
{
    return pow(n,a)+pow(n,b);
}
double solve(double n,double a,double b)
{
    double ret=n-(f(n,a,b)/(a*pow(n,a-1)+b*pow(n,b-1)));
    while(!equal(floor(f(n,a,b)),floor(f(ret,a,b))))
    {
		ret=ret-((f(ret,a,b)-f(n,a,b))/(a*pow(ret,a-1)+b*pow(ret,b-1)));
	}
    return ret;
}
double solve2(double n,double a,double b)
{
    double ret=n-(f(n,a,b)/(a*pow(n,a-1)+b*pow(n,b-1)));
    while(!equal(floor(f(n,a,b))+1,floor(f(ret,a,b))))
    {
		ret=ret-((f(ret,a,b)-f(n,a,b)-1)/(a*pow(ret,a-1)+b*pow(ret,b-1)));
	}
    return ret;
}
signed main()
{
    int T;
    scanf("%d",&T);
    double n,a,b;
    Mker::init();
    while(T--)
    {
        Mker::read(n,a,b);
        ans+=fabs(solve2(n,a,b)-solve(n,a,b));
        // printf("%lf\n",ans);
    }
    printf("%lf",ans);
    return 0;
}
```  
（（接着机房大佬告诉我这玩意跑一遍就能满足精度需求  
然后就跑了一遍 只有80分，代码如下：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps = 1e-6;
double ans=0;
double f(double n,double a,double b)
{
    return pow(n,a)+pow(n,b);
}
double solve(double n,double a,double b)
{
    double ret=(f(n,a,b)-floor(f(n,a,b))/(a*pow(n,a-1)+b*pow(n,b-1)));
	return ret;
}
double solve2(double n,double a,double b)
{
    double ret=(f(n,a,b)-ceil(f(n,a,b))/(a*pow(n,a-1)+b*pow(n,b-1)));
    return ret;
}
signed main()
{
    int T;
    scanf("%d",&T);
    double n,a,b;
    Mker::init();
    while(T--)
    {
        Mker::read(n,a,b);
        ans+=solve(n,a,b)-solve2(n,a,b);
        // printf("%lf\n",ans);
    }
    printf("%lf",ans);
    return 0;
}
```
然后进行疯狂卡常 失败  
然后看大佬莫得用函数 就把函数搬出来  
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
double ans=0;
signed main()
{
    int T;
    scanf("%d",&T);
    double n,a,b;
    Mker::init();
    while(T--)
    {
        Mker::read(n,a,b);
        double powa=pow(n,a-1),powb=pow(n,b-1);
        ans+=(powa*a+powb*b-floor(powa*a+powb*b))/(a*powa+b*powb)-(powa*a+powb*b-ceil(powa*a+powb*b))/(a*powa+b*powb);
    }
    printf("%lf",ans);
    return 0;
}
```  
然后就A了emmm  
（（为什么比赛莫得把函数整出来啊QAQ  

---

## 作者：lzkAK2009 (赞：2)

## 题意
给定 $3$ 个实数 $n$、$a$、$b$，得到了函数 $f(n)=n^{a}+n^{b}$，求使得 $\lfloor f(n) \rfloor=\lfloor f(n') \rfloor$ 的 $n'$ 的取值范围。
## 思路
给定了函数 $y=f(n)$，可以得出 $f(n)$ 的导数
$$f'(n)=an^{a-1}+bn^{b-1}$$
同时给出了 $y$ 的变化范围
$$\Delta y=1$$
通过作图可以发现， $n$ 的变化范围 $\Delta n$ 很小，可以用微分很快的求出来
$$\Delta y\approx dy=f'(n)\Delta n$$
所以很容易就能得出 $n$ 的变化范围
$$\Delta n\approx \frac{\Delta y}{f'(n)}=\frac{1}{f'(n)}=\frac{1}{an^{a-1}+bn^{b-1}}$$
由于误差远小于 $10^{-3}$，所以可以通过本题。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
double n,a,b,ans;
int t;
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}
using namespace Mker;
int main(){
	scanf("%d",&t);
	init();
	for(int i=1;i<=t;i++){
		read(n,a,b);
		ans+=1.0/(a*pow(n,a-1)+b*pow(n,b-1));
	}
	printf("%.5lf",ans);
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：2)

### 简化题意

给定三个实数 $n, a, b$，求方程 $\left \lfloor {x ^ a + x ^ b} \right \rfloor = \left \lfloor {n ^ a + n ^ b} \right \rfloor$ 的解的最大值与最小值的差。

### 题目分析

前置知识：导数，极限。

题意可化为：求方程

$${x ^ a + x ^ b} = \left \lfloor {n ^ a + n ^ b} \right \rfloor$$

$${x ^ a + x ^ b} = \left \lfloor {n ^ a + n ^ b} \right \rfloor + 1$$

方程解的差。

画出图像来大概是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/1y4xxrjt.png)

我们可以发现，$\left \lfloor {n ^ a + n ^ b} \right \rfloor$ 和 $\left \lfloor {n ^ a + n ^ b} \right \rfloor + 1$ 这两个点的 $x$ 值靠的非常近，他们中间的曲线近似可以看做直线，因此我们可以把它当做直线斜率。

计算斜率的方法为求导。我们将 $f(x)$ 的导函数称为 $(x)'$，那么 $(x ^ a + x ^ b)' = (x^a)' + (x ^ b)' = a x^{a - 1} + b x ^ {b - 1}$ 。

然后将 $\left \lfloor {n ^ a + n ^ b} \right \rfloor$ 和 $\left \lfloor {n ^ a + n ^ b} \right \rfloor + 1$ 带入并化简得到答案为 $\frac{1}{a x^{a - 1} + b x ^ {b - 1}}$ （当然也可以用 $\tan$ 啦）

### 代码

```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;

namespace Mker
{
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}

using namespace Mker;

double n, a, b;
int T;

int main()
{
    scanf("%d", &T);
    init();

    double res = 0;
    while (T -- )
    {
        read(n, a, b);
        res += (double)1.00 / (a * pow(n, a - 1) + b * pow(n, b - 1));
    }
    
    printf("%.5lf\n", res);
    
    return 0;
}
```

---

## 作者：Digital_Sunrise (赞：1)

## 思路

这题的 $a,b$ 其大无比 $(5\le a,b\le 10)$ 。

再乘个 $n(4\le n\le 5)$ 。

最保守的估计是个 $8n^5$ ，

其函数的增长的速度已经达到了离谱的程度，

离谱到在到达 $n$ 的下限 $4$ 时它的曲线在题目要求的精度内已经可以作为一个直线考虑。

于是考虑算函数的导数（作为直线的斜率） $d=an^{a-1} \times bn^{b-1}$ ，

然后直接算出在 $y$ 轴变化 $1$ 时 $x$ 轴变化的量 $\dfrac{1}{k}$ 即为答案。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int T;
double ans;

namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}

int main()
{
    cin >> T;
    Mker::init();
    while(T--)
    {
        double n,a,b;
        Mker::read(n,a,b);
        double d = a * pow(n,a - 1) + b * pow(n,b - 1);
        ans += 1.0 / d;
    }
    cout << fixed << setprecision(5) << ans;
    return 0;
}
```

---

## 作者：Jayun (赞：1)

# 链接：

[洛谷](https://www.luogu.com.cn/problem/P5515)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14773786.html)

# 题目大意：

求出 $\lfloor n^a+n^b\rfloor$ 相等时，$n$ 的上下界的差值。

# 正文：

如果不取整，函数 $f(x)=x^a+x^b$ 的图象是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/u7qzijfl.png)

我们要找的是最大的 $x_1-x_2$。

现在我们知道 $f(x_1)-f(x_2)\rightarrow 1$，即它趋向于 $1$。我们知道斜率的公式是 $\frac{y_1-y_2}{x_1-x_2}=\frac{f(x_1)-f(x_2)}{x_1-x_2}$，我们可以通过斜率 $k$ 倒推 $x_1-x_2=\frac{f(x_1)-f(x_2)}{k}$。

而求斜率 $k$，可以求导。设 $u(x)=x^a,v(x)=x^b$，则 $f(x)=u(x)+v(x)$。

$$\begin{aligned}k=f'(x)&=u'(x)+v'(x)\\
&=(x^a)'+(x^b)'\\
&=ax^{a-1}+bx^{b-1}\end{aligned}$$

然后答案 $x_1-x_2=\frac{0.\dot{9}}{k}$。

# 代码：

```cpp
inline ll READ()
{
	ll x = 0, f = 1;
	char c = getchar();
	while (c != '-' && (c < '0' || c > '9')) c = getchar();
	if (c == '-') f = -f, c = getchar();
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x * f;
}

namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}

int t; 
double n, a, b, k, ans;

int main()
{
	t = READ();
	Mker::init();
	for (; t--; )
	{
		Mker::read(n, a, b);
		k = a * pow(n, a - 1) + b * pow(n, b - 1);
		ans += 0.9999999 / k;
	}
	printf ("%.5lf", ans);
	return 0;
}
```

---

## 作者：zzy2333 (赞：1)

表示对于官方题解有点蒙，其实这题用牛顿迭代法推出来的式子是一样的，并且牛顿迭代法理解起来更简单一些。

不懂牛顿迭代法的话可以参考[这篇日报](https://www.luogu.org/blog/zhang-xu-jia/niu-dun-die-dai-fa-yang-xie)

进入正题。这题看起来可以乱搞，于是我写了个二分交上去。
代码大概是这样:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const double eps=1e-11;
int t;
double n,a,b;
double ans=0;
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}
int main(){
	scanf("%d",&t);
	Mker::init();
	while(t--){
		Mker::read(n,a,b);
		int num=pow(n,a)+pow(n,b);
		double l=0.0,r=5.0;
		double maxn=-1.0,minn=10.0;
		while(r-l>eps){
			double mid=(l+r)/2;
			int now=pow(mid,a)+pow(mid,b);
			if(now==num){
				maxn=max(maxn,mid);
				l=mid;
			}
			else if(now<num)l=mid;
			else r=mid;
		}
		l=0.0,r=5.0;
		while(r-l>eps){
			double mid=(l+r)/2;
			int now=pow(mid,a)+pow(mid,b);
			if(now==num){
				minn=min(minn,mid);
				r=mid;
			}
			else if(now>num)r=mid;
			else l=mid;
		}
		ans+=maxn-minn;
	}
	printf("%.10lf\n",ans);
	return 0;
}
```
最后一个样例跑不出来，信仰交了一发，65分。

显然二分复杂度是不对的，于是开始考虑正解。

我们定义函数$ f(x)=x^a+x^b $
于是题目要求就是找到最小和最大的x，使$\lfloor f(x) \rfloor=\lfloor {f(n)} \rfloor$

发现$f(x)$单调增，所以上式也就是求一个x使$f(x)=\lfloor f(n) \rfloor  $或者是$\lfloor f(n) \rfloor+1 $

我们设$\lfloor f(n) \rfloor=num $

于是题目转化为，解下面这两个方程
$$ x^a+x^b=num $$
$$ x^a+x^b=num+1 $$
$f(x)$是可导的，于是可以用牛顿迭代法

于是开始码牛顿迭代法,其实看起来挺高端的东西代码挺短
就几行
```cpp
double solve(double num){
	double x=4.5;
	for(int i=1;i<=10;i++)x-=(pow(x,a)+pow(x,b)-num)/(a*pow(x,a-1)+b*pow(x,b-1));
	return x;
}
```
然后TLE了，跟暴力得分一样。
后来有大佬说把x出值设为n，迭代一次就能出结果

于是我试了试
```cpp
double solve(double num){
	double x=n;
	x-=(pow(x,a)+pow(x,b)-num)/(a*pow(x,a-1)+b*pow(x,b-1));
	return x;
}
```
然后只有80分

什么？这个解法不是单次$O(1) $吗

后来我突然想到pow函数算的很慢

于是我用k1,k2,k3,k4分别记录pow函数算出的值。

然后终于AC了，比赛的时候就是因为在最后时间A了这题排名没太惨，我还是太菜了。。。

完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int t;
double n,a,b;
double k1,k2,k3,k4;
double ans=0;
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#define uint unsigned int
	uint sd;int op;
	inline void init() {scanf("%u %d", &sd, &op);}
	inline uint uint_rand()
	{
		sd ^= sd << 13;
		sd ^= sd >> 7;
		sd ^= sd << 11;
		return sd;
	}
	inline double get_n()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return x + 4;
	}
	inline double get_k()
	{
		double x = (double) (uint_rand() % 100000) / 100000;
		return (x + 1) * 5;
	}
	inline void read(double &n,double &a, double &b)
	{
		n = get_n(); a = get_k();
		if (op) b = a;
		else b = get_k(); 
	}
}
double solve(double num){
	double x=n;
	x-=(k1+k2-num)/(a*k3+b*k4);
	return x;
}
int main(){
	scanf("%d",&t);
	Mker::init();
	while(t--){
		Mker::read(n,a,b);
		k1=pow(n,a);
		k2=pow(n,b);
		k3=k1/n;
		k4=k2/n;
		int num=k1+k2;
	//	double l=0.0,r=5.0;
		double maxn=solve(num+1),minn=solve(num);
		ans+=maxn-minn;
	}
	printf("%.10lf\n",ans);
	return 0;
}
```
另外，赛后看了题解之后想起来，其实num和num+1算出来的结果的差就是
$ \frac{1}{(a*k3+b*k4)} $把这个东西加起来输出就行了

---


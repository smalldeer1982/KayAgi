# 电学实验

## 题目描述

物理课上，小L和小K在做电学实验：“探究电阻两端的电压一定时，通过电阻的电流和电阻的大小的关系”。在这一实验中，控制电阻箱两端的电压为 $1~ V$ ，调节旋钮改变电阻箱的电阻，分别改为 $1 ~ \Omega , 2 ~ \Omega , 3 ~ \Omega , \ldots , n ~ \Omega $ ，分别读出对应的电流表示数为 $1 ~ A, \dfrac 1 2 ~  A , \dfrac 1 3 ~ A , ... ,\dfrac 1 n ~ A$ 。

在描述实验结论的时候，小L和小K产生了分歧。

小K：“众所周知，电阻两端的电压一定时，通过电阻的电流和电阻的大小成反比。也就是说，如果电阻箱两端电压保持不变，电阻箱的电阻为 $x ~ \Omega $ ，则通过电阻箱的电流为 $\dfrac 1 x ~ A$ 。”

小L：“但是我们为什么不可以用一个最高 $n-1$ 次的曲线去拟合它呢？”

为了改变小L的错误认识，小K决定先让 **小L按自己的结论** 去计算出电阻箱的电阻为 $(n+1) ~ \Omega$ 时，通过电阻箱的电流，然后进行实验，检验答案的正确性。同时，为了让小L更深刻地认识到自己的错误，小K决定进行多组实验，每组实验取不同的 $n$ 。

但是，小L在求解关于这 $n$ 组实验数据的最高 $n-1$ 次曲线时，遇到了问题。小L不想手算出这条曲线和曲线在 $(n+1) ~ \Omega $ 时的值，所以他找到了你，希望你能够求出这个值。

为了使运算更方便，小L将所有数据转化为取模 $998244353$ 意义下的整数值，你的输出也应该是这个整数值。但是，有时候数据的组数过多，导致实验数据或最后的运算结果没有意义，此时你需要输出 `-1` 。

## 说明/提示

对于 $10\%$ 的数据， $1\le n\le 6$ 。

对于 $30\%$ 的数据， $1\le n\le 50$ 。

对于 $50\%$ 的数据， $1\le n\le 5000$ 。

对于 $70\%$ 的数据， $1\le n\le 10^5$ 。

对于 $100\%$ 的数据， $1\le T\le 100,1\le n\le 10^{18}$ 。

## 样例 #1

### 输入

```
3
1
2
998244853```

### 输出

```
1
0
-1```

# 题解

## 作者：hsfzLZH1 (赞：22)

出题人： [hsfzLZH1](https://www.luogu.org/space/show?uid=43486)

本题主要考察数学知识和各种乱搞能力。

## 题目大意

给出一个最高 $n-1$ 次的多项式 $f(x)$ ，对于 $i\in \mathbb{Z}$ 且 $1\le i\le n$ ，有 $f(x)=x^{-1} ~ (\mod 998244353)$ ，求 $f(n+1)\mod 998244343$ 的值。

## 10pts

直接计算打表即可。

## 30pts

~~当然可以打出更大的表。~~

设 $f(x)=\sum_{i=0}^{n-1} a_i x^i$ ，即将点值表示法转化为系数表示法，然后带入 $x=n+1$ 求出值。

分别令 $x=1,2,\ldots , n$ ，可以得到 $n$ 条以 $a_i$ 为变量的多元一次方程，用 **高斯消元** 求解即可求出 $a_i$ 。时间复杂度 $O(Tn^3)$ 。

当然，也可以对每组数据进行一次 **拉格朗日插值** ，根据 $n$ 个点值插出另一个点值，时间复杂度 $O(Tn^2)$ 。

每次对相邻两个数进行差分，对差分数组再次进行差分，直到只剩下一个数，按这个数进行差分的逆运算，也可以求出 $f(n+1)$ 的值，时间复杂度 $O(Tn^2)$ 。

## 50pts

将询问离线，问题转化为：

1. 加入一个点值。

2. 设当前点值集合大小为 $s$ ，求出这 $s$ 个点对应的 $s-1$ 次多项式在某一处的值。

这个问题可以在预处理后单次操作 $O(s)$ 解决。

当然，将询问离线后，也可以在上次差分的基础上进行差分，单次也是 $O(n)$ 的。

时间复杂度 $O(n^2+T)$ 。

## 70pts

观察到本题给出的是在 $1,2,\ldots ,n$ 时的点值，这样的插值可以在 $O(n)$ 时间复杂度内解决的。时间复杂度 $O(Tn)$ 。

不知道有没有用分治 FFT 的 $O(n\log_2 n)$ 做法。

## 100pts

先考虑在什么时候会出现逆元未定义或不存在这样的多项式的情况，当 $n\ge 998244353$ 时，会出现逆元未定义的情况，而当 $n< 998244353$ 时，因为给出的点值均不相同，所以一定存在这样的多项式。

开始愉快地推式子：

根据拉格朗日插值的式子， $f(x)=\sum_{i=1}^n y_i \prod_{j\neq i} \dfrac {x-x_j} {x_i-x_j}$

令 $x=n+1,x_i=i,y_i=\dfrac 1 i$ ，有 $f(n+1)=\sum_{i=1}^{n} \dfrac 1 i \prod_{1\le j\le n,j\neq i} \dfrac {n-j+1} {i-j}$

$f(n+1)=\sum_{i=1}^n \dfrac  {\prod_{1\le j\le n,j\neq i}(n-j+1)} {\prod_{0\le j\le n,j\neq i} {i-j} }$

$f(n+1)=\sum_{i=1}^n \dfrac {(-1)^{n-i}n!} {(n-i+1)(n-i)!i!}$

$f(n+1)=\dfrac 1 {n+1} \sum_{i=1}^n (-1)^{n-i} \dfrac {(n+1)!} {(n-i+1)!i!}$

$f(n+1)=\dfrac 1 {n+1} \sum_{i=1}^n (-1)^{n-i} C_{n+1}^{i}$

$f(n+1)=\dfrac 1 {n+1} (-(-1)^n C_{n+1}^0 -(-1)^{-1} C_{n+1}^{n+1}+\sum_{i=0}^{n+1} (-1)^{n-i}C_{n+1}^i)$

$\sum_{i=0}^{n+1} (-1)^{n-i}C_{n+1}^i=-(1-1)^{n+1}=0$

$f(n+1)=\dfrac {1-(-1)^n} {n+1}$

所以， $n$ 是偶数时， $f(n+1)=0$ ； $n$ 是奇数时， $f(n+1)=\dfrac 2 {n+1}$ 。（这个规律应该打表也能找得出来）

## 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const ll mod=998244353;
ll T,n;
ll ksm(ll a,ll k)
{
	ll ret=1,x=a%mod;
	while(k)
	{
		if(k&1)ret=ret*x%mod;
		x=x*x%mod;k>>=1;
	}
	return ret;
}
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n);
		if(n>=mod)printf("-1\n");
		else if(n&1)printf("%lld\n",2*ksm(n+1,mod-2)%mod);
		else printf("0\n");
	}
	return 0;
}
```

---

## 作者：jijidawang (赞：8)

带来 Krydom 的最新科技！！！ 

***

我们令 $g(x)=x\cdot f(x)-1$ .

显然，$1,2,3,\cdots,n$ 均为 $g(x)$ 的根，则 $g(x)$ 可以表示为
$$g(x)=C\cdot (x-1)(x-2)\cdots(x-n)$$
不难发现，
$$C=\dfrac{(-1)^n}{n!}$$
所以，
$$f(n)=\dfrac{g(n)+1}n=\dfrac{(-1)^{n+1}+1}{n}$$
直接求即可 .

代码略 .

---

## 作者：lam_dyr (赞：7)

题解区大佬们的拉格朗日插值看的本蒟蒻一脸恐慌，那就写一篇亲民的题解吧。

## 题意

题面较长，核心是要用一个 $n-1$ 次多项式 $P(x)$ 拟合点 $(i,\frac{1}{i})$，然后计算 $P(n+1)$ 在模 $998244353$（以下简称 $MOD$）意义下的值。

## 思路

直接求该多项式的值是困难的，我们不妨先判一下下无解的情况。

- $n+1\ge MOD$：题目中 $n$ 的范围是 $1\le n\le 10^{18}$，如果 $n+1\ge MOD$，此时 $n+1$ 在模 $MOD$ 意义下为 $0$，逆元不存在，所以直接输出 $-1$。

~~以上不懂的请自行查阅有关逆元的知识。~~

判完无解之后如何考虑呢？我们可以分类讨论。考虑能覆盖所有情况的分类——奇偶性讨论。

在讨论之前，我们不妨先通过构造转化一下。

令 $Q(x)=x\times P(x)-1$，其中 $P(x)$ 是我们要拟合的多项式。根据题意，$P(i)=\frac{1}{i}$，所以 $Q(i)=i\times\frac{1}{i}-1=0$ 对于 $i=1,2,\dots,n$ 成立。因此，我们可以将 $Q(x)$ 转化为：$Q(x)=C\times(x-1)(x-2)\dots(x-n)$，其中 $C$ 是一个常数。

我们构造 $Q(x)$ 有什么用呢？当然是为了方便计算 $P(n+1)$ 啦！根据 $Q(x)$ 的定义，有：

$$Q(n+1)=(n+1)\times P(n+1)-1$$

所以：

$$P(n+1)=\frac{Q(n+1)+1}{n+1}$$

$$P(n+1)=\frac{C\times(n+1-1)(n+1-2)\dots(n+1-n)+1}{n+1}$$

$$P(n+1)=\frac{C\times n!+1}{n+1}$$

经过以上推导，我们就可以开始愉快的分类讨论了。

- **$n$ 为偶数：**

当 $n$ 为偶数时，我们考虑 $Q(0)$ 的值。

$$Q(0)=C\times(-1)\times(-2)\times\dots\times(-n)=C\times(-1)^n\times n!$$

由于 $n$ 是偶数，所以 $(-1)^n=1$，因此：

$$Q(0)=C\times n!$$

同时，根据 $Q(x)$ 的定义，$Q(0)=0\times P(0)-1=-1$。因此：

$$C=\frac{-1}{n!}$$

带入 $P(n+1)$ 的表达式：

$$P(n+1)=\frac{(\frac{-1}{n!})\times n!+1}{n+1}=\frac{-1+1}{n+1}=0$$

所以，当 $n$ 为偶数时，$P(n+1)=0$。

- **$n$ 为奇数：**

同理，当 $n$ 为奇数时，考虑 $Q(0)$ 的值。

$$Q(0)=C\times(-1)^n\times n!=-C\times n!$$
又因为 $Q(0)=-1$，所以 $-C\times n!=-1$，$C=\frac{1}{n!}$。

带入 $P(n+1)$，得：

$$P(n+1)=\frac{\frac{1}{n!}\times n!+1}{n+1}=\frac{2}{n+1}$$

所以，当 $n$ 为奇数时，$P(n+1)=\frac{2}{n+1}$（模 $MOD$ 意义下）。

注意此时要先计算 $n+1$ 的逆元。

## Code

~~以下是短的吓人的代码。~~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=998244353;
ll ksm(ll a,ll b,ll mod){
    ll res=1;
    a%=mod;
    while(b>0){
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    int T;
    cin>>T;
    while(T--){
        ll n;
        cin>>n;
        //判断n+1是否大于等于模数
        if(n>=MOD){
            cout<<"-1\n";
            continue;
        }
        //如果n是偶数，输出0
        if(n%2==0){
            cout<<"0\n";
            continue;
        }
        //如果n是奇数，计算2/(n+1) mod 998244353
        //先计算逆元
        ll inv=ksm(n+1,MOD-2,MOD);
        ll ans=(2*inv)%MOD;
        cout<<ans<<"\n";
    }
}
```

---

## 作者：StupidSeven (赞：3)

## Subject 
[题目传送门](https://www.luogu.com.cn/problem/P5553)

题意：给定一个 $n-1$ 次多项式 $f(x)$ ， $\forall\ x\in[1,n]$ ， $f(x)=\dfrac{1}{x}$ ，求 $f(n+1)$ 。

## Analysis
我们构造一个多项式 $g(x)=xf(x)-1 ,x\in[1,n]$ ，显然 $g(x)=0$ 有 $n$ 个根，可以写成根的形式 :
$$g(x)=C\times\prod\limits_{i=1}^n(x-i)$$
其中 $C$  是一个常数。由上面 $g(x)$ 我们知道 $g(x)$ 的常数项是 $-1$ 。根据韦达定理我们知道根的形式下 $g(x)$ 的常数项为 $C\times(-1)^n\times n!$ ，所以 $C$ 为 $\dfrac{(-1)^{n-1}}{n!}$ 。

那么我们就可以把 $g(x)$ 写出来了：
$$g(x)=\dfrac{(-1)^{n-1}}{n!}\times\prod\limits_{i=1}^n(x-i)$$

那么 $g(n+1)$ ，就是：
$$g(n+1)=\dfrac{(-1)^{n-1}}{n!}\times\prod\limits_{i=1}^n(n+1-i)$$

右边显然是 $n!$ ，所以 $g(n+1)=(-1)^{n-1}$ ，又因为 $g(x)=xf(x)-1$ ，所以 $f(n+1)=\dfrac{(-1)^{n-1}+1}{n+1}$ ，当 $n$ 是奇数时， $f(n+1)=\dfrac{2}{n+1}$ ，求一下逆元就可以取模了。当 $n$ 是偶数是， $f(n+1)=0$ ，这样就写完啦。

---

## 作者：Mikefeng (赞：0)

# P5553 电学实验

## 题目大意：

设多项式 $f(x)$ 满足 $f(x)=\frac{1}{x}(x=1,2,\cdots,n)$

求 $f(n+1)\mod 998244353$ 的值。

## 思路

设 $g(x)=f(x)\times x-1=\frac{1}{x} \times x-1=0$

因为 $x=1,2,\cdots,n$，所以 $(x-1),(x-2),\cdots,(x-n)$ 中有一个为零。

所以 $g(x)=(x-1)\times (x-2)\times \cdots \times (x-n)\times c$。（$c$ 是一个常数）

又因两个式子中的常数项相等，所以 $(-1) \times (-2) \times \cdots \times (-n) \times c=(-1)^n \times n! \times c = -1$

所以 $c=\frac{-1}{(-1)^n \times n!}=\frac{(-1)^{n+1}}{n!}$

将 $c$ 代入第二个式子，得：
$g(n+1)=n\times(n-1)\times \cdots \times 1 \times c = n! \times \frac{(-1)^{n+1}}{n!}=(-1)^{n+1}$

由 $g(x)$ 的定义得 $g(n+1)=f(n+1)\times(n+1)-1$

因此 $f(n+1)=\frac{(-1)^{n+1}+1}{n+1}$

当 $n$ 大于 $998244353$ 时，运算结果无意义。

$n$ 为奇数时 $f(n+1)=0$，$n$ 为偶数时 $f(n+1)=\frac{2}{n+1}$。

## 代码

```cpp
#include<iostream>
#define m 998244353
using namespace std;
long long n,t;
long long fm(long long x,long long y){
	long long ans=1,a=x%m;
	while(y){
		if(y&1) ans=ans*a%m;
		a=a*a%m;
		y>>=1;
	}
	return ans;
}
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		if(n>=m) cout<<-1<<endl;
		else if(n&1) cout<<2*fm(n+1,m-2)%m<<endl;
		else cout<<0<<endl;
	}
	return 0;
}
```


---

## 作者：暗影之梦 (赞：0)

## 题目大意：
设多项式 $f(x)$ 满足 $f(k)= \frac{1}{x} $ $x=1,2,...n+1$

求 $f(n+1)$

## 解题思路：
一般解法是用拉格朗日差值做的，这里提供另一个思路：

设另一个多项式 $g(k)$ ,使 $g(k)=f(k)*k-1$ 

由 $f(x)$ 可得 $g(x) = (x-1)*(x-2)*...*(x-n-1)*c$ , $c$ 为一个常数项。

再将 $g(x)=(x-1)*(x-2)*...*(x-n-1)*c$ 与 $g(x)=f(x)*x-1$ 对比，可得 $g(x)=f(x)*x-1$ 中的常数项 $-1$ 等于 $g(x) = (x-1)*(x-2)*...*(x-n-1)*c$ 中的常数项 $(-1)^n*(n+1)!*c$ 。则 $c= \frac{(-1)^n}{(n+1)!}$ 。

最后将 $c$ 的值带入当 $x=n+1$ 时 $g(x)=(x-1)*(x-2)*...*(x-n-1)*c$ ，发现 $x-1=n+1$ , $x-2=n$ ... $x-n-1=1$ 。则 $g(n+1)=(n+1)!*\frac{(-1)^n}{(n+1)!}=(-1)^n$。

因为 $g(k)=f(k)*k-1$ ，所以 $f(n+1)= \frac{(g(n+1)+1)}{n+1}= \frac{[(-1)^n+1]}{n+1}$.

因此，当 $n$ 是偶数时， $f(n+1)=0$ ;当 $n$ 是奇数时， $f(n+1)=\frac{2}{n+1}$ 。处理结果时用费马小定理的分数次方取模来快速幂即可

---


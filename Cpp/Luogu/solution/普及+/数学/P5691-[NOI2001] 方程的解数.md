# [NOI2001] 方程的解数

## 题目描述

已知一个 $n$ 元高次方程：         
$$\sum\limits_{i=1}^n k_ix_i^{p_i} = 0$$
其中：$x_1, x_2, \dots ,x_n$ 是未知数，$k_1,k_2, \dots ,k_n$ 是系数，$p_1,p_2,…p_n$ 是指数。且方程中的所有数均为整数。

假设未知数 $x_i \in [1,m] \space ( i \in [1,n])$，求这个方程的整数解的个数。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le n \le 6$，$1\le m \le 150$，且
$$\sum\limits_{i=1}^n |k_im^{p_i}| < 2^{31}$$  
答案不超过 $2^{31}-1$，$p_i \in \mathbb N^*$。

## 样例 #1

### 输入

```
3
150
1 2
-1 2
1 2```

### 输出

```
178```

# 题解

## 作者：LawrenceSivan (赞：23)

# P5691 [NOI2001] 方程的解数

updated 修复了一点点乱码

## 前言

最近在复习折半搜索。

其实折半搜索除了这个还有一些好题的：

[P4799 [CEOI2015 Day2]世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)

[P3067 [USACO12OPEN]Balanced Cow Subsets G](https://www.luogu.com.cn/problem/P3067)

[CF888E Maximum Subsequence](https://www.luogu.com.cn/problem/CF888E)

## 题意

求方程 $\sum \limits_{i=1}^n k_ix_i^{p_i}=0, x_i \in [1,m](i\in [1,n])$ 的整数解的个数。

最为朴素的方法是枚举 $x_i$，然后复杂度就是 $O(m^n)$ 的。~~GG~~

想办法降复杂度。

首先 $x_i$ 是肯定要枚举的，但是肯定又不能直接枚举。

于是考虑怎样把指数降下去。

可以用 折半搜索（_meet in middle_）.

## 折半搜索

做法为将整个搜索的过程分为两部分，然后每部分分别进行搜索，最后将得到两个答案序列，再将答案序列进行合并，即可得到最终的答案。

可以发现，当状态非常之多的时候，这种优化还是非常明显的，最优情况下可以直接把复杂度开个根号。

需要注意的是，折半搜索应用的时候需要满足以下条件：

- 搜索各项不能相互干扰。

- 需要满足搜索状态可逆，就是说一个状态可以从两个方向都得到。

折半搜索其实还是用的比较广泛的。

BFS ,DFS 还有状压 DP 都有类似的应用。

折半搜索一般的难点就在于最后的答案序列合并。（可能会使用一些奇奇怪怪的高深的玩意才能搞得出来）

实现非常灵活，需要按照题目来进行选择。

一般比较常见的排序后二分，双指针还有哈希表（自然还有一些我没见过的）。

逐个分析一下（以下的代码均不是本题的，只是提供一下大概的板子长啥样）：

排序后二分 复杂度肯定是带 $\log$ 的。

为什么正确？

在一个有序的序列中，如果我们可以找到一个位置可以做到对答案有贡献，那么这个位置之前的所有位置都是可以对答案有贡献的。

所以直接统计就好。

```cpp
sort(a+1,a+1+cnta);
for(re int i=1;i<=cntb;i++)
    ans+=upper_bound(a+1,a+1+cnta,m-b[i])-a-1;
```

双指针一般是线性的，效果很不错，代码比较好写。

缺点就是比较难想，需要考虑一些问题（例如单调性）。

```cpp
int l=cnta,r=1;
for(r=1;r<=cntb;r++){
	while(a[l]+b[r]>m)l--;//m是一个限制条件
	if(a[l]&&b[r])ans+=(l-1);  
} 
```

哈希表也是线性，至于具体如何就要看脸了。

如果不被卡的话哈希表确实是一种非常不错的选择。

具体就是先处理一半，然后把搜到的答案存到哈希表里，然后搜另一半，之后再去哈希表里找，把结果合并就可以了。

```cpp
void dfs1(){//搜索一半 
	if (到达边界){
		add(hash(x)); 
		return;
	} 
	... 
}

void dfs2(){//处理另一半 
	if (到达边界){
		ans+=sum[hash(x)];
		return;
	} 
	... 
}

```

## 本题解法

观察这个式子，想办法把 $n$ 的规模降为原来的一半。

$\sum \limits_{i=1}^n k_ix_i^{p_i}=0$

把左边拆开得：

$\sum \limits_{i=1}^{\lfloor n/2 \rfloor} k_ix_i^{p_i}+\sum \limits_{\lfloor n/2 \rfloor}^{n} k_ix_i^{p_i}=0$

移项得：

$\sum \limits_{i=1}^{\lfloor n/2 \rfloor} k_ix_i^{p_i}=-\sum \limits_{\lfloor n/2 \rfloor}^{n} k_ix_i^{p_i}$

于是这样就可以折半搜索了。

接下来确定一下是否满足性质：

- $x_i$ 的不同取值不会影响别的答案，方程的解数量不会发生改变。

- 因为是要枚举 $x_i$ 的取值，所以无论怎么搜，答案都是一样的，所以满足状态可逆。

考虑合并。

可以发现，等号两边的区别在于有一个负号。

于是我们可以搜一半，然后找另一半中满足 与它相加等于 $0$ 的数，也就是相反数。

之后合并答案就可以了。

关于哈希的合并方法和排序后二分别的题解已经说的很清楚了，这里主要说一下双指针的统计方法。

首先将两个答案数组排序。

然后找到两个相加满足条件的第一个位置，然后统计左半部分一样的有多少个，右半部分一样的有多少个，然后运用乘法原理合并起来就好了。

```cpp
sort(a+1,a+1+cnta);
sort(b+1,b+1+cntb);
	
int l=1,r=cntb;
for (;l<=cnta&&r>=1;l++){
	while (a[l]+b[r]>0)r--;//找到满足条件的第一个位置
	int x=1,y=0;
	for(int j=r;a[l]+b[j]==0&&j>0;j--)y++;//计算第二个部分有多少个满足的的
	while(l<cnta&&a[l]==a[l+1])x++,l++;//计算左半部分有多少一样的
	ans+=x*y;//乘法原理
} 
```

## CODE：

```cpp
//#define LawrenceSivan

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define re register
const int maxn=4e6+5;
#define INF 0x3f3f3f3f

int n,m;

int k[10],p[10];

int a[maxn],b[maxn],cnta,cntb,ans;

int qpow(int a,int b){
	int res=1,x=a;
	for(;b;b>>=1,x=x*x){
		if(b&1)res=res*x;
	}
	return res;
}

void dfs(int l,int r,int sum,int *arr,int &cnt){
	if(l>r){
		arr[++cnt]=sum;
		return;
	}
	for(re int i=1;i<=m;i++)
		dfs(l+1,r,sum+k[l]*qpow(i,p[l]),arr,cnt);
	
}

inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    return x*f;
}

int main(){
#ifdef LawrenceSivan
    freopen("aa.in","r",stdin);
    freopen("aa.out","w",stdout);
#endif
	n=read();m=read();
	for(re int i=1;i<=n;i++){
		k[i]=read();p[i]=read();
	}
	
	int mid=(1+n)>>1;
	dfs(1,mid,0,a,cnta);
	dfs(mid+1,n,0,b,cntb);

	sort(a+1,a+1+cnta);
	sort(b+1,b+1+cntb);
	
    
	int l=1,r=cntb;
	for (;l<=cnta&&r>=1;l++){
	    while (a[l]+b[r]>0)r--;
	    int x=1,y=0;
	    for(re int j=r;a[l]+b[j]==0&&j>0;j--)y++;
	    while(l<cnta&&a[l]==a[l+1])x++,l++;
	    ans+=x*y;
	} 
	 
	 
	printf("%lld\n",ans);
	
    return 0;
}

```

 


---

## 作者：nofall (赞：20)

题意:求满足$n$元方程$\sum_{i=1}^{n}k_i*x_i^{p_i}=0$的$n$元整数组的个数。

$n<=6, x_i<=150$

常规做法是枚举$x_i$，时间复杂度是$O(150^6)$的，显然过不了。

那我们可以想一想能不能把复杂度上的指数减半(因为减半了就能过了)。

所以我们可以把原式折成两半，即$\sum_{i=1}^{\lfloor{n/2}\rfloor}k_i*x_i^{p_i}=-\sum_{\lceil{n/2}\rceil}k_i*x_i^{p_i}$

然后我们先做左半边，将所有情况求和得到的值$x$，存入哈希表里。

处理好左半边，再处理右半边。

右半边每算出来一个$y$，就去哈希表中查找$-y$的出现次数，累加起来就是结果。

代码:

```cpp
#include <bits/stdc++.h>
#define mod 5000007

using namespace std;

int n, m, k[7], p[7], P[152][7], ans, table[mod], t[mod];

int hash(int x) {
	int v = x % mod;
	if(v < 0) v += mod;
    while(t[v] && table[v] != x) {
	    v++;
		if(v == mod) v = 0;
	}
	return v;
}

inline void dfs1(int dep, int sum) {
	if(dep > (n >> 1)) {
		int v = hash(sum); t[v]++, table[v] = sum; return;
	}
	for(register int i = 1; i <= m; ++i) dfs1(dep + 1, sum + k[dep] * P[i][p[dep]]);
}

inline void dfs2(int dep, int sum) {
	if(dep > n) {
		ans += t[hash(sum)]; return;
	}
	for(register int i = 1; i <= m; ++i) dfs2(dep + 1, sum - k[dep] * P[i][p[dep]]);
}

int main() {
	scanf("%d%d", &n, &m); ans = 0;
	for(register int i = 1; i <= m; ++i) for(register int j = 0; j <= 4; ++j) P[i][j] = j ? P[i][j - 1] * i : 1;
	for(register int i = 1; i <= n; ++i) scanf("%d%d", &k[i], &p[i]);
	dfs1(1, 0); dfs2((n >> 1) + 1, 0); printf("%d\n", ans);
	return 0;
}
```

2019.11.30 我写的双搜好像是最优解第一23333

---

## 作者：xsap (赞：6)

- 算法：折半搜索（双向DFS）
- 思路：正常搜索是$O(m^n)$，直接爆炸。于是想到了折半搜索。即暴搜$x_{1} , x_{2} ... x_{n / 2}$，存入数组并离散化，并记录每个值有多少种凑法。之后再爆搜$x_{n / 2 + 1} ... x_{n}$，每次在数组中二分查找即可。
- 代码：

```.cpp
# include <iostream>
# include <cstdio>
# include <algorithm>
# include <cmath>

using namespace std ;

int n , m ;
int k[10] ;
long long p[10] ;
int w[8000000] ;
int tmp ;
int cnt = 0 ;
long long ans = 0 ;

int calpow( int x , long long y )
{
	int res = 1 ;
	for ( long long i = 1 ; i <= y ; i++ )
		res *= x ;
	return res ;
}

void dfs1( int now , int sum )
{
	if ( now == tmp )
	{
		w[++ cnt] = sum ;
		return ;
	}
	for ( int i = 1 ; i <= m ; i++ )
	{
		dfs1( now + 1 , sum + k[now] * pow( i , p[now] ) ) ;
	}
	return ;
}

void dfs2( int now , int sum )
{
	if ( now > n )
	{
		int find = upper_bound( w + 1 , w + cnt + 1 , -sum ) - 
		lower_bound( w + 1 , w + cnt + 1 , -sum ) ;
		ans += find ;
		return ;
	}
	for ( int i = 1 ; i <= m ; i++ )
	{
		dfs2( now + 1 , sum + k[now] * pow( i , p[now] ) ) ;
	}
}

int main()
{
	scanf("%d%d" , &n , &m) ;
	for ( int i = 1 ; i <= n ; i++ )
		scanf("%d%lld" , &k[i] , &p[i]) ;
	tmp = n / 2 + 1 ;
	dfs1( 1 , 0 ) ;
	sort( w + 1 , w + cnt + 1 ) ;
	dfs2( tmp , 0 ) ;
	printf("%lld\n" , ans) ;
	return 0 ;
}
```

---

## 作者：jun头吉吉 (赞：6)

## 题意


$$\text{求：}\sum_{i=1}^nk_ix_i^{p_i}=0,x_i\in[1,m](i\in[1,n])\text{的解数}$$

## 题解
~~NOI出绿题，在线懵逼~~

显然，$O(m^n)$的dfs大家都会写，但此时最大时间复杂度达到了$11,390,625,000,000\ $~~还可以吧，天河二号应该能跑出来，你谷测评姬就别想了~~,此时我们就可以用一种神奇的方法：$\texttt{meet\ in\ middle}$

简单来说，我们可以把方程拆成两部分：

$$\sum_{i=1}^{\lfloor \frac n 2\rfloor}k_ix_i^{p_i}+\sum_{i={\lfloor \frac n 2\rfloor}+1}^nk_ix_i^{p_i}=0$$

即：

$$\sum_{i=1}^{\lfloor \frac n 2\rfloor}k_ix_i^{p_i}=-\sum_{i={\lfloor \frac n 2\rfloor}+1}^nk_ix_i^{p_i}$$

那么这样一来，两边的枚举都只需要$O(m^{\frac n 2})$就够了，接下来考虑如何合并。假设我们当前右边的值为$y$，那么左边的值就为$-y$，那么我们如果求出$-y$的方案数，那整个方程的解数就显而易见了。

因此我们这里需要一种结构来存储方案数。$\texttt{hash}$表就是一种很好的选择。我们可以用类似链式前向星的方法，把$\texttt{hash}$值相同的值挂在同一个位置。复杂度:$O(\text{玄学})$~~(依rp从O(1)到O(n)不等)~~

## 代码
有了思路代码就很好写了
```cpp
 #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){
	    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
	}
	template <typename T>inline void read(T& t){
	    t=0;int f=0;char ch=getc();
	    while (!isdigit(ch)){
	        if(ch=='-')f = 1;
	        ch=getc();
	    }
	    while(isdigit(ch)){
   	    	t=t*10+ch-48;
   	    	ch = getc();
   		}
		if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){
	    read(t);read(args...);
	}
}
namespace out{
	char buffer[1<<21];
	int p1=-1;
	const int p2 = (1<<21)-1;
	inline void flush() {
		fwrite(buffer,1,p1+1,stdout),
		p1=-1;
	}
	inline void putc(const char &x) {
		if(p1==p2)flush();
		buffer[++p1]=x;
	}
	template <typename T>void write(T x) {
		static char buf[15];
		static int len=-1;
		if(x>=0){
			do{
    			buf[++len]=x%10+48,x/=10;
    		}while (x);
		}else{
    		putc('-');
			do {
    			buf[++len]=-(x%10)+48,x/=10;
			}while(x);
		}
		while (len>=0)
			putc(buf[len]),--len;
	}
}
using namespace std;
int n,m;
int k[10],p[10]; 
const int mod=10000000+'S'+'J'+'Y'+'A'+'K'+'I'+'O'+'I';
struct node{int num,val,nxt;}e[150*150*150*2];
int head[mod],cnt;
int ans=0;
int Hash(int x){
	return (x%mod+mod)%mod;
}void add(int x){
	int num=Hash(x);
	for(int i=head[num];i;i=e[i].nxt)
	if(e[i].num==x){
		e[i].val++;
		return;
	}e[++cnt]=(node){x,1,head[num]};
	head[num]=cnt;
}int qry(int x){
	int num=Hash(x);
	for(int i=head[num];i;i=e[i].nxt)
	if(e[i].num==x)return e[i].val;
	return 0;
}void dfs1(int now,int val){
	if(now>(n>>1)){add(val);return;}
	for(int i=1;i<=m;i++)dfs1(now+1,val+k[now]*pow(i,p[now]));
}void dfs2(int now,int val){
	if(now>n){ans+=qry(-val);return;}
	for(int i=1;i<=m;i++)dfs2(now+1,val+k[now]*pow(i,p[now]));
}
signed main(){
	in::read(n,m);
	for(int i=1;i<=n;i++)
		in::read(k[i],p[i]);
	dfs1(1,0);dfs2((n>>1)+1,0);
	out::write(ans);
	out::flush();
	return 0;
}
```

---

## 作者：Celtic (赞：3)

这道题是折半搜索。

推荐一下[大佬的博客](https://www.cnblogs.com/Phoenix41/p/12537234.html)，我就是看这个看明白的。

普通的搜索复杂度是$O(m^n)$，数据在$m=150,n=6$时会 TLE。

所以我们考虑折半搜索，也就是先搜$x_1,x_2,\cdots,x_{\frac{n}{2}}$，把搜到的函数值存入哈希表中。

然后再搜$x_{\frac{n}2{}},x_{\frac{n}{2}+1},\cdots,x_n$，答案加上表中当前函数值的相反数的解的数量。

~~由于哈希表不好写~~，所以我用了$\operatorname{map}$来简化代码。然而普通的$\operatorname{map}$虽然在洛谷上能过，但在数据较大的（比如校内 OJ ）上会 MLE 所以我们用迭代器来减少访问次数，减少内存。

具体细节见代码。

```cpp
#include<bits/stdc++.h>
#include<tr1/unordered_map>
#define N 20
#define re register
#define MAX 2001
#define eps 1e-10
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
	ret=0;re bool pd=false;re char c=getchar();
	while(!isdigit(c)){(c=='-')&&(pd=true);c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();}	
	ret=pd?-ret:ret;
	return;
}
ll n,m,k[N],p[N],ans;
tr1::unordered_map<ll,ll>vis;
tr1::unordered_map<ll,ll>::iterator ip; 
inline ll qpow(re ll a,re ll b)
{
	re ll ret=1;
	while(b)
	{
		if(b&1)ret*=a;
		a*=a;
		b>>=1;
	}
	return ret;
}
inline void dfs(re ll deep,re ll now)
{
	for(re int i=1;i<=m;i++)
	{
		if(deep==(n>>1))
		{
			vis[now+k[deep]*qpow(i,p[deep])]++;
			continue;
		}
		else if(deep==n)
		{
			ip=vis.find(-now-k[deep]*qpow(i,p[deep]));
			if(ip!=vis.end())
				ans+=ip->second;
			continue;
		}
		dfs(deep+1,now+k[deep]*qpow(i,p[deep]));
	}
	return;
}
int main()
{
	read(n);
	read(m);
	for(re int i=1;i<=n;i++)
		read(k[i]),read(p[i]);
	dfs(1,0);
	dfs((n>>1)+1,0);
	printf("%d\n",ans);
	exit(0);
}
```


---

## 作者：Melo_DDD (赞：2)

讲一种暴力统计答案的方法。

如果你不想用 ``upper_bound``、``lower_bound``，或者认为哈希表和迭代器指针太麻烦，那么请看下去。

首先我们发现 $x$ 的取值最多有 $150$ 种，而 $150^3$ 是可过的，所以用折半搜索，这不是重点，这部分内容请看其他题解，主要讲一讲如何暴力的统计答案再优美的切掉这道题。

首先对于这种统计答案，如果想要单纯的使用 STL 的话，无非就两种选择：set 或者 map。分别考虑这两种。

首先我们应该注意到折半搜索找到的和不满足唯一性，所以应该使用 multiset。

那么我们将这两个玩意分别考虑：

- 如果想要使用 multiset，那么我们的思路应该是将前后两半分别存进两个 multiset 里面，最后对第一个中的每个值 $i$，去查找第二个中的 $-i$ 的个数，需要用到 ``count`` 函数，但是它的复杂度是 $\mathcal{O}(k+\log n)$ 的，非常危险，时间比较大。

- 如果是 map，可以做到（理论上的）$\mathcal{O}(1)$ 查询，但是空间比较大，而且遍历很不方便（只能用麻烦的迭代器），同样会愉快的 T 掉几个点。

那么我们现在可以有这样一种想法：极限的卡过时间的同时极限的卡过空间，怎么办？

注意到用 multiset 的瓶颈在于 ``count`` 函数，那么我们不妨将第二个 multiset 变成 map 从而做到常数级别的查询。

同时，我们也可以看做将第 $1$ 个 map 变成了 multiset，那么遍历就没有那么麻烦，同时降低一些空间。

要是想卡一卡可以用 unordered_map。

实际上最慢的点只有 $3.33$ 秒。

代码：

```cpp
inline void dfs (int num ,int end ,int sum ,bool flag) {
	if (num >= end + 1) {
		if (! flag) s1.insert (sum) ; // s1 是 multiset
		else s2[sum] ++ ; // s2 是 map
		return ;
	}
	f (i ,1 ,m ,1) {
		dfs (num + 1 ,end ,sum + k[num] * qpow (i ,p[num]) ,flag) ;
	}
}
for (auto i : s1) { // auto 遍历非常方便
	ans += s2[-i] ; // O (1) 访问
 }
```

---

## 作者：一只书虫仔 (赞：2)

#### Description

> 求下面这个方程：
> $$\sum_{i=1}^n k_i x_i^{p_i}=0$$
> 整数解且 $x_i \in [1,m]$ 的个数。

#### Solution

下面先令 $n=6$。

首先考虑暴力，暴力枚举 $x_i$，$\mathcal O(m^6)$。

然后一步步剪枝，将方程如下变形：

$$\sum\limits _{i=1}^{5} k_ix_i^{p_i}=-k_6x_6^{p_6}$$

然后用 $\mathcal O(m^5)$ 的时间复杂度算出前 $n-1$ 项，第 $n$ 项可以直接推导：

$$x_6=\sqrt[p_6]{\frac{-\sum\limits _{i=1}^5 k_ix_i^{p_i}}{k_6}}$$

那我们继续变形：

$$\sum\limits_{i=1}^3 k_ix_i^{p_i}=-\sum\limits_{i=4}^6 k_ix_i^{p_i}$$

对于左边的和右边的分别 dfs 求解，这样时间复杂度是 $\mathcal O(m^3)$ 的，毕竟左右互不干扰。

然后假设 dfs 后左边产生的和分别为 $a_1,a_2,\cdots ,a_k$，右边产生的和分别为 $b_1,b_2,\cdots,b_k$，那么接下来只需要考虑怎么从 $a_i$ 中找到与 $-b_i$ 相同的个数即可。

有两种做法：

- 开桶，用 `map`。
- 排个序，然后二分查找。

那对于任何 $n$，只需要将变形改为：

$$\sum\limits_{i=1}^{\frac n 2} k_ix_i^{p_i}=-\sum\limits_{i=\frac n 2+1}^n k_ix_i^{p_i}$$

即可。

#### Code

```cpp
dfs1(1, 0);
sort(val1 + 1, val1 + cnt1 + 1);
dfs2(n / 2 + 1, 0);
int cnt = 0;
for (int i = 1; i <= cnt2; i++) 
	cnt += (upper_bound(val1 + 1, val1 + cnt1 + 1, -val2[i]) - lower_bound(val1 + 1, val1 + cnt1 + 1, -val2[i]));
printf("%d", cnt);
```

---

## 作者：蓝莲花__ (赞：2)

# 思路：双向搜索

想想看，如果是暴力DFS搜索，一定会TLE

#### 但是我们可以将搜索分为两半，这样的话每一半的搜索量就是150^3

这样，我们再把两次搜索中所有的可能的值存下来，得到两个数组f,g

将f从小到大排序，g从大到小排序，这样的话我们就能在O(n)的时间内得到答案了

优（du）秀（liu）的代码

```cpp
#include<bits/stdc++.h>
#define fo(i,a,b) for (int i=(a);i<=(b);++i)
using namespace std;
int read(){
	int x=0,ff=1;char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')ff=-1;ch=getchar();
	}while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);ch=getchar();
	}return ff==1?x:-x;
}
const int mx=3500000;
int a[mx],b[mx],n,m,k[10],p[10],c1,c2,f[mx],g[mx],ff,gg,sf[mx],sg[mx];
long long ans;
int qm(int x,int kk){
	int s=1,t=x;while(kk){
		if(kk&1)s=s*t;kk>>=1;t=t*t;
	}return s;
}
int F(int x,int gr){
	return k[gr]*qm(x,p[gr]);
}
void dfs1(int x,int sum){
	if(x==n/2+1){
		a[++c1]=sum;return;
	}fo(i,1,m)dfs1(x+1,sum+F(i,x));
}
void dfs2(int x,int sum){
	if(x==n+1){
		b[++c2]=sum;return;
	}fo(i,1,m)dfs2(x+1,sum+F(i,x));
}
bool cmp1(int x,int y){
	return x<y;
}
bool cmp2(int x,int y){
	return x>y;
}
void work(){
	dfs1(1,0);dfs2(n/2+1,0);
	sort(a+1,a+c1+1,cmp1);sort(b+1,b+c2+1,cmp2);
	fo(i,1,c1){
		if(a[i]!=f[ff]||ff==0)f[++ff]=a[i],sf[ff]=1;
		else if(a[i]==f[ff])sf[ff]++;
	}
	fo(i,1,c2){
		if(b[i]!=g[gg]||gg==0)g[++gg]=b[i],sg[gg]=1;
		else if(b[i]==g[gg])sg[gg]++;
	}
	int i=1,j=1;
	while(i<=ff&&j<=gg){
		if(f[i]+g[j]==0)ans+=sf[i]*sg[j],i++,j++;
		else if(f[i]+g[j]>0)j++;
		else if(f[i]+g[j]<0)i++;
	}cout<<ans;
}
int main(){
	cin>>n>>m;fo(i,1,n)cin>>k[i]>>p[i];
	work();
	return 0;
}
```


---

## 作者：迟暮天复明 (赞：1)

[题面](https://www.luogu.com.cn/problem/P5691)

[博客查看(没说效果更佳)](https://www.cnblogs.com/1358id/p/15099525.html)


本人用的是暴力分类讨论 + unordered_map 存储，与所有的题解都不同。

因为 $n \leq 6$ ，非常的小，并且我不想写 DFS，所以直接暴力分类讨论 $n=1,n=2,\dots,n=6$ 的情况。

当 $n \leq 3$ 时，可以用循环嵌套来解决，这里就不再赘述了。

当 $n > 3$ 时，暴力循环去做的时间复杂度达到了 $O(m^n)$ ，无法通过本题，所以考虑优化（以 $n=6$ 为例，其余类推）：先枚举 $x_1,x_2,x_3$ ，存储 $k_1\times x_1^{p_1}+k_2\times x_2^{p_2}+k_3\times x_3^{p_3}$ ，接下来枚举 $x_4,x_5,x_6$ ，则答案就要增加 $k_1\times x_1^{p_1}+k_2\times x_2^{p_2}+k_3\times x_3^{p_3} = -(k_4\times x_4^{p_4}+k_5\times x_5^{p_5}+k_6\times x_6^{p_6})$ 的个数，用 map 存一下即可。

时间复杂度 $O(m^{\frac{n}{2}})$，但是这个做法**非常**慢，用 unordered_map 会好一点。

upd：链接挂了，重新修了一下。

---

## 作者：abruce (赞：1)

这道题首先发现 $n$ 比较小，$m$ 也不是很大，但是直接 $m^n$ 爆搜是会出问题的。这时候，我们可以想到一种神奇的做法，meet in middle。这个算法主要步骤就是先算前面半部分，再算后面半部分，最后把两边合法的方案拼接在一起，就成了最终的答案，时间复杂度是 $O(m^{\frac{n}{2}})$。两边的搜索爆搜就可以了，但中间的合并值得思考，我们可以把前面搜索出来的答案用一个哈希表存起来，在后面搜索完成时直接去哈希表里找前面的答案。  
```cpp
#include<bits/stdc++.h>
#define mod 4000037
#define int long long
using namespace std;
//map<int,int> maps;
int n,m,p[155],k[155],a,ans,h[4000050][2];
int lock(int x) {
	int p=x;
	if(p<0)p=-p;
	p%=mod;
	while(h[p%mod][0]&&h[p%mod][0]!=x) {
		p++;
	}
	return p%mod;
}
void hinsert(int x) {
	int p=lock(x);
	h[p][0]=x;
	h[p][1]++;//注意可能有多个相同的，所以不是设为1，而是自增
}
int hfind(int x) {
	int p=lock(x);
	if(h[p][0]==x) {
		return h[p][1];
	}
	return 0;
}//用了一个手写的哈希表，注意模数大一点
void dfs(int stp,int d) {
	if(stp==d+1) {
		hinsert(a);//把答案塞进去
		return;
	}
	for(register int i=1; i<=m; i++) {
		a+=pow(i,p[stp])*k[stp];
		dfs(stp+1,d);
		a-=pow(i,p[stp])*k[stp];
	}
}
void dfs2(int stp) {
	if(stp==n+1) {
		ans+=hfind(-a);//找它的相反数，这样才能凑成0
		return;
	}
	for(register int i=1; i<=m; i++) {
		a+=pow(i,p[stp])*k[stp];
		dfs2(stp+1);
		a-=pow(i,p[stp])*k[stp];
	}
}
signed main() {
	scanf("%lld%lld",&n,&m);
	for(register int i=1; i<=n; i++) {
		scanf("%lld%lld",&k[i],&p[i]);
	}
	dfs(1,n/2);
	dfs2(n/2+1);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Viktley (赞：1)

**分析：**
题目要求出给定的方程解的个数，这个方程在最坏的情况下可以有6个未知数，而且次数由输入决定。这样就不能利用数学方法直接求出解的个数，而且注意到解的范围最多150个数，因此恐怕只能使用枚举法了。

我一开始是先想到了用到dfs去穷举6层，虽然想法很美好，但是时间不允许啊O（m^n）.换种思路， 题目要求n项值加起来=0，那我们可不可以只算n/2项呢？根据初中移项知识，就可以把题目变一个形式,前n/2项=-1*(后n/2项），那时间复杂度就降成O（m^n>>1）,那这样就能过了。最后再用hash将前半段的值记录一下，然后在后半段搜索的时候看看与表中有多少个相同的就行了。

还有注意一下：
设前半段有3项，值可能为 1 2 3或3 2 1或2 1 3。虽然他们的总和是一样的，但是也算方程的不同解
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<queue>
#define fre(x) freopen(#x".in","r",stdin),freopen(#x".out","w",stdout);
using namespace std;
const int MAX=2147483647;
const int N=1e6;
const int Mod=10000007;
long long n,m,k[10],p[10],ans,mid; 
long long hash[Mod+666][2]; 
long long qy(long long x) {return x%Mod;}
long long dw(long long x)
{
	long long a=qy(abs(x)),i=0;
	while(i<Mod&&hash[qy(a+i)][0]&&hash[qy(a+i)][0]!=x)
		i++;
	return qy(a+i);
}
void tp()
//特判，如果只有一个未知数，且系数为0，则方程正好有m组解(x=1..m)，否则无解
{
	if(n==1) 
	{
		if(!k[1])printf("%lld",m);
		else printf("0");
		exit(0);
	}
}
void dfs1(long long dep,long long sum)//前半段
{
	if(dep==mid)
	{
		//把所有可能出现的答案放进hash
		for(long long i=1;i<=m;i++)
		{
			long long temp=sum+k[dep]*pow(i,p[dep]);
			hash[dw(temp)][0]=temp,hash[dw(temp)][1]++;
		}
		return ;
	}
	for(long long i=1;i<=m;i++)
		dfs1(dep+1,sum+k[dep]*pow(i,p[dep])); 
}
void dfs2(long long dep,long long sum)//后半段
{
	if(dep==n)
	{
		for(long long i=1;i<=m;i++)
		{
			long long temp=(-1)*(sum+k[dep]*pow(i,p[dep]));//记得要乘-1，移项变号
			if(hash[dw(temp)][0]==temp) ans+=hash[dw(temp)][1];//如果正好抵消，则加上其对应的数量
		}
		return ;
	}
	for(long long i=1;i<=m;i++)
		dfs2(dep+1,sum+k[dep]*pow(i,p[dep]));
}
int main()
{
	//fre();
	scanf("%lld%lld",&n,&m);
	mid=n>>1;
	for(int i=1;i<=n;i++) scanf("%lld%lld",&k[i],&p[i]);
	tp();
	dfs1(1,0),dfs2(mid+1,0);
	printf("%lld",ans);
	return 0;
}

```


---


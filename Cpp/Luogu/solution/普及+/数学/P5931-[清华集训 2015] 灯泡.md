# [清华集训 2015] 灯泡

## 题目背景

$2022$ 年，评测数据发生了翻天覆地的变化，请 $2022$ 年前通过此题的人重新交一遍。

## 题目描述

相比 Wildleopard 的家，他的弟弟 Mildleopard 比较穷。他的房子是狭窄的，而且在他的房间里仅有一个灯泡。每天晚上，他徘徊在自己狭小的房子里，思考如何赚更多的钱。有一天，他发现他的影子的长度随着他在灯泡和墙壁之间走动时会发生变化。一个突然的想法出现在他的脑海里，他想知道在房间里他的影子的最大长度。

![](https://cdn.luogu.com.cn/upload/image_hosting/i78578mk.png)

## 说明/提示

$1\le T \le 100,0.01 \le H,h,D \le 1000,H-h\ge 0.01$，保证 $H,h,D$ 最多由 $6$ 位小数构成。

## 样例 #1

### 输入

```
3
2 1 0.5
2 0.5 3
4 3 4```

### 输出

```
1.000
0.750
4.000```

# 题解

## 作者：yangrunze (赞：71)

~~这计算量……可真是……酸爽……~~

（正因为如此，接下来的内容中，我会尽量完整地展现计算过程，如果你是懒癌晚期不想亲自算的话，计算的部分可以直接跳过）


------------

咳咳，这个题，我的思路是这样的：**设小人走过离灯泡的距离为 $x$** ，求出**影长 $y$ 与 $x$ 的函数解析式**，这样不就转化成**求函数最值**的问题了嘛~

那怎么求呢？我们利用**几何知识**——**相似三角形**。

当然，这个题有一个小地方需要注意——对于不同的位置，我们要**分类讨论**（经历过数学中考的我已经轻车熟路~）

（以下图片都由万能的 [desmos](https://www.desmos.com) 赞助播出~动态图[戳这体验](https://www.desmos.com/geometry/j6snipbwfc)）

（P.S. ：以下图片中，$AB$ 是灯泡，$MN$ 是小人）

### 1. 当影子全部落在地面上时：

![](https://cdn.luogu.com.cn/upload/image_hosting/k9nb5xjp.png)

根据初三的几何知识，我们可以轻松得到 $\triangle OAB \sim \triangle OMN$

进而可以得到 $\dfrac{AB}{MN}=\dfrac{OB}{ON}$

再根据我们前面函数的定义，可以得到 $\dfrac{H}{h}=\dfrac{x+y}{y}$

把比例式交叉相乘化成等积式，$h(x+y)=Hy$

去括号，移项，合并同类项，得 $hx+hy=Hy,(H-h)y=hx$

即 $y=\dfrac{h}{H-h}x$

当然，别忘了考虑**自变量的取值范围**：要保证影子完全落在地面上，我们还有一个要求就是 $x+y\le D$，

即 $\dfrac{h}{H-h}x+x\le D$

通分合并同类项，可以解得$\dfrac{H}{H-h}x\le D$，

$x\le D\dfrac{H-h}{H}$

所以第一种情况的函数解析式为 ：$y=\dfrac{h}{H-h} x\quad(0\le x\le D\dfrac{H-h}{H})$

### 2. 当影子有一部分落在墙上时：
![](https://cdn.luogu.com.cn/upload/image_hosting/3c5r1bwk.png)

这时，影长被分为了两部分：我们设 $QN=y_1,PQ=y_2$


肉眼可见 $y_1=D-x$，那我们只要求出 $y_2$ 就可以啦！

那 $y_2$ 怎么求呢？我们注意到，上一种情况的那组相似三角形依然存在，延长 $BN,AM$ 交于点 $O$，还是 $\triangle OAB \sim \triangle OMN$

这样的话，根据上一种情况可得 $ON=\dfrac{h}{H-h}x$

为了方便后续计算，设 $\dfrac{h}{H-h}=s$，$ON=sx$。

我们发现，还有一组相似三角形：$\triangle OPQ \sim \triangle OMN$

即： $\dfrac{MN}{PQ}=\dfrac{ON}{OQ}$

把我们刚才设好的东西都代进去：$\dfrac{h}{y_2}=\dfrac{sx}{sx-y_1}$

将 $y_1=D-x$ 代入：$\dfrac{h}{y_2}=\dfrac{sx}{sx-D+x},\dfrac{h}{y_2}=\dfrac{sx}{(s+1)x-D}$

即：$sx\times y_2=h[(s+1)x-D]$

将$sx$除过去，可以得到$y2=\dfrac{h[(s+1)x-D]}{sx}$

当然，我们还可以继续化简：我们注意到分子分母都有相同的 $x$，可以拆出来约掉：

$\begin{aligned}y2=h\times[\dfrac{(s+1)x- D}{sx}]\\=h\times[\dfrac{(s+1)x}{sx}-\dfrac{D}{sx}]\\=h\times(\dfrac{s+1}{s}-\dfrac{D}{sx})\end{aligned}$


将 $s=\dfrac{h}{H-h}$ 代回到式子里面：

$\begin{aligned}y2=h\times(\dfrac{s+1}{s}-\dfrac{D}{sx})\\=h\times(\dfrac{\dfrac{h}{H-h}+1}{\dfrac{h}{H-h}}-\dfrac{D}{\dfrac{h}{H-h}x})\\=h\times(\dfrac{\dfrac{H}{H-h}}{\dfrac{h}{H-h}}-\dfrac{D}{\dfrac{h}{H-h}x})\\=h\times(\dfrac{H}{h}-\dfrac{D(H-h)}{hx})\end{aligned}$

将 $h$ 乘进去：$y_2=H-\dfrac{D(H-h)}{x}$

然后根据 $y=y_1+y_2$，再加上自变量取值范围，这一段的函数也就出现了：

$y_=D-x+H-\dfrac{D(H-h)}{x}(\dfrac{H-h}{H}\le x\le D)$

这样的话，这个函数就很清晰得展现在我们眼前了：

$y=\begin{cases}\dfrac{h}{H-h} x\quad(0\le x\le D\dfrac{H-h}{H})\\D-x+H-\dfrac{D(H-h)}{x}(D\dfrac{H-h}{H}\le x\le D)\end{cases}$

（[动态图戳这](https://www.desmos.com/calculator/2newpdj2h0)）


------------

接下来，我们来考虑这个函数的最大值：这个函数时由两部分组成的，我们只需要把两部分的最大值都求出来，再取个 $\max$ 就行了。

第一个函数非常简单：它是个斜率大于 $0$ 的正比例函数，最大值就是当 $x=D\dfrac{H-h}{H}$的时候，算出 $y_{\max}=\dfrac{h}{H-h}\times D\dfrac{H-h}{H}=\dfrac{Dh}{H}$

那至于第 $2$ 个函数呢，我们先把它变一下：

$y=D+H-[\color{red}{x+\dfrac{D(H-h)}{x}}\color{black}]$

有没有发现红色的部分有点眼熟呢？？？

熟读高中数学必修一的小伙伴们肯定都看出来了：这是**对钩函数**！

（科普：对钩函数就是形如 $y=ax+\frac{b}{x}$的函数，是由一次函数和反比例函数相加而成，由于图像像两个[![](https://cdn.luogu.com.cn/upload/image_hosting/njchq0f8.png)](https://www.luogu.com.cn/discuss/show/142324)，因此而得名）

我们都知道，对钩函数是跟**基本不等式**密不可分的。

基本不等式是啥？ 当 $a>0,b>0$时，$a+b\ge 2\sqrt{ab}$

这有什么关系？我们把这部分对勾函数带到基本不等式里看看：

$x+\dfrac{D(H-h)}{x}\ge 2\sqrt{x\times\dfrac{D(H-h)}{x}}$

即 $x+\dfrac{D(H-h)}{x}\ge 2\sqrt{D(H-h)}$

这一部分的最小值出来啦！

也就是说，这个函数的最大值就是$D+H-2\sqrt{D(H-h)}$

$\cdots\cdots$

吗？

肯定没那么简单！在本题中，**自变量是有取值范围的**，也就是说：这是一个**区间最值**问题，我们要判断当 $y$ 是这个“最大值”的时候， $x$ 到底能不能取到。

那怎么判断能否取到呢？别忘了，在基本不等式中有一句话是特别重要的：

当且仅当 $a=b$ 时，等号成立。

也就是说，当 $y$ 取到最大值 $D+H-2\sqrt{D(H-h)}$ 时，$x=\dfrac{D(H-h)}{x}$

去分母，得到 $x^2=D(H-h)$

解得 $x_1=\sqrt{D(H-h)},x_2=-\sqrt{D(H-h)}$（舍去）

也就是说，当且仅当 $x=\sqrt{D(H-h)}$ 时，$y$ 取到最大值。

不仅如此，我们还可以发现：当 $x<\sqrt{D(H-h)}$ 时，$y$ 随 $x$ 的增大而增大；当 $x>\sqrt{D(H-h)}$ 时，$y$ 随 $x$ 的增大而减小。（对钩函数的性质，有兴趣的小伙伴们可以证明一下）

就这样，我们就可以画出函数的大致图像。最后一步，就是结合图像分析在各个区间内的最值啦！

![](https://cdn.luogu.com.cn/upload/image_hosting/w9ddfdxt.png)

首先，当 $D\dfrac{H-h}{H}\le \sqrt{D(H-h)}\le D$ 时，没说的，最大值就是 $D+H-2\sqrt{D(H-h)}$S

![](https://cdn.luogu.com.cn/upload/image_hosting/0ks41jmo.png)

其次，当 $\sqrt{D(H-h)}\ge D$ ，也就是取值范围在最大值的**左边**时，这时函数**单调递增**，当$x=D$ 时，$y=D-D+H-(H-h)=h$

![](https://cdn.luogu.com.cn/upload/image_hosting/zduml1y2.png)

最后，当 $\sqrt{D(H-h)}\le D\dfrac{H-h}{H}$ ，也就是取值范围在最大值的**右边**时，这时函数**单调递减**，当$x=\dfrac{H-h}{H}$ 时，$y=D-(H-h)\times\dfrac{D}{H}$

All in all, 第二部分的函数的最大值是这样的：

$y_{\max}=\begin{cases}D-(H-h)\times\dfrac{D}{H}\quad (\sqrt{D(H-h)}\le D\dfrac{H-h}{H})\\D+H-2\sqrt{D(H-h)}\quad(D\dfrac{H-h}{H}\le \sqrt{D(H-h)}\le D)\\h\quad(\sqrt{D(H-h)}\ge D)\end{cases}$

这样的话，我们就成功求出了函数的最大值！

（代码很好写，我就不贴了）



------------


方法讲完了，不过这时肯定还有小朋友有疑问：

——“yrz，我不会基本不等式和对钩函数，那怎么办呀？”

别急，我们还有一种方法——**三分法**。

虽然不会对钩函数，但经过适量分析，也可以发现第二部分的函数先递增，后递减，是一个**单峰函数**。

三分和我们熟悉的二分类似，都是每次把答案锁定在一个区间，大事化小，小事化了。我们都知道，二分是很适合**单调函数**的（就是**要么一直上升，要么一直下降，不拐弯**）；而三分呢，它适用于**单峰函数**或**单谷函数**（就是“**只拐一次弯**”，**会出现一个最小值/最大值**）


不仅如此，三分的代码和二分也很像，就是把当前的区间平均分成 **3** 份，然后根据两个分界点（相当于二分的 mid）的函数值确定答案在这三个区间的某一个里面。具体的操作我就不细说啦，想学的小伙伴们可以去看其它题解或者找[模板题](https://www.luogu.com.cn/problem/P3382)玩玩~



------------
$\huge \color{springgreen}The\;end$

$\tiny\text{(P.S:中考终于考完了)}$


---

## 作者：do_while_false (赞：17)

首先这题是道典型的三分题，[三分模板](https://www.luogu.com.cn/problem/P3382)。

我们分两种情况讨论:
- 影子没有碰到墙壁
- 影子碰到墙壁

对于情况一，我们直接用数学方法求出影子在地上的长度即可，具体请看代码。

对于情况二，影子在地上的长度和在墙上的长度明显是两个单调函数。因此合并后即为一个单峰函数，此时我们用三分法求单峰函数的极值即可。

```cpp
#include<bits/stdc++.h>
#define MAXN 100000
using namespace std;
int n;
double H,h,D;
double ask(double x) {//返回大的那种情况 
    if(x<=h*D/H) return x+(H-(H-h)*D/(D-x));
    else return x-D+((D-x)*H/(H-h));
}
void three_cut() {//三分，具体原理不懂可以去看模板题题解 
	double l=0,r=MAXN;
	while(r-l>=0.0000001) {
		double lmid=l+(r-l)/3;
		double rmid=r-(r-l)/3;
		if(ask(lmid)>ask(rmid)) r=rmid;
		else l=lmid;
	}
	printf("%.3lf\n",ask(l));
}

int main(void) {
	scanf("%d",&n);
	for(int i=0;i<n;i++) {
		scanf("%lf%lf%lf",&H,&h,&D);
		three_cut();
	}
	return 0; 
} 
```
管理员大大求过,qvq。

---

## 作者：iuyi (赞：11)

这是道简单推导题

首先，如果影子没有到达墙壁的话，向右移动会更优

所以只考虑影子有一部分在墙壁上的情况

设影子在墙壁上的长度为 $l$ ，$l$ 的合法取值为 [$0,h$]

由相似可以推导出 $L=l+\frac{(h-l)\cdot D}{H-l}$

将上面的柿子对 $l$ 求导可以得到 $1+\frac{(-H+h)\cdot D}{(H-l)^{2}}$

我们要求原式的极值，所以令导数等于 $0$ ，得到

$(H-l)^{2}=(H-h)\cdot D$

显然这个方程有两个解，我们只要 $<H$ 的那一个，即

$l=H-\sqrt{(H-h)\cdot D}$

如果 $l$ 不在区间 [$0,h$] 中，就取合法区间的端点

将 $l$ 代入 $L=l+\frac{(h-l)\cdot D}{H-l}$ 就可以得到答案了

```cpp
#include <bits/stdc++.h>
using namespace std;
signed main() {
	int t;
	cin >> t;
	while (t--) {
		double H,h,D;
		cin >> H >> h >> D;
		double l = H-sqrt((H-h)*D);
		if (l < 0) {
			l = 0;
		}
		if (l > h) {
			l = h;
		}
		printf("%.3lf\n",l+(h-l)*D/(H-l));
//		这里一定要先乘再除
//		如果写成 l+(h-l)/(H-l)*D 会 WA 一个点 
	}
	return 0;
}
```


---

## 作者：xh39 (赞：6)

本文使用大量latex,如果炸了,请看[这里](https://www.luogu.com.cn/training/8647)。

## algorithm

1.一次函数求解析式(建议学习)

2.三分。(与算法3任选一个学习,建议学习算法2)

3.均值不等式,即求分式函数$y=\frac ax+b\times x$的最值。

## solution
会讲得比较慢,所以有些大佬会的部分可以跳过。

一定影子要投在墙上,这样才能使影子更长。但是我太菜了不知道证明。

很显然要设人到灯的距离为x。然后列出关于x的代数式然后求min。

我们发现射出的光线是直线。然后我们现在想求出L。

首先地面上的影子长度很好求,就是(D-x)。然后我们要求出墙壁上的长度,就必须知道高。先求一次函数解析式。

先建立平面直角坐标系,我认为 以地面作为x轴,y轴过灯做x轴的垂线 这个方法最方便,因为任意一关键点(即有用的点)都可以很快的表示成坐标了。

现在找2个点就可以求出解析式。首先,灯的位置很容易求出是(0,H)。人的位置也很容易求出是(x,h)。

然后开始求解析式。设这个解析式为y=ax+b;

列出方程$\begin{cases}H=0\times a+b ①\\h=x×a+b②\\\end{cases}$ 

至于解方程我不在这里解,结果为:$a=\frac{h-H}{x},b=H$

现在我们知道这个光设在墙壁上的坐标为(D,?),要求?,所以把x=D代入。

然后就可以知道坐标为$(D,H-\frac{(H-h)\times D}{x})$

现在我们就列出了代数式:$D-x+H-\frac{(H-h)\times D}{x}$。

然后求这个代数式的最值有2种方法:

方法1:数学,求分式函数的最值。这里我不做演示,具体看[我发的讨论](https://www.luogu.com.cn/discuss/show/217337?page=3),第4条回复。

方法2:三分。

肯定在x向右移时,墙上的影子增长速度特别快,>地面影子减少速度。可一直向右移会发现墙上影子增长越来越慢,到某点=地面影子,然后再向右移就<地面影子减少速度了。我们就是要求这个点。会发现这是单峰的,所以可以三分。

## ac.code
```cpp
#include<iostream>
#include<cmath>
using namespace std;
#define eps 0.000000000001 //精度误差,建议在10~13位小数。视情况而定。
double H,h,D;
double f(double x){ //计算长度。
	return D-x+H-(H-h)*D/x;
}
int Main(){
	cin>>H>>h>>D;
	double l=(H-h)/H*D,r=D,m1,m2; //必须投在墙上,并且最多不能超过房子。
	while(l+eps<=r){ //三分。
		m1=l+(r-l)/3.0;
		m2=l+(r-l)/1.5; //相当于m2=l+(r-l)/3.0*2.0;
		if(f(m1)>=f(m2)){
			r=m2;
		}else{
			l=m1;
		}
	}
	printf("%.3f\n",f(l)); //注意是求长度!!!
	return 0;
}
int main(){ //多组数据我喜欢把main函数写简短。
	int t,i;
	cin>>t;
	for(i=0;i<t;i++){
		Main();
	}
	return 0;
}
```
欢迎提出问题吊打我!

---

## 作者：pomelo_nene (赞：5)

我们假设对应的角度为 $\theta$，如果墙上有影子，那么有函数关系 $D+H-((H-h)/\tan \theta+D\tan \theta)$。我们根据数形结合讨论得到极值点，有以下几个关系：

- 如果 $\sqrt{(H-h)/D} \geq H/D$，答案为 $h \times D/H$；

- 如果 $\sqrt{(H-h)/D} \leq (H-h)/D$，答案为 $h$；

- 否则答案为 $D+H-2 \times \sqrt{(H-h) \times D}$

综上。

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int main(){
	int T;
	scanf("%d",&T);
	while(T-->0)
	{
		double hh,h,d;
		scanf("%lf %lf %lf",&hh,&h,&d);
		double ans=d-h*d/hh;
		if(ans<=sqrt((hh-h)*d) && d>=sqrt((hh-h)*d))	ans=d+hh-2*sqrt((hh-h)*d);
		else if(sqrt((hh-h)*d)<ans)	ans=h*d/hh;
		else 	ans=h;
		printf("%.3lf\n",ans);
	}
	return 0;
}
```

---

## 作者：Reanap (赞：4)

经过观察我们可以发现，如果离得过远，影子的长度不会很长，同时离得过近，他同时也不会很长，所以我们考虑三分他里墙的距离，同时计算影子的长度。另外关于边界就是一个很显然的结论:映在墙上的一定比不映在墙上的影子长。

同时计算影子长度时，我们可以用在光线上的两个相似三角形计算。

第一个的相似比为（tan）：$\dfrac{H-h}{D-mid}$，所以高度与影子长度为：

$h - \dfrac{H-h}{D-mid}*mid+mid$

另外，本题数据极其恶心，精度要多开很多很多位，同时乘法计算也要挪到除法前面去卡精度。

下面给出代码：

```cpp
#include <cstdio>
typedef long long LL;
double H , h , D;
double js(double mid) {
	double re = h - (H - h) * mid / (D - mid) + mid;//注意卡精度
	return re;　　　　　
}
int main() {
	LL t;
	scanf("%lld" , &t);
	while(t --) {
		scanf("%lf %lf %lf" , &H , &h , &D);
		double l = 0 , r = h / H * D;//刚好不映到墙上
		while(r - l > 0.0000001) {//三分
			double lmid = l + (r - l) / 3 , rmid = r - (r - l) / 3;
			if(js(lmid) >= js(rmid)) {
				r = rmid;
			} else {
				l = lmid;
			}
		}
		printf("%.3lf\n" , js(l));
	}
	return 0;
}

```

---

## 作者：离散小波变换° (赞：3)

## 推导

假设人后面没有墙，设此时投射到地面上的影子长度为 $x$。容易发现 $x$ 的取值范围是 $\left[0,D\times \dfrac{h}{H-h}\right]$。因为当 $x$ 比较小的时候影子不会被投到墙上，此时一直远离灯肯定是更优的，所以可以一直远离到影子恰好投影到墙上的时刻。于是我们希望研究的 $x$ 的取值范围实际是：

$$\left[D\times \dfrac{h}{H},D\times \dfrac{h}{H-h}\right]$$

现在加入了这堵墙。那么投射到地面上的影子长度就没有 $x$ 了。设少去的那一部分影子的长度为 $y$，容易发现：

$$y=x\times\dfrac{H}{h}-D$$

那么根据相似可以得到投射到墙上的那部分影子长度就是 $y\times \dfrac{h}{x}$。得到影子的总长度：

$$L=(x-y)+y\times \dfrac{h}{x}=-\left(\dfrac{H-h}{h}\times x+Dh\times \dfrac{1}{x}\right)+(H+d)$$

大概长得像个对勾函数，也就是单峰的。如果峰不在定义域里就直接取两端点的最大值就行，否则最大值在 $x=h\times \sqrt{\dfrac{D}{H-h}}$ 时取得，值为 $H + D - 2 \times \sqrt{D \times (H - h)}$。

由于 $x$ 在两个端点处的取值有自己的几何意义（一个是影子恰好落在墙上，一个是整个人贴在墙上），所以容易直接根据几何意义算出来而不用代公式。可以发现，影子刚好落在墙上时影子长度就是 $D\times \dfrac{h}{H}$，人贴在墙上时长度就是 $h$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
int main(){
    int T; scanf("%d", &T); while(T --){
        long double H, h, D;
        scanf("%Lf%Lf%Lf", &H, &h, &D);
        long double l = D * h / H;
        long double r = D * h / (H - h);
        long double x0 = h * sqrtl(D / (H - h));
        if(l <= x0 && x0 <= r)
            printf("%.3Lf\n", H + D - 2 * sqrtl(D * (H - h)));
        else printf("%.3Lf\n", max(D / H * h, h));
    }
    return 0;
}
```

---

## 作者：Astral_Plane (赞：2)

就这种题基本90%是个数学题，~~数学好的一点算法都不用~~。

最重要的是，针对不同的计算方式，要采取完全不同的定义域。

#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-8;
int t; double H,h,D;
double cal(double x)
{
	return x+(h-x)*D/(H-x);
}
double three_devide(double low,double up)
{
	double m1,m2;
	while(up-low>=eps)
	{
		m1=low+(up-low)/3;
		m2=up-(up-low)/3;
		if(cal(m1)<=cal(m2))
		  low=m1;
		else up=m2;
	}
	return (m1+m2)/2;
}
int main()
{
	freopen("ZOJ3203.in","r",stdin);
	freopen("ZOJ3203.out","w",stdout);
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lf%lf%lf",&H,&h,&D);
    	double ans=three_devide(0,h);
    	printf("%0.3lf\n",cal(ans));
	} 
	return 0;
}
```
这里采取最好理解的一种方式，上原图：

![“原图”](https://cdn.luogu.com.cn/upload/image_hosting/qoe1o8mc.png)

这样的话，由于考虑到对勾函数是单峰函数，并且一次函数部分的极值无论如何也不需要，定义域应该确定为~~简单的~~：（0，h）.

似乎大部分题解的定义域都和这个不同，公式不同咯，我就提供一个我觉得简单的版本。

---

## 作者：Lebetap (赞：1)

~~这很显然是一道三分~~

因为影子的长度很明显会是一个单峰函数

---

![](https://cdn.luogu.com.cn/upload/image_hosting/c9x1z4it.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们可以看到这张图片，利用直角构造两个相似三角形

当$Mildleopard$站在**离灯泡**$x$水平距离时，他与墙的距离即为$D - x$

那么这两个三角形的相似比即为$x/(D - x)$

我们知道灯泡的高度与$Mildleopard$的高度的差为$H - h$

然后就可以算出下面的三角形的较短边的长度(我实在不知道用什么表述了)
即为$(H - d) / [x / (D - x)] = (H - d) / x * (D - x)$

然后我们就可以算出在墙上的影子的长度为$h - (H - d) / x * (D - x)$

那么整个影子的长度即为$D - x + h - (H - d) / x * (D - x)$

但是，我们还有一种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/xwdg6llk.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

~~图画的比较丑，见谅~~

与上述方法相同，我们还是利用直角构造两个相似三角形

但此时我们的相似比为$(H - h)/h$(h为$Mildleopard$的身高，我忘在图上标了)

影子的长度即为$x / (H - h) * h$

以上就是check了，三分就比较简单，但要**卡一下精度**，这里就不赘述了

```cpp
#include <cstdio>

double H, h, D;

double check(double x) {
	if((H - h) / x * (D - x) > h) {           //如果灯的高度小于影子到墙时底部到灯的距离 
		return x / (H - h) * h;               //就返回第二种情况 
	}
	return D - x + h - (H - h) / x * (D - x); //否则返回第一种 
}

double Three(double l, double r) {            //三分 
	while(l + 0.0000001 < r) {
		double midl = l + (r - l) / 3;
		double midr = r - (r - l) / 3;
		if(check(midl) > check(midr)) {
			r = midr;
		} else {
			l = midl;
		}
	}
	return l;
}

int main() {
	int t;
	scanf("%d", &t);
	while(t--) {
		scanf("%lf %lf %lf", &H, &h, &D);
		printf("%.3f\n", check(Three(0, D)));
	}
	return 0;
} 
```

---


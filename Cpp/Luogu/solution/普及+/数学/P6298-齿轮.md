# 齿轮

## 题目描述

Daniel13265 从不知哪里找来了 $n$ 个齿轮，第 $i$ 个齿轮的齿数为不超过 $m$ 的正整数 $a_i$。他现在想把其中 $k$ 个齿轮按照一定的方式拼接在一起。

当齿轮使用一段时间后，就会产生损耗。一个齿轮组的损耗速率是由这个齿轮组的所有齿轮齿数的最大公约数决定的：最大公约数越大，相同的齿之间啮合的频率就会增高，从而损耗的速率就会变快。这个最大公约数又被称为损耗因子。

算出一个齿轮组的损耗因子是很容易的。可是现在 Daniel13265 想要知道，对于可能拼接出的所有齿轮组的损耗因子。

Daniel13265 知道拼接出损耗因子大于 $m$ 的齿轮组是不可能的，而且由于可能拼出的齿轮组的个数很多，你只需要反过来告诉他对于所有的 $t\in[1, m]$，能够拼接出的损耗因子为 $t$ 的齿轮组的个数对 $10^9+7$ 取模后的结果即可。

## 说明/提示

### 样例解释

损耗因子为 $1$ 的齿轮组有 $(1,2),(1,3),(1,4),(1,6),(2,3),(3,4)$ 共 $6$ 个；  
损耗因子为 $2$ 的齿轮组有 $(2,4),(2,6),(4,6)$ 共 $3$ 个；  
损耗因子为 $3$ 的齿轮组有 $(3,6)$ 共 $1$ 个。

### 数据范围

**本题采用捆绑测试。你每通过一个子任务的所有数据点，就能得到该子任务的全部分数。**

| 子任务编号 | $n\le$ | $m\le$ | $k\le$ | 分值 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10^6$ | $10$ | $10$ |
| $2$ | $10^3$ | $10^3$ | $10^3$ | $20$ |
| $3$ | $10^6$ | $10^3$ | $2$ | $5$ |
| $4$ | $10^6$ | $10^6$ | $1$ | $5$ |
| $5$ | $10^6$ | $10^6$ | $2$ | $20$ |
| $6$ | $10^6$ | $10^6$ | $10^6$ | $40$ |

对于 $100\%$ 的数据，满足 $1\le k\le n\le10^6$，$1\le a_i\le m\le10^6$。

## 样例 #1

### 输入

```
5 6 2
1 2 3 4 6
```

### 输出

```
6 3 1 0 0 0
```

# 题解

## 作者：Daniel13265 (赞：12)

这是「Daniel13265 的公开赛」的官方题解。

---

## 子任务 $1$

暴力枚举这 $k$ 个数得到答案。

## 子任务 $2$

设 $f_{i,j,d}$ 表示前 $i$ 个数中选了 $j$ 个数，这 $j$ 个数的最大公约数为 $d$ 的方案数，那么有转移式

$$f_{i,j,d}=f_{i-1,j,d}+\sum_{\gcd(t,a_i)=d}f_{i-1,j-1,t}$$

如果直接做时间复杂度是 $\mathcal O\left(nkm^2\right)$。

但是可以将式子转化一下，改为对于每一个 $d$，让 $f_{i-1,j-1,d}$ 转移到 $f_{i-1,j-1,\gcd(d,a_i)}$，这样时间复杂度就降为了 $\mathcal O(nkm\log m)$，依然无法通过。

考虑到 $f_{i,j,d}$ 中非零值的个数为

$$\mathcal O\left(\sum_{i=1}^{k}\frac{\min(n,m)}i\right)=\mathcal O(\min(n,m)\log k)$$

所以只记录这些值进行转移，时间复杂度为 $\mathcal O\left(n\min(n,m)\log k\log m\right)$。由于实际运行时其复杂度达不到理论上界，因此可以通过本题。而如果在 $\mathcal O\left(m^2\right)$ 的时间复杂度内预处理出任意两个数之间的最大公约数，时间复杂度就进一步减为 $\mathcal O\left(m^2+n\min(n,m)\log k\right)$。

## 子任务 $3$

直接预处理出任意两个数之间的最大公约数，然后再判断每一对数出现了多少次即可。

## 子任务 $4$

直接统计每个数出现了多少次。

## 子任务 $5,6$

设损耗因子为 $t$ 的齿轮组个数为 $f_t$，则根据容斥原理有

$$f_t=\binom{\sum_{i=1}^{n}\left[t|a_i\right]}{k}-\sum_{t|i}f_i$$

即在所有能被 $t$ 整除的数中选出 $k$ 个数的方案数减去选出来的数的最大公约数大于 $t$ 的方案数，就是最大公约数刚好等于 $t$ 的方案数。

直接倒着枚举 $t$ 按照这个式子做即可通过此题，总时间复杂度为

$$\mathcal O(n)+\sum_{i=1}^{m}\mathcal O\left(\frac{m}{i}\right)+\mathcal O(m)=\mathcal O(n+m\log m)$$

---

## 作者：StudyingFather (赞：11)

我们设 $g_i$ 表示选 $k$ 个数，它们的 $\gcd$ 是 **$i$ 的倍数** 的方案数。

显然有：

$$
g_i=\binom {\sum_{i=1}^n [i|a_i]}{k}
$$

然而 $g_i$ 不仅包括了 $\gcd$ 是 $i$ 的情况，还包括了 $\gcd$ 是 $2i,3i, \ldots$ 的情况。

我们可以容斥。倒序枚举 $i$，将 $g_i$ 的值，减去 $g_{2i},g_{3i},\ldots$ 的值即可。

时间复杂度？求 $g_i$ 的过程可以做到 $O(m \log m)$，组合数可以直接预处理阶乘的逆元，时间复杂度 $O(n)$。

总时间复杂度 $O(m \log m+n)$。

```cpp
// Problem : P6298 齿轮
// Contest : Luogu Online Judge
// URL : https://www.luogu.com.cn/problem/P6298
// Author : StudyingFather
// Site : https://studyingfather.com
// Memory Limit : 128 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#define MOD 1000000007
using namespace std;
long long f[1000005],inv[1000005],invf[1000005],g[1000005];
int t[1000005];
long long c(int x,int y)
{
 if(x<y)return 0;
 return f[x]*invf[y]%MOD*invf[x-y]%MOD;
}
int main()
{
 ios::sync_with_stdio(false);
 int n,m,k;
 cin>>n>>m>>k;
 f[0]=invf[0]=1;
 for(int i=1;i<=n;i++)//预处理
 {
  if(i!=1)inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;
  else inv[1]=1;
  f[i]=f[i-1]*i%MOD;
  invf[i]=invf[i-1]*inv[i]%MOD;
 }
 for(int i=1;i<=n;i++)
 {
  int x;
  cin>>x;
  t[x]++;
 }
 for(int i=m;i;i--)
 {
  int cnt=0;
  for(int j=1;i*j<=m;j++)
  {
   cnt+=t[i*j];
   g[i]=(g[i]-g[i*j]+MOD)%MOD;//容斥的过程
  }
  g[i]=((g[i]+c(cnt,k))%MOD+MOD)%MOD;
 }
 for(int i=1;i<=m;i++)
  cout<<g[i]<<' ';
 return 0;
}
```

---

## 作者：迟暮天复明 (赞：4)

![](bilibili:BV1Yb4y1S7mH)

---

## 作者：ethan0328 (赞：3)

## 题意

给定 $n$ 个数，其中取 $k$ 个数，它们的最大公约数为 $t$，其中 $t\in[1, m]$，求对于每一个 $t$，有多少种取法。

## 思路

令 $f_{i}$ 表示表示选 $k$ 个数，它们的最大公约数是 $i$ 的倍数的方案数。

显然 $f_{i}$ 为 $a_{i}$ 中 $i$ 和 $i$ 的倍数的个数中选 $k$ 个数的方案数

### $f_{i}=\binom{\sum_{x=0}^{n}[i|a_x]}{k}$

但 $f_{i}$ 表示的是 $i$ 的倍数的方案数，还包含 $i \times2,i\times3,\cdots \cdots$ 的方案数。

所以我们考虑倒序枚举 $i$，每次 $f_{i}$ 减去 $f_{i \times 2}+f_{i \times 3}+\cdots \cdots$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,mod=1e9+7;
int n,m,k,f[N],cnt[N],fac[N],inv[N];
int quickpow(int a,int b,int p)
{
	int ret=1;
	a%=p;
	while(b)
	{
		if(b%2==1)
		{
			ret=(ret*a)%p;
		}
		a=a*a%p;
		b/=2;
	}
	return ret;
}
int c(int x,int y)
{
//	cout<<x<<" "<<y<<endl;
	if(x<y)
	{
		return 0;
	}
//	cout<<fac[x]<<" "<<inv[y]<<" "<<inv[x-y]<<endl;
	return fac[x]*inv[y]%mod*inv[x-y]%mod;
}
signed main()
{
	int x,y;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		cnt[x]=(cnt[x]+1)%mod;
	}
	fac[0]=fac[1]=1;
	for(int i=2;i<N;i++)
	{
		fac[i]=fac[i-1]*i%mod;
	}
	inv[N-1]=quickpow(fac[N-1],mod-2,mod);
	for(int i=N-2;i>=0;i--)
	{
		inv[i]=inv[i+1]*(i+1)%mod;
	}
	for(int i=m;i;i--)
	{
		x=0;
		y=0;
		for(int j=i;j<=m;j+=i)
		{
			x=(x+cnt[j])%mod;
			y=(y+f[j])%mod;
		}
		f[i]=((c(x,k)-y)%mod+mod)%mod;
	}
	for(int i=1;i<=m;i++)
	{
		cout<<f[i]<<" ";
	}
}
```


---

## 作者：FZzzz (赞：3)

本来不想发题解的，发现题解跟我不一样就发一个吧。

我是套路选手，所以直接上莫比乌斯反演。

设：$f(x)$ 为选 $k$ 个数的 $\gcd$ 为 $x$ 的方案数，$g(x)=\sum\limits_{x|d}f(d)$。

则 $g(x)$ 即为选 $k$ 个数的 $\gcd$ 为 $x$ 的倍数的方案数，亦即为选 $k$ 个数都为 $x$ 的倍数的方案数。

设有 $c$ 个数是 $x$ 的倍数，则 $g(x)=C_c^k$，这里钦定 $c<k$ 时 $C_c^k=0$。

这个 $C_c^k$ 是可以递推出来的，这样 $g(x)$ 是可以在 $O(\frac n x)$ 时间内预处理出来的（这里认为 $n$ 与 $m$ 同阶），那么根据调和级数，整个 $g$ 函数就是可以在 $O(n\log n)$ 内预处理出来的。

然后根据莫比乌斯反演，我们知道 $f(x)=\sum\limits_{x|d}\mu(\frac d x)g(d)$，于是 $f$ 也是可以在总共 $O(n\log n)$ 时间内算出来的。总时间复杂度 $O(n\log n)$。

下面是代码，有点卡常。
```cpp
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
    int x=0;
    bool f=0;
    char c=getchar();
    while(!isdigit(c)&&c!='-') c=getchar();
    if(c=='-'){
        f=1;
        c=getchar();
    }
	while(isdigit(c)){
        x=x*10+c-'0';
        c=getchar();
    }
    return f?-x:x;
}
const int maxn=1e6+5;
int n,m,k,cnt[maxn];
typedef long long ll;
ll mod=1e9+7;
ll inv[maxn],c[maxn];
int minf[maxn];
ll mu[maxn];
ll g[maxn];
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=readint();
    m=readint();
    k=readint();
    for(int i=0;i<n;i++) cnt[readint()]++;
    inv[1]=1;
    for(int i=2;i<=n-k;i++) inv[i]=inv[mod%i]*(mod-mod/i)%mod;
    c[k]=1;
    for(int i=k+1;i<=n;i++) c[i]=c[i-1]*i%mod*inv[i-k]%mod;
    for(int i=2;i<=m;i++) if(!minf[i])
    	for(int j=i;1ll*i*j<=m;j++) minf[i*j]=i;
    mu[1]=1;
    for(int i=2;i<=m;i++)
    	if(!minf[i]) mu[i]=mod-1;
    	else{
    		if((i/minf[i])%minf[i]==0) mu[i]=0;
    		else mu[i]=mu[minf[i]]*mu[i/minf[i]]%mod;
		}
	for(int i=1;i<=m;i++){
		int tot=0;
		for(int j=1;i*j<=m;j++) tot+=cnt[i*j];
		g[i]=c[tot];
	}
	for(int i=1;i<=m;i++){
		ll ans=0;
		for(int j=1;i*j<=m;j++) ans=(ans+mu[j]*g[i*j]%mod)%mod;
		printf("%d ",(int)ans);
	}
	printf("\n");
    return 0;
}
```

---

## 作者：Godzilla (赞：0)

### $\mathtt{Description:}$

给定 $n$ 个数，求其中取 $k$ 个数，它们的 $\gcd$ 为 $t$ ，其中 $t∈[1,m]$ 。

### $\mathtt{Solution:}$

套路：

这里是求多个数的 $\gcd$ 为 $t$ ，那么可以设 $f(i)$ 表示用 $k$ 个数，组合是 $i$ 的的方案数。

那么可以用容斥：

$f(i)=sum-f(2i)-f(3i)-f(4i)\dots f(ki)$

其中 $sum$ 为组合是 $i$ 的 **倍数** 的方案数， $ki$ 为不大于 $n$ 的最大整数。

注意这里要倒序枚举，不然会出错。

预处理阶乘 $O(n)$ ，求 $f(i)$ 为 $m\log m$ ，即 $\dfrac{m}{1}+\dfrac{m}{2}+\dots \dfrac{m}{m}$ 。

这里会用到 [乘法逆元](https://www.cnblogs.com/zjp-shadow/p/7773566.html) 预处理组合数。

### $\mathtt{Code:}$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

#define LL long long
#define PR pair<int,int>

using namespace std;

const int kN=1e6;
const int kMod=1e9+7;

int n,m,k;
int a[kN+5];
int num[kN+5];
LL fac[kN+5],inv[kN+5];
LL f[kN+5];

int v[kN];

LL Qpow(LL a,LL b){
	LL res=1;
	for(int i=0;(1<<i)<=b;++i){
		if(b&(1<<i)){
			res=(res*a)%kMod;
		}
		a=(a*a)%kMod;
	}
	return res;
}

void Init(){
	fac[0]=1;
	for(int i=1;i<=kN;++i){
		fac[i]=(fac[i-1]*i)%kMod;
	}
	inv[kN]=Qpow(fac[kN],kMod-2);
	for(int i=kN-1;i>=0;--i){
		inv[i]=inv[i+1]*(i+1)%kMod;
	}
}

LL C(LL n,LL m){
	return fac[n]*inv[m]%kMod*inv[n-m]%kMod;
}

int main(){
	Init();
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		v[a[i]]++;
	}
	for(int i=1;i<=m;++i){
		for(int j=i;j<=m;j+=i){
			if(!v[j]){continue;}
			num[i]+=v[j];
		}
	}
	for(int i=m;i;--i){
		if(!num[i]||num[i]<k){continue;}
		f[i]=C(num[i],k);
		for(int j=2*i;j<=m;j+=i){
			f[i]-=f[j];
			f[i]=(f[i]+kMod)%kMod;
		}
	}
	for(int i=1;i<=m;++i){
		printf("%lld ",f[i]);
	}
	return 0;
}
```





---


# 隔离的日子

## 题目背景

（背景改编自 百度贴吧/南北组备用吧/呆萌南北日常/F9023，作者 [落墨成白](https://tieba.baidu.com/home/main/?un=%E8%93%93%E8%90%BD%E9%B1%BC&ie=utf-8&id=tb.1.a8bcbb73.CMcL9PXngjHz-dKRJ7_T4A&fr=frs)）

### 数据已修复。 

&emsp;&emsp;一天又一天，每到深夜房间里又只余下手机屏幕的亮光，洛天依总会有一种与世界割离的失落感。  
&emsp;&emsp;闷在被子里孤独的想哭的日子里，她开始想念起哪些忙于工作带着一点点畏惧、忐忑和烦恼的小日子。  
&emsp;&emsp;毒辣的阳光，想出门的心，不想被晒黑的小心思交织在一起，占据心间的便是这些复杂的小情绪。  
&emsp;&emsp;如果可以还行要一份水果拼盘，阿绫总说她不能贪凉，所以趁着阿绫大意的时候把双手浸入打满水的水桶中，瞄着阿绫那无可奈何的眼神，心情舒爽啊。  
&emsp;&emsp;每到深夜回想起来仍会觉得回味无穷，可孤单一人时将水龙头拧开胳膊冲刷而过的冰凉感却寻不着那时的快乐。  
&emsp;&emsp;都说对生活选择短暂遗忘时，就会收获一丁点儿的快乐。  
&emsp;&emsp;可是为什么脑海里的那些场景却越发清晰？  
&emsp;&emsp;以往每逢休假，暖暖的阳光隔着玻璃照进来，阿绫就躺在摇椅上，她便可以赖在阿绫怀里软软的趴着，一个中午的就这么过去了，宛如养成系手游般堪是消磨时间的良方。  
&emsp;&emsp;还有街角那家糖炒栗子，拉着阿绫站在店铺门前看着油亮的栗子在翻炒机理跳着舞，被炸开的缝里透出诱人的气息。  
&emsp;&emsp;缠着阿绫买上几斤装好，恼人的阿绫却不肯给她，只是无比淡定地从袋子里捞出一粒，轻轻一捏，板栗便爆开了，轻轻一掰，栗子肉完完整整地出现在她的面前。这时她只需要张嘴，阿绫只会宠溺的将栗子喂到她的嘴里，只需看见她眯眼满足的表情，阿绫也会露出开心的笑。  
&emsp;&emsp;不禁泛起苦笑，自己还有一套对栗子的深入研究呢——

## 题目描述

以前，天依会把买来的 $n$ 个栗子排成一行，从左至右编号为：$1,2,\cdots ,n$，第 $i$ 颗栗子有甜度 $a_i$ 和咸度 $b_i$。

天依认为甜和咸应该进行均衡的搭配，所以她定义了一个完美搭配 $(i,j)$，其中 $i,j$ 是两个栗子的下标。具体的，称 $(i,j)$ 为一个完美搭配，当且仅当 $j$ 是所有满足 $i<j \leq n$ 并且 $(a_j-b_i) \times (b_j+b_i)=a_j \times b_i + a_i \times b_j$ 的 $j$ 中**最小的一个**。不难发现当 $i$ 一定，完美搭配唯一确定。
   
现在天依想知道，对于每个栗子 $i$，哪个栗子和它形成完美搭配？

## 说明/提示

#### 样例解释 #1

第一个栗子：$(22 - 8) \times (8 + 8) = 22 \times 8 + 6 \times 8$，所以输出为 $2$。

第二个栗子没有满足条件的完美搭配。

第三个栗子：$(23 - 4) \times (4 + 4) = 23 \times 4 + 15 \times 4$，所以输出为 $4$。

第四个栗子：$(31 - 4) \times (4 + 4) = 31 \times 4 + 23 \times 4$ ，所以输出为 $5$。

因为第五个栗子是最后一个栗子，所以没有满足条件的完美搭配。

---

#### 数据范围 
**本题采用捆绑测试。**

- Subtask 1（30 Points），$n \leq 10^3$。
- Subtask 2（70 Points），$n \leq 5 \times 10^4$。

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^4$，$1 \leq a_i \leq 10^9$，$1 \leq b_i \leq 100$。

---

### 题目背景 ( 续 )
&emsp;&emsp;味道愈发的真实，栗子的香气仿佛仍绕在鼻尖……  
&emsp;&emsp;味道？洛天依猛然起身走出卧室隔着一道门栏，望着她。  
&emsp;&emsp;“你是不是傻？我现在在隔离呀，你来干什么？”有惊喜有忧虑洛天依骤然哭泣出声。  
&emsp;&emsp;乐正绫挠挠头，栗子的温热隔着纸袋传到手心，像寒冷日子里抱在手中的暖宝宝。  
&emsp;&emsp;“我回程的列车上有感染病例，我也需要被隔离了，他们问我家在哪里，我说了你的地址。”  
&emsp;&emsp;乐正绫剥开壳，捏了一颗放进小哭包的嘴里。  
&emsp;&emsp;栗子香在两人嘴角飘荡，“时间又得加长了啊……”天依微微喘着气嘟囔道，心底却是多了几分期待的快乐，其实如果有阿绫在的话，也不是不可以在房间多待段时间的。  
&emsp;&emsp;“啊，很抱歉呢。”乐正绫轻笑着。不知道是因为再次珍贵的时间，还是手指抚摸过天依泛红的唇角。

## 样例 #1

### 输入

```
5
6 8
22 8
15 4
23 4
31 4```

### 输出

```
2
-1
4
5
-1```

# 题解

## 作者：Reanap (赞：7)

这道题还是比较简单，我相信$50\%$以上的参赛选手都能够拿到良心出题人的这$100$pts。（出题人现在才想起交题解）

首先我们观察式子：

 $(a_j-b_i) \times (b_j+b_i)=a_j \times b_i + a_i \times b_j$ 
 
 发现这个式子非常地不好看，我们想要把下标相同放在一块儿（方便预处理维护），所以我们把式子括号拆开，得：
 
 $a_j \times b_j + b_i \times a_j - b_j \times b_i - b_i \times b_i = a_j \times b_i + a_i \times b_j$
 
 移项合并同类项，提取公因式得：
 
 $(a_j - a_i - b_i) \times b_j = b_i \times b_i $
 
 我们设 $k = a_j - a_i - b_i$
 
 则有:
 
 $k \times b_j = b_i \times b_i$
 
 和
 
 $a_j = a_i + b_i + k$
 
 因此我们就列出这样一个不定方程组，只要知道了一个未知项就可以知道其他项。
 
 因此我们考虑枚举$k$，观察式子可知$k$必然是$b_i \times b_i$的因数。而且题目中$b_i$比较小，因此完全可以去枚举，然后去计算$a_i$和$b_i$，之后在判断是否存在$a_i$和$b_i$这种元素的情况（可以使用map来维护，其实$b$的极限数据可以提升到$1000$去卡$\log n$的map，但出题人比较良心）。
 
 如果还有不懂的可以去看看下面的代码：
 
 ```cpp
#include <map>
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 5e4 + 5;
map <pair<int , int> , int> M;
int n , a[MAXN] , b[MAXN] , ans[MAXN];
signed main() {
//	freopen("11.in" , "r" , stdin);
//	freopen("11.out" , "w" , stdout);
	scanf("%d" , &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d %d" , &a[i] , &b[i]);
	}
	for (int i = n; i >= 1; --i) {
		int res = 1e9;
		for (int j = 1; j <= b[i]; ++j) {
			if(b[i] * b[i] % j == 0) {
				int x = 0 , y = 0;
				if(M[make_pair(a[i] + b[i] + j  , b[i] * b[i] / j)]) {
					x = M[make_pair(a[i] + b[i] + j  , b[i] * b[i] / j)];
				}
				if(M[make_pair(a[i] + b[i] + b[i] * b[i] / j  , j)]) {
					y = M[make_pair(a[i] + b[i] + b[i] * b[i] / j  , j)];
				} 
				if(x) res = min(res , x);
				if(y) res = min(res , y);
			}
		}
		if(res != 1e9) ans[i] = res;
		else ans[i] = -1;
		M[make_pair(a[i] , b[i])] = i;
	}
	for (int i = 1; i <= n; ++i) printf("%d\n" , ans[i]);
	return 0;
}
 
 ```
 
 
 

---

## 作者：囧仙 (赞：4)

- **题意**

  给出两个长度为 $n$ 的序列 $a,b$，对于每个 $i$，求一个最小的 $j$，使得 $(a_j - b_i) \times (b_j + b_i) = a_j \times b_i + a_i \times b_j$，找不到输出 `-1`
  
- **解析**

  首先肯定要对那个式子进行化简：
  
  $$(a_j - b_i) \times (b_j + b_i) = a_j \times b_i + a_i \times b_j$$
  
  $$ a_j \times b_j + a_j \times b_i - b_i \times b_j - (b_i) ^ 2 = a_j \times b_i + a_i \times b_j$$
  
  发现两边都有 $a_j \times b_i$，这样就消去了一项，变为：
  
  $$a_j \times b_j - b_i \times b_j - (b_i)^ 2 = a_i \times b_j$$
  
  $$a_j \times b_j = a_i \times b_j + b_i \times b_j + (b_i) ^ 2$$
  
  然后你就会发现，未知量太多了，有 $a_j,b_j$ 两个，做不了
  
  那么这个时候怎么办呢？
  
  ~~弃题，跑路~~
  
  这种情况一般需要去看下数据范围
  
  $$1 \le b_i \le 100$$
  
  考虑对于每个 $i$ 进行求解时枚举一个 $b_j$，这样未知量就只有 $a_j$ 了
  
  枚举了 $b_j$，等式右边的值我们都是已知的，也就可以解出 $a_j$ 了
  
  于是，问题转化为：$5 \times 10 ^ 6$ 次求 $i$ 右边第一个 $a_j = x,b_j = y$ 的数的位置
  
  考虑开 $100$ 个 set，第 $i$ 个 set 存所有 $b_j = i$ 的 $j$，这样满足了 $b_j = y$ 的限制
  
  然后从左往右求解每个询问，每次从 $i$ 移动到 $i + 1$ 时把 $i + 1$ 删掉，这样满足了在 $i$ 右边的限制
  
  $a_j = x$ 的限制可以让 set 按大小关系排序，然后用 lower_bound 求出来
  
  然后这题就做完了，答案是每个 $b_j$ 求出的答案的 $\min$
  
  时间复杂度：$O(n \log n \times b_i)$
  
  ~~其实我觉得暴力没准能卡过去~~
  
代码：

```cpp
#include <cstdio>
#include <set>
using namespace std;
#define ll long long
int n;
ll a[50005],b[50005];

struct node{
	ll val;//存的是编号
	friend bool operator<(node x,node y){
	    if(a[x.val] == a[y.val]) return x.val < y.val;//当值相同的时候，编号在前面的更优
	    return a[x.val] < a[y.val]; //从小到大排序
    }
};

set <node> fnd[105];

int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++){
		scanf("%lld%lld",&a[i],&b[i]);
		fnd[b[i]].insert({i});
	}
	for(int i = 1;i <= n;i++){
		fnd[b[i]].erase({i});
		int ans = 0x3f3f3f3f;
		for(int j = 1;j <= 100;j++){
			ll val = a[i] * j + b[i] * j + b[i] * b[i];
			if(val % j != 0) continue;//方程无整数解，舍去
			a[0] = val / j;
			set<node>::iterator res = fnd[j].lower_bound({0});
			if(res != fnd[j].end() && a[res->val] == val / j){//lower_bound 找不到会返回end，要判一下
				if(ans > res->val) ans = res->val;
			}
		}
		if(ans == 0x3f3f3f3f) printf("-1\n");
		else printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：cyn2006 (赞：2)

### $Part\ 1$

由题意：

$$(a_j-b_j)(b_i+b_j)=a_jb_i+a_ib_j$$
$$a_jb_j-b_i^2-b_ib_j+a_jb_i=a_jb_i+a_ib_j$$
$$a_jb_j-b_ib_j-a_ib_j=b_i^2$$
$$b_j(a_j-a_i-b_i)=b_i^2$$

假设我们当前枚举的栗子为 $i$，则 $a_i,a_j$ 定

令 $a_i+a_j=c,\ b_i^2=d$，$c,d$ 为常数，则有 $b_j(a_j-c)=d\Longrightarrow a_j=c+\frac{d}{b_j}$

由于 $a_j\in N^+,b_j\in [1,100]$，我们可以枚举 $b_j$ 使得 $b_j|d$，再去判断 $a_j$ 的有无以及寻找最小值。

### $Part\ 2$

考虑使用哈希表 $or\ map$ 的数据结构。

我们以 $b$ 的定义域为大小，由此建立 $100$ 个哈希表，从右往左枚举，边查询边将新的 $(a_i,b_i)$ 存到哈希表 $or\ map$ 中，最后将答案输出即可。

```cpp
int hash(int x){
	return x&65535;//hash 这样写也能过
}
void solve(){
	mp[b[n]][hash(a[n])]=n,ret[n]=-1;
	for(int i=n-1;i;--i){
		int x=a[i],y=b[i],ans=INT_MAX;
		for(int j=1;j<=100;++j){
			if(y*y%j==0){
				int c=y*y/j+y+x;
				if(mp[j][hash(c)])
					ans=std::min(ans,mp[j][hash(c)]);
			}
		}
		mp[b[i]][hash(a[i])]=i;
		ret[i]=ans==INT_MAX?-1:ans;
	}
}
```

### 时间复杂度？

- 如果食用哈希表的话复杂度为 $O(100n)$
- 如果食用 $map$ 的话复杂度为 $O(100nlog_2n)$
- 不过我就这样写 $hash$ 了还是比 $pb\_ds$ 的 $hash\_table$ 慢？~~食用平板电视真好！~~

---

## 作者：Vsinger_洛天依 (赞：1)

[原题](https://www.luogu.com.cn/problem/P6393)

- 题意：
$a$ 和 $b$ 两个长度为 $n$ 的序列中，$i$ 和 $j$ 为序列的下标同时满足 $i<j<n$，求在满足 $(a_j-b_i) \times (b_j+b_i) = a_j \times b_i +a_i \times b_j$ 中最小的 $j$，若不存在则输出 $-1$。

- 思路：
将原式子进行因式分解。
$$(a_j-b_i) \times (b_j+b_i) = a_j \times b_i +a_i \times b_j$$
$$a_j \times b_j + a_j \times b_i - b_i \times b_j-b_i^2 = a_j \times b_i +a_i \times b_j$$
再通过移项与合并同类项得以下式子。
$$a_j \times b_j+a_i \times b_j-a_i\times b_j=b_i^2$$
$$b_j\times(a_j+a_i+b_i)=b_i^2$$
考虑本题数据范围较小，仅为 $1\le b_i\le100$ 。

可以考虑在求解 $i$ 时枚举 $b_j$ 的值，此时只需求出 $a_i$ 的值来解此题。

且因数据较弱，可使用 ```map``` 来求解。

```map``` 的用法可见 oi-wiki 的[关联式容器](https://oi-wiki.org/lang/csl/associative-container/#map)处。

- 解析：
创建一个 ```map``` 维护 $i$ 与其对应的 $j$，用数组记录所有 $j$ 的值，并找出最小的 $j$。

  找出最小值可以先定义一个极大值，再使用 $\min$ 函数求出所求的最小 $j$。若仍为极大值则输出 $-1$ 即无解。

    


---

## 作者：HHC883 (赞：0)

# 题目分析
先推式子。

$$(a_j - b_i) \times (b_j + b_i) = a_j b_j + a_j b_i - b_i b_j - b_i^2$$

为使

$$a_j b_j + a_j b_i - b_i b_j - b_i^2 = a_j b_i + a_i b_j$$

应有

$$a_j b_j - b_i b_j - b_i^2 = a_i b_j$$

整理得

$$(a_i + b_j) b_j + b_i^2 = a_j b_j$$

但是这个式子还是很难处理。不过我们注意到 $  1\le b_i \le 100$，所以 $b_i$ 只有 $100$ 种可能。于是我们想到枚举 $b_i$，然后 $a_j b_j$ 就确定下来了，所有满足 $(a_j - b_i) \times (b_j + b_i) = a_j b_i + a_i b_j$ 的栗子也就确定下来了。但题目还要求 $j>i$ 且尽量小，于是我们想到为每个栗子唯一编号为 $a_i b_i \times (5 \times 10^4 + 1) + i$（这样所有栗子的编号都互不相同，其实就是哈希的思路），然后把 $b_i$ 相同的栗子放到同一个桶里（桶里存的是编号，可以用 vector 实现），然后对每个桶排序，计算的时候二分桶里第一个大于等于 $((a_i + b_i) b_j + b_i^2) \times (5 \times 10^4 + 1) + i + 1$ 的栗子并判断是否可行即可。注意在每个桶的末尾插入一个极大的数，如 $10^{18}$，以此避免二分出问题。

时间复杂度为 $O(n \log n \max b_i)$。
# 参考代码
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#define int long long
using namespace std;
const int base=5e4+1;
int n;
int a[(int)5e4+5],b[(int)5e4+5];
vector<int> tab[105];
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i],tab[b[i]].push_back(a[i]*b[i]*base+i);
	for(int i=1;i<=100;i++) tab[i].push_back(1e18),sort(tab[i].begin(),tab[i].end());
	for(int i=1;i<=n;i++){
		int ans=1e9;
		for(int j=1;j<=100;j++){
			int tmp=*lower_bound(tab[j].begin(),tab[j].end(),((a[i]+b[i])*j+b[i]*b[i])*base+i+1);
			if(tmp/base==(a[i]+b[i])*j+b[i]*b[i]) ans=min(ans,tmp%base);
		}
		if(ans==1e9) cout<<"-1\n";
		else cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：0)

## 题意

给定两个有 $n$ 个元素的序列 $a,b$，对于每个 $i$ 求出满足：

$$(a_j-b_i)(b_j+b_i)=a_jb_i+a_ib_j$$

的最小 $j$，不存在输出 $\texttt{-1}$。

## 解析

先化简一下。

$$a_jb_j+a_jb_i-b_ib_j-b_i^2=a_jb_i+a_ib_j$$

$$a_jb_j-b_ib_j-b_i^2=a_ib_j$$

准备移项：

$$a_jb_j-b_ib_j-a_ib_j=b_i^2$$

$$b_j(a_j-b_i-a_i)=b_i^2$$

似乎不是很好处理，但是「穷途末路时，莫忘看已知」，考虑对准数据范围做题。

你会发现 $b_i$ 的数据范围特别良心，于是考虑对于每一组 $b_i$ 枚举 $j$，判断整除关系，然后利用 $\texttt{map}$ 或者 $\texttt{set}$ 过题。

---

## 作者：HS_xh (赞：0)

## 题意

$a$ 和 $b$ 两个长度为 $n$ 的序列中，$i$ 和 $j$ 为序列的下标同时满足 $i<j<n$，求在满足 $(a_j-b_i) \times (b_j+b_i) = a_j \times b_i +a_i \times b_j$ 中最小的 $j$，若不存在则输出 $-1$。

## 思路

因式分解
$$(a_j-b_i) \times (b_j+b_i) = a_j \times b_i +a_i \times b_j$$
$$a_j \times b_j + a_j \times b_i - b_i \times b_j-b_i^2 = a_j \times b_i +a_i \times b_j$$
移项与合并可得
$$a_j \times b_j+a_i \times b_j-a_i\times b_j=b_i^2$$
$$b_j\times(a_j+a_i+b_i)=b_i^2$$

因为此题数据范围较小，可以枚举 $b_j$ 的值，所以只需求出 $a_i$ 的值来解此题。

可使用 ```map``` 来求解。

## 解析

创建一个 ```map``` 维护 $i$ 与其对应的 $j$，用数组记录所有 $j$ 的值，并找出最小的 $j$。

  找出最小值可以先定义一个极大值，再使用 $\min$ 函数求出所求的最小 $j$。若仍为极大值则输出 $-1$ 即无解。
  
## 代码
 ```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int> abc;
int n,a[100001],b[100001],c,ans[100001]={0};
map<pair<int,int>,int> maap;
int main() 
{
    cin>>n;
    for(int i=1;i<=n;i++)
   		cin>>a[i]>>b[i];
    for(int i=n;i>=1;--i)
	{
   		c=0x7fffffff;
		for (int j=1;j<=b[i];++j) 
			if(b[i]*b[i]%j==0) 
			{
				int x=0,y=0;
   				if(maap[pair<int,int>(a[i]+b[i]+j,b[i]*b[i]/j)])
   					x=maap[pair<int,int>(a[i]+b[i]+j,b[i]*b[i]/j)]; 

   				if(maap[make_pair(a[i]+b[i]+b[i]*b[i]/j,j)]) 
   					y=maap[pair<int,int>(a[i]+b[i]+b[i]*b[i]/j,j)];

   				if(x!=0) 
				   	c=min(c,x);
   				if(y!=0) 
					c=min(c,y);
			}	
		if(c!=0x7fffffff)
			abc.push(c);
		else
		    abc.push(-1);
		maap[make_pair(a[i],b[i])]=i;
    }
    for(int i=1;i<=n;i++)
	{
    	cout<<abc.top()<<endl;
    	abc.pop();
	}
}
```


---


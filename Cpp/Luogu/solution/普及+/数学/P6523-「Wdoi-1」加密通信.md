# 「Wdoi-1」加密通信

## 题目背景

自月战之后，八云紫在槐安通道中设立了一重结界，使得从地面传向月都的信息全部会被拦截和破译。  

为了维持正常的通讯，八意永琳同月兔们研究出了一种全新的加密方式。

## 题目描述

首先，八意永琳会写出需要被加密的明文 $A$ ，此段明文由 $n-1$ 个正整数构成。

之后，她会构造出一个由 $n$ 个**质数**构成的密文 $B$，满足对  $\forall  i \in [1,n),B_i \times B_{i + 1} = A_i$。

为了提高信息的利用率，八意永琳规定 $B$ 中出现的所有质数的值必须在 $[1,M]$ 范围内。

## 说明/提示

#### 数据规模

- 对于 $20\%$ 的数据，$n \le 5,M \le 10$。

- 对于 $40\%$ 的数据，$A_i \le 10 ^ {12}$。

- 对于 $70\%$ 的数据， $A_i \neq A_{i + 1}$。

- 对于$100\%$的数据，$3 \le n \le 10 ^ 5$，$1 \le A_i,M \le 10 ^ {18}$，$1 \le T \le 5$。

- 以上几档部分分呈**包含关系**，$100\%$ 包含 $70\%$，$70\%$ 包含 $40\%\ \ldots\ldots$以此类推。

#### 数据保证：

- 若不考虑 $b_i$ 在 $[1,M]$ 范围内的条件，必然有至少一组合法解。

- 有至少一对 $(i,j)$，使得 $A_i \neq A_j$。

#### 后置资料

**本段资料与答题相关性不大**。

[百度百科 - 质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin)

## 样例 #1

### 输入

```
2
4 233
55 35 77
4 5
55 35 77 ```

### 输出

```
11 5 7 11 
-1```

# 题解

## 作者：Aw顿顿 (赞：16)

首先要膜 $\bold{\small N\color{red}aOH\_Frog}$，另外被 Wdsr 团踢出来的蒟蒻写一下 Wdoi 题的题解/kk

社区分快掉没了/kel 求个赞，好吗？

## 题意简述

一段由 $n-1$ 个正整数构成的明文 $A$，对应一个由 $n$ 个质数构成的密文 $B$，对于范围内的 $i$ 满足 $B_i\times B_{i+1}=A_i$，且保证质数的范围在 $[1,M]$。

## 解法简析

由于整个密文是以递推的形式展现的，所以只要知道其中的一项，我们就可以很容易推知密文的内容。

其次，对于任意的一个 $A_i$，一定都是两个质数的乘积，也就是说，一个很显然的想法是对其做质因数分解。但是面向数据做题，$A_i\le 10^{18}$，所以这个想法不太现实——但是他是有启发作用的。

题目告诉我们：**有至少一对 $(i,j)$，使得 $A_i \neq A_j$**，这是一个突破口，因为：

$$B_{i-1}\times B_{i}=A_i\quad\large\&\normalsize\quad B_i\times B_{i+1}=A_{i+1}$$

那么怎么办呢？由于 $B_{i-1}$ 和 $B_{i+1}$ 都是质数，所以可以发现 $B_i$ 一定是 $A_i$ 和 $A_{i+1}$ 的质因数，且是最大公因数，即：

$$\gcd(A_i,A_{i+1})=B_i$$

那么我们只要找到这样的一组 $A_i$ 和 $A_{i+1}$ 并求其最大公因数 $B_i$，然后向两端进行推论，就可以得出一个可能的序列了。

因为用辗转相除法可以再 $O(\log n)$ 级别求出公因数，向两端递推的复杂度大致为 $O(n)$，最后判断答案是否存在质数不在 $[1,m]$ 区间内的情况。

代码不是很难实现，那就不放了。


---

## 作者：pigstd (赞：8)

一道简单的构造题

首先，我们发现，只要知道密文中的一个数字，那么就可以把整条密文写出来。因为$B_{i} \times B_{i+1} = A_{i}$，而且$B_{i}$和$B_{i+1}$都是质数，说明$A_{i}$一定是两个质数的乘积，所以$B_{i+1}$一定是$A_{i}$和$A_{i+1}$的因数

但是因为$A_{i} \le 10^{18}$，所以不能直接求质因数，题目告诉我们至少有一对$A_{i}$和$A_{i+1}$满足$A_{i}$不等于$A_{i+1}$，那么这两个数的最大公因数就是$B_{i+1}$的值

c++代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int M=1e5+10;
int T;
int a[M],ans[M];

int gcd(int a,int b)
{
	return b==0?a:gcd(b,a%b);
}//求最大公因数

inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}

signed main()
{
	T=read();
	while(T--)
	{
		memset(a,0,sizeof(a));
		memset(ans,0,sizeof(ans));
		int n=read(),m=read(),ooo;
		for (int i=1;i<n;i++)
			a[i]=read();
		for (int i=1;i<n-1;i++)
			if (a[i]!=a[i+1])
				{int k=gcd(a[i],a[i+1]);ans[i+1]=k,ooo=i+1;break;}//找到其中的一个密文，ooo作为标记改密文的位置
		for (int j=ooo-1;j>=1;j--)
			ans[j]=a[j]/ans[j+1];//向前推密文
		for (int j=ooo+1;j<=n;j++)
			ans[j]=a[j-1]/ans[j-1];//向后推密文
		int flag=1;
		for (int i=1;i<=n;i++)
			if (ans[i]>m)
				{flag=0;break;}//判断是否有质数大于m
		if (!flag)
			printf("-1\n");
		else
			for (int i=1;i<=n;i++)
				printf("%lld ",ans[i]);
		printf("\n");//输出
	}
	return 0;
}
```

---

## 作者：Utilokasteinn (赞：4)

感觉这道题不是很难，唯一难就难在不能从第一个数开始找质因数。

题目说了，给出n-1个数，要求把它们拆分成n个质数，并且小于等于m，输出这n个质数。如果无法实现，就输出-1。因为题目满足n-1个数都能被拆分成两个质数，所以直接用__gcd函数就可以了。但是，如果有两个相同的数挨在一起，那么第一个数就有两种选择的机会，一种是__gcd(a[1],a[2]),一是a[1]/__gcd(a[1],a[2])，比如下面组数据：
```cpp
1
5 100
21 21 33 77

```

如果从第一个数开始做，它会分解成这5个数：1，21，1，33，2。显然，这个答案是错的，这也是为什么有人得70分的原因(因为我最开也这样。。。。)

正解是先查找到第一个与后一个数不相等的那个数，记录下来。然后从那个数开始，向前向后做，这样就可以避免有两个数重复。这样做，上面例子的答案是这样的：3，7，3，11，7。

代码如下：
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
long long t,n,m,k,a[100001],ans[100001],flag=1;
//t代表t组数据，n代表n个数，m代表质数大小不可以超过m
//k用来记录第一个与后面那个数不相等的数
//a[i]用来存储输入的n-1个数
//ans[i]用来存储答案，也就是n个质数 
//flag是用来看质数是否超过m，超过就是0，没超过是1 
int main()//主函数 
{
	for(cin>>t;t--;flag=1,cout<<endl)
	{//输入数据数，循环t次，每次flag都要赋值为1，并且换行 
		cin>>n>>m;//输入n和m 
		for(int i=1;i<n;i++)
			cin>>a[i];//输入n-1个数 
		for(int i=1;i<n-1;i++)
			if(a[i]!=a[i+1])
			{//找到第一个与后一个数不相等的数 
				ans[i+1]=__gcd(a[i],a[i+1]);
				k=i;//记录是第几个数 
				break;
			}
		for(int i=k;i>0;i--)
			ans[i]=a[i]/ans[i+1];
		//从后往前算 
		for(int i=k+1;i<=n;i++)
			ans[i]=a[i-1]/ans[i-1];
		//从前往后算 
		for(int i=1;i<=n;i++)
			if(ans[i]>m){flag=0;break;}
		//如果有一个质数大于m，flag就等于0，就可以直接退出了 
		if(flag)for(int i=1;i<=n;i++)//如果flag不为0，就输出质数 
			cout<<ans[i]<<" ";//输出质数 
		else cout<<-1;//否则就输出-1
		//换行在前面的循环里面 
	}
	return 0;//程序结束 
}
```
最后附上无注释代码，挺简洁的，只有572B：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,m,k,a[100001],ans[100001],flag=1;
int main()
{
	for(cin>>t;t--;flag=1,cout<<endl)
	{
		cin>>n>>m;
		for(int i=1;i<n;i++)
			cin>>a[i];
		for(int i=1;i<n-1;i++)
			if(a[i]!=a[i+1])
			{
				ans[i+1]=__gcd(a[i],a[i+1]);
				k=i;
				break;
			}
		for(int i=k;i>0;i--)
			ans[i]=a[i]/ans[i+1];
		for(int i=k+1;i<=n;i++)
			ans[i]=a[i-1]/ans[i-1];
		for(int i=1;i<=n;i++)
			if(ans[i]>m){flag=0;break;}
		if(flag)for(int i=1;i<=n;i++)
			cout<<ans[i]<<" ";
		else cout<<-1;
	}
	return 0;
}
```
谢谢观赏

---

## 作者：Day_Dreamer_H (赞：2)

# P6523 题解

## 题目大意
$T$ 组数据，每组给定 $N,M$ 以及长度为 $N-1$ 的数组 $A$，求一个长度为 $N$ 的数组 $B$ 使得对于 $B_i \times B_{i+1}=A_i$，$0\le i<n$ 并且 $B$ 中元素均 $\le M$ 且为质数，若无解输出 $-1$。

$A_i,M\le 10^{18},3\le N\le5$
## 思路
~~一眼构造并且没有思路~~

一开始看到质数的第一反应是上个筛子，但一看 $10^{18}$ 就放弃了这个行为。

**看看数据范围发现了几行奇怪的话：**

对于 $70\%$ 的数据， $A_i \neq A_{i+1}$。

若不考虑 $b_i$ 在 $[1,M]$ 范围内的条件，必然有至少一组合法解。

有至少一对 $(i,j)$，使得 $A_i \neq A_j$。

为什么频繁的提到了 $A_i\neq A_j$，似乎在暗示什么（这很明显）。

我们发现一个性质：

$B_i\times B_{i+1}=A_i$，并且 $B_{i-1}\times B_i=A_{i-1}$。

可以发现 $B_i$ 在两个柿子里都出现了，也就是如果相邻两个数的公约数不为 $1$，为质数且在范围内，那么 $B_i=\gcd(A_i,A_{i-1})$，若不为质数则输出 $-1$，若为 $1$ 跳过即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long gcd(long long x,long long y){//正常的GCD
	long long t = x%y;
	do{
		t = x%y;
		x = y;
		y = t;
		
	}while(t!=0);
	return x;
}
int main(){
	int T;
	cin>>T;
	while(T--){
		bool okay = true;
		long long x = -1,pos = -1;
		long long n,m;
		long long a[100005] = {0};
		long long result[100005] = {0};
		scanf("%lld %lld",&n,&m);
		for(int i = 0;i<n-1;i++)scanf("%lld",&a[i]);
		for(int i = 0;i<n-2;i++){
			x = gcd(a[i],a[i+1]);
			pos = i+1;
			if(x!=1&&a[i]!=a[i+1]){
				break;
			}
		}
		for(int i = 2;i<=sqrt(x);i++){
			if(x%i == 0){
				okay = false;
				break;
			}
		}//若最大公因数本身就不为质数，那么必然无解
		result[pos] = x;
		if(result[pos]>m)okay = false;//不符合条件的情况打个标记，最后一起处理
		for(int i = pos-1;i>=0;i--){
			result[i] = a[i]/result[i+1];
			if(result[i]>m)okay = false;
		}
		for(int i = pos+1;i<n;i++){
			result[i] = a[i-1]/result[i-1];
			if(result[i]>m)okay = false;
		}
		if((!okay)||x == -1){
			cout<<-1<<endl;
			continue;
		}
		for(int i = 0;i<n;i++){
			printf("%d ",result[i]);
		}
		printf("\n");
	}
} 
```
## 总结
对于构造题目，我们似乎可以发现一种共性，就是数据范围会给你一个特殊的情况，而正解也与特殊情况相关，所以没有思路的时候不妨也先写写部分分找找思路

---

## 作者：fervency (赞：2)

~~为了社贡！~~

### 分析

这是一道清新可爱的构造，给出数组 $a_{i}=b_{i}\times b_{i+1}$ 以及 $b_{i}$ 值域，求一组合法的 $b_{i}$。

$a_{i-1}=b_{i-1}\times b_{i}$

$a_{i}=b_{i}\times b_{i+1}$

由于保证 $b_{i-1}$、$b_{i}$、$b_{i+1}$ 是质数，所以相邻的 $a_{i}$ 的最大公约数就是此时的 $b_{i}$。

我认为实际上的重点在于**数据保证**：

- 若不考虑 $b_{i}$ 在值域范围内的条件，必然有至少一组合法解。

- 有至少一对 $(i,j)$，使得 $a_{i}≠a_{j}$。

第一句话告诉我们不用判质数，保证所求 $b_{i}$ 一定是质数，第二句话提醒我们存在 $a_{i}=a_{i+1}$ 的情况，所以我们要提前找出 $a_{i}≠a_{i+1}$ 的位置，再向两侧扩展。

### code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=300010;
int n,T,M,a[N],b[N];
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int gcd(int aa,int bb){return bb?gcd(bb,aa%bb):aa;}
bool check()
{
	int maxx=0,flag;
	for(int i=2;i<n;i++)
	{
		if(a[i]!=a[i-1])
		{
			flag=i;
			break;
		}
	}
	int bb=gcd(a[flag],a[flag-1]);
	b[flag]=bb;
	for(int i=flag-1;i>=1;i--) b[i]=a[i]/b[i+1];
	for(int i=flag;i<n;i++) b[i+1]=a[i]/b[i];
	for(int i=1;i<=n;i++) if(b[i]>M) return 0;
	return 1;
}
signed main()
{
	T=read();while(T--)
	{
		n=read(),M=read();
		for(int i=1;i<n;i++) a[i]=read();
		if(!check()) printf("-1");
		else for(int i=1;i<=n;i++) printf("%lld ",b[i]);
		puts("");
	}
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

首先我们观察数据范围，$a_i\leq 10^{18}$，暴力预处理质数，肯定是不行的，但是由于数据保证了一定有解，因此我们可以这样做：

![](https://cdn.luogu.com.cn/upload/image_hosting/arix8eqh.png)

首先先找到前面一组连续的数，对于该段数的最后一个，和后一个数取 $\operatorname{gcd}$，如例子中，$15$ 和 $35$，将他填进去，其他的数依次带入即可，注意到 $\gcd$ 的复杂度是 $\log$ 级别的，可以通过本题。

**代码：**

```cpp
//By: Luogu@⚡炭治郎⚡(a.k.a. Kamado_Tanjiro)(LuoguID:308854)
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int INF=(sizeof(int)==4?0x3f3f3f3f:0x3f3f3f3f3f3f3f3f);
const int MOD=998244353;
const long double EPS=1e-7;
const int MAXN=100020;

int Orignal[MAXN];
int Secret[MAXN];

void Output(int n,int m);

signed main()
{
	ios::sync_with_stdio(0);
	int T;

	cin>>T;

	while(T--)
	{
		int n,m;

		cin>>n>>m;

		for(int i=1;i<n;i++)
			cin>>Orignal[i];

		int LstPos=-1;

	 	for(int i=2;i<n;i++)
		{
			if(Orignal[i]!=Orignal[i-1])
			{
				LstPos=i;

				break ;
			}
		}

		Secret[LstPos]=__gcd(Orignal[LstPos],Orignal[LstPos-1]);

		for(int i=LstPos-1;i>=1;i--)
			Secret[i]=Orignal[i]/Secret[i+1];

		for(int i=LstPos;i<n;i++)
			Secret[i+1]=Orignal[i]/Secret[i];

		Output(n,m);
	}

	return 0;
}

void Output(int n,int m)
{
	for(int i=1;i<=n;i++)
	{
		if(Secret[i]>m)
		{
			cout<<"-1\n";

			return ;
		}
	}

	for(int i=1;i<=n;i++)
	{
		cout<<Secret[i]<<" ";
	}

	cout<<endl;
}


```

---

## 作者：HGJH°L (赞：1)

蒟蒻第一次写题解，如有不清楚的地方请指出qwq

------------

题目描述：

对于每一组给出 $n-1$ 个数，输出 $n$ 个数，使得第 $i$ 个数乘第 $i+1$ 个数等于原本的第 $i$ 个数。


------------

本题一眼看上去非常难 ~~（至少在我看来是这样）~~ ，因为 $a_i$ 和 $m$ 最大能够达到 $10^{18}$ 这样一个量级。如果我们直接暴力枚举每个数的因数并判断是否为质数的话是绝对会TLE的，所以我们要考虑其他的解决办法。

首先从题目描述中可以看出 $b_{i-1} \times b_i=a_{i-1}$ ，$b_i \times b_{i+1}=a_i$ 。因为 $b_{i-1}$ 和 $b_{i+1}$ 均为质数，所以 $b_i$ 为 $a_{i-1}$ 和 $a_i$ 的最大公约数。

通过观察题目（若不考虑 $b_i$ 在 $\left [1,M \right ]$  范围内的条件，必然有至少一组合法解），我们可以发现，只要确定某两个数（设为 $a_{i-1}$ 和 $a_i$ ）之间的最大公约数（设为 $b_i$ ），就一定能推出来所有数两两之间的最大公约数（  $b$  ），且必定是质数。因为如果 $b_i$ 不为质数，则不可能有合法的解，与题目给出的条件相冲突，因此可得出 $b_i$ 必定为质数。

那么如何从 $b_i$ 推导到其他的数呢？因为 $b_i$ 是 $a_{i-1}$ 的因数之一，所以可以通过 $b_{i-1} \times b_i=a_{i-1}$ 的变形 $b_{i-1}=\dfrac{a_{i-1}}{b_i}$ 得到 $b_{i-1}$ 。同理可根据 $b_{i+1}=\dfrac{a_i}{b_{i+1}}$ 得到 $b_{i+1}$ 。以此类推就可以得到完整的 $b$ 数组了。

但是有一点很关键，就是 $a_{i-1}$ 和 $a_i$ 不能随便选取，因为相邻的两个数可能相同。如果 $a_{i-1}=a_i$ ，那么得出的 $b_i$ 就会是两者自身（也就是一个因数），与题目要求相违背。那么我们该如何选取 $a_{i-1}$ 和 $a_i$ 呢？ 

再仔细观察一下（ $\exists a_i$ ， $a_j$， $a_i$ != $a_j$ ），我们可以得出一个结论，一定有两个相邻的数不同（请读者自证）。因此必定有两个相邻的数具有既不为 $1$ 也不为两者自身的公约数，即上一段中所提到的 $a_{i-1}$ 及 $a_i$ ，而这两个数的最大公约数就是我们最初需要确定的 $b_i$ 。所以只要判断得出的结果 $b$ 是否比 $m$ 大即可。

已加入防抄袭措施，马蜂略丑轻喷qwq

```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF 0x7f7f7f7f
#define rei register int
#define il inline
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))

using namespace std;

int T;//组数
int n,m;
ll a[100005],b[100005];//开两个数组，b数组用来记录两数之间的最大公约数
int tag;//记录两个相邻的不同的数的位置
bool f;//记录是否有公约数比m大

ll gcd(ll x,ll y)//求两个数之间的最大公约数（递归版）
{
	if (x==y)
		return x;
	if (x<y)
		swap(x,y);
	if (x%y==0)
		return y;
	return gcd(y,x%y);
}

signed main()
{

	read(T);
	while (T--)
	{
		read(n,m);
		f=0;//每输入一组数据标记一定要归0！
		for (ri i=1;i<n;i++)//记住a的数量为n-1而不是n
		{
			read(a[i]);
			if (i>1&&a[i]!=a[i-1])//如果相邻的两个数不同
				tag=i;//记录位置
		}
		b[tag]=gcd(a[tag-1],a[tag]);//算出a[tag-1]和a[tag]的最大公约数
		if (b[tag]>m)//如果a[tag-1]和a[tag]的最大公约数比m大
			f=1;
		for (ri i=tag-1;i>=1&&!f;i--)//从tag-1到1进行计算
		{
			b[i]=a[i]/b[i+1];//因为是求因数，所以只需进行除法便可计算出另一个因数
			if (b[i]>m)//如果另一个因数比m大
				f=1;
		}
		for (ri i=tag+1;i<=n&&!f;i++)//从tag+1到n进行运算
		{
			b[i]=a[i-1]/b[i-1];//由于i最后到n，所以要-1
			if (b[i]>m||!Miller_Rabin(b[i])||b[i]*b[i-1]!=a[i-1])//同上
				f=1;
		}
		if (f)//如果有标记（即不符合条件）
			print(-1,'\n');
		else
		{
			for (ri i=1;i<n;i++)
				print(b[i],' ');
			print(b[n],'\n');
		}
	}
	return 0;
}
```
如果有不懂的地方随时欢迎在留言板下留言

---

## 作者：cbyybccbyybc (赞：1)

## 题意
给定一个数列$A$，让你求出一个质数数列$B$，使$B_i\times B_{i+1}=A_i$。



## 思路

我们可以画出一张图
![](https://cdn.luogu.com.cn/upload/image_hosting/20ocosmi.png)
由图我们可以得出：**$b[i]=gcd(a[i-1],a[i]);$** ，同时，题目告诉我们$b[i]\times b[i+1]=a[i]$，因此，我们可以采用递推的方式，通过判断两个相邻的$A_i$确定一个$b[i]$，从而确定整个$B$数组。

然而，这道题数据比较毒瘤，不能从$A_1$开始枚举，因为$A_1$和$A_2$可能相等，所以我们先用$O(n)$的时间枚举$i$，找到一个$A_i$和$A_{i+1}$不同的$i$，之后就用公式进行模拟。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int ans[1000010],a[100010];
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}//快读
inline void write(int X)
{
	if(X<0) {X=~(X-1); putchar('-');}
	if(X>9) write(X/10);
	putchar(X%10+'0');
}//快输
void init()//对于每组数据进行处理
{
	int n,m,c,t;
	n=read(),m=read();
	for(int i=2;i<=n;i++)
		a[i]=read();//读入
	for(int i=2;i<=n-1;i++)
	{
		if(a[i]!=a[i+1])//找到第一个不相等的i
		{
			t=i;
			break;
		}
	}
	int b=__gcd(a[t],a[t+1]),tt=t+1;//用系统gcd确定一个b
	int bb=b;
	ans[t]=b;
	for(int i=t-1;i>=1;i--)
	{
		ans[i]=(a[i+1]/ans[i+1]);//从t-1~1推算
	}
	for(int i=t+1;i<=n;i++)
	{
		ans[i]=(a[i]/ans[i-1]);//从t+1~n推算
	}
	for(int i=1;i<=n;i++)
	{
		if(ans[i]>m||ans[i]<=0)//如果有个不满足情况
		{
			puts("-1");//输出-1
			return ;
		}
	}
	for(int i=1;i<=n;i++)
	{
		write(ans[i]);//快速输出每个答案
		printf(" ");
	}
	printf("\n");
}
signed main()
{
	int t;
	t=read();
	for(int i=1;i<=t;i++)
	{
		init();
	}
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：0)

根据题意，有 $A_{i-1}=B_i\times B_{i-1},A_i=B_i\times B_{i+1}$，当 $A_{i-1}\neq A_i$ 时，因为所有的 $B_i$ 都是质数，所以说这两数的最大公因数就是 $B_i$。而知道其中一个 $B_i$，就能很容易地推出整个密文。题目中有保证有至少一对 $(i,j)$ 使得 $A_i\neq A_j$，其实就是一定有一对相邻的数不相等。所以只要找到其中一对数，问题就迎刃而解了。又因为保证有解，所以也不用再做其他判断了。最后判断 $B$ 中的值满不满足要求就行了。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int T,n,m,a[N],b[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
}
signed main(){
	T=read();
	while(T--){
		n=read();m=read();int pos=0,g=0;
		for(int i=1;i<n;i++)a[i]=read();
		for(int i=1;i<n-1;i++){
			if(a[i]!=a[i+1]){
				pos=i;g=gcd(a[i],a[i+1]);b[i]=g;b[i-1]=a[i]/g;break;
			}
		}//cout<<pos; 
		for(int i=pos-1;i>=1;i--){
			b[i-1]=a[i]/b[i];
		}
		for(int i=pos+1;i<n;i++){
			b[i]=a[i]/b[i-1];
		}
		bool flag=0;
		for(int i=0;i<n;i++){
			if(b[i]>m)flag=1;
		}
		if(!flag){
			for(int i=0;i<n;i++)printf("%lld ",b[i]);
			putchar('\n');
		}
		else puts("-1");
	}
	return 0;
}

```


---

## 作者：XL4453 (赞：0)

### 解题思路：

题目的基本思想很简单，找到每一个位置上的数由哪两个质数的乘积构成，然后按照位置依次顺推就行了。

但是题目中的 $A_i$ 的范围是 $10^{18}$，不能直接使用上面的思路做。

---
此时可以注意到题目中的两个很奇怪的条件：

1. 不考虑 $[1,M]$ 的范围限制一定有解。
2. 至少存在一对 $(i,j)$ 使得 $A_i\neq A_j$。

有了第一个条件，可以发现所有的值都可以写成 $p_x\times p_y$ 的形式，其中 $p$ 表示质数。

而根据第二个条件，可以发现至少有一个位置满足 $A_i\neq A_{i+1}$，这也就意味着 $b_i$ 可以直接用 $\gcd(A_i,A_{i+1})$ 计算出 $b_{i+1}$。

然后结合第一个条件也就能直接用已知值拓展到相邻位置，从而推导出所有的值了。

---
### 代码：

```cpp
#include<cstdio>
using namespace std;
#define int long long
int T,n,m,ans[100005],num[100005],p;
int gcd(int x,int y){
	if(y==0)return x;
	return gcd(y,x%y);
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld",&n,&m);
		for(int i=1;i<n;i++)scanf("%lld",&num[i]);
		for(int i=1;i<n-1;i++){
			if(num[i]!=num[i+1]){
				p=i+1;ans[p]=gcd(num[i],num[i+1]);
				break;
			}
		}
		for(int i=p+1;i<=n;i++)ans[i]=num[i-1]/ans[i-1];
		for(int i=p-1;i>=1;i--)ans[i]=num[i]/ans[i+1];
		bool flag=0;
		for(int i=1;i<=n;i++){
			if(ans[i]>m){
				flag=1;
				break;
			}
		}
		if(flag){
			printf("-1\n");
			continue;
		}
		for(int i=1;i<=n;i++)
		printf("%d ",ans[i]);
		printf("\n");
	}
	return 0;
}
```


---

## 作者：Hexarhy (赞：0)

### Preface

简单构造题，性质很好发现。

### Solution

「数据保证」里的两点有比较大的提示：

1. 必然存在一组解。
1. 至少有相邻的一对 $a_i$ 互不相同。

- 根据第一个条件，我们考虑 $a_i$ 一定能表示为两质数乘积。

言下之意就是她的因子只有这两个质数。

而 $a_i=b_ib_{i+1},a_{i+1}=b_{i+1}b_{i+2}$，也就是说 $\operatorname{gcd}(a_i,a_{i+1})=b_{i+1}$。

这就是一个很重要的性质。我们可以通过这个来推出其它的 $b_i$。

- 第二个条件告诉我们：

如果 $a_i=a_{i+1}$，也就是 $a_i$ 为质数的平方，此时二者的 $\text{gcd}$ 为 $1$，不适用刚才的结论。因此我们需要找到不相同的 $a_i$ 与 $a_{i+1}$，再从这个 $i$ 向前向后推答案。

- 关于无解：

其实就是某个 $b_i>m$。

~~我刚开始做很 sb，推出答案后还验证是不是素数，忘记了第一个条件，白浪费时间和码力。~~

### Code

```cpp
bool solve(void)
{
    int i=1;
    for(i=2;i<n;i++)
        if(a[i]!=a[i-1])
        {
            b[i]=gcd(a[i],a[i-1]);
            break;
        }
    for(int j=i-1;j>=1;j--) b[j]=a[j]/b[j+1];
    for(int j=i+1;j<=n;j++) b[j]=a[j-1]/b[j-1];
    for(int i=1;i<=n;i++)   if(b[i]>m)  return false;
    return true;
}
```

---

## 作者：KadiaNEFU (赞：0)

![](http://a1.qpic.cn/psc?/V13gqYSE2pRb0L/A5hOE6*rc9U8eSRlr1H24j8mSSRRhsmG7zKgNrDvt5vEIeURfK3V2pS.C3JTgCJClMxz7F12BDqrwFcsc26Azw!!/c&ek=1&kp=1&pt=0&bo=tAPJAQAAAAARF18!&tl=3&vuin=2132886896&tm=1589360400&sce=60-2-2&rf=0-0)
观察此图我们发现，B和A存在一种关系：**B是前后两个A的一个公因子**，且B都是质数。但M的范围太大。玩一个素数筛肯定是不现实的。因为题目保证在R内一定存在有一组数列B使数列A成立，我们就先忽略M的限制，以一定存在答案来分析。**A一定是两个质数的乘积，相邻两个A至少有一个质因子相同。我们分为两种情况**

- **相邻的两个A不同**：这种情况下，相邻两个A只可能有一个非1真因子，那么这个B也就是唯一确定的，可以用gcd来得到这个因子。

- **相邻的两个A相同**：这种情况下，两个A的因子有2个非1真因子，此时不能确定对应B应该是哪一个值(此处的B应该由周围的B来确定)，但如果前一个B已经确定，那么这个位置的B也是可以确定的，这样只要确定了一个B，之后的B都是可以确定的。

依据这个思路理一下：**先试图用gcd求每一个B**(从第二个B开始找，因为第一个B可以由第二个B得来)，如果相邻A不同，直接用gcd，如果A相同，判断前一个B是否确定，如果确定就依据前一个B和此处的A来确定此处的B，如果之前的B没有确定，则跳过。**循环一次后我们再从n向1遍历求B**,如果已经有这里的B就跳过，不然就由之前的一个B来得到，之前的B一定是确定的了，这也是为什么我们要倒过来遍历的原因。

**code**
```cpp
#include <bits/stdc++.h>

using namespace std;
long long a[100005];
long long ans[100005];
int main()
{
    int t;
    cin >> t;
    long long n,m;
    while(t--)
    {
        memset(a,0,sizeof(a));
        memset(ans,0,sizeof(ans));
        cin >> n >> m;
        for(int i=1; i<n; i++)
        {
            cin >> a[i];
        }
        int ok=1;
        for(int i=2; i<=n; i++)
        {
            if(i<n&&a[i]!=a[i-1])
                ans[i]=__gcd(a[i],a[i-1]);
            else if(ans[i-1])
                ans[i]=a[i-1]/ans[i-1];
            if(ans[i]>m)
            {
                ok=0;
                goto loop;
            }
        }
        for(int i=n; i>=1; i--)
        {
            if(ans[i])
                continue;
            ans[i]=a[i]/ans[i+1];
            if(ans[i]>m)
            {
                ok=0;
                goto loop;
            }
        }
loop:
        if(!ok)
        {
            cout << "-1" << endl ;
            continue;
        }
        for(int i=1; i<=n; i++)
        {
            if(i==1)
                cout << ans[i] ;
            else
                cout << " " << ans[i];
        }
        cout << endl ;
    }
    return 0;
}
```




---

## 作者：青鸟_Blue_Bird (赞：0)

首先，根据题目中的条件，我们可以十分轻易滴推出一个性质：

b[i] = a[i] / b[i + 1];

知道了无比重要的这一点后，我们接下来要做的，就是如何确定b中的一个数。

发现：题目中保证a数组有两个不同，所以，我们只用找到a数组中第一个不同的点，然后将b数组设为其gcd就好了。（为什么？  注意b数组中都是质数这一点。）

然后，我们从这一点愉快的往两边求就ok啦！

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100010
#define ll long long

inline ll read(){
	ll x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){
		if(c == '-')s = -1;
		c = getchar();
	}
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = getchar();
	}
	return x * s;
} 

ll a[N], ans[N];

ll gcd(ll a, ll b){
	return !b ? a : gcd(b, a % b);
}

int main(){
	ll T = read();
	while(T--){
		ll n = read(), m = read();
		for(int i = 1;i < n; i++) a[i] = read();
		ll now;
		for(int i = 1;i < n; i++){
			if(a[i] != a[i + 1]){  /*找到第一个不相同的*/
				ans[i + 1] = gcd(a[i], a[i + 1]);
				now = i; /*记录下来*/ 
				break;
			}
		}
		for(int i = now;i > 0; i--){
			ans[i] = a[i] / ans[i + 1];  /*往前求*/
		}
		for(int i = now + 1;i <= n; i++){
			ans[i] = a[i - 1] / ans[i - 1];  /*往后求*/
		}
		bool flag = 1;
		for(int i = 1;i <= n;i++){
			if(ans[i] > m){  /*不合要求*/
				flag = 0;
				break;
			}
		}
		if(flag) 
			for(int i = 1;i <= n; i++)
				cout << ans[i] << " ";
		else cout << "-1";
		cout << endl;
	}
	return 0;
}
```
~~(cout赛高！）~~

---

## 作者：Create_Random (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6523)

据说这题赛时都是用Pollard-Rho过的。

~~都没听说过的蒟蒻瑟瑟发抖~~

思路：

分情况讨论。

------------
当 $a_i \ne a_{i+1}$ 时（即 $70\%$ 的数据时）.

可从序列的一端找到两个数的最大公因数。

然后从 $3$ 开始向后处理。

使得 $b_i=\frac{a_{i-1}}{b_{i-1}}$ .

同时判断 $\frac{a_{i-1}}{b_{i-1}}$ 是否可以整除

以及最后的 $b_i$ 是否大于 $m$.

如 $\frac{a_{i-1}}{b_{i-1}}$ 不能被整除，

或有 $b_i$ 大于 $m$ .

就输出 $-1$.

否则将序列输出。

此部分代码：

```cpp
b[2]=gcd(a[1],a[2]);
b[1]=a[1]/b[2];
for(int i=3;i<=n;i++)
{
	if(a[i-1]%b[i-1]!=0)
	{
		cout<<-1<<endl;
		flag=1;
		break;
	}
	b[i]=a[i-1]/b[i-1];
}
if(flag)
{
	continue;
}
for(int i=1;i<=n;i++)
{
	if(b[i]>m)
	{
		cout<<-1<<endl;
		flag=1;
		break;
	}
}
if(flag)
{
	continue;
}
for(int i=1;i<=n;i++)
{
	printf("%lld ",b[i]);
}
cout<<endl;
```
------------
当存在 $a_i=a_{i+1}$ 时，

即可从第一个 $a_i \ne a_{i+1}$ 的位置开始。

求出这个数和下一个数的最小公倍数，

同时分别向前和向后处理。

向前： $b_i=\frac{a_{i+1}}{b_{i+1}}$

向后： $b_i=\frac{a_{i-1}}{b_{i-1}}$

判断 $-1$ 时与第一种情况相同

此部分代码：

```cpp
for(int i=1;i<n;i++)
{
	if(a[i]==a[i+1])
	{
		flag=1;
	}
}
if(flag)
{
	flag=0;
	int cnt;
	for(int i=1;i<n;i++)
	{
		if(a[i]!=a[i+1])
		{
			cnt=i;
			break;
		}
	}
	b[cnt+1]=gcd(a[cnt],a[cnt+1]);
	b[cnt]=a[cnt]/b[cnt+1];
	for(int i=cnt+2;i<=n;i++)
	{
		if(a[i-1]%b[i-1]!=0)
		{
			cout<<-1<<endl;
			flag=1;
			break;
		}
		b[i]=a[i-1]/b[i-1];
	}
	if(flag)
	{
		continue;
	}
	for(int i=cnt-1;i>=1;i--)
	{
		if(a[i+1]%b[i+1]!=0)
		{
			cout<<-1<<endl;
			flag=1;
			break;
		}
		b[i]=a[i+1]/b[i+1];
	}
	if(flag)
	{
		continue;
	}
	for(int i=1;i<=n;i++)
	{
		printf("%lld ",b[i]);
	}
	cout<<endl;
}
```
最后放一下完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,m;
long long a[100010];
long long b[100010];
bool flag;
long long gcd(long long a,long long b)
{
	if(a%b==0)
	{
		return b;
	}
	return gcd(b,a%b);
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		flag=0;
		scanf("%d%lld",&n,&m);
		for(int i=1;i<n;i++)
		{
			scanf("%lld",&a[i]);
		}
		for(int i=1;i<n;i++)
		{
			if(a[i]==a[i+1])
			{
				flag=1;
			}
		}
		if(flag)
		{
			flag=0;
			int cnt;
			for(int i=1;i<n;i++)
			{
				if(a[i]!=a[i+1])
				{
					cnt=i;
					break;
				}
			}
			b[cnt+1]=gcd(a[cnt],a[cnt+1]);
			b[cnt]=a[cnt]/b[cnt+1];
			for(int i=cnt+2;i<=n;i++)
			{
				if(a[i-1]%b[i-1]!=0)
				{
					cout<<-1<<endl;
					flag=1;
					break;
				}
				b[i]=a[i-1]/b[i-1];
			}
			if(flag)
			{
				continue;
			}
			for(int i=cnt-1;i>=1;i--)
			{
				if(a[i+1]%b[i+1]!=0)
				{
					cout<<-1<<endl;
					flag=1;
					break;
				}
				b[i]=a[i+1]/b[i+1];
			}
			if(flag)
			{
				continue;
			}
			for(int i=1;i<=n;i++)
			{
				printf("%lld ",b[i]);
			}
			cout<<endl;
			continue;
		}
		b[2]=gcd(a[1],a[2]);
		b[1]=a[1]/b[2];
		for(int i=3;i<=n;i++)
		{
			if(a[i-1]%b[i-1]!=0)
			{
				cout<<-1<<endl;
				flag=1;
				break;
			}
			b[i]=a[i-1]/b[i-1];
		}
		if(flag)
		{
			continue;
		}
		for(int i=1;i<=n;i++)
		{
			if(b[i]>m)
			{
				cout<<-1<<endl;
				flag=1;
				break;
			}
		}
		if(flag)
		{
			continue;
		}
		for(int i=1;i<=n;i++)
		{
			printf("%lld ",b[i]);
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：infinities (赞：0)

确实如比赛首页所说，是简单构造(作为绿题似乎有一点过了)。

首先发现题面最底下的说明，有这么一句： “有至少一对 $(i,j)$，使得 $a_i \not= a_j$”。

那么这个肯定不是白给的，我们考虑从这个入手，把这个柿子感性理解一下，会发现一定有一组 $a_i \not= a_{i + 1}$。

接着我们找到这个 $i$ 使得 $a_i \not= a_{i + 1}$ 之后，因为题目保证有一组解，所以每一个数一定只能分解为1乘以它本身或者两个质数之乘积，而且每对相邻两个数之间一定有一个质数公因数。

再加上质数的特殊性质，我们可以知道，对 $a_i$ 和 $a_{i + 1}$ 求gcd，得出的结果一定是 可能的解 中的 $b_{i +1}$，然后我们就确定了一个答案，剩下的答案只需要递推一下就出来了。

最后判一下这组解是否有数大于m即可。

Code:
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

int num[102444], b[123232], t, n, m, di;

signed main(){
    
    cin >> t;
    while(t--){
    	int fl = 1, fla = 1;//两个判断
        cin >> n >> m;
        --n;//这里--n是因为刚开始看错题了，懒得改所以补救一下
        cin >> num[1];
        for(int i = 2; i <= n; i++){
            cin >> num[i]; 
        
            if(num[i] != num[i - 1] && fla){di = i - 1, fla = 0;}//找到第一组相邻且不相等的数
        }
        
        b[di + 1] = __gcd(num[di], num[di + 1]); //求一下gcd
        ++di;
        
        for(int i = di + 1; i <= n + 1; i++)b[i] = num[i - 1] / b[i - 1];
		for(int i = di - 1; i >= 1; i--)b[i] = num[i] / b[i + 1];//递推
		
		for(int i = 1; i <= n + 1; i++)
		    if(b[i] > m && fl){puts("-1"); fl = 0;}
		if(!fl)continue;//判一下无解
		
		for(int i = 1; i <= n + 1; i++)cout << b[i] << " ";
		cout << "\n";
    }
}

```

---

## 作者：bifanwen (赞：0)

[CSDN同步](https://blog.csdn.net/bifanwen/article/details/105930020)

[博客园同步](https://www.cnblogs.com/bifanwen/p/12830030.html)

[洛谷博客同步](https://www.luogu.com.cn/blog/bfw/solution-p6523)

[原题链接](https://www.luogu.com.cn/problem/P6523)

简要题意：

给定一个数列 $a_1 , a_2 \cdots a_{n-1}$，求 **任意一个满足以下条件的长度为 $n$ 的质数数列 $\text{ans}$：**

$$\text{ans}_i \times \text{ans}_{i+1} = a_i$$

本题是某洛谷公开赛 $T1$，有一定思维难度。

### 前记

本人 $193ms$ 的代码截止 $\text{2020.5.5 12:00}$ 排名第一，效率最高。 ~~如果不开火车头优化就屈居第三了~~ （实际上估计也 **不太** 会有人能超过它了，除非是变态卡常）

下面的 $m$ 指的是：

$$m = \max_{i=1}^n a_i$$

并且，**各算法对应的数据范围没有下限是因为不存在特殊情况**，特此说明。

### 算法一

> 对于 $20 \%$ 的数据，$n \leq 5$，$m \leq 10$.

显然我们可以发现，如果确定了 $p_1$，就可以递推出整个数列。

由于 $p_1$ 只受到 $a_1$ 的限制（即 $p_1 | a_1$），所以我们枚举 $a_1$ 的 **质因子** 作为 $p_1$，然后递推判断即可。

时间复杂度：$O(Tn \sqrt{m})$

解释：$T$ 组数据，每组数据枚举因数是 $O(\sqrt{m})$ 的时间，递推是 $O(n)$ 的时间，而判断素数我们可以打表（反正 $20$ 以内的素数也不多），$O(1)$ 判断即可。

实际得分：$20pts$ ~ $40pts$.（下面会有说明）

[Link 代码](https://paste.ubuntu.com/p/Qjp8KTspD8/)

注：上述代码并没有预处理素数表。（实际上浪费 $\sqrt{M}$ 的时间也不会有什么问题）

### 算法二

> 对于 $40 \%$ 的数据，$m \leq 10^{12}$.

这个部分分没什么用，是用来给选手乱搞的。

出题人的官方题解中说：

![](https://s1.ax1x.com/2020/05/05/YiCbz8.png)

（看得不太清楚可以放大看）

实际上这样理论上是无法通过 $n \leq 10^5$ , $T \leq 5 $, $m \leq  10^{12}$ 这样庞大的数据。

简单计算一下：

你可以欧拉筛出 $\sqrt{m} = 10^6$ 以内的素数表，共 $78498$ 个，估算为 $8 \times 10^4$ 个。

你在这 $8 \times 10^4$ 个中枚举因数，然后 $O(n)$ 验证。

时间复杂度：$O(Tn \times 8 \times 10^4)$.

简单估计：$O(5 \times 10^5 \times 8 \times 10^4 = 40 \times 10^9 = 4 \times 10^{10})$.

**所以理论上，如果跑满时间复杂度是根本无法通过的，也无法分析该程序具体的常数是多少。**

可能出题人的数据有点弱，导致每次 $O(n)$ 根本跑不满，枚举到半路就被剪枝了吧。

所以按照算法一的思路，卡一卡常数就可以得到 $40pts$.

时间复杂度：$O(Tn \sqrt{m})$.

实际得分：$20pts$ ~ $40pts$.

### 算法三

> 对于 $70 \%$ 的数据，$a_i \not = a_{i+1}$.

暂时我们想不出，$a_i \not = a_{i+1}$ 有什么性质。

那么先把得到的 $n-1$ 个方程组列出来吧：

$$ \begin{cases}
p_1 \times p_2 = a_1 \\
p_2 \times p_3 = a_2 \\ \\
\vdots \\
p_{n-1} \times p_n = a_{n-1} \\
\end{cases}
$$

只看前两个方程，我们可以得到的是：

$$p_2 | \gcd(a_1 , a_2)$$

同理，我们可以得到：

$$p_x | \gcd(a_{x-1} , a_x) (1 < x < n)$$

然而，因为 **题目保证没有上限的限制就有解**，所以，$\gcd(a_{x-1} , a_x)$ 只存在一个质因子。

只存在一个质因子，又 $\because a_i \not = a_{i-1} (1 < i < n)$ ，$\therefore p_i = \gcd(a_{i-1},a_i) (1 < i < n)$.

我们不需要算那么多个 $\gcd$，只需要算出 $p_2$，就可以递推得到整个序列！

时间复杂度：$O(Tn \log m)$.（只保证 $70 \%$ 的数据答案正确，不保证 $100 \%$ 的数据答案都正确）

实际得分：$70pts$.

### 算法四

> 对于 $100 \%$ 的数据，$T \leq 5$，$n \leq 10^5$，$m \leq 10^{18}$.

可以发现，$O(Tn \log m)$ 完全可以通过本题，但是，对于 $a_i = a_{i+1}$ 的情况，$\gcd(a_{i-1} , a_i) = a_i$，根本没有起到一点点降低时间的可能。

但是，我们只需要 **求出一个 $p_i$ 就可以得到整个序列**，注意到题目保证：

> 至少存在一组 $(i,j)$，使得 $a_i \not = a_j$.

这说明整个序列 **不完全一样**，也就是说 **至少存在一组 $a_i \not = a_{i+1}$.**

那么，我们只需要找到这个位置，求出 $p_i$，然后往两边递推就可以得到答案。

时间复杂度：$O(Tn \log m)$.（保证答案正确）

实际得分：$100pts$.

[Link 代码](https://paste.ubuntu.com/p/x7nxzY9Ctv/)

---


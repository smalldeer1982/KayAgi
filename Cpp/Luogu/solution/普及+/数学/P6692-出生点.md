# 出生点

## 题目背景

小 L、小 W 和小 H 在一起van♂游戏。

~~由于小 L 太菜了所以导致他一直在看着小 W 和小 H 打游戏。~~

## 题目描述

这款游戏的地图可以抽象成一张有 $n$ 行 $m$ 列的网格图，网格图上有 $k$ 个障碍点，相邻两点间边长为 $1$。游戏开始时~~小 L~~、小 W 和小 H 会**各自**随机出生在一个点。当然，他们**不会出生在障碍点**。

~~经常开局死的~~小 L 看着小 W 和小 H 每次在地图上汇合时经过的路径，很想知道他们每次出生后两个人之间的期望距离。（这里的距离指两点间[曼哈顿距离](https://www.luogu.com.cn/blog/xuxing/Distance-Algorithm)，即 $\left|x_1-x_2\right|+\left|y_1-y_2\right|$）

由于小 L 可以非常容易算出有多少种出生点安排方案，所以你实际上**只需要告诉他所有情况中他们两人距离之和**。

**注意**：小 W 出生在点 $A$，小 H 出生在点 $B$，跟小 W 出生在点 $B$，小 H 出生在点 $A$，这两种情况**视作同一种情况**。

## 说明/提示

对于样例一，地图样式如下（其中蓝点为障碍点，红点为可能的出生点）：  
![](https://cdn.luogu.com.cn/upload/image_hosting/3bq78rx7.png)

+ 出生点为 $(1,1)$ 和 $(1,1)$，距离为 $0$。
+ 出生点为 $(1,1)$ 和 $(1,2)$，距离为 $1$。
+ 出生点为 $(1,1)$ 和 $(1,3)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(2,2)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(2,3)$，距离为 $3$。
+ 出生点为 $(1,1)$ 和 $(3,1)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(3,2)$，距离为 $3$。
+ 出生点为 $(1,2)$ 和 $(1,2)$，距离为 $0$。
+ 出生点为 $(1,2)$ 和 $(1,3)$，距离为 $1$。
+ 出生点为 $(1,2)$ 和 $(2,2)$，距离为 $1$。
+ 出生点为 $(1,2)$ 和 $(2,3)$，距离为 $2$。
+ 出生点为 $(1,2)$ 和 $(3,1)$，距离为 $3$。
+ 出生点为 $(1,2)$ 和 $(3,2)$，距离为 $2$。
+ 出生点为 $(1,3)$ 和 $(1,3)$，距离为 $0$。
+ 出生点为 $(1,3)$ 和 $(2,2)$，距离为 $2$。
+ 出生点为 $(1,3)$ 和 $(2,3)$，距离为 $1$。
+ 出生点为 $(1,3)$ 和 $(3,1)$，距离为 $4$。
+ 出生点为 $(1,3)$ 和 $(3,2)$，距离为 $3$。
+ 出生点为 $(2,2)$ 和 $(2,2)$，距离为 $0$。
+ 出生点为 $(2,2)$ 和 $(2,3)$，距离为 $1$。
+ 出生点为 $(2,2)$ 和 $(3,1)$，距离为 $2$。
+ 出生点为 $(2,2)$ 和 $(3,2)$，距离为 $1$。
+ 出生点为 $(2,3)$ 和 $(2,3)$，距离为 $0$。
+ 出生点为 $(2,3)$ 和 $(3,1)$，距离为 $3$。
+ 出生点为 $(2,3)$ 和 $(3,2)$，距离为 $2$。
+ 出生点为 $(3,1)$ 和 $(3,1)$，距离为 $0$。
+ 出生点为 $(3,1)$ 和 $(3,2)$，距离为 $1$。
+ 出生点为 $(3,2)$ 和 $(3,2)$，距离为 $0$。

总和为 $42$。

### 数据范围

**本题采用捆绑测试。**

+ Subtask 1( $10\%$ )：$n,m\leq 80$。
+ Subtask 2( $20\%$ )：$n,m\leq 5000$。
+ Subtask 3( $15\%$ )：$k=0$。
+ Subtask 4( $15\%$ )：$m=1$。
+ Subtask 5( $40\%$ )：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 10^9,1\leq x_i\leq n,1\leq y_i\leq m,0\leq k\leq 5\times 10^5,k<n\times m$，**保证所有障碍点各不相同**。

## 样例 #1

### 输入

```
3 3 2
2 1
3 3
```

### 输出

```
42```

## 样例 #2

### 输入

```
9 8 8
3 2
4 6
7 3
9 5
3 7
2 2
1 6
6 4
```

### 输出

```
11552```

# 题解

## 作者：littleKtian (赞：10)

考虑容斥。

于是只要求 $m^2\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}(j-i)+n^2\sum\limits_{i=1}^{m-1}\sum\limits_{j=i+1}^{m}(j-i)-\sum\limits_{i=1}^k\sum\limits_{x=1}^{n}\sum\limits_{y=1}^{m}(\left|x_i-x\right|+\left|y_i-y\right|)+\sum\limits_{i=1}^{k-1}\sum\limits_{j=i+1}^{k}(\left|x_i-x_j\right|+\left|y_i-y_j\right|)$ 即可。

~~md怎么这么复杂。~~

考虑将上面式子分成三部分。

+ $m^2\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}(j-i)+n^2\sum\limits_{i=1}^{m-1}\sum\limits_{j=i+1}^{m}(j-i)$

上面式子是将行与列的贡献分开来单独计算的。

考虑改变枚举顺序，变成先枚举 $j-i$。

$\begin{aligned}m^2\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}(j-i)+n^2\sum\limits_{i=1}^{m-1}\sum\limits_{j=i+1}^{m}(j-i)&=m^2\sum\limits_{i=1}^{n-1}i\times(n-i)+n^2\sum\limits_{i=1}^{m-1}i\times(m-i)\\&=m^2n\sum\limits_{i=1}^{n-1}i-m^2\sum\limits_{i=1}^{n-1}i^2+n^2m\sum\limits_{i=1}^{m-1}i-n^2\sum\limits_{i=1}^{m-1}i^2\end{aligned}$

$\sum i$ 跟 $\sum i^2$ 可以直接代公式 $O(1)$ 求出。

（如果你不知道的话我可以告诉你 $\sum\limits_{i=1}^{n}i=\dfrac{n(n+1)}{2},\sum\limits_{i=1}^{n}i^2=\dfrac{n(n+1)(2n+1)}{6}$）

~~当然如果你想式子好看一些可以将上面的 $\sum\limits_{i=1}^{n-1}$ 和 $\sum\limits_{i=1}^{m-1}$ 都换成$\sum\limits_{i=1}^{n}$ 和 $\sum\limits_{i=1}^{m}$，反正都会被消掉对答案无影响。~~

+ $\sum\limits_{i=1}^k\sum\limits_{x=1}^{n}\sum\limits_{y=1}^{m}(\left|x_i-x\right|+\left|y_i-y\right|)$

同样我们将行与列的贡献分开来计算。

$\begin{aligned}\sum\limits_{i=1}^k\sum\limits_{x=1}^{n}\sum\limits_{y=1}^{m}(\left|x_i-x\right|+\left|y_i-y\right|)&=\sum\limits_{i=1}^{k}(m\sum\limits_{x=1}^{n}\left|x_i-x\right|+n\sum\limits_{x=1}^{m}\left|y_i-y\right|)\\&=\sum\limits_{i=1}^{k}(m\sum\limits_{x=1}^{x_i-1}(x_i-x)+m\sum\limits_{x=x_i+1}^{n}(x-x_i)+n\sum\limits_{y=1}^{y_i-1}(y_i-y)+n\sum\limits_{y=y_i+1}^{m}(y-y_i))\end{aligned}$

同样直接 $\sum i$ 公式代进去即可。

+ $\sum\limits_{i=1}^{k-1}\sum\limits_{j=i+1}^{k}(\left|x_i-x_j\right|+\left|y_i-y_j\right|)$

依然将行与列的贡献分开来计算。

$\sum\limits_{i=1}^{k-1}\sum\limits_{j=i+1}^{k}(\left|x_i-x_j\right|+\left|y_i-y_j\right|)=\sum\limits_{i=1}^{k-1}\sum\limits_{j=i+1}^{k}\left|x_i-x_j\right|+\sum\limits_{i=1}^{k-1}\sum\limits_{j=i+1}^{k}\left|y_i-y_j\right|$

考虑求 $\sum\limits_{i=1}^{k-1}\sum\limits_{j=i+1}^{k}\left|x_i-x_j\right|$。

将所有障碍点按 $x_i$ 从小到大排序。

$\sum\limits_{i=1}^{k-1}\sum\limits_{j=i+1}^{k}\left|x_i-x_j\right|=\sum\limits_{i=2}^{k}\sum\limits_{j=1}^{i-1}(x_i-x_j)$

（注意两条式子的枚举顺序）

设 $f[k]=\sum\limits_{i=1}^{k-1}(x_k-x_i),f[1]=0$。

容易发现 $f[k+1]=f[k]+k\times(x_{k+1}-x_k)$。

而 $\sum\limits_{i=1}^{k}f[i]$ 就是我们要求的，按顺序直接扫一遍即可。

$\sum\limits_{i=1}^{k-1}\sum\limits_{j=i+1}^{k}\left|y_i-y_j\right|$ 用同样的方式解决即可。

复杂度 $O(k\log k)$。

（上面式子化到不同的程度就对应相应的部分分了）

---

## 作者：ynxynx (赞：5)

为了写这道题我调了两个小时，结果发现等差数列忘记除以二，这道题细节太多了。

---
### 进入正题

大家都说的很明白了，这道题用容斥，分为三步。

#### 第一步

先不考虑障碍，直接算出每对点的 **曼哈顿距离**。

由于 $x$ 坐标和 $y$ 坐标是对称的，我们只分析 $x$ 坐标。

一共有 $m$ 组 $\lbrace 1,2, \cdots ,n-1,n\rbrace$ ，对于每个  $|x_i-x_j|$，直接将它看作一组，最后乘 $m^2$ 就可以了，原因一楼说的很明白了。

$ \quad s_{0x} $ （一部分）


$=\frac{1}{2}\big(|n-1|+|n-2|+\cdots+|n-n|+|(n-1)-(n-1)|+\cdots+|1-1|\big)$ （这里要去重，避免逆元浪费时间）

$=\frac{1}{2}\big(n\times(n-1)+(n-1)\times(n-2)+\cdots+2\times1\big)$ 

直接用小奥知识整数裂项，懂得跳过。

$\quad\frac{1}{2}\big(n\times(n-1)+(n-1)\times(n-2)+\cdots+2\times1\big)$ 

$=\frac{1}{6}\big((n+1)\times n\times (n-1)-(n-2)\times n\times (n-1)+\cdots + 3\times2\times1-2\times1\times0\big)$

$=\frac{1}{6}(n+1)\times(n-1)\times n$

所以

$s_1=s_x+s_y=\frac{1}{6}m^2\times(n+1)\times(n-1)\times n+\frac{1}{6}n^2\times(m+1)\times(m-1)\times m$

#### 第二步

对于每个障碍，减去其和其他节点的距离和。
假设第 $i$ 个障碍的节点为 $(x_i,y_i)$。

$\quad s_2 $

$= \sum \bigg(m\times \Big(|x_i-1|+\cdots+|x_i-n|\Big)+n\times\Big( |x_i-1|+\cdots+|x_i-m|\Big) \bigg)$

$=\sum\bigg( m\times\Big(\frac{x_i\times(x_i-1)}{2}+\frac{(n-x_i+1)\times(n-x_i)}{2}\Big)+n\times\Big(\frac{x_i\times(x_i-1)}{2}+\frac{(m-x_i+1)\times(m-x_i)}{2}\Big) \bigg)$

#### 第三步

加上每对障碍的曼哈顿距离，直接排序然后手算。

假设排序后 $x_1\leqslant x_2 \leqslant \cdots \leqslant x_k$。



$s_3=\sum \big(\sum_{1\leqslant i\leqslant j\leqslant k}^{}|x_i-x_j|\big)=\sum\big(\sum_{i=1}^{k} x_i\times(i\times2-k-1\big)$


最后 $ans=s1-s2+s3$，做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=500005,mod=1e9+7;
struct node{
	long long x,y;
}p[N];
long long n,m,k;
long long s1,s2,s3,dx[N],dy[N];
long long Pow(long long a,int b){//快速幂 
	long long ans=1;
	for (;b;b>>=1){
		if (b&1) ans=ans*a%mod;
		a=a*a%mod;
	}
	return ans;
}
long long NY(long long a,long long b){//逆元 
	return a*Pow(b,mod-2)%mod;
} 
signed main(){
	scanf("%lld %lld %lld",&n,&m,&k);
	for (int i=1;i<=k;i++){
		scanf("%lld %lld",&p[i].x,&p[i].y);
	}
	s1=NY(n*n%mod*m%mod*(m-1)%mod*(m+1)%mod,6)+NY(m*m%mod*n%mod*(n-1)%mod*(n+1)%mod,6);
	for (int i=1;i<=k;i++) {
		long long x=p[i].x,y=p[i].y,w;
		dx[i]=x,dy[i]=y;
		w=m*((x*(x-1)/2%mod+(n-x)*(n-x+1)/2%mod)%mod)%mod+n*((y*(y-1)/2%mod+(m-y)*(m-y+1)/2%mod)%mod)%mod;//我之前就是忘记除以2了
		s2+=w;
	}
	sort(dx+1,dx+k+1);
	sort(dy+1,dy+k+1);
	for (int i=k;i;i--){
		s3=((s3+dx[i]*(2*i-k-1)%mod)%mod+mod)%mod;
		s3=((s3+dy[i]*(2*i-k-1)%mod)%mod+mod)%mod;
	}
	long long h=((s1-s2+s3)%mod+mod)%mod;
	printf("%lld",h);
	return 0;
}
```

撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。

---

## 作者：lndjy (赞：3)

出题人的式子已经推的很详细了，就是一个容斥，我这里就不说了。

我来提供一个代码，完全按照出题人的式子写的，码风可读，有注释，分成3部分对应3个式子。供大家对着查错。

注意一个点，$n,m\le 10^9$ ，也就是说出题人式子中的 $n^2m$ 就会爆`long long`，于是我~~偷懒~~用了`__int128`.

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define int __int128
using namespace std;
const int p=1e9+7;
int inline read()
{
	int ans=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*f;
}
int n,m,k,ans;
struct point
{
	int x,y;
}a[500005];
int f[500005],g[500005]; 
bool cmpx(point aa,point b)
{
	return aa.x<b.x;
}
bool cmpy(point aa,point b)
{
	return aa.y<b.y;
}
int sum(int n)//求1-n的和 
{
	if(n%2==0) return (n/2*(n+1))%p;
	else return ((n+1)/2*n)%p;
}
int sqr(int n)//求1-n的平方和 
{
	if(n%2==0) return (n/2*(n+1)*(2*n+1)/3)%p;
	else return ((n+1)/2*n*(2*n+1)/3)%p;
}
signed main()
{
	n=read();m=read();k=read();
	for(int i=1;i<=k;i++)
	a[i].x=read(),a[i].y=read();
	//第一个式子 
	ans=ans+((m*m*n)%p)*sum(n-1);
	ans%=p;
	ans=ans-((m*m)%p)*sqr(n-1);
	ans=((ans%p)+p)%p;
	ans=ans+((m*n*n)%p)*sum(m-1);
	ans%=p;
	ans=ans-((n*n)%p)*sqr(m-1);
	ans=((ans%p)+p)%p;
	//第二个式子，注意是减
	for(int i=1;i<=k;i++)
	{
		ans-=(m*sum(a[i].x-1))%p+(m*sum(n-a[i].x))%p;
		ans=((ans%p)+p)%p;
		ans-=(n*sum(a[i].y-1))%p+(n*sum(m-a[i].y))%p;
		ans=((ans%p)+p)%p;
	 } 
	 //第三个式子
	sort(a+1,a+k+1,cmpx);
	for(int i=2;i<=k;i++)
	{
		f[i]=f[i-1]+((i-1)*(a[i].x-a[i-1].x))%p;
		f[i]%=p;
		ans=ans+f[i];
		ans%=p;
	}
	sort(a+1,a+k+1,cmpy);
	for(int i=2;i<=k;i++)
	{
		g[i]=g[i-1]+((i-1)*(a[i].y-a[i-1].y))%p;
		g[i]%=p;
		ans=ans+g[i];
		ans%=p;		
	}
	long long an=ans%p;
	cout<<an;
	return 0;
}
```


---

## 作者：lzy20091001 (赞：1)

[洛谷 P6692 出生点](https://www.luogu.com.cn/problem/P6692)

## 题意简述

$n$ 行 $m$ 列构成 $mn$ 个格点，在其中指定 $k$ 个障碍点。每行、每列之间的距离为 $1$，每次任意选取两个非障碍点，计算这两个点的曼哈顿距离，求所有选法的距离之和。

## 分析

由容斥原理，答案为「任意两点之间的距离之和」$-$「每个障碍点到其他所有点的距离之和」$+$「任意两障碍点之间的距离之和」。下面分别考虑这三部分怎么求。

### 前置知识

$$
\sum _ {i = 1} ^ n i = \frac{n (n + 1)}{2} \\
\sum _ {i = 1} ^ n i ^ 2 = \frac{n (n + 1) (2n + 1)}{6}
$$

两式可以用数学归纳法证明。

### 任意两点之间的距离之和

显然行和列是等价的，下面考虑行之间的距离，即纵坐标对答案的贡献。

$$
i \ \overbrace{\circ \circ \cdots \circ \circ} ^ m \\
\cdots \\
j \circ \circ \cdots \circ \circ
$$

如图，我们任意选取两行，不妨设为第 $i$ 行和第 $j$ 行（$1 \le i < j \le n$）。在第 $i$ 行和第 $j$ 行各任选 $1$ 个点，由乘法原理知共有 $m ^ 2$ 种选法。显然这两点纵坐标的差为 $j - i$。所以，第 $i$ 行和第 $j$ 行的纵坐标对答案的贡献为 $m ^ 2 \cdot (j - i)$。

枚举 $i, j$，我们得到纵坐标对答案的贡献为：

$$
\sum _ {i = 1} ^ {n - 1} \sum _ {j = i + 1} ^ {n} [m ^ 2 (j - i)]
$$

考虑化简：

$$
\begin{aligned}
    \sum _ {i = 1} ^ {n - 1} \sum _ {j = i + 1} ^ n [m ^ 2 (j - i)] & = m ^ 2 \sum _ {i = 1} ^ {n - 1} \sum _ {j = i + 1} ^ n (j - i) \\
                                                                    & = m ^ 2 \sum _ {i = 1} ^ {n - 1} \sum _ {j = 1} ^ {n - i} j \\
                                                                    & = m ^ 2
                                                                        \begin{pmatrix}
                                                                            \begin{aligned}
                                                                                  & 1 + 2 + \cdots + (n - 2) + (n - 1) \\
                                                                                + & 1 + 2 + \cdots + (n - 2) \\
                                                                                + & \cdots  \\
                                                                                + & 1 + 2 \\
                                                                                + & 1
                                                                            \end{aligned}
                                                                        \end{pmatrix} \\
                                                                    & = m ^ 2 \sum _ {i = 1} ^ {n - 1} [i \cdot (n - i)] \\
                                                                    & = m ^ 2 \sum _ {i = 1} ^ {n - 1} [i n - i ^ 2] \\
                                                                    & = m ^ 2 n \sum _ {i = 1} ^ {n - 1} i - m ^ 2 \sum _ {i = 1} ^ {n - 1} i ^ 2
\end{aligned}
$$

这样化简的好处是可以直接套用两个公式，时间复杂度 $O(1)$ 。

横坐标同理。综上，「任意两点之间的距离之和」为

$$
m ^ 2 n \sum _ {i = 1} ^ {n - 1} i - m ^ 2 \sum _ {i = 1} ^ {n - 1} i ^ 2 + n ^ 2 m \sum _ {i = 1} ^ {m - 1} i - n ^ 2 \sum _ {i = 1} ^ {m - 1} i ^ 2
$$

### 每个障碍点到其他所有点的距离之和

直接枚举每个障碍点，显然 $\sum _ {i = 1} ^ k \sum _ {x = 1} ^ n \sum _ {y = 1} ^ m (|x _ i - x| + |y _ i - y|)$ 即为所求。

类似地，考虑化简：

$$
\begin{aligned}
    \sum _ {i = 1} ^ k \sum _ {x = 1} ^ n \sum _ {y = 1} ^ m (|x _ i - x| + |y _ i - y|) & = \sum _ {i = 1} ^ k (\sum _ {x = 1} ^ n \sum _ {y = 1} ^ m |x _ i - x| + \sum _ {x = 1} ^ n \sum _ {y = 1} ^ m |y _ i - y|) \\
                                                                                         & = \sum _ {i = 1} ^ k (m \sum _ {x = 1} ^ n |x _ i - x| + n \sum _ {y = 1} ^ m |y _ i - y|) \\
                                                                                         & = \sum _ {i = 1} ^ k [m \sum _ {x = 1} ^ {x _ i - 1} (x _ i - x) + m \sum _ {x = x _ i + 1} ^ {n} (x - x _ i) + n \sum _ {y = 1} ^ {y _ i - 1} (y _ i - y) + n \sum _ {y = y _ i + 1} ^ m (y - y _ i)] \\
                                                                                         & = \sum _ {i = 1} ^ k (m \sum _ {x = 1} ^ {x _ i - 1} x + m \sum _ {x = 1} ^ {n - x _ i} x + n \sum _ {y = 1} ^ {y _ i - 1} y + n \sum _ {y = 1} ^ {m - y _ i} y)
\end{aligned}
$$

时间复杂度 $O(k)$。

### 任意两障碍点之间的距离之和

将 $x$ 从小到大排序。设 $f _ i = \sum _ {j = 1} ^ {i - 1} (x _ i - x _ j)$。特别地，$f _ 1 = 0$。则显然 $\sum _ {i = 1} ^ k f _ i$ 即为所求。

有递推式 $f _ i = f _ {i - 1} + (i - 1) \cdot (x _ i - x _ {i - 1})$。

证明：

$$
\begin{aligned}
    f _ i & = \sum _ {j = 1} ^ {i - 1} (x _ i - x _ j) \\
          & = \sum _ {j = 1} ^ {i - 2} (x _ i - x _ j) + x _ i - x _ {i - 1} \\
          & = \sum _ {j = 1} ^ {i - 2} [(x _ i - x _ {i - 1}) + (x _ {i - 1} - x _ j)] + x _ i - x _ {i - 1} \\
          & = \sum _ {j = 1} ^ {i - 2} (x _ i - x _ {i - 1}) + f _ {i - 1} + x _ i - x _ {i - 1} \\
          & = f _ {i - 1} + (i - 1) \cdot (x _ i - x _ {i - 1})
\end{aligned}
$$

因此递推 $f$ 的同时累加答案即可，$y$ 同理。

时间复杂度 $O(k \log k)$。

## 代码

```cpp
#include <iostream>
#include <algorithm>

const int MOD = 1e9 + 7;

int x[500005], y[500005];

int sum1(int n) // 公式 1
{
    return 1ll * n * (n + 1) / 2 % MOD;
}

int sum2(int n) // 公式 2
{
    // 注意被 6 整除的问题
    // n * (n + 1) 一定被 2 整除, 因此只需讨论 n, (n + 1), (2 * n + 1) 中哪个因式被 3 整除
    if (n % 3 == 1) // 此时 (2 * n + 1) 被 3 整除
        return 1ll * n * (n + 1) / 2 % MOD * (2 * n + 1) / 3 % MOD;
    return 1ll * n * (n + 1) / 6 % MOD * (2 * n + 1) % MOD; // 否则 n 和 (n + 1) 一定有一个被 3 整除
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int n, m, k;
    long long f, ans = 0;

    std::cin >> n >> m >> k;
    for (int i = 1; i <= k; i++)
        std::cin >> x[i] >> y[i];

    // 任意两点之间的距离之和
    ans += 1ll * m * m % MOD * n % MOD * sum1(n - 1) % MOD;
    ans -= 1ll * m * m % MOD * sum2(n - 1) % MOD;
    ans += 1ll * n * n % MOD * m % MOD * sum1(m - 1) % MOD;
    ans -= 1ll * n * n % MOD * sum2(m - 1) % MOD;
    ans = (ans % MOD + MOD) % MOD; // 取模时注意负数

    // 每个障碍点到其他所有点的距离之和
    for (int i = 1; i <= k; i++)
    {
        ans -= 1ll * m * sum1(x[i] - 1) % MOD;
        ans -= 1ll * m * sum1(n - x[i]) % MOD;
        ans -= 1ll * n * sum1(y[i] - 1) % MOD;
        ans -= 1ll * n * sum1(m - y[i]) % MOD;
        ans = (ans % MOD + MOD) % MOD; // 取模时注意负数
    }

    // 任意两障碍点之间的距离之和
    f = 0;
    std::sort(x + 1, x + k + 1);
    for (int i = 2; i <= k; i++)
    {
        f += 1ll * (i - 1) * (x[i] - x[i - 1]) % MOD;
        f %= MOD;
        ans += f;
        ans %= MOD;
    }
    f = 0;
    std::sort(y + 1, y + k + 1);
    for (int i = 2; i <= k; i++)
    {
        f += 1ll * (i - 1) * (y[i] - y[i - 1]) % MOD;
        f %= MOD;
        ans += f;
        ans %= MOD;
    }

    std::cout << ans << "\n";

    return 0;
}
```

---


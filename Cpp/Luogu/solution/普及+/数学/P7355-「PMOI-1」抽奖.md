# 「PMOI-1」抽奖

## 题目描述

活动奖池中共有 $n$ 种道具，dead_X 有 $m$ 张兑奖券。一张兑奖券可以兑换成一次抽奖机会或 $114514$ 金币。

dead_X 决定将一部分兑奖券拿来抽奖，并将剩下的兑奖券兑换成金币。

在一次抽奖机会中，dead_X 会等概率得到所有奖池中一款道具的 $1919810$ 秒**体验卡**。

由于 dead_X 在活动中买了 VIP 卡，他可以在所有抽奖结束后选择一款**抽奖得到**的体验卡，将所有这种类型的体验卡上交，并得到对应种类的**永久道具**。

注意，dead_X 可以不使用这个功能，但是不可以使用多于一次。

有选择困难症的 dead_X 想知道，有多少种可能的**活动结果**。

两种活动结果不同，当且仅当 dead_X 获得的金币不同，或者在任何一次抽奖中获得的体验卡不同（即抽到体验卡形成的序列不同），或者获得的永久道具不同。

注意，抽奖中获得的都是体验卡，最后选择的永久道具和体验卡在哪一次抽出没有关系。

------------

Update 2023.11.16：出题人看自己好几年前写的题面绷不住了，补一份形式化题面。

定义一个序列的权值是其不同元素个数 $+1$，例如 $[1,9,2,6,8,1,7]$ 的权值是 $7$。

对于所有长度 $\in[0,m]$，每个数 $\in [1,n]$ 的整数序列，求其权值和对 $10^9+7$ 取模的值。

## 说明/提示

【样例解释】

以下为第二组测试数据所有可能的方案：

假设两种物品分别为 $A$ 和 $B$。

1. 兑换 $229028$ 金币。
1. 兑换 $114514$ 金币，获得 $A$ 体验卡。
1. 兑换 $114514$ 金币，获得 $B$ 体验卡。
1. 兑换 $114514$ 金币，获得 $A$ 永久道具。
1. 兑换 $114514$ 金币，获得 $B$ 永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $A$ 体验卡。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡。
1. 第一次获得 $B$ 体验卡，第二次获得 $B$ 体验卡。
1. 第一次获得 $A$ 体验卡，第二次获得 $A$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡，指定 $B$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡，指定 $B$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $B$ 体验卡，指定 $B$ 为永久道具。

【数据范围】
- Subtask1（10pts）：$n,m\leq5,T\le25$；
- Subtask2（10pts）：$n=1$；
- Subtask3（10pts）：$m=1$；
- Subtask4（20pts）：$n,m\leq1000,T\leq 5$；
- Subtask5（20pts）：$\sum m\leq10^6$；
- Subtask6（30pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1\le n,m\leq 10^9$，$1\le T\leq 10^5$。

## 样例 #1

### 输入

```
5
2 1
2 2
3 3
114 514
1919810 7872754```

### 输出

```
5
15
115
338602801
30498159```

# 题解

## 作者：wwlw (赞：5)

令 $F(t)$ 表示抽了 $t$ 张体验卡的情况数。
那么答案就是 $\sum_{t=0}^n F(t)$，那我们只需求出所有 $F(t)$ 
如果考虑先抽 $t$ 张卡，再看有多少种卡可以选话，这样实际上是很难知道哪些种类的卡已经抽到。所以转换思路，考虑先选定卡再抽，这样就能保证选的卡一定是抽到了的。
$$F(t)=m^t+m\sum_{i=1}^t \binom{t}{i} (m-1)^{t-i}$$
组合意义即为，不选的情况数——每张卡都能随便抽，加上选卡的情况数——卡的种类 $\times$ 枚举抽到了多少选的卡的那个种类的卡 $\times$ 这些卡是在哪几次抽到的 $\times$ 剩下的随便抽
容易发现这个式子可以化简
$$F(t)=m^t+m(-t^{m-1}+\sum_{i=0}^t \binom{t}{i} (m-1)^{t-i} 1^i)=m^t+m(-(m-1)^t+m^t)$$
所以答案就是
$$\sum_{t=0}^n F(t)=\sum_{t=0}^n m^t+\sum_{t=0}^n m^{t+1}-m\sum_{t=0}^n (m-1)^t$$
容易发现就是三个等比数列，随便求一下和即可。

```cpp
#include<stdio.h>
#define ll long long
#define N 100007
#define Mod 1000000007

inline int read(){
	int x=0,flag=1; char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') flag=0;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	return flag? x:-x;
}

ll qpow(ll x,ll y){
	ll ret=1,cnt=0;
	while(y>=(1LL<<cnt)){
		if(y&(1LL<<cnt)) ret=(ret*x)%Mod;
		x=(x*x)%Mod,cnt++;
	}
	return ret;
}

ll calc(ll x,ll y){
	if(!x) return 1;
	if(x==1) return (y+1)%Mod;
	return (qpow(x,y+1)-1+Mod)%Mod*qpow((x-1+Mod)%Mod,Mod-2)%Mod;
}

int main(){
	int T=read();
	while(T--){
		ll n=read(),m=read();
		ll ans=(calc(n,m)+calc(n,m+1)-1-n*calc(n-1,m)%Mod+Mod)%Mod;
		printf("%lld\n",ans);
	}
}
```

---

## 作者：dead_X (赞：2)

## 谢罪
有人提出题面过于复杂而实际思路十分简单的问题，出题人在这里谢罪/kk
## 形式化题面
定义一个序列的权值为不同元素个数 $+1$，求所有每个数 $\in[1,m]$，长度 $\leq n$ 的序列的权值和。
## 题解
我们先算出长度固定为 $k$ 的情况的答案。

注意到我们构造序列可以分两步。

第一步是确定一个的序列，第二步是计算序列的权值。

我们不妨把两步分开做。

第一步的序列个数不难求出是 $n^k$。

对于第二步，我们考虑求所有序列权值的平均值，即**期望出现不同数的个数**。

显然每个数在序列中出现的概率是相同的，等于 $1$ 减去每一次抽奖都没有抽到的概率，即 $1-(\frac{n-1}{n})^k$。

于是我们全部乘起来，得到答案为 $n^k\times(n\times(1-(\frac{n-1}{n})^k))+1)=n^{k+1}+n^k-n\times(n-1)^k$。

然后我们发现我们还要求 $k=0,1,2,\cdots,m$ 的答案，其实这步并不难，我们发现可以直接等比数列求和。

注意到 $n,k$ 很小的时候算概率和等比数列求和可能会出一些问题，因此需要一些小特判。
## 代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+(ch&15),ch=getchar();
    return x;
}
const int p=1000000007;
int qp(int x,int y)
{
    int res=1;
    for(int now=x; y; now=now*now%p,y>>=1) (y&1)&&(res=res*now%p);
    return res;
}
signed main()
{
    for(int T=read();T--;)
    {
        int n=read(),m=read();
        if(n==1) printf("%lld\n",((m<<1)+1)%p);
        else if(n==2) printf("%lld\n",((qp(n,m+1)+qp(n,m+2)+p-1-n)%p*qp(n-1,p-2)%p+p-n*(m+1)%p)%p);
        else printf("%lld\n",((qp(n,m+1)+qp(n,m+2)+p-1-n)%p*qp(n-1,p-2)%p+p-n*(qp(n-1,m+1)+p-1)%p*qp(n-2,p-2)%p)%p);
    }
    return 0;
}
```

---

## 作者：123456Mm (赞：1)

本题是一道有意思的数学题

我们考虑用 $k$  张奖券 $(0\leq k\leq m)$

当 $k=0$ 时，显然有1种方案

于是我们设总方案数为 $tot$

$tot=\sum\limits_{k=1}^mcnt(k)+1$

现在问题就变成了求 $cnt(k)$

对于每一个 $k$ ,都可以选择不兑换永久道具，这样有 $n^k$ 种方式

如果兑换永久道具，我们可以考虑兑换第 $i$ 种道具，那么在不考虑能否取到的情况下有 $n^k$ 种情况，但显然，其中有 $(n-1)^k$ 种情况中不包含第 $i$ 种道具，应与排除

故 $cnt(i)=n^k+n\times(n^k-(n-1)^k)=n^k+n^{k+1}-n\times(n-1)^k$

对于60分，我们可以枚举 $k$ ,注意取模和最后答案要加1

对于100分，可以发现 $cnt(i)$ 的每一项均为等比数列，可以公式计算，注意要特判，不能求0或-1的逆元

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;
int T;
long long n,m;
long long ans=1;
long long quickpow(long long a,long long b){
	if(b==0)return 1;
	if(b%2==1){
		return a*quickpow(a,b-1)%mod;
	}
	else {
		long long mul=quickpow(a,b/2);
		return mul*mul%mod;
	}
}//快速幂 
long long inv(long long n){
	return quickpow(n,mod-2)%mod;
}//逆元 
int main(){
	cin>>T;
	//小心inv(0) inv(-1) 
	while(T--){
		scanf("%lld%lld",&n,&m);
		ans=1;
		long long tmp;
		if(n==1)tmp=2*m%mod;
		else {
			tmp=quickpow(n,m+1)%mod;
			tmp+=mod;
			tmp-=n;
			tmp%=mod;
			tmp*=inv(n-1);
			tmp%=mod;
			tmp*=(n+1);
			tmp%=mod;
		}
		ans=(ans+tmp)%mod;
		tmp=0;
		if(n==2){
			tmp=n*m%mod;
		}
		
		if(n!=1&&n!=2){
			tmp=quickpow(n-1,m+1)%mod;
			tmp+=mod;
			tmp-=(n-1);
			tmp*=inv(n-2);
			tmp%=mod;
			tmp*=n;
			tmp%=mod;
		}
		ans=(ans+mod-tmp)%mod;
		cout<<ans<<endl;
	}
}
```


---


# 「PMOI-2」参天大树

## 题目描述

b6e0 有一棵参天大树。这棵二叉有根树有无数多个节点。它的根节点的编号为 $1$，对于每一个 $x(x\ge1)$，编号为 $x$ 的节点有编号为 $2x$ 和 $2x+1$ 的子节点。

你需要在编号小于等于 $n$ 的节点中，选出两个**可以相同**的节点，求出所有情况中它们的最近公共祖先的编号的和。也就是求（其中 $\operatorname{LCA}(i,j)$ 表示 $i$ 与 $j$ 的最近公共祖先的编号）：
$$\sum_{i=1}^n\sum_{j=1}^n \operatorname{LCA}(i,j)$$
保证存在一个自然数 $k$，满足 $n=2^k-1$。

**答案对 $998244353$ 取模。**

## 说明/提示

【样例解释】

对于第一次询问，$n=2^2-1=3$，答案为 $1+1+1+1+2+1+1+1+3=12$。

【数据范围】

**本题采用捆绑测试。**

- Subtask1（20pts）：$k\le8$；
- Subtask2（20pts）：$t,k\le300$；
- Subtask3（20pts）：$k\le10^4$；
- Subtask4（40pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le t,k\le10^6$。

## 样例 #1

### 输入

```
2
2
3```

### 输出

```
12
88```

# 题解

## 作者：ezuyz (赞：8)

### 考虑递推
设 $f[k]$为层数为 $k$ 时的贡献， $siz$ 为上一次树的大小，即这次左子树或右子树的大小。

可以发现，随着层数的加 $1$ 至 $k$ 层，所在同一层的节点产生的贡献与左右位置无关而只与其深度有关（因为整棵树为满二叉树，所以同层的任何两个节点的位置**结构相同**，成为 $LCA$ 的次数也相同），因此，我们可以通过交换节点将新的满二叉树的两颗子树看作原来的 $k-1$ 层的树编号扩大了 $2$ 倍和扩大了 $2$ 倍再加 $1$，因此左子树产生的贡献为 $f[k-1]$ 的二倍，右子树产生的贡献为 $f[k-1]$ 的二倍再加上 $LCA$ 在右子树上的情况总数，即总共有 $f[k-1]*2+siz*siz$ 点贡献，这样 $LCA$ 在两颗子树上的情况（即 $i$ 和 $j$ 都同在一颗子树上）就解决了，我们考虑 $i$,$j$ 在不同的子树上和在根节点的情况，而因为以下情况产生的贡献都为 $1$，因此贡献数就等于情况数。

- 当 $i$ 和 $j$ 分别在两颗不同子树上时，一共有 $siz*siz*2$ 种情况（ $i$,$j$ 的值可互换，因此要乘 $2$）。
- 当 $i$ 和 $j$ 其中一个为根节点时，共有 $siz*2*2$ 种情况（两颗子树大小共为 $siz*2$，$i$,$j$ 的值可互换再乘 $2$）。
- 当 $i$ 和 $j$ 都为根节点时，有一种情况。

因此总递推式为：

$$f[i]=f[i-1]*2+f[i-1]*2+siz*siz+siz*siz*2+siz*2*2+1$$

### code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll mod=998244353;
ll f[1000006];
int main()
{
	f[1]=1;
	ll siz=1;
	for(int i=2;i<=1000000;i++)
	{
		f[i]=((f[i-1]<<2)+((siz*siz)<<1)+siz*siz+(siz<<2)+1)%mod;
		siz=((siz<<1)+1)%mod;
	}
	int T;
	cin>>T;
	ll k;
	while(T--)
	{
		scanf("%lld",&k);
		printf("%lld\n",f[k]);
	}
}
```


---

## 作者：b6e0_ (赞：8)

## 官方题解。

**谢罪：本题时限原来应该是 200ms，但是赛前不知道被谁改了没发现，所以放了在循环内快速幂的方法过。赛后时限已经调小。**

这棵树只有前 $n$ 个节点有用。下面将前 $n$ 个节点直接称呼为“这棵树”。

可以发现这棵树一定是满二叉树，$k$ 即为为树的深度。

考虑贡献，对每一个节点计算它是多少对节点的 LCA，可以发现是（左子树节点个数+1）乘（右子树节点个数+1）-1。设当前是第 $x$ 层（根节点在第一层），则：
1. 这层有 $2^{x-1}$ 个节点；
2. 这层的第一个节点的编号是 $2^{x-1}$，最后一个节点是 $2^x-1$；
3. 这层的每一个节点的左子树和右子树都有 $2^{k-x}-1$ 个节点。

这样，答案就是：
$$\sum_{i=1}^k2^{i-2}(2^{i-1}+2^i-1)[2(2^{k-i})^2-1]$$
将括号拆开，用等比数列求和继续推：
$$\begin{aligned}&\,\quad\sum_{i=1}^k2^{i-2}(2^{i-1}+2^i-1)[2(2^{k-i})^2-1]\\&=\sum_{i=1}^k(2^{2i-3}+2^{2i-2}-2^{i-2})(2^{2k-2i+1}-1)\\&=\sum_{i=1}^k2^{2k-2}-2^{2i-3}+2^{2k-1}-2^{2i-2}-2^{2k-i-1}+2^{i-2}\\&=k\cdot2^{2k-2}+k\cdot2^{2k-1}-\dfrac{2^{2k}-1}6-\dfrac{2^{2k}-1}3-2^{2k-1}+2^{k-1}+\dfrac{2^k-1}2\end{aligned}$$
这个式子继续推下去可以得到 $(3k-4)2^{2k-2}+2^k$，但是原来的式子就可以算了，复杂度不变，这里就不写过程了。用这个更简单的式子的程序最慢的点跑了不到 100ms，所以这题时限开 200ms 没问题。

此处在循环内快速幂能过，但我的原意不是这样。

预处理 $2$ 的次幂和 $2,3,6$ 的逆元，在每次询问时把答案存下来，如果是已经查询过的就直接输出。时间复杂度 $\mathcal O(k+t)$。代码：
```cpp
#include<bits/stdc++.h>
using namepace std;
const int mod=998244353;
long long fac[2000010],ans[1000010];
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x;
}
inline void write(int x)
{
	if(!x)
	{
		putchar('0');
		putchar('\n');
		return;
	}
	int sta[10],tp=0;
	while(x)
	{
		sta[++tp]=x%10;
		x/=10;
	}
	while(tp)
		putchar(sta[tp--]+'0');
	putchar('\n');
}
int main()
{
	int t=read(),k,i;
	long long ny2=499122177,ny3=332748118,ny6=166374059;//提前算出来的逆元
	memset(ans,-1,sizeof ans);
	fac[0]=1;
	for(i=1;i<2000001;i++)
		fac[i]=fac[i-1]*2%mod;
	while(t--)
	{
		k=read();
		if(ans[k]==-1)//如果没算过
			ans[k]=(k*fac[2*k-2]%mod+k*fac[2*k-1]%mod-(fac[2*k]-1+mod)*ny6%mod+mod-(fac[2*k]-1+mod)*ny3%mod+mod-fac[2*k-1]+mod+fac[k-1]+(fac[k]-1+mod)*ny2%mod)%mod;//按照式子算
		write(ans[k]);
	}
	return 0;
}
```

---

## 作者：pigstd (赞：6)

下文中不妨令 $1$ 号点的高度为 $1$，显然我们有：高度为 $i$ 的节点是 $\displaystyle 2^{i-1}$ 到 $\displaystyle 2^i-1$，共有 $\displaystyle 2^{i-1}$ 个，和为 $\displaystyle \frac {(2^{i-1}+2^{i}-1)\times2^{i-1}}{2}$。

设 $f_i$ 表示 $LCA$ 高度为 $i$ 的方案数，显然，高度为 $i$ 的每个节点为 $LCA$ 的几率是相同的，方案是都是 $\displaystyle \frac {f_i}{2^{i-1}}$，所以答案为 $\displaystyle \sum_{i=1}^k  \frac {f_i}{2^{i-1}} \times \frac {(2^{i-1}+2^{i}-1)\times2^{i-1}}{2}=\frac 1 2 \sum_{i=1}^k  f_i \times(2^{i-1}+2^i-1)$。

然而直接求 $f_i$ 并不简单，考虑差分。设 $g_i$ 表示 LCA 高度 $\ge i$ 的方案数，那么显然 $f_i=g_i-g_{i+1}$。

在 $\displaystyle 2^{i-1}$ 个节点中，每个节点 $p$ 有 $\displaystyle 2^{k-i+1}-1$ 节点以 $p$ 为祖先（包括自身），这 $\displaystyle 2^{k-i+1}-1$ 个节点中，任意两个节点的 $LCA$ 都 $\ge i$，因此每个节点对 $g_i$ 的贡献为 $\displaystyle (2^{k-i+1}-1)^2$，那么便不难得到 $\displaystyle g_i=2^{i-1}\times (2^{k-i+1}-1)^2$，那么便可化简 $\displaystyle f_i=g_i-g_{i+1}=2^{i-1}\times (2^{k-i+1}-1)^2-2^{i}\times (2^{k-i}-1)^2=2^{2\times k-i}-2^{i-1}$。

于是就可以得到 $\displaystyle ans=\frac 1 2 \sum_{i=1}^k (2^{2\times k-i}-2^{i-1}) \times (2^{i-1}+2^i-1)$。可以拿到 $40$ 分，~~显然这是不够的。~~ 我们需要继续化简。

$\displaystyle ans=\frac 1 2 \sum_{i=1}^k (2^{2\times k-i}-2^{i-1}) \times (2^{i-1}+2^i-1)=\frac 1 2 \sum_{i=1}^k(2^{2\times k-1}+2^{2 \times k}-2^{2\times k-i}-2^{2\times i-2}-2^{2\times i-1}+2^{i-1})=\frac 1 2 (k \times (2^{2\times k-1}+2^{2 \times k})-\sum_{i=k}^{2\times k-1}2^i-\sum_{i=0}^{2\times k-1}2^i+\sum_{i=0}^{k-1}2^i)$。

然后等比数列求和即可~~实际上直接算个前缀和就可以了，不过还是再推一下比较好。~~

$\displaystyle \frac 1 2 (k \times (2^{2\times k-1}+2^{2 \times k})-\sum_{i=k}^{2\times k-1}2^i-\sum_{i=0}^{2\times k-1}2^i+\sum_{i=0}^{k-1}2^i)= \frac 1 2 (k \times (2^{2\times k-1}+2^{2 \times k})-2^{2\times k}+2^k-2^{2\times k}+1+2^k-1)=\frac 1 2(k \times (2^{2\times k-1}+2^{2 \times k})+2^{k+1}-2^{2\times k+1})=k\times (2^{2\times k-2}+2^{2\times k-1})+2^k+2^{2\times k}$。

预处理 $2$ 的次方然后便可 $O(1)$ 得到答案，注意要处理到 $2\times 10^6$。

code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int Mod=998244353;
const int M=2e6+10;
int T,pow2[M];

inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}

void init()
{
	pow2[0]=1;
	for (int i=1;i<=2e6;i++)
		pow2[i]=pow2[i-1]*2%Mod;
}

signed main()
{
	T=read();init();
	while(T--)
	{
		int k=read();int ans=k*(pow2[k*2-2]+pow2[k*2-1])%Mod-pow2[2*k]+pow2[k];
		ans%=Mod,ans+=Mod,ans%=Mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：LCGUO (赞：5)

我们考虑每个点对答案的贡献是多少。

对于一个点 $x$，它被加为他的左子树大小乘上他右子树的大小。

因为顺序可以交换，所以最后答案要乘二，又因为 $\operatorname{LCA}(x,x)$ 被算了两次，所以要减一。

即 $2^{k-i}\times2^{k-i}\times2-1=2^{2k-2i+1}-1$。

而每一层的点，他被计算的次数是一定的，所以我们可以一层一层考虑。

设 $f(i)$ 表示第 $i$ 层的编号和，$g(i)$ 表示当前总层数为 $k$ 时，第 $i$ 层的点被计算了几次。

$f(i)=\dfrac{2^i\times (2^i-1)}{2}-\dfrac{2^{i-1}\times (2^{i-1}-1)}{2}$

$g(i)=2^{2k-2i+1}-1$

所以答案为 $\sum_{i=1}^kf(i)\times g(i)$ 。

化简这个式子

$=\large{\sum_{i=1}^kf(i)\times2^{2k-2i+1}-\sum_{i=1}^k f(i)}$

$\large{=\sum_{i=1}^kf(i)\times2^{2k-2i}\times2-\dfrac{2^k\times (2^k-1)}{2}}$

设 $x=\dfrac{2^k\times (2^k-1)}{2}$

$\large{=\sum_{i=1}^k 2\times\left(\dfrac{2^i\times (2^i-1)}{2}-\dfrac{2^{i-1}\times (2^{i-1}-1)}{2}\right)\times2^{2k-2i}-x}$

$\large{=\sum_{i=1}^k2^{2k-2i}\times(2^{2i}- 2^i)-\sum_{i=1}^k2^{2k-2i}\times (2^{2i-2}-2^{i-1})}-x$

$\large{=\sum_{i=1}^k2^{2k}-\sum_{i=1}^k2^{2k-i}-\sum_{i=1}^k2^{2k-2}+\sum_{i=1}^k 2^{2k-i-1}-x}$

$\large{=k\times2^{2k}-k\times \dfrac{2^{2k}}{4}-\sum_{i=1}^k(2^{2k-i}-2^{2k-i-1})-x}$

$\large{=\dfrac{3}{4}\times k \times2^{2k}+2^{k-1}-2^{2k-1}-\dfrac{2^k\times (2^k-1)}{2}}$

$\large{=\dfrac{3}{4}\times k\times2^{2k}+2^{k-1}-2^{2k-1}-(2^{2k-1}-2^{k-1})}$

$\large{=\dfrac{3}{4}\times k\times2^{2k}+2^{k}-2^{2k}}$

$\large{=\left(\dfrac{3}{4}k\times2^k+1-2^k\right)\times2^k}$

代码如下

```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
inline int read(){
    int f=1,s=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=0;c=getchar();}
    while(c>='0'&&c<='9')s=(s<<1)+(s<<3)+c-'0',c=getchar();
    return f?s:-s;
}
const int Mod=998244353,N=2e6+10,inv2=499122177,inv4=748683265;
int T,k,p[N];
int main(){
    T=read(); p[0]=1;
    for(rint i=1;i<=1000000;++i) p[i]=1ll*p[i-1]*2%Mod;//预处理2的次幂
    while(T--){
        k=read();
        printf("%lld\n",1ll*(1ll*3*inv4%Mod*k%Mod*p[k]%Mod+1-p[k]+Mod)%Mod*p[k]%Mod);
    }
    return 0;
}
```

时间复杂度预处理 $O(k)$，查询 $O(1)$。

---

## 作者：Imy_bisLy (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7419?contestId=41187)

### 写的前面
- $\text{mod}$ 后出现减法算法不加 $\text{mod}$ 出现负数修了半天我是sb。
- 在预处理递推过程中会出现负下标，就会出现一些很奇怪的错误，还有就 $2^0 = 1$
其实负下标在我这里没太大的影响，就是会造成$1$的精度缺失，因为两个$\frac{1}{2}$我都没加上。
- 注释里其实是有彩蛋的，自己感觉自己写的很对，但一直过不去，就 $\text{rand()}$了一下，中间出现了负数，如果一直调不出来可以看一看
### solution
![](https://img.imgdb.cn/item/604376bd360785be54b79cf3.jpg)
1. 以三层的图为例，题目显然给出的是一颗完全二叉树
然后枚举以哪个点为$\text{LCA}$进行统计答案，以这个思路开始,考虑这个点的贡献。
2. 发现一号点的贡献是$1$号点的(左儿子数 + 1) $\times$ 右儿子数,左儿子 + 1意义是它加上它自己的贡献
然后每层依次递推，最终会得出这样一个式子。

$$\sum\limits_{ i = 1}^{k}\left[\left( 2^{k - 2\times i + 3} - 1 \right) \times\left(\frac{\left(2^{i - 1} + 2^{i} -1\right) \times 2^{i - 1}}{2}\right)\right]$$
然后就是很裸的解式子的问题了，我们可以不这个式子做到$O(n)$

下面的推导有部分跳步

首先不考虑 $\sum$ , 而且看着分数很难受，$\frac{1}{2}$ 可以删掉，把$2^{i-1}$乘进去
$$\sum\limits_{ i = 1}^{k}\left[\left( 2^{k - 2\times i + 3} - 1 \right) \times\left(2^{2i - 2} + 2^{2i - 1} -2^{i-1}\right)\right]$$
然后分配率处理

$$\sum\limits_{i = 1}^{k}\left( 2^{k-2} + 2^{k-1} - 2^{k-i-1}-2^{2i-3}-2^{2i-2}+2^{i-2}\right)$$

然后发现里面出现常量了，有的地方可以把$\sum$给提出来，最后可以得到一个这样的式子

$$k \times \left( 2^{2k - 2} + 2^{2k-1}\right) - \sum\limits_{i=1} ^{k}2^{k-i-1} - \sum\limits_{i=1}^{k}2^{2i-3} - \sum\limits_{i=1}^{k}2^{2i-2} + \sum\limits_{i=1}^{k} 2^{i-2}$$

显然可以预处理出 $2^?$幂以及 $2^{2i-3}$ 还有$2^{2i-2}$以及 $2$的幂的前缀和

$\sum\limits_{i=1}^{k}2^{2k-i-1}$这一块就是由$2$的幂的前缀和得到的，可以化为$\text{sum}_{2k-2}-\text{sum}_{k-2}$

$\text{sum}$表示2的幂的前缀和

然后我们就可以做到$O(n)$的预处理，$O(1)$的查询，总的复杂度为$O(n + T)$

### code
```cpp
/*
Author:Imy_isLy
知识点: 树形结构 前缀和
*/
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <string>
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e6+100 * 2;
const int M = 1e6;
const int inf = 2147483647;
const int mod = 998244353;
//=============================================================
int n, k;
int POW[N], sum[N], sum2i_3[N], sum2i_2[N];

//=============================================================
int read() {
  int s = 0 , f = 0 ; char ch = getchar() ;
  while(!isdigit(ch)) f |= (ch == '-') , ch = getchar();
  while(isdigit(ch)) s = s * 10 + (ch ^ 48) , ch = getchar();
  return f ? -s : s;
}
void pre() {
  POW[0] = 1;
  int pp = 1;
  for (int i = 1 ; i <= (M << pp); ++i) {
    POW[i] = (POW[i - 1] << pp) % mod;
    sum[i] = (sum[i - 1] + POW[i] ) % mod;
  }
  for (int i = 1 ; i <= (M << pp); ++i) {
    if(2 * i - 3 >= 0)
    sum2i_3[i] = (sum2i_3[i - 1] + POW[2 * i - 3]) % mod; 
    if(2 * i - 2 >= 0) 
    sum2i_2[i] = (sum2i_2[i - 1] + POW[2 * i - 2]) % mod;
  }
  return ;
}
signed main() {
//  freopen("1.in","r",stdin);
//  freopen("2.out","w",stdout);
//	srand(time(0));
//  int T = rand() % M; 
	int T = read();
  pre();
  while(T--) {
    k = read();
    if(k == 0) {
      puts("0"); continue;
    }
    if(k == 1) {
      puts("1");continue;
    }
    int ans  = 
    ( ( ( ( k * (POW[ 2 * k - 2] + POW[2 * k - 1] ) % mod) % mod
    - (sum[2 * k - 2] % mod - sum[k - 2] % mod + mod ) % mod + mod ) % mod 
    + (-sum2i_3[k] % mod - sum2i_2[k] % mod + mod) % mod 
    + sum[k - 2] % mod ) + mod ) % mod;
    cout << (ans + 1ll) % mod <<"\n";
  }
//  system("pause");
  return 0;
}
```

---

## 作者：jdsb (赞：3)

## 题意

>有一颗以 $1$ 为根的无限大的满二叉树，每个 $x(x \ge 1)$ 都有两个子节点，编号分别为 $2x$  和 $2x+1$ ，求 $\sum\limits_{i=1}^n \sum\limits_{j=1}^n LCA(i,j) $ ，满足 $ \exists k,n=2^k-1$ 。

## 分析

- 首先看题目里 $n$ 的限制，$ \exists k,n=2^k-1$，可以知道这是一颗满二叉树，这样我们的计算就比较好处理了。

- 先考虑计算当总层数为 $k$ 时，第 $i$ 层的结点会对答案贡献多少次，因为同一层的结点的形态是一样的，所以贡献次数也是一样的，不信邪的同学可以打个表看看。不放设第 $i$ 层的结点的贡献次数为 $num_i$ 。则 $num_i=2^{2k-2i+1}-1$。式子很简单，考虑怎么得到的，上张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qd3ghml4.png)

- 不放设第 $i$ 层的某个结点为 $x$ ，则 $x$ 的子树大小为 $2^{k-i+1}-1$ ，对于它的左子树以及 $x$ 结点本身有 $2^{k-i}$ 个结点（橙色部分） ，这 $2^{k-i}$ 个结点中的任意一个结点，和右子树以及 $x$ 结点本身的 $2^{k-i}$ 个结点（紫色部分） 的任意一个结点的 $LCA$ 都是 $x$ ，并且也只有这些结点的 $LCA$ 为 $x$ ，然后因为结点标号可以交换算两次，所以就是 $2^{k-i}\times2^{k-i}\times2=2^{2k-2i+1}$，还要减一是因为 $(x,x)$ 这对被算了两次。

- 第 $i$ 层的贡献次数以及算出来了，那么第 $i$ 层的总贡献就是次数乘上权值，设第 $i$ 层的权值为 $val_i$，则有 $val_i=2^{2i-2}+2^{2i-3}-2^{i-2}$ ，比较简单，直接用等差数列算，$\dfrac{(2^{i-1}+2^i-1)\times2^{i-1}}{2}$ ，化简可得上式。

- 下面直接列式子：
  $$
  \begin{aligned}
  ans
  &=\sum_{i=1}^k num_i\times val_i\\
  &=\sum_{i=1}^k (2^{2k-2i+1}-1)\times(2^{2i-2}+2^{2i-3}-2^{i-2})\\
  \end{aligned}
  $$

- 不妨设 $A_i=2^{2i-2}+2^{2i-3}-2^{i-2}$ ，则有：
  $$
  \begin{aligned}
  ans
  &=\sum_{i=1}^k A_i\times(2^{2k-2i+1}-1)\\
  &=\sum_{i=1}^k \left( A_i\times2^{2k-2i+1} \right) -\sum_{i=1}^k A_i\\
  \end{aligned}
  $$
  

- 设左边的式子为 $f(k)$，右边的式子为 $g(k)$ ，则有
  $$
  \begin{aligned}
  f(k+1)
  &=\sum_{i=1}^{k+1}\left( A_i\times2^{2k-2i+3} \right)\\
  &=\sum_{i=1}^{k} \left( A_i\times2^{2k-2i+3} \right) +A_{k+1}\times2^{2k-2(k+1)+3}\\
  &=4\sum_{i=1}^{k} \left( A_i\times2^{2k-2i+1} \right) +2A_{k+1}\\
  &=4f(k)+2A_{k+1}
  \end{aligned}
  $$
  

- $g(k)$ 直接推就行了，然后 $O(\max k)$ 预处理出所有 $f$ 和 $g$ 数组，就可以 $O(1)$ 处理每个询问了。

## 代码

- 比赛时的代码，~~为了卡常用了些恶臭的取模优化~~ ，有点丑，大家看看就好。

```cpp
#include<bits/stdc++.h>
#define fre(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout)
#define ll long long
using namespace std;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') { if(c=='-') f=-1;c=getchar(); }
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^'0'),c=getchar();
	return x*f;
}
const int mod=998244353,N=4e6+5,M=1e6;
inline int inc(int x,int y) { x+=y-mod; return x+(x>>31&mod); }
inline int del(int x,int y) { x-=y; return x+(x>>31&mod); }
inline int mul(int x,int y) { return 1ll*x*y%mod; }
inline void Inc(int &x,int y) { x=inc(x,y); }
inline void Del(int &x,int y) { x=del(x,y); }
inline void Mul(int &x,int y) { x=mul(x,y); }
int p[N],f[N],g[N],a[N];
inline int A(int x) { return del(inc(p[2*x-2],p[2*x-3]),p[x-2]); }
int main(){
	int q=read();
	int mx=0;
	for(int i=1;i<=q;i++) a[i]=read(),mx=max(mx,a[i]);
	p[0]=1;
	for(int i=1;i<=mx<<1;i++) p[i]=inc(p[i-1],p[i-1]);
	f[1]=2,g[1]=1;
	for(int i=2;i<=mx;i++) f[i]=inc(mul(f[i-1],4),mul(A(i),2));
	for(int i=2;i<=mx;i++) g[i]=inc(g[i-1],A(i));
	for(int i=1;i<=q;i++) printf("%d\n",del(f[a[i]],g[a[i]]));
	return 0;
}
```



---

## 作者：Suzt_ilymtics (赞：3)

Update：规范了标点和描述。

## Description

> $T$ 组数据，每次给定一个深度为 $k$ 的满二叉树，对于任意一个 $x$ 点，它的左右儿子编号分别为 $2 \times x,\ 2 \times x + 1$  求 
> $$\sum_{i = 1}^{n}\sum_{j = 1}^{n} \text{LCA}(i, j)$$

## Solution

看数据范围和题目给的优美的满二叉树可以猜到这是道规律题。

发现如果真的按照那个式子去枚举 $i,j$，一组数据都跑不完。

而且这个式子看起来不是很好化简。

不如让我们换一种思路，**枚举每一个结点，看看有多少点对会对其造成贡献，即多少点对的LCA是这个结点**。

结合图来理解会比较好，先来个 $k = 3$ 时的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zlht5pbs.png)

不难发现，当枚举到 $1$ 号结点时：

$1$ 号结点的左子树内的每个元素加上它本身 和 右子树内的每个元素加上它本身 配对的时候，他们的LCA都为 $1$ 号结点。

那么，左边 $4$ 个结点与右边 $4$ 个结点配对，交换先后位置还能进行配对，注意 $(1, 1)$ 交换后还是 $(1, 1)$，所以共有 $2 \times 4 \times 4 - 1$ 对结点，统计贡献时乘以该节点的编号即可。

貌似没什么规律？

让我们设该节点的深度为 $i$，那么以该节点为LCA的点对有 $2 \times 2^{k - i} \times 2^{k - i} - 1$ 个。

好，每个节点的贡献可以 $O(1)$ 求了，那总的复杂度还是 $O(T2^{k})$ 啊。

看来还需要优化，

发现每一层的有贡献的点对数是一定的，并且每一层的元素都是连续的，首项为 $2^{i - 1}$，尾项为 $2^{i} - 1$的数列，可以用小学高斯用的方法直接求出，那么第 $i$ 层的贡献为：

$$(2^{2k - 2i + 1 } - 1) \times \frac{(2^{i - 1} + 2^i - 1) \times 2^{i-  1}}{2}$$

总的贡献为 ~~就多个西格玛还要写两行~~： 

$$\large\sum_{i = 1}^{k} ((2^{2k - 2i + 1 } - 1) \times \frac{(2^{i - 1} + 2^i - 1) \times 2^{i-  1}}{2})$$


扔个演算过程：

$$\large\sum_{i = 1}^{k} (2^{2k - 2i + 1} - 1) \times \frac{2^{2i - 2} + 2^{2 i - 1} - 2^{i-  1}}{2}$$


$$\large\sum_{i = 1}^{k} (2^{2k - 2i + 1} - 1) \times (2^{2i - 3} + 2^{2i - 2} - 2^{i-  2})$$

$$\large\sum_{i = 1}^{k} (2^{2k - 2i + 1} - 1) \times (2^{2i - 3} + 2^{2i - 2} - 2^{i-  2})$$

$$k \times (2^{2k-2} + 2^{2k-1})  - \sum_{i = 1}^{k} 2^{2k-i-1} - \sum_{i = 1}^{k} 2^{2i - 3} - \sum_{i = 1}^{k} 2^{2i - 2} + \sum_{i = 1}^{k} 2^{i - 2}$$

注意在原来的式子中当 $k = 1$ 是会出现负下标的，为了避免出现不必要的麻烦，我们先算出后三项 $k = 1$ 时的结果为 $-1$ ，然后从 $k = 2$ 开始枚举就好了。

反正就是对这个式子乱搞一下，使用初中学习的指数运算，最后化简合并一下搞成这个样子 ~~感觉贼丑~~ ：
            
$$k \times (2^{2k-2} + 2^{2k-1}) + 2^{k-1} - 2 - \sum_{i = 1}^{k} 2^{2k-i-1} - \sum_{i = 2}^{k} 2^{2i - 3} - \sum_{i = 2}^{k} 2^{2i - 2}$$

发现后面三个求和操作都可以预处理出来，直接暴力算到 $1e6$ 然后处理个前缀和就可以做到 $O(1)$ 求了。

## Code

赛时代码，不推荐阅读/kk

~~不知道为啥第一个点跑那么慢~~

```cpp
/*
Work by: Suzt_ilymics
Knowledge: ??
Time: O(??)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define LL long long
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 4e6+5;
const int INF = 1e9+7;
const int Mod = 998244353;

int T, n, ans;
int Poww[MAXN]; //多次重关键字重怕了
int sum[MAXN], sum1[MAXN], sum0[MAXN];

int read(){
	int s = 0, f = 0;
	char ch = getchar();
	while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
	while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
	return f ? -s : s;
}

void Init() {
    Poww[0] = 1;
    for(int i = 1; i <= 4000000; ++i) Poww[i] = Poww[i - 1] * 2 % Mod; // 不知道为什么要预处理到4e6，感觉2e6就可以（调用的时候有乘2的操作
    for(int i = 2; i <= 2000000; ++i) {// 预处理出后面三个求和部分
        sum[i] = (sum[i - 1] + Poww[i]) % Mod;
        sum1[i] = (sum1[i - 1] + Poww[2 * i - 3]) % Mod;
        sum0[i] = (sum0[i - 1] + Poww[2 * i - 2]) % Mod;
    }
}

signed main()
{
    Init();
    T = read();
    while(T--){
        n = read();
        if(n == 0) { cout<<0<<endl; continue;} //发现我们的式子算不出n = 0 或 1 的情况，特判一下就好了
        if(n == 1) { cout<<1<<endl; continue;}
        ans = ((((((((n * (Poww[2 * n - 2] + Poww[2 * n - 1])) % Mod - 2 + Poww[n - 1]) % Mod - sum[2 * n - 2]) % Mod + sum[n - 1]) % Mod - sum1[n]) % Mod - sum0[n]) % Mod - Poww[n - 1]) % Mod + Mod + Mod) % Mod;
        //意思就是上面的式子，反正比较混乱（逃
        printf("%lld\n", ans % Mod);
    }
	return 0;
}

```



---

## 作者：唐一文 (赞：3)

## Description

[传送门](https://www.luogu.com.cn/problem/P7419)

## Solution

~~这篇题解推式子的部分可能比其他题解繁琐（~~

不妨设根结点的深度为 $1$

~~根据常识/画图可知~~ 若满二叉树的一个节点 $x$ 深度为 $i$，那么它的左子树和右子树大小为 $2^{k-i}-1$

再考虑 $x$ 对答案产生了多少贡献

- 若从左子树选一个点，从右子树选一个点，这两个点的 LCA 必为 $x$

产生了 $x\times\left(2^{k-i}-1\right)\times\left(2^{k-i}-1\right)=x\left(2^{k-i}-1\right)^2$ 的贡献

因为枚举的是有序数对，所以实际产生了 $2x\left(2^{k-i}-1\right)^2$ 的贡献

- 若选一个 $x$，从任意一个子树中选一个点，LCA 也为 $x$

产生了 $x\times\left(\left(2^{k-i}-1\right)+\left(2^{k-i}-1\right)\right)=2x\left(2^{k-i}-1\right)$ 的贡献

因为枚举的是有序数对，所以实际产生了 $4x\left(2^{k-i}-1\right)$ 的贡献

- 若选的两个点都为 $x$，LCA 即为 $x$，产生了 $x$ 的贡献

那么 $x$ 对答案产生的贡献为 $2x\left(2^{k-i}-1\right)^2+4x\left(2^{k-i}-1\right)+x$

配方化简后得到 $x\left(2^{2k-2i+1}-1\right)$

接下来考虑每一层的贡献

~~根据常识/画图可知~~ 深度为 $i$ 的节点为 $2^{i-1}\sim2^{i}-1$，共 $2^{i-1}$ 个数

那么每一层的贡献为

$$\sum_{j=2^{i-1}}^{2^i-1}j\left(2^{2k-2i+1}-1\right)$$

将 $\left(2^{2k-2i-1}-1\right)$ 提到 $\sum$ 前得到

$$\left(2^{2k-2i+1}-1\right)\sum_{j=2^{i-1}}^{2^i}j$$

后面的用等差数列求和即可

每一层的贡献即为

$$\left(2^{2k-2i+1}-1\right)\dfrac{2^{i-1}(2^{i-1}+2^i-1)}{2}$$

把 $\dfrac{1}{2}$ 移上去

$$2^{i-2}\left(2^{2k-2i+1}-1\right)(2^{i-1}+2^i-1)$$

把 $2^{i-2}$ 移到 $\left(2^{2k-2i+1}-1\right)$ 中

$$\left(2^{2k-i-1}-2^{i-2}\right)(2^{i-1}+2^i-1)$$

其中 $2^{i-1}+2^i-1$ 可化成 $3\times2^{i-1}-1$

展开得到

$$3\times2^{2k-2}-2^{2k-i-1}-3\times2^{2i-3}+2^{i-2}$$

总贡献即在前面套个 $\sum$

$$\sum_{i=1}^k\left(3\times2^{2k-2}-2^{2k-i-1}-3\times2^{2i-3}+2^{i-2}\right)$$

展开再简单化简得到

$$3k\times2^{2k-2}-2^{2k-1}\sum_{i=1}^k\left(\dfrac{1}{2}\right)^{i}-\dfrac{3}{8}\sum_{i=1}^k4^{i}+\dfrac{1}{4}\sum_{i=1}^k2^i$$

每一部分都可以等比数列求和

$$3k\times2^{2k-2}-2^{2k-1}\left(1-\left(\dfrac{1}{2}\right)^{k}\right)-\dfrac{3}{8}\cdot\dfrac{4^{k+1}-4}{3}+\dfrac{1}{4}\left(2^{k+1}-2\right)$$

继续往下化简

$$3k\times2^{2k-2}-2^{2k-1}+2^{k-1}-\dfrac{4^k-1}{2}+\dfrac{2^k-1}{2}$$

化简

$$3k\times2^{2k-2}-2^{2k-1}+2^{k-1}-2^{2k-1}+2^{k-1}$$

合并

$$3k\times2^{2k-2}-2^{2k}+2^{k}$$

也可以写成 $(3k-4)\times2^{2k-2}+2^k$

预处理 $2$ 的幂做完了

## Code

~~马蜂丑，主要还是看上面的推式子部分吧~~
```cpp
#include<bits/stdc++.h>
#define il inline
#define iL (1<<20)
#define re register
#define TEM template<class T>il void
#define Write(x,LC) write((x)),*iter++=LC
#define flush() fwrite(Out,1,iter-Out,stdout),iter=Out
#define gc() ((iS==iT)?(iT=(iS=ibuf)+fread(ibuf,1,iL,stdin),(iS==iT)?EOF:*iS++):*iS++)
using namespace std;
namespace IO{
  char ibuf[iL],*iS=ibuf+iL,*iT=ibuf+iL,Out[iL],*iter=Out;
  TEM read(re T &x){re char c;for(c=gc();!isdigit(c);c=gc());for(x=0;isdigit(c);x=(x<<1)+(x<<3)+(c^48),c=gc());}
  TEM write(re T x){re T c[35],l;for(l=0;!l||x;c[l++]=x%10,x/=10);for(;l;*iter++=c[--l]+'0');flush();}
}
using namespace IO;
#define mod 998244353
int T,k,mul[1000005]={1};
main(){
  for(re int i=1;i<1000001;++i)mul[i]=mul[i-1]+mul[i-1],mul[i]<mod?0:mul[i]-=mod;
  read(T);
  for(re int _=0;_<T;++_)read(k),k>1?(Write(((1ll*mul[k]+1ll*(k+k+k-4)*mul[k-2]%mod*mul[k])%mod+mod)%mod,'\n')):(Write(1,'\n'));
}
```

---

## 作者：critnos (赞：1)

给一个辣鸡柿子。

一些平凡的结论：

1. 对于编号为 $x$ 的节点，lca 为 $x$ 的数对个数为其左子树对其右子树的贡献加其右子树对其左子树的贡献加左右子树对 $x$ 的贡献，即 $2\times (\text{左子树大小}+1)\times(\text{右子树大小}+1)-1$

2. 同一层的节点 lca 为该节点的数对个数相同。

3. 同一个节点左右子树大小相同。

4. 对于深度为 $i$ 的节点，左/右子树大小均为 $2^{k-i}-1$。

5. 第 $i$ 层有 $2^{i-1}$ 个节点。

6. 第 $i$ 层第一个节点为 $2^{i-1}$。

分层讨论，第 $i$ 层的节点 $x$ 的贡献为

$$(2(2^{k-i})^2-1)x$$

那么提出公因数，第 $i$ 层的贡献为

$$(2(2^{k-i})^2-1)\sum_{j=2^{i-1}}^{2^i-1} j$$
 
等差数列求和得

$$\dfrac {(2(2^{k-i})^2-1)(2^{i-1}+2^i-1)2^{i-1}} 2$$

整个树的答案为

$$\sum_{i=1}^k \dfrac {(2(2^{k-i})^2-1)(2^{i-1}+2^i-1)2^{i-1}} 2$$

拆开得

$$\sum_{i=1}^k (2^{k-i})^2(2^{i-1}+2^i-1)2^{i-1}-\sum_{i=1}^k \dfrac {(2^{i-1}+2^i-1)2^{i-1}} 2$$

后面那坨东西可以前缀和了，看前面的柿子（分母约掉了）。

化成

$$\sum_{i=1}^k 2^{2k-i-1}(3\times 2^{i-1}-1)$$

再拆开

$$\sum_{i=1}^k 2^{2k-i-1}\times3\times 2^{i-1}-\sum_{i=1}^k 2^{2k-i-1}$$

后面那坨东西又可以前缀和了，继续化前面的柿子。

$$3\times \sum_{i=1}^k 2^{2k-2}$$

看见没有！

$$3k\times2^{2k-2}$$

做完了！

---

## 作者：cmll02 (赞：1)

提供一种奇怪的递推做法。（新时限 O2 可过）

显然第 $i$ 层（离叶子的距离 $+1$）在 LCA 会统计 $2^{2i-1}-1$ 次。

然而这么统计会很难递推。。因为 $i$ 时推 $i+1$ 没法直接改。

但多统计一次就好递推了。也就是统计 $2^{2i-1}$ 次，之后删去。

这样就好推了。

$i$ 到 $i+1$ 只要先 $\times 4$，然后加上新叶子结点的和（因为叶子结点之后统计一次）。

叶是连续的，那直接等差数列求和一下就完事了。

然后就递推过了？

预处理一下即可。

Code:（`Mod` 省略的部分还是放[云剪贴板](https://www.luogu.com.cn/paste/mz0op4dl)吧，写得很丑）

```cpp
#include <stdio.h>
#define int long long

const int mod = 998244353;
int qp(int x,int p)
{
	int res=1;
	while(p)
	{
		if(p&1)res=res*x%mod;
		x=x*x%mod;
		p>>=1;
	}
	return res;
}
struct Mod{...};
#undef int
#define int Mod
inline int read()
{
	int num=0;char c=getchar();
	while(c<48||c>57)c=getchar();
	while(c>47&&c<58)num=(num*10)+(c^48),c=getchar();
	return num;
}
inline int dcslqh(int l,int r)
{
	return (r-l+1)*(l+r)*499122177;
}
int a[1000005],b[1000005];
signed main()
{
	signed T=read().x;
	a[1]=2,b[0]=1,b[1]=2;int l=1,r=1,p2=1;
	for(signed i=2;i<=1000000;i++)
	{
		a[i]=a[i-1]*4;
		l=r+1,r=r+r+1;
		a[i]=a[i]+dcslqh(l,r)*2;
		b[i]=b[i-1]*2;
	}
	while(T--)
	{
		Mod n=read();
		printf("%lld\n",(a[n.x]-dcslqh(1,b[n.x]-1)).x);
	}
	return 0；
}
```

---

## 作者：_Moonlight22 (赞：0)

分 $Subtask$ 讨论：

### $Subtask1:$

直接暴力解决,记录 $k$ 值为1到8时答案。

时间复杂度：$O(k2^k+t)$

------------
### $Subtask2:$

考虑拆开结果，可以发现答案即是每个节点的编号乘以 $LCA$ 是该节点的点对的数量。然后 $LCA$ 是该节点的点对的数量就是 
$$2\times( \text{左子树大小}+1)\times (\text{右子树大小}+1)-1$$ 
同时，因为题目中树是一棵满二叉树，因此任意节点左子树大小与其右子树大小相等，且同深度节点子树大小相同。所以，当一个节点在树中深度为 $d$ ，树深度为 $k$ 时,则以该节点为根的树大小为 $2^{k-d+1}-1$。 

综上，同深度节点可以合并计算（因为它们左子树大小、右子树大小都相同），则深度 $d$ 的一行节点第一个为 $2^{d-1}$ ，最后一个为 $2^d-1$ ，设树深度为 $k$ ，则总贡献为：
$$\dfrac{(2^{d-1}+2^d-1)\times2^{d-1}\times(2(2^{k-d})^2-1)}{2}$$
答案就是：

$$\sum\limits_{i=1}^k(2^{i-1}+2^i-1)\times2^{i-2}\times(2(2^{k-i})^2-1)$$

直接暴力计算即可。

时间复杂度：$O(tk)$


------------
### $Subtask3,4:$

去括号，得：

$$\sum\limits_{i=1}^k(2^{2i-3}+2^{2i-2}-2^{i-2})\times(2^{2k-2i+1}-1)$$
$$\sum\limits_{i=1}^k2^{2k-2}+2^{2k-1}-2^{2k-i-1}-2^{2i-3}-2^{2i-2}+2^{i-2}$$

拆去 $\sum\limits_{i=1}^k$，得：

$$k\times2^{2k-2}+k\times2^{2k-1}-(2^{k-1}+2^{k-2}+……+2^{2k-2})+(2^{-1}+2^{0}+……+2^{k-2})$$
$$-(2^{-1}+2^{1}+……+2^{2k-3}+2^{0}+2^{2}+……+2^{2k-2})$$

化简得答案为：

$$k\times2^{2k-2}+k\times2^{2k-1}-(2^{2k-1}-2^{k-1})+(2^{k-1}-2^{-1})-(2^{2k-1}-2^{-1})$$

去括号，得答案为：
$$k\times2^{2k-2}+(k-2)\times2^{2k-1}+2^k$$
预处理2的次幂即可。

时间复杂度：$O(t+k)$

代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int maxn=2e6+1,MODD=998244353;
long long pow[maxn];
int read()
{
    int x=0,k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
}
int main()
{
    pow[0]=1;
    for(int i=1;i<maxn;i++)
        pow[i]=pow[i-1]*2%MODD;
    int t,k;
    scanf("%d",&t);
    for(int i=1;i<=t;i++)
    {
        k=read();
        long long ans=((k*pow[2*k-2]%MODD+(k-2)*pow[2*k-1])%MODD+pow[k])%MODD;
        printf("%lld\n",ans);
    }
    return 0;
}
```


---

## 作者：Azazеl (赞：0)

赛时自闭了，来写一份T1的题解。

#### 题意

>  $~~~~$ 求一颗类似线段树标号的满二叉树节点两两之间的LCA的和

#### 题解

$~~~~$ 不算很难，但我打了一个半小时多/kk，并且按时间来看**不是最优**的。

$~~~~$ 下面规定这个二叉树有 $k$ 层，定义一个节点的层数为它到 $1$ 号节点经过的**边数**，$d_i=\sum_{i=1}^n i=\dfrac{i\times (i+1)}{2}$。

$~~~~$ 首先，每一个在第 $i$ 层的节点的子树大小都是固定的，且子树均为满二叉树，下面记第 $i$ 层节点的子树大小 $siz_i=2^{k-i}-1$，

$~~~~$ 然后依然由于相同层的节点子树是完全一样的，所以我们来看一个在第 $i$ 层的节点有多少点对是以它为 LCA的。首先子树内共有 $siz_i^2$ 个点对，选到子树外的点显然不可能以该点为 LCA，而它的两个儿子的子树内的点对肯定是**不**以这个点为LCA的，所以第 $i$ 层的点共有 $siz_i^2-2\times siz_{i+1}^2$ 个点对以它为 LCA。

$~~~~$ 显然第 $i$ 层的点我们可以一起计算，它们的总贡献应该为 $(d_{2^{i+1}-1}-d_{2^{i}-1})\times(siz_i^2-2\times siz_{i+1}^2)$ 。

$~~~~$ 现在把所有式子展开来计算，答案就是

$$
\large \sum_{i=0}^{k-1} [(2^{k-i}-1)^2-2\times(2^{k-i-1}-1)^2]\times [\dfrac{2^{i+1}\times (2^{i+1}+1)}{2}+\dfrac{2^{i}\times (2^{i}+1)}{2}]
$$

$~~~~$ ~~随便~~化简一下，得到答案为：
$$
\large \sum_{i=0}^{k-1} (2^{2(k-i)-1}-1)\times (3\times 2^{2i-1}-2^{i-1})
$$
$~~~~$ 把前面拆开，让 $2^{2k}$ 被单独化出来：
$$
\large 2^{2k}\times \sum_{i=0}^{k-1} \dfrac{3\times 2^{2j-1}-2^{j-1}}{2^{2j}-1}-\sum_{i=0}^{k-1}(3\times 2^{2j-1}-2^{j-1})
$$


$~~~~$ 把两个 $\Sigma$ 都 $\mathcal{O(k)}$ 预处理一下，再做一下前缀和，就可以单次 $\mathcal{O(1)}$ 回答。

$~~~~$ 赛后改成200ms时限要吸口氧。

#### 代码

```cpp
#include <cstdio>
#include <algorithm>
#define ll long long
ll Pow[2000005],Sum1[2000005],Sum2[2000005];
const ll MOD=998244353;
template<typename T>void read(T &x)
{
    T f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    x*=f;
}
ll qpow(ll a,ll b)
{
	ll ret=1;
	while(b)
	{
		if(b&1) ret=ret*a%MOD;
		a=a*a%MOD;
		b>>=1;
	}
	return ret%MOD;
}
template<typename T>void print(T x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
int main() {
	int T,k;
	read(T);
	Pow[0]=1;
	for(int i=1;i<=2000000;i++) Pow[i]=Pow[i-1]*2%MOD;
	Sum1[0]=499122177;Sum2[0]=1;
	for(int i=1;i<=1000000;i++) Sum2[i]=3*Pow[2*i-1]%MOD-Pow[i-1],Sum1[i]=Sum2[i]*qpow(Pow[2*i+1],MOD-2)%MOD,Sum1[i]=(Sum1[i]+Sum1[i-1])%MOD,Sum2[i]=(Sum2[i]+Sum2[i-1])%MOD;
	ll Ans=0;
	while(T--)
	{
		read(k);Ans=Pow[2*k];
		Ans=Ans*Sum1[k-1]-Sum2[k-1];
		print((Ans%MOD+MOD)%MOD);puts("");
	}
	return 0;
}
```



---

## 作者：Booksnow (赞：0)

# 参天大树

## 题目大意

给出一个 $n$ 层的满二叉树，其根节点编号为 $1$ ，对于每一个 $x(x \ge 1)$ ，编号为 $x$ 的节点有编号为 $2x$ 与编号为 $2x+1$ 的子节点。

需要从该二叉树的节点中选出一些节点(**可以相同**)，求出所有情况中他们 $LCA$ 的和。

则我们需要求出下面这个式子的值：

$$ \sum_{i=1}^{i<=n}\sum_{j=1}^{j<=n} LUA(i,j) $$

最终答案对 $998244343$ 取模。

## 分析

拿到这个题，我们可以换一个角度来思考，不妨想一想如果我们想要选出节点的 $LCA$ 为 $i$ 节点，有多少种不同的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/jnqye804.png)

其实我们可以分为以下三种情况：

- 这两个点就是 $x$ 与 $x$ ，这样就能保证有 $x$ 的贡献，很显然该情况只会出现一次。

- 这两个点分别在 $x$ 的左子树与右子树，如上图，这样也能保证他们的 $LCA$ 恰为 $x$ ，则这种情况的总数肯定就是左子树的大小乘右子树的大小还要乘 $2$ ，注意这里的乘 $2$ 是因为除了选择同一个点的情况其余情况都可以反转。

- 固定其中一个点为 $x$ ，剩余的点在 $x$ 的子树中选取，则很显然情况数位 $2$ 乘 $x$ 所有后代的数量。

那么，我们就能处理出 $x$ 为 $LCA$ 时的所有贡献了。

设 $sum_{sun}$ 为 $x$ 一个子树的大小，设根节点的层数为 $1$ ， $x$ 的层数为 $i$ ，则易有 $sum_{sun}=2^{n-i}-1$ 。

则当前的可知道 $LCA$ 为 $x$ 的贡献为:

$$ sum_x=x\times [1+2\times (2^{n-1}-1) \times (2^{n-1}-1)+2\times2\times (2^{n-1}-1)] $$

进行化简即为

$$ sum_x=x\times[1+2\times (2^{n-1}-1)\times (2^{n-1}+1)]=x\times [1+2\times(2^{2(n-i)}-1)] $$

接下来考虑如何将其转化到层上去，我们发现，其实每层的节点他们的子树都是一模一样的，所不同的只是系数，我们设 $sum_i$ 表示第 $i$ 层所有节点编号值的和，则有：

$$ans=\sum_{i=1}^{i<=n}sum_i\times [1+2\times(2^{2(n-i)}-1)]$$

设 $numl_i$ 表示第 $i$ 层最左边节点的编号， $numr_i$ 表示第 $i$ 层最右边节点的编号，则有：

$$ numl_i=2^{i-1} , numr_i=numl_i+2^{i-1}-1 $$

$$ sum_i=\frac {(numl_i+numr_i)\times 2^{i-1}}{2}=\frac{3\times 2^{2(i-1)}-2^{i-1}}{2} $$

则

$$ ans=\sum_{i=1}^{i<=n} \frac{3\times 2^{2(i-1)}-2^{i-1}}{2}+(3\times 2^{2(i-1)}-2^{i-1})(2^{2(n-1)}-1)=\sum_{i=1}^{i<=n}(3\times 2^{2(i-1)}-2^{i-1})(2^{2(n-1)}-\frac{1}{2}) $$

展开即为

$$ ans=\sum_{i=1}^{i<=n}3\times2^{2(n-1)}-2^{2n-i-1}+\frac{1}{2}\times 2^{i-1}-\frac{3}{2}\times 2^{2(i-1)} $$

然后再展开

$$ans=3n\times2^{2(n-1)}+\frac{1}{2}\times \sum_{i=1}^{i<=n}2^{i-1}-\frac{3}{2}\times \sum_{i=1}^{i<=n}2^{2(i-1)}-2^{2n}\sum_{i=1}^{i<=n}\frac{1}{2^{i+1}}$$

然后，又有

$$ \sum_{i=1}^{i<=n}2^{i-1}=2^n-1 $$

后面的两个求和式用到等比数列求和的知识，即

$$ \sum_{i=1}^{i<=n}2^{2(i-1)}=\frac{1-2^{2n}}{1-2^2}=\frac{2^{2n}-1}{3} $$

$$ \sum_{i=1}^{i<=n}\frac{1}{2^{i+1}}=\frac{\frac{1}{4}\times(1-(\frac{1}{2})^n)}{1-\frac{1}{2}} $$ 

最后得到的答案为：

$$ ans=3n\times 2^{2n-2}+2^n-2^{2n} $$

然后就做完了。

更新：此题根本不用快速幂，可以通过直接 $O(n)$ 的预处理避免超时，下面是最新代码。

## CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+10,MOD=998244353;
inline ll read()
{
    ll s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
ll dis[N];
int main()
{
	ll t=read();
	dis[0]=1;
	for(register int i=1;i<=1e6;i++) dis[i]=dis[i-1]*2%MOD;
	while(t--){
		ll n=read(),temp=dis[n-1];
		ll ans=((3*n%MOD-4+MOD)%MOD*temp%MOD*temp%MOD+temp*2%MOD+MOD)%MOD;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---


# [COCI 2012/2013 #1] SNAGA

## 题目描述

从一个正整数 $N$ 开始，找到不能被 $N$ 整除的最小正整数。如果我们用得到的正整数重复这个过程，我们最终会得到 $2$。

定义 $\operatorname{strength}(N)$ 为结果序列的长度。例如 $N = 6$，可以得到由 $4$ 个数字组成的结果序列 $6,4,3,2$，包含 $4$ 个整数，所以 $\operatorname{strength}(6) = 4$。

给定两个正整数 $A,B$，请计算：

$$ \sum\limits_{i=A}^B \operatorname{strength}(i)$$

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，保证 $3 \le A < B \le 10^{17}$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $140$。

题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)** ___T5 SNAGA___。

## 样例 #1

### 输入

```
3 6```

### 输出

```
11```

## 样例 #2

### 输入

```
100 200```

### 输出

```
262```

# 题解

## 作者：Alarm5854 (赞：5)

这道题目一看数据范围就知道它是一道数学题，不过要怎样处理呢？

令 $f(x)$ 为不能整除 $x$ 的最小整数，其中 $x\ge 3$，很显然的是 $\text{strength}(x)=\text{strength}(f(x))+1$，这根据定义可知。

关键就在这里：对于所有 $x\in [3,10^{17}]$，一定有 $f(x)\le 41$，因为 $\text{lcm}(1,2,...,40)<10^{17}$，而 $\text{lcm}(1,2,...,41)>10^{17}$，所以只需要预处理一下 $3$ 到 $41$ 之间的 $\text{strength}(i)$ 即可。

预处理完之后，计算 $3$ 到 $n$ 的 $\text{strength}(i)$ 的和。答案初始化为 $2n+k$，其中 $k$ 为任意常数，因为之后计算答案的时候可以抵消，枚举 $2$ 到 $40$，并更新 $\text{lcm}$，再更新答案即可。

```cpp
#include<ctime>
#include<cstdio>
#include<cctype>
#define ll long long
using namespace std;
ll read(){
	char c;
	ll x=0,f=1;
	while(!isdigit(c=getchar()))
		f-=2*(c=='-');
	while(isdigit(c)){
		x=x*10+f*(c-48);
		c=getchar();
	}
	return x;
}
ll gcd(ll x,ll y){
	while(x&&y){
		ll z=x;
		x=y;
		y=z%y;
	}
	return x|y;
}
ll lcm(ll x,ll y){
	return x/gcd(x,y)*y;
}
ll a,b,str[55];
ll f(ll x){//找最小的正整数使得不能整除x
	ll t=2;
	for(;;++t){
		if(x%t)
			break;
	}
	return t;
}
ll work(ll x){
	ll tmp=1;
	ll res=x*2;
	for(ll i=2;i<43;++i){
		tmp=lcm(tmp,i);
		res+=x/tmp*(str[i+1]-str[i]);//在1~x中f(i)>tmp的有x/tmp个，而这些开始默认它为tmp，所以要改变
	}
	return res;
}
int main(){
	a=read()-1;
	b=read();
	for(ll i=3;i<=43;++i)
		str[i]=str[f(i)]+1;//预处理strength(i)，实际上并不需要确切值，像这里其实处理的是strength(i)-1
	printf("%lld",work(b)-work(a));
	return 0;
}
```



---

## 作者：Φρανκ (赞：4)

题意：定义 $\operatorname{strength}(n)$ 为从 $n$ 开始每次选取最小的不整除之的正整数构成序列的长度，求 $\sum_{i=A}^B \operatorname{strength}(i)$。

核心思想：暴力枚举

解：

显然，答案应当大于等于 $A-B+1$。

发现一个数 $n$ 与其后一项 $m$ 满足 $lcm(1, 2, ..., m-1)\mid n$ 且 $lcm(1, 2, ..., m)\nmid n$，而 $lcm(1, 2, ..., 41)>10^{17}$，所以可以暴力求出  $1\sim 41$ 中每个数的函数值与最小公约数值，不妨设为 $f(i),l(i)$。则在 $A\sim B$ 之间满足后项是 $i$ 的有 $\frac{B}{l(i)}-\frac{A-1}{l(i)}-(\frac{B}{l(i+1)}-\frac{A-1}{l(i+1)})$ 个数，每个数会使答案增加 $f(i)$。依次求算即可。

代码：
```
#include <bits/stdc++.h>
using namespace std;
long long a, b, l[42], v[42], n[42], res;
int main()
{
	cin>>a>>b;
	res=b-a+1;//赋初值
	l[1]=1;
	for(long long i=2; i<=41; i++)
		l[i]=l[i-1]/__gcd(l[i-1], i)*i;//计算lcm
	v[2]=1;
	for(int i=3; i<=41; i++)
		for(int j=2; j<i; j++)
			if(i%j!=0)
			{
				v[i]=v[j]+1;
				break;
			}//暴力求值
	for(int i=1; i<=41; i++)
		n[i]=b/l[i]-(a-1)/l[i];//计算个数
	for(int i=2; i<=41; i++)
		res+=v[i]*(n[i-1]-n[i]);//加和
	cout<<res;
	return 0;
}

```

---

## 作者：Treap_qwq (赞：1)

感谢管理员的审核！

## Hint 0

懒人认为 $A$ 和 $B$ 同阶，记其值域为 $V$。

## Hint 1

可以试着通过数据范围分析时间复杂度。首先我们看一下数据范围 $3 \le A < B \le 10 ^ {17}$，所以显然复杂度要小于 $O (\sqrt V)$。我们此时必须考虑一些数学策略来将复杂度降到趋近于 $O (\log V)$。

## Hint 2

我们考虑初始化。由于题意，我们记终态 $x$ 转化成终态 $2$ 需要的操作次数为 $F (x)$，有题目中的定义，可知终态 $x$ 会先转换为 $\mathrm{Strength} (x)$，所以可以得到一条直接模拟的式子：

$$
F (x) = F (\mathrm {Strength} (x)) + 1
$$

但是显然，这条式子我们不能直接模拟，否则时间跟空间复杂度都会趋近于 $O (V)$。所以，我们显然只能预处理到一定的数值 $k$，且大于 $k$ 的数都能够经过若干次迭代转换为小于等于 $k$ 的值。

## Hint 3

考虑 $k$ 取什么值会使 $x$ 能够至少一次迭代转移到 $k$。我们发现此时我们尝试打表枚举 $\mathrm {Strength} (x)$ 发现它的最大值是 $41$。证明也很简单，我觉得使用 $\mathrm {lcm} (1, 2, \cdots, 41) \ge 10 ^ {17}$ 的证法比较正确，但是计算复杂度时不能用这种方法。但是，我们也可以考虑 $x = \prod p_i ^ {q_i}$，这种分解方式的约束是 $\forall p_i\ge 2$，且 $\forall q_i\ge 1$。我们记 $r_i = p_i - 2$，那么 $x=\prod (2 + r_i) ^ {q_i}$，由于 $2 + r_i \ge 2$，所以 $i \le \log_2 x$，于是分析出复杂度是 $O (\log V)$。

## Hint 4

于是我们可以考虑最终做法了。复杂度显然 $O (\log V)$。

计算 $3$ 到 $V$ 的 $\mathrm{strength} (x)$ 的和。答案初始化为 $2 V$，实际上任意的 $2 V + k$ 都可以，但是要求 $k\ge 0$。枚举 $2$ 到 $45$，并更新 $\mathrm{lcm}$ 和 $\mathrm {ans}$ 即可。最后的答案是 $F (B) - F (A - 1)$，不要像我一样把 $A - 1$ 打成 $A$ 调了好久。

---

## 作者：Shellchen (赞：1)

首先，$\le 10^{17}$ 的一个数，它第一次最大能跳到 $41$。所以就可以预处理出 $1$ 到 $50$ 的所有数的 $strength$。

然后考虑处理对于每个 $i$，$[a,b]$ 中有多少个数第一次就跳到 $i$。很明显，如果一个数 $x$ 能被 $[1,i-1]$ 中所有数整除，且不能被 $i$ 整除，那么 $x$ 第一次就会跳到 $i$。于是就变成求最小公倍数的问题了。

记得开 long long。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=42;
int f(int x)
{
	for(int i=2;i<=x;i++) if(x%i!=0) return i;
}
int lcm(int x,int y)
{
	return x/__gcd(x,y)*y;
}
int a[N],cnt[N];
signed main()
{
	a[2]=1;
	for(int i=3;i<N;i++) a[i]=a[f(i)]+1;
	int l,r,lj=0,lm=1;
	cin>>l>>r;
	int i=1;
	while(lm<=r)
	{
		i++;
		lm=lcm(i,lm);
		int k=r/lm-(l-1)/lm;
		k=(r-l+1)-k;
		k-=lj;
		cnt[i]=k;
		lj+=k;
	}
	int ans=r-l+1;
	for(int i=2;i<N;i++) ans+=a[i]*cnt[i];
	cout<<ans; 
    return 0;
}
```

---

## 作者：XuYueming (赞：1)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P7586)。

[更好的体验](https://www.cnblogs.com/XuYueming/p/18383507)。

## 题意简述

定义 $f(x)$ 表示不能整除 $x$ 的最小正整数。

给出数字 $n$，每次 $n \gets f(n)$，当 $n = 2$ 时停止。定义 $g(n)$ 为这一过程中的数字个数，例如 $g(6) = 4$。给定 $l, r$，求 $\sum \limits _ {i = l} ^ r g(i)$。

$3 \leq l \lt r \leq 10^{18}$。

## 题目分析

首先发现 $f(x)$ 非常小，在 $x \leq 10^{18}$ 时，有 $n = \max f(x) = 41$。所以，我们枚举 $i = 1, \ldots, n$，每次统计在 $[l, r]$ 中，$f(x) = i$ 的个数有多少个，这些数的 $g$ 函数值都是 $g(i) + 1$，所以将个数乘上 $g(i) + 1$ 就可以累加到答案中去了。得到 $1 \sim n$ 的 $g$ 的函数值是简单的。容易证明，这样的统计是不重不漏的。

我们怎么求出 $f(x) = i$ 的个数呢？发现，“不能整除 $x$ 的最小正整数”等价于“能够整除小于它的所有正整数，但不能整除它”，换句话说，$f(x) = i$ 的 $x$ 满足 $\forall t \in [1, i), t \mid x$ 以及 $i \not \mid x$。不妨从前者中扣出后者，即两个条件同时满足的很难计算，那么我们先计算满足 $A$ 的方案数，减去满足 $A$ 但不满足 $B$ 的方案数。

前者又等价于 $\operatorname{lcm}(1, \ldots, i - 1) \mid x$，不妨记 $p_i = \operatorname{lcm}(1, \ldots, i)$，前者等价于 $p_{i - 1} \mid x$。所以 $[l, r]$ 中，能够整除 $p_{i - 1}$ 的个数，等价于是 $p_{i - 1}$ 的倍数的个数，也就是 $\Big \lfloor \cfrac{r}{p_{i - 1}} \Big \rfloor - \Big \lfloor \cfrac{l - 1}{p_{i - 1}} \Big \rfloor$。

再来看看满足前者但不满足后者的个数。此时 $p_{i - 1} \mid x$ 并且 $i \mid x$。发现其实就是 $p_i \mid x$，用同样的方法计数即可。

形式化地讲，答案 $ans = \sum \limits _ {i = 2} ^ {41} {\Large {\Bigg (}} \Bigg ( \Big \lfloor \cfrac{r}{p_{i - 1}} \Big \rfloor - \Big \lfloor \cfrac{l - 1}{p_{i - 1}} \Big \rfloor \Bigg ) - \Bigg ( \Big \lfloor \cfrac{r}{p_{i}} \Big \rfloor - \Big \lfloor \cfrac{l - 1}{p_{i}} \Big \rfloor \Bigg ) {\Large {\Bigg )}} \times \Big ( g(i) + 1 \Big)$。

$f, g$ 什么的打个表预处理一下，时间复杂度 $\Theta(\max f(x))$。

## 代码

```cpp
#include <cstdio>
#include <iostream>
#include <array>
using namespace std;

constexpr int f(int x) {
    for (int i = 2;; ++i)
        if (x % i)
            return i;
}

constexpr const int N = 41;

template <typename T>
using arr = array<T, N + 1>;
using lint = long long;

constexpr arr<int> len = []() {
    arr<int> res = {};
    res[2] = 1;
    for (int i = 3; i <= N; ++i) res[i] = res[f(i)] + 1;
    return res;
}();

template <typename T>
constexpr T gcd(T a, T b) {
    return b ? gcd(b, a % b) : a;
}
template <typename T>
constexpr T lcm(T a, T b) {
    return a / gcd(a, b) * b;
}

constexpr arr<lint> val = []() {
    arr<lint> res = {};
    res[1] = 1;
    for (int i = 2; i <= N; ++i) res[i] = lcm(res[i - 1], 1ll * i);
    return res;
}();

lint l, r, res;

signed main() {
    scanf("%lld%lld", &l, &r);
    for (int i = 2; i <= N; ++i)
        res += ((r / val[i - 1] - (l - 1) / val[i - 1]) - (r / val[i] - (l - 1) / val[i])) * (len[i] + 1);
    printf("%lld", res);
    return 0;
}
```

## 反思 & 总结

遇到数据范围巨大的时候，考虑：倍增、矩阵快速幂、数位 DP、根号分治、数学性质。

本题属于最后一类，关键点在于发现 $\operatorname{lcm}$ 很小，并**转变计数视角**，使用小小容斥计数。

---

## 作者：djh0314 (赞：1)

[**洛谷**](https://www.luogu.com.cn/problem/P7586)。

## 题意

应该好理解，~~没理解的话可以看一下下面暴力的代码。~~

## 分析

观察这种题，范围 $3\le A < B \le 10^{17}$，首先就只有几种算法了（至少我没学过多少种）：倍增，矩阵快速幂，数学，数位 DP，循环，或一些特殊情况。

而这题，他有一个不能整除的性质，看来只有数学来解决了，先确定了一个大的方向。

先打一个暴力，打个小表来分析一下性质：
~~~cpp
inline int js(int x) {
	if(x==2) return 1;
	for(int j=2;j<=x;++j) if(x%j) return 1+js(j);
}
~~~

输出前一百个观察一下：
![](https://cdn.luogu.com.cn/upload/image_hosting/kj4mcwuw.png)

再随机几个我们发现，所有的 $len$ 都是小于等于 $4$ 的。

由此，我们再次分析一下我们的操作，可以得到几个性质（令 $f_i$ 表示 $i$ 的最小的不能整除的数）：     
1. 奇数的 $len$ 必然为 $2$。
2. 所有小于 $f_i$ 的数都是 $i$ 的因数。

看起来有点像废话？所有小于 $f_i$ 的数都是 $i$ 的因数，这也就导致，我们的前 $f_i$ 个数的 lcm。

输出一下前缀的 lcm：
![](https://cdn.luogu.com.cn/upload/image_hosting/txcucxox.png) 

当我们的 $i$ 大于 $42$ 时，就已经超过了我们的范围了，因此，我们的 $f_i\le 42$，这是第一个衍生性质。

再分析一下 $f_i$ 在数字上的性质，进而判断 $len_i$ 的数值。      

先给出结论：
1. $i$ 是一个奇数，那么 $len_i=2$；
2. $f_i$ 是一个奇数，那么 $len_i=3$；
3. $f_i$ 是一个偶数，那么 $len_i=4$。

这三个结论中的前两个都应该是很显然的，着重分析一下第 3 个。

因为 $f_i$ 是一个偶数，我们令 $f_i=2\times k$，那么 $k$ 也就已经判断过，是 $i$ 的因数。     
那为什么我们的 $2\times k$ 不是其因数了呢？是因为我们增加了一个 $2$ 的因数。          
因此，我们对其造成关键的实际上是 $2^q$，（$q$ 为 $2\times k$ 的 $2$ 的最大幂次）。            
而 $2^q\le 2\times k$，由此，我们的 $f_i$ 应当就是 $2^q$，而 $f_{2^q}=3$。由此，得出我们的结论 3。

最后轮到了如何求答案了，我们分开处理三种数，可能不太好算，我们令其一部分放在一起考虑。

我们令基础的贡献为 3，那么，我们只要减去奇数的个数，就可以处理出 1，2 的贡献，同时，计算了一部分的 3，我们只需要加上第三种数字的个数即可。

对于这一部分，我们又要分成 4 种，根据 $f_i$ 的种类分类，因为 $f_i\le 42$，$f_i=2^q$，所以此时的 $f_i$ 只有四种可能：4、8、16、32。

要使 $f_i$ 是 $x$，我们需要使 $i$ 使 $x$ 前面所有数的 lcm 的因数，同时不被 $x$ 整除，用一个小小容斥即可。

~~~cpp
for(int i=2;i<=5;++i) {
	res+=x/num[i];//num为预处理的前缀lcm
	ll y=num[i]*(1<<i)/__gcd(num[i],(1<<i));
	if(y<0) continue;//防止爆
	res-=x/y;
}
~~~


---

## 作者：ZnPdCo (赞：1)

~~校内考试唯一会做的题。~~

如果打了暴力的 $\operatorname{strength}(N)$ 函数，就会发现这个暴力跑得飞快！为什么呢？我们把函数的每一次 $\operatorname{S(N)}$ 都打印出来，发现即使初始的 $N$ 非常大，经过第一次 $\operatorname{S}(N)$ 都会变得非常小！这个第一次经过 $\operatorname{S}(N)$ 函数后的数最大是 $41$。也就是说，我们只需要求出 $[2,41]$ 这些数的 $\operatorname{strength}(N)$，然后暴力遍历 $[A,B]$，结果就是 $\sum_{i=A}^{B} \operatorname{strength}(\operatorname{S}(i))+1$。

可惜的是，这样的时间复杂度还是 $O(n)$。但是我们可以想到一个想法，对于一个 $x$，如果我们能求出使得 $\operatorname{S}(N)=x$ 的 $N$ 的个数 $D_x$，我们可以得到结果为 $D_x(\operatorname{strength}(x)+1)$。

我们再次回到题目，发现如果一个数最小的不能整除的正整数是 $x$，那么说明这个数是 $1\sim x-1$ 的所有数的公倍数，且不是 $1\sim x$ 的所有数的公倍数。也就是说，如果一个数 $N$ 的 $\operatorname{S}(N)=x$，那么这个数是 $\operatorname{lcm}(1,2,\cdots,x-1)$ 的倍数而不是 $\operatorname{lcm}(1,2,\cdots,x)$ 的倍数。

因为 $x$ 最大是 $41$，显然这个数是容易求出来的。我们只需要枚举 $x$ 的值，然后求出 $[A,B]$ 里面有多少个数满足是 $\operatorname{lcm}(1,2,\cdots,x-1)$ 的倍数而不是 $\operatorname{lcm}(1,2,\cdots,x)$ 的倍数。容斥原理。

---

对于第一次经过 $\operatorname{S}(N)$ 函数后的数最大是 $41$ 的证明，可以暴力求出 $\operatorname{lcm}(1,2,\cdots,41)$，发现已经超过 $10^{17}$ 了，不能再大了。

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll a, b;
ll fun(ll x, ll tot=1) {
	if(x == 2) {
		return tot;
	}
	for(ll i = 1; i <= x; i++) {
		if(x % i != 0) {
			return fun(i, tot+1);
		}
	}
}
ll facf[110];
ll s[110];
ll ans;
int main() {
	facf[1] = 1;
	for(ll i = 2; i <= 41; i++) {
		facf[i] = facf[i-1] * i / __gcd(facf[i-1], i);
		s[i] = fun(i);
	}
	scanf("%lld %lld", &a, &b);
	if(a <= 41) {			// 特判
		for(ll i = a; i <= min(41ll, b); i++) {
			ans += fun(i);
		}
		a = min(41ll, b) + 1;
	}
	for(ll i = 2; i <= 41; i++) {
		ll A = (a-1) / facf[i-1] - (a-1) / facf[i];
		ll B = b / facf[i-1] - b / facf[i];
		ans += (B - A) * (s[i] + 1);
	}
	printf("%lld", ans);
}
```



---

## 作者：Kevin_Mamba (赞：1)

### 题意

略。

### 解析

1. 证明：对于任意整数 $x(x\ge 3)$，有 $\mathrm{strength} (x)\le4 $。

证明过程：

若序列为 $x,a_1,a_2,...,a_n$，不难发现，对于任意的 $i(1\le i\le n)$，$a_i$ 都必定**只有一个质因子。**

为什么呢？因为若不是这样，$a_i$ 就会变成它的一个不能整除前一个数的质因子，并且这个质因子肯定会比 $a_i$ 小。

所以每个 $a_i$ 都能被写成 $a_i=p^m$，其中 $p$ 是一个质数，$m$ 为正整数。

* 当 $a_1=2$ 时，序列 $x,2$，函数值为 $2$。

* 当 $a_1=2^m(m\gt 1)$ 时，序列 $x,2^m,3,2$，函数值为 $4$。

* 当 $a_1=p^m(p\ne2,m\ge1)$ 时，序列 $x,p^m,2$，函数值为 $3$。

证毕。

2. 分类讨论。

* $a_1=2$，函数值为 $2$。

此时 **$x$ 为奇数。** 

* $a_1=2^m(m\gt 1)$，函数值为 $4$。

这种情况比较复杂。

首先，**$x$ 是 $y=\mathrm {lcm}(2,3,...,2^m-1)$ 的倍数，且不是 $2^m$ 的倍数**（这里的 $\mathrm {lcm}$ 代表的是**最小公倍数**）。

因为 $y$ 是 $2^{m-1}$ 的倍数，所以条件就等价于 **$\dfrac{x}{y}$ 是奇数**。 

* 其余的数函数值为 $3$。

综合下来，主要都是**统计区间内奇数个数。**

### 代码

可能有些地方写的不是很简洁，看懂思路的话可以自己实现。

```cpp
#include<bits/stdc++.h>
#define il inline
#define re register
using namespace std;

const int N=43,
prime[N]={2,3,5,7,11,13,17,19,23,29,31,37,41};

long long A,B,f[N],ans,num;

int base[N];

il void init() {
	re int ret;
	for(re int i=0;prime[i];i++) {
		ret=prime[i];
		while(ret<N) {
			base[ret]=prime[i];
			ret*=prime[i];
		} 
	}
	re long long last=2;
	f[2]=1;
	for(re int i=3;i<N;i++) {
		if(base[i]) {
			f[i]=f[last]*base[last];
			last=i;
//			cerr<<i<<' '<<f[i]<<'\n';
		}
	}
}

il void gao(re int x) {
//	if(B<f[x]) return ;
	re long long a=A/f[x],b=B/f[x];
	if(a*f[x]<A) a++;
	re long long k=b-a+1;
	if(k%2==0) {
		ans+= k*2;
		num-=k/2; 
	} 
	else {
		if(a%2==1) {
			ans+=k*2+2;
			num-=k/2;
			num--;
		}
		else {
			ans+=k*2-2;
			num-=k/2;
		}
	}
}

il void work() {
	num = B-A+1;
	if(num%2==0) {
		ans+=num;
		num/=2;
	}
	else {
		if(A%2==1) {
			ans+=num+1;
			num/=2;
		}
		else {
			ans+=num-1;
			num/=2;
			num++;
		} 
	}
//	cerr<<ans<<'\n';
	for(re int i=4;i<N;i++) {
		if(base[i]==2) {
			if(f[i]>B) break;
			gao(i);
		}
	}
	ans+=num*3;
}

int main() {
	init();
	scanf("%lld%lld",&A,&B);
	work();
	printf("%lld\n",ans);
	return 0;
}

/*
As for any array:
x a_1,a_2,...,a_n
a_i = p^m
p is a prime number,
n is an int (n>0) 

a_i = 2^m : m=1 ? 2 : 4
else : 3 
*/ 

```















---


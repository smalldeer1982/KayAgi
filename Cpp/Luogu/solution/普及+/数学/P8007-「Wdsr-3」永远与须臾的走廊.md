# 「Wdsr-3」永远与须臾的走廊

## 题目背景

永远亭是迷途森林里的不可思议的屋子。

为了躲避月之使者的到来，也是为了防御，永远亭内被布下了一条无尽的长廊。困在其中的对手无法触及到真实，陷入到永远与须臾的陷阱里去。

不过，无尽的长廊 $S$ 毕竟只是单一有限走廊 $S_0$ 的无限循环，其本质是永远亭的主人蓬莱山辉夜及八意永琳设下的圈套。正因该长廊是通过辉夜的能力实现的，因此辉夜可以通过修改该「有限长的」走廊 $S_0$，进而作用于「无限长的」长廊 $S$。这意味着有限的修改可以创造出无限的变动。

光秃秃的长廊显得单调，也难以起到掩人耳目的目的。辉夜决定在长廊上绘制象征着月初的「上弦月」和象征着月末的「下弦月」，以达到图案交错重叠的目的。为了方便起见，「上弦月」可以被近似认为是左括号，而「下弦月」可以被近似认为是右括号。作为优雅的月之都的公主，当然会有不少条条框框——轮到你帮助辉夜满足她的要求了。

## 题目描述

辉夜希望创造一个无限长的括号序列 $S$ 作为永远亭长廊的绘制图案，它由一个长度为 $n$ 的括号序列 $S_0$ 不断重复而成。

我们称一个括号序列 $T$ 是合法的，当且仅当它可以由以下方式生成：

- $\verb!()!$ 是一个合法的括号序列。  
- 如果 $A$ 是合法括号序列，那么 $\verb!(!A\verb!)!$ 同样是一个合法括号序列。  
- 如果 $A,B$ 都是合法括号序列，那么 $AB$（即 $A,B$ 拼接）同样是一个合法括号序列。

例如，$\verb!(()())!,\verb!()()!,\verb!((()())())!$ 都是合法括号序列；而 $\verb!)(!,\verb!(()!,\verb!())(()!$ 均不是合法括号序列。

现在辉夜已经确定了 $S_0$ 当中一部分的符号。你需要求出，「在剩下来的单元上绘制括号，使得这条无限长的长廊上可以找到**无限长的**合法括号序列」的方案数。两种方案不同仅当两种方案中有至少一个位置的 `?` 被替换成了不同的字符。输出它对 $998,244,353$（一个大质数）取模后的结果。

## 说明/提示

#### 样例 1 解释

符合条件的方案共有三种：$\verb!(())!$、$\verb!()()!$ 和 $\verb!())(!$。

- 第一种方案，$\overbrace{\text{\tt\textcolor{red}{(())}\textcolor{blue}{(())}\texttt{...}\textcolor{red}{(())}\textcolor{blue}{(())}}}^{\text{无穷个}}$ 可以找到无限长的合法括号序列。
- 第二种方案，$\overbrace{\text{\tt\textcolor{red}{()()}\textcolor{blue}{()()}\texttt{...}\textcolor{red}{()()}\textcolor{blue}{()()}}}^{\text{无穷个}}$ 同样可以找到无限长的合法括号序列。
- 第三种方案，$\text{\tt\textcolor{red}{())}}\overbrace{\text{\tt\textcolor{red}{(}\textcolor{blue}{())(}\texttt{...}\textcolor{red}{())(}\textcolor{blue}{())}}}^{\text{无穷个}}\text{\tt\textcolor{blue}{(}}$ 仍然可以找到无穷长的括号序列。

可以证明，不存在其他方案。

#### 数据范围及约定

$$
\def{\arraystretch}{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le } & \textbf{特殊性质} & \textbf{分值} \cr\hline
1 & 20 & - & 20 \cr\hline
2 & 10^5 & \text{A} & 10 \cr\hline
3 & 10^5 & \text{B} & 10 \cr\hline
4 & 10^5 & - & 60 \cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证字符串里仅出现 $\verb!(!$ 和 $\verb!)!$。  
**特殊性质** $\textbf{B}$：保证字符串里仅出现 $\verb!?!$。

对于全部数据，满足 $1\le n\le 10^5$，且字符串里仅出现 $\verb!(!,\verb!)!,\verb!?!$ 三种字符。

## 样例 #1

### 输入

```
4
(???
```

### 输出

```
3```

## 样例 #2

### 输入

```
8
(???))??```

### 输出

```
10```

# 题解

## 作者：囧仙 (赞：13)

## 题解

首先给出结论：**方案合法，当且仅当左括号数目和右括号数目相等**。

考虑非常套路地，将左括号记为 $+1$，右括号记为 $-1$。那么一段括号序列可以被看做是一条折线，碰到左括号就向上走 $1$ 个单位，碰到右括号就向下走一个单位。

![](https://cdn.luogu.com.cn/upload/image_hosting/10agng53.png)

这张图对应的 $S_0=\verb!())()(!$。容易发现，如果左括号数目和右括号数目相同，那么折线就会出现循环节，并且总是能在一个循环节里找到一个最低的位置。那么再选定无穷次循环后的折线的最低点，它们之间形成的括号序列就是无限长的合法括号序列。

![](https://cdn.luogu.com.cn/upload/image_hosting/ker91u6h.png)

这张图对应的 $S_0=\verb!())((!$。容易发现，如果左括号数目和右括号数目不相同，那么整条折线就会有向上/向下的趋势（每次循环后，折线总体的高度至少改变一个单位）。那么我们无论如何是找不到一条线段能够经过无穷个折线的，因此必然不合法。

---

现在假设有 $u$ 个左括号，$v$ 个右括号，$w$ 个问号。已知合法方案里左括号和右括号数目相同，因此假设 $x$ 个问号替换成了左括号，$y$ 个问号替换成了右括号，就有：

$$
\begin{cases}
u+x=v+y \cr
x+y=w
\end{cases}
$$

因此可以解出，$x=\dfrac{v+w-u}{2}$。那么答案就是 $\dbinom{w}{x}$，记得判一下无论如何都不能让左右括号数目相等的情况。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e5+3;
const int MOD =998244353;
int n,a,b,c; char S[MAXN];
int pwr(int x,int y){
    int r=1; while(y){
        if(y&1) r=1ll*r*x%MOD; x=1ll*x*x%MOD,y>>=1; 
    }
    return r;
}
int chs(int x,int y){
    if(y<0||y>x) return 0;
    int r=1,s=1,t=1; up(1,x,i){
        r=1ll*r*i%MOD; if(i==y) s=r; if(i==x-y) t=r;
    }
    return 1ll*r*pwr(s,MOD-2)%MOD*pwr(t,MOD-2)%MOD;
}
int main(){
    scanf("%d%s",&n,S+1);
    up(1,n,i) switch(S[i]){
        case '(': ++a; break;
        case ')': ++b; break;
        case '?': ++c; break;
    }
    printf("%d\n",n%2==0?chs(c,(c+b-a)/2):0);
    return 0;
}
```

---

## 作者：0xFF (赞：7)

#### 题目大意


------------
给定一个长度为 $n$ 的只含有左括号、右括号和问号的括号序列，可以在问号处填上左括号或者右括号使得整个序列成为一个**无限长的**合法的括号序列，输出所有可能的方案数对 $998244353$ 取模的结果。

- 这里的无限长的合法的括号序列指的是可以由一个长度为 $n$ 的括号序列 $S_0$ 经过无限次重复得到的（如果实在理解不了这句话可以仔细阅读原题中的样例解释部分）


#### 思路分析


------------


首先考虑在一般情况下的括号序列需要满足以下条件：

- 对于每一个左括号，在它的右边都有唯一的右括号与它对应

再看这道题，题目描述看似唬人，实则是大大降低了此题的难度。

由于一个括号序列是无限长的，所以只要使得在 $S_0$ 中的左括号数量等于右括号数量。~~就这么简单？没错，这题还真就这么简单~~

所以答案就呼之欲出了，只需要统计出问号的数量、当前已经有的左括号数量和当前已经有的右括号数量。所以题目就转化成了在问号中填上整个序列长度一半减去当前已经有的左括号数量或者当前已经有的右括号数量。

最后，由于题目中存在分数且存在取模运算，故不能直接对分数进行取模，只需求出逆元即可。

~~别忘了开 `long long`~~

#### 代码实现


------------
```cpp
int quick_power(int x,int k){
	long long tmp = 1;
	while(k > 0){
		if(k & 1) tmp = tmp * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return tmp;
}
int main(){
	n = read();
	scanf("%s",s+1);
	for(int i=1;i<=n;i++){
		if(s[i]=='(') cnt1++;
		if(s[i]==')') cnt2++;
	} 
	res = n - cnt1 - cnt2;
	if(cnt1 > n/2 || n % 2 == 1 || res + cnt1 < n/2){
		printf("0\n");
		return 0;
	}
	int sum = 1, ans = 1;
	for(int i=1;i<=res;i++){
		sum = sum * i % mod;
		if(i == n / 2 - cnt1) ans = ans * quick_power(sum , mod - 2) % mod;
		if(i == res - n/2 + cnt1) ans = ans * quick_power(sum , mod - 2) % mod;
	}
	ans = ans * sum % mod;
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Lvlinxi2010 (赞：4)

~~本人是个萌新,第一次写题解~~

**不喜勿喷，谢谢！**

-------
**下面是正题->**

### 题目大意

在不无限循环的情况下，一个合格的序列必须满足：

1. 左右括号的数量要相等。

2. 每个右括号出现时，必须保证它左边有可以和它配对的左括号。

其实第二个条件是不必要的
~~（我就被坑了很久）~~，

原因是：无限循环可以把无法配对的右括号搬到左括号右边；

除了一种情况：当右括号出现时，所有它左边的左括号都配对完毕，

这就是不合法的序列。


令已知左括号数为 $ x $ ,右括号数为 $ y $ ，

求的就是在问号位置中填入 $ \frac n 2- x $ 个左括号的方案数。

$ 998244353 $ 是个质数，

可以用[费马小定理求逆元](https://blog.csdn.net/gaojunonly1/article/details/79965908?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164301640316780255256884%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164301640316780255256884&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79965908.first_rank_v2_pc_rank_v29&utm_term=%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%B1%82%E9%80%86%E5%85%83&spm=1018.2226.3001.4187)
。

话不多说，上代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN = 1e6 + 10;
char s[MAXN];
int n;
const int p=998244353;
long long qpow(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1){
        	ans=ans*a%p;
		}
        a=a*a%p;
        b>>=1;
    }
    return ans;
}
long long C(long long a,long long b){
    if(a<b||b<0)return 0;
    if(b==0)return 1;
    long long x=a-b;
    for(long long i=a-1;i>x;i--){
    	a=a*i%p;
	}
    for(long long i=b-1;i>1;i--){
    	b=b*i%p;
	}
    return a*qpow(b,p-2)%p;
}
int main(){
    scanf("%d",&n);
    if(n%2==1){
    	printf("%d",0);
    	return 0;
	}
    scanf("%s",s+1);
    int l=0,q=0;
    for(int i=1;i<=n;i++){
        if(s[i]=='('){
        	l++;
		}
        if(s[i]=='?'){
        	q++;
		}
    }
    printf("%lld",C(q,n/2-l));
    return 0;
}
```
**~~本蒟蒻不懂压行~~**

**码风丑陋，敬请谅解~**

**~~求过~~**


---

## 作者：2huk (赞：3)

## 题目描述

给定一个长度为 $n$ 的只含有 `(`、`)` 和 `?` 的括号序列 $S_0$，现在要在 $S_0$ 的 `?` 上面填入 `(` 和 `)`，使得将这个括号序列无限长的反复拼接后存在一个无限长的合法括号序列。问有多少种填法，答案对 $998244353$ 取模。

我们称一个括号序列 $T$ 是合法的，当且仅当它可以由以下方式生成：

- $\verb!()!$ 是一个合法的括号序列。
- 如果 $A$ 是合法括号序列，那么 $\verb!(!A\verb!)!$ 同样是一个合法括号序列。
- 如果 $A,B$ 都是合法括号序列，那么 $AB$（即 $A,B$ 拼接）同样是一个合法括号序列。

## 问题转化

如果要使得 $S_0$ 无限拼接后能得到一个长的合法括号序列，实际上我们可以把它理解成「把 $S_0$ 复制**两份**使得这个长度为 $2n$ 的括号序列中存在长度 $\ge n$ 的括号序列的数量」。

这两个问题的答案实际是一样的，所以我们着手解决这个简化版的问题。我们令 $S_1 = S_0S_0$ (也就是上面说的将 $S_0$ 复制两份得到的括号序列）。

如果 $S_0$ 本身合法，那么显然 $S_1$ 也是符合我们的要求的。

如果 $S_0$ 不合法，那么它可能会有两种情况：「`(` 和 `)` 的数量不相等」和 「`(` 和 `)` 的数量相等 但 `)` 的左边没有多余的 `(` 或  `(` 的右边没有多余的 `)`」。

- 对于情况 $1$，显然将它拼成两份后也是不符合我们的要求的。你可以举个例子，比如 $S_0 = \text{(()(}$，则 $S_1 = \text{(()((()(}$。
- 对于情况 $2$，我们可以把它变个说法，即「$S_0$ 的形式为 `...)...(...` 且这两个括号都无法匹配」。那么显然，将它复制两个为 $S_1$ 时，这两个括号就可以匹配了。你还是可以举个例子，比如 $S_0 = \text{())(}$，则 $S_1 = \text{())(())(}$。

所以，情况 $1$ 的括号形式是不可能变得合法的，情况 $2$ 的括号形式是一定可以变得合法的。所以问题也就变成了「求将 $S_0$ 中的 `?` 填充完后，使得 `(` 的数量与 `)` 相等的方案数」。

## 解决

求将 $S_0$ 中的 `?` 填充完后，使得 `(` 的数量与 `)` 相等的方案数。

如果 $\left| S_0 \right|$ 为奇数，显然不可能存在相同数量的 `(` 和 `)`，答案为 $0$。

否则，如果最开始给出的 `(` 和 `)` 的数量已经超过 $\dfrac {\left|S_0\right|}2$ 了，那么我们无论如何填充也无法改变事实，答案也为 $0$。

剩下的 $S_0$ 也就全都是合法的了。

首先我们分别统计出 `()?` 的数量为 $l,r,q$。我们想要做的是在 $q$ 个 `?` 中填入 `(` 和 `)`，使得 $S_0$ 中 `(` 与 `)` 的数量相等。

由于我们要使得 `(` 和 `)` 的数量相等，也就是 `(` 的数量和 `)` 的数量都是 $\dfrac{\left| S_0 \right|}2$，所以也就是要在现在的 $q$ 个位置中填入 $\dfrac{\left| S_0 \right|}2 - l$ 个 `(` 和 $\dfrac {\left| S_0 \right|}2 - r$ 个 `)`。方案数为 $C_{q}^{\frac{\left| S_0 \right|}2 - l}$ 或 $C_q^{\frac{\left| S_0 \right|}2 - r}$。

## 代码

```cpp
#include <iostream>

#define int long long

const int N = 1e5 + 100;

namespace Combination
{
	const int P = 998244353;

	int fac[N], inv[N];

	int mod(int a)			// a % P
	{
		return (a % P + P) % P;
	}

	int mul(int a, int b)		// (a * b) % P
	{
		return mod(mod(a) * mod(b));
	}

	int mul(int a, int b, int c)	// (a * b * c) % P
	{
		return mul(mul(a, b), c);
	}

	int fpm(int a, int b)		// (a ^ b) % P
	{
		int res = 1;
		while (b)
		{
			if (b & 1) res = mul(res, a);
			b >>= 1, a = mul(a, a);
		}
		return res;
	}

	void init(int n)		// 预处理阶乘和逆元
	{
		fac[0] = 1;
		for (int i = 1; i <= n; i ++ ) fac[i] = mul(fac[i - 1], i);
		inv[n] = fpm(fac[n], P - 2);
		for (int i = n - 1; i >= 1; i -- ) inv[i] = mul(inv[i + 1], i + 1);
	}

	int C(int x, int y)		// C(x, y) % P
	{
		if (x < y) return 0;
		if (!y) return 1;
		return mul(fac[x], inv[y], inv[x - y]);
	}
};

using namespace std;
using namespace Combination;

int n;
char c;
int l, r, q;

signed main()
{
	init(1e5 + 10);		// 预处理组合数 
	
	// 读入 
	cin >> n;
	
	for (int i = 1; i <= n; i ++ )
	{
		cin >> c;
		// 分别统计 '(', ')', '?' 的数量 
		if (c == '(') l ++ ;
		else if (c == ')') r ++ ;
		else q ++ ;
	}
	
	if (n & 1 || l > n / 2 || r > n / 2)		// 特判不合法的情况 
	{
		puts("0");
		return 0;
	}
	
	cout << C(q, n / 2 - l);		// 答案为 C(q, n / 2 - l)
	
	return 0;
}
```


---

## 作者：__Toator__ (赞：1)

组合数水题。

首先，容易想到一个合法括号串必定含有数量相同的左括号和右括号，我们假设左括号比右括号多一，由于题目中的串无限长，所以之后的每个循环节都会多出一个左括号没法配对。由此可知一个合法括号串的长度必定是偶数。特判一下奇数的情况即可。

知道这个后就很简单了，我们统计一下左括号，右括号和空位的个数。我们设串长为 $n$，空位的个数为 $x$ ，左括号的个数为 $l$，则要在空位上填 $\frac{n}{2} - l$ 个左括号，方案数为
$C^{\frac{n}{2} - l}_{x}$，求组合数即可。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL; 
const int N=1e5+5,mod=998244353; 
int n;
int cnt_l,cnt_r;
int cnt_empty;
char s[N];
LL f[N],g[N];
LL qpow(LL a,LL b){
  LL s=1;
  while(b){
  	if(b&1) s=s*a%mod;
  	a=a*a%mod;
  	b>>=1;
  }
  return s;
}
void init(){
  f[0]=g[0]=1;
  for(int i=1;i<=n;i++){
  	f[i]=f[i-1]*i%mod;
  	g[i]=g[i-1]*qpow(i,mod-2)%mod;
  }
}
LL C(LL n,LL m){
  return f[n]*g[m]%mod*g[n-m]%mod;
}
int main(){
  scanf("%d%s",&n,s);
  init();
  for(int i=0;i<n;i++)
    if(s[i]!='?')
	  s[i]=='('?cnt_l++:cnt_r++;
  int cnt_empty=n-cnt_l-cnt_r;
  if(abs(cnt_r-cnt_l)>cnt_empty||n%2==1){
  	puts("0");
  	return 0;
  }
  printf("%lld\n",C(cnt_empty,n/2-cnt_l));
  return 0;
} 
```

---

## 作者：daniEl_lElE (赞：1)

## 思路

命题：若一个序列 $\text{(}$ 和 $\text{)}$ 相等，那么就可以构造出一个无限长的括号序列。

证明：考虑优先拼接其中两个，必定存在一个括号序列。找到这个序列后在其中添加无数个原序列即可获得。

那么，我们其实只需要在 $n$ 个字符中找出所有 $\text{?}$ 并且计算是否可以构造成一个 $\text{(}$ 和 $\text{)}$ 数量相等的序列。然后组合数学处理即可。复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int mod=998244353;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1; 
	}
	return ans;
}
signed main(){
	int n;
	cin>>n;
	int l=0,r=0,qs=0;
	string s;
	cin>>s;
	for(int i=1;i<=n;i++){
		if(s[i-1]=='(') l++;
		if(s[i-1]==')') r++;
		if(s[i-1]=='?') qs++;
	}
	if(n%2==1||l>n/2||r>n/2){
		cout<<0;
		return 0;
	}
	// C(qs,n/2-l)
	int nd=n/2-l;
	int up=1,down=1;
	for(int i=1;i<=nd;i++){
		up=(up*(qs-i+1))%mod;
		down=(down*i)%mod;
	}
	cout<<(up*qp(down,mod-2))%mod;
	
	return 0;
}
```

---

## 作者：XL4453 (赞：0)

不是很难的数数题。

---
### 解题思路：

不难发现，一个括号序列满足条件的充要条件是序列中的左括号和右括号数量相等。

---
首先证明充分性。

提出一个引理，一个左括号和右括号数量相等的括号序列进行若干次将最后一个元素移动到第一个元素之前之后一定能构成一个合法的括号序列。

这个引理的的一个可行的构造性证明是这样的，将左括号看成是 $1$，右括号看成 $-1$，找出原序列中前缀和最小的一个位置，取这个位置的后一个位置作为新的序列的开头即可。

有了这个引理之后就能直接进行构造了，按照同样的方法，取元序列前缀和最小的一个位置的后一个位置作为起点，然后取任意的长度恰好等于元序列长度的若干倍的

---
然后证明必要性。

可以发现，一个长度无限的合法括号序列一定包括了无限个元括号序列，假设这个元括号序列的左括号和右括号长度不相等，那么一定要求有无限个左括号或者右括号进行补充，而左右括号相等是序列是合法序列的一个必要条件，这显然是不可能达到的。所以一定不可能出现左右括号不相等的情况。

---
数据范围很小，并不需要用到什么高超的组合数技巧。

---
### 代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define int long long
const int MOD=998244353;
int n,le,ri,uk;
char c;
int pow(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=(ans*a)%MOD;
		a=(a*a)%MOD;
		b=b>>1;
	}
	return ans;
}
int calc(int n,int m){
	if(m<0||m>n)return 0;
	int ans=1;
	for(int i=n;i>n-m;i--)ans=(ans*i)%MOD;
	for(int i=2;i<=m;i++)
	ans=(ans*pow(i,MOD-2)%MOD)%MOD;
	return ans;
}
signed main(){
	scanf("%lld",&n);
	if(n%2==1){
		printf("0\n");
		return 0;
	}
	for(int i=1;i<=n;i++){
		cin>>c;
		if(c=='(')le++;
		else if(c==')')ri++;
		else uk++;
	}
	printf("%lld\n",calc(uk,(uk+ri-le)/2));
	return 0;
}
```


---

## 作者：Galois_Field_1048576 (赞：0)

  **方案合法，当且仅当左括号数目和右括号数目相等。** 这里先给出证明：  
充分性：将所有的 $\texttt{()}$ 忽略，剩下的必然是 $\texttt{)))))).....((((((}$ （右括号和左括号个数相等），则每一个左括号在下一节必然能找到一个右括号配对。  
必要性：如果存在无穷长的序列，将所有的 $\texttt{()}$ 忽略，剩下的必然是 $\texttt{)))))).....((((((}$，前必然有有限（其实必然是 $0/1$）节无法配对，$2 \sim \infty$ 借用前面一节的左括号配对右括号。  
左括号和右括号的个数可以用 $+1$ 或 $-1$ 体现。  
假设剩下来的数为 $w$，有 $q$ 个 $\texttt{?}$ ，我们先填 $|w|$ 个括号(具体左括号或右括号按 $w$ 的符号决定)(如果 $q - |w| \lt 0$ 直接输出 $-1$)  
剩下 $q - |w|$ 个问号均匀分配左右括号。答案是$\begin{pmatrix}
q \\ \frac{q-|w|}{2}
\end{pmatrix}$ （因为问号变成的左右括号必有一个是 $\frac{q-|w|}{2}$ 个）  
简单组合即可。  
### Talk is cheap, show me the code.
```cpp
#include <iostream>
using namespace std;
int F[100006], Finv[100006], inv[100006];
#define MOD 998244353
long long C(long long n, long long m) {
	if(m < 0 || m > n) return 0;
    return F[n] * 1ll * Finv[n - m] % MOD * Finv[m] % MOD;
} 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
	int top=0;
	int n,ques=0;cin>>n;
	char r[100006];
	cin >> r+1;
	inv[1] = 1;
	for(register int i = 2; i < n+5; i ++)
	    inv[i] = (MOD - MOD / i) * 1ll * inv[MOD % i] % MOD;
	    
	F[0] = Finv[0] = 1;
	for(register int i = 1; i < n+5; i ++)
	    F[i] = F[i-1] * 1ll * i % MOD,
	    Finv[i] = Finv[i-1] * 1ll * inv[i] % MOD;
	for (int i=1;i<=n;++i)
		if (r[i]=='(') top++; 
		else if (r[i] == ')') top--;
		else ques ++; 
	if (ques - abs(top) < 0 || ques - abs(top) & 1) {
		cout << 0 << endl;
		return 0;
	} 
	cout << C(ques,(ques-abs(top))/2) << endl; 
	return 0; // I AK IOI!
} 
```

---

## 作者：bmatrix (赞：0)

Upd.2022.2.3 代码写的太烂，删了（

[题目传送门](https://www.luogu.com.cn/problem/P8007)

这题如果不仔细分析的话，很容易被当成 DP 白白浪费很多时间（就像我）。

首先根据题意，可以认为左右括号是一种相互“抵消”的关系：

**对于每个左括号，它右面总要有且仅有一个对应的右括号与其配对**，才能使其成为一个合法括号序列。

在已知序列不无限循环的时候，为了使一个序列为合法括号序列，我们需要保证的条件有：

1. 左右括号数目相等。
2. 每个右括号出现时，必须保证它左边有**可以和它配对的**左括号。

如果还是不理解，可以看下代码：
```cpp
bool check(){
    int l=0;//统计左右括号之差
    for(int i=1;i<=n;i++){
        if(s[i]=='(')l++;
        else{
            if(l==0)return 0;//保证右括号左边有可以和它配对的左括号
            else l--;
        }
    }
    return l==0;//保证左右括号数目相等
}
```

但是在**无限循环**的情况下，我们只需要保证左右括号相等即可，证明如下：

首先如果不相等，它一定不是合法括号序列，因为这样即使无限循环下去，也一定存在无法配对的括号，这是显然的。

在左右括号相等时，序列不合法的情况只有一个：即当一个右括号出现时，左边所有左括号都配对完了，没有剩下和它配对的了，例如  `(()())))((`。

由于左右括号数目相等，无法配对的右括号一定和无法配对的左括号数目相等。

那么，**如果将无法配对的右括号都搬到无法配对的左括号右边，这个序列就一定是一个合法括号序列了**。

比如，对于 `(()())))((` ，我们如果将 `(()())))` 都搬到序列右边，使无法配对的右括号和无法配对的左括号配上对，得到的 `(((()())))` 就一定是一个合法括号序列。

**而题目中的“无限循环”正帮我们实现了这个“搬”的过程。**

~~证毕。~~

那么这题的任务就变成了“求出所有问号的填法中能使左右括号数目相等的方案数  $\bmod\, 998244353$ 的值”。

由于左右括号数目之和等于 $n$ 且左右括号数目相等，左右括号的数目一定都等于 $\frac n 2$，同时如果 $n$ 是奇数一定无法满足条件。

令已知的左括号数目为 $l$，问号数目为 $q$，求的就是在所有问号中填入 $\frac n 2-l$ 个左括号的方案数，即 $\binom{q}{\frac n 2-l}$。

那么剩下的就是老生常谈的求组合数了，由于 $998244353$ 是个质数，利用费马小定理求逆元就可以了。

代码太丑，略了。

---


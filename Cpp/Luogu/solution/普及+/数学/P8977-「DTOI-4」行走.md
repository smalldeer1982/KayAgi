# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# 题解

## 作者：xiaoqian02 (赞：4)

刚打完比赛，来水个题解。

这篇题解讲 dfs 做法，但是我觉得应该也有 bfs 做法。

个人认为这篇题解还算比较好理解。
### 第一部分：思路
~~这道题我一直以为从任意点开始走都可以，于是耗了 $15$ 分钟，直到同学提醒我……~~

既然只能从 $1$ 开始，就好办一点。

首先，我们知道，一定不能经过权值为 $-1$ 的点。因为如果在第 $k$ 个点经过 $-1$，一定有 $\sum\limits_{j=k+1}^{|P|} \frac{1}{2^{j-1}} + ( - \frac{1}{2^{k-1}}) < 0$。不可能经过无穷多个点，取不到等号，反而亏了。

~~就这样，一个 $-1$ 毁掉了一切。~~

所以，只能走 $1$ 或 $0$。感谢良心的出题人与良心的小 L，没有搞出乱七八糟的权值。

同时，我们也能证明能走 $1$ 时走 $1$ 一定比走 $0$ 优。而且根据题目里字典序的定义，最后不能有多余的 $0$，否则去掉了字典序更小。

直接这么写，其实 Subtask $5$ 就过了。但我们的目标不是 $20$ 分，而是 $100$ 分。

由于这道题的字典序比较坑，所以我们不用链式前向星，而是用 vector 来存边（邻接表）。存完边排个序就可以了。

具体 dfs 的过程写在 dfs 代码注释里（应该算比较详细了）。
```cpp
bool dfs(int p,int fr,int dep)
//由于建了双向边，fr 存从哪里过来的，避免再回去
//dep 存深度，便于修改 qz 数组
//a 是权值，ed 是边（用 vector 存），nxt 存下一个怎么走最大（为 0 表示停下来最大），qz 是当前最大值（二进制）
//mx 存储从当前点出发能到的点权值的最大值，便于控制接下来全是 0 的情况
//dfs 函数是 bool 类型因为要存下来走这一条有没有更新最大值，如果更新了就要把 nxt 连过去。bg 就是存有没有更新的
{
	int mx=-1;
	bool bg=0;
	for(int i=0;i<ed[p].size();i++)
	{
		int k=ed[p][i];
		if(k==fr) continue;
		mx=max(mx,a[k]);
		if(a[k]==-1) continue;//-1 一定不走
		if(a[k]==1)//能走 1 一定走 1
		{
			if(qz[dep]==0)
			{
				if(mxd<dep) mxd=dep;//更新一下长度，便于之后再更新时清零
				qz[dep]=1;
				nxt[p]=k;//连过去
				bg=1;//能更新
				for(int j=dep+1;j<=mxd;j++) qz[j]=0;//后面全部清零
			}
			bool pp=dfs(k,p,dep+1);//这条路下去有没有更新
			if(pp) nxt[p]=k,bg=1;//更新了就连过去
		}
	}
	if(mx==-1) return 0;//走不下去了
	if(mx==0)
	{
		if(qz[dep]==1) return 0;//最大值能取到 1 但是接下来只有 0
		for(int i=0;i<ed[p].size();i++)
		{
			int k=ed[p][i];
			if(k==fr) continue;
			if(a[k]==-1) continue;
			bool pp=dfs(k,p,dep+1);
			if(pp) nxt[p]=k,bg=1;
		}
	}
	return bg;
}
```
dfs 结束之后还要特判。

- 如果 $a_1=-1$，后面是怎么加都加不到 $0$ 的。所以我们什么都不干，直接 `return 0;` 就可以了。这个其实应该在 dfs 前判断，但因为也是特判，所以放到这里一起说。

- 如果 $a_1=0$ 且 $nxt_i=0$，说明只走到 $1$ 最优，当然这等同于什么都不干，所以也不输出。

最后输出一下，就能愉快地 AC 了。

### 第二部分：完整代码

dfs 部分前面给过，这一段就不加注释了。
```cpp
#include<bits/stdc++.h>
using namespace std;
void IOS()//cin 优化
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
}
vector<int> ed[500005];
//vector 存边
//P.S.本蒟蒻之前从来没用过 vector，这次是第一次
int n,u,v,mxd,a[500005],nxt[500005];
int qz[500005];
bool vis[500005];
bool dfs(int p,int fr,int dep)
{
	int mx=-1;
	bool bg=0;
	for(int i=0;i<ed[p].size();i++)
	{
		int k=ed[p][i];
		if(k==fr) continue;
		mx=max(mx,a[k]);
		if(a[k]==-1) continue;
		if(a[k]==1)
		{
			if(qz[dep]==0)
			{
				if(mxd<dep) mxd=dep;
				qz[dep]=1;
				nxt[p]=k;
				bg=1;
				for(int j=dep+1;j<=mxd;j++) qz[j]=0;
			}
			bool pp=dfs(k,p,dep+1);
			if(pp) nxt[p]=k,bg=1;
		}
	}
	if(mx==-1) return 0;
	if(mx==0)
	{
		if(qz[dep]==1) return 0;
		for(int i=0;i<ed[p].size();i++)
		{
			int k=ed[p][i];
			if(k==fr) continue;
			if(a[k]==-1) continue;
			bool pp=dfs(k,p,dep+1);
			if(pp) nxt[p]=k,bg=1;
		}
	}
	return bg;
}
int main()
{
	IOS();
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++)
	{
		cin>>u>>v;
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	for(int i=1;i<=n;i++) sort(ed[i].begin(),ed[i].end());//排个序，方便按字典序来
	if(a[1]==-1) return 0;
	dfs(1,-1,0);
	if(a[1]==0&&!nxt[1]) return 0;
	for(int i=1;i;i=nxt[i]) cout<<i<<" ";
	cout<<endl;
	return 0;
}
```
### 第三部分：Others
~~这个小 L 确实很无聊~~

~~std 看起来好长啊~~

这题的数据需要加强一下，不然可以用可以过大多数数据的错解面向数据编程，然后过这道题。

有依赖的捆绑挺好的，有些错解大数据能过但小数据过不去，导致最后 $20$ 分。

最后，如果你的代码过不去，给一组可能的 hack（至少 hack 掉了同机房的同学）：
```
Input:
10
0 0 0 0 0 1 0 0 0 1
1 2
2 3
3 4
4 5
5 6
1 7
7 8
8 9
9 10
Output:
1 7 8 9 10
```

---

## 作者：Hovery (赞：4)

## 前言

记得判空！！！

## Sol

首先可以发现一点，$-1$ 是不能走到的，要不然后面全是 $1$ 也不会更优。

然后考虑先走到一个 $1$ 肯定比当前不走 $1$ 后面全走 $1$ 来得优。

所以就可以先走 $1$ 直到不能走了再去走 $0$。

由于路径数很少，可以考虑用广搜。

对于当前点我们设它是第 $x$ 个被访问到的，并且走到它为止已经有了 $y$ 个 $1$。

然后这个点能继续往下搜的条件是对于所有与它被访问到的时间相同的点，它的 $y$ 必须是最大的，这个很显然，要不然就不会更优。

## Code

~~感觉还是看代码更好理解~~

```
#include<bits/stdc++.h>
#define pb push_back
using namespace std;

int n, m, a[500010], mx[500010], vis[500010], f[500010];
vector<int> G[500010];
queue< tuple<int, int, int> > q;
pair<int, int> ans;
vector<int> anss;

void dfs(int now, int fa)
{
    for (auto i : G[now])
    if (i != fa)
    {
        f[i] = now;
        dfs(i, now);
    }
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    for (int i = 1;i <= n;i++)
    {
        cin >> a[i];
    }
    if (a[1] == -1)
    {
        return 0;
    }
    for (int i = 1;i < n;i++)
    {
        int x, y;
        cin >> x >> y;
        G[x].pb(y);
        G[y].pb(x);
    }
    for (int i = 1;i <= n;i++)
    {
        sort(G[i].begin(), G[i].end());
    }
    q.push({1, 0, a[1] == 1});
    ans = {1, a[1] == 1};
    while (!q.empty())
    {
        auto [x, dep, val] = q.front();
        q.pop();
        vis[x] = 1;
        if (val < mx[dep])
        {
            continue;
        }
        if (val > ans.second)
        {
            ans = {x, val};
        }
        for (auto i : G[x])
        if (!vis[i] && a[i] != -1)
        {
            int _ = val + (a[i] == 1);
            mx[dep + 1] = max(mx[dep + 1], _);
            q.push({i, dep + 1, _});
        }
    }
    if (ans.second == 0)
    {
        return 0;
    }
    dfs(1, 0);
    int now = ans.first;
    while (now != 1)
    {
        anss.pb(now);
        now = f[now];
    }
    anss.pb(1);
    reverse(anss.begin(), anss.end());
    for (auto i : anss)
    cout << i << ' ';
}
```

---

## 作者：Leasier (赞：4)

首先我们需要注意到：**我们一定不会选任何 $-1$。**

证明：假定我们选择了一个 $a_{P_i} = -1$，则最优情况下路径 $P$ 的后缀 $[i, |P|]$ 的贡献为 $-\frac{1}{2^{i - 1}} + \displaystyle\sum_{j = i + 1}^{|P|} \frac{1}{2^{j - 1}} = -\frac{1}{2^{|P| - 1}} < 0$，即选了不如不选。

首先判掉 $a_1 = -1$ 的情况，此时答案为空。

否则，我们选择的方案一定为一条从 $1$ 出发且点权不为 $-1$ 的路径。下面的讨论中我们默认去除了树上所有 $a_i = -1$ 的点 $i$ 及其子树。

此时我们还需要注意到：**如果当前这一步可以选 $1$，我们一定不会选 $0$。**

证明：假定我们选择了一个 $a_{P_i} = 0$，则最优情况下路径 $P$ 的后缀 $[i, |P|]$ 的贡献为 $\displaystyle\sum_{j = i + 1}^{|P|} \frac{1}{2^{j - 1}} = \frac{1}{2^{i - 1}} - \frac{1}{2^{|P| - 1}}$；假定我们选择了一个 $a_{P_i} = 1$，则最坏情况下路径 $P$ 的后缀 $[i, |P|]$ 的贡献为 $\frac{1}{2^{i - 1}}$。即当前这步选 $0$ 一定不如选 $1$。

现在来总结一下我们选 $P$ 的策略；

- 每一步尽量选 $1$。
- 实在不行了再选 $0$。
- 字典序最小。

我们考虑将目前所有**不考虑字典序**的情况下可能最优的当前路径深度最大的位置存在一个数组 $a$ 里，初始 $a = [1]$。

现在我们希望尽量选尽量长的全 $1$ 连续段，则我们每次**能选 $1$ 就尽量选，否则选 $0$**。扫一遍 $a$ 中的点的儿子并更新 $a$ 即可。

但是这样做得到的路径还是不一定优——因为末尾的若干 $0$ 对路径权值没有贡献，而我们留着它们反而会让字典序变大。所以我们最后还要扔掉得到的路径末尾的权值为 $0$ 的点。

这里需要注意的一点是：**出于末尾 $0$ 的问题，最终所有 $P$ 值相同的路径终点都需要保留下来讨论。**

时间复杂度为 $O(n)$。

代码：
```cpp
#include <stdio.h>

typedef struct {
	int nxt;
	int end;
} Edge;

int cnt = 0;
int a[500007], head[500007], fa[500007], dot1[500007], dot2[500007], dot3[500007], ans[500007];
bool mark1[500007], mark2[500007], vis[500007];
Edge edge[1000007];

inline int read(){
	int sign = 1, ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		if (ch == '-') sign = -sign;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return sign * ans;
}

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void dfs1(int u, int father){
	fa[u] = father;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father){
			mark1[u] |= a[x] == 1;
			mark2[u] |= a[x] != -1;
			dfs1(x, u);
		}
	}
}

void dfs2(int u){
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != fa[u]){
			dfs2(x);
			vis[u] |= vis[x];
		}
	}
}

void dfs3(int u, int &len){
	int nxt = 0x7fffffff;
	ans[++len] = u;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != fa[u] && vis[x] && nxt > x) nxt = x;
	}
	if (nxt != 0x7fffffff) dfs3(nxt, len);
}

int main(){
	int n = read();
	for (register int i = 1; i <= n; i++){
		a[i] = read();
	}
	if (a[1] == -1) return 0;
	int cnt1 = 0, cnt2 = 0, len = 0;
	for (register int i = 1; i < n; i++){
		int u = read(), v = read();
		add_edge(u, v);
		add_edge(v, u);
	}
	dfs1(1, 0);
	dot1[++cnt1] = 1;
	while (true){
		int cnt3 = 0;
		bool flag = false;
		for (register int i = 1; i <= cnt1; i++){
			if (mark1[dot1[i]]){
				flag = true;
				break;
			}
		}
		if (!flag){
			for (register int i = 1; i <= cnt1; i++){
				dot2[++cnt2] = dot1[i];
				if (mark2[dot1[i]]) flag = true;
			}
			if (!flag) break;
			for (register int i = 1; i <= cnt1; i++){
				int u = dot1[i];
				for (register int j = head[u]; j != 0; j = edge[j].nxt){
					int x = edge[j].end;
					if (x != fa[u] && a[x] == 0) dot3[++cnt3] = x;
				}
			}
		} else {
			cnt2 = 0;
			for (register int i = 1; i <= cnt1; i++){
				int u = dot1[i];
				for (register int j = head[u]; j != 0; j = edge[j].nxt){
					int x = edge[j].end;
					if (x != fa[u] && a[x] == 1) dot2[++cnt2] = dot3[++cnt3] = x;
				}
			}
		}
		cnt1 = cnt3;
		for (register int i = 1; i <= cnt3; i++){
			dot1[i] = dot3[i];
		}
	}
	for (register int i = 1; i <= cnt2; i++){
		vis[dot2[i]] = true;
	}
	dfs2(1);
	dfs3(1, len);
	while (len > 0 && a[ans[len]] == 0) len--;
	for (register int i = 1; i <= len; i++){
		printf("%d ", ans[i]);
	}
	return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：3)

好像实现和其他题解均不同。

先分析题目。

显然往 $-1$ 走显然不优。  
那只需考虑点权非负的情况。

先不考虑字典序。  
我们按深度递增考虑每个节点。

考虑对于当前节点 $u$：
- 如果 $\exists v\in son(u)\ \text{s.t.}\ a_v=1$，那么 $\forall v \in son(u)$，$a_v=0$ 就不优了。
- 否则只有 $\forall v \in son(u)$，$a_v=0$ 是候选集合。

那么我们使用一个 bfs 即可知道 $a_{P_i}$ 的具体数值。

现在考虑字典序。

记 $d_u$ 为 $u$ 到根的简单路径经过的边数。  
在 bfs 中我们可以顺带求出每个点 $u$ 是否可能为 $P_{d_u}$。

做一个类似 dfs，每次选择字典序最小的可能点即可。

注意由于要求字典序最小，所以 $a_{P_i}$ 的后缀 $0$ 是要被割掉的。

代码很短很好写。

```cpp
const int N=5e5+3;
int n,m,a[N],pa[N],c[N];
bool f[N];
sd vector<int>G[N],ans,_[N];
void bfs()
{
  _[0].push_back(pa[1]=1),c[0]=a[1]==1;
  for(int i=0;_[i].size();++i)
  {
    for(int u:_[i]) for(int v:G[u]) pa[v]||!a[v]||(_[i+1].push_back(v),pa[v]=u);
    c[i+1]=!!_[i+1].size();
    if(!_[i+1].size()) for(int u:_[i]) for(int v:G[u]) pa[v]||(_[i+1].push_back(v),pa[v]=u);
  }
  for(m=n;~m&&!c[m];--m);
  for(int u:_[m]) f[u]=1;
  if(m<0) return;
  for(int i=m;i--;) for(int u:_[i+1]) f[pa[u]]|=f[u];
  return;
}
void Solve()
{
  rd(n);
  for(int i=1;i<=n;++i) rd(a[i]);
  for(int i=1,u,v;i<n;++i) rd(u,v),~a[u]&&~a[v]&&(G[u].push_back(v),G[v].push_back(u),7);
  for(int i=1;i<=n;++i) sd stable_sort(begin(G[i]),end(G[i]));
  bfs();
  if(m<0) return;
  for(int u=1;ans.size()<m;)
    for(int v:G[u]) if(v^pa[u]&&f[v])
    {
      ans.push_back(u=v);
      break;
    }
  wrt("1 ");
  for(int x:ans) wrt(x,' ');
  return;
}
```

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/119113492)。

---

## 作者：肖翔 (赞：2)

给个挺蠢的做法：

可以把题目给出的 $f(P)$ 看成一种奇怪的二进制，

走一条路径相当于从高位向低位填数。

显然高位能填 $1$ 一定比填 $0$ 好，同理 $0$ 一定比 $-1$ 好。

我们考虑对每个点，求一下它往下走能得到的最大二进制数。

但是直接做位数是 $O(n)$ 的，时空都会爆炸。

容易发现我们的二进制数中只会有 $0,1$。

我们只维护二进制数中为 $1$ 的位置。

类似树形 DP 的转移即可，每次选子树中的最大二进制数，再更新当前位。

这样直接模拟可以用 `deque`。

但！是！

这题的 `deque` 会炸空间。我们要用 `vector`，维护一下翻转后的位置序列。

每次做完记得清空子树的 `vector`，这样同一时刻只会维护 $O(n)$ 个位置。

于是做完了，跑的很慢但能过。

但似乎还是比大多数人的直接 `dfs` 快，原理未知。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10;
const int M=1e6+10;
struct edge{
	int v,nxt;
}e[M];
int h[N],Cnt;
inline void add(int x,int y){
	e[Cnt].v=y;
	e[Cnt].nxt=h[x];
	h[x]=Cnt++;
	return;
}
const int inf=0x7f7f7f7f;
int n;int a[N];
vector<int>v[N];
inline int cmp(int a,int b){
	int l=v[a].size()-1,r=v[b].size()-1;
	while(l>=0&&r>=0){
		if(v[a][l]<v[b][r])return 1;
		if(v[a][l]>v[b][r])return -1;
		l--;r--;
	}
	if(v[a].size()<v[b].size())return -1;
	if(v[a].size()>v[b].size())return 1;
	return 0;
}
int to[N];bool ok[N];
inline void pre(int x,int fa,int dep){
	to[x]=inf;
	for(int i=h[x];~i;i=e[i].nxt){
		int y=e[i].v;
		if(y==fa)continue;
		pre(y,x,dep+1);
		int c=cmp(y,x);
		if(c==1){
			swap(v[x],v[y]);	
			to[x]=y;
		}
		if(c==0&&y<to[x]){
			to[x]=y;
		}
	}
	for(int i=h[x];~i;i=e[i].nxt){
		int y=e[i].v;
		if(y==fa)continue;
		vector<int>().swap(v[y]);
	}
	if(a[x]==1)v[x].push_back(dep);
	if(v[x].size())ok[x]=1;
	return;
}


signed main(){
	int x,y;memset(h,-1,sizeof(h));
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i]; 
	for(int i=1;i<n;i++){
		cin>>x>>y;
		if(a[x]==-1||a[y]==-1)continue;
		add(x,y);
		add(y,x);
	}
	pre(1,0,1);
	int now=1;
	if(v[1].size()==0||a[1]==-1)return 0;
	while(now!=inf&&ok[now]){
		cout<<now<<" ";
		now=to[now];
	}
}
```


---

## 作者：Nuyoah_awa (赞：1)

本题是一个 DFS 题。

赛时漏掉了很多小细节就挂了。

### 题目大意
给定有点权的一棵树，从 $1$ 开始遍历，求 $f(p)$ 最大且字典序最小的路径。

### 题目分析

看了眼数据，$n \le 5 \times 10 ^ 5$ 不是很大，考虑 dfs 枚举每条路径。

然后来说说剪枝优化。
1. 首先，如果经过一个点权为 $-1$ 的点，这个点会减 $\displaystyle\frac{1_{}}{2^{i}}$，而他后面的点最多加 $\displaystyle\sum_{j = i + 1}^{|p|} \frac{1}{2^{j}}$，两数相减可得 $\displaystyle\frac{1_{}}{2^{i}} - \displaystyle\sum_{j = i + 1}^{|p|} \frac{1}{2^{j}} = \frac{1}{2^{p}} > 0$ 也就是说后面怎么加都加不回来了，所以不能遍历点权为 $-1$ 的点。
2. 题目要求字典序最小，就可以先把边按照字典序排好，这样遍历到的第一个就是字典序最小的了。
3. 很明显，走点权为 $1$ 的点比走点权为 $0$ 的点要大，也可以通过 $1.$ 的公式证明。
4. 最后，怎么判断路径为空，~~（我赛时也没想出来）~~，其实就是当树只有一个点或一号点的点权为 $0$ 或 $-1$ 时，路径为空。

我开始使用数组存答案，比较麻烦，还不好回溯，后来借鉴了大佬的链表法，由于是一棵树，我们可以建一个数组 $nx$ 用来表示从这个点往下，往哪个子节点走是最优路径。我们从该点遍历子节点，更新当前节点的最优路径。

由于输入输出过多，建议使用 scanf,printf 或快读快写并开 O2，要不然会 TLE。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 500005;
long long n, u, v, ans, a[N], nx[N], tot[N];
vector <long long> e[N];
bool dfs(long long x, long long last, long long deep)
{
	long long maxn = -1;
	bool flag = false;
	for(long long i = 0;i < e[x].size();i++)
	{
		if(e[x][i] == last)
			continue;
		maxn = max(maxn, a[e[x][i]]);
		if(a[e[x][i]] == -1)
			continue;
		if(a[e[x][i]] == 1)
		{
			if(tot[deep] == 0)
			{
				if(ans < deep)
					ans = deep;
				tot[deep] = 1;
				nx[x] = e[x][i];
				flag = true;
				for(long long j = deep + 1;j <= ans;j++)
					tot[j] = 0;
			}
			if(dfs(e[x][i], x, deep + 1))
				nx[x] = e[x][i], flag = true;
		}
	}
	if(maxn == -1)
		return 0;
	if(maxn == 0)
	{
		if(tot[deep] == 1)
			return 0;
		for(long long i = 0;i < e[x].size();i++)
		{
			if(e[x][i] == last || a[e[x][i]] == -1)
				continue;
			if(dfs(e[x][i], x, deep + 1))
				nx[x] = e[x][i], flag = true;
		}
	}
	return flag;
}
int main()
{
	scanf("%lld", &n);
	for(long long i = 1;i <= n;i++)
		scanf("%lld", &a[i]);
	for(long long i = 1;i < n;i++)
	{
		scanf("%lld %lld", &u, &v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(long long i = 1;i <= n;i++)
		sort(e[i].begin(), e[i].end());
	if(a[1] == -1)
		return 0;
	dfs(1, -1, 0);
	if(a[1] == 0 && nx[1] == 0)
		return 0;
	for(long long i = 1;i > 0;i = nx[i])
		printf("%lld ", i);
	printf("\n");
	return 0;
}
```

---

## 作者：Nicrobot (赞：0)

以下，令 $dep(x)$ 表示 $x$ 的深度，$fa(x)$ 表示 $x$ 的父节点。

我们知道不等式：


$$
\sum_{y=x+1}^{k}\dfrac{1}{2^y} < \dfrac{1}{2^x}
$$

其中 $k$ 为 $>x$ 的整数。

所以有如下结论：

**结论 1**：

- 对于任意结点 $x$，若 $a_x=-1$ 则该节点不会被路径经过。

如果经过了 $-1$，后面即使全部是 $1$ 也不够凑。

**结论 2**：

- 对于任意结点 $x$，若 $a_x=0$ ，$y$ 为与 $x$ 深度相同的一个点且 $a_y=1$，且满足 $1 \to fa(x)$ 和 $1 \to fa(y)$ 的简单路径上的点的点权全部对应相同，则该节点不会被路径经过。

 $y$ 加上了 $1/2^{dep(y)}$，$x$ 没有变，而后面 $x$ 怎样都凑不够。

---

根据上述结论，我们便可以使用广度优先搜索（BFS）算法求出点权最大的路径。为了保证字典序，我们可以用 `vector` 存图，对每个点的每条出边按照点的编号排序，这样就可以知道字典序最小的路径了。

注意特判 $a_1=-1$。

```cpp
#include <bits/stdc++.h>

const int N = 5e5 + 10;

int n, a[N];
int d[N]; // 深度
int cmx[N]; // 每层最值
int val[N]; // 由 1 到 x 路径上 1 点数 
bool vis[N]; // bfs 标记经过
std::vector<int> e[N];

inline int read()
{
    int x = 0, o = 1;
    char ch = getchar();
    while ((ch < '0' || ch > '9') && ch != EOF)
    {
        if (ch == '-')
            o = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = x * 10 + (ch - '0'), ch = getchar();
    return x * o;
}

void dfs1(int now, int fa, int dep)
{
    d[now] = dep;
    for (int i : e[now])
    {
        if (i != fa)
        {
            dfs1(i, now, dep + 1);
        }
    }
}

int bfs()
{
    std::queue<int> q;
    int ans = 0;
    val[1] = a[1], q.push(1);
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        if (vis[x] || val[x] < cmx[d[x]]) // 曾经经过，或点数不够
            continue;
        if (val[x] > val[ans])  // 记录答案
            ans = x;
        vis[x] = 1;
        for (int i : e[x])
        {
            if (!vis[i])
            {
                val[i] = val[x] + a[i];
                cmx[d[i]] = std::max(cmx[d[i]], val[i]); // 记录层内最值
                q.push(i);
            }
        }
    }
    return ans;
}

// 求出路径
std::vector<int> s;
void dfs2(int now, int fa, int to) 
{
    s.push_back(now);
    if (now == to)
    {
        for (int i : s)
            std::cout << i << ' ';
        std::cout << std::endl;
        exit(0);
    }
    for (int i : e[now])
        if (i != fa)
            dfs2(i, now, to);
    s.pop_back();
}

int main()
{
    n = read();
    for (int i = 1; i <= n; i++)
        a[i] = read();
    for (int i = 1; i < n; i++)
    {
        int u, v;
        u = read(), v = read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    // 排序保证字典序
    for (int i = 1; i <= n; i++)
        std::sort(e[i].begin(), e[i].end());
    if (a[1] == -1)
        return 0;
    dfs1(1, 0, 0);
    int to = bfs();
    dfs2(1, 0, to);
    return 0;
}
```

---

## 作者：Epoch_L (赞：0)

## Solution
首先用浮点数存这个权值肯定是存不下的，肯定是存在某种结论只跟单个点的点权有关。

我们知道一个不等式：
$$
\frac 1{2^i}< \displaystyle\sum_{j=i+1}^{+\infty} \frac{1}{2^j}
$$
事实上知道极限的话右边的式子是等于 $\frac{1}{2^i}$ 的，但在这题 $+\infty$ 实际只能取到 $5\times 10^5$，故不等号成立。

因为每个点的贡献跟其深度有关，所以考虑进行 bfs，一层一层考虑，能够得到很多结论：

+ 不可能走 $-1$ 这个点。根据上面的不等式，就算后面全是 $1$，都消除不了 $-1$ 所产生的负贡献，所以不如遇到 $-1$ 直接停下来。

于是可以特判掉 $a_1=-1$。并且连边时如果有一端是 $-1$ 就不连。

+ 当 $1$ 和 $0$ 同时存在时，走 $1$ 比走 $0$ 优。同理就算 $0$ 后面全是 $1$，也比不上当前的 $1$ 贡献大。

于是有一个走的策略：优先走 $1$ 再走 $0$。

按照上面的思路可以写出代码，最后会在某一层出现一些决策点，从根走到这些点都是满足权值最大的。为了满足字典序最小的问题，做一遍 dfs，记 $ok_u$ 表示 $u$ 的子树内是否存在决策点。最后从 $1$ 出发，走它儿子中最小的满足 $ok_i=1$ 的点即可。

因为我们遇到 $0$ 还会继续往下判断，所以可能会出现某条路径最后有一段 $0$，这会使字典序变大。可以考虑每一层都开一个 vector 记最优决策，最后如果当前层的点权都是 $0$，就一直往上跳。

## Code
此题数据较强，有很多 corner case，一些细节写在代码注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mkp make_pair
#define fi first
#define se second
using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using ull=unsigned long long;
inline void read(int &x){
  char ch=getchar();
  int r=0,w=1;
  while(!isdigit(ch))w=ch=='-'?-1:1,ch=getchar();
  while(isdigit(ch))r=(r<<1)+(r<<3)+(ch^48),ch=getchar();
  x=r*w;
}
const int N=5e5+7;
int n,fa[N],now,a[N];
vector<int>edge[N];
vector<int>q[N];
bool ok[N];
bool cmp(int x,int y){return a[x]>a[y];}
void dfs(int u,int f){fa[u]=f;for(int v:edge[u])if(v!=f)dfs(v,u);}//第一遍dfs处理每个点的父亲
void dfs1(int u){for(int v:edge[u])if(v!=fa[u])dfs1(v),ok[u]|=ok[v];}//第二遍dfs处理ok
void write(int u){
  printf("%d ",u);
  sort(edge[u].begin(),edge[u].end());//走最小的
  for(int v:edge[u])if(v!=fa[u]&&ok[v]){write(v);break;}
}
void bfs(){
  q[1].pb(1);
  while(!q[++now].empty()){
    sort(q[now].begin(),q[now].end(),cmp);//将点权从大到小排
    int tmp=a[q[now][0]];
    while(a[*(--q[now].end())]!=tmp)q[now].pop_back();//跟最大点权不一样的不要
    for(int u:q[now])for(int v:edge[u])if(v!=fa[u])q[now+1].pb(v);//下一层的决策点。
  }
  now--;
  while(now>1&&a[q[now][0]]==0)now--;//注意now>1，因为q[0][0]不存在，会RE
  if(now==1&&a[1]==0)exit(0);//特判一下
  for(int u:q[now])ok[u]=1;
}
int main(){
  read(n);
  for(int i=1;i<=n;i++)read(a[i]);
  if(a[1]<0)return 0;
  for(int i=1,x,y;i<n;i++){
    read(x),read(y);
    if(a[x]<0||a[y]<0)continue;
    edge[x].pb(y),edge[y].pb(x);
  }
  dfs(1,0);bfs();
  dfs1(1);write(1);
  return 0;
}
```

---

## 作者：是青白呀 (赞：0)

## 「DTOI-4」行走
### 基本做法：BFS

### 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

请你求出一条起点为节点 $1$ 的**简单有向路径**，或选择一条空路径，使得 $ \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$ 最大。输出字典序最小的路径。

### 分析

观察原式发现，每个节点的权值在计入贡献时被乘上了一个数 $\displaystyle\frac{1}{2^{i - 1}}$。我们很容易联想到一个众所周知的不等式。

$\displaystyle\frac{1}{2^{i}}>\frac{1}{2^{i+1}}+\frac{1}{2^{i+2}}+\frac{1}{2^{i+3}}+...+\frac{1}{2^{i+\infty}}$

我们可以得到如下结论。

1. 无论如何都不能选权值为 $-1$ 的点，因为纵使后面有再多的权值为 $1$ 的点，也无法挽回被减去的值，还不如就此打住不选了。

2. 某个节点同时有权值为 $1$ 和 $0$ 的节点时，一定选权值为 $1$ 的节点，因为纵使权值为 $0$ 的节点以后有再多的权值为 $1$ 的点，也无法达到此刻加上的这个 $\displaystyle\frac{1}{2^{i - 1}}$。

对于权值为 $-1$ 的点的处理很简单，在连边时，若发现该边连接的节点有权值为 $-1$ 的，就不连这条边，以此断绝后患，一劳永逸。

```cpp
for(int i=1;i<n;i++){
		int x,y;
		read(x),read(y);
		if(a[x]==-1||a[y]==-1)continue;
		add(x,y);
		add(y,x);
	}
```

此时树上的节点权值全为 $0$ 或 $1$。由结论 2 发现，当我们在比较两条路径的贡献时，其实是从根往叶子**逐层比较、一票否决**，因为原式中乘上的 $\displaystyle\frac{1}{2^{i-1}}$ 中 $i$ 就为该点的深度。于是我们容易想到使用 BFS 模拟比较的过程。在比较的过程中，若该层既有权值为 $1$ 的节点，又有权值为 $0$ 的点，就删掉所有权值为 $0$ 的点向上连的边。

具体的实现也很简单。多开一个新队列，当该层的节点没有判断完时，下一层的节点先暂存在该队列中。当原队列中的该层节点全部处理完，再讲下一层的所有节点转移到原队列中去即可。作者在比赛时使用了优先队列使得所有权值为 $0$ 的点先出队列，但其实使用普通队列，出队后再判断也可以，耗时相差不大。

```cpp
struct node{
	int val,id;
	friend bool operator<(node x,node y){
		return x.val>y.val;
	}
};

void bfs(int st){
	queue<int>q;
	priority_queue<node>p;
	int dep=1;
	p.push((node){a[st],st});
	dep1[dep]=a[st];//dep1是用来记录该层有无权值为1的点的
	while(!p.empty()||!q.empty()){
		if(dep1[dep]&&!p.empty()){
			while(!p.top().val){
				node x=p.top();
				p.pop();
				e[fe[x.id]].del=1;//del标记为1即该边被删除了
			}
		}
		node x=p.top();
		p.pop();
		for(int i=fir[x.id];i;i=e[i].nxt){
			if(e[i].to==fa[x.id])continue;
			q.push(e[i].to);
		}
		if(p.empty()){
			dep++;
			while(!q.empty()){
				p.push((node){a[q.front()],q.front()});
				if(a[q.front()]==1)dep1[dep]=1;
				q.pop();
			}
		}
	}
}
```
此时的树已经很接近我们想要的样子了。它可能长这样。
![](https://cdn.luogu.com.cn/upload/image_hosting/180af05p.png)

（其中褐色的是权值）

树上仍有一些节点躲过了比较留存下来，但我们想要的其实是该树中深度最大的一条路径（即1-3-4），因为在这棵树中，每一层节点的权值已经相等了（不相等的话权值为 $0$ 的早就被删去）。所以在寻找字典序最小的答案前，我们先 DFS 一次，找到每个节点往下走可以走到的最大深度，找字典序时，直接将节点最大深度与整棵树的最大深度比较即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/2bvu0bq6.png)

同时还要注意的是，在记录节点最大深度时，叶子端连续的权值为 $0$ 的点不应计入答案（如上图），否则可能影响字典序判断（如上图可能输出 1 3 或 1 3 4，而正确答案应为1 2）。

找字典序最小路径只需找到每个节点中可达到最大深度的编号最小的节点并继续 DFS 即可，记得不要输出叶子端连续的权值为 $0$ 的点。
```cpp
int sondep[N];//节点可达最大深度
void dfs2(int x,int d){//求最大深度
	bool lf=1;//判断是否为叶子结点
	for(int i=fir[x];i;i=e[i].nxt){
		if(e[i].to==fa[x]||e[i].del)continue;
		dfs2(e[i].to,d+1);
		lf=0;
		sondep[x]=max(sondep[x],sondep[e[i].to]);
	}
	if((lf&&a[x]==1)||(!lf&&(a[x]==1||sondep[x])))sondep[x]=max(sondep[x],d);//叶子连续0不更新
}

vector<int>ans;
int zr=0;
bool ed=1;
void dfs3(int x){//找字典序
	int minn=N;
	for(int i=fir[x];i;i=e[i].nxt){
		if(e[i].to==fa[x]||e[i].del||sondep[e[i].to]<sondep[1])continue;
		minn=min(minn,e[i].to);
	}
	if(minn==N){
		if(a[x]==0)zr++,ed=0;
		//printf("%d %d\n",x,zr);
		ans.push_back(x);
		return;
	}
	dfs3(minn);
	if(!ed){
		if(a[x]!=0)ed=1;
		else zr++;//记录叶子连续0的个数，输出时去掉
	}
	ans.push_back(x);
}
```

下面是完整代码。

```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
inline void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch-'0');
		ch=getchar();
	}
	p=w*x;
}
int n,a[N];
struct node{
	int val,id;
	friend bool operator<(node x,node y){
		return x.val>y.val;
	}
};
struct edge{
	int to,nxt;
	bool del;
}e[2*N];
int fir[N],np;

void add(int x,int y){
	e[++np]=(edge){y,fir[x],0};
	fir[x]=np;
}

int fe[N],fa[N];
void dfs1(int x,int f){
	fa[x]=f;
	for(int i=fir[x];i;i=e[i].nxt){
		if(e[i].to==f)continue;
		fe[e[i].to]=i;
		dfs1(e[i].to,x);
	}
}

bool dep1[N];
void bfs(int st){
	queue<int>q;
	priority_queue<node>p;
	int dep=1;
	p.push((node){a[st],st});
	dep1[dep]=a[st];
	while(!p.empty()||!q.empty()){
		if(dep1[dep]&&!p.empty()){
			while(!p.top().val){
				node x=p.top();
				p.pop();
				e[fe[x.id]].del=1;
			}
		}
		node x=p.top();
		p.pop();
		for(int i=fir[x.id];i;i=e[i].nxt){
			if(e[i].to==fa[x.id])continue;
			q.push(e[i].to);
		}
		if(p.empty()){
			dep++;
			while(!q.empty()){
				p.push((node){a[q.front()],q.front()});
				if(a[q.front()]==1)dep1[dep]=1;
				q.pop();
			}
		}
	}
}

int sondep[N];
void dfs2(int x,int d){
	bool lf=1;
	for(int i=fir[x];i;i=e[i].nxt){
		if(e[i].to==fa[x]||e[i].del)continue;
		dfs2(e[i].to,d+1);
		lf=0;
		sondep[x]=max(sondep[x],sondep[e[i].to]);
	}
	if((lf&&a[x]==1)||(!lf&&(a[x]==1||sondep[x])))sondep[x]=max(sondep[x],d);
}

vector<int>ans;
int zr=0;
bool ed=1;
void dfs3(int x){
	int minn=N;
	for(int i=fir[x];i;i=e[i].nxt){
		if(e[i].to==fa[x]||e[i].del||sondep[e[i].to]<sondep[1])continue;
		minn=min(minn,e[i].to);
	}
	if(minn==N){
		if(a[x]==0)zr++,ed=0;
		//printf("%d %d\n",x,zr);
		ans.push_back(x);
		return;
	}
	dfs3(minn);
	if(!ed){
		if(a[x]!=0)ed=1;
		else zr++;
	}
	ans.push_back(x);
}

int main(){
	read(n);
	for(int i=1;i<=n;i++)
	    read(a[i]);
	for(int i=1;i<n;i++){
		int x,y;
		read(x),read(y);
		if(a[x]==-1||a[y]==-1)continue;
		add(x,y);
		add(y,x);
	}
	if(a[1]==-1)return 0;
	dfs1(1,0);
	bfs(1);
	dfs2(1,1);
	dfs3(1);
	for(int i=ans.size()-1;i>=zr;i--)
	    printf("%d ",ans[i]);
	return 0;
}
```


---

## 作者：LiYomi (赞：0)

搞个题解？ 赛后 3min 过，中间写 bug 了，QAQ

首先，该题可以细想一下，发现本质上就是多个二进制数，位与位之间连成了一个树。
所以：
1. 如果某一个节点出现了 $-1$，就不用了再继续向下走了，一定是负贡献
2. 假设当前节点 $u$ 的一个子节点 $v_i$ 对应的值 $a[v_i]=1$，那么 $u$ 的其他节点如果说 $a[v_j]=0$ 那么也不用向下走了，因为走 $i$ 节点的路比走 $j$ 节点的路一定更大。

于是乎，蒟蒻想到了搞一个 BFS，把所有节点分层处理（这里指的是根据高度划分）

阶段一：从根节点向外能走 $1$ 就走 $1$ ，并且走 $1$ 会淘汰同一层是 $0$ 的节点。

阶段二：如果下一层没有 $1$ 可以走了，就走 $0$。

问题来了，答案怎么搞？

我们考虑一条链是 $1\ 1\ 1\ 0\ 0\ 1$，中间走 $0$ 了怎么处理？

可以用一个 vector<int>ans 记录答案节点，如果到了新的一层发现有 $1$，那么之前的 $ans$ 可以直接 $clear$ 了，走过 $0$，再走 $1$ 也不影响这个判断。
  
综上我们有了以下代码：
```cpp
while(q.size())
{
	int h1=0; //记录当前节点 x 有没有 a[y]=1 的节点
	int len=q.size();
	for(int i=1;i<=len;i++)
	{
		int x=q.front();q.pop();
		// caculate ans
		if(a[x]==1) ans.push_back(x);//答案的节点最后一定是 1，想想为什么？
		// go down
		for(int i=0;i<v[x].size();i++) if(a[v[x][i]]==1&&v[x][i]!=fa[x]) h1++; //找 a[v_i] 并且 v_i 不能是父亲
		for(int i=0;i<v[x].size();i++)
		{
			int y=v[x][i];
			if(y==fa[x]) continue;
			if(a[y]==-1) continue;
			if(h1&&(a[y]!=1)) continue;//淘汰 0 的点
			fa[y]=x; q.push(y);
		}
	}
	if(q.size()&&h1) ans.clear(); //如果新的一层有 1，就把之前的 ans 清空
}
```
                                       
之后就发现~~愉快~~的 WA 掉了。Hack 了一个小时发现
![](https://s1.ax1x.com/2023/02/01/pSDnBAH.png)

这样一种图，$7$ 和 $8$ 节点为 $1$，其他全 $0$ 就输出了 $1,2,4,8$

正确答案明显应该是 $7$，这里 $a[7]=1$, $a[6]=0$, $7$ 没有能淘汰 $6$ 的子节点 $8$，发现对于一个节点，不仅能淘汰他自己的子节点，还能淘汰下一层的其他节点的子节点，仔细一想确实有道理。
                                       
到此我们得到了二进制最大的几个点，还要找字典序最小的。把找到的点打标记，排序一下邻接表，DFS 去找第一个满足的点就是字典序最小的了。
                
                                       
  然后就有了 AC 代码
[提交记录](https://www.luogu.com.cn/record/101121883)

```cpp
int n,m;
int a[N],fa[N];
vector<int>v[N];
vector<int>ans;
queue<int>q;
queue<int>q2;
void bfs(int x)
{
	q.push(x);
	if(a[x]==-1) return;
	while(q.size())
	{
		int h1=0;
		int len=q.size();
		for(int i=1;i<=len;i++)//记录当前层的下一层有没有 1，淘汰下一层所有的 0 节点
		{
			int x=q.front();q.pop();
			for(int i=0;i<v[x].size();i++) if(a[v[x][i]]==1&&v[x][i]!=fa[x]) h1++;
			q2.push(x);
		}
		for(int i=1;i<=len;i++)
		{
			int x=q2.front();q2.pop();
			// caculate ans
			if(a[x]==1) ans.push_back(x);
			// go down
			int h2=0;
			for(int i=0;i<v[x].size();i++)
			{
				
				int y=v[x][i];
				if(y==fa[x]) continue;
				if(a[y]==-1) continue;
				if(h1&&(a[y]!=1)) continue;
				fa[y]=x; q.push(y);
			}
		}
		if(q.size()&&h1) ans.clear();
	}
}
int vis[N],pos=0;
void dfs(int x,int f)
{
	if(pos) return;
	if(vis[x])
	{
		pos=x;
		return;
	}
	for(int i=0;i<v[x].size();i++)
	{
		int y=v[x][i];
		if(y==f) continue;
		dfs(y,x);
	}
}
stack<int>s;
void solve()
{
	rd(n);
	for(int i=1;i<=n;i++) rd(a[i]);
	for(int i=1;i<=n-1;i++)
	{
		int x,y;
		rd(x,y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	for(int i=1;i<=n;i++) sort(v[i].begin(),v[i].end());
	bfs(1);
	for(int i=0;i<ans.size();i++) vis[ans[i]]=1;
	dfs(1,0);
	if(!pos) return;
	while(fa[pos]) s.push(pos),pos=fa[pos];s.push(pos);
	while(s.size()) wt(s.top(),3),s.pop();
}

```

                                           


---


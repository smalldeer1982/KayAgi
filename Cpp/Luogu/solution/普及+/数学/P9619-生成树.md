# 生成树

## 题目背景

> 我们是未成熟的斗士 现在绝不认输
>
> 我们是未成熟的梦想家 现在绝不哭泣

## 题目描述

现给定一个无向完全图 $G(V,E)$ 和一个长度为 $|V|$ 的权值数组 $a$．$a_i$ 表示编号为 $i$ 的节点的权值．

定义一条边 $e(u,v)$ 的边值为 $val(e)$，满足 $val(e)=a_u\oplus a_v$，也就是边连接的两个节点的权值的异或和；定义 $G$ 的一个生成树 $T(V,E_t)$ 的权值为 $Val(T)$，满足 $Val(T)=\sum_{e\in E_t}val(e)$，也就是树上边的边权和．

您需要求出 $\sum_{T}Val(T)$．即 $G$ 中所有不同生成树的权值的和．

我们认为两棵生成树是不同的，当且仅当两棵树的边集 $E_t$ 不完全相同，即至少存在一条边，满足其仅属于两棵生成树中的其中一棵．

## 说明/提示

### 样例 #1 说明：
考虑一共存在三个生成树 $\{1-2-3\},\{1-3-2\},\{3-1-2\}$．

它们的权值分别为 $(1\oplus 2)+(2\oplus 3)=4,(1\oplus 3)+(3\oplus 2)=3,(3\oplus 1)+(1\oplus 2)=5$．

有 $4+3+5=12$．

### 数据点约束
保证对于所有数据，$1\le n\le 10^6$，$0\le a_i\le 10^9$．
|测试点编号|数据范围|特殊性质|
|:-:|:-:|:-:|
|$1$||所有 $a_i$ 相等|
|$2\sim 5$|$n\le 4$||
|$6\sim 10$|$n\le 300$||
|$11\sim 12$|$n\le 5\times 10^4$|$a_i=[i=1]$|
|$11\sim 15$|$n\le 5\times 10^4$||
|$16\sim 20$|||

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
12```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4```

### 输出

```
19008```

## 样例 #3

### 输入

```
10
1 1 4 5 1 4 1 9 1 9```

### 输出

```
567022588```

# 题解

## 作者：_Aurore_ (赞：5)

### 题目描述

现在有 $n$ 个节点的完全图，第 $i$ 个节点的点权为 $a_i$。如果 $u,v$ 之间存在一条边的话，贡献为 $a_u \oplus a_v$。一颗生成树的价值就是全部边的边权和，希望求出原图全部生成树的价值和。

$n \leqslant 10^6$。

### 思路点拨

实际上，对于任何一条边 $(u,v)$，在全部生成树中出现次数是一样的。这一点很好理解吧。

全部生成树的边的数量和就是 $n^{n-2}\times (n-1)$，将其均摊到每一条边就是 $\dfrac{n^{n-2}\times (n-1)}{n\times (n-1)\times \frac{1}{2}}=2\times n^{n-3}$，令其为 $w$ 表示每一条边的出现次数。

我们现在的目的就是求出每一条边的价值和然后乘上 $w$ 就是答案。价值和十分好算，我们枚举每一个二进制位，对于第 $i$ 个元素，如果该位上是 $1$ 就找 $i+1,i+2,..,n$ 这些元素里哪些该位是 $0$；如果该位上是 $0$ ,就找 $i+1,i+2,..,n$ 这些元素里哪些该位是 $1$。数量乘上 $2^{bit}$，$bit$ 就看你现在枚举到第几位了。过程可以使用前缀和优化，$O(n \log W)$。

这一部分放一个代码 $cnt$ 就是上述的 $\sum_{i=1}^n sum_{j=1}^n a_i \oplus a_j$。

```cpp
	for(int i=0;i<=31;i++){
		for(int j=1;j<=n;j++){
			if(a[j]&(1ll<<i)) sum[j]=sum[j-1]+1;
			else sum[j]=sum[j-1];
		}
		for(int j=1;j<=n;j++){
			if(a[j]&(1ll<<i)) cnt=(cnt+(1ll<<i)*((n-j)-(sum[n]-sum[j])))%mod;
			else cnt=(cnt+(1ll<<i)*(sum[n]-sum[j]))%mod;
		}
	}
```


本题还是比第一题简单了不少。

---

## 作者：hjqhs (赞：4)

你说的对，但是《原神》是由米哈游自主研发的一款全新开放世界冒险游戏。  
签到题。  
看到这道题有很明显的想法：对于无向完全图 $G(V,E)$，设第 $i$ 条边在所有最小生成树中出现了 $v_i$ 次。答案为 $\sum_{e \in E} \times v_e$。所以我们需要求出 $v$。  
由 Cayley 公式知完全图 $K_n$ 有 $n^{n-2}$ 个生成树。由于是无向图，每条边是等价的，所以所有边共出现了 $n^{n-2} \times (n-1)$ 次，共 $\frac{n \times (n-1)}{2}$ 条边，所以一条边出现次数为：
$$\frac{ n^{n-2} \times (n-1) }{\frac{n \times (n-1)}{2}} = 2 \times n^{n-3}$$  
然后是一个很经典的 trick：因为是异或，所以每一个二进制位分开讨论，想要产生贡献的情况只能是一条边所连的两个端点同一二进制位一个为 $1$，另一个为 $0$。那记 $t_i$ 为 $n$ 个点点权转化成二进制后，从右往左第 $i$ 位为 $0$ 的数的个数。那么答案为：
$$2 \times n^{n-3} \times \sum_{0 \le i \le 30}(2^i \times t_{i+1} \times (n-t_{i+1}))$$
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define per(i,a,b) for(int i=b;i>=a;--i)
#define pv(i,p) for(int i=0;i<p.size();++i)
#define ptc putchar
#define il inline
#define reg register
// #define push_back pb
#define mp make_pair
#define eb emplace_back
// #define ret; return 0;
using namespace std;
const int N=1000005;
const int MOD=998244353;
const int INF=0x3f3f3f3f;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
int Max(int a,int b){return a>b?a:b;}
int MAX(int a,int b,int c){return Max(a,Max(b,c));}
int Min(int a,int b){return a<b?a:b;}
int MIN(int a,int b,int c){return Min(a,Min(b,c));}
void Swap(int&a,int&b){int tmp=a;a=b;b=tmp;}
int read(){
  int x=0,f=1;
  char ch=getchar();
  while(ch<'0'||ch>'9'){
    if(ch=='-')f=-1;
    ch=getchar();
  }
  while(ch>='0'&&ch<='9'){
    x=(x<<3)+(x<<1)+(ch^48);
    ch=getchar();
  }
  return x*f;
}
int o,n,s,a[N],t[32],pow2[32];
void solve(){
	cin>>n;
	pow2[0]=1;
	for(int i=1;i<=32;++i){
		pow2[i]=pow2[i-1]*2;
		pow2[i]%=MOD;
	}
	o=2;
	for(int i=1;i<=n-3;++i){
		o*=n;o%=MOD;
	}
	for(int i=1;i<=n;++i){
		cin>>a[i];
		for(int j=1;j<=31;++j){
			int c=a[i]>>(j-1);
			if(c&1)continue;
			else ++t[j];
		}
	}
	for(int i=0;i<31;++i){
		s+=((pow2[i]*t[i+1])%MOD*(n-t[i+1])%MOD);
		s%=MOD;
	}
	cout<<(((o%MOD)*(s%MOD))%MOD);
}
signed main(){
  // freopen(,,stdin);
  // freopen(,,stdout);
  ios::sync_with_stdio(0);
  cin.tie(0);
  solve();
  return 0;
}
```

---

## 作者：Arghariza (赞：2)

#### Description：

> 给定 $n$ 以及序列 $a_1,a_2\cdots,a_n$，求 ：
> $$\sum\limits_{T}\sum\limits_{(u,v)\in T}a_u\oplus a_v$$

#### Solution：

不难发现每对 $(u,v)$ 的权值 $a_u\oplus a_v$ 的贡献次数是相同的，即完全图中一条边被包含在某棵生成树中的方案数，记为 $c$。

考虑如何求出 $c$，考虑一条边 $(u,v)$ 存在于一棵生成树中，当且仅当 $(u,v)$ 这条边两边的子树中的点 $u',v'$ 没有连边。

枚举 $u$ 所在的连通块大小（除去 $u$ 这个点）为 $i$，那么 $v$ 所在连通块大小（包括 $v$）为 $n-i-1$，$u$ 所在的连通块大小为 $i+1$。

根据 $\text{Cayley}$ 定理，$n$ 个点无向完全图生成树个数为 $n^{n-2}$。

于是我们从除去 $u,v$ 的 $n-2$ 个点中选出 $i$ 个点放进 $u$ 的子树中，剩下的点放进 $v$ 的子树中，再在两边分别构建出生成树，方案数就是：

$$c=\sum\limits_{i=0}^{n-2}\dbinom{n-2}{i}(i+1)^{i-1}(n-i-1)^{n-i-3}$$

注意这里 $a^b$ 在 $b<0$ 时应该为 $1$，含义为 $1$ 个点仅有一种生成树。

然后我们简单地得到了每条边 $(u,v)$ 的贡献次数 $c$，答案就是：

$$\text{ans}=c\cdot \sum\limits_{1\le i<j\le n}a_i\oplus a_j$$

考虑如何求出 $\sum\limits_{1\le i< j\le n}a_i\oplus a_j$，考虑拆位，从小到大枚举 $j$，记录 $i<j$ 的所有 $a_i$ 的第 $k$ 位 $1$ 的个数总和 $c_k$，然后枚举 $a_j$ 的每一位 $k$，统计所有 $a_i\oplus a_j$ 的第 $k$ 位的贡献：

- 若 $a_j$ 第 $k$ 位为 $0$：由于 $0\oplus 1=1$，贡献为 $2^k\cdot c_k$。
- 若 $a_j$ 第 $k$ 位为 $1$：由于 $1\oplus 0=1$，贡献为 $2^k\cdot(j-1-c_k)$。

然后将 $a_j$ 的对应第 $k$ 位加入 $c_k$ 即可。

复杂度 $O(n(\log n+\log w))$。

```cpp
// Problem: U321268 生成树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/U321268?contestId=129172
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;

namespace vbzIO {
    char ibuf[(1 << 20) + 1], *iS, *iT;
    #if ONLINE_JUDGE
    #define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
    #else
    #define gh() getchar()
    #endif
    #define mt make_tuple
    #define mp make_pair
    #define fi first
    #define se second
    #define pc putchar
    #define pb emplace_back
    #define ins insert
    #define era erase
    typedef tuple<int, int, int> tu3;
    typedef pair<int, int> pi;
    inline int rd() {
        char ch = gh();
        int x = 0;
        bool t = 0;
        while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
        while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
        return t ? ~(x - 1) : x;
    }
    inline void wr(int x) {
        if (x < 0) x = ~(x - 1), putchar('-');
        if (x > 9) wr(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace vbzIO;

const int N = 1e6 + 100;
const int P = 998244353;

int n, a[N], fac[N], ifac[N], c[40];

int qpow(int p, int q) {
	if (p < 0 || q < 0) return 1;
	int res = 1;
	for (; q; q >>= 1, p = 1ll * p * p % P)
		if (q & 1) res = 1ll * res * p % P;
	return res;
}

void init(int lim) {
	fac[0] = 1;
	for (int i = 1; i <= lim; i++)
		fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[lim] = qpow(fac[lim], P - 2);
	for (int i = lim - 1; ~i; i--)
		ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
}

int C(int n, int m) {
	if (m < 0 || n < m) return 0;
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

int main() {
	n = rd(), init(n);
	for (int i = 1; i <= n; i++) a[i] = rd();
	int res = 0, ans = 0;
	for (int i = 0; i <= n - 2; i++) 
		(res += 1ll * C(n - 2, i) * qpow(i + 1, i - 1) % P * qpow(n - i - 1, n - i - 3) % P) %= P;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= 30; j++) {
			if ((a[i] >> j) & 1) ans += 1ll * (1 << j) * (i - 1 - c[j]) % P;
			else ans += 1ll * (1 << j) * c[j] % P;
			ans %= P;
		}
		for (int j = 0; j <= 30; j++)
			(c[j] += ((a[i] >> j) & 1)) %= P;
	}
	wr(1ll * res * ans % P);
    return 0;
}
```

---

## 作者：lfxxx (赞：2)

首先，不难理解，既然是完全图，那每条边都是等价的。

考虑生成树一共有 $n^{n-2}$ 种，每种有 $n-1$ 条边，边又有 $\frac{n \times (n-1)}{2}$ 种，所以每种边会被计算 $2 \times n^{n-3}$ 次，考虑用一个桶记录每一位是几的数有多少个，然后算出所有边贡献总和乘上这个数即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int qpow(int a,int b){
    if(b==0) return 1;
    if(b==1) return a;
    int res=qpow(a,b/2);
    res=res*res%998244353;
    if(b%2==1) res=res*a%998244353;
    return res;
}
int n;
int cnt[100];
int a[1000001];
int sum=0;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        a[i]=x;
        for(int j=0;j<=30;j++) cnt[j]+=(((1<<j)&x)?1:0);
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<=30;j++){
            if((1<<j)&a[i]){
                sum+=(n-cnt[j])*(1<<j);
                sum%=998244353;
            }
            else{
                sum+=cnt[j]*(1<<j);
                sum%=998244353;
            }
        }
    }
    if(n>=3)
        cout<<sum*qpow(n,n-3)%998244353;
    else 
        cout<<sum%998244353;
}
```


---

## 作者：jimmy916 (赞：1)

# P9619 生成树 题解

### 题意
给一个 $n$ 个节点的完全图，第 $i$ 个节点的权值为 $a_i$，若 $u,v$ 之间存在一条边使其相连，那么 $E_{u,v}$ 贡献为 $a_u\oplus a_v$。

生成树的价值就是全部边的边权和，求原图全部生成树的价值和，答案对 $998244353$ 取模。

### 分析
首先，既然是完全图，那每条边都是等价的。

然后，在一个完全图中，生成树共会有 $n^{n-2}$ 种，每种 $n-1$ 条边，边又有 $\tfrac{n\times (n - 1)}{2}$ 种。

所以，每条边会被计算 $2 \times n^{n -2}$ 次。

### 代码

```cpp
#include <iostream>

using namespace std;

const int N = 1000010, mod = 998244353;

long long n;
long long a[N];
long long t[40], cnt;

long long pow(long long a, long long b) {
	if(b == 0)
		return 1;
	if(b == 1)
		return a;
	long long res = pow(a, b / 2);
	return (res * res % mod) * ((b & 1)? a : 1) % mod;
}

int main() {
	cin >> n;
	for (long long i = 1; i <= n; i ++ ) {
		cin >> a[i];
		for (int j = 0; j <= 30; j ++ )
			t[j] += ((1 << j) & a[i])? 1 : 0;
	}
	for (long long i = 1; i <= n; i ++ )
		for (int j = 0; j <= 30; j ++ )
			cnt += (((1 << j) & a[i])? n - t[j] : t[j]) * (1 << j), cnt %= mod;
	cout << (n >= 3? cnt * pow(n, n - 3) : cnt) % mod << endl;
	return 0;
}
```

---

## 作者：Frozen_Ladybug (赞：1)

### 题目描述

有 $n$ 个节点的完全图，第 $i$ 个节点的点权为 $a_i$。如果 $u,v$ 之间存在一条边的话，贡献为 $a_u⊕a_v$。生成树的价值就是全部边的边权和，希望求出原图全部生成树的价值和。

### 思路

因为是完全图，所以所有的边都是等价的。

生成树总共 $n^{n-2}$ 种，每种有 $n-1$ 条边，边共 $\frac{n\times(n-1)}{2}$ 条，每条边会被计算 $2 \times n^{n-3}$ 次。

### 其他注意点

如果用程序自带的 ```pow``` 函数会有失精的问题，所以要手写幂和取模运算。

```c
ll qpow(ll a,ll b){
    if(b==0) return 1;//任何数的0次方都是1
    if(b==1) return a;//1次方就是自己
    ll res=qpow(a,b/2);
    res=res*res%mod;//取一半平方,和二分思想类似
    if(b%2==1) res=res*a%mod;//如果是奇数再乘一个a
    return res;
}
```

其中 $mod=998244353$，返回幂取模后的结果。

### 完整代码

```c
#include<bits/stdc++.h>
#define ll long long
#define mod 998244353
//方便后面写取模
using namespace std;
ll n,cnt[105],a[1000005],sum=0;
int main(){
    scanf("%lld",&n);
    for(ll i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        for(ll j=0;j<=30;j++) cnt[j]+=(((1<<j)&a[i])?1:0);
    }//最前面的处理,不多说
    for(ll i=1;i<=n;i++){
        for(ll j=0;j<=30;j++){
            if((1<<j)&a[i]){
                sum+=(n-cnt[j])*(1<<j);
                sum%=mod;
            }//如果j和a[i]奇偶性相同,需要用n减
            else{
                sum+=cnt[j]*(1<<j);
                sum%=mod;
            }//反之不用n减,直接乘
        }
    }
    if(n>=3) sum=sum*qpow(n,n-3)%mod;//每条边计算的次数为qpow(n,n-3)
    else sum=sum%mod;//只有1或2条边,取模即可
    printf("%lld",sum);//输出答案
    return 0;
}
```

---

## 作者：_Kenma_ (赞：0)

# P9619 解题报告

## 前言

感觉是二合一题。

割裂感比较重。

## 思路分析

读题可能需要一点时间。

实际上是一个无向图生成树边权和计数问题。

首先因为每条边是等价的，所以每条边的贡献次数是相等的，考虑算出这个系数。

根据 prufer 序列的相关知识，我们知道生成树的数量为 $n^{n-2}$，每棵生成树的边的数量为 $n-1$，边的总数为 $\frac{n \cdot (n-1)}{2}$，所以每条边的贡献系数 $k$ 为：

$$k=\frac{n^{n-2}\cdot (n-1)}{\frac{n \cdot (n-1)}{2}}=2n^{n-3}$$

注意特判 $n=1$ 和 $n=2$ 的情况。

现在问题转化为求：

$$ans=k\cdot \sum_{i=1}^{n} \sum_{j=i+1}^{n} a_i \oplus a_j$$

感觉是经典题。

考虑拆位处理，分别计算每一位的贡献。

具体地，可以从 $1$ 到 $n$ 依次计算，设 $f_{i,j,0/1}$ 表示 $1$ 到 $i$ 的数中，第 $j$ 位为 $0/1$ 的数的个数，那么如果 $a_i$ 的第 $j$ 位为 $1$，用 $f_{i-1,j,0}$ 更新答案，否则用 $f_{i-1,j,1}$ 更新答案。

做完了。总体复杂度为 $O(n\log v)$。

## 代码实现

```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int n,ans,a[1000005],cnt[35][2];
int binpow(int a,int b){
	if(b==0) return 1;
	int res=binpow(a,b/2);
	if(b&1) return res*res%mod*a%mod;
	else return res*res%mod;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	if(n==1){
		cout<<0;
		return 0;
	}else if(n==2){
		cout<<(a[1]^a[2])%mod;
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=30;j++){
			if(a[i]&(1<<j)){
				ans=(ans+cnt[j][0]*(1<<j)%mod)%mod;
				cnt[j][1]++;
			}else{
				ans=(ans+cnt[j][1]*(1<<j)%mod)%mod;
				cnt[j][0]++;
			}
		}
	}
	ans=ans*binpow(n,n-3)%mod*2%mod;
	cout<<ans;
	return 0;
}

```

---

## 作者：harmis_yz (赞：0)

题解摘自 [CSP2024 前做题情况](https://www.luogu.com.cn/article/0b5hlxos)。

## 分析

考虑枚举边。我们枚举生成树上有一条 $u\to v$ 的边，那么这两个点与其它 $n-2$ 个点形成的生成树的数量根据 Prüfer 序列为：$n^{n-2+1-2}\times 2 \times \prod\limits_{i=1}^{n-2} 1$。那么这条边的贡献就是 $(a_u ⊕a_v)\times 2\times n^{n-3}$。发现后面是定值，那么有总价值为：$2\times n^{n-3}\times \sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}a_i ⊕ a_j$。拆位算贡献就行了。时间复杂度 $O(n)$。

## 代码

```cpp
il void solve(){
	n=rd;
	for(re int i=1;i<=n;++i){
		int x=rd;
		for(re int j=0;j<=33;++j)
		if(x&(1ll<<j)) ++cnt[j];
	}
	for(re int j=33;j>=0;--j){
		int s1=cnt[j],s0=n-cnt[j];
		sum=(s1*s0%p*(1ll<<j)%p+sum)%p;
	}
	printf("%lld\n",sum*2%p*qmi(n,n-3,p)%p); 
	return ;
}
```

---

## 作者：Star_F (赞：0)

## 题目大意：

给定一个无向完全图，每个点有点权，每条边的价值是这条边两个端点的点权的异或值，求出这张图中所有生成树的价值和。

## 题目分析：

前置知识：Cayley 凯莱定理

Cayley凯莱定理：一张完全图中不同的生成树的数量有 $n^{n-2}$ 种。

每个生成树有 $n-1$ 条边，所以全部生成树的边数之和就是 $(n-1) \times n^{n-2}$。由于本题给定的是一张完全图，所以共有 $\frac{n \times (n-1)}{2}$ 条边，由此得出每条边出现的次数为 $2 \times n^{n-3}$。

下面就是计算价值，因为一条边的价值是其两个端点的异或值，我们考虑二进制处理，如果期中一个点的第 $i$ 位为 $1$，这时想要对答案产生贡献就必须另一个点的第 $i$ 位为 $0$，因为只有这样两个点异或起来才不可能为 $0$，反之。由此我们通过枚举点的二进制位，然后计算价值即可。

代码里也有注释，可供参考。

## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define ROF(i, a, b) for (int i = (a); i >= (b); --i)
#define DEBUG(x) cerr << #x << '=' << x << endl

inline int rd(){
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9'){
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
    return x * f;
}

void print(int x){
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
    return;
}

namespace Star_F{
    #define int long long
    const int mod = 998244353;
    int n, x, ans, a[1000005], tmp[40];
    int p[40];
    void Main(){
        n = rd();       //读入
        p[0] = 1;
        FOR(i, 1, 32)
            p[i] = (p[i - 1] * 2) % mod;   //p[i]为2^i mod 998244353 的值
        x = 2;          
        FOR(i, 1, n - 3)
            x = x * n % mod;            //求 2*n^(n-3) mod 998244353 的值
        FOR(i,1,n){
            a[i] = rd();                //读入每个点
            for (int j = 1; j <= 31;j++){       //枚举这个点的每个二进制位
                int b = a[i] >> (j - 1);        //求这位数
                if(b&1)                 //如果这位是1，选择跳过
                    continue;
                else
                    tmp[j]++;           //否则记录j这位为0的个数。
            }
        }
        FOR(i,0,30){            //p[i] 为这一位本身的价值， tmp[i+1] 为第 i+1位为0的个数，（n-tmp[i+1])位第 i+1 位为1的个数
            ans = ans + (p[i] * tmp[i + 1] % mod * (n-tmp[i + 1]) % mod) % mod;
        }
        cout << x * ans % mod;   //输出答案
    }

}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    return Star_F::Main(), 0;
    return 0;
}
```

---

## 作者：P_VICVIC_R (赞：0)

~~第一眼：生成树计数？矩阵树定理才绿题？~~

仔细一看：**无向完全图**，行了，有[公式](https://zhuanlan.zhihu.com/p/554751658)。

---

### 题意

有 $𝑛$ 个节点的**无向完全图**，第 $𝑖$ 个节点的点权为 $𝑎_i$。对于 $𝑢,𝑣$ 之间的一条边，贡献为 $𝑎_𝑢\oplus𝑎_𝑣$。每棵生成树的价值是其全部边的边权和，求原图全部生成树的价值和。

### 思路

首先因为是**完全图**，那么意味着最后统计贡献时，每条边都会被计算相同的次数。

那么对于一个 $n$ 个点的完全图：

| 种类           | 数量                       |
| -------------- | -------------------------- |
| 点             | $n$                        |
| 边             | $\frac{n\times (n-1)}{2} $ |
| 生成树         | $n^{n-2}$                  |
| 每个生成树边数 | $n-1$                      |

简单算一下：
$$
\text{每个生成树边数} \times \text{完全图生成树数} \div \text{完全图总边数}=\text{每条边贡献次数}\\
\frac{(n-1)\times n^{n-2}}{\frac{n\times(n-1)}{2}}=2\times\frac{n^{n-2}}{n}=2\times n^{n-3}
$$
特例是只有一个或两个点时：只有一个点答案为 $0$，两个点答案就是唯一的那条边的权值。

剩下的就是开桶算每一位是几的数有几个，求总贡献，之后搞个快速幂算一下每条边被计算的次数，乘上就行。

~~（long long 警告。）~~

[（代码太烂不建议看）](https://www.luogu.com.cn/record/159146566)

---


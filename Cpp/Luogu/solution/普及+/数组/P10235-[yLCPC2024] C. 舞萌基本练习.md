# [yLCPC2024] C. 舞萌基本练习

## 题目描述

扶苏在游玩舞萌 dx 的过程中，发现一首歌可以分成不超过 $k$ 段分别进行练习。

具体来说，这首歌共有 $n$ 个音符，每个音符有一个难度值。第 $i$ 个音符的难度值为 $a_i$。扶苏觉得一段歌曲的音符的难度应该是尽可能变难的。因此对于音符序列的一个区间 $[l, r]$，她认为这段区间的『不优美度』是这段区间的**逆序对**数。

一个区间 $[l, r]$ 的**逆序对数**被定义为满足 $l \leq i < j \leq r$ 且 $a_i > a_j$ 的数对 $(i, j)$ 个数。

扶苏希望把这首歌划分成不超过 $k$ 个子段，满足每个音符都至少属于一个子段，使得不优美度最大的段的不优美度尽可能小。

形式化的，你需要划分出 $t \leq k$ 个区间 $[l_1, r_1], [l_2, r_2], \dots [l_t, r_t]$，满足：

- $l_1 = 1$，$r_t = n$。
- 对 $1 \leq i < t$，$r_i + 1= l_{i + 1}$。
- 对 $1 \leq i \leq t$，$l_i \leq r_i$。

定义 $f(l, r)$ 表示区间 $[l, r]$ 的不优美度，最小化 $\max\limits_{i = 1}^t f(l_i, r_i)$

## 样例 #1

### 输入

```
2
5 2
1 3 2 5 4
8 2
4 2 3 6 7 1 8 5```

### 输出

```
1
2```

# 题解

## 作者：Brilliant11001 (赞：9)

## [题目传送门](https://www.luogu.com.cn/problem/P10235)

## 大致题意：

多组测试数据，每组数据给定一个长度为 $n$ 的序列和一个参数 $k$，要求将此区间划分成不超过 $k$ 段，使这些区间中的逆序对数量的最大值最小。

## 思路：

对于求“最大值最小”这类问题，很容易想到二分。显然，本题的答案是具有单调性的，即**当划分的段数减少时，区间中逆序对数量的最大值只会增大不会减小**。

所以我们考虑将二分答案转化为二分判定，具体为：我们二分一个 $limit$ 值，表示当前的解，然后将当前这个 $limit$ 代入计算。

若当前解合法，则说明区间 $[limit,r]$ 的解肯定都是合法的，因为此时 $limit$ 也可能作为最后答案，所以令 $r = mid$，向左扩展答案即可。

若当前解不合法，则说明区间 $[l,limit]$ 的解肯定都不合法，所以此时令 $l = mid + 1$ 向右扩展答案即可。

二分的问题解决了，那么怎么判断这个解是否合法呢？

一个很简单的想法：扫描整个序列，一开始整个序列只有一段，将序列中的数一个一个地加入这个段中，当此段逆序对数量大于 $limit$ 时，就重新开辟新的一段并使段数 $cnt$ 增加 $1$。将整个序列划分完后，若 $cnt \le k$，则此解合法，否则不合法。

对于求逆序对数量，用树状数组可以很好解决。

建立一个权值树状数组，每次在某段末尾加入一个数时，只需计算该段中大于它的数的个数，这就是新增的逆序对数。

然而这里要注意两个点：

1. $-10^9 \le a_i \le 10^9$，所以需要离散化；
2. 在重新开辟一段时，之前那段的数要全部从树状数组中抹去，这样才能让它正确地求出后面段的逆序对数。

$\texttt{Some Tips}$：

由于长度为 $n$ 的序列最大逆序对数量为 $\frac{n(n-1)}{2}$，所以我的二分上界取了 $10^{10}$。

在每次二分中，序列中的所有数只会进入一次、出一次树状数组，所以 $\operatorname{check()}$ 的时间复杂度为 $O(n\log n)$。

整个程序时间复杂度 $O(n\log n\log 10^{10})$，空间复杂度 $O(n)$。

$\texttt{Code}：$

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>

#define lowbit(x) x & -x
using namespace std;

const int N = 100010;

int T, n, k;
int a[N], c[N];
int nums[N];
int tt;
int fnd[N];

int find(int x) {
	return lower_bound(nums + 1, nums + tt + 1, x) - nums;
}

int ask(int x) {
	int res = 0;
	for(; x; x -= lowbit(x)) res += c[x];
	return res;
}

void add(int x, int y) {
	for(; x <= n; x += lowbit(x)) c[x] += y;
}

bool check(long long limit) {
	int cnt = 1; //段数 
	long long f = 0; //目前处理的段的逆序对数 
	int L = 1; //目前处理的段的左端点 
	for(int i = 1; i <= n; i++) {
		int tmp = ask(tt) - ask(fnd[i]); //计算新增的逆序对数 
		if(f + tmp > limit) {
			cnt++; //段数 + 1
			f = 0; //重置逆序对数
			for(int j = L; j <= i - 1; j++) 
				add(fnd[j], -1); //清除上一区间的贡献 
			L = i; //更新左端点 
		}
		else f += tmp;
		add(fnd[i], 1); //加入树状数组
	}
	for(int i = L; i <= n; i++) add(fnd[i], -1); //不要忘了最后一段也要抹去
	return cnt > k;
}

int main() {
	scanf("%d", &T);
	while(T--) {
		scanf("%d%d", &n, &k);
		for(int i = 1; i <= n; i++) {
			scanf("%d", &a[i]);
			nums[++tt] = a[i];
		}
		sort(nums + 1, nums + tt + 1);
		tt = unique(nums + 1, nums + tt + 1) - nums - 1;
		for(int i = 1; i <= n; i++) fnd[i] = find(a[i]);
		long long l = 0, r = 1e10;
		while(l < r) {
			long long mid = l + r >> 1;
			if(check(mid)) l = mid + 1;
			else r = mid;
		}
		printf("%lld\n", l);
		for(int i = 1; i <= tt; i++) nums[i] = 0;
		tt = 0;
	}
	return 0;
}
```

---

## 作者：CAICAIA (赞：3)

# P10235 舞萌基本练习 题解

## 思路

看到最大值最小首先考虑**二分答案**。

由于答案满足单调性，可以二分不优美度的最大值，也就是逆序对数的最大值。

我们在每次增加一个元素的时候都要求解当前区间的逆序对数，所以不能用归并排序求逆序对数，考虑树状数组解法。

如果不会树状数组求逆序对，请出门右转[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)。

具体解法都写在代码里了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MX=100100;
#define int long long   //不开long long 见祖宗
int n,k;
int a[MX]={0};
int mid[MX]={0};
void li(){                    //离散化
    for(int i=1;i<=n;i++)  mid[i]=a[i];
    sort(mid+1,mid+n+1);
    int len=unique(mid+1,mid+1+n)-mid-1;
    for(int i=1;i<=n;i++){
        a[i]=lower_bound(mid+1,mid+1+len,a[i])-mid;
    }
}


int tree[MX]={0};                         //树状数组
inline int lowbit(int x){return x&(-x);}
void add(int x,int val){              
    for(;x<=n;x+=lowbit(x)){
        tree[x]+=val;
    }
}
int query(int x){
    int sum=0;
    for(;x;x-=lowbit(x)){
        sum+=tree[x];
    }
    return sum;
}

queue<int> qu;
void del(){                            //清空数组
    while(!qu.empty()){
        int x=qu.front();qu.pop();
        add(x,-1);
    }
}
bool check(int m){
    int l=1,r=1;           //l为当前区间左端点，r为当前区间右端点
    int sum=1,ni=0;        //sum为当前区间个数，ni为当前区间逆序对数
    while(r<=n){
        add(a[r],1);
        qu.push(a[r]);
        ni+=(r-l+1)-query(a[r]);      //统计逆序对数
        if(ni>m){                     //超过m就新划分一个区间
            sum++,l=r,ni=0;
            del();                    //树状数组清空
            if(sum>k)  break;         //如果超过k个就不合法
            continue;
        }
        r++;
    }
    del();    //记得清空数组
    if(sum>k)  return 0;              //如果超过k个就不合法
    return 1;
}
signed main(){
    int T;scanf("%lld",&T);
    while(T--){
        scanf("%lld%lld",&n,&k);
        for(int i=1;i<=n;i++) scanf("%lld",a+i);
        li();
        int l=0,r=n*n,mid,ans=n*n;
        while (l<=r)             //二分答案
        {
            mid=(l+r)>>1;
            if(check(mid))  r=mid-1,ans=mid;
            else  l=mid+1;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：zjinze (赞：3)

#### 前言：

赛时我艰难地过了这道题。

#### 涉及算法：

二分，离散化，树状数组。

#### 注意：

这题只讲具体思路，如果有些必要的算法或数据结构没学，请自行学习。

#### 简要题意：

我们可以将给定的数列分成不超过 $k$ 段，并使每一段中的逆序对数量的最大值最小。

#### 思路：

显然，对于划分段数并求最大值最小的题目，我们可以用二分答案；对于求逆序对的题目，可以先离散化，再用树状数组。但是这里我们检查答案是否合法时，每超出一段，就要清空整个树状数组，可是这样却会超时。那我们怎么做呢？我们可以开两个树状数组，记录上一段及之前的所有逆序对个数和当前段及之前的所有逆序对的个数。我们可以用当前段及之前的所有逆序对的个数减去上一段及之前的所有逆序对个数就行了。我们这时只需要在到达新的一段时，更新上一段及之前的所有逆序对个数的树状数组即可。

#### code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define lowbit(x) x&-x
const int N=1e5+7;
int t,n,k,a[N],tree[N],tree2[N],b[N],c[N],d[N],e[N],tot=0,l,r,mid,tmp;
void add(int x){
	for(int i=x;i<=n;i+=lowbit(i)){
		tree[i]++;
	}
	return ;
}
int query(int x){
	int ans=0;
	for(int i=x;i>=1;i-=lowbit(i)){
		ans+=tree[i];
	}
	return ans;
}
void add2(int x){
	for(int i=x;i<=n;i+=lowbit(i)){
		tree2[i]++;
	}
	return ;
}
int query2(int x){
	int ans=0;
	for(int i=x;i>=1;i-=lowbit(i)){
		ans+=tree2[i];
	}
	return ans;
}
void init(){
	for(int i=0;i<=tot;i++)tree[i]=tree2[i]=0;
	return ;
}
bool cmp(int x,int y){
	return x<y;
}
int find(int x){
	int l=1,r=tot,mid;
	while(l<r){
		mid=(l+r)>>1;
		if(c[mid]>=x){
			r=mid;
		}
		else{
			l=mid+1;
		}
	}
	return l;
}
bool check(int mid){
	init();
	int st=1,cnt=1,sum=0;
	tmp=0;
	for(int i=1;i<=n;i++){
		sum+=i-st-query(d[i])+query2(d[i]);
		if(sum>mid){
			for(int j=st;j<i;j++){
				add2(d[j]);
			}
			st=i;
			++cnt;
			sum=0;
		}
		if(cnt>k)return false;
		add(d[i]);
	}
	return cnt<=k;
}
signed main(){
	cin>>t;
	while(t--){
		cin>>n>>k;
		tot=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			b[i]=a[i];
		}
		sort(b+1,b+n+1,cmp);
		for(int i=1;i<=n;i++){
			if(b[i]!=b[i-1])c[++tot]=b[i];
		}
		for(int i=1;i<=n;i++){
			d[i]=find(a[i]);
		}
		l=0,r=1e18;
		while(l<r){
			mid=(l+r)>>1;
			if(check(mid)){
				r=mid;
			}
			else{
				l=mid+1;
			}
		}
		cout<<l<<"\n";
	}
	return 0;
}
```

---

## 作者：_Spectator_ (赞：2)

[可能更好的食用体验](/article/1h2wk7em) $|$ 
[题目传送门](/problem/P10235) $|$ 
[我的其他题解](/user/523641#article.2)

前置知识：二分答案，离散化，树状数组。

------------
### ${\color{#00CD00}\text{思路}}$

注意到答案具有单调性，因此考虑使用二分答案。

对于一个答案 $x$，遍历一遍原数组，动态维护当前区间的逆序对数量。如果发现加入当前数 $a_i$ 后区间的逆序对数超过了 $x$，就将 $a_i$ 划归一个新的区间。最后统计出总共的区间数量，若不超过 $k$ 则为一个合法的答案。

使用树状数组维护逆序对数量即可。具体实现见代码。

需要离散化。

时间复杂度 $O(n\log^2n)$。

------------

### ${\color{#00CD00}\text{代码}}$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e5+5;
LL T,n,k,len;
int a[N],rk[N];

struct BIT{ //树状数组模板。
	int c[N],tag[N],ti;
    //其中的 ti 为时间戳，用于避免重复清空树状数组带来的时间开销。
    //tag[x] 为 x 最后一次被访问的时间戳。
	BIT(){ti=1;}
	int lowbit(int x){return x&-x;}
	void update(int x,int k){
		while(x<=len){
			if(tag[x]!=ti)c[x]=0,tag[x]=ti;
			c[x]+=k,x+=lowbit(x);
		}
	}
	int query(int x){
		int sum=0;
		while(x){
			if(tag[x]!=ti)c[x]=0,tag[x]=ti;
			sum+=c[x],x-=lowbit(x);
		}
		return sum;
	}
}t;

bool ok(LL x)
{
	LL cnt=1,sum=0; //cnt 为区间数量，sum 为当前区间逆序对数量。
	for(int i=n;i>0;i--) //倒序遍历数组。
	{
		int tmp=t.query(a[i]-1); //计算 a[i] 对当前区间逆序对数量的贡献。注意相等的不算逆序对。
		if(sum+tmp>x)sum=0,cnt++,t.ti++; //加上 a[i] 后逆序对数量超过 x，将 a[i] 划归新区间。
		else sum+=tmp; //注意这里有个 else。
		t.update(a[i],1); //将树状数组第 a[i] 位加上一，用于前面的数统计后面比当前小的数的个数。
	}
	t.ti++; //t.ti++ 作用等价于清空树状数组。
	return cnt<=k; //判断答案合法。
}

int main()
{
    ios::sync_with_stdio(false),cin.tie(0);
	for(cin>>T;T-->0;)
	{
		/*step1: 读入+离散化*/
		cin>>n>>k;
		for(int i=1;i<=n;i++)cin>>a[i],rk[i]=a[i];
		sort(rk+1,rk+1+n);
		len=unique(rk+1,rk+1+n)-(rk+1);
		for(int i=1;i<=n;i++)a[i]=lower_bound(rk+1,rk+1+len,a[i])-rk;
		/*step2: 二分答案*/
		LL l=-1,r=n*(n-1)/2; //注意这里 r 的值可能爆 int。
		while(l+1<r)
		{
			LL mid=(l+r)/2;
			if(ok(mid))r=mid;
			else l=mid;
		}
		cout<<r<<"\n";
	}
	return 0;
}
```

---

## 作者：Lian_zy (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P10235)

# 题意简述
给你一个数列 $a$，将它分成不超过 $k$ 段，使得逆序对数量最大的段的逆序对数量尽可能小。

# 题目分析
观察题目，发现：

`使得逆序对数量最大的段的逆序对数量尽可能小。`

好了，看到这就是二分没跑了。

那么 `check()` 函数怎么写呢？

我们先从逆序对讲起。

逆序对可以使用归并排序和树状数组两种方法来解决，如果你不会逆序对，请移步模板：[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)。

本题貌似无法使用归并排序通过，如果有的话请在评论区踩爆该蒟蒻，所以我们使用树状数组编写 `check()` 函数。

具体思路：

1.设定双指针 $l,r$，初值都为 $1$。

2.

如果这段加上第 $r$ 个数依然不超过  $x$，则加上第 $r$ 个数字在这段内所产生的逆序对，其中 $x$ 是我们二分的数值。

否则，将 $cnt$（分的段数）加 $1$，此时可以加入一个判断，如果 $cnt$ 大于 $k$了，那么直接返回不行，这个可以优化点时间（也优化不了多少，但是可以用于抢最优解），清空树状数组，怎么清空呢？这个先别急，我待会会讲。然后将 $ccnt$（某段内逆序对的个数）清零，然后记得让 $l = r$，表示新的一段开始了。

3.重复第二步直到 $r > n$。

好的现在流程结束了，你可能会问：咋清空树状数组啊

暴力赋值或使用 `memset`，时间复杂度 $O(n)$，肯定会爆。

考虑优化暴力：只有将不为零的数字清零，这样就会避免很多浪费，开一个队列记录不为 $0$ 的元素。

一次清除需要 $\log_2 n$ 的时间，每个元素进出队列一次，共 $n$ 次，总共下来只需要 $n \log_2 n$，比暴力的 $O(n^2)$ 好多了。

# 总结 & 代码
`check()` 函数的复杂度大约 $n \log_2 n$，一共执行 $\log_2 n$ 次，总时间复杂度大约为 $n (\log_2 n)^2$，可以通过本题。

``` cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;

const ll maxn = 1e5 + 10;
struct node {
	ll num, val;
} b[maxn];
queue<ll> q;
long long l, r, mid, ans, cnt;
ll T, n, k, nk, left, right, a[maxn], tree[maxn];
ll lowbit(ll x) {
	return x & -x;
}
ll query(ll x) {
	return x ? tree[x] + query(x - lowbit(x)) : 0;
}
bool cmp(node x, node y) {
	if (x.val == y.val) return x.num < y.num;
	return x.val < y.val;
}
void update(ll x, ll y) {
	if (x > n) return ;
	tree[x] += y;
	update(x + lowbit(x), y);
	return ;
}
void clearq() {
	while (q.size()) {
		update(q.front(), -1);
		q.pop();
	}
	return ;
}
bool check(ll x) {
	clearq();
	cnt = 0, nk = 1;
	left = right = 1;
	while (right <= n) {
		update(a[right], 1);
		q.push(a[right]);
		cnt += (right - left + 1) - query(a[right]);
		if (cnt > x) {
			nk++;
			clearq();
			left = right, cnt = 0;
			if (nk > k) return false;
		} else right++;
	}
	return nk <= k;
}
int main() {
	scanf("%lld", &T);
	while (T--) {
		scanf("%lld %lld", &n, &k);
		for (ll i = 1; i <= n; i++) {
			scanf("%lld", &b[i].val);
			b[i].num = i;
		}
		sort(b + 1, b + n + 1, cmp);
		for (ll i = 1; i <= n; i++) a[b[i].num] = i;
		l = 0, r = n * n - n >> 1; 
		while (l <= r) {
			mid = l + r >> 1;
			if (check(mid)) {
				ans = mid;
				r = mid - 1;
			} else l = mid + 1;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：1)

# 题意简述

[传送门。](https://www.luogu.com.cn/problem/P10235)

给定一个长度为 $n$ 的序列 $a$。定义其子序列 $a_{l,r}$ 的特征值 $f(l,r)$ 为 $[l,r]$ 的逆序对数量。

给定一个 $k$。要求你将 $a$ 分为 $k$ 段。我们额外定义序列 $a$ 的**总特征值**为其每一段特征值的最大值，要求你使得这个**最大值最小**,并将其输出。

# 思路分析

在完成本题前推荐完成的题目：[逆序对](https://www.luogu.com.cn/problem/P1908)，[数列分段](https://www.luogu.com.cn/problem/P1182)。

看到最大值最小很容易想到二分答案，我们二分答案 $t$。然后判断是否存在可行方案将序列 $a$ 划分成若干段，使得每一段的特征值不超过 $t$。

逆序对的话直接套上树状数组模板就好，记得清空树状数组和离散化。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=1e5+10;
ll T,n,k,a[N],book[N],tot,c[N];
void read(){
    scanf("%lld %lld",&n,&k);
    for(int i=1;i<=n;i++)scanf("%lld",a+i),book[i]=a[i];
    sort(book+1,book+1+n);
    tot=unique(book+1,book+1+n)-(book+1);
    for(int i=1;i<=n;i++)a[i]=lower_bound(book+1,book+1+tot,a[i])-book;
    return;
}
void add(ll x,ll t){
    for(;x<=tot;x+=(x&-x))c[x]+=t;
    return;
}
ll ask(ll x){
    ll cnt=0;
    for(;x>0;x-=(x&-x))cnt+=c[x];
    return cnt;
}
void remove(ll l,ll r){
    for(ll i=l;i<=r;i++)add(a[i],-1);
    return;
}
bool check(ll t){
    ll group=1,cnt=0,r=n;
    for(int i=n;i>=1;i--){
        ll now=ask(a[i]-1);
        if(cnt+now<=t)cnt+=now,add(a[i],1);
        else remove(i+1,r),cnt=0,r=i,group++,add(a[i],1);
    }
    remove(1,r);
    if(group<=k)return 1;
    else return 0;
}
ll solve(){
    ll l=0,r=n*n,mid,ans=r;
    while(l<r){
        mid=(l+r)>>1;
        if(check(mid))r=mid,ans=mid;
        else l=mid+1;
    }
    return ans;
}
void clear(){
    for(int i=1;i<=tot;i++)book[i]=0;
    for(int i=1;i<=n;i++)a[i]=0;
    for(int i=1;i<=n;i++)c[i]=0;
    return;
}
int main(){
    scanf("%lld",&T);
    while(T--){
        read();
        printf("%lld\n",solve());
    }
}
```
如有错误，请指出。

---

## 作者：what_can_I_do (赞：1)

[传送门](https://www.luogu.com.cn/problem/P10235)

两个板相加，难道不应该评黄吗？

明显考虑二分，因为答案具有单调性。如果答案更小的都满足了，那么答案再大一点也是满足的。感性地理解，我们划分每个段都是相当于在减少总的逆序对数量，所以当逆序对数量越大需要划分的段的数量也就越少。如果此时逆序对更少的都满足了，那么逆序对更多的需要划分的段数会更少，那么也肯定满足了。

二分的判断函数直接用模拟做。用一个值记录目前的不优美度，那么如果这个值超过我们二分的 $mid$ 那么就把此时循环到的这个点作为划分，以这个点重新为开始划分新的子段。如果最后子段数量不超过题目要求的值那么就说明该 $mid$ 可以满足题目条件。

对于如何求区间的逆序对数，不细讲。本人用了一种非常蠢的线段树做法，区间修改，单点查询。其实跟逆序对的板题区别就在于一个线段树的清零操作，因为统计新区间的时候要把原来旧区间的数据清零。

注意：二分的区间要算好，本题的二分区间右端点应该为 $n^2$ 也就是 $10^{10}$，如果选择的右端点太大会超时。

# CODE：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define lc k<<1
#define rc k<<1|1
using namespace std;
int t;
int n,k;
struct aaa
{
	int s,x;
}a[100010];
int z[100010];
inline bool cmp(aaa b,aaa c)
{
	if(b.s==c.s) return b.x<c.x;
	return b.s<c.s;
}
struct tree
{
	int sum,lt;
}tr[400010];
inline void up(int k)
{
	tr[k].sum=tr[lc].sum+tr[rc].sum;
}
inline void pd(int k)
{
	if(tr[k].lt)
	{
		tr[lc].lt=1,tr[rc].lt=1;
		tr[lc].sum=0,tr[rc].sum=0;
		tr[k].lt=0;
	}
}
inline void add(int l,int r,int ql,int k)
{
	if(ql==l&&ql==r)
	{
		tr[k].sum++;
		return;
	}
	pd(k);
	int mid=(l+r)>>1;
	if(ql<=mid) add(l,mid,ql,lc);
	else add(mid+1,r,ql,rc);
	up(k);
}
inline int query(int l,int r,int ql,int qr,int k)
{
	if(ql<=l&&r<=qr) return tr[k].sum;
	pd(k);
	int mid=(l+r)>>1,sum=0;
	if(ql<=mid) sum+=query(l,mid,ql,qr,lc);
	if(mid<qr) sum+=query(mid+1,r,ql,qr,rc);
	return sum;
}
inline bool check(ll mid)
{
	tr[1].lt=1,tr[1].sum=0;
	ll sum=0,ss=1;
	for(register int i=1;i<=n;i++)
	{
		ll d=query(1,n,z[i]+1,n,1);
		if(sum+d>mid)
		{
			ss++,sum=0;
			tr[1].lt=1,tr[1].sum=0;
		}
		else sum+=d;
		add(1,n,z[i],1);
	}
	return ss<=k;
}
inline void ef()
{
	ll l=0,r=1e10,ans=1e10;
	while(l<=r)
	{
		ll mid=(l+r)>>1;
		if(check(mid)) ans=mid,r=mid-1;
		else l=mid+1;
	}
	printf("%lld\n",ans);
}
int main()
{
	cin>>t;
	while(t--)
	{
		scanf("%d%d",&n,&k);
		for(register int i=1;i<=n;i++)
		{
			int c;
			scanf("%d",&c);
			a[i].s=c,a[i].x=i;
		}
		sort(a+1,a+n+1,cmp);
		for(register int i=1;i<=n;i++) z[a[i].x]=i;
		ef();
	}
	return 0;
}
```

---

## 作者：I_will_AKIOI (赞：1)

非常好的一道题，我交了 $10$ 发才过，~~虽然有一些是过不掉快疯了乱交的~~。

题目很简单，将数组 $a$ 划分为不超过 $k$ 个的序列，使得这些序列的逆序对最大值最小。

看到最大值最小的问题，很容易想到二分。由于一个区间的逆序对个数可达 $n^2$ 级别，所以我们二分上界要开大，还得开 ```long long```。

然后我们就开始求每个区间的逆序对个数。我们遍历这个数组，如果序列加入当前值超过了 $mid$，则我们在这里把序列划分开。若最后我们划分的序列个数超过了 $k$，说明答案太小了，否则当前值可以作为答案，令 $r=mid$。

接下来就是我们的核心部分了，如何求区间逆序对。洛谷上有模板题 [P5047](https://www.luogu.com.cn/problem/P5047)。哇是一道紫题，这题加上二分是不是得评黑啊？当然不是。由于我们这里区间划分是连续的，所以就相当于只求了 $\log n$ 个长度为 $n$ 的逆序对。

我们可以记录每一个数的出现次数（这里值域为 $10^9$，先要离散化）。接着开始枚举。这个数对答案的贡献就是当前区间长度减去小于等于当前数的个数。至于怎么求区间小于 $x$ 的个数，就可以使用树状数组。然后本题就愉快地切掉了。注意枚举下一个区间时要清空树状数组。再遍历刚才的数组，清空即可。

```
#include<bits/stdc++.h>
#define int long long
#define lowbit(x) (x&(-x))
using namespace std;
int n,k,a[100005],b[100005],c[100005];
void update(int x,int y)
{
  while(x<=n)
  {
    c[x]+=y;
    x+=lowbit(x);
  }
  return;
}
int q(int x)
{
  int ans=0;
  while(x)
  {
    ans+=c[x];
    x-=lowbit(x);
  }
  return ans;
}
int query(int l,int r){return q(r)-q(l-1);}
//树状数组的单点修改，区间查询模板
void clear(int l,int r)//清空a[l~r]
{
  for(int i=l;i<=r;i++) update(a[i],-1);
  return;
}
bool check(int x)
{
  int cnt=1,sum=0,last=1;//last记录上一个区间终点
  for(int i=1;i<=n;i++)
  {  
    int now=i-last-query(1,a[i]);//求出当前数对逆序对的贡献
    if(sum+now>x)//无法再加入了，划分出新的区间
    {
      sum=0;
      cnt++;
      clear(last,i-1);
      last=i;
    }
    else sum+=now;
    update(a[i],1);//将当前数加入树状数组
  }
  clear(last,n);
  return cnt<=k;//划分出的序列不超过要求，说明答案合法
}
void solve()
{
  cin>>n>>k;
  for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i];
  if(n==1)
  {
    cout<<0<<"\n";
    return;
  }
  sort(b+1,b+n+1);
  int m=unique(b+1,b+n+1)-b-1;
  for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+m+1,a[i])-b;
  //离散化
  int l=0,r=n*n,mid,ans;
  while(l<r)
  {
    mid=l+r>>1;
    if(check(mid)) r=ans=mid;
    else l=mid+1;
  }
  cout<<ans<<"\n";
  return;
}
signed main()
{
  ios::sync_with_stdio(0);
  int t;
  cin>>t;
  while(t--) solve();
  return 0;
}
```

---

## 作者：homo_snow (赞：0)

题目中一个最大值最小的关键字就锁定了二分。

考虑二分最大不优美度。

对于判断答案的准确性十分简单：暴力。

利用权值线段动态维护逆序对数量，大于了二分答案就清空，如果清空次数用完了就说明答案不符合条件。

最后将数据离散化一下即可通过本题。

> PS：暴力清空线段树会 TLE，所以对于清空的过程需要一点小优化。见代码）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5+10;
const int INF = 0x3f3f3f3f;
const int nxt[2][4] = {{0,1,0,-1},{1,0,-1,0}};
const int mod = 98244353;

int t , n , k ,m,a[N],b[N],tree[N<<2];
int ans = INF;

void build(int pos,int l,int r){
	if(!tree[pos]) return; //如果这段区间没有用过就无视掉
	tree[pos] = 0;
	if(l == r)  return;
	int mid = (l + r) >> 1;
	build(pos<<1,l,mid);
	build(pos<<1|1,mid+1,r);
}

void update(int pos,int l,int r,int x){
	if(l == r){
		tree[pos] ++;
		return;
	}
	int mid = (l + r) >> 1;
	if(x <= mid) update(pos<<1,l,mid,x);
	else update(pos<<1|1,mid+1,r,x);
	tree[pos] = tree[pos<<1]+tree[pos<<1|1];
}

int query(int pos,int l,int r,int x,int y){
	if(l > y || r < x) return 0;
	if(x <= l && r <= y) return tree[pos];
	int mid = (l + r) >> 1,res = 0;
	if(x <= mid) res += query(pos<<1,l,mid,x,y);
	if(mid < y) res += query(pos<<1|1,mid+1,r,x,y);
	return res;
}

int check(int x){
	build(1,1,n);
	int cnt = 1, sum = 0;
	for(int i = 1; i <= n; i++){
		sum += query(1,1,n,a[i]+1,n);
		if(sum > x)build(1,1,n),sum = 0,cnt++;
		if(cnt > k) return 0;
		update(1,1,n,a[i]);
	}
	return 1;
}

signed main(){
	scanf("%lld",&t);
	while(t--){
		ans = INF;
		scanf("%lld%lld",&n,&k);
		for(int i = 1; i <= n; i++)
			scanf("%lld",&a[i]),b[i] = a[i];
		sort(b+1,b+n+1);
		m = unique(b+1,b+n+1) - b - 1;
		for(int i = 1; i <= n; i++) a[i] = lower_bound(b+1,b+m+1,a[i])-b;
		int l = 0, r = n*n;
		while(r - l > 1){
			int mid = (l + r) >> 1;
			if(check(mid)) r = mid;
			else l = mid;
		}
		if(check(l)) printf("%lld\n",l);
		else printf("%lld\n",r);		
	}
}
```

---

## 作者：xuan_gong_dong (赞：0)

## 题面

[P10235 [yLCPC2024] C. 舞萌基本练习](https://www.luogu.com.cn/problem/P10235)

## 分析

考虑二分答案，判断当前的答案是否符合题目中所给的条件，

判断的时候暴力枚举，直到当前枚举的区间逆序对个数超过 $m$，然后区间加 $1$，再重新统计。

判断可以直接用树状数组求逆序对，需要注意的一个细节就是不能用 $\texttt{memset}$ 直接清空树状数组，需要用 $\texttt{fill}$ 或者循环清空，不然 $T$ 过大会被卡住，

时间复杂度为 $O(n \times \log^2 n)$，可以通过。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mid (l+r)/2

int t;

int n,k;
int a[100001],temp[100001];

int tr[100001];
int lowbit(int x) {return x&(-x);}
void add(int i,int v){
    if(i>n) return ;
    return tr[i]+=v,add(i+lowbit(i),v);
}
int check(int i){
    if(i==0) return 0;
    return tr[i]+check(i-lowbit(i));
}

bool DSB_lwy(int m){
    fill(tr,tr+n+1,0);
    int s=0,K=k;
    for(int i=1,j=1;i<=n;i++){
        s+=i-j-check(a[i]);
        if(s>m){
            if(--K==0) return 0;
            for(int w=j;w<i;w++) add(a[w],-1);
            s=0,j=i;
        }
        add(a[i],1);
    }
    return K-(s>m);
}

int solve(){
//	cout<<"QWW";
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++) scanf("%lld",a+i),temp[i]=a[i];
    sort(temp+1,temp+n+1);
    for(int i=1;i<=n;i++)
        a[i]=lower_bound(temp+1,temp+n+1,a[i])-temp;
    
    int l=0,r=9e9;
    while(l<r){
        if(DSB_lwy(mid)) r=mid;
        else l=mid+1;
    }
    return l;
}

signed main(){
    scanf("%lld",&t);
    while(t--) printf("%lld\n",solve());
    return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

发现是求最大值最小值问题，且满足单调性，考虑二分答案。

想一下如何快速判断答案 $x$ 是否合理，考虑贪心算法，如果当前点加入后的逆序对数量大于 $x$，那么此区间结束，下一个区间的左端点为当前点；否则就加入当前区间。

最后如果满足每个区间逆序对数量 $\le x$ 时，区间的数量 $>k$ 了，那么就不符合要求。

求逆序对数量可以选用值域线段树或者树状数组，本篇题解是后者。

时间复杂度为 $O(N \log^2 N)$。

**注意离散化。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pii pair<int, int>

inline int read() {
	int x=0,f=1;char C=getchar();
	while(C<'0'||C>'9'){if(C=='-') f=-1;C=getchar();}
	while(C>='0'&&C<='9') x=(x<<3)+(x<<1)+(C^48),C=getchar();
	return x*f;
}
inline ll rd() {
	ll x=0,f=1;char C=getchar();
	while(C<'0'||C>'9'){if(C=='-') f=-1;C=getchar();}
	while(C>='0'&&C<='9') x=(x<<3)+(x<<1)+(C^48),C=getchar();
	return x*f;
}
inline char get(){
	char C = getchar();
	while(C<'0'||C>'9'){C = getchar();}
	return C;
}
const int N = 1e5+5;
int n, m, k, a[N], b[N];
ll tree[N];
void add(int x, ll val)
{
	for (int i = x; i <= m; i += (i&-i))
		tree[i]+=val;
}
ll ask(int x)
{
	ll res = 0;
	for (int i = x; i; i -= (i&-i))
		res += tree[i];
	return res;
}
bool check(ll x)
{
	int l = 1;
	ll val = 0, ans = 0;
	for (int i = 1; i <= m; i++)
		tree[i] = 0;
	for (int i = 1; i <= n; i++)
	{
		ll now = ask(m)-ask(a[i]);
		if (now + val <= x)
		{
			val += now;
			add(a[i], 1);
		}
		else
		{
			ans++;
			val = 0; 
			for (int j = l; j <= i-1; j++)
				add(a[j], -1);
			//cout << l << " " << i-1 << endl;
			l = i;
			add(a[i], 1);
		}
	}
	//cout << l << " " << n << endl;
	ans++;
	//cout << ans << endl;
	if (ans <= k)
		return true;
	return false;
}
void solve()
{
	n = read();
	k = read();
	for (int i = 1; i <= n; i++)
	{
		a[i] = read();
		b[i] = a[i];
	}
	sort(b+1, b+n+1);
	m = unique(b+1, b+n+1)-b-1;
	for (int i = 1; i <= n; i++)
	{
		a[i] = lower_bound(b+1, b+m+1, a[i])-b;
	}
	ll l = 0, r = 5e9, ans, mid;
	while (l <= r)
	{
		mid=(l+r)>>1;
		//cout << mid << ":\n"; 
		if (check(mid))
		{
			ans = mid;
			r = mid-1;
		}
		else
			l = mid+1;
	}
	cout<<ans<<endl;
}
signed main()
{
	int t = read();
	while (t--)
	{
		solve();
	}
 	return 0; 	
}
```
#### 后话：

因为本人赛时只口胡了并没有写代码，此题解的代码由朋友 [Xlw6friend](https://www.luogu.com.cn/user/741169) 提供。

---

## 作者：WisNourx_ (赞：0)

打比赛的时候机房朋友卡了 1.5h，然后我看半小时写出来了/xk

## 题目分析
看题目是求每个区间的最大逆序对最小，且不能划分超过 $k$ 段。

对于处理逆序对，可以想到用树状数组维护。

好了，接下来咋做内？

一个假思路是维护为以 $i$ 结尾的一段区间的逆序对数。很明显，这样做肯定是错误的。

注意到题目要求求的是**每个区间的最大逆序对数的最小值**。反复品味这句话，不难发现，我们在意的应该是划分的 $tot$ 个区间中逆序对数最大的那一个，其他的区间对于我们并不重要。

如果假定最大逆序对数为 $x$，我们只需要满足每个区间的逆序对数不超过 $x$ 就可以了。

由此可以将问题转化为二分最大逆序对数，判断是否可以满足，进而确定答案。

对于 $\text{check}$ 函数的实现，只需要将序列扫一遍，每次往树状数组中加入 $a_i$，判断逆序对数是否大于 $x$。大于就清空之前加过的值，重新开一段；小于就继续扫。最后判断划分的段数是否大于 $k$ 即可。

由于每次在划分区间时才会清空树状数组，所以实际上 $\text{check}$ 函数的复杂度还是 $O(n \log n)$，总的时间复杂度为 $O(n \log^2 n)$。

代码实现如下：
```cpp
#include<map>
#include<queue>
#include<cmath>
#include<vector>
#include<complex>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#define int long long
using namespace std;

char buf[1<<20], *p1=buf, *p2=buf;
#define getchar() (p1==p2&&(p2=buf+fread(p1=buf, 1, 1<<20, stdin), p1==p2)?EOF:*p1++)
template <typename T>
void read(T &x)
{
	x=0;int f=1;char c=getchar();
	while (!isdigit(c)) f=(c=='-')?-1:1, c=getchar();
	while (isdigit(c)) x=(x<<1)+(x<<3)+c-'0', c=getchar();
	x*=f;
}

typedef long long LL;
const int N=1e5+10, delta=1e9+1;
int n, m, c[N], b[N], a[N];

int lowbit(int x) {return x&-x;}
void add(int x, int k) {for (;x<=n;x+=lowbit(x)) c[x]+=k;}
int getsum(int x) {int res=0;for (;x;x-=lowbit(x)) res+=c[x];return res;}
int get(int x, int i) {return x+getsum(n)-getsum(i);}

bool check(LL x)
{
	int tot=1, res=0, last=1;
	for (int i=1;i<=n;i++)
	{
		add(a[i], 1);
		if (get(res, a[i])>x) 
		{
			for (int j=last;j<i;j++) add(a[j], -1);//当划分序列时才清空
			last=i;tot++;res=get(0, a[i]);
		}
		else res+=get(0, a[i]);
	}
	for (int i=1;i<=n;i++) c[i]=0;
	return tot<=m;
}

signed main()
{
	int T;read(T);
	while (T--)
	{
		read(n), read(m);
		for (int i=1;i<=n;i++) read(a[i]), a[i]+=delta, b[i]=a[i];
		sort(b+1, b+n+1);int k=unique(b+1, b+n+1)-b-1;
		for (int i=1;i<=n;i++) a[i]=lower_bound(b+1, b+k+1, a[i])-b;
      //记得离散化
		int l=0, r=n*n, ans;
      //序列的逆序对数最多为n^2，所以用n^2作为二分上界
      //如果你没用#define int long long，这里记得要用(LL)n*n
		while (l<=r) 
		{
			int mid=(l+r)>>1;
			if (check(mid)) r=mid-1, ans=mid;
			else l=mid+1;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

话说回来，真的有人会用线段树求逆序对吗。。

~~有个抽象机房同学就是这种人~~

---


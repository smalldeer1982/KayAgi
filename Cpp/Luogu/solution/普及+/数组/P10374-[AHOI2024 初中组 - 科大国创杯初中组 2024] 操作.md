# [AHOI2024 初中组 / 科大国创杯初中组 2024] 操作

## 题目背景

**本题的数据不是官方数据。**

**本题征集（能够上传到这里的）官方数据。**

**（没法上传到这里的）官方数据：<https://www.luogu.com.cn/training/499869>**

**本题民间数据下载：<http://8.136.99.126/blog/3/67f0c2307aadac7b413b837b>**

## 题目描述

小可可有一个数组 $\{a_n\}$（初始值为 $\{a_n\}=\{0,0,\ldots,0\}$）和从左到右的 $m$ 个机器，其中第 $i$ 个机器有类别 $o_i \in \{1,2\}$ 和参数 $x_i,y_i$。第 $i$ 个机器执行的操作如下：

- 若 $o_i=1$，则将 $a_{(x_i)}$ 加上 $y_i$，此时保证 $1 \le x_i \le n$，$1 \le y_i \le 10^4$。
- 若 $o_i=2$，则执行第 $x_i \sim y_i$ 个机器的操作各一次，此时保证 $1 \le x_i \le y_i \le i-1$。
- 特别地，保证 $o_1=1$。

现在，小可可依次执行了第 $c_1,c_2,\ldots,c_k$ 个机器的操作各一次，她想知道最后得到的数组 $\{a_n\}$ 是什么。

由于数组中元素的值可能很大，你只需要帮她求出每个元素除以 $10007$ 的余数即可。

## 说明/提示

### 样例 1 解释

先执行第 $1$ 个机器的操作，给 $a_1$ 加上了 $2$。

然后执行第 $2$ 个机器的操作，它操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$。

然后执行第 $3$ 个机器的操作。它先操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$；然后操作了第 $2$ 个机器，第 $2$ 个机器又操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$。

综上所述，最后得到的数组为 $\{8,0\}$。

### 数据范围


对于 $10\%$ 的数据，$n,m,k \le 10$。

对于 $30\%$ 的数据，$n,m,k \le 1000$。

对于另外 $20\%$ 的数据，$n=1$。

对于另外 $20\%$ 的数据，$k=1$。

对于 $100\%$ 的数据，$1 \le n,m,k \le 2 \times 10^5$，$1 \le c_i \le m$，$o_i \in \{1,2\}$，$o_1=1$。此外，对于第 $i$ 个机器，保证：

- 若 $o_i=1$，则 $1 \le x_i \le n$，$1 \le y_i \le 10^4$。
- 若 $o_i=2$，则 $1 \le x_i \le y_i \le i-1$。

## 样例 #1

### 输入

```
2 3 3
1 2 3
1 1 2
2 1 1
2 1 2```

### 输出

```
8 0```

# 题解

## 作者：wrh316 (赞：21)

题目包含重要性质：如果 $oi \gets 2$，那么 $ri<i$。也就是说调用关系不会构成环。

考虑维护每个机器的调用次数 $t$，初始的时候 $t$ 为一，表示第 $ci$ 台机器需要调用一次。此时除了编号最大的机器的调用次数是确定的，其余机器都可能不是正确的调用次数。

我们从大到小扫描每一台机器，并且将他对前面机器的影响下传。假设当前为第 $i$ 台机器，由于机器的操作只有两种，如果是 $1$ 操作，说明其会执行 $ti$ 次 $a _ {xi}$ 加上 $yi$ 的操作，也就是相当于 $a _ {xi}←a _ {xi}+ti×yi$。如果是 $2$ 操作，相当于将 $[li,ri]$ 范围内的 $t$ 加一。这一步显然不可以暴力，但是发现是一个区间加，可以采用打差分标记。由于扫描线是从右往左，所以在 $ri$ 处打上加一，$li-1$ 处打上减一标记，然后利用一个变量 $sum$ 从右往左累和到i处即可得到 $ti$。累和的过程跟随扫描线一同进行，这样复杂度仅为 $O(n)$。

采用打差分标记代码：
```
t[c]++;
t[c - 1]--;
```
从大到小扫描每一台机器代码：
```
for (int i = m; i >= 1; i--) {
	ans = (ans + t[i]) % mod;
	if (type[i] == 1) a[x[i]] = (a[x[i]] + y[i] * ans) % mod;
	else {
		t[y[i]] = (t[y[i]] + ans) % mod;
		t[x[i] - 1] = (t[x[i] - 1] + mod - ans) % mod;
	}
}
```

---

## 作者：2021sunzishan (赞：9)

这是一篇差分题解，应该能看得懂。

## 思路：
首先观察题目，肯定不会让你真的一个个修改（时间爆炸），所以一定需要算出每个机器人被执行的次数（第一次刺激）。
那么求次数的难点就在于机器人还有区间嵌套（第二次刺激）。

这两次刺激以后，你想到了什么？反正我想到了差分。

读题可以看到：$1\le x_i\le y_i\le i-1$。这说明什么？说明前面的机器人只受后面的影响。换句人话说，就是只要后面的机器人处理完，这个机器人的执行次数就知道了。

至此，本题思路就出来了：倒着做差分。实现非常简单。

**切勿抄袭！！！**
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
int n,m,k,mod=10007;
int d[N],ans[N];
inline int read(){
	int a=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*f;
}
struct node{
	int l,r,x,y,opt;
}a[N];
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read(),m=read(),k=read();
	for(int i=1;i<=k;i++){
		int x=read();
		d[x]++,d[x-1]--;//初始执行次数
	}
	for(int i=1;i<=m;i++){
		a[i].opt=read();
		if(a[i].opt==1)
			a[i].x=read(),a[i].y=read();
		else
			a[i].l=read(),a[i].r=read();
	}
	int s=0;
	for(int i=m;i>=1;i--){
		s+=d[i],s=(s+mod)%mod;
		d[i]=s;//s就是当前这个机器人i的执行次数
		if(a[i].opt==1)continue;
		int l=a[i].l,r=a[i].r;
		d[r]+=s,d[l-1]-=s;//反向差分
		d[r]=(d[r]+mod)%mod,d[l-1]=(d[l-1]+mod)%mod;
	}
	for(int i=1;i<=m;i++){
		if(a[i].opt==2)continue;
		ans[a[i].x]+=a[i].y%mod*d[i]%mod,ans[a[i].x]%=mod;//累计答案
	}
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]);
	return 0;
}

```
## 坑点
- 对于可能的负数，最好的方法就是加模取模。
- 机器人们可能在同一个位置修改多次，所以最后 $ans$ 不是直接赋值。
- 机器人是 $m$ 个不是 $n$ 个。

完结~

---

## 作者：喵仔牛奶 (赞：6)

推荐大家做 [P7077](https://www.luogu.com.cn/problem/P7077)。

对于 $o_i=1$ 的操作显然可以利用数组 $\mathcal{O}(1)$ 完成。

对于 $o_i=2$，观察到 $y_i<i$，也就是只有编号大于 $i$ 的函数才会直接或间接地调用 $i$。考虑枚举 $i=n,(n-1),...,1$，维护 $i$ 被调用的次数 $d_i$，每次操作就相当于将 $j\in[x_i,y_i]$ 的 $d_j$ 加上 $d_i$。使用差分实现即可。

时间复杂度 $\mathcal{O}(n+m+k)$。

代码：
```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 1e6 + 5, mod = 10007;
	int n, m, k, u, v, op[N], x[N], y[N], d[N], a[N];
	void Add(int& x, int y) { x = (x + y) % mod; }
	int main() {
		cin >> m >> n >> k; // 对调了 n 和 m
		REP(i, 1, k) cin >> u, d[u] ++;
		REP(i, 1, n) cin >> op[i] >> x[i] >> y[i], Add(d[i], mod - d[i + 1]);
		DEP(i, n, 1) {
			Add(d[i], d[i + 1]);
			if (op[i] == 1) Add(a[x[i]], y[i] * d[i]);
			if (op[i] == 2) Add(d[y[i]], d[i]), Add(d[x[i] - 1], mod - d[i]);
		}
		REP(i, 1, m) cout << a[i] << ' ';
		cout << '\n';
		return 0;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：Hulless_barley (赞：4)

[P10374 [AHOI2024 初中组] 操作](https://www.luogu.com.cn/problem/P10374)

首先，这题显而易见可以用差分来做。差分每台机器的执行次数，然后求所有 $o_i=1$ 的机器操作结果。

那么，如何对每台机器的执行次数进行差分呢？得分两种情况讨论：
1. $o_i=1$，相当于 $x_i$ 到 $x_i$ 的区间内每个机器都操作了一遍，`e[x[i]]++,e[x[i]-1]--`；
2. $o_i=2$，相当于 $x_i$ 到 $y_i$ 的区间内每个机器都操作了一遍，`e[y[i]]++,e[x[i]-1]--`。

我们先将 $c$ 里面的 $k$ 台机器都执行一遍，求出每台机器真正要执行多少遍。

但是有个棘手的问题，$o_i=2$ 的机器可能会执行 $o_i=2$ 的机器。那岂不又要做一遍差分了吗？做完后万一又出现了 $o_i=2$ 的机器怎么办？但是题目数据说当 $o_i=2$ 时，$1\le x_i\le y_i\le i-1$。所以每台机器只会对自己前面的机器产生影响。那么就可以从后往前遍历每台机器，边做差分的前缀和操作，边改变差分数组。

至此，题目思路已讲完。但还有很多坑点。
# 坑点一
$n,m,k$ 容易弄混，注意检查每个 `for` 循环的终止条件。
# 坑点二
在遍历 $c$ 的循环中，注意不要把 `c[i]` 写成 `i`（关键这个错误还特别难检查）。
# 坑点三
在遍历 $c$ 的循环中，如果 $o_i=1$，那么需要操作的区间是 $[c_i,c_i]$ 而非 $[x_{c_i},x_{c_i}]$。
# 坑点四
不要偷懒，每个地方都要取模。

例如：
- `a[x[i]]=(a[x[i]]+sum*(y[i]%mod)%mod)%mod`
- ```cpp
  e[r]+=s,e[r]%=mod;
  e[l-1]-=s,e[l-1]%=mod;
  ```
- `sum=(sum+e[i]+mod)%mod;`
# 坑点五
可能出现负数，所以需要加上 $mod$ 再模 $mod$。

- 错误示范：`sum=(sum+e[i])%mod;`；
- 正确示范：`sum=(sum+e[i]+mod)%mod;`。
# 坑点六
（我为了偷懒所以用了一个过程修改差分数组）

```cpp
void make(int l,int r,int s){
	e[r]+=s,e[r]%=mod;
	e[l-1]-=s,e[l-1]%=mod;
}
```
一定要加第三个参数 $s$，不是所有情况都是 `++` 或 `--`。

# 坑点七
小样例太水了，以上大部分坑点都无法检查出来（别问我怎么知道的，都是 WA 的教训啊）。

建议动手做几个样例。这里贡献一个：

输入：
```
10 10 5
1 4 6 7 10 
1 1 1
2 1 1
2 1 2
2 1 3
1 4 9
1 2 4
2 1 5
1 3 7
1 6 6
2 1 9
```

输出：
```
29 8 7 27 0 6 0 0 0 0
```


另外，测试样例或者代码可以用暴力对拍。

```cpp
void op(int p){
	if(o[p]==1)a[x[p]]+=y[p];
	else for(int i=x[p];i<=y[p];i++)op(i);
}
void s(){
	for(int i=1;i<=k;i++)op(c[i]);
	for(int i=1;i<=n;i++)printf("%lld ",a[i]);
	cout<<'\n';
	memset(a,0,sizeof a);
}
```


没了，放个代码，完结撒花！（qwq 做对这题太不容易了）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5+5;
const int mod = 10007;
int a[N],c[N],o[N],x[N],y[N],e[N],q[N];
int n,m,k,sum;
void make(int l,int r,int s){
	e[r]+=s,e[r]%=mod;
	e[l-1]-=s,e[l-1]%=mod;
}
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
		scanf("%lld",&c[i]);
	for(int i=1;i<=m;i++)
		scanf("%lld %lld %lld",&o[i],&x[i],&y[i]);
	for(int i=1;i<=k;i++){
		if(o[c[i]]==1)make(c[i],c[i],1);
		else make(x[c[i]],y[c[i]],1);
	}
	for(int i=m;i>=1;i--){
		sum=(sum+e[i]+mod)%mod;
		if(o[i]==2)make(x[i],y[i],sum);
		else a[x[i]]=(a[x[i]]+sum*(y[i]%mod)%mod)%mod;
	}
	for(int i=1;i<=n;i++)
		printf("%lld ",a[i]);
	return 0;
}
```

---

## 作者：wrh316 (赞：4)

### 思路
因为这题题目说每次执行第二种机器时，只会执行他左边的机器。所以我们就能想到，倒着遍历操作序列，每次遇到一类型的机器时，$cnt _ {x}$ 增加 $1$。

当遇到二类型的机器时，循环 $x _ {i} \sim y _ {i}$ 加上次数。

注意：这里加上的次数不是 $1$，而是当前这个 $2$ 类型的机器的操作次数，当前这个机器操作了 $n$ 次，那 $x _ {i} \sim y _ {i}$ 的机器当然也操作了 $n$ 次，所以我们就有了：
```c++
for(int i = xi;i <= yi;i++) cnt[i] += cnt[x];
```
但是光这样写还是会超时，重点就是在这个循环时间太长了，所以我们要想办法降低这个循环。有什么方法可以快速更新一个区间的特征值呢？可以想到用线段树。
### 线段树思路
首先，我们遍历操作序列，桶计数，计算每个机器的操作次数 $cnt _ {x}$。

然后倒着遍历机器，对于二类型的机器，如果遍历到，操作次数确定，再计算当前机器的操作次数，进行单点更新，接着： 

- 如果当前机器是一类型，直接加。
- 如果当前机器是二类型，区间更新。

最后输出即可。
```c++
#include <bits/stdc++.h>
#define MAXN 200005
using namespace std;

const int MOD = 10007;
int n,m,k;
int cnt[MAXN * 4],add[MAXN * 4];
int a[MAXN];
int op[MAXN],l[MAXN],r[MAXN];
void down(int p,int l,int r){
	if(add[p]){
		add[p * 2] = (add[p * 2] + add[p]) % MOD;
		add[p * 2 + 1] = (add[p * 2 + 1] + add[p]) % MOD;
		add[p] = 0;
	}
	return ;
}
void get(int p,int l,int r,int x){
	if(x < l || x > r) return ;
	if(l == r){
		cnt[x] = (cnt[x] + add[p]) % MOD;
		add[p] = 0;
		return ;
	}
	down(p,l,r);
	int mid = l + r >> 1;
	get(p * 2,l,mid,x);
	get(p * 2 + 1,mid + 1,r,x);
	return ;
}
void update(int p,int l,int r,int x,int y,int v){
	if(y < l || x > r) return ;
	if(x <= l && r <= y){
		add[p] = (add[p] + v) % MOD;
		return ;
	}
	down(p,l,r);
	int mid = l + r >> 1;
	update(p * 2,l,mid,x,y,v);
	update(p * 2 + 1,mid + 1,r,x,y,v);
	return ;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>k;
	for(int i = 1,x;i <= k;i++){
		cin>>x;
		cnt[x] = (cnt[x] + 1) % MOD;
	}
	for(int i = 1;i <= m;i++) cin>>op[i]>>l[i]>>r[i];
	for(int i = m;i >= 1;i--){
		get(1,1,m,i);
		if(op[i] == 1) a[l[i]] = (a[l[i]] + r[i] * cnt[i]) % MOD;
		else update(1,1,m,l[i],r[i],cnt[i]);
	}
	for(int i = 1;i <= n;i++) cout<<a[i]<<" ";
	return 0;
}
```

---

## 作者：DLJdouliangjian (赞：3)

## AHOI2024初中组 操作 线段树写法题解  
这题第一眼看上去肯定是用模拟，遍历操作序列，依次操作，然而不用多说，肯定会超时。  
所以要换思路：
既然每个机器的操作是不变的，那我们不妨记录每个机器的操作次数，第 $x$ 台机器的操作次数记为 $cnt_{x}$ 
这题还有一个重要条件：  
若 $o_{i}$ = $2$ ,则执行机器 $ x_{i}$ 到 $y_{i}$ 的操作各一次，此时保证  
$1 \le x_{i} \le y_{i}< i-1 $ 。

翻译过来就是每次执行第二种机器时，只会执行他左边的机器。  
所以我们就能想到，倒着遍历操作序列。  
每次遇到一类型的机器时，`cnt[x]++`。  
遇到二类型的机器时  循环 $ x_{i}$ 到 $y_{i}$ 加上次数。  

注意：这里加上的次数不是 $1$，而是当前这个 $2$ 类型的机器的操作次数，很好理解，当前这个机器操作了 $n$ 次，那 $x_{i}$ 到 $y_{i}$ 的机器当然也操作了 $n$ 次,所以我们就有了：  
```cpp
for(int i=xi;i<=yi;i++){   
    cnt[i]+=cnt[x]   
}
```
但是捏，介个样子他还是会超时，重点就是在这个循环时间太长了，所以我们要想办法降低这个循环。  
有什么方法可以快速更新一个区间的特征值呢？？？  
然后我们就可以想到用 
### 线段树 。
至此，思路就分析好了，接下来是代码： 
 
```cpp
#include<bits/stdc++.h>  
#define MAXN 200005  
using namespace std;  
const int MOD=10007;  
int n,m,k;  
int cnt[MAXN * 4],add[MAXN * 4];  
int a[MAXN];  
int op[MAXN],l[MAXN],r[MAXN];

void down(int p,int l,int r){  
    if(add[p]){  
        add[p * 2]+=add[p];  
        add[p * 2 + 1]+=add[p];  
        add[p]=0;  
    }  
}  
void get(int p,int l,int r,int x){  
    if(x<l||x>r){  
        return ;  
    }  
    if(l==r){  
        cnt[x]=(cnt[x]+add[p])%MOD;  
        add[p]=0;  
        return ;  
    }  
    down(p,l,r);  
    int mid=l+r>>1;  
    get(p*2,l,mid,x);  
    get(p*2+1,mid+1,r,x);  
    return ;  
}  
void update(int p,int l,int r,int x,int y,int v){  
    if(x>r||y<l) return ;  
    if(x<=l&&r<=y){  
        add[p]=(add[p]+v)%MOD;  
        return ;  
    }  
    down(p,l,r);  
    int m=l+r>>1;  
    update(p*2,l,m,x,y,v);  
    update(p*2+1,m+1,r,x,y,v);  
    return ;  
}  
int main(){  
    cin>>n>>m>>k;  
    for(int i=1,x;i<=k;i++){  
        cin>>x;  
        cnt[x]=(cnt[x]+1)%MOD;  
    }  
    for(int i=1;i<=m;i++){  
        cin>>op[i]>>l[i]>>r[i];  
    }  
    for(int i=m;i>=1;i--){  
        get(1,1,m,i);  
        if(op[i]==1) a[l[i]]=(a[l[i]]+r[i]*cnt[i])%MOD;  
        else{  
            update(1,1,m,l[i],r[i],cnt[i]);  
        }  
    }  
    for(int i=1;i<=n;i++){  
        cout<<a[i]<<" ";  
    }  
    return 0;
}
```

---

## 作者：ran_qwq (赞：3)

此题的突破口在于 $2$ 操作满足 $1\le x_i\le y_i\le i-1$，也就是第 $i$ 个 $2$ 操作在执行了其他操作以后**不会再被执行**，且可以看作**从后往前**执行。

这里的操作是单点加，单点查，所以没必要对区间维护线段树。我们对**操作**维护线段树，维护每个操作应该被操作的**次数**。从后往前扫，扫到第 $i$ 个操作，设当前的次数是 $t_i$，则把 $t_{x_i}\sim t_{y_i}$ 全部加上 $t_i$。

这样我们就算出了每个操作的实际执行次数。开个桶维护每个数最后的值即可。

核心代码：

```cpp
void QwQ() {
	n=rd(),m=rd(),k=rd();
	for(int i=1,x;i<=k;i++) x=rd(),T.upd(1,1,m,x,x,1);
	for(int i=1;i<=m;i++) p[i]={rd(),rd(),rd()};
	for(int i=m;i;i--) if(p[i].op==2) T.upd(1,1,m,p[i].x,p[i].y,T.qry(1,1,m,i));
	for(int i=1;i<=m;i++) if(p[i].op==1) a[p[i].x]=vadd(a[p[i].x],vmul(p[i].y,T.qry(1,1,m,i)));
	for(int i=1;i<=n;i++) wr(a[i]," ");
}
```

---

## 作者：liuhaoyan0323 (赞：2)

线段树好题。
## 思路
首先考虑直接模拟，然后你就会发现超时。
  
再次读题发现没有要求强制在线，那么我们将 $o_i=1$ 操作先存起来，对于 $o_i=2$ 操作我们总能将其拆为若干个 $o_i=1$ 操作存起来，最后模拟做 $o_i=1$ 的操作。  
  
说到数列操作，便想到差分和线段树，保险起见这里我们采用线段树。

~~赛场没想到这一步。悲~~

## 代码
```cpp
#include<bits/stdc++.h>
#define N 20000005
#define P 10007
using namespace std;
typedef struct TreeNode{
	int l,r,sum;
}TreeNode;
TreeNode tr[N];
typedef struct Machine{
	int op,x,y;
}Machine;
Machine machine[N];
int n,m,K,a[N],ans[N];
void build(int idx,int l,int r){
	tr[idx]={l,r,0};
	if(l==r)return;
	int mid=(l+r)>>1;
	build(idx<<1,l,mid);
	build(idx<<1|1,mid+1,r);
}
void update(int idx,int l,int r,int k){
	if(l<=tr[idx].l&&r>=tr[idx].r){
		tr[idx].sum=(tr[idx].sum+k)%P;
		return;
	}
	int mid=(tr[idx].l+tr[idx].r)>>1;
	if(l<=mid)update(idx<<1,l,r,k);
	if(r>mid)update(idx<<1|1,l,r,k);
}
int solve(int idx,int x){
	if(tr[idx].l==tr[idx].r)return tr[idx].sum;
	tr[idx<<1].sum=(tr[idx<<1].sum+tr[idx].sum)%P;
	tr[idx<<1|1].sum=(tr[idx<<1|1].sum+tr[idx].sum)%P;
	tr[idx].sum=0;
	int mid=(tr[idx].l+tr[idx].r)>>1;
	if(x<=mid)return solve(idx<<1,x);
	return solve(idx<<1|1,x);
}
int main(){
	int n,m,K;
	scanf("%d%d%d",&n,&m,&K);
	for(int i=1;i<=K;i++){
		int x;
		scanf("%d",&x);
		a[x]=(a[x]+1)%P;
	}
	for(int i=1;i<=m;i++){
		int op,x,y;
		scanf("%d%d%d",&op,&x,&y);
		machine[i]={op,x,y};
	}
	build(1,1,m);
	for(int i=m;i>=1;i--){
		if(machine[i].op==1)update(1,i,i,a[i]);
		else{
			int t=solve(1,i);
			update(1,machine[i].x,machine[i].y,(t+a[i])%P);
		}
	}
	for(int i=1;i<=m;i++){
		if(machine[i].op==1){
			(ans[machine[i].x]+=solve(1,i)*machine[i].y%P)%=P;
		}
	}
	for(int i=1;i<=n;i++)printf("%d ",ans[i]%P);
	return 0;
}
```

---

## 作者：lilong (赞：2)

提供一种树状数组的做法。

对于每个操作，我们考虑求出它执行的次数。题目保证了对于操作 $2$ 所执行的操作编号都比其自身编号小，换句话说，即每个操作的执行次数是由**编号比它大的操作决定的**。

有了这个性质后，不难发现可以倒着扫一遍每个操作。对于当前操作 $i$，可以通过前面的处理得到其执行的次数。如果是操作 $1$，直接更新 $a$ 数组即可。如果是操作 $2$，则对执行操作的区间加上当前操作的次数即可（因为也要做相同的次数）。

现在我们需要一个东西来实现区间修改、单点查询。树状数组就是一个不错的选择。

时间复杂度 $O(m\log m)$，其中 $m$ 为操作个数。

```cpp
#include <iostream>
#include <cstdio>
#define MOD 10007

using namespace std;

int n,m,k,d,a[1000001],c,o[1000001],x[1000001],y[1000001];
int t[1000001];

int lowbit( int x )
{
	return x & ( -x );
}

void update( int x , int y )
{
	for( int i = x ; i <= m ; i += lowbit( i ) )
		t[i] = ( ( t[i] + y ) % MOD + MOD ) % MOD;//注意这里可能会加上一个负数，因此需要特别处理。
}

int query( int x )
{
	int sum = 0;
	for( int i = x ; i >= 1 ; i -= lowbit( i ) )
		sum = ( sum + t[i] ) % MOD;
	return sum;
}

int main()
{
	scanf( "%d%d%d" , &n , &m , &k );
	for( int i = 1 ; i <= k ; i ++ )
		scanf( "%d" , &c ),update( c , 1 ),update( c + 1 , -1 );//初始输入的操作都要执行一遍。
	for( int i = 1 ; i <= m ; i ++ )
		scanf( "%d%d%d" , &o[i] , &x[i] , &y[i] );
	for( int i = m ; i >= 1 ; i -- )
	{
		if( o[i] == 1 ) a[x[i]] = ( a[x[i]] + query( i ) * y[i] % MOD ) % MOD;
		if( o[i] == 2 ) d = query( i ),update( x[i] , d ),update( y[i] + 1 , -d );
	}
	for( int i = 1 ; i <= n ; i ++ )
		printf( "%d " , a[i] );
	return 0;
}
```

---

## 作者：QinghongLi (赞：2)

# 分析
当 $o_i$ 等于 $2$ 时 $y_i$ 小于 $i$ 那么显然从后往前执行时，可以先将 $x_i$ 到 $y_i$ 的区间加该操作需要操作的次数，来标记该区间的操作需要操作。区间赋值，显然的差分就能解决。细节看我代码和注释，代码简洁，注释详细。
# 代码
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define mod 10007
using namespace std;
long long int book[200005],c[200005][3],a[200005];
int main()
{
    long long int n,m,k,now=0,b;
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++)scanf("%lld",&b),book[b]++,book[b-1]--;//把k次运行变成差分
    for(int i=1;i<=m;i++)scanf("%lld%lld%lld",&c[i][0],&c[i][1],&c[i][2]);
    for(int j=m;j>0;j--){
        now=(book[j]%mod+now+mod*100)%mod;//m和n的值都已经比模数大了，如果给一个差分取模了，很可能因为前面的负数而报错
        if(c[j][0]==1)
            a[c[j][1]]=(a[c[j][1]]+now%mod*(c[j][2]%mod))%mod;
        else{
            book[c[j][2]]=(book[c[j][2]]+now)%mod;
            book[c[j][1]-1]=(book[c[j][1]-1]-now+mod*100000)%mod;//模数太小，单纯加mod不够用
        }
    }
    for(int i=1;i<=n;i++)printf("%lld ",a[i]);
    return 0;
}

```

---

## 作者：Tipsy_bamboo (赞：1)

此题的关键在于每个机器只能操作他前面的机器，因为如果可以操作后面的，那么可能出现无穷无尽的死循环。
每一个机器添加的值不一样，如果出现区间修改，每个机器会成为维护的障碍。
此时注意到虽然无法及时的更新 $a$ 数组里的值，但是我们很容易发现知道每个机器的操作次数后可以很快地求出 $a$ 数组。
所以我们使用树状数组（线段树也可以）维护哪些机器被使用了多少次。因为每个机器只能操作前面的，我们从后往前扫描，如果是操作别的机器的机器，就进行区间修改。如果是修改 $a$ 数组的机器，就跳过。
遍历结束后可以发现只有修改 $a$ 数组的机器有值，此时直接修改 $a$ 数组即可。

```cpp
#include<bits/stdc++.h>
using namespace std;


const long long N = 2e5 + 5, P = 10007;

struct type {
	long long t, x, y;
};

type m[N];
long long a[N], c[N], tree[4 * N], tag[4 * N];

void pushup (long long pos) {
	tree[pos] = (tree[pos << 1] + tree[pos << 1 | 1]) % P;
}

void addtag (long long pos, long long l, long long r, long long num) {
	tree[pos] = (tree[pos] + (r - l + 1) * num % P) % P;
	tag[pos] = (tag[pos] + num) % P;
}

void pushdown (long long pos, long long l, long long r) {
	long long mid;
	if (tag[pos] == 0) return;
	mid = (l + r) >> 1;
	addtag (pos << 1, l, mid, tag[pos]);
	addtag (pos << 1 | 1, mid + 1, r, tag[pos]);
	tag[pos] = 0;
}

void update (long long pos, long long l, long long r, long long pl, long long pr, long long num) {
	long long mid;
	if (pl <= l && r <= pr) {
		addtag (pos, l, r, num);
		return;
	}
	pushdown (pos, l, r);
	mid = (l + r) >> 1;
	if (pl <= mid) update (pos << 1, l, mid, pl, pr, num);
	if (pr > mid) update (pos << 1 | 1, mid + 1, r, pl, pr, num);
	pushup (pos);
}

long long query (long long pos, long long l, long long r, long long p) {
	long long mid;
	if (l == r) return tree[pos];
	pushdown (pos, l, r);
	mid = (l + r) >> 1;
	if (p <= mid) return query (pos << 1, l, mid, p);
	if (p > mid) return query (pos << 1 | 1, mid + 1, r, p);
}

int main () {
	ios :: sync_with_stdio (false);
	cin.tie (0);
	cout.tie (0);
	long long n, m2, k, temp;
	cin >> n >> m2 >> k;
	for (long long i = 1; i <= k; ++i) {
		cin >> c[i];
	}
	for (long long i = 1; i <= m2; ++i) {
		cin >> m[i].t >> m[i].x >> m[i].y;
	}
	for (long long i = 1; i <= k; ++i) {
		if (m[c[i]].t == 1) update (1, 1, m2, c[i], c[i], 1);
		if (m[c[i]].t == 2) update (1, 1, m2, m[c[i]].x, m[c[i]].y, 1);
	}
	for (long long i = m2; i >= 1; --i) {
		if (m[i].t == 1) continue;
		temp = query (1, 1, m2, i);
		if (temp == 0) continue;
		update (1, 1, m2, m[i].x, m[i].y, temp);
	}
	for (long long i = 1; i <= m2; ++i) {
		if (m[i].t == 2) continue;
		temp = query (1, 1, m2, i);
		a[m[i].x] = (a[m[i].x] + m[i].y * temp % P) % P;
	}
	for (long long i = 1; i <= n; ++i) {
		cout << a[i] << " ";
	}
	cout << endl;
	return 0;
}
```

---

## 作者：ryf_loser (赞：1)

### 此题大意：
 给你 $n$ 个机器，每个机器有两种操作：1. 给 $a_{x}$ 加上 $y$。2. 操作从 $x$ 到 $y$ 的机器。输出 $a$ 数组。

### 此题正解：差分。

想到对每一个元素计算操作了几次操作一，最终直接做乘法。显然想到差分，最终前缀和求次数。

但是显然有很多操作一，正向差分+前缀和时间复杂度显然达到 $O(m^2)$，超时。

想到逆向操作，大部分人用的是这种方法，我就不说了。这了说的是树状数组或线段树将 $O(m^2)$ 化简成 $O(\log(m)m)$。

为什么用树状数组或线段树，是因为如果用前缀和，每次都需要 $O(m)$ 进行求和，时间复杂度过大，用树状数组或线段树优化成 $O(\log(m))$ 即可。

### 赛时丑陋代码，请见谅。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10007;
int n,m,k,b[200005],c[200005],a[200005];
long long tre[200005];//树状数组
struct node{int flag,x,y,t;}s[200005];
inline void work(int x,long long k){//树状数组插入
        while (x<=m){tre[x]+=k;x+=x&(-x);}
}
inline long long ask(int x){//树状数组查询
	long long ans=0;while (x>0){(ans+=tre[x])%=mod;x-=x&(-x);}
	if (ans<0)ans+=mod;
	return ans;
}
int main(){
	scanf ("%d%d%d",&n,&m,&k);
	for (int i=1;i<=k;i++)scanf ("%d",&c[i]);
	for (int i=1;i<=m;i++)scanf ("%d%d%d",&s[i].flag,&s[i].x,&s[i].y);
	for (int i=1;i<=k;i++)s[c[i]].t++;
	for (int i=m;i>=1;i--){//倒推
		(s[i].t+=ask(i))%=mod;//注意取模，否则过大溢出
		if (s[i].t){
			if (s[i].flag==1)(a[s[i].x]+=s[i].y*s[i].t%mod)%=mod;//操作 1
			else work(s[i].x,s[i].t),work(s[i].y+1,-s[i].t);//操作 2
		}
	}
	for (int i=1;i<=n;i++)printf ("%d ",a[i]);//输出
	return 0;
}
```

### 结尾

赛时拿到满分，但在取模方面写了很长时间，导致 T4 没时间写，最后擦线……

---

## 作者：LionBlaze (赞：1)

做这道题，我们要考虑到操作的两个性质：

> 1. 每次执行同一个操作得到的结果都是一样的。
> 3. $k$ 次执行同一个操作相当于将执行一次这个操作的更改 $\times k$。

还有操作二（$o_i = 2$）的一个性质：

> 只会执行编号在 $i$ 之前的操作。

所以，我们可以这样做：

因为操作二的性质，所以我们可以倒着看每一条操作。下面定义 $cnt_i$ 为编号为 $i$ 的操作**实际**执行的次数（所以刚开始时每个 $cnt_{(c_i)}$ 都要为 $1$）：

1. 倒序枚举每一个操作，设这次操作编号为 $i$。
2. 如果 $o_i = 1$，即为直接修改操作，则直接将 $a_{(x_i)}$ 加上 $y_i$，但是要加上 $cnt_i$ 次，所以总共加上 $y_i \times cnt_i$。
3. 否则，为区间调用操作，将 $cnt_{(x_i)}, cnt_{(x_i+1)}, cnt_{(x_i+2)}, \cdots, cnt_{(y_i)}$ 都加上 $1$（都多调用一次），但是一共要加上 $cnt_i$ 次，所以一共加上的是 $cnt_i$。

但是，现在的时间复杂度仍然是 $O(nm)$ 的，因为每次将 $cnt_{(x_i)}$ 到 $cnt_{(y_i)}$ 加上 $cnt_i$ 时，仍然需要 $O(n)$ 复杂度。

如何优化区间加减？考虑差分。

但是！！如果直接从前往后差分的话，不可以实时知道 $cnt_i$，所以需要从后往前差分。

还有，就是注意 $cnt_i$ 可能会非常大，所以需要**实时取模**，但是有减法，取模然后加上模数再取模就好。

这题就完美地结束啦~

```
#include <cstdio>

using namespace std;

int o[200005], x[200005], y[200005], cnt[200005], a[200005];

int main()
{
    int n, m, k;
    scanf("%d%d%d", &n, &m, &k);
    for(int i=1;i<=k;i++)
    {
        int c_i;
        scanf("%d", &c_i);
        cnt[c_i]++;
        cnt[c_i-1]--; //单点修改
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d", o + i, x + i, y + i);
    }
    for(int i=m;i>=1;i--)
    {
        cnt[i] = ((cnt[i] + cnt[i+1]) % 10007 + 10007) % 10007; //从后往前差分
        if(o[i] == 2)
        {
            cnt[y[i]] += cnt[i];
            cnt[x[i]-1] -= cnt[i]; //区间修改
        }
        else a[x[i]] = (a[x[i]] + y[i]*cnt[i]) % 10007;
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d%c", a[i], " \n"[i == n]);
    }
    return 0;
}
```

---

## 作者：zbzbzzb (赞：1)

第一种操作肯定很简单。

难点在于第二种操作，观察数据范围发现 $1\le x_i\le y_i\le i−1$，可以知道每个机器只会受后面的机器影响。

那么就可以开一个数组统计一下每个机器调用过多少次，使用差分计算，然后直接乘 $y_i$ 就行了。

那么倒着差分，每次枚举到 $op=2$ 都要差分一下，然后枚举到 $op=1$ 就直接用 $y_i \times d_i$ 即可。

CODE：

```
#include<bits/stdc++.h>
using namespace std;
const int mod=10007;
int n,m,k,tmp,sum,ret[200010],d[200010],l[200010],r[200010],cl[200010],cr[200010],op[200010];
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++){
		scanf("%d",&tmp);
		d[tmp]++;
		d[tmp-1]--;//计算初始的操作数
	}for(int i=1;i<=m;i++){
		scanf("%d",&op[i]);
		if(op[i]==1){
			scanf("%d%d",&l[i],&r[i]);
		}else{
			scanf("%d%d",&cl[i],&cr[i]);
		}
	}for(int i=m;i>=1;i--){
		sum=(sum+d[i]+mod)%mod;
		d[i]=sum;//sum是执行的次数
		if(op[i]==2){
			d[cr[i]]=((d[cr[i]]+sum)+mod)%mod;//差分
			d[cl[i]-1]=((d[cl[i]-1]-sum)+mod)%mod;
		}
	}for(int i=1;i<=m;i++){
		if(op[i]==1){
			ret[l[i]]=(ret[l[i]]+r[i]*d[i])%mod;//计算出y*次数
			ret[l[i]]=(ret[l[i]]+mod)%mod;
		}
	}for(int i=1;i<=n;i++){
		printf("%d ",ret[i]);//输出
	}return 0;
}
```

---

## 作者：_7thRC_CB_CRP_ (赞：1)

# soulution

首先知道，我们操作顺序并不影响，因为每个操作都单独分开。

所以我们考虑从后往前处理。

接着我们复杂度的瓶颈是什么呢？

是因为我们将操作分开了，导致于被操作二卡住了。所以尝试看能不能合起来，答案是可以的，因为一个位置被其他机器触发的操作和原本的操作其实就是一样的。

那么从后往前枚举，尝试记录每个机器人的操作次数，最后再来统一进行一操作。

如果这个点是 $o_i=2$ 那么将他操作，将 $[x_i,y_i]$ 每个元素加上它的值，并将它清零，这样从后往前枚举每一个数就行了。

这个时候仍需要有一种方法维护动态区间修改、单点查询。所以我们只需要用线段树来进行维护就行了。

但思路还可以近一步优化，考虑我们的枚举顺序，发现我们每个东西都只访问一次，并且顺序统一，每次操作只改变前面的结果，那么我们可以采取从后往前差分的方式。

# code of Segment Tree

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
long long as[200001];
long long o[200001],x[200001],y[200001];
struct node {
	long long left,right;
	long long add;
	long long vis1;
};
node tree[50000001]; 
void build(long long now) {
	tree[now].add%=10007;
	tree[now].vis1%=10007;
	if(tree[now].left==tree[now].right) 
		return;
	tree[now*2].left=tree[now].left;
	tree[now*2].right=((tree[now].right+tree[now].left)>>1);
	tree[now*2+1].left=tree[now*2].right+1;
	tree[now*2+1].right=tree[now].right;
	build(now*2);
	build(now*2+1);
}
void make(long long i,long long a,long long b,long long c) {
	tree[i].add%=10007;
	tree[i].vis1%=10007;
	if(a<=tree[i].left&&b>=tree[i].right) {
		tree[i].add+=(c*(b-a+1));
		tree[i].vis1+=c;
		return;
	} 
	if(a<=tree[i*2].right) {
		if(b>=tree[i*2+1].left) {
			tree[i].add+=(b-a+1)*c;
			make(i*2,a,tree[i*2].right,c);
			make(i*2+1,tree[i*2+1].left,b,c);
		} else {
			tree[i].add+=(b-a+1)*c;
			make(i*2,a,b,c);
		}
	} else {
		make(i*2+1,a,b,c);
		tree[i].add+=(b-a+1)*c;
	}
}
long long ans(long long i,long long a,long long b) {
	tree[i].add%=10007;
	tree[i].vis1%=10007;
	if(a==tree[i].left&&b==tree[i].right) {
		tree[i*2].add+=(tree[i*2].right-tree[i*2].left+1)*tree[i].vis1;
		tree[i*2].vis1+=tree[i].vis1;
		tree[i*2+1].add+=(tree[i*2+1].right-tree[i*2+1].left+1)*tree[i].vis1;
		tree[i*2+1].vis1+=tree[i].vis1;
		tree[i].vis1=0;
		return tree[i].add;
	} else {
		if(a<=tree[i*2].right) {
			if(b>=tree[i*2+1].left) {
				tree[i*2].add+=(tree[i*2].right-tree[i*2].left+1)*tree[i].vis1;
				tree[i*2].vis1+=tree[i].vis1;
				tree[i*2+1].add+=(tree[i*2+1].right-tree[i*2+1].left+1)*tree[i].vis1;
				tree[i*2+1].vis1+=tree[i].vis1;
				tree[i].vis1=0;
				return ans(i*2,a,tree[i*2].right)+ans(i*2+1,tree[i*2+1].left,b);
			} else {        
				tree[i*2].add+=(tree[i*2].right-tree[i*2].left+1)*tree[i].vis1;
				tree[i*2].vis1+=tree[i].vis1;
				tree[i*2+1].add+=(tree[i*2+1].right-tree[i*2+1].left+1)*tree[i].vis1;
				tree[i*2+1].vis1+=tree[i].vis1;
				tree[i].vis1=0;
				return ans(i*2,a,b);
			}
		} else {
			tree[i*2].add+=(tree[i*2].right-tree[i*2].left+1)*tree[i].vis1;
			tree[i*2].vis1+=tree[i].vis1;
			tree[i*2+1].add+=(tree[i*2+1].right-tree[i*2+1].left+1)*tree[i].vis1;
			tree[i*2+1].vis1+=tree[i].vis1;
			tree[i].vis1=0;
			return ans(i*2+1,a,b);
		}
	}
}
int main() {
	long long k;
	cin>>n>>m>>k;
	tree[1].left=1;
	tree[1].right=m;
	build(1);
	while(k--) {
		long long op;
		cin>>op;
		make(1,op,op,1); 
	}
	for(int i=1;i<=m;i++)
		cin>>o[i]>>x[i]>>y[i];
	for(int i=m;i>=1;i--) {
		if(o[i]==1)
			continue;
		make(1,x[i],y[i],ans(1,i,i));
		make(1,i,i,-ans(1,i,i));
	}
	for(int i=1;i<=m;i++) {
		if(o[i]==2)
			continue;
		as[x[i]]+=y[i]*ans(1,i,i);
		as[x[i]]%=10007; 
	}
	for(int i=1;i<=n;i++)	
		cout<<as[i]<<' ';
	return 0;
} 
```

# code of Difference

```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,n,m,as[200001],di[200001],o[200001],x[200001],y[200001];
long long ans[200001];
int main() {
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++) {
		long long s;
		cin>>s;
		di[s]+=1;
		di[s-1]-=1;
	}
	for(int i=1;i<=m;i++) 
		cin>>o[i]>>x[i]>>y[i];
	long long now=0;
	for(int i=m;i>=1;i--) {
		now+=di[i];
		now%10007;
		if(o[i]==1) {
			as[i]=now;
			continue;
		}
		di[y[i]]+=now;
		di[y[i]]%=10007;
		di[x[i]-1]-=now;
		di[x[i]-1]%=10007;
	}
	for(int i=1;i<=m;i++) 
		if(o[i]==1)
			ans[x[i]]+=y[i]*as[i],ans[x[i]]%=10007;
	for(int i=1;i<=n;i++) 
		cout<<(ans[i]%10007+10007)%10007<<' '; 
	return 0;
} 
```

---

## 作者：LiaoYF (赞：1)

场切。感觉难度没有绿。

## 做法

首先发现结果与操作顺序无关，于是可以倒着做。从 $m$ 到 $1$ 遍历所有操作，因为一个操作不会被编号小于它的操作所影响，所以遍历到一个操作的时候它最终被操作的次数都是可以确定的，如果是操作 $2$ 的话相当于给 $l$ 到 $r$ 的每个操作的操作次数加上当前操作的操作次数，操作 $1$ 直接加。

需要支持区间加、单点查询的数据结构维护操作次数，使用树状数组和线段树均可。本篇题解使用树状数组维护差分。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
//RP++
// 1h accepted.
int n,m,k,d[200005],a[200005];
const int mod=10007;
inline int lowbit(int x){
    return x&(-x);
}
void _add(int x,int c){
    for(int i=x;i<=m;i+=lowbit(i)){
        d[i]+=c%mod;
        d[i]=(d[i]%mod+mod)%mod;
    }
}
void add(int l,int r,int x){
    _add(l,x);
    _add(r+1,-x);
}
int query(int x){
    int res=0;
    for(int i=x;i;i-=lowbit(i)){
        res+=d[i]%mod;
        res=(res%mod+mod)%mod;
    }
    return res;
}
struct node{
    int op,l,r;
}b[200005];
signed main(){
    //freopen("c.in","r",stdin);
    //freopen("c.out","w",stdout);
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++){
        int x;
        cin>>x;
        add(x,x,1);
    }
    for(int i=1;i<=m;i++){
        cin>>b[i].op>>b[i].l>>b[i].r;
    }
    for(int i=m;i>=1;i--){
        int cnt=query(i);
        if(cnt){
            if(b[i].op==2){
                add(b[i].l,b[i].r,cnt);
            }else{
                a[b[i].l]+=b[i].r*cnt%mod;
                a[b[i].l]%=mod;
            }
        }
    }
    for(int i=1;i<=n;i++){
        cout<<a[i]%mod<<" ";
    }
    return 0;
}


```

---

## 作者：_O_v_O_ (赞：1)

考虑离线倒序进行所有操作。

那么对于一次操作：

- $o=1$：$a_x\leftarrow a_x+c_i\times y$，可以直接暴力加，但是根据后面的操作需用树状数组。
- $o=2$：对于每个 $\forall x\le i\le y$ 的 $i$，$c_i\leftarrow c_i+1$，拿树状数组维护即可。

时间复杂度 $O(m\log n)$。

------------


补个证明：

首先我们发现 $o=2$ 时 $x_i\le y_i<i-1$ 那么可以得出如果倒序进行操作不会影响后面的操作。

那么当 $o=1$ 时进行的次数肯定为要对这个数进行的所有操作次数之和。

证毕。

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10374)

# 题目分析
看到区间操作，就想到线段树。

既然用线段树，就要明确树结点存的是什么内容。这里由于有操作二的存在，无法直接存数组 $a$ 的值。于是考虑存每个操作执行了多少次。

这里有一个十分显然的思路：输入第 $i$ 次操作时，如果是操作一，就单点修改叶子节点 $i$，让该节点的操作次数加一；如果是操作二，就把从 $x_i$ 到 $y_i$ 区间的操作次数加一，最后扫描线段树所有叶子节点统计每个操作的执行次数。但是这样做有一个问题：如果操作二中又套了若干个操作二，那么还需要继续进行区间修改。这样时间复杂度比较高。于是考虑在上述方法上稍加修改。

一个修改方法是在输入操作的时候只进行单点修改，也就是输入了哪个操作就把该操作对应的叶子节点的执行次数加一。可以发现一点，最后一个操作二及其后面的所有操作的执行次数一定是 $1$，也就是只在输入过程中执行的那一次。所以考虑离线从后往前遍历所有操作，如果遍历到第 $i$ 个操作是操作一，就让 $a_{(x_i)}$ 加上 $y_i \times sum_i$，其中 $sum_i$ 表示第 $i$ 个操作的执行次数。之所以可以直接加是因为倒序遍历时后遍历到的操作不会影响已经遍历完的操作。如果第 $i$ 个操作为操作二，那么如果这个操作被做过，也就是 $sum_i>0$，那么再执行区间修改，也就是把从 $x_i$ 到 $y_i$ 区间的操作次数加上这个操作的操作次数。这种有序的遍历可以有效处理操作之间互相影响带来的不便，因为遍历一个操作时不必考虑已经遍历完成的操作了，也就是说遍历到操作 $i$ 时 $sum_i$ 已经不会再变了。

注意每次运算过后都要取模。

# 代码

```
#include<bits/stdc++.h>
#define N 1000001
#define P 10007
using namespace std;
struct tree{
	int l,r;
	int lazy;
	int sum;
}t[N];
void build(int x,int l,int r){
	t[x].l=l;
	t[x].r=r;
	if(l==r){
		t[x].sum=t[x].lazy=0;
		return;
	}
	int mid=(l+r)>>1;
	build(x*2,l,mid);
	build(x*2+1,mid+1,r);
	t[x].sum=t[x*2].sum+t[x*2+1].sum;
	return;
}
void change(int x,int l,int r,int k){
	if(t[x].l==l&&t[x].r==r){
		t[x].lazy=(t[x].lazy+k)%P;
		t[x].sum=(t[x].sum+(r-l+1)*k)%P;
		return;
	}
	if(t[x].lazy){
		t[x*2].lazy=(t[x*2].lazy+t[x].lazy)%P;
		t[x*2].sum=(t[x*2].sum+(t[x*2].r-t[x*2].l+1)*t[x].lazy)%P;
		t[x*2+1].lazy=(t[x*2+1].lazy+t[x].lazy)%P;
		t[x*2+1].sum=(t[x*2+1].sum+(t[x*2+1].r-t[x*2+1].l+1)*t[x].lazy)%P;
		t[x].lazy=0;
	}
	if(r<=t[x*2].r){
		change(x*2,l,r,k);
	}
	else if(l>=t[x*2+1].l){
		change(x*2+1,l,r,k);
	}
	else{
		change(x*2,l,t[x*2].r,k);
		change(x*2+1,t[x*2+1].l,r,k);
	}
	t[x].sum=(t[x*2].sum+t[x*2+1].sum)%P;
	return;
}
int find(int x,int p){
	if(t[x].l==p&&t[x].r==p){
		return t[x].sum%P;
	}
	if(t[x].lazy){
		t[x*2].lazy=(t[x*2].lazy+t[x].lazy)%P;
		t[x*2].sum=(t[x*2].sum+(t[x*2].r-t[x*2].l+1)*t[x].lazy)%P;
		t[x*2+1].lazy=(t[x*2+1].lazy+t[x].lazy)%P;
		t[x*2+1].sum=(t[x*2+1].sum+(t[x*2+1].r-t[x*2+1].l+1)*t[x].lazy)%P;
		t[x].lazy=0;
	}
	if(p<=t[x*2].r){
		return find(x*2,p);
	}
	else{
		return find(x*2+1,p);
	}
	t[x].sum=(t[x*2].sum+t[x*2+1].sum)%P;
}//以上为线段树
int c[N],a[N]={0};
struct mach{
	int o,x,y;
}ma[N];
int main(){
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++){
		cin>>c[i];
	}
	for(int i=1;i<=m;i++){
		cin>>ma[i].o>>ma[i].x>>ma[i].y;
	}
	build(1,1,m);
	for(int i=1;i<=k;i++){
		int nk=c[i];
		change(1,nk,nk,1);
	}
	for(int i=m;i>=1;i--){
		int fx=find(1,i);
		if(ma[i].o==2){
			if(fx>0){
				change(1,ma[i].x,ma[i].y,fx);
			}
			continue;
		}
		a[ma[i].x]=(a[ma[i].x]+fx*ma[i].y)%P;
	}
	for(int i=1;i<=n;i++){
		cout<<a[i]%P<<' ';
	}
	return 0;
}
```

---


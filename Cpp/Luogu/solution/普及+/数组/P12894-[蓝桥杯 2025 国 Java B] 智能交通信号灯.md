# [蓝桥杯 2025 国 Java B] 智能交通信号灯

## 题目描述

蓝桥智慧城市在一条主干道上沿路安装了 $N$ 个智能交通信号灯，这些信号灯按位置从 $1$ 到 $N$ 编号。每个信号灯都有着一种控制模式，对于第 $i$ 个信号灯，其控制模式用 $A_i$ 表示，$A_i$ 是一个大于等于 $1$ 的整数。

为了评估信号灯配置的 “多样性”，交通管理专家提出了一种度量方式：对于任意两个不同位置 $x$ 和 $y$，它们的多样性分数被定义为大于等于 $1$ 的整数中，第一个既不是 $A_x$ 也不是 $A_y$ 的数值，记作 $\text{mex}(A_x, A_y)$。例如，当 $A_x = 1$ 且 $A_y = 2$ 时，$\text{mex}(1, 2) = 3$；当 $A_x = 1$ 且 $A_y = 3$ 时，$\text{mex}(1, 3) = 2$；当 $A_x = 2$ 且 $A_y = 2$ 时，$\text{mex}(2, 2) = 1$。

政府希望通过分析和调整信号灯配置，提升道路通行效率。为此，他们计划执行 $M$ 条操作指令，每条指令为以下两类之一：

- $1\ l\ r$：查询操作。计算所有满足 $l \leq i < j \leq r$ 的信号灯对 $(A_i, A_j)$，其多样性分数 $\text{mex}(A_i, A_j)$ 的总和。
- $2\ k\ x$：调整操作。将第 $k$ 个信号灯的控制模式 $A_k$ 修改为新的值 $x$。

现在，请你协助政府依次处理这 $M$ 次操作，并输出每个查询操作的结果。

## 说明/提示

**【样例说明】**

初始时信号灯的控制模式依次为：$1, 2, 3, 4, 5$。第一次查询区间 $[1, 5]$，$\text{mex}$ 值分别为 $3, 2, 2, 2, 1, 1, 1, 1, 1, 1$，总和为 $15$。

第二次操作后，信号灯的控制模式依次为：$2, 2, 3, 4, 5$。第二次查询区间 $[1, 5]$，$\text{mex}$ 值均为 $1$，总和为 $10$。

**【评测用例规模与约定】**

对于 $10\%$ 的评测用例，$2 \leq N, M \leq 100$，$1 \leq l < r \leq N$，$1 \leq k \leq N$，$1 \leq A_i, x \leq 10^3$。

对于 $40\%$ 的评测用例，$2 \leq N, M \leq 10^3$，$1 \leq l < r \leq N$，$1 \leq k \leq N$，$1 \leq A_i, x \leq 10^5$。

对于 $100\%$ 的评测用例，$2 \leq N, M \leq 10^5$，$1 \leq l < r \leq N$，$1 \leq k \leq N$，$1 \leq A_i, x \leq 10^9$。


## 样例 #1

### 输入

```
5 3
1 2 3 4 5
1 1 5
2 1 2
1 1 5```

### 输出

```
15
10```

# 题解

## 作者：qwqerty (赞：2)

根据 $\operatorname{mex}$ 的性质，我们可以得出以下结论：
- $\operatorname{mex}(x,y)=3$ 当且仅当 $x=1,y=2$ 或 $x=2,y=1$。
- $\operatorname{mex}(x,y)=2$ 当且仅当 $x=y=1$ 或 $x>2,y=1$ 或 $x=1,y>2$。
- $\operatorname{mex}(x,y)=1$ 当且仅当 $x>1,y>1$。

根据该结论，我们可以用树状数组或线段树维护区间内 $1$ 与 $2$ 的个数，记其为 $c_1$ 和 $c_2$，并令 $L$ 为区间长度。  
根据乘法原理，$\operatorname{mex}$ 为 $3$ 的个数为 $c_1c_2$。$\operatorname{mex}$ 为 $2$ 的个数为 $\dfrac{c_1(c_1-1)}{2}+c_1(L-c_1-c_2)$。$\operatorname{mex}$ 为 $1$ 的个数为 $\dfrac{(L-c_1)(L-c_1-1)}{2}$。  
故答案为 $3c_1c_2+c_1(c_1-1)+2c_1(L-c_1-c_2)+\dfrac{(L-c_1)(L-c_1-1)}{2}$。   
```java
import java.util.*;
public class Main {
		static final int N = 100005;
		static int n, q, a[] = new int[N];
		static class F {
				long[]t = new long[N];
				void u(int x, int y) {
					for (int i = x; i <= n; i += i & -i) t[i] += y;
				}
				long q(int x) {
					long r = 0;
					for (int i = x; i > 0; i -= i & -i) r += t[i];
					return r;
				}
		}
		static F t1 = new F(), t2 = new F();
		public static void main(String[] args) {
			Scanner sc = new Scanner(System.in);
			n = sc.nextInt();
			q = sc.nextInt();
			for (int i = 1; i <= n; i++) {
				a[i] = sc.nextInt();
				if (a[i] == 1) t1.u(i, 1);
				else if (a[i] == 2) t2.u(i, 1);
			}
			while (q-- > 0) {
				int op = sc.nextInt();
				if (op == 1) {
					int l = sc.nextInt(), r = sc.nextInt();
					long c1 = t1.q(r) - t1.q(l - 1), c2 = t2.q(r) - t2.q(l - 1), len = r - l + 1, c3 = len - c1 - c2;
					System.out.println(1 * (len - c1) * (len - c1 - 1) / 2 + 2 * (c1 * (c1 - 1) / 2 + c1 * c3) + 3 * (c1 * c2));
				} else {
					int k = sc.nextInt(), x = sc.nextInt();
					if (a[k] == 1) t1.u(k, -1);
					else if (a[k] == 2) t2.u(k, -1);
					if (x == 1) t1.u(k, 1);
					else if (x == 2) t2.u(k, 1);
					a[k] = x;
				}
			}
		}
}
```

---

## 作者：thy80 (赞：2)

# 思路
对于每个 mex 操作，我们有
$$$$
mex(A_i,A_j)=
\begin{cases}
1 & A_i=2,A_j=2 & \text{或} & A_i=2,A_j>2 & \text{或} & A_i>2,A_j=2 & \text{或} & A_i>2,A_j>2
\\
2 & A_i=1,A_j>2 & \text{或} & A_i>2,A_j=1 & \text{或} & A_i=A_j=1 
\\
3 & A_i=1,A_j=2 & \text{或} & A_i=2,A_j=1
\end{cases}
$$$$

所以我们可以得到 mex 的结果只有 $1,2,3$。

继续读题，注意到题目中的操作为单点修改和区间查询，所有我们可以考虑树状数组。对于操作 $1$，我们可以分成 mex 为 $1$ 的数对的数量，mex 为 $2$ 的数对的数量，mex 为 $3$ 的数对的数量。

我们设有 $x$ 个 $A_i$ 为 $1$，$y$ 个 $A_i$ 为 $2$，$z$ 个 $A_i>2$。

若 $mex(A_i,A_j)=1$，则它的个数为 $b \times (b-1) \div 2+b \times c+z \times (z-1) \div 2$，他贡献的“多样性分数”为 $b \times (b-1) \div 2+b \times c+z \times (z-1) \div 2$。

若 $mex(A_i,A_j)=2$，则它的个数为 $x \times (x-1) \div 2 + x \times z$，他贡献的“多样性分数”为 $x \times (x-1)+2 \times x \times z $。

若 $mex(A_i,A_j)=3$，则它的个数为 $x \times y$，他贡献的“多样性分数”为  $3 \times x \times y$。

所以我们可以维护三个树状数组，第一个维护 $1$ 的个数的前缀和，第二个维护 $2$ 的个数的前缀和，第三个维护 $>2$ 的数的个数的前缀和。 

对于操作 $2$，我们可以用一个数组 $o$ 存第 $k$ 个位置上的数所在树状数组，每次将第 $o_k$ 个树状数组中的第 $k$ 位 $-1$，第 $x$ 个树状数组的第 $k$ 为 $+1$

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+5;
int n,m;
int lowbit(int x){
	return x&(-x);
}
void in(int *tree,int x,int y){//这里用了点指针，可以直接写正常的函数,多写几个。 
	for(int i=x;i<=n;i+=lowbit(i)){
		tree[i]=tree[i]+y;
	}
}
int getsum(int *tree,int x){//同上 
	int sum=0;
	for(int i=x;i>0;i-=lowbit(i)) sum+=tree[i];
	return sum;
}
int C[5][N],o[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&o[i]);
		if(o[i]>2) o[i]=3;
		in(C[o[i]],i,1);
	}
	while(m--){
		int op,x,y;
		scanf("%d%d%d",&op,&x,&y);
		if(op==1){
			ll ans=0;
			int a=getsum(C[1],y)-getsum(C[1],x-1);
			int b=getsum(C[2],y)-getsum(C[2],x-1);
			int c=getsum(C[3],y)-getsum(C[3],x-1);
			ans+=1ll*b*(b-1)/2+1ll*b*c+1ll*c*(c-1)/2;
			ans+=1ll*a*(a-1)+2ll*a*c;
			ans+=3ll*a*b;
			printf("%lld\n",ans);
		}
		else{
			if(y>2) y=3;
			in(C[o[x]],x,-1);
			in(C[y],x,1);
			o[x]=y;
		}
	}
	return 0;
}
```

---

## 作者：hex4C45 (赞：2)

## 题目分析

众所周知，$\operatorname{mex} \{a,b \}$ 可以分类讨论。

当 $a=b=1$，$\operatorname{mex} \{a,b \}=2$；

当 $a,b$ 中仅有一个为 $1$ 且另一个大于 $2$，$\operatorname{mex} \{a,b \}=2$；

当 $a,b$ 中仅有一个为 $1$ 且另一个为 $2$，$\operatorname{mex} \{a,b \}=3$；

否则，$\operatorname{mex} \{a,b \}=1$。

于是我们发现询问只要统计区间内 $1$、$2$、大于 $2$ 的数的数量，分 $C_3^2=6$ 种情况算贡献求个和就可以算出答案了。

容易发现建三个树状数组就好了。修改和查询都是 $\mathcal O(\log N)$，总共是 $\mathcal O(M\log N)$。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll c[3][114514],a[114514];int n;
int lowbit(int x) {return x&(-x);}
void add(ll* f,int x,int y)
{
    for(;x<=n;x+=lowbit(x)) f[x]+=y;
}
ll sum(ll* f,int x)
{
    ll res=0;for(;x;x-=lowbit(x)) res+=f[x];
    return res;
}
int main(){
    int m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(a[i]==1) add(c[0],i,1);
        else if(a[i]==2) add(c[1],i,1);
        else add(c[2],i,1);
    }
    for(int i=1;i<=m;i++)
    {
        int o,x,y;
        cin>>o>>x>>y;
        if(o==1)
        {
            ll s,t,p;
            s=sum(c[0],y)-sum(c[0],x-1);
            t=sum(c[1],y)-sum(c[1],x-1);
            p=sum(c[2],y)-sum(c[2],x-1);
            ll ans=0;
            ans+=t*p+t*(t-1)/2+p*(p-1)/2;
            ans+=s*p*2+s*(s-1);
            ans+=t*s*3;
            cout<<ans<<endl;
        }else{
            if(a[x]==1) add(c[0],x,-1);
            else if(a[x]==2) add(c[1],x,-1);
            else add(c[2],x,-1);
            a[x]=y;
            if(a[x]==1) add(c[0],x,1);
            else if(a[x]==2) add(c[1],x,1);
            else add(c[2],x,1);
        }
    }
}
```

---

## 作者：Little_Deer_Peach (赞：2)

题意已经够简洁了不再赘述。

分类讨论和树状数组简单题。首先我们发现 $\text{mex}$ 运算是对于两个数来说的，所以该运算只有三种结果，从而还能发现大于 $3$ 的数字与 $3$ 对于答案来说起到的作用是一样的。所以我们可以把所有大于 $3$ 的数字看做 $3$ 来做这道题。

接着讨论 $\text{mex}$ 计算的结果所对应的情况：
1. 答案为 $1$ 时，有三种情况：$2$ 和 $2$，$2$ 和 $3$ 或者 $3$ 和 $3$；
2. 答案为 $2$ 时，有两种情况：$1$ 和 $1$ 或者 $1$ 和 $3$；
3. 答案为 $3$ 时，有一种情况：$1$ 和 $2$。

最终答案怎么计算？计算出每种情况的方案数再乘以该方案对应的 $\text{mex}$ 的答案，最后累加就是查询的答案。

对于数字相同的数字，不就是求最多握手（比赛）次数的问题吗。设该数字数量为 $n$，$\frac{n \times (n-1)}{2}$ 就是方案总数。

对于两个不同的数字，就是衣服搭配的方案数问题，两种数字的数量相乘就是总方案数。

那么我们就需要维护一个区间内数字 $1$，$2$ 和 $3$ 的个数。有单点修改和区间查询，我们会想到树状数组。

所以，我们就能过了这道题。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define endl '\n'
const int N=1e5+5;
int n,m;
int a[N];
int num[N][4];
inline int lowbit(int x){return x&(-x);}
inline void add(int x,int y){//增加一个数y
	while(x<=n){
		num[x][y]++;
		x+=lowbit(x);
	}
	return;
}
inline void del(int x,int y){//删去一个数y
	while(x<=n){
		num[x][y]--;
		x+=lowbit(x);
	}
	return;
}
  inline int query(int x,int y){//查询区间[1,x]数y的数量
	int res=0;
	while(x){
		res+=num[x][y];
		x-=lowbit(x);
	}
	return res;
}
signed main(){
	IOS;
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i],a[i]=(a[i]>3?3:a[i]);
	for(int i=1;i<=n;i++)add(i,a[i]);
	while(m--){
		int opt;
		cin>>opt;
		if(opt==1){
			int l,r;
			cin>>l>>r;
			int num1=query(r,1)-query(l-1,1);
			int num2=query(r,2)-query(l-1,2);
			int num3=query(r,3)-query(l-1,3);//变量名能告诉你变量的含义（确信）
			int ans=num1*(num1-1)+num1*num2*3+num1*num3*2+num2*(num2-1)/2+num2*num3+num3*(num3-1)/2;
			cout<<ans<<endl;
		}
		else{
			int k,x;
			cin>>k>>x;
			x=(x>=3?3:x);
			del(k,a[k]);//删去原来的数
			a[k]=x;//修改
			add(k,x);//增加修改的数
		}
	}
	return 0;
}
/*
分类讨论的过程（以a为第一关键字，b为第二关键字排序，这样就不会漏情况了）：
a=1,b=1 mex=2
a=1,b=2 mex=3
a=1,b=3 mex=2
a=2,b=2 mex=1
a=2,b=3 mex=1
a=3,b=3,mex=1
*/
```
[记录](https://www.luogu.com.cn/record/221970967)。

---

## 作者：Chaser_of_light (赞：2)

### 题意：
给定一个序列 $a_{1,2,..,N}$，然后有 $M$ 次询问，修改操作。  
修改操作：给定 $x,val$ 两个数，然后 $a_x\gets{val}$。  
询问操作：给定区间 $[l,r]$ 求  $\sum_{1\le i < j \le n}\operatorname{mex}(a_i,a_j)$。  
- $\operatorname{mex}(x,y)$ 代表不为 $x$，$y$ 的最小正整数。  

### 思路 ：
注意到 $\operatorname{mex}(x,y)$ 等价于 $\operatorname{mex}(\min(3,x),\min(3,y))$。  
就将数组转换成数组元素只有 1、2、3 的数组。  
（解释：$\operatorname{mex}(x,y)$ 只能为 1、2、3，所以大于等于三的数是效果相同的。）  
分三种情况讨论，此处 $\operatorname{mex}(x,y)$ 和 $\operatorname{mex}(y,x)$ 等价。  
1. $\operatorname{mex}(x,y)=1$，则有 $\operatorname{mex}(2,2)$ 或 $\operatorname{mex}(2,3)$ 或 $\operatorname{mex}(3,3)$（两个不为一的数的方案）。  
2. $\operatorname{mex}(x,y)=2$，则有 $\operatorname{mex}(1,1)$ 或 $\operatorname{mex}(1,3)$（两个不为二的数的方案数减去两个都为三的方案数）。  
3. $\operatorname{mex}(x,y)=3$，则有 $\operatorname{mex}(1,2)$（两个不为三的数减去两个都为一或二的方案数）。  


注意到是单点修改，区间求和，就维护三个树状数组，求出贡献。    
~~树状数组不教了，不会去看模板。~~  
详细讲一下贡献求法。  
$cnt_i$ 表区间内$i$的个数，$txt_i$ 表区间内 $\operatorname{mex}(a_x,a_y)=i(1\le x < y \le n)$的对数。  

然后有：    

$$
\begin{aligned}
txt_1 &= \dbinom{{cnt}_2 + {cnt}_3}{2} \\
&= \dfrac{({cnt}_2 + {cnt}_3) \times ({cnt}_2 + {cnt}_3 - 1)}{2}
\end{aligned}
$$
$$
\begin{aligned}
txt_2 &= \dbinom{{cnt}_1 + {cnt}_3}{2} - \dbinom{{cnt}_3}{2} \\
&= \dfrac{({cnt}_1 + {cnt}_3) \times ({cnt}_1 + {cnt}_3 - 1)}{2} - \dfrac{{cnt}_3 \times ({cnt}_3 - 1)}{2}
\end{aligned}
$$
$$
\begin{aligned}
txt_3 &= \dbinom{{cnt}_1 + {cnt}_2}{2} - \dbinom{{cnt}_1}{2} - \dbinom{{cnt}_2}{2} \\
&= \dfrac{({cnt}_1 + {cnt}_2) \times ({cnt}_1 + {cnt}_2 - 1)}{2} - \dfrac{{cnt}_1 \times ({cnt}_1 - 1)}{2} - \dfrac{{cnt}_2 \times ({cnt}_2 - 1)}{2}
\end{aligned}
$$

可自己尝试推一推。  
组合数不会看[这里](https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E6%95%B0%E5%85%AC%E5%BC%8F/94872)。  
然后剩下就都一样了，自己尝试推一推。  
总和：  
$$
\sum^{3}_{i=1} txt_i
$$
还有，开 long long，不然迟早见祖宗!  


### AC 代码
```cpp
#include<bits/stdc++.h>
#define debug puts("-1")
#define inf 0x3f3f3f3f3f3f3f3f
#define kg putchar(' ')
#define hh putchar('\n')
#define int long long
#define db double
#define ri register int
#define fir first
#define sec second
#define pb push_back
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define pii pair<int,int>
#define ulp(i,a,b) for(ri i=a;i<=b;++i)
#define dlp(i,a,b) for(ri i=a;i>=b;--i)
#define mod 1000000007
using namespace std;
int read(){
    int num=0;bool f=false;char c=getchar();
    while(!isdigit(c)){if(c=='-')f=true;c=getchar();}
    while(isdigit(c))num=(num<<3)+(num<<1)+(c^48),c=getchar();
    return f?-num:num;
}
void write(int x){
    if(x<0)putchar('-'),write(-x);
    else if(x<10)putchar('0'+x);
    else write(x/10),putchar('0'+x%10);
}
#define N 100005
#define lowbit(x) (x&(-x))
int n,m,op,x,y;
int a[N];
int tr[4][N];
void update(int idx, int i, int val) {
    for(;i<=n;i+=lowbit(i)) {
        tr[idx][i]+=val;
    }
}
int query(int idx, int l, int r) {
    int ans=0;
    for(int i=r;i>0;i-=lowbit(i)) {
        ans+=tr[idx][i];
    }
    for(int i=l-1;i>0;i-=lowbit(i)) {
        ans-=tr[idx][i];
    }
    return ans;
}

signed main() {
    n=read(),m=read();
    ulp(i,1,n) {
        a[i]=read();
        a[i]=a[i]>3?3:a[i]; 
        update(a[i],i,1); 
    }
    while(m--) {
        op=read(),x=read(),y=read();
        if(op&1) { 
            int l=x,r=y;
            int c1=query(1, l, r); 
            int c2=query(2, l, r);
            int c3=query(3, l, r); 
            int cnt1=(c2+c3)*(c2+c3-1)/2;
            int cnt2=(c1+c3)*(c1+c3-1)/2-c3*(c3-1)/2;
            int cnt3=(c1+c2)*(c1+c2-1)/2-c1*(c1-1)/2-c2*(c2-1)/2;
            int ans=cnt1+2*cnt2+3*cnt3;
            write(ans),hh;
        } 
        else {
        	y=y>3?3:y;
        	if(a[x]==y)continue;
            update(a[x],x,-1);
            update(y,x,1);
            a[x]=y;
        }
    }
    return 0;
}
`````````
码风不好，不喜勿喷。  
有问题可以评论，有空会回。

---

## 作者：Amoribus (赞：2)

对于一个区间，设区间中 $1$ 的数量为 $q_1$，$2$ 的数量为 $q_2$，长度为 $len$。

则每个 $1$ 产生的贡献为：$q_2\times 3+(len-q_2-1)\times 2$

则每个 $2$ 产生的贡献为：$q_1\times 3+(len-q_1-1)$

每个 $\geq 3$ 的数产生的贡献为：$q_1\times 2+(len-q_1-1)$

由于一对数会重复算两次，所以累加的结果还要除以 $2$。

线段树维护即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+7;
int seg1[N<<2],seg2[N<<2],a[N],n,m;
void update1(int p,int l,int r,int x,int v){
	if(l==r&&l==x){
		seg1[p]=v;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid) update1(p<<1,l,mid,x,v);
	if(x>mid) update1(p<<1|1,mid+1,r,x,v);
	seg1[p]=seg1[p<<1]+seg1[p<<1|1];
}
void update2(int p,int l,int r,int x,int v){
	if(l==r&&l==x){
		seg2[p]=v;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid) update2(p<<1,l,mid,x,v);
	if(x>mid) update2(p<<1|1,mid+1,r,x,v);
	seg2[p]=seg2[p<<1]+seg2[p<<1|1];
}
int query1(int p,int l,int r,int x,int y){
	//cout<<"p="<<p<<endl;
	if(x<=l&&r<=y){
		return seg1[p];
	} 
	int mid=l+r>>1,sum=0;
	if(x<=mid) sum+=query1(p<<1,l,mid,x,y);
	if(y>mid) sum+=query1(p<<1|1,mid+1,r,x,y);
	return sum;
}
int query2(int p,int l,int r,int x,int y){
	
	if(x<=l&&r<=y){
		return seg2[p];
	} 
	int mid=l+r>>1,sum=0;
	if(x<=mid) sum+=query2(p<<1,l,mid,x,y);
	if(y>mid) sum+=query2(p<<1|1,mid+1,r,x,y);
	return sum;
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==1) update1(1,1,n,i,1);
		if(a[i]==2) update2(1,1,n,i,1);
	}
	while(m--){
		int op;
		cin>>op;
		if(op==1){
			int l,r,ans;
			cin>>l>>r;
			int q1=query1(1,1,n,l,r);
			int q2=query2(1,1,n,l,r);
			//cout<<q1<<" "<<q2<<endl;
			int len=r-l+1;
			ans=(q1*(q2*3+(len-q2-1)*2)+q2*(q1*3+(len-q1-1))+(len-q1-q2)*(q1*2+(len-q1-1)))/2;
			cout<<ans<<endl;
		}
		if(op==2)
		{
			int k,x;
			cin>>k>>x;
			if(x==1) update1(1,1,n,k,1),update2(1,1,n,k,0);
			else if(x==2) update2(1,1,n,k,1),update1(1,1,n,k,0);
			else{
				update1(1,1,n,k,0);
				update2(1,1,n,k,0);
			}
		}
	}
	return 0;
}
```

---

## 作者：seika27 (赞：2)

### 思路
让我们思考一下这道题的突破口。

不难发现只有两个数的 $\text{mex}$ 运算，答案只有三种。

当答案为 $1$ 时，要求两数都大于 $1$。

当答案为 $2$ 时，要求两数一个是 $1$ 另一个不是 $2$。

当答案为 $3$ 时，要求两数一个是 $1$ 一个是 $2$。

然后对于一个区间，我们思考怎么快速计算。

我们记当前区间内 $1$ 的个数为 $s1$，记 $2$ 的个数为 $s2$。

那么接下来需要动用我们小学水平的组合数技巧。

分别求出不同答案的出现次数，然后就做完了。

在这里给出出现次数，令 $l$ 为区间长。

答案为 $1$ 是 $\frac{(l-s1)\times(l-s1-1)}{2}$。

答案为 $2$ 是 $\frac{s1\times(s1-1)}{2}+s1\times(l-s1-s2)$。

答案为 $3$ 是 $s1\times s2$。

维护 $s1$ 和 $s2$ 可以用树状数组。

### code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n,m;
struct trary
{
#define lw (x&-x)
	int c[N];
	inline void update(int x,int y)
	{
		for(;x<=n;x+=lw)c[x]+=y;
		return;
	}
	inline int query(int x)
	{
		int ans=0;
		for(;x>=1;x-=lw)ans+=c[x];
		return ans;
	}
}subaru,momoka;
int a[N];
signed main()
{
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		subaru.update(i,a[i]==1);
		momoka.update(i,a[i]==2);
	}
	for(int i=1;i<=m;++i)
	{
		int op,x,y;
		cin>>op>>x>>y;
		if(op==1)
		{
			int s1=subaru.query(y)-subaru.query(x-1);
			int s2=momoka.query(y)-momoka.query(x-1);
			cout<<3*s1*s2+s1*(s1-1)+2*s1*(y-x+1-s1-s2)+(y-x+1-s1)*(y-x-s1)/2<<'\n';
		}
		if(op==2)
		{
			if(a[x]==1)subaru.update(x,-1);
			if(a[x]==2)momoka.update(x,-1);
			a[x]=y;
			if(a[x]==1)subaru.update(x,1);
			if(a[x]==2)momoka.update(x,1);
		}
	}
	return 0;
}
```

---

## 作者：CommandSR (赞：1)

## 题意

[link](https://www.luogu.com.cn/problem/P12894)

## 题解

首先显然把所有大于 $3$ 的数变成 $3$ 答案不会改变。

然后发现数对只有以下几种：

```
1 1
2 2
3 3
1 2
1 3
2 3
```

发现要区间查询 $1$，$2$，$3$ 的个数，直接建三个树状数组维护。单点修改也可以树状数组修改。

查完了之后设 $1$，$2$，$3$ 的个数分别为 $cnt1$，$cnt2$，$cnt3$，那么只需分类讨论一下统计答案：

```cpp
ll ans = 0;
ans += 1ll * cnt1 * (cnt1 - 1) / 2 * 2; // 1 1 ans = 2
ans += 1ll * cnt2 * (cnt2 - 1) / 2; // 2 2 ans = 1
ans += 1ll * cnt3 * (cnt3 - 1) / 2; // 2 2 ans = 1
ans += 1ll * cnt1 * cnt2 * 3; // 1 2 ans = 3
ans += 1ll * cnt2 * cnt3 * 1; // 2 3 ans = 1
ans += 1ll * cnt1 * cnt3 * 2; // 1 3 ans = 2
```

## Code

```cpp
// Problem: P12894
#include <bits/stdc++.h>
#define db double
#define ll long long
#define pc putchar
#define gc getchar
#define sz(x) ((int)x.size())
#define F(i, a, b) for (int i = (a); i <= (b); ++i)
#define D(i, a, b) for (int i = (a); i >= (b); --i)
#define TimeMemory cout<<fabs(&Med-&Mbe)/1048576.0<<"MB "<<1.0*clock()/CLOCKS_PER_SEC*1000<<"ms\n"
bool Mbe;
using namespace std;
namespace IO {
#define typ ll
	inline typ rd() {
		typ x = 0; bool f = 1; char ch = gc();
		while (ch < '0' || ch > '9') { if (ch == '-') f = 0; ch = gc(); }
		while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gc();
		return (f ? x : (-x));
	}
	inline void wr(typ x) {
		if (x < 0) pc('-'), x = -x;
		if (x > 9) wr(x / 10); pc(x % 10 + '0');
	}
}
using namespace IO;
// ----------------- Main Code -----------------
const int N = 1e5 + 5;
int n, m, a[N];
struct BIT {
	int c[N];
	void upd(int p, int x) { for (int i = p; i <= n; i += (i & -i)) c[i] += x; }
	int qry(int p) { int res = 0; for (int i = p; i; i -= (i & -i)) res += c[i]; return res; }
} T[4];
int main() {
	n = rd(), m = rd();
	F(i, 1, n) {
		a[i] = rd();
		if (a[i] > 3) a[i] = 3;
		T[a[i]].upd(i, 1);
	}
	F(i, 1, m) {
		int op = rd(), l = rd(), r = rd();
		if (op == 1) {
			int	cnt1 = T[1].qry(r) - T[1].qry(l-1);
			int cnt2 = T[2].qry(r) - T[2].qry(l-1);
			int cnt3 = T[3].qry(r) - T[3].qry(l-1);
			ll ans = 0;
			ans += 1ll * cnt1 * (cnt1 - 1) / 2 * 2; // 1 1
			ans += 1ll * cnt2 * (cnt2 - 1) / 2; // 2 2
			ans += 1ll * cnt3 * (cnt3 - 1) / 2; // 2 2
			ans += 1ll * cnt1 * cnt2 * 3; // 1 2
			ans += 1ll * cnt2 * cnt3 * 1; // 2 3
			ans += 1ll * cnt1 * cnt3 * 2; // 1 3
			wr(ans), pc('\n');
		} else {
			T[a[l]].upd(l, -1);
			a[l] = r;
			if (a[l] > 3) a[l] = 3;
			T[a[l]].upd(l, 1);
		}
	}
	return 0;
}
```

---

## 作者：CSP_S_2023_T2 (赞：1)

### 思路

令一个区间内 $1$ 的个数为 $a$，$2$ 的个数为 $b$，其余个数为 $c$。

由题意得 $\mathrm {mex}(1,1)=2$，$\mathrm {mex}(1,2)=3$，$\mathrm {mex}(1,k)=2$（$k \ge 3$），$\mathrm {mex}(k,l)=1$（$k,l \ge 2$）。

则该区间的多样性分数为 $3 \times a \times b + 2 \times a \times c + a \times (a-1) + \frac{(b+c) \times (b+c-1)}{2}$。

树状数组维护 $1$ 的个数和 $2$ 的个数即可。

记得开 long long。

### 代码（Java）


```java
import java.util.Scanner;

public class Main{
    static final int N=100010;
    static int n,m,opt;
    static int[] a=new int[N],c1=new int[N],c2=new int[N];
    
    static void add1(int x,int v){
    	for(int i=x;i<N;i+=(i&-i)) c1[i]+=v;
    }
    
    static void add2(int x,int v){
    	for(int i=x;i<N;i+=(i&-i)) c2[i]+=v;
    }
    
    static int query1(int x){
    	int cnt=0;
    	for(int i=x;i>0;i-=(i&-i)) cnt+=c1[i];
    	return cnt;
    }
    
    static int query2(int x){
    	int cnt=0;
    	for(int i=x;i>0;i-=(i&-i)) cnt+=c2[i];
    	return cnt;
    }
    
    public static void main(String[] args){
        Scanner scanner=new Scanner(System.in);
        n=scanner.nextInt();
        m=scanner.nextInt();
        for(int i=1;i<=n;i++){
            a[i]=scanner.nextInt();
            if(a[i]==1) add1(i,1);
            if(a[i]==2) add2(i,1);
        }
        for(int i=0;i<m;i++){
    		opt=scanner.nextInt();
    		if(opt==1){
    			int l,r;
    			l=scanner.nextInt();
    			r=scanner.nextInt();
                //求 1,2,非 1 非 2 的数量
    			long num1=query1(r)-query1(l-1);
    			long num2=query2(r)-query2(l-1);
    			long num3=r-l+1-num1-num2;
                //计算答案
    			System.out.println(3*num1*num2+2*(num1*num3+num1*(num1-1)/2)+(num2+num3)*(num2+num3-1)/2);
    		}
    		else{
    			int k,x;
    			k=scanner.nextInt();
    			x=scanner.nextInt();
                //更新树状数组
    			if(a[k]==1) add1(k,-1);
    			if(a[k]==2) add2(k,-1);
    			a[k]=x;
    			if(x==1) add1(k,1);
    			if(x==2) add2(k,1); 
    		}
    	}
    }
}
```


### 代码（C++）


```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=1e5+10;
int n,m,opt,a[N],c1[N],c2[N];  //c1 维护 1,c2 维护 2 

void add1(int x,int v){
	for(int i=x;i<N;i+=(i&-i)) c1[i]+=v;
}

void add2(int x,int v){
	for(int i=x;i<N;i+=(i&-i)) c2[i]+=v;
}

int query1(int x){
	int cnt=0;
	for(int i=x;i;i-=(i&-i)) cnt+=c1[i];
	return cnt;
}

int query2(int x){
	int cnt=0;
	for(int i=x;i;i-=(i&-i)) cnt+=c2[i];
	return cnt;
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
    	if(a[i]==1) add1(i,1);
    	if(a[i]==2) add2(i,1);
	}
	while(m--){
		cin>>opt;
		if(opt==1){
			int l,r;
			cin>>l>>r;
            //求 1,2,非 1 非 2 的数量
			int num1=query1(r)-query1(l-1);
			int num2=query2(r)-query2(l-1);
			int num3=r-l+1-num1-num2;
            //计算答案
			cout<<3ll*num1*num2+2ll*(num1*num3+num1*(num1-1)/2)+1ll*(num2+num3)*(num2+num3-1)/2<<'\n';
		}
		else{
			int k,x;
			cin>>k>>x;
            //更新树状数组
			if(a[k]==1) add1(k,-1);
			if(a[k]==2) add2(k,-1);
			a[k]=x;
			if(x==1) add1(k,1);
			if(x==2) add2(k,1); 
		}
	}
    return 0;  //完结撒花
}
```

---

## 作者：redfull66 (赞：0)

当 $x \le y$ 时，可以将 $\operatorname{mex}(x,y)$ 分为三类。

1. $x \ne 1$ 且 $y \ne 1$，则 $\operatorname{mex}(x,y) = \operatorname{mex}(y,x) = 1$。
2. $x=1$ 且 $y \ne 2$，则 $\operatorname{mex}(x,y) = \operatorname{mex}(y,x) = 2$。
3. $x=1$ 且 $y=2$，则 $\operatorname{mex}(x,y) = \operatorname{mex}(y,x) = 3$。

注意到 $\operatorname{mex}(x,y)$ 的值只跟 $1$ 和 $2$ 的数量有关，所以可以用树状数组统计 $1$ 和 $2$ 的数量，进而求出答案。

原 C++ 代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,q,op,x,y,k,kk,kkk,a[100005],t[100005][2];
long long lb(long long x){return x&(-x);}
void up(long long x,long long y,long long op){while(x<=n)t[x][op]+=y,x+=lb(x);}
long long sum(long long x,long long op,long long ans=0){while(x)ans+=t[x][op],x-=lb(x);return ans;}
int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++)cin>>a[i],up(i,(a[i]==1),0),up(i,(a[i]==2),1);
    while(q--){
    	cin>>op>>x>>y;
    	if(op==2)up(x,-(a[x]==1)+(y==1),0),up(x,-(a[x]==2)+(y==2),1),a[x]=y;
    	else k=sum(y,0)-sum(x-1,0),kk=sum(y,1)-sum(x-1,1),kkk=y-x+1,cout<<k*(k-1)/2+kkk*(kkk-1)/2+k*(kkk+kk-k)<<endl;
	}
    return 0;
}

```

转化后的 Java 代码。

```java
import java.util.Scanner;

public class Main {
    static long n, q, op, x, y, k, kk, kkk;
    static long[] a = new long[100005];
    static long[][] t = new long[100005][2];

    static long lb(long x) {
        return x & (-x);
    }

    static void up(long x, long y, long op) {
        while (x <= n) {
            t[(int) x][(int) op] += y;
            x += lb(x);
        }
    }

    static long sum(long x, long op, long ans) {
        while (x > 0) {
            ans += t[(int) x][(int) op];
            x -= lb(x);
        }
        return ans;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextLong();
        q = scanner.nextLong();
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextLong();
            up(i, (a[i] == 1) ? 1 : 0, 0);
            up(i, (a[i] == 2) ? 1 : 0, 1);
        }
        while (q-- > 0) {
            op = scanner.nextLong();
            x = scanner.nextLong();
            y = scanner.nextLong();
            if (op == 2) {
                up(x, -((a[(int) x] == 1) ? 1 : 0) + ((y == 1) ? 1 : 0), 0);
                up(x, -((a[(int) x] == 2) ? 1 : 0) + ((y == 2) ? 1 : 0), 1);
                a[(int) x] = y;
            } else {
                k = sum(y, 0, 0) - sum(x - 1, 0, 0);
                kk = sum(y, 1, 0) - sum(x - 1, 1, 0);
                kkk = y - x + 1;
                System.out.println(k * (k - 1) / 2 + kkk * (kkk - 1) / 2 + k * (kkk + kk - k));
            }
        }
        scanner.close();
    }
}

```

---

## 作者：HPXXZYY (赞：0)

$\color{blue}{\texttt{[Problem]}}$

给定一个长度为 $n$ 的数组 $a_{1\dots n}$，进行 $m$ 次一下操作：

1. 给定 $l,r$，求出 $\sum\limits_{l \leq i < j\leq r}\text{mex}\{a_{i},a_{j}\}$。其中 $\text{mex}\{ x_{1},x_{2},\dots,x_{n} \}$ 表示大于等于 $1$ 的最小的未在 $x_{1 \dots n}$ 中出现的整数。
2. 给定 $k,x$，修改 $a_{k}=x$。

$1 \leq n,m \leq 1\times 10^{5}, 1 \leq l < r \leq n, 1 \leq k \leq n, 1\leq a_{i},x \leq 1 \times 10^{9}$。

$\color{blue}{\texttt{[Analysis]}}$

其实 $\text{mex}\{x,y\}(x<y)$ 的取值无非就是 $1,2,3$。

- 当 $x=1,y=2$ 时，$\text{mex}=3$。
- 当 $x=1,y \not = 2$ 时，$\text{mex}=2$。
- 否则 $\text{mex}=1$。

这题到这里也就做完了。

开一个树状数组分别统计区间内 $1,2$ 出现的次数就可以了。

记得开 long long。

$\color{blue}{\text{Code}}$

```cpp
const int N=1e5+100;

class Fenwick_Tree{
	public:
		void set_size(int n){
			this->n=n;
			for(int i=1;i<=n;i++)
				c[i]=0;
		}
		void modify(int x,int val){
			for(int i=x;i<=n;i+=lowbit(i))
				c[i]+=val;
		}
		int query(int x){
			int ans=0;
			for(int i=x;i;i-=lowbit(i))
				ans+=c[i];
			
			return ans;
		}
	private:
		int c[N],n;
		int lowbit(int x){
			return x&(-x);
		}
}cnt[2];

int query(int num,int l,int r){
	if (num<1||num>2) return -1;
	
	--num;
	return cnt[num].query(r)-cnt[num].query(l-1);
}

typedef long long ll;
#define sum(n) (1ll*(n)*((n)-1)/2)
ll query(int l,int r){
	int n=r-l+1;
	int x=query(1,l,r),y=query(2,l,r),z=n-x-y;
	
	return 3ll*x*y+2ll*sum(x)+2ll*x*z+1ll*(sum(n)-1ll*x*y-sum(x)-1ll*x*z);
}

int n,m,a[N];

int main(){
	n=read();m=read();
	
	cnt[0].set_size(n);
	cnt[1].set_size(n);
	
	for(int i=1;i<=n;i++){
		a[i]=read();
		if (a[i]<=2)
			cnt[a[i]-1].modify(i,1);
	}
	
	for(int i=1;i<=m;i++){
		int opt=read(),l=read(),r=read();
		
		if (opt==1) printf("%lld\n",query(l,r));
		else{
			if (a[l]<=2)
				cnt[a[l]-1].modify(l,-1);
			
			a[l]=r;
			if (a[l]<=2)
				cnt[a[l]-1].modify(l,1);
		}
	}
	
	return 0;
}
```

--------------------------

顺便一说，这题的数据好水啊。犯了一个及其低级的错误，但是还能拿 $75$ 分。

不过可以理解，毕竟修改操作 $a_{i},x$ 都大于等于 $3$ 时等于没改，如果数据纯随机的话，大部分修改都是没用的。

```cpp
	for(int i=1;i<=m;i++){
		int opt=read(),l=read(),r=read();
		
		if (opt==1) printf("%lld\n",query(l,r));
		else{
			if (a[l]<=2)
				cnt[a[l]-1].modify(i,-1);
			
			a[l]=r;
			if (a[l]<=2)
				cnt[a[l]-1].modify(i,1);
		}
	}
```

考验一下大家，能不能找出错误在哪。

答案：modify 那里把 `l` 写成 `i` 了。

---

## 作者：hjhAKIOI (赞：0)

## P12894 [蓝桥杯 2025 国 Java B] 智能交通信号灯 题解

注意到题目中的 $\text{mex}$ 运算具有性质：$\text{mex}(a,b)\le 3$。

证明也很容易，如果 $\text{mex}(a,b)>3$，那么说明 $1,2,3$ 都出现了，与只有两个数矛盾。

所以这启发我们分别计算 $1,2,3$ 的贡献。以下记 $cnt1$ 为区间中 $1$ 出现的个数，$cnt2$ 为区间中 $2$ 出现的个数，$len$ 为区间长度。

1. $\text{mex}(A_i,A_j)=1$ 的情况。

   只要两个数都不等于 $1$ 即可。所以共有 $\binom{len-cnt1}{2}$ 种方案。
   
2. $\text{mex}(A_i,A_j)=2$ 的情况。

   这表明 $A_i,A_j$ 中至少有一个数是 $1$，且都不等于 $2$。分开考虑，如果两个数都是 $1$，共有 $\binom{cnt1}{2}$ 种方案；否则，先选一个 $1$，再选一个不是 $1$ 也不是 $2$ 的数，共有 $cnt1\times(len-cnt1-cnt2)$ 种方案。
   
3. $\text{mex}(A_i,A_j)=3$ 的情况。

   这表明一个数是 $1$，一个数是 $2$。那么共有 $cnt1\times cnt2$ 种方案。

于是把对应的方案数乘上对应的贡献再加起来就是答案。

发现只需要维护区间的 $1,2$ 出现次数。于是用两个树状数组，第一个在是 $1$ 的位置为 $1$，否则为 $0$；第二个在是 $2$ 的位置为 $1$，否则为 $0$。那么每次询问出现次数相当于区间求和。单点修改时，对应修改即可。

于是容易写出代码。
```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
const int N=1e5+5; 
int n,m;
int a[N];

struct BIT{
	int c[N];
	BIT(){ memset(c,0,sizeof(c));}
	void add(int x,int v){
		for(;x<=n;x+=x&-x) c[x]+=v;
	}
	int ask(int x){
		int res=0;
		for(;x;x-=x&-x) res+=c[x];
		return res; 
	}
}c1,c2;

int C(int x){
	return x*(x-1)/2;
}

signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==1) c1.add(i,1);
		if(a[i]==2) c2.add(i,1);
	}
	while(m--){
		int op,x,y;
		cin>>op>>x>>y;
		if(op==1){
			int cnt1=c1.ask(y)-c1.ask(x-1),cnt2=c2.ask(y)-c2.ask(x-1);
			cout<<C(y-x+1-cnt1)+C(cnt1)*2+cnt1*(y-x+1-cnt1-cnt2)*2+cnt1*cnt2*3<<endl;
		}
		if(op==2){
			if(a[x]==1) c1.add(x,-1);
			if(a[x]==2) c2.add(x,-1);
			a[x]=y;
			if(a[x]==1) c1.add(x,1);
			if(a[x]==2) c2.add(x,1);
		}
	}
	return 0;
}
```

---


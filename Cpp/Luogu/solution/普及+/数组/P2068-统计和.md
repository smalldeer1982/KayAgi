# 统计和

## 题目描述

给定一个长度为 $n(0\leq n\leq 10^5)$，初始值都为 $0$ 的序列，$x(0\leq x\leq 10^5)$ 次的修改某些位置上的数字，每次加上一个数，并在此期间提出 $y(0\leq y\leq 10^5)$ 个问题，求每段区间的和。

## 样例 #1

### 输入

```
5
4
x 3 8
y 1 3
x 4 9
y 3 4```

### 输出

```
8
17
```

# 题解

## 作者：Nero_Claudius (赞：16)

这是一道单点修改，区间查询的线段树。

需要实现的操作有三个：建树，更新与查询。

首先，线段树用结构体维护，如下：

```cpp
struct node {
	int l, r;
	int val;
} tree[maxn * 4];
```

其中l, r表示节点所表示区间左右端点，而val则是区间和。

Build函数如下：

```cpp
void Build(int l, int r, int pos) {
	tree[pos].l = l;
	tree[pos].r = r;
	tree[pos].val = 0;
	if(l == r) return ;
	int mid = (l + r) / 2;
	Build(l, mid, pos * 2);
	Build(mid + 1, r, pos * 2 + 1);
}
```

这个函数就是初始化整棵线段树，没有什么特别需要解释的。

Update函数如下：

```cpp
void Update(int x, int val, int pos) {
	if(tree[pos].r == tree[pos].l) {
        tree[pos].val += val;
        return ;
    }
    
    int mid = (tree[pos].l + tree[pos].r) / 2;
    if(x <= mid) Update(x, val, pos * 2);
    else Update(x, val, pos * 2 + 1);
    tree[pos].val = tree[pos * 2].val + tree[pos * 2 + 1].val;
}
```

x表示需要修改的节点，val表示需要增加的值，pos表示当前节点。

如果走到了叶节点上，直接修改，然后结束。

否则，判断x在当前节点的哪一个儿子上，向下。

最后更新当前节点的值。

Query函数如下：

```cpp
int Query(int l, int r, int pos) {
	if(tree[pos].l >= l && tree[pos].r <= r) {
        return tree[pos].val;
    }
    int mid = (tree[pos].l + tree[pos].r) / 2;
    int ans = 0;
    if(l <= mid) ans += Query(l, r, pos * 2);
    if(mid < r) ans += Query(l, r, pos * 2 + 1);
    return ans;
}
```

如果当前节点的整个区间都已经被包含在所求的区间内了，那么不用再进行划分，返回区间值即可。

否则分三种情况讨论：

    1. 若所求区间只与左儿子有交集，移到左儿子。
    
    2. 若只与右儿子有交集，移到右儿子。
    
    3. 若被当前节点覆盖，左儿子右儿子都算。
    
    
以上就是思路及关键代码。

顺便推荐两道经典的单点修改题目（反正我是做了的）：

    1. HDU1166 敌兵布阵
    
    2. HDU1754 I hate it
    
    （注：第二道题是求区间最值，和模板稍有不同。）

---

## 作者：Suuon_Kanderu (赞：15)


树状数组是一种用来维护区间操作的数据结构




如图，一个维护和的一个树状数组。

因为直接看十进制看不出什么套路，好心的我转换成了二进制。

你可以清晰的发现很多性质，下面我来捋一捋：
![](https://cdn.luogu.com.cn/upload/image_hosting/9t3bv5s8.png)
- 设树状数组为$C_i$，正常数组为$A_i$。
- 首先我们定义一个函数 $\operatorname {lowbit}  k $ 表示二进制中最右边“1”的位置（你可能觉得奇怪但这个函数很有用。
- 单点修改：
	随便举个例子，比如将$A_{0001} + 5$，看图我们要将$C_{0001} + 5,C_{0010} + 5,C_{0100} + 5,C_{1000} + 5$，很容易看出规律：
    
    每个增加的下标都是原有的下标 i 加上 
            $ \operatorname {lowbit}i $ 
   
   有人可能要问了不就是1的位置往右移动了1位吗？你扯出个 lowbit 有啥用？
   
   不急，换个例子，比如把$A_{0011} + 5$，就要把 $C_{0100}+5,C_{1000} + 5$。
   
   在这个例子中，
   
   $\operatorname {lowbit}0011 = 1 $  ， $0011 + \operatorname {lowbit}0011  = 0100$。
   
   $\operatorname {lowbit}0100 = 3 $  , $  0100 + \operatorname {lowbit}0100  = 1000$  。
   
   看吧，全部吻合了。
   ![](https://cdn.luogu.com.cn/upload/image_hosting/9t3bv5s8.png)
   
   （为了不让你们翻页看，我给你们再加一次
   ）
- 区间查询 ：
	树状数组来求 1 到 N 的区间和比较方便，但我们如何求 K 到 N 的区间和呢？ 只需要让 1 到 N 的和 减去 1到 K-1 的和。（前缀和思想） 

	也来个例子，求$\sum\limits_{i = 1}^{n=7}A_i$,你们可能知道了，肯定又和 $\operatorname {lowbit} $ 有关,它 等于 $C_{0111} + C_{0111- \operatorname{lowbit}0111}(0110) +  C_{0110- \operatorname{lowbit}0110}(0100) $,再减的话就为0了，所以就OK了。

- 单点查询 ，跟上面差不多，就是用$C_{i}$的值减去$ C_{i - \operatorname {lowbit}i} $ 再减去 $C_{(i - \operatorname {lowbit}i) - \operatorname {lowbit}(i - \operatorname {lowbit}i)} \cdots$。

P.S. 跟上面差不多，就不仔细说了。

P.S. $ \operatorname {lowbit} i $的实现是 $i&（-i）$,用了计算机内部补码的性质 

~~受了k总的影响~~，题解不发代码，只要能帮助别人，就是一篇合格的题解！

---

## 作者：蔡俊黠 (赞：10)

刚刚学了线段树，找点模板题练练手！
这题要我们做的就是单点修改，区间查询
一想到单点修改，区间查询，树状数组绝对是主角！
可是我要练习线段树！因为线段树的应用范围比树状数组要广，所以不能会了树状数组就不学其他的算法

线段树的意义上面的各位大佬已经解释得很清楚了，我的解释都在代码里，我比较喜欢在代码里说明这一步要做什么，这一步的意义

一遍就AC，线段树好感度++！

### AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5*4;
int n,m;
long long tree[N*4];
void change_point(int k,int l,int r,int x,int v) //单点修改 
//k:当前结点  l,r:当前区间  x:原序列的位置 v:需要修改的值 
{
	if (r<x||l>x) return; //当前区间与原序列的位置完全无交集
	if (l==x&&r==x) //当前结点为对应的叶子结点
	{
	    tree[k]+=v;
		return;	
	} 
	int mid=(l+r)/2;
	change_point(k*2,l,mid,x,v);
	change_point(k*2+1,mid+1,r,x,v); //修改右子区间
	tree[k]=tree[k*2]+tree[k*2+1];//更新相关的值 
}
long long search(int k,int l,int r,int x,int y)
//k:当前结点  l,r:当前区间  x,y:查询区间 
{
	if (y<l||x>r) return 0;//当前区间与原序列的位置完全无交集,返回一个不影响答案的值 
	if (l>=x&&r<=y) return tree[k]; //询问区间在当前区间，返回维护好的值
	int mid=(l+r)/2;
	return search(k*2,l,mid,x,y)+search(k*2+1,mid+1,r,x,y); 
}
int main()
{
	scanf("%d %d",&n,&m);
	for (int i=1;i<=m;i++)
	{
		char c; int x,y;
		cin>>c>>x>>y;
		if (c=='x') change_point(1,1,n,x,y);//单点修改 
		if (c=='y') printf("%lld\n",search(1,1,n,x,y));//区间查询 
	}
	return 0;
}
```


---

## 作者：Suuon_Kanderu (赞：5)

有树状数组的地方，就少不了线段树。有线段树的地方，就少不了分块。~~我自己编的~~

**分块是一种很容易理解数据结构，他可以维护很多的东西**~~当然我都不会~~，本题解旨在让只能得暴力分的同学AC本题！学会分块的思想以及方法，会比较详细。

- 分块的思想

	所谓分块，顾名思义，就是把一组数据分为若干块，从而提高效率。
    
    举个例子：来看一组数据1,5,6,4,5。
    我们把他分成$\sqrt{n}$个块（不同的情况块的数量不同，就是这样
 
| 编号 | 数值 | 第几块 |
| ----------- | ----------- | ----------- |
| 1 | 1 | 1 |
| 2 | 5 | 1 |
| 3 | 6 | 2 |
| 4 | 4 | 2 |
| 5 | 5 | 3 |

如果我们要让编号一到五加1，可以这样做：
	
    1. 把第一块（1）的值 暴力 加1
    2. 把中间块（2）的每个块的标记+1
    （如何打标记？只要再开一个数组，记录每一块的统一加的值即可，相信学过线段树的同学一定很熟悉）
    3. 把最后一块（3）的数值 暴力 加1

然后就是这样




|编号 | 数值 | 第几块 |
| ----------- | ----------- | ----------- | ----------- |
| 1 | 2（1+1） |1  | 
| 2 | 6 （5+1）| 1 | 
| 3 | 6 | 2 |  |
| 4 | 4 | 2 |  |
| 5 | 6 （5+1）|3  |

|第几块  | 标记 |
| ----------- | ----------- |
| 1 | 0 |
| 2 | 1（0+1） |
| 3 | 0 |


区间查询同理，只是暴力加的时候要加上打的标记。

单点查询就是把标记和数值加起来就OK。

- 具体实现
	
    实现时我们要考虑一些细节。
    
    1. 如果要操作的两个端点在一个块内，直接暴力相加。
    还是很好理解的
- 代码（不是本题）
```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<string.h>
using namespace std;
const int N=10000000+100;
struct fk{//分块大法 
	int num,rank;//数值，第几块 
}a[N];
int tag[N];//标记
#define rank(x) a[x].rank
#define tag(x) tag[x]
#define num(i) a[i].num
int n,bs,zo;//共有几个数，块的大小 ,总共有几个块 
int qsum(int l){
	return a[l].num + tag(rank(l));//单点查询
}
void change2(int l,int r,int add){
    for (int i=l; i<=min(rank(l)*bs,r); i++)num(i)+=add;//这个是前面的块，这里后面解释
    if (rank(l)!=rank(r))
        for (int i=(rank(r)-1)*bs+1; i<=r; i++)num(i)+=add;//这个是后面的块，这里后面解释
    for (int i=rank(l)+1; i<=rank(r)-1; i++)
        tag(i)+=add;//这个是整块处理
}
void pr(){
	printf("\tid\tnum\trank\n");
	for(int i=1;i<=n;i++)printf("\t%d:\t%d\t%d\n",i,num(i),rank(i));
	printf("\n\tid\ttag\n");
	for(int i=1;i<=zo;i++)printf("\t%d:\t%d\t\n",i,tag(i));	
}
signed main(){
	cin>>n;bs=sqrt(n);
	if(n/bs*bs==n)zo=n/bs; else zo=n/bs+1
    //会不会有不完整的块;
	int k;cin>>k;		
	for(int i=1;i<=n;i++){
		a[i].num = 0;
		a[i].rank=(i-1)/bs+1;		
	} 
	int l,r;
	while(k--){            
		int op; scanf("%d",&op);
		if(op==0){
		    scanf("%d%d",&l,&r);
            change2(l,r,1);
		}
		if(op==1) {
			scanf("%d",&l);
            printf("%d\n",qsum(l));
		}	
	} 
	return 0;
}
```
（大佬自行跳过此区域）
	解释一下处理前面的块和后面的块的代码
     min(rank(l)*bs,r)
     
       				
                    
                    
rank（l） $\times$ bs就是第 I 个块 乘上 块的大小，很容易明白，就是块的最后一个元素。
	用前面的数列，比如
    
  rank(1) $\times$ 2 = 1 $\times$2 = 2 
  
  果然是第一个块的最后一个元素。
    min()里面有个 r 是考虑左端点和右端点可能在一个块里，如果是，那么就直接暴力全加完，后面的操作其实都没执行。
    
 (rank(r)-1)*bs+1同理，就是块的第一个元素。
 
 简单粗暴
 




---

## 作者：S_Gloria (赞：3)

~~就是一个很裸的树状数组题~~
### 写在前面：

原码，反码，补码：

正数：原==反==补

负数：

原码略；

反码：第一位（符号位）不变，其他位取反；

补码：反码+1；

栗子：-10

原码：10001010；

反码：11110101；

补码：11110110；


------------

------------


### 树状数组：
ccs：树状数组，顾名思义，就是橡树一样的数组..


![](https://cdn.luogu.com.cn/upload/pic/73033.png)

看这张图就一目了然了。

**两个数组：**

a[i]储存原序列；
c[i]树状数组；

c[1]存第一个数（如图），
c[2]存前两个数的和，
c[3]存第三个数，
c[4]存前四个数的和...以此类推。



树状数组储存方式独特，其中储存的和的个数为其lowbit值。

**举个栗子**：

c[1]中存了1个数，lowbit（1）=1；

c[2]中存了2个数，lowbit（2）=2；

c[4]中存了4个数，lowbit（4）=4；

而lowbit怎么算呢？~~（先逃）~~

### 树状数组主要包括三个函数

**first. 求lowbit值**
```cpp
int lowbit(int x)
{
	return x&(-x);
}
```

**second.给第x个数加k**

```cpp
void update(int x,int k)
{

	while(x<=n)
	{
 		c[x]+=k;
		x+=lowbit(x);
	}
}
```

**third.查询区间和**

```cpp
int getsum(int x)
{
	int sum=0;
	while(x>0)
	{
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
```


~~（手动模拟一下就知道了）~~

#### 题目
**题目描述**

如题，已知一个数列，你需要进行下面两种操作：

1.将某一个数加上x

2.求出某区间每一个数的和

**输入格式**

第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。

第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。

接下来M行每行包含3个整数，表示一个操作，具体如下：

操作1： 格式：1 x k 含义：将第x个数加上k

操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和

**输出格式**

输出包含若干行整数，即为所有操作2的结果。





```cpp
#include<iostream>
using namespace std;
int n,m;
int c[510000];
int lowbit(int x)
{
	return x&(-x);
}
void update(int x,int k)//对第x个数加k
{

	while(x<=n)
	{
 		c[x]+=k;
		x+=lowbit(x);
	}
}
int getsum(int x)//求前x项的和
{
	int sum=0;
	while(x>0)
	{
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
int main()
{
	int a;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		update(i,a);//建立树状数组
	}
		
	int x,k,z;
	
	for(int i=1;i<=m;i++)
	{
		cin>>z>>x>>k;
		if(z==1)update(x,k);
		if(z==2)
		{
			int u=getsum(k);
			int v=getsum(x-1);
			cout<<u-v<<endl; 
		}
	}
}
```



**题目描述**

如题，已知一个数列，你需要进行下面两种操作：

1.将某区间每一个数数加上x

2.求出某一个数的值

**输入格式**

第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。

第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。

接下来M行每行包含2或4个整数，表示一个操作，具体如下：

操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k

操作2： 格式：2 x 含义：输出第x个数的值

**输出格式**

输出包含若干行整数，即为所有操作2的结果。

```cpp
#include<iostream>
using namespace std;
int n,m;
int c[510000],c2[510000];
int lowbit(int x)
{
	return x&(-x);
}
void update(int x,int k)
{

	while(x<=n)
	{
 		c[x]+=k;
		x+=lowbit(x);
	}
}
int getsum(int x)
{
	int sum=0;
	while(x>0)
	{
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
int main()
{
	int a,sum=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		update(i,a);
		sum+=a;
		c2[i]=sum;//直接用前缀和存原树状数组
	}
	int x,y,z;
	for(int i=1;i<=m;i++)
	{
		cin>>a;
		if(a==1)
		{
			cin>>x>>y>>z;
			update(x,z);
			update(y+1,-z);
		}
		if(a==2)
		{
			cin>>x;
			cout<<getsum(x)-c2[x-1]<<endl;
		}
	}
}
```

## 最后贴上完整AC代码
```cpp
#include<iostream>
using namespace std;
int n,m;
int c[110000];
char a;
int lowbit(int x)
{
	return x&(-x);
}
void update(int x,int k)
{
	while(x<=n)
	{
		c[x]+=k;
		x+=lowbit(x);
	}
}
int getsum(int x)
{
	int sum=0;
	while(x>0)
	{
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
int main()
{
	cin>>n>>m;
	int x,y;
	for(int i=1;i<=m;i++)
	{
		cin>>a>>x>>y;
		if(a=='x')
			update(x,y);
		if(a=='y')
			cout<<getsum(y)-getsum(x-1)<<endl;
	}
}
```


---

## 作者：皮卡丘最萌 (赞：2)

蒟蒻今天终于红了，于是写篇题解庆祝一下。


------------

由于蒟蒻能力不足，只能奉上树状数组解法。

树状数组就是一种数据结构基于用途是维护序列的前缀和。对于区间[1，x]，树状数组将其分为logx个子区间，从而满足快速询问区间和。

例如有这样一个数列：

A 1 3 6 2 9 12 8 3 5 6

对其进行维护后，变成这样：

![404](https://cdn.luogu.com.cn/upload/pic/75801.png)

而sum数组的值是这样累加的：

![404](https://cdn.luogu.com.cn/upload/pic/75802.png)

这样，在修改时，我们只需要把所有与其相关联的位置修改；求和时只需要把所有与其相关联的位置相加，时间复杂度都是log n级别的。

要求所有相关联的点，我们只要求(-x) and x的值，具体涉及到位运算的知识。

------------

代码：
```pascal
var n,m,i,j,x,y:longint; 
a,b,c:array[0..1000001] of longint; z1,z:char;
function lowbit(x:longint):longint;
begin
exit(x and (-x));             //求相关联的点
end;

procedure xg(x,y:longint);
begin
while x<=n do
  begin
  c[x]:=c[x]+y;
  x:=x+lowbit(x);      //修改操作，把所有与其相关联的位置修改
  end;
end;

function sum(x:longint):longint;
begin
sum:=0;                   //注意这里要先归0
while x>0 do
  begin
  sum:=sum+c[x];
  x:=x-lowbit(x);     //求和操作，把所有与其相关联的位置相加
  end;
end;


begin
readln(n,m);
for i:=1 to m do
  begin
  readln(z,z1,x,y);
  if z='x' then xg(x,y) else writeln(sum(y)-sum(x-1));
           //在进行求和操作时，与前缀和一样，减的都是sum(x-1)
  end;
end.
```



---

## 作者：封禁用户 (赞：2)

 ```
 来一发线段树题解
 这莫非就是单点修改区间查询的线段树，
 别忘记数组要开大（至少开4倍空间）
 因为一开始数组都是零，所以我们可以对build函数做一些修改：
 ```cpp
 inline void build(int k,int ll,int rr)
{
    tree[k].l=ll,tree[k].r=rr;
    if(tree[k].l==tree[k].r)
        return;//这里的读入可以去掉
    int m=(ll+rr)/2;
    build(k*2,ll,m);
    build(k*2+1,m+1,rr);
    //最后就不需要加了
}
然后就是单点修改：
```cpp
inline void change_point(int k)
{
    if(tree[k].l==tree[k].r)
    {
        tree[k].w+=y;//对第a位加b的操作
        return;
    }
    if(tree[k].f) down(k);//标记下传
    int m=(tree[k].l+tree[k].r)/2;//类似二分的查找
    if(x<=m) change_point(k*2);//二分查找
    else change_point(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w; //最后累加到k
}
区间查询：
```cpp
inline void ask_interval(int k)
{
    if(tree[k].l>=a&&tree[k].r<=b) 
    {
        ans+=tree[k].w;//累加
        return;
    }
    if(tree[k].f) down(k);//标记下传
    int m=(tree[k].l+tree[k].r)/2;//这里同上
    if(a<=m) ask_interval(k*2);
    if(b>m) ask_interval(k*2+1);
}
AC代码放上：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,a,b,m,x,y;
long long ans;
struct node
{
    int l,r;
    long long f,w;
}tree[2000005];
inline void build(int k,int ll,int rr)
{
    tree[k].l=ll,tree[k].r=rr;
    if(tree[k].l==tree[k].r)
        return;
    int m=(ll+rr)/2;
    build(k*2,ll,m);
    build(k*2+1,m+1,rr);
}
inline void down(int k)
{
    tree[k*2].f+=tree[k].f;
    tree[k*2+1].f+=tree[k].f;
    tree[k*2].w+=tree[k].f*(tree[k*2].r-tree[k*2].l+1);
    tree[k*2+1].w+=tree[k].f*(tree[k*2+1].r-tree[k*2+1].l+1);
    tree[k].f=0;
}
inline void ask_interval(int k)
{
    if(tree[k].l>=a&&tree[k].r<=b) 
    {
        ans+=tree[k].w;
        return;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(a<=m) ask_interval(k*2);
    if(b>m) ask_interval(k*2+1);
}
inline void change_point(int k)
{
    if(tree[k].l==tree[k].r)
    {
        tree[k].w+=y;
        return;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) change_point(k*2);
    else change_point(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w; 
}
int main()
{
    scanf("%d%d",&n,&m);
    build(1,1,n);
    char ps[2];
    for(int i=1;i<=m;i++)
    {
        scanf("%s",ps);
        ans=0;
        if(ps[0]=='y')
        {
            scanf("%d%d",&a,&b);
            ask_interval(1);
            printf("%lld\n",ans);
        }
        else
        {
             scanf("%d%d",&x,&y);
             change_point(1);
        }
    }
    return 0;
}

```
```
```
```
 ```

---

## 作者：ModestCoder_ (赞：2)

来一波树状数组

其实很简单啦，代码也比线段树好码

两个操作：

1、x，那就把所有管辖范围有输入的数的点加

2、y，求和

上程序










```cpp
var
    c:array[0..1000000] of longint;
    n,m,x,y,i:longint;
    ch,ch1:char;
function lowbit(x:longint):longint;
begin
    exit(x and -x);
end;
procedure change(x,y:longint);
begin
    while x<=n do
        begin
            inc(c[x],y);
            inc(x,lowbit(x));
        end;
end;
function getsum(x:longint):longint;
begin
    getsum:=0;
    while x>0 do
        begin
            inc(getsum,c[x]);
            dec(x,lowbit(x));
        end;
end;
begin
    readln(n);
    readln(m);    
    for i:=1 to m do
        begin
            read(ch,ch1);
            if ch='x' then
                begin
                    readln(x,y);
                    change(x,y);
                end else
                begin
                    readln(x,y);
                    writeln(getsum(y)-getsum(x-1)); //前缀和
                end;
        end;
end.

```

---

## 作者：S1gMa (赞：2)

刚刚学完线段树 做练习的同时来写一篇题解吧

首先 ：建树

对于线段树的编写 第一步的重点就是建树 此后所有进行的更改均需第一步建树

顾名思义： 建树从字面意义上来讲就是 数组以树的方式存储下来；

举个例子：

令 $a[6] = {1,3,5,7,9,11};a[6]=1,3,5,7,9,11$;

同时再开一个数组 $tree[4 · 6] = 0，tree[4 · 6]=0$; （这里对于线段树来说一般需要开 $ 4 * n$ 的空间 $n$ 为原数组大小）

核心思想：每次进行对数组二分 分为 $L ,R$ 两个分叉 每个叶子的父节点为其子节点的和

接着单点修改时 可直接查询遍历子树修改 每次查询时将lazy下放即可

求和时分左右子树查找最后累加即可

简单易懂的题解，代码如下
```
#include <bits/stdc++.h>
using namespace std;
#define MAX_LEN 400005

int arr[MAX_LEN];
int size1;
long long add[MAX_LEN];
long long tree[MAX_LEN] = {0};
int q, p, m;
long long k;

void push_down(int node, int m)//lazy标记 同时下放操作
{
    if (add[node])
    {
        add[2 * node + 1] += add[node];
        add[2 * node + 2] += add[node];
        tree[2 * node + 1] += (m - (m >> 1)) * add[node];
        tree[2 * node + 2] += (m >> 1) * add[node];
        add[node] = 0;
    }
}

void build_tree(int node, int start, int end)//建树
{
    add[node] = 0;
    if (start == end)
        tree[node] = arr[start];
    else
    {
        int mid = (start + end) / 2;
        int left_node = 2 * node + 1;
        int right_node = 2 * node + 2;
        build_tree(left_node, start, mid);
        build_tree(right_node, mid + 1, end);//分别遍历左右子树
        tree[node] = tree[left_node] + tree[right_node];
    }
}
void arr_tree(int node, int start, int end, int L, int K)
{
    if (start == end)
    {
        tree[node] += (end - start + 1) * K;
        add[node] += K;//lazy数组进行标记
        return;
    }
    push_down(node, end - start + 1);//下放
    int mid = (start + end) / 2;
    int left_node = 2 * node + 1;
    int right_node = 2 * node + 2;
    if (L <= mid)
        arr_tree(left_node, start, mid, L, K);
    if (L > mid)
        arr_tree(right_node, mid + 1, end, L, K);
    tree[node] = tree[left_node] + tree[right_node];//因为修改后的值会影响线段树的要求 因此 需要重新更新其子树的节点值
}

long long query_tree(int node, int start, int end, int L, int R)
{
    if (R < start || L > end)
        return 0;//如果本身不符合区间 直接返回0
    else if (L <= start && end <= R)
        return tree[node];
    else if (start == end)
        return tree[node];//遍历到最深子节点 则返回
    else
    {
        push_down(node, end - start + 1);//下放操作
        int mid = (start + end) / 2;
        int left_node = 2 * node + 1;
        int right_node = 2 * node + 2;
        long long sum_left = query_tree(left_node, start, mid, L, R);
        long long sum_right = query_tree(right_node, mid + 1, end, L, R);
        return sum_left + sum_right;//累加操作
    }
}//求和同理

int main()
{
    cin >> size1 >> m;
    for (int i = 0; i < size1; i++)
    {
        arr[i] = 0;
    }
    build_tree(0, 0, size1 - 1);
    for (int i = 0; i < m; i++)
    {
        char z;
        int x, y;
        cin >> z;
        if (z == 'x')
        {
            cin >> x >> k;
            arr_tree(0, 0, size1 - 1, x - 1, k);
        }
        if (z == 'y')
        {
            cin >> x >> y;
            long long sum = query_tree(0, 0, size1 - 1, x - 1, y - 1);
            cout << sum << endl;
        }
    }
    return 0;
}

---

## 作者：king_xbz (赞：1)

//这是一道经典的树状数组模板题适合树状数组初学者练习
//若从未接触过树状数组，建议先了解前缀和 
code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define h 5782356
#define p 2001
using namespace std;
int lowbit(int x);
void addup(int x,int y);//区间增加函数 
int tot(int x);//区间求和函数 
int f[h]; 
int tree[h];//树状数组 
int n,w;//n和w要开全局变量方便查询 
vector <int>q;//没用到的vector 
char a; 
int b,c;
signed main()
{
    cin>>n;
    cin>>w;
    //输入n与w 
    for(int i=1;i<=w;i++)
    {
    cin>>a>>b>>c;
    if(a=='x')
    addup(b,c);
    //如果a是x，就增加 
    else
    if(a=='y')
    cout<<tot(c)-tot(b-1)<<endl;
    //如果a是y，就输出区间和，注意换行（我开始就因此全wa） 
    //tot(一定是b-1)
}
} 
int lowbit(int x)
{
	return x&(-x);
}
//这里用到lowbit
//根据“and”的性质 
//x&(-x)，若x为0则结果为0；
//else 
//x为奇数时，结果为1；
//x为偶数时，结果为x中2的最大次方的因子。
void addup(int x,int y)
{
//	int t=0;
	for(int i=x;i<=n;i+=lowbit(i))
	tree[i]+=y;	
}
//在i位置加上y
int tot(int x)
{
	int t=0;
	for(int i=x;i;i-=lowbit(i))
	t+=tree[i];
	return t;
}
//根据前缀和求tree[from 1 to x]的和 
```cpp

---

## 作者：合451518 (赞：1)

标准的简化版线段树模板。

由于没有初始值，所以不需要建树。

介绍三个核心函数：

1. up(int p)

用于更新p节点的值。因为这是二叉树，p节点的子节点为2p,2p+1.

s[]用于存储tree.

更新操作：s[p]=s[2p]+s[2p+1];

2. update(int p, int l, int r, int x, int v)

用于更新第x个数，使第x个数+v

因为更新第x个数后，存储第x个数值节点的父节点（上司）都会受到影响，于是传递节点p，节点p的值为：s[p]=a[l]+a[l+1]+..+a[r];

l,r是p的“范围”

若l=r表示已经找到存储a[x]的节点，+v.

然后再二分，更新节点。

3. query(int p, int l, int r, int x, int y);

p,l,r的定义见2.

这个函数用于获得[x,y]区间的和。

分析可知：如果[l,r]包含于[x,y]，那么可以直接将s[p]的值加入最后的答案中。

（s[p]=a[l]+..+a[r], a[l]+...+a[r]+k=a[x]+...+a[y].）

所以在这种情况下，可以直接返回。


if (x<=l && y<=r) then return s[p];

如果[l,r]不是[x,y]的子集，那么取m=(l+r) div 2;

分两边讨论。

如果x<=m,则讨论左边；

如果m<y,讨论右边。


注意：

这两种情况是并列的，不存在else的情况。

所以这一段的伪代码就是：

```cpp
m=(l+r)/2;
int ret=0;
if x<=m ret+=query左边
if m<y ret+=query右边
return ret;
```
具体实现见下。

最后。。主程序

由于不需要建树，我们只需要看读入处理部分。思路即伪代码如下：


```cpp
for i=1 to m do begin
 cin >> ch >> a >> b;
 if (ch=='x') update a 节点
  else cout << query << endl;
end;
```
即可。

附上完整c++代码：










```cpp
//Luogu 2068
#include<cstdio>
#include<iostream>
using namespace std;
const int MAXN=100000;
int n, m;
long long s[MAXN*4+10]={0};
void up(int p)
{
    s[p]=s[2*p]+s[2*p+1];
    return;
}
void update(int p, int l, int r, int x, int v)
{
    if (l==r) {
        s[p]+=v;
        return;
    }
    int m=(l+r)/2;
    if (x<=m) update(2*p, l, m, x, v);
        else update(2*p+1, m+1, r, x, v);
    up(p);
    return;
}
long long query(int p, int l, int r, int x, int y)
{
    if (x<=l && r<=y) {
        return s[p];
    }
    int m=(l+r)/2;
    long long ret=0;
    if (x<=m) ret+=query(p*2, l, m, x, y);
    if (m<y) ret+=query(p*2+1, m+1, r, x, y);
    return ret;
}
int main()
{
    cin >> n;
    cin >> m;
    char ch;
    int a, b;
    for (int i=0; i<m; i++) {
        cin >> ch;
        scanf("%d%d", &a, &b);
        cin.ignore();
        if (ch=='x') {
            update(1,1,n,a,b);
        }
            else cout << query(1,1,n,a,b) << endl;
    }
    return 0;
}

```

---

## 作者：重回巅峰！ (赞：1)

标准的树状数组。。。。。

算法分析

如果直接做的话,修改的复杂度是O(1),询问的复杂度是O(N),M次询问的复杂度是M\*N.M,N的范围可以有100000以上,所以这样做会超时,但是如果用线段树的话,还是很不错的! 有很多线段树能实现但树状数组却实现不了的题目。

线段树解法分析

可以看出,这棵树的构造用二分便可以实现.复杂度是2\*N.

每个结点用数组a来表示该结点所表示范围内的数据之和.

修改一个位置上数字的值,就是修改一个叶子结点的值,而当程序由叶子结点返回根节点的同时顺便修改掉路径上的结点的a数组的值.

对于询问的回答,可以直接查找i..j范围内的值,遇到分叉时就兵分两路,最后在合起来.也可以先找出0..i-1的值和0..j的值,两个值减一减就行了.后者的实际操作次数比前者小一些.

这样修改与维护的复杂度是logN.询问的复杂度也是logN,对于M次询问,复杂度是MlogN.

然而不难发现,线段树的编程复杂度大,空间复杂度大,时间效率也不高!!!!

所以我们来想用树形数组来实现:

那么,何为树形数组呢??

C数组就是树状数组,a数组是原数组;

对于序列a，我们设一个数组C定义C[t] = a[t – 2^k + 1] + … + a[t]，k为t在二进制下末尾0的个数。

K的计算可以这样:

2^k=t and (t xor (t-1))

以6为例

```cpp
(6)10=(0110)2
xor 6-1=(5)10=(0101)2
(0011)2
and (6)10=(0110)2
(0010)2
```
所以问题变的很简单,重要写几个函数就可以了;
```cpp
var
  sum:array[0..100005]of longint;
  n,i,x,a,b,w:longint;
  ch:char;
function lowbit(x:longint):longint;
begin
  exit(x and -x);
end;
procedure add(x,k:longint);
begin
  while x<=n do
  begin
    sum[x]:=sum[x]+k;
    x:=x+lowbit(x);
  end;
end;
function query(x:longint):longint;
begin
  query:=0;
  while x>0 do
  begin
    query:=query+sum[x];
    x:=x-lowbit(x);
  end;
  exit(query);
end;
begin
  readln(n);
  readln(w);
  for i:=1 to w do
  begin
    readln(ch,a,b);
    if ch='x' then add(a,b);
    if ch='y' then writeln(query(b)-query(a-1));
  end;
end.

```

---

## 作者：时光_Memory (赞：0)

  

```cpp
#include<cstdio>  
#include<cstdlib>  
#include<iostream>  
#include<cmath>  
#include<algorithm>
using namespace std;  
long long n;  
int w;
int x,y;
int a[100000],c[100000];  
char ch;
void xiugai(int k,int num)
{
    while(k<=n)
      {
        c[k]+=num;
        k+=k&-k;
      }
}
long long qiuhe(int k)
{
    long long sum=0;
    while(k>0)
      {
        sum+=c[k];
        k-=k&-k;
      }
    return sum;
}
int main()  
{  
    cin>>n;
    cin>>w;
       for(int i=1;i<=w;i++)
         {
            cin>>ch;
            cin>>x>>y;
            if(ch=='x')//修改
              xiugai(x,y);
            if(ch=='y')//询问
              cout<<qiuhe(y)-qiuhe(x-1)<<endl;
      }
}
```

---

## 作者：YZ亮晶晶 (赞：0)

裸的树状数组

```delphi

var i,n,w,x,y:longint;c:array[0..100000]of longint;ch:char;
function lowbit(x:longint):longint; //求2^k(k为二进制后面0的个数）
begin
    exit(x and(-x));
end;
procedure change(x,data:longint);//向上维护c数组
begin
    repeat
        c[x]:=c[x]+data;
        x:=x+lowbit(x);
    until x>n;
end;
function sum(x:longint):longint;//求和
begin
    sum:=0;
    repeat
        sum:=sum+c[x];
        x:=x-lowbit(x);
    until x<=0;
end;
begin
    readln(n,w);
    for i:=1 to w do
    begin
        readln(ch,x,y);
        if ch='x' then change(x,y);
        if ch='y' then  writeln(sum(y)-sum(x-1));
    end;
end.

```

---

## 作者：汇文客 (赞：0)

标准的树状数组动态统计。在此贴上模板。

```delphi

function lowbit(x:longint):longint;
begin
  lowbit:=x and -x;
end;

procedure change(i:longint;num:int64);
begin
  while i<=n do
  begin
    c[i]:=c[i]+num;
    i:=i+lowbit(i);
  end;
end;

function sum(i:longint):int64;
begin
  sum:=0;
  while i>0 do
  begin
    sum:=sum+c[i];
    i:=i-lowbit(i);
  end;
end;

```

---


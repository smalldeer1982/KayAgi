# 【模板】树状数组 2

## 题目描述

如题，已知一个数列，你需要进行下面两种操作：

1. 将某区间每一个数加上 $x$；

2. 求出某一个数的值。

## 说明/提示

#### 样例 1 解释：

 ![](https://cdn.luogu.com.cn/upload/pic/2258.png) 

故输出结果为 $6$ 和 $10$。

---

#### 数据规模与约定

对于 $30\%$ 的数据：$N\le8$，$M\le10$；

对于 $70\%$ 的数据：$N\le 10000$，$M\le10000$；

对于 $100\%$ 的数据：$1 \leq N, M\le 500000$，$1 \leq x, y \leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。

## 样例 #1

### 输入

```
5 5
1 5 4 2 3
1 2 4 2
2 3
1 1 5 -1
1 3 5 7
2 4```

### 输出

```
6
10```

# 题解

## 作者：getchar_unlocked (赞：27)

[树状数组 1](https://www.luogu.com.cn/problem/P3374) | [树状数组 2（本题）](https://www.luogu.com.cn/problem/P3368) | [修改记录](https://www.luogu.com.cn/paste/3i6jww3e)

### 前置知识

**lowbit**：

> $\operatorname{lowbit}(X)$ 表示 $X$ 在二进制下，最末尾的 $1$ 所代表的数字加上后面的 $0$ 组成的数字。
> 
> 对于数 $X$ 做 lowbit 操作，在代码中可以表示为 `X&(-X)`。例如当 $X=76$ 时，其二进制为 $\texttt{1001100}$，则 $-X$ 在计算机用反码表示，为 $\texttt{0110100}$，将其按位与操作之后得到 $\texttt{0000100}$，后面组成的数字为 $\texttt{100}$，也就是 $\operatorname{lowbit}(X)$ 的值。

**差分**：

> 一种简单的结构，可以实现 $\mathcal{O}(1)$ 区间修改和 $\mathcal{O}(N)$ 单点查询。
> 
> 令存储差分数组的数组为 $D$。修改操作，将 $[L,R]$ 增加 $K$，则需更改 $D_L\gets D_L+K$，$D_{R+1}\gets D_{R+1}-K$；查询操作需要统计前 $N$ 个数的前缀和。

### 算法介绍

[树状数组](https://oi-wiki.org/ds/fenwick/)，是一种可以实现**单点修改**和**区间查询**的数据结构。

而对于本题，变成了区间修改和单点查询，只需要改变原本的数组 $C$ 的含义变差分即可（与差分模板几乎相同）。
- 对于修改操作，将 $[L,R]$ 增加 $K$，则需更改 $C_L\gets C_L+K$，$C_{R+1}\gets C_{R+1}-K$；
- 对于查询操作，查询第 $X$ 个数的值，则需要求前 $X$ 个 $C_i$ 的和。

### 正确性证明

在这里讲一下树状数组。

![](https://cdn.luogu.com.cn/upload/image_hosting/b0cujsbk.png)

上图是一个树状数组的图示。对于每一个区间 $[L,R]$，代表的是这个区间的和。如果想要访问一个区间 $[L,R]$，那么就要从最大的区间开始，逐级划分，然后加和（类似于[线段树](https://oi-wiki.org/ds/seg/)的思想）。

不难发现，有些区间是没有用的。例如 $[2,2]$，可以用 $[1,2]$ 的值减去 $[1,1]$ 的值得到。图中画叉号的区间都是可以删掉的。

![](https://cdn.luogu.com.cn/upload/image_hosting/g43es59o.png)

删掉没有用的区间后，给每个区间做一个编号，每一个区间的编号为它的右端点的数字。令编号为 $i$ 的区间和为 $C_i$。

你会发现，编号为 $i$ 的区间应为 $[i-\operatorname{lowbit}(i),i]$。初始化十分好想，可以直接用 $A_i$ 的和来表示即可，为：

$$C_i=\sum_{j=i-\operatorname{lowbit}(i)+1}^iA_i$$

![](https://cdn.luogu.com.cn/upload/image_hosting/sczsoyy7.png)

现在想要查询区间 $[L,R]$ 的和，则需要用 $[1,R]$ 的和减去 $[1,L-1]$ 的和。想要查询区间 $[1,X]$ 的和，首先要让其加上 $C_X$，然后让 $X$ 向前移动 $\operatorname{lowbit}(X)$ 位，即 $X\gets X-\operatorname{lowbit}(X)$。然后再加上 $C_X$，再向前移动。循环至 $X$ 变为 $0$ 为止，可以保证包含 $[1,X]$ 中的每一个数都被查询，就完成了统计区间 $[1,X]$ 的问题。

由于单次查询，每一次都会去掉二进制末尾的一个 $1$，在最差情况下会移动 $\log X$ 次，故查询的时间复杂度为 $\mathcal{O}(\log X)$。

现在想要修改点 $X$ 的值，使其增加 $K$。那么相反，$X$ 每次需要向后移动 $\operatorname{lowbit}(X)$ 位，即 $X\gets\operatorname{lowbit}(X)$，然后修改 $C_X\gets C_X+K$。一直向右移动直到移动到大于或等于 $N$ 的点停止，保证每个包含该点的区间都被修改。

同理，单点修改的时间复杂度亦为 $\mathcal{O}(\log X)$。

整体时间复杂度为 $\mathcal{O}(N\log N)$，空间复杂度 $\mathcal{O}(N)$。

### 注意事项

- 需要开 `long long`。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int n,m,a[N];
long long c[N]; // 注意 c 中的值可能超过 int 范围
int lowbit(int x){
	return x&(-x);
}
void add(int x,int k){ // 修改操作
	while(x<=n){
		c[x]+=k;
		x+=lowbit(x);
	}
	return;
}
long long sum(int x){ // 查询操作
	int res=0;
	while(x){
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		add(i,a[i]-a[i-1]); // 按照差分含义初始化
	}
	while(m--){
		int op;cin>>op;
		if(op==1){
			int l,r,k;cin>>l>>r>>k;
			add(l,k),add(r+1,-k); // 差分操作
		}
		else{
			int x;cin>>x;
			cout<<sum(x)<<"\n"; // 前 x 个数的和
		}
	}
	return 0;
}
```

---

## 作者：Fish_egg_ (赞：11)

树状数组是一种支持**单点修改，区间查询**的精巧的数据结构，通常用于维护满足**结合律**和**可差分**的运算和信息。又称二叉索引树（Binary Index Tree）、Fenwick Tree。

### $\color{00cd00}\text{原理介绍}$

下面这张图展示了树状数组的原理（来源：OI-Wiki）。

![](https://oi-wiki.org/ds/images/fenwick.svg)

其中 $c_x$ 表示以 $x$ 为右端点，长度为 ${\rm lowbit}(x)$ 的区间的和。

> ${\rm lowbit}(x)$ 表示的是 $x$ 在二进制表示下，最低位的 $1$ 的权值。  
> 例如，$10$ 在二进制表示下为 $10\underset{\blacktriangle}{\bf1}0$，加粗的就是最低位的 $1$，它的权值是 $2$，因此 $\rm lowbit(10)=2$。  
> 再例如，$24$ 在二进制表示下为 $1\underset{\blacktriangle}{\bf1}000$，最低位的 $1$ 的权值为 $8$，因此 $\rm lowbit(24)=8$。  
> 根据位运算知识，可以得到 `lowbit(x) = x & -x`，其中 `&` 为**按位与**运算。

如果一个数减去自己的 $\rm lowbit$，得到的数再减去自己的 $\rm lowbit$，不断重复，最终这个数一定会变成 $0$。

例如 $7(111)\overset{\!-1}{\longrightarrow}6(110)\overset{\!-2}{\longrightarrow}4(100)\overset{\!-4}{\longrightarrow}0$。

那么我们要计算 $a_{1\dots7}$ 的和，就只需要求 $c_7+c_6+c_4$ 即可。观察上图，看看是不是这样。

由此我们可以得到查询 $a_{1\dots x}$ 的代码：
```cpp
int query(int x)
{
	int ans = 0;
	while(x > 0)
	{
		ans += c[x];
		x -= lowbit(x);
	}
	return ans;
}
```

可以发现，树状数组通过将一段数划分成 $O(\log n)$ 段数的和，从而能够实现高效的查询操作。

如果要求任意一段区间 $a_{l\dots r}$ 的和，可以借助前缀和的思想，用 $a_{1\dots r}$ 的和减去 $a_{1\dots l-1}$ 的和，即 `query(r) - query(l-1)`。这也说明树状数组可以当成一个支持修改的前缀和来用。

如果要将 $a_5$ 加上一个数 $k$ 该如何处理？观察包含 $a_5$ 的区间，只有 $c_5$，$c_6$ 和 $c_8$。那么就只需要将 $c_5$，$c_6$ 和 $c_8$ 都加上 $k$ 即可。而 $6=5+\rm lowbit(5)$，$8=6+\rm lowbit(6)$。也就是说，在树状数组中，一个结点 $x$ 的父亲是 $x+{\rm lowbit}(x)$。由此我们可以得到将 $a_x$ 加上 $k$ 的代码：
```cpp
void update(int x, int k)
{
	while(x <= n)
	{
		c[x] += k;
		x += lowbit(x);
	}
}
```
显然，修改操作的时间复杂度也为 $O(\log n)$。

但是在本题中，我们需要实现的是**区间修改，单点查询**，怎么办？借助**差分**的思想。定义差分数组 $d_i = a_i - a_{i-1}$。于是有 $a_x = \sum\limits_{i=1}^x d_i$。如果要在 $a_{l\dots r}$ 加上 $k$，只需要让 $d_l\gets d_l+k,d_{r+1}\gets d_{r+1}-k$。使用树状数组维护这一过程即可。

### $\color{00cd00}\text{代码实现}$

树状数组的模板部分和 [P3374](https://www.luogu.com.cn/problem/P3374) 是完全一样的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
struct BIT{ //树状数组维护差分数组
	int c[N], lowbit(int x){return x & -x;}
	void update(int x, int k){while(x < N) c[x] += k, x += lowbit(x);}
	int query(int x){int s = 0; while(x) s += c[x], x -= lowbit(x); return s;}
} t;
int n, m, a[N];
signed main(){
	cin.tie(nullptr) -> sync_with_stdio(false);
	cin >> n >> m;
	for(int i=1; i<=n; i++) cin >> a[i], t.update(i, a[i] - a[i-1]);
	while(m --> 0){
		int op, x, y, k; cin >> op;
		if(op == 1) cin >> x >> y >> k, t.update(x, k), t.update(y + 1, -k);
		if(op == 2) cin >> x, cout << t.query(x) << "\n";
	}
	return 0;
}
```

推荐继续阅读我的 [树状数组小记](https://www.luogu.com.cn/article/m0npccng)，包含更多树状数组的高级应用。

---

## 作者：zzx0102 (赞：9)

upd on 2025.4.6 删了一些“考虑”。

引入问题：[P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

显然如果直接暴力一定会 T，需要优化。

我们可以将这些区间拆分成更少的区间数，再对区间暴力求和，就可以起到优化的作用。

于是任何一个数 $x$ 在二进制下均只有 $\mathcal{O}(\log x)$ 位为 $1$。

于是，我们将 $[1,x]$ 这个区间拆分成 $\mathcal{O}(\log x)$ 个区间的和。

令 $x=2^{d_1}+2^{d_2}+\cdots +2^{d_k}$，且 $\forall i\in[2,k],d_i>d_{i-1}$，设 $s_i=s_{i-1}+2^{d_i},s_0=0$，则 $[1,x]$ 被我们拆分成了 $\bigcup\limits_{i=1}^k(s_{i-1},s_i]$。

例：当 $x=15$ 时，$x=(1111)_2$，即 $[1,x]=(0,8]\cup(9,12]\cup(12,14]\cup(14,15]$。

我们用 $\operatorname{lbt}(x)$ 表示 $\operatorname{lowbit}(x)$，指 $x$ 在二进制中最低位的 $1$ 的值，即当 $x=2^{d_1}+2^{d_2}+\cdots 2^{d_k}$ 时，$\operatorname{lbt}(x)=2^{\min\limits_{i=1}^k d_i}$。

所以一般的树状数组大致长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/j0hltmbb.png)

这样分有一个性质：对于每一个区间的右端点 $r$，都只对应一个 $l$。

首先，根据我们的拆分规则，$r=l+2^x$，并且 $x=\log_2\operatorname{lbt}(r)$，所以 $l=r-\operatorname{lbt}(r)$。

所以一共有 $n$ 个不同的子区间。

接下来快速维护 $n$ 个子区间。

由于 $n$ 个区间的右端点各不相同，所以每个区间的区间和可以标记在右端点的位置上。我们建立一个数组 $tr$，则 $tr_x$ 表示以 $x$ 为右端点的子区间的和。即

$$tr_x=\sum\limits_{i=x-\operatorname{lbt}(x)+1}^{x} a_x$$

其中 $a_x$ 表示单点值。

接下来考虑如何修改和查询。

查询显然直接每次将 $x$ 减去 $\operatorname{lbt}(x)$，每次累加 $tr_x$，直至 $0$ 就完事了，复杂度 $\mathcal{O(\log x)}$。

修改其实也不难，可以修改 $x$ 即将所有包含 $x$ 的区间都求出来。

显然 $tr_{x+\operatorname{lbt}(x)}$ 这个区间包含 $x$。

然后 $tr_{x+\operatorname{lbt}(x)+\operatorname{lbt}(x+\operatorname{lbt}(x))}$ 包含 $x+\operatorname{lbt}(x)$，也包含 $x$。

所以每次将 $x$ 加上 $\operatorname{lbt}(x)$，一直到 $n$ 即可。

到了这里，已经可以写出修改和查询的代码了。

```cpp
void chg(int x, int k) {for(; x <= n; x += lbt(x)) tr[x] += k;}
int ask(int x) {int sum = 0; for(; x; x -= lbt(x)) sum += tr[x]; return sum;}
```

这里有一个常数优化，可以使树状数组查询常数变小。

需要查 $[l,r]$ 的区间和，可以用前缀和的方式去求，这当中会有一些重复计算。忽略这些重复计算即可优化。

```cpp
int ask(int l, int r){
	l--; int sum = 0;
	while(r > l) sum += a[r], r -= lbt(r);
	while(l > r) sum -= a[l], l -= lbt(l);
	return sum;
}
```

大约快了一倍。

于是考虑如何求 $\operatorname{lbt}(x)$。

这个总不能 $\mathcal{O}(\log n)$ 枚举，不然复杂度会多一个 $\log$。

当然您可以预处理 $\forall i\in[1,n],\operatorname{lbt}(i)$，不过这样就显得有些没有技术含量，而且会使树状数组常数增大。

计算机用补码存储和表示数值。考虑 $-x$（$x > 0$）的补码，它等于 $x$ 的反码 $+1$。设 $\mathrm{lbt}(x) = 2 ^ k$，我们发现 $-x$ 的补码在低 $k - 1$ 位（第 $0\sim k - 1$ 位）都是 $0$；在第 $k$ 位和 $x$ 相同，均为 $1$；在高于 $k$ 的位和 $x$ 相反。

例如，对于二进制数 $(0\cdots 010100)_2$，其 $\operatorname{lowbit}$ 值为 $4$，其反码为 $(1\cdots 101011)_2$，相反数的补码为 $(1\cdots 101100)_2$。又因为正数的补码就是它本身，所以一个数的 $\operatorname{lowbit}$ 值就等于它和它的相反数的按位与，即 `x & -x`。

[P3374 CODE](https://www.luogu.com.cn/paste/so9eq979)

接下来就是用树状数组维护区间加区间和。

这里使用差分。设差分数组为 $d$，原数组为 $a$。则

$$a_i=\sum\limits_{j=1}^i d_j$$

区间查询即

$$\sum\limits_{i=l}^r a_i$$

$$=\sum\limits_{i=l}^r\sum\limits_{j=1}^i d_j$$

计算贡献，得原式为

$$\sum\limits_{i=1}^{l-1} (r-l+1)d_i+\sum\limits_{i=l}^r (r-i+1)d_i$$

$$=\sum\limits_{i=1}^{l-1} (r-l+1)d_i+(r+1)\sum\limits_{i=l}^r d_i- \sum\limits_{i=l}^r d_i\times i$$

$$=(r+1)\sum\limits_{i=1}^{l-1}d_i-l\times \sum\limits_{i=1}^{l-1}d_i+(r+1)\sum\limits_{i=l}^r d_i- \sum\limits_{i=l}^r d_i\times i$$

$$=(r+1)\sum\limits_{i=1}^r d_i-l\times \sum\limits_{i=1}^{l-1} d_i- \sum\limits_{i=1}^r d_i\times i+\sum\limits_{i=1}^{l-1} d_i\times i$$

可以用两个树状数组维护 $d_i$ 以及 $d_i\times i$ 的前缀和，直接计算即可。

[P3372 CODE](https://www.luogu.com.cn/paste/85r3atvv)

你都会区间加区间和了，应该会区间加单点和吧。

其实单点和更简单，只用开一个树状数组维护 $d_i$ 就行，$a_i=\sum\limits_{j=1}^i d_j$，区间修改只用改 $d_l$ 和 $d_{r+1}$ 就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline
#define gc getchar
#define W while
const int N = 500010; int tr[N], n, q; int lbt(int x) {return x & (-x);}
I void add(int x, int k) {for(; x <= n; x += lbt(x)) tr[x] += k;}
I int query(int x) {
	int sum = 0;
	for(; x; x -= lbt(x)) sum += tr[x];
	return sum;
}
I void Read(int &x) {
	x = 0; char ch = gc(); W(ch < '0' || ch > '9') ch = gc();
	W(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = gc();
}
I void Read(int &x, int &y) {Read(x), Read(y);}
int main() {
	Read(n, q); for(int i = 1; i  <= n; i++) {int x; Read(x); add(i, x); add(i + 1, -x);}
	W(q--) {
		int op, x, y, k; Read(op, x);
		if(op == 1) {
			Read(y);  scanf("%d", &k);
			add(x, k); add(y + 1, -k);
		}
		else printf("%d\n", query(x));
	}
	return 0;
}
```

复杂度 $\mathcal{O(n\log n)}$。

关于 $\operatorname{lowbit(x)}$ 的求法，参考了 [这里](https://www.luogu.com.cn/article/ca41ol8t)。

---

## 作者：粥2414 (赞：8)

~~应该不会有人先做模板 $2$ 后做模板 $1$ 吧~~？

默认读者已经完成了[【模板】树状数组 $1$](https://www.luogu.com.cn/problem/P3374)，所以本题解重点讲解差分部分。
# 前置知识
1. 树状数组单点修改，区间查询。
2. 差分思想。
# 思路
众所周知，树状数组是一种非常好写且高效的求前缀和的数据结构。普通的树状数组仅仅只支持单点修改。那么如果题目要求**区间**修改，**单点**查询，该怎么做呢？
## 修改
不难想到可以利用差分思想修改，即把树状数组看作差分数组。每次让区间 $[l,r]$ 加上 $v$ 时，只需要让下标为 $l$，$l+\operatorname{lowbit}(l)$ 等处加上 $v$，让 $r+1$，$r+1+\operatorname{lowbit}(r+1)$ 等处加上 $-v$ 即可。
## 查询
查询第 $i$ 个数的值时，正常查询到 $i$ 的前缀和，便可以得出答案。
# 正确性和复杂度分析
这样为什么是正确的呢？

众所周知，只要对差分数组求一个前缀和，就可以还原出原数组。而树状数组就是用于求前缀和的数据结构。我们用构建差分数组的方式去构建树状数组，使得此时的树状数组**同时具有差分数组和普通树状数组的性质**。这样，求一遍前缀和便可以得出原数据。  
仔细想想，这样做的本质就是**用树状数组维护差分数组**。

时间复杂度显然是 $O(n\log{n})$。

# 代码
代码与普通树状数组相差不大，唯一有区别的就是 ``do_add`` 函数。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll sta__[100], stalen;
inline ll read() {
	ll x = 0, f = 1;
	char ch;
	while ((ch = getchar()) < 48 || ch > 57)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
inline void write (ll x, bool bo) {
	if (x < 0)putchar ('-'), x = -x;
	do sta__[++stalen] = x % 10, x /= 10;
	while (x);
	while (stalen)putchar (sta__[stalen--] + 48);
	putchar (bo ? '\n' : ' ');
}
const ll N = 500009;
ll tr[N];
ll n, m;
inline ll lowbit (ll x) {
	return x & (-x);
}
inline void add (ll pos, ll v) {
	while (pos <= n) {
		tr[pos] += v;
		pos += lowbit (pos);
	}
}
inline void do_add (ll k, ll y, ll x) { //差分思想修改
	add (x, k);
	add (y + 1, -k);
}
inline ll do_qu (ll pos) {
	ll res = 0;
	while (pos > 0) {
		res += tr[pos];
		pos -= lowbit (pos);
	}
	return res;
}
int main() {
	n = read(), m = read();
	for (int i = 1; i <= n; i++)
		do_add (read(), i, i);
	for (int i = 1; i <= m; i++) {
		ll op = read();
		if (op == 1)do_add (read(), read(), read()); //函数传参从右到左
		else write (do_qu (read()), 1);
	}
	return 0;
}
```

---

## 作者：Debug618 (赞：5)

你可以把此题看做[【模版】树状数组 1](https://www.luogu.com.cn/problem/P3374) 的升级版，所以我建议你先过了[【模版】树状数组 1](https://www.luogu.com.cn/problem/P3374) 再来尝试写这道题。

## 正文
在 [【模版】树状数组 1](https://www.luogu.com.cn/problem/P3374) 里，我们知道树状数组可以在 $O(n\log n)$ 的时间复杂度下**单点修改，区间查询**。而现在，题目要求的是**区间修改，单点查询**。

如果我们直接暴力，时间复杂度 $O(MN)$，显然 TLE。

我们可以尝试简化问题，如果限制询问一定在修改之后，就可以使用差分。而如果询问可能插在修改中间，是不是可以在树状数组上差分呢？仔细思考，差分同样是单点修改，通过求差分数组一个区间的和来求得原数组一个数的值，刚好满足普通树状数组的功能！

忘了差分怎么做的可以看下面这段，如果还记得就快点 AC 这道题吧！（参考代码在最后~~不是让你 ctj！！！~~）

## 差分

回顾差分，我们知道一个差分数组 $d$ 对应原数组 $a$ 的关系是 $d_i = a_i - a_{i-1}$，那么假设我们将区间 $[l,r]$ 都加上 $x$，即 $a_l, a_{l+1},\dots,a_r$ 都加上 $x$，对应到差分数组就是：
$$
\begin{aligned}
  d_l &= \left(a_l + x\right) - a_{l-1} = a_l - a_{l-1} + x\\
  d_{l+1} &= \left(a_{l+1} + x\right) - \left(a_l + x\right) = a_{l+1} - a_l\\
  d_{l+2} &= \left(a_{l+2} + x\right) - \left(a_{l+1} + x\right) = a_{l+2} - a_{l+1}\\
\end{aligned}\\
\vdots\\
\begin{aligned}
  d_r &= (a_r + x) - (a_{r-1} + x) = a_r - a_{r-1}\\
  d_{r+1} &= a_{r+1} - (a_{r} + x) = a_{r+1} - a_{r} - x
\end{aligned}
$$
发现了吗？在差分数组上，对于 $[l+1,r]$ 的部分，所有操作都抵消了，只剩下 $d_l$ 需要加上 $x$ 以及 $d_{r+1}$ 需要减去 $x$。

如何从差分数组求每个数呢？肥肠简单，只需要从头加到这个数的下标就好了（假设要求 $a_k$ 的值），即：
$$
\begin{aligned}
  d_1 + d_2 + \dots + d_k &= (a_1 - a_0) + (a_2 - a_1) + \dots + (a_k - a_{k-1})\\
  &= a_k - a_0\\
  &= a_k
\end{aligned}
$$
（由于我们不需要对 $a_0$ 进行操作，将其初始化为 $0$ 即可）

而树状数组实现的区间求和正好是从下标 $1$ 开始的~~连减法都省了~~。

剩下的就很简单了，直接套用[【模版】树状数组 1](https://www.luogu.com.cn/problem/P3374) 的代码，详细实现见下。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 

const int N = 5e5 + 5; 

int a, c[N], n, m; 

int lowbit (int x) {
	return x & -x; 
}

void update (int i, int x) {
	for (; i <= n; i += lowbit(i)) {
		c[i] += x; 
	}
}

int sum (int x) {
	int ans = 0; 
	while (x != 0) {
		ans += c[x]; 
		x -= lowbit(x); 
	}
	return ans; 
}

int main () {
	
	scanf("%d%d", &n, &m); 
	int last = 0;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a); 
		update(i, a - last); 
		last = a; 
	}
	int op, x, y, k; 
	for (int i = 0; i < m; i++) {
		scanf("%d", &op); 
		if (op == 1) {
            scanf("%d%d%d", &x, &y, &k);
            update(y + 1, -k); // 差分思想
            update(x, k);
        } else {
            scanf("%d", &x);
            printf("%d\n", sum(x)); // 求差分数组 [1,x] 的和
        }
	}
	return 0; 
}
```

---

## 作者：easy42 (赞：4)

### 目录

- 前言
- 算法介绍
- 正确性证明
- 代码实现
- 后记

### 前言

本篇由 easy42 编写。

这是一篇数据结构**分块**题解。

### 算法介绍

分块，是一种暴力数据结构。它能以比线段树差，比暴力好的复杂度解决问题，时间复杂度通常是 $O(m \sqrt n)$ 的，适合解决 $n=m=10^5$ 的问题。

分块与线段树的不同之处是：分块是把序列分为一个个小块，而线段树则把序列建成一颗二叉树，每个节点存储区间值。

线段树一般只能解决具有合并性的问题，然而分块可以更灵活，更暴力的解决问题。

而且分块编码相对较为简单，在考场上可以发挥优势。

### 正确性证明

分块的思想可以概述为：整块统一处理，散块暴力统计。

分块的步骤是这样的：先把序列分成长度为 $\lfloor \sqrt n\rfloor$ 个块，为什么分这个值后面会说。

如果 $\sqrt n$ 的值是一个整数，则一共有刚好 $\sqrt n$ 个块。

如果 $\sqrt n$ 的值不是一个整数，后面会多出一个散块。

对于每个块，维护它的修改标记，以及序列中每个数的值。

这题分为两个操作：

1. 区间修改
2. 单点查询

在区间修改时，区间 $[l,r]$ 可能会跨越多个块，如果是整块，对它的修改标记加上 $k$，散块则对原数组的元素加上 $k$。

在单点查询时，直接把原数组的元素加上这个块的修改标记就好了。

分析一下，我们既要遍历所有块的元素，也要遍历序列中所有的块，此时的时间复杂度为 $O(m(\frac{n}{t}+t))$，其中 $t$ 为块的长度。当块长度取到 $\sqrt n$ 时，有较好的时间复杂度 $O(m \sqrt n)$。

### 代码实现

#### 初始化

首先，要确定把块的长度 $block$ 设为 $\lfloor \sqrt n \rfloor$。

```cpp
int block=sqrt(n);//块长
```

块的个数 $t$。

```cpp
int t=n/block;//块的个数
if(n%block) t++;//增加散块
```

需要维护每个块的开头与结尾。

```cpp
for(int i=1;i<=t;i++){
    head[i]=(i-1)*block+1;//是上个块的开头加一
    tail[i]=i*block;
}
```

请注意，最后一个块的末尾不能超过 $n$。

```cpp
tail[t]=n;
```

以及使用数组 $cnt$ 确定每个块所归属的位置。

```cpp
for(int i=1;i<=n;i++){
    cnt[i]=(i-1)/block+1;
}
```

初始化完成。

#### 区间修改

如果在同一块内，暴力修改即可。

```cpp
if(cnt[x]==cnt[y]){
    for(int i=x;i<=y;i++){
        a[i]+=k;
    }
}
```

如果不在同一块内，先处理整块，再处理散块。

如果是整块，直接修改标记。

```cpp
for(int i=cnt[x]+1;i<=cnt[y]-1;i++){
    add[i]+=k;
}
```

散块暴力更新：

```cpp
for(int i=x;i<=tail[cnt[x]];i++){
    a[i]+=k;
}
for(int i=head[cnt[y]];i<=y;i++){
    a[i]+=k;
}
```

#### 单点查询

直接把当前值加上块的修改标记就行了。

```cpp
cout<<a[x]+add[cnt[x]]<<endl;
```

总代码：

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
int n,m,add[1000005],a[1000005],head[1000005],tail[1000005],cnt[1000005];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int block=sqrt(n);
	int t=n/block;
	if(n%block) t++;
	for(int i=1;i<=t;i++){
		head[i]=(i-1)*block+1;
		tail[i]=i*block;
	}
	tail[t]=n;
	for(int i=1;i<=n;i++){
		cnt[i]=(i-1)/block+1;
	}
	while(m--){
		int op;
		cin>>op;
		if(op==1){
			int x,y,k;
			cin>>x>>y>>k;
			if(cnt[x]==cnt[y]){
				for(int i=x;i<=y;i++){
					a[i]+=k;
				}
			}
			else{
				for(int i=cnt[x]+1;i<=cnt[y]-1;i++){
					add[i]+=k;
				}
				for(int i=x;i<=tail[cnt[x]];i++){
					a[i]+=k;
				}
				for(int i=head[cnt[y]];i<=y;i++){
					a[i]+=k;
				}			
			}
		}
		else{
			int x;
			cin>>x;
			cout<<a[x]+add[cnt[x]]<<endl;
        }
	}
	return 0;
}
```

### 后记

点个赞吧！

---

## 作者：穼柗° (赞：3)

树状数组是单点修改、区间查询，而这题是区间修改、单点查询，相当于动态的差分，维护差分数组就可以单点修改、区间查询。

设这个序列是 $a$，它的长度是 $n$，它的差分数组是 $d$，即对于所有整数 $j\in[2,n]$ 都有 $d_j=a_j-a_{j-1}$，特别地 $d_1=a_1$，显然 $a_x=\sum\limits_{i=1}^x d_i$。

当执行操作 $1$，区间 $[x,y]$ 内每个数都加上 $k$ 的时候，$d_x$ 加上 $k$，$d_{y+1}$ 减去 $k$（当 $y=n$ 时不减）。

当执行操作 $2$，要输出 $a_x$ 的值时，输出 $\sum\limits_{i=1}^n d_i$ 就好了。

$d$ 用树状数组维护，时间复杂度 $O(M\log N)$，空间复杂度 $O(N)$，不会爆。

代码如下。
```cpp
#include <iostream>
#define int long long
using namespace std;
int n,q,c[1000001];
void upd(int i,const int x) {
	for(;i<=n;i+=i&-i) c[i]+=x;
}
int query(int i) {
	int ret=0;
	for(;i;i-=i&-i) ret+=c[i];
	return ret;
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false),
	cout.tie(nullptr);
	cin>>n>>q;
	for(int a,i=1;i<=n;i++) {
		cin>>a;
		upd(i,a);
		upd(i+1,-a);
	}
	for(int op,l,r,x;q--;) {
		cin>>op;
		if(op==1) {
			cin>>l>>r>>x;
			upd(l,x);
			upd(r+1,-x);
		} else {
			cin>>x;
			cout<<query(x)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：a202401006 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3368)
## 解析
### 题目大意
给你一些数，设存进数组 $num$ 中，接下来给你一些数据，每个数据有两种情况：

1. 如果这一组数据输入的第一个数为一，那么后面还会有三个数：设为 $ls2$，$ls3$，$ls4$ 这几个数，表示将 $num$ 数组中的第 $ls2$ 到第 $ls3$ 这些位置加上 $ls4$。
2. 如果这一组数据输入的第一个数为二，那么后面会有一个数，我们设为 $ls2$ 这个数，表示输出 $num[ls2]$ 这个数。

### 考察知识
明显这一题是考察树状数组二啦。为什么用它？首先大家大概可以想到去暴力，结果可想而知，听取超时声一片，时间复杂度真的是太感人。

那该怎么办？当然是用树状数组啦！下面讲一讲它。

#### 讲讲树状数组
**树状数组二简单介绍**

 _什么是树状数组？_ 

> 简单地说，树状数组是一个能够在 $O(\operatorname{log}n)$ 的时间按复杂度内完成查询、单点或区间的具有差分性质操作的数组。

 _来讲讲怎么用树状数组二。_

我们先了解一个函数：$\operatorname{lowbit}$ 函数。
> 树状数组使用 lowbit 函数确定区间长度的核心原因在于其利用二进制分解的特性高效管理区间，从而实现快速的前缀和查询与动态更新，我们每一段的区间长度由 lowbit 决定，可以大大优化时间复杂度，从而实现更优的时间内做更多的事情。

![](https://cdn.luogu.com.cn/upload/image_hosting/kq4jsiho.png)

在树状数组一中，设 $n$ 表示 $a$ 的大小，单点修改 $a[x]$ 的过程如下：
1. 初始化 $x'=x$。
2. 修改 $c[x']$。
3. 更新 $x'$ 为 $x'+\operatorname{lowbit}(x)$，如果 $x'>n$ 说明已经跳到尽头了，终止循环；否则回到第二步。

但是树状数组二是修改区间，怎么办呢？

暴力明显是做不了的。我们换一个思路：将数组 $C[i]$ 表示区间 $[x-\operatorname{lowbit}(x)+1...x]$ 进行多次修改后的修改总值，$a[i]$ 表示初始数组。所以便会发现：

-  $C[2]$ 管辖 $A[1...2]$ 的修改值。
-  $C[4]$ 管辖 $A[1...4]$ 的修改值。
-  $C[6]$ 与 $C[2]$ 同理，管辖 $A[5...6]$ 的修改值。
-  $C[8]$ 管辖 $A[1...8]$ 的修改值。
-  其余的 $C[i]$ 管辖 $A[i]$ 的修改值。

所以，只需要查询 $A[x]$ 的修改值，再加上其本身即可。

现在要实现区间求和，怎么办呢？

树状数组是一个具有差分性的数组，所以对于区间加，我们只需要对于区间 $[l...r]$ 加上 $k$，我们只需要像前缀和一样，在从 l 向上走的所有节点都加上 $k$，从 $r+1$ 向上走的所有节点都加上 $−k$ 即可。
> 差分
> 
> 一种简单的结构，可以实现 $O(1)$ 区间修改和 $O(N)$ 单点查询。
> 
> 为啥用差分？利用差分，可以把区间问题转化为端点问题。如果区间内每个元素都修改，复杂度为 $O(n)$；用差分转化为只记录两个端点后，复杂度降低到 $O(1)$。这就是差分的重要作用。

**树状数组二时间复杂度**

树状数组二（运用差分）的时间复杂度为 $O(M\operatorname{log}N)$。


## 代码
套个模板就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int Iamyuantc=0x9fffff;
int num[Iamyuantc],chafen[Iamyuantc],n,m;
int lowbit(int x)
{
	return x&-x;
}

void add(int k,int x)
{
	while(k<=n)
	{
		chafen[k]+=x;
		k+=lowbit(k);
	}
}

int sum(int x)
{
	int ans=0;
	while(x)
	{
		ans+=chafen[x];
		x-=lowbit(x);
	}
	return ans;
}

signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>num[i];
	}
	for(int i=1;i<=m;i++)
	{
		int ls1;
		cin>>ls1;
		if(ls1==1)
		{
			int ls2,ls3,ls4;
			cin>>ls2>>ls3>>ls4;
			add(ls2,ls4);
			add(ls3+1,-ls4);
		}
		else
		{
			int ls2;
			cin>>ls2;
			cout<<num[ls2]+sum(ls2)<<endl;
		}
	}
}
```

---

## 作者：Restart_Justin (赞：2)

本文默认读者已经通过 [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)。
## 暴力
学会了树状数组，一眼就可以暴力。

$1$ 操作可以遍历每个 $i(x \leq i \leq y)$，用树状数组给 $a_i$ 加上 $k$。

$2$ 操作直接查询 $x$ 至 $x$ 的区间和。（话说这样是不是多此一举啊……）
## 正解
可以利用差分思想。

树状数组不一定要维护原数组，也可以维护差分数组（下文用 $d$ 表示）。

这样就好办了。

### 转化题意
$1$ 操作就是给 $d_x$ 加 $k$，给 $d_{y + 1}$ 减去 $k$。

$2$ 操作就是查询 $\sum_{1 \leq i \leq x} d_i$。

树状数组可以维护。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5 * 1e5 + 5;
int n, m, t[maxn];
int lowbit(int x) {
    return x & -x;
}
void update(int x, int k) {
    for (int i = x; i <= n; i += lowbit(i))
        t[i] += k;
}
int query(int x) {
    int res = 0;
    for (int i = x; i; i -= lowbit(i))
        res += t[i];
    return res;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    int tmp = 0;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        update(i, x - tmp);
        tmp = x;
    }
    for (int i = 1; i <= m; i++) {
        int op;
        cin >> op;
        if (op == 1) {
            int x, y, k;
            cin >> x >> y >> k;
            update(x, k);
            update(y + 1, -k);
        } else {
            int x;
            cin >> x;
            cout << query(x) << "\n";
        }
    }
}
```

---

## 作者：XXh0919 (赞：2)

~~又来水咕值啦！~~

注：本文给出的两篇代码因写的时间相距甚远，故码风会有很大差异。

### 方法一：树状数组

我们都知道，普通的树状数组只支持单点修改，但本题要求区间修改，我们该如何用树状数组解决呢？其实我们容易想到的将区间修改变为单点修改的算法有两个，一个是前缀和，另一个是差分。但题目并没有说查询区间和，所以考虑差分。

对于修改操作，我们只需要每一次在查到根节点之前经过的所有点（$l,l+\text{lowbit}(l),...$）上加上这个修改的值。由于差分的性质，$r+1,r+1+\text{lowbit}(r+1)$ 等点的地方都要减去这个值。

至于查询，我们知道差分数组做一遍前缀和后就是原数组，所以只需要查询到目标位置的前缀和就行了。

时间复杂度 $O(n\log n)$。

### 树状数组 Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
#define pi pair<int,int>
#define mkp(a,b) make_pair((a),(b))
#define IOS ios::sync_with_stdio(0)
using namespace std;
const int N=3e6+15;

int n,m;
int a[N];
int t[N];

int lowbit(int x){
	return x&-x;
}

void update(int x,int y){
	for(;x<=n;x+=lowbit(x)){
		t[x]+=y;
	}
}

int sum(int x){
	int ans=0;
	for(;x;x-=lowbit(x)){
		ans+=t[x];
	}
	return ans;
}

signed main(){
	IOS;
	cin>>n>>m;
	rep(i,1,n){
		cin>>a[i];
	}
	rep(i,1,m){
		int op,x,y,z;
		cin>>op>>x;
		if(op==1){
			cin>>y>>z;
			update(x,z);
			update(y+1,-z);
		}
		else{
			cout<<a[x]+sum(x)<<endl;
		}
	}
	return 0;
} 
```

### 方法二：分块

如果你说你不想用差分，而是想更直接地求出答案，那这时候我们又该怎么办呢？那简单，分块大法好啊！

不管是修改还是查询，我们始终遵循一个原则：散块暴力，整块假装修改，即打延迟标记。最后求答案时只需要将那个位置的值加上相应的延迟标记就行了。

时间复杂度 $O(n\sqrt n)$。

### 分块 Code


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 15;

int n, m, t;
int a[N];
int l[N], r[N], pos[N], add[N];

void init () {
	t = sqrt (n);
	for (int i = 1; i <= n; ++ i) {
		l[i] = r[i - 1] + 1;
		r[i] = i * t;
	}
	
	r[t] = n;
	
	for (int i = 1; i <= t; ++ i) {
		for (int j = l[i]; j <= r[i]; ++ j) {
			pos[j] = i;
		}
	}
}

void update (int ll, int rr, int x) {
	int p = pos[ll], q = pos[rr];
	if (p == q) {
		for (int i = ll; i <= rr; ++ i) {
			a[i] += x;
		}
		return ;
	}
	for (int i = ll; i <= r[p]; ++ i) a[i] += x;
	for (int i = l[q]; i <= rr; ++ i) a[i] += x;
	for (int i = p + 1; i <= q - 1; ++ i) add[i] += x;
	return ;
}

int main () {
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; ++ i) scanf ("%d", &a[i]);
	init ();
	while (m --) {
		int op, l;
		scanf ("%d%d", &op, &l);
		if (op == 1) {
			int r, x;
			scanf ("%d%d", &r, &x);
			update (l, r, x);
		} else {
			printf ("%d\n", a[l] + add[pos[l]]);
		}
	}
	return 0;
} 
```

---

## 作者：HD131399Ab (赞：2)

# P3368 【模板】树状数组 2
## 前置知识
树状数组的单点修改和区间查询。
## 题意

如题，已知一个数列，你需要进行下面两种操作：

1. 区间修改：将区间 $[x,y]$ 内每个数加上 $k$；

2. 单点查询。

## 思路

树状数组的原始功能是“单点修改+区间查询”，如何拓展为区间修改？  
我们只需要一个差分数组，就能把单点修改用来处理区间修改问题，实现“区间修改＋单点查询”。

### 为什么用差分？

回顾差分数组的定义： $ D_k=a_k-a_{k-1} $，及原数组相邻元素的差。  
由定义可得： $ a_k= \sum_{i = 1}^{k} D_i $。这个公式体现的 $ a $ 与 $ D $之间的关系，及**差分是前缀和的逆运算**，它把求 $a_k$  转化为求 $D$ 的前缀和，正适合用树状数组来求解。
#### tips:
利用差分，可以把区间问题转化为端点问题。如果区间内每个元素都修改，复杂度为 $ O(n) $；用差分转化为只记录两个端点后，复杂度降低到 $O(1)$。这就是差分的重要作用。
### 如何用树状数组处理区间修改？

对于区间 $[L,R]$ 的修改问题，对 $D$ 做以下操作：
1. 把 $D_L$ 加上 $d$；
2. 把 $D_{R+1}$ 减去 $k$。  

然后用树状数组 $sum()$ 函数求前缀和 $sum_x=D_1+D_2+D_3+\cdots+D_x$，有：
1. $1 \le x<L$，前缀和 $sum_x$ 不变；
2.  $L \le x \le R$，前缀和 $sum_x$ 增加 $k$；
3.   $1 < x \le L$，前缀和 $sum_x$ 不变，因为被 $D_{R+1}$ 减去的 $d$ 抵消了；

$sum_x$ 的值是差分数组 $D$ 的前缀和，等于 $a_x$。这样，就用树状数组实现了高效的区间修改。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 500005;
#define lowbit(x)  (x&(-x))
int tree[N];
void update(int x, int d) {   //单点修改
	while (x <= N) {
		tree[x] += d;
		x += lowbit(x);
	}
}
int sum(int x) {     //查询前缀和
	int ans = 0;
	while (x > 0) {
		ans += tree[x];
		x -= lowbit(x);
	}
	return ans;
}
void Interval_update(int L, int R, int k) { //区间修改
	update(L, k);
	update(R + 1, -1 * k);
}
int main() {
	int n, m, k;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) { //输入
		scanf("%d", &k);
		Interval_update(i, i, k);
	}
	int i;
	int L, R;
	while (m--) {
		scanf("%d", &i);
		if (i == 1) {  //区间修改
			scanf("%d%d%d", &L, &R, &k);
			Interval_update(L, R, k);
		} else {       //单点查询
			scanf("%d", &k);
			printf("%d\n", sum(k)); //把sum(k)看成a[k]
		}
	}
	return 0;
}
```
~蒟蒻第一篇题解，管理大大求过QwQ~

---

## 作者：Chase12345 (赞：1)

# 引入
这是树状数组 2 的题目，建议先完成树状数组 1 之后再来完成这道题。
# 做法
这道题其实和树状数组 1 类似，不过要差分。首先我们设 $d_i=a_i-a_{i-1}$，此时我们其实可以得到：
$$
a_i=\sum_{j=1}^{i} d_j
$$
欸，这个时候是不是差分起效果了呢？好消息还真是。因为这道题并不要求区间查询，单点查询这样就可以了。不过怎么修改呢？我们看回我们学过的差分。对所有的 $i \in [l,r]$ 的 $a_i$ 全部加上 $k$，相当于将 $d_l$ 加上 $k$，$d_{r+1}$ 减去 $k$，那不就行了吗？
# 正确性证明和复杂度分析
见[我写的文章](https://www.luogu.com.cn/article/13oci7bn)
# 代码
原来的建树写挂了，这里换了一种建树方式，总的复杂度仍为 $O(n \log n)$。可以通过。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
long long n, a[N], c[N], s[N];

int lowbit(int x) {
    return x & -x;
}

void add(int k, int x) {
    for (int i = k; i <= n; i += lowbit(i))
        c[i] += x;
}

int query(int k) {
    int sum = 0;
    for (int i = k; i; i -= lowbit(i))
        sum += c[i];
    return sum;
}

void build() {
    for (int i = 1; i <= n; i++) {
        add(i, a[i]);
        add(i + 1, -a[i]);
    }
}

int main() {
    int m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    build();
    while (m--) {
        int op;
        cin >> op;
        if (op == 1) {
            int x, y, k;
            cin >> x >> y >> k;
            add(x, k);
            add(y + 1, -k);
        } else {
            int x;
            cin >> x;
            cout << query(x) << '\n';
        }
	}
    return 0;
}
```

---

## 作者：ssy666666 (赞：0)

# 【模板】树状数组 2

首先，本文默认读者已经会做[树状数组 $1$](https://www.luogu.com.cn/problem/P3374)，因此在此不做展开，不会的读者可以参考我的[题解](https://www.luogu.com.cn/article/h5hs3f54)。

下面进入正题：

## 算法介绍

首先，在树状数组 $1$ 中，我们已经学会了树状数组的单点修改，区间查询操作。但本题要求进行区间修改，区间查询。如果仍然使用单点操作，时间复杂度会高达 $O(nm \log n)$，所以会直接爆炸。

所以我们该如何解决这样的问题？

联想到区间查询操作：

在查询操作中，我们进行两次查询 $(1,r)$ 和 $(1,l-1)$，再将两次操作结果相减。

因此，我们构想出一种情况：在进行区间更改时，也通过更改 $(1,r)$ 和 $(1,l-1)$ 来实现，$(1,r)$ 加上 $x$，$(1,l-1)$ 减去 $x$。

回想查询操作的实现方式：我们每次循环枚举结点，每次枚举上一次的结点减去 `lowbit`。这样就可以将 $(1,i)$ 不重复，不遗漏计算完。

而我们要做的区间修改操作要求也同样是将 $(1,i)$ 不重复，不遗漏，每个数都加上 $x$。因此，我们可以使用同样的方法，循环枚举结点，每次枚举上一次的结点减去 `lowbit`。

**code**
```cpp
void change(int q,int k)
{
	int t=q;
	while(t>0)
	{
		tr[t]+=k;
		t-=lowbit(t);
	}
	return;
}
```

## 正确性证明
又因为原来区间查询的操作时间复杂度为 $O(\log n)$，同理，区间修改的时间复杂度也同样是 $O(\log n)$，所以总时间复杂度为 $O(m \log n)$，可以接受。

## 代码实现

**AC code**
```cpp
#include<bits/stdc++.h>
using namespace std;

int num[500005];
int tr[500005];
int n,m;

int lowbit(int r)
{
	return r&(-r);
}

void change(int q,int k)
{
	int t=q;
	while(t>0)
	{
		tr[t]+=k;
		t-=lowbit(t);
	}
	return;
}

int get_num(int r)
{
	int cnt=num[r];
	int p=r;
	while(p<=n)
	{
		cnt+=tr[p];
		p+=lowbit(p);
	}
	return cnt;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&num[i]);
	}
	
	int t,p,q,k;
	
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&t);
		if(t==1)
		{
			scanf("%d",&p);
			scanf("%d",&q);
			scanf("%d",&k);
			
			change(q,k);
			change(p-1,-k);
		}
		else
		{
			scanf("%d",&p);
			printf("%d\n",get_num(p));
		}
	}
	
	return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 前置知识

**如果你不会这个部分，请先查看我这个部分的题解，本篇题解默认你的实力是刚刚掌握前置知识。**

单点修改、区间查询的做法：

[树状数组1](/problem/P3374)和[题解](/article/hxcl9u2b)。

## 题目分析

鉴于两者非常类似，我们考虑使用树状数组。

考虑一下如何转化。

不难想到多次修改可以差分，区间修改也可以。

对于 $[l,r]$ 的修改可以改为对 $l,r+1$ 进行单点修改。

但是此时查询从 $x$ 变为 $[1,x]$。

这样明显是树状数组可以维护的，时间复杂度 $O(q\log n)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
//#define int long long 
#define lowbit(x) ((x)&(-(x)))
using namespace std;
const int N=500001;
int n,m,a[N];
void add(int x,int k){
    while(x<=n)
        a[x]+=k,x+=lowbit(x);
    return;
}
int qry(int k){
    int ans=0;
    for(;k;k-=lowbit(k))
        ans+=a[k];
    return ans;
}//单点查询（因为差分要前缀和）
signed main(){
    cin>>n>>m;
    for(int i=1,k;i<=n;i++){
        cin>>k;
        add(i,k),add(i+1,-k);//差分修改
    }
    for(int op,x,y,k;m;--m){
        cin>>op>>x;
        if(op==1){
            cin>>y>>k;
            add(x,k),add(y+1,-k);//差分修改
        }
        else
            cout<<qry(x)<<'\n';
    }
    return 0;
}
```

---

## 作者：lw393 (赞：0)

**介绍 fenwick tree(树状数组)**

**算法介绍**

树状数组是一个快速解决前缀和的数据结构。每个节点存储的值如下图：

![](https://oi-wiki.org/ds/images/fenwick.svg)

$tree_1$ 存储的是 $a_1$；

$tree_2$ 存储的是 $a_1+a_2$；

$tree_3$ 存储的是 $a_3$；

$tree_4$ 存储的是 $a_1+a_2+a_3+a_4$。

$\cdots$

本质上，树状数组每个存储的就是以这个编号 $i$ 为右端点，长度为 $\operatorname{lowbit}(i)$ 的一段区间的和。这里 $\operatorname{lowbit}(i)$（其中$\operatorname{lowbit}(i)$ 定义为非负整数 $i$ 在二进制表示下“最低位的 $1$ 及其后面的所有的 $0$”的二进制构成的数值。）

在 c++ 中，我们可以通过如下代码快速求 $$\operatorname{lowbit}(i)$$：

```cpp
int lowbit(int x) { return x & (-x); }
```

**正确性证明**

我们需要使用两个函数：add 与 sum。

先考虑 sum，这个函数是处理区间前缀和的。

我们考虑如何将 $1$ 到 $pos$ 的和拆分成多个区间。

这里我们举个例子，$pos=7$。此时 $\sum_{i=1}^{pos}a_i = tree_7 + tree_6 + tree_4$。

不难发现查询的每一步都跳了 $\operatorname{lowbit}(i)$ 步，从而在 $O(\log n)$ 的次数内，完成了对答案的统计。

下面是 c++ 实例：

```cpp
int sum(int x){
  int res = 0;
  for(int i = res; i > 0; i -= lowbit(i)){
    res += tree[i];
  }
  return res;
}
```

再而思考一下，如果我们进行了对一个数的修改，我们怎么高效地利用树状数组的性质，对其进行 $O(\log n)$ 次操作，维护树状数组（模仿 sum 函数的步骤）。

我们注意到树状数组的定义，则不难发现 $a_i$ 对 $tree_i, tree_{i+\operatorname{lowbit}(i)}\cdots$ 都有贡献。

所以我们就通过上述性质写出 add 函数：
```cpp
void add(int x, int v){
  for(int i = x; i <= n; i += lowbit(i)){
    tree[i] += v;
  }
}
```

我们就得到了树状数组的完整代码（已封装）：

```cpp
int lowbit(int x) { return x & (-x); }
struct fenwick{
	int tree[N], n;
	void add(int k, int x) { for(int i = k; i <= n; i += lowbit(i)) tree[i] += x; }
	int sum(int k) { int ans = 0; for(int i = k; i > 0; i -= lowbit(i)) ans += tree[i]; return ans; }
}t1;
```

再说本题，如何做区间修改 + 单点查询。

我们刚刚得到的树状数组仅仅能满足单点修改与区间查询。而不能做到区间修改与单点查询。

那么我们换个思路，做一次差分如何呢？

对于差分数组而言 $\sum_{i=1}^{pos} d_i = a_{pos}$。

我们对于这样一个差分数组上去维护树状数组显然是可行的。

对于区间 $[l,r]$ 统一加上 $d$，等价于在差分数组的 $l$ 位置上加 $d$, $r+1$ 位置上加 $-d$。

而查询 $pos$ 这个位置呢，就是统计差分数组的 $1$ 到 $pos$ 这一段的和。

**代码实现**（此处因为是很早写的，没封装）：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 5e5 + 5;

int n, q;
int a[N], d[N], tree[N];

int lowbit(int x){
    return x & (-x);
}

void add(int k, int v){
    for(int i = k; i <= n; i += lowbit(i)){
        tree[i] += v;
    }
}

int sum(int k){
    int res = 0;
    for(int i = k; i > 0; i -= lowbit(i)){
        res += tree[i];
    }
    return res;
}

void solve(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> q;
    for(int i = 1; i <= n; i++) cin >> a[i], d[i] = a[i] - a[i - 1], add(i, d[i]);
    for(int i = 1; i <= q; i++){
        int op;
        cin >> op;
        if(op == 1){
            int l, r, v;
            cin >> l >> r >> v;
            add(l, v);
            add(r + 1, -v);
        }else{
            int x;
            cin >> x;
            cout << sum(x) << '\n';
        }
    }
}

int main(){
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

---

## 作者：GZXUEXUE (赞：0)

### 算法介绍

对于本题来说，我们考虑用树状数组维护差分数组。  
本篇题解将介绍树状数组这种数据结构。

树状数组用数组 $\operatorname{Tree}$（为叙述方便，在下文中简写为 $t$）维护二进制的索引结构。  
每个节点 $t_i$ 存储区间 $[i - \operatorname{lowbit}(i) + 1,i]$ 的和，其中 $\operatorname{lowbit}(x) = x \operatorname{and} -x$，用于确定区间长度。  
- 在单点更新时，我们可以沿 $i \gets i + \operatorname{lowbit}(i)$ 这一操作向上修改父节点；
- 在前缀和查询时，我们可以沿 $i \gets i - \operatorname{lowbit}(i)$ 这一操作累加子树值。

[树状数组就是删除掉一些线段树中没有用的节点。](https://www.bilibili.com/video/BV1ce411u7qP/)

对于本题，树状数组（维护差分数组）的时间复杂度如下：
- 区间修改：$O(\log(LR))$，其中要差分的区间为 $[L,R]$；
- 单点查询：$O(\log X)$，其中要查询的点为 $X$。

~~广告：此算法在[该古籍](https://www.luogu.me/article/hjqcqwbb)中亦有记载！~~

### 正确性证明

#### 从结构上来说

设二进制数 $i = 2^{k_1} + 2^{k_2} + \dots + 2^{k_m}$（$k_1 > k_2 > \cdots > k_m$），则：  
- 每个 $t_i$ 存储区间 $[i - 2^{k_m} + 1, i]$ 的和；
- 前缀和为 $\sum\limits_{j=1}^i a_j = \sum t_{2^{k_1}} + t_{2^{k_1} + 2^{k_2}} + \dots + t_i$。

#### 从操作时来说

- 更新时  
  修改 $t_x$ 时，我们通过 $i \gets i + \operatorname{lowbit}(i)$ 遍历所有覆盖 $x$ 的区间节点，更新其值。
- 查询时  
  求 $\sum\limits_{j=1}^x a_j$ 时，我们通过 $i \gets i - \operatorname{lowbit}(i)$ 遍历所有包含 $x$ 的区间节点。

#### 归纳

当 $i=1$ 时，$t_1 = a_1$，正确。  
假设所有 $j < i$ 的节点正确维护区间和，则 $i$ 的更新路径必然覆盖其影响的所有父区间，查询路径精确分割二进制位。

### 代码实现

```cpp
# include <iostream>
using namespace std;
const int MAXN = 5e5 + 5;
int n,m,a[MAXN],Tree[MAXN];
int lowbit(int x){
    return x & -x;
}void _add(int end,int num){
    while (end <= n){
        Tree[end] += num;
        end += lowbit(end);
    }
}void add(int l,int r,int num){
	_add(l,num); _add(r + 1,-num);
}int query(int x){
    int sum = 0,org = x;
    while (x != 0){
        sum += Tree[x];
        x -= lowbit(x);
    }return a[org] + sum;
}int main(){
	cin >> n >> m;
	for (int i = 1;i <= n;i++) cin >> a[i];
	while (m--){
	    int op,x; cin >> op >> x;
	    if (op == 1){
	        int y,k; cin >> y >> k;
	        add(x,y,k);
	    }else cout << query(x) << endl;
	}return 0;
}
```

---


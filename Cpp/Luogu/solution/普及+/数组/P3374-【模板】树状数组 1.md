# 【模板】树状数组 1

## 题目描述

如题，已知一个数列，你需要进行下面两种操作：

- 将某一个数加上 $x$；

- 求出某区间每一个数的和。

## 说明/提示

【数据范围】

对于 $30\%$ 的数据，$1 \le n \le 8$，$1\le m \le 10$；   
对于 $70\%$ 的数据，$1\le n,m \le 10^4$；   
对于 $100\%$ 的数据，$1\le n,m \le 5\times 10^5$。

数据保证对于任意时刻，$a$ 的任意子区间（包括长度为 $1$ 和 $n$ 的子区间）和均在 $[-2^{31}, 2^{31})$ 范围内。


样例说明：

 ![](https://cdn.luogu.com.cn/upload/pic/2256.png) 

故输出结果 $14$ 和 $16$。

## 样例 #1

### 输入

```
5 5
1 5 4 2 3
1 1 3
2 2 5
1 3 -1
1 4 2
2 1 4```

### 输出

```
14
16```

# 题解

## 作者：皎月半洒花 (赞：764)

# 一、浅析数据结构之用处和高级数据结构之特性

数据结构者，谓之**数据之关系**。单论数据特性，也不过是数据之间的存储方式罢。但要说更深层次之作用，是**运用其存储之特性，建立数学之模型，更方便地才处理数据尔**。

以上是鲁迅同志说的（鲁迅：$exm$？？？），其实一切的数据结构不过就是一种**用于处理数据的、成熟的、合理的结构封装**。较低级的数据结构不会支持什么操作，仅是维护自身的存储秩序；而高级数据结构则可以支持许多操作——其实也不过是维护自身数据的秩序而已，只不过在维护其自身秩序的同时，由于其本身结构复杂且特点鲜明，所以会产生许多很优化的算法。
（鲁迅：看在你讲得这么好饶了你！）

而今天我们主要介绍有关 RMQ、RSQ 问题的、较为基础的高级数据结构。

# 二、先来介绍分块思想吧

## （一）基本性质与证明

其实从本质上来讲，分快更像是一种思想。分块，顾名思义，就是将一个区间分成几块，然后对于每个询问，整合一个或者多个甚至全部区间的信息。但是在这种整合不是随便整合，必须要有技巧、有目的地整合，才会减小时间复杂度。

先看一道例题：

现在你有一个长度为 $n$ 的序列，有 $m$ 个操作：

1.修改某位置的元素的值。

2.将一段区间的元素加上或减去一个值。

3.求一段区间的元素的最大值。

$n,m\leq 50000$。

让我们考虑分块:
首先第一步，进行区间划分，在这一步我们考虑将整个序列划分成 $\sqrt{n}$ 块，这可以使得其总查询时间最快

证明：

对于搜查整个序列中的一段区间，设这段区间内的完整分块块数是 $C$ 块，每一段均匀的分块都 $S$ 个元素，那么这一段区间的最复杂形式为:有 $C$ 个完整区间，并且闭区间 [$l$,$r$] 还在两端包括有不完整的分好的块：

```cpp
——|—【————|——————|——————|————】—|————
```

上图中【】表示区间，| 与 | 之间表示分好的均匀块（博主不知道怎么画精美的图啦）

我们可以发现该区间内有 $C$ 段完整区间，$2$ 段不完整区间；而同时，不完整区间的元素数量之和，绝对小于等于 $2S$；那么我们对于这一个区间而言，共需要进行最多 $C+2S$ 次查询——因为一个分块可以供给块内所有元素的信息。那么查询的时间复杂度便是 $O(C+2S)$。从渐进意义上来讲，时间复杂度为 $O(C+S)$，渐进整合后便是 $O(\max\{C,S\})$（**渐进的时间复杂度，可以认为等于对数值改变影响最大的数值的复杂度**）。

在知道这一点之后，我们可以这么想：

因为 

$$
C\times{S}+2S\geq r-l+1
$$

所以我们可以近似地看做有

$$
C\times{S}=r-l+1
$$

所以在同一区间内 $C×S$ 之积可以看作是个定值。那么当且仅当 $S=C$ 时，才会使得 $\max\{C,S\}$ 最小，此时 $S=C=\sqrt{n}$。

## （二）分块的运行机制

首先就是确立所分的块与被包含元素之间的关系，我们在此用一个 `belong` 数组记录每个点与所分的块之间的关系，同时进行区间记录。

```cpp
	int n,a[MAXN],belong[MAXN];
	int S,C=0,st[MAXN],ed[MAXN];//sum[MAXN],ma_x[MAXN],mi_n[MAXN]; 
	/*
	n:元素个数，a[]：元素，belong[]:每个元素所属的块的编号 
	S:每个块有多少元素 C:分块个数 st/ed:每个块的左边界、右边界 
	sum[MAXN]/ma_x[MAXN]/mi_n[MAXN]用于记录区间信息 
	*/ 
	void pretreat()
	{
		S=int(sqrt(double(n)));
		for(int i=1;i<=n;i+=S){
			st[++C]=i;
			ed[C]=min(i+S-1,n);//有可能会越界（sqrt必然有精度误差） 
		}
		for(int i=1;i<=C;i++)
			for(int j=st[i];j<=ed[i];j++)
				{
				belong[j]=i;//初始化belong 
				/*
    //区间操作  sum[i]+=a[j];
				ma_x[i]=max(ma_x[i],j);
				*/
				}
	}
```

其次便是区间修改 & 单点修改：由于区间操作只能针对于某个已经被分好的块，所以对于某些不完整区间的改动，需要进行单点修改。

对于区间修改，还有一点，为了帮助我们对区间讯息的整合，所以会引进一个`delta mark`，记录某个区间整体的变化情况。

注意：**当且仅当一个块被统一修改，才会改变这个块的 `delta` 值。**

```cpp
//区间单点修改 ，此处以求区间和为例 
	inline void updata_single(int x,int k)
	{
		a[x]+=k;
		sum[belong[x]]+=k;
	}
	
	//区间修改，同上
	int delta[MAXN];//用于记录一个！完整！区间的修改 
	void updata_range(int x,int y,int k)
	{
	    int l=belong[x],r=belong[y];
		if(l==r&&st[l]==x&&st[r]==y)
		{delta[l]=k; return ;}//ma_x[]
		//这个if纯粹是为了减少底下的运算，毕竟判断只有O(1) qwq
		else
		{
			for(int i=x;i<=ed[l];i++)
				updata_single(i,k);//如果不是完整区间，就单点修改 
			if(st[l]>x&&st[r]<y)return ; 
			//如果查询区间被某个块完全包含且不相等，
			//不需要进行以下操作 
			for(int i=st[r];i<=y;i++)
				updata_single(i,k);
			//如果所查询区间与块有交集且不想等
			//不需进行以下操作 
			for(int i=l+1;i<r;i++)
				delta[i]+=k;;
		}
	}
	
```

紧接着就是区间询问了，此时我们的 `delta` 就派上用场啦！
```cpp
	int query(int x,int y)//依然为区间和 
	{
		int l=belong[x],r=belong[y],ans=0;
		if(l==r){
			for(int i=x;i<=y;i++)
				ans+=a[i]+delta[belong[i]];
		}
		else{
			for(int i=x;i<=ed[l];i++)
				ans+=a[i]+delta[belong[i]];
			for(int i=l+1;i<r;i++)
				ans+=sum[i]+delta[i]*(ed[i]-st[i]+1);
				//对于每个区间的O(1)运算 
			for(int i=st[r];i<=y;i++)
				ans+=a[i]+delta[belong[i]];
		}
		return ans;
	}
```
我们会发现，对于一个分块程序来说，期望的时间总复杂度为：$O(m\sqrt n)$，对于 $50000$ 来说完全能跑开。

# 三、树状数组浅谈
 
## （一）关于树状数组的正确释义

首先要知道一个很重要的点：

**树状数组用的是树结构的思想(也就是树型逻辑结构)，而不是真正的“树形结构”**，初学者不要被强行拉入坑啊（换句话说，从某种意义上，树状数组跟树其实——————没有特别大的关系）。

那它为什么被叫作树状数组呢？

## （二）树状数组的存储特点

首先解释，树状数组支持的操作：

1、区间和、区间异或和、区间乘积和 RMQ（**显然，支持的操作都具有交换律，这也算是树状数组的一大特性吧**）

2、单点修改（**朴素的树状数组结构不支持区间修改，当然也可以普及成区间修改结构但我们先不提**）

那为什么不直接用前缀和或者差分数组呢？

我们知道，前缀和数组的维护是 $O(n)$ 的，查询、修改是 $O(1)$ 的。然而，树状数组的维护却是 $O(\log n)$ 的。并且查询、修改也是 $O(1)$ 的——这便是一个很大的优化。

等等，$\log n$？有点眼熟诶。再提示提示，这个 $\log$ 实际意义其实是 $\log$ 以 $2$ 为底———————

对，没猜错，就是二进制表示法，也就是二叉树上数据之间的特殊逻辑关系！

实际上，对于树状数组的每一个 i，其实际意义应该为：

**算上其本身的讯息，总共存储了 $2^k$ 个元素的信息，其中 $k$ 表示 $i$ 在二进制下，末尾零的个数，同时也可以表示最小的含 1 位的二进制权值——换句话讲，$2^k$ 即可表示成：对于每个二进制意义下的 $i$，从最末位数 $k+1$ 位，保留这 $k+1$ 位并删除 $k+1$ 位以左的所有数位上的数，留下的新二进制数的实际大小。**

而对于每一个x的最低含一位，即上文中的 $2^k$，可以借助一个 $\rm lowbit$ 函数实现——而这个的实现方式是很玄学的：

```cpp
	inline int lowbit(int x)
	{
		//return (x^(x-1))&x;
		return x&(-x);
	}
```
上文代码中给了两种不同的实现方式，而这两种中，有一种是通过数学+二进制的方式得出，另一种则是通过计算机编码特性得出——我实在懒得证了。

（三）树状数组的建立、维护和查询

建立：此处拿求区间和为样例

```
void build() 
{
for(int i=1;i<=n;i++)       
{cin>>a[i];tree[i]=i;}//一开始先赋初值
}
```

维护：看注释
```cpp
void updata(int x,int k)
{
	for(;x<=n;x+=lowbit(x))
		tree[x]+=k;
//此处可以如是想：lowbit取出的是当前x的最低含一位
//权值位，相加后等于向高位进位，并且已有的数位永远为零
//这就可以推出：每当x值+=lowbit(x)时，都会有进位，并且
//进位后的新x值一定包含所有原来的x值，也就是说，这一步
//充分地向上进位，达到区间和更新的目的。 
}
```

询问：从大到小枚举，比较方便。

```cpp
	long long query(int x){
		int ans;
		for(;x;x-=lowbit(x))
			ans=ans+tree[x];
		return ans;
	}
```

整合：相减即可。

```cpp
    inline long long my_union(int x,int y)
	{
		return query(x)-query(y-1);
     }
```

因此操作的复杂度均为单次 $O(\log n)$。





---

## 作者：feecle6418 (赞：105)

这里是一篇 **CDQ分治** 的题解！

CDQ分治的基本思想可以概括为：把这些询问排成一个序列（离线），递归处理相对于左区间和右区间的询问，在计算答案时，**合并两个子问题（类似于归并排序求逆序对），即考虑左半区间内的修改对右半区间内的询问产生的影响**。也就是，用左边的子问题来帮助解决右边的子问题。因此，CDQ分治可以支持修改。

对于这道题，我们把两个操作拆成三个操作：
1. 修改。
2. 对于查询操作 $[l,r]$ 的 $[1,l-1]$ 查询前缀和。在此时，我们需要把此次查询的结果**减去**当前前缀和。
3. 对于查询操作 $[l,r]$ 的 $[1,r]$ 查询前缀和。在此时，我们需要把此次查询的结果**加上**当前前缀和。

然后，我们对于整个**询问序列**进行CDQ分治，即可出解。相比于树状数组，常数较大，最大的点跑了540ms。若有不理解的地方可自行对照代码。

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct Query{
    int type,id,val;
    bool operator <(const Query sasa) const {
        return id==sasa.id?type<sasa.type:id<sasa.id;
    }
}a[2000005];
int qid,ans[2000005];
int aid=0;
Query tmp[2000005];
void CDQ(int l,int r){
    if(l==r)return ;
    int mid=(l+r)>>1;
    CDQ(l,mid);
    CDQ(mid+1,r);
    int sum=0,p=l,q=mid+1,o=l;
    while(p<=mid&&q<=r){
        if(a[p]<a[q]){
            if(a[p].type==1)sum+=a[p].val;
            tmp[o++]=a[p++];
        }
        else {
            if(a[q].type==2)ans[a[q].val]-=sum;
            if(a[q].type==3)ans[a[q].val]+=sum;
            tmp[o++]=a[q++];
        }
    }
    while(p<=mid)tmp[o++]=a[p++];
    while(q<=r){
        if(a[q].type==2)ans[a[q].val]-=sum;
        if(a[q].type==3)ans[a[q].val]+=sum;
        tmp[o++]=a[q++];
    }
    for(int i=l;i<=r;i++)a[i]=tmp[i];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        int t;
        scanf("%d",&t);
        a[++qid].type=1;
        a[qid].id=i;
        a[qid].val=t;//把最初的N个数也看成修改操作
    }
    for(int i=1;i<=m;i++){
        int opt,x,y;
        scanf("%d%d%d",&opt,&x,&y);
        if(opt==1){
            a[++qid].type=1;
            a[qid].id=x;
            a[qid].val=y;
        }
        else {
            a[++qid].type=2;
            a[qid].id=x-1;
            a[qid].val=++aid;
            a[++qid].type=3;
            a[qid].id=y;
            a[qid].val=aid;
        }
    }
    CDQ(1,qid);
    for(int i=1;i<=aid;i++)printf("%d\n",ans[i]);
}
```

---

## 作者：蒟蒻lxy (赞：79)

#### 本人树状数组的第一篇题解（~~也可以说是教程~~）
题目链接：[Link](https://www.luogu.org/problemnew/show/P3374)
## 1.思路

~~看一下题目名字你就知道了~~   
其实就是树状数组裸题（ _~~也没什么好说的~~_   
上图：

![树状数组](https://res.jisuanke.com/img/upload/20180503/a0d62ec5fe7ada70fb95cea10e943b6642ab1b41.png)
其中lowbit指：
> **lowbit 为一个数的二进制表示中最右边 11 所对应的值**   
> 或者说：   
> **lowbit=$2^k$,k为一个数的二进制表示中末尾0的个数** 

lowbit看起来不好求，**但是**，有一种简单版的~~无脑~~操作：
```
int lowbit(int x)
{
	return x&(-x);
}
```
~~为什么不早点说~~

   树状数组就是由lowbit分段的一种~~实用的~~数据结构，它的每一个节点管一个区间，存的是这个节点管的区间的最大值
## 2:分析
看到题目的要求：
> 1.将某一个数加上x

> 2.求出某区间每一个数的和

所以我们需要支持修改和查询操作

在这里我们设原数组为s，树状数组为c

### 修改：
修改即在x位置加上d   
想想看，树状数组的每一个节点存的是它管的区间的最大值，所以，如果修改最底层的一个点的值，受影响的是不是一条链？

修改节点11的值（红线即为受影响的）
![树状数组2](https://cdn.luogu.com.cn/upload/pic/62210.png)
由此可以推出此代码：
```cpp
void add(int x,int d)
{
	s[x]+=d;
	for(int i=x;i<=n;i+=lowbit(i))
		c[i]+=d;
}
```
### 查询：

查询比较复杂。

假设我们要求区间[L,R]的和     
那我们可以由[1,r]的和-[1,L]的和求出次结果    
问题就在于怎么求[1,X]的和

其实很简单
> 1. 设sum为和值
> 2. sum加上区间[X-lowbit(X)**+1**,X]的值（记住一定要+1）
> 3. x=X-lowbit(X)
> 4. 如果(x==0)则结束，否则回到步骤2

~~没毛病~~      
所以代码来了：
```
int sum(int x)
{
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i))
		ans+=c[i];
	return ans;
}
```
## 3.整体代码
树状数组完全可以被封装为一个类   
在这里我实现一下。

其他代码：   
```
//初始化
void init()
{
	memset(c,0,sizeof(c));
	for(int i=1;i<=n;i++)
		for(int j=i-lowbit(i)+1;j<=i;j++)
			c[i]=c[i]+s[j];
}
```
```
//调试用的输出
void print()
{
	for(int i=1;i<=n;i++)
		printf("%d ",s[i]);
	cout <<"     ";
	for(int i=1;i<=n;i++)
		printf("%d ",c[i]);
	cout << endl;
}
```

### 整体 ~~(终于要写完了啊啊啊）~~
```
#include<bits/stdc++.h>
using namespace std;
const int Maxn=500005;
int n,s[Maxn],m;
int lowbit(int x)
{
	return x&(-x);
}
struct node
{
	int c[Maxn];
	void add(int x,int d)//修改
	{
		s[x]+=d;
		for(int i=x;i<=n;i+=lowbit(i))
			c[i]+=d;
	}
	int sum(int x)//查询
	{
		int ans=0;
		for(int i=x;i>0;i-=lowbit(i))
			ans+=c[i];
		return ans;
	}
	void init()//初始化
	{
		memset(c,0,sizeof(c));
		for(int i=1;i<=n;i++)
			for(int j=i-lowbit(i)+1;j<=i;j++)
				c[i]=c[i]+s[j];
	}
	void print()//用来调试的输出
	{
		for(int i=1;i<=n;i++)
			printf("%d ",s[i]);
		cout <<"     ";
		for(int i=1;i<=n;i++)
			printf("%d ",c[i]);
		cout << endl;
	}
}a;
int main()
{
	cin >> n >> m;
	for(int i=1;i<=n;i++)//输入
		scanf("%d",&s[i]);
	a.init();//初始化
	for(int i=1;i<=m;i++)
	{
		//a.print();//调试
		int b,x,y;
		scanf("%d%d%d",&b,&x,&y);
		if(b==1)//操作1
			a.add(x,y);//把x为加上y
		else//操作2
			printf("%d\n",a.sum(y)-a.sum(x-1));//如上“查询”章所说
	}
	//a.print();//调试
	return 0;
}
```
这应该是我最长的一篇题解~~~QWQ

---

## 作者：冈崎梦美 (赞：72)

# 分块大法

## 1.1 概念
分块是一种~~暴力~~数据结构。分块的基本思想是把一个整体数列分成多块，使得查询时可以调用已经处理好的每块的信息。它的查询复杂度一般为$ O(\sqrt{n}) $。修改复杂度不一定，在这一题中修改复杂度为$ O(1) $。

## 1.2 为何选择分块？何时使用分块？
当然是因为它比较好想好写了！当题目中出现各种~~傻逼毒瘤一般~~比较难以实现的更新操作时，线段树、树状数组的更新操作均需进行较大改动才可使用时，就是分块派上用场的时候！

~~这道题好像更新很好实现啊，你是不是在打自己的脸啊?~~

## 2.1 一切的开始
要分块，首先要确定块的大小。一般来说，块的大小都为$\sqrt{n}$。这样大小的块可以保证整个序列被分成$\sqrt{n}$块。这样查询的时间复杂度可以达到平均。

分块算法中需要记录的信息有：
```
int sum[maxn];//一个块的和
int l[maxn];//一个块的左端点（起始点）
int r[maxn];//一个块的右端点（终结点）
int a[maxn];//原数组
int belong[maxn];//第i个元素属于第belong[i]个块
int block,num;//block表示块的大小，num表示块的数量。
```

分块的build函数代码为：
```
void build()
{
    block=sqrt(n);//块的大小是根号n
    num=n/block;if (n%block) num++;//有可能n不是完全平方数，这时块数需要加一
    for(int i=1;i<=num;i++)
    {
        l[i]=(i-1)*block+1;r[i]=i*block;
    }//对于左端点和右端点处理
    for(int i=1;i<=n;i++) belong[i]=(i-1)/block+1;
    r[num]=n;//最后一个块的右端点一定为n
    for(int i=1;i<=num;i++)
        for(int j=l[i];j<=r[i];j++)
            sum[i]+=a[j];//预处理出所有块的和
}
```

## 2.2 更新操作
很简单，无须赘述，基本上代码一看就懂。
```
inline void updata(int x,int y)//第x个元素加上y
{
    a[x]+=y;
    sum[belong[x]]+=y;//第x个元素所在的块的总和也要加上y
}
```

## 2.3 查询操作
这基本上是分块最难的点。但实际也很简单。

查询共有两种情况：
### A. 区间被一个块完整包含
直接暴力求解。因为块的大小最大为$\sqrt{n}$，所以复杂度为$O(\sqrt{n})$。
```
if (belong[x]==belong[y])
{
    for(int i=x;i<=y;i++) ans+=a[i];
    return ans;
}
```

### B. 区间横跨多个块
这是我们讲述的重点。请看下面这张图：

![查询区间](https://cdn.luogu.com.cn/upload/pic/16820.png)

如图，我们需要查询x至y的区间和。

首先，我们先暴力求出x到它所属的块的右端点的区间和。如下图所示：

![上述操作即为暴力求解图中黑箭头到红箭头之间的区间和](https://cdn.luogu.com.cn/upload/pic/16827.png)

上述操作即为暴力求解图中黑箭头到红箭头之间的区间和。代码如下
：
```
for(int i=x;i<=r[belong[x]];i++) ans+=a[i];
```

接下来，我们会发现：

![](https://cdn.luogu.com.cn/upload/pic/16830.png)

** 从x所属的下一个块开始，到y之前的一个块的区间内，所有块都是完整的 **

所以我们只需要使用之前处理出来的块的信息就可以啦。代码如下：
```
for(int i=belong[x]+1;i<=belong[y]-1;i++) ans+=sum[i];
```
然后重复类似开始的操作，暴力求解途中蓝箭头至y那一段即可。
```
for(int i=l[belong[y]];i<=y;i++) ans+=a[i];
```
所以分块中查询的函数部分如下：
```
inline int query(int x,int y)
{
    int ans=0;
    if (belong[x]==belong[y])
    {
        for(int i=x;i<=y;i++) ans+=a[i];
        return ans;
    }
    for(int i=x;i<=r[belong[x]];i++) ans+=a[i];
    for(int i=belong[x]+1;i<=belong[y]-1;i++) ans+=sum[i];
    for(int i=l[belong[y]];i<=y;i++) ans+=a[i];
    return ans;
}
```

## 3.1 完整code
分块的代码还是很好写的。需要注意的是这题数据有点大，所以要用读优+内联卡常过。
```
#include<bits/stdc++.h>
#define maxn 500007
using namespace std;
int sum[maxn],r[maxn],l[maxn],a[maxn],belong[maxn],block,num,n,m;
inline void write(int x)
{
    if(x<0) x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline int read()
{
    int x=0,f=1;char ch;
    for(;!isdigit(ch);ch=getchar()) f=ch=='-'?-1:1;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return x*f;
}
inline int query(int x,int y)
{
    int ans=0;
    if (belong[x]==belong[y])
    {
        for(int i=x;i<=y;i++) ans+=a[i];
        return ans;
    }
    for(int i=x;i<=r[belong[x]];i++) ans+=a[i];
    for(int i=belong[x]+1;i<=belong[y]-1;i++) ans+=sum[i];
    for(int i=l[belong[y]];i<=y;i++) ans+=a[i];
    return ans;
}
inline void updata(int x,int y)
{
    a[x]+=y;
    sum[belong[x]]+=y;
    //for(int i=1;i<=num;i++) printf("l: %d,r: %d,sum: %d\n",l[i],r[i],sum[i]);
    //putchar('\n');
}
inline void build()
{
    block=sqrt(n);
    num=n/block;if (n%block) num++;
    for(int i=1;i<=num;i++)
    {
        l[i]=(i-1)*block+1;r[i]=i*block;
    }
    for(int i=1;i<=n;i++) belong[i]=(i-1)/block+1;
    r[num]=n;
    for(int i=1;i<=num;i++)
        for(int j=l[i];j<=r[i];j++)
            sum[i]+=a[j];
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
    }
    build();
    //for(int i=1;i<=num;i++) printf("l: %d,r: %d,sum: %d\n",l[i],r[i],sum[i]);
    for(int i=1;i<=m;i++)
    {
        int mode=read(),x=read(),y=read();
        if (mode==1) updata(x,y);
        else
        {
            write(query(x,y));
            putchar('\n');
        }
    }
    return 0;
}
```
就这么多啦。比赛临近，多写点题解攒RP。* Feather-Sea *祝您在洛谷好运连连！

---

## 作者：Fish_egg_ (赞：18)

树状数组是一种支持**单点修改，区间查询**的精巧的数据结构，通常用于维护满足**结合律**和**可差分**的运算和信息。又称二叉索引树（Binary Index Tree）、Fenwick Tree。

### $\color{00cd00}\text{原理介绍}$

下面这张图展示了树状数组的原理（来源：OI-Wiki）。

![](https://oi-wiki.org/ds/images/fenwick.svg)

其中 $c_x$ 表示以 $x$ 为右端点，长度为 ${\rm lowbit}(x)$ 的区间的和。

> ${\rm lowbit}(x)$ 表示的是 $x$ 在二进制表示下，最低位的 $1$ 的权值。  
> 例如，$10$ 在二进制表示下为 $10\underset{\blacktriangle}{\bf1}0$，加粗的就是最低位的 $1$，它的权值是 $2$，因此 $\rm lowbit(10)=2$。  
> 再例如，$24$ 在二进制表示下为 $1\underset{\blacktriangle}{\bf1}000$，最低位的 $1$ 的权值为 $8$，因此 $\rm lowbit(24)=8$。  
> 根据位运算知识，可以得到 `lowbit(x) = x & -x`，其中 `&` 为**按位与**运算。

如果一个数减去自己的 $\rm lowbit$，得到的数再减去自己的 $\rm lowbit$，不断重复，最终这个数一定会变成 $0$。

例如 $7(111)\overset{\!-1}{\longrightarrow}6(110)\overset{\!-2}{\longrightarrow}4(100)\overset{\!-4}{\longrightarrow}0$。

那么我们要计算 $a_{1\dots7}$ 的和，就只需要求 $c_7+c_6+c_4$ 即可。观察上图，看看是不是这样。

由此我们可以得到查询 $a_{1\dots x}$ 的代码：
```cpp
int query(int x)
{
	int ans = 0;
	while(x > 0)
	{
		ans += c[x];
		x -= lowbit(x);
	}
	return ans;
}
```

可以发现，树状数组通过将一段数划分成 $O(\log n)$ 段数的和，从而能够实现高效的查询操作。

如果要求任意一段区间 $a_{l\dots r}$ 的和，可以借助前缀和的思想，用 $a_{1\dots r}$ 的和减去 $a_{1\dots l-1}$ 的和，即 `query(r) - query(l-1)`。这也说明树状数组可以当成一个支持修改的前缀和来用。

如果要将 $a_5$ 加上一个数 $k$ 该如何处理？观察包含 $a_5$ 的区间，只有 $c_5$，$c_6$ 和 $c_8$。那么就只需要将 $c_5$，$c_6$ 和 $c_8$ 都加上 $k$ 即可。而 $6=5+\rm lowbit(5)$，$8=6+\rm lowbit(6)$。也就是说，在树状数组中，一个结点 $x$ 的父亲是 $x+{\rm lowbit}(x)$。由此我们可以得到将 $a_x$ 加上 $k$ 的代码：
```cpp
void update(int x, int k)
{
	while(x <= n)
	{
		c[x] += k;
		x += lowbit(x);
	}
}
```
显然，修改操作的时间复杂度也为 $O(\log n)$。

### $\color{00cd00}\text{代码实现}$

以下是一份经过封装的极简树状数组代码，可以通过本题。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
struct BIT{ //树状数组
	int c[N], lowbit(int x){return x & -x;}
	void update(int x, int k){while(x < N) c[x] += k, x += lowbit(x);}
	int query(int x){int s = 0; while(x) s += c[x], x -= lowbit(x); return s;}
} t;
long long n, m;
signed main(){
	cin.tie(nullptr) -> sync_with_stdio(false);
	cin >> n >> m;
	for(int i=1, x; i<=n; i++) cin >> x, t.update(i, x);
	while(m --> 0){
		int op, x, y; cin >> op >> x >> y;
		if(op == 1) t.update(x, y);
		if(op == 2) cout << t.query(y) - t.query(x - 1) << "\n";
	}
	return 0;
}
```

推荐继续阅读我的 [树状数组小记](https://www.luogu.com.cn/article/m0npccng)，包含更多树状数组的高级应用。

---

## 作者：yijan (赞：15)

~~作为刚学oi的萌新~~  
写一篇较为详细的$cdq$分治题解（前面写过但是写的不是很详细啊）。
有问题请指出！

### 1. 预处理

首先把询问离线。（强制在线？出门右转~~树套树~~树状数组

对于一个查询区间，为了方便计算贡献考虑拆成两个。查询$[l,r]$等价于查询$[1,l-1],[1,r]$ 。然后我们就可以把所有的查询和修改存下来啦
```cpp
struct query{ll x,c,opt,cnt,ct;}q[MAXN*3],t[MAXN*3];
```
x：表示这个操作的位置。显然，前面把一个询问拆成两个后，每个询问只需要一个数字表示其操作位置

opt 表示这是个查询还是个修改

当opt == 1  则这是个修改操作，其中c存修改的值

当opt == 0  则这是个查询操作，如果c=-1 则表示查询后的值应该乘以-1.比如说对于查询$[l,r]$显然查询$[1,l-1]$后得到的值应当乘以-1再加到这个查询最后的ans里面。而对于$[1,r]$显然不用乘直接放进去。

cnt：这是第几个**操作** ，每进行一次查询或修改都++

ct: 这是第几个**询问** ， 一个询问拆成了两个query，这两个点ct必须相等，用以统计答案。

### 怎么分治？

现在我们就又了很多很多很多很多很多很多很多的操作了,但是怎么解决这些操作？

我们知道每一次单点修改会对所有$cnt$在其之后，且$x$在其之后的询问产生贡献。

那么考虑这样分治：

首先把所有操作**按照x进行排序**，（x位置一样则按照先修改，再查询的顺序排）

然后**对询问分治**。

现在问题是： 对于l到r的所有询问，已知关于x排序了的序列，然后考虑所有$cnt<=m(=l+r>>1)$左边（即在中点左边）的**修改**操作，对于所有$cnt>m$（即在中点右边）的询问的影响。

### 注意:这里只考虑**左边的修改**对于**右边的查询**的影响

然后考虑合并，直接从l到r，如果$cnt<=m$ 则放在左半边，如果$cnt>m$则放在右半边。由于原序列关于x有序，这样选出来的两半的序列也一定关于x有序（很显然吧，是按照从左到右选的）

然后问题转化成了两个完全相同的子问题：关于x有序，考虑贡献。

贡献算完了的过程就很无脑了，预处理ans为询问区间的和（利用前缀和）然后ans+贡献就好了。

这个的复杂度分析很显然了$O(nlogn)$

### 有什么用？

#### “这题显然树状数组就好了啊QAQ 怕不是想变成下一个a+b”

= =然而并不是。cdq分治多数时候并不是在这种时候用。

而是在很多很麻烦的时候顶替一些高级数据结构。（~~强制在线请出门右转~~

经常出现很多树套树的题目可以用cdq分治套一层树状数组过。而且有很多优点：常数小，编码复杂度小。。

下面推荐几个cdq的题QAQ 这些你就不能一个树状数组压过去了

~~当然你说你可以树状数组套树状数组那我也没办法了~~

[BZOJ1176 Mokia](https://www.lydsy.com/JudgeOnline/problem.php?id=1176)  
[luogu3810 三维偏序](https://www.luogu.org/problemnew/show/P3810)

还是给个代码吧，都说不给代码的题解不是好题解。。  
略微压行很简短
```cpp
/*Heroes Never Die!*/
#include "cstdio"
#include "algorithm"
using namespace std;
typedef long long ll;
#define MAXN 500006
struct query{ll x,c,opt,cnt,ct;}q[MAXN*3],t[MAXN*3];
ll n,m,A[MAXN],cnt,ct,ans[MAXN],S[MAXN];
bool cmp(query a,query b){ return a.x != b.x ? a.x < b.x : a.opt > b.opt; }
void cdq(ll l,ll r);
int main(){
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=n;++i) scanf("%lld",&A[i]),S[i] = S[i-1] + A[i];
    for(ll i=1,opt,x,x2,c;i<=m;++i){
        scanf("%lld",&opt);
        if(opt == 1) ++cnt,scanf("%lld%lld",&q[cnt].x,&q[cnt].c),q[cnt].opt=1,q[cnt].cnt=cnt;
        else scanf("%lld%lld",&x,&x2),++ct,++cnt,q[cnt] = {x-1,-1,0,cnt,ct},++cnt,q[cnt] = {x2,1,0,cnt,ct},ans[ct] = S[x2] - S[x-1];
    }
    sort(q+1,q+1+cnt,cmp);
    cdq(1,cnt);
    for(ll i=1;i<=ct;++i) printf("%lld\n",ans[i]);
}
void cdq(ll l,ll r){
    if(l == r) return;
    ll m = l + r >> 1,s = 0;
    for(ll i=l;i<=r;++i)
        if(q[i].cnt <= m && q[i].opt) s += q[i].c;
        else if(q[i].cnt > m && !q[i].opt) ans[q[i].ct] += s * q[i].c;
    ll l1 = l , l2 = m + 1;
    for(ll i=l;i<=r;++i) if(q[i].cnt <= m) t[l1++] = q[i]; else t[l2++] = q[i];
    for(ll i=l;i<=r;++i) q[i] = t[i];
    cdq(l,m),cdq(m+1,r);
}
```

广告：blog：[yihan.ac.cn](yihan.ac.cn)欢迎互换友联

---

## 作者：ssy666666 (赞：10)

# 树状数组
树状数组，通俗点说，可以理解为用数组来模拟树。

## 前置知识

我们先说明一个东西——```lowbit```。

```lowbit``` 指的是一个数字在二进制下最后一位的数。

e.g. $6$ 在二进制下的表示为 $(110)_2$，所以 ```lowbit(6)=2```。

## 算法介绍

如果你学过线段树的话，可以发现，线段树可以代替大部分的树状数组。

树状数组是怎么存储数据的呢，如图：

![树状数组模式图](https://cdn.luogu.com.cn/upload/image_hosting/qj36rk4l.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

树状数组中，每一个结点存储了一段下标的数据和/$\min$/$\max$ 等。在本题中，要求求出区间和。所以区间需要存储这一段下标的和。

e.g.结点 $4$ 存储的信息为原数组的下标 $1$ 到 $4$ 的数据和。

那既然如此，树状数组有什么样的性质，能存储什么样的数据？

树状数组满足可减性。

说人话，就是所求数据可以用两段数据（起始下标为 $1$）相减得到（这也是线段树能代替大部分树状数组的原因，因为大部分具有可减性的结构也具有可加性，但具有可加性的结构不一定具有可减性）。

e.g. 求下标 $3$ 到 $5$ 之间的和，可以通过 $1$ 到 $5$ 的和减去 $1$ 到 $2$ 的和得到。

同时，树状数组满足可合并性，一段数据可以通过两段或多段数据相加得到。每个结点 $i$ 存储的数据为原数组 $(i-lowbit(i),i)$ 的所有数据。

e.g. 联系上图，结点四存储了 $1$ 到 $4$ 的数据和，它可以通过结点 $2$（$1$ 到 $2$ 的和）加结点 $3$（$3$ 的和）加原数组 $4$（$4$ 的和）得到。

所以我们该如何搭建一个树状数组？

首先，与线段树不同，树状数组只需要开一倍空间，在本题中，$n \le 5 \times10^5$，所以只需要开 $5 \times 10^5$ 大小的数组。

同时，树状数组并不需要初始化（或全部初始化为 $0$）。因为其结点只存储对应数据，不存储左右儿子等多余信息，因此只需要开 ```int``` 就可以了。

## 正确性证明

观察图标，我们来看一看每个结点表示的和的区间（~~打个表~~）：

|$a[i]$|$l$|$r$|区间长度|```lowbit(n)```|
|:---:|:---:|:---:|:---:|:---:|
|$1$|$1$|$1$|$1$|$1$|
|$2$|$1$|$2$|$2$|$2$|
|$3$|$3$|$3$|$1$|$1$|
|$4$|$1$|$4$|$4$|$4$|
|$5$|$5$|$5$|$1$|$1$|
|$6$|$5$|$6$|$2$|$2$|
|$7$|$7$|$7$|$1$|$1$|
|$8$|$1$|$8$|$8$|$8$|
|……|……|……|……|……|

观察表格，可以发现，区间长度等于 ```lowbit(n)```。

我们再看每个节点子节点的二进制（从小到大）。

|结点|所有子结点(包含自己)|所有子结点的二进制|
|:---:|:---:|:---:|
|$1$|$1$|$(001)_2$|
|$2$|$1$,$2$|$(001)_2$,$(010)_2$|
|$3$|$3$|$(011)_2$|
|$4$|$2$,$3$,$4$|$(010)_2$,$(011)_2$,$(100)_2$|
|……|……|……|

再根据这个对应下每个结点的父结点的二进制：

|结点|父结点|结点的 ```lowbit```|
|:---:|:---:|:---:|
|$1$|$2$|$1$|
|$2$|$4$|$2$|
|$3$|$4$|$1$|
|$4$|$8$|$4$|
|……|……|……|

观察表格，可以发现，父结点位置等于本结点位置加本结点的 ```lowbit``` 值。

回到最开始的图，可以发现，包含本结点的结点只有它的祖先。

$e.g.$ 在大小为 $8$ 的树状数组中，包含 $3$ 的结点只有 $4$、$8$。

因此，我们可以用循环枚举需要更改的结点。

**Code**

```cpp
void add(int i,int num)//i表示初始更改的结点，num表示加上的值
{
	int t=i;
	while(t<=n)
	{
		tr[t]+=num;
		t+=lowbit(t);
	}
	return;
}
```

在查询区间和的时候，只需要计算 $1$ 到 $r$ 的值减去 $1$ 到 $l-1$ 的值就可以了。

又因为每个结点 $i$ 表示的区间大小为 ```lowbit(i)```。

所以可以循环枚举需要查询的结点，将所有和加起来。

**code**
```cpp
int get_sum(int r)
{
	if(r==0)
		return 0;
	return tr[r]+get_sum(r-lowbit(r));
}

int get_num(int l,int r)
{
	return get_sum(r)-get_sum(l-1);
}
```

在时间复杂度上，操作一中，若原来增加的结点为 $i$，则会不断加上 ```lowbit(i)```，所以向上枚举一次后，```lowbit()``` 至少乘 $2$，又要保证 ```lowbit()```$\leq n$，所以时间复杂度为 $O(\log n)$。

同理，操作二中，每次 ```lowbit``` 至少乘 $2$，又要保证 $i \ne 0$，所以时间复杂度也为 $O(\log n)$。

因此，总时间复杂度为 $O(m \log n)$。

## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

int num[500005];

int tr[500005];

int n,m;

int lowbit(int num)
{
	return num&(-num);
}

void add(int i,int num)
{
	int t=i;
	while(t<=n)
	{
		tr[t]+=num;
		t+=lowbit(t);
	}
	return;
}

int get_sum(int r)
{
	if(r==0)
		return 0;
	return tr[r]+get_sum(r-lowbit(r));
}

int get_num(int l,int r)
{
	return get_sum(r)-get_sum(l-1);
}

int main()
{
	memset(tr,0,sizeof(tr));
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&num[i]); 
		
		add(i,num[i]);
	}
	
	int u,p,q;
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&u);
		scanf("%d",&p);
		scanf("%d",&q);
		
		if(u==1)
		{
			add(p,q);
		}
		else
		{
			printf("%d\n",get_num(p,q));
		}
	}
	return 0;
}

```

---

## 作者：喵仔牛奶 (赞：9)

## 简介

本篇题解以双层分块例，讲解了**多层分块**解决本题的方法。

## 双层分块

### 算法流程

将序列分块后，对散块暴力，剩下的问题又变回了单点修改、区间求和。于是可以将每个块看着整体，权值为块内数的和，再次进行分块。本篇题解提供一种简洁的写法。

首先取一个 $B$，满足 $n<B^3$，本题可以取 $B=2^7$。以 $B$ 为一块，进行双层分块。

对于第一层，第 $x$ 块包含原序列中 $[xB,(x+1)B)$ 的位置。对于第二层，第 $x$ 块包含第一层 $[xB,(x+1)B)$ 中的块。

记 $d(x)=\lfloor\frac{x}{B}\rfloor$，表示 $x$ 在第一层所在的块编号，同时也是第一层第 $x$ 块在第二层所在的块编号。

用 $a$ 表示原序列，记 $p_i$ 为第一层第 $i$ 块包含的数的和，$q_i$ 为第二层第 $i$ 块包含的块的 $p_i$ 和。维护 $A,B,C$ 三个序列：
- $A_i=\sum_{j=i}^{(d(i)+1)B-1}a_j$，即 $i$ 在第一层的所在块中的**后缀和**。
- $B_i=\sum_{j=\boldsymbol{i+1}}^{(d(i)+1)B-1}p_j=\sum_{j=(i+1)B}^{(d(i)+1)B^2-1}a_j$，即第一层的第 $i$ 块在第二层的所在块中的后缀 $p_i$ 和**减去 $\boldsymbol{p_i}$**。
- $C_i=\sum_{j=\boldsymbol{i+1}}^{d(d(n))}q_j=\sum_{j=(i+1)B^2}^{n}a_j$，即第二层中 $i+1$ 后面的块的 $q_i$ 和**减去 $\boldsymbol{q_i}$**。

考虑查询 $[x,n]$ 的和。将 $[x,n]$ 拆成三段：$[x,(d(x)+1)B),[(d(x)+1)B,(d(d(x))+1)B^2),[(d(d(x))+1)B^2,n]$。可以发现，$A_x,B_{d(x)},C_{d(d(x))}$ 恰好为这三段，故答案为 $A_x+B_{d(x)}+C_{d(d(x))}$。

对于查询区间和，差分为两个后缀即可。

代码实现：
```cpp
// d(x)=x/(2^7)=x>>7
// 求 [x,n] 的和
int ask(int x) { return s1[x] + s2[x >> 7] + s3[x >> 14]; }
// 求 [l,r] 的和
int ask(int l, int r) { return ask(l) - ask(r + 1); }
```

考虑加 $a_x$ 加上 $y$。具体地：
- 对于 $A$，只有和 $x$ 同块且 $i\le x$ 的有影响。对于 $i\in[d(x)B,x],A_i\gets A_i+y$。
- 对于 $B$，只有和 $d(x)$ 同块且 $i+1\le d(x)$ 的有影响。对于 $i\in[d(d(x))B,d(x)\boldsymbol),B_i\gets A_i+y$。
- 对于 $C$，只有 $i+1\le d(d(x))$ 的有影响。对于 $i\in[0,d(d(x))\boldsymbol),C_i\gets A_i+y$。

代码实现：
```cpp
void upd(int x, int y) {
	REP(i, x >> 7 << 7, x) s1[i] += y;
	REP(i, x >> 14 << 7, (x >> 7) - 1) s2[i] += y;
	REP(i, 0, (x >> 14) - 1) s3[i] += y;
}
```

考虑时间复杂度。查询复杂度显然为 $\mathcal O(1)$。对于修改，复杂度为 $\mathcal O(B)$，取 $B=n^{1/3}$，复杂度为 $\mathcal O(n^{1/3})$。

### 代码实现

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 5e5 + 5;
	namespace BLK {
		int s1[N], s2[N], s3[N];
		void upd(int x, int y) {
			REP(i, x >> 7 << 7, x) s1[i] += y;
			REP(i, x >> 14 << 7, (x >> 7) - 1) s2[i] += y;
			REP(i, 0, (x >> 14) - 1) s3[i] += y;
		}
		int ask(int x) { return s1[x] + s2[x >> 7] + s3[x >> 14]; }
		int ask(int l, int r) { return ask(l) - ask(r + 1); }
	}
	int n, q, o, x, y;
	int main() {
		cin >> n >> q;
		REP(i, 1, n) cin >> x, BLK::upd(i, x);
		REP(te, 1, q) {
			cin >> o >> x >> y;
			if (o == 1) BLK::upd(x, y);
			if (o == 2) cout << BLK::ask(x, y) << '\n';
		}
		return 0;
	}
}
int main() {
	cin.tie(0)->sync_with_stdio(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

## 多层分块

### 算法流程

对于 $z$ 层分块，我们需要取合适的 $B$ 使得 $B^{z+1}>n$。令 $d^k(x)=d(d^{k-1}(x))$，$d^1(x)=d(x)$。

维护 $A_{z,i}=\sum_{j=(i+[z>1])B^{z-1}}^{(d(i)+1)B^z-1}a_j$。

修改时，$[x,n]$ 的答案为 $\sum_{i=0}^{z}A_{\lfloor\frac{x}{B^i}\rfloor}$。

查询时，对于 $A_0$,把 $[d(x)B,x]$ 加上 $y$，对于 $A_z\text{ }(z>0)$，把 $[d^z(x)B,d^{z-1}(x))$ 加上 $y$ 即可。

考虑复杂度，查询为 $\mathcal O(z)$，修改为 $\mathcal O(n^{1/(z+1)})$.

### 代码实现

这是本题三层分块的实现，取 $B=2^5$。

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 5e5 + 5;
	namespace BLK {
		int s1[N], s2[N], s3[N], s4[N];
		void upd(int x, int y) {
			REP(i, x >> 5 << 5, x) s1[i] += y;
			REP(i, x >> 10 << 5, (x >> 5) - 1) s2[i] += y;
			REP(i, x >> 15 << 5, (x >> 10) - 1) s3[i] += y;
			REP(i, 0, (x >> 15) - 1) s4[i] += y;
		}
		int ask(int x) { return s1[x] + s2[x >> 5] + s3[x >> 10] + s4[x >> 15]; }
		int ask(int l, int r) { return ask(l) - ask(r + 1); }
	}
	int n, q, o, x, y;
	int main() {
		cin >> n >> q;
		REP(i, 1, n) cin >> x, BLK::upd(i, x);
		REP(te, 1, q) {
			cin >> o >> x >> y;
			if (o == 1) BLK::upd(x, y);
			if (o == 2) cout << BLK::ask(x, y) << '\n';
		}
		return 0;
	}
}
int main() {
	cin.tie(0)->sync_with_stdio(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：ZYX0716 (赞：6)

[模板1](https://www.luogu.com.cn/problem/P3374)

## 题目大意：

有一个由 $n$ 个数字组成的数列，对于第 $i$ 个数其初始值为 $i$，对这个数列进行 $m$ 次操作：

- 操作1：将第 $x$ 个数加 $k$。

- 操作2：输出 $a$ 数组中 $[x,y]$ 区间内的和，包括 $a[x]$ 和 $a[y]$。

## 算法分析：

由于 $n$ 和 $m$ 的范围均为 $5 \times 10^5$，因此暴力绝对不可取，考虑使用**树状数组**解决。

关于树状数组：

1. 简介：树状数组的学名是**二叉搜索树**，其利用二叉树思想的前缀和的加强版。

2. 与二叉树的区别：简单来说，树状数组比二叉树少了大部分**非叶子节点的子节点**。以下两幅图帮助理解：

   （1）一个倾斜的二叉树![](https://cdn.luogu.com.cn/upload/image_hosting/38jcb721.png)

   （2）其对应的树状数组![](https://cdn.luogu.com.cn/upload/image_hosting/aulr1y1l.png)

   观察后可发现，一个二叉树如果只保留每一列最上面的一个节点，就是其对应的树状数组。

3. 在本题的运用：单点修改，区间查询。

介绍一个新的概念，$lowbit$：

-    对于一个正整数 $x$，我们规定 $lowbit(x)$ 为：二进制表示的 $x$，除最后一位 $1$ 外，其余全部改为 $0$，所得到的数。

-    一般将 $lowbit(i)$ 用于求 $a[i]$ 的父节点。

```cpp
inline int lowbit(int x){
	return x&(-x);
}
```

## Code:


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[500005],c[500005];
inline int lowbit(int x){
	return x&(-x);
}
void add(int i,int x){//将第i个数增加x。
	while(i<=n){
		c[i]+=x;
		i+=lowbit(i);
	}
}
int query(int x){//求a[x]到a[y]的区间和。
	int s=0;
	while(x){
		s+=c[x];
		x-=lowbit(x);
	}
	return s;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		add(i,a[i]);//为每个结点赋初值。
	}
	int op,x,y;
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&op,&x,&y);
		if(op==1){//将a[x]的值加y。
			a[x]+=y;
			add(x,y);
		}else{
			printf("%d\n",query(y)-query(x-1));//输出区间和。
		}
	}
    return 0;
}
```

---

## 作者：yuantc (赞：3)

# 前言：
### 什么是树状数组？
树状数组是解决‌单点修改加区间求和‌问题的高效选择，代码量远小于线段树。
### 核心操作：
* 单点修改‌（在数组某个位置增加一个值）。
* 前缀和查询‌（求数组前 $k$ 个元素的和）。

### 核心思想：

树状数组通过‌**二进制表示法‌**将数组元素组织成树形结构，每个节点存储一段区间的和，从而实现快速更新和查询。其核心在于 ‌$\operatorname{lowbit}$ 函数‌（计算最低位的 1 的值）。

假设原数组为 $a[1..n]$，树状数组为 $tree[1..n]$。

当 $n=8$ 时：
|下标|二进制|管理|
|:-:|:-:|:-:|
|1|001|$[1,1]$|
|2|010|$[1,2]$|
|3|011|$[3,3]$|
|4|100|$[1,4]$|
|5|101|$[5,5]$|
|6|110|$[5,6]$|
|7|111|$[7,7]$|
|8|1000|$[1,8]$|

 
#### 单点修改
* 目标‌：在原数组 $a[x]$ 上增加 $val$，并更新树状数组。

* 操作‌：从 $x$ 开始，不断向上跳跃到父节点，更新所有包含 $a[x]$ 的区间。


```
void update(int x, int val)
{
    while(x<=n)
   {
        tree[x]+=val;
        x+=lowbit(x); //找到父节点（x + 最低位的1）
    }
}

```


#### 前缀和查询

* 目标‌：计算原数组前 $x$ 个元素的和。
* 操作‌：从 $x$ 开始，不断向左上跳跃，累加路径上的区间和。

```
int query(int x) 
{
    int sum=0;
    while (x>0)
    {
        sum+=tree[x];
        x-=lowbit(x); //移动到前一个区间（x - 最低位的1）
    }
    return sum;
}
```

# 完整代码：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e5+10;//数据范围通常为5e5，+10防止越界

ll n,m;
ll tree[N];//树状数组（下标从1开始）

inline ll lowbit(ll x)//计算最低位的1，如lowbit(6)=2（二进制110的最低位10）
{
    return x&-x;
}

void update(ll x,ll val)//单点更新：在位置x上增加val，并向上更新父节点
{
    while(x<=n)//从叶子节点向上更新到根
	{
        tree[x]+=val; //当前节点增加val
        x+=lowbit(x);//移动到父节点（当前下标+最低位）
    }
}

ll query(ll x)//查询前缀和：计算前x项的和
{
    ll sum=0;
    while(x>0)//从当前节点向左上回溯
	{
        sum+=tree[x]; //累加路径上的节点值
        x-=lowbit(x);//移动到前一个区间（去掉最低位的1）
    }
    return sum;
}

int main()
{
    cin>>n>>m;//初始化树状数组（等效于单点插入）
    for(int i=1;i<=n;i++)
	{
        ll num;
        cin>>num;
        update(i,num);//将初始值逐个单点更新
    }
    while(m--)//处理m次操作
	{
        ll op,x,y;
        cin>>op>>x>>y;
        if(op==1)update(x,y);//单点修改：在x位置加y
        else cout<<query(y)-query(x-1)<<endl;//区间查询：[x,y]的和 = 前y项和 - 前x-1项和
    }
    return 0;
}

```
‌

‌单点修改‌：时间复杂度 $O(\log n)$。

‌前缀和查询‌：时间复杂度 $O(\log n)$。

‌空间复杂度‌：$O(n)$。

‌$\operatorname{lowbit}$‌：
找到二进制中最低位的 1，例如 $x=6$（二进制 110），返回 2（二进制 10）。
用于定位树状数组的父子节点关系。

$\operatorname{update}‌$：
从叶子节点 $x$ 开始，沿父链向上更新所有包含该点的区间。

$x+lowbit(x)$:
找到父节点下标。

‌$\operatorname{query}$：

计算前 $x$ 项的和，从节点 $x$ 向左上跳跃，累加路径上的区间值。$x-\operatorname{lowbit(x)}$ 移动到前一个区间的末尾（例如：$7 → 6 → 4 → 0$）。

# ‌初始化：

初始值通过 $\operatorname{update}$ 逐个插入，等效于将每个位置初始值视为一次单点更新。

## 对比线段树：


|操作|线段树|树状数组|
|:-:|:-:|:-:|
|单点修改|是|是|
|区间查询|是|是|
|区间修改|是|否|
|代码复杂度|复杂|简洁|


# 实际应用案例

假设原数组为 $a=[1,3,5,7,9]$ 初始化树状数组的过程如下：

‌初始空数组‌：$tree=[0,0,0,0,0]$。

‌逐个插入元素‌：

插入 $a=1 →$ 更新 $x=1,2,4$，

插入 $a=3 →$ 更新 $x=2,4$，

插入 $a=5 →$ 更新 $x=3,4$，

插入 $a=7 →$ 更新 $x=4$，

插入$ a=9 →$ 更新 $x=5$，

最终树状数组为：$tree=[1,4,5,16,9]$。

‌验证前缀和‌：

$\operatorname{query(5)}=1+3+5+7+9=25$。

#### 正确。

---

## 作者：_H17_ (赞：2)

## 题目分析

题目要求我们在较快的时间内实现单点加、区间查询。

如果我们正常做，若干次 $[1,n]$ 的区间查会把时间卡爆。

如果前缀和的话，修改操作需要恢复数组，也很慢。

如果使用差分，查询也要很长时间。

考虑使用树状数组，它的结构大体如下：

![树状数组.png（加载失败了）](https://cdn.luogu.com.cn/upload/image_hosting/iro8jso7.png)

我们知道 $\operatorname{lowbit}(x)$ 表示 $x$ 只保留最低的一位 $1$。

我们让 $f_x$ 的管辖空间是 $a_{x-\operatorname{lowbit(x)}+1}\sim a_x$。

我们考虑单点修改：对于一个点 $x$，我们显然知道最小管辖它的是 $f_x$，之后每次 $x\gets x+\operatorname{lowbit}(x)$，显然这样子末尾 $0$ 的数量增加了，一定包含。

考虑查询：$\sum\limits_{i=l}^{r}a_i=\sum\limits_{i=1}^{r}a_i-\sum\limits_{i=1}^{l-1}a_i$。

考虑处理其中一部分：求 $1\sim x$ 的和。

我们考虑到必须要取 $x$，还不能取更大的，显然 $f_x$ 满足这个条件。

但是 $f_x$ 也包含了 $a_{x-\operatorname{lowbit}(x)+1}\sim a_{x-1}$，所以我们直接跳树状数组 $x\gets x-\operatorname{lowbit}(x)$。

时间复杂度：考虑跳 $\operatorname{lowbit}$ 的性质，跳完 $\operatorname{lowbit}$ 之后末尾的 $1$ 又加了一个，至少翻倍，所以修改复杂度是 $O(\log n)$；查询的复杂度可以考虑为给 $x$ 做二进制拆分（本质就是这样），复杂度也是 $O(\log n)$。

时间复杂度 $O(q\log n)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
//#define int long long 
#define lowbit(x) ((x)&(-(x)))
using namespace std;
const int N=500001;
int n,m,a[N];
void add(int x,int k){
    while(x<=n)
        a[x]+=k,x+=lowbit(x);//加、并且跳
    return;
}
int qry(int k){
    int ans=0;
    for(;k;k-=lowbit(k))//跳
        ans+=a[k];//统计答案
    return ans;
}
int qry(int l,int r){
    return qry(r)-qry(l-1);//两部分
}
signed main(){
    cin>>n>>m;
    for(int i=1,k;i<=n;i++){
        cin>>k;
        add(i,k);
    }
    for(int op,a,b;m;--m){
        cin>>op>>a>>b;
        if(op==1)
            add(a,b);
        else
            cout<<qry(a,b)<<'\n';
    }
    return 0;
}
```

## 后续延伸

如何做区间修改、单点查询？

详见[树状数组 2](/problem/P3368) 和[题解](/article/ngp9j242)。

---

## 作者：huyinuo (赞：1)

# P3374 【模板】树状数组 1 题解
**~~题解区已经有很多奆佬了，希望可以夹缝求生。~~**
## 题意
对一个数列进行两种操作：

 - 将一个数加上 $x$。
 - 求 $[x,y]$ 的前缀和。
## 思考
对于这道题，即使未引入树状数组，也有暴力和前缀和和差分可以解决。
#### 非正解复杂度分析
**暴力时间复杂度**

- 操作 1 $O(1)$。
- 操作 2 最坏 $O(n)$。

$m$ 次操作时间复杂度最坏 $O(nm)$。

**pass**。

**前缀和差分时间复杂度**

- 预处理 $O(n)$。
- 操作1 进行处理 $O(n)$。
- 操作2  $O(1)$。

$m$ 次操作时间复杂度最坏 $O(nm)$。

**pass**。

那我们就该引入树状数组了
## 算法分析
树状数组以二叉树为底层逻辑，二叉树是一种优秀的数据结构，许多以二叉树为底层的算法都可以将复杂度降为 $\log$ 级别，树状数组也是如此。
![](https://cdn.luogu.com.cn/upload/image_hosting/o86vjxgk.png)
这是一个树状数组示意图，其中 $c$ 数组就表示树状数组。树状数组每一个值都储存着这个位置所管理的前缀和。当我们要更新值的时候，重新处理前缀和只需要一层一层往上更新管理当前位置的值就行了。
此时我们就要引入一个函数```lowbit```。
### 核心函数
#### lowbit

```lowbit```是指将参数转为二进制后最后一个 $1$ 所代表的位置，而在这里~~虽然不知道原理~~像是一个梯子，$
x + lowbit(x)$ 就可以访问往上一层的下标。编码很简单，只有一行
```cpp
int lowbit(int x) {return x & -x;}
```
我更喜欢取别名：
```cpp
#define lowbit(x) x & -x;
```
#### 更新值
理解上一个函数之后就很简单了：
```cpp
/*可以把整个过程理解为爬梯子
|-------|
|-------|
|-------|   
|tree[x]| x 
x:当前位置 lowbit(x):往上一个台阶的距离 tree[x]:当前位置能管理到所有值的前缀和
*/
void update(int x,int d) //最开始在x 把a[x] 加上d
{
	while(x <= n)       //梯子最高就n层
	{
		tree[x] += d;     //当前位置加上d
		x += lowbit(x);   //往上一层
	}
}
```
#### 求 $[x,y]$ 前缀和
输出和普通前缀和差不多，用 ```sum(x)``` 表示 $x$ 的前缀和，输出 ```sum(x) - sum(y - 1)``` 就行了。
```cpp
int sum(int x)
{
//和刚刚理解方法差不多 这里是下楼梯，顺便把所有的加上
  int ans = 0;      //答案
	while(x > 0)      //最少1层
	{
		ans += tree[x]; //加上值
		x -= lowbit(x); //往下
	}
	return ans;
}
```

至此所有的都分析完了。
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pc putchar
#define lowbit(x) x & -x 
typedef long long ll;
typedef pair<int,int> pii;
const int maxn = 5e5 + 10;
int n,T;
int tree[maxn];
int op,x,y;
void update(int x,int d)
{
	while(x <= n)
	{
		tree[x] += d;
		x += lowbit(x); 
	}
} //更新部分
int sum(int x)
{
	int ans = 0;
	while(x > 0)
	{
		ans += tree[x];
		x -= lowbit(x); 
	}
	return ans;
} //前缀和
void solve()
{
	scanf("%d%d%d",&op,&x,&y);
	if(op == 1) update(x,y);                //操作1:更新
	else printf("%d\n",sum(y) - sum(x - 1));//操作2:前缀和
} //单词操作
int main()
{
	scanf("%d%d",&n,&T);
	for(int i=1;i<=n;i++) scanf("%d",&x),update(i,x);
  //这一行是初始化 更新当前值所有能管理到它的
	while(T --) solve();
	return 0;
}
```

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3374)
# 解析
## 题目大意
给你一个数列，要你完成将数列中的某个数加上另一个数或者求这个数列中某一段的和。
## 考察知识
本题考查树状数组一。下面讲一下。

### 为什么用它？
想到爆算明显是不行的，看一眼贴心的时间复杂度便可知道。然而树状数组是一个能在 $O(\operatorname{log}n)$ 的时间复杂度内完成查询、单点或区间的具有差分性质操作的数组。所以用它比较方便。

**复杂度证明**

查询时通过 $i-\operatorname{lowbit}(i)$ 逐层向上跳转（如查询前 7 项和时，从 $7→6→4→0$，共 3 次操作）。每次操作消除二进制表示中最右侧的 1，例如：7 的二进制为 $111→$ 消除后变为 $110(6)→$ 消除后变为 $100(4)→$ 消除后变为 $000(0)$。若 $n$ 的二进制有 $k$ 位，最多循环 $k$ 次（$k = ⌈\operatorname{log}n⌉$）。以下是例子。

-  $n=8$ 时，二进制为 1000，最多循环 4 次。
-   $n=1024$ 时，最多循环 10 次（$\operatorname{log}_21024=10$）。

更新时通过 $i+\operatorname{lowbit}(i)$ 逐层向上修改祖先节点（如修改位置 3 时，从 $3→4→8→16…$ 直到超出 $n$）。每次操作将二进制表示中最右侧的1向高位移动，例如：
3 的二进制为 $11→$ 移动后变为 $100(4)→$ 移动后变为 $1000(8)$。循环终止于 $i$ 超过数组长度 $n$，最坏情况下修改 $⌈\operatorname{log}n⌉$ 次例如：修改位置 1 时，可能连锁更新 $2,4,8,16…$ 等节点（每个节点对应二进制位提升）。

每个元素需通过更新操作插入树状数组，初始空数组需执行 $n$ 次更新操作。单次更新复杂度为 $O(\operatorname{log}n)$，总复杂度为 $O(n\operatorname{log}n)$。

树状数组的构建时间满足递推关系:$T(n)=T(n−1)+O(\operatorname{log}n)$。解得总复杂度为： $T(n)=\sum_{k = 1}^{n}O(\operatorname{log}k)=O(n\operatorname{log}n)$。
### 怎么用它？
请看下面这个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/kq4jsiho.png)

这个就是树状数组的图。首先，我们读入的时候建立一个 $A$ 数组和一个 $C$ 数组，$C$ 数组就是用来储存原始数组 $A$ 某段区间的和的，也就是说，这些区间的信息是已知的，我们的目标就是把查询前缀拆成这些小区间。

由图可知：

-  $C[2]$ 管辖 $A[1…2]$。
-  $C[4]$ 管辖的是 $A[1…4]$。
-  $C[6]$ 管辖的是 $A[5…6]$。
-  $C[8]$ 管辖的是 $A[1…8]$。
-  剩下的 $C[x]$ 管辖的都是 $A[x]$ 自己。

然后，我们得要了解一个 $\operatorname{lowbit}$ 函数。

> 树状数组使用 $\operatorname{lowbit}$ 函数确定区间长度的核心原因在于其利用二进制分解的特性高效管理区间，从而实现快速的前缀和查询与动态更新，我们每一段的区间长度由 $\operatorname{lowbit}$ 决定，可以大大优化时间复杂度，从而实现更优的时间内做更多的事情。

在树状数组一中，设 $n$ 表示 $a$ 的大小，单点修改 $a[x]$ 的过程如下：
1. 初始化 $x'=x$。
2. 修改 $c[x']$。
3. 更新 $x'$ 为 $x'+\operatorname{lowbit}(x)$，如果 $x'>n$ 说明已经跳到尽头了，终止循环；否则回到第二步。

接下来你发现你就过了。
### 思路
思路不用说了，就是树状数组一。套个模板即可。
# 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=0x9ffff;
int num[N],n,m;
int lowbit(int x)
{
	return x&-x;
}

void add(int x,int k)
{
	while(x<=n)
	{
		num[x]+=k;
		x+=lowbit(x);
	}
}

int sum(int x)
{
	int answer=0;
	while(x)
	{
		answer+=num[x];
		x-=lowbit(x);
	}
	return answer;
}

signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int ls;
		cin>>ls;
		add(i,ls);
	}
	for(int i=1;i<=m;i++)
	{
		int ls1,ls2,ls3;
		cin>>ls1>>ls2>>ls3;
		if(ls1==1)
		{
			add(ls2,ls3);
		}
		else
		{
			int ls4=sum(ls3)-sum(ls2-1);
			cout<<ls4<<endl;
		}
	}
}
```

---

## 作者：ZJH234567 (赞：1)

## 二维偏序大意  
给定一个序列 $a, b$，对每个 $i$，求出所有 $j$，使得 $a _ {i} $ $\leq $ $a _ {j} $ ，$b _ {i} $ $
\leq $ $b _ {j} $。  

---  
## 如何做哪？  
1. **排序预处理**  
   序列的顺序不会影响答案，所以先排序（以 $a$ 作为第一关键字，$b$ 作为第二关键字）。
2. **归并框架**  
   所有符合条件的 $j$ 一定在 $i$ 之前（因为只有 $i$ 前的 $j$ 才满足 $a _ {i} $ $ \leq $ $a _ {j} $，并在 $a _ {i} $ $ = $ $a _ {i} $ 时 $b _ {i} $ $ \leq $ $b _ {j} $）。  
   对序列进行归并排序，分治时存在三种情况：  
   - **情况 1**：$i, j$ 都在左边 → 递归左半部分  。
   - **情况 2**：$i, j$ 都在右边 → 递归右半部分  。
   - **情况 3**：$j$ 在左，$i$ 在右 → 左半部分对右半部分产生贡献  （步骤与归并排序求逆序对类似）  。

---  
## 本题解法  
- 将所有操作（包括初始序列）视为一个序列：  
  - 初始序列和添加操作 $\to$ **操作 1**  。
  - 查询操作拆分为两个子操作：  
- 求 $[1, x-1]$ 的前缀和 $\to$ **操作 2**  。
- 求 $[1, y]$ 的前缀和  $\to$ **操作 3**  。
- 排序规则：  
  - 第一关键字：$pos$（操作下标）  。
  - 第二关键字：$type$（操作类型，操作 1 在前）  。

---  
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+10;

struct GG{
    int type,pos,v; // type:1-修改 2-减查询 3-加查询
    bool operator <(const GG &t)const{
        if(pos==t.pos) return type<t.type;
        return pos<t.pos;
    }
}q[N],tmp[N];

int n,m,idx=0,qidx=0,ans[N];

void CDQ(int l,int r){
    if(l==r) return ;
    int mid=(l+r)>>1;
    CDQ(l,mid),CDQ(mid+1,r);
    int k=0,i=l,j=mid+1,sum=0;
    while(i<=mid&&j<=r){
        if(q[i]<q[j]){
            if(q[i].type==1) sum+=q[i].v;
            tmp[k++]=q[i++];
        }else{
            if(q[j].type==2) ans[q[j].v]-=sum;
            if(q[j].type==3) ans[q[j].v]+=sum;
            tmp[k++]=q[j++];
        }
    }
    while(i<=mid) tmp[k++]=q[i++];
    while(j<=r){
        if(q[j].type==2) ans[q[j].v]-=sum;
        if(q[j].type==3) ans[q[j].v]+=sum;
        tmp[k++]=q[j++];
    }
    for(int i=0,j=l;j<=r;i++,j++) q[j]=tmp[i];
    return ;
}

int main(){
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1,x;i<=n;i++){
        cin>>x;
        q[++idx]={1,i,x};
    }
    while(m--){
        int op,x,y;
        cin>>op>>x>>y;
        if(op==1){
            q[++idx]={1,x,y};
        }else{
            qidx++;
            q[++idx]={2,x-1,qidx}; // 前缀减查询
            q[++idx]={3,y,qidx}; // 前缀加查询
        }
    }
    CDQ(1,idx);
    for(int i=1;i<=qidx;i++) cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：liyao2025 (赞：1)

## 题意：
有一个由 $n$ 个数字组成的数列，对这个数列进行 $m$ 次操作：

- 将第 $x$ 个数加 $k$。

- 输出 $[x,y]$ 区间内的和。

## 树状数组

### 引入
一个包含n个数的序列 $2,7,1,12,5,9,\dots,$ 计算前 $i$ 个数的和值，称为前缀和。

$sum[i]=a[1]+a[2]+,\dots,+a[i](i=1,2,\dots,n)$。

累加求前 $n$ 个数的和值需要 $O(n)$ 时间。而且若对 $a[i]$ 进行修改，则 $sum[i],sum[i+1],\dots,sum[n]$ 都需要修改，最坏的情况下需要 $O(n)$ 时间。

树状数组可以高效实现，其查询前缀和与点更新均为 $O(\log n)$。

那么树状数组是如何巧妙地实现呢？

### 正文

树状数组引入了分级管理制度，设置一个管理小组，每个管理员管理一个或多个连续的元素。例如，数列有 $9$ 个元素，分别用 $a[1],a[2],\dots,a[9]$ 存储，管理数组为 $c[]$。管理数组 $c[]$ 是树状的，因此称为树状数组。

![](https://cdn.luogu.com.cn/upload/image_hosting/btxm391y.png)

树状数组，又称为二进制索引树 $(Binary Indexed Trees)$，通过二进制分解划分区间。那么 $c[i]$ 存储的是哪些值？

### 1.区间长度

若 $i$ 的二进制表示末尾有 $k$ 个连续的 $0$，则 $c[i]$ 存储的区间长度为 $2^k$，**从** $a[i]$ **向前数** $2^k$ **个元素**，即 $c[i]=s[i-2^k+1]+s[i-2^k+2]+,\dots,+a[i]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8muf48us.png)

举例：
- $c[6]=a[5]+a[6]$
- $c[12]=a[9]+a[10]+a[11]+a[12]$，即管理 $\operatorname{lowbit(12)}$ 个。
### 2.前驱和后继
- **直接前驱**： $c[i]$ 的直接前驱为 $c[i-\operatorname{lowbit(i)}]$，即 $c[i]$ 左侧紧邻的子树的根。

- **直接后继**：$c[i]$ 的直接后继为 $c[i+\operatorname{lowbit(i)}]$，即 $c[i]$ 的父节点。

- **前驱**：$c[i]$ 左侧所有子树的根。

- **后继**：$c[i]$ 的所有祖先。

![](https://cdn.luogu.com.cn/upload/image_hosting/375f3o9u.png)

### 3.查询前缀和
前 $i$ 个元素的前缀和 $sum[i]$ 等于 $c[i]$ 加上 $c[i]$ 的前驱。
$sum[7]$ 等于 $c[7]$ 加上 $c[7]$ 的前驱，$sum[7]=c[7]+c[6]+c[4]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/x7i89w83.png)

### 4.点更新
 若对 $a[i]$ 进行修改。
 - 令 $a[i]$ 加上一个数 $z$，则只需更新 $c[i]$ 及其后继（祖先）。
 - 即令这些节点都加上 $z$ 即可，无需修改其他节点。

例如，修改 $a[5]$，令其加 $2$。只需 $c[5]+2$，然后 $c[5]$ 的后继分别加 $2$，即 $c[6]+2,c[8]+2,c[16]+2,c[32]+2,\dots$。

### 5.查询区间和

若求区间和值 $a[i]+a[i+1]+,\dots,+a[j]$，则求解前 $j$ 个元素的和值减去前 $i-1$ 个元素的和值即可。即 $sum[j]-sum[i-1]$。

### 思路
套模板就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,x,y,z;
long long a[1000005],c[1000005];
long long lowbit(long long i)//求lowbit
{
    return (-i)&i;
}
void add(long long i,long long z)//添加操作
{
    for(;i<=n;i+=lowbit(i))
    c[i]=c[i]+z;
} 
long long sum(long long i)//求和操作
{
    long long s=0;
    for(;i>0;i-=lowbit(i))
    s+=c[i];
    return s;
} 
int main(){
    scanf("%lld%lld",&n,&m);//输入
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        add(i,a[i]);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%lld%lld%lld",&z,&x,&y);
        if(z==1)add(x,y);
        else printf("%lld\n",sum(y)-sum(x-1));//求区间和，输出
    }
    return 0;
}
```

---

## 作者：GZXUEXUE (赞：1)

### 算法介绍

本篇题解将介绍树状数组这种数据结构。

树状数组用数组 $\operatorname{Tree}$（为叙述方便，在下文中简写为 $t$）维护二进制的索引结构。  
每个节点 $t_i$ 存储区间 $[i - \operatorname{lowbit}(i) + 1,i]$ 的和，其中 $\operatorname{lowbit}(x) = x \operatorname{and} -x$，用于确定区间长度。  
- 在单点更新时，我们可以沿 $i \gets i + \operatorname{lowbit}(i)$ 这一操作向上修改父节点；
- 在前缀和查询时，我们可以沿 $i \gets i - \operatorname{lowbit}(i)$ 这一操作累加子树值。

**[树状数组就是删除掉一些线段树中没有用的节点。](https://www.bilibili.com/video/BV1ce411u7qP/)**

对于本题，树状数组的时间复杂度如下：
- 建立数组：$O(N \log ⁡N)$；
- 单点修改：$O(\log⁡X)$，其中要修改的点为 $X$；
- 区间查询：$O(\log⁡(LR))$，其中要查询的区间为 $[L,R]$。

~~广告：此算法在[该古籍](https://www.luogu.me/article/hjqcqwbb)中亦有记载！~~

### 正确性证明

#### 从结构上来说

设二进制数 $i = 2^{k_1} + 2^{k_2} + \dots + 2^{k_m}$（$k_1 > k_2 > \cdots > k_m$），则：  
- 每个 $t_i$ 存储区间 $[i - 2^{k_m} + 1, i]$ 的和；
- 前缀和为 $\sum\limits_{j=1}^i a_j = \sum t_{2^{k_1}} + t_{2^{k_1} + 2^{k_2}} + \dots + t_i$。

#### 从操作时来说

- 更新时  
  修改 $t_x$ 时，我们通过 $i \gets i + \operatorname{lowbit}(i)$ 遍历所有覆盖 $x$ 的区间节点，更新其值。
- 查询时  
  求 $\sum\limits_{j=1}^x a_j$ 时，我们通过 $i \gets i - \operatorname{lowbit}(i)$ 遍历所有包含 $x$ 的区间节点。

#### 时间复杂度证明

- 单点修改和查询均依赖 $\operatorname{lowbit}$ 操作。每次操作最多遍历其二进制位数次，而 $i$ 的二进制位数是 $\lceil\log_2 i\rceil$。
- 由于 $\operatorname{lowbit}$ 保证每次跳转至少「消去」一个二进制位的 $1$，故最多 $\lceil\log_2 i\rceil$ 次操作即可完成。

因此，树状数组单次操作时间复杂度严格为 $O(\log n)$。

#### 归纳

当 $i=1$ 时，$t_1 = a_1$，正确。  
假设所有 $j < i$ 的节点正确维护区间和，则 $i$ 的更新路径必然覆盖其影响的所有父区间，查询路径精确分割二进制位。  
而对于时间复杂度，每次修改或查询**一个点 $X$** 时最多会访问 $O(\log X)$ 个节点，因为其由二进制位数决定。

### 代码实现

```cpp
# include <iostream>
using namespace std;
const int MAXN = 5e5 + 5;
int n,m,a[MAXN],Tree[MAXN];
int lowbit(int x){
    return x & -x;
}void add(int end,int num){
    while (end <= n){
        Tree[end] += num;
        end += lowbit(end);
    }
}int _query(int x){
    int sum = 0;
    while (x != 0){
        sum += Tree[x];
        x -= lowbit(x);
    }return sum;
}int query(int l,int r){
	return _query(r) - _query(l - 1);
}void build(){
	for (int i = 1;i <= n;i++) add(i,a[i]);
}int main(){
	cin >> n >> m;
	for (int i = 1;i <= n;i++) cin >> a[i];
	build();
	while (m--){
	    int op,x,y; cin >> op >> x >> y;
	    if (op == 1) add(x,y);
	    else cout << query(x,y) << endl;
	}return 0;
}
```

---

## 作者：qiuby123456 (赞：0)

> 众所周知，树状数组是一个可以用来单点增加、单点设置、单点求值、区间增加、区间求和（最大值、最小值等）的数据结构。

本题需要你执行两种操作：
1. 单点增加（以下记为修改操作）；
2. 区间求和（以下记为查询操作）。

一看到题目，感觉使用暴力算法好像不太行？修改的时间复杂度为 $\mathcal O(1)$，查询的时间复杂度为 $\mathcal O(n)$。看一下数据范围，$1\le n,m\le5\times10^5$。如果数据全部都是查询操作的话，那么总时间复杂度为 $\mathcal O(nm)$，会 TLE。那么我们想，有没有一种数据结构，能够支持以上两种操作而不会 TLE？我们只求它的时间复杂度能达到 $\mathcal O(m\log n)$。当然，能达到 $\mathcal O(m+n)$ 就更好了。

当然有了！~~线段树可以解决你的问题！~~（不要和我讲分块）树状数组可以解决本题！让我们看看树状数组是怎么解决问题的。

# 前情提要

我们需要了解 $\operatorname{lowbit}$ 函数。

我们不妨拿一个数 $24$ 作为例子，它的二进制是 $11000$。按照字面意思理解，$\operatorname{lowbit}$ 是用来求一个数 $x$ 最低的二进制位以及后面附带的 $0$。那么 $\operatorname{lowbit}(24)=\operatorname{lowbit}((11000)_2)=(1000)_2=8$，其中 $(x)_2$ 表示 $x$ 为二进制数。

那么，$\operatorname{lowbit}$ 该怎么求呢？

我们知道，负整数在计算机的反码与原码每一组对应的二进制位不相等，而补码是反码加一。如果末尾有连续的 $1$，那么这个加一的操作会把那连续的 $1$ 清零并且把原来最近的 $0$ 置为 $1$。那么 $\operatorname{lowbit}$ 的求法就呼之欲出了。

如果一个数 $x$ 是自然数，那么有 $\operatorname{lowbit}(x)=x\operatorname{bitand}(-x)$。用代码表示就是 `int lowbit(int x){return x ^ -x;}`。

# 建树

有一个下标范围为 $[1,n]$ 原始数组 $a$ 和一个下标范围相同的树状数组 $c$，满足对于一个在 $[1,n]$ 范围内下标 $i$，满足 $c_i=a_{i-\operatorname{lowbit}(i)+1}+a_{i-\operatorname{lowbit}(i)+2}+\cdots+a_{i-1}+a_i=\sum_{j=\operatorname{lowbit}(i)+1}^ia_j$。也就是说，$c_i$ 存储的是从 $a_{i-\operatorname{lowbit}(i)+1}$ 到 $a_i$ 这 $\operatorname{lowbit}(i)$ 个元素的和（管辖 $[i-\operatorname{lowbit}(i)+1,i]$ 范围）。

~~显然，~~$c_i=c_{i-1}+c_{i-1-\operatorname{lowbit}(i-1)}+c_{i-1-\operatorname{lowbit}(i-1)-\operatorname{lowbit}(i-1-\operatorname{lowbit}(i-1))}+\cdots$。

但是开始还未读入数据时 $a$ 数组全为 $0$，所以 $c$ 树状数组全为 $0$，不用建树，只需要在读入初始数据时进行单点增加即可。

# 修改：将第 $x$ 个数加上 $k$

每次先修改 $c_x$，$a_x$ 看情况修改（本题不需要）。然后根据 $x$ 被哪些节点管辖，再去修改相应的节点。

$x$ 被 $c_x$，$c_{x+\operatorname{lowbit}(x)}$，$c_{x+\operatorname{lowbit}(x)+\operatorname{lowbit}(x+\operatorname{lowbit}(x))}$ 等管辖。

片段代码：

```cpp
void addv(int x, int k){
	while (x < n){
		c[x] += k;
		x += lowbit(x);
	}
}
```

# 查询：区间 $[x,y]$ 内每个数的和

采用前缀和思想，先求区间 $[1,x-1]$ 内每个数的和，再求区间 $[1,y]$ 内每个数的和，最后相减得出答案。

对于求 $[1,x]$ 范围内的和，我们有一个变量 $s$ 初始化为 $0$，然后执行以下操作。

先求出 $c_x$ 的管辖范围（实际上不需要求，$c_x$ 的管辖范围已经被固定好了），将 $s$ 加上 $c_x$，然后把 $x$ 设置为管辖范围之前的最后一个下标，也就是 $x\gets x-\operatorname{lowbit}(x)$。

重复执行以上操作直到 $x\le0$。

片段代码：

```cpp
int query(int x){
	int s = 0;
	while (x){
		s += c[x];
		x -= lowbit(x);//这句等价于：x ^= lowbit(x);
	}
	return s;
}
```

完整的非人类能理解的代码：

```cpp
#include <cstdio>
int c[500001], n, m;
inline int lowbit(int x){
	return x & -x;
}
inline int pluslb(int x){
	return x + (x & -x);
}
inline int minuslb(int x){
	return x & -x ^ x;
}
void addv(int x, int v){
	while (x < n){
		c[x] += v;
		x = pluslb(x);
	}
}
int query(int x){
	int sum = 0;
	while (x){
		sum += c[x];
		x = minuslb(x);
	}
	return sum;
}
int query_range(int l, int r){
	return query(r) - query(l - 1);
}
void input(){
	int i, v;
	scanf("%d%d", &n, &m);
	++n;
	for (i = 1; i < n; ++i){
		scanf("%d", &v);
		addv(i, v);
	}
}
void output(){
	int o, x, y;
	while (m--){
		scanf("%d%d%d", &o, &x, &y);
		if (o & 1){
			addv(x, y);
		}
		else{
			printf("%d\n", query_range(x, y));
		}
	}
}
int main(){
	input();
	output();
	return 0;
}
```

但是，还不够！最近我比较喜欢把数据结构包装成类（浪费时间的毒瘤），于是：

```cpp
#include <cstdio>
int n, m;
template<typename T, int len>
class fenwick{
	private:
		class element{
			private:
				fenwick<T, len> *fw;
				int x;
			public:
				element(fenwick<T, len> *m_fw, int m_x): fw(m_fw), x(m_x){}
				operator T(){
					return (*fw)[x];
				}
				element &operator=(const T &v){
					fw -> set(x, v);
					return *this;
				}
				element &operator+=(const T &v){
					fw -> add(x, v);
					return *this;
				}
		};
	protected:
		T fw[len];
	public:
		fenwick(){}
		fenwick(const fenwick<T, len> &other){
			for (int i = 0; i < len; ++i){
				fw[i] = other.fw[i];
			}
		}
		void add(int x, T v){
			while (x < len){
				fw[x] += v;
				x += x & -x;
			}
		}
		void set(int x, T v){
			add(x, v - fw[x]);
		}
		T query(int x){
			T sum = 0;
			while (x){
				sum += fw[x];
				x ^= x & -x;
			}
			return sum;
		}
		T &operator[](int x) const{
			return query(x) - query(x - 1);
		}
		element operator[](int x){
			return element(this, x);
		}
		T operator()(int l, int r){
			return query(r) - query(l - 1);
		}
};
fenwick<int, 500005> c;
void input(){
	int i, v;
	scanf("%d%d", &n, &m);
	++n;
	for (i = 1; i < n; ++i){
		scanf("%d", &v);
		c[i] += v;
	}
}
void output(){
	int o, x, y;
	while (m--){
		scanf("%d%d%d", &o, &x, &y);
		if (o & 1){
			c[x] += y;
		}
		else{
			printf("%d\n", c(x, y));
		}
	}
}
int main(){
	input();
	output();
	return 0;
}
```

---

## 作者：Chase12345 (赞：0)

# 引入
这是一道要求单点加、区间和的题目。复习学过的内容看看能不能用：
* 暴力：显然不行，时间复杂度爆炸。
* 前缀和：能解决区间和，但是似乎并无法在常数或 $\log$ 的复杂度完成。

似乎都废了。不过先不要灰心，暴力的话每个位置维护的区间太小，而前缀和每个位置维护的区间比较大，我们是不是可以将它们两个结合起来，弄成一种数据结构，每个位置合理分配区间，就能在 $\log$ 的复杂度完成？这正是这道题的树状数组。
# 代码实现
这里先贴上代码，方便后续讲解
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
long long n, a[N], c[N], s[N];

int lowbit(int x) {
    return x & -x;
}

void build() {
	for (int i = 1; i <= n; i++)
		c[i] = s[i] - s[i - lowbit(i)];
}

void add(int k, int x) {
    for (int i = k; i <= n; i += lowbit(i))
        c[i] += x;
}

int query(int k) {
    int sum = 0;
    for (int i = k; i; i -= lowbit(i))
        sum += c[i];
    return sum;
}

int main() {
    int m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
    	cin >> a[i];
		s[i] = s[i - 1] + a[i];
	}
    build();
    while (m--) {
    	int op, x, k, y;
    	cin >> op >> x;
    	if (op == 1) {
    		cin >> k;
    		add(x, k);
		} else {
			cin >> y;
			cout << query(y) - query(x - 1) << '\n';
		}
	}
}
```
# 介绍
树状数组是一个维护区间问题的一个十分优秀的数据结构，它的常数比较小，在某些题目中代码十分简单，跑得飞快。比起线段树，树状数组局限性较大，需要的思维难度比较大，在出题人不卡常的情况下一般使用线段树代替树状数组。

这道题需要每次操作都在 $O(\log n)$。显然地，前缀和和暴力并无法在正确的复杂度完成。前面说过，在合理分配每一个位置维护的区间可以有效优化。这里先介绍 `lowbit` 函数。

`lowbit` 函数就是求出一个数 $x$ 在二进制下的最低的二进制位。可以直接用 `lowbit(x) = x & -x` 实现。为什么呢？

在计算机中，负数采用补码表示，`-x` 等于 `~x+1`，当 $x$ 和 $-x$ 进行按位与的时候：
1.  $x$ 的最低位 $1$ 右边的所有 $0$，在 `~x` 中会变成 $1$，加 $1$ 之后又变成 $0$。
2.  $x$ 的最低位 $1$ 在 `~x` 中变为 $0$，加 $1$ 后变回 $1$。
3.  $x$ 的最低位 $1$ 左边的所有位与 `~x` 的相应位相反。

其中 `~x` 表示对 $x$ 进行按位取反操作。

  我们对于每个 $c_x$，均维护 `[x - lowbit(x) + 1, x]` 这个区间，就能证明在 $O(\log n)$ 的复杂度内完成每次操作。
# 正确性证明
## 区间和
这一点显然。由于对于正整数 $x$，必定是有有限个二进制位，一直减最低的二进制 $1$，必定会得到 $0$，也就是能找遍所有数的和。且由于 $x$ 的二进制下有 $O(\log x)$ 位，所以时间复杂度必然是 $O(\log x)$。
## 单点加
其实树状数组美其名曰就是一棵树。你每次更新都必定会跳到它的父节点，直到树根，停止跳动。而兄弟节点必然不包含这个点。所以一直向上跳，复杂度 $O(\log x)$。不会错误更新，也不会重复更新。

---

## 作者：cwxcplh (赞：0)

这是一道很简单的树状数组模版题！

# 树状数组是什么

顾名思义，就是一个结构为树形结构的数组，和二叉树的结构类似但又不同，它是在二叉树的结构上删除了一些中间节点。

# 树状数组可以解决什么问题

1. **单点修改，区间查询。**

2. **区间修改，单点查询。**

3. **区间修改，区间查询。**

# 树状数组讲解

因为这道题是明显的单点修改、区间查询，所以我们只讲第一种。

要理解树状数组怎么工作的，我们首先得从二叉树入手：

![](https://cdn.luogu.com.cn/upload/image_hosting/im0e1dtm.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

如果我把这棵二叉树变一下，就会成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/zjg1khht.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

就是我们经常看见很多大佬拿来讲树状数组用的图。

这个图是什么意思呢？我给大家解释一下：我们对每一个数分别减去 $1,2,4,8,\dots$，直到原数的最低位 $1$ 与后面的 $0$ 组成的数比我要减去的数小，然后把减去后的数给作为子节点连起来，并连上原本的这个点。

有点抽象，让我们来拿上面的作为例子：首先是根节点 $8$，那么我们把 $8$ 分别减去 $1,2,4$ ，但不能减去 $8$，再连上自己原本的数，连起来就会得到这样一棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/090wu35j.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

然后是 $4$，我们又对 $4$ 进行如上操作。

接着是 $6$，$6$ 我就要着重讲了，对于 $6$ 来讲，它的二进制中最低的那一位 $1$ 在第 $2$ 位，与后面的 $0$ 组出来的数是 $2$，所以它最大减到 $1$ 而不能大于等于 $2$，所以它的子节点就是 $5$，也就是我们上面的那张图。

那又有人问：怎么处理出来二进制下最低位的 $1$ 与后面的 $0$ 所组成的数呢？这就要引出树状数组中一个很重要的东西了：**$\operatorname{lowbit}$** 函数。

这个 $\operatorname{lowbit}$ 函数的实现也很简单，就是 $x\&(-x)$ （$\&$ 表示与运算），具体原因主要涉及到[补码](https://blog.csdn.net/zl10086111/article/details/80907428?ops_request_misc=%257B%2522request%255Fid%2522%253A%252222BBBD7E-8EBF-4814-9AC3-8BECC68BB781%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=22BBBD7E-8EBF-4814-9AC3-8BECC68BB781&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80907428-null-null.142%5Ev100%5Epc_search_result_base3&utm_term=%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81&spm=1018.2226.3001.4187)的相关知识（学会了自己推）。

又有人问了：这么建树的好处有什么？好处可大了去了。首先我们可以很直观的看到每个子节点加上它的 $\operatorname{lowbit}$ 就是父节点，而我们的每个节点又是拿来存储前缀和的（比如上面的 `t[i]` 就是指一段区间内的前缀和，具体那段区间不方便叙述，请读者自行感受），所以说如果我们有一个点发生了改变，我们可以找到那个点所对应的那一段区间的前缀和，然后把它的父节点全部改变，这样在本质上这个点就已经完成改变了，而跳父亲节点的方式也很简单：一直加 $\operatorname{lowbit}$，直到加不动为止。

有人说：你这个我用普通的二叉树也能实现啊。但下面这个可就是树状数组特有的性质。

假设我们要求在发生改变后 $1$ 到 $7$ 的和。如果用普通的前缀和，时间复杂度太高了，二叉树又不方便求和，但树状数组是这么做的：

```cpp
int find(int x,int y)//x 到 y 的总和
{
    int sum1=0,sum2=0;
    for(int i=y;i>=1;i-=lowbit(i))
    {
        sum1+=tree[i];
    }
    for(int i=x-1;i>=1;i-=lowbit(i))
    {
        sum2+=tree[i];
    }
    return sum1-sum2;
}
```

因为这个 `tree[i]` 是一段区间的前缀和，我们就可以把它想象成一个有点奇怪的前缀和，而从上面的这张图中找规律能明显的看出：某段区间的前缀和就是从终点一直减 $\operatorname{lowbit}$，然后一直加当前这个区间的前缀和就对了。也就是说：$ans=tree_7+tree_6+tree_4$。

以上就是单点修改、区间查询的具体操作方法了。

AC 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,x,y,z,a[1000006],tree[1000006];
int lowbit(int x)
{
    return x&-x;
}
inline void init()
{
	cin>>n>>q; 
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
}
inline void build()//这棵树不需要真正的建出来，因为你只需要前缀和
{
    for(int i=1;i<=n;i++)
    {
        tree[i]=a[i];
        int m=lowbit(i);
        for(int j=1;j<m;j<<=1)
        {
            tree[i]+=tree[i-j];//上面的公式
        }
    }
}
inline void pl(int x,int y)//修改
{
    for(int i=x;i<=n;i+=lowbit(i))
    {
        tree[i]+=y;
    }
}
int find(int x,int y)//查找
{
    int sum1=0,sum2=0;
    for(int i=y;i>=1;i-=lowbit(i))
    {
        sum1+=tree[i];
    }
    for(int i=x-1;i>=1;i-=lowbit(i))
    {
        sum2+=tree[i];
    }
    return sum1-sum2;
}
inline int work()
{
    init();
    build();
    while(q--)
    {
        cin>>x>>y>>z;
        if(x==1)
        {
            pl(y,z);
        }
        else
        {
            cout<<find(y,z)<<endl;
        }
    }
    return 0;
}
signed main()
{
    return work();
}
```

---


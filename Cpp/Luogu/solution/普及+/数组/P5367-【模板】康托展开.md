# 【模板】康托展开

## 题目描述

求 $1\sim N$ 的一个给定全排列在所有 $1\sim N$ 全排列中的排名。结果对 $998244353$ 取模。

## 说明/提示

对于 $10\%$ 数据，$1\le N\le 10$。

对于 $50\%$ 数据，$1\le N\le 5000$。

对于 $100\%$ 数据，$1\le N\le 1000000$。

## 样例 #1

### 输入

```
3
2 1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
4
1 2 4 3```

### 输出

```
2```

# 题解

## 作者：_louhc (赞：73)

康托展开真是个神奇的东西。  
除了本题用于求某排列的排名外，康托展开一般用于哈希，不过我也没做到过这样的哈希题。

# 康托展开

先给你柿子。
$$ans=1+\sum_{i=1}^{n} A[i]\times(n-i)!$$
其中$A[i]$代表$\sum_{j=i}^{n}[a[j] < a[i]]$  
怎么来理解这个柿子呢？想象构造出字典序比当前排列小的有几个排列  
枚举到$i$表示 1到i-1和原来的排列一样，i位肯定不一样，之后咋样都行。  
既然到i位不一样，那么字典序大小其实就是取决于i位。很明显，第i位肯定要小于a[i]。然后只要把i后面小于a[i]的数交换到i位，后面随便排就行了。  
很明显，这样枚举可以做到不重不漏。因为要求的是排名，所以ans+=1。  
当然要用树状数组优化一下，复杂度是O(nlgn)的。

## 双语代码（滑稽
~~写Pascal就是为了卡常数,加O2秒杀C++)~~

### C++98/11/14/17

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 1000005
#define rgt register
#define mod 998244353

int N, a[MAXN], fac, c[MAXN], ans;
char *p;

inline void read( rgt int &x ){
	x = 0; while( !isdigit(*p) ) ++p;
	while( isdigit(*p) ) x = x * 10 + ( *p & 15 ), ++p;
}

int main(){
	scanf( "%d", &N ), fac = 1;
	p = new char[N * 8 + 100],
	fread( p, 1, N * 8 + 100, stdin );
	for ( rgt int i = N; i; --i ) read(a[i]);
	for ( rgt int i = 1, s, j; i <= N; ++i ){
		for ( s = 0, j = a[i]; j; j -= j & -j ) s += c[j];
		ans = ( ans + 1ll * fac * s ) % mod, fac = 1ll * fac * i % mod;
		for ( j = a[i]; j <= N; j += j & -j ) ++c[j];
	} printf( "%d\n", ans + 1 );
	return 0;
}
```

### Pascal

```pas
var
n, fac, s, ans, i, j:longint;
a, c:array[1..1000000] of longint;
begin
    read(n); fac := 1; ans := 0;
    for i := n downto 1 do
    begin
        read(a[i]);
        c[i] := 0;
    end;
    for i := 1 to n do
    begin
        j := a[i]; s := 0;
        while j > 0 do
        begin
            s := s + c[j];
            j := j - ( j and -j ); 
        end;
        ans := ( QWORD(ans) + QWORD(fac) * QWORD(s) ) mod 998244353;
        fac := QWORD(fac) * QWORD(i) mod 998244353;
        j := a[i];
        while j <= n do
        begin
            c[j] := c[j] + 1;
            j := j + ( j and -j );
        end;
    end;
    writeln((ans + 1) mod 998244353);
end.
```
# 逆康托展开

类似于进制转换，不断 % (n-i)!, /(n-1)!就可以得到A数组，然后就可以还原出原排列。  

**Update on 2019.7.23**  
~~昨天刚刚集训回来，于是就来填坑了~~

[例题](https://www.luogu.org/problemnew/show/UVA11525)  
这题十分好心地为我们省去了求出A数组的过程（否则要高精度除法？  
问题说白了就是在每一个`[i,n]`区间内求K大值。可以使用权值线段树+二分来解决这一问题。这应该比较基础，所以看代码吧qaq。

## 代码

~~没怎么卡常数，本来想搞zkw线段树非递归减小常数，但是懒。。。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 50005

int T, N, tr[MAXN << 2];

void Build( int c, int l, int r ){ //建树
	if ( l == r ) return tr[c] = 1, void();
	int mid((l + r) >> 1), ls(c << 1), rs(c << 1 | 1);
	Build( ls, l, mid ), Build( rs, mid + 1, r ),
	tr[c] = tr[ls] + tr[rs];
}

int Get( int c, int l, int r, int k ){ //找到k大值的同时删除k大值
	--tr[c]; if ( l == r ) return l;
	int mid((l + r) >> 1), ls(c << 1), rs(ls | 1);
	if ( tr[ls] < k ) return Get( rs, mid + 1, r, k - tr[ls] );//线段树上二分找到k大值
	return Get( ls, l, mid, k );
}

int main(){
	scanf( "%d", &T );
	while( T-- ){
		scanf( "%d", &N ), Build( 1, 1, N );
		for ( int i = 1, s; i <= N; ++i )
			scanf( "%d", &s ), printf( "%d%c", Get(1, 1, N, s + 1), "\n "[i < N] );
	} return 0;
}
```

---

## 作者：bovine__kebi (赞：27)

首先我们来了解一下什么是康拓展开：

康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的

 听起来很高深其实一句话概括：**求全排列**
 我们先来了解一下康托展开的基本操作方法，一个数的的排列的排名就相当于：  
$$\small a_n·(n-1)!+a_{n-1}·(n-2)!+\cdots+a_1·0!+1$$
其中"（n）!"表示从$n$一直乘到$1$，也就是$n$的阶乘，$a_i$表示原数的第i位在当前未出现的元素中是排在第几个的。举个例子：  
$3\quad 2\quad 1$的排名就是:  
$2·2+1·1+0·1+1=6$  
$2\quad 3\quad 1$的排名就是：  
$1·2+1·1+0·1+1=4$

计算一下复杂度，从计算阶乘一直到求和，总复杂度$O(n^2)$,先放一下暴力的代码，期望得分$40\sim50$分

于是我们重新审视一下这个式子，发现阶乘是可以预处理的，但是瓶颈在于不知道怎么寻找出$a_i$,往优化的方向想，还要能够加和减的，就只有两个东西，一个树状数组，一个线段树，线段树码量。。。堪忧，所以我们选择树状数组。

下面我们来思考如何维护$a_i$,我们可以把树状数组的每一个位置上的值都加$1$,只要$a_i$这个数出现了，我们就把它减去$1$（也就是加上$-1$），然后需要查询$a_i$的值的时候，直接树状数组套路求和就好了，复杂度就这样降到了$O(n\log n)$，期望得分:$100$  
码风不毒瘤，请放心食用：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;//上界
const int Mod=998244353；//神圣的模数
typedef long long ll;//加上这个很有用的，可以避免过多的重复long long
int n;
ll jc[maxn];//阶乘
ll tree[maxn];//树状数组
ll lowbit(ll x){return x&(-x);}//树状数组实现的支撑-取最低位,不知道的请翻到最后
ll sum(ll x)//求和
{
    ll ans=0;
    while(x!=0)
    {
        ans+=tree[x]%Mod;
        x-=lowbit(x);
    }
    return ans%Mod;
}
void add(ll x,ll k)//加法
{
    while(x<=n)
    {
        tree[x]+=k;
        x+=lowbit(x);
    }
}
int main()
{
    scanf("%d",&n);
    jc[0]=1;
    for(int i=1;i<=n;i++)//预处理阶乘
    {
        jc[i]=jc[i-1]*i%Mod;
        jc[i]%=Mod;
    }
    for(int i=1;i<=n;i++)
    {
        add(i,1);//如前面所说的那样，每一位都加上1
    }
    ll ans=1;//求排名，所以位置的值为1
    for(int i=1;i<=n;i++)
    {
        ll a;
        scanf("%lld",&a);//读入
        ans+=((sum(a)-1)*jc[n-i]%Mod)%Mod;//取模运算分进去，不知道的往后看
        add(a,-1);//这一个位置的值出现了，就把他减掉
    }
    printf("%lld\n",ans%Mod)；
    return 0;
}
```
树状数组：[看这里](https://www.luogu.com.cn/problem/P3374)  
取余运算：[看这里](https://www.luogu.com.cn/problem/P1226)  
管理员求过（づ￣3￣）づ╭❤～

---

## 作者：xuezhe (赞：17)

### 简介
康托展开是一种哈希的方法，其作用是将全排列映射成一个整数，该整数为全排列的排名。

### 解题过程
我们先拿一组数据来手玩：

求全排列 $1,3,2,5,4$ 的排名。

第 1 位是 1 ，这个全排列之前除 1 以外没有任何数会放在第 1 位，故不增加排名。

第 2 位是 3 ，在以 $1$ 为开头的全排列中，这个全排列之前还有以 2 作为第 2 位的全排列，共 1 个数。故前面存在 $1 \times (5-2)!$ 个全排列。

第 3 位是 2 ，在以 $1,3$ 为开头的全排列中，这个全排列之前除 2 以外没有任何数会放在第 3 为，故不增加排名。

第 4 位是 5 ，在以 $1,3,2$ 为开头的全排列中，这个全排列之前还有以 4 作为第 4 位的全排列，共 1 个数。故前面存在 $1 \times (5-4)!$ 个全排列。

第 5 位自然稳定，无需考虑。

所以该全排列的前面共有 $1 \times (5-2)! + 1 \times (5-4)! = 7$ 个全排列，排名则是前面全排列的数量加1，即第 8 。

给出核心代码，时间复杂度为 $O(n^2)$ ：
```cpp
/*给出全排列长度n和全排列a[1..n]，用康托展开求其排名*/
int cantor(int n,int *a){
    int i,j;
    int ranking=1,s;
    for(i=1;i<n;++i){
        s=0;
        for(j=i+1;j<=n;++j){
            if(a[j]<a[i]){
                ++s;
            }
        }
        ranking+=s*f[n-i];
    }
    return ranking;
}
```

这种做法的时间复杂度，对于这道题的数据来说，必然超时。我们就需要对其进行优化。

我们把大量的时间耗在了查找上面，但实际上，我们可以使用树状数组/线段树来进行优化。这里推荐树状数组，常数小，代码短， ~~好背~~ 。

我们只需要将左边小于 $a_i$ 的数的数量 $x$ 记录下来，右边小于 $a_i$ 的数的数量即为 $a_i-1-x$ 。

这个时候，我们可以将树状数组当作一个桶来使用。遍历过程中每次将桶中的 $b_{a_i}$ 置为1，对树状数组进行对应的操作即可。要求左边小于 $a_i$ 的数时，只要做一个前缀和即可。

时间复杂度为$O(nlogn)$

给出AC代码：
```cpp
#include <iostream>
#include <cstdio>
#define MOD (998244353)
using namespace std;
int n,a[1000000];
int c[1000001]={};
inline int lowbit(int x){
    return x&(-x);
}
inline void modify(int p){
    while(p<=n){
        ++c[p];
        p+=lowbit(p);
    }
    return;
}
inline int ask(int p){
    int s=0;
    while(p){
        s+=c[p];
        p-=lowbit(p);
    }
    return s;
}
inline void readInt(int &x){
    char c;
    while((c=getchar())<'0' || c>'9');
    x=(c^48);
    while('0'<=(c=getchar()) && c<='9'){
        x=x*10+(c^48);
    }
    return;
}
int fac[1000000]={1,1};
int main(){
    int i,s=0;
    readInt(n);
    for(i=0;i<n;++i){
        readInt(a[i]);
    }
    for(i=2;i<1000000;++i){
        fac[i]=(long long)fac[i-1]*i%MOD;
    }
    for(i=0;i<n;++i){
        s=(s+(long long)fac[n-1-i]*(a[i]-1-ask(a[i]-1))%MOD)%MOD;
        modify(a[i]);
    }
    printf("%d\n",(s+1)%MOD);
    return 0;
}
```

### 相关题目
[P1379 八数码游戏](https://www.luogu.org/problemnew/show/P1379)

利用康托展开可以进行状态压缩，便于BFS开记忆数组。

~~map流玩家当我什么也没说好了~~

---

## 作者：UperFicial (赞：10)

# 康托展开模板

### 前言

~~看了亿眼题解就会写了~~

~~但是爆了亿次零/dk/dk~~

这里说说自己对康托展开的理解。

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/P5367)

### 题意简述

给定一个 $1$ 至 $n$ 的排列，求它在 $1$ 至 $n$ 的全排列中的排名。

### 题目分析

假设给定的 $n$ 个正整数分别是 $a_1,a_2,\cdots,a_n$。

我们先看一个柿子：

$$\sum_{i=1}^n(v_{a_i}\times (n-i)!)+1$$

其中 $v_{a_i}$ 表示在第 $i+1$ 至 $n$ 位的比 $a_i$ 小的数的个数。

这个柿子就是最终的答案，我们来解释一下。

单考虑第 $i$ 位，它本身可以放 $v_{a_i}$ 个的，因为要计算它的排名的话比它小的数都可以放上去。而剩下的 $(n-i)$ 个位置一共就可以放 $(n-i)$ 个数，你怎么放都行，所以一共有 $(n-i)!$ 种方法。最后需要加上 $1$ 是因为要计算它本身的排名。

那怎么维护 $v$ 呢？我们设 $h_{x}$ 表示到了目前第 $i$ 个位置，数 $x$ 有没有出现过，没出现过为 $1$，出现过为 $0$，显然，一开始所有数都没出现过，$h$ 数组就都应该赋值成 $1$。

当我们要计算 $v_{a_i}$ 时，可以考虑这样一个柿子：$\sum_{j=1}^{a_i-1}h_j$，意思是先把所有比 $a_i$ 小的加上，而那些已经出现过的都已经成为 $0$ 了，完美的维护了 $v$。

显然 $h$ 需要树状数组维护。

阶乘用一个 $O(n)$ 的预处理也维护出来了，不过中间要注意精度的问题。

时间复杂度：$O(n\log n)$。

空间复杂度：$O(n)$。

[$AC$ 记录](https://www.luogu.com.cn/record/47700389)

[$code$](https://paste.ubuntu.com/p/fWCx2WVVX2/)

$$\texttt{The End.by UF}$$



---

## 作者：Anita_Hailey (赞：4)

## 序

~~果冻要买啥口味的？~~

## 正文

**康托展开** 求一个全排列的 **rank**，是一种特殊的 hash

考虑对于每一位进行计算，比如计算 2143 的 rank

1. 第一位是 2 比它小的有 1 个 于是 ans += 1 * 3!
2. 第二位是 1 比它小的是 0 个，于是 ans += 0 * 2!
3. 第三位是 4 比他小的是 1 个，于是 ans += 1 *  1!
4. 第四位是 3 比它小的没有于是 ans += 0 * 0!

ans = 7

但是最后应该加一，因为最小的那个算的是 0.。

所以，我们显而易见的可以得到一个 $O(n^2)$ 的做法，于是，在这个题目里 TLE 了。

这里我们不妨假定开了 O2.

那么，事实上 $O(n\sqrt n)$ 可以通过此题，来说说思路。把数分成 $\sqrt n$ 个块，我们每次对于一个块内做 erase 操作，即可，然后统计只要枚举每个块的元素个数即可，在整块里直接就是块中元素个数，在分出来的就是一个二分出位置即可。

```c++
#include <bits/stdc++.h>

#define gc(  ) std::getchar(  )
#define pc( i ) std::putchar( i )

template < typename T >
inline
T read(  )
{
	register T x = 0;
	register char ch = gc(  );
	register bool f = 0;
	while( !std::isdigit( ch ) )
	{
		f = ( ch == '-' );
		ch = gc(  );
	}
	while( std::isdigit( ch ) )
	{
		x = x * 10 + ( ch - '0' );
		ch = gc(  );
	}
	return f ? -x : x;
}

template < typename T >
void
put( T x )
{
	if( x < 0 )
	{
		x = -x;
		pc( '-' );
	}
	if( x < 10 ) {
		pc( x + 48 );
		return;
	}
	put < T > ( x / 10 );
	pc( x % 10 + 48 );
	return ;
}

#define Rep( i, j, k ) for( int i = j; i >= k; --i )
#define rdi(  ) read < int > (  )
#define rdl(  ) read < long long > (  )
#define pti( i ) put < int > ( i ), putchar( ' ' )
#define ptl( i ) put < long long > ( i ), putchar( ' ' )
#define For( i, j, k ) for( int i = j; i <= k; ++i )

const int mod = 998244353, Maxn = 1000001;

int a[ Maxn ], n, fac[ Maxn ], bl[ Maxn ], bol;

long long ans;

std::vector < int > v[ 10000 ];

void
fakemain(  )
{
	bol = sqrt( n = rdi( ) );
	For( i, 1, n ) v[ bl[ i ] = ( i - 1 ) / bol + 1 ].push_back( i ), a[ i ] = rdi( );
	fac[ 0 ] = 1;
	For( i, 1, n - 1 ) fac[ i ] = ( long long ) fac[ i - 1 ] * i % 998244353;
	ans = 1;
	For( i, 1, n )
	{
		std::vector < int >::iterator it = std::lower_bound( v[ bl[ a[ i ] ] ].begin( ), v[ bl[ a[ i ] ] ].end( ), a[ i ] );
		int tmp = 0;
		For( j, 1, bl[ a[ i ] ] - 1 ) tmp += v[ j ].size( );
		tmp += it - v[ bl[ a[ i ] ] ].begin( );
		ans = ( ans + ( long long ) fac[ n - i ] * tmp ) % 998244353;
		v[ bl[ a[ i ] ] ].erase( it );
	}
	ptl( ans );
	return;
}


int
main( int argc, char* argv[] )
{
	fakemain(  );
	return 0;
}
```

## 嵬

二模了，慌得一批

---

## 作者：超级玛丽王子 (赞：1)

康托展开=好东西。

这个东西在状态压缩方面用的很多，把全排列压缩成大小可以接受的数。具体的使用可以看看[这里](https://www.cnblogs.com/cjoierljl/p/9147579.html)。

首先讲一下基础做法：$O(n^2)$ 求解康托展开。

## 例题：判断 $2143$ 是数码集合 $\{1,2,3,4\}$ 的全排列中第几大的数。

计算排在 $2143$ 前面的排列数目，可以将问题转换为以下排列的和：
1. 首位小于 $2$ 的所有排列。首位小于 $2$ 的数只有 $1$，后面三个数的排列有 $A_3^3$，即 $6$ 种，记作 $1\times 3!$。
2. 首位为 $2$，第二位小鱼 $1$ 的所有排列。然而，$1$ 已经是最小的数了，没有符合条件的排列，共 $0$ 种，记作 $0\times2!$；
3. 前两位为 $21$，第三位小于 $4$ 的所有排列。由于 $1,2$ 已经用过了，符合条件的只有 $3$，共 $1$ 种，记作 $1\times1!$；
4. 前 $3$ 位为 $214$，第四位小于 $3$ 的所有排列。无，共 $0$ 种，记作 $0\times0!$。

求和得到 $2143$ 之前有 $7$ 种排列，所以它是第 $8$ 大的。

根据上面的例子我们可以得到康托展开的公式：

把一个集合产生的全排列按字典序排序，第 $X$ 个排列的计算公式为：
$$X=a_n\times(n-1)!+a_{n-1}*(n-2)!+\cdots+a_i*(i-1)!+\cdots+a_2\times1!+a_1\times0!$$

其中，$a_i$ 表示原数的第 $i$ 位在当前未出现的元素中排在第几个（从 $0$ 开始），并且有 $0\le a[i]<i\ \ (1\le i\le n)$

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=998244353;
int str[1000005],n;
long long fac[1000005];
void init() {
    scanf("%d",&n);
    fac[0]=fac[1]=1;
    for(int i=2;i<=n;i++) fac[i]=(fac[i-1]*i)%mod;
    for(int i=0;i<n;i++) scanf("%d",str+i),str[i]--;
}
void Cantor() {
    long long result=0;
    for(int i=0;i<n;i++) {
        int counted=0;
        for(int j=i+1;j<n;j++) 
            if(str[i]>str[j]) ++counted;
        result=(result+(counted*fac[n-i-1])%mod)%mod;
    }
    printf("%lld",(result+1)%mod);
}
int main(void) {
    init();
    Cantor();
    return 0;
}
```

## 然而，这个复杂度显然是不可承受的！
$O(n^2)$ 只能[得 $50$ 分](https://www.luogu.com.cn/record/39778591)。因此，我们采用树状数组优化的方式，将 $O(n)$ 判断出现排名的算法优化到 $O(\log_2n)$。

完整代码就不放了，仅仅把处理 `counted` 的部分换成树状数组就好了。

## 完结撒花~ 求赞求互关QAQ

---


# [GESP202406 七级] 区间乘积

## 题目描述

小杨有一个包含 $n$ 个正整数的序列 $A=[a_1,a_2,\ldots,a_n]$。

小杨想知道有多少对 $\langle l,r\rangle(1\leq l\leq r\leq n)$ 满足 $a_l\times a_{l+1}\times\ldots\times a_r$ 为完全平方数。

一个正整数 $x$ 为完全平方数当且仅当存在一个正整数 $y$ 使得 $x=y\times y$。


## 说明/提示

### 样例解释

满足条件的 $\langle l,r\rangle$ 有  $\langle 1,5\rangle$ 和 $\langle 3,3\rangle$。


### 数据范围

子任务编号|数据点占比|$n$|$a_i$
:-:|:-:|:-:|:-:
$1$|$20\%$|$\leq 10^5$|$1\leq a_i\leq 2$
$2$|$40\%$|$\leq 100$|$1\leq a_i\leq 30$
$3$|$40\%$|$\leq 10^5$|$1\leq a_i\leq 30$


## 样例 #1

### 输入

```
5
3 2 4 3 2```

### 输出

```
2```

# 题解

## 作者：Tomle (赞：40)

# 前言

一个月没写题解了，为了挽救估值，精心写了这篇题解。

本文有些冗长，可能会浪费您的时间，但可以对这道题有更清晰的理解。

## 约定
1. 下文中 $\bigoplus$ 表示**异或**。
2. 质数 $p$ 在 $a$ 中出现了 $x$ 次表示将 $a$ **分解质因数**后，$p$ 一共出现了 $x$ 次。

# 思路

## 二进制表示
首先，我们把每个数 $a_i$ 分解质因数，显然，$a_i$ 为完全平方数当且仅当每个质数都出现了**偶数**次。

注意到本题 $1\le a_i\le30$，其中的质数只有 $2,3,5,7,11,13,17,19,23,29$，共 $10$ 个。我们不妨将 $1\sim30$ 中每个数用二进制表示：对于第 $i$ 个质数（第 $i$ 位），若它出现了**奇数**次，这个二进制数的第 $i$ 位为 $1$，若出现了**偶数**次，则为 $0$。

## 两数相乘的二进制表示
由于本题需要**乘法**，我们考虑当知道 $a$ 和 $b$ 的二进制表示 $x$ 与 $y$，如何求出 $ab$ 的二进制表示 $z$。对于第 $i$ 个质数 $p_i$，共有四种情况：

- $p_i$ 在 $a$ 中出现了偶数次，$x$ 的第 $i$ 位为 $0$。$p_i$ 在 $b$ 中出现了偶数次，$y$ 的第 $i$ 位为 $0$，则 $p_i$ 在 $ab$ 中出现了偶数次，$z$ 的第 $i$ 位为 $0$。

- $p_i$ 在 $a$ 中出现了偶数次，$x$ 的第 $i$ 位为 $0$。$p_i$ 在 $b$ 中出现了奇数次，$y$ 的第 $i$ 位为 $1$，则 $p_i$ 在 $ab$ 中出现了奇数次，$z$ 的第 $i$ 位为 $1$。

- $p_i$ 在 $a$ 中出现了奇数次，$x$ 的第 $i$ 位为 $1$。$p_i$ 在 $b$ 中出现了偶数次，$y$ 的第 $i$ 位为 $0$，则 $p_i$ 在 $ab$ 中出现了奇数次，$z$ 的第 $i$ 位为 $1$。

- $p_i$ 在 $a$ 中出现了奇数次，$x$ 的第 $i$ 位为 $1$。$p_i$ 在 $b$ 中出现了奇数次，$y$ 的第 $i$ 位为 $1$，则 $p_i$ 在 $ab$ 中出现了偶数次，$z$ 的第 $i$ 位为 $0$。

容易发现，以上每种情况其实都是在进行**异或**操作，推出 $z=x\bigoplus y$。

## 本题主要部分
对于本题，令 $b_i$ 为 $i$ 的二进制表示，我们要维护一个**前缀异或和**，也就是 $pre_i=\bigoplus_{j=1}^ib_{a_i}$ 或 $pre_i=pre_{i-1}\bigoplus b_{a_i}$，特别的，$pre_0=0$。

容易发现，区间 $[l,r]$ 满足答案当且仅当 $pre_r=pre_{l-1}$，当 $pre_r$ 和 $pre_{l-1}$ 为 $1$ 的位异或后相互抵消时，$[l,r]$ 中数的乘积才是完全平方数。

令 $cnt_i$ 表示二进制表示为 $i$ 的数的个数。我们从 $1\sim n$ 扫描每个数 $a_i$，右端点为 $i$ 满足条件的区间的个数为 $cnt_{pre_i}$，将其计入答案后更新 $cnt_{pre_i}$。

# 细节
1. $cnt$ 数组大小开到 $2^{10}$。
2. 先计入答案，后更新（`ans += cnt[prexor]++;`）。
3. $pre_0=0$，初始时 $cnt_0=1$。
4. **十年 OI 一场空，不开 【】 见祖宗！**

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a[100005], b[35], prexor;
long long ans, cnt[1 << 10];
vector <int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

void read(int &a, int ch = 0) {
	while (!isdigit(ch = getchar()));
	for (a = 0; isdigit(ch); ch = getchar()) a = (a << 3) + (a << 1) + (ch ^ 48);
}
void prework() {
	// 预处理数组 b
	for (int i = 1; i <= 30; i++) {
		int j = i;
		for (int k = 0; k < 10; k++) {
			while (j % prime[k] == 0) {
				b[i] ^= 1 << k;
				j /= prime[k];
			}
		}
	}
}
int main() {
	prework();
	read(n);
	cnt[0] = 1;
	for (int i = 1; i <= n; i++) {
		read(a[i]);
		prexor ^= b[a[i]];
		ans += cnt[prexor]++;
	}
	cout << ans;
	return 0;
}
```

# 写在最后
本题思维难度和代码难度都一般，感觉评绿有点高了，应该是上位黄。

本人表达能力较差，简单的思路被写得很冗长，但将其底层逻辑刨析得较为透彻。

本人写文章偏向学术，有些内容可能晦涩难懂，欢迎在评论区指出。

---

## 作者：whrwlx (赞：23)

第一次抢到最优解！发篇题解纪念一下！

### 题意

有几个区间的乘积是完全平方数。

### 分析

很容易发现：

>一个数是完全平方数时，它的所有质因子的指数都为偶数。

那么，我们可以通过判断它的所有素因子的指数是否都为偶数来判断这个数是否为完全平方数，那么我们很自然而然的想到异或。

然后我们可以用状态压缩来储存每个数素因子的指数的奇偶性，即：

>对每个数进行质因数分解，使一个变量 res 为 $1$ 的二进制位表示了出现奇数次的质因数。

并用 map 存异或前缀和。

总时间复杂度为 $O(n\log n+n \sqrt{V})$，$V$ 为 $a$ 数组的最大值。

### 考虑优化

我们发现一个神奇的事情：

$1 \le a_i \le 30$，所以最多有 $10$ 个质因数。

然后我们就可以在质因数分解上优化。（其实是打表）

总时间复杂度为 $O(n\log n+nw)$，其中 $w=10$。

但是我们发现 $\sqrt{V}$ 的最大值为 $6$，貌似复杂度更劣了，所以我们加上一个特判就行了。

```c++
#include<bits/stdc++.h>
#define int long long
#define fd(i,a,b) for(int i=a,_i=b;i<=_i;i=-~i)
using namespace std;
const int N=1e5+509;
int n,a[N],ans;
int p[15]={0,2,3,5,7,11,13,17,19,23,29};
map<int,int> f;//用unordered_map会 WA QwQ
inline int work(int x)
{
	int res=0;
	fd(i,1,10)
	{
      if(p[i]>x) break;//特判一下
		while(x%p[i]==0) res^=(1<<i),x/=p[i];
	}
	return res;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	f[0]=1;//不要忘记把f[0]=1加进去！
	fd(i,1,n)
	{
		cin>>a[i];
		a[i]=work(a[i])^a[i-1];
		ans+=f[a[i]],f[a[i]]++;
	}
	cout<<ans;
	return 0;
}
```

### 后续

其实这道题求 res 的过程也可以打表，但是很麻烦，就不打表了。

upd：最优解被抢了呜呜呜。

所以打一个表：

```c++
int work[40]={0,0,2,4,0,8,6,16,2,0,10,32,4,64,18,12,0,128,2,256,8,20,34,512,6,0,66,4,16,1024,14,0,2,36,130,24};
```

用这个代替之前的 work 函数。

---

## 作者：xxseven (赞：8)

~~喜提本题前六个通过的最短代码，发篇题解庆祝一下~~

一段区间积的真实值很显然我们无法求出来，那么就要通过完全平方数的性质进行转化。

我们有结论：一个数是完全平方数，当且仅当这个数质因数分解后，所有质因子的指数都为偶数。

那么，判定一个数是否为完全平方数，可以等价于判定它的所有素因子的指数是否为偶数。出现奇数次为假，出现偶数次为真，想到了什么？异或！

具体地，我们可以对每个 $a_i$ 进行质因数分解，用一个变量 $res$ 记录结果，如果含有一个质因数 $x$，就令 $res \gets res \operatorname{xor} 2^x$。这样，最终 $res$ 为 $1$ 的二进制位就代表了出现奇数次的质因数。

然后，我们对每个 $a_i$ 求得的 $res$ 做异或前缀和，如果在前缀和数组 $b$ 中有 $b_i = b_j$，那么说明 $(i+1,j)$ 这段区间所有数的乘积没有出现次数为奇数的质因子，是一个合法的区间。对此我们可以开一个 map 记作 $f$，每枚举到一个数，先令 $ans \gets ans + f_{b_i}$，再令 $f_{b_i} \gets f_{b_i}+1$ 即可。不要忘记把 $b_0=1$ 加进去！ 

总时间复杂度 $O(n \log n+n \sqrt{a})$，可以通过此题。
下面是很短的完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+6;
int n,a[N];
map<int,int> f;
long long ans;

int apart(int x){
	int res=0;
	for(int i=2;i*i<=x;++i){
		while(x%i==0){
			res^=1<<i; //用异或标记出现次数的奇偶性 
			x/=i;
		}
	}
	if(x!=1) res^=1<<x;
	return res;
}

int main(){
	cin>>n; f[0]=1;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		a[i]=apart(a[i]);
		a[i]^=a[i-1];
		ans+=f[a[i]]; f[a[i]]++; 
	}
	cout<<ans;
	return 0;
}

```

希望这篇题解能够帮到你！

---

## 作者：jr_inf (赞：8)

$$
\text{设} \ \prod_{i=1}^{r}a_i=\prod p_i^{x_i},\prod_{i=1}^{l-1}a_i=\prod p_i^{y_i}\\ 
	\therefore \prod_{i=l}^{r} a_i=\frac{\prod_{i=1}^{r}a_i}{\prod_{i=1}^{l-1}a_i}=\prod p_i^{x_i-y_i}
$$
其中 $p_i$ 为小于等于 $30$ 的所有质数。

若 $\langle l,r\rangle$ 满足条件，那么每个 $x_i-y_i$ 均为偶数。换句话说，当且仅当每个 $x_i$ 与 $y_i$ 的奇偶性相同，$\langle l,r\rangle$ 满足条件。

由于 $p$ 中仅有 $10$ 个数（手玩可得），那么 $\prod p_i^{x_i}$ 中的 $10$ 个 $x_i$ 的奇偶性仅有 $2^{10}=1024$ 种情况，我们可以直接用类似哈希的方法记录它，最后看看有多少个相同的哈希值即可。时间复杂度 $O(n)$。

code：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,p[]={2,3,5,7,11,13,17,19,23,29},ma[1024],cnt,fac[10]={1};
long long ans;
signed main()
{
	ma[0]=1;
	scanf("%d",&n);//l=1 时
	for(int i=1;i<10;++i)fac[i]=fac[i-1]*2;
	for(int i=1,x;i<=n;++i)
	{
		scanf("%d",&x);
		for(int j=0;j<10;++j)while(x%p[j]==0)x/=p[j],cnt^=fac[j];//直接在原来的基础上修改
		ans+=ma[cnt];
		++ma[cnt];
	}
	printf("%lld",ans);
}
```

---

## 作者：bifanwen (赞：6)

[原题链接](https://www.luogu.com.cn/problem/P10724)

简要题意：给定序列 $\{a_n\}$，求 $1 \leq l \leq r \leq n$ 且 $\prod \limits_{i = l}^r a_i$ 为完全平方数的个数。

$n \leq 10^5, \space 1 \leq a_i \leq 30$.

### 算法一 暴力 40

考虑到直接算再验证肯定是不行的。由于完全平方数等价于“每个质因子幂次都是偶数”，所以实际上只需要验证每个质因子个数即可。

那么可以预处理前缀质因子个数的奇偶性（不关心有多少，只关心奇偶性），枚举后验证。$a_i$ 很小，$30$ 之内只有 $2,3,5,7,11,13,17,19,23,29$ 共 $10$ 个素数，时间复杂度 $\mathcal{O}(10n^2)$. $40 \text{pts}$.

### 算法二 正解 100

考虑一下 $a_i \leq 2$ 的情形。这时候我们只需要考虑一个质因子 $2$ 的奇偶情况。 $\forall 1 \leq i \leq n$, $\prod \limits_{j = 1}^i a_j$ 中 $2$ 的质因子要么是偶数，要么是奇数，用 $p_i = 0 \space 或 \space 1$ 表示。

注意到 $[l,r]$ 对答案有贡献当且仅当 $p_{l - 1} = p_r$. 由于我们只关心答案而不关心是哪些区间的贡献，只需要知道 $p_i$ 之间相等的情形，也就是有多少个 $i$ 使得 $p_i = 0$，有多少个 $p_i = 1$. 然后从中任选两个作为答案即可。

显然这扩展到 $a_i \leq 30$ 不太难。直接地，开一个 $0/1$ 的十维数组 $p$，每一维表示从小到大第几个素数的奇偶性情况，最后枚举 $p$ 统计即可。

有一个细节：十维都是 $0$ 的情况要初始化为 $1$，因为 $p_{l - 1} = p_r$ 的判断中可能访问到 $p_0$，如果没有初始化会导致 $l = 1$ 的答案被忽略掉。

另一个细节：答案最大会到 $\frac{n(n - 1)}{2}$，要开 $\text{long long}$.

代码实现虽然暴力，但足够简洁明白。

时间复杂度：$\mathcal{O}(10n)$. $100 \text{pts}$.

```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
inline void read(T &x) {
	x = 0; int f = 1; char c = getchar();
	while(!isdigit(c)) {if(c == '-') f = -f; c = getchar();}
	while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
	x *= f;
}

typedef long long ll;
const int N = 1e5 + 1;

int n, f[11];
int p[2][2][2][2][2][2][2][2][2][2];

int main() {
	read(n);
	p[0][0][0][0][0][0][0][0][0][0] = 1;
	for(int i = 1; i <= n; i++) {
		int x; read(x);
		while(x % 2 == 0) f[1] ^= 1, x /= 2;
		while(x % 3 == 0) f[2] ^= 1, x /= 3;
		while(x % 5 == 0) f[3] ^= 1, x /= 5;
		while(x % 7 == 0) f[4] ^= 1, x /= 7;
		while(x % 11 == 0) f[5] ^= 1, x /= 11;
		while(x % 13 == 0) f[6] ^= 1, x /= 13;
		while(x % 17 == 0) f[7] ^= 1, x /= 17;
		while(x % 19 == 0) f[8] ^= 1, x /= 19;
		while(x % 23 == 0) f[9] ^= 1, x /= 23;
		while(x % 29 == 0) f[10] ^= 1, x /= 29;
			// 暴力分解 
		p[f[1]][f[2]][f[3]][f[4]][f[5]][f[6]][f[7]][f[8]][f[9]][f[10]]++;
			// 十维状态个数记录 
	}
	ll Ans = 0;
	for(int a = 0; a <= 1; a++)
	for(int b = 0; b <= 1; b++)
	for(int c = 0; c <= 1; c++)
	for(int d = 0; d <= 1; d++)
	for(int e = 0; e <= 1; e++)
	for(int f = 0; f <= 1; f++)
	for(int g = 0; g <= 1; g++)
	for(int h = 0; h <= 1; h++)
	for(int i = 0; i <= 1; i++)
	for(int j = 0; j <= 1; j++) { // 枚举所有可能的奇偶状态 
		int t = p[a][b][c][d][e][f][g][h][i][j];
		Ans += 1ll * t * (t - 1) / 2; // 任选 2 个的方案数 
	}
	printf("%lld\n", Ans);
	return 0;
}

```

---

## 作者：Nailoong_SHM (赞：4)

# 题解
## 一、分析
看看标签：数论，再看题目：完全平方。这不是质因数分解的标配吗？继续看数据范围：$1\leq a_i\leq 30$。直接枚举走起！！！

## 二、思路
### 1.数据处理
我们可以先把每一个数质因数分解，然后记录每一个质因子出现的次数（而不是有没有出现），然后把每一个质因子出现的次数的奇偶性记录下来,做一个前缀和（因为要连乘），状压（我这个蒟蒻竟然用了状压）成一个数，存下来。
### 2.计算答案
#### 2.1 问题
现在每个前缀和的质因子出现个数都变成了 $0/1$，所以只要判断两个前缀和的状压状态相同即可，可是难道我们要把所有数对都遍历一遍吗？显然不行，复杂度 $O(n^2)$ 直接爆炸。那怎么办呢？
### 2.2 解决
明显我们计算下标 $i$ 的时候，需要比较的是前面有几个状压状态和 $i$ 相等的，有没有更快的方式呢？当然有！我用的是 STL 中的 map，用来记录前面每个状态出现的次数。这样代码就呼之欲出了。
## 三、代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int prime[12]={0,2,3,5,7,11,13,17,19,23,29};//枚举质数
int n;
struct num{
	int cnt[12]={0,0,0,0,0,0,0,0,0,0,0,0};//初始化
}a[100010],sumk[100010];
int sum[100010];
map<int,int>mp;//存状态出现的次数
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		int t=1;
		while(x && t<=10){//分解质因子
			if(x%prime[t]==0){
				x/=prime[t];
				a[i].cnt[t]++;
			}else t++;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=10;j++){//做一个前缀和
			sumk[i].cnt[j]+=sumk[i-1].cnt[j]+a[i].cnt[j];
			sumk[i].cnt[j]%=2;//记录奇偶性
		}
		for(int j=1;j<=10;j++){
			sum[i]|=(1<<(j-1))*sumk[i].cnt[j];//状压
		}
	}
	int cnt=0;
	mp[0]=1;//注意有可能有些本身就是完全平方数
	for(int i=1;i<=n;i++){
		if(mp[sum[i]]!=0){
			cnt+=mp[sum[i]];//记录答案
		}
		mp[sum[i]]++;//记录状态
	}
	printf("%d",cnt);
	return 0;
}
```
## END、最后
上面的代码并不能 AC，只有 80 分。是哪里错了呢？送你几句真言：

 _**十年OI一场空，不开 LONGLONG 见祖宗**_ 

 _**十年OI两茫茫，不开 LONGLONG 就凉凉**_ 

 _**拜拜**_

---

## 作者：Dioretsa (赞：3)

对于 $a_i$ 我们可以先将其质因数分解。下表是样例中对于 $a_i$ 其每个质因子出现的次数（即代码中的 $f$ 数组）。

| $i$ | $a_i$ | $2$ | $3$ | $5$ | $7$ | $11$ | $13$ | $17$ | $19$ | $23$ | $29$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $0$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $2$ | $2$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $3$ | $4$ | $2$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $4$ | $3$ | $0$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $5$ | $2$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |

显然地，若一个数为完全平方数，则它每个质因子出现的数均为偶数次。则我们关心每个质因子出现次数的奇偶性即可。

考虑对于前 $1$ 至 $k$ 个数相乘，我们仍然可以将其质因数分解。其分解结果为 $f'_{k,j}=\sum_{i=0}^kf_{i,j}$（$j$ 代表质因子）。同样地，我们仍然只关心每个质因子出现次数的奇偶性。

由于只关心奇偶性，于是，我们定义 $g_{k,j}=\sum_{i=0}^kf_{i,j} \bmod 2$。对于样例，$g$ 数组的结果如下表所示。

| $k$ | $a_k$ | $2$ | $3$ | $5$ | $7$ | $11$ | $13$ | $17$ | $19$ | $23$ | $29$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | / | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $1$ | $3$ | $0$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $2$ | $2$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $3$ | $4$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $4$ | $3$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $5$ | $2$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |

若存在 $k_1,k_2$ 使得对于所有的 $j$，都有 $g_{k1,j}=g_{k2,j}$。则在 $k_1$ 至 $k_2$ 间，质因子的个数必然增加了偶数个（可对着上表 $k_1=2,k_2=3$ 的情况模拟）。由于增加了偶数个质因子，则可以说明 $k_1,k_2$ 间存在完全平方数。

考虑具体实现，将 $g$ 数组每行看作一个二进制数。例如 $k=2$ 时，二进制数为 $(11)_2=(3)_{10}$。可用 map 映射，下标为二进制数对应的十进制数，数值存数出现的次数，类似于开了一个个桶。则上表中 $g$ 数组对应的数结果如下。

| $k$ | num | $2$ | $3$ | $5$ | $7$ | $11$ | $13$ | $17$ | $19$ | $23$ | $29$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $1$ | $2$ | $0$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $2$ | $3$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $3$ | $3$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $4$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| $5$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |

将结果映射到map上，如下表前两列所示。

| first(pos) | second(value) | 对答案的贡献 |
| :----------: | :----------: | :----------: |
| $0$ | $2$ | $1$ |
| $1$ | $1$ | $0$ |
| $2$ | $1$ | $0$ |
| $3$ | $2$ | $1$ |

对于一个二进制数，出现了 $k$ 次，则它对答案的贡献为 $\frac{k×(k-1)}{2}$（即为两两组合），如上表第三列所示。

则答案 $ans=1+0+0+1=2$，此题得解。

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
using namespace std;
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
		x=x*10+ch-48;
		ch=getchar();
	}
	return x*f;
}
int prime[15]={0,2,3,5,7,11,13,17,19,23,29};
int n,a[MAXN],f[MAXN][30],g[MAXN][30]; 
long long ans=0;
map <long long,long long> h;
int main() {
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		for(int k=2;k<=sqrt(double(a[i]));k++)
			if(a[i]%k==0) while(a[i]%k==0) a[i]/=k,f[i][k]++; 
		if(a[i]!=1) f[i][a[i]]++;
		for(int j=1;j<=10;j++) g[i][prime[j]]=g[i-1][prime[j]]+f[i][prime[j]];
	}
	for(int i=0;i<=n;i++){
		int base=1,sum=0;
		for(int j=1;j<=10;j++){
			g[i][prime[j]]%=2;
			sum+=g[i][prime[j]]*base;
			base*=2;	
		}
		h[sum]++;
	}
	for(map<long long,long long>::iterator it=h.begin();it!=h.end();it++) 
		ans=ans+(it->second)*(it->second-1)/2;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：andycode (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10724)

 # 题目大意

给出 $n$ 个数 $a_i$，求有多少对 $\lang l,r \rang$，满足 $1 \le l \le r \le n$ 且 $a_l \times a_{l+1} \times \dots \times a_{r-1} \times a_r$ 为完全平方数。

一个正整数 $x$ 为完全平方数，当且仅当存在一个正整数 $y$，使得 $x = y^2$。

 # 思路讲解

 ## 阶段一：前缀积

首先，我们将问题进行一个类似前缀和的转化。

设 $p_i$ 为 $\prod_{j=1}^{i} a_j$，即序列 $A$ 前 $i$ 个数的乘积，则题目可转换为存在多少对 $\lang l,r \rang$，满足 $\frac{p_r}{p_{l-1}}(p_0 = 1)$ 为完全平方数。

 ## 阶段二：分解质因数

可是 $p_i$ 最高可达到 $30^{10^5}$，存不下。需要再次优化。

学过奥数的朋友应该都知道，完全平方数的因数个数为奇数，反之亦然，因为它的平方根只能算一次。

而求出一个数因数个数，只需将它分解质因数后将所有质因数的指数先各自加 $1$ 后相乘即可。因为它的因数都可以表述为它的若干个质因数的乘积（$1$ 除外），所以每个质因数可以取走 $0$ 到该质因数指数个（取走 $0$ 个则作为 $1$ 相乘，如果都不取则结果为 $1$）。

再回到题目，可以发现 $a_i$ 的上限很小，只有 $30$，所以我们可以列出 $30$ 以内的所有质数 $2,3,5,7,11,13,17,19,23,29$，并定义一个二维数组 $s_{i,j}$，表示序列 $a$ 的前 $i$ 个数的乘积分解质因数后第 $j$ 个质数的指数为多少（如果为 $0$ 则表示不存在）。

在给 $s_{i,j}$ 赋值时，就可以统计 $a_i$ 分解质因数后，第 $j$ 个质数的指数（不存在为 $0$），再加上 $s_{i-1,j}$ 的指数。在 $p_{l-1}$ 和 $p_r$ 进行相除时，只需将 $s_r$ 的每一个 $s_{r,i}$ 减去 $s_{l-1}$ 的每一个 $s_{l-1,j}$ 即可（$1 \le i,j \le 10$）。

判断是否为完全平方数时只需用上前面说的方法，将减后的指数加 $1$ 并相乘，求出因数个数。如果因数为奇数个，则该数是完全平方数，否则不是。

这样我们就可以枚举所有的 $\langle l,r \rangle$，查看有多少个的乘积为完全平方数。算法复杂度为 $O(n^2)$。

 ## 阶段三：状态压缩+异或

$O(n^2)$ 的算法复杂度未免还是过于庞大，能不能再次优化呢？

如果要使所有质因数的指数加 $1$ 后的乘积为奇数，那乘积就不能含有质因子 $2$，所以所有质因数加 $1$ 后的结果必需为奇数，也就是说所有质因子的指数必需为偶数，所以我们只关心 $p_{r}$ 除以 $p_{l-1}$ 后所有的质因数的指数是否为偶数。

所以我们可以将 $s_{i,j}$ 压缩成 $s_i$，$s_i$ 从右往左数第 $j$ 个二进制位表示 $p_i$ 第 $j$ 个质数的指数模 $2$ 的余数（如果 $p_i$ 的质因数中不存在第 $j$ 个质数，则指数算作 $0$）。

可是 $s_i$ 如果直接相加可能会进位，该如何避免进位呢？

按位异或相信大家都不陌生，在编程时可以用 `^` 来表示。它的运算规则为遍历每一个**二进制位**，如果不同则答案的这一位为 $1$，否则为 $0$。

不过，我们可以换一种方式来表示它的运算规则——相加但不进位。因为不管是按照依照原来的规则，还是新定义出来的规则，都不影响结果。

所以我们在算出 $a_i$ 的质因数后，就可让 $s_i$ 直接异或 $s_{i-1}$。

在 $p_r$ 和 $p_{l-1}$ 进行相除时，就可以直接将 $s_r$ 的每一位减去 $s_{l-1}$ 的每一位（如果不足则自己加上 $2$），如果每一位为 $0$，则说明 $s_r$ 和 $s_l$ 的质因子相减后每一位为偶数，即 $p_r \div p_{l-1}$ 为完全平方数，也就是说 $\lang l,r \rang$ 满足题目要求。

仔细观察，不难发现，如果$s_r$ 的每一位减去 $s_{l-1}$ 的每一位（如果不足则自己加上 $2$）后，每一位为 $0$，则说明 $s_r$ 和 $s_{l-1}$ 相等。

所以我们可以遍历右端点，并将答案加上前面所有和 $s_r$ 相等的 $s_{l-1}(l \le i)$ 的数量即可，统计 $s_j$ 的操作可以通过 `map` 实现。

注意，$l=1$ 时 $s_{l-1}$ 为 $0$，要提前加入 `map` 中。

算法复杂度为 $O(n \log{n})$。

 # 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int prime[11]={0,2,3,5,7,11,13,17,19,23,29};
//统计小于30的质数
map<long long,long long> cnt;
long long n,a[100005],s[100005],ans;
int main(){
    cin>>n;
    cnt[0]=1;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        int tmp=0;
        for(int j=1;j<=10;j++){
            //统计s[i]
            int sum=0;
            while(a[i]%prime[j]==0)
                sum++,a[i]/=prime[j];
            tmp+=sum%2,tmp*=2;//赋值后左移一位
        }
        s[i]=s[i-1]^tmp;
        ans+=cnt[s[i]]++;
        //统计前面出现多少次s[i],并将s[i]出现的次数加1
    }
    cout<<ans;
    return 0;
}
```
完结撒花！

---

## 作者：Lysea (赞：2)

### Solution

看见题解区没有用分治做的，来一发。

见统计区间个数，立马想到分治。

我们定义“平方前缀积”为在一个区间前缀积的基础上，每存在一个平方因子就消掉它。

容易发现前缀积的每个数 $x$ 都满足 $ μ(x)\neq0$，也就是质因子最高幂次为 $1$。

而 $a_i\le 30$，只存在不超过 $10$ 个质因子，所以我们可以类似状压，用一个二进制数去表示这个前缀积。

并且如果两个区间“平方前缀积”相等，显然这两个区间合并后的“平方前缀积”为 $0$，也就是前缀积为完全平方数。

我们在处理区间 $[l,mid]$ 与 $[mid+1,r]$ 时，可以先算出左区间从右往左的“平方前缀积”，哈希记每个有前缀积个数，再计算右区间从右往左的“平方前缀积”，累加答案即可。

### Code


```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005
#define BASE 10000007
#define INF 1e18
#define ull unsigned long long
using namespace std;
int n,ans,a[N],b[N],cnt[N];
int pri[N]={0,2,3,5,7,11,13,17,19,23,29},fnt=10;
bool calc(int x){
	int k=sqrt(x);
	return k*k==x;
}
int h(int x){
	for(int i=1;i<=fnt;i++){
		while(x%pri[i]==0){
			x/=pri[i];
			cnt[i]=(cnt[i]+1)%2;
		}
	}
	int res=0;
	for(int i=1;i<=fnt;i++){
		res=(res<<1)+cnt[i];
	}
	return res;
}
void init(){
	for(int i=1;i<=fnt;i++) cnt[i]=0;
}
void solve(int l,int r){
	if(l==r){
		ans+=calc(a[l]);
		return;
	}
	int mid=l+r>>1;
	solve(l,mid),solve(mid+1,r);
	init();
	for(int i=0;i<=(1<<11);i++) b[i]=0;
	for(int i=mid;i>=l;i--) b[h(a[i])]++;
	init();
	for(int i=mid+1;i<=r;i++) ans+=b[h(a[i])];
	return;
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	solve(1,n);
	cout<<ans;
	return 0;
}
```

---

## 作者：chrispang (赞：2)

### 思路
当一个数是完全平方数的时候，它的所有质因子的次数都是偶数。

记 $x$ 的质因子为 $p_1^{q1} \times p_2^{q2} \times p_3^{q3} ... \times p_v^{qv}$。这些数可以通过次数的奇偶性用一个 $v$ 位的二进制串 $B$ 表示，$B_i$ 为 $0$ 说明 $q_i$ 为偶数，$B_i$ 为 $1$ 说明 $q_i$ 为奇数。比如 $10 = 2^1 \times 3^0 \times 5^1$，可以用二进制串 $101$ 来表示。

如果有两个数 $x$ 和 $y$，满足 $x > y$，它们的二进制串 $B$ 相同，那么 $x \div y$ 一定是完全平方数。记 $t_i$ 为每个 $a_i$ 的前缀积，$b_i$ 为每个 $a_i$ 的前缀积所对应的二进制串。对于每个 $i$ 如果存在 $k_i$ 个 $x$ 满足 $i > x$，并且 $b_i = b_x$，那么就有 $k_i$ 个以 $i$ 为右端点的区间积为完全平方数。最终答案 $ans = \sum_{i = 1}^{n} \ k_i$
​
### 代码实现

可以先把每个到 $i$ 的前缀积对应的 $b_i$ 用字符串表示，再用 map 存储（想省时间其实也可以用 unordered_map）对于每个 $i$，满足条件的 $x$ 的个数，即在 $i$ 前面的二进制串等于 $b_i$ 的数的个数。前缀积太大，不用高精度可能存不下，只需要存前缀积中每个质因子的指数就好了。

### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;

long long n, x, ans, cnt[11];
long long p[11] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29}; //30以内的所有质数(0是用来占位的)。 
map<string, long long>t;//存储当前每个二进制串出现了几次。 
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x; 
		if(x != 1) {
			for (int i = 1; i <= 10; i++) //分解质因数。 
				while(x % p[i] == 0) {
					x /= p[i];
					cnt[i]++; //对应质因子的指数加一。 
				}
		}
		string str = "";
		for (int i = 1; i <= 10; i++)
			if(cnt[i] % 2) str += "1"; //奇数用1表示。 
			else str += "0" ; //偶数用0表示。 
		ans += t[str];
		if(str == "0000000000") ans++;//完全平方数需要特判 
		t[str]++;
	}
	cout << ans << endl;
    return 0;
}
```

---

## 作者：Wei_Han (赞：1)

其实值域再大一点还是需要再分析一下的，但是发现 $a_i \leq 30$，说明每个每个数的因数个数以及他们是谁都可以算出来，而且已知完全平方数的每个因子个数都是偶数，假设我们把 $30$ 以内的每个质数的奇偶性看做一位二进制位，那么每个数字都可以被表示为一个二进制数，而且因为 $30$ 以内的质数只有 $10$ 个，所以这个数最大只有 $2^{10}$，然后因为我们是区间乘起来，也就是区间内每种质数的个数都加起来，由于记录的是奇偶性，他就等价于直接做区间异或，而区间异或就可以前缀异或和解决了，我们要求的是区间异或和为 $0$，就找两个值相同的就行了，这东西就可以直接计数了，记 $sum_i$ 为 $i$ 这个前缀异或和出现的次数，那么答案就是 $\sum \frac{sum_i^2}{2}$，记得空集也计入统计。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define pr putchar('\n')
#define pp putchar(' ')
#define pii pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(register ll i = a ; i <= b ; ++ i )
#define Fo(a,i,b) for(register ll i = a ; i >= b ; -- i )
#define fi first
#define se second
//#pragma GCC optimize(2)
using namespace std;
typedef long long ll;
const int N=2e5+5,M=1e7+5;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}

ll prime[30]={2,3,5,7,11,13,17,19,23,29},n,a[N],ans[N];
unordered_map<ll,ll> mp;
signed main(){
	read(n);fo(1,i,n) read(a[i]);
	fo(0,i,9) fo(1,j,n) while(a[j]%prime[i]==0) a[j]/=prime[i],ans[j]^=(1<<i);  
	fo(1,i,n) ans[i]=ans[i-1]^ans[i];
	fo(1,i,n) mp[ans[i]]++;mp[0]++;
	ll sum=0;fo(0,i,1<<10) sum+=mp[i]*(mp[i]-1)/2; 
	wr(sum);pr;
	return 0;
}	
``````

---

## 作者：osfly (赞：0)

提供一种比较好想的思路。

注意到 $a_i$ 很小，考虑先将 $30$ 以内的质数记录下来。记 $k$ 为质数种类数，易得 $k=10$。

令 $a_x=\prod^k_{i=1}p_i^{c_i}$，其中 $p_i$ 为质数。

我们记与 $a_x$ 对应的 $b_x$ 为 $b_x=\sum^k_{i=1}2^{[2|c_i]}$，其中当 $c_i$ 为 $2$ 的倍数时，$[2|c_i]=1$，否则为 $0$。

这样我们就能把每个 $a_i$ 转化为二进制的形式存储了。

注意到 $\prod^r_{i=l}a_i$ 为完全平方数当且仅当该区间内的所有 $a_i$ 的乘积的唯一分解形式的幂均是偶数 。其等价于对于每一个二进制位，该区间内的所有 $b_i$ 的这一二进制位总共有偶数个 $1$。即：$\oplus^r_{i=l}b_i=0$

其中 $\oplus$ 表示异或。

这是一个经典的区间异或问题，该问题有一个性质：区间异或和为 $0$ 的充要条件是前缀异或和相等，数数时顺便记录一下与该前缀异或值相等的数的个数即可。

时间复杂度 $O(kn)$，虽然带了 $10$ 倍常数但是也足够通过此题。

```cpp
#include<bits/stdc++。h>
using namespace std;

#define ll long long

const int N=1e5+10;

int pri[10]={2,3,5,7,11,13,17,19,23,29};
int n;
int a[N];

int work(int x)
{
	int res=0;
	for(int i=0;i<10;i++)
	{
		int cnt=0;
		while(x%pri[i]==0) cnt++,x/=pri[i];
		res+=(1<<i)*(cnt&1);
	}
	return res;
}

int cnt[1<<11];
ll ans;

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),a[i]=work(a[i]),a[i]^=a[i-1];
	cnt[0]++;
	for(int i=1;i<=n;i++)
		ans+=cnt[a[i]],cnt[a[i]]++;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xinxin2022 (赞：0)

一道练习完全平方数的特性的好题。

首先暴力肯定不行，`long long`都存不下，~~除非你打高精~~而且时间复杂度也无法接受。

那很容易想到利用完全平方数的性质解题。

显然一个区间乘积这么大的数，只能从因数方面入手，那手玩一下样例：

$3 \times 2 \times 4 \times 3 \times 2 = 2 \times 2 \times 2 \times 2 \times 3 \times 3$

简化一下：

$3 \times 2 \times 4 \times 3 \times 2 = 2^4 \times 3^2$

发现一个规律：**所有完全平方数，将其质因数分解后每个质因子的指数都为偶数**。

那就好办了，将需要判断的数进行质因数分解，并判断指数就行了。

但问题又来了，这样做的时间复杂度是 $O(n^2)$ 的，所以要前缀和优化。

但问题又又又来了，前缀和我们存不下。

注意，我们只需要判断质因子指数的奇偶即可，自然可以想到使用**异或前缀和**，如果数组里有 $s_i = s_j$，那就说明区间 $[i+1,j]$ 的乘积没有指数为奇数的质因子。

然后使用`map`记录之前有几个异或前缀和数组中的数与这次计算出的数相等，就得到了正确时间复杂度的代码。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100005],ans2;
int s[100005];
//异或前缀和
unordered_map<int,int> mp;
//使用不排序的unordered_map，比map快
int w(int rp){
    int l=2,ans=0;
    while(rp>1){
        if(l*l>rp) break;
        //为了优化时间复杂度
        while(rp%l==0){
            ans^=(int)pow(2,l);
            rp/=l;
        }
        l++;
    }
    if(rp-1) ans^=(int)pow(2,rp);
    return ans;
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    mp[0]=1;
    for(int i=1;i<=n;i++){
        s[i]=w(a[i])^s[i-1];
        ans2+=mp[s[i]];
        //可以匹配的数量就是答案应当增加的数量
        mp[s[i]]++;
        //map统计
    }
    cout<<ans2;
    return 0;
}
```

时间复杂度：

对单个数质因数分解为 $O(\sqrt{a_i})$，`unordered_map`的时间复杂度正常情况下相对于质因数分解较低，因此总时间复杂度为：

$$O(\sum_{i=1}^{n} \sqrt{a_i})$$

---

## 作者：Dtw_ (赞：0)

# Solution
考虑一个完全平方数的所有质因子的指数都是偶数，容易想到处理一个前缀积进行这个操作，但是前缀积太大了，存不下，所以只需要处理每个数分解后质因子的指数。

考虑将这个质因子的指数压成一个 01 串，$1$ 表示这个质因子的指数是奇数，$0$ 表示偶数，然后对于这个计数。

具体计数就是你要找到一个在当前积之前的积，然后找到每一位奇偶性都和当前相同的数，然后计数就行。
# Code

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n' 

#define int long long

#define fi first
#define se second

#define pii pair<int, int>

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const int INF = 0x3f3f3f3f3f3f3f3f;

const int P = 998244353;

const int N = 1e6 + 10;

int n, a[N], res;

int p[] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

unordered_map<int, int> f;

signed main()
{
    cin >> n;
    f[0] = 1;
    int cur = 0;
    for(int i=1; i<=n; i++)
    {
        int x;
        cin >> x;
        for(int j=1; j<=10; j++)
        {
            while(x % p[j] == 0) cur ^= (1 << j), x /= p[j];
        }
        res += f[cur];
        f[cur]++;
    }
    cout << res;
    return 0;
}
```

---

## 作者：luxiaomao (赞：0)

## [P10724](https://www.luogu.com.cn/problem/P10724) 简单数学题

### Problem

给出长 $n$ 的正整数序列 $a_i$，求出该序列中有多少个区间，满足该区间内所有数的乘积是完全平方数。

### Solution

$n \le 10^5$，显然不能 $O(n^2)$ 暴力。

发现乘积会很大，我们考虑质因数分解（$a_i \le 30$，这个范围内只有十个质数），记 $cnt_{i,j}$ 为 $a_i$ 的质因子中有几个质数 $j$。

如果一个数 $a_i$ 是完全平方数，显然所有的 $cnt_{i,j}$ 都是偶数。

这个结论同样可以拓展到乘积，如果 $\prod\limits_{i=l}^ra_i$ 是完全平方数，所有的 $\sum\limits_{i = l}^ra_{i,j}$ 都是偶数。

考虑根据奇偶性进行前缀和，两个前缀和相同就为答案增加一个贡献。

如何快速判断前缀和是否相同？发现只有十个质数，那么我们简单状压一下就行了，当然暴力也不是不行，复杂度吃得消。

具体实现请看代码。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;

int n,a[N];
int p[] = {114514,2,3,5,7,11,13,17,19,23,29},tot = 10;

int sum[N][15];
int cnt[1100],ans;

signed main()
{
	scanf("%lld",&n);
	for(int i = 1;i <= n;i++)
	{
		scanf("%lld",&a[i]);
		for(int j = 1;j <= 10;j++)
			while(a[i]%p[j] == 0)
				sum[i][j]++,a[i]/=p[j];
	}
	cnt[0]++;
	for(int i = 1;i <= n;i++)
	{
		int k = 0;
		for(int j = 1;j <= 10;j++)
			sum[i][j] += sum[i-1][j];
		for(int j = 1;j <= 10;j++)
			k = k*2 + sum[i][j]%2;
		ans += cnt[k]++;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


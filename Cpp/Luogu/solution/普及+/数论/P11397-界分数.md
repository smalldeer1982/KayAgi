# 界分数

## 题目背景

[标分数](https://www.luogu.com.cn/problem/P8319)

## 题目描述

定义函数 $f(x)$：

有一个 $\frac{0}{x}$ 的分数。你可以进行以下两种操作直到这个分数为 $1$：

1. 分子 $+1$，然后如果这个分数可以约分，约分到最简形式。
2. 分子分母同时 $+1$，然后如果这个分数可以约分，约分到最简形式。

$f(x)$ 的值为最小操作次数。

给定 $n$，求 $\sum\limits_{i=1}^n f(i) \bmod 998244353$。

## 说明/提示

【样例解释】

$f(1)=1$，$f(2)=2$，$f(3)=3$，$f(4)=3$（$\frac{1}{4}\rightarrow\frac{1}{2}\rightarrow 1$）。

【数据范围】

对于全部数据，$1\le n \le 10^{18}$。

**本题采用捆绑测试。**

| Subtask 编号 | 特殊性质 | 分值 |
| -----------: | -----------: |-----------: |
| 0 | $n=5$ | $5$ |
| 1 | $n\le 10$ | $20$ |
| 2 | $n\le 10^3$ | $40$ |
| 3 | $n\le 10^6$ | $25$ |
| 4 | 无特殊性质 | $10$ |



## 样例 #1

### 输入

```
4```

### 输出

```
9```

## 样例 #2

### 输入

```
114```

### 输出

```
785```

## 样例 #3

### 输入

```
114514```

### 输出

```
1930181```

# 题解

## 作者：yummy (赞：15)

## 结论

第一步纯分子 $+1$。从 $\dfrac{1}{x}$ 开始，每次：

- 若 $x$ 是奇数，则分子和分母都 $+1$。
- 若 $x$ 是偶数，则分子 $+1$。

这样，每次 $x$ 都会变成 $\lceil x/2 \rceil$，总步数为 $\lceil \log_2 x\rceil+1$。

## 感性理解的缺陷

一个常见的感性理解是：

- 由于 $\dfrac{\log_2 n}{n-1}$ 在 $n=2$ 时取最大值，因此每次约分约掉 $2$ 的“性价比”是最高的。
- 约掉相同的 $\gcd$，约分的时机越早，$+1$ 次数越小。

然而这些感性理解有一些问题，包括但不限于：

- 完全没有考虑约分后分子不是 $1$ 的情形，如 $\dfrac{1}{5},\dfrac{2}{5},\dfrac 3 5,\dfrac 2 3, \dfrac 1 1$ 这种路径为什么一定不优。
- 背包问题告诉我们，性价比最大不代表总价值最大。
- 事实上，如果初始分子不是 $1$，结论完全不长这样，但是你能写一个类似的“感性理解”出来，说明确实还有逻辑漏洞。

出题人也给过我一些补丁，但是打上补丁之后，因为无法穷尽所有可能的策略，所以仍然有一些新问题。

## 参考证明

下面的论证均从 $\dfrac{1}{x}$ 开始。

设 $a_i$ 为第 $i$ 步 $+1$ 前的分母，$b_i$ 为第 $i$ 步 $+1$ 前的分子，并且最优方案用了 $n$ 步。

根据定义，$a_1=x$，$b_1=1$，且 $a_n=b_n=1$，并且：

- $\forall 1\le i<n$，存在 $1\le k_i<b_{i}+1$ 使得 $b_{i+1}=\dfrac{b_i+1}{k_i}$（分子固定 $+1$）
- 此时必有 $\dfrac{a_i}{k_i}\le a_{i+1}\le \dfrac{a_{i}+1 }{k_i}$。

**Lemma** $\sum\limits_{i=1}^{n-1} k_i \le 2n-2$。

**Proof** 依题意，$b_{i+1}k_i = b_i+1$，得到 $b_{i+1}(k_i-1) = b_i-b_{i+1}+1$，从而 $k_{i}-1\le b_i-b_{i+1}+1$。把 $-1$ 移项后对两边求和，有 $\sum\limits_{i=1}^{n-1} k_i \le b_1-b_n + (2n-2)=2n-2$。

**Proof of theorem** 由数学归纳法，有 $x=a_1 \le \prod\limits_{i=1}^{n-1} k_i$。只需证明所有 $k_i$ 都是 $2$ 的时候，$\prod\limits_{i=1}^{n-1} k_i$ 最大，就可以证明 $n\ge \lceil \log_2 x \rceil$。

若有的 $k_i$ 不是 $2$，由于所有 $k_i$ 总和是 $2n-2$，则至少存在一对 $k_p=1,k_q>2$。此时 $(k_p+1)(k_q-1)=k_pk_q+(k_q-k_p-1) >k_pk_q$，从而这个 $k_i$ 不是最大的。

由于 $2n-2$ 的划分方案数是有限的，因此最大值必然存在。从而，最大值在 $k_i$ 全是 $2$ 时取到。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long Mod=998244353;
int main(){
	long long n,ans=1;
	scanf("%lld",&n);
	for(int i=0;i<=61;i++){
		long long l=(1ll<<i)+1,r=min(n,2ll<<i);
		if(l>n)break;
		ans=(ans+(r-l+1)%Mod*(i+2))%Mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：DeepSkyCore (赞：9)

证明一下操作次数是最优的：

感觉不如归纳法。

对于 $p=\frac{a}{b}, 1\le a\le b$，定义 $f(\frac{a}{b})=\lceil \log_2 \frac{b}{a} \rceil$。

这个函数取得最小值 $f(x)=0$ 当且仅当 $x=1$。

设 $p$ 在一次操作后变为 $q$，下证 $f(p)\le f(q)+1$：

由于 $f$ 单调不升，由 $\frac{b+1}{a+1}\ge \frac{b}{a+1}$ 有 $f(\frac{a+1}{b+1})\ge f(\frac{a+1}{b})$，所以我们只考虑操作 1。

设 $f(\frac{a}{b})\ge f(\frac{a+1}{b})+2$，展开 $\log$ 后，由于 $a,b\ge 1$，有：

$$
\frac{2a}{b}\lt \frac{a+1}{b} \\
2a\lt a+1 \\
a\lt 1
$$

这显然是错的。因此原命题成立。

---

所以我们得出结论：一次操作后 $f(p)$ 的值最多减 1。

而当 $a=1$ 时我们存在一种方式，使得每次操作 $f(p)$ 都减 1：

- 若 $b$ 是奇数执行操作 2，否则执行操作 1。

而当 $f(p)=0$ 时，可以发现 $p$ 的值只可能是 $1$。

综上我们证明了，对于 $p=\frac{1}{b}$，它的最小操作次数是 $f(p)$。

由于一开始分子是 $0$，所以要先执行一个操作才能套用如上结论。显然我们应该执行操作 1。

因此对于 $\frac{0}{x}$，操作次数下界是 $\lceil \log_2 x\rceil+1$。

---

## 作者：CleverLiu (赞：2)

本人数学去年 12 月确实不好，提供一个比较笨的办法，供大家参考。

首先考虑 $n\le10$ 的情况。设计两个状态，分子 $x$ 和分母 $y$。依题意模拟即可，猜想最终情况的最简分数执行操作数不超过 1000 ，实际上可以任意选一个比较大的数字。

```cpp
ull dfs(ull x, ull y, ull step) {
	if (x == y) return step;
	if (step > 1e3) return 0x3f3f3f3f3f;
	ull gcd = __gcd(x,y);
	x /= gcd,y /= gcd;
	return min(dfs(x + 1, y + 1, step + 1), dfs(x + 1, y, step + 1));
}
```

或许聪明的你会想到打表，这时候我们发现答案形成了一个有趣的形式。

![](https://cdn.luogu.com.cn/upload/image_hosting/sei8r64d.png)

通过进一步分析，我们发现对于每个步数 $k\ge3$，有 $2^{k-2}$ 个数字。所以我们可以将 $n$。分解为若干个完整组和一组可能的不完整组。

完整组：每组 $k$ 的数目为 $2^{k-2}$。

不完整组：当前 $k$ 的数目为 $(n - w) * k$。其中 $n$ 为题目条件， $w$ 为已处理部分数目。

当时赛时得出了答案，但是为什么最后 Substack #5 全 `TLE` 了呢？只有 90 分。肯定是爆 `long long` 了。试着用 `unsigned long long`。发现只多对了 2 个测试点。试着用 `__int128` 来做中间运算但是不用来保存答案和输出，终于 `AC` 。

因为公式的限制，所以 $n<10$ 的部分还是打表或者暴力~~才不是没有把式子推全~~。

下面是 $n\ge10$ 部分的代码。

```cpp
ull i = 2, sum = 1;
while (t + 1 << (i - 2)) <= n) {
    t += 1 << (i - 2);
    sum = (sum + (i * (1 << (i - 2)))) % mod) % mod;
    i++;
}
sum = (sum + (((n - t - 1) * i) % mod)) % mod;
```

温馨提示，复制代码不可以满分，但理解题解之后可以。

---

## 作者：wzy0 (赞：1)

对于初始值 $\frac{0}{x}$。 \
首先，第 $1$ 步肯定是分子加 $1$。

然后我们考虑选择一个数作为约分的公因数，假设为 $y$。 \
由于分子是 $1$，所以每次需要让分子加 $y - 1$ 次。

所以答案的期望大约为：
$$ (y-1) * \lceil \log_y n \rceil$$

人眼一下看不出来最优解，所以使用绘图软件：
![](https://cdn.luogu.com.cn/upload/image_hosting/3xna33oq.png)
我们发现，$y = 2$ 时最优。

#### 所以，我们得出结论
- 若 $x$ 是奇数，则分子分母 $+1$。
- 若 $x$ 是偶数，则分子 $+1$。 \
每次操作后 $x \gets \lceil \frac{x}{2} \rceil$，则总步数为 $1 + \lceil \log_2 x \rceil$。

所以我们枚举最高位，计算个数及贡献。 \
**记得 $\bmod 998244353$。**

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

const long long mod=998244353;
long long n,l,r,t,an;

int main(){
	ios::sync_with_stdio(0);cin.tie();cout.tie();
	cin>>n;an=1;
	for(int i=0;i<62;i++){
		l=(1ll<<i)+1;r=min(2ll<<i,n); 
		if(l>n)break;
		t=(r-l+1)%mod*(i+2)%mod;
		an+=t;an%=mod;
	}
	cout<<an;
	return 0;
}

```

---

## 作者：Noah03 (赞：1)

### 题意

---

给定一个函数 $f(x)$，求 

$$\sum_{i=1}^{n} \limits f(i) \ \bmod 998244353$$

其中 $f(x)$ 的定义如下：

有一个分数，值为 $\frac{0}{x}$。你可以进行以下两种操作直到这个分数为 $1$：

1. 分子 $+1$，然后如果这个分数可以约分，约分到最简形式。
2. 分子分母同时 $+1$，然后如果这个分数可以约分，约分到最简形式。

$f(x)$ 的值为最小操作次数。

### 分析

---

首先暴力枚举次数肯定是会超时的。

我们可以考虑如下贪心策略：

首先将分子加 $1$。

1. 若分母是奇数，选择操作 $2$，并把分子和分母约去 $2$。

2. 若分母是偶数，选择操作 $1$，并把分子和分母约去 $2$。

但题目中的数据范围是 $1 \leq n \leq 10^{18}$，这种方法只能通过 $90\%$ 的测试点。所以我们考虑优化。

因为每次操作都会将分子和分母除以 $2$，所以 $f(x)=\lceil\log_2x\rceil+1$（加 $1$ 是因为前面修改了一次分子）。于是问题就转化为求 

$$\sum_{i=1}^{n} \limits \lceil\log_2i\rceil+1$$

看上去这个式子只能用 $O(n)$ 求解，但是求和中有 $\lceil\log_2i\rceil$，这是 $i$ 在二进制表示下的位数，我们可考虑采用二进制分组的方法求解。

具体方法：

首先，把二进制表示长度 $len$ 满足 $len\in[1,n]$ 的挑出来。对于每个 $len$，每次定义一个 $L$ 和 $R$，其中 $L=2^{len-1},R=\min\{2^{len}-1,n\}$（$R$ 要小于等于 $n$ 是因为求和的范围只到 $n$），$L$ 代表二进制表示下长度为 $i$ 的最小值，同理 $R$ 表示最大值。所以长度为 $len$ 时的答案即为 $(R-L+1) \times len$。最后将答案累加起来即为最终答案。

注意：

1. 要开 `long long`；
2. 注意取模。

### 代码

---

请勿抄袭。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=998244353;
int main(){
	ll n;
	scanf("%lld",&n);
	ll ans=0;
	for(ll l=1,r=1,cnt=1;l<=n;l=r+1,r=min(r*2,n),cnt++){
		ans=(ans%mod+(r-l+1)%mod*cnt%mod)%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

$$\text{The End.}$$

---

## 作者：Z_301 (赞：1)

首先，可以简单说明 $f(x)\le \lceil \log _2x\rceil+1$：

- 一种合法的操作方案：先令分子加一。然后每次如果分母是奇数就都加一，否则分子加一。

接下来我们说明 $f(x)\ge \lceil \log _2x\rceil+1$。

对于一种操作方案，记第 $i$ 次操作约分时分子分母同时除以了 $k_i$。可以发现：

1.  $\prod k_i\ge x$，否则即使分母没有变大也无法让分母变为一。
2. 第 $i$ 次操作，分子至少减少了 $k_i-1$，而最后分子是 $1$，所以操作数不低于 $1+\sum k_i-1$。

记最优方案得到的 $\sum k_i-1$ 为 $s$，所有满足 $k_i\ge1$ 且 $\prod k_i\ge x$ 的序列 $\{k_i\}$ 中 $\sum k_i-1$ 最小值为 $l$，可以发现 $f(x)\ge 1+s\ge 1+l$，这是因为后者总是包含前者。

假设我们已经获得了 $\sum k_i-1$ 最小的 $\{k_i\}$，如果存在一个 $k_i>2$，那么把它换成若干个 $2$ 可以使 $\prod k_i$ 更大，显然也是合法的。这是因为在 $x>2$ 时，$x\le 2^{x-1}$（可以用一些数学知识自行分析）。

那么可以得到，存在一个 $\{k_i\}$ 满足 $\prod k_i\ge x$ 且 $\sum k_i-1$ 最小，满足所有 $k_i\le 2$。由此可得 $l=\lceil \log _2x\rceil$。

综上，$f(x)\ge l+1=\lceil \log _2x\rceil+1$。所以 $f(x)=\lceil \log _2x\rceil+1$。

---

## 作者：jiangyunuo (赞：0)

本题我将以比赛时我的思路来告诉你解法。（[题目意思](https://www.luogu.me/paste/amqo1rqc#)）
### 第一思路：
看了前两套测试点，打表是个好办法（仅限于前两套测试点）：

我就拿广搜为例，主要就是利用广搜对不同情况进行模拟，之后用辗转相除求最大公因数，判断分数值是否到 $1$，选择是否返回。感兴趣的读者可以研究一下，虽然这不是本文的重点：

```cpp
#include<bits/stdc++.h>
using namespace std;
int zzxc(int a,int b){    //辗转相除求最大公因数。
	int c;
	c=b%a;
	if(c!=0)return zzxc(c,a);
	else return a;
}
int bfs(int x){
	queue<int>p;
	queue<int>q;
	int a=0,b=1;   //a 负责计算答案，即操作次数。b 代表每一次操作的考虑情况，之所以初始值为一，是因为这个分数一开始是 0/x 的情况，就一种情况，由于每种情况都会有两种操作，也就是说每一轮操作后，b 在就会乘二，即要考虑的操作情况是上一轮的两倍。同一轮的每种考虑情况的操作次数是相同的，所以 a 每过一轮才加一。
	int l,r,ll,rr,m,n;
	p.push(0);
	q.push(x);    //初始化分数。
	while(1){
		a++;
		for(int i=1;i<=b;i++){
			l=p.front();
			r=q.front();
			ll=l;
			rr=r;
			l+=1;
			m=zzxc(l,r);
			l/=m;
			r/=m;
			if(l==r)return a;    //模拟分子加一。
			p.push(l);
			q.push(r);
			ll+=1;
			rr+=1;
			n=zzxc(ll,rr);
			ll/=n;
			rr/=n;
			if(ll==rr)return a;   //模拟分子分母同加一。
			p.push(ll);
			q.push(rr);
			p.pop();
			q.pop();
		}
		b*=2;
	}
}
int main(){
	int n;
	cin>>n;
	long long ans=0;
	for(int i=1;i<=n;i++){
		ans+=bfs(i);
	}
	cout<<ans<<endl;
	return 0;
}
```

以上代码是直接求答案的，一下是我根据代码给出的表格（其实懂上面代码，那这一部分其他内容可以不用看了）。

|$x$ 的值|$f(x)$ 的值|
|:-:|:-:|
|$1$|$1$|
|$2$|$2$|
|$3$|$3$|
|$4$|$3$|
|$5$|$4$|
|$6$|$4$|
|$7$|$4$|
|$8$|$4$|
|$9$|$5$|
|$10$|$5$|

于是：

```cpp
#include<bits/stdc++.h>  
using namespace std;
int main(){
	int n;
	cin>>n;
	if(n==1)cout<<1<<endl;
	else if(n==2)cout<<3<<endl;
	else if(n==3)cout<<6<<endl;
	else if(n==4)cout<<9<<endl;
	else if(n==5)cout<<13<<endl;
	else if(n==6)cout<<17<<endl;
	else if(n==7)cout<<21<<endl;
	else if(n==8)cout<<25<<endl;
	else if(n==9)cout<<30<<endl;
	else if(n==10)cout<<35<<endl;
    return 0;
}
```

但是，这样肯定超时，咱们往下看。

### 第二思路：

在刚才打表的过程中，同时参照[标分数](https://www.luogu.com.cn/problem/P8319)，我发现：每次约分前好像分子和分母的最大公因数都是 $2$，既然这样，我们就可以写个循环模拟下（$x$ 是分子，$y$ 是分母）：


```cpp
while(x!=y){       //设置条件，当 x==y 时，这个分数为 1，一次循环就是一次操作。
    if(x%2||x)x++;   //有两种情况，x 要增加。
    if(y%2&&y!=1)y++;   //有两种情况都满足，y 要增加，y!=1 是特判，y 都为 1 了，就无需增加了。
    x/=2;
    y/=2;       //约分。
    ans++;     //记录操作次数。
}
```

话说 $x$ 和 $y$ 可以分开操作，但题目不行，解释下为什么可以这么做（此处的偶数不包含 $0$）：

1. 当 $x$ 为奇数，$y$ 为偶数：一次符合的操作，$x+1$。
2. 当 $x$ 为偶数，$y$ 为奇数：不存在，由于 $x$ 和 $y$ 的最大公因数一到 $2$ 就约分了，$x=2$ 只会在操作一半还没约分时出现，$x$ 只会为 $0$ 或 $1$（上文的代码 $x=0$ 的情况特判了）。
3. 当 $x$ 为偶数，$y$ 为偶数：不存在。
4. 当 $x$ 为奇数，$y$ 为奇数数：一次符合的操作，$x+1$，$y+1$。

所以明白了吧，你这也得明白 $x$ 与 $y$ 的最大公因数为 $2$。要知道，一个分数分母越小，按相同的方式改变分子，分数值变化越大。那我肯定是能约分，就直接约分，毕竟每一次约分都会让分母变小，从而让分数值变化更大。假若我可以约分却不约分，那下一次操作分数值变化就没直接约分的大了，而我们的目标就是让分数值从 $0$ 变为 $1$，要次数最小，每次分数值变化就得确保最大。

有了核心，代码也跟着给了：

```cpp
#include<bits/stdc++.h>  
using namespace std;
int main(){
	int n,ans=0;
	int x,y;
	cin>>n;
	for(int i=1;i<=n;i++){  //循环求解
		y=i;
		x=0;
		while(x!=y){
			if(x%2||x)x++;
			if(y%2&&y!=1)y++;
			x/=2;
			y/=2;
			ans++;
		}
	}
	cout<<ans<<endl;
    return 0;
}
//备注：此代码没有取模，但对于前四个测试点已经够用了。
```

虽然这想法没问题，但这对前四套测试点有用，第五套会超时，因为 $n=10^{18}$ 太大了，会超时，不慌，接着看。

### 第三思路：

数据这么大，这是道数学题无疑了。

可，规律在哪呢？

经过我反复观察，终于，我发现了。

我通过查看各个 $f(x)$ 的值，发现了如下结果：

|$f(x)$ 的值，后文用 $a$ 表示|等于这个值的 $x$ 的数量（单位：个），后文用 $b$ 表示|
|:-:|:-:|
|$1$|$1$|
|$2$|$1$|
|$3$|$2$|
|$4$|$4$|
|$5$|$8$|
|$6$|$16$|
|$7$|$32$|
|$8$|$64$|
|$\dots$|$\dots$|

看出来了吧，对于 $f(x)$ 为 $m$ 的 $x$ 的数量，其值为 $2^{m-2}$（除了 $f(x)$ 为 $1$ 的情况，算个特例），且我们可以发现，这些 $x$ 都是连在一起的，如：满足 $f(x)$ 为 $4$ 的 $x$ 是 $5、6、7、8$，以此类推。

于是，我们可以通过这个表格，来计算结果，如 $n=7$ 时（注，之后我讲的 $n$ 并非题目中的 $n$ 其实是表示未计算的 $f(x)$ 的数量），我们先看表格第一行，满足 $f(x)=1$ 的 $x$ 只有一个，答案累计为 $1 \times 1 = 1$（这里的意思是），且剩下的 $n$ 为 $6$，接着看第二行，满足 $f(x)=2$ 的 $x$ 也只有一个，答案累计为 $1 + 2 \times 1 = 3$，且剩下的 $n$ 为 $5$，再看第三行，满足 $f(x)=3$ 的 $x$ 有两个，答案累计为 $3 + 3 \times 2 = 9$，且剩下的 $n$ 为 $3$，最后看第四行，满足 $f(x)=4$ 的 $x$ 有四个，但是由于 $n$ 只剩三，所以答案累计为 $9 + 4 \times 3 = 21$，且剩下的 $n$ 为 $0$，答案就为 $21$，是不是很简单，其它 $n$ 的情况也以此类推。

接着，我们就能得出代码：

```cpp
#include<bits/stdc++.h>  
using namespace std;
const int N=998244353;
int main(){
	long long n,a=2,b=1,c=1;   //n 的意思见题目，a 和 b 见前文，初设定其实是 f(x)=2 的情况。
	unsigned long long ans=1;  //ans 是答案。
	cin>>n;
	n--;  //和前文一样情况的初设定。
	while(n>0){     //循环内容可以参考前文举的例子用的运算方法。
		if(c>n)b=n;
		b%=N;   //取模。
		ans+=b*a;
		n-=c;
		a++;  //这一行和下一行你可以看成是切换行数。
		b*=2;
		c*=2;   //由于 b 是会被取模的，让 b 来算 n 的值并不正确。 
		ans%=N;   //取模。
	}
	cout<<ans<<endl;
    return 0;
}
```

这是[正确的](https://www.luogu.com.cn/record/194480703)。不过，这里还要证明一下为什么会有这个表格，根据第二思路，我们可以知道，分子与分母约分时最大公因数为 $2$，并且每种情况都是操作一次就约分一下（除了分子为 $0$ 时），你仔细想想，如果这样的话，一个 $\frac{0}{x}$ 约了 $z$ 次分（也就进行了 $z+1$ 次操作），则 $x$ 最多就为 $2^z$，同时最小为 $2^{z-1}+1$（毕竟再小约分次数就不到 $z$ 次了，很好理解吧），接着想一想也不难想到约了 $z$ 次分的 $x$ 就有 $2^z - 2^{z-1} - 1 + 1 = 2^{z-1}$ 个，即操作为 $z+1$ 次的 $x$ 有这么多个，也就得到了上文的结论，懂了吧。

---


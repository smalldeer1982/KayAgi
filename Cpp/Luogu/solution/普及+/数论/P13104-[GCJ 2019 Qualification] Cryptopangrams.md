# [GCJ 2019 Qualification] Cryptopangrams

## 题目描述

在 Code Jam 团队中，我们喜欢互相发送全字母短语（pangram），即包含英语字母表中每个字母至少一次的短语。一个常见的例子是 “the quick brown fox jumps over the lazy dog”。有时我们的全字母短语中包含机密信息，例如 `CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS`，因此我们需要保证它们的安全。

我们翻看了一本密码学教材几分钟，了解到分解两个大质数的乘积非常困难，于是我们基于这个事实设计了一种加密方案。首先，我们做了一些准备：

- 我们选择了 $26$ 个不同的质数，且每个质数都不大于某个整数 $N$。
- 我们将这些质数按升序排列。然后，将最小的质数分配给字母 $A$，第二小的分配给 $B$，以此类推。
- 团队中的每个人都记住了这份列表。

现在，每当我们想要发送一个全字母短语作为消息时，我们首先去除所有空格，形成明文消息。然后，我们记录下明文第一个字母对应的质数与第二个字母对应的质数的乘积。接着，记录第二个和第三个字母对应质数的乘积，依此类推，直到倒数第二个和最后一个字母对应质数的乘积。这个新的数值列表就是我们的密文。密文中的数值个数比明文字符数少 $1$。

例如，假设 $N = 103$，我们选择了前 $26$ 个奇质数，因为我们担心偶数太容易分解。那么 $A = 3$，$B = 5$，$C = 7$，$D = 11$，以此类推，直到 $Z = 103$。又假设我们想加密上面的全字母短语 `CJ QUIZ KNOW BEVY OF DP FLUX ALGORITHMS`，那么明文为 `CJQUIZKNOWBEVYOFDPFLUXALGORITHMS`。此时密文的第一个数值是 $7$（`C` 对应的质数）乘以 $31$（`J` 对应的质数）$= 217$；下一个数值是 $1891$，以此类推，最后一个数值是 $3053$。

我们会给你一个密文消息和我们使用的 $N$ 的值。我们不会告诉你用的是哪些质数，也不会告诉你如何解密密文。你能否恢复出明文呢？

## 说明/提示

**限制条件**

- $1 \leq T \leq 100$。
- $25 \leq L \leq 100$。
- 明文包含每个英文字母至少一次。

**测试点 1（10 分，可见）**

- $101 \leq N \leq 10000$。

**测试点 2（15 分，隐藏）**

- $101 \leq N \leq 10^{100}$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543```

### 输出

```
Case #1: CJQUIZKNOWBEVYOFDPFLUXALGORITHMS
Case #2: SUBDERMATOGLYPHICFJKNQVWXZ```

# 题解

## 作者：_hud (赞：1)

# 题解：[P13104 \[GCJ 2019 Qualification\] Cryptopangrams](https://luogu.com.cn/problem/P13104)

## 题目大意

给定整数 $N$ 和长度为 $L$ 的密文序列，每个密文是相邻两个字母对应质数的乘积。已知：

1. 使用 $26$ 个不超过 $N$ 的不同质数，按升序依次对应字母 $\texttt{A}$ 至 $\texttt{Z}$。
2. 明文是包含所有字母的全字母句。
3. 密文序列 $c_i$ 由相邻字母对应质数 $p_i$ 和 $p_{i+1}$ 的乘积组成。

求长度为 $L+1$ 的明文字符串。

## 思路

由题意，设明文对应的质数序列为 $p_0, p_1, \dots, p_L$，则密文满足：

$$
c_i = p_i \times p_{i+1} \quad (0 \leq i < L)
$$

从题意出发寻找突破口，我们令 $c_k \neq c_{k+1}$。由题意得：

- $c_k = p_k \times p_{k+1}$
- $c_{k+1} = p_{k+1} \times p_{k+2}$

故容易得到：

$$
\begin{aligned}
p_{k+1} = \gcd(p_k \times p_{k+1},\ p_{k+1} \times p_{k+2}) = \gcd(c_k,\ c_{k+1})
\end{aligned}
$$

这样我们就寻找到了一个质数。

计算出 $p_{k+1}$ 的值后，容易递推出 $p_0, p_1, \dots, p_L$ 的值。得到所有质数后，我们将所有不同的质数升序排序，并与字母 $\texttt{A}$ 至 $\texttt{Z}$ 一一对应。

然后按题意模拟即可。
时间复杂度 $O(L \log \max(c_i))$。

分析完思路，再来讲讲实现。注意到数据范围 $N \leq 10^{100}$，需要使用高精度算法，而本蒟蒻不会，怎么办？

Python 大法好。

## 代码

```py
def gcd(a : int, b : int):
    return a if b == 0 else gcd(b, a % b)
def sol(case):
    l = int(input().split()[1])
    c = list(map(int, input().split())) # 存储密文
    ps = [0] * (l + 1) # 存储质数序列
    idx = -1
    # 查找第一个相邻不等的位置
    for idx in range(l - 1):
        if c[idx] != c[idx + 1]:
            break
    g = gcd(c[idx], c[idx + 1])
    ps[idx + 1] = g; ps[idx] = c[idx] // g # 计算出一个质数
    # 递推
    for i in range(idx - 1, -1, -1): ps[i] = c[i] // ps[i + 1]
    for i in range(idx + 1, l): ps[i + 1] = c[i] // ps[i]
    h = {} # 建立质数到字母的映射
    for i, p in enumerate(sorted(set(ps))):
        h[p] = chr(i + 65)
    print("Case #%d: %s" % (case, ''.join(h[p] for p in ps)))
if __name__ == "__main__": 
    t = int(input())
    for _ in range(0, t): sol(_ + 1)
```

---


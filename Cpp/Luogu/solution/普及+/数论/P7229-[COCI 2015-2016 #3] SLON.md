# [COCI 2015/2016 #3] SLON

## 题目描述

小 Q 在学校里非常调皮。

他上课时总是很无聊，他总是把课堂弄得一团糟。老师希望让他冷静下来，所以给他出了一道很难的数学题。

老师给小 Q 一个算术表达式 $A$、整数 $P$ 和 $M$，小 Q 要回答的是以下问题：

> 求最小非负整数  $x$，使含  $x$ 的表达式  $A$ 除以  $M$ 余数等于  $P$。

注意每一个运算符均会连接两个数或是变量。每一个乘号都不会省略且不允许连接两个含有 $x$ 的表达式。括号均合法，可能存在括号内容仅有一个数或变量的情况。

题目保证原表达式化简后一定能写成一个形如 $kx+b$ 的一元一次式。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据：
- 令 $|A|$ 为字符串 $A$ 的长度，那么 $1 \le |A| \le 10 ^ 5$。
- 表达式 $A$ 中仅会有 $\texttt{+}$，$\texttt{-}$，$\texttt{*}$，$\texttt{(}$，$\texttt{)}$，$\texttt{x}$，和 $\texttt{0}$ $\sim$ $\texttt{9}$。
- $0 \le P \le M - 1$。
- $1 \le M \le 10 ^ 6$。

#### 说明
翻译自 [COCI 2015-2016 #3 D SLON](https://hsin.hr/coci/archive/2015_2016/contest3_tasks.pdf)，满分 120。

## 样例 #1

### 输入

```
5+3+x
9 10
```

### 输出

```
1```

## 样例 #2

### 输入

```
20+3+x
0 5
```

### 输出

```
2```

# 题解

## 作者：伟大的王夫子 (赞：11)

本题就是一个裸的中缀表达式求值。在本题中，我们可以写一个结构体，来存储表示一个数的值（$b$ 或者 $kx+b$，其中 $ k \not = 0$。

对于中缀表达式求值，有一个很好的方法就是先转化为计算机好算的后缀表达式。

那么究竟如何才能实现这个转化呢？

这里我给大家讲一个很常规的做法。

1. 建立一个用于存运算符的栈，逐一扫描该中缀表达式中的元素。
1. 如果遇到一个数，输出该数。
1. 如果遇到左括号，把左括号入栈。
1. 如果遇到右括号，不断取出栈顶并输出，直到栈顶为左括号，然后再把左括号出栈。
1. 如果遇到运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶并输出，最后把新符号入栈。优先级为乘法 > 加减法 > 左括号。
1. 依次取出并输出栈中所有剩余符号，最终输出序列就是一个与原中缀表达式等价的一个后缀表达式。

然后在求的时候，注意各个数的顺序，否则会因为减法不满足交换律而错的很惨。

```cpp
#include <bits/stdc++.h>
using namespace std;
template <class T>
inline void Rd(T &x) {
    x = 0;
    bool f = 0;
    char ch = getchar();
    while (!isdigit(ch)) f |= ch == '-', ch = getchar();
    while (isdigit(ch)) x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();
    if (f)
        x = -x;
}
typedef long long ll;
struct P {
    ll a, b;
};
ll M, PP;
P operator*(const P &a, const ll &b) {
    P c = a;
    c.a *= b, c.b *= b;
    c.a %= M, c.b %= M;
    return c;
}
P operator*=(P &a, const ll &b) {
    a = a * b;
    return a;
}
P operator+(const P &a, const P &b) {
    P c;
    c.a = a.a + b.a, c.b = a.b + b.b;
    c.a %= M, c.b %= M;
    return c;
}
P operator+(const P &a, const int &b) {
    P c;
    c.a = a.a, c.b = a.b + b;
    c.b %= M;
    return c;
}
P operator-(const P &a, const int &b) {
    P c;
    c.a = a.a, c.b = a.b - b;
    c.b = ((c.b + M) % M + M) % M;
    return c;
}
P operator-(const P &a, const P &b) {
    P c;
    c.a = ((a.a - b.a + M) % M + M) % M;
    c.b = ((a.b - b.b + M) % M + M) % M;
    return c;
}
string a;
struct shizi {
    ll x;
    P a;
    char ch;
    int t;
    shizi() {
        ch = 0;
        x = 0;
    }
} b[100005], s[100005];
int m, p;
int prior(char ch) {
    if (ch == '(')
        return 1;
    if (ch == '+' || ch == '-')
        return 2;
    if (ch == '*')
        return 3;
}
ll calc(ll a, ll b, char ch) {
    if (ch == '*')
        return a * b % M;
    if (ch == '+')
        return (a + b) % M;
    if (ch == '-')
        return ((a - b + M) % M + M) % M;
}
P operator - (const int &a, const P &b) {
	P c = b;
	c.b = ((a - c.b) % M + M) % M;
	c.a = (-c.a % M + M) % M;
	return c;
}
int main() {
    ll x = 0;
    cin >> a >> PP >> M;
    for (int i = 0; i < a.size(); ++i) {
        if (a[i] == 'x') {
            b[++m].a.a = 1;
            b[m].t = 2;
            continue;
        }
        if (isdigit(a[i])) {
            x = x * 10 + (a[i] ^ 48);
            x %= M;        	
            if (i == a.size() - 1 || !isdigit(a[i + 1]))
                b[++m].x = x, x = 0, b[m].t = 1;
        } else {
            if (a[i] == '(')
                s[++p].ch = '(', s[p].t = 3;
            else if (a[i] == ')') {
                while (p && s[p].ch != '(') b[++m] = s[p--];
                if (s[p].ch == '(')
                    --p;
            } else {
                while (p && prior(s[p].ch) >= prior(a[i])) b[++m] = s[p--];
                s[++p].ch = a[i], s[p].t = 3;
            }
        }
    }
    while (p) b[++m] = s[p--];
    for (int i = 1; i <= m; ++i) {
        if (b[i].t != 3)
            s[++p] = b[i];
        else {
            shizi d = s[p], c = s[p - 1];
            shizi e;
            char ch = b[i].ch;
            if (c.t == 1 && d.t == 1)
                e.x = calc(c.x, d.x, b[i].ch), e.t = 1;
            else if (d.t == 1 && c.t == 2) {
                if (ch == '*')
                    e.a = c.a * d.x;
                if (ch == '+')
                    e.a = c.a + d.x;
                if (ch == '-')
                    e.a = c.a - d.x;
                e.t = 2;
            } else if (c.t == 2 && d.t == 2) {
                if (ch == '+')
                    e.a = c.a + d.a;
                if (ch == '-')
                    e.a = c.a - d.a;
                if (ch == '*') cout << 11;
            	e.t = 2;
            } else {
            	if (ch == '*') e.a = d.a * c.x;
            	if (ch == '+') e.a = d.a + c.x;
            	if (ch == '-') e.a = c.x - d.a;
            	e.t = 2;
			}
            p -= 2;
            s[++p] = e;
        }
    }
    P ans = s[1].a;
	for (int i = 0; i < M; ++i)
		if (((ans.a * i + ans.b) % M + M) % M == PP) {
			printf("%d", i);
			break;
		}
}
```

---

## 作者：Computer1828 (赞：4)

题意就是让你把这个式子给拆括号合并同类项搞成一个 $kx+b$ 的简单式，然后求方程 $kx+b \% m = p$ 的最小非负整数解。

如果我们设 $f(x) = kx+b$，那么就有 $f(1) = k+b,f(0) = b$，所以 $k = f(1)-f(0),b = f(0)$，题目就转化成求 $x$ 分别为 $0$ 和 $1$ 时原式的值，也就是中缀表达式求值。

处理中缀表达式，一般先把它化成后缀表达式，这个流程大致如下：

假设有一个队列用于保存输出的后缀表达式，一个栈用于存储符号。然后重复以下步骤：

1. 遇到一个数字，加进队列。
2. 遇到运算符，如果栈为空**或**栈顶是左括号**或**它的优先级比栈顶的高（括号的优先级最高），那么就把这个运算符加进栈；否则将栈顶运算符加进队列，并弹掉。
3. 遇到左括号，直接加进栈。遇到右括号，重复执行把栈顶符号移进队列直到栈顶为左括号，然后把左括号踢出栈。

这个时候，从队头到队尾就是原中缀表达式对应的后缀表达式。

对这个后缀表达式求值就能算出 $f(1)$ 和 $f(0)$，然后暴力枚举求最小 $x$。

需要注意求后缀表达式时的减号运算，减法是不满足交换律的：$a-b \neq b-a$，所以求值时遇到运算符后从栈里取的两个数顺序要反过来。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
/*
( : -1
+ : -2
- : -3
* : -4
*/
inline bool is_digit(char ch){return ch>='0' && ch<='9';}
inline ll prio(ll ch){//求符号优先级
	if(ch == -2) return 1;
	if(ch == -3) return 1;
	if(ch == -4) return 2;
}
inline ll ctd(char ch){//将符号转换成数值
	if(ch == '+') return -2;
	if(ch == '-') return -3;
	if(ch == '*') return -4;
}
char Str[100005],str[100005];
int m,p,len,cnt;
ll num[100005];
inline ll func(int x){//求 x = 1 和 x = 0 的值
	for(int i = 1;i<=len;++i){
		str[i] = Str[i];
		if(str[i] == 'x') str[i] = char(x+48);
	}
	stack<ll> opt;cnt = 0;
	for(int i = 1;i<=len;++i){//处理成后缀表达式
		char ch = str[i];
		if(is_digit(str[i])){
			ll tmp = 0;
			while(is_digit(str[i])){
				tmp = tmp*10 + (str[i]-'0');tmp %= m;
				++i;
			}
			num[++cnt] = tmp;--i;
		}else if(str[i] == '(') opt.push(-1);
		else if(str[i] == ')'){
			while(opt.top() != -1){
				num[++cnt] = opt.top();
				opt.pop();
			}
			opt.pop();
		}else{
			while(!opt.empty() && opt.top() <= -2 && prio(ctd(ch))<prio(opt.top())){
				num[++cnt] = opt.top();
				opt.pop();
			}
			opt.push(ctd(ch));
		}
	}
	while(!opt.empty()){num[++cnt] = opt.top();opt.pop();}
	
	stack<ll> ans;
	for(int i = 1;i<=cnt;++i){//算后缀表达式
		if(num[i]>=0) ans.push(num[i]);
		else{
			ll s2 = ans.top();ans.pop();
			ll s1 = ans.top();ans.pop();//注意
			switch(num[i]){
				case -2:ans.push((s1+s2)%m);break;
				case -3:ans.push((s1-s2+m)%m);break;
				case -4:ans.push(s1*s2%m);break;
			}
		}
	}
	return ans.top();
}
int main(){
	scanf("%s",Str+1);len = strlen(Str+1);
	scanf("%d%d",&p,&m);
	ll f1 = func(1),f0 = func(0);
	ll k = f1-f0,b = f0;
	for(ll i = 0;i<m;++i){
		ll s = k*i+b;
		if((s%m+m)%m == p) return printf("%lld",i),0;
	}
}
```

---

## 作者：hzxphy (赞：2)

## 题意
给定一个能够化简为函数 $f(x)=kx+b$ 的中缀表达式，求最小的 $x$ 使得 $f(x)$ 模 $m$ 为 $P$。
## 思路
~~之前喜欢用后缀表达式计算，模拟考时被卡了才知道难受。~~

### 表达式求值
本蒟蒻尝试了一下硬算中缀表达式，思路如下：
1. 如果形如 `(...)`，递归 `...`（去除括号），但是不要和 `(...)(...)(...)` 混了，需要判定一下。
2. 在序列中查找优先级最低的运算符（如有多个取第一个）。
3. 若没有一个运算符和括号，则要么为 `x`，要么为数字判定即可。

### 求 $f(x)$ 的方法：

因为直接代入特值可以用上述方法计算，我们考虑：

存在两个式子 $f(0)=b$ 和 $f(1)=k+b$，且 $f(0)$ 和 $f(1)$ 可求得。

解得 $b=f(0)$ 和 $k=f(1)-f(0)$

### 最后讲一下 $f(x)$ 已知时如何求出 $ans$：
1. 暴力枚举区间 $[0,m)$
2. exgcd 计算

综上，本题得解。
## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5;
int p,m;string s;
int u[MAXN+1],cnt=0,lk[MAXN+1];
int Calc(int l,int r,int xnum){
	// cout<<l<<' '<<r<<"TTTT\n";
	int i=upper_bound(u+1,u+1+cnt,l)-u;
	if(s[l]=='('){
		bool fg=true;
		while(u[i]<=r){
			if(lk[u[i]]>lk[l]){
				i++;
				continue;
			}
			if(s[u[i]]=='+'||s[u[i]]=='-'||s[u[i]]=='*'){
				fg=false;break;
			}
			i++;
		}
		if(fg)return Calc(l+1,r-1,xnum);
	}
	int p=-1;
	while(u[i]<=r){
		if(lk[u[i]]>lk[l]){
			i++;
			continue;
		}
		if(s[u[i]]=='+'){
			return (Calc(l,u[i]-1,xnum)+Calc(u[i]+1,r,xnum)+m)%m;
		}
		if(s[u[i]]=='-'){
			return ((Calc(l,u[i]-1,xnum)-Calc(u[i]+1,r,xnum))%m+m)%m;
		}
		if(s[u[i]]=='*')p=u[i];
		i++;
	}
	if(p==-1){
		if(l==r&&s[l]=='x')return xnum;
		int num=0;
		for(int i=l;i<=r;i++)num=(num*10+s[i]-'0')%m;
		return num;
	}
	return (1ll*Calc(l,p-1,xnum)*Calc(p+1,r,xnum))%m;
}
void exgcd(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	int tmp=x;
	x=y;
	y=tmp-a/b*y;
	return;
}
int main(){
	cin>>s;
	cin>>p>>m;
	int tmp=0;
	for(int i=0;i<(int)s.length();i++){
		if(s[i]=='+'||s[i]=='-'||s[i]=='*')u[++cnt]=i;
		lk[i]=tmp;
		if(s[i]=='('){
			lk[i]=tmp;
			tmp++;
		}
		else if(s[i]==')'){
			tmp--;
			lk[i]=tmp;
		}
		else lk[i]=tmp;
	}
	int b=Calc(0,(int)s.length()-1,0);
	int bplusk=Calc(0,(int)s.length()-1,1);
	int k=bplusk-b;
	// int k,b;cin>>k>>b;B
	// cout<<"f(x)="<<k<<"x+"<<b<<"$$$\n";
	int t=__gcd(k,-m);
	int xx,yy;
	exgcd(k,-m,xx,yy);
	long long x0=1ll*xx*(p-b)/t,y0=1ll*yy*(p-b)/t;
	// cout<<x0<<' '<<y0<<"vvvv\n";
	while(x0<0){
		if(t<0){
			x0-=m/t;
			y0-=k/t;
		}
		else{
			x0+=m/t;
			y0+=k/t;
		}
	}
	while(x0>0){
		if(t>0){
			if(x0-m/t<0)break;
			x0-=m/t;
			y0-=k/t;
		}
		else{
			if(x0+m/t<0)break;
			x0+=m/t;
			y0+=k/t;
		}
	}
	printf("%lld\n",x0);
	// cout<<b<<"***\n";
	return 0;
}
```

---

## 作者：hjyowl (赞：2)

### 题意

给定一个方程，求最小的 $x$ 使得方程在对 $m$ 取模的意义下等于 $n$。

### 思路

众所周知，由于题目保证是一个一次函数，所以说我们可以充分利用一次函数特性。

我们可以先计算 $x$ 等于 $0$ 情况下的值，这种情况 $kx+b$ 这一部分就只有 $b$，也就是我们得到了 $b$ 的值。

然后我们在计算 $x$ 等于 $1$ 情况下的值，然后把两个式子消了，得到了 $k$ 的值。

有了 $k$ 和 $b$，那么我们解决这个式子就直接用扩展欧几里得了。

至于表达式求值，该怎么做就怎么做。

---

## 作者：small_lemon_qwq (赞：2)

把表达式 $A$ 看作 $f(x)$，求出 $f(0)$ 和 $f(1)$ 就可以确定 $f(x)=kx+b$，然后 exgcd 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
string s,b;
int p,m;
int a[200];
stack<int>st;
int calc(int x,char op,int y){
    if(op=='+')return (x+y)%m;
    if(op=='-')return (x-y+m)%m;
    if(op=='*')return x*y%m;
}
int calc(string s){
    a['*']=3;
    a['+']=a['-']=2;
    a['(']=1;
    s="("+s+")";
    stringstream s2;
    while(st.size())st.pop();
    for(int i=0;i<s.size();i++){
        char x=s[i];
        if(x>='0'&&x<='9'){
            while(x>='0'&&x<='9'){
                s2<<x;
                x=s[++i];
            }
            s2<<" ";i--;
            continue;
        }else if(x=='('){
            st.push(x);
        }else if(x==')'){
            while(st.size()&&st.top()!='(')s2<<(char)st.top(),st.pop();
            if(st.size())st.pop();
        }else{
            while(st.size()&&a[st.top()]>=a[x])s2<<(char)st.top(),st.pop();
            st.push(x);
        }
    }
    s=s2.str();
    int did=0;
    string bot=s2.str();
    while(st.size())st.pop();
    for(char c:bot){
        if(c>='0'&&c<='9'){
            did=(did*10+c-'0')%m;
        }else if(c=='+'||c=='*'||c=='-'){
            if(st.size()<2)continue;
            int x=st.top();st.pop();
            int y=st.top();st.pop();
            st.push(calc(y,c,x)%m);
        }else if(c==' '){
            st.push(did);
            did=0;
        }
     }
     int x=st.top();st.pop();
     return x;
}
void exgcd(int a,int b,int&x,int&y){
    if(!b){
        x=1;y=0;
        return;
    }
    exgcd(b,a%b,y,x);
    y-=a/b*x;
    x%=m;
    y%=m;
}
signed main(){
    cin>>s>>p>>m;
    b=s;
    for(int i=0;i<s.size();i++){
        if(s[i]=='x'){
            s[i]='0';
            b[i]='1';
        }
    }
    int x=calc(s);
    int y=calc(b);
    int k=((y-x)%m+m)%m;
    int b=x;/*y=kx+b*/
    /*
    (kx+b)%m=p
    kx+b=p(mod m)
    kx=p-b(mod m)
    kx+my=p-b
    */
    int t=abs(__gcd(k,m));
    p/=t;
    b/=t;
    k/=t;
    m/=t;
    int xx,yy;
    exgcd(k,m,xx,yy);
    xx=(xx%m+m)%m;
    cout<<(xx*(p-b)%m+m)%m;
    return 0;
}
```

---

## 作者：xrtbclx (赞：1)

### 思路：
一个中缀表达式求值加暴力枚举。读入数据后，从小到大枚举 $x$，并利用栈实现中缀表达式求值。

### 实现：
#### 关于使用栈进行中缀表达式求值：
如果遇到一个数，输出该数。  
如果遇到左括号，把左括号入栈。  
如果遇到右括号，不断取出栈顶并输出，直到栈顶为左括号，然后再把左括号出栈。  
如果遇到运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶并输出，最后把新符号入栈。优先级为乘法 > 加减法 > 左括号。  
依次取出并输出栈中所有剩余符号，最终输出序列就是一个与原中缀表达式等价的一个后缀表达式。
#### 枚举：从小到大枚举 $x$，直到符合条件即可。

---


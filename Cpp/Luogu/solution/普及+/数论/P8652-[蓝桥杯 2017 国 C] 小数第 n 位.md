# [蓝桥杯 2017 国 C] 小数第 n 位

## 题目描述

我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。

如果我们把有限小数的末尾加上无限多个 $0$，它们就有了统一的形式。

本题的任务是：在上面的约定下，求整数除法小数点后的第 $n$ 位开始的 $3$ 位数。

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2017 年第八届国赛

## 样例 #1

### 输入

```
1 8 1```

### 输出

```
125```

## 样例 #2

### 输入

```
1 8 3```

### 输出

```
500```

## 样例 #3

### 输入

```
282866 999000 6```

### 输出

```
914```

# 题解

## 作者：5k_sync_closer (赞：8)

不知道为啥别的题解直接就快速幂了……感觉这个不容易看出

小数点后第 $n$ 位就是把小数点往后移 $n$ 位后的个位。

根据小学数学知识，把一个数的小数点往后移 $n$ 位相当于把这个数乘以 $10^n$。

所以 $\dfrac ab$ 的第 $n$ 位即为 $\dfrac{a\times 10^n}b$ 的个位，即 $\lfloor\dfrac{a\times 10^n}b\rfloor\bmod 10$。

推式子：

$$
\begin{aligned}
&\lfloor\dfrac{a\times 10^n}b\rfloor\bmod 10\\
=&\lfloor\dfrac{a\times 10^n}b\rfloor-10k\bmod 10\\
=&\lfloor\dfrac{a\times 10^n-10bk}b\rfloor\bmod 10\\
=&\lfloor\dfrac{a\times 10^n\bmod 10b}b\rfloor
\end{aligned}
$$

快速幂算分子即可。

注意 $10b>2^{32}$，需要龟速乘或者开 `__int128`。

```cpp
#include <cstdio>
__int128 P(__int128 x, __int128 y, __int128 M)
{
    __int128 q = 1;
    for (; y; y >>= 1, x = x * x % M)
        if (y & 1)
            q = q * x % M;
    return q;
}
__int128 a, b, n;
int main()
{
    scanf("%lld%lld%lld", &a, &b, &n);
    for (__int128 i = n; i < n + 3; ++i)
        printf("%lld", a * P(10, i, 10 * b) % (10 * b) / b);
    return 0;
}
```


---

## 作者：A_grasser (赞：7)

## 题意简化

输入三个数，求第一个数除以第二个数的小数部分中第三个数开始的三位。

## 需要注意的地方

1. 暴力算法过不了，要用更好做法。

## 解法分析

我们复习一下竖式除法的过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/vsqiv5f2.png)

### 一级解法

暴力。

思路：把被除数除以除数，每除以一次就乘十，但看了一下好像加了 hack 数据点，并且它本身也过不了，就不细说了。

### 二级解法

这道题暴力慢就慢在每次乘十太费时间了，那就引入新算法：快速幂。

#### 前置知识：快速幂（可直接跳过）

快速幂是什么？我们结合图解理解一下快速幂与普通乘法的区别:

![](https://cdn.luogu.com.cn/upload/image_hosting/5g27d0z9.png)

可能看起来没有什么区别，但是在指数较大的时候，它就比普通算法优得多。我们结合模板看一看它的实现：

```cpp
long long fpow(long long num,long long base,long long mod){//分别是底数，指数，取模值
	long long res=1;//结果
	while(base!=0){
		if(base%2==1) res=res*num%mod;//可以
		base/=2;//指数除以2
		num=num*num%mod;//将其变成它的平方
	}
	return res;
}
```
这样子的做法，结果不变，时间复杂度可以从 $O(n)$ 飞跃到 $O(\log{n})$ 的级别。初学者可能有些难以理解，慢慢学就懂了。

在比赛中快速幂是很重要的知识，应用它的题目有矩阵快速幂等等。

#### 知识讲解完毕

回到问题，我们把被除数乘十的过程用快速幂替代，就能过了。

```cpp
//已通过
#include<bits/stdc++.h>
//万能头文件
using namespace std;
long long x,y,n;
long long fpow(long long num,long long base,long long mod){//分别是底数，指数，取模值
	long long res=1;//结果
	while(base!=0){
		if(base%2==1) res=res*num%mod;//可以
		base/=2;//指数除以2
		num=num*num%mod;//将其变成它的平方
	}
	return res;
}
int main(){
	cin>>x>>y>>n;
	cout<<x*fpow(10,n-1,y)*10/y%10<<x*fpow(10,n,y)*10/y%10<<x*fpow(10,n+1,y)*10/y%10;//这三位数
	//fpow(...,...,...)就是快速幂
	return 0;
}
```

如果想让你的快速幂主体再快一点点（所谓的常数优化），可以改成这样：

```cpp
long long fpow(long long num,long long base,long long mod){//分别是底数，指数，取模值
	long long res=1;//结果
	while(base){
		if(base&1) res=res*num%mod;//可以
		base>>=1;//指数除以2
		num=num*num%mod;//将其变成它的平方
	}
	return res;
}
```
这样加快了运算速度（使用了位运算）。


最后说一句，我比较推荐万能头文件，这样可以省去很多不必要的麻烦。

## 完整代码

```cpp
//已通过
#include<bits/stdc++.h>
//万能头文件
using namespace std;
long long x,y,n;
long long fpow(long long num,long long base,long long mod){//分别是底数，指数，取模值
	long long res=1;//结果
	while(base!=0){
		if(base%2==1) res=res*num%mod;//可以
		base/=2;//指数除以2
		num=num*num%mod;//将其变成它的平方
	}
	return res;
}
int main(){
	cin>>x>>y>>n;
	cout<<x*fpow(10,n-1,y)*10/y%10<<x*fpow(10,n,y)*10/y%10<<x*fpow(10,n+1,y)*10/y%10;//这三位数
	//fpow(...,...,...)就是快速幂 
	return 0;
}
```

---

## 作者：zhiyangfan (赞：5)

### 题意
求 $\frac{a}{b}$ 小数点后第 $n,n+1,n+2$ 位处的值。($1\le a,b,n\le 10^9$)
### 题解
考虑我们做竖式除法的过程，对于当前的数 $x(x<b)$，这位得到的商是 $\lfloor\frac{10x}{b}\rfloor$，当前的数会变为 $(10x)\bmod b$。这里要求 $x<b$ 保证了商是一个 $[0,9]$ 内的整数，且由于接下来的数都是模 $b$ 的余数，所以会一直满足。（竖式除法一开始要求 $x<10b$）

然后我们来观察上述过程，本题实际上就是不断令 $x\leftarrow (10x)\bmod b$。直到到我们想要的那个位置的前一个位置，得到一个数 $y$，计算 $\lfloor\frac{10y}{b}\rfloor$ 即为答案。

由于取模的性质，我们可以得到 $y=10^kx\bmod b$。对于 $10^k\bmod b$ 的计算，我们可以使用快速幂。具体来讲，就是把 $k$ 进行二进制分解，并同时计算 $10^{2^i}\bmod b$ 来拼出答案。

时间复杂度 $\mathcal{O}(\log n)$。
```cpp
#include <cstdio>
typedef long long ll;
inline int ksm(int a, int b, int mod)
{
    int ret = 1;
    while (b)
    {
        if (b & 1) ret = (ll)ret * a % mod;
        a = (ll)a * a % mod; b >>= 1;
    }
    return ret;
}
int main()
{
    int a, b, n; scanf("%d%d%d", &a, &b, &n);
    int t = (ll)a * ksm(10, n - 1, b) % b;
    printf("%d", (int)(t * 10ll / b));
    t = t * 10ll % b;
    printf("%d", (int)(t * 10ll / b));
    t = t * 10ll % b;
    printf("%d\n", (int)(t * 10ll / b));
    return 0;
}
```

---

## 作者：Red0rangE (赞：4)

## 题意理解

给出三个整数 $a$，$b$，$n$，求出 $a \div b$ 结果的第 $n$ 位开始向后的三个数字。

## 思路阐述

模拟除法步骤，以第一个样例为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/npdm28m9.png)

重复执行 $n+2$ 位除法，对于 $a$ 不断乘以 $10$ 就是图中的补零操作，取模便是得出下一个被除数的操作。（对于第 $n$ 位、第 $n+1$ 位、第 $n+2$ 位进行输出）

**但是！注意数据范围！** 显然 $n+2$ 次的模拟过不了最坏情况，所以我们不能这么搞。

注意我们的模拟除法有许多不必要的重复操作（不断对 $a$ 乘以十补零），可以用快速幂优化。

## 代码呈现

```cpp
#include <bits/stdc++.h>
using namespace std;

long long x,y,n;

long long qsum(long long a,long long b,long long p ){//快速补零
    long long ans=1;
    while (b){
        if (b&1) ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans;
}

signed main(){
    
    scanf("%lld%lld%lld",&x,&y,&n);
    printf("%lld",x*qsum(10,n-1,y)*10/y%10);
    printf("%lld",x*qsum(10,n,y)*10/y%10);
    printf("%lld",x*qsum(10,n+1,y)*10/y%10);
    return 0;
    
}
```


希望可以帮到各位大佬。

---

## 作者：liupan2010 (赞：3)

$\texttt{Describe
}$：

求 $\dfrac{a}{b}$ 小数点后第 $n,n+1,n+2$ 位。

$\texttt{Solution}$：

因为 $n\le10^9$ 的巨大范围，所以这题不能直接用 $\Theta(n)$ 做。

所以我们先来模拟一下求小数的过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/4e2r3y0y.png)

很明显，$\dfrac{a}{b}$ 小数点后 $i$ 位可化为 $\left\lfloor \dfrac{a\times10^i}{b}\right\rfloor\bmod10$。那我们可以直接上快速幂了。

$\texttt{AC Code}$：

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int qpow(int a,int n,int b){
    int t=1;
    while(n){
        if(n&1){
        	t=t%b*a%b;
		}
        n>>=1;
        a=a%b*a%b;
    }
    return t%b;
}
signed main(){
	int a,b,n;
	cin>>a>>b>>n;
	cout<<a*qpow(10,n-1,b)*10/b%10<<a*qpow(10,n,b)*10/b%10<<a*qpow(10,n+1,b)*10/b%10;
	return 0;
}
```

---

## 作者：xueruo (赞：1)

## 题意：
求 $\frac{a}{b}$ 的小数点后 $n,n+1,n+2$ 分别为什么数字。  
## 思路:
考虑到 $n \le 10^9$，所以不能直接枚举小数点后面的数字。所以把答案转换为 $\lfloor \frac{a \times 10^{n}}{b} \rfloor $。   
这个式子是怎么推出来的呢？举个例子，$\frac{1}{4} =0.25$，小数点后 $1$ 位就是 $\lfloor \frac{1 \times 10^{1}}{4} \rfloor =2$。  
![](https://s1.ax1x.com/2023/04/29/p93P4E9.png)
再用 [快速幂](https://www.luogu.com.cn/blog/djq090705/kuai-su-mi) 计算这个式子。  
```cpp
#include<iostream>
#include<cmath>
#define int long long
using namespace std;
int a,b,n;
inline int fp(int a,int b,int mod){
	int ret = 1;
    while (b){
        if (b & 1) ret = ret * a % mod;
        a = a * a % mod;
		b >>= 1;
    }
    return ret;
}
signed main(){
	cin>>a>>b>>n;
	cout<<a*fp(10,n-1,b)*10/b%10;
	cout<<a*fp(10,n,b)*10/b%10;
	cout<<a*fp(10,n+1,b)*10/b%10;
	return 0;
}
/*
in
1 8 1
out
125
*/
```

---

## 作者：huangruiheng0217 (赞：1)

此题题意应该还是比较明确的。求一个除法算式结果的小数点后第 $n$，$n+1$，$n+2$ 位上的数字，有必要的时候补 $0$。

可以回想小学的时候怎么列竖式算除法的：每次在被除数的小数点最后一位补 $0$（在代码中反映为被除数乘以 $10$），然后对除数求出商和余数，商就是商 ~~（废话文学）~~，余数是下一轮除法的被除数的第 $1$ 位（也可能是前几位）。

前 $n-1$ 轮求余数（也就是下一轮的被除数），后 $3$ 轮求商和余数并输出商。

代码很简单。但是我们还不满足，因为 $n$ 的规模可以达到 $10^9$。比如下面这一组数据：

`123 456 1000000000`

很容易超时。~~（不过本题不会被卡，不但因为出数据人友善，还有洛谷评测机跑得飞快）~~ 
我们需要更优秀的解法。

> upd：现在好像加了一组 hack 数据，暴力被卡了。

显然，$\dfrac{a}{b}$ 小数点后第 $n$ 位等价于 $\lfloor \dfrac{a \times 10^n}{b}\rfloor$ 的最后一位。

注意到计算分子可以用快速幂优化。（当然是建立在余数有可乘性的基础之上）

```cpp
long long a,b,n;
long long qpow(){
	long long res=a,x=10,y=n-1;
	while(y){
		if(y&1)res=(res*x)%b;
		y>>=1;
		x=(x*x)%b;
	}return res;
}
```

由于设计到两个整型变量的相乘，建议使用 `long long` 防爆 `int`。~~当然如果不嫌麻烦写个龟速乘也可以。~~

---

## 作者：I_will_AKIOI (赞：0)

乍一看只需要像高精度那样模拟即可。但数据范围不允许啊。但是题目只要求输出 $3$ 位小数，所以我们需要找到规律。

先模拟一下除法竖式过程：

![图片](https://cdn.luogu.com.cn/upload/image_hosting/2rf1zl30.png)

我们其实并不需要一位一位算，可以在被除数后面补 $0$，补到 $n$ 位时再算出结果即可。补 $0$ 就相当于 $\times 10$，可以用快速幂来解决。注意一定要模。

补 $0$ 后被除数变成了 $10^n\times a$，除以除数后想下取整，最后再 $\bmod$ $10$ 即可。得出小数点后第 $n$ 项为 $\large\left\lfloor\frac{10^n\times a}{b}\right\rfloor\bmod 10$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,n;
long long pow(long long x,long long y)
{
  long long ans=1;
  while(y)
  {
    if(y&1) ans=ans*x%b;
    x=x*x%b;
    y>>=1;
  }
  return ans%b;
}//快速幂
int main()
{
  cin>>a>>b>>n;
  cout<<a*pow(10ll,n-1)*10ll/b%10ll;//计算时全部转为long long类型
  cout<<a*pow(10ll,n)*10ll/b%10ll;
  cout<<a*pow(10ll,n+1)*10ll/b%10ll;
  return 0;
}
```

---


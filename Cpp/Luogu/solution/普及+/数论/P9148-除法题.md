# 除法题

## 题目描述

给定大小为 $n$ 的集合 $a$，保证其中元素互不相同且均为正整数。

如果我们从中**按顺序**取出三个元素 $a, b, c$，则共有 $n \cdot (n-1) \cdot (n-2)$ 种不同的选择方案。

现在对于一种选择方案 $(a,b,c)$，定义其权值为 $\Bigl\lfloor\dfrac{a}{b}\Bigr\rfloor\Bigl\lfloor\dfrac{a}{c}\Bigr\rfloor\Bigl\lfloor\dfrac{b}{c}\Bigr\rfloor$。

你需要对所有的选择方案计算权值的总和，你只需输出这个总和对 $2^{32}$ 取模的结果。

注：$\lfloor a\rfloor$ 表示不大于 $a$ 的最大整数。如 $\lfloor 2.4\rfloor=2$、$\lfloor 5\rfloor=5$。

## 说明/提示

**【样例解释 \#1】**

对于样例 \#1，权值不为 $0$ 的选择方案只有以下几种：

- $(3,2,1)$，权值为 $6$。
- $(4,2,1)$，权值为 $16$。
- $(4,3,1)$，权值为 $12$。
- $(4,3,2)$，权值为 $2$。

因此，样例 \#1 的答案为 $6+16+12+2=36$。

---

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n, a_i \le 5000$。

**本题采用捆绑测试。**

|子任务|$n$|特殊性质|分值|
|-|-|-|-|
|1|$=3$||$10$|
|2|$\le 300$||$20$|
|3|$\le 2000$||$20$|
|4||A|$20$|
|5|||$30$|

特殊性质 A：保证 $a_i=i$。

---

**【提示】**

本题中大部分算法都拥有较小的常数，请相信你的复杂度。

## 样例 #1

### 输入

```
4
1 2 3 4
```

### 输出

```
36
```

## 样例 #2

### 输入

```
6
8 6 4 2 10 15
```

### 输出

```
268
```

# 题解

## 作者：syzf2222 (赞：22)

注意到只有 $a>b>c$ 时，$(a,b,c)$ 的贡献才不为 $0$。

**解法一：**

根据调和级数，我们有：
$$
\sum_{i=1}^n \dfrac{n}{i} = O(n\log n)
$$

枚举 $b$ 和 $c$，再枚举 $s$ 表示 $a$ 是 $c$ 的几倍，这样满足条件的 $a$ 是一段区间，记为 $[L,R]$，于是我们需要计算：
$$
\sum_{b=1}^n \sum_{c=b+1}^n \lfloor\dfrac{b}{c}\rfloor \sum_{s=1}^{n/c} s \sum_{a=L}^R \lfloor\dfrac{a}{b}\rfloor
$$
对每个 $b$，使用前缀和预处理出 $\sum \lfloor\dfrac{i}{b}\rfloor$ ，即可消去最后一个求和符号。

如果暴力枚举 $b,c,s$，总复杂度为 $O(n^2\log n)$，可以通过此题。

**解法二**

我们有：
$$
\sum_{i\geqslant 1}\frac{1}{i^2}=\frac{\pi^2}{6}
$$
枚举 $a$，枚举 $b,c$ 分别是 $a$ 的几倍，我们需要求 $b\in[L_b,R_b],c\in[L_c,R_c]$ 的所有 $b,c$ 对的 $\lfloor\frac{b}{c}\rfloor$ 之和，我们可以预处理一个二维前缀和统计，于是时间复杂度为：
$$
\sum_{i=1}^n(\frac ni)^2\leqslant n^2\sum_{i\geqslant 1}\frac{1}{i^2}=O(n^2)
$$

---

## 作者：离散小波变换° (赞：6)

## 题解

注意到我们要统计 $\Big\lfloor\dfrac{a}{b}\Big\rfloor\Big\lfloor\dfrac{a}{c}\Big\rfloor\Big\lfloor\dfrac{b}{c}\Big\rfloor$ 的和。只有当 $a\ge b$，$a\ge c$，$b\ge c$ 的时候才会对结果有贡献。再加上题设给出的 $a,b,c$ 互不相等的条件，于是一定有 $a>b>c$。

最暴力的想法是，分别枚举 $a,b,c$ 的值再统计贡献。时间复杂度为 $\mathcal O(n^3)$，铁定超时。于是我们希望只枚举 $a,b$，然后快速求出 $c$ 的贡献。枚举完 $a,b$ 之后 $\Big\lfloor\dfrac{a}{b}\Big\rfloor$ 的值已经确定，我们更加关心**后面两个除式的值**。

可以反过来去枚举 $c$，然后设法维护这个 $c$ 对 $a,b$ 的贡献。

注意到在 $c$ 确定的情况下 $\Big\lfloor\dfrac{a}{c}\Big\rfloor$ 和 $\Big\lfloor\dfrac{b}{c}\Big\rfloor$ 的可能取值都只有 $\Big\lfloor\dfrac{v}{c}\Big\rfloor$ 个（$v$ 是值域）。考虑分别枚举 $\Big\lfloor\dfrac{a}{c}\Big\rfloor$ 和 $\Big\lfloor\dfrac{b}{c}\Big\rfloor$ 的值。此时对应的 $a$ 的范围和 $b$ 的范围都是可以计算得到，不妨设 $a\in[a_1,a_2]$，$b\in [b_1,b_2]$（由于 $a\neq c$，$b\neq c$，记得抠掉 $a=c$ 或者 $b=c$ 的情况）。那么点对 $(a,b)$ 应该是一个矩形。考虑维护一个二维数表，第 $i$ 行第 $j$ 列的值表示 $a=i$，$b=j$ 的贡献。我们要做的事情就是对这个二维数表做一个子矩阵加法，这是可以用**二维差分**在单次 $\mathcal O(1)$ 的情况下做到的。所有 $c$ 的贡献计算完后，再分别枚举 $a,b$ 的值计算贡献。

## 时间复杂度

枚举 $c$ 的复杂度为：

$$\sum_{i=1}^v\dfrac{v}{i}\times \dfrac{v}{i}=v^2\times \sum_{i=1}^v\dfrac{1}{i^2}$$

欧拉已经证明了 $\sum \dfrac{1}{i^2}$ 是收敛的，且收敛到 $\dfrac{\pi^2}{6}$。所以这部分复杂度是 $\mathcal O(v^2)$。

最后枚举 $a,b$ 的时间复杂度显然也是 $\mathcal O(v^2)$。所以总时间复杂度为 $\mathcal O(v^2)$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
const int MAXN= 5000 + 3;
int n, m = 5000, A[MAXN]; bool C[MAXN];
unsigned ans = 0, D[MAXN][MAXN];
int qread(){
    int w=1,c,ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
int main(){
    n = qread();
    up(1, n, i) A[i] = qread(), C[A[i]] = true;
    up(1, m, c) if(C[c]){
        up(1, m, i){
            int a1 = c * i, a2 = min(c * (i + 1) - 1, m);
            if(a1 > a2) break;
            up(1, m, j){
                int b1 = c * j, b2 = min(c * (j + 1) - 1, m);
                if(b1 > b2) break;
                a1 = max(a1, c + 1);
                b1 = max(b1, c + 1);
                D[    a1][    b1] += i * j;
                D[    a1][b2 + 1] -= i * j;
                D[a2 + 1][    b1] -= i * j;
                D[a2 + 1][b2 + 1] += i * j;
            }
        }
    }
    up(1, m, i) up(1, m, j){
        D[i][j] += D[i][j - 1];
    }
    up(1, m, i) up(1, m, j){
        D[i][j] += D[i - 1][j];
    }
    up(1, m, a) up(1, m, b) if(a > b){
        if(C[a] && C[b])
            ans += (a / b) * D[a][b];
    }
    printf("%u\n", ans);
    return 0;
}
```

## 后记

直接观察差分数组，可以发现很明显的规律。根据这个规律可以大幅减小常数（但是没办法优化时间复杂度）。

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
const int MAXN= 5000 + 3;
int n, m, A[MAXN]; bool C[MAXN];
unsigned ans = 0, D[MAXN][MAXN];
int qread(){
    int w=1,c,ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
int main(){
    n = qread();
    up(1, n, i) A[i] = qread(), m = max(m, A[i]), C[A[i]] = true;
    up(1, m, c) if(C[c]){
        for(int i = 2 * c;i <= m;i += c)
        for(int j = 2 * c;j <= m;j += c)
            ++ D[i][j];
        for(int i = 2 * c;i <= m;i += c)
            ++ D[c + 1][i], ++ D[i][c + 1];
        ++ D[c + 1][c + 1];
    }
    up(1, m, i) up(1, m, j){
        D[i][j] += D[i - 1][j] + D[i][j - 1] - D[i - 1][j - 1];
        if(C[i] && C[j] && i > j)
            ans += (i / j) * D[i][j];
    }
    printf("%u\n", ans);
    return 0;
}
```

---

## 作者：Daidly (赞：3)

$$

\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n

\lfloor\frac{a_i}{a_j}\rfloor

\lfloor\frac{a_i}{a_k}\rfloor

\lfloor\frac{a_j}{a_k}\rfloor

$$

可以发现只有 $a_i>a_j>a_k$ 时有贡献，不妨先排序。

发现有两个 $a_i$ 在上面，两个 $a_k$ 在下面。

如果枚举 $a_i$ 的话，$\lfloor\frac{a_i}{a_j}\rfloor$ 有约 $\sqrt{a_i}$ 取值；而枚举 $a_k$ 的话，$\lfloor\frac{a_i}{a_k}\rfloor$ 有 $\frac{n}{a_k}$ 种取值。

考虑 $\sum_{i=1}^n(\sqrt{i})^2$ 和 $\sum_{i=1}^n(\frac{n}{i})^2$ 都是 $n^2$ 级别，都可以过，下面细说枚举 $a_k$。

枚举 $a_k$ 预处理 $\frac{n}{a_k}$ 段值相同的 $a_i$ 的 $i$ 区间，可以存到 `vector` 里。

预处理二维前缀和以解决范围内的 $\lfloor\frac{a_i}{a_j}\rfloor$ 之和。

注意虽然我们可以在预处理时保证 $a_k$ 不与 $a_i,a_j$ 相同，但是不好让 $a_i\ne a_j$，可以先全加上去，再减去相同的。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int unsigned int

int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

void print(int x){
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int N=5005;
int n,a[N],sum[N][N],ans;
struct node{int l,r,v;};
vector<node>p[N];

signed main(){
	n=read();
	for(int i=1;i<=n;++i)a[i]=read();
	sort(a+1,a+n+1);
	for(int i=1;i<=n;++i){
		for(int j=i+1;j<=n;++j){
			int L=j,R=j;
			while(a[R+1]/a[i]==a[L]/a[i])R++;
			p[i].push_back((node){L,R,a[L]/a[i]}),j=R;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(a[j]/a[i]);
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=0;j<p[i].size();++j){
			for(int k=j;k<p[i].size();++k){
				int tmp=sum[p[i][j].r][p[i][k].r]-sum[p[i][j].l-1][p[i][k].r]-sum[p[i][j].r][p[i][k].l-1]+sum[p[i][j].l-1][p[i][k].l-1];
				ans+=p[i][j].v*p[i][k].v*tmp;
			}
		}
        for(int j=0;j<p[i].size();++j)ans-=p[i][j].v*p[i][j].v*(p[i][j].r-p[i][j].l+1);
	}
	print(ans);
	return 0;
}
```



---

## 作者：Planet_Earth (赞：3)

# **P9148 除法题**

思路：

#### 预处理和排序：

首先读取集合 $a$ 的元素，并统计每个元素的出现次数。

将集合 $a$ 的元素按降序排序，以便后续计算时更方便地处理除法运算。

#### 利用前缀和加速计算：

对于每个可能的 $b$（作为中间元素），我们需要计算所有可能的 $a$ 和 $c$ 的组合对应的权值。

为了快速计算 $⌊\frac{c}{a} ⌋$ ，我们可以使用一个前缀和数组 $tmp$。

其中 $tmp$ 表示所有小于等于 $i$ 的数 $x$，满足（当前 $b$ 对应的值）的整数部分的和。

这样，当我们遍历可能的 $c$ 值时，就可以通过前缀和数组快速计算出所有满足条件的 $c$ 对应的 $⌊\frac{c}{a} ⌋$ 之和。

#### 嵌套循环计算权值：

外层循环遍历所有可能的 $b$ 值（从 $1$ 到 $n$）。

内层循环遍历所有可能的 $c$ 值（从 $b$ 的下一个位置到 $n$），并利用前缀和数组计算 $⌊\frac{c}{a} ⌋$ 和$⌊\frac{c}{b} ⌋$ 。

同时，由于我们已经按降序排序了 $a$ 数组，所以可以直接通过遍历 $s$（$s$ 表示 $c$ 除以 $b$ 的整数部分）来计算所有可能的 $c$ 值对应的权值部分。

#### 累加结果并取模：

将所有计算得到的权值累加，并对 $2^{32}$ 取模，以避免整数溢出。

AC 代码

```cpp
#include <bits/stdc++.h>
#define int unsigned int
#define N 5010
using namespace std;
int n,a[N],cnt[N],tmp[N];
bool cmp(int x,int y) {
	return x>y;
}
signed main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> a[i];
		cnt[a[i]]++;
	}
	sort(a+1,a+n+1,cmp);
	int ans=0;
	for(int bid=1;bid<=n;bid++){
		for(int i=1;i<=5000;i++){
			if(cnt[i]){
				tmp[i]=tmp[i-1]+((int)i/(int)a[bid]);
			}
			else{
				tmp[i]=tmp[i-1];
			}
		}
		for(int cid=bid+1;cid<=n;cid++){
			int t1=0;
			for(int s=1;s<=(int)5000/a[cid];s++){
				t1+=(tmp[max(min(a[cid]*(s+1)-1,(int)5000),a[bid])]-tmp[max(a[cid]*s-1,a[bid])])*s;
			}
			ans+=t1*((int)a[bid]/(int)a[cid]);
		}
	}
	cout << ans << endl;
	return 0;
}
//Planet_Earth
```

---

## 作者：wfc284 (赞：2)

[传送门](https://www.luogu.com.cn/problem/P9148)  
显然，只有 $a>b>c$ 时才有贡献。  
首先可以写一个 $O(n^3)$ 的枚举：
```cpp
sort(a+1, a+n+1);
for(int i = 1; i <= n; ++i)
    for(int j = i+1; j <= n; ++j)
        for(int k = j+1; k <= n; ++k)
            ans += (a[k]/a[j]) * (a[k]/a[i]) * (a[j]/a[i]);
```
绝对T飞。那如果要优化一遍，不妨先枚举 $i$，然后尝试直接计算贡献。  
先预处理一下：对于每个 $a_i$，计算出所有 $\left \lfloor \frac{a_j}{a_i} \right \rfloor$ 相同的区间。可以用 vector 存一下。即：
```cpp
struct node {
  int l, r, v;
};
vector<node> p[N];
```  
$p_i$ 起到了枚举 $i$ 时，能快速算出贡献的作用。  
$\forall x \in [p_{i,j}.l,p_{i,j}.r]$，都有 $\left \lfloor \frac{a_x}{a_i} \right \rfloor=p_{i,j}.v$。  
然后可以再算一个前缀和：$sum_{i,j}=\sum_{1 \leqslant x \leqslant i,1 \leqslant y \leqslant j} \left \lfloor \frac{a_x}{a_y} \right \rfloor$。  
算前缀和为的是快速计算 $\left \lfloor \frac{a_k}{a_j} \right \rfloor$。  
即：用 vector 算了$\left \lfloor \frac{a_j}{a_i} \right \rfloor$ 和 $\left \lfloor \frac{a_k}{a_i} \right \rfloor$，用前缀和处理 $\left \lfloor \frac{a_k}{a_j} \right \rfloor$。

最后计算贡献。（详见代码） 
### Code
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define Linf 0x3f3f3f3f3f3f3f3f
#define re register
#define int unsigned
using namespace std;
const int N = 5e3+2;

int n, a[N], sum[N][N], ans;

struct node {
	int l, r, v;
};
vector<node> p[N];

signed main() {
	cin >> n;
	for(re int i = 1; i <= n; ++i) cin >> a[i];
	sort(a+1, a+n+1);
	
	for(re int i = 1; i <= n; ++i)	//预处理贡献
		for(re int l = i+1, r = i+1; r <= n; l = ++r) {	//显然l和r都不下降，可以用双指针
			while(a[r+1] / a[i] == a[l] / a[i]) ++r;
			p[i].push_back((node) {l, r, a[l] / a[i]});
		}
	
	for(re int i = 1; i <= n; ++i)	//前缀和
		for(re int j = 1; j <= n; ++j)
			sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[j]/a[i];
	
	int ans = 0;
	for(re int i = 1; i <= n; ++i) {
		for(re int j = 0; j < p[i].size(); ++j)	//枚举"j"（实际是个范围，此范围中a[j]/a[i]为定值）
			for(re int k = j; k < p[i].size(); ++k) {	//同理
				int tmp = sum[p[i][j].r][p[i][k].r] - sum[p[i][j].r][p[i][k].l-1] - sum[p[i][j].l-1][p[i][k].r] + sum[p[i][j].l-1][p[i][k].l-1];	//即计算∑(a[k]/a[j])
				ans += p[i][j].v * p[i][k].v * tmp;	//相加即可，注意是可以"j"="k"的，即有可能j和k的实际值在一个区间里，但j!=k。这种贡献也要加上
			}
		for(re int j = 0; j < p[i].size(); ++j)
			ans -= p[i][j].v * p[i][j].v * (p[i][j].r - p[i][j].l + 1);	//减去j和k的实际值相等的情况
	}
	cout << ans;
    return 0;
}
```

---

## 作者：uid_310801 (赞：2)

首先将序列 $v$ 从小到大排序。

发现对于确定的 $b$，$\lfloor \frac {v_a} {v_b} \rfloor$ 相等的 $a$ 一定是一个连续段。我们对于每个数预处理出这些段，用结构体存储下每个连续段的左端点、右端点、值。这段二分时间复杂度为 $O(n\log n)$，暴力复杂度为 $O(n^2)$，所以二分找或者暴力皆可。

然后枚举 $b,c$，且 $b$ 大于 $c$。$b$ 之后的序列应该被 $b,c$ 依次预处理出的段相互划分成了若干更小的段，某个段的贡献为

$$len\times \lfloor \frac {v_l} {v_b} \rfloor\times \lfloor \frac {v_l} {v_c} \rfloor\times \lfloor \frac {v_b} {v_c} \rfloor$$

其中 $len$ 表示段的长度，$v_l$ 表示处于段内最左边的数。段内 $\lfloor \frac {v_l} {v_b} \rfloor\times \lfloor \frac {v_l} {v_c} \rfloor$ 都相等，取哪个值都一样。

不难发现由于每个数不相同，每一次枚举出 $b$ 和 $c$，段的个数均摊下来是 $\log n$，故可以通过。

取模要求直接用 `unsigned int` 存储即可实现。

代码里有关于枚举这些段的具体实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned int ll;
const ll N=5e3+10;
ll n,a[N],ans;
struct node{
	ll l,r,val;
};
node init(ll _l,ll _r,ll _v){
	node a;a.l=_l,a.r=_r,a.val=_v;
	return a;
}
vector<node> v[N];
signed main(){
	scanf("%u",&n);
	for(int i=1;i<=n;i++){
		scanf("%u",&a[i]);
	}
	sort(a+1,a+n+1);
	a[n+1]=23333;//防止越界
	for(int i=n-1;i>=1;i--){
		for(int j=a[i];j<=5000;j+=a[i]){
			ll l=lower_bound(a+i+1,a+n+2,j)-a,r=lower_bound(a+i+1,a+n+2,j+a[i])-a-1;//二分找左右端点
			if(r<l)	continue;//不存在则跳过
			v[i].push_back(init(l,r,j/a[i]));
			if(r==n)	break;			
		}
	}
	for(int i=1;i<=n-2;i++){
		for(int j=i+1;j<=n-1;j++){
			ll tmp=a[j]/a[i];
			ll lz=0,rz=0;
			while(v[i][lz].r<=j)	lz++;//使得两段有交集
			while(true){
				ll maxl=max(v[i][lz].l,v[j][rz].l),minr=min(v[i][lz].r,v[j][rz].r);//该段为当前枚举的两个段的交集的长度
				ll len=minr-maxl+1;ans+=tmp*len*v[i][lz].val*v[j][rz].val;//计算答案
				if(minr==n)	break;//枚举到结尾了，就跳过
				if(minr==v[j][rz].r)	rz++;
				if(minr==v[i][lz].r)	lz++;
           //如果哪个段的右端点比较前，就往后枚举哪个段。这里包含了两个段右端点相同的情况。
			}
			
		}
	}
	printf("%u",ans);
} 
```


---

## 作者：zyn_ (赞：1)

# P9148 除法题

## 题目大意

给定大小为 $n$ 的数组 $a_i$。求

$$
Ans=\sum_{i\neq j,i\neq k,j\neq k}\lfloor\frac{a_i}{a_j}\rfloor\lfloor\frac{a_i}{a_k}\rfloor\lfloor\frac{a_j}{a_k}\rfloor
$$

$1\le n,a_i\le 5000$，**$a_i$ 中的元素互不相同。**

## 题目分析

令 $V=5000$ 为值域。

只有 $a_i\gt a_j\gt a_k$ 时有贡献。将 $a_i$ **从大到小**排序。答案变为

$$
Ans=\sum_{k=1}^{n}\sum_{1\le i,j\lt k,i\neq j}\lfloor\frac{a_i}{a_j}\rfloor\lfloor\frac{a_i}{a_k}\rfloor\lfloor\frac{a_j}{a_k}\rfloor
$$

令 $x=\lfloor\frac{a_i}{a_k}\rfloor$，$y=\lfloor\frac{a_j}{a_k}\rfloor$。则 $a_k x\le a_i\lt a_k(x+1)$，$a_k y\le a_j\lt a_k(y+1)$。由 $a_i,a_j$ 的范围，可确定出 $i\in[Li,Ri]$，$j\in[Lj,Rj]$。$Li,Ri,Lj,Rj$ 可以 $O(1)$ 求出。设 $[Li,Ri]\cap [Lj,Rj]=P$。

$$
\begin{aligned}
Ans &= \sum_{k=1}^{n}\sum_{x=1}^{\lfloor\frac{V}{a_k}\rfloor}\sum_{y=1}^{\lfloor\frac{V}{a_k}\rfloor}\sum_{i=Li}^{Ri}\sum_{Lj\le j\le Rj,i\neq j}\lfloor\frac{a_i}{a_j}\rfloor\lfloor\frac{a_i}{a_k}\rfloor\lfloor\frac{a_j}{a_k}\rfloor \\
&= \sum_{k=1}^{n}\sum_{x=1}^{\lfloor\frac{V}{a_k}\rfloor}\sum_{y=1}^{\lfloor\frac{V}{a_k}\rfloor}xy\sum_{i=Li}^{Ri}\sum_{Lj\le j\le Rj,i\neq j}\lfloor\frac{a_i}{a_j}\rfloor \\
&= \sum_{k=1}^{n}\sum_{x=1}^{\lfloor\frac{V}{a_k}\rfloor}\sum_{y=1}^{\lfloor\frac{V}{a_k}\rfloor}xy(\sum_{i=Li}^{Ri}\sum_{j=Lj}^{Rj}\lfloor\frac{a_i}{a_j}\rfloor-\sum_{i=j\in P}1)
\end{aligned}
$$

$\sum_{i=Li}^{Ri}\sum_{j=Lj}^{Rj}\lfloor\frac{a_i}{a_j}\rfloor$ 用二维前缀和解决。$\sum_{i=j\in P}1$ 即为 $P$ 中的正整数个数，可 $O(1)$ 求出。枚举 $k,x,y$，此时枚举次数为 $\sum_{k=1}^{n}(\lfloor\frac{V}{a_k}\rfloor)^2$。

下证，这样枚举的时间复杂度为 $O(V^2)$。

注意到 **$a_i$ 互不相同**，所以

$$
\begin{aligned}
\sum_{k=1}^{n}(\lfloor\frac{V}{a_k}\rfloor)^2 &\le \sum_{k=1}^{n}(\frac{V}{k})^2 \\
&= V^2 \sum_{k=1}^{n}\frac{1}{k^2}
\end{aligned}
$$

$$
\begin{aligned}
\sum_{k=1}^{n}\frac{1}{k^2} &= 1+\sum_{k=2}^{n}\frac{1}{k^2} \\
& \le 1+\sum_{k=2}^{n}\frac{1}{(k-1)k} \\
& = 1+\sum_{k=2}^{n}(\frac{1}{k-1}-\frac{1}{k}) \\
& = 1+1-\frac{1}{n} \\
& \le 2
\end{aligned}
$$

得证。

## AC code

取模用 `unsigned int`。

代码中的变量名不完全与公式中的变量名相同。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 5000U
unsigned n,a[N+9],x[N+9][N+9],l1,r1,l2,r2,u,v,ans,p,q,s,t,f[N+9],g[N+9];
int main(){
	scanf("%u",&n);
	for(unsigned i=1;i<=n;++i)scanf("%u",&a[i]);
	sort(a+1,a+n+1,greater<unsigned>());
	for(unsigned i=1,j=N;i<=n;++i)while(j>=a[i]&&j>=1)f[j]=i,--j;
	for(unsigned i=n,j=1;i>=1;--i)while(j<=a[i]&&j<=N)g[j]=i,++j;
	for(unsigned i=1;i<=n;++i)
		for(unsigned j=1;j<=n;++j)
			x[i][j]=x[i][j-1]+x[i-1][j]-x[i-1][j-1]+a[i]/a[j];
	for(unsigned i=1;i<=n;++i)
		for(unsigned j=1;j<=N/a[i];++j)
			for(unsigned k=1;k<=j;++k){
				l1=a[i]*j;r1=min(N,a[i]*j+a[i]-1);
				l2=a[i]*k;r2=min(N,a[i]*k+a[i]-1);
				p=f[r1];q=min(i-1,g[l1]);s=f[r2];t=min(i-1,g[l2]);
				u=max(p,s);v=min(q,t);
				if(q>=p&&t>=s)ans+=j*k*(x[q][t]-x[q][s-1]-x[p-1][t]+x[p-1][s-1]);
				if(u<=v)ans-=j*k*(v-u+1);
			}
	printf("%u",ans);
	return 0;
}
```

---

## 作者：船酱魔王 (赞：1)

# P9148 除法题 题解

## 题意回顾

一个大小为 $ n $ 的互异正整数集合中按顺序选出三个不同的数 $ a,b,c $，权值为 $ \lfloor \frac{a}{b} \rfloor \lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor $。求出所有选择方案权值和模 $ 2^{32} $ 的结果。

$ n \le 5000 $，集合中所有元素都小于等于 $ 5000 $。

## 分析

$ n \le 5000 $，给 5s，因为对 $ 2^{32} $ 的取模可以通过 ```unsigned int``` 来实现，所以常数应该很小，时间复杂度肯定高于 $ O(n^{2}) $。

经过本人用乘除法预处理、循环展开等方式的卡常测试，卡常暴力是没法 $ O(n^3) $ 通过的，因此考虑优化算法。

因为取整会破坏掉一些例如数学速算的性质，所以只能枚举一部分，我们考虑枚举 $ b,c $，权值的三个元素已经求出两个。

枚举 $ a $ 肯定是行不通的，但是可以枚举 $ \lfloor \frac{a}{b} \rfloor $ 或 $ \lfloor \frac{a}{c} \rfloor $，根据常理推测，最大值配最小值这种极端值更容易出解，因此先考虑枚举 $ \lfloor \frac{a}{c} \rfloor $，则我们可以发现 $ a $ 的范围已定。我们在枚举 $ b $ 的那层循环里预处理出 $ \lfloor \frac{a}{b} \rfloor $   的前缀和，在枚举 $ \lfloor \frac{a}{c} \rfloor $ 时即可快速出解。

实际上枚举 $ \lfloor \frac{a}{b} \rfloor $ 也可以，需要先枚举 $ c $ 再枚举 $ b $ 并在枚举 $ c $ 的循环下预处理 $ \lfloor \frac{a}{c} \rfloor $ 的前缀和，也是可以的，写法基本上是对称的，在此提供的是枚举 $ \lfloor \frac{a}{c} \rfloor $ 预处理 $ \lfloor \frac{a}{b} \rfloor $ 的写法的代码。

因为调和级数 $ n + \frac{n}{2} +\frac{n}{3}+\frac{n}{4}+\cdot \cdot \cdot+\frac{n}{n} \approx n \log n $ 的结论，因此时间复杂度是 $ O(n^2 \log n) $ 的，可过。

实现细节参考 AC 代码。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ui unsigned int
using namespace std;
const int N = 5005;
int n;
ui a[N];
int cnt[N];
ui tmp[N];
bool cmp(ui x, ui y) {
	return x > y;
}
int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		cnt[a[i]]++;
	}
	sort(a + 1, a + n + 1, cmp);
	ui ans = 0;
	for(int bid = 1; bid <= n; bid++) {
		for(int i = 1; i <= 5000; i++) {
			if(cnt[i]) {
				tmp[i] = tmp[i - 1] + ((ui)i / (ui)a[bid]);
			} else {
				tmp[i] = tmp[i - 1];
			}
		}
		for(int cid = bid + 1; cid <= n; cid++) {
			ui t1 = 0;
			for(ui s = 1; s <= (ui)5000 / a[cid]; s++) {
				t1 += (tmp[max(min(a[cid] * (s + 1) - 1, (ui)5000), a[bid])] - tmp[max(a[cid] * s - 1, a[bid])]) * s;
			}
			ans += t1 * ((ui)a[bid] / (ui)a[cid]);
		}
	}
	cout << ans << endl;
	return 0;
}
```

## 总结与评价

本题是一道月赛的 div.2 B。这题赛场上通过率只有 $ 4.7\% $，有点太难了，希望以后月赛出题人手下留情。

---


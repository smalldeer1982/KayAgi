# 萃香的请柬

## 题目背景

**管理员提示：数据中存在 $l=0$，请等同于 $l=1$ 处理。**

现在是宴会开始前一天

![](https://cdn.luogu.com.cn/upload/pic/15052.png)

## 题目描述

萃香在小时候就一直有一个梦想，就是邀请全乡居民一起参加宴会，在上次发动异变被灵梦退治之后她仍旧没有放弃，而是在元宵节前早早准备好了难以计数的请柬。

现在，宴会即将开始，萃香却还是有一大堆请柬没有送出。经过大数学家琪露诺的严谨推算，到2018年时幻想乡的居民数目已经远远超过了外界，而这就使得宴会的邀请变得极为困难。

但是，拥有"操纵密度程度的能力"的萃香可以分成大大小小的萃香一起去送请柬。由于小萃香的移动速度过慢，因此她决定只让大萃香曲去送请柬。

开始时有S只萃香，之后每过一秒每一个大萃香会分成一大一小两个萃香，与此同时上一次分出的小萃香会积聚能量变大为大萃香。

直观的说，下面是开始只有一个大萃香时前四秒的变化情况(大萃香用"B"表示，小萃香用"L"表示)
![](https://cdn.luogu.com.cn/upload/pic/15043.png)

(很容易看出，第一次的大萃香经过一秒后分成了一大一小两只萃香，之后一秒刚才分出的大萃香继续分裂，而刚才的小萃香长大为大萃香)

可是，我们这位"小小的百鬼夜行"发现了一个严重的问题:在**经过无限长的时间**后，萃香的数目太多了。于是她决定每一次只让一段区间内的大萃香去送请柬，而她现在想要知道每一次能够送出的请柬个数。

如果你能帮她完成这个任务，她就会送给你两个奖励——100分和宴会的请柬!

## 说明/提示

【数据范围】:

![](https://cdn.luogu.com.cn/upload/pic/15239.png)

## 样例 #1

### 输入

```
B
2
2 3
1 5```

### 输出

```
1
3```

# 题解

## 作者：Wy12121212 (赞：57)

# 萃香的新年宴会 #1 萃香的请柬

## by Wy12121212

[题目链接](https://www.luogu.org/problemnew/show/U20836)

题意:
一串序列由01组成，**初始状态随机**，每次变换序列中原来的‘1’变为‘10’，原来的‘0’变为‘1’，在经过无限次变换之后试求闭区间[l,r]间的‘1’的数量。

**本题做题难度:** _普及+/提高-_ 

**本题思考难度:** _提高+？_ 

**考查知识点:**收敛数列，斐波那契，~~找规律~~数学归纳法

看到这道题时你可能会蒙住，所以让我们先来简化一下题意:

一串序列由01组成，**初始序列为‘1’**，每次变换序列中原来的‘1’变为‘10’，原来的‘0’变为‘1’，在经过无限次变换之后试求闭区间[l,r]间的‘1’的数量。

然后对于这种数学题我们当然要愉快地打表啦

t=0:1

t=1:10

t=2:101

t=3:10110

t=4:10110101

......

到这里你可能已经发现数列的长度和其中‘1’的个数都是斐波那契数列，即fib[i]长度的数列对应fib[i-1]个‘1’

**严格证明:**

t次变换增加的‘1’由t-1次变换的‘0’和t-1次变换的‘1’得到，而t-1次变换的‘0’由t-2次变换的‘1’分裂得到，所以$num_1[t]=num_1[t-1]+num_1[t-2]$，而长度的证明亦同理。

那么问题就变得简单一些了，相信很多人直接就打出了正解，即将i递归拆分为若干个斐波那契数，每一次拆分(i-=fib[k])时ans[i]+=fib[k-1]，然后差分一下输出ans[r]-ans[l-1]100分就到手了(注意边界和l=0的情况)

然而，这道题如果做到这里是没有价值的，因为
### 1.你没有证明拆分的正确性
### 2.这只是初始状态为'1'的特殊情况，没有推广为一般情况

**1.证明拆分的正确性：**

这里要用一个概念斐波那契进制，即任何一个正整数可以被拆分成若干个互异的斐波那契数(fib[0]=1,fib[1]=2)，比如说4=fib(101)，至于为什么请各位自己探究。

**2.推广到一般情况(初始不一定为‘1’)：**

这里引用一下极限的概念胡诌一下:当t不断增加趋近于正无穷的时候，这个数列呈收敛态(**你可以理解为函数的波动渐渐趋于平稳**)，而当t≥s时(s为收敛极限)你可以近似认为函数在[0,+∞]之间确定下来，当然，鉴于此题数据范围极小，收敛极限也不会很大。而我们要计算的就是这个收敛后的序列的情况。

**但是函数收敛的趋势如何?**

下面说人话:经过无限长的时间后，长度为[0,$2^{63}-1$]的数列就是由第一个数扩展很多次而来的(**你可以形象地认为后面的数及其扩展被第一个数挤出了这个范围**)，如果第一个数开始时为‘1’，则与特殊情况完全一致，若为‘0’，则变换一次变为‘1’后与特殊情况完全一致。

## 所以你惊喜的发现，无论初始状态如何，最后序列的状态都不会受到任何影响。

至此，得证。

总结:这是一道很好的题，如果要严格解题的话思维难度很高，如果找规律的话也可以切掉(不建议)

AC代码
```cpp
    while(q--)
    {
        scanf("%lld%lld",&a,&b);a--;
        long long ans=0;
        for(int i=91;i>=0;i--)
        {
            if(a>=f[i]&&b>=f[i])a-=f[i],b-=f[i];
            else if(a>=f[i])a-=f[i],ans-=f[i-1];
            else if(b>=f[i])b-=f[i],ans+=f[i-1];
        }
        printf("%lld\n",ans);
    }
```

如果你抄袭的话请便，我知道你会喜欢棕名的

如果你有任何问题，请**加入我的团队**发帖提问或者加我的qq，私信我可能看不见


---

## 作者：MusicLC (赞：5)

原出题人wy12121212大佬已经将思路讲的十分详细了，然而他没有贴出完整的代码和关于代码的详细解释就凉了（默哀三秒），谨在此作出补充。


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<algorithm>
#include<queue>
using namespace std;
long long int q,a,b,f[10001],rua;
char kdl[1000010];
int main()
{
    scanf("%s",kdl);//珂朵莉。 
    f[0]=1;
    f[1]=1;
    f[2]=2;
    for(int i=3;i<=91;i++)//i定义的太大的话，斐波那契数列过大会导致无法输出…… 
    f[i]=f[i-1]+f[i-2];//归纳数列长度！！！注意，是长度！！！（每个第i个数列中大翠香数量为第i-1个数列的长度！） 
    
    scanf("%lld",&q);
    
    for(long long int p=1;p<=q;p++)
    {
        scanf("%lld%lld",&a,&b);
        a--;//毕竟是闭区间。 
        for(int i=91;i>=0;i--)//从大到小! 这点需要自己理解，讲不清楚的。
        {
            if(a>=f[i]&&b>=f[i])
            {
            	a-=f[i];
                b-=f[i];//区间过大找不到，于是缩小区间。 
            }
            else if(a>=f[i])
            {
            	a-=f[i];
                rua-=f[i-1];//如果左区间大而右区间小（因为上一层递推中右区间执行了第三个if，嘛），则缩小左区间同时减去理论上在上一层中右区间缩小过程中多算的大翠香。 
            }
            else if(b>=f[i])
            {
                b-=f[i];
                rua+=f[i-1];//如果左区间小而右区间大，说明所求区间合适，缩小右区间并计算其中大翠香数。 
            }
        }
        
        printf("%lld\n",rua);//注意！斐波那契数列可拆分为若干个互异的斐波那契数列！正是用该方法拆分一个比较大的斐波那契数列计算[1,2^63-1]中的大翠香数的。 
        rua=0;
    }
}
```


---

## 作者：囧仙 (赞：3)

## 题意简述

> 初始时有一个长度为 $S$ 的由 $\texttt{B,L}$ 组成的字符序列。  
现在将这个序列进行变换： $\texttt{B->BL,L->B}$ ，将新出现的字符拼在一起。$n$ 次询问，每次询问变换**无穷**次后区间 $[l,r]$ 内字符 $\texttt{B}$ 的数量。

## 题解

一道貌似比较经典的题？

由于序列可以变换无穷次，因而我么能够得到一个比较显然的结论：

- 初始序列完全没用。

为什么呢？事实上，从第二个字符起的序列都会被第一个字符新生成的序列顶到无穷远处去。也就是说，除了第一个字符，后面的字符都没有用；如果第一个字符是 $\texttt{L}$ ，它将会在下一次变换中变为 $\texttt{B}$ ，因而第一个字符是什么也不重要了。我们完全可以当作初始序列只有 $\texttt{B}$ 。

考虑先简单地观察一下前几次变换的情况：

$$\begin{aligned}
&\texttt{B} \cr
&\texttt{BL} \cr
&\texttt{BLB} \cr
&\texttt{BLBBL} \cr
&\texttt{BLBBLBLB} \cr
&\texttt{BLBBLBLBBLBBL} \cr
& \cdots \cr
&\texttt{BLBBLBLBBLBBLBLBBLBLB}\cdots \cr
\end{aligned}$$

### 结论

- $1.$ 字符串最前面的字符是不会发生变化的。换句话说，某个字符串总是下一个字符串的**前缀**。

- $2.$ 每次变换相当于在后面接上了上一次变换后的字符串。

考虑如何证明。事实上，两个结论是相辅相成的。

### 证明

我们设字符串的连接操作 $\texttt{A+B}$ 表示将串 $B$ 接在串 $A$ 后面。且设 $S_i$ 表示变换了 $i$ 次后的字符串。下面使用数学归纳法证明：

$$S_{i}=S_{i-1}+S_{i-2},(i\ge 2)$$

- 当 $i=2$ 时， $S_2=\texttt{BLB}=S_1+S_0$ 成立。

- 假设 $i=t$ 时成立，那么 $S_{i+1}$ 应当是 $S_i$ 进行一次变换后的结果。事实上，又由于 $S_{i}=S_{i-1}+S_{i-2}$ ，因而 $S_{i}$ 就是 $S_{i-1}$ 和 $S_{i-2}$ 分别变换后拼接在一起的结果。也就是说，

$$S_{i+1}=S_{i-1+1}+S_{i-2+1}=S_i+S_{i-1}$$

- 于是对于任意的 $i\ge 2$ ，命题成立。

### 计算

我们要计算 $[l,r]$ 内所有 $\texttt{B}$ 的数量。显然，这相当于区间 $[1,r]$ 内 $\texttt{B}$ 的数量减去区间 $[1,l-1]$ 内 $\texttt{B}$ 的数量。两个做法一致，我们只考虑前者。

求出最小的 $t$ ，使得 $|S_t|\ge r$ 。根据上述结论，有 $S_t=S_{t-1}+S_{t-2}$ 。由 $t$ 的最小性可得， $r>|S_{t-1}|$ 。

此时， $[0,r]$ 内 $\texttt{B}$ 的数量应该为 $S_{t-1}$ 内 $\texttt{B}$ 的数量，再加上 $S_{t-2}$ 内 $[0,r-|S_{t-1}|]$ 的数量了。前者可以预处理，后者可以递归处理。又由于新的 $t$ 肯定不超过 $t-1$ ，于是最多操作 $t$ 次。斐波那契数列的增长速度可以当作指数级别，因此总复杂度为 $\mathcal O(q\log v)$ 。

**注意**：该题可能出现 $l=0$ 的情况，需要特判。如果你用的是 $\text{unsigned long long}$ ，可能会溢出为 $\verb!ULLONG_MAX!$ 。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
typedef unsigned int       u32;
typedef unsigned long long u64;
const int MAXN =1000+3;
u64 n,A[MAXN],B[MAXN],s;
u64 qread(){
    u64 w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
u64 clc(u64 w){
    int t=0; u64 r=0; while(t<=s&&A[t]<=w) ++t;
    dn(t,0,i) if(w>=A[i]) r+=B[i],w-=A[i]; return r;
}
int main(){
    A[0]=1,B[0]=0,A[1]=B[1]=1,s=1;
    while(A[s]<(1ull<<62)) B[s+1]=B[s]+B[s-1],A[s+1]=A[s]+A[s-1],++s;
    scanf("%*S"); n=qread(); up(1,n,i){
        u64 l=qread(),r=qread();
        printf("%llu\n",clc(r)-(l==0?0:clc(l-1)));
    }
    return 0;
}
```

---

## 作者：zhoumurui (赞：2)

（下面的描述中，定义“字符串加字符串”为字符串的拼接操作。）

### 题面展示

有一个字符串 $S$，字符集为 $\{\texttt{B},\texttt{L}\}$。

令 $ch$ 为一个字符，定义 $f_{ch}$：

- 当 $ch= \texttt{B}$，$f_{ch} = \texttt{BL}$。
- 当 $ch= \texttt{L}$，$f_{ch} = \texttt{B}$。

若 $S$ 的长度等于 $m$，定义 $g(S) = f_{S_0} + f_{S_1} + \dots + f_{S_{m-1}}$。

给出 $S$，令 $T$ 等于 $g^{(N)}(S)$，$N$ 足够大。

$n$ 次询问，每次问 $T$ 在 $[l,r]$ 区间中有几个 $\texttt{L}$。

### 解题思路

_对于一个结论，括号里是对结论的解释和直观理解。_

**结论 1** $N$ 足够大时，对于任意正整数 $n$，$g^{(N)}(S)$ 的前 $n$ 位与 $S$ 无关。（$N$ 足够大时，对于任意正整数 $n$，$g^{(N)}(S)$ 的前 $n$ 位都是 $S_0$ 分裂而来的。由于 $S_0 = \texttt{B}$ 时经过一轮会变成 $\texttt{L}$，因此 $S_0$ 的取值也不影响答案。）

根据结论 1 我们发现答案和 $S$ 完全没有关系，读入进来就可以扔掉。完全将答案看做由 $S = \texttt{L}$ 分裂而成。

**结论 2** $g^{(n+2)}(\texttt{L}) = g^{(n+1)}(\texttt{L}) + g^{(n)}(\texttt{L})$。（手动模拟，或用数学归纳法简单地证明一下。）

**推论 2-1** $g^{(n)}(\texttt{L})$ 是 $g^{(n+1)}(\texttt{L})$ 的前缀。

结论 2 为我们展示了一个求出 $g^{(N)}(\texttt{L})$ 的前 $k$ 项里有多少个 $L$ 的方法。

提前预处理出 $a_i = \lvert g^{(i)}(\texttt{L}) \rvert$，取使 $a_i < k$ 的最大的 $i$。

那么将 $g^{(N)}(\texttt{L})$ 的前 $k$ 项分为 $[1,a_i]$ 和 $[a_i+1,k]$ 两个部分。

由推论 2-1，$[a_i+1,k]$ 这个部分与 $[1,k-a_i]$ 是等价的。

由于 $a_{90} > 10^{18}$，$[1,a_i]$ 这一部分可以提前预处理掉，而 $[1,k-a_i]$ 这个部分递归下去。由斐波那契数列的增长率也可以看出，这个时间复杂度是 $O(\log n)$ 的。

要回答 $T$ 在 $[l,r]$ 区间中有几个 $\texttt{L}$，实际上就是 $[1,r] - [1,l-1]$，差分一下。**特判 $l=0$ 的情况。**

### 核心代码展示

```cpp
int z[105],t[105];
int cal(int k){
    if (k<=0)return 0;
    else if (k<=2)return 1;
    int i=lower_bound(z+1,z+93,k)-z-1;
    int ans=t[i]+cal(k-z[i]);
    return ans;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    string c;
    cin>>c;
    int n;
    z[1]=z[2]=1;
    t[1]=t[2]=1;
    for (int i=3;i<=92;i++){
        z[i]=z[i-1]+z[i-2];
        
    }
    for (int i=3;i<=92;i++){
        t[i]=cal(z[i]);
    }
    cin>>n;
    while (n--) {
        int l,r;
        cin>>l>>r;
        cout<<cal(r)-cal(l-1)<<"\n";
    }
    return 0;
}
```

---

## 作者：kenyyz (赞：2)

# P4275 萃香的请柬 题解
[题目传送门](https://www.luogu.com.cn/problem/P4275)
## 1. 寻找性质
由于经过了无限长的时间，因此第一个字符已经被无限的展开了，所以不用考虑后面的字符。而 $L$ 经过一回合的变换会变为 $B$，因此第一个字符是固定的，由此我们可以得出：**第一行字符输入没用**。
## 2. 发现规律
题目只给出了四行字符，难以发现规律，于是我们根据题意继续打表：
```c++
B
BL
BLB
BLBBL
BLBBLBLB
BLBBLBLBBLBBL
BLBBLBLBBLBBLBLBBLBLB
BLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBBL
......
```
接下来统计每行大萃香的个数和萃香的总个数:
```c++
1  1  B
1  2  BL
2  3  BLB
3  5  BLBBL
5  8  BLBBLBLB
8  13 BLBBLBLBBLBBL
13 21 BLBBLBLBBLBBLBLBBLBLB
21 34 BLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBBL
......
```
不难发现大萃香的数目和萃香的总数都呈**斐波那契数列**的样式增长，并且第 $i$ 个字符串是由第 $i−1$ 和第 $i−2$ 个字符串拼接而成的。有了这些规律，就可以根据思路打出代码了。
## 3. 代码实现
```c++
#include<bits/stdc++.h>
using namespace std;
long long int n,f[105],l[500005],r[500005];
string s;
int main(){
	f[0]=f[1]=f[2]=1;
	for(int i=3;i<=90;i++){//最多开92，否则会爆。 
		f[i]=f[i-1]+f[i-2];
	}//预处理一个斐波那契数列。 
	cin>>s;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>l[i]>>r[i];
		l[i]--;
		long long int ans=0,bns=0;
		for(int j=90;j>=1;j--){
			if(l[i]>=f[j]){
				ans=ans+f[j-1];
				l[i]=l[i]-f[j];
			}
			if(l[i]<=0) break;
		}//计算从开始到l-1的大萃香个数。 
		for(int j=90;j>=1;j--){
			if(r[i]>=f[j]){
				bns=bns+f[j-1];
				r[i]=r[i]-f[j];
			}
			if(r[i]<=0) break;
		}//计算从开始到r的大萃香个数 
		cout<<bns-ans<<'\n';//相减求出区间内大翠香的个数。 
	}
	return 0;
}
```
### 代码时间复杂度
* $n$ 次询问，每次都要跑一遍斐波那契数列表，一共 $90$ 个数字，所以时间复杂度为：$O(90n)=O(n)$。

---

## 作者：Awatesolo (赞：2)

# 题解：P4275 萃香的请柬
* 晚自习无聊就在纸上想这题……
## 题目性质
* 发现这些性质是解决此题的关键。
1. 第一行输入是废话。这是为什么？
   * 首先观察样例。我们发现在**经过无限长的时间后**第一个字母长出来的大小翠香会变得无限长（废话），所以就不用考虑后面的字母了。
   * 还发现就算在经过无限长的时间，**任意位置的翠香类型不会改变**。
   * 其次，如果第一个字母是 $L$，我们发现第二天 $L$ 就会长出 $R$，那么在经过无限长的时间后我们**可以忽略**这一天。
   * 因此，无论第一行输入什么，我们都只需要当成输入一个 $B$ 就好了。
2. 在**当成输入一个 $B$ 的情况下**，设第 $i$ 行的大翠香个数为 $f_i$，则
  
  $$
  f_i=f_{i-1}+f_{i-2},f_1=f_2=1
  $$

即 $f_i$ 为**斐波那契数列**。

3. 对于任意一行的任意前缀，都可以由上面的若干行组成。比如

   
   ![](https://cdn.luogu.com.cn/upload/pic/15043.png)
   
中前缀$[1,4]$由第三行和第一行组成。

* 知道了这些性质，来思考怎么解决问题吧！
## 题目解法
* 预处理 $f_i$，即预处理**斐波那契数列**。
* 对于每次询问，我们求出 $[1,r]$ 与 $[1,l-1]$ 中大翠香的个数，设为 $ansr$ 和 $ansl$ 答案即 $ansr-ansl$。(利用前缀和思想)。

  * 那怎么求前缀呢？（以求 $[1,r]$ 为例）我们先找到比 $r$ 大的最小 $f_i$（可以二分，但数据较小，最多约 $100$ 次，所以不用），然后从 $i$ 开始从大到小枚举斐波那契数列的每一项，考虑 $r$ 由哪几项组成即可。
## 代码
```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
int maxn=0;
int f[114514]; 
signed main()
{
	string s;
	cin>>s;
	cin>>n;
	f[1]=f[2]=1;
	for(int i=3;i<=1145;i++){//预处理
		f[i]=f[i-1]+f[i-2];
	}
	int l,r;
	for(int k=1;k<=n;k++){
		cin>>l>>r;
		int st;
		for(int i=1;i;i++){//找到比 r 大的最小 f[i]
			if(f[i+1]>r){
				st=i;
				break;
			}
		}
		int ans=0;
		while(r){
			if(r>=f[st]){//考虑 r 由哪几项组成。
				r-=f[st];
				ans+=f[st-1];
			}
			st--;
		}
		if(l==0) l=1;
		l--;
		for(int i=1;i;i++){
			if(f[i+1]>l){
				st=i;
				break;
			}
		}
		while(l){
			if(l>=f[st]){
				l-=f[st];
				ans-=f[st-1];
			}
			st--;
		}
		cout<<ans<<'\n';
	}
	return 0;
} 
```

---

## 作者：不会dp退役菜鸡 (赞：2)

（之前排版太乱，重做一次）

先找规律，从S只有一个的开始，因为最终总是分裂了inf次，那么其实不管怎么样最后都是由S引导的字母组。

先打一份表：

S

SL

SLS

SLSSL

SLSSLSLS

SLSSLSLSSLSSL
……………………………………

不难fa现，其实第n个字母组=（第n-1个字母组）结尾带上（第n-2个字母组）（n>2)，照此即可编出程序了。

~~（代码能力太差，无力贴出代码ε＝ε＝ε＝(#>д<)ﾉ）~~

---

## 作者：hexz01 (赞：1)

# P4275 萃香的请柬 题解
## 0. 读读题

[没读题的点这里](https://www.luogu.com.cn/problem/P4275)

## 1.1 题意简化
题意为：给定一串 ```BL``` 组成的字串，每一次变换，```B``` 变为 ```BL```，```L``` 变为 ```B```，求指定时刻区间 ```B``` 数量。

我们考虑一个简单点的问题：

初始状态为 ```B```，每次 ```B``` 变为 ```BL```，```L``` 变为 ```B```，求指定时刻区间 ```B``` 数量。

先列出前 9 次变换的结果：

```
num  cntB  length  BL-string 
 0    1      1     B
 1    1      2     BL
 2    2      3     BLB
 3    3      5     BLBBL
 4    5      8     BLBBLBLB
 5    8      13    BLBBLBLBBLBBL
 6    13     21    BLBBLBLBBLBBLBLBBLBLB
 7    21     33    BLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBBL
 8    33     54    BLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBLB
```

来看看我们发现了什么（下文称 ```i``` 次变换后的 ```BL``` 序列为 ```s[i]```）：
1. ```B``` 的数量和总长成 ```Fibonacci``` 数列（```s[i]``` 的长度为 ```f[i]```，```s[i]``` 中 ```B``` 的数量为 ```f[i-1]```）。
2. ```s[i]``` 每次都是 ```s[i-1]``` 与 ```s[i-2]``` 首尾相接。

### 严格证明
1. ```B``` 的数量和总长成 ```Fibonacci``` 数列：根据变换，每一次 ```B``` 增加的数量是上一次 ```L``` 的数量，而根据变换，上一次 ```L``` 的数量是上上次 ```B``` 的数量。
所以每一次 ```B``` 的数量是上次 ```B``` 的数量加上上次 ```B``` 的数量，成 ```Fibonacci``` 数列。
2. 序列总长成 ```Fibonacci``` 数列：根据变换，每一次变换增加的长度为上一次的 ```B``` 数量，而上一次的 ```B``` 数量为上上次的长度，故每一次的长度是上两次长度和，成 ```Fibonacci``` 数列。
3. ```s[i]``` 每次都是 ```s[i-1]``` 与 ```s[i-2]``` 首尾相接：从第二次变换后的结果开始，就能拆分为上次的结果和上上次的结果，每次同时往后变换，所以 ```s[i]``` 每次都是 ```s[i-1]``` 与 ```s[i-2]``` 首尾相接。

## 1.2.1 解决简化后的问题
于是，对于这个问题，我们可以提前计算提问范围内的 ```Fibonacci``` 数。

然后，根据条件 2，我们可以求出一段前缀中的 ```B``` 数量，最后输出差分后的结果即可。

问题就在于如何求出一段前缀中的 ```B``` 数量。

### 1.2.1.1 法一

根据条件二：
```s[i]``` 每次都是 ```s[i-1]``` 与 ```s[i-2]``` 首尾相接。

我们举出例子：
```
BLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBLB
|--------------------------------------|
```
上述例子中，我们求前缀内的 ```B``` 数量（范围如 ```|-|``` 所示），我们发现上面的串可以拆成如下两个串（```s[k-1]```，```s[k-2]```）：
```
             string-L                       string-R
BLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBBL    BLBBLBLBBLBBLBLBBLBLB
|---------------------------------    -----|
```
根据预处理我们得知，```L``` 串中有 21 个 ```B```，于是我们将答案加上 21，继续考虑 ```R``` 串：
```
   string-L         string-R
  BLBBLBLBBLBBL     BLBBLBLB
 BLBBLBLB  BLBBL
BLBBL  BLB
|----  BL B
       |
```
于是答案等于 $21+3+1=25$。

### 1.2.1.2 实现
我们可以考虑每次对于当前区间，二分查找最大的不超过区间长度的 ```Fibonacci``` 数，把答案加上这个数的上一个（因为 ```s[i]``` 中 ```B``` 的数量是 ```f[i-1]```），并缩小区间。
```cpp
int find(int l, int r, int x){
    int max1=l-1;//只会写左闭右闭区间
    while(l<=r){
        int mid=(l+r)>>1;
        if(f[mid]<=x){
            max1=max(max1, mid);
            l=mid+1;
        }else{
            r=mid-1;
        }
    }
    return max1;
}
int ans(int x){
    int ans=0;
    while(x>0){
        int were=find(1, tot, x);//找出不超过x的最大Fibonacci数
        ans+=f[were-1];//B数量是f[i-1]
        x-=f[were];//长度是f[i]
    }
}
```

### 1.2.2.1 法二

法二的思想与法一类似，我们在法一中能发现一个重要的性质：**每一次找到的不超过区间长度的最大 ```Fibonacci``` 数单调递减！**

于是，我们可以从最长的在询问范围内的 ```Fibonacci``` 数向下遍历 ```Fibonacci``` 序列，如果当前数小于等于区间长度，就处理这个答案，再寻找剩下的。

### 1.2.2.2 实现

```cpp
int ans(int l){
    int ans=0;
    for(int i=tot;i>=1 && l;i--){
        if(f[i]<=l)
            ans+=f[i-1], l-=f[i];
    }
    return ans;
}
```

## 2.1 回到题目
我们已经解决了简化后的题目，于是我们回到本题：

> 给定一串 ```BL``` 组成的字串，每一次变换，```B``` 变为 ```BL```，```L``` 变为 ```B```，求指定时刻区间 ```B``` 数量。

我们发现，不管他给出多长的串，在经过**无限长时间**的变化后， ```Fibonacci``` 数都爆 ```long long``` 了，那原始串除第一个字母外其他的变换结果已经被挤出了询问范围。

于是我们只要考虑第一个字母的情况：
1. 第一个字母是 ```B```，那么与简化后的题目一致。
2. 第一个字母是 ```L```，那么变换一次后变为 ```B```，与简化后的题目一致。

至此，我们开心的发现，题目与我们简化后的问题是一样一样滴！

所以，我们就可以用刚才的代码 ```AC``` 这道题了！

## 2.2  AC 代码
注：这里使用的求前缀 ```B``` 数量的方法为法一。
```cpp
#include <iostream>
using namespace std;
typedef long long ll;
const int N=107;
ll f[N], tot=0;//Fibonacci数列，tot是long long范围内Fibonacci数的个数
void F(){
    f[1]=f[2]=1LL;
    for(int i=3;;i++){
        f[i]=f[i-1]+f[i-2];
        if(f[i]<0){//爆long long了
            tot=i-1;
            break;
        }
    }
}
int find(int l, int r, ll x){
    int max1=l-1;//只会写左闭右闭区间
    while(l<=r){
        int mid=(l+r)>>1;
        if(f[mid]<=x){
            max1=max(max1, mid);
            l=mid+1;
        }else{
            r=mid-1;
        }
    }
    return max1;
}
ll ans(ll x){
    ll ans=0;
    while(x>0){
        int were=find(1, tot, x);//找出不超过x的最大Fibonacci数
        ans+=f[were-1];//B数量是f[i-1]
        x-=f[were];//长度是f[i]
    }
    return ans;
}
int main(){
    string s;
    int n;
    cin>>s>>n;
    F();
    while(n--){
        ll l, r;
        cin>>l>>r;
        cout<<ans(r)-ans(l-1)<<endl;//做一个差分
    }
    return 0;
}
```

---

## 作者：D2T1 (赞：1)

# 题解 P4275

### Part 1. 打表

一眼看过去，像一道找规律，那就先打个表找吧。

```
const int N = 1e6 + 10;
int n, l, r;
char s[N], k[N];

int main(){
	s[1] = 'L'; n = 11;
	for(int i = 1; i <= n; ++ i){
		int tp = 0, cnt = 0;
		for(int j = 1; j <= strlen(s+1); ++ j){
			if(s[j] == 'B') k[++tp] = 'B', k[++tp] = 'L';
			else k[++tp] = 'B';
		}
		for(int i = 1; i <= tp; ++ i){
			s[i] = k[i];
			if(k[i] == 'B') ++ cnt;
		}
		printf("%d %d %s\n", cnt, tp, k+1);
	}
}
```

打表找到若第一个符号为 $\text{B}$ 时后面若干步的变化情况。大致如下：（第一列为 $\text{B}$ 数，第二列为总数）

```
1 1 B
1 2 BL
2 3 BLB
3 5 BLBBL
5 8 BLBBLBLB
8 13 BLBBLBLBBLBBL
13 21 BLBBLBLBBLBBLBLBBLBLB
21 34 BLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBBL
```

可以发现 $\text{B}$ 数和总数都是斐波那契数列。且第 $k$ 步的结果是第 $k-2$ 步结果接在 $k-1$ 步后面。

------------

### Part 2. 性质

可以发现一个很妙的性质：**开始时萃香的状态对答案没有影响**！因为答案的计算是在**经过无限长的时间后**，此时后面的 $\text{B,L}$ 变化的都被第一个 $\text{B,L}$ 变化的顶到了无限远处，若第一个为 $\text{L}$，在第二步也变为了 $\text{B}$。

------------

### Part 3. 步骤

1. 预处理出斐波那契数列，得到 `long long` 内有 $92$ 个斐波那契数。
1. 编写一个可以求出 $1$ 至 $k$ 中 $\text{B}$ 个数的函数。**注意特判 $k$ 为 $0$ 时的情况**。
1. 差分，输出。

```cpp
//P4275 by _zyINF
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
long long fib[N], l, r;
char s[N];
int n; 

int chk(long long k){
	int L = 1, R = 92;
	while(L < R){
		int mid = (L + R + 1) >> 1;
		if(fib[mid] > k) R = mid - 1;
		else L = mid;
	}
	return L;
}
long long que(long long k){
	if(k < 0) return 0;
	long long ans = 0;
	while(k){
		long long p = chk(k);
		ans += fib[p-1], k -= fib[p];
	}
	return ans;
}

int main(){
	fib[1] = fib[2] = 1;
	for(int i = 3; i <= 92; ++ i) fib[i] = fib[i-2] + fib[i-1];
	scanf("%s%d", s+1, &n);
	for(int i = 1; i <= n; ++ i){
		scanf("%lld%lld", &l, &r);
		printf("%lld\n", que(r) - que(l-1));
	}
	return 0;
}
```

---

## 作者：Lacuna (赞：0)

找规律题。

#### 题目比较复杂，这里给出简化题意：

给定初始字符串，每次将字符串中的 ```B```
改成 ```BL```，```L``` 改成 ```B```，将字符串变化无限次，求 $l \sim r$ 区间中，```B``` 的个数。

假设开始字符串中只有一个 ```B```，我们可以打个表：

#### 字符串变化的过程：


```
B
BL
BLB
BLBBL
BLBBLBLB
BLBBLBLBBLBBL
BLBBLBLBBLBBLBLBBLBLB
BLBBLBLBBLBBLBLBBLBLBBLBBLBLBBLBBL
......
```

#### 然后可以得出：

字符串长度：
```
1 2 3 5 8 13 21 34......
```

```B``` 的个数：

```
1 1 2 3 5 8 13 21......
```

可以发现这两串数都是斐波那契数列。我们用一个数组 $f$ 表示第二个数组。第一个数组的第 $i$ 项对应的就是第二个数组的第 $i+1$ 项。

另外还有两个美妙的性质：

1. 第 $i$ 个字符串是由第 $i-1$ 和第 $i-2$ 个字符串拼接而成的。

2. 字符串初始是什么状态和结果没有影响。因为字符串被变化了无数次，后面的变化总会被第一个字符无限的变化顶到无限远处。所以我们只要考虑第一个字母的两种情况，```B``` 的情况就是上面打表的情况，```L``` 的情况经过第一次变化后会转变为 ```B```，接下来的情况和第一个字母是 ```B``` 的情况相同。

#### 然后就有实现思路了：

首先，将斐波那契数列预处理：

```cpp
void init(){
  f[1]=f[2]=1;
  for(int i=3;i<=92;i++)
    f[i]=f[i-1]+f[i-2];
}
```
然后，我们可以写出一个求出 $1 \sim k$ 区间 ```B``` 的个数的函数。先用在斐波那契数列中二分查找出小于等于 $k$ 的长度。减去长度后，答案加上 ```B``` 的个数后继续找。

对于 $l \sim r$ 区间的答案，我们差分求解即可。

#### 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define gc getchar
#define pc putchar
#define LL long long

const int N=1000005;

char s[N];
LL n,l,r,f[95];

inline LL read(){
  LL x=0,f=1;
  char ch=gc();
  while(!isdigit(ch)){
    if(ch=='-') f=-1;
	ch=gc();
  }
  while(isdigit(ch))
    x=(x<<1)+(x<<3)+ch-'0',ch=gc();
  return x*f;
}
inline void write_(LL x){
  if(x<0) x=-x,pc('-');
  if(x>9) write_(x/10);
  pc(x%10+'0');
}
inline void write(LL x){
  write_(x);
  pc('\n');
}

int search(LL x){
  int l=1,r=92;
  while(l<=r){
    int mid=(l+r)/2;
    if(f[mid]<=x) l=mid+1;
    else r=mid-1;
  }
  return r;
}
LL solve(LL k){
  LL ans=0;
  for(;k>0;){
  	LL sum=search(k);
  	ans+=f[sum-1],k-=f[sum];
    //此处的sum查找的是字符串最大的长度，表示为B的个数就是f[sum-1]。
  }
  return ans;
}
void init(){
  f[1]=f[2]=1;
  for(int i=3;i<=92;i++)
    f[i]=f[i-1]+f[i-2];
}

int main(){
  scanf("%s",s+1),n=read(),init();
  for(int i=1;i<=n;i++){
  	l=read(),r=read();
  	l=(l==0?1:l);
  	write(solve(r)-solve(l-1)); 
  } 
  return 0;
}
```

对于每次操作的时间复杂度是 $O(\log k)$，总的时间复杂度是 $O(n \log k)$。

---


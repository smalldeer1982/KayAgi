# [CQOI2014] 数三角形

## 题目描述

给定一个 $N\times M$ 的网格，请计算三点都在格点上的三角形共有多少个。注意三角形的三点不能共线。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1\le N,M\le1000$。

## 样例 #1

### 输入

```
2 2```

### 输出

```
76```

# 题解

## 作者：emptysetvvvv (赞：177)

## 背景

小萌新 $\varnothing$ 如何也想不到，**此题存在 $O(n)$ 的做法！！**

## 思路

### Part I

显然，总体思路应为：**【三角形数量】等于【任选三个点的方案数】减去【三点共线的方案数】**。

共有 $(n+1)(m+1)$ 个点，故【任选三个点的方案数】为 $C_{(n+1)(m+1)}^3$。

**【三点共线的方案数】等于【横着的】加【竖着的】加【斜着的】**。

【横着的】指三点所在直线平行于 $x$ 轴。共有 $m+1$ 条横线，每条横线上有 $n+1$ 个点，从这 $n+1$ 个点中选取 $3$ 个，方案数为 $(m+1)\cdot C_{n+1}^3$。

同理，【竖着的】指三点所在直线平行于 $y$ 轴，方案数为 $(n+1)\cdot C_{m+1}^3$。

看来，我们现在最关心的是【斜着的】，斜着的直线按**斜率正负**分为两种，并且这两种的方案数是相等的。因此，我们只需要计算出斜率为正的方案数，再乘以 $2$ 即可。

方便起见，不妨将核心计算内容——斜率为正的方案数记为 $ans$。

### Part II

先考虑较朴素的 $O(n^2)$ 做法。

在此之前，观察可以发现一个小小的结论：

**假设网格中 $AB$ 平行于底边 $x$ 轴，长度为 $i$ ，$BC$ 平行于侧边 $y$ 轴，长度为 $j$ ，那么 $AC$ 上的整点数量为 $\gcd(i,j)+1$。**

那么我们可以枚举两点横坐标差 $i$，纵坐标差 $j$，则两点连线上的整点数量为 $\gcd(i,j)+1$（不算两端点自身的话有 $\gcd(i,j)-1$ 个）。

对于每组横坐标差 $i$，纵坐标差 $j$ 的点对，我们先选取两端点，再在他俩之间的 $\gcd(i,j)-1$ 个点中任选一个作为第三个点，方案数为 $\gcd(i,j)-1$。

每组点对可以有 $\gcd(i,j)-1$ 种方案，像这样横坐标差 $i$，纵坐标差 $j$ 的点对共有 $(n-i+1)(m-j+1)$ 个，故可以枚举 $i,j$ 计算：

$$ans=\sum_{i=1}^n\sum_{j=1}^m(n-i+1)(m-j+1)(\gcd(i,j)-1)$$

直接计算这个式子复杂度 $O(nm)=O(n^2)$，考虑 $\gcd$ 的计算的话甚至是 $O(n^2\log n)$。当然，对于本题的数据是绰绰有余了。

### Part III

提供一个相当美妙并且相当好写的 $O(n)$ 做法。

我们看到 $[\gcd(i,j)=1]$ 这样的项时，总是按照莫比乌斯反演套路将其化为 $\sum_{d\mid\gcd(i,j)}\mu(d)$。

实际上，对于 $\gcd(i,j)$ 这样的项时，也是有套路的，那就是根据欧拉反演将其化为 $\sum_{d\mid\gcd(i,j)}\varphi(d)$。

他的原理是欧拉函数的一个有趣性质：

**$n$ 的所有因子的欧拉函数和为 $n$ ，即 $\sum_{d\mid n}\varphi(d)=n$**。

证明及更详细的信息见 $\varnothing$ 的[博客](https://www.luogu.com.cn/blog/emptyset/ou-la-ding-li)。

也就是说：

$$ans=\sum_{i=1}^n\sum_{j=1}^{m}(n-i+1)(m-j+1)\left(\sum_{d\mid\gcd(i,j)}\varphi(d)-1\right)$$

考虑到 $\varphi(1)=1$，不妨先预先化简下，把 $\varphi(1)$ 和 $-1$ 抵消掉，免得以后麻烦：

$$ans=\sum_{i=1}^n\sum_{j=1}^{m}(n-i+1)(m-j+1)\sum_{d\mid\gcd(i,j)}^{d\ne 1}\varphi(d)$$

更复杂了？不妨先来看看 $d|\gcd(i,j)$ 的含义：

**$i,j$ 的最大公约数的每个因子**。

那不正是 $i,j$ 的每个公约数吗？

**枚举 $i,j$ 再枚举他们的所有公约数，等价于枚举每个约数 $d$ 再枚举 $d$ 的 $i$ 倍、$j$倍**。

可以看出，$d$ 的取值范围成了 $[2,\min(n,m)]$，$i,j$ 最小可取 $1$，最大分别取 $\left\lfloor\dfrac{n}{d}\right\rfloor,\left\lfloor\dfrac{m}{d}\right\rfloor$，即：

$$ans=\sum_{d=2}^{\min(n,m)}\sum_{i=1}^{\lfloor{n/d}\rfloor}\sum_{j=1}^{\lfloor{m/d}\rfloor}(n-id+1)(m-jd+1)\varphi(d)$$

$$=\sum_{d=2}^{\min(n,m)}\varphi(d)\sum_{i=1}^{\lfloor{n/d}\rfloor}(n-id+1)\sum_{j=1}^{\lfloor{m/d}\rfloor}(m-jd+1)$$

很明显，$\sum_{i=1}^{\lfloor{n/d}\rfloor}(n-id+1)$ 是等差数列求和，

首项为 $(n-d+1)$，末项为 $(n-\left\lfloor\dfrac{n}{d}\right\rfloor d+1)$ 即 $(n\bmod d+1)$，项数为 $\left\lfloor\dfrac{n}{d}\right\rfloor$，故：

$$\sum_{i=1}^{\lfloor{n/d}\rfloor}(n-id+1)=\dfrac{1}{2}(n-d+1+n\bmod d+1)\left\lfloor\dfrac{n}{d}\right\rfloor$$

同理有：

$$\sum_{j=1}^{\lfloor{m/d}\rfloor}(m-jd+1)=\dfrac{1}{2}(n-d+1+n\bmod d+1)\left\lfloor\dfrac{n}{d}\right\rfloor$$

最终得到：

$$ans=\dfrac{1}{4}\sum_{d=2}^{\min(n,m)}\varphi(d)(n-d+n\bmod d+2)\left\lfloor\dfrac{n}{d}\right\rfloor(m-d+m\bmod d+2)\left\lfloor\dfrac{m}{d}\right\rfloor$$

欧拉函数可以利用欧拉筛线性预处理出，枚举 $d$ 复杂度 $O(\min(n,m))=O(n)$。

## 代码

```cpp
#include <cstdio>
#include <iostream> 
using namespace std;
const int maxn = 1005;
int n, m, p[maxn], phi[maxn], tot;
bool mark[maxn];
long long ans;
long long C(long long x) { return x * (x-1) * (x-2) / 6; }
void sieve(int n) {
	phi[1] = 1;
	for(int i = 2; i <= n; ++i) {
		if(!mark[i]) p[++tot] = i, phi[i] = i - 1;
		for(int j = 1; j <= tot and p[j]*i <= n; ++j) {
			mark[p[j]*i] = true;
			if(i % p[j]) phi[p[j]*i] = phi[i] * (p[j]-1);
			else { phi[p[j]*i] = phi[i] * p[j]; break; }
		}
	}
}
int main() {
	scanf("%d %d", &n, &m);
	if(n > m) swap(n, m);
	sieve(n);
	for(int d = 2, x, y; d <= n; ++d)//记得 ans 要乘以 2，这里直接除以 2 就行了不用除以 4
		ans += (long long)phi[d]*(n-d+n%d+2)*(n/d)*(m-d+m%d+2)*(m/d)/2;
	ans = C((n+1)*(m+1)) - (m+1)*C(n+1) - (n+1)*C(m+1) - ans;
	printf("%lld\n", ans);
}
```

## p.s

不考虑一些奇奇怪怪的 0ms 的话，$\varnothing$ 当初交的时候是 29ms 最优解诶。

觉得蛮有意思的话也请点个赞吧，无论你是否看明白了。

---

## 作者：PPL_ (赞：64)

# 前言

今天测试考的这道题，但是扫雷把脑子扫炸了，于是没有推出来

**我自闭了**

本蒟蒻作者数学第一菜，可能说的不清楚，你有两个解决方案：

①憋着

②看别人的

# 题目

[蒟蒻专用传送门](http://222.180.160.110:1024/problem/4105)

[传送门(洛谷)](https://www.luogu.org/problem/P3166)

# 正题

我们别怕数学题，跟着我一步一步来，可以推出来的！

这道题总体思路是算出三角形的总数，减去共线的三角形个数，即为答案

首先它有多少个三角形呢？

明显是：$C_{(n+1)*(m+1)}^3$，即$(n+1)*(m+1)$个点中选$3$个点的方案数

为了方便处理，我们先减去 **横线上** 和 **竖线上** 的三点共线的三角形

一边有$m+1$和$n+1$个点，分别有$n+1$行，$m+1$列所以减去$C_{n+1}^3*(m+1)$和$C_{m+1}^3*(n+1)$

然后我们考虑斜着的三点共线的三角形，比如这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/ygn8xxl2.png)

我们由于只有$n^2$的时间，就只能枚举一个点的坐标，根据它与原点的连线，确定线上有多少个坐标点

我们枚举了一个点，加上坐标原点，我们就确定了两个点了，还有一个点当然就是这条线段上的坐标为整数的点，现在我们就要算出有多少个这样的点(当然不算坐标原点和枚举的这个点)

首先已知坐标有$(0,0)$和枚举的$(i,j)$，那么这条直线的解析式为$y=\frac{j}{i}x$，因为这是一条线段，所以$(0\le x\le i,0\le y\le j)$，而且我们要排除$(0,0)$和$(i,j)$两个点，所以$(0 < x < i,0 < y < j)$，我们还要使$y$为整数，明显当$i,j$互质的时候已经没救了，所以$i,j$一定不互质

那么重新写这条直线的解析式：$y=\frac{j/gcd(i,j)}{i/gcd(i,j)}x,(0 < x < i,0 < y < j)$，现在这两个数$($分子和分母$)$铁定互质了，我们只需要使$x$为$i/gcd(i,j)$的倍数就可以使$y$为整数了，那么有多少个$x$是$i/gcd(i,j)$的倍数呢？

我们回头看向$x$的范围$(0 < x < i)$，于是就有$\frac{i}{i/gcd(i,j)}-1$，即$gcd(i,j)-1$个，为什么要减一呢？给你几秒钟思考时间

因为是$x < i$而不是$x \le i$啊

于是我们求出有$gcd(i,j)-1(1\le i\le n,1\le j\le m)$个点在这个线段上(不算坐标原点和枚举的这个点)

我们把上面那个图拿下来验证：

![](https://cdn.luogu.com.cn/upload/image_hosting/ygn8xxl2.png)

$i=4,j=8,gcd(i,j)-1=4-1=3$，看图，果然这条线上有3个点

但是坐标原点并不是一定在三角形上，而且我们已经花去了$O(n^2*log(n))$的时间了，这意味着我们只能在$O(1)$的时间内算出其它的方案数

在草稿纸上一顿乱搞：我们可以把这个已经枚举出来的三角形向上或左平移，相当于就是其它位置的三点共线的三角形：

![](https://cdn.luogu.com.cn/upload/image_hosting/yct2rxk0.png)

红色的线段是我们枚举的，绿色的是向右平移，粉色(紫色？)的是向上平移的，当然，我们别忘了还有黑色的

如上图所示，我们就可以计算出共有多少个可以通过平移得到的位置：$(n-i+1)*(m-j+1)$

再乘上之前我们得出的$gcd(i,j)-1$，即$(gcd(i,j)-1)*(n-i+1)*(m-j+1)$个共线的三角形

完了吗？

$naive$

这只是从左下到右上的线段上的三角形，还有从左上到右下的线段上的三角形需要减：

![](https://cdn.luogu.com.cn/upload/image_hosting/np8y3l9a.png)

如图，我们只减了形似于红色的线段上的三角形，但是还有形似于绿色的线段上的三角形

可以轻松证明，把它转一下，就是后者了，所以我们最后要乘个$2$

最后的最后，记得开$long\space long$

# 代码
```cpp
//12252024832524
#include <cstdio>
#include <algorithm>
using namespace std; 

typedef long long LL;
const int MAXN = 1005;
int n,m,n1,m1;
LL s[MAXN][MAXN],ans;

int Read()
{
	int x = 0,f = 1;char c = getchar();
	while(c > '9' || c < '0'){if(c == '-')f = -1;c = getchar();}
	while(c >= '0' && c <= '9'){x = (x*10) + (c^48);c = getchar();}
	return x * f;
}
void Put(LL x)
{
	if(x > 9) Put(x/10);
	putchar(x%10^48);
}
template <typename T>T Max(T x,T y){return x > y ? x : y;}
template <typename T>T Min(T x,T y){return x < y ? x : y;}
template <typename T>T Abs(T x){return x < 0 ? -x : x;}
int gcd(int x,int y)
{
	if(!y) return x;
	return gcd(y,x%y);
}
LL Cn3(LL x)
{
	return x * (x-1) * (x-2) / 6;
}
void solve4()
{
	n = n1+1;
	m = m1+1; 
	ans = Cn3(n*m) - m*Cn3(n) - n*Cn3(m);
	for(int i = 1;i < n;++ i)
		for(int j = 1;j < m;++ j)
			ans -= 2ll * (gcd(i,j)-1) * (n - i) * (m - j);
	printf("%lld\n",ans);
}

int main()
{
//	freopen("triangle.in","r",stdin);
//	freopen("triangle.out","w",stdout);
	n1 = Read();
	m1 = Read();
	solve4();
	return 0;
}
```
# By The Way

我再也不玩扫雷了，$QAQ$

---

## 作者：ww3113306 (赞：26)

感觉楼下大佬的题解不是很详细，这里详细的讲一下推导过程
组合数+容斥原理+gcd

正确做法是暴力的一种优化，ans=所有情况 - 平行坐标轴的三点共线 - 斜线三点共线

如果快速求斜线三点共线：

首先要知道一个结论，对于点(a,b) (x,y)连成的线段而言(其中a>x,b>y)，

在它们中间有gcd(a-x,b-x)-1个整点，因此基本的思路就是枚举两个点，

然后第3个点就是gcd(a-x,b-x)-1种可能了

至于为什么第3个点一定要在中间，是为了保证不重不漏，只用两边的点统计中间的点，

然而这样复杂度太高，于是可以发现，可以将这两个点组成的线段中左下那个端点平移至原点，

这样相当于只要枚举一个点，并且由于要考虑k<0的情况，因为矩形是有对称性的，

所以要求原点+一个点 与 (0,m)+一个点 的和就可以直接2 *（原点+一个点）

由于长的一样的线有很多，于是问题就转化为如果求这些一样的线的个数，

那么可以发现，这样任意一条线，向上只能平移(n - i)，向下(m - j)次，

所以可能性就为(n - i + 1) * (m - j + 1),其中+1是因为可以向上移动0个单位

但由于这里n,m一开始就加了1，所以这个式子就不用+1了

因此枚举每个点即可

```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define LL long long
LL n,m,ans,go;

int gcd(int x,int y)
{
	if(!y) return x;
	else return gcd(y,x%y);
}

void work()
{
	scanf("%lld%lld",&n,&m);
	++n,++m;//因为是一个网格，所以真正的坐标系其实有(n+1,m+1)
	go=n*m;
	ans=go * (go - 1) * (go - 2) / 6 - n * m * (m - 1) * (m - 2) / 6 - m * n * (n - 1) * (n - 2) / 6;//记得除掉取出数列的全排列
	for(R i=1; i<n ;i++)//因为是取了原点，所以相当于坐标系是从0开始了
		for(R j=1; j<m ;j++)//枚举这个点
			ans-=(LL)2 * (LL)(gcd(i,j) - 1) * (LL)(n - i) * (LL)(m - j); 
	printf("%lld\n",ans);
}

int main()
{
	freopen("in.in","r",stdin);
	work();
	fclose(stdin);
	return 0;
}
```

---

## 作者：BillYang (赞：15)

此题不好直接求三角形个数，用全集-补集思想转化为求三点共线的数量。

具体求法是先求出水平共线数量与竖直共线数量。

用排列组合的知识可知为$C_n^3$与$C_m^3$。

接着处理倾斜的直线，直接枚举直线起点终点无疑要超时，注意到除去水平与竖直直线后，每一条直线都是有斜率的。

故只需要枚举倾斜直线的倾斜向量，然后便可以使用最大公约数/排列组合的知识解决了。

代码如下：

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
inline const int Get_Int() {
    int num=0,bj=1;
    char x=getchar();
    while(x<'0'||x>'9') {
        if(x=='-')bj=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9') {
        num=num*10+x-'0';
        x=getchar();
    }
    return num*bj;
}
typedef long long LL;
LL n,m,ans=0;
int main() {
    m=Get_Int()+1;
    n=Get_Int()+1;
    ans=(n*m)*(n*m-1)*(n*m-2)/6; //全集 
    if(n>=3)ans-=n*(n-1)*(n-2)/6*m; //水平共线 
    if(m>=3)ans-=m*(m-1)*(m-2)/6*n; //竖直共线 
    for(int i=1; i<n; i++) //枚举倾斜向量 
        for(int j=1; j<m; j++)
            ans-=(n-i)*(m-j)*(__gcd(i,j)-1)*2; //有(n-i)*(m-j)个可选向量，中间点有gcd-1种可选方案，上下翻转*2 
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：星沐 (赞：12)

## 这是道关于排列组合的题目
#### 然后我们先来看排列组合的几个公式，如下
$\frac{}{}$
$A_n^{m}$=$\frac{n!}{(n-m)!}$;

$\frac{}{}$
$C_n^{m}$=$\frac{A_n^{m}}{m!}$=$\frac{n!}{m!(n-m)!}$;

###### ①　从n个不同元素中，任取m个元素按照一定的顺序排成一列，叫做从n个不同元素中取出m个元素的一个排列。

###### ②　从n个不同元素中，取出m个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数。

###### 即A（n,m）；

###### ①　从n个不同元素中，任取m个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合。

###### ②　从n个不同元素中，取出m个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。

###### 即C（n,m）；


------------
##### 思路：用C（n，m)的公式，先求出全集，再来减去重复的，重复的有三种，在行上，在列上，在斜线上。

### 记得用long long不然会爆int，因为我这道题就爆int了。
## 考试时记得看数据范围。
```
```

------------
### 主代码如下
```
	n++;
	m++;	//n乘以m，有n+1条线，有m+1条线，
	ans=(n*m-2)*(n*m-1)*(n*m)/（1*2*3）;//因为是求C(n*m,3);
	if(n>=3)//保证n-2>0;
	ans-=m*n*(n-1)*(n-2)/（1*2*3）;//因为是求C(n,3)，且有m列，所以乘以m；
	if(m>=3)//保证m-2>0;
	ans-=n*m*(m-1)*(m-2)/（1*2*3）；//因为是求C(m,3)，且有n行，所以乘以n；
	for(int i=1;i<n;++i)
		for(int j=1;j<m;++j)
		ans-=(n-i)*(m-j)*(__gcd(i,j)-1)*2;
		//__gcd(i,j)-1为求斜线的点的选择方案。
        //因为上下翻转都有，所以乘以2；
        
        
        //最后输出ans的值。
   
```

##### 思路和其他题解差不多，但我加上了一些理解，如有不准确的地方，请指正，谢谢；

---

## 作者：D_14134 (赞：11)

### 思路
先计算出所有点中任意选三个点的方案数，再减去三点共线的三角形数就可以。

可以注意到，当选定(0,0)(0,0)为起点时，和终点(i,j)(i,j)所形成的向量上就会有gcd(i,j)gcd(i,j)个整数点。

设点(x,y)(x,y)为点PP，当某个向量的终点变为点PP时，就可以和之前的gcd(x,y)−1gcd(x,y)−1个点以及零点形成gcd(x,y)−1gcd(x,y)−1个三点共线的三角形。

此时，线段(0,0)→(x,y)(0,0)→(x,y)的贡献就为gcd(x,y)−1gcd(x,y)−1，由于其还可以向右和向下平移，故这条向量的贡献还要再乘以(n−x)×(m−y)(n−x)×(m−y)，

此外，以(0,0)(0,0)为起点的向量的斜率的范围为[π2,−π2][π2,−π2]，为了补全左半边，还要乘以22，所以一条不垂直且不水平的向量对答案产生的负贡献为

(gcd(x,y)−1)×(n−x)×(m−y)×2(gcd(x,y)−1)×(n−x)×(m−y)×2。

# code
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define int long long
#define IN inline
int n,m,t,ans,gcd[1010][1010];
IN int getgcd(int a,int b){
	if(gcd[a][b]) return gcd[a][b];
	if(!a) return gcd[a][b]=b;
	if(!b) return gcd[a][b]=a;
	return gcd[a][b]=getgcd(b,a%b);
}
IN void init(){
	for(int i=1;i<=m;i++) gcd[0][i]=i;
	for(int i=1;i<=n;i++) gcd[i][0]=i;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) getgcd(i,j);
}
signed main(){
	scanf("%lld%lld",&n,&m);
	init();
	t=(n+1)*(m+1);
	ans=t*(t-1)*(t-2)/6;
	for(int i=0;i<=n;i++)
	  	for(int j=0;j<=m;j++)
	    	if(i||j){
	    		if(!i||!j) ans-=(gcd[i][j]-1)*(n-i+1)*(m-j+1);
	    		else ans-=2*(gcd[i][j]-1)*(n-i+1)*(m-j+1);
	    	}
	printf("%lld",ans);
}
```


---

## 作者：Hercules (赞：6)

题解：P3166 [CQOI2014]数三角形

首先可以看出这道题为组合数的题。

先变换一下题目，求在$N \times M$的网格中任意取3个点情况的数目为多少？

通过组合数的基本知识，我们可以轻易得到共有$C_{(n + 1) \times (m + 1)} ^ 3$种。

由此，我们回到本题，三角形的限制要比任取三个点要多情况——不能共线！

---

大概可以分为两种：

$\ \ \ \ $1.在同一网格线上；

$\ \ \ \ $2.在同一斜线上。

第一种情况非常容易，总共有：$(n+1) \cdot C_{m+1} ^ 3 \ + \ (m+1) \cdot C_{n+1} ^ 3$种情况。

看完这个有没有感觉这个题也就这样$QWQ$，不要骄傲，第二种你怎么搞啊。。。

通过枚举斜率吗？好像可以哦，人家数据不开心了：你不把我当人看？！~~（你本来就不是人）~~

不看空间限制和时间限制来做题都是耍流氓！

所以，**想正解！！！**

---

我们来枚举$i,j$，分别为两个点横坐标差和纵坐标差，再通过$gcd(i,j)-1$操作求出当前直线上的整点数。

在整个图中像这样的点对数量共有$(n - i + 1) \cdot (m - j + 1)$对。

则这样的情况总数量为：

$sum = \sum\limits^n_{i=1} \sum\limits^m_{j=1}(n-i+1)\cdot(m-j+1)\cdot(gcd(i,j)-1)$

复杂度为$O(n^2log(n))$，这道题完全可以过去。



像$(n-i+1) \cdot (m-j+1)$就是简单的组合数，相信大家可以理解。



解释一下为什么是$gcd(i,j)-1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/38w0mlrf.png)

例：$4 \times 6$的方格（如图），对角线连接，$4 \times 6$中$\frac{3}{2}$单位的横坐标对应1单位的纵坐标。

同理：3个单位的横坐标对应2个单位的纵坐标，有两个整点。

由此，我们可以推出$i,j$的整点数。

$P.S.$如果算两端顶点的话是$gcd(i,j)+1$，不算的话就是$gcd(i,j)-1$。

---

实际上在前面枚举$i,j$时，若从0开始枚举，就可以代替与坐标轴平行的情况，但是为了更容易理解，代码是先处理完直线再进行斜线处理的。

```c
#include <bits/stdc++.h>
#define int long long

int n, m, ans;

inline int calc(int x) {
	return x * (x - 1) * (x - 2) / 6;
}

inline int gcd(int x, int y) {
	return (!y) ? x : gcd(y, x % y);
}

signed main() {
#ifndef ONLINE_JUDGE
#ifdef LOCAL
	freopen("testdata.in", "r", stdin);
	freopen("testdata.out", "w", stdout);
#endif
#ifndef LOCAL
	freopen("20200725数三角形.in", "r", stdin);
	freopen("20200725数三角形.out", "w", stdout);
#endif
#endif
	scanf("%lld %lld", &n, &m);
	int t = (n + 1) * (m + 1);
	ans = t * (t - 1) * (t - 2) / 6 - calc(n + 1) * (m + 1) - calc(m + 1) * (n + 1);
	for (register int i = 1; i <= n; i++)
		for (register int j = 1; j <= m; j++)
			ans -= (n - i + 1) * (m - j + 1) * 2 * (gcd(i, j) - 1);
	printf("%lld\n", ans);
	return 0;
}
```



这道题被我们解决了，一道简单的组合数学的题，就是枚举比较巧妙。


---

## 作者：Mihari (赞：6)

# T3 「CQOI2014」数三角形
## 题目
[点这里](https://loj.ac/problem/2240)
## 考场思考
听歌听到兴头上，不要打扰我...

~~虽然写道这里我也在听歌...~~ 
## 正解
~~其实这道题还是可做的。~~ 

>膜拜 [$luogu$ 大佬](https://www.luogu.org/blog/suwakow/solution-p3166)  orz or2 orz
>膜拜 [机房大佬 $\text{JZM}$](https://blog.csdn.net/qq_42101694/article/details/103073680) orz or2 orz

其实我与 [机房大佬 $\text{JZM}$](https://me.csdn.net/qq_42101694) 的思路如出一辙

~~因为我们都看了同一篇博客~~ 

回到正题，这道题怎么做？

`子方法 1`

先想怎么得到一点部分分。

考虑暴力

暴力枚举 $p_1,p_2,p_3$ 的横纵坐标。

其实很好实现，时间复杂度 $O(N^3M^3)$

~~我考试的时候居然连这个都没打~~

`子方法 2 (正解)`

现在应该朝更高的得分去奋斗。

转换思考方向，我们要找的这些三角形有怎样的特点呢？

先看一个网格中的三角形：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191114203227408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY2hpbmVyeUNvdW50cnk=,size_16,color_FFFFFF,t_70#pic_center)

似乎它和我们平常看到的三角形没啥不同的。

但是如果你这样看呢？

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191114203519481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY2hpbmVyeUNvdW50cnk=,size_16,color_FFFFFF,t_70#pic_center)

不难看出，$\triangle BCE$ 被矩形 $ABCD$ 完全包围。

但是这里要否决一种情况，如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191114204201292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY2hpbmVyeUNvdW50cnk=,size_16,color_FFFFFF,t_70#pic_center)

这个三角形不能说是被整个矩形完全包围的，还有更小的矩阵更 `适合` 它。

用这样的眼光去看每一个三角形，不难看出，每一个三角形都被某一个矩形所围起来。

调转思路，我们要求大矩阵 $(N,M)$ 中有多少个这样的三角形，是否就是被包含在 $(N,M)$ 中的每一个小矩阵中所含的三角形个数之和？

正确性显然，证明此处不给出。

那么，引出下一个问题：如何快速求出一个矩阵 $(i,j)$ 中含有多少个被其完全包围的三角形？

这里分开讨论：
___
`情况 1`
形如以下被包围的三角形：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191114204519569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY2hpbmVyeUNvdW50cnk=,size_16,color_FFFFFF,t_70#pic_center)

其实也可以叫做：
>**有且只有**一个顶点与矩形顶点重合

就用上图情况来说，$F、D$ 的位置有多少个？

显然：$(i-1)(j-1)$ 个 **（不与顶点重合）**

有四个顶点，共 $4(i-1)(j-1)$ 个。
___

`情况 2`

这里不再附图，直接描述

>**有且只有**两个点与矩形顶点重合，并且这两个点不是矩形对角线

这样的情况有多少？先给出一张初始图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191114205132563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY2hpbmVyeUNvdW50cnk=,size_16,color_FFFFFF,t_70#pic_center)

先假设有一个点已与矩形顶点重合，不妨假设 $D$ 已与 $C$ 重合。
再假设 $H$ 与 $E$ 重合

那么显然，$G$ 只能在线段 $AB$ 上动，共有 $i-1$ 个合法位置 **（不能与顶点重合）**。

那么，如果 $G$ 与 $B$ 重合时呢？

这时 $H$ 只能在 $AE$ 上动，公共 $j-1$ 个合法位置。

而每种情况最多出现两次，共 $2[(i-1)+(j-1)]$ 种情况。

___
`情况 3`
形如以下的三角形：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191114205940293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY2hpbmVyeUNvdW50cnk=,size_16,color_FFFFFF,t_70#pic_center)

我们把它叫做

>**有且只有**两个点与矩形顶点重合，且这两个点构成矩形对角线

这样的情况其实有些复杂，因为这个 $P$ 点显然可以随便取 ~~除非它跑出矩形去或者在 DF 这条线上~~ 

首先，不考虑它跑到 $DF$ 线段上去了。

那么这样的点有多少个？

显然有 $(i+1)(j+1)-4$ 个，为什么 $-4$ ？它不能与矩形顶点重合。
那么，现在考虑在 $DF$ 上有多少个点。

首先，我们假设当 $P(x,y)$ 时在 $DF$ 上，那么就有：

$$\frac{D_y-F_y}{D_x-F_x}=\frac{y-F_y}{x-F_x}$$
接下来怎么化简？

**对于任意一条线段，假若我们把它平移到某个端点与原点重合时，它所经过的整点的数量是不变的。**

那么我们假设把 $F$ 平移到 $O$ 上面去，那么就有：

$$\frac{D_y}{D_x}=\frac{y}{x}$$

而其中 $x,y$ 是整数。

接下来，这 $x,y$ 有哪些取值？

这样打开：

$$\frac{p\times gcd(D_x,D_y)}{q\times gcd(D_x,D_y)}=\frac{y}{x}$$
那么，显然可以看出：

 - 当 $x=q$ 时，$y=p$
 - 当 $x=q\times 2$ 时，$y=p\times 2$
 - 当 $x=q\times 3$ 时，$y=p\times 3$
 ...

 - 当 $x=q\times gcd(D_x,D_y)=D_x$ 时，$y=p\times gcd(D_x,D_y)=D_y$

（$tip$：这也算是给楼下大佬的一个补充吧...）

要问 $x,y$ 有多少组取值？显然 $gcd(D_x,D_y)$ 种。

但是，去掉端点，就只有 $gcd(D_x,D_y)-1$ 种。

但是每个矩形一共有两条对角线 ~~不可能有只有一条对角线的长方形吧~~ 
所以一共有 $2\times (gcd(len_x,len_y)-1)$ 种三角形。

注意我这里所用的是**长度**，因为我们之前为了处理方便，将 $F$ 点假定为了原点。

___
`情况 4`
当三个点都与矩形重合时，有多少种情况呢？

对于每一个矩形来说，应该都是固定的吧。

一共有 $4$ 个。

___
一共的情况，就只有这四种，那么，我们将这些贡献全部加起来，得到
$$\begin{aligned}
w&=4(i-1)(j-1)+2[(i-1)+(j-1)]+ \\
&2\{ (i+1)(j+1)-4-[gcd(i,j)-1] \}+4\\
&=6ij-2\times gcd(i,j)
\end{aligned}$$
最后用 $O(NM)$ 枚举 $i、j$，再将这些贡献加 起来即可。

注：这只是单个矩形的贡献，一共有 $(N-len_x+1)(M-len_y+1)$ 个长度为 $len_x$，宽度为 $len_y$ 的矩形。


```cpp
#include<cstdio>

#define rep(i,__l,__r) for(register int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define dep(i,__l,__r) for(register int i=__l,i##_end_=__r;i>=i##_end_;--i)
// #define FILEOI
#define int long long

#define cg (c=getchar())
template<class T>inline void qread(T& x){
	x=0;char c;bool f=0;
	while(cg<'0'||'9'<c)if(c=='-')f=1;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	if(f)x=-x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
inline int qread(){
	int x=0;char c;bool f=1;
	while(cg<'0'||'9'<c)if(c=='-')f=0;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	return f?x:-x;
}
#undef cg
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline void getInv(int inv[],const int r,const int MOD)
{inv[0]=inv[1]=1;for(int i=2;i<=r;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;}
inline int gcd(const int a,const int b){return b?gcd(b,a%b):a;}
template<class T>void fwrit(const T x){
	if(x<0)return (void)(putchar('-'),fwrit(-x));
	if(x>9)fwrit(x/10);putchar(x%10^48);
}

int m,n,ans;

inline void init(){qread(m,n);}

inline int calc(const int i,const int j){return 6*i*j-2*gcd(i,j);}

signed main(){
#ifdef FILEOI
	freopen("triangle.in","r",stdin);
	freopen("triangle.out","w",stdout);
#endif
	init();
	rep(i,1,m)rep(j,1,n)ans+=(m-i+1)*(n-j+1)*calc(i,j);
	fwrit(ans),putchar('\n');
	return 0;
}
```

---

## 作者：不存在之人 (赞：5)

### 数学题，补集转化。

**总点数-共线点数，横着竖着直接算好了，斜着需要考虑一下。**

考虑枚举两个点之间的横坐标之差和纵坐标之差，如果是$(0,0)$到$(a,b)$的矩形，对角线上有$gcd(a,b)-1$个点。

为什么呢？把斜边看成直角三角形，那么如果存在$(0,0)-(c,d)在(0,0)-(a,b)$上，那么这两个直角三角形相似，如果一个直角三角形不能再往下分，当且仅当$c$和$d$互质，即$c=a/gcd(a,b),d=b/gcd(a,b)$

**然后算一下这样的斜线有多少条就好了。**
```cpp
#include<cstdio>
using namespace std;
int n,m;
long long ans;
long long C(int x)
{
	return (long long)x*(x-1)*(x-2)/6;
}
int gcd(int x,int y)
{
	if (y==0) return x;
	else return gcd(y,x%y);
}
int main()
{
	scanf("%d%d",&n,&m);
	n++;m++;
	ans=C(n*m)-(long long)n*C(m)-(long long)m*C(n);
	for (int i=1;i<n;i++)
	  	for (int j=1;j<m;j++)
	  	{
	  		int num=gcd(i,j)-1;
	  		if (num>=1) ans-=(long long)(n-i)*(m-j)*num*2;
	  	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：qiianr (赞：5)

  [洛谷传送门](https://www.luogu.org/problemnew/show/P3166)
## 题目概述
n*m的矩阵中三角形的个数 （三角形三个顶点要在格点上）

恩，这不就是再 **（n+1）*(m+1)** 个点中选三个**合法**点嘛~~（思路在乱搞中开始涌现）~~

天哪，三个点对（n+1）* (m+1)个点，简直无异于大海捞针，固定了一个点，还有另外两个点，而且固定的位置也不好确定，所以，换一换思路吧

不如反过来想，我们可以找不符合三角形规则的方案总数，用总方案数减去，剩下的就是我们所求的了

继续推！！！

###  总方案数 C ( (n+1)*(m+1) ,3 );

**不合法的点即不符合三角形三点共线规则：**

1.三点在同一列或同一行
```java
要不重不漏的求出
C(n+1,3)*(m+1)+C(m+1,3)*(n+1)
```

2.三点在同一斜线
```java
枚举对角线(左下-右上), 即(0, 0)-(x, y), 我们发现这种情况有(n-y)*(m-x)*2(算上左上-右下的)种, 
然后中间有gcd(x, y)-1个点(不合法), 乘起来就好了
我们枚举一下边上两个点的横纵坐标之差(i,j)。
那么中间的点可选的位置就是gcd(i,j)-1;然后再乘上这种直线的条数即可。
```
### 组合数需预处理

**杨辉三角法**
```cpp
int exi[SIZE][SIZE];
long long C(int n,int m){//C(n,m)=C(n-1,m)+C(n-1,m-1)
	if(m==0 || m==n) return 1;
	if(exi[n][m]) return exi[n][m];
	else return exi[n][m]=C(n-1,m)+C(n-1,m-1);
}
```
尤其要注意递归的边界

时间复杂度不超过O(n^2)

**巧妙法**
```cpp
long long C(int n,int m){
	long long ans=1;
	for(int i=1;i<=m;i++)
		ans=ans*(long long)(n-m+i)/i;
	return ans;
}
```
这种方法甚是巧妙, 较好地**规避了数据溢出**的情况

##### AC代码
```cpp
#include <cstdio>
#include <iostream>
#define ll long long
using namespace std;
int n,m;

int gcd(int a,int b){//辗转相除求最大公约数
    return b==0?a:gcd(b,a%b);
}

ll C(int n,int m){
    long long res=1;
    for(int i=1;i<=m;i++)
        res=res*(ll)(n-m+i)/i;
    return res;
}

int main(){
    scanf("%d%d",&n,&m);
    ll ans=C((n+1)*(m+1),3);//方案总数
    for(int i=2;i<=n;i++){//计算斜对角线上的三点共线
        for(int j=2;j<=m;j++){
            ans-=(ll)(gcd(i,j)-1)*(n-i+1)*(m-j+1)*2;
        }
    }
    ans-=C(n+1,3)*(m+1);
    ans-=C(m+1,3)*(n+1);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：little_prince (赞：2)

数字三角形

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans;
int gcd(int a,int b) {
	if(a%b==0) return b;
	return gcd(b,a%b);
}
int main() {
	cin>>n>>m;
	
	for(long long i=1;i<=n;i++)
	for(long long j=1;j<=m;j++){
		ans+=(long long)(n-i+1)*(m-j+1)*(6*i*j-2*gcd(i,j));
	}
	cout<<ans; 
	/* 
	第一种情况：有两个点在矩形的一条边上，第三个点在这两个点所在公共边的对边上
	那么，每一条边都会有m+1或n+1种情况，在矩形顶点会重复，一共重复4次
	ans1=2(m+1)+2(n+1)-4;
	第二种情况：固定一个点在矩形顶点上，另外两点分别在此点所对的两条边上（即一点固定在矩形顶点，三点不在一条边上）
	那么，每一个固定顶点都会有4(m-1)(n-1)种情况，一共可以固定4个顶点
	ans2=4(m-1)(n-1);
	第三种情况：两点固定在对角线上
	先算出所有点的个数为(m+1)(n+1)个，因为三点不能共线，所以首先减去当前对角线经过的点(gcd(m,n)+1) <请自行证明>
	然后减去另外两个矩形顶点（不然会与第一种情况重复） 有两条对角线 
	ans3=2((m+1)(n+1)-(gcd(m,n)+1)-2)
	所以每一个当前矩形的方案数：
	total=ans1+ans2+ans3=6mn-2gcd(m,n); 
	枚举每一个当前矩形（将上面的m,n换成i,j） 
	而每一个当前矩形的个数有(n-i+1)*(m-j+1)个
	答案就显而易见咯 */
	return 0;
}

```

---

## 作者：aiyougege (赞：2)

### bzoj 3505 [Cqoi2014]数三角形
#### Description
给定一个nxm的网格，请计算三点都在格点上的三角形共有多少个。下图为4x4的网格上的一个三角形。
注意三角形的三点不能共线。
#### Solution
　　网格上共有$s=(n+1)(m+1)$个点.第一个点任取, 第二个点取处第一个之外的一个, 这两个点取的方案为$s\times (s-1)$ 个, 第三个点除了不能取这两个点之外, 也不能取这两个点所在的直线上的点.
　　问题转化为在网格图中一条直线上有几个点.发现一条直线上点的斜率$t=\frac{y}{x}$确定, 而一个点的$x,y$都必须为整数, 设$d=(a,b)$, 所以直线上$\frac{y}{d}$单位个纵坐标和$\frac{x}{d}$单位个横坐标对应一个网格上一个点.所以一条直线上网格上的点数为$$\min\{\frac{y}{\frac{y}{d}}+1,\frac{x}{\frac{x}{d}}+1\}=d+1$$.
　　所以可以枚举每一条直线, 然而枚举一条直线不如枚举一条线段, 这样只需要让线段起点为$(0,0)$, 枚举线段的终点$(x,y)$, 而与其完全相同的线段有$(n+1-y)(m+1-x)$条, 这是斜率大于0的线段, 还有斜率小于0的线段, 一条斜率大于0的线段和一条斜率小于0的线段是一一对应的.综上所述, 答案可以表示为
　　$$C_{nm}^3-mC_n^3-nC_m^3-2\sum_{y=1}^n\sum_{x=1}^m\left( (x,y)-2\right) \times(n+1-y)(m+1-x)$$
#### Code
```c++
#include<iostream>
#include<cstdio>
using namespace std;
#define int long long

int gcd(int a,int b){return (!b)?a:gcd(b,a%b);}
long long C3(int n){
	return (long long)n*(n-1)*(n-2)/6;
}

int n,m;

main(){
	scanf("%lld%lld",&n,&m);
	long long ans=C3((n+1)*(m+1))-(m+1)*C3(n+1)-(n+1)*C3(m+1);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			ans-=2*(gcd(i,j)-1)*(n+1-i)*(m+1-j);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：yzxoi (赞：2)

三倍经验![](https://i.loli.net/2019/02/22/5c6febb58ef30.jpg)
### [LOJ #2240. 「CQOI2014」数三角形](https://loj.ac/problem/2240)
### [BZOJ 3505: [Cqoi2014]数三角形](https://www.lydsy.com/JudgeOnline/problem.php?id=3505)
## [Luogu P3166 [CQOI2014]数三角形](https://www.luogu.org/problemnew/show/P3166)
（Luogu要大一些。。。）
## 题意
给定一个$n \times m$的网格，请计算三点都在格点上的三角形共有多少个。下图为$4 \times 4$的网格上的一个三角形。注意三角形的三点不能共线。

![](https://i.loli.net/2017/05/03/59091867eebda.png)
## 思路
由题意可知，其实就是让你求一个网格内有多少个不同的三角形。

First Of All，这个网格是从$(0,0)$到$(n,m)$的，出现了令人难受的$0$，于是我们可以在一开始把$n++,m++$范围就变成了$(1,1)$到$(n,m)$$\quad (n,m)$都已$+1$。

由于三角形是不可以三点共线的，所以我们可以求出不符合条件的三角形个数（三点共线）以及所有的三角形个数（包括不符合的与符合的）。

那么最终的答案=总方案数即所有的三角形个数（包括不符合的与符合的）-不符合条件的三角形个数（三点共线）

有了这个思路后就可以开始解决这道题了。

总方案数很简单，无非就是在一个$(n,m)$的网格中任意选取$3$个点，求方案数嘛！所以我们可以搬出~~小学~~~，不对，~~初中~~，不对，~~高中~~，对对对，学的知识——组合公式。

先来看看百度百科对组合数的介绍：
>组合数公式是指从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做$n$个不同元素中取出$m$个元素的组合数。用符号$C(m,n)$ 表示。

相信你一定看(mei)懂(kan)了。

没关系，反正你只需要记住组合公式：
$$C_{n}^{m}=\frac{n!}{m!(n-m)!}$$

那么组合数的C++怎么实现呢？

#### 方法一：暴力？不介绍。

#### 方法二：优化的暴力

首先感觉枚举两次虽然不会TLE，但是容易爆long long。然而我非常懒，所以就不想打高精。
为了防止爆long long。这里给出某个大佬的做法：

首先你枚举一个$i$从$1$~$m$。那么看一看上面的组合公式，哪些量可以用$i$、$n$、$m$来表示?

首先$m!=m\times (m-1) \times (m-2) \times \dots \times 1$。然后惊人的发现，这不就是$res/i$吗？

然后看$\frac{n!}{(n-m)!}$。因为$n!=n \times (n-1) \times (n-2) \times(n-3) \times \dots \times 1$，$(n-m)!=(n-m) \times (n-m-1) \times \dots \times 1$。因为$n>n-m$，所以$\frac{n!}{(n-m)!}=n \times (n-1) \times (n-2) \times \dots \times (n-m+1)$。这不就是$res \times (n-m+i)$吗？

如果觉得有问题，可以动脑想一想。
```C++
long long C(long long a,long long b){
    long long res=1;
    for(long long i=1;i<=b;i++)
        res=(res*(long long)(a-b+i))/i;
    return res;
}
```
终于把组合数介绍完了。。。
接下来废话少说，返回到这道题上。

总方案数$=C_{3}^{n\times m}$。

接下来算一算不满足的方案数（三点共线）。

如果是一列的三点共线：方案数$=C_{3}^{n}\times m$

如果是一行的三点共线：方案数$=C_{3}^{m}\times n$

如果是斜着的三点共线。那么就要通过枚举来看一看有多少是不满足的（三点共线）

PS:一条斜线从$(0,0)$到$(x,y)$有$gcd(x,y)-1$个整点。

于是乎，我们可以枚举$x$、$y$，因为起点不一定为$(0,0)$，所以，每次枚举就要将答案减去整点的个数$\times (n-i)\times(m-j )\times 2$（因为有两条对角线，所以乘$2$）。

## 代码
我知道泥萌就想看这个：
```C++
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans;
long long gcd(long long x,long long y){
    return y==0?x:gcd(y,x%y);
}
long long C(long long a,long long b){
    long long res=1;
    for(long long i=1;i<=b;i++)
        res=(res*(long long)(a-b+i))/i;
    return res;
}
//C(n,m)=n!/(m!*(n-m)!)
int main(){
    scanf("%lld%lld",&n,&m);
    n++;m++;
    ans=C(n*m,3);
    ans-=C(n,3)*m;
    ans-=C(m,3)*n;
    for(long long i=2;i<=n-1;i++){
        for(long long j=2;j<=m-1;j++){
            long long Pt=gcd(i,j)-1;
            ans-=Pt*(n-i)*(m-j)*2;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：BlueQuantum (赞：1)

# 「CQOI 2014」数三角形 题解

蒟蒻模拟赛题~~啥都不会~~

比赛时打了个$O(n^2m^2)$的暴力~~还WA了~~

## 正题

题目要求在$n \times m$个网格中选3个点组成三角型求方案数

然而$n \times m$个网格中其实是有$(n+1) \times (m+1)$个点的，所以下文中$n$和$m$都是加1之后的

我当时思路是枚举两个点然后计算第三个点的贡献，显然会T。考虑采用组合数和容斥解决:
$\binom{n\cdot m}3$ 表示从所有点中选三个点，即所有“三角型”的数目。但实际上有很多不合法的情况，即三点共线的情况。其中三点共线的情况又分为竖着，横着，和斜着。

竖着和横着的情况较好处理(以横着为例): 从横着总共$m$个点中选3个: $\binom m3$, 乘上总共$n$行即: $n \times \binom m3$

最麻烦的是斜着的线

先考虑一个性质: 斜着的两个点, 设为$A(a, b)$和$B(c,d)$, 之间的整点(不包括$A$和$B$)数有$\gcd(|a-c|,|b-d|)-1$个.

可以这样理解: $\gcd(|a-c|,|b-d|)$即为$A,B$两点间横坐标的差能被整分，同时纵坐标的差也能被整分的份数，再根据~~小学学过的~~植树原理，减去1就是$A,B$两点间斜线段内的整点数.

然后, 我们具体考虑怎样去除所有斜向不合法的点. 如果一个一个点对去枚举的话同样是会超时的, 必须优化. 可以想到, 斜率为正的线段和斜率为负的线段方案是一样的, 于是可以只算正的最后把答案$\times 2$.

还不够, 继续优化, 发现需要统计的线段中有很多斜率, 长度一模一样的线段, 只是位置不同, 而计数问题显然不用考虑位置的影响, 于是想办法高效计算这些一样的线段. 我们可以只枚举线段的一个端点$(x,y)$, 把另一个端点固定为$(0,0)$, 这样就已经可以枚举出所有不同斜率和长度的线段了, 这样的一条线段我们把它看作是选定端点再从内部选一个点组成的三角形, 所以方案数为$\gcd(|a-c|,|b-d|)-1$. 然后考虑这样一个线段会出现多少次, 是$(n-x)*(m-y)$次.

终于, 得出结果是:
$$
\binom{n\cdot m}3-n*\binom m3-m*\binom n3-2\sum_{x=1}^{n-1}\sum_{y=1}^{m-1}(\gcd(x,y)-1)*(n-x)*(m-y)
$$
(枚举上界是$n-1$和$m-1$(其实就是原题中的$n,m$)的原因是我的点是从0~n编号的)

*Talk is cheap, show me your code*:

```cpp
#include <cstdio>

typedef long long ll;
int n, m, tot;
ll ans;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

int main() {
#ifndef ONLINE_JUDGE
#ifdef LOCAL
  freopen("testdata.in", "r", stdin);
  freopen("testdata.out", "w", stdout);
#endif
#ifndef LOCAL
  freopen("tri.in", "r", stdin);
  freopen("tri.out", "w", stdout);
#endif
#endif

  scanf("%d%d", &n, &m);
  ++n, ++m;
  tot = n * m;
  ans = 1ll * tot * (tot - 1) * (tot - 2) / 6 - 1ll * n * m * (m - 1) * (m - 2) / 6 -
        1ll * m * n * (n - 1) * (n - 2) / 6;
  for (int i = 1; i < n; ++i) {
    for (int j = 1; j < m; ++j) {
      ans -= 2ll * (gcd(i, j) - 1) * (n - i) * (m - j);
    }
  }
  printf("%lld", ans);
  return 0;
}
```

---

## 作者：potatoler (赞：1)

### [题目](https://www.luogu.com.cn/problem/P3166)简述

给定一个 $N\times M$ 的网格，请计算三点都在格点上的三角形共有多少个。注意三角形的三点不能共线。

### 思路

直接求三角形的个数比较困难。我们知道在网格中随便选三个不共线的格点就可以构成一个三角形，所以总选法减去三点共线的方案数就是三角形的个数。

横纵向三点共线的方案很好统计：对于题目中 $N$ 行 $M$ 列的网格，每行有 $M+1$ 个点，三点共线的方案数就是 $C^3_n$，因为有 $N$ 行所以横向三点共线总方案数一共是 $N \times C^3_n$；纵向可以使用相同的方法算出。

接下来我们考虑一下斜向三点共线的方案数：选定三点中的两个点作为一条线段上的两个端点，线段上（除两端点）的格点数就是在两点确定的情况下三点共线的方案数。![三角形.png](https://i.loli.net/2020/07/25/94M51bv8wd36uBJ.png)
不妨看一下这张图：黑色的线是我们选定两端点构成的线段，添加灰色的辅助线我们可以以它为斜边扩展成一个两条直角边分别为 $i$，$j$ 的直角三角形。如果其中还有 $i=nk$，$j=mk$，那么我们还可以找到正好 $k$ 个小三角形，它们的两条直角边分别是 $n$，$m$，斜边是原来的线段上均等的 $k$ 段。为什么是这样呢？如果把左下的端点看作平面直角坐标系上的原点，那么右上的端点坐标就是 $(i,\ j)$。这条线段所处的直线是正比例函数 $y=kx$，其中斜率 $k=\frac{j}{i}=\frac{m}{n}$。线段上的点都满足这个关系式，但是因为是在网格图上，可选的只有坐标为整数的点。约去 $i$ 与 $j$ 的最大公约数 $k$，所得的 $m$ 和 $n$ 便是按照上面的的方法画出的小直角三角形的直角边长度。因为约去了 $k=GCD(i,j)$，所以一共有 $k$ 个这样的小三角形，即线段可以被格点分成 $k$ 段，也就是有 $k-1$ 个可选的中间点。

刚才只是对于一个固定的线段分析的，同样形态的线段可以在网格中的多个位置出现，线段也会有不同的形态。我们可以枚举 $i$ 和 $j$ 处理不同形态的线段，并将结果乘以它横纵可以移动的范围。当然更简单的理解方法是将线段抽象成一个向量，仍然枚举 $i$ 和 $j$ 并让它在网格中移动。

值得注意的是，$N\times M$ 的网格横纵点数都要加一，而且如果默认讨论两端点在左下和右上，实际的方案数还要乘以 2。

### Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<climits>
#include<utility>
#define int long long
using namespace std;
int n, m, ans;

inline int GCD(int a, int b){
	return b>0 ? GCD(b, a%b) : a;
}

signed main(){
	scanf("%lld%lld", &n, &m);
	n++, m++;
	ans = (n*m)*(n*m-1)*(n*m-2)/6;
	if(n >= 3) ans -= (n*(n-1)*(n-2)/6) * m;
	if(m >= 3) ans -= (m*(m-1)*(m-2)/6) * n;
	for(int i=1;i<n;i++)
		for(int j=1;j<m;j++){
			ans -= (n-i)*(m-j)*(GCD(i,j)-1)*2;
		}
	printf("%lld", ans);
	return 0;
}
```





---

## 作者：VPYEKINDAR (赞：1)

题解其他写的都清楚，但是必须要说一点，也给大家一个提醒吧，以后考试遇见组合数这种东西，对于这一题可以递推求，也可以用公式求C(n,3)(最好用公式吧)，但是这种题千万不要用递归，像我用了递归+记忆化，考试这样写(我觉得考试这一题也不会少像我这种用递归求C的,一定要注意)，直接只有30分，所以大家以后建议用稳点得方式求这些已经有递推公式得东西，比如C，A,卡特兰数之类的

---

## 作者：littleseven (赞：0)

## 题解：

**组合数学**

*首先对于这道题的读入，n和m是从0开始计算的，为了方便处理，不妨将n与m都++。*

我们可以先考虑去枚举每一个三角形，很显然是做不到的。

那么我们可以换一种思路，我们可以确定的是每一个三角形一定有三个点，并且这三个点不共线。

对于一定有三个点，很显然我们可以得到总答案：$ans~=~C_{n*m}^{3}$

那么对于三点不共线，我们现在就要考虑以下的情况：

1.三点不共横线：很显然，我们枚举每一条横边，在上边任选三个点，这样的三个点都是不合法的，又因为有n条横边，所以$ans~-=~n \times C_{m}^{3}$

2.三点不共竖线：同上，枚举每一条竖边，任选三点除去，所以$ans~-=~m \times C_{n}^{3}$

3.三点不过斜线：如何判断斜线，这就是这道题的难点所在，分析后我们可以发现一个问题，对于一个$(x \times y)$的网格矩形，从最左上角点到最右下角点的直线会经过$gcd(x,y)-1$个格点（不包含起点和中点），同理从最右上角点到最左下角点也会经过$gcd(x, y)-1$个格点，那么我们只需要枚举所有的矩形，删去这些情况即可：$ans~-=~(n-i)*(m-j)*(gcd(i,j)-1)*2$

最终得到的ans就是答案。



**！！！注意：这道题的数据需要开$long long$**

## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

ll n, m, ans;

ll gcd(ll a,ll b)
{
	if (b == 0)
		return a;
	return gcd(b, a % b);
}
int main()
{
	scanf("%lld%lld", &m ,&n);
	n ++ ;
	m ++ ;
	ans = (n * m) * (n * m - 1) * (n * m - 2) / (1 * 2 * 3);
	ans -= n * m * (m - 1) * (m - 2) / (1 * 2 * 3);
	ans -= m * n * (n - 1) * (n - 2) / (1 * 2 * 3);
	for (ll i = 2; i < n; i ++ )
		for (ll j = 2; j < m; j ++ )
		{
			ans -= (n - i) * (m - j) * (gcd(i, j) - 1) * 2;
		}
	printf("%lld\n", ans);
	return 0;
}
```

---


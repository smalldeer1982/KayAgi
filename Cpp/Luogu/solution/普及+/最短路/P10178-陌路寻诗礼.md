# 陌路寻诗礼

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/pkwo5ogg.png)

作为 luogu 网红的帆巨，有非常多狂热的粉丝，而我们的帆巨也很喜欢面基，寻找遍布大江南北的粉丝们。




## 题目描述

帆巨所在的家乡的地图是一张有 $n$ 个节点 $m$ 条有向道路的有向图，每个节点都是一个城市，而帆巨所在的城市是 $1$ 号城市，并且 $1$ 号城市总是可以通过若干道路到达其他任何城市。

第 $i$ 条道路从 $x_i$ 号城市出发到达 $y_i$ 号城市，长度为 $z_i$。

帆帆现在要从他的 $1$ 号城市前往各个城市面基。

精通 spfa 算法的帆帆在面基的过程中自然会按照长度和最短的路径去其他城市。

但是帆帆有选择困难症，他希望从 $1$ 号城市到达每一座城市的最短路径都是唯一的，所以他决定施加魔法，改变所有道路的长度，具体地：

帆巨施加魔法后，对于每一条道路的长度，都可以 **独立地** 将其变成一个 $[1,k]$ 范围内的整数，其中 $k$ 是帆巨的魔法等级。

但帆巨所在的世界的地图和他的魔法等级一直在变，总共会变 $T$ 次，所以他希望你对 $T$ 次询问都给出一种构造方法使得帆巨不会纠结或者报告无解。



## 说明/提示

### 【样例解释】

对于第一组数据，$1$ 号点到达每个点的路径都是唯一，自然无论怎么设置边权，最短路都是唯一的。

对于第二组数据，因为 $k=1$，所以两条边的边权都只能设置为 $1$。$1$ 号点到 $2$ 号点的最短路长度为 $1$，走两条边都可以，所以不是唯一的。

### 【数据范围】

本题采用捆绑测试。

对于 $20\%$ 的数据，$n,m\leq 5$。

对于另外 $20\%$ 的数据，$k=1$。

对于另外 $20\%$ 的数据，$m=n-1$。

对于另外 $20\%$ 的数据，$k=10^9$。

对于 $100\%$ 的数据，$n\ge 1$，$m\ge 0$，$1\le \sum n,\sum m\leq 3\times 10^5$，$1\leq k \leq 10^9$，$1\le x_i,y_i\le n$。

## 样例 #1

### 输入

```
2
3 2 3
1 2
2 3
2 2 1
1 2
1 2```

### 输出

```
Yes
1 2
No```

# 题解

## 作者：CleverRaccoon (赞：25)

## 前言

我认为官方题解的思路和代码稍有些复杂，所以来分享一下我的思路。

代码似乎和 dijkstra 板子没差几行。

## 题目描述

在一个 $n$ 个点 $m$ 条边的无向图中构造出每条边的长度 $z_i$（$1\leq z_i\leq k$），使得点 $1$ 到任何一个点的最短路径都是**唯一**的，如果不能做到，则报告无解。

## 思路

考场上我的做法只涉及到了普通的 dijkstra 进行略微的修改。

文中提到的 spfa 算法很好地帮助我们很好的想到了 dijkstra 算法（spfa 算法可能会被卡，而且也没有负权，因为 $1\leq z_i\leq k$）。

- 首先写好 dijkstra 的板子。

- 接下来，我们思考，如果所有最短路径都是唯一的，那么每条边的边权 $z_i=1$ 即可。

- 如果有最短路径不唯一呢？如果找到一条路径和当前找到的路径长度相同，那么如果当前找到了第 $i$ 条边，使 $z_i\to z_i+1$ 即可，这样就可以避免路径长度相同了。

- 接下来，判定无解：如何判定无解呢？因为我们只要在第 $i$ 条边找到一条长度相同的最短路径，就会使 $z_i\to z_i+1$，那么很有可能 $z_i$ 经过多次 $z_i\to z_i+1$ 就会超过 $k$，超过 $k$ 即无解。故只要判断 $z_i$ 中的最大值是否大于 $k$ 即可。如果大于 $k$ 则无解；否则有解，输出每条边的边权 $z$ 数组即可。

一句话总结，先写 dijkstra 板子，然后边权全部初始化为 $1$，如果碰上路径长度相同，则将当前这条边的边权加一，最后判断如果最大边权超过 $k$，则无解，否则有解，输出答案即可。

个人认为自己的思路比较简单易想且写起来很方便。

## 代码

相比 dijkstra 模板，基本上没改几行。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF=1e9;
const int N=3e5+5;

struct nodee{
	int to,id;	// id 记录是第几条边
};

vector<nodee> e[N];
int n,m,k;
int T;
bool vis[N];
int dis[N];
int ans[N],mx;	// ans 数组即 z 数组，mx 记录 ans 的最大值，以便判断是否大于 k

struct node{
	int id,val;
	bool operator<(const node &o)const{	// 比较结构体大小
		return val>o.val;
	}
};

bool dijkstra(int s){	// dijkstra 板子
	memset(vis,0,sizeof vis);	// 清空很重要
	memset(dis,0x3f,sizeof dis);
	mx=-INF;	// 求最大，所以先设为一个极小值
	priority_queue<node> q;	// 使用优先队列优化
	q.push({s,0});
	dis[s]=0;
	while(!q.empty()){
		int u=q.top().id;
		int val=q.top().val;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=0;i<e[u].size();i++){
			int v=e[u][i].to,id=e[u][i].id;
			if(dis[v]>dis[u]+1){	// 边权都是 1，由于每条边只会遍历一次，所以修改不会影响唯一一次遍历时的边权 1
				dis[v]=dis[u]+1;
				q.push({v,dis[v]});
			}else if(dis[v]==dis[u]+1){	// 如果最短路径长度相同，那么 ++ans[id] 同时记录最大值即可
				mx=max(mx,++ans[id]);
			}
		}
	}
	return mx<=k;	// 如果最大值不超过 k 那么就有解
}

int main(){
	cin>>T;
	while(T--){
		cin>>n>>m>>k;
		for(int i=1;i<=n;i++)e[i].clear();	// 清空
		for(int i=1;i<=m;i++){
			int x,y;
			cin>>x>>y;
			e[x].push_back({y,i});	// 要记录是第 i 条边
		}
		fill(ans+1,ans+m+1,1);	// 一开始边权 ans 即 z 都设为 1
		if(dijkstra(1)){	// 有解
			puts("Yes");
			for(int i=1;i<=m;i++)cout<<ans[i]<<" \n"[i==m];	// 输出答案即可
		}else puts("No");
	}
	return 0;
}
```

然后就能通过本题了。


---

## 作者：云浅知处 (赞：19)

### Subtask 1

考虑假如我们知道那些边在最短路上，那贪心地让这些边的边权尽可能小，其余的边边权尽可能大即可，因此每条边只有两种取值 $1$ 或 $k$ ，我们 $2^m$ 枚举每条边的选择然后验证即可。

复杂度 $O(T2^m(n+m))$。

### Subtask 2

$k=1$ 时，每条边取值唯一，可以用 BFS 求出 $1$ 号点到每个点的最短路以及路径个数。

复杂度 $O(n+m)$。

### Subtask 3

$m-1$ 时，因为 $1$ 号点可以到达每个点，所以这是一棵以 $1$ 为根的外向树。

那么到每个点的路径唯一，随便赋值都行。

### Subtask 4

当 $k=10^9$ 时，最短路一定不会走这些边，我们相当于可以删一些边。

那么找出一棵以 $1$ 为根的外向树，树上的边赋值为 $1$，剩下的赋值为 $10^9$ 即可。

### Subtask 5

考虑一棵以 $1$ 为根的最短路径树，树边赋值为 $1$，非树边赋值为 $k$，那么到每个点的最短路就是树上的深度，记为 $\text{dep}(x)$。

对于一条非树边 $(u_i,v_i)$，我们要求 $\text{dep}(v_i)< \text{dep}(u_i)+k$，否则这条边就在最短路上。

我们找出一棵 BFS 树，那么有性质：

- 对于非树边 $(u_i,v_i)$，都有 $\text{dep}(v_i)\leq\text{dep}(u_i)+1$，否则不满足 BFS 的性质 。

因此，当 $k>1$ 时，这棵 BFS 树自然就满足 $\text{dep}(v_i)< \text{dep}(u_i)+k$，符合要求。

否则，$k=1$ 时，方案唯一，我们只需要验证就行了。

复杂度 $O(n+m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;

int T, n, m, k, d[N];
vector< pair<int, int> > g[N];
bool vis[N], tf;
queue<int> q;

int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d%d", &n, &m, &k); tf = false;
        for (int i = 1; i <= n; ++i) d[i] = -1, g[i].clear();
        for (int i = 1, x, y; i <= m; ++i) {
            scanf("%d%d", &x, &y); vis[i] = false;
            g[x].push_back(make_pair(y, i));
        }
        d[1] = 0; q.push(1);
        while (!q.empty()) {
            int x = q.front(); q.pop();
            for (auto tmp : g[x]) {
                int y = tmp.first;
                if (d[y] != -1) {
                    if (d[y] == d[x] + 1) tf = true;
                    continue;
                }
                d[y] = d[x] + 1;
                vis[tmp.second] = true;
                q.push(y);
            }
        }
        if (k == 1 && tf) {
            puts("No");
            continue;
        }
        puts("Yes");
        for (int i = 1; i <= m; ++i)
            if (vis[i]) cout<<1<<" \n"[i==m];
            else cout<<k<<" \n"[i==m];
    }
    return 0;
}
```

---

## 作者：maomao233 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10178)

赛时只会 $k=1$ 和 $m=n-1$ 的做法，菜死了。

---

乱搞做法：

先来讲述 $k=1$ 的做法。由于道路的长度一定为 $1$，所以“判断最短路径是否唯一”这个问题可以转换为[P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)。我们直接跑一遍计数，再判断答案是否均为 $1$（最短路径均唯一）即可。  
注意多测数组需清空。

然后是 $k>1$ 的做法。显然此时一定有解，因为我们可以将不同道路的长度都设为不同的值。如果我们不同道路的长度用随机数的方法生成，显然此时最短路径重复的概率是很低的，本题也就迎刃而解了。  
注意生成的随机数一定要足够得大，但同时不能小于 $1$ 或超过 $k$。这里我推荐对于第 $i$ 条边，输出 `i*100+rand()%10000+1`。   
同时，最短路径重复的概率还是有的，但是我们多交几次就能过了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
#define lb(x) x&-x
#define itn int
inline string its(int x){stringstream ss;string s;ss<<x;ss>>s;return s;}
inline int sti(string s){stringstream ss;int x;ss<<s;ss>>x;return x;}
inline string jia(string a1,string b1){int a[10010],b[10010],c[10010];int lena=a1.size(),lenb=b1.size();for(int i=0;i<lena;i++){a[i]=a1[lena-1-i]-'0';}for(int i=0;i<lenb;i++){b[i]=b1[lenb-1-i]-'0';}int lenc=max(lena,lenb),t=0;for(int i=0;i<lenc;i++){c[i]=a[i]+b[i]+t;if(c[i]>=10){t=1,c[i]%=10;}else{t=0;}}if(t==1){lenc++;c[lenc-1]=1;}string s;for(int i=lenc-1;i>=0;i--){s+=c[i]+'0';}return s;}
inline string jian(string a1,string b1){if(a1.size()<b1.size()||a1.size()==b1.size()&&a1<b1){pc('-'),swap(a1,b1);}int a[10010],b[10010],c[10010];int lena=a1.size(),lenb=b1.size();for(int i=0;i<lena;i++){a[i]=a1[lena-1-i]-'0';}for(int i=0;i<lenb;i++){b[i]=b1[lenb-1-i]-'0';}int lenc=lena;for(int i=0;i<lenc;i++){if(a[i]<b[i]){a[i+1]--,a[i]+=10;}c[i]=a[i]-b[i];}while(lenc>=1&&c[lenc-1]==0){lenc--;}string s;for(int i=lenc-1;i>=0;i--){s+=c[i]+'0';}return s;}
inline int qpow(int a,int b,int p){int ans=1;while(b){if(b&1){ans=(ans*a)%p;}b>>=1;a=(a*a)%p;}return ans;}
inline int qp(int a,int b){int ans=1;while(b){if(b&1){ans*=a;}b>>=1;a*=a;}return ans;}
int dis[300010];
int ans[300010];
int head[300010];
struct edge
{
	int v,w,nxt;
}e[300010];
int cnt=0;
inline void add(int u,int v,int w)
{
	cnt++;
	e[cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt;
}
struct node
{
	int x,y;
	bool operator<(const node&a)const
	{
		return y>a.y;
	}
};
int n,m,k;
inline void dij()
{
	dis[1]=0,ans[1]=1;
	priority_queue<node>q;
	q.push({1,0});
	while(!q.empty())
	{
		node t=q.top();
		q.pop();
		int u=t.x,d=t.y;
		if(d!=dis[u])
		{
			continue;
		}
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].v,w=e[i].w;
			if(d+w==dis[v])
			{
				ans[v]+=ans[u];
			}
			if(dis[u]+w<dis[v])
			{
				dis[v]=dis[u]+w,ans[v]=ans[u];
				q.push({v,dis[v]});
			}
		}
	}
}
signed main()
{
	int t;
	rd(t);
	while(t--)
	{
		rd(n,m,k);
		cnt=0;
		for(int i=1;i<=n;i++)
		{
			dis[i]=1e18,ans[i]=head[i]=0;
		}
		for(int i=1;i<=m;i++)
		{
			int x,y;
			rd(x,y),add(x,y,1);
		}
		if(k==1)
		{
			dij();
			int flag=0;
			for(int i=1;i<=n;i++)
			{
				if(ans[i]!=1)
				{
					flag=1;
					break;
				}
			}
			if(!flag)
			{
				puts("Yes");
				while(m--)
				{
					wt(1),kg;
				}
				hh;
			}
			else
			{
				puts("No");
			}
		}
		else
		{
			puts("Yes");
			srand(time(0));
			for(int i=1;i<=m;i++)
			{
				wt(i*100+rand()%10000+1),kg;
			}
			hh;
		}
	}
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：3)

我们来想一下，怎么能求出一个图的最短路条数。

我们边 Dijkstra 边想。

点 $1$ 的最短路条数一定是 $1$，自环的边权也需要大于等于 $1$。

这也证明了自环对答案没有影响。

如果对 $(u,v,w)$ 松弛的时候。

如果 $dis_v>dis_u+w$，那么 $v$ 最短路条数就被更新（覆盖）成了 $u$ 的最短路条数。

根据乘法原理，即得证。

且因为最短路有了更新，所以这是覆盖而不是加法。

如果 $dis_v=dis_u+w$，那么 $v$ 最短路条数就加上 $u$ 的最短路条数。

根据加法原理，即得证。

且因为最短路没有更新，所以这是加法而不是覆盖。

因为每个点都有一条最短路（能到），所以我们不能让 $dis_v=dis_u+w$ 出现。

那我们就可以想出以下算法。

最开始 $dis_{2\dots n}$ 都被赋值为 $2 \times 10^9$。

接着执行 Dijkstra。

在松弛 $(u,v)$ 时。

设 $p=dis_v-dis_u$，如果 $dis_v$ 是没被更新过的，那么 $p$ 就是比较大的值。

可以证明 $dis_u$ 一定被更新过。

如果 $p>k$ 或者 $p<1$，这个时候边权 $w$ 就可以随便在 $[1,k]$ 范围内取，反正取多少没关系，我们就认定取 $1$。

如果 $1 \le p \le k$，这个时候，我们就在取数时，不能取到 $p$。

所以，我们为了不用常熟大的 `rand()` 函数，可以这样分类讨论。

如果 $1\le p<k$，就直接将 $w$ 赋值为 $p+1$，得出 $2 \le w \le k$，是 OK 的。

如果 $p=k$，就直接将 $w$ 赋值为 $p-1$，得出 $w=k-1$，是 OK 的？

当然不是，这样，就不会无解了。

除了 $p=k$ 还要满足一个条件 $p>1$ 才能满足。

因为当 $k=p=1$ 时，是不能取到任意数的。

它不满足 $1 \le p<k$，但满足 $p=k$。

但这样是无解。

所以就必须要加一个条件 $p>1$。

现在代码就简单了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int head[300010],to[600010],val[600010],nxt[600010],tot;
inline void add(int u,int v){
	to[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}
bitset<300010>vis;
int dis[300010],ans[300010];
inline bool dij(){
	priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
	for(int i=1;i<=n;i++) dis[i]=2e9;
	vis=0;
	q.push({0,1});
	dis[1]=0;
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=nxt[i]){
			int p=dis[to[i]]-dis[u];
			if(p<1 || p>k) val[i]=1;
			else if(1<=p && p<k) val[i]=p+1;
			else if(p==k && p>1) val[i]=p-1;
			else return true;
			if(dis[to[i]]==dis[u]+val[i]) return true;
			if(dis[to[i]]>dis[u]+val[i]){
				dis[to[i]]=dis[u]+val[i];
				q.push({dis[to[i]],to[i]});
			}
		}
	}
	return false;
}
void solve(){
	tot=0;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) head[i]=0;
	for(int i=1;i<=m;i++) to[i]=val[i]=0;
	tot=0;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
	}
	if(dij()) cout<<"No\n";
	else{
		cout<<"Yes\n";
		for(int i=1;i<=m;i++) cout<<val[i]<<" ";
		cout<<"\n";
	}
}
int main() {
	ios::sync_with_stdio(0);
	int t;
	cin>>t;
	while(t--) solve();
	return 0;
}
```

---

## 作者：SXqwq (赞：2)

### Description

给定有 $n$ 个节点，$m$ 条边的有向无权图。你需要给每条边赋权值 $a_i$（满足 $a_i \in \{1,k\}$)，使得从 $1$ 号节点到图上每条节点的最短路径唯一。

### Analysis

很有趣的构造题。

我们不妨从 $1$ 号节点开始，对整张图进行 BFS。对于边 $u,v$。设 $dis_i$ 表示从 $1$ 到 $i$ 的最短距离。如果 $v$ 未访问则该条边赋为 $1$ 即可。如果访问了且 $dis_u+1=dis_v$。这时如果将该条边赋为 $1$ 则会出现矛盾。赋为 $2$ 即可。

如此我们就保证了最短路径唯一。

对于判定无解，显然当 $k=1$ 时方案唯一。如果此时对某条边赋为 $2$ 则显然无解。 

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1001000;
const int INF = 0x3f3f3f3f;
typedef pair<int,int> PAIR;
int T;
int n,m,k;
int vis[N];
int idx;
int nn,mm;
struct Node
{
	int w,to,next;
}edgs[N];
int head[N];
bool flag = 0;
void add(int start ,int end , int len)
{
    idx++; 
    edgs[idx].w = len;
    edgs[idx].to = end;
    edgs[idx].next = head[start]; 
    head[start] = idx;
}
void bfs()
{
	for(int i=1;i<=n;i++) vis[i] = INF;
	queue <int> q;
	q.push(1);
	vis[1] =0;
	while(!q.empty())
	{
		int p = q.front();
		q.pop();
		for(int j = head[p] ; j != 0 ; j = edgs[j].next)
		{
			int to = edgs[j].to,w = edgs[j].w;
			if(vis[to] == INF)
			{
			    edgs[j].w = 1;
				vis[to] = vis[p] + 1;
				q.push(to);
			}
			else
			{
				if(vis[p] + 1 == vis[to]) 
					edgs[j].w = 2,flag = 1;
				else edgs[j].w = 1;
			} 
		}
	}
}
void memset1() //初始化操作，多测要清空 
{
	idx = 0;
	flag = 0;
	for(int i=1;i<=n;i++)
	{
		head[i] = 0;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>T; 
	while(T--)
	{	
		cin>>n>>m>>k;
		memset1();
		nn = n,mm = m;
		for(int i=1;i<=m;i++)
		{
			int u,v;
			cin>>u>>v;
			add(u,v,0);
		}
		bfs();
		if(k == 1 && flag )
		{
			cout<<"No"<<endl;
			continue;
		}
		cout<<"Yes"<<endl;
		for(int i=1;i<=m;i++)
		{	
			cout<<edgs[i].w<<" ";
		}
		cout<<endl;
	}
}
```

---

## 作者：_O_v_O_ (赞：1)

首先，当 $k\ge 2$ 时，我们可以像 Prim 一样建一棵最短路树，把树内所有边赋值为 $1$，树外所有树设为 $k$，这样很明显能满足要求。

证明：  
首先把所有边权赋值为 $1$，很明显有些点有多个最短路。  
而一个树内根到所有点的简单路径只有一条，所以把树外的边赋值成 $k$ 后，最短路便唯一了。

其次就是 $k=1$ 时的情况了。

很明显只能把所有边都赋值为 $1$，所以按照 [P1144](https://www.luogu.com.cn/problem/P1144) 计数即可。

代码按照思路模拟很简单，不放了。

---

## 作者：aCssen (赞：1)

### Solution

提供一种不需要脑子的做法。

首先，将所有边的边权视为 $1$，在图上做一遍 bfs，其中能更新最短路的边将其赋为 $1$，对于其余的边，为了不让其更新最短路，边权越大越好，所以赋为 $k$。

这种构造显然一定是最优的，因为不存在使最短路更小的方式。

接下来，我们在这张赋好权的图中再做一遍 dijkstra，进行最短路计数，如果存在一个点 $i$，使 $1 \sim i$ 的最短路数量不为 $1$，则无解。

最短路计数当然要取模，模数随便选就行。

如果你用链式前向星存图，那么从 $1 \sim m$ 输出就是按边的顺序输出。

做完了。
### Code
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
typedef long long ll;
const int maxn=3e5+5;
const int MOD=217838923;
int head[maxn],edge[maxn],ver[maxn],nxt[maxn],tot,n,m,k;
priority_queue<pair<int,int> >Q;
ll dis[maxn],f[maxn];
bool vis[maxn];
queue<int>q;
void add_edge(int u,int v){
	ver[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}
void bfs(int s){
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i];
			if(!vis[y]){
				vis[y]=edge[i]=true;
				q.push(y);
			}
		}
	}
}
void dijkstra(int s){
	dis[s]=0;
	f[s]=1;
	Q.push(make_pair(0,s));
	while(!Q.empty()){
		int x=Q.top().second;
		Q.pop();
		if(vis[x]) continue;
		vis[x]=true;
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i],z=edge[i];
			if(dis[x]+z<dis[y]){
				dis[y]=dis[x]+z;
				f[y]=f[x];
				Q.push(make_pair(-dis[y],y));
			}
			else if(dis[x]+z==dis[y])
				f[y]=(f[y]+f[x])%MOD;
		}
	}
}
void solve(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++) head[i]=vis[i]=f[i]=0;
	for(int i=1;i<=m;i++) edge[i]=0;
	tot=0;
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add_edge(u,v);
	}
	bfs(1);
	for(int i=1;i<=n;i++){
		vis[i]=0;
		dis[i]=1e18;
	}
	for(int i=1;i<=m;i++)
		if(!edge[i]) edge[i]=k;
	dijkstra(1);
	for(int i=1;i<=n;i++){
		if(f[i]!=1){
			printf("No\n");
			return;
		} 
	}
	printf("Yes\n");
	for(int i=1;i<=m;i++)
		printf("%d ",edge[i]);
	printf("\n");
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--) solve();
	return 0;
}
```

---

## 作者：AKPC (赞：0)

先给原图所有边权赋值 $1$，dijkstra 找最短路的同时记录最短路的个数。

```cpp
while (!que.empty()){
	que.pop();
	if (tmp[x]) continue;
	tmp[x]=1;
	for (auto y:e[x]){
		if (f[y.fr]>v+y.sc){
			cnt[y.fr]=1;//重新设定最短路出现次数
			f[y.fr]=v+y.sc;//更新最短路的答案
			tree[++tip]=mpr(x,y.fr);//统计最短路遍历到的边，注意这只是遍历到的第一条最短路的边
			que.push(mpr(f[y.fr],y.fr));//把新节点放进队列
		}
		else if (f[y.fr]==v+y.sc){
			cnt[y.fr]++;//增加最短路径个数
		}
	}
}
```


如果 $k\geq2$，答案显然是 `Yes`，把**仅一条**最短路上的边赋权 $1$，其他的设成 $k$。

反之，这个图只能是边权都是 $1$ 的原图，需要判断 $1$ 到每个节点的最短路个数，如果有一个节点有 $\geq2$ 的最短路径个数，输出 `No`，反之就是 `Yes` 并输出 $m$ 个 $1$。

---

## 作者：Sternenlicht (赞：0)

思路：

把 $1$ 号节点作为出发点，BFS 遍历有向图。

记 $dis_i$ 表示从 $1$ 到 $i$ 的最短路径的距离，$vis_i$ 表示点 $i$ 是否被访问过。

对于点 $u$ 和它所能到达的点 $v$，分 $v$ 是否被访问过进行讨论。

* $v$ 没被访问过。那么现在访问到 $v$ 的路径即为最短路径。把从 $u$ 到 $v$ 的边的权值赋为 $1$，更新 $dis_v$ 为 $dis_u + 1$，标记 $vis_v$，把点 $v$ 加入到队列当中。

* $v$ 已被访问过。设第一次通到点 $v$ 的点为 $fir$。此时如果 $dis_v = dis_u + 1$，说明 $dis_u = dis_{fir}$。现在我们就不能把这条边的权值再赋值为 $1$ 了，因为这样会使得有两条最短路径，与题面要求矛盾，所以赋值为 $2$ 即可。但如果 $dis_v \ne dis_u + 1$，说明 $dis_u \ne dis_{fir}$，即 $dis_u < dis_{fir}$ 或者 $dis_u > dis_{fir}$，此时我们就可以把这条边的权值赋值为 $1$。

需要注意的是，当 $k = 1$ 时，有且仅有一种方案，即所有边权均为 $1$。此时若我们把赋值过边权为 $2$，说明无解。这种情况，我们在赋值边权为 $2$ 的时候记录一下，BFS 结束后特判即可。

```cpp
#include <bits/stdc++.h>
#define il inline
namespace Fast_IO {
	template <typename T> il void read(T &x) {
		x = 0; int f = 0; char ch = getchar();
		while (!isdigit(ch))f |= (ch == '-'), ch = getchar();
		while (isdigit(ch))x = x * 10 + (ch - 48), ch = getchar();
		x = f ? -x : x;
	}
	template <typename T, typename ...Args>
	il void read(T &x, Args& ...args) {read(x), read(args...);}
	template <typename T> il void write(T x, char c = '\n') {
		if (x) {
			if (x < 0)x = -x, putchar('-');
			char a[30]; short l;
			for (l = 0; x; x /= 10)a[l ++] = x % 10 ^ 48;
			for (l --; l >= 0; l --)putchar(a[l]);
		} else putchar('0');
		putchar(c);
	}
} using namespace Fast_IO;
using namespace std;

const int Maxn = 1000005;
struct Edge {int to, nxt, val;} edge[Maxn];
int n, m, k, flag, head[Maxn], tot, dis[Maxn], vis[Maxn];
il void init() {
	flag = tot = 0;
	for (int i = 1; i <= n; i ++)
		head[i] = vis[i] = 0, dis[i] = -1;
}
il void add(int u, int v) {edge[++tot] = {v, head[u], 0}; head[u] = tot;}
il void bfs(int st) {
	queue<int> que;
	que.push(st);
	dis[st] = 0;
	vis[st] = 1;
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		for (int i = head[u]; i; i = edge[i].nxt) {
			int v = edge[i].to;
			if (!vis[v]) {
				edge[i].val = 1;
				dis[v] = dis[u] + 1;
				vis[v] = 1;
				que.push(v);
			} else {
				if (dis[v] == dis[u] + 1) {
					edge[i].val = 2;
					flag = 1;
				} else edge[i].val = 1;
			}
		}
	}
}
signed main() {
	int T; read(T);
	while (T --) {
		read(n, m, k), init();
		for (int i = 1, u, v; i <= m; i ++) read(u, v), add(u, v);
		bfs(1);
		if (flag && k == 1) {puts("No"); continue;}
		puts("Yes");
		for (int i = 1; i <= m; i ++) write(edge[i].val, ' ');
		putchar('\n');
	}
	return 0;
}
```

注意：初始化不能用 ``memset``，否则 Subtask1 会 TLE？

---


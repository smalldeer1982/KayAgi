# [NOIP 2001 提高组] Car 的旅行路线

## 题目描述

又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  
她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。


![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)

**注意**：图中并没有标出所有的铁路与航线。


那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。


找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$，$1\le S \le 100$，$1\le A,B \le S$。

**【题目来源】**

NOIP 2001 提高组第四题

## 样例 #1

### 输入

```
1
3 10 1 3
1 1 1 3 3 1 30
2 5 7 4 5 2 1
8 6 8 8 11 6 3```

### 输出

```
47.5```

# 题解

## 作者：_jimmywang_ (赞：58)

### ~~口胡五分钟，代码两小时！~~

这个题啊，真是好写，也不好写。

好写呢，在于建个图，再跑一遍$Floyd$，比较最小值，就没了

不好写呢，就在于：

1.每个矩形只给了3个点.....

2.代码长（可能不是），相近的变量多（这是我）等等

来一步一步分析吧。。。

### $0.$题意:

~~（略）~~

### $1.$建图

#### $(1).$找到矩形的另外$1$个点

这个东西咋找呢？用亿点初中几何知识知道矩形是平行四边形，而平行四边形是对角线互相平分的。

如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ohht6xr0.png)

其中，点$A,B,C$为输入的点，$D$是所求的点，对角线交点为$P$

这个例子中，$BC$是一条对角线，$AD$是另一条。根据中点公式，可以得到

 $$\begin{cases}x_P=\dfrac{x_B+x_C}{2}\\x_P=\dfrac{x_A+x_D}{2}\end{cases}$$
$$\begin{cases}y_P=\dfrac{y_B+y_C}{2}\\y_P=\dfrac{y_A+y_D}{2}\end{cases}$$

所以可得
$$\begin{cases}x_D=x_B+x_C-x_A\\y_D=y_B+y_C-y_A\end{cases}$$

于是， 我们再用勾股定理判断一下哪两个点构成对角线，然后就能求出这个点啦！

#### $(2).$建图
这里我们发现题目给了两种路线，一种是城市之间的航空路线，一种是城市内部的公路。

所以建图的主要问题就在于判断两个点是否在同一城市内。

这个问题，要靠你标点的方式确定，此处就举本人的例子来说明。

我的想法是第$1$个城市标号$1,2,3,4$,第$2$个城市标号$5,6,7,8$,以此类推。

那么这些点的标号与对应的城市号有什么关系呢？

经过研究发现，若点的编号为$i$,则它对应的城市编号即为$(i-1)/4$（下取整）

于是这样就行了。

### $2.$最短路

$emmm$，一看数据范围，$s \leq 100$

所以最多只有$400$个点，$O(n^3)$都能过。

那么$O(n^3)$的最短路是啥？$Floyd$啊~

跑一遍$Floyd$，然后求一下$A$的每个机场到$B$的每个机场的最小值就过了~


完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
const ll inf=0x7f7f7f7f;
ll s,A,B,TTT;
double ans=inf,t,dis[410][410];
double x[410],y[410],T[110];
double diss(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
double ds(double x1,double y1,double x2,double y2){return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);}
int main() {
    scanf("%lld",&TTT);
    while(TTT--){
        memset(dis,0,sizeof(dis)),ans=inf;
        scanf("%lld%lf%lld%lld",&s,&t,&A,&B);
        f(i,1,s){
            scanf("%lf%lf%lf%lf%lf%lf%lf",&x[(i-1)*4+1],&y[(i-1)*4+1],&x[(i-1)*4+2],&y[(i-1)*4+2],&x[(i-1)*4+3],&y[(i-1)*4+3],&T[i]);
            double dab=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+2],y[(i-1)*4+2]);
            double dac=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+3],y[(i-1)*4+3]);
            double dbc=ds(x[(i-1)*4+2],y[(i-1)*4+2],x[(i-1)*4+3],y[(i-1)*4+3]);
            if(dab+dac==dbc)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+3]-x[(i-1)*4+1],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+3]-y[(i-1)*4+1];else
            if(dab+dbc==dac)x[i*4]=x[(i-1)*4+1]+x[(i-1)*4+3]-x[(i-1)*4+2],y[i*4]=y[(i-1)*4+1]+y[(i-1)*4+3]-y[(i-1)*4+2];else
            if(dbc+dac==dab)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+1]-x[(i-1)*4+3],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+1]-y[(i-1)*4+3];
        }
        f(i,1,s*4)f(j,1,s*4)if(i!=j){
                if((i-1)/4!=(j-1)/4)dis[i][j]=t*diss(x[i],y[i],x[j],y[j]);
                else dis[i][j]=T[(i-1)/4+1]*diss(x[i],y[i],x[j],y[j]);
            }
        f(k,1,s*4)f(i,1,s*4)f(j,1,s*4)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
        f(i,1,4)f(j,1,4)ans=min(ans,dis[(A-1)*4+i][(B-1)*4+j]);
        printf("%.1lf\n",ans);
    }
	return 0;
}

```



---

## 作者：ShineEternal (赞：18)

这道题代码可真的不简单。。

## 题目链接：
https://www.luogu.org/problem/P1027

## 分析：

**注：这里面的点指机场而非城市**

这道题乍一看题目描述不难，其实就是一个最短路问题，不过就是起点可能有多个，终点也有多个，所以我们跑个Floyd就行。

- 但因为我怕$O(n^3)$跑不起，所以换成了$n$遍$dijkstra$(这里n☞点数)

所以时间复杂度为：$O(n^2log_n)$

- (dij用了堆优化

### 然后我们来到样例，发现还有毒瘤的预处理。

样例无良的给了矩形的三个点，说明第四个点可以根据前三个求出。

- 于是我们考虑到运用矩形对角线的一些性质。

- 首先找出距离最远的两个点（三个点中）

- 然后连线取中点（当然编程中不用连线那一步操作）

- 再将另外的第3个点（不在连线的两端）向中点连线，延长即可

```cpp
void find(double a,double b,double c,double d,double e,double f)//读入三个点的坐标，跑完函数就把第四个点的值赋完了
{
	cnt++;
	dis[1].num=sqrt(Sqr(a-c)+Sqr(b-d)); 
	dis[1].id=1;
	dis[2].num=sqrt(Sqr(e-c)+Sqr(f-d)); 
	dis[2].id=2;
	dis[3].num=sqrt(Sqr(a-e)+Sqr(b-f));
	dis[3].id=3;
	sort(dis+1,dis+4,cmp);
	if(dis[1].id==1)
	{
		double x=min(a,c)+Abs(a-c)/2;
		double y=min(b,d)+Abs(b-d)/2;
		double xn=x+x-e;
		double yn=y+y-f;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
	if(dis[1].id==2)
	{
		double x=min(c,e)+Abs(e-c)/2;
		double y=min(f,d)+Abs(f-d)/2;
		double xn=x+x-a;
		double yn=y+y-b;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
	if(dis[1].id==3)
	{
		double x=min(a,e)+Abs(a-e)/2;
		double y=min(b,f)+Abs(b-f)/2;
		double xn=x+x-c;
		double yn=y+y-d;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
}
```

这样，就处理完了，最后，我们发现其实任意两点都有连接（要不航线要不铁路），所以处理出距离，在判断是否在一个城市，就可以找到每条路的价值。

- 跑dij即可


- 别忘了给点所在的城市打标记，这样最后方便找A和B

**这里引申出了一个惨痛的教训：结构体的存储方式要想好**

刚开始我是以一个城市为一个结构体，然后就特别难写，最后只好重构代码

## $code:$

```cpp
#include<cstdio>
#include<cmath>
#include<map>
#include<cstring>
#include<queue> 
#include<algorithm>
using namespace std;
#define pa pair<double,int>
int vis[4005];
priority_queue<pa,vector<pa>,greater<pa> > q;
struct point
{
	double x,y,T;
	int id;
}p[4005];
struct D
{
	double id;
	double num;
}dis[4];
double Sqr(int x)
{
	return x*x;
}
double cmp(const D &a,const D &b)
{
	return a.num>b.num;
}
double Abs(double x)
{
	if(x<0)return -x;
	return x;
}
int cnt=0;
void find(double a,double b,double c,double d,double e,double f)
{
	cnt++;
	dis[1].num=sqrt(Sqr(a-c)+Sqr(b-d)); 
	dis[1].id=1;
	dis[2].num=sqrt(Sqr(e-c)+Sqr(f-d)); 
	dis[2].id=2;
	dis[3].num=sqrt(Sqr(a-e)+Sqr(b-f));
	dis[3].id=3;
	sort(dis+1,dis+4,cmp);
	if(dis[1].id==1)
	{
		double x=min(a,c)+Abs(a-c)/2;
		double y=min(b,d)+Abs(b-d)/2;
		double xn=x+x-e;
		double yn=y+y-f;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
	if(dis[1].id==2)
	{
		double x=min(c,e)+Abs(e-c)/2;
		double y=min(f,d)+Abs(f-d)/2;
		double xn=x+x-a;
		double yn=y+y-b;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
	if(dis[1].id==3)
	{
		double x=min(a,e)+Abs(a-e)/2;
		double y=min(b,f)+Abs(b-f)/2;
		double xn=x+x-c;
		double yn=y+y-d;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
}
double d[405][405],dist[405][405];
void dijkstra(int s)
{
	memset(vis,0,sizeof(vis));
	d[s][s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int x=q.top().second;
        q.pop();
        if(vis[x]==1)
        continue;
        vis[x]=1;
        for(int i=1;i<=cnt;i++)
        {
            if(d[s][x]+dist[x][i]<d[s][i])
            {
                d[s][i]=d[s][x]+dist[x][i];
                q.push(make_pair(d[s][i],i));
            }
        }
    }
}
int main()
{
	double t;
	int N,A,B,s;
	scanf("%d",&N);
	while(N--)
	{
		cnt=0;
		scanf("%d%lf%d%d",&s,&t,&A,&B);
		int city=0;
		for(int i=1;i<=s;i++)
		{
			city++;
			for(int j=1;j<=3;j++)
			{
				cnt++;
				scanf("%lf%lf",&p[cnt].x,&p[cnt].y);
				p[cnt].id=city;
			}
			scanf("%lf",&p[cnt].T);
			p[cnt-2].T=p[cnt].T;
			p[cnt-1].T=p[cnt].T;
			p[cnt+1].T=p[cnt].T;
			//printf("%lf %lf\n",p[cnt-j+1].x,p[cnt-j+1].y);
			find(p[cnt-2].x,p[cnt-2].y,p[cnt-1].x,p[cnt-1].y,p[cnt].x,p[cnt].y);
			p[cnt].id=city;
			//printf("i=%lf %lf\n",p[cnt].x,p[cnt].y);
		}
		for(int i=1;i<=cnt;i++)
		{
			for(int j=1;j<=cnt;j++)
			{
				double tmp=sqrt(Sqr(p[i].x-p[j].x)+Sqr(p[i].y-p[j].y));
				if(p[i].id==p[j].id)
				{
					dist[i][j]=tmp*p[i].T;
				}
				else
				{
					dist[i][j]=tmp*t;
				}
			}
		}
		for(int i=1;i<=cnt;i++)
		{
			for(int j=1;j<=cnt;j++)
			{
				d[i][j]=2147483640;
			}
		}
		for(int i=1;i<=cnt;i++)
		{
			dijkstra(i);
		}
		double ans=2147483640;
		for(int i=1;i<=cnt;i++)
		{
			for(int j=1;j<=cnt;j++)
			{
				if(p[i].id==A&&p[j].id==B)
				{
					if(d[i][j]<ans)
					{
						ans=d[i][j];
					}
					//ans=min(ans,d[i][j]);
				}
			}
		}
		printf("%.1lf\n",ans);
	}		
	return 0;
}
```




---

## 作者：rediserver (赞：2)

## 思路



用Airport结构体存储机场的x,y坐标，用`airports_`数组存储所有机场。顺序为先存储第0个城市的4个机场，然后第1个城市的4个机场。。。最后一个城市的4个机场。所以`airports_[i]`机场所在的城市编号为`i / 4`。而`第i个城市的第j个机场`，在`airports_`中的编号则为`i * 4 +ｊ`。这两个换算定义成了宏。

输入时通过每个城市的前三个机场坐标计算最后一个机场坐标。

用dijkstra计算起点到终点的最短路径。注意：

* dijkstra算法只有一个源，而在这里起点城市的4个机场均可作为起点，故将这4个机场与源的距离设为0。

* 只要收录的机场所在城市为终点城市，则达到目的地。

* 整个程序没有存储具体的图，对于每次收录的机场来讲，任何其他未收录的机场均为邻接点，计算它们的直线距离，此时若它们在同一城市，则它们之间的费用为直线距离乘以该城市的铁路费，否则费用为直线距离乘以航线费。

## 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <math.h>
using namespace std;

#define N_AIRPORTS_PER_CITY 4 //每个城市的机场数
#define GET_CITY_INDEX(airport_idx) ((airport_idx) / N_AIRPORTS_PER_CITY) //得到一个机场所属的城市编号
#define GET_AIRPORT_INDEX(city_idx, i) ((city_idx) * N_AIRPORTS_PER_CITY + (i)) //得到一个城市第i个机场的编号
#define NO_VALUE -1

class CarRoute {
public:
    CarRoute() {}
    ~CarRoute() {}

    void solve(); //主函数

private:
    struct Airport {
        //机场的坐标
        int x; 
        int y;
    };

    int square(int x) { return x * x; }

    /* 返回两个机场间的直线距离 */
    float getAirportDist(Airport& a, Airport& b);

    /* 用dijkstra求最短路 */
    float dijkstra(int src_city, int des_city);

    int nAirports_; //总机场数量
    Airport *airports_; //机场数组，依次存储第0个，第1个。。。城市的4个机场

    int cost_air_; //航线单位里程的价格
    int *cost_train_; //cost_train_[i]为第i个城市中高速铁路的单位里程价格
};

void CarRoute::solve() {
    int nCities, src_city, des_city; //城市数，起点，终点
    scanf("%d %d %d %d", &nCities, &cost_air_, &src_city, &des_city);
    src_city--; //改为从0开始编号
    des_city--;
    nAirports_ = nCities * N_AIRPORTS_PER_CITY;
    airports_ = new Airport[nAirports_];
    cost_train_ = new int[nCities];
    for (int i = 0; i < nCities; i++) {
        int ax, ay, bx, by, cx, cy, dx, dy;
        //输入每个城市前三个机场
        scanf("%d %d %d %d %d %d %d", &ax, &ay, &bx, &by, &cx, &cy, cost_train_ + i);
        airports_[GET_AIRPORT_INDEX(i, 0)].x = ax;
        airports_[GET_AIRPORT_INDEX(i, 0)].y = ay;
        airports_[GET_AIRPORT_INDEX(i, 1)].x = bx;
        airports_[GET_AIRPORT_INDEX(i, 1)].y = by;
        airports_[GET_AIRPORT_INDEX(i, 2)].x = cx;
        airports_[GET_AIRPORT_INDEX(i, 2)].y = cy;
        int abSquare = square(ax - bx) + square(ay - by);
        int acSquare = square(ax - cx) + square(ay - cy);
        int bcSquare = square(bx - cx) + square(by - cy);
        if (abSquare == acSquare + bcSquare) { //c为直角顶点
            dx = ax + bx - cx;
            dy = ay + by - cy;
        }
        else if (acSquare == abSquare + bcSquare) { //b为直角顶点
            dx = ax + cx - bx;
            dy = ay + cy - by;
        }
        else { //a为直角顶点
            dx = bx + cx - ax;
            dy = by + cy - ay;
        }
        //最后一个机场的坐标已确定
        airports_[GET_AIRPORT_INDEX(i, 3)].x = dx;
        airports_[GET_AIRPORT_INDEX(i, 3)].y = dy;
    }
    float minCost = dijkstra(src_city, des_city); //计算最短路
    printf("%.1f\n", minCost);
    free(airports_);
    free(cost_train_);
}

float CarRoute::getAirportDist(Airport & a, Airport & b) {
    return sqrt(square(a.x - b.x) + square(a.y - b.y));
}

float CarRoute::dijkstra(int src_city, int des_city) {
    float *cost = new float[nAirports_]; //cost[i]表示从起点到第i个机场的当前最小费用
    bool *collected = new bool[nAirports_];
    fill(cost, cost + nAirports_, NO_VALUE);
    fill(collected, collected + nAirports_, false);
    for (int i = 0; i < 4; i++) //将起点城市的4个机场的cost设为0
        cost[GET_AIRPORT_INDEX(src_city, i)] = 0;
    while (true) {
        int minV = NO_VALUE;
        float minCost = NO_VALUE;
        //在未收录机场中找到cost最小的
        for (int i = 0; i < nAirports_; i++)
            if (!collected[i] && cost[i] != NO_VALUE && (cost[i] < minCost || minCost == NO_VALUE)) {
                minV = i;
                minCost = cost[i];
            }
        int minCity = GET_CITY_INDEX(minV); //minCity为最小cost机场minV所在城市
        if (minCity == des_city) { //若与终点在同一城市
            free(cost);
            free(collected);
            return minCost;
        }
        if (minV == NO_VALUE) break;
        collected[minV] = true; //收录minV
        for (int i = 0; i < nAirports_; i++) 
            if (!collected[i]) {
                float dist = getAirportDist(airports_[minV], airports_[i]); //dist为minV到i的直线距离
                //若minV与i在同一城市中，则从minV到i的费用为dist乘以该城市的铁路费用，否则为dist乘以航线费用
                float cost_tmp = GET_CITY_INDEX(i) == minCity ? dist * cost_train_[minCity] : dist * cost_air_;
                if (minCost + cost_tmp < cost[i] || cost[i] == NO_VALUE) { //若通过minV使cost[i]变小
                    cost[i] = minCost + cost_tmp; //更新
                }
            }
    } //while
    free(cost);
    free(collected);
    return NO_VALUE;
}


int main() {
    CarRoute carRoute;
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        carRoute.solve();
    }
    return 0;
}
```


---

## 作者：licone (赞：2)

SPFA+数论~

应该是最简短清晰的代码了，判断第四个点用了求斜边对应点的方法，类似向量~








```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<queue>
using namespace std;
int n,s,t,A,B,fi[401],w[340001],ne[340001],cnt,x[5][401],y[5][401],val;
double v[340001],dis[401],minn;
bool b[401];
queue<int> q;
void add(int u,int vv,double val1)
{
    w[++cnt]=vv;v[cnt]=val1;ne[cnt]=fi[u];fi[u]=cnt;
}
double cal(double x1,double y1,double x2,double y2)
{
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
double cal2(int x1,int y1,int x2,int y2)
{
    return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
}
void getn(int u)
{
    double k[4]={0,cal2(x[1][u],y[1][u],x[2][u],y[2][u]),
                   cal2(x[2][u],y[2][u],x[3][u],y[3][u]),
                   cal2(x[3][u],y[3][u],x[1][u],y[1][u])},tot=k[1]+k[2]+k[3];
    int fre,num[3]={0};
    for(int i=1;i<=3;i++)
      if(k[i]*2==tot) fre=(i==1 ? 3:i-1);
      else num[++num[0]]=(i==1 ? 3:i-1);
    x[4][u]=x[num[1]][u]+x[num[2]][u]-x[fre][u];
    y[4][u]=y[num[1]][u]+y[num[2]][u]-y[fre][u];
}
int main()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d%d%d%d",&s,&t,&A,&B);minn=999999999;
        memset(fi,0,sizeof(fi));cnt=0;
        for(int k=1;k<=s;k++)
        {
            scanf("%d%d%d%d%d%d%d",&x[1][k],&y[1][k],&x[2][k],&y[2][k],&x[3][k],&y[3][k],&val);
            getn(k);
            for(int i=1;i<=3;i++)
              for(int j=i+1;j<=4;j++)
              {
                  double kkz=cal(x[i][k],y[i][k],x[j][k],y[j][k])*(double)val;
                  add(4*k+i-4,4*k+j-4,kkz);add(4*k+j-4,4*k+i-4,kkz);
              }
        }
        for(int k1=1;k1<s;k1++)
          for(int k2=k1+1;k2<=s;k2++)
            for(int i=1;i<=4;i++)
                for(int j=1;j<=4;j++)
                {
                    double kkz=cal(x[i][k1],y[i][k1],x[j][k2],y[j][k2])*(double)t;
                    add(4*k1-4+i,4*k2-4+j,kkz);add(4*k2-4+j,4*k1-4+i,kkz);
              }
        for(int i=1;i<=4;i++)
        {
            memset(dis,127,sizeof(dis));
            q.push(A*4-4+i);b[A*4-4+i]=1;dis[A*4-4+i]=0;
            while(!q.empty())
            {
                int k=q.front();q.pop();b[k]=0;
                for(int j=fi[k];j;j=ne[j])
                  if(dis[w[j]]>dis[k]+v[j])
                  {
                    dis[w[j]]=dis[k]+v[j];
                    if(!b[w[j]])
                    {
                        b[w[j]]=1;q.push(w[j]);
                    }
                  }
            }
            for(int j=1;j<=4;j++)
              if(dis[B*4-4+j]<minn) minn=dis[B*4-4+j];
        }
        printf("%.1lf\n",minn);
    }
    return 0;
}
```

---

## 作者：LiJunze0501 (赞：1)

# 我的算法
因为 $s \leqslant 100$，所以直接采用 Floyd。
# 题目分析
这道题重难点在哪里呢？就是通过矩阵三个点的坐标求出第四个点的坐标。  
这里查了很久，先求出直角点（可以通过勾股求），设 1 点为直角点，那么第四个点的坐标就可以这么求：
$x4=x2+x3-x1$，$y4=y2+y3-y1$。  
下面具体说一下怎么求直角点：  
先定义几个变量：  
- $d12$：1 号点到 2 号点的距离；  
- $d23$：2 号点到 3 号点的距离；  
- $d13$：1 号点到 3 号点的距离；

然后给出判断：
$
\begin{cases}
\begin{cases}
x4=x2+x3-x1\\y4=y2+y3-y1
\end{cases} & d12+d13=d23，\text{即 1 号点是直角点}\\
\begin{cases}
x4=x1+x3-x2\\y4=y1+y3-y2
\end{cases} & d12+d23=d13，\text{即 2 号点是直角点}\\
\begin{cases}
x4=x1+x2-x3\\y4=y1+y2-y3
\end{cases} & d23+d13=d12，\text{即 3 号点是直角点}\\
\end{cases}
$
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,t,a,b;
double Tp[101];
struct ap{
	double x,y;
}air[401];
int pf(int x){//平方
	return x*x;
}
double dis(int xx,int yy){//求距离
	return sqrt(pf(air[xx].x-air[yy].x)+pf(air[xx].y-air[yy].y));
}
void getair4(int id){//求第四个机场的坐标
	double d12=pf(air[4*(id-1)+1].x-air[4*(id-1)+2].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+2].y);
	double d23=pf(air[4*(id-1)+2].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+2].y-air[4*(id-1)+3].y);
	double d13=pf(air[4*(id-1)+1].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+3].y);
	if(d12+d13==d23){//1是直角点
		air[4*id].x=air[4*(id-1)+2].x+air[4*(id-1)+3].x-air[4*(id-1)+1].x;
		air[4*id].y=air[4*(id-1)+2].y+air[4*(id-1)+3].y-air[4*(id-1)+1].y;	
	}
	if(d12+d23==d13){//2是直角点
		air[4*id].x=air[4*(id-1)+1].x+air[4*(id-1)+3].x-air[4*(id-1)+2].x;
		air[4*id].y=air[4*(id-1)+1].y+air[4*(id-1)+3].y-air[4*(id-1)+2].y;	
	}
	if(d23+d13==d12){//3是直角点
		air[4*id].x=air[4*(id-1)+1].x+air[4*(id-1)+2].x-air[4*(id-1)+3].x;
		air[4*id].y=air[4*(id-1)+1].y+air[4*(id-1)+2].y-air[4*(id-1)+3].y;	
	}
}
double cost[401][401];
int main(){
	cin>>n;
	while(n--){
		cin>>s>>t>>a>>b;
		//第i个市的第j机场，4*(i-1)+j
		for(int i=1;i<=4*s;i++)
			for(int j=1;j<=4*s;j++)
				if(i!=j) cost[i][j]=INT_MAX;
		//花费初始化为最大值 
		for(int i=1;i<=s;i++){
			cin>>air[4*(i-1)+1].x>>air[4*(i-1)+1].y;
			cin>>air[4*(i-1)+2].x>>air[4*(i-1)+2].y;
			cin>>air[4*(i-1)+3].x>>air[4*(i-1)+3].y;
			cin>>Tp[i-1];
			getair4(i);
		}
		//把机场坐标求出后，就可以初始化了
		for(int i=1;i<=4*s;i++)
			for(int j=1;j<=4*s;j++)
				if(i!=j) cost[i][j]=cost[j][i]=((i-1)/4==(j-1)/4)?dis(i,j)*Tp[(i-1)/4]:dis(i,j)*t;//条件成立时，是同一座城市的机场，不成立时则不是同一座城市中的机场 
		for(int k=1;k<=4*s;k++)
			for(int i=1;i<=4*s;i++)
				for(int j=1;j<=4*s;j++)
					if(i!=j&&j!=k&&i!=k) cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);//从i机场经过k机场到达j机场更省钱
		double ans=INT_MAX;
		for(int i=1;i<=4;i++)
			for(int j=1;j<=4;j++) ans=min(ans,cost[4*(a-1)+i][4*(b-1)+j]);//a城市的第i座机场到b城市的第j座机场中的最小价钱
		printf("%.1lf\n",ans);
	}
}
```

---


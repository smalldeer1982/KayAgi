# [GESP202406 八级] 空间跳跃

## 题目描述

小杨在二维空间中有 $n$ 个水平挡板，并且挡板之间彼此不重叠，其中第 $i$ 个挡板处于水平高度 $h_i$，左右端点分别位于 $l_i$ 与 $r_i$。

小杨可以在挡板上左右移动，当小杨移动到右端点时，如果再向右移动会竖直掉落，从而落到下方第一个挡板上，移动到左端点时同理。小杨在挡板上每移动 $1$ 个单位长度会耗费 $1$ 个单位时间，掉落时每掉落 $1$ 个单位高度也会耗费 $1$ 个单位时间。

小杨想知道，从第 $s$ 个挡板上的左端点出发到第 $t$ 个挡板需要耗费的最少时间是多少？

注意：可能无法从第 $s$ 个挡板到达到第 $t$ 个挡板。

## 说明/提示

### 样例解释

耗费时间最少的移动方案为，从第 $3$ 个挡板左端点移动到右端点，耗费 $3$ 个单位时间，然后向右移动掉落到第 $2$ 个挡板上，耗费 $100000-6=99994$ 个单位时间，之后再向右移动 $1$ 个单位长度，耗费 $1$ 个单位时间，最后向右移动掉落到第 $1$ 个挡板上，耗费 $3$ 个单位时间。共耗费 $100001$ 个单位时间。

### 数据范围

子任务编号|数据点占比|$n$|特殊条件
:-:|:-:|:-:|:-:
$1$|$20\%$|$\leq 1000$|$l_i=1$
$2$|$40\%$|$\leq 1000$|$l_i=i,r_i=i+1$
$3$|$40\%$|$\leq 1000$|

对于全部数据，保证有 $1\leq n\leq 1000$，$1\leq l_i\leq r_i\leq 10^5$，$1\leq h_i\leq 10^5$。


## 样例 #1

### 输入

```
3
3 1
5 6 3
3 5 6
1 4 100000```

### 输出

```
100001```

# 题解

## 作者：Solwek (赞：21)

一道很神奇的题目，感觉什么算法都行。

由于 $n\le 1000$ 并且联系题目，我们很难不想到 $dp$，设 $f_{i,0}$ 表示已经来到第 $i$ 层，并且在左端点的最少时间，$f_{i,1}$ 表示已经来到第 $i$ 层，并且在右端点的最少时间。

状态转移显然，我们只需要枚举 $i$ 从左端点落到的板子编号和右端点落到的板子编号进行转移，以左端点举例：（设落下去的板子编号为 $j$）。

$$f_{j,0}=\min(f_{j,0},f_{i,0}+l_i-l_j+h_i-h_j)$$

$$f_{j,1}=\min(f_{j,1},f_{i,0}+r_j-l_i+h_i-h_j)$$

转移条件为 $j$ 是第一个满足 $l_j\le l_i\le r_j$ 并且 $h_i\ge h_j$ 条件的板子编号。

初值为 $f_{s,0}=0,f_{s,1}=r_s-l_s$。

但由于题目并未保证 $h_i\ge h_{i+1}$，所以我们要先排序，再 $dp$，并且 $s,t$ 也要变成新序列的编号。

时间复杂度应该是 $O(n^2)$。


## code:
```
#include<bits/stdc++.h>
#define int long long
using namespace std;

struct node{
	int l,r,h,id;
}a[1010];
int dp[1010][2];
bool cmp(node x,node y){
	if(x.h==y.h)return x.l<y.l;
	return x.h>y.h;
}
signed main(){	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int n,os,ot;
	cin>>n>>os>>ot;
	for(int i=1;i<=n;i++)
		cin>>a[i].l>>a[i].r>>a[i].h,a[i].id=i,dp[i][0]=dp[i][1]=1e18;
	sort(a+1,a+n+1,cmp);
	int s,t;
	for(int i=1;i<=n;i++){
		if(a[i].id==os)s=i;
		if(a[i].id==ot)t=i;
	}
	dp[s][0]=0,dp[s][1]=a[s].r-a[s].l;
	int ans=1e18;
	for(int i=s;i<=t;i++){
		for(int j=i+1;j<=t;j++){
			if(a[i].l>=a[j].l&&a[i].l<=a[j].r&&a[i].h>a[j].h){
				int val=a[i].h-a[j].h;
				if(j==t)ans=min(ans,dp[i][0]+val);
				dp[j][0]=min(dp[j][0],dp[i][0]+a[i].l-a[j].l+val);
				dp[j][1]=min(dp[j][1],dp[i][0]+a[j].r-a[i].l+val);
				break;
			}
		}
		for(int j=i+1;j<=t;j++){
			if(a[i].r>=a[j].l&&a[i].r<=a[j].r&&a[i].h>a[j].h){
				int val=a[i].h-a[j].h;
				if(j==t)ans=min(ans,dp[i][1]+val);
				dp[j][0]=min(dp[j][0],dp[i][1]+a[i].r-a[j].l+val);
				dp[j][1]=min(dp[j][1],dp[i][1]+a[j].r-a[i].r+val);
				break;
			}
		}
	}
	if(ans==1e18)cout<<"-1\n";
	else cout<<ans<<'\n';
	return 0;
}  
```

---

## 作者：__Octhyccc__ (赞：12)

~~（口胡 $5$ 分钟，代码 $1$ 小时！）~~

考虑使用最短路，那么考虑如何建图。

对于第 $i$ 个挡板，它的左端点为 $2i-1$ 号点，右端点则为 $2i$ 号点。建边很简单，建一条从 $2i-1$ 到 $2i$，边权为 $r_i-l_i$ 的边，再反着装一次就解决了。

如果可以从一块挡板上掉到另外一块挡板上，就需要考虑加点，可以分两种情况讨论：

![](https://cdn.luogu.com.cn/upload/image_hosting/9y84bvei.png)

产生新点必须满足以下所有条件：

1. $l_j\le l_i\le r_j$ 或者 $l_j\le r_i\le r_j$。
2. $h_i>h_j$ 并且 $h_i-h_j$ 达到最小值。

为什么不也在新点也建双向边呢？因为即使你建了也没用（你不可能从新点掉落挡板吧），单向边足够了。

然后记录一下在第 $t$ 块挡板上产生的新点编号，用一个 vector 存着就可以。

之后跑一遍最短路，输出最小的值就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int __Ending__=-1e9-7;
const int INF=INT_MAX;
struct line{
	int l,r,h;
}L[1001];
int n,head[10001],cnt,s,t,use,h1=-1,h2=-1;
int idx=__Ending__,idy=__Ending__,dis[10001],vis[10001];
struct edge{
	int u,v,w,nxt;
}e[10001];
struct node{
	int w,now;
	const bool operator <(const node &x)const{
		return w>x.w;
	}
};
priority_queue<node>q;
vector<int>v;
void add(int u,int v,int w){
	cnt++;
	e[cnt].u=u,e[cnt].v=v;
	e[cnt].w=w,e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dijkstra(){
	for(int i=1;i<=use;i++)dis[i]=INF;
	dis[2*s-1]=0;
	q.push((node){0,2*s-1});
	while(!q.empty()){
		node x=q.top();
		q.pop();
		int u=x.now;
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(dis[v]>dis[u]+e[i].w){
				dis[v]=dis[u]+e[i].w;
				q.push((node){dis[v],v});
			}
		}
	}
}
int main(){
	scanf("%d",&n);
	scanf("%d%d",&s,&t);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&L[i].l,&L[i].r,&L[i].h);
	}
	for(int i=1;i<=n;i++){
		add(use+1,use+2,L[i].r-L[i].l);
		add(use+2,use+1,L[i].r-L[i].l);
		use+=2;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(L[j].h<L[i].h){
				if(L[i].l>=L[j].l && L[i].l<=L[j].r){
					if(h1<L[j].h)idx=j,h1=L[j].h;
				}
				if(L[i].r>=L[j].l && L[i].r<=L[j].r){
					if(h2<L[j].h)idy=j,h2=L[j].h;
				}
			}
		}
		if(idx!=__Ending__){
			use+=1;
			add(use,2*idx-1,L[i].l-L[idx].l);
			add(use,2*idx,L[idx].r-L[i].l);
			add(2*i-1,use,L[i].h-L[idx].h);
			if(idx==t)v.push_back(use);
		}
		if(idy!=__Ending__){
			use+=1;
			add(use,2*idy-1,L[i].r-L[idy].l);
			add(use,2*idy,L[idy].r-L[i].r);
			add(2*i,use,L[i].h-L[idy].h);
			if(idy==t)v.push_back(use);
		}
		idx=idy=__Ending__;
		h1=h2=-1;
	}
	dijkstra();
	int ans=INF;
	for(int i=0;i<v.size();i++){
		ans=min(ans,dis[v[i]]);
	}
	if(ans==INF)printf("%d",-1);
	else printf("%d",ans);
	return 0;
}
```

---

## 作者：Octopus_hsfzy (赞：7)

**DP** 出奇迹！  

首先，我们先复习一下能用**动态规划**解决的问题，需要满足的三个条件：**最优子结构**，**无后效性**和**子问题重叠。**

#### 最优子结构：
简单来说，最优子结构就是一个大问题可以分成**若干个子问题**，且**局部做到最优**整体就能最优。此外，最优子结构有时也可以用**贪心**来做。
#### 无后效性：
已经求最优解的子问题，**不会**再受到后续决策的影响。
#### 子问题重叠：
如果有大量的重叠子问题，我们可以将这些子问题的最优解存储下来，**避免重复求解**相同的子问题，从而提升运行效率。

好了，讲完动态规划的使用场景，让我们直奔主题吧：

既然确定了要使用动态规划，那就要先要明确两个点：**状态设定**和**状态转移方程**。

#### 状态设定：
因为我们下降到挡板有两个方式：到左端点或右端点。所以，我们分别设定： 1. $f_{1}[i]$ 为已经来到第 $i$ 层，且在左端点上的最小时间；2. $f_{2}[i]$ 为已经来到第 $i$ 层，且在右端点上的最小时间。
#### 状态转移方程：
左端点：转移条件是 $j$ 为第一个满足 $r[j]\ge l[i]\ge l[j]$ 且 $h[i]>h[j]$。

转移方程：
$$
f_{1}[j]=\min(f_{1}[j],f_{1}[i]+l[i]-l[j]+v)
$$
$$
f_{2}[j]=\min(f_{2}[j],f_{1}[i]+r[j]-l[i]+v)
$$
（以上的 $v$ 为 $(h[i]-h[j])$）

右端点：同理，转移条件是 $j$ 为第一个满足 $r[j]\ge r[i]\ge l[j]$ 且 $h[i]>h[j]$。

转移方程：
$$
f_{1}[j]=\min(f_{1}[j],f_{2}[i]+r[i]-l[j]+v)
$$
$$
f_{2}[j]=\min(f_{2}[j],f_{2}[i]+r[j]-r[i]+v)
$$
讲完主要思路，再讲一下细节：  
1. 初始化：$f_{1}[s]=0;f_{2}[s]=r[s]=l[s]$；
2. 题目未报证 $h[i]$ 的单调性，所以要排序。

好，上代码：
```cpp
#include<bits/stdc++.h>//本章鱼码风与大多数人不同，不喜勿喷
using namespace std;
long long zym=114514114514,f1[1005],f2[1005],n,s,t,x,y,v;
struct somebody{
	long long l,r,h,k;//结构体定义
};
somebody a[1005];
bool cmp(somebody x,somebody y){
	if(x.h!=y.h) return x.h>y.h;
	else return x.l<y.l;
}
int main(){	
cin>>n>>s>>t;
for(int i=1;i<=n;i++){
	scanf("%lld%lld%lld",&a[i].l,&a[i].r,&a[i].h);
	a[i].k=i;
	f1[i]=114514114514;//因为我们是求最大值，所以定义一个很大的数
	f2[i]=114514114514;
}
sort(a+1,a+n+1,cmp);//排序
for(int i=1;i<=n;i++){
	if(a[i].k==s) x=i;//找排序后的s和t
	if(a[i].k==t) y=i;
}
f1[x]=0;//DP操作前的初始化
f2[x]=a[x].r-a[x].l;
for(int i=x;i<=y;i++){//DP!!!!!(若看不懂请返回前面继续消化)
	for(int j=i+1;j<=y;j++){//左端点
		if(a[i].l>=a[j].l&&a[i].l<=a[j].r&&a[i].h>a[j].h){
			v=a[i].h-a[j].h;
			if(j==y) zym=min(zym,f1[i]+v);
			f1[j]=min(f1[j],f1[i]+a[i].l-a[j].l+v);
			f2[j]=min(f2[j],f1[i]+a[j].r-a[i].l+v);
			break;
		}
	}
	for(int j=i+1;j<=y;j++){//右端点
		if(a[i].r>=a[j].l&&a[i].r<=a[j].r&&a[i].h>a[j].h){
			v=a[i].h-a[j].h;
			if(j==y) zym=min(zym,f2[i]+v);
			f1[j]=min(f1[j],f2[i]+a[i].r-a[j].l+v);
			f2[j]=min(f2[j],f2[i]+a[j].r-a[i].r+v);
			break;
		}
	}
}
if(zym==114514114514) cout<<-1;//如果找不到到目标挡板的路，输出-1
else cout<<zym;//正常的输出
return 0;
}
```
时间复杂度：$O(n^{2})$

---

## 作者：CleverRaccoon (赞：6)

### 题目简述

- 在二维空间中有 $n$ 个水平挡板，并且挡板之间彼此不重叠，其中第 $i$ 个挡板处于水平高度 $h_i$，左右端点分别位于 $l_i$ 与 $r_i$。

- 在挡板上左右移动，移动到右端点时，如果再向右移动会竖直掉落，从而落到下方第一个挡板上，移动到左端点时同理。在挡板上每移动 $1$ 个单位长度会耗费 $1$ 个单位时间，掉落时每掉落 $1$ 个单位高度也会耗费 $1$ 个单位时间。

- 求从第 $s$ 个挡板上的左端点出发到第 $t$ 个挡板需要耗费的最少时间，或输出 `-1` 报告无解。

- $1\leq n\leq 1000$，$1\leq l_i\leq r_i\leq 10^5$，$1\leq h_i\leq 10^5$。

### 思路

- 考虑 DP。

- 首先排序使得 $h_i\ge h_i+1$。

- 设计状态 $f_{i,0}$ 表示高度为 $i$ 且位于左端点的最短时间；$f_{i,1}$ 表示高度为 $i$ 且位于右端点的最短时间。

- 易得初始条件为 $f_{s,0}=0,f_{s,1}=r_s-l_s$。

- 设从 $u$ 落到 $v$，$d=h_u-h_v$，则状态转移方程为（两个条件为并列关系，即满足了第一个条件转移后，若还满足第二个条件，仍可以通过第二个条件继续转移）：

$$
\text{若 } l_v\leq l_u\leq r_v \text{ 且 } h_u>h_v，\begin{cases}
f_{v,0}=min(f_{v,0},f_{u,0}+l_u-l_v+d)\\
f_{v,1}=min(f_{v,1},f_{u,0}+r_v-l_u+d)\\
\end{cases}\\
\text{若 } l_v\leq r_u\leq r_v \text{ 且 } h_u>h_v，\begin{cases}
f_{v,0}=min(f_{v,0},f_{u,1}+r_u-l_v+d)\\
f_{v,1}=min(f_{v,1},f_{u,1}+r_v-r_u+d)\\
\end{cases}
$$

- 本题也可以使用最短路，将每个挡板的左端点和右端点连边，每个端点再分别和其他端点之间连边，跑一遍最短路即可。

### 代码

第一种思路的代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1005;
const long long INF=2e18;
int n,s,t;
long long f[N][2],ans=INF;
struct node{
	int l,r,h;
	int id;
	bool operator==(int x){
		return x==id;
	}
}a[N];

int main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++){
		cin>>a[i].l>>a[i].r>>a[i].h;
		a[i].id=i;
	}
	
	sort(a+1,a+n+1,[](const node &a,const node &b){
		if(a.h==b.h)return a.l<b.l;	// or return a.r<b.r;
		return a.h>b.h;
	});
	
	s=find(a+1,a+n+1,s)-a;
	t=find(a+1,a+n+1,t)-a;
	
	memset(f,0x3f,sizeof f);
	f[s][0]=0,f[s][1]=a[s].r-a[s].l;
	for(int u=s;u<=t;u++){
		auto check=[&](int x,int y,int h1,int h2){
			return a[x].l<=y&&y<=a[x].r&&h1>h2;
		};
		for(int v=u+1;v<=t;v++){
			if(check(v,a[u].l,a[u].h,a[v].h)){
				f[v][0]=min(f[v][0],f[u][0]+a[u].l-a[v].l+a[u].h-a[v].h);
				f[v][1]=min(f[v][1],f[u][0]+a[v].r-a[u].l+a[u].h-a[v].h);
				if(v==t)ans=min(ans,f[u][0]+a[u].h-a[v].h);
				break;
			}
		}
		for(int v=u+1;v<=t;v++){
			if(check(v,a[u].r,a[u].h,a[v].h)){
				f[v][0]=min(f[v][0],f[u][1]+a[u].r-a[v].l+a[u].h-a[v].h);
				f[v][1]=min(f[v][1],f[u][1]+a[v].r-a[u].r+a[u].h-a[v].h);
				if(v==t)ans=min(ans,f[u][1]+a[u].h-a[v].h);
				break;
			}
		}
	}
	cout<<(ans==INF?-1:ans)<<'\n';
	return !~(0^0);
}
```

最短路的思路的代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1005;
int n,s,t,l[N],r[N],h[N];
int drop[N][2];
bool vis[N<<1];
struct node{
	int id;
	long long tot,ht;
	bool operator<(const node &o)const{
		if(tot+ht==o.tot+o.ht){
			return tot>o.tot;
		}
		return tot+ht>o.tot+o.ht;
	}
};
vector<node> e[N<<1];	// 一个挡板两个端点，故乘二

void init(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(h[i]<=h[j])continue;
			if(l[j]<=l[i]&&l[i]<=r[j]){
				if(h[j]>h[drop[i][0]]){
					drop[i][0]=j;
				}
			}
			if(l[j]<=r[i]&&r[i]<=r[j]){
				if(h[j]>h[drop[i][1]]){
					drop[i][1]=j;
				}
			}
		}
	}
}

#define le(x) ((x)<<1)
#define ri(x) ((x)<<1|1)

void link(){
	for(int i=1;i<=n;i++){
		e[le(i)].push_back({ri(i),0,r[i]-l[i]});
		e[ri(i)].push_back({le(i),0,r[i]-l[i]});
		if(drop[i][0]){
			int ht=h[i]-h[drop[i][0]];
			e[le(i)].push_back({le(drop[i][0]),ht,l[i]-l[drop[i][0]]});
			e[le(i)].push_back({ri(drop[i][0]),ht,r[drop[i][0]]-l[i]});
		}
		if(drop[i][1]){
			int ht=h[i]-h[drop[i][1]];
			e[ri(i)].push_back({le(drop[i][1]),ht,r[i]-l[drop[i][1]]});
			e[ri(i)].push_back({ri(drop[i][1]),ht,r[drop[i][1]]-r[i]});
		}
	}
}

long long bfs(){
	priority_queue<node> q;
	q.push({le(s),0,0});
	long long ans=2e18;
	while(!q.empty()){
		int u=q.top().id;
		long long utot=q.top().tot,uht=q.top().ht;
		q.pop();
		if(u>>1==t){
			ans=min(ans,utot);
		}
		if(vis[u]){
			continue;
		}
		vis[u]=true;
		for(int i=0,v,w,z;i<e[u].size();i++){
			v=e[u][i].id,w=e[u][i].tot,z=e[u][i].ht;
			q.push({v,utot+uht+w,z});
		}
	}
	if(ans==2e18){
		return -1;
	}else{
		return ans;
	}
}

int main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++){
		cin>>l[i]>>r[i]>>h[i];
	}
	init();
	link();
	cout<<bfs()<<'\n';
	return !~(0^0);
}
```

---

## 作者：CaiZi (赞：6)

## [GESP202406 八级] 空间跳跃 题解
**[题目链接](https://www.luogu.com.cn/problem/P10726)**
### 前言
这里给出一个非常暴力，时间复杂度上界有 $10^8$ 的做法，但是由于洛谷评测机性能高，所有点都可以在 $40\text{ ms}$ 内通过。

你也可以看一看别的题解更加高效的做法，本篇题解仅可以通过本题的数据范围，稍微加强便可以卡掉。
### 题目分析

首先将所有挡板按照高度排序，之后的 $i,l_i,r_i,h_i$ 均指排序后的挡板的信息。我们枚举两块挡板进行 DP，第一块挡板从高度高的挡板开始枚举，第二块挡板高度比第一块挡板高。

我们令 $f_{i,0}$ 表示到达第 $i$ 快挡板左边的最少时间，$f_{i,1}$ 表示到达第 $i$ 块挡板右边的最少时间。我们假设小杨可以穿过挡板，有以下转移方程（凑合看吧，配合样例应该还是很好理解的）：

$$\begin{cases}f_{i,0}=\min\limits_{i+1\le j\le n\land l_i\le l_j\le r_i}\{f_{j,0}+h_j-h_i+l_j-l_i\}\\f_{i,0}=\min\limits_{i+1\le j\le n\land l_i\le r_j\le r_i}\{f_{j,1}+h_j-h_i+r_j-l_i\}\\f_{i,1}=\min\limits_{i+1\le j\le n\land l_i\le l_j\le r_i}\{f_{j,0}+h_j-h_i+r_i-l_j\}\\f_{i,1}=\min\limits_{i+1\le j\le n\land l_i\le r_j\le r_i}\{f_{j,1}+h_j-h_i+r_i-r_j\}\end{cases}$$

但是这个方程有问题，实际中小杨不可以穿过挡板，因此我们第二块挡板需要从高度低的挡板开始枚举。同时每次第二块挡板枚举后，需要将其的范围全部覆盖，避免出现后面枚举的挡板穿透这块挡板。而暴力是不可取的，因为本题中值域有 $10^5$，加上前面的 $O(n^2)$ 直接爆炸。

接下来使用树状数组区间加单点查，判断一个位置是否被覆盖过，每次第一块挡板枚举后，记得将树状数组清空（我调了 $1$ 个小时）。时间复杂度 $O(n^2\log m+nm)$，其中 $m$ 为值域。

毕竟 CCF 的评测机效率可能略差，如果你追求更高效的时间复杂度，可以对其进行离散化，这样时间复杂度就是 $O(n^2\log n)$ 了，不过我懒得写。
### 代码展示
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r,h,m;
}a[1001];
int n,u,v,s,t,f[1001][2],p=INT_MAX,tre[100002];
inline void update(int x,int y){
	for(int i=x;i<=100001;i+=i&-i){
		tre[i]+=y;
	}
	return;
}
inline int query(int x){
	int y=0;
	for(int i=x;i>=1;i-=i&-i){
		y+=tre[i];
	}
	return y;
}
inline bool cmp(node x,node y){
	return x.h<y.h;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>u>>v;
	for(int i=1;i<=n;i++){
		cin>>a[i].l>>a[i].r>>a[i].h;
		a[i].m=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(a[i].m==u){
			s=i;
		}
		if(a[i].m==v){
			t=i;
		}
	}
	memset(f,100,sizeof(f));
	f[s][0]=0;
	f[s][1]=a[s].r-a[s].l;
	for(int i=n;i>=1;i--){
		for(int j=1;j<=100001;j++){
			tre[j]=0;
		}
		for(int j=i+1;j<=n;j++){
			if(a[i].l<=a[j].l&&a[j].l<=a[i].r&&query(a[j].l)==0){
				f[i][0]=min(f[i][0],f[j][0]+a[j].h-a[i].h+a[j].l-a[i].l);
				f[i][1]=min(f[i][1],f[j][0]+a[j].h-a[i].h+a[i].r-a[j].l);
			}
			if(a[i].l<=a[j].r&&a[j].r<=a[i].r&&query(a[j].r)==0){
				f[i][0]=min(f[i][0],f[j][1]+a[j].h-a[i].h+a[j].r-a[i].l);
				f[i][1]=min(f[i][1],f[j][1]+a[j].h-a[i].h+a[i].r-a[j].r);
			}
			update(a[j].l,1);
			update(a[j].r+1,-1);
		}
	}
	for(int i=1;i<=100001;i++){
		tre[i]=0;
	}
	for(int i=t+1;i<=n;i++){
		if(a[t].l<=a[i].l&&a[i].l<=a[t].r&&query(a[i].l)==0){
			p=min(p,f[i][0]+a[i].h-a[t].h);
		}
		if(a[t].l<=a[i].r&&a[i].r<=a[t].r&&query(a[i].r)==0){
			p=min(p,f[i][1]+a[i].h-a[t].h);
		}
		update(a[i].l,1);
		update(a[i].r+1,-1);
	}
	if(p>=1684300900){
		cout<<"-1";
	}
	else{
		cout<<p;
	}
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/164899596)**

---

## 作者：fine8862 (赞：6)

## 概述

这是一篇时间复杂度为“线性乘对数级别”的“扫描线+最短路”题解。

由于 $n \le 1000$，且我的实现常数较大，所以我的程序实际运行时间并不是特别短。

## 分析

题目所求为最短路且有明显的转移方式，于是可以建图跑最短路。

最短路的实现比较简单，故不在这里阐述。接下来的重点放在建图部分。

### 建图的主要思路

考虑有三种转移方式，如下：

>1. 从一个挡板的左/右边缘走到右/左边缘。
>2. 从一个挡板的做/右边缘跳到在另一个挡板上的落点。
>3. 从一个挡板上的落点走到该挡板的左/右边缘。

解决方法则是：

>1. 建一条端点分别为“挡板的左右边缘”的双向边，边权为挡板长度。
>2. 建一条从边缘到落点的单向边，边权为边缘和落点的高度差。
>3. 建两条从落点分别到“挡板的左/右边缘”的单向边，边权为落点到左/右边缘的长度。

显然第一种比较容易操作。而第二种和第三种则需要找到落点。

#### 找落点

一个“坐标为 $(x,h)$ 的边缘”的落点是一个在挡板上的点 $(x_0,h_0)$。并且这个点使得 $x_0=x,h_0<h$ 且 $h_0$ 最大。

如果暴力寻找一个落点，时间复杂度为 $\mathcal{O}(n)$，又由于有 $2n$ 个边缘，所以总复杂度为 $\mathcal{O}(n^2)$，虽然足以通过本题，但是可以继续优化。

首先对所有挡板按照 $h$ 进行升序排序，并按照顺序重新编号（注意把 $S,T$ 亦重新编号）。

我们考虑扫描线，然后将高度 $h$ 逐渐增大，把平面分层若干层一维序列，每一层需要查询/提供如下信息：

>1. 该序列的每一个位置如果作为边缘，它的落点在哪里。
>2. 该序列的每一个位置如果作为边缘，它的落点在哪个挡板上。
>3. 该序列的每一个位置如果作为边缘，它和落点的高度差是多少。

而维护了第二个信息，即可推算出第一个信息和第三个信息。

> 不妨已知一个边缘 $(x,h)$ 的落点在第 $k$ 个挡板上。那么它的落点就是 $(x,h_k)$，高度差就是 $h-h_k$。（可以发现，维护挡板的高度也是可以的）

对于第二个信息，相当于一个区间覆盖。

- 每一层在统计完后，若该层有一个挡板是第 $k$ 个，那么就把这个序列 $[l_k,r_k]$ 的落点改为在第 $k$ 个挡板上，供下一层查询。

不难发现，可以使用一个“区间修改，单点查询”的线段树来维护第二个信息。

综上，我们找到落点，即可建出图，最后跑最短路就做完了。

## 时间复杂度分析


线段树 + 扫描线时间复杂度为 $\mathcal{O}(n\log (\max r))$。


一个挡板最多会建出 $4$ 个图上的点（左/右边缘和它们对应的落点），所以最多会建出 $4n$ 个点，每个点最多引出两条边，所以最多会建出 $8n$ 个点。所以最短路时间复杂度为 $\mathcal{O}(n\log n)$。

总时间复杂度为 $\mathcal{O}(n\log (\max r)+n\log n)$，可以近似认为 $n\log n$。
## 实现上的细节

有一些细节可供*参考*。（可能是我写法的问题）

1. 答案需要求走在 $T$ 号挡板的最短路，而不是到两端的最短路，所以走到中间的某些落点也是可以的。
2. 总共会有 $4n$ 个点。

## code

```cpp
#include<bits/stdc++.h>
#define PII pair<ll,ll>
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;
typedef long long ll;
const ll INF=0x3f3f3f3f3f3f3f3f;
const ll N=1e3+5,M=1e5+5;
const ll maxlen=1e5;
struct seg{
    ll id;
    ll l,r,h;
    friend bool operator<(seg x,seg y){
        return x.h<y.h;
    }
}a[N];
struct seg_tree{
    struct node{
        ll l,r;
        int col,tag;
    }tr[M<<2];
    void pushdown(ll p){
        mktag(p<<1,tr[p].tag);
        mktag(p<<1|1,tr[p].tag);
        tr[p].tag=0;
    }
    void mktag(ll p,ll k){
        if(tr[p].r==tr[p].l)tr[p].col=k;
        tr[p].tag=k;
    }
    void build(ll p,ll l,ll r){
        tr[p].l=l,tr[p].r=r;
        if(l==r){
            tr[p].col=tr[p].tag=0;
            return;
        }
        ll mid=(l+r)>>1;
        build(p<<1,l,mid);
        build(p<<1|1,mid+1,r);
    }
    void update(ll p,ll ql,ll qr,ll k){
        ll l=tr[p].l,r=tr[p].r;
        if(ql<=l&&r<=qr){
            mktag(p,k);
            return;
        }
        if(tr[p].tag)pushdown(p);
        ll mid=(l+r)>>1;
        if(ql<=mid)update(p<<1,ql,qr,k);
        if(qr>mid)update(p<<1|1,ql,qr,k);
    }
    ll query(ll p,ll q){
        ll l=tr[p].l,r=tr[p].r;
        if(l==r)return tr[p].col;
        if(tr[p].tag)pushdown(p);
        ll mid=(l+r)>>1;
        if(q<=mid)return query(p<<1,q);
        else return query(p<<1|1,q);
    }
}Tr;//维护区间覆盖的线段树
ll n,S,T,news,newt;
vector<PII>G[N<<2];//4n个点
ll dis[N<<2],vis[N<<2];//4n个点
ll pos[N<<2];//4n个点
void add(ll u,ll v,ll w){
    G[u].push_back({v,w});
}
int main(){
	ios::sync_with_stdio(0);
    Tr.build(1,1,maxlen);
    cin>>n>>S>>T;
    for(ll i=1;i<=n;i++)cin>>a[i].l>>a[i].r>>a[i].h,a[i].id=i;
    sort(a+1,a+1+n);//按照 h 升序排序
    ll cnt=n*2;
    for(ll i=1;i<=n;i++){//扫描线
        pos[i*2-1]=i;
        pos[i*2]=i;
        add(i*2-1,i*2,a[i].r-a[i].l);
        add(i*2,i*2-1,a[i].r-a[i].l);//建一条端点分别为“挡板的左右边缘”的双向边，边权为挡板长度
        ll lid=Tr.query(1,a[i].l);//找落点
        if(lid!=0){
            pos[++cnt]=lid;//新加一个落点，它在第 lid 个挡板上
            add(i*2-1,cnt,a[i].h-a[lid].h);//建一条从边缘到落点的单向边，边权为边缘和落点的高度差
            add(cnt,lid*2-1,a[i].l-a[lid].l);
            add(cnt,lid*2,a[lid].r-a[i].l);//建两条从落点分别到“挡板的左/右边缘”的单向边，边权为落点到左/右边缘的长度
        }
        ll rid=Tr.query(1,a[i].r);
        if(rid!=0){
            //同上
            pos[++cnt]=rid;
            add(i*2,cnt,a[i].h-a[rid].h);
            add(cnt,rid*2-1,a[i].r-a[rid].l);
            add(cnt,rid*2,a[rid].r-a[i].r);
        }
        Tr.update(1,a[i].l,a[i].r,i);
        if(a[i].id==S)news=i*2-1;
        if(a[i].id==T)newt=i;
    }
    memset(dis,0x3f,sizeof dis);//以下是最短路
    dis[news]=0;
    priority_queue<PII>q;
    q.push({0,news});
    while(!q.empty()){
        PII tmp=q.top();
        q.pop();
        ll u=tmp.second;
        if(vis[u])continue;
        vis[u]=1;
        for(PII e:G[u]){
            ll v=e.first;
            if(dis[u]+e.second<dis[v]){
                dis[v]=dis[u]+e.second;
                q.push({-dis[v],v});
            }
        }
    }
    ll ans=INF;
    for(int i=1;i<=cnt;i++){
        if(pos[i]==newt)ans=min(ans,dis[i]);//统计"走到中间的某些落点或边缘"的答案
    }
    if(ans<INF)cout<<ans<<endl;
    else cout<<"-1\n";
	return 0;
}
```

---

## 作者：Licis_Subway (赞：4)

8 月 25 日更新：在思路部分加强了对多个挡板叠落的实现过程的讲解。

本题可以使用动态规划或者最短路算法实现。

本题解会先建图，再使用 Dijkstra 最短路算法。
# 思路
假设有两个水平挡板如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/gcblriht.png)
我们分别在挡板两侧新建两个节点：
![](https://cdn.luogu.com.cn/upload/image_hosting/z91lrus7.png)
在新建的图中，节点 $l_1$ 与 $r_1$ 有一条边，而节点 $l_2$ 与 $r_2$ 也有一条边。

现在，我们要想办法让挡板 1 的节点和挡板 2 的结点建立联系。

设挡板 1 和挡板 2 的距离为 $h$：
![](https://cdn.luogu.com.cn/upload/image_hosting/ywr16w9k.png)
那么我们就可以新建两条边：

1. 节点 $l_1$ 至 $l_2$ 且权值为 $h+l$。
2. 节点 $l_1$ 至 $r_2$ 且权值为 $h+r$。

像这样，只要较靠上的挡板可以掉落至较靠下的挡板，那么就可以新建两条边。

注：挡板 1 上的 $r_1$ 也可以新建两条至 $l_2$ 和 $r_2$ 的边。

**注意：在实现时，还有一种情况需要大家注意：如果一个板子底下同事有两个板子（如图）**
![](https://cdn.luogu.com.cn/upload/image_hosting/ym0k7qt1.png)
那么我们就说挡板 1 的左端点只能掉落至挡板 2 上，而不能掉落至挡板 3 上；挡板 1 的右端点可以直接掉落至挡板 3 上。

有同学可能会问：这种情况，挡板 1 的右端点会掉落至挡板 2 还是挡板 3？
![](https://cdn.luogu.com.cn/upload/image_hosting/t1xvdpp4.png)
答案：掉落在哪都不影响答案，因为直接掉落和创建两条边对整张图是没有影响的。
# 代码
注：在代码中，为了方便，我把每个位于挡板左侧的节点的编号设为他所在的挡板的编号 $\times 2$，而在右侧的即为他所在的挡板的编号 $\times 2 +1$。
```cpp
#include<cstdio>
#include<queue>
#include<vector>
#include<utility>
#include<set>
#include<cstring>
using namespace std;
int n,s,t,m;
const int N=10005;
struct Node
{
    int v,w;
    friend bool operator <(const Node &x,const Node &y){return x.w>y.w;}
};
Node make_node(const int &v,const int &w)
{
    Node ans;
    ans.v=v;ans.w=w;
    return ans;
}
int l[N],r[N],h[N],firstdrop[N<<1],dropto[N<<1],dis[N<<1];
bool vis[N<<1];
set<int> dropable;
vector<pair<int,int> > G[N<<1];
inline int LL(int x){return 2*x;}
inline int RR(int x){return 2*x+1;}
inline int min(const int &x,const int &y){return x<=y?x:y;}
void Dijkstra(int s)
{
    for(int i=1;i<=m;i++) dis[i]=2e9;
    priority_queue<Node> pq;
    dis[s]=0;
    pq.push(make_node(s,dis[s]));
    while(!pq.empty())
    {
        Node cur=pq.top();
        pq.pop();
        int u=cur.v;
        if(vis[u]) continue;
        vis[u]=true;
        vector<pair<int,int> >::iterator it=G[u].begin();
        for(;it!=G[u].end();it++)
        {
            int v=it->first,w=it->second;
            if(!vis[v]&&dis[v]>dis[u]+w)
            {
                dis[v]=dis[u]+w;
                pq.push(make_node(v,dis[v]));
            }
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&s,&t);
    m=2*n+1;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&l[i],&r[i],&h[i]);
        G[LL(i)].push_back(make_pair(RR(i),r[i]-l[i]));
        G[RR(i)].push_back(make_pair(LL(i),r[i]-l[i]));
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(h[i]>=h[j]&&i!=j)
            {
                //Right
                if(r[i]>=l[j]&&r[i]<=r[j])
                    if(firstdrop[RR(i)]<=h[j])
                    {
                        firstdrop[RR(i)]=h[j];
                        dropto[RR(i)]=j;
                    }
                if(l[i]>=l[j]&&l[i]<=r[j])
                    if(firstdrop[LL(i)]<=h[j])
                    {
                        firstdrop[LL(i)]=h[j];
                        dropto[LL(i)]=j;
                    }
            }
    for(int i=1;i<=m;i++)
        if(dropto[i]==t) dropable.insert(i);
    for(int i=2;i<=m;i+=2)
    {
        if(dropto[i+1]!=0)
        {
            int nowh=h[i/2]-h[dropto[i+1]],Llen=r[i/2]-l[dropto[i+1]],Rlen=r[dropto[i+1]]-r[i/2];
            G[i+1].push_back(make_pair(LL(dropto[i+1]),nowh+Llen));
            G[i+1].push_back(make_pair(RR(dropto[i+1]),nowh+Rlen));
        }
        if(dropto[i]!=0)
        {
            int nowh=h[i/2]-h[dropto[i]],Llen=l[i/2]-l[dropto[i]],Rlen=r[dropto[i]]-l[i/2];
            G[i].push_back(make_pair(LL(dropto[i]),nowh+Llen));
            G[i].push_back(make_pair(RR(dropto[i]),nowh+Rlen));
        }
    }
    Dijkstra(2*s);
    int minn=2e9;
    set<int>::iterator it=dropable.begin();
    for(;it!=dropable.end();it++) minn=min(minn,dis[*it]+(h[*it/2]-h[t]));
    minn=min(min(minn,dis[2*t]),dis[2*t+1]);
    if(minn>=2e9)
    {
        printf("-1\n");
        return 0;
    }
    printf("%d\n",minn);
    return 0;
}
```

---

## 作者：caoyuchen110911 (赞：4)

一道 dp 题。

$dp_{i,0}$ 为到达第 $i$ 块挡板左端的用时，$dp_{i,1}$ 为到达第 $i$ 块挡板右端的用时。

第 $i$ 个挡板的左端到第 $j$ 个挡板的左端所需时间为 $h_i-h_j+l_i-l_j$，也就是说 $dp_{j,0}=dp_{i,0}+h_i-h_j+l_i-l_j$。右端点同理可得。

具体看代码注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//不开 long long 见祖宗 
int dp[1005][2];
//dp[i][0]:在i挡板的左端点时的时间 
//dp[i][1]:在i挡板的右端点时的时间 
struct cyc{
	int l,r,h,I;
}c[1005];
bool cmp(cyc x,cyc y)
{
	return x.h>y.h;//高的在前 
	//高度相同,无需排序 
}
signed main()
{
    int n,s,t,s2,t2,ans=1e18;
    scanf("%lld%lld%lld",&n,&s,&t);
    for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld",&c[i].l,&c[i].r,&c[i].h);
		c[i].I=i;//防止排序后找不到编号s和t的挡板 
		dp[i][0]=dp[i][1]=1e18;//最短时间,初始化最大 
	}
    sort(c+1,c+1+n,cmp);
    for(int i=1;i<=n;i++)
    {
    	if(c[i].I==s)s2=i;
    	if(c[i].I==t)t2=i;
		//存下排序后的s和t,记作s2和t2 
	}
	dp[s2][0]=0,dp[s2][1]=c[s2].r-c[s2].l;//初始化不能忘 
	for(int i=s2;i<=t2;i++)
	{
		for(int j=i+1;j<=t2;j++)//只在比当前挡板低的挡板寻找 
		{
			//高度已经排好,无需再次比较 
			if(c[i].l>=c[j].l&&c[i].l<=c[j].r)//i的左端点在j的范围内 
			{
				if(j==t2)ans=min(ans,dp[i][0]);//更新答案 
				dp[j][0]=min(dp[j][0],dp[i][0]+c[i].l-c[j].l);
				//原计划和从i挡板掉落(左至左)的最优值 
				dp[j][1]=min(dp[j][1],dp[i][0]+c[j].r-c[i].l);
				//原计划和从i挡板掉落(左至右)的最优值 
				break;//找到了就退出 
			}
		}
		for(int j=i+1;j<=t2;j++)
		{
			if(c[i].r>=c[j].l&&c[i].r<=c[j].r)//i的右端点在j的范围内 
			{
				if(j==t2)ans=min(ans,dp[i][1]);
				dp[j][0]=min(dp[j][0],dp[i][1]+c[i].r-c[j].l);
				//原计划和从i挡板掉落(右至左)的最优值 
				dp[j][1]=min(dp[j][1],dp[i][1]+c[j].r-c[i].r);
				//原计划和从i挡板掉落(右至右)的最优值 
				break;
			}
		}
	}
	if(ans==1e18)printf("-1\n");//没有办法走到 
	else printf("%lld\n",ans+c[s2].h-c[t2].h);
	//最后加上高度,因为不管怎么走,从s2到t2的高度差是不会变的,最后加可以防止出错 
    return 0;
}
```

---

## 作者：2huk (赞：4)

最短路？线段树？直接暴力 DP！

首先，如果线段 $i$ 的高 $h_i$ 不在 $[h_t, h_s]$ 内，那么这条线段一定不会被用到。同时，若 $h_i = h_s, i \ne s$ 或 $h_i = h_t, i \ne t$，也就是说线段 $i$ 和线段 $s, t$ 在同一高度但不是线段 $s, t$，那么这条线段也一定不会被用到。

排除这些无用线段后，我们将高度离散化。此时最高的（即 $h$ 最大的）线段一定是**唯一**的线段 $s$，最低的（即 $h$ 最小的）线段一定是**唯一**的线段 $t$。令离散化后的高度范围为 $[1, m]$。

我们令离散化后高度为 $i$ 的线段构成的集合为 $S_i$，集合中的第 $j$ 条线段为 $(i, j)$。代码里可以用 vector 存储。

考虑 DP。因为小球不能往上走，所以往下走的步数**一定**是 $h_s - h_t$。若这个值是负的那么直接输出 $-1$。那么我们只需要处理左右走的步数即可。以下的步数都指左右的步数。

若我们设 $f(i, j)$ 表示从线段 $s$（也就是线段 $(m, 1)$）走到线段 $(i, j)$ 的最小步数，那么转移不了。因为小球从一条线段掉落到另一条线段只能通过它的两个端点，所以我们多设一维：

- $f(i, j, 0)$ 表示到达线段 $(i, j)$ **左端点**的最少步数；
- $f(i, j, 1)$ 表示到达线段 $(i, j)$ **右端点**的最少步数。
- $f(i, j, 2)$ 表示到达线段 $(i, j)$ 上**任意位置**的最少步数（包括左右端点）；

显然答案为 $f(1, 1, 2)$，表示到达线段 $t$ 上任意位置的最少步数。

若我们可以求出 $X(x, y), Y(x, y)$ 表示从 $x$ 高度的 $y$ 位置掉落时，小球会掉落到高度为 $X(x, y)$ 的第 $Y(x, y)$ 个线段上，那么可以转移（令	$L(x, y), R(x, y)$ 分别表示线段 $(x, y)$ 的左右端点的横坐标）：

$$
f(x, y, 0) + |L(x, y) - L(X(x, y), Y(x, y))| \to f(X(x, y), Y(x, y), 0) \\
f(x, y, 0) + |L(x, y) - R(X(x, y), Y(x, y))| \to f(X(x, y), Y(x, y), 1) \\
f(x, y, 0) \to f(X(x, y), Y(x, y), 2) \\
f(x, y, 1) + |R(x, y) - L(X(x, y), Y(x, y))| \to f(X(x, y), Y(x, y), 0) \\
f(x, y, 1) + |R(x, y) - R(X(x, y), Y(x, y))| \to f(X(x, y), Y(x, y), 1) \\
f(x, y, 1) \to f(X(x, y), Y(x, y), 2)
$$

$X(x, y), Y(x, y)$ 可以暴力求解。也就是说转移复杂度为 $\mathcal O(n)$。状态数相当于计算每个高度的线段数之和，即 $n$。所以总时间复杂度 $\mathcal O(n^2)$。

注意代码中因为使用 vector 所以有些下标从 $0$ 开始。例如答案为 $f(1, 0, 2)$ 而非上文的 $f(1, 1, 2)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int n, s, t;

struct Seg {
	int h, l, r;
}seg[N];

struct SEG {
	int l, r;
};

int nums[N], cnt;
vector<SEG> segs[N];
int f[N][N][3];

pair<int, int> calc(int x, int y) {
	for (int i = x - 1; i; -- i )
		for (int j = 0; j < segs[i].size(); ++ j )
			if (segs[i][j].l <= y && segs[i][j].r >= y)
				return {i, j};
	return {-1, -1};
}

int main() {
	cin >> n >> s >> t;
	
	for (int i = 1; i <= n; ++ i ) {
		cin >> seg[i].l >> seg[i].r >> seg[i].h;
	}
	
	if (seg[s].h <= seg[t].h) {
		puts("-1");
		return 0;
	}
	
	for (int i = 1; i <= n; ++ i ) {
		if (seg[i].h <= seg[s].h && seg[i].h >= seg[t].h) {
			if (i != s && seg[i].h == seg[s].h) continue;
			if (i != t && seg[i].h == seg[t].h) continue;
			nums[ ++ cnt] = seg[i].h;
		}
	}
	
	sort(nums + 1, nums + cnt + 1);
	cnt = unique(nums + 1, nums + cnt + 1) - nums - 1;
	
	for (int i = 1; i <= n; ++ i ) {
		if (seg[i].h <= seg[s].h && seg[i].h >= seg[t].h) {
			if (i != s && seg[i].h == seg[s].h) continue;
			if (i != t && seg[i].h == seg[t].h) continue;
			segs[lower_bound(nums + 1, nums + cnt + 1, seg[i].h) - nums].push_back({seg[i].l, seg[i].r});
		}
	}
	
	memset(f, 0x3f, sizeof f);
	f[cnt][0][0] = 0;
	f[cnt][0][1] = seg[s].r - seg[s].l;
	f[cnt][0][2] = 0;
	
	for (int i = cnt; i > 1; -- i )
		for (int j = 0; j < segs[i].size(); ++ j ) {
			auto t = calc(i, segs[i][j].l);
			int x = t.first, y = t.second;
			
			if (~x) {
				f[x][y][0] = min(f[x][y][0], f[i][j][0] + abs(segs[i][j].l - segs[x][y].l));
				f[x][y][1] = min(f[x][y][1], f[i][j][0] + abs(segs[i][j].l - segs[x][y].r));
				f[x][y][2] = min(f[x][y][2], f[i][j][0]);
			}
			
			t = calc(i, segs[i][j].r);
			x = t.first, y = t.second;
			
			if (~x) {
				f[x][y][0] = min(f[x][y][0], f[i][j][1] + abs(segs[i][j].r - segs[x][y].l));
				f[x][y][1] = min(f[x][y][1], f[i][j][1] + abs(segs[i][j].r - segs[x][y].r));
				f[x][y][2] = min(f[x][y][2], f[i][j][1]);
			}
		}
	
	int res = f[1][0][2];
	if (res > 1e9) puts("-1");
	else cout << res + (seg[s].h - seg[t].h) << '\n';
	
	return 0;
}
```

---

## 作者：yuyc (赞：4)

有人在考场上两分钟想到建边跑最短路，但是两度看错数据范围，并尝试使用树状数组来维护区间赋值，痛失 S 组免初赛资格，我不说是谁。

### 解析

读完题目，我们发现，在挡板上移动与垂直掉落的**本质**是一样的，都是消耗 $1$ 单位时间，移动 $1$ 单位长度。

所以我们可以考虑建边，具体地，对于每个挡板的左端点，向右端点连一条边权为挡板长度的**双向边**，代表在挡板上移动。

对于每个挡板的端点 $u$，尝试从该端点垂直向下连一条**单向边**，连到位于该端点正下方第一个挡板上，我们在这里新开一个点，边权为两挡板高度差，代表垂直下落，下方没有挡板则不连。

然后，从新开的这个点出发，往所在挡板的左右端点分别连**单向边**，边权为该点到左右端点的距离，即 $u$ 到该挡板左右端点的**水平**距离，代表垂直下落之后在挡板上移动。

如何给结点编号？我的做法是，令第 $i$ 个挡板的左端点的编号为 $2i - 1$，右端点编号为 $2i$，这样就有了 $2n$ 个点，向下连边的时候再一个一个加点。

可能有点抽象，放个图：


![](https://cdn.luogu.com.cn/upload/image_hosting/ei5pep8b.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/m6sc93hh.png)

可以发现，除了起点挡板，其余挡板不需要用双向边来连接左右端点，不过这不是必要的优化。

建完边，从 $2s-1$ （起点挡板的左端点）开始跑单源最短路即可，我采用的是不加优化的 Dijkstra，答案为在挡板 $t$ 上的所有点的 $dis$ 最小值。

暴力找到一个挡板的端点正下方的第一个挡板，复杂度是 $O(n)$ 的，找 $n$ 个挡板，复杂度为 $O(n^2)$，暴力 Dijkstra 的复杂度为 $O(n^2)$，故总复杂度为 $O(n^2)$，足以通过此题。
### 代码
```cpp

#include <bits/stdc++.h>
#define mp make_pair
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;

const int N = 1e3 + 5, mod = 10007;
int cnt;
struct B{
	int l,r,h;//存储挡板的信息
}b[N];
vector<pii> g[N<<2];
bool vis[N<<2];
ll dis[N<<2];
int n,s,t;
void dij(){
	memset(dis,127,sizeof(dis));
	dis[s * 2 - 1] = 0;
	while(1){
		int u = 0;
		for(int i=1;i<=cnt;i++){
			if(!vis[i] && dis[i] < dis[u]){
				u = i;
			}
		}
		if(!u) break;
		vis[u] = true;
		for(pii p : g[u]){
			int v = p.first,w = p.second;
			if(dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
			}
		}
	} 
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	vector<int> fin;//在挡板 t 上的点
	cin>>n>>s>>t;
	fin.push_back(t * 2 - 1),fin.push_back(t * 2);//
	for(int i=1;i<=n;i++){
		cin>>b[i].l>>b[i].r>>b[i].h;
		cnt += 2;
		int lpos = i * 2 - 1,rpos = i * 2;
		g[lpos].push_back(mp(rpos,b[i].r - b[i].l));
		g[rpos].push_back(mp(lpos,b[i].r - b[i].l));
	}
	for(int i=1;i<=n;i++){
		int lb = 0,rb = 0;//左右端点向下找到的第一个挡板（比当前挡板低的最高的挡板）
		int mxlh = 0,mxrh = 0;//找到的挡板的高度
		for(int j=1;j<=n;j++){
			if(b[j].h < b[i].h && b[j].h > mxlh && b[i].l <= b[j].r && b[i].l >= b[j].l){
				mxlh = b[j].h;
				lb = j;
			}
			if(b[j].h < b[i].h && b[j].h > mxrh && b[i].r <= b[j].r && b[i].r >= b[j].l){
				mxrh = b[j].h;
				rb = j;
			}
		}
		int lpos = i * 2 - 1,rpos = i * 2;
		int lhcha = b[i].h - mxlh,rhcha = b[i].h - mxrh;//高度差
		if(lb){
			cnt++;
			g[lpos].push_back(mp(cnt,lhcha));
			g[cnt].push_back(mp(lb * 2 - 1,b[i].l - b[lb].l));
			g[cnt].push_back(mp(lb * 2,b[lb].r - b[i].l));
			if(lb == t){
				fin.push_back(cnt);
			}
		}
	
		if(rb){
			cnt++;
			g[rpos].push_back(mp(cnt,rhcha));
			g[cnt].push_back(mp(rb * 2 - 1,b[i].r - b[rb].l));
			g[cnt].push_back(mp(rb * 2,b[rb].r - b[i].r));
			if(rb == t){
				fin.push_back(cnt);
			}
		}
		
	}
	dij();
	ll res = 9e18;
	for(int i : fin){
		res = min(res,dis[i]);
	}
	cout<<(res == 9e18 ? -1 : res);
	return 0;
}
```

---

## 作者：klxxwyx123 (赞：3)

本题可以用 dp 来写。  
## 思路：
- 排序：因为挡板的高低没有顺序，因此我们可以对挡板按高度进行排序。
- 存储编号：由于挡板按高度排序后找不出第 $s$ 个挡板和第 $t$ 个挡板了，所以我们可以用结构体存储编号，在排序后重新查找。
- 定数组：可以定义一个二维的 dp 数组。$dp_{i,0}$ 表示到第 $i$ 个挡板左端的所需时间，$dp_{i,1}$ 表示到第 $i$ 个挡板右端的所需时间。
- 赋值：由于小杨初始在第 $s$ 个挡板的左端点，所以  $dp_{s,0}$ 应赋值为 $0$，而 $dp_{s,1}$ 应赋值为第 $s$ 个挡板中左端点到右端点的距离，也就是 $r_s-l_s$。因为第 $i$ 个挡板的左端点到第 $j$ 个挡板的左端点需要 $h_i-h_j+l_i-l_j$ 的时间，所以 $dp_{j,0}=dp_{i,0}+h_i-h_j+l_i-l_j$。右端点也可以由此推出。
  
其余内容看代码注释：

```cpp
#include <bits/stdc++.h>
#define int long long//数据范围大，要开long long
using namespace std;
struct stu{//结构体方便排序
	int l,r,h,id;
}a[1005];
bool cmp(stu a,stu b){
	if(a.h!=b.h) return a.h>b.h;//按高度排序
	return a.l<b.l;//否则从左到右排序
}
int dp[1005][2]; 
signed main(){
	int n,s,t;
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++){
		cin>>a[i].l>>a[i].r>>a[i].h;
		a[i].id=i;//存储编号
		dp[i][0]=1e18;//赋值为最大
		dp[i][1]=1e18;
	} 
	if(a[s].h<a[t].h){//判断高度，如果第s个挡板比第t个挡板低，则直接输出
		cout<<-1;
		return 0;
	}
	sort(a+1,a+1+n,cmp);
	int s1,t1;
	for(int i=1;i<=n;i++){
		if(a[i].id==s){
			s1=i;
		} 
		if(a[i].id==t){
			t1=i;
		} 
	}
	dp[s1][0]=0,dp[s1][1]=a[s1].r-a[s1].l;
	int ans=1e18;
	for(int i=s1;i<=t1;i++){		
		//从左端点下来 
		for(int j=i+1;j<=t1;j++){
			if(a[i].l>=a[j].l&&a[i].l<=a[j].r&&a[i].h>a[j].h){//如果能落在第j个挡板上,则执行。
				if(t1==j) ans=min(ans,dp[i][0]+a[i].h-a[j].h);//已经落在了第t个挡板上。
				dp[j][0]=min(dp[j][0],dp[i][0]+a[i].h-a[j].h+a[i].l-a[j].l); //落在第j个挡板的左端点上。
				dp[j][1]=min(dp[j][1],dp[i][0]+a[i].h-a[j].h+a[j].r-a[i].l); //落在第j个挡板的右端点上。
				break; 
			} 
		}	
		//从右端点下来 
		for(int j=i+1;j<=t1;j++){
			if(a[i].r<=a[j].r&&a[i].r>=a[j].l&&a[i].h>a[j].h){
				if(t1==j) ans=min(ans,dp[i][1]+a[i].h-a[j].h);
				dp[j][0]=min(dp[j][0],dp[i][1]+a[i].h-a[j].h+a[i].r-a[j].l);
				dp[j][1]=min(dp[j][1],dp[i][1]+a[i].h-a[j].h+a[j].r-a[i].r);
				break;
			} 
		}		
	}
	if(ans==1e18) cout<<-1;//如果ans未改变，说明无法落在第t个挡板上。
	else cout<<ans;
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：3)

# P10726 题解

~~祝贺本蒟蒻 GESP 8 级侥幸获得 92 分~~

## 思路

题目求的是花费的最少时间，DP 好像不大好写，看看能不能把问题转换成图论问题，求最短路。

### 图论

对于每个挡板，创建两个点，表示左端点和右端点。

在挡板的两个端点才能往下降，所以将左右两端下落后到达的位置也分别创建两个点，这些点有可能落在其它挡板的中间，也有可能与左右端点重合，然后对于这两个点，创建一条连接到左端点的边，创建一条连接到右端点的边。

### 点编号的处理

对于第 $i$ 个挡板的左端点，用 $i$ 作为编号，对于它的右端点，用 $n+i$ 作为编号，这样把前面 $2n$ 个点充分利用好。

对于左右端点分别往下掉落所产生的新的点，从 $2n+1$ 开始动态开点。

这样一来，最多只需要创建 $4n$ 个点就行了。

### 边数分析

接下来分析边数。

对于一个挡板，左右端点彼此连接，花费 $2$ 条边，然后分别往下落，又需要 $2$ 条边，对于下落后产生的新点，分别向左右端点再连边，产生 $4$ 条边，所以，对于一个挡板，最多只需要创建 $8$ 条边。

这样一来，边数组只需要开到 $8n$ 就行了。

## 代码

除了要开 `long long`，其余没什么好说的，剩下就是 `dijkstra` 板子了。

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N=4005;
const int M=8005;
const int inf=1e18;

typedef pair<int,int> pii;

int n;
int S,T;
int e[M],ne[M],w[M],h[N],tot;
int idx;
vector<int> nodes[N];
int dis[N];
priority_queue< pii,vector<pii>,greater<pii> > q;

struct node {
    int l,r,h,i;
    friend bool operator < (const node& a,const node& b) {
        return a.h>b.h;
    }
} arr[N];

void add(int a,int b,int c) {
    e[tot]=b,w[tot]=c,ne[tot]=h[a],h[a]=tot++;
}

void dijkstra(int s) {
    for (int i=0;i<N;++i) dis[i]=inf;
    q.push({dis[s]=0,s});
    while (!q.empty()) {
        auto tp=q.top(); q.pop();
        int u=tp.second;
        for (int i=h[u];~i;i=ne[i]) {
            if (dis[e[i]]>dis[u]+w[i]) {
                q.push({dis[e[i]]=dis[u]+w[i],e[i]});
            }
        }
    }
}

signed main() {
    memset(h,-1,sizeof(h));
    scanf("%lld",&n); idx=2*n;
    scanf("%lld %lld",&S,&T);
    for (int i=1;i<=n;++i) {
        int l,r,h;
        scanf("%lld %lld %lld",&l,&r,&h);
        arr[i]={l,r,h,i};
    }
    if (S==T) {
        printf("0");
        return 0;
    }
    sort(arr+1,arr+1+n);
    for (int i=1;i<=n;++i) {
        if (arr[i].i==S) {
            S=i;
            break;
        }
    }
    for (int i=1;i<=n;++i) {
        if (arr[i].i==T) {
            T=i;
            break;
        }
    }
    if (S>T) {
        printf("-1");
        return 0;
    }
    for (int i=1;i<=n;++i) {
        int l,r,h;
        l=arr[i].l;
        r=arr[i].r;
        h=arr[i].h;
        nodes[i].push_back(i);
        nodes[i].push_back(n+i);
        add(i,n+i,r-l);
        add(n+i,i,r-l);
        int j;
        for (j=i+1;j<=n;++j) {
            if (arr[j].h<h && l>=arr[j].l && l<=arr[j].r) {
                break;
            }
        }
        if (j<=n) {
            int t=++idx;
            nodes[j].push_back(t);
            add(i,idx,h-arr[j].h);
            add(idx,j,l-arr[j].l);
            add(idx,n+j,arr[j].r-l);
        }
        for (j=i+1;j<=n;++j) {
            if (arr[j].h<h && r>=arr[j].l && r<=arr[j].r) {
                break;
            }
        }
        if (j<=n) {
            int t=++idx;
            nodes[j].push_back(t);
            add(n+i,idx,h-arr[j].h);
            add(idx,j,r-arr[j].l);
            add(idx,n+j,arr[j].r-r);
        }
    }
    dijkstra(S);
    int ans=inf;
    for (int p:nodes[T]) {
        ans=min(ans,dis[p]);
    }
    if (ans==inf) ans=-1;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：xxxalq (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P10726)

# 思路分析

考虑使用动态规划，因为每块板子只能从左右端点跳跃，所以考虑使用动态规划，设 $dp_{i,0/1}$ 表示从第 $s$ 块板子跳到第 $i$ 块板子的左/右端点的最短跳跃距离。我们使用刷表法，如果能从第 $i$ 块板子的左边直接跳到第 $j$ 块板子，那么就可以进行转移。

$$dp_{j,0}=\min(dp_{j,0},dp_{i,0}+h_{i}-h_{j}+l_{i}-l_{j})$$

$$dp_{j,1}=\min(dp_{j,1},dp_{i,0}+h_{i}-h_{j}+r_{j}-l_{i})$$

右侧同理。然后考虑怎么枚举所有可能的转移，我们把数组按照 $h$ 降序排序，对于每个 $i$，可能转移到的情况就只会出现在它后面的第一个。

我们用 $f$ 数组来记录跳到每一块板子的答案，注意不是跳到左右端点。

# 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read(){
	int x=0;
	bool flag=false;
	char ch=getchar();
	while(ch>57||ch<48){
		if(ch==45){
			flag=true;
		}
		ch=getchar();
	}
	while(ch>=48&&ch<=57){
		x=(x<<1)+(x<<3)+(ch-48);
		ch=getchar();
	}
	return flag?-x:x;
}
struct node{
	int idx,l,r,h;
}a[1003];
int n,s,t;

ll dp[1003][2],f[1003];
bool cmp(node A,node B){
	if(A.h==B.h){
		if(A.l==B.l){
			return A.r<B.r;
		}
		return A.l<B.l;
	}
	return A.h>B.h;
}
int main(){
	n=read(),s=read(),t=read();
	for(int i=1;i<=n;i++){
		dp[i][0]=dp[i][1]=1e18,f[i]=1e18;
		a[i].l=read(),a[i].r=read(),a[i].h=read();
		a[i].idx=i;
	}
	sort(a+1,a+1+n,cmp);
	bool flag=false;
	for(int i=1;i<=n;i++){
		if(a[i].idx==s){
			dp[s][0]=0;
			dp[s][1]=a[i].r-a[i].l;
			flag=true;
		}
		if(!flag){
			continue;
		}
		for(int j=i+1;j<=n;j++){
			if(a[j].l<=a[i].l&&a[i].l<=a[j].r&&a[i].h>a[j].h){
				f[a[j].idx]=min(f[a[j].idx],dp[a[i].idx][0]+a[i].h-a[j].h);
				dp[a[j].idx][0]=min(dp[a[j].idx][0],dp[a[i].idx][0]+a[i].h-a[j].h+a[i].l-a[j].l);
				dp[a[j].idx][1]=min(dp[a[j].idx][1],dp[a[i].idx][0]+a[i].h-a[j].h+a[j].r-a[i].l);
				break;
			}
		}
		for(int j=i+1;j<=n;j++){
			if(a[j].l<=a[i].r&&a[i].r<=a[j].r&&a[i].h>a[j].h){
				f[a[j].idx]=min(f[a[j].idx],dp[a[i].idx][1]+a[i].h-a[j].h);
				dp[a[j].idx][0]=min(dp[a[j].idx][0],dp[a[i].idx][1]+a[i].h-a[j].h+a[i].r-a[j].l);
				dp[a[j].idx][1]=min(dp[a[j].idx][1],dp[a[i].idx][1]+a[i].h-a[j].h+a[j].r-a[i].r);
				break;
			}			
		}
	}
	if(f[t]==1e18){
		cout<<-1;
	}else{
		cout<<f[t];
	}
	return 0;
}
```

---

## 作者：I_am_Lord_Voldemort (赞：2)

题目分析：从 $s$ 到 $t$ 的最少时间，联想到最短距离，所以考虑建图来做。
  
具体思路：对于每一个挡板，左右端点都联通，先加上边。按高度排序后，枚举左右端下方挡板序号。考虑到 $s$ 和 $t$ 之间的挡板，掉到它中间后一定会走向它的端点，因此只用在挡板的端点之间加边就好，再对 $t$ 特判一下。最后跑一遍 Dijkstra 即可。

下面是代码：
 ```
#include<bits/stdc++.h>
using namespace std;
#define Inf 0x7fffffff
const int maxn=5000;
struct node{
	int u,v,w;
}e[maxn];
struct bar{
    int l,r,h;
    bool operator < (const bar & t) const{
        return h<t.h;
    }
    bool operator == (const bar & t) const{
        return l==t.l&&r==t.r&&h==t.h;
    }
}ba[maxn];
struct T{
	int d,u;
	bool operator < (const T & t) const{
		return d>t.d;
	}
};
int n,m,ss,t;
int dis[maxn]={},first[maxn]={},nxt[maxn],xnt=0;
bool vis[maxn]={};
void add(int u,int v,int w){
	e[++xnt].u=u;e[xnt].v=v;e[xnt].w=w;
	nxt[xnt]=first[u];first[u]=xnt;
    //cout<<u<<" "<<v<<" "<<w<<endl;
}
void djst(int s){
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	priority_queue<T>q;
	q.push(T{dis[s],s});
	while(!q.empty()){
		T t=q.top();q.pop();
		int d=t.d,u=t.u;
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=first[u];i;i=nxt[i]){
			int v=e[i].v;
			if(d+e[i].w<dis[v]){
				dis[v]=d+e[i].w;
				q.push(T{dis[v],v});
			}
		}
	}
}
signed main(){
    int n,s,t;
    cin>>n>>s>>t;
    int poss,post;bar ss,tt;
    for(int i=1;i<=n;i++){
        cin>>ba[i].l>>ba[i].r>>ba[i].h;
    }
    ss=ba[s];tt=ba[t];
    if(ss.h<=tt.h){
        cout<<-1;return 0;
    }
    sort(ba+1,ba+n+1);
    for(int i=n;i>=1;i--){
        if(ba[i]==ss) poss=i;
        if(ba[i]==tt) post=i;
    }
    for(int i=post;i<=poss;i++){
        int l=ba[i].l,r=ba[i].r,h=ba[i].h;
        add(2*i-1,2*i,r-l);
        add(2*i,2*i-1,r-l);
        for(int j=i-1;j>=1;j--){
            if(ba[j].h<h){
                int flag=0;
                if(ba[j].l<=(l)&&(l)<=ba[j].r){
                    if(j!=post){
                        add(2*i-1,2*j-1,h-ba[j].h+l-ba[j].l);
                        add(2*i-1,2*j,h-ba[j].h+ba[j].r-l);
                        flag=1;
                    }
                    else{
                        add(2*i-1,2*j-1,h-ba[j].h);
                        flag=1;
                    }
                }
                if(flag) break; 
            }
        }
        for(int j=i-1;j>=1;j--){
            if(ba[j].h<h){
                int flag=0;
                if(ba[j].l<=(r)&&(r)<=ba[j].r){
                    if(j!=post){
                        add(2*i,2*j-1,h-ba[j].h+r-ba[j].l);
                        add(2*i,2*j,h-ba[j].h+ba[j].r-r);
                        flag=1;
                    }
                    else{
                        add(2*i,2*j-1,h-ba[j].h);
                        flag=1;
                    }
                }
                if(flag) break; 
            }
        }
    }
    djst(2*poss-1);
    if(dis[2*post-1]<1000000) cout<<dis[2*post-1];
    else cout<<-1;
}
```

---

## 作者：zhangyaiwei (赞：1)

刚开始看到这题就感觉像最短路题，注意到 $n\le1000$ ，于是一个朴素的想法诞生了。

先 $O(n^2)$ 暴力求出每个挡板从左，从右能到哪个挡板。然后向两个挡板连边。

但这样做有个问题，就是如果从挡板连边的话，你会发现你并不知道刚到达这个挡板的时候在哪里，也就无法求出边权。既然从挡板到端点再到挡板不好走，那不如直接从让一个挡板的端点走到另一个端点。这样就可以确定在挡板上走的时间了（如图）。
![](https://cdn.luogu.com.cn/upload/image_hosting/69nfqh9v.png)

然后还有一些需要注意的，由于小杨在挡板上是可以移动的，所以一个挡板上的两个端点之间也需要连边。还有，由于我们只需要到 $t$ 挡板就好了，所以需要去掉到左右端点的代价，可以考虑将垂直下落的代价和挡板上的水平代价分开存储，最后对于**所有**到达挡板 $t$ 的方案去掉最后的水平代价求一个最小值即可（注意不要只看到达 $t$ 的最短路，只要在 $t$ 之前是最短路的都要看，因为有可能有的路径加上水平代价后很大，但去掉后又很小）。

最后，上代码。
``` cpp
#include<bits/stdc++.h>
#define int long long
#define Lft(x) x*2-1//挡板x的左端点编号
#define Rht(x) x*2//右端点
#define Rec(x) (x+1)/2//端点对应的挡板编号
using namespace std;
int n,s,t,ans=1145141919810,l[1111],r[1111],h[1111],L[2][1111];
bool w[2111];//双倍空间存端点状态
struct K{
	int a,duv,lrv;//duv:除去最后水平代价，lrv：最后的水平距离
	bool operator < (const K &x)const{
		if(duv+lrv==x.duv+x.lrv) return duv>x.duv;
		return duv+lrv>x.duv+x.lrv;
	}
};
vector<K> v[2111];
priority_queue<K> q;
signed main(){
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++){
		cin>>l[i]>>r[i]>>h[i];
	}
  //n^2 找下落位置
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(h[j]<h[i]){
				if(l[j]<=l[i]&&l[i]<=r[j]&&h[j]>h[L[0][i]]){
					L[0][i]=j;
				}
				if(l[j]<=r[i]&&r[i]<=r[j]&&h[j]>h[L[1][i]]){
					L[1][i]=j;
				}
			}
		}
	}
  //连边
	for(int i=1;i<=n;i++){
        v[Lft(i)].push_back({Rht(i),0,r[i]-l[i]});
        v[Rht(i)].push_back({Lft(i),0,r[i]-l[i]});
		if(L[0][i]){
			v[Lft(i)].push_back({Lft(L[0][i]),h[i]-h[L[0][i]],l[i]-l[L[0][i]]});
			v[Lft(i)].push_back({Rht(L[0][i]),h[i]-h[L[0][i]],r[L[0][i]]-l[i]});
		}
		if(L[1][i]){
			v[Rht(i)].push_back({Lft(L[1][i]),h[i]-h[L[1][i]],r[i]-l[L[1][i]]});
			v[Rht(i)].push_back({Rht(L[1][i]),h[i]-h[L[1][i]],r[L[1][i]]-r[i]});
		}
	}
  //求最短路
	q.push({Lft(s),0,0});
	while(!q.empty()){
		int qs=q.top().a,qw=q.top().duv,qk=q.top().lrv;
		q.pop();
       // cout<<(Rec(qs)*2-1==qs?"Left of ":"Right of ")<<Rec(qs)<<" ^V : "<<qw<<" <-> : "<<qk<<endl;
		if(Rec(qs)==t){
			ans=min(ans,qw);
		}
		if(w[qs]) continue;
		w[qs]=1;
		for(int i=0;i<v[qs].size();i++){
			int N=v[qs][i].a;
			if(!w[N]){
				q.push({N,qw+qk+v[qs][i].duv,v[qs][i].lrv});
			}
		}
	}
	cout<<(ans==1145141919810?-1:ans);
}
```

---


# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# 题解

## 作者：StudyingFather (赞：225)

在讨论本题的做法前，有必要先分析一下问题的一些特殊性质。

题解区部分题解在性质分析等方面存在一定欠缺，一定程度上可能会影响读者理解做法。

## 分析

先给出一些记号：

- $P(s,t)$：代表树上两点 $s,t$ 之间的路径（的长度）。
- $D(s,t)$：代表树上两点 $s,t$ 之间的路径（的长度），且这条路径是树的最长简单路径（即树的直径）。

另外，为了方便理解，并使得表意清晰，原题中提到的「树的核」均称为「路径」。

以下引理和定理基于**图上所有边权均为正**这一前提推出。

**引理 1**：对于一棵所有边权均为正的树，如果其存在多条直径，则树上必存在一点 $p$，使得所有直径均经过该点（简单来说，所有直径必交于至少一点）。

**证明**：用反证法。

如果存在两条直径 $D(s,t),D(s^\prime,t^\prime)$ 不相交，则 $\exists a \in D(s,t), b \in D(s^\prime,t^\prime)$，且 $\forall p \in P(a,b) - \{a, b\}$，$p \notin D(s, t)$，$p \notin D(s^\prime, t^\prime)$（即，$P(a,b)$ 除了 $a,b$ 两点之外，其他点均不在这两条直径上）。设 $d_1 = \max \{P(s,a), P(a,t)\}$，$d_2 = \max \{P(s^\prime,b), P(b,t^\prime)\}$，易知 $d_1,d_2 \geq \dfrac{1}{2}D(s, t)$，于是 $d_1 + d_2 + P(a,b) > D(s,t)$，即 $d_1,d_2,P(a,b)$ 这三段拼接成了一条比 $D(s,t), D(s^\prime,t^\prime)$ 这两条直径更长的简单路径，出现了矛盾。$\square$

（啥，你说可能有三条直径两两相交，但不交于一点的情况？画图后马上就发现有环了。）

**定理 1**：对于一棵所有边权均为正的树，如果其存在多条直径，则各直径的中点（不一定恰好是某个节点，可能在某条边的内部）是唯一的。

**证明**：还是用反证法。

设树的两条直径分别为 $D(s, t), D(s^\prime,t^\prime)$，它们的中点分别为 $m, m^\prime$，且两个中点不重合。可以推出，$m^\prime \in D(s, t)$（否则由 **引理 1**，两直径必定存在一个交点 $p$。设 $d_1 = \max \{P(s,p), P(p,t)\}$，$d_2 = \max \{P(s^\prime,p), P(p,t^\prime)\}$，则 $d_1, d_2 > \dfrac{1}{2}D(s, t)$，$d_1 + d_2 > D(s,t)$，与 $D(s,t)$ 是直径矛盾）。

于是实际情况大致如下图所示（略去了树上的其他不必要点，不妨设 $m^\prime$ 位于更靠近 $t$ 的一侧）。

![](https://cdn.luogu.com.cn/upload/image_hosting/oaiyl6ql.png)

则 $P(s,s^\prime) = P(s, m^\prime) + P(m^\prime + s^\prime) > \dfrac{1}{2}D(s, t) + \dfrac{1}{2}D(s^\prime, t^\prime) = D(s,t)$，与 $D(s,t)$ 是直径矛盾。$\square$

**引理 2.1**：若两条直径有重叠的部分，则于重叠部分同一端点引出的两条直径的非重叠的部分的长度相等。

**证明**：设两条直径分别为 $D(a, c)$，$D(b, d)$，重叠部分为 $P(s,t)$，如下图所示（$P(s,t)$ 可能是一个点，即 $s = t$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/f587t21u.png)

如果 $P(a,s) \neq P(b,s)$（此时容易得到 $P(c,t) \neq P(d,t)$），则取 $P(a, s)$ 和 $P(b,s)$ 中较长的一条（长度设为 $d_1$），$P(c, t)$ 和 $P(d,t)$ 中较长的一条（长度设为 $d_2$），则由于 $d_1$ 和 $d_2$ 不在同一条直径上（否则推出 $D(a,c) > D(b,d)$，出现矛盾）则 $d_1 + P(s,t) + d_2 > D(a,c)$，出现了矛盾。$\square$

**引理 2.2**：若路径存在不位于直径上的部分，这条路径对应的偏心距一定不会比全部位于直径上的路径的偏心距的**最小值**更小。

**证明**：原命题等价于，对于任意一条不完全位于（或者完全不位于）直径上的路径 $F$，都存在一条完全位于直径上的路径 $F^\prime$，使得 $\operatorname{ECC}(F) \geq \operatorname{ECC}(F^\prime)$。下面是一个构造性的证明。

简单来说，我们采用如下方法构造：对于一条不完全位于（或者完全不位于）直径上的路径 $F$，找到该路径与直径的一个交点 $m$（必要时通过延长 $F$ 来找到交点），然后再证明 $P(m,m)$ 这条路径至少不会比 $F$ 更劣。

沿用 **引理 2.1** 中出现的记号，构建下图（树上的部分节点略去）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9iwxoi6p.png)

注：

1. 加粗的点一定位于树的某条直径上，未加粗的点一定不位于树的任意一条直径上，即 $P(p,v)$ 这条路径不是树的直径。
2. 其实原图有多少条直径对本引理证明没有影响，~~图上保留多条直径只是忘记删了~~。

现在开始讨论。

1. 考虑 $P(p,u)$ 这条路径。距离 $P(p,u)$ 最远的点是哪个点，是 $v$ 吗？因为，$P(b,m) + P(m,v) < P(b,m) + P(m,d) = D(b,d)$，即 $P(m,v) < P(m,d)$，因此距离 $u$ 最远的点，是直径的端点，不是 $v$ 这样一个不在直径上的点。
2. 现在考虑 $P(u,v)$ 这条路径。距离 $P(u,v)$ 最远的点是哪个点，是 $p$ 吗？如果 $P(p,u) \geq P(a,m)$（其余情况同理），则 $D(a,c) = P(a,m) + P(m,c) \leq P(p,u) + P(m,c) < P(p,u) + P(u,m) + P(m,c) = P(p,c)$，与 $D(a,c)$ 是直径矛盾。因此距离 $P(u,v)$ 最远的点，仍然是直径的端点。
3. 最后考虑 $P(m,m)$ 这条路径。距离 $P(m,m)$ 最远的点是哪个点，是 $p$ 或者 $v$ 吗？注意到 $p,v$ 均不在直径上，于是 $P(b,m) + P(m,p) < P(b,m) + P(m,d) = D(b,d)$，即 $P(m,p) < P(m,d)$（这里只举了 $p$ 的情况，$v$ 同理），因此距离 $P(m,m)$ 最远的点，仍然是直径的端点。

（由于直径是树上最长简单路径这一性质，距离上述三条路径最远的点一定不会在从直径上 $m$ 之外的其他点引出的支链上取得，因此这些支链没有画出。）

对于 2 和 3 两种情况，偏心距显然为 $\max\{P(a,m), P(m,c)\}$，对于 1 这种情况，偏心距为 $\max\{P(a,m), P(m,c)\} + P(u,m)$。综上，1 和 2 这两种路径不完全位于（或者完全不位于）直径上的方案，不会比 3 这种完全位于直径上的方案更优。$\square$

因此，虽然原题限制路径只能在直径上取得，但可以忽略这一限制考虑所有满足长度限制的路径，而求得的最小偏心距不变。

**定理 2**：设在所有满足长度限制的路径中，取得最小偏心距的路径得到的偏心距为 $\textrm{minBCC}$，则对于任意一条直径，都存在一条长度不超过 $s$ 的路径 $F$，使得 $\operatorname{BCC}(F) = \mathrm{minBCC}$。

**证明**：

沿用 **引理 2.1** 中出现的记号，构建下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mjb8pfen.png)

注：加粗的点一定位于树的某条直径上，未加粗的点一定不位于树的任意一条直径上，即 $P(p,z)$ 这条路径不是树的直径。

如果我们取 $P(c,y)$ 这条路径，距离该路径最远的点，容易发现不是 $p$。可能是 $z$ 吗？定理 1 告诉我们，$P(t,z) < \dfrac{1}{2}D(a,c)$，从而得到 $P(x,z) < \dfrac{1}{2}D(a,c)$。而 $P(a,y) \geq \dfrac{1}{2} D(a,c)$，因此排除 $z$ 是最远点的可能性。

（$d$ 是最远点时，$P(c,d)$ 也是树的直径，为了不影响 $P(s,t)$ 是直径重合部分这一前提，这里假定 $P(c,d)$ 不是树的直径。）

综上，这条路径的偏心距 $\operatorname{ECC}(P(c,y)) = P(a,y)$。简单比较后容易发现，$P(t,t)$ 这条路径偏心距（容易看出是 $P(a,t)$）一定会更小。

由此得出，当所选路径不包含直径的重合部分时，这条路径一定不是最优路径。

现在考虑所选路径包含直径重合部分的情况。以 $P(s,t)$ 为例，这时候的偏心距 $\operatorname{ECC}(P(s,t)) = \max\{P(m,p), P(s,a), P(t,c)\}$，如果将 $P(s,t)$ 延伸成 $P(s,y)$ 或者 $P(s,q)$，偏心距的表达式没有发生变化（仍然存在 $P(t,c)$ 项）。因此，在所选路径包含直径重合部分的时候，直径的选择对答案没有影响。$\square$

由 **定理 2**，我们不用在树上的每条直径上都找到取得最小偏心距的路径，只需要在其中一条直径上找即可。

## 解法

### 解法一：枚举

先求出树的任意一条直径，然后在直径上枚举路径的端点。 

（由 **引理 2.2**，也可以不用求出树的直径，直接枚举树上的所有路径。）

接下来 DFS 遍历整棵树，按定义求出其他点到路径的距离，从而得到该路径的偏心距。

枚举的时间复杂度 $O(n^2)$，遍历的时间复杂度为 $O(n)$，总时间复杂度为 $O(n^3)$，已经可以通过本题。

### 解法二：双指针优化枚举

注意到，在固定路径的一端 $s$ 的前提下，随着路径长度的增加，偏心距不会变大。

于是可以考虑枚举路径的一端 $s$，用双指针的技巧找到距离 $s$ 最远，且不超过路径长度上限的点 $t$，从而减少候选的最优路径数量。

枚举的过程时间复杂度降到了 $O(n)$，总时间复杂度为 $O(n^2)$。

### 解法三：二分

考虑二分偏心距，将最优化问题变成存在性问题。

定义一端是直径上的点，且只有该点在直径上，其他点都不在直径上的一条链为直径的**支链**。设 $d_i$ 为从 $i$ 点引出的最长支链的长度。

分析偏心距的可能情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/pzx0c11u.png)

以路径 $P(2,4)$ 为例，距离该路径最远的点，可能是 $1$，$5$，$p$。由于 $P(1,5)$ 是直径，$q$ 到 $P(2,4)$ 的距离一定不会比 $1$ 到 $P(2,4)$ 更远，因此在计算偏心距的时候不用考虑 $q$ 点。$1,5$ 是直径的端点，而 $p$ 是路径上的点（除了路径端点）引出的支链的最远点。

归纳一下，设直径上的点分别为 $a_1,a_2,\ldots,a_k$，取的路径为 $P(a_i,a_j)$（$i \leq j$），则所求的偏心距为：$\max \{\max_{i < p < j} d_{a_p}, P(a_1,a_i), P(a_j, a_k)\}$。

$d_i$ 可以在求出直径后通过一次 DFS 求出。在二分偏心距 $e$ 后，先找到直径的两端点 $i$，$j$，使得 $P(a_1,a_i), P(a_j,a_k) \leq e$，再判断路径长度是否超过限制，以及 $\max_{i < p < j} d_{a_p} < e$ 是否满足。如果以上条件均满足，则找到一条可行的路径。

时间复杂度 $O(n \log \sum w)$。可以通过 [P2491](https://www.luogu.com.cn/problem/P2491)。

### 解法四：双指针+前缀和

考虑将解法二的双指针引入解法三。

解法二低效的原因主要在于每次双指针求出最优区间后都要 DFS 一遍，在解法三分析了偏心距的组成后，我们发现没有必要再进行重复的 DFS，只需要在双指针过程中，动态更新 $\max_{i < p < j} d_{a_p}, P(a_1,a_i), P(a_j, a_k)$ 即可。

第一项区间最大值是经典的滑动窗口，可以用单调队列计算，其余两项前缀和即可。

时间复杂度 $O(n)$。

到这里就完了吗？时间复杂度确实到达了下限（输入就需要同样的时间复杂度），但是代码实现还能更简单。

注意到一个性质：$\forall l \in [1,i]$，$d_{a_l} \leq P(a_1, a_i)$，同样地，$\forall l \in [j,k]$，$d_{a_l} \leq P(a_j, a_k)$。

**证明**：由直径是树上最长简单路径的性质，可以得到 $d_{a_j} + P(a_j, a_i) \leq P(a_1,a_i)$，再结合 $P(a_j, a_i) > 0$，从而原命题得证。$\square$

于是我们将偏心距的表达式替换为 $\max \{\max_{1 \leq p \leq k} d_{a_p}, P(a_1,a_i), P(a_j, a_k)\}$，这一过程中我们加入的项都是不大于 $P(a_1,a_i), P(a_j, a_k)$ 的项，在取 $\max$ 后不会影响结果。

$\max_{1 \leq p \leq k} d_{a_p}$ 是定值，因此不必再使用单调队列！实现难度也相应简单了不少。

## 参考实现

把四个解法的代码都贴了出来，不同解法之间使用 `namespace` 进行隔离，可以通过对比阅读以观察优化点。

```cpp
// Problem: P1099 [NOIP2007 提高组] 树网的核
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1099
// Memory Limit: 128 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <algorithm>
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
struct edge {
  int v, w;
  edge(int v = 0, int w = 0) {
    this->v = v;
    this->w = w;
  }
};
const int maxn = 300000 + 5;
vector<edge> e[maxn];
int dep[maxn], f[maxn], c;
int dia[maxn], cnt, pres[maxn], posts[maxn];
bool vis[maxn];
int n, s;
void dfs(int u, int fa) {
  f[u] = fa;
  for (auto ed : e[u]) {
    if (ed.v == fa || vis[ed.v]) continue;
    dep[ed.v] = dep[u] + ed.w;
    if (dep[ed.v] > dep[c]) c = ed.v;
    dfs(ed.v, u);
  }
}
void get_diameter() {
  dfs(1, 0);
  dep[c] = 0;
  dfs(c, 0);
  for (int u = c; u; u = f[u]) {
    dia[++cnt] = u;
    pres[cnt] = dep[u];
  }
  reverse(dia + 1, dia + cnt + 1);
  reverse(pres + 1, pres + cnt + 1);
  for (int i = cnt; i > 0; i--) posts[i] = pres[cnt] - pres[i];
}
namespace sub1 {
void solve() {
  int minecc = 1 << 30;
  for (int i = 1; i <= cnt; i++)
    for (int j = i; j <= cnt; j++) {
      if (pres[j] - pres[i] <= s) {
        memset(vis, 0, sizeof(vis));
        for (int k = i; k <= j; k++) vis[dia[k]] = true;
        int ecc = 0;
        for (int k = i; k <= j; k++) {
          dep[dia[k]] = 0, c = 0;
          dfs(dia[k], 0);
          ecc = max(ecc, dep[c]);
        }
        minecc = min(minecc, ecc);
      }
    }
  cout << minecc << endl;
}
}  // namespace sub1
namespace sub2 {
void solve() {
  int minecc = 1 << 30;
  int l = 1, r = 1;
  for (; l <= cnt; l++) {
    while (r <= cnt && pres[r + 1] - pres[l] <= s) r++;
    memset(vis, 0, sizeof(vis));
    for (int k = l; k <= r; k++) vis[dia[k]] = 1;
    int ecc = 0;
    for (int k = l; k <= r; k++) {
      dep[dia[k]] = 0, c = 0;
      dfs(dia[k], 0);
      ecc = max(ecc, dep[c]);
    }
    minecc = min(minecc, ecc);
  }
  cout << minecc << endl;
}
}  // namespace sub2
namespace sub3 {
int maxd[maxn];
bool check(int ecc) {
  int l = 1, r = cnt;
  while (l < cnt && pres[l + 1] <= ecc) l++;
  while (r > l && posts[r - 1] <= ecc) r--;
  if (pres[r] - pres[l] > s) return false;
  int d = 0;
  for (int i = l + 1; i < r; i++) d = max(d, maxd[i]);
  return d <= ecc;
}
void solve() {
  for (int i = 1; i <= cnt; i++) vis[dia[i]] = true;
  for (int i = 1; i <= cnt; i++) {
    dep[dia[i]] = 0, c = 0;
    dfs(dia[i], 0);
    maxd[i] = dep[c];
  }
  int l = 0, r = 1 << 30, ans = 0;
  while (l <= r) {
    int mid = (l + r) >> 1;
    if (check(mid))
      ans = mid, r = mid - 1;
    else
      l = mid + 1;
  }
  cout << ans << endl;
}
}  // namespace sub3
namespace sub4 {
void solve() {
  for (int i = 1; i <= cnt; i++) vis[dia[i]] = true;
  int maxd = 0;
  for (int i = 1; i <= cnt; i++) {
    dep[dia[i]] = 0, c = 0;
    dfs(dia[i], 0);
    maxd = max(dep[c], maxd);
  }
  int l = 1, r = 1;
  int minecc = 1 << 30;
  for (; l <= cnt; l++) {
    while (r <= cnt && pres[r + 1] - pres[l] <= s) r++;
    minecc = min(max(maxd, max(pres[l], posts[r])), minecc);
  }
  cout << minecc << endl;
}
}  // namespace sub4
int main() {
  ios::sync_with_stdio(false);
  cin >> n >> s;
  for (int i = 1; i < n; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    e[u].emplace_back(v, w);
    e[v].emplace_back(u, w);
  }
  get_diameter();
  sub4::solve();
  return 0;
}
```

---

## 作者：Mosklia (赞：193)

发布一篇时间复杂度为$O(n)$的题解
***
# $\text{Prev 1}$：读懂题意  
什么树网啊，明明就是普通的**无根树**么……  
一直到偏心距（$\text{E CCF}$（为什么去不掉这个空格？））以前相信大家都能看懂……  
然后题目要求**直径**上的一段路径，使其在**长度**$\leq s$的前提下偏心距最小。  
把题目从$\text{CCF}$语言翻译成现代汉语，就是：  

> 给定一棵带边权无根树，在其直径上求出一段长度不超过$s$的路径$F$，使得离路径距离最远的点到路径的距离最短。  

# $\text{Prev 2}$：直径的定义与性质及其引发的思考  
首先，明白一件事：对于**直径上任意一个点**，到它本身的距离最远的点一定是**直径的某个端点**。理由很简单：如果存在某个点$P$使得直径上的点$A$到其的距离超过点$A$到直径的两端距离的最大值，那么我们可以将直径的一个端点与$A$分离开，并且接上$AP$得到一条比直径更长的路径。但是根据定义，直径应该是整棵树上的最长路径，因此，之前的那条直径是一条*假的直径*。换句话说，假设不成立。  
然后考虑对于直径上的一条路径$F$，有哪些因素会对其偏心距造成影响。    
为了方便描述，
```cpp
using 直径::路径;
```  
首先，肯定会有路径两端点分别到直径两端点对答案造成影响。并且设路径端点、直径端点分别为$A_1,A_2,P_1,P_2$，如果对答案造成影响的是$A_1,P_1$或者$A_2,P_2$，那么$A_1P_1$路径$F$的交点只有$A_1$，$A_2P_2$与路径$F$的交点只有$A_2$。  
那么，路径$F$的长度越长答案一定越优吗？  
~~显然~~不是这样的。  
因为刚刚只考虑了$A_1,A_2$对答案的贡献。但是路径上的其它点对答案其实也有贡献。比如说对于下面的这幅图：  
![](https://cdn.luogu.com.cn/upload/pic/32613.png)  
当$s=18$时答案应该为$3$，但是如果只考虑$A_1,A_2$的贡献，计算结果则会变成$0$。  
从上图不难看出，路径上其它点$Q$对答案的贡献为：**不经过路径上任何其它点所能到达的最远点的距离**。~~不难~~发现实际计算答案时即使把路径端点的这种“贡献”计入总贡献也不会产生影响（因为端点的第一种贡献更大，“掩盖住了”这种贡献）。  
那么如果一棵树有多条直径怎么办呢？没关系，**任选一条**即可。首先，两条直径不可能不相交。把相交的那一部分看成一个点，剩下的直径部分就会**关于这个点对称**。而如果选择的路径包含了分叉点，其偏心距就是恒定的（这个分叉点到直径末端的距离），所以可以任选一条直径求解。  
# $\text{Main}$：解题过程  
本题可以使用邻接矩阵存图，但是为了修改方便，也为了降低空间间复杂度（[$\text{BZOJ}$上这道题的数据规模被增强到了$n \leq 5 \times 10^5$](https://www.lydsy.com/JudgeOnline/problem.php?id=1999)）此处仍然使用邻接表存图。  
```cpp
struct Point { //点
	int dist = 0, head = 0;
	int fa = 0, fa_dist = 0; //以直径一个端点为根，父节点编号及到其距离
	int cur_dist = 0; //后面用来降低时间复杂度
	bool vis = false;
} pt[305];
struct Path { //边
	int end = 0, weight = 0;
	int next = 0;

	Path(int __end = 0, int __cost = 0, int __next = 0) :
		end(__end), weight(__cost), next(__next) {}
} ph[605];
```
```cpp
void set_path(int u, int v, int w) {
	ph[++ptr] = Path(v, w, pt[u].head), pt[u].head = ptr;
	ph[++ptr] = Path(u, w, pt[v].head), pt[v].head = ptr;
}//这个连边函数的写法来自panda_2134大爷
```
接下来是两次$\text{DFS}$求出直径。  
```cpp
void dfs1(int p) { //p表示正在访问哪个点
	if(pt[p].vis) return;
	pt[p].vis = true; //做好标记
	for(int i = pt[p].head; i; i = ph[i].next) {
		int s = ph[i].end;
		if(pt[s].vis) continue;
		pt[s].fa = p,
		pt[s].fa_dist = ph[i].weight,
		pt[s].dist = pt[p].dist + ph[i].weight;
		dfs1(s); //注意要在访问子节点前维护好子节点信息！
	}
}
```
（这是主函数中对应部分）  
```cpp
dfs1(1);
int rt, tempx = 0; //tempx保存已经找到的最远点
for(int i = 1; i <= n; ++i) {
	pt[i].vis = false;
	if(pt[i].dist > pt[tempx].dist)
		tempx = i;
}
rt = tempx, tempx = 0;
for(int i = 1; i <= n; ++i)
	pt[i].dist = pt[i].fa =
	pt[i].fa_dist = 0;

dfs1(rt);
for(int i = 1; i <= n; ++i) {
	pt[i].vis = false;
	if(pt[i].dist > pt[tempx].dist)
		tempx = i;
}
int dist1 = 0, dist2 = 0, tot;
while(pt[tempx].fa) //将直径按照从叶子到根的顺序打印到数组del中
	dist2 += pt[tempx].fa_dist,
	del[++m] = tempx,
	pt[tempx].vis = true,
	tempx = pt[tempx].fa;
pt[rt].vis = true, del[++m] = tempx;
tot = dist2;
```  
然后预处理出每个点**以第二种方式产生的贡献值**（通过一次$DFS$，主函数中的调用过程~~比较简单，~~留给读者自己思考）  
```cpp
int dfs2(int p) {
	pt[p].vis = true;
	int temp = 0;
	for(int i = pt[p].head; i; i = ph[i].next) {
		int s = ph[i].end;
		if(pt[s].vis) continue;
		pt[s].dist = pt[p].dist + ph[i].weight;
		dfs2(s);
		temp = std::max(temp, pt[s].dist);
	}
	return temp;
} 
```
显然，上面的所有过程都是$O(n)$的。那么为什么会有其它的$O(n^2)$的写法呢？  
（**个人认为本题的主要时间复杂度来自以下过程：**）  
接着是枚举所选路径的两个端点并且计算答案。这个过程的时间复杂道是$O(n^2)$，所以，算法总时间复杂度为$O(n^2)$。对于官方数据$n \leq 300$轻松通过。  

## 完结撒花？

可是最后面一部分代码呢？不存在的！**本题解是$O(n)$的题解**，怎么可能有$O(n^2)$的代码？  
仔细看一下写出的$O(n^2)$的代码（没写完的请自觉写完）。这不就是一个线性的动态规划嘛！  
把记录下来的直径序列看成区间，本题变成了**求一个长度不超过$s$的区间，使得其中所有元素的贡献值的最大值最小**。  
这种动态规划想到什么？没错，**单调队列**！  
用单调队列维护一下区间元素的第二种贡献值，第一种贡献可以在左/右端点移动的同时计算。具体写法见以下代码。  
```cpp
std::deque<int> q; //需要#include <deque>（<queue>行）
int ans = 2147483647; //正无穷
for(int i = 1, j = 1; i <= m; dist2 -= pt[del[i]].fa_dist, ++i) {
//dist1是到起始端点的距离，初始化为0
//dist2是到终止端点的距离，初始化为直径长度
	pt[del[i]].cur_dist = dist2; //cur_dist成员表示这个点离终点的距离（没写好，dist最后用来保存第二种贡献值了）
	while(!q.empty() && pt[q.front()].cur_dist - s > pt[del[i]].cur_dist)
		q.pop_front();
	while(j < i && tot - dist1 - dist2 > s)
		dist1 += pt[del[j++]].fa_dist;
	while(!q.empty() && pt[q.back()].dist < pt[del[i]].dist)
		q.pop_back();
	q.push_back(del[i]);
	int temp = std::max(dist1, dist2);
	temp = std::max(temp, pt[q.front()].dist);
	ans = std::min(temp, ans); //状态转移
}
```  
# $\text{End}$：总结
	1、我是真的没看出来那个“中心”的概念有什么用……
    2、即使原始的数据范围很水，也要尽力优化。AC不是我们的终极目标，我们的终极目标是获得经验。

以上就是我要说的全部内容。由于水平所限，如果大家有什么不满意的地方或是什么建议想要提出，欢迎随时私信我！

---

## 作者：天泽龟 (赞：60)

虽然本题题解已有很多，但基本上是$O(N^3)$的暴力或$O(N)$的递推做法，而仍有一种$O(N·logN)$的做法没人提及，但仍可通过$Vijos$上$N=400000$的大数据。

### 没错，他就是二分。

本文将从**二分的正确性，二分的具体实现过程，二分边界**等多个方面详细阐述这种解法，希望您在观看过后也能对**二分答案**有一个更为详细的理解。

顺便，$bzoj$的加强版挂了，我把数据贴到了洛谷可供给大家验题，[戳这。](https://www.luogu.org/problem/U89620)

## $1. ~$二分的正确性/单调性的证明

众所周知，一道题如果能通过二分求解，那么他一定具有**单调性**。

对于本题而言，如果我们对偏心距进行二分答案，在$check$函数的变化，那么很显然的是，当你设定的偏心距越大，可满足的核就会越向**树的中心**集中，$s$自然也就越小了，所以这是满足单调性的。

然而又由于涉及到边界问题，导致其**并非严格单调**，关于这个细节部分等到第三节再来细谈。

## $2.~$二分的具体实现过程/$check$函数

既然我们已经确定了偏心距的范围，那么问题就转化成 **“对于一条直径是否存在一个核，长度小于$s$且偏心距不超过定值$mid$？”**

那我们知道**对于树上的任意点，他到其他点的最大距离即为他到某直径端点的距离**。从而我们可以推断出，某一核的偏心距实质上也就是 **核的端点到直径端点的距离最值**。如果我们设直径两端点为$A,B$，核$F$的两端点为$p,q$，那么以上结论就可以表述为：
$$ECC(F)=\max(dis[p,A],dis[q,B])$$
对于上式，$p,q$是我们要求的**未知范围**，而$A,B$是我们**已知的**直径端点，易想到去通过$A,B$去反推$p,q$。

具体的说，我们可以 ~~以A,B为圆心，以mid为半径画圆~~ 以$A,B$端点分别**向直径内部递推，找到与端点距离不超过$mid$的最远节点，** 此时的两点即为所求的$p,q$。

最终我们判断$p,q$两点距离是否小于$s$，作为我们二分答案的判断标志。**注意，这里不用考虑绝对值！！** 如果距离为负，标志着两点范围已经互相越过去到达了对面，那么这时候在范围内随便取一个点都应该是满足的。

对于具体的操作来说，可以先以直径某一端点（如$A$）为根节点，以此不断向下递归同时记录已走的距离，找到最远满足条件的节点$p$；对于另一端$B$可以直接往上不断跳，找到最远满足节点$q$。

放上$check$的部分代码：
```cpp
ll drop(ll u,ll fa,ll x)  //从高往下掉
{
	for (ll i=fir[u];i;i=e[i].nex)
	if (v[e[i].u]) {
		if (e[i].u==fa) continue;
		l1+=e[i].w; if (l1>x) return u;
		else return drop(e[i].u,u,x);
	}
}

ll up(ll u,ll x)  //从低往上爬
{
	while (u!=A&&l2+w[u]<=x) l2+=w[u],u=f[u][0]; 
	return u;
}

bool check(ll x)
{
	l1=l2=0; p=drop(A,0,x); q=up(B,x); 
	return (d[q]-d[p]<=s);
}

```

算上主函数里的二分，应该是$O(N·logN)$的时间复杂度。

## $3.~$二分的边界判断

所谓二分边界，就是指放在主程序中的$l,r$。普遍的来说，二分答案是可以从$0$取到$INTMAX$的，但对于本题，情况发生了改变。

我们不妨从一个例子引入：

	6 6 
	1 2 5 
	2 3 3 
	3 4 3 
	4 5 5 
	3 6 6 
    错解：5  正解：6
    
~~恩？？为什么会这样呢？~~ 我们来看一下这棵树长什么样：
![](https://cdn.luogu.com.cn/upload/image_hosting/c7ljywx4.png)

当我们取${2,3,4}$作为核的点集时，按上面的做法，据直径端点的距离应为$5$，但很显然答案应该是由$6$号节点造成的$6$！

相信你肯定恍然大悟了：**我们全程没有考虑支链对答案的影响！！**

如果放在考场上，相信如果换做我的一位朋友，他一定会心态崩溃，疯狂怀疑二分的正解性，开始胡乱打暴力骗分，最后惨遭爆炸 ~~（你说的这个朋友到底是不是你自己）（这题好像骗分就能AC）~~。 但是在平常做题，有较多时间的情况下，我们不妨详细探讨一下这个问题。

---

1. 很明显的是，在众多支链中，仅会有**最长支链**对答案造成影响（由偏心距的定义可推出）。当**核的左右两端点 到直径端点的距离**比**最长支链到核的距离**短的时候，偏心距就不受直径的影响了。

由第一章的证明，在达到边界前仍是满足单调性的，于是我们就大胆猜想：**二分边界的上界是树的直径，下界就是最长支链到直径的距离！** 

我们对其证明：

- 上界应该很好理解，当你假定$A$这个端点为树的核，那么他的偏心距显然就是树的直径$D$了。

- 下界我们想要证明的是，会不会出现最长支链到核的距离，小于最长支链到直径距离的情况。

由定义可知，核是直径的一段路径，设最长支链与该直径交于$F$点，最长支链的叶节点为$C$，如果$F\in \text{核的点集}$，那么偏心距必然$\geq FC$。

如果$f\notin \text{核的点集}$，那么设核到F的距离为$d$，由于支链必然小于到直径端点$A,B$的距离，则亦满足：$d+FB\geq d+FC$，，取等条件是$C$是另一直径的端点。上式表明若核不包含$F$，偏心距仍在直径端点处取得，最长支链无贡献。

形象地说，如果以$A$为端点找核的话，偏心距应该满足这么一个样子：
![](https://cdn.luogu.com.cn/upload/image_hosting/lhv7k44i.png)

$FC$即为直径的最长支链，所以单调性也该限制于此。

---

2. 现在我们来想想如何求最长支链。

我们不妨用暴力的思想，考虑每一个不在直径上的点，用$LCA$求出与直径的交点$F$，然后再利用简单的树上两点公式算出最大支链即可。

枚举每个点是$O(N)$的，算LCA是$O(logN)$的，合起来是$O(N·logN)$，依然是在时限内的。

至此，我们算出了二分的下界，整篇题解就结束了。

## $4.$日 后谈
从写这道题，到写完这篇题解，共花了我7个小时（下午4时~晚上11时），主要是期间有很多钻牛角尖的地方，这告诉我们没事千万别死磕题，智商会下降的。

期间一直在想能不能通过类比树的重求出树的中心，然后类似洪水填充向直径扩散求最小偏心距，最终码量有点大，没能实现，期望有后人能帮我验证这一想法可行性。

最后的最后，还是上我丑陋的代码：
```cpp
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>
#define mp make_pair
#define pr pair<int,int>
#define maxn 500010
#define ll long long
using namespace std;
//1. 搞出一条直径O(N)，可证明上面必有最优核。
//2. 对于不在直径AB的点， 算LCA，比较与直径关系求最长支链 
//3. 二分答案，A,B两端点以mid为半径画圆，标记核范围p,q
//4. 判断p,q距离是否小于s， 

struct ed{
	ll u,nex,w;
}e[maxn*2];
ll n,s,st,fir[maxn];
ll ans,A,B,D,l,r,d[maxn];//树的重心D信息
ll f[maxn][21],dd[maxn],v[maxn],w[maxn],F,minn;//树的中心F信息
ll p,q,l1,l2;

void add(ll x,ll y,ll w)
{
	e[++st].u=y; e[st].nex=fir[x]; e[fir[x]=st].w=w;
	e[++st].u=x; e[st].nex=fir[y]; e[fir[y]=st].w=w;
}

void dfs(ll u,ll fa,ll w)
{
	d[u]=d[fa]+w; if (d[u]>ans) ans=d[u],l=u;
	for (ll i=fir[u],ax=0;i;i=e[i].nex)
	{
		ll v=e[i].u,w=e[i].w;
		if (v==fa) continue;  dfs(v,u,w);
	}
}

void dfsl(ll u,ll fa)
{
	f[u][0]=fa; dd[u]=dd[fa]+1; 
	for (ll i=1;i<=20;i++) f[u][i]=f[f[u][i-1]][i-1];
	for (ll i=fir[u];i;i=e[i].nex) if (e[i].u!=fa) dfsl(e[i].u,u),w[e[i].u]=e[i].w;
}

void Fdis(ll u) { while (u) v[u]=1,u=f[u][0]; }  //标记直径

ll lca(ll x,ll y)
{
	if (dd[x]>dd[y]) swap(x,y);
	for (ll i=20;i>=0;i--)
		if (dd[y]-(1<<i)>=dd[x]) y=f[y][i];
	if (x==y) return x;
	for (ll i=20;i>=0;i--)
		if (f[y][i]!=f[x][i]) y=f[y][i],x=f[x][i];
	return f[x][0];
}

ll dismin()  //找最大支链 
{
	dfsl(A,0); Fdis(B); 
	for (ll i=1;i<=n;i++)
	if (!v[i])
	{
		ll L=lca(i,B); 
		minn=max(minn,d[i]-d[L]);
	}
	return minn;
}

ll drop(ll u,ll fa,ll x)
{
	for (ll i=fir[u];i;i=e[i].nex)
	if (v[e[i].u]) {
		if (e[i].u==fa) continue;
		l1+=e[i].w; if (l1>x) return u;
		else return drop(e[i].u,u,x);
	}
}



ll up(ll u,ll x)
{
	while (u!=A&&l2+w[u]<=x) l2+=w[u],u=f[u][0]; 
	return u;
}

bool check(ll x)
{
	l1=l2=0; p=drop(A,0,x); q=up(B,x); //极短的核心内容
	return (d[q]-d[p]<=s);
}

int main()
{
	scanf("%lld%lld",&n,&s);
	for (ll i=1,x,y,w;i<n;i++)
	scanf("%lld%lld%lld",&x,&y,&w),add(x,y,w);
	dfs(1,0,0); ans=0; r=l; dfs(l,0,0); 
	A=r; B=l; D=ans;//1.
	l=dismin(); r=D; //2. l即为最大支链长
	while (l<r)
	{
		ll mid=(l+r)/2; 
		if (check(mid)) r=mid; else l=mid+1;
	}
	printf("%lld\n",l);
} 

```

写这东西真心累，~~字数我觉得都能上洛谷日报~~。

---

## 作者：qhr2023 (赞：4)

## solution

题面写得很晦涩，就是给定一个无根树，找任意直径上一条长度不超过 $s$ 的路径，使图上最远的点到这条路径的距离最小。

这里不需要找直径，直接枚举路径即可，若路径存在不位于直径上的部分，这条路径对应的偏心距一定不优，第一篇题解有证明。

先求出图上任意两点的距离，这里用了 Floyd，然后枚举路径 $i$ 到 $j$，对于每对 $(i, j)$，再枚举结点 $k$ 找偏心距。考虑求偏心距。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)

偏心距的重点在求点到路径的距离。拿样例举例，此时的 $i$ 和 $j$ 分别是 $D$ 和 $G$，枚举 $k$ 时枚举到了 $B$，此时 $B$ 到这条路径的距离是路径 ```BF``` 的长度，而 $B$ 到 $D$ 的路径 ```BFED```，加上 $B$ 到 $G$ 的路径 ```BFG```，再减去 $D$ 到 $G$ 的路径 ```GFED``` 正好是 $2$ 个 ```BF```，所以 $B$ 到路径两端点的距离和减去路径长度即 $B$ 到路径距离的二倍。

设 $f_{i, j}$ 表示 $i$ 到 $j$ 的距离，路径 $(i, j)$ 对应的偏心距就是 $\frac{f_{i, k}+f_{j, k}-f{i, j}}{2}$ 的最大值，答案就是每条路径对应偏心距的最小值。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, s, f[305][305], ans=1e9;
int main () {
	cin >> n >> s;
	memset(f, 0x3f, sizeof f);
	for (int i=1, u, v, w; i<n; ++i)
		cin >> u >> v >> w,
		f[u][v]=f[v][u]=w;
	for (int i=1; i<=n; ++i)	
		f[i][i]=0;
	for (int k=1; k<=n; ++k)
		for (int i=1; i<=n; ++i)
			for (int j=1; j<=n; ++j)
				f[i][j]=min(f[i][j], f[i][k]+f[k][j]);
	for (int i=1; i<=n; ++i)
		for (int j=1; j<=n; ++j)
			if (f[i][j]<=s) {
				int mx=0;
				for (int k=1; k<=n; ++k)	
					mx=max(mx, (f[i][k]+f[j][k]-f[i][j])/2);
				ans=min(mx, ans);
			}
	cout << ans;
	return 0;
}
```

---

## 作者：JXR_Kalcium (赞：2)

## 题目大意

给定一棵有 $n$ 个结点的无根树，在树上找一条路径，使得路径长不超过 $s$ 且**任意一点到这条路径的距离最大值最小**，数据范围 $n\le 300$。

## 解题思路

这一题可以使用**最短路**。注意到 $n\le 300$，所以直接跑一遍 Floyd 即可求出任意两点的距离。然后再枚举路径，用两层循环 $i,j$ 枚举路径的两个端点，再用一层循环枚举剩下的“任意一点”$k$。对于 $k$ 到路径 $i\rightarrow j$ 的距离可推导公式，若 $k\rightarrow w$ 与 $i\rightarrow j$ 交于点 $w$，则

$$
\begin{aligned}
iw+kw+jw+kw&=ik+jk\\
ij+2kw&=ik+jk\\
kw&=\frac{ik+jk-ij}{2}
\end{aligned}
$$

最后在 $k$ 的循环里求 $p=\max(kw)$，答案即为 $\min(p)$。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define endl putchar(10)
#define spc putchar(32)
#define R register
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x << " = " << x, endl
#endif

inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=(x<<1)+(x<<3)+c-48, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    static ll sta[41]; ll top=0;
    if(x<0) putchar('-'), x=-x;
    do sta[top++]=x%10, x/=10; while(x);
    while(top) putchar(sta[--top]+48);
}

ll n,s,a[301][301],x,y,z,mx,ans=1e18;

int main()
{
    n=read(); s=read();

    for(R int i=1; i<=n; ++i)
    {
        for(R int j=1; j<=n; ++j)
        {
            if(i!=j) a[i][j]=1e18;
        }
    }

    for(R int i=1; i<n; ++i)
    {
        x=read(); y=read(); z=read();
        a[x][y]=z; a[y][x]=z;
    }

    for(R int i=1; i<=n; ++i)
    {
        for(R int j=1; j<=n; ++j)
        {
            for(R int k=1; k<=n; ++k)
            {
                if(i!=j && i!=k && j!=k)
                a[j][k]=min(a[j][k],a[j][i]+a[i][k]), a[k][j]=a[j][k];
            }
        }
    }

    for(R int i=1; i<=n; ++i)
    {
        for(R int j=1; j<=n; ++j)
        {
            if(a[i][j]<=s)
            {
                mx=0;
                for(R int k=1; k<=n; ++k)
                mx=max(mx,a[i][k]+a[j][k]-a[i][j]>>1);
                ans=min(ans,mx); 
            }
        }
    }

    write(ans);
    return 0;
}
```

---

## 作者：tangzirui1016 (赞：1)

发现 $O(n^3)$ 的复杂度可以通过。

我的思路：枚举路径上的两个端点，然后以这条简单路径上的点为当前子树的根节点 $x$，然后搜索，注意，如果搜到了这条路径上的某一个点，这个分支就需要停下。找到 $ECC(x)$，取这条路径上最大的 $ECC(x)$ 作为这条路径的答案，找到所有路径中的最小值，时间复杂度 $O(n^3)$。 

如何找到这条路径上的点呢？我是先记录一个以节点 $1$ 为树的根节点，该节点的深度，同时记录该节点的父节点。对于两个路径的端点 $x,y$，向上一直走，直到找到 $x,y$ 的最近公共祖先，经过的点都是该路径上的点。
 
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int id,len;
};
vector<node>v[305];
int n,s,root,dis[305][305],c[305],ft[305],ans,ANS=1e9;
bool f[305];
void Dis(int x,int fa){//计算两点之间的距离
	for(auto i:v[x]){
		int to=i.id,e=i.len;
		if(to==fa) continue; 
		dis[root][to]=dis[root][x]+e;
		Dis(to,x);
	}
}
void make_c(int x,int fa){ //计算深度
	for(auto i:v[x]){
		int to=i.id;
		if(to==fa) continue;
		c[to]=c[x]+1;
		ft[to]=x;
		make_c(to,x);
	}
}
void make_f(int x,int y){ //给路径上的每一个点打上标记
	f[x]=f[y]=1;
	while(x!=y){
		if(c[x]>=c[y]) f[x=ft[x]]=1;
		else f[y=ft[y]]=1;
	}
}
void dfs(int x,int fa,int len){ //找到当前路径的ECC的最大值
	ans=max(ans,len);
	for(auto i:v[x]){
		int to=i.id;
		if(to==fa||f[to]) continue;
		dfs(to,x,len+i.len);
	}
}
int main(){
	cin>>n>>s;
	for(int i=1,x,y,z;i<n;i++){
		cin>>x>>y>>z;
		v[x].push_back({y,z});
		v[y].push_back({x,z});
	}
	for(int i=1;i<=n;i++){
		root=i;
		Dis(root,0);
	}
	make_c(1,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(dis[i][j]>s) continue;
			ans=0;
			memset(f,0,sizeof(f));
			make_f(i,j);
			for(int i=1;i<=n;i++){
				if(f[i]) dfs(i,0,0);
			}
			ANS=min(ANS,ans);
		}
	}
	cout<<ANS;
	return 0;
}
```

---


# 移动迷宫

## 题目背景

花生在电线杆的小广告上看到大侦探福尔魔斯正在招募助手帮助他抓住穷凶极恶的杀人魔：不知道。

花生出于某种原因来到了福尔魔斯的住处接受面试。但福尔魔斯住在一个...移动迷宫里？

## 题目描述

这个迷宫一共有 $n$ 个房间和 $m$ 条双向道路。第 $i$ 条道路连接 $u_i$ 和 $v_i$ 这两个房间，长度为 $w_i$。

福尔魔斯的迷宫是是会变化的：每通过一条道路（到达一个房间），所有道路都会伸缩，如果原本长度是 $t$，伸缩后长度会变化为 $\dfrac{1}{1-t}\bmod 754974721$。（如果你不知道分数如何取模，可移步 [P2613](https://www.luogu.com.cn/problem/P2613)；同时注意有可能涉及负数取模）

花生位于 $1$ 号房间。根据花生的测算，福尔魔斯就住在 $n$ 号房间。

请你帮帮花生最快到达 $n$ 号房间找到福尔魔斯。

------
负数取模：$x<0,p>0$，$x$ 对 $p$ 取模的结果等于 $x+p$ 对 $p$ 取模的结果。

$754974721$ 是一个质数。

## 说明/提示

### 样例 #1 解释：
沿路径 $1\rightarrow 4\rightarrow5$，路径长度为 $78888+150994944 = 151073832$。

---
对于 $30\%$ 的数据，$n\le 10$。

对于另外 $30\%$ 的数据，所有边边权相等。

对于 $100\%$ 的数据，$1\le n,m\le 10^5$，保证是一张连通图，$1\le u_i,v_i\le n$，$1<w_i<754974721$，保证无论任何时刻不会出现边权为 $1$ 的边。

所有输入的数都是整数。

---
后记：  
花生到达福尔魔斯住的房间后，看见福尔魔斯正盯着显示屏目不转睛：“你在看什么？”   
福尔魔斯：“不知道。”


## 样例 #1

### 输入

```
5 7
1 2 3
2 3 8
3 5 1000
2 4 100
4 5 6
1 4 78888
1 3 114514```

### 输出

```
151073832```

## 样例 #2

### 输入

```
6 8
1 3 100000000
1 5 200000000
2 5 300000000
2 6 400000000
3 4 500000000
5 6 600000000
4 5 700000000
3 6 303063652
```

### 输出

```
403063652```

# 题解

## 作者：FLY_lai (赞：4)

## 【$n\le 10$】

给爆搜的。不过搜索应该也不好写。

## 【所有边权相等】

这个题的难点其实就在于有可能通过往回走把原本的下一步变小。但是当所有边权相等的时候，往回走本身就要花费 "原本下一步" 的权值，再走回来必然严格更差。

所以不会走回头路。于是只需要正常跑最短路即可。

## 【满分做法】

样例二给了提示：$303063652$ 在经过一次变化之后不变。可能会启示选手们思考这个函数本身的不变性质。

观察发现，$\dfrac{1}{1-\dfrac{1}{1-\dfrac{1}{1-x}}}=x$，也就是说一条道路变化三次之后会变成原来的长度。

既然如此，我们直接分层图，将图分成三层。令 $x'=\dfrac{1}{1-x},x''=\dfrac{1}{1-x'}$。

对于一条边 $(u,v,w)$，在新图里变成三条边：$(u_1,v_2,w),(u_2,v_3,w'),(u_3,v_1,w'')$。然后从 $1$ 跑最短路，答案就是 $\min(dist[n_1],dist[n_2],dist[n_3])$。

Fun Facts: 这题本来模数是 $998$，但是我们发现 $998$ 没有一个迭代之后等于自身的不好做提示性样例，所以改了模数。~~实在太伟大了~~

-----

## Code

```
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const ll N = 3e5 + 5;
const ll MOD = 754974721;

ll fpow(ll a, ll b, ll p) {
	ll mul = 1;
	while (b) {
		if (b & 1)
			mul = mul * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return mul;
}
long long inv(long long x, long long mod) { // 计算 x 在模 mod 下的逆元 
	x = (x % mod + mod) % mod;
	return fpow(x, mod - 2, mod);
}

ll n, m;
struct Edge {
	ll to, val;
	Edge(ll t = 0, ll v = 0) {
		to = t, val = v;
	}
};
vector<Edge> e[N];
void addedge(ll u, ll v, ll w) {
	ll ww = inv(1 - w, MOD), www = inv(1 - ww, MOD);
	e[u].push_back(Edge(v + n, w));
	e[u + n].push_back(Edge(v + 2 * n, ww));
	e[u + 2 * n].push_back(Edge(v, www));
	
	e[v].push_back(Edge(u + n, w));
	e[v + n].push_back(Edge(u + 2 * n, ww));
	e[v + 2 * n].push_back(Edge(u, www));
}

ll dist[N];
bool vis[N];
typedef pair<ll, ll> pii;
void dijkstra(ll s) {
	priority_queue<pii, vector<pii>, greater<pii> > q;
	memset(dist, 0x3f, sizeof dist);
	memset(vis, false, sizeof vis);
	dist[s] = 0;
	q.push(make_pair(dist[s], s));
	while (!q.empty()) {
		ll h = q.top().second;
		q.pop();
		if (vis[h])
			continue;
		vis[h] = true;
		for (ll i = 0; i < e[h].size(); i++)
			if (dist[e[h][i].to] > dist[h] + e[h][i].val) {
				dist[e[h][i].to] = dist[h] + e[h][i].val;
				q.push(make_pair(dist[e[h][i].to], e[h][i].to));
			}
	}
}
int main() {
	cin >> n >> m;
	for (ll i = 1; i <= m; i++) {
		ll u, v, w;
		cin >> u >> v >> w;
		addedge(u, v, w);
	}
	dijkstra(1);
	cout << min(dist[n * 3], min(dist[n * 2], dist[n]));
	return 0;
}
```

---

## 作者：lg1058428 (赞：2)

找规律题。
# 解题思路
注意到 $\dfrac{1}{1-\dfrac{1}{1-\dfrac{1}{1-t}}}=\dfrac{1}{1-\dfrac{t-1}{t}}=t$。  
考虑使用分层图，建三层，再跑一遍最短路即可。  
我们可以从 $u$ 向 $v+n$，$u+n$ 向 $v+n\times2$，$u+n\times2$ 向 $v$ 建边，反方向同理。  
然后就是 dijkstra 的板子了。
# AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define PII pair<long long,long long>
using namespace std;
const int mod = 754974721;
int n, m;
int dis[300005];
bool vis[300005];
struct node {
	int vv, ww;
};
vector<node>a[300005];
bool operator <(node x, node y) {
	return x.ww > y.ww;
}
priority_queue<node> q;
int qpow(int x, int y) {
	int res = 1;
	while (y) {
		if (y & 1) res = res * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return res;
}
int calc(int x) {
	return (qpow((1 - x), mod - 2) + mod) % mod;
}
signed main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v, w;
		cin >> u >> v >> w;
		if (u == v) continue;
		a[u].push_back({v + n, w});
		a[u + n].push_back({v + 2 * n, calc(w)});
		a[u + 2 * n].push_back({v, calc(calc(w))});
		a[v].push_back({u + n, w});
		a[v + n].push_back({u + 2 * n, calc(w)});
		a[v + 2 * n].push_back({u, calc(calc(w))});
	}
	for (int i = 1; i <= 3 * n; i++) dis[i] = LLONG_MAX;
	q.push({1, 0});
	while (!q.empty()) {
		int v = q.top().vv, w = q.top().ww;
		q.pop();
		if (!vis[v]) {
			vis[v] = 1, dis[v] = w;
			for (int i = 0; i < a[v].size(); i++) {
				node now = a[v][i];
				if (!vis[now.vv]) q.push({now.vv, w + now.ww});
			}
		}
	}
	cout << min(dis[n], min(dis[2 * n], dis[3 * n]));
	return 0;
}
```

---

## 作者：dg114514 (赞：2)

赛时 10 min 出思路，但是 30 min 过。\
$\frac{1}{1-t}$ 看起来没有什么性质，所以考虑连分数的性质。手算几次可得 $\frac{1}{1-\frac{1}{1-\frac{1}{1-t}}}=t$。然后就可以考虑建一个三层分层图，权值依次是 $w$，$\frac{1}{1-w}$，$\frac{1}{1-\frac{1}{1-w}}$。然后跑 Dijkstra 最短路就可以了。（具体的，根据状态调整不同的边权，如果 $sta=0$，则权值为 $w$，如果 $sta=1$，则权值为 $\frac{1}{1-w}$，如果 $sta=2$，则权值为 $\frac{1}{1-\frac{1}{1-w}}$，其他同单源最短路模板）SPFA 没试过，可能会被卡？

### 代码实现（可能不是正常的分层图）

```cpp
#include<bits/stdc++.h>
#define int uint64_t
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
constexpr int mod=754974721;
inline int inv(int a){//费马小定理
	int b=mod-2,res=1;
	while(b){
		if(b&1)res=res*a%mod;
		b>>=1,a=a*a%mod;
	}
	return res;
}
inline int f(int x){// 1/(1-x)
	return inv(1-x+mod);//可能是负数所以加上一个 mod
}
struct node{
	int v,w,sta;
	friend bool operator<(node a,node b){
		return a.w>b.w;
	}
};
priority_queue<node>q;//小根堆
vector<node>e[100005];
int dis[100005][3];//三层分层图，所以 dis 要有第二维
signed main(){
	memset(dis,0x3f,sizeof dis);
	int n,m,u,v,w;
	cin>>n>>m;
	rep(i,1,m){
		cin>>u>>v>>w;
		e[u].push_back({v,w,0}),e[v].push_back({u,w,0});//建无向边，0 没用
	}
	dis[1][0]=0;//不解释
	q.push({1,0,0});//当前 1 节点，权值和 0，分层图状态 0
	while(!q.empty()){
		auto [v,w,sta]=q.top();//取出堆顶
		q.pop();
		int ts=(sta+1)%3;//下一步的状态
		for(auto [u,W,fwsta]:e[v]){//fwsta 没用
			if(sta>=1){
				W=f(W);
				if(sta==2)W=f(W);
			}//计算出当前的边的权值
			if(dis[u][ts]>w+W)
				q.push({u,w+W,ts}),dis[u][ts]=w+W;
		}
	}
	cout<<min({dis[n][0],dis[n][1],dis[n][2]});//可能 dis[n][0]>dis[n][1] 之类的，所以是三个取 min
}
```

---

## 作者：LostKeyToReach (赞：2)

这道题很显然吧。

我们分析一下 $t$ 值的变换：

$$
t \Rightarrow \frac{1}{1-t} \Rightarrow \frac{t - 1}{t} \Rightarrow t.
$$

容易发现这是一个循环节为 $3$ 的变换过程，那么我们可以令 $f_{i, 0/1/2}$ 表示从 $1$ 到 $i$，且当前状态为 $0/1/2$ 的最短路即可，时间复杂度 $\mathcal{O}(n \log m)$。

代码如下：

```cpp
#define MULTI_TEST 0
#define int long long
struct Node {
    int v;
    int c[3];
};
int32_t main() {
#if MULTI_TEST == 1
#else
    int n, m;
    std::cin >> n >> m;
    std::vector<std::vector<Node>> adj(n + 1);
    for (int i = 0; i < m; ++i) {
        int x, y, w;
        std::cin >> x >> y >> w;
        int c0 = (LL)Z(w);
        int c1 = (LL)(Z(1) / Z(1 - w));
        int c2 = (LL)(Z(w - 1) / Z(w));
        adj[x].pb(Node{ y,{c0,c1,c2} });
        adj[y].pb(Node{ x,{c0,c1,c2} });
    }
    std::vector<std::vector<int>> dist(n + 1, std::vector<int>(3, 1e18));
    dist[1][0] = 0;
    using qwq = std::tuple<LL, int, int>;
    std::priority_queue<qwq, std::vector<qwq>, std::greater<qwq>> pq;
    pq.push({ 0,1,0 });
    while (!pq.empty()) {
        auto [d, x, r] = pq.top();
        pq.pop();
        if (d != dist[x][r]) continue;
        for (auto& v : adj[x]) {
            int y = v.v, cost = v.c[r];
            if (cost + d < dist[y][(r + 1) % 3]) {
                dist[y][(r + 1) % 3] = cost + d;
                pq.push({ dist[y][(r + 1) % 3], y, (r + 1) % 3 });
            }
        }
    }
    std::cout << std::min({ dist[n][0], dist[n][1], dist[n][2] }) << "\n";
#endif
}
```

---

## 作者：Scean_Tong (赞：1)

### Problem

给你一张 $n$ 个点的有权无向连通图，每走一条路，所有道路的边权都会由 $w$ 变成 $\frac{1}{1-w}$，求 $1$ 到 $n$ 的最短路。

### Solution

$\frac{1}{1-w}$ 经典套路了属于是，把这个不断带回，你会发现带 $3$ 次后这个式子就又变成了 $w$，所以直接把图分为 $3$ 层。

第一层和第二层之间边权为 $w$，第二层和第三层之间边权为 $\frac{1}{1-w}$，第三层和第一层之间边权为 $\frac{1}{1-\frac{1}{1-w}}$。

建完图直接跑最短路即可，答案为 $dis_{n_1},dis_{n_2},dis_{n_3}$ 的最小值。

### Code
```cpp
inline void solve() {
	Fastio::cin >> n >> m;
	for(int i = 1, u, v, w; i <= m; i++){
		Fastio::cin >> u >> v >> w;
		G[u].push_back(std::make_pair(v + n, w)); 
		G[v].push_back(std::make_pair(u + n, w));
		G[v + n].push_back(std::make_pair(u + n * 2, qpow(-w + mod + 1, mod - 2))); 
		G[u + n].push_back(std::make_pair(v + n * 2, qpow(-w + mod + 1, mod - 2))); 
		G[v + n * 2].push_back(std::make_pair(u, qpow(-qpow(-w + mod + 1, mod - 2) + mod + 1, mod - 2))); 
		G[u + n * 2].push_back(std::make_pair(v, qpow(-qpow(-w + mod + 1, mod - 2) + mod + 1, mod - 2))); 
	}
	dijkstra(1);
	Fastio::cout << std::min(std::min(dis[n], dis[n * 2]), dis[n * 3]) << '\n';
}
```

---

## 作者：MaiJingYao666 (赞：1)

# P11898 移动迷宫 题解  
找规律的结论题。  
为表示方便，下文形如 $x^{-1}$ 以为 $x$ 模 754974721 意义下的乘法逆元，即 $x \times x^{-1} \equiv 1 \pmod {754974721} $。
### 解题思路  
看到变化的这么诡异，就预感到有规律可以找。  
显然，对于一个边权 $t_0$，一开始是 $t_0$，变化一次之后就是 $\frac{1}{1-t_0} \bmod 754974721 = (\frac{1}{1-t_0})^{-1}$，记为 $t_1$。而我们知道虽然余数没有可除性，但是逆元是有可乘性的，换而言之，取不取逆元不影响它之后取模的结果，则第二次变化之后就是 $\frac{1}{1-t_1}=\frac{1}{1-\frac{1}{1-t_0}}$，根据我们小学学的方法，把数翻上来，就是 $\frac{1}{-\frac{t_0}{1-t_0}}=-\frac{1-t_0}{t_0}$，记为 $t_2$。第三次变化就是 $\frac{1}{1-t_2}=\frac{1}{1+\frac{1-t_0}{t_0}}=\frac{1}{\frac{1}{t_0}}=t_0$。耶？变回来了。所以任何数三次变化之后都会有一个循环，换而言之，对于任意一条路径 $w_i$，一开始是 $w_{i,0}$，设当前走了 $x$ 步：  
1.    $x \bmod 3 = 0$，$w_i=w_{i,0}$。
2.    $x \bmod 3 = 1$，$w_i=(\frac{1}{1-w_{i,0}})^{-1}$。
3.    $x \bmod 3 = 2$，$w_i=(-\frac{1-w_{i,0}}{w_{i,0}})^{-1}$。

所以就是个喜闻乐见的分层图了，开三倍空间就可以。  
关于逆元的计算，由于 754974721 是个质数，所以用费马小定理算就可以了。$x^{-1}=x^{754974721-2} \bmod 754974721$。  

### AC 代码  

```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e5+1,M=6e5+1;
typedef long long ll;
typedef pair<ll,int> PII;
const ll mod=754974721;
int n,m;
int h[N*3],ne[M],e[M],idx;
ll w[M];
inline void add(int a,int b,ll c){
	e[idx]=b;
	w[idx]=c;
	ne[idx]=h[a];
	h[a]=idx++;
}
inline ll inv(ll a,ll b){
	b-=2;
	ll res=1;
	while(b){
		if(b&1) res=(res*a)%mod;
		b>>=1;
		a=(a*a)%mod;
	}
	return res;
}
ll x,y,z;
ll dis[N*3];
bool vis[N*3];
inline void dijkstra(){
	priority_queue<PII,vector<PII>,greater<PII>> q;
	dis[1]=0;
	q.push({0,1});
	while(q.size()){
		int ver=q.top().second;
		q.pop();
		if(vis[ver])continue;
		vis[ver]=1;
		for(int i=h[ver];i!=-1;i=ne[i]){
			int j=e[i];
			if(dis[j]>dis[ver]+w[i]){
				dis[j]=dis[ver]+w[i];
				q.push({dis[j],j});
			}
		}
	}
}
int main(){
	memset(h,-1,sizeof h);
	memset(dis,0x7f,sizeof dis);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y>>z;
		add(x,y+n,z);
		add(y,x+n,z);
		ll t=((1-z)%mod+mod)%mod;
		t=inv(t,mod);
		add(x+n,y+2*n,t);
		add(y+n,x+2*n,t);
		t=((1-t)%mod+mod)%mod;
		t=inv(t,mod);
		add(x+2*n,y,t);
		add(y+2*n,x,t);
	}
	dijkstra();
	cout<<min(min(dis[n],dis[n<<1]),dis[n*3]);//三种情况都有可能
}
```

---

## 作者：CNS_5t0_0r2 (赞：1)

看到这种边的长度在变化的题一眼分层图，但一看数据范围直接放弃。

$n,m$ 都是 $10^5$ 级别的，总不能建 $10^5$ 层吧（别说时间复杂度了，空间已经炸了）。

这题巧妙的地方就在于 $\frac{1}{t - 1}$ 迭代 $3$ 次就变了回来，即：

$$\frac{1}{1 - \frac{1}{1 - \frac{1}{t}}} = t$$

所以说我们根本就不需要建 $m$ 层图，只用建 $3$ 层。把每个点 $u$ 拆成 $3$ 个点 $u_0,u_1,u_2$，其中 $u_i$ 代表的是进入点 $u$ 时经过的边数 $\bmod 3 = i$。

这样，对于每条边 $(u,v,w)$（这里认为是有向的），就拆成了 $3$ 条边：$(u_0,v_1,w),(u_1,v_2,\frac{1}{1 - w}),(u_2,v_0,\frac{1}{1 - \frac{1}{w}})$。

这里解释一下边权：以第一条边举例，因为进入 $u$ 的时候经过的边数是 $3$ 的倍数，上文提到，一条边的边权变换 $3$ 次就会变回原来的边权，所以此时 $(u,v)$ 的边权就是 $w$。

其余同理。

注意，最后的答案不一定是 ``dis[n]``，因为我们不知道走最短路径需要经过几条边，所以最后的答案应该是三种边数取最小值，即 ``min(dis[n],dis[n + n],dis[n + n + n])``。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 9,M = 1e5 + 9,MOD = 754974721;
int n,m;
struct edge{
	int to,cost,nex;
} e[(M << 1) * 3];
int head[N * 3],ecnt;
void addedge(int u,int v,int w){
	ecnt++;
	e[ecnt] = (edge){v,w,head[u]};
	head[u] = ecnt;
}

struct node{
	int d,id;
};
bool operator<(node x,node y){
	return x.d > y.d;
}

int dis[N * 3];
bool vis[N * 3];
priority_queue<node> q;

void dij(int st){
	memset(dis,0x3f,sizeof dis);
	dis[st] = 0;
	q.push((node){0,st});
	while(!q.empty()){
		node u = q.top();
		int d = u.d,id = u.id;
		q.pop();
		if(vis[id])
			continue;
		vis[id] = true;
		for(int i = head[id];i;i = e[i].nex){
			int v = e[i].to,w = e[i].cost;
			if(dis[v] > dis[id] + w){
				dis[v] = dis[id] + w;
				if(!vis[v])
					q.push((node){dis[v],v});
			}
		}
	}
}

int qpow(int x,int y){
	int ret = 1;
	while(y){
		if(y & 1)
			ret = ret * x % MOD;
		x = x * x % MOD;
		y >>= 1;
	}
	return (ret + MOD) % MOD;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		int u,v,w;
		cin >> u >> v >> w;
		int w_ = qpow(1 - w,MOD - 2),w__ = qpow(1 - w_,MOD - 2);
		addedge(u,v + n,w);
		addedge(u + n,v + n + n,w_);
		addedge(u + n + n,v,w__);
		addedge(v,u + n,w);
		addedge(v + n,u + n + n,w_);
		addedge(v + n + n,u,w__);
	}
	
	dij(1);
	
	cout << min(dis[n],min(dis[n + n],dis[n + n + n]));
	return 0;
}
```

---

## 作者：gesong1234 (赞：1)

题目传送门：[P11898 移动迷宫](https://www.luogu.com.cn/problem/P11898)。
# 思路

首先一个原始长度为 $t$ 的边，收缩一次长度会变为 $\dfrac{1}{1-t}$，收缩两次长度会变为 $\cfrac{1}{1-\frac{1}{1-t}}=\dfrac{t-1}{t}$，收缩三次长度变为 $\dfrac{1}{1-\frac{t-1}{t}}=t$。

根据上面的推导我们发现每一条边的长度在 $t,\frac{1}{1-t},\frac{t-1}{t}$ 中循环，我们就可以设 $d_{i,1/2/3}$ 表示从 $1$ 到 $i$ 点且**来到这个点的边**的类型为 $1/2/3$，用类似 dij 的方法转移即可，具体的细节可以看代码。

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=754974721,N=1e5+10;
int d[N][4],n,m;
#define pii pair<int,int>
vector<pii >a[N];
map<pii,int>vis;
inline int read(){
	char c=getchar();
	int f=1,ans=0;
	while(c<48||c>57) f=(c==45?f=-1:1),c=getchar();
	while(c>=48&&c<=57) ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();
	return ans*f;
}
void exgcd(int a,int b,int &x,int &y){
	if (b==0) x=1,y=0;
	else exgcd(b,a%b,y,x),y-=a/b*x;
}
inline int inv(int a){
	int x,y;
	exgcd(a,mod,x,y);
	return (x%mod+mod)%mod;
} 
inline int get(int t,int op){
	if (op==1) return t;
	else if (op==2) return inv(1-t+mod);
	return (t-1+mod)*inv(t)%mod;
}
struct nord{
	int u,w,op;
	bool operator <(const nord &x) const{
		return w>x.w;
	}
};
main(){
	n=read(),m=read();
	while(m--){
		int u=read(),v=read(),w=read();
		a[u].push_back({v,w});
		a[v].push_back({u,w});
	}
	for (int i=1;i<=n;i++) d[i][1]=d[i][2]=d[i][3]=1e17;
	d[1][3]=0;
	priority_queue<nord>q;
	q.push({1,0,3});
	while(!q.empty()){
		nord x=q.top();q.pop();
		int u=x.u,op=x.op;
		if (vis.count({u,op})) continue;
		vis[{u,op}]=1;
		for (auto i:a[u]){
			int v=i.first;
			int x=op+1;
			if (x==4) x=1;
			int w=get(i.second,x);
			if (d[v][x]>d[u][op]+w){
				d[v][x]=d[u][op]+w;
				q.push({v,d[v][x],x});
			}
		}
	}
	cout <<min(min(d[n][1],d[n][2]),d[n][3]);
    return 0;
}
```

---

## 作者：TemplateClass (赞：0)

找规律。设最开始某条道路的长度是 $t$，则一次变换后变为：

$$\frac{1}{1 - t}$$

两次变换后变为：

$$\frac{1}{1 - \frac{1}{1 - t}} = \frac{1 - t}{1 - t - 1} = \frac{t - 1}{t}$$

三次变换后变为：

$$\frac{\frac{1}{1 - t} - 1}{\frac{1}{1 - t}} = 1 - (1 - t) = t$$

发现经过 $3$ 次变换后长度又变回了 $t$，因此我们先把可能的这 $3$ 种边权存到边的信息中，然后跑一个最短路，但节点信息中要加一个 $m$，表示现在的边权循环到了哪一个，别的就和正常的分层图最短路无异了。

```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<cstring>

typedef long long ll;
typedef unsigned long long ull;

constexpr int N = 1e5 + 1;
constexpr int MOD = 754974721;

struct Node1 {
	int v, w0, w1, w2;
};
struct Node2 {
	ull d; int u, m;
	
	inline bool operator < (const Node2& rhs) const {
		return d ^ rhs.d ? d > rhs.d : (u ^ rhs.u ? u > rhs.u : m > rhs.m);
	}
};
int n, m; std::vector<Node1> G[N];

int fpow(int x, int y) {
	if(!x || !y) return !y;
	int res = fpow(x, y >> 1);
	res = (1ull * res * res) % MOD;
	if(y & 1) res = (1ull * res * x) % MOD;
	return res;
}
inline int inv(int x) { return fpow((x + MOD) % MOD, MOD - 2); }

ull dis[N][3];
inline void Dijkstra() {
	std::memset(dis, 0x3f, sizeof dis);
	
	dis[1][0] = 0ull;
	std::priority_queue<Node2> que;
	que.push((Node2){0, 1, 0});
	
	while(!que.empty()) {
		Node2 now = que.top(); que.pop();
		int u = now.u, m = now.m; ull d = now.d;
		if(u == n || d > dis[u][m]) continue;
		for(const auto& edge : G[u]) {
			int v = edge.v, w0 = edge.w0, w1 = edge.w1, w2 = edge.w2;
			ull newd = d + (m ? (m == 1 ? w1 : w2) : w0);
			if(newd < dis[v][(m + 1) % 3]) {
				dis[v][(m + 1) % 3] = newd;
				que.push((Node2){newd, v, (m + 1) % 3});
			}
		}
	}
}

int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);
	
	std::cin >> n >> m;
	for(int i = 1; i <= m; ++i) {
		int u, v, w; std::cin >> u >> v >> w;
		int w1 = inv(1 - w), w2 = inv(1 - w1);
		G[u].push_back((Node1){v, w, w1, w2});
		G[v].push_back((Node1){u, w, w1, w2});
	}
	
	Dijkstra();
	std::cout << std::min({dis[n][0], dis[n][1], dis[n][2]}) << "\n";
	
	return 0;
}
```

---

## 作者：e_zhe (赞：0)

### 分析

一道很不错的分层图最短路题目。

观察 ~~（或打表）~~ 可以发现道路的长度每三个一循环，即
$$\frac{1}{1-\frac{1}{1-\frac{1}{1-x}}}=x$$

那么可以对原图建三层的分层图，节点 $x$ 对应的三个节点 $x_1=x,x_2=x+n,x_3=x+n\times 2$。若原图有一条从 $u$ 到 $v$，长度长度为 $w$ 的边，$w_1=w,w_2=\frac{1}{1-w_1},w_3=\frac{1}{1-w_2}$，则建好的分层图如下：

![分层图示意图](https://cdn.luogu.com.cn/upload/image_hosting/6en27lp8.png)

在分层图上跑最短路，最后输出节点 $n$ 对应的三个节点 $n_1,n_2,n_3$ 距离 $1$ 号节点的距离的最小值即可。

~~好像没有卡 SPFA。~~

### Code

```cpp
#include<bits/stdc++.h>
#define cst const
#define i64 long long
#define mmax(x,y) ((x)>(y)?(x):(y))
#define mmin(x,y) ((x)<(y)?(x):(y))

using namespace std;

template<typename T>
void read_arr(int n,T *arr){
	for(int i=1;i<=n;++i)cin>>arr[i];
	return;
}

namespace Math{
	i64 ExGcd(cst i64 &a,cst i64 &b,i64 &x,i64 &y){
		if(b==0){x=1,y=0;return a;}
		
		i64 res=ExGcd(b,a%b,y,x);
		y-=a/b*x;
		return res;
	}
	
	//返回值为 a/b%m，本题中模数为质数，可以直接用快速幂，但扩欧更保险
	i64 getmod_frac(cst i64 &a,cst i64 &b,cst i64 &m){
		i64 x=0,y=0;
		i64 tmp=Math::ExGcd(b,m,x,y);
		x=x*a/tmp,x=(x%m+m)%m;
		
		if(a%tmp)return -1;
		return x;
	}
}

constexpr int N=1e5+5;
constexpr i64 mod=754974721;
int n,m;

namespace Graph{
	int tot_edge,hd[N*3];
	struct Edge{int to;i64 val;int lst;}g[N*12];
	void add_edge(cst int &u,cst int &v,cst i64 &w){
		g[++tot_edge]=Edge{v,w,hd[u]};
		hd[u]=tot_edge;
	}
	
	//最短路
	i64 dist[N*3];bool inque[N*3];
	queue<int> que;
	void spfa(int st){
		memset(dist,0x3f,sizeof dist),
		memset(inque,false,sizeof inque);
		while(!que.empty())que.pop();
		
		dist[st]=0,inque[st]=true;
		que.push(st);
		
		while(!que.empty()){
			int frt=que.front();que.pop();
			
			for(int i=hd[frt];~i;i=g[i].lst){
				int ne=g[i].to;i64 val=g[i].val;
				
				if(dist[ne]<=dist[frt]+val)continue;
				dist[ne]=dist[frt]+val;
				if(inque[ne]==false){
					inque[ne]=true;
					que.push(ne);
				}
			}
			
			inque[frt]=false;
		}
	}
}

using namespace Graph;

int main(){
	ios::sync_with_stdio(false),
	cin.tie(nullptr),cout.tie(nullptr);
	
	memset(hd,-1,sizeof hd);
	
	cin>>n>>m;
	for(int _=0;_<m;++_){
		int x1,x2;i64 w1;cin>>x1>>x2>>w1;
		
		//求边权
		i64 w2=Math::getmod_frac(1,1-w1,mod);
		i64 w3=Math::getmod_frac(1,1-w2,mod);
		
		//建分层图
		add_edge(x1+n*0,x2+n*1,w1),add_edge(x2+n*0,x1+n*1,w1),
		add_edge(x1+n*1,x2+n*2,w2),add_edge(x2+n*1,x1+n*2,w2),
		add_edge(x1+n*2,x2+n*0,w3),add_edge(x2+n*2,x1+n*0,w3);
	}
	
	spfa(1);
	
	i64 ans=1e18;
	for(int i=0;i<=2;++i)ans=mmin(ans,dist[n+n*i]);
	
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Tighnarri (赞：0)

比较巧妙地一道题，简单说说我的思路：

观察到 $n,m\le 1e5$ 那么就可以知道一个做法是超时的：

> 每走一步就去更新一遍边权。

所以我们要对这个式子 $\frac{1}{1-t} \pmod {754974721}$ 找规律。

重复代入三次后发现得出的数为 $t$ 。

这时候想到了记录一个 $step$ 表示当前走的是第几步，然后用 $step \bmod 3$ 这类操作去计算边权。

仔细思考一下似乎并不好写而且正确性并没有多么大，~~简单来说就是没有前途~~。

那么接着就想到了分层图。

将三种边权分到三层建图，具体地说：

> 我们令图分为 $1,2,3$ 层，每条边的边权在循环中的值为 $w_1,w_2,w_3$ 。
>
> 那么对于一条 $u$ 到 $v$ 的边，我们从第一层的 $u$ 向第二层的 $v$ 建一条 $w_1$ 的边，第二层的 $u$ 向第三层的 $v$ 建一条 $w_2$ 的边，第三层的 $u$ 向第一层的 $v$ 建一条 $w_3$ 的边。
>
> 反之亦然。 

直接在建好的分层图上跑最短路即可。

AC code：

实现的并不优美，致歉。
```cpp
#include<iostream>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#define int long long
#define ll __int128
using namespace std;
const int N=1e5+50;
const int M=1e5+50;
const int p=754974721;
int n,m;
struct node{
	int v,w;
};
vector<node> vec[3*N];
bool vis[3*N];
ll dis[3*N];
queue<int> que;
int gn(int i,int k){
	return i+k*n;
}
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){
		x=1;
		y=0;
		return a;
	}
	int res=exgcd(b,a%b,x,y);
	int tmp=x;
	x=y;
	y=tmp-a/b*y;
	return res;
}
ll qpow(ll a,ll b,ll p){
	ll res=1;
	while(b){
		if(b&1) res=res%p*a%p;
		a=a%p*a%p;
		b>>=1;
	}
	return res%p;
}
ll modify(ll k){
//	ll x,y;
//	exgcd(1-k,p,x,y);
	return qpow((1-k+p)%p,p-2,p);
}
void add(int u,int v,int w){
	vec[u].push_back({v,w});
	return ;
}
int spfa(int u){
	for(int i=1;i<=3*n;i++) dis[i]=1e18;
	dis[u]=0;
	vis[u]=1;
	que.push(u);
	while(!que.empty()){
		int x=que.front();que.pop();
		vis[x]=0;
		for(int j=0;j<(int)vec[x].size();j++){
			int y=vec[x][j].v;
			int w=vec[x][j].w;
			if(dis[y]>dis[x]+w){
				dis[y]=dis[x]+w;
				if(!vis[y]){
					que.push(y);
					vis[y]=1;
				}
			}
		}
	}
	return min(dis[gn(n,0)],min(dis[gn(n,1)],dis[gn(n,2)]));
//	return dis[gn(n,0)];
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		int w2=modify(w);
		w2=(w2%p+p)%p;
		int w3=modify(w2);
		w3=(w3%p+p)%p;
		add(gn(u,0),gn(v,1),w);
		add(gn(u,1),gn(v,2),w2);
		add(gn(u,2),gn(v,0),w3);
		add(gn(v,0),gn(u,1),w);
		add(gn(v,1),gn(u,2),w2);
		add(gn(v,2),gn(u,0),w3);
	}
	int ans1=spfa(gn(1,0));
	cout<<ans1;
	return 0;
}
```

---

## 作者：hgckythgcfhk (赞：0)

看到这个形式比较诡异，而且每走一条边全局都改，很自然地想到分层图，所以大体得到一个建图方式，每次走到下一层，最后一层连向第一层，所以可以猜测层数不多，那就顺着这个思路往下想下去，反正不会耽误太多时间，打表 $t=2$ 发现迭代 $3$ 次会循环。

基于上述的猜想，同时带着对这题能做的信任，先相信不同循环的长度是不多的，同时不会有太长的非循环部分，总之结构是简单的，好，现在开始代入未知数推广到一般情况：

$t\to \dfrac{1}{1-t}\to \dfrac{1}{1-\dfrac{1}{1-t}}=\dfrac{t-1}{t}=1-\dfrac{1}{t}\to \dfrac{1}{1-(1-\dfrac{1}{t})}=t$。

发现循环节固定是 $3$。

本题的关键是注意到全局修改想到分层图，这样让我们相信问题的结构并不复杂，更有底气地推式子，我见到一个人上来怼着式子推推到第二步就认为思路不对式子会越推越复杂放弃了没做出来，我认为前面的思考过程是有必要的。

为防止因火车头导致无法过审，这里只放核心程序，省略了缺省源。
```cpp
unsigned n,m,pre[N<<2];ull d[N<<2];
struct A{unsigned v;ull w;il bool operator<(A a)const{return w>a.w;}};vector<A>a[N<<2];
il unsigned f(cit x){return inv(p+1-x);}
void edge(){int u=rd()<<2,v=rd()<<2;cit ll w1=rd(),w2=f(w1),w3=f(w2);
	a[u|0]+=A{v|1,w1},a[u|1]+=A{v|2,w2},a[u|2]+=A{v|0,w3};
	a[v|0]+=A{u|1,w1},a[v|1]+=A{u|2,w2},a[v|2]+=A{u|0,w3};
}priority_queue<A>q;Bool(b,N<<2);
void init(){rd(n),rd(m);for(;m--;edge());//cerr<<f(6);
	a[1]+=A{4,0};//,a[1]+=A{5,0},a[1]+=A{6,0};
	a[n<<2|0]+=A{2,0},a[n<<2|1]+=A{2,0},a[n<<2|2]+=A{2,0};
}void solve(){init();while(q.SZ)q.pop();b.reset();q.push(A{1,0});
	for(tmx(d),d[1]=0;q.SZ;q.pop())if(int u=q.top().v;!b[u]&&(b[u]=1))for(auto&[v,w]:a[u])if(d[u]+w<d[v])d[v]=d[u]+w,pre[v]=u,!b[v]?q.push(A{v,d[v]}),0:0;
	cout<<d[2]<<'\n';//for(int u=2;pre[u];u=pre[u])cerr<<u<<' '<<(u&3)<<' '<<(u>>2)<<' '<<d[u]<<'\n';
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}
```
注意起点只有一个。

---

## 作者：DFM_O (赞：0)

## [P11898 题目](https://www.luogu.com.cn/problem/P11898)

### 解题思路
$\frac{1}{1-t}$ 这个式子一看就很可疑，不难发现道路的伸缩三次后长度将还原，于是一条边的边权只有可能有三种变化，于是我们可以认为一个点有三种状态，跑 Dijkstra 最短路即可。

对于每个点的三个状态都要分别记录最短路，可以多建 $2n$ 个点并重新连边，即分层图，也可以直接在 Dijkstra 上修改，即记录每个点入堆时的状态，最后的答案即为点 $n$ 三种状态的最短路的最小值。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const long long p=754974721;
inline long long poww(long long a,long long b)
{
    long long ss=1;
    while(b)
    {
        if(b&1)
            ss=ss*a%p;
        a=a*a%p;
        b>>=1;  
    }
    return ss;
}
inline int ny(int a,int b)
{
	int s=poww(b,p-2)*a%p;
	return s;
}
struct owp
{
	int v;
	int w[3];
};
vector<owp> g[300001];
typedef pair<long long,long long> op;
priority_queue<op,vector<op>,greater<op>> pq;
int ds[300001],n;
bool st[300001];
inline void dij(int s)
{
	for(int i=1;i<=300000;i++)
		ds[i]=LLONG_MAX;
	ds[s]=0,pq.push({0,s});
	while(!pq.empty())
	{
		int now=pq.top().second,nowzh=now/n-(now%n==0),rnow=now%n;
		if(rnow==0)
			rnow=n;
		pq.pop();
		if(st[now]==1)
			continue;
		st[now]=1;
		for(auto [v,w]:g[rnow])
		{
			int rv=n*((nowzh+1)%3)+v;
			if(ds[rv]>ds[now]+w[nowzh])
				ds[rv]=ds[now]+w[nowzh],pq.push({ds[rv],rv});
		}
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	int m;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		int w1=(ny(1,1-w)+p)%p,w2=(ny(1,1-w1)+p)%p,we[3]={w,w1,w2};
		g[u].push_back({v,w,w1,w2}),g[v].push_back({u,w,w1,w2});
	}
	dij(1);
	int s=min(ds[n],min(ds[n*2],ds[n*3]));
	cout<<s;
	return 0;
}
```

---


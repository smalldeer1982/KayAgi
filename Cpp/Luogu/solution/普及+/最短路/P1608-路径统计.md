# 路径统计

## 题目描述

“RP 餐厅” 的员工素质就是不一般，在齐刷刷的算出同一个电话号码之后，就准备让 HZH,TZY 去送快餐了，他们将自己居住的城市画了一张地图，已知在他们的地图上，有 $N$ 个地方，而且他们目前处在标注为 “1” 的小镇上，而送餐的地点在标注为 “N” 的小镇。（有点废话）除此之外还知道这些道路都是单向的，从小镇 $I$ 到 $J$ 需要花费 $D[I, J]$ 的时间，为了更高效快捷的将快餐送到顾客手中，他们想走一条从小镇 $1$ 到小镇 $N$ 花费最少的一条路，但是他们临出发前，撞到因为在路上堵车而生气的 FYY，深受启发，不能仅知道一条路线，万一。。。于是，他们邀请 FYY 一起来研究起了下一个问题：这个最少花费的路径有多少条？


## 说明/提示

对于 $30\%$ 的数据 $N\leq 20$；

对于 $100\%$ 的数据 $1\leq N\leq 2000$，$0\leq E\leq N\times (N-1)$，$1\leq C\leq 10$。


## 样例 #1

### 输入

```
5 4
1 5 4
1 2 2
2 5 2
4 1 1
```

### 输出

```
4 2```

# 题解

## 作者：_WRYYY_ (赞：28)


update 2022.2.17 图炸了

update 2022.8.20 修改了一些错误
## step 0 一些建议
做此题前建议先去做 [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144) 并且建议使用 Dijkstra 算法去写，原因在 [这个帖子](https://www.luogu.com.cn/discuss/407511) 和 [这个帖子](https://www.luogu.com.cn/discuss/407546) 也感谢这位大佬的付出。 ~~不然我就要拿SPFA写了。~~
## step 1 坑
这道题有个坑，那就是在这句话上 ```
两个不同的最短路方案要求：路径长度相同（均为最短路长度）且至少有一条边不重合。```

我认为应该是所生成的最短路序列不得有重，重复的不加入计数，这里就要求我们去重边了，与 [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144) 不同，P1144 是允许序列有重，这里给出一组数据。

输入：

```
3 4
1 2 2
1 2 2
2 3 1
1 3 3
```
所生成的最短路序列为：

```
1 2 3 (重边中第一条)
1 2 3 (重边中第二条)
1 3
```
可以看到如果只按字面理解的话那答案应该是：3 3，因为 1-2 这条边有两条。

如果是序列指不重才会是正确答案：3 2。
## step 2 计数操作
我们只需要在跑 Dijkstra 算法是加入计数操作就可以了。

如果 $dist[y] > dist[x]+e $ 那么就说明找到了优的路径，将 $y$ 的路径计数用 $x$ 的路径计数覆盖，并将 $y$ 的 $dist$ 值更新，即实施  ```dist[y] = dist[x]+e``` 和  ```ans[y]=ans[x]``` 操作。

如果 $dist[y] = dist[x]+e $ 那么 $y$ 节点就加上 $x$ 节点的计数 ,即实施 ```ans[y]+=ans[x]``` 操作。

此处的 $y$ 是 $x$ 所连节点，$e$ 为连接 $x$ 与 $y$ 这条边的权值。

## step 3.1-1 迭代器去重

选择用空间换时间的可以跳过这一段，但个人认为有关迭代器的知识大家可以去看看，毕竟以后说不定要用到？

有关于迭代器（iterator），这是一个类似于指针的东西，支持自增（```++```）和自减（```--```），这里不再赘述，[洛谷日报](https://www.luogu.com.cn/blog/poi/cpp-iterator)里有关于这个的介绍。

由于蒟蒻不会写重载运算符，所以直接用了 STL 自带的 ```pair``` 类型，它会先以第一关键字进行比较，再以第二关键字进行比较，我们用第一关键字存边的另一端点，用第二关键字存这条边的权值，再使用 ```sort()``` 函数进行排序，因为 ```sort()``` 默认从小到大，这样可以保证重边都挨在一起，并且第一次出现的某个节点所代表的边一定是所有其代表的边中权值最小的，这样我们便可以执行删除操作，将在其后并与其编号相同的边全部删除。

代码：

```cpp
for(int i=1;i<=n;i++){
		sort(a[i].begin(),a[i].end());
		ls=INT_MAX;
		for(basic_string <pair<int,int> >::iterator it=a[i].begin();it!=a[i].end();++it){
			ls3=*it;
			if(ls3.first!=ls)ls=ls3.first;
			else {//若是相同则删除，并将迭代器--
				a[i].erase(it);
				--it;
			}
		}
	}
```


## step 3.1-2 Code
话不多说，代码实现：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define ll  long long
#define ull unsigned long long
using namespace std;
using namespace __gnu_pbds;
inline ll read(){
   ll s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
   return s*w;
}
inline void print(ll ch){
	if (ch<0)ch=-ch,putchar('-');
	if (ch>9)print(ch/10);
	putchar(ch%10+'0');
}
int n,m,s;
int dist[2010],ans[2010];
bool v[2010];
__gnu_pbds::priority_queue<pair<int,int>,greater<pair<int,int> >, pairing_heap_tag > w;//pbds 中的小根堆 
basic_string <pair<int,int> > a[2010];//一个和 vector 差不多的容器
void dij(){//堆优化 Dijkstra
	pair<int,int> x1;
	int x,y,e;
	while(!w.empty()){
		x1=w.top();
		x=x1.second;
		w.pop();
        if(v[x])continue;
		v[x]=1;
		for(int i=0;i<a[x].size();i++){
			y=a[x][i].first;
			e=a[x][i].second;
			if(dist[y]>dist[x]+e){
				dist[y]=dist[x]+e;
				ans[y]=ans[x];//覆盖 
				if(!v[y]){
					w.push(make_pair(dist[y],y));	
				}
			}
			else if(dist[y]==dist[x]+e)ans[y]+=ans[x];//累加 
		}
	}
}
int main()
{
	n=read(),m=read(),s=1;
	int ls,ls1,ls2;
	pair<int,int> ls3;
	for(int i=0;i<m;i++){
		ls=read(),ls1=read(),ls2=read();
		a[ls]+=make_pair(ls1,ls2);//basic_string专属添加元素，理解成 push_back() 即可 
	}
	for(int i=1;i<=n;i++){//这里需要熟悉STL中迭代器的使用 
		sort(a[i].begin(),a[i].end());
		ls=INT_MAX;
		for(basic_string <pair<int,int> >::iterator it=a[i].begin();it!=a[i].end();++it){
			ls3=*it;
			if(ls3.first!=ls)ls=ls3.first;
			else {
				a[i].erase(it);
				--it;
			}
		}
	}
	for(int i=1;i<=n;i++){
		dist[i]=INT_MAX;
	}
	dist[s]=0;
	w.push(make_pair(dist[s],s));
	ans[s]=1;
	dij();
	if(dist[n]==INT_MAX){//如果等于原数值则输出 No answer 
		cout<<"No answer";
		return 0;
	}
	print(dist[n]);
	putchar(32);
	print(ans[n]);
	return 0;
}
```
运行时间  ```basic_string```：

![](https://cdn.luogu.com.cn/upload/image_hosting/74gz8657.png)

运行时间  ```vector```：

![](https://cdn.luogu.com.cn/upload/image_hosting/q8qg5w9z.png)

在此补充一句，在插入 1e8 以上级别数据时。 ```basic_string``` 将会明显慢于 ```vector ``` 。在开启 ``O2`` 的情况下插入 3e8 的数据 ```basic_string``` 会被卡到 5000ms 及以上，无论是使用 ```+=X``` 或者是直接使用 ``` push_back ``` ，而 ```vector``` 若是使用 ```push_back``` 会稳定在 4000ms 左右，使用 ``` emplace_back ``` 更是能稳定在 3500ms 左右。但一般的题目并不会使用 1e8 及以上如此离谱的数据，故此我又测试了百万即 1e6 级别的插入，在此时二者的差别也不大了，不开 O2 都是稳定在 250ms 左右，开 O2 二者都稳定在 30ms ，所以在不那么离谱的数据情况下两者都是能选用的。~~而且 ```baisc_string ``` 的 ``` +=``` 插入还挺诱人的~~ 

综上所述，数据不离谱时按自己喜好选择，比较离谱的话还是用 ```vector``` + ```emplace_back``` 吧。在以后我可能会在博客对二者进行更细致的讨论。~~也可能会咕咕咕~~
## step 3.2-1 用空间换时间

这样写就跟写邻接矩阵差不多了，但是或许可以使用 ```short``` 类型，因为题目中 $ 1\le C \le 10 $ 而在输入的时候不需要加或者乘，```short``` 类型是完全够用的，这里为了方便还是使用了 ```int``` 类型。

首先我们要进行初始化，其实用 11 去初始化就好了，不需要使用到 32767 或者是 ```INT_MAX``` ，这里建议使用双重 ```for``` 循环而不是 ```memset()``` 用了 ```memset()``` 会稍微慢点，在开了 ```O2``` 后对比会比较明显，不过在 $n$ 较大时这俩差别不大。

接下来就和写邻接矩阵一样了，如果 $ qc_{r1,r2} \le r3 $ 那么就跳过循环，在代码中，我们使用这个语句：

```
if(qc[ls][ls1]<=ls2)continue;
```


## step 3.2-2 Code

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define ll  long long
#define ull unsigned long long
using namespace std;
using namespace __gnu_pbds;//以上请忽略 
inline ll read(){//快读 
   ll s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
   return s*w;
}
inline void print(ll ch){//快输 
	if (ch<0)ch=-ch,putchar('-');
	if (ch>9)print(ch/10);
	putchar(ch%10+'0');
}
int n,m,s;
int dist[2010],ans[2010],qc[2010][2010];
bool v[2010];
__gnu_pbds::priority_queue<pair<int,int>,greater<pair<int,int> >, pairing_heap_tag > w;//pbds 中的小根堆 
basic_string <pair<int,int> > a[2010];//一个和 vector 差不多的容器，但似乎更快 
void dij(){//堆优化 Dijkstra
	pair<int,int> x1;
	int x,y,e;
	while(!w.empty()){
		x1=w.top();
		x=x1.second;
		w.pop();
        if(v[x])continue;
		v[x]=1;
		for(int i=0;i<a[x].size();i++){
			y=a[x][i].first;
			e=a[x][i].second;
			if(dist[y]>dist[x]+e){
				dist[y]=dist[x]+e;
				ans[y]=ans[x];//覆盖 
				if(!v[y]){
					w.push(make_pair(dist[y],y));	
				}
			}
			else if(dist[y]==dist[x]+e)ans[y]+=ans[x];//累加 
		}
	}
}
int main()
{
	n=read(),m=read(),s=1;
	int ls,ls1,ls2;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			qc[i][j]=INT_MAX;
		}
	}
	pair<int,int> ls3;
	for(int i=0;i<m;i++){
		ls=read(),ls1=read(),ls2=read();
		if(qc[ls][ls1]<=ls2)continue;
		a[ls]+=make_pair(ls1,ls2);//basic_string专属添加元素，理解成 push_back() 即可 
		qc[ls][ls1]=ls2;
	}
	for(int i=1;i<=n;i++){
		dist[i]=INT_MAX;
	}
	dist[s]=0;
	w.push(make_pair(dist[s],s));
	ans[s]=1;
	dij();
	if(dist[n]==INT_MAX){//如果等于原数值则输出 No answer 
		cout<<"No answer";
		return 0;
	}
	print(dist[n]);//输出答案 
	putchar(32);
	print(ans[n]);
	return 0;
}
```

运行时间 ```for``` :

![](https://cdn.luogu.com.cn/upload/image_hosting/z8bp7uwi.png)


运行时间 ```memset()``` ：

![](https://cdn.luogu.com.cn/upload/image_hosting/dv0m1fll.png)

如有错误和不足，欢迎 dalao 们指出 qwq。


---

## 作者：Texas_the_Omertosa (赞：16)

[题目传送门](https://www.luogu.com.cn/problem/P1608)

### 0x00 本题坑点

这题不能使用 `SPFA`，会被卡掉 #1,#13

>  关于 SPFA，它死了。

本题我们可以参考[最短路计数](https://www.luogu.com.cn/problem/P1144)，但最短路计数可以使用 `SPFA`。~~我用的就是。~~

还有这题最大的坑点：

有重边！有重边！！有重边！！！

### 0x01 思路

本题可以这样想：一个点的最短路数就是这个点前赴的最短路数之和。因为从上一个点过来都是同一条路。所以我们可以得到以下算最短路数代码：

```cpp
if(dis[i]==dis[last]+vaule)
{
	ans[i]+=ans[last];
}
```

但是有一个问题：有的时候我们会发现当前求的不是最短路，要更新，那么我们又得出更新最短路时更新答案代码：

```cpp
if(dis[i]>dis[last]+vaule)
{
	dis[i]=dis[last]+vaule;
    ans[i]=ans[last];
    q.push(make_pair(-dis[i],i));
}
```

这题的核心就搞定了。

### 0x02 AC Code

```cpp
//by olkieler
#include<bits/stdc++.h>
#define int long long
#define inf LLONG_MAX
#define retrun return
#define N 2005
#define M 4000005
#define mod 114514
using namespace std;
priority_queue<pair<int,int> >q;
struct node
{
	int next;
	int pointer;
	int vaule;
};
node edge[M];
int n,m,tot;
bool vis[N];
int c[N][N];
int head[N];
int dis[N];
int ans[N];
inline void add(int u,int v,int w)
{
	edge[++tot].pointer=head[u];
	edge[tot].next=v;
	edge[tot].vaule=w;
	head[u]=tot;
}
inline void input()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		if(!c[u][v])
		{
			c[u][v]=1;
			add(u,v,w);
		}
		if(c[u][v])
		{
			for(int i=head[u];i;i=edge[i].pointer)
			{
				if(edge[i].next==v)
				{
					edge[i].vaule=min(edge[i].vaule,w);
					break;
				}
			}
		}
	}
}
inline void init()
{
	for(int i=2;i<=n;i++)
	{
		dis[i]=inf;
	}
	ans[1]=1;
	q.push(make_pair(0,1));
}
inline void dijkstra()
{
	while(!q.empty())
	{
		int ls=q.top().second;
		q.pop();
		if(vis[ls])
		{
			continue;
		}
		vis[ls]=1;
		for(int i=head[ls];i;i=edge[i].pointer)
		{
			int y=edge[i].next;
			int z=edge[i].vaule;
			if(dis[y]>dis[ls]+z)
			{
				dis[y]=dis[ls]+z;
				q.push(make_pair(-dis[y],y));
				ans[y]=0;
			}
			if(dis[y]==dis[ls]+z)
			{
				ans[y]+=ans[ls];
			}
		}
	}
}
inline void output()
{
	if(dis[n]==inf)
	{
		cout<<"No answer\n";
		retrun;
	}
	cout<<dis[n]<<' '<<ans[n]<<'\n';
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	input();
	init();
	dijkstra();
	output();
	return 0;
}
```

---

## 作者：_JF_ (赞：14)

# **P1608 路径统计 题解** 

不喜欢 dijkstra 优化的同学可以看过来。

前置知识 ： dijkstra 以及其性质的足够了解。

不会的左转 [oiwiki](https://oiwiki.com/graph/shortest-path/)

[题目传送门](https://www.luogu.com.cn/problem/P1608)

[P1339 [USACO09OCT]Heat Wave G](https://www.luogu.com.cn/problem/P1339)

这一道题的本质其实就是在 dijkstra 中加一个计数就可以的，但一些题解讲得不是特别清楚。

```cpp
	for(int j=1;j<=n;j++)
		{
			if(minn+a[p][j]<dis[j])
			{
				dis[j]=minn+a[p][j];
				sum[j]=sum[p];
			}
			else if(dis[j]==dis[p]+a[p][j])
				sum[j]+=sum[p];
		}
```
整个代码的核心就在这里。

首先 $j$ 遍历的就是关于 $p$ 连接的节点，如果我当前的最短路可以更新，证明 $j$ 这个点就是在当前 $p$ 的最短路往后一条边。 但就长远来说，$dis[j]$ 不一定就是从起点到 $j$ 的一个最短路,所以他的总方案数就继承了他原先的 $sum[p]$ 的方案种数。

其次就是另外一个 else 他就是 $p$ 和 $j$ 完完全全连通了。

可以确定当前的就是最短路，直接加上去就可以了。

但是你可能会有这样的疑问，如果 $p$ 走过的路和 $j$ 重复了，会不会多算？



其实是不会的，因为我每次都是挑最优的去走，所以 $sum[p]$ 就是有一些拐弯的地方更新而来的，所以不重复。

注意一开始要判重边。


所以完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =2037;
const int maxn=1e6+10;
int a[N][N];
int dis[maxn],vis[maxn],sum[maxn],n,m;
void dijkstra(int s)
{
	int minn,p;
	memset(dis,0x3f3f3f3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s]=0;
	sum[s]=1;
	for(int i=1;i<=n;i++)
	{
		minn=1e6+10;
		for(int j=1;j<=n;j++)
		{
			if(!vis[j]&&minn>dis[j])
				p=j,minn=dis[j];
		}
		vis[p]=1;
		for(int j=1;j<=n;j++)
		{
			if(minn+a[p][j]<dis[j])
			{
				dis[j]=minn+a[p][j];
				sum[j]=sum[p];
			}
			else if(dis[j]==dis[p]+a[p][j])
				sum[j]+=sum[p];
		}
	}
}
int main()
{
	memset(a,1e6+10,sizeof(a));
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		if(a[u][v]>w)
			a[u][v]=w;
	}
	dijkstra(1);
	if(dis[n]==0x3f3f3f3f)
		cout<<"No answer";
	else
		cout<<dis[n]<<" "<<sum[n];
	return 0;
}
```

[一个深痛的教训](https://www.luogu.com.cn/record/72774516)

所以同学们一定要看好数据范围！！！！！！（手动加感叹号）



---

## 作者：ningago (赞：6)

### 简化题意

求 $1$ 到 $n$ 的最短路数量，没有输出 ``No answer``。

### 思路

按照原来 dijkstra 求最短路的方式，我们有判断能否更新的三角不等式：

$$dis[nx] \ge dis[now] + w$$

( $now$ 为当前节点，$nx$ 为它的一个邻居节点，$w$ 为两点之间权值）；

可以看出，当 $dis[nx] = dis[now] + w$ 时表示出现了同样长度的最短路，而 $dis[nx] > dis[now] + w$ 时则表示找到了更优的最短路。

同时，如果 $now$ 的（其中一个）前驱节点 $pre$ 的最短路有 $cnt[pre]$ 条，容易发现如果不等式符号为等号，则 ``cnt[now] += cnt[pre]`` （累积），为大于号则 ``cnt[now] = cnt[pre]`` （覆盖）。

### Code:

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <cstring>
 
#define N 2010
using namespace std;
 
int n,m;
struct node
{
    int to,val;
};
vector <node> g[N];
int dis[N],cnt[N];
int chong[N][N];
bool done[N];
struct edge
{
    int u,val;
    bool operator < (const edge &x)const{
        return val > x.val;
    }
};
void dijkstra(int s)
{
    priority_queue <edge> q;
    memset(dis,0x3f3f3f3f,sizeof(dis));
    dis[s] = 0;
    cnt[s] = 1;
    q.push((edge){s,0});
    while(!q.empty())
    {
        int t = q.top().u;
        q.pop();
        if(!done[t])
        {
            done[t] = 1;
            for(int j = 0;j < g[t].size();j++)
            {
                int nx = g[t][j].to;
                int ww = g[t][j].val;
                if(dis[nx] > ww + dis[t])
                {
                    dis[nx] = ww + dis[t];
                    cnt[nx] = cnt[t];
                    q.push((edge){nx,dis[nx]});
                }
                else if(dis[nx] == ww + dis[t])
                    cnt[nx] += cnt[t];
            }
        }
    }
    if(dis[n] == 0x3f3f3f3f)
        printf("No answer\n");
    else
        printf("%d %d",dis[n],cnt[n]);
}
 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 1,a,b,c;i <= m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        if(chong[a][b] == c)
            continue;//坑点，重边不参与计算，但题面没说……需要自己根据题面情境理解感悟出来
        g[a].push_back((node){b,c});
        chong[a][b] = c;
    }
    dijkstra(1);
    return 0;
}
```

---

## 作者：34ytw8ew7ft (赞：4)

大家好，这里是蒟蒻天鹏。

**主体思路：裸Dijkstra+矩阵存图**  为什么不用SPFA？众所周知，它死了。  
相信各位对于最短路早已是轻车熟路，故不过多赘述。而题目中还要求输出最短路径的条数，怎么办呢？

我们假设这样一个图的存在：  
![](https://cdn.luogu.com.cn/upload/pic/54263.png)

在这个图中，由$A-D$的最短路径共有三条，分别是$A-D,A-B-D,A-B-C-D$，长度都是30  
接下来我们再对这个图搞事情：  
![](https://cdn.luogu.com.cn/upload/pic/54264.png)

可以看到，由$A-E$的最短路径还是三条，长度是40。  
这个时候我们发现了一个好玩的特性，$A-E$的条数就是$A-D$的条数！别着急，我们再稍加修改：  
![](https://cdn.luogu.com.cn/upload/pic/54267.png)

现在$A-F$的条数是1条，距离为10，加入$F-E$的距离(30)后，距离为40；$A-D$的条数是3条，距离为30，加入$D-E$的距离(10)后，距离为40；$A-E$的条数是4条。可以发现，由于$40=40$,$A-E$的条数就是$A-F,A-D$的条数之和。我们再去做做修改：  
![](https://cdn.luogu.com.cn/upload/pic/54268.png)

此时，$A-G$的最短路径条数是1条，加上关联边长度为20；$A-F,A-D$的最短路径条数分别是1条和3条，加上关联边长度为40；由于$40=40>20$，所以$A-E$的最短路径条数是1条，距离为20。于是我们可以归纳一下：

**求节点$n$的最短距离条数，先要求其节点关联节点的最短路径距离+关联边的长度，之后选出最短的，将它们的最短距离条数加和。（好麻烦啊）**

这是个好东西，怎么用呢？

众所周知，dijsktra在求最短路的时候会更新距离，我们可以新建一个path数组存路径条数，在更新距离的时候可以直接对距离更新。核心代码:
```cpp
//dijisktra更新距离时：
if(dis[j]>dis[u]+w)
{
	dis[j]=dis[u]+w;
	path[j]=path[u];//不同长度变最短
}
else if(dis[j]==dis[u]+w)
	path[j]+=path[u];//相同长度加和
```
轻松愉悦

下面是完整的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int tu[2010][2010];//不要在意这个细节
bool vis[2010]={0};
int dis[2010],path[2010];
int n,m,from,I,J,C;
void dij(int a）//常规的dij
{
	memset(dis,0x3f,sizeof(dis));
	dis[a]=0;
	for(int i=1;i<=n;i++)
	{
		int u,maxu=1e9;
		for(int j=1;j<=n;j++)
			if(!vis[j]&&maxu>dis[j])
			{
				maxu=dis[j];
				u=j;
			}
		vis[u]=1;
		for(int j=1;j<=n;j++)
		{
			int w=tu[u][j];
			if(dis[j]>dis[u]+w)
			{
				dis[j]=dis[u]+w;
				path[j]=path[u];//不同长度变最短
			}
			else if(dis[j]==dis[u]+w)
				path[j]+=path[u];//相同长度加和
		}
	}
}
int main()
{	
	memset(tu,63,sizeof(tu));
	cin>>n>>m;
	for(int i=0;i<m;i++)
	{
		cin>>I>>J>>C;
		if(tu[I][J]>C)
		{
			tu[I][J]=C;	//注意有向图	
		}
	}
	
	dij(1);
	if(dis[n]==0x3f3f3f3f)//如果还是初值，输出no ans
		cout<<"No answer"<<endl;
	else
		cout<<dis[n]<<" "<<path[n];
	return 0;
}
```

---

## 作者：eEfiuys (赞：2)

题目：[P1608](https://www.luogu.com.cn/problem/P1608)

~~楼下题解比这个详细多了，可是图看起来太复杂。蒟蒻认为本题解还是简单易懂的。~~

由于 $N$ 比较小，因此使用邻接矩阵存图，这样**方便处理重边**（题目要求边不重合）。最短路算法使用 [堆优化 dijkstra](https://www.luogu.com.cn/problem/P4779)。

接下来我们考虑**使用 dp 的思想**来计数。记 $d_i$ 为 $1$ 到 $i$ 的最短路长度，$cnt_i$ 为 $1$ 到 $i$ 的最短路数量，$u$ 为一条边的起点，$v$ 为一条边的终点，$w$ 为边权。
- $d_u+w<d_v$：这说明之前到 $v$ 的**不是最短路**，需要清零；那么**当前**的最短路**只从 $u$ 转移**，$cnt_v$ 就应该等于 $cnt_u$。
- $d_u+w=d_v$：这说明从一个新的点**再次**得到了**当前**最短路，原先的依然是，那么 $cnt_v$ 就加上 $cnt_u$。

以上是本题重点，时间复杂度即 dijkstra 的复杂度，为 $(n+m)\times\log{n}$。细节见注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
int n,m;
int e[N][N];
int d[N],cnt[N];
bool vis[N];
void dijkstra(){
	priority_queue<pair<int,int>>q;
	#define mp make_pair
	memset(d,0x3f,sizeof(d));
	d[1]=0,cnt[1]=1; //从1到1的最短路长度为0，有1条
	q.push(mp(-0,1));
	while(!q.empty()){
		int u=q.top().second;
		q.pop(),
		if(vis[u])continue;
		vis[u]=1;
		for(int i=1;i<=n;i++){
			int v=i,w=e[u][i]; //没有边的话，边权为正无穷，自然不会成为最短路，不用特判
			if(d[u]+w<d[v])d[v]=d[u]+w,q.push(mp(-d[v],v)),cnt[v]=cnt[u];
			else if(d[u]+w==d[v])cnt[v]+=cnt[u];
		}
	}
}
int main(){
	cin>>n>>m;
	memset(e,0x3f,sizeof(e)); //邻接矩阵边权初始化为正无穷
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		e[u][v]=min(e[u][v],w); //有重边，取较小的
	}
	dijkstra();
	if(d[n]==0x3f3f3f3f)puts("No answer"); //最短路还是初始化的值，说明不连通
	else cout<<d[n]<<" "<<cnt[n]<<endl;
	return 0;
}
```

---

## 作者：panyanppyy (赞：2)

### 不开邻接矩阵和不会迭代器的福音！
看到题解区都是用迭代器和邻接矩阵的，那我这个用 $STL$ 的蒟蒻肯定要来一发的咩。
## 题目
求从 $1\sim n$ 最短路的长度和数量 ~~（一句话题意）~~。
## 题解
楼上的大佬都说得很清楚了，~~那我还是再说一遍吧~~。

$\texttt{Spfa}$ 死了，用 $\texttt{Dijkstra}$。

当较短路出现的时候肯定要进行一次松弛操作，也就是
```cpp
if(g[v]>g[u]+w)g[v]=g[u]+w;
```
考虑用 $cnt_i$ 记录 $1\sim i$ 的最短路数量，由于 $v$ 是由 $u$ 转移过来的，那么松弛后 $cnt_v\leftarrow cnt_u$。

然鹅这还不够，仔细想想当：```g[v]==g[u]+w``` 的情况，显然 $cnt$ 不转移好像不对，毕竟长度一样，也是一条最短路。那么就有了以下：
```cpp
if(g[v]==g[u]+w)cnt[v]+=cnt[u]
```
## 实现
写完代码，一交，只有 $60$？

楼上的大佬也点明了这题的坑点：

```
两个不同的最短路方案要求：路径长度相同（均为最短路长度）且至少有一条边不重合。
```
### 有重边
看见有人用邻接矩阵存图，可以有效避免重边。~~但我不,我用~~ $vector$ 存图。

用迭代器？~~我懒~~。

**STL** 大法好。

将数据**排序后**，快速去重函数（重复就保留第一个）：```unique(a.begin(),a.end(),cmp)```。

```a.begin() a.end()``` 是 $vector$ 的头尾指针，表示从头到尾（废话）。

```cmp``` 是自定义函数，可以如果重复，就会把它放到最后（**不是删除**）：
```cpp
bool cmp(node x,node y){
	return x.v==y.v;
}
```
```unique``` 还有一个重点是返回值，它返回的是去重后数组应该有的最后一个数的迭代器（~~怎么又是它~~）。

用 ```n=unique(a.begin(),a.end(),cmp)-a.begin()``` 就能得到去重后长度了，在 $vector$ 中 ```.pop_back()``` 多余的就行了（~~怎么更复杂了，幸好代码不长~~）。

[机房大佬](https://www.luogu.com.cn/user/159686)%%%给出了两种别的方法：
```cpp
a.erase(unique(a.begin(),a.end()),a.end());
a.resize(unique(a.begin(),a.end())-a.begin());
```
[Code](https://www.luogu.com.cn/paste/8no1srmb)

---

## 作者：JoyJoyGang (赞：1)

这道题目要去重边，我们发现 $n$ 和 $c$ 的范围非常的小，因此直接 $bol$ 数组去重就行 $bol[x][y][c]$ 分别代表着一条从 $x$ 到 $y$ 的边长度为 $c$，因为我们无法保证输入的第一条是最短的边，所以这样整是 ok 的。

剩下的在不同 $dij$ 里面加上一个计数的数组 $shu$ 即可。

在求最短路的时候顺道转移 $shu$ 即可，具体见代码。

代码里写的很清楚啊！

```cpp
#include<bits/stdc++.h>
#define pr pair<int,int>
using namespace std;
const int MA=2002;
const int MAXN=2000000005;
int n,m,head[MA],cnt=0;
struct zh{
	int x,y,z;
}a[MA*MA];
void cun(int x,int y,int z){
	a[++cnt].x=head[x];a[cnt].y=y;a[cnt].z=z;head[x]=cnt;
}
int dis[MA],shu[MA];
bool bel[MA],bol[MA][MA][12];
priority_queue<pr,vector<pr>,greater<pr> > q; 
void dij(){
	for(int i=1;i<=n;i++){
		dis[i]=MAXN;bel[i]=0;shu[i]=0;
	}
	shu[1]=1;
	dis[1]=0;q.push(make_pair(0,1));
	while(q.empty()==0){
		int x=q.top().second;q.pop();
		if(bel[x]==1){
			continue;
		}
		bel[x]=1;
		for(int i=head[x];i;i=a[i].x){
			int y=a[i].y,z=a[i].z;
			if(dis[y]==dis[x]+z){
				shu[y]+=shu[x];
			}			
			if(dis[y]>dis[x]+z){
				dis[y]=dis[x]+z;shu[y]=shu[x];
				q.push(make_pair(dis[y],y));
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		if(bol[x][y][z]==0){
			cun(x,y,z);bol[x][y][z]=1;
		}
	}
	dij();
	if(dis[n]==MAXN){
		printf("No answer");return 0;
	}
	printf("%d %d",dis[n],shu[n]);
	return 0;
}
```


---

## 作者：Exiler (赞：1)

## 原题

[P1608 路径统计](https://www.luogu.com.cn/problem/P1608)

---

## 思路概述

### 题意分析

带有向边判重的单源最短路径与最短路径计数。

### 思路分析

首先排除已经死掉的SPFA。

考虑Dijkstra，但由于需要判重边，所以直接邻接矩阵存图。笔者不建议邻接矩阵判重后再用链式前向星存图（ $100→53$ 血的教训）。

---

## 算法实现

### 关于邻接矩阵存图

由于求最短路，所以两个点之间的同一条有向边只需要保留边权最小的一条。

代码如下：

```cpp
for(RI i=1,x,y,w;i<=m;++i)
	{
		cin >> x >> y >> w;
		dist[x][y]=min(dist[x][y],w);
	}
```

### Dijkstra的线段树实现

本题可以用堆优化，但是笔者决定介绍Dijkstra的线段树实现方式。

从算法原理入手：Dijkstra算法的流程是每次选取离起点最近的点，并搜索所有出边，松弛与其相连的其他点。最后在松弛操作中求得起点到终点的最短路径。而每次选取最近点的操作，就是线段树的优化对象（与堆优化效果一致）。

线段树的实现与其他权值线段树没有太大差别。但由于每次只进行单点修改，所以不需要懒标记，只需要区间最小值上传。

值得注意的是，每次取出最近点后需要将该点从集合中删除（对应堆优化中的出堆）。在线段树中，向取出的下标上传一个极大值，使其不会再被上传，即达到类似效果。

### 关于路径计数

最短路径计数考虑两种情况。

为方便表述，设当前选定的最近点为 $u$ ，与起点最短路径长度为 $dis_u$ ；搜索到的出边为 $i$ ，权值为 $w_i$ ；边的另一端点 $v$ ，与起点最短路径长度 $dis_v$ ；两点的最短路径数分别为 $cnt_u,cnt_v$。

当 $dis_v>w_i+dis_u$ ，此时点 $v$ 的最短路径被更新，其最短路径数也要被其前驱点 $u$ 的最短路径数覆盖，即 $cnt_v=cnt_u$ 。

当 $dis_v=w_i+dis_u$ ，说明在点 $u$ 松弛之前，点 $v$ 已经存在长度相同的最短路径，此时到达点 $v$ 的最短路径即为当前两个点最短路径数的和，即 $cnt_v=cnt_u+cnt_v$ 。

---

## AC code

因为实现太烂，代码凑合看看就行。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<set>
#include<ctime>
#define RI register int
#define RN register node
using namespace std;
const int maxn=2e3+10;
typedef struct node
{
	int dis;
	int pos;
};
typedef struct
{
	int l,r;
	node data;
}tree;
tree e[maxn<<2];
int n,m,cnt;
int fir[maxn],dis[maxn],dist[maxn][maxn],rec[maxn];
bool v[maxn];
inline node getmin(node x,node y);/*返回距离最小的结点*/
inline void push_up(int p);/*区间最小值上传*/
inline void build(int p,int l,int r);/*建树*/
inline void update(int p,node opt);/*上传值（在本题中上传最大整数 类似于堆优化中的出堆）*/
inline node query(int p,int l,int r);/*查询最小值*/
inline void dijkstra(int st);/*Dijkstra板子*/
int main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin >> n >> m;
	memset(dist,0x3f3f3f3f,sizeof(dist));
	for(RI i=1,x,y,w;i<=m;++i)
	{
		cin >> x >> y >> w;
		dist[x][y]=min(dist[x][y],w);/*因为需要判重 所以直接邻接矩阵存图*/ 
	}
	dijkstra(1);
	if(dis[n]==0x3f3f3f3f) puts("No answer");
	else cout << dis[n] << " " << rec[n];	
	return 0;
}
inline node getmin(node x,node y)
{
	if(x.dis<y.dis) return x;
	else return y;
}
inline void push_up(int p)
{
	e[p].data=getmin(e[p<<1].data,e[p<<1|1].data);
	return;
}
inline void build(int p,int l,int r)
{
	e[p].l=l;e[p].r=r;
	if(l==r) e[p].data=(node){0x3f3f3f3f,0};
	else
	{
		e[p].data=(node){0x3f3f3f3f,0};
		RI mid=(l+r)>>1;
		build(p<<1,l,mid);build(p<<1|1,mid+1,r);
		push_up(p);
	}
	return;
}
inline void update(int p,node opt)
{
	if(e[p].l>=opt.pos && e[p].r<=opt.pos) e[p].data=opt;
	else
	{
		RI mid=(e[p].l+e[p].r)>>1;
		if(mid>=opt.pos) update(p<<1,opt);
		else update(p<<1|1,opt);
		push_up(p);
	}
	return;
}
inline node query(int p,int l,int r)
{
	if(e[p].l>=l && e[p].r<=r) return e[p].data;
	else
	{
		RI mid=(e[p].l+e[p].r)>>1;
		RN ret=(node){0x3f3f3f3f,1};
		if(mid>=l) ret=getmin(ret,query(p<<1,l,r));
		if(mid<r) ret=getmin(ret,query(p<<1|1,l,r));
		return ret;
	}
}
inline void dijkstra(int st)
{
	memset(dis,0x3f3f3f3f,sizeof(dis));
	build(1,1,n);
	dis[st]=0;rec[st]=1;
	update(1,(node){0,st});
	for(RI i=1;i<n;++i)
	{
		RN temp=query(1,1,n);update(1,(node){0x3f3f3f3f,temp.pos});
		if(v[temp.pos]) continue;
		v[temp.pos]=1;
		for(RI j=1;j<=n;++j)
			if(dis[j]>dis[temp.pos]+dist[temp.pos][j])
			{
				dis[j]=dis[temp.pos]+dist[temp.pos][j];rec[j]=rec[temp.pos];/*最小权值更新 当前结点最短路径数等于其前驱的最短路径数*/
				update(1,(node){dis[j],j});
			}
			else if(dis[j]==dis[temp.pos]+dist[temp.pos][j]) rec[j]+=rec[temp.pos];/*不更新最小权值 但是更新最短路径数*/
	}
	return;
}
```

---

## 作者：Emp7iness (赞：1)

## 题意简述

求从 $1$ 到 $n$ 的最短路的数量。

## 题解

关于 `SPFA`，它死了。用 `Dijkstra`。

题目要求最短路的数量，那就新开一个数组 $s[i]$ 记录从 $1$ 到 $i$ 的最短路数量。

怎么更新这个数组的值呢？

分类讨论。在松弛时如果 $d[v]>d[u]+w$（$d[i]$ 记录从 $1$ 到 $i$ 的最短路长度，$w$ 为边权）说明之前的不是最短路，所以把 $s[v]$ 更新为 $s[u]$。

如果 $d[v]=d[u]+w$，说明又得到了最短路，所以把 $s[v]$ 加上 $s[u]$。

不要忘了可能有重边。这里我用邻接矩阵，比 `vector` 方便一些。

## 代码

```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int N=2005;
int n,m,d[N],v[N],s[N],e[N][N];
priority_queue<pair<int,int>> q;
void dijkstra()
{
	memset(d,0x3f,sizeof(d));
	d[1]=0; s[1]=1;
	q.push(make_pair(0,1));
	while(!q.empty())
	{
		int u=q.top().second;
		q.pop(); 
		if(v[u]) continue;
		v[u]=1;
		for(int i=1;i<=n;i++)
		{
			int v=i,w=e[u][i];
			if(d[v]>d[u]+w)
			{
				d[v]=d[u]+w;
				s[v]=s[u];
				q.push(make_pair(-d[v],v));
			}
			else if(d[v]==d[u]+w)	s[v]+=s[u];
		}
	}
}
int main()
{
	memset(e,0x3f,sizeof(e));
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		e[u][v]=min(e[u][v],w);
	}
	dijkstra();
	if(d[n]==0x3f3f3f3f)	cout<<"No answer";
	else	cout<<d[n]<<" "<<s[n];
	return 0;
}
```

---

## 作者：kaceqwq (赞：1)

# 题目大意：
有 $N$ 个地方，从 $1$ 开始，在 $N$ 结束。这些道路都是单向的，从一个地方到另一个地方要花费钱，现求从起始地到 $N$ 地的最少花费和花费最少的路径的总数。

# 分析：
这道题不难看出，是一道最短路的题，与 [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144) 类似，并在此基础上要求求出最少花费。首先我们可以使用邻接表存储图的信息，接着使用 dijkstra 算法求最短路，以及最少路径的总数，并且使用大根堆优化。~~（至于 SPFA ，它死了）~~

### 关于 Dijkstra 算法
Dijkstra算法
流程如下：

1.  初始化 $ans_1=0$ ,其余节点的 $ans$ 值为正无穷大。 
    
2.  找出一个未被标记的、 $ans_x$ 最小的节点 $x$ ，然后标记节点 $x$ 。
    
3. 扫描节点x的所有出边 $( x , y , z)$ ， 若 $ans_y > ans_x+z$ ，则使用 $ans_x + z$更新 $ans_y$ 。
    
4. 重复上述 $2 ~ 3$ 两个步骤，直到所有节点都被标记。
    
Dijkstra算法基于贪心思想，它只适用于所有边的长度都是非负数的图。当边长 $z$ 都是非负数时，全局
最小值不可能再被其他节点更新，故在第1步中选出的节点x必然满足: $ans_x$ 已经是起点到 $x$ 的最短路
径。我们不断选择全局最小值进行标记和扩展，最终可得到起点 $1$ 到每个节点的最短路径长度，而本题只需得到起点 $1$ 到 $N$ 的最短路径长度即可。

知道了这个之后做这题就很简单了，根据这个我们可以求出最短路径长度，可是本题还要求最短路径的数量，这个怎么求呢？

其实最短路径数量能在求最短路径的同时得出。判断是否更新某个点的最短路径长度有三种不同情况，对最短路径数也有不同的更新迭代。

1.若 $ans_y > ans_x+z$

说明找到了更优的方案，就把 $num_y$ 更换成现在新方案的最短路径数。

2.若$ans_y > ans_x+z$

说明要再次访问这个点，这时就 让 $num_y$ 加上其入度的最短路径数量

3.若$ans_y < ans_x+z$

说明没有更优的方案，即无需变化 $num_y$ 。

# Code：
```cpp
#include<bits/stdc++.h> 
using namespace std;
int head[1000005],ver[1000005],ed[1000005],net[1000005],ans[10000005],num[1000005];
int n,m,s,tot,x,y,z,chong[10005][10005];
bool flag[1000005]
priority_queue< pair<int ,int > > q;;  //大根堆，用于优化dijkstra
void add(int x,int y,int z)   // 邻接表存图，表示建立一条由 x 指向 y， 边权为 z 的边
{
	ver[++tot]=y;
	ed[tot]=z;
	net[tot]=head[x];
	head[x]=tot;
}
void dijkstra()  // dijkstra最短路算法
{
	memset(flag,0,sizeof(flag));
	ans[1]=0;    //从 1 开始
	num[1]=1;
	q.push(make_pair(0,1));   //建边
	while(!q.empty())
	{
	int sum=q.top().second;   //找出堆顶元素
	q.pop();
	if(flag[sum])
	continue;
	flag[sum]=1;
	for(int i=head[sum];i;i=net[i]){
	int y=ver[i],z=ed[i];
	if(ans[y]>ans[sum]+z)   //如果发现更短的路径选择，就更新点的最小路径数
	{
		ans[y]=ans[sum]+z; // ans数组存储最少花费
		num[y]=num[sum];   // num数组存储最少路径的数量
		q.push(make_pair(-ans[y],y));
	}
	else
	if(ans[y]==ans[sum]+z)
	num[y]+=num[sum];  // 长度相同便把这个点的最少花费路径数加上它入度的最少花费路径  
	}
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	ans[i]=2147483647;   //将答案初始化成一个很大的数
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;    //输入边的信息
		if(chong[x][y]==z)  //判断重边，去重处理
		continue;
		add(x,y,z);  //建边
		chong[x][y]=z;
	}
	dij);
	if(ans[n]==2147483647)  //如果答案没有变化，输出 No answer
	cout<<"No answer"<<'\n';  
	else                   //否则输出答案
	cout<<ans[n]<<' '<<num[n]<<'\n';
	return 0;
}
```


---

## 作者：Acerkaio (赞：0)

### 题外话
建议先写这题 [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

可以说此题为 P1144 加强版。

### 思路
分为两个操作：

1. 我们只需要在 dijkstra 中检查是否会更新点，如果更新，则将被更新的点的最少花费路径数设为 $0$。

1. 如果一个点到另一个点的花费刚好为到达的点的最小花费，即再次到达了那个点，到达的点的最小花费路径数就会加上它入度的最少花费路径。

### 核心代码
操作一：
```cpp
if (d[y] > d[minn] + z) { //d 数组为最小花费，更新操作。
	d[y] = d[minn] + z;
	q.push(make_pair(-d[y], y));
	ans[y] = 0;
}
```

操作二：

```cpp
if (d[y] == d[minn] + z) {
	ans[y] += ans[minn];
}
```
### 小坑点
重边只算边权最小的就好了。

---


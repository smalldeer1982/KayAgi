# 小明的游戏

## 题目描述

小明最近喜欢玩一个游戏。给定一个 $n \times m$ 的棋盘，上面有两种格子 `#` 和 `@`。游戏的规则很简单：给定一个起始位置和一个目标位置，小明每一步能向上，下，左，右四个方向移动一格。如果移动到同一类型的格子，则费用是 $0$，否则费用是 $1$。请编程计算从起始位置移动到目标位置的最小花费。

## 说明/提示

对于20%的数据满足：$1 \le n, m \le 10$。   
对于40%的数据满足：$1 \le n, m \le 300$。   
对于100%的数据满足：$1 \le n, m \le 500$。   

## 样例 #1

### 输入

```
2 2
@#
#@
0 0 1 1
2 2
@@
@#
0 1 1 0
0 0```

### 输出

```
2
0```

# 题解

## 作者：NaCly_Fish (赞：29)

双权图，明显的双端队列BFS啊，题解里怎么没人写呢。。
****
这里简单介绍一下双端队列BFS吧：  

我们在用$\text{dijkstra}$跑最短路的时候，会用到堆优化，把当前最短路最小的点放到前面去。  
现在这个图的权要么是$0$，要么是$1$，如果还用堆来维护，似乎有些浪费了。  

这个时候我们就要用到双端队列，它支持查询队头、队尾，加入元素到队头、队尾。  
我们仍然希望距离大的点放后面，小的放前面，该怎么办呢？  
因为只有$0$和$1$两种权值，如果$u\rightarrow v$的边是$0$权，那就把$v$放在队头；否则放在队尾。  
现在原本$\Theta(\log n)$的堆优化，在这里只需要$\Theta(1)$了！

****
介绍完了双端队列BFS，那这题的做法就很明显了，直接套板子即可。  
为了方便，这里我直接用了STL，需要使用库$\text{deque}$。  
这样做的复杂度是$\Theta(nm)$的，在构造数据+大数据量的情况下，比$\text{SPFA}$和$\text{dijkstra}$ $\color{red}\text{都要快}$。  
一些关键的部分我加了注释，没太明白的可以看看。

代码奉上：  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
#include<deque>
#include<vector>
#define N 503
#define inf 0x3f3f3f3f
#define ll long long
using namespace std;

struct node{
    int x,y;
    node(int x=0,int y=0):x(x),y(y){}
};

char a[N][N];
bool vis[N][N];
int d[N][N];
const int dx[4] = {0,0,1,-1};
const int dy[4] = {1,-1,0,0};
int n,m,x1,y1,x2,y2;

inline void read(int &x);
void print(int x);
void bfs();

int main(){
    while(1){
        read(n),read(m);
        if(n==0&&m==0) break;
        for(int i=1;i<=n;++i){
            int j = 0;
            char c = getchar();
            while(c!='#'&&c!='@') c = getchar(); 
            while(c=='#'||c=='@'){
                a[i][++j] = c;
                c = getchar();
            }
        }
        read(x1),read(y1),read(x2),read(y2);
        ++x1,++y1,++x2,++y2;
        bfs();
        print(d[x2][y2]);
        putchar('\n');
    }
    return 0;
}

void bfs(){
    int x,y,nx,ny,w;
    memset(d,inf,sizeof(d));
    memset(vis,0,sizeof(vis));
    d[x1][y1] = 0;
    deque<node> q; //新建一只双端队列
    q.push_back(node(x1,y1));
    while(!q.empty()){
        x = q.front().x;
        y = q.front().y;
        q.pop_front();
        if(vis[x][y]) continue; //由于是bfs,所以要判断有没有来过,来过了就不用再来了
        vis[x][y] = true;
        for(int i=0;i<4;++i){ //遍历周围格子
            nx = x+dx[i];
            ny = y+dy[i];
            if(nx>n||nx<1||ny>m||ny<1) continue; //判断是否越界
            w = a[nx][ny]!=a[x][y]; //确定边权,一样为1,不一样为0
            if(d[x][y]+w>=d[nx][ny]) continue; //松弛操作
            d[nx][ny] = d[x][y]+w;
            if(w==0) q.push_front(node(nx,ny)); //0权放前面
            else q.push_back(node(nx,ny)); //1权放后面
        }
    }
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    } 
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

最后再推荐一道双端队列BFS的例题：  
[ [BalticOI 2011 Day1] Switch the Lamp On](https://www.luogu.org/problemnew/show/P4667)

---

## 作者：pipiispig (赞：11)

##
其实呀....这个题可以用01BFS来做QwQ,美名其曰双端队列（deque）;
##
那么什么是01BFS呢？就是一个维护了双端队列的BFS，边权为1时向后插入为0时向前插入的说，例题的话应该就是电路问题了吧（比这个题要难的说）；
当然有简单的SPOJ KATHTHI - KATHTHI呀，可以试试QwQ;

```
#include<iostream>
#include<cstdio>
#include<deque>
#include<cstring>
using namespace std;

const int N=505;

int n,m,x1,x2,y1,y2;

char s[N][N];

int vis[N][N];

int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};

struct node
{
	int x;
	int y;
	int z;
	char c;	
};

int main()
{
	while(scanf("%d%d",&n,&m)&&n&&m)
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				cin>>s[i][j];
			}
		}
		cin>>x1>>y1>>x2>>y2;
		x1++,y1++,x2++,y2++;//敲黑板：他给的图是0~n-1,而我的是1~n所以只好它的坐标都+1了QwQ,论没读好题的后果；
		deque<node>q;
		memset(vis,0,sizeof(vis));
		q.push_back((node){x1,y1,0,s[x1][y1]});
		vis[x1][y1]=1;
		while(!q.empty())
		{
			node w=q.front();q.pop_front();//是pop_front()!!!不是pop_back()；
			if(w.x==x2&&w.y==y2)
			{
				cout<<w.z<<endl;
				break;
			}
			for(int i=0;i<4;i++)
			{
				int xx=w.x+dx[i];
				int yy=w.y+dy[i];
				if(xx>n||yy>m||xx<1||yy<1||vis[xx][yy])continue;
				vis[xx][yy]=1;
				if(s[xx][yy]==w.c)q.push_front((node){xx,yy,w.z,w.c});//根据边权的值分开判断呀
				else q.push_back((node){xx,yy,w.z+1,s[xx][yy]});//与上一句一样的废话QwQ;
			}
		}
	}
}
```
是不是很简单就AC了？完全不需要最短路和spfa呢，时间复杂度也相当优秀，如果手写双端队列的话应该跟快吧QwQ
01BFS可以在O(n+m)求出边权只有0/1的最短路

---

## 作者：Eleven谦 (赞：9)

# 小明的游戏
[题目传送门qwq](https://www.luogu.com.cn/problem/P4554)

#### 前言

说实话，刚拿到这道题，我因为懒得将坐标转换为一个编号，所以直接淦的二维最短路（~~明明二维最短路更麻烦好吧~~）

在用二维做法A掉这题后，另外写了正常点的常规最短路

本篇题解将会介绍这**两种**做法

#### 提醒

这道题给出的起点和终点的坐标都是从 **$0$开始的**

所以建图那些是从$1$到$N$的话，请对起点终点坐标++（虽过不了样例也会提醒你这个$point$)

------------
#### 算法证明

这题一看就是道搜索（$DFS$会被$T$掉，$BFS$的双端队列可以过）

但是这题也能跑最短路，**将四个方向转换为连边**，然后从$1$到$N$求得最短距离即可

------------
#### 二维最短路

（~~啊我真优秀~~）

二维实现最短路还是调了一点时间的，这里就罗列一下我主要遇到的两个问题：

1. 建图连边的时候，有向边的方向没有搞清楚（两种做法都要注意）

2. 不知道$Dijkstra$的优先队列对于二维最短路怎么进行存储和排序

然后我们再根据上面两个问题的解决，来讨论思路

- 有向边的方向

当前点向四个方向扩展，如果合法，那么有向边当然是**当前点连向其他点**

注意一下：**向四个方向扩展时要判断是否越界！**

- 优先队列维护二维最短路

在自定义结构体内使用**重载运算符！**

代码段：

```cpp
struct node {
    int val,tx,ty,net;   //val是花费，tx是下一个点的横坐标，ty是纵坐标
    bool operator < (const node &x )const {  //重载运算符
        return val>x.val;
    }
} e[5200010];

priority_queue<node> q;
```
这样定义后，在跑二维最短路的时候就可以正常维护啦

- 二维最短路代码

```cpp
#include <bits/stdc++.h>
using namespace std;
char s[5001][5001];
int n,m,sx,sy,ex,ey;
int tot,dis[5001][5001],vis[5001][5001],head[5001][5001];

struct node {
	int val,tx,ty,net;
	bool operator < (const node &x )const {
		return val>x.val;
	}
} e[5200010];

priority_queue<node> q;  //重载运算符之后的优先队列 

inline void add(int fx,int fy,int nx,int ny,int w) {  //连边 
	e[++tot].tx=nx;
	e[tot].ty=ny;
	e[tot].val=w;
	e[tot].net=head[fx][fy];
	head[fx][fy]=tot;
}

inline void dijkstra(int fx,int fy) {
	for(register int i=1;i<=n;i++) {
		for(register int j=1;j<=m;j++) {
			vis[i][j]=0;
			dis[i][j]=20050206;
		}
	}
	dis[fx][fy]=0;
	q.push((node) {
		0,fx,fy
	});
	while(!q.empty()) {
		int x=q.top().tx;
		int y=q.top().ty;
		q.pop();
		if(vis[x][y]) continue;
		vis[x][y]=1;
		for(register int i=head[x][y];i;i=e[i].net) {
			int vx=e[i].tx;
			int vy=e[i].ty;
			if(dis[vx][vy]>dis[x][y]+e[i].val) {
				dis[vx][vy]=dis[x][y]+e[i].val;
				q.push((node) {
					dis[vx][vy],vx,vy  //这里dis[]就不用取反啦 
				});
			}
		}
	}
}

int main() {
	while(scanf("%d%d",&n,&m)) {
		if(n==0&&m==0) break;
		tot=0;  //记得清零 
		memset(head,0,sizeof(head));
		for(register int i=1;i<=n;i++) {
			for(register int j=1;j<=m;j++) {
				cin>>s[i][j];
			}
		}
		scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
		sx++;sy++;   //注意输入是从0开始 
		ex++;ey++;
		for(register int i=1;i<=n;i++) {  //如果给您的眼睛带来不适，我很抱歉QAQ 
			for(register int j=1;j<=m;j++) {
				if(s[i-1][j]==s[i][j]&&i-1>=1) add(i,j,i-1,j,0);
				if(s[i-1][j]!=s[i][j]&&i-1>=1) add(i,j,i-1,j,1);
				
				if(s[i][j-1]==s[i][j]&&j-1>=1) add(i,j,i,j-1,0);
				if(s[i][j-1]!=s[i][j]&&j-1>=1) add(i,j,i,j-1,1);
				
				if(s[i+1][j]==s[i][j]&&i+1<=n) add(i,j,i+1,j,0);
				if(s[i+1][j]!=s[i][j]&&i+1<=n) add(i,j,i+1,j,1);
				
				if(s[i][j+1]==s[i][j]&&j+1<=m) add(i,j,i,j+1,0);
				if(s[i][j+1]!=s[i][j]&&j+1<=m) add(i,j,i,j+1,1);
			}
		}
		dijkstra(sx,sy);
		printf("%d\n",dis[ex][ey]);
	}
	return 0;
}
```


------------
#### 常规最短路

讲真，常规最短路其实就是上面二维最短路的优化（二维最短路属于不动脑子，直接给什么做什么，常规的最短路就需要转换，但是转换之后代码更简便也更容易实现）

- 坐标转换为编号

为什么要将坐标转换为编号？因为这样我们就**将维护二维最短路改成常规的最短路了**，接下来就不用想什么重载运算符后用优先队列维护三个值了

- 常规最短路代码$Code$

因为常规最短路的思路真的很简单，就是跑板子，所以直接给代码啦qwq

```cpp
#include <bits/stdc++.h>
using namespace std;
char s[510][510];
int n,m,sx,sy,ex,ey,tot,cnt;
deque<int> q;
int sum[510][510],dis[520010],vis[520010],head[520010];

struct node {
	int to,net,val;
} e[520010];

inline void add(int u,int v,int w) {
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].net=head[u];
	head[u]=tot;
}

inline void spfa(int s) {
	for(register int i=1;i<=cnt;i++) {
		vis[i]=0;
		dis[i]=20050206;
	}
	dis[s]=0;
	vis[s]=1;
	q.push_back(s);
	while(!q.empty()) {
		int x=q.front();
		q.pop_front();
		vis[x]=0;
		for(register int i=head[x];i;i=e[i].net) {
			int v=e[i].to;
			if(dis[v]>dis[x]+e[i].val) {
				dis[v]=dis[x]+e[i].val;
				if(!vis[v]) {
					vis[v]=1;
					if(!q.empty()&&dis[q.front()]<dis[v]) q.push_back(v);
					else q.push_front(v);
				}
			}
		}
	}
}

int main() {
	while(scanf("%d%d",&n,&m)) {
		if(n==0&&m==0) break;
		tot=0;cnt=0;
		memset(sum,0,sizeof(sum));
		memset(head,0,sizeof(head));
		for(register int i=1;i<=n;i++) {
			for(register int j=1;j<=m;j++) {
				cin>>s[i][j];
				sum[i][j]=++cnt;  //用编号代替坐标
			}
		}
		scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
		sx++;sy++;ex++;ey++;
		for(register int i=1;i<=n;i++) {
			for(register int j=1;j<=m;j++) {  //如果又给您的眼睛带来不适，我再次感到很抱歉QAQ 
				if(s[i][j]==s[i-1][j]&&i-1>0) add(sum[i][j],sum[i-1][j],0);
				if(s[i][j]!=s[i-1][j]&&i-1>0) add(sum[i][j],sum[i-1][j],1);
				
				if(s[i][j]==s[i][j-1]&&j-1>0) add(sum[i][j],sum[i][j-1],0);
				if(s[i][j]!=s[i][j-1]&&j-1>0) add(sum[i][j],sum[i][j-1],1);
				
				if(s[i][j]==s[i+1][j]&&i+1<=n) add(sum[i][j],sum[i+1][j],0);
				if(s[i][j]!=s[i+1][j]&&i+1<=n) add(sum[i][j],sum[i+1][j],1);
				
				if(s[i][j]==s[i][j+1]&&j+1<=m) add(sum[i][j],sum[i][j+1],0);
				if(s[i][j]!=s[i][j+1]&&j+1<=m) add(sum[i][j],sum[i][j+1],1);
			}
		}
		spfa(sum[sx][sy]);
		printf("%d\n",dis[sum[ex][ey]]);
	}
	return 0;
}
```

------------

嗯...写完了...

最后，如果这篇题解有任何错误或您不懂的地方，欢迎下方留言区评论，我一定会及时回复、改正

谢谢各位dalao啊qwq

------------






---

## 作者：daqirui (赞：9)

### SPFA代码实现
#### 其实就是最短路的进阶版
#### 加上权值就可以了
#### 如果符号相等，则权值为0
#### 如果符号不相等，则权值为1
#### 其他都一样
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
const int MAXN=500,INF=2147483647,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
int n,m,x1,y1,x2,y2,d[MAXN*MAXN],V,E,nx,ny;
bool inq[MAXN*MAXN];
char map[MAXN][MAXN+1];
struct edge{
	int from,to,cost;
	edge(){}
	edge(int a,int b,int c){
		from=a;
		to=b;
		cost=c;
	}
};
vector<edge> edges;
vector<int> G[MAXN*MAXN];
void graph_init(){
	for(int i=0;i<n;i++){
		G[i].clear();
	}
	edges.clear();
}
void addedge(int from,int to,int cost){
	edges.push_back(edge(from,to,cost));
	G[from].push_back(edges.size()-1);
}
void SPFA(int s){
	for(int i=0;i<V;i++){
		d[i]=INF;
		inq[i]=false;
	}
	d[s]=0;
	queue<int> Q;
	Q.push(s);
	inq[s]=true;
	while(!Q.empty()){
		int u=Q.front();
		Q.pop();
		inq[u]=false;
		for(int i=0;i<G[u].size();i++){
			edge e=edges[G[u][i]];
			if(d[u]<INF&&d[e.to]>d[u]+e.cost){
				d[e.to]=d[u]+e.cost;
				if(!inq[e.to]){
					Q.push(e.to);
					inq[e.to]=true;
				}
			}
		}
	}
}
int main(){
	while(cin>>n>>m){
		if(n==0&&m==0){
			break;
		}
		V=n*m;
		graph_init();
		for(int i=0;i<n;i++){
			cin>>map[i];
		}
		cin>>x1>>y1>>x2>>y2;
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				for(int k=0;k<4;k++){
					nx=i+dx[k];
					ny=j+dy[k];
					if(0<=nx&&nx<n&&0<=ny&&ny<m){
						if(map[i][j]==map[nx][ny]){
							addedge(i*m+j,nx*m+ny,0);
						}
						else{
							addedge(i*m+j,nx*m+ny,1);
						}
					}
				}
			}
		}
		SPFA(x1*m+y1);
		cout<<d[x2*m+y2]<<endl;
	}
	return 0;
}

```

---

## 作者：流逝丶 (赞：7)

每个点向它旁边的点连边，相同dis为0，不同为1。

n=3,m=3每个点的标号如下:

1 2 3 

4 5 6

7 8 9

这样安排标号唯一，标号计算公式$（i-1）* m+j$,连边时判断一下边界，因为题目默认坐标是从（0,0）开始，所以方便做题，将读入的起点和终点坐标都加1。然后跑个最短路就可以了


```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
int n,m;
int ex,ey,px,py;
int a[505][505];
char ch[255];

struct node{
	int to,nxt,dis;
}e[20000005];
int head[250005],cnt,dis[250005],in[250005];
inline void add(int from,int to,int dis){
	e[++cnt]=(node){to,head[from],dis};
	head[from]=cnt;
}
void spfa(){
	queue<int>q;
	for(int i=1;i<=n*m;++i)
		dis[i]=2000000000,in[i]=0;
	dis[(ex-1)*m+ey]=0;
	in[(ex-1)*m+ey]=1;
	q.push((ex-1)*m+ey);
	while(!q.empty()){
		int now=q.front();
		q.pop();
		in[now]=0;
		for(int i=head[now];i;i=e[i].nxt)
			if(dis[now]+e[i].dis<dis[e[i].to]){
				dis[e[i].to]=dis[now]+e[i].dis;
				if(!in[e[i].to]){
					q.push(e[i].to);
					in[e[i].to]=1;
				}
			}
	}
	printf("%d\n",dis[(px-1)*m+py]);
}
int main(){
	while(scanf("%d%d",&n,&m)){
		if(n==0&&m==0)break;
		cnt=0;
		memset(head,0,sizeof(head));
		for(int i=1;i<=n;++i){
			scanf("%s",ch+1);
			for(int j=1;j<=m;++j){
				if(ch[j]=='@')a[i][j]=1;
				else a[i][j]=0;
			}	
		}
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j){
				if(i>1)
					add((i-1)*m+j,(i-2)*m+j,a[i][j]^a[i-1][j]),add((i-2)*m+j,(i-1)*m+j,a[i][j]^a[i-1][j]);
				if(i<n)
					add((i-1)*m+j,i*m+j,a[i][j]^a[i+1][j]),add(i*m+j,(i-1)*m+j,a[i][j]^a[i+1][j]);
				if(j>1)
					add((i-1)*m+j,(i-1)*m+j-1,a[i][j]^a[i][j-1]),add((i-1)*m+j-1,(i-1)*m+j,a[i][j]^a[i][j-1]);
				if(j<m)
					add((i-1)*m+j,(i-1)*m+j+1,a[i][j]^a[i][j+1]),add((i-1)*m+j+1,(i-1)*m+j,a[i][j]^a[i][j+1]);
			}
		scanf("%d%d%d%d",&ex,&ey,&px,&py);
		ex++;ey++;px++;py++;
		spfa();
	}
	return 0;
}
```


---

## 作者：LitShone (赞：6)

# 不用建图的bfs！~~（好久不bfs了）~~

debug一个小时后终于a了（感谢[HG1](https://www.luogu.org/space/show?uid=115947)的帮助!）

机房大佬有的缩点有的建图，~~我一个究极蒟蒻却用bfs~~

点开题解都需要建图，我决定给大家分享一种简单的做法，58行465ms的bfs

------------
思路就是利用spfa的原理，找二维最短路

需要注意的点：y1不能用！！！！！！
还有就是点从0开始！！！！~~（debug半小时才检查出来）~~

话不多说，自以为代码简洁明了，里面有注释！！
上代码！

------------


```cpp
#include <bits/stdc++.h>
#define I return
#define like 0
#define guanliyuan ;
#define int long long//微操微操
using namespace std;

int n,m,x1,x2,y3,y2;
int dis[501][501],vis[501][501];
char mp[501][501];
int dx[5]={0,1,0,-1,0};
int dy[5]={0,0,1,0,-1};
queue<int> qx;
queue<int> qy;

void spfa(){
	int x,y;
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	qx.push(x1);
	qy.push(y3);
	vis[x1][y3]=1;
	dis[x1][y3]=0;
	while(qx.size()&&qy.size()){//开始宽搜
		x=qx.front();qx.pop();
		y=qy.front();qy.pop();
		for(int i=1;i<=4;i++){
			if(x+dx[i]<n&&x+dx[i]>=0&&y+dy[i]>=0&&y+dy[i]<m){
				int D=(mp[x][y]!=mp[x+dx[i]][y+dy[i]]);//由题意得微操，减少代码长度
				if(dis[x+dx[i]][y+dy[i]]>dis[x][y]+D){//如果可以就更新
					dis[x+dx[i]][y+dy[i]]=dis[x][y]+D;
					if(!vis[x+dx[i]][y+dy[i]]){//注意x,y不可更新！！
						qx.push(x+dx[i]);qy.push(y+dy[i]);
						vis[x+dx[i]][y+dy[i]]=1;
					}
				}
			}
		}
		vis[x][y]=0;//与spfa思路相似
	}
}

signed main(){//与define int long long配套的设施
	char a;
	n=1;m=1;
	while(1){
		scanf("%ld%ld",&n,&m);
		if(n==0&&m==0) break;
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++){
				cin>>a;
				mp[i][j]=a;
			}
		scanf("%ld%ld%ld%ld",&x1,&y3,&x2,&y2);
		spfa();
		cout<<dis[x2][y2]<<endl;
	}
	I like guanliyuan//邹老板微操
}
```


---

## 作者：January的忧伤 (赞：5)

简单最短路，感觉和[这题](https://www.luogu.org/problemnew/show/P4667)的建图方式比较像。    
### 正文部分:         
因为空间足够，所以我们并不需要$O(1)$的哈希算法，可以考虑开一个数组$mark[i][j]$表示第$i$行第$j$列所对应的编号。初始化的时候将整个矩阵遍历一遍然后将计数器$tot++$就好了。     
如何建图？       
我们已经处理出了每个点的编号，然后就跟$dfs$一样创建一个$dir$数组，往$4$个方向拓展，如何相同则权值为$1$,否则则为$0$。    
之后跑一遍最短路就好了。      
顺便提一句，这题不卡$spfa$,不需要$Dijkstra$。      
代码我就不放了，实现难度应该不是很大。

---

## 作者：zhengrunzhe (赞：4)

提供一个~~Dijkstrea~~pDijkstra+Heap

若用map[i][j]表示棋盘，与上的连边权值就是map[i][j]!=map[i-1][j]，左右下以此类推

二维数组搞最短路不好搞，给他改成一维。坐标(x,y)对应的编号是(x-1)*m+y

共n²个点，每个点至多有上下左右四个连边，最大边数为4n²

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<utility>
#include<algorithm>
#define num(x,y) (x-1)*m+y
using namespace std;
typedef pair<int,int>heap;
const int N=510;
bool vis[N*N];
int n,m,cnt,head[N*N],sx,sy,ex,ey,d[N*N];
char map[N][N];
struct edge{int to,next;bool w;}e[N*N*4];
inline void addedge(int u,int v,bool w)
{
	e[++cnt].next=head[u];
	head[u]=cnt;
	e[cnt].to=v;
	e[cnt].w=w;
}
inline int dijkstra(int s,int t)
{
	memset(d,0x7f,sizeof(d));memset(vis,0,sizeof(vis));
	priority_queue<heap,vector<heap>,greater<heap> >q; //pair优先队列做小根堆
	q.push(make_pair(d[s]=0,s));
	while (q.size())
	{
		int u=q.top().second;q.pop();
		if (vis[u])continue;vis[u]=1;
		for (int v,i=head[u];i;i=e[i].next)
			if (!vis[v=e[i].to]&&d[v]>d[u]+e[i].w)
				q.push(make_pair(d[v]=d[u]+e[i].w,v));
	}
	return d[t];
}
int main()
{
	while (scanf("%d%d",&n,&m)==2&&n+m)
	{
		cnt=0;
		memset(head,0,sizeof(head)); //刚开始这个没清零一直错…
		for (int i=1;i<=n;i++)
			for (int j=1;j<=m;j++)
				scanf(" %c",&map[i][j]);
		for (int i=1;i<=n;i++)
			for (int j=1;j<=m;j++) //建边，其实写个方向数组更方便但是我懒得改了
			{
				if (i>1)addedge(num(i,j),num(i-1,j),map[i][j]!=map[i-1][j]);
				if (i<n)addedge(num(i,j),num(i+1,j),map[i][j]!=map[i+1][j]);
				if (j>1)addedge(num(i,j),num(i,j-1),map[i][j]!=map[i][j-1]);
				if (j<m)addedge(num(i,j),num(i,j+1),map[i][j]!=map[i][j+1]);
			}
		scanf("%d%d%d%d",&sx,&sy,&ex,&ey);sx++;sy++;ex++;ey++; //题目给的坐标是从零开始…转成1开始比较方便
		printf("%d\n",dijkstra(num(sx,sy),num(ex,ey)));
	}
	return 0;
}
```

---

## 作者：you_xiao (赞：3)

这道题呢，很多人都想到单源最短路，然后就去建边，跑图，然后AC，

这真的必要吗？

其实dij是很优秀的，但是很多时候会被奇怪的图卡爆空间和时间

比如下面这一题

[飞飞侠（国集）](https://www.luogu.org/problem/P4473)
以及[题解](https://www.luogu.org/blog/xcgzyouxiao/solution-p4473)

大家都是定式思维，看到图就是边，看到边就去存，往往忘记了边的意义

## 边的存在只是告诉你前进方向

如果方向很明确，那么边就没有意义，甚至成为累赘

所以说，

# 我又不存边了！！！教练！！

我们看，一个格子可以向上下左右走，这是可以抽象成为mp数组的，

并且格子位置有序，就可以直接找到周围的四个格子，

那么就不需要边来指引了，

对于dij的过程，建立以dis为依据，顺便存一下坐标的优先队列，

然后像宽搜一样打就好了。。。

一样的就不加，不一样的加一  XD

（话说直接叫宽搜不好吗？？？）

（或者 ~~优先队列优化的记忆化启发式宽搜？？？~~）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,mp[550][550],dis[550][550],yd[2][4]={{1,-1,0,0},{0,0,1,-1}};
bool b[550][550];
const int inf=0x3fffffff;
struct dd{
	int x,y;
}st,ed;

void fake_dij(){
	priority_queue< pair<int,pair<int,int> > >que;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			dis[i][j]=inf;
			b[i][j]=0;
		}
	}
	dis[st.x][st.y]=0;
	que.push(make_pair(0,make_pair(st.x,st.y)));
	while(que.size()){
		dd x=(dd){que.top().second.first,que.top().second.second};que.pop();
		if(b[x.x][x.y])continue;
		for(int i=0;i<4;i++){
			int xx=x.x+yd[0][i],yy=x.y+yd[1][i];
			if(mp[xx][yy]){
				if(mp[xx][yy]!=mp[x.x][x.y]){
					if(dis[xx][yy]>dis[x.x][x.y]+1){
						dis[xx][yy]=dis[x.x][x.y]+1;
						if(!b[xx][yy])que.push(make_pair(-dis[xx][yy],make_pair(xx,yy)));
					} 
				}
				else {
					if(dis[xx][yy]>dis[x.x][x.y]){
						dis[xx][yy]=dis[x.x][x.y];
						if(!b[xx][yy])que.push(make_pair(-dis[xx][yy],make_pair(xx,yy)));
					}
					
				}
			}
		} 
	}
	printf("%d\n",dis[ed.x][ed.y]);
}

int main(){
	while(1){
		scanf("%d%d",&n,&m);
		if(n==0&&m==0)return 0;
		memset(mp,0,sizeof(mp));
		char ch;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				ch=getchar();
				while(ch!='@'&&ch!='#')ch=getchar();
				if(ch=='@')mp[i][j]=1;
				else mp[i][j]=2; 
			} 
		}
		scanf("%d%d%d%d",&st.x,&st.y,&ed.x,&ed.y);
		st.x++;st.y++;ed.x++;ed.y++;
		fake_dij();
	}
	return 0;
}
```
没有了建边操作的dij真是爽快呢，就像新年的清晨穿上新的内裤一样清爽呢。。。


---

## 作者：黄汝鹏 (赞：3)

题目大意：给你一张图，两两之间边的权值有的为1，有的为0，求最小值，应该这样简化题目会有些眼熟，没错，spfa模板题，不过要加上降维（二维->一维），降维公式
```cpp
i*m+j
```
上代码吧，60分代码——邻接链表储存（我也不知为啥错QWQ，~~大佬帮忙~~）
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
#include<string>
#include<queue>
#include<algorithm>
using namespace std;
const int N = 500*500+10;
queue<int> q;
int n,m,xa,xb,ya,yb,num;
int head[N],d[N],v[N];
int dx[]={0,0,1,-1};
int dy[]={-1,1,0,0};
char f[500+10][500+10];
int boundary(int a,int b)
{
	if((a<0)||(a>n)||(b>m)||(b<0)) return 0;
	return 1;
}
struct come{
	int to,next,cost;
}edge[N*2];
void add_edge(int from,int to,int cost)
{
	num++;
	edge[num].to=to;
	edge[num].cost=cost;
	edge[num].next=head[from];
	head[from]=num;
}
void spfa(int s)
{
	memset(v,0,sizeof(v));
	memset(d,0x3f,sizeof(d));
	d[s]=0,v[s]=1;
	q.push(s);
	while(q.size())
	{
		int u=q.front();
		q.pop();
		v[u]=0;
		for(int i=head[u];i;i=edge[i].next)
		{
			int to=edge[i].to;
			int cost=edge[i].cost;
			if(d[to]>d[u]+cost)
			{
				d[to]=d[u]+cost;
				if(!v[to]) q.push(to),v[to]=1;
			}
		}
	}
}
int main()
{
	while(cin>>n>>m)
	{
		while(!q.empty()) q.pop();
		if(n==0&&m==0) break;
		for(int i=0;i<n;i++)
		    for(int j=0;j<m;j++)
		        cin>>f[i][j];
		cin>>xa>>ya>>xb>>yb;
		for(int i=0;i<n;i++)
		    for(int j=0;j<m;j++)
		        for(int k=0;k<4;k++)
		        {
		        	int aa=i+dx[k];
		        	int bb=j+dy[k];
		        	if(boundary(aa,bb)==1)
		        	{
		        		if(f[i][j]==f[aa][bb])
						    add_edge(i*m+j,aa*m+bb,0);
		        	    else
		        	        add_edge(i*m+j,aa*m+bb,1);
		        	}
		        }
		spfa(xa*m+ya);
		cout<<d[xb*m+yb]<<endl;
	}
	return 0;
} 
```
第二次，vecter，我也用的不太熟练，但AC了(O~OY)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
#include<string>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;
const int N = 500*500+10,INF=2147483647;
int n,m,xa,xb,ya,yb,num;
int head[N],d[N],v[N];
int dx[]={0,0,1,-1};
int dy[]={-1,1,0,0};//四方位
char f[500+10][500+10];
int boundary(int a,int b)//判断边界
{
	if((a<0)||(a>n)||(b>m)||(b<0)) return 0;
	return 1;//记住，先a——n，b——m,血的教训
}
struct come
{
    int from,to,cost;
    come(){}
    come(int a,int b,int c)
	{
        from=a;
        to=b;
        cost=c;
    }
};
vector<come> edge;
vector<int> G[N];
void gg(){
    for(int i=0;i<n;i++)
        G[i].clear();
    edge.clear();
}
void add_edge(int from,int to,int cost)
{
    edge.push_back(come(from,to,cost));
    G[from].push_back(edge.size()-1);
}
void spfa(int s)
{
	queue<int> q;
	for(int i=0;i<n*m;i++)
	{
		v[i]=0;
		d[i]=INF;
	}
	d[s]=0,v[s]=1;
	q.push(s);
	while(q.size())
	{
		int u=q.front();
		q.pop();
		v[u]=0;
		for(int i=0;i<G[u].size();i++)
		{
			come e=edge[G[u][i]];
			int to=e.to;
			int cost=e.cost;
			if(d[to]>d[u]+cost)
			{
				d[to]=d[u]+cost;
				if(!v[to])    q.push(to),v[to]=1;
			}
		}
	}
}
int main()
{
	while(cin>>n>>m)
	{
		if(n==0&&m==0) break;
		gg();
		for(int i=0;i<n;i++)
		    cin>>f[i];
		cin>>xa>>ya>>xb>>yb;
		for(int i=0;i<n;i++)
		    for(int j=0;j<m;j++)
		        for(int k=0;k<4;k++)
		        {
		        	int aa=i+dx[k];
		        	int bb=j+dy[k];
		        	if(boundary(aa,bb)==1)
		        	{
		        		if(f[i][j]==f[aa][bb])
						    add_edge(i*m+j,aa*m+bb,0);
		        	    else
		        	        add_edge(i*m+j,aa*m+bb,1);
		        	}
		        }
		spfa(xa*m+ya);
		cout<<d[xb*m+yb]<<endl;
	}
	return 0;
} 
```
撰文不易，大佬轻喷，管理大大求通过

热爱编程，永不放弃，不服努力终得志

---

## 作者：在想Peach (赞：2)

本弱鸡并不会01bfs也不想打最短路，用联通块缩点（伪）处理，这样每个点之间的边都是1，直接bfs就行。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=1000005;
struct node
{
	int pos,ans;
};
int n,m,cnt,dx[5]={1,-1,0,0},dy[5]={0,0,1,-1},sx,sy,tx,ty,st,tt;
int from[505][505],head[maxn],nxt[maxn],to[maxn],tot;
char s[505][505];
bool p[maxn];
queue<node>q;
inline int read()
{
	char z=getchar();int x=0,y=1;
	while(z<'0'||z>'9'){if(z=='-')y=-1;z=getchar();}
	while(z<='9'&&z>='0'){x=x*10+z-'0';z=getchar();}
	return x*y;
}
inline void add(int x,int y)
{
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
inline void dfs(int x,int y)
{
	for(register int i=0;i<4;i++)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if(nx>0&&ny>0&&nx<=n&&ny<=m)
		{
			if(s[x][y]==s[nx][ny]&&!from[nx][ny])
			{
				from[nx][ny]=from[x][y];
				dfs(nx,ny);
				
			}
		}
	}
}
int main()
{
	while(1)
	{
		n=read();m=read();
		if(n==0&&m==0)return 0;
		memset(from,0,sizeof(from));cnt=0;
		memset(head,0,sizeof(head));tot=0;
		memset(p,0,sizeof(p));
		for(register int i=1;i<=n;i++)
			scanf("%s",s[i]+1);
		sx=read();sy=read();tx=read();ty=read();
		sx++;sy++;tx++;ty++;
		for(register int i=1;i<=n;i++)
			for(register int j=1;j<=m;j++)
				if(!from[i][j])from[i][j]=++cnt,dfs(i,j);
		for(register int i=1;i<=n;i++)
			for(register int j=1;j<=m;j++)
				for(register int k=0;k<4;k++){
					int nx=i+dx[k],ny=j+dy[k];
					if(nx>0&&ny>0&&nx<=n&&ny<=m)
						if(from[i][j]!=from[nx][ny])
							add(from[i][j],from[nx][ny]);
				}
		st=from[sx][sy];tt=from[tx][ty];
		p[st]=1;
		q.push((node){st,0});
		while(!q.empty())
		{
			node u=q.front();q.pop();
			if(u.pos==tt){printf("%d\n",u.ans);break;}
			for(register int i=head[u.pos];i;i=nxt[i])
			{
				int g=to[i];
				if(p[g])continue;
				p[g]=1;
				q.push((node){g,u.ans+1});
			}
		}
		while(!q.empty())q.pop();
	}
}
```


---

## 作者：按Ctrl加w会AC (赞：2)

一开始数据似乎是挂了

开尽了优化,交了整整一页

就是简单的 bfs

```cpp
#include <cstdio>
#include <bitset>
#include <cstring>
#include <algorithm>
#define __R register
using namespace std;
typedef pair <int,int> pii;

const int MAXN=1005,MAXQ=1000005,inf=0x3f3f3f3f,dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
int n,m,sx,sy,tx,ty,dis[MAXN][MAXN];
bool p; bitset <MAXN> vis[MAXN];
char mp[MAXN][MAXN];

inline char getc(){
	static const int IN_LEN=10000000;
    static char buf[IN_LEN],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,IN_LEN,stdin),p1==p2)?EOF:*p1++;
}
template <typename T>
inline void read(T &x){
	x=0; __R char ch; __R bool fl=0;
	while (ch=getc(),ch<48||57<ch) fl^=ch=='-'; x=(ch&15);
	while (ch=getc(),47<ch&&ch<58) x=(x<<1)+(x<<3)+(ch&15);
	if (fl) x=-x;
}
void readc(char &x){
	while (x=getc(),x!='@'&&x!='#');
}

struct STACK{
	int num[2][MAXQ],size;
	void clear(){
		size=0;
	}
	void push(int x,int y){
		size++;
		num[0][size]=x;
		num[1][size]=y;
	}
} Q[2];

int P[MAXQ][2];
void bfs(int x_,int y_){
	int Head=0,Tail=1;
	P[Tail][0]=x_,P[Tail][1]=y_;
	vis[x_][y_]=1;
	while (Head!=Tail){
		Head++;
		int x=P[Head][0],y=P[Head][1];
		for (int i=0;i<4;i++){
			int nx=x+dir[i][0],ny=y+dir[i][1];
			if (nx<1||ny<1||n<nx||m<ny||vis[nx][ny]) continue;
			if (mp[nx][ny]!=mp[x_][y_]){
				if (dis[nx][ny]==inf) Q[p^1].push(nx,ny),dis[nx][ny]=dis[x_][y_]+1; 
				continue;
			}
			vis[nx][ny]=1;
			dis[nx][ny]=dis[x_][y_];
			++Tail;
			P[Tail][0]=nx,P[Tail][1]=ny;
		}
	}
}

inline void work(){
	for (int i=1;i<=n;i++){
		vis[i].reset();
		for (int j=1;j<=m;j++)
			dis[i][j]=inf;	
	}
	dis[sx][sy]=0;
	int Head=0,Tail=1;
	Q[p=0].clear();
	Q[p].push(sx,sy);
	while (1){
		Q[p^1].clear();
		for (int i=1;i<=Q[p].size;i++){
			int x=Q[p].num[0][i];
			int y=Q[p].num[1][i];
			bfs(x,y);
		}
		if (dis[tx][ty]!=inf) break;
		p^=1;
	}
	printf("%d\n",dis[tx][ty]);
}

int main(){
	while (read(n),read(m),n&&m){
		for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			readc(mp[i][j]);
		read(sx),read(sy),read(tx),read(ty);
		sx++,sy++,tx++,ty++;
		work();
	}
	return 0;
}
```

---

## 作者：_jimmywang_ (赞：1)

此题每个点向相邻的点连边，不一样的边权为$1$,一样的是$0$

然后每个点都有一个编号，点$(i,j)$的编号是$i*m+j+1$

所以一个$2*2$的矩阵就是

1 2

3 4

于是跑最短路就行了

$code$:

```
#include<algorithm>
#include<bitset>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<map>
#include<iostream>
#include<queue>
#include<set>
#include<stack>
#include<string>
#include<vector>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
inline ll read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
#define d read()
struct edge{
	ll u,v,w,nx;
}e[1000010];
ll n,m,tot;
ll dis[100010];

ll head[1000010];
bool vis[500010];
bool mp[510][510];
struct node{
	ll w,now;
	inline bool operator <(const node &x)const{
		return w>x.w;
	}
};
ll k(ll i,ll j){return i*m+j+1;}

priority_queue<node> q;
int main(){
	while(cin>>n>>m&&n&&m){
		memset(dis,0x3f,sizeof(dis));

		memset(vis,0,sizeof(vis));
		memset(mp,0,sizeof(mp));
		f(i,1,n*m)e[i].u=e[i].v=e[i].w=e[i].nx=head[i]=0;
		tot=0;
		f(i,0,n-1)
			f(j,0,m-1){

				char c;
				cin>>c;
				if(c=='@')mp[i][j]=1;

			}
		ll s,t;
		ll a1=d,a2=d,a3=d,a4=d;
		s=k(a1,a2);
		t=k(a3,a4);
		dis[s]=0;

		f(i,0,n-1)
			f(j,0,m-1){

				ll x=k(i,j);

				if(i>0){
					tot++;
					e[tot].u=x,e[tot].v=k(i-1,j),e[tot].w=(mp[i][j]!=mp[i-1][j]);

					e[tot].nx=head[e[tot].u];
					head[x]=tot;
				}
				if(i+1<n){
					tot++;
					e[tot].u=x,e[tot].v=k(i+1,j),e[tot].w=(mp[i][j]!=mp[i+1][j]);

					e[tot].nx=head[e[tot].u];
					head[x]=tot;
				}
				if(j>0){

					tot++;
					e[tot].u=x,e[tot].v=k(i,j-1),e[tot].w=(mp[i][j]!=mp[i][j-1]);

					e[tot].nx=head[e[tot].u];
					head[x]=tot;
				}
				if(j+1<m){

					tot++;
					e[tot].u=x,e[tot].v=k(i,j+1),e[tot].w=(mp[i][j]!=mp[i][j+1]);

					e[tot].nx=head[e[tot].u];
					head[x]=tot;
				}
			}
		dis[s]=0;

		q.push((node){0,s});
		while(!q.empty()){
			ll u=q.top().now;
			q.pop();
			if(vis[u])continue;
			vis[u]=1;
			for(int i=head[u];i;i=e[i].nx){
				ll v=e[i].v;
				if(dis[v]>dis[u]+e[i].w){

					dis[v]=dis[u]+e[i].w;

					q.push((node){dis[v],v});

				}
			}
		}
		cout<<dis[t]<<endl;

	}
	return 0;
}
```


---

## 作者：Ousmane_Dembele (赞：1)

老实说，直到现在我都没有弄懂为什么开250000会挂，开2500000就ac了

为大家提供一个标准的dijkstra(priority_queue优化）做法

首先建图，500的数据直接硬来就行
```
for(int i=1;i<=n;i++)
  for(int j=1;j<=m;j++){
     if(i>1)addedge((i-1)*m+j, (i-2)*m+j, s[i][j]!=s[i-1][j]);
     if(i<n)addedge((i-1)*m+j, i*m+j,s[i][j]!=s[i+1][j]);
     if(j>1)addedge((i-1)*m+j, (i-1)*m+j-1,s[i][j]!=s[i][j-1]);
     if(j<m)addedge((i-1)*m+j, (i-1)*m+j+1,s[i][j]!=s[i][j+1]);
  }
```
紧接着，跑一个dijk模板，记得每次重设vis
```
//
//  main.cpp
//  luoguP4554小明的游戏
//
//  Created by Ousmane_Dembele on 2019/3/29.
//  Copyright © 2019 Ousmane_Dembele. All rights reserved.
//

#include <iostream>
#include <cstdio>
#include <queue>
#include <string.h>
using namespace std;
char s[1001][1001];
#define int long long
int n,m;
int nxt[2006001],to[2600001],head[2600001],cost[2600001],cnt,sx,sy,ex,ey,start,ed;
int dis[2600001],vis[2600001];
struct node{
    int dis,num;
    bool operator<(const node &a)const{
        return dis>a.dis;
    }
};

void add(int u,int v,int w){
    to[++cnt]=v;
    nxt[cnt]=head[u];
    cost[cnt]=w;
    head[u]=cnt;
}
void addedge(int u,int v,int w){
    //cout<<u<<" "<<v<<" "<<w<<endl;
    add(u,v,w);
    add(v,u,w);
}
void dijkstra(){
    priority_queue<node>q;
    while(!q.empty()){
        q.pop();
    }
    for(int i=0;i<=2600000;i++)dis[i]=19260817;
    memset(vis,0,sizeof(vis));
    dis[start]=0;
    q.push({0,start});
    while(!q.empty()){
        node w=q.top();
        q.pop();
        int v=w.num;
        if(vis[v]==1)continue;
        vis[v]=1;
        for(int i=head[v];i;i=nxt[i]){
            int u=to[i];
            if(dis[u]>cost[i]+dis[v]){
                dis[u]=cost[i]+dis[v];
                q.push({dis[u],u});
            }
        }
    }
}

signed main(){
    while(1){
        
        scanf("%lld%lld",&n,&m);
        if(n==0&&m==0)return 0;
        memset(head,-1,sizeof(head));
        cnt=0;
        for(int i=1;i<=n;i++)scanf("%s",s[i]+1);
        //for(int i=1;i<=n;i++)cout<<s[i]+1<<endl;
        //        for(int i=1;i<=n;i++){
        //            for(int j=1;j<=m;j++){
        //                for(int k=1;k<=4;k++){
        //                    if(i+x[k]<=n&&j+y[k]<=m&&i+x[k]>=1&&j+y[k]>=1){
        //                        if(s[i+x[k]][j+y[k]]==s[i][j])addedge((i-1)*m+j,(i+x[k]-1)*m+j+y[k],0);
        //                        else addedge((i-1)*m+j,(i+x[k]-1)*m+j+y[k],1);
        //                    }
        //                }
        //            }
        //        }
        //        for(int i=1;i<=n;i++)
        //            for(int j=1;j<=m;j++)
        //                scanf("%c",&s[i][j]);
        //        for(int i=1;i<=n;i++)
        //            cout<<s[i]+1<<endl;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++){
                if(i>1)addedge((i-1)*m+j, (i-2)*m+j, s[i][j]!=s[i-1][j]);
                if(i<n)addedge((i-1)*m+j, i*m+j,s[i][j]!=s[i+1][j]);
                if(j>1)addedge((i-1)*m+j, (i-1)*m+j-1,s[i][j]!=s[i][j-1]);
                if(j<m)addedge((i-1)*m+j, (i-1)*m+j+1,s[i][j]!=s[i][j+1]);
            }
        scanf("%lld%lld%lld%lld",&sx,&sy,&ex,&ey);
        sy++;ey++;
        start=sx*m+sy;
        //cout<<start<<endl;
        ed=ex*m+ey;
        dijkstra();
        //if(dis[ed]==192600000817)dis[ed]=0;
        //for(int i=1;i<=n*m;i++)cout<<dis[i]<<" ";
        printf("%lld\n",dis[ed]);
    }
}






```


---

## 作者：JasonZRY (赞：1)

看大家都用最短路和双向bfs，我就用单纯的bfs吧

大家既然连双向都会，这种单向的就不解释了吧

```
#include<bits/stdc++.h>
using namespace std;
int n,m,sx,sy,tx,ty,d[4][2]={{0,1},{0,-1},{1,0},{-1,0}},dis[505][505],qx[5000000],qy[5000000],tot,tow;
char ch[505][505];
bool flag[505][505];
void bfs(){
    for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)dis[i][j]=1e9;
    qx[tot=1]=sx;
	qy[tow=1]=sy;
	dis[sx][sy]=0;
    while(tot<=tow){
        flag[qx[tot]][qy[tot]]=0;
        for(int i=0;i<4;++i){
            int nx=qx[tot]+d[i][0],ny=qy[tot]+d[i][1];
            if(nx<1||nx>n||ny<1||ny>m)continue;
            if(dis[nx][ny]>dis[qx[tot]][qy[tot]]+(ch[nx][ny]!=ch[qx[tot]][qy[tot]])){
                dis[nx][ny]=dis[qx[tot]][qy[tot]]+(ch[nx][ny]!=ch[qx[tot]][qy[tot]]);
                if(!flag[nx][ny])flag[qx[++tow]=nx][qy[tow]=ny]=1;
            }
        }
        tot++;
    }
}
int main(){
    while(cin>>n>>m){
        if(n==0&&m==0)break;
        for(int i=1;i<=n;++i)scanf("%s",ch[i]+1);
        cin>>sx>>sy>>tx>>ty;
        sx++;
		sy++;
		tx++;
		ty++;
        bfs();
        cout<<dis[tx][ty]<<"\n";
    }
}
```
求管理通过

---

## 作者：rediserver (赞：1)

# P4554 小明的游戏
[原题地址](https://www.luogu.org/problemnew/show/P4554)
[GitHub题解](https://github.com/jerrykcode/luogu)

## 思路

Dijkstra，图的顶点为棋盘上的格子，一个顶点的邻接点为棋盘上与它相邻的格子。顶点与邻接点的距离：若为同类型的格子则为0，否则为1。

## 代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <vector>
using namespace std;

typedef unsigned short uint16_t; //16位无符号类型
typedef uint16_t grid_t; //格子
typedef uint16_t dist_t; //距离(花费)
#define DIST_INF 0xffff

//坐标
struct Coordinate {
	grid_t row, col; //行与列
	Coordinate() {}
	Coordinate(grid_t row, grid_t col) : row(row), col(col) {}
};

//dijkstra中存入优先队列的坐标
struct PriorityCoordinate : public Coordinate {
	dist_t dist; //与源的距离
	PriorityCoordinate(grid_t row, grid_t col, dist_t dist) : Coordinate(row, col), dist(dist) {}
	
	//优先队列用于比较的结构体
	struct cmp {
		bool operator() (PriorityCoordinate& a, PriorityCoordinate& b) {
			return a.dist > b.dist;
		}
	};
};

//迭代器，用于枚举一个格子相邻的格子
struct Iterator {
	//构造函数，传入棋盘与尺寸
	Iterator(char ** board, grid_t n_rows, grid_t n_cols) : board(board), n_rows(n_rows), n_cols(n_cols) {}
	
	//设置格子
	bool setCoordinate(grid_t row, grid_t col) {
		if (row < n_rows && col < n_cols) {
			this->row = row;
			this->col = col;
			direction = UP; //初始向上开始找
			return true;
		}
		return false;
	}
	
	//得到下一个相邻格子的行与列
	bool next(grid_t * p_row, grid_t * p_col) {
		switch (direction) {
		case UP: { //向上找
			direction = LEFT; //下次向左
			if (row - 1 >= 0) { //上面存在格子
				*p_row = row - 1;
				*p_col = col;
				return true;
			}
			else //上面不存在
				return next(p_row, p_col); //递归找
			break;
		}
		case LEFT: { //向左找
			direction = RIGHT; //下次向右
			if (col - 1 >= 0) { //左边存在格子
				*p_row = row;
				*p_col = col - 1;
				return true;
			}
			else 
				return next(p_row, p_col); //递归找
			break;
		}
		case RIGHT: { //向右找
			direction = DOWN; //下次向下
			if (col + 1 < n_cols) { //右边存在格子
				*p_row = row;
				*p_col = col + 1;
				return true;
			}
			else 
				return next(p_row, p_col); //递归
			break;
		}
		case DOWN: { //向下找
			direction = END; //向下为最后可能得到的相邻格子，下次将结束寻找
			if (row + 1 < n_rows) { //下边存在格子
				*p_row = row + 1;
				*p_col = col;
				return true;
			}
			else
				return next(p_row, p_col); //递归，事实上direction更新为END后，递归也只可能返回false
			break;
		}
		case END :{ //无处可找
			return false; //返回false
			break;
		}
		default: return false; break;
		}	
		return false;
	}
private:
	char ** board; //棋盘
	grid_t n_rows, n_cols; //棋盘的尺寸
	grid_t row, col; //当前格子，next函数得到的便是row, col的相邻格子

	//寻找相邻格子的方向
	typedef enum {
		UP,
		LEFT,
		RIGHT,
		DOWN,
		END,
	} Direction;

	Direction direction;
};

//计算最短距离(最小花费)
//与普通dijkstra相同，只是图的顶点是棋盘中的一个格子(坐标)，一个顶点的邻接点为棋盘中与他相邻的格子
dist_t dijkstra(char ** board, grid_t n_rows, grid_t n_cols, Coordinate src, Coordinate des) {
	bool ** collected = new bool *[n_rows];
	dist_t ** dist = new dist_t *[n_rows];
	for (size_t i = 0; i < n_rows; i++) {
		collected[i] = new bool[n_cols];
		fill(collected[i], collected[i] + n_cols, false);
		dist[i] = new dist_t[n_cols];
		fill(dist[i], dist[i] + n_cols, DIST_INF);
	}
	priority_queue<PriorityCoordinate, vector<PriorityCoordinate>, PriorityCoordinate::cmp> pq;
	pq.push(PriorityCoordinate(src.row, src.col, 0));
	dist[src.row][src.col] = 0;
	grid_t top_row, top_col;	
	dist_t top_dist, tmp_dist;
	grid_t adj_row, adj_col;
	Iterator it(board, n_rows, n_cols);
	while (!pq.empty()) {
		top_row = pq.top().row;
		top_col = pq.top().col;
		top_dist = pq.top().dist;
		pq.pop();
		if (collected[top_row][top_col]) continue;
		collected[top_row][top_col] = true;
		if (top_row == des.row && top_col == des.col) {
			//到达终点
			while (!pq.empty()) pq.pop();
			break;
		}
		it.setCoordinate(top_row, top_col); //设置迭代器
		while (it.next(&adj_row, &adj_col)) { //遍历相邻的格子
			if (!collected[adj_row][adj_col]) {
				tmp_dist = top_dist + (board[top_row][top_col] == board[adj_row][adj_col] ? 0 : 1);
				if (tmp_dist < dist[adj_row][adj_col]) {
					//更新
					dist[adj_row][adj_col] = tmp_dist;
					pq.push(PriorityCoordinate(adj_row, adj_col, tmp_dist));
				}
			}
		}
	}
	dist_t result = dist[des.row][des.col];
	//释放内存
	for (size_t i = 0; i < n_rows; i++) {
		free(collected[i]);
		free(dist[i]);
	}
	free(collected);
	free(dist);
	return result;
}

int main() {
	grid_t n, m, x1, y1, x2, y2;
	Coordinate src, des;
	char ** board;
	while (1) {
		scanf("%hd %hd", &n, &m);		
		if (!n) break;
		//输入棋盘
		board = new char *[n];
		for (size_t i = 0; i < n; i++) {
			board[i] = new char[m];			
			for (size_t j = 0; j < m; j++) {		
				scanf(" %c", &board[i][j]);
			}
		}
		//输入起点，终点坐标
		scanf("%hd %hd %hd %hd", &x1, &y1, &x2, &y2);
		src.row = x1;
		src.col = y1;
		des.row = x2;
		des.col = y2;
		printf("%hd\n", dijkstra(board, n, m, src, des));
		for (size_t i = 0; i < n; i++) {
			free(board[i]);
		}
		free(board);
	}
	return 0;
}

```

---

## 作者：伊莉砂糖蔗 (赞：0)

##### 由于相邻且符号相同的点两个点相互连通且无花费
##### 所以这两个点可以看成一个整体
##### 也就是看成一个大的点
##### 当两点相邻而又不属于一个“点”时
##### 我们可以说这两个“点”间有一条边
##### 建立完图后spfa就ok了
```cpp
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
long long n,m;
int col=0;       //点号
int co[510][510];  //标记a[i][j]属于哪个“点”
char a[510][510];
int dis[510*510];
int head[510*510];
int f[510*510];
int tot;
int dx[]={0,1,-1,0,0};
int dy[]={0,0,0,1,-1};
struct woc
{
    int to,from;
	int next;
	int w;
}e[510000];
void build(int x,int y)
{
    ++tot;
	e[tot].to=y;
	e[tot].from=x;
	e[tot].w=1;
	e[tot].next=head[x];
	head[x]=tot;
}
queue<int>q;
void add(int x,int y)  //缩点
{
	co[x][y]=col;
	for(int i=1;i<=4;i++)
	{
		if(a[dx[i]+x][dy[i]+y]==a[x][y] && !co[dx[i]+x][dy[i]+y])
		{
			add(dx[i]+x,dy[i]+y);
		}
	}
}
void spfa(int s,int end)
{
	dis[s]=0;
	f[s]=1;
	q.push(s);
	while(!q.empty())
	{
	    int now=q.front();
		q.pop();
		f[now]=0;
		for(int i=head[now];i;i=e[i].next)
		{
		    if(dis[e[i].to]>dis[now]+e[i].w)
			{
			    dis[e[i].to]=dis[now]+e[i].w;
				if(!f[e[i].to])
				{
				    f[e[i].to]=1;
					q.push(e[i].to);
				}
			}
		}
	}
	cout<<dis[end]<<endl;
}
int main()
{
	while(cin>>n>>m && n && m)
	{
	   memset(co,0,sizeof(co));
		memset(dis,127/2,sizeof(dis));
		memset(head,0,sizeof(head));
		memset(e,0,sizeof(e));
		memset(f,0,sizeof(f));
		col=0;
		tot=0;
		
		for(int i=1;i<=n;i++)
		  for(int j=1;j<=m;j++)
		    cin>>a[i][j];
		int sx,sy,ex,ey;
		cin>>sx>>sy>>ex>>ey;
	    for(int i=1;i<=n;i++)
		  for(int j=1;j<=m;j++)
			if(!co[i][j])
			{
			  col++; 
			  add(i,j);
			}
		for(int i=1;i<=n;i++)
		  for(int j=1;j<=m;j++)
			for(int k=1;k<=4;k++)            //建边
			   if(co[i+dx[k]][j+dy[k]]!=co[i][j])
					build(co[i+dx[k]][j+dy[k]],co[i][j]);
	 spfa(co[sx+1][sy+1],co[ex+1][ey+1]);//将要访问的s,e所在“点”上传
	}
	return 0;
}

```


---

## 作者：Zekrom (赞：0)

首先，这道题可以抽象成最短路的问题  
实现方法   
1.遍历联通块  
2.对于横向纵向，若联通块不同，添加边   
3.执行最短路，求出d[c[ex][ey]]  
注意：加边应用邻接表，直接数组存会爆栈（~~刚开始我还想去重边导致re qaq~~）  
上代码  
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 510 
using namespace std;
int n,m,cnt,sx,sy,ex,ey,c[N][N],d[N*N],tot,head[N*N];
bool map[N][N],vis[N*N];
int dx[]={0,1,0,0,-1};
int dy[]={0,0,1,-1,0}; 
struct Edge{
	int v,next;
}edge[N*N*4];
inline int read(){
	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return x*f;
}
void dfs(int x,int y){
	c[x][y]=cnt;
	for(int i=1;i<=4;i++){
		int vx=x+dx[i],vy=y+dy[i];
		if(map[vx][vy]==map[x][y]&&vx>=1&&vx<=n&&vy>=1&&vy<=m&&!c[vx][vy])
			dfs(vx,vy);
	}
}
inline void add(int x,int y){edge[++tot].v=y;edge[tot].next=head[x];head[x]=tot;}
void spfa(int s){
	queue<int>q;
	memset(d,0x3f,sizeof(d));memset(vis,0,sizeof(vis));
	q.push(s);d[s]=0;vis[s]=1;
	while(q.size()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].v;			
			if(d[v]>d[u]+1){
				d[v]=d[u]+1;
				if(!vis[v])vis[v]=1,q.push(v);
			}
		}
	}
}
int main()
{
	n=read();m=read();
	while(1){
		if(n==0&&m==0)break;
		memset(map,0,sizeof(map));memset(c,0,sizeof(c));memset(head,0,sizeof(head));cnt=0,tot=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++){
				char ch;cin>>ch;
				if(ch=='#')map[i][j]=1;
			}
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(!c[i][j])cnt++,dfs(i,j);
		for(int j=1;j<=m;j++)
			for(int i=1;i<n;i++)
				if(c[i][j]!=c[i+1][j])add(c[i][j],c[i+1][j]),add(c[i+1][j],c[i][j]);
		for(int i=1;i<=n;i++)
			for(int j=1;j<m;j++)
				if(c[i][j]!=c[i][j+1])add(c[i][j],c[i][j+1]),add(c[i][j+1],c[i][j]);
		sx=read()+1,sy=read()+1,ex=read()+1,ey=read()+1;
		spfa(c[sx][sy]); 
		printf("%d\n",d[c[ex][ey]]);
		n=read();m=read();		
	} 
	return 0;
}

```


---


# [JLOI2011] 飞行路线

## 题目描述

Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。

Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？

## 说明/提示

#### 数据规模与约定

对于 $30\%$ 的数据，$2 \le n \le 50$，$1 \le m \le 300$，$k=0$。

对于 $50\%$ 的数据，$2 \le n \le 600$，$1 \le m \le 6\times10^3$，$0 \le k \le 1$。

对于 $100\%$ 的数据，$2 \le n \le 10^4$，$1 \le m \le 5\times 10^4$，$0 \le k \le 10$，$0\le s,t,a,b < n$，$a\ne b$，$0\le c\le 10^3$。

另外存在一组 hack 数据。

## 样例 #1

### 输入

```
5 6 1
0 4
0 1 5
1 2 5
2 3 5
3 4 5
2 3 3
0 2 100```

### 输出

```
8```

# 题解

## 作者：SuperJvRuo (赞：165)

套路题，分层图。

以样例为例（使用 @EternalAlexander 这位dalao的OI Painter绘制）：

![](https://cdn.luogu.com.cn/upload/pic/19106.png)

各层内部正常连边，各层之间从上到下连权值为0的边。每向下跑一层，就相当于免费搭一次飞机。跑一遍从$s$到$t+n*k$的最短路即可。

```
#include<cstdio>
#include<cctype>
#include<cstring>
#include<queue>
#include<algorithm>
#include<vector>
#include<utility> 
#include<functional>

int Read()
{
    int x=0;char c=getchar();
    while(!isdigit(c))
    {
        c=getchar();
    }
    while(isdigit(c))
    {
        x=x*10+(c^48);
        c=getchar();
    }
    return x;
}

using std::priority_queue;
using std::pair;
using std::vector;
using std::make_pair;
using std::greater;

struct Edge
{
    int to,next,cost;
}edge[2500001];
int cnt,head[110005];

void add_edge(int u,int v,int c=0)
{
    edge[++cnt]=(Edge){v,head[u],c};
    head[u]=cnt;
}

int dis[110005];
bool vis[110005];
void Dijkstra(int s)
{
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > points;
    points.push(make_pair(0,s));
    while(!points.empty())
    {
        int u=points.top().second;
        points.pop();
        if(!vis[u])
        {
            vis[u]=1;
            for(int i=head[u];i;i=edge[i].next)
            {
                int to=edge[i].to;
                if(dis[to]>dis[u]+edge[i].cost) 
                {
                    dis[to]=dis[u]+edge[i].cost;
                    points.push(make_pair(dis[to],to));
                }
            }
        }
    }
}

int main()
{
    int n=Read(),m=Read(),k=Read(),s=Read(),t=Read();
    int u,v,c;
    for(int i=0;i<m;++i)
    {
        u=Read(),v=Read(),c=Read();
        add_edge(u,v,c);
        add_edge(v,u,c);
        for(int j=1;j<=k;++j)
        {
            add_edge(u+(j-1)*n,v+j*n);
            add_edge(v+(j-1)*n,u+j*n);
            add_edge(u+j*n,v+j*n,c);
            add_edge(v+j*n,u+j*n,c);
        }
    }
    for(int i=1;i<=k;++i)
	{
		add_edge(t+(i-1)*n,t+i*n);
	}//预防奇葩数据
    Dijkstra(s);
    printf("%d",dis[t+k*n]);
    return 0;
}
```

---

## 作者：Anguei (赞：80)

**分层图最短路**板子题。

对于图中的每个结点 $u$，可以把它拆成 $k + 1$ 个节点 $u_j, j \in [0, k]$，分别表示当使用 $j$ 次免费通行权限后到达 $u$ 号节点的状态。对于样例，则可以这样表示（图画得不是很好，见谅）：

![pic](https://s1.ax1x.com/2018/10/30/i2gtIJ.png)

图中加粗结点表示样例的起点和终点。

事实上，虽然样例可以用这种方法画图表示，但我们写代码的时候不一定要建这么多结点。只需要按照原始的输入建普通的图。考虑 dp。设 $\text{dis}_{i, j}$ 表示当前从起点 $i$ 号结点，使用了 $j$ 次免费通行权限后的最短路径。显然，$\text{dis}$ 数组可以这么转移：

$$ \text{dis}_{i, j} = \min\{\min\{\text{dis}_{from, j - 1}\}, \min\{\text{dis}_{from,j} + w\}\} $$

其中，$from$ 表示 $i$ 的父亲节点，$w$ 表示当前所走的边的边权。当 $j - 1 \geq k$ 时，$\text{dis}_{from, j}$ = $\infty$。

事实上，这个 dp 就相当于对于每个结点的 $k + 1$ 个状态，想象成拆为 $k + 1$ 个不同的结点，每个结点之间可以相连，仿佛这张图一共有 $k + 1$ 层。

对于进行 Dijkstra 算法的过程，把 $\text{done}$ 数组也开成二维就好，每次入队的时候分别判断能否使用免费通行权限即可。最后统计答案的时候需要统计出到最后一个结点总共 $k + 1$ 种状态的最短距离。

核心代码如下：

```cpp
struct State { // 优先队列的结点结构体
    int v, w, cnt; // cnt 表示已经使用多少次免费通行权限
    State() {}
    State(int v, int w, int cnt) : v(v), w(w), cnt(cnt) {}
    bool operator<(const State &rhs) const { return w > rhs.w; }
};

void dijkstra() {
    memset(dis, 0x3f, sizeof dis);
    dis[s][0] = 0;
    pq.push(State(s, 0, 0)); // 到起点不需要使用免费通行权，距离为零
    while (!pq.empty()) {
        const State top = pq.top(); pq.pop();
        int u = top.v, nowCnt = top.cnt;
        if (done[u][nowCnt]) continue;
        done[u][nowCnt] = true;
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].v, w = edge[i].w;
            if (nowCnt < k && dis[v][nowCnt + 1] > dis[u][nowCnt]) { // 可以免费通行
                dis[v][nowCnt + 1] = dis[u][nowCnt];
                pq.push(State(v, dis[v][nowCnt + 1], nowCnt + 1));
            }
            if (dis[v][nowCnt] > dis[u][nowCnt] + w) { // 不可以免费通行
                dis[v][nowCnt] = dis[u][nowCnt] + w;
                pq.push(State(v, dis[v][nowCnt], nowCnt));
            }
        }
    }
}

int main() {
    n = read(), m = read(), k = read(); 
    // 笔者习惯从 1 到 n 编号，而这道题是从 0 到 n - 1，所以要处理一下 
    s = read() + 1, t = read() + 1;
    while (m--) {
        int u = read() + 1, v = read() + 1, w = read();
        add(u, v, w), add(v, u, w); // 这道题是双向边 
    }
    dijkstra();
    int ans = std::numeric_limits<int>::max(); // ans 取 int 最大值为初值
    for (int i = 0; i <= k; ++i)
    	ans = std::min(ans, dis[t][i]); // 对到达终点的所有情况取最优值 
    println(ans);
}
```

---

## 作者：Heartlessly (赞：61)

## Description

给定一个 $n\ (2 \leq n \leq 10^4)$ 个点（编号为 $0 \sim n - 1$），$m\ (1 \leq m \leq 5 \times 10^4)$ 条边的无向图，其中最多可以把 $k\ (0 \leq k \leq 10)$ 条边的边权变成 $0$，求 $s$ 到 $t\ (0 \leq s,t < n)$ 的最短路。

## Solution

**分层图最短路** 模板题。

这类题目主要难在建图。

比如说，对于样例

### Sample Input

```
5 6 1
0 4
0 1 5
1 2 5
2 3 5
3 4 5
2 3 3
0 2 100
```

### Sample Output

```
8
```

建出来的图：

![E8gzgs.png](https://s2.ax1x.com/2019/04/30/E8gzgs.png)

我们可以考虑把图分成 $k + 1$ 层，每往下一层，边权变成 $0$ 的边就增加 $1$ 条。编号为 $i$ 的点在第 $j$ 层的编号为 $i + j \times n\ (0 \leq i < n,0 \leq j \leq k)$ 。

每一层都有同样的 $n$ 个点，$m$ 条边。

在层与层之间有单向边，边权为 $0$，且不能从下层到上层。

对于一条边权为 $w$ 的无向边 $u \leftrightarrow v$，我们可以在第 $i = 0 \sim k$ 层连无向边 $u + i \times n \leftrightarrow v + i \times n$，边权为 $w$，表示每一层里的 $u$ 和 $v$ 能互相到达，且花费的代价为 $w$ 。

紧接着，在第 $i - 1$ 层和第 $i$ 层之间连两条边权为 $0$ 的有向边 $u + (i-1) \times n \to v + i \times n$ 和 $v + (i-1) \times n \to u + i \times n$，表示可以把边 $u \to v$ 或 $v \to u$ 的边权变成 $0$，然后到下一层的 $v$ 点或 $u$ 点。

建图后，$s$ 到 $t + k \times n$ 的最短路即是用完 $k$ 次机会的最少花费。

最后可能没有用完 $k$ 次机会，所以到每层终点的最短路都有可能成为答案，取最小值即可。时间复杂度为 $O\left(mk\log (nk) \right)$ 。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 2e5, MAXM = 5e6;
int n, m, k, s, t, tot, ans = 0x7fffffff, head[MAXN + 5], dis[MAXN + 5];
bool vis[MAXN + 5];
struct Edge {
    int next, to, dis;
} e[MAXM + 5];
struct Node {
    int val, id;
    inline friend bool operator<(Node x, Node y) {
        return x.val > y.val;
    } 
};

inline void addEdge(int u, int v, int w) {
    e[++tot] = (Edge) { head[u], v, w };
    head[u] = tot;
}

inline void dijkstra(int s) {//堆优化 dijkstra 
    memset(dis, 0x3f, sizeof (dis));
    priority_queue<Node> q;
    dis[s] = 0;
    q.push((Node) { 0, s });
    for (; !q.empty(); ) {
        int u = q.top().id;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next)
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) q.push((Node) { dis[v], v });
            }
    }
}

int main() {
    read(n), read(m), read(k), read(s), read(t);
    ++s, ++t;//点的编号改为 1 ~ n 
    for (int u, v, w, i = 1; i <= m; ++i) {
        read(u), read(v), read(w);
        ++u, ++v;
        addEdge(u, v, w), addEdge(v, u, w);
        for (int j = 1; j <= k; ++j) {//一共 k 层 
            addEdge(u + (j - 1) * n, v + j * n, 0), addEdge(v + (j - 1) * n, u + j * n, 0);
            //层与层之间对应的点连一条权值为 0 的边 
            addEdge(u + j * n, v + j * n, w), addEdge(v + j * n, u + j * n, w);
            //每一层中对应的点连边
        }
    }
    dijkstra(s);
    for (int i = 0; i <= k; ++i) ans = min(ans, dis[t + i * n]);
    //可能没有用完 k 次机会，所以要取 到每一层终点最短路 的最小值 
    write(ans);
    putchar('\n');
    return 0;
}
```


---

## 作者：shenbear (赞：60)

各位大佬用的都是分层图哎，我一个蒟蒻，根本不知道分层图是啥，怎么办？

从最简单的djstl开始

```c
void djstl()
{
    q.push(pnode(s,0));
    dis[s]=0;
//    vis[s]=1;
    while(!q.empty())
    {
        pnode u=q.top();
        q.pop();
    //    vis[u.x]=0;
        if(u.l>dis[u.x]) continue;
        for(int i=head[u.x];i;i=p[i].next)
        {
            int v=p[i].to;
            if(dis[v]>dis[u.x]+p[i].v)
            {
                dis[v]=dis[u.x]+p[i].v;
       //         if(!vis[v])
                {
            //        vis[v]=1;
                    q.push(pnode(v,dis[v]));
                }
            }
        }
    }
}
```
if(dis[v]>dis[u.x]+p[i].v) dis[v]=dis[u.x]+p[i].v;
这句话是不是很眼熟，像什么？

# **dp！！！**


------------
对，这道题就是用dp，从这个式子来看，djstl本质就是

**dp+bfs**

但他是一维的，无法满足需求，可以变成二维吗？

答案是肯定的，因为对于每一个点，都可以从用免费机会与不用转移过来，既然能转移，而且可以证明如果能转移时不转移，后面情况肯定不如转移，那么就可以用dp

那么如何转移

我们设f[v][k]为v点用了k次免费花的最少费用

观察if(dis[v]>dis[u.x]+p[i].v) dis[v]=dis[u.x]+p[i].v;

同理，可以得到不用机会的转移方程

**f[v][k]=f[u][k]+边权；**

如果用了**f[v][k]=f[v][k-1] _注意k>0_**

边界也和djstl一样f[s][i]=0;(0<=i<=k)，
其他为inf

循环并没有太多问题，把for放在while外面就行了，因为while在外面的话，每一次for前都要把（s，0）压入，这样所有for执行完前，while一直在，这样while就没太大意义，而且有些操作是针对while而非for的

## 本题还有一个坑点，就是**编号是0~n-1**


------------
上代码


------------
```
#include <bits/stdc++.h>
using namespace std;
int n,m,k,s,t,f[111111][21];
struct edge
{
	int next,to,vl;
}p[1111111];
int head[1111111],num;
void ad(int x,int y,int z) 、、前向星
{
	p[++num].next=head[x];
	p[num].to=y;
	p[num].vl=z;
	head[x]=num;
}
struct vs
{
	int x,vl;
	vs(int a,int b)
	{
		x=a;
		vl=b;
	}
	bool operator <(const vs b) const
    {
        return vl>b.vl;
    }
};
priority_queue<vs> q;
void djstl()
{
	for(int i=0;i<=k;i++) f[s][i]=0;
	for(int i=0;i<=k;i++)//for放外面
	{
		q.push(vs(s,0));
		while(!q.empty())\\djstl
		{
			vs u=q.top();
			q.pop();
			if(u.vl>f[u.x][i]) continue;#这个操作就是针对while的
			for(int j=head[u.x];j;j=p[j].next)
			{
				int v=p[j].to;
				bool bl=0;
				if(i)
				if(f[v][i]>f[u.x][i-1])
				{
					f[v][i]=f[u.x][i-1];
		//			printf("!%d %d %d %d %d\n",u.x,v,i,j,f[v][i]);	
					bl=1;
				}
				if(f[v][i]>f[u.x][i]+p[j].vl)
				{
					f[v][i]=f[u.x][i]+p[j].vl;
		//			printf("@%d %d %d %d %d\n",u.x,v,i,j,f[v][i]);	
					bl=1;
				}
				if(bl)
				{
					q.push(vs(v,f[v][i]));
				}
			}
		}
	}
}《--这是个中文大括号【滑稽】
int main()
{
	cin>>n>>m>>k>>s>>t;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		ad(x,y,z);
		ad(y,x,z);
	}
	for(int i=0;i<n;i++) ！注意是0~n-1
	{
		for(int j=0;j<=k;j++) f[i][j]=1e9;
	}
	djstl();
//	printf("%d %d\n",f[0][0],f[2][1]);
	printf("%d",f[t][k]);
	return 0；<-有点奇怪的分号
}

```


---

## 作者：顾z (赞：33)


>### Description
>Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在nn个城市设有业务，设这些城市分别标记为$0$到$n−1$，一共有$m$种航线，每种航线连接两个城市，并且航线有一定的价格。

>Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多$k$种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？
>### Input
>数据的第一行有三个整数，$n,m,k$，分别表示城市数，航线数和免费乘坐次数。

>第二行有两个整数，$s,t$，分别表示他们出行的起点城市编号和终点城市编号。

>接下来有$m$行，每行三个整数，$a,b,c$，表示存在一种航线，能从城市$a$到达城市$b$，或从城市$b$到达城市$a$，价格为$c$。 

>### Output
>只有一行，包含一个整数，为最少花费

### 分析

​	明显,此题为最短路问题,但是考虑到可以免费搭乘(即直接通过一条边无需费用.)

这种问题有一个官方的名字 **分层图最短路问题**

> 分层图最短路是指在可以进行分层图的图上解决最短路问题.

是不是听起来就很nb?

~~具体分层图是啥,我也不知道~~

> 一般模型：
>
> ​	 　在图上,有$k$次机会可以直接通过一条边,问起点与终点之间的最短路径.

很明显,这道题是一个裸的分层图最短路问题 (貌似这类问题都挺裸的 emm

#### 解法

 我们设

> $dis[i][j]$代表到达$i$用了$j$次免费机会的最小花费.
>
> $vis[i][j]$代表到达$i$用了$j$次免费机会的情况是否出现过.	

对于某条路径我们可以选择使用机会,也可以选择不使用机会.

讨论这两种情况即可

```c++
#include<cstdio>
#include<queue>
#include<cstring>
#define R register
#define N 20008
using namespace std;
inline void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s>='0' and s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int head[N],tot,n,m,s,t,k;
int dis[N][15],ans=2147483647;
bool vis[N][15];
struct cod{int u,v,w;}edge[N*6+8];
inline void add(int x,int y,int z)
{
	edge[++tot].u=head[x];
	edge[tot].v=y;
	edge[tot].w=z;
	head[x]=tot;
}
struct coc{
	int u,d,used;
	bool operator <(const coc&a) const 
	{
		return d>a.d;
	}
};
inline void dijkstra()
{
	memset(dis,127,sizeof dis);
	dis[s][0]=0;
	priority_queue<coc>q;
	q.push((coc){s,0,0});
	while(!q.empty())
	{
		int u=q.top().u,now=q.top().used;
		q.pop();
		if(vis[u][now])continue;
		vis[u][now]=true;
		for(R int i=head[u];i;i=edge[i].u)
		{
			if(now<k and !vis[edge[i].v][now+1] and dis[edge[i].v][now+1]>dis[u][now])//当前路径,使用一次免费机会.注意判断 now<k
			{
				dis[edge[i].v][now+1]=dis[u][now];
				q.push((coc){edge[i].v,dis[edge[i].v][now+1],now+1});
			}
			if(!vis[edge[i].v][now] and dis[edge[i].v][now]>dis[u][now]+edge[i].w)//当前路径,不使用免费机会
			{
				dis[edge[i].v][now]=dis[u][now]+edge[i].w;
				q.push((coc){edge[i].v,dis[edge[i].v][now],now});
			}
		}
	}
}
int main()
{
	in(n),in(m),in(k);
	in(s),in(t);
	s++;t++;//这里个人习惯不同.我选择记录编号为1~n
	for(R int i=1,x,y,z;i<=m;i++)
	{
		in(x),in(y),in(z);
		x++;y++;
		add(x,y,z);
		add(y,x,z);
	}
	dijkstra();//直接跑dijkstra
	for(R int i=0;i<=k;i++)
		ans=min(ans,dis[t][i]);//到达t我们需要对使用免费机会的情况枚举.取min
	printf("%d",ans);
}
```



---

## 作者：KevinYu (赞：21)

第一次发紫题题解。    
简单来说就是分层图，第i层代表使用了i次免费飞行的情况。     
所以建k个图，图间以权值为0的边连接，跑最短路即可。     
上代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<climits>
#include<ctime>
#include<cstdlib>
#include<algorithm>
#include<iostream>
#include<complex>
#include<map>
#include<queue>
#include<vector>
#define ll long long
#define INF 0x3f3f3f3f
using namespace std;
struct edge
{
	int to,next,weight;
}a[6000060];
struct node
{
	int dist,id;
	node(){}
	node(int dist,int id):dist(dist),id(id){}
};
bool operator <(node xi,node yi)
{
	return xi.dist>yi.dist;
}
int n,m,k;
int s,t;
int x,y,w;
int cnt(0);
int head[1000010];
int vis[1000010];
int dist[1000010];
void addedge(int xi,int yi,int wi)
{
	a[cnt].to=yi;
	a[cnt].next=head[xi];
	a[cnt].weight=wi;
	head[xi]=cnt++;
}
void dijkstra(int s)
{
	memset(vis,0,sizeof(vis));
	memset(dist,INF,sizeof(dist));
	priority_queue<node> q;
	q.push(node(0,s));
	dist[s]=0;
	while(!q.empty())
	{
		node t(q.top());
		q.pop();
		if(vis[t.id])continue;
		vis[t.id]=1;
		for(int i=head[t.id];i!=-1;i=a[i].next)
		{
			int v=a[i].to;
			if(dist[v]>a[i].weight+t.dist)
			{
				dist[v]=a[i].weight+t.dist;
				q.push(node(dist[v],v));
			}
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d%d",&n,&m,&k);
	scanf("%d%d",&s,&t);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&w);
		addedge(x,y,w);
		addedge(y,x,w);
		for(int j=1;j<=k;j++)
		{
			addedge(x+(j*n),y+(j*n),w);
			addedge(y+(j*n),x+(j*n),w);
			addedge(x+((j-1)*n),y+(j*n),0);
			addedge(y+((j-1)*n),x+(j*n),0);
		}
	}
	for(int i=1;i<=k;i++)addedge(t+(i-1)*n,t+i*n,0);
	dijkstra(s);
	printf("%d",dist[t+k*n]);
	return 0;
}
```

---

## 作者：GK0328 (赞：18)

这显然是一道分层图最短路。。。

然而我这个蒟蒻之前总是写错分层图，还好这次一遍A了（~~心情大好~~）。。。

我认为的分层图是这样的：

![](https://cdn.luogu.com.cn/upload/pic/29090.png)

~~本蒟蒻拙劣的画技可能已经让大佬鄙视了。。。~~

对于普通的最短路，数组只开一维，d[u]表示从起点到达u的最短路。。。

现在多加入一维，d[g][h]表示从起点到g，使用优惠次数为h的的最短路径。

转移也需要改变：

首先是不使用优惠的情况：

d[son][h]:=min(d[son][h],d[g][h]+cost)（son为从g出发能到达的节点，cost为所需的费用）

使用优惠？！

d[son][h+1]:=min(d[son][h+1],d[g][h])

本蒟蒻讨厌堆，所以打了个蒟蒻版的线段树优化。。。

~~Pascal~~ Code：

```cpp
// luogu-judger-enable-o2//洛谷O2
uses math;//懒得打max，min
type node=record//记录类型记录g和h
  g,h:longint;
end;
var
  head,next,d1,d2:array[0..500005]of longint;
  tree:array[0..500005]of int64;
  id:array[0..500005]of node;
  d:array[0..20005,0..25]of int64;
  ss:array[0..500005]of longint;
  n,m,k,s,t,i,j,x,y,z,num,zty,v,cost,getnode,ll:longint;
  ans,inf:int64;
  u,newnode:node;
procedure add(x,y,z:longint);//链式前向星记录边
begin
  inc(num);
  d1[num]:=y;//节点
  d2[num]:=z;//价值
  next[num]:=head[x];
  head[x]:=num;
end;
function titititing(u:node):longint;////将node类型变为一个数字
begin
  exit((u.g-1)*(k+1)+u.h+1);
end;
function titititingg(p:longint):longint;//通过数字取出g
begin
  exit((p-1) div (k+1)+1);
end;
function titititingh(p:longint):longint;//通过数字取出h
begin
  if p mod (k+1)=0 then
    exit(k);
  exit(p mod (k+1)-1);
end;
procedure build(p,l,r:longint);//建树
var
  mid,getg,geth:longint;
begin
  if l=r then
  begin
    getg:=titititingg(l);
    geth:=titititingh(l);
    tree[p]:=d[getg][geth];
    id[p].g:=getg;
    id[p].h:=geth;
    ss[l]:=p;
    exit;
  end;
  mid:=(l+r) >> 1;
  build(p+p,l,mid);
  build(p+p+1,mid+1,r);
  if tree[p+p]<=tree[p+p+1] then
  begin
    tree[p]:=tree[p+p];
    id[p]:=id[p+p];
  end else
  begin
    tree[p]:=tree[p+p+1];
    id[p]:=id[p+p+1];
  end;
end;
procedure change(p:longint);//修改
begin
  if p=0 then
    exit;
  if tree[p+p]<=tree[p+p+1] then
  begin
    tree[p]:=tree[p+p];
    id[p]:=id[p+p];
  end else
  begin
    tree[p]:=tree[p+p+1];
    id[p]:=id[p+p+1];
  end;
  change(p div 2);
end;
begin
  readln(n,m,k);
  readln(s,t);
  inc(s);inc(t);
  for i:=1 to m do
  begin
    readln(x,y,z);
    inc(x);inc(y);
    add(x,y,z);
    add(y,x,z);
  end;
  inf:=1000000007;
  for i:=1 to n do
    for j:=0 to k do
      d[i][j]:=inf;
  d[s][0]:=0;
  build(1,1,n*(k+1));
  while tree[1]<inf do
  begin
    u:=id[1];
    zty:=titititing(u);
    tree[ss[zty]]:=inf;
    change(ss[zty] div 2);
    ll:=head[u.g];
    while ll<>0 do
    begin
      v:=d1[ll];
      cost:=d2[ll];
      if d[u.g][u.h]+cost<d[v][u.h] then//第一种情况
      begin
        d[v][u.h]:=d[u.g][u.h]+cost;
        newnode.g:=v;
        newnode.h:=u.h;
        getnode:=titititing(newnode);
        tree[ss[getnode]]:=d[v][u.h];
        change(ss[getnode] div 2);
      end;
      if (u.h<k) and (d[u.g][u.h]<d[v][u.h+1]) then//第二种情况
      begin
        d[v][u.h+1]:=d[u.g][u.h];
        newnode.g:=v;
        newnode.h:=u.h+1;
        getnode:=titititing(newnode);
        tree[ss[getnode]]:=d[v][u.h+1];
        change(ss[getnode] div 2);
      end;
      ll:=next[ll];
    end;
  end;
  ans:=inf;
  for i:=0 to k do
    ans:=min(ans,d[t][i]);
  writeln(ans);
end.
```

---

## 作者：IzumiSagiri (赞：9)

分层图的模版题      
什么是分层图     
分层图--------可以理解为有多个平行的图     
第i层表示用了i张免费卷后到达每个点的最短路     
显然，可以在同层跑最短路，而低层可以到高层       
这就满足了在不同层间无后效性的拓展    
于是我们可以设状态
```
dis[i][j]//表示在第j层（用j张免费卷）到第i个点的最短路径
dis[i][j]=Min(Min{dis[k][j]+value[k][i]},Min{dis[k][j-1]})
//k为与i联通的点
```
献上我丑陋的代码:    
```
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define ll long long

struct point{
    ll d,id,dep;
    bool operator <(const point &a)const{
        return d>a.d;
    }
};

priority_queue<point>q;

ll u[100005],v[100005],w[100005];
ll first[10005],next[100005];
ll tot=0;

inline void addedge(ll a,ll b,ll c){
    tot++;u[tot]=a,v[tot]=b,w[tot]=c;
    next[tot]=first[a];first[a]=tot;
}

ll dis[10005][15];
ll vis[10005][15];
ll n,m,k;

//管它卡不卡spfa,dij+heap常规操作
ll dijkstra(ll s,ll t){
    memset(dis,0x3f,sizeof dis);
    dis[s][0]=0;q.push({0,s,0});vis[s][0]=1;
    while(!q.empty()){
        point p=q.top();q.pop();
        ll x=p.id,op=p.dep,d=p.d;
        
        if(d!=dis[x][op])continue;
        vis[x][op]=1;
        
        for(int i=first[x];i;i=next[i]){
            int y=v[i];
            if(!vis[y][op]){
				if(dis[y][op]>dis[x][op]+w[i]){
					dis[y][op]=dis[x][op]+w[i];
					q.push({dis[y][op],y,op});
				}
            }
            if(op<k&&!vis[y][op+1]){
            	if(dis[y][op+1]>dis[x][op]){
            		dis[y][op+1]=dis[x][op];
            		q.push({dis[y][op+1],y,op+1});
				}
			}
        }
    }
    return dis[t][k];
}

int main(){
    scanf("%lld%lld%lld",&n,&m,&k);
    ll s,t;scanf("%lld%lld",&s,&t);
    for(ll i=1;i<=m;i++){
        ll a,b,c;scanf("%lld%lld%lld",&a,&b,&c);
        addedge(a,b,c);addedge(b,a,c);
    }
    printf("%lld",dijkstra(s,t));
    return 0;
}
```

---

## 作者：兮水XiShui丶 (赞：8)

## 这是一个分层图
### 然而我和楼下的那位做分层图的方式并不一样

话说为啥有几个点卡SPFA啊，去bzoj上都9100ms过了qwq
首先，因为这里的k很小，所以我们可以把判断的inque和vis数组直接开成二维数组。

然后我们每一次松弛时先用这个点去更新和他同一层的点，然后再用他更新下一层的点

而且统计答案的时候注意，要
```cpp
 F(i,0,k) 
     ans=min(ans,vis[i][go_t]);
```
因为在每一层中都找到t的最小值（最多k条免费）,为什么要在每一层都找，而不是只在最后一层寻找呢。假设有这么一种情况，由s--t的最少的路上的途径数目少于k条，那么在k之前的某一层上就有dis=0，但是如果必须使用k条路径的话，那么就会找的一条路途数多于k的路来满足这个条件，那么只用第k层的dis自然不是正确结果了

下边是代码： 
```cpp
	#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#define K 11
#define N 10000
#define M 110000
#define F(i,a,b) for(int i=a;i<=b;i++)
#define G(i,a,b) for(int i=head[a];i;i=b[i].next)

using namespace std;

int n,m,k,t,start,go_t;
struct Edge{
    int to;
    int data;
    int next;
}e[M];
struct Que{
    int time,cur;
    Que(int a,int b):time(a),cur(b){}
 	Que(){}
};
int head[N],vis[K][N];
bool inque[K][N];
int ans=2147483647;
queue <Que> qu;

void add (int x,int y,int z){
    e[++t].to=y;
    e[t].data=z;
    e[t].next=head[x];
    head[x]=t;
    return;
}
inline void spfa (int x){
    memset(vis,0x3f3f3f3f,sizeof(vis));
    vis[0][x]=0;inque[0][x]=1;qu.push(Que(0,start));
    while (!qu.empty()){
        Que j=qu.front();
        qu.pop();
        inque[j.time][j.cur]=0;
        G(i,j.cur,e){
            int k=e[i].to;
            if (vis[j.time][k]>vis[j.time][j.cur]+e[i].data){
                vis[j.time][k]=vis[j.time][j.cur]+e[i].data;
                if (!inque[j.time][k]){
                    inque[j.time][k]=1;
                    qu.push(Que(j.time,k));
                }
            }
        }
        if (j.time<k)
         G(i,j.cur,e){
         	int k=e[i].to;
         	if (vis[j.time+1][k]>vis[j.time][j.cur]){
         		vis[j.time+1][k]=vis[j.time][j.cur];
         		if (!inque[j.time+1][k]){
         			inque[j.time+1][k]=1;
         			qu.push(Que(j.time+1,k));
                 }
             }
         }
    }
    F(i,0,k) 
     ans=min(ans,vis[i][go_t]);
    return;
}

int main(){
    scanf ("%d%d%d",&n,&m,&k);
    scanf ("%d%d",&start,&go_t);
    F(i,1,m){
        int x,y,z;
        scanf ("%d%d%d",&x,&y,&z);
        add (x,y,z);
        add (y,x,z);
    }
    spfa(start);
    printf ("%d\n",ans);
    return 0;
}
```

---

## 作者：Randolph、 (赞：7)

## [P4568 [JLOI2011]飞行路线](https://www.luogu.org/problem/P4568)

感觉题解会沉底吧。。~~如果觉得好就赞一个吧qwq~~

分层图模板题，相似的题还有[P4822 [BJWC2012]冻结](https://www.luogu.org/problem/P4822)，[
P2939 [USACO09FEB]改造路Revamping Trails](https://www.luogu.org/problem/P2939),其实做惯了也就不难了。。

为什么有这篇题解？

- ~~感觉写的比较简洁清晰~~

- 线段树优化最短路

### 一、堆优化dijkstra

 652ms /  25.58MB /  1.31KB C++

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int MAXN=110005,MAXM=2500001;
struct edge {
	int to,dis,next;
} e[MAXM];
int n,m,k,s,t,head[MAXN],dis[MAXN],cnt;
bool vis[MAXN];
struct node {
	int dis,pos;
	bool operator <(const node &x)const {
		return x.dis<dis;
	}
};
priority_queue<node> q;
inline void add_edge(int u,int v,int d) {
	e[++cnt].dis=d;
	e[cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
inline void dijkstra() {
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	q.push((node) {
		0,s
	});
	while(!q.empty()) {
		node tmp=q.top();
		q.pop();
		int x=tmp.pos,d=tmp.dis;
		if (vis[x]) continue;
		vis[x]=1;
		for (int i=head[x]; i; i=e[i].next) {
			int y=e[i].to;
			if (dis[y]>dis[x]+e[i].dis) {
				dis[y]=dis[x]+e[i].dis;
				if (!vis[y])
					q.push((node) {
					dis[y],y
				});
			}
		}
	}
}
int main() {
	scanf("%d%d%d%d%d",&n,&m,&k,&s,&t);
	for (register int i=0; i<m; i++) {
		register int u,v,d;
		scanf("%d%d%d",&u,&v,&d);
		add_edge(u,v,d),add_edge(v,u,d);
		for(int j=1; j<=k; ++j) {
			add_edge(u+(j-1)*n,v+j*n,0);
			add_edge(v+(j-1)*n,u+j*n,0);
			add_edge(u+j*n,v+j*n,d);
			add_edge(v+j*n,u+j*n,d);
		}//每层之间建边
	}
	for(int i=1; i<=k; ++i) {
		add_edge(t+(i-1)*n,t+i*n,0);//每层终点连边（不一定用K次最优）
	}
	dijkstra();
	printf("%d",dis[k*n+t]);
	return 0;
}
```

### 二、线段树dijkstra

 523ms /  26.64MB /  1.41KB C++
 
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=110005,M=2500001;
int n,m,kth,cnt,s,t;
int tr[N<<2],h[N],nxt[M],to[M],w[M],dis[N];
#define R register int
inline int rd() {
	int t=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0' && c<='9') t=(t<<3)+(t<<1)+(c^48),c=getchar();
	return t;
}
inline void add_edge(int u,int v,int _w) {
	nxt[++cnt]=h[u],to[cnt]=v,w[cnt]=_w,h[u]=cnt;
}
#define min(a,b) (dis[a]<dis[b]? a:b)
inline void modify(int o,int l,int r,int pos,int val) {
	if (l==r) {
		tr[o]=val;
		return;
	}
	int mid=l+r>>1;
	if (pos<=mid) modify(o<<1,l,mid,pos,val);
	else modify(o<<1|1,mid+1,r,pos,val);
	tr[o]=min(tr[o<<1],tr[o<<1|1]);
}
inline void dijkstra() {
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0,modify(1,1,kth*n,s,s);//线段树存点的编号，然后通过比较dis上传
	for (R t=1,u,v; t<kth*n; t++) {
		u=tr[1],modify(1,1,kth*n,u,0);//dis0始终保持0x3f，作为删除操作
		for (R i=h[u]; i; i=nxt[i])
			if (dis[v=to[i]]>dis[u]+w[i])
				dis[v]=dis[u]+w[i],modify(1,1,kth*n,v,v);
	}
}
int main() {
	n=rd(),m=rd(),kth=rd(),s=rd()+1,t=rd()+1;//编号加1，空出dis0的位置
	for (R i=1,u,v,_w; i<=m; i++) {
		u=rd()+1,v=rd()+1,_w=rd();
		add_edge(u,v,_w),add_edge(v,u,_w);
		for(int j=1; j<=kth; ++j) {
			add_edge(u+(j-1)*n,v+j*n,0);
			add_edge(v+(j-1)*n,u+j*n,0);
			add_edge(u+j*n,v+j*n,_w);
			add_edge(v+j*n,u+j*n,_w);
		}
	}
	for (R i=1;i<=kth;i++)
	 add_edge(t+(i-1)*n,t+i*n,0);
	kth++;
	dijkstra();
	printf("%d",dis[(kth-1)*n+t]);
	return 0;
}
```

三、DP最短路

 296ms /  2.26MB /  1.15KB C++
 
 这种方法最快，而且数组的范围比较好确定
 
 注意dis，vis，node是二维，要记录点的编号和所用次数
 
 ```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct edge {
	int v,w,h;
} e[100010];
int n,m,K,s,t,cnt,ans,h[10010],d[10010][11];
bool vis[10010][11];
struct node {
	int u,k;
	bool operator <(const node &x) const {
		return d[u][k]>d[x.u][x.k];
	}
};
inline void add(int u,int v,int w) {
	e[++cnt]=(edge) {v,w,h[u]},h[u]=cnt;
}
inline void dijkstra() {
	priority_queue<node> q;
	memset(d,0x3f,sizeof d);
	q.push((node) {
		s,0
	}),d[s][0]=0,vis[s][0]=1;//s点，用了0次
	while(!q.empty()) {
		node x=q.top();
		q.pop(),vis[x.u][x.k]=0;
		for (register int i=h[x.u],v,u,k; i; i=e[i].h) {
			if (d[v=e[i].v][k=x.k]>d[u=x.u][k]+e[i].w) {
				d[v][k]=d[u][k]+e[i].w;
				if (!vis[v][k]) q.push((node) {
					v,k
				}),vis[v][k]=1;
			}//更新不使用的情况，k不变
			if (d[v][k+1]>d[u][k] && k<K) {
				d[v][k+1]=d[u][k];
				if (!vis[v][k+1] && k<K) q.push((node) {
					v,k+1
				}),vis[v][k+1]=1;
			}//更新使用的情况，k加1且小于K
		}
	}
}
int main() {
	scanf("%d%d%d%d%d",&n,&m,&K,&s,&t);
	for (int i=1,u,v,w; i<=m; i++)
		scanf("%d%d%d",&u,&v,&w),add(u,v,w),add(v,u,w);
	dijkstra();
	ans=1e9;
	for (int i=0; i<=K; i++)
		ans=ans<d[t][i]? ans:d[t][i];//用几次最优
	printf("%d",ans);
}
```


---

## 作者：w2321 (赞：6)

# 分层图最短路
[转载地址](https://blog.csdn.net/Robin2321/article/details/103964365)


 - 题目 [P4568飞行路线](https://www.luogu.com.cn/problem/P4568)
 
#### 做法
 - 题目说一共有k次免费乘坐机会。
 - 我们可以假设每个点都有免费通向下一个点的一条路，建k+1层图。
![](https://img-blog.csdnimg.cn/20200114184409834.png)
 - （当然这里要建双向边）第一行是第一层图，第二行是第二层图（注：因为第一层有n个点，所以第二层要从n+0开始，避免重复）第一层表示不消耗免费次数，第二层表示消耗一次免费次数，以此类推，**第 i 层表示消耗 i-1 次免费次数**。
 - 于是我们就可以通过比较起点0到终点 n , 2n , 3n，. . .，(k+1)*n 的最短路来找到**消耗k次免费机会后的最短路**，也就是最小花费。
 - `ans=min(dis[n],dis[2*n],dis[3*n],...,dis[(k+1)*n]);`
 ##### 举个例子
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200118103349217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JvYmluMjMyMQ==,size_16,color_FFFFFF,t_70)
`
 - `dis[2]`表示1到2的最短路,`dis[5]`表示1到5的最短路；
 - `dis[10]`表示1到10的最短路，由图可以看出，**有且只有**经过了**1**条权值为0的边才能到10这个点，也就是说花费了**1**次免费机会；
 -  同样，`dis[15]`表示1到15的最短路，由图可以看出，**有且只有**经过了**2**条权值为0的边才能到15这个点，也就是说花费了**2**次免费机会；
 - 同理，`dis[20]`表示1到20的最短路，由图可以看出，**有且只有**经过了**3**条权值为0的边才能到20这个点，也就是说花费了**3**次免费机会；
 - 以此类推，`dis[25]`表示1到25的最短路，由图可以看出，**有且只有**经过了**4**条权值为0的边才能到25这个点，也就是说花费了**4**次免费机会；
 - 所以，显然，`ans=min(dis[5],dis[10],dis[15],dis[20],dis[25]);`**（这里要看k是多少，比较k+1个数的大小）。**


##### 下面看代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define maxn 900005//因为要建n*(k+1)个点 
#define maxm 90000005//因为有好多条边（当然我这里太大了点） 
#define inf 0x7fffffff
#define ri register int
using namespace std;
priority_queue<pair<int,int> >q;//骚操作 
int to[maxm];
int weight[maxm];
int next[maxm];
int head[maxn];
int dis[maxn];
int vis[maxn];
int n,m,K,s,t,cnt;
inline int read()//快读 
{
	ri x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0') 
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
inline void add_edge(int u,int v,int w)//建边 
{
	to[cnt]=v;
	weight[cnt]=w;
	next[cnt]=head[u];
	head[u]=cnt;
	cnt++;
}
void Dijkstra(int s,int t)//这里和最短路一毛一样 
{
	for(ri i=0;i<=maxn;++i) dis[i]=inf;//每个点都要初始化 
	dis[s]=0;
	q.push(make_pair(-dis[s],s));
	while(q.size())
	{
		ri k=q.top().second;
		q.pop();
		if(vis[k]) continue;
		vis[k]=1;
		for(ri i=head[k];i!=-1;i=next[i])
		{
			ri v=to[i],w=weight[i];
			if(!vis[v]&&dis[k]+w<dis[v])
			{
				dis[v]=dis[k]+w;
				q.push(make_pair(-dis[v],v));
			}
		}
	}
}
int main()
{
	n=read(),m=read(),K=read();
	s=read(),t=read();
	memset(head,-1,sizeof(head));
	for(ri i=1,u,v,w;i<=m;++i)
	{
		u=read(),v=read(),w=read();
		for(ri j=0;j<=K;++j)
		{
			add_edge(u+n*j,v+n*j,w);//建当前层的图 
			add_edge(v+n*j,u+n*j,w);
			if(j!=K)//第K层没有下一层 
			{
				add_edge(u+n*j,v+n*(j+1),0);//建下一层的图 
				add_edge(v+n*j,u+n*(j+1),0);
			}
		}
	}
	Dijkstra(s,t);
	ri min=inf;
	for(ri i=0;i<=K;++i)
		if(dis[t+n*i]<min) min=dis[t+n*i];//找K+1层中最小的值 
	printf("%d",min);
	return 0;
}
```

 - 看不懂我的代码的请看[这里](https://blog.csdn.net/Robin2321/article/details/103979475)。


---

## 作者：bztMinamoto (赞：6)

为什么卡spfa啊QAQ……在其他地方用spfa都能过的说……害得我要用dijkstra重新打一遍……

我们可以用图的思路来考虑这道问题。首先，这道题因为有k次免费机会，所以不能和平常的最短路一样考虑，因为那样会导致无法判定哪些边应该免费。

既然无法以城市为点，那我们换个思路，以每一个状态为点。设（x+i乘n）表示一个节点，x为城市编号，i为用了i次免费机会。那么，我们可以从（x+i乘n）向（y+i乘n）连一条长度为z的边，从（x+i乘n）向（x+（i+1）乘n）连一条长度为0的边。这就变成一道N（k+1）个点的图。在这一个有向图上，我们只需要求出1到（x+i乘k）的最小距离，即为所求的答案

温馨提示，请不要用spfa，用堆优化的dijkstra，否则……

ps：话说为什么乘号打不出来……

具体细节看注解，上代码（我知道你们只关心这个）
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<cstring>
#define a(a,b,c) for(int a=b;a<=c;a++)
#define b(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
typedef long long LL;
const int N=110050,M=2100050,INF=0x3f3f3f3f;
struct ab{
    int y,z;
};
int ver[M],edge[M],Next[M],head[N],used[N],d[N];
int n,m,k,s,t,tot;
bool operator < (ab i,ab j)
{
	if((i.z-1)/n!=(j.z-1)/n) return (i.z-1)/n>(j.z-1)/n;
	return i.z>j.z;
    //注意，堆里要优先使用的免费次数少的，再考虑边权，否则会WA
}
void add(int x,int y,int z)
{
    ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
    return;
}
void kruskal(int s)
{
    priority_queue<ab> q;
    q.push(ab{s,0});
    memset(d,0x3f,sizeof(d));
    d[s]=0;
    while(!q.empty())
    {
        int x=q.top().y;
        q.pop();
        if(used[x]) continue;
        used[x]=1;
        for(int i=head[x];i;i=Next[i])
        {
            int y=ver[i],z=edge[i];
            if(d[y]>d[x]+z)
            {
                d[y]=d[x]+z;
                q.push(ab{y,d[y]});
            }
        }
    }
}
int main()
{
    scanf("%d%d%d%d%d",&n,&m,&k,&s,&t),s++,t++;
    //将题目的0——n-1改为1——n存储
    a(i,0,m-1)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        x++,y++;
        a(j,0,k-1)
        {
            add(x+j*n,y+j*n,z);
            add(y+j*n,x+j*n,z);
            add(x+j*n,y+(j+1)*n,0);
            add(y+j*n,x+(j+1)*n,0);
            //如上面所说，将无向图连边
        }
        add(x+k*n,y+k*n,z);
        add(y+k*n,x+k*n,z);
    }
    kruskal(s);
    //有可能航线总共都不足k条，以防万一（虽然直接输出也能A就是了……）
    b(i,k,0)
    if(d[t+i*n]!=INF)
    {
        printf("%d\n",d[t+i*n]);
        return 0;
    }
    return 0;
}
```

---

## 作者：Isprime (赞：6)

## 题解P4568[JLOI]飞行路线

[配合Blog食用更佳](https://www.luogu.org/blog/149815/solution-p4568)

[原题传送门](https://www.luogu.org/problem/P4568)

**分层图模板题**

题意简化：有n个点，m条边，求s到t的最短路


原本是这样的（图很丑，请见谅）

![](https://cdn.luogu.com.cn/upload/pic/72236.png)

但题目中多了一个条件：我们至多可以让k条边的权值变为0（不一定要有k条边权值变成0）

这不就是分层图裸题吗，建k层图（因为k≤10，所以并不会占用太大的空间），举个栗子：x和y之间有一条权值为z的边，则第0到k层的x,y之间都要连权值为z的边,第0到k-1层的x或y连到第i+1层的y或x的权值改为0（代表一次免费乘坐飞机）

图就变成了下面这个样子↓

![](https://cdn.luogu.com.cn/upload/pic/72243.png)

~~乱七八糟，看都看不清~~

p.s.图中8和9的编号画反了 ~~，凑合着看吧~~

好吧等有时间了我会改

所以最终答案只需要跑一边Dijkstra再找出dis[i*(n+1)+t]的最小值即为答案

Code
```cpp
#include<cstdio>
#include<queue>
#define ri register int
#define MAXN 10001
#define MAXM 50001
#define INF 2147483647
using namespace std;
int n,m,k,s,t,edge_sum;
int head[MAXM*201],dis[MAXN*201];
bool vis[MAXN*201];
struct Edge{
	int next,to,dis;
}edge[MAXM*201];//前向星存图
inline void addedge(int from,int to,int dis){
	edge[++edge_sum].next=head[from];
	edge[edge_sum].dis=dis;
	edge[edge_sum].to=to;
	head[from]=edge_sum;
}
struct Node{
	int u,dis;
	bool operator <(const Node& rhs) const {
        return dis>rhs.dis;
    }
};
inline void dijkstra(){//堆优化Dij
	priority_queue<Node> q;//STL优先队列，用来优化Dij
	q.push((Node){s,0});
	while(!q.empty()) {
		int u=q.top().u;
		q.pop();
		vis[u]=1;
		for(ri i=head[u];i;i=edge[i].next)
			if(!vis[edge[i].to]&&dis[edge[i].to]>dis[u]+edge[i].dis){
				dis[edge[i].to]=dis[u]+edge[i].dis;		
				q.push((Node){edge[i].to,dis[edge[i].to]});
			}
	}
}
int main()
{
	scanf("%d %d %d",&n,&m,&k);
	scanf("%d %d",&s,&t);
   for(ri i=1;i<=m;i++)
   {
    int x,y,z;
       scanf("%d%d%d",&x,&y,&z);
       for(ri j=0;j<=k;j++) addedge(j*(n+1)+x,j*(n+1)+y,z),addedge(j*(n+1)+y,j*(n+1)+x,z);//因为是无向图所以存两次
       for(ri j=0;j<k;j++) addedge(j*(n+1)+x,(j+1)*(n+1)+y,0),addedge(j*(n+1)+y,(j+1)*(n+1)+x,0);//存第i层的x(y)和第i+1层的y(x)之间的边
   }
   for(ri i=0;i<=(n+1)*k+n;i++) dis[i]=INF;//初始值赋为INF
   dis[s]=0;
   dijkstra();//Dij求最短路
   int min=INF;
   for(ri i=0;i<=k;i++) if(min>dis[i*(n+1)+t]) min=dis[i*(n+1)+t];//寻找最优解
   printf("%d\n",min);
   return 0;
}
```

# 说句闲话：研究分层图的最好方法是
### A了4568,再A了2939，还要A了4822
**祝你们成功 (滑稽**

AC紫题+=3;

我都告诉你这么多了，不点个赞？

---

## 作者：AcerMo (赞：5)

没有卡SPFA啊？？加一个玄学优化就过了啊23333
我们定义一个二维dis，dis[i][j]表示到第i个点，用了j次免费机会的最短路径，用优先队列优化最短路，第一次跑到ed时，一定是最短路。（STL建图版的SPFA）
```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e4+5;
const int M=1e5+10;
int st,ed;
int n,m,kpath;
int dis[N][15],vis[N][15];
struct edge
{
	int to,cost;
}add;
vector<edge>v[M];
struct fast
{
	int to,cost,k;
	bool friend operator < (fast a,fast b)
	{
		return a.cost>b.cost; 
	} 
}now,t;
priority_queue<fast>q;
void SPFA()
{
	memset(dis,0x3f,sizeof(dis));
	now.to=st;now.cost=0;now.k=0;
	q.push(now);dis[st][0]=0;
	while (q.size())
	{
		now=q.top();q.pop();
		if (vis[now.to][now.k]) continue;
		vis[now.to][now.k]=1;
		if (now.to==ed) {cout<<now.cost;return ;}
		for (int i=0;i<v[now.to].size();i++)
		{
			int go=v[now.to][i].to;
			int pay=v[now.to][i].cost;
			if (now.k<kpath&&!vis[go][now.k+1]&&dis[go][now.k+1]>now.cost)
			{
				dis[go][now.k+1]=now.cost;
				t.to=go;t.cost=now.cost;t.k=now.k+1;
				q.push(t);
			}
			if (dis[go][now.k]>now.cost+pay&&!vis[go][now.k])
			{
				dis[go][now.k]=now.cost+pay;
				t.to=go;t.cost=dis[go][now.k];t.k=now.k;
				q.push(t);
			}
		}
	}
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&kpath,&st,&ed);
	for (int i=1;i<=m;i++)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add.to=a;add.cost=c;v[b].push_back(add);
		add.to=b;add.cost=c;v[a].push_back(add);
	}
	SPFA();
	return 0;
}

```

---

## 作者：lxy__ (赞：4)

这是一道很经典的分层图最短路题

考虑把图分成 $k$ 层（就是每个点复制 $k$ 次），第 $i$ 层表示当前已经使用了 $i$ 次免费机会。

首先，我们将**每一层图**都按照给定的方式连边。如 $a$ 点可以通向 $b$ 点，长度为 $c$ ，那么

1. 当前层 $a$ 通向当前层 $b$ 花费为 $c$ 。（ 不使用 ）

2. 当前层 $b$ 通向当前层 $a$ 花费为 $c$ 。

3. 由当前层的 $a$ 通往下一层 $b$ ，免费。（ 使用一次免费机会 ）

4. 由当前层的 $b$ 通往下一层 $a$ ，免费。

因为只有 $k$ 层，所以最多只能使用 $k$ 次免费机会。

然后跑 $dijkstra +$ 堆优化，在每一层的 $t$ 点处取最小值即可。

双倍经验前往[P2939 [USACO09FEB]改造路Revamping Trails](https://www.luogu.org/problemnew/show/P2939)

## Code

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=1000005; // 防 RE 数组大小
struct Edge
{
	int nxt,to,w;
}e[maxn*10];
struct node
{
	int id,dis;
	friend bool operator<(node x,node y) // 从小到大排序
	{
		return x.dis>y.dis;
	}
};
priority_queue<node>q;
int n,m,k,s,t,a,b,c,cnt=0,ans=0x3f3f3f3f,vis[maxn],dis[maxn],head[maxn];
void add(int x,int y,int w) // 邻接表存图
{
	e[++cnt]=(Edge){head[x],y,w};
	head[x]=cnt;
}
void dijkstra() // 最短路（不会的请右转单源最短路模板）
{
	memset(vis,0,sizeof(vis));
	memset(dis,0x3f,sizeof(dis));
	q.push((node){s,0});
	dis[s]=0;
	while(!q.empty())
	{
		int a=q.top().id;
		q.pop();
		if(vis[a]) continue;
		vis[a]=1;
		for(int i=head[a];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(dis[v]>dis[a]+e[i].w) 
			{
				dis[v]=dis[a]+e[i].w;
				if(!vis[v])
					q.push((node){v,dis[v]});
			}
		}
	}
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&k,&s,&t);
	s++; t++; // 个人习惯从1开始
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&a,&b,&c);
		a++; b++;
		for(int j=0;j<=k;j++) // 循环层数
		{
			add(a+j*n,b+j*n,c); // 每一层都按照给定方式连边
			add(b+j*n,a+j*n,c);
			if(j<k)
			{
				add(a+j*n,b+(j+1)*n,0); // 当前a -> 下一层b
				add(b+j*n,a+(j+1)*n,0); // 当前b -> 下一层a
			}
		}
	}
	dijkstra();
	for(int i=0;i<=k;i++)
		ans=min(ans,dis[i*n+t]); // 统计答案
	printf("%d",ans);
	return 0;
}
```


---

## 作者：寒鸽儿 (赞：3)

### 分层图最短路模板
板子没什么好讲的，大家讨论得都差不多了，来说一说一些细节和启示。  
首先，本蒟蒻在接触到这个的时候就感觉很多的代码并不是特别完善。例如针对dis[v][p]的更新取到的最小值不一定小于dis[v][t], 其中t < p。这不符合贪心原理。其原因是,我们用dijkstra或spfa维护dp时要求不重复走过路，因而大多数代码跑出来的是严格使用p次机会取到的最优值，而不是至多使用p次机会取得的。这在某种意义上也算是一种限制条件。发现本题所谓的"hack"数据就是基于这个原理弄出来的(其实当初初学的时候就设计过类似的东西)。  
为了取得合理的答案，可以考虑用dis[v][p]更新dis[v][z],p<z<=k。具体的，可以在dij过程中维护(但是复杂度较高)。当然本题只是求到某点的最短路，所以不必要这么麻烦，只要在输出前扫描所有的dis[e][p]，e为结束点,0<= p <= k,取最小值即可。
最后附上代码  
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define pii pair<int, int>
#define pip pair<int, pii>

using namespace std;

int head[10010], ver[100010], wei[100010], nex[100010], d[10010][20], tot, n, k, s, e;

inline void add(int u, int v, int w) {
    ver[tot] = v; wei[tot] = w; nex[tot] = head[u]; head[u] = tot++;
}

priority_queue<pip> q;

void dijkstra(int s) {
    d[s][0] = 0;
    q.push(make_pair(0, make_pair(s, 0)));
    while(!q.empty()) {
        int cur = q.top().second.first, p = q.top().second.second, de = -q.top().first; q.pop();	
        if(de > d[cur][p]) continue;
        for(int i = head[cur]; i != -1; i = nex[i]) {
            int u = cur, v = ver[i], w = wei[i];
            if(d[v][p] > d[u][p] + w) {
                d[v][p] = d[u][p] + w; q.push(make_pair(-d[v][p], make_pair(v, p)));
            }
            if(p < k && d[v][p+1] > d[u][p]) {
                d[v][p+1] = d[u][p]; q.push(make_pair(-d[v][p+1], make_pair(v, p+1)));
            }
        }
    }
}

int main() {
    int m, u, v, w;
    scanf("%d %d %d %d %d", &n, &m, &k, &s, &e);
    memset(head, -1, sizeof(head));
    while(m--) {
        scanf("%d %d %d", &u, &v, &w);
        add(u, v, w); add(v, u, w);
    }
    memset(d, 0x3f, sizeof(d));
    dijkstra(s);
    int res = 0x3f3f3f3f;
    for(int i = 0; i <= k; i++) res = min(res, d[e][i]);
    printf("%d\n", res);
    return 0;
}
```
欢迎互相关注(然而在oi界蒟蒻的圈很小)。  
最后安利一下[蒟蒻的洛谷博客](https://www.luogu.org/blog/oldherd/)

---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P4568)看题目。 
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先考虑特殊情况（$k=1$）。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~过于经典~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑从$1$开始求出到所有点的最短路数组$f[]$，从$n$开始求出到所有点的最短路数组$g[]$（$g$当然是在反图上面跑出来的）。枚举每一条边$(u,v)$，假如它就是那条不花钱的边，那么此时的花费就是$f[u]+g[v]$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而现在$k\not=1$了，怎么做呢？  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重新考虑$k=1$，我们换一个思路。考虑$DP$。状态$f(u,0/1)$表示从$1$出发，到达$u$点，不使用/使用特权的最小花费。转移方程比较简单：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle f(u,0)=\min_{(v,u)\in E}\{f(v,0)+w(v,u)\},f(u,1)=\min_{(v,u)\in E}\{\min\{f(v,0),f(v,1)+w(v,u)\}\}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果原图是$DAG$，那么我们当然可以$DP$。但是原图不是啊......所以我们还是得建图跑$Dijkstra$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;怎么建呢？考虑建两个图，第一个表示没有使用特权，第二个表示使用过了。自然，原图中的点$u$就对应地变成了$u_1$和$u_2$。对于每条边$e\in E$，在新图中建两类边$E_1$和$E_2$，$E_1$中有$(u_1,v_1)$和$(u_2,v_2)$，边权均为$w(e)$，也就是表示不用特权；$E_2$中只有$(u_1,v_2)$，边权为$0$，表示使用特权。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跑完之后答案就是$n_1$和$n_2$的最短路的最小值。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在把这个方案扩展到$k>1$的情况。状态$f(u,k)$表示从$1$出发，到达$u$点，使用$k$次特权的最小花费。状态转移应该可以自己列出来了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在考虑建新图。一个点$u$就变成了$u_1,u_2,...,u_{k+1}$;一条边$e\in E$变成了$E_1$和$E_2$两类边。$E_1$中为$(u_1,u_1),(u_2,u_2),...,(u_{k+1},u_{k+1})$，边权均为$w(e)$；$E_2$中为$(u_1,u_2),(u_2,u_3),...,(u_k,u_{k+1})$，边权均为$0$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为$n_1,n_2,...,n_{k+1}$的最短路的最小值。
# 代码
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 5, MAXM = 5e4 + 5, MAXK = 15;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct node
{
	int u, dis;
	node(){}
	node( const int U, const int Dis ){ u = U, dis = Dis; }
	bool operator < ( const node & other ) const { return ! ( dis < other.dis ); }
};

struct edge
{
	int to, nxt, w;
}Graph[MAXK * MAXM * 4 + MAXK * 2];

priority_queue<node> q;

int dis[MAXN * MAXK];
int head[MAXN * MAXK];
int N, M, K, S, T, cnt;
bool visited[MAXN * MAXK];

void addEdge( const int from, const int to, const int W )
{
	cnt ++;
	Graph[cnt].w = W, Graph[cnt].nxt = head[from], Graph[cnt].to = to;
	head[from] = cnt;
}

void Dijkstra( const int sta )
{
	while( ! q.empty() ) q.pop();
	memset( dis, 0x3f, sizeof( dis ) ), memset( visited, false, sizeof( visited ) );
	dis[sta] = 0, q.push( node( sta, 0 ) );
	node h;
	int v, w;
	while( ! q.empty() )
	{
		h = q.top(), q.pop();
		if( visited[h.u] ) continue;
		visited[h.u] = true;
		for( int i = head[h.u] ; i ; i = Graph[i].nxt )
		{
			v = Graph[i].to, w = Graph[i].w;
			if( ! visited[v] && dis[v] > dis[h.u] + w )
				dis[v] = dis[h.u] + w, q.push( node( v, dis[v] ) );
		}
	}
}

int main()
{
	int fr, to, W;
	read( N ), read( M ), read( K );
	read( S ), read( T );
	for( int i = 1 ; i <= M ; i ++ )
	{
		read( fr ), read( to ), read( W );
		for( int j = 0 ; j < K ; j ++ ) addEdge( fr + j * N, to + ( j + 1 ) * N, 0 ), addEdge( to + j * N, fr + ( j + 1 ) * N, 0 );
		for( int j = 0 ; j <= K ; j ++ ) addEdge( fr + j * N, to + j * N, W ), addEdge( to + j * N, fr + j * N, W );
	}
	Dijkstra( S );
	int res = INF;
	for( int i = 0 ; i <= K ; i ++ )
		res = MIN( res, dis[i * N + T] );
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：回青绝影 (赞：2)

### 裸的分层图……

------------

[P4822](https://www.luogu.org/problem/P4822)

[P4568](https://www.luogu.org/problem/P4568)

[P1948](https://www.luogu.org/problem/P1948)

[P2939](https://www.luogu.org/problem/P2939) <--毒瘤，卡数组大小

### 4倍经验！


------------

将上下两层之间连上权值为0的边就可以了！

然后就是分层图常规操作了

注意细节！
细节处打 $ * $ 号

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1500001;
struct st{
    int dis,x;
    st (const int a,const int b){
        dis=a;
        x=b;
    }
    bool operator < (const st a)const {
        return dis>a.dis;
    }
};
priority_queue <st> q;
int n,m,cnt,s,t,k;
int nxt[2*N],last[2*N],a[2*N],w[2*N];
int dis[N];
bool l[N];
void add(int x,int y,int z){
    nxt[++k]=last[x];
    last[x]=k;
    a[k]=y;
    w[k]=z;
}
void dijkstra(int s){
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    q.push(st(0,s));
    while (!q.empty()){
        while (!q.empty()&&l[q.top().x]) q.pop();
        if (q.empty()) break;
        int x=q.top().x;q.pop();
        l[x]=1;
        for (int i=last[x];i;i=nxt[i]){
            int y=a[i];
            if (dis[y]>dis[x]+w[i]){
                dis[y]=dis[x]+w[i];
                q.push(st(dis[y],y));
            }
        }
    }
}
signed main(){
    scanf("%lld%lld%lld%lld%lld",&n,&m,&cnt,&s,&t);
    // for (int i=0;i<n;i++) last[i]=-1;
    for (int x,y,z,i=1;i<=m;i++){
        scanf("%lld%lld%lld",&x,&y,&z);
        add(x,y,z);add(y,x,z);
        for (int j=1;j<=cnt;j++){
            add(x+(j-1)*n,y+j*n,0);
            add(y+(j-1)*n,x+j*n,0);
            add(x+j*n,y+j*n,z);						//*
            add(y+j*n,x+j*n,z);						//*
        }
    }
    for (int i=1;i<=cnt;i++) add(t+(i-1)*n,t+i*n,0);	//*
    dijkstra(s);
    printf("%lld",dis[t+cnt*n]);
    return 0;
}
```


---

## 作者：Sangber (赞：2)

### 前言
看到好多大佬都在跑分层图最短路，$\text{DP}$ 解法的我瑟瑟发抖。。。

----
### 题目描述
给定一张 $N$ 个点（点编号从 $0$ 到 $N-1$），$M$ 条边的无向带权图 $G$。给定常数 $k$，你可以在图 $G$ 中使不超过 $k$ 条边的边权为 $0$，求在该条件下点 $s$ 到点 $t$ 的最短路。  
数据范围：$2\le N\le10000,1\le M\le50000,0\le k\le10$

----
### 基本思路
考虑 $\text{DP}$  
我们设 $dis[i][u]$ 表示从点 $s$ 出发对 $i$ 条边的边权清零时的最短路，答案就是 $dis[k][t]$  
考虑转移：  
首先跑一遍裸的最短路，求出 $dis[0][u]\ u \in[0,n-1]$  
然后对于 $\forall\ i \in [1,k]$  
$$dis[i][u]=min\{dis[i-1][v],dis[i][v]+(v,u)\}$$
其中 $u$ 是 $v$ 的后继。  
然后就可以开始转移了。  

----
### 注意事项

+ 点编号从 $0$ 到 $N-1$
+ 无向图边的空间开两倍

----
### 参考代码
```cpp
/*--------------------------------
  Author: The Ace Bee
  Blog: www.cnblogs.com/zsbzsb
  This code is made by The Ace Bee
--------------------------------*/
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <cmath>
#include <ctime>
#include <queue>
#define rg register
#define mp make_pair
#define pii pair < int, int >
using namespace std;
template < typename T > inline void read(T& s) {
	s = 0; int f = 0; char c = getchar();
	while (!isdigit(c)) f |= (c == '-'), c = getchar();
	while (isdigit(c)) s = s * 10 + (c ^ 48), c = getchar();
	s = f ? -s : s;
}
const int _ = 10010;
const int __ = 100010;
int n, m, k, s, t, dis[11][_], exi[_];
int tot, head[_], nxt[__], ver[__], w[__];
inline void Add_edge(int u, int v, int d)
{ nxt[++tot] = head[u], head[u] = tot, ver[tot] = v, w[tot] = d; }
queue < int > q1, q2;
inline void spfa1(int x) {
	memset(dis[x], 0x3f, sizeof dis[x]);
	dis[x][s] = 0, exi[s] = 1;
	q1.push(s), q2.push(s);
	while (!q1.empty()) {
		int u = q1.front(); q1.pop(), exi[u] = 0;
		for (rg int i = head[u]; i; i = nxt[i]) {
			int v = ver[i];
			if (dis[x][v] > dis[x - 1][u]) {
				dis[x][v] = dis[x - 1][u];
				if (!exi[v])
					exi[v] = 1, q1.push(v), q2.push(v);
			}
		}
	}
}
inline void spfa2(int x) {
	if (x == 0)
		memset(dis[x], 0x3f, sizeof dis[x]), q2.push(s);
	dis[x][s] = 0, exi[s] = 1;
	while (!q2.empty()) {
		int u = q2.front(); q2.pop(), exi[u] = 0;
		for (rg int i = head[u]; i; i = nxt[i]) {
			int v = ver[i];
			if (dis[x][v] > dis[x][u] + w[i]) {
				dis[x][v] = dis[x][u] + w[i];
				if (!exi[v]) exi[v] = 1, q2.push(v);
			}
		}
	}
}
int main() {
#ifndef ONLINE_JUDGE
	freopen("in.in", "r", stdin);
#endif
	read(n), read(m), read(k), read(s), read(t);
	for (rg int u, v, d, i = 1; i <= m; ++i)
		read(u), read(v), read(d), Add_edge(u, v, d), Add_edge(v, u, d);
	spfa2(0);
	// for (rg int u = 0; u < n; ++u)
	// 		printf("%d%c", dis[0][u], " \n"[u == n - 1]);
	for (rg int i = 1; i <= k; ++i) {
		spfa1(i);
		// for (rg int u = 0; u < n; ++u)
		// 	printf("%d%c", dis[i][u], " \n"[u == n - 1]);
		spfa2(i);
		// for (rg int u = 0; u < n; ++u)
		// 	printf("%d%c", dis[i][u], " \n"[u == n - 1]);
	}
	printf("%d\n", dis[k][t]);
	return 0;
}

```
----
**完结撒花 $QwQ$**

---

## 作者：arfa (赞：2)

用高度来限制 $K$,这个很好理解,看第一位的图可知了。

当然 $DP$ 也是可以的。

手写堆 $7.in$ 会炸掉! 因为会有 $heap_{num} \leq 0$ 的时候!

![](https://i.loli.net/2018/11/24/5bf95120d3c3a.png)

```pascal
// luogu-judger-enable-o2
// T1

Uses math;

var
    next,rope,from,value,reach:array[-1..21000000] of longint;
    heap,node:array[-1..21000000] of longint;
    dis,cnt:array[-1..510000] of longint;
    id:array[-1..510000,-1..11] of longint;
    ask:array[-1..510000] of boolean;
    l,r,k,i,j,n,m,num,tot,free,sink,source:longint;

procedure swap(var a,b:longint);var t:longint; begin t:=a; a:=b; b:=t; end;

procedure add(l,r,sum:longint);
begin
    inc(tot); from[tot]:=l; reach[tot]:=r; value[tot]:=sum; next[tot]:=cnt[l]; cnt[l]:=tot;
end;

procedure Insert(x:longint);
var father:longint;
begin
    if x=1 then exit;
    father:=x >> 1;
    if heap[father]>heap[x] then
    begin
        swap(heap[x],heap[father]); swap(node[x],node[father]);
        Insert(father);
    end;
end;

procedure Down(x:longint);
var son:longint;
begin
    if x << 1>num then exit;
    son:=x << 1;
    if (son+1<=num)and(heap[son+1]<=heap[son]) then inc(son);
    if heap[x]>heap[son] then begin swap(heap[x],heap[son]); swap(node[x],node[son]); end;
    Down(son);
end;

procedure Dijkstar;
var i,key,rope:longint;
begin
    fillchar(ask,sizeof(ask),0);
    rope:=0; dis[source]:=0; num:=0;
    for i:=1 to free do
    begin
        inc(num); heap[num]:=dis[id[source,i]]; node[num]:=id[source,i];
        Insert(num);
    end;
    repeat
        key:=node[1];
        heap[1]:=heap[num]; node[1]:=node[num];
        dec(num); down(1);
        if ask[key]=False then
        begin
            inc(rope); ask[key]:=True;
            i:=cnt[key];
            while i<>-1 do
            begin
                if (dis[reach[i]]>value[i]+dis[key]) then
                begin
                    dis[reach[i]]:=value[i]+dis[key];
                    inc(num); heap[num]:=dis[reach[i]]; node[num]:=reach[i];
                    Insert(num);
                end;
                i:=next[i];
            end;
        end;
    until rope=n*free;
end;

begin
    filldword(dis,sizeof(dis) div 4,maxlongint div 84);
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);
    filldword(heap,sizeof(heap) div 4,0);
    read(n,m,free,source,sink);
    inc(free); inc(source); inc(sink);
    for j:=1 to free do for i:=1 to n do id[i,j]:=(j-1)*n+i;
    for j:=1 to free do dis[id[source,j]]:=0;
    for i:=1 to m do
    begin
        read(l,r,k); inc(l); inc(r);
        for j:=1 to free do begin add(id[l,j],id[r,j],k); add(id[r,j],id[l,j],k); end;
        for j:=1 to free-1 do begin add(id[l,j],id[r,j+1],0); add(id[r,j],id[l,j+1],0); end;
    end;
    Dijkstar;
    writeln(dis[id[sink,free]]);
end.
```

---

## 作者：sun123zxy (赞：2)

[blog中查看](https://www.cnblogs.com/sun123zxy/p/shortestpath.html)

嘛，这是分层图最短路的模版题

说白了就是图上动态规划。对路径有额外要求，在普通的最短路上给dis数组上加维表示状态就行

比如此题就是dis[i][j]表示当走到i点，还剩j张免费劵时花费的最小值

在单源最短路的基础上有2种情况

第一种是不用劵转移到下一节点，花钱转移。dis[to][fr]=dis[id][fr]+edge[i].w

第二种是用劵转移，这是不需要花钱，但余下免费劵的数量减1。dis[to][fr-1]=dis[id][fr]

注意第二种情况当免费劵已经用完时不能转移

这道题目只需要更新这2种情况，有些可以叠加使用的题目就得多一重循环转移了
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;

const int INF=2147483647;
int n,m,K,Start,End;
struct star{//链式前向星 
    int u,v,w;
}edge[100005];
int last[100005],next[100005];
void addedge(int u,int v,int w){
    m++;
    edge[m]=(star){u,v,w};
}
void starinit(){//前向星初始化 
    for(int i=1;i<=n;i++) last[i]=-1;
    for(int i=1;i<=m;i++){
        int flag=edge[i].u;
        next[i]=last[flag];
        last[flag]=i;
    }
}
struct em{//加到优先队列里的结构体 
    int id,fr,val;
    bool operator<(em uuz)const{//重载，STL里的优先队列默认是大根堆 
        return val>uuz.val;
    }
};
int dis[100005][15];
priority_queue<em>heap;
void dij(int sta){//dijkstra+优先队列 
    for(int i=1;i<=n;i++)for(int j=0;j<=K;j++) dis[i][j]=INF;
    dis[sta][K]=0;
    heap.push((em){sta,K,0});
    for(;!heap.empty();){
        em now=heap.top();
        int id=now.id;
        int fr=now.fr;
        heap.pop();
        if(now.val!=dis[id][fr]) continue;//判断是否被废弃 
        for(int i=last[id];i!=-1;i=next[i]){
            int to=edge[i].v;
            if(dis[to][fr]>dis[id][fr]+edge[i].w){//更新不用免费劵的情况 
                dis[to][fr]=dis[id][fr]+edge[i].w;
                heap.push((em){to,fr,dis[to][fr]});
            }
            if(fr-1>=0&&dis[to][fr-1]>dis[id][fr]){//更新使用免费劵的情况 
                dis[to][fr-1]=dis[id][fr];
                heap.push((em){to,fr-1,dis[to][fr-1]});
            }
        }
    }
}
int main(){
    int cirno;
    cin>>n>>cirno>>K;
    cin>>Start>>End;
    Start++;End++;//把编号弄成正整数方便处理 
    for(int i=1;i<=cirno;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        u++;v++;//同上 
        addedge(u,v,w);
        addedge(v,u,w);
    }
    starinit();
    dij(Start);
    int ans=INF;
    for(int i=0;i<=K;i++){//有可能没用完劵 
        ans=min(ans,dis[End][i]);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：xixiup (赞：2)

这道题就是一个经典的分层图题，如果我们将一个图复制k次，成为一个k层的图。

如果从点i到点j有一条路径，那么从第x层的i节点到第x+1的j节点和第x层的j节点到第x+1层的i节点都各有一条长度为0的边，但如果已尽到了第k层将不能继续往下搜 ~~想吃霸王餐吧QwQ~~

如一个这样的图：

![](https://cdn.luogu.com.cn/upload/pic/45961.png)

在k=1时，把它变成：

![](https://cdn.luogu.com.cn/upload/pic/45962.png)
就可以了

```cpp

#include<bits/stdc++.h>
using namespace std;//万能头不说(话说不会的可以做这道题吗?)
const int maxn=10010,maxk=20;//开大点，小心RE
const int point=maxn*maxk;
struct po{//每一个点
	int z,x;
	bool operator<(const po&a)const{//重置'<'
		return a.x<x;
	}
}o,re;
int di[point],i,j,n,m,k,fr,to,x,y,zz;
bool vi[point];
priority_queue<po>q;//自动排序堆.
vector<int>a[point],b[point];//相邻的点与边权
void add_edge(int u,int v,int c){//加入一条边
	a[u].push_back(v),b[u].push_back(c);
}
void add(int t,int y,int kkk){
	add_edge(t,y,kkk);
    add_edge(y,t,kkk);
    for(int j=1;j<=k;++j){
        add_edge(t+(j-1)*n,y+j*n,0);//权为0的点
        add_edge(y+(j-1)*n,t+j*n,0);
        add_edge(t+j*n,y+j*n,kkk);//构建每层的图
        add_edge(y+j*n,t+j*n,kkk);
    }
	return;
} 
int main()
{
	cin>>n>>m>>k;
	k++;
	cin>>fr>>to;
	fr++,to++;
	for(i=1;i<=n*k;i++){
		di[i]=100000000;
	}
	for(i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&zz);
		x++,y++;
		add(x,y,zz);
	}
	di[fr]=0;
	o.z=fr,o.x=0;
	q.push(o);
	while(!q.empty()){
		o=q.top();
		q.pop();
		if(vi[o.z]==0){
			vi[o.z]=1;
			int l=a[o.z].size();
			for(i=0;i<l;i++){
				if(di[o.z]+b[o.z][i]<di[a[o.z][i]]){
					di[a[o.z][i]]=di[o.z]+b[o.z][i];
					re.z=a[o.z][i],re.x=di[a[o.z][i]];
					q.push(re);
				}
			}
		}
	}
	int MAX=100000000;
	for(i=to;i<=n*k;i+=n){
		MAX=min(MAX,di[i]);
	}
	cout<<MAX;
	return 0;
}

```

---

## 作者：EarthGiao (赞：1)

## 【思路】
分层图 + dijkstra     
分层图板子题        
如果想了解分层图请看这里
[了解分层图](https://www.cnblogs.com/acioi/p/11716483.html)      

### 【题目大意】
从1到n跑    
其中可以让k条路的耗时变为原来的一半     
求最小耗时    
  
### 【题目分析】
如果你不是第一次做分层图的话   
那看到这k条路减半    
一定会想到一个很有意思的算法分层图   
分层图就是专门用来解决这种k条路减半的问题的   
不过需要开很大的空间    
开数组的时候要好好斟酌一下  
不然很容易出问题     

### 【核心思路】
正常建一遍图    
然后赋值k遍    
第i张图作为用了i次免费的机会      
所以两张图之间是免费机会用的路    
那就需要赋值为0     
这样直接跑dijkstra就完全没有问题    
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct point
{
	int w,x;
	bool operator < (const point & xx)const
	{
		return xx.w < w;
	}
};
const int Max = 4000000;
struct node
{
	int y,ne,z;
}a[Max];
int sum = 0,head[Max];
int d[Max];

void add(int x,int y,int z)
{
	a[++ sum].y = y;
	a[sum].ne = head[x];
	a[sum].z = z;
	head[x] = sum;
}
bool use[Max];
int s,t;
priority_queue<point>q;
void dj()
{
	memset(d,0x3f,sizeof(d));
	d[s] = 0;
	q.push((point){0,s});
	while(!q.empty())
	{
		point qwq = q.top();
		q.pop();
		int x = qwq.x,w = qwq.w;
		if(use[x] == true)
			continue;
		else
			use[x] = true;
		for(register int i = head[x];i != 0;i = a[i].ne)
		{
			int awa = a[i].y;
			if(d[awa] > d[x] + a[i].z)
			{
				d[awa] = d[x] + a[i].z;
				if(use[awa] == false)
					q.push((point){d[awa],awa});
			}
		}
	}
}
int main()
{
	int n,m,k;
	cin >> n >> m >> k;
	cin >> s >> t;
	int x,y,z;
	for(register int i = 1;i <= m;++ i)
	{
		cin >> x >> y >> z;
		add(x,y,z),add(y,x,z);
		for(register int j = 1;j <= k;++ j)
		{
			add(j * n + x,j * n + y,z);
			add(j * n + y,j * n + x,z);
			add((j - 1) * n + x,j * n + y,0);
			add((j - 1) * n + y,j * n + x,0);
		}
	}
	dj();
	int M = 0x7fffffff;
	for(register int i = 0;i <= k;++ i)
		M = min(M,d[i * n + t]);
	cout << M << endl;
	return 0;
}
```

---

## 作者：xryjr233 (赞：1)

建一个分层图,第$i$层的第$j$个节点表示走到$j$号节点,用了$i$个优惠的最短路,我们设为$[i,j]$。

然后对于原图的一条权值为$w$的双向边$(u,v)$,对于任意的$0\le x\le k$,在$[x,u]$和$[x,v]$之间建立权值为$w$的双向边,对于任意的$0\le x<k$,在$[x,u]$和$[x+1,v]$之间以及$[x,v]$和$[x+1,u]$之间分别建立单向边。

从$[0,s]$开始跑单源最短路,答案为$0\le x\le k$的$[x,t]$到$[0,s]$的最短路的最小值。

code:

```cpp
#include<bits/stdc++.h>
#define val(u,id) (n*(u)+id)
using namespace std;
struct node{
	int d,mn;
	bool operator<(node y)const{
		return mn==y.mn?d>y.d:mn>y.mn;
	}
}td;
struct edge{
	int t,v,nxt;
}e[2200010];
const int INF=1e9;
int n,m,k,s,t,u,v,w,be[110010],cnt,mn[110010],vis[110010],ans=INF;
priority_queue<node>pq;
void add(int x,int y,int val){
	e[++cnt].t=y,e[cnt].v=val,e[cnt].nxt=be[x],be[x]=cnt;
}
void Dijkstra(){
	for(int i=0;i<=k;++i)for(int j=0;j<n;++j)mn[val(i,j)]=INF;
	mn[s]=0,pq.push((node){s,0});
	while(!pq.empty()){
		while(!pq.empty()&&vis[(td=pq.top(),td.d)])pq.pop();
		if(pq.empty())return;
		pq.pop(),vis[td.d]=1;
		for(int i=be[td.d];i;i=e[i].nxt)(mn[e[i].t]>mn[td.d]+e[i].v)?mn[e[i].t]=mn[td.d]+e[i].v,pq.push((node){e[i].t,mn[e[i].t]}),0:0;
	}
}
int main(){
	scanf("%d%d%d%d%d",&n,&m,&k,&s,&t);
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&u,&v,&w);
		for(int j=0;j<k;++j)add(val(j,u),val(j,v),w),add(val(j,v),val(j,u),w),add(val(j,u),val(j+1,v),0),add(val(j,v),val(j+1,u),0);
		add(val(k,u),val(k,v),w),add(val(k,v),val(k,u),w);
	}
	Dijkstra();
	for(int i=0;i<=k;++i)ans=min(ans,mn[val(i,t)]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：G_A_TS (赞：1)

有兴趣的童鞋可以去刷[这道题](https://www.cnblogs.com/wzzorz/articles/10994078.html)  
[原题link](https://www.luogu.org/problemnew/show/P4568)  
Dijkstra+dp(?)  
附样例图片，使用EternalAlexander的[OI painter](https://pan.baidu.com/s/1bt5zHPvulT7s8Qjg45LfkA)  
![样例](https://i.loli.net/2019/06/13/5d023f6c1a91d96703.png)  
(我是先多建边)  
dijkstra，删掉vis数组，dp即可  
dist[i][j]为点i用掉j次免费机会时到源点的最短路  
剩下的很好理解?~~(雾)~~

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,K;
int ip1,ip2,ip3,st,en;
int dist[10010][11];
struct edge
{
	int to;
	int dis;
	int N;
};
struct node
{
	int dis;
	int pos,N;
	bool operator < (const node &x)const
	{
		return x.dis<dis;
	}
};
vector<edge>a[10010];
void Dijkstra(int x)
{
	priority_queue<node>q;
	for(int i=0;i<=1;i++)
	{
		node sta;
		sta.dis=0;
		sta.pos=x;
		sta.N=i;
		dist[x][i]=0;
		q.push(sta);
	}
	while(!q.empty())
	{
		node T=q.top();
		q.pop();
		int now=T.pos;
		for(int i=0;i<a[now].size();i++)
		{
			if(a[now][i].N+T.N>K)
			{
				continue;
			}
			if(dist[a[now][i].to][T.N+a[now][i].N]>dist[now][T.N]+a[now][i].dis)
			{
				dist[a[now][i].to][T.N+a[now][i].N]=dist[now][T.N]+a[now][i].dis;
				node tmp;
				tmp.dis=dist[a[now][i].to][T.N+a[now][i].N];
				tmp.pos=a[now][i].to;
				tmp.N=T.N+a[now][i].N;
				q.push(tmp);
			}
		}
	}
}
int main()
{
	cin>>n>>m>>K;
	cin>>st>>en;
	for(int i=1;i<=m;i++)
	{
		cin>>ip1>>ip2>>ip3;
		a[ip1].push_back((edge){ip2,ip3,0});
		a[ip2].push_back((edge){ip1,ip3,0});
		a[ip1].push_back((edge){ip2,0,1});
		a[ip2].push_back((edge){ip1,0,1});
	}
	for(int i=0;i<=10001;i++)
	{
		for(int j=0;j<=10;j++)
		{
			dist[i][j]=2147483647;
		}
	}
	Dijkstra(st);
	printf("%d",dist[en][K]);
}
```


---

## 作者：kfhkx (赞：0)

## p党的福利 

### 分层图板子合集（spfa+堆优化的dijkstra）

这题一看就是分层图的最短路问题

分层图最短路以我的理解就是将n个图合在一起跑最短路

那如何合图呢？
------------

- 其实就是先建k个图，每个图的主体是一样的（正常边权在每个图都能体现到）

- 然后将特殊边从第j-1个图向j个图连边就行了（1≤j≤k)
```pascal
//我这里采用的是链式前向星存的图
procedure link(x,y,z:longint);
begin
        inc(tot);
        ne[tot]:=he[x];
        he[x]:=tot;
        t[tot]:=y;
        w[tot]:=z;
end;
//这一步和平常的存图一样
//但是要注意数组要开2*k*m那么大
//然后是读入操作，这里就有文章可做了
for i:=1 to m do begin
	readln(x,y,z);
	link(x,y,z);//首先是正常的无向图存图
	link(y,x,z);
	for j:=1 to k do begin//这里就是分层图独有的存图方法
		link((j-1)*n+x,j*n+y,0);//从第j-1个图的x点向第j个图的y点连一条权值为0的边
		link((j-1)*n+y,j*n+x,0);
		link(x+j*n,y+j*n,z);
		link(y+j*n,x+j*n,z);//在第j个图中建立正常的边权
	end;
end;
```
建完图，然后就快乐地跑最短路就行了~

### P4568(裸dijkstra)pas 
TLE4个点 64分
```pascal
var
        n,m,k,s,e,i,j,head,tail,tot,v,minn,x,y,z:longint;
        ans:int64;
        he,ne,t,w,dis:array[0..4000000] of int64;
        p:array[0..4000000] of boolean;
function min(x,y:int64):int64;
begin
        if x<y then exit(x) else exit(y);
end;
procedure link(x,y,z:longint);
begin
        inc(tot);
        ne[tot]:=he[x];
        he[x]:=tot;
        t[tot]:=y;
        w[tot]:=z;
end;
begin
        readln(n,m,k);
        readln(s,e);
        for i:=1 to m do begin
                readln(x,y,z);
                link(x,y,z);
                link(y,x,z);
                for j:=1 to k do begin
                        link((j-1)*n+x,j*n+y,0);
                        link((j-1)*n+y,j*n+x,0);
                        link(x+j*n,y+j*n,z);
                        link(y+j*n,x+j*n,z);
                end;
        end;
        for i:=0 to n*(k+1) do dis[i]:=maxlongint*10000;
        dis[s]:=0;
        head:=s;
        while not p[head] do begin
                p[head]:=true;
                v:=he[head];
                while v>0 do begin
                        if (not (p[t[v]])) and (dis[t[v]]>dis[head]+w[v]) then
                         dis[t[v]]:=dis[head]+w[v];
                        v:=ne[v];
                end;
                minn:=maxlongint;
                for i:=0 to n*(1+k) do if (not p[i]) and (minn>dis[i]) then begin
                        minn:=dis[i];
                        head:=i;
                end;
        end;
        ans:=maxlongint*10000;
        for i:=0 to k do ans:=min(ans,dis[e+i*n]);
        writeln(ans);
end.
```
### P4568(堆+dijkstra).pas 
开o2 394ms 不开458ms
```pascal
var
        n,m,k,s,e,i,j,head,tot,v,x,y,z:longint;
        ans:int64;
        he,ne,t,w,dis,cj,num,heap:array[0..4000000] of int64;
function min(x,y:int64):int64;
begin
        if x<y then exit(x) else exit(y);
end;
function swap(var x,y:int64):int64;
var
        t:int64;
begin
        t:=x;
        x:=y;
        y:=t;
end;
procedure link(x,y,z:longint);
begin
        inc(tot);
        ne[tot]:=he[x];
        he[x]:=tot;
        t[tot]:=y;
        w[tot]:=z;
end;
procedure insert(a,x:longint);
var
        i:longint;
begin
        if cj[x]<>0 then begin
                i:=cj[x];
                heap[i]:=a;
        end else begin
                inc(heap[0]);
                i:=heap[0];
                heap[i]:=a;
                num[i]:=x;
                cj[x]:=i;
        end;
        while (i>>1>0) and (heap[i]<heap[i>>1]) do begin
                swap(cj[num[i]],cj[num[i>>1]]);
                swap(heap[i],heap[i>>1]);
                swap(num[i],num[i>>1]);
                i:=i>>1;
        end;
end;
procedure del;
var
        i,m:longint;
begin
        cj[num[1]]:=0;
        heap[1]:=heap[heap[0]];
        num[1]:=num[heap[0]];
        dec(heap[0]);
        i:=1;
        if (heap[i<<1]<heap[i<<1+1]) or (i=heap[0]) then m:=i<<1 else m:=i<<1+1;
        while (m<=heap[0]) and (heap[m]<heap[i]) do begin
                swap(cj[num[i]],cj[num[m]]);
                swap(heap[i],heap[m]);
                swap(num[i],num[m]);
                i:=m;
                if (heap[i<<1]<heap[i<<1+1]) or (i<<1=heap[0]) then m:=i<<1 else m:=i<<1+1;
        end;
end;
begin
        readln(n,m,k);
        readln(s,e);
        for i:=1 to m do begin
                readln(x,y,z);
                link(x,y,z);
                link(y,x,z);
                for j:=1 to k do begin
                        link((j-1)*n+x,j*n+y,0);
                        link((j-1)*n+y,j*n+x,0);
                        link(x+j*n,y+j*n,z);
                        link(y+j*n,x+j*n,z);
                end;
        end;
        for i:=0 to n*(k+1) do dis[i]:=maxlongint*10000;
        heap[0]:=1;
        num[1]:=s;
        dis[s]:=0;
        head:=s;
        while heap[0]<>0 do begin
                v:=he[head];
                while v>0 do begin
                        if dis[t[v]]>dis[head]+w[v] then begin
                                dis[t[v]]:=dis[head]+w[v];
                                insert(dis[t[v]],t[v]);
                        end;
                        v:=ne[v];
                end;
                del;
                head:=num[1];
        end;
        ans:=maxlongint*10000;
        for i:=0 to k do ans:=min(ans,dis[e+i*n]);
        writeln(ans);
end.
```
### P4568(spfa).pas
413ms
```pascal
var
        n,m,k,i,j,x,y,z,head,tail,v,o,s,e:longint;
        tot,ans,maxn,g:int64;
        ne,he,t,w,f:array[0..200000] of int64;
        dis:array[0..200000,0..21] of int64;
        p:array[0..200000] of boolean;
        q:array[0..8000000] of longint;
function min(x,y:int64):int64;
begin
        if x<y then exit(x) else exit(y);
end;
procedure link(x,y,z:longint);
begin
        inc(tot);
        ne[he[x]]:=tot;
        he[x]:=tot;
        t[tot]:=y;
        w[tot]:=z;
        if f[x]=0 then f[x]:=tot;
end;
procedure swap(x,y:longint);
begin
        g:=q[x];
        q[x]:=q[y];
        q[y]:=g
end;
begin
        maxn:=maxlongint*100;
        readln(n,m,k);
        readln(s,e);
        inc(s);
        inc(e);
        for i:=1 to m do begin
                readln(x,y,z);
                inc(x);
                inc(y);
                link(x,y,z);
                link(y,x,z);
        end;
        for i:=1 to n+1 do for j:=0 to k do dis[i,j]:=maxn;
        dis[s,0]:=0;
        head:=0;
        tail:=1;
        p[s]:=true;
        q[1]:=s;
        for i:=0 to k do begin
                while head<>tail do begin
                        inc(head);
                        o:=q[head];
                        v:=f[o];
                        while v<>0 do begin
                                if dis[o,i]+w[v]<dis[t[v],i] then begin
                                        dis[t[v],i]:=dis[o,i]+w[v];
                                        if not p[t[v]] then begin
                                                inc(tail);
                                                q[tail]:=t[v];
                                                if dis[t[v],i]<dis[q[head+1],i] then swap(head+1,tail);
                                                p[t[v]]:=true;
                                        end;
                                end;
                                v:=ne[v];
                        end;
                        p[o]:=false;
                end;
                for j:=1 to n do begin
                        v:=f[j];
                        while v<>0 do begin
                                dis[t[v],i+1]:=min(dis[t[v],i+1],dis[j,i]);
                                v:=ne[v];
                        end;
                end;
                head:=0;
                tail:=0;
                for j:=1 to n do if dis[j,i+1]<>maxn then begin
                        inc(tail);
                        q[tail]:=j;
                        p[j]:=true;
                end else p[j]:=false;
        end;
        ans:=maxn;
        for i:=0 to k do ans:=min(ans,dis[e,i]);
        writeln(ans);
end.
```

---


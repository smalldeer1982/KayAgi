# 抓住czx

## 题目背景

蒟蒻 lty 出了一道题，但是由于太弱了，所以希望喜欢鸽子的 czx 来帮他写一个 std 。由于 czx 又放鸽子去了，所以没有写 std。蒟蒻 lty 觉得受到了学长的鄙视，所以决定去 czx 放鸽子的地方找他。

## 题目描述

 czx 放鸽子的地方是一个公园，公园珂以看作是由 $n$ 个点 $m$ 条边组成的无向图(保证无自环）， lty 将从公园的入口（ $b$ 号节点）进去寻找 czx ， czx 刚开始的位置为 $e$ ，而 czx 会在 $a_i$ 个单位时间时变化位置到第 $x$ 个节点去，在此之前 lty 已经知道了 czx 的具体位置和接下来他位置的变化方案，蒟蒻 lty 现在想知道他至少需要花多少时间找到 czx 。

UPD:

保证图联通， czx 最后会待在一个地方不动

## 说明/提示

**样例解释：**

在开始的时候就直接走到 $2$ 号节点，然后等到 czx过来。总花费时间 $9$ 个单位时间。

对于 30% 的数据，$n\le 100,m\le 1000,T\le 100$

对于另外 30% 的数据，$T=0$

对于 100% 的数据，$n \le 10^5,m \le 5\times10^5,T \le 10^5$

数据保证所有时间在 int 范围内

注意：在任意一个 czx 开始移动的时间点，都是 czx 先瞬移，然后 lty 再行走，也就是说， lty 不能在 czx 瞬移的时候到他瞬移前的点抓住他，但是 lty 可以在他瞬移到的点等着抓他。

## 样例 #1

### 输入

```
6 9 1 6
1 2 1
1 3 3
1 4 4
2 3 2
3 6 6
4 5 6
2 5 9
3 5 7
5 6 2
3
10 3
8 5
9 2```

### 输出

```
9```

# 题解

## 作者：Eleven谦 (赞：5)

# 抓住czx

[洛谷P4880  抓住czx](https://www.luogu.com.cn/problem/P4880)

#### 前言（~~吐槽~~ 珂忽略）

这道题说来都心酸，在第一次得到$T=0$的$30pt$s后，开始肝正解

但是在判断的时候忽略了一种情况（我并没有意识到），一直卡在了$90pts$，甚至还发了贴去求助（然而并没有人回我QAQ）

后来在[同桌的帮助下](https://www.cnblogs.com/Poetic-Rain/?tdsourcetag=s_pctim_aiomsg)，意识到了缺少一种情况，然后自己想出了这种情况怎么处理，但是.....因为手贱多写了一个“$=$”，又在#1和#2反复横跳（我真惨~~菜~~）

最后~~耐心地~~又敲了一遍，才艰难的A掉了这道并不难的蓝题

------------
#### 解题思路

好了，吐槽完了，开始正题吧

- $T=0$的特殊情况

只要会求最短路的，应该都没问题吧，$30pts$给得死死的

多说一点：$T=0$意味着$czx$不会瞬移，则$czx$一直在$e$这个位置，那抓住他的最短时间自然就是从$b$到$e$的最短路长度咯

- 完整正解

在除$T=0$的特殊情况外，也会存在一种情况不用考虑瞬移：**我们在$czx$第一次瞬移之前就抓住了他**，即从$b$到$e$的最短路长度$＜$第一次瞬移的时间

注意一下，这里的“第一次”并不是指输入的第一组瞬移数据，而是排序后的第一次（即我们**将所有瞬移按照时间节点从早到晚排序**后的第一次瞬移）

之后的情况就都是需要考虑瞬移的了（我们**用$dis[i]$表示从$1$到$i$的最短时间**）

设$czx$第$i$次瞬移到的点为$pi$、时间为$ti$

- **若$dis[pi]≤ti$，说明我们在第$i$次瞬移后抓住了他**

这里可能大家会疑惑：为什么是“$≤$”而不是“$＜$”？题目中不是说在一个瞬移时间点，总是$czx$先瞬移走，然后我们才到，这样是抓不住的啊

题目中确实说明了这一点，但是这个规则并不影响我们的这个判断，而是影响我们下面的另一个判断（下面会着重点出）

然后，我们再来解释一下这个判断的原理（也能解释上面的疑惑）：

1. 若我们比$czx$**先到达**$pi$这个点（对应dis[pi]＜ti），那我们就在$pi$这个点**等着抓**他就好了（守株待兔嘛）

2. 若我们和$czx$**同时到达**$pi$这个点（对应dis[pi]＝ti），那我们就**正好抓住**他

- **若$dis[pi]>ti$,说明我们无法在$pi$这个点抓住$czx$，但是也需要加以讨论**

（这就是我一直忽略的情况，下面给出图来帮助理解）

![](https://img2020.cnblogs.com/blog/2055990/202007/2055990-20200702124604433-855615558.png)

在第$2$时刻，$czx$已经到达点$3$，而我们还在从$1$到$3$的路上，那显然是$dis[pi]>ti$的情况

但是在第$3$时刻我们到达了$czx$所在的点$3$，而此时$czx$还没有进行下一次的瞬移，所以我们抓住了他

面对上面这种情况，我们单单因为$dis[pi]>ti$的话，就会错失掉在第$3$时刻抓住$czx$是机会！所以我们还需要**加个判断防止误判：$dis[a[i].p]<a[i+1].t$**

还是来解释一下原理：**如果我们到达$pi$这个点的时间在$czx$下一次瞬移之前，那我们依旧能够抓住他，所以这种情况答案就是我们到达$pi$的时间**

再着重讲一下为什么这里就是“$<$”而不是“$≤$”，正如上面的疑惑，题目中说定了在一个瞬移的时间点，总是$czx$先瞬移然后我们再到达。所以当我们到达$pi$时，$czx$已经瞬移走了，故我们抓不住他（请大家注意区分qwq）

------------
#### 代码Code

```cpp
#include <bits/stdc++.h>
using namespace std;
priority_queue<pair<int,int> > q;
int n,m,t,b,E,x,y,z;
int tot,dis[1000010],vis[1000010],head[1000010];

struct node {
	int to,net,val;
} e[1000010];

struct nodes {
	int t,p;
} a[1000010];

inline void add(int u,int v,int w) {
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].net=head[u];
	head[u]=tot;
}

inline void dijkstra(int s) {  //Dijkstra求最短路板子 
	for(register int i=1;i<=n;i++) {
		vis[i]=0;
		dis[i]=2005020600;
	}
	dis[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty()) {
		int x=q.top().second;
		q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(register int i=head[x];i;i=e[i].net) {
			int v=e[i].to;
			if(dis[v]>dis[x]+e[i].val) {
				dis[v]=dis[x]+e[i].val;
				q.push(make_pair(-dis[v],v));
			}
		}
	}
}

inline bool cmp(nodes x,nodes y) {
	return x.t<y.t;
}

int main() {
	scanf("%d%d%d%d",&n,&m,&b,&E);
	for(register int i=1;i<=m;i++) {
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	scanf("%d",&t);
	for(register int i=1;i<=t;i++) {
		scanf("%d%d",&a[i].t,&a[i].p);
	}
	sort(a+1,a+1+t,cmp);   //将所有瞬移按照时间点从早到晚排序 
	dijkstra(b);
	if(dis[E]<a[1].t||t==0) {  //不用管瞬移的两种情况 
		printf("%d",dis[E]);
		return 0;
	}
	for(register int i=1;i<=t;i++) {  //枚举瞬移找答案 
		if(dis[a[i].p]<=a[i].t) {  //守株待兔或正好抓住的情况 
			printf("%d",a[i].t);
			return 0;
		}
		else {
			if(dis[a[i].p]<a[i+1].t) {  //在下一次瞬移前抓住的情况 
				printf("%d",dis[a[i].p]);
				return 0;
			}
		}
	}
	return 0;
}
```

------------

最后，如果有任何地方不懂或不对的，欢迎大家在评论区留言，我会及时回复，谢谢大家啊qwq

------------



---

## 作者：Wolfycz (赞：4)

关于$SPFA$，它还活着

这题没卡$SPFA$~~（本来我想造数据卡的，被出题人拒绝了）~~

所以就是一个单源最短路加一下简单判断即可，没啥坑，TLE可能是自己写挂了啥的

``` cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')    f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<1)+(x<<3)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x>=10)	print(x/10);
	putchar(x%10+'0');
}
const int N=1e5,M=1e6;
int pre[(M<<1)+10],now[N+10],child[(M<<1)+10],val[(M<<1)+10];
int h[N+10],deep[N+10];
bool vis[N+10];
int n,m,S,tot;
struct S1{
	int x,T;
	void insert(int _x,int _T){x=_x,T=_T;}
	bool operator <(const S1 &a)const{return T<a.T;}
}A[N+10];
void join(int x,int y,int z){pre[++tot]=now[x],now[x]=tot,child[tot]=y,val[tot]=z;}
void SPFA(int x){
	int head=0,tail=1;
	memset(deep,63,sizeof(deep));
	h[1]=x,vis[x]=1,deep[x]=0;
	while (head!=tail){
		if (++head>N)	head=1;
		int Now=h[head];
		for (int p=now[Now],son=child[p];p;p=pre[p],son=child[p]){
			if (deep[son]>deep[Now]+val[p]){
				deep[son]=deep[Now]+val[p];
				if (!vis[son]){
					if (++tail>N)	tail=1;
					vis[h[tail]=son]=1;
				}
			}
		}
		vis[Now]=0;
	}
}
int main(){
	n=read(),m=read(),S=read(),A[0].insert(read(),0);
	for (int i=1;i<=m;i++){
		int x=read(),y=read(),z=read();
		join(x,y,z),join(y,x,z);
	}
	SPFA(S);
	int T=read();
	for (int i=1;i<=T;i++){
		int x=read(),y=read();
		A[i].insert(y,x);
	}
	A[++T].insert(0,inf);//最后防止不出答案
	sort(A,A+1+T);
	for (int i=0;i<=T;i++){
		if (deep[A[i].x]<A[i+1].T){
			printf("%d\n",max(deep[A[i].x],A[i].T));
			break;
		}
	}
	return 0;
}
```

---

## 作者：Tiffany_Tendering (赞：3)

   比赛的时候打的  其实也就是在原来spfa的基础上加一点小操作就好了
   czx真的太皮了 他老师在跑 所以我们可以？？？ 以不变应万变!
   
   1 从b点跑一遍spfa 预处理出起点到每一个点的距离  边权为通过这条边的时间 
   
   2 对czx变化的时间###### 从小到大排序 从时间最小的地点开始判断 
     
     并记录一下在某一个位置停留的起始时间和终止时间
     起始时间就是我们输入的  终止时间就是到下一个地点的时间-1
     
     注意终止时间要在排序之后判断
     
     然后对czx所在的地点枚举排序 
     
     如果到达这个点的最小时间 
     
     也就是最短路小于czx在这个点的终止时间 
     
     那么我们就可以直接输出
     ##### 注意 我们输出的是max（到这个点的最短路， czx在这个点的初始时间）
     
     因为如果最短路 < 初始时间 那么就是czx在这个点的时候 我们也到了这个点
     反之 就是我们先到了这个点等着czx


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn = 100005;
const int maxm = 500005;
int n,m,st,en,top,head[maxn],tttt,dis[maxn];
bool vis[maxn] ;
struct edge {
	int to,value,next ;
}e[maxm << 1];
struct nodee{int timst,timen,node ;}t[maxn];  //记录czx地点的结果体 timst为起始时间 timen为终止时间 
inline int read() {
	int x = 0; bool flag = 1;
	char k = getchar() ;
	while((k < '0' || k > '9') && k != '-') k = getchar() ;
	while(k == '-'){flag = false ; k = getchar() ;}
	while(k >= '0' && k <= '9'){x = x * 10 + k - '0' ;  k = getchar() ;}
	return flag ? x : -x ;
}
void add_edge(int u,int v,int w) {
	e[++top].next = head[u] ;
	e[top].to = v;
	e[top].value = w;
	head[u] = top ;
}
void spfa(int s) {
	queue< int >q ;
	for(int i = 1;i <= n ;++i) dis[i] = 1e9,vis[i] = 0 ;
	dis[s] = 0;
	q.push(s) ; vis[s] = 1;
	while(!q.empty()) {
		int u = q.front() ;
		q.pop() ;
		vis[u] = 0;
		for(int i = head[u]; i ;i = e[i].next) 
			if(dis[e[i].to] > dis[u] + e[i].value) {
				dis[e[i].to] = dis[u] + e[i].value;
				if(!vis[e[i].to]) {q.push(e[i].to) ; vis[e[i].to] = 1;}
			}
	}
}
bool cmp(nodee a,nodee b) { return a.timst < b.timst ;}
int main() {
	scanf("%d%d%d%d",&n,&m,&st,&en) ;
	t[1].timst = 1; t[1].node = en;
	for(int i = 1;i <= m ;++i) {
		int u,v,z; 
		u = read() ; v = read() ; z = read() ;
		add_edge(u,v,z) ; add_edge(v,u,z) ; //加边 
	}
	scanf("%d",&tttt) ; tttt++;
	spfa(st) ;  //预处理最短路 
	for(int i = 2;i <= tttt;++i) {
		int timee,pla; timee = read() ; pla = read() ;
		t[i].timst = timee ;  //这点的起始时间输入的时间 
		t[i].node = pla ;
	}
	sort(t + 1,t + tttt + 1, cmp) ;
	for(int i = 2;i <= tttt; ++i) 
		t[i - 1].timen = t[i].timst - 1; //更新终止时间 
	t[tttt].timen = 1e9; //czx在最后一个点不动 所以终止时间无限大 
	for(int i = 1;i <= tttt ;++i) 
		if(dis[t[i].node] <= t[i].timen) {printf("%d\n",max(dis[t[i].node], t[i].timst) ) ;return 0;} //取max输入 直接return即可 
	printf("%d\n",max(dis[t[tttt].node] , t[tttt].timst)) ;  //如果在前几个点到不了的话 就直接到最后一个点了 不过这一句可能没什么用？？？ 
	return 0;
}
```

---

## 作者：Refined_heart (赞：2)

笔者（蒟蒻）近来开了看最短路算法，写此题解以记之。

题目大意：有$n$个点，$m$条边的图，给定起点以及终点变化的时间以及位置，求哪一时刻到达终点的路程最短。

首先考虑起点，我们发现，起点是不动的，终点无论如何也总会在这张图上变化，于是我们可以先跑一遍$dijkstra$求出起点到所有点的最短路$(time)$，有了时间，方便我们对于时间变化做处理。

考虑变化时间。我们发现，如果靠前的时间已经可以到达，那么它一定是$answer$，因为再变化的话时间一定靠后。于是，我们$sort$一遍时间，以时间升序排序。对于每一个时刻的点，我们暴力枚举，并且暴力$check$它能否到达即可。注意题目的初始化，刚开始的起点是$e$，最后会停留在一个点不动。而且，$czx$的变化总是要提前（即如果它变化的同时我们到达了，则它先变化）。

所以枚举比较的时候不能取等号。

$Code:$
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
#define inf 2147483647
#define int long long
int n,m,b,s;
struct edge{
	int to,next,dis;
}e[1100000];
int dis[1100000],vis[1100000];
int head[1100000],tot,t;
struct cg{
	int time,x;
}c[1100000];
struct node{
	int dis,pos;
	bool operator<(const node&x)const{
		return x.dis<dis;
	}
};
priority_queue<node>q;
inline void add(int x,int y,int w){
	e[++tot].to=y;
	e[tot].next=head[x];
	e[tot].dis=w;
	head[x]=tot;
}
inline bool cmp(cg a,cg b){
	return a.time<b.time;
}
void dijkstra(){
	dis[b]=0;
	q.push((node){0,b});
	while(!q.empty()){
		node tmp=q.top();
		q.pop();
		int x=tmp.pos;
		if(vis[x])continue;
		vis[x]=1;
		for(int i=head[x];i;i=e[i].next){
			int y=e[i].to;
			if(dis[y]>dis[x]+e[i].dis){
				dis[y]=dis[x]+e[i].dis;
				if(!vis[y])q.push((node){dis[y],y});
			}
		}
	}
}
signed main(){
	scanf("%lld%lld%lld%lld",&n,&m,&b,&s);
	for(int i=1;i<=n;++i)dis[i]=inf;
	for(int i=1;i<=m;++i){
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}scanf("%lld",&t);
	for(int i=1;i<=t;++i)scanf("%lld%lld",&c[i].time,&c[i].x);
	sort(c+1,c+t+1,cmp);//离线排序处理 
	dijkstra();//dijkstra
	c[0].x=s;//初始化 
	for(int i=1;i<=t;++i)
		if(dis[c[i].x]<c[i+1].time){//判断能否到达 
			printf("%lld\n",max(dis[c[i].x],c[i].time));//能就输出较大的那个 
			return 0;
		}
	printf("%lld\n",max(dis[c[t].x],c[t].time));//不能则一定能在最后抓住 
	return 0;
}
```
$Update:$

1.笔者因为太懒用了宏定义代替$int$并且用了$signed$ $main$,其实正常写就好

2.做这题的原因之一是因为笔者一同学也叫$czx$……

3.最后强行安利一波我的博客：[请各位指教](https://www.cnblogs.com/h-lka/)

---

## 作者：szbszb (赞：2)

### 本题是一个较为复杂的最短路算法

首先吐槽一下描述有误，这道题有自环~~虽然并无影响~~

本题相当于单源多目标最短路，算法主体如下：

1、跑一遍最短路算法，算出源点到其他点的距离；

2、对czx的位置进行分析处理

对于最短路，我们可以用迪杰斯特拉或SPFA，不会的话戳[这里](https://www.luogu.org/problemnew/show/P4779)

而对于位置分析，首先想的是对czx的时间定位（即在哪段时间内在哪点），想到的是用快排：
```cpp
void qsort(int l,int r)
{
	int mid=ll[(l+r)/2],i=l,j=r;
	while (i<=j)
	{
		while (ll[i]<mid) i++;
		while (ll[j]>mid) j--;
		if (i<=j)
		{
			swap(ll[i],ll[j]);
            swap(dd[i],dd[j]);
			i++;
			j--;
		}
	}
	if (j>l) qsort(l,j);
	if (i<r) qsort(i,r);
}
```
这样就能让时间有序，其中ll数组记录时间，dd数组记录在哪个点。
（之所以双写是因为有l记录左边界，有d来做最短路）

如果嫌烦~~或不会~~可以用stl模板库，即：
```cpp
struct ss{
	long long dd,ll;//结构体，其中ll，dd如上
}w[100001];
bool cjj(ss a,ss b)
{
	return a.ll<b.ll;//判断大小（不要问我为什么叫cjj）
}
int main()
{
    ……
	sort(w+1,w+t+1,cjj);//排序
	……
}
```
综上，代码就出来了：
```
#include<bits/stdc++.h>
using namespace std;
struct ss{
	long long dd,ll;
}w[100001];
bool cjj(ss a,ss b)
{
	return a.ll<b.ll;
}
priority_queue<pair<long long,long long> >q;
long long t,e,b1,n,m,s,i,cnt,x,y,z,he[1000001],ne[2000001],l[2000001],to[2000001],d[1000001];
bool b[1000001];
int main()
{
	scanf("%lld%lld%lld%lld",&n,&m,&b1,&e);
	for (i=1;i<=m;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&z);//邻接表
		cnt++;
		ne[cnt]=he[x];
		to[cnt]=y;
		l[cnt]=z;
		he[x]=cnt;
		cnt++;
		ne[cnt]=he[y];
		to[cnt]=x;
		l[cnt]=z;
		he[y]=cnt;
	}
	for (i=1;i<=n;i++) d[i]=1e9;
		d[b1]=0;
	q.push(make_pair(0,b1));
	while (q.size())
	{
		x=q.top().second;
		q.pop();
		if (b[x]) continue;
		b[x]=true;
		for (i=he[x];i!=0 ;i=ne[i])
			if (d[to[i]]>d[x]+l[i])
			{
				d[to[i]]=d[x]+l[i];
				q.push(make_pair(-d[to[i]],to[i]));//迪杰斯特拉
			}
	}
	w[0].dd=e;
	w[0].ll=0;//因为刚开始也算一条数据
	scanf("%lld",&t);
	for (i=1;i<=t;i++)
		scanf("%lld%lld",&w[i].ll,&w[i].dd);
	sort(w+1,w+t+1,cjj);
	for (i=0;i<t;i++)
		if (d[w[i].dd]<w[i+1].ll)//注意是小于
		{
			printf("%lld",max(d[w[i].dd],w[i].ll));//划重点，因为可以先到然后守株待兔
			return 0;
		}
	printf("%lld",max(d[w[t].dd],w[t].ll));
	return 0;
}
```
在最后判断时，我只用了“d[w[i].dd]<w[i+1].ll”因为假如它在之前的话也没关系，有输出时的判断，而若有更小，由于已按时间排完序，它肯定在之前结束了，也到不了这儿

---

## 作者：Acestar (赞：1)

思路还是不难的。

就是跑出来 $lty$ 从起点到每个点的最短路，把 $czx$ 到每个点的时间从小到大排序，然后把 $lty$ 到每个点的时间与 $czx$ 到下一个点的时间判断一下，如果 $<$ **注意是小于**，也就是说 $lty$ 先到，直接输出较大的时间。

最后如果没有找到答案，直接输出 $lty$ 和 $czx$ 到最后一个点的较大时间。


```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<map>
#include<algorithm>
#define N 100010
#define int long long

using namespace std;

typedef pair<int,int> P;
int n,m,s,e,T;
struct node
{
	int to,cost;
	node(int _to,int _cost)
	{
		to=_to,cost=_cost;
	}
};
struct path
{
	int t,x;	//czx在t时间到x 
};
vector<node>G[N];
int dis[N];
priority_queue <P,vector<P>,greater<P> > que;
path a[N];

int read()	//快读 
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x;
}

void dijkstra(int s)	//dijkstra堆优化 
{
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	que.push(P(0,s));
	while(!que.empty())
	{
		P p=que.top();
		que.pop();
		int u=p.second;
		if(p.first>dis[u]) continue;
		for(int i=0; i<G[u].size(); i++)
		{
			int v=G[u][i].to,w=G[u][i].cost;
			if(dis[u]+w<dis[v])
			{
				dis[v]=dis[u]+w;
				que.push(P(dis[v],v));
			}
		}
	}
	return;
}

bool cmp(path x,path y)
{
	return x.t<y.t;
}

signed main()
{
	n=read(),m=read(),s=read(),e=read();
	for(int i=1; i<=m; i++)
	{
		int x=read(),y=read(),z=read();
		G[x].push_back(node(y,z));
		G[y].push_back(node(x,z));
	}
	dijkstra(s);
	T=read(); 
	for(int i=1; i<=T; i++)
		a[i].t=read(),a[i].x=read();
	sort(a+1,a+1+T,cmp);	//按时间从小到大排序 
	a[++T]=(path){0,e};	//注意这里要把起点加进去 
	for(int i=1; i<=T; i++)
	{
		if(dis[a[i].x]<a[i+1].t)
		{
			printf("%lld\n",max(dis[a[i].x],a[i].t));	//输出后到的人的时间 
			return 0;
		}
	}
	printf("%lld\n",max(dis[a[T].x],a[T].t));
	return 0;
}
```


~~话说我们学校好像有一个叫 [$lty$](https://www.luogu.com.cn/user/13352) 的学长~~

---

## 作者：Forward_Star (赞：1)

其实就是个单源最短路问题，先敲一个堆优化$dijkstra$或者$spfa$，然后离线处理所有瞬移的时刻，将它们按瞬移时刻进行排序，排序后位置变化是依次进行的；假设当前$czx$经$i$次瞬移后到达点$a[i].x$，且下一次瞬移时刻为$a[i+1].t$，那么若$lty$最短到达时间$dist[a[i].x]<a[i+1].t$（不能取等号，因$czx$总是优先瞬移），则$lty$可以在$a[i].x$抓到$czx$；由于排序后瞬移时刻是递增的，故即使后面的瞬移地点也可以满足条件使$lty$抓到$czx$，也必定时间更长（即使提前到也要等$czx$），故直接输出即可。

另外，特判一下在最后一个地点抓到$czx$的情况。

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
    struct forward_star
    {
        int next,to;
        long long w;
    };
    struct newdata
    {
        long long t;
        int x;
    };
    int n,m,b,e,cnt,tot,t;
    forward_star edge[1000001];
    int head[100001];
    int heap[100001];
    long long dist[100001];
    newdata a[100001];
void add(int u,int v,long long w)
{
    cnt++;
    edge[cnt].to=v;
    edge[cnt].w=w;
    edge[cnt].next=head[u];
    head[u]=cnt;
}
void adjust_up(int now)
{
    while (now>1&&dist[heap[now/2]]>dist[heap[now]])
    {
        swap(heap[now],heap[now/2]);
        now/=2;
    }
}
void adjust_down(int now)
{
    if (now*2+1<=tot)
    {
        int k;
        if (dist[heap[now*2]]<dist[heap[now*2+1]]) k=now*2; else k=now*2+1;
        if (dist[heap[now]]>dist[heap[k]])
        {
            swap(heap[now],heap[k]);
            adjust_down(k);
        } else return;
    }
    else if (now*2<=tot)
    {
        if (dist[heap[now]]>dist[heap[now*2]])
        {
            swap(heap[now],heap[now*2]);
            adjust_down(now*2);
        } else return;
    }
    return;
}
void addheap(int now)
{
    heap[++tot]=now;
    adjust_up(tot);
}
void remove()
{
    heap[1]=heap[tot];
    tot--;
    adjust_down(1);
}
void solve() //堆优化+dijkstra过程
{
    memset(dist,0x7f7f,sizeof(dist));
    dist[b]=0;
    tot=0;
    addheap(b);
    while (tot>0)
    {
        int now=heap[1];
        int i=head[now];
        remove();
        while (i!=0)
        {
            if (dist[now]+edge[i].w<dist[edge[i].to])
            {
                dist[edge[i].to]=dist[now]+edge[i].w;
                addheap(edge[i].to);
            }
            i=edge[i].next;
        }
    }
}
bool cmp(newdata i,newdata j)
{
    return i.t<j.t;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&b,&e);
    for (int i=1;i<=m;i++)
    {
        int u,v;
        long long w;
        scanf("%d%d%lld",&u,&v,&w);
        add(u,v,w);
        add(v,u,w);
    }
    scanf("%d",&t);
    int now=e;
    solve(); //做一遍最短路
    for (int i=1;i<=t;i++)
        scanf("%lld%d",&a[i].t,&a[i].x);
    sort(a+1,a+t+1,cmp); //离线处理，排序时间
    a[0].x=e;
    for (int i=0;i<t;i++)
    	if (dist[a[i].x]<a[i+1].t)
    	{
    		printf("%lld",max(dist[a[i].x],a[i].t));
    		return 0;
    	}
    printf("%lld",max(dist[a[t].x],a[t].t));
    return 0;
}
```

---

## 作者：Sober_Clever (赞：0)

这道题的思路有点意思

对于T为0的情况，直接输出d[e]

T不为0时，用队组存a[i],x

按a[i]排序

若lty在czx离开x前到达x（d[x]<a[i+1]）

则lty可以在点x卡到czx

最后在所有这样的x中找出max(a[i],d[x])（a[i]、d[x]分为为czx、lty到达x的时刻）的最小值即可

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int MAXN=1e5 + 3;
int read()
{
	int x=0,w=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') w=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-48;c=getchar();}
	return x*w;
}

struct Edge
{
	int to,next,w;
}e[MAXN*10];
int head[MAXN]={0},cnt=0;
inline void add(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}

priority_queue<pair<int,int> > Q;
int d[MAXN]={0},vis[MAXN]={0};
void dij(int s)
{
	memset(d,127,sizeof(d));
	memset(vis,0,sizeof(vis));	
	d[s]=0,Q.push(make_pair(-d[s],s));
	while(!Q.empty())
	{
		int u=Q.top().second;
		Q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(d[v]>d[u]+e[i].w)
				d[v]=d[u]+e[i].w,Q.push(make_pair(-d[v],v));
		}
	}
}

pair<int,int> p[MAXN];
int main()
{
	int n=read(),m=read(),s=read(),t=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read();
		add(u,v,w);
		add(v,u,w);
	}
	int T=read();
	for(int i=1;i<=T;i++)
		p[i].first=read(),p[i].second=read();
	sort(p+1,p+1+T);
	dij(s);
	int ans=1<<30;
	if(T==0)
		ans=d[t];
	else
	{
		if(d[t]<p[1].first) ans=d[t];
		for(int i=1;i<T;i++)
		{
			int v=p[i].second;
			if(d[v]<p[i+1].first)//lty可以赶在czx离开前到达v 
				ans=min(ans,max(d[v],p[i].first));
		}
		ans=min(ans,max(d[p[T].second],p[T].first));
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：寒鸽儿 (赞：0)

### 单源最短路水题
根据给定的图跑dij可以知道lty何时能最早到达某点。 
我们要求得最优的时间，就要考虑能否更早抓到czx。所以，我们将czx出现的时间排序，从早到晚考虑，能否在这一段时间内捕捉到czx。  
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#define pii pair<int, int>

using namespace std;

const int maxn = 100010, maxm = 1000010, maxt = 100010;

inline char gc() {
	static char buf[1<<21], *p1 = buf, *p2 = buf;
	return p1==p2 && (p2=(p1=buf)+fread(buf, 1, 1<<21, stdin), p1==p2) ? EOF : *p1++;
}

inline void read(int &x) {
	x = 0; char ch = gc();
	while(ch < '0' || ch > '9') ch = gc();
	while(ch >= '0' && ch <= '9') x = (x<<3)+(x<<1)+(ch&15), ch = gc();
}

struct chg{
	int time, pl;
	inline bool operator < (const chg & o) const {
		return time < o.time;
	}
}cg[maxt];

struct edges{
	int to, wei, nex;
}e[maxm<<1];
int head[maxn], tot;

inline void addedge(int u, int v, int w) {
	e[tot] = (edges){v, w, head[u]}; head[u] = tot++;
}


priority_queue<pii> q;
int d[maxn];
inline void dij(int s) {
	memset(d, -1, sizeof(d));
	d[s] = 0; q.push(make_pair(0, s));
	while(!q.empty()) {
		int cur = q.top().second, dmen = -q.top().first; q.pop();
		if(dmen > d[cur]) continue;
		for(int i = head[cur]; i != -1; i = e[i].nex) {
			if(d[e[i].to] == -1 || d[e[i].to] > d[cur] + e[i].wei) {
				d[e[i].to] = d[cur] + e[i].wei;
				q.push(make_pair(-d[e[i].to], e[i].to));
			}
		}
	}
}

int main() {
	memset(head, -1, sizeof(head));
	int n, m, b, e, u, v, w, t;
	read(n); read(m); read(b); read(e);
	while(m--) {
		read(u); read(v); read(w);
		addedge(u, v, w);
		addedge(v, u, w);
	}
	read(t);
	for(int i = 0; i < t; i++)
		read(cg[i].time), read(cg[i].pl);
	sort(cg, cg+t);
	dij(b);
	if(t == 0) {
		printf("%d\n", d[e]);
	} else if(d[e] < cg[0].time) {
		printf("%d\n", d[e]);
	} else {
		for(int i = 0; i < t; i++) {
			int pls = cg[i].pl, tm = i != t ? cg[i+1].time : 0x3f3f3f3f;
			if(d[pls] < tm) {
				printf("%d\n", max(cg[i].time, d[pls]));
				return 0;
			}
		}
	}
	return 0;
}
```

---


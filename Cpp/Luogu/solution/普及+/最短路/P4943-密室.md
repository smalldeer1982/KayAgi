# 密室

## 题目背景

NOIP2018 原创模拟题 T2

NOIP DAY1 T2 or DAY2 T2 难度

题目背景改编自小说《哈利波特与密室》。

## 题目描述

**密室被打开了。**

哈利与罗恩进入了密室，他们发现密室由n个小室组成，所有小室编号分别为：$1,2,...,n$ 。所有小室之间有 $m$ 条通道，对任意两个不同小室最多只有一条通道连接，而每通过一条通道都需要 $C_i$ 的时间。

开始时哈利与罗恩都在编号为 $1$ 的小室里，他们的目标是拯救金妮和寻找日记，但是他们发现金妮和日记可能在两个不同的小室里，为了尽快发现真相，他们决定以最少的时间到达两个目标小室。但是某些小室只有会与蛇对话的人才能进入，也就是只有哈利一个人可以进入。

现在，哈利告诉你密室的结构，请你计算他们到达两个目标小室的最短时间。

## 说明/提示

**样例解释：**

**样例一：**

哈利：$1->5->6$ 花费时间为 $5$

罗恩：$1->3->4$ 花费时间为 $5$

所以最短时间为 $5$

**样例二：**

![图1](https://cdn.luogu.com.cn/upload/pic/31438.png)

如图，橙色表示目标小室，绿色只有哈利可以通过

哈利：$1->2->3->4->6$ 花费时间为 $9$

罗恩：$1->9->8$ 花费时间为 $16$

所以最短时间为 $16$

**数据范围：**

$10\%$ 数据满足：$n\leq 5$

$30\%$ 数据满足：$n\leq 20$

$50\%$ 数据满足：$n\leq 1000$

$70\%$ 数据满足：$n\leq 10000$

$100\%$数据满足：$n\leq 50000$ ; $a,b,k\leq n$ ;  $c\leq 1000$ ; $m\leq 100000$，保证罗恩可以在密室 $1$

**特殊约定：**

$30\%$ 数据满足：$k=0$

## 样例 #1

### 输入

```
6 8 1
5
1 2 3
2 3 2
1 3 4
3 4 1
4 6 5
5 6 2
1 6 6
1 5 3
4 6```

### 输出

```
5```

## 样例 #2

### 输入

```
10 13 3
3 4 10
1 2 1
2 3 2
3 4 3
4 5 4
5 6 5
6 7 10
7 8 5
8 9 10
9 10 3
10 1 2
1 9 6
3 8 10
4 6 3
6 8```

### 输出

```
16```

# 题解

## 作者：丨Sky灬丨无惧 (赞：9)

### 题解

思路：数据范围$n\le50000$,所以不能使用邻接矩阵，于是使用链式前向星。根据样例一看出，可以罗恩去救金妮，哈利去拿日记；根据样例二看出，可以罗恩去拿日记，哈利去救金妮。再加上一个人单独前往的情况，于是就有了4种走法：

```
1. 罗恩拿日记，哈利救金妮；

2. 罗恩救金妮，哈利拿日记；

3. 哈利自己救金妮并拿日记；

4. 罗恩自己救金妮并拿日记；
```

这样一看要跑四遍SPFA，但是由于罗恩能走的哈利也能走，哈利能走的罗恩却不能走，所以罗恩单独前往的SPFA就可以省略了。然后求出三种走法的最小值即可。其中注意的是，当求哈利自己走时，由于先前已经求过哈利到日记和金妮的最小值了，所以只要求日记到金妮的最小值。

![](https://cdn.luogu.com.cn/upload/pic/31438.png)

【代码】 ：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,k=0,k1,u,v,w,x,y,lsg,b[1000000],vis[1000000];
int q[10000000],r,l,check=0,ans[1000000],c[1000000];
int zc[100];//用来存放临时答案。
struct sb {
	int u,v,w,next;
};
sb a[1000000];
void ctt(int u,int v,int w) {
	a[++k].u=u;
	a[k].v=v;
	a[k].w=w;
	a[k].next=b[u];
	b[u]=k;
	return;
}
void SPFA() {
	for(int i=1; i<=n; i++)ans[i]=1e9;
	r=0;
	l=1;
	memset(c,0,sizeof(c));//j因为有多次SPFA所以要记得及时清除。
	if(check!=2) {//当两人一起行动时,从一开始。
		q[++r]=1;
		ans[1]=0;
	}
	else {//当哈利自己行动时，只要计算从日记到金妮。
		q[++r]=x;
		ans[x]=0;
	}
	while(l<=r) {
		int u=q[l++];
		c[u]=0;
		if(!check&&vis[u])continue;/罗恩无法通过带蛇的房间。
		for(int i=b[u]; i; i=a[i].next) {
			int v=a[i].v;
			if(ans[v]>ans[u]+a[i].w) {
				ans[v]=ans[u]+a[i].w;
				if(c[v]==0) {
					c[v]=1;
					q[++r]=v;
				}
			}
		}
	}
}
int main() {
	cin>>n>>m>>k1;
	for(int i=1; i<=k1; i++) {
		cin>>lsg;
		vis[lsg]=1;//带蛇的房间打上标记。
	}
	for(int i=1; i<=m; i++) {
		cin>>u>>v>>w;
		ctt(u,v,w);
		ctt(v,u,w);
	}
	cin>>x>>y;
	SPFA();//先从罗恩开始，这样思路稍微清晰点，此时check=0。
	zc[1]=ans[x];//罗恩到金妮的路程。
	zc[2]=ans[y];//罗恩到日记的路程。
	check++;
	SPFA();//此时求哈利的路程，check=1，上面判断有蛇房间的判断已失效。
	zc[3]=ans[x];//哈利到金妮的路程。
	zc[4]=ans[y];//哈利到日记的路程。
	check++;
	SPFA();//求日记到金妮的路程，此时check=2，上方的判定生效。
	zc[5]=ans[y];//日记到金妮的路程。
	int x2,y2,z2;//三个临时存放点
	x2=max(zc[1],zc[4]);//计算罗恩救金妮，哈利拿日记的最大值，因为此时时间应是最后完成的时间，才是结束，样例二可看出。
	y2=max(zc[2],zc[3]);//计算哈利救金妮，罗恩拿日记的最小值。
	z2=min(zc[3],zc[4])+zc[5];//计算哈利自己行动的最小值，使用min因为此时一人行动，从最小开始才最优。
	x2=min(x2,y2);//比较罗恩救金妮，哈利拿日记和哈利救金妮，罗恩拿日记的最小值，x2更新为此时的最小值。
	cout<<min(x2,z2);//用上一次比较的最小值同哈利自己行动的路程比较，最小值就是最终答案。
	return 0;
}
```

完结撒花。

---

## 作者：xcyy (赞：4)

**这题思路非常简单，大概五分钟就能出，总共就3种情况**

1,哈利去x或y，罗恩去x或y
2,哈利去x或y之后再去另外一个 
3,罗恩去x或y之后再去另外一个 
我跑了六遍最短路，但只需要写2个最短路，一个是哈利的一个是罗恩的。
但其实这2个最短路差别也不大，也是就是由

if(dis2[v]>dis2[u]+w)
变成了
if(dis1[v]>dis1[u]+w&&!nb[v])这个nb数组存的就是哈利能过而罗恩过不了的，因为哈利nb所以就叫nb数组了哈哈哈。
另外还有一个坑点，我一开始初始化给inf的值是0x7f就只有90分，
但改成了0x3f3f3f3f就过了，目前还不是很明白为什么，但网上有个ACM的朋友和我这么说的
![](https://cdn.luogu.com.cn/upload/pic/71530.png)
不是很懂，但也懒得懂了，如果哪位大佬知道更加简单的解释方法麻烦和我解释一下，感激不尽。

好了上代码了

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
#define N 100005
#define inf 0x3f3f3f3f
int h[N];
int head[N],nxt[N*2],to[N*2],val[N*2];
int dis1[N],dis2[N],nb[N],vis[N],f[N]; 
int tot;
int a,b,n,m,k;
int ans1,ans2,ans3,ans4,ans5,ans6,ans7,ans8,ans;
//哈利去x或y，罗恩去x或y
//哈利去x或y之后再去另外一个 
//罗恩去x或y之后再去另外一个 
inline void add(int x,int y,int z)
{
	nxt[++tot]=head[x];
	to[tot]=y;
	val[tot]=z;
	head[x]=tot;
}

inline void spfa1(int x)
{
	memset(dis1,inf,sizeof(dis1));
	memset(vis,0,sizeof(vis));
	vis[x]=1;
	dis1[x]=0;
	queue<int> q;
	q.push(x);
	while(q.size())
	{
		int u=q.front();
		vis[u]=0;
		q.pop();
		for(int i=head[u];i;i=nxt[i])
		{
			int v=to[i];int w=val[i];
			if(dis1[v]>dis1[u]+w&&!nb[v])//两个spfa唯一不一样的地方
			{
			dis1[v]=dis1[u]+w;
			if(!vis[v]) 
			vis[v]=1,q.push(v);
			}
		}
	}
}

inline void spfa2(int x)
{
	queue<int> q;
	memset(dis2,inf,sizeof(dis2));
	memset(vis,0,sizeof(vis));
	q.push(x);
	dis2[x]=0;
	vis[x]=1;
	while(q.size())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=nxt[i])
		{
			int v=to[i];int w=val[i];
			if(dis2[v]>dis2[u]+w)
			{
				dis2[v]=dis2[u]+w;
				if(!vis[v])
				vis[v]=1,q.push(v);
			}
		}
	}
}

int main()
{
	int x,y,z;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++)
	{
	scanf("%d",&h[i]);	
	nb[h[i]]=1;
	}
	for(int i=1;i<=m;i++)
	{
	scanf("%d%d%d",&x,&y,&z);	
	add(x,y,z);add(y,x,z);
	}
	scanf("%d%d",&a,&b);
	spfa1(1);
	ans1=dis1[a];ans2=dis1[b];//罗分别去a,b的时间 
	//cout<<ans1<<" "<<ans2<<endl;
	spfa1(a);
	ans5+=ans1+dis1[b];//罗去了a又去b 
	spfa1(b);
	ans6+=ans2+dis1[a];//罗去了b又去a 
	
	spfa2(1);
	ans3=dis2[a];ans4=dis2[b];//哈分别去a,b的时间 
	//cout<<ans3<<" "<<ans4<<endl; 
	spfa2(a);
	ans7+=ans3+dis2[b];//哈去了a又去b 
	spfa2(b);
	ans8+=ans4+dis2[a];//哈去了b又去a 
	int ansa=max(ans4,ans1);
	if(max(ans3,ans2)<ansa)//看看这2套组合哪个小 ,单走代表 
	ansa=max(ans3,ans2);
	//cout<<ansa<<endl;
	int ansb=min(ans5,ans6);
	ansb=min(ansb,ans7);
	ansb=min(ansb,ans8);
	ans=min(ansb,ansa);
	printf("%d",ans);
	return 0;
} 
```


---

## 作者：kangli (赞：4)

~~这题有蓝色？~~

我们发现：对于做每次的最短路，有三种情况

1.哈利去一号房间，罗恩去二号房间。

2.哈利去二号房间，罗恩去一号房间。

3.让一个人去两个房间，由于罗恩走过的路哈利都能走，所以我们直接让哈利去两个房间就可以了，此时我们处理还要分两种讨论：

        （1）哈利先到一号房间，再从一号房间到二号房间。       
        （2）哈利先到二号房间，再从二号房间到一号房间。

**注意：1、2两种情况是求两个时间的最大值，而第三种要吧两个时间累加**

最后把四个时间比较最小值即可。

时间复杂度约为$O(KM)$（由于数据范围不大，~~而且不卡$SPFA$~~，此题能过）

下面贴比赛的代码（奇丑无比）：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
using namespace std;
struct bian{int to,f;};
const int maxn=50100;
vector <bian> v[maxn];//哈利走的路
vector <bian> vs[maxn];//罗特走的路
int kk,q[maxn*100],vis[maxn],d[maxn],ans[18];
int zhi[maxn],st,ed,l,r,n,m;
void spfa()//求出哈利直接到一个房间的最短路
{
	l=0,r=1;
	memset(q,0,sizeof(q)); memset(vis,0,sizeof(vis));
	for (int i=1; i<=n; i++) d[i]=99999999;
	q[1]=1,d[1]=0;vis[1]=1;
	while (l<r)
	{
		l++;
		int x=q[l];
		for (unsigned int i=0;i<v[x].size(); i++)
		{
			int y=v[x][i].to,z=v[x][i].f;
			if (d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				if (!vis[y]) vis[y]=1,r++,q[r]=y;
			}
		}
		vis[x]=0;
	}
	
}
void spfa2()//求出罗特直接到一个房间的最短路
{
	l=0,r=1;
    for (int i=1; i<=n; i++) d[i]=99999999;	
   	memset(q,0,sizeof(q)); memset(vis,0,sizeof(vis));
	q[1]=1,d[1]=0;vis[1]=1;
	while (l<r)
	{
		l++;
		int x=q[l];
		for (unsigned int i=0;i<vs[x].size(); i++)
		{
			int y=vs[x][i].to,z=vs[x][i].f;
			if (d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				if (!vis[y]) vis[y]=1,r++,q[r]=y;
			}
		}
		vis[x]=0;
	}
}
void spfa3()//求出哈利到一个房间再到另一个房间的最短路
{
	l=0,r=1;
    for (int i=1; i<=n; i++) d[i]=99999999;	
   	memset(q,0,sizeof(q)); memset(vis,0,sizeof(vis));
	q[1]=st,d[st]=0;vis[st]=1;
	while (l<r)
	{
		l++;
		int x=q[l];
		for (unsigned int i=0;i<v[x].size(); i++)
		{
			int y=v[x][i].to,z=v[x][i].f;
			if (d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				if (!vis[y]) vis[y]=1,r++,q[r]=y;
			}
		}
		vis[x]=0;
	}
}
void spfa4()//同上，求出哈利到一个房间再到另一个房间的最短路
{
	l=0,r=1;
    for (int i=1; i<=n; i++) d[i]=99999999;	
   	memset(q,0,sizeof(q)); memset(vis,0,sizeof(vis));
	q[1]=ed,d[ed]=0;vis[ed]=1;
	while (l<r)
	{
		l++;
		int x=q[l];
		for (unsigned int i=0;i<v[x].size(); i++)
		{
			int y=v[x][i].to,z=v[x][i].f;
			if (d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				if (!vis[y]) vis[y]=1,r++,q[r]=y;
			}
		}
		vis[x]=0;
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&kk);
	for (int i=1; i<=kk; i++) {int di; scanf("%d",&di),zhi[di]=1;}
	for (int i=1; i<=m; i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		int xx=x,yy=y,zz=z;
		bian k,k2;
		k.to=y,k.f=z; k2.to=x,k2.f=z;
		v[x].push_back(k); v[y].push_back(k2);
		bian kk,kk2;
		kk.to=yy,kk.f=zz; kk2.to=xx,kk2.f=zz;
		if (!zhi[xx]&&!zhi[yy]){
			vs[xx].push_back(kk); vs[yy].push_back(kk2);
		}
	}
	scanf("%d%d",&st,&ed);
	spfa(); ans[0]=d[st]; ans[1]=d[ed];
	spfa2(); ans[2]=d[st]; ans[3]=d[ed];
	spfa3(); ans[4]=d[ed];
    spfa4(); ans[9]=d[st];
	ans[5]=max(ans[0],ans[3]); ans[6]=max(ans[1],ans[2]);
	ans[7]=ans[1]+ans[4]; ans[8]=ans[4]+ans[0];
    ans[10]=ans[9]+ans[1];
	int da=99999999;
	for (int i=5; i<=8; i++)
	da=min(da,ans[i]);
    da=min(da,ans[10]);
	printf("%d\n",da);
	return 0;
}
```

---

## 作者：RiverFun (赞：4)

这个题我跑了四遍最短路。。。。。。

一共有四种情况：

1.哈利这么走1->x->y；

2.哈利这么走1->y->x；

3.哈利这么走1->x，罗恩这么走1->y；

4.哈利这么走1->y，罗恩这么走1->x；

注意：第3、4种情况要选取时间最长的人的最小值。

注意#2：别忘了初始化。

下面是~~愉快的~~代码时间

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#define MAXN 100000
#define INF 2147483647
struct Edge {
	int v , nx , w;
}e[MAXN * 4];
int min(int a , int b) {
	if (a < b) return a;
	else return b;
}
int max(int a , int b) {
	if (a > b) return b;
	else return b;
}
int head[MAXN] , dist[MAXN] , n , m , ans = INF , ans2 = INF , ecnt , w , u , v , k , ki , x , y , dis1[MAXN] , dis2[MAXN];
bool vis[MAXN], cant[MAXN];
void add(int f , int t , int w) {
	e[++ecnt].v = t;
	e[ecnt].nx = head[f];
	e[ecnt].w = w;
	head[f] = ecnt;
}
struct node {
	int id , w;
};
bool operator < (node a , node b) {
	return a.w > b.w;
}
void dijkstra1(int s , int dis[]) {
	memset(vis , 0 , sizeof(vis));
	std::priority_queue <node> q;
	q.push((node){s , 0});
	dis[s] = 0;
	while (!q.empty()) {
		node f = q.top();
		q.pop();
		int v = f.id;
		if (vis[v]) continue;
		vis[v] = 1;
		for (int i = head[v] ; i ; i = e[i].nx) {
			int to = e[i].v;
			if (dis[to] > dis[v] + e[i].w) {
				dis[to] = dis[v] + e[i].w;
				q.push((node){to , dis[to]});
			}
		}
	}
}
void dijkstra2(int s , int dis[]) {
	memset(vis , 0 , sizeof(vis));
	std::priority_queue <node> q;
	q.push((node){s , 0});
	dis[s] = 0;
	while (!q.empty()) {
		node f = q.top();
		q.pop();
		int v = f.id;
		if (vis[v]) continue;
		vis[v] = 1;
		for (int i = head[v] ; i ; i = e[i].nx) {
			int to = e[i].v;
			if (cant[to] == 1) continue;
			if (dis[to] > dis[v] + e[i].w) {
				dis[to] = dis[v] + e[i].w;
				q.push((node){to , dis[to]});
			}
		}
	}
}
void init() {
	memset(dis1 , 0x7f , sizeof(dis1));
	memset(dis2 , 0x7f , sizeof(dis2));
	memset(dist , 0x7f , sizeof(dist));
}
int main() {
	memset(cant , 0 , sizeof(cant));
	init();
	scanf("%d%d%d" , &n , &m , &k);
	for (int i = 1 ; i <= k ; i++) {
		scanf("%d" , &ki);
		cant[ki] = 1;
	}
	for (int i = 1 ; i <= m ; i++) {
		scanf("%d%d%d" , &u , &v , &w);
		add(u , v , w);
		add(v , u , w);
	}
	scanf("%d%d" , &x , &y);
	dijkstra1(x , dist);
	ans = min(dist[1] + dist[y] , ans);
	init();
	dijkstra1(y , dist);
	ans = min(ans , dist[1] + dist[x]);
	init();
	dijkstra1(1 , dis1);
	dijkstra2(1 , dis2);
	ans2 = max(dis1[x] , dis2[y]);
	ans2 = min(ans2 , max(dis1[y] , dis2[x]));
	printf("%d" , min(ans , ans2));
}

```

---

## 作者：MZ_CXQ (赞：3)

初看此题好像很难,但仔细分析,两个终点要么被两个人完成,要么被一个人完成,而一个人完成只需考虑哈利(两人起点相同,本质上等价,罗恩能走的哈利都能走)

所以便有四种情况

$h->s1,l->s2$

$h->s2,l->s1$

$h->s1->s2$

$h->s2->s1$

跑三次$dijkstra$即可解决(($h,1$),($l,1$),($h,s1$))

代码如下
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#define ll long long
using namespace std;

template <typename T> void in(T &x) {
	x = 0; T f = 1; char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
	while(isdigit(ch)) {x = 10*x+ch-'0'; ch = getchar();}
	x *= f;
}

template <typename T> void out(T x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) out(x/10);
	putchar(x%10+'0');
}
//---------------------------------------------------------------

const int N = 50005,M = 100005;

int n,m,k,h[N],s1,s2;

struct edge {
	int v,w,nxt;
	edge(int v = 0,int w = 0,int nxt = 0):v(v),w(w),nxt(nxt){};
}e[M<<1]; int head[N],e_cnt;

void add(int u,int v,int w) {
	e[++e_cnt] = edge(v,w,head[u]); head[u] = e_cnt;
}

struct node {
	int pos,dis;
	node(int pos = 0,int dis = 0):pos(pos),dis(dis){};
	bool operator < (const node &sed) const {
		return dis > sed.dis;
	}
};

int dis[N],vis[N];

void dijkstra(int p,int s) {
	priority_queue <node> q;
	memset(dis,0x3f,sizeof(dis)); 
	memset(vis,0,sizeof(vis));
	q.push(node(s,0)); dis[s] = 0;
	while(!q.empty()) {
		node _u = q.top(); q.pop();
		int u = _u.pos; 
		if(vis[u]) continue; vis[u] = 1;
		for(int i = head[u]; i;i = e[i].nxt) {
			int v = e[i].v; if(p == 2 && h[v]) continue; 
			if(dis[v] > dis[u]+e[i].w) {
				dis[v] = dis[u]+e[i].w;
				q.push(node(v,dis[v]));
			}
		}
	}
}

int main() {
	int i,x,a,b,c; in(n); in(m); in(k);
	for(i = 1;i <= k; ++i) in(x),h[x] = 1;
	for(i = 1;i <= m; ++i) {
		in(a); in(b); in(c);
		add(a,b,c); add(b,a,c);
	}
	in(s1); in(s2);
	int h_s1,h_s2,l_s1,l_s2,s1_s2;
	dijkstra(1,1); h_s1 = dis[s1],h_s2 = dis[s2];
	dijkstra(2,1); l_s1 = dis[s1],l_s2 = dis[s2];
	dijkstra(1,s1); s1_s2 = dis[s2];
	out(min(min(max(h_s1,l_s2),max(h_s2,l_s1)),min(h_s1,h_s2)+s1_s2));
	return 0;
}
```


---

## 作者：Horizon·Sun (赞：3)

# 很好的一道思维题
~~然而我第一次只得了80分~~
## 思路：
分两个图作最短路，一个是哈利，一个是罗恩。

分好情况：

1. 哈去第一个，罗去第二个；
2. 哈去第二个，罗去第一个；
3. 哈去第一个，再去第二个；
4. 哈去第二个，再去第一个；

## 注意：
1. 因为哈利能走的路一定比罗恩的多，所以罗恩不能去的一些点哈利能去。因此有了3,4点情况；
2. 哈去第一个和第二个不是分别去，而是连续的（我就是这里没注意才wa的）；

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define maxn 1000010
using namespace std;

int len1[maxn],len2[maxn];
int pre1[maxn],last1[maxn],other1[maxn];
int que1[maxn],dis1[maxn];
bool vis1[maxn];

int pre2[maxn],last2[maxn],other2[maxn];
int que2[maxn],dis2[maxn];
bool vis2[maxn];

int l1,l2,n,m,k,e1,e2;

bool pd[maxn];
int ans[7];

void add(int x,int y,int z)
{
    l1++;
    pre1[l1]=last1[x];
    last1[x]=l1;
    other1[l1]=y;
    len1[l1]=z;
    if(pd[x]||pd[y])
    return;
    else
    {
        l2++;
        pre2[l2]=last2[x];
        last2[x]=l2;
        other2[l2]=y;
        len2[l2]=z;
    }
}

void SPFA1(int s)
{
    memset(dis1,63,sizeof dis1);
    memset(vis1,0,sizeof vis1);
    que1[1]=s;
    dis1[s]=0;
    int h=0,t=1;
    while(h!=t)
    {
        h++;
        int u=que1[h];
        vis1[u]=0;
        for(int p=last1[u];p;p=pre1[p])
        {
            int v=other1[p];
            if(dis1[v]>dis1[u]+len1[p])
            {
                dis1[v]=dis1[u]+len1[p];
                if(!vis1[v])
                {
                    t++;
                    vis1[v]=1;
                    que1[t]=v;
                }
            }
        }
    }
}

void SPFA2(int s)
{
    memset(dis2,63,sizeof dis2);
    que2[1]=s;
    dis2[s]=0;
    int h=0,t=1;
    while(h!=t)
    {
        h++;
        int u=que2[h];
        vis2[u]=0;
        for(int p=last2[u];p;p=pre2[p])
        {
            int v=other2[p];
            if(dis2[v]>dis2[u]+len2[p])
            {
                dis2[v]=dis2[u]+len2[p];
                if(!vis2[v])
                {
                    t++;
                    vis2[v]=1;
                    que2[t]=v;
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=k;i++)
    {
        int x;
        scanf("%d",&x);
        pd[x]=1;
    }
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
    scanf("%d%d",&e1,&e2);
    SPFA1(1);
    ans[1]=dis1[e1],ans[2]=dis1[e2],ans[5]=dis1[e1],ans[6]=dis1[e2];
    SPFA1(e1);
    ans[5]+=dis1[e2];
    SPFA1(e2);
    ans[6]+=dis1[e1];
    SPFA2(1);
    ans[3]=dis2[e1],ans[4]=dis2[e2];
    int a,b,c;
    a=max(ans[1],ans[4]);
    b=max(ans[2],ans[3]);
    c=min(ans[5],ans[6]);
    int aaa;
    aaa=min(a,b);
    aaa=min(aaa,c);
    printf("%d",aaa);
    
    return 0;
}
```


---

## 作者：一个昵称 (赞：2)

**~~这是我做过的一道最水的紫题~~**

~~emmm 其实说他是紫题也还是合理的 毕竟模板都是蓝题……~~

简单的分析一下题目 可以发现这是一道最短路的题 于是果断dijkstra （~~SPFA已死 其实主要是本蒟蒻只会dijkstra~~）

我们可以发现 两个人是同时去找两个房间的 只是其中有一个人有些房间走不了 那么其实最短时间就是 **哈利去1号房间 罗恩去2号房间的时间** 和 **哈利去2号房间 罗恩去1号房间的时间** 和 **哈利先去1 再去2 的时间** 和 **哈利先去2 再去1的时间** 的最小值 因为罗恩有些房间去不了 所以哈利所走的一定是最短的 故不考虑罗恩自己跑两个房间的情况

所以 我们只用跑三遍最短路就好啦 分别是 哈利从起点开始的 罗恩从起点开始的 和 哈利从1到2的（因为1到2和2到1是一样的）

下面附上代码 看不懂的请自觉去看模板题[最短路模板](https://www.luogu.org/problem/P4779)

```cpp
#include<iostream>
#include<queue>
using namespace std;

#define INF 0x7fffffff

int n,m,k,cnt=0;

int ak[50001];

int dis1[50001];

struct nod{
	int to,nxt,w;
}e[200005];

struct heap{
	int u,d;
	bool operator <(const heap& rhs )const{
		return rhs.d<d;
	}
};

int head[100001];

void addEdge(int u,int v,int w){
	e[++cnt]=(nod){v,head[u],w};
	head[u]=cnt;
}

void Djstl(){
	priority_queue <heap> q;
	for(int i=1;i<=n;i++) dis1[i]=INF;
	dis1[1]=0;
	q.push((heap){1,0});
	while(!q.empty()){
		heap x=q.top();
		q.pop();
		for(int i=head[x.u];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].w;
			if(dis1[v]>dis1[x.u]+w){
				dis1[v]=dis1[x.u]+w;
				q.push((heap){v,dis1[v]});
			}
		}
	}
}

void djstll(int s){
	priority_queue <heap> q;
	for(int i=1;i<=n;i++) dis1[i]=INF;
	dis1[s]=0;
	q.push((heap){s,0});
	while(!q.empty()){
		heap x=q.top();
		q.pop();
		for(int i=head[x.u];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].w;
			if(dis1[v]>dis1[x.u]+w){
				dis1[v]=dis1[x.u]+w;
				q.push((heap){v,dis1[v]});
			}
		}
	}
}

void djstl(){
	priority_queue <heap> q;
	for(int i=1;i<=n;i++) dis1[i]=INF;
	dis1[1]=0;
	q.push((heap){1,0});
	while(!q.empty()){
		heap x=q.top();
		q.pop();
		for(int i=head[x.u];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].w;
			if(ak[v]) continue;
			if(dis1[v]>dis1[x.u]+w){
				dis1[v]=dis1[x.u]+w;
				q.push((heap){v,dis1[v]});
			}
		}
	}
}


int main(){
	cin>>n>>m>>k;
	for(int i=1,lj;i<=k;i++){
		cin>>lj;
		ak[lj]=1;
	}
	for(int i=1,u,v,w;i<=m;i++){
		cin>>u>>v>>w;
		addEdge(u,v,w);
		addEdge(v,u,w);
	}
	int md1,md2;
	cin>>md1>>md2;
	Djstl();//哈利
	int hl1=dis1[md1],hl2=dis1[md2];
	djstll(md1);//从1到2
	int hl3=dis1[md2];
	djstl();//罗恩
	int ln1=dis1[md1],ln2=dis1[md2];
	long long ans=min(min(max(hl1,ln2),max(hl2,ln1)),min(hl1,hl2)+hl3);
	cout<<ans;
	return 0;
}
```


---

## 作者：szbszb (赞：2)

###### 惊奇的发现一遍过
本题的走法有三（四）种：
	
    1、哈利去日记，罗恩去金妮
    
    2、哈利去金妮，罗恩去日记
    
    3、哈利自己走
  第一、第二中取最短路的最大值；
  
  而第3中情况只要取去1，去2的较短边，因为双向边代表的d[日记][金妮]==d[金妮][日记]，即min（d[原点][金妮],d[原点][日记]）+d[日记][金妮]
  
  这样题就好做了
  
  之后，读入k即罗恩不能走的就直接将b[i]设为true即可，之后先算罗恩的最短路
  总而言之，一共要跑三次最短路，按顺序为：罗恩的，哈利的，从金妮到日记的（哈利）
  上代码：
  ```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<pair<long long,long long> >q;
long long n,m,s,i,cnt,x,y,z,he[1000001],ne[2000001],l[2000001],to[2000001],d[1000001],a1,a2,min1,k;
bool b[1000001];
int main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for (i=1;i<=k;i++)
		{
			scanf("%lld",&x);
			b[x]=true;//直接设该点不能走，之后先跑罗恩
		}
	for (i=1;i<=m;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&z);
		cnt++;
		ne[cnt]=he[x];
		to[cnt]=y;
		l[cnt]=z;
		he[x]=cnt;
		cnt++;
		ne[cnt]=he[y];
		to[cnt]=x;
		l[cnt]=z;
		he[y]=cnt;//邻接表
	}
	scanf("%lld%lld",&y,&z);//以y、z储存日记、金妮的位置
	memset(d,127,sizeof(d));
	d[1]=0;
	q.push(make_pair(0,1));
	while (q.size())
	{
		x=q.top().second;
		q.pop();
		if (b[x]) continue;
		b[x]=true;
		for (i=he[x];i!=0 ;i=ne[i])
			if (d[to[i]]>d[x]+l[i])
			{
				d[to[i]]=d[x]+l[i];
				q.push(make_pair(-d[to[i]],to[i]));
			}
	}//罗恩的
	a1=d[y];
	a2=d[z];//记录
	for (i=1;i<=n;i++) b[i]=false;
	memset(d,127,sizeof(d));
	d[1]=0;
	q.push(make_pair(0,1));
	while (q.size())
	{
		x=q.top().second;
		q.pop();
		if (b[x]) continue;
		b[x]=true;
		for (i=he[x];i!=0 ;i=ne[i])
			if (d[to[i]]>d[x]+l[i])
			{
				d[to[i]]=d[x]+l[i];
				q.push(make_pair(-d[to[i]],to[i]));
			}
	}//哈利的
	min1=min(max(a1,d[z]),max(a2,d[y]));//计算1、2两种情况的最小值
	a1=min(d[y],d[z]);
	for (i=1;i<=n;i++) b[i]=false;
	memset(d,127,sizeof(d));
	d[y]=0;
	q.push(make_pair(0,y));
	while (q.size())
	{
		x=q.top().second;
		q.pop();
		if (b[x]) continue;
		b[x]=true;
		for (i=he[x];i!=0 ;i=ne[i])
			if (d[to[i]]>d[x]+l[i])
			{
				d[to[i]]=d[x]+l[i];
				q.push(make_pair(-d[to[i]],to[i]));
			}
	}//从金妮到日记的
	min1=min(min1,d[z]+a1);//再次判断
	printf("%lld",min1);
	return 0;
}
```
分析之后，这道题也不算难

---

## 作者：TheShadow (赞：1)

# 闲扯

做了昨天讲课听了一天的网络流，脑子都痛了，换点题做，结果随机调到这道题，发现貌似很好做的样子。。

# Solution

首先我们分情况讨论一下。

1. 罗恩去密室 $1$ ，哈利去密室 $2$ 。
2. 罗恩去密室 $2$ ，哈利去密室 $1$ 。
3. 罗恩吃瓜，哈利去两个密室。

对于罗恩可以走的路，哈利一定是可以走的，所以哈利到两个密室的时间一定不小于罗恩。所以罗恩选择去他能去的密室中较近的一个，剩下一个由哈利去。

为什么是对哒？

考虑罗恩去较远的一个，那么哈利到较近的一个密室所用的时间是不大于罗恩所用时间的，所以答案为罗恩到较远密室所用的时间。

考虑罗恩去较近的一个，那么哈利到较远的一个密室所用的时间是不大于罗恩所用时间的，所以答案不大于罗恩到较远密室所用的时间。

综上，对于前两种情况，可以由以上策略解决。

对于第 $3$ 种情况，我们记录一下哈利到两间密室用时最短为多少，再找出两间密室间的最小距离，两者累加即为答案。

最后输出再取一个最小值即可。

$ps:$ 对于前两种情况，答案应取用两人用时的最大值。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(res*bas)%mod;
		bas=(bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 5e4+5;
int n,m,k,u,v,d,t1,t2,head[MAXN],num_edge,dis[MAXN],ans,now;
struct Edge{
	int next,to,dis;
	Edge(){}
	Edge(int next,int to,int dis):next(next),to(to),dis(dis){}
}edge[MAXN<<2];
il add_edge(int u,int v,int d){
	edge[++num_edge]=Edge(head[u],v,d),head[u]=num_edge;
	edge[++num_edge]=Edge(head[v],u,d),head[v]=num_edge;
}
bool tr[MAXN],onl[MAXN],fla;
il dijkstra(int s,int type){
	priority_queue<pair<int,int> > q;q.push(make_pair(0,s));
	del(dis,0x3f),del(tr,0),dis[s]=0;
	while(!q.empty()){
		pair<int,int> tmp=q.top();q.pop();
		ri pos=tmp.second;
		if(tr[pos]) continue;
		tr[pos]=1;
		for(ri i=head[pos];i;i=edge[i].next){
			if(type&&onl[edge[i].to]) continue;
			if(dis[edge[i].to]>dis[pos]+edge[i].dis){
				dis[edge[i].to]=dis[pos]+edge[i].dis;
				if(!tr[edge[i].to]) q.push(make_pair(-dis[edge[i].to],edge[i].to));
			}
		}
	}
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m),read(k);
	for(ri i=1;i<=k;++i) read(u),onl[u]=1;
	for(ri i=1;i<=m;++i) read(u),read(v),read(d),add_edge(u,v,d);
	read(t1),read(t2);
	dijkstra(1,1);
	if(dis[t1]<dis[t2]) ans=dis[t1];
	else ans=dis[t2],fla=1;
	dijkstra(1,0),ans=max(ans,(fla?dis[t1]:dis[t2])),now=min(dis[t1],dis[t2]);
	dijkstra(t1,0),now+=dis[t2];
	printf("%d",ans<now?ans:now);
	return 0;
}
```

# 总结

~~无~~

---

## 作者：rediserver (赞：0)

# P4943 密室

[原题地址](https://www.luogu.org/problemnew/show/P4943)

[GitHub题解](https://github.com/jerrykcode/luogu)


## 思路

Dijkstra计算最短距离，扩展邻接点时判断该顶点是否可达(对Harry所有顶点可达，对Ron可能有顶点不可达)。

dijkstra中使用accessible数组判断顶点是否可达。

对于到达两个目的地x和y的时间有几种情况，其中最小的时间即所求答案:

* Harry到达x，Ron到达y，两者中较大的时间

* Harry到达y，Ron到达x，两者中较大的时间

* Harry一个人到达x和y，又有两种情况，取其中小的：

	* Harry先到达x再到达y

	* Harry先到达y再到达x

	在Ron存在不可达顶点，即Harry到达一个顶点的最短距离可能小于Ron到达该顶点的最短距离，这种方法可能更快

* Ron一个人到达x和y，但Ron到达一个顶点的最短距离不可能小于Harry到达该顶点的最短距离，所以这种方法不用考虑

## 代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
using namespace std;

typedef unsigned short vertex_t; //顶点类型(输入数据最大50000)
typedef unsigned short weight_t; //图的边权重类型(输入数据最大1000)
typedef unsigned int dist_t; //距离类型(边权重最大1000，但两点之间的距离可能超出65535)

//dist_t可能的最大值
#define DIST_T_INF 0xffffffff

//邻接点结构体
struct AdjNode {
	vertex_t adj_v; //邻接顶点
	weight_t adj_weight; //邻接边权重
	AdjNode(vertex_t adj_v, weight_t adj_weight) : adj_v(adj_v), adj_weight(adj_weight) {}
};

//Dijkstra
class Dijkstra {
public:
	/*
	计算最短距离
	@param graph 图
	@param n 顶点数，顶点编号0~n-1
	@param src 源
	@param des 终点
	@param accessible 数组，表示一个顶点是否可达
	@return dist_t 返回src与des之间的最短距离
	*/
	dist_t minDist(vector<AdjNode>* graph, size_t n, vertex_t src, vertex_t des, bool * accessible);

private:
	//优先队列存储的结构体
	struct PriorityNode {
		vertex_t v; //顶点
		dist_t dist; //源与v的距离
		PriorityNode(vertex_t v, dist_t dist) : v(v), dist(dist) {}

		//优先队列用于比较的结构体
		struct cmp {
			bool operator() (PriorityNode& a, PriorityNode& b) {				
				return a.dist > b.dist;
			}
		};
	};

private:
	//成员变量
	dist_t * dist_; //dist_[v]为当前src与v的最短距离
	bool * collected_; //collected_[v]表示当前v是否收录
	priority_queue<PriorityNode, vector<PriorityNode>, PriorityNode::cmp> pqueue_; //优先队列
};

dist_t Dijkstra::minDist(vector<AdjNode>* graph, size_t n, vertex_t src, vertex_t des, bool * accessible) {
	//dijkstra算法
	dist_ = new dist_t[n];
	fill(dist_, dist_ + n, DIST_T_INF); //初始化
	collected_ = new bool[n];
	fill(collected_, collected_ + n, false); //初始化
	dist_[src] = 0;
	pqueue_.push(PriorityNode(src, 0));
	vertex_t top_v, adj_v;
	dist_t tmp_dist;
	while (!pqueue_.empty()) {
		top_v = pqueue_.top().v; //当前与src距离最小的顶点出队列
		pqueue_.pop();
		if (collected_[top_v]) continue;
		collected_[top_v] = true;
		if (top_v == des) {
			//到达终点
			while (!pqueue_.empty()) pqueue_.pop();
			break;
		}
		for (auto it = graph[top_v].begin(); it != graph[top_v].end(); it++) { //遍历邻接点
			adj_v = it->adj_v; //邻接点
			if (!accessible[adj_v]) continue; //若adj_v不可达，则continue
			if (!collected_[adj_v]) { 
				//此时adj_v没被收录，即src到adj_v的最短距离还未确定
				tmp_dist = dist_[top_v] + (dist_t)it->adj_weight; //tmp_dist = src到top_v的距离 + top_v到adj_v的距离
				if (tmp_dist < dist_[adj_v]) {
					//更新
					dist_[adj_v] = tmp_dist;
					pqueue_.push(PriorityNode(adj_v, tmp_dist));
				}
			}
		} //for
	} //while
	//若src不可达des，则dist_[des]为DIST_T_INF
	dist_t result = dist_[des];
	//释放内存
	free(dist_);
	free(collected_);
	return result;
}

int main() {
	int n, m, k;
	scanf("%d %d %d", &n, &m, &k);	
	bool * accessible = new bool[n];
	//初始化所有顶点可达
	fill(accessible, accessible + n, true);
	size_t i;
	if (k) {
		int room;
		for (i = 0; i < k; i++) {
			scanf("%d", &room);
			//该顶点(房间)仅Harry可达，对Ron来说不可达
			//输入顶点编号为 1~n，改为0~n-1
			accessible[room - 1] = false;
		}
	}
	vector<AdjNode> * graph = new vector<AdjNode>[n];
	int a, b, c;
	for (i = 0; i < m; i++) {
		//插入边
		scanf("%d %d %d", &a, &b, &c);
		a--; b--; //顶点编号改为从0开始		
		graph[a].push_back(AdjNode((vertex_t)b, (weight_t)c));
		graph[b].push_back(AdjNode((vertex_t)a, (weight_t)c));
	}	
	scanf("%d %d", &a, &b);
	//des_x和des_y为需要到达的两个目的地
	vertex_t des_x = a - 1, des_y = b - 1; //编号改为从0开始
	Dijkstra dijkstra;
	//先计算Ron到达des_x与des_y的最短距离，因为此时accessible中Ron不可达的顶点已经标记为false了
	dist_t ron_x = dijkstra.minDist(graph, n, 0, des_x, accessible); //Ron到达des_x的最短距离(时间)
	dist_t ron_y = dijkstra.minDist(graph, n, 0, des_y, accessible); //Ron到达des_y的最短距离(时间)
	dist_t harry_x, harry_y, harry_x_y;
	if (k) { //若存在只能Harry走的顶点
		fill(accessible, accessible + n, true); //所有顶点Harry均可达
		harry_x = dijkstra.minDist(graph, n, 0, des_x, accessible); //Harry到达des_x的最短距离(时间)
		harry_y = dijkstra.minDist(graph, n, 0, des_y, accessible); //Harry到达des_y的最短距离(时间)
		harry_x_y = dijkstra.minDist(graph, n, des_x, des_y, accessible); //Harry从x走到y的最短距离(时间)
	}
	else { //若不存在只能Harry走的顶点
		//所有顶点Harry与Ron都可达，Harry到达任意一个顶点的最短距离与Ron到达该顶点的最短距离相同
		harry_x = ron_x;
		harry_y = ron_y;
	}
	dist_t result = DIST_T_INF; //结果
	result = min(result, max(harry_x, ron_y)); //Harry去des_x, Ron去des_y
	result = min(result, max(harry_y, ron_x)); //Harry去des_y, Ron去des_x
	if (k) {
		//des_x，des_y都由Harry一个人去，
		//(Harry先到des_x再到des_y或者先到des_y再到des_x)
		//在存在只有Harry可达的顶点时，这种方式才可能更快
		result = min(result, min(harry_x + harry_x_y, harry_y + harry_x_y));
	}
	printf("%u", result);
	free(accessible);
	for (i = 0; i < n; i++)
		vector<AdjNode>().swap(graph[i]);
	return 0;
}
```

---

## 作者：CR_Raphael (赞：0)

模版题

很明显，由于哈利恒快与罗恩：

哈利->x->y

哈利->y->x

哈利->x同时罗恩->y

哈利->同时罗恩->x

别忘了无向边开两倍空间，别打错字母尤其是i，别把数组开小

嗯，沉迷文化课的我就是这样做错水题的。

相信不少语文水平跟我差不多人有一个疑惑：为什么不能让哈利解锁房间，罗恩和哈利一起走一段再分开？（这样#2会WA）

因为题面描述是：

 _某些小室只有会与蛇对话的人才能进入，只有哈利**一个人**可以**进入**_ 

而不是：

 _某些小室只有会与蛇对话的人才能打开，只有哈利可以**打开**_ 
 
 所以哈利不能带罗恩飞，有扫帚也不行。

代码（最短路模版题）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<vector>
#define dist dis[aa] 
#define p2 pair<int, int> 
#define f1 first 
#define f2 second 
#define mp make_pair 
using namespace std;

const int maxn = 50005;
const int maxm = 2*100005;
int n, m, k, x, y;
priority_queue < p2, vector<p2>, greater<p2> > q;

struct graph {
	int tm, to[maxm], nex[maxm], st[maxn], l[maxm];
	int bothg[maxn];
	int dis[10][maxn];
	void cle() {
		memset(to, 0, sizeof(to));
		memset(nex, 0, sizeof(nex));
		memset(st, 0, sizeof(st));
		memset(l, 0, sizeof(l));
		memset(bothg, 0, sizeof(bothg));
		memset(dis, 0x3f, sizeof(dis));
	}
	void adde(int a, int b, int c) {
		tm++;
		nex[tm]=st[a];
		l[tm]=c;
		to[tm]=b;
		st[a]=tm;
		
		tm++;
		nex[tm]=st[b];
		l[tm]=c;
		to[tm]=a;
		st[b]=tm;
	}
	void HP(int a) {
		int i, ti;
		for(i=1; i <= a; i++) {
			scanf("%d", &ti);
			bothg[ti]=1;
		}
		for(i=1; i <= n; i++) bothg[i]=(!bothg[i]);
		return;
	}
	void count(int stt, int aa, int hc) {
		dist[stt]=0;
	//cout<<q.size()<<' '<<q.empty()<<endl;
	//cout<<q.size()<<' ';
	//cout<<q.empty()<<endl;
	//if(!q.empty())cout<<q.top().f1<<' ';
	//if(!q.empty()) cout<<867<<endl;
		while(!q.empty()) q.pop();
		int i, a, b, cc, ti=0;
		q.push(mp(0, stt));
		//cout<<aa<<endl;
		while(!q.empty()) {
			ti++;
			if(ti > n) break;
			cc=q.top().f1;
			a=q.top().f2;
			q.pop();
			for(i=st[a]; i != 0; i=nex[i]) {
				b=to[i];
				if(hc || bothg[b]){
					if(dist[b] > cc+l[i])
						dist[b]=cc+l[i], q.push(mp(dist[b], b));
				}
			}
		}
		//for(i-1; i <= n; i++) cout<<bothg[i]<<' '; cout<<endl;
		//for(i=1; i <= n; i++) if(dist[i] != 0x3f3f3f3f) cout<<dist[i]<<' '; else cout<<'*'<<' ';
		//cout<<endl;
		return;
	}
} G;

int main() {
	int i, a, b, c, ans=0x7fffffff;
	G.cle();
	scanf("%d%d%d", &n, &m, &k);
	G.HP(k);
	for(i=1; i <= m; i++) {
		scanf("%d%d%d", &a, &b, &c);
		G.adde(a, b, c);
	}
	scanf("%d%d", &x, &y);
	G.count(1, 1, 0);
	G.count(1, 2, 1);
	G.count(x, 3, 0);
	G.count(x, 4, 1);
	G.count(y, 5, 0);
	G.count(y, 6, 1);
	//for(i=1; i <= n; i++) {
		//ans=min(ans, G.dis[2][i]+max(G.dis[4][i],G.dis[5][i]));
		//ans=min(ans, G.dis[2][i]+max(G.dis[6][i],G.dis[3][i]));
	//printf("%d\n", ans);
	//}
	ans=min(ans, max(G.dis[1][x],G.dis[2][y]));
	ans=min(ans, max(G.dis[2][x],G.dis[1][y]));
	ans=min(ans, G.dis[2][x]+G.dis[4][y]);
	ans=min(ans, G.dis[2][y]+G.dis[6][x]);
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：Mathison (赞：0)

[题目传送门](https://www.luogu.org/problemnew/show/P4943)

题意见传送门

【分析】

设两个终点为 $x,y$，则

欲求到达终点的最短时间，我们有四种走法：

$\text{Harry}:1\rightarrow x,\ \text{Ron}:1\rightarrow y$

$\text{Harry}:1\rightarrow y,\ \text{Ron}:1\rightarrow x$

$\text{Harry}:1\rightarrow x\rightarrow y$

$\text{Harry}:1\rightarrow y\rightarrow x$ 

所以我们跑 $4$ 遍$\ \text{dijkstra}$，分别记录上述的六条路径的最短路

注意$\text{Harry}$和$\text{Ron}$同时走的时候**最短用时**是他们**两人用时的最大值**

下面是AC代码，那个答案变量的**命名规则**是人（$a$表示$\text{Harry}$，$b$表示$\text{Ron}$）+起点+终点
```
#include<bits/stdc++.h>
using namespace std;
const int N=50010,M=200100;
int n,m,k,ed1,ed2,tot,dis[N],nxt[M],head[N],edge[M],ver[M];
int ans1=2e9,ans2=2e9,a1x,a1y,b1x,b1y,axy,ayx;
bool vis[N],flag[N];
priority_queue<pair<int,int> > q;
void add(int x,int y,int z)
{
	ver[++tot]=y;
	edge[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot;
}
void dij(int st,int ju)//ju判断两人，0为Ron，1为Harry
{
	for(int i=1;i<=n;i++) dis[i]=2e9;
	memset(vis,0,sizeof vis);
	dis[st]=0;
	q.push(make_pair(0,st));
	while(q.size())
	{
		int x=q.top().second;q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=ver[i],z=edge[i];
			if(!ju&&flag[x]) continue;//Ron不能走只能Harry走的点
			if(dis[y]>dis[x]+z)
			{
				dis[y]=dis[x]+z;
				q.push(make_pair(-dis[y],y));
			}
		}
	}
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=k;i++)
    {
    	int x;
    	scanf("%d",&x);
    	flag[x]=1;
	}
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	scanf("%d%d",&ed1,&ed2);//两个终点
	dij(1,1); a1x=dis[ed1],a1y=dis[ed2];
	dij(1,0); b1x=dis[ed1],b1y=dis[ed2];
	ans1=min(max(a1x,b1y),max(a1y,b1x));//两人走
	dij(ed1,1); axy=dis[ed2];
	dij(ed2,1); ayx=dis[ed1];
	ans2=min(a1x+axy,a1y+ayx);//只有Harry走
	printf("%d\n",min(ans1,ans2));//取最优
	return 0;
}

```

---

## 作者：02XXX (赞：0)

思路：跑四遍（spfa没炸我也很奇怪233）

我用空间换时间，到时候记录就行了

记着四种是：
           
           1.&2.罗恩一条路，哈利一条路

           3.&4.哈利走两条路

代码应该很好理解，因为我太弱233


```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define maxn 50005 
using namespace std;
inline int read()//愉悦的快读
{
	char c=getchar();
	int w=0,f=1;
	while(c<'0'||c>'9') {if(c=='-') f=-1; c=getchar();}
    while(c>='0'&&c<='9') { w=(w<<3)+(w<<1)+c-'0'; c=getchar();}
    return w*f;
}
struct E{
	int to,next,w;
}edge[100001<<1];//邻接矩阵标程
int head[maxn],cnt,t1[3],t2[3],ans,t;
bool pan[maxn],vis1[maxn],vis2[maxn];
inline void add(int u,int v,int w)
{
	edge[++cnt].next=head[u];
	edge[cnt].to=v;
	edge[cnt].w=w;
	head[u]=cnt;
}
int n,m,k,tot;
int a,b,c;
int x,y,dis1[maxn],dis2[maxn];//空间战
queue <int> q1,q2;
void dij(int now)
{
	for(int i=1;i<=n;i++)
	{
	  dis1[i]=21474360;
	}
	q1.push(now);
	dis1[now]=0;
	vis1[now]=true;
	while(!q1.empty())
	{
		int u=q1.front();
		q1.pop();
		vis1[u]=0;
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(pan[v]) continue;
			if(dis1[v]>dis1[u]+edge[i].w)
			{
			  dis1[v]=dis1[u]+edge[i].w;
			  	//cout<<dis1[v]<<" "<<v<<endl;
			   if(!vis1[v]) {
				q1.push(v);
				vis1[v]=true;
			    }
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
	  dis2[i]=21474360;
	}
	q2.push(now);
	vis2[now]=true;
	dis2[now]=0;
	while(!q2.empty())
	{
		int u=q2.front();
		q2.pop();
		vis2[u]=0;
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dis2[v]>dis2[u]+edge[i].w)
			{
				//cout<<"pp"<<v<<endl;
			  dis2[v]=dis2[u]+edge[i].w;
			   if(!vis2[v])
			  {
				//cout<<now<<"ppp"<<v<<" "<<dis2[v]<<" "<<edge[i].w<<endl;
				q2.push(v);
				vis2[v]=true;
			  }
			}
		}
	}
	t2[++tot]=dis2[1];t1[tot]=dis1[1];
}
int main()
{
	n=read(),m=read(),k=read();
	for(int i=1;i<=k;i++)
	{
		int g=read();
	  pan[g]=1;
    }
	for(int i=1;i<=m;i++)
	{
		a=read(),b=read(),c=read();
		add(a,b,c);
		add(b,a,c);
	}
	x=read(),y=read();
	dij(x);//从目标点反跑
	int ans1=dis2[1]+dis2[y];//情况三
	memset(vis1,0,sizeof(vis1));
	memset(vis2,0,sizeof(vis2));//每次清除掉
	dij(y);
	int ans2=dis2[1]+dis2[x];//情况四
	//cout<<t1[1]<<" "<<t2[1]<<" "<<t1[2]<<" "<<t2[2]<<endl;
	ans=min(max(t1[1],t2[2]),max(t1[2],t2[1]));//找出情况一、二中最小值
	//cout<<ans<<" "<<dis2[1]<<" "<<dis2[x]<<endl;
	ans=min(ans,ans2);
	ans=min(ans,ans1);
	cout<<ans;//答案
	return 0;
}

```

另外，打好模板真的很重要，我就因为没加q.pop()卡了好长时间了...

---

## 作者：顾z (赞：0)



# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

表示第一眼看到题是个水题. emmm

结果发现自己错了.

然后突然发现不卡数组,不卡时间.

~~于是我就跑了6遍正常人都是跑4遍的~~

这题坑点在于会存在4种情况

1. 哈利到$x$,罗恩到$y$
2. 哈利到$y$.罗恩到$x$
3. 哈利不动,罗恩走遍$x,y$
4. 罗恩不动,哈利走遍$x,y$

蒟蒻表示只考虑到了前两种.

还是大佬[@_王小呆](https://www.cnblogs.com/wangxiaodai/)强啊  orz

然后就跑$6$遍$dijkstra$!

还改了好久的 qwq

``代码``

```c++
#include<cstdio>
#include<algorithm>
#include<queue>
#include<iostream>
#define int long long 
#define R register
#define N 50008

using namespace std;

inline void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}

int n,m,k;

int head[N],tot,a,b;
int dis[N],diss[N],disss[N],dissss[N];
int ans1,ans2,ans3,ans4,ans5,ans6;
int ans7,ans8,ans=21474836476666666LL;
struct cod{int u,v,w;}edge[N<<2];
struct hop
{
	int u,d;
	bool operator <(const hop&a)const
	{
		return d>a.d;
	}
};
bool vis[N],ok[N];

inline void add(int x,int y,int z)
{
	edge[++tot].u=head[x];
	edge[tot].v=y;
	edge[tot].w=z;
	head[x]=tot;
}

inline void dij(int s,int ds[],bool flg)
{
	for(R int i=1;i<=n;i++)ds[i]=21474836476666LL,vis[i]=false;
	priority_queue<hop>q;
	q.push((hop){s,0});ds[s]=0;
	while(!q.empty())
	{
		int u=q.top().u;q.pop();
		if(vis[u])continue;
		vis[u]=true;
		for(R int i=head[u];i;i=edge[i].u)
		{
			if(ok[edge[i].v] and !flg)continue;
			if(!vis[edge[i].v] and ds[edge[i].v]>ds[u]+edge[i].w)
			{
				ds[edge[i].v]=ds[u]+edge[i].w;
				q.push((hop){edge[i].v,ds[edge[i].v]});
			}
		}
	}
}
signed main()
{
	in(n),in(m),in(k);
	for(R int i=1,x;i<=k;i++)in(x),ok[x]=true;
	for(R int i=1,x,y,z;i<=m;i++)
	{
		in(x),in(y),in(z);
		add(x,y,z);add(y,x,z);
	}
	in(a),in(b);
	dij(1,dis,1);//哈利.
	dij(1,diss,0);
	ans1=dis[a],ans2=dis[b];
	ans3=diss[a],ans4=diss[b];
	
	ans=min(ans,max(ans3,ans2));
	ans=min(ans,max(ans1,ans4));
	
		
	dij(a,disss,1);//哈利
	dij(a,dissss,0);	
	ans5=disss[b],ans6=dissss[b];
	ans=min(ans,min(ans1+ans5,ans3+ans6));
		
	dij(b,disss,1);//哈利
	dij(b,dissss,0);
	
	ans7=disss[a],ans8=dissss[a];
	ans=min(ans,min(ans2+ans7,ans4+ans8));
	
	printf("%lld",ans);
}
```


---


# [传智杯 #2 决赛] 传送门

## 题目描述

传智专修学院里有 $n$ 栋教学楼，有 $m$ 条双向通行道路连接这些教学楼，不存在重边和自环。每条道路都有一定的长度，而且所有教学楼之间都可以直接或者间接的通过道路到达。我们可以很容易的求出这些教学楼之间的最短路。

为了使交通更为顺畅，校方决定在两个教学楼里增设一对传送门。传送门可以将这对教学楼的距离直接缩短为 0。利用传送门，某些教学楼之间的最短路的距离就变短了。

由于预算有限，学校里只能安装一对传送门。但是校长希望尽可能方便学生，使任意两点之间的最短路长度的总和最小。当然啦，从 $x$ 教学楼到 $y$ 教学楼的长度和从 $y$ 教学楼到 $x$ 教学楼的长度只需要统计一次就可以了。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/2mjfn32x.png)

样例如图。当在 1 和 4 号教学楼架设一对传送门时，1 → 2 的最短路是 3，1 → 3 的最短路是 0+2，1 → 4 的最短路是 0，2 → 3 的最短路是 4，2 → 4 的最短路是 3+0，3 → 4 的最短路是 2，最短路之和是 14，是最佳方案。

## 样例 #1

### 输入

```
4 5
1 2 3
1 3 6
2 3 4
2 4 7
3 4 2
```

### 输出

```
14```

# 题解

## 作者：_Fontainebleau_ (赞：39)

期末考前一天发题解求 $rp$ 。

这道题一看数据范围 $n≤100$ 。暴力石锤了。

很容易想到 $Floyd$ 。

先算未建传送门时的最短路。接着两所学校两所学校枚举，求建传送门的最优方案。

要开两个数组，
```cpp
int f[101][101];
int F[101][101];
```
$f[i][j]$ 表示未建传送门时的 $i$ 到 $j$ 的最短路。

$F[i][j]$ 表示建了传送门之后 $i$ 到 $j$ 的最短路。

改上代码了~

```cpp
#include<bits/stdc++.h>
#define FOR(i,j,k)  for(int i=(j);i<=(k);i++)
using namespace std;
int n,m;
int f[101][101];
int F[101][101];
inline void back()
{
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			F[i][j]=f[i][j];
}
int main()
{
	scanf("%d%d",&n,&m);
	memset(f,-1,sizeof(f));
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		if(f[u][v]==-1||f[u][v]>w)	f[u][v]=f[v][u]=w;//建边，防重边（不过数据里没有）
	}
	for(int k=1;k<=n;k++)	
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				if(f[i][k]!=-1&&f[k][j]!=-1)
					if(f[i][j]==-1||f[i][j]>f[k][j]+f[i][k])
						f[i][j]=f[i][k]+f[k][j];//Floyd
	int ans=2e9;//较大值
	for(int i=1;i<=n;i++)	
		for(int j=1;j<=n;j++)//暴力枚举
		{
			back();//先让F数组还原成f数组
			F[i][j]=F[j][i]=0;//在教学楼 i 和 j 之间建立传送门
			for(int x=1;x<=n;x++)	
				for(int y=1;y<=n;y++)	
					if(F[x][y]==-1||F[x][y]>F[x][i]+F[i][y])
						F[x][y]=F[x][i]+F[i][y];//Floyd
			for(int x=1;x<=n;x++)
				for(int y=1;y<=n;y++)	
					if(F[x][y]==-1||F[x][y]>F[x][j]+F[j][y])
						F[x][y]=F[x][j]+F[j][y];//Floyd
			int res=0;
			for(int x=1;x<=n;x++)	
				for(int y=1;y<x;y++)
					res+=F[x][y];
			ans=min(res,ans);
		}
	printf("%d\n",ans);
	return 0;
}
```
为什么这里 $↓$ 要这么算呢
```cpp
			for(int x=1;x<=n;x++)	
				for(int y=1;y<=n;y++)	
					if(F[x][y]==-1||F[x][y]>F[x][i]+F[i][y])
						F[x][y]=F[x][i]+F[i][y];
			for(int x=1;x<=n;x++)
				for(int y=1;y<=n;y++)	
					if(F[x][y]==-1||F[x][y]>F[x][j]+F[j][y])
						F[x][y]=F[x][j]+F[j][y];
```

因为建立了传送门，只有使用传送门才会影响当前最短路。


------------
$❀$ **完结撒花** $❀$

---

## 作者：xhQYm (赞：25)

- 题目链接：[P6464 传送门](https://www.luogu.com.cn/problem/P6464)



这题一看是求的是**最短道路之和**，很容易想到全源最短路算法`Floyd`。

首先，学过`Floyd`的人都可以想到这题的最朴素做法。怎么做呢？

就是先双重循环枚举要改变的一条边，之后再三重循环做`Floyd`。

但是，这样做的世界复杂度是 $O(n^5)$ ，对于 $n=100$ 的数据难以容忍。

那么怎么优化呢？

你可以发现，每次改变**一条边**就给整个图做一次`Floyd`太浪费时间了，我们只需要把跟那条边有关系的做一下`Floyd`，就是用前两层循环的参数 $i,j$ 当作中转点 $k$ 做一次`Floyd`即可，这样就可以省去枚举中转点 $k$ 的时间了。

这个方法的时间复杂度为 $O(n^4)$ ，对于 $n=100$ 的数据可以刚好卡过时间线。



那么我们就愉快的写出代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int n,m;
int g[N][N];
int f[N][N];
void init()
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            g[i][j]=f[i][j];
}//重新赋值
int main()  
{
    cin>>n>>m;
    memset(g,0x3f,sizeof g);
    while(m--)
    {
        int a,b,w;
        cin>>a>>b>>w;
        g[a][b]=g[b][a]=w;
    }  
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            {
                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
                f[i][j]=g[i][j];
            }//先做一遍floyd
    int ans=2e9;//赋值很大的一个数
    for(int i=1;i<=n;i++)
        for(int j=1;j<i;j++)
        {
            g[i][j]=g[j][i]=0;
            for(int k1=1;k1<=n;k1++)
                for(int k2=1;k2<=n;k2++)
                    g[k1][k2]=min(g[k1][k2],g[k1][i]+g[i][k2]);
            for(int k1=1;k1<=n;k1++)
                for(int k2=1;k2<=n;k2++)
                    g[k1][k2]=min(g[k1][k2],g[k1][j]+g[j][k2]);
                    //做floyd
            int res=0;
            for(int k1=1;k1<=n;k1++)
                for(int k2=1;k2<k1;k2++)
                    res+=g[k1][k2];//求和
            ans=min(ans,res);
            init();
        }
    cout<<ans;
    return 0;
}
```



如果还有疑问或者发现文章错误，欢迎私信或者评论区提问或指出！

---

## 作者：Mars_Dingdang (赞：23)

这数据范围显然是 Floyd 裸题啊啊啊。
## 题目大意
传智专修学院里有 $n$ 栋教学楼，有 $m$ 条**双向通行道路**连接这些教学楼，**不存在重边和自环**。每条道路都有一定的长度，而且所有教学楼之间都可以直接或者间接的通过道路到达。我们可以很容易的求出这些教学楼之间的最短路。

为了使交通更为顺畅，校方决定在两个教学楼里增设一对传送门。传送门可以将这对教学楼的距离直接缩短为 $0$。利用传送门，某些教学楼之间的最短路的距离就变短了。

由于预算有限，学校里只能安装**一对**传送门。但是校长希望尽可能方便学生，**使任意两点之间的最短路长度的总和最小**。当然啦，从 $x$ 教学楼到 $y$ 教学楼的长度和从 $y$ 教学楼到 $x$ 教学楼的长度只需要统计一次就可以了。

## 大体思路

给定一个各个点相互联通的无向图，我们可以选择在这个无向图中的两点假设一个传送门，使这两个点的距离变为 $0$，当这两个点的距离为 $0$ 之后，这样就有可能影响其他点对点之间的最短距离，问我在任意点对之间架设一个传送门之后，任意点对之间的最短路距离之和最小为多少。

这一题，题目已经给了提示，任意点对，能求任意点对点之间的最短距离只有 floyd 算法了（[全源最短路](https://www.luogu.com.cn/problem/P5905)），用 floyd 跑完多元最短路之后 $O(n^3)$，剩下就是暴力枚举。

任意一个点对设为 $(i,j)$ 在这个点对上架设传送门,这里复杂度为 $O(n^2)$，在假设个传送门之后，我们考虑，除了 $(i,j)$ 点对之外，枚举其他点对设为 $(a,b)$ ，这里复杂度为 $O(n^2)$，会收到这个传送门的什么影响呢？设一个点 $x,y$ 在跑完 floyd 之后对最短路距离为 `dp[x][y] == dp[y][x]`，考虑如果 $a$ 到 $b$ 点最短路不经过 $(i,j)$ 这一边的话，那么 $a$ 到 $b$ 之间的最短路距离是不会被影响的，反之如果经过了 $(i,j)$ 这条路的化（经过的情况可以是 $a\to i\to j\to b$、$a\to j\to i\to b$），那么 $a$ 到 $b$ 之间的距离肯定会被影响，这个时候 $a$ 到 $b$ 之间的最短路距离是 $\min\left\{dp(a,b),\min( dp(a,i) + dp(j,b), dp(a,j) + dp(i,b))\right\}$。

## 完整代码
```cpp
#include<bits/stdc++.h>
const int INF = 0x3f3f3f3f;
using namespace std;
const int maxn = 1e105;
int dp[maxn][maxn];//抄袭有奖qaq
int main(){
    int n, m; 
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            if(i == j) dp[i][j] = 0;
            else dp[i][j] = INF;
    int u, v, w;
    for(int i = 0; i < m; i ++)
    {
        scanf("%d %d %d", &u, &v, &w);
        //建立双向边
        dp[u][v] = w;
        dp[v][u] = w;
    }
    //floyd 算法
    for(int k = 1; k <= n; k ++)
        for(int i = 1; i <= n; i ++)
            for(int j = 1; j <= n; j ++)
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
     
    //假设假设建立传送门的点对为（i，j）(默认j > i)，枚举减少的距离任意一个点对点（a, b）（这里默认b > a）距离为
    int ans = INF, res;
    for(int i = 1; i < n; i ++)
        for(int j = i + 1; j <= n; j ++)
        {
            res = 0;
            for(int a = 1; a < n; a ++)
                for(int b = a + 1; b <= n; b ++)
                    if(a != i || b != j)
                        res += min(dp[a][b], min(dp[a][i] + dp[j][b], dp[a][j] + dp[i][b]));     
            ans = min(ans, res);
        }
    printf("%d\n", ans);
    return 0;
}
```
题目来源：第二届“传智杯”全国大学生 IT 技能大赛（决赛）。

---

## 作者：银杉水杉秃杉 (赞：20)

朋友们好啊！

既然题目叫做传送门，那我们先放一个传送门

[题目传送门 P6464 传送门 ](https://www.luogu.com.cn/problem/P6464)

题目就不过多阐释了，这是一道非常有趣的最短路问题

先考虑一下数据范围。哇，$n≤100$诶，然后我啪就打了一个非常暴力的$Floyd$，很快啊！

这里先说明一下：

$f[i][j]$表示没有传送门时的$i$到$j$的最短路。

$g[i][j]$表示有了传送门之后$i$到$j$的最短路。

主要内容如下：

```cpp
	for (int k=1;k<=n;k++)//标准Floyd
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++)
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	ans=1e9;
	for (int k=1;k<=n;k++)
		for (int l=k+1;l<=n;l++)
		{
			for (int i=1;i<=n;i++)
				for (int j=1;j<=n;j++)
					g[i][j]=f[i][j];
			g[k][l]=g[l][k]=0;
			for (int m=1;m<=n;m++)//每更新一次传送门就跑一次Floyd
				for (int i=1;i<=n;i++)
					for (int j=1;j<=n;j++)
						g[i][j]=min(g[i][j],g[i][m]+g[m][j]); 
			sum=0;
			for (int i=1;i<=n;i++)
				for (int j=i+1;j<=n;j++)
					sum+=g[i][j];
			ans=min(ans,sum);	
		}
```


这段代码时间复杂度为$O(n^5)$，这是肯定要爆的，说明需要优化将复杂度优化为$O(n^4)$。那么该如何优化呢？

我们发现在每次更改传送门后不断在重复做$Floyd$，每个点都要当作一次中转点$m$，效率低下。既然每一次变化只改变了$k$和$l$之间的距离，我们只需要分别将$k$和$l$作为中转点来做$Floyd$。于是复杂度直接降为$O(n^4)$，完全可以AC了。

具体内容如下：

```cpp
	for (int k=1;k<=n;k++)
		for (int l=k+1;l<=n;l++)
		{
			for (int i=1;i<=n;i++)
				for (int j=1;j<=n;j++)
					g[i][j]=f[i][j];
			g[k][l]=g[l][k]=0;
			for (int i=1;i<=n;i++)
				for (int j=1;j<=n;j++)
					g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
			for (int i=1;i<=n;i++)
				for (int j=1;j<=n;j++)
					g[i][j]=min(g[i][j],g[i][l]+g[l][j]);
			sum=0;
			for (int i=1;i<=n;i++)
				for (int j=i+1;j<=n;j++)
					sum+=g[i][j];
			ans=min(ans,sum);	
		}
```

完整代码（AC Code）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum,ans;
int f[110][110],g[110][110];
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)//初始化
		for (int j=1;j<=n;j++)
			if (i==j)
				f[i][j]=0;
			else
				f[i][j]=1e9;//最大值记得开大一点
	for (int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		f[u][v]=f[v][u]=w;//双向建边
	}
	for (int k=1;k<=n;k++)//无传送门时的最短路f数组
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++)
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	ans=1e9;
	for (int k=1;k<=n;k++)
		for (int l=k+1;l<=n;l++)
		{
			for (int i=1;i<=n;i++)//注意：每次更新传送门都要重置g数组
				for (int j=1;j<=n;j++)
					g[i][j]=f[i][j];
			g[k][l]=g[l][k]=0;
			for (int i=1;i<=n;i++)//k作为中转点
				for (int j=1;j<=n;j++)
					g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
			for (int i=1;i<=n;i++)//l作为中转点
				for (int j=1;j<=n;j++)
					g[i][j]=min(g[i][j],g[i][l]+g[l][j]);
			sum=0;
			for (int i=1;i<=n;i++)//求边和
				for (int j=i+1;j<=n;j++)
					sum+=g[i][j];
			ans=min(ans,sum);//更新最小值	
		}
	cout<<ans<<endl;
	return 0;
}
```

好了，这道题就到这儿了（点到为止）

谢谢朋友们！

---

## 作者：Bitter_Tea (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P6464)

今天找最短路的题，发现了这道题:~~这不就是洛谷初赛模拟的真题吗！！！~~

基本思路就是$Floyd$

因为n最多只有$100$，~~我们发现我们再怎么跑也不会超时~~

我们只需要预处理出每两个点之间的距离。然后我们$n^2$枚举传送门的位置即可。

对于传送门的位置$x$、$y$，我们就如同$Floyd$一样把它们当做中间节点，进行更新即可，因为我们选择传送门不会对其他的最短路产生影响


$code$
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int N=105,inf=2147483647;
int d[N][N],f[N][N];
int n,m,ans;
void solve(int i,int j) 
{
	int dis=0;
	for(int x=1; x<=n; x++)
		for(int y=1; y<=n; y++)
			f[x][y]=d[x][y];
	f[i][j]=f[j][i]=0;
	for(int x=1; x<=n; x++)
		for(int y=1; y<=n; y++)
			f[x][y]=min(f[x][y],f[x][i]+f[i][y]);
	for(int x=1; x<=n; x++)
		for(int y=1; y<=n; y++)
			f[x][y]=min(f[x][y],f[x][j]+f[j][y]);
	for(int x=1; x<=n; x++)
		for(int y=x+1; y<=n; y++)
			dis+=f[x][y];
	if(dis<ans) ans=dis;
}
int main() 
{
	scanf("%d%d",&n,&m);
	memset(d,0x3f,sizeof(d));
	for(int i=1; i<=n; i++) d[i][i]=0;
	for(int i=1; i<=m; i++) 
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		d[x][y]=d[y][x]=z;
	}
	for(int k=1; k<=n; k++)
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
	ans=inf;
	for(int i=1; i<=n; i++)
		for(int j=i+1; j<=n; j++)
			solve(i,j);
	printf("%d\n",ans);
	return 0;
}
```
^-^，谢谢大家



---

## 作者：simonG (赞：7)

#### [传送门](https://www.luogu.com.cn/problem/P6464)
### 前言
floyd算法本质是动态规划，但是时间复杂度为$O(n^3)$。但同时，floyd的优点是，一次跑图就可以求出所有点之间的最短路，大大减少了代码复杂度。
### 详解
>1,存图，使用邻接矩阵（不做解释）且不存在重边与子环。传送门的建设，即把两点之间距离设为$0$。

>2,最短路，使用floyd算法。（$n<=100,n^3<=1000000$其实，使用dijkstra和（SPfa）也行。）  
状态转移方程为$dp[j][k]=min(dp[j][k],dp[j][i]+dp[i][k]);$

>3,建设传送门，即每条边都枚举一遍，依次求出最小值，再求出最终答案即可。这是一道非常有趣的最短路问题！！！

### 代码
```cpp
#include<bits/stdc++.h>
#define inf 999999999
#define ll long long
using namespace std;
ll dp[105][105];
ll n,m;
void floyed()
{
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
			for(ll k=1;k<=n;k++)
				dp[j][k]=min(dp[j][k],dp[j][i]+dp[i][k]);
	return ;
}
int main()
{
	cin>>n>>m;
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
			if(i==j) dp[i][j]=0;
			else dp[i][j]=inf;
	for(register int i=1;i<=m;i++)
	{
		ll x,y,w;
		cin>>x>>y>>w;
		dp[x][y]=dp[y][x]=w;
	}
	floyed();
	ll t=0,ans=inf;
	for(register int i=1;i<n;i++)
		for(register int j=i+1;j<=n;j++)
		{
			t=0;
			for(ll k=1;k<n;k++)
				for(ll l=k+1;l<=n;l++)
					if(i!=k||j!=l)
						t+=min(dp[k][l],min(dp[k][i]+dp[j][l],dp[k][j]+dp[i][l]));
			ans=min(ans,t);
		}
	cout<<ans<<endl;
	return 0;
}
```
### 后记
floyd是个好算法！！！

---

## 作者：y0y68 (赞：6)

特简单的 $\texttt{floyd}$

--------------

首先用 $\texttt{floyd}$ 算好没安装传送门的最短路，然后枚举任意两个教学楼，求出在这两个教学楼之间安装传送门的最短路之和，再与最小值比较就可以了，于是轻松写出了时间复杂度为 $O(N^5)$ 的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,dis[105][105],tmp[105][105];
//tmp用来记录没安装传送门的最短路，因为dis会在枚举安装的传送门是改变
int main(){
	cin>>n>>m;
	memset(dis,0x3f,sizeof dis);
	//两点距离初始化最大值
	for(int u,v,w;m;m--){
		scanf("%d%d%d",&u,&v,&w);
		dis[u][v]=dis[v][u]=w;//注意双向边
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]),tmp[i][j]=dis[i][j];//floyd模板，要保存tmp
	int mn=-1u/2;//-1u/2为int类型最大值
	for(int u=1;u<=n;u++)
		for(int v=1;v<u;v++){
			int s=0;
			dis[u][v]=dis[v][u]=0;//安装传送门的两个教学楼之间距离为0
			for(int k=1;k<=n;k++)
				for(int i=1;i<=n;i++)
					for(int j=1;j<=n;j++)
						dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
			for(int i=1;i<=n;i++)
				for(int j=1;j<i;j++)
					s+=dis[i][j];//算最短路总和
			mn=min(mn,s);
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					dis[i][j]=tmp[i][j];//要恢复
		}
	cout<<mn<<endl;
	return 0;
}
```

由于 $n \le 100$ ，$\texttt{TLE}$ 是必定的，得优化一下。

注意到安装传送门时，只修改了一条边的权值，所以在 $\texttt{floyd}$ 中不用枚举中间量 $k$ ，只需让 $k$ 为 $u,v$ 就行了。

$\texttt{AC}$ 无注释代码上场 （请别抄）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,dis[105][105],tmp[105][105];
int main(){
	cin>>n>>m;
	memset(dis,0x3f,sizeof dis);
	for(int u,v,w;m;m--){
		scanf("%d%d%d",&u,&v,&w);
		dis[u][v]=dis[v][u]=w;
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]),tmp[i][j]=dis[i][j];
	int mn=-1u/2;
	for(int u=1;u<=n;u++)
		for(int v=1;v<u;v++){
			int s=0;
			dis[u][v]=dis[v][u]=0;
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					dis[i][j]=min(dis[i][j],dis[i][u]+dis[u][j]);
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					dis[i][j]=min(dis[i][j],dis[i][v]+dis[v][j]);
			for(int i=1;i<=n;i++)
				for(int j=1;j<i;j++)
					s+=dis[i][j];
			mn=min(mn,s);
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					dis[i][j]=tmp[i][j];
		}
	cout<<mn<<endl;
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：4)

# 思路
枚举所有点对，建传送门，跑最短路，累加。

~~显然这样会 TLE~~，所以尝试优化求最短路的过程。

我们发现，建传送门只改变了一条边，整张图上的其他边没有变化。

所以我们用 floyd，让 k 分别赋值传送门的两个点。

这样在 relax 时只会考虑与 k 有关的边。

其他边和传送门无关，relax 后也不会改变最短路

可以只在开始时把整张图 floyd 一遍
# 代码
```cpp
//只有k = a或k = b时路径会变(其他的不变)
#include <iostream>
#include <cstring>
#include <limits.h>
using namespace std;
int map[101][101], smap[101][101], n, m, minn(INT_MAX);//一个大数
int main()
{
	ios::sync_with_stdio(0);
	cin >> n >> m;
	memset(map, 0x3f, sizeof map); //把所有路径改成无限
	for(register int i(1);i <= m;++i)
	{
		int a, b, c;cin >> a >> b >> c;
		map[a][b] = c;map[b][a] = c;//存图
	}
	for(int k(1);k <= n;++k)
		for(int i(1);i <= n;++i)
			for(register int j(1);j <= n;++j)
			{
				if(map[i][j] > map[i][k] + map[k][j])
					map[i][j] = map[i][k] + map[k][j]; //没有门时floyd一遍
				smap[i][j] = map[i][j]; //提前存最初的map
			}
	for(int a(1);a <= n;++a)
		for(int b(1);b < a;++b)
		{
			map[a][b] = 0;map[b][a] = 0; //传送门
			for(int i(1);i <= n;++i) //k=a
				for(register int j(1);j <= n;++j)
					if(map[i][j] > map[i][a] + map[a][j])
						map[i][j] = map[i][a] + map[a][j]; //floyd
			for(int i(1);i <= n;++i) //k=b
				for(register int j(1);j <= n;++j)
					if(map[i][j] > map[i][b] + map[b][j])
						map[i][j] = map[i][b] + map[b][j]; //floyd
			int temp(0);
			for(int i(1);i <= n;++i)
				for(register int j(1);j < i;++j)
					temp += map[i][j]; // 累加路径
			if(temp < minn) minn = temp; //更新最小值
			for(int i(1);i <= n;++i)
				for(register int j(1);j <= n;++j)
					map[i][j] = smap[i][j]; //把map改回来
		}
	cout << minn;
	return 0;
}
```


---

## 作者：expnoi (赞：4)

通过本题需要一些小小的思维技巧。

看到这题的第一步，想出的解法就是暴力，$O(n^2)$枚举所有可以赋值为0的边。然后$O(n^3)$再跑一遍Floyd。然后用一个变量存储最优解。

不过，很显然，这种方法是超时的。

我们不妨想想其他可以优化的地方。

是不是只要修改和被修改的这条边有关联的所有边就行了。

什么是有关联呢，比如我们要设$(i,j)$为0，那么只要连到i或者连到j的边都要改。

或者说是中间点包含i或j的都要改

注意：累计的时候第二层循环要小于第一层循环的k。因为当等于k时，他不是一条边，当大于k时，他已经统计过而重复了。

那么我们就可以愉快的用$O(n^4)$的方法水过这题啦~
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int dp1[1001][1001],dp2[1001][1001],n,m,u,v,w,ans=2.14e9;
int main()
{
	n=read();
	m=read();
	memset(dp1,0x3f,sizeof(dp1));
	for(int i=1;i<=m;i++)
	{
		u=read();
		v=read();
		w=read();
		dp1[u][v]=dp1[v][u]=w;
	}
	for(int k=1;k<=n;k++)//跑Floyd
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				dp1[i][j]=min(dp1[i][j],dp1[i][k]+dp1[k][j]);
				dp2[i][j]=dp1[i][j];//我们要先给原来的最短路备个份
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i!=j)//显然这不能构成边，故特判
			{
				dp1[i][j]=dp1[j][i]=0;
				for(int k=1;k<=n;k++)
				{
					for(int l=1;l<=n;l++)
					{
						dp1[k][l]=min(dp1[k][l],dp1[k][i]+dp1[i][l]);
					}
				}
				for(int k=1;k<=n;k++)
				{
					for(int l=1;l<=n;l++)
					{
						dp1[k][l]=min(dp1[k][l],dp1[k][j]+dp1[j][l]);
					}
				}
				int cnt=0;
				for(int k=1;k<=n;k++)
				{
					for(int l=1;l<k;l++)
					{
						cnt+=dp1[k][l];//统计结果
					}
				}
				ans=min(ans,cnt);//保存最优结果
				for(int k=1;k<=n;k++)
				{
					for(int l=1;l<=n;l++)
					{
						dp1[k][l]=dp2[k][l];//再回到原先的备份
					}
				}
			}
		}
	}
	write(ans);
}
```

---

## 作者：Meteorshower_Y (赞：3)

~~本来想的是Dijkstra~~
一看数据……n<=100
~~???~~

直接刚Floyd不香吗？

暴力算法

对每一条边建一条传送门(1/2*n(n-1))，分别跑一次Floyd -> O（n^3）

时间复杂度为O（n^5）想想都会TLE掉（~~Time Limit Enough~~）

所以我们需要优化算法

如果对于一个传送门来说，他影响的最短路只有 经过他的两个端点的路径 ，所以我们把Floyd最外层的k优化掉，只对他的两个端点在原最短路+传送门（一条无向边权值为0）进行Floyd的第二三层循环求最短路即可


下面上高清代码~

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int inf=1e8+50;  //初始化inf，只开到1e7 会WA;  wi<=10000 ,m<=4950,最坏情况为4.95*10^7 
int n,m,x,y,z;
int a[110][110],b[110][110],num,ans=inf;  //用两个数组a表示原最短路，b表示建造传送门后的最短路 
inline void init()
{
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			a[i][j]=inf;
	for(int i=1;i<=n;i++)
		a[i][i]=0;                       //自己到自己路径长为 Zero（0） 
}
inline void init2(int x,int y)
{
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			b[i][j]=a[i][j];
	b[x][y]=b[y][x]=0;                   // Pay attention to 无向图 
}
int main()
{
	scanf("%d%d",&n,&m);
	init();									//初始化a数组 
	for(register int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		a[x][y]=a[y][x]=z;              //无向图 双向存边 
	}
	for(register int k=1;k<=n;k++)      //Floyd 板子 
		for(register int i=1;i<=n;i++)
			for(register int j=1;j<=n;j++)
				if(a[i][j]>a[i][k]+a[k][j])
					a[i][j]=a[i][k]+a[k][j];
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<i;j++)     //i->j;j->i 有传送门 
		{
			init2(i,j);                  //对b数组初始化 
			num=0;
			for(register int k=1;k<=n;k++)   //对 经过 i节点的路径操作 
				for(register int l=1;l<=n;l++)
					if(b[k][l]>b[k][i]+b[i][l])
						b[k][l]=b[k][i]+b[i][l];
			for(register int k=1;k<=n;k++)   //对 经过 j节点的路径操作 
				for(register int l=1;l<=n;l++)
					if(b[k][l]>b[k][j]+b[j][l])
						b[k][l]=b[k][j]+b[j][l];
			for(register int k=1;k<=n;k++)
				for(register int l=1;l<k;l++)  //注意l<k 因为每条边只算一次 
					num+=b[k][l];             
			ans=min(ans,num);
		}
	printf("%d",ans);
	return 0;
}
```

感谢你的观看和支持~

---

## 作者：苏黎世 (赞：2)

### 注意数据范围：n <= 100 !!

于是，我们直接想到了Floyd算法。

这道题可以说思想难度还是有点高的，如果你过了这个题，那么说明你的Floyd算法已经炉火纯青了。

具体看代码：

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
#define rint register int
const int maxn = 105;
const int cl = 1e8 + 999;//贪玩蓝月警告 
int n, mm, maxx, maxy, ans = 2147483647;
int m[maxn][maxn];
int m2[maxn][maxn];

void clear1()//初始化 
{
	for(rint i = 1;i <= n; ++i)
		for(rint j = 1;j <= n; ++j)
		  m[i][j] = cl;
	for(int i = 1;i <= n; ++i)
	  m[i][i] = 0;//不能自己走自己 
}

void clear2(int x, int y)
{
	for(rint i = 1;i <= n; ++i)
	  for(rint j = 1;j <= n; ++j)
	    m2[i][j] = m[i][j];
	m2[x][y] = 0; m2[y][x] = 0;//处理传送门 
}

void cini()
{
	
	scanf("%d%d", &n, &mm);
	clear1();
	int u, v, w;
	for(rint i = 1;i <= mm; ++i)
	{
		scanf("%d%d%d", &u, &v, &w);
		m[u][v] = w; m[v][u] = w;
	}
}

void floyd()//先对现有图进行处理 
{
	for(rint k = 1;k <= n; ++k)
		for(rint i = 1;i <= n; ++i)
			for(rint j = 1;j <= n; ++j)
				  if(m[i][j] > m[i][k] + m[k][j])
				  	m[i][j] = m[i][k] + m[k][j];
}

void work()
{
	int now;
	for(rint i = 1;i <= n; ++i)
		for(rint j = 1;j <= n; ++j)
		{
			clear2(i, j);
			now = 0;
			
			for(rint k = 1;k <= n; ++k)
				for(rint q = 1;q <= n; ++q)
				  if(m2[k][q] > m2[k][i] + m2[i][q])
				    m2[k][q] = m2[k][i] + m2[i][q];
			//处理经过i的边 
			for(rint k = 1;k <= n; ++k)
				for(rint q = 1;q <= n; ++q)
				  if(m2[k][q] > m2[k][j] + m2[j][q])
				    m2[k][q] = m2[k][j] + m2[j][q];
			//处理经过j的边 
			for(rint k = 1;k <= n; ++k)
				for(rint q = 1;q < k; ++q)
				   now+= m2[k][q];
			//计算结果 
			ans = ans > now ? now : ans;//更新答案 
		}
	printf("%d", ans);
}

int main()
{
	cini();
	floyd();
	work();
	return 0;
}
```

感谢支持~

---


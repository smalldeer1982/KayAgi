# [COCI 2009/2010 #7] BAKICE

## 题目描述

有轨电车上总会出现诸多问题，其中包括人群抢夺座位的乱象——他们总会以飞快的速度去抢距离自己最近的座位。

当多名乘客同时瞄准同一个座位准备入座时，问题将会产生。如果只有一名乘客离该座位最近（对于此题，两个点的距离定义为**欧几里得距离**，即 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$），那么他就会入座而其他乘客将会另选最近的座位；如果多名乘客与座位的欧几里得距离都是最近的，那么将会产生「爆炸事件」。「爆炸事件」后，涉及到的乘客和座位都将会「爆炸」（即后续无需继续考虑）。

给定电车中座位、乘客和地板的 $R \times C$ 地图，用 $\texttt .$ 、$\texttt X$ 和 $\texttt L$ 分别表示地板、乘客和座位。求在所有乘客都落座或「爆炸」和座位被抢光最先发生的一个事件之前，发生了多少次「爆炸事件」。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$1 \le R,C \le 100$。

**【提示与说明】**

**题目译自 [COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST #7](https://hsin.hr/coci/archive/2009_2010/contest7_tasks.pdf) _Task 3 BAKICE_。**

**本题分值按 COCI 原题设置，满分 $70$。**

## 样例 #1

### 输入

```
4 4
.LX.
.X..
....
.L..```

### 输出

```
1```

## 样例 #2

### 输入

```
4 4
.XLX
.X..
...L
.X..```

### 输出

```
2```

## 样例 #3

### 输入

```
7 7
...X.X.
XL....L
.......
...L...
.....XL
.......
...X...```

### 输出

```
1```

# 题解

## 作者：FReQuenter (赞：3)

发现数据很小。所以基本上随便写写都能过/cf

首先预处理出每个人和每个椅子之间的距离。注意用的是欧几里得距离，别用曼哈顿距离算。

然后来考虑每个人选哪个椅子。这里我们发现，让人去选椅子很麻烦（因为要排序距离）所以直接把所有人到椅子的距离都单独拿出来排序依次处理。这样子一个人选了一个椅子之后就不会动了。

最后统计一下每个椅子被选了多少次。如果大于一次就会炸。然后就做完了。

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define int long long
#define sqr(x) ((x)*(x))
using namespace std;
int r,c,cp,cs,ans,cr,sit[25005];
char a[505][505];
pair<int,int> pas[25005],seat[25005],sited[25005];
pair<int,pair<int,int>> ge[25005];
int dis(int x,int y){
	return sqr(pas[x].fi-seat[y].fi)+sqr(pas[x].se-seat[y].se);
}
signed main(){
	cin>>r>>c;
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			cin>>a[i][j];
			if(a[i][j]=='X') pas[++cp]={i,j};
			if(a[i][j]=='L') seat[++cs]={i,j};
		}
	}
	for(int i=1;i<=cp;i++){
		for(int j=1;j<=cs;j++){
			ge[++cr]={dis(i,j),{i,j}};
		}
	}
	sort(ge+1,ge+cr+1);
	for(int i=1;i<=cr;i++){
		if(!sit[ge[i].se.fi]){
			int u=ge[i].se.fi,v=ge[i].se.se;
			if(!sited[v].se) sit[u]=v,sited[v]={u,1};
			else if(dis(u,v)==dis(sited[v].fi,v)) sit[u]=v,sited[v].se++;
		}
	}
	for(int i=1;i<=cs;i++) if(sited[i].se>1) ans++;
	cout<<ans;
}
```

---

## 作者：Strelizia_Qy (赞：3)

~~发现这题没人写题解，那我来水一篇。~~

## **题意简述**
给定一张 $R×C$ 的地图，每个乘客（用 `X` 表示）会寻找离自己最近的座位（用 `L` 表示），不存在两个 `L` 和某一个 `X` 的距离相等的情况。

如果多名乘客找到了同一个座位，且他们与这一座位的距离相等，那么会发生一次「爆炸」。  

如果多名乘客找到了同一个座位，但他们与这一座位的距离不相等，那么不会发生「爆炸」，距离最近的将入座，其他乘客将选择其他座位。

统计「爆炸」次数。

## **题目分析**

我们可以预先计算每一位乘客和每一个座位之间的距离。

因为是找最近的座位，又注意到算法标签“**贪心**”，所以将所有的距离从小到大排序。

排序过后遍历，对于每一个距离 $dis1$ 和它所对应的乘客 $u$ 以及座位 $v$，分以下情况讨论：

+ 如果乘客 $u$ 在此之前已经选择了其他的座位，因为距离是从小到大排序的，所以可以保证之前所选择的座位比现在的座位 $v$ 更近。所以直接 `continue` 。

+ 如果乘客 $u$ 此前**没有选择过座位**，且座位 $v$ **没有其他乘客坐**，那么乘客 $u$ 可在座位 $v$ 落座。可以保证座位 $v$ 是乘客 $u$ 能坐的座位中离他最近的一个。

+ 如果乘客 $u$ 此前**没有选择过座位**，但座位 $v$ **已经有其他乘客** $x$ 坐了，分以下两种情况讨论：
	1. 乘客 $x$ 到座位 $v$ 的距离 $dis0$ 与乘客 $u$ 到座位 $v$ 的距离 $dis1$ **相等**，那么将发生一次「爆炸」。
   
   2. 乘客 $u$ 到座位 $v$ 的距离 $dis1$ **大于**乘客 $x$ 到座位 $v$ 的距离 $dis0$。那么乘客 $x$ 将在座位 $v$ 入座，乘客 $u$ 需要另寻座位。

最后统计爆炸次数就好了~

## **AC代码**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxRC=105,maxn=10005;
int R,C;
int cnt_p,cnt_s;//分别记录乘客的个数，座位的数量 
int ans;//统计爆炸次数 
int road;//统计边的条数 
int sit[maxn];// sit[u]=v 表示第 u 个乘客坐在第 v 个位置 
char mp[maxRC][maxRC];//地图 
struct position{int x,y;}passenger[maxn],seat[maxn];//存每个乘客、每个座位的位置 
struct Edge{double dis;int from,to;}e[maxn];//存边 
struct node{int sum,num;}come[maxn];
// come[v].sum 表示坐在座位 v 的乘客的个数，come[v].num 表示坐在座位 v 的乘客编号（如有多个，只记录第一个） 
bool cmp(Edge x,Edge y){return x.dis<y.dis;}
int main()
{
	cin>>R>>C;
	for(int i=1;i<=R;i++)
		for(int j=1;j<=C;j++)
		{
			cin>>mp[i][j];
			if(mp[i][j]=='X')passenger[++cnt_p].x=i,passenger[cnt_p].y=j;
			else if(mp[i][j]=='L')seat[++cnt_s].x=i,seat[cnt_s].y=j;
		}
	for(int i=1;i<=cnt_p;i++)
			for(int j=1;j<=cnt_s;j++)
			{
				int a=passenger[i].x,b=passenger[i].y;
				int c=seat[j].x,d=seat[j].y;
				e[++road].from=i;e[road].to=j;
				e[road].dis=sqrt((a-c)*(a-c)+(b-d)*(b-d));//计算距离 
			}
	sort(e+1,e+road+1,cmp);//从小到大排序 
	for(int i=1;i<=road;i++)
	{
		int u=e[i].from,v=e[i].to;
		if(sit[u])continue;//乘客 u 在此之前已经选择了其他的座位,continue
		if(sit[u]==0)//此前未选择座位 
		{
			if(come[v].sum==0)//如果座位 v 没有其他乘客坐 
			{
				sit[u]=v;//标记 
				come[v].num=u;
				come[v].sum=1;
			}
			else//如果座位 v 已经有其他乘客 x 坐 
			{
				int a=passenger[u].x,b=passenger[u].y;// u 的位置 
				int c=seat[v].x,d=seat[v].y;// v 的位置 
				double dis1=sqrt((a-c)*(a-c)+(b-d)*(b-d));// dis1 为 u 到 v 的距离 
				int a1=passenger[come[v].num].x,b1=passenger[come[v].num].y;// x 的位置 
				double dis0=sqrt((a1-c)*(a1-c)+(b1-d)*(b1-d));// dis0 为 x 到 v 的距离 
				if(dis1==dis0)
				{
					sit[u]=v;//标记 
					come[v].sum++;//选择坐在 v 的个数加 1 
				}
			}
		}
		
	}
	for(int i=1;i<=cnt_s;i++)
		if(come[i].sum>1)ans++;//如果有多个人选择坐在同一位置 ，发生一次爆炸 
	cout<<ans;
	return 0;
}
```



---

## 作者：ycy1124 (赞：1)

### 题意
有一个 $r\times c$ 的格子房间，每个格子上可能会有一个座位或者是一个人，每个人都会向离他最近的座位移动，并且走的是直线，假如一个人无法最先到达离他最近的座位的话就会向离他第二近的座位移动，以此类推。

我们设如果有一个座位会同时被多个人最先到达那么就会发生一起“爆炸”事件，有关的人和座位不会参与到之后的行动。现在试问会发生多少起爆炸事件。
### 思路
由于位置和人都很少，所以可以考虑暴力求出每个人与每个座位的距离。接下来我们按照每条路径的距离从短到长排个序，然后开始模拟求答案。

首先我们用几个数组标记一下每个座位与每个人是否找到座位或者被坐了，然后拿一个数组记录一下每个座位最先到达的人的距离。然后我们考虑，如果这条路径的人和座位都没被标记那么他可以走，如果人被标记就直接 `continue`，否则判断一下这条路径与那个座位最先到达的人的距离，如果相等就累加答案，否则 `continue`。
### 代码
```cpp
#include<bits/stdc++.h>
#define ld long double
using namespace std;
struct Node{
    int x,y;
}a[10005],b[10005];
bool bja[10005],bjb[10005],bza[10005];
ld ma[10005];
struct node{
    int v,u;
    ld w;
}qwq[1000005];
inline bool cmp(node x1,node x2){
    return x1.w<x2.w;
}
int r,c,tota,totb,totc,ans;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>r>>c;
    for(int i=1;i<=r;i++){
        for(int j=1;j<=c;j++){
            char ch;
            cin>>ch;
            if(ch=='L'){
                a[++tota]={i,j};
            }
            else if(ch=='X'){
                b[++totb]={i,j};
            }
        }
    }
    for(int i=1;i<=tota;i++){
        for(int j=1;j<=totb;j++){
            qwq[++totc]={i,j,(ld)sqrt(1.00*(a[i].x-b[j].x)*(a[i].x-b[j].x)+(a[i].y-b[j].y)*(a[i].y-b[j].y))};
        }
    }
    sort(qwq+1,qwq+totc+1,cmp);
    for(int i=1;i<=totc;i++){
        if(!bja[qwq[i].v]&&!bjb[qwq[i].u]){
            bja[qwq[i].v]=1;
            bjb[qwq[i].u]=1;
            ma[qwq[i].v]=qwq[i].w;
        }
        else if(bjb[qwq[i].u]){
            continue;
        }
        else if(bja[qwq[i].v]&&qwq[i].w==ma[qwq[i].v]){
            if(!bza[qwq[i].v]){
                ans++;
                bza[qwq[i].v]=1;
                bjb[qwq[i].u]=1;
            }
            else{
                bjb[qwq[i].u]=1;
            }
        }
        else{
            continue;
        }
    }
    cout<<ans;
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/197432276)。

---

## 作者：qwer6 (赞：0)

我们刚拿到这道题的时候第一时间可能会想到计算每张椅子由谁去做，或者每个人坐哪张椅子，但是实际上这些都是不好求的。

那怎么办呢？

我们观察发现数据范围十分小，那几乎随便乱搞都行，所以我们考虑求出若干个三元组 $(a,b,c)$，表示编号为 $b$ 的人到编号为 $c$ 的椅子距离为 $a$，然后我们把所有三元组按照 $a$ 从小到大排序，然后我们直接模拟即可。

对于一个三元组 $(a,b,c)$，如果 $b$ 已经有位置做了，那么跳过，如果 $c$ 没有人坐，直接坐上去，如果 $c$ 已经有人坐了，且距离与 $a$ 相等，那么我们将 $cnt_c$ 加一即可。

最后统计 $cnt$ 数组中有多少个大于 $1$ 的数即可。

```c++
/*by qwer6*/
#include<bits/stdc++.h>
#define Nxt puts("")
#define Spa putchar(32)
#define Pline puts("------------------------------")
#define pii pair<int,int>
#define fi first
#define se second
namespace FastIO{
	inline int read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a=a*f;
	}
	inline int read(){
		char c=getchar();
		int f=1,a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a*f;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		std::stack<int>st;
		do{
		   st.push(x%10);
		   x/=10;
		}while(x);
		while(!st.empty())putchar(st.top()+'0'),st.pop();
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
int R,C,id,tot,q,ans;
int cnt[2505],b[2505];
char mp[55][55];
bool flag[2505];
//表示这个人有没有椅子 
pii place[2505];
struct Node{
	int val,people,chair;
	bool operator <(const Node &a)const{
		return val<a.val;
	}
}a[2505*2505];
void solve(int idx,int x,int y){
	for(int i=1,dis;i<=tot;i++){
		dis=(place[i].fi-x)*(place[i].fi-x)+(place[i].se-y)*(place[i].se-y);
		a[++q]={dis,idx,i};
	}
}
signed main(){
	read(R),read(C);
	for(int i=1;i<=R;i++)scanf("%s",mp[i]+1);
	for(int i=1;i<=R;i++)
		for(int j=1;j<=C;j++)
			if(mp[i][j]=='L'){
				++tot;
				b[tot]=-1;
				place[tot]={i,j};
			}
	for(int i=1;i<=R;i++){
		for(int j=1;j<=C;j++){
			if(mp[i][j]=='X'){
				++id;
				solve(id,i,j);
			}
		}
	}
	sort(a+1,a+q+1);
	for(int i=1;i<=q;i++){
		if(flag[a[i].people])continue;
		if(b[a[i].chair]==-1){
			b[a[i].chair]=a[i].val;
			cnt[a[i].chair]++;
			flag[a[i].people]=1;
		}else if(b[a[i].chair]==a[i].val){
			cnt[a[i].chair]++;
			flag[a[i].people]=1;
		}
	}
	for(int i=1;i<=tot;i++)if(cnt[i]>=2)ans++;
	write(ans);
}
```

---

## 作者：内拉组里 (赞：0)

非常非常暴力的解法，甚至用不到标签里的最短路。

# Thoughts :

观察数据范围发现，乘客和座位最多只有 $ \frac{RC}2 = 5 \times 10^3 $ 个，

那么两两组合最多只有 $ \frac{R^2 C^2}4 = 2.5 \times 10^7 $ 种。

实际上数据很水，只出到了 $ R = 41,C = 40 $。

那么一共就只有 $ \frac{R^2 C^2}4 \le 7 \times 10^5 $ 中情况，跑得飞快。

具体来说就是把每个乘客和座位的位置分别丢进两个 vector 里，

然后以二元组 $ (P,S) $ 的形式丢进优先队列里，其中 $ P $ 是乘客的位置，$ S $ 是座位的位置，

同时应以两位置的欧氏距离为关键字进行排序。

剩下只需要统计答案即可。

每次从队中取出一个二元组，首先判断乘客 $ P $ 是否已经找到座位，如果是就直接跳过、

然后分两种情况讨论：

- 乘客 $ P $ 是距离座位 $ S $ 最近的乘客（之一），不管三七二十一抢过来再说。
- 存在与座位 $ S $ 的距离和乘客 $ P $ 的乘客，那么标记一下这个座位，表示这个座位会**爆炸**。

最后输出被标记的座位数即可。

# Analyses :

> 总时间复杂度 $ \Theta (RC \log{RC}) $。
>
> 总空间复杂度 $ \Theta (RC) $。

# Code :

```cpp
/* reference : @Luogu.FReQuenter (527598) */
#include	<iostream>
#include	<vector>
#include	<queue>
#include	<map>
using namespace std;
using pii = pair<int,int>;
constexpr int maxc = 55;

int r, c;
char s[maxc];
vector<pii> chr, ppl;
map<int,int> vis, own, cnt;

inline int dist (const pii &a, const pii &b)
{
	int x = a.first - b.first;
	int y = a.second - b.second;
	return x * x + y * y;
}
struct cmp
{
	bool operator() (const pii &a, const pii &b) const { return dist (ppl[a.first], chr[a.second]) > dist (ppl[b.first], chr[b.second]); }
};

signed main (void)
{
	cin >> r >> c;
	for (int i = 1; i <= r; i++)
	{
		cin >> s + 1;
		for (int j = 1; j <= c; j++)
		{
			if (s[j] == 'X') ppl.push_back({i, j});
			else if (s[j] == 'L') chr.push_back({i, j});
		}
	}
	priority_queue<pii,vector<pii>,cmp> q;
	for (int i = 0; i < ppl.size(); i++)
	{
		for (int j = 0; j < chr.size(); j++)
		{
			q.push({i, j});
		}
	}
//	for (auto i : ppl) cerr << i.first << ' ' << i.second << endl;
//	cerr << endl << ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl;
//	for (auto i : chr) cerr << i.first << ' ' << i.second << endl;
//	cerr << endl;
	while (!q.empty())
	{
		pii now = q.top(); q.pop();
		int p = now.first;
		int c = now.second;
		if (!vis[p])
		/* ppl[p] didn't find a single seat */
		{
			if (!own[c])
			{
				vis[p] = 1;
				own[c] = p + 1;
				cnt[c] = 1;
			}
			else if (dist (ppl[p], chr[c]) == dist (ppl[own[c] - 1], chr[c]))
			{
				vis[p] = 1;
				cnt[c]++;
			}
		}
	}
	int ans = 0;
	for (auto i : cnt) if (i.second > 1) ans++;
	cout << ans << endl;
	return 0;
}
```

---

## 作者：2b2b2bbb (赞：0)

# 题意

给定一张 $R \times C$ 的图，其中，用 $\texttt .$、$\texttt X$ 和 $\texttt L$ 分别表示地板，乘客和座位。

所有乘客回去一个没有距离比他更短的人的座位，你要判断有几个座位会因为两个乘客到达同一个的座位距离相等而发生爆炸座位。输出数量。

# 思路

首先，我们可以发现这个地图的大小很小。那么我们就可以先求出所有人和座位的坐标。然后直接枚举所有人到达所有座位的距离。要使用阿基里德公式。

然后，当我们求出所有人到达所有座位的距离时，我们可以记录下来，然后我们可以先按距离从小到大排个序。

因为我们是要距离最短，那么当是争夺同一个座位时后一人到达的距离必定大于等于前一个争夺的人。

然后我们遍历一遍所有情况，判断所有可能性：

1，当这个人已经选过了就不在查看另外两种。

2，如果这个座位还没有选择那么我们就先让当前的人选择，同时不判断下一个。

3，如果这个座位之前没有发生爆炸事件，但是这次的距离等于和我们保存的最短距离相等就代表发生了一个新的爆炸事件。

最后输出答案即可。不懂的可以看看代码，代码上我已明确表明了每一步的作用和每一次的判断。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
char c[105][105];
int cnt;
struct rz{
	int x,y;
}l[10005],r[10005];//座位或人的坐标
int le,re;
struct pi{
	double x;
	rz a,b;
}a[10005];//所有人和所有座位的距离与是那个座位与人
bool cmp(pi x,pi y){//排序
	return x.x < y.x;
}
double ajld(int x_1,int y_1,int x_2,int y_2){//求出距离
	return sqrt((x_1 - x_2) * (x_1 - x_2) + (y_1 - y_2) * (y_1 - y_2));
}
double vis[105][105];//到达x,y点的最小距离
int dis[105][105];//当前座位是否发生过爆炸事件
bool ss[105][105];//当前的人是否已经选择了座位
bool aa[105][105];//当前的座位是否已经被占
signed main(){
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i ++){
		for(int j = 1 ; j <= m ; j ++){
			cin >> c[i][j];
			//统计所有人和所有座位的坐标
			if(c[i][j] == 'L'){
				le ++;
				l[le].x = i;
				l[le].y = j;
			}
			if(c[i][j] == 'X'){
				re ++;
				r[re].x = i;
				r[re].y = j;
			}
		}
	}
	for(int i = 1 ; i <= re ; i ++){
		for(int j = 1 ; j <= le ; j ++){
			cnt ++;
			a[cnt].x = ajld(r[i].x , r[i].y , l[j].x , l[j].y);//求出距离
			a[cnt].a.x = r[i].x;//记录本次距离的人的x坐标
			a[cnt].a.y = r[i].y;//记录本次距离的人的y坐标
			a[cnt].b.x = l[j].x;//记录本次距离的座位的x坐标
			a[cnt].b.y = l[j].y;//记录本次距离的座位的y坐标
		}
	}
	int ans = 0;
	sort(a + 1 , a + 1 + cnt , cmp);//排序
	for(int i = 1 ; i <= cnt ; i ++){
		if(ss[a[i].a.x][a[i].a.y])continue;//如果这个人已经选择了座位就退出
		if(aa[a[i].b.x][a[i].b.y] == 0){//如果这个座位没人选
			vis[a[i].b.x][a[i].b.y] = a[i].x;//可以证明没人选的话此人的距离必定是最短的距离
			//标记人和座位
			ss[a[i].a.x][a[i].a.y] = 1;
			aa[a[i].b.x][a[i].b.y] = 1;
			continue;
		}
		if(a[i].x == vis[a[i].b.x][a[i].b.y] && !dis[a[i].b.x][a[i].b.y]){//如果发生爆炸事件
			dis[a[i].b.x][a[i].b.y] = 1;
			ans ++;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：LastKismet (赞：0)

# 前言
这篇题解的方法比较暴力且直接。
# 题意
给出一些人和一些座位，每个人会尽量前往最近的座位，但如果存在另一个人离那个座位的距离比他离那个座位的距离更小，就会找下一个座位，直到找到合适的座位或没有座位坐为止。

求坐了两个人以上的座位个数。
# 思路
首先，肯定的，每个人都会尽量往距离最小的座位坐，可以贪心解决。

我们考虑，一个人能坐到某个位子，当且仅当他离那个位子的距离是所有人离那个位子的距离中最短的。

但我们会发现一个问题：假如对于某一个位子存在一个最短的距离，但是造成这个距离的人已经坐了另外的位置，那么这个距离事实上不存在，因此次小的距离同样可以坐到这上面。

因此，我们考虑在每个人选完位子后删除其到其他所有位子的距离，以消除影响。

同时，为了防止当判断一段距离时，存在“应该被消除的距离”，我们应该从小到大处理每一段距离。证明很容易，如果存在一段会对其他距离造成影响的“应该被消除的距离”，它必然小于会被其影响的距离。

由于 $n$ 很小，直接暴力储存所有距离即可。
# 实现
主要实现过程都在思路部分了，这里主要讲一个细节：

如何判断一个距离是否应该被消除，并且让一个人选完位置后删除距离呢？

直接暴力储存每一个座位有关的所有距离的存在个数即可。每次判断一个距离是否应该被消除，就看它存在个数是否为 $0$ 。

更细节的，使用离散化，就可以直接用计数数组了。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define fir first
#define sec second
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<int,pii> pip;

const int N=105;

int r,c;
int ans;
char a[N][N];
int xnt;
int x[N*N*N*N];
int cb,cc;
pii box[N*N],cat[N*N];
int cnt[N*N];
int bds[N*N][N*N];
bool fns[N*N];
priority_queue<pii,vector<pii>,greater<pii> > ct[N*N];
priority_queue<int,vector<int>,greater<int> > bx[N*N];
priority_queue<pip,vector<pip>,greater<pip> > qs;

int dis(pii a,pii b){
    return (a.fir-b.fir)*(a.fir-b.fir)+(a.sec-b.sec)*(a.sec-b.sec);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>r>>c;
    for(int i=1;i<=r;i++){
        for(int j=1;j<=c;j++){
            cin>>a[i][j];
            if(a[i][j]=='L')box[++cb]={i,j};
            if(a[i][j]=='X')cat[++cc]={i,j};
        }
    }
    for(int i=1;i<=cc;i++){
        for(int j=1;j<=cb;j++){
            int ds=dis(cat[i],box[j]);
            x[++xnt]=ds;
        }
    }
    sort(x+1,x+1+xnt);
    xnt=unique(x+1,x+1+xnt)-x-1;
    for(int i=1;i<=cc;i++){
        for(int j=1;j<=cb;j++){
            int ds=lower_bound(x+1,x+1+xnt,dis(cat[i],box[j]))-x;
            ct[i].push({ds,j});
            bx[j].push(ds);
            bds[j][ds]++;
            qs.push({ds,{i,j}});
        }
    }
    while(!qs.empty()){
        pip q=qs.top();qs.pop();
        int i=q.sec.fir,j=q.sec.sec,d=q.fir;
        if(fns[i])continue;
        while(bds[j][bx[j].top()]==0)bx[j].pop();
        if(bx[j].top()==d){
            fns[i]=true;
            cnt[j]++;
            while(!ct[i].empty()){
                pii tp=ct[i].top();ct[i].pop();
                if(tp.sec==j)continue;
                bds[tp.sec][tp.fir]--;
            }
        }
    }
    for(int i=1;i<=cb;i++){
        if(cnt[i]>1)ans++;
    }
    cout<<ans;
	return 0;
}
```

---

## 作者：_Weslie_ (赞：0)

水题。

## 思路

$n\le 100$，考虑直接模拟。

我们首先预处理出人和座位之间的距离，数组记为 $e$。

然后把 $e$ 按距离排序。

对于一条边，连接人 $x$ 和座椅 $y$，我们这么处理：

- 人 $x$ 已经坐上座位。显然一定有一个座位，使得在这个人的位置出发，距离更短。所以这个座位不是答案。
- 人 $x$ 还没有坐上座位，同时座位 $y$ 还没有人坐。那么人 $x$ 坐在座位 $y$ 上一定最优。证明：如果再往后走，还有一个人 $x$ 可以坐的座位，人 $x$ 到这个座位的距离一定更长。
- 人 $x$ 还没有坐上座位，但是这个座位 $y$ 被另一个人 $z$ 坐了，并且这个人 $x$ 到座位 $y$ 的距离比另一个人 $z$ 到座位 $y$ 的距离大。这样这个人 $x$ 就无法坐在这个座位上，只能再往后找。
- 人 $x$ 还没有坐上座位，但是这个座位 $y$ 被另一个人 $z$ 做了，但是这个人 $x$ 和另一个人 $z$ 到这个座位 $y$ 的距离一致。自然会发生爆炸。

于是可以写出代码：

```
	for(int i=1;i<=cnt;i++){
		int u=e[i].u,v=e[i].v;
		if(vis[u]){
			continue;
		}
		if(!zhan[v]){
			vis[u]=v;
			zhan[v]=u;
			sum[v]++;
		}
		else{
			double dis=e[i].dis;
			double dis1=sqrt((sx[v]-px[zhan[v]])*(sx[v]-px[zhan[v]])+(sy[v]-py[zhan[v]])*(sy[v]-py[zhan[v]]));
			if(dis==dis1){
				zhan[v]=u;
				vis[u]=v;
				sum[v]++;
				ans++;
			}
		}
	}
```

但是这个代码是错误的。原因是：如果 $n$ 个人同时抢一个座位，这个代码会统计 $n-1$ 次。很显然：除了第一个人，后面所有人枚举到这个位置，都会有一个人在这上面，触发 `ans++` 的条件。

举个例子：

```
3 3
.X.
XLX
.X.
```

很显然四个人都会抢一个位置，发生一次爆炸，但是这个代码会输出 $3$。

因为我们在枚举到第二个人时，判断第一个人占掉了，距离一致，答案增加；在枚举到第三个人时，判断第二个人占掉了，距离一致，答案增加；在枚举到第四个人时，判断第三个人占掉了，距离一致，答案也增加。

如何避免这个问题？我们需要一个 `sum` 数组，统计抢这个位置的人数。如果多于 $1$，则会发生爆炸，答案增加。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int u,v;
	double dis;
}e[10005];
char ch[105][105];
int n,m,cnt1,cnt2,cnt;
int px[10005],py[10005],sx[10005],sy[10005];
int vis[10005];
bool cmp(node _,node __){
	return _.dis<__.dis;
}
int zhan[10005],sum[10005];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>ch[i][j];
			if(ch[i][j]=='X'){
				px[++cnt1]=i;
				py[cnt1]=j;
			}
			if(ch[i][j]=='L'){
				sx[++cnt2]=i;
				sy[cnt2]=j;
			}
		}
	}
	for(int i=1;i<=cnt1;i++){
		for(int j=1;j<=cnt2;j++){
			e[++cnt].u=i;
			e[cnt].v=j;
			e[cnt].dis=sqrt((sx[j]-px[i])*(sx[j]-px[i])+(sy[j]-py[i])*(sy[j]-py[i]));
		}
	} 
	sort(e+1,e+cnt+1,cmp);
	for(int i=1;i<=cnt;i++){
		int u=e[i].u,v=e[i].v;
		if(vis[u]){
			continue;
		}
		if(!zhan[v]){
			vis[u]=v;
			zhan[v]=u;
			sum[v]++;
		}
		else{
			double dis=e[i].dis;
			double dis1=sqrt((sx[v]-px[zhan[v]])*(sx[v]-px[zhan[v]])+(sy[v]-py[zhan[v]])*(sy[v]-py[zhan[v]]));
			if(dis==dis1){
				zhan[v]=u;
				vis[u]=v;
				sum[v]++;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=cnt2;i++){
		if(sum[i]>1)ans++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

### 思路

我们首先把每个座位到每个人的距离计算出来，将座位 $i$ 和乘客 $j$ 的距离 $dis$ 连同座位的编号和乘客的编号打包在一个结构体中（我们用<乘客 $i$，座位 $j$>表示），然后对这个结构体按照 $dis$ 从小到大的顺序排序，然后从前往后遍历。

那么这样做有什么好处呢？这样我们就可以保证先访问到的<乘客 $i$，座位 $j$>距离一定 $≤$ 后访问到的<乘客 $k$，座位 $j$>距离。

当我们访问到一个<乘客 $i$，座位 $j$>，若此时这个座位还没有人坐，那么我们就标记这个座位被乘客 $i$ 占用了。后面如果我们通过<乘客 $k$，座位 $j$>访问到了这个座位 $j$，并且发现已经有乘客 $i$ 占用了这个座位，那么我们知道 $dis_{i,j}≤dis_{k,j}$，所以要么发生爆炸，要么乘客 $k$ 没有位置，这样就保证了座位 $j$ 的占用不会改变。

当我们访问到一个<乘客 $i$，座位 $j$>，若此时这个座位还没有人坐，那么我们就标记这个座位被乘客 $i$ 占用了，让 $seatpeoplecnt_j$ 加 $1$，同时我们还需要标记乘客 $i$ 已经找到位置了，后面访问到 $i$ 就直接跳过。当我们访问到一个 <乘客 $k$，座位 $j$>，若 $dis_{i,j}=dis_{k,j}$，我们也把 $seatpeoplecnt_j$ 加 $1$。

最后，我们扫描一遍 $seatpeoplecnt$ 数组，如果有 $>1$ 的值，就会发生一次爆炸。注意我们不应该在发现 $dis_{i,j}=dis_{k,j}$ 就把 $ans+1$，否则同一个座位会爆炸多次。



### 代码

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//头文件
#include<bits/stdc++.h>

//数据类型
#define ll long long
#define ull unsigned long long
#define db double
#define endl '\n'
//命名空间
using namespace std;
//常量
const int N=2e5+5;
const int M=1e3;
const int MOD=903250223;
const int INF=1e9;
//变量
int n,fn[N],zn[N],m,u,ans,seat,cnt,flg[N],t[N],seat_people_cnt[N];
char cop,cc,cs1[N],s[M][M];

struct node{
	int sid,pid,dis;
}a[N];

int dis(int x,int y,int a,int b){
	return (x-a)*(x-a)+(y-b)*(y-b);// 没必要开根号
}

bool cmp(node a,node b){
	return a.dis<b.dis;
}

signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s[i][j]=='L'){
				u=0,++seat;
				for(int ii=1;ii<=n;ii++){
					for(int jj=1;jj<=m;jj++){
						if(s[ii][jj]=='X'){
							a[++cnt]={seat,++u,dis(i,j,ii,jj)};
						}
					}
				}
			}
		}
	}
//	cout<<cnt<<"cnt\n";
	sort(a+1,a+cnt+1,cmp);
//	for(int i=1;i<=cnt;i++)cout<<a[i].dis<<' ';
	for(int i=1;i<=cnt;i++){
		if (!flg[a[i].pid] && (!t[a[i].sid] || a[i].dis == t[a[i].sid])) {
            flg[a[i].pid] = 1;//标记a[i].pid已经就坐
            ++seat_people_cnt[a[i].sid];
            t[a[i].sid] = a[i].dis;//记录距离
        }
	}
	ans=0;
	for(int i=1;i<=seat;i++)if(seat_people_cnt[i]>1)ans++;
	cout<<ans;
	
	
}

```




---

## 作者：djh0314 (赞：0)

[P8073 [COCI2009-2010#7] BAKICE](https://www.luogu.com.cn/problem/P8073)   

### 题意
对于每位乘客（用 X 表示）会寻找距离（**欧几里得距离**）自己最近的座位（用 L 表示）。   

坐座位满足以下原则：      
- 如果有别人离这个椅子更近，那这个人会选择下一张最近的椅子。
- 如果有别人离这个椅子一样近，那这个椅子与这些人都会发生 **1** 次爆炸。        
（不存在一个人离两个人相同距离）。


### 分析

因为对于一个人不存在有两张椅子离其距离相等，   
那么我们就可以认为这个人会选择离自己最近的目前没有人坐的椅子。     


又看到数据范围 $1\le R,C\le 100$，非常小，那我们不妨暴力一点。

我们暴力处理出所有椅子与人的距离，并进行排序。   

对于我们当前选择的这条线路分情况讨论：

1. 如果当前这个人已经有了一个位置，那么当前的线路无意义，直接跳过。
2. 如果当前这张椅子未选，直接选择这张椅子。
3. 如果当前这张椅子被选，并且之前那个人的距离更近，跳过。
4. 如果当前这张椅子被选，并且之前那个人的距离和这次距离相等，发生一次爆炸。

#### 注意

1. 一张椅子只会发生一次爆炸，因此爆炸后我们要对这个椅子进行标记，防止重复运算。
2. 题目所求为欧几里得距离，而不是曼哈顿距离。

---


# [蓝桥杯 2020 省 AB3] 限高杆

## 题目描述

某市有 $n$ 个路口，有 $m$ 段道路连接这些路口，组成了该市的公路系统。其中一段道路两端一定连接两个不同的路口。道路中间不会穿过路口。

由于各种原因，在一部分道路的中间设置了一些限高杆，有限高杆的路段货车无法通过。

在该市有两个重要的市场 $A$ 和 $B$，分别在路口 $1$ 和 $n$ 附近，货车从市场 $A$ 出发，首先走到路口 $1$，然后经过公路系统走到路口 $n$，才能到达市场 $B$。两个市场非常繁华，每天有很多货车往返于两个市场之间。

市长发现，由于限高杆很多，导致货车可能需要绕行才能往返于市场之间，这使得货车在公路系统中的行驶路程变长，增加了对公路系统的损耗，增加了能源的消耗，同时还增加了环境污染。

市长决定要将两段道路中的限高杆拆除，使得市场 $A$ 和市场 $B$ 之间的路程变短。请问最多能减少多长的距离?

## 说明/提示

**【样例说明】**

只有两段道路有限高杆，全部拆除后，$1$ 到 $n$ 的路程由原来的 $17$ 变为了 $11$，减少了 $6$。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测样例，$2 \leq n \leq 10,1 \leq m \leq 20,1 \leq c \leq 100$。

对于 $50 \%$ 的评测样例，$2 \leq n \leq 100,1 \leq m \leq 1000,1 \leq c \leq 1000$。

对于 $70 \%$ 的评测样例，$2 \leq n \leq 1000,1 \leq m \leq 10000,1 \leq c \leq 10000$。

对于所有评测样例，$2 \leq n \leq 10000,2 \leq m \leq 10^5,1 \leq c \leq 10000$，至少 有两段道路有限高杆。

蓝桥杯 2020 第三轮省赛 AB 组 H 题。

## 样例 #1

### 输入

```
5 7
1 2 1 0
2 3 2 1
1 3 9 0
5 3 8 0
4 3 5 1
4 3 9 0
4 5 4 0```

### 输出

```
6```

# 题解

## 作者：carp_oier (赞：14)

# 题意分析

在这个题中我们可以知道，如果这条路有限高杆的话，那么就不允许同行，但是如果没有则可以通行。

限高杆最多只可以拆两个。

有了这两个条件我们就可以从集合的角度进行分析（这样子可以保证不重不漏）：

- 首先，我们在面对一个杆的时候我们会有两种决策：
	
   1. 我当前拆卸的杆数还没有到达 2，那么我可以拆掉这个杆子并通行。
   
   2. 我不愿意拆这个杆子（不论我拆的数量是否到达 2），那么我就直接跳过，然后绕路走。

- 之后，如果我们面对的是一个没有杆子的道路：

	3. 我直接对这个最短路进行常规操作，正常更新。
    
分析到这里，大家大概也就明白，这是一个分层图的题，或者可以是一个动态规划 + 最短路的题目，具体做法看个人癖好。（我个人喜欢对分层图的题全部当成动态规划 + 最短路）。

最后需要留个心眼，比如说它拆了这条路的限高杆，但是这条路比其他路加起来还要长，这样子拆了还不如不拆，所以说，最后答案我们需要在这个拆一个和拆两个里面取最小值，然后我们再用一次也不拆的最小值减去这个最小值，就得到我们的正确答案了。

下面则是给那些自己敲了一遍，不断检查代码~~但是还是感觉是题目的问题（“多对的代码啊~可它就是不对~”）~~ 的同学们的一些小帮助。

# CODE TIME	

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rl register ll

const ll N = 1e4 + 10, M = 2e5 + 10;

ll n, m;

ll tot, ne[M], e[M], h[N], w[M], dis[N][3], sta[M];

bool st[N][3];

struct node
{
	ll id, dis, type;
	bool operator <(const node &x) const
	{
		return dis > x.dis;
	}
};

priority_queue<node> q;

inline void add(ll a, ll b, ll c, ll d)
{
	ne[++tot] = h[a], h[a] = tot, e[tot] = b, w[tot] = c, sta[tot] = d;
}

inline void dij(ll s)
{
	memset(dis, 0x3f, sizeof dis);
	memset(st, 0, sizeof st);
	
	dis[s][0] = dis[s][1] = dis[s][2] = 0;
	
	q.push({s, 0, 0});
	
	while(q.size())
	{
		node asd = q.top();
		q.pop();
		ll u = asd.id, t = asd.type, dist = asd.dis;
		if(st[u][t]) continue;
		st[u][t] = 1;
		for(rl i=h[u]; ~i; i = ne[i])
		{
			ll v = e[i];
			if(sta[i] && t <= 1)
			{
				if(dis[v][t + 1] > dis[u][t] + w[i])
				{
					dis[v][t + 1] = dis[u][t] + w[i];
					q.push({v, dis[v][t + 1], t + 1});
				}
				else continue;
			}else if(!sta[i]) 
			{
				if(dis[v][t] > dis[u][t] + w[i])
				{
					dis[v][t] = dis[u][t] + w[i];
					q.push({v, dis[v][t], t});
				}
			}
		}
	}
}

int main()
{
	memset(h, -1, sizeof h);
	
	cin >> n >> m;
	
	for(rl i=1; i <= m; ++ i)
	{
		ll a, b, c, d;
		cin >> a >> b >> c >> d;
		add(a, b, c, d), add(b, a, c, d);
	}
	
	dij(1);
	
	cout << dis[n][0] - min(dis[n][1], dis[n][2]) << endl;
	return 0;
}
```


 完结撒花~感谢支持我的题解（高情商的人应该都懂我的意思）

---

## 作者：Shanganze (赞：8)

显然，是一道分层图板题，但黄是不是有点过分了。

如果一条路有限高杆就不能走。一共可以拆除两道限高杆，那我们就可以建三层图。每一层图中的道路表示不拆除限高杆的道路，层与层之间将这条道路上的限高杆拆除。每向下走一层，就相当于拆除了一条限高杆。

建图部分：如果这条道路没有限高杆，就在就在每一层中相连；有限高杆就在相邻两层连边。

#### 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct a1{
	int nex,to,dis;
}x[4000001];
int dis[400001],head[400001],p=0,v[400001];
void add(int a,int b,int c){
	x[++p].nex=head[a];
	x[p].to=b;
	x[p].dis=c;
	head[a]=p;
	return ;
}
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*f;
}
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >z;
int pre[1000001];
signed main(){
	int n,m;
	n=read();m=read();
	for(int q=1;q<=m;q++){
		int a,b,c,d;
		a=read();b=read();c=read();d=read();
		if(d==1){//有限高杆
			add(a,b+n,c);//第一层和第二层相连，注意是从上往下连，第一层中的a和第二层中的b相连，第一层中的b和第二层中的a相连。
			add(b,a+n,c);
			add(b+n,a+n+n,c);//同上
			add(a+n,b+n+n,c);
		}
		else{//无限高杆
			add(a,b,c);
			add(b,a,c);
			add(b+n,a+n,c);
			add(a+n,b+n,c);
			add(b+n+n,a+n+n,c);
			add(a+n+n,b+n+n,c);
		}
	}
	fill(dis,dis+1+n*3,1e9);//三层图三倍数组初始化
	z.push(make_pair(0,1));
	dis[1]=0;
	while(!z.empty()){
		int i=z.top().second;
		z.pop();
		if(v[i])continue;
		v[i]=1;
		for(int q=head[i];q;q=x[q].nex){
			int o=x[q].to;
			if(dis[o]>dis[i]+x[q].dis){
				dis[o]=dis[i]+x[q].dis;
				pre[o]=i;
				z.push(make_pair(dis[o],o));
			}
		}
	}//单源最短路模板
	cout<<dis[n]-min(dis[n*3],min(dis[n],dis[n*2]));;//注意最短路不一定要拆两个限高杆
	return 0;
}
```


---

## 作者：Wy_x (赞：4)

题目传送门：[P8724 [蓝桥杯 2020 省 AB3] 限高杆](https://www.luogu.com.cn/problem/P8724)


------------

### 解决方法：

基本思想是分层图，但提供一个与众不同的做法（双倍经验 [P1849](https://www.luogu.com.cn/problem/P1849)）。

定义两个队列 $q,q_2$，其中，$q$ 是跑 Dijkstra 所用的队列，$q_2$ 记录有限高杆的路通向的点和距离（具体实现参考代码）。

邻接表存图，多开一个 $D$ 记录这条路上是否有限高杆。

加点操作：
```cpp
void add(int a,int b,int c,int d)
{//加点操作
	E[a].push_back(b);
	V[a].push_back(c);
	D[a].push_back(d);
}
```

在 Dijkstra 开始前，清空 $q$，把 $q_2$ 中的值附到 $q$ 中，同时更新从起点到 $q_2$ 中的点的最小距离，实现如下：

```cpp
void copy_queue()
{
	while(!q.empty()) q.pop();
	while(!q2.empty()) q.push(q2.top()),dis[q2.top().second]=min(dis[q2.top().second],q2.top().first),q2.pop();
	//同时更新dis记录的最短路（类似延时更改）
}
```

Dijkstra 函数中，

- 传入一个参数 $cnt$，记录拆了几条限高杆。
- 扩展边时，如果这条路有限高杆，就把它存入 $q_2$，中；反之，进行 Dijkstra 的松弛操作。
- 结束时，更新起点到终点的最短路。

```cpp
void dij(int cnt)
{
	memset(vis,0,sizeof(vis));
	//清空vis数组
	copy_queue();//把 q_2 附给 q
	
	while(q.size())
	{
		int x=q.top().second;
		q.pop();
		
		if(vis[x]) continue;//到过这个节点
		vis[x]=1;//记录
		
		for(int i=0;i<E[x].size();i++)
		{
			int k=E[x][i];
			int w=V[x][i];
			int d=D[x][i];
			
			if(d) q2.push(make_pair(min(dis[k],dis[x]+w),k));
			//注意把长度取min，否则拆除后最短路无法保证
			else if(dis[k]>dis[x]+w)//松弛操作
			{
				dis[k]=dis[x]+w;
				q.push(make_pair(dis[k],k));
			}
		}
	}
	maxn=max(maxn,dis[n]);//这里是记录没拆限高杆时的最短路
	minn=min(minn,dis[n]);//拆限高杆后的最短路
	if(cnt<2) dij(cnt+1);//没拆够两个限高杆，继续拆。
}
```


------------

### 完整代码：
```cpp
#include<bits/stdc++.h>
#define reg register
#define int long long
using namespace std; 
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q,q2;

int n,m;
vector<int> E[100005],V[100005];
vector<int> D[100005];
int maxn=-999999999,minn=9999999999;
int dis[1<<20];
bool vis[1<<20];

void copy_queue()
{
	while(!q.empty()) q.pop();
	while(!q2.empty()) q.push(q2.top()),dis[q2.top().second]=min(dis[q2.top().second],q2.top().first),q2.pop();
	//同时更新dis记录的最短路（类似延时更改）
}

void add(int a,int b,int c,int d)
{//加点操作
	E[a].push_back(b);
	V[a].push_back(c);
	D[a].push_back(d);
}

void dij(int cnt)
{
	memset(vis,0,sizeof(vis));
	//清空vis数组
	copy_queue();//把 q_2 附给 q
	
	while(q.size())
	{
		int x=q.top().second;
		q.pop();
		
		if(vis[x]) continue;//到过这个节点
		vis[x]=1;//记录
		
		for(int i=0;i<E[x].size();i++)
		{
			int k=E[x][i];
			int w=V[x][i];
			int d=D[x][i];
			
			if(d) q2.push(make_pair(min(dis[k],dis[x]+w),k));
			//注意把长度取min，否则拆除后最短路无法保证
			else if(dis[k]>dis[x]+w)//松弛操作
			{
				dis[k]=dis[x]+w;
				q.push(make_pair(dis[k],k));
			}
		}
	}
	maxn=max(maxn,dis[n]);//这里是记录没拆限高杆时的最短路
	minn=min(minn,dis[n]);//拆限高杆后的最短路
	if(cnt<2) dij(cnt+1);//没拆够两个限高杆，继续拆。
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	//加速
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		add(a,b,c,d);
		add(b,a,c,d);
	}
	
	memset(dis,0x3f,sizeof(dis));
	//初始化dis为无穷大
	dis[1]=0;
	q2.push(make_pair(dis[1],1));
	//往q_2中加入起点，
	//经过copy_queue()后就在 q 中了
	dij(0);//从不拆限高杆开始枚举
	
	cout<<maxn-minn;
	return 0;
}
```



---

## 作者：Eleveslaine (赞：3)

前置知识：单源最短路。

---

分层图最短路。

所谓分层图，就是把原图复制共 $k$ 份（本题中 $k=3$），得到的第 $i(0 \le i < k)$ 张图称为第 $i$ 层（第 $0$ 层即原图去掉特殊边得到的图），再在这些层中间视具体情况加边。一般适用于处理对边有特殊需求的情况，例如本题中的“限高杆”或者 [P4568](https://www.luogu.com.cn/problem/P4568) 中的“免费乘坐”（该题目也是典型的分层图）。然后跑最短路即可解决问题。

具体地，设原图中的点 $u$ 在第 $i(0\le i < 3)$ 层的结点编号为 $u+ni$，其中 $n$ 为点数。在本题中，若边 $(u,v,w,d)$ 的 $d=0$，则直接在每层内部加双向边，即加边 $(u+ni,v+ni,w,d),\forall i \in [0,3)$；否则 $d=1$，则需要加**单向**边 $(u+ni,v+n(i+1),w,d)$ 和 $(v+ni,u+n(i+1),w,d),\forall i\in[0,2)$。之所以加单向边，是因为显然不能也没有必要在同一方向上经过同一条限高路段两次，换言之经过的层编号连续且单调不降。

举个例子，样例建出的分层图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/yqmj1wjo.png)

其中实线边是层内部的边，虚线边是层之间的边。注意虚线边是单向的。

建完图以后跑以 $1$ 为起点的最短路即可。注意本题要求能减少多长距离，所以要先求原图中 $1$ 到 $n$ 最短路（设为 $p$），再求分层图最短路（设为 $q$），则答案为 $p-q$。

需要注意的是，分层图最短路并不一定以点 $3n$ 为终点，点 $n,2n$ 或 $3n$ 都可以作为终点（因为并不要求两条必须经过去除限高的路，也就是说不一定要走到第 $2,3$ 层），所以 $q=\min\{\mathrm{dist}_n,\mathrm{dist}_{2n},\mathrm{dist}_{3n}\}$，其中 $\mathrm{dist}$ 是单源最短路的结果数组，即 $\mathrm{dist}_u$ 表示 $1$ 到 $u$ 的最短路长度。

**更新：这里取 $\boldsymbol{q=\bold{min}\{\bold{dist}_{2n},\bold{dist}_{3n}\}}$ 也可以通过原数据，对此有 hack 数据，见[此贴](https://www.luogu.com.cn/discuss/673920)。**

求原图中 $1$ 到 $n$ 最短路时，我们给每条边记录 $d$，如果 $d=1$ 那么在第一次 dijkstra 时直接 `continue;` 即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> ints;
const int maxn=31005,maxm=2000005,inf=0x3f3f3f3f;
struct Edge
{
    int next,to,w;
    bool d;
} edge[maxm];
int n,m,u,v,w,d,cnt=1,head[maxn];
inline void add(int u,int v,int w,bool d)
{
    edge[++cnt].to=v;
    edge[cnt].w=w;
    edge[cnt].next=head[u];
    edge[cnt].d=d;
    head[u]=cnt;
}
priority_queue <ints,vector<ints>,greater<ints>> q;
int dist[maxn];
bool vis[maxn];
void dijkstra(int s,bool f)
{
    memset(dist,0x3f,sizeof(dist));
    memset(vis,0,sizeof(vis));
    dist[s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int u=q.top().second;
        q.pop();
        if(vis[u])
            continue;
        vis[u]=1;
        for(int i=head[u];i;i=edge[i].next)
        {
            if(!f && edge[i].d)
                continue;
            int v=edge[i].to;
            if(dist[v]>dist[u]+edge[i].w)
            {
                dist[v]=dist[u]+edge[i].w;
                if(!vis[v])
                    q.push(make_pair(dist[v],v));
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin >> n >> m;
    while(m--)
    {
        cin >> u >> v >> w >> d;
        if(d==0)
            for(int i=0;i<3;++i)
                add(u+n*i,v+n*i,w,d),add(v+n*i,u+n*i,w,d);
        else
            for(int i=0;i<2;++i)
                add(u+n*i,v+n*(i+1),w,d),add(v+n*i,u+n*(i+1),w,d);
    }
    dijkstra(1,0);
    int p=dist[n];
    dijkstra(1,1);
    int q=min({dist[n],dist[2*n],dist[3*n]});
    cout << p-q << endl;
    return 0;
}
```

---

## 作者：chenhaoyou (赞：2)

## 大意
货车要从 $1$ 号点开到 $n$ 号点，有限高杆的路走不了，能拆掉两个限高杆，问拆除前后的路程之差最大为多少。
## 分析
很明显这是一道最短路的题（如果最短路不知道的看这个，[最短路](https://blog.csdn.net/jahup/article/details/106982608?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169007464916800188592767%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169007464916800188592767&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106982608-null-null.142^v90^insert_down28v1,239^v3^insert_chatgpt&utm_term=bellmam-ford&spm=1018.2226.3001.4187)，大佬写的特别好 orz），问题就在于拆杆，这里有一点 dp 的思想，我们把不拆杆，拆一个杆，和拆两个杆分为三个不同的状态，在 $dist$ 数组里面分别存储，最短路时从 $1$ 号点开始扫，如果当前的路有一个限高杆，那么把结果存在拆一个杆的状态里，如果有两个限高杆，那么把结果存在拆两个杆的状态里，没有就存在没拆的状态里，如果超过两个就直接跳过，其余的求最短路的过程和模板一样，这样最短路时的参数会比较多，不过更清晰，这里我使用了 dijkstra 加堆优化来求最短路。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n,m,x,y,z,d[11111][3],w,w1;//后面一维表示拆掉几个杆
bool vis[111111][3],b;
struct f{
	int i,s;
	bool b;//i 是编号，s 是边权，b 是这条路上有没有杆子
};
vector<f> a[111111];
void dji()
{
	memset(d,127,sizeof(d));
	priority_queue<pair<int,pair<int,int> >,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > q;//三个参数分别是，最短路长度，目前拆了几个杆，当前节点的编号
	d[1][0]=0;
	q.push({0,{0,1}});
	while(q.size())//模板，只差了一维
	{
		w=q.top().second.second;
		w1=q.top().second.first;
		q.pop();
		if(vis[w][w1]) continue;
		vis[w][w1]=1;
		for(int i=0;i<a[w].size();i++)
		{
			if(a[w][i].b+w1>2) continue;//如果拆了超过两根杆就直接跳过
			if(d[a[w][i].i][a[w][i].b+w1]>d[w][w1]+a[w][i].s)
			{
				d[a[w][i].i][a[w][i].b+w1]=d[w][w1]+a[w][i].s;
				q.push({ d[a[w][i].i][a[w][i].b+w1] , {a[w][i].b+w1 , a[w][i].i } });
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z>>b;
		a[x].push_back((f){y,z,b});
		a[y].push_back((f){x,z,b});//别忘了建双向图
	}
	dji();
	cout<<d[n][0]-min(d[n][1],min(d[n][2],d[n][0]));//求不拆杆和拆杆时路程的最大差值
	return 0;
}

```


---

## 作者：junee (赞：1)

# P8724 题解

## 前置知识

单源最短路，分层图思想。

## 题目分析

这是一道最短图的题，我们可以考虑使用 dijkstra 算法来求最短路。

当有限高杆时就无法通过，最多只能拆除两个限高杆，所以我们可以建三层图来解决这个问题，然后跑 dijkstra 算法就可以解决问题了。

本题的难点在于建图，这里放出我建图的代码。

```cpp
if(!d){//当d=0时，说明没有限高杆，所以正常建图 
	add(a,b,c),add(b,a,c);
	add(a+n,b+n,c),add(b+n,a+n,c);
	add(a+n*2,b+n*2,c),add(b+n*2,a+n*2,c);
}
else{//当有限高杆时，第一层跟第二层连边，第二层和第三层连边 
	add(a,b+n,c),add(b,a+n,c);
	add(a+n,b+n*2,c),add(b+n,a+n*2,c);
}
```

## AC 代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
typedef pair<int,int>PII;
const int N=1e5+10,M=6*N;//分层图要空间要多开！！！ 
int h[N],e[M],ne[M],w[M],idx;
int dist[N];
bool st[N];
void add(int a,int b,int c){//邻接表建图 
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dijkstra(){//dijkstra算法 
	memset(dist,0x3f,sizeof dist);
	memset(st,0,sizeof st);
	priority_queue<PII,vector<PII>,greater<PII> >heap;
	dist[1]=0;
	heap.push({0,1});
	while(heap.size()){
		int ver=heap.top().second;
		heap.pop();
		if(st[ver])continue;
		st[ver]=1;
		for(int i=h[ver];~i;i=ne[i]){
			int j=e[i];
			if(dist[j]>dist[ver]+w[i]){
				dist[j]=dist[ver]+w[i];
				heap.push({dist[j],j});
			}
		}
	}
}
int n,m;
int main(){
	cin>>n>>m;
	memset(h,-1,sizeof h);//初始化 
	for(int i=1;i<=m;i++){
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		if(!d){//当d=0时，说明没有限高杆，所以正常建图 
			add(a,b,c),add(b,a,c);
			add(a+n,b+n,c),add(b+n,a+n,c);
			add(a+n*2,b+n*2,c),add(b+n*2,a+n*2,c);
		}
		else{//当有限高杆时，第一层跟第二层连边，第二层和第三层连边 
			add(a,b+n,c),add(b,a+n,c);
			add(a+n,b+n*2,c),add(b+n,a+n*2,c);
		}
	}
	dijkstra();
	int minn=min(dist[n*2],dist[n*3]);//求出拆除一个限高杆和两个限高杆后的最小值 
	cout<<dist[n]-minn;//与原来的距离做差 
	return 0;
}
```

---

## 作者：Maysoul (赞：1)

这题可以通过建立**分层图**来求解，[分层图模板题](https://www.luogu.com.cn/problem/P4568)。

分层图并不难，只需要把图建好即可。

一共可以拆两条路的限高杆，那我们就建三层图，分别是不拆的，拆一条的，拆两条的。每向下走一层，就等于拆了一条限高杆。

先看没有杆的情况，在这种情况下，我们是不会多拆的，之前拆了几条还是几条，故每层内部正常连边即可。

当有杆的时候，我们就联通每一层的上下。注意有一种情况是拆而不走，需要额外枚举一次建出边，但是这题不用考虑这种情况。因为你拆了不走不是白白浪费一次机会？当然做别的分层图题的时候要小心这种情况。

然后跑一遍 Dijkstra 即可，这里不再赘述。

还有注意输出的时候，两根都拆不一定是最优解，故最优解应该是三层图的终点的最小值。

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
const int INF=0x3f3f3f3f;
int num,ans;
int n,m,s,t,k; 
struct node{
	int id;
	int dist;
	node()
	{
		id=0;dist=0;
	}
	node(int c,int d)
	{
		id=c;dist=d;
	}
	bool operator < (const node &x)const
	{
		return x.dist<dist;
	}
};
priority_queue<node> que;
struct linkstar{//链式前向星存图
	int to,from;
	int w;
	int next;
}edge[11000000];
int head[11000000];
int dis[11000000];
bool vis[11000000];
int escnt;
void add(int from,int to,int w)
{
	edge[escnt].from=from;
	edge[escnt].to=to;
	edge[escnt].w=w;
	edge[escnt].next=head[from];
	head[from]=escnt;
	escnt++;
}
void Dijkstra(int u)//Dijkstra最短路
{
	memset(dis,0x3f,sizeof(dis));
	dis[u]=0;
	que.push(node(u,0));
	while(que.size())
	{
		node cp=que.top();
		que.pop();
		if(vis[cp.id]) continue;
		vis[cp.id]=true;
		for (int i=head[cp.id];i!=-1;i=edge[i].next)
		{
			if(dis[edge[i].to]>dis[cp.id]+edge[i].w)
			{
				dis[edge[i].to]=dis[cp.id]+edge[i].w;
				//cout<<dis[edge[i].to]<<endl;
				que.push(node(edge[i].to,dis[edge[i].to]));
				
			}
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	cin>>n;
	cin>>m;
	for (int i=0;i<m;i++)
	{
		int x,y,w;
		bool flag=0;
		cin>>x>>y>>w;
		cin>>flag;
		if(flag)//如果拆，就联通上下两层
		{
			add(x,y+n,w);
			add(y,x+n,w);
			add(x+n,y+n+n,w);
			add(y+n,x+n+n,w);
		}
		else//如果不拆，就在本层内连边
		{
			add(x,y,w);
			add(y,x,w);
			add(x+n,y+n,w);
			add(y+n,x+n,w);
			add(x+n+n,y+n+n,w);
			add(y+n+n,x+n+n,w);	
		}
	}
	Dijkstra(1);
	cout<<dis[n]-min(dis[n+n+n],min(dis[n+n],dis[n]))<<endl;
	return 0;
}


```







---

## 作者：Yoimiyamwf (赞：0)

# 题意
给定一张无向图，其中若干条边在初始时不能通过，求去除其中至多2条边的限制，从 $1$ 号点到 $n$ 号点的最短路径最多缩短的值。

# 分析
本题显然是一个分层图最短路。在 dijkstra 算法的优先队列中，额外维护一个当前已通过的被限制的边数。

设 $cost_{i,j}$ 是从 $1$ 号点出发，拆除 $j$ 个限高杆，到达点 $i$ 的最短距离，当前节点为 $u$，从它出发的一条边的目标节点为 $v$，路径长为 $w$，当前已拆除 $k$ 个限高杆，则：

- 如果边上没有限制，则 $cost_{v,k} \gets \operatorname{min}(cost_{v,k},cost_{u,k}+w)$

- 如果边上有限制，且 $k\le1$，则 $cost_{v,k+1} \gets \operatorname{min}(cost_{v,k+1},cost_{u,k}+w)$

这样跑完最短路后，容易发现最终答案即为 $cost_{n,0}-\operatorname{min}(cost_{n,1},cost_{n,2})$。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int id,cost,t;
};
bool operator <(node a,node b){
	return a.cost>b.cost;
}
priority_queue <node> q;
struct Edge{
	int nex,to,cost;
	bool h;
}edge[2000010];
bool vis[1000010][3];
int n,m,a,b,c,d,cost[1000010][3],k,head[1000010],tot,id,ans;
void addEdge(int from,int to,int cost,int d){
	tot++;
	edge[tot].to=to;
	edge[tot].nex=head[from];
	edge[tot].cost=cost;
	head[from]=tot;
	edge[tot].h=d;
}
void dij(){
	memset(cost,0x3f,sizeof(cost));
	cost[1][0]=0;
	q.push({1,0,0});
	while(!q.empty()){
		id=q.top().id,k=q.top().t;
		q.pop();
		if(vis[id][k]) continue;
		vis[id][k]=true;
		for(int i=head[id];i;i=edge[i].nex){
			if(edge[i].h+k<=2&&cost[edge[i].to][edge[i].h+k]>cost[id][k]+edge[i].cost){
				cost[edge[i].to][edge[i].h+k]=cost[id][k]+edge[i].cost;
				q.push({edge[i].to,cost[edge[i].to][edge[i].h+k],edge[i].h+k});
			}
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a>>b>>c>>d;
		addEdge(a,b,c,d);
		addEdge(b,a,c,d);
	}
	dij();
	ans=min(cost[n][2],cost[n][1]);
	cout<<cost[n][0]-ans;
	return 0;
}
```


---

## 作者：ryf_loser (赞：0)

分层图板子，尽管调了我~~一个小时~~。

# 题目大意

给你 $n$ 个点，$m$ 条边，有些边能走，有些边不能走，如果可以最多恢复原来两条边，那么从 $1$ 到 $n$ 的最短距离最多减少多少？ 

# 题目解答

此题用分层图解答最妙，可以设第一层图表示不恢复边，第二层图表示恢复一条边，第三层图表示恢复两条边。

如果本来就可以走，那么同层连边，和正常图一样，表示可以到达；如果本来有限高杆，那么从一层往二层连边，表示从恢复零条边到恢复一条边，需要恢复一条，二层往三层连边，表示从恢复一条边到恢复二条边，需要恢复一条。直接跑最短路即可。

AC CODE

```cpp
#include<cstdio>
#include<queue>
using namespace std;
inline int in(){
	int x=0,f=1;char c;
	c=getchar();
	while (c<'0'||c>'9'){
		if (c=='-')f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
struct edge{int to,nex,dis;}w[4000001];
int head[4000001],id,n,m,dis[4000001];
bool vis[4000001];
inline void add(int u,int v,int d){
    w[++id].dis=d;
   	w[id].to=v;
    w[id].nex=head[u];
    head[u]=id;
}
struct node{
    long long dis;int pos;
    bool operator<(const node &x)const{return x.dis<dis;}
};
priority_queue<node> q;
inline void dijkstra(){//最短路板子
    for (int i=3*n;i>=1;i--)dis[i]=1e9;
    dis[1]=0;q.push({0,1});
    while(!q.empty()){
        int x=q.top().pos;
        q.pop();
        if(vis[x])continue;
        vis[x]=1;
        for (int i=head[x];i;i=w[i].nex){
            int y=w[i].to;
            if(dis[y]>dis[x]+w[i].dis){
            	dis[y]=dis[x]+w[i].dis;
                q.push({dis[y],y});
            }
        }
    }
}
int main(){
    n=in(),m=in();
    while (m--){
    	int u=in(),v=in(),d=in(),w=in();
        if (w==1){//本来不可以走情况
			add(u,v+n,d);add(v,u+n,d);
			add(u+n,v+n+n,d);add(v+n,u+n+n,d);
		}
		else {//本来就可以走情况
			add(u,v,d);add(v,u,d);
			add(u+n,v+n,d);add(v+n,u+n,d);
			add(u+n+n,v+n+n,d);add(v+n+n,u+n+n,d);
		}
    }
    dijkstra();
    printf ("%d",dis[n]-min(dis[n],min(dis[n+n],dis[n+n+n])));//直接求解
    return 0;
}
```

# 结语

~~抢到最优解~~ 。

~~109 ms~~

---

## 作者：allqpsi (赞：0)

### 这道题很简单。

用最短路可以简单通过。

关于 SPFA，他死了。所以我们来用 Dijkstra 算法来解决这个问题。

我们可以简单的发现我们可以用拆限高杆后的最短距离减不拆限高杆的最短距离。

问题来了，我们怎么记录拆的限高杆呢？

其实，我们可以每拆一个限高杆后加 $n$。按照题目，最多可以拆两个限高杆。所以我们可以在建路时让有限高杆的路到路口编号加 $n$ 的路口。再在加 $n$ 的路上加上一个到路口编号加两个 $n$ 的路口。最后，再做最短路。

#### 让人激动的代码来了：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
	bool operator<(node l)const{
		return l.y<y;
	}
};
priority_queue<node>qi;
vector<node>vi[300005];
int n,m,a,b,c,d,di[30005];
bool vis[30005];
void dij(){
	memset(vis,false,sizeof(vis));
	memset(di,127,sizeof(di));
	di[1]=0;
	qi.push(node{1,0});
	while(!qi.empty()){
		int x=qi.top().x;
		qi.pop();
		if(vis[x]){
			continue;
		}
		for(int i=0;i<vi[x].size();i++){
			int a=vi[x][i].x,b=vi[x][i].y;
			if(di[a]>di[x]+b){
				di[a]=di[x]+b;
				qi.push(node{a,di[a]});
			}
		}
		vis[x]=true;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&a,&b,&c,&d);
		if(d==0){
			vi[a].push_back(node{b,c});
			vi[b].push_back(node{a,c});
			vi[a+n].push_back(node{b+n,c});
			vi[b+n].push_back(node{a+n,c});
			vi[a+n+n].push_back(node{b+n+n,c});
			vi[b+n+n].push_back(node{a+n+n,c});
		}
		else{
			vi[a].push_back(node{b+n,c});
			vi[b].push_back(node{a+n,c});
			vi[a+n].push_back(node{b+n+n,c});
			vi[b+n].push_back(node{a+n+n,c});
		}
	}
	for(int i=1;i<=n;i++){
		vi[a].push_back(node{a+n,0});
		vi[a+n].push_back(node{a+n+n,0});
	}
	dij();
	if(di[n]-min(di[n*2],di[n*3])<0){
		cout<<0;
		return 0;
	}
	cout<<di[n]-min(di[n*2],di[n*3]);
}
```

感谢 Franz_Liszt 提供的 hack 数据，已改正。

---

## 作者：CodingShark (赞：0)

显然是分层图最短路的板子题，拆两段限高杆，因此建 3 层图。

如果一条道路没有限高杆，则：

- 第一层在 $u, v$ 之间连双向边

- 第二层在 $u, v$ 之间连双向边

- 第三层在 $u, v$ 之间连双向边

如果一条道路有限高杆，则：

- 第一层 $u$ 与第二层 $v$ 连边

- 第一层 $v$ 与第二层 $u$ 连边（注意无向图，一定是双向边！！）

- 第二层 $u$ 与第三层 $v$ 连边

- 第三层 $v$ 与第二层 $u$ 连边（注意无向图，一定是双向边！！）

当然在实际跑最短路路时不需要明确分层，用 $u,u+n,u+2n$ 表示这三层的节点就可以了。

但是注意到就算拆了限高杆货车也可能不走那条道路，所以相邻两层直接对应的点也需要连一条边权为 0 的边。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct Edge
{
    int u, v, w, next;
} e[1000005];
struct state
{
    int dis, v;
    bool operator<(const state t) const
    {
        return dis > t.dis;
    }
};
int n, m, pos, head[100005], dis[100005];
bool vis[100005];
void addEdge(int u, int v, int w)
{
    e[++pos] = {u, v, w, head[u]};
    head[u] = pos;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int u, v, w, op;
        scanf("%d%d%d%d", &u, &v, &w, &op);
        if (op & 1)
        {
            addEdge(u, v + n, w);
            addEdge(v, u + n, w);
            addEdge(u + n, v + 2 * n, w);
            addEdge(v + n, u + 2 * n, w);
        }
        else
        {
            addEdge(u, v, w);
            addEdge(v, u, w);
            addEdge(u + n, v + n, w);
            addEdge(v + n, u + n, w);
            addEdge(u + 2 * n, v + 2 * n, w);
            addEdge(v + 2 * n, u + 2 * n, w);
        }
    }
    for (int i = 1; i <= n; i++)
    {
        addEdge(i, i + n, 0);
        addEdge(i + n, i + 2 * n, 0);
    }
    dij(1); // Dijkstra 最短路，就不用贴上来了吧
    printf("%d", dis[n] - dis[3 * n]); // dis[n] 是原图最短路
    return 0;
}
```




---


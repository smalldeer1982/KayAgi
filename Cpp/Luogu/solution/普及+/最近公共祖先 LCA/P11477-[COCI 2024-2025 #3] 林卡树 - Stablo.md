# [COCI 2024/2025 #3] 林卡树 / Stablo

## 题目背景


译自 [COCI 2024/2025 #3](https://hsin.hr/coci/) T4。$\texttt{2s,0.5G}$。满分为 $120$。


## 题目描述


给定 $n$ 个节点的有根树，根节点为 $1$。点 $i$ 的点权为 $v_i$。

定义函数 

$$f(y)=\sum_{x\in \operatorname{subtree}(y)} \operatorname{dist}(x,y)\cdot v_x$$

其中，$\operatorname{subtree}(y)$ 表示 $y$ 的子树内所有点构成的集合（包括 $y$），$\operatorname{dist}(x,y)$ 表示 $x,y$ 之间的最短路径上的边数。换言之，$f(y)$ 是 $y$ 子树内所有点的点权乘以到 $y$ 的距离求和。

有 $q$ 次操作，每次操作给定两个节点 $x,y$。在一次操作中：

- 将 $x$ 的所有儿子接到 $x$ 的父亲上；
- 将 $x$ 删掉；
- 令 $y$ 的儿子中，包含 $x$ 的为 $z$。将 $x$ 插入到 $y$ 和 $z$ 之间。
- 求出 $f(y)$。

保证 $x\in \operatorname{subtree}(y)$，且 $x\neq y$。特别地，若 $y$ 是 $x$ 的父亲，则原树的形态保持不变。

需要注意的是，**操作之间相互独立**。也就是说，每次操作都是在初始形态的树上操作（而不是在上一次操作的基础上操作）。



## 说明/提示



### 样例解释

样例 $1$ 中，操作后，有 $\operatorname{dist}(1,3)=1,\operatorname{dist}(1,2)=2$。所求为 $3+2\cdot 2=7$。

### 数据范围


对于 $100\%$ 的数据，保证：

- $1\le n,q\le 5\times 10^5$；
- $1\le v_i\le 10^6$；
- $1\le p_i\lt i$；
- $1\le x,y\in n$；
- $x\neq y$，$x\in \operatorname{subtree}(y)$。


| 子任务编号 | $n,q\le$ |  特殊性质 | 得分 |  
| :--: | :--: | :--: |:--: | 
| $ 1 $    | $10^3$ |  |   $ 21 $   |  
| $ 2 $    | $5\times 10^5$ | A  |  $ 37 $   |  
| $ 3 $    | $5\times 10^5$ | B  |  $ 22 $   |  
| $ 4 $    | $5\times 10^5$ |  |  $ 40 $   |  

- 特殊性质 A：树的形态是链。换言之，$p_i=i-1$。
- 特殊性质 B：每个节点最多有 $20$ 个儿子。



## 样例 #1

### 输入

```
3 1
1 2 3
1 2
3 1```

### 输出

```
7```

## 样例 #2

### 输入

```
3 2
4 5 6
1 1
2 1
3 1```

### 输出

```
11
11```

## 样例 #3

### 输入

```
5 3
2 5 2 2 2
1 2 3 2
4 3
3 2
5 1```

### 输出

```
2
8
26```

# 题解

## 作者：cengzh (赞：6)

[传送门](https://www.luogu.com.cn/problem/P11477)

虽然重交了几次了，但真不是故意的，错误好难找，辛苦管理员了。

#

考虑将 $f(x)$ 转化为更好求得的形式。

记 $dep_p$ 为 $p$ 到根节点的距离，$v_p$ 为 $p$ 的点权。

对于节点 $x$，令其子树内所有点为 $a_1,a_2,$ $\dots$ $,a_n$。

于是有：

$$ f(x) = v_{a_1} \times (dep_{a_1} - dep_x) + v_{a_2} \times (dep_{a_2} - dep_x) + \ldots + v_{a_n} \times (dep_{a_n} - dep_x)$$

将括号拆开，得：

$$f(x) = v_{a_1} \times dep_{a_1} + v_{a_2} \times dep_{a_2} + \ldots + v_{a_n} \times dep_{a_n} - \sum_{i=1}^n v_{a_i} \times dep_x$$

在这个式子中，有非常多的不变量，我们只用预处理三个量。

1. 深度 $dep_p$ 
2. 减号前这一串式子，记为 $tot_p$ 
3.  $\sum_{i=1}^n v_{a_i}$，记为 $sum_p$（$p$ 子树内节点点权和）

即可求 $f(x)$。

现在回到查询，我们简要概括这个操作：

给出 $(x,y)$，将 $x$ 沿父亲不断上移成 $y$ 的儿子，$x$ 的所有儿子由 $x$ 的原父亲继承，求 $f(y)$。

我们尝试找到一些结论：

* 结论1：对于 $x$，其子树内所有节点产生的贡献不变。

  证明：对于 $x$ 子树内的每个节点，$x$ 上移后，深度仍不变，点权亦不变，那么贡献不变。

* 结论2：对于 $y$ 包含 $x$ 的子树的根节点 $y_{son}$，$x$ 上移后，整体贡献加 $(sum_{y_{son}} + v_{y_{son}}) -( sum_x + v_x)$。

  证明：记 $y$ 包含 $x$ 的子树内所有**非 $x$ 子树内节点**的节点为 $b_1,b_2 \ldots b_m$，对于 $i \in [1,m]$，容易证明 $x$ 上移后 $b_i$ 到 $y$ 的距离加 $1$，那么这部分的贡献就多了 $\sum_{i=1}^m v_{b_i}$。

  容易得：

   $$\sum_{i=1}^m v_{b_i} = (sum_{y_{son}} + v_{y_{son}}) -( sum_x + v_x)$$


有了这两个结论，结合 $x$ 上移对 $x$ 本身贡献的影响，求 $f'(y)$ 就很简单了。

$$f'(y) = f(y) + (sum_{y_{son}} + v_{y_{son}}) -( sum_x + v_x) + v_x  - v_x \times (dep_x - dep_y)$$

整理得：

$$f'(y) = f(y) + sum_{y_{son}} + v_{y_{son}} - sum_x - v_x \times (dep_x - dep_y)$$

由数据范围想到要用 $O(n \log n)$ 时间复杂度的算法。

题目的优化关键在求 $y_{son}$，我们使用倍增法。

预处理 $O(n)$，查询 $O(q)$，每次查询 $O(\log n)$
 找子树。

总时间复杂度为 $O(n + q \log n)$。

以下为代码：


```c
# include <stdio.h>
# include <stdlib.h>

struct Node
{
	int p;
	struct Node* next;
}; 

struct Head
{
	struct Node* next;
};

struct Head p[500005];
long long val[500005]; 
long long tot[500005];
long long dep[500005];
long long sum[500005];
long long f[500005];
int father[500005][22];
int cur;

struct Node* ini()
{
	struct Node* tmp = (struct Node*) malloc (sizeof(struct Node)); 
	tmp->next = NULL;
	return tmp;
}

void add(int u,int fa)
{
	struct Node* tmp = ini();
	tmp->p = u;
	tmp->next = p[fa].next;
	p[fa].next = tmp;
	return ;
}

void dfs(int u,int fa)
{
	dep[u] = dep[fa]+1;
	cur++;
	
	father[u][0] = fa;
	
	for (int i=1;i<21;i++)
	{
		father[u][i] = father[father[u][i-1]][i-1];
	}
	
	for (struct Node* tmp=p[u].next;tmp!=NULL;tmp=tmp->next)
	{
		int v = tmp->p;
		if (v == fa)
		{
			continue;
		}
		dfs(v,u);
		tot[u]+=tot[v]+val[v]*dep[v];
		sum[u]+=sum[v]+val[v]; 
	}
	f[u] = tot[u]-sum[u]*dep[u];

	return ;
}

int get_root(int x, int y)
{
    int k = 20;
    while (k >= 0)
    {
        if (dep[father[x][k]] >= dep[y]+1) 
    		{
            x = father[x][k];
        }
        k--;
    }
    return x;
}

int main (void)
{
	int n,q;
	scanf ("%d %d",&n,&q);
	
	for (int i=1;i<=n;i++)	
	{
		scanf ("%d",&val[i]);
		p[i].next = NULL;
	}
	
	for (int i=2;i<=n;i++)
	{
		int fa;
		scanf ("%d",&fa);
		add(i,fa);
	}
	
	dfs(1,1); 
	
	for (int i=1;i<=q;i++)
	{
		int x,y;
		scanf ("%d %d",&x,&y);
		int son = get_root(x,y);
		printf ("%lld\n",f[y]+sum[son]+val[son]-sum[x]-val[x]*(dep[x]-dep[y]));	//
	}
	
	return 0;
} 
```

---

## 作者：yinbe (赞：1)

## 题目

定义函数 $f(y)$ 为根为 $y$ 的子树内所有点的点权乘以到 $y$ 的距离求和，每次给定 $x,y$ 然后操作：

- 将 $x$ 的所有儿子接到 $x$ 的父亲上；
- 将 $x$ 作为原来 $y$ 中包含 $x$ 的子树的根，原来的根变为它的儿子。

每次求操作后的 $f(y)$，操作之间互相独立。

## 思路

考虑预处理原来的 $f(y)$，然后每次考虑操作后对 $f(y)$ 的影响。

定义 $z$ 为原来 $y$ 中包含 $x$ 的子树的根，$depth_{x}$ 表示 $x$ 的深度，$sum_{x}$ 表示以 $x$ 为根的子树的点权和。

预处理 $f(y)$：从 $f(son_{y})$ 到 $f(y)$，以 $son_{y}$ 为根的子树到 $y$ 的距离全部会加 $1$，相当于就是加上 $sum_{son_{y}}$，所以 $f(y)=\sum\limits_{i\in son_{y}}(f(i)+sum_{i}))$。

计算操作后对 $f(y)$ 的影响：如图，上图为操作前，下图为操作后。

![](https://cdn.luogu.com.cn/upload/image_hosting/h029lm62.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/cg2ojod9.png)

$x$ 的深度从 $depth_{x}$ 变为 $depth_{y}+1$ ，深度减少了 $depth_{x}-depth_{y}-1$，所以对 $f(y)$ 的贡献减少了 $v_{x}\times (depth_{x}-depth_{y}-1)$。一开始以 $x$ 为根的子树接到了 $x$ 的父亲上，所以它们的深度会减 $1$，对 $f(y)$ 的贡献减少了 $sum_{x}$。 $x$ 插入使得以 $z$ 为根的子树所有节点深度加 $1$，对 $f(y)$ 的贡献增加了 $sum_{z}$。

所以操作后的 $f'(y)=f(y)-v_{x}\times (depth_{x}-depth_{y}-1)-sum_{x}+sum_{z}$。

## 代码

```cpp
#include<iostream>
using namespace std;
const int N=5e5+5,M=5e5+5;
int n,q,head[N],nxt[M<<1],ver[M<<1],depth[N],fa[N][20],tot;
long long v[N],sum[N],f[N];
int LOG2[N];
void dfs(int x,int fath,int d)
{
	depth[x]=d;
	sum[x]=v[x];
	for(int i=1;i<=LOG2[d];i++)
		fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=head[x];i;i=nxt[i])
	{
		int y=ver[i];
		if(y!=fath)
		{
			dfs(y,x,d+1);
			sum[x]+=sum[y];
			f[x]+=f[y]+sum[y];
		}
	}
}
int LCA_son(int x,int y)
{
	if(depth[x]<depth[y])
		swap(x,y);
	while(depth[x]-1!=depth[y])
	{
		int cha=depth[x]-depth[y]-1;
		x=fa[x][__builtin_ctz(cha)];
	}
	if(fa[x][0]==y)
		return x;
	x=fa[x][0];
	for(int i=LOG2[depth[x]];i>=0;i--)
	{
		int nowx=fa[x][i];
		int nowy=fa[y][i];
		if(nowx!=nowy)
		{
			x=nowx;
			y=nowy;
		}
	}
	return x;
}
void add(int x,int y)
{
	tot++;
	ver[tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
int main()
{
	scanf("%d%d",&n,&q);
	LOG2[1]=0;
	for(int i=2;i<=n;i++)
		LOG2[i]=LOG2[i>>1]+1;
	for(int i=1;i<=n;i++)
		scanf("%lld",&v[i]);
	for(int i=2;i<=n;i++)
	{
		scanf("%d",&fa[i][0]);
		add(i,fa[i][0]);
		add(fa[i][0],i);
	}
	dfs(1,0,0);
	while(q--)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(fa[x][0]==y)
		{
			printf("%lld\n",f[y]);
			continue;
		}
		int z=LCA_son(x,y);  
		printf("%lld\n",f[y]-(depth[x]-depth[y]-1)*v[x]+(sum[z]-sum[x]));
	}
	return 0;
}
```

---

## 作者：hao_zi6366 (赞：1)

## 题目分析
记 $sum_u$ 为 $u$ 节点子树内的点权和，$dep_u$ 为节点 $u$ 的深度（根节点深度为 $1$），$val_u$ 为节点 $u$ 的权值。

可以预处理出一开始时所有节点的 $f(u)$。
$$
f(u)=\sum_{v\in subtree(u)}f(v)+sum_u-val_u
$$
现在考虑每次修改，以下图的树，当修改 $3$ 号节点和 $1$ 号节点时为例：
![](https://cdn.luogu.com.cn/upload/image_hosting/2g3d2hcu.png)

红色区域是 $3$ 号节点的所有儿子，蓝色区域是 $3$ 号节点和 $1$ 号节点之间的点，黄色是  $1$ 号节点的其他儿子。

修改后：

![](https://cdn.luogu.com.cn/upload/image_hosting/fj7eobnq.png)

发现：
- 红色区域和黄色区域对 $f(1)$ 的贡献并无变化
- 蓝色区域的所有节点多加了一次
- $3$ 节点的贡献减少了 $(dep_3-dep_1)$ 次

若修改 $x$ 节点和 $y$ 节点，记 $y$ 的儿子中，包含 $
x$ 的为 $z$ 节点。  
那么得到 
$$
f'(y)=f(y)+(sum_z-sum_x)-(dep_y-dep_x-1)\times val_x
$$
倍增求 $z$ 即可。
## 完整代码
```cpp
#include<bits/stdc++.h>
typedef long long LL;
const int N=5e5+5;
int val[N],fa[N],dep[N],t[N][22],lg[N];
LL sum[N],f[N];
std::vector<int> G[N];
void dfs(int u,int ff){
    sum[u]=val[u];
    dep[u]=dep[ff]+1;
    t[u][0]=ff;
    for(int i=1;i<=lg[dep[u]];i++){
        t[u][i]=t[t[u][i-1]][i-1];
    }
    for(int v:G[u]){
        if(v==ff)continue;
        dfs(v,u);
        sum[u]+=sum[v];
        f[u]+=f[v];
    }
    f[u]+=(sum[u]-val[u]);
}
int findz(int x,int y){//倍增求z
    for(int i=lg[dep[x]];i>=0;i--){
        if(dep[t[x][i]]>dep[y])x=t[x][i];
    }
    return x;
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cout.tie(nullptr);
    std::cin.tie(nullptr);

    int n,q;
    std::cin>>n>>q;
    for(int i=2;i<=n;i++){
        lg[i]=lg[i/2]+1;
    }
    for(int i=1;i<=n;i++){
        std::cin>>val[i];
    }
    for(int i=2;i<=n;i++){
        std::cin>>fa[i];
        G[i].push_back(fa[i]);
        G[fa[i]].push_back(i);
    }
    dfs(1,0);
    while(q--){
        int x,y;
        std::cin>>x>>y;
        if(fa[x]==y){//特判x为y的儿子
            std::cout<<f[y]<<"\n";continue;
        }
        int z=findz(x,y);
        std::cout<<f[y]-(dep[x]-dep[y]-1)*val[x]+(sum[z]-sum[x])<<"\n";
    }
    return 0;
}

```

---

## 作者：Hy13_xsm (赞：0)

## 题意

题目已经把关键步骤很清晰地描述出来了，这里不多赘述。

## Solution

将思路聚焦到操作上。因为每次操作都具有独立性，不要求在线，所以题目难度已经减了大半。可以发现，每次第一步操作后子树的深度减 $1$，所以考虑初始化 $s$ 数组表示每个数对应的子树（包含自己）的 $f$ 值之和，求出 $s_z-s_x+f_y$ 就求到了没有操作前的 $f$，然后可以发现后面又把 $x$ 点插入到了子树前面的位置，所以子树的深度不变，也就没有其他要考虑的了。

初始化操作是从根节点 $1$ 开始的，所以求 $s_z-s_x$ 时其实还有一部分多余，需要减掉前面一段的 $f$ 值。

接下来的问题就是如何快速求出 $z$。一个一个跳的时间复杂度是 $O(n)$，所以可以采用倍增的方法，如果跳 $2^i$ 个过后深度还比 $y$ 低那就继续尝试跳 $2^{i-1}$ 个，否则跳过继续尝试，直到最后就可以成功找到 $z$ 点。

## AC 代码


```cpp
#include<bits/stdc++.h>
#define N 500005
#define int long long
using namespace std;
int n,q,v[N],d[N],s[N],f[N],dp[N][25];
vector<int>g[N];
void dfs(int u,int fa)
{
	dp[u][0]=fa;
	d[u]=d[fa]+1;
	s[u]=v[u];
	for(int i=0;i<g[u].size();i++)
	{
		int to=g[u][i];
		if(to==fa)continue;
		dfs(to,u);
		s[u]+=s[to];
		f[u]+=s[to]+f[to];
	}
}
int calc(int x,int y)
{
	for(int i=20;i>=0;i--)
	{
		if(d[dp[x][i]]>d[y])
		x=dp[x][i];
	}
	return x;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)
	cin>>v[i];
	for(int i=2;i<=n;i++)
	{
		int x;
		cin>>x;
		g[x].push_back(i);
	}
	dfs(1,0);
	for(int j=1;j<=20;j++)
	{
		for(int i=1;i<=n;i++)
		dp[i][j]=dp[dp[i][j-1]][j-1];
	}//倍增，不是动态规划！
	for(int i=1;i<=q;i++)
	{
		int x,y;
		cin>>x>>y;
		int z=calc(x,y);
		if(z==x)cout<<f[y]<<endl;//特判
		else cout<<s[z]-s[x]+f[y]-(d[x]-d[y]-1)*v[x]<<endl;
	}
	return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

首先，对于这种奇怪操作，我们应该找到操作的本质。

这个操作不难看出是把 $x$ 放到 $y$ 的儿子的位置，$x,y$ “之间”的点往下顺延，$x$ 子树里的不动。

由于每次操作独立，不难想到预处理之后每次在算。

考虑预处理 $f$ 函数，$f(u)=\sum\limits_{s\in\operatorname{subtree(u)}} f(s)+v_s$（距离多了 $1$（经过 $(u,v)$ 这条边）所以都加上 $v_s$）。

考虑修改后的 $f(y)'$ 和之前的区别。

首先 $y$ 祖先部分以及祖先的其他子树不需要考虑。

其次 $y$ 中的非 $x$ 的子树（即除了 $z$ 以外的儿子对应的子树）都没变。

考虑 $z$ 子树内：显然上面 $(z,y)$ 变成 $(x,y),(x,z)$ 多了一条边，所以加上 $\sum\limits_{u\in \operatorname{subtree(z)}}v_u$，但是 $x$ 子树内并不符合上面的式子，所以减去 $\sum\limits_{u\in \operatorname{subtree(x)}}v_u$。

考虑 $x$ 子树内不包含 $x$，上面虽然多了一条边，但是下面少了一条，不变。

考虑 $x$，$\operatorname{dist}(x,y)\to 1$，一共减去了 $\operatorname{dist}(x,y)-1$。

剩下的问题就是找 $z$，显然 $z$ 是 $x$ 的祖先，可以倍增、树剖求（也可以用 DFS 序）。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
constexpr int N=5e5+1;
int n,q,v[N],sum[N],siz[N],top[N],vis[N],son[N],dep[N],fa[N],f[N];
vector<int>e[N];
void add(int u,int v){
    e[u].push_back(v);
    return;
}
int dfs_siz(int u){
    int maxs=-1;
    siz[u]=1,dep[u]=dep[fa[u]]+1;
    for(auto v:e[u]){
        if(fa[u]==v)
            continue;
        siz[u]+=dfs_siz(v);
        if(siz[v]>maxs)
            maxs=siz[v],son[u]=v;
    }
    return siz[u];
}
int dfs_sum(int u){
    sum[u]=v[u];
    for(auto v:e[u]){
        if(fa[u]==v)
            continue;
        sum[u]+=dfs_sum(v);
    }
    return sum[u];
}
void dfs_chain(int u,int tp){
    top[u]=tp;
    if(son[u])
        dfs_chain(son[u],tp);
    for(auto v:e[u]){
        if(v==fa[u]||v==son[u])
            continue;
        dfs_chain(v,v);
    }
    return;
}
int finds(int x,int y){
    int last=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]>dep[top[y]])
            last=top[x],x=fa[top[x]];
    }
    return x==y?last:son[y];
}
int dfs_ans(int u){
    f[u]=0;
    for(auto v:e[u]){
        if(v==fa[u])
            continue;
        f[u]+=dfs_ans(v)+sum[v];
    }
    return f[u];
}
signed main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++)
        cin>>v[i];
    for(int i=2;i<=n;i++){
        cin>>fa[i];
        add(i,fa[i]),add(fa[i],i);
    }
    dfs_siz(1),dfs_sum(1),dfs_chain(1,1),dfs_ans(1);
    for(int x,y,z;q;--q){
        cin>>x>>y;
        z=finds(x,y);
        cout<<f[y]+(sum[z]-sum[x])-(dep[x]-dep[y]-1)*v[x]<<'\n';
    }
    return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P11477 题目](https://www.luogu.com.cn/problem/P11477)

### 解题思路
首先我们可以对于每个操作的每个步骤进行分析：

- 将 $x$ 的所有儿子接到 $x$ 的父亲上并将 $x$ 删除的操作可以认为是将 $x$ 的子树内所有节点的深度减少 $1$。
- 将 $x$ 插入到 $y$ 和 $z$ 之间的操作可以认为是将 $z$ 的子树内所有节点的深度增加 $1$，并将 $x$ 的深度修改为 $dep_y+1$。

由于节点 $x$ 一定满足 $x\in \operatorname{subtree}(z)$，所以任意节点 $i$ 若满足 $i\in \operatorname{subtree}(x)$，则一定满足 $i\in \operatorname{subtree}(z)$。

于是不难发现 $x$ 的子树内的每个节点的深度先减少了 $1$，又增加了 $1$，即深度没有改变，于是一整个操作就可以视为将所有满足 $i\in \operatorname{subtree}(z)$ 且 $i\not\in \operatorname{subtree}(x)$ 的节点 $i$ 的深度增加 $1$，并将 $x$ 的深度减少 $dep_x-dep_y-1$。

即将原来的 $f(y)$ 增加：

$$\sum_{i\in \operatorname{subtree}(z)}v_i-\sum_{i\in \operatorname{subtree}(x)}v_i-(dep_x-dep_y-1)\times v_x$$

在 $q$ 次操作前，我们可以提前计算出 $dep_i$ 和  $f(i)$，并对于每个节点 $i$ 将 $\sum_{j\in \operatorname{subtree}(i)}v_j$ 计算出来。

对于 $z$ 的计算方法，可以用 LCA 中使用的倍增法快速求出。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<int> g[500001];
int v[500001],zh[500001],dep[500001],s[500001];
inline void dfs(int x,int fa)
{
	s[x]=v[x];
	for(auto u:g[x])
	{
		if(u!=fa)
		{
			dfs(u,x);
			zh[x]+=zh[u]+s[u],s[x]+=s[u];
		}
	}
}
int f[500001][21];
void dfs2(int n,int sh)
{
	f[n][0]=sh;
	int t=2,i=1;
	while(t<=dep[n])
	{
		f[n][i]=f[f[n][i-1]][i-1];
		i++,t=t*2;
	}
	for(int u:g[n])
	{
		if(u!=sh)
		{
			dep[u]=dep[n]+1;
			dfs2(u,n);
		}
	}
}
inline int qs(int x,int sh)
{
	int now=x,i=0;
	while(sh)
	{
		if(sh%2==1)
			now=f[now][i];
		sh/=2,i++;
	}
	return now;
}
signed main()
{
	ios::sync_with_stdio(false);
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=n;i++)
		cin>>v[i];
	for(int i=2;i<=n;i++)
	{
		int x;
		cin>>x;
		g[i].push_back(x),g[x].push_back(i);
	}
	dep[1]=1;
	dfs(1,0),dfs2(1,0);
	while(q--)
	{
		int x,y;
		cin>>x>>y;
		int now=zh[y]-(dep[x]-dep[y]-1)*v[x]+(s[qs(x,dep[x]-dep[y]-1)]-s[x]);
		cout<<now<<"\n";
	}
	return 0;
}
```

---

## 作者：_ayaka_ (赞：0)

### 思路

简单分析一下题面，发现如果树不改变，$f(x)$ 是可以预处理出来的。叶节点的 $f(x)$ 为 $0$，这是显然的。同时通过 DFS 可以求出一个点的子树累加的和 $num$。假设 $x$ 的所有儿子组成一个集合 $\operatorname{son}(x)$，那么 $f(x)$ 即为：

$$f(x)=(\sum_{i\in \operatorname{son}(x)} f(i) ) + num_x-v_x$$

那我们就可以预处理出所有的 $f(x)$ 了。

操作互相独立，因此不用真的操作，更改答案即可。对于每一次的操作，我们先记录这一次的答案 $ans=f(y)$，再进行分析：

- 将 $x$ 的所有儿子接到 $x$ 的父亲上，那就相当于让所有 $x$ 的子树上的点的 $\operatorname{dist}-1$，只需将 $ans$ 加上 $num_x$ 再减去 $v_x$ 即可。
- 将 $x$ 删掉，我们要提前记录每个点的深度 $d$，那这里只需减去 $(d_x-d_y) \times v_x$ 就可以了。
- 令 $y$ 的儿子中，包含 $x$ 的为 $z$。将 $x$ 插入到 $y$ 和 $z$ 之间。这里先是要求出 $z$，整一个倍增从 $x$ 跳到比 $y$ 的深度大 $1$ 的点即可。然后这个操作相当于加了一个 $x$，并让除 $x$ 以外在 $z$ 的子树上的所有点的 $\operatorname{dist}+1$，这两者结合就等价于让 $ans+num_z$。
- 求出 $f(y)$。输出求出的 $ans$ 即可。

注意若 $y$ 是 $x$ 的父亲，则原树的形态保持不变。所以若 $z=x$，直接输出 $f(y)$ 就行了。时间复杂度 $O(n\log n)$。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int q, n, v[500005], x, y, num[500005], sum[500005], f[50][500005], d[500005], ans, z;
struct edge {
	int to, nxt;
} t[2000005];
int h[500005], cnt;
void addedge(int u, int v) {
	t[++cnt] = {v, h[u]};
	h[u] = cnt;
}
void dfs(int u) {
	for (int i = 1; i <= 25; i++) {
		f[i][u] = f[i - 1][f[i - 1][u]];
	}//倍增 
	for (int i = h[u]; i; i = t[i].nxt) {
		int v = t[i].to;
		f[0][v] = u;
		d[v] = d[u] + 1;
		dfs(v);
		num[u] += num[v];
		sum[u] += sum[v];
	}
	sum[u] = sum[u] + num[u] - v[u];
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		num[i] = v[i];
	}
	for (int i = 1; i < n; i++) {
		cin >> x;
		addedge(x, i + 1);
	}
	dfs(1);
	for (int i = 1; i <= q; i++) {
		ans = 0;
		cin >> x >> y;
		ans += sum[y];
		z = x;
		for (int i = 25; i >= 0; i--) {
			if (d[f[i][z]] > d[y]) z = f[i][z];
		}//倍增找z 
		if (z == x) cout << ans << "\n";//特判 
		else {
			ans += num[z];
			ans -= num[x]-v[x];
			ans -= (d[x] - d[y]) * v[x];
			cout << ans << "\n";
		}
	}
	return 0;
}
```

---


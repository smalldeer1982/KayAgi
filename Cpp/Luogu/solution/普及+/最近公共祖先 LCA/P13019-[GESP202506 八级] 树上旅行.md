# [GESP202506 八级] 树上旅行

## 题目描述



给定一棵有 $ n $ 个结点的 **有根树**，结点依次以 $1,2,\dots,n$ 编号，其中根结点的编号为 $1$。

小 A 计划在这棵有根树上进行 $q$ 次旅行。在第 $i$ 次旅行中，小 A 首先选定结点 $s_i$ 作为起点，并移动若干次。移动分为以下两种：

1. 移动至当前结点的父结点。特殊地，如果当前位于根结点，则不进行移动。
2. 移动至当前结点的所有子结点中**编号最小**的结点。特殊地，如果当前位于叶子结点，则不进行移动。

由于移动次数可能很大，对于第 $i$ 次旅行，旅行中的移动以 $k_i$ 个不为零的整数构成的序列 $a_{i,1}, a_{i,2}, \dots, a_{i,k_i}$ 表示。对 $a_{i,j}$，若 $a_{i,j} > 0$ 则代表进行 $a_{i,j}$ 次第一种移动；若 $a_{i,j} < 0$ 则代表进行 $-a_{i,j}$ 次第二种移动。根据给出的序列从左至右完成所有移动后，小 A 所在的结点即是旅行的**终点**。

给定每次旅行的起点与移动序列，请你求出旅行终点的结点编号。


## 说明/提示



| 子任务编号 | 测试点占比 | $n$ | $q$ | $\sum k_i$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|:-:|
| $1$          | $20\%$         | $\leq 100$ | $\leq 100$ | $\leq 1000$ | 保证 $a_{i,j}$ 为 $1$ 或 $-1$ |
| $2$          | $20\%$         | $\leq 10^4$ | $\leq 10^4$ | $\leq 4 \times 10^4$ | 仅包含第一种移动 |
| $3$          | $20\%$         | $\leq 10^4$ | $\leq 10^4$ | $\leq 4 \times 10^4$ | 仅包含第二种移动 |
| $4$          | $40\%$         | $\leq 10^5$ | $\leq 2 \times 10^4$ | $\leq 10^5$ | - |

对于所有测试点，保证：

- $1 \leq n \leq 10^5$
- $1 \leq q \leq 2 \times 10^4$
- $1 \leq p_i \leq n$
- $1 \leq s_i \leq n$
- $k_i \geq 1$ 且 $\sum k_i \leq 10^5$
- $1 \leq |a_{i,j}| \leq n$


## 样例 #1

### 输入

```
5 4
1 1 2 2
3 3
1 -1 -1
2 5
1 -1 1 -1 1
5 8
1 1 1 -1 -1 -1 -1 -1
5 3
-1 -1 1```

### 输出

```
4
1
4
2```

## 样例 #2

### 输入

```
8 3
5 4 2 1 3 6 6
8 1
8
8 2
8 -8
8 3
8 -8 8```

### 输出

```
1
7
1```

# 题解

## 作者：songge888 (赞：11)

### 题意

给定一棵有根树（根为 1 号点），有 $q$ 次查询。每次从某个起点 $s$ 出发，按照指令 $a_{i,j}$ 移动：

- $a_{i,j}>0$：向上走 $a_{i,j}$ 步（即走到 $a_{i,j}$ 级祖先）。
- $a_{i,j}<0$：向下走 $a_{i,j}$ 步，每一步都选择**当前点所有子节点中编号最小的那个**继续走。

输出每次操作后停在的最终结点编号。

## 思路

注意到 $\sum a_{i,j}$ 最大可以到 $2 \times 10^9$，考虑倍增。

设 $f_{x,j}$ 表示结点 $x$ 向上跳 $2^j$ 步后的位置，则：
$$
f_{x,j}=f_{f_{x,j-1},j-1}
$$
设 $s_{x,j}$ 表示结点 $x$ 向下跳 $2^j$ 步后的位置，则：
$$
s_{x,j}=s_{s_{x,j-1},j-1}
$$
为了具体实现，我们可以先建一棵树（这里叫 `g`）。

然后对于每个点 $u$，对所有 $u$ 的子节点 $v$ 从小到大排序。

这样 `g[u][0]` 便是节点 $u$ 向下走的字节点。

之后分别向下和向上倍增即可。

### 代码

```c++
#include<bits/stdc++.h>
#define int long long
#define double long double
#define bug cout<<"___sgge888___"<<'\n';
using namespace std;
int n,m;
int f[100005][20];
int s[100005][20];
vector<int>g[100005];
int dep[100005];
void dfs(int u,int fa){
    dep[u]=dep[fa]+1;
    f[u][0]=fa;
    if(!g[u].empty()){
        s[u][0]=g[u][0];
    }
    else{
        s[u][0]=u;
    }
    for(auto v:g[u]){
        dfs(v,u);
    }
}
void init(){
    for(int j=1;j<20;j++){
        for(int i=1;i<=n;i++){
            if(f[i][j-1]!=0){
                f[i][j]=f[f[i][j-1]][j-1];
            }
        }
    }
    for(int j=1;j<20;j++){
        for(int i=1;i<=n;i++){
            s[i][j]=s[s[i][j-1]][j-1];
        }
    }
}
int up(int u,int k){
    if(u==1){
        return 1;
    }
    int dis=dep[u]-1;
    if(k>=dis){
        return 1;
    }
    for(int i=0;i<20;i++){
        if((k>>i)&1){
            u=f[u][i];
        }
    }
    return u;
}
int down(int u,int k){
    for(int i=0;i<20;i++){
        if((k>>i)&1){
            u=s[u][i];
        }
    }
    return u;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=0;j<20;j++){
            s[i][j]=i;
        }
    }
    f[1][0]=0;
    for(int i=2;i<=n;i++){
        int p;
        cin>>p;
        f[i][0]=p;
        g[p].push_back(i);
    }
    for(int i=1;i<=n;i++){
        sort(g[i].begin(),g[i].end());
    }
    dfs(1,0);
    init();
    for(int i=1;i<=m;i++){
        int u,k;
        cin>>u>>k;
        int ans=u;
        for(int j=1;j<=k;j++){
            int x;
            cin>>x;
            if(x>0){
                ans=up(ans,x);
            }
            else{
                x=-x;
                ans=down(ans,x);
            }
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：u822844 (赞：10)

## 序言
萌新第一篇题解，将分享一种与全部已有题解不同的方案（类似链式拆分，考场做法）。

## 题意简述
给定一颗有根树，树上执行允许执行多次旅行，每次旅行有一个两种操作组成的序列：
1. 重复多次移动到父节点（在根节点时位置不变）；
2. 重复多次移动到编号最小子节点（在叶子节点时位置不变）。

求旅行结束后的位置。

## 部分分一
考虑暴力做法，预存每一个节点的父节点和最靠左字节点，递归 $k$ 次直接执行查找。
核心代码：
```cpp
int up(int s,int c){
    if(c==0||s==1)return s;
    return up(parent[s],c-1);
}
int down(int s,int c){
    if(c==0||son[s]==INT_MAX)return s;
    return down(son[s],c-1);
}
```
```cpp
for(int i=2;i<=n;i++){
    cin>>parent[i];
    if(i<son[parent[i]])son[parent[i]]=i;
}
```

## 部分分二
尝试把树拆分为一条条链：维护一个 map 作为节点到链的映射，遍历每一个节点，检查当前节点是否在链上，如果在链上则跳过，否则依次查找它的首个子节点，将子节点加入到链中，直到叶子节点。

因为每一次创建都会**一次性**找到叶子节点，而且不能从已经位于链上的节点创建链，所以每个节点都一定对应且只对应一条链，如此存储合适。
![](https://cdn.luogu.com.cn/upload/image_hosting/qe5m2q6f.png)
如图，考虑题目样例二

1. 从 $1$ 开始构建
    - $1$ 的唯一子节点是 $5$ ,添加 $5$
    - $5$ 的唯一子节点是 $2$ ,添加 $2$
    - 以此类推，分别加入 $4,3,6$
    - $6$ 的两个子节点中，$7$ 编号较小，选择它加入
    - $7$ 没有子节点，退出
    - 构建出第一条链（同时标记了这些节点的对应第一条链）：$1\rightarrow5\rightarrow2\rightarrow4\rightarrow3\rightarrow6\rightarrow7$
2. $8$ 以前所有节点都被标记，全部跳过
3. 从 $8$ 开始构建
    - $8$ 没有子节点，退出
    - 构建出第二条链（并标记 $8$ 在第二条链上）：$8$

核心代码：
```cpp
for(int i=1;i<=n;i++){
    if(!down_mp.count(i)){
        vector<int>c_chain;
        int s=down_chains.size();
        int idx=0;
        for(int node=i;node!=INT_MAX;node=son[node]){
            c_chain.push_back(node);
            down_mp[node]={s,idx++};//idx:保存在链上的编号，便于查询
        }
        down_chains.push_back(c_chain);
    }
}
```

对于查询处理：
1. 对于向下的查询，直接从表中找出对应的链和链上位置，加上移动量并移动（如果超过链长度说明在叶子节点，就移动至链尾）；
2. 对于向上的查询，从表中找出对应的链和位置，减去移动量后，如果是有效索引就直接移动，如果超出链范围则暴力查找（后文考虑跳链）

核心代码：
```cpp
if(op>0){
    auto c_chain=down_chains[down_mp[s].first];
    int idx=down_mp[s].second-op;
    if(idx<0){
        s=up(c_chain[0],-idx);//暴力处理剩余部分
    }else{
        s=c_chain[idx];
    }
}else if(op<0){
    op=-op;
    auto c_chain=down_chains[down_mp[s].first];
    int pos=down_mp[s].second+op;
    if(pos>=c_chain.size()){
        s=c_chain.back();
    }else{
        s=c_chain[pos];
    }
}
```
[可得部分分](https://www.luogu.com.cn/record/222020898)

## 正解
在上一部分的做法中，对于无法在一条链中处理完的移动，会"回退"到暴力查找，进而超时。

因为链首节点（根除外）不是最小子节点，所以预处理时会把它另外分一条链。

由此，我们可以尝试在每一条链中尽可能多的向上查找如果仍有剩余步数停在链头，就从链头节点的父节点所在链继续查找，直到用完步数或到达根。

核心代码：
```cpp
if(op > 0) {
    while(op > 0 && s != 1) {
        auto& c_chain = down_chains[down_mp[s].first];
        int steps = min(op, down_mp[s].second);
        
        if(steps > 0) {
            s = c_chain[down_mp[s].second - steps];
            op -= steps;
        } else {
            op--;
            s =  parent[c_chain[0]];
        }
    }
}
```
[可得满分](https://www.luogu.com.cn/record/222367059)

## 常数优化
因为每一个节点都**一定属于**唯一的一条链，所以可以把链对应表 down_mp 外层改为静态数组而非 map，down_chains 同理。

[AC记录](https://www.luogu.com.cn/record/222367848)及完整代码附上：
```cpp
#include<bits/stdc++.h>
using namespace std;
int parent[100005];
int son[100005];
pair<int,int> down_mp[100005]; 
int n,q;
vector<int> down_chains[100005];  
int chain_count = 0;  

int main() {
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);
    
    cin >> n >> q;
    parent[1] = 0;
    for(int i = 0; i <= n+1; i++) son[i] = INT_MAX;
    for(int i = 2; i <= n; i++) {
        cin >> parent[i];
        if(i < son[parent[i]]) son[parent[i]] = i;
    }
    
    for(int i = 1; i <= n; i++) {
        if(down_mp[i].first == 0 && down_mp[i].second == 0) { 
            int s = chain_count++;
            int idx = 0;
            for(int node = i; node != INT_MAX; node = son[node]) {
                down_chains[s].push_back(node);
                down_mp[node] = {s, idx++};
            }
        }
    }
    
    while(q--) {
        int s, k, op;
        cin >> s >> k;
        while(k--) {
            cin >> op;
            if(op > 0) {
                while(op > 0 && s != 1) {
                    auto& c_chain = down_chains[down_mp[s].first];
                    int steps = min(op, down_mp[s].second);
                    
                    if(steps > 0) {
                        s = c_chain[down_mp[s].second - steps];
                        op -= steps;
                    } else {
                        op--;
                        s = parent[c_chain[0]];
                    }
                }
            } else if(op < 0) {
                op = -op;
                auto& chain_info = down_mp[s];
                auto& c_chain = down_chains[chain_info.first];
                int pos = chain_info.second + op;
                if(pos >= c_chain.size()) {
                    s = c_chain.back();
                } else {
                    s = c_chain[pos];
                }
            }
        }
        cout << s << endl;
    }
    return 0;
}
```

---

## 作者：XCDRF_ (赞：3)

# P13019 [GESP202506 八级] 树上旅行 题解

[题目链接](https://www.luogu.com.cn/problem/P13019)

[转至专栏阅读](https://www.luogu.com.cn/article/6y5wg9mm)

## 解题思路

将题目转化一下，操作 $1$ 就是从一个点向上跳 $x$ 次，操作 $2$ 就是从一个点向下跳 $x$ 次。观察到 $x$ 比较大，如果直接一步一步跳显然会超时。这时我们可以选择倍增。首先预处理出从一个点开始向上和向下跳 $2^k$ 步后会跳到哪里，然后用类似快速幂的方式跳，将 $x$ 二进制分解，如果当前位是 $0$ 就不跳，如果当前位是 $1$ 就跳。时间复杂度 $O(k\log n)$。

写代码时注意一下边界情况的处理。

## 参考代码

```cpp
#include<iostream>
using namespace std;
const int N=1e5+5;
int n,q;
int fa[N][20],ch[N][20];
int get1(int s,int x){
	int nw=0;
	while(x){
		if(x&1) s=fa[s][nw];
		nw++;
		x>>=1;
	}
	return s;
}
int get2(int s,int x){
	int nw=0;
	while(x){
		if(x&1) s=ch[s][nw];
		nw++;
		x>>=1;
	}
	return s;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) ch[i][0]=1e9;
	fa[1][0]=1;//根节点，不往上跳
	for(int i=2,x;i<=n;i++){
		cin>>x;
		ch[x][0]=min(ch[x][0],i);//算出当前节点向下跳一步会跳到哪里
		fa[i][0]=x;//向上跳一步到父亲
	}
	for(int i=1;i<=n;i++)
		if(ch[i][0]==1e9) ch[i][0]=i;//如果该节点是叶子节点，就不往下跳了
	for(int j=1;j<=18;j++)
		for(int i=1;i<=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1],ch[i][j]=ch[ch[i][j-1]][j-1];
	for(int i=1,s,x;i<=q;i++){
		cin>>s>>x;
		for(int j=1,v;j<=x;j++){
			cin>>v;
			if(v>0) s=get1(s,v);
			else s=get2(s,-v);
		}
		cout<<s<<'\n';
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/221858521)

---

## 作者：hjyowl (赞：1)

### 思路

首先，对于向上爬的，考虑直接使用倍增记录祖先然后每次跳上去即可。

关键是往下的怎么做。

注意到，我们可以使用类似重链剖分的思想，我们定义小儿子链为链上的每个点都是他父节点中编号最小的儿子构成的一条链，这样我们通过搜索就会得到很多条这样的小儿子链，记录一下小儿子链和上面的点信息。然后我们每次往下跳的时候只要找到该点属于的小儿子链然后往直接输出下跳 $k$ 次后的值即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long N = 100010, M = 20;
vector<long long> vec[N];
long long n, m;
long long id[N];
map<pair<long long, long long>, long long> mp, mpp;
long long fa[N][M];
long long now = 0;
long long sz[N];
void dfs(long long u, long long cnt) {
    id[u] = now;
    sz[now]++;
    mp[{now, cnt}] = u;
    mpp[{now, u}] = cnt;
    if (vec[u].size()) {
        dfs(vec[u][0], cnt + 1);
    }
}
int main() {
    cin >> n >> m;
    for (long long i = 2; i <= n; i++) {
        long long x;
        cin >> x;
        vec[x].push_back(i);
        fa[i][0] = x;
    }
    for (long long i = 0; i < M; i++) {
        fa[1][0] = 1;
    }
    for (long long i = 1; i <= n; i++) {
        sort(vec[i].begin(), vec[i].end());
    }
    for (long long i = 1; i <= n; i++) {
        if (!id[i]) {
            now++;
            dfs(i, 1);
            // cout << sz[now] << " " << id[i] << endl;
        }
    }
    for (long long j = 1; j < M; j++) {
        for (long long i = 1; i <= n; i++) {
            fa[i][j] = fa[fa[i][j - 1]][j - 1];
        }
    }
    while (m--) {
        long long s, k;
        cin >> s >> k;
        for (long long i = 1; i <= k; i++) {
            long long x;
            cin >> x;
            if (x > 0) {
                long long tt = x;
                for (long long j = M - 1; j >= 0; j--) {
                    if (tt >= (1 << j)) {
                        s = fa[s][j];
                        tt -= (1 << j);
                    }
                }
            } else {
                x = -x;
                long long c = id[s];
                // cout << c << endl;
                long long t = mpp[{c, s}];
                // cout << t << endl;
                s = mp[{c, min(sz[c], x + t)}];
            }
        }
        cout << s << endl;
    }
    return 0;
}
```

---

## 作者：liyancen (赞：1)

# 解题报告
可以发现 $\sum k_i=10^5$，自然而然地想到使用倍增。根据题目描述，发现会有两个操作，一个是向父亲节点移动，一个是向儿子编号最小的一个点移动，那么很自然就会想到维护两个倍增数组，一个向上跳，一个向下跳。

那么我们要注意一下这两个维护的时间，很显然，我们要先维护向上跳的，然后向下递归，再维护向下跳的。

```cpp
void dfs(int x,int fa){
	depth=max(depth,deep[x]);
	for (int i=1;(1<<i)<=deep[x]-1;i++){
		dp1[x][i]=dp1[dp1[x][i-1]][i-1];
	}
	int len=mp[x].size(),minn=INT_MAX;
	for (int i=0;i<len;i++){
		int t=mp[x][i];
		if (t==fa)continue;
		dp1[t][0]=x,deep[t]=deep[x]+1;
		dfs(t,x);
		minn=min(minn,t);
	}
	dp2[x][0]=(minn==INT_MAX?x:minn);
	for (int i=1;deep[x]+(1<<i)<=depth;i++){
		dp2[x][i]=dp2[dp2[x][i-1]][i-1];
	}
}
```
维护完了之后，就是直接跳了，这一步还是非常简单的。
```cpp
void jump(int x){
	int index=__lg(x),mi=(deep[s]-x<0?0:deep[s]-x);//确定上边界不会越界
	for (int i=index;i>=0;i--){
		if (dp1[s][i]==0||deep[dp1[s][i]]<mi)continue;
		s=dp1[s][i];
	}
}

void down(int x){
	int index=__lg(x),mx=(deep[s]+x>depth?depth:deep[s]+x);//确定下边界不会越界
	for (int i=index;i>=0;i--){
		if (dp2[s][i]==0||deep[dp2[s][i]]>mx)continue;
		s=dp2[s][i];
	}
}
```
这就是这道题的完整的思路，有一些细节大家可以自己调试一下，下面给出完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF=1e5+10;

vector<int> mp[INF];
int deep[INF],dp1[INF][20],dp2[INF][20];
int n,q,s,depth;

void dfs(int x,int fa){
	depth=max(depth,deep[x]);
	for (int i=1;(1<<i)<=deep[x]-1;i++){
		dp1[x][i]=dp1[dp1[x][i-1]][i-1];
	}
	int len=mp[x].size(),minn=INT_MAX;
	for (int i=0;i<len;i++){
		int t=mp[x][i];
		if (t==fa)continue;
		dp1[t][0]=x,deep[t]=deep[x]+1;
		dfs(t,x);
		minn=min(minn,t);
	}
	dp2[x][0]=(minn==INT_MAX?x:minn);
	for (int i=1;deep[x]+(1<<i)<=depth;i++){
		dp2[x][i]=dp2[dp2[x][i-1]][i-1];
	}
}

void jump(int x){
	int index=__lg(x),mi=(deep[s]-x<0?0:deep[s]-x);
	for (int i=index;i>=0;i--){
		if (dp1[s][i]==0||deep[dp1[s][i]]<mi)continue;
		s=dp1[s][i];
	}
}

void down(int x){
	int index=__lg(x),mx=(deep[s]+x>depth?depth:deep[s]+x);
	for (int i=index;i>=0;i--){
		if (dp2[s][i]==0||deep[dp2[s][i]]>mx)continue;
		s=dp2[s][i];
	}
}

int main() {
	cin>>n>>q;
	for (int i=2;i<=n;i++){
		int t;
		cin>>t;
		mp[t].push_back(i);
		mp[i].push_back(t);
	}
	deep[1]=1,dp1[1][0]=1;
	dfs(1,-1);
	for (int i=1;i<=q;i++){
		int k;
		cin>>s>>k;
		for (int j=1;j<=k;j++){
			int t;
			cin>>t;
			if (t>0)jump(t);
			else down(-t);
		}
		cout<<s<<"\n";
	}
	return 0;
}
```

---

## 作者：b__b (赞：1)

简单倍增，学过 LCA 的很容易想到。

我们先考虑第一种操作，我们发现如果暴力一步一步往上跳实在太花时间了。我们很容易想到跟 LCA 的倍增算法一样预处理以加快速度。

定义 $\mathrm{fa}_{x,i}$ 表示结点 $x$ 的第 $2^i$ 个祖先。则当结点 $x \neq 1$ （即结点 $x$ 不是树的根）时 $\mathrm{fa}_{x,0}$ 就是 $x$ 结点的父结点。对于根结点，由于题目要求如果当前位于根结点，则不进行移动；因此我们可以将根结点的父结点设为它自己，这样在根结点往上跳还是在根结点。

于是我们有（$\mathrm{father}_x$ 就是 $x$ 的父结点）：
$$
\mathrm{fa}_{x,i}=
\begin{cases}
1, &x=1 \\
\mathrm{father}_x, &i=0,x \neq 1 \\
\mathrm{fa}_{\mathrm{fa}_{x,i-1},i-1}, &\text{otherwise.}
\end{cases}
$$
第三种情况可以理解为从 $x$ 结点先跳到第 $2^{i-1}$ 个祖先，再往前跳 $2^{i-1}$ 个祖先，总共就是第 $2^i$ 个祖先。

第二个操作思路相近，定义 $\mathrm{so}_{x,i}$ 表示从 $x$ 结点往下走 $2^i$ 层到达的结点，则有（$\mathrm{son}_x$ 就是结点 $x$ 的编号最小的儿子结点，如果没有儿子结点则为 $0$）：
$$
\mathrm{so}_{x,i}=
\begin{cases}
x, &\mathrm{son}_x=0 \\
\mathrm{son}_x, &i=0,\mathrm{son}_x \neq 0 \\
\mathrm{so}_{\mathrm{so}_{x,i-1},i-1}, &\text{otherwise.}
\end{cases}
$$
第一种情况可以让我们从叶子结点往下跳永远只会跳到它自己。如何处理 $\mathrm{son}_x$ 可以在输入时做，具体见代码。

我们预处理完了，现在该如何利用呢？我们可以将 $a$ 拆分成若干个 $2$ 的非负整数次方相加，每一个 $2$ 的次幂都可以运用上面的 $\mathrm{fa}$ 和 $\mathrm{so}$。直接使用循环遍历即可。

现在我们来计算复杂度：

时间复杂度：预处理时，对于每一个 $\mathrm{fa}_{x,i}$ 和 $\mathrm{so}_{x,i}$，它都可以以 $\mathcal{O}(1)$ 的复杂度计算出来；$2^i$ 不会超过 $n$，因此最多只会有 $\log_2n$ 个 $i$；要遍历 $n$ 个节点，预处理的时间复杂度为 $\mathcal{O}(n \log n)$，显然可以接受。

对于每一个操作，由于最多只会往上跳 $\log_2 \left| a_{i,j} \right|$ 次，因此所有操作的时间复杂度总和就是 $\mathcal{O}(\sum \log \left| a_{i,j} \right|)$。最多只会有 $\sum k_i=10^5$ 个操作（也就是最多只有 $10^5$ 个 $a_{i,j}$），$\log \left| a_{i,j} \right|$ 最大只会是 $\log_2{n}=\log_2{10^5} \approx 17$。因此这个复杂度也是可以接受的。

空间复杂度：要存储 $\mathrm{fa}$ 和 $\mathrm{so}$ 数组，总共为 $\mathcal{O}(n \log n)$，可以接受。

代码：
```cpp
#include <cstdio>
const int N = 1e5 + 5;
int fathers[18][N], sons[18][N];
int main() {
    int n, q;
    scanf("%d%d", &n, &q);
    for (int i = 2; i <= n; ++i) {
        int p;
        scanf("%d", &p), fathers[0][i] = p; //记录父结点
        if (!sons[0][p]) //如果还没有记录编号最小的儿子结点
            sons[0][p] = i; //因为这是第一次记录，结点编号一定是最小的
    }
    fathers[0][1] = 1; //根结点的父亲设为自己
    for (int i = 1; i <= n; ++i)
        if (!sons[0][i]) sons[0][i] = i; //如果还没有记录子结点说明是叶子结点，将儿子设为它自己
    for (int j = 1; (1 << j) <= n; ++j) //第2^j个祖先或者儿子
        for (int i = 1; i <= n; ++i) //当前结点
            sons[j][i] = sons[j - 1][sons[j - 1][i]], fathers[j][i] = fathers[j - 1][fathers[j - 1][i]]; //上面得到的递推式
    for (int s, k; q--;) {
        scanf("%d%d", &s, &k);
        for (int a; k--;) {
            scanf("%d", &a);
            if (a > 0) {
                for (int g = 0; (1 << g) <= a; ++g) //二进制拆分
                    if (a & (1 << g))
                        s = fathers[g][s]; //需要跳一次
            } else {
                a = -a;
                for (int g = 0; (1 << g) <= a; ++g) //过程同上
                    if (a & (1 << g))
                        s = sons[g][s];
            }
        }
        printf("%d\n", s);
    }
}
```

---

## 作者：HsNu1ly7_ (赞：1)

## 题意

给你一棵树，有 $q$ 次询问，每次询问给你一个起点 $s$，有 $k$ 个整数，若 $a_{i,j} > 0$，则移动 $a{i,j}$ 次，每次移动到当前节点的父节点，若当前节点为树根，则结束操作。若 $a_{i,j} < 0$，则移动 $-a_{i,j}$ 次，每次移动到当前节点编号最小的子节点，若当前节点为叶子节点则结束操作。

## 思路

若对于每次给出的 $a_{i,j}$，暴力搜索，会超时。

对于这种连续在树上进行上跳或下移的题目，可以用倍增求 LCA 的思想。

设 $fa_{u , i}$ 为点 $u$ 向上移动 $2^i$ 个节点最终的节点编号，那么 $fa_{u , i} = fa_{fa_{u , i - 1} , i - 1}$，其中 $fa_{u , 0}$ 就是点 $u$ 的父亲节点。

操作二大同小异，设 $son_{u , i}$ 为点 $u$ 执行 $2^i$ 次操作二后节点的编号，那么 $son_{u , i} = son_{son_{u , i - 1} , i - 1}$，其中 $son_{u , 0}$ 就是点 $u$ 编号最小的子节点。

在查询过程中，从高往低枚举二进制位，若 $a_{i , j}$ 的第 $k$ 位二进制位为 $1$，那么将 $s_i$ 更新为 $fa_{s_i , k}$ 或者是 $son_{s_i , k}$。

剩下的细节看代码。

## Code


```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep( i , l , r ) for (int i = (l) ; i <= (r) ; i++)
#define per( i , r , l ) for (int i = (r) ; i >= (l) ; i--)
const int N = 1e5 + 10 ;
int n , q ;
int fa[N][25] ;
vector <int> g[N] ;
int son[N][25] ;
int min_son[N] ;
int dfs (int u , int faa){
	bool flg = 0 ;
	son[u][0] = 1e9 ;
	rep (i , 1 , 19) fa[u][i] = fa[fa[u][i - 1]][i - 1] ;
	int minv = 1e9 ;
	for (auto v : g[u]){
		if (v == faa) continue ;
		flg = 1;
		int t = dfs (v , u) ;
		if (minv > v){
			minv = v ;
			min_son[u] = t ;
		}
		son[u][0] = min (son[u][0] , v) ;
	}
	if (flg && son[u][0] != 1e9 && son[son[u][0]][0] != 1e9){
		rep (i , 1 , 19){
			son[u][i] = son[son[u][i - 1]][i - 1] ;
		}
	}
	if (!flg){
		min_son[u] = u ;
	}
	return min_son[u] ;
}
void solve (){
	cin >> n >> q ;
	rep (i , 2 , n){
		cin >> fa[i][0] ;
		g[fa[i][0]].push_back (i) ;
		g[i].push_back (fa[i][0]) ;
	}
	fa[1][0] = 1 ;
	dfs (1 , 0) ;
	rep (i , 1 , n){
		rep (j , 0 , 19){
			if (fa[i][j] == 0) fa[i][j] = 1 ;
			if (son[i][j] == 0 || son[i][j] == 1e9){
				son[i][j] = min_son[i] ;
			}
		}
	}
	while (q--){
		int s , k ;
		cin >> s >> k ;
		rep (i , 1 , k){
			int x ;
			cin >> x ;
			if (x > 0){
				per (j , 19 , 0){
					if ((1 << j) & x){
						s = fa[s][j] ;
					}
				}
			}else{
				x = -x ;
				per (j , 19 , 0){
					if ((1 << j) & x){
						s = son[s][j] ;
					}
				}
			}
		}
		cout << s << '\n' ;
	}
}

signed main (){
	int _ = 1 ;
	//cin >> _ ;
	while ( _-- ){solve () ;}
	return 0 ;
}
```

---

## 作者：MARSandEARTH (赞：0)

~~第一眼：这是什么玩意，
第二眼：这是什么乐子。~~

部分分无用，直接正解。

注意到对于每个点进行操作时只会移动到固定的点上，所以标记操作后的点。

不妨记点 $u$ 进行 $2^k$ 次 $1$ 操作后的点 $v$ 为 $anc_{u,k}$，点 $u$ 进行 $2^k$ 次 $2$ 操作后的点 $v$ 为 $son_{u,k}$，可以 $O(n\log n)$ 预处理。

每进行操作时利用类似 LCA 的倍增思想移动即可。

共进行 $\sum k_i$ 次操作，每次操作复杂度 $O(\log n)$，总复杂度 $O((n+k)\log n+q)$，可以通过。

---


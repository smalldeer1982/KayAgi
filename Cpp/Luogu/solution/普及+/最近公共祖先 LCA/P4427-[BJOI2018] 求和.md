# [BJOI2018] 求和

## 题目描述

master 对树上的求和非常感兴趣。他生成了一棵有根树，并且希望多次询问这棵树上一段路径上所有节点深度的 $k$ 次方和，而且每次的 $k$ 可能是不同的。此处节点深度的定义是这个节点到根的路径上的边数。他把这个问题交给了 pupil，但 pupil 并不会这么复杂的操作，你能帮他解决吗？

## 说明/提示

### 样例解释

以下用 $d (i)$ 表示第 $i$ 个节点的深度。

对于样例中的树，有 $d (1) = 0, d (2) = 1, d (3) = 1, d (4) = 2, d (5) = 2$。

因此第一个询问答案为 $(2^5 + 1^5 + 0^5) \bmod 998244353 = 33$，第二个询问答案为$(2^{45} + 1^{45} + 2^{45}) \bmod 998244353 = 503245989$。

### 数据范围

对于 $30\%$ 的数据，$1 \leq n,m \leq 100$。

对于 $60\%$ 的数据，$1 \leq n,m \leq 1000$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 300000$，$1 \leq k \leq 50$。

另外存在 5 个不计分的 hack 数据。

### 提示

数据规模较大，请注意使用较快速的输入输出方式。

## 样例 #1

### 输入

```
5
1 2
1 3
2 4
2 5
2
1 4 5
5 4 45```

### 输出

```
33
503245989```

# 题解

## 作者：shadowice1984 (赞：57)

大概是树上差分的题？

先介绍下什么是树上差分……(说实在的应该叫树上前缀和比较好)

大概是我们要算路径上的一些数(通常是求和)，然后计算路径信息的时候我们处理一些信息，然后通过算$Dep_{u}+Dep_{v}-2Dep_{lca(u,v)}$来计算路径上的信息

题目看起来非常有树链剖分的感觉……但是问题是，这道题没有修改这就导致题目难度大幅度下降了，所以我们先把每个点深度的k次方打一个表，之后我们因为要做减法，所以我们令$val_{i,k}$表示i到1号点路径上点深度的k次方之和……

然后问题来了，我们维护的是点权和，所以呢我们发现直接减的话会导致lca这个点没算，所以略微改一下公式，使lca这个点也被算一次

然后我们询问$u,v,k$的时候输出$val_{u,k}+val_{v,k}-val_{lca(u,v)}-val_{fa_{lca(u,v)}}$即可

问题就是如何找lca了……~~(欢迎使用TarjanO(n)求lca)~~

~~欢迎使用st表O(1)查询~~

然而最粗暴，可靠性最强，常数小而不会被轻易卡的算法还是倍增，所以这道题上一个倍增板子即可通过此题了~(不会倍增法求lca的话出门左转你站膜板区，包教包会~)

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;typedef long long ll;const ll mod=998244353;const int N=3*1e5+10;const int M=60;
int n;int m;int v[2*N];int x[2*N];int al[N];int ct;ll dep[N];int fa[N][22];int book[N];ll val[N][M];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}ll mi[M];
inline void dfs(int u)//处理val的信息以及倍增的信息 
{
    book[u]=true;for(int i=0;fa[u][i];i++){fa[u][i+1]=fa[fa[u][i]][i];}
    for(int i=al[u];i;i=x[i])
    {
        if(book[v[i]]){continue;}
        fa[v[i]][0]=u;dep[v[i]]=dep[u]+1;
        for(int j=1;j<=50;j++){mi[j]=mi[j-1]*dep[v[i]]%mod;}
        for(int j=1;j<=50;j++){val[v[i]][j]=(mi[j]+val[u][j])%mod;}
        dfs(v[i]);
    }
}
inline int lca(int u,int v)//倍增求lca 
{
    if(dep[u]<dep[v]){swap(u,v);}int d=dep[u]-dep[v];
    for(int i=0;d;d>>=1,i++){if(d&1){u=fa[u][i];}}if(u==v){return u;}
    for(int i=20;i>=0;i--){if(fa[u][i]!=fa[v][i]){u=fa[u][i];v=fa[v][i];}}
    return fa[u][0]; 
}
int main()
{
    scanf("%d",&n);mi[0]=1;
    for(int i=1,u,v;i<n;i++){scanf("%d%d",&u,&v);add(u,v);add(v,u);}dfs(1);//dfs处理 
    scanf("%d",&m);
    for(int i=1,u,v,k;i<=m;i++)
    {
        scanf("%d%d%d",&u,&v,&k);int l=lca(u,v);//然后我们就直接减了，注意lca只算但是要算一次 
        printf("%lld\n",(val[u][k]+val[v][k]+2*mod-val[fa[l][0]][k]-val[l][k])%mod);
    }return 0;//拜拜程序~ 
}

```

---

## 作者：NaCly_Fish (赞：34)

看来树剖学多了，人会变傻是真的23333    
看到和树有关的题都会想到树剖  
~~假的，因为自己太弱了~~  

不多说了，来看题。题目中只有查询，没有修改操作，很容易就能想到用差分来做。  
这里用一个数组$\text{s}[u][k]$表示从根到$u$节点的$k$次方和，这个在树剖的时候就可以顺便处理掉。   
$k$很小，不过$50$，随便搞不会超时
```cpp
for(int i=0;i<=50;++i){
    s[u][i] = s[f][i]+power(depth[u]-1,i);
    s[u][i] %= p;
}
```  
这里$\text{depth}[1]=1$，比题目中深度的定义多了$1$，所以要$-1$。$f$表示$u$的父节点   

然后树剖完了之后，每次查询可以$\Theta(\log_2n)$解决。  
要注意两点：  
1、$\text{lca}(u,v)$只被重复算了一次，而它的祖先节点都被重复算了两次。  
2、进行减法运算时，结果有可能小于$0$，$+p$再模$p$就好了。
```cpp
f = lca(u,v);
ans = (s[u][k]+s[v][k])%p;
ans -= (s[f][k]+s[fa[f]][k])%p;
ans = (ans+p)%p;
```   

另外：不用都开long long，占空间要多出一倍。快速幂的时候临时转一下就行了。

最后贴出AC代码：  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define N 300003
#define inf 0x3f3f3f3f
#define ll long long
#define p 998244353
using namespace std;

vector<int> adj[N];
int n,m,cnt;
int depth[N],son[N],s[N][51],size[N];
int id[N],top[N],fa[N];

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)){
        x = (x<<3)+(x<<1)+c-'0';
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

void dfs1(int u,int f){
    depth[u] = depth[f]+1;
    for(int i=0;i<=50;++i){
        s[u][i] = s[f][i]+power(depth[u]-1,i);
        s[u][i] %= p;
    }
    fa[u] = f;
    size[u] = 1;
    int v,t = -1,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(v==f) continue;
        dfs1(v,u);
        size[u] += size[v];
        if(size[v]>t){
            t = size[v];
            son[u] = v;
        }
    }
}

void dfs2(int u,int f){
    id[u] = ++cnt;
    top[u] = f;
    if(son[u]==0) return;
    dfs2(son[u],f);
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(v==fa[u]||v==son[u]) continue;
        dfs2(v,v);
    }
}

inline int lca(int u,int v){
    int t;
    while(top[u]!=top[v]){
        if(depth[top[u]]<depth[top[v]]){
            t = u;
            u = v;
            v = t;
        }
        u = fa[top[u]];
    }
    if(depth[u]<depth[v]) return u;
    return v;
}

int main(){
    int u,v,k,f,ans;
    read(n);
    for(int i=1;i<n;++i){
        read(u),read(v);
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs1(1,0);
    dfs2(1,1);
    read(m);
    ++m;
    while(--m){
        read(u),read(v),read(k);
        f = lca(u,v);
        ans = (s[u][k]+s[v][k])%p;
        ans -= (s[f][k]+s[fa[f]][k])%p;
        ans = (ans+p)%p;
        print(ans);
        putchar(10);
    }
    return 0;
}
```


---

## 作者：米奇奇米 (赞：20)

## 这道题目难度不是很大，大概也就$Noip Day2T1$的难度。
### 下面我们来讲一下我的心路历程
### $1.1$理解题目意思：
这道题目就是给我们求树上的两个点$x,y$，给你一个权值$k$，让你计算在$x,y$之间的总和，这道题目的总和是这样算的:那么我们先来理解一下样例：

![](https://cdn.luogu.com.cn/upload/pic/60623.png)

样例中$deep[1]=0,deep[4]=2,deep[2]=1$，所以对于第一组数据它的答案就是$2^5+1^5+0^5=33$

### $2.1$算法思想
这道题目看到点与点之间的距离、深度，很容易想到用$lca$,如果你不会$lca$[右拐☞](https://www.luogu.org/problemnew/show/P3379)
这样我们这道题目剩下的就是如何统计答案，我们记录一个数组$pre[u][k]$表示以$u$为节点，$k$为题目给定的权值，在这棵数中的前缀和。

对于样例的第二组数据：$pre[4][45]$表示从$4$到根节点$1$的答案。那么我们计算$4$与$5$之间的总和是不是就是$pre[4][k]+pre[5][k]-pre[lca(4,5)][k]-pre[fa[lca(4,5)][0]][k]$

于是我们对于任何树上的两点$a,b$，$a,b$的公共祖先为$x$两点之间的总和就是$sum=pre[a][k]+pre[b][k]-pre[x][k]-pre[fa[x][0]][k]$，其中的$fa[][]$就是求$lca$时候的变量数组。

那么对于如何预处理出$pre[][]$,我们可以再预处理$lca$时顺带便完成。于是就很简单啦！

### $3.1$代码实现
这道题目的代码实现是很简单的，就是$lca$的模板代码（只要在$dfs$预处理时加点东西就可以了），于是就是套用得出来的公式就可以了。
```cpp
#include <bits/stdc++.h>
#define int long long 
#define re register
using namespace std;
const int maxn=300500,mod=998244353;
struct nood {
	int nex,to;
} e[maxn<<2];
int head[maxn],fa[maxn][25],dep[maxn];
int n,m,cnt,res,ans,vis[maxn],pre[maxn][55];
inline int ksm(int a,int b) {
	int ret=1;
	while(b) {
		if(b&1) ret=ret*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ret%mod;
}//快速幂
inline void add_edge(int u,int v) {
	e[++cnt].nex=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
inline void dfs(int u,int f) {
	dep[u]=dep[f]+1;
	fa[u][0]=f;
	for ( re int i=1;i<=50;i++ ) 
		pre[u][i]=(pre[f][i]+ksm(dep[u],i)+mod)%mod;
    //因为k最多只有50，所以直接暴力预处理每一个pre数组
	for ( re int i=head[u];i;i=e[i].nex ) {
		int v=e[i].to;
		if(v==f) continue;
		dfs(v,u);
	}
}
inline int Lca(int x,int y) {
	if(dep[x]>dep[y]) swap(x,y);
	for ( re int i=20;i>=0;i-- ) 
		if(dep[x]<=dep[y]-(1<<i)) y=fa[y][i];
	if(x==y) return x;
	for ( re int i=20;i>=0;i-- ) 
		if(fa[x][i]!=fa[y][i]) 
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}//纯种lca模板
inline int read() {
	int sum=0,ff=1; char ch=getchar();
	while(ch<'0' or ch>'9') { if(ch=='-') ff=-1; ch=getchar(); }
	while(ch>='0' and ch<='9') { sum=(sum*10+ch-'0'); ch=getchar(); }
	return sum*ff;
}
signed main() {
//	freopen("BJOI2018.in","r",stdin);
//	freopen("BJOI2018.out","w",stdout);
	n=read();
	for ( re int i=1;i<=n-1;i++ ) {
		int u=read(),v=read();
		add_edge(u,v);
		add_edge(v,u);
	}
	
	dep[1]=-1; dfs(1,1);//电风扇预处理deep数组
	for ( re int j=1;j<=21;j++ ) 
		for ( re int i=1;i<=n;i++ ) 
			fa[i][j]=fa[fa[i][j-1]][j-1];
    //倍增预处理fa数组
	int q=read();
	while(q--) {
		int x=read(),y=read(),z=read();
		int lca=Lca(x,y);
		int sum1=(pre[x][z]+pre[y][z]+mod)%mod;
		int sum2=(pre[lca][z]+pre[fa[lca][0]][z]+mod)%mod;
		//套用公式
		printf("%lld\n",((sum1-sum2)+mod)%mod);
	}
	return 0;
}
		
```


---

## 作者：dunko (赞：7)

## **题目**

[这里](https://www.luogu.org/problemnew/show/P4427)

## **思路**

题目要求的是路径上点的深度的k次方和。

这题一看用树剖加线段树一定可以解。

k<=50！！！

可以先在建线段树时将0到50次和都算一遍，这样查询时就会很方便。

因为k次方会很大，我先用了一个数组，将0到树上最深的点的深度的0到50次都算了一遍。

这题是Mod998244353，在算几次方时要开long long。在线段树求区间和时，只要注意取模，就不会超出int范围，所以区间和用int就可以啦。这样就保证了空间不会超，时间也是安全的。（多好！



以上是线段树，树剖部分想必大家都明白，就不说了（~~这不是偷懒！！！~~）。

## **代码**

不说了:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=300001,mod=998244353;
int n,m,head[maxn],cnt,tot;
long long f[maxn][51];
int dep[maxn],siz[maxn],fa[maxn],son[maxn],maxx,anss,ans;
struct node{
    int nxt,to;
}edge[maxn<<1];
void add_edge(int x,int y){
    edge[++cnt]=(node){head[x],y};
    head[x]=cnt;
}
void dfs1(int x,int ffa){
    fa[x]=ffa,siz[x]=1;
    for(int i=head[x];i;i=edge[i].nxt){
        int y=edge[i].to;
        if(y!=ffa){
            dep[y]=dep[x]+1;
            dfs1(y,x);
            siz[x]+=siz[y];
            if(siz[y]>siz[son[x]]) son[x]=y;
        }
    }
}
int top[maxn],in[maxn],id[maxn];
void dfs2(int x,int tp){
    top[x]=tp,in[x]=++tot,id[tot]=x;
    if(son[x]) dfs2(son[x],tp);
    for(int i=head[x];i;i=edge[i].nxt){
        int y=edge[i].to;
        if(y!=fa[x]&&y!=son[x]) dfs2(y,y);
    }
}
int t[maxn<<2][51];
void build(int c,int l,int r){
    if(l==r){
        for(int i=0;i<=50;i++)
        t[c][i]=f[dep[id[l]]][i];
        return;
    }
    int mid=(l+r)>>1;
    build(c<<1,l,mid); build(c<<1|1,mid+1,r);
    for(int i=0;i<=50;i++)
    t[c][i]=(t[c<<1][i]+t[c<<1|1][i])%mod;
}
long long query(int c,int l,int r,int x,int y,int k){
    if(x<=l&&r<=y) return t[c][k];
    int mid=(l+r)>>1;anss=0;
    if(mid>=x) anss=query(c<<1,l,mid,x,y,k);
    if(mid<y) anss=(anss+query(c<<1|1,mid+1,r,x,y,k))%mod;
    return anss;
}
long long ask(int x,int y,int k){
    ans=0;
    while(top[x]^top[y]){
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        ans=(ans+query(1,1,n,in[top[x]],in[x],k))%mod;
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    ans=(ans+query(1,1,n,in[x],in[y],k))%mod;
    return ans;
}
int main(){
    scanf("%d",&n);
    int x,y,k;
    for(int i=1;i<n;i++){
        scanf("%d%d",&x,&y);
        add_edge(x,y),add_edge(y,x);
    }
    dfs1(1,0),dfs2(1,1);
    for(int i=1;i<=n;i++) maxx=max(maxx,dep[i]);
    //先预处理出i的k次方
    for(int i=0;i<=maxx;i++) f[i][0]=1;
    for(int i=0;i<=maxx;i++)
    for(int j=1;j<=50;j++) f[i][j]=(f[i][j-1]*i)%mod;
    
    build(1,1,n);
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&k);
        printf("%lld\n",ask(x,y,k));
    }
    return 0;
}
```



---

## 作者：Treaker (赞：5)

来一发指针树剖题解。
这个题的话，我们维护一下300000以内每一个数50以内的每个次方，每个节点维护50以内的每个次方，转移时for循环转移。
取模操作会比较慢（参考骗分导论），所以我们采用减来算。
详见代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
const int N = 300001 , mod = 998244353;
inline int work(int x) {return x >= mod ? x - mod : x;}
int n , m , maxdep , cnt;
int head[N] , hs[N] , dfn[N] , id[N] , dep[N] , top[N] , fa[N] , size[N] , f[N][51];
struct Tree_div
{
	struct Edge
	{
		int to , nxt;
	}e[N << 1];
	inline void add(int from,int to)
	{
		e[++cnt] = (Edge) {to,head[from]};
		head[from] = cnt; 
	}
	void get_tree(int now)
	{
		size[now] = 1;
		maxdep = max(maxdep,dep[now]);
		for(int i = head[now];i;i = e[i].nxt)
		{
			int to = e[i].to;
			if(dep[to] || to == 1)	continue;
			dep[to] = dep[now] + 1;
			fa[to] = now;
			get_tree(to);
			size[now] += size[to];
			if(size[to] > size[hs[now]])	hs[now] = to;	
		}
	}
	void dfs(int now,int topfa)
	{
		dfn[now] = ++cnt;
		id[cnt] = now;
		top[now] = topfa;
		if(hs[now])	dfs(hs[now],topfa);
		for(int i = head[now];i;i = e[i].nxt)
		{
			int to = e[i].to;
			if(to == hs[now] || to == fa[now])	continue;
			dfs(to,to);
		}
	}
	struct node
	{
		node *ls , *rs;
		int l , r , sum[51];
		node (int l = 0,int r = 0) : l(l) , r(r) {ls = rs = NULL; sum[51] = {0};}
		inline int len() {return r - l + 1;}
		inline int mid() {return (l + r) >> 1;}
		inline void up() {for(int i = 1;i <= 50;i ++)	sum[i] = work(ls -> sum[i] + rs -> sum[i]);}
	} *root , pool[N << 2] , *tail;
	void build(node *&p,int l,int r)
	{
		p = new (tail ++) node(l,r);
		if(l == r)
		{
			for(int i = 1;i <= 50;i ++)	p -> sum[i] = f[dep[id[l]]][i];
			return ;
		}
		build(p -> ls,l,p -> mid());
		build(p -> rs,p -> mid() + 1,r);
		p -> up();
	}
	int Sum(node *p,int x,int y,int k)
	{
		if(x <= p -> l && p -> r <= y)	return p -> sum[k];
		int res = 0;
		if(x <= p -> mid())	res = work(res + Sum(p -> ls,x,y,k));
		if(y > p -> mid())	res = work(res + Sum(p -> rs,x,y,k));
		return res;
	}
	inline int SUM(int x,int y,int k)
	{
		int res = 0;
		while(top[x] != top[y])	
		{
			if(dep[top[x]] < dep[top[y]])	swap(x,y);
			res = work(res + Sum(root,dfn[top[x]],dfn[x],k));
			x = fa[top[x]];
		}
		if(dep[x] < dep[y])	swap(x,y);
		res = work(res + Sum(root,dfn[y],dfn[x],k));
		return res;
	}
	inline void init()
	{
		n = read();
		for(int i = 1 , u , v;i < n;i ++)	u = read() , v = read() , add(u,v) , add(v,u);
		get_tree(1);
		cnt = 0;
		dfs(1,1);
		for(int i = 1;i <= 50;i ++)	f[1][i] = 1;
		for(int i = 2;i <= maxdep;i ++)	
		{
			f[i][0] = 1;
			for(int j = 1;j <= 50;j ++)	f[i][j] = (long long)f[i][j-1] * i % mod;
		}
		build(root,1,n);
		m = read();
		for(int i = 1 , x , y , k;i <= m;i ++)
		{
			x = read(); y = read(); k = read();
			printf("%d\n",SUM(x,y,k));
		}
	}
	Tree_div() {tail = pool;}
}cf;
int main() {cf.init();return 0;}
```


---

## 作者：Caro23333 (赞：5)

树剖

因为k很小，所以可以将1~300000的k次方都预处理出来，记为d[i][k]

因为这个题目没有任何修改操作，所以树剖之后我们利用d数组预处理一个前缀和即可完成查询

时间复杂度O(kn+mlogn)开O2肯定过了

ps:考场上有人O(nm)水过不知道是什么操作

```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#define mod 998244353

using namespace std;
const int MAXN = 300005;
int n,m;
inline int read()
{
    char c = 0;
    int res = 0;
    while(!isdigit(c)) c = getchar();
    while(isdigit(c))
    {
        res = res*10+c-'0';
        c = getchar();
    }
    return res;
}
struct Node
{
    int u,v;
    Node *next;
}*h[MAXN],pool[MAXN<<1];
int tot = 0;
inline void addEdge(int u, int v)
{
    Node *p = &pool[++tot], *q = &pool[++tot];
    p->v = v; p->next = h[u]; h[u] = p;
    q->v = u; q->next = h[v]; h[v] = q;
}
int maxdep = 0;
int size[MAXN],top[MAXN],son[MAXN],id[MAXN],rid[MAXN],dep[MAXN],fa[MAXN],dfn = 0;
inline void dfs1(int u)
{
    maxdep = max(maxdep,dep[u]);
    size[u] = 1;
    int maxa = -1;
    for(Node *p = h[u]; p; p=p->next)
    {
        if(p->v==fa[u]) continue;
        dep[p->v] = dep[u]+1;
        fa[p->v] = u;
        dfs1(p->v);
        size[u] += size[p->v];
        if(size[p->v]>maxa)
        {
            maxa = size[p->v];
            son[u] = p->v;
        }
    }
}
inline void dfs2(int u, int topf)
{
    id[u] = ++dfn;
    rid[id[u]] = u;
    top[u] = topf;
    if(son[u]) dfs2(son[u],topf);
    for(Node *p = h[u]; p; p=p->next)
    {
        if(id[p->v]) continue;
        dfs2(p->v,p->v);
    }
}
int c[55][MAXN];
long long p[MAXN][55];
int main()
{
//	freopen("sum.in","r",stdin);	
 //   freopen("sum.out","w",stdout);
    n = read();
    for(int i = 1; i<n; i++)
        addEdge(read(),read());
    dfs1(1);
    dfs2(1,1);
    
    for(int i = 1; i<=maxdep; i++)
    {
    	p[i][1] = i;
        for(int j = 2; j<=50; j++)
            p[i][j] = p[i][j-1]*i%mod;
    }
    for(int i = 1; i<=50; i++)
        for(int j = 1; j<=n; j++)
            c[i][j] = (c[i][j-1]+p[dep[rid[j]]][i])%mod;
    m = read();
    int x,y,z;
    while(m--)
    {
        x = read(), y = read(), z = read();
        int res = 0;
        while(top[x]!=top[y])
        {
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            res = (res+((long long)c[z][id[x]]-c[z][id[top[x]]-1]+mod)%mod)%mod;
            x = fa[top[x]];
        }
        if(dep[y]<dep[x]) swap(x,y);
        res = (res+((long long)c[z][id[y]]-c[z][id[x]-1]+mod)%mod)%mod;
        printf("%d\n",res);
    }
    return 0;
}
```

---

## 作者：Rainybunny (赞：3)

唔, 很有信心地码了LCA结果WA爆零, 一定要注意取模负数的情况!  
顺带一句, 最快的IO是iostream!  


------------
进入正题, 本题明显是一道LCA(最近公共祖先)的板题.  
LCA问题的求解一般有以下三种方法:  
- 暴力爬树, 单次$O(n)$;
- 倍增, 单次$O(log_2n)$;
- Tarjan, 多次$O(n+q)$;  

对于algori.1, 期望得分30分, 这里主要总结algori.2倍增法, 其预处理时间可以卡过数据, 而且容易实现. ~~其实是因为我背不住Tarjan.~~  
求得LCA之后呢? 我们需要qkpow扫一遍depth? NO!  
命名并求解! 我们用$Ans(a,b,k)$来表示答案, 再令:  

$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,PreSum(u,k)=\sum_{v}depth_v^k[LCA(u,v)=v]$  

简单来说, 就是u的所有祖先结点(包括u本身)的深度的k次方和.  
类比线性前缀和的思想, 设$LCA(a,b)=d$, 则应有:  

$Ans(a,b,k)=PreSum(a,k)+PreSum(b,k)-2\times PreSum(d,k)+depth_d^k$  

这并不令我们满意, 因为我们并不希望维护过多的"k次方", 这很容易在mod过程中出错.  
观察左式第四项, 我们难道要为了它来维护depth的k次方? 得益于倍增算法会求得每个结点的父亲, 叫这个倍增爬树的数组F吧, 我们用它对Ans继续化简:  

$Ans(a,b,k)=PreSum(a,k)+PreSum(b,k)-PreSum(d,k)-(PreSum(d,k)-depth_d^k)$
$
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,=PreSum(a,k)+PreSum(b,k)-(PreSum(d,k)+PreSum(F[d][0],k))$  

That's amazing! 这样一来, 只用在dfs时顺便维护一下PreSum就可以AC了.  
如果还是WA, 可以借(chao)鉴(xi)一下代码里对取模的处理. Good luck!  
```cpp
#include <vector>
#include <iostream>

#define Int register int

typedef long long int LL;

using namespace std;

const int MAXN = 300000, MAXK = 50, MAXLOG = 20, Mod = 998244353;
int n, m, Fa[MAXN + 5][MAXLOG + 5] = {};
LL Depth[MAXN + 5] = {}, PreSum[MAXN + 5][MAXK + 5] = {};
vector<int> G[MAXN + 5] = {};

inline void AddEdge ( const int u, const int v ) { // 加边操作 
	G[u].push_back ( v );
	G[v].push_back ( u );
}

inline void DFS ( const int u, const int fa ) { // 预处理depth[], Fa[][] and PreSum[][]. 
	Fa[u][0] = fa;
	for ( Int i = 1; i <= 20; ++ i ) {
		Fa[u][i] = Fa[Fa[u][i - 1]][i - 1];
	}
	LL Tmp = 1;
	for ( Int i = 1; i <= 50; ++ i ) {
		Tmp = ( Tmp * Depth[u] ) % Mod; // 随时取模! 
		PreSum[u][i] = PreSum[fa][i] + Tmp;
		if ( PreSum[u][i] >= Mod ) PreSum[u][i] -= Mod;
	}
	for ( unsigned int i = 0; i < G[u].size (); ++ i ) { // 寻找相邻结点 
		if ( G[u][i] ^ fa ) { // 若不是父结点(ps.只有相等的两个整数亦或值为零, 即a^b==0等价于a==b) 
			Depth[G[u][i]] = Depth[u] + 1; // 当然, 这句可以扔到上面 
			DFS ( G[u][i], u );
		}
	}
}

inline int LCA ( int a, int b ) { // LCA模板 
	for ( Int i = 20; ~ i; -- i ) { 
		if ( Depth[Fa[a][i]] >= Depth[b] ) {
			a = Fa[a][i];
		}
		if ( Depth[Fa[b][i]] >= Depth[a] ) { // 两个if只有一个会进入, 也有写法是当a>b时, swap( a, b ). 
			b = Fa[b][i];
		}
	}
	if ( a ^ b ) {
		for ( Int i = 20; ~ i; -- i ) {
			if ( Fa[a][i] ^ Fa[b][i] ) {
				a = Fa[a][i], b = Fa[b][i];
			}
		}
		return Fa[a][0]; // 注意哦, 两个结点一起向上爬时, 算法会把"刚好会合"当做"超过目标点", 所以此时a与b还有一步之遥 
	}
	return a; // 不需要一起爬, return任意一个点 
}

inline void Work () {
	ios :: sync_with_stdio ( false ); // 鲁迅说:"时间就像海绵里的水, cin/cout关掉同步总是还有的." 
	cin >> n;
	for ( Int i = 1; i <= n - 1; ++ i ) {
		int u, v;
		cin >> u >> v;
		AddEdge ( u, v );
	}
	Depth[0] = -1; // 题目要求根结点深度为0, 因为在dfs中会+1, 这里先赋为-1 
	DFS ( 1, 0 ); // 预处理 
	cin >> m;
	while ( m -- ) {
		int a, b, k, lab;
		cin >> a >> b >> k;
		lab = LCA ( a, b );
		cout << ( ( PreSum[a][k] + PreSum[b][k] ) % Mod - ( PreSum[lab][k] + PreSum[Fa[lab][0]][k] ) % Mod + Mod ) % Mod << endl;
		// 特别注意, 取模后的减法可能爆出负数, 被数论折磨过的孩子都知道, 标准处理方法是( x % Mod + Mod ) % Mod. 
	}
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：GXZJQ (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P4427)

- 更新于 $2024$ 年 $12$ 月 $29$ 日：修改了一处笔误。
---

## 题目大意

给定一棵树，共有 $m$ 组询问，每组询问需要回答从结点 $i$ 到结点 $j$ 的**简单**路径上所有点深度的 $k$ 次方和，$i,j,k$ 在每组询问中指定。

## 思路分析

考查 LCA 知识的运用。

首先，明确一点，对于一棵树而言，$i,j$ 两点之间的**简单**路径是先由 $i$ 走到 $\text{LCA}(i,j)$，再由 $\text{LCA}(i,j)$ 走到 $j$ 两部分构成的。那么本题的思路就十分明显了，根据类似 [P8855 [POI2002] 商务旅行](https://www.luogu.com.cn/problem/P8855) 的思想按照公式计算答案即可。

那么，公式又该如何推导呢？我们结合图片来理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/f1ab3zd4.png)

假设此时 $i=6,j=4$，很明显 $\text{LCA}(6,4) = 2$。$i,j$ 到根结点的路径已用不同颜色标出。那么，如果我们把两个图相加，会得到什么？

![](https://cdn.luogu.com.cn/upload/image_hosting/3bzu5wrc.png)

在这里，只计算一遍的点使用黄色标出，计算两遍的点用红色标出，那么，由于我们要的是 $6 + 3 + 2 + 4$ 的信息，所以我们还需要减去他们最近公共祖先的信息后再减去他们最近公共祖先的父节点的信息。

所以，我们只需要定义数组 $a_{q,k}$ 表示结点 $q$ 到结点 $1$ 路径上点深度的 $k$ 次方之和，则形式化地，对于两个节点 $i,j$，记他们的最近公共祖先为 $p$，$p$ 的父节点为 $s$，则最终答案为：

$$
(a_{i,k}+a_{j,k}-a_{p,k}-a_{s,k}) \bmod 998244353
$$

## 参考代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int N = 300000 + 10;
const int M = 50 + 10;
int d[N], anc[N][31];
int h[2 * N], to[2 * N], nxt[2 * N], cnt;
int n, m, x, y, k;
long long po[M];
long long a[N][M];

void add(int u, int v) {
	to[++cnt] = v;
	nxt[cnt] = h[u];
	h[u] = cnt;
}

void DFS(int u, int fa) {
	for(int i = 0; i <= 20; i++) anc[u][i + 1] = anc[anc[u][i]][i];
	for (int i = h[u]; i != -1; i = nxt[i]) {
		int v = to[i];
		if (v == fa) continue;
		anc[v][0] = u, d[v] = d[u] + 1;
		for (int j = 1; j <= 50; j++) {po[j] = po[j - 1] * d[v] % mod;}
		for (int j = 1; j <= 50; j++) {a[v][j] = (po[j] % mod + a[u][j] % mod) % mod;}
		DFS(v, u);
	}
}

int LCA(int u, int v) {
	if (d[u] < d[v]) swap(u, v);
	for (int i = 18; i >= 0; i--) if (d[anc[u][i]] >= d[v]) u = anc[u][i];
	if (u == v) return u;
	for (int i = 18; i >= 0 && u != v; i--) if (anc[u][i] != anc[v][i]) u = anc[u][i], v = anc[v][i];
	return anc[u][0];
}

int main() {
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	memset(h, -1, sizeof h);
	cin >> n;
	po[0] = 1;
	for (int i = 1; i <= n - 1; i++) {
		int u, v;
		cin >> u >> v;
		add(u, v), add(v, u);
	}
	DFS(1, 0);
	cin >> m;
	for (int i = 1; i <= m; i++) {
		cin >> x >> y >> k;
		int p = LCA(x, y);
		// cout << p << " ";
		cout << (long long)(a[x][k] + a[y][k] + 2 * mod - a[p][k] - a[anc[p][0]][k]) % mod << endl;
	}
	// for (int i = 1; i <= n; i++) cout << d[i] << " ";
	return 0;
}
```

---

## 作者：Arghariza (赞：1)

大家好像都用的是在线LCA倍增算法欸...

那我用一下离线的tarjan好了

由题意容易知道这题使用LCA~~标签上都有了啊喂~~

由于这里每组询问对于另一组询问并没有影响，所以我们能用tarjan算法，当然倍增也行

- 首先定义变量（注释在代码里面）：

```
struct edge {int to, prev; } e[1000005]; //edge结构体，存边
struct node {//node结构体，存query
    int to, prev, num; 
    bool flag; 
    node() {flag = false; } //构造函数，应该...学过吧
} qs[1000005]; 

bool vis[500005], flg[500005]; //两个结构体分别记录edge,query
int n, m, s, tot = 0, cnt = 0, lca[500005], last[500005], lastq[500005], pre[500005]; //tot,cnt是链式前向星用的，lca就是lca的数组，last和lastq也是链式前向星用的，pre是并查集的祖先数组
int maxd = -1, dep[500005], a[500005], b[500005], k[500005]; //a,b,k是输入数组，dep表示深度
ll sum[500005][60]; 
```

- 然后是链式前向星存图（没啥好说）：

```
inline void add(int x, int y) {//add edge
    e[++tot].to = y; 
    e[tot].prev = last[x]; 
    last[x] = tot; 
} 

inline void add2(int x, int y, int id) {//add query
    qs[++cnt].to = y; 
    qs[cnt].prev = lastq[x]; 
    qs[cnt].num = id; 
    lastq[x] = cnt; 
} 
```

- 我们的chg函数：

```
inline int chg(int num) {
	if (num & 1) return num + 1; //如果num & 1 != 0，返回num + 1
	else return num - 1; //否则返回num - 1
}  
```

- 接着我们找祖先（不用讲了）：

```
int find(int x) {//路径压缩找祖先
    if (pre[x] != x) pre[x] = find(pre[x]); 
    return pre[x]; 
} 
```

- 然后是合并（也不用说了吧）：

```
void merge(int x, int y) {
	int f1 = find(x), f2 = find(y); 
    pre[f2] = f1; 
} 
```

- 大大小小的附加函数处理好了，接着是我们代码的核心部分（dfs）：

```
void dfs(int cur, int f) {//cur表示现在边的编号
    for (int i = last[cur]; i; i = e[i].prev) {//先枚举边
        if (e[i].to != f && !vis[e[i].to]) {//如果满足条件就可以继续dfs
            dep[e[i].to] = dep[cur] + 1;//深度+1
            maxd = max(maxd, dep[e[i].to]);//得到maxd
            vis[e[i].to] = 1;//打上标记
            dfs(e[i].to, cur);//继续搜索
            merge(cur, e[i].to);//合并俩边
        } 
    }
    for (int i = lastq[cur]; i; i = qs[i].prev) {//枚举query
        if (!qs[i].flag && vis[qs[i].to]) {//满足条件
            lca[qs[i].num] = find(qs[i].to);//找到祖先并赋值给lca数组
        	qs[i].flag = 1;//标记i
            qs[chg(i)].flag = 1;//标记chg(i)
        }
    }
} 
```

- 接着是getsum函数（要记得%p）：

```
ll getsum(int x, int y, int k) {
    if (x != -1) {//如果x不等于-1
        return (sum[y][k] - sum[x][k] + p) % p; //返回
    } else {//否则
        return sum[y][k] % p; //返回
    } 
} 
```

- 最后是main函数：

```
int main() {
    cin >> n; //输入n
    for (int i = 1, x, y; i < n; i++) {//循环
        cin >> x >> y; //输入边
        //存边
        add(x, y); 
        add(y, x); 
    } 
    cin >> m; //输入m
    for (int i = 1; i <= n; i++) pre[i] = i; //并查集初始化
    for (int i = 1; i <= m; i++) {//循环
        cin >> a[i] >> b[i] >> k[i]; //输入query
        //存query
        add2(a[i], b[i], i); 
        add2(b[i], a[i], i); 
    } 
    dfs(1, 0); //dfs函数
    for (int i = 1; i <= maxd; i++) {//sum初始化
        sum[i][1] = i; //一条边要为1
        for (int j = 2; j <= 50; j++) {
            sum[i][j] = (sum[i][j - 1] * i) % p;//记得%p 
        } 
    } 
    for (int j = 1; j <= 50; j++) {
        for (int i = 1; i <= maxd; i++) {
            sum[i][j] = (sum[i][j] + sum[i - 1][j]) % p;//记得%p 
        } 
    }  
    for (int i = 1; i <= m; i++) {
        ll ans = 0; //ans
        if (a[i] == lca[i]) {如果a[i]=lca[i]
    		ans = getsum(dep[a[i]] - 1, dep[b[i]], k[i]); //得到ans的值
        } else if (b[i] == lca[i]) {//如果b[i]=lca[i]
    		ans = getsum(dep[b[i]] - 1, dep[a[i]], k[i]); //得到ans的另一个值
        } else {//否则
        	ans = getsum(dep[lca[i]] - 1, dep[a[i]], k[i]); //得到ans
        	ans = (ans + getsum(dep[lca[i]], dep[b[i]], k[i])) % p; //更新ans
        } 
        cout << ans << endl;//输出ans 
    } 
    return 0; //结束
} 
```

所以整个代码就得出来了：

```
#include<cstdio>
#include<iostream>
#define p 998244353
#define ll long long
using namespace std;

struct edge {int to, prev; } e[1000005]; 
struct node {
    int to, prev, num; 
    bool flag; 
    node() {flag = false; } 
} qs[1000005]; 

bool vis[500005], flg[500005]; 
int n, m, s, tot = 0, cnt = 0, lca[500005], last[500005], lastq[500005], pre[500005]; 
int maxd = -1, dep[500005], a[500005], b[500005], k[500005]; 
ll sum[500005][60]; 

inline void add(int x, int y) {
    e[++tot].to = y; 
    e[tot].prev = last[x]; 
    last[x] = tot; 
} 

inline int chg(int num) {
	if (num & 1) return num + 1; 
	else return num - 1; 
}  

inline void add2(int x, int y, int id) {
    qs[++cnt].to = y; 
    qs[cnt].prev = lastq[x]; 
    qs[cnt].num = id; 
    lastq[x] = cnt; 
} 

int find(int x) {
    if (pre[x] != x) pre[x] = find(pre[x]); 
    return pre[x]; 
} 

void merge(int x, int y) {
	int f1 = find(x), f2 = find(y); 
    pre[f2] = f1; 
} 

void dfs(int cur, int f) {
    for (int i = last[cur]; i; i = e[i].prev) {
        if (e[i].to != f && !vis[e[i].to]) {
            dep[e[i].to] = dep[cur] + 1; 
            maxd = max(maxd, dep[e[i].to]); 
            vis[e[i].to] = 1; 
            dfs(e[i].to, cur); 
            merge(cur, e[i].to); 
        } 
    }
    for (int i = lastq[cur]; i; i = qs[i].prev) {
        if (!qs[i].flag && vis[qs[i].to]) {
            lca[qs[i].num] = find(qs[i].to); 
        	qs[i].flag = 1; 
            qs[chg(i)].flag = 1;
        }
    }
} 

ll getsum(int x, int y, int k) {
    if (x != -1) {
        return (sum[y][k] - sum[x][k] + p) % p; 
    } else {
        return sum[y][k] % p; 
    } 
} 

int main() {
    cin >> n; 
    for (int i = 1, x, y; i < n; i++) {
        cin >> x >> y; 
        add(x, y); 
        add(y, x); 
    } 
    cin >> m; 
    for (int i = 1; i <= n; i++) pre[i] = i; 
    for (int i = 1; i <= m; i++) {
        cin >> a[i] >> b[i] >> k[i]; 
        add2(a[i], b[i], i); 
        add2(b[i], a[i], i); 
    } 
    dfs(1, 0); 
    for (int i = 1; i <= maxd; i++) {
        sum[i][1] = i; 
        for (int j = 2; j <= 50; j++) {
            sum[i][j] = (sum[i][j - 1] * i) % p; 
        } 
    } 
    for (int j = 1; j <= 50; j++) {
        for (int i = 1; i <= maxd; i++) {
            sum[i][j] = (sum[i][j] + sum[i - 1][j]) % p; 
        } 
    }  
    for (int i = 1; i <= m; i++) {
        ll ans = 0; 
        if (a[i] == lca[i]) {
    		ans = getsum(dep[a[i]] - 1, dep[b[i]], k[i]); 
        } else if (b[i] == lca[i]) {
    		ans = getsum(dep[b[i]] - 1, dep[a[i]], k[i]); 
        } else {
        	ans = getsum(dep[lca[i]] - 1, dep[a[i]], k[i]); 
        	ans = (ans + getsum(dep[lca[i]], dep[b[i]], k[i])) % p; 
        } 
        cout << ans << endl; 
    } 
    return 0; 
} 
```

---

## 作者：Chester1011 (赞：1)

蒟蒻一开始没看数据规模，暴力k次方加，结果很显然：~~美妙的30分~~。

然后就是疯狂卡常，~~最后放弃了~~。

------------
#### 再次浏览数据规模， O（NK）的预处理好像不会炸，
然后就是漫长的改代码旅程

------------
算了，不回顾历史了，~~都是泪T_T~~。进入正题：

咱们先不管K次方和，从点i节点到点j节点的路径其实就是i到它俩的最近公共祖先（这里写作lc）与lc到j这条路径，所以打一个LCA模板这一问就解决了。

再就是K次方和了，其实也很好写，在询问之前预处理出根节点到每个点的K次方和，再就是O（1）查询了。

话不多说，手起，码落：
```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
struct edge{int v,net;}e[600005];
const int mod=998244353;
inline int read()
{
	re int sum=0;
	re char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')sum=(sum<<1)+(sum<<3)+(ch^48),ch=getchar();
	return sum;
}
inline int Min(int x,int y){return (x<y?x:y);}
inline int Max(int x,int y){return (x>y?x:y);}
int n,m,dep[300005],hd[300005],cnt,f[300005][20];
long long ans,poww[300005][51],sum[300005][51],num;//poww[i][j]为i节点深度的j次方，sum[i][j]为根节点到i节点的j次方和
inline void add(int u,int v)
{
	e[++cnt].v=v,e[cnt].net=hd[u],hd[u]=cnt;
	e[++cnt].v=u,e[cnt].net=hd[v],hd[v]=cnt;
}
void first(int u,int fa)
{
	for(re int i=1;i<=19;i++)f[u][i]=f[f[u][i-1]][i-1];
	for(re int i=hd[u],v;i;i=e[i].net)
	{
		v=e[i].v;
		if(v==fa)continue;
		dep[v]=dep[u]+1;
		f[v][0]=u;
		first(v,u);
	}
}
inline int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(re int i=19;i>=0;i--)
		if(dep[f[x][i]]>=dep[y])x=f[x][i];
	if(x==y)return x;
	for(re int i=19;i>=0;i--)
		if(f[x][i]!=f[y][i])
			x=f[x][i],y=f[y][i];
	return f[x][0];
}
void dfs(int u,int fa)
{
	for(re int i=hd[u],v;i;i=e[i].net)
	{
		v=e[i].v;
		if(v==fa)continue;
		for(re int j=1;j<=50;j++)
			sum[v][j]=(sum[u][j]+poww[v][j])%mod;
		dfs(v,u);
	}
}//蒟蒻的K次方和预处理
int main()
{
	freopen("sum.in","r",stdin);
    freopen("sum.out","w",stdout);
	n=read();
	for(re int i=1;i<n;i++)add(read(),read());
	m=read();
	first(1,-1);
	for(re int i=1;i<=n;i++)
	{
		num=dep[i];
		for(re int j=1;j<=50;j++)
			poww[i][j]=num,num=(num*dep[i])%mod;
	}
	dfs(1,-1);
	for(re int i=1,x,y,z,lc,mi;i<=m;i++)
	{
		x=read(),y=read(),z=read(),ans=0;
		lc=lca(x,y);
		ans=(sum[x][z]-sum[lc][z]+mod)%mod;
		ans=(ans+(sum[y][z]-sum[lc][z]+mod)%mod)%mod;
		ans=(ans+poww[lc][z])%mod;//最后lc节点要记得加上
		printf("%lld\n",ans);	
	}
	return 0;
}

```


---

## 作者：寒鸽儿 (赞：1)

### 考察lca\树上差分\树剖
当然大众解法是树上差分或者树剖。  
其实还有更加暴力一点的解法。  
例如，从u节点到达v节点，其最近公共祖先计为anc，用d表示深度，则所求可以表示为： d(u)^k + (d(u)-1)^k + (d(u)-2)^k + …… + d(anc)^k + (d(anc+1)) ^ k + (d(anc)+2)^k + …… + d(v)^k  
可以看到，这个结果等于 d(anc)^k + (d(anc+1)) ^ k + (d(anc)+2)^k + …… + d(v)^k + d(anc)^k + (d(anc+1)) ^ k + (d(anc)+2)^k + …… + d(u)^k - d(anc) ^ k.  
如果用f(x, k)表示 1^k + 2^k + …… + x^k, 上述式子等价于f(d(u), k) + f(d(v), k) - f(d(anc), k) - f(d(anc-1), k)  
没错这就是普通的差分。先用O(Dk)预处理这个前缀和，D表示深度。预处理lcaO(n), 然后lca找到anc每次查询O(logn),m次查询共O(mlogn),所以O(Dk+mlogn+n)。即使是一条链，D取到300000, Dk1500000也不会gg。  
代码如下：
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#define p 998244353

using namespace std;

int n;
int head[300010], ver[600010], nex[600010], tot = 0;
int fa[300010][20], d[300010], t, dmax;
long long pr[300010][60];

inline int max(int i, int j) {
    return i > j ? i : j;
}

inline long long max(long long i, long long j) {
	return i > j ? i : j;
}

inline char gc() {
    static char buf[300000], *p1 = buf, *p2 = buf;
    return p1==p2 && (p2 = (p1 = buf) + fread(buf, 1, 300000, stdin), p1 == p2) ? EOF : *p1++;
}

inline int read() {
    int x = 0;
    char ch = gc();
    while(ch < '0' || ch > '9') ch = gc();
    while(ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch & 15); ch = gc(); }
    return x;
}

inline void add(int u, int v) {
    ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;
}

inline void dfs1(int pre, int cur) {
    d[cur] = d[pre] + 1; fa[cur][0] = pre; dmax = max(d[cur], dmax);
    for(int i = 1; i <= t; i++) fa[cur][i] = fa[fa[cur][i-1]][i-1];
    for(int i = head[cur]; i != -1; i = nex[i]) if(ver[i] != pre)
        dfs1(cur, ver[i]);
}

inline void swap(int &i, int &j) {
	int t = i; i = j; j = t;
}

inline int lca(int u, int v) {
	if(d[v] < d[u]) swap(u, v);
	for(int i = t; i > -1; --i) if(d[fa[v][i]] >= d[u]) v = fa[v][i];
	if(u == v) return u;
	for(int i = t; i > -1; --i) if(fa[v][i] != fa[u][i]) u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

int main() {
    int u, v;
    n = read(); t = (int)(log(n) / log(2)) + 1;
    memset(head, -1, sizeof(head));
    for(int i = 1; i < n; i++) {
        u = read(); v = read();
        add(u, v); add(v, u);
    }
    dmax = 0; d[0] = -1;
    dfs1(0, 1);
    for(int i = 1; i <= dmax; i++) {
        pr[i][0] = 1; pr[i][1] = i % p;
        for(int k = 2; k <= 50; k++)
            pr[i][k] = pr[i][k-1] * i % p;
    }
    for(int i = 1; i <= 50; i++)
        for(int j = 1; j <= dmax; j++)
            pr[j][i] = (pr[j-1][i] + pr[j][i]) % p;
    int m = read();
    int du, dv, dfa, k, ft;
    long long ans = 0;
    while(m--) {
        u = read(); v = read(); k = read();
        ft = lca(u, v); dfa = d[ft]; du = d[u]; dv = d[v]; 
        ans = (pr[du][k] + pr[dv][k] + p + p - pr[dfa][k] - pr[d[fa[ft][0]] == -1 ? 0 : d[fa[ft][0]]][k]) % p;
        printf("%lld\n", ans);
    }
    return 0;
}
```
之前跟机房众人口糊打表加速，然而一打出表来内存到了148MBQaQ。  
欢迎互相关注(然而在oi界蒟蒻的圈很小)。  
最后安利一下[蒟蒻的洛谷博客](https://www.luogu.org/blog/oldherd/)

---

## 作者：SuperJvRuo (赞：1)

这种不带修改的题，对于蒟蒻来说还是倍增比较好写

预处理1~50次方的深度的前缀和，倍增时一段一段计入答案，注意科学取膜
```
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>

#define MOD 998244353
#define LL long long

int Read()
{
    int x = 0; char c = getchar();
    while (!isdigit(c))
    {
        c = getchar();
    }
    while (isdigit(c))
    {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }
    return x;
}

struct Edge
{
    int to, next;
}edge[600002];

int head[300002], cnt;

void Add_edge(int u, int v) 
{
    edge[++cnt] = (Edge) { v, head[u] };
    head[u] = cnt;
    edge[++cnt] = (Edge) { u, head[v] };
    head[v] = cnt;
}

int sum[300002][52],depth[300002],maxdepth;//sum[i][j]记录深度i的j次方的前缀和 
int grand[300002][21];//记录倍增祖先 
bool vis[300002];

void Get_depth(int node)//dfs得到父亲与深度 
{
    vis[node] = 1;
    for (int i = head[node]; i; i = edge[i].next)
    {
        int to=edge[i].to;
        if (!vis[to])
        {
            maxdepth = std::max(depth[to] = depth[node] + 1, maxdepth);
            grand[to][0] = node;
            Get_depth(to);
        }
    }
}

void Fast_power(int dep, int p)//记忆化快速幂，也许可以减小常数 
{
    if (sum[dep][p])
    {
        return;
    }
    if (!p)
    {
        sum[dep][p] = 1;
        return;
    }
    else
    {
        Fast_power(dep, p >> 1);
        if (p & 1)
        {
            sum[dep][p] = (LL)sum[dep][p >> 1] * (LL)sum[dep][p >> 1] % MOD * (LL)dep % MOD;
        }
        else
        {
            sum[dep][p] = (LL)sum[dep][p >> 1] * (LL)sum[dep][p >> 1] % MOD;
        }
    }
    return;
}

void Get_power(int num)
{
    for (int i = 1; i <= maxdepth; ++i)
    {
        for (int j = 50; j >= 1; --j)
        {
            Fast_power(i, j);//快速幂 
        }
    }
    for (int i = 1; i <= maxdepth; ++i)
    {
        for (int j = 1; j <= 50; ++j)
        {
            sum[i][j] = (sum[i][j] + sum[i-1][j])%MOD;//前缀和 
        }
    }
}

void init(int n)
{
    for (int i = 1; (1 << i) <= n; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            grand[j][i] = grand[grand[j][i - 1]][i - 1];//预处理倍增 
        }
    }
}

int Query(int u, int v, int k, int n)//查询
{
    int ans = 0;
    if (depth[u]>depth[v])
    {
        std::swap(u, v);
    }
    int dif = depth[v] - depth[u];
    for (int i = 0; (1 << i) <= dif; ++i)
    {
        if ((1 << i)&dif)
        {
            ans = ((ans - sum[depth[grand[v][i]]][k] + sum[depth[v]][k]) % MOD + MOD) % MOD;
            v = grand[v][i];
        }
    }
    if (u != v)
    {
        for (int i = (int)log2(n); i >= 0; --i)
        {
            if (grand[u][i] != grand[v][i])
            {
                ans = ((ans - sum[depth[grand[u][i]]][k] + sum[depth[u]][k]) % MOD + MOD) % MOD;
                u = grand[u][i];
                ans = ((ans - sum[depth[grand[v][i]]][k] + sum[depth[v]][k]) % MOD + MOD) % MOD;
                v = grand[v][i];
            }
        }
        /*
        / 此时的状况应为： 
        /       LCA
        /      /   \
        /     u    v
        /    /      \
        /  已统计的部分 
        */ 
        //需要加上u、v的答案 
        ans = ((ans - sum[depth[grand[u][0]]][k] + sum[depth[u]][k]) % MOD + MOD) % MOD;
        ans = ((ans - sum[depth[grand[v][0]]][k] + sum[depth[v]][k]) % MOD + MOD) % MOD;
        u = grand[u][0];
    }
    /*
    / 此时的状况应为：
    /      LCA,u,v
    /      /     \
    /    已统计的部分 
    */ 
    //那么再加上LCA的答案即可 
    return ((ans - sum[depth[grand[u][0]]][k] + sum[depth[u]][k]) % MOD + MOD) % MOD;
}

int main()
{
    int n = Read();
    for (int i = 1; i<n; ++i)
    {
        Add_edge(Read(), Read());
    }

    grand[1][0] = 1;
    depth[1] = 0;
    Get_depth(1);
    Get_power(n);
    init(n);

    int m = Read(), u, v, k;
    for (int i = 0; i<m; ++i)
    {
        u = Read(), v = Read(), k = Read();
        printf("%d\n", Query(u, v, k, n));
    }
    return 0;
}
```

---

## 作者：AmamiyaUmi (赞：1)

蒟蒻的广告：http://www.neptuuz.com/wordpress/?p=297

由于k的范围比较小，所以可以开k个线段树，然后就是树剖裸题了，

要注意很多优化的细节，初始化线段树不能一个个点赋值，不然就会变成O(knlogn)然后TLE（怎么评测显示的是RE？loj显示的才是TLE）

复杂度O(kn+mlogn)，还要开个O2才能过

Code:
```cpp
#include<stdio.h>
#include<iostream>
#define MAXN 300010
#define MOD 998244353
#define LL long long
#define pos(l, r) ((l+r) | (l != r))
using namespace std;

int read() {
	int x = 0;
	char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	while (c >= '0' && c <= '9') {
		x = x*10+c-'0';
		c = getchar();
	}
	return x;
}

void write(int x) {
	if (x == 0) putchar('0');
	else {
		int len = 0, dg[20];
		while (x > 0) {
			dg[++len] = x%10;
			x /= 10;
		}
		for (int i = len; i >= 1; --i) putchar(dg[i]+'0');
	}
	putchar('\n');
}

struct Edge {
	int u, v, next;
} e[MAXN*2];

int n, m, h[MAXN], w[MAXN], son[MAXN], id[MAXN], top[MAXN], cnt, par[MAXN], dep[MAXN][51], t[51][MAXN*2], fid[MAXN];

void addEdge(int num, int ui, int vi) {
	e[num] = (Edge) {ui, vi, h[ui]};
	h[ui] = num;
}

void dfs(int u) {
	w[u] = 1;
	for (int i = h[u]; i; i = e[i].next) {
		if (!w[e[i].v]) {
			dep[e[i].v][1] = dep[u][1]+1;
			par[e[i].v] = u;
			dfs(e[i].v);
			w[u] += w[e[i].v];
			if (w[son[u]] < w[e[i].v]) son[u] = e[i].v;
		}
	}
}

void init(int u, int p) {
	id[u] = ++cnt;
	fid[cnt] = u;
	top[u] = p;
	if (son[u]) init(son[u], p);
	for (int i = h[u]; i; i = e[i].next) {
		if (!top[e[i].v]) init(e[i].v, e[i].v);
	}
}

void build(int l, int r, int p, int k) {
	if (l == r) t[k][p] = dep[fid[l]][k];
	else {
		int mid = (l+r)>>1, lc = pos(l, mid), rc = pos(mid+1, r);
		build(l, mid, lc, k);
		build(mid+1, r, rc, k);
		t[k][p] = t[k][lc]+t[k][rc];
		if (t[k][p] >= MOD) t[k][p] -= MOD;
	}
}

int query(int l, int r, int x, int y, int p, int k) {
	if (x <= l && r <= y) return t[k][p];
	int mid = (l+r)>>1, lc = pos(l, mid), rc = pos(mid+1, r), ans = 0;
	if (x <= mid) ans += query(l, mid, x, y, lc, k);
	if (y > mid) ans += query(mid+1, r, x, y, rc, k);
	if (ans >= MOD) ans -= MOD;
	return ans;
}

int solve(int u, int v, int k) {
	int pu = top[u], pv = top[v], res = 0;
	while (pu != pv) {
		if (dep[pu][1] < dep[pv][1]) {
			swap(u, v);
			swap(pu, pv);
		}
		res += query(1, n, id[pu], id[u], pos(1, n), k);
		if (res >= MOD) res -= MOD;
		u = par[pu];
		pu = top[u];
	}
	if (dep[u][1] < dep[v][1]) swap(u, v);
	res += query(1, n, id[v], id[u], pos(1, n), k);
	if (res >= MOD) res -= MOD;
	return res;
}

int main() {
	n = read();
	for (int i = 1, ui, vi; i < n; ++i) {
		ui = read(); vi = read();
		addEdge(i, ui, vi);
		addEdge(i+n, vi, ui);
	}
	dfs(1);
	init(1, 1);
	for (int i = 1; i <= 50; ++i) {
		for (int j = 1; j <= n; ++j) {
			if (i == 1) break;
			dep[j][i] = (LL)dep[j][i-1]*(LL)dep[j][1]%MOD;
		}
		build(1, n, pos(1, n), i);
	}
	m = read();
	for (int i = 1, ui, vi, k; i <= m; ++i) {
		ui = read(); vi = read(); k = read();
		write(solve(ui, vi, k));
	}
	return 0;
}
```

---

## 作者：cz666 (赞：1)

## 题意：

给出一棵有最多 $300000$ 个节点并且根结点编号为 $1$ 的有根树，再给出最多 $300000$ 个询问，每次询问给出 $x,y,k$ ，要求求出在树上 $x$ 到 $y$ 的路径上所有点深度的 $k$ 次方之和（根节点深度为 $0$ ，次方和统计包括点 $x$ 和点 $y$ ）。

## 前置知识：

1. 树上最短距离必然是 $x->lca(x,y)->y$ ，显然成立。

2. 暴力跳 $lca$ 在链的情况下必然会 $TLE$ ，所以还需要掌握倍增 $lca$ 的写法。

3. 每次找出树上最短路然后暴力快速幂累加，最坏每次都要加长度为 $N$ 的一条链，时间复杂度会达到 $O(TNlogN)$ 的级别，必定逃不出 $TLE$ 的命运。看到 $k$ 的范围才 $1$ ~ $30$ 不难想到需要 $N*K$ 的复杂度去预处理k次方的和。

## 思路：

用链式前向星存边并根据题意以 $1$ 号节点为根建树，在建树的过程中顺便处理当前点的深度和当前节点 $2^{0}$ 、 $2^{1}$ 、 $2^{2}$ ······的祖先节点，为后续倍增 $lca$ 做准备。**代码如下：**

```cpp
inline void add(int u,int v){
	edge[++cnt]=v;nxt[cnt]=head[u];head[u]=cnt;
	edge[++cnt]=u;nxt[cnt]=head[v];head[v]=cnt;
}//链式前向星存边方式，很节约空间
inline void build(int x,int fa){
	f[x][0]=fa;dep[x]=dep[fa]+1;//2^0的祖先节点就是父亲节点，dep数组记录深度
	for (int i=1;i<=p[dep[x]];++i) f[x][i]=f[f[x][i-1]][i-1];//得出其他祖先节点
	for (int next=head[x];next;next=nxt[next])
	 if (edge[next]!=fa) build(edge[next],x);//前向星找儿子节点递归下去建树
}
```

 $p$ 数组是一个 $O(log)$ 级变为 $O(1)$ 的预处理常数优化，可以 $O(1)$ 给出 $n$ 以内任意数的 $log_{2}$ 是多少，很有效。**代码如下：**
 
```cpp
for (int i=1;i<=n;++i) p[i]=p[i-1]+(1<<p[i-1]==i);
```

而且这里有用到一个~~算是公式的~~玩意儿吧，就是 $f[x][i]=f[f[x][i-1]][i-1]$ ， $f[x][i]$ 因为存的是点 $x$ 的 $2^{i}$ 的祖先节点，而这个祖先节点是点 $x$ 的 $2^{i-1}$ 的祖先节点的 $2^{i-1}$ 的祖先节点，所以就可以像 $dp$ 一样得到 $x$ 的 $2^{i}$ 的祖先节点。

做完了存边和建树，接下来就是对每次询问给出的 $x$ 和 $y$ 做倍增 $lca$ 了。这个应该不需要多作解释，具体疑问见下面代码里写的注释吧。**代码如下：**

```cpp
inline int lca(int x,int y){
	if (dep[x]<dep[y]) swap(x,y);//默认让x的深度大于y的深度，减少分类讨论
	while(dep[x]>dep[y]) x=f[x][p[dep[x]-dep[y]]-1];
   //倍增将x跳到x的祖先处，直到x和y等深为止
	if (x==y) return x;//如果x=y，代表x和y重合了，那么lca(x,y)就是当前的x
	for (int i=p[dep[x]]-1;i>=0;--i)
	 if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];//如果2^i两者的祖先不同，那么就一起向上跳到2^i，直到它们父亲节点相同为止
	return f[x][0];//返回它们相同的那个父亲节点
}
```

做完倍增 $lca$ ，我们只需要最后一步统计 $k$ 次方和就行了。经过思考，我们发现这条链一定是从深度高的地方到深度低的地方， $lca(x,y)$ 时深度最低，然后再从深度低的到另一个深度高的地方，而且相邻点的深度差都是 $1$ ，所以可以前缀和预处理，然后 $ \Sigma^{r}_{i=l} ksm[i][k]=mi[r][k]-mi[l-1][k]$ 就可以 $O(1)$ 求出 $k$ 次方和了。**代码如下：**

```cpp
inline void pre(){
	for (int i=1;i<=n;++i) mi[i][0]=1;//任意正整数的0次幂为1
	for (int i=1;i<=n;++i) p[i]=p[i-1]+(1<<p[i-1]==i);//前面倍增lca中p数组的预处理
	for (int i=1;i<=n;++i)
	 for (int j=1;j<=50;++j) mi[i][j]=mi[i][j-1]*i%M;//求出i的j次幂对M取模后的值
	for (int i=1;i<=n;++i)
	 for (int j=1;j<=50;++j) mi[i][j]=(mi[i-1][j]+mi[i][j])%M;//对所求的幂次做前缀和
}
```
## 复杂度分析：

时间复杂度稳定 $O(TlogN)$ ，空间复杂度也远远达不到 $512MB$ 。

## 完整无注释代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int L=1000000;
char LZH[L],*SSS,*TTT;
inline char gc(){if (SSS==TTT) TTT=(SSS=LZH)+fread(LZH,1,L,stdin);return *SSS++;}
inline int read(){int x=0,f=1;char c=gc();for (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;for (;c>='0'&&c<='9';c=gc()) x=(x<<1)+(x<<3)+c-48;return x*f;}
inline void write(int x){if(x<0) putchar('-'),x=-x;if(x>9) write(x/10);putchar(x%10+48);}
inline void wln(int x){write(x);putchar(10);}
inline void wlk(int x){write(x);putchar(32);}
const int maxn=300003;
const int M=998244353;
int edge[maxn<<1],nxt[maxn<<1],head[maxn],p[maxn];
int n,cnt,f[maxn][20],dep[maxn],mi[maxn][53];
inline void pre(){
	for (int i=1;i<=n;++i) mi[i][0]=1;
	for (int i=1;i<=n;++i) p[i]=p[i-1]+(1<<p[i-1]==i);
	for (int i=1;i<=n;++i)
	 for (int j=1;j<=50;++j) mi[i][j]=mi[i][j-1]*i%M;
	for (int i=1;i<=n;++i)
	 for (int j=1;j<=50;++j) mi[i][j]=(mi[i-1][j]+mi[i][j])%M;
}
inline void add(int u,int v){
	edge[++cnt]=v;nxt[cnt]=head[u];head[u]=cnt;
	edge[++cnt]=u;nxt[cnt]=head[v];head[v]=cnt;
}
inline void build(int x,int fa){
	f[x][0]=fa;dep[x]=dep[fa]+1;
	for (int i=1;i<=p[dep[x]];++i) f[x][i]=f[f[x][i-1]][i-1];
	for (int next=head[x];next;next=nxt[next])
	 if (edge[next]!=fa) build(edge[next],x);
}
inline int lca(int x,int y){
	if (dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y]) x=f[x][p[dep[x]-dep[y]]-1];
	if (x==y) return x;
	for (int i=p[dep[x]]-1;i>=0;--i)
	 if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
signed main(){
	n=read();pre();
	for (int i=1;i<n;++i) add(read(),read());
	build(1,0);for (int i=1;i<=n;++i) dep[i]--;
	int T=read();while(T--){
		int x=read(),y=read(),k=read();
		int top=lca(x,y),ans=mi[max(dep[x],dep[y])][k];
		ans=(ans+M-mi[dep[top]?dep[top]-1:0][k])%M;
		ans=(ans+mi[min(dep[x],dep[y])][k])%M;
		ans=(ans+M-mi[dep[top]][k])%M;wln(ans);
	}
	return 0;
}
```

完结撒花 $QwQ$ ！

---

## 作者：lqhsr (赞：0)

**总的来说，这题就是一个字:玄！**

首先拿到题目我们都不难想到就是lca

但是题目中要求输出路径中所有点的k次方和

再看看k的范围----k<=50!!!

这么好的性质当然是给我们预处理k次方和的啦

**于是我们记$mem[i][k]$表示$\sum_{j=1}^{j<=i}j^k$**

由于路径上的点的深度必定是连续的一段区间

根据容斥的思想于是我们就可以很快知道**答案就是**

$mem[de[x]-1][k]-mem[de[fa]-2][k]+mem[de[y]-1][k]-mem[de[fa]-1][k]$

其中x,y表示两个节点,de表示深度,fa表示最近公共祖先

~~然后这题就成SB题了~~

我花了一个下午的时间调这题,这里分享一下我过的坑:

**1:所有变量都要初始化**

一开始我的全局变量都没出始化,于是一直RE后来输出de[0]发现它的值是个随机数...

**2.de数组都要加1**

也就是说de[1]=1,在使用时再-1,否则f数组就不对

**3.计算答案时要特判x==y和fa==1**

x==y时如果x==1则 $ans=0$

否则 $ans=(de[x]-1)^k$

fa==1时 $ans=mem[de[x]-1][k]+mem[de[y]-1][k]$

**然后就是代码啦**

```cpp
#include<bits/stdc++.h>
#define int  long long
using namespace std;
int read(){
    int x=0;char ch=getchar();
    while(ch>'9'||ch<'0')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}
int de[1000005],mem[300005][55],n,m,f[300005][55];
const int mod=998244353;
int head[1000005],ji;
struct node{
    int next,yuan;
}ed[10000005];
void dfs(int k,int d){
    for(int i=head[k];i;i=ed[i].next){
        int y=ed[i].yuan;
        if(!de[y]){
            de[y]=d;
            f[y][0]=k;
            for(int j=1;j<=20;j++)f[y][j]=f[f[y][j-1]][j-1];
            dfs(y,d+1);
        }
    }
}
void add(int p,int q){
	ed[++ji].next=head[p];
	ed[ji].yuan=q;
	head[p]=ji;
}
int quick(int b,int p){
    int re=1;
    while(p){
        if(p&1)re=(1ll*re*b)%mod;
        p>>=1;b=(1ll*b*b)%mod;
    }
    return re;
}
int mo(int aa,int bb){
    int re=aa+bb;
    re=((re+mod)%mod%mod);
    return re;
}
void pre(){
    for(int i=1;i<=300005;i++){
    	for(int j=1;j<=50;j++){
            mem[i][j]=mo(mem[i-1][j],quick(i,j));
        }
    }
}
void work(int x,int y,int fa,int k){
    int ans=0;
    de[0]=0;de[1]=1;mem[0][k]=0;
    if(fa!=1){
    	ans=mo(mem[de[x]-1][k]-mem[de[fa]-2][k],mod);
    	ans=mo(ans,mo(mem[de[y]-1][k]-mem[de[fa]-1][k],mod));
   	}else {
   		ans=mem[de[x]-1][k];
   		ans=mo(ans,mem[de[y]-1][k]);
   	}
    if(x!=y)printf("%lld\n",ans);
    else if(x==1)printf("0\n");
    	 else printf("%lld\n",quick(de[x]-1,k));
}
void lca(int x,int y,int k){
    if(de[x]>de[y])swap(x,y);
    int memx=x,memy=y;
    for(int i=20;i>=0;i--){
        if(de[f[y][i]]>=de[x])y=f[y][i];
    }
    if(x==y){work(memx,memy,memx,k);return ;}
    for(int i=20;i>=0;i--){
        if(f[x][i]!=f[y][i]){
            x=f[x][i],y=f[y][i];
        }
    }
    work(memx,memy,f[x][0],k);
}
signed main(){
    pre();
    memset(f,0,sizeof(f));
    memset(de,0,sizeof(de));
    memset(ed,0,sizeof(ed));
    memset(head,0,sizeof(head));
    n=read();
    int cn,cm,ck;
    for(int i=1;i<n;i++){
		int cn=read(),cm=read();
		add(cn,cm);add(cm,cn);
	}
    de[1]=1;
    dfs(1,2);
    m=read();
    for(int i=1;i<=m;i++){
        cn=read(),cm=read(),ck=read();
        lca(cn,cm,ck);
    }
}
```

就这么多了,我得吃饭去啦

---


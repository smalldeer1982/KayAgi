# [POI 2002] 商务旅行

## 题目描述

某地首都的商人要经常到其他城镇去做生意，他们会按自己的路线去走。

有 $N$ 个城镇，首都编号为 $1$。商人从首都出发，其他各城镇之间都有道路连接。

任意两个城镇之间如果有直连道路，在他们之间行驶需要花费单位时间。如果从首都出发，能到达任意一个城镇。

请你求出商人最短的旅行时间。

## 说明/提示

数据范围：$1 \le N \le 30000$。**保证公路网络不会存在环。**

## 样例 #1

### 输入

```
5
1 2
1 5
3 5
4 5
4
1
3
2
5```

### 输出

```
7```

# 题解

## 作者：_lqs_ (赞：5)

看到这题，想都没想就打了一个 dijkstra 算法，但是我没看到时限，为了这道题还专门学了最近公共祖先。

# solution
- 这道题由于输入的是 $n-1$ 条边，所以我们自然而然的想到这是一棵树，路径只有一条，而树上有很多性质，因此我们可以进行一下分析，先将图画出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/2aqsin41.png)

- 从图中可以知道以下信息：

1. 如果两个点在根节点两侧，假如是要从点 $now$ 到点 $ a$ ,用 $p$ 表示 $now$ 到 $a $ 的最短路径，用 $ dis$ 数组表示根节点到其他点的最短路径，则有：
$$ p=dis_{now}+dis_{a} $$

2. 这个结论的正确性显然：分居根节点两侧，直接把两点到根节点的距离相加即可.

3. 如果在同一侧，就要判断这两点的最近公共祖先是否是其中一个点，请读者思考为什么是最近公共祖先。如果不是，设最近公共祖先为 $p1$ ,那么有：
$$p=dis_{now}+dis_{a}-2 \cdot dis_{p1}$$

4. 至于为什么乘 $2$ ,读者可以参考上面的图，点 $3$ 和点 $4$ 的最近公共祖先是点 $5$ ，点 $3$ 到点 $5$ 的最短路径是 $dis_{3}-dis_{5}$ ,点 $4$ 到点 $5$ 的最短路径是 $dis_{4}-dis_{5}$ ,两者相加即可得到以上式子。

5. 如果最近公共祖先是其中一个点呢？那也非常简单，跟上面提到的第一个式子类似，用最短路径较大的减去最短路径较小的即可：
$$p=dis_{now}-dis_{a}$$

6. 第一和第二个式子其实可以合并，因为如果在根节点两侧，其最近公共祖先必定是根节点，而根节点的最短路径是 $0$ ,所以没有任何影响。
6. 注意：以上所有式子都是默认 $dis_{now} \ge dis_{a}$ ,因此在代码中记得加上绝对值符号。

7. 若对最近公共祖先有不懂的，可以去[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)加以学习。

# code
```cpp
#include<bits/stdc++.h>
#define N 30005
using namespace std;
int n,m,i,j,ans,a,b,c,x,y,t,now=1,k;
int dis[N],h[N*30],f[N],u[N];
int p[N][25];
struct AB{
	int a,b,n;
}d[N*2];
void cun(int a,int b){//链式前向星存图
	d[++k].a=a,d[k].b=b;
	d[k].n=h[a],h[a]=k;
}
void dfs(int u,int last){//dfs求出根节点到每个点的最短路径
    dis[u]=dis[last]+1;
    p[u][0]=last;
    for(int i=1;(1<<i)<=dis[u];i++)
        p[u][i]=p[p[u][i-1]][i-1];
    for(int i=h[u];i;i=d[i].n){
        int v=d[i].b;
        if(v!=last) dfs(v,u);
    }
}                               
int lca(int a,int b){//lca模板,这是本题的核心，若有不懂一定要去学习
    if(dis[a]>dis[b]) swap(a,b);   
    for(int i=20;i>=0;i--){
    	if(dis[a]<=dis[b]-(1<<i)) b=p[b][i];
	}
    if(a==b) return a;                
    for(int i=20;i>=0;i--){
        if(p[a][i]==p[b][i]) continue;
        else a=p[a][i],b=p[b][i];         
    }
    return p[a][0];              
}
int main(){
	memset(h,-1,sizeof(h));
	scanf("%d",&n);
	for(i=1;i<=n-1;i++){
		scanf("%d%d",&a,&b);
		cun(a,b);
		cun(b,a);
	}
	dfs(1,0);
	scanf("%d",&m);
	for(i=1;i<=m;i++){
		scanf("%d",&a);
        int p1=lca(a,now);
        if(p1!=a && p1!=now) ans+=(dis[a]+dis[now]-dis[p1]*2);//式子1和式子2合并
        else ans+=(abs(dis[now]-dis[a]));//式子3的推论，记得加abs
        now=a;//更新下一个起点
	} 
	printf("%d",ans);
	return 0;
}
```


---

## 作者：mysterys (赞：3)

翻了题解区的  $3$  篇题解，都没有发现树上差分的写法，于是就有了这篇题解。
# 前置知识
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
1. [树上差分——P3128 [USACO15DEC]Max Flow P](https://www.luogu.com.cn/problem/P3128)
# 思路
这题其实和 [P6869](https://www.luogu.com.cn/problem/P6869) 很像，只不过本题中访问顺序并不是从小到大，而是按给定顺序访问。

**具体的说**，考虑对每一条边进行差分操作，最后  ```dfs```  总计出每一条走过的次数，求和即为答案。
# $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define FILE(x) freopen(x".in", "r", stdin);freopen(x".out", "w", stdout);
#define ll long long
#define endl '\n'
const int _=30005;
int n,m;
struct node{
	int to,nxt;
}e[_<<1];
int head[_],cnt;
int fa[_][20],deep[_];
int Q[_],val[_<<1],ans;
inline void add(int u,int v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
inline void init(int x,int dad){
	fa[x][0]=dad;
	deep[x]=deep[dad]+1;
	for(int i=1;(1<<i)<=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=head[x];i;i=e[i].nxt){
		if(e[i].to!=dad) init(e[i].to,x);
	}
}
inline int getlca(int x,int y){//倍增求LCA
	if(deep[x]<deep[y]) swap(x,y);
	for(int i=19;i>=0;i--){
		if(deep[fa[x][i]]>=deep[y]) x=fa[x][i];
		if(x==y) return x;
	}
	for(int i=19;i>=0;i--){
		if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	}
	return fa[x][0];
}
inline void dfs(int x){
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa[x][0]){
			dfs(v);
			val[x]+=val[v];
		}
	}
	ans+=val[x];//总计答案
}
signed main(){
	cin.tie(nullptr)->ios::sync_with_stdio(false);
	cout.tie(nullptr);
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);add(v,u);
	}
	init(1,0);
	cin>>m;
	Q[0]=1;
	for(int i=1;i<=m;i++){
		cin>>Q[i];
	}
	for(int i=1;i<=m;i++){
		int Lca=getlca(Q[i-1],Q[i]);
		val[Q[i-1]]++;val[Q[i]]++;//边差分
		val[Lca]-=2;
	}
	dfs(1);
	cout<<ans;
	return 0;
}
```

---

## 作者：xiezheyuan (赞：3)

[可能有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p8855.html)

## 简要题意

给出一个 $N$ 个节点的树和一个长度为 $M$ 的序列 $S$。你需要从 $1$ 出发，依次经过 $S$ 中的所有点，求至少需要经过的边数。

$1 \le N \le 30000$

## 思路

首先先给出一个结论：树上两点之间的最短离，等于两点的深度和减去其最近公共祖先的两倍。

证明如下（令 $d(u)$ 为 $u$ 的深度，$r$ 为树根，$a(u,v)$ 为从 $u$ 到 $v$ 的最短距离，$l(u,v)$ 为 $u,v$ 的最近公共祖先）：

$$
\begin{aligned}
&d(u)+d(v)-2d(l(u,v))\\
&=a(r,u)+a(r,v)-a(r,l(u,v))-a(r,l(u,v))\\
&=a(l(u,v),u)+a(r,l(u,v))+a(l(u,v),v)+a(r,l(u,v))-a(r,l(u,v))-a(r,l(u,v))\\
&=a(l(u,v),u)+a(l(u,v),v)\\
&=a(u,v)
\end{aligned}
$$

然后的过程就很简单了，使用树剖（用于求最近公共祖先）和上述结论求出 $a(1,S_1)+a(S_1,S_2)+\cdots+a(S_{M-1}+S_{M})$ 即可。

时间复杂度 $O(N+M\log N)$，可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 500005;

struct edge {
	int nxt, to;
} g[N << 1];
int head[N << 1], ec;
void add(int u, int v) {
	g[++ec].nxt = head[u];
	g[ec].to = v;
	head[u] = ec;
}

int root;
int siz[N], son[N], fa[N], top[N], dep[N];
void dfs1(int u, int father, int deep) {
	dep[u] = deep;
	siz[u] = 1;
	fa[u] = father;
	for (int i = head[u]; i; i = g[i].nxt) {
		int v = g[i].to;
		if (v == father) {
			continue;
		}
		dfs1(v, u, deep + 1);
		siz[u] += siz[u];
		if (siz[v] >= siz[son[u]]) {
			son[u] = v;
		}
	}
}

void dfs2(int u, int father, int t) {
	top[u] = t;
	if (son[u])dfs2(son[u], u, t);
	for (int i = head[u]; i; i = g[i].nxt) {
		int v = g[i].to;
		if (v == father) {
			continue;
		}
		if (v == son[u]) {
			continue;
		}
		dfs2(v, u, v);
	}
}

int lca(int x, int y) {
	int fx = top[x], fy = top[y];
	while (fx != fy) {
		if (dep[fx] < dep[fy]){
			swap(fx, fy);
			swap(x, y);
		}
		x = fa[fx], fx = top[x];
	}
	if (dep[x] > dep[y]) {
		return y;
	}
	else return x;
}


int n,m,s;

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	dfs1(1,0,1);
	dfs2(1,0,1);
	cin>>m;
	int ret=0,u=1,v=0;
	while(m--){
		cin>>v;
		ret+=(dep[u]+dep[v]-2*dep[lca(u,v)]); // 运用结论
		u=v;
	}
	cout<<ret;
	return 0;
}
```

---

## 作者：lrqlrq250 (赞：3)

## 解题思路
首先注意到这是 $N$ 个点 $N - 1$ 条边且没有环的连通图，因此一定是一棵树。

因此任意两点间的距离是固定的，我们就可以直接 $\mathit{LCA}$ 求距离了，有：

$$dis(x, y) = dis(root, x) + dis(root, y) - 2 \cdot dis(root, \mathit{LCA}(x, y))$$

显然钦定哪个节点为根对结果不会有影响，不断求出相邻两个要访问的城市之间的距离累加即可。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
struct Edge{int to, next;}e[60005];
int n, m, head[30005], tot, t, dep[30005], f[30005][18];

inline void addedge(int u, int v){
	e[++tot].to = v;
	e[tot].next = head[u];
	head[u] = tot;
}

inline int LCA(int x, int y){
	if (dep[x] > dep[y]) swap(x, y);
	for (int i=t; i>=0; i--) if (dep[f[y][i]] >= dep[x]) y = f[y][i];
	if (x == y) return x;
	for (int i=t; i>=0; i--) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0]; 
}

int main(){
	scanf("%d", &n);
	int u, v;
	for (int i=1; i<n; i++){
		scanf("%d%d", &u, &v);
		addedge(u, v); addedge(v, u);
	}
	t = (int)log2(n) + 1;
	queue<int> q; q.push(1); dep[1] = 1;
	while (!q.empty()){
		u = q.front(); q.pop();
		for (int i=head[u]; i; i=e[i].next) if (!dep[e[i].to]){
			v = e[i].to;
			dep[v] = dep[u] + 1;
			f[v][0] = u;
			for (int j=1; j<=t; j++) f[v][j] = f[f[v][j - 1]][j - 1];
			q.push(v);
		}
	}
	int last = 1, ans = 0;
	scanf("%d", &m);
	while (m--){
		scanf("%d", &u);
		ans += dep[u] + dep[last] - 2 * dep[LCA(u, last)];
		last = u;
	}
	printf("%d\n", ans);
	return 0;
}
```


---


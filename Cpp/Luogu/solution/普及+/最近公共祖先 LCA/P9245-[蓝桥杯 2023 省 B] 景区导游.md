# [蓝桥杯 2023 省 B] 景区导游

## 题目描述

某景区一共有 $N$ 个景点，编号 $1$ 到 $N$。景点之间共有 $N-1$ 条双向的摆渡车线路相连，形成一棵树状结构。在景点之间往返只能通过这些摆渡车进行，需要花费一定的时间。

小明是这个景区的资深导游，他每天都要按固定顺序带客人游览其中 $K$ 个景点：$A_{1},A_{2},\ldots,A_{K}$。今天由于时间原因，小明决定跳过其中一个景点，只带游客按顺序游览其中 $K-1$ 个景点。具体来说，如果小明选择跳过 $A_{i}$，那么他会按顺序带游客游览 $A_{1},A_{2},\ldots,A_{i-1},A_{i+1},\ldots,A_{K}(1 \leq i \leq K)$。

请你对任意一个 $A_{i}$，计算如果跳过这个景点，小明需要花费多少时间在景点之间的摆渡车上？

## 说明/提示

**【样例说明】**

原路线是 $2 \rightarrow 6 \rightarrow 5 \rightarrow 1$。

当跳过 $2$ 时，路线是 $6 \rightarrow 5 \rightarrow 1$，其中 $6 \rightarrow 5$ 花费时间 $3+2+2=7$，$5 \rightarrow 1$ 花费时间 $2+1=3$，总时间花费 $10$。

当跳过 $6$ 时，路线是 $2 \rightarrow 5 \rightarrow 1$，其中 $2 \rightarrow 5$ 花费时间 $1+1+2=4$，$5 \rightarrow 1$ 花费时间 $2+1=3$，总时间花费 $7$。

当跳过 $5$ 时，路线是 $2 \rightarrow 6 \rightarrow 1$，其中 $2 \rightarrow 6$ 花费时间 $1+1+2+3=7$，$6 \rightarrow 1$ 花费时间 $3+2+1=6$ ，总时间花费 $13$。

当跳过 $1$ 时，路线时 $2 \rightarrow 6 \rightarrow 5$，其中 $2 \rightarrow 6$ 花费时间 $1+1+2+3=7$，$6 \rightarrow 5$ 花费时间 $3+2+2=7$ ，总时间花费 $14$。


**【评测用例规模与约定】**

对于 $20 \%$ 的数据，$2 \leq K \leq N \leq 100$。

对于 $40 \%$ 的数据，$2 \leq K \leq N \leq 10^{4}$。

对于 $100 \%$ 的数据，$2 \leq K \leq N \leq 10^{5}$，$1 \leq u,v,A_{i} \leq N$，$1 \leq t \leq 10^{5}$。保证 $A_{i}$ 两两不同。 

蓝桥杯 2023 省赛 B 组 I 题。

## 样例 #1

### 输入

```
6 4
1 2 1
1 3 1
3 4 2
3 5 2
4 6 3
2 6 5 1```

### 输出

```
10 7 13 14
```

# 题解

## 作者：kouki_hash (赞：5)

最近正在学 LCA，正好看到蓝桥杯省赛这题，似乎刚放上去还没有题解，正好作为本蒟蒻第一篇题解练练手~~结果发现不会写题解~~。

## 题意分析
题意比较简单，在一棵有 $N$ 个点的无向有权树上选出 $K$ 个点，随后有 $K$ 个询问，每次询问会跳过一个点，跳过的点从1、2、3依次到 $K$，求每次依次访问剩余点的路径权值和最小值。

## 解题思路
首先很容易得出：由于访问顺序固定，任意连续访问点之间的路径权值和都要最小，这样按顺序访问所有点后的路径权值和一定最小。而一棵无向树上任意两点的最短路径有且只有一条，并且经过这两点的 LCA 即最近公共祖先（不管边带不带权都一样）。这样的最短路径很好求得，用树上前缀和 sum[i] 表示树根到结点i的路径权值和，那么任意两点 a 和 b 的最短路径为
$$dis(a,b)=sum[a]+sum[b]-2 \times \operatorname{LCA}(a,b)$$
再求出按原访问顺序的路径权值前缀和，对于 $A _ {i}$ 有
$$ans[i]=dis(A _ {1},A _ {2})+dis(A _ {2},A _ {3})+\dots+dis(A _ {i-1},A _ {i})(2 \le i \le K)$$
那么当跳过 $A _ {i}$ 时，答案就是
$$\begin{cases} ans[K]-ans[2] & i = 1 \\ ans[i-1]+dis(a[i-1],a[i+1])+ans[K]-ans[i+1] & 2 \le i \le K-1 \\ ans[K-1] & i = K \end{cases}$$
那么问题来到如何求出一些给定点对的 LCA。这里本蒟蒻用了离线算法 Tarjan 算法，~~因为懒得写倍增~~因为赛时可以比较快捷地实现。

简单来说，此题需要以下步骤：读入树后，进行一次 DFS 预处理出所有结点的树上前缀和 sum[i]。读入游览线路，记录下相邻数对和间隔数对。跑一遍 Tarjan 算法，求出按照原访问顺序的路径权值前缀和，求出答案。时间复杂度为 $O\left(m\,\alpha(m+n, n) + n\right)$。

## 具体代码
```cpp
#include <bits/stdc++.h>
using namespace std;

long long a[100005];

bool vis1[100005];
long long sum[100005];

bool vis2[100005];
long long fa[100005];
vector<long long>q[100005];//保存要查询的点对，离线查询

map<pair<long long, long long>, long long>ma;//保存点对及其LCA

long long ans[100005];

struct node {
	long long v;
	long long t;
} edge;

vector<struct node>g[100005];

long long find(long long x) {
	if (fa[x] == x) {
		return x;
	} else {
		return fa[x] = find(fa[x]);
	}
}

void dfs(long long x) {//预处理求出树上前缀和
	vis1[x] = true;

	for (long long i = 0; i < g[x].size(); i++) {
		if (vis1[g[x][i].v] != true) {
			sum[g[x][i].v] = g[x][i].t + sum[x];
			dfs(g[x][i].v);
		}
	}
	return;
}

void tarjan(long long x) {//标准tarjan模板
	vis2[x] = true;

	for (long long i = 0; i < g[x].size(); i++) {
		if (vis2[g[x][i].v] == false) {
			tarjan(g[x][i].v);
			fa[g[x][i].v] = x;
		}
	}

	for (long long i = 0; i < q[x].size(); i++) {
		if (vis2[q[x][i]] == true) {
			ma[ {x, q[x][i]}] = find(q[x][i]);
			ma[ {q[x][i], x}] = find(q[x][i]);
		}
	}
	return;
}

long long get_dis(long long x, long long y) {//求出树上两点最短路径
	return sum[x] + sum[y] - 2 * sum[ma[ {x, y}]];
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	long long n, k;
	cin >> n >> k;

	for (long long i = 1; i < n; i++) {
		long long u, v, t;
		cin >> u >> v >> t;

		g[u].push_back({v, t});
		g[v].push_back({u, t});
	}

	dfs(1);//预处理出树上前缀和

	for (long long i = 1; i <= k; i++) {//离线保存所需查询
		cin >> a[i];
		if (i >= 2) {//相邻点对
			q[a[i]].push_back(a[i - 1]);
			q[a[i - 1]].push_back(a[i]);
		}
		if (i >= 3) {//间隔点对
			q[a[i]].push_back(a[i - 2]);
			q[a[i - 2]].push_back(a[i]);
		}
	}

	for (long long i = 1; i <= n; i++) {//tarjan算法初始化
		fa[i] = i;
	}

	tarjan(1);//预处理出所求LCA

	for (long long i = 2; i <= k; i++) {//按原访问顺序的路径权值前缀和
		ans[i] = ans[i - 1] + get_dis(a[i], a[i - 1]);
	}

	for (long long i = 1; i <= k; i++) {//分段得出答案
		if (i == 1) {
			cout << ans[k] - ans[2] << " ";
		} else if (i == k) {
			cout << ans[k - 1] << " ";
		} else {
			cout << ans[i - 1] + get_dis(a[i - 1], a[i + 1]) + ans[k] - ans[i + 1] << " ";
		}
	}
	return 0;
}
```

提交，AC，然后这篇题解就结束了~~果然写题解好难~~。

---

## 作者：Erik_Aoi (赞：2)

### 题意：
给出一个 $n$ 节点的带权树和一个长度为 $k$ 的原始路径 $route$，要求对于路径中每个点 $i$，求移去该点时所需的总代价。 

### 思路：
1. 注意到数据规模为 $10^5$，因此当算法时间复杂度为 $O(n\log n)$ 时可以解决问题。  
   对于一个含 $k$ 个路径点的路径，对每个路径点 $i$，只需计算：
   - 相邻的 $route[i-1]$ 到 $route[i]$ 的距离 $cost[i]$；
   - 跳过中间点（即 $route[i-2]$ 直接到 $route[i]$）的距离 $jump[i]$。

2. 这时候遍历每个路径点 $route[i]$ 时，就可以分三种情况计算总代价：
   $$ans(i)=\begin{cases}
   \sum_{j=3}^{k} cost[j], &i=1,\\
   \sum_{j=2}^{k-1} cost[j], &i=k,\\
   \sum_{j=2}^{i-1} cost[j]+jump[i+1]+\sum_{j=i+2}^{k} cost[j], &2\le i\le k-1.
   \end{cases}$$

3. 为了高效计算区间内 $cost$ 的累加和：
   - 构造前缀和数组 $pre$，使得查询区间和的时间复杂度为 $O(1)$。
   - 使查询两点间距离的复杂度为 $O(\log n)$，总体时间复杂度为 $O(k\log n)$。

4. 因此，使用**倍增**求解最近公共祖先和两点距离：
   - 选取任意节点（这里选节点 $1$）作为根节点，通过 DFS 计算每个节点到根节点的总距离 $dis[i]$。
   - 构造倍增数组，其转移方程为：  
     $$fa[cur][i]=fa[fa[cur][i-1]][i-1]$$
   - 两点 $u$ 和 $v$ 的距离为：  
     $$dis[u]+dis[v]-2\cdot dis[LCA(u,v)]$$
   - 构造倍增数组时间复杂度为 $O(n\log n)$，查询复杂度为 $O(k\log n)$，总时间复杂度为 $O((n+k)\log n)$。


```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#define int long long

using namespace std;

vector<pair<int, int>> e[100005];
int n, m, k;
int fa[100005][25] = { 0 };
int dep[100005] = { 0 };

int route[100005] = { 0 };
int dis[100005] = { 0 };
int jump[100005] = { 0 };
int pre[100005] = { 0 };

void dfs(int cur, int from) {
    fa[cur][0] = from;
    dep[cur] = dep[from] + 1;

    for (int i = 1; i <= 24; i++) {
        fa[cur][i] = fa[fa[cur][i - 1]][i - 1];
    }

    for (auto [u, w] : e[cur]) {
        if (u == from) continue;
        dis[u] = dis[cur] + w;
        dfs(u, cur);
    }
}

int lca(int x, int y) {
    if (dep[x] > dep[y]) swap(x, y);
    int dis = dep[y] - dep[x];
    for (int i = 0; dis; i++, dis >>= 1) {
        if (dis & 1) y = fa[y][i];
    }
    if (x == y) return y;
    for (int i = 24; i >= 0; i--) {
        if (fa[x][i] != fa[y][i]) {
            x = fa[x][i], y = fa[y][i];
        }
    }
    return fa[y][0];
}

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> n >> k;
    for (int i = 1; i <= n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({ v,w });
        e[v].push_back({ u,w });
    }
    for (int i = 1; i <= k; i++) cin >> route[i];
    dfs(1, 1);

    //pre[i]表示从route[1]依次到route[i]的总花费，jump[i]表示从route[i-2]跳到route[i]的花费。
    for (int i = 2; i <= k; i++) {
        int x = route[i - 1], y = route[i];
        int fa = lca(x, y);
        pre[i] = pre[i - 1] + dis[x] + dis[y] - 2 * dis[fa];
        if (i + 1 <= k) {
            int z = route[i + 1];
            fa = lca(x, z);
            jump[i + 1] = dis[x] + dis[z] - 2 * dis[fa];
        }
    }

    for (int i = 1; i <= k; i++) {
        int ans = 0;
        if (i == 1) ans = pre[k] - pre[2];
        else if (i == k) ans = pre[k - 1];
        else ans = pre[i - 1] + jump[i + 1] + pre[k] - pre[i + 1];
        cout << ans << " ";
    }

    return 0;
}

```
### 关于优化（主要集中在 LCA）：

可以使用**欧拉序列 RMQ** 来 $ O(1) $ 查找父亲节点。因为本蒟蒻只会 ST 表，时间复杂度约为 $ O(n \log n + k) $；又因为该欧拉序列的大小是 $ 2n $，而 $ k\leq n $，因此反倒会因为常数较大比倍增慢。

**欧拉序列**：[提交记录](https://www.luogu.com.cn/record/209430738)

**朴素 tarjan 并查集**能做到比倍增更优，但同欧拉序列一样，常数较大，不如重链剖分：[提交记录](https://www.luogu.com.cn/record/209624695)

**重链剖分**可以把时间复杂度降到 $ O(n + k\log n) $：[提交记录](https://www.luogu.com.cn/record/209576509)

最后，**不必构建前缀和数组**。只需先求出完整走完的总花费，然后求移去某个节点后变化的花费即可。

以下是重链剖分且省去前缀和数组的代码，代码复杂度、时间复杂度和空间复杂度都较优：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#define int long long

using namespace std;

vector<pair<int, int>> e[100005];
int n, m, k;
int dep[100005] = { 0 };
int fa[100005] = { 0 };
int siz[100005] = { 0 };
int son[100005] = { 0 };
int top[100005] = { 0 };

int route[100005] = { 0 };
int dis[100005] = { 0 };
int jump[100005] = { 0 };
int to[100005] = { 0 };

void dfs1(int cur) {
    siz[cur] = 1;
    for (auto [u, w] : e[cur]) {
        if (dep[u]) continue;
        dis[u] = dis[cur] + w;
        dep[u] = dep[cur] + 1;
        fa[u] = cur;
        dfs1(u);
        siz[cur] += siz[u];
        if (siz[u] > siz[son[cur]]) son[cur] = u;
    }
}

void dfs2(int cur, int t) {
    top[cur] = t;
    if (!son[cur]) return;
    dfs2(son[cur], t);
    for (auto [u, w] : e[cur]) {
        if (u != son[cur] and u != fa[cur]) dfs2(u, u);
    }
}

int lca(int x, int y) {
    while (top[x] != top[y]) {
        if (dep[top[x]] > dep[top[y]]) x = fa[top[x]];
        else y = fa[top[y]];
    }
    return dep[x] < dep[y] ? x : y;
}

int getsum(int x, int y) {
    int fa = lca(x, y);
    return dis[x] + dis[y] - 2 * dis[fa];
}

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> n >> k;
    for (int i = 1; i <= n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({ v,w });
        e[v].push_back({ u,w });
    }
    for (int i = 1; i <= k; i++) cin >> route[i];
    dep[1] = 1;
    dfs1(1);
    dfs2(1, 1);

    int sum = 0;

    for (int i = 2; i <= k; i++) sum += to[i] = getsum(route[i - 1], route[i]);
    
    for (int i = 1; i <= k; i++) {
        int ans = 0;
        if (i == 1) ans = sum - to[i + 1];
        else if (i == k) ans = sum - to[i];
        else ans = sum - to[i] - to[i + 1] + getsum(route[i - 1], route[i + 1]);
        cout << ans << " ";
    }
    return 0;
}

```

---

## 作者：liumuyunC2026 (赞：0)

经过同机房大佬 [yuruilin2026](https://www.luogu.com.cn/user/1294410) 和 [Hootime](https://www.luogu.com.cn/user/1275540 ) 的帮助下成功 **AC** 了这道题。

# 做题思路

这道题是一道求树的点与点之间边的长度的题，很容易想到用 **LCA** 求解。

统计时，先按顺序将点队之间距离累加，记做 $ans$。$dist(i,j) = dist[i] + dist[j] - 2 \times dist[lca(i,j)]$ 。

遍历一遍。

1. 当 $i = 1$ 时，$ans = cnt- dist[1] - dist[2] + 2  \times dist[lca(1,2)]$。

2. 当 $i > 1$ 且 $i < k$ 时，$ans = cnt - 2 \times dist[i] + 2 \times dist[lca(i-1,i)] + 2 \times dist[lca(i,i+1)] - 2 \times dist[lca(i-1,i+1)]$。

3. 当 $i = k$ 时，$ans = cnt - dist[k-1] - dist[k] + 2 \times dist[lca(k-1,k)]$。

# 代码实现


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
struct Edge{
	int to,w,next;
}e[N];
int head[N],d[N],dist[N],st[N][21],x[N];
int n,k,u,v,w,cnt;
void dfs(int u)
{
	for(int j=1;j<=20;j++) st[u][j]=st[st[u][j-1]][j-1];
	for(int i=head[u];~i;i=e[i].next)
	{
		int v=e[i].to,w=e[i].w;
		if(v==st[u][0]) continue;
		st[v][0]=u,d[v]=d[u]+1,dist[v]=dist[u]+w;
		dfs(v);
	}
}
void add(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	e[cnt].w=w;
	head[u]=cnt;
}
int lca(int x,int y)
{
	int k=log2(n);
	if(d[x]>d[y]) swap(x,y);
	for(int i=k;i>=0;i--)
	{
		if(d[st[y][i]]>=d[x]) y=st[y][i];
	}
	if(x==y) return x;
	for(int i=k;i>=0;i--)
	{
		if(st[x][i]!=st[y][i]&&st[x][i]&&st[y][i]) x=st[x][i],y=st[y][i];
	}
	return st[x][0];
}
signed main()
{
	memset(head,-1,sizeof(head));
	memset(dist,0,sizeof(dist));
	memset(d,0,sizeof(d));
	
	cin>>n>>k;
	for(int i=1;i<n;i++)
	{
		cin>>u>>v>>w;
		add(u,v,w),add(v,u,w);
	}
	d[1]=1;
	dfs(1);
	int ans=0;
	for(int i=1;i<=k;i++) cin>>x[i];
	for(int i=2;i<=k;i++) ans=ans+dist[x[i-1]]+dist[x[i]]-2*dist[lca(x[i-1],x[i])];
	for(int i=1;i<=k;i++)
	{
		if(i==1) cout<<ans-dist[x[1]]-dist[x[2]]+2*dist[lca(x[1],x[2])]<<" ";
		else if(i!=k)
			cout<<ans-dist[x[i-1]]-2*dist[x[i]]-dist[x[i+1]]+2*dist[lca(x[i],x[i-1])]+2*dist[lca(x[i],x[i+1])]+dist[x[i-1]]+dist[x[i+1]]-2*dist[lca(x[i-1],x[i+1])]<<" ";
		else cout<<ans-dist[x[k-1]]-dist[x[k]]+2*(dist[lca(x[k-1],x[k])]);
	}
}
```

---

## 作者：Meickol (赞：0)

挺简单的题，十五分钟切了。

LCA + 树上前缀和 + 枚举，按题意模拟即可。

先算出原本游览 $k$ 个景点需要的总时间记为 $sum$。

然后依次枚举跳过 $i$ 号景点，更新一下距离即可。

比较简单就不多作解释了，计算两点之间的时间使用的是树上前缀和思想统计两点间的边前缀和，$dist_i$ 表示从 $1$ 号点出发到达 $i$ 号点的距离前缀和。

具体思路实现可见代码。

时间复杂度 $\mathcal O(n \log n)$。

```cpp
#define rep(x,y,z) for(int x=y;x<=z;x++)
typedef long long LL;
const int N=1e5+5,M=N*2;
int n,k;
int e[M],ne[M],h[N],w[M],idx;
void add(int a,int b,int c){
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
int order[N];
int dep[N],fa[N][25];
LL dist[N];
void dfs(int u,int father){
	if(father==-1) dep[u]=1;
	else dep[u]=dep[father]+1,fa[u][0]=father;
	rep(i,1,20) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=h[u];~i;i=ne[i]){
		int j=e[i];
		if(j==father) continue;
		dist[j]=dist[u]+w[i];
		dfs(j,u);
	}
}
int lca(int u,int v){
	if(dep[u]<dep[v]) swap(u,v);
	per(i,20,0) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
	if(u==v) return v;
	per(i,20,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
void solve(){
	memset(h,-1,sizeof h);
	cin>>n>>k;
	rep(i,1,n-1){
		int a,b,c;
		cin>>a>>b>>c;
		add(a,b,c);
		add(b,a,c);
	}
	dfs(1,-1);
	rep(i,1,k) cin>>order[i];
	LL sum=0;
	rep(i,1,k-1){
		int x=order[i],y=order[i+1];
		int anc=lca(x,y);
		int d=dist[x]+dist[y]-dist[anc]*2;
		sum+=d;
	}
	rep(i,1,k){ // 跳过 i 点
		LL tmp=sum;
		if(i-1>=1){
			int x=order[i];
			int y=order[i-1];
			int anc=lca(x,y);
			LL d=dist[x]+dist[y]-dist[anc]*2;
			tmp-=d;
		}
		if(i+1<=k){
			int x=order[i];
			int y=order[i+1];
			int anc=lca(x,y);
			LL d=dist[x]+dist[y]-dist[anc]*2;
			tmp-=d;
		}
		if(i-1>=1 && i+1<=k){
			int x=order[i-1];
			int y=order[i+1];
			int anc=lca(x,y);
			LL d=dist[x]+dist[y]-dist[anc]*2;
			tmp+=d;
		}
		cout<<tmp<<" ";
	}
}
```

---


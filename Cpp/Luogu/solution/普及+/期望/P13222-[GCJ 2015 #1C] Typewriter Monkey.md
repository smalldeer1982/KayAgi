# [GCJ 2015 #1C] Typewriter Monkey

## 题目描述

你的出版社决定让猴子随机敲击键盘来创作伟大的文学作品。你是一个猴子的监督员，这只猴子的键盘上有 $K$ 个按键，每个按键上都标有一个大写英文字母（同一个字母可能出现在多个按键上）。猴子将从一个空字符串开始，重复 $S$ 次以下操作：从键盘上等概率随机选择一个按键并按下，将该按键上的字母添加到字符串的末尾。最终得到的字符串长度为 $S$。

你有一个长度为 $L$ 的*目标单词*，你希望猴子能够敲出来（目标单词不一定是真正的英文单词）。这个目标单词可能在猴子敲出的字符串中出现多次（重叠的情况也算，例如目标单词为 "ABA"，猴子敲出 "ABABA" 时，包含两个 "ABA"）。

你打算每出现一次目标单词就给猴子一根香蕉。当你去检查猴子的作品时，你会带上足够多的香蕉，以保证无论猴子敲出了什么，你都能支付得起。然后，你会根据猴子实际敲出的目标单词次数支付香蕉，剩下的香蕉归你所有。

你期望最终能留下多少根香蕉？

## 说明/提示

**样例解释**

注意，第 5 组样例不在 Small 数据集的范围内。

在第 1 组样例中，猴子根本无法敲出目标单词 "MONKEY"（因为键盘上缺少目标单词中的大部分字母），所以你无需带香蕉，也不会支付任何香蕉。可怜的猴子！

在第 2 组样例中，猴子一定会敲出 "AAAA"，其中目标单词 "AAA" 会出现两次（重叠），你需要带两根香蕉并全部支付出去。

在第 3 组样例中，猴子可能敲出的字符串有 "AA"、"AB"、"BA"、"BB"，每种概率均为 $1/4$，它们分别包含 0、1、1、2 次目标单词。你需要带两根香蕉以备 "BB" 的情况，但平均支付 $(0 + 1 + 1 + 2) / 4 = 1$ 根香蕉。

在第 4 组样例中，猴子第一步有 $1/3$ 的概率敲 "G"，第二步有 $1/3$ 的概率敲 "O"，所以敲出 "GO" 的概率为 $1/9$，你需要带一根香蕉，并在 $1/9$ 的情况下支付出去。

在第 5 组样例中，理论上猴子最多能敲出 9 次 "ROSENCRANTZ"，但实际出现一次的概率都极小，可以忽略不计。

**数据范围**

$1 \leq T \leq 100$。

**小数据集（11 分）**

- 时间限制：~~240~~ 5 秒。
- $1 \leq K \leq 7$。
- $1 \leq L \leq S \leq 7$。

**大数据集**

- 时间限制：~~480~~ 10 秒。
- $1 \leq K \leq 100$。
- $1 \leq L \leq S \leq 100$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5
7 6 6
BANANAS
MONKEY
2 3 4
AA
AAA
2 1 2
AB
B
6 2 2
GOOGLE
GO
26 11 100
ABCDEFGHIJKLMNOPQRSTUVWXYZ
ROSENCRANTZ```

### 输出

```
Case #1: 0.0
Case #2: 0.0
Case #3: 1.0
Case #4: 0.8888889
Case #5: 9.0```

# 题解

## 作者：_LRH_ (赞：0)

- ## 题意

  给出一个键盘在上面等概率随机选一个字母放入初始为空的字符串里面得到的字符串长度为 $S$ 并有一个长度为 $L$ 的模板串。求得到的字符串里最多可以匹配几个模板串，与匹配模板串的期望的差。

- ## 思路

  很显然我们一看到这种问题和数据规模和它无后效性的特质就会想到 DP 来转移。

  接着我来确定一下我们的状态。

  - $ f_{i,j} $ 表示形成的字符串长度为 $i$ 已经匹配到了模式串第 $j$ 个位置的期望。
 
  - $ dp_{i,j}$  表示形成的字符串长度为 $i$ 已经匹配到了模式串第 $j$ 个位置的概率。
 
  - $ d_{i,j}$  表示形成的字符串长度为 $i$ 已经匹配到了模式串第 $j$ 个位置的最大匹配数。
 
  到这里读者可以去思考一下该如何转移。

  其实很简单我们只需要使用 KMP 来帮助我们转移达到一个比较高效的时间复杂度，不会 KMP 的读者可以去 [这里](https://www.luogu.com.cn/problem/P3375) 学习一下。

  那么最终的答案就是 $d_{S,i}$ 的最大值减去    $\sum_{i=0}^{m} f_{S,i}$。

- ## 代码

```cpp

#include <bits/stdc++.h>

using namespace std;

const int N = 105, M = 30;

int T, K, L, S, nxt[N], d[N][N], dis[M];

string s, str;

double f[N][N], dp[N][N];

int main() {
	cin >> T;
	for (int t = 1; t <= T; t++) {
		cin >> K >> L >> S;
		
		cin >> s;
		//键盘 
		cin >> str;
		//模式串 
		int m = str.size(), n = s.size();
		str = " " + str + "*", s = " " + s;
		memset(nxt, 0, sizeof(nxt));
		memset(dis, 0, sizeof(dis));
		
		for (int i = 2, j = 0; i <= m; i++) {
			for (; j && str[i] != str[j + 1]; j = nxt[j]) {
			}
			if (str[i] == str[j + 1]) {
				j++;
			}
			nxt[i] = j;
		}//KMP
		
		for (int i = 0; i <= 100; i++) {
			for (int j = 0; j <= 100; j++) {
				f[i][j] = 0;
				dp[i][j] = 0;
				d[i][j] = 0;
			}
		}//多测清空 
		
		f[0][0] = 0, dp[0][0] = 1; //初始的期望为0，概率为1 
		for (int i = 1; i <= n; i++) {
			dis[s[i] - 'A']++;
		} //算出每个字母出现的概率以便转移 
		
		for (int i = 0; i < S; i++) {
			for (int j = 0; j <= m; j++) {
				if (dp[i][j] == (double)0.0) {
					continue;
				}
				for (char ch = 'A'; ch <= 'Z'; ch++) {
 					int tmp = j;
					for (; tmp && ch != str[tmp + 1]; tmp = nxt[tmp]) {
					}
					tmp += (ch == str[tmp + 1]);
					d[i + 1][tmp] = max(d[i + 1][tmp], d[i][j] + (tmp == m)); //如果匹配完了答案要加一 
					double cnt = (double)dis[ch - 'A'] / (double)K; //这个字母使用的概率 
					if (tmp == m) {
						f[i + 1][tmp] += (double)1.0 * dp[i][j] * cnt; //匹配到这里的概率乘上它的贡献就是新增的期望 
					}
                    dp[i + 1][tmp] += dp[i][j] * cnt; //转移期望 
                    f[i + 1][tmp] += f[i][j] * cnt; //转移概率 
				}	
			}
		}
		
		double ans = 0;
		int sum = 0;
		for (int i = 0; i <= m; i++) {
			if (dp[S][i] == (double)0.0) {
				continue;
			} //没有概率到这里就跳过 
			sum = max(sum, d[S][i]);
			ans += f[S][i];
		}
		
		ans = (double)sum - ans;
		cout << "Case #" << t << ": ";
		printf("%.8f\n", ans);
	}
	return 0;
}

---


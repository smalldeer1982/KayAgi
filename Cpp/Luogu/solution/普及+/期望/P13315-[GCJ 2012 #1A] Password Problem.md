# [GCJ 2012 #1A] Password Problem

## 题目描述

我有一个非常长的密码，有时候在输入时会出错。现在我已经输入了部分密码，但可能在输入前面的某些字符时按错了键。已知我每个字符输入正确的概率，你觉得我该怎么做？

我有三种选择：

1. 继续输入剩下的密码，然后按下“回车”。我知道剩下的字符我一定能全部正确输入。如果之前输入的某个字符错了，我就需要重新输入整个密码并再次按“回车”——而这次我一定能全部输入正确。
2. 按下“退格键”若干次，删除我已经输入的最后若干字符，然后像选项 1 那样输入剩下的密码并按“回车”。如果没有删除的字符中有错的，我仍需重新输入整个密码并再次按“回车”，这次我一定能全部输入正确。
3. 直接放弃，按“回车”重新输入整个密码，再按一次“回车”。我知道这次我一定能全部输入正确。

我希望让期望按键次数最小。每输入一个字符算一次按键，每按一次“退格键”也算一次按键，每按一次“回车”完成一次尝试或直接放弃也算一次按键。

注意：“期望”按键次数是指如果这种情况发生很多次，平均每次需要的按键数。见下例。

**例子**

假设我的密码是“guest”，我已经输入了前两个字符，但每个字符输入时出错的概率都是 $40\%$。那么共有四种情况：

* 我输入了“gu”，全对。这种情况概率为 $0.6 \times 0.6 = 0.36$。
* 我输入了 'g' 正确，'u' 错了，此时输入的是“gx”。（这里 'X' 表示输错的字符。）概率为 $0.6 \times 0.4 = 0.24$。
* 我输入了 'u' 正确，'g' 错了，输入的是“xu”。概率为 $0.4 \times 0.6 = 0.24$。
* 两个都错了，输入的是“xx”。概率为 $0.4 \times 0.4 = 0.16$。

我并不知道自己实际错了几个，但对于任何策略，都可以算出期望按键次数。如下表：

| 概率 | "gu" | "gx" | "xu" | "xx" | 期望值 |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 如果继续输入 | $4$ | $10$ | $10$ | $10$ | $7.84$ |
| 如果退格一次 | $6$ | $6$ | $12$ | $12$ | $8.4$ |
| 如果退格两次 | $8$ | $8$ | $8$ | $8$ | $8$ |
| 如果直接放弃 | $7$ | $7$ | $7$ | $7$ | $7$ |

如果我继续输入，有 $0.36$ 的概率只需 $4$ 次按键，有 $0.64$ 的概率需要 $10$ 次按键。大量重复这种情况，平均每次需要 $0.36 \times 4 + 0.64 \times 10 = 7.84$ 次按键。但在这个例子中，直接放弃（重输）只需要 $7$ 次按键，是更优选择。


## 说明/提示

**限制条件**

- $1 \leq T \leq 20$
- 对所有 $i$，$0 \leq p_i \leq 1$

**测试集 1（10 分，可见结果）**

- $1 \leq A \leq 3$
- $A < B \leq 100$

**测试集 2（10 分，隐藏结果）**

- $1 \leq A \leq 99999$
- $A < B \leq 100000$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
3
2 5
0.6 0.6
1 20
1
3 4
1 0.9 0.1```

### 输出

```
Case #1: 7.000000
Case #2: 20.000000
Case #3: 4.500000```

# 题解

## 作者：DecemberFox (赞：0)

# P13315 [GCJ 2012 #1A] Password Problem 题解

## 题目分析

本题需要从若干种输入密码的方式中，找到按键次数期望最小的一种。

## 解法分析

由于后续的输入一定是正确的，因此确定了操作方案，就可以通过概率计算出最终输入的次数。随后对三种情况分类讨论，分别求出对应的期望值并输出最小值即可。

- 首先是直接删掉重新输入，那么一定会先按一次回车，输入正确密码并再按一次回车，共计 $b+2$ 次操作，并且该种情况发生的概率为 $P(A)=1$，故此时期望值 $E(A)=P(A)\times(b+2)=b+2$。

- 然后是继续输入密码，此时就会分为两种情况。
  - 若先前输入的 $a$ 个字符全部输入正确，则只需要输入剩余的字符和回车即可完成，共计 $b-a+1$ 次操作。

    全部正确的概率 $P(B')=\displaystyle\prod^b_{i=1}P_i$。
  - 但也有可能输入不正确，则在原来的基础上还需要重新输入一次密码，共计 $b-a+1+b$ 次操作。

    反之，出现错误的概率 $P(\overline{B'})=1-P(B)$。

  两者概率之和为 $1$，故此时期望值 $E(B)=P(B')\times(b-a+1)+P(\overline{B'})\times(2b-a+1)$。

- 最后计算删除若干个字符后重新输入的期望。首先删除全部一定不比直接放弃优，不删的情况再上面讨论过了，因此从 $1$ 到 $a-1$ 枚举剩余多少个字符，便于计算概率。

  对于前 $k$ 个字符，分析方式与第二种相同，分为全部正确和不正确，操作次数分别为 $a-k+b-k+1$ 和 $a-k+b-k+1+b+1$；全部正确的概率为 $P(C'_k)=\displaystyle\prod^k_{i=1}P_i$，出现错误的概率为 $P(\overline{C'_k})=1-P(C_k)$。

  对应的期望为 $E(C_k)=P(C'_k)\times(a+b-2k+1)+P(\overline{C'_k})\times(a+2b-2k+2)$。

- 最终期望为上述中最小者，$E(X)=\min\{E(A),E(B),E(C_k)\}$。

时间复杂度为 $O(b)$。

最终代码如下：

```cpp
namespace SOLVE
{
	typedef long long ll;
	typedef unsigned long long ull;
	typedef __int128 lll;
	typedef unsigned __int128 ulll;
	const int const1=1e5+10;
	double ans,p[const1],P;
	void solve(int task)
	{
		int i,n,m;
		read(n,m);
		P=1.0;
		ans=m+2;
		for(i=1;i<=n;++i)
		{
			scanf("%lf",&p[i]);
			P*=p[i];
		}
		ans=std::min(ans,P*(m-n+1.0)+(1.0-P)*(2.0*m-n+2.0));
		P=p[1];
		for(i=1;i<n;P*=p[++i]) ans=std::min(ans,P*(n+m-2.0*i+1.0)+(1.0-P)*(n+2.0*m-2.0*i+2.0));
		printf("Case #%d: %.6lf\n",task,ans);
	}
}
int main()
{
	int t,tk(0);
	read(t);
	while(t--) SOLVE::solve(++tk);
	return 0;
}
```

---


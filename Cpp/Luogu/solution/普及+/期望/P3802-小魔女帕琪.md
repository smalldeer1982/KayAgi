# 小魔女帕琪

## 题目背景

从前有一个聪明的小魔女帕琪，兴趣是狩猎吸血鬼。

帕琪能熟练使用七种属性（金、木、水、火、土、日、月）的魔法，除了能使用这么多种属性魔法外，她还能将两种以上属性组合，从而唱出强力的魔法。比如说为了加强攻击力而将火和木组合，为了掩盖弱点而将火和土组合等等，变化非常丰富。

## 题目描述

现在帕琪与强大的夜之女王，吸血鬼蕾咪相遇了，夜之女王蕾咪具有非常强大的生命力，普通的魔法难以造成效果，只有终极魔法：帕琪七重奏才能对蕾咪造成伤害。帕琪七重奏的触发条件是：连续施放的 $7$ 个魔法中，如果魔法的属性各不相同，就能触发一次帕琪七重奏。

请注意，无论前 $6$ 个魔法是否已经参与施放终极魔法，只要连续 $7$ 个魔法的属性各不相同，就会再触发一次终极魔法。例如，如果用序号来代表一种魔法，魔法的施放序列为 $1, 2, 3, 4, 5, 6,7, 1$，则前 $7$ 个魔法会触发一次终极魔法，后 $7$ 个魔法会再触发一次终极魔法。

现在帕琪有 $7$ 种属性的能量晶体，第 $i$ 种晶体可以施放出属性为 $i$ 的魔法，共有 $a_i$ 个。每次施放魔法时，会等概率随机消耗一个现有的能量晶体，然后释放一个对应属性的魔法。

现在帕琪想知道，她触发帕琪七重奏的期望次数是多少，可是她并不会算，于是找到了学 OI 的你。

## 说明/提示

#### 样例输入输出 1 解释

显然一定会触发一次帕琪七重奏。

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $\sum_{i = 1}^7 a_i \leq 10$。
- 对于 $100\%$ 的数据，保证 $0 \leq a_i \leq 10^9$，且 $\sum_{i = 1}^7 a_i \leq 10^9$。

## 样例 #1

### 输入

```
1 1 1 1 1 1 1```

### 输出

```
1.000```

# 题解

## 作者：ButterflyDew (赞：132)

UDT：2018.9.25

之前写的有不小问题，居然没人提。。

----------

详细一点的说一下

[欢迎在博客食用喵~](https://www.cnblogs.com/ppprseter/p/9319997.html)

提一点：放招是不会互相影响的，1-7放招了，2-8还可以放招

首先直接考虑对于取的前7个能量晶体

设$N=\sum_{i=1}^7 a_i$

考虑前7个一连串取出了$a_1,a_2,a_3,..a_7$的概率

为$\frac{a_1}{N} \times \frac{a_2}{N-1} \times \frac{a_3}{N-2} \times \frac{a_4}{N-3}  \times \frac{a_5}{N-4}  \times \frac{a_6}{N-5}  \times \frac{a_7}{N-6}$

因为是条件概率，所以样本空间减少了(n-x)

对条件概率：
简单一点的解释是，B在A发生的条件下发生的概率。

举个栗子，掷色子第一次投6概率为1/6，为A事件，第二次投6概率仍为1/6，为B事件。如果把两次投掷产生的一个结果算成一个最终状态，那么连续的状态AB发生的概率为1/36，也即是B在A发生的条件下发生的概率。

然后我们对取出1-7的式子发现，如果我们不按1-7的顺序取，分子分母并没有变化

那么直接按照排列组合，把所有顺序的全部统计

即$7! \times \frac{a_1}{N} \times \frac{a_2}{N-1} \times \frac{a_3}{N-2} \times \frac{a_4}{N-3}  \times \frac{a_5}{N-4}  \times \frac{a_6}{N-5}  \times \frac{a_7}{N-6}$

但其实后面每七位对应的答案都是这样，下面讲为什么

以上只是提供一个**感性**的类似的说明方法，和下面的并非直接相关

------------
在考虑之后怎么取之前，我们先想一个问题。

你班要选择投票一个人，在班花喵面前吃巧克力，然后班主任拿了一个盒盒让你们摸球球，里面有1个红球和29个白球（你班30人），抽到红球的人就有了这个至高无上的权利，一个个的去抽，那么顺序不一样的话，是公平的吗？？

当然...是了

第一个人抽中的概率是 $\frac {1}{30}$
第二个人抽中的概率是 $\frac {29}{30} \times \frac {1}{29}$
第三个人抽中的概率是 $\frac {29}{30} \times \frac {28}{29} \times \frac {1}{28}$
...

以上只是提供一个**感性**的类似的说明方法，和下面的并非直接相关

------------
然后我们考虑用类似的方法把它说清楚

如果第一个取出$a_1$

我们考虑它取出的合法的第2-8个，就可以再次放招了

概率为

### $\frac{a_1}{N} \times \frac{a_2}{N-1} \times \frac{a_3}{N-2} \times \frac{a_4}{N-3}  \times \frac{a_5}{N-4}  \times \frac{a_6}{N-5}  \times \frac{a_7}{N-6} \times \frac{a_1-1}{N-7}$

同理组合有$7!$种(这$7!$是确定了首位而$2-8$不定的情况)

如果第一个取$a_2$

概率为
### $\frac{a_2}{N} \times \frac{a_1}{N-1} \times \frac{a_3}{N-2} \times \frac{a_4}{N-3}  \times \frac{a_5}{N-4}  \times \frac{a_6}{N-5}  \times \frac{a_7}{N-6} \times \frac{a_2-1}{N-7}$

我们把第一个取出的7种可能加在一起

发现末项加起来化简是1

即$\sum_{i=1}^7 \frac{a_i-1}{N-7}=1$

于是对第2-8位的贡献化简结果就是$7! \times \frac{a_1}{N} \times \frac{a_2}{N-1} \times \frac{a_3}{N-2} \times \frac{a_4}{N-3}  \times \frac{a_5}{N-4}  \times \frac{a_6}{N-5}  \times \frac{a_7}{N-6}$

所以最终答案就是（乘上了$N-6$项）
$7! \times \frac{a_1}{N} \times \frac{a_2}{N-1} \times \frac{a_3}{N-2} \times \frac{a_4}{N-3}  \times \frac{a_5}{N-4}  \times \frac{a_6}{N-5}  \times {a_7}$

------------
**Code：**
```cpp
#include <cstdio>
double a[8],s,ans=1;
int main()
{
    for(int i=1;i<=7;i++)
    {
        scanf("%lf",a+i);
        s+=a[i];
    }
    for(int i=1;i<=6;i++)
        ans=ans*a[i]/(s+1-i)*double(i);
    ans=ans*a[7]*7.0;
    printf("%.3lf\n",ans);
    return 0;
}
```

---

## 作者：command_block (赞：65)

~~这东西在任务计划里躺了三个月了。~~

来点严谨的！ 

看到期望题先别方，**大胆推一波柿子先**。

在前7次就触发一个"七重奏"的概率不算难求。

想象一个七元排列$\{p_1,p_2,p_3,p_4,p_5,p_6,p_7\}$

指第$p_1$次触发魔法1,$p_2$次触发魔法2,等等。 

显然，$p$的具体值并不影响事件的期望。

假定排列为$\{1,2,3,4,5,6,7\}$好了~~（草率）~~

设$N=a_1+a_2+a_3+a_4+a_5+a_6+a_7$

这个东西成立的概率是$\large{a_1/N*a_2/(N-1)*a_3/(N-2)...a_7/(N-6)}$

因为在取魔法1的时候有$\large{a_1/N}$的概率，在此条件下取魔法2又有$\large{a_2/(N-1)}$(N减少了1)

当然七元排列有$7!$个。

所以在第7次就触发一个"七重奏"的概率是$\large{7!*a_1/N*a_2/(N-1)*a_3/(N-2)...a_7/(N-6)}$

接下来考虑在第8次触发一个"七重奏"的概率。

首先要知道，魔法发动互不影响。

相当于你在胡乱用掉一个晶体后重头再来。

也就是$(a_1/N)(7!*(a_1-1)/(N-1)*a_2/(N-2)*a_3/(N-3)...a_7/(N-7))+$

$(a_2/N)(7!*a_1/(N-1)*(a_2-1)/(N-2)*a_3/(N-3)...a_7/(N-7))+$

$……$

$(a_7/N)(7!*a_1/(N-1)*a_2/(N-2)*a_3/(N-3)...(a_7-1)/(N-7))+$

设$∏a_i=R$

也就是

$=7!/N/(N-1)/(N-2)/.../(N-7)*((a_1-1)R+(a_2-1)R+...+(a_7-1)R)$

$=7!/N/(N-1)/(N-2)/.../(N-7)*(N-7)R$

$=7!/N/(N-1)/(N-2)/.../(N-6)*R$

$=7!*a_1/N*a_2/(N-1)*a_3/(N-2)...a_7/(N-6)$

也就是“在第8次触发一个七重奏的概率”与“所以在第7次就触发一个七重奏的概率”相等。

同理“在第任意次触发一个七重奏的概率”与“所以在第7次就触发一个七重奏的概率”相等

这就好办了，直接$(N-6)*7!*a_1/N*a_2/(N-1)*a_3/(N-2)...a_7/(N-6)$

最后注意卡精度。

Code:

```cpp
#include<cstdio>
using namespace std;
double a[10],N,ans=1;
int main()
{
  for(int i=1;i<=7;i++){
    scanf("%lf",&a[i]);
    N+=a[i];
  }if (N<7){
   printf("0.000");
    return 0;
  }for(int i=1;i<=7;i++)
    ans=ans*a[i]/(N-i+1);
  printf("%.3lf\n",ans*1*2*3*4*5*6*7*(N-6));
  return 0;
}
```

---

## 作者：_兰_ (赞：33)

这是一篇纯组合解法的题解。

事实上，概率期望题只要组合组的好，就可以当做细节题做，气氛就变得relax起来。

于是开始我们的推导。

首先令$\rm S = \sum a_i$。

然后我们考虑总的状态数即是$\rm S!$。此处不需要考虑如何消除重复元素贡献的原因是两种相同的排列是等概率的两个事件，所以需要多算一次。

然后考虑我们拿出$\rm 7$个元素之后，还有$\rm S-7+1=S-6$个空等着我们去填，也就是连续一个大可以放到$\rm S-6$个空里面，也就是
$$\rm \binom{S-6}{1}\cdot 7! \cdot \prod_{i=1}^{7} a_i\cdot (S-7)!$$

其中$\rm (S-7)!$是剩下元素的排列数，$\rm \prod a_i$是每个元素选一个的方案数。

所以答案就是

$$\rm \frac{\rm \binom{S-6}{1}\cdot 7! \cdot \prod_{i=1}^{7} a_i\cdot (S-7)!}{S!}$$

稍微化简一下就可以得到：

$$\rm ans = \frac{7!\cdot \prod _{i=1}^{7}a_i}{S(S-1)(S-2)(S-3)(S-4)(S - 5)}$$

然后就愉快地做完了。




---

## 作者：codecode (赞：33)

#### 题意简述：

有 $a_i$ 个 $i$（$1 \leq i \leq 7$），每次从所有未选的中随机选出一个，接在最后面，求连续 $7$ 个互不相同的数的组数的期望值。

#### 题解：

记 $N=a_1+a_2+\cdots+a_7$。

> 事实上，任意连续 $7$ 位构成终极魔法的概率是一样的。
>
> 这是因为，尽管帕琪是依次使用各个魔法，但实际上，**我们可以认定只需要从一个长度为 $N$ 的数列中**求出连续 $7$ 个互不相同的数的组数的期望值。
>
> 于是，连续 $7$ 个数 $x_{i+1},x_{i+2},\dots,x_{i+7}$ 能否成为终极魔法与剩余的 $N-7$ 个数的相对顺序无关。
>
> 因此，我们并**不需要**关心是否有条件概率来干扰计算，这个序列在遍历所有可能情形后，关于我们所要求的——连续 $7$ 个互不相同的数的组数的期望值，是期望平均的。
>
> 即在所有可能情况下，**连续 $7$ 个互不相同的数在序列中是平均分布的**。
>
> 所以，任意连续 $7$ 位构成终极魔法的概率是一样的。

深刻理解了这一点后，这道题就很简单了。

而一共有 $N-6$ 组连续 $7$ 位，故若设连续 $7$ 位构成一个终极魔法的概率为 $P$，最终答案就是 $E=(N-6)P$。

我们只需要求 $P$，由分布的平均性，进而只需要计算前 $7$ 位构成终极魔法的概率。这可以这么计算：

- 所有可能的情况，共 $N(N-1)\cdots(N-6)$ 种；

- 需要计算的情况，共 $a_1\times a_2\times \cdots a_7\times A_7^7$ 种。

故

$$P=\dfrac{7!\times a_1\times a_2\times \cdots a_7}{N(N-1)\cdots(N-6)}$$

于是最终的答案是

$$E=(N-6)P=\dfrac{7!\times a_1\times a_2\times \cdots a_7}{N(N-1)\cdots(N-5)}$$

时间复杂度 $\Theta(1)$。


------------

#### 代码：

```
#include<bits/stdc++.h>
using namespace std;
int n;
double a[8],ans;
int main(){
    for(int i=1;i<=7;i++)
        cin>>a[i],n+=a[i];
    ans=a[1]*1.0/n*a[2]/(n-1)*a[3]/(n-2)*a[4]/(n-3)*a[5]/(n-4)*a[6]/(n-5)*a[7]*5040;
    //7!=5040
    printf("%.3f",ans);
    return 0;
}
```

---

## 作者：AlanSP (赞：15)

~~萌新第一次写期望题解，求过qwq。~~

感觉题解里大佬写的太强了，这里我也来发表一下个人的见解。

令$S=\sum_{i=1}^7a_i$

设施展一次帕琪七重奏的概率为$P(A)$，那么很显然有：
$$
P(A)=\frac{a_1}S*\frac{a_2}{S-1}*\frac{a_3}{S-2}*\frac{a_4}{S-3}*\frac{a_5}{S-4}*\frac{a_6}{S-5}*\frac{a_7}{S-6}
$$
但我们发现，每一次可以从任意的元素开始，所以内部的顺序是随机的，这就构成了7的排列，即$7!$。
$$
P(A)=7!*\frac{a_1}S*\frac{a_2}{S-1}*\frac{a_3}{S-2}*\frac{a_4}{S-3}*\frac{a_5}{S-4}*\frac{a_6}{S-5}*\frac{a_7}{S-6}
$$
在这个题中，我们可以发现$E(A)=P(A)$，这就具有了很好的性质，因为期望是具有线性可加性的，即：
$$
E(A+B)=E(A)+E(B)
$$
我们就可以得到总共的期望【设为$E(M)$】为：
$$
E(M)=7!*\frac{a_1}S*\frac{a_2}{S-1}*\frac{a_3}{S-2}*\frac{a_4}{S-3}*\frac{a_5}{S-4}*\frac{a_6}{S-5}*\frac{a_7}{S-6}
$$
$$
+7!*\frac{a_1-1}{S-6}*\frac{a_2-1}{S-7}*\frac{a_3-1}{S-8}*\frac{a_4-1}{S-9}*\frac{a_5-1}{S-10}*\frac{a_6-1}{S-11}*\frac{a_7-1}{S-12}+\dots
$$
这样的式子看起来很不可化简（~~其实我也不会化~~）。

但我们可以从它的本身含义入手。

每次加一次$P(A)$，相当于在上一次选出的7个数后面补上7个数。

也就是说我们相当于在造一个很长的链：
$$
1,2,3,4,5,6,7,1,2,3,4\dots
$$
（当然这只是其中一个例子。）

我们会发现，从其中任意截取一个点向后延伸7位，都构成一个完整的1~7的排列。

而一共能截多少个呢？

不难发现除了最后6个不行，其他都行。

故为$S-6$个。

所以最终答案为：
$$
E(M)=(S-6)*7!*\frac{a_1}S*\frac{a_2}{S-1}*\frac{a_3}{S-2}*\frac{a_4}{S-3}*\frac{a_5}{S-4}*\frac{a_6}{S-5}*\frac{a_7}{S-6}
$$
$$
 =7!*\frac{a_1}S*\frac{a_2}{S-1}*\frac{a_3}{S-2}*\frac{a_4}{S-3}*\frac{a_5}{S-4}*\frac{a_6}{S-5}*a_7
$$


直接做就行（$7!=5040$）：

```cpp
#include<bits/stdc++.h>
using namespace std;
double a[8],ans=1,sum;
int main()
{
	for(int i=1;i<=7;i++) scanf("%lf",&a[i]),sum+=a[i];
	for(int i=1;i<=6;i++)
	{
		ans*=a[i];
		ans/=(sum-i+1);
	}
	ans*=5040;
	ans*=a[7];
	printf("%.3lf",ans);
	return 0;
}
 
```



---

## 作者：orangebird (赞：15)

设n=sigma(ai)

对于每一位i，从i开始的7位中，7个魔法都不相同的概率为7! \* a1/n \* a2/(n-1) \* a3/(n-2) \* a4/(n-3) \*a5/(n-4) \* a6/(n-5) \* a7/(n-6)

由于一共有n-6个这样的位置i，所以最后一项除以n-6可以消去

答案就是7! \* a1/n \* a2/(n-1) \* a3/(n-2) \* a4/(n-3) \*a5/(n-4) \* a6/(n-5) \* a7

代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
double a1,a2,a3,a4,a5,a6,a7,n;
int main()
{
    cin>>a1>>a2>>a3>>a4>>a5>>a6>>a7;
    n=a1+a2+a3+a4+a5+a6+a7;
    printf("%.3lf",5040*a1/n*a2/(n-1)*a3/(n-2)*a4/(n-3)*a5/(n-4)*a6/(n-5)*a7);
} 
```

---

## 作者：4526_ (赞：9)

[题目链接](https://www.luogu.org/problemnew/show/P3802)

~~众所周知，帕琪有哮喘和贫血，不可能连续咏唱7个魔法，所以输出0.000即可~~

公式的推导已经有dalao分析得很详细了，这里就着重讲一下写代码时的一些注意事项和部分执行语句的用法

**主要思想：概率/期望**

本题公式：7!  *  (a1/n)  *  [ a2/(n-1)) ]  *  [a3/(n-2)]  *  [a4/(n-3)]  *  [a5/(n-4)]  *  [a6/(n-5)]  *  a7

注意事项：

1、**输入输出格式**：注意到输出要求“一个四舍五入保留3位的浮点数”，对于这种格式，c++中最便捷的语句就是scanf和printf，用法如下:

①读入域宽为n（即n位）的整数a： scanf("%nd",&a);(取前n位)（若不加域宽则读到空格/换行为止）

②读入域宽为n（即n个字符）的字符串ch： scanf("%nc",&ch)（若不加域宽则读入单个字符）

③输出域宽为n的整数a： printf("%nd",a);（左端补空格，若位数大于n则出错）或 printf("%0nd",a);（左端补0）（若不加域宽则输出原数字）

④输出保留小数点后n位（四舍五入）的浮点数d：printf("%.nlf",d);（若不加n则保留小数点后6位）

上面没有列举的用法可能会出错，比如scanf("%.3lf",&d)，一般不建议这么用，当然自己试一下是理解执行语句最好的方法

应用举例：scanf("%1d",&a[i]) ;读入一位整数

例题： [P1451 求细胞数量](https://www.luogu.org/problemnew/show/P1451)

2、**数据类型兼容**：由于ai是整数而输出要求浮点数，有的oier会在转换数据类型上浪费时间，然而不同数据类型并不是那么“泾渭分明”，以下用a>b表示类型a可以兼容/代替类型b：

double > int

double > float

long long > long > int > short

unsigned long long > | long long |

其中double和float所占用的空间不会对总空间产生太大影响，而double的精度高于float，即float能过的double一定能过，但double能过的float不一定能过（比如本题），所以一般浮点数直接用double；而long long和int由于占用空间差距较大，能用int就尽量不用long long

3、**特殊数据处理**：对于首尾数据需要特殊处理的，不用在循环中加入特判，直接拎出循环即可（如本题a[7]），可使代码更简洁精炼

4、**运算过程中的数据范围**：以本题为例，应该有不少人会把分子分母分别相乘再做除法，然而Πai最大可达到10^63，显然会导致溢出，其他题目亦是如此，一定要先预判数据范围，避免在细节上丢分

5、**头文件的选择**：即使有便捷的万能头文件，还是应该对常用头文件有一定的了解，如<cmath>主要包含max、min、sqrt、pow等，<cstring>主要包含对字符串进行操作的函数，<iostream>主要包含cin、cout等，<algorithm>主要包含sort等stl函数，特别注意<cmath>中y1为关键字；本题没有使用特殊函数，只需<cstdio>即可

最后是AC代码：
```cpp
#include<cstdio>
using namespace std;

double ans=1,arr[10];

int main(){
	for(int i=1;i<=7;++i){
		scanf("%lf",&arr[i]);
		arr[0]+=arr[i];
	}
	for(int i=1;i<=7;++i) printf("%lf\n",arr[i]);
	for(int i=1;i<=6;++i){
		ans*=arr[i]/(arr[0]+1-i)*i;
	}
	ans*=arr[7]*7;
	printf("%.3lf",ans);
	return 0;
}
```

欢迎来[我的blog](https://www.luogu.org/blog/4526-Au/#)看看

---

## 作者：zhaomingrui (赞：6)

```
#include<cstdio>
#include<iostream>
using namespace std;
//本题涉及的知识点：排列组合和数学期望；算是期望的入门题；
//本题的价值为一，故此题的期望等于概率; 
//总体来看：有n=a1+a2+a3+a4+a5+a6+a7点的魔法；
//首先没有哪一个位置的魔法数为0;
/*
  所以先在从1到7的位置下，概率为：(a1/n)*(a2/n-1)*....*(a7/n-6);
  再放大一点考虑1~n中有n-6段连续的1~7;
  那么概率还要再乘上(n-6);
  每七个位置中,a1~7的排布有7！种;
 所以得出公式 E=7!*(n-6)* (a1/n)*(a2/n-1)*....*(a7/n-6)再化简一下;
 代码：*/
 int main()
 {
 	double a[8],n=0;
 	 for(int i=1;i<=7;i++)
 	 {
 	  scanf("%lf",&a[i]);
 	  n+=a[i];
     }
	   printf("%.3lf",5040*a[1]/n*a[2]/(n-1)*a[3]/(n-2)*a[4]/(n-3)*a[5]/(n-4)*a[6]/(n-5)*a[7]);
	   return 0;
 } 
```

---

## 作者：fdfdf (赞：6)

表示做题的时候并不会楼下大佬的神奇算法（虽然式子看上去很简单）

题意相当于要求一个每种数字个数给定的数列中出现连续7个元素各不相同的次数的期望

那么我们考虑每7个连续的位置，这些位置产生贡献的概率是相同的

因此直接暴搜搞出第一段连续的位置(1-7)中产生贡献的概率，之后$\times(\sum_{i=1}^{7}{a_i}-7+1)$即可
```cpp
#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<iomanip>
#include<cstring>
#include<complex>
#include<vector>
#include<cstdio>
#include<string>
#include<bitset>
#include<cmath>
#include<queue>
#include<stack>
#include<map>
#include<set>
#define mp make_pair
#define pb push_back
#define RG register
#define il inline
using namespace std;
typedef unsigned long long ull;
typedef vector<int>VI;
typedef long long ll;
typedef double dd;
const dd eps=1e-10;
const int mod=1e9+7;
const int N=3000010;
const int M=90000;
il ll read(){
    RG ll data=0,w=1;RG char ch=getchar();
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();
    return data*w;
}

il void file(){
    //freopen("a.in","r",stdin);
    //freopen("a.out","w",stdout);
}

int a[10],cnt[10],tot;
dd ans;

void dfs(int x,dd p){
    if(x==8){
        for(RG int i=1;i<=7;i++)
            if(!cnt[i])return;
        ans+=p;return;
    }
    for(RG int i=1;i<=7;i++)
        if(a[i]){
            a[i]--;cnt[i]++;
            dfs(x+1,p*(a[i]+1)/(tot-x+1));
            a[i]++;cnt[i]--;
        }
}

int main()
{
    for(RG int i=1;i<=7;i++)a[i]=read(),tot+=a[i];
    dfs(1,1);printf("%.3lf\n",ans*(tot-7+1));
    return 0;
}
```

---

## 作者：hehelego (赞：3)

## solution

首先给定了$(a_1,a_2\dots a_7),n=\sum a_i$后,有$N=\frac{n!}{\prod_{i=1}^7 (a_i!)}$个不同的序列.



首先判掉一些为期望为$0$的情况,$\exists i,a_i=0$或者$\sum_i a_i\lt 7$.

----------


考虑算所有序列中的魔法数量.  
- 按序列统计:计算包含$i\ (0\leq i\leq n-6)$个魔法的序列分别有多少种,假设是$f_i$那么有$\sum_{i=1}^7 if_i$个.
- 按位置统计,对于$k$,统计$(a_{k-6},a_{k-5}\dots a_{k-1},a_k)$是$1..7$的排列的序列数量.  


第一个我不会,但是我会第二个.  

对于这一段,有$7!$种方案. 

而$[1..k-7],[k+1..n]$上面,我们把这两段(可能为空,并不重要)拼接起来.拼接前是$a,b$得到$a+b$,如果$a'+b'\neq a+b$那么$a'\neq a\texttt{ or } b'\neq b$故统计拼接后的不同结果即可.  
此时是$(a_1-1,a_2-1\dots a_7-1),n'=n-7$的一个子问题,那就是$\frac{(n-7)!}{\prod (a_i-1)!}$  
于是第$k$位有贡献$1$的序列是$7!\frac{(n-7)!}{\prod (a_i-1)!}$个.  


我们发现它和$k$是无关的,于是所有序列中的魔法数量和是$(n-6)7!\frac{(n-7)!}{\prod (a_i-1)!}$和上面的总数除一下即可.  



$$
\frac{(n-6)7!\frac{(n-7)!}{\prod (a_i-1)!}}{\frac{n!}{\prod_{i=1}^7 (a_i!)}}
$$

$$
=7!\times \frac{(n-6)(n-7)!}{n!}\times \frac{\prod (a_i!)}{\prod (a_i-1)!}
$$

$$
=7! (n-6) n^{\underline 7}\times \prod \frac{ (a_i!)}{ (a_i-1)!}
$$

$$
=7! (n-6) n^{\underline 7}\times \prod a_i
$$

没了.




## code

```cpp
#include <bits/stdc++.h>
int a[7],n,minv=1;
int main(){
	for(int i=0;i<7;i++){
		std::cin>>a[i];
		n+=a[i]; minv=std::min(minv,a[i]);
	}
	if(minv==0||n<7){
		puts("0.000");
	}else{
		double ans=1.0*(n-6);
		for(int i=0;i<7;i++) ans/=double(n-i);

		for(int i=0;i<7;i++) ans*=a[i];
		for(int i=1;i<=7;i++) ans*=i;
		printf("%.3lf\n",ans);
	}

	return 0;
}
```


---

## 作者：liangjialin (赞：2)

好吧，其实讨论区的dalao已经把题解说的very清楚了。

注意一些小细节：

0. 用double（float会挂两个点，就算本地过了）

0. 不要乘完了所有再除（对于100%的测试点，a1+a2+a3+a4+a5+a6+a7<=10^9）

//aa=2\*3\*4\*5\*6\*7\*a\*b\*c\*d\*e\*f\*g;

//bb=sum\*(sum-1)\*(sum-2)\*(sum-3)\*(sum-4)\*(sum-5);

//必挂无疑

其实很想问问，期望，小学生会吗？（反正我是小学生的时候，不会）

最后贴上代码：

```cpp
double a,b,c,d,e,f,g,sum;
int main()
{
    cin>>a>>b>>c>>d>>e>>f>>g;
    sum=a+b+c+d+e+f+g;
    printf("%.3lf",5040*a/sum*b/(sum-1)*c/(sum-2)*d/(sum-3)*e/(sum-4)*f/(sum-5)*g);
}

```

---

## 作者：Rainybunny (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[题目链接](https://www.luogu.org/problem/P3802).
# 题解
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$N=\sum_{i=1}^na_i$, 第一步, 我们计算七重奏在$[1,7]$出现的概率, 很轻易地有:  $p_1=7!\sum_{i=1}^7\frac{a_i}{n-i+1}$. 接着, 推导七重奏出现在$[2,8]$的概率:  
$\displaystyle p_2=a1/N*(7!*(a1-1)/(N-1)*a2/(N-2)*…*a7/(N-7))$
$\displaystyle +a2/N*(7!*a1/(N-1)*(a2-1)/(N-2)*…*a7/(N-7))$
$\displaystyle +…+a7/N*(7!*a1/(N-1)*a2/(N-2)*…*(a7-1)/(N-7))$
$=(a1+…+a7-7)/N*(7!*a1/(N-1)*a2/(N-2)*…*a7/(N-7))$
$=7!*a1/N*a2/(N-1)*…*a7/(N-6)$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些繁杂, 不过可以发现, 对于每个位置的七重奏, 其出现概率是一样的. 那么期望便是:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle 7!\times a_1/N\times a_2/(N-1)\times…\times a7/(N-6)\times(N-6)
=7!\times a_1/N\times a_2/(N-1)\times…\times a_7$

# 代码
```cpp
#include <cstdio>

#define Int register int

int a[8] = {}, N;
double Ans = 7.0 * 6 * 5 * 4 * 3 * 2 * 1;

inline void Work () {
	for ( Int i = 1; i <= 7; ++ i ) {
		scanf ( "%d", &a[i] );
		N += a[i];
	}
	for ( Int i = 1; i <= 7; ++ i ) {
		Ans *= 1.0 * a[i] / ( i ^ 7 ? N -- : 1.0 );
	}
	printf ( "%.3lf\n", Ans );
}

int main () {
	Work ();
	return 0;
}
```

---


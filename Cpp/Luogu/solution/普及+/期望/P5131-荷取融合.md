# 荷取融合

## 题目背景

作为一款Rougelike类游戏，TODR具有丰富的装备系统。每一款装备独特的外观和华丽的特效，上百种各有效果的印记，复杂的炼成调和分解融合系统都塑造了这款游戏极高的游戏性。    

现在你的装备刷到了满级，需要和其他装备融合来继续成长，当然，你需要让河城荷取将你原装备中的印记抽取出来以便和新装备合成。 

## 题目描述

已知原装备有 $n$ 个印记槽，每个印记槽中有无限多的一种印记，第 $i$ 个印记槽中的这种印记价值为 $a_{i}$。     

河城荷取会用机械臂抽取印记槽内的印记，每一次抽取时，机械臂会向下抓取，从正下方的印记槽中抽取出一个印记，之后机械臂会向右移动或停留在原地(如果移动，那么可以移动任意格)，开始时机械臂的位置任意，但是任意时刻机械臂都必须在某个印记槽上。  

河城荷取会进行 $k$ 次抓取，抓取结束后，你获得的总收益等于抓上来的 $k$ 个印记价值的乘积。

假设河城荷取进行的一切操作都是随机的，那么你能获得的收益的平均值是多少呢?  

由于答案可能不是整数，你只需输出答案对 $\text{19260817}$ 取模后的结果。  

## 说明/提示

#### 样例 $1$ 解释:  

机械臂开始可以停在三个槽上方。  

先后抓取的印记槽的位置可以是 $(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)$ 六种,每一种抓取方案的收益分别是 $9,3,6,1,2,4$ ，平均值为 $\frac{25}{6}$，在 $ \text{mod 19260817}$ 的意义下等于 $16050685$   


#### 数据范围:  

$a_{i}<19260817$  

![](https://cdn.luogu.com.cn/upload/pic/42182.png)   

## 样例 #1

### 输入

```
3 2
3 1 2```

### 输出

```
16050685```

## 样例 #2

### 输入

```
6 3
1 1 4 5 1 4```

### 输出

```
16509294```

# 题解

## 作者：离散小波变换° (赞：11)

## 题目大意

$n$个数中选择$k$个（可以重合），求这$k$个数的乘积的期望。

## 题解

很显然，这个问题可以拆分为两部分：**求方案总数**，以及**求所有方案的贡献和**。

### 求方案总数

我们设$F_{i,j}$表示前$i$个数中，选择$j$个数的方案。那么考虑第$i$个数如何处理。

- $1.$不选择第$i$个数。它的方案总数为$F_{i-1,j}$。

- $2.$选择第$i$个数。它的方案总数为$F_{i,j-1}$。

那么有：

$$F_{i,j}=F_{i-1,j}+F_{i,j-1}$$

### 求贡献和

同样地，我们定义$G_{i,j}$表示前$i$个数中，选择$j$个数的贡献总和。与上文类似，考虑第$i$个数的情况。

- $1.$不选择第$i$个数。这一部分的贡献总和为$G_{i-1,j}$。

- $2,$选择第$i$个数。这一部分的贡献总和为$G_{i,j-1}\times A_i$。

也就是说，

$$G_{i,j}=G_{i-1,j}+G_{i,j-1}\times A_i$$


最后的答案为$\frac{G_{n,k}}{F_{n,k}}$。用快速幂求出$F_{n,k}$的逆元即可。

### 空间优化

开$\mathcal O(n\times k)$的空间会爆炸。因此考虑滚动数组优化。

$F_{i,x},G_{i,x}$的值只和$F_{i-1,x}$和$G_{i-1,x}$的值相关。因此我们只需要保留上一个枚举到的$i$即可。具体的实现中，我们只需要用布尔变量$o$表示当前所用的数组，而$\operatorname{not} o$表示上一个枚举到的$i$时所用的数组。每次枚举完$i$，就令$o\gets \operatorname{not} o$即可。

时间复杂度$\mathcal O(n\times k)$，空间复杂度$\mathcal O(k)$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
const int MOD =19260817;
const int MAXN =1e5+3,MAXK=300+3;
int F[2][MAXK],G[2][MAXK],P[MAXN];
int n,k; bool o;
int pwr(int x,int y){
    int ret=1,t=x; while(y){
        if(y&1) ret=(LL)ret*t%MOD; y>>=1,t=(LL)t*t%MOD;
    }
    return ret;
}
int main(){
    n=qread(),k=qread(); up(1,n,i) P[i]=qread();
    F[!o][0]=1;
    up(1,n,i){
        F[o][0]=1; up(1,k,j)F[o][j]=(F[!o][j]+F[o][j-1])%MOD;
        G[o][0]=1; up(1,k,j)G[o][j]=((LL)G[!o][j]+(LL)G[o][j-1]*P[i])%MOD;
        o=!o;
    }
    printf("%d\n",(LL)G[!o][k]*pwr(F[!o][k],MOD-2)%MOD);
    return 0;
}
```

---

## 作者：Leianha (赞：4)

## DP

[博客阅读](https://www.cnblogs.com/wljss/p/12534475.html)

一个值得思考的 $DP$ 题。

设 $f[i][j]$ 为前 $i$ 个中选了 $j$ 次的方案数， $g[i][j]$ 为前 $i$ 个中选了 $j$ 次的所有方案的价值积的和。枚举上一个选取的位置和次数即可.

$O(n^2k^2)$ $20$分 空间也会爆炸

```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n, k;
LL tot, sum;
const int N = 100010, mod = 19260817;
int a[N];
LL f[N][305], g[N][305];
LL ksm(LL a, LL b, LL mod)
{
	LL res = 1;
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1)res = res * a % mod;
	return res;
}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	f[0][0] = 1; g[0][0] = 1;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= k; ++j)
			for (int l = 0; l < i; ++l)
				for (int o = 0; o < j; ++o)(f[i][j] += f[l][o]) %= mod;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= k; ++j)
			for (int l = 0; l < i; ++l)
				for (int o = 0; o < j; ++o)(g[i][j] += g[l][o] * ksm(a[i], j - o, mod)) %= mod;
	for (int i = 1; i <= n; ++i)(tot += f[i][k]) %= mod, (sum += g[i][k]) %= mod;
	cout << sum*ksm(tot, mod - 2, mod) % mod;
	return 0;
}
```
发现枚举上一个位置并没有什么用，记录一下前缀和就行了。

另外空间也只需要一维就行。

$O(nk^2)$ $70$分
```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n, k, now;
LL tot, sum;
const int N = 100010, mod = 19260817;
int a[N];
LL f[305], g[305], F[305], G[305];
LL ksm(LL a, LL b, LL mod)
{
	LL res = 1;
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1)res = res * a % mod;
	return res;
}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	F[0] = G[0] = 1; now = 1;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = k; j >= 1; --j)
		{
			f[j] = g[j] = 0;
			for (int o = 0; o < j; ++o)(f[j] += F[o]) %= mod;
			(F[j] += f[j]) %= mod;
			for (int o = 0; o < j; ++o)(g[j] += G[o] * ksm(a[i], j - o, mod)) %= mod;
			(G[j] += g[j]) %= mod;
		}
		(tot += f[k]) %= mod; (sum += g[k]) %= mod;
	}
	cout << sum*ksm(tot, mod - 2, mod) % mod;
	return 0;
}
```
发现循环$o$的含义就是类似于前缀和，差分一下就行。（$g$ 的差分需要将快速幂拆开）

$O(nk)$ $80$分
```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n, k, now;
LL tot, sum;
const int N = 100010, mod = 19260817;
int a[N];
LL f[305], g[305], F[305], G[305], S[305];
LL ksm(LL a, LL b, LL mod)
{
	LL res = 1;
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1)res = res * a % mod;
	return res;
}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	F[0] = G[0] = S[0] = 1; now = 1;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= k; ++j)f[j] = (f[j - 1] + F[j - 1]) % mod;
		for (int j = 1; j <= k; ++j)(F[j] += f[j]) %= mod;
		for (int j = 1; j <= k; ++j)S[j] = (S[j - 1] + G[j] * ksm(ksm(a[i], mod - 2, mod), j, mod)) % mod;
		for (int j = 1; j <= k; ++j)g[j] = ksm(a[i], j, mod) * S[j - 1] % mod;
		for (int j = 1; j <= k; ++j)(G[j] += g[j]) %= mod;
		(tot += f[k]) %= mod; (sum += g[k]) %= mod;
	}
	cout << sum*ksm(tot, mod - 2, mod) % mod;
	return 0;
}
```
上面的方法虽然时间复杂度对了，但由于快速幂跑的慢，递推省掉快速幂就行了。

$O(nk)$ $100$分
```cpp
#include<iostream>
#include<cstdio>
#define LL long long
using namespace std;
int n, k;
LL tot, sum;
const int N = 100010, mod = 19260817;
int a[N];
int f[305], g[305], F[305], G[305], S[305];
inline int ksm(int a, LL b)
{
	int res = 1;
	for (; b; b >>= 1, a = (LL)a * a % mod)
		if (b & 1)res = (LL)res * a % mod;
	return res;
}
inline int work(int x) {return x >= mod ? x - mod : x;}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; ++i)scanf("%d", &a[i]);
	F[0] = G[0] = S[0] = 1;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= k; ++j)f[j] = work(f[j - 1] + F[j - 1]);
		for (int j = 1; j <= k; ++j)F[j] = work(F[j] + f[j]);
		for (int j = 1, inv = ksm(a[i], mod - 2), now = 1; j <= k; ++j)now = (LL)now * inv % mod, S[j] = work(S[j - 1] + (LL)G[j] * now % mod);
		for (int j = 1, now = 1; j <= k; ++j)now = (LL)now * a[i] % mod, g[j] = (LL)now * S[j - 1] % mod;
		for (int j = 1; j <= k; ++j)G[j] = work(G[j] + g[j]);
		tot = work(tot + f[k]); sum = work(sum + g[k]);
	}
	cout << sum*ksm(tot, mod - 2) % mod;
	return 0;
}
```

---

## 作者：Ydoc770 (赞：2)

## Luogu P5131 荷取融合 [Link](https://www.luogu.com.cn/problem/P5131)

这道题是机房同学用**期望** tag 检索到的，所以很自然的把这道题当做期望 DP 来做了。然而经过讨论我们发现这是完全错误的。接下来我会先详细讲这道题如果求期望应该怎么 DP，以及求期望为什么不符合题意，还有正确的题意应该怎么做。

### 收益期望的求法（不是正解）

首先这道题如果对期望 DP 需要考虑后继状态的数量，因为题意告诉我们每次随机右移会等概率移动到当前或右边所有位置中的某一个位置，所以划分状态时一定会考虑当前的位置。自然有一个状态：设 $f_{i,j}$ 表示从 $i$ 位置出发选了 $j$ 个印记的期望。

根据题意 $i$ 位置是必选的，否则应该考虑方案中上一个位置的后继状态。容易得到边界情况

$$
f_{i,1}=a_i
$$

接下来我们考虑从后继状态转移到当前状态。由于我们从 $i$ 位置出发会等概率前往当前位置或右边位置中的一个，也就是每种后继状态有 $1\over n-i+1$ 的概率取到，所以有转移

$$
f_{i,j}=\sum_{t=i}^n{a_if_{t,j-1}\over n-i+1}={a_i\over n-i+1}\sum_{t=i}^nf_{t,j-1}
$$

最后由于题意告诉我们初始位置任意，所以答案即为

$$
ans={\sum_{i=1}^nf_{i,k}\over n}
$$

然后发现转移里后面的和式可以前缀和优化，所以直接 DP 是 $O(nk)$ 的。

这样我们就求出了收益的期望，然后一测样例你就会发现全是错的。

其实因为这道题求的根本不是期望啊，输出格式说的是求**收益的平均值**。

为什么不是期望呢？每种方案的平均值和期望有什么区别呢？

![](https://s2.loli.net/2025/04/08/uBHSzKikpARs34I.png)

其实这道题由于向右移动后左边的印记都不能取了，所以每种方案并不是等概率的。

举个最简单的例子：抓到 $k$ 次第 $1$ 个印记的方案概率是 ${1\over n^k}$，而抓到 $k$ 次第 $n$ 个印记的方案概率是 $1\over n$。前者不会影响后继状态的数量，后者抓一次第 $n$ 个印记之后后继状态只剩抓第 $n$ 个印记了。

原题目求的是每个方案收益的均值，相当于忽略了期望中每种方案的概率系数，钦定了每种方案等概率，这不是期望。

### 收益平均值的求法

接下来我们考虑求解原题。

由于不用考虑后继状态的数量，所以我们不需要在状态中体现位置对概率的影响。同时我们可以把原问题分成总收益和方案数两部分来分开 DP。设 $f_{i,j}$ 表示考虑了前 $i$ 个位置，选择了 $j$ 个印记的总收益，$g_{i,j}$ 表示考虑了前 $i$ 个位置，选择了 $j$ 个印记的总方案数。

考虑转移。我们在考虑前 $i-1$ 个位置的基础上考虑第 $i$ 个位置选或不选对总收益的影响。选择 $i$ 位置的印记就会让 $f_{i-1,j-1}$ 这部分的收益都乘上 $a_i$；不选的收益就是 $f_{i-1,j}$。所以有转移

$$
f_{i,j}=a_i\times f_{i-1,j-1} + f_{i-1,j}
$$

类似的，总方案数也由选或不选 $i$ 位置的印记两部分构成，所以有转移

$$
g_{i,j}=g_{i-1,j-1}+g_{i-1,j}
$$

注意一下初始状态，选 $0$ 个物品的总收益和总方案数被钦定为 $1$，否则转移出来全是 $0$。

直接 DP 的时间复杂度是 $O(nk)$。还有就是这个题 $O(nk)$ 的空间复杂度会 MLE，所以需要滚动数组。

### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn = 1e5 + 10, maxk = 3e2 + 10, mo = 19260817;
int n, k, a[maxn];
ll f[2][maxk], g[2][maxk];

ll qpow(ll x, ll y) {
    ll res = 1;
    while(y) {
        if(y & 1) (res *= x) %= mo;
        (x *= x) %= mo; y >>= 1;
    } return res;
}

int main(){
    ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);

    cin >> n >> k;
    for(int i = 1; i <= n; i++) cin >> a[i];

    g[0][0] = 1;
    for(int i = 1; i <= n; i++) {
    	f[i & 1][0] = g[i & 1][0] = 1;
        for(int j = 1; j <= k; j++) {
        	f[i & 1][j] = (f[(i & 1) ^ 1][j] + a[i] * f[i & 1][j - 1]) % mo;
        	g[i & 1][j] = (g[(i & 1) ^ 1][j] + g[i & 1][j - 1]) % mo;
		}
    }
    
    cout << f[n & 1][k] * qpow(g[n & 1][k], mo - 2) % mo; 
    return 0;
}
```

诚心希望洛谷的标签功能和工单反馈机制日益完善，为广大 OIer 提供更好的刷题环境！

---

## 作者：漠寒 (赞：2)

## 分析

首先看数据范围就知道这应该是一个 $O(nk)$ 的题。考虑 dp。

用 $f[i][j]$ 表示抓取了 $i$ 个，最后一个是 $j$ 的答案之和，$g[i][j]$ 表示有多少种不同的抓取方案，最后答案就是所有满足要求的 $f$ 之和除以对应的 $g$。

转移时，因为你可以从上一个抓取往右边跑，所以你只会从比 $j$ 小的地方转移到 $f[i][j]$ 和 $g[i][j]$。所以在循环的同时用两个数分别记录 $f$ 和 $g$ 的前缀和即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod=19260817;
inline int qpow(int ds,int zs){
	int x=1;
	while(zs){
		if(zs&1)x=1ll*x*ds%mod;
		ds=1ll*ds*ds%mod;zs>>=1;
	}
	return x;
}
inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
	res*=f;
}
int n,k;
int ti;
int a[100005],f[2][100005],g[2][100005],b[100005],bb[100005];
//只有128MB，所以要滚动数组 
signed main()
{
	f[0][1]=1;
	g[0][1]=1;
	read(n);read(k);
	for(int i=1;i<=n;i++)read(a[i]);
	for(int i=1;i<=k;i++){
		ti^=1;
		memset(f[ti],0,sizeof(f[ti]));
		memset(g[ti],0,sizeof(g[ti]));
		for(int j=1;j<=n;j++){
			b[j]=(b[j-1]+f[ti^1][j])%mod;//其实一个数就行了，不需要开数组 
			bb[j]=(bb[j-1]+g[ti^1][j])%mod;
			f[ti][j]=b[j]*a[j]%mod;
			g[ti][j]=bb[j];
		}
	}
	int sum=0,cnt=0;
	for(int i=1;i<=n;i++){
		sum=(sum+f[ti][i])%mod;
		cnt=(cnt+g[ti][i])%mod;
	}
	cout<<(sum*qpow(cnt,mod-2)%mod);
	return 0;
}

```


---

## 作者：LXcjh4998 (赞：1)

[Luogu 链接](https://www.luogu.com.cn/problem/P5131)
# 题意
求在 $n$ 个正整数 $a_i$ 中选取可以重复的 $k$ 个数的乘积的期望，结果对 $19260817$ 取模（$1\le n\le10^5,1\le k\le300,1\le a_i<19260817$）。
# 思路
显然，这一问题可以转化为求**方案总数**和**所有方案的贡献和**。
## 求方案总数
设 $G_{i,j}$ 为前 $i$ 个数选 $j$ 个的方案数。

则有：$G_{i,j}=G_{i-1,j}+G_{i,j-1}$。

即考虑是否选择 $a_i$，$G_{i-1,j}$ 为不选择 $a_i$ 的方案数，$G_{i,j-1}$ 为选择 $a_i$ 的方案数。

为了方便转移，令 $G_{i,0}=1,G_{0,j}=0$。
## 求所有方案的贡献和
设 $F_{i,j}$ 为前 $i$ 个数选 $j$ 个的方案的贡献。

则有：$F_{i,j}=F_{i-1,j}+a_i\times F_{i,j-1}$。

即考虑是否选择 $a_i$，$F_{i-1,j}$ 为不选择 $a_i$ 的贡献，$a_i\times F_{i,j-1}$ 为选择 $a_i$ 的贡献。

为了方便转移，令 $F_{i,0}=1,F_{0,j}=0$。
## 求期望
期望即 $\dfrac{F_{n,k}}{G_{n,k}}$，用快速幂求 $G_{n,k}$ 的逆元即可。
## 优化空间复杂度
若开二维数组，则空间会炸掉，考虑把第一维压掉。

注意到 $F_j$ 和 $G_j$ 在转移时须保证 $F_{j-1}$ 和 $G_{j-1}$ 更新过，而本身没被更新，因此第二层循环只需正序枚举即可保证正确性。
# 程序
[AC 记录](https://www.luogu.com.cn/record/212351239)
```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
#define ll long long
#define ull unsigned long long
#define uint unsigned int
#define vl __int128
#define ld long double
#define INF 0x3f3f3f3f
#define ls rt<<1
#define rs rt<<1|1
#define lb(x) ((x)&(-(x)))
#define pb push_back
#define forUp(i,a,b) for(int i=(a);i<=(b);++i)
#define forDown(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int N=1e5+10,K=300+10,mod=19260817;
//#define use_file
//#define more_test
//#define need_init
#ifdef more_test
int T;
#endif

int n,k,a[N];

int F[K],G[K];

int qp(int x,int y,int mod){
	int ans=1;
	while(y){
		if(y&1)ans=1ll*ans*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return ans;
}

void SOLVE(/*int TestID*/){
	scanf("%d%d",&n,&k);
	forUp(i,1,n)scanf("%d",&a[i]);
	F[0]=G[0]=1;
	forUp(i,1,n){
		forUp(j,1,k){
			F[j]=(F[j]+1ll*a[i]*F[j-1])%mod;
			G[j]=(G[j]+G[j-1])%mod;
		}
	}
	printf("%lld",1ll*F[k]*qp(G[k],mod-2,mod)%mod);
}
/*
Input:

Output:

*/
int main(){
	#ifdef use_file
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
	#endif
	#ifdef need_init
	init();
	#endif
	#ifdef more_test
	scanf("%d",&T);
	for(int i=1;i<=T;++i)SOLVE(i);
	#else
	SOLVE();
	#endif
	return 0;
}
```

---

## 作者：404Not_Found (赞：1)

比较简单的 dp。

首先这里的期望相当于所有方案的权值总和减去方案数，之后就是简单的 dp 了。

设 $f(i,j)$ 为前 $i$ 个数选了 $j$ 次的方案数，$g(i,j)$ 为权值和，转移很简单：

$$\begin{cases} f(i,j)=f(i-1,j)+f(i,j-1) \\g(i,j)=g(i-1,j)+g(i,j+1) \times a_i\end{cases}$$

最后的答案为 $\dfrac{g(i,j)}{f(i,j)}$，因为要取模，所以还要求个逆元。

注意到 $f(i,j),g(i,j)$ 都是从 $i-1$ 处转移过来，所以可以用滚动数组优化。

时间复杂度：$\mathcal{O}(nk)$，空间复杂度：$\mathcal{O}(n+k)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;
const int MAXK = 305;
const long long P = 19260817;
#define LL long long
int n,k,a[MAXN];
LL f[2][MAXK],g[2][MAXK];
LL power(LL a,LL b)
{
	LL ret=1;
	for(;b;b>>=1,a=(a*a)%P) if(b&1) ret=(ret*a)%P;
	return ret;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	f[1][0]=f[0][0]=g[1][0]=g[0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k;j++)
		{
			f[i&1][j]=(f[i&1^1][j]+f[i&1][j-1])%P;
			g[i&1][j]=(g[i&1^1][j]+g[i&1][j-1]*a[i]%P)%P;
		}
	printf("%lld\n",g[n&1][k]*power(f[n&1][k],P-2)%P);
}
```

---

## 作者：Mars_Dingdang (赞：1)

基础贡献计算动态规划。

## 题目大意
给定 $n$ 个数 $a_i$，每次可重复地随机选出 $k$ 个数，求这 $k$ 个数地乘积的平均值（期望）。

$n\le 10^5, k\le 300$。

## 大体思路
考虑期望计算方式：用总和除以总方案数。故只需计算出乘积的总和以及总的方案数即可。可以利用动态规划。

具体地，令 $F[i, j]$ 表示前 $i$ 个数随机选 $j$ 个的方案数。若第 $i$ 个数不选，则相当于前 $i-1$ 个选 $j$ 个；若第 $i$ 个数选，则相当于前 $i$ 个还要选 $j-1$ 个，故 $F[i, j]=F[i-1, j]+F[i, j-1]$。

同理，令 $G[i, j]$ 表示前 $i$ 个数随机选出 $j$ 个的乘积的总和。利用上述方式对选不选进行讨论可得，$G[i, j]=G[i-1, j]+G[i, j-1]\times a_i$。

边界条件：对于所有 $j=0$，$F[i, 0]=G[i, 0]=1$；特殊地，$F[0, 0]=1$。同时，由于 $i$ 的转移只与 $i-1$ 有关，可以用滚动数组优化空间，即用 `F[i&1][j]` 限制第一维。

最终答案为 $\dfrac {G[n, k]}{F[n, k]}$。由于 $19260817$ 是质数，可以利用费马小定理与快速幂求出逆元。注意动态规划状态转移时及时取模。时间复杂度 $O(nk)$。空间复杂度 $O(n)$，若不储存 $a_i$ 可以降为 $O(k)$。

## 完整代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5;
const ll mod = 19260817;
inline ll Pow(ll a, ll b) {
	ll ans = 1;
	while(b) {
		if(b & 1) ans = (ans * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return ans % mod;
}
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll n, a[maxn], F[2][maxn], k, G[2][maxn];
int main () {
	read(n); read(k);
	rep(i, 1, n) read(a[i]);
	F[0][0] = 1;
	rep(i, 1, n) {
		F[i & 1][0] = 1; // 边界
		rep(j, 1, k) F[i & 1][j] = (F[(i - 1) & 1][j] + F[i & 1][j - 1]) % mod;	// 滚动数组优化
		G[i & 1][0] = 1;
		rep(j, 1, k) G[i & 1][j] = (G[(i - 1) & 1][j] + G[i & 1][j - 1] * a[i]) % mod;
	}
	writeln((G[n & 1][k] * Pow(F[n & 1][k], mod - 2)) % mod); // 逆元
	return 0;
}
```

---

## 作者：koishi_offical (赞：0)

### 题目大意
从 $n$ 个数中随机选 $k$ 个可以重复的数，其权值为 $k$ 个数的乘积，求权值的期望。

### 解法
我们先将要求结果分成两部分:

1 . 所有方案的权值总和。

2 . 方案数。

考虑 dp ，设 $f(i,j)$ 为前 $i$ 个数中选 $j$ 次的方案数，$dp(i,j)$ 为前 $i$ 个数中选 $j$ 次的所有方案的权值总和。

最终答案即为 $\frac{dp(n,k)}{f(n,k)}$ .

#### 状态转移方程

对于 $f$ 来说，每次有两种方式到达 $f(i,j)$ ，从左面过来或者再抓取一个，因此可得状态转移方程为：
   
   $f(i,j)=f(i-1,j)+f(i,j-1)$

对于 $dp$ 来说，从左面过来的不会选取数字，因此直接统计即可，再抓取一个的，需要乘上 $a(i)$ 再统计进去。 综上，状态转移方程为：

  $dp(i,j)=dp(i-1,j)+dp(i,j-1)\times a(i)$
  
#### 优化

可以看到每次状态转移方程第一维只和 $i$ 和 $i-1$ 有关，因此我们可以用滚动数组滚掉第一维。

#### 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=19260817;
const int N=1e5+10,K=310;
int n,k;
int a[N],f[2][K],dp[2][K];
int quickpow(int a,int b)
  {
      int ans=1,x=a;
      while(b)
        {
            if(b&1) ans=ans*x%mod;
            b>>=1;
            x=x*x%mod;
        }
      return ans;
  }
signed main() {
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    f[0][0]=f[1][0]=1;
    dp[0][0]=dp[1][0]=1;
    for(int i=1;i<=n;i++)
     {
      for(int j=1;j<=k;j++)
        {
            f[i&1][j]=(f[i&1][j-1]+f[i&1^1][j])%mod;
            dp[i&1][j]=(dp[i&1^1][j]+dp[i&1][j-1]*a[i])%mod;
        }
     }
   cout<<(dp[n&1][k]*quickpow(f[n&1][k],mod-2))%mod;
}
```


---


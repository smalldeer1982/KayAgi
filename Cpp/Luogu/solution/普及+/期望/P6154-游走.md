# 游走

## 题目背景

zbw 在 B 城游走。

## 题目描述

B 城可以看作一个有 $n$ 个点 $m$ 条边的**有向无环图**。**可能存在重边**。

zbw 在 B 城随机游走，他会在所有路径中随机选择一条路径，选择所有路径的概率相等。路径的起点和终点可以相同。

定义一条路径的长度为经过的边数，你需要求出 zbw 走的路径长度的期望，答案对 $998244353$ 取模。

## 说明/提示

样例说明：样例的答案分别为 $\dfrac{2}{5}$，$\dfrac{25}{19}$ 和 $\dfrac{11}{9}$。

| 测试点编号 | $n$ | $m$ | 特殊性质 | 每测试点分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $\le 10$ | $\le 10$ | 无 | $2$ |
| $3,4,5$ | $\le 15$ | $\le 100$ | 无 | $2$ |
| $6,7,8$ | $\le 100$ | $\le 10^3$ | 无 | $2$ |
| $9,10$ | $\le 10^3$ | $\le 10^4$ | 无 | $2$ |
| $11,12$ | $\le 10^4$ | $\le 10^5$ | 无 | $5$ |
| $13,14$ | $\le 10^5$ | $\le 2\times10^5$ | 无 | $5$ |
| $15,16$ | $\le 10^5$ | $\le 7\times10^5$ | 无 | $10$ |
| $17$ | $\le 10$ | $=n-1$ | 有向树 | $10$ |
| $18$ | $\le 10^3$ | $=n-1$ | 有向树 | $10$ |
| $19$ | $\le 10^4$ | $=n-1$ | 有向树 | $10$ |
| $20$ | $\le 10^5$ | $=n-1$ | 有向树 | $10$ |

其中，“有向树”的定义是：若把图视为无向图，则为一棵树（如样例 $1,2$）。

保证所有数据均按照某种方式随机，这意味着你可以认为算法执行过程中，你可以放心执行模意义下除法操作而不用担心除以零。

## 样例 #1

### 输入

```
3 2
1 2
3 2```

### 输出

```
199648871```

## 样例 #2

### 输入

```
6 5
1 3
2 3
3 4
4 5
4 6```

### 输出

```
630470119```

## 样例 #3

### 输入

```
5 6
1 2
1 3
4 5
3 4
3 5
2 4```

### 输出

```
887328315```

# 题解

## 作者：gyh20 (赞：26)

感谢 [Feecle_6418] (https://www.luogu.com.cn/user/42156) 提供本题。

题意:给定一个有向无环图，求其中一条路径长度的期望。

一条路径长度的期望 $=$ $\dfrac{sum}{cnt}$。

其中 $sum$ 代表所有路径长度的总和， $cnt$ 代表路径的个数。

记忆化搜索，令 $f_i$ 表示从 $i$ 开始的路径长度和， $g_i$ 表示从 $i$ 开始的路径条数。

则 $f_i=\sum\limits_{edge(i,j)}f_j+g_j$（每条路径都变长 $1$）

$g_i=1+\sum\limits_{edge(i,j)}g_j$（所有路径加上自己到自己）

答案即为 $\dfrac{\sum f_i}{\sum g_i}$。

$std$ $by$ [Feecle_6418](https://www.luogu.com.cn/user/42156)

```cpp
//100 points
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define mod 998244353ll
using namespace std;
struct Edge{
	int to,next;
}e[700005];
int cnt,h[100005],n,m;
long long f[100005],g[100005],s1,s2;
//f:路径长度和
//g:路径数
void Add_Edge(int x,int y){
	e[++cnt].to=y;
	e[cnt].next=h[x];
	h[x]=cnt;
}
void DP(int now){
	if(g[now])return ;
	g[now]=1;
	for(int i=h[now];i;i=e[i].next){
		int y=e[i].to;
		DP(y);
		(g[now]+=g[y])%=mod;
		(f[now]+=f[y]+g[y])%=mod;
	}
}
long long Power(long long x,long long y,long long z){
	long long ret=1;
	while(y){
		if(y&1)ret=ret*x%z;
		y>>=1;
		x=x*x%z;
	}
	return ret;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<=m;i++){
		scanf("%d%d",&x,&y);
		Add_Edge(x,y);
	}
	for(int i=1;i<=n;i++)if(!g[i])DP(i);
	for(int i=1;i<=n;i++)(s1+=f[i])%=mod,(s2+=g[i])%=mod;
	printf("%lld\n",s1*Power(s2,mod-2,mod)%mod);
	return 0;
}
```


---

## 作者：zsaskk (赞：11)

[题面](https://www.luogu.com.cn/problem/P6154)

------------

给定一个$DAG$，求所走路径长度的期望。

期望$E(X)=\sum_{}^{}{X}_{i}×P({X}_{i})$

在这道题目里，我们认为每一条路径出现概率相同，那么期望就是$\frac{lenth}
{num}$

------------

$lenth$和$num$都可以用$DAG$上的一个常见处理方式计算。

定义$num[x],f[x]$分别为以$x$为结尾的路径的数量和长度和。

考虑对$DAG$进行拓扑排序。

考虑$DAG$中的一个点$x$，定义一个点$from$，那么根据$DAG$的定义，$x$无法回到$from$，也就是说，$from$对$x$有影响，$x$对$from$无影响。

那么我们可以进行拓扑排序，当当前点为$x$时，枚举$x$能到的点$y$，进行操作$f[y]+=f[x],num[y]+=num[x]$。

意义很简单，就是以$x$为结尾的路径可以~~再长一点~~，延伸到$y$。

最后把每一个点的$f[x]$和$num[x]$加起来就行了，再求个逆元。

复杂度$O(n+m)$

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define p 998244353
#define int long long
#define chk_digit(c) (c>='0'&&c<='9')
inline int read() {
	reg int x=0,f=1;reg char c=getchar();
	while(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }
	while(chk_digit(c)) x=x*10+c-'0',c=getchar();
	return x*f;
}
int n,m,cnt,h[100005],num[100005],f[100005],indeg[100005],ans1,ans2;
stack<int> s;
struct node{ int y,next; }edg[700005<<1];
inline void add(int x,int y) { edg[++cnt].next=h[x],edg[cnt].y=y,h[x]=cnt; }
inline void topo_sort() {//拓扑排序
	while(s.size()) {
		int x=s.top();s.pop();
		for(reg int i=h[x];i;i=edg[i].next) {
			int y=edg[i].y;
			--indeg[y],num[y]=(num[x]+num[y])%p,f[y]=(f[y]+f[x]+num[x])%p;
			if(!indeg[y]) s.push(y);
 		}
	}
	for(reg int i=1;i<=n;++i) ans1=(f[i]+ans1)%p,ans2=(ans2+num[i])%p;
}
inline int quick_pow(int a,int b) {//逆元
	int ans=1,base=a;
	while(b) {
		if(b&1) ans=ans*base%p;
		base=base*base%p,b>>=1;
	}
	return ans%p;
}
signed main() {
	n=read(),m=read();
	for(reg int i=1;i<=m;++i) {
		int x=read(),y=read();
		add(x,y),++indeg[y];
	}
	for(reg int i=1;i<=n;num[i]=1/*初始化为1*/,++i) if(!indeg[i]) s.push(i);//把起点放进去
	topo_sort();
	printf("%lld\n",(quick_pow(ans2,p-2)*ans1)%p);
}
```



---

## 作者：Hexarhy (赞：4)

### Preface

蛮水的一道图论题，可以简单复习拓扑排序。

### Solution

先考虑期望怎么算。显然，答案为 $\dfrac{L}{S}$，其中 $L$ 为所有路径总长度，$S$ 为路径条数。

接下来就是图论的活。

考虑到 DAG，我们可以拓扑排序后进行 dp。设 $f_i$ 为以节点 $i$ 为终点的路径总长度，$g_i$ 为以节点 $i$ 为终点的路径条数。显然，

$$f_i=\sum_{edge(j,i)}f_j+g_j$$

$$g_i=\sum_{edge(j,i)}g_j$$

很好理解，即 $j$ 到 $i$ 有边时，$f_i$ 为所有以 $j$ 为结尾的路径长度上均加上 $1$。而这样的路径有 $g_j$ 条，所以总的就是 $f_j+g_j$。

至于边界值，显然 $\forall i\in G,g_i=1$，因为每个点的路径条数至少为 $1$。

那么答案为：

$$\large\dfrac{\sum_{i\in G} f_i}{\sum_{i\in G}g_i}$$

然后求逆元取个模就可以了。

### Notice

- 注意开`long long`。

然后就没啥坑点了。

### Code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

typedef long long ll;
const int MAXN=1e5+5;
const ll MOD=998244353;
int n,m;
ll L,S;
vector<int> edge[MAXN];
ll f[MAXN],g[MAXN];
int indeg[MAXN];
bool visit[MAXN];

void topo_sort(void)//模板
{
	queue<int> q;
	for(int i=1;i<=n;i++)
     if(!indeg[i])
      q.push(i);
    while(!q.empty())
    {
    	const int u=q.front();
    	q.pop();
    	if(visit[u])	continue;
    	visit[u]=true;
    	for(auto v:edge[u])
    	{
    		indeg[v]--;
    		if(!indeg[v])	q.push(v);
    		f[v]=(f[v]+f[u]+g[u])%MOD;//dp
    		g[v]=(g[v]+g[u])%MOD;
		}
	}
}

ll qpow(ll base,ll k)//快速幂求逆元
{
	ll res=1;
	while(k)
	{
		if(k&1)	res=res*base%MOD;
		base=base*base%MOD;
		k>>=1;
	}
	return res;
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v;cin>>u>>v;
		edge[u].push_back(v);
		indeg[v]++;
	}
	for(int i=1;i<=n;i++)	g[i]=1;//初始化
	topo_sort();
	for(int i=1;i<=n;i++)	L=(L+f[i])%MOD;//统计答案
	for(int i=1;i<=n;i++)	S=(S+g[i])%MOD;
	cout<<(L*qpow(S,MOD-2))%MOD<<endl;
	return 0;
}
```

---

## 作者：wangjinbo (赞：3)

题意：有一个 $n$ 个点， $m$ 条边的有向无环图，随机选择一条路径，求路径的期望长度。

根据期望的定义，令所有路径长度和为 $sum$ ，总路径数为 $cnt$ ，我们可以知道答案就是$\frac{sum}{cnt}$。下面分别来说如何求 $sum$ 和 $cnt$。


### 1. 求cnt

令 $cnt[i]$ 为节点 $i$ 为起点的路径数。对每个点进行一次搜索即可，令当前点为 $now$ ，若 $now$ 无出边，则 $cnt[now]=1$
否则 $cnt[now]$ 为其所有后继节点的 $cnt$ 值加1（注意：不是求能到的节点数，即有多条路径可到达同一节点时，计为多条）

### 2.求sum

我们考虑每一条边对结果产生的影响，即每一条边被用到的次数。根据乘法原理，设一条边为 $u$ -> $v$，则此边被用到的次数为 终点为 $u$ 的路径数*起点为 $v$ 的路径数。然后我们发现起点为 $v$ 的路径数已经求过了，就是 $cnt[v]$ 。那么只需要求出终点为 $u$ 的路径数就可以了。最简单的办法是建一个反图，那么原图上终点为 $u$ 的路径数即为反图上起点为 $u$ 的路径数。用相同的方法求解即可。

下面上AC代码（知道你们只想要这个）
# AC代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxm=7e5+10;
const int mod=998244353;
const int maxn=1e5+10;
long long qpow(long long a,long long b,int mod)
{
	if(b==0)return 1;
	long long t=qpow(a,b/2,mod);
	if(b&1)return t*t%mod*a%mod;
	else return t*t%mod;
}
struct edge{
	int next,to;
};
edge a[maxm],b[maxm];//a正图和b反图
long long heada[maxn],headb[maxn],cnta[maxn],cntb[maxn],cnt;
void add(int x,int y)
{
	cnt++;
	a[cnt].next=heada[x];
	a[cnt].to=y;
	heada[x]=cnt;
	b[cnt].next=headb[y];
	b[cnt].to=x;
	headb[y]=cnt;
}
bool vis[maxn];
void dfs1(int now)//处理正图
{
	vis[now]=1;
	for(int i=heada[now];i;i=a[i].next)
	{
		int u=a[i].to;
		if(u){
			if(vis[u]){
				cnta[now]+=cnta[u];cnta[now]%=mod;continue;
			}
			dfs1(u);
			cnta[now]+=cnta[u];
			cnta[now]%=mod;
		}
	}
	cnta[now]++;
}
void dfs2(int now)//处理反图
{
	vis[now]=1;
	for(int i=headb[now];i;i=b[i].next)
	{
		int u=b[i].to;
		if(u){
			if(vis[u]){
				cntb[now]+=cntb[u];cntb[now]%=mod;continue;
			}
			dfs2(u);
			cntb[now]+=cntb[u];
			cntb[now]%=mod;
		}
	}
	cntb[now]++;
}
signed main()
{
	int n,m;
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%lld %lld",&x,&y);
		add(x,y);
	}
	for(int i=1;i<=n;i++)
	if(!vis[i])dfs1(i);
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++)
	if(!vis[i])dfs2(i);
	long long ans1=0,ans2=0;
	for(int i=1;i<=n;i++)
	{
		ans1+=cnta[i];
		ans1%=mod;
	}
	for(int i=1;i<=n;i++)
	for(int j=heada[i];j;j=a[j].next){
		int u=a[j].to;
		ans2+=cntb[i]*cnta[u]%mod;
		ans2%=mod;
	}
	printf("%lld\n",ans2*qpow(ans1,mod-2,mod)%mod);
	return 0;
}
```
顺便说一句，这道题一定记着全部开LL+每次运算都取模，否则随时随地爆LL（比赛时因为这个调了半小时）

---

## 作者：寒鸽儿 (赞：2)

### P6154 游走

#### 思路

记图 $G = \{V, E\}$ , 所有路径的集合为 $P$ 。等概率选择每一条路径的情况下 , 每条路径被选中的概率即为 $\frac{1}{\left| P \right|}$ 。  
$$
E(X) = \sum_{p_k \in P} \frac{length(p_k)}{\left| P \right|}
$$
来换一种统计的思路 , 一条边 $e$ 对期望的贡献是它被选入路径的概率 $\times 1$ 。
$$
E(X) = \sum_{e \in E}\frac{\sum_{p_k \in P}[e \in p_k]}{\left| P \right|} = \frac{1}{\left| P \right|} \sum_{e \in E} \sum_{p_k \in P}[e \in p_k]
$$
那么问题就转化为求 $\left| P \right|$ 以及对于每条边 $e$ 有多少路径 $p_k$ 满足 $e \in p_k$ 。  

然后以拓扑序在正图和反图上跑个dp就能完成统计。  

#### code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const ll p = 998244353;
const int maxn = 100010; 

Graph G, _G;
queue<int> q;
int ind[maxn], _ind[maxn];
ll cnt[maxn], _cnt[maxn];

inline ll inv(ll a) {
	ll res = 1 % p;
	for(int b = p - 2; b; b >>= 1) {
		if(b & 1) res = res * a % p;
		a = a * a % p;		
	}
	return res;
}

int main() {
	int n, m, u, v;
	cin >> n >> m;
	G.resize(n + 1);
	_G.resize(n + 1);
	for(int i = 0; i < m; ++i) {
		cin >> u >> v;
		G[u].push_back(v); ++ind[v];
		_G[v].push_back(u); ++_ind[u];
	}
	for(int i = 1; i <= n; ++i) if(!ind[i]) q.push(i);
	ll tot = 0, ans = 0;
	while(!q.empty()) {
		int cur = q.front(); q.pop();
		tot = (tot + cnt[cur]) % p;
		for(int ver : G[cur]) {
			cnt[ver] = (cnt[ver] + cnt[cur] + 1) % p;
			if(!(--ind[ver])) q.push(ver);
		}
	}
	for(int i = 1; i <= n; ++i) if(!_ind[i]) q.push(i);
	while(!q.empty()) {
		int cur = q.front(); q.pop();
		for(int ver : _G[cur]) {
			_cnt[ver] = (_cnt[ver] + _cnt[cur] + 1) % p;
			if(!(--_ind[ver])) q.push(ver);
		}
	}
	tot = (tot + n) % p; 
	for(int cur = 1; cur <= n; ++cur)
		for(int ver : G[cur])
			ans = (ans + ((cnt[cur] + 1) * (_cnt[ver] + 1)) % p) % p;
	ans = ans * inv(tot) % p;
	cout << ans << endl;
	return 0;
}
```



---

## 作者：天梦 (赞：1)

# P6154

[链接](https://www.luogu.com.cn/problem/P6154)

不难发现，所有的路径被选概率都是一样的，也就是说，所有的路径被选的概率是 $1$ 除以路径的总条数。再者我们需要算出所有路径的长度总和。

考虑 dp 。令 $f_k$ 表示结尾为 $k$ 的路径长度总和，$g_k$ 表示结尾为 $k$ 的路径条数。

不难设计一个 dp ：

$$
f_u=\sum\limits_{v,(v,u)\in E} f_v+g_v\\

g_u=\sum\limits_{v,(v,u)\in E}g_v
$$

累加所有答案算逆元就可以了。

代码：

```c++
#include<bits/stdc++.h>
#define dd double
#define ld long double
#define ll long long
#define int long long
#define uint unsigned int
#define ull unsigned long long
#define N 100010
#define M 700010
using namespace std;

const int INF=0x3f3f3f3f;
const ll mod=998244353;

template<typename T> inline void read(T &x) {
    x=0; int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    x*=f;
}

int rd[N],n,m;

struct edge{
    int to,next;
    inline void intt(int to_,int ne_){
        to=to_;next=ne_;
    }
};
edge li[M];
int head[N],tail;

inline void add(int from,int to){
    li[++tail].intt(to,head[from]);
    head[from]=tail;
}

queue<int> q;

ll ans1,ans2,f[N],g[N];
bool vis[N];

inline void solve(){
    while(q.size()){
        int top=q.front();q.pop();g[top]++;ans1+=f[top];ans2+=g[top];
        ans1%=mod;ans2%=mod;
        for(int x=head[top];x;x=li[x].next){
            int to=li[x].to;
            f[to]+=f[top]+g[top];g[to]+=g[top];
            f[to]%=mod;g[to]%=mod;
            rd[to]--;
            if(!rd[to]) q.push(to);
        }
    }
}

inline ll ksm(ll a,ll b,ll mod){
    a%=mod;
    ll res=1;
    while(b){
        if(b&1) (res*=a)%=mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}

signed main(){
    read(n);read(m);
    for(int i=1;i<=m;i++){
        int from,to;read(from);read(to);
        add(from,to);rd[to]++;
    }
    for(int i=1;i<=n;i++){
        if(!rd[i]) q.push(i);
    }
    solve();
    // printf("%lld %lld\n",ans1,ans2);
    ll inv=ksm(ans2,mod-2,mod);
    printf("%lld\n",ans1*inv%mod);
    return 0;
}
```


---

## 作者：AzzyZhe (赞：1)

## 题解 [P6154 游走](https://www.luogu.com.cn/problem/P6154)
----
### 思路
----
根据题目我们要求一个**有平行边**无自环边的 **$\text{DAG}$** 上`Z`走过路径长度的数学期望，由数学期望定义很容易知道即求路径长之和比上路径数。

如记路径数量为 $\operatorname{T}(G)$，记路径总长度为 $\operatorname{S}(G)$，即要求 $\frac{\operatorname{T}(G)}{\operatorname{S}(G)}$ ；

先让我们以常规思路寻找递推关系求解 $\operatorname{T}(G)$ 和 $\operatorname{S}(G)$ 。

考虑一种简单的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/mchzpanb.png)

如图，让我以圆圈为终点表示出所有可能路径。有什么规律呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/6rhsyky2.png)

观察一条边两边的点，这里观察所有以 $3$ 为终点和以 $4$ 为终点的路径，

可以发现以 $4$ 为终点的长度非 $0$ 的边都可以看作是以 $3$ 为终点的边的延长，则以 $4$ 为终点路径长度之和为以 $3$ 为终点路径长度之和加上以 $4$ 为终点路径数乘 $1$ ；

以 $4$ 为终点路径数为以 $3$ 为终点路径数加 $1$ 。

若以 $F_1[i]$ 表示以 $i$ 为终点路径数， $F_2[i]$ 表示以 $i$ 为终点路径长度之和。

即

$$F_1[4]=F_1[3]+1$$

$$F_2[4]=F_2[3]+1*F_1[3]$$

再考虑更复杂的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/858v4nlz.png)![](https://cdn.luogu.com.cn/upload/image_hosting/cqv4izvy.png)

可以发现上面的两条规律这里也成立，不难理解。

可以归纳出：

$$F_1[p]=\sum\limits_{(i,p)\in G}F_1[i]+1$$

$$F_2[p]=\sum\limits_{(i,p)\in G}(F_2[i]+F_1[i])$$

且易知：

$$T(G)=\sum\limits_{i\in G}F_1[i]$$

$$S(G)=\sum\limits_{i\in G}F_2[i]$$

已经可以求解。

### 实现
----
根据以上关系，

求解一个点之前需要先处理能到达的点，利用拓扑排序的思路`dfs`一遍即可，详见代码。

当然也可以原本拓扑排序本身，但是不建议，毕竟拓扑排序基本都可以记忆化搜索代替，相对还容易写错= =。

~~其实大概是之前比赛拓扑排序写裂有了阴影。~~

至于分数取模，

当 $p$ 是质数时，由费马小定理
$$a^{p-1}\equiv1\pmod{p}$$

得
$$a^{-1}\equiv a^{p-2}\pmod{p} $$

则
$$\frac{a}{b}=a*b^{-1}\equiv a*b^{p-2}\pmod{p}$$

快速幂求解即可。

~~刚开始还是搞错数据范围WA了70pts。~~

### 代码
----
```cpp
#include<iostream>
using namespace std;
typedef long long int64;
int64 const mod=998244353;
#define MAXN 100010
#define MAXM 700010
int64 qkPow(int64 x,int64 t)//快速幂，用来求逆元
{
	int64 a=1;
	while(t)
	{
		if(t&1)
			a*=x,a%=mod;
		x*=x,x%=mod;
		t>>=1;
	}
	return a;
}
int64 sum,tot;//sum:总长度(T) tot:路条数(S)
int n,m;
int head[MAXN];
int v[MAXM],nxt[MAXM];
int indgr[MAXN];
int64 F1[MAXN],F2[MAXN];//F1[i]:以i为终点路径条数 F2路径总长
void dfs(int p)
{
	if(indgr[p])
		return;
	F1[p]++,F1[p]%=mod;
	tot+=F1[p],tot%=mod;
	sum+=F2[p],sum%=mod;
	for(int i=head[p];i;i=nxt[i])
		F1[v[i]]+=F1[p],F1[v[i]]%=mod,
		F2[v[i]]+=F2[p]+F1[p],F2[v[i]]%=mod,
		indgr[v[i]]--,
		dfs(v[i]);
}
int mian()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1,u;i<=m;i++)
		cin>>u>>v[i],
		indgr[v[i]]++,
		nxt[i]=head[u],
		head[u]=i;
	for(int i=1;i<=n;i++)
		if(!indgr[i])
			dfs(i);
	//cerr<<sum<<' '<<tot<<'\n';
	cout<<(sum*qkPow(tot,mod-2))%mod;
	return 0;
}

```
----
$upd:$
- $2021.7.21$ 换掉了瞎眼配图

---

## 作者：TYxxj (赞：1)

## 题解：

### 1. 暴力思路：
从每个点开始全图遍历，累加出所有路径条数和路径长度和，两者相除求逆元即是答案。

50分代码：
```cpp
#include<cstdio>
#define int long long
using namespace std;
const int maxn=1e5+10;
const int maxm=7*1e5+10;
const int tt=5*1e6;
const int mod=998244353;
int n,m,cnt,tmp;
int tot,to[maxm],nxt[maxm],head[maxn];
int inv[tt];
void add(int x,int y) {
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
void dfs(int x,int dep) {
	cnt++;
	tmp+=dep;
	for(int i=head[x]; i; i=nxt[i]) {
		int y=to[i];
		dfs(y,dep+1);
	}
}
signed main() {
	scanf("%lld%lld",&n,&m);
	inv[1]=1;
	for(int i=2; i<=tt; i++)inv[i]=((mod-mod/i)*inv[mod%i])%mod;
	for(int i=1; i<=m; i++) {
		int x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y);
	}
	for(int i=1; i<=n; i++)dfs(i,0);
	int ans=(tmp*inv[cnt])%mod;
	printf("%lld\n",ans);
	return 0;
}
```

### 2. 正解记忆化：
本来以为是什么期望DP+拓排之类的小神题（当然对于学弟来讲是水题）。

结果正解就是暴搜+记忆化优化。

怀疑人生。

逆元没有必要拿线性求逆元，因为998244353是质数，所以逆元直接就是ap−2，快速幂即可。

代码：
```cpp
#include<cstdio>
#define int long long
using namespace std;
const int maxn=1e5+10;
const int maxm=7*1e5+10;
const int tt=5*1e6;
const int mod=998244353;
int n,m,cnt,tmp,ans;
int tot,to[maxm],nxt[maxm],head[maxn];
int f[maxn],g[maxn];
void add(int x,int y) {
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
void dfs(int x) {
	if(f[x])return;
	f[x]=1;
	for(int i=head[x]; i; i=nxt[i]) {
		int y=to[i];
		dfs(y);
		f[x]=(f[x]+f[y])%mod;
		g[x]=(g[x]+f[y]+g[y])%mod;
	}
}
int qpow(int a,int b) {
	int ret=1;
	while(b) {
		if(b&1)
			ret=(ret*a)%mod;
		b>>=1;
		a=(a*a)%mod;
	}
	return ret%mod;
}
signed main() {
	scanf("%lld%lld",&n,&m);
	for(int i=1; i<=m; i++) {
		int x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y);
	}
	for(int i=1; i<=n; i++)if(!f[i])dfs(i);
	for(int i=1; i<=n; i++) {
		cnt=(cnt+f[i])%mod;
		tmp=(tmp+g[i])%mod;
	}
	ans=(tmp%mod*qpow(cnt,mod-2)%mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Graphcity (赞：1)

在这道题中，我们假设有 $k$ 条路径，第 $i$ 条路径的长度为 $l_i$ , 则总期望（ 用 $ans$ 表示 ）如下：

$$
ans=\sum_{i=1}^{k}l_i \cdot \dfrac{1}{k}
$$

也就是**所有路径的总长度除以路径条数**。

我们设从点 $i$ 开始的路径一共有 $num_i$ 条，总长度为 $sum_i$ ，则可以得到这个公式：

$$
\begin{matrix}
sum_i= \sum_{j} num_j+sum_j \\ 
num_i= 1+\sum_{j} num_j
\end{matrix}
$$

其中 $i$ 有一条边连向 $j$ 。这个过程可以用记忆化搜索的办法实现。

计算 $ans$ 时，我们就可以这样：

$$
ans= \dfrac{\sum_{i=1}^{n} sum_i}{\sum_{i=1}^{n} num_i}
$$

最后结果对 $998244353$ 取模的过程可以使用扩欧实现。

```cpp
#include<bits/stdc++.h>
#define Maxn int(1e5)
#define Maxm int(7e5)
#define Mod 998244353
#define ll long long
using namespace std;

struct Node//链式前向星 
{
	ll to,nxt;
} Edge[Maxm+5];
ll tot,Head[Maxn+5];

inline void Addedge(ll x,ll y)
{
	Edge[++tot].to=y;
	Edge[tot].nxt=Head[x];
	Head[x]=tot;
}

inline ll exgcd(ll a,ll b,ll &x,ll &y)//扩欧 
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	ll nowgcd=exgcd(b,a%b,y,x);
	y=y-a/b*x;
	return nowgcd;
}

ll n,m,anssum,ansnum;
//anssum:路径长度之和 ansnum:路径总数 
ll vis[Maxn+5];
ll sum[Maxn+5],num[Maxn+5];

inline void dfs(ll x)//记忆化搜索 
{
	if(vis[x])//如果已经搜索过 
		return;
	num[x]=1;
	for(register ll i=Head[x];i;i=Edge[i].nxt)//状态转移 
	{
		dfs(Edge[i].to);
		sum[x]=(sum[x]+sum[Edge[i].to]+num[Edge[i].to])%Mod;
		num[x]=(num[x]+num[Edge[i].to])%Mod;
	}
	vis[x]=1;//标记 
}

int main()
{
	scanf("%lld%lld",&n,&m);
	for(register ll i=1;i<=m;++i)//连边 
	{
		ll a,b;
		scanf("%lld%lld",&a,&b);
		Addedge(a,b);
	}
	for(register ll i=1;i<=n;++i)//搜索 
	{
		if(!vis[i])
			dfs(i);	
		anssum=(anssum+sum[i])%Mod;
		ansnum=(ansnum+num[i])%Mod;
	}
	ll nowgcd,rub;//计算答案 
	exgcd(ansnum,Mod,nowgcd,rub);//扩欧计算逆元 
	nowgcd=(nowgcd+Mod)%Mod;
	anssum=anssum*nowgcd%Mod;
	printf("%lld",anssum);
    return 0;
}
```

---

## 作者：zym_LFCOIer (赞：0)

## Solution
首先，易得，本题答案为

$\frac{\text{图中所有路径的长度和}}{\text{图中的路径条数}}$.

设 $f_i$ 表示以节点 $i$ 结尾的路径总长度，$g_i$ 表示以节点 $i$ 为结尾的路径条数，则在对图进行拓扑排序后，有：
1. $$f_i=\sum_{j,(i,j)\in{E}}f_j+g_j$$
2. $$g_i=\sum_{j,(i,j)\in{E}}g_j$$
$1$ 式表示，以 $j$ 为结尾的路径长度都增加 $1$，所以加上 $g_j$，再累加到 $f_i$ 中；

$2$ 式表示，以 $j$ 为结尾的路径条数直接累加到 $g_i$ 中；

对于分数取模，考虑有 $998244353$ 为素数，直接用费马小定理求逆元即可。最后结果便是：
$\frac{\sum_{i=1}^n f_i}{\sum_{i=1}^n g_i}$.

坑点：开`long long`，注意 $m$ 的数据范围
## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N=100010,M=700010;
const int MOD=998244353;
int head[N],ver[M],nxt[M];
int f[N],g[N],deg[N];
int ans1,ans2,n,m,tot;

void addedge(int x,int y){
    ver[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
    deg[y]++;
}

void topsort(){
    queue<int> q;
    for(int i=1;i<=n;i++)
        if(deg[i]==0) q.push(i);

    while(!q.empty()){
        int x=q.front();q.pop();
        for(int i=head[x];i;i=nxt[i]){
            int y=ver[i];
            if(--deg[y]==0) q.push(y);
            (f[y]+=f[x]+g[x])%=MOD;
            (g[y]+=g[x])%=MOD;
        }
    }
}

int power(int a,int b){
    int res=1;
    for(;b;b>>=1){
        if(b&1) res=res*a%MOD;
        a=a*a%MOD;
    }
    return res%MOD;
}

int inv(int x){
    return power(x,MOD-2);
}

signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;

    for(int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        addedge(x,y);
    }

    for(int i=1;i<=n;i++) 
    	g[i]=1;
    
    topsort();
    
    for(int i=1;i<=n;i++) (ans1+=f[i])%=MOD;
    for(int i=1;i<=n;i++) (ans2+=g[i])%=MOD;

    cout<<(ans1*inv(ans2)+MOD)%MOD<<endl;
    return 0;
}
```

---

## 作者：YinyuDream (赞：0)

# 题意

给定一个有向无环图，等概率的选一条路径，求路径长度的期望。

# 题解

由期望的公式$E(x)=\sum_{i=1}^\infty i \times p(x=i)$，由于每一条路径出现的概率是相等的，设所有路径长度为$len$，路径条数为$cnt$，所以我们就可以得到路径长度的期望$E(x)=len/cnt$。那么，对于$len$和$cnt$的求法，我们可以使用拓扑排序。令$f_u$为到$u$的路径长度总和，$g_u$为到$u$的路径条数，对于任意一点$u$，考虑其入边，他能被入边上的另外一点$v$更新，到达$u$的路径条数为到达$v$的路径条数之和再加上1，到达$u$的路径的权值之和为到达$v$的路径权值之和+到达$v$的路径数量，具体地，$g_u=\sum g_v+1$，$f_u=\sum(f_v+g_v)$。这样，我们就可以求出答案了。对于取模运算，乘以其逆元即可。

# 代码

```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=1e6+10,p=998244353;
int n,m,k;
long long len,sum;
struct node{
	int to,next;
}edge[maxn];
int head[maxn],deg[maxn];
long long f[maxn],g[maxn];
void add(int u,int v)
{
	edge[++k].to=v;
	edge[k].next=head[u];
	head[u]=k;
}
queue<int>q;
long long qpow(long long a,long long b)
{
	if(b==0)return 1;
	long long c=qpow(a,b/2);
	c=c*c%p;
	if(b&1)c=c*a%p;
	return c;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		add(u,v);
		deg[v]++;
	}
	for(int i=1;i<=n;i++)
		if(!deg[i])
			q.push(i);
	while(q.size()){
		int u=q.front();
		q.pop();
		f[u]++;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].to;
			f[v]=(f[u]+f[v])%p;
			g[v]=(g[v]+g[u]+f[u])%p;
			deg[v]--;
			if(!deg[v])
			q.push(v);
		}
	}
	for(int i=1;i<=n;i++)
		len=(len+g[i])%p,sum=(sum+f[i])%p;
	printf("%lld",len*qpow(sum,p-2)%p);
	return 0;
}
```


---


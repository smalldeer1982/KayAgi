# [RC-03] 随机树生成器

## 题目描述

小 R 有一个随机树生成器，其工作原理如下：
- 输入 $n$，则对于每个 $1<i\le n$，随机选择一个 $[1,i)$ 中的节点作为其父亲。返回这棵树。

给定 $n,k$，小 R 想知道可能生成的所有 $n$ 个点的树中，$k$ 号点的度数和。

由于答案可能很大，请输出答案模 $10^9+9$ 的值。

## 说明/提示

【样例说明】

- 数据 $1$：一共有两种情况，$1$ 号点的度数分别为 $1,2$。因此答案为 $3$。
- 数据 $2$：一共有两种情况，$2$ 号点的度数分别为 $1,2$。因此答案为 $3$。
- 数据 $3$：一共有两种情况，$3$ 号点的度数均为 $1$。因此答案为 $2$。

【数据范围】

本题捆绑测试。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le k\le n\le 10^7$。详细数据范围如下。

- Subtask 1（20 分）：$T\le 50$，$n\le 8$。
- Subtask 2（55 分）：$T=1$，$n\le 10^5$。
- Subtask 3（20 分）：$T=1$。
- Subtask 4（5 分）：没有任何附加限制。

## 样例 #1

### 输入

```
3
3 1
3 2
3 3```

### 输出

```
3
3
2```

# 题解

## 作者：一只书虫仔 (赞：9)

#### Description

> 随机生成一棵 $n$ 个点的树，运行机制为对于点 $i$，在 $[1,i-1]$ 中随机挑选一个点 $j \in [1,i-1]$ 作为 $i$ 的父亲节点，概率均等，求所有可能生成的树中节点 $k$ 的度数之和。

#### Solution

对于点 $p$ 而言，他的度数分为两部分，一部分是父亲节点，贡献为 $1$，但是要注意节点 $1$ 没有父亲节点，要省掉；一部分是儿子节点，对于每个点 $p' \in [p+1,n]$，都有可能在 $[1,p'-1]$ 中随机挑选一个点作为他的父亲，而选中是点 $p$ 的概率即为 $\frac 1 {p'-1}$。而节点为 $n$ 的树一共有 $\displaystyle \prod\limits_{i=1}^{n-1}i$ 种，故答案应为：

$$\displaystyle \prod\limits_{i=1}^{n-1}i \times \sum\limits_{p'=p+1}^n \frac 1 {p'-1}+[p\ne 1] \times \displaystyle \prod\limits_{i=1}^{n-1}i$$

具体实现细节用逆元就可以了，预处理逆元和阶乘然后求一下前缀和即可。

---

## 作者：Mine_King (赞：3)

[在我的博客获得更好的阅读体验](https://www.cnblogs.com/mk-oi/p/15111721.html)

## Problem

[洛谷P6862 [RC-03] 随机树生成器](https://www.luogu.com.cn/problem/P6862)

**题目大意：**

有 $T$ 组数据。  
有一个随机树生成器，对于给定的 $n$，会生成一棵 $n$ 个点的有根树。其中，第 $i$ 个点（$1 < i$）等概率选取 $[1,i)$ 中的某个点作为父亲。给定 $n,k$，问所有可能生成的树中，$k$ 号点的度数之和。

## Solution

我们首先考虑一共能生成几棵树。显然，对于第 $i$​ 个点（$i>1$），他能选择 $i-1$​ 个父亲。根据乘法原理，一共 $n$​ 个点，所以能生成的树的个数为：

$$
\prod\limits_{i=2}^n i-1 = \prod\limits_{i=1}^{n-1} i
$$
对于每棵树，若 $k \not= 1$，那么他将有一个父亲贡献 $1$ 的度。并且对于每个 $k < i \le n$，他们都有 $\dfrac{1}{i-1}$ 的概率选择 $k$ 做为父亲贡献 $1$ 的度。  
所以对于给定的 $n,k$，答案为：
$$\prod\limits_{i=1}^{n-1} i \times \sum\limits_{i=k+1}^n \dfrac{1}{i-1} + [k \not= 1] \times \prod\limits_{i=1}^{n-1} i$$  
$$= \prod\limits_{i=1}^{n-1} i \times \sum\limits_{i=k}^{n-1} \dfrac{1}{i} + [k \not= 1] \times \prod\limits_{i=1}^{n-1} i$$
观察到 $T \times n$​​ 很大，所以我们要预处理出逆元的前缀和与阶乘。然后就可以 $O(1)$ 回答询问了。

## Code

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int mod=1e9+9;
int T,n,k,fac[10000005],inv[10000005];
int main()
{
	fac[0]=1;
	for(int i=1;i<=1e7;i++) fac[i]=1ll*fac[i-1]*i%mod;
	inv[1]=1;
	for(int i=2;i<=1e7;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(int i=1;i<=1e7;i++) inv[i]=(inv[i-1]+inv[i])%mod;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&k);
		int ee=(inv[n-1]-inv[k-1]+mod)%mod;
		printf("%lld\n",(1ll*fac[n-1]*ee%mod+(k!=1)*fac[n-1])%mod);
	}
	return 0;
}
```

---

## 作者：Little09 (赞：3)

首先我们知道，树的形态总共是 $(n-1)!$ 种。

考察在第 $i$ 个点时，第 $j$ $(j>i)$ 个点对第 $i$ 个点的贡献，显然第 $j$ 个点有 $\dfrac{1}{j-1}$ 的概率选择第 $i$ 个点作为父亲，所以第 $i$ $(i>1)$ 个点的度数和是：

$$(n-1)!\times(\sum_{j=i+1}^{n}\dfrac{1}{j-1}+1)$$

上式的 $+1$ 是由于要加上父亲节点的度。需要注意，对于 $1$ 号节点而言，它没有父亲节点，所以不用加那个 $1$。


然后发现可以线性预处理逆元，然后求前缀和，再预处理阶乘，就可以 $O(n)$ 预处理，$O(1)$ 求每个询问的答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll p=1000000009;
const ll N=10000000;
ll inv[10000006],jc[10000006];
int T;
int main()
{
	inv[1]=1;
	for (int i=2;i<=N;i++)
	{
		inv[i]=((p-p/i)*inv[p%i])%p;
	}
	for (int i=2;i<=N;i++)
	{
		inv[i]=(inv[i-1]+inv[i])%p;
	}
	jc[1]=1;
	for (ll i=2;i<=N;i++)
	{
		jc[i]=(jc[i-1]*i)%p;
	}
	cin >> T;
	while (T--)
	{
		ll n,k;
		cin >> n >> k;
		ll u;
		if (k!=1) u=(inv[n-1]-inv[k-1]+p+1)%p;
		else u=(inv[n-1]-inv[k-1]+p)%p;
		u=(u*jc[n-1])%p;
		printf("%lld\n",u);
	}
	return 0;
}
```


---

## 作者：LittleMoMol (赞：2)

## 前言

模数要模 $10^9+9$！！模数要模 $10^9+9$！！模数要模 $10^9+9$！！

[欢迎博客食用](https://www.cnblogs.com/LittleMoMol-kawayi/p/solution_LuoGu_P6862.html)

## 结论

$n$ 个点的树的形态有 $(n-1)!$ 个，对于节点 $k$，它的所有度数和为 $(n-1)!\left(\sum\limits_{j=k+1}^n \dfrac{1}{j-1} + [k \not= 1] \right)$

## 理论基础

### 树的形态

我们先说为什么 $n$ 个点的树的形态有 $(n-1)!$ 种。

对于第 $1$ 个点，加入后只有 $1$ 种形态，且它是根节点，这是显然的。

对于第 $2$ 个点，只能认 $1$ 这个节点为爹，所以只有 $1$ 种形态。

对于第 $3$ 个点，能认的爹有 $1$ 或者 $2$，所以总共有 $2$ 种形态。

对于第 $4$ 个点，对于之前两种形态的每一种，能认的爹有 $1$ 或 $2$ 或 $3$，所以总共有 $2 \times 3$ 种形态。

我相信到这里你已经发现了其中的规律了！

对于第 $i$ 个点，加入后树总共有 $(i-1)!$ 种。

所以 $n$ 个点的树的形态有 $(n-1)!$ 种。

### 度数和

再来看为什么答案是 $(n-1)!\left(\sum\limits_{j=k+1}^n \dfrac{1}{j-1} + [k\not= 1] \right)$

我们将这个式子拆成两部分：$(n-1)! \sum\limits_{j=k+1}^n \dfrac{1}{j-1}$ 和 $(n-1)! [k \not= 1]$

我们先看较为简单的第二部分，度数=父亲节点数量+儿子节点数量，因为这是一棵树，所以每个**非根节点**有且只有一个父亲，**根节点**没有父亲，这就是公式第二部分的由来。

对于第一部分，对于每个点 $k'\ (k < k' \le n)$，它会在 $1 \sim k'-1$ 中任意挑选一个爹，所以挑到点 $k$ 当爹的概率自然是 $\dfrac{1}{k'-1}$。

## 细节处理

观察公式发现我们需要快速求出阶乘，这个很简单；还要快速求出逆元，这个用快速幂的话就超时了，所以用线性求逆元，不懂线性求逆元的可以[戳我](https://oi-wiki.org/math/number-theory/inverse/)。

## Code

```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

const int N = 1e7 + 31;
const LL mod = 1e9 + 9;

int T, n, k;
LL inv[N], jc[N];

void init()
{
	inv[1] = 1;
	for (int i = 2; i < N; i ++ )
		inv[i] = (mod - mod / i) * inv[mod % i] % mod;
	for (int i = 2; i < N; i ++ ) inv[i] = (inv[i] + inv[i - 1]) % mod;
	jc[1] = 1;
	for (int i = 2; i < N; i ++ ) jc[i] = i * jc[i - 1] % mod;
	return;
}

int main()
{
	cin >> T;
	init();
	while (T -- )
	{
		cin >> n >> k;
		LL ans;
		if (k == 1) ans = (inv[n - 1] - inv[k - 1] + mod) % mod;
		else ans = (inv[n - 1] - inv[k - 1] + 1 + mod) % mod;
		ans = (ans * jc[n - 1]) % mod;
		cout << ans << endl;
	}
}
```

## 后语

~~概率/期望是真难，一天就做了俩绿题……~~

完结撒花，收~

---

## 作者：Fairicle (赞：1)

**update on 10.27** 感谢评论区大佬指出错误，先已修正并放出该做法的 75pts 代码


这种题目可以等价于求期望，因此有两种做法，一种是直接求所有方案的总和，一种是先求期望再乘上树的形态数。

不妨尝试第一种，设 $f(n)$ 表示节点数为 $n$ 时的总度数。

那么有

$$f(k)=\begin{cases}(k-1)!&k>1\\0&k=1\end{cases}\ f(n)=(n-1)f(n-1)+(n-2)!(n>k)$$

通项难求，难以预处理，最多只能做到 $95pts$ （如果能做请 D 爆这个菜鸡）

$T=1$ 的 75pts 代码：
```cpp
cin>>n>>k;
    if(n==1){cout<<0<<endl;return 0;}
    fac[0]=fac[1]=1;
    for(ri i=2;i<=n;++i) fac[i]=1ll*i*fac[i-1]%mod;
    if(k>1)
    f[k]=fac[k-1];else f[k]=0;
    for(ri i=k+1;i<=n;++i) f[i]=(1ll*(i-1)*f[i-1]+fac[i-2])%mod;
    cout<<f[n]<<endl;
```


那就考虑第二种，发现当节点数为 $v(v>=k)$时，加入一个节点对期望的贡献就是 $\dfrac{1}{v}$

那么容易求出总期望为 $1+\sum_{i=k}^{n-1}\dfrac{1}{i}$

树的形态有 $(n-1)!$ 种，乘上它就行了。

线性预处理逆元，阶乘和逆元前缀和，就能做到 $O(n)$ 预处理，$O(1)$ 查询。

记得特判 $n=1$ 。

code：
```cpp
#include"bits/stdc++.h"
using namespace std;
#define N 10000010
#define ri register int
#define ll long long
#define mod 1000000009
ll inv[N],fac[N],t,n,k;
inline void init(){
	inv[0]=inv[1]=fac[0]=fac[1]=1;
	for(ri i=2;i<=N-10;++i) fac[i]=1ll*i*fac[i-1]%mod,inv[i]=(mod-(mod/i))*inv[mod%i]%mod;
}
int main(){
	init();
	for(ri i=2;i<=N-10;++i) inv[i]=(inv[i]+inv[i-1])%mod;
	cin>>t;
	while(t--){
		cin>>n>>k;
		if(n==1) cout<<0<<endl;
		else cout<<(1ll+inv[n-1]-inv[k-1]+mod)%mod*fac[n-1]%mod<<endl;
	}
	return 0;
}
```


---

## 作者：JYX0924 (赞：0)

当考虑到第 $i$ 个点时，它的父亲有 $i-1$ 种情况。因此，生成的树共有 $(n-1)!$ 种情况。考虑到点 $k$ 的度数包含它的父亲结点的个数，即 $(n-1)!$，以及它的儿子结点的个数。对于每一个结点 $j > k$，$j$ 是 $k$ 的儿子的概率都是 $\frac{1}{j-1}$，总概率 $\sum_{j=k+1}^{n} \frac{1}{j-1}$，即 $\sum_{j=k}^{n-1} \frac{1}{j}$。因此，期望就是 $(n-1)!+(n-1)! \times \sum_{j=k}^{n-1} \frac{1}{j}$。注意，$k=1$ 是没有父亲结点，而且要预处理逆元数组并求前缀和。

下面是我的代码。


```cpp
#include<bits/stdc++.h>
#define ll long long 
#define maxn 10000005 
#define mod 1000000009 
using namespace std;
ll T,n,k,sum[maxn],jie[maxn],inv[maxn],num[maxn],tot;
bool vis[maxn];
ll cal(ll x,ll y)
{
	ll ret=1,tt=x;
	while(y)
	{
		if(y&1) ret*=tt,ret%=mod;
		y>>=1; tt*=tt; tt%=mod;
	}
	return ret;
}
void init()
{
	for(int i=2;i<maxn;i++)
	{
		if(!vis[i]) num[++tot]=i,inv[i]=cal(i,mod-2);
		for(int j=1;j<=tot&&i*num[j]<maxn;j++)
		{
			vis[i*num[j]]=1; inv[i*num[j]]=inv[i]*inv[num[j]]%mod;
			if(!(i%num[j])) break;
		}
	}
	sum[1]=1; for(int i=2;i<maxn;i++) sum[i]=sum[i-1]+inv[i],sum[i]%=mod;
	jie[0]=1; for(ll i=1;i<maxn;i++) jie[i]=jie[i-1]*i%mod;
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>T; init();
	while(T--)
	{
		cin>>n>>k; cout<<(jie[n-1]*(sum[n-1]-sum[k-1]+mod)%mod+(k!=1)*jie[n-1]%mod)%mod<<"\n";
	}
	return 0;
}
```
谢谢大家！！！

---

## 作者：wizard（偷开O2 (赞：0)

一道树的性质和组合数学结合的好题。

### 题意

有一个数列，对于数列中的点 $i \in (1,n]$，随机选一个 $j \in [1,i)$ 作为自己的父亲。构建好一个含有 $n$ 个节点的树后，求树上节点 $k$ 的度数之和。

### 分析

构建好一个含有 $n$ 个节点的树后，我们发现对于一个节点，他的父亲以及祖先序号必定比它本身小，所以对于当前节点 $i$，他能选择的父亲只有 $i-1$ 个，特殊的，一号节点没有父亲。所以对于 $n$ 个点，每个点都能找到 $n-1$ 个父亲，所以能生成树的个数就是 $(n-1)!$。

我们拿单个节点分析，发现除了 $1$ 节点之外，每个节点都有父亲，所有每个节点的父亲都能给予该节点一个贡献，当我们的答案节点 $k$ 为父亲时，他的儿子节点必定序号小于它，所以对于 $x \in (k,n]$，每个节点都有 $\frac{1}{x-1}$ 的概率为 $k$ 的儿子，所以就有 $\frac{1}{x-1}$ 的概率选择 $k$ 为父亲且给予 $k$ 一个贡献。

对于所有的生成树的点，也就是所有能生成的生成树个数，有:

$$(n-1)! \times \sum\limits_{i=k+1}^{n}\frac{1}{i-1}+[k \neq 1] \times (n-1)!$$

逆元算出来直接求就行了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ls ((now<<1))
#define rs ((now<<1)|1)
#define mid ((l+r)>>1)
const int maxn=1e7+10;
const int inf=1e9;
const int maxa=2e3+10;
const int modd=1e9+9;
int f[maxn],inv[maxn];
void init(){
	f[0]=f[1]=1;
	for(int i=1;i<=maxn;i++){
		f[i]=f[i-1]*i%modd;
	}
	inv[0]=inv[1]=1;
	for(int i=2;i<=maxn;i++){
		inv[i]=(modd-modd/i)*inv[modd%i]%modd;
	}
	for(int i=1;i<=maxn;i++){
		inv[i]=(inv[i-1]+inv[i])%modd;//前缀和 
	}
}
signed main(){
	int t;
	cin >> t;
	init();
//	for(int i=1;i<=15;i++){
//		cout << inv[i] << " ";
//	}
	while(t--){
		int n,k;
		cin >> n>> k;
		int dex=0;
		dex=(inv[n-1]-inv[k-1]+modd)%modd;//k~n-1
		cout << (f[n-1]*dex%modd+(k!=1)*f[n-1])%modd << endl;
	}

	return 0;
}
```

---

## 作者：luxiaomao (赞：0)

## [P6862](https://www.luogu.com.cn/problem/P6862) 数学题

刚好最近在学概率和期望，这篇题解就当学习笔记罢。

## Solution

先看题意：

> 给出正整数 $n$，则对于节点 $i\in\{2,3,\dots,n\}$，随机选择一个 $\{1,2,\dots,i-1\}$ 中的节点作为其父亲，得到一棵树。
>
> 输入 $n,k$，求出所有可能生成的树中，$k$ 号点的度数和。
>
> 答案对 $10^9+9$ 取模。

让我们考虑一个问题：“所有可能生成的树”有多少种情况呢？

首先，这棵树生成的模式是把一个节点放在另一个节点的下面作为儿子。那么节点 $1$ 就是根节点，节点 $2$ 就是根节点的儿子，到这里都只有一种情况。

节点 $3$ 可以选择节点 $1$ 或 $2$ 作为父亲，有两种可能。节点 $4$ 又可以把原来三个节点的树分成三种可能……

这是一个可以叠加的过程，总情况数量为：

$$\prod\limits_{i=2}^ni-1 = \prod\limits_{i=1}^{n-1}i=(i-1)!$$

---

度数就是父亲的数量（如果有）再加上孩子的数量。

对于一棵树，如果是根节点就没有父亲，否则就有一个父亲，再乘上总情况数即可。

那儿子呢？

我们注意到，可能成为 $k$ 的儿子的节点有 $\{k+1,k+2,\dots,n\}$，其中对于节点 $i(k<i\le n)$，它有 $i-1$ 个父亲可以选择，那么它选中 $k$ 的概率是 $\dfrac{1}{i-1}$。

把这些孩子选中的概率都累加起来，再乘上总情况数（别忘了这个），就是：

$$(i-1)!\times\sum\limits_{i=k+1}^n\dfrac{1}{i-1}$$

再把刚才说的父亲加上，我们就得到了最终答案：

$$(i-1)!\times(\sum\limits_{i=k+1}^n\dfrac{1}{i-1})+(i-1)!\times[k\not=1]$$

---

别急嘛，这还没完呢。 $n \le 10^7$ 的数据范围而且还是多测，你确定这不超时？

我们先记 $mul_i = i!$，然后再记 $inv_i$ 为 $i$ 在模 $10^9+9$ 下的逆元，这两个东西都是可以 $O(n)$ 预处理出来的。

那么式子变成：

$$mul_{i-1}\times(\sum\limits_{i=k+1}^ninv_{i-1})+mul_{i-1}\times[k\not=1]$$

怎么还有一个求和 qwq！那就来个前缀和，记 $sum_i=\sum\limits_{j=1}^iinv_j$ 罢，这个同样是可以 $O(n)$ 处理的。

那么就是：

$$mul_{i-1}\times(sum_{n-1}-sum_{k-1})+mul_{i-1}\times[k\not=1]$$

别忘了 $sum$ 是取过模的，这样算出来的区间逆元和可能是负数，我们给它加上模数再取一次模，就得到了最终的式子：

$$mul_{i-1}\times(sum_{n-1}-sum_{k-1}+(10^9+9))\bmod (10^9+9)+mul_{i-1}\times[k\not=1]$$

## Code Time

说了这么多，代码时间到。

```
#include<bits/stdc++.h>
#define N 10000005
#define mod 1000000009
#define int long long
using namespace std;

int T,n,k;
int inv[N],sum[N],mul[N];

void init()
{
	inv[1] = sum[1] = 1;
	for(int i = 2;i <= 10000000;i++)
	{
		inv[i] = (mod-mod/i)*inv[mod%i]%mod;
		sum[i] = (sum[i-1]+inv[i])%mod;
	}
	mul[0] = mul[1] = 1;
	for(int i = 2;i <= 10000000;i++)mul[i] = mul[i-1]*i%mod;
	return;
}

signed main()
{
	init();
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld",&n,&k);
		printf("%lld\n",((k!=1)*mul[n-1]+(sum[n-1]-sum[k-1]+mod)%mod*mul[n-1])%mod);
	}
	return 0;
}
```

虽然码量不大，但是思维难度还不错。

感谢阅读~QAQ

---

## 作者：yangzichen1203 (赞：0)

# Problem

[P6862 [RC-03] 随机树生成器](https://www.luogu.com.cn/problem/P6862)

# Solution

首先我们可以求出树的个数。由于第$i$个节点有 $(i-1)$ 个父节点可选，根据乘法原理可得，总共有 $(n-1)!$ 棵树。

显然，一个节点，都会对其父节点做出$1$的贡献（ $k=1$ 除外），且对k号节点做出$1$的贡献的概率为 $\dfrac{1}{i-1}$。

那么我们就可以得出答案。

$k\ne1$ 时（加上父节点的贡献）：

$(n-1)! \times (\sum\limits_{i=k+1}^n \dfrac{1}{i-1}+1)$

$k=1$ 时（$1$号节点没有父节点）：

$(n-1)! \times (\sum\limits_{i=k+1}^n \dfrac{1}{i-1})$

那我们怎么实现呢？求逆元时如果一个一个的去算的话就会 TLE($O(n\log(n))$，所以我们可以用 $O(n)$ 的算法预处理出 $1\sim10^7$ 内各数在模 $10^9+9$ 意义下的逆元，详见[P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)。在计算阶乘时也进行预处理。注意数据会爆 int，所以每次操作时要强制转换为 long long（或者数组开成     long long）。预处理完后，就可以对于每一次询问 $O(1)$ 输出答案。

# Code

话不多说，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 10000005
#define mod 1000000009
//注意数据范围
int fac[MAXN],inv[MAXN];
//fac[i]表示i的阶乘，inv[i]表示i在模mod的意义下的逆元
int f[MAXN];//f[i]表示inv的前缀和
void init(){
	fac[0]=1;//0的阶乘是1
	for(int i=1;i<=1e7;i++) fac[i]=(long long)fac[i-1]*i%mod;
	//注意可能会爆int，所以要强制转化为long long
	inv[1]=1;
	for(int i=2;i<=1e7;i++) inv[i]=(long long)(mod-mod/i)*inv[mod%i]%mod;
	//同上，参考P3811【模板】乘法，逆元O(n)求出每个数的逆元
	for(int i=1;i<=1e7;i++) inv[i]=(inv[i-1]+inv[i])%mod;
	//求前缀和，没啥好说的，记得模mod
}
int main(){
    init();//初始化
    int t;
    cin>>t;
	while(t--){//省事
		int n,k;
		cin>>n>>k;
		int t=(inv[n-1]-inv[k-1]+mod)%mod;//注意可能减成负数，会出错
		if(k!=1) t=(t+1)%mod;
		cout<<(long long)t*fac[n-1]%mod<<endl;//cout稍慢，建议开O2
	}
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/123337186)

完结撒花，第一次写题解，求管理员通过。

---

## 作者：HPXXZYY (赞：0)


$\color{blue}{\texttt{[Solution]}}$

首先，让我们先算出一共有多少种可能的树。

我们把一般的父亲找儿子的建树过程反过来，即儿子找父亲，这两种方法是一样的，因为当每个节点都确定了自己的父亲是谁的时候，这棵树就建好了。

第 $1$ 个点一定是根，只有 $1$ 种选择；对于第 $i$ 个点（$2 \leq i \leq n$）而言，节点 $[1,i)$ 都可以是它父亲，有 $(i-1)$ 种选择，故不同的树的数量为：

$$\left (\prod\limits_{i=2}^{n} (i-1)\right ) \times 1 =(n-1)!$$

然后，让我们考虑答案是多少。

对于节点 $i$ 而言（$1 \leq i \leq n$），节点 $(i,n]$ 都可能成为它的儿子。特别地，节点 $j(j \in (i,n])$ 有 $\dfrac{1}{j-1}$ 的概率成为 $i$ 的儿子。所以它对节点的度的总和的贡献即为：

$$(n-1)! \times \dfrac{1}{j-1}$$

所以答案为：

$$(n-1)! \times \left ( \left ( \sum \limits_{j=i+1}^{n} \dfrac{1}{j-1} \right ) +1\right )$$

那个 $+1$ 是因为还有一条从 $i$ 的父亲到 $i$ 的边。当然对于节点 $1$ 而言就不需要 $+1$。

因为有多组数据和取模，所以我们预处理出在取模意义下的 $(n-1)!$ 和逆元的前缀和，就可以 $O(1)$ 地回答每个询问了。

总的时间复杂度：$O(\max \{n\}+T)$。

**千万注意不是对 $\left (1 \times 10^9+7\right )$ 而是对 $\left (1 \times 10^9+9\right )$ 取模！**


$\color{blue}{\texttt{[code]}}$

```cpp
const int N=1e7+100;
const int mod=1e9+9;
inline int ksm(int a,int b){
	register int ret=1;
	while (b){
		if (b&1) ret=1ll*ret*a%mod;
		a=1ll*a*a%mod;b>>=1;
	}
	return ret;
}
int inv[N],fac[N],pre[N];
inline void InitImportantArray(int n){
	fac[0]=inv[1]=1;pre[1]=0;
	for(int i=1;i<=n;i++){
		fac[i]=1ll*fac[i-1]*i%mod;
		if (i>1) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	}
	for(int i=2;i<=n;i++)
		pre[i]=(pre[i-1]+inv[i-1])%mod;
}
int main(){
	InitImportantArray(1e7);
	for(int t=1,T=read();t<=T;t++){
		register int n=read(),k=read();
		if (k==1) printf("%lld\n",1ll*fac[n-1]*(pre[n]-pre[k]+mod)%mod);
		else printf("%lld\n",1ll*fac[n-1]*(pre[n]-pre[k]+1+mod)%mod);
	}
	return 0;
}
```

---


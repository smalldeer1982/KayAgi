# 「SWTR-7」IOI 2077

## 题目背景

#### 友情提醒：本题输入输出量很大，请不要使用 cin 或 scanf。题目最下方附有快读及其使用方法。

#### 赛时提醒：若对于选出的 $m$ 无解，则期望值为 $0$。可以结合样例 2 的解释说明以更好理解。

#### 赛时提醒：你需要求的是能力值之和的期望而不是最大值。

---

小 A 被 FCC 钦定参加 IOI 2077！71 岁老将请求出战！

## 题目描述

IOI 2077 有 $n$ 位**候选**参赛者，他们分别编号为 $1\sim n$。每位候选参赛者都有一个能力值，且**能力值互不相等**，第 $i$ 位候选参赛者的能力值为 $a_i$。小 A 更喜欢有序的数字，所以他将这 $n$ 位候选参赛者按照能力值**从小到大**排好了序，即**满足 $a_i<a_{i+1}\ (1\leq i<n)$。**

正式参赛者将会从这 $n$ 位候选参赛者中产生。具体地，所有参赛者将是候选参赛者的一个子串 $[l,r]$，即编号为 $l,l+1,\cdots,r$ 的选手将参加 IOI 2077，其中，小 A 的编号为 $k$。因为他知道自己被钦定参加 IOI 2077，所以 $l\leq k\leq r$。可能的参赛者一共有 $q$ 种情况，每种情况用三个数 $l_i,r_i,k_i\ (l_i\leq k_i\leq r_i)$ 描述，即参赛者为编号在区间 $[l_i,r_i]$ 中的候选参赛者，而小 A 的编号为 $k_i$。

由于自己太菜，小 A 对即将到来的 IOI 感到力不从心。他决定选择一些参赛者作为队友，并与他们在赛场上相互帮（zuo）助（bi）。具体地，设正式参赛人数为 $s$，那么小 A 会在 $[0,\lfloor\frac{s-1}{2}\rfloor]$ 中**等概率随机**选择一个数 $m$，并从 $s$ 位参赛者中**随机**选出 $2m$ 个作为他的队友。不过，小 A 不希望自己显得太菜，所以**他的能力值 $a_k$ 必须是这 $2m+1$ 个人的能力值的中位数**。

俗话说，人多力量大，小 A 希望他与所有选出的队友的能力值之和尽量地大。**不过在此之前，他想知道这个值的期望值是多少**。请对 $998244353$ 取模，保证答案在该模数下有意义。**对于每一种可能的参赛者情况，你都需计算该情况下的答案。为了避免过大的输出，你只需要计算所有答案的异或和。**

## 说明/提示

**「样例 1 说明」**

- 第 1 个询问：  
  因为 $s_1=r_1-l_1+1=5$，所以 $m$ 可以为 $0,1$ 或 $2$。  
  $m=0$ 时：小 A 没有队友，那么期望值就是他自身的能力值 $a_{k_1}=a_3=5$。    
  $m=1$ 时：小 A 可以选**编号** $(1, 4)$ 或 $(1, 5)$ 或 $(2, 4)$ 或 $(2, 5)$ 的参赛者作为他的队友，能力值之和分别为 $14,15,15,16$，期望值为 $\frac{14+15+15+16}{4}=15$。    
  $m=2$ 时：小 A 只能全选，期望值为 $2+3+5+7+8=25$。  
	综上，期望值为 $\frac{5+15+25}{3}=15$。

- 第 2 个询问：  
  因为 $s_2=r_2-l_2+1=3$，所以 $m$ 可以为 $0$ 或 $1$。  
  $m=0$ 时，小 A 没有队友，期望值为 $3$。    
  $m=1$ 时，小 A 无法选择，期望值为 $0$。  
  综上，期望值为 $\frac{3+0}{2}=\frac{3}{2}$，对 $998244353$ 取模后为 $499122178$。
  
$15\oplus499122178=499122189$。

**「数据范围与约定」**

**本题采用捆绑测试。**

记 $s_i=r_i-l_i+1$。

- Subtask #0（1 point）：是样例。
- Subtask #1（10 points）：$s_i\leq 2$。
- Subtask #2（20 points）：$s_i\leq 16$，$q\leq 40$，$n\leq 640$。
- Subtask #3（15 points）：$s_i,q\leq 500$，$n\leq 10^5$。
- Subtask #4（15 points）：$s_i,q\leq 3\times 10^3$，$n\leq 10^5$。
- Subtask #5（15 points）：$s_i,q\leq 2\times 10^5$，$n\leq 5\times 10^5$。
- Subtask #6（24 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,q\leq 2\times 10^6$，$1\leq l_i\leq k_i\leq r_i\leq n$，$1 \le a_i \le 998244352$，$a_i<a_{i+1}\ (1\leq i<n)$。

对于所有测试点，时间限制 1s，空间限制 512MB。

**「帮助/提示」**

关于 [有理数取余](https://www.luogu.com.cn/problem/P2613)，[中位数](https://baike.baidu.com/item/%E4%B8%AD%E4%BD%8D%E6%95%B0/3087401?fr=aladdin)。

本题输入输出量**极大**，**请注意 I/O 优化。**  
本题提供**有符号 32 位整数**快读模板，保证读入用时不超过 250ms：

```cpp
#define gc getchar()
inline int read(){
	int x=0; bool sgn=0; char s=gc;
	while(!isdigit(s))sgn|=s=='-',s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+(s-'0'),s=gc;
	return sgn?-x:x;
}

// 如果需要读入直接调用 read() 即可。
// 一个例子（与正解无关，仅供参考）：

int t=read(),n=read(),q=read();
int a[2000005],l[2000005],r[2000005],k[2000005];
for(int i=1;i<=n;i++)a[i]=read();
for(int i=1;i<=q;i++)l[i]=read(),r[i]=read(),k[i]=read();

// 这样你就可以在 250ms 内读入全部数据了。
```

**「题目来源」**

[Sweet Round 07](https://www.luogu.com.cn/contest/51773) C。  
idea & solution：[SSerWarriors_Cat](https://www.luogu.com.cn/user/147999)；data：[Alex_Wei](https://www.luogu.com.cn/user/123294) ；验题：[chenxia25](https://www.luogu.com.cn/user/138400)。

---

IOI 2077 落下帷幕，小 A 凭借出（dui）色（you）的发（bang）挥（zhu）成功 AK 了 IOI，这不禁让他回想起曾经满腔热血的自己，以及和他共同奋斗在 OI 路上的战友们。如今他们虽已天各一方，说起来也有十几年没见过面了，但他们真挚的友谊未曾淡去，也将永远不会褪色。

>*“爷爷，您手机里有段录音，还写着 'ycx txdy!'。”*  
>*“哦，是嘛？放出来听听。”*  
>>*“I AK IOI. I AK ACM World Final. I AK Universe OI. I think all of you are vegetable chickens.”*  
>>*“I AK IOI. I AK ACM World Final. I AK Universe OI. I think all of you are vegetable chickens.”*  
>>*“I AK IOI. I AK ACM World Final. I AK Universe OI. I think all of you ............”*

2077.7.7

## 样例 #1

### 输入

```
0
5 2
2 3 5 7 8
1 5 3
2 4 2
```

### 输出

```
499122189```

# 题解

## 作者：dingcx (赞：12)

这是一道数学题。

## 思路

参赛者满足 能力值 $\le$ 小 A 的人数 等于 能力值 $\ge$ 小 A 的人数，即在 $l$ ~ $k-1$ 中选的人数 等于 在 $k+1$ ~ $r$ 中选的人数。

**枚举**这个相等的**人数**，计算此时的期望：

$0$ 人：期望值为 $a_k$（就这一种）

$1$ 人：通过计算每个人被选中的概率乘以每个人的能力值得到答案。在 $l$ ~ $k-1$ 中每个人被选中的概率是 $\frac{1}{k-l}$，在 $k+1$ ~ $r$ 中每个人被选中的概率是 $\frac{1}{r-k}$。于是能力期望值为 $\frac{a_l+...+a_{k-1}}{k-l}+\frac{a_{k+1}+...+a_r}{r-k}+a_k$，可用前缀和优化（$s$ 为前缀和数组）：

$$\frac{s_{k-1}-s_{l-1}}{k-l}+\frac{s_r-s_k}{r-k}+a_k$$

$2$ 人：在 $l$ ~ $k-1$ 中每个人被选中的概率是 $\frac{2}{k-l}$，在 $k+1$ ~ $r$ 中每个人被选中的概率是 $\frac{2}{r-k}$。于是能力期望值为 

$$2\times\frac{s_{k-1}-s_{l-1}}{k-l}+2\times\frac{s_r-s_k}{r-k}+a_k$$

$\cdots\cdots$

$\min(k-l,r-k)$（记作 $mi$）人，能力期望值为 

$$mi\times\frac{s_{k-1}-s_{l-1}}{k-l}+mi\times\frac{s_r-s_k}{r-k}+a_k$$

$mi+1$ 人：能力期望值为 $0$。

$\cdots\cdots$

$\lfloor \frac{r-l}{2} \rfloor$ 人：能力期望值为 $0$。

于是，总的能力期望值：

$$\frac{(mi+1)\times a_k+(1+...+mi)\times \frac{s_{k-1}-s_{l-1}}{k-l}+(1+...+mi)\times\frac{s_r-s_k}{r-k}}{\lfloor \frac{r-l}{2} \rfloor}$$

也就是

$$\frac{(mi+1)\times a_k+\frac{\normalsize mi*(mi+1)}{\normalsize 2}\times (\frac{\normalsize s_{k-1}-\normalsize s_{l-1}}{\normalsize k-l}+\frac{\normalsize s_r-s_k}{\normalsize r-k})}{\lfloor \frac{\normalsize r-l}{\normalsize 2} \rfloor}$$

接下来考虑怎么有理数取余，也就是 [这道题](https://www.luogu.com.cn/problem/P2613)。

注意**不能**先上下通分，把答案的分子分母算出来，然后取余。这样不仅要考虑各种细节，还会超时。（~~我就是因为这样做而没有在赛时做出这道题~~）

正确的做法是先**预处理** $2\times10^6$ 内每个数关于 $998244353$ 的**逆元**，存到一个数组上（记作 $inv$），这样就把除转换成乘了。

还有一个**细节**，就是如果预处理前缀和数组的时候取模了，那前缀和的差可能会 $<0$。因此要么预处理时不取模，要么在计算答案时 $+mod$。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
const int MAXN=2e6+10,MOD=998244353;
ll a[MAXN],s[MAXN],inv[MAXN];
int read(){
	int num=0,sign=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<1)+(num<<3)+ch-'0';ch=getchar();}
	return num*sign;
}
int main(){
	int type=read(),n=read(),m=read(),ans=0;
	for(int i=1;i<=n;i++)
   		a[i]=read(),s[i]=(s[i-1]+a[i])%MOD; //算前缀和
	inv[1]=1; //预处理逆元数组
    for(int i=2;i<=2e6;i++)
        inv[i]=(MOD-(MOD/i*inv[MOD%i]%MOD))%MOD;
	while(m--){
		ll l=read(),r=read(),k=read();
		ll mi=min(k-l,r-k),res;
		res=((mi+1)*a[k]%MOD+((mi*(mi+1)/2)%MOD)*(((s[k-1]-s[l-1]+MOD)*inv[k-l]%MOD+(s[r]-s[k]+MOD)*inv[r-k]%MOD)%MOD)%MOD)%MOD;
		ans^=(res*inv[(r-l)/2+1]%MOD);
      		//套公式
	}
	printf("%d\n",ans);
	return 0; //华丽结束
}
```
求点赞~

---

## 作者：二gou子 (赞：8)

一开始以为是个组合数神题，~~后来发现是个申必等差数列~~。

## Sol

一开始看到期望吓了一跳，因为我期望实在菜得要死。最后才发现是期望救我一命。

首先我们注意到题目给出的序列已经按照升序排列了，这为我们统计答案提供了便利，~~一开始我眼瞎没看到这条件还搁那想可持久化线段树呢~~。

然后我们考虑如何统计答案，先想暴力怎么做。很显然，我们要先枚举 $m$ ，接着就会遇到一个问题：给定 $n$ 个数，选出 $m$ 个元素，所有情况的元素和是多少。这样来思考：对于每一个元素，选它的情况个数都是相等的。所以我们可以算出所有情况，也就是 $C_n^m$ ，每一次选了 $m$ 个数，再平均到 $n$ 个数里，就相当于每个数都被选了 $\frac{C_n^m*m}{n}$ 次，再乘上这些元素的和，就是这个问题的答案了。

设区间内小于中位数的数的个数是 $cnt1$ ，它们的和是 $sum1$ 。大于中位数的个数是 $cnt2$ ，它们的和是 $sum2$ 。假设当前枚举到了 $i$ （也就是选了 $2i+1$ 个人），左边（也就是小于中位数的那些数）选出一种方案，右边对这一种情况的贡献就是刚刚我们解决的那个问题的答案，即 $\frac{C_{cnt2}^i*i}{cnt2}*sum2$ ，又因为左边一共有 $C_{cnt1}^i$ 种方案，所以右边的数对和的总贡献就是 $C_{cnt1}^i*\frac{C_{cnt2}^i*i}{cnt2}*sum2$，同理可以得到左边对和的总贡献，再加上中间那个 $a[k]$ 会选到 $C_{cnt1}^i*C_{cnt2}^i$ 次，就可以得到期望的分子了。然后发现分母也很好求，直接就是 $C_{cnt1}^i*C_{cnt2}^i$ ，这样我们就可以通过枚举 $i$ 来得到答案了。别忘了一共有 $(r-l)/2+1$ 个选择 $m$ 的方案，所以最后还要除一下，总时间复杂度 $O(nq)$ 。

发现这样并不能过题，当我头痛于化简组合数时，发现一些神奇的东西：我们把分子合并同类项之后这样写出来：$(\frac{sum1*i}{cnt1}+\frac{sum2*i}{cnt2})*C_{cnt1}^i*C_{cnt2}^i$ ，发现了什么？没错，可以直接把分母约掉！这也就是为什么我开头说期望救了我一命，这样我们的目标就是求出 $\sum\limits_{i=0}^{min(cnt1,cnt2)}\frac{sum1*i}{cnt1}+\frac{sum2*i}{cnt2}$ 了，然后再把 $i$ 提出来，惊奇的发现这其实就是个等差数列求和，可以直接 $O(1)$ 算。结合前面的暴力，预处理前缀和外加线性求一下逆元，总时间复杂度来到 $O(n+q)$ 。

## Code

挺短的，要注意一点就是异或出来的最终答案不要取模

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e6+5,mod=998244353;
int t,n,q;
int a[N];
ll sum[N],inv[N],ans;
int main()
{
	scanf("%d",&t);
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		sum[i]=(sum[i-1]+a[i])%mod;
	}
	
	inv[1]=1;
	for(int i=2;i<=n;i++){
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	}
	
	while(q--){
		int l,r,k;
		scanf("%d%d%d",&l,&r,&k);
		ll summ=0,val=(ll)a[k],cnt1=k-l,cnt2=r-k,sum1=sum[k-1]-sum[l-1],sum2=sum[r]-sum[k];
		sum1=(sum1+mod)%mod;sum2=(sum2+mod)%mod;
		ll di1=inv[cnt1],di2=inv[cnt2],lim=min(cnt1,cnt2);
		summ=val*(lim+1)%mod;
		ll w=sum1*di1%mod+sum2*di2%mod;
		summ+=(lim+1)*lim%mod*inv[2]%mod*w%mod;
		summ%=mod;
		summ=(summ*inv[(r-l)/2+1])%mod;
		ans^=summ;
	}
	printf("%lld\n",ans);
	
	return 0;
}
```

---

## 作者：intel_core (赞：1)

直接考虑每个人作为队友对答案的贡献：     
* 枚举 $i \in[0,s]$ ，如果 $x-l<s$ 或 $r-x>s$ 则易知无解    
* 否则考虑每个数出现的几率：   
	* 如果 $j<x$ ，概率为 $\frac{i}{x-l}$    
   * 如果 $j>x$ ，概率为 $\frac{i}{r-x}$     
* 所以我们可以通过很 $\text{naive}$ 地处理前缀和来做到 $\text{O(nq)}$ 的效率 

但这只能获得大概 $\text{50pts}$ ，还需要优化：    
$ans= \sum_{i=1}^{min(x-l,r-x)}(\frac{i}{x-l}\times\text{sum(l,x-1)}+\frac{i}{r-x}\times \text{sum(x+1,r)})$     
很明显，两个部分都可以把前面的分式单独求和，可以 $\text{O(n)}$ 预处理  
于是这个比较水的 $\text{C}$ 就被我们过掉了     
```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define int long long
inline int read(){
	int x=0; bool sgn=0; char s=gc;
	while(!isdigit(s))sgn|=s=='-',s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+(s-'0'),s=gc;
	return sgn?-x:x;
}
const int NR=4e6+10;
const int MOD=998244353;
int t,n,q,a[NR],sum[NR],p[NR];
int calc(int l,int r){
	return ((r-l+1)*(l+r)/2)%MOD;
}
int cal(int l,int r){return (sum[r]-sum[l-1]+MOD)%MOD;}
void init(){
	p[1]=1;
	for(int i=2;i<=n;i++)
		p[i]=((-(MOD/i)*p[MOD%i])%MOD+MOD)%MOD;
}

signed main(){
	cin>>t>>n>>q;
	for(int i=1;i<=n;i++)
		a[i]=read(),sum[i]=(sum[i-1]+a[i])%MOD;
	int ans=0;init();
	while(q--){
		int l=read(),r=read(),x=read();
		int k=min(x-l,r-x);
		int res=((calc(1,k)*cal(l,x-1))%MOD*p[x-l]%MOD)+((calc(1,k)*cal(x+1,r))%MOD*p[r-x]%MOD);
		res%=MOD;res=(res*p[k+1])%MOD;res=(res+a[x])%MOD;
		res=(res*(k+1))%MOD*p[(r-l)/2+1]%MOD;ans^=res;
	}	
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：jockbutt (赞：0)

一道挺有意思的期望打牌。

## Solution

首先思考朴素的式子。

我们定义 $ x = k - l $ 和 $ y = r - k$ 分别表示小 A 左边和右边的人数。由题目性质得知左边和右边要选同样数量的数。为了方便，我们钦定 $ x < y $，那么当选择的人数超过 $2\times x $ 的时候就会无解。

在其中，我们考虑对于两边各选 $ p $ 个数的时候，左边第 $ i $ 个数的贡献为 $ C^{p-1}_{x-1}\times C^{p}_{y}\times a_i $，而各选 $ p $ 个数时一共有  $ C^{p}_{x}\times C^{p}_{y}$ 种情况，所以说化简下来，第 $ i $ 个数的贡献为 $ \frac{a_i \times i}{x} $，右边同理。纯暴力枚举时间复杂度 $ O(n^2\times q) $。  
因为枚举 $ a_i $ 可以用前缀和优化掉，时间复杂度可以降为 $ O(n \times q) $，代码大致如下：

```cpp
namespace BF{
	inline void solve(int l,int r,int k)
	{
		int x=k-l,y=r-k,s1=(s[k-1]-s[l-1])%mo,s2=(s[r]-s[k])%mo,res;
		if(x>y)	swap(x,y),swap(s1,s2);
		res=(x+1)*a[k]%mo;
		for(int i=0;i<=x;++i)
		{
			int tmp=(i*(s1*inv[x]%mo+s2*inv[y]%mo)%mo)%mo;
			add(res,tmp);
		}
		res=res*inv[(r-l)/2+1]%mo;
		ans^=res;
	}
}
```

然后，通过化简，我们可以优化掉枚举 $ p $ 的情况，用 $ O(1) $ 的复杂度回答每一个询问。

对于每个询问的答案为 $ \frac{s \times x \times (x+1)}{2 \times x \times len} $，最后不要忘了把 $ k $ 加上。


## Code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int BUFFER=1<<20;
char RB[BUFFER],*RP=RB,*RT=RB;
#define getchar() RP==RT?(RT=RB+fread(RB,1,BUFFER,stdin),RP=RB,*RP++):*RP++
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9')	{if(ch=='-')f=-1;ch=getchar();}
	while('0'<=ch&&ch<='9')	{x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int Subtask;
int n,q,ans;
const int maxn=2e6+10,mo=998244353;
int a[maxn],s[maxn];
int inv[maxn],fac[maxn],ifac[maxn];
inline void add(int &x,int y)	{x+=y;if(x>=mo)	x-=mo;}
inline void init()
{
	inv[1]=fac[1]=ifac[1]=ifac[0]=fac[0]=1;
	for(int i=2;i<=2000001;++i)
	{
		fac[i]=fac[i-1]*i%mo;
		inv[i]=(mo-mo/i)*inv[mo%i]%mo;
		ifac[i]=inv[i]*ifac[i-1]%mo;
	}
}
inline int C(int x,int y)
{
	if(x<0||y<0||x<y)	return 0;
	return fac[x]*ifac[y]%mo*ifac[x-y]%mo;
}
namespace BF{
	inline void solve(int l,int r,int k)
	{
		int x=k-l,y=r-k,s1=(s[k-1]-s[l-1])%mo,s2=(s[r]-s[k])%mo,res;
		if(x>y)	swap(x,y),swap(s1,s2);
		res=(x+1)*a[k]%mo;
		for(int i=0;i<=x;++i)
		{
			int tmp=(i*(s1*inv[x]%mo+s2*inv[y]%mo)%mo)%mo;
			add(res,tmp);
		}
		res=res*inv[(r-l)/2+1]%mo;
		ans^=res;
	}
}
inline void solve(int l,int r,int k)
{
	int x=k-l,y=r-k,s1=(s[k-1]-s[l-1])%mo,s2=(s[r]-s[k])%mo,res;
	if(x>y)	swap(x,y),swap(s1,s2);
	res=(x+1)*a[k]%mo;
	res=(res+((s1*inv[x]%mo+s2*inv[y]%mo)%mo*x%mo*(x+1)%mo*inv[2]%mo)%mo)%mo;
	res=res*inv[(r-l)/2+1]%mo;
	ans^=res;
}
signed main(){
	init();
	Subtask=read();
	n=read(),q=read();
	for(int i=1;i<=n;++i)   a[i]=read(),s[i]=s[i-1]+a[i];
	for(int i=1,L,R,K;i<=q;++i)
	{
		L=read(),R=read(),K=read();
		solve(L,R,K);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Otomachi_Una_ (赞：0)

假设每次询问，小 A 在 $k$ 号位置，左右为 $l,r$。

因为小 A 必须在实力值中间的位置，所以在小 A 左右选择的人相同，记为 $m$。

为方便描述，假设参赛选手中比小 A 弱的，强的分别有 $L,R$ 个。那么，$m\leq\min(L,R)$。

发现左边一个数出现的概率为 $\dfrac{m}{L}$，其中 $m$ 在 $0$ 到 $\min(L,R)$ 之间概率相等。

下面我们设 $M=\min(L,R)$。

也就是总的概率为 $\dfrac{M\times (M+1)}{2\times L}$。

假设比小 A 弱的选手，强的选手实力值之和分别为 $S,T$，那么所求的期望值就是：

$$\dfrac{\dfrac{M\times (M+1)}{2\times L}\times S+\dfrac{M\times (M+1)}{2\times R}\times T}{r-l+1}$$

$$=M\times(M+1)\times \dfrac{S\times R+T\times L}{2L\times R\times (r-l+1)}$$

这里我们直接用费马小定理求逆元即可。

---


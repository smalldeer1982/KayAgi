# 「LAOI-4」Mex Tower (Easy ver.)

## 题目背景

**本题与 Hard Version 的区别为本题需给出一个合法的方案。**

## 题目描述

定义 $\operatorname{mex}(x, y)$ 表示在集合 $\{x, y\}$ 中最小的未出现的 **自然数**。例如，$\operatorname{mex}(1, 5) = 0$，$\operatorname{mex}(3, 0) = 1$。

继而，我们定义对自然数序列 $a_1\dots a_n$ 的一次操作，是将序列 $a$ 替换为 **长度为 $\bm{n - 1}$ 的** 序列 $b_1\dots b_{n-1}$，其中 $b_i = \operatorname{mex}(a_i, a_{i+1})$。

你需要构造一个长度为 $n$ 的自然数序列 $a_1\dots a_n$，满足 $0 \leq a_i \leq 10^9$；然后对它进行 $n - 1$ 次操作。显然最终序列 $a$ 只会剩下一个数，你需要最大化这个数的值。

如果有多种可能的数列，可以输出任何一种合法方案。

## 说明/提示

### 样例解释

对于 $n = 2$，我们对 $[0, 1]$ 进行操作后显然会得到 $[2]$。可以证明，这是我们能得到的最大的答案。  
其它合法的输出如 $[1, 0]$ 等也可以通过。

对于 $n = 5$ 和 $n = 7$，暂时不能给你一个明确的答复。

### 数据规模与约定

**「本题采用捆绑测试」**

| $\text{Subtask}$ | $\sum n \le$|  特殊性质  | 总分值 |
| :--------------: | :-----: |:-----: | :--------: |
|       $1$        |  $10$ | 无| $5$ |
$2$        | $10^5$  | $\text{A}$ | $15$ |
|       $3$        | $10^5$  | $\text{B}$ | $15$ |
|       $4$        | $50$ | $n\le 25$ | $10$ |
|       $5$        | $10^3$ | 无 | $20$ |
|       $6$        | $10^6$ |     无     | $35$ |

特殊性质 $\text{A}$：保证 $n\equiv 3\pmod 4$。

特殊性质 $\text{B}$：保证 $n\equiv 2\pmod 4$。

对于所有数据，保证 $1 \leq T \leq 10^4$，$n > 1$，$\sum n \leq 10^6$。

## 样例 #1

### 输入

```
3
2
5
7```

### 输出

```
0 1
3 1 5 0 1
0 7 9 4 0 0 4```

# 题解

## 作者：SafariMo (赞：5)

显然答案最多是 $2$。

所以我们考虑构造。

观察得由 $n$ 个 $1$，$1$ 个 $2$ 和 $n$ 个 $0$。组成的序列操作后为 $n$ 个 $1$，$n$ 个 $0$。

并且 $n$ 个 $0$，$n$ 个组成的序列操作后为 $n-1$ 个 $1$，$1$ 个 $2$ 和 $n-1$ 个 $0$。

按以上方法构造即可，本题存在多解。

---

## 作者：ivyjiao (赞：4)

挺好的找规律题。

截至发题解时无人和我构造方法相同。

由于 $\text{mex}$ 的定义，$\text{mex(a,b)}$ 至多为 $2$。所以答案至多为 $2$，序列中出现 $>2$ 的数无意义。

我们考虑这个新定义运算的逆运算，即给出一个长度为 $n$ 的 $b$，构造一个长度为 $n+1$ 的 $a$，使得 $b_i=\text{mex}(a_i,a_{i+1})$。

由上文可知，这种构造中，$2$ 只能由 $(0,1)$ 得到，$1$ 只能由 $(0,2)$ 得到，$0$ 只能由 $(1,2)$ 得到（括号内顺序无所谓）。

所以我们只需要把 $n=2$ 构造出来，然后就可以由 $n=2$ 得到 $n=3$，由 $n=3$ 得到 $n=4$，由 $n=4$ 得到 $n=5$，以此类推。

于是，我们可以得出：

当 $n=2$ 时，答案显然为 $2$，构造为 $\{1,0\}$。

当 $n=3$ 时，为了构造出 $n=2$ 的情况，我们可以构造 $\{0,2,1\}$。

当 $n=4$ 时，为了构造出 $n=3$ 的情况，我们可以构造 $\{2,1,0,2\}$。

当 $n=5$ 时，为了构造出 $n=4$ 的情况，我们可以构造 $\{1,0,2,1,0\}$。

$\cdots$

发现规律：

当 $n=m$ 时，为了构造出 $n=m-1$ 的情况，我们可以构造 $a_i=2-(m+i+1)\bmod3$。

此题得解，时间复杂度 $O(tn)$。~~难道还能是别的吗？？？~~

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int main(){
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++) cout<<2-(n+i+1)%3<<" ";
        cout<<endl;
    }
}
```

---

## 作者：_wsq_ (赞：3)

一种和出题人不一样的构造方法。

很明显，因为答案由两个数得来，而两个数不可能同时包含 $0$、$1$ 和 $2$。所以答案至多为 $2$，考虑构造。

我们可以用 $0$ 和 $1$ 来构造 $2$，用 $0$ 和 $2$ 来构造 $1$，用 $1$ 和 $2$ 来构造 $0$。然后自下而上就可以推出规律了，如下：

```
1 2 0 1 2 0
 0 1 2 0 1
  2 0 1 2
   1 2 0
    0 1
     2
```

由此，得出：

答案的第一位为 $(n+1)\bmod3$，后面每次加 $1$ 模 $3$ 即可。

AC 代码：

```cpp
#include <iostream>
using namespace std;
int main(){
    int t,n,a;
    cin>>t;
    while(t--){
        cin>>n;
        a=(n+1)%3;
        for(int i=1;i<=n;i++){
            cout<<a<<' ';
            a++;
            a%=3;
        }
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：Breath_of_the_Wild (赞：3)

容易发现答案最多为 $2$，因此我们需要构造出答案为 $2$ 的 $a$，还要具备着一定的规律性。

以下仅为我赛时的构造方法，不止有这一种。

考虑从 $2$ 开始，倒着推出构造的数组，只填 $0,1,2$ 三个数。于是，上面一行应该是 $0,1$，接着是 $1,2,0$，然后是 $0,0,1,1$，等等。

整个图大概就长下面这样（以 $9$ 为例）：
```
1 1 1 1 2 0 0 0 0
 0 0 0 0 1 1 1 1
  1 1 1 2 0 0 0
   0 0 0 1 1 1
    1 1 2 0 0
     0 0 1 1
      1 2 0
       0 1
        2
```
于是就找到规律了。

如果 $n$ 是奇数，则
1. 先输出 $\lfloor\frac{n}{2}\rfloor$ 个 ``1``。
2. 再输出 ``2``。
3. 最后输出 $\lfloor\frac{n}{2}\rfloor$ 个 ``0``。

否则
1. 先输出 $\frac{n}{2}$ 个 ``0``。
2. 再输出 $\frac{n}{2}$ 个 ``1``。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+3;
int T,n,a[N];
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		if(n&1){
			for(int i=1;i<=(n>>1);i++) cout<<"1 ";
			cout<<"2 ";
			for(int i=1;i<=(n>>1);i++) cout<<"0 ";
		}else{
			for(int i=1;i<=(n>>1);i++) cout<<"0 ";
			for(int i=1;i<=(n>>1);i++) cout<<"1 ";
		}
		cout<<'\n';
	}
	return 0;
}

---

## 作者：Claire0918 (赞：1)

我们注意到
$$
(\forall x, y \in \mathbb{N})(\operatorname{mex}(x, y) \in \{0, 1, 2\})
$$
且 $\operatorname{mex}$ 具有交换律。

又有对应关系
$$
\operatorname{mex}(x, y) = 
\begin{cases}
2 & x = 0, y = 1\\
1 & x = 0,y \neq 1\\
0 & x \neq 0, y \neq 0
\end{cases}
$$

为保证得到的序列可以继续倒推，即该序列可能是某一个序列通过一次变换得到的序列，我们要求序列中所有数的取值范围为 $\{0, 1, 2\}$ 而不是 $\mathbb{N}$。

而欲要使得最后的数最大，即序列为 $[2]$。

读者易证，翻转序列不会影响最终结果，我们只考虑其中一个。

再倒推，即得到 $[0, 1]$。

我们设上一级的序列为 $[a, b, c]$。

显而易见，$b \neq 0$，所以 $c = 0$，又有 $b \neq 1$，所以 $b = 2$，而且有 $a \neq 0$。我们简记为 $[\neq 0, 2, 0]$。

再设有上一级的 $[a, b, c, d]$。

又十分显然地，$b = 0$，所以 $a$ 任意取值，$c = 1$，又 $d \neq 0$。那么结果简记为 $[\text{all}, 0, 1, \neq 0]$。

再设有上一级的 $[a, b, c, d, e]$。

显然有 $b \neq 0, c \neq 0 \wedge c \neq 1$，所以有 $a$ 任意取值，$c = 2, d = 0$，所以 $e$ 任意取值。简记为 $[\text{all}, \neq 0, 2, 0, \text{all}]$。

再设有上一级的 $[a, b, c, d, e, f]$。

显然有 $d \neq 0$，所以 $c = 0, d = 1$，所以 $a, b, f$ 任意取值，简记为 $[\text{all}, \text{all}, 0, 1, \neq 0, \text{all}]$。

我们将上述结果列在一起
$$
[2]\\
[0, 1]\\
[\neq 0, 2, 0]\\
[\text{all}, 0, 1, \neq 0]\\
[\text{all}, \neq 0, 2, 0, \text{all}]\\
[\text{all}, \text{all}, 0, 1, \neq 0, \text{all}]
$$

我们不难发现，从 $n \geq 5$ 开始，结果总是在 $n - 2$ 的结果两侧各加上一个 $[\text{all}]$。于是我们可以直接令 $\text{all} = 0$，然后输出。

注意 $n = 4$ 与 $n = 2$ 相比出现了新的元素，所以 $n = 2$ 特判，其他情况分奇偶输出。

Code: 
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

int t, n;

int main(){
    scanf("%d", &t);
    while (t--){
        scanf("%d", &n);
        if (n == 2){
            printf("0 1\n");
            continue;
        }
        if (n & 1){
            for (int i = 1; i <= (n >> 1) - 1; i++){
                printf("0 ");
            }
            printf("1 2 0 ");
            for (int i = 1; i <= (n >> 1) - 1; i++){
                printf("0 ");
            }
        }else{
            for (int i = 1; i <= (n >> 1) - 1; i++){
                printf("0 ");
            }
            printf("0 1 1 ");
            for (int i = 1; i <= (n >> 1) - 2; i++){
                printf("0 ");
            }
        }
        putchar('\n');
    }

return 0;
}
```

---

## 作者：lilong (赞：1)

这是一道找规律题。

不妨从小情况入手。当 $n=2$ 时，显然令 $a=\{ 0,1 \}$ 是最优的，此时进行一次操作得到 $2$，为最大的答案。这是最基础的情况，也就是对于 $n$ 更大的情况，答案最多也只能是 $2$。接下来观察 $\operatorname{mex}$ 的性质。

- $\operatorname{mex}(0,1)=2$

- $\operatorname{mex}(0,2)=1$

- $\operatorname{mex}(1,2)=0$

不难发现，原来在 $0,1,2$ 中，只要有了其中的两个数，便可以通过一次 $\operatorname{mex}$ 转换为第三个数。有了这个性质，便可以开始构造答案了。

因为 $\operatorname{mex}(1,2)=0$，$\operatorname{mex}(0,2)=1$，所以 $\{0,1\}$ 可由 $\{1,2\}$ 和 $\{0,2\}$ 分别操作后得到。把其中相同的 $2$ 放在中间，可得到 $\{1,2,0\}$。这就是 $n=3$ 的一组合法解。

对于 $n$ 更大的情况，可以照着上述思路继续推。把推出来的结果列表：

```cpp
2
0 1
1 2 0
2 0 1 2
0 1 2 0 1
```

不难发现在每一列以及最外层的斜线上，都是 $0,1,2$ 在循环滚动。于是便可以很方便地输出了。

代码如下：

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
	int T,n,cnt;
	cin >> T;
	while( T -- )
	{
		cin >> n;
		cnt = 1;
		for( int i = 1 ; i <= n ; i ++ )
		{
			cout << ( cnt + ( n - i + 1 )  ) % 3 << ' ';
			cnt = ( ( cnt - 1 ) % 3 + 3 ) % 3;
		} 
		cout << endl;
	}
	return 0;
}
```

---

## 作者：DHeasy (赞：1)

跟官方有点不太一样的解法，可能会有些麻烦。

注意到最终剩下的数一定 $\le2$，所以构造的方案一定要使得最后剩下的数为 $2$。

#### 证明

设两个数 $a,b$（$a,b\ge0$）。

当 $a\not=0,b\not=0$ 时，$\operatorname{mex}(a,b)=0\lt2$；

当 $a=0,b=1$ 或 $a=1,b=0$ 时，$\operatorname{mex}(a,b)=2$；

否则，$\operatorname{mex}(a,b)=1\lt2$。

综上 $\operatorname{mex}(a,b)\le2$。

定义对长度为 $l$ 的自然数序列 $a_1,a_2\dots a_l$ 的一次分解操作，是将序列 $a$ 替换为长度为 $l+1$ 的序列 $b_1,b_2\dots b_{l+1}$，其中 $a_i = \operatorname{mex}(b_i, b_{i+1})$（$1\le i\le l$）。

最终的构造方案就是对 $2$ 进行 $n-1$ 次分解操作，最终得到的序列，答案肯定是不唯一的。

注意到长度为 $n$ 的答案是可以由长度为 $n-1$ 的答案分解得到。

尝试着分解，发现：

当 $n=2$ 时，构造序列可以为 $[1,0]$；

当 $n=3$ 时，由 $n=2$ 分解得到 $[0,2,2]$；

当 $n=4$ 时，由 $n=3$ 分解得到 $[1,1,0,1]$；

当 $n=5$ 时，由 $n=4$ 分解得到 $[2,0,2,2,0]$；

当 $n=6$ 时，由 $n=5$ 分解得到 $[0,1,1,0,1,1]$；

当 $n=7$ 时，由 $n=6$ 分解得到 $[2,2,0,2,2,0,2]$；

以此类推，可以得到：

```
2
1 0
0 2 2
1 1 0 1
2 0 2 2 0
0 1 1 0 1 1
2 2 0 2 2 0 2
1 0 1 1 0 1 1 0
0 2 2 0 2 2 0 2 2
1 1 0 1 1 0 1 1 0 1
2 0 2 2 0 2 2 0 2 2 0
0 1 1 0 1 1 0 1 1 0 1 1
...
```

其中第 $i$ 行表示当 $n$ 等于 $i$ 是 的答案。

把奇数行和偶数行分开来看。

```
2
0 2 2
2 0 2 2 0
2 2 0 2 2 0 2
0 2 2 0 2 2 0 2 2
2 0 2 2 0 2 2 0 2 2 0

1 0
1 1 0 1
0 1 1 0 1 1
1 0 1 1 0 1 1 0
1 1 0 1 1 0 1 1 0 1
0 1 1 0 1 1 0 1 1 0 1 1
```

发现第 $i$ 行（$i\gt2$）的答案就是在第 $i-2$ 行的答案头和尾各添加一个数。而第 $2$ 行的序列为 $[1,0]$

发现奇数行添加的数为：

```
0 2
2 0
2 2
0 2
...
```

偶数行添加的数为：

```
1 1
0 1
1 0
1 1
...
```

由此就可以 $O(n)$ 构造了，具体实现见代码。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
deque<int>q; //双端队列维护头和尾的添加
void Push(int x,int y){q.push_front(x),q.push_back(y);} //添加操作
int main(){
	scanf("%d",&t);
	while(t--){
	    scanf("%d",&n);
		while(!q.empty()) q.pop_back();
		if(n&1){ //奇数行
			q.push_back(2);
			int s=n/2;
			for(int i=1;i<=s;i++){
				if(i%3==1) Push(0,2);
				else if(i%3==2) Push(2,0);
				else Push(2,2);
			}
		}
		else{ //偶数行
			Push(1,0);
			int s=n/2-1;
			for(int i=1;i<=s;i++){
				if(i%3==1) Push(1,1);
				else if(i%3==2) Push(0,1);
				else Push(1,0);
			}
		}
		while(!q.empty()){printf("%d ",q.front()),q.pop_front();}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：水星湖 (赞：1)

感觉做麻烦了，看到这题先写了个爆搜。

下面是爆搜代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[105], n, ans, v[105], t[105],f;
int mex(int a, int b){ 
if (a != 0 && b != 0) return 0; 
    if (a != 1 && b != 1) return 1; 
    if (a != 2 && b != 2) return 2; 
}
void dfs(int step){
    if(f) return;
    if(step == n + 1){
        for(int i = 1; i <= n; i++) v[i] = a[i];
            for(int i = n - 1; i >= 1; i--){
                for(int j = 1; j <= i; j++)
                    t[j] = mex(v[j], v[j+1]);
                for(int j = 1; j <= i; j++)
                    v[j] = t[j];
            }
        ans = max(ans, v[1]);


        if(v[1] == 2){
            for(int i = 1; i <= n; i++) cout << a[i] << ' ';
            cout << endl;
            f = 1;
        }
        return;
    }
    a[step] = 1;
    dfs(step + 1);
    a[step] = 0;
    dfs(step + 1);
    a[step] = 2;
    dfs(step + 1);
}
void solve()
{
    ans = 0, f = 0;
    memset(a, 0, sizeof(a));
    cin >> n;
    dfs(1);
    cout << ans << endl;
}
signed main()
{
    int t;cin>>t;
    while(t--)solve();
    return 0;
}
```

这个代码可以输出第一组答案为 $2$ 的解。其中 $a_i$ 的值只取 $0,1,2$ 的原因请读者自行思考。

给出 $n=2\sim11$ 的输出：

```
1 0 
2
1 2 0 
2
1 1 0 1 
2
1 1 2 0 1 
2
1 1 1 0 1 1 
2
1 1 1 2 0 1 1 
2
1 1 1 1 0 1 1 1 
2
1 1 1 1 2 0 1 1 1 
2
1 1 1 1 1 0 1 1 1 1 
2
1 1 1 1 1 2 0 1 1 1 1 
2
```

规律很容易发现，分讨 $n$ 的奇偶即可。

---

## 作者：lbh666 (赞：1)

容易发现答案只能为 $0$，$1$，$2$。我们就需要尽可能的凑出 $2$。

- 采用倒推的方法记录一下。

```cpp
2 0 1 2 0 1 2
 1 2 0 1 2 0
  0 1 2 0 1
   2 0 1 2
    1 2 0
     0 1
      2
```

答案不止这一种，但这样构造方便一些。

- 可以发现，每一层都是按 $0$，$1$，$2$ 循环得出的，每一层的头部也是按 $0$，$1$，$2$ 循环得到的。

- 这是因为 $1$ 可以由 $\text{mex}(2,0)$ 得到，$2$ 可以由 $\text{mex}(0,1)$得到，$0$ 可以由 $\text{mex}(1,2)$ 得到。在保证前一个倒推的结果为循环节的情况下，新推出来的结果依旧是循环节。

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,l,r) for(int i=l;i<=r;++i)
using namespace std;

int t;

int main(){
	cin>>t;
	while(t--){
		int n,head;
		cin>>n;
		head=(1+n)%3; //依图意算出每一层的头部 
		for(int i=1;i<=n;++i){
			cout<<head<<" ";
			head=(head+1)%3;//输出一个循环节 
		}
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：0)

很明显最终数最大为 $2$，难点在于构造。

我们可以画一个倒推的图来找出规律，这是我画的：

$$2 \\ 10 \\ 021 \\ 1100 \\ 00211 \\ 111000 \\ 0002111 \\ \cdots$$

因此可以发现规律：

- 当 $n\equiv 0\pmod 2$ 时，输出 $\frac{n}{2}$ 个 $1$ 和 $\frac{n}{2}$ 个 $0$。
- 当 $n\equiv 1\pmod2$ 时，输出 $\lfloor\frac{n}{2}\rfloor$ 个 $0$，一个 $2$ 和 $\lfloor\frac{n}{2}\rfloor$ 个 $1$。

---

## 作者：Bc2_ChickenDreamer (赞：0)

## P10369

### Sol

很容易发现，剩余的数最多为 $2$。

如果没有 $0$，那么 $\text{mex}$ 函数的值必定为 $0$。所以，我们必须要构造出 $0$。

我们发现，$\text{mex}(0, 1) = 2$。所以，我们最后必须要把序列变成 $[0, 1]$。我们把 $[0, 1]$ 往上推一步，只有形如 $[1, x, 0]$ 的数列才能构造出 $[0, 1]$。

假设 $x = 1$，我们继续往上推找规律。但我们发现我们无法用任何 $n = 4$ 的序列构造出 $[1, 1, 0]$。所以 $x = 1$ 行不通。

接下来 $x = 2$。我们从 $[1, 2, 0]$ 继续往上推，你就会得到这样子的一个序列表：

```
0 1
1 2 0
0 0 1 1
1 1 2 0 0
0 0 0 1 1 1
1 1 1 2 0 0 0
0 0 0 0 1 1 1 1
......
```

我们发现，有些序列形如 $[1, 1, \cdots, 1, 2, 0, 0, \cdots, 0]$，有些则形如 $[0, 0, \cdots, 0, 1, 1, \cdots, 1]$。

于是发现道理：

+ $n \bmod 2 = 0$ 时构造形如 $[0, 0, \cdots, 0, 1, 1, \cdots, 1]$ 的序列，且 $0, 1$ 各占序列一半。

+ $n \bmod 2 = 1$ 时构造形如 $[1, 1, \cdots, 1, 2, 0, 0, \cdots, 0]$ 的序列，且 $2$ 在序列的正中间。


### Code

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <map>

using namespace std;

using ll = long long;

const int kMaxN = 1e5 + 10, kInf = (((1 << 30) - 1) << 1) + 1, kMod = 1e9 + 7;
const ll kLInf = 9.22e18;

ll n;

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int t;
  for (cin >> t; t; -- t) {
    cin >> n;
    if (!(n % 2)) { // 0, 0, ..., 0, 1, 1, ..., 1
      for (int i = 1; i <= n; ++ i) {
        cout << !(i <= n / 2) << ' '; // 各一半
      }
      cout << '\n';
    } else { // 1, 1, ..., 1, 2, 0, 0, ..., 0
      for (int i = 1; i <= n; ++ i) {
        if (i == n / 2 + 1) { // 正中间
          cout << 2 << ' ';
        } else if (i <= n / 2) { // 前半边
          cout << 1 << ' ';
        } else { // 后半边
          cout << 0 << ' ';
        }
      }
      cout << '\n';
    }
  }
  return 0;
}
```

---

## 作者：jqQt0220 (赞：0)

注意到题目中的 $\operatorname{mex}$ 的集合只有两个数，那么分类讨论，如果两个都不是 $0$，那答案就是 $0$；否则如果两个都不是 $1$，那么就是 $1$；否则就一定是 $(0,1)$，是 $2$。所以最终答案最大只能是 $2$。

知道了要构造答案为 $2$ 的，就可以开始找规律了。既然 $\operatorname{mex}$ 的值最大只有 $2$，那么这里构造的数列最大也只有 $2$，同时为了保证好找规律，这里以数尽量小为标准。我们可以从 $n=2$ 入手，由上可知在 $n=2$ 时，答案只可能为 $0,1$ 或 $1,0$。这里以前者为例，向后推：$\operatorname{mex}(a_{1},a_{2})=0,\operatorname{mex}(a_{2},a_{3})=1$，那么 $a_{1},a_{2}\ne0,a_{2},a_{3}\ne1$，那么 $a_{2}$ 只能 $=2$，$a_{1}=1,a_{3}=0$。根据如上方法推出剩下的：
```plain
n: a
2: 0 1
3: 1 2 0
4: 2 0 1 2
5: 0 1 2 0 1
6: 1 2 0 1 2 0
7: 2 0 1 2 0 1 2
```

有没有发现什么规律？可以发现 $a_{1}=(n+1)\bmod3,a_{2}=(n+2)\bmod3\dots$，那么得出答案 $a_{i}=(n+i)\bmod3$。代码懒得放了（

---

## 作者：ran_qwq (赞：0)

两个数的 mex 最多是 $2$，又 $n>1$，所以答案最多是 $2$。

考虑怎么样构造出 $2$。

- 当 $n\bmod 3=1$ 时，构造 $a=\{2,0,1,2,0,1,2,\dots\}$。
- 当 $n\bmod 3=2$ 时，构造 $a=\{0,1,2,0,1,2,0,\dots\}$。
- 当 $n\bmod 3=0$ 时，构造 $a=\{1,2,0,1,2,0,1,\dots\}$。

---
显而易见地，当 $n=1$ 时序列 $\{2\}$ 满足条件。而构造出来的 $n$ 的情况经过一次消除后可以变为 $n-1$ 的情况，所以该构造方法可行。

---

## 作者：_O_v_O_ (赞：0)

来一种代码简单的倒推方法。

因为最后的数为 $2$，考虑倒推：

$$2 \\ 01 \\ 120 \\ 2012 \\ 01201 \\ 120120 \\ \cdots$$

我们可以的到归纳公式：$f_i=(i+n)\bmod 3$，直接模拟即可。

---

## 作者：sgl654321 (赞：0)

## 题目大意
请构造一个长度为 $n$ 的序列，一次操作把每个元素同时修改为 $\text{mex}\{a_i, a_{i + 1}\}$，使得经过 $n - 1$ 次操作后最后剩下的那个数最大。

## 解题思路
首先这个剩下的数一定是 $2$。其次，我们发现构造的序列中大于 $2$ 的数字都是没有意义的，改成 $2$ 也没有区别。我们只需要用 $0,1,2$ 这三个数字构造就行了。

下面我将给出我的构造方案：

> $a_1 = (n + 1)\bmod 3$，$a_i = (a_{i - 1} + 1)\bmod 3(i \ge 2)$。

接下来给证明：

- $n = 2$ 时序列 $a = \{0, 1\}$，符合题意。

- 对于 $n > 2$ 的情况，容易发现：

$\text{mex}\{0, 1\} = 2, \text{mex}\{1, 2\} = 0, \text{mex}\{2, 0\} = 1$。

即 $\text{mex}\{i, (i + 1)\bmod 3\} = (i + 2)\bmod 3$。

序列 $a$ 操作一遍后，会变成的序列 $b$ 的第一个元素为：

$b_1 = \text{mex}\{a_1, a_2\} = \text{mex}\{(n + 1) \bmod 3, (n +2)\bmod 3\} = n\bmod 3$。

$b_1$ 正好是序列长度为 $n - 1$ 时的 $a_1$！这意味着，序列 $b$ 就是长度为 $n - 1$ 时的序列 $a$。这样不断操作下去，最后一定为达到最大结果。

### 参考代码

这个就算了吧。上面构造方案都写那么清楚了。

---

## 作者：Luxe877 (赞：0)

原题链接在此：[link](https://www.luogu.com.cn/problem/P10369)

## 本题题意
构造一个长度为 $n$ 的序列，使得在 $n-1$ 次操作后的值最大。操作为将数列第 $i$ 个数换为 $\text{mex}(a_i,a_{i+1})$，每次操作后数列长度会减一。$\text{mex}(a_i,a_{i+1})$ 意为在集合 $\{a_i,a_{i+1}\}$ 中最小的没出现的自然数，比如说 $\text{mex}(1,2)=0$，$\text{mex}(0,2)=1$，$\text{mex}(1,0)=2$。

## 思路
既然是构造题目，那就要考虑找到其中规律。

首先因为要最大化最终值，根据上面题意中的三个结论，可以得出最后的值最大为 $2$，所以当 $n=2$ 时，数列 $a$ 为 `0 1`，这个通过样例解释也可以得到。

然后通过这个 $n=2$ 的结论推 $n>2$ 的结论。那么可以根据暴力算法或者手算，可得如下数列（$n \leq 10$）。

```cpp
2
0 1
1 2 0
0 0 1 2
1 1 2 0 1
0 0 0 1 2 0
1 1 1 2 0 1 1
0 0 0 0 1 2 0 0
1 1 1 1 2 0 1 1 1
0 0 0 0 0 1 2 0 0 0
```

如果上述数列的推导不是很理解的话可以自己手算一下。总之，不难发现如下结论：

- $n$ 为偶数时，需先输出 $\frac{n}{2}$ 个 `0`，然后输出 `1 2`，最后再输出 $n-(\frac{n}{2}+2)$ 个 `0`。还有特判的 $n=2$ 情况直接输出 `0 1`。
- $n$ 为奇数时，需先输出 $\lfloor \frac{n}{2} \rfloor$ 个 `1`，然后输出 `2 0`，最后再输出 $n-(\lfloor \frac{n}{2} \rfloor+2)$ 个 `1`。

根据这个结论写代码就可以了。代码贴在下面：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n;
int num[1000002];
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n;
		if(n%2==0)
		{
			if(n==2)
			{
				cout<<"0 1";
			}else{
				for(int i=1;i<=n/2;i++)
				{
					cout<<"0 ";
				}
				cout<<"1 2 ";
				if(n>4)
				{
					for(int i=1;i<=n-(n/2+2);i++)
					{
						cout<<"0 ";
					}
				}
			}
		}else{
			for(int i=1;i<=n/2;i++)
			{
				cout<<"1 ";
			}
			cout<<"2 0 ";
			if(n>3)
			{
				for(int i=1;i<=n-(n/2+2);i++)
				{
					cout<<"1 ";
				}
			}
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：__qkj__ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10369)
## 解题思路
一遇到这种题，先打表找规律。

我们从第一层开始，一层一层往下推。

因为 $\operatorname{mex(x,y)}$ 的最大值是 $2$（此时 $x=0,y=1$），所以最后一层是 $2$，接着，就是 $1,0$，再接着，就是 $0,2,1$。

```plane
         2
        1 0
       0 2 1
      2 1 0 2
     1 0 2 1 0
    0 2 1 0 2 1
   2 1 0 2 1 0 2
  1 0 2 1 0 2 1 0
 0 2 1 0 2 1 0 2 1
2 1 0 2 1 0 2 1 0 2
```

可以发现，每行都是三个数，然后重复，列也是一样的。

我们再写一个方阵：

```plane
210
102
021
```

设当前正在输出的是第 $i$ 行第 $j$ 列（$0\le j<n,2\le i\le n$），则输出方阵的第 $(i-2) \bmod 3$ 行，第 $j \bmod 3$ 列。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char a[5][5]={
	{"102"},
	{"021"},
	{"210"}
};
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;
		for(int i=0;i<n;i++)
			cout<<a[(n-2)%3][i%3]<<' ';
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/P10369)

# 思路分析

因为本题中的 $\text{mex}$ 只涉及到两个数，因此最终结果最大即为 $2$，重点是如何构造合法方案。

我们可以进行倒退，可以得到一种构造方法。

1. 构造长为 $2n$ 的方案

先输出 $n$ 个 $0$，再输出 $n$ 个 $1$。

2. 构造长为 $2n+1$ 的方案

先输出 $n$ 个 $1$，再输出 $2$，最后再输出 $n$ 个 $1$。

可以发现，两种情况可以互相转换。

# Code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int T,n;
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        if(n&1){
            for(int i=1;i<=n/2;i++)printf("1 ");
            printf("2 ");
            for(int i=1;i<=n/2;i++)printf("0 ");
        }else{
            for(int i=1;i<=n/2;i++)printf("0 ");
            for(int i=1;i<=n/2;i++)printf("1 ");
        }
        putchar('\n');
    }
    return 0;
}
```

如有错误，请指出。

---


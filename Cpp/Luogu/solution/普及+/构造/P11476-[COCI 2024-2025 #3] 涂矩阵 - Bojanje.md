# [COCI 2024/2025 #3] 涂矩阵 / Bojanje

## 题目背景


译自 [COCI 2024/2025 #3](https://hsin.hr/coci/) T3。$\texttt{1s,0.5G}$。满分为 $90$。

## 题目描述


有一个初始为全白的 $n\times n$ 矩阵。

每次操作可以选择一列 / 一行，将这一列 / 一行**覆盖**成红色 / 蓝色。

给定矩阵的目标状态，试构造一组操作序列使得矩阵达到目标状态，或者报告无解。

**不需要**最小化操作序列的长度，合法即可得分。


## 说明/提示


对于 $100\%$ 的数据，保证 $1\le n\le 2\times 10^3$。


| 子任务编号 | $k\le$ |  特殊性质 | 得分 |  
| :--: | :--: | :--: |:--: | 
| $ 1 $    | $2\times 10^3$ |  A  |   $ 15 $   |  
| $ 2 $    | $10^2$ |   |  $ 35 $   |  
| $ 3 $    | $2\times 10^3$  |  | $ 40 $   |

- 特殊性质 A：$a_{i,j}\in\{0,1\}$。





## 样例 #1

### 输入

```
3
0 0 1
1 1 1
0 0 1```

### 输出

```
2
2 3 1
1 2 1```

## 样例 #2

### 输入

```
3
1 1 2
2 1 1
2 1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
4
0 1 2 1
2 2 2 1
0 1 2 1
1 1 2 1```

### 输出

```
5
2 2 1
1 2 2
2 4 1
1 4 1
2 3 2```

# 题解

## 作者：light_searcher (赞：3)

怎么没有题解。

一道不错的题，不需要什么算法，直接倒推还原即可。

首先，存在 $0$ 的位置所在的行和列一定都不会被染色。然后如果一行或一列全都是 $1$ 或 $2$，那么它就可以是最后一个被染色的。然后我们设想把这一行或列给消除掉，剩下的位置再并成一个矩阵，重复上述操作即可得到最终答案。

但是代码显然不能这么写。注意到能不能消除与这行或这列上本身有的数字个数和已经消除的数字个数间的大小关系有关，那么我们可以考虑通过记 $h_{1/2}$ 和 $w_{1/2}$ 表示列或行已经被消除的 $1$ 或 $2$ 的个数。然后对行和列分别消除，同时维护 $h$ 和 $w$，当消不动的时候停止。此时我们得到一个答案序列，然后再按照这个序列把矩阵染色，与原矩阵相比，如果不同则无解。

代码有点难写，求答案序列部分的复杂度为 $\mathcal O(n)$。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
int n,a[N][N],b[N][N],h[3],w[3];
vector<int>vech[N],vecw[N];
struct node{
	int type,idx,col;
};
vector<node>ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++){
		int cnt1=0,cnt2=0;
		for(int j=1;j<=n;j++)
			if(a[i][j]==1) cnt1++;
			else if(a[i][j]==2) cnt2++;
		if(cnt1+cnt2==n) vech[cnt1].push_back(i);
	}
	for(int i=1;i<=n;i++){
		int cnt1=0,cnt2=0;
		for(int j=1;j<=n;j++)
			if(a[j][i]==1) cnt1++;
			else if(a[j][i]==2) cnt2++;
		if(cnt1+cnt2==n) vecw[cnt1].push_back(i);
	}
	int l1=0,r1=n,l2=0,r2=n;
	while(1){
		int sum1=0,sum2=0;
		for(;l1<=min(h[1],r1);l1++){
			w[2]+=vech[l1].size();
			sum1+=vech[l1].size();
			for(int j:vech[l1]) ans.push_back({1,j,2});
		}
		for(;r1>=max(n-h[2],l1);r1--){
			w[1]+=vech[r1].size();
			sum1+=vech[r1].size();
			for(int j:vech[r1]) ans.push_back({1,j,1});
		}
		for(;l2<=min(w[1],r2);l2++){
			h[2]+=vecw[l2].size();
			sum2+=vecw[l2].size();
			for(int j:vecw[l2]) ans.push_back({2,j,2});
		}
		for(;r2>=max(n-w[2],l2);r2--){
			h[1]+=vecw[r2].size();
			sum2+=vecw[r2].size();
			for(int j:vecw[r2]) ans.push_back({2,j,1});
		}
		if(!sum1&&!sum2) break;
	} 
	reverse(ans.begin(),ans.end());
	for(auto t:ans)
		if(t.type==1)
			for(int i=1;i<=n;i++) b[t.idx][i]=t.col;
		else
			for(int i=1;i<=n;i++) b[i][t.idx]=t.col;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(a[i][j]!=b[i][j]){
				puts("-1");
				return 0;
			}
	printf("%d\n",ans.size());
	for(auto i:ans) printf("%d %d %d\n",i.type,i.idx,i.col);
	return 0;
}
```

有意思的是，输入：

```
3
1 1 1
1 1 1
1 1 1
```

输出：
```
6
2 3 2
2 2 2
2 1 2
1 3 1
1 2 1
1 1 1
```
不过确实非常合理。

---

## 作者：player_1_Z (赞：3)

### 思路
这题如果暴力行列和颜色，时间复杂度不好判断，但是肯定会超时，于是就要运用**逆向思维**。这题既然有覆盖，那就反过来做，这样覆盖就没了。接下来找涂色方法，我们发现一次必须**涂一整行（列）**，所以直接找都为同一个颜色的行（列），然后记录这个操作再删掉并打标记，以此类推，最后判断是否每个不为白色的点都被涂过就行了（也就是看有没有标记和是不是白色）。
### 特别注意
因为不能涂白色，所以找到的同色行（列）不能都是白色。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[2003][2003],s[2][2005][3],pf[2005][2005];
//s的第一维：0为列，1为行；第二维：行数（列数）；第三维：三种颜色，其中存这一列（行）中每个颜色的个数 
bool f=1;
struct A{
	int x,y,z;
};
stack<A> st;
int check(int i,int j){//判断这一列（行）是否都是一个数 
	if(s[i][j][0]) return 0;//不能染0
	if(s[i][j][1]&&s[i][j][2]) return 0;//不止一个数 
	if(s[i][j][1]) return 1;
	if(s[i][j][2]) return 2;
	return 0;
}
void paint(int i,int j){
	if(pf[i][j]) return ;//因为我们是反着处理，所以染了的就不再染了（不覆盖 ）
	pf[i][j]=1;
	s[0][i][a[i][j]]--;
	s[1][j][a[i][j]]--;
}
void paintmax(int t,int x,int c){
	st.push({t,x,c});
	for(int j=1;j<=n;j++){//对列（行）中格子染色 
		if(t) paint(j,x);
		else paint(x,j);
	}
	for(int j=1;j<=n;j++){//再次递归 
		c=check(t^1,j);//如果这次是行（列）下一次就看列（行） 
		if(c) paintmax(t^1,j,c);
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			s[0][i][a[i][j]]++; //行列都要增加 
			s[1][j][a[i][j]]++;
		}
	}
	for(int i=1;i<=n;i++){//枚举颜色都相同的列（行） 
		for(int t=0;t<=1;t++){
			int c=check(t,i);//是否同色 
			if(c) paintmax(t,i,c);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) f&=pf[i][j]||!a[i][j];//判断是否（涂过色或是白色） 
	}
	if(f){
		cout<<st.size()<<endl;
		while(!st.empty()){
			A x=st.top();st.pop();
			cout<<x.x+1<<" "<<x.y<<" "<<x.z<<"\n";
		}
	}
	else cout<<-1;
	return 0;
}
```

---

## 作者：lvweisi (赞：2)

这题只要模拟就行了。
#### BUT...
---
最后  $4$  个点 TLE 卡了我很久，只要优化亿点点就好了。

思路:
---
只要按照他给你的样子倒推就好了，出现 $n$ 个相同的数就把它的答案压到答案数组中。


**奉上我的~~屎山~~代码**
```cpp
#include<iostream>
using namespace std;
int n;
int mp[5000][5000];//存储状态
int ansi[1000005];//存储每个a
int ansj[1000005];//存储每个b
int anss[1000005];//存储每个c
int h[1000005],h1;//存储每行是否被选中
int l[1000005],l1;//存储每列是否被选中
int san;//存储被改过的数字个数
/*本人英语不咋地,变量都是中文首字母,见谅哈*/
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int y,e;
int main(){
    cin.tie(0);
    cout.tie(0);
	n=read();
	int zj=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			mp[i][j]=read();//快读优化
			if(mp[i][j]==0)h[i]=l[j]=1,zj++,h1++,l1++;
		}
	}
	if(zj==n*n){
		cout<<0;//特判,如果全是0就一步都不需要
		return 0;
	}
	int pd0=0;
	while(1){
		for(int i=1;i<=n;i++){
			if(h[i]==1)continue;
			y=0,e=0;
			for(int j=1;j<=n;j++){
				if(mp[i][j]==1)y++;
				else if(mp[i][j]==2)e++;
				if(min(y,e)!=0)break;
			}
			if(y==0||e==0){
			    if(y!=e){
				    for(int j=1;j<=n;j++)if(mp[i][j]!=3)san++,mp[i][j]=3;
				    ansi[0]++;
				    ansi[ansi[0]]=1;
				    ansj[ansi[0]]=i;
				    if(y>0)anss[ansi[0]]=1;
				    else anss[ansi[0]]=2;
				}
				h1++;
				h[i]=1;
				if(h1+l1==2*n||san+zj==n*n)break;
			}
		}
		if(san+zj==n*n||san+zj==n*n)break;
		for(int j=1;j<=n;j++){
			if(l[j]==1)continue;
			y=0,e=0;
			for(int i=1;i<=n;i++){
				if(mp[i][j]==1)y++;
				else if(mp[i][j]==2)e++;
				if(min(y,e)!=0)break;
			}
			if(y==0||e==0){
			    if(y!=e){
    				for(int i=1;i<=n;i++)if(mp[i][j]!=3)san++,mp[i][j]=3;
	    			ansi[0]++;
		    		ansi[ansi[0]]=2;
			    	ansj[ansi[0]]=j;
				    if(y>0)anss[ansi[0]]=1;
				    else anss[ansi[0]]=2;
				}
				l[j]=1;
				l1++;
				if(h1+l1==2*n||san+zj==n*n)break;
			}
		}
		if(san+zj==n*n)break;
		int pd=h1+l1;
		if(pd==2*n)break;
		if(pd==pd0){
			cout<<-1;
			return 0;
		}
		pd0=pd;//亿点点的特判
	}
	if(ansi[0]==0||san+zj!=n*n){
		cout<<-1;
		return 0;
	}
	printf("%d\n",ansi[0]);
	for(int i=ansi[0];i>=1;i--){
	    printf("%d %d %d\n",ansi[i],ansj[i],anss[i]);
	}
	return 0;//完结撒花
}
```

---

## 作者：Kingna (赞：1)

考虑倒推，首先找到一行或一列全是相同颜色，这可以作为最后一步。然后将这一行打标记。

然后继续寻找一行或者一列，除了打标记之外，全是相同颜色。同时将这一行打标记。

这样循环往复的查找，我们需要在 $O(1)$ 时间内查询颜色是否全部一样。复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long
const int N = 2000 + 5;

int n, cnta[N][3], cntb[N][3], a[N][N], vis[N][N], vs[N];
vector<pair<int, pair<int, int>> > ans;

signed main() {
//  freopen("bojanje.in.1e", "r", stdin);
  cin >> n;
  _for(i, 1, n) _for(j, 1, n) {
    int x;
    cin >> x;
    cnta[i][x]++;
    cntb[j][x]++;
    a[i][j] = x;
  } 
  int ff = 0;
  _for(cas, 1, 2 * n) { // 重复操作 2 * n 次
    _for(i, 1, n) {
      int t = cnta[i][0] + cnta[i][1] + cnta[i][2];
      if ((cnta[i][1] == t || cnta[i][2] == t) && t != 0 && cnta[i][0] == 0) {
        ans.push_back({0, {i, (cnta[i][1] == t) ? 1 : 2}});
        cnta[i][1] = cnta[i][2] = 0;
        _for(j, 1, n) if (!vis[i][j]) cntb[j][a[i][j]]--;
        _for(j, 1, n) if (vis[i][j] == 0) vis[i][j] = 1;
      }
    }
    _for(i, 1, n) {
      int t = cntb[i][0] + cntb[i][1] + cntb[i][2];
      if ((cntb[i][1] == t || cntb[i][2] == t) && t != 0 && cntb[i][0] == 0) {
        ans.push_back({1, {i, (cntb[i][1] == t) ? 1 : 2}});
        cntb[i][1] = cntb[i][2] = 0;
        _for(j, 1, n) if (!vis[j][i]) cnta[j][a[j][i]]--;
        _for(j, 1, n) if (!vis[j][i]) vis[j][i] = 1;
      }
    }
  }
  int flg = 0;
  _for(i, 1, n) if (cnta[i][1] || cnta[i][2]) flg = 1;
  _for(i, 1, n) if (cntb[i][1] || cntb[i][2]) flg = 1;
  if (flg) puts("-1"), exit(0); 
  reverse(ans.begin(), ans.end());
  cout << ans.size() << endl; 
  for (auto v : ans) {
    cout << v.first + 1 << ' ' << v.second.first << ' ' << v.second.second << endl; 
  } 
}
```

---

## 作者：Tracy_Loght (赞：1)

考试二十分钟秒了，本场最水的签到题。

玩过积木的同学们一定知道，对于一个积木，如果它在最上面，那么一定这一列或行的颜色一样的。

那么它下面的呢？我们不知道啊，啊对啊，我们不知道当成任意颜色不可以吗？

注意！这题不需要最小化操作次数。

那么我们就有了一种做法，先对每一行或列扫一次，如果这一行或列上颜色一定，我们就保存答案，然后将这一行列的颜色改为任意。

后来的操作都一样，反反复复的判即可，只是对上面的颜色一定，改为除了任意颜色的地方，颜色一定即可。

对于不合法的方案，就是某一步时，整个图上都没有一个满足的地方即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,jl,zxy[3001][3001],o[3001][3001];
struct {
	ll v[3001],a,b,f;
} x[3001],y[3001];
struct {
	ll x,z,p;
} k[4000001];
void exset(ll c,ll x_) {
	jl++;
	k[jl].x=c;
	k[jl].z=x_;
	if(c==1) {
		if(x[x_].a==n) k[jl].p=1;
		else k[jl].p=2;
		for(ll i=1; i<=n; i++) {
			if(y[i].v[x_]==1) y[i].b++;
			else y[i].a++;
		}
	} else if(c==2) {
		if(y[x_].a==n) k[jl].p=1;
		else k[jl].p=2;
		for(ll i=1; i<=n; i++) {
			if(x[i].v[x_]==1) x[i].b++;
			else x[i].a++;
		}
	}
}
int main() {
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n;
	for(ll i=1; i<=n; i++)
		for(ll j=1; j<=n; j++) cin>>zxy[i][j];
	for(ll i=1; i<=n; i++) {
		for(ll j=1; j<=n; j++) {
			x[i].v[j]=zxy[i][j];
			if(zxy[i][j]==1) x[i].a++;
			else if(zxy[i][j]==2) x[i].b++;
			else {x[i].f=1;m++;break;}
		}
	}
	for(ll i=1; i<=n; i++) {
		for(ll j=1; j<=n; j++) {
			y[i].v[j]=zxy[j][i];
			if(zxy[j][i]==1) y[i].a++;
			else if(zxy[j][i]==2) y[i].b++;
			else {y[i].f=1;m++;break;}
		}
	}
	while(1) {
		ll p=1;
		for(ll i=1; i<=n; i++) 
			if(x[i].f==0) {
				if(max(x[i].a,x[i].b)==n) {
					exset(1,i);p=0;x[i].f=1;
				}
			}
		for(ll i=1; i<=n; i++) 
			if(y[i].f==0) {
				if(max(y[i].a,y[i].b)==n) {
					exset(2,i);p=0;y[i].f=1;
				}
			}
		if(p==1) break;
	}
	if(jl!=n+n-m) cout<<"-1";
	else {
		for(ll i=jl;i>=1;i--){
			if(k[i].x==1) for(ll j=1;j<=n;j++) o[k[i].z][j]=k[i].p;
			if(k[i].x==2) for(ll j=1;j<=n;j++) o[j][k[i].z]=k[i].p;
		}
		for(ll i=1;i<=n;i++) for(ll j=1;j<=n;j++) 
				if(zxy[i][j]!=o[i][j]){cout<<"-1";return 0;}
		
		cout<<jl<<"\n";
		for(ll i=jl;i>=1;i--) cout<<k[i].x<<" "<<k[i].z<<" "<<k[i].p<<"\n";

	}
	return 0;
}

```

---

## 作者：chenzhiyou12 (赞：1)

Tag：模拟。

不难发现，我们可以倒着删除最后的笔画，然后按删除的顺序倒序输出。这样做的好处是，如果有解，选择每次删掉的行（列）变得更方便了（直接判断这个行（列）在之前删完之后，是否都为一种颜色即可）。

之后只需要处理每次删除一个行（列）会产生什么影响。不难发现，如果删除一个行，就会对所有的列造成该颜色数量减一的贡献，开一个数组记录一下即可。列同理。

然后就是代码实现了，自认为实现的不错（尽量减少了一下码量），有一定参考价值。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
#define vi vector<int>
#define pb push_back
#define For(i,j,k) for(int i=j;i<=k;++i)
#define Rof(i,j,k) for(int i=j;i>=k;--i)
using namespace std;
const int N=2e3+10;
int n,m,a[N][N],cnt[3][N][2],d[3][2];
//cnt[i][j][k] 表示第j行（如果i是1是行，是2是列），颜色k的数量（0表示红色，1表示蓝色）
//d[i][j] 表示行（如果i是1是行，是2是列）被减去的颜色j的数量
bool st[3][N];
//st[i][j] 表示第j行（如果i是1是行，是2是列），是否已经被删除
struct opt{int typ,id,c;}ans[N<<1]; 
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL),cout.tie(NULL);
    cin>>n;
    For(i,1,n){For(j,1,n){cin>>a[i][j];}}
    For(i,1,n){
        For(j,1,n){if(a[i][j]){cnt[1][i][a[i][j]-1]++;}}
        For(j,1,n){if(a[i][j]){cnt[2][j][a[i][j]-1]++;}}
    }
    For(r,1,n){//最多删n轮
        bool flg1=false,flg2=false;
        //flg1表示是否还有颜色，flg2表示该轮是否成功的删除了某行或者某列
        For(tt,1,2){//枚举行，列
            For(i,1,n){//枚举行（列）的编号
                if(st[tt][i]){continue;} // 不操作已经删过的
                For(cc,0,1){ //枚举颜色
                    if(cnt[tt][i][cc]-d[tt][cc]==n-d[tt][0]-d[tt][1]&&cnt[tt][i][cc]-d[tt][cc]!=0&&!(cnt[tt][i][1-cc]-d[tt][1-cc])){
                    //可以删的条件是有颜色需要删，且这种颜色的数量等于删完之后行（列）剩余的格子数量。
                        d[3-tt][cc]++,st[tt][i]=true,flg2=true;
                        ans[++m]={tt,i,cc+1};
                    }
                    if(cnt[tt][i][cc]-d[tt][cc]!=0||cnt[tt][i][1-cc]-d[tt][1-cc]!=0){flg1=true;}
                }
            }
        }
        if(flg1&&!flg2){
        //有颜色但是没有操作，说明无解了
            cout<<-1<<'\n';
            return 0;
        }
        if(!flg1){break;}
    }
    cout<<m<<'\n';
    Rof(i,m,1){cout<<ans[i].typ<<' '<<ans[i].id<<' '<<ans[i].c<<'\n';}
    return 0;
}
```

---

## 作者：Little_x_starTYJ (赞：1)

### 解题思路
首先看完题目，然后发现很难，接着开始写代码，最后一片青青草原。

考虑倒着思考。最后一次操作一定会让某一行/列全部为 $1$ 或者全部为 $2$，那么我们每一次只需要删除全为 $1$ 或者全为 $2$ 的行/列，一直到不能操作，然后判断整个地图是否全是 $0$ 即可。

如果我们直接暴力删除其实是不好模拟的，所以我们用两个变量来表示地图剩下的行数、列数，然后将删除的行/列全部赋值为 $-1$，代表当前点不可用，最后统计的时候判断是否全是 $-1,0$ 即可。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[2010][2010], h[2010][10], l[2010][10];
struct node {
	int a, b, c;
};
bool vish[2010], visl[2010];
vector<node> v;
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n;
	cin >> n;
	int hh = n, ll = n;
	for (int i = 1; i <= n; i++) {
		vish[i] = visl[i] = 1;
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
			h[i][a[i][j]]++;
			l[j][a[i][j]]++;
		}
	}
	while (hh && ll) {
		bool flag = false;
		for (int i = 1; i <= n; i++) {
			if (vish[i]) {
				for (int j = 1; j <= 2; j++) {
					if (h[i][j] == ll) {
						vish[i] = 0;
						v.push_back({1, i, j});
						flag = true;
						for (int k = 1; k <= n; k++) {
							l[k][j]--;
							a[i][k] = -1;
						}
						hh--;
					}
				}
			}
		}
		if (!hh) {
			break;
		}
		for (int i = 1; i <= n; i++) {
			if (visl[i]) {
				for (int j = 1; j <= 2; j++) {
					if (l[i][j] == hh) {
						visl[i] = 0;
						flag = true;
						v.push_back({2, i, j});
						for (int k = 1; k <= n; k++) {
							a[k][i] = -1;
							h[k][j]--;
						}
						ll--;
					}
				}
			}
		}
		if (!flag) {
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					if (a[i][j] > 0) {
						cout << "-1\n";
						return 0;
					}
				}
			}
			break;
		}
	}
	cout << v.size() << "\n";
	for (int i = v.size() - 1; i >= 0; i--) {
		cout << v[i].a << ' ' << v[i].b << ' ' << v[i].c << "\n";
	}
	return 0;
}
```

---

## 作者：Ybll_ (赞：1)

# 题意：

给你一个 $n\times n$ 的目标矩阵，你可以在某一列或某一行刷上 $1$ 或 $2$（颜色会被**覆盖**），给出一种可以从白墙刷成目标矩阵的方案。

# 思路：

每次判断是否有一列或者一行只有 $1$ 或 $2$，如果有，直接扒下来删掉，没有就看剩下的是不是全为 $0$，如果不是，该方案无解，输出 $-1$。

具体做法就是记录下每一列和每一行的 $0$，$1$，$2$ 的个数，然后写一个 `checkk()` 函数，扫一遍，判断还能不能删数，能得话继续删，不能就判断是否有接。

如果要删除某一列，给这一列的剩下的 $1$ 或 $2$ 的个数赋值为 $0$，暴力看每一行，将这一行剩下的 $1$ 或 $2$ 的个数减一。

删除某一行时同理。

# 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct ans{int a,b,c;}ans[4005];
int n,a[2005][2005],w[3][2005],h[3][2005],cnt;
bool check(){
	bool flag=0;
	for(int i=1;i<=n;i++){
		if((w[1][i]>0&&w[2][i]==0||w[2][i]>0&&w[1][i]==0)&&w[0][i]==0||(h[1][i]>0&&h[2][i]==0||h[2][i]>0&&h[1][i]==0)&&h[0][i]==0)return 1;//有一列或有一行全是1或2，返回1继续删
		if(w[1][i]>0||w[2][i]>0||h[1][i]>0||h[2][i]>0)flag=1;//如果剩下的数不全是零，为后面判断是否有解做准备
	}
	if(flag){//无解，输出-1跑路
		cout<<-1;
		exit(0);
	}
	return 0;//删完了，返回0输出答案
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>a[i][j],w[a[i][j]][i]++,h[a[i][j]][j]++;//记录每一列和每一行0，1，2的个数
	while(check()){
		for(int i=1;i<=n;i++){//删行
			if(w[0][i]>0||w[1][i]>0&&w[2][i]>0)continue;//有0或者既有1又有2
			if(w[1][i]>0){//全是1
				ans[++cnt]={1,i,1},w[1][i]=0;
				for(int i=1;i<=n;i++)h[1][i]--;
			}
			if(w[2][i]>0){//全是2
				ans[++cnt]={1,i,2},w[2][i]=0;
				for(int i=1;i<=n;i++)h[2][i]--;
			}
		}
		for(int i=1;i<=n;i++){//删列
			if(h[0][i]>0||h[1][i]>0&&h[2][i]>0)continue;//有0或者既有1又有2
			if(h[1][i]>0){//全是1
				ans[++cnt]={2,i,1},h[1][i]=0;
				for(int i=1;i<=n;i++)w[1][i]--;
			}
			if(h[2][i]>0){//全是2
				ans[++cnt]={2,i,2},h[2][i]=0;
				for(int i=1;i<=n;i++)w[2][i]--;
			}
		}
	}
	//下面就是输出答案了
	cout<<cnt;
	for(int i=cnt;i>0;i--)cout<<"\n"<<ans[i].a<<" "<<ans[i].b<<" "<<ans[i].c;
	return 0;
}
```

---

## 作者：gghack_Nythix (赞：1)

## 前言：

简单题，一遍就过了。

## 分析：

首先我们可以求出最后一批染色的行或者列，这个只需要判断一行或者一列上是否全都是有颜色且颜色相同的。

然后染完最后一批行或者列之后，我们多出来了一些不确定颜色的格子，这些格子可以填任意颜色，因为原矩阵中这些位置是被最后一批行或者列的颜色挡住了的。

处理这些不确定的格子，不妨将他们假设成一种通用颜色，既可以充当任何颜色的颜色。

然后每次染完一行或者一列之后，影响到的只可能是所有列或者行，每次更新一下这些列或者行的颜色个数，一旦某种颜色个数又为 $n$ 了，就把他也加入染色，这样一直重复即可得到答案。

实现的时候用个堆维护，然后标记一下哪些行或者列已经扔到堆里面去了，这些直接跳过不管。最后我们得到一个操作序列，倒过来就是我们所求的。

至于无解，你按照操作序列染一下色再与原矩阵比较一下即可。

时间复杂度是 $\mathcal{O(n^2 \log n)}$，能过。

```cpp
# include <bits/stdc++.h>
# define pb push_back
# define mk make_pair
using namespace std;
const int N = 5000;
struct node {
    int rc , op , z , zl;
    bool operator < (const node & hh) const {return z > hh.z;}
};
priority_queue <node> q;
int n , a[N][N] , b[N][N] , hang[N][3] , lie[N][3];
bool vishang[N] , vislie[N];
vector <pair<int , pair <int , int> > > seq;
signed main () {
    cin >> n;
    for (int i = 1;i <= n;++i) for (int j = 1;j <= n;++j) 
    cin >> a[i][j];
    for (int i = 1;i <= n;++i) {
        int tot[3];
        tot[0] = tot[1] = tot[2] = 0;
        for (int j = 1;j <= n;++j) tot[a[i][j]] ++ , hang[i][a[i][j]] ++;
        if (tot[1] == n || tot[2] == n) q.push (node{i , 0 , 0 , (tot[1] == n ? 1 : 2)}) , vishang[i] = 1;
    }
    for (int j = 1;j <= n;++j) {
        int tot[3];
        tot[0] = tot[1] = tot[2] = 0;
        for (int i = 1;i <= n;++i) tot[a[i][j]] ++ , lie[j][a[i][j]] ++;
        if (tot[1] == n || tot[2] == n) q.push (node{j , 1 , 0 , (tot[1] == n ? 1 : 2)}) , vislie[j] = 1;
    }
    while (!q.empty()) {
        node tp = q.top();
        q.pop();
        seq.pb (mk (tp.op + 1 , mk (tp.rc , tp.zl) ) );
        if (tp.op == 0) {
            for (int i = 1;i <= n;++i) 
            lie[i][0] += tp.zl == 0 ? 0 : 1 , 
            lie[i][1] += tp.zl == 1 ? 0 : 1 , 
            lie[i][2] += tp.zl == 2 ? 0 : 1 ;
            for (int i = 1;i <= n;++i) {
                if (lie[i][1] == n  && !vislie[i]) q.push (node{i , 1 , tp.z + 1 , 1}) , vislie[i] = 1;
                else if (lie[i][2] == n  && !vislie[i]) q.push (node{i , 1 , tp.z + 1 , 2}) , vislie[i] = 1;
            }
        } 
        else {
            for (int i = 1;i <= n;++i) 
            hang[i][0] += tp.zl == 0 ? 0 : 1 , 
            hang[i][1] += tp.zl == 1 ? 0 : 1 , 
            hang[i][2] += tp.zl == 2 ? 0 : 1 ;
            for (int i = 1;i <= n;++i) {
                if (hang[i][1] == n && !vishang[i]) q.push (node{i , 0 , tp.z + 1 , 1}) , vishang[i] = 1;
                else if (hang[i][2] == n && !vishang[i]) q.push (node{i , 0 , tp.z + 1 , 2}) , vishang[i] = 1;
            }
        }
    }
    reverse (seq.begin() , seq.end());
    for (auto x : seq) {
        if (x.first == 1) for (int j = 1;j <= n;++j) b[x.second.first][j] = x.second.second;
        if (x.first == 2) for (int j = 1;j <= n;++j) b[j][x.second.first] = x.second.second;
    }
    for (int i = 1;i <= n;++i) for (int j = 1;j <= n;++j) 
    if (b[i][j] != a[i][j]) return cout << "-1" , 0;
    cout << seq.size() << "\n";
    for (auto x : seq) cout << x.first << " " << x.second.first << " " << x.second.second << "\n";
    return 0;
}
```

---

## 作者：Tracy_Loght (赞：1)

就这还绿题，比某些黄简单。

## 思路：

显而易见的是，对于一行或一列，我们至多进行**一次**操作。

因为假设我们对这一行列图了蓝色，我们再涂红色就覆盖了所有的这一行列上的蓝色。

同理，这也是为什么题目保证 $0\le k\le 4\, 000$。

还注意到，我们只能涂红或蓝，所以白色格子的行列都图涂不了。

然后将所有一行一列都同色的先涂了，则这个下面的格子都是红或蓝的，我们定为任意符。

这里解释一下，就像倒放一样，后涂的先判了，最后将倒放的倒放，就是答案了。

显然，我们在将一行一列上颜色一定或为任意符的再涂了即可。

反复反复的涂，由于答案最多 $4000$ 个，则不会超时。

## 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,jl,zxy[3001][3001],o[3001][3001];
struct {
	ll v[3001],a,b,f;
} x[3001],y[3001];
struct {
	ll x,z,p;
} k[4000001];
void exset(ll c,ll x_) {
	jl++;
	k[jl].x=c;
	k[jl].z=x_;
	if(c==1) {
		if(x[x_].a==n) k[jl].p=1;
		else k[jl].p=2;
		for(ll i=1; i<=n; i++) {
			if(y[i].v[x_]==1) y[i].b++;
			else y[i].a++;
		}
	} else if(c==2) {
		if(y[x_].a==n) k[jl].p=1;
		else k[jl].p=2;
		for(ll i=1; i<=n; i++) {
			if(x[i].v[x_]==1) x[i].b++;
			else x[i].a++;
		}
	}
}
int main() {
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n;
	for(ll i=1; i<=n; i++)
		for(ll j=1; j<=n; j++) cin>>zxy[i][j];
	for(ll i=1; i<=n; i++) {
		for(ll j=1; j<=n; j++) {
			x[i].v[j]=zxy[i][j];
			if(zxy[i][j]==1) x[i].a++;
			else if(zxy[i][j]==2) x[i].b++;
			else {x[i].f=1;m++;break;}
		}
	}
	for(ll i=1; i<=n; i++) {
		for(ll j=1; j<=n; j++) {
			y[i].v[j]=zxy[j][i];
			if(zxy[j][i]==1) y[i].a++;
			else if(zxy[j][i]==2) y[i].b++;
			else {y[i].f=1;m++;break;}
		}
	}
	while(1) {
		ll p=1;
		for(ll i=1; i<=n; i++) 
			if(x[i].f==0) {
				if(max(x[i].a,x[i].b)==n) {
					exset(1,i);p=0;x[i].f=1;
				}
			}
		for(ll i=1; i<=n; i++) 
			if(y[i].f==0) {
				if(max(y[i].a,y[i].b)==n) {
					exset(2,i);p=0;y[i].f=1;
				}
			}
		if(p==1) break;
	}
	if(jl!=n+n-m) cout<<"-1";
	else {
		for(ll i=jl;i>=1;i--){
			if(k[i].x==1) for(ll j=1;j<=n;j++) o[k[i].z][j]=k[i].p;
			if(k[i].x==2) for(ll j=1;j<=n;j++) o[j][k[i].z]=k[i].p;
		}
		for(ll i=1;i<=n;i++) for(ll j=1;j<=n;j++) 
				if(zxy[i][j]!=o[i][j]){cout<<"-1";return 0;}
		
		cout<<jl<<"\n";
		for(ll i=jl;i>=1;i--) cout<<k[i].x<<" "<<k[i].z<<" "<<k[i].p<<"\n";

	}
	return 0;
}

```

---

## 作者：tiantianyang (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11476)
### 题目大意
给你一个 $n\times n$ 的墙壁，让你涂上一或者二且可以覆盖，问你可行的方案，不必要最小。
### 思路
因为刷过的墙可以被覆盖，所以如果正着推肯定很难，因此我们可以考虑**逆推**。

我们每一次判断在一列或一行上有没有只有一或二只有一种的，如果存在的话，就把这一列或一行扒下来不看！如果到最后有落单的数字无法改变，就说明无解否则我们就逆序输出答案。

具体的做法就是将每一行每一列一、二、零的个数记下来，再通过一个查找函数判断是否可以扒下来。然后把这一列或一行给打上标记（就是相当于删除）最后再判断是否又不是零且没有打标记的，就说明无解，不然逆序输出。
### 代码
```
#include<bits/stdc++.h>//c++14
using namespace std;
typedef pair<int, int> pii;
const int N=2e3+5;
int n,val;
int cnt[3][N][3],a[N][N];// cnt记录行列0、1、2的个数 a是输入数组 
bool painted[N][N];//代表已经涂过的 
vector<pair<int, pii>> ans;//存储答案 
int check(int way,int opt){//判断一行或一列是否只有一或二 
	if(cnt[opt][way][0]!=0) return 0;
	if(cnt[opt][way][1]!=0&&cnt[opt][way][2]!=0) return 0;
	if(cnt[opt][way][1]) return 1;
	if(cnt[opt][way][2])  return 2;
	return 0;
}
void paint_one(int x,int y){//把单个打上标记 
	if(painted[x][y]) return ;
	painted[x][y]=1;
	cnt[1][x][a[x][y]]--;cnt[2][y][a[x][y]]--;//打上标记后将对应数组的个数减一 
}
void paint_all(int way,int opt,int color){//把一行或一列打上标记 
	ans.push_back({opt,{way,color}});
	for(int i=1;i<=n;i++){
		if(opt==1) paint_one(way,i);
		else if(opt==2) paint_one(i,way);
	}
	for(int i=1;i<=n;i++) {//在不同的行列递归判断 
		if(opt==1){
			if((color=check(i,2))) paint_all(i,2,color);
		}else if(opt==2){
			if((color=check(i,1))) paint_all(i,1,color);
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); 
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){cin>>a[i][j];cnt[1][i][a[i][j]]++;cnt[2][j][a[i][j]]++;}//1代表行 2代表列 
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=2;j++)
			if(val=check(i,j)) paint_all(i,j,val);//判断是否是同一列并且打上标记 
	
	bool good=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) good&=(painted[i][j]||!a[i][j]);//看看是不是每一个非零的数都打上标记 
	
	if(good) {//逆序输出答案 
		cout<<ans.size()<<endl;
		for(int i=ans.size()-1;i>=0;i--) cout<<ans[i].first<<" "<<ans[i].second.first<<" "<<ans[i].second.second<<endl;
	}else cout<<-1<<endl;//否则无解 
	return 0;//完美收官 
} 
```

---

## 作者：ycy1124 (赞：0)

### 题意
我们有一个 $n\times n$ 的全 $0$ 矩阵，现在我们希望用一些将某一行或某一列全部染成 $2,3$ 的操作使其变成目标矩阵并构造方案或输出无解。
### 思路
我们某一行或者某一列一定不会被染色多次，因此操作次数小于等于 $4\times 10^3$ 显然是满足的。我们发现，当我们的当前矩阵有某一行或者某一列均为同一种颜色时，我们显然可以在末尾添加一次操作将这行或列染色掉，然后便可以将这一行或列直接在当前矩阵中删除掉。由于我们是倒序加入操作的，所以并不需要考虑对其它操作的影响。

考虑我们这样一直将可以染色的行或列全部删除直到没有可删除的行或列了该怎么办。我们发现，如果此时还有没有被染色正确的点的话就一定无解了。为什么呢，我们发现，此时无论如何染某一行或列，都一定会有不满足最终矩阵的位置。因此我们只需要一直操作到不能继续操作，再按照找到的操作还原矩阵判断一下与最终矩阵相不相同即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define N 2000 + 39
using namespace std;
int a[N][N], h[3][N], l[3][N], n, c[N][N];
bool vis[2][N];
struct Node
{
	int op, x, color;
};
stack<Node>ans, check;
queue<Node>q;
int main()
{
	ios :: sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i ++)
	{
		for(int j = 1; j <= n; j ++)
		{
			cin >> a[i][j];
			h[a[i][j]][i] ++;
			l[a[i][j]][j] ++;//我们记录每一行每一列0，1，2的个数，这样就能快速找到全1或2的行或列
		}
	}
	for(int i = 1; i <= n; i ++)
	{
		if(h[0][i])//有0一定不能染色
		{
			vis[0][i] = 1;//判断一行或一列能否被染色，有0的显然不行
		}
		else
		{
			if(!h[1][i])
			{
				vis[0][i] = 1;
				q.push({1, i, 2});
			}
			else if(!h[2][i])
			{
				vis[0][i] = 1;
				q.push({1, i, 1});
			}
		}
		if(l[0][i])
		{
			vis[1][i] = 1;
		}
		else
		{
			if(!l[1][i])
			{
				vis[1][i] = 1;
				q.push({2, i, 2}); 
			}
			else if(!l[2][i])
			{
				vis[1][i] = 1;
				q.push({2, i, 1});
			}
		}
	}
	while(q.size())//一直寻找可以被操作的位置
	{
		check.push(q.front());
		ans.push(q.front());
		int op = q.front().op, x = q.front().x, color = q.front().color;
		q.pop();
		if(op == 1)
		{
			for(int i = 1; i <= n; i ++)
			{
				if(vis[1][i])
				{
					continue;
				}
				l[color][i] --;//修改行的时候更新每一列
				if(l[color][i] == 0)
				{
					vis[1][i] = 1;
					q.push({2, i, color == 1 ? 2 : 1});
				}
			}
		}
		else
		{
			for(int i = 1; i <= n; i ++)
			{
				if(vis[0][i])
				{
					continue;
				}
				h[color][i] --;//同理
				if(h[color][i] == 0)
				{
					vis[0][i] = 1;
					q.push({1, i, color == 1 ? 2 : 1});
				}
			}
		}
	}
	while(check.size())//还原一下我们的操作的最终矩阵
	{
		int op = check.top().op, x = check.top().x, color = check.top().color;
		check.pop();
		for(int i = 1; i <= n; i ++)
		{
			if(op == 1)
			{
				c[x][i] = color;
			}
			else
			{
				c[i][x] = color;
			}
		}
	}
	for(int i = 1; i <= n; i ++)
	{
		for(int j = 1; j <= n; j ++)
		{
			if(c[i][j] != a[i][j])
			{
				cout << -1;//不合法输出-1
				return 0;
			}
		}
	}
	cout << ans.size() << '\n';
	while(ans.size())
	{
		cout << ans.top().op << ' ' << ans.top().x << ' ' << ans.top().color << '\n';
		ans.pop();
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/231874372)。

---

## 作者：qwer6 (赞：0)

## 1. Description

给定一个目标矩阵，称将一行或一列**覆盖**为蓝色或红色为一次操作。

问是否可以通过若干次操作将一个全为 $0$ 的矩阵变为目标矩阵，如果可以，那么输出一种可行方案，否则输出 $-1$。

## 2. Solution

发现了操作是覆盖，因此考虑倒着做。

容易发现一整列或一整行都是同一种颜色的一定是最后刷的，那么我们删掉这些行列，然后继续找剩下的一整列或一整行都是同一种颜色的，删掉，重复操作即可，其实过程类似一个拓扑排序。

判断是否合法可以选择将刷了那些行，列记录下来，然后如果一个有颜色的位置对应的行和列都没有被刷的话，就是不合法的方案。

最后倒序输出方案即可。

## 3. Code

```c++
/*by qwer6*/
/*略去缺省源与快读快写*/
const int N=2005;
int n,len,cntline,cntrow;
int a[N][N],line[2][N],row[2][N];
bool visline[N],visrow[N];
struct Node{
	int kind,idx,col;
}ans[N<<1];
signed main(){
	read(n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			read(a[i][j]);
			if(a[i][j]){
				row[a[i][j]-1][i]++;
				line[a[i][j]-1][j]++;
			}
		}
	}
	queue<Node>q;
	cntline=cntrow=n;
	for(int i=1;i<=n;i++){
		if(row[0][i]==n){
			q.push({1,i,0});
			visrow[i]=1;
		}
		if(row[1][i]==n){
			q.push({1,i,1});
			visrow[i]=1;
		}
		if(line[0][i]==n){
			q.push({2,i,0});
			visline[i]=1;
		}
		if(line[1][i]==n){
			q.push({2,i,1});
			visline[i]=1;
		}
	}
	while(!q.empty()){
		Node tmp=q.front();
		q.pop();
		ans[++len]=tmp;
		if(tmp.kind==1){
			cntrow--;
			for(int i=1;i<=n;i++){
				if(visline[i])continue;
				line[tmp.col][i]--;
				if(line[tmp.col^1][i]==cntrow){
					q.push({2,i,tmp.col^1});
					visline[i]=1;
				}
			}
		}else{
			cntline--;
			for(int i=1;i<=n;i++){
				if(visrow[i])continue;
				row[tmp.col][i]--;
				if(row[tmp.col^1][i]==cntline){
					q.push({1,i,tmp.col^1});
					visrow[i]=1;
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j]&&!visrow[i]&&!visline[j]){
				puts("-1");
				exit(0);
			}
		}
	}
	write(len),Nxt;
	for(int i=len;i>=1;i--)
		write(ans[i].kind),Spa,write(ans[i].idx),Spa,write(ans[i].col+1),Nxt;
}
```

---

## 作者：JCT_addyi (赞：0)

### 思路：
如果我们像题目一样模拟的话，暴力肯定会超时，所以我们用**逆向思维**找出只有一种颜色的这一行或列，这样的行或列就可以消掉，注意**白色不能消除**是它原有的底色。

我们用一个数组来存每一行或列，三种情况每种各有多少个，只有一种颜色就是说其余两种是 $0$ 那么我们就消掉将其数值改为 $0$ 然后，与这一行或列相关的行或列的所消除的颜色的数值减一。每消完一行就枚举一下每一列看有没有可以消的，列也一样。最后如果不合法就输出 $-1$ 即可。

### 代码如下：
详细看代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
const int N = 2005;
int n, a[N][N], cnt[N][2][3];
vector<pair<int,pii > > ans;
bool painted[N][N];
int check(int t,int i) {//统计某行或某列是否同色
	if(cnt[i][t][0]) return 0;
	if(cnt[i][t][1]&&cnt[i][t][2]) return 0;
	if(cnt[i][t][1]) return 1;
	if(cnt[i][t][2]) return 2;
	return 0;
}
void paint_cell(int i,int j) {//对一个单元格染色
	if(painted[i][j]) return;
	painted[i][j]=1;
	--cnt[i][0][a[i][j]];
	--cnt[j][1][a[i][j]];
}
void paint_block(int t,int i,int val) {//对一行或一列染色
	ans.push_back({t,{i,val}});
	for(int j=0;j<n;++j)
		if (t) paint_cell(j,i); //判断是行还是列 
		else paint_cell(i,j);
	for(int j=0;j<n;++j) //把对应的行（列）中的数删去 
		if((val=check(t^1,j))) paint_block(t^1,j,val);
}
int main() {
//	freopen("paint.in","r",stdin);
//	freopen("paint.out","w",stdout);
	cin>>n;
	for(int i=0;i<n;++i)
		for(int j=0;j<n;++j){
			cin >> a[i][j];
			++cnt[i][0][a[i][j]];//行++
			++cnt[j][1][a[i][j]];//列++
		}
	for(int i=0;i<n;++i)
		for(int val,type=0;type<2;++type)
			if((val=check(type,i))) paint_block(type,i,val); //一整行完整的 
	bool good=1;
	for(int i=0;i<n;++i)
		for(int j=0;j<n;++j) good&=painted[i][j]||!a[i][j]; //判断是否合法 
	if(good){
		cout<<ans.size()<<"\n";
		for(int j=ans.size()-1;j>=0;j--)
			cout<<ans[j].first+1<<" "<<ans[j].second.first+1<<" "<<ans[j].second.second<<"\n";
	}
	else cout<<"-1\n";
	return 0;
}
```

谢谢大家！

---

## 作者：Emplace (赞：0)

## 思路
此题如果直接硬构造，肯定非常困难，那不妨另辟蹊径。

我们显然可以在目标矩阵中发现一些完整的行和列，那么这些绝对是最后再整个涂。因为是最后整个涂，那我们直接~~孤立~~无视它，再看其它的。那看的时候跟前面一个道理（如果你找不到，那就是无解）。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[3000][3000],col[3000][3000],ans[3000][4],sum;
int cnt[3][3][3000]; 
int check(int type,int id){
 //   cout<<cnt[0][type][id]<<" "<<cnt[1][type][id]<<" "<<cnt[2][type][id]<<endl;
	if(cnt[0][type][id]){
		return 0;
	} 
	if(cnt[1][type][id]&&cnt[2][type][id]){
		return 0;
	} 
	if(cnt[1][type][id]){
		return 1;
	}
	if(cnt[2][type][id]){
		return 2;
	}
    return 0;
}
void pain_t(int colour,int i,int j){
	if(col[i][j]) return ;
	col[i][j]=colour;
	cnt[colour][1][i]--;
	cnt[colour][2][j]--;
}
void paint(int colour,int type,int id,int ZhiYang_in_Jiujiang){
	//cout<<colour<<" "<<type<<" "<<id<<" "<<ZhiYang_in_Jiujiang<<endl;
	ans[++sum][1]=type,ans[sum][2]=id,ans[sum][3]=colour;
	for(int i=1;i<=n;i++){
		if(type==1) pain_t(colour,id,i);
		if(type==2) pain_t(colour,i,id);
	} 
//	cout<<cnt[0][2][2]<<endl;
	for(int i=1;i<=n;i++){
	//	cout<<((type-1)^1+1)<<" "<<i<<endl;
		if(check((((type-1)^1)+1),i)) paint(check(((type-1)^1)+1,i),((type-1)^1)+1,i,id);
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			cnt[a[i][j]][1][i]++;
			cnt[a[i][j]][2][j]++;
		}
	}
	//cout<<cnt[1][2][2]<<endl;
	for(int i=1;i<=n;i++){
		if(check(1,i)) /*cout<<1<<" "<<i<<endl,*/paint(check(1,i),1,i,114);
		if(check(2,i)) paint(check(2,i),2,i,114);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
//			cout<<col[i][j]<<" ";
			if(!col[i][j]&&a[i][j]){
				cout<<-1;
				return 0;
			}
		}
	//	cout<<endl;
	}
	cout<<sum<<endl;
	for(int i=sum;i>=1;i--){
		cout<<ans[i][1]<<" "<<ans[i][2]<<" "<<ans[i][3]<<endl;
	}
	return 0;
}
 
```

---

## 作者：Igallta (赞：0)

## 思路

### 前言

拿到这道题之后我们通常先思考正着怎么做。

我们发现正着做很难做，所谓正难则反，我们便考虑倒着做。

既然正着做是给一行或者一列涂色，那么倒着做就是给一行或者一列撤销，看最后能不能变成一个白板。

### 什么时候撤销？怎么撤销？

我们可以考虑撤销我们目前显然可以撤销的行、列。

如果一个行、列只有一个颜色（但不能全无色）的时候，你就可以撤销它们。

那么为什么撤销之后这一列可以看作被删除？

因为前面刷的颜色总是会被后面刷的颜色覆盖掉，我撤销了这一次刷颜色那就相当于让覆盖掉的颜色重见天日。但因为我不好实现直接让被覆盖掉的颜色填在现在撤销的位置。所以我便可以看作把那一列删除。

### 怎么判断无解？

只需要在删除的同时记录哪些格子被撤销，最后循环枚举每一个格子，如果这个格子如果本来有颜色但没有被撤销成功那就是无解。（反之：这个格子无色或者有颜色被撤销就是合法的）

## 代码

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#define int long long
#define PYY pair<int,int>
#define x first
#define y second
#define LL k<<1
#define RR k<<1|1
#define emp emplace_back
using namespace std;
using namespace __gnu_pbds;
const int N = 2e3 + 1;
int n, a[N][N], cnt[2][N][3];
bool isp[N][N], en ;
stack<pair<int, pair<int, int>>>st;
int color(int tp, int x) {
	int c0 = cnt[tp][x][0], c1 = cnt[tp][x][1], c2 = cnt[tp][x][2];
	if (c0 > 0)return 0;
	if (c1 > 0 && c2 > 0)return 0;
	if (c1 > 0)return 1;
	if (c2 > 0)return 2;
	return 0;
}
void del(int x, int y) {
	if (!isp[x][y]) {
		isp[x][y] = 1;
		cnt[0][x][a[x][y]]--;
		cnt[1][y][a[x][y]]--;
	}
}
signed main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
			cnt[0][i][a[i][j]]++;
			cnt[1][j][a[i][j]]++;
		}
	}
	do {
		en = 0;
		for (int i = 1; i <= n; i++) {
			int tp = color(0, i), pt = color(1, i);
			if (tp) {
				st.push({1, {i, tp}});
				en = 1;
				for (int j = 1; j <= n; j++) {
					del(i, j);
				}
			}
			if (pt) {
				st.push({2, {i, pt}});
				en = 1;
				for (int j = 1; j <= n; j++) {
					del(j, i);
				}
			}
		}

	} while (en);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (!(!a[i][j] || (a[i][j] && isp[i][j]))) {
				cout << -1;
				return 0;
			}
		}
	}
	cout<<st.size()<<"\n";
	while (st.size()) {
		pair<int, pair<int, int>>tmp = st.top();
		st.pop();
		cout << tmp.x << ' ' << tmp.y.x << ' ' << tmp.y.y << '\n';
	}
	return 0;
}
```

---


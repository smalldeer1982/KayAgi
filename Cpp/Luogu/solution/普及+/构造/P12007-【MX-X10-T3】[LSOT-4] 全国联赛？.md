# 【MX-X10-T3】[LSOT-4] 全国联赛？

## 题目背景

> 你真的以为我们能打进全国联赛吗？

## 题目描述

北宇治的吹奏部一共有 $n$ 个学生，学生的编号为 $1$ 到 $n$。在泷昇到来之前已经建立了 $m$ 对配合关系（$0 \le m \le n - 1$），每对配合关系 $u,v,w$ 表示在 $u$ 或 $v$ 演奏后另一人能在 $w$ 单位的时间后立刻演奏完成配合。若两人没有直接的配合关系，也可以通过多次的配合关系来间接完成配合，他们造成的误差时间是中间每次配合花费的时间之和。

现在的吹奏部简直乱的像一盘散沙！为此，泷昇有 $n-m-1$ 种特训方案。第 $i$ 种方案可以让任意两个成员建立配合关系，最终训练的效果能让二人在 $a_i$ 的时间内完成配合。定义不协调度为对于所有的 $1\le x<y\le n$，$x,y$ 之间误差时间的最小值的和。如果有两个成员在最后无法配合，则认为不合法。为了打进全国联赛，他希望不协调度尽量的小。

请告诉泷昇这个最优的不协调度。数据保证一定存在至少一种合法的方案。因为结果可能很大，你只需要输出不协调度对 $10^9+7$ 取模的值。

## 说明/提示

**【样例解释 #1】**

之前的配合关系形如：

![](https://cdn.luogu.com.cn/upload/image_hosting/t66wfiko.png)

最优秀的训练方式训练之后的配合关系形如：

![](https://cdn.luogu.com.cn/upload/image_hosting/mxc2d4v2.png)

这样的话，$(1,7)$ 的误差时间的最小值是 $4$，方案是通过 $(1,2)$、$(2,3)$、$(3,7)$ 依次进行配合。

类似的，所有误差时间之和是 $76$。

可以证明不存在更优秀的合法方案。

**【数据范围】**

**本题采用捆绑测试。**

- 子任务 1（13 分）：$n\le 6$。
- 子任务 2（22 分）：$n\le 2000$。
- 子任务 3（18 分）：在建立新的配合关系前，任意两个可以配合的成员都可以通过不超过一个中间的成员间接配合。
- 子任务 4（19 分）：$a_i=0,w=1$。
- 子任务 5（15 分）：$a_i$ 全部相同。
- 子任务 6（13 分）：无特殊性质。

对于全部的数据，$0\le m<n\le 10^6$，$0\le a_i,w\le 10^6$，$1\le u,v\le n$。

## 样例 #1

### 输入

```
7 3
1 2 1
3 5 3
3 7 2
1 2 3
```

### 输出

```
76
```

## 样例 #2

### 输入

```
14 9
8 9 539682
14 4 470495
10 7 265900
14 5 234094
1 9 255217
7 1 559336
7 6 883781
7 13 679978
11 1 598746
433139 142690 902471 766101
```

### 输出

```
108274449
```

# 题解

## 作者：Chiesl (赞：9)

**修改：2025.4.12，经提醒，修正状态转移方程中的一处笔误。**

## 题意简述

有一张有 $n$ 个节点，$n - 1$ 条边的无向无环图（说白了就是一棵树，至于为什么后文会证明），已知 $m$ 条边的起点，终点以及边权，还有剩下的 $n - m - 1$ 条边的边权，求所有可能的树中任意两点的距离的和最小。

## 分析题目

我们将每个成员抽象成点，每个关系抽象成一条带权边，那我们的目标就是确定一张使得其中任意两个成员的距离的和最小的图。

不难发现，最后得到的目标图一定是一棵树，为什么呢？

首先，初始已经确定了 $m$ 条边，我们发现将 $n - m - 1$ 条边全部确定以后，一共有 $n - 1$ 条边，并且根据题目题目中 **如果有两个成员在最后无法配合，则认为不合法** 以及 **数据保证一定存在至少一种合法的方案** 的表述，我们发现，最后形成的图一定是一个有着 $n$ 个节点，$n - 1$ 条边的无向连通图，也就是说其中一定没有环，有环则必不连通，那么需要得到的目标图其实也就是一棵可爱的树。

那么初始的输入里也不可能存在环。也就是说，我们会得到一颗颗小树，然后通过 $n - m - 1$ 次“两树合并”得到最终的目标树。

## 解题思路

### 状态转移方程

我们不妨逆向思维一下，假设一些东西已经知道了，那就可以愉快的开始动态规划了 awa。

我们现在先考虑有两棵树，用一条权为 $w$ 边将它们的根节点相连，组成的新树中，任意两点的距离的和为多少？

我们设 $f_u$ 表示以 $u$ 为根的子树中，所有节点到 $u$ 的距离的和，$F_u$ 表示以 $u$ 该子树中任意两点的距离的和（假设已知，求法下文给出）。

设将要合并的两棵棵树的根节点分别为 $u$，$v$，节点数分别为 $c_u$，$c_v$，设新树的根节点为 $root$，那么连接 $u$，$v$ 合并这两棵树后，新树的的 $F_{root}$ 满足以下状态转移方程：

- $F_{root} = F_u + F_v + f_u \times c_v + f_v \times c_u + c_u \times c_v \times w$

应该不难理解（知道你很急，怎么不写 $f$ 的递推式？但是你先别急，下文介绍）。

从此处我们可以看出，先不考虑 $w$，因为两棵树的 $c_u$ 与 $c_v$ 是确定的，但是根节点的选择却会影响 $f_u$ 与 $f_v$ 的值，所以我们要将其最小化以取得最优，即选择最小的根节点使得树中所有点到根节点的距离的和最小，也就是树的重心。

假定 $u$，$v$ 是树的重心，那么新的 $root$ 一定是 $u$，$v$ 中的一个，不妨假设 $c_u > c_v$（毕竟不满足可以交换），那么 $root$ 一定是 $u$，通过选择 $u$ 与 $v$ 的 $f$ 的不同的转移方程可以看出：

- $f_{root} = f_u + f_v + c_v \times w$ 选择 $u$
- $f_{root} = f_u + f_v + c_u \times w$ 选择 $v$

由于 $c_u > c_v$，所以上面那个肯定更优，所以上面的式子就是 $f$ 的状态转移方程。

用这样不断地转移，最后只剩下一棵树那就是目标答案了。

此时读者可能要掀桌子了，你还没写许多关键的东西呢，怎么初始化、怎么安排合并的顺序以及 $w$，空写一个方程在这有什么用呢？请耐心看，非常感谢 qwq。

### 初始化

首先是 $f$ 的初始化，其实一个小小的换根 DP 就解决了。那至于 $F$，其实是不用算出来的，准确的说，是不用把每个小小树（昵称）的 $F$ 算出来，反正最后都是加到 $ans$ 里的总量，所以算个总量即可，至于后面合并转移的时候，只需要将 $ans$ 加上 $f_u \times c_v + c_v \times c_u + c_u \times c_v \times w$ 就行了，稍稍改变状态转移方程，每次合并直接让 $ans$ 增加，且只递推 $f$ 就行了。

至于初始的 $ans$，它是这样算的：

- $ans = \frac{1}{2} \times \sum\limits_{i = 1} ^ n f_i$

乘上 $\frac{1}{2}$ 是因为算了两次，即 $dist(u, v)$ 与 $dist(v, u)$ 各算了一次。

### 合并顺序及边的安排

那么你肯定发现了，答案的值也会与合并的顺序以及选择的边有关，不能随便乱合并，那么究竟如何最优化呢？

首先，让越小的边承担越多的“行走”，即出现在两点间最短路的次数最多。

那么就是说最后合并两个剩下的最大的树时用最小的边权吗？当然不是！很显然首先是越早供合并用的边的承担的越多，其次才是供越大的两个树合并的边承担的越多。

为什么呢？你想，我们之前说了，新合成的树的重心会是原来那个树中点较多的一棵树的重心 $u$，那么此后假设有新的一棵树 $T$，其点数为 $c_t$ 与该树合并，那么未选择的 $v$ 及其子树都将经过合并用的边去与 $T$ 上的每个节点联系，那么这条边就会被多经过 $c_v \times c_t$ 次，此后也是如此。

读到此处，如果你觉得大彻大悟了，遍可开始自己着手写代码了，如果不知道具体如何设计程序可继续往下看。

## 程序设计

### 初始化 & 小小树的存储

前文所提的初始化很容易想到一遍循环遍历 $n$ 个点去做换根 DP，只需要把每次经过的点标记下来就行，遇到之前已经经过的点就不做换根了，因为它包含在其他子树当中。这样就可以计算出初始时所有的 $f_u$ 了（$1 \le u \le n$）。然后记录在每个小小树中最小的 $f$。实际程序实现时，只需要知道一个值就行，甚至不需要知道重心是哪个点。

这个过程，其实说白了就是求每个小小树的重心，然后用结构体储存下来该树所有点到重心的距离的和，放进优先队列里，以该树的节点数为关键字，后文要做“合并石子”。这一段的时间复杂度 $O(n)$，也就是换根 DP 的时间复杂度，即每个点只经过一次。

算初始 $ans$ 时，有一个小细节，要取模，不然会喜提 WA。然后就是对 $\sum\limits_{i = 1} ^ n f_i$ 取模 $p$ 时，你会惊喜的发现有可能出现取模完变奇数的情况，此时直接除以二肯定炸了，还是难逃一 WA，所以将除以二变成乘以 $500000004$，这是 $2$ 在模 $10 ^ 9 + 7$ 意义下的逆元。

对于未确定的 $n - m - 1$ 条边，从小到大排序即可，前文有讲述原因。

### “合并石子”

我们发现，接下来的过程就像极了合并石子，每次取两个节点数最多的“石子”合并，刚好合并 $n - m - 1$ 次后，就只剩下最后一棵我们所需要的大树了。

当然，可以不用优先队列，说白了就是一路从大合到小，比赛时脑子不清醒打了优先队列，而且好像确实蛮方便的 awa。

讲到这里，是不是可以自己实现了？如果实在还有不明白的地方就请观看代码吧！

虽然蒟蒻的码风并不喜人，但是还是添加了足够的注释以备神犇观看的 qwq。

## 代码如下

优先队列：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6 + 5;
const ll p = 1e9 + 7, inv2 = 5e8 + 4;//模数与逆元
struct node {
	ll w;
	int nxt, to;
} edge[N << 1];
struct Node {
	ll f, cnt;//分别表示该树所有点到重心的距离和与该树的点数
	inline bool operator < (const Node &b) const {return cnt < b.cnt;}//重载运算符，以该树的点数为关键字
} a;//描述一棵树
bool vis[N];
priority_queue<Node> q;//默认大根堆
ll f[N], size[N], F[N], ans, w[N];
int n, m, head[N], tot, res, rt;
inline bool cmp (Node x, Node y) {return x.cnt > y.cnt;}
void add (int from, int to, ll w) {
	edge[++tot].nxt = head[from];
	edge[tot].to = to;
	edge[tot].w = w;
	head[from] = tot;
}//链式前向星应该都会吧？
void dfs1 (int u, int pa) {
    size[u] = 1, res++;
    for (int i = head[u], v; i; i = edge[i].nxt) {
		v = edge[i].to;
		if (v == pa) continue;
		dfs1(v, u), size[u] += size[v];
		f[u] += f[v] + size[v] * edge[i].w;
	}
}//第一次 dfs
void dfs2 (int u, int pa) {
	vis[u] = true;
	for (int i = head[u], v; i; i = edge[i].nxt) {
		v = edge[i].to;
		if (v == pa) continue;
		f[v] = f[u] + (res - 2 * size[v]) * edge[i].w;
		if (f[v] < a.f) a.f = f[v];
		dfs2(v, u);
	}
}//第二次 dfs，换根求重心应该都会吧？
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v, w; i <= m; i++) scanf("%d%d%d", &u, &v, &w), add(u, v, w), add(v, u, w);//无向边建俩
	for (int i = 1; i <= n - m - 1; i++) scanf("%lld", &w[i]);//输入
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			res = 0, dfs1(i, 0), a.f = f[i], dfs2(i, 0), a.cnt = res;//记录小小树
			q.push(a);//上文所述的具体实现
		}
	}
	for (int i = 1; i <= n; i++) ans = (ans + f[i]) % p;
	ans = (ans * inv2) % p;//初始答案
	Node u, v;
	sort(w, w + n - m);
	for (int i = 1; i <= n - m - 1; i++) {
		u = q.top(), q.pop(), v = q.top(), q.pop();/*取当前节点数最多的两个树出来
		（其实说白了就是从大合到小，一直合，也可以不用优先队列来实现，看个人，用优先队列其实不好
		可以按节点数从大到小排序以后直接和，比这个快很多，堆的操作也是有时间复杂度的）*/
		ans = (ans + u.f * v.cnt % p + v.f * u.cnt % p + u.cnt * v.cnt * w[i] % p) % p;//状态转移方程的程序实现
		u.f = ((u.f + v.cnt * w[i]) % p + v.f) % p, u.cnt = (u.cnt + v.cnt) % p;//新的树的各种信息更新
		q.push(u);//合并好的树继续放入堆中
	}//类似于合并石子
	printf("%lld", ans);
    return 0;
}
```

不使用优先队列：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6 + 5;
const ll p = 1e9 + 7, inv2 = 5e8 + 4;//模数与逆元
struct node {
	ll w;
	int nxt, to;
} edge[N << 1];
struct Node {
	ll f, cnt;//分别表示该树所有点到重心的距离和与该树的点数
	inline bool operator < (const Node &b) const {return cnt > b.cnt;}//重载运算符，小于变大于，从大到小排序
} a[N];//描述一棵树
bool vis[N];
ll f[N], size[N], F[N], ans, w[N];
int n, m, head[N], tot, res, rt, cnt;
void add (int from, int to, ll w) {
	edge[++tot].nxt = head[from];
	edge[tot].to = to;
	edge[tot].w = w;
	head[from] = tot;
}//链式前向星应该都会吧？
void dfs1 (int u, int pa) {
    size[u] = 1, res++;
    for (int i = head[u], v; i; i = edge[i].nxt) {
		v = edge[i].to;
		if (v == pa) continue;
		dfs1(v, u), size[u] += size[v];
		f[u] += f[v] + size[v] * edge[i].w;
	}
}//第一次 dfs
void dfs2 (int u, int pa) {
	vis[u] = true;
	for (int i = head[u], v; i; i = edge[i].nxt) {
		v = edge[i].to;
		if (v == pa) continue;
		f[v] = f[u] + (res - 2 * size[v]) * edge[i].w;
		if (f[v] < a[cnt].f) a[cnt].f = f[v];
		
		dfs2(v, u);
	}
}//第二次 dfs，换根求重心应该都会吧？
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v, w; i <= m; i++) scanf("%d%d%d", &u, &v, &w), add(u, v, w), add(v, u, w);//无向边建俩
	for (int i = 1; i <= n - m - 1; i++) scanf("%lld", &w[i]);//输入
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) res = 0, dfs1(i, 0), a[++cnt].f = f[i], dfs2(i, 0), a[cnt].cnt = res;//记录小小树
	}
	for (int i = 1; i <= n; i++) ans = (ans + f[i]) % p;
	ans = (ans * inv2) % p;//初始答案
	Node u, v;
	sort(w, w + n - m), sort(a + 1, a + 1 + cnt);
	u = a[1];	
	for (int i = 2; i <= cnt; i++) {
		v = a[i], ans = (ans + u.f * v.cnt % p + v.f * u.cnt % p + u.cnt * v.cnt * w[i - 1] % p) % p;//状态转移方程的程序实现
		u.f = ((u.f + v.cnt * w[i - 1]) % p + v.f) % p, u.cnt = (u.cnt + v.cnt) % p;		
	}//正经实现
	printf("%lld", ans);
    return 0;
}
```

那么全文到这里就结束了，感谢审核管理员耐心看完，神犇幸苦了，求过 qwq。

如有不足，欢迎指出 awa。

---

## 作者：MPLN (赞：8)

## 题目解释

数据保证一定存在至少一种合法的方案，容易发现是森林，而我们的目的就是用给出的新边把它们连成一棵树，使得：

$$
\sum_{u=1}^n\sum_{v=u}^ndis(u,v)
$$ 

最小。然后求出答案对 $10^9+7$ 取模即可。

## 思路与解法

以下我们把单独的点也看作一棵树。

由于最终是一棵树，已有的树内部就不会连边了，所以只需要再树与树之间相连。怎么选择呢？

首先，假设我们要连接 A B 两棵树，**一定是选择它们分别的重心连接**（附：重心指选择一个点，使树中所有点到此点距离和最小）。这点很好证明，读者可以自行尝试。

于是我们可以求出所有树的重心。然后对于这么多重心，又该怎么连呢？第一，肯定是要从一个重心出发连接其他所有树的重心的。贪心地讲，这样可以让树贴近于一个菊花图，答案必定不劣。所以问题就是怎么选这个“源点”。

我们设 $sz_x$ 为树 $x$ 的节点数量，$sum_x$ 为树 $x$ 所有点到其重心的距离和。答案很简单，就是**选 $sz$ 最大的树的重心作为“源点”**。这需要~~靠直觉~~研究一下最终答案是怎么来的。

在最终答案里，每条边的贡献是什么？不就是两边的点有多少组连接！换句话说，每条边贡献为：$w\times sz_u\times sz_v$（$u,v$ 为连接的两棵树），即 $sz_u(n-sz_u)$。众所周知，此时 $sz_u$ 越小结果越小。假设最大点数的树为 $x$，另一树为 $y$。若选择 $x$ 的重心作“源点”则答案有一项 $sz_y(n-sz_y)$，若选择 $y$ 的重心作“源点”则答案有一项 $sz_x(n-sz_x)$；其余都是相同项。那么显然选 $x$ 作“源点”更优。

类似地，我们优先选择 $w$ 较小的边连接 $sz$ 较大的树。

## Code1

如果已经理解，想要实现更简洁的代码，请下翻至 Code2 部分。


---


为求清晰，我在这里将代码分了几个板块。

总时间复杂度 $O(n\operatorname{log}n)$，瓶颈在于排序重心和 $a$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MOD = 1000000007;

struct edge { int v, w; };
int n, m, k, a[1000010];
vector<edge> e[1000010];

//STEP1: 求所有树的重心（树中其他点到这个点距离和最小）
int p, mnval, vis[1000010], sz[1000010], f[1000010], g[1000010];
void dfs1(int fa, int x, int u) {
    sz[x] = 1, f[x] = 0, vis[x] = u;
    for (edge t: e[x]) {
        int v = t.v, w = t.w;
        if (v == fa) continue;
        dfs1(x, v, u);
        sz[x] += sz[v];
        f[x] += f[v] + w * sz[v];
    }
}
void dfs2(int fa, int x, int u) {
    if (g[x] < mnval) mnval = g[x], p = x;
    for (edge t: e[x]) {
        int v = t.v, w = t.w;
        if (v == fa) continue;
        g[v] = g[x] + w * (sz[u] - 2 * sz[v]);
        dfs2(x, v, u);
    }
}

//STEP2: 按sz排序所有重心
int b[1000010], btp = 0;
bool cmp(int x, int y) { return sz[x] > sz[y]; }

//STEP3: 构造新树后求答案，每条边贡献为：边权*连接的两棵树点数之积
int ans = 0, nsz[1000010];
void dfs3(int fa, int x) {
    nsz[x] = 1;
    for (edge t: e[x]) {
        int v = t.v, w = t.w;
        if (v == fa) continue;
        dfs3(x, v);
        ans = (ans + (n - nsz[v]) * nsz[v] * w) % MOD;
        nsz[x] += nsz[v];
    }
}

signed main() {
    cin >> n >> m;
    k = n - m - 1;
    for (int i = 1, x, y, z; i <= m; i++) {
        cin >> x >> y >> z;
        e[x].push_back({y,z});
        e[y].push_back({x,z});
    }
    for (int i = 1; i <= k; i++) cin >> a[i];
    sort(a + 1, a + k + 1);
    //求所有树重心
    for (int i = 1; i <= n; i++) {
        if (vis[i]) continue;
        dfs1(0, i, i);
        mnval = 1e18, g[i] = f[i];
        dfs2(0, i, i);
        sz[p] = sz[i];
        b[++btp] = p;
    }
    sort(b + 1, b + btp + 1, cmp);
    //从点最多的树重心出发，连所有其他树的重心（点多的树优先用边权小的连）
    int o = b[1];
    for (int i = 2, j = 1; i <= btp; i++, j++) {
        e[o].push_back({b[i],a[j]});
        e[b[i]].push_back({o,a[j]});
    }
    dfs3(0, o);
    cout << ans;
    return 0;
}
/*
a<b，SZx>SZy>SZz，Sy>Sx>Sz
SZy*Sz+SZz*Sy+(a+b)*SZz*SZy+Sx*SZz+Sz*SZx+b*SZz*SZx+Sx*SZy+Sy*SZx+a*SZy*SZx
SZy*Sz+SZz*Sy+b*SZz*SZy+Sx*SZz+Sz*SZx+(a+b)*SZz*SZx+Sx*SZy+Sy*SZx+a*SZy*SZx
SZy*Sz+SZz*Sy+b*SZz*SZy+Sx*SZz+Sz*SZx+a*SZz*SZx+Sx*SZy+Sy*SZx+(a+b)*SZy*SZx
a*SZz*SZy+b*SZz*SZx
b*SZz*SZx+a*SZz*SZx
a*SZz*SZx+b*SZy*SZx
SZy
SZx
*/
```

## Code2

可以运用一些技巧省略 dfs3 步骤。具体见这份代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MOD = 1000000007;
struct edge { int v, w; }; vector<edge> e[1000010];
int n, m, k, a[1000010], b[1000010], btp = 0, ans = 0;
int p, mnval, vis[1000010], sz[1000010], f[1000010], g[1000010];
bool cmp(int x, int y) { return sz[x] > sz[y]; }
void dfs1(int fa, int x, int u) {
    sz[x] = 1, f[x] = 0, vis[x] = u;
    for (edge t: e[x]) {
        int v = t.v, w = t.w;
        if (v == fa) continue;
        dfs1(x, v, u);
        sz[x] += sz[v], f[x] += f[v] + w * sz[v];
    }
}
void dfs2(int fa, int x, int u) {
    if (g[x] < mnval) mnval = g[x], p = x;
    for (edge t: e[x]) {
        int v = t.v, w = t.w;
        if (v == fa) continue;
        g[v] = g[x] + w * (sz[u] - 2 * sz[v]);
        dfs2(x, v, u);
        ans = (ans + w * sz[v] * (sz[u] - sz[v])) % MOD; // 内部互相连接的每条边的贡献
    }
}
signed main() {
    cin >> n >> m; k = n - m - 1;
    for (int i = 1, x, y, z; i <= m; i++) {
        cin >> x >> y >> z;
        e[x].push_back({y,z}), e[y].push_back({x,z});
    }
    for (int i = 1; i <= k; i++) cin >> a[i];
    sort(a + 1, a + k + 1);
    for (int i = 1; i <= n; i++) {
        if (vis[i]) continue;
        dfs1(0, i, i), mnval = 1e18, g[i] = f[i];
        dfs2(0, i, i), sz[p] = sz[i], b[++btp] = p;
        ans = (ans + g[p] * (n - sz[p])) % MOD; // 还有这么多点要连这里的所有点
        
    }
    sort(b + 1, b + btp + 1, cmp);
    for (int i = 2, j = 1; i <= btp; i++, j++)
        ans = (ans + a[j] * sz[b[i]] * (n - sz[b[i]])) % MOD; // 直接算出这些边的权重
    cout << ans;
    return 0;
}
```

---

## 作者：r1sing (赞：4)

## 分析题目
首先题目要求把一个森林通过加一些固定的权值的边来得到一棵树，使得树上的点两两的距离之和是最小的。那么为了使得合并之后点两两之间距离和最小，只能去考虑合并两棵带权树的重心。可以发现如果把原来森林里的每一棵树用它的重心表示，则最后的图是一个菊花图。而且为了使得点两两之间距离和最小要把最大的树放在菊花图的中心，次大的用最小的边连接，最小的用最长的边连接，即可。所以换根 DP 求出重心再按照上述策略合并并求出答案。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll p = 1e9 + 7;
ll n, m;
vector <pair <ll, ll>> adj[1000005];
ll dp[1000005];
ll siz[1000005];
ll a[1000005];
ll zx, ans;
void dcd(ll u, ll fa)
{
	siz[u] = 1;
	for(auto it:adj[u])
	{
		if(it.first != fa)
		{
			dcd(it.first, u);
			siz[u] += siz[it.first];
			dp[u] += siz[it.first] * it.second + dp[it.first];
		}
	}
}
void dcu(ll u, ll fa)
{
	zx = min(zx, dp[u]);
	for(auto it:adj[u])
	{
		if(it.first != fa)
		{
			ans += siz[it.first] * (siz[u] - siz[it.first]) % p * it.second % p;
			ans %= p;
			dp[it.first] += (dp[u] - dp[it.first] - siz[it.first] * it.second + (siz[u] - siz[it.first]) * it.second);
			siz[it.first] = siz[u];
			dcu(it.first, u);
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);     cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= m; i++)
	{
		ll u, v, w;
		cin >> u >> v >> w;
		adj[u].push_back({v, w});
		adj[v].push_back({u, w});
	}
	vector <ll> v;
	for(int i = 1; i <= n; i++)
	{
		if(!siz[i])
		{
			zx = 0x7f7f7f7f7f7f7f7f;
			dcd(i, 0);
			dcu(i, 0);
			zx %= p;
			ans += zx * (n - siz[i]) % p;
			ans %= p;
			v.push_back(siz[i]);
		}
	}
	sort(v.begin(), v.end());
	for(int i = 1; i <= n - 1 - m; i++)
		cin >> a[i];
	sort(a + 1, a + n - m, greater <ll>());
	for(int i = 1; i <= n - m - 1; i++)
	{
		ans += a[i] * v[i - 1] % p * (n - v[i - 1]) % p;
		ans %= p;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：shuqiang (赞：4)

## 题目大意

给你 $n$ 个节点的树中的 $m$ 条边（带权），和剩下 $n-m-1$ 条边的权值，你需要把这 $n-m-1$ 条边插在树上（插完后必须是一棵树）并使所有路径的长度和最小。

## Subtask2

我们要保证**所有路径的长度和最小**，其实可以拆贡献，对于每条边，我们考虑一共有多少条路径包含了这条边。

观察样例已经连好的边，尝试用拆贡献计算一下。
![](https://cdn.luogu.com.cn/upload/image_hosting/mxc2d4v2.png)

1. 边 $(1,2)$ 的上面有 $1$ 个节点，下面 $6$ 个节点，总贡献为 $1 \times 6 \times 1=6$。
2. 边 $(2,3)$ 的左边有 $2$ 个节点，右边 $5$ 个节点，总贡献为 $2 \times 5 \times 1=10$。
3. 边 $(3,6)$ 的上面有 $1$ 个节点，下面 $6$ 个节点，总贡献为 $1 \times 6 \times 2=12$。
4. 边 $(3,4)$ 的左边有 $6$ 个节点，右边 $1$ 个节点，总贡献为 $6 \times 1 \times 3=18$。
5. 边 $(3,5)$ 的上面有 $6$ 个节点，下面 $1$ 个节点，总贡献为 $6 \times 1 \times 3=18$。
6. 边 $(3,7)$ 的上面有 $6$ 个节点，下面 $1$ 个节点，总贡献为 $6 \times 1 \times 2=12$。

所以答案为 $6+10+12+18+18+12=76$，与样例输出一致。

这样就可以把这棵树的答案分成两部分，一部分是已知的边，另一部分就是未知的边。

### 已知的边

把其他节点分开连在这个连通块上是不优的，证明如下：

设 $a+b=n(a,b,n>0)$，则 $n^2=(a^2+2ab+b^2)=(n^2-2ab+b^2)+4ab=(a-b)^2+4ab$，所以当 $n$ 不变时，$|a-b|$ 越小，$ab$ 越大。

因为总节点数是一样的，所以分开插入一定会使两边节点的差变小，故乘积大，所以边的贡献会增加。

比如这样插入：

![](https://cdn.luogu.com.cn/upload/image_hosting/aztu2n7k.png)

边 $(3,7)$ 的贡献就变成了 $4 \times 3 \times 2=24$，显然不优。

由于无论其他节点怎么拼，这个连通块的贡献都不会受影响，所以肯定是按照这个连通块的最优方式来拼，即剩余连通块都插在一个节点上。

我们把每个连通块都缩小到只有节点个数种可能，接下来观察样例图中 3,5,7 这个连通块。

![](https://cdn.luogu.com.cn/upload/image_hosting/vt6xq7bv.png)

显然，无论其它的连通块怎么连，都是有 $4$ 个节点，对内部的节点没有影响，那么我们枚举其它连通块要连在哪。

1. 连在节点 $3$ 上，即 $x_1$，边 $(3,5)$ 的贡献为 $6 \times 1 \times 3=18$，边 $(3,7)$ 的贡献为 $6 \times 1 \times 2=12$，连通块总贡献为 $30$。
2. 连在节点 $5$ 上，即 $x_2$，边 $(3,5)$ 的贡献为 $5 \times 2 \times 3=30$，边 $(3,7)$ 的贡献为 $1 \times 6 \times 2=12$，连通块总贡献为 $42$。
3. 连在节点 $7$ 上，即 $x_3$，边 $(3,5)$ 的贡献为 $1 \times 6 \times 3=18$，边 $(3,7)$ 的贡献为 $2 \times 5 \times 2=20$，连通块总贡献为 $38$。

得到这个连通块的最小贡献为 $30$，方法是把其它节点连在 $3$ 上。

实现就是对于每个点，计算以它为根时这个连通块的答案，然后对于每个联通块取最小。

已知边的部分时间复杂度为 $\mathcal{O}(n^2)$。

### 未知的边

我们前面把已知边算完了，所以我们只需要求对于每条位置边的左边和右边各有多少个节点就可以了。

前面已经证明过，当 $a+b$ 不变时，$|a-b|$ 越小，$ab$ 越大，显然，权值更大的点要让两端点的数量差尽可能的大，所以我们先排序，直接用快速排序时间为 $\mathcal{O}(n \log n)$，这题中保证了 $a_i \le 10^6$（后面的 $a$ 均指未知边边权），所以我们可以用桶排序来去掉 $\log$。

接着，每次我们找到权值最大的边时，要找一个连通块，假设第 $i$ 个连通块的点的个数为 $c_i$，先对 $c_i$ 排序，方便计算，然后找到 $\min(\min(c_i),n-\max(c_i))$，但是这样的话往 $c$ 加连通块会很麻烦，观察到 $\min(c_i) \le n-\max(c_i)$，因为 $n-\max(c_i)$ 其实就是除了最大的 $c_i$ 外所有 $c_i$ 的和，一定大于等于 $\min(c_i)$，所以得出 $\min(\min(c_i),n-\max(c_i))=\min(c_i)$。

最后，我们按照从大到小的顺序遍历 $a_i$，然后每次取最小的 $c_i$ 并删除，答案增加 $a_ic_i(n-c_i)$ 即可，**记得取模**。

未知边部分时间复杂度为 $\mathcal{O}(n)$。


```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;
typedef long long ll;

const int N = 1e6 + 10, mod = 1e9 + 7, V = 1e6;
int n, m, u, v, w, fa[N], sz[N], a[N], t[N], b[N], idx, idx2, x;
ll ans = 0, lst = 0, wt[N]; bool vis[N];
vector<pair<int, int> > g[N];
vector<int> gp[N];

int gr(int u){
	if(u == fa[u]) return u;
	return fa[u] = gr(fa[u]);
}

void mg(int u, int v){
	int ru = gr(u), rv = gr(v);
	fa[ru] = rv;
}

void get_sz(int u, int f){
	sz[u] = 1;
	for(auto ed: g[u]){
		int v = ed.first; ll w = ed.second;
		if(v == f) continue;
		get_sz(v, u);
		sz[u] += sz[v];
	}
}

ll get_w(int u, int f){
	ll wth = 0;
	for(auto ed: g[u]){
		int v = ed.first; ll w = ed.second;
		if(v == f) continue;
		wth += get_w(v, u) + (ll)w * sz[v] * (n-sz[v]);
	}
	return wth;
}

bool cmp(int x, int y){
	return x > y;
}

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++) fa[i] = i;
	for(int i = 1; i <= m; i++){
		cin >> u >> v >> w;
		g[u].push_back({v, w});
		g[v].push_back({u, w});
		mg(u, v);
	}
	for(int i = 0; i < n-m-1; i++){
		cin >> x;
		t[x]++;
	}
	for(int i = V; i >= 0; i--){
		while(t[i]--) a[idx2++] = i;
	}
	for(int i = 1; i <= n; i++) gp[gr(i)].push_back(i);
	for(int i = 1; i <= n; i++){
		get_sz(i, 0);
		wt[i] = get_w(i, 0);
	}
	for(int i = 1; i <= n; i++){
		if(gp[i].size()){
			ll mn = 1e18;
			for(int j: gp[i]) mn = min(mn, wt[j]);
			ans = (ans + mn) % mod;
			b[gp[i].size()]++;
		}
	}
	for(int i = 1; i <= n; i++){
		while(b[i]--){
			ans = (ans + lst) % mod;
			lst = (ll)i * (n-i) % mod * a[idx++] % mod;
		}
	}
	cout << ans;
	return 0;
}
```

## 正解

现在更劣的地方在算已知的边上，考虑把计算已知边过程的复杂度优化到 $\mathcal{O}(n)$。

同样的，一个连通块的答案跟外部怎么连接是没有关系的，所以我们只需要看连通块内部，看以哪个节点作为根时所有边与这个点的距离和最小就行了。

这就是很经典的换根 dp 了。

我们先把这个树中所有节点的子树大小求出来，然后求出根节点与所有节点的距离和，假设第 $i$ 个点的答案为 $f_i$，子树大小为 $s_i$，$u$ 通向 $v$ 的边权为 $w$，看这张图辅助理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/pkbz3mnr.png)

此时，有 $(s_1-s_v)$ 个点，也就是 $v$ 子树外面的点距离 $v$ 都比 $u$ 大 $w$，$s_v$ 个点的距离都比 $u$ 小 $w$，递推式即为 $f_v=f_u+(s_1-s_v) \times w-s_v \times w=f_u+(s_1-2s_v) \times w$

这样，我们就可以在 $\mathcal{O}(n)$ 的时间内算完已知边对答案的贡献。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;
typedef long long ll;

const int N = 1e6 + 10, mod = 1e9 + 7, V = 1e6;
int n, m, u, v, w, fa[N], sz[N], a[N], t[N], b[N], idx, idx2, x;
ll ans = 0, lst = 0, dp[N]; bool vis[N];
vector<pair<int, int> > g[N];
vector<int> gp[N];

int gr(int u){
	if(u == fa[u]) return u;
	return fa[u] = gr(fa[u]);
}

void mg(int u, int v){
	int ru = gr(u), rv = gr(v);
	fa[ru] = rv;
}

void get_sz(int u, int f){
	sz[u] = 1;
	for(auto ed: g[u]){
		int v = ed.first; ll w = ed.second;
		if(v == f) continue;
		get_sz(v, u);
		sz[u] += sz[v];
	}
}

ll get_d(int u, int f){
	ll res = 0;
	for(auto ed: g[u]){
		int v = ed.first; ll w = ed.second;
		if(v == f) continue;
		res += get_d(v, u);
		res += (ll)sz[v] * w;
	}
	return res;
}

void get_dp(int u, int f, int rt){
	for(auto ed: g[u]){
		int v = ed.first; ll w = ed.second;
		if(v == f) continue;
		dp[v] = dp[u] + (sz[rt] - 2 * sz[v]) * w;
		get_dp(v, u, rt);
	}
}

void get_w(int u, int f){
	for(auto ed: g[u]){
		int v = ed.first; ll w = ed.second;
		if(v == f) continue;
		ans = (ans + (ll)w * sz[v] * (n-sz[v])) % mod;
		get_w(v, u);
	}
}

bool cmp(int x, int y){
	return x > y;
}

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++) fa[i] = i;
	for(int i = 1; i <= m; i++){
		cin >> u >> v >> w;
		g[u].push_back({v, w});
		g[v].push_back({u, w});
		mg(u, v);
	}
	for(int i = 0; i < n-m-1; i++){
		cin >> x;
		t[x]++;
	}
	for(int i = V; i >= 0; i--){
		while(t[i]--) a[idx2++] = i;
	}
	for(int i = 1; i <= n; i++) gp[gr(i)].push_back(i);
	for(int i = 1; i <= n; i++){
		if(gp[i].size()){
			get_sz(i, 0);
			dp[i] = get_d(i, 0);
			get_dp(i, 0, i);
			ll mn = 1e18; int mnn;	
			for(int j: gp[i]){
				if(mn > dp[j]){
					mn = dp[j];
					mnn = j;
				}
			}
			get_sz(mnn, 0);
			get_w(mnn, 0);
		}
	}
	for(int i = 1; i <= n; i++){
		if(gp[i].size()) b[gp[i].size()]++;
	}
	for(int i = 1; i <= n; i++){
		while(b[i]--){
			ans = (ans + lst) % mod;
			lst = (ll)i * (n-i) % mod * a[idx++] % mod;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：良心WA题人 (赞：3)

首先可以注意到本质上是一个森林，让你连边使得任意两点之间距离之和最小。

首先考虑 $a_i=0$ 的时候。外面的每个点一定会经过这个连通块的某个点才能到达连通块内别的点。所以经过的这个点到达别的点的距离和要尽量小才优。所以要取以它为根，$\sum dis_u$ 最小的一个点。这个是经典问题，做法很多，题解是使用换根实现。

其实算两点距离之和还有一种算法，是枚举每条边，让这条边的权值乘上两侧的点数之积的和。根据均值不等式，两侧点数之差越大乘积越小。而每个连通块至少会用一条边连出去，故最不均匀的方式一定是菊花图，且菊花图的中心是点数最多的连通块。

菊花图的形态已经确定，贪心地让 $a_i$ 大的尽量分配到两侧点数乘积尽量小的位置即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fastio
{
    const int bufl=1<<20;
    const double base1[16]={1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8,1e-9,1e-10,1e-11,1e-12,1e-13,1e-14,1e-15};
    const double base2[16]={1,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13,1e14,1e15};
    struct IN{
        FILE *IT;char ibuf[bufl],*is=ibuf,*it=ibuf;
        IN(){IT=stdin;}IN(char *a){IT=fopen(a,"r");}
        inline char getChar(){if(is==it){it=(is=ibuf)+fread(ibuf,1,bufl,IT);if(is==it)return EOF;}return *is++;}
        template<typename Temp>inline void getInt(Temp &a){a=0;int b=0,c=getChar();while(c<48||c>57)b^=(c==45),c=getChar();while(c>=48&&c<=57)a=(a<<1)+(a<<3)+c-48,c=getChar();if(b)a=-a;}
        template<typename Temp>inline void getDouble(Temp &a){a=0;int b=0,c=getChar(),d=0;__int128 e=0,f=0;while(c<48||c>57)b^=(c==45),c=getChar();while(c>=48&&c<=57)e=(e<<1)+(e<<3)+c-48,c=getChar();if(c==46){c=getChar();while(c>=48&&c<=57)d++,f=(f<<1)+(f<<3)+c-48,c=getChar();}a=e+base1[d]*f;if(b)a=-a;}
        IN& operator>>(char &a){a=getChar();return *this;}
        IN& operator>>(char *a){do{*a=getChar();}while(*a<=32);while(*a>32)*++a=getChar();*a=0;return *this;}
        IN& operator>>(string &a){char b=getChar();while(b<=32)b=getChar();while(b>32)a+=b,b=getChar();return *this;}
        IN& operator>>(int &a){getInt(a);return *this;}
        IN& operator>>(long long &a){getInt(a);return *this;}
        IN& operator>>(__int128 &a){getInt(a);return *this;}
        IN& operator>>(float &a){getDouble(a);return *this;}
        IN& operator>>(double &a){getDouble(a);return *this;}
        IN& operator>>(long double &a){getDouble(a);return *this;}
    };
    struct OUT{
        FILE *IT;char obuf[bufl],*os=obuf,*ot=obuf+bufl;int Eps;long double Acc;
        OUT(){IT=stdout,Eps=6,Acc=1e-6;}OUT(char *a){IT=fopen(a,"w"),Eps=6,Acc=1e-6;}
        inline void ChangEps(int x=6){Eps=x;}
        inline void flush(){fwrite(obuf,1,os-obuf,IT);os=obuf;}
        inline void putChar(int a){*os++=a;if(os==ot)flush();}
        template<typename Temp>inline void putInt(Temp a){if(a<0){putChar(45);a=-a;}if(a<10){putChar(a+48);return;}putInt(a/10);putChar(a%10+48);}
        template<typename Temp>inline void putLeading(Temp a,int b){if(!b)return;putLeading(a/10,b-1);putChar(a%10+48);}
        template<typename Temp>inline void putDouble(Temp a){if(a<0){putChar(45);a=-a;}__int128 b=a;putInt(b);a-=b;a*=base2[Eps];b=a+Acc;putChar(46);putLeading(b,Eps);}
        OUT& operator<<(char a){putChar(a);return *this;}
        OUT& operator<<(char *a){while(*a>32)putChar(*a++);return *this;}
        OUT& operator<<(string a){for(auto c:a)putChar(c);return *this;}
        OUT& operator<<(int a){putInt(a);return *this;}
        OUT& operator<<(long long a){putInt(a);return *this;}
        OUT& operator<<(__int128 a){putInt(a);return *this;}
        OUT& operator<<(float a){putDouble(a);return *this;}
        OUT& operator<<(double a){putDouble(a);return *this;}
        OUT& operator<<(long double a){putDouble(a);return *this;}
        ~OUT(){flush();}
    };
}
using fastio::IN;
using fastio::OUT;
IN fin;
OUT fout;
typedef __int128 ll;
const int NN=1e6+4,P=1e9+7;
int siz[NN],a[NN];
bool vis[NN];
vector<pair<int,int> >g[NN];
ll dfs(int u,int fa)
{
	vis[u]=true;
	siz[u]=1;
	ll res=0;
	for(auto t:g[u])
	{
		int v=t.first,w=t.second;
		if(v==fa)
			continue;
		res+=dfs(v,u)+1ll*siz[v]*w;
		siz[u]+=siz[v];
	}
	return res;
}
ll minn,res;
void get_min(int u,int fa,ll now,int all)
{
	minn=min(minn,now);
	res+=now;
	for(auto t:g[u])
	{
		int v=t.first,w=t.second;
		if(v==fa)
			continue;
		get_min(v,u,now+1ll*w*(all-siz[v])-1ll*w*siz[v],all);
	}
}
int main()
{
	double be=clock();
	int n,m;
	fin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		fin>>u>>v>>w;
		g[u].push_back({v,w});
		g[v].push_back({u,w});
	}
	ll ans=0;
	vector<int>p;
	for(int i=1;i<=n;i++)
		if(!vis[i])
		{
			minn=dfs(i,0);
			res=0;
			get_min(i,0,minn,siz[i]);
			ans+=res/2+1ll*minn*(n-siz[i]);
			p.push_back(siz[i]);
		}
	sort(p.begin(),p.end(),greater<int>());
	for(int i=1;i<=n-m-1;i++)
		fin>>a[i];
	sort(a+1,a+n-m);
	for(int i=1;i<=n-m-1;i++)
		ans+=1ll*(n-p[i])*p[i]*a[i];
	fout<<ans%P;
	return 0;
}
```

---

## 作者：luogu_starblue (赞：2)

为了避免繁琐的讨论，本篇题解中所有 $n$ 均为偶数，奇数的情况类似。

# 题目大意

给定一些树形的连通块，有边权，一共有 $n$ 个点 $m$ 条边，以及 $n-m-1$ 条带权边。设 $d_{i,j}$ 表示从节点 $i$ 到 $j$ 的最短路径，你需要用这些边将所有连通块连接成一颗树，同时最小化任意两个节点的最短路径和，即最小化 $\displaystyle\sum_{x=1}^{n}\sum_{y=x+1}^{n}d_{x,y}$。

# 解题思路

## 如何连接两个连通块

首先我们先考虑如何在合并两个连通块，如果要连接两个连通块的话，那么肯定要先从两个连通块中各自选择一个点，我们设这两个点为 $u_1$ 和 $u_2$。同时设 $s_1$ 为第一个连通块中各个点到 $u_1$ 的距离和，即 $s_1=\displaystyle\sum_{u_1,v\in同一个连通块}{d_{u_1,v}}$。$s_2$ 同理。我们设这条新边的边权为 $w$，连通块的大小为 $size_1$ 和 $size_2$，根据乘法原理，这次操作会增加不协调度为 $s_1\times size_2 + s_2 \times size_1+w\times size_1 \times size_2$。根据这个柿子，我们不难发现如果要最小化增加的不协调度，那么需要最小化 $s_1$ 和 $s_2$。而这个值和我们选择哪个点作为 $u$ 是有关系的。

那么，如何找到最优的 $u$ 呢，我们可以先假设任意一个节点为当前的 $u$，然后去移动这个 $u$，假设我们要移动 $u$ 到其儿子 $v$ 的话，那么 $s$ 的值会增加 $w\times (-siz_v+(size-size_v))$。其中 $size_v$ 以 $v$ 为根的子树大小，$w$ 为边权。然后根据增加值的正负来判断是否要移动。

事实上，我们这样移动完成后的点一定是 [树的重心](https://oi-wiki.org/graph/tree-centroid/)，因为树的重心的子树大小均不会超过 $\displaystyle\frac{n}{2}$，所以从重心移动到其儿子一定不会使答案更优。

## 如何连通整张图

接下来考虑如何联通整张图。我们先思考这样一个问题:如果初始整张图没有一条边，我们应该怎么连？显然此时连成一个菊花图，即一个点度数为 $n-1$，其余点度数为 $1$ 的时候是最优的，这启示我们在连接的时候也应该选择一个联通块作为“中心联通块”，然后其他联通块分别往这个中心联通块连一条边。

在证明上面这个结论前，我们先考虑选择哪个联通块作为中心联通块，考虑如果我们选择一个大小为 $x$ 的联通块连接到中心联通块的话，那么增加的不协调度为 $f(x)=x\times (n-x)\times w$，设最大的联通块大小为 $s_{max}$，其他一个任意联通块大小为 $s$，若 $s_{max}\le \displaystyle \frac{n}{2}$，那么显然 $f(s)\le f(s_{max})$。若 $s_{max}\gt \displaystyle\frac{n}{2}$，其它联通块大小 $s \le n-s_{max}$，此时也满足 $f(s)\le f(s_{max})$。于是我们就证明了选择最大的联通块作为中心联通块是最优的。

至于第一个结论，因为我们选择了最大的联通块作为中心联通块，则设另外两个联通块大小为 $a\le b\lt \displaystyle\frac{n}{2}$，因为 $f(a)+f(b)\le f(a)+f(a+b)$，因此我们选择两个联通块把他们相连，再把连接出来的联通块接到中心联通块上肯定不比单独连到中心联通块上更优。

## 计算答案
我们可以直接计算答案而不用去真正模拟题目中的操作，对于每一个联通块，我们找到它们的重心，然后以重心为根做 dfs，计算联通块内每条边的贡献。

然后我们将那些未加入的边权排序，贪心地选择边权较大的边与大小较小的联通块相匹配即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e6+9;
const int mod=1e9+7;
struct node
{
	int v,w;
};
vector<node>G[maxn];
int siz[maxn];
int f[maxn];
int centre;
int n,m;
int a[maxn];
vector<int>b;
int cnt;
void dfs0(int u,int lst)//计算连通块大小 
{
	cnt++;
	for(auto it:G[u])
	{
		int v=it.v;
		if(v==lst)continue;
		dfs0(v,u);
	}
}
void dfs1(int u)//找重心 
{
	siz[u]=1;
	for(auto it:G[u])
	{
		int v=it.v;
		if(siz[v])continue;
		dfs1(v);
		siz[u]+=siz[v];
		f[u]=max(f[u],siz[v]);
	}
	f[u]=max(f[u],cnt-siz[u]);
	if(f[u]<f[centre])centre=u;
}
ll ans=0;
void dfs2(int u,int lst)//计算连通块内部答案 
{
	siz[u]=1;
	for(auto it:G[u])
	{
		int v=it.v,w=it.w;
		if(v==lst)continue;
		dfs2(v,u);
		siz[u]+=siz[v];
		ans=(ans+1ll*siz[v]*(n-siz[v])%mod*w%mod)%mod; 
	}
}
bool cmp(int x,int y)
{
	return x>y;
}
int main()
{
	f[0]=1e9;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		G[u].push_back({v,w});
		G[v].push_back({u,w}); 
	}
	for(int i=1;i<=n;i++)
	{
		if(!siz[i])
		{
			cnt=0;
			centre=0;
			dfs0(i,0);
			dfs1(i);
			b.push_back(cnt);
			dfs2(centre,0);
		}
	}
	for(int i=1;i<=n-m-1;i++)cin>>a[i];
	sort(a+1,a+1+n-m-1,cmp);
	sort(b.begin(),b.end());
	for(int i=1;i<=n-m-1;i++)
	{
		ans=(ans+1ll*b[i-1]*(n-b[i-1])%mod*a[i]%mod)%mod;//计算新加入边的答案	
	} 
	cout<<ans;
    return 0;
}
```

---

## 作者：AxB_Thomas (赞：2)

# 一. 题面：[点这里](https://www.luogu.com.cn/problem/P12007)
# 二. 思路：
首先有一个比较常用的 trick 就是对于任意一颗带权树，对于题目中所求的两点对之间的距离和有如下公式：
$$Sum_{dis}=\sum_{e\in E}w(e)\times size_v\times(n-size_v)$$
这个公式应当是容易理解的，那么最后的贡献就可以这么算，但是现在有一个连边的问题。这和最优化问题有关，可以 dp 吗？好像不太现实，那我们考虑贪心。一步步来，首先你肯定会有一个疑问就是如果要连边，应当连到这个连通块的哪一个点呢。因为连通块本身的点对之间距离是确定的，考虑其他连通块连过来时造成的贡献，显然我们应当让这个连接点到这个连通块其他部分的距离和最小（很好证明）。关于距离和最小这个问题是经典的，可以其中一个解法是可以考虑换根dp 。解决这个问题之后，我们就要考虑我们分别连接哪些联通块是最优的呢。让我们回到算贡献的式子，那么我们应当是希望这个图是菊花图（假设我们把所有连通块内部的点缩成一个点之后），这样可以最小化每一个形如 $x(n-x)$ 的乘积式。问题是菊花图的中心是什么呢。我们猜想是连通块大小最大的那一个，证明考虑反证法，假设调换最大块和某一块的值，一定不会使答案变小，手搓一个二次函数图像之后就会发现这个问题等价于证明：任意一个正整数 $t$ 表示不是最大块的大小都有：
$$t\leq n-\max\{size\}$$
那么这是显然成立的（请读者自行思考，这是简单的。）
所以最后只需要以最大块向外连边即可，至于连边的顺序，考虑将边权大的连向乘积贡献小的连通块即可。
# 三. Code：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<vector>
#define ll __int128 
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch > '9' || ch < '0'){if(ch == '-'){f = -1;}ch = getchar();}
	while(ch >= '0'&&ch <= '9'){x = x * 10 + ch - 48; ch = getchar();}
	return x * f;
}

inline void write(ll x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + 48);
	return;
}
const int N = 1e6 + 5,MOD = 1e9 + 7;
int siz[N],a[N];
std::vector<std::pair<int,int> > G[N];

ll dfs(int u,int fa)
{
	siz[u] = 1;
	ll res = 0;
	for(auto now : G[u])
	{
		int v = now.first,w = now.second;
		if(v == fa) continue;
		res += dfs(v,u) + 1ll * siz[v] * w;
		siz[u] += siz[v];
	}
	return res;
}

ll tmp_res = 0,mn = 0;
void chgrt_dp(int u,int fa,ll mn_now,int now_siz)
{
	mn = std::min(mn,mn_now);
	tmp_res += mn_now;
	for(auto now : G[u])
	{
		int v = now.first,w = now.second;
		if(v == fa) continue;
		chgrt_dp(v,u,mn_now + 1ll * (now_siz - siz[v]) * w - 1ll * siz[v] * w,now_siz);
	}
}

bool cmp(int a,int b){return a > b;}
int main()
{
	int n,m;
	n = read(),m = read();
	for(int i = 1;i <= m;++i)
	{
		int u,v,w;
		u = read(),v = read(),w = read();
		G[u].push_back({v,w});
		G[v].push_back({u,w});
	}
	
	for(int i = 1;i <= n - m - 1;++i) a[i] = read();
	std::sort(a + 1,a + n - m);
	std::vector<int> p;
	ll ans = 0;
	for(int i = 1;i <= n;++i)
	{
		if(!siz[i])
		{
			mn = dfs(i,0);
			tmp_res = 0;
			chgrt_dp(i,0,mn,siz[i]);
			ans += tmp_res / 2 + 1ll * (n - siz[i]) * mn;
			p.push_back(siz[i]);
		}
	}
	std::sort(p.begin(),p.end(),cmp);
	
	for(int i = 1;i <= n - m - 1;++i) ans += 1ll * (n - p[i]) * p[i] * a[i];
	write(ans % MOD);
	return 0;
}
```

---

## 作者：Ice_function (赞：2)

不难发现，题目的答案等于所有边的边权乘以左边点的数量乘以右边点的数量。

对于一个连通块，存在一个点被连边使得对于这个连通块的答案的增加量最小，连一个点对于连通块的增加量是一这个点作根，所有点的上面的边权乘以子树的大小，使用换根 dp 求出。并且计算所有点的贡献。

最后将所有待加入的边从小到大排序，将选出来的点连成菊花即可，边权越大连的两端点数差越小。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10,mod=1e9+7;

int n,r,a[N];

struct edge{int v,w;};vector <edge> g[N];

int sz[N],val[N],all;

int dfs(int u,int la,int lw)
{
	int x=0;
	sz[u]=1;
	for (auto e : g[u])
	{
		if (e.v==la) continue;
		x+=dfs(e.v,u,e.w);
		sz[u]+=sz[e.v];
	}
	all+=sz[u]*(n-sz[u])%mod*lw%mod;
	all%=mod;
	x+=(val[u]=sz[u]*lw);
	return x;
}


int minx,minn;

void DP(int u,int la,int lv,int lw)
{
	int x=lv;
	int prela=sz[la],preu=sz[u],pre=x;
	if (la)
	{
		x-=sz[u]*lw;
		sz[la]-=sz[u];
		sz[u]+=sz[la];
		x+=sz[la]*lw;
		if (minx>x) minx=x,minn=u;
	}
	for (auto e : g[u])
	{
		if (e.v==la) continue;
		DP(e.v,u,x,e.w);
	}
	sz[la]=prela,sz[u]=preu,x=pre;
}

bool cmp(int a,int b)
{
	return a>b;
}

signed main()
{
	scanf("%lld %lld",&n,&r);
	for (int i=1;i<=r;i++)
	{
		int u,v,w;
		scanf("%lld %lld %lld",&u,&v,&w);
		g[u].push_back({v,w});
		g[v].push_back({u,w});
	}
	for (int i=1;i<=n-1-r;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1,cmp);

	int ans=0,S=0;
	priority_queue <int,vector<int>,greater<int> > q;
	for (int i=1;i<=n;i++)
	{
		if (sz[i]) continue;
		int x=dfs(i,0,0);
		int siz=sz[i];
		minx=x,minn=i;
		DP(i,0,x,0);
		q.push(siz);
		S+=siz;
		all=0;
		dfs(minn,0,0);
		ans=(ans+all)%mod;
	}

	for (int i=1;i<=n-1-r;i++)
	{
		int x=q.top();q.pop();
		ans+=x*(S-x)%mod*a[i]%mod;
		ans%=mod;
	}
	printf("%lld\n",ans);

	return 0;
}
```

感觉这题数据有点水。

---

## 作者：fanminghao000 (赞：1)

## 题解

这题可以分成两个部分来考虑，一是怎么连边最优，二是怎么计数。

### 连边

显然，初始边连完后产生 $n-m$ 个连通块，每个连通块里要再挑一个点和其他连通块相连，才能形成一棵树，我们考虑选哪一个点最优。

设 $f_u$ 为连通块的一个节点 $u$ 到连通块内其他所有点的距离之和，$s$ 为该连通块的大小，那么连边后该连通块对答案产生的贡献为：

$$
(n-s)f_u
$$

显然 $n-s$ 为定值，使 $f_u$ 最小即可。这个问题可以用换根 DP 解决，转移式为：

第一次 dfs，其中 $siz_v$ 表示子树大小：

$$
f_u=\sum_{v \in son(u)} f_v+siz_v\times w_{u,v}
$$

第二次 dfs：

$$
f_v=f_u-siz_v\times w_{u,v}+ (s-siz_v) \times w_{u,v}
$$

这是个换根 DP 的板子，不会的话可以移步[这里](https://www.luogu.com.cn/problem/P9584)。

~~tips: 取模是个好习惯，但这里 $f_u$ 是用来比较大小的，所以不能取模。~~

然后我们就找到了每个联通块的“代表” 点。接下来考虑怎么连。

不难猜想连出来的结构一定是个类似菊花图的东西，即所有边的一端都连在同一个点（连通块）上。因为这样，每两个连通块间最多只走两条边就能到达彼此，一定比其他方式更优。

接下来的结论是连通块大小 $s$ 越大，连的边权值越小。这也很好证明，因为该边的贡献为：

$$
a_i\times s(n-s)
$$

根据和一定差小积大，也就是二次函数的性质很好看出来，$s$ 越大，$s(n-s)$ 越大；即使 $s> \frac{n}{2}$，也有其他 $s'\leq n-s$，值总不会大于 $s(n-s)$，故给该联通块连更小的 $a_i$ 总是最优的。至于谁做根节点？把根节点看做自己连向自己的，边权为 $0$ 的边，根据上面的贪心，当然是最大的那个连通块啦。于是边就连完了。

### 计数

这就比较简单了，考虑每条边的贡献，边两端每对点的路径都要经过一次该边，所以贡献为：

$$
w_{u,v}\times (n-siz_v) \times siz_v
$$

跑一遍 dfs 就可以了。于是这道题做完了。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int mod=1e9+7;
int n,m,ans;
struct edge{
	int v,nxt,w;
}e[2000010];
int head[1000010],cnt;
void add(int u,int v,int w){
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int a[1000010],f[1000010],siz[1000010];
bool vis[1000010];
vector<int> dot;
struct node{
	int x,siz;
	friend bool operator <(node x,node y){
		return x.siz>y.siz;
	} 
};
vector<node> lt;
void dfs(int u,int fa){
	siz[u]=1,vis[u]=1;
	dot.push_back(u);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(v==fa) continue;
		dfs(v,u);
		siz[u]+=siz[v];
		f[u]=f[u]+f[v]+siz[v]*w;
	}
}
void dp(int u,int fa){
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(v==fa) continue;
		f[v]=f[u]-(w*(siz[v]))+w*(dot.size()-siz[v]);
		dp(v,u);
	}
} 
void work(int x){
	dot.clear();
	dfs(x,0);
	dp(x,0);
	int zx=0,mx=1e18;
	for(auto u:dot) if(f[u]<mx) zx=u,mx=f[u];
	lt.push_back(node{zx,dot.size()});
}
void cal(int u,int fa){
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(v==fa) continue;
		int plus=((w*siz[v]*(n-siz[v]))%mod+mod)%mod; 
		ans+=plus;
		ans%=mod;
		cal(v,u);
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v,w;cin>>u>>v>>w;
		add(u,v,w),add(v,u,w);
	}
	for(int i=1;i<=n-m-1;i++) cin>>a[i];
	sort(a+1,a+n-m);
	for(int i=1;i<=n;i++) if(!vis[i]) work(i);
	sort(lt.begin(),lt.end());
	for(int i=1;i<lt.size();i++){
		add(lt[0].x,lt[i].x,a[i]);
		add(lt[i].x,lt[0].x,a[i]);
	}
	dfs(lt[0].x,0);
	cal(lt[0].x,0);
	cout<<(ans+mod)%mod<<endl;
	return 0;
} 
```

---

## 作者：Lele_Programmer (赞：1)

# P12007 题解

## 思路

题意很简单，给你一张无向无环图，再给你若干条边，让你把这些边连到原图里，使得连接后的图构成一个无向无环连通图，也就是一棵树。对于每一对节点 $(u,v)$，满足 $1 \le u < v \le n$，要使得 $u$ 到 $v$ 的距离之和最小。

### 连通块内部

不妨将原图看成若干个连通块，每一个连通块内的节点两两距离之和可以直接计算，这里与后面如何连接没有直接关系。

对于每一个连通块里面的每一条边，计算这条边会走过多少次，乘上边权就是这条边的贡献。假设这条边连接了左右两棵子树，这条边走过的次数就是两棵子树的节点数的乘积。

下面代码 $val$ 表示这一部分的答案之和，$tsz$ 表示该连通块的大小。

```cpp
void dfs2(int u,int fa,int& val,int tsz) {
    _graph(i,u) {
        if (e[i]==fa) continue;
        val+=(w[i]*(tsz-sz[e[i]])%mod)*sz[e[i]]%mod;
        dfs2(e[i],u,val,tsz);
    }
}
```

### 连通块与连通块之间

接下来考虑跨越了连通块之间的节点对 $(u,v)$ 它们之间的距离如何计算。

假设跨越了 $A,B$ 两个连通块，从节点 $a$ 离开 $A$，从节点 $b$ 离开 $B$，也就是从 $u$ 走到 $a$，走过新增边走到 $b$，再走到 $v$。

#### 原有的边

这里先抛掉新增边，直接计算 $u$ 到 $a$，以及 $b$ 到 $v$ 的路径长。

也就是说，我们需要在连通块 $A$ 中选出一个节点 $a$，满足 $a$ 走到连通块里面每一个点的距离之和最小，然后让 $a$ 作为中转到别的连通块的必经点，连通块 $B$ 同理。

这一步可以用树形 dp 做掉，先确定一个根节点，求出这个根节点到其它所有点的距离之和，然后从这个点开始移动，把状态转移给其它点，求出其它点的这个值。

下面代码就是求出根节点到其它节点的距离之和。

```cpp
void dfs1(int u,int fa) {
    sz[u]=1;
    _graph(i,u) {
        if (e[i]==fa) continue;
        dfs1(e[i],u);
        sz[u]+=sz[e[i]];
        f[u]+=f[e[i]]+w[i]*sz[e[i]];
    }
}
```
然后把状态转移给其它点，用 $res$ 保存最小值。

```cpp
void dfs3(int u,int fa,int& res,int tsz) {
    res=min(res,f[u]);
    vis[u]=true;
    _graph(i,u) {
        if (e[i]==fa) continue;
        f[e[i]]=f[u]-w[i]*sz[e[i]]+w[i]*(tsz-sz[e[i]]);
        dfs3(e[i],u,res,tsz);
    }
}
```

对于每一个连通块，它里面的点肯定要跟其它连通块的每个点之间走过一遍，设当前连通块的大小为 $tsz$，那么这个连通块的贡献就是 $(n-tsz) \times res$。

#### 新增的边

最后考虑新增的边如何将每个连通块选择出来的那个点连接。

对于一个连通块，假设它的大小为 $tsz$，那么与它相连的新增的边一定会被走过 $tsz \times (n-tsz)$ 次，容易发现这个次数是一个定值，而它的贡献还要乘上边权，而给定的边的边权也是定值。

现在就转化成了两个数组 $a,b$，要让 $a$ 中的每个元素与 $b$ 的某一个元素的乘积之和最小，很容易想到将 $a,b$ 排序，让较大者去乘较小者。

假设有 $g$ 条新增边，那么连通块数量一定是 $g+1$，只有这样才能连接成树状结构，不难证明。

那么我们 $(n-tsz) \times tsz$ 由小到大排序的 $g$ 个连通块已经把 $g$ 条新增边取完了，那剩下最后一个连通块呢？

会发现 $g$ 条边均只连了一端，于是将这 $g$ 条边的另外一端全部接到最后这个连通块上。

## 代码

```cpp
#define int long long
#define i32 signed

const int N=1000005;
const int M=2000005;
const int mod=1e9+7;
const int inf=5e18;

int n,m,g;
int e[M],w[M],ne[M],h[N],tot;
bool vis[N];
int sz[N],f[N];
int arr[N];
vector<int> vec;

void add(int a,int b,int c) {
    e[tot]=b,w[tot]=c,ne[tot]=h[a],h[a]=tot++;
}

void dfs1(int u,int fa) {
    sz[u]=1;
    _graph(i,u) {
        if (e[i]==fa) continue;
        dfs1(e[i],u);
        sz[u]+=sz[e[i]];
        f[u]+=f[e[i]]+w[i]*sz[e[i]];
    }
}

void dfs2(int u,int fa,int& val,int tsz) {
    _graph(i,u) {
        if (e[i]==fa) continue;
        val+=(w[i]*(tsz-sz[e[i]])%mod)*sz[e[i]]%mod;
        dfs2(e[i],u,val,tsz);
    }
}

void dfs3(int u,int fa,int& res,int tsz) {
    res=min(res,f[u]);
    vis[u]=true;
    _graph(i,u) {
        if (e[i]==fa) continue;
        f[e[i]]=f[u]-w[i]*sz[e[i]]+w[i]*(tsz-sz[e[i]]);
        dfs3(e[i],u,res,tsz);
    }
}

bool cmp(const int& a,const int& b) {
    return a>b;
}

i32 main() {
    memset(h,-1,sizeof(h));
    read(n),read(m),g=n-m-1;
    while (m--) {
        int a,b,c;
        read(a),read(b),read(c);
        add(a,b,c),add(b,a,c);
    }
    _rep(i,1,g) read(arr[i]);
    int ans=0;
    _rep(i,1,n) {
        if (vis[i]) continue;
        dfs1(i,0);
        int tsz=sz[i],val=0;
        dfs2(i,0,val,tsz);
        int res=inf;
        dfs3(i,0,res,tsz);
        res%=mod;
        ans=(ans+(n-tsz)*res)%mod;
        ans=(ans+val)%mod;
        vec.emplace_back(tsz*(n-tsz));
        // printf("test: %lld %lld +%lld +val:%lld\n",i,res,(n-tsz)*res,val);
    }
    // printf("f: "); _rep(i,1,n) writesp(f[i]); putchar(10);
    sort(vec.begin(),vec.end(),cmp);
    sort(arr+1,arr+1+g);
    // printf("size: vec, arr: %lld %lld\n",(int)vec.size(),g);
    // printf("vec: "); _iter(it,vec) writesp(*it); putchar(10);
    // printf("arr: "); _rep(i,1,g) writesp(arr[i]); putchar(10);
    _rep(i,1,g) ans=(ans+arr[i]*vec[i])%mod;
    write(ans);
    return 0;
}
```

该取模的时候取模，不该取模的时候别取模，因为 $f$ 数组会参与到最小值的选择中，所以这个数组不能取模，点数乘点数乘边权即 $10^6 \times 10^6 \times 10^6 = 10^{18}$，刚好存得下。

---

## 作者：five_rice_water (赞：1)

题意大概是说有 $n$ 个点，现在给出了部分边的树。给出剩了下的边的边权，要自己添加这些边使得这 $n$ 个点构成一棵树，在此基础上最小化 $\sum\limits_{i=1}^n \sum\limits_{j=i+1}^n dis(i,j)$，其中 $dis(i,j)$ 表示 $i$ 到 $j$ 的距离。

做法是这样的，我们首先对于每一个连通块，找到这个联通块里面最小化 $\sum\limits_{i=1}^{siz} dis(i,k)$ 的 $k$，其中 $siz$ 表示 $k$ 所在的连通块的大小。

这样的意义是为了最小化所有点到达接下来添加的边的距离。

这部分时间复杂度 $O(n)$。

然后不难发现，边权更小的边要连接尽可能大的连通块，这样能使得更多的点可以通过权值更小的边互相连通。

至于在哪两个点连接这两个连通块，就是我们之前找到的每一个连通块的 $k$。

这部分时间复杂度 $O(n \log n)$。

最后连好边以后我们再解决最小化 $\sum\limits_{i=1}^n \sum\limits_{j=i+1}^n dis(i,j)$ 这个问题了，这个问题相对板子，可以参考[这道题](https://www.luogu.com.cn/problem/P3478)。

总时间复杂度 $O(n+n \log n + n)$，但是常数较大。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int Mod = 1e9 + 7;
const int N = 1e6 + 5;
int n, m, cnt;
int dep[N], f[N];
int siz[N], head[N], a[N], tree[N];
//siz[i]表示i所在的连通块大小
//head[i]表示i所在的连通块的距离最小的节点
bool vis[N];

struct node {
	int v, w;
};

struct edge {
	int siz, head;
	friend bool operator <(edge a, edge b) {
		return a.siz < b.siz;
	}
};
priority_queue<edge>q;
vector<node>e[N];

int QuickPower(int x, int k) {
	int ans = 1;
	int base = x;
	while (k) {
		if (k & 1) {
			ans *= base;
			ans %= Mod;
		}
		base *= base;
		base %= Mod;
		k >>= 1;
	}
	return ans;
}

void dfs(int id, int top, int x, int father, int w) {
	vis[x] = 1;
	siz[id]++;
	tree[x] = 1;
	dep[x] = dep[father] + w;
	f[top] += dep[x];
	for (int i = 0; i < e[x].size(); i++) {
		int v = e[x][i].v;
		int W = e[x][i].w;
		if (v == father)
			continue;
		dfs(id, top, v, x, W);
		tree[x] += tree[v];
	}
}

void solve(int id, int x, int father) {
	for (int i = 0; i < e[x].size(); i++) {
		int v = e[x][i].v;
		int w = e[x][i].w;
		if (v == father)
			continue;
		f[v] = f[x] - tree[v] * w + (siz[id] - tree[v]) * w;
		if (f[v] < f[head[id]]) {
			head[id] = v;
		}
		solve(id, v, x);
	}
}

signed main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x, y, z;
		cin >> x >> y >> z;
		e[x].push_back({y, z});
		e[y].push_back({x, z});
	}
	for (int i = 1; i <= n - m - 1; i++) {
		cin >> a[i];
	}
	sort(a + 1, a + 1 + n - m - 1);
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			dfs(++cnt, i, i, 0, 0);
			head[cnt] = i;
			solve(cnt, i, 0);
		}
	}
	for (int i = 1; i <= cnt; i++) {
		q.push({siz[i], head[i]});
	}
	cnt = 0;
	while (q.size() > 1) {
		cnt++;
		edge x = q.top();
		q.pop();
		edge y = q.top();
		q.pop();
		e[x.head].push_back({y.head, a[cnt]});
		e[y.head].push_back({x.head, a[cnt]});
		int tmp;
		if (x.siz > y.siz)
			tmp = x.head;
		else
			tmp = y.head;
		q.push({x.siz + y.siz, tmp});
	}
	memset(dep, 0, sizeof(dep));
	memset(f, 0, sizeof(f));
	memset(tree, 0, sizeof(tree));
	dfs(0, 1, 1, 0, 0);
	solve(0, 1, 0);
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		ans += f[i];
		ans %= Mod;
	}
	cout << ans *QuickPower(2, Mod - 2) % Mod << endl;
	return 0;
}
```

---


# [XJTUPC 2025] 9-Nine

## 题目背景

『九次九日九重色，

天色天歌天籁音，

春色春恋春熙风，

雪色雪花雪余痕』

---  _《9-nine-》_ 

## 题目描述

工艺品（Artifact），白巳津川市自行制作的动画《轮回转生的莫比乌斯环》（虽然收视率极低）中的道具居然来到了现实！拥有它的人都会获得独有的特殊能力，这一切的一切都要从那场地震开始。

「千年之前，本世界和异世界是互通的，而工艺品正是异世界的魔法道具。由于种种原因，出现了一个叫「生命之树」的组织，将所有的工艺品回收后设下了法阵，阻止了两个世界的流通。但是由于地震，法阵被破坏，于是工艺品便流向了这个世界。」------来自异世界的玩偶索菲提娅如是说道。

在索菲的帮助下，我们的主角新海翔带领四位女主与反派进行激烈的斗争，最终成功阻止其使用工艺品犯下不可饶恕的错误。不过，为了根除这个问题，新海翔和索菲决定断绝两个世界的联系，重新打开封印。

封印的法阵可以看做两个 $9 \times 9$ 的黑白方阵，新海翔和索菲分别可以控制一个方阵，他们可以做如下动作：

- 新海翔将自己面前的方阵向左或向右旋转 $90$ 度；
- 索菲将自己面前的方阵向左或向右旋转 $90$ 度（两个方阵不联动）；
- 新海翔和索菲选择方阵的同一列，进行交换；

当新海翔一侧的方阵全是白色，同时索菲一侧的方阵全是黑色，那么封印就完成了，法阵将会开启，断开两个世界的联系，大家可以回归正常生活。

时间有限，请你------我们的「第九人（Nine）」，帮助他们在 $999$ 步内完成这个封印。

话虽如此，但是出题人被警告题出太难了，所以决定缩小数据范围！

具体的，将方阵的边长减小至 $3$，同时步数减小至 $9\times 9=81$！

形式化地说，有两个 $3 \times 3$ 的 01 矩阵 $A$ 和 $B$，你可以做如下操作：

- 操作 $1$：选择矩阵 $A$ 或 $B$，将其向左或向右旋转 $90$ 度；
- 操作 $2$：选择一个整数 $k$ ($1 \le k \le 3$)，将两矩阵的第 $k$ 列交换。

请在 $81$ 次操作内将 $A$ 变为全 0 矩阵。数据保证此时 $B$ 一定为全 1 矩阵。

## 说明/提示

可以证明，在数据合法的情况下，原题在 $999$ 步内一定存在解，弱化版的题目在 $81$ 步内一定存在解。

~~最重要的是还在分割商法的《9-nine-》今年即将推出新作，预计冬季上架某平台。~~

## 样例 #1

### 输入

```
100
000
000
111
111
011```

### 输出

```
9
BL
BL
BL
AL
C1
AL
C1
AR
C1```

# 题解

## 作者：_hud (赞：10)

# [题解：P12533 [XJTUPC 2025] 9-Nine](https://luogu.com.cn/problem/P12533)

## 题目大意  
给定两个 $3 \times 3$ 的 01 矩阵 $A$ 和 $B$，需通过以下操作在 $81$ 步内将 $A$ 变为全 0 矩阵，同时 $B$ 变为全 1 矩阵：  
1. **旋转操作**：对 $A$ 或 $B$ 左旋（逆时针）或右旋（顺时针）$90^\circ$；  
2. **交换操作**：选择一列 $k$，交换 $A$ 和 $B$ 的第 $k$ 列。

## 思路分析  
一道很好的构造题。

为了方便讲解，我们引入魔方中的概念：称矩阵 $A$ 中心元素为中心块，矩阵 $A$ 四个角上的元素为角块，其余元素为棱块。

观察样例不难发现，所给样例即是在不影响其他位置元素的前提下，交换 $A$ 和 $B$ 中两个角块的操作步骤。故我们往这个方向思考，棱块、中心块也一定能通过类似方法复原到正确的位置上。我们逐一分析：

1. **处理中心块**

显然，若 $A$ 的中心块为 1，直接交换中间列（操作 `C2`），使得中心为 0 即可。本步至多操作 $1$ 次。

2. **处理棱块**

我们可以先通过至多 $2 \times 2 = 4$ 次旋转操作将 $A$ 中为 $1$ 的棱块和 $B$ 中为 $0$ 的棱块置于第二行第一列，然后交换第一列（操作 `C1`）即可。本步至多操作 $(4 + 1) \times 4 = 20$ 次。

3. **处理角块**

我们仿照样例，先通过至多 $2 \times 2 = 4$ 次旋转操作将 $A$ 中为 1 的角块置于第三行第一列，将 $B$ 中为 0 的角块置于第一行第一列，然后通过样例中给出的操作（即 `C1`，`AL`，`C1`，`AR`，`C1`）交换两个角块即可。本步至多操作 $(4 + 5) \times 4 = 36$ 次。

统计以上三步的步数，至多需要 $1 + 20 + 36 = 57$ 次，远小于题目要求的 $81$ 次。可以通过此题。

同时，还需要通过模拟实现旋转和交换列的操作，这里就不细讲了。具体可以看代码。

## 代码  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define DEBUG { cout << '\n' << a[1] << ' ' << a[2] << ' ' << a[3] << '\n' << b[1] << ' ' << b[2] << ' ' << b[3] << "\n\n"; }
string a[4], b[4], opts[82];
int opt;
inline void C(int x) {
    opts[opt++] = "C" + to_string(x);
	char t0 = a[1][x], t1 = a[2][x], t2 = a[3][x];
    a[1][x] = b[1][x], a[2][x] = b[2][x], a[3][x] = b[3][x], b[1][x] = t0, b[2][x] = t1, b[3][x] = t2;
}
inline void AL() {
    opts[opt++] = "AL";
	string t1 = a[1], t2 = a[2], t3 = a[3];
	a[1][1] = t1[3], a[1][2] = t2[3], a[1][3] = t3[3], a[2][1] = t1[2], a[2][2] = t2[2], a[2][3] = t3[2], a[3][1] = t1[1], a[3][2] = t2[1], a[3][3] = t3[1];
}
inline void AR() {
    opts[opt++] = "AR";
	string t1 = a[1], t2 = a[2], t3 = a[3];
	a[1][1] = t3[1], a[1][2] = t2[1], a[1][3] = t1[1], a[2][1] = t3[2], a[2][2] = t2[2], a[2][3] = t1[2], a[3][1] = t3[3], a[3][2] = t2[3], a[3][3] = t1[3];
}
inline void BL() {
    opts[opt++] = "BL";
	string t1 = b[1], t2 = b[2], t3 = b[3];
	b[1][1] = t1[3], b[1][2] = t2[3], b[1][3] = t3[3], b[2][1] = t1[2], b[2][2] = t2[2], b[2][3] = t3[2], b[3][1] = t1[1], b[3][2] = t2[1], b[3][3] = t3[1];
}
inline void BR() {
    opts[opt++] = "BR";
	string t1 = b[1], t2 = b[2], t3 = b[3];
	b[1][1] = t3[1], b[1][2] = t2[1], b[1][3] = t1[1], b[2][1] = t3[2], b[2][2] = t2[2], b[2][3] = t1[2], b[3][1] = t3[3], b[3][2] = t2[3], b[3][3] = t1[3];
}
signed main() {
    cin.tie(0), cout.tie(0) -> sync_with_stdio(0);
    for(int i = 1; i <= 3; i++) cin >> a[i], a[i] = " " + a[i];
    for(int i = 1; i <= 3; i++) cin >> b[i], b[i] = " " + b[i];
    // 第一步：处理中心块
    if(a[2][2] == '1') C(2);
    // 第二步：处理棱块
    for(int i = 0; i < 4; i++) {
		if(a[1][2] == '1') AL();
		else if(a[2][3] == '1') AR(), AR();
		else if(a[3][2] == '1') AR();
		if(a[2][1] == '1') {
			if(b[2][1] == '0') {}
			else if(b[1][2] == '0') BL();
			else if(b[2][3] == '0') BR(), BR();
			else BR();
			C(1);
        }
	}
    // 第三步：处理角块
    for(int i = 0; i < 4; i++) {
		if(a[1][3] == '1') AL(), AL();
		else if(a[1][1] == '1') AL();
		else if(a[3][3] == '1') AR();
		if(a[3][1] == '1') {
			if(b[1][1] == '0') {}
			else if(b[1][3] == '0') BL();
			else if(b[3][1] == '0') BR();
			else BR(), BR();
			C(1), AL(), C(1), AR(), C(1);
		}
	}
    cout << opt << '\n';
    for(int i = 0; i < opt; i++) cout << opts[i] << '\n';
    return 0; // 完结撒花
}
```

---

## 作者：Vitamin_B (赞：4)

# 思路
纯纯一道 BFS。

## 预处理
首先，你可以先把输入进来的字符串矩阵给转化为二进制数，作为 BFS 的起点。

```cpp
for (int i = 0; i < 3; ++ i) {
  cin >> s;
    for (int j = 0; j < 3; ++ j)
      sa = sa << 1 | (s[j] - '0');
}
```

## 五种操作
1. 旋转：我们可以现在草稿上打好旋转后的二进制数的每一个二进制位在原二进制数上的映射，随后直接使用。这边直接放出：
    ```
    l[] = {
      6, 3, 0,
      7, 4, 1,
      8, 5, 2
    }, r[] = {
      2, 5, 8,
      1, 4, 7,
      0, 3, 6
    };
    ```
1. 交换：由于是二进制数，所以我们不能直接使用 `swap` 函数，我们要先利于按位与运算把 $x$ 的第 $i$ 位清空，再取出 $y$ 的第 $i$ 位并利用或运算塞进 $x$ 的第 $i$ 位中。

## BFS
我们需要在此阶段进行 $5$ 种操作增加分支。但显然直接爆搜复杂度会爆炸，所以需要记忆化并记录下对于每个状态的操作数、上一步操作类型（需要用于输出）。

## 输出
这需要输出操作方案，所以可以采用递归的方式倒序输出先前记录的上一步操作类型。
```
void f(当前状态){
  f(上一步操作前的状态);
  输出上一步操作类型;
}
```

---

[完整代码](https://www.luogu.me/paste/vx0p9mxt)。

---

## 作者：Focux_ (赞：3)

状压 BFS。

对于每个已经出现过的状态，将其还原进行操作后，再将其压成二进制的状态，若在此之前没有出现过，那么便将其压入队列中。

关于如何保存路径，可以开一个路径数组，每次新增一个状态时，就将之前的状态的路径加入本次的操作压入路径数组中。

具体实现见代码片段。

旋转（以 AL 为例）。

```cpp
//代码实现中将 A、B 数组放在了一起，上半部分为 A，下半部分为 B。
//b 数组为上次的状态。
for(int i=3;i<6;i++)
	for(int j=0;j<3;j++)
		a[i][j]=b[i][j];							//B 数组不变。 
a[0][0]=b[0][2],a[0][1]=b[1][2],a[0][2]=b[2][2],
a[1][0]=b[0][1],a[1][1]=b[1][1],a[1][2]=b[2][1],
a[2][0]=b[0][0],a[2][1]=b[1][0],a[2][2]=b[2][0];	//暴力地旋转 A 数组。 
in();												//压成二进制状态。 
if(dp[ls]==0)										//若之前没有出现过，则进行处理。 
{
	dp[ls]=1;
	way[ls][0]=way[lsbf][0]+1;
	for(int i=1;i<=way[lsbf][0];i++)
		way[ls][i]=way[lsbf][i];
	way[ls][way[ls][0]]=1;							//这一段是压路径。 
	dl[++r]=ls;
}
```

交换。

```cpp
for(int k=0;k<3;k++)						//枚举修改哪一列。 
{
	for(int i=0;i<6;i++)
		for(int j=0;j<3;j++)
			a[i][j]=b[i][j];				//先赋值。 
	for(int i=0;i<3;i++)
		swap(a[i][k],a[i+3][k]);			//再修改。 
	in();
	if(dp[ls]==0)
	{
		dp[ls]=1;
		way[ls][0]=way[lsbf][0]+1;
		for(int i=1;i<=way[lsbf][0];i++)
			way[ls][i]=way[lsbf][i];
		way[ls][way[ls][0]]=5+k;			//压路径。 
		dl[++r]=ls;
	}
}
```

---


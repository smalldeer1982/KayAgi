# [UOI 2023] An Array and Addition Again

## 题目描述

给定一个编号从 $1$ 到 $100$ 的数组 $a$。初始时，对于 $1 \leq i < 100$ 有 $a_i = 0$，最后一个元素 $a_{100} = 1$。

可以通过**增量操作**来修改数组 $a$。要执行 $m$ 次**增量操作**，需要选择 $m$ 个整数 $p_1, p_2, \dots, p_m$（$1 \le p_i < 100$），并按顺序执行赋值操作 $a_{p_i} \leftarrow (a_{p_i} + a_{p_i + 1})$（$i$ 从 $1$ 到 $m$）。

给定一个整数 $n$，找到一组**增量操作**序列，使得在执行完这些操作后，数组 $a$ 的第一个元素 $a_1$ 等于 $n$。

## 说明/提示

为了清晰起见，题目描述中的输入样例已被简化。要得到正确答案，请将 $\tt{...}$ 替换为从 $97$ 到 $8$ 的整数序列。

以第二个样例的第二组输入数据为例，其中 $n = 16$。在执行以下操作后，数组 $a$ 的前 $8$ 个元素的变化如下：

- $p_1 = 99$，$a = [0, 0, 0, 0, 0, 0, 0, 0, \ldots, 0, 0, 1, 1]$；
- $p_2 = 98$，$a = [0, 0, 0, 0, 0, 0, 0, 0, \ldots, 0, 1, 1, 1]$；
- $\ldots$
- $p_{93} = 7$，$a = [0, 0, 0, 0, 0, 0, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{94} = 6$，$a = [0, 0, 0, 0, 0, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{95} = 5$，$a = [0, 0, 0, 0, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{96} = 4$，$a = [0, 0, 0, 1, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{97} = 4$，$a = [0, 0, 0, 2, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{98} = 3$，$a = [0, 0, 2, 2, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{99} = 3$，$a = [0, 0, 4, 2, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{100} = 2$，$a = [0, 4, 4, 2, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{101} = 2$，$a = [0, 8, 4, 2, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{102} = 1$，$a = [8, 8, 4, 2, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$；
- $p_{103} = 1$，$a = [16, 8, 4, 2, 1, 1, 1, 1, \ldots, 1, 1, 1, 1]$。

### 评分标准

前四个测试块允许使用**不超过 300 次**增量操作。

- （$4$ 分）：$n \leq 100$；
- （$6$ 分）：$n = k^2$，其中 $1 \le k \le 100$；
- （$10$ 分）：$n = (2^k - 1)$，其中 $k$ 为整数；
- （$13$ 分）：$n$ 是斐波那契数（即 $n$ 属于序列 $1, 1, 2, 3, 5, 8, 13, 21, 34, \dots$）；
- （最多 $67$ 分）：无额外限制。设使用的增量操作次数为 $c$。如果 $c \le 300$，得 $67$ 分；否则得 $(17 + \left \lfloor \frac{2000 - c}{34} \right \rfloor)$ 分。

用于计算最后一个测试块得分的 $\tt{C++}$ 代码如下：

```cpp
((c <= 300) ? 67 : (17 + (2000 - c) / 34))
```

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
1 0
1```

### 输出

```
99
99 98 ... 7 6 5 4 3 2 1```

## 样例 #2

### 输入

```
2 0
3
16```

### 输出

```
101
99 98 ... 7 6 5 4 3 2 1 1 1
103
99 98 ... 7 6 5 4 4 3 3 2 2 1 1```

# 题解

## 作者：Vct14 (赞：2)

构造好玩捏！

我们发现通过增量操作我们可以轻易地将一个数翻倍。所以考虑递归当前数应为多少。但是如果当前数 $k$ 是奇数的话其无法通过翻倍得到，而翻出 $k-1$ 之后再加一也不好处理。于是考虑一开始就将所有 $a_i$ 均赋为 $1$。如此若 $k$ 为奇数，可以直接递归 $\dfrac {k-1}2$；否则在递归前先将当前 $a_i$ 赋为 $2$，然后递归 $\dfrac{k-2}2$。

可以发现每次递归实质上是消去了 $k$ 的一个二进制位，最终目标为 $1$ 位（即 $1$）。而 $k$ 最多有 $\left\lfloor\log_2 10^{18}\right\rfloor+1=60$ 位，因此需要的最大 $a$ 数组大小约为 $60<100$，操作次数 $s<99+(60-1)\times3=276<300$。因此这样构造是正确的。
 
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define add op.push_back(i)

vector<int> op;
void work(int i,int k){
	if(k==1) return ;
	if(k==2){add;return ;}
	if(!(k%2)) add;
	work(i+1,(k-1)/2); // k 为偶数时，(k-2)/2==(k-1)/2
	add;add; // 将 a_i 赋值为 $a_{i+1}*2
}

signed main(){
	int t,g;cin>>t>>g;
	while(t--){
		op.clear();
		int n;cin>>n;
		for(int i=99; i>=1; i--) add;
		work(1,n);
		cout<<op.size()<<"\n";
		for(int x : op) cout<<x<<" "; 
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：MonKeySort_ZYczc (赞：1)

2025.5.25：  
Update：添加正确性证明。  


---


有点 Ad-hoc 的意思，写个题解玩玩。
## 思路流程
手玩一下样例，发现输出总是先输出 99 到 1 的 99 个数。  
那么先通过这种方法把 $a_1$ 到 $a_{100}$ 置为 1。  
$n\le10^{18}$，这样的数据范围让我们在剩下的 $300-99=201$ 次操作完成肯定需要 $O(\log n)$ 的方法完成。  
这玩意与 DS、倍增都扯不上什么关系，考虑**分治**。  
逝世递归函数：  
我们需要两个极为相似的函数，一个计算次数，一个输出方案。  
函数中传两个参，$p$ 与 $k$，代表将 $a_p$ 的值变为 $k$ 的最小操作数/输出方案。  
- 对于计算次数的函数：
   - 首先，在函数运行前设 $ans=99$；
   - 函数内：
     - 若 $k$ 值为 1，直接返回；
     - 若 $k$ 值为 2，$ans$ 值增加 1，直接返回；
     - 否则：
       - 若 $k$ 是奇数，$ans$ 值增加 2，递归，参设为 $p+1$ 与 $\frac{k-1}{2}$。
       - $k$ 是偶数，$ans$ 值增加 3，递归，参设为 $p+1$ 与 $\frac{k}{2}-1$。
         
为什么增加 2、增加 3，还有奇怪的参呢？往下看：  
（没错下面是我复制粘贴改的）
- 对于输出方案的函数：
   - 先在函数运行前输出 $ans$ **并换行**；
   - 函数内：
     - 若 $k$ 值为 1，直接返回；
     - 若 $k$ 值为 2，输出 $p$，直接返回；
     - 否则：
       - 若 $k$ 是奇数，递归，参设为 $p+1$ 与 $\frac{k-1}{2}$，之后输出 $p$，再输出 $p$**（输出两次）**。
       - $k$ 是偶数，**先输出一遍 $p$**，递归，参设为 $p+1$ 与 $\frac{k}{2}-1$，之后输出 $p$，再输出 $p$**（输出两次）**。
     - **最后再换行一次**。 

可以自己参悟一下：  
- 当 $k$ 是奇数时，由于 $a_p$ 已经是 1（还记得一开始的 99 次操作吗？），只要 $a_{p+1}$ 为 $\frac{k-1}{2}$，之后让 $a_p$ 加上两次 $a_{p+1}$ 即可。操作共两次。
- 当 $k$ 是偶数时，注意到 $a$ 数组长度只有 100，比操作数更紧，考虑用操作数换 $a$ 数组空间。先让 $a_p$ 增加 $a_{p+1}$，即 1（由于还没有递归到，$a_{p+1}$ 就是 1），然后仿照奇数时的方法即可。

让我们证明一下正确性。  
由于每次 $k$ 至少会除以 2，所以迭代层数为 $\lceil \log_2{n}\rceil$，最坏 $\lceil \log_2{10^{18}}\rceil<64$。  
每次迭代会使用 $a$ 数组中的一个位置，也就是一定使用不到 64 个位置，不会超出 $a$ 数组 100 的范围。  
再考虑操作数最坏情况，即使每次迭代操作数加上的数都是 3（实际上卡不到这么大）最坏也就 $64\times3=192$ 次操作，$192+99=291<300$，可以 AC。

实际测试中，这个方法最多操作数为 273 次（测试点 #18 与 #19），不是很优秀，欢迎挑战/证明最优操作步数。
时间复杂度大致是 $O(t\log n)$，但会有 2 到 3 的一个小常数。  
~~细节：我的代码测试点 #3 输出是 114（怎么哪都有 homo）。~~
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,g,n,ans;
void sol1(int p,int k)
{
	if(k==1) return;
	if(k&1) sol1(p+1,k>>1),ans+=2;
	else 
	{
		if(k!=2) sol1(p+1,(k>>1)-1),ans+=3;
		else ans++;
	}
 } 
void sol2(int p,int k)
{
	if(k==1) return;
	if(k&1) sol2(p+1,k>>1),cout<<p<<' '<<p<<' ';
	else 
	{
		if(k!=2) cout<<p<<' ',sol2(p+1,(k>>1)-1),cout<<p<<' '<<p<<' ';
		else cout<<p<<' ';
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>T>>g;
	while(T--)
	{
		ans=99;cin>>n;
		sol1(1,n);
		cout<<ans<<endl;
		for(int i=99;i>=1;i--) cout<<i<<' ';
		sol2(1,n);cout<<endl;
	 } 
}
```

---


# 「TFXOI Round 2」命中注定的抉择

## 题目背景

>*无有因，何果？*

## 题目描述

**在题目描述的末尾提供有形式化题意，请注意本题特殊的内存限制。**

你被流放在了时间与空间的轮回之中。等待你的，只有无尽岁月的缓慢流淌，与无尽深渊的永恒凝视。不过神打算宽恕你，所以他给了你一个能够重获新生的机会。

现在，「神」拿出了 $n$ 枚黑色棋子和 $m$ 枚白色棋子，以及 $k$ 种不同大小的盒子，第 $i$ 种盒子有 $a_i$ 个。其中，对于 $\forall i \in [1,k-1]$，一个第 $i+1$ 种盒子可以存放任意个第 $i$ 种盒子。这些棋子除颜色外都没有区别，同类的盒子也都没有区别。  

然后，你可以随意的把这 $n+m$ 个棋子分配到第 $1$ 种盒子中，棋子不能有剩余，每个第 $1$ 种盒子也不能为空。接下来，仿照第一步，再依次把第 $i$ 种盒子分配到第 $i+1$ 种盒子当中，同样第 $i$ 种盒子不能有剩余，每个第 $i+1$ 种盒子也不能为空。  

完成这些操作后，你的面前将存在多个最大规格的盒子，每个最大规格的大盒子内嵌套着若干个次大规格的盒子，每个次大规格的盒子又嵌套着若干个稍小规格盒子，以此类推，直至最小规格的盒子，且盒子里都放置有盒子或棋子。  

最后，你需要先随机地选择一个最大规格的盒子，再随机地选择一个其中次大的盒子，以此类推，直到随机摸出一枚棋子，若该棋子是黑色的，那么你就能够被「神」接纳；否则，你将永远待在时间与空间的轮回之中。

当然，你并不想待在这个暗无天日之处。你想知道，你能够被宽恕的最大概率是多少。

由于「神」并不希望你的答案有精度误差，所以**你需要输出答案对 $998244353$ 取模的结果。**

### 形式化题意
给你一棵高度为 $k+2$ 的树，**从底往上**，树的第 $0$ 层（即最底层）有 $n+m$ 个点，其中有 $n$ 个点是黑色的，$m$ 个点是白色的。树的第 $i\in[1,k]$ 层有 $a_i$ 个节点，这些点没有颜色。树的根节点连向每个第 $k$ 层的节点。  

你需要构造一种连边方案，满足除最底层节点外，每个节点至少有一个儿子节点。并且使得从树的根节点出发，每次随机地走到该节点的一个儿子节点，一直走到最底层节点为止，停留在黑色节点的概率最大。你需要输出最大概率对 $998244353$ 取模的结果。

## 说明/提示

这是一份读入数据的示例：   
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e7+5;
int n,m,k,d,x;
int a[N];
int main(){
	cin>>n>>m>>k;
	cin>>a[1]>>d>>x;
	for(int i=2;i<=k;i++){
		a[i]=((a[i-1]-d)^x);
	}
	return 0;
}
```
该读入示例保证能正确读入数据，但是**不保证该示例的内存占用满足全部数据的内存限制**。

### 样例 $1$ 解释
一共只有 $1$ 种盒子，该种盒子有 $2$ 个。  
先把 $1$ 颗黑子放入一个盒子中，再把 $2$ 颗白子放入另一个盒子中即可达到最大概率。  
答案为 $\frac{1}{2}$，取模后为 $499122177$。
### 样例 $2$ 解释
一共只有 $3$ 种盒子，每种盒子分别有 $6$ 个，$4$ 个，$2$ 个。  
答案为 $\frac{5}{6}$，取模后为 $831870295$。

下图是一种可能的摆放方法，但是并不能使概率最大化。
![](https://cdn.luogu.com.cn/upload/image_hosting/q2k8a6r4.png)
### 数据范围
对于全部的数据：$0\le n,m\le 10^9$，$0\le x\le d\le 10^9$，$0\le k\le 10^7$，$1\le a_k\le a_{k-1}\le\dots\le a_1\le n+m\le2\times10^9$，详细数据范围见下表。

数据保证答案在模 $998244353$ 下有意义。

|Subtask 编号|$n,m$|$k$|特殊限制|分值|
|:-:|:-:|:-:|:-:|:-:|
|#1||$=0$||$5$|
|#2|$\le 5$|$=1$|$a_1\le5$|$10$|
|#3||$=1$|$a_1=2$|$10$|
|#4||$=1$||$10$|
|#5||$=2$||$15$|
|#6||||$25$|
|#7|||$10$ MB 内存限制|$25$|

注：默认内存限制是 $512$ MB。

## 样例 #1

### 输入

```
1 2 1
2 0 0
```

### 输出

```
499122177```

## 样例 #2

### 输入

```
3 4 3
6 1 1
```

### 输出

```
831870295```

# 题解

## 作者：Tiffake (赞：2)

出题人题解。

Sub1 显然答案为 $\frac{n}{n+m}$。  
Sub2 是给深搜的，枚举每个盒子怎么放即可。  
所以从 Sub3 开始讲。
### Subtask #3
假设其中一个盒子共放置 $s$ 个棋子，其中有 $x$ 个黑子时概率最大。我们有 $\frac{n-x}{n+m-s}+\frac{x}{s}\le \frac{n-1}{n+m-1}+1$，因此一个盒子放一个黑子，剩下的放另一个盒子概率最大。
### Subtask #4
考虑能否从 Sub3 的结论拓展，尽量每个黑子都只放一个盒子，正确性是肯定的。  
每个盒子最多只能为答案提供 $\frac{1}{a_1}$ 的贡献，一个黑子显然也是如此。而一个黑子如果选择和 $x$ 个黑子，$y$ 个白子放在一起只会为答案贡献 $\frac{1}{a_1}(\frac{x+1}{x+y+1}-\frac{x}{x+y})$，不如单独放一个盒子。
### Subtask #5
现在，我们需要考虑有嵌套的情况。由于一开始我们已经选择了一些盒子只放黑子，现在在第二层的角度上完全可以把它们当作黑子，因为只要摸到它们就一定会摸到黑子。接下来就可以像之前一样放了。若 $n$ 大于了 $a_1$，需要注意维护一个既有白子也有黑子的盒子，在第二层时把它当作白子即可（当然概率是要算其中黑子的）。
### Subtask #6
我们把 $k$ 层分成两部分，一部分是 $a_i>n$，这时没有黑子和白子放在一起；另一部分黑子和白子会放在一起，注意算有白子的盒子的贡献。然后注意判断当前在哪部分就行了。时间复杂度 $O(k)$，如果一直用费马小定理算逆元会多一个 $\log$，不一定可过，可以先预处理所有逆元降低复杂度。  
当然，也可以用递归分治处理，不过空间复杂度较高，不宜 `#define int long long`。
### Subtask #7
现在我们不能开数组预处理，但是可以把它压成一个变量，只需要单独维护分子和分母就行了。  
~~这个 Sub 的意义是用来卡掉一些奇怪做法的~~。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid ((l+r)>>1)
using namespace std;
const ll mod=998244353;
ll n,m,cn,cm,a,k,d,x;
inline ll inv(ll n){
	ll res=1,m=mod-2;
	while(m){
		if(m&1)res=res*n%mod;
		n=n*n%mod,m>>=1;
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>k>>a>>d>>x;
	for(int i=1;i<=k;i++){
		if(a>n)m=a-n-!!cn;
		else
			if(m)cn=n-a+1,cm=m,n=a-1,m=0;
			else cn=((cn+cm)%mod*(n-a+2)%mod-cm+mod)%mod,n=a-1;
		a=a-d^x;
	}
	if(cn)cout<<(cn+(cn+cm)*n%mod)%mod*inv((cn+cm)*(n+1)%mod)%mod;
	else cout<<n*inv(n+m)%mod;
	return 0;
}
```

---

## 作者：Ligans (赞：2)

下文描述均按照**形式化题意**描述。

我们把所有叶子节点均为黑色的子树称为**黑树**，把有且仅有一个叶子节点的黑树称为**黑链**。

手模一下，发现：最优情况下树的形态有最多最长的黑链。

这是因为：越早越多选中黑树，停留在黑色节点的概率越大；而多个叶子节点的黑树，相当于对一些黑色叶子节点造成了“浪费”。

也就是说：**从上至下**，我们要在每一层构造最多的黑链。

- 当 $a_i>n$ 时，该层黑链的数量为 $n$；
- 当 $a_i\le n$ 时，
  - 若 $m=0$，该层黑链的数量仍为 $n$；
  - 否则，该层黑链的数量为 $a_i-1$，因为必须留下一个包含白色叶子节点的子树。

留下的子树仍可以包含更多的黑链，而我们仍希望在该子树中停留在黑色节点的概率最大。

这显然是原问题的缩小版，继续按照上面的构造方法做即可。

从上到下统计概率即可。每次维护概率的分数形式而非其逆元，可以让时间复杂度降一只 $\log$ 变成 $O(k)$。

```cpp
void sol(){
	n=rd(),m=rd(),k=rd();
	a=rd(),d=rd(),x=rd();
	_rep(i,1,k) a=(a-d)^x;
	a0=n+m;
	ll p=0,q=1,res=0;
	_per(i,k,0){
		a=i?(a^x)+d:a0;
		
		_modmul(p,a-res),_modmul(q,a-res);
		if(a-res>n){
			_modadd(p,n);
			break;
		}
		_modadd(p,a-res-1);
		n-=a-res-1;
		res=a-1;
	}
	wr(p*qpow(q,mod-2)%mod);
}
```

---

甚么歹毒出题人卡空间呵气煞我也。

---

## 作者：trailfight (赞：1)

从反面考虑，要求摸到黑棋概率最大等价于摸到白棋概率最小，因此尽量让白棋放在同一个子树内。从根出发，只要黑棋数量能够满足当前层的子树数量，除了和所有白棋一起放到同一棵子树的黑棋外，其它子树分别放一颗黑棋就行。如果黑棋数量小于当前层的子树数量，即可从下一层开始停止计算白棋概率，因为下一层开始的所有子树中黑棋和白棋不再混合在一起。

由于每层子树数量的运算可逆，即从

$$a_i=(a_{i-1}-d)\oplus x$$

可推出

$$a_{i-1}=(a_i\oplus x)+d$$

因此可以从根节点开始算白棋的最小概率。

最后还需要额外判断一下最终层的子树数量是否不大于黑棋数，若子树数量不大于黑棋数，则还需算一次这层中白棋的概率。

最后的最后由于求的是黑棋的最大概率，通过快速幂求出白棋最小概率后还需要换算出黑棋概率。

贴一下代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll P=998244353;
ll fz=1, fm=1, n, m, k, a, d, x;
ll ksm(ll x){
	ll y=1, z=P-2;
	while(z){
		if(z&1){
			y=y*x%P;
		}
		x=x*x%P;
		z=z>>1;
	}
	return y;
}
int main(){
	cin>>n>>m>>k;
    if(k) cin>>a>>d>>x;
    for(int i=1; i<k; ++i){
        a=(a-d)^x;
    }
    ll c=0;
    for(int i=0; i<k; ++i){
        if(a<=n){
            fm=fm*(a-c)%P;
            c=a-1;
        }else{
            fz=fz*(a-n)%P;
            fm=fm*(a-c)%P;
            break;
        }
        a=(a^x)+d;
    }
    if(a<=n){
        fz=fz*m%P;
        fm=fm*(m+n-c)%P;
    }
	cout<<(P+1-fz*ksm(fm)%P)%P<<'\n';
    return 0;
}
```

---

## 作者：modfish_ (赞：0)

说实话这题比 T3 难想吧。

## 思路
在以下文章中，我们把某一过程中，所有叶子都是黑点的树成为黑树，有叶子是白点的树称为白树。初始时有 $n$ 个黑树，$m$ 个白树。之后记黑树数量为 $B$，白树数量为 $W$。

大概想一下，你就会发现，在每一层都是把白树集中连在一个父亲上，而黑树分散开来与父亲一一对应比较优。因为这样，在这一层就有更大的概率走到黑点上。

不过事实通常不尽如人意。在每一层，我们可能遇到两种情况：

- 白点太多，无法集中在同一个点（对应 $B+1\le a_i$）。那就多分几个，也不是不能接受。但是黑点绝对不能接到同一个父亲上。
- 黑点太多，无法分散开来（对应 $B+1>a_i$）。此时你会发现：白树必定可以连到同一个父亲，同时有一些黑树无法连到独立的父亲。可以发现，把这些黑树连到白树的父亲上是最优的。

为什么呢？因为此时，无论如何都只能留下 $a_i-1$ 个黑树，那我们肯定希望，走到白树里后，仍能走到黑点的概率尽可能大。所以把这些黑树连上去可以增大概率。

现在我们已经有了一个策略，那么如何求概率呢？

注意到，当 $W>1$ 时，黑树里只有黑点，白树里只有白点，概率不言自明。只有 $W=1$ 时，才会出现白树里有黑点的情况。此时，我们记录 $P$ 表示走进白树后，走到黑点的概率。

在黑点太多的情况，我们往白树里多加了一些黑点（事实上，加了 $B-(a_i-1)$ 个，以下记为 $y$ 个）。那么概率 $P$ 发生的变化是：

$$P\leftarrow \frac{y}{y+1}+\frac{1}{y+1}\times P$$

化简一下即为：

$$P\leftarrow\frac{y+P}{y+1}$$

不过因为 $k$ 太大，如果每一次都用快速幂求一遍 $y$ 的逆元可能无法接受。我们考虑维护 $P$ 的分数形式：

$$P=\frac{U}{D}$$

每次发生的变化即为：

$$U\leftarrow U+Dy$$

$$D\leftarrow D(y+1)$$

可以直接维护。

综合来看，只要按照策略维护 $B,W,U,D$ 即可，最终按照 $W=1$ 还是 $W>1$ 稍微分类讨论一下，即可算得答案。

时间复杂度 $O(k)$，空间复杂度 $O(1)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int p = 998244353;

ll qpow(ll a, ll x){
    ll res = 1;
    while(x){
        if(x & 1) res = res * a % p;
        a = a * a % p;
        x >>= 1;
    }
    return res;
}

int main(){
    int n, m, k, a, d, x;
    scanf("%d %d %d %d %d %d", &n, &m, &k, &a, &d, &x);
    if(k == 0){
        printf("%lld\n", qpow(n + m, p - 2) * n % p);
        return 0;
    }
    ll U = 0, D = 1;
    for(int i = 1; i <= k; i ++){
        if(a - 1 > n) m = a - n;
        else{
            int y = n - (a - 1);
            U = (D * y % p + U) % p, D = D * (y + m) % p;
            n = a - 1, m = 1;
        }
        a = (a - d) ^ x;
    }
    if(m == 1) printf("%lld\n", (qpow(D, p - 2) * U % p * qpow(n + m, p - 2) % p + qpow(n + m, p - 2) * n % p) % p);
    else printf("%lld\n", qpow(n + m, p - 2) * n % p);
    return 0;
}
```

---

话说你们比赛说明里的“普及/提高-”，不会指的这道吧？

这道绝对不止黄吧，还是我太菜了？

---

## 作者：可爱大黄兔 (赞：0)

## 解题思路

首先根据公式 $a_i = (a_{i-1} - d) ^ x$ 计算每一层的盒子数，注意从第二层开始计算。使用 $op$ 表示状态。然后逐层处理：若 $op=1$：计算全黑数量 $ot = \min(a_i-1, A)$。令 $l = A - ot$，$sl = s - ot$，若 $l = 0$：则剩余全白，则 $s = a_i$，$A = ot$。若 $l = sl$：则剩余全黑，则 $s = a_i$，$A = a_i$。若 $op=2$：计算全黑数 $ot = \min(a_i-1, s-1)$。接下来可知剩余节点数 $t = (s-1) - ot$。然后更新两种节点都可能存在的概率 $v = (t + v) \times (t+1)^{-1}$。
最后处理完所有层后，根据最终状态计算答案：

- 若 $op=1$，概率为 $A \times s^{-1}$。
- 若 $op=2$，概率为 $((s-1) + v) \times s^{-1}$。

## 代码

用费马小定理求逆元，代码就不放了（~~怕小鞋神抄~~）。初始复杂度 $O(\log_{} \bmod\times k)$，用 map 优化可以防止 TLE。

---


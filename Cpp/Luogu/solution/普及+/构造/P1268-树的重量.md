# 树的重量

## 题目描述

树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。

令 $N=\{1,2,3,\cdots ,n\}$，用一个 $N$ 上的矩阵 $M$ 来定义树 $T$。其中，矩阵 $M$ 满足：对于任意的 $i$，$j$，$k$，有 $M[i,j]+M[j,k] \ge M[i,k]$。树 $T$ 满足：

1. 叶节点属于集合 $N$；
2. 边权均为非负整数；
3. $d_T(i,j)=M[i,j]$，其中 $d_T(i,j)$ 表示树上 $i$ 到 $j$ 的最短路径长度。

如下图，矩阵 $M$ 描述了一棵树。

$$M=\begin{bmatrix}
0 & 5 & 9 & 12 & 8 \\
5 & 0 & 8 & 11 & 7 \\
9 & 8 & 0 & 5 & 1 \\
12 & 11 & 5 & 0 & 4 \\
8 & 7 & 1 & 4 & 0 \\
\end{bmatrix}$$

树的重量是指树上所有边权之和。对于任意给出的合法矩阵 $M$，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵 $M$。你的任务就是，根据给出的矩阵 $M$，计算 $M$ 所表示树的重量。下图是上面给出的矩阵 $M$ 所能表示的一棵树，这棵树的总重量为 $15$。

![](https://cdn.luogu.com.cn/upload/image_hosting/dnk8ys2t.png)


## 样例 #1

### 输入

```
5
5 9 12 8
8 11 7
5 1
4
```

### 输出

```
15

```

## 样例 #2

### 输入

```
4
15 36 60
31 55
36```

### 输出

```
71```

# 题解

## 作者：TsReaper (赞：160)

锻炼思维的好题，需要运用一些树的性质。以下用g(i,j)表示点i与点j之间的距离。

首先，我们考虑n=2时的情况，很显然答案就是g(1,2)。

接下来考虑n=3时的情况。由于所有点均为叶子节点，很显然点3是从点1到点2的路径上分叉出来的，就像下图。

 ![](https://cdn.luogu.com.cn/upload/pic/1522.png) 

设蓝色部分长度为len，那么答案就是g(1,2)+len。len怎么求呢？显然，len = (g(1,3)+g(2,3)-g(1,2))/2。

n>3的情况也同理。枚举i，看看点n是不是从点1~i的路径上分叉出来的，求出的最小len就是要加到答案里面去的。如下图。

 ![](https://cdn.luogu.com.cn/upload/pic/1523.png) 

如果认为点4是从1~2的路径上分叉出来的，答案就会加上红色部分的长度。但是红色部分长度显然有一部分是多余的。只有认为点4是从1~3的路径上分叉出来的，才能加上正确答案（也就是蓝色部分）。


---

## 作者：Mathison (赞：47)

算是一种贪心吧

当$n=2$时，显然答案就是$dis(1,2)$。

当$n=3$时，（下图是偷来的）~~（水印还是洛谷2.0呢……）~~

![](https://cdn.luogu.com.cn/upload/pic/1522.png)


答案是$dis(1,2)+$蓝线长度

蓝线长度是$\frac {dis(1,3)+dis(2,3)-dis(1,2)}{2}$

因此$$ans=dis(1,2)+\frac {dis(1,3)+dis(2,3)-dis(1,2)}{2}$$

那么考虑$n$是任意值时，第$n$条路径可以处于$1$到$2$~$(n-1)$的任意一条路径上产生分支，那么我们显然要找最小值，因此最后答案

$$ans=dis(1,2)+\sum_{i=3}^{n}{min_{j=2}^{i-1}\frac {dis(1,i)+dis(i,j)-dis(1,j)}{2}}$$

```
#include<bits/stdc++.h>
using namespace std;
int n,dis[35][35];
int main()
{
    while(~scanf("%d",&n))
    {
        if(!n) break; 
        for(int i=1;i<n;i++)
            for(int j=i+1;j<=n;j++)
                scanf("%d",&dis[i][j]);
        int ans=dis[1][2];
        for(int i=3;i<=n;i++)
        {
            int tmp=0x7fffffff;
            for(int j=2;j<i;j++) 
                tmp=min(tmp,(dis[1][i]-dis[1][j]+dis[j][i])/2);
            ans+=tmp;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```


---

## 作者：dzz1537568241 (赞：25)

本篇文章有：

- 本题的题解

- 分析树上最短路的性质

------------

不得不承认这道题非常有趣，让人对**树上的最短路**有一个全新的认识

**这道题目绝对不止树上贪心那么简单**

努力思考一下可以有非常多的性质推导出来

# 问题推导

在拿到题目的时候，弄清楚你**需要求出什么**

需要：

- 树的各边长度

题目给出：

- 每个节点之间最短路

- 整个图中不存在负边


我们的做法是：每一次把一个点加入树内，求出这个点和已经构建好的树的边的长度

![](https://cdn.luogu.com.cn/upload/image_hosting/r1her4dc.png)

(注：u -> v的意思 是 **节点u 到 节点v 的最短路**)

举个例子，上图的节点编号是依次加入树中的点的编号，

第一个加入1，树的重量为0

第二个加入2，树的重量增加了1 -> o + o -> 2

第三个加入3，树的重量增加了o -> p + p -> 3

第四个加入4，树的重量增加了p -> 4

依次类推，可以发现我们只需要求出每一次加入的点与之前构建好的树的距离。

这里要强调的是：求出的是“**每一次加入的点与之前构建好的树的距离**”

节点和其父节点的距离与我们要求出的距离无关。

![](https://cdn.luogu.com.cn/upload/image_hosting/6syt9muw.png)
如上图所示，当我们把节点u加入树内

则 u -> 树的距离 = x

1.  u -> v = ( x + y )
 
1.  u -> t = ( x + z )

1.  v -> t = ( y + z )

得出 ： x = [ 1式 + 2式 - 3式 ]/ 2

现在来思考反例：

- 什么情况下反例存在呢？

当把 u 点加入树中的时候，**u到树的距离为 u -> k**

![](https://cdn.luogu.com.cn/upload/image_hosting/t46pts3m.png)

**上式求出的是：**

# u 到（v -> u 和 t -> v 和 u -> t 三条路径的交点)的距离

- **引理一：** 当把 **u 加入树中**时，**u 到该树的距离**为 **连接u 和 这棵树的最小边**

这是很显然的事情，加入 u 的时候，u到这棵树的距离为u -> k ,而 u 到这棵树的每一个节点都需要经过u -> k, 因此不可能有更小的u -> 树中节点的边

- **引理二：当且仅当v -> u 和 t -> v 和 u -> t 三条路径的交点** 是 **k时**，原来的方程才会成立

比如说， 当u点加入树中的时候,枚举到点 g

我们要求的是 uk 的距离

1.  u -> v = ( uk + ko + ov)
 
1.  u -> g = ( uk + ko + og)

1. 	v -> g = ( vo + og )

uo + og = [ 1式 + 2式 - 3式 ]/ 2

多算了一个长度为 og 的线段，显然不对。

结合引理一和引理二，我们只需要固定住一个点 v, 然后枚举树上每一个点 t， 求出 **u 到（v -> u 和 t -> v 和 u -> t 三条路径的交点)的距离**，取最小即可。

这样可以设计出 n * n算法，不需要 n ^ 3

写出伪代码：

```cpp
int ans;

for(图中每一个点u){//枚举每一个还没被加入树里的点 
	//求出 u 与该树 的距离后，把 u 加入树中 
	
	int len = INF;//len是 u 到该树的距离 
	
	int v = root;//假想了一个树中的根节点出来 
	//其实只要是已经在树上的点，都可以作为v，随便定
	
	for(树中的每一个点t){//枚举树中已经有的每一个点 
		len = min(len, ( u 到 v 的距离 + u 到 t 的距离 - v 到 t 的距离) /2 );  
	}
	
	把u加入树中
	
	ans += len;//原数的重量 + u到这棵树的距离 
}
```

最后给出真正的代码

```cpp
#include <iostream>
#define INF 0x3f3f3f
using namespace std;
int ans = 0, N = 0;
const int maxn = 45;
int d[maxn][maxn];
int main(){
	cin>> N;
	while(N){
		ans = 0;
		for(int i = 1; i <= N; i++){
			for(int j = i + 1; j <= N; j++){
				cin>>d[i][j];
				d[j][i] = d[i][j];
			}
		}
		
		int v = 1;//假想了一个树中的根节点出来 
				//其实只要是已经在树上的点，都可以作为v，随便定
		
		for(int u = 1; u <= N; u++){//枚举每一个还没被加入树里的点 
			int len = INF;//len是 u 到该树的距离 
			for(int t = 1; t < u; t++){//枚举树中已经有的每一个点 
				len = min(len, (d[u][v] + d[u][t] - d[v][t]) >> 1);
			}
			if(len != INF)ans += len; //这里由于是顺序加入，所以并没有把u加入树中的必要 
		}
		cout<< ans<< endl;
		cin>>N;
	}
}
```
这道题目可以榨出来的汁很多很多

下次给定多个个点和他们互相之间的距离，就应该要想到能够求出他们每一条边的长度

树上的最短路径，不一定一定要构建一棵树求lca的

最后祝大家CSP2019 RP++!!!

---

## 作者：Rbrq (赞：13)

啊啊啊~一道做了5个小时，看了90分钟的题目XD，现在讲讲我的理解

题目描述

树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。


令N={1..n}，用一个N上的矩阵M来定义树T。其中，矩阵M满足：对于任意的i，j，k，有M[i,j] + M[j,k] >= M[i,k]。树T满足：


1．叶节点属于集合N；


2．边权均为非负整数；


3．dT(i,j)=M[i,j]，其中dT(i,j)表示树上i到j的最短路径长度。


如下图，矩阵M描述了一棵树。




树的重量是指树上所有边权之和。对于任意给出的合法矩阵M，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵M。你的任务就是，根据给出的矩阵M，计算M所表示树的重量。下图是上面给出的矩阵M所能表示的一棵树，这棵树的总重量为15。



输入输出格式

输入格式：

 

输入数据包含若干组数据。每组数据的第一行是一个整数n(2<n<30)。其后n-1行，给出的是矩阵M的一个上三角(不包含对角线)，矩阵中所有元素是不超过100的非负整数。输入数据保证合法。

输入数据以n=0结尾。

 

输出格式：

 

对于每组输入，输出一行，一个整数，表示树的重量。

 

 

 

 

也就是说，题目会把树上两点最短路以一个不含对角线的上半部分矩阵给你，就像下面这样

 

5 9 12 8
8 11 7
5 1
4

关于这种输入的代码如下
```cpp

for ( int i = 1; i <= n; ++i )
        for ( int j = i + 1; j <= n; ++j ) {
             scanf( "%d", &dis[i][j] );
             dis[j][i] = dis[i][j];
         }
 
```

接下来讲一下思路，首先根据树的定义，两个点树上最短距离就是两个点之间的路径

 

然后我们逐一考虑一下 n 的大小对于 答案的影响

 

首先是 n=1 的时候 很明显答案为 0

然后当 n=2 的时候 如下图，答案应该为 dis[1][2]

![](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fvo6x8ddz8j306o06bt8i.jpg)

 

当 n=3 的时候 

![](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fvo6xj77quj30ba08cdfq.jpg)
 

那么就只有可能是(dis[1][3]+dis[2][3]-dis[1][2])>>1+dis[1][2]

 

当 n=4 的时候，我们需要考虑 它分别从 1到2 的路径中生成，从3到1的路径中生成，从2到3的路径生成，寻找它们的最小值，就是多出来的长度

 

核心代码

 
```cpp
for ( int i = 3;i <= n; ++i ) {
            int dt = 0x3f3f3f3f ;
            for ( int j = 1; j <= i - 1; ++j )
              for ( int k = 1; k <= j - 1; ++k ) {
                 dt = min ( dt, ( dis[j][i] + dis[k][i] - dis[j][k] ) >> 1 );
           }
           ans += dt;
      }
```

 

切记 ans要加上dis[1][2];

 

完整代码

 ```cpp
include<bits/stdc++.h>
using namespace std;

const int Maxn = 31;

int n, ans = 0, dis[Maxn][Maxn];

int main () {
    while ( 1 ) {
      scanf( "%d", &n );
      if ( n == 0 ) break;
      for ( int i = 1; i <= n; ++i )
        for ( int j = i + 1; j <= n; ++j ) {
             scanf( "%d", &dis[i][j] );
             dis[j][i] = dis[i][j];
         }
      ans = dis[1][2];
      for ( int i = 3;i <= n; ++i ) {
            int dt = 0x3f3f3f3f ;
            for ( int j = 1; j <= i - 1; ++j )
              for ( int k = 1; k <= j - 1; ++k ) {
                 dt = min ( dt, ( dis[j][i] + dis[k][i] - dis[j][k] ) >> 1 );
           }
           ans += dt;
      }
      printf("%d\n", ans);         
    } 
    return 0; 
} 
```

![](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fvo6yc46xrj30mb0d7aa9.jpg)

---

## 作者：white_hat_hacker (赞：12)

同学们最好###先看看楼下的题解，再看俺滴啦

直接看人家会害羞地(✿◡‿◡)   (逃

========================================

这题的求解方法是对于每个节点x，找到它到已知的节点y的LCA（x,y）的距离###最小值，并将最小值加入ans。

========================================

证明思路：

把以任意已知节点为根root、以所有已知节点作为树的节点，所形成的树记作T，设{y}属于T，将待处理的节点x插入T中，可以根据矩阵算得root与LCA（x,y）的距离，设为{L}。由于T的特殊性，即以某个已知叶子节点为root，**可以存在一条有权值边，不连接任何叶子节点**。设Li属于L，且Li###不等于max{L}，那么###无法确定x是否处于root与y的链上，因为x既可以###直接作为y与root的链的分支，###间接作为分支的分支，而所得的结果是相同的。

如图：

![](http://chuantu.biz/t5/150/1501000570x3026628498.jpg)

再来考虑max{L}，**不可能同时存在两种情况**，使得满足root到LCA(x,y)的距离为max{L}。从这个角度来说，我们就确定了x与相应L最大的节点的相对位置。

###也就是说，当且仅当root与LCA(x,y)的距离最大时，x与y的关系才可以确定，即x，y可以看作是类似兄弟的关系。

###从而得出，当root与LCA(x，y)的距离最大，对于x与LCA(x，y)最小，从而我们把最小值加入ans。

证明完毕。

=========================================

不知道讲的够不够清楚，反正抓住最大值才能确定大致位置就可以辣。

贴上代码：


```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAXN 35
using namespace std;
int d[MAXN][MAXN];
int n;
int main()
{
    while(1){
        scanf("%d",&n);
        if(!n){
            break;
        }
        for(int i=1;i<n;i++){
            for(int j=i+1;j<=n;j++){
                scanf("%d",&d[i][j]);
            }
        }
        int ans=d[1][2];
        for(int i=3;i<=n;i++){
            int t=0x7fffffff;
            for(int j=2;j<i;j++){
                t=min(t,d[1][i]-(d[1][j]+d[1][i]-d[j][i])/2);
            }
            ans+=t;
        }
        printf("%d\n",ans);
    }
    return 0;
}
PS：都要修复数据干啥？这题明明是多组数据有木有？！一组顶你好几组的！！！
```

---

## 作者：A_Big_Jiong (赞：5)

~~来自一个CSP2019在**树**上吊死的蒟蒻~~

------------

## 算法

#### 0. 第$1$点与第$2$点之间的链必然存在，只是形态可能不同，直接添加

#### 1. 考虑加入第$i,i \geq 3$个点，插入到先前存在的链上

#### 2. 设新加入的边的长度为$s$，易得

------------

$s=\frac{dis[x][y]+dis[x][i]+dis[y][i]}{2}-dis[x][y]$

化简得

$s=\frac{-dis[x][y]+dis[x][i]+dis[y][i]}{2}$

其中$x$是哪个点无关紧要，$x$的存在是为了计算$s$的值的，多余的长度会被减去

------------

#### 3. 计算s的最小值

------------

一开始我也是对求最小值很不理解，于是乱搞了一下，搞了个估计是假的证明，但看到网上基本没有证明，所以还是写一下这个**很不数学的假证明**吧

$ans$为最小边的长度，即$ans=\min{\frac{-dis[x][y]+dis[x][i]+dis[y][i]}{2}}$

假设存在$sol,sol>ans$，根据题意，$sol$一定与$ans$交已构造树于**不同**链上

设$ans$交已构造树于$(u,v)$链上，则有

$sol+dis[u][v]+dis[z][u] > dis[i][v]$

其中，$i$为新拓展的点，$z$为$(u,v)$外联通至$u$的路径

$dis[u][v] > dis[i][v] - ans$

移项，得

$dis[u][v] + ans> dis[i][v]$

$sol > ans$

$dis[z][u] \geq 0$

此刻，$dis[i][v]$为树上任意两点简单路径的性质被破坏，此连接方法不存在

综上，不存在$sol>ans$且仍能满足条件

**如果大家有更好的证明方法或者发现我的证明有误还请各位麻烦告诉我，本人数学水平完蛋，还请各位dalao帮忙，感谢！**

------------

#### 4. 累加到答案中

#### 5. 输出。多组数据，别忘了初始化和数组清空

------------

## 代码
没啥好讲的，顺手贴一下吧
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 35;
int n, ans;
int dis[N][N];
int main() {
	while (~scanf("%d", &n)) {
		if (n == 0)  return 0;
		memset(dis, 0, sizeof dis);
		for (int i = 1; i < n; ++i)
		  for (int j = i + 1; j <= n; ++j)
		    scanf("%d", &dis[i][j]), dis[j][i] = dis[i][j];
		ans = dis[1][2];
		for(int i = 3; i <= n; ++i) {
			int tmp = 0x3f3f3f3f;
			for (int j = 2; j < i; ++j)
			  tmp = min(tmp, (-dis[1][j] + dis[1][i] + dis[i][j]) / 2);
			ans += tmp;
		}
		printf("%d\n", ans);
	}
	return 0;
}
```


---

## 作者：mohei0 (赞：3)

## 题意

给出一个树的叶子节点间的距离，求树的边权和

## 分析

其实这题是从看错题面开始的

本来并没有看到叶子节点这个条件，然后想到了一些奇奇怪怪的算法

### 看错题面的解法

假设给出的这些点组成了一棵树，我们要怎么做呢？

看到距离+邻接矩阵，我们就想到了floyd

显然不可能出现三个点 $a,b,c$ 的距离出现 $dis(a,b)+dis(b,c)<dis(a,c)$ 的情况

那么出现 $dis(a,b)+dis(b,c)=dis(a,c)$ 的情况呢？

这时 $b$ 必然在 $a$ 到 $c$ 的简单路径上

所以就可以乱搞了

### 真题面的解法

我们考虑模仿上面的做法

当 $dis(a,b)+dis(b,c)=dis(a,c)$ 时，显然 $c$ 到 $lca(a,c)$ 的距离 $w_1$ 与 $c$ 到 $lca(b,c)$ 的距离 $w_2$ 取 $min$ 后是等于 $0$ 的

那距离相加大于的怎么办呢？

我们发现当距离相加时，有一段路径是被重复走的，如何把这段路径求出来呢？

分类讨论一下

**当 $a$ 在 $b$ 的祖先方向， $c$ 也在 $b$ 的祖先方向时**

如图

![无标题.png](https://i.loli.net/2019/07/18/5d2ff074252af75386.png)

$dis(a,b)+dis(b,c)$ 的没有被重复走的部分是 $dis(a,c)$

所以我们可以求出重复走的长度为 $\Large\frac{dis(a,b)+dis(b,c)-dis(a,c)}{2}$

**当 $a$ 在 $b$ 的孩子方向， $c$ 在 $b$ 的祖先方向时**

![无标题.png](https://i.loli.net/2019/07/18/5d2ffaf7ec22a61889.png)

$dis(a,b)+dis(b,c)$ 的没有被重复走的部分是 $dis(a,c)$

所以我们可以求出重复走的长度为 $\Large\frac{dis(a,b)+dis(b,c)-dis(a,c)}{2}$

**当 $a$ 在 $b$ 的孩子方向， $c$ 也在 $b$ 的孩子方向时**

![2.png](https://i.loli.net/2019/07/18/5d2ffaf80c05d79455.png)

$dis(a,b)+dis(b,c)$ 的没有被重复走的部分是 $dis(a,c)$

所以我们可以求出重复走的长度为 $\Large\frac{dis(a,b)+dis(b,c)-dis(a,c)}{2}$

**结论**

综上所述，不管这三点的位置关系如何，被重复走的路长度为 $\Large\frac{dis(a,b)+dis(b,c)-dis(a,c)}{2}$

我们再来观察一下被重复走的路径的具体意义

其实就是 $b$ 到 $lca(a,b)$ 与 $b$ 到 $lca(c,b)$ 的这两个距离取 $min$

那么这个有什么用呢？

其实我们将一个点 $u$ 到所有不是 $u$ 子树中的点的 $lca$ 求出来后，最小的距离就是 $u$ 到 $u$ 父亲的距离

但怎么处理在 $u$ 子树中的点呢？

我们发现一旦点中有 $u$ 的子树中节点时，求出的 $lca$ 一定为 $0$ ，也就是不跳父亲，我们只要等这个子树中的节点跳到 $u$ 就好了

所以我们一步一步跳父亲就好了

具体如何跳父亲呢？

$\forall \text{v在u的祖先方向},dis(u,v)=dis(v,u)=dis(u,v)-\text{u到u父亲的距离}$

也就是在邻接矩阵中一行一列的减

注意距离为 $0$ 就不用再减了

注意跳父亲后时合并两个相同的点，我用的方法是当两点相同时直接不处理其中一点

怎么判断两点相同呢？

当 $dis(u,v)=0$ 时 $u,v$ 就相同了

答案就是所有边之和，也就是每次跳父亲时距离累加

小细节见代码

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXN=37;

int n,ans;
int m[MAXN][MAXN]; //邻接矩阵，相当于dis
bool same[MAXN]={0}; //0不忽略，1忽略

int main()
{
	cin>>n;
	while(n)
	{
		memset(same,0,sizeof(same)); //忽略点的初值全设为不忽略
		ans=0;
		for(int i=1;i<=n;i++)
			for(int j=i+1;j<=n;j++){cin>>m[i][j];m[j][i]=m[i][j];}
		for(int i3=0;!i3;) //跳到只剩下一个点为止
		{
			for(int i=1,minn,k;i<=n;i++)
			{
				if(same[i]) continue; //当这个点被忽略时，不对这个点进行操作
				k=0; //k是取任意一个不是i的点（因为要凑齐三个点）
				minn=1e9; //minn是最小的lca距离
				for(int j=1;j<=n;j++)
					if(!same[j]&&i!=j) k=j; //不能取被忽略的点，也不能取i
				if(k==0){i3=1;break;} //当没有符合条件的k时，意味着只剩一个点，就直接输出答案 
				for(int j=1;j<=n;j++)
					if(i!=j&&k!=j&&!same[j]) //当第三点不同于i与k，且没有被忽略 
						minn=min(minn,(m[i][j]+m[i][k]-m[j][k])/2); //取min 
				if(minn==1e9){ans+=m[i][k];i3=1;break;}
				//当没有满足条件的第三点时，minn不会被更新，这时ans加上最后剩下的两点间的边，输出答案 
				for(int j=1;j<=n;j++) //跳父亲 
					if(!same[j])
					{
						m[i][j]=m[i][j]-minn;
						m[j][i]=m[j][i]-minn;
					}
				ans+=minn; //记答案 
				for(int j=1;j<=n;j++)
					if(!same[j]&&m[i][j]==0&&i!=j) same[j]=1; //忽略距离为0的点 
			}
		}
		cout<<ans<<endl;
		cin>>n;
	}
}
```

---

## 作者：EricWay1024 (赞：3)

应当这样理解这道题：

起初，树上只有两个节点1和2.这时，树的重量就是它们之间的路径长度m[1][2]。

现在，假设树上有k-1个节点(3<=k<=n), 我们希望把第k个节点加入到这棵树中。这会导致树的重量增大，增大的量恰好就是第k+1个节点到它**目前的树**上的父亲的距离。于是我们只需要计算这个距离。

注意到：除非只有两个节点，叶子节点以外的节点都一定有至少两个儿子，否则这个节点可以删去。

因此：第k个节点一定有兄弟节点，记为bro。因为k>=3，所以现在树上应该还可以再找到至少一个节点，记为rand。

注意到：从bro到k的路径长度加上从k到rand的路径长度，恰好等于从bro到rand的路径长度加上两倍的k到它父亲的距离。

我们其实并不需要特意找bro和rand。只需要枚举路径起始点i, 终点设为1，取最小值即可。注意：显然i应该在k之前。

```cpp
#include<bits/stdc++.h>
#define INF 0x7f7f7f7f
#define N 50
#define M
using namespace std;

inline int read(){
    int x=0; int sign=1; char c=getchar();
    while(c>'9' || c<'0') {if (c=='-') sign=-1;c=getchar();}
    while(c>='0' && c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x*sign;
}

int m[N][N];
int dis[N];
int main(){
#ifdef ERIC
    //freopen("1268.in", "r", stdin);
#endif
    int n;
    while (n=read()){
        for(int i=1; i<=n-1; i++){
            for(int j=i+1; j<=n; j++){
                m[j][i]=m[i][j]=read();
            }
        }
        int ans=m[1][2];
        memset(dis, INF, sizeof(dis));
		for (int k=3; k<=n; k++){
			for (int i=2; i<k; i++){
				dis[k]=min(dis[k], m[i][k]+m[k][1]-m[i][1]);
				}
			}
			ans+=dis[k]/2;
		} 
        cout<<ans<<endl;
        
    }
    
    return 0;
}


```

---

## 作者：杰森的伯恩 (赞：3)

#思考过程

结论：矩阵中的任意M（i，j）表示的其实就是i到j的最短路径。

证明：

反设M（i，j）不是最短路径，则一定存在一个k，使得M（i，k）+M（k，j）<M(i,j),而题目中说对于任意的k均满足：M[i,j] + M[j,k] >= M[i,k]，矛盾！


不妨以一号节点为根，根据两两点之间的最短路径建出的树应该都是同构的，题目中要求的树的重量实际上就是这些同构的树中边权和最小的那个，那如何建造边权和最小的那个呢？

借用一下楼下的图<https://cdn.luogu.com.cn/upload/pic/1523.png>

用蓝边连接4号节点比用红边连接4好节点所得到的树边权和更小，因为有一部分可以共用就节省了开销。那么根据这个可以有个很直观的感受，使所有的非叶子节点尽可能地靠近叶子节点，远离根节点，使公共部分尽量多，这就是题目的本质。

具体的实现过程与代码楼下已经很详细了。


---

## 作者：zhangzuhao啊tlan (赞：2)

首先我们看一下题目给我们的信息。

题目给了你一个邻接矩阵，表示任意两个点之间的最短路径。
并说明这个图是一个树，且边权为非负整数。
并且给你一个树的重量的定义：树上所有边的边权和。
并不加证明的给你性质：树的重量是唯一的。
让你求任意一个邻接矩阵的树的重量.

#### 关键的是数据范围（矩阵中所有元素是不超过100的非负整数）。
这意味着我们可以有一些奇妙的做法。

我们先将0号节点当做根节点，1号节点为0号节点的末端。
![](https://cdn.luogu.com.cn/upload/image_hosting/6pf2uo07.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

接下来我们需要一个节点一个节点的向树上添加，并且需要满足邻接矩阵的性质，同时维护答案。
数据范围很小，这就意味着我们可以在树枝上建立数组，维护到下一个树枝的指针。

![](https://cdn.luogu.com.cn/upload/image_hosting/0eoszamv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

一开始建立树枝时，树枝上的枝杈是空的。
考虑一下加入2号节点，2号节点应该加在0-1树枝上的哪里呢？
我们设2号节点到0号节点的距离为l。

![](https://cdn.luogu.com.cn/upload/image_hosting/qoqw7ur3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

同样的，我们也可以计算出2号节点到它的父节点的距离，从而更新答案。
同时在0-1树枝的相应位置上加上新的树枝，末端节点为2，更新新树枝的长度。
 
 那么扩展一下，当我们加入n号节点时，先从0-1树枝上找到新节点需要加入的位置。如果该位置没有树枝，在此加入树枝并更新答案。
 如果有树枝的话，更改l的值，在这个新树枝上递归下去，直到将节点插入一个没有树枝的位置。（注意，根和叶子都可以添加树枝）
![](https://cdn.luogu.com.cn/upload/image_hosting/0trmsoc9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

正确性证明：（具体见代码）

  一、在递归入口我们维护的是到0号节点距离的性质。
  
  二、在递归的每一层，我们维护的是到当前树枝叶子节点距离的性质
  
  三、因为输入数据保证合法，所以我们只需要维护当前可以维护的性质，直到确定树枝的位置。
  
  四、在递归至下一层时，无论树枝安在哪，都不会对与上一层其他叶子节点之间的距离产生影响
  
算法的优越性与不足（我看其他题解没有和我做的一样的就交一份吧）：

 不足：

  一、如果题目更改值域，这算法就没法用了（空间爆炸），或者用数据结构O(logn)维护树枝的位置。

  二、像是模拟，不好写
  
 优越性：
 
  一、可以确定树的形状（这道题没啥用）
  
  二、随机数据时间复杂度为O(nlogn)（还是没啥用，输入都O(n^2)了），不停的向一个地方插树枝能将时间卡至O(n^2)。
  
总结：
  
  本题解跟其他做法不太一样，虽然不如其他做法好，好歹也是一种做法，希望大家能够理解。
 
###  代码
```cpp
#include<bits/stdc++.h>
#define il inline
#define fl(i,l,r) for(register int i=(l);i<(r);++i)
#define maxn 40
#define maxa 110
using namespace std;
template <class T> inline void read(T &x) {
	//读入整型数据 
	x=0;
	char ch=getchar(),w=0;
	while (!isdigit(ch)) w=(ch=='-'),ch=getchar();
	while (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=w?-x:x;
	return;
}
struct branch;
struct branch{
	int length;//树枝长度 
	int bh;//树枝末叶节点的编号 
	branch *head;// 树枝头指针，有length+1个 树枝 
	il void apply(int b,int x);// 向树枝内存池申请空树枝 
	il void addbranch(int x,int nowl);
};
int n,ans;
int dis[maxn][maxn];
// 邻接矩阵 
branch anybra[maxn*maxa],*nowan;
// 树枝内存池 
il void branch::apply(int b,int x){
    // 向树枝内存池申请空树枝，并初始化 ，更新答案 
	head=nowan,bh=b,length=x;
	branch *end=nowan+length+1;
	for(;nowan<end;nowan++){
		nowan->bh=-1;
	}
	ans+=length;
}
void branch::addbranch(int x,int nowl){
	//x号节点递归插入（在this树枝上，长度为nowl） 
	int nowf=(nowl+dis[x][this->bh]-this->length)>>1;
	//下一层长度公式 
	int nowbh=nowl-nowf;
	//本树枝上树枝编号 
	branch *next=this->head+nowbh;
	//下一个树枝的指针 
	if(next->bh==-1){
		//如果对应位置为空， 插入树枝 
		next->apply(x,nowf);
	}
	else next->addbranch(x,nowf);
	    //不然递归该位置的树枝 
}
il void cs(){
	//初始化(答案为0，树枝内存池清空) 
	ans=0;
	nowan=anybra;
}
il bool dealone(){
	read(n);if(n==0) return 1;//输入结束 
	cs();//初始化 
	fl(i,0,n) fl(j,i+1,n) read(dis[i][j]);
	fl(i,0,n) fl(j,0,i) dis[i][j]=dis[j][i];
	//输入邻接矩阵 
	nowan++,anybra->apply(1,dis[0][1]);
	//初始化0-1树枝 
	fl(i,2,n) anybra->addbranch(i,dis[0][i]);
	//递归加入树枝 
	printf("%d\n",ans);
	//输出答案 
	return 0;
}
int main(){
	//freopen("testdata.in","r",stdin);
    begin:
    	if(dealone()) exit(0);
    goto begin;
	return 0;
}
```

 




---

## 作者：QWsin (赞：2)

**
哎呦这道题。。。

怪我开始看题解不认真

这属于构造答案的题  按刘汝佳（%%%）的说法这是最考水平的= =

所以我就做不来了

构造方法楼下讲的很清楚

我主要说一说怎么知道是哪条路分支出来的

傻逼的我想了半天觉得这无解  但是题目又没让你输出是从哪里出来的

所以好像可以枚举

一个一个点处理  假设当前点为i

枚举一个j（2<=j<i）再根据1~i i~j 1~j三条边计算多出来的长度  取这里面使得多出来的长度最小的那个

为什么不枚举其他边呢。。  因为这里所有点都好像是叶子

所以从中间多一个分支  取哪两个点来计算貌似并不影响。。

（好像我证明不了）

大概就这样啦= =

其实我是想来贴代码的  (好像比他们短的样子= =)

**
```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=50;
const int INF=(1<<30);
int d[maxn][maxn];
int main()
{
    int n;
    while(scanf("%d",&n)==1&&n)
    {
        for(int i=1;i<=n;i++)
            for(int j=i+1;j<=n;j++)
                 scanf("%d",&d[i][j]),d[j][i]=d[i][j];
        int ans=d[1][2];   //从1开始构造的话  1~2这条边是必须加进去的
        for(int i=3;i<=n;i++)
        {
            int t=INF; 
            for(int j=2;j<i;j++)
            {
                t=min(t,(d[1][i]+d[j][i]-d[1][j])/2);
            }
            ans+=t;
        }
        printf("%d\n",ans);
    }
    return 0;
}


```

---

## 作者：APTX_4869 (赞：2)

##[题目传送门](https://www.luogu.org/problem/P1268)
太巧妙了。。。
先推荐大佬的[题解](https://www.luogu.org/blog/user4341/solution-p1268)

当$n=2$时，答案就是$dis[1][2]$
那么答案大于2时呢？

![enter image description here](https://i.loli.net/2019/08/26/cNW4yivjLMtVsKu.png)

考虑3号点，因为1，和2号点的路径已经统计到答案里去了，3号点对答案产生的贡献只有蓝色部分的路径长度。那怎么求呢？考虑弗洛伊德求最短路的方法，借助中间点更新（这里不太一样啊$hhh$）。3号点一定在1号和2号节点路径的分支上，那么$dis[1][3]+dis[2][3]-dis[1][2]$就等于蓝色部分路径长度的两倍。
接下来考虑4号点，由于我们现在不知道它是从于1号点相连的那个点的分支连出来的，所以需要枚举一下。假如枚举出一个点不是我们所要求的点。如图，4号点是从1号点到3号点的路径中连出来的分支（这里说的分支是指最小的一个，因为其他的一定已经加进答案里去了）。如果我们当前枚举到了2号点，那么求出来的答案会是橙色路径的长度，但我们实际要求的其实是红色路径的长度。考虑这两条路径的区别，发现**橙色的路径比红色的路径长！**所以我们枚举的时候取最小的一个就行了。
至此，此题完美解决。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 35;
int n,ans,len,dis[N][N];
int main()
{
	scanf("%d",&n);
	while(n!=0)
	{
		ans=0;
		for(int i=1;i<=n;i++)
		 for(int j=i+1;j<=n;j++)
		  scanf("%d",&dis[i][j]);
		ans=dis[1][2];
		for(int i=3;i<=n;i++)
		{
			len=1054612165;
			for(int j=2;j<i;j++)
			{
				len=min(len,(dis[1][i]+dis[j][i]-dis[1][j])>>1);
			}
			ans+=len;
		}
		printf("%d\n",ans);
		scanf("%d",&n);
	}
	return 0;
}
```

---

## 作者：01190220csl (赞：2)

思路都一样，发份代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n;
	cin >> n;
	while (n != 0) {
		int m[31][31];
		for (int i = 1; i < n; i++)
			for (int j = i + 1; j <= n; j++)
				cin >> m[i][j];
		int ans = m[1][2], add;
		for (int i = 3; i <= n; i++) {
			add = 0x3f3f3f3f;
			for (int j = 2; j < i; j++)//这里j是目标点，如果不看，会影响看懂证明
				add = min(add, (m[j][i]+m[1][i]-m[1][j])/2);
			ans += add;
		}
		cout << ans << endl;
		cin >> n;
	}
}
```
证明如下：
	假设在考虑点a时发生错误，即$\exists 1<b<a,dis(a,b)\neq m(a,b)$（看不懂自己查）。设原解法中求出点a的目标点为c（c满足$\forall 1<k<n,(m[a][c]+m[1][c]-m[1][a])/2<=(m[a][k]+m[1][k]-m[1][a])/2$。
    
    现在考虑以1,b,c三点构成的一棵子树，该子树三边交点为x。
    
$\because dis(a,b)=m(a,b)$

$\therefore$ $a$点的正确目标点为$b$。

若该点在(1,x)上，则两种目标点相等，目标点b的假设错误。
若该点在(b,x)上，则目标点c的假设错误。
若该点在(c,x)上，则目标点b的假设错误。

应该知道为什么要最小了吧？


---

## 作者：Tyher (赞：2)

像这样的构造题目一般的技巧就是把一些点的信息合并然后减小规模，

最后得到答案。

考虑如何合并两个叶子，对于两个有相同父亲的叶子A，B，

设他们的父亲为C，设A到C的距离为x，B到C的距离为y。

那么对于所有其他的叶子D，我们有M[D,A] - M[D,B] = x - y,

且x + y = M[A,B]。

我们枚举这样的A，B,检查他们是否满足条件，如果满足，

那么我们可以解出x，y，然后把A,B合并起来。

合并A，B就是把A到C的距离调整为M[A,B]，

然后修正各个点到A的距离，即M[D,A] = M[D,A] + y。

最后合并到只剩下两个点时他们之间的距离即为答案。


```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define ll long long
#define il inline
#define rg register
#define INF 2147483647
#define N 300
using namespace std;
int n,nums[N][N],ans;
il int read()
{
    rg int data=0,w=1;char p=getchar();
    while(p!='-'&&(p<'0'||p>'9'))p=getchar();
    if(p=='-')w=-1,p=getchar();
    while(p>='0'&&p<='9')data=data*10+p-'0',p=getchar();
    return data*w;
}
int main()
{
    freopen("weight.in","r",stdin),freopen("weight.out","w",stdout);
    while(cin>>n&&n)
    {
        memset(nums,0,sizeof(nums));
        for(rg int i=1;i<=n;++i)
            for(rg int j=i+1;j<=n;++j)
                nums[i][j]=read(),nums[j][i]=nums[i][j];
        ans=nums[1][2];
        for(rg int i=3;i<=n;++i)//枚举当前要加进去的点 
        {
            rg int minn=INF;
            for(rg int j=2;j<=i-1;++j)//枚举最小的边 
                minn=min(minn,(nums[1][i]+nums[i][j]-nums[1][j])/2);
            ans+=minn;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：ShuYuMo (赞：1)

# 思路
考虑根据这个邻接矩阵，如何生成一棵树。
先将点$1-2$连边，并将距离算进最终答案，这样构成了一个只有两个节点的树。

见例图：（黑色为还未加入树中，　红色为加入了，　字母点为非叶子节点，数字点为叶子节点）
![原图](https://s2.ax1x.com/2019/11/03/KOT2nS.png)

加入两个点$1-2$，最终答案加上($2 - Ａ - B - 1$)的长度
![KOqn3R.png](https://s2.ax1x.com/2019/11/03/KOqn3R.png)

加入点$3$，最终答案再加上($A - C - D - 3$)的长度
![KOqKjx.png](https://s2.ax1x.com/2019/11/03/KOqKjx.png)

加入点$4$，最终答案再加上($D - 4$)的长度
![KOqQu6.png](https://s2.ax1x.com/2019/11/03/KOqQu6.png)

加入点$5$，最终答案加上($C - 5$)的长度
![KOqug1.png](https://s2.ax1x.com/2019/11/03/KOqug1.png)

如此往复，最终加入全部的点
![KOLtdU.png](https://s2.ax1x.com/2019/11/03/KOLtdU.png)


也就是每次加点的时候，只需要把它和最近的一个已经在树上的点相连即可。这条路径的长度需要加入最终答案。

难点在于，如何确定每次加点需要累计的答案。离当前待加入的点　最近的一个树中点一定不是一个叶子节点，

但是我们只有每个叶子节点之间的最短距离。


观察下图

![KXV0sK.png](https://s2.ax1x.com/2019/11/03/KXV0sK.png)

$1 ,2$都已经在树中了，$3$不在树中，要在最终答案中加入$A - 3$的长度，可以发现：

$$dis(A, 3) = (dis(2, 3) + dis(1, 3) - dis(1, 2)) / 2$$

也就是我们枚举两个在树中的点对，通过上面的式子，得到加入这个点的价值，这些价值中取最小值即可。

这样就可以算出答案。

我们按顺序加入点，如果当前要加入的点为点$i$，那就要考虑每一个已加入的点$1$-$(i - 1)$组成的点对。

同时可以发现，只需要从枚举$1$到剩余其他树中的点即可。

# Codes
这题代码的话，我觉得唯一的难点在于如何读入……
```cpp
/*!
 * Copyright(c) 2019 Shu_Yu_Mo
 * MIT Licensed
 * Luogu: https://www.luogu.org/space/show?uid=44615
 * Github: https://github.com/oldsuold/
 * Gitee: https://gitee.com/Shu_Yu_Mo/
 */
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
#include<set>
#include<algorithm>
#define inf 0x7fffffff
#define _R register
using namespace std;
const int _ = 110;
inline int read()
{
    char c = getchar(); int sign = 1; int x = 0;
    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); } 
    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }
    return x * sign;
}
int M[_][_];
int n;
void doit()
{
    memset(M, 0, sizeof(M));
    for(_R int i = 1;i <= n;i++){
        for(_R int j = 1;j <= n - i;j++){
            M[i][j + i] = M[j + i][i] = read();
        }
    }
    int ans = M[1][2];
    for(_R int i = 3;i <= n;i++){
        int TMP = inf;
        for(_R int j = 1;j < i;j++)
            TMP = min(TMP, ((M[1][i] + M[j][i] - M[1][j]) >> 1));
        ans += TMP;
    }
    printf("%d\n", ans);
}       
int main()
{
    while((n = read()) != 0) doit();
    return 0;
}
```

---

## 作者：Azuree (赞：0)

[查看原题请戳这里]( https://www.luogu.org/problem/P1268 )

一个非常直观的思路是直接通过搜索得到树的形态以及每一条边的边权，但是这样做貌似非常慢，所以我们可以换一种思路。

我们可以发现，因为题目让求的是树的边权的和，所以我们其实不用太关心最终树的形态。

我们从易到难进行考虑：

当只有$2$个点时，树应该是这样的：

![](https://i.loli.net/2019/11/03/243deWAZqxnfTsI.png)

抽象一下：

![](https://i.loli.net/2019/11/03/HRBVfw8LSy3nGju.png)

很显然，$ans=dis(1,2)$。

那么，如果有$3$个点呢？

考虑到如果想让最终的总边权最小，而点与点之间的距离又不变，那么我们应该尽量选取最长的公共边，于是我们可以$1->2$这条链上插入$3$.

![](https://i.loli.net/2019/11/03/w34HgEid5pvjuyY.png)

如图，其中红边边权$k$为我们插入节点$3$所消耗的最小代价，其中$k=(dis(1,3)+dis(2,3)-dis(1,2))/2$(总距离-公共边的距离)

然后我们再考虑第$4$给点：

![](https://i.loli.net/2019/11/03/fL5VxmWqYi6J7zX.png)

如图，红边和蓝边代表着节点$4$不同的插入位置，即选择了不同的边为公共边。

如果有更多的点，我们应该枚举其插入的位置，取最小值并更新答案。

特殊的，我们初始选择了$1->2$这条边，所以要把$dis(1,2)$加入答案。

code:

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register

using namespace std;

int read()
{
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

int n,ans,map[105][105];

int main()
{
    n = read();
    while(n)
    {
        for(re int i = 1; i <= n; i++)
            for(re int j = i + 1; j <= n; j++)
                map[i][j] = map[j][i] = read();
        ans = map[1][2];
        for(re int i = 3; i <= n; i++)
        {
            int Min = INF;
            for(re int j = 1; j <= i - 1; j++)
                for(re int k = j + 1; k <= i - 1; k++)
                    Min = min(Min,map[i][j] + map[i][k] - map[j][k]);
            ans = ans + (Min >> 1);
        }
        printf("%d\n",ans);
        n = read();
    }
    return 0;
}
```

---

## 作者：Tofu (赞：0)

贪心题，思维巧妙。

不能马上看懂第一篇题解的可以看看。

具体做法就是上面题解所说的：

          对于点i，在点1与点2~（i-1）的路径中找一个最小的插入边权，加入答案。
          
          插入边权的定义为：W=min(W,(dis[1][i]+dis[i][k]-dis[1][k])/2)(2<=k<=i-1)(i>=3)
          
为什么这样做是正确的？

证明如下：

1. 先撇去对路径一端一定是点1的限制，证明后面半句话。假设我们已经求得了i-1个点的“进化树”，如图

![1](https://cdn.luogu.com.cn/upload/image_hosting/22xgltz1.png)

为了使新点连接到树上的那条边权最小，我们可以枚举两个叶子节点，放在这两个点的路径上，连上新边，边权就是上述的插入边权，枚举出每个新点的最小插入边权，加入答案，保证答案最小。

形成新图

![2](https://cdn.luogu.com.cn/upload/image_hosting/0tfu4wsq.png)

假设新点k，接在了u和v的路径上。

因为给出的数据一定是合法的，所以一定可以找出一个连接点（黄点），改变 u（或v）到黄点 以及 黄点到橙点 的边权，使得dis[k][u]和dis[k][v]合法。

那么其他的dis是否也合法？

反证法:不妨再取一个点p，显然**dis[p][k]=dis[p][u]-dis[u][k]+插入边权**,等式右边都是已经合法的，要是dis[p][k]不合法，那么数据也不合法，构造不出这样一棵树，但数据一定是合法的，所以任意的dis[p][k]一定合法，证毕。

这样得出的“进化树”无需考虑树上边权的大小（即黄点在哪里），只要插入的边合法，自然能找出对应的黄点，更新对应的边权，但这些并不需要我们求，毕竟答案只与插入边权有关。

2. 对于每一个新点，我们都需要枚举两维的点作为插入的两端，这样一共是3维循环，如果固定一个端点，就能减少一维循环。正确性证明如下：

从1的证明可知，任取两点做端点一定能保证新点到所有点的dis合法。假设还是点k，接在了u和v的路径上。因为dis[1][k]合法，所以满足：**dis[1][k]+dis[u][k]-dis[1][u]=插入边权**，这个式子正好就是我们贪心的式子，只不过v变成了1，正确性显然。

每一组数据都可以优化到**O(n^2)**

最后附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int dis[40][40];
int n,m,i,j,x,tmp,ans;
int main(){
    while(true){
        cin>>n;
        if(n==0) break;
        ans=0;
        for(i=1;i<=n-1;i++){
            for(j=1;j<=n-i;j++){
                cin>>x;
                dis[i][j+i]=dis[j+i][i]=x;
            }
    	}
    	if(n>=2) ans=dis[1][2];
    	for(i=3;i<=n;i++){
            int now=100000000;
            for(j=2;j<=i-1;j++){
                now=min(now,dis[1][i]+dis[i][j]-dis[1][j]);
            }
            ans+=(now/2);
    	}   
    	cout<<ans<<endl;
    }
    return 0;
}
```


---

## 作者：keep_ (赞：0)

思路很简单，别的博客写的也很清楚了（但我一开始还是没彻

底看懂题意，写的出了问题)

在此分享一种稍微有点变化的做法

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
const int maxn=1e2;
inline int read(){
	int ret=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-f;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		ret=ret*10+(ch^'0');
		ch=getchar();
	}
	return ret*f;
}
int map[maxn][maxn];
int n;
int ans;
int main(){
//	freopen("a.in","r",stdin);
	while(cin>>n&&n!=0){
		for(int i=1;i<=n-1;i++){
			for(int j=i+1;j<=n;j++){
				map[i][j]=map[j][i]=read();
			}
			ans=0;
			ans+=map[1][2];
	//		ans=(map[3][2]+map[3][1]-map[1][2])/2
			for(int i=3;i<=n;i++){
				int tmp=0x3f3f3f3f;
				for(int j=2;j<i;j++){
					tmp=min(tmp,(map[1][i]+map[j][i]-map[1][j])/2);	
				}
				ans+=tmp;
			}
		}
		cout<<ans<<endl;
		memset(map,0,sizeof(map));
	}
	return 0;
}
```

关键思路在于，在求新加入的点i的贡献重量时我们先固定一

个点 1，枚举维护j，1-j的这条路便是i节点可能连接的路

枚举下去即可得到答案

---


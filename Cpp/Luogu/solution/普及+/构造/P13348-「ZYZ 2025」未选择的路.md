# 「ZYZ 2025」未选择的路

## 题目背景

> 黄色的树林里分出两条路 / 可惜我不能同时去涉足  
> 我在那路口久久伫立 / 我向着一条路极目望去 / 直到它消失在丛林深处
>
> 但我却选了另外一条路 / 它荒草萋萋，十分幽寂 / 显得更诱人，更美丽  
> 虽然在这条小路上 / 很少留下旅人的足迹
>
> 那天清晨落叶满地 / 两条路都未经脚印污染 / 啊，留下一条路等改日再见  
> 但我知道路径延绵无尽头 / 恐怕我难以再回返
>
> 也许多少年后在某个地方 / 我将轻声叹息将往事回顾  
> 一片树林里分出两条路 / 而我选择了人迹更少的一条 / 从此决定了我一生的道路
>
> ——义务教育教科书语文人教版七年级下册《未选择的路》

## 题目描述

在平面直角坐标系中，有一个 $n\times n$ 的网格，其最左下角的点坐标为 $(0,0)$，最右上角的点坐标为 $(n,n)$。有一个人最初站在 $(0,0)$ 的位置，要到达 $(n,n)$。他每一次移动可以沿某个方格的对角线移动，并称他**经过**了这个方格。

请你求出，在仅经过每个方格**至多**一次的情况下，他最多能经过多少方格，并给出一种可行的方案。

你可以参照样例解释中的图片理解题意。

## 说明/提示

**【样例解释 #2】**

下图是输出所对应的方案，在可能会造成歧义的地方会走颜色相同的两条线段。

![](https://cdn.luogu.com.cn/upload/image_hosting/o0ze8nab.png)

**【数据范围】**

**本题采用捆绑测试。**

|子任务编号|特殊性质|分值|
|:-:|:-:|:-:|
|$0$|$n\le6$|$30$|
|$1$|$n$ 为奇数|$25$|
|$2$|$n$ 为偶数|$25$|
|$3$|无|$20$|

对于所有的测试数据，保证：$1\le n\le10^3$。

## 样例 #1

### 输入

```
2```

### 输出

```
2
1 1
2 2```

## 样例 #2

### 输入

```
3```

### 输出

```
9
1 1
2 2
3 1
2 0
1 1
0 2
1 3
2 2
3 3```

# 题解

## 作者：tuntunQwQ (赞：8)

如图所示将网格图黑白染色后，容易发现如果我们想要经过一个黑格，那么我们的路径一定是沿着副对角线走的；如果我们想要经过一个白格，那么我们的路径一定是沿着主对角线走的。对于一个 $n$，由此可以确定一张图，我们需要在图中找到一条经过格子数最多的起点为 $(0,0)$ 且终点为 $(n,n)$ 的一笔画路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/d70qkrfs.png)

若 $n$ 为奇数，则图中仅存在 $2$ 个奇点（起点和终点），那么整张图就可以一笔画出来，经过格子数就为 $n^2$。

若 $n$ 为偶数，则图中存在 $4$ 个奇点（四个对角上的点），那么整张图就不可以一笔画出来，由于其中的 $2$ 个奇点为固定的起止点，我们必须删掉多余的奇点，只保留起止点这两个奇点。删完后应该是这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/xi3vot69.png)

我们发现，为了让奇点只剩下起点和终点，我们不得不舍弃对角线上的 $n$ 个白色格子，经过格子数就为 $n^2-n$。

接下来是求方案。既然已经知道了要走的所有点和边，我们只要输出一种移动的顺序即可。考虑当 $n$ 为奇数时，我们可以逐行经过；当 $n$ 为偶数时，我们可以由外到内经过。

![](https://cdn.luogu.com.cn/upload/image_hosting/boker1bk.png)

如图，按照蓝绿黄橙红的顺序移动。

按照移动顺序遍历再输出即可。代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,add;
signed main(){
	cin>>n;
	if(n%2==1){
		cout<<n*n<<'\n';
		for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(i%2==1){
                    if(j%2==1)cout<<i<<' '<<j<<'\n';
                    else cout<<i-1<<' '<<j<<'\n';
                }
                else{
                    if(j%2==1)cout<<i<<' '<<n-j<<'\n';
                    else cout<<i-1<<' '<<n-j<<'\n';
                }
            }
        }
	}
	else{
		cout<<n*n-n<<'\n';
		for(int i=n-1;i>1;i-=2,add++){
			for(int j=1;j<=i;j++){
				if(j%2==1)cout<<1+add<<' '<<j+add<<'\n';
				else cout<<add<<' '<<j+add<<'\n';
			}
			for(int j=2;j<=i;j++){
				if(j%2==1)cout<<j+add<<' '<<n-add-1<<'\n';
				else cout<<j+add<<' '<<n-add<<'\n';
			}
			for(int j=2;j<=i;j++){
				if(j%2==1)cout<<n-add-1<<' '<<n-add-j<<'\n';
				else cout<<n-add<<' '<<n-add-j<<'\n';
			}
			for(int j=2;j<=i;j++){
				if(j%2==1)cout<<n-add-j<<' '<<1+add<<'\n';
				else cout<<n-add-j<<' '<<add<<'\n';
			}
		}
		for(int i=n/2;i<=n;i++)cout<<i<<' '<<i<<'\n';
	}
	return 0;
}
```

---

## 作者：KappaNitori (赞：7)

### 前言

[P13348 「ZYZ 2025」未选择的路](https://www.luogu.com.cn/problem/P13348)，原题链接。

打比赛的时候硬是推公式推了半个小时，~~也算一种新奇的思路~~。

### 思路

在网格中寻找一条路径，使得覆盖的方格尽可能多，不能重复经过任何方格，点可以重复走。

我们可以分情况讨论，当 $n$ 为奇数时，只需要蛇形向上走折线便可经过所有方格，即最多覆盖 $n^2$ 个方格；

当 $n$ 为偶数时，路径呈螺旋状，根据**欧拉图**的性质，这条路径的奇点不能超过两个，所以副对角线经过的格子无法覆盖，即最多覆盖 $n^2-n$ 个格子。

### 推理

如下图：

![N=5](https://cdn.luogu.com.cn/upload/image_hosting/6ifdkryh.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/be12469m.png)



我们设 $x,y$ 来表示点当前的坐标，每移动一次便更新 $x,y$ 的位置，之后输出。易发现：

当 $n$ 为奇数，如图1，奇数层与偶数层 $x,y$ 的变化规律是不一样的，因此要分情况枚举。

当 $n$ 为偶数，如图2，螺旋的每一条边上 $x,y$ 的变化规律都是不一样的。从最外圈开始遍历，分边枚举，每次更新 $x,y$ 的起点，遍历所有矩阵，最后输出对角线上剩余的点即可。


### AC Code

```cpp
#include<bits/stdc++.h>
#define qwq cout<<"QwQ"<<endl;
#define ll long long
using namespace std;

int n;

int main()
{
	scanf("%d",&n);
	
	
	
	if(n%2)
	{
		printf("%d\n",n*n);
		int x=0,y=0;
		
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				if(i%2)
				{
					x++;
					if(j%2) y++;
					else y--;
				}
				
				else
				{
					x--;
					if(j%2) y++;
					else y--;
				}
				//分层数更新x和y。 
				
				printf("%d %d\n",x,y);
			}
			
		}
	}
	
	else
	{
		printf("%d\n",n*n-n);
			
		int x=1,y=1;
		int s=0,e=0;
		int m;
		m=n;//找替身。 
			
		while(m>=2)
		{
			s++,e++;
			x=s,y=e;
			printf("%d %d\n",s,e);
			//更新x和y的起点（均在对角线上）。 
			
			m-=2;
			//每次螺旋可以遍历两层点。 
			for(int i=1;i<=4;i++)
			{
				for(int j=1;j<=m;j++)
				{
					if(i==1) 
					{
						y++;
						if(j%2) x--;
						else x++;
					}
					if(i==2) 
					{
						x++;
						if(j%2) y++;
						else y--;
					}
					if(i==3) 
					{
						y--;
						if(j%2) x++;
						else x--;
					}
					if(i==4) 
					{
						x--;
						if(j%2) y--;
						else y++;
					}
					
					//分情况枚举螺旋的每一条边。 
					
					printf("%d %d\n",x,y);
				}
					
			}
		}
			
		for(int i=n/2+1;i<=n;i++)
		{
			printf("%d %d\n",i,i);
		} //输出对角线上剩余的点。
	}
	return 0;
}
```
End.

我们下次再见(=w=)。

---

## 作者：Cnolm (赞：4)

# 前言
[原题链接](https://www.luogu.com.cn/problem/P13348)  
本题是很有思维含量的一道题 ~~（因为我磕了很久）~~。  
看到数据范围是 $10^3$ 量级的，因此如果用 dfs 大概率会直接爆掉，因此考虑 ~~找规律~~ 递推。
# 解法
不难发现，题目中给出 $3\times3$ 格的解法不仅是最优解，还可以刚好填满所有能走的方格，因此，如有一种在该 $3\times3$ 方案上拓展的解法，且该方案在拓展的区域也填满所有方格，则其一定是最优解。

注意到，我们发现 $5\times5$ 方格上的解法可以从 $3\times3$ 方格上的解拓展而来。（如图一）  
![](https://cdn.luogu.com.cn/upload/image_hosting/aq8oo5x8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
 (图一)

同时，这样拓展的内容对所有 **单数** 边长的方格都适用。当输入一个边长为 $n$ $(n=2k+1)$ （ $k$ 为正整数）的格子时，经过的格子数就是 $n\times n$ 。  
接下来，只需要用 $5\times5$ 拓展 $7\times7$，再用 $7\times7$ 拓展 $9\times9$，以此类推。

借此，我们就可以写出处理单数边长的代码啦（如下）。
```cpp
void solve(int n) {
	bool j;
	for (int i = n - 1, j = 1;i >= 0; i--, j = !j) {
		cout << i << " " << n + j << endl;
	}
	for (int i = 1, j = 1;i <= n; i++, j = !j) {
		cout << i << " " << n + j + 1 << endl;
	}
	cout << n + 1 << " " << n + 1 << endl;
	for (int i = n, j = 1;i >= 0; i--, j = !j) {
		cout << n + j + 1 << " " << i << endl;
	}
	for (int i = 1, j = 0;i <= n; i++, j = !j) {
		cout << n + j << " " << i << endl;
	}
	cout << n + 1 << " " << n + 1 << endl;
	cout << n + 2 << " " << n + 2 << endl;
    return ;
}
```
其实代码很好理解，意思为分别处理从上到下，从下到上。从左到右，从右到左的路径。  
同时注意，输入参数 $n$ 表示的是从 $n\times n$ 拓展到 $(n+2)\times (n+2)$。

**那么！** 双数的情况呢？  
或许，在单数的情况上再伸出去一格方块不就行了吗？起初，我也是这么想的，导致[喜提WA 25pts](https://www.luogu.com.cn/record/225493932)。因此这并不是最优解。

经过 ~~手动~~ 深搜，我找到了 $4\times4$ 和 $6\times6$ 的最优解（读者可自证），（如图2）。  
![](https://cdn.luogu.com.cn/upload/image_hosting/oqcuuva0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)   ![](https://cdn.luogu.com.cn/upload/image_hosting/czf8t7c8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
(图二 & 图三)

不知道大家有没有看出什么端倪，我们可以把每个 **黑-绿-蓝-橙** 的线路走向看做一个小整体。所以双数边长的方案和单数一样，是可以 **拆解** 的！  
将每个小整体单独提取出来，逆时针旋转 45°，可以发现每个小整体依次减少 2 格的高度，增加 2 格的宽度（不理解请看图四和图五）  
![](https://cdn.luogu.com.cn/upload/image_hosting/taqoy56j.png?x-oss-process=image/resize,m_lfit,h_170,w_225) ![](https://cdn.luogu.com.cn/upload/image_hosting/o2znu28q.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
[图四 & 图五 (以 $6\times6$ 方格的最优解为例)]

按照这种方法写出双数边长的代码即可。不难发现当输入一个边长为 $n$ $(n=2k)$ （ $k$ 为正整数）的格子时，经过的格子数就是 $n\times (n-1) $ 。(减去 左上-右下 的对角线)。  
然后记得补上上面图上的粉色部分，这样就可以写出双数边长方案的代码啦！
```cpp
void solve2(int x, int y, int h, int w) {
	if (h <= 2) { //执行上述粉色部分
		for (int i = 0;i < 3;i++) cout << x + i << " " << y + i << endl;
		for (y+=3;y <= n;y+=2) {
			cout << n - 1 << " " << y << endl << n << " " << y+1 << endl;
		}
		return;
	}
	if (x != 0 || y != 0) cout << x << " " << y << endl; //注意特判0 0的情况
	for (int i = 1;i < h;i++) cout << x + i << " " << y + i << endl;
	for (int i = 0;i < w;i++) cout << x + h - i << " " << y + h + i << endl;
	for (int i = 0;i < h - 1;i++) cout << x + h - w - i << " " << y + h + w - i << endl;
	for (int i = 0;i < w + 1;i++) cout << x - w + 1 + i << " " << y + w + 1 - i << endl;
	solve2(x+2, y, h-2, w+2); //递归执行
}
```

加上判断就是 [AC Code](https://www.luogu.com.cn/record/225694405) 啦！这样就~~开心的~~干掉了一道绿题。
# AC CODE
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
void solve(int n) {
	bool j;
	for (int i = n - 1, j = 1;i >= 0; i--, j = !j) {
		cout << i << " " << n + j << endl;
	}
	for (int i = 1, j = 1;i <= n; i++, j = !j) {
		cout << i << " " << n + j + 1 << endl;
	}
	cout << n + 1 << " " << n + 1 << endl;
	for (int i = n, j = 1;i >= 0; i--, j = !j) {
		cout << n + j + 1 << " " << i << endl;
	}
	for (int i = 1, j = 0;i <= n; i++, j = !j) {
		cout << n + j << " " << i << endl;
	}
	cout << n + 1 << " " << n + 1 << endl;
	cout << n + 2 << " " << n + 2 << endl;
    return ;
}

int pow2(int n) {
	return n * n;
}
void solve2(int x, int y, int h, int w) {
	if (h <= 2) {
		for (int i = 0;i < 3;i++) cout << x + i << " " << y + i << endl;
		for (y+=3;y <= n;y+=2) {
			cout << n - 1 << " " << y << endl << n << " " << y+1 << endl;
		}
		return;
	}
	if (x != 0 || y != 0) cout << x << " " << y << endl;
	for (int i = 1;i < h;i++) cout << x + i << " " << y + i << endl;
	for (int i = 0;i < w;i++) cout << x + h - i << " " << y + h + i << endl;
	for (int i = 0;i < h - 1;i++) cout << x + h - w - i << " " << y + h + w - i << endl;
	for (int i = 0;i < w + 1;i++) cout << x - w + 1 + i << " " << y + w + 1 - i << endl;
	solve2(x+2, y, h-2, w+2);
}
signed main() {
	cin >> n;
	if (n % 2 == 1 || n == 2) { //单数情况
		cout << pow2(n) << endl;
		cout << "1 1\n";
		for (int i = 1;i+2 <= n;i+=2) {
			solve(i);
		}
		return 0;
	}
	else { //双数情况
		cout << pow2(n) - n << endl;
		solve2(0, 0, n-1, 1);
	}
	return 0;
}
```

特别注意，```solve2(int,int,int,int)``` 函数中要避免 ```0 0\n``` 的输出。

---

## 作者：Meng142857 (赞：4)

$ZYZ$ 退役 $MOer$ 来凑个热闹，然后惊奇发现 $MO$ 构造题，遂作此题解，~~抢个沙发（虽然不知道沙发还在不在）~~  
### 前置芝士：一笔画问题（欧拉问题）  
欧拉定理：任何一个连通图存在欧拉路径当且仅当其度数为奇数的点为 $0$ 或 $2$ 个。   
定理的证明：[欧拉回路存在性的判断(来自OI Wiki)](https://oiwiki.org/graph/euler/)  
### 回到原题   
注意到每一步走完后，其 $x,y$ 坐标的变化量只能是以下四种：  
$$(+1,+1),(+1,-1),(-1,+1),(-1,-1)$$  
故每一次走完之后 $x+y$ 的奇偶性不变。即每一步所到的点 $(x,y)$ 严格满足 $2|x+y$ 。  
此时我们可以构造一张图，将所有在一个单位方格对角的且满足 $2|x+y$ 两个点 $(x,y)$ 之间连上边，故每个方格恰连有一条边。这些边构成一个图 $G$ ，此时问题转化为求 $G$ 的最长欧拉路径。  
当 $n$ 为奇数时，$G$ 除了左上角和右下角全部为偶点，存在欧拉路径。故最长路长度为 $n^2$ 。    
构造：在每一行内从左往右走，右上右下交替进行。到最右端后进入上一行并返回左端，之后依法炮制即可：  
代码实现：
```cpp

cout<<n*n<<endl;
for(int i=0;i<=n-1;i++){
  if(i%2==0){
    for(int j=1;j<=n;j++){
			cout<<i+j%2<<' '<<j<<endl;
		}
	}
	else{
		for(int j=n-1;j>=0;j--){
			cout<<i+(j+1)%2<<' '<<j<<endl;
		}
	}
}
```
当 $n$ 为偶数时  
此时共有四个奇点（四个角上的点都是奇点），要删去尽量少的边使得变为两个奇点。  
设删除的边构成图 $G'$，由于 $G'$ 除了左上和右下的点其余点全部为偶点，又由于任何图的奇点只能为偶数个，故 $G$ 连通，即 $G'$ 为从左上到右下的一条欧拉路径，其长度至少为 $n$ ,故取出的边至多有 $n^2-n$ 条。  
构造：删去左上到右下主对角线的所有边，余下的边为从左下到右上的主对角线和 $\dfrac{n}{2}-1$ 个长方形，其四条边解析式为 
$$x+y=2k,x+y=2(n-k),y-x=2k,x-y=2k (1\leq k \leq\dfrac{n}{2}-1)$$  
像串糖葫芦一样每走一步走一个圈即可。  
代码实现：
```cpp
cout<<n*(n-1)<<endl;
for(int i=1;i<=n/2-1;i++){
	for(int j=i;j>=0;j--){
		cout<<j<<' '<<i*2-j<<endl;
	}
	for(int j=1;j<=n-2*i;j++){
		cout<<j<<' '<<j+i*2<<endl;
	}
	for(int j=n-2*i+1;j<=n;j++){
		cout<<j<<' '<<2*n-i*2-j<<endl;
	}
	for(int j=n-1;j>=2*i;j--){
		cout<<j<<' '<<j-i*2<<endl;
	}
	for(int j=2*i-1;j>=i;j--){
		cout<<j<<' '<<i*2-j<<endl;
	}
}
for(int i=n/2;i<=n;i++){
	cout<<i<<' '<<i<<endl;
}
```
最后把上面两个代码拼起来就可以AC啦！

---

## 作者：undefined_behavior (赞：4)

## 思路

观察subtask，发现要根据 $n$ 的奇偶性分类讨论。

 $n$ 为奇数时没什么好说的，一层层走折线就可以经过所有方格。

 重点是 $n$ 为偶数的情况，这时肯定是走不到所有的方格的。最多走到 $n(n - 1)$ 个方格。下面以 $n = 6$ 为例：
 ![](https://cdn.luogu.com.cn/upload/image_hosting/d8hl115w.png)
 ~~手画的，难看勿喷~~
 
 最优情况下，左上到右下的对角线上的方格是走不到的。采用从外到内的走法，从当前最外层的右下角走起，折线走过四条边最后回到右下角，接着走下一圈，之后补齐右上到左下的对角线即可。实现时可以采用递归的方式。

## code


```cpp
//头文件太长删掉了
#define _for(i,a,b) for(int i=(a);i<=(b);i++)
#define _rof(i,a,b) for(int i=(a);i>=(b);i--)
#define max(a,b) a>=b ? a:b
#define min(a,b) a<b ? a:b
using namespace std;
inline void solve(int x){
    printf("%d %d\n",x,x);
    if(x==n/2)return;

    int flg=1;
    _for(i,x+1,n-x){
        printf("%d %d\n",i,x-flg);
        flg^=1;
    }
    _for(i,x+1,n-x){
        printf("%d %d\n",n-x+flg,i);
        flg^=1;
    }
    _rof(i,n-x-1,x){
        printf("%d %d\n",i,n-x+flg);
        flg^=1;
    }
    _rof(i,n-x-1,x){
        printf("%d %d\n",x-flg,i);
        flg^=1;
    }

    solve(x+1);
}
signed main(){
    scanf("%d",&n);
    if(n&1){
        printf("%d\n",n*n);
        _for(i,1,n){
            if(i%2){
                _for(j,1,n)
                    printf("%d %d\n",j,i+((j%2==1)?0:-1));
            }else{
                _rof(j,n-1,0)
                    printf("%d %d\n",j,i+((j%2==0)?0:-1));
            }
        }
    }else{
        printf("%d\n",n*(n-1));
        solve(1);
        _for(i,n/2+1,n) printf("%d %d\n",i,i);
    }
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/225640784)

---

## 作者：block_in_mc (赞：2)

首先考虑 $n$ 是奇数的情况。不难发现，你可以从起点开始，依次走完每一行，最后到达终点。下图是 $n=3$ 时的走法：

![](https://cdn.luogu.com.cn/upload/image_hosting/1rul6tn4.png)

然后考虑 $n$ 是偶数的情况。可以证明，只能经过 $n^2-n$ 个格子，且只有从左上到右下对角线的格子无法被经过。

> **证明**：显然，对于某一个格子，只有一种经过它的方法（不考虑方向）。对于 $n=6$ 时，画出每个格子的对应对角线得到：
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/1qozkjjv.png)
>
> 按照欧拉图的性质，存在一条通过图中每条边恰好一次的路径（即这张图能够被**一笔画**）当且仅当度数为奇数的点有最多两个，且它们为这条路径的起点或终点。
>
> 由于起点和终点度数均为 $1$，想要这张图能够被一笔画，其它节点的度数应当均为偶数。而最左上角与右下角的节点度数为奇数，两条标红色的边应被删掉而不被经过。
>
> 删除这两条边后，其另外一顶点度数减少一变为奇数，应当再删除以其为顶点的一条边，这就会导致另外一个节点度数减少一变为奇数，依次类推。
>
> 事实上，你需要删除一条从 $(0,n)$ 到 $(n,0)$ 的路径才能解决这个矛盾，此时 $(0,n)$ 和 $(n,0)$ 度数为 $0$，其余点要么度数没有减少，要么减少 $2$，符合能够一笔画的定义。
>
> 而显然，最短的一条从 $(0,n)$ 到 $(n,0)$ 的路径就为从左上到右下的对角线 。

这里给出一种合法的构造方式：采用递归的方式，从最外圈开始一圈一圈向内走，走到最中心后再向右上直接走到终点。下图是 $n=6$ 时的走法：

![](https://cdn.luogu.com.cn/upload/image_hosting/rpz7qohr.png)

AC 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
vector<pair<int, int>> res;
void update(int l, int r) {
	res.push_back({l + 1, l + 1});
	if (r - l == 2) return;
	int x = l + 1, y = l + 1;
	while (x + 2 <= r) {
		res.push_back({x + 1, y - 1});
		res.push_back({x + 2, y});
		x += 2;
	}
	while (y + 2 <= r) {
		res.push_back({x + 1, y + 1});
		res.push_back({x, y + 2});
		y += 2;
	}
	while (x - 2 >= l) {
		res.push_back({x - 1, y + 1});
		res.push_back({x - 2, y});
		x -= 2;
	}
	while (y - 2 >= l) {
		res.push_back({x - 1, y - 1});
		res.push_back({x, y - 2});
		y -= 2;
	}
	update(l + 1, r - 1);
}
int main() {
	scanf("%d", &n);
	if (n % 2 == 1) {
		printf("%d\n", n * n);
		int x = 0, y = 0;
		while (true) {
			while (x + 2 <= n) {
				res.push_back({x + 1, y + 1});
				res.push_back({x + 2, y});
				x += 2;
			}
			res.push_back({x + 1, y + 1});
			if (y == n - 1) break;
			res.push_back({x, y + 2});
			y += 2;
			while (x - 2 >= 0) {
				res.push_back({x - 1, y - 1});
				res.push_back({x - 2, y});
				x -= 2;
			}
		}
	}
	else {
		printf("%d\n", n * n - n);
		update(0, n);
		for (int i = n / 2 + 1; i <= n; i++)
			res.push_back({i, i});
	}
	for (pair<int, int> pr : res) 
		printf("%d %d\n", pr.first, pr.second);
	return 0;
}
```

---

## 作者：Forgive_Me (赞：1)

**本题解主要讲一个自认为容易理解的代码实现，走的路径方案有清晰的图，代码有清晰注释，码风良好。**

---


特殊性质启发我们分奇偶讨论。

首先考虑**奇数**的情况。

感觉上（结合样例认为）它可以走满。  
考虑行列数均为奇数的特殊性。以下以 $n=5$ 为例。  
我们可以考虑逐行走。简单画图可以发现，我们可以从 $(0,0)$ 走到 $(n,1)$，从 $(n,1)$ 走到 $(0,2)$，以此类推。  
具体地，如下图，我们走一行蓝色再走一行红色，恰好可以走满。
![](https://cdn.luogu.com.cn/upload/image_hosting/11dl3dj4.png)

发现每一步纵坐标的增加量会取负，每一行横坐标的增加量会取负。有下面的实现。

```cpp
if(n&1)
{
	int ans=n*n;
	cout<<ans<<'\n';
	int x=0,y=0,dx=1,dy=1,op1=1,op2=-1;
	for(int i=1;i<=n;i++) 
	{
		for(int j=1;j<=n;j++)
		{
			x+=dx,y+=dy;
			cout<<x<<" "<<y<<'\n';
			dx*=op1,dy*=op2;
		}
		dx*=-1;dy*=-1;
	}
}
```

然后考虑**偶数**的情况。  

最基本的情况是 $n=4$。

如图，我们从 $(0,0)$ 出发先沿着红线走一圈到 $(1,1)$，再走蓝线走到终点。
![](https://cdn.luogu.com.cn/upload/image_hosting/g6nuxtgo.png)
  
此时我们走过的格子数是$4\times4-4=12$，也就是除了左上到右下的格子其他都走满。  
我们尝试感性证明一下这个值是答案的最大值。

**引理1**：我们走过的路径一定是一个欧拉路径，也就是一定能被一笔画。  
这意味着，图中奇度数点的个数一定为 $0$ 或 $2$。   
**引理2**：起点和终点（原图的四个顶点）一定是奇度数点（度数一定为1）。    
**引理3**：图中的每个点度数最大值为 $4$。  
**引理4**：如果我们当前所在位置为 $(x,y)$，有 $(x+y)\&1=0$。  
因为我们每次走一个斜线，横纵坐标之和的奇偶性是不变的。 

考虑我们如果要经过左上角的格子，必然经过 $(0,n)$ 和 $(1,n-1)$ 两个点。  
然而结合上面引理，我们不能在路径中继续添加奇度数点，所以 $(0,n)$ 必然不被经过。  
此时对于 $(1,n-1)$ 来说，既然 $(1,n-1)$ 到 $(0,n)$ 的边不存在，那么它的度数必然不是 $4$，最多是 $2$，因此 $(1,n-1)$ 到 $(2,n-2)$ 的边也不应存在。  
以此类推，我们就证明了对于偶数 $n$，它的答案是 $n\times n-n$。

那么我们只需考虑如何构造了。  
首先对于 $n=4$ 直接按照上图构造。  
考虑 $n=6$ 与 $n=4$ 的关系，本质就是把 $n=4$ 外围再围上一圈。
那我们能不能先走外面一圈再走中间呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/7e85b1bd.png)

考虑这样的构造。红圈是表示递归上面的 $n=4$ 情况。  
我们可以实现先走外圈，再走中间 $(1,1)$ 到 $(n-1,n-1)$，最后从 $(n-1,n-1)$ 到 $(n,n)$。  
对于 $n=8$ 同理，先走两圈蓝线再走中间 $n=4$ 的红线，最后走到终点。  
发现对于偶数，我们都可以先走一圈外圈到达相对位置的 $(1,1)$，然后递归 $n-2$。

讲一下具体的代码实现。  
为了方便，我把 $n=4$ 的步骤存到了一个数组里面，方便直接输出。  
对于外层的蓝色路径，我把它分为五个部分：$(0,0)$ 到 $(1,1)$ 以及上下左右的四边。  
每次走的时候我们记三组变量，分别表示当前位置，当前方向，下一步方向变化量。  
对于四条边的路径，我们分别讨论方向的变化，具体实现见下。

以下完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dx4[15]={1,2,3,4,3,2,1,0,1,2,3,4};
int dy4[15]={1,0,1,2,3,4,3,2,1,2,3,4};
//存下n=4的情况 
//当前处理的边长，当前的位置 
void dfs(int n,int x,int y)
{
	if(n==2)
	{
		cout<<"1 1\n2 2\n";
		return ;
	}
	if(n==4)
	{
		for(int i=0;i<12;i++)
			cout<<x+dx4[i]<<" "<<y+dy4[i]<<'\n';
		return ;
	}
	int nx=1,ny=1,dx=1,dy=-1,op1=1,op2=-1;
	//nx,ny：当前的位置
	//dx,dy：下一步坐标的变化量（走的方向）
	//op1,op2：下一步坐标变化量的变化量（走的方向变化） 
	cout<<x+nx<<" "<<y+ny<<'\n';
	for(int i=1;i<=4;i++)
	{
		//这里是一开始整理方向的时候写的，供大家理解方向 
		//if(i==1) dx=1,dy=-1,op1=1,op2=-1;
		//if(i==2) dx=1,dy=1,op1=-1,op2=1;
		//if(i==3) dx=-1,dy=1,op1=1,op2=-1;
		//if(i==4) dx=-1,dy=-1,op1=-1,op2=1;
		for(int j=2;j<=n-1;j++)
		{
			nx+=dx,ny+=dy;
			cout<<x+nx<<" "<<y+ny<<'\n';
			dx*=op1,dy*=op2;
		}
		dx*=op1,dy*=op2;
		op1*=-1,op2*=-1;
	}
	dfs(n-2,x+nx,x+ny);
	
}
signed main()
{
	int n;
	cin>>n;
	if(n==1)
	{
		cout<<"1\n1 1\n";
		return 0;
	}
	if(n&1)
	{
		int ans=n*n;
		cout<<ans<<'\n';
		int x=0,y=0,dx=1,dy=1,op1=1,op2=-1;
		for(int i=1;i<=n;i++) 
		{
			for(int j=1;j<=n;j++)
			{
				x+=dx,y+=dy;
				cout<<x<<" "<<y<<'\n';
				dx*=op1,dy*=op2;
			}
			dx*=-1;dy*=-1;
		}
	}
	else
	{
		int ans=n*n-n;
		cout<<ans<<'\n';
		dfs(n,0,0);
		for(int i=(n-4)/2;i>=1;i--) cout<<(n-i+1)<<" "<<(n-i+1)<<'\n';
		//走到终点 
	}
}
```

---

## 作者：islet3141 (赞：1)

## 在现有题解的基础上进行解释和方法的补充
1. $n$ 等于奇数时的一笔画方式确实是显然的；但 $n$ 等于偶数时，像我这样的蒟蒻很难明确地意识到本题数学证明的切入点，即左上和右下方块无法被经过。
![](https://cdn.luogu.com.cn/upload/image_hosting/xhqlbp16.png)  
这里提供一种注意到的方法，具有普适性，即寻找不变量。由于每次移动的 $x$ 和 $y$ 均 $+1$ 或 $-1$ ，奇偶性的改变抵消了，因此 $x+y$ 的奇偶性是不变的，始终为偶数。当 $n$ 为偶数的时候，点 $C$ 和点 $B$ 的 $x$ 、$y$ 之和是奇数，因此不可能被经过；而也不可能经过点 $D\to$ 点 $A$ ，因为线路既不是在点 $A$ 开始，也不是在点 $A$ 结束。综上所述，两种经过方式都不可以，因此这一格不可以被经过。

2. 提供一种新的一笔画方式，思路上更加简洁：左下到右上的对角线是主线，每到一个新的点就沿着对角线画一个内接长方形，类似老电视待机时的DVD动画轨迹。

## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int x, y, n;

void traverse() {
    while (x > 0)
    {
        x--; y++;
        cout << x << ' ' << y << '\n';
    }
    while (y < n)
    {
        x++; y++;
        cout << x << ' ' << y << '\n';
    }
    while (x < n)
    {
        x++; y--;
        cout << x << ' ' << y << '\n';
    }
    while (y > 0)
    {
        x--; y--;
        cout << x << ' ' << y << '\n';
    }
    while (x != y)
    {
        x--; y++;
        cout << x << ' ' << y << '\n';
    }
}

int main() {
    cin >> n;

    if (n % 2) cout << n * n << '\n';
    else cout << n * (n - 1) << '\n';
    
    while (x < n)
    {
        x++; y++;
        cout << x << ' ' << y << '\n';
        if (x < (n + 1) / 2) traverse();
    }
    return 0;
}
```

---

## 作者：Damon12 (赞：1)

### P13348 「ZYZ 2025」未选择的路题解
~~没想到能评绿，我还晚到了 3h。~~


---

题很好理解吧，输入也简单，只有 $n$。于是分两种情况讨论（$x$，$y$ 初始化为 0）。
1. $n$ 为奇数：
    - 题中已给出 $n=3$ 时的图，但是我们可以自己画一个更简单的，如下：![n=3](https://cdn.luogu.com.cn/upload/image_hosting/0mryztqd.png)~~这图啊，又难画，我第一次学，还不会上传，看我用心良苦，点个赞吧。~~
    - 当 $n$ 为奇数时可以填满所有格子，这里简单说明一下（这里的 $q$ 指任意偶数，$p$ 指任意奇数）：我们从 $(q,0)$ 出发时总是可以向右上，然后按特定路线（右上，右下）总是可以走到 $(q+1,n)$。关于从 $(p,n)$ 出发的情况同理，我们总能使 $(q+1,n)$ 与 $(p,n)$ 接上，从而走满所有格子。
    - 我们把他分为 3 行，从下往上标，第1行与第3行一模一样。我们可以想象一下，当行数为奇数时的路径是不是都一样（右上，右下，右上，右下……）。偶数行同理。
    - 行数为奇数时，先右上。然后重复 $\frac{n-1}{2}$ 次 _右下右上_ 。
    - 行数为偶数时，先左上。然后重复 $\frac{n-1}{2}$ 次 _左下左上_ 。
    - 可以给到代码：
      ```cpp
      if(n&1){//n 为奇数
          cout<<n*n<<"\n";//一共 n*n 个格子
          for(int i=1;i<=n;i++){
              if(i&1){//奇数行（这里的行是格子，不是坐标中的交叉点）
                  x++,y++;//右上
                  cout<<x<<" "<<y<<"\n";
                  for(int j=(n-1)/2;j>0;j--){//其实可以直接 n/2
                      x++,y--;//右下
                      cout<<x<<" "<<y<<"\n";
                      x++,y++;//右上
                      cout<<x<<" "<<y<<"\n";
                  } 
              }else{//偶数行
                  x--,y++;//左上
                  cout<<x<<" "<<y<<"\n";
                  for(int j=(n-1)/2;j>0;j--){
                  x--,y--;//左下
                  cout<<x<<" "<<y<<"\n";
                  x--,y++;//左上
                  cout<<x<<" "<<y<<"\n";
          	 }
          }
      }
      ```
      ~~对新手非常友好~~
    - 现在拿到了 n 为奇数的 25 分。
2. $n$ 为偶数：
   - 还是画个图吧，可怜下我啊：![n=4](https://cdn.luogu.com.cn/upload/image_hosting/8yiq3648.png)
   - 其实我们自己画 $n=4$ 的情况较为好画，至于 $n=8$ 请听我细细道来。
   - 画 $n=4$ 时延用 $n$ 为奇数的想法，但是我们不能走到 $(0,4)$，于是继续往上，经过几轮尝试后能找到这么一种画法，虽然不能确定是不是最长的，但我们能分析（最后证明为最长）。~~这其实是一种数学思想，但我好像不确定是不是。~~
   - 现在只剩 4 个格子没满，我们尝试连一下。![n=4](https://cdn.luogu.com.cn/upload/image_hosting/kjq5npo7.png)
   - 可以看到图中存在 4 个出度或入度为奇数的边（说白了就是连向一个点的边数），因为我们不能从黄色线段中取出任意一段加到原本的图上，所以我们可以大致总结出：不能存在超过或少于两个点连向其他边的边数为奇数，否则不能构成一条路径。
   - 说白了就是：**恰好两个顶点的度数为奇数**（作为起点和终点）。这其实是欧拉路径的一个判定条件。另一个就是所有路径连通，简单吧。
   - 于是我们尝试去掉连向 $(4,0)$ 与 $(0,4)$ 的边，这时连向 $(1,3)$ 与 $(3,0)$ 的边数又出现奇数的情况，去掉，得到了我们画的图。所以当 $n=4$ 时，答案为 12。
   - 我们还是去掉连接左上与右下边上的所有边，并且尝试用一种方案画出路径，我们先把所有能到的点用红点标出。![n=8](https://cdn.luogu.com.cn/upload/image_hosting/numuvwkt.png)
   - 先把不要的点去掉，就变成了连线操作，从 $(0,0)$ 尝试经过所有红点到达 $(8,8)$。首先只能走到 $(1,1)$，再尝试绕回来。![n=8](https://cdn.luogu.com.cn/upload/image_hosting/69dk5ash.png)
   - 现在又只能往右上，继续重发操作，我们能够画出：![n=8](https://cdn.luogu.com.cn/upload/image_hosting/sh3tp5wh.png)~~话说这个图咋调大啊 QwQ。~~
   - 还是可以证得无论再加哪条边，都会使某个点的度数变为奇数。故该法为最长路径之一。
   - 注意到了中点时直接往终点走就行了，明显看出此做法不会漏掉任何能连的点。
   - 总结一下方法：先向右上走（设该点为出发点），再以右下，右上，左上，左下的方向走到图的边缘就行了，最后回到出发点。直到走到 $(n/2,n/2)$。
   - 贴上偶数的代码：
      ```cpp
      if(!(n&1)){
          cout<<n*n-n<<"\n";//减掉对角线上的格子
          while(x+1!=n/2 && y+1!=n/2){//提前判断是否到中点
              x++;y++;
              cout<<x<<" "<<y<<"\n";
              int nx=x,ny=y;//记录“起点”
              while(y>0 && x<n){//四个循环走到底
              	x++;y--;
              	cout<<x<<" "<<y<<"\n";
              } 
              while(x<n && y<n){
              	x++;y++;
              	cout<<x<<" "<<y<<"\n";
              }
              while(y<n && x>0){
              	x--;y++;
              	cout<<x<<" "<<y<<"\n";
              }
              while(x>0 && y>0){
              	x--;y--;
              	cout<<x<<" "<<y<<"\n";
              }
              while(nx!=x && ny!=y){//回起点
              	x++;y--;
              	cout<<x<<" "<<y<<"\n";
              }
          }
           while(x!=n && y!=n){//往终点一直走
               x++;y++;
               cout<<x<<" "<<y<<"\n";
           }
      }
      ```



---

直接构造在其他的算法中应该是最快的吧。（不加其他优化的情况下）

制作不易，点个赞吧 QwQ。

---

## 作者：liuyuantao (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P13348)

一道优秀的构造题。  
观察样例我们考虑分类讨论。  
我们考虑**环状遍历**。如下图（水平有限）：  
$5 \times 5$（奇数）版：  
![](https://cdn.luogu.com.cn/upload/image_hosting/p5qx5mpf.png)  

$4 \times 4$（偶数）版：  
![](https://cdn.luogu.com.cn/upload/image_hosting/qxsxjw13.png)  
由红色，蓝色，浅蓝（如果有），黄色（如果有），绿色为行走路径。

* $n$ 是奇数。发现可以遍历全图，答案即为 $n^2$。
* $n$ 是偶数。发现可以遍历除了其中一条对角线以外的所有格子，答案即为 $n^2-n$。

以下为答案正确性简证（其实有点复杂，若有不对请指出）：  
考虑对点 $(x,y)$ 染色。对于横纵坐标和 $x+y$ 为偶数的染白色，其它染黑色。  
由对角线上转移知 $x,y$ 的绝对值变化均为 $1$。于是 $x+y$ 奇偶性不变，所以人总是在黑色点上移动。  
于是问题转化为：给定一无向连通图，选出其一个子图，使此图存在**欧拉通路**，且起点为 $(0,0)$，终点为 $(n,n)$，求最大欧拉通路长度并输出此图。  
之后我们求点的度数。对于在中央的点，四周都有点与其连通，度数为 $4$。在边上的点，有两个点与其连通，度数为 $2$，在对角线上的点，度数即为 $1$。  
* 当 $n$ 为奇数时，点 $(0,n)$ 和 $(n,0)$ 均为黑点，于是只有 $2$ 个点 $(0,0)$ 和 $(n,n)$ 为目标图中奇点，可知图中本身就存在欧拉通路，自然可以遍历全图。所有白点都被遍历，那么所有格子也就被遍历了。  
* 当 $n$ 为偶数时，点 $(0,n),(n,0),(0,0),(n,n)$ 均为奇点且在目标图中，于是图中**本身不存在**欧拉通路。由于我们已经确定了起点和终点，那么我们可以直接删掉 $(0,n)$ 与 $(1,n-1)$ 之间连的边和 $(n,0)$ 和 $(n-1,1)$ 之间连的边，理由是它们不可能在最终欧拉通路中（否则无法回头而走不到 $(n,n)$）。之后我们发现此时目标图关于 $(0,0)$ 和 $(n,n)$ 形成的**对角线对称**。我们又发现 $(1,n-1)$ 和 $(n-1,1)$ 成为了奇点（有 $3$ 条边），且对这些奇点的边进行删除后又会产生新的奇点，由此简单推理可以得到**一定会删除与对角线相连的边，与另一部分删除的边形成偶点**。于是我们可以得到结论：在左上和右下两部分所对应的删边应该也**对称**（否则此部分一定有其它奇点，对称才能保证没有额外奇点），所以我们只需最小化一部分中的删边数量，以最大化路过格子数。  
我们知道点到直线的线段中，垂线段最短。于是我们从 $(1,n-1)$ 向 $y=x$ 作垂线 $y=-x+n$，两线交于点 $(\frac{n}{2},\frac{n}{2})$。两点间路径即为删去边，另一侧对称即可。  
画图知道此时 $y=-x+n$ 这一条对角线上无边，其它均有边，答案即为全图格子数减去一条对角线上格子数。

~~呼正确性证明终于写完了……~~  
接下来是构造正确性证明：  
首先遍历对角线上的点 $(i,i)$。每遍历一个点就按照左上，右上，右下，左下，左上顺序跑一个环。显然每一条线都与上一次对应边平行无交点，于是不会跑到重边（可能有重点）。当 $i \ge \frac{n}{2}$ 时位于的环要么在 $n-i+1$ 时跑完了（$i>\frac{n}{2}$），要么没有环（$i=\frac{n}{2}$），于是直接一路走到 $(n,n)$。  
显然非对角线上的一条边一定位于一个小环中，所以此遍历方法可以不重不漏输出所有边。  
输出时可以改完到达点再输出，也可以先输出再更改。

最终时间复杂度 $O(n^2)$，空间复杂度 $O(1)$。  
这么良心的题解，为什么不点个赞呢 OvO。

[AC code](https://www.luogu.com.cn/record/225752855)
```cpp
#include <bits/stdc++.h>

using namespace std;

#define LL long long
#define min(mina,minb) ((mina<minb)?(mina):(minb))

const int N=1e3+5;

string s;
LL n,m,k,cnt,ans,gf,inf=1e16;
int fx[5]={0,-1,1,-1,1},gx[5]={0,-1,-1,1,1};

int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	if(n&1){
		cout<<n*n<<'\n';
	}
	else{
		cout<<n*(n-1)<<'\n';
		
	}
	int x,y;
		for(int i=1;i<n/2.0;i++){
			cout<<i<<' '<<i<<'\n';
			x=y=i;
			while(y>0){
				cout<<x+1<<' '<<y-1<<'\n';
				x++;y--;
			}
			while(x<n){
				cout<<x+1<<' '<<y+1<<'\n';
				x++;y++;
			}
			while(y<n){
				cout<<x-1<<' '<<y+1<<'\n';
				x--;y++;
			}
			while(x>0){
				cout<<x-1<<' '<<y-1<<'\n';
				x--;y--;
			}
			while(x<i){
				cout<<x+1<<' '<<y-1<<'\n';
				x++;y--;
			}
		}
		for(int i=ceil(n/2.0);i<=n;i++){
			cout<<i<<' '<<i<<endl;
		}
	
	return 0;
}
```

---

## 作者：Chenxuhang_play (赞：1)

## 前言

题目传送门：www.luogu.com.cn/problem/P13348

看题先看数据范围。

|子任务编号|特殊性质|分值|
|:-:|:-:|:-:|
|$0$|$n\le6$|$30$|
|$1$|$n$ 为奇数|$25$|
|$2$|$n$ 为偶数|$25$|
|$3$|无|$20$|

对于所有的测试数据，保证：$1\le n\le10^3$。

---

容易想到这道题要以奇偶数为突破口。

## 30 pts

首先可以发现对于子任务 $0$，有 $1\le n\le6$。注意到子任务 $0$ 的分数是 $30$ 分，正好是 $6$ 的倍数。于是可以认为子任务 $0$ 中的是 $n\in[1,6]$。考虑到这一点就可以直接打表骗分了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	if(n==1) cout<<"1\n1 1";
	else if(n==2) cout<<"2\n1 1\n2 2";
	else if(n==3) cout<<"9\n1 1\n2 2\n3 1\n2 0\n1 1\n0 2\n1 3\n2 2\n3 3";
	else if(n==4) cout<<"12\n1 1\n0 2\n1 3\n2 4\n3 3\n4 2\n3 1\n2 0\n1 1\n2 2\n3 3\n4 4";
    else if(n==5) cout<<"25\n1 1\n0 2\n1 3\n0 4\n1 5\n2 4\n1 3\n2 2\n1 1\n2 0\n3 1\n2 2\n3 3\n2 4\n3 5\n4 4\n3 3\n4 2\n3 1\n4 0\n5 1\n4 2\n5 3\n4 4\n5 5";
	else if(n==6) cout<<"30\n1 1\n0 2\n1 3\n0 4\n1 5\n2 6\n3 5\n4 6\n5 5\n6 4\n5 3\n6 2\n5 1\n4 0\n3 1\n2 0\n1 1\n2 2\n1 3\n2 4\n3 5\n4 4\n3 3\n2 2\n3 1\n4 2\n5 3\n4 4\n5 5\n6 6";
}
```

## 55 pts

其实可以发现对于 $n$ 是奇数，可以用一种绝妙的方法走完所有的格子。就是左右横跳。不懂没关系，看图。（如图是边长为 $5$ 的网格）

![图片](https://cdn.luogu.com.cn/upload/image_hosting/wo0if1qp.png)

对于所有的 $n$ 是奇数，都可以用这种方法走过每一个格子，显然是最优解。有了这一点就可以编写代码了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	if(n%2)
	{
		cout<<n*n<<endl;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<n;j++)
			{
				cout<<i+(j+1)%2<<" "<<(i%2 ? n-j-1 : j+1)<<endl;
			}
		}
	}
	else if(n==2) cout<<"2\n1 1\n2 2";
	else if(n==4) cout<<"12\n1 1\n0 2\n1 3\n2 4\n3 3\n4 2\n3 1\n2 0\n1 1\n2 2\n3 3\n4 4";
	else if(n==6)
	{
		cout<<"30\n1 1\n0 2\n1 3\n0 4\n1 5\n2 6\n3 5\n4 6\n5 5\n6 4\n5 3\n6 2\n5 1\n4 0\n3 1\n2 0\n1 1\n2 2\n1 3\n2 4\n3 5\n4 4\n3 3\n2 2\n3 1\n4 2\n5 3\n4 4\n5 5\n6 6";
	}
	return 0;
}
```

## 100 pts

考虑完奇数就要考虑偶数了。

先看图。（如图是边长为 $8$ 的网格）

![图片](https://cdn.luogu.com.cn/upload/image_hosting/hiw9b7b6.png)

打圆圈的地方是**没有**走过的格子。不知道大家能不能看出来什么。

每一个圈是相似的。于是我们可以构造一个函数 `even` 来画每一个圈圈。值得一提的是，每一圈中的点的横纵坐标均要加上圈数。最后沿着对角线走到 $(n,n)$ 即可。

再把奇数的代码结合进去就有了最终的代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
void even(int n,int i)
{
	int x=1;
	int y=1;
	while(y<n)
	{
		cout<<x%2+i<<" "<<y+i<<endl;
		x++;
		y++;
	}
	x=2;
	y=1;
	while(x<n)
	{
		cout<<x+i<<" "<<n-1+(y%2)+i<<endl;
		x++;
		y++;
	}
	x=1;
	y=n-2;
	while(y>0)
	{
		cout<<n-1+(x%2)+i<<" "<<y+i<<endl;
		x++;
		y--;
	}
	x=n-2;
	y=0;
	while(x>0)
	{
		cout<<x+i<<" "<<y%2+i<<endl;
		x--;
		y++;
	}
	return;
}
int main()
{
	int n;
	cin>>n;
	if(n%2)
	{
		cout<<n*n<<endl;
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<n;j++)
			{
				cout<<i+(j+1)%2<<" "<<(i%2 ? n-j-1 : j+1)<<endl;
			}
		}
	}
	else
	{
		cout<<n*(n-1)<<endl;
		for(int i=0;;i++)
		{
			even(n-2*i,i);
			if(n==2*i) break;
		}
		for(int i=n/2+1;i<=n;i++)
		{
			cout<<i<<" "<<i<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P13348 题解

非常简单的构造题。

## 思路

奇偶分讨。

当 $n$ 为奇数时比较好做，可以如下图的方式来走。

![](https://cdn.luogu.com.cn/upload/image_hosting/9lkkwgcf.png)

于是能写出这样的代码：

```cpp
int x=0,y=0,xx=1,yy=1;
while (x!=n || y!=n) {
    int nx=x+xx,ny=y+yy;
    if (nx>n || nx<0) {
        xx*=-1,yy*=-1;
        continue;
    }
    ans.emplace_back(pii{nx,ny});
    x=nx,y=ny;
    yy*=-1;
}
```

偶数的情况稍微难一点，我们会发现右下角和左上角的点是永远走不到的，因为你要走到就要走到它们对角线上的另一点，而走完回来的时候还是必须经过那条边，就不符合题意了，可以像下图一样构造：

![](https://cdn.luogu.com.cn/upload/image_hosting/6vbtd5c5.png)

对于整张图的左上到右下的对角线经过的点，每一次走过这个点，都保持当前的运动状态不变再走一次，其余保持一上一下尽可能覆盖多的点。

## 代码

```cpp
const int N=1005;

int n;
vector<pii> ans;
bool flag[N][N];

int main() {
    read(n);
    if (n&1) {
        int x=0,y=0,xx=1,yy=1;
        while (x!=n || y!=n) {
            int nx=x+xx,ny=y+yy;
            if (nx>n || nx<0) {
                xx*=-1,yy*=-1;
                continue;
            }
            ans.emplace_back(pii{nx,ny});
            x=nx,y=ny;
            yy*=-1;
        }
    } else {
        int x=0,y=0,xx=1,yy=1;
        flag[0][n]=flag[n][0]=true;
        while (x!=n || y!=n) {
            int nx=x+xx,ny=y+yy;
            if (flag[x+1][y-1]) {
                yy*=-1,flag[x][y]=true;
                ny=y+yy;
                ans.emplace_back(pii{nx,ny}),x=nx,y=ny,yy*=-1;
            } else if (nx>n || nx<0) xx*=-1,yy*=-1;
            else ans.emplace_back(pii{nx,ny}),x=nx,y=ny,yy*=-1;
        }
    }
    writeln(ans.size());
    _rep(i,0,(int)ans.size()-1) writesp(ans[i].first),writeln(ans[i].second);
    return 0;
}
```

---

## 作者：Carey_chen (赞：0)

### 题意

> 在一个网格图中，要从 $(0,0)$ 到达 $(n,n)$。只能沿某个方格的对角线移动，并且每个方格至多经过一次。求最多能经过多少方格，并给出一种可行的方案。

### 解法

根据部分分，可以想到需要按 $n$ 的奇偶分类。

#### $n$ 为奇数

$n$ 为奇数时每一格都可以走到，只要按图示的“蛇形”方法即可。

![图片](https://cdn.luogu.com.cn/upload/image_hosting/4nvenjk1.png)


#### $n$ 为偶数

一种想法是只走 $(n-1)^2 + 1$ 个格子，像这样：

![图片](https://cdn.luogu.com.cn/upload/image_hosting/cijx0eth.png)

但是这不是最优解，通过模拟数据或证明可以得出：最多只能走 $(n-1)n$ 个格子。

延续上面的思路，可以得出一种构造方式：

![图片](https://cdn.luogu.com.cn/upload/image_hosting/k28o3nqa.png)

把所有在副对角线（虚线）上的格子全部避开，其他按照“蛇形”走法即可。
观察图片可得：走到副对角线上时，需要按照先前的方向再走一步。

按这种方法实现即可，注意细节。

### $\mathfrak{Code}$

```cpp
#include <bits/stdc++.h>

using namespace std;

void calc(int i, int j, int &x, int &y, int &lst) // 计算下一个位置
{
	if (i % 2 == 1 && j % 2 == 1)
	{
		x++;
		y++;
		lst = 0;
	}
	if (i % 2 == 1 && j % 2 == 0)
	{
		x++;
		y--;
		lst = 1;
	}
	if (i % 2 == 0 && j % 2 == 1)
	{
		x--;
		y++;
		lst = 2;
	}
	if (i % 2 == 0 && j % 2 == 0)
	{
		x--;
		y--;
		lst = 3;
	}
}

int dx[4] = {1, 1, -1, -1};
int dy[4] = {1, -1, 1, -1};

int x = 0, y = 0, lst = 0, val = 0; //lst代表上一次的方向，val代表在该行是否已经经过了副对角线。

int main()
{
	int n;

	scanf("%d", &n);

	if (n % 2 == 1) // 奇数
	{
		printf("%d\n", n * n);
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				calc(i, j, x, y, lst);
				printf("%d %d\n", x, y);
			}
		}
	}
	else // 偶数
	{
		printf("%d\n", n * (n - 1));
		for (int i = 1; i <= n - 1; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				if (x + y == n) // 走到副对角线上时，需要按照先前的方向再走一步。
				{
					x += dx[lst];
					y += dy[lst];
					val ^= 1;
					printf("%d %d\n", x, y);
					continue;
				}

				calc(i, j + val, x, y, lst);

				printf("%d %d\n", x, y);
			}

			val = 0;
		}
	}


	return 0;
}
```

---

## 作者：_Weslie_ (赞：0)

一眼题。

## Solution P13348

### n 为奇数

答案是 $n^2$。

我们可以构造这样的路径，从第 $1$ 行到第 $n$ 行：

![](https://cdn.luogu.com.cn/upload/image_hosting/4bgkwmc1.png)

同理，可以构造这样的路径，从第 $n$ 行到第 $1$ 行：

![](https://cdn.luogu.com.cn/upload/image_hosting/f0obxc2c.png)


把它们拼在一起：

![](https://cdn.luogu.com.cn/upload/image_hosting/ykpd0djo.png)

达到了 $n^2$。

构造代码：

```
if(n&1){
	printf("%d\n",n*n);
	for(int i=1;i<=n;i++){
		if(i&1){
			for(int j=1;j<=n;j++){
				if(j&1)printf("%d %d\n",i,j);
				else printf("%d %d\n",i-1,j);
			}
		} 
		else{
			for(int j=n-1;j>=0;j--){
				if(j&1)printf("%d %d\n",i-1,j);
				else printf("%d %d\n",i,j);
			}
		} 
	}
}
```

### n 为偶数

答案是 $n^2-n$。

假设答案是 $n^2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/vilyvu8z.png)

你会发现这张图有 $4$ 个度数为奇数的点，所以不行。

![](https://cdn.luogu.com.cn/upload/image_hosting/hgnv5s79.png)

这是答案方案。

假设我们在答案方案上加入一条边。由于我们要加的边显然是红点上面的边，而红点的角上全部都是偶数度数的点，所以加一条边一定会再产生两个奇点。所以无法再加边。

你说，我们可以加了边再删掉。

你会发现，如果我们这么干：

![](https://cdn.luogu.com.cn/upload/image_hosting/3hm1j2ct.png)

这样不仅多一个红点，还产生了额外的两个奇数度数点。显然是得不偿失。

所以答案最多只有 $n^2-n$。

构造方式如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/zwdfi5tg.png)

```
if((n-1)&1){
	printf("%d\n",n*n-n);
	for(int i=2;i<=n;i++){
		if((i-1)&1){
			for(int j=1;j<=n;j++){
				if(j<=n-i){
					if(j&1)printf("%d %d\n",i-1,j);
					else printf("%d %d\n",i-2,j);					
				}
				else{
					if(j&1)printf("%d %d\n",i-1,j);
					else printf("%d %d\n",i,j);
				}
			}
		}
		else{
			for(int j=n-1;j>=0;j--){
				if(j<=n-i){
					if(j&1)printf("%d %d\n",i-2,j);
					else printf("%d %d\n",i-1,j);					
				}
				else{
					if(j&1)printf("%d %d\n",i,j);
					else printf("%d %d\n",i-1,j);
				}
			}
		} 
	}
}
```

---


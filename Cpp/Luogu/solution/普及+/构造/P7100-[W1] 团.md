# [W1] 团

## 题目描述

我有一张 $n$ 个节点的无向边带权图。它的边很多，用这个方法表示：

 - 有 $k$ 个集合；第 $i$ 个集合可以表示为 $S_i=\{(T_1,W_1),(T_2,W_2),\dots,(T_{|S_i|},W_{|S_i|})\}$。
 - 对于任何两对 $(T_i,W_i),(T_j,W_j)$ 在同一个集合里面，图中会形成一条连 $T_i$ 和 $T_j$ 的边，边权为 $W_i+W_j$。

请对于所有节点 $i$ 找到 $1$ 到 $i$ 的最短路，即从 $1$ 到 $i$ 的边权和最小的简单路径。

## 说明/提示

对于前 $10\%$ 的数据，$|S_i|=2$；  
对于前 $20\%$ 的数据，$|S_i|\le10$；  
对于前 $50\%$ 的数据，$|N|\le1000,\sum|S_i|\le2000$;  
对于 $100\%$ 的数据，$1\le|N|\le2\cdot10^5,\sum|S_i|\le4\cdot10^5,0\le W_i\le10^9$。

## 样例 #1

### 输入

```
5 2
3
1 1
2 1
5 3
3
2 1
3 2
4 1```

### 输出

```
0 2 5 4 4```

# 题解

## 作者：SDqwq (赞：16)

[博客食用更佳](https://www.luogu.com.cn/blog/Sham-Devour/solution-p7100)

[前置芝士：最短路](https://oi-wiki.org/graph/shortest-path/)

# Step 0 题意

- 一张 $n$ 个结点的无向带权图。

- 有 $k$ 个集合；第 $i$ 个集合可以表示为 $S_i=\{(T_1,W_1),(T_2,W_2),…,(T_{|S_i|},W_{|S_i|})\}$。

- 对于任何两对 $(T_i,W_i),(T_j,W_j)$ 在同一个集合里面，图中会形成一条连 $T_i$ 和 $T_j$ 的边，边权为 $W_i+W_j$。

# Step 1 暴力

按照题意暴力建图，直接跑堆优化 dijkstra 即可。

时间复杂度：$\mathcal{O}((n+\sum|{S_i}^2|)\log \sum|{S_i}^2|)$

# Step 2 正解

观察暴力解法后发现主要问题是边数太大。

- 考虑在每个集合 $S_i$ 中加入一个虚点 $x$。

- $x$ 向 $T_i$ 连接一条边权为 $W_i$ 的无向边 $(i\in[1,|S_i|])$。

执行完上述操作后可以发现仍然满足题目中 $<T_i,T_j>=W_i+W_j(i,j\in[1,|S_i|])$ 的要求。

此时边数为 $2\times\sum|S_i|$，可以承受。

时间复杂度：$\mathcal{O}((n+\sum|S_i|)\log\sum|S_i|)$

# Step 3 代码

```cpp
#include <cstdio>
#include <iostream>
#include <queue>

using namespace std;

typedef long long ll;
const ll inf = 0x3f3f3f3f3f3f3f3f;

int n, k, S, cnt, tot, T[400005], elast[600005];
ll W[400005], dis[600005];
bool vis[600005];

struct edge {
	int to, next;
	ll len;
} e[800005];

void add (int u, int v, ll w) {
	e[++cnt].to = v;
	e[cnt].len = w;
	e[cnt].next = elast[u];
	elast[u] = cnt;
}

struct node {
	ll dis;
	int id;
	node (ll _dis, int _id) {
		dis = _dis;
		id = _id;
	}
};

bool operator < (node x, node y) {
	return x.dis > y.dis;
}

priority_queue<node> pq;

void dijkstra (int x) {
	for (int i = 1; i <= tot; i++)
		dis[i] = inf;
	dis[x] = 0;
	pq.push(node(0, x));
	while (!pq.empty()) {
		node u = pq.top();
		pq.pop();
		if (vis[u.id])
			continue;
		vis[u.id] = true;
		for (int i = elast[u.id]; i != 0; i = e[i].next)
			if (dis[e[i].to] > dis[u.id] + e[i].len) {
				dis[e[i].to] = dis[u.id] + e[i].len;
				pq.push(node(dis[e[i].to], e[i].to));
			}
	}
}

int main () {
	scanf("%d %d", &n, &k);
	tot = n;
	for (int i = 1; i <= k; i++) {
		scanf("%d", &S);
		tot++;
		for (int j = 1; j <= S; j++) {
			scanf("%d %lld", &T[j], &W[j]);
			add(T[j], tot, W[j]);
			add(tot, T[j], W[j]);
		}
	}
	dijkstra(1);
	for (int i = 1; i <= n; i++)
		printf("%lld ", dis[i]);
	return 0;
}
```

---

## 作者：Mr_think (赞：8)

## [P7100 [w3R1] 团](https://www.luogu.com.cn/problem/P7100)

## 题目大意：
有一个$n$个节点的无向带权图，由$k$个集合组成，每个集合$S_i$中有一些点$\lbrace(T_1,W_1),(T_2,W_2),...,(T_{\left|S_i\right|},W_{\left|S_i\right|})\rbrace$，集合中的任意两点都有一条连接$T_i,T_j$的无向边，边权为$W_i+W_j$。我们要求  $1$ 到 $i$ 的最短路。
## solution:
tf老师说：“图论题，建完图后打个模板就行了。”，所以我们考虑如何**建图**。

暴力地去想，对于每个集合中的点$T_i$，我们可以从$T_i$向其他点$T_j$连一条边。
根据样例建图如下图：
![团暴力图](https://cdn.luogu.com.cn/upload/image_hosting/cprjm23m.png)

时间复杂度爆炸：$O(k|S_i^2|)$

所以我们考虑，在每个集合中新添一个虚拟节点$T_{n+i}$，其点权$W_{i+n}$为0，再向其他点$T_j$连边。
如下图：
![团正解图](https://cdn.luogu.com.cn/upload/image_hosting/w0mqjarx.png)

时间复杂度：$O(k|S_i|)$

### 正确性证明：

我们举个例子，原图中$3\rightarrow4$的路径被拆成了$3\rightarrow7\rightarrow4$，边权和仍为$3$。我们这个过程的实质就是将一条边拆成**两条边**。

接下来，我们打上最短路模板$dijkstra$堆优化或者$SPFA$均可通过此题。

## 接下来是细节的处理：

总路径长有可能超$int$，所以要开$long$ $long$。$dis$数组要初始化成$0x3f3f3f3f3f3f3f3f$

看到这的同学，可以自己去写代码了(~~tf口吻~~)

[Code(SPFA)](https://www.luogu.com.cn/paste/y02t1j2k)
(~~dijkstra懒得写了，有意者可私信提供~~)

### End
## 作者的碎碎念：

有用留赞(~~言简意赅~~)

---

## 作者：PigAunt (赞：3)

# P7100 [W1] 团

## 问题分析

本题主要的问题在边的数量上。如果按题意加边，不仅难以存储，而且会超时。因此，**减少边的数量是本题的关键**。

我们来看本题图的形式：

![按题意加边](https://cdn.luogu.com.cn/upload/image_hosting/2anv4spz.png)

可见，集合内每两个点之间都有边相连，边数为 $\frac {n(n + 1)} {2}$。

既然需要减少边的数量，而集合内点与点之间两两相连，我们可以自然想到网络通信中的**交换机**。在集合中引入一个“交换机”，只需要加一个点，与其他点一一相连即可。

引入“交换机”后的图如下：

![引入交换机](https://cdn.luogu.com.cn/upload/image_hosting/poygej4i.png)

边数为 $n$，大大地减少了边数。

因此，本题的解决方法为：在建图时用“交换机”减少边的数量，然后用最短路算法跑一遍就可以了。

## 细节问题

注意“交换机”点的编号不能与已有的重复。

## 代码实现

```cpp
#include <iostream>
#include <queue>

const int N = 2 * 2e5 + 5, M = 2 * 4e5 + 5;
const long long PosInf = 0x3f3f3f3f3f3f3f3f;
typedef std::pair<long long, int> PLI;

struct Edge
{
	int to, w;
	int next;
}edges[M];

int n, k;
long long dis[N];
int head[N], total;
bool vis[N];

void Add(int a, int b, int c)
{
	edges[total].to = b;
	edges[total].w = c;
	edges[total].next = head[a];
	head[a] = total++;
}

void Dijkstra(int start)
{
	std::priority_queue<PLI, std::vector<PLI>, std::greater<PLI> > heap;
	for (int i = 0; i < N; i++)
	{
		vis[i] = false;
		dis[i] = PosInf;
	}
	dis[start] = 0;
	heap.push({0, start});
	
	while (!heap.empty())
	{
		PLI t = heap.top();
		heap.pop();
		
		if (vis[t.second])
			continue;
		vis[t.second] = true;
		
		for (int i = head[t.second]; i != -1; i = edges[i].next)
		{
			int v = edges[i].to, w = edges[i].w;
			if (dis[v] > dis[t.second] + w)
			{
				dis[v] = dis[t.second] + w;
				heap.push({dis[v], v});
			}
		}
	}
}

int main()
{
	for (int i = 0; i < N; i++)
		head[i] = -1;
	
	std::cin >> n >> k;
	for (int i = 1; i <= k; i++)
	{
		int g = 0;
		std::cin >> g;
		for (int j = 1; j <= g; j++)
		{
			int a, b;
			std::cin >> a >> b;
			Add(a, n + i, b);
			Add(n + i, a, b);
		}
	}
	
	Dijkstra(1);
	
	for (int i = 1; i <= n; i++)
		std::cout << dis[i] << " ";
	std::cout << std::endl;
	return 0;
}
```

---

## 作者：answerend42 (赞：3)

[更好的阅读体验](https://answerend42.github.io/2020/11/22/lg7100/)

[原题链接](https://www.luogu.com.cn/problem/P7100)

[官方题解](https://www.luogu.com.cn/blog/220037/w33z-round-1-ti-xie)

**题目描述**

我有一张 $n$ 个节点的无向边带权图。它的边很多，用这个方法表示：

 - 有 $k$ 个集合；第 $i$ 个集合可以表示为 $S_i=\{(T_1,W_1),(T_2,W_2),\dots,(T_{|S_i|},W_{|S_i|})\}$。
 - 对于任何两对 $(T_i,W_i),(T_j,W_j)$ 在同一个集合里面，图中会形成一条连 $T_i$ 和 $T_j$ 的边，边权为 $W_i+W_j$。

请对于所有节点 $i$ 找到 $1$ 到 $i$ 的最短路，即从 $1$ 到 $i$ 的边权和最小的简单路径。

**输入格式**

第一行两个正整数 $n,k$。 
接下来描述 $k$ 个集合。 
第 $i$ 集合的描述的第一行一个正整数 $|S_i|$，表示 $|S_i|$ 的大小。
接下来 $S_i$ 行，每行两个正整数 $t,w$，表示 $(t,w)\in S_i$。

对于前 $10\%$ 的数据，$|S_i|=2$； 
对于前 $20\%$ 的数据，$|S_i|\le10$；
对于前 $50\%$ 的数据，$|N|\le1000,\sum|S_i|\le2000$；
对于 $100\%$ 的数据，$1\le|N|\le2\cdot10^5,\sum|S_i|\le4\cdot10^5,0\le W_i\le10^9$。

**输出格式**

一行 $n$ 个正整数；第 $i$ 个正整数表示 $1$ 到 $i$ 的最短路长度。如果不存在一条路径，输出 $\textsf{0x3f3f3f3f3f3f3f3f}=4557430888798830399$。

**题解**

1. 暴力建图，跑 Dijkstra，可以通过前 $50\%$ 的数据

2. 对于 $100\%$ 的数据，仍然使用暴力建图并采用优先队列优化的 Dijkstra 就是 $\mathcal{O}(\sum |S^2_i| \log \sum |S^2_i|)$ 的复杂度，不能接受，考虑如何优化建图。

   每个集合中所有点总要两两连边，这样边数是 $|S^2| - |S|$($\dfrac{|S| \times (|S|-1)}{2} \times 2$)的，将其转换一下，对于每一个集合设立一个中间点，所有的点 $T_i$ 向其连一条边权为 $W_i$ 的边，和原图实际上是等价的，边数变成了 $2|S|$。

   以样例为例：

   ![优化前的原图](https://i.loli.net/2020/11/22/UpRceOrI4JZdz8H.png)

	优化前的原图
    
   ![优化建图后(6,7为中间点)](https://i.loli.net/2020/11/22/cztZGfCdMI87rLn.png)
   
   	优化建图后(6,7为中间点)

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4e5 + 5, M = N << 2;
const ll INF = 0x3f3f3f3f3f3f3f3f;
int tot, head[N], to[M], nxt[M];
bool vis[N];
ll cst[M], dis[N], b[N];
int n, k, siz, x;
ll y;
int Mid;
struct Node {
    ll x, dis;
    bool operator<(const Node &rhs) const { return rhs.dis < dis; }
};
void add(int x, int y, ll z) { to[++tot] = y, cst[tot] = z, nxt[tot] = head[x], head[x] = tot; }
void dij(int u) {
    priority_queue<Node> q;
    for (int i = 1; i <= Mid; i++) dis[i] = INF;
    dis[u] = 0;
    q.push(Node{ u, 0 });
    while (!q.empty()) {
        int t = q.top().x;
        q.pop();
        if (vis[t]) continue;
        vis[t] = 1;
        for (int i = head[t]; i; i = nxt[i]) {
            int v = to[i];
            if (dis[v] > dis[t] + cst[i]) {
                dis[v] = dis[t] + cst[i];
                if (!vis[v]) q.push(Node{ v, dis[v] });
            }
        }
    }
}
int main() {
    cin >> n >> k;
    Mid = n;
    for (int i = 1; i <= k; i++) {
        cin >> siz;
        Mid++;
        for (int j = 1; j <= siz; j++) {
            cin >> x >> b[j];
            add(x, Mid, b[j]);
            add(Mid, x, b[j]);
        }
    }
    dij(1);
    for (int i = 1; i <= n; i++) cout << dis[i] << " ";
    return 0;
}
```

**注意**

1. 本题**需要** long long
2. 图**不一定**联通
3. 每一个集合的中间点都是**不同**的（代码中用 $n+1 \sim n+k$ 表示）



---

## 作者：Chinshyo (赞：1)

**单源最短路的问题**
#  $ First $ : 建图
建图的过程题目告诉我们，对于每一个$ i,j $，如果$(T_i,W_i),(T_j,W_i)∈S$，那么$ T_i,T_j $之间就会有权值为$ W_i+W_j $的无向边。那么根据题意我们可以知道，**只要在集合$ S $内的任意两点都两两相连**。所以通过样例我们可以构造出来的如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/t5c4t7vy.png)

有了这些，就可以直接通过双重循环来将图中任意两点相连。配合输入的局部代码：
```cpp
int n, k;
cin >> n >> k;
int t, a, b;
for(int i = 1; i <= k; i++) {
	cin >> t;
	vector < pair<int, int> > Set;
	for(int j = 1; j <= t; j++){
		cin >> a >> b;
		Set.push_back(make_pair(a, b));
	}
	for(int j = 0; j < t; j++){
		for(int k = j + 1; k < t; k++){
			graph[Set[j].first].push_back((node){Set[k].first, Set[k].second + Set[j].second});
			graph[Set[k].first].push_back((node){Set[j].first, Set[k].second + Set[j].second});
		}
	}
}	
```
# $ Second $ :最短路求解
我们所知的最流行的两种最短路求解算法就是$ Dijkstra $了。
### 算法简介

在最开始时，只有起点的最短距离是确定的。在尚未使用过的顶点中，距离的$d[i]$最小顶点就是最短路径已经确定的顶点。因为本题不存在负边，所以不会再之后的更新中变小。**他的局限就是无法考虑负权**。

![](https://cdn.luogu.com.cn/upload/image_hosting/uy0rhkxt.png)

如图，箭头所指节点的最短路径已知是$ 0 $，所以我们就可以通过他来更新他所指向的所有边。

### 局部代码
```cpp
while(!pr.empty()){
		int now = pr.top().second;//记录节点当时的编号
		pr.pop();
		if(visited[now] == true){//判重
			continue;
		}
		visited[now] = true;
		
		for(int i = 0; i < graph[now].size(); i++){
			int next = graph[now][i].to;//下一个节点
			if(dis[now] + graph[now][i].cost < dis[next]){//如果找到更优解
				dis[next] = dis[now] + graph[now][i].cost;//更新最短路
				pr.push(make_pair(dis[next], next));//压入小根堆
			}
		}
	}
```
# $ Third $:收尾
本题最终是要求输出到每个节点的最短距离。所以我们可以直接将整个$dis$数组输出。
```cpp
for(int i = 1; i <= n; i++){
		cout << dis[i] << ' ';
}
```
# $ Forth $:终了 · 贴代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MaxN = 200005;
struct node{
	int to, cost;
};
vector <node> graph[MaxN];
bool visited[MaxN];
int dis[MaxN];

int main(){
	int n, k;
	cin >> n >> k;
	int t, a, b;
	for(int i = 1; i <= k; i++) {
		cin >> t;
		vector < pair<int, int> > Set;
		for(int j = 1; j <= t; j++){//无脑输入 
			cin >> a >> b;
			Set.push_back(make_pair(a, b));
		}
		for(int j = 0; j < t; j++){
			for(int k = j + 1; k < t; k++){
				graph[Set[j].first].push_back((node){Set[k].first, Set[k].second + Set[j].second});
				graph[Set[k].first].push_back((node){Set[j].first, Set[k].second + Set[j].second});
			}
		}
	}
	
	priority_queue< pair<int, int> , vector< pair<int, int> > , greater< pair<int, int> > > pr; //first->cost second->node
	pr.push(make_pair(0, 1));
	for(int i = 1; i <= n; i++){
		dis[i] = INT_MAX;
	}
	dis[1] = 0;
	memset(visited, false, sizeof(visited));
	
	while(!pr.empty()){
		int now = pr.top().second;//记录节点当时的编号
		pr.pop();
		if(visited[now] == true){//判重
			continue;
		}
		visited[now] = true;
		
		for(int i = 0; i < graph[now].size(); i++){
			int next = graph[now][i].to;//下一个节点
			if(dis[now] + graph[now][i].cost < dis[next]){//如果找到更优解
				dis[next] = dis[now] + graph[now][i].cost;//更新最短路
				pr.push(make_pair(dis[next], next));//压入小根堆
			}
		}
	}
	
	for(int i = 1; i <= n; i++){//输出 
		cout << dis[i] << ' ';
	}
	return 0;
}
```



---

## 作者：pomelo_nene (赞：1)

显然我们无法将所有的边建出来。考虑到只有一个集合内的数会建出边，所以对每一个集合建一个虚点，集合里面的所有点都与这个虚点连边，边权即 $W_i$。显然，这样做 $(T_i,T_j)$ 的距离确实是 $W_i+W_j$。

这样就把边缩到了 $\sum |S_i| \leq 4\times 10^5$ 级别，点也变成了 $n+k$ 级别（最差应该是 $6 \times 10^5$）。直接 Dijkstra  求最短路即可。时间复杂度 $O(\sum |S_i| \log n)$。

---

## 作者：Marginal_world (赞：0)

问题分析：理解题意，根据题目描述，我们发现如果直接暴力存图，存储难度大，容易超时。但如果我们能够解决边的问题，之后就是一个裸的单源最短路。

问题聚焦：**减少边的数量**。

解决方法：交换机思想。

在集合中引入一个“交换机”，只需要加一个点，与其他点一一相连即可。经过理论分析，引入交换机后并不会对问题结果产生影响。

至此，本题的全部难点已讨论完毕。

代码实现：

```cpp
#include<bits/stdc++.h>
#define ll long long
typedef std::pair<long long, int> PLI;
const int N=2*2e5+5,M=2*4e5+5;
const ll maxn=0x3f3f3f3f3f3f3f3f;
using namespace std;
int vis[N],head[N];
ll dis[N];
int cnt,n,k;
struct node{
	int to,next;
	ll val;
}e[M];
void add_cnt(int u,int v,ll w){//链式前向星存图
	e[++cnt].to=v;
	e[cnt].next=head[u];
	e[cnt].val=w;
	head[u]=cnt;
}
void Dijkstra(int st){//单源最短路堆优化模板
	std::priority_queue<PLI, std::vector<PLI>, std::greater<PLI> > q;//定义优先队列
	for(int i=0;i<N;i++){
		vis[i]=0;
		dis[i]=maxn;
	}
	dis[st]=0;
	q.push({0,st});
	while(!q.empty()){
		PLI u=q.top();
		q.pop();
		if(vis[u.second])continue;
		vis[u.second]=1;
		for(int i=head[u.second];i!=-1;i=e[i].next){
			int v=e[i].to;
			ll w=e[i].val;
			if(dis[v]>dis[u.second]+w){
				dis[v]=dis[u.second]+w;
				q.push({dis[v],v});
			}
		}
	}
}
int main(){
	for(int i=0;i<N;i++)
	head[i]=-1;
	cin>>n>>k;
	for(int i=1;i<=k;i++){
		int s;
		cin>>s;
		for(int j=1;j<=s;j++){
			int a,b;
			cin>>a>>b;
			add_cnt(a,n+i,b);//交换机思想，一个额外的点
			add_cnt(n+i,a,b);
		}
	}
	Dijkstra(1);
	for(int i=1;i<=n;i++)
	cout<<dis[i]<<" ";
	return 0;
}
```


---

## 作者：Kalium (赞：0)

# P7100 [W1] 团 题解

## 前言：

本篇题解有freopen，文件名是歌名，有兴趣的听听。

## 题意：

有k个集合，每个集合里的点都能相连，边权为两个点的点权之和。问1-i的最短路。

## 思路：

一看感觉很简单，暴力建图然后dij。

再看看出题人是w33z，立马想到这个毒瘤人士不可能出这么简单的题目。

看了看数据范围，好家伙，你就是不让我暴力建图。

~~于是我翻了翻题解，~~ 发现我们可以添加一个点n+i，然后将每个点都与这个点连接，边权即为点权。

下面我放张图理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/sysfe5ry.png)

这玩意是不是可以等价于这个：

![](https://cdn.luogu.com.cn/upload/image_hosting/dzw5kuci.png)

那由于有k个集合，我们就要建立n + k个点。

剩下的就是正常的最短路的堆优化了。

## 细节：

如果RE的话，建议看看[这个帖子](https://www.luogu.com.cn/discuss/show/314181)（我的sb问题）。

注意longlong，详情见 $w_i$ 的范围。

## 代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

#define inf 0x3f3f3f3f
#define ll long long

const int N = 2e5 + 7; 
const int M = 4e5 + 7;

using namespace std;

int n, k;

ll dis[M];

struct Edge{
	int next, to;
	ll w;
} edge[M << 2];

int head[M], cnt;

struct Heap {
	ll x;
	int idx;
} heap[M << 2 | 1];

int sz;

bool flag[M << 1];

inline void ins(int u, int v, ll w) {
	edge[++ cnt].to = v;
	edge[cnt].w = w;
	edge[cnt].next = head[u];
	head[u] = cnt;
}

inline void push(ll x, int idx) {
	int now = ++ sz;
	heap[now].x = x, heap[now].idx = idx;
	
	while (now != 1) {
		int fa = now >> 1;
		
		if (heap[fa].x > heap[now].x)
			swap(heap[fa], heap[now]);
		else break;
		
		now = fa;
	}
}

inline void pop() {
	int now = 1;
	
	swap(heap[1], heap[sz]);
	sz --;
	
	while (now << 1 <= sz) {
		int son = now << 1;
		
		if (son + 1 <= sz && heap[son].x > heap[son + 1].x) son ++;
		
		if (heap[now].x > heap[son].x)
			swap(heap[now], heap[son]);
		else break;
		
		now = son;
	}
}

inline void dijkstra() {
	memset(dis, inf, sizeof(dis));
	dis[1] = 0;
	
	push(dis[1], 1);
	
	while (sz) {
		int k = heap[1].idx;
		
		pop();
		
		if (flag[k]) continue;
		
		flag[k] = 1;
		
		for (int i = head[k]; ~i; i = edge[i].next) {
			int v = edge[i].to;
			
			if (dis[v] > dis[k] + edge[i].w) {
				dis[v] = dis[k] + edge[i].w;
				push(dis[v], v);
			}
		}
	}
}

int main() {
	freopen("Closer.in", "r", stdin);
	freopen("Closer.out", "w", stdout);
	
	memset(head, -1, sizeof(head));
	
	scanf("%d %d", &n, &k);
	
	for (int i = 1, m; i <= k; i ++) {
		scanf("%d", &m);
		
		for (int j = 1, u; j <= m; j ++) {
			ll w;
			
			scanf("%d %lld", &u, &w);
			
			ins(u, n + i, w);
			ins(n + i, u, w);
		}
	}
	
	dijkstra();
	
	for (int i = 1; i <= n; i ++) {
		if (dis[i] == inf)
			printf("45574308887988303990x3f3f3f3f3f3f3f3f=4557430888798830399 ");
		else
			printf("%lld ", dis[i]);
	}
	
	printf("\n");
	
	fclose(stdin);
	fclose(stdout); 
	
	return 0;
}
```

$Atlantic.$


---

## 作者：SfumatoCannon_ (赞：0)

### Solution

#### 50pts

暴力建图，跑一遍```dijkstra```即可。

但由于**边数过多**，显然不能通过 $100\%$ 的数据。

#### 100pts

发现题目中的一个重要性质：

* 对于任何两对 $(T_i,W_i),(T_j,W_j)$ 在同一个集合里面，图中会形成一条连 $T_i$ 和 $T_j$ 的边，边权为 $W_i+W_j$ .

如果我们将 $W_i$ 和 $W_j$ 这两个边权的组成部分单独来看的话，很容易构建出这样一种模型：

![](https://cdn.luogu.com.cn/upload/image_hosting/d0ccdp0z.png)

其中 $T_i=1,T_j=2$.

那么我们发现：$T_i$ 到 $T_j$ 的距离依然是 $W_i+W_j$.

于是我们就有了一种新的建图方式：

* 我们新建一个点 $p$ , 对于任意的 $(T_i,W_i)\in S$ ，我们都只向 $p$ 连一条权值为 $W_i$ 的边。

通过这种方式，我们巧妙的将边数大大地减小了，并且对答案没有任何影响。

***

### code

```cpp
#include <cstdio>
#include <queue>
using namespace std;
#define inf 0x3f3f3f3f3f3f3f3f
#define maxn 500001
#define maxm 800001
typedef long long ll;
struct node
{
    ll id, num;
    bool operator<(const node &x) const
    {
        return x.num < num;
    }
};
struct Edge
{
    ll next, to, dis;
} bian[maxm];
ll ans[maxn * 2];
ll n, k, h[maxn * 2];
bool vis[maxn * 2];
ll t;
void add(ll x, ll y, ll z)
{
    t++;
    bian[t].next = h[x];
    bian[t].to = y;
    bian[t].dis = z;
    h[x] = t;
}
void dijkstra(ll start)
{
    priority_queue<node> Q;
    ll i, p;
    for (i = 1; i <= n + k; i++)	//注意这里初始化的范围，还包括新增的k个点
    {
        ans[i] = inf;
        vis[i] = false;
    }
    ans[start] = 0;
    Q.push((node){start, 0});
    while (!Q.empty())
    {
        p = Q.top().id;
        Q.pop();
        if (vis[p])
            continue;
        vis[p] = true;
        for (i = h[p]; i; i = bian[i].next)
        {
            if (ans[p] + bian[i].dis < ans[bian[i].to])
            {
                ans[bian[i].to] = ans[p] + bian[i].dis;
                if (!vis[bian[i].to])
                    Q.push((node){bian[i].to, ans[bian[i].to]});
            }
        }
    }
}
int main()
{
    ll i, j, s, t, w;
    scanf("%lld%lld", &n, &k);
    for (i = 1; i <= k; i++)
    {
        scanf("%lld", &s);
        for (j = 1; j <= s; j++)
        {
            scanf("%lld%lld", &t, &w);
            add(t, n + i, w);	//将n+i号点作为新增的点，不会发生重复现象
            add(n + i, t, w);
        }
    }
    dijkstra(1);
    for (i = 1; i <= n; i++)	//最后只需输出前n个点的答案即可
        printf("%lld ", ans[i]);
    return 0;
}

// 另，这是我第300个AC的题，所以发篇题解留个念qwq
```


---


# [THUPC 2022 初赛] 造计算机

## 题目描述

小R和小C听说贵系有一门造计算机的课之后吓得连夜提交了退学申请。

开玩笑的啦！正处于大一的他们对这门课不但不害怕，甚至有些想笑。他们超强的动手能力甚至驱使他们想造一个玩意玩玩。

当然由于他们毕竟才大一，计算机专业课基本上都没上过，经过长时间的艰苦奋战，他们终于造出了一个奇怪的玩意：

这台计算机只有 $n$ 个内存单元，反而有足够多个寄存器。内存单元的编号从 $1$ 到 $n$ ，寄存器从 $n+1$ 开始往上编号。每个内存单元和寄存器可以存储一个整数。

目前他们已经设计好了一类指令：`swap i, j`，表示交换编号为 $i$ 和 $j$ 的单元里的数，其中 $i$ 和 $j$ 均为正整数且 $i \neq j$ 。他们打算写一段程序来测试这条指令。

最开始， $n$ 个内存单元中乱序存放着 $1\thicksim n$ 这些数，且每个数恰好出现一次。而每个寄存器里存放的是它的编号。

两人打算设计一段指令序列，使得计算机依次执行完这些指令后，所有内存和寄存器中的数都归位，也就是恰好等于它自己的编号。

虽然没学过计算机专业课，小R和小C还是懂一点皮毛的，因此他们规定每条 `swap` 指令操作的两个位置至少有一个需要是寄存器，也就是 $i$ 和 $j$ 至少有一者应当大于 $n$。

然而，正当他们写完程序开始运行时，却发现系统崩溃了！在查找了半天原因后，他们发现了一个奇怪的 bug：他们设计出来的计算机不能运行两条相同的指令！也就是说，他们不能在一段程序里出现两条相同的 `swap i, j` 指令。更进一步他们发现即使出现一条 `swap i, j` 一条 `swap j, i` 也不行，因为计算机会自动将这两条指令视为同一条。

然后可怜的小R和小C就斯巴达了。不过他们在弃疗之前还是打算利用现有的架构把程序写出来。不仅如此，他们还希望用到的寄存器数量尽可能少。你能帮帮他们吗？

## 说明/提示

【样例解释】

最初，前 $4$ 个单元的值依次为 $(2,1,3,4)$ 。

执行指令 `swap 3, 4`，各单元的值变为 $(2,1,4,3)$ 。

执行指令 `swap 1, 3`，各单元的值变为 $(4,1,2,3)$ 。

执行指令 `swap 2, 4`，各单元的值变为 $(4,3,2,1)$ 。

执行指令 `swap 1, 4`，各单元的值变为 $(1,3,2,4)$ 。

执行指令 `swap 2, 3`，各单元的值变为 $(1,2,3,4)$ 。

可以证明 $m=1$ 是不行的。


## 样例 #1

### 输入

```
2
2 1```

### 输出

```
2 5
3 4
1 3
2 4
1 4
2 3```

# 题解

## 作者：破壁人五号 (赞：13)

这题本人曾经在去年 6 月**搬**到过联考，而且是在最小化 $m$ 的前提下最小化 $k$ 的加强版。![/qd](https://cdn.jsdelivr.net/gh/4bqwq/LuoguEmojiSender@main/image/qd.gif)

首先特判所有数已经归位的情况，这时 $m=0$。其余情况下都有 $m=2$（$m=1$ 的话你把 $n+1$ 交换到前 $n$ 个位置之后就回不去了）。

以下的「Solution 1」为本题做法（你可以在 [Matrix 67 的博客](http://www.matrix67.com/blog/archives/3570) 里面找到本题），「Solution 2」为最小化 $k$ 的做法。代码是最小化了 $k$ 的。

---

该问题最早出现于 Futurama 第 6 季第 10 集 The Prisoner of Benda。（虽然出题人并没有看过）

下面将交换 $a_i,a_j$ 的操作记为 $(ij)$。记 $x=n+1,y=n+2$。

## Solution 1

原动画中给出了如下的构造解：

将排列 $a$ 分解为多个非空的环之积，考虑分别处理每个环。不失一般性地，我们考虑 $a=[2,\cdots n,1]$，对此进行操作：$(1x)\to(2y)\to(3y)\to(4y)\cdots\to(ny)\to(2x)\to(1y)$。在处理完每个环之后，$x,y$ 的位置可能互换，此时我们需要再做 $(xy)$。

设 $a$ 为 $r$ 个非空的环之积，环长之和为 $m$，则其需要 $m+2r+(r \bmod 2)$ 次操作。这在环数大于 $2$ 时不是最优解。期望得分 $64$ 分。

## Solution 2

[这篇论文](http://arxiv.org/pdf/1204.6086) 给出了最优构造（如果你想要阅读原论文的话，注意此处的操作是自左向右执行的，而论文中是从右向左执行的）：

考虑将原排列分解为多个非空的环 $C_i$ 之积，每个环形如：
$$
\begin{pmatrix}
    a_1,a_2,a_3,\cdots a_k\\
    a_k,a_1,a_2,\cdots a_{k-1}
\end{pmatrix}
$$

以 $C_1$ 为例，我们定义：

- $$G_1(x)=(a_1x)\to (a_2x)\to  \cdots\to  (a_kx)$$
- $$F_1(x)=(a_1x)$$

进行操作：
$$\begin{aligned}
&F_r(y)\to F_{r-1}(y)\to \cdots\to  F_{2}(y)\\ 
\to & \left[(a_1x)\to G_1(y)\to(a_k x)\right] \\
\to &G_2(x)\to G_3(x)\to \cdots \to G_r(x)
\end{aligned}$$

设 $a$ 为 $r$ 个非空的环之积，环长之和为 $m$，则其需要 $m+r+2$ 次操作。

其正确性容易验证。我们下面证明这个解是最优的。

### 证明

首先我们只保留环中的元素，那些不用换位置的元素我们忽略。

假设 $m+r+2$ 的解不是最优，那么操作数 $t<m+r+2$。通过考虑置换的奇偶性（即逆序对个数的奇偶性）我们可以发现 $t\neq m+r+1$，于是我们有 $t\leq m+r$。

另一方面，对于每个元素，它的初始位置与最终位置不同，一定至少被交换过一次。因此 $t\geq m$。

进一步地，考虑第一个环 $C_1=\begin{pmatrix}    a_1,a_2,a_3,\cdots a_k\\    a_k,a_1,a_2,\cdots a_{k-1}\end{pmatrix}$，我们考虑环中**最后一次**被操作到的元素，它一定是与 $x$ 或 $y$ 交换，且把位于这个元素处的、不属于 $C_1$ 的东西扔出去；在这个交换之前，它一定与 $x,y$ 中的一个交换过一次。其余环类似。于是对于每个环，它至少会带来一次额外的操作，于是我们有 $t\geq m+r$。

综上，$t=m+r$，且不可能出现操作 $(xy)$。

类似地，对于每个环，我们考虑环中**第一次**被操作到的元素，它同样会被交换了两次。于是对于每个环，它首次操作到的元素和最后一次被操作到的元素是同一个。

总结一下，对于环 $C_1$，它有以下性质：

- 有且仅有唯一一个元素 $a\in C_1$，满足有两次关于 $a$ 的操作；
- 对于其他所有 $C_1$ 中的元素，其操作时间在 $a$ 的这两次操作之间。

其余环也有类似性质。

现在对于每个环 $C_i$，定义 $N_i$ 为对其首次操作与最后一次操作之间（不含）的操作数。

不失一般性地，我们：

- 通过给环编号，可以使得 $N_1\leq N_i,\forall 1<i \leq r$；
- 通过交换 $x,y$，可以使得 $(ay)$ 在 $(ax)$ 之前；
- 通过改变第一个环的起点，可以使得 $a$ 为 $C_1$ 的最后一个元素（$a=a_k$）。

现在考虑 $(a_ky)$ 与 $(a_kx)$ 之间（含）的所有包含 $y$ 的操作，记作 $M$。下面我们用反证法证明 $M$ 一定包含 $C_1$ 以外的元素。

> 假设 $M$ 中只包含 $C_1$ 中的元素。由于我们需要对于 $i=1,2,\cdots k-1$ 把 $a_{i+1}$ 移到 $a_i$，以下操作必须按照如下顺序执行：
> $$(a_ky),(a_{k-1}y),\cdots (a_1y)$$
> 此时 $a_1$ 到达不了 $a_k$，矛盾。

现在假设 $(hy)\in M,h\notin C_1,h\in C_j$，而 $(a_my)$ 为 $M$ 中紧接在 $(hy)$ 之前的操作。显然我们的操作不能把 $a_m$ 最终送到 $h$，$h$ 应当在 $(a_kx),(a_ky)$ 之间出现两次，于是 $N_j<N_1$，矛盾。证毕。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
int getint(){ int x;scanf("%d",&x);return x; }
int a[N];
bool vis[N];
vector<int>r[N];int cnt=0;
vector<pair<int,int> >ans;
void swp(int x,int y){
    ans.emplace_back(min(x,y),max(x,y));
    swap(a[x],a[y]);
}

int main(){
    int n=getint();
    for(int i=1;i<=n;i++)a[i]=getint();
    a[n+1]=n+1;a[n+2]=n+2;
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            int u=i;
            while(!vis[u]){
                vis[u]=1;
                r[cnt].push_back(u);
                u=a[u];
            }
            // reverse(r[cnt].begin(),r[cnt].end());
            ++cnt;
        }
    }
    vector<int>cy;
    for(int i=0;i<cnt;i++)if(r[i].size()>1)cy.push_back(i);
    if(cy.empty())return puts("0 0"),0;

    for(int i=cy.size()-1;i;--i)swp(r[cy[i]].back(),n+2);
    swp(r[cy[0]].back(),n+1);
    for(int i:r[cy[0]])swp(i,n+2);
    swp(r[cy[0]].front(),n+1);
    for(int i=1;i<cy.size();i++)for(int j:r[cy[i]])swp(j,n+1);
    swp(n+1,n+2);
    
    printf("%d %d\n",2,(int)ans.size());
    for(auto i:ans)
        printf("%d %d\n",i.first,i.second);
    // for(int i=1;i<=n+2;i++)cerr<<"> "<<a[i];cerr<<endl;
    return 0;
}
```


---

## 作者：_Diu_ (赞：7)

~~赛事压哨过特来水一发题解纪念一下。~~

一道构造。

> 题目大意：给定一个长度为 $n$ 的数组，你可以使用若干个寄存器，里面有互不相同的值，要求构造出一种方案，每次交换两个位置的数（两个位置中至少有一个是寄存器），使最终数组有序，但是要求最后寄存器的值不变。同一对位置只能执行一次操作，要求构造出的方案使用的寄存器数量最少。

我们发现 $k$ 的限制是 $1e6$，而 $n$ 最大是 $1e5$，所以寄存器数量上线肯定不高，否则 $k$ 会变得特别大。

因此，我们可以合理猜测最终答案的 $m$ 是一个常数。

我们发现交换两个位置 $u,v$ 的值需要用到两个寄存器：（假设 $x,y$ 是两个不同的寄存器）

`swap` $(u,x)$

`swap` $(v,y)$

`swap` $(u,y)$

`swap` $(v,x)$

所以只要不是数组原来就有序（那样答案为 $0,0$），那么答案下界就是 $2$，我们能否构造一种方案使得 $m=2$？

答案是肯定的。

我们发现如果把每一个位置上的数最终要去到的位置连一条边，最终会连成若干个环。我们只需要按着环把元素一个一个换下去就好了。

我们发现每一个环之间互相独立，我们只需要保证不对两个寄存器进行操作，就能一直进行下去。

对于一个大小为 $s$ 的环 $d_1,d_2,\dots,d_s$，我们进行这样的操作：

`swap` $(d_1,x)$

`swap` $(d_2,x)$

$\dots$

我们发现这样之后原本在 $d_1$ 的元素就成功归位了，所以我们继续下去。

但如果最后，$x$ 里存的是 $d_1$ 的值，$d_1$ 里面存的是 $x$ 的值，但我们无法再次直接交换两者，所以我们退回一步：

$\dots$

`swap` $(d_{s-1},x)$

`swap` $(d_s,y)$

`swap` $(d_1,y)$

`swap` $(d_s,x)$

这样子就能在保证上述条件的情况下完成一个环的归位。

但是这样会使 $x$ 和 $y$ 里的值交换一下。

所以我们最后判断一下 $x$ 和 $y$ 里的值是否交换过，如果交换过花一次换回来就行了。

因为此题对时间复杂度要求不高，直接报搜 $O(n)$ 就行了。

## code

赛时代码实现比较粗糙吗，看看就好了：

代码里的输出 $m,k$ 被我吃了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,m,k,a[N],st[N],tp,vis[N];
struct upt{
	int x,y;
}ans[N];
void dfs(int x){
	st[++tp]=x,vis[x]=1;
	if(!vis[a[x]])dfs(a[x]);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	a[n+1]=n+1,a[n+2]=n+2;
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			if(i==a[i])continue;//只有一个就没必要了
			tp=0;
			dfs(i);
			m=2;
			ans[++k]={st[1],n+1};swap(a[st[1]],a[n+1]);
			for(int j=2;j<tp;j++)ans[++k]={st[j],n+1},swap(a[st[j]],a[n+1]);
			ans[++k]={st[tp],n+2},swap(a[st[tp]],a[n+2]);
			ans[++k]={st[tp],n+1},swap(a[st[tp]],a[n+1]);
			ans[++k]={st[1],n+2},swap(a[st[1]],a[n+2]);
		}
	}
	if(a[n+1]!=n+1)ans[++k]={n+1,n+2};
	for(int i=1;i<=k;i++)printf("%d %d\n",ans[i].x,ans[i].y);
}
```

---

## 作者：RedreamMer (赞：1)

## 思路

发现如果这个排列需要需要排序，那么必须至少需要 $2$ 个寄存器，而恰好 2 个寄存器就可以构造出方案。

将每个点所在置换环（即对 $i \to a_i$ 建边得到的图的每一个环）拎出来一个个处理，我们的目标是将 $i$ 上的值换到换到 $a_i$ 的位置，有这样一个构造方法：

先特判环大小为 $1$，在环上任取一点为起点，以这个点为头断环为链，令原环大小为 $n$，用第一个寄存器 $x$ 不断进行 $(x, 1), (x, 2), (x, 3), \dots, (x, n - 1)$，的 swap 操作，再用第二个寄存器 $y$ 进行一次 $(y, n)$，然后再是 $(x, n), (y, 1)$，由此操作发现不但将整个环上的点排好了序，并且 $x, y$ 点上的值也没有丢，那么这样将所有环排好序后，最后特判进行一次 $(x, y)$ 就行了。

## 代码

```cpp
const int N = 1e6;
int a, s[N + 5], p[N + 5], top, now;
bool vis[N + 5];
struct pii {int x, y;};
vector<pii> ans;

void ins(int n, int m) {
	ans.PB((pii) {n, m});
	assert(siz(ans) <= 1e6);
	swap(p[n], p[m]);
}

signed main() {
	// freopen("in2.in", "r", stdin);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> a;
	rep(i, 1, a) cin >> s[i], p[i] = s[i];
	p[a + 1] = a + 1, p[a + 2] = a + 2;
	bool o = 1;
	rep(i, 1, a) if(s[i] != i) o = 0;
	if(o) return cout << "0 0", 0;
	rep(i, 1, a) {
		if(vis[i] || s[i] == i) continue;
		int x = i;
		for(; !vis[x]; x = s[x]) {
			vis[x] = 1;
			if(s[x] == i) ins(a + 2, x);
			ins(a + 1, x);
		}
		ins(a + 2, i);
	}
	if(p[a + 1] != a + 1) ins(a + 1, a + 2);
	rep(i, 1, a + 2) assert(p[i] == i);
	cout << 2 << ' ' << siz(ans) << '\n';
	rep(i, 0, siz(ans) - 1) cout << ans[i].x << ' ' << ans[i].y << '\n';
	return 0;
}
```

---

## 作者：PrincessQi (赞：1)

考虑猜结论。

若原来就排好了序，答案一定是 $0$，否则答案是 $2$。

考虑使用构造一种方案的方法证明这个结论。

假设 位置 $i$ 上的数为 $a_i$，则 $i$ 向 $a_i$ 连边，可得到若干个环。

设寄存器为 $p,q$，当前处理的环为 $\{m_k\}$。

则依次交换 $p,m_1$ 至 $p,m_{k-1}$、$q,m_k$、$q,m_1$、$p,m_k$ 即可。因为两个环不可能有交点，所以每个数只会和 $p$ 交换一次、和 $q$ 交换一次或不交换，不会有重复。如果最后 $p$、$q$ 错位的话再交换一次 $p,q$ 即可。

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,p,q,a[1000005],vis[1000005];
vector<pair<int,int> >ans;
void dfs(int x,int fa){
	vis[x]=1;
	if(a[x]==fa){
		ans.push_back(make_pair(x,q));
		swap(a[x],a[q]);
		ans.push_back(make_pair(fa,q));
		swap(a[fa],a[q]);
		ans.push_back(make_pair(x,p));
		swap(a[x],a[p]);
		return;
	}
	ans.push_back(make_pair(x,p));
	int qwq=a[x];
	swap(a[x],a[p]);
	dfs(qwq,fa);
}
int main(){
	scanf("%d",&n);
	int f=1;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i]!=i)f=0;
	}
	if(f){
		printf("0 0");
		return 0;
	}
	p=n+1;
	q=n+2;
	a[p]=p;
	a[q]=q;
	for(int i=1;i<=n;i++)
		if(vis[i]==0){
			if(a[i]==i)vis[i]=1;
			else dfs(i,i);
		}
	if(a[p]!=p)swap(a[p],a[q]),ans.push_back(make_pair(p,q));
	printf("2 %d\n",ans.size());
	int l=ans.size();
	for(int i=0;i<l;i++)
		printf("%d %d\n",ans[i].first,ans[i].second);
	return 0;
}
```

---

## 作者：Aewrxuk (赞：0)

题目链接：[[THUPC2022 初赛] 造计算机](https://www.luogu.com.cn/problem/P8210)。

我们将错位的值的位置与起应在的位置连一个边，连完之后我们发现整个序列被分为了若干环，我们只要依次将环中的数与第 $n+1$ 个寄存器换位，我们就会发现，我们面临一个困境：

假设这是一个大小为 $num$ 的环。

$a_{n+1}$ 的值为 $h_1$，$a_{h_1}$ 的值为 $n+1$，但是我们却无法交换这两个位置，因为之前已经交换过，这时我们就要试着再加入几个寄存器。我们试着往前推几步，并再加入一个寄存器，就可以完成交换，具体操作为：

当我们在交换 $h_{num-1}$ 时，依次执行：
$$\begin{aligned}&\operatorname{swap}(h_{num-1},n+1)\\&\operatorname{swap}(h_{num},n+2)\\&\operatorname{swap}(h_1,n+2)\\&\operatorname{swap}(h_{num},n+1)\end{aligned}$$

最后第 $n+1$ 和 $n+2$ 的数值可能会交换，在加一下就可以了。因为数据较小，我们只需要枚举每一个环，最后输出结果就可以了。

注意特判给的排列不需要排序的情况，直接输出 `0 0` 即可。

代码实现：

```cpp
pair<int, int>ans[1000010];
int n, tot, num, op;
int huan[100010], v[100010], a[100010];
void dfs(int x) {
    huan[++num] = x;
    v[x] = 1;

    if (!v[a[x]])
        dfs(a[x]);
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        if (a[i] != i)
            op = 1;
    }
    if (!op) {
        cout << 0 << ' ' << 0 << '\n';
        return 0;
    }
    a[n + 1] = n + 1;
    a[n + 2] = n + 2;
    for (int i = 1; i <= n; i++) {
        if (v[i] || i == a[i])
            continue;
        num = 0;
        dfs(i);
        for (int j = 1; j < num; j++) {
            ans[++tot].first = huan[j];
            ans[tot].second = n + 1;
            swap(a[huan[j]], a[n + 1]);
        }
        ans[++tot].first = huan[num];
        ans[tot].second = n + 2;
        swap(a[huan[num]], a[n + 2]);
        ans[++tot].first = huan[1];
        ans[tot].second = n + 2;
        swap(a[huan[1]], a[n + 2]);
        ans[++tot].first = huan[num];
        ans[tot].second = n + 1;
        swap(a[huan[num]], a[n + 1]);
    }
    if (a[n + 1] == n + 2) {
        ans[++tot].first = n + 1;
        ans[tot].second = n + 2;
    }
    cout << 2 << ' ' << tot << '\n';
    for (int i = 1; i <= tot; i++)
        cout << ans[i].first << ' ' << ans[i].second << '\n';
    return 0;
}
```

---

## 作者：CommunismFighter (赞：0)

我们观察一下当某个数 $i$ 的位置 $ps_{i} \neq i$ 时的情况：

- 假设 $ps_{i} = j,ps_{j} = i$，那么实际上就是 $i,j$ 这两个数位置发生了互换，这时我们让两个寄存器分别存储 $i,j$，最后再交换即可
- 考虑 $ps_{i} = j,ps_{j} = z,ps_{z} = i$ 这种情况，实际上是 $i,j,z$ 这三个数互相交换，我们可以将 $i$ 存到第一个寄存器里，$j$ 存到第二个寄存器里（到这里的步骤和上面那种情况没有变化）。然后我们再将 $j,z$ 交换，交换之后 $ps_{j} = j,ps_{z} = z$，然后再进行第一种情况的步骤即可
- 那如果有更多的数互相交换呢，那我们取其一 $i$ 放进第一个寄存器里，再将 $ps_{i}$ 上对应的数$k$放进第二个寄存器中，然后将 $k$ 与 $ps_{k}$ 上的数字 $u$ 交换，这是就有了 $ps_{k} = k$，然后再对 $z$ 重复上一个步骤即可，当第二个寄存器中的数都回归原位之后，就只剩下 $i$ 没有被对应了，再将 $i$ 放回对应位置即可

### 用理解的方式证明合理性：

对于 $ps_{i} \ne i$，一定是有一堆数互相牵扯影响，比如说 ``` 2 3 1``` 这种乱序排列。

我们从中挑出一个放入寄存器一，剩下的通过寄存器二使它们回归原位。在使用寄存器二的过程中，因为每一个数都有唯一对应的位置 $ps$，所以更新过程中不会存在重复的情况，最后放回寄存器一种的数时亦是如此。

另外每堆互相影响的数之间是相互独立的，因为如果某两堆不相互独立扯上关系，那么这两堆也一定可以因为关系牵扯合并成一堆进行处理。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<bitset>
#include<cstring>
#include<cmath>
#include<fstream>
#include<stack>
#include<queue>
#include<map>
#include<climits>
#define int long long
using namespace std;
const int N = 1e7+5,inf = 1e16;
inline int read(){
	int x = 0,f = 1;
	char ch = getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') f = -1;
		ch = getchar();
	}
	while(ch>='0' && ch<='9'){
		x = (x<<1)+(x<<3)+(ch^48);
		ch = getchar();
	}
	return x*f;
}
int n,num[N],ps[N],ct;
pair<int,int>as[N];
signed main(){
	n = read();
	for(int i=1;i<=n;++i){
		num[i] = read();
		ps[num[i]] = i;
	}
	num[n+1] = n+1;
	num[n+2] = n+2;
	ps[n+1] = n+1;
	ps[n+2] = n+2;
	int k;
	for(int i=1;i<=n;++i){
		if(ps[i]!=i){
			as[++ct] = {ps[i],n+1};
			k = ps[i];
			ps[i] = n+1;
			ps[num[n+1]] = k;
			swap(num[k],num[n+1]);
			as[++ct] = {i,n+2};
			ps[num[i]] = n+2;
			ps[num[n+2]] = i;
			swap(num[i],num[n+2]);
			while(num[n+2]<=n){
				as[++ct] = {num[n+2],n+2};
				k = num[n+2];
				ps[k] = k;
				ps[num[k]] = n+2;
				swap(num[k],num[n+2]);
			}
			as[++ct] = {num[n+1],n+1};
			k = num[n+1];
			ps[num[n+1]] = num[n+1];
			ps[num[k]] = n+1;
			swap(num[k],num[n+1]);
		}
	}
	if(!ct){
		printf("%lld %lld\n",0,0);
		return 0;	
	}
	if(ps[n+1]!=n+1) as[++ct]= {n+1,n+2};
	printf("%lld %lld\n",2,ct);
	for(int i=1;i<=ct;++i){
		printf("%lld %lld\n",as[i].first,as[i].second);
	}
	return 0;
}
```


---

## 作者：Tastoya (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8210)

[更好的阅读体验](https://www.cnblogs.com/baijian0212/p/p8210.html)
### 思路

> 结论：如果序列原先就合法，答案为 $0$；否则，最多使用两个寄存器。


我们对 $i \rightarrow a_i$ 建边得到若干个环，我们单独考虑一个环如何操作。

对于一个长度为 $4$ 的数列，再包含两个寄存器，设两个寄存器的值分别为 $x,y$。

![](https://cdn.luogu.com.cn/upload/image_hosting/e9dn22co.png)

显然 $4,1,3$ 组成了一个环，我们对其进行一些操作，使得他们回到他们想要到达的位置，即箭头指向的位置。

我们记 $\operatorname{pos}_i$ 表示值 $i$ 所在的位置，把 $4$ 看作环的起点，那么把这个环拆成一条链就是 $4,3,1$，下文称之为链。

首先我们将值 $4$ 与值 $5$ 交换位置，在此基础上再将值 $3$ 与刚刚换到第五个位置的值 $4$ 交换位置，除了链的最后一个元素外，剩下的元素按照上面的方式依次与第一个寄存器进行交换。

这样，我们链的第 $1 \sim n-2$ 个元素都达到了自己的目标位置（他们指向的位置就是目标位置）。只剩下原本链的最后一个元素和倒数第二个元素没有达到目标位置。

我们寄存器原本的值 $x$ 放在了链的第一个位置，链的倒数第二个元素放在了第一个寄存器的位置。链的最后一个元素仍在其原位置。

考虑如何处理剩下这两个元素。我们设链的倒数第二个值为 $a$，最后一个值为 $b$。

我们考虑把值 $b$ 与值 $y$ 交换，现在 $y$ 在链的末尾，$b$ 在第二个寄存器；

再考虑把刚刚换到链的末尾的值 $y$ 与第一个寄存器的值进行交换，即将值 $y$ 与值 $a$ 交换，现在 $a$ 在链的末尾（达到了目标位置），$y$ 在第一个寄存器；

再考虑将第二个寄存器的值与链首的值进行交换，即把 $b$ 与 $x$ 进行交换，$b$ 达到了其目标位置。

到这里，前面的内存单元就已经合法了。我们再考虑一下两个寄存器顺序是否合法就可以了。
### Code
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100500;

int n,m;

int a[N];

vector< pair<int,int> > ans;
deque<int> st;

bool vis[N];

void dfs(int x) {
    vis[x] = 1;
    st.push_back(x);

    if(!vis[a[x]])
        dfs(a[x]);
    
    return ;
}


int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for(int i = 1;i <= n; i++) 
        cin >> a[i];
    
    a[n + 1] = n + 1;
    a[n + 2] = n + 2;
    
    for(int i = 1;i <= n; i++) {
        if(!vis[i] && i != a[i]) {
            st.clear();
            
            dfs(i);

            m = 2;

            for(auto const &it : st) {
                if(it == st.back())
                    break;

                ans.emplace_back(it,n + 1);
                swap(a[it],a[n + 1]);
            }
            
            ans.emplace_back(st.back(),n + 2);
            swap(a[st.back()],a[n + 2]);

            ans.emplace_back(st.back(),n + 1);
            swap(a[st.back()],a[n + 1]);

            ans.emplace_back(st.front(),n + 2);
            swap(a[st.front()],a[n + 2]);
        }
    }

    if(a[n + 1] != n + 1) 
        ans.emplace_back(n + 1,n + 2);
    
    cout << m << " " << ans.size() << "\n";
    for(auto const &it : ans) 
        cout << it.first << " " << it.second << "\n";
    
    return 0;
}
```

---

## 作者：Hanzelic (赞：0)

## [原题链接](https://www.luogu.com.cn/problem/P8210)
我们最少需要 $2$ 个寄存器，因为这样我们可以避免出现重复的情况。 

假设有内存单元 $x$，$y$ 和寄存器 $a$，$b$，那我们可以通过 $x→a$，$y→b$，$x→b$，$y→a$ 来实现不重复的转换。 

对于这个题来说，我们只需要依次遍历整个数组，找到不符合标准的进行上述转化，直到两个寄存器还是之前的数（顺序可以改变，但是数值不能变）就停止，继续下一个循环，这样是肯定可以保证这个位置之前的数值都是对应好的，因为如果前面的数如果和这个位置没有关系，那么前面的数肯定是排好了的，也就是用不到了，反之就在这次匹配中肯定也是能排好了的，于是我们就可以避免用到重复的交换，最后判断一下两个寄存器之间是否匹配就行了。  

记得特判一下本来就拍好序的情况，那就不需要寄存器了。
## 代码
```cpp
#include<bits/stdc++.h>
#define M 100505
#define N 1000005
using namespace std;
int n,m,k,now=1;
int num[M],x[N],y[N],from[M];
bool p;
int main(){
	scanf("%d",&n);
	for(int q=1;q<=n;q++){
		scanf("%d",&num[q]);
		if(num[q]!=q)p=1;
		from[num[q]]=q;
	}
	if(!p){
		printf("0 0\n");
		return 0;
	}
	num[n+1]=n+1;num[n+2]=n+2;
	from[n+1]=n+1;from[n+2]=n+2;
	for(int q=1;q<=n;q++){
		if(num[q]!=q){
			x[++k]=q;
			y[k]=n+1;
			swap(from[num[q]],from[num[n+1]]);
			swap(num[q],num[n+1]);
			x[++k]=num[n+1];
			y[k]=n+2;
			swap(from[num[num[n+1]]],from[num[n+2]]);
			swap(num[num[n+1]],num[n+2]);
			while(num[n+2]!=n+2&&num[n+2]!=n+1){
				x[++k]=num[n+2];
				y[k]=n+2;
				swap(from[num[n+2]],from[num[num[n+2]]]);
				swap(num[n+2],num[num[n+2]]);
			}
			while(num[n+1]!=n+1&&num[n+1]!=n+2){
				x[++k]=num[n+1];
				y[k]=n+1;
				swap(from[num[n+1]],from[num[num[n+1]]]);
				swap(num[n+1],num[num[n+1]]);
			}
		}
	}
	if(num[n+1]!=n+1){
		x[++k]=n+1;
		y[k]=n+2;
	}
	printf("2 %d\n",k);
	for(int q=1;q<=k;q++){
		printf("%d %d\n",x[q],y[q]);
	}
	return 0;
}
```


---

## 作者：donghanwen1225 (赞：0)

赛时我们队写这个题从 1h 的时候写到比赛结束，赛后才知道是方案假了。

------------

实际上这题的构造方案非常高妙。先给出结论：如果满足 $\forall i\in[1,n],a_i=i$，那么需要 $0$ 个寄存器；否则只需要 $2$ 个寄存器。

我们将排列 $a$ 中的每个数 $a_i$ 都视为 $i\to a_i$ 的一条有向边，那么可以得到一张 $n$ 个点 $n$ 条边的有向图。

这里要使用到一个引理：在构造出的这张有向图中，所有点都处在一个环上。

如果读者学过群论，立即可以看出这其实就是把一个 $n$ 阶置换拆分成多个不相交轮换之积。要证明这个引理可以用数学归纳法，这里就不证了，读者可以自行感性理解。

接下来设我们得到了 $p$ 个环，其中某个环中的点可以表示为 $b_1,b_2,\cdots,b_k$。那么我们需要做的，就是用两个寄存器，完成从 $b_1,b_2,\cdots,b_k$ 到 $b_k,b_1,b_2,\cdots,b_{k-1}$ 的变换。

我们有如下的方案：

|步数|当前排列|操作|
| :-----------: | :-----------: | :-----------: |
|$\text{step 1}$|$b_1,b_2,b_3,b_4,\cdots,b_k,n+1,n+2$|$\text{swap }b_1,n+1$|
|$\text{step 2}$|$n+1,b_2,b_3,b_4\cdots,b_k,b_1,n+2$|$\text{swap }b_2,n+2$|
|$\text{step 3}$|$n+1,n+2,b_3,b_4,\cdots,b_k,b_1,b_2$|$\text{swap }b_3,b_2$|
|$\text{step 4}$|$n+1,n+2,b_2,b_4,\cdots,b_k,b_1,b_3$|$\text{swap }b_4,b_3$|
|$\cdots$|$\cdots$|$\cdots$|
|$\text{step }k$|$n+1,n+2,b_2,b_3,\cdots,b_{k-2},b_k,b_1,b_{k-1}$|$\text{swap }b_k,b_{k-1}$|
|$\text{step }k+1$|$n+1,n+2,b_2,b_3,\cdots,b_{k-2},b_{k-1},b_1,b_{k}$|$\text{swap }b_k,n+1$|
|$\text{step }k+2$|$b_k,n+2,b_2,b_3,\cdots,b_{k-2},b_{k-1},b_1,n+1$|$\text{swap }b_1,n+2$|

这样，我们就只用两个寄存器完成了一个环的任务。

那么只需要对这 $p$ 个环分别进行这样的操作，就可以解决此题了。

最后注意，每次变换后两个寄存器都会互换位置。因此若长度大于等于 $2$ 的环的个数为奇数，则最后还需要将两个寄存器的位置互换。

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,bs,cur=0,cs=0,f=0,a[100001],b[100001],vis[100001],ans1[1000001],ans2[1000001];
void ins(int x,int y){bs++;ans1[bs]=x;ans2[bs]=y;}
void sol()
{
	if(cur==1) return;
	cs++;
	ins(b[1],n+1);ins(b[2],n+2);
	for(int i=3;i<=cur;i++) ins(b[i],n+2);
	ins(b[1],n+2);ins(b[2],n+1);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),f=f||(a[i]!=i);
	if(!f){printf("0 0");return 0;}
	for(int i=1;i<=n;i++)
		if(!vis[i])
		{
			cur=0;int now=i;
			while(1)
			{
				b[++cur]=now;vis[now]=1;
				now=a[now];if(now==i) break;
			}
			sol();
		}
	if(cs&1) ins(n+1,n+2);
	printf("2 %d\n",bs);
	for(int i=1;i<=bs;i++) printf("%d %d\n",ans1[i],ans2[i]);
	return 0;
}
```

---


# [THUPC 2023 决赛] 着色

## 题目背景

远古的笔迹，远古的乐音，远古的历史，远古的 $K_{1000}$，若无人问津，便悄然褪色……

## 题目描述

给出一个 $n$ 个节点的无向完全图，你需要给每条边标上一个 $0 \sim 9$ 的数字，使得图上不存在一个三元环或五元环满足：其上所有边的数字相同。

## 说明/提示

### 数据规模与约定

对于所有测试数据，$2 \le n \le 1000$。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
4```

### 输出

```
012
34
5
```

# 题解

## 作者：rui_er (赞：7)

有趣的构造题！

不存在三元环或五元环颜色相同看起来很诈骗，不妨加强一下问题，使得不存在奇环颜色相同。也就是说，每种颜色构成一个二分图。

又发现颜色数 $10=\lceil\log_21000\rceil$，其中 $1000$ 是 $n$ 的上限。因此，我们可以自然地想到使用二进制位为 $0$ 或为 $1$ 作为划分左部、右部的依据。

具体地，我们使得连接 $u,v$ 的边的颜色为 $\operatorname{ctz}(u\oplus v)$，其中 $\operatorname{ctz}(x)=\log_2(\operatorname{lowbit}(x))$，是 $x$ 二进制后导零个数。容易发现，这种构造是符合要求的，每种颜色的边必定连接某一个二进制位不同的两个点，因此每种颜色的边都构成二分图。

于是不存在奇环颜色相同，自然就不存在三元环或五元环颜色相同了。

```cpp
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

int main() {
    int n;
    scanf("%d", &n);
    rep(i, 1, n-1) {
        rep(j, i+1, n) printf("%d", (int)__builtin_ctz(i ^ j));
        puts("");
    }
    return 0;
}
```

---

## 作者：lyhqwq (赞：3)

# Solution

喵喵构造

我们考虑将三元环和五元环的限制增强，变为图中不存在颜色相同的奇环。

那么每种颜色都构成一个二分图。

接下来提供一种和其他题解不同的构造方法。

我们考虑分治，每次将当前所有点分成两部分，所有的点之间的边染上相同的颜色，然后递归两部分内部染下一种颜色。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n;
int a[N][N];
void solve(int l,int r,int o){
    if(l==r) return;
    int mid=(l+r)>>1;
    solve(l,mid,o+1),solve(mid+1,r,o+1);
    for(int i=l;i<=mid;i++) for(int j=mid+1;j<=r;j++) a[i][j]=o;
}
int main(){
    scanf("%d",&n);
    solve(1,n,0);
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++) printf("%d",a[i][j]);
        puts("");
    }
    return 0;
}

```


---

## 作者：船酱魔王 (赞：3)

# P9384 [THUPC 2023 决赛] 着色 题解

## 题意回顾

有一个 $ n $ 个点的无向完全图，给每条边染色，共 $ 10 $ 种颜色，要使得任意三/五元环上所有边的颜色不完全相同，构造染色方案或报告无解。

$ n \le 1000 $。

## 分析

三元环和五元环都是奇环，想到二分图，因此我们的目标是使得任意颜色的边和所有点构成的图是二分图。

而 $ 10 $ 种颜色让人联想到 $ 2^{10}=1024>1000 $，因此考虑按二进制位染色。

一个想法就是每种颜色对应一个二进制位，当那个二进制位不同的两个点才有可能染那种颜色。两个点的不同位可能很多，至少有 $ 1 $ 个。因此我们在这些不同位中任选即可选出染色。我们的代码实现是选取最低位的。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n;
int lowbit(int x) {
	return x & (-x);
}
int tz[1024];
int main() {
	cin >> n;
	for(int j = 0; j < 10; j++) {
		tz[(1 << j)] = j;
	}
	for(int i = 1; i < n; i++) {
		for(int j = i + 1; j <= n; j++) {
			cout << (char)('0' + tz[lowbit(i ^ j)]);
		}
		cout << endl;
	}
	return 0;
}
```

## 总结与评价

清新构造题，代码短思维量大，THUPC 的题质量真高啊（

---

## 作者：Stairs_upon_temple (赞：3)

## [P9384](https://www.luogu.com.cn/problem/P9384)

构造题，首先考虑爆搜，但结果跑不出来。

既然题目中描述相同元素不能构成三元环或五元环，其实可以把条件用的更局限，考虑相同元素只能构成偶环，即同一权值的边构成二分图，可以发现本题刚好 $10$ 种颜色，刚好 $2^{10}=1024 > 1000$。

接下来考虑怎么构造二分图，本题大部分思路都是令 $s=i \oplus j$，并将 $\operatorname{lowbit(s)}$ 作为染色的依据，但没有提到怎么去想出这样的思路。

首先，令一个集合 $A= \{ a_1,a_2,a_3 \dots a_k\}$，其中的元素互不相同,且都不为零。

令另一个集合 $B=\{b_1,b_2,b_3 \dots b_l\}$，其中 $l=k$ 且 $\forall a_i \in A$ 满足 $a_i \oplus a_{i+1} \in B$，特别地 $b_l=a_1 \oplus a_k$。

说人话就是集合 $B$ 是由集合 $A$ 中两个相邻的元素异或得到的。

对于以上两个集合有一个性质：即当 $k$ 为偶数时，对于形式类似于 $\exists b_i,b_j \in B,i \ne j \ \operatorname{lowbit(b_i)}=\operatorname{lowbit(b_j)}$ 的情况刚好能不重不漏的覆盖整个 $B$ 集合，具体请读者自证。

那以上结论有什么用呢？可以发现在一个二分图里面，点数刚好是偶数，而每个点的序都不同，刚好满足上述条件，故可以按照思路中的 $\operatorname{lowbit(s)}$ 作为染色的依据。

```cpp
/*
g++ -o2 P9384.cpp -o c -std=c++14
.\c

*/

#include<cstdio>

using namespace std;
const int N=1e3+100;
int n;
int t[N];

int lowbit(int x){
    return x&(-x);
}

int main(){
    scanf("%d",&n);
    for(int i=0;i<=10;i++){
        t[1<<i]=i;
    }
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            printf("%d",t[lowbit(i^j)]);
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：迟暮天复明 (赞：1)

考场上想到的做法。

记边 $(i,j)$ 的权值为 $f(j-i)$，其中 $f(i)$ 为满足 $2^k \mid i$ 且 $2^{k+1}\nmid i $ 的 $k$。不难证明这个 $k$ 唯一。

正确性是显然的。如果 $f(i,j)=m$ 且 $f(j,k)=m$，那么 $f(i,k)$ 一定至少为 $m+1$。五元环的情况类似。

---

## 作者：small_stone (赞：1)

先感慨一下，THUPC 的题质量是真的高，思维难度大、码量小，~~耗了我半小时~~。

言归正传，这道题就是说给边涂色，要求相同颜色的边没有三元环和五元环。

为了方便考虑，我们把要求提高，相同颜色的边没有奇数环。

什么样的图没有奇数环？——二分图。

不了解二分图的可以戳[这个链接](https://oiwiki.org/graph/bi-graph/)。

由于二分图的性质，我们只需让相同颜色的边与所有点构成一个二分图即可。考虑到 $2^{10} > 1000$，我们用一个二进制位表示一种颜色，如果是 $0$，表示在一个点集，否则在另一个点集。因此，我们可以枚举点 $i$ 和 $j$，找出二进制中不同的那一位（如有多位，随便输出一位，我是输出最低位），输出对应颜色即可。

怎么找不同的哪一位？方法如下，先将两个数异或，这时相同的位为 $0$，不同的为 $1$。再进行 lowbit 操作就能找出不同的那一位了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
unordered_map<long long,long long> m;
long long lowbit(long long x) {
	return x&-x;
}
int main() {
	scanf("%lld",&n);
	for (long long i=0;i<=9;i++) m[1<<i]=i;
	for (long long i=1;i<=n-1;i++) {
		for (long long j=1;j<=n-i;j++) {
			printf("%lld",m[lowbit(i^(i+j))]);
		}
		printf("\n");
	}
	return 0;
}
//用时：67ms
//内存：808.00KB
```

---

## 作者：Melo_DDD (赞：0)

参考了尺子姐姐的题解。

五元环很不常见，所以我们尝试扩展到所有奇环。那么可以发现原图中每种颜色的边拎出来构成的图是二分图。

进一步发现 $1000$ 恰好接近 $2^{10}$，考虑二进制对二分图分部。

容易想到按照二进制下某一位进行分部，那么考虑把连接 $i$ 和 $j$ 的边染成 $\rm ctz(i\oplus j)$，即两数异或和最低位的 $1$ 的位数。那么可以按照这一位是 $1$ 还是 $0$ 分部，正确性显然。

```cpp
f (i ,1 ,n - 1 ,1) {
  f (j ,1 ,n - i ,1)
  std :: cout << __builtin_ctz (i ^ i + j) ;
  puts ("") ;
}
```

---

## 作者：Fire_Raku (赞：0)

[P9384 [THUPC 2023 决赛] 着色](https://www.luogu.com.cn/problem/P9384)

思维题+构造

三元环还可以，五元环有点抽象，考虑将其全归为奇环，那么题目就变成：求一种设边权的方案，使得只用边权 $i$ 无法构成奇环。

那么这个限制等价于只保留边权为 $i$ 的边的图是二分图，那么一条边的两个端点得是不同属性。考虑怎么构造二分图，看到 $0∼9$ 的边权和 $n$ 的范围，考虑将其对应到二进制上每个位。构造方式：两点 $i$ 和 $j$ 之间连边权为 $ctz(i\oplus j)$（二进制上最低的不相同的位置）。

证明这样连边的合法性，边权 $i$ 连接的两个端点二进制上第 $i$ 位一定不同，就将点分为了两类（第 $i$ 位为 $1$ 或为 $0$），此时如果保留边权为 $i$ 的边，一定为二分图。

复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
#define pii std::pair<int, int>
#define mk std::make_pair
#define fi first
#define se second
#define pb push_back

using i64 = long long;
using ull = unsigned long long;
const i64 iinf = 0x3f3f3f3f, linf = 0x3f3f3f3f3f3f3f3f;

int n;
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
	std::cin >> n;

	for (int i = 1; i < n; i++) {
		for (int j = 1; i + j <= n; j++) {
			std::cout << __builtin_ctz(i ^ (i + j)); 
		}
		std::cout << "\n";
	}	

	return 0;
}
```

---


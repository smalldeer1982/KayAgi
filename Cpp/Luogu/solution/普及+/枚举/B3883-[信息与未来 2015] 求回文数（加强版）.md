# [信息与未来 2015] 求回文数（加强版）

## 题目描述

一个正整数，正读和反读都相同的数为回文数，例如 $22,131,2442,37073,6,\cdots$。所有的 $1$ 位数都是回文数。

现给出一个正整数 $n$，求出 $[1,n]$ 中的回文数的个数。

## 说明/提示

### 样例解释
在 $1$ 至 $24$ 中，回文数有 $1\sim 9,11,22$，共 $11$ 个。
### 数据范围
$1\le n\le10^{100}$。

## 样例 #1

### 输入

```
24```

### 输出

```
11```

# 题解

## 作者：zjh114514 (赞：8)

观前提示：本题解建议已经有数位 dp 基础的谷民食用。如果不知道什么是数位 dp，请移步 [P2602](https://www.luogu.com.cn/problem/P2602)，那里有非常详细的数位 dp 解析。
# 求回文数（加强版）题解
## 题意
给出一个正整数 $n$，求 $[1,n]$ 中回文数的个数对 $20091119$ 取模的值。  
$n≤10^{100}$
## 思路
观察到 $n$ 很大，可以考虑数位 dp。  
简单思考可以发现，对于不足 $n$ 位的数，可以提前计算出回文数的个数。  
而对于 $n$ 位的数，可以采用暴力求回文数的做法，枚举回文数的一半得到整个回文数，并用记忆化搜索优化。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=105,MOD=20091119;
char s[MAXN];
int a[MAXN],len;
int dp[2][MAXN];
int temp[MAXN],total;
int check(){
    for(int i=total,j=(len>>1)+(len&1);i&&j;i--,j--){//+(len&1)判断奇/偶回文数。
        if(temp[i]>a[j]) return 0;
        if(temp[i]<a[j]) return 1;
    }
    return 1;
}
int dfs(bool lim,int pos){//lim为1时代表前面高位的都和原数一样，pos为当前下标。
    if(pos==(len>>1)){//枚举到一半。
        if(!lim) return 1;//如果lim为0，后面可以随便取，返回1。
        return check();//否则判断一下是否超出原数，仅会判断1次。
    }
    if(~dp[lim][pos]) return dp[lim][pos];
    int res=0;
    for(int i=0;i<=9;i++){
        if(pos==len&&!i) continue;//最高位必不等0。
        if(lim&&i>a[pos]) break;//超出原数就终止循环。
        temp[++total]=i;//存下回文数的一半。
        res=(res+dfs(lim&&i==a[pos],pos-1))%MOD;
        total--;
    }
    return dp[lim][pos]=res;
}
int solve(){
    for(int i=1;i<=len;i++) a[i]=s[len-i+1]-48;//转成数字，a[1]为个位。
    int res=0;
    for(int i=len-1;i;i--){
        int res2=9;//避免前导零。
        for(int j=i-1;j>(i>>1);j--) res2=(res2*10)%MOD;
        res=(res+res2)%MOD;
    }
    //提前计算不足n位的数的回文数个数。
    memset(dp,-1,sizeof(dp));
    res=(res+dfs(1,len))%MOD;
    return res;
}
int main(){
    scanf("%s",s+1);
    len=strlen(s+1);
    printf("%d",solve());
    return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：7)

加强 By @[沉石鱼惊旋](/user/516346)

upd 2023.11.13 20:59 修改一处表达错误。

upd 2023.11.22 21:06 修改 std。

upd 2023.12.30 15:22 添加 ShanireZ 按题解实现的做法。

# 简要题意

求 $[1,n]$ 中有多少回文数，对 $20091119$ 取模。

~~模数是我的生日。~~

# 题目思路

考虑分成 $len=\left\vert n\right\vert$ 和 $len<\left\vert 	n\right\vert$ 两部分。

$len<\left\vert n\right\vert$ 是很好计算的。

我们会发现答案一定是 $[10\dots000000\dots01,999999\dots99999]$ 的形式，所以这一部分答案就是 $\sum 9\times 10^{\left\lceil\frac{len}{2}\right\rceil-1}$。

然后考虑 $len=\left\vert n\right\vert$ 怎么做，我们可以先把他搞成**最大的比 $n$ 小的回文串**。那么答案就在 $10\dots000000\dots01$ 到刚才这个回文串之间。统计个数是简单的，类似高精度减法即可，而且这里没有退位操作。

```cpp
void pre_ans()
{
    for (int len = 1; len < n; len++)
    {
        int m = (len + 1) >> 1;
        (ans += qpow(10, m - 1) * 9) %= p;
    }
}
```

# 完整代码

感谢 @[Aaplloo](https://www.luogu.com.cn/user/137426) 指出的错误。

~~题解中提到的实现等我什么时候调完代码什么时候放。~~

[Code by @irris](https://www.luogu.com.cn/paste/wvlxskaj)

[Code by @ShanireZ](https://www.luogu.com.cn/paste/4ic34ae8)

---


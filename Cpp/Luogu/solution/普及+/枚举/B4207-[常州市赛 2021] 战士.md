# [常州市赛 2021] 战士

## 题目背景

搬运自 <http://czoj.com.cn/p/443>。数据为民间数据。

## 题目描述

小 $\text X$ 在玩一款操控战士和怪物战斗的游戏。战士初始生命值为 $\text{iH}$ 、初始攻击力为 $\text{iA}$ 。怪物只有一个，初始生命值为 $H$ 。  
战斗是回合制的，且有一个回合数限制 $M$ 。如果在 $M$ 回合内怪物还没有被杀死，小 $\text X$ 就失败了。在每个回合，战士先行动，怪物再行动。  
每当战士行动，小 $\text X$ 可以命令战士做以下两件事中的一件：  

- 攻击，让怪物的生命值减少当前战士攻击力的数值。  
- 磨刀，让战士攻击力增加 $\text{dA}$ 。  

每当怪物行动，怪物会攻击战士，使战士的生命值减少 $C_i$ ，其中 $i$ 为回合数。  
当一个角色生命值小于等于 $0$ 时，角色会死亡。  

- 如果怪物死亡，那么战斗就结束了。  
- 如果战士死亡，会立刻复活，将生命值和攻击力恢复为初始数值。  

现在小 $X$ 想问问你，最少能在几个回合内杀死怪物。  

## 说明/提示

### 样例解释
其中一种合法方案：  
- 第一回合：战士磨刀，战士攻击力变为 $2$ ；怪物攻击，战士生命值变成 $2$。  
- 第二回合：战士攻击，怪物生命值变为 $4$ ；怪物攻击，战士生命值变成 $1$ 。  
- 第三回合：战士攻击，怪物生命值变为 $2$ ；怪物攻击，战士死亡后复活，生命值变为 $4$ ，攻击力变为 $1$ 。  
- 第四回合：战士攻击，怪物生命值变为 $1$ ；怪物攻击，战士生命值变成 $3$ 。  
- 第五回合：战士攻击，怪物死亡。  
### 数据范围
本题共有 $10$ 个测试点。  
对于所有数据，$1\le \text{iH,iA},H\le10^9,0\le \text{dA}\le10^9,1\le C_i\le M\le2\times10^5$。
|测试点编号|$M$|特殊性质|
|:-:|:-:|:-:|
|$1$|$\le 2\times10^5$|$\text{dA}=0$|
|$2\sim3$|$\le20$|无|
|$4\sim5$|$\le30$|无|
|$6\sim8$|$\le10^3$|无|
|$9\sim10$|$\le2\times10^5$|无|

## 样例 #1

### 输入

```
4 1 6 1 8
2 1 1 1 1 1 1 1```

### 输出

```
5```

# 题解

## 作者：Ag2WO4 (赞：1)

连续的若干次回合内显然优先磨刀，令在 $m$ 回合内磨了 $p$ 次刀则总伤害为 $[\text{iA+dA}(m-p)]p$ 即 $-dp^2+(\text{iA+dA}m)p$，它是一个二次函数，其最大值在 $-\frac{b}{2a}$ 即 $\frac{\text{iA+dA}m}{2d}$ 处取到，由于二次函数的对称性离它最近的整数值就是取整时的最大值。直接模拟每轮能否一刀斩，能就输出，否则攒大招，同时模拟剩余血量，战士死亡时强制清空大招。注意特判 $\text{dA=0}$ 时不要磨刀。
```python
i,a,h,d,m=map(int,input().split());m=n=q=0
for j in map(int,input().split()):
    m+=1;q+=1;n+=j;o=int((a+m*d)/2/d)+(1 if(a+m*d)/2/d>.5+int((a+m*d)/2/d)else 0)if d else 1<<30
    if(a+d*(m-min(o,m)))*min(o,m)>=h:print(q);exit()
    if n>=i:h-=(a+d*(m-min(o,m)))*min(o,m);m=n=0
print(-1)
```

---

## 作者：cheny919 (赞：0)

### 题目分析
在这个题目中我们需要让战士造成伤害最大。因为战士有死后复活并攻击力复原的特点，因此只需要把两次死亡的间隔看为一个阶段，这中间每一个回合都看做一次行动，这样就只需要考虑如何做到一个阶段内的最优解就可以了。但是有时候虽然先磨刀可以得到一阶段造成伤害的最优解，但造成的伤害却远远溢出了，不如直接砍一刀节省时间。所以我们需要判断会不会出现这种情况。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int gongxian,xueyuan,digong[200005],dixue,modao,gongyuan;
	int boluo2[200005]={0},huihexian=0,huihe=1,boluo1=0,boluo3=0,boluo4=1,panduan=0,pineapple=1,pineapple2=0,pineapple3=0;
	cin>>xueyuan>>gongyuan>>dixue>>modao>>huihe;
	gongxian=gongyuan;
	for(int i=1;i<=huihe;i++)
	{
		cin>>digong[i];
		boluo1=boluo1+digong[i];
		boluo2[boluo4]++;
		if(boluo1>=xueyuan)
		{
			boluo1=0;
			boluo4=boluo4+1;//boluo4代表是第几阶段。
		}
	}
	while(panduan==0)
	{
		if(panduan==0)//求一个阶段的最优解。
		{
			boluo2[pineapple]=boluo2[pineapple]-1;
			pineapple2=dixue-gongxian;
			pineapple3=dixue-modao*boluo2[pineapple];
			if(pineapple2<=0) pineapple2=0;
			if(pineapple3<=0) pineapple3=0;//一定要写这两行代码！这两行代码用于解决阶段最优解伤害溢出的情况。
			if(pineapple2>pineapple3)
			{
				gongxian=gongxian+modao;
						huihexian=huihexian+1;
			}
			else if(pineapple3>=pineapple3)
			{
				dixue=dixue-gongxian;
						huihexian=huihexian+1;
			}
		}
		if(panduan==0&&boluo2[pineapple]<=0)
		{
			pineapple=pineapple+1;
			gongxian=gongyuan;
		}
		if(dixue<=0)
		{
			panduan=7;
		}
		if(huihexian>huihe)
		{
			panduan=4;
		}
	}
	if(huihexian<=huihe) cout<<huihexian<<endl;
	if(huihexian>huihe) cout<<"-1"<<endl;
	return 0;
}
```

---


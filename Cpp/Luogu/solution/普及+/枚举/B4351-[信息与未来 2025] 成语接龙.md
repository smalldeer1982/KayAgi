# [信息与未来 2025] 成语接龙

## 题目描述

小朋友们都很喜欢成语接龙，但如果遇到可以无限接龙的 “防不胜防”、“忍无可忍” 和 “为所欲为”，游戏就会陷入僵局。Dr. X 发明了改进版的成语接龙：把 $16$ 个汉字写在 $4$ 行 $4$ 列的方阵中，要求：

- 第一行（从左往右读）是一个四字成语。
- 最后一列（从上往下读）是一个四字成语。
- 最后一行（从右往左读）是一个四字成语。
- 第一列（从下往上读）是一个四字成语。
- 对角线（从左上到右下读）是一个四字成语。
- 对角线（从右上到左下读）是一个四字成语。
- 上面 $6$ 个成语各不相同。

下面是一个满足条件的成语接龙：

![](https://cdn.luogu.com.cn/upload/image_hosting/vuia52vl.png)

Dr. X 找到了一本成语词典，你能帮 Dr. X 编程找到词典中所有满足条件的成语接龙方阵吗？

## 说明/提示

对于 $40\%$ 的数据，$n ≤ 100$。

对于 $100\%$ 的数据，$10 ≤ n ≤ 10^4$，且输入中的所有成语均来自真实的成语词典。成语词典中没有重复的成语。

## 样例 #1

### 输入

```
10
hua xiang niao yu
yu miao tian xia
xia li ba ren
ren mian tao hua
hua qian yue xia
yu chu jing ren
ji xiang ru yi
xin xiang shi cheng
cong ming ling li
jian kang cheng zhang```

### 输出

```
1```

## 样例 #2

### 输入

```
（见下发文件 idiom.txt）```

### 输出

```
58```

# 题解

## 作者：Yivan11 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/B4351)
这题没想到我不仅是最优解而且也是第一个发题解的人，也正好该涨涨咕值了，好的回归正题，准备讲了啊。
## 题目理解
这道题要求我们找出所有满足特定条件的 $4\times4$ 汉字方阵，其中六个不同的成语分别对应不同的行、列和对角线。我们需要高效地枚举所有可能的成语组合，并验证它们是否能构成符合条件的方阵。

## 思路
我们首先可以直接枚举六个成语，分别对应方阵的第一行、最后一列、最后一行、第一列、主对角线和副对角线，确保每个位置的汉字匹配且成语不重复，然后使用哈希表加速查找，通过六重循环检查所有可能组合，满足条件就要给他计数。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin >> n;
    vector<vector<string>> I(n, vector<string>(4));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < 4; ++j) {
            cin >> I[i][j];
        }
    }
    unordered_map<string, vector<int>> F;
    unordered_map<string, vector<int>> L;
    for (int i = 0; i < n; ++i) {
        F[I[i][0]].push_back(i);
        L[I[i][3]].push_back(i);
    }
    int c = 0;
    for (int i1 = 0; i1 < n; ++i1) {
        const auto& I1 = I[i1];
        const string& d = I1[3];
        for (int i2 : F[d]) {
            if (i2 == i1) continue;
            const auto& I2 = I[i2];
            const string& p = I2[3];
            for (int i3 : F[p]) {
                if (i3 == i1 || i3 == i2) continue;
                const auto& I3 = I[i3];
                const string& m = I3[3];

                for (int i4 : F[m]) {
                    if (i4 == i1 || i4 == i2 || i4 == i3) continue;
                    const auto& I4 = I[i4];
                    if (I4[3] != I1[0]) continue;

                    for (int i5 : F[I1[0]]) {
                        if (i5 == i1 || i5 == i2 || i5 == i3 || i5 == i4) continue;
                        const auto& I5 = I[i5];
                        if (I5[3] != I2[3]) continue;
                        for (int i6 : F[I1[3]]) {
                            if (i6 == i1 || i6 == i2 || i6 == i3 || i6 == i4 || i6 == i5) continue;
                            const auto& I6 = I[i6];
                            if (I6[3] != I3[3]) continue;
                            c++;
                        }
                    }
                }
            }
        }
    }
    cout << c << endl;
    return 0;
}
```
最后在这里说一句，谢谢大家的观看。

---


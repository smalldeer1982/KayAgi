# 「XSOI-R1」跳跃游戏

## 题目背景

本来可怜的 $\texttt{MhxMa}$ 想出这道题，但是已经被 $\texttt{Ferm\_Tawn}$ 抢了，此时 $\texttt{MhxMa}$ 坐在电脑面前，看着马上要造好的数据，想象着自己的题难倒一大片选手的梦想破灭了。

## 题目描述

这是一个跳跃游戏。在游戏中你可以跳到任意位置，其中有 $n$ 个点：$1 , 2 , 3, \cdots , n$，跳到那里会有奖励分数 $a_1 , a_2 , \cdots , a_n$。

显然，这个游戏很简单，$\texttt{MhxMa}$ 没过多久就获得了所有分数，于是改进了代码，添加了经验值这个参数。

对于有奖励分数的 $n$ 个点，若从点 $x$ 跳到点 $y$，会获得经验值 $\operatorname{score}_{x , y}(1\le x\le y\le n)$：

$$\operatorname{score}_{x,y}=\begin{cases}\operatorname{len}  & \operatorname{gcd}(a_x , a_{x+1} , \dots , a_y)=2 , \operatorname{len \ mod} 2 = 0  \\ \operatorname{len} &\gcd(a_x , a_{x + 1} , \dots , a_y)=3 , \operatorname{len \ mod} 2 = 1\\ 0 & \operatorname{others} \end{cases}$$

其中，$\operatorname {len}$ 表示区间的长度，即 $y-x+1$。

**对于每一对位置 $(x,y)$，多次跳跃只会获得一次经验值。**

为了向 $\texttt{MhxMa}$ 展现你的编程实力，你决定写一个代码算出这个游戏能刷到的最大经验值。

## 说明/提示

**请使用较快的读入方式。**

### 样例解释 #1

$\operatorname{score_{2 , 2}}= 1$。

$\operatorname{score_{2 , 4}}= 3$。

$\operatorname{score_{3 , 5}}= 3$。

$\operatorname{score_{4 , 4}}= 1$。

$1+3+3+1=8$。

### 样例解释 #2

$\operatorname{score_{1 , 2}}= 2$。

$\operatorname{score_{1 , 4}}= 4$。

$\operatorname{score_{2 , 3}}= 2$。

$\operatorname{score_{2 , 5}}= 4$。

$\operatorname{score_{3 , 4}}= 2$。

$\operatorname{score_{4 , 5}}= 2$。

$2+ 4 + 2 + 4 + 2 + 2 = 16$。

------------
### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 0（20 pts）：$n \le 10^2$。 

- Subtask 1（10 pts）：$n \le 2 \times 10^3$。

- Subtask 2（20 pts）：$n \le 10^4$。

- Subtask 3（50 pts）：$n \le 6 \times 10^5 $。


对于所有测试数据，$1 \le n \le 6 \times 10^5$，$1 \le a_i \le 10^7$。

## 样例 #1

### 输入

```
5
2 3 6 3 9```

### 输出

```
8```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
16```

## 样例 #3

### 输入

```
9
6 2 3 6 4 6 8 2 5```

### 输出

```
19```

# 题解

## 作者：Ferm_Tawn (赞：7)

显然，要获得最大经验值就是枚举所有有经验值的 $(x,y)$。

首先要解决的是如何快速求出 $l \sim r$ 的 $\gcd$ 值，可以用 $st$ 表来进行实现，单次查询复杂度为 $O(\log n)$ , 没学过的人请转步 P3865,  $st$  表预处理和查询代码如下：


```cpp
void Init(int n){
    lg[1] = 0;
    for(int i = 2 ; i <= n ; i++) lg[i] = lg[i >> 1] + 1;
    for(int i = 1 ; i <= n ; i++) st[i][0] = a[i];
    for(int j = 1 ; j <= lg[n] ; j++){
        for(int i = 1 ; i + (1 << j) - 1 <= n ; i++) st[i][j] = __gcd(st[i + (1 << (j - 1))][j - 1] , st[i][j - 1]);
    }
}
int Find(int l , int r){
    int x = lg[r - l + 1];
    return __gcd(st[l][x] , st[r - (1 << x) + 1][x]);
}

```

接下来就是考虑如何快速算出所有经验值的总和。

这里复杂度是 $O(n \log^2 n)$ 。

这里给出的做法是枚举 $x$ ，二分查找  $y$ 。

先给出一个显而易见的定理：若 $\gcd(a_1,a_2 ,\cdots , a_L)= 3 $ 且 $\gcd(a_1,a_2,\cdots , a_R ) = 3$ ，则对于 $L \le k \le R$ ，$\gcd(a_1,a_2 ,\cdots , a_k)= 3$ 。

若求出 $L \operatorname{and} R$ ，就可以求出以 $x$ 为左端点的 $\operatorname{score_{x,y}}$ 的总和了。

题解中只写出 $\gcd(a_x , a_{x + 1} , \dots , a_y)=3 , \operatorname{len \ mod} 2 = 1$ 的情况，另一种情况本质上是一样的。

对于这种情况，先对 $R$ 进行二分答案，其中二分的是 $R$ 在第几个 $\operatorname{len}$ 长度为奇数的位置上，则 $l = 1 , r = \dfrac{n - x}2 + 1$ , 而 $\operatorname{check}$ 函数就是查找当前 $x \sim \operatorname{mid}$ 的 $\gcd$ ，但是,由于 $\operatorname{mid}$ 表示第几个 $\operatorname{len}$ 长度为奇数的位置，而不是真正的位置，需要计算出 $\operatorname{truemid}= (\operatorname{mid} - 1) \times 2 + x$ ，接下来就是如何对 $l,r$ 进行变化。

- 若 $x \sim \operatorname{mid}$ 的 $\gcd$ 值正好等于 $3$ ，则记录答案，$l=\operatorname{mid} + 1$ 。

- 若 $x \sim \operatorname{mid}$ 的 $\gcd$ 值是 $3$ 的倍数且不等于 $3$ ，则 $l = \operatorname{mid} + 1$ 。

- 否则，$r = \operatorname{mid} - 1$ 。

这样子就能求出 $R$ 了。

其实很多人以为对于 $x \le k \le R$ , 其 $\gcd$ 的值都为 $3$ ，那就大错特错了，其实其 $\gcd$ 的值是 $3$ 的倍数，而不是 $3$ ，举个例子：

```
3
6 6 3

``` 

其中, 对于 $x=1$ 时 , $R=3$ ，但 $k=2$ 时，其 $\gcd$ 值为 $6$ ，不符合要求。

所以说还是要求 $L$ ，不过这也很简单，其实跟求 $R$ 是一样的，就是把范围缩小到了 $x \sim R$ 而已，这里就不过多阐述。

最后求出 $L$ 和 $R$ 后，就要计算答案了，这里可用求和公式计算。

其中首项为 $L - x + 1$ ，尾项为 $R-x + 1$ ，项数为 $\dfrac{R-L} 2 +1$，则局部答案为 $\dfrac{(L+R-2 \times x + 2) \times (\dfrac{R-L} 2 +1)} 2$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int st[600010][30] , a[600010] , lg[600010];
void Init(int n){
    lg[1] = 0;
    for(int i = 2 ; i <= n ; i++) lg[i] = lg[i >> 1] + 1;
    for(int i = 1 ; i <= n ; i++) st[i][0] = a[i];
    for(int j = 1 ; j <= lg[n] ; j++){
        for(int i = 1 ; i + (1 << j) - 1 <= n ; i++) st[i][j] = __gcd(st[i + (1 << (j - 1))][j - 1] , st[i][j - 1]);
    }
}
int Find(int l , int r){
    int x = lg[r - l + 1];
    return __gcd(st[l][x] , st[r - (1 << x) + 1][x]);
}
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    Init(n);
    long long res = 0;
    for(int i = 1 ; i <= n ; i++){
        int l = 1 , r = (n - i) / 2 + 1;
        int best = -1;
        while(l <= r){
			int mid = (l + r) / 2;
			int true_mid = (mid - 1) * 2 + i;
			if(Find(i , true_mid) % 3 != 0) r = mid - 1;
			else if(Find(i , true_mid) % 3 == 0){
				best = max(best , true_mid);
				l = mid + 1;
			}
			else{
				l = mid + 1;
			}
		}
		int best2 = 1e9;
		if(best != -1){
			int l = 1 , r = (best - i) / 2 + 1;
			while(l <= r){
				int mid = (l + r) / 2;
				int true_mid = (mid - 1) * 2 + i;
				if(Find(i , true_mid) == 3){
					best2 = min(best2 , true_mid);
					r = mid - 1;
				}
				else l = mid + 1;
			}
			
		}
		if(!(best == -1 || best2 == 1e9)) res += (long long)(best + best2 - 2 * i + 2) * (long long)((best - best2) / 2 + 1) / 2ll;
		l = 1 , r = (n - i + 1) / 2;
        best = -1;
        while(l <= r){
			int mid = (l + r) / 2;
			int true_mid = mid * 2 + i - 1;
			if(Find(i , true_mid) % 2 != 0) r = mid - 1;
			else if(Find(i , true_mid) % 2 == 0){
				best = max(best , true_mid);
				l = mid + 1;
			}
			else{
				l = mid + 1;
			}
		}
		best2 = 1e9;
		if(best != -1){
			int l = 1 , r = (best - i + 1) / 2;
			while(l <= r){
				int mid = (l + r) / 2;
				int true_mid = mid * 2 + i - 1;
				if(Find(i , true_mid) == 2){
					best2 = min(best2 , true_mid);
					r = mid - 1;
				}
				else l = mid + 1;
			}		
		}
		if(best == -1 || best2 == 1e9) continue;	
		res += (long long)(best + best2 - 2 * i + 2) * (long long)((best - best2) / 2 + 1) / 2ll;
    }
    printf("%lld" , res);
    return 0;
}
```

如有错误，请予以指正。

~~（可能作者脑抽，没想到简单解法，有简单解法可以私信）~~

---

## 作者：Fated_Shadow (赞：4)

## 前言

怎么全是神秘二分？双指针不好吗？
[传送门](https://www.luogu.com.cn/problem/P10403)

## 思路

容易想到维护区间 $\gcd$ 使用 st 表，$O(n\log^2_n)$ 预处理，$O(n\log_n)$ 查询。  
直接暴力查询每个区间 $O(n^2\log_n)$ 过不了一点。  
看见了有人使用二分，但是考虑直接双指针。  
单独考虑 $\gcd=2$ 和 $\gcd=3$ 的情况。观察到固定右端点的话，区间 $\gcd$ 随左端点单调递增（固定左端点的话，区间 $\gcd$ 随右端点单调递减）。  
那么，固定右端点时，使得 $\gcd=2$ 的左端点也是一段区间。当我们右移右端点时，这段合法区间也要跟着右移（$\gcd=3$ 同理）。  
那么直接双指针即可。注意判断合法情况，统计答案时也注意区间长度奇偶问题。  
时间复杂度 $O(n\log^2_n)$，空间复杂度 $O(n\log_n)$。

## Code

**Talk is cheap, show me the code.**


```cpp
// Problem: P10403 「XSOI-R1」跳跃游戏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10403
// Memory Limit: 128 MB
// Time Limit: 750000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace FastIO {
    char gc() {
        static char buf[1 << 24], *is = buf, *it = buf;
        if (is == it) is = buf, it = is + fread(buf, 1, 1 << 24, stdin);
        return is == it ? EOF : *is ++;
    }
    char out[1 << 24];
    int len;
    void flush() {fwrite(out, 1, len, stdout), len = 0;}
    void pc(char x) {if (len == 1 << 24) flush(); out[len ++] = x;}
    struct Flusher {~Flusher() {flush();} } Fls;
    // #define gc() getchar()
    // #define pc(X) putchar(X)
    inline void read(char& ch) {ch = gc();}
    inline void read(char *s) {
        char ch = gc();
        while (ch < 33 || ch > 126) ch = gc();
        for (; ch >= 33 && ch <= 126; ch = gc()) *s++ = ch;
        *s = '\0';
    }
    template <class T>
    inline void read(T &x) {
        char c, flag = 0;
        while ((c = gc()) < '0' || c > '9') flag |= c == '-';
        x = c & 15;
        while ((c = gc()) >= '0' && c <= '9')
        x = (x << 3) + (x << 1) + (c & 15);
        if (flag) x = ~x + 1;
    }
    template <class T, class ...T1>
    inline void read(T &x, T1 &...x1) {read(x), read(x1...);}
    template <class T>
    inline void _put(T x) {if(x > 9) _put(x / 10); pc((x % 10) | 48);}
    template <class T>
    inline void write(T x) {if(x < 0) pc('-'), x = ~x + 1; _put(x);}
    template <> inline void write(char x) {pc(x);}
    template <class T, class ...T1>
    inline void write(T x, T1 ...x1) {write(x), write(x1...);}
}
using FastIO::read;
using FastIO::write;
template <class T>
inline bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}
template <class T>
inline bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}

const int N = 6e5 + 10, K = 20;
int n, a[N], st[N][K], lg[N], ans;
int gcd(int a, int b) {return b ? gcd(b, a % b) : a;}
int query(int l, int r) {
    int k = lg[r - l + 1]; return gcd(st[l][k], st[r - (1 << k) + 1][k]);
}
int f2(int x) {x /= 2; return (x + 1) * x;}
int f3(int x) {return (x + (x % 2 ? 1 : 0)) * ((x + 1) / 2) / 2;}

signed main() {
    // freopen(".in", "r", stdin);
    // freopen(".out", "w", stdout);
    read(n), lg[0] = -1;
    for(int i = 1; i <= n; ++i)
        read(a[i]), st[i][0] = a[i], lg[i] = lg[i >> 1] + 1;
    for(int k = 1; k <= lg[n]; ++k) for(int i = 1; i + (1 << k) - 1 <= n; ++i)
        st[i][k] = gcd(st[i][k - 1], st[i + (1 << (k - 1))][k - 1]);
    for(int i = 1, l = 1, r = 1; i <= n; ++i) {
        if(a[i] & 1) l = i + 1, r = i;
        else {
            while(r < i && query(r + 1, i) <= 2) ++r;
            while(l <= r && query(l, i) < 2) ++l;
            if(r >= l && query(r, i) == 2 && query(l, i) == 2)
                ans += f2(i - l + 1) - f2(i - r); 
        }
    }
    for(int i = 1, l = 1, r = 1; i <= n; ++i) {
        if(a[i] % 3) l = i + 1, r = i;
        else {
            while(r < i && query(r + 1, i) <= 3) ++r;
            while(l <= r && query(l, i) < 3) ++l;
            if(r >= l && query(r, i) == 3 && query(l, i) == 3)
                ans += f3(i - l + 1) - f3(i - r); 
        }
    }
    write(ans);
    return 0;
}
```

## End

实际上本题时间瓶颈在于 st 表，使用二分与使用双指针并无太明显的差距，不过能写更优就是了（实际上还是慢的一批）。如有问题，欢迎指正。

---

## 作者：wangyanjing (赞：1)

PS:记录一下自己的想法。
# Solution
枚举 $x$，可以用 ST 表 和 二分求出 $y$ 的取值范围 $[l,r]$。（其他的题解有讲，这里就不讲了）。

然后我们需要快速求出以下代码的值：

```cpp
int F(int l,int r,int x){
	int ans = 0;
	for(int i = l;i<=r;i+=2) ans += i - x + 1;
	return ans;
}
```

由于公差是 $2$，我们可以想到：把每一项都除 $2$ 向下取整后，公差为 $1$，即：
$$\sum_{i = \lfloor \frac{l}{2} \rfloor} ^ {\lfloor \frac{r}{2} \rfloor} 2i - x+1$$
可以想到：$l,r$ 奇偶性相同，当 $l,r$ 为奇数时，加上 $\lfloor \frac{r}{2} \rfloor - \lfloor \frac{l}{2} \rfloor + 1$ 即可。
# Code 

```cpp
#include<cstdio>
const int N = 6e5+5;
#define ll long long 
inline int gcd(int a,int b){return b?gcd(b,a%b):a;}
int a[N];
struct Sparse_Table{
	int St[N][20],Log2[N];
	inline int Ask(int l,int r){
		if(l>r) return 0;
		int x = Log2[r-l+1];
		return gcd(St[l][x],St[r-(1<<x)+1][x]);
	}
	inline void init(int n){
		for(int i = 1;i<=n;++i) St[i][0] = a[i];
		for(int i = 2;i<=n;++i)	Log2[i] = Log2[i>>1]+1;
		for(int j = 1;j<=Log2[n];++j)
			for(int i = 1;i+(1<<j)-1<=n;++i)
				St[i][j] = gcd(St[i][j-1],St[i+(1<<j-1)][j-1]);
	}
}ST;
inline int Bound_Max(int l,int BoundL,int BoundR,int d){
	int ans = 0;
	while(BoundL <= BoundR){
		int mid = BoundL + BoundR >> 1;
		//printf("%d %d %d\n",BoundL,mid,BoundR);
		if(ST.Ask(l,mid) % d) BoundR = mid - 1;
		else BoundL = mid + 1,ans = mid;
	}
	return ans; 
}
inline int Bound_Min(int l,int BoundL,int BoundR,int d){
	int ans;
		while(BoundL <= BoundR){
		int mid = BoundL + BoundR >> 1;
		//printf("%d %d %d\n",BoundL,mid,BoundR);
		if(ST.Ask(l,mid) > d) BoundL = mid + 1;
		else BoundR = mid - 1,ans = mid;
	}
	return ans; 
}
inline ll Sum(int l,int r,int x){
	ll ans = 0;
	int l2 = l>>1,r2 = r>>1;
	int len = r2-l2+1;
	ans += 1ll * (l2 + r2 - x + 1) * len;
	if(r & 1) ans += len;
	return ans;
}
int main(){
	int n;
	std::scanf("%d",&n);
	for(int i = 1;i<=n;++i) std::scanf("%d",a+i);
	ST.init(n);
	//printf("%d",ST.Ask(1,n)); 
	ll ans = 0;
	for(int l = 1;l<=n;++l){
		int Rmax = Bound_Max(l,l+1,n,2);
		if((Rmax - l + 1) & 1) --Rmax;
		if(ST.Ask(l,Rmax) ^ 2) continue;
		int Rmin = Bound_Min(l,l+1,Rmax,2);
		if((Rmin - l + 1) & 1) ++Rmin;
		ans += Sum(Rmin,Rmax,l);
		//for(int i = Rmin;i<=Rmax;i+=2) printf("%d %d\n",l,i);
	} 
	for(int l = 1;l<=n;++l){
		int Rmax = Bound_Max(l,l,n,3);
		if(!((Rmax - l + 1) & 1)) --Rmax;
		if(ST.Ask(l,Rmax) ^ 3) continue;
		int Rmin = Bound_Min(l,l,Rmax,3);
		if(!((Rmin - l + 1) & 1)) ++Rmin;
		ans += Sum(Rmin,Rmax,l);
		//for(int i = Rmin;i<=Rmax;i+=2) printf("%d %d\n",l,i);
	}
	std::printf("%lld",ans); 
	return 0;
}

```
时间复杂度：$O(n \log n \log V)$。

---

## 作者：Inracle (赞：1)

怎么不优化过不去。

### 分析

我们知道，如果左端点一定，那么区间 $\gcd$ 一定是**单调不升**的，因为 $\gcd (a,b)$ 一定不小于 $\gcd (a,b,c)$。所以可以二分出 $\gcd$ 为某个值的右端点范围。那么这个题就有了一个做法：枚举每个左端点，二分出区间 $\gcd$ 为 $2,3$ 的右端点范围，计算贡献。这时，我们就需要一个能快速求出区间 $\gcd$ 的数据结构：[st 表](https://www.luogu.com.cn/problem/P1890)。

二分出区间 $\gcd$ 为 $2,3$ 的右端点范围后，我们便可以算贡献了。**对于固定左端点，区间 $\gcd$ 为 $2$ 或 $3$ 时，贡献显然都是一个公差为 $2$ 的等差数列**。先通过右端点范围确定等差数列首末项，就可确定项数及等差数列和了。举个例子：左端点为 $2$，区间 $\gcd$ 为 $2$，右端点范围为 $9 \sim 14$，等差数列首项即是 $9$，末项 $13$。则等差数列和为 $(9+13) \times [(13-9) \div 2 + 1] \div 2 = 33$。

### ~~卡常~~ 优化

第一，能不开 long long 就不开；第二，可以利用前面二分的答案。例如，区间 $\gcd$ 为 $3$ 的范围与区间 $\gcd$ 为 $2$ 的范围是相连的，区间 $\gcd$ 为 $3$ 的范围的末尾即为区间 $\gcd$ 为 $2$ 的范围的开头减一，这样就可以由四次减为三次二分；还可以通过前面的二分缩小本次的二分范围。

### 代码

如下。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,rp,stdin),p1==p2)?EOF:*p1++)

using namespace std;
const int N=6e5+10;
const int rp=1e6+10;

int n,p[N],dp[20][N];
ll ans;
char buf[rp],*p1=buf,*p2=buf;

inline int read() 
{
	int x=0,f=1; char c=0;
    while(!isdigit(c)){if(c=='-') f=-1; c=gc();}
    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=gc();
    return x*f;
}//快读

inline int get(int l,int r)
{
	int k=log2(r-l+1);
	return __gcd(dp[k][l],dp[k][r-(1<<k)+1]);
}//st 表查询

inline void rmq()
{
	for(int i=1;i<=n;++i) dp[0][i]=p[i];
	for(int i=1;i<20;++i)
		for(int j=1;j<=n-(1<<i)+1;++j)
			dp[i][j]=__gcd(dp[i-1][j],dp[i-1][j+(1<<(i-1))]);
}//st 表预处理

inline int ef(int x,int r,int v)
{
	int L=x,R=r,ans=r+1;
	while(L<=R)
	{
		int mi=(L+R)>>1;
		if(get(x,mi)<=v) R=mi-1,ans=mi;
		else L=mi+1;
	}
	return ans;
}//二分以 x 为左端点最近的区间 gcd 为 v 的右端点

signed main()
{
	cin.tie(0)->sync_with_stdio(0);
	n=read(); int l2,r2,l3,r3;
    //gcd 为 2 的右端点范围和 gcd 为 3 的右端点范围
	for(int i=1;i<=n;++i) p[i]=read();
	rmq();
	for(int i=1;i<=n;++i)
	{
		r2=ef(i,n,1)-1; l2=ef(i,r2,2); 
		r3=l2-1; l3=ef(i,r3,3); //r3 即利用上次二分
        //二分函数中的 r 缩小了二分范围
		l2-=i-1; r2-=i-1; l3-=i-1; r3-=i-1;//转化为区间长度
		if(l2&1) ++l2; if(r2&1) --r2;
		if(!(l3&1)) ++l3; if(!(r3&1)) --r3;//找到等差数列首末项
		ans+=(r2+l2)*1ll*(((r2-l2)>>1)+1)>>1;
		ans+=(r3+l3)*1ll*(((r3-l3)>>1)+1)>>1;//公式
        //把 /2 改为了 >>1
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Wei_Han (赞：0)

因为不符合任何一个条件的跳跃价值为 $0$，所以我们可以跳跃至任意位置，题意即求 $\sum_{i=1}^{n} \sum_{j=i}^{n} score_{i,j}$。

由于 $\gcd$ 运算有结合律，所以我们可以用 st 表来维护区间 $\gcd$ 的值，预处理 $O(n\log n)$，查询 $O(1)$。

因为两个得分条件不冲突，所以我们可以分开来考虑。假设我们固定一个端点 $i$，区间 $\gcd$ 是单调不降的，因此我们可以二分找到 $l$ 和 $r$，使对于 $l \leq j \leq r$，都有 $\gcd(a_i,a_{i+1},...,a_j) = k$，$k$ 为这个条件中需要的值，即 $2$ 或 $3$，统计答案时注意还有区间长度限制，等差数列直接算就好了，复杂度 $O(n\log n)$。

注意本题时间限制。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define pr putchar('\n')
#define fi first
#define se second
#define pp putchar(' ')
#define pii pair<ll,ll>
#define pdi pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(register ll i = a ; i <= b ; ++ i )
#define Fo(a,i,b) for(register ll i = a ; i >= b ; -- i )
#define pb push_back
//#pragma GCC optimize(2)
using namespace std;
typedef int ll;
// typedef long long ll;
//typedef __int128 ll;
typedef double db;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
const ll N=1e6+5,M=2e4+5,mod=1e9+7;
ll n,a[N],st[N][20];
long long sum;
inline ll ask(ll l,ll r){
	ll lg=log2(r-l+1);
	return __gcd(st[l][lg],st[r-(1<<lg)+1][lg]);
}
inline void check3(ll i)
{
	ll l=i,r=n;//3 5   3 6
	while(l<r){
		ll mid=l+r>>1;
		if(ask(i,mid)>3) l=mid+1;
		else r=mid;
	}
	ll beg=l;if(ask(i,beg)!=3) return;
	l=beg,r=n;
	while(l<r)
	{
		ll mid=l+r+1>>1;
		if(ask(i,mid)==3) l=mid;
		else r=mid-1;
	}
	ll end=l;if(ask(i,end)!=3) return; 
	ll beg1=0,end1=0;
	if((beg-i+1)&1) beg1=beg-i+1;
	else if(end!=beg) beg1=beg-i+2;
	else if(end==beg) return;
	if((end-i+1)&1) end1=end-i+1;
	else end1=end-i;
	sum+=1ll*(beg1+end1)*((end1-beg1)/2ll+1ll)/2ll;
}
inline void check2(ll i)
{
	if(i==n) return;
	ll l=i,r=n;
	while(l<r){
		ll mid=l+r>>1;
		if(ask(i,mid)>2) l=mid+1;
		else r=mid; 
	}
	ll beg=l;if(ask(i,beg)!=2) return;
	l=beg,r=n;
	while(l<r)
	{
		ll mid=l+r+1>>1;
		if(ask(i,mid)==2) l=mid;
		else r=mid-1;
	}
	ll end=l;if(ask(i,end)!=2) return;
	ll beg1=0,end1=0;
	if((beg-i)&1) beg1=beg-i+1;
	else if(beg!=end) beg1=beg-i+2;
	else if(beg==end) return;
	if((end-i)&1) end1=end-i+1;
	else end1=end-i;
	sum=sum+1ll*(beg1+end1)*((end1-beg1)/2ll+1ll)/2ll;
}
signed main(){
	read(n);fo(1,i,n) read(a[i]),st[i][0]=a[i];
	fo(1,j,20) fo(1,i,n) if(i+(1<<j)-1<=n) st[i][j]=__gcd(st[i][j-1],st[i+(1<<j-1)][j-1]);
	fo(1,i,n) check3(i),check2(i);
	cout << sum << endl;
    return 0;
}
``````

---

## 作者：封禁用户 (赞：0)

### 思路
首先，我们需要一个数据结构来维护区间的最大公因数的值，易想到用 st 表维护。

预处理区间最大公因数后，考虑如何求解。   
首先考虑枚举 $x,y$，时间复杂度为 $\mathcal{O\left( n^2\log{n}\right)}$，期望得分 $50$。考虑优化。

首先，有一个简单的结论。若 $\gcd({a_{x}},{a_{x+1}}{a_{x+2}},...,a_L)=n,\gcd({a_{x}},{a_{x+1}},{a_{x+2}},...,a_R)=n$，则对于所有的 $i(L<i<R)$，$\gcd({a_{x}},{a_{x+1}},{a_{x+2}},...,a_i)=n$ 一定成立。可以考虑枚举 $x$，二分答案出 $L,R$，即可求出 $\sum_{y=x}^{n}score_{x,y}$ 的值。

对于 $\gcd({a_{x}},{a_{x+1}},{a_{x+2}},...,a_y)=2,len   \bmod2=0$ 的情况，思考如何二分答案 $R$。我们需要三个变量 $l,r,mid$，用来进行二分。$R$ 为满足 $len \bmod2=0$ 的位置。  

需要注意 $mid$ 维护的是满足 $len \bmod2=0$ 的位置，所以，查询区间 gcd 时，查找的区间是 $\left[ {x,x+mid \times 2-1}\right]$，不是 $\left[ {x,mid}\right]$。令查询结果为 $q$。若 $q\bmod2 \neq 0$，$r=mid-1$。否则，若 $q=2$，$R=\max(R,x+mid \times 2-1),l=mid+1$。否则，$l=mid+1$。二分出 $L,R$ 后，即可计算答案。由题可知：
$$
\begin{aligned}
{}&\sum_{y=x}^{n}score_{x,y}&\\
=&\sum_{y=L}^{R}len(len \bmod2=0)&\\
=&(L-x+1+R-x+1)\times((R-L)\div2+1)\div2&\\
=&(L+R-2x+2)\times((R-L)\div2+1)\div2
\end{aligned}
$$

### AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=6e5+7;
int n,a[N],lg[N],f[N][20],ans;

int gcd(int x,int y){
	if(x%y==0)
		return y;
	return gcd(y,x%y);
}

int query(int l,int r){
	int k=lg[r-l+1];
	return gcd(f[l][k],f[r-(1<<k)+1][k]);
}

signed main(){
	scanf("%lld",&n);
	lg[1]=0;
	for(int i=2;i<=n;++i)
		lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;++i)
		scanf("%lld",&f[i][0]);
	for(int j=1;j<=lg[n];++j)
		for(int i=1;i<=n-(1<<j)+1;++i)
			f[i][j]=gcd(f[i][j-1],f[i+(1<<(j-1))][j-1]);
	for(int i=1;i<=n;++i){
		int l=1,r=(n-i)/2+1;
		int R=-1,L=1e9;
		while(l<=r){
			int mid=(l+r)>>1;
			int real_mid=(mid-1)*2+i;
			int q=query(i,real_mid);
			if(q%3!=0)
				r=mid-1;
			else if(q==3){
				R=max(R,real_mid);
				l=mid+1;
			}
			else l=mid+1;
		}
		if(~R){
			int l=1,r=(R-i+1)/2+1;
			while(l<=r){
				int mid=(l+r)>>1;
				int real_mid=(mid-1)*2+i;
				int q=query(i,real_mid);
				if(q==3){
					L=min(L,real_mid);
					r=mid-1;
				}
				else l=mid+1;
			}
		}
		if(~R&&L!=1e9)
			ans+=(L-i+1+R-i+1)*((R-L)/2+1)/2;
		l=1,r=(n-i+1)/2;
		R=-1,L=1e9;
		while(l<=r){
			int mid=(l+r)>>1;
			int real_mid=mid*2+i-1;
			int q=query(i,real_mid);
			if(q%2!=0)
				r=mid-1;
			else if(q==2){
				R=max(R,real_mid);
				l=mid+1;
			}
			else l=mid+1;
		}
		if(~R){
			int l=1,r=(R-i+1)/2;
			while(l<=r){
				int mid=(l+r)>>1;
				int real_mid=mid*2+i-1;
				int q=query(i,real_mid);
				if(q==2){
					L=min(L,real_mid);
					r=mid-1;
				}
				else l=mid+1;
			}
		}
		if(~R&&L!=1e9)
			ans+=(L-i+1+R-i+1)*((R-L)/2+1)/2;
	}
	cout<<ans;
}
```

---


# [蓝桥杯 2024 省 B] 拔河

## 题目描述

小明是学校里的一名老师，他带的班级共有 $n$ 名同学，第 $i$ 名同学力量值为 $a_i$。在闲暇之余，小明决定在班级里组织一场拔河比赛。

为了保证比赛的双方实力尽可能相近，需要在这 $n$ 名同学中挑选出两个队伍，队伍内的同学编号连续 $\{{a_{l_1}}, a_{l_1 + 1}, \dots, a_{r_1 - 1}, a_{r_1}\}$ 和 $\{{a_{l_2}}, a_{l_2 + 1}, \dots, a_{r_2 - 1}, a_{r_2}\}$，其中 $l_1 \le r_1<l_2 \le r_2$。

两个队伍的人数不必相同，但是需要让队伍内的同学们的力量值之和尽可能相近。请计算出力量值之和差距最小的挑选队伍的方式。

## 说明/提示

### 样例 1 解释

其中一种最优选择方式：

队伍 1：$\{a_1, a_2, a_3\}$，队伍 2：$\{a_4, a_5\}$，力量值和分别为 $10 + 9 + 8 = 27$，$12 + 14 = 26$，差距为 $|27 − 26| = 1$。

### 数据规模与约定

- 对 $20\%$ 的数据，$n \leq 50$。
- 对全部的测试数据，保证 $1 \leq n \leq 10^3$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
10 9 8 12 14
```

### 输出

```
1```

# 题解

## 作者：GXZJQ (赞：33)

# P10385 [蓝桥杯 2024 省 B] 拔河 题解


- 更新于 $2024$ 年 $5$ 月 $10$ 日：修改了第二份代码中的小错误，感谢 MyNameIsikun 的指正和 hack 数据。

- 更新于 $2024$ 年 $5$ 月 $12$ 日：修改了题目链接的指向，感谢 wzj0829 的提醒。

[题目链接](https://www.luogu.com.cn/problem/P10429)

## 题目大意

给定一个长度为 $n$ 的序列，求出两个子序列 $[l_1,r_1]$ 和 $[l_2,r_2]$ 中数字和的差值的最小值，保证 $l_1 \le r_1\le l_2 \le r_2$。

## 题目分析

### 思路一：暴力 $\mathcal {O}(n^5)$

使用循环，暴力枚举区间的左右端点并进行求和，最后比较差值。由于枚举端点的时间复杂度为 $\mathcal {O}(n^4)$，求和的时间复杂度为 $\mathcal {O}(n)$，所以最终时间复杂度为 $\mathcal {O}(n^5)$，无法通过本题。

### 思路二：暴力+前缀和 $\mathcal {O}(n^4)$

同思路一，暴力枚举区间的左右端点并进行求和，最后比较差值。但我们使用前缀和维护序列和的时候可以优化掉暴力求和的 $\mathcal {O}(n)$，所以最终时间复杂度为 $\mathcal {O}(n^4)$，无法通过本题。

### 思路三：双指针 $\mathcal {O}(n^3)$

- 枚举 $r_1,l_2$，定义双指针 $i,j$，分别从 $r_1$ 和 $l_2$，分别从左边和右边扫描整个序列；

- 枚举 $l_1,r_2$，定义双指针 $i,j$，向中间扫描整个序列。

使用双指针的总体复杂度为 $\mathcal {O}(n^3)$，理论上可以通过，但还不够优秀。

### 思路四：枚举单个区间 $\mathcal {O}(n^2 \log n)$

双指针算法仅仅是理论上可以通过，但可能会出现一些小的情况造成超时。这时我们就要用一种时间复杂度更为优秀的算法。

我们尝试只用 $\mathcal {O}(n^2)$ 枚举第一个区间 $[l_1,r_1]$，然后回归题目本身，它要求数字和差值尽可能小，所以要在右区间中找到和左区间的和最相近的值，不妨使用一个 `multiset` 进行维护，记其为 $S$。

开始的时候，我们把所有可能的右区间的和都加入 $S$ 中去，接下来用 $r_1$ 枚举左区间，当 $r_1=k$ 时，在 $S$ 中删除以 $k$ 为左端点的区间和。

## 细节和优化

- 用前缀和维护整个序列的数字和；

- 使用 `lower_bound` 二分查找第一个大于等于 $k$ 的位置；

- 注意 `multiset` 的维护，不可以直接使用 `erase`，而是要对其传入一个值为 $k$ 的元素的迭代器，有指向性地删除。

## 参考代码

### 双指针 $\mathcal {O}(n^3)$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e3 + 10;
int n, a[maxn];
int ans = INT_MAX;
int minnum(int a, long long b) {
	return a > b ? b : a;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++) {
			int l = i - 1, r = j + 1;
			long long suml = a[i], sumr = a[j];
			ans = minnum(ans, abs(suml - sumr));
			while (l >= 1 && r <= n) {
				if (suml > sumr) sumr += a[r++];
				else suml += a[l--];
				ans = minnum(ans, abs(suml - sumr));
			}
			while (l >= 1) {
				suml += a[l--];
				ans = minnum(ans, abs(suml - sumr));
			}
			while (r <= n) {
				sumr += a[r++];
				ans = minnum(ans, abs(suml - sumr));
			}
		}
	cout << ans << endl;
	return 0;
}
```
[提交记录](https://www.luogu.com.cn/record/157479751)

### 枚举单个区间 $\mathcal {O}(n^2 \log n)$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e3 + 10;
int n;
long long a[maxn], ans = 1e9;
multiset<long long> S;
long long minnum(long long a, long long b) {
	return a > b ? b : a;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i], a[i] = a[i - 1] + a[i];//前缀和维护
	for (int i = 1; i <= n; i++) for (int j = i; j <= n; j++) S.insert(a[j] - a[i - 1]);//全部插入
	for (int i = 1; i < n; i++) {
		for (int j = i; j <= n; j++) {
			auto p = S.find(a[j] - a[i - 1]);
			S.erase(p);//删除
		}
		for (int j = 1; j <= i; j++) {
			auto k = a[i] - a[j - 1];
			auto p = S.lower_bound(k);
			if (p != S.end()) ans = minnum(ans, abs(*p - k));
			if (p != S.begin()) p --, ans = minnum(ans, abs(*p - k));
		}
	}
	cout << ans;
	return 0;
}
```
[提交记录](https://www.luogu.com.cn/record/158578666)

---

## 作者：一扶苏一 (赞：21)

### Description

给定一个序列，要求从中找到两个不相交的子段，使得两个子段元素和的差值尽可能小。

序列长度不超过 $10^3$。

### Analysis

从大到小枚举 $r_1$。$r_1$ 右侧的所有区间都是合法的第二个子段。用一个数据结构维护这些区间和。

再枚举 $l_1$。对于一个 $[l_1, r_1]$ 的区间和 $\mathrm {sum}$，要在数据结构里找到离 $\mathrm {sum}$ 最近的元素。

这是一个插入、lower_bound 问题，可以用 set 维护。

时间复杂度：每次右端点进行 $r_1 \to r_1 - 1$ 移动时，把所有以 $r_1$ 为右端点的区间加入 set。一共有 $O(n^2)$ 个区间。插入的复杂度是 $O(n^2 \log n)$；对于一个 $[l_1, r_1]$ 的区间，要在 set 里查询 lower_bound 找到不小于 $\mathrm {sum}$ 的最小数，该位置前面的是小于 $\mathrm {sum}$ 的最大数，一次查询是 $O(\log n)$ 的，共 $O(n^2)$ 次查询，复杂度也是 $O(n^2 \log n)$。于是总时间复杂度 $O(n^2 \log n)$。

### Code

```cpp
#include <bits/stdc++.h> 

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  using ll = long long;
  int n;
  std::cin >> n;
  std::vector<int> a(n);
  for (auto &i : a) std::cin >> i;
  std::set<ll> s;
  ll ans = LONG_LONG_MAX;
  for (int r = n - 2; r >= 0; --r) {
    ll sum = 0;
    for (int l = r + 1; l < n; ++l) s.insert(sum += a[l]);
    sum = 0;
    for (int l = r; l >= 0; --l) {
      sum += a[l];
      auto p = s.lower_bound(sum);
      if (p != s.end()) {
        ans = std::min(ans, *p - sum);
      }
      if (p != s.begin()) {
        ans = std::min(ans, sum - *std::prev(p));
      }
    }
  }
  std::cout << ans  << '\n';
}
```

---

## 作者：飘然归隐 (赞：10)

前缀和的题，难点在于怎么在合适的时间复杂度内解决。暴力显然不行。用前缀和来记录，从而枚举出每一个区间，用对组来标记一下每个区间的长度和区间头，再对这些区间进行排序。因为两个区间不能连在一起，所以要用区间头来判断。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
ll n;
ll a[1005];
ll sum[1005];
vector<pair<ll,int> > v;
ll ans=1e18;//初始化要开大一点 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];//前缀和 
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)
		{
			v.push_back(make_pair(sum[j]-sum[i-1],i));//标记这个区间的头 i 
		}
		
	}
	sort(v.begin(),v.end());//从小到大排序 
	for(int i=0;i<v.size()-1;i++)
	{
		if(v[i].second!=v[i+1].second)//两个区间不能连在一起 所以要判断一下 
		{
			ans=min(ans,v[i+1].first-v[i].first);
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：RandomLife (赞：9)

[传送门](https://www.luogu.com.cn/problem/P10429)

## 题意

求两个不重叠的区间 $[l1,r1]$ 和 $[l2,r2]$，使得两个区间和的差最小。

## 题解

既然要求差最小，那么很容易想到 `lower_bound`。

于是，我们先开一个 `set`，然后从尾到头枚举 $r1$。然后：

- 首先，将所有以 $r1+1$ 为左端点的区间和扔进 `set` 里。

- 然后，我们对于所有以 $r1$ 为右端点的区间，将它的和在 `set` 里求一个 `lower_bound`，就可以得到最接近当前区间且总和大于等于该区间的和。将索引减一就是小于且最接近的。

- 每一步用两种方案更新答案。

然后就没有了。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int n;
long long a[N],ans=1e18;
set<long long>s;
int main(){
	freopen("a.in","r",stdin);
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=n-1;i;--i){
		long long sum=0;
		for(int j=i+1;j<=n;++j)sum+=a[j],s.insert(sum);
		sum=0;
		for(int j=i;j;--j){
			sum+=a[j];
			auto p=s.lower_bound(sum);
			if(p!=s.end())ans=min(ans,*p-sum);
			if(p!=s.begin())ans=min(ans,sum-*prev(p));
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Frozen_Ladybug (赞：4)

### 题目大意

给一个长度为 $n$ 的数组，确定两个不相交的区间，使得区间和的差值尽量小。

### 解法

我们记数列的 $x$ 至 $y$ 项和为 $s_{[x,y]}$。

则有 $l_1\le r_1<l_2\le r_2$，取 $\min\{s_{[l_1,r_1]}-s_{[l_2,r_2]}\}$。

修改一下变量就有对任意 $1\le l_1\le r_1<l_2\le r_2\le n$，要求 $\min\{s_{[l_1,r_1]}-s_{[l_2,r_2]}\}$。

我们可以用 ```set``` 存下来后面那个区间，然后前面那个区间按 $R_1$ 递增的方式枚举区间，同时 $R_1$ 扫的时候边删动态维护 ```set```。

对于每个区间，在 ```set``` 里面二分找到最近的数（也就是大于等于 $x$ 的数和它前面那个数）更新答案。复杂度为 $O(n^2\log n)$。

### 代码

```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int a[1005],n;
ll s[1005],res=LONG_LONG_MAX;
int main(){
    multiset<ll> S;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),s[i]=s[i-1]+a[i];
	for(int l=1;l<=n;l++)
		for(int r=l+1;r<=n;r++) S.insert(s[r]-s[l]);
	for(int r=1;r<n;r++){
		for(int l=0;l<r;l++){
			ll val=s[r]-s[l];
			auto it=S.lower_bound(val);
			if(it!=S.end()){
				ll ans=abs(*it-val);
				res=min(res,ans);
			}
			if(it!=S.begin()){
				it--;
				ll ans=abs(*it-val);
				res=min(res,ans);
			}
		}
		for(int r2=r+1;r2<=n;r2++) S.erase(S.find(s[r2]-s[r]));
	}
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：TruchyR (赞：4)

妙妙题。  
考虑先枚举 $l_2$ 再枚举 $r_2$，思考如何确定最小的差值。  
我们发现，$l_1\leq r_1<l_2$，所以可以处理出所有的满足条件的第一个队伍的力量值之和，然后二分即可，这里使用 set 会更加方便。    
从小到大枚举 $l_2$，每次枚举后再把新的满足条件的力量值之和（右端点为 $l_2$）加入即可。    
由于两队力量值之和的大小关系不确定，代码中正反各做了一次。    
时间复杂度 $O(n^2\log n)$，代码如下：    
```cpp
#include<bits/stdc++.h>
#define int long long
#define MX 1005
using namespace std;
int read();
int n,res=1e9,a[MX],b[MX];
void solve(){
	set<int> s;
	s.insert(a[1]);
	for(int i=2;i<=n;i++){//枚举 l[2]
		int sm=0;
		for(int j=i;j<=n;j++){//枚举 r[2] 
			sm+=a[j];
			int mn=*s.lower_bound(sm)-sm;
			//这里加这个判断的原因：如果这个数比 set 内所有的数都大则会导致出错
			if(mn>=0) res=min(res,mn);
		}sm=0;
		for(int j=i;j>=1;j--){//加入新的满足条件的力量值之和 
			sm+=a[j];
			s.insert(sm);
		}
	}
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++) a[i]=b[n-i+1]=read();
	solve();memcpy(a,b,sizeof(b));solve();
	printf("%lld\n",res);
	return 0;
}
int read(){
	int Ca=0;char Cr=' ';int Cf=1;
	while(Cr<'0' || Cr>'9'){Cr=getchar();if(Cr=='-'){Cf=-1;}}
	while(Cr>='0' && Cr<='9'){Ca=Ca*10+Cr-48;Cr=getchar();}
	return Ca*Cf;
}
```

---

## 作者：hgckythgcfhk (赞：4)

题意相当于选两个不交的区间使得区间的和的差最小，一开始没想出来，然后看了一眼数据范围突然想到了 $O(n^2\log n^2)$ 的做法，我们可以直接枚举一个区间，然后从这个区间的后面所有区间里面找一个和它最接近的，这个最接近的一定是排序后第一个比它大的或者第一个比它大的前一个（这个东西的意义可能是最后一个比它小的，也可能是和它相等的），发现可以用 `multiset` 来维护，这个东西其实就是一个不去重的 `set` 用的不多，但最好知道有这个东西，由于本人太菜，所以没想到 $O(n\log n)$ 的做法，但感觉好像有。

具体说的不清楚的地方看程序能看明白。

为防止火车头导致无法过审删除了大部分用不到的宏定义，可能会多删，但不影响阅读。
```cpp
#include <bits/stdc++.h>
#define rg register
#define cit const rg unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0),freopen("1.in","r",stdin),freopen("1.out","w",stdout)
#define int rg unsigned
#define ll long long
#define ull unsigned ll
#define sca(a) for(int $=0;$<n;cin>>a[++$])
//#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
inline ll max(const rg ll a,const rg ll b){return a>b?a:b;}
//inline ll min(const rg ll a,const rg ll b){return a<b?a:b;}
using namespace std;constexpr unsigned N=1e5+1;inline ull dis(cit ll a,cit ll b){return a>b?a-b:b-a;}
multiset<ull>s;ull a[N];
signed main(){open;int n;cin>>n;sca(a);
	for(int i=2;i<=n;++i)a[i]+=a[i-1];int ll ans=~0;
	for(int l=2;l<=n;++l)for(int r=l;r<=n;++r)
	s.emplace(a[r]-a[l-1]);for(int r=1;r<n;++r){
		for(int l=r;l;--l){cit ll sum=a[r]-a[l-1];
			auto it=s.lower_bound(sum);
			ans=min(dis(*it,sum),ans);--it;
			ans=min(dis(*it,sum),ans);}
		for(int i=r+1;i<=n;++i)s.erase(s.find(a[i]-a[r]));
	}cout<<ans;
}
```

---


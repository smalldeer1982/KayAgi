# 矩形

## 题目描述

给出一个 $n \times n$ 的矩阵，矩阵中，有些格子被染成白色，有些格子被染成黑色，现要求矩阵中白色**矩形**的数量。

## 说明/提示

对于$30\%$的数据，$n ≤ 50$；

对于$100\%$的数据，$n ≤ 150$；


## 样例 #1

### 输入

```
4
WWBW
BBWB
WBWW
WBWB```

### 输出

```
15```

# 题解

## 作者：3493441984zz (赞：78)

# 本蒟蒻只会$n^3$

唉，还是太弱了，靠刷点水题过日子


------------
# 思路：

我们枚举出矩形左下角的点，坐标为$(i,j)$，并且枚举这个点向右的长度$k$，那么以$(i,j)$为左下角，宽度为$k-j+1$的矩形自然就是能向上扩展的高度最小值了，光说可能不太清楚，下面模拟一下（有图哦$qwq$）

我们以下面为例子，粗略讲一下（不会全部模拟）

样例：

$4$

$WWWW$

$WWBW$

$WWWW$

$WWWW$

那么假设我们枚举$i,j$分别为$4,1$，也就是第四行第一列，那么我们向右枚举$k$

当$k=1$时，我们求出以$i,j$为左下角，宽度为$k-j+1$也就是$1$的矩形有多少个，我们可以看到有$4$个，分别是:

![](https://i.loli.net/2019/02/12/5c62baaac721d.png)
![](https://i.loli.net/2019/02/12/5c62baee7c52f.png)
![](https://i.loli.net/2019/02/12/5c62bb6bbdcf1.png)
![](https://i.loli.net/2019/02/12/5c62bba2a8f1e.png)

我们其实可以发现就是能向上扩展的高度个矩形

当$k=2$时,我们发现以$i,j$为左下角，宽度为$2$的矩形也有$4$个，分别为：

![](https://i.loli.net/2019/02/12/5c62bc64a2f0b.png)
![](https://i.loli.net/2019/02/12/5c62bc88ce1fb.png)
![](https://i.loli.net/2019/02/12/5c62bca0b5c98.png)
![](https://i.loli.net/2019/02/12/5c62bcbbbd140.png)

当$k=3$时，我们发现以$i,j$为左下角，宽度为$3$的矩形有$2$个，分别为：

![](https://i.loli.net/2019/02/12/5c62bd1f2eb35.png)
![](https://i.loli.net/2019/02/12/5c62bd37ac4c3.png)

当$k=4$时，我们发现以$i,j$为左下角，宽度为$4$的矩形有$2$个，分别为：

![](https://i.loli.net/2019/02/12/5c62bd9e0c7ac.png)
![](https://i.loli.net/2019/02/12/5c62bdbb22180.png)

那么到这里我们就枚举出了左下角为$4,1$的所有矩形

而且我们可以发现，矩形个数就是能向上扩展的高度

那么我们会枚举$i,j$，让每一个点作为矩形左下角，同时枚举宽度，一层一层下来，最后就是不遗漏的所有矩形个数，具体证明就省略了，自己想想就知道了

时间复杂度$O(n^3)$

下面是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 157
using namespace std;
int n,now,ans;
int high[N];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			char in;
			scanf(" %c",&in);
			if(in=='W')
				++high[j];
			else
				high[j]=0;
		}
		for(int j=1;j<=n;++j)
		{
			now=high[j];
			for(int k=j;k<=n;++k)
			{
				if(!high[k])
					break;
				now=min(now,high[k]);
				ans+=now;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
~~~

---

## 作者：tong_xz (赞：34)

## n^2的复杂度

翻了翻题解，发现没有n^2的算法

在n^3的基础上，加单调栈维护当前点往右第一个比它小的数的位置即可QwQ

代码:
```cpp
#include<cstdio>
#define N 155
using namespace std;
int min(int a,int b){
    return a<b?a:b;
}
char get_a_char(){
    char c=getchar();
    while(c!='W'&&c!='B'){
        c=getchar();
    }
    return c;
}
int b[N][N],dp[N][N];
int s[N];
int e;
int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j){
            b[i][j]=(get_a_char()=='W');
        }
    }
    for(int i=n-1;i>=0;--i){
        for(int j=0;j<n;++j){
            if(b[i][j]){
                b[i][j]+=b[i+1][j];
            }
        }
    }
    int ans=0;
	s[0]=n;
    for(int i=0;i<n;++i){
		e=0;
        for(int j=n-1;j>=0;--j){
			while(b[i][s[e]]>b[i][j]){
				--e;
			}
			dp[i][j]=b[i][j]*(s[e]-j)+dp[i][s[e]];
			ans+=dp[i][j];
			s[++e]=j;
        }
    }
    printf("%d",ans);
}
```

其实这道题数据比较水，连n^4的算法都能过。。。

---

## 作者：_Atyou (赞：15)

## 暴力枚举

题意就是找有多少个矩形

很容易想复杂了 但是如果矩形固定了左下角向右上方拓展着去找，即不会重复，也使思维变得简单了很多

每行开始时，预处理这一行每一列的高度，方便之后的统计，
然后确认往右拓展，能取的高度是拓展到的高度中的最小值，然后会发现以i, j为左下角宽度为k-j+1的矩形数量在数值上等于高度，累加后就是答案了

### 时间复杂度：O(n^3)


```cpp
#include <bits/stdc++.h>
using namespace std;

namespace atyou { 

const int N = 150 + 5;
char c[N][N];
int n, cnt[N], ans; //cnt存储当前行各列的最高高度 

int main() {
    ios::sync_with_stdio(false);
    cin>>n;
    for (register int i=1; i<=n; i++)
        for (register int j=1; j<=n; j++) cin>>c[i][j];
    for (register int i=1; i<=n; i++) { //按行处理 
        for (register int j=1; j<=n; j++)
            if (c[i][j] == 'B') cnt[j]=0;  //遇B清零 
            else cnt[j]++; //高度累加 
        for (register int j=1; j<=n; j++) {
            int high=cnt[j];  
            for (register int k=j; k<=n; k++) {
                if (!cnt[k]) break; //遇到B 矩形不能在向右拓展，跳出循环 
                high=min(high, cnt[k]); //高度当然取小的 
                ans+=high; //以i j为左下角 宽为k-j+1的矩形自然是高度个 
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}

}

int main() {
    atyou::main();
    return 0;
}

```

---

## 作者：_Ayanami_ (赞：11)

### 数据很小

### 直接暴力枚举
四重循环前两重枚举左上角端点，后两重枚举矩形大小

来随便整一组数据

![](https://cdn.luogu.com.cn/upload/image_hosting/wq5mlxmf.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

以(1,1)为左上端点为例

![](https://cdn.luogu.com.cn/upload/image_hosting/f6566187.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们可以发现宽度为x+1的矩形的最大长度<=宽度为x的矩形的最大长度

同理长度为x+1的矩形的最大宽度<=长度为x的矩形的最大宽度

所以我们在枚举矩形长宽时每次以当前最大长宽更新长宽上限

代码如下
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,e,s,ans;
bool z[201][201]={0};//白格为1黑格为0，一开始先全记为黑
char c;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>c;
			if(c=='W')
			{
				z[i][j]=1;//记录白格
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)//枚举左上端点坐标
		{
			if(z[i][j])//若当前端点为白
			{
				e=s=1919810;//初始化长宽最大值
				for(int k=0;i+k<=n&&k<e;k++)
				{
					if(!z[i+k][j])//碰到黑格
					{
						e=k;//更新宽度上限
						break;
					}
					for(int v=0;j+v<=n&&v<s;v++)
					{
						if(!z[i+k][j+v])//碰到黑格
						{
							s=v;//更新长度上限
							break;
						}
						ans++;//当前矩形存在，ans++
					}
				}
			}
		}
	}
	cout<<ans;
	return 0;//over
}
```


---

## 作者：衡屿睿 (赞：9)

其实这道题最多值提高-好吗！

来个前缀和题解。

降维还是老套路，只是把B变成1，W变成0，暴力出所有和为0矩形即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int s[201][201]={0},a[201][201];
int main()
{
    int n,sum=0;
    char f;
    cin>>n;
    for(int i=1;i<=n;++i)
    {
     int ans=0;
      for(int j=1;j<=n;++j)
       {
         cin>>f;
         if(f=='W')a[i][j]=0;
         else a[i][j]=1;
         ans+=a[i][j];
         s[i][j]=s[i-1][j]+ans;
       } 
    }
    for(int i=1;i<=n;++i)
     for(int i1=i;i1<=n;++i1)
      for(int j=1;j<=n;++j)
       for(int j1=j;j1<=n;++j1)
        if(s[i1][j1]+s[i-1][j-1]-s[i-1][j1]-s[i1][j-1]==0)sum++;//四重循环没爆，感谢数据
    cout<<sum;
    return 0;
} 
```
不理解四重循环的，见下：
二维前缀和——

对于一个矩阵a，我们能在O（1）时间内求出子矩阵[x1~x2][y1~y2]的和。

设sum[i][j]为子矩阵[1~i][1~j]的和。则由容斥原理得：

sum[0][j]=sum[i][0]=0

a[x1~x2][y1~y2]=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1]

四重循环相当于是在枚举x1x2y1y2。


---

## 作者：Wider (赞：9)

这是一个n^3算法

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,ans=0;
bool map[200][200][200];
char a[200][200];
int main(){
    cin>>n;
    memset(map,0,sizeof(map));
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++){
        cin>>a[i][j];
        if(a[i][j]=='W')map[i][j][j]=1;
    }
    for(int k=1;k<=n;k++)//枚举行数
        for(int i=1;i<=n;i++)//枚举左边
            for(int j=i;j<=n;j++){//枚举右边
                if(map[k][i][j-1]==1&&a[k][j]=='W')map[k][i][j]=1;//预处理第k行从第i个到第j个是否全部是'W'
            }
    /*for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=i;j<=n;j++)
            cout<<"第"<<k<<"行 "<<"从"<<i<<"到"<<j<<"是否全为W:"<<map[k][i][j]<<endl;*/
    for(int i=1;i<=n;i++)//枚举左边
        for(int j=i;j<=n;j++){//枚举右边
            int t=0;
            for(int k=1;k<=n;k++)//枚举行数
                if(map[k][i][j])//map[k][i][j]表示第k行从第i个到第j个是否全部是'W'
                t++;
                else{
                    ans+=(t*(t+1))>>1;
                    t=0;
                }
            ans+=(t*(t+1))>>1;
        }
    cout<<ans<<endl;
}
```

---

## 作者：EternalAlexander (赞：8)

庆祝一下第一次没看题解没听过讲没任何提示过蓝题。

首先，这题从数据范围，题目内容等等来看都很像dp，一眼看出应该是没有问题的。

确定了用dp做后，现在来设计状态。对于一个这样的矩阵，很好想到的一种状态设计就是dp[m, n]表示原矩阵中的[0, 0]到[m, n]的子矩阵中含有的白色矩形数量。那么转移方程就是

dp[m, n]=dp[m-1, n]+dp[m, n-1]-dp[m-1, n-1]+（加上[m, n]这一格后增加的矩形数量）

现在，关键就是（加上[m, n]这一格后增加的矩形数量）。

将它记为count(i, j)，那么如何计算呢？


这就是count函数了（其中map[i][j]表示矩阵[i,j]格的颜色，0为白，1为黑）。首先，沿着x-方向扩展直到撞到黑格，每到一格就向y-方向扩展直到撞到黑格，将扩展的格子数记为j，记leftscan[l]为到目前为止j的最小值。

然后沿着y-方向扩展直到撞到黑格，每到一格就向x-方向扩展直到撞到黑格，如果扩展到的格子数量<=leftscan则把答案增加1。

这个函数的正确性可以通过手动操作一下来验证。


```C++
```
```C++

int count(int x, int y) {
    int l, j; int ans = 0; int M = 2147483647;
    for (l = x; map[l][y]==0; --l) {
        for (j=0; map[l][y-j]==0; ++j) {;}
        leftscan[l]=min(M, j); M=min(M, j); 
    } 
    for (int i = y; map[x][i]==0; --i) {
        for (j=0; map[x-j][i]==0; ++j) {
            if (leftscan[x-j]>=y-i+1) ans++; 
        }
    } for (l = x; map[l][y]==0; --l) {leftscan[l]=0;}
    return ans;
}
```
那么程序就很好写了，复杂度为n^4,但是一般跑不满这个时间。总结一下，这个做法的状态设计很简单，但是转移复杂，甚至需要专门编写函数辅助转移。

代码如下

    
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int leftscan[151]; int upscan[151]; int map[151][151]; 
int count(int x, int y);
int main()
{
    int n; int dp[151][151]; char c;
    memset(map, 1, sizeof(map)); memset(dp, 0, sizeof(dp)); 
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            cin>>c; 
            if (c=='W') map[i][j]=0;
            else map[i][j]=1;
        }
    } 
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+count(i, j);
        }
    }printf("%d", dp[n][n]);
    return 0;
} 
int count(int x, int y) {
    int l, j; int ans = 0; int M = 2147483647;
    for (l = x; map[l][y]==0; --l) {
        for (j=0; map[l][y-j]==0; ++j) {;}
        leftscan[l]=min(M, j); M=min(M, j); 
    } 
    for (int i = y; map[x][i]==0; --i) {
        for (j=0; map[x-j][i]==0; ++j) {
            if (leftscan[x-j]>=y-i+1) ans++; 
        }
    } for (l = x; map[l][y]==0; --l) {leftscan[l]=0;}
    return ans;
}

```

---

## 作者：plane (赞：8)

题目大意：白色格子可组成矩形的数量。 


枚举法。先预处理一个数组down[I,j]，表示表示从I,j这个格子向下最多有多少个连续的白色格子（前提是本身也是白色，黑色就为0）。 


然后枚举矩形上边的两个顶点。先枚举左上的一个，如果是黑色格子就跳过，如果是白色格子就先ans+temp[I,j],然后让k从j往后找，temp记录这行白色格子深度（down[i]）的最小值，只要是白色的格子，就ans+temp..这样就不会重复查找


预处理


```delphi


for i:=1 to n do if map[n,i] then f[n,i]:=0 else f[n,i]:=1;
  for i:=n-1 downto 1 do
    for j:=1 to n do
      begin
        if map[i,j] then f[i,j]:=0;
        if not map[i,j] then f[i,j]:=f[i+1,j]+1;
      end;


```

主过程


```delphi



for i:=1 to n do
    for j:=1 to n do
      if not map[i,j]
      then
        begin
          ans:=ans+f[i,j];
          k:=j+1;
          temp:=f[i,j];
          while (k<=n) and (not map[i,k]) do
            begin
              temp:=min(temp,f[i,k]);
              ans:=ans+temp;
              inc(k);
            end;
        end;



```

---

## 作者：Lates (赞：6)

考虑分别统计每一行的方案数

对于这一行的第 $i$ 格，记

- $h_i$ 为这一行第 $i$ 格往上连续白格的数量，
- $l_i/r_i$ 为这一行第 $i$ 格往 左/右 第一个 $h$ 值 $<h_i$ 的格

其中 $l_i,r_i$ 容易用单调栈维护，$h_i$ 随便模拟即可。

![image.png](https://i.loli.net/2020/07/22/mgrIBQ63eXDYxwn.png)

对于这个图，$l_i=i-3,r_i=i+4$。可以得到的矩形都是在阴影部分内。

根据乘法原理得到第 $i$ 格的方案数即为 $(i-(l_i+1)+1)\times((r_i-1)-i+1)\times h_i$=$(i-l_i)(r_{i}-i)h_i$。

对于每一行每一格都统计答案即可。

$Code$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define int long long 
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int MAX=155;
int n,h[MAX];char x[MAX][MAX];
int s[MAX],top,ans,l[MAX],r[MAX];
inline void solve(){
	top=0;
	for(register int i=1;i<=n;++i){
		while(top&&h[s[top]]>h[i])--top;
		l[i]=top?s[top]:0;
		s[++top]=i;
	}
	top=0;
	for(register int i=n;i;--i){
		while(top&&h[s[top]]>=h[i])--top;
		r[i]=top?s[top]:n+1;
		s[++top]=i;
	}
	for(register int i=1;i<=n;++i){
		ans+=(i-l[i])*(r[i]-i)*h[i];
	}
}
signed main(){
	n=read();
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=n;++j){
			cin>>x[i][j];
		}
	}
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=n;++j){
			++h[j];
			if(x[i][j]=='B')h[j]=0;
		} 
		solve();
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：巨型方块 (赞：5)

我的博客

http://blog.csdn.net/largecub233/article/details/72770038

求点赞^\_^


来一个用xjb算法的题解；

xjb是什么算法？

这种算法基本上可以解决所有题目；

也许你不会lct；

也许你不会插头dp；

也许你不会莫比乌斯反演；

但是，只要你会xjb算法，noip甚至省选noi都不成问题！


我们对于这道题

要有一个初步的想法；

对于(i,j)这个点；

如果可以求出以这个点为右下角的所有矩阵；

那么这道题就好办了；

但是这个类似与dp的思想，却好像无法实现；

那怎么办呢？

我们对于(i,j)

维护x表示这个点向左最多连续几个W

维护y表示这个点向上最多连续几个W

显然(i,j)这个点最大贡献就是x\*y

但是我们咋么求这个点的实际贡献呢？

我们从x\*y这个矩阵的左下角开始向右上角搜索；

勾出一条边界线；

边界线左下放全部是W

这样我们一遍勾出边界，一边计算答案就好了；

时间复杂度

150\*150\*300

满
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=155;
int a[N][N],x[N][N],y[N][N],s[N][N];
int ans,n,m,xx,yy;
char c;
bool check(int x,int y,int xx,int yy){
    return (s[xx][yy]-s[xx][y-1]-s[x-1][yy]+s[x-1][y-1])==(xx-x+1)*(yy-y+1);
}
int dfs(int a1,int a2,int xx,int yy){
    int ans=0;
    int x=xx;
    int y=yy-a1+1;
    while(a1&&a2){
        ans+=a1;
        while(!check(x-1,y,xx,yy))y+=1,a1--;
        x-=1;
    }
    return ans;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){cin>>c;if(c=='W')a[i][j]=1;s[i][j]=a[i][j];}
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)s[i][j]+=s[i][j-1];
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)s[i][j]+=s[i-1][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(a[i][j]){
                x[i][j]=x[i][j-1]+1;
                y[i][j]=y[i-1][j]+1;
                ans+=dfs(x[i][j],y[i][j],i,j);
            }
    printf("%d",ans);
}
```

---

## 作者：珈乐唯毒 (赞：3)

# O(n*n)过！！！
~~不会用latex的蒟蒻真可怜~~

思路：统计以每一排为底边，以一个特定值为高的矩形

首先进行预处理，记录下每一个点可以往下蔓延多少个点，记为这个点的高度。

然后，枚举每一排。

再计算以一个点的高度为长方形的高，可以得到多少个长方形。实现方法：利用单调栈找出左右第一个比该点矮的点。这样就能得出以该拍为底，该点的高为高能得出的最大矩形。

之后只要统计就可以了，下见代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,m,a[N][N],b[N][N],h[N],f[N],w[N];
string c;
int q[N],l,ans;
int main(){
//	freopen("rectangle.in","r",stdin);
//	freopen("rectangle.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>c;
		for(int j=1;j<=m;j++){
			if(c[j-1]=='W')
				a[i][j]=1;
			else 
				a[i][j]=0;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!a[i][j])
				continue;
			if(a[i-1][j])
				b[i][j]=b[i-1][j]-1;
			else
				for(int k=i;k<=n;k++){
					if(a[k][j])
						b[i][j]++;
					else break;
				}
		}
	}
	for(int i=1;i<=n;i++){
		memset(h,0,sizeof(h));
		memset(f,0,sizeof(f));
		memset(w,0,sizeof(w));
		for(int j=1;j<=m+1;j++){
			if(!a[i][j]){
				for(int k=1;k<=l;k++)
					h[q[k]]=q[l];
				l=0;
			}
			else{
				while(b[i][q[l]]>b[i][j]){
					h[q[l]]=j-1;
					w[q[l]]=max(w[q[l]],b[i][j]);
					l--;
				}
				while(b[i][q[l]]==b[i][j])
					l--;
				q[++l]=j;
			}
		}
		for(int j=m;j>=0;j--){
			if(!a[i][j]){
				for(int k=1;k<=l;k++)
					f[q[k]]=q[l];
				l=0;
			}
			else{
				while(b[i][q[l]]>b[i][j]){
					f[q[l]]=j+1;
					w[q[l]]=max(w[q[l]],b[i][j]);
					l--;
				}
				q[++l]=j;
			}
		}
		for(int j=1;j<=m;j++){
			if(!h[j]||!f[j])
				continue;
			int t=(h[j]-f[j]+1);
			ans+=(t+1)*t/2*(b[i][j]-w[j]);//去重
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：机器侠 (赞：3)

# 题解：
这是一个O（n）的算法

首先，用两个数组a和b，一个扫描左边，一个扫描上面，就得出了宽度为一的矩形

接着，定义函数sm对其他进行扫描，得出结果，累加到ans上
最后，输出ans

上代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,ans,a[155][155],b[155][155];
bool f[155][155];
int sm(int x,int y,int c,int d)//扫描
{

    int s=0;
    int l=c;
    for(int i=x;i>(x-d);--i)
    {
        l=min(l,a[i][y]);
        s+=l;
    }
    return s;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=n;++j)
	  {
	  	char ch;
	  	cin>>ch;
	  	if(ch=='W')
	  	  f[i][j]=true;else
	  	  f[i][j]=false;
	  }    
	memcpy(b,a,sizeof(a));
	for(int i=1;i<=n;++i)
	 for(int j=1;j<=n;++j)
	   if(f[i][j])
	   {
	 	  a[i][j]=a[i][j-1]+1;//向左扫描
	 	  b[i][j]=b[i-1][j]+1;//向上扫描
		  ans+=sm(i,j,a[i][j],b[i][j]);
	   }
	 	
	 printf("%d",ans);//输出ans
	 return 0;
}
```


---

## 作者：wenye05 (赞：1)

upd1:调整了下格式，并写了些试图解释一些人代码所用内存不到1M的文字
upd2:纠正了个错误

# 题目链接
[P1191 矩形](https://www.luogu.com.cn/problem/P1191)

# 思路
O(n^3)
~~其实应该到不了~~

考虑矩形右下角，维护各个点两个信息，即向左和向上有多少连续的W（前提是这个点是W）

声明变量：向左w[i][j]，向上h[i][j]

于是枚举到i,j这个点时只需向左枚举连续的W，并根据h更新ans

根据图来看

![](https://cdn.luogu.com.cn/upload/image_hosting/dhk2y1tc.png)

模拟下样例

![](https://cdn.luogu.com.cn/upload/image_hosting/wm18ry3y.png)

从1,1开始看，此时直接用h更新即可，ans=1

![](https://cdn.luogu.com.cn/upload/image_hosting/apdegmfn.png)

1,2这个点的h为1，以其为右下角宽为1的矩形有1(h[1][2])个，ans+=1

向左一个格，h依旧为1，说明相应的宽为2的矩形有1(h[1][1])个，ans+=1

那要是崎岖的地方呢？（或者说h有变化）

![](https://cdn.luogu.com.cn/upload/image_hosting/i2kgb22f.png)

考虑这个图有字的格子

![](https://cdn.luogu.com.cn/upload/image_hosting/hn2aijwb.png)

ans++

向左走

![](https://cdn.luogu.com.cn/upload/image_hosting/4dumah82.png)

ans加的是红圈框的的矩形，ans+=1

那么可以发现，枚举时更新ans用的是枚举的一段区间中h的最小值

这里只是稍稍说说，可以依据代码、画几个图多看看，比如再画个开始枚举时h大的崎岖图，想想为什么h大于1也可以用h来更新，以及其更新的是什么【提示：宽一定，高不同的矩形】

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define N 155
int h[N][N],w[N][N],n;
long long ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){
        char a=getchar();
        while(a!='W' && a!='B')a=getchar();
        if(a=='W'){w[i][j]=w[i][j-1]+1;h[i][j]=h[i-1][j]+1;}
        else    {w[i][j]=h[i][j]=0;continue;}
        int mi=h[i][j];
        for(int k=j;k>j-w[i][j];k--){
            mi=min(mi,h[i][k]);
            ans+=mi;
        }
    }
    cout<<ans;
    return 0;
}

```

# 卡常

还是O(n^3)，有兴趣的同学可以去找找更快的

这里是卡下空间

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define N 155
int n;
int w,h[N];
long long ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            char a=getchar();
            while(a!='W' && a!='B')a=getchar();
            if(a=='W'){w++;h[j]++;}
            else    {w=h[j]=0;continue;}//the line is necessary.
            int mi=h[j];
            for(int k=j;k>j-w;k--){
                mi=min(mi,h[k]);
                ans+=mi;
            }
        }
        w=0;//don't forget
    }
    cout<<ans;
    return 0;
}
```

约1.01MB的内存

然而经过我再次提交后发现其实可以到达700多k

感谢观看

---

## 作者：EarthGiao (赞：1)

## 【思路】
暴力？    
输入数据，    
同时记录没一点从他开始到上面一共有多少个连续的白点    
然后再枚举一遍矩阵     
每一个点都求出附近能够组成的矩阵的数量  
累加起来   
怎么求能够成矩阵的数量呢？     
枚举这个矩阵的长    
然后宽是长覆盖的范围里面最矮的那个    
用长* 宽就是目前矩阵的长能够包含的矩阵的数量   
输出和就好了      


## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>

using namespace std;
const int Max = 1005;
int f[Max][Max];
int main()
{
	char c;
	int n;
	cin >> n;
	for(register int i = 1;i <= n;++ i)
	{
		for(register int j = 1;j <= n;++ j)
		{
			cin >> c;
			if(c == 'B')f[i][j] = 0;
			else
			f[i][j] = f[i - 1][j] + 1;
		}
	}
	int ans = 0;
	for(register int i = 1;i <= n;++ i)
	{
		for(register int j = 1;j <= n;++ j)
		{
			int M = f[i][j];
			for(register int l = j,r = j;l >= 1,r <= n;++ l,++ r)
			{
				M = min(M,min(f[i][l],f[i][r]));
				ans += (r - l + 1) * M;
			}
		}
	}
	cout << ans << endl;
	return 0;
} 
```

---

## 作者：syh0313 (赞：1)

pascal AC解




```cpp
program p1191;
var n,i,j,min,t:longint;
    ans:int64;
    ch:char;
    up,f:array[-10..1010,-10..1010]of longint;
    map:array[-10..1010,-10..1010]of boolean;        防止越界
begin
  readln(n);
  for i:=1 to n do
   begin
     for j:=1 to n do
       begin
         read(ch);
         if ch='W'    字符读入
          then map[i,j]:=true
          else map[i,j]:=false;
       end;
     readln;
   end;
  for i:=1 to n do
   for j:=1 to n do
    if map[i,j]=true
     then up[i,j]:=up[i-1,j]+1;    先从左向右搜一遍
  ans:=0;
  for i:=1 to n do
   for j:=1 to n do
    if map[i,j]=true
     then begin
            min:=up[i,j];
            f[i,j]:=up[i,j];
            t:=j-1;    从下往上找
            while (map[i,t]=true)and(min<up[i,t]) do      若几行相同的话就取最短的一行的ans  若上一行的白格比这一行多就操作
             begin
               inc(f[i,j],min);
               dec(t);      从下往上搜 直到map（i，j）=false为止
             end;
            inc(f[i,j],f[i,t]);
            inc(ans,f[i,j]);
          end;
 writeln(ans);
end.
```

---

## 作者：zhyh (赞：1)

首先感谢 @巨型方块 的解题思路（就是那个xjb算法）

因为蒟蒻我代码看得晕晕的，所以按自己的理解改了一些实现方法的细节，应该简便些

先来介绍一下这个神奇的xjb算法（再次感谢他！）：

（以下的方向即以输入的矩形所展示的为准）

我们记某一点（都只算白点）a[i][j] 向左方可延伸的最大长度为 lenc[i][j]，向上方为 lend[i][j]；

首先枚举矩形的右下角坐标（i，j），求出其 lenc 和 lend，

接着在左上角为（i-lend，j-lenc）的矩形范围内的最下边开始往上扫：

（记扫描线长为 ll，ll 初值为 lenc；记已经扫了 xx 个单位）

扫描线表示此时已经扫过左上角为（i-xx，j-ll+1）的白色矩形；

每次扫描线向上一个单位时，扫描线长更新为 min（lenc[i-x][j]，ll），即满足始终使扫描线覆盖白色区域

对于每次 xx，答案累加 ll 即可（也就是该右下角坐标、此时纵坐标长度确定时的方案数）

（另外这种神奇的xjb算法适用性挺广的，妥妥的O(N^3)）

具体代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
    int n,a[155][155],lenc[155][155],lend[155][155],ans=0;    char c;
    //a记录，len意义如上文
int search(int x,int y,int lc,int ld){
    
    int tmp=0;  //步骤如上文所述
    int ll=lc;
    
    for(int xx=x;xx>(x-ld);xx--){  //扫描过程
        ll=min(ll,lenc[xx][y]);
        tmp+=ll;
    }
    
    return tmp;
}

int main(){
    
    scanf("%d",&n);
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>c;
            if(c=='W')a[i][j]=1;
        }
    }
    
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(a[i][j]){
                lenc[i][j]=lenc[i][j-1]+1;  //len可从前一个点求得；
                lend[i][j]=lend[i-1][j]+1;
                
                ans+=search(i,j,lenc[i][j],lend[i][j]);
            }
    
    printf("%d",ans);
    
    return 0;
}
```
施工完毕


---

## 作者：chenxinyang2006 (赞：0)

嗯，这是个不错的题，各种大佬也有低复杂度算法，但是我只有一个勉强卡着能过的$n ^ 3\ log(n)$

首先这个题肯定要枚举矩阵的左上角$(a,b)$

然后这个矩阵还是有很多种可能，不太好做

所以只能再枚举一个右边界$d$

这个时候，矩阵的形状其实已经很确定了，唯一不确定的就是下边界

然后下边界只要$c$是可以的，显然$[a,c]$这个区间都可以

也就是说，只要求出最大的$c$，左上角$(a,b)$，右边界$d$的白色矩形个数就可以求出，为$c - a + 1$个

这个$c$可以二分得到，但是判定矩形$[a,b][c,d]$是不是白色有些困难，因为我们现在的复杂度已经很屑了，再乘点什么东西瞬间爆炸

显然二分换倍增是比较明智的选择，考虑设$W[a][b][c][d]$表示矩形$[a,b][a + 2 ^ d,c]$是否全是白色，这个东西套个倍增板子就可以求了

顺便解释下为什么预处理出来的矩阵，高要为$2 ^ d + 1$，因为倍增往下跳必须跳$2 ^ d$步，不然会无法求出正确答案。往下$2 ^ d$，高度就是$2 ^ d + 1$

代码：

```cpp
#include <cstdio>
int n;
char map[155][155];
int tmp[155][155][155];//i行[j,k]都是白 
int W[155][155][155][10];//W[a][b][c][d]表示矩形[a,b][a + 2 ^ d][c]是否全是白色 
int ans;

int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++){
		scanf("%s",&map[i][1]);
	}
	for(int a = 1;a <= n;a++){
		for(int b = 1;b <= n;b++){
			int tag = 1;
			for(int c = b;c <= n;c++){
				if(map[a][c] == 'B') tag = 0;
				tmp[a][b][c] = tag;
				if(tmp[a][b][c] && tmp[a - 1][b][c]){//根据定义，d = 0时W[a - 1][b][c]是管a - 1行和a行的
					W[a - 1][b][c][0] = 1;
				}
			}
		}
	}
	for(int i = 1;i <= 7;i++){
		for(int a = 1;a <= n;a++){
			if(a + (1 << i) > n) continue;//这里必须判，否则RE，开大数组会MLE……
			for(int b = 1;b <= n;b++){
				for(int c = b;c <= n;c++){
					W[a][b][c][i] = W[a][b][c][i - 1] & W[a + (1 << i - 1)][b][c][i - 1];
				}
			}
		}
	}
	for(int a = 1;a <= n;a++){
		for(int b = 1;b <= n;b++){
			for(int c = b;c <= n;c++){
				if(!tmp[a][b][c]) continue;//有可能自己这一行都不行，得判掉
				int now = a;
				for(int i = 7;i >= 0;i--){//注意这里从大到小
					if(W[now][b][c][i]){
						now += (1 << i);
					} 
				}
				ans += (now - a + 1);
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

不过这么做确实有点麻烦，可能还是因为我懒得找规律，只能暴力上了

---

## 作者：Celebrate (赞：0)

[我的博客](https://blog.csdn.net/zsyzClb/article/details/84886769)

因为前面在USACO里面做过好几道关于在平面内找矩阵的问题了

所以当我看到这一道题的时候就马上想到了，两条边确定矩阵的方法

首先就是枚举两列，然后搞两个指针，p2用for循环开路，p1跟在后面，然后维护一下指针，时间复杂度O(N^3)

代码

```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
using namespace std;
 
const int N = 210 ;
int n ;
char st[N] ;
int sum[N][N] ; //sum[i][]表示第i行的前缀和 
inline int solve ( int h , int x , int y ) {  
	return sum[h][y] - sum[h][x-1] ; 
}
inline void next ( int &p1 ,int x , int y ) {
	while ( solve( p1 , x , y ) != 0 && p1 < n ) p1 ++ ;
}
 
int main() {
	cin >> n ;
	for ( int i = 1 ; i <= n ; i ++ ) {
		scanf ( "%s" , st + 1 ) ; 
		for ( int j = 1 ; j <= n ; j ++ )
			sum[i][j] = sum[i][j-1] + ( st[j] == 'W' ? 0 : 1 ) ; //得到前缀和 
	}
	int ans = 0 ;
	for ( int l = 1 ; l <= n ; l ++ ) // 枚举两列 
		for ( int r = l ; r <= n ; r ++ ) {
			int p1 = 1 ; next ( p1 , l , r ) ; //得到第一个满足条件的 
			for ( int p2 = p1 ; p2 <= n ; p2 ++ ) { //从当前这一个开始搜索 
				if ( p2 < p1 ) continue ; //如果p2直接跳到p1后面去了，那么就p2++ 
				if ( solve ( p2 , l , r ) != 0 ) { //如果当前这一行不满足要求 
					p1 = p2 + 1 ; next( p1 , l , r ) ; //尾往后跳 
					if ( solve ( p1 , l , r ) != 0 ) break ; //如果没有找到，就直接退出 
				}
				if ( solve ( p2 , l , r ) == 0 ) { // 如果满足条件，就将以p2结尾的开头在p1以内的所有矩阵记录一下 
					ans += ( p2 - p1 + 1 ) ;
				}
			}
		}
	cout << ans << endl ; //最后输出 
	return 0 ;
}

```

---


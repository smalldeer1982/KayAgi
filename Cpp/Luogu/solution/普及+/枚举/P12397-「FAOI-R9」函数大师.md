# 「FAOI-R9」函数大师

## 题目背景

作为一名电脑技术大神，明月喜欢用几何画板画出各种奇形怪状函数的图象，例如 $ y=\frac{x^x}{\sin x} $，$ y=\lfloor x^{\tan x} \rfloor $，$ y=\frac{x+x^3+x^5+x^7}{1+x^2+x^4+x^6} $，它们有的连续，有的离散，有的长得很奇怪，但是作为一名中考数学 99/100 的 math master，他自信自己能掌握很多函数的规律。

于是，清风给了他一个这样的函数。

## 题目描述

清风定义函数 $ s(x)(x \in \mathbb{N^*}) $ 代表 $ x $ 在十进制表示下的的各位数字之和，即：

$$ s(x)=\sum_{i=0}^{+\infty}(\lfloor \frac{x}{10^i} \rfloor \bmod 10) $$
清风又定义 $ S_k(x) (x\in \mathbb {N^*},k\in \mathbb{N}) $，满足：

$$ S_0(x) = x,S_k(x) = s(S_{k-1}(x)) $$

清风再定义 $ f_k(x)(x\in \mathbb {N^*},k\in \mathbb{N}) $，满足：

$$ f_k(x)=\sum_{i=0}^{k}S_i(x) $$

清风把这个函数给了明月，明月自信满满地将函数输入几何画板后，显示的图象让他眼花缭乱。为了探究这个函数的性质，明月找到了你。

给定你 $ k $，每次询问给定你 $ m $，请你求出 $ y=f_k(x) $  与 $ y=m $ 两个函数图象的公共点个数，可以证明这个数值一定是有限的。

## 说明/提示

**【样例 1 解释】**

对于样例 $ 1 $，每组数据对应的所有公共点的 $ x $ 坐标集合分别为 $ \{12\} $、$ \{5\} $、$ \varnothing $ 和 $ \{26\} $。

**【数据规模与约定】**

**本题采用捆绑测试。**

对于每个测试点，$ 1 \le T \le 10^5 $，$ 0 \le k \le 10^9 $，$ 1 \le m \le 10^{18} $。

* Subtask 1（5 pts）：$ k=0 $。
* Subtask 2（20 pts）：$ T \le 10 $，$ m \le 10^5 $，$ k \le 10 $。
* Subtask 3（25 pts）：$ T \le 10 $，$ m \le 10^6 $，$ k \le 10^4 $。
* Subtask 4（25 pts）：$ k \le 1 $。
* Subtask 5（25 pts）：无特殊限制。

## 样例 #1

### 输入

```
4 3
21
20
19
50```

### 输出

```
1
1
0
1```

# 题解

## 作者：Fiendish (赞：5)

函数 $f_k(x)$ 是一个十分有趣的函数。

可以先做一下变形。

$\begin{aligned}f_k(x)=S_0(x)+S_1(x)+S_2(x)\dots&=x+s(x)+S_0(s(x))+S_1(s(x))+\dots\\&=f_{k-1}(s(x))+x\end{aligned}$

若 $f_k(x)=m$，则 $m-f_{k-1}(s(x))=x$。

由此可以看出符合条件的 $x$ 不会超过 $m$。

因此，问题转化为每次询问有多少个 $s(x)$ 使得 $s(m-f_{k-1}(s(x)))=s(x)$。由于 $x\le m$，所以 $s(x)$ 不会很大，最大就到 $162$（当 $x=10^{18}-1$ 时）。因此我们可以先预处理出 $f_{k-1}(i),i\in[1,162]\land i\in\mathbb Z$，处理询问时枚举所有可能的 $s(x)$ 并对答案进行统计。时间复杂度 $O(T\log m)$。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long s(long long x){//求一个数在十进制下的各位数字之和
	long long ans=0;
	while(x) ans+=x%10,x/=10;
	return ans;
}
long long S[200][5];
long long f[200];//由于 k 是固定的，所以只需要开一维
int T,k;
long long m;
int main(){
	cin>>T>>k;
	for(int i=1;i<=162;i++){//预处理
		S[i][0]=i;
		S[i][1]=s(S[i][0]);
		S[i][2]=s(S[i][1]);
		if(k<=3)
			for(int j=0;j<k;j++) f[i]+=S[i][j];
		else f[i]=S[i][0]+S[i][1]+S[i][2]+1ll*(k-3)*S[i][2];
	}
	while(T--){
		cin>>m;
		long long ans=0;
		for(int i=1;i<=162;i++)//枚举 s(x)
			if(s(m-f[i])==i) ans++;
		cout<<ans<<'\n';
	}
}
```

---

## 作者：船酱魔王 (赞：4)

## 题意回顾

对于定义域在 $ \mathbb {N^+} $ 的函数 $ s(x) $，满足：

$$ s(x)=\sum_{i=0}^{\lfloor log_{10}x \rfloor} {\lfloor \frac{x}{10^i} \rfloor \bmod 10} $$

我们又定义 $ S_k(x) (x\in \mathbb {N^+}, k \in \mathbb{N}) $，满足：

$$ S_0(x) = x,S_k(x) = s(S_{k-1}(x)) $$

我们再定义 $ f_k(x)(x\in \mathbb {N^+},k\in \mathbb{N}) $，满足：

$$ f_k(x)=\sum_{i=0}^{k}S_i(x) $$

现在，一开始给定你 $ k $，每次询问给定你 $ m $，请你求出满足 $ f_k(x)=m (x \in \mathbb {N^+}) $ 的 $ x $ 的个数。

$ T \le 10^5 $，$ k \le 10^9 $，$ m \le 10^{18} $。

## 分析

首先理解题意，$ s(x) $ 是在求 $ x $ 的 $ 10 $ 进制下数字和，$ S_k(x) $ 是对 $ x $ 进行 $ k $ 次数字和操作，$ f_k(x) $ 是对 $ x $ 进行 $ 0 \sim k $ 次数字和操作的结果的和。

这样的方程在大多数情况下看起来没有公式类的高效解法，因此考虑枚举。

$ k=0 $ 时（子任务 $ 1 $）可以发现 $ f_0(x)=x $，因此答案必然为 $ 1 $。

子任务 $ 2 $ 可以暴力枚举 $ x $，然后暴力算出 $ f_k(x) $，检验是否等于 $ m $。

子任务 $ 3 $ 可以发现数据范围需要 $ O(Tm) $ 的复杂度。考虑如何快速计算 $ f_k(x) $。可以发现数字和函数会让数近乎变为其对数，下降速度很快，可以在几次内跌落到个位数，同时，对于个位数，数字和即是其本身。因此我们对于每个 $ x $，直接用类似于 子任务 $ 2 $ 的做法暴力求数字和再累加，当数字和小于 $ 10 $ 时直接加上剩余数字和个数和当前数字和的乘积，因为数字和不会再变化。防止被卡常可以提前预处理好 $ f_k(x) $。（这也是出题人规定 $ k $ 固定的原因）。

子任务 $ 4 $ 用于启发正解，发现要解的方程就是 $ x+s(x)=m $，不能枚举 $ x $ 但是结合上一档部分分的结论，即 $ s(x) $ 远小于 $ x $，我们可以枚举 $ s(x) $，检验 $ x $ 是否符合要求。

正解（子任务 $ 5 $）把方程化为 $ x+\sum_{i=1}^{k}S_i(x)=m $，再化为 $ x+f_{i-1}(s(x))=m $，结合前面的结论，$ s(x) $ 不大所以可以直接枚举，算出 $ f_{i-1}(s(x)) $，用 $ m $ 减去后检验是否符合要求即可。

最终解法的时间复杂度是 $ O(Tw \log V) $，$ V $ 代表值域，$ w $ 是 $ s(x) $ 枚举范围，不超过 $ 200 $。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int T, k;
long long m;
long long f1[205];
int s(long long x) {
	int res = 0;
	while(x) {
		res += x % 10;
		x /= 10;
	}
	return res;
}
int main() {
	cin >> T >> k;
	if(k == 0) {
		for(int ti = 1; ti <= T; ti++) {
			cout << 1 << endl;
		}
		return 0;
	}
	int t1;
	for(int i = 1; i <= 200; i++) {
		t1 = i;
		for(int j = 1; j <= k; j++) {
			if(t1 < 10) {
				f1[i] += t1 * (long long)(k - j + 1);
				break;
			}
			f1[i] += t1;
			t1 = s(t1);
		}
	}
	int t2;
	for(int ti = 1; ti <= T; ti++) {
		cin >> m;
		t2 = 0;
		for(int j = 1; j <= 200; j++) {
			t1 = m - f1[j];
			if(t1 <= 0) {
				continue;
			}
			if(s(t1) == j) {
				t2++;
			}
		}
		cout << t2 << endl;
	}
	return 0;
}
```

---

## 作者：nbhs23a28 (赞：3)

怎么题解区那么多大佬的复杂度都带 $\log$ 啊，我来提供个可行性优化性卡常下的常数复杂度做法。

省流：本题思路为对于 $S_i(x)$ 这一函数探究其特殊性质，结合可行性优化性卡常即可通过。

注意到 $s(x)$ 这一函数的迭代每次都取数位和。不难发现对于任意 $m$ 满足 $1\le m\le 10^{18}$，经过三四次迭代，总能得到一位数，之后的迭代便退化成 $S_i(x)=S_{i-1}(x) (i \ge 4)$ 了。于是，对于较大的 $k$，我们只需枚举最终恒定的一位数即可。而 $f_k(x)-f_0(x) (k \le 4)$ 显然小于 $200$（随便找的较接近上界的数），这样，我们便能在常数时间内枚举得到答案了。

然而我们发现，即使这样枚举还是会超时！原来是常数太大了。经分析，该做法的瓶颈在于 $k \ge 4$ 时，多了一层枚举最终恒定的一位数，总常数已经高于 $10^3$ 了。这时我们可充分利用人类数学智慧卡常：注意到一个数的数位和与该数本身在模 $9$ 意义上同余，因此该数最终得到的恒定的一位数与该数本身模 $9$ 意义上同余，进一步不正与该数一一对应吗（最终 $9$ 种恒定的一位数在模 $9$ 意义上互不相同）！这样，我们寻找时每次加 $9$，等同于把多的一层枚举抵消了！此时常数降至 $10^2$ 级别，足以通过本题。

Code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int k,m,ans,swh[300];//swh:数位和
//常数在10^2~10^3级别，卡常通过
long long s(int num)
{int sum=0;
 if(num<300&&swh[num]) 
 return swh[num];
 while(num)
 {sum+=num%10;
  num=num/10;
 }
 return sum;
}
void solve1(int sum,int ys)
{for(int i=max(1ll,sum-200);i<=sum;i++)
 {int summ=0,num=i;summ+=num;
  num=s(num);summ+=num;
  num=swh[num];summ+=num;
  num=swh[num];summ+=num;
  if(swh[num]==ys) 
  {i+=8; //别小看这一小小的一行卡常哟
   if(summ==sum)
   ans++;
  }
 }
}
void solve2(int sum,int c)
{for(int i=max(1ll,sum-200);i<=sum;i++)
 {int summ=0,num=i;summ+=num;
  for(int j=1;j<=c;j++)
  num=s(num),summ+=num;
  if(summ==sum) 
  ans++;
 }
}
signed main()
{ios::sync_with_stdio(0);cin.tie(0);
 int t;cin>>t>>k;
 for(int i=1;i<300;i++)
 swh[i]=s(i);
 while(t--)
 {cin>>m;
  ans=0;
  if(k>=4)
  {int a;
   for(int i=1;i<=9;i++)
   {a=i*(k-3);
    if(m-a>=0) solve1(m-a,i);
   }
  }
  else
  solve2(m,k);
  
  cout<<ans<<'\n';
 }
}
```

---

## 作者：Mier_Samuelle (赞：2)

场切了。

### Statement

我们定义：

- $s(x)$ 为 $x$ 在十进制下各个数位上的数之和，即 $s(x)=\sum\limits_{i=0}^\infty\left(\left\lfloor \dfrac{x}{10^i} \right\rfloor \mathrm{mod}\;10\right)$。
- $S_k(x)=\begin{cases} x & k=0 \\ s(S_{k-1}(x)) & k \ge 1 \end{cases}$。
- $f_k(x)=\sum\limits_{i=0}^k S_i(x)$。

给定 $k$，$t$ 次询问，每次给定 $m$，求 $y=f_k(x)$ 与 $y=m$ 的图象的公共点个数。

数据范围：$1 \le t \le 10^5$，$0 \le k \le 10^9$，$1 \le m \le 10^{18}$。

### Analysis

根据 Subtask 提示，分几种情况考虑：

- 当 $k=0$ 时：
  - 由题意知 $f_0(x)=x=m$。
  - 答案显然为 $1$。
- 当 $k=1$ 时：
  - 由题意知 $f_1(x)=x+s(x)=m$。
  - 由于 $x$ 可能很大，枚举 $x$ 无法接受，故考虑枚举较小的 $s(x)$。
  - 具体地，枚举 $a \in [1,162]$，则 $x=m-a$。
  - 验证 $s(x)=a$ 是否成立即可。
- 当 $k=2$ 时：
  - 由题意知 $f_2(x)=x+s(x)+s(s(x))=m$。  
  - 类似地，枚举 $a \in [1,162]$，记 $b=s(a)$，则 $x=m-a-b$。
  - 验证 $s(x)=a$ 且 $s(s(x))=b$ 是否成立即可。
- 当 $k \ge 3$ 时：
  - 由题意知 $f_k(x)=x+s(x)+s(s(x))+\dots+S_k(x)=m$。  
  - 注意到，当 $k$ 逐渐增大时，$S_k(x)$ 减小极快。  
  - 实际上，对于任意 $x \le m \le 10^{18}$，当 $k \ge 3$ 时，$S_k(x)$ 都是相同的。
  - 因此，枚举 $a \in [1,162]$，记 $b=s(a)$，$c=s(b)$，则 $x=m-a-b-(k-2) \times c$。
  - 验证 $s(x)=a$，$s(s(x))=b$ 且 $s(s(s(x)))=c$ 是否成立即可。

复杂度是常数级的。

### Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int INF = 0x3f3f3f3f3f3f3f3f;
int t, k;
int s(int x){
	int ret = 0;
	while (x > 0){
		ret += x % 10;
		x /= 10;
	}
	return ret;
}
void solve(){
	int m;
	cin >> m;
	int cnt = 0;
	if (k == 0){ //不要忘记 k=0 的情况
		cout << 1 << endl;
		return;
	}
	for (int a = 0;a <= 200;a++){
		int b = s(a), c = s(b), d = s(c);
		if (k == 1){
			int x = m - a;
			cnt += (s(x) == a);
		}
		else if (k == 2){
			int x = m - a - b;
			cnt += (s(x) == a && s(s(x)) == b);
		}
		else{
			int x = m - a - b - c * (k - 2);
			cnt += (s(x) == a && s(s(x)) == b && s(s(s(x))) == c);
		}
	}
	cout << cnt << endl;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> t >> k;
	while (t--) solve();
	return 0;
}
```

---

## 作者：wpl123456wpl (赞：1)

# 洛谷 P12397

## [题目传送机](https://www.luogu.com.cn/problem/P12397)

## 题目详情

### 题目描述

清风定义函数 $ s(x)(x \in \mathbb{N^*}) $ 代表 $ x $ 在十进制表示下的的各位数字之和，即：

$$ s(x)=\sum_{i=0}^{+\infty}(\lfloor \frac{x}{10^i} \rfloor \bmod 10) $$
清风又定义 $ S_k(x) (x\in \mathbb {N^*},k\in \mathbb{N}) $，满足：

$$ S_0(x) = x,S_k(x) = s(S_{k-1}(x)) $$

清风再定义 $ f_k(x)(x\in \mathbb {N^*},k\in \mathbb{N}) $，满足：

$$ f_k(x)=\sum_{i=0}^{k}S_i(x) $$

请求解出有多少个 $f_k(x) = m$ 。

### 输入格式

第一行两个整数 $ T,k $，表示有 $ T $ 组询问，$ k $ 的意义见题目描述。

接下来 $ T $ 行，每行一个正整数，第 $ i $ 行的表示第 $ i $ 次询问的 $ m $。

### 数据范围

对于每个测试点，$ 1 \le T \le 10^5 $，$ 0 \le k \le 10^9 $，$ 1 \le m \le 10^{18} $。

* Subtask 1（5 pts）：$ k=0 $。
* Subtask 2（20 pts）：$ T \le 10 $，$ m \le 10^5 $，$ k \le 10 $。
* Subtask 3（25 pts）：$ T \le 10 $，$ m \le 10^6 $，$ k \le 10^4 $。
* Subtask 4（25 pts）：$ k \le 1 $。
* Subtask 5（25 pts）：无特殊限制。

## 逐步分析

不如我们先骗部分分。

### Subtask 1 分析

对于 $k = 0$，$f_k(x)$ 只会取 $S_0(x) = x$，什么数等于 $m$ 了？显而易见只有 $m = m$，所以当 $k = 0$ 直接输出 $1$ 即可。

### Subtask 2 分析

对于 $f_k(x)$ 不管 $k$ 等于多少，$f_k(x)$ 至少为 $x$ ，因此 $x$ 的枚举范围是 $1 \ldots m$，再次花 $k$ 的时间求出 $f_k(x)$ 的值。( $s(x)$ 的求解时间均摊下来为常数级别 )

对此枚举 $x$，暴力求解 $f_k(x)$，单个任务时间复杂度为 $O(M \times K)$，总时间复杂度为 $O(T \times M \times K)$。

### Subtask 3 分析

这里，就得好好分析函数了。

对于函数 $s(x)$，若 $x$ 是一位数，在十进制表示下的的各位数字之和就是 $x$，**那么后面的循环就没必要进行下去了**， 可以直接用乘法解决，**那需要进行多少次才能直接求解？**

继续分析，当 $M$ 的上限为 $1 \times 10^6$，对于 $s(1) \ldots s(m)$中，**最大 $s(x)$ 的值为 $54$**。继续分析，当 $M$ 的上限为 $54$，对于 $s(1) \ldots s(m)$中，**最大 $s(x)$ 的值为 $13$**。继续分析，当 $M$ 的上限为 $13$，对于 $s(1) \ldots s(m)$中，**最大 $s(x)$ 的值为 $9$**。

上述分析，**我们一共求解了 $3$ 次最大值，最大值就已经只有了个位数**，那么对于循环 $k$，我们实际上最多找3次就可以直接使用乘法求解，总时间复杂度由 $O(T \times M \times K)$ 降到了 $O(T \times M)$。

### Subtask 4 分析

这里，采用了 **Subtask 3** 的分析方向，我们依旧对函数 $s(x)$ 下手。

当 $M$ 的上限为 $1 \times 10^{18}$，对于 $s(1) \ldots s(m)$中，**最大 $s(x)$ 的值为 $162$**。由于 $k = 1$，$f_k(x)$ 只会算到这一步，于是 **$162$ 成为了突破口**。当我们考虑枚举 $S_1(x)$ **( $1 \ldots 162$ )** 我们理想是函数 $f_k(x)$ 的值等于 $m$，我们的期望是 $x = (m - S_1(x))$，而我们又选择枚举 $S_1(x)$，所以我们只需判断 是否 $s(x) = S_1(x)$，若成立，则代表 $f_1(x) = m$。

总时间时间复杂度 $O(T)$。

### Subtask 5 分析

我们的 **Subtask 3** 和 **Subtask 4** 分别求解的是 $K$ 大 和 $M$ 大，**实际上正解就是他两互相结合**。先写出暴力代码 **Subtask 2**，总时间复杂度$O(T \times M \times K)$。将枚举 $x$ 的循环优化成 **Subtask 4** 的写法，总时间复杂度降至 $O(T \times K)$。在将枚举 $k$ 的循环用上 **Subtask 3** 的技巧，总时间复杂度降至 $O(T)$。

## 代码展示

### Subtask 3 代码展示

[Subtask 3](www.luogu.com.cn/paste/c1ws7g92)

### Subtask 4 代码展示

[Subtask 4](www.luogu.com.cn/paste/owsaxfq2)

### Subtask 5 代码展示

[Subtask 5](www.luogu.com.cn/paste/onzfejw9)

---

## 作者：201012280925LSY (赞：1)

## 思路
注意到 $k \le 10^9$ 而 $m \le 10^{18}$，根据 $f_k$ 函数的定义，我们可以知道可行解 $x$ 必然小于等于 $m$。因为 $m \le 10^{18}$，所以 $S_1(x)$ 最大时即为 $S_1(x) \le 162$。

依次类推，我们可以得出 $S_2(x) \le 18$ 和 $S_3(x) \le 9$。

因为个位数的数字和就是其本身，所以说在 $k \ge 3$ 时 $S_k(x) = S_3(x)$。

找到了这个规律，我们就可以枚举 $S_1(x)$ 的值，$S_2(x)$ 的值，以及 $S_3(x)$ 的值。再往后就不需要枚举了，$S_0(x)$ 的值也不需要枚举。

在 $k\ge 3$ 的情况下，我们令 $i=S_3(x)$，$j=S_2(x)$ 和 $l=S_1(x)$。

那么如果 $x$ 是可行的，则有 $(k-2)\times i + j+ l+x= m$。移一下项可以进一步得到 $x=m- (k-2) \times i -j-l$。这个时候我们判断一下 $l$ 是否等于 $S_1(x)$，即 $l$ 是否等于 $S_1(m-(k-2)\times i -j - l)$。同理，我们还得判断一下 $S_1(j)$ 是否等于 $i$，才能得出 $x$ 是可行的。

而对于 $k=2$ 和 $k=1$ 以及 $k=0$ 的情况，我们特判一下即可。

具体见代码：
```cpp
//code by 201012280925LSY
#include<bits/stdc++.h>
using namespace std;
long long T,k,answer;
long long check(long long x)//即为函数 s1(x)。
{
	long long sum=0;
	while(x)
	{
		sum+=x%10;
		x/=10;
	}	
	return sum;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>T>>k;
	while(T--)
	{
		long long m;
		cin>>m;
		answer=0;
		if(k==0)
		{
			cout<<1<<"\n";
			continue;
		}
		if(k==1)
		{
			for(int i=1;i<=162;i++)
			{
				if(check(m-i)==i)answer++;
			}
			cout<<answer<<"\n";
			continue;
		 } 
		if(k==2)
		{
			for(int i=1;i<=18;i++)
			{
				for(int j=1;j<=162;j++)
				{
					if(check(j)!=i)continue;//不合法退出。
					if(check(m-j-i)==j)answer++;
				}
			}
			cout<<answer<<"\n";
			continue;
		}
		for(int i=1;i<=9;i++)
		{
			for(int j=1;j<=18;j++)
			{
				if(check(j)!=i)continue;
				for(int l=1;l<=162;l++)
				{
					if(check(l)!=j)continue;
					if(check(m-j-l-(k-2)*i)==l)answer++;
				}
			}
		}
		cout<<answer<<"\n";
	}
	return 0;
}
```

---

## 作者：LXcjh4998 (赞：1)

[Luogu 链接](https://www.luogu.com.cn/problem/P12397)
# 题意
令 $\displaystyle s(n)=\sum_{i=0}^{+\infty}(\lfloor\frac{n}{10^i}\rfloor\bmod 10)$，即 $n$ 在十进制下各位数字之和；

令 $S_k(n)=\begin{cases}n,&k=0\\s(S_{k-1}(n)),&k>0\end{cases}$；

令 $\displaystyle f_k(n)=\sum_{i=0}^kS_i(n)$。

对于一个固定的 $k$（$0\le k\le10^9$），每次询问给出一个 $m$（$1\le m\le10^{18}$），求存在多少个 $n$，使得 $f_k(n)=m$。

询问数量 $1\le q\le10^5$。
# 思路
显然，满足条件的 $n\le m$，所以 $n\le10^{18}$。

所以 $S_1(n)\le162,S_2(n)\le18,S_3\le9,\forall i>3,S_i(n)=S_3(n)$。

考虑枚举 $S_1(n)$，并算出 $sum=\displaystyle\sum_{i=1}^kS_i(n)$，若 $s(m-sum)=S_1(n)$，则 $n=m-sum$ 是一个解。

当 $k=0$ 时，直接输出 $1$ 即可。
# 程序
[AC 记录](https://www.luogu.com.cn/record/215818214)
```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
#include<unordered_map>
#include<complex>
#define ll long long
#define ull unsigned long long
#define uint unsigned int
#define vl __int128
#define ld long double
#define INF 0x3f3f3f3f
#define eps 1e-9
#define ls rt<<1
#define rs rt<<1|1
#define fir first
#define sec second
#define lb(x) ((x)&(-(x)))
#define pb push_back
#define pii pair<int,int>
#define pdi pair<double,int>
#define forUp(i,a,b) for(int i=(a);i<=(b);++i)
#define forDown(i,a,b) for(int i=(a);i>=(b);--i)
template<typename T>inline void chkMax(T &x,T y){if(x<y)x=y;}
template<typename T>inline void chkMin(T &x,T y){if(x>y)x=y;}
template<typename T>inline void addMod(T &x,T y,T mod){if((x+=y)>=mod)x-=mod;}
template<typename T>inline void subMod(T &x,T y,T mod){if((x-=y)<0)x+=mod;}
using namespace std;
const int N=0+10;
//#define use_file
//#define more_test
//#define need_init
#ifdef more_test
int T;
#endif

ll T,k;ll m;

ll s(ll n){
	ll ans=0;
	while(n>0)ans+=n%10,n/=10;
	return ans;
}

ll ans,S[163];

void SOLVE(/*int TestID*/){
	scanf("%lld%lld",&T,&k);
	if(k==0){
		while(T--){
			scanf("%lld",&m);
			printf("1\n");
		}
		return;
	}
	forUp(i,1,162)S[i]=s(i);
	if(k==1){
		while(T--){
			scanf("%lld",&m);
			ans=0;
			forUp(i,1,162)if(s(m-i)==i)++ans;
			printf("%lld\n",ans);
		}
		return;
	}
	if(k==2){
		while(T--){
			scanf("%lld",&m);
			ans=0;
			forUp(i,1,162)if(s(m-i-S[i])==i)++ans;
			printf("%lld\n",ans);
		}
		return;
	}
	while(T--){
		scanf("%lld",&m);
		ans=0;
		forUp(i,1,162)if(s(m-i-S[i]-(k-2)*S[S[i]])==i)++ans;
		printf("%lld\n",ans);
	}
}
/*
Input:

Output:

*/
int main(){
	#ifdef use_file
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
	#endif
	#ifdef need_init
	init();
	#endif
	#ifdef more_test
	scanf("%d",&T);
	for(int i=1;i<=T;++i)SOLVE(/*i*/);
	#else
	SOLVE();
	#endif
	return 0;
}
```

---

## 作者：Firsry (赞：0)

## 题目大意

给定一个正整数函数：

- $s(x)$ 表示 $x$ 的十进制数字之和；
- $S_0(x)=x$，$S_k(x)=s\bigl(S_{k-1}(x)\bigr)$；
- $f_k(x)=\sum_{i=0}^k S_i(x)$。

对于固定的 $k(0\le k\le10^9)$，有 $T(\le10^5)$ 个查询，每次给定 $m(\le10^{18})$，求满足 $f_k(x)=m$ 的正整数 $x$ 的个数。

## 函数分析

1. **数字和上界**：对于 $x\le10^{18}$，$s(x)\le9\times19=171$.
2. **数根 $\mathrm{digitRoot}$**：
   - $S_1(x)=s(x)\le171$；
   - $S_2(x)=s(s(x))\le s(163)= 10$，且对任意 $j>3$，$S_j(x)=S_3(x)$（数根）。

由此，$f_k(x)$ 至多包含如下四种项：

- $S_0(x)=x$；
- $S_1(x)=s(x)$；
- $S_2(x)=s(s(x))$；
- 对于 $k\ge3$，还要加上 $(k-2)$ 个 $S_j(x)$，即 $(k-2)\times\mathrm{dr}(x)$。

## 分类讨论

记 $t=s(x)$，$d=\mathrm{digitRoot}(x)\in{1,2,\dots,9}$。

### 情况 1：$k=0$

$$
f_0(x)=x=m
$$

只要 $m\ge1$，唯一解 $x=m$，答案为 1，否则为 0。

### 情况 2：$k=1$

$$
f_1(x)=x+s(x)=m \Longrightarrow x=m-t,\quad t=s(x)
$$

枚举 $t=1\dots171$，令 $x=m-t$，检查 $x\ge1$ 且 $s(x)=t$ 即可。

### 情况 3：$k=2$

$$
f_2(x)=x+s(x)+s(s(x))=m
$$

枚举 $t=s(x)=1\dots171$，令

$$
x=m−t−s(t),x = m - t - s(t)
$$

检查 $x\ge1$ 且 $s(x)=t$ 即可。

### 情况 4：$k\ge3$

$$
f_k(x)=x + s(x) + s(s(x)) + (k-2)\,d = m.
$$

枚举：

1. 数根 $d=1\dots9$；

2. 数字和 $t=d,d+9,d+18,\dots\le171$；

3. 令
   $$
   x=m−t−s(t)−(k−2) d,x=m - t - s(t) - (k-2)\,d
   $$
   并校验 $x\ge1,\ s(x)=t,\mathrm{digitRoot}(x)=d$。

每次枚举 $t$ 的步长为 9，总共 $\lceil171/9\rceil=19$ 次，共 $9\times19=171$ 次检查。

## 时间复杂度

对每个查询最多做 $171$ 次常数级检查，$T\le10^5$ 时总计 $1.7\times10^7$ 次，C++ 可在 1s 内完成。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

ll T, k, m;

inline ll read() {
	ll x = 0;
	char ch = getchar();
	while (!isdigit(ch))
		ch = getchar();
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

inline int digitSum(ll x) {
	int s = 0;
	while (x)
		s += x % 10, x /= 10;
	return s;
}
int digitalRoot(ll x) {
	return digitSum(digitSum(digitSum(x)));
}

inline ll k0() {
	return (m >= 1 ? 1 : 0);
}
inline ll k1() {
	ll res = 0;
	for (int t = 1; t <= 171 && t < m; t++)
		if (digitSum(m - t) == t)
			res++;
	return res;
}
inline ll k2() {
	ll res = 0;
	for (int t = 1; t <= 171; t++) {
		ll x = m - t - digitSum(t);
		if (x >= 1 && digitSum(x) == t)
			res++;
	}
	return res;
}
inline ll k3() {
	ll res = 0;
	for (int d = 1; d <= 9; d++) {
		ll base = m - (k - 2LL) * d;
		for (int t = d; t <= 171; t += 9) {
			ll x = base - t - digitSum(t);
			if (x < 1)
				break;
			if (digitSum(x) == t && digitalRoot(x) == d)
				res++;
		}
	}
	return res;
}

int main() {
	T = read(), k = read();
	while (T--) {
		m = read();
		if (k == 0)
			cout << k0() << '\n';
		else if (k == 1)
			cout << k1() << '\n';
		else if (k == 2)
			cout << k2() << '\n';
		else
			cout << k3() << '\n';
	}
	return 0;
}
```

---

## 作者：DDF_ (赞：0)

## 题面

函数 $s(x)$ 为 $x$ 十进制下各个位数的和。

函数 $S_{k}(x)=s(S_{k-1}(x))$，且 $S_{0}(x)=x$。

函数 $f_{k}(x)$ 为 $\sum_{i=0}^{k}S_{i}(x)$。

给定整数 $k$ 和 $m$，求 $y=f_{k}(x)$ 图像与 $y=m$ 的交点个数。

## 题解

注意到 $f_{k}(x) \ge x$。

又注意到数据范围 $1 \le m \le 10^{18}$。

所以只在 $x \le 10^{18}$ 时，会出现 $f_{k}(x) = m$ 的情况。

所以 $S_{1}(x)$ 最大为 $17 \times 9 = 153$。

$S_{2}(x)$ 最大为 $18$。

$S_{3}(x)$ 就是一位数了，那么就有 $S_{i}(x)=S_{3}(x),i \ge 3$。

那么就有：
$$
f_{k}(x) =\begin{cases}
x & k=0\\
x+S_{1}(x) & k=1\\
x+S_{1}(x)+S_{2}(x) & k=2\\
x+S_{1}(x)+S_{2}(x)+(k-3+1) \times S_{3}(x) & k \ge 3
\end{cases}
$$

从 $S_{1}(x)$ 入手枚举，预处理对应的 $S_{2}(x)$ 和 $S_{3}(x)$，那么此时 $x=m-(S_{1}(x)+S_{2}(x)+(k-3+1) \times S_{3}(x))$，然后再判定一下 $x$ 十进制下各个位数的和是否与 $S_{1}(x)$ 相等，如果相等，那么 $(x,f_{k}(x))$ 就为一个交点。

统计一下答案即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t,k;
int s2[155],s3[155];
ll m;
void init() {
	for(int i=0;i<=153;i++) {
		int x=i;
		while(x) s2[i]+=x%10,x/=10;
	}
	for(int i=0;i<=153;i++) {
		int x=s2[i];
		while(x) s3[i]+=x%10,x/=10;
	}
	return;
}
int main() {
	init();
	scanf("%d%d",&t,&k);
	while(t--) {
		scanf("%lld",&m);
		if(k==0) puts("1");
		else {
			ll ans=0ll;
			for(ll i=0;i<=153;i++) {
				ll x=m-(i+(k>=2)*s2[i]+s3[i]*max(1ll*k-3ll+1ll,0ll));
				ll sum=0ll;
				while(x) sum+=x%10,x/=10;
				if(sum==i) ans++;
			}
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：HirasawaYuii (赞：0)

# P12397 「FAOI-R9」函数大师 题解

[题目链接](https://www.luogu.com.cn/problem/P12397)

## 思路

$s(x)$ 意为 $x$ 的各位数字之和，下文以“缩”代指此类操作。

$S_k(x)$ 意为被缩了 $k$ 次后 $x$ 的各位数字之和。

$f_k(x) = \sum_{i=0}^{k}S_i(x) $。

由于 $1\le m\le 10^{18}$，所以 $s(m)$ 最大值即为 $9\times18=162$。

显然，$m$ 只能最多被缩 $3$ 次。

例如当 $m=199$ 时：$199\to 19\to 10\to1$。

引入一个概念，数根：一个正整数的各位数字相加，直到得到一个一位数。

当 $k>2$ 时，后面的 $\sum_{i=3}^{k}S_i(m)$ 显然都为 $m$ 的数根。

可得出：$f_k(x)=S_0(x)+S_1(x)+S_2(x)+S_3(x)\times(k-2)\left( k\ge2\right)$

将所有 $S_k(x)$ 消掉，设 $x$ 的数根为 $y$，可进一步得出：$f_k(x)=x+s(x)+s(s(x))+y\times(k-2) \left( k\ge2\right)$

代入 $m=f_k(x)$ 并移项后可得 $x+s(x)+s(s(x))=m-y\times(k-2)$

由此，问题转化为了如何求该方程解的根。

从上面的概念和推导可得出，$1\le y\le 9,2\le s(x)+s(s(x))\le 200$（此处 $200$ 为一个粗略值，大致是通过 $162+9=171$ 类似的操作得出）。

观察到数据范围很小，可以用枚举来解决。

这里选择枚举 $y$，得出每一个 $t=m-y\times(k-2)$ 后再枚举 $x\in[t-200,t]$​ 并代入尝试，若相等即为一解。

这里还需要注意枚举 $x$ 的原根须和当前 $y$ 相等，具体处理方式可看代码。

最后统计解的个数即可。

此外，还需处理 $k=0$ 与 $k=1$ 的情况。$k=0$ 显然直接输出 1，$k=1$ 也可通过类似 $k\ge2$​ 的情况枚举即可]。


## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define mst(x, y) memset(x, y, sizeof(x))
#define pii pair<ll, ll>
#define fi first
#define se second
#define mp(x, y) make_pair(x, y)

ll read(){ll x = 0, f = 1;char c = getchar();while(c < '0' || c > '9'){if(c == '-') f = -1;c = getchar();}while(c >= '0' && c <= '9'){x = 10*x+c-'0';c = getchar();}return f*x;}
void writ(ll x){if(x < 0){putchar('-');x = -x;}if(x > 9) writ(x/10);putchar(x%10 | 0x30);return;}
void write(ll x){writ(x);puts("");}
void wr(ll x){writ(x);putchar(' ');}
// const ll N = , inf = 0x3f3f3f3f;

ll k, m, ans;
ll s(ll x){
	ll res = 0;
	while(x){
		res += x%10;
		x /= 10;
	}
	return res;
}
void init(){
	m = read(), ans = 0;
}
void solve(){
	init();
	if(k == 0){
		write(1);
	}
	else if(k == 1){
		for(ll x = max(1ll, m-200);x <= m;x++){
			if(x+s(x) == m){
				ans++;
			}
		}
		write(ans);
	}
	else{
		for(ll y = 1;y <= 9;y++){
			ll t = m-y*(k-2), x = max(1ll, t-200);
			x = x+(y-x%9+9)%9;
			for(;x <= t;x += 9){
				if(x+s(x)+s(s(x)) == t){
					ans++;
				}
			}
		}
		write(ans);
	}
}

signed main(){
	ll T = read();
	k = read();
	while(T--) solve();
	return 0; 
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

求满足 $f_k(x)=m$ 的 $x$ 数量。

因为 $S_0(x)=x$，所以问题就变成求 $\sum\limits_{i=1}^{k}S_i(x)=m-x$。

注意到左式很小，考虑枚举左边，但是左边存在依赖关系，不妨枚举 $z=S_1(x)$，这样可以 $O(\log z)$ 求出左式，记作 $h$，$x=m-h$。

然后判断实际的 $S_1(x)$ 是否与 $z$ 相等即可。

## 代码实现

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define int long long 
using namespace std;
using namespace __gnu_pbds;
int T,k,n,ans;
int get_sum(int n){
    int ret=n,tmp;
    for(int i=1;i<k;i++){
        tmp=0;
        while(n)
            tmp+=(n%10),n/=10;
        ret+=(n=tmp);
        if(n<10){
            ret+=n*(k-i-1);
            break;
        }
    }
    return ret;
}
void Main(){
    ans=0;
    cin>>n;
    if(k==0){
        cout<<"1\n";
        return;
    }
    for(int i=1,tmp;i<=9*18;i++){
        int v=get_sum(i);
        v=n-v,tmp=0;
        while(v)
            tmp+=(v%10),v/=10;
        if(tmp==i)
            ans++;
    }
    cout<<ans<<'\n';
    return;
}
signed main(){
    ios::sync_with_stdio(0);
    for(cin>>T>>k;T;--T)
         Main();
    return 0;
}
```

---


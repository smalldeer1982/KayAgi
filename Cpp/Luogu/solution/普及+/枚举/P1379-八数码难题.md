# 八数码难题

## 题目描述

在 $3\times 3$ 的棋盘上，摆有八个棋子，每个棋子上标有 $1$ 至 $8$ 的某一数字。棋盘中留有一个空格，空格用 $0$ 来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为 $123804765$），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。


## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7rhxbnup.png)

图中标有 $0$ 的是空格。绿色格子是空格所在位置，橙色格子是下一步可以移动到空格的位置。如图所示，用四步可以达到目标状态。

并且可以证明，不存在更优的策略。

## 样例 #1

### 输入

```
283104765
```

### 输出

```
4
```

# 题解

## 作者：hidden_er (赞：331)

上次发过超长代码的题解后惨遭同校大佬批斗


痛定思痛，在向大佬学习之后，带来最短代码（滑稽）

思路大体与之前相同：

map去重，

在这里只需要一个队列，因为需要较少步数达到的状态一定在步数较多的状态前入队列

（我之前那个最长程序也可以用一个队列，不需要两个队列辗转，只要加个步数的记录就行了）


stl大法好%%%


```cpp
#include<iostream>
#include<map>
#include<queue>
#include<algorithm>
#define ll long long//在这里看到一种很骚的操作：直接把int定义成long long；main函数用signed类型--麻麻再也不怕我忘开long long了！
using namespace std;
const ll dx[]={-1,0,0,1},dy[]={0,-1,1,0};//转移数组；
ll n;
int  main()
{
    cin>>n;
    queue<ll> q;
    q.push(n);
    map<ll,ll> m;
    m[n]=0;
    while(!q.empty())
    {
        int u=q.front(); //初始状态入队列
        int c[3][3],f=0,g=0,n=u;q.pop();
        if(u==123804765)break;
        for(ll i=2;i>=0;i--)
            for(ll j=2;j>=0;j--)
            {
                c[i][j]=n%10,n/=10;
                if(!c[i][j])f=i,g=j;
            }
        for(ll i=0;i<4;i++)
        {
            ll nx=f+dx[i],ny=g+dy[i],ns=0;
            if(nx<0||ny<0||nx>2||ny>2)continue; //越界就不执行
            swap(c[nx][ny],c[f][g]);
            for(ll i=0;i<3;i++)
                for(ll j=0;j<3;j++)ns=ns*10+c[i][j];//矩阵转数列 
            if(!m.count(ns))
            {
                m[ns]=m[u]+1;//map去重的同时顺便统计到达这个状态所需的步数
                q.push(ns);
            }
            swap(c[nx][ny],c[f][g]);//状态复原
        }
    }
    cout<<m[123804765]<<endl; // map的下标直接用数列表示
    return 0;
}

```

---

## 作者：Drinkkk (赞：196)

Upd on 2022.3.23：这篇题解是我小学时期（2017.12.31）写的，没想到一直到现在这篇题解都不停地有新的评论，所以趁还没退役，来修缮一下这篇题解的内容。这个号已经不用了，但偶尔还是会来上一下的，有问题可以在评论区提出。

**思路一**：用最朴素的 BFS，每当搜索到一个新的状态时，就将这个新的状态放入队列内，然后存储 0 的位置，以便于以后的搜索。但是我们发现，这样就会有很多重复的状态进入队列，导致搜索的速度变慢了，而且还占用了许多的空间。

**思路二**：这里与 **思路一** 不同的地方在于多了一个对于搜索到的新状态进行判重。这样就可以减少内存的消耗，但是问题来了，这样子就会花费更多的时间，所以我们实际上是在以时间换空间，效率较为低下，所以这种方法是不可行的。


**思路三**：我们用双向宽搜解决问题，用一个结构体和队列 $f$ 来存储相关数据，$f[i].map[j][k]$ 表示这个队列里的第 $i$ 组数据的状态的第 $j$ 行 $k$ 列，并用 $w_i$ 和 $w_j$ 来表示 0 所在的位置的纵坐标以及横坐标，用 $t$ 来表示步数，我们用 $f[1]$ 来存储开始的状态，用 $f[2]$ 来存储结束的状态。

接着，我们用 $c$ 来表示它是从起始状态开始延伸过来的，还是从目标状态开始延伸过来的。若 $c=1$，就表示它是从起始状态开始延伸过来的，否则当 $c=2$ 时就表示它是从目标状态开始延伸过来的。所以当搜索新的状态时发现有两个重复的话就判断一下他们的 $c$ 是否相等，若我们用 $\text{now}$ 来表示与新搜索到的状态相同的状态的位置，$\text{tou}$ 表示当前的状态，那么答案等于 $(f[\text{now}].c+f[\text{tou}].c+1)$。其效率相比于 **思路二** 有显著提升。

如果你还不明白什么是双向宽搜的话，在这里我做了一个 $3 \times 3$ 的示例，浅绿色为起始状态，深绿色为目标状态，黄色代表要搜索的点。


 ![](https://cdn.luogu.com.cn/upload/pic/12638.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/12639.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/12640.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/12641.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/12642.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/12643.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/12644.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/12645.png) 
 ![](https://cdn.luogu.com.cn/upload/pic/12646.png) 


**思路四**：既然双向宽搜 AC 不了，那能不能够再优化呢？其实，我们大部分的时间都是用来进行状态的判重了。那么，怎样能够更快地进行判重呢？考虑暴力！我们可以用一个九维的 $\text{bool}$ 数组 $cq$ 来进行判重，假设我们用一个二维数组 $nz$ 来存储新的状态的话，那么我们在判重时仅需要判断 $cq[nz[1][1]][nz[1][2]][nz[1][3]][nz[2][1]][nz[2][2]][nz[2][3]][nz[3][1]][nz[3][2]][nz[3][3]]$ 的值为真还是假即可，我把它为真时算作已有重复，为假时为没有重复，虽然这个式子有点长，但是我们在判重时仅需判断 1 次，大大地减少了判重时的运算量。

对于输入为 ``603712458`` 的数据，这种做法比前面的要快上 100s+，也充分地体现了优化的重要性。

注意当起点和终点状态相同的时候要特判。

由于每种状态只会搜一次，所以不会 TLE。本题中运用的用九位数组判断状态重复性的思想，其实就是状态压缩的基础，你可以将这九个数压成一个九位数，然后用个 ``set`` 之类的东西存状态，也是可以的。

### 代码实现

```cpp
#include <cstdio>
#include <cstring>
struct node{ int map[5][5],wi,wj,t; } f[100001];
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
int xd[5][5]={0,0,0,0,0,
              0,1,2,3,0,
              0,8,0,4,0,
              0,7,6,5,0,
              0,0,0,0,0};
bool cq[9][9][9][9][9][9][9][9][9];
int nz[5][5];
bool zp(int tou)
{
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            if(f[tou].map[i][j]!=xd[i][j])
            {
                return false;
            }
        }
    }
    return true;
}
bool pdc()
{
    if(cq[nz[1][1]][nz[1][2]][nz[1][3]][nz[2][1]][nz[2][2]][nz[2][3]][nz[3][1]][nz[3][2]][nz[3][3]]==true)
    {
        return false;
    }
    return true;
}
void paint()
{
    cq[nz[1][1]][nz[1][2]][nz[1][3]][nz[2][1]][nz[2][2]][nz[2][3]][nz[3][1]][nz[3][2]][nz[3][3]]=true;
}
void bfs()
{
    int tou=1,wei=2;
    while(tou<wei)
    {
        if(zp(tou)==true)
        {
            printf("%d",f[tou].t);
            return ;
        }
        for(int i=0;i<=3;i++)
        {
            int nx=f[tou].wi+dx[i];
            int ny=f[tou].wj+dy[i];
            if(nx>=1 && nx<=3 && ny>=1 && ny<=3)
            {
                memset(nz,0,sizeof(nz));
                for(int j=1;j<=3;j++)
                {
                    for(int k=1;k<=3;k++)
                    {
                        nz[j][k]=f[tou].map[j][k];
                    }
                }
                nz[f[tou].wi][f[tou].wj]=f[tou].map[nx][ny];
                nz[nx][ny]=0;
                if(pdc()==true)
                {
                    for(int j=1;j<=3;j++)
                    {
                        for(int k=1;k<=3;k++)
                        {
                            f[wei].map[j][k]=nz[j][k];
                        }
                    }
                    f[wei].t=f[tou].t+1;
                    f[wei].wi=nx;
                    f[wei].wj=ny;
                    paint();
                    if(zp(wei)==true)
                    {
                        printf("%d",f[tou].t+1);
                        return ;
                    }
                    wei++;
                }
            }
        }
        tou++;
    }
}
int main()
{
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            char ch;
            scanf("%c",&ch);
            f[1].map[i][j]=ch-'0';
            if(f[1].map[i][j]==0)
            {
                f[1].t=0;
                f[1].wi=i;
                f[1].wj=j;
            }
        }
    }
    bfs();
    return 0;
}
```

---

## 作者：niiick (赞：138)

怎么所有dalao写的都是双向bfs，
蒟蒻写了一发IDA*， 本以为会T，结果其实~~跑得还挺快？~~

迭代加深的A*算法

所谓迭代加深就是每次**限制搜索深度**，
这样可以在整个搜索树深度很大而答案深度又很小的情况下大大提高效率

使k从1开始不断加深枚举，
作为最大步数进行**迭代加深搜索**判断，而对于不用移动的情况可以一开始直接特判

在这里我们的**A*估价函数**设置为

**当前状态还有多少个位置与目标状态不对应**

若**当前步数+估价函数值>枚举的最大步数**
则直接返回

当然这只是基本思路，搜索还可以有很大优化

我们在搜索中再加入**最优性剪枝**，
显然当前枚举下一个状态时如果**回到上一个状态肯定不是最优**，
所以我们在枚举下一状态时加入对这种情况的判断

将状态数组对称排列会很方便进行这一操作
```cpp
int nxtx[]={0,1,-1,0};
int nxty[]={1,0,0,-1};
```
*********************

```cpp
//niiick
#include<iostream>
#include<string>
#include<map>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long lt;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

char ss[15];
int ans[4][4]=
{{0,0,0,0},
 {0,1,2,3},
 {0,8,0,4},
 {0,7,6,5}};
int a[5][5],k,judge;
int nxtx[]={0,1,-1,0};
int nxty[]={1,0,0,-1};

int check()
{
    for(int i=1;i<=3;++i)
    for(int j=1;j<=3;++j)
    if(ans[i][j]!=a[i][j])return 0;
    return 1;
}

int test(int step)
{
    int cnt=0;
    for(int i=1;i<=3;++i)
    for(int j=1;j<=3;++j)
    if(ans[i][j]!=a[i][j]){ if(++cnt+step>k) return 0;}
    return 1;
}

void A_star(int step,int x,int y,int pre)
{
    if(step==k){ if(check())judge=1; return;}达到当前限制的最大深度
    if(judge) return;
    for(int i=0;i<4;++i)
    {
        int nx=x+nxtx[i],ny=y+nxty[i];
        if(nx<1||nx>3||ny<1||ny>3||pre+i==3) continue;//加入了上述最优性剪枝
        swap(a[x][y],a[nx][ny]);
        if(test(step)&&!judge) A_star(step+1,nx,ny,i);//A*估价合法再向下搜索
        swap(a[x][y],a[nx][ny]);
    }
}

int main()
{
    int x,y;
    scanf("%s",&ss);
    for(int i=0;i<9;++i)
    {
        a[i/3+1][i%3+1]=ss[i]-'0';
        if(ss[i]-'0'==0)x=i/3+1,y=i%3+1;
    }
    if(check()){printf("0");return 0;}//特判不用移动
    while(++k)//枚举最大深度
    {
        A_star(0,x,y,-1);
        if(judge){printf("%d",k);break;}
    }
    return 0;
}
```

---

## 作者：lx_zjk (赞：123)

# 八数码~~难~~题

这真是一道蓝题，~~蓝是水的颜色~~

本人准备了三种AC此题的方法

从上到下时间复杂度依次降低

话不多说

# NO.1 朴素BFS + MAP
~~STL大发吼~~

用map将每一步的状态记录下来，然后上BFS

是本蒟蒻花~~半个小时~~写的，代码量略长

不开O2 6418ms ~~巨慢无比~~

```cpp
//八数码BFS版  

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f=1,x=0;
    char ch;
    do {
        ch=getchar();
        if(ch=='-')f=-1;
    } while(ch>'9'||ch<'0');
    do {
        x=x*10+ch-'0';
        ch=getchar();
    } while(ch>='0'&&ch<='9');
    return f*x;
}

string a;

string goal="123804765";

map<string,bool>vis;

struct node{
    string a;
    int step;
};

queue<node>q;

inline void expand(node b){	
    string s=b.a;
    int st=b.step;
    int cnt=st;
//	if(cnt==11) exit(0);

    string olds=s;
    for(int i=0;i<9;i++){
        if(s[i]=='0')
        {
            if(i>=3&&i<=8){//向上拓展 
                swap(s[i],s[i-3]);
            //	cout<<cnt<<" q 1 "<<s<<endl;
                if(s==goal){
                    cout<<st+1<<endl;
                    exit(0);
                }
                if(vis[s]==0){
                    vis[s]=1;
                    q.push({s,st+1});
                }
                swap(s[i],s[i-3]);
            }
            if(i>=0&&i<=5)//向下拓展 
            {
                swap(s[i],s[i+3]);
        //		cout<<cnt<<" q 2 "<<s<<endl;
                if(s==goal){
                    cout<<st+1<<endl;
                    exit(0);
                }
                if(vis[s]==0){
                    vis[s]=1;
                    q.push({s,st+1});
                }
                swap(s[i],s[i+3]);
            }
            if(i%3==1||i%3==2)//向左拓展 
            {
                swap(s[i],s[i-1]); 
        //		cout<<cnt<<" q 3 "<<s<<endl;
                if(s==goal){
                    cout<<st+1<<endl;
                    exit(0);
                }
                if(vis[s]==0)
                {
                    vis[s]=1;
                    q.push({s,st+1});
                }
                swap(s[i],s[i-1]); 
            }
            if(i%3==1||i%3==0)//向右拓展 
            {
                swap(s[i],s[i+1]); 
        //		cout<<cnt<<" q 4 "<<s<<endl;
                if(s==goal){
                    cout<<st+1<<endl;
                    exit(0);
                }
                if(vis[s]==0){
                    vis[s]=1;
                    q.push({s,st+1});
                }
                swap(s[i],s[i+1]); 
            }
            break;
        }
    }
    return ;
}


inline void BFS()
{
    
    node r;
    r.a=a;r.step=0;
    q.push(r);
    vis[a]=1;
    while(!q.empty())
    {
        node sss=q.front();q.pop();
        expand(sss);
    } 
}

int main(){
    cin>>a;	
    if(a==goal) {
        cout<<"0\n";
        return 0;
    }
    BFS();
    return 0;
}

```


# NO.2 HASH+朴素BFS
------------
上代码

用hash表将每一个状态记录下来，然后就是BFS板子

不开O2 1202ms ~~好慢啊~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MOD 3600
struct node{
    int p,t;char c[9];
}num;
queue<node>q;
int st,en,ans;
vector<long long>hash[MOD];
int a[9];
bool found=false;
const int w[10][5]={{0},{2,2,4},{3,1,3,5},{2,2,6},{3,1,5,7},{4,2,4,6,8},{3,3,5,9},{2,4,8},{3,5,7,9},{2,6,8}};
char che[9]={'1','2','3','8','0','4','7','6','5'};
inline bool check(node x){
    for(int i=0;i<=8;i++)
    if(x.c[i]!=che[i]) return false;
    return true;
}
int b[9]; 
inline bool checkh(node x){
    long long num=0,tmp;
    for(int i=0;i<9;i++)
    {
        a[i]=x.c[i]-'0';
        num=num*10+a[i];
    }
    tmp=a[8]*256+a[7]*128+a[6]*64+a[5]*32+a[4]*16+a[3]*8+a[2]*4+a[1]*2+a[0];
    for(int i=0,to=hash[tmp].size();i<to;i++){
        if(hash[tmp][i]==num) return false;
    }
    hash[tmp].push_back(num);
    return true;
}
inline void make(node x){
    for(int i=1;i<=w[x.p][0];i++){
        node nxt=x;
        nxt.p=w[x.p][i];
        nxt.t=nxt.t+1;
        char ch;
        ch=nxt.c[x.p-1],nxt.c[x.p-1]=nxt.c[w[x.p][i]-1],nxt.c[w[x.p][i]-1]=ch;
        if(check(nxt)){found=true,ans=nxt.t;return;}
        if(checkh(nxt))q.push(nxt);
    }
}
int main()
{
    scanf("%s",num.c);
    for(int i=0;i<=8;i++){
        if(num.c[i]!=che[i]){
            found=true;
            break;
        }
    }
    if(!found){puts("0");return 0;}
    found=false;
    for(int i=0;i<=8;i++)
    {
        if(num.c[i]=='0'){
            num.p=i+1;
            break;
        }
    }	
    q.push(num);
    while(!q.empty())
    {
        make(q.front());
        q.pop();
        if(found) break;
    }
    printf("%d",ans);
    return 0;
} 
```
# NO.3 双端队列BFS

不开O2 148ms ~~质的飞跃~~

双端队列是在网上看博客学的

以为是用deque或者两个queue实现的

然而一位大佬给了我启发 

可以用一个queue 写双端队列

把初始状态和最后状态一起存进去，这样代码量可以更少

也就A了这道题
```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f=1,x=0;
    char ch;
    do {
        ch=getchar();
        if(ch=='-')f=-1;
    } while(ch>'9'||ch<'0');
    do {
        x=x*10+ch-'0';
        ch=getchar();
    } while(ch>='0'&&ch<='9');
    return f*x;
}

ll a,goal=123804765;

ll s[4][4];

map<int,int>dis;

map<int,int>vis;

int dx[5]={1,-1,0,0};
int dy[5]={0,0,1,-1};

inline void deque_BFS()
{
    queue<ll>q;
    if(a==goal){
        cout<<"0\n";
        exit(0);
    }
    vis[a]=1;vis[goal]=2;
    dis[a]=0;dis[goal]=0;
    q.push(a);
    q.push(goal);
    while(!q.empty())
    {
        ll now,cur=q.front();q.pop();
        now=cur;
        int sx,sy;
        for(int i=3;i>=1;i--)
        {
            for(int j=3;j>=1;j--)
            {
                s[i][j]=now%10;now/=10;
                if(!s[i][j])sx=i,sy=j;	
            }
        }
        for(int i=0;i<4;i++)
        {
            int xx=sx+dx[i],yy=sy+dy[i];
            if(xx<1||xx>3||yy<1||yy>3) continue;
            swap(s[sx][sy],s[xx][yy]);
            now=0;
            for(int j=1;j<=3;j++)
            {
                for(int k=1;k<=3;k++)
                {
                    now=now*10+s[j][k];
                }
            }
            if(vis[cur]==vis[now])
            {
                swap(s[sx][sy],s[xx][yy]);
                continue;
            }
            if(vis[now]+vis[cur]==3)
            {
                cout<<dis[cur]+dis[now]+1<<endl;
                exit(0); 
            }
            
            dis[now]=dis[cur]+1;
            vis[now]=vis[cur];
            q.push(now);
            swap(s[sx][sy],s[xx][yy]);
        }
    }
}

int main(){
    a=read();
    deque_BFS(); 
    return 0;
}

```

### update 2019.8.16 更新了 $A*$ 和 $IDA*$的做法

# NO.4 $A*$ 做法

$A*$其实是优先队列$priority$$_$$queue$ $BFS$ 加上一个估价函数

$F(N) = H(N) + G(N)$

$F*(N) = H*(N) + G*(N)$

但是时间复杂度还是$IDA*$快

### CODE 
```cpp
#include <bits/stdc++.h>

//#include <windows.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

int x, y, now;

char s[15];

string goal = "123804765";

int h(string cur){
	int res = 0;
	for (int i = 0; i < 9; i ++ ){
		if (goal[i] != cur[i] && goal[i] != 0) res++;
	}
	return res;
} 

struct node{  
    int f, step;  
    string now; 
	bool operator < (const node &x) const {  
        return f > x.f;        
    }  
};

int ans = 0x7fffffff;

priority_queue <node> q;

map <string, bool>mp;

map <string, int> dis;

int dx[4] = {0, 1, -1, 0};
int dy[4] = {1, 0, 0, -1};

void A_STAR(){
	while (!q.empty())
	{
		node t = q.top(); q.pop();
		string cur = t.now;
		if (cur == "123804765") {
			printf("%d\n", t.step);
			exit(0);
		}
		int sx, sy;
		for(int i = 0; i < 9; i ++ ){
	       	if(cur[i] - '0' == 0) sx = i / 3 + 1, sy = i % 3 + 1;
		}
	//	0 1 2 3 4 5 6 7 8 
	//	(1, 1) (1, 2) (1, 3)
	//	(2, 1) (2, 2) (2, 3)
	//	(3, 1) (3, 2) (3, 3)
 	//	(xx - 1) * 3 + yy - 1
		int tmp1 = (sx - 1) * 3 + sy - 1;
		for (int i = 0; i < 4 ; i ++ ){
			int xx = dx[i] + sx, yy = dy[i] + sy;			
			if (xx < 1 || xx > 3 || yy < 1 || yy > 3) continue;
			int tmp2 = (xx - 1) * 3 + yy - 1;
			swap(cur[tmp1], cur[tmp2]);
			if (mp[cur] == 0 || (mp[cur] == 1 && (t.step + 1) < dis[cur])) {
				dis[cur] = t.step + 1;
				q.push((node){h(cur) + t.step + 1, t.step + 1, cur}); 
				mp[cur] = 1;
			}
			swap(cur[tmp1], cur[tmp2]);
		}
	}
}

int main() {
    scanf("%s",s);
    for(int i = 0; i < 9; ++ i ) 
		if(s[i] - '0' == 0) x = i / 3 + 1, y = i % 3 + 1;
    if (h(s) == 0) {puts("0"); return 0;}
    while(q.size()) q.pop();
	q.push((node){h(s), 0, s});
	mp[s] = 1;
	dis[s] = 0;
	A_STAR();
	return 0;
}
```

# NO.5 $IDA *$ 算法

不开O2 462ms

修改下 估价函数(h()) 估计时间复杂度会降更低

### code
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
	ll f = 1, x = 0; char ch;
	do {ch = getchar(); if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
	do {x = x * 10 + ch - '0'; ch = getchar();} while (ch >= '0' && ch <= '9');
	return f * x;
}

char s[15];

char goal[] = {'1', '2', '3', '8', '0', '4', '7', '6', '5'};

int maxdepth;

inline int h(char *cur) {
	int res = 0;
	for (int i = 0; i < 9; i ++ ) {
		if (goal[i] != cur[i] && cur[i] != 0) res++;
	}
	return res;
}

int dx[] = {0, 1, -1, 0};
int dy[] = {1, 0, 0, -1};


bool dfs (int depth, char *a, int pre) {
	if (h(a) == 0) return true;
	if (depth + h(a) - 1 > maxdepth) return false;
	int sx, sy;
	for (int i = 0; i < 9; i ++ )
		if (a[i] == '0') sx = i / 3 + 1, sy = i % 3 + 1;
	for (int i = 0; i < 4; i ++ ) {
		int xx = dx[i] + sx, yy = dy[i] + sy;
		if (xx < 1 || xx > 3 || yy < 1 || yy > 3 || (pre + i == 3)) continue;
		swap(a[(xx - 1) * 3 + yy - 1], a[(sx - 1) * 3 + sy - 1]);
		if (dfs(depth + 1, a, i)) return true;
		swap(a[(xx - 1) * 3 + yy - 1], a[(sx - 1) * 3 + sy - 1]);
	}
	return false;
}

int main() {
	scanf ("%s", s);
	if (h(s) == 0) {puts("0"); return 0;}
	for (maxdepth = 1; ; maxdepth ++ ) {
		if (dfs(0, s, -1)) {
			printf ("%d\n", maxdepth);
			return 0;
		}
	}
	return 0;
}

```

---

## 作者：Christopher_Yan (赞：96)

八数码难题，一道经典的BFS题目（反正我也不会什么康托展开...）写完后，发现众多题解中并没有几篇双向BFS，于是就来发一波题解（尽管单向的BFS也能AC，但双向BFS明显要高效许多）。

#### 思路如下：
首先我们可以将这个3x3的矩阵转化为一个九位数字，存入队列时也会方便很多，按方向尝试0周围的数字，判重记答案时可以使用map。然后就这样进行单向的BFS，accepted！

#### 重要优化：双向BFS
双向BFS的使用要求之一就是知道终止状态，这道题目实在是在合适不过了。	这里可以将判重数组的值设为0,1,2，分别代表未访问过，顺序访问过，逆序访问过，当某个状态被顺序逆序都访问过时，那么这就是连接答案的那个状态。如果看到这里还不甚理解，不用着急，代码是比较清晰的。

#### 双向BFS满分代码：
```
#include<bits/stdc++.h>
#define ll long long int
using namespace std;
int n,g=123804765;
short a[4][4],fx,fy,nx,ny;
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1}; //代表向四个方向移动
queue<int> q;
map<int,int> v;
map<int,int> ans;
void solve()
{
	if(n==g) 		 //特判
    {
        printf("0");
        exit(0);
    }				
    q.push(n);		//起始状态与终止状态同时入队
    q.push(g);
    ans[n]=0;
    ans[g]=1;		
    v[g]=2;			//将两个方向标记成不同的数字
    v[n]=1;
    while(!q.empty())
    {
        ll now,cur=q.front();
        q.pop();
        now=cur;
        for(int i=3;i>=1;i--)
            for(int j=3;j>=1;j--)
            {
                a[i][j]=now%10,now/=10;
                if(a[i][j]==0) fx=i,fy=j;
            }
        for(int i=0;i<4;i++)
        {
            nx=fx+dx[i];
            ny=fy+dy[i];
            if(nx<1 || nx>3 || ny<1 || ny>3) continue;
            swap(a[fx][fy],a[nx][ny]);
            now=0;
            for(int p=1;p<=3;p++)
                for(int j=1;j<=3;j++)
                    now=now*10+a[p][j];	//数字转矩阵
            if(v[now]==v[cur]) 
            {
                swap(a[fx][fy],a[nx][ny]); //一定要先换回来再跳过
                continue;
            }
            if(v[now]+v[cur]==3)		//说明新延伸出的点已被另一方向访问过
            {
                printf("%d",ans[cur]+ans[now]);//两方向步数和即为总步数
                exit(0);
            }
            ans[now]=ans[cur]+1;
            v[now]=v[cur];				//与上一状态的方向保持一致
            q.push(now);
            swap(a[fx][fy],a[nx][ny]); //不要忘记将还回来
        }	
    }
}
int main()
{
    scanf("%d",&n);
    solve();
}
```
最后说一下这个双向的效率有多高：

单向BFS：8388ms.

双向BFS：228ms.

这里列举了两组数据，科学准确的说明了....

所以我认为这道题目写双向BFS是个不错的选择。



---

## 作者：zhz小蒟蒻 (赞：43)

### 前言：对于八数码难题这道经典bfs的题目，~~（这是我听学长讲的）~~，我花了不止多久的时间才过了它。  

**思路：首先，我们可以用bfs，在队列中存储每一步的状态，并将这一个状态取hash值，~~也就是众位大佬讲的康托展开~~，如果当某一个状态的hash值已经等于了目标状态的hash值，那么直接输出它的步数即可。（因为广搜有一个第一个搜到的目标状态必定是最优的特性） **

### 补充——康托展开（以下内容选自度娘）：  
```
康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。  
康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。
```        
**康托展开运算:
       $X=a_n(n-1)!+a_{n-1}(n-2)!+...+a_1\cdot0!$  
其中$a_i$为整数,并且$0\leq a_i<i,1\leq i \leq n$。    
$a_i$表示原数的第$i$位在当前未出现的元素中是排在第几个  
**    
**举个例子说明：  
在$(1,2,3,4,5)$ $5$个数的排列组合中，计算 $34152$ 的康托展开值。  
首位是 $3$ ，则小于 $3$ 的数有两个，为 $1$ 和 $2$ ,则首位小于 $3$ 的所有排列组合为 $a[5]\times(5-1)!$  
第二位是 $4$，则小于 $4$ 的数有两个，为 $1$ 和 $2$，$a[5]=2$ ,注意这里 $3$ 并不能算，因为 $3$ 已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此$a[4]=2$。  
第三位是 $1$，则在其之后小于 $1$ 的数有 $0$ 个，所以 $a[3]=0 $。  
第四位是 $5$，则在其之后小于 $5$ 的数有 $1$ 个，为 $2$，所以 $a[2]=1$。  
最后一位就不用计算啦，因为在它之后已经没有数了，所以 $a[1]$ 固定为 $0$   
根据公式：  
  	$X=2\times 4!+2\times3!+0\times2!+1\times1!+0\times0!=61$  
所以 $34152$的康托展开值是 $61$ （代码实现就在本题中有）  
**  
### 回归正题
根据上面我们的思路，我们把代码实现出来就是这样：  
```
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
typedef unsigned long long ull;  //纯属闲得蛋痛
ull end;
int book[3000000];  //判断每一个状态是否出现过，也就是排重（值可以不开这么大）
int v1[4]={0,1,0,-1};  //方向数组，枚举0可以走的四个方向
int v2[4]={1,0,-1,0};
struct node
{
    int x,y,kkk;  //x,y表示0在a数组中的下标,kkk表示当前的步数
    ull hash1;    //康托展开的哈希值
    int a[4][4];  //状态数组
};
node que[2000001]; //结构体
ull hash1(char s[])//康托展开的函数
{
	int f[9]={0,1,2,6,24,120,720,5040,40320}; //先将每一个阶乘的值存下来，方便直接运算
	int book[9]={0}; //判断每一个数是否已经出现
    ull ans=0,x=8;
    for(int i=0;i<strlen(s);i++) //将传来的字符数组遍历一遍
    {
    	int num=0;   //num存储在第i个数前的数的数目
    	book[s[i]-'0']=1; //先标记第s[i]个数已经出现
    	for(int j=0;j<s[i]-'0';j++) //遍历s[i]之前的数
    		if(!book[j])  //如果这个数没出现过，那么num++
				num++;
    	ans+=num*f[x--];  //康托展开的公式，每一项等于这一项数前未出现过的数乘以这个数位数的阶乘
    }
    return ans;  //返回康托展开的值
}
int main()
{
    int head=1,tail=2;
    int i,j,k,n;
    char s[9],ss[9];
    scanf("%s",s);
    end=hash1("123804765");  //首先将目标状态的值存下来
    que[head].kkk=0;  //步数初始化为0
    que[head].hash1=hash1(s);  //将初始状态的哈希值放入hash1
    book[que[head].hash1]=1;  //标记目标状态已经出现
    for(i=1;i<=3;i++)
    	for(j=1;j<=3;j++)
    	{
    		que[head].a[i][j]=s[(i-1)*3+j-1]-'0';
    		if(que[head].a[i][j]==0)
    		{
    			que[head].x=i;
    			que[head].y=j;
    		}
		}//将初始状态存进二维数组，并记录下0的位置
    while(head<=tail) //bfs
    {
        if(que[head].hash1==end) //如果当前状态的值等于目标状态的值，那么就输出步数
        {
            printf("%d",que[head].kkk);
            return 0;
        }
        for(k=0;k<4;k++) //否则，枚举四个方向
        {
        	char ch[9]={0};  //用来转换的字符串
            int tx=que[head].x+v1[k],ty=que[head].y+v2[k];//0移动后的位置
            if(tx<1 || tx>3 || ty<1 || ty>3) continue; //如果移动出了边界，那么这个状态肯定不合法
            for(i=1;i<=3;i++)
            	for(j=1;j<=3;j++)
            		que[tail].a[i][j]=que[head].a[i][j]; 
            swap(que[tail].a[tx][ty],que[tail].a[que[head].x][que[head].y]); //将上一个状态转移过来，再转换位置
            for(i=1;i<=3;i++)
            	for(j=1;j<=3;j++)
            		ch[(i-1)*3+j-1]=que[tail].a[i][j]+'0'; //将二维数组存进字符数组
            ull ans=hash1(ch);  //获取这个二位数组的哈希值（康托展开值）
            if(!book[ans]) //如果这个状态没有出现过，那么将他加入队列
            {
                book[ans]=1; //标记这个状态出现过
                que[tail].hash1=ans;  //记录下它的哈希值
                que[tail].x=tx; que[tail].y=ty;  //存下目前状态0的位置
                que[tail].kkk=que[head].kkk+1; //将步数+1
                tail++;
            }
        }
        head++;  //千万要加上这句话，不然就会死循环
    }
    return 0;
}
```
### 这就是本蒟蒻的见解，希望能对大家有些帮助  
### 如果文章有问题，或者那些地方不懂，可以私信发给我

---

## 作者：EndSaH (赞：35)

$2018.11.5$ $Update:$ 整体调整了码风(但是纯代码那里没有调整) 加入了 $LaTeX$ ~~难以想象一个不用LeTeX的文章是多么丑陋~~

难得写个蓝题不看题解 那就来水一篇题解吧 $233333$

~~（话说这题真的是蓝题吗 map去重单向广搜套板子跟魔板2730一样的啊）~~

我采用的方法是：
## 双向广搜+哈希链表
双向广搜我想楼上大佬已经讲的比较清楚了

以后要记得 看到这种
### 目标和初始状态确定
的题目一定要双向广搜！！！（比单向快很多）

重点介绍一下哈希链表
~~（不要问我为什么不用map 就是想撞个壁23333）~~

正如楼上大佬所说 如果直接将这 $9$ 个数字凑成 $9$ 位数再用 $ bool$ 数组去重 绝对是不行的（$1e9$ 还不炸内存吗）

但是不去重又会 **TLE** 该怎么办呢？

方法多种多样 康托展开 $(unordered)map$ 进制转换 等等等等

哈希表也是一个不错的选择 这里 我选择了常用的取模法求哈希值

先看代码：
```cpp
struct Node
//个人习惯 结构体和函数开头大写
{
	int key, step;
	bool head;
	Node *next;
	Node(){key = step = head = 0;next = NULL;}
    //构造函数初始化
}hash[mod1 + 2];
//这里我的mod1取了1e5+7
```
解释一下:
开结构体存节点 各个变量所表示的分别是：

$key$ ：关键值

$step$ ：步数

$head$ ：这个节点隶属于初始还是目标，很重要

$*next$ ：指向下一个节点的指针 用作链表 

$hash$ 数组：以 $hash$ 值为下标 即可访问相应节点

看到这里 你也许产生了疑问：

明明 $hash$ 值已经是一个关键值了（作为下标用来访问数组）
那么 $key$ 是用来干嘛的？

你可以将 $hash$ 数组 抽象为这么一个表：

|  哈希值|
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
|1|  |  |  |  |  |  |  |
|2|  |  |  |  |  |  |  |
|3|  |  |  |  |  |  |  |
|4|  |  |  |  |  |  |  |
|5|  |  |  |  |  |  |  |
|6|  |  |  |  |  |  |  |
|7|  |  |  |  |  |  |  |
|……|  |  |  |  |  |  |  |
|(此列即下标)|  |  |  |  |  |  |  | |

这是最初始的状态 数组内部都为空 没有链表

现在 插入一个元素：$(1)$

计算其哈希值为 $1$ $mod$ $(1e5+7)=1$

那么查询 $hash$ 数组
```cpp
int a = 1, H = a % mod1;
hash[H].key == 0
```
查找到其key值 发现为零

就表示这个节点没有被访问过

那么 插入 $(1)$ 这个元素：
```cpp
if(hash[H].key == 0)
	hash[H].key = a,
    ......;
```
现在的哈希表变成了这样

|哈希值|
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
|1|$key=1$,(...)|  |  |  |  |  |  |
|2|  |  |  |  |  |  |  |
|3|  |  |  |  |  |  |  |
|4|  |  |  |  |  |  |  |
|5|  |  |  |  |  |  |  |
|6|  |  |  |  |  |  |  |
|7|  |  |  |  |  |  |  |
|……|  |  |  |  |  |  |  |
|(此列即下标)|  |  |  |  |  |  |  | |

（省略号就是省略了其余状态, $head$ 和 $step$ 等）

那么 再来 插入 $(1e5+9)$ 这个元素
```cpp
int b = 1e5 + 9, H = b % mod1(==2);
hash[H].key == 0
```
查询到其 $key$ 值为 $0$, 那么就继续插入：
```cpp
if(hash[H].key == 0)
	hash[H].key = b,
    ....;
```
|  哈希值|
|:----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
|1|$key=1$,(...)|  |  |  |  |  |  |
|2|$key=1e5+9$,(...)|  |  |  |  |  |  |
|3|  |  |  |  |  |  |  |
|4|  |  |  |  |  |  |  |
|5|  |  |  |  |  |  |  |
|6|  |  |  |  |  |  |  |
|7|  |  |  |  |  |  |  |
|……|  |  |  |  |  |  |  |
|(此列即下标)|  |  |  |  |  |  |  | |

看起来 这一点也不难写吧？

然而 无论是什么方法 单哈希总是会出现冲突的时候

（也许这个题会不冲突？我不会证明 只好认真写完233）

比如 现在再插入一个值：$(2e5+16)$
```cpp
int c = 2e5 + 16, H = c % mod1(==2)
hash[H].key == 1e5+9
```
这时候 发现取模法出现冲突了 那么该怎么放呢？

这时候 $*next$ 也就是链表的作用体现出来了

那么我们这么放:

|  哈希值|
|:----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
|1|$key=1$,(...)||  |  |  |  |  |
|2|$key=1e5+9$,(...)|--->|$key=2e5+16$,(...)|  |  |  |  |
|3|  |  |  |  |  |  |  |
|4|  |  |  |  |  |  |  |
|5|  |  |  |  |  |  |  |
|6|  |  |  |  |  |  |  |
|7|  |  |  |  |  |  |  |
|……|  |  |  |  |  |  |  |
|(此列即下标)|  |  |  |  |  |  |  | |
“$---->$”就是我抽象的链23333
表示链表

写成代码 该怎么实现？
```cpp
if(hash[H].key != 0 && hash[H].key != c)
//如果key == c说明这是同一个值 不需要插入
{
	Node *newnode=new Node;
    newnode->key=c;
    ......;
    hash[H].next=newnode;
}
```
$next$ 表示该节点的下一个链接节点

因为初始值赋为了 $NULL$ 所以不能直接操作 $next$ 指针

需要附设一个 $newnode$ 指针 并用 $new$ 动态分配空间

那么一个哈希链表就如此实现了！是不是很简单？

如果已经链接了 从第一个遍历到最后一个再插入就可以了
```cpp
Node *now = &hash[H];
while(now->next)//等价于 now->next != NULL
	now=now->next;
```
这样子 遍历到最后再插入就好了

这种哈希表最差都是一个线性的链表

不过最差情况基本不可能出现吧（除非你傻子一样的设 $mod1=2$）

一般冲突也不会产生多少次的（甚至不产生都很有可能）

哈希链表的原理和实现大概讲完了 那么我们回到具体的题目：

要用哈希链表完成去重的工作，那么我们的表就得支持查询和插入两种操作

但是 仔细想想 具体题目具体分析 貌似可以直接把查询和插入融为一体？

我的去重代码是这样的
```cpp
bool Query(const CB& x, bool head)
//返回值为true则表示没有搜过
//head表示是从哪个节点（头或尾）扩展而来
//CB：CheckerkBoard,棋盘，我自己定义的结构体
{
	int num = 0, sum1, sum2;
//num用于计算当前状态的那个九位数 sum1是取模mod1后的值
//sum2是没有必要的 我强行双哈希 原本key是存num的 我改成了存sum2- -
	For(i, 3)
		For(j, 3)
			num = num * 10 + x.value[i][j];
//#define For(i, j) for(register int (i) = 0; (i) < (j); ++(i))
//开宏定义简化代码
//value就是棋盘上的数字
	sum1 = num % mod1, sum2 = num % mod2;
	if(!hash[sum1].key)
//如果key值为0 代表没有出现过 return true表示没搜到的同时顺手插入一下链表
	{
		hash[sum1].key = sum2;
		hash[sum1].head = head;
		hash[sum1].step = x.step;
		return true;
	}
	if(hash[sum1].key == sum2)
//如果key值与sum2相等 则证明已经放过这个值 即已经搜过
	{
		if(head != hash[sum1].head)
//敲黑板！！！head这个值的作用在这里就体现出来了
//第一个没有结构体的head是这个函数传进来的参数
//两个head都是一个意思 表示是从哪个节点（头或尾）扩展而来
//如果这个节点搜过 那么就判断
//要是head不相等 就说明是两棵不同搜索树同时搜到了这个节点
//两个搜索树产生了交叉 即已经搜到了答案
//答案路径就是 头->交叉点->尾
//可以证明最优(当前层次即当前步数）
//这就是双向bfs的精髓之处
		{
			flag = true;
			ans = x.step + hash[sum1].step;
//应用全局变量flag表示已经搜到答案 ans存储答案
//这也是为什么我的哈希表顺手存了个步数
//可能有些人（就是我）会想不通 觉得ans应该等于：
//x.step + hash[sum1].step -1或者是+1
//这个就自己画一下搜索树推吧
		}
		return false;
	}
	else
	{
//如果key != sum2 就是产生冲突了
//那么我们遍历链表 看看是不是有这个节点
		Node *now = hash[sum1];
		while(now->next)
		{
			now = now->next;
			if(now->key == sum2)
			{
//这里同上 如果已经搜到过 就判断一下head的值 不同则表示搜索完成
				if(head != now->head)
				{
					flag = true;
					ans = now->step + x.step;
				}
				return false;
			}
		}
//没找到 return true表示没搜过 顺手插入一下 
		Node *newnode = new Node;
		newnode->key = sum2;
		newnode->head = head;
		now->next = newnode;
		return true;
	}
}
```
顺便放上我的双向bfs：(代码里很多注释, 别跳过去了233)
```cpp
void BFS()
{
	queue<CB> q1;
	queue<CB> q2;
// 用STL的队列 懒得手打了23333
	start.step = goal.step = 0;
	q1.push(start);
	q2.push(goal);
	while(true)
	{
		if(q1.size() > q2.size())
// 节点少的先扩展 双向bfs默认规则
		{
			CB now = q2.front();
			q2.pop();
			For(i, 4)
			{
				int xx = now.spx + dx[i], yy = now.spy + dy[i];
				if(xx < 0 or xx > 2 or yy < 0 or yy > 2)
// or 和 || 是等效的- -同样的还有and(与)和xor(异或)等等
					continue;
				CB wib = now;
				wib.step = now.step + 1;
				wib.spx = xx, wib.spy = yy;
				swap(wib.value[xx][yy], wib.value[now.spx][now.spy]);
//这里解释一下 因为一个空格只能跟附近四个换 
//那就开个常量数组 跟平常走迷宫的数组一样 不要傻傻的写4次代码233
//spx与spy表示“0” 即空格所在位置
				if(Query(wib, 0))
					q2.push(wib);
				if(flag)
					return;
			}
		}
		else
		{
			CB now = q1.front();
			q1.pop();
			For(i, 4)
			{
				int xx = now.spx + dx[i], yy = now.spy + dy[i];
				if(xx < 0 or xx > 2 or yy < 0 or yy > 2)
					continue;
				CB wib = now;
				swap(wib.value[xx][yy], wib.value[now.spx][now.spy]);
				wib.spx = xx, wib.spy = yy;
				wib.step = now.step + 1;
				if(Query(wib, 1))
					q1.push(wib);
				if(flag)
					return;
			}
		}
		if(flag)
			return;
	}
}
```
说到这里 大家大致明白了这道题的思路了吧？
放上完整无注释代码
```cpp
#include<iostream>
#include<queue>
#define For(i,j) for(register int (i)=0;(i)<(j);++(i))

using std::cin;
using std::cout;
using std::queue;
using std::swap;
using std::endl;

const int mod1=1e5+7,mod2=1e6+9,dx[]={0,0,1,-1},dy[]={1,-1,0,0};

bool flag;
int ans;
struct Node
{
	int key,step;
	bool head;
	Node *next;
	Node(){key=step=head=0;next=NULL;}
}hash[mod1+2];
struct CB
{
	int value[3][3],spx,spy,step;
	void init()
	{
		value[0][0]=1;
		value[0][1]=2;
		value[0][2]=3;
		value[1][0]=8;
		value[1][1]=0;
		value[1][2]=4;
		value[2][0]=7;
		value[2][1]=6;
		value[2][2]=5;
		spx=1,spy=1;
	}
	bool operator== (const CB &x) const
	{
		For(i,3)
			For(j,3)
				if(value[i][j]!=x.value[i][j])
					return false;
		return true;
	}
}start,goal;
bool Query(const CB &x,bool head)
{
	int num=0,sum1,sum2;
	For(i,3)
		For(j,3)
			num=num*10+x.value[i][j];
	sum1=num%mod1,sum2=num%mod2;
	if(!hash[sum1].key)
	{
		hash[sum1].key=sum2;
		hash[sum1].head=head;
		hash[sum1].step=x.step;
		return true;
	}
	if(hash[sum1].key==sum2)
	{
		if(head!=hash[sum1].head)
		{
			flag=true;
			ans=x.step+hash[sum1].step;
		}
		return false;
	}
	else
	{
		Node *now=&hash[sum1];
		while(now->next)
		{
			now=now->next;
			if(now->key==sum2)
			{
				if(head!=now->head)
				{
					flag=true;
					ans=now->step+x.step;
				}
				return false;
			}
		}
		Node *newnode=new Node;
		newnode->key=sum2;
		newnode->head=head;
		now->next=newnode;
		return true;
	}
}
void BFS()
{
	queue <CB> q1;
	queue <CB> q2;
	start.step=goal.step=0;
	q1.push(start);
	q2.push(goal);
	while(true)
	{
		if(q1.size()>q2.size())
		{
			CB now=q2.front();
			q2.pop();
			For(i,4)
			{
				int xx=now.spx+dx[i],yy=now.spy+dy[i];
				if(xx<0||xx>2||yy<0||yy>2)
					continue;
				CB wib=now;
				wib.step=now.step+1;
				wib.spx=xx,wib.spy=yy;
				swap(wib.value[xx][yy],wib.value[now.spx][now.spy]);
				if(Query(wib,0))
					q2.push(wib);
				if(flag)
					return;
			}
		}
		else
		{
			CB now=q1.front();
			q1.pop();
			For(i,4)
			{
				int xx=now.spx+dx[i],yy=now.spy+dy[i];
				if(xx<0||xx>2||yy<0||yy>2)
					continue;
				CB wib=now;
				swap(wib.value[xx][yy],wib.value[now.spx][now.spy]);
				wib.spx=xx,wib.spy=yy;
				wib.step=now.step+1;
				if(Query(wib,1))
					q1.push(wib);
				if(flag)
					return;
			}
		}
		if(flag)
			return;
	}
}
int main(int argc,char *argv[])
{
	std::ios::sync_with_stdio(false);
	cin.tie(NULL);
	char ch;
	For(i,3)
		For(j,3)
		{
			cin>>ch;
			if(ch=='0')
				start.spx=i,start.spy=j;
			start.value[i][j]=ch-'0';
		}
	goal.init();
	if(goal==start)
	{
		cout<<0;
		return 0;
	}
	BFS();
	cout<<ans;
	return 0;
}
```
（记得特判初始跟结束相等的特殊情况！(别看了第31个点我说的就是你)）

~~以为能AC交上去结果90 看到那个expected 0我就知道出了什么事了~~

~~顺手重载了个运算符判相等233(实际上不需要)~~

（还有我不明白的是
为什么题解双向广搜会有几百ms？~~我才0ms~~）

# 祝大家早日成为神牛牪犇！！

# $(Update:NOIP2018rp++)$

---

## 作者：伟大的王夫子 (赞：33)

如果想要更好的体验，可以到[我的博客](https://www.luogu.org/blog/I-AK-IOI/)去看

我使用的算法是IDA_star

好处在于效率高，不用hash

我们想想，假设每一步都是有意义的，那么一个数字成功对上也要移动他们的曼哈顿距离次

所以，我们将估价函数设计为所有数字与目标状态中数字的曼哈顿距离之和（当然0不算，否则你就可以高兴的WA了）

还有一个显然的优化，就是记录上一次的操作

而且我们不一定要用二维数组，可以用一个string来保存状态。对于一个string中的下标i，纵坐标为i/3, 横坐标为i%3。对于二维数组下标x, y, string中的下标便为x * 3 + y

还有不明白的，请看代码
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
string st, ed;//起始状态和目标 
int depth;//搜索深度 
//估价函数，为每个数字的曼哈顿距离之和 
int hfunc(string st) {
	int ans = 0;
	for (register int i = 0; i < st.size(); ++i) {
		if (st[i] == '0') continue;//0不算，否则会WA 
		int j = ed.find(st[i]), r = i / 3, c = i % 3;
		int x = j / 3, y = j % 3;
		//横坐标为/3, 纵坐标为%3 
		ans += abs(r - x) + abs(c - y);
	}
	return ans;
}
const int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};
//IDA_star
//除了估价函数，还有一个显然的优化是记录上一次的操作 
bool dfs(int now, int pre) {
	int cnt = hfunc(st);
	if (!cnt) return 1;
	if (now + cnt > depth) return 0;
	//当前步数+估价>深度限制，立即回溯 
	int pos = st.find('0'), x = pos / 3, y = pos % 3;
	for (register int i = 0; i < 4; ++i) {
		int nx = x + dx[i], ny = y + dy[i];
		if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || nx * 3 + ny == pre) continue;
		//数组中的下标为横坐标*3+纵坐标 
		swap(st[pos], st[nx * 3 + ny]);
		if (dfs(now + 1, pos)) return 1;
		swap(st[pos], st[nx * 3 + ny]);
	}
	return 0;
}
int main() {
	cin >> st;
	ed = "123804765";
	depth = hfunc(st);
	while (depth <= 27 && !dfs(0, -1)) ++depth;
	cout << depth << endl;
}
```
跑得还很快

[评测记录](https://www.luogu.org/record/22955029)


---

## 作者：SSSF (赞：17)

我给你说个大实话

迭代加深就是深搜和广搜的英雄结合体

太妙了  

太强了

这道题用个迭代加深分分钟ac

~~然而我用了两小时学习迭代加深~~

所谓迭代加深就是将深搜限制一个深度，再扩展这个情况下的所有情况

这样有个好处，就是在答案很浅的情况，你可以很快搜出答案而不用顺藤摸瓜找下去，那样tle。

这个题就是一个实践迭代的好题吧

我看了第一篇题解才做的题，但是我觉得有的地方讲的我不太懂，所以写了详细的注释，发给大家一个更好懂的版本？？？



```cpp
//A*算法 +深搜 
//最优性剪枝有两个
//第一个是当前一定不是最优解见test
//第二个是当前状态在以前出现过见pre 
#include <iostream>
#include <cstdio>
using namespace std; 
char s[10];
bool judge;
int sta[4][4],x,y,k=2;
int ans[4][4]={{0,0,0,0},{0,1,2,3},{0,8,0,4},{0,7,6,5}};
//方向设成这样很有讲究
//把左右两步相加等于3，上下两步相加等于3
//如果说上一步是向左你这一步向右，或者是上一步向上这一步向下，就回到上次状态了吧？
//回到上次状态就重复了直接过滤return
//方便后面check 
int dx[4]={0,1,-1,0};
int dy[4]={1,0,0,-1};
//判当前状态是否与目标状态吻合 
bool check(){
    for(int i=1;i<=3;i++)
    for(int j=1;j<=3;j++)
    if(ans[i][j]!=sta[i][j])return 0;
    return 1;
}
//最优性剪枝 
//如果当前状态和目标状态的不同点+已经走的步数>枚举的深度就不用走下去 
bool test(int step){
    int diff=0;
    for(int i=1;i<=3;i++)
    for(int j=1;j<=3;j++)
    if(ans[i][j]!=sta[i][j]){
        if(++diff+step>k)return 0; //在循环内部判，更好 
    } 
    return 1;
}
//算法核心
//第一步是看这个步骤到达没有 
void Astar(int step,int x,int y,int pre){
    if(step==k){
        if(check())judge=1;//这里不应该把check和step一起形成条件判断，因为这样的话到了k步还会一直搜下去 
        return;
    }
    if(judge)return;
    for(int i=0;i<4;i++){//四面广搜 
        int nx=x+dx[i];
        int ny=y+dy[i];
        if(nx>3||nx<1||ny>3||ny<1||pre+i==3)continue;//这个就是那个判断有没有回到上次状态的请况，简直大佬！ 
        swap(sta[nx][ny],sta[x][y]);
        if(test(step))Astar(step+1,nx,ny,i);
        swap(sta[nx][ny],sta[x][y]);
    }
}
int main() {
    scanf("%s",&s);
    for(int i=0;i<9;i++){
        sta[i/3+1][i%3+1]=s[i]-'0';
        if(s[i]-'0'==0){x=i/3+1;y=i%3+1;}
    }
    if(check()){
        printf("%d ",0);
        return 0;
    }
    while(++k){
        Astar(0,x,y,-1);
        if(judge){
            printf("%d",k);
            break;
        }
    }
    return 0;
}
```


---

## 作者：zsc2003 (赞：15)


首先感谢老师的指导！！！


在此引用一下老师的讲解


康拓展开


如果按照平常的思路，把 $x$ 的位置看做 $0$ ，一共有 $8!$ 个状态，来判断某一个状态是否被访问过。 

但是问题来了？

怎么把一个带有 $x$ 的数组转变为转变为数字呢？

第一个联想到的就是 $STL$ 中的 $map$ ，但是 $map$  的速度太慢了，会超时，这个时候我们就要用一种快速的方法把这个带有 $x$ 的数组转换为数组，那就是 $hash$ ，如何$hash$ 就是用康拓展开这个公式。 

这个公式的描述：
$X=a_n*(n-1)!+a_{n-1}*(n-2)!+...+a_i*(i-1)!+...+a_2*1!+a_1*0!$  $a_i$ 表示所有未出现的元素中比 $a_i$ 这个元素小的个数，他是最小的就为 $0$ . 

这个里面有几个关键词就是前面未出现的所有元素和为出现的元素; 

我们来举个例子 

数组 $ \{1,2,3 \}$ 按从小到大的排列一共 $6$ 个：$123 \ 132 \ 213 \ 231 \ 312 \ 321$。 

有一个数组 $ \{2,5,7,8 \} $ 求它的一个排列 $7528$ 的对应的值 

$ a_4=7$ （注意这里的 $7$ 表示的是元素，不是数字，下同） 这个元素在 前面未出现的所有元素 $ \{2,5,7,8 \}$ 中是前面有几个比它小数？其中 $2,5$ 都比他小所以$a_4 = 2$； 

$a_3=5$ 这个元素在前面未出现的所有元素 $ \{2,5,7 \}$(元素 $8$ 已经出现过了，所以不满足红字的条件)中，有一个比它小的数字，所以 $a_3 = 1$； 

$a_3=2$ 这个元素在前面未出现的所有元素 $ \{2,7 \}$ 中，有 $0$ 个比它小的数字，所以 $a_3 = 0$； 

$a_3=8$ 这个元素在前面未出现的所有元素 $ \{7 \}$ 中，有 $0$ 个比它小的数字，所以 $a_3 = 1$； 

所以 $X = a_4*(4-1)!+a_3*(3-1)!+a_2*(2-1)!+a_1*(1-1)!$  

$X = 2*(3!) + 1*(2!) +0*(1!) + 0*(0!)= 14 $

上面就是康拓展开的一般过程，简单描述为已知一个排列，就能知道这个排列中元素的个数 $len$ ,我们可以通过这几个元素和 $len$ 将这个排列转换为一个十进制数 

上面所说的是康拓展开能解决的问题！


康拓逆展开生成全排列


既然我们可以通过排列把给出的元素转换为一个十进制数，那么肯定能通过这个这个逆向的过程，由 $X$ 计算出$a_1,a_2,a_3….a_n$ 

我们通过一个实例来解释上面所说的话，就比如上面那个解释康拓的例子，我们是否能过通过知道 $X=14$ 以及元素数组 $\{2,5,7,8\}$计算出 $a_1,a_2,a_3,a_4$ 呢？ 

在不考虑任何范围的情况下，列举不完全的下面几种情况： 

$14 = 1*(3!) + 1*(2!) +1*(1!) + 1*(0!)$ 

$14 = 2*(3!) + 2*(2!) +0*(1!) + 0*(0!)$ 

$14 = 0*(3!) + 6*(2!) +1*(1!) + 1*(0!)$ 

满足情况的之有第二种情况因为最后一个数也就是 $a_1$ 必须是 $0$ ，因为做最后只剩下一个数了，不可能再有比他小的数字了 

我们就用这种情况 $14 = 2*(3!) + 2*(2!) +0*(1!) + 0*(0!) $，来推算出一般的情况， 

1. 因为最后三个数加起来是不可能超过 $(3!)$ 的，所以我们可以通过 $14%(3!)$ 来得到 $a_4$ 

2. 用 $14/(3!)$ 的余数就是剩下的后面三个数之和，为 $4$ 

3. 然后通过 $4$ 在对 $(2！)$ 取模，就得到了 $a_3$ 

4. 然后一直重复的循环 $1,2$ 过程就能过依次得到 $a_n,a_{n-1},...a_1$ 

上面的过程也叫做辗转相除


通过上面的过程就能通过数组元素 $A_n$ 和对应的十进制数，就能求出这个排列


解题思路


懂得了上面的理论，我们就知道可以把 $x$ 的位置看做 $0$ ，然后将这个数值数组通过康拓展开为一个十进制数，表示初始状态，然后一共过 $(9!)$ 个状态，通过 $BFS$ 枚举这些状态，求得转化的路径。

下面附上我的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct position
{
	int a,b,c,d,e,f,g,h,i;
	long long step;
}f,t;
bool vis[400000];
queue<position> q;
int ans;
inline int jc(int n)
{
	int num=1;
	for(int i=2;i<=n;i++)
		num*=i;
	return num;
}
inline int ktzk(position f)//康拓展开 
{
	int a[15],num=0;
	bool v[15];
	for(int i=0;i<=10;i++)
		a[i]=v[i]=0;
	a[0]=f.a,a[1]=f.b,a[2]=f.c,a[3]=f.d,a[4]=f.e,a[5]=f.f,a[6]=f.g,a[7]=f.h,a[8]=f.i;	
	for(int j=0;j<9;j++)
	{
		int x=a[j];	
		int s=0;
		for(int i=0;i<x;i++)
			if(v[i]==0)
				s++;
		v[x]=1;
		num+=s*jc(9-j-1);
	}
	return num;
} 
int main()
{
	scanf("%1d%1d%1d%1d%1d%1d%1d%1d%1d",&f.a,&f.b,&f.c,&f.d,&f.e,&f.f,&f.g,&f.h,&f.i);
	f.step=0;
	q.push(f);
	ans=46685;//1 2 3 8 0 4 7 6 5
	while(!q.empty())
	{
		f=q.front();
		q.pop();
		int x=ktzk(f);
 		if(x==ans)
		{
			printf("%lld\n",f.step);
			return 0;
		}
		if(vis[x]==1)
			continue;
		vis[x]=1;
		f.step++;
		if(f.a==0)
		{
			t=f;
			swap(t.a,t.b);
			q.push(t);
			t=f;
			swap(t.a,t.d);
			q.push(t);
		}
		else if(f.b==0)
		{
			t=f;
			swap(t.b,t.a);
			q.push(t);
			t=f;
			swap(t.b,t.c);
			q.push(t);
			t=f;
			swap(t.b,t.e);
			q.push(t);
		}
		else if(f.c==0)
		{
			t=f;
			swap(t.c,t.b);
			q.push(t);
			t=f;
			swap(t.c,t.f);
			q.push(t);	
		}
		else if(f.d==0)
		{
			t=f;
			swap(t.d,t.a);
			q.push(t);
			t=f;
			swap(t.d,t.e);
			q.push(t);
			t=f;
			swap(t.d,t.g);
			q.push(t);
		}
		else if(f.e==0)
		{
			t=f;
			swap(t.e,t.b);
			q.push(t);
			t=f;
			swap(t.e,t.d);
			q.push(t);
			t=f;
			swap(t.e,t.f);
			q.push(t);
			t=f;
			swap(t.e,t.h);
			q.push(t);
		}
		else if(f.f==0)
		{
			t=f;
			swap(t.f,t.c);
			q.push(t);
			t=f;
			swap(t.f,t.e);
			q.push(t);
			t=f;
			swap(t.f,t.i);
			q.push(t);
		}
		else if(f.g==0)
		{
			t=f;
			swap(t.g,t.d);
			q.push(t);
			t=f;
			swap(t.g,t.h);
			q.push(t);
		}
		else if(f.h==0)
		{
			t=f;
			swap(t.h,t.i);
			q.push(t);
			t=f;
			swap(t.h,t.e);
			q.push(t);
			t=f;
			swap(t.h,t.g);
			q.push(t);
		}
		else if(f.i==0)
		{
			t=f;
			swap(t.i,t.h);
			q.push(t);
			t=f;
			swap(t.i,t.f);
			q.push(t);
		}
	}
	printf("no answer!\n");
	return 0;
}
```

---

## 作者：VitrelosTia (赞：9)

怎么题解区的巨佬用的都是双向广搜/哈希/康托展开/Astar，太高深了！这里介绍一种只要 $24$ 行的解法。

思路很简单，就用最基础的 BFS。`map`来记录当前状态需要多少步到达同时判重，当前状态符合结果就输出它的值，否则枚举每一种状态。

实现方面的难点在枚举每一种状态，方法是找到将空格在棋盘中的坐标，之后将这个点向四个方向移动并与原位置交换，判断交换后的的状态是否访问过（这里的判重可以用`map`)，如果没有访问过，就将它入队，此时它的值就是原状态的值加一。

代码写上了详尽的注释，可以配合食用。
```cpp
#include<bits/stdc++.h>
std::string s;
std::map<std::string,int> mp;//键为棋盘的状态，值为到达当前状态的长度
std::queue<std::string> q;
const int pos[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//四个方向
int main() {
	std::cin>>s;q.push(s);mp[s]=0;//读入；入队；记录长度
	while(!q.empty()){
		std::string t=q.front();q.pop();//BFS基本操作，将队首取出并记录；出队
		if(t=="123804765"){ printf("%d",mp[t]);return 0; }//如果到达符合结果，输出结束状态的键并结束程序
		int k=t.find('0'),x=k/3,y=k%3,dis=mp[t];//k是空格的位置，x，y空格的坐标，dis是当前状态的值
		for(int i=0;i<4;i++){
			int dx=x+pos[i][0],dy=y+pos[i][1];//dx,dy是新位置的坐标
			if(dx<0||dx>2||dy<0||dy>2) continue;//BFS基本操作，如果超过边界就略去
			std::swap(t[k],t[dx*3+dy]);//交换旧空格位置和新空格位置
			if(!mp.count(t)){//如果新状态没有访问过
				q.push(t);//将新状态入队
				mp[t]=dis+1;//新状态的键值就是旧状态+1
			}
			std::swap(t[k],t[dx*3+dy]);//接下来还要判断其他方向，所以要再交换一次回到初始状态
		}
	}
	return 0;
}
```


---

## 作者：Lee02 (赞：8)

## BFS模板题

通过题意我们可以知道：1.求解最少步数 2.达到最终状态

于是，我们肯定这是一道BFS了。

那么，如何来写呢？

### 状态表示
由于题目所给的是一个由数字组成的串，且有可能会有前导零。~~感谢前面大佬排雷~~   所以，我们可以将其存入一个**字符串**中，在使用'0'的坐标时，只需要做一些基本操作就行了（具体操作见代码）。

### 状态转移
1.记得判断是否到达目标位置，如果到达，返回distance

首先，我们要找出**0**的位置，然后我们将其分别向上下左右移动，看能否成功，如果可以，就在**判重**后塞入队列

#### 以上，就是这道题的具体思路，也大概是BFS的通用套路

上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int bfs(string s)
{
	map<string,int> d;//通过hash来保存距离
	queue<string> q;//BFS的对列
	int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};//偏差量数组
	string end="123804765";//中止情况
	q.push(s);
	d[s]=0;
	while(!q.empty())
	{
		string now=q.front();
		q.pop();
		
		if(now==end)
		{
			return d[now];
		}
		int dis=d[now];
		int pos=now.find('0');//查找0的位置
		int x=pos/3,y=pos%3;//1维->2维基本操作
	
		for(int j=0;j<4;j++)//遍历
		{
			int fx=x+dx[j],fy=y+dy[j];
			if(fx>=0&&fx<3&&fy>=0&&fy<3)
			{
				swap(now[fx*3+fy],now[pos]);
				if(!d.count(now))
				{
					d[now]=dis+1;
					q.push(now);
				}
				swap(now[fx*3+fy],now[pos]);//记得在变化后还原现场
			}
		}
	
	}
}
int main ()
{
	string s;
	cin>>s;//输入
	cout<<bfs(s)<<endl;//输出
	return 0;
} 
```

在AcWing上还有一道类似的题目，是考察将BFS路径保存的一道题，大家可以试试：叫[这个](https://www.acwing.com/problem/content/181/)。这个真的不是在打广告！！！求管理员大大不要拒！

思路：yxc

感谢！

---

## 作者：will7101 (赞：7)

IDA\*水过...

启发函数h为所有数字离正确位置的曼哈顿距离，每次增加搜索深度，搜到则出解。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 100005;
int fin[9][2] = {{1,1},{0,0},{0,1},{0,2},{1,2},{2,2},{2,1},{2,0},{1,0}};
struct State
{
    int a[3][3];
};
int lim, ok;
int H(const State &st)
{
    int ret = 0;
    for(int i = 0; i < 3; ++i){
        for(int j = 0; j < 3; ++j){
            int t = st.a[i][j];
            if(t) ret += abs(fin[t][0]-i) + abs(fin[t][1]-j);
        }
    }
    return ret;
}
void dfs(State st, int g)
{
    int h = H(st);
    if(ok || g + h > lim){
        return;
    }
    if(h == 0){
        ok = 1; return;
    }
    int x, y;
    for(int i = 0; i < 3; ++i){
        for(int j = 0; j < 3; ++j){
            if(st.a[i][j] == 0) x = i, y = j;
        }
    }
    if(x > 0){
        swap(st.a[x][y], st.a[x-1][y]);
        dfs(st, g+1);
        swap(st.a[x][y], st.a[x-1][y]);
    }
    if(x < 2){
        swap(st.a[x][y], st.a[x+1][y]);
        dfs(st, g+1);
        swap(st.a[x][y], st.a[x+1][y]);
    }
    if(y > 0){
        swap(st.a[x][y], st.a[x][y-1]);
        dfs(st, g+1);
        swap(st.a[x][y], st.a[x][y-1]);
    }
    if(y < 2){
        swap(st.a[x][y], st.a[x][y+1]);
        dfs(st, g+1);
        swap(st.a[x][y], st.a[x][y+1]);
    }
}
char ch[10];
int main()
{
    freopen("in.txt", "r", stdin);
    State st;
    scanf("%s", ch);
    for(int i = 0; i < 3; ++i){
        for(int j = 0; j < 3; ++j){
            st.a[i][j] = ch[i*3+j] - '0';
        }
    }
    for(lim = 0;; ++lim){
//        printf("lim=%d\n", lim);
        dfs(st, 0);
        if(ok) break;
    }
    printf("%d\n", lim);
    return 0;
}
```

---

## 作者：enceladus (赞：7)

# 八数码
## 非常经典的一道题

** 前面几个大佬已经说了主要思路 **

~~我这个蒟蒻只能搞搞优化~~

但是优化是可以暴力出奇迹的

~~虽然本来就是一个暴力的题~~



------------



#### 1.   	考虑空间优化
	首先八数码的矩阵用9个int有点浪费空间
 	9个数字都是0到9，可以用一个存就行了
 	分别放到每一个数位里
 	在矩阵和int之间转化就行了
 	附上辣鸡代码

```cpp
//#define I int
//#define fo(i,a,b) for(I i=a;i<b;++i)
//defeine FO(i,a,b) for(I i=a;i<=b;++i)
struct ED{
    short a[3][3];
};
struct EE{
    int v;
    int id;
    EE(I a=0,I b=0):v(a),id(b){}
};
struct D{
	I x;
	I y;
}dd[]={{0,1},{1,0},{-1,0},{0,-1}};
I d[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};

I toint(ED x){
    I a=0;
    fo(i,0,9){
        a+=x.a[i/3][i%3]*d[i];
    }
    return a;
}
ED toju(I x){
    ED s;
    fo(i,0,9){
        s.a[i/3][i%3]=x/d[i]%10;
    }
    return s;
}
```
	toint 和 toju 实现在矩阵和int的转化
	d数组处理出10的i次幂，方便使用
	EE结构里的ID是搜索深度，v是转换成int的矩阵
#### 2. 考虑判重
	搜索过程中为了防止重复元素入队，需要判重，怎么判？bool数组？
	0-9的数字一共有9876543210个 bool数组开不下，怎么办？
    用哈希！
    可以用STL的unordered_map
    也可以自己写哈希
   ~~反正乱搞就是了~~
    
 #### 3.BFS实现
 	直接上代码
    
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<vector>
#include<cstring>
#include<queue>
#include<unordered_map>
#define IL inline
#define R register
#define I int
#define OP operator
#define CT const
#define FUCK friend
#define FO(i,a,b) for(I i=a;i<=b;++i)
#define fo(i,a,b) for( I i=a;i<b;++i)
#define ll long long
CT I goal = 123804765;
typedef bool QWQ;
using namespace std;
struct ED{
    short a[3][3];
};
struct EE{
    int v;
    int id;
    EE(I a=0,I b=0):v(a),id(b){}
};
struct D{
	I x;
	I y;
}dd[]={{0,1},{1,0},{-1,0},{0,-1}};
I d[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};

I toint(ED x){
    I a=0;
    fo(i,0,9){
        a+=x.a[i/3][i%3]*d[i];
    }
    return a;
}
ED toju(I x){
    ED s;
    fo(i,0,9){
        s.a[i/3][i%3]=x/d[i]%10;
    }
    return s;
}
queue< EE >q;
unordered_map<I,I> mp;
I fir;
I main(){
    scanf("%d",&fir);
    q.push(EE(fir,0));
    while(!q.empty()){
            EE x=q.front();q.pop();
            if(mp.count(x.v))continue;
            mp[x.v]=1;
            if(x.v==goal){
                cout<<x.id<<endl;
                return 0;
            }else{
                ED xx=toju(x.v);
                fo(i,0,3){
                    fo(j,0,3){
                        if(xx.a[i][j]==0)
                            fo(k,0,4){
                                I fx,fy;
                                fx=i+dd[k].x;
                                fy=j+dd[k].y;
                                if(fx<0||fy<0||fx>=3||fy>=3)
								{
                                    continue;
                                }else{
                                	ED xxxx=xx;
                                    swap(xxxx.a[i][j],xxxx.a[fx][fy]);
                                    I xxx=toint(xxxx); 
	                                q.push(EE(xxx,x.id+1));
                                }
                            }
                	 }
           		}
			}	
       }
    return 0;
}
```
~~大括号太恶心了，不调了~~

	然后就没有然后了

---

## 作者：nono123 (赞：6)

蒟蒻的第二篇题解，希望不被Orz.....


------------
#在看到有确定的**起始状态**和**终止状态**时就很自然想到了
## **双向BFS**
但是怎么样存每个的状态呢？
如果直接将每个状态凑成**9位**的数字，再用bool去重，那么肯定要炸
(1e9的空间)

**那么，重点来了**
## 康托展开
康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。
其实可以理解为——由N个数字(不重复，且从小到大)组成的N位数字，再N个数字的全排列中的顺序（从小到大排序）

**比如**：
231

在由1,2,3这三个数字的全排列
：123 ，132 ，213 ，231 ，312 ，321
中排第3(从第0开始)，所以231的康托值为3

**那么康托值怎么求呢**？

X = A[0] * (n-1)! + A[1] * (n-2)! + … + A[n-1] * 0!~~(
怎么证明，我真的不知道，Orz)~~

A[i]表示在第i位数字之后比A[i]小的数字的数量

eg.  
	231=1x2 +1x1+0x1
    
    在第一位数字2后只有1个比2小：1  所以 1*（3-1）!
    
    在第二位数字3后只有1个比3小：1  所以 1*（2-1）!
    
    在第三位数字1后没有比1小的  所以0*(1-1)!
```cpp
int cantor(int *A,int n)//求康托值
{
	int ans=0,sum=0;
	for(int i=1;i<=n;i++)
	{
		sum=0;
		for(int j=i+1;j<=n;j++)
		{
			if(a[i]>a[j])sum++;
		}
		ans+=jc[n-i]*sum;
	}
	return ans;
}
```
同时知道康托值同时也可以求出那个数
```cpp
void ccantor(int n,int can)//有点丑
{
	for(int i=n;i>1;i--)
	{
		int p=can/jc[i-1];
		can=can-p*jc[i-1];
		int turns=0;
		for(int j=1;j<=n;j++)
		{
			if(vis[j]==0)
			{
				turns++;
			}
			if(p+1==turns)
			{
				a[n-i+1]=j;vis[j]=1;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(vis[i]==0)a[n]=i;
	}
}
```
那么本题自然就可以用康托展开来压缩空间
（讲九宫格形象为一列数）

# **上代码，代码里有注释**

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<iostream>
using namespace std;
///362880+10为九宫格康托展开最大值 
char Begin[10],End[10];///定义正向数列和反向数列 
int step[2][362890],pose,posb,m;///双向步数，正向空位地址，反向空位地址 
bool vis[2][362890];///双向访问标记 
struct node{
	char word[9];
	int poss;
	bool flag;
	node(){};
	node(const char a[],const int b,const bool c)///初始化双向九宫格的结构体函数 
	{
		strcpy(word,a),poss=b,flag=c;
	} 
}tmp;
queue<node> point;///一个队列 
int power[10]={1,1,2,6,24,120,720,5040,40320,362880};///康托展开的阶乘表 
bool flag[10];
int cantor(char s[])///康托展开模板 
{
	memset(flag,1,sizeof(flag));
	int ans=0,temp;
	for(int i=0;i<9;i++)
	{
		flag[s[i]-'0']=0;
		temp=0;
		for(int j=0;j<s[i]-'0';j++)
			if(flag[j])temp++;
		ans+=temp*power[8-i];
	}
	return ans;
}
int dir[4]={1,-1,3,-3};///九宫格上下左右的bfs 
int twobfs()///双向bfs 
{
	memset(vis,0,sizeof(vis));
	point.push(node(Begin,posb,0));///压入正反空位 
	point.push(node(End,pose,1));
	vis[0][cantor(Begin)]=vis[1][cantor(End)]=1;
	int temp,dx,temp2,pos;
	///temp存当前九宫格映射值,temp2存后一步映射，dx存下一步空格位置，pos为当前位置 
	while(!point.empty())//队列非空 
	{
		tmp=point.front();///取队头扩展 
		pos=tmp.poss;///存储当前空格位置 
		point.pop();///队头出队 
		temp=cantor(tmp.word);///九宫格离散化（康托） 
		if(vis[!tmp.flag][temp])///当前位置的反向bfs已被访问过，说明找到了解 
			return step[0][temp]+step[1][temp];
		for(int i=0;i<4;i++)
		{
			dx=pos+dir[i];///4个方向 
			if(dx>=0&&dx<=8&&(dx/3==pos/3||dx%3==pos%3))///0的位置在范围之内且保证同行同列交换（注意:是从0~8，而不是1~9[这里需要思考一下]） 
			{
				swap(tmp.word[dx],tmp.word[pos]);///交换0与隔壁的位置 
				temp2=cantor(tmp.word);///存储走后映射值 
				if(!vis[tmp.flag][temp2])///如果当前位置没被访问过 
				{
					vis[tmp.flag][temp2]=1;///标记为访问 
					step[tmp.flag][temp2]=step[tmp.flag][temp]+1;///当前方向步数+1 
					point.push(node(tmp.word,dx,tmp.flag));///压入队列 
				}
				swap(tmp.word[dx],tmp.word[pos]);///恢复原状态，以便下次移动 
			}
		}
	}
	return -1;///队列为空了还没找到最短路返回-1（当然本题保证一定有解） 
}
int main()
{
	for(int i=0;i<9;i++)///初始九宫格 
	{
		scanf(" %c",&Begin[i]);
		if(Begin[i]-'0'==0)posb=i;
	}
	End[0]='1';End[1]='2';End[2]='3';End[3]='8';End[4]='0';End[5]='4';End[6]='7';End[7]='6';End[8]='5';pose=4;
	///目标图已确认 
	printf("%d\n",twobfs());
	return 0;
}
```


这就是这道题，希望大家看的懂，QAQ...


# 扩展
本题保证了一定有解，可如果有无法达到的情况该怎么办呢？

那么我们把时间浪费在**无用**的bfs上，时间复杂度就会大大增加。

这里就有一种判断是否一定可以达到目标图的方法

# 逆序对
**注意：（0代表的是空格，而非是一个数值）**

思考1:

0在向左或向右走时，逆序对数会改变吗？
就像1234□5678 ==》123□456789 or
12345□678这样，他只是改变了空格的位置，而没有改变数字的位置。因此逆序对数不会发生改变

思考2：

0在上下移动时，逆序对数会改变吗？

分3类讨论（

x1 x2 x3

x4  □  x5

x6 x7 x8

①当x2<x3&&x2<x4时，逆序对数会减少2

②当x2>x3&&x2>x4时，逆序对数会增加2

③当x2<x3&&x2>x4||x2>x3&&x2<x4时，逆序对数不变（+1，-1）

因此，不论怎么移动空格的位置，逆序对的奇偶性是不会改变的

思考3

如果起始状态和终止状态的逆序对数奇偶性不同那么可以达到吗？

答案显然是**不能**的！因为2个若要达到目标状态，那么九宫格必然是完全相同的，那么必然他们的逆序对数奇偶性是相同的。那么你连奇偶性都无法保证相同，你能保证图相同吗？

所以判断逆序对奇偶性，就可以大大减少时间。（~~虽然这道题不需要，但是可以练一下思维码~~）
**而且一共只有9个数，求逆序对就不需要特别高级的算法来求**，**什么归并，树状数组都不需要啦**（所以逆序对优化自己打吧）

这就是这道题的思路（~~难得打了那么久，给个赞？~~）[挂个博客](http://www.luogu.org/blog/nono123/)


---

## 作者：Drifterming (赞：6)

/\*这道题一开始用的是map判重，TLE了俩点。然后改hash，全WA了，感觉我自己写hash选模数靠运气。

然后不写hash了，写进制位，AC了，因为知道了前八位数后，第九位就能确定，所以只求前八位数的和就可以。

楼下写的是字符串转数字，我写的是字符串转图来扩展状态，然后再将合法解转字符串加入搜索状态中并在转化过程中判重。

\*/






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#include<string> 
#include<queue>
using namespace std;
int pos,x,y,ans;
int sum;
string s;
char a[4][4];
struct state    //记录搜索状态 
{
    string s;    //字符串表状态 
    int step;    //到达这个状态需要几步 
}now,temp;
bool flag[88888888];    //八位数判重 
queue<state> que;        //搜索用的队列 
int cx[4]={-1,0,1,0};    //改方向用的数组 
int cy[4]={0,1,0,-1};
void mswap(char &a,char &b)        //手写swap 
{
    char c;
    c=a;a=b;b=c;
    return;
}
string change()        //将图转化成字符串，顺便求前八位数的和 
{
    sum=0;
    string s;
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            s+=a[i][j];
            if(!(i==3&&j==3)) sum=sum*10+a[i][j]-'0';    //求前八位数 
        }
    }
    return s;
}
void bfs()
{
    while(!que.empty())
    {
        pos=0;
        now=que.front();que.pop();
        for(int i=1;i<=3;i++)    //转化成一个3*3的矩阵 
        {
            for(int j=1;j<=3;j++)
            {
                if(now.s[pos]=='0') x=i,y=j;
                a[i][j]=now.s[pos++];
            }
        }
        for(int i=0;i<4;i++)    //上下左右四个方向找 
        {
            if(x+cx[i]>0&&x+cx[i]<4&&y+cy[i]>0&&y+cy[i]<4)
            {
                mswap(a[x][y],a[x+cx[i]][y+cy[i]]);        //换位 
                temp.s=change();    //将图转化成字符串，判重 
                if(temp.s=="123804765")        //到达了目标状态，输出答案 
                {
                    printf("%d",now.step+1);
                    return;
                }
                if(!flag[sum])        //当前状态没出现过，添加状态 
                {
                    flag[sum]=1;
                    temp.step=now.step+1;
                    que.push(temp);
                }
                mswap(a[x][y],a[x+cx[i]][y+cy[i]]);        //再换回来 
            }
        }
    }
}
int main()
{
    cin>>s;
    now.s=s;now.step=0;
    que.push(now);
    for(int i=0;i<8;i++)    //初始状态判重 
    {
        sum=sum*10+s[i]-'0';
    }
    flag[sum]=1;
    bfs();
    return 0;
}
```

---

## 作者：Ckger (赞：5)

发现自己最近非常黑，几次编译错误都是因为变量名产生歧义（在自己电脑上好好的）。
这道题目中最烦（猥）恼（琐）的无非就是判重了，~~其他的都很简单~~（个鬼）。

今天呢，我就给大家介绍一种判重查找的方法，我们可以用“康托展开”的方法.

我先大致讲一下康拓展开：

比如1～4的全排列，先看第一位，无论怎么选，都剩下三个数，转变为剩下三个数的全排列。众所周知，n个数的全排列有n！个。因此，确定第m位在n个数（一定要是剩下的，已选过的不算）中排第几（设为p），然后sum（位置）加上（n-1）！* p，直到n=1为止，最后sum++即可得到全排列s在n位全排列中的排名了

将方案（0~8排列组成的）在0~8九个数的全排列中查找位置（yasuo函数）：
```
int yasuo(char s[10])//s="012345678"  -->x=1
{
	int p,sum=0;//p为在s[m]之前的数
	for (int m=1;m<=9;m++)
	{
		p=0;
		for (int i=m+1;i<=9;i++)
			if (s[i]-'0'<s[m]-'0')
				p++;//每当有一个数比s[m]小，p++
		if (m<9) sum+=p*jc[9-m];//jc数组里装的阶乘
		else sum++;//注意最后sum要+1
	}
	return sum;//宿命即位置
}
```

还有将位置拓展成方案的函数（jieya函数）：
即是将之前的yasuo函数倒过来写一遍，不是用第m项的阶乘去乘上p，而是用总量/m项的阶乘 + 1得到p，再判重，最后将p加入数组，如下所示

```
void jieya(int x)	//x=1 --> s="012345678"
{
	int w,js=0,xx,w2,l;
	bool pc[10];
	memset(pc,false,sizeof(pc));
	for (int m=8;m>=1;m--)
	{
		js=0;
		w=x/jc[m]+1;//jc数组里装的阶乘
		xx=x%jc[m];
		x=xx;
		for (int i=1;i<=9;i++)
		{
			if (pc[i]==false) js++,l=i;
			if (js==w) w2=l-1,pc[l]=true;
		}
		now[9-m]=w2+'0';
	}
	for (int i=1;i<=9;i++)
		if (!pc[i])
		{
			w=i-1;
			break;
		}
	now[9]=w+'0';
}
```

接下来，有了这两个函数，我们就可以使方案与位置对应，从而快速地查找（时间效率为O(n方)，其实也可以用树状数组优化，只是本蒟蒻太渣了，就没写）。之后便是~~简单的~~bfs广搜来查找（广搜就不唠叨了，看代码）：

# code：


```
#include<bits/stdc++.h>
#define MAXN 400000
using namespace std;
char st[10],ed[10]={' ','1','2','3','8','0','4','7','6','5'},now[10],yyyy[10];
bool find1=false;
int mubiao,tmp,jc[10],dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};
int head,tail;
int dui[MAXN],step[MAXN];
bool chuxian[MAXN];
int yasuo(char s[10])//s="012345678"  -->x=1
{
	int p,sum=0;
	for (int m=1;m<=9;m++)
	{
		p=0;
		for (int i=m+1;i<=9;i++)
			if (s[i]-'0'<s[m]-'0')
				p++;
		if (m<9) sum+=p*jc[9-m];
		else sum++;
	}
	return sum;
}

void jieya(int x)	//x=1 --> s="012345678"
{
	int w,js=0,xx,w2,l;
	bool pc[10];
	memset(pc,false,sizeof(pc));
	for (int m=8;m>=1;m--)
	{
		js=0;
		w=x/jc[m]+1;
		xx=x%jc[m];
		x=xx;
		for (int i=1;i<=9;i++)
		{
			if (pc[i]==false) js++,l=i;
			if (js==w) w2=l-1,pc[l]=true;
		}
		now[9-m]=w2+'0';
	}
	for (int i=1;i<=9;i++)
		if (!pc[i])
		{
			w=i-1;
			break;
		}
	now[9]=w+'0';
}
int main()
{
	
	jc[1]=1;jc[2]=2;
	int sss=3;
	for (int i=3;i<=9;i++)
	{
		jc[i]=sss*jc[i-1];
		sss++;
	}
	memset(chuxian,false,sizeof(chuxian));
	mubiao=yasuo(ed);
	for (int i=1;i<=9;i++)
		cin>>st[i];
	dui[1]=yasuo(st);
	chuxian[dui[1]]=true;
	step[1]=0;
	head=1;
	tail=1;
	while(head<=tail)
	{
		jieya(dui[head]-1);//将当前的位置转化为方案存于now数组
		char sb[4][4];//不要在意变量名
		int cen=1,lie=1,lx,ly;
		for (int i=1;i<=9;i++)//将方案存于二维数组中
		{
			sb[cen][lie]=now[i];
			if (now[i]=='0') lx=cen,ly=lie;
			lie++;
			if (lie>3)
				lie=1,cen++;
		}
		char sc[4][4];//保存当前状态，以免丢失
			for (int i=1;i<=3;i++)
				for (int j=1;j<=3;j++)
					sc[i][j]=sb[i][j];
		for(int i=1;i<=4;i++)
		{
			for (int q=1;q<=3;q++)
				for (int j=1;j<=3;j++)
					sb[q][j]=sc[q][j];//提取当前状态
			int nx=lx+dx[i],ny=ly+dy[i];//拓展新方案
			swap(sb[lx][ly],sb[nx][ny]);//交换
			int sd=1;
			for (int ssss=1;ssss<=3;ssss++)
				for (int j=1;j<=3;j++)
					yyyy[sd]=sb[ssss][j],sd++;将新方案存于yyyy数组中
			if (nx>=1&&nx<=3&&ny>=1&&ny<=3)//如果方案可行
			{
				tmp=yasuo(yyyy);//tmp为当前方案的位置
				if(chuxian[tmp]==false)//如果方案没有过
				{
					chuxian[tmp]=true;//标记
					tail++;
					dui[tail]=tmp;
					step[tail]=step[head]+1;//赋值
					if(tmp==mubiao)//如果完成目标
					{
						cout<<step[tail];//输出
						find1=true;//标记已找到
						break;结束
					}
				}	
			}
			
		}
		if(find1) break;//如果找到则结束
		head++;//队首加加
	}
	if (!find1) cout<<"0";//如果没找到（不存在，因此一开始就是目标状态，输出0）
	return 0;
}
```

---

## 作者：_Sein (赞：5)

##  A* 做法

 - 什么为A*
 
   如果给定一个“目标状态”（如八数码中的目标状态），需要求出从出台到目标状态的最小代价。那么BFS甚至优先队列BFS都不够完善，多余的状态多过，导致程序过慢，TLE。一个状态的当前代价最小，但不意味着以后这个状态都保持最优，其他状态可能会成为最优解。这时候我们就可以用到**估计函数**来求求解了，保持现在最优以及未来估计最优。这就是所谓的A*算法。
   
 - 基本准则
 
 	因为A*实际上是一种启发式算法，所以没有什么固定的套路。
    
    但有基本准则：
    设当前状态state到目标状态所需代价的估计值为f(state)。
    
    设在未来搜索中，实际求出的从当前状态state到目标状态的最小代价为g(state).
    
    对于任意的state，应有f(state)≤g(state)。
    
    证明请参照lyd的算法进阶指南。
    
 
 - 思路
 
 	就是当前移动次数dis+当前状态下每一个点的位置到目标状态的位置的曼哈顿距离,每次取出堆顶(以堆顶的估计函数+dis为关键项)，就可以~~求出最短次数了~~。
 
 - 代码比较冗杂（~~请轻喷~~)
 ```cpp
 #include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int dx[4]={0,1,-1,0};
const int dy[4]={1,0,0,-1};
int d[9];
void pre()
{
    d[0]=1;for(int i=1;i<=8;i++)d[i]=d[i-1]*i;
}
struct node
{
    int dis,f,k,x,y,ans;
    int a[5][5];
    node(){dis=k=f=0;memset(a,0,sizeof(a));x=y=0;}
    bool operator <(const node &a)const{return f==a.f?dis>a.dis:f>a.f;}//重构小根堆 
    inline void kt()//康托展开 
    { 
        k=0;
        int b[20],len=0;
        for(int i=1;i<=3;i++)for(int j=1;j<=3;j++)b[++len]=a[i][j]+1;//相当于将一个3*3的图排成一行； 
        bool bo[20];memset(bo,false,sizeof(bo));//初始化 
        //统计当前这个是第几个康托排列 
        for(int i=1;i<=9;i++)
        {
            for(int j=1;j<b[i];j++)
            {
                if(bo[j]==false)
                {
                    k+=d[9-i];
                }
            }
            bo[b[i]]=true;
        } 
    }
    inline void find_f(const node &ed)//A*的估计函数f 
    {
        int x1=1,y1=1;bool ap[10];memset(ap,false,sizeof(ap));
        f=dis;
        while(x1<=3)
        {
            if(y1==4)x1++,y1=1;
            bool bk=true;
            for(int i=1;i<=3;i++)
            {
                for(int j=1;j<=3;j++)
                {
                    if(ap[ed.a[i][j]])continue;
                    if(ed.a[i][j]==a[x1][y1])
                    {
                        f+=abs(x1-i)+abs(y1-j);ap[a[x1][y1]]=true;
                        y1++;
                        bk=false;
                        break;
                    }
                }
                if(bk==false)break;
            }
        }
    }
};
node st,ed;
priority_queue<node>q;
bool v[510000];
int main()
{
    pre();
    memset(v,false,sizeof(v));
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
        	char c=getchar();
            st.a[i][j]=c-'0';if(st.a[i][j]==0){st.x=i,st.y=j;}
        }
    }
    ed.a[1][1]=1;ed.a[1][2]=2;ed.a[1][3]=3;
	ed.a[2][1]=8;ed.a[2][2]=0;ed.a[2][3]=4;
	ed.a[3][1]=7;ed.a[3][2]=6;ed.a[3][3]=5;
	ed.x=2,ed.y=2;
    st.kt();ed.kt();
    if(st.k==ed.k){printf("0\n");return 0;}
	v[st.k]=true;st.dis=0;st.find_f(ed);
    q.push(st);
    while(!q.empty())
    {
        node t=q.top();
        q.pop(); 
        for(int i=0;i<4;i++)
        {
            node now=t;
			int x=now.x+dx[i],y=now.y+dy[i];
            if(x<1||x>3||y<1||y>3)continue;
            int tw=now.a[now.x][now.y];now.a[now.x][now.y]=now.a[x][y];now.a[x][y]=tw;
            now.x=x,now.y=y;
            now.dis++;
            now.kt();
            if(v[now.k])continue;
            now.find_f(ed);
            v[now.k]=true;
			if(now.k==ed.k){printf("%d\n",now.dis);return 0;}
            q.push(now);
        }
    }
    return 0;
}
 ```
 AC:189ms
 


---

## 作者：Garrison (赞：4)

八数码是一道很经典的题，我用的方法是：康托展开、模拟、字符串……[其实正解是HASH]

题面描述：给定数码初始状态，求多少步可以达到给定状态。

分析：输入的是一个九位数，那么我们可以有两种方法输入：1、数字；2、字符数组(字符串)

这道题其实是一道图，但是没有直接给出明确的，所以称之为隐式图。在构造完图之后，很容易想到是BFS

**要点：**

1、八数码的储存问题：难道真的要开一个[3][3]的二维数组吗？其实没必要，有题的输入我们就可以获得启发，我们可以用一个9位数来储存这个状态。

2、如何储存？队列就好了。最开始由字符数组输入(当然也可以直接用数字),在需要改变状态时压缩改变状态，在不需要时解压储存。

3、关于解压和压缩，其实将9位数放进数组里很容易，反之也很容易。解压：
```
int Decompression/*解压(用数字储存)*/(char s[10])
{
	int x=0;
	for(int i=1;i<=9;++i)
		x=x*10+(s[i]-'0');
	return x; 
}
```
压缩：
```
void Compression/*将数字变成字符*/(int x,char s[10])
{
	int i=9;
	while(i)
	{
		s[i]=(x%10+'0');
		x/=10;
		--i;
	}
	return;
}
```
4、关于挪动规律：将一个数码向上挪动就是-3，向下挪动就是+3，向左挪动就是-1，向右挪动就是+1(边界的要额外判断)
```
	//w所在位置就是0所在位置
	switch(plan)
	{
		case 1:
			if(w>3)
				swap(to[w],to[w-3]);
			break;
		case 2:
			if(w<=6)
				swap(to[w],to[w+3]);
			break;
		case 3:
			if(w%3!=1)
				swap(to[w],to[w-1]);
			break;
		case 4:
			if(w%3!=0)
				swap(to[w],to[w+1]);
			break;
		default:break;
	}
```
**5、判重：**

这可以说是一个最重要的点了，最无语的办法(再不能想出更好方法的前提下)用set/map，最正常的方法就是用Hash(但是本文章不介绍),以及本文介绍的康托展开。

何为康托展开？附一个链接[康托展开](康托展开_百度百科)自己了解了解。

因为开一个九位数的数组肯定不行(有万恶的空间限制)所以要尽可能的减少数位，那么9！的数组开的了吗？答案是肯定的。所以我们可以用一个数组来存储每一种状态所在的是该序列的第多少个。代码如下：
```
int wh=1;
	for(int i=1;i<=9;++i){
		int k=0;
		for(int j=1;j<=i;++j)
			if(s[j]<=s[i])
				++k;
		wh+=(s[i]-'0'+1-k)*times[i];
	}
	return wh;
```
那么一切都好了，Bfs怎么写呢？（只要学过的都知道）发一个伪代码：
```
	头=尾=1;	
	while(头<=尾){
		取出最开始的头元素
		压缩成数组;
		四个方向循环{
			将转换后的状态储存
			将转换后的状态解压成数字
			求转换后的状态是第多少个
			if(如果没有出现过){
				出现
				将解压后的数字入队
				步数为上一步的步数+1;
				如果和要求的状态一样{
					输出
					return;
				}
			}
		}
		头指针++;
	}
```
说了这么多了，相信已经讲得很清楚了，最后，完整代码放上！

```
#include<bits/stdc++.h>
using namespace std;
#define SET 400000
char str[10],aim[10]{' ','1','2','3','8','0','4','7','6','5'};
char now[10],next[10];
int a,times[10];
int team[SET],step[SET];
bool apear[SET];
int Decompression(char s[10])
{
	int x=0;
	for(int i=1;i<=9;++i)
		x=x*10+(s[i]-'0');
	return x; 
}
void Compression(int x,char s[10])
{
	int i=9;
	while(i)
	{
		s[i]=(x%10+'0');
		x/=10;
		--i;
	}
	return;
}
void move(int plan,char where[10],char to[10])
{
	memcpy(to,where,10);
	int w;
	for(int i=1;i<=9;++i)
		if(to[i]=='0')
			w=i;
	switch(plan)
	{
		case 1:
			if(w>3)
				swap(to[w],to[w-3]);
			break;
		case 2:
			if(w<=6)
				swap(to[w],to[w+3]);
			break;
		case 3:
			if(w%3!=1)
				swap(to[w],to[w-1]);
			break;
		case 4:
			if(w%3!=0)
				swap(to[w],to[w+1]);
			break;
		default:break;
	}
}
int f(char s[10])
{
	int wh=1;
	for(int i=1;i<=9;++i){
		int k=0;
		for(int j=1;j<=i;++j)
			if(s[j]<=s[i])
				++k;
		wh+=(s[i]-'0'+1-k)*times[i];
	}
	return wh;
}
void solve()
{
	a=Decompression(aim);
	team[1]=Decompression(str);
	if(a==team[1]){
		cout<<0<<endl;
		return;
	}
	int head,tail;
	head=tail=1;	
	while(head<=tail){
		int n=team[head];
		Compression(n,now);
		for(int i=1;i<=4;++i){
			move(i,now,next);
			int nn,wn;
			nn=Decompression(next);
			wn=f(next);
			if(!apear[wn]){
				apear[wn]=1;
				team[++tail]=nn;
				step[tail]=step[head]+1;
				if(nn==a){
					cout<<step[tail]<<endl;
					return;
				}
			}
		}
		++head;
	}
	return;
}
int main()
{
	times[8]=1;
	for(int i=7;i>=1;--i)
		times[i]=(9-i)*times[i+1];
	for(int i=1;i<=9;++i)
		cin>>str[i];
	solve();
	return 0;
}
```


---

## 作者：Zechariah (赞：4)

看到好多大佬用的BFS，本蒟蒻默默来一发迭代深搜

我们把移动棋子看作移动空格，这样方便写，在dfs的时候加一个深度限制，避免递归层数过多，目标状态打个表，每次移动判定一下，还要注意移动空格时不要往回走了，一旦与目标状态相同，输出深度-1(步数)即可
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <string>
#include <cstdlib>
#include <algorithm>

using namespace std;
int deep;
int dx[5]={0,-1,1,0};
int dy[5]={1,0,0,-1};
char m[5][5];
char mb[4][4]={
{},
0,'1','2','3',
0,'8','0','4',
0,'7','6','5'
};
bool dfs(int step,int x,int y,int last,int sum)
{
    if (step+sum>deep)return false;
    if (!sum)return true;
    int p;
    for (int k=0;k!=4;++k)
    {
        if (k!=(3-last))
        {
            p=sum;
            int xx=x+dx[k],yy=y+dy[k];
            if (xx<=0||yy<=0||xx>3||yy>3)continue;
            if (m[xx][yy]==mb[xx][yy]&&m[xx][yy]!=mb[x][y])++p;
            if (m[xx][yy]!=mb[xx][yy]&&m[xx][yy]==mb[x][y])--p;
            if (mb[xx][yy]=='0')--p;
            if (mb[x][y]=='0')++p;
            swap(m[xx][yy],m[x][y]);
            if (dfs(step+1,xx,yy,k,p))return true;
            swap(m[xx][yy],m[x][y]);
        }
    }
    return false;
}

int main()
{
    int x,y;
    int sum=0;
    for (int i=1;i<=3;++i)
    {
        for (int j=1;j<=3;++j)
        {
            m[i][j]=getchar();
            if (m[i][j]=='0')
            {
                x=i;
                y=j;
            }
            if (m[i][j]!=mb[i][j])
            ++sum;
        }
    }
    for (deep=1;;++deep)
    {
        if (dfs(0,x,y,-1,sum))
        {
            printf("%d",deep-1);
            break;
        }
    }
    return 0;
}
```

---

## 作者：Zcus (赞：4)

啊！！这一题算是BFS中的经典了，如果你不懂BFS的话，可以睡觉了~~~

啊！！现在我们来分析一下思路

1.使用3\*3的数组存储，操作十分简单，但会超时很多点，有兴趣的读者可以自行尝试一下；

2.程序中用3\*3的二维数组表示布局比较直观，但在判断重复，判断是否达到目标方面，却给程序增加了复杂性，也影响了运行速度。可以改用字符串形式来表示布局，第1..3个数表示第一行的三个数，第4..6个数，表示第二行的三个数，第7..9个数表示第三行的三个数。这样，程序的判断和判重可以方便很多。

但如判重时使用的是一个存下所有情况的数组，那也能拿10分。

如：10分代码


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
int hash1=1,f[51000];
string go,to,hashb[51000],ans[51000];
int h=0,t=1;
int a[4]={1,-1,0,0},
    b[4]={0,0,1,-1};
int out(int t)
{  int s=0;
    do{s++;
      t=f[t];
    }while(f[t]!=0);
        return s;
}
int pz(int n)
{
    for(int i=1;i<=n;i++) 
      if(hashb[i]==ans[h]) return 0;
      return 1;
}
int bfs()
{  
    ans[1]=go;f[1]=0;
    do{int i;
    
        h++;
        for( i=0;i<=8;i++)
          if(ans[h][i]=='0') break;
         for(int x=0;x<4;x++)
         {
                int nowx,nowy,tox,toy,wz;
                nowx=i/3+1;
                nowy=i%3+1;
                tox=nowx+a[x];
                toy=nowy+b[x];
                wz=(tox-1)*3+toy-1;
                if(tox>=1&&tox<=3&&toy>=1&&toy<=3&&wz>=0&&wz<=8&&nowx>=1&&nowx<=3&&nowy>=1&&nowy<=3)
                {
                    char c;
                    c=ans[h][wz];
                    ans[h][wz]=ans[h][i];
                    ans[h][i]=c;
                    
                    if(pz(hash1)==1) {
                        t++;ans[t]=ans[h];
                        f[t]=h;
                        hashb[++hash1]=ans[t];
                        if(ans[t]==to) {return out(t);}
                        
                    
                     }
                      c=ans[h][i];
                        ans[h][i]=ans[h][wz];
                        ans[h][wz]=c;
                            
                        
                         
                }
         }
        
     }while(h<t);
}
int main()
{
    cin>>go;
    hashb[1]=go;
    to="123804765";
    int answer;
      answer=bfs();
    printf("%d",answer);
   
    return 0;
}
```
现在我们发现判重的时候浪费了许多时间，所以我们可使用MAP或康托展开

100分（MAP）


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<string>
#include<map>
using namespace std;
int hash1=1,f[510000];
string go,to,ans[510000];
int h=0,t=1;
int a[4]={1,-1,0,0},
    b[4]={0,0,1,-1};
map<string,int>hashb;
int out(int t)
{  int s=0;
    do{s++;
      t=f[t];
    }while(f[t]!=0);
        return s;
}
int bfs()
{  
    ans[1]=go;f[1]=0;
    do{int i;
    
        h++;
        for( i=0;i<=8;i++)
          if(ans[h][i]=='0') break;
         for(int x=0;x<4;x++)
         {
                int nowx,nowy,tox,toy,wz;
                nowx=i/3+1;
                nowy=i%3+1;
                tox=nowx+a[x];
                toy=nowy+b[x];
                wz=(tox-1)*3+toy-1;
                if(tox>=1&&tox<=3&&toy>=1&&toy<=3&&wz>=0&&wz<=8&&nowx>=1&&nowx<=3&&nowy>=1&&nowy<=3)
                {
                    char c;
                    c=ans[h][wz];
                    ans[h][wz]=ans[h][i];
                    ans[h][i]=c;
                    
                    if(hashb[ans[h]]!=1) {
                        t++;ans[t]=ans[h];
                        f[t]=h;
                        hashb[ans[h]]=1;
                        if(ans[t]==to) {return out(t);}
                        
                    
                     }
                      c=ans[h][i];
                        ans[h][i]=ans[h][wz];
                        ans[h][wz]=c;
                            
                        
                         
                }
         }
        
     }while(h<t);
}
int main()
{
    cin>>go;
    hashb[go]=1;
    to="123804765";
    int answer;
      answer=bfs();
    printf("%d",answer);
   
    return 0;
}
```

---

## 作者：沧澜 (赞：4)

# A\*算法

在这里，只讲一下A\*的做法，就不讲A\*的原理了毕竟原理太多了，有需求的可以戳[这里](http://www.cnblogs.com/xiaotuzi/p/6491491.html)

思路：A\*其实就是一个剪枝，我们在这里需要一个这里有一个估价函数：

**当前状态的估价函数是当前在状态理想情况下到达目标状态的代价； **

比如我们现在走了g步，估价为H步， 然后我们迭代加深枚举的k步(k从0开始枚举，所以我们要预先特判无解情况，当然可以掐秒)；

如果g+H>k，显然就不能继续了。\(^o^)/就是这么简单；


至于为什么A\*是dfs不是bfs，因为bfs没有一个确定的k，而dfs的k我们是枚举的，至于这样的话有很多的重复。

因为假如答案是4， 那么k=0~3时的搜索是无用的，但是在这道题目里面显然k不是很大，而且加入k=ans爆搜的时间复杂度是n；

那么k=0~ans的时间复杂度类似与n\*n，虽然这样，还是比直接暴力好，那我们可不可以把k-1的所有g==k,g==k-1的状态存下来呢??

好像很麻烦欸，当然喽k我们可以二分?(在这里，我只提供这些优化思路，而我的就是最朴素的喽)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int ans,num[4][4];
int n,m,x,y,z,X,Y;
int dx[4]={0,1,-1,0};
int dy[4]={1,0,0,-1};
int fx[11]={0,1,1,1,2,3,3,3,2};
int fy[11]={0,1,2,3,3,3,2,1,1};
int H(){
    int bns=0;
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            if(num[i][j])
                bns+=abs(i-fx[num[i][j]])+abs(j-fy[num[i][j]]);
    return bns;
}
void dfs(int k,int X,int Y,int g){
    int h=H();
    if(!h){
        ans=g;
        return ;
    }
    if(h+g>k||ans||g==k)    return ;
    for(int i=0;i<4;i++){
        int x=dx[i]+X;
        int y=dy[i]+Y;
        if(x>=1&&y>=1&&x<=3&&y<=3){
            swap(num[X][Y],num[x][y]);
            dfs(k,x,y,g+1);
            swap(num[x][y],num[X][Y]);
        }
    }
}
int main(){
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++){
            char x;
            scanf("%c",&x);
            num[i][j]=x-'0';
            if(!num[i][j])
                X=i,Y=j;
        }
    for(int k=1;;k++){
        dfs(k,X,Y,0);
        if(ans){
            printf("%d",ans);
            return 0;
        }
    }
}
```

---

## 作者：Fuyang_KBZ (赞：4)

#本蒟蒻表示SET过了 却把HASH写TLE

##用set很容易理解 把每个状态用一个变量组合成一个九位数

##如果访问过 return false 否则把这个状态加进去

##BFS套模板就好了

···cpp


    


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
#define hashsize 1000003
using namespace std;
typedef int state[9];
state st[1000001],goal;
int mx[4] = {0,0,1,-1};
int my[4] = {1,-1,0,0};
int first[100001],next[100001];
int disit[1000001];
int head = 1, tail = 2;
set<int> vis;
int hash(state&);
bool insert(int );
int BFS();
int main()
{
    for(int i = 0; i < 9; i++)
    scanf("%1d",&st[1][i]);
    goal[0] = 1;
    goal[1] =2;
    goal[2] =3;
    goal[3] =8;
    goal[4] =0;
    goal[5] =4;
    goal[6] =7;
    goal[7] =6;
    goal[8] =5;
    BFS();
    cout<<disit[head];
}
int BFS()
{
    memset(first,0,sizeof(first));
    while(head < tail)
    {
        state& now = st[head];
        if(memcmp(&now,&goal,sizeof(goal)) == 0) return head;
        int zero_pos;
        for(zero_pos = 0; zero_pos < 9; zero_pos++) if(now[zero_pos] == 0) break;     //找“0” 
        int x = zero_pos / 3;                  //坐标转化 
        int y = zero_pos % 3;
        for(int i = 0; i < 4; i++)             //尝试上下左右 
        {
            int xx = x + mx[i];
            int yy = y + my[i];
            if(xx > 2 || xx < 0 || yy > 2 || yy < 0) continue;
            int zz = xx * 3 + yy;
            state& n = st[tail];
            memcpy(&n,&now,sizeof(now));
            n[zz] = now[zero_pos];
            n[zero_pos] = now[zz];             //更新0点 
            disit[tail] = disit[head] + 1;
            if(insert(tail)) tail++;
        }
        head++;
    }
}
int hash(int s)
{
    int ans = 0;
    for(int i = 0; i < 9; i++) ans= ans * 10 + st[s][i];
    return ans % hashsize;
}
bool insert(int s)
{
    int v = 0;
    for(int i = 0; i < 9; i++) v = v*10 + st[s][i];
    if(vis.count(v)) return false;      //若访问过 
    vis.insert(v);                      //将这个状态加进去 
    return true;
}
/*bool insert(int s)
{
    int val = hash(s);
    int u = first[val];
    while(u)
    {
        if(memcpy(&st[u],&st[s],sizeof(st[u])) == 0) return false;        // 垃圾的HASH 
        u = next[u];
    }
    next[s] = first[val];
    first[val] = s;
    return true;
}*/
```
```cpp

---

## 作者：plane (赞：4)

本题有写法好几个写法，但主要思路是BFS：


##No。1


采用双向宽搜，分别从起始态和结束态进行宽搜，暴力判重。如果只进行单向会超时。


##No。2


采用hash进行判重，宽搜采用单向就可以AC。


##No。3


运用康拓展开进行判重，即使采用单向宽搜时间效率也很高。


---

## 作者：a526955194 (赞：4)

似乎题解里没有A\*算法和双向宽搜的代码，那我就献一下丑吧

先Orz楼下暴力宽搜AC的大神，另外在下也是刚学这些东西，可能讲得不好

A\*：个人认为A\*比双向宽搜好写的多，代码长度也是很短，估价函数非常容易想到，即当前所有1-8（不包括0）数字位置与目标位置的距离之和，在这里可能会出现一个疑问：为什么是不包括0的？我刚开始也是打上0，的仔细研究之后可以发现答案都偏大2左右（其实把Ans-2也可以A了数据太水）后来发现：只要1-8的数字都完美地和目标位置匹配了，那0这个可以自由移动的数字也自然在目标位置上了，故可以估价的时候不统计（在这里可以不把0看成一个需要转移到目标位置上的数字，而是不存在的缺口，可能会有助于理解）接下来可以迭代枚举答案，每次记录0坐标即可，若  当前估价值+当前步数>答案  则剪枝（因为估价值是一个完成匹配的最低限）。

```cpp

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
struct A{int x,y;};
int a[3][3],flag,stx,sty,Ans;
int p1[4]={1,-1,0,0};int p2[4]={0,0,1,-1};
int gx[9]={1,0,0,0,1,2,2,2,1};
int gy[9]={1,0,1,2,2,2,1,0,0};
int Guess(){
    A z[9]={0};int sum=0;
    for(int i=0;i<=2;i++)
        for(int j=0;j<=2;j++)
            z[a[i][j]].x=i,z[a[i][j]].y=j;
    for(int i=1;i<9;i++)
        sum+=(abs(z[i].x-gx[i])+abs(z[i].y-gy[i]));
    return sum;
}
void Dfs(int now,int goal,int x,int y){
    if(now>goal)return;
    if(flag)return;int v=Guess();
    if(v==0){flag=1;return;}
    if(now+v>goal)return;
    for(int k=0;k<4;k++){
        int nx=x+p1[k];int ny=y+p2[k];
        if(nx<0||nx>2||ny<0||ny>2)continue;
        swap(a[x][y],a[nx][ny]);
        Dfs(now+1,goal,nx,ny);
        swap(a[x][y],a[nx][ny]);
    }
}
int main(){
    char ch[10];scanf("%s",ch);
    int k=0;
    for(int i=0;i<3;i++)
    for(int j=0;j<3;j++){
        a[i][j]=ch[k]-'0',k++;
        if(a[i][j]==0)stx=i,sty=j;
    }Ans=-1;
    while(!flag)
        Ans++,Dfs(0,Ans,stx,sty);
    printf("%d\n",Ans);
    return 0;
}
)
```
双向宽搜：代码复杂度较高，需要用到离散和康托展开，基本思想与普通双向宽搜一样，从目标状态和起始状态同时开始搜索，若一方扩展到另一方曾到达过的状态，即输出两者步数之和终止程序

```cpp

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
struct A{int a[3][3];}q[2][1000005];
int p1[4]={1,-1,0,0};int p2[4]={0,0,1,-1};
int Ans[2][1000005];int head[2]={1,1};int tail[2]={2,2};
int Contor(int x){
    int Fac[10]={1,1,2,6,24,120,720,5040,40320,362880},m[9];
    for(int i=9;i>=1;i--)m[i]=x%10,x/=10;int Ret=0;
    for(int i=1;i<=9;i++){
        int tmp=0;
        for(int j=i+1;j<=9;j++)
            if(m[i]>m[j])tmp++;
        Ret+=tmp*Fac[9-i];
    }return Ret;
}
int HASH(int a[3][3]){
    int x=0,k=1;
    for(int i=2;i>=0;i--)
    for(int j=2;j>=0;j--)
        x+=a[i][j]*k,k*=10;
    return Contor(x);
}
void Bfs(int m){
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            q[m][tail[m]].a[i][j]=q[m][head[m]].a[i][j];
    int x,y;int s=HASH(q[m][head[m]].a);
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            if(q[m][head[m]].a[i][j]==0)x=i,y=j;
    for(int k=0;k<4;k++){
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                q[m][tail[m]].a[i][j]=q[m][head[m]].a[i][j];
        int nx=x+p1[k];int ny=y+p2[k];
        if(nx<0||nx>2||ny<0||ny>2)continue;
        swap(q[m][tail[m]].a[x][y],q[m][tail[m]].a[nx][ny]);
        int now=HASH(q[m][tail[m]].a);
        if(Ans[m][now]==-1){
            Ans[m][now]=Ans[m][s]+1;
            if(Ans[1][now]!=-1&&Ans[0][now]!=-1)
                {printf("%d\n",Ans[1][now]+Ans[0][now]);exit(0);}
            tail[m]++;
        }
    }head[m]++;
}
void Work(){
    while(1)
        if(head[0]-tail[0]<=head[1]-tail[1])Bfs(0);
        else Bfs(1);
}
int main(){
    char ch[10];scanf("%s",ch);
    int k=0;
    for(int i=0;i<3;i++)
    for(int j=0;j<3;j++)
        q[0][1].a[i][j]=ch[k]-'0',k++;
    q[1][1].a[0][0]=1;q[1][1].a[0][1]=2;q[1][1].a[0][2]=3;
    q[1][1].a[1][0]=8;q[1][1].a[1][1]=0;q[1][1].a[1][2]=4;
    q[1][1].a[2][0]=7;q[1][1].a[2][1]=6;q[1][1].a[2][2]=5;
    memset(Ans,-1,sizeof Ans);
    Ans[0][HASH(q[0][1].a)]=Ans[1][HASH(q[1][1].a)]=0;
    Work();return 0;
}

```

---

## 作者：hhhwg07 (赞：3)

第一想法肯定是BFS但会TLE（64分），考虑优化

本人利用了A*进行了优化

A*的思路是对从一个状态到目标状态的最小花费进行预估（即估值函数），则从初始状态到该状态的最小化费加上该估值就是从初始状态经过该状态到目标状态的花费最小值的估值，每次拓展估值最小的，可利用优先队列进行维护（类似于Dijkstra堆优化）（详情点[这里](https://www.jianshu.com/p/a3951ce7574d)）

至于估值函数本人计算有多少个位置目标状态与该状态的数不一样
```cpp
int g(const f &a){
	int cnt=0;
	rep(i,1,3){
		rep(j,1,3){
			if(a.g[i][j]!=e.g[i][j])cnt++;
		}
	}
	return cnt;
}
```
去重的问题用set解决

上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,s,e) for(int i=s;i<=e;i++)
#define REP(i,s,e) for(int i=s;i>=e;i--)
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
struct f{
	int g[4][4];//存图
	int w;//到该状态的路径长
	int fx(){//寻找空格
		rep(i,1,3)
			rep(j,1,3)
				if(g[i][j]==0)return i;
	}
	int fy(){
		rep(i,1,3)
			rep(j,1,3)
				if(g[i][j]==0)return j;
	}
}p,e;
int g(const f &a){//估值函数
	int cnt=0;
	rep(i,1,3){
		rep(j,1,3){
			if(a.g[i][j]!=e.g[i][j])cnt++;
		}
	}
	return cnt;
}
void copy(f &a,const f &b){//复制队顶
	a.w=b.w;
	rep(i,1,3){
		rep(j,1,3){
			a.g[i][j]=b.g[i][j];
		}
	}
}
bool operator == (const f &a,const f &b){//set需要
	rep(i,1,3){
		rep(j,1,3){
			if(a.g[i][j]!=b.g[i][j])return false;
		}
	}
	return true;
}
bool operator < (const f &a,const f &b){//set需要
	string sa,sb;
	rep(i,1,3){
		rep(j,1,3){
			sa+=a.g[i][j]+'0';
			sb+=b.g[i][j]+'0';
		}
	}
	return sa<sb;
}
bool operator > (const f &a,const f &b){//优先队列需要
	int fa=a.w+g(a),fb=b.w+g(b);
	return fa>fb;
}
set<f> s;
priority_queue<f,vector<f>,greater<f> > q;
int main(){
	e.g[1][1]=1;e.g[1][2]=2;e.g[1][3]=3;//目标状态
	e.g[2][1]=8;e.g[2][2]=0;e.g[2][3]=4;
	e.g[3][1]=7;e.g[3][2]=6;e.g[3][3]=5;
	p.w=0;
	char c;
	rep(i,1,3){
		rep(j,1,3){
			cin>>c;
			p.g[i][j]=c-'0';
		}
	}
	q.push(p);
	while(!q.empty()){//搜索
		copy(p,q.top());q.pop();
		if(s.count(p))continue;
		s.insert(p);
		if(p==e){
			cout<<p.w<<endl;
			break;
		}
		int x=p.fx(),y=p.fy();
		p.w++;
		rep(i,0,3){
			if(x+dx[i]<1||x+dx[i]>3||y+dy[i]<1||y+dy[i]>3)continue;
			swap(p.g[x+dx[i]][y+dy[i]],p.g[x][y]);
			if(!s.count(p))q.push(p);
			swap(p.g[x+dx[i]][y+dy[i]],p.g[x][y]);
		}
	}
	return 0;
}
```


---

## 作者：XiXi (赞：3)

这道题较难，先发个题解吧！

```cpp
const goal='123804765';
vx:array[1..4] of integer=(1,-1,3,-3);
maxn=1200007; 
type rec=record      s:string[9];      
step:longint;      end;      re=record      f:boolean; 
s:string[9];      end;
var opt:array[0..maxn] of rec; flag:array[0..maxn] of re; i,j,n,m,x,w,k:longint; v:boolean;  st,y:string[9];
 function lhash(s:string):int64; {屏弃了其他的所有HASH函数，因为其他的函数再好都要有一个LENGTH（S）的循环，有可能造成超时}   
var   hash:int64;   
begin   val (s,hash);   
lhash:=hash mod maxn;   
end; 
procedure judge; {判断是否达到目标状态}   
begin   if opt[m].s=goal then     
begin     writeln (opt[m].step);
halt;     end;   end; 
begin readln (st); opt[1].s:=st； 
opt[1].step:=0; x:=lhash(st); flag[x].f:=true;
flag[x].s:=st; i:=1; j:=1; while i<=j do   
begin   w:=pos ('0',opt[i].s);   
for k:=1 to 4 do     
if ((w mod 3=1) and (k<>2) or ((w mod 3=0)) and (k<>1))or (w mod 3=2) then
if (w+vx[k]>0) and (w+vx[k]<=9) then       
begin       y:=opt[i].s;      {状态初始化}
y[w]:=y[w+vx[k]];       y[w+vx[k]]:='0';       x:=lhash(y);       v:=false;      
while (x<maxn) and (flag[x].f) do   
begin         if flag[x].s=y then          
begin           v:=true;           break;
end;         inc (x);
end;       if not v then    {生成状态}      
begin         inc (j);
m:=j mod maxn;        opt[m].s:=y;      opt[m].step:=opt[i].step+1;        
flag[x].f:=true;         flag[x].s:=y;        judge;         end; 
end;  inc (i);   end; end.
理解了再炒，我也想了很久的（备注自己删吧！）
```

---

## 作者：「QQ红包」 (赞：2)

显然判重可以用map,然而map太慢了.于是我就用bitset,开九亿似乎不会炸,然而蜜汁ce,然后开八位算了,最后一位直接扔掉

而且这样跑得很快.

本来打算直接在一个9位数上模来模去搞一下然后四个方向太麻烦了所以干脆拆开交换再合起来入队

```cpp
#include<bits/stdc++.h>
using namespace std;
long long T;
long long n;
bitset<90000000> Map;
struct node
{
    long long a;
    long long d;//存0的位置
    long long s;//记录步数
};
queue<node> q;
node u,v;
long long a[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
long long b[10];
inline void rpk()
{
    b[1]=0;
    for (long long i=1;i<=9;i++)
    {
        b[9-i+1]=v.a%10;
        v.a/=10;
    }//拆成9位
    long long t=b[u.d];b[u.d]=b[v.d];b[v.d]=t;//交换
    v.a=0;
    for (long long i=1;i<=9;i++)
    {
        v.a+=b[i]*a[9-i];
    }//再拼起来
    if (Map[v.a/10]==0) q.push(v);
    Map[v.a/10]=1;
}
int main()
{
    scanf("%lld",&n);
    u.a=n;
    for (long long i=1;i<=9;i++)
    {
        if ((n%10)==0) 
        {
            u.d=9-i+1;
            //cout<<u.d;
            break;
        }
        n/=10;
    }
    Map[n/10]=1;//起点标记
    T=123804765;
    u.s=0;
    q.push(u);
    while (!q.empty())
    {
        u=q.front();q.pop();
        if (u.d>3)//不在第一行
        {
            v.d=u.d-3;//改变0的位置
            v.a=u.a;
            v.s=u.s+1;
            rpk();
            if (v.a==T)
            {
                printf("%lld",u.s+1);
                return 0;
            }
        }//上移
        if (u.d<7)//不是最下面的几行
        {
            v.d=u.d+3;
            v.a=u.a;
            v.s=u.s+1;
            rpk();
            if (v.a==T)
            {
                printf("%lld",u.s+1);
                return 0;
            }    
        }下移
        if ((u.d%3==1)||(u.d%3==2))//不是最后一列就可以左移
        {
            v.d=u.d+1;
            v.a=u.a;
            v.s=u.s+1;
            rpk();
            if (v.a==T)
            {
                printf("%lld",u.s+1);
                return 0;
            }        
        }//左移
        if (u.d%3!=1)//不在第一列就可以右移
        {
            v.d=u.d-1;
            v.a=u.a;
            v.s=u.s+1;       
            rpk();
            if (v.a==T)
            {
                printf("%lld",u.s+1);
                return 0;
            } 
            //cout<<v.a<<"\n";
        }//右移
    }
    return 0;
}
```

---

## 作者：Rockdu (赞：2)

先后写过三遍这个题。

第一次的时候用的是 bfs+康托展开 在数据修改之前因该是可以AC的，就是用时在边缘徘徊（改了后还没试过）

第二次用的是A\*+map 但是估值函数没有选好，用的是没有归位的数码个数 导致有一个点直接WA，速度也受到了影响再加上使用map，基本上在1000MS左右

今天突然想起来，就重新写了一遍，A\*+康托展开，并且换用每一个数码到目标的曼哈顿距离速度果然提升。直接上到42MS

下面是风格鬼畜的代码













```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<cmath>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
int des[10]={1,2,3,8,0,4,7,6,5,0};
int dpos[10]={4,0,1,2,5,8,7,6,3,0};//预处理目标 
bool vis[1000000];
int fact[]={1,1,2,6,24,120,720,5040,40320,362880};//阶乘表 
int ch(int * c){//康托展开 
    int n=0;
    int len=9;
    for(int i=0;i<len;i++){
        int cnt = 0;
        for(int j=i+1;j<len;j++) if(c[i]>c[j]) cnt++;
        n+=    fact[len-1-i] * cnt;
    }
    return n;
}
struct node
{
    int state[10];
    int h(){
        int ret=0;
        for(int i=0;i<9;i++){    //计算方法为所有数码到目标的曼哈顿距离之和 
                int sx=i%3,sy=i/3;
                int dx=dpos[state[i]]%3,dy=dpos[state[i]]/3;
                ret+=abs(dx-sx)+abs(dy-sy);
            }
        return ret;
    }
    int f;
    int step;
    node(int rs[],int rstep){
        for(int i=0;i<9;i++){
            state[i]=rs[i]; }
        step=rstep;
    }
    node(){ }
    void judge(){f=step+h();}
    bool operator <(const node &a) const{
        return f>a.f;//估值越小 越优先 
    }
};
priority_queue<node > qn;
int fdz(int * state){
    for(int i=0;i<9;i++)
        if(state[i]==0)
            return i;
}
bool tryleft(int * state,int pos){
    if(pos%3==0) return false;
    swap(state[pos],state[pos-1]);
    return true;
}
bool tryright(int * state,int pos){
    if(pos%3==2) return false;
    swap(state[pos],state[pos+1]);
    return true;
}
bool tryup(int * state,int pos){
    if(pos/3==0) return false;
    swap(state[pos],state[pos-3]);
    return true;
}
bool trydown(int * state,int pos){
    if(pos/3==2) return false;
    swap(state[pos],state[pos+3]);
    return true;
}
bool cmp(int * a,int * b){
    for(int i=0;i<9;i++)
        if(a[i]!=b[i])    return 0;
    return 1;
}
int Astar(){
    while(!qn.empty()){
        node org;
        node nstate=qn.top();
        int step=nstate.step;
        if(cmp(nstate.state,des))
            return step;
        int pos=fdz(nstate.state);
        qn.pop();
        org=nstate;
        if(tryleft(org.state,pos))
            if(!vis[ch(org.state)]){                    
                node newn(org.state,step+1);
                newn.judge();
                vis[ch(org.state)]=1;
                qn.push(newn);
            }
        org=nstate;
        if(tryright(org.state,pos))
            if(!vis[ch(org.state)]){
                node newn(org.state,step+1);
                newn.judge();
                vis[ch(org.state)]=1;
                qn.push(newn);
            }
        org=nstate;
        if(tryup(org.state,pos))
            if(!vis[ch(org.state)]){
                node newn(org.state,step+1);
                newn.judge();
                vis[ch(org.state)]=1;
                qn.push(newn);
            }
        org=nstate;
        if(trydown(org.state,pos))
            if(!vis[ch(org.state)]){
                node newn(org.state,step+1);
                newn.judge();
                vis[ch(org.state)]=1;
                qn.push(newn);
            }
    }
    return -1;
}
int main()
{
    int start[9];
    char s[10];
    gets(s);
    for(int i=0;i<9;i++)
        start[i]=s[i]-'0';
    node st(start,0);
    vis[ch(start)]=1;
    st.judge();
    qn.push(st);
    int ans=Astar();
    if(ans!=-1) printf("%d",ans);
    else printf("No");
    return 0;
}
同一道题，在不同的时段能写出质量完全不同的代码，看来OI之路还很长啊
```

---

## 作者：dph754132771 (赞：2)

/\*
\* P1379

\* Au：Small\_Ash

\* 大家几乎都是bfs+哈希或者是双向bfs+哈希啊

\* 我不会哈希就弱弱的上一个单向bfs+STL的set。。。（耗时很大）

\* 唯一的好处就是实现代码加上思考的时间仅仅只花了20来分钟。。。（废话代码就只有31行）

\* 下面是代码，因为bfs楼上的大神们讲的都很详细了，我就只对set做批注了

\* 至于为什么可以用set，是利用了set的特性，元素无序，而且只出现一次。

\*/
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>
using namespace std;
string start,end="123804765";
set <string> v;//某状态是否被访问 
string q[1000001],fx[9]={"13","024","15","046","1357","248","37","468","57"};
int ql,qr,t[1000001];
void bfs(){
    while (qr>ql){
        string s=q[ql]; int temp=t[ql],begin=s.find("0",0); ql++;
        for (int i=0;i<fx[begin].size();i++){
            int next=fx[begin][i]-48;string ss=s;
            char tt=ss[begin]; ss[begin]=ss[next]; ss[next]=tt;
            if (ss==end) {printf("%d",temp+1); return;}
            if (v.count(ss)==0){//count 是返回元素个数，因为set里一个元素只出现一次，所以可一理解成count=1时，该情况已被访问 
                q[qr]=ss;t[qr]=temp+1;qr++;v.insert(ss);
            } 
        }
    }
    return;
}
int main(){
    cin>>start;
    if (start==end) printf("0");
    q[qr]=start;t[qr]=0;qr++;v.insert(start);
    bfs();
    return 0;
}

```

---

## 作者：doby (赞：2)

代码不长，但好懂……吗……

当然，还可以打表，如果不带任何技巧直接枚举的话，一共有362880行……

方法一：bfs+hash

```cpp
#include<iostream>
#include<cstdlib>
#include<string>
using namespace std;
string qs[3000000],data[1000007],s,c,a,b="123804765",gz[9]={"13","024","15","046","1357","248","37","468","57"};
int sum,list[1000007]={0},next[1000007]={0},u,tim[3000000],head=0,tail=1,cnt=0,t,x,p,i,j;
int hash(string h)
{
    sum=0;
    for(i=0;i<h.size();i++){sum=sum*33+h[i];}//微小的处理
    sum=abs(sum%1000007),u=list[sum];
    while(u){if(data[u]==h){return 0;}u=next[u];}//如果出现过，返回0，否则找到最后一个，返回1并且进入到链
    data[++cnt]=h,next[cnt]=list[sum],list[sum]=cnt;
    return 1;
}
void jh(int x,int y){char t=s[x];s[x]=s[y],s[y]=t;}//两个位置交换
int main()
{
    cin>>a;
    if(a==b){cout<<"0";return 0;}//特判，虽然好像没有特殊情况
    qs[1]=a,tim[1]=0;
    while(head<tail)
    {
        head++,c=qs[head],t=tim[head],x=c.find("0",0);//拖出状态，找到0的位置
        for(j=0;j<gz[x].size();j++)
        {
            s=c,p=gz[x][j]-48;jh(x,p);//交换
            if(s==b){cout<<t+1;return 0;}//如果是目标情况，输出
            if(hash(s)){tail++,qs[tail]=s,tim[tail]=t+1;}//如果没出现过，进队
        }
    }
    return 0;
}
```
方法二：打表
九位，int都能存得下……

感受到超长度的恐惧了吗……


---

## 作者：N0othing (赞：1)

这道题蒟蒻用的是双向bfs。由于本蒟蒻的思路与其他大佬有些不一样，所以打出来。
```
#include<bits/stdc++.h>
using namespace std;
int a[10][10],x[5]={0,0,0,1,-1},y[5]={0,1,-1,0,0},l,r;
map<int,int>bj,bs;//map存图，不用担心爆空间
queue<int>q1,q2;
int beg,en=123804765,cnt1,cnt2;
void cf(long long x){//拆分函数，将一个九位数拆到二维数组里
    for(int i=3;i>=1;--i){
        for(int j=3;j>=1;--j){
            a[i][j]=x%10;
            x/=10;
            if(a[i][j]==0)l=i,r=j;//记录0的位置
        }
    }
}
int hb(){//合并函数，将二位数组合并成九位数
        int s=0;
        for(int i=1;i<=3;++i)for(int j=1;j<=3;++j)
            s=s*10+a[i][j];
    return s;
}
int main(){
    scanf("%d",&beg);
    bj[beg]=1,bj[en]=2,bs[beg]=0,bs[en]=0;//bs是已经走过的步数，bj是标记，从上往下搜是1，从下往上搜是2
    q1.push(beg),q1.push(en);//入队
    if(beg==en){
        cout<<0;
        return 0;
    }
    while(!q1.empty()){
        int p=q1.front();
        q1.pop();
        cf(p);
        for(int ij=1;ij<=4;++ij){
            if(l+x[ij]>3||l+x[ij]<1||r+y[ij]>3||r+y[ij]<1)continue;
            swap(a[l][r],a[l+x[ij]][r+y[ij]]);//找所有可能性
            int q=hb();
            swap(a[l][r],a[l+x[ij]][r+y[ij]]);
            if(bj[p]==1){//从上往下搜
                if(bj[q]==1)continue;//搜过就跳过
                if(bj[q]==2||p==en){//已经找到答案，输出
                    printf("%d",bs[q]+bs[p]+1);
                    return 0;
                }else{//入队
                    q1.push(q);
                    bj[q]=1;
                    bs[q]=bs[p]+1;
                }
            }else{//同上
                if(bj[q]==2)continue;
                if(bj[q]==1){
                    printf("%d",bs[p]+bs[q]+1);
                    return 0;
                }else{
                    q1.push(q);
                    bj[q]=2;
                    bs[q]=bs[p]+1;
                }
            }        
        }  
    }
    return 0;
}

---

## 作者：念古兰 (赞：1)

俗话说，**暴力出奇迹，骗分得省一**  
这道题主要就是暴搜（广搜）  
怎么搜呢，应该大部分的同学都能想到我们只要考虑空格的变化，然后根据空格的变化进行广搜就可以了  
这道题除了暴搜这一类基本操作，剩下的就是如何判重了其实用散列表就可以做到，  
~~emmmm，本来哈希表里面想要%19260817的，后来发现不是素数不够优……~~  
散列表用vector实现（不要对STL有什么误会，跑的飞快的），然后判重后插入就可以了  
先上一波hash的实现
```cpp
const int ha=192817;
vector<int> hash[ha];
struct state{
    int a[10],dis;
    state(int *b,int d)
    {
    	for(register int i=1;i<=9;i++) a[i] = b[i];
    	dis = d;
	}
};
bool myhash(state xx)
{
	int x=0;
	for(int i=1;i<=9;i++) x=x*10+xx.a[i]; 
	int m=x%ha;
	int siz=hash[m].size();
	for(register int i=0;i<siz;i++) if(hash[m][i]==x) return false;
	hash[m].push_back(x);
	return true;
}
```
然后就是正文的bfs啦，为了帮助大家更快阅读（作者懒），代码不给注释，注意其中bfs的时候要判断能不能进行节点的拓展（也就是“越界”）的问题  
还有，输入的时候不要只是输入一个整数后转成状态，而应先转成字符后再操作，毕竟谁都无法预见是否出题人的数据是由前导0的  
具体见代码  
coding：
```cpp
#include <bits/stdc++.h> 
using namespace std;
typedef long long ll;
const int ha=192817;
vector<int> hash[ha];
struct state{
    int a[10],dis;
    state(int *b,int d)
    {
    	for(register int i=1;i<=9;i++) a[i] = b[i];
    	dis = d;
	}
};
bool myhash(state xx)
{
	int x=0;
	for(int i=1;i<=9;i++) x=x*10+xx.a[i]; 
	int m=x%ha;
	int siz=hash[m].size();
	for(register int i=0;i<siz;i++) if(hash[m][i]==x) return false;
	hash[m].push_back(x);
	return true;
}
int bfs(state s)
{
     int ans,b[10]={0,1,2,3,8,0,4,7,6,5};
     state goal(state(b,0));
     queue<state> q;
     q.push(s);
     myhash(s);
     while(!q.empty())
     {
     	state x=q.front();q.pop();
     	bool ok=1;
     	for(register int i=1;i<=9;i++) if(x.a[i]!=goal.a[i]) ok=0;
     	if(ok) return x.dis;
     	int cen=0,pos=0;
		for(register int i=1;i<=9;i++) if(x.a[i] == 0)
	    {
	    	pos=i;cen=pos/3+1;
	    	if(pos%3==0) cen--;
	    	break;
		}
		if(pos+1<=3*cen)
		{
			state tmp=x;
			tmp.dis=x.dis+1;
			swap(tmp.a[pos],tmp.a[pos+1]);
			if(myhash(tmp)) q.push(tmp);
		}
		if(pos-1>(cen-1)*3)
		{
			state tmp=x;
			tmp.dis=x.dis+1;
			swap(tmp.a[pos],tmp.a[pos-1]);
			if(myhash(tmp)) q.push(tmp);
		}
		if(cen<3)
		{
			state tmp=x;
			tmp.dis=x.dis+1;
			swap(tmp.a[pos],tmp.a[pos+3]);
			if(myhash(tmp)) q.push(tmp);
		 }
		 if(cen>1)
		 {
		 	state tmp=x;
		 	tmp.dis=x.dis+1;
		 	swap(tmp.a[pos],tmp.a[pos-3]);
		 	if(myhash(tmp)) q.push(tmp);
		  } 
	 }
}
int main()
{
	int a[10]={0};
	for(register int i=1;i<=9;i++)
	{
		char ch=0;
		ch=getchar();
		a[i] = ch-'0';
	}
	printf("%i",bfs(state(a,0)));
return 0;
}

```



---

## 作者：Rainybunny (赞：1)

Cantor展开的证明来自我的题解[P3014 牛线Cow Line](https://www.luogu.org/problemnew/show/P3014)

本题也是一道**Cantor展开**的模板~~水~~题, 为了在68篇题解里生存下去, 在这里甩一下自己对Cantor展开的证明:
# Cantor展开
先甩一下原定理:  
**给定一长度为$n$严格上升数列$a$, 令初始状态$a_0=a$, 对a进行全排列, 第k次生成的数列为$a_k$, 则有Cantor展开式:**  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$k=Hash(a_k)=\sum_{i=1}^n(n-i)!\sum_{j=i+1}^n[a_{k,i}>a_{k,j}]$
## 证明
构造如下Hash操作:  
&nbsp;&nbsp;&nbsp;&nbsp;**1)按顺序取出$a_{k,i}$**  
&nbsp;&nbsp;&nbsp;&nbsp;**2)取所有$a_{k,j}<a_{k,i},i<j$与$a_{k,i}$交换位置, 并对$a_{k,i+1}$至$a_{k,n}$的元素进行全排**  
现只需证, **该操作(1)仅限于, (2)不重复, (3)不遗漏地生成所有于$a_k$之前生成的数列, 即$a_1,a_2,...,a_{k-1}$.** 不妨设$a_k=S$, 操作后$a_k'=T$. 

------------
 
### 下证性质(1)
不妨设取出$S_m$与后交换,  
$\because$对于$\forall i<m,S_i=T_i$  
又$\because S_m>T_m$  
$\therefore T$一定全排生成于$S$之前, 已证.  

------------
  
### 下证性质(2)
(一) 若取$S_m$于后交换, 设多种不同交换结果$T_1,T_2,...$  
显然，$T_{1,m}\neq T_{2,m}\neq ...$.  
又在$\forall T_i$中，$T_{m+1}$至$T_n$又全排生成, 必不全等, 已证.  
  
(二) 若取$S_n,S_m$分别交换, 不妨设$n<m$,  
则取$S_m$所生成的结果$T,T_n=S_n$,  
又取$S_n$所生成的结果$T',T'\neq S_n$.  
$\therefore T\neq T'$, 已证.  
  
综上,性质(2)已证.  

------------

### 下证性质(3)
不妨任取全排数列$a_i, i\in[0,k-1]$  
$\because S$生成于$a_i$之后  
$\therefore$必先出现最小的$m$, s.t.(such that, 使得)$S_m>a_{i,m}$, 且对于$j<m,S_j=a_{i,j}$.  
$\because a_i$无重复元素  
$\therefore a_{i,m}\in\{S_n|n>m\}$  
又$\because S_m>a_{i,m}$  
$\therefore$当取$S_m$交换时, 必会s.t.一组结果$T$, $T_m=a_{i,m}$  
此时, $a_i$必由$T_{m+1}$至$T_n$的全排列生成, 已证.  

------------

故, 该操作性质已证明, 其生成的数列总数就是$k$.  
不妨设取出$S_i$与后交换, 其生成的数列总数显然为:  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Total_i=(n-i)!\sum_{j=i+1}^n[S_i>S_j]$  

那么所有的数列总数即为:  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$k=\sum_{i=1}^nTotal_i=\sum_{i=1}^n(n-i)!\sum_{j=i+1}^n[S_i>S_j]$  

则对于$\forall a_k$, 该操作生成的数列总数为:  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$k=\sum_{i=1}^n(n-i)!\sum_{j=i+1}^n[a_{k,i}>a_{k,j}]$  

故, 原命题成立, 证毕!  


------------
是不是非常简单呢? ~~滑稽~~  
之所以在这里引出Cantor展开, 是因为我们在Search时必须对状态进行Hash处理, 不然难以标记Vis数组.  
下面呢, 就看看我写的双向BFS吧, 如果在搜索模板方面有疑问, 可以探访其他dalao的题解!

```cpp
#include <queue>
#include <cstdio>
#include <algorithm>

namespace Optimize { // IO优化模板 
	#define Eps 1e-8
	#define Inf 0x3f3f3f3f
	#define Int register int
	#define LL long long int
	#define Type template<typename _T>
	#define FileClose() fclose ( stdin ), fclose ( stdout )
	#define FileOpen( fname ) freopen ( fname".in", "r", stdin ), freopen ( fname".out", "w", stdout )
	Type inline _T Max ( const _T a, const _T b ) { return a > b ? a : b; }
	Type inline _T Min ( const _T a, const _T b ) { return a < b ? a : b; }
	Type inline _T Abs ( const _T x ) { return x < 0 ? -x : x; }
	Type inline _T rint () {
		_T x = 0; int f = 1; char s = getchar ();
		while ( s < '0' || '9' < s ) f = s == '-' ? -1 : 1, s = getchar ();
		while ( '0' <= s && s <= '9' ) x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar ();
		return x * f;
	}
	Type inline void wint ( _T x ) {
		if ( x < 0 ) putchar ( '-' ), x = ( ~ x ) + 1;
		if ( 9 < x ) wint ( x / 10 );
		putchar ( x % 10 + '0' );
	}
}

using namespace std;
using namespace Optimize;

struct Node { // 结点结构体 
	int k, x, CantorKey, Step; // CantorKey是状态的Hash; k记录结点方向(正或反) 
	Node () {}
	inline Node ( const int SearchWay, const int _, const int __, const int ___ ) {
		k = SearchWay, x = _, CantorKey = __, Step = ___;
	}
};

const int Mov[4] = { -3, 1, 3, -1 };
LL FAC[10] = { 1 }; // 阶乘预处理 
vector<int> Start, Target;
int sx, sy, tx, ty;
int Vis[2][362885] = {}; // 9! = 326880

inline LL Cantor ( vector<int> a, const int n = 9 ) { // Cantor展开 
	LL ret = 0, tot = 0;
	for ( Int i = 0; i < n; ++ i ) {
		tot = 0;
		for ( Int j = i + 1; j < n; ++ j ) {
			tot += a[i] > a[j];
		}
		ret += tot * FAC[n - i - 1];
	}
	return ret;
}

inline vector<int> ReCantor ( LL k, const int n = 9 ) { // 逆展开(ps.其实可以直接储存序列) 
    vector<int> v, ret;
    for ( Int i = 0; i < n; ++ i ) {
        v.push_back ( i );
    }
    for ( Int i = n; i; -- i ) {
        LL r = k % FAC[i - 1], t = k / FAC[i - 1];
        k = r;
        ret.push_back ( v[t] );
        v.erase ( v.begin () + t );
    }
    return ret;
}

inline int DBFS () {
	int s = Cantor ( Start ), t = Cantor ( Target );
	if ( s == t ) { // 起点终点重合, 在DBFS里必须特判 
		return 0;
	}
	queue<Node> Q;
	Q.push ( Node ( 0, sx, s, 0 ) );
	Q.push ( Node ( 1, tx, t, 0 ) );
	while ( ! Q.empty () ) {
		Node now = Q.front ();
		Q.pop ();
		vector<int> S = ReCantor ( now.CantorKey );
		if ( Vis[now.k ^ 1][now.CantorKey] ) {
			return Vis[now.k][now.CantorKey] + Vis[now.k ^ 1][now.CantorKey]; // 直接在Vis数组里记录步数 
		}
		for ( Int i = 0; i < 4; ++ i ) {
			int mx = now.x + Mov[i];
			if ( 0 <= mx && mx < 9 && ( now.x / 3 == mx / 3 || now.x % 3 == mx % 3 ) ) { // (常规操作)
				swap ( S[now.x], S[mx] );
				int Key = Cantor ( S );
				if ( ! Vis[now.k][Key] ) {
					Vis[now.k][Key] = now.Step + 1;
					Q.push ( Node ( now.k, mx, Key, now.Step + 1 ) );
				}
				swap ( S[now.x], S[mx] );
			}
		}
	}
	return -1;
}

inline void Work () {
	#define rint rint<int> () // 声明读入int类型 
	for ( Int i = 1; i <= 9; ++ i ) {
		FAC[i] = FAC[i - 1] * i;
	}
	for ( Int i = 0; i < 9; ++ i ) {
		Start.push_back ( getchar () - '0' );
		if ( ! Start[i] ) {
			sx = i;
		}
	}
	int a[] = { 1, 2, 3, 8, 0, 4, 7, 6, 5 };
	for ( Int i = 0; i < 9; ++ i ) { // 给出终止状态 
		Target.push_back ( a[i] );
		if ( ! Target[i] ) {
			tx = i;
		}
	}
	int Ans = DBFS ();
	wint ( Ans ), putchar ( '\n' ); // Bye! 
}

int main () {
//	FileOpen ( "" );
	Work ();
//	FileClose ();
	return 0;
}
```

---

## 作者：q17770027225 (赞：1)


这道题在vjudge上写过一遍，用了两种方法写了两天QAQ
那道题还得把路径求出来，还不一定保证有解~~awsl~~洛谷太友善了qwq

方法一：双向bfs+康托展开

康托展开其实就相当于字符串哈希，不同的字符串映射到不同的数，双向bfs可以有效降低时间复杂度，毕竟遍历的深度会降低一半

本题ac代码：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
struct qw
{
	string x;
	int num;
};
int hash1[9]={1,1,2,6,24,120,720,5040,40320};
queue<qw> q[2];
string s1,b="123804765";
int vis[maxn][2]={0},d[4]={-3,3,-1,1},step=0;
int pan(int i,int x)//判断位置 
{
	if((i==0&&x<3)||(i==1&&x>5)) return 0;
	if((i==2&&x%3==0)||(i==3&&x%3==2)) return 0;
	return 1;
} 
int get_h(string s)//康托展开 
{
	int ans=0,i,j,k;
	for(i=0;i<9;i++)
	{ 
		k=0;
		for(j=0;j<i;j++)
		{
			if(s[j]>s[i]) k++;
		}
		ans+=k*hash1[i];
	}
	return ans;
}
void bfs(int t)
{
	int len=q[t].size();
	while(len--)
	{
		qw u=q[t].front();q[t].pop();
		for(int i=0;i<4;i++)
		{
			if(!pan(i,u.num)) continue;
			int bx=u.num+d[i];
			string c=u.x;swap(c[bx],c[u.num]);
			int p=get_h(c);
			if(vis[p][t]) continue;
			vis[p][t]=1;
			if(vis[p][t^1]) {cout<<step<<endl;exit(0);} 
			q[t].push((qw){c,bx});
		}
	}
}
void solve()
{
	vis[get_h(s1)][0]=vis[get_h(b)][1]=1;
	while(step<=5000)
	{
		step++;bfs(0);
		step++;bfs(1);
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>s1;
	//cout<<get_h(s1)<<" "<<get_h(b);
	for(int i=0;i<9;i++)
	if(s1[i]=='0') {q[0].push((qw){s1,i});}
	q[1].push((qw){b,4});
	if(s1==b) {cout<<"0"<<endl;return 0;}//特判 
	solve();
} 
```

求路径的代码，包括找不到路径情况的特判（起始状态和这道题不太一样）代码很丑QAQ
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <algorithm>
#include <cmath>
#include <queue>
#include <map>
#include <vector>
using namespace std;
const int maxn=5e5+10;
int hash1[9]={1,1,2,6,24,120,720,5040,40320};
struct node
{
	int num;//追溯上一个状态 
	char ch;//存储该状态的字符 
}pre[maxn];
int vis[maxn]={0},vis1[maxn]={0};
struct node2
{
	string c;//储存矩阵状态 
	int num;
}e;
int dir[4]={-3,3,-1,1};
char d[10]={"udlr"},d1[10]={"durl"};//方向 
void show(int x)//从最开始的点输出字符 
{
	if(pre[x].num==-1) return ;
	show(pre[x].num);
	printf("%c",pre[x].ch);
}
void show1(int x)//输出终点经过路径的字符 
{
	while(pre[x].num!=-1)
	{
		printf("%c",pre[x].ch);
		x=pre[x].num;
	}
	printf("\n");
}
int get_hash(string e)//获得哈希值康托展开
{
	int s=0,i,j,k;
	for(i=0;i<9;i++)
	{
		k=0;
		for(j=0;j<i;j++)
		if(e[j]>e[i]) k++;
		s+=k*hash1[i];
	}
	return s;
}
int pan(int i,int x)
{
	if((i==0&&x<3)||(i==1&&x>5)) return 0;
	if((i==2&&x%3==0)||(i==3&&x%3==2)) return 0;
	return 1;
} 
void bfs()
{
	int num=2;
	pre[1].num=-1;pre[2].num=-1;
	string end1="123456780";//终点 
	vis[get_hash(e.c)]=1;
	vis1[get_hash(end1)]=2;
	node2 f,w;
	queue<node2> q1,q2;
	f.c=end1,f.num=8;
	q1.push(e);q2.push(f);//存储最初状态
	while(!q1.empty()&&!q2.empty())
	{
		f=q1.front();q1.pop();
		int p=get_hash(f.c);
		if(vis1[p]) 
		{
			show(vis[p]);show1(vis1[p]);
			return;
		}
		for(int i=0;i<4;i++)
		{
			if(!pan(i,f.num)) continue;
			int x=f.num+dir[i];w=f;
			swap(w.c[f.num],w.c[x]);
			int q=get_hash(w.c);
			if(vis[q]) continue;
			vis[q]=++num;
			w.num=x;
			pre[num].num=vis[p];
			pre[num].ch=d[i];
			q1.push(w);
		}
		f=q2.front();q2.pop();
		p=get_hash(f.c);
		if(vis[p])
		{
			show(vis[p]);show1(vis1[p]);
			return;
		}
		for(int i=0;i<4;i++)
		{
			if(!pan(i,f.num)) continue;
			int x=f.num+dir[i];w=f;
			swap(w.c[f.num],w.c[x]);
			int q=get_hash(w.c);
			if(vis1[q]) continue;
			vis1[q]=++num;
			w.num=x;
			pre[num].num=vis1[p];
			pre[num].ch=d1[i];
			q2.push(w);
		}
	} 
	printf("unsolvable\n");
}
int main()
{
	char a[30];
	while(gets(a))
	{
		int i,j,k=0,n;
		n=strlen(a);
		e.c="";
		for(i=0,j=0;i<n;i++)
		{
			if(a[i]!=' ')
			{
				if(a[i]=='x') {e.num=j;e.c+='0';}
				else e.c+=a[i];
				j++;
			}
		}
		for(i=0;i<9;i++)
		{
			if(e.c[i]=='0') continue;
			for(j=0;j<i;j++)
			{
				if(e.c[j]=='0') continue;
				if(e.c[j]>e.c[i]) k++;
			}
		}
		memset(vis1,0,sizeof(vis1));
        memset(vis,0,sizeof(vis));
		if(k&1) printf("unsolvable\n");
		else bfs();
	}
	return 0;
} 
//4  3  2  7  5  x  1  6  8
```
A*算法（还是vjudge上的题）

可以和spfa相类比，一句话概括就是不断地求当前状态和目标状态的距离，距离（自己计算的，必定小于实际距离），先处理优先队列中离终点最小的点就行了。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm> 
#include<queue>
#include<vector>
#include<cmath>
#include<cstring>
using namespace std;
const int maxn=5e5+10;
struct qw
{
	int num;
	char ch;
}pre[maxn];
struct node
{
	int f[3][3];
	int x,y;
	int g,h;
	int hash_num;
	bool operator<(const node &a)const
	{
		return h+g>a.h+a.g;
	}
};
int dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}},vis[maxn]={0};
int ha[9]={1,1,2,6,24,120,720,5040,40320};
char d[5]={"udlr"};
int get_hash(node x)//状态压缩：康托展开 
{
	int i,j,k=0,a[9],ans=0;
	for(i=0;i<3;i++)
	for(j=0;j<3;j++) a[k++]=x.f[i][j];
	for(i=0;i<9;i++)
	{
		k=0;
		for(j=0;j<i;j++) if(a[j]>a[i]) k++;
		ans+=ha[i]*k;
	} 
	return ans;
}
//评估函数，获得评估值，计算1到8回到原点需要的最小步数，必定小于实际操作数 
int get_h(node x)
{
	int i,j,ans=0;
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			if(x.f[i][j])
			ans+=abs(i-(x.f[i][j]-1)/3)+abs(j-(x.f[i][j]-1)%3); 
		}
	}
	return ans;
}
void print(int x)
{
	if(pre[x].num==-1)  return;
	print(pre[x].num);
	printf("%c",pre[x].ch);
}
void A_star(node e)
{
	memset(vis,0,sizeof(vis));
	int q1=get_hash(e),k=1,en;
	node u,w;							
	for(int i=0;i<3;i++)
	for(int j=0;j<3;j++) 
	{
		if(i==2&&j==2) u.f[i][j]=0;
		else u.f[i][j]=k++;
	}
	en=get_hash(u);
	if(en==q1) {printf("\n");return;} 
	e.g=0;e.h=get_h(e);e.hash_num=q1;
	vis[q1]=1;pre[q1].num=-1;
	priority_queue<node> q;q.push(e);
	while(!q.empty())
	{
		u=q.top();q.pop();
		for(int i=0;i<4;i++)
		{
			int cx=u.x+dir[i][0],cy=u.y+dir[i][1];
			if(cx<0||cx>=3||cy<0||cy>=3) continue;
			w=u;swap(w.f[cx][cy],w.f[u.x][u.y]);
			q1=get_hash(w);
			if(vis[q1]) continue;vis[q1]=1;
			w.g+=1;w.h=get_h(w);w.x=cx;w.y=cy;w.hash_num=q1;
			pre[q1].num=u.hash_num;pre[q1].ch=d[i];
			if(q1==en) {print(q1);printf("\n");return;} 
			q.push(w);
		}
	}
	printf("unsolvable\n");
}
int main()
{
	char a[30];
	while(gets(a))
	{
		node e;
		int i,j,n,num=0;
		n=strlen(a);
		for(i=0;i<=n;i++)
		{
			if(a[i]!=' ')
			{
				if(a[i]!='x'&&a[i]>='1'&&a[i]<='8') e.f[num/3][num%3]=a[i]-'0';
				else if(a[i]=='x') {e.f[num/3][num%3]=0;e.x=num/3;e.y=num%3;} 
				num++;
			}
		}
		int b[10],k=0;
		for(i=0;i<3;i++)
		for(j=0;j<3;j++) b[k++]=e.f[i][j];
		for(i=0;i<9;i++)
		{
			k=0;
			for(j=0;j<i;j++) if(b[j]>b[i]) k++; 
		}
		if(k&1) printf("unsolvable\n");
		else A_star(e);
	}
}
//2  3  4  1  5  x  7  6  8
```




---

## 作者：fαns (赞：1)

~~这道题很明显是个**BFS**~~，意思就是从一个初始方阵开始，**移动0（空格）的位置**，使矩阵**变成最后的方阵**（123 804 765）。那么写一个**广搜**就可以完成此题了。
那么问题来了，如何解决**判重**的问题呢？

**一、map**

c++中的stl，可效率太低，pass（~~实际上是因为我不会用~~）

**二、哈希表**

楼下大佬们已经介绍的很详细了，本蒟就不再介绍了

**三、康拓展开+标记数组**

这里给大家介绍一个神奇的东西，康拓展开。

康拓展开其实就是求出一个数列是整个排列中的第几个，

公式为：康托展开的公式是 **X=a1*(n-1)!+a2*(n-2)!+...+an*0!**

其中，**Ai指的是位于位置i后面的数小于Ai值的个数**

如，在（1，2，3，4，5）5个数的排列组合中，计算 14352位于第几个排列。

第一位是1，后面**没有比1小的数**，所以a1=0；

第二位是4，后面3,2比4小，所以a2=2；

第三位是3，后面2比3小，所以a3=1；

第四位是5，后面2比5小，所以a4=1；

第五位是2，后面**没有数比它小**，所以a5=0；

代入公式，得：

```
X=0*4!+2*3!+1*2!+1*1!+0*0!

X=0+12+2+1

X=15
```

所以14352的康拓展开值为15

但是如果要**求是第几个排列的话，就还需要加1**

所以14352是第**16**个排列。

code：
```cpp
int cantor(int a[], int n)
{
	int ans = 0;
	for (int i = 1;i <= n;i++)
	{
		int x = 0, c = 1, m = 1;
		for (int j = i + 1;j <= n;j++)
		{
			if (a[j] < a[i]) x++;
			m *= c;
			c++;
		}
		ans += x * m;
	}
	return ans;
}
```
那么我们就只需要开一个**标记数组**来标记所有康拓展开值就行了。
（**876543210的康拓展开值是362879，所以把数组开到362881就行了**）

废话不说，上代码：
```
#include <cstdio>
#include <cstdlib> 
#include <cstring>
#include <algorithm>
using namespace std;
int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};	//空格移动四个方向的变化
struct node
{
	int nonex, noney;	//存空格的x和y坐标
	int step;	//存步数
	int a[4][4];	//存棋盘
}q[362881];
int book[362881], need = 46686;	//123804765是第46686个排列。
int cantor(int tmp[][4], int n)	//康拓展开
{
	int a[10];
	for (int i = 1;i <= 3;i++)
		for (int j = 1;j <= 3;j++)
			a[(i - 1) * 3 + j] = tmp[i][j];	//二维转一维
	int ans = 0;
	for (int i = 1;i <= n;i++)
	{
		int x = 0, c = 1, m = 1;
		for (int j = i + 1;j <= n;j++)
		{
			if (a[j] < a[i]) x++;
			m *= c;
			c++;
		}
		ans += x * m;
	}
	return ans;
}
void bfs(int a[][4])
{
	int tmpx, tmpy, head = 0, tail = 0;
	for (int i = 1;i <= 3;i++)	//找到空格的位置
	{
		for (int j = 1;j <= 3;j++)
		{
			if (a[i][j] == 0)
			{
				tmpx = i;
				tmpy = j;
				break;
			}	
		}
	}
	q[++tail].nonex = tmpx;
	q[tail].noney = tmpy;
	q[tail].step = 0;
	for (int i = 1;i <= 3;i++)
		for (int j = 1;j <= 3;j++)
			q[tail].a[i][j] = a[i][j];
	book[cantor(a, 9) + 1] = 1;	//打标记
	if(cantor(a, 9) + 1 == need) 	//要加上，不然第31个点过不了（我被卡过一次了，而且还10分（其它点都三分））
	{
		printf("0");
		return;
	}
	while (head < tail)
	{
		head++;
		for (int i = 0;i < 4;i++) //枚举空格的移动
		{
			int xx = q[head].nonex + dx[i];
			int yy = q[head].noney + dy[i];
			if (xx > 3 || xx < 1 || yy > 3 || yy < 1) continue;	//判越界
			int b[4][4];
			for (int j = 1;j <= 3;j++)
				for (int k = 1;k <= 3;k++)
					b[j][k] = q[head].a[j][k];
			swap(b[q[head].nonex][q[head].noney], b[xx][yy]);
			int tt = cantor(b, 9) + 1;
			if (book[tt] == 0) //判断是否已经入队
			{
				book[tt] = 1;
				q[++tail].nonex = xx;
				q[tail].noney = yy;
				q[tail].step = q[head].step + 1;
				for (int j = 1;j <= 3;j++)
					for (int k = 1;k <= 3;k++)
						q[tail].a[j][k] = b[j][k];
				if (tt == need)	//判断是否找到答案
				{
					printf("%d", q[tail].step);
					return;
				}
			}
		}
	}
}
int main()
{
	int a[4][4];
	char x[10];
	scanf("%s", x);
	for (int i = 0;i < 9;i++)
		a[i / 3 + 1][i % 3 + 1] = x[i] - '0'; //将一维数组转化成二维数组
	bfs(a);
	return 0;
}
```

---

## 作者：2x6_81 (赞：1)

这道题，用普通的BFS就行，不用双向（~~因为我不会~~，但真的普通的就可以过）

将矩阵变成一个字符串（其实就是哈希），那么`a(x,y)`中的内容就变成了`b(x*3+y)`（想一想，为什么）

目标矩阵：
```
1 2 3
8 0 4
7 6 5
```
HASH：`123804765`

以`0`来BFS，控制`0`的位置，其他就像正常BFS一样啦，注意输入的就是目标矩阵。map去重。
Code：
```
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast")
string s,to="123804765";
map<string,bool> vis;
struct per
{
	string ss;
	int zx,zy,st;
	per(string s,int x,int y,int step)
	{ss=s;zx=x;zy=y;st=step;}
};//ss:HASH,zx:0的x坐标,zy:0的y坐标(方便判断),step:步数  
queue<per> q;
int f0(string s)
{
	for(int i=0;i<s.size();i++)
	if(s[i]=='0')
	return i;
	return -1;
}//判断0的位置  
int bfs()
{
	int dir[4][2]={0,-1,-1,0,0,1,1,0};
	int t=f0(s);
	q.push(per(s,t/3,t%3,1));//b(x) -> a(x/3,x%3) (想一想,为什么)
	vis[s]=1;//标记 
	while(!q.empty())
	{
		per t=q.front();
		for(int i=0;i<4;i++)
		{
			int tx=t.zx+dir[i][0];
			int ty=t.zy+dir[i][1];
			if(tx<0||tx>2||ty<0||ty>2)continue;
			swap(t.ss[t.zx*3+t.zy],t.ss[tx*3+ty]);//交换 
			if(t.ss==to)return t.st;
			if(vis[t.ss]){swap(t.ss[t.zx*3+t.zy],t.ss[tx*3+ty]);continue;}
			vis[t.ss]=1;//标记 
			q.push(per(t.ss,tx,ty,t.st+1));
			swap(t.ss[t.zx*3+t.zy],t.ss[tx*3+ty]);//换回来  
		}
		q.pop();
	}//普通BFS  
	return 0;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>s;//因为有string,只能用cin(方便于比较) 
	if(s==to) cout<<'0'<<endl;
	else cout<<bfs()<<endl;
	return 0;
}
```

---
第二种，记忆化BFS，（我不想贴代码了）

---

## 作者：处1a2b3c4d (赞：1)

# STL大法好！！！

### 使用STL中的queue和set可以很快水过此题！

# 算法：普通BFS(洛谷服务器就是快!)

### 话说NOIP级别的选手是不是可以大量使用STL来减少代码量和出错率啊？感觉NOIP不会毒瘤卡常的说...

**注意：**

- 状态的转移有条件，不要做将位于第一行的数字与其上方的数字交换这样的傻事！

- set库中find()函数使用时一定要搭配对应的迭代器，当集合中存在该元素时返回其所在的迭代器，反之返回end()迭代器的值

然后就是源代码了，~~详尽的~~注释应该能帮助新手们看懂代码：

```cpp
#include<set>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;
int getp(int x,int y){return x*3+y;}//找到在九宫格中当前位点所对应的标号->[0,8] 
struct Cse{
	int f[9],x,y;//九宫格和0点的x,y坐标 
	inline Cse UpShft(){Cse ans=*this; swap(ans.f[getp(x,y)],ans.f[getp(x-1,y)]); ans.x=x-1; return ans;} 
	inline Cse DwnShft(){Cse ans=*this; swap(ans.f[getp(x,y)],ans.f[getp(x+1,y)]); ans.x=x+1; return ans;}
	inline Cse LftShft(){Cse ans=*this; swap(ans.f[getp(x,y)],ans.f[getp(x,y-1)]); ans.y=y-1; return ans;}
	inline Cse RhtShft(){Cse ans=*this; swap(ans.f[getp(x,y)],ans.f[getp(x,y+1)]); ans.y=y+1; return ans;}
	//四个函数上下左右移动0点位置更新x,y值并返回移动后结果 
	bool operator == (const Cse& rhs) { for(int i=0;i<9;i++) if(f[i]!=rhs.f[i]) return 0; return 1; }//重载==运算符便于判断状态 
	int turn(){long long ans=0; for(int i=0;i<9;i++) ans=ans*10+(f[i]-'0'); return ans;}//将当前九宫格内状态转化为数字(Hash) 
	void print(){for(int i=0;i<9;i++) cout<<f[i]<<" "; cout<<endl;}//调试用输出 
};
queue<Cse> Q;//BFS标配队列 
set<int> Set;//判重所用的集合 
set<int>::iterator itr;//为判重步骤专门声明的迭代器，用来存储find()函数的返回值并于end()迭代器做对比 
queue<int> Step;//格外用一个队列来保存转移到当前状态的操作步数 
int main()
{
	Cse res={{1,2,3,8,0,4,7,6,5},1,1};//定义最终状态 
	int f[9],x,y;
	char c;
	for(int i=0;i<9;i++) {cin>>c; f[i]=c-'0'; if(f[i]==0) x=i/3 , y=i%3;}//读入初始状态并找到x,y的值 
	Cse Start={{f[0],f[1],f[2],f[3],f[4],f[5],f[6],f[7],f[8]},x,y};//定义末状态 
	Q.push(Start);
	Step.push(0);//状态和步数入队 
	while(!Q.empty())
	{
		Cse np=Q.front();
		Q.pop();
		int ns=Step.front();
		Step.pop();//状态与步数出队 
		if((itr=Set.find(np.turn()))!=Set.end()) continue;//判重：如果集合中有一个状态使用turn函数得到的hash值与当前状态相同则跳过 
		Set.insert(np.turn());//记录下当前状态 
		if(np==res) {cout<<ns; return 0;}//如果当前状态为目标状态，输出并退出 
		if(np.x!=0) {Q.push(np.UpShft());  Step.push(ns+1);}
		if(np.x!=2) {Q.push(np.DwnShft()); Step.push(ns+1);}
		if(np.y!=0) {Q.push(np.LftShft()); Step.push(ns+1);}
		if(np.y!=2) {Q.push(np.RhtShft()); Step.push(ns+1);}//根据当前状态的x,y坐标讨论下一步的变化,将下一步的状态与步数入队 
	}
}
```

---

## 作者：Cobalt (赞：1)

### 比较明显的宽搜，对于每一种状态让空格和上下左右的棋子交换位置
### 状态存储：
为了防止MLE，和题目一样用一个数字保存棋子的顺序
### 判重
用STL的set，代码会比较短
### 队列因为不知道该开多大直接用STL的
我觉得代码还是很短的：
```cpp
#include <cstdio>
#include <set>
#include <queue>
#include <cmath>
using namespace std;
struct node{
	int val;//状态 
	int step;//到这个状态的步数 
};
int f[4][4],i,j,k,n,v,m,t,sx,sy,b=123804765;
queue <node> q;
set <int> book;
node a;

int F(int u,int tx,int ty,int sx,int sy){
	//u: 原状态 | tx,ty:要和空格替换棋子的位置 | sx,sy:空格的位置  
	int t=f[tx][ty];
	u=u-t*pow(10,9-(tx-1)*3-ty)+t*pow(10,9-(sx-1)*3-sy); 
	return u;//返回互换位置之后的状态 
}

int main(){
	scanf("%d",&n);
	q.push((node){n,0});
	
	while(!q.empty()){
		a=q.front();
		q.pop();
		v=m=a.val;
		
		if(book.find(v)!=book.end())//set判重 
			continue;
		book.insert(v);
		
		if(v==b){
			printf("%d",a.step);//如果到达目标状态就输出 
			return 0;
		}
		//先把数字换成数组（好吧是因为我太弱） 
		for(i=3;i>=1;i--){
			for(j=3;j>=1;j--){
				f[i][j]=v%10;
				v/=10;
				if(!f[i][j]){
					sx=i;sy=j;
				}
			}
		}
		//和四个方向的棋子换位置 
		if(sx>1){
			k=F(m,sx-1,sy,sx,sy);
			q.push((node){k,a.step+1});
		}
		if(sx<3){
			k=F(m,sx+1,sy,sx,sy);
			q.push((node){k,a.step+1});
		}
		if(sy>1){
			k=F(m,sx,sy-1,sx,sy);
			q.push((node){k,a.step+1});
		}
		if(sy<3){
			k=F(m,sx,sy+1,sx,sy);
			q.push((node){k,a.step+1});
		}
		
	}
	return 0;
} 
```

---

## 作者：封禁用户 (赞：1)

看到这题题解清一色的康托


我觉得这真的必要么......


状态是9位数，只要知道8个数字另外一个自然也就知道了


数字0---8显然只要九进制


那暴力开bool桶就好了啊......


为了节约时间用char进行的纯广搜无优化，共计1010ms。虽然不快，但至少过所有点也是无压力的



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
bool ss[88888888];//数字随便打的
int i,j,k,m,n,h,t;char sans[10]={'0','1','2','3','8','0','4','7','6','5'};//最终状态
struct ppp{
    int f,x;
    char t[10];
}a[500001];
void push(char s[10],int x,int ans)
{
    int anst=1,p=0;
    for(int i=1;i<=8;i++)求这个数字的前八位九进制表示
    {
        p+=anst*(s[i]-48);
        anst*=10;
    }
    if(ss[p])return;
    ss[p]=1;
    if(!strcmp(s,sans))
    {
        cout<<ans+1;
        exit(0);
    }
    t++;
    a[t].f=ans+1;strcpy(a[t].t,s);a[t].x=x;
}
inline void Swap(char &c1,char &c2)//手写的稍微快一点
{
    char c3=c1;c1=c2;c2=c3;
}
int main()
{
    gets(a[1].t);
    for(int i=9;i>=1;i--)
    a[1].t[i]=a[1].t[i-1]; a[1].t[0]='0';//不要介意，我觉得1---9表示看起来顺一点.........
    for(i=1;i<=9;i++)if(a[1].t[i]=='0')break;
    h=0,t=1;a[1].f=0;a[1].x=i;
    while(h<t)//广搜模版部分
    {
        h++;
        int q=a[h].x;
        if(q-3>=1)Swap(a[h].t[q],a[h].t[q-3]),push(a[h].t,q-3,a[h].f),Swap(a[h].t[q],a[h].t[q-3]);
        if(q+3<=9)Swap(a[h].t[q],a[h].t[q+3]),push(a[h].t,q+3,a[h].f),Swap(a[h].t[q],a[h].t[q+3]);
        if(q%3!=1)Swap(a[h].t[q],a[h].t[q-1]),push(a[h].t,q-1,a[h].f),Swap(a[h].t[q],a[h].t[q-1]);
        if(q%3!=0)Swap(a[h].t[q],a[h].t[q+1]),push(a[h].t,q+1,a[h].f),Swap(a[h].t[q],a[h].t[q+1]);
    }
}
```

---

## 作者：zxxdxlh (赞：1)

    

        
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
int vis[362885],ss;  //visit数组：此康托展开值是否被访问过 
const int jc[]={1,1,2,6,24,120,720,5040,40320,362880};  //阶乘打表 
const int dx[]={-1,1,0,0};  //控制 
const int dy[]={0,0,-1,1};  //移动 
struct node{
    int x,y;     //结构体中-坐标 
    int step;    //步数 
    int a[10];   //数列 
};
node target;     //定义 target为最终状态
queue<node> q;
int result(int a[])  //康托展开 
{
    int sum=0,num;
    for(int i=0;i<9;i++){
        num=0;
        int cur=a[i];
        for(int j=i+1;j<9;j++){
            if(a[j]<cur) num++;
        }
        sum+=num*jc[8-i];    
    }
    return sum;
}
void bfs()
{
    while(!q.empty()){            //若队列不为空 
        node cs=q.front();        //将当前队首赋给cs 
        q.pop();                  //将队首弹出 
        if(result(cs.a)==ss) {    //若此时cs康托展开值等于最终状态的值 
        printf("%d\n",cs.step) ;return ;}  //打印此时步数并返回 
        int x=cs.x,y=cs.y,yl=x*3+y;       //若还不等于最终值  定义x=原来行数，y=原来列数，yl= 原来空格所在的位置 
        for(int i=0;i<4;i++){    //循环：尝试向四个方向移动 
            node ns;            //定义移动后的ns 
            ns=cs;              //把原来的cs赋给ns 
            int nx=x+dx[i];     //移动行数 
            int ny=y+dy[i];        //移动列数 
            if(nx>=0&&nx<3&&ny>=0&&ny<3){   //若未出边界 
                int xz=nx*3+ny;        //定义 xz=移动后的空格所在位置 
                ns.a[yl]=cs.a[xz];  //将交换空格位置的值与空格位置的值交换 
                ns.a[xz]=0;   //将交换空格位置的值与空格位置的值交换 
                ns.step=cs.step+1; //步数+1 
                ns.x=nx,ns.y=ny;   //将移动后的行列数赋给ns中的x，y 
            }
            if(!vis[result(ns.a)]) {  //如果此排列的康托展开未被占用 
                vis[result(ns.a)]=1;  //那么将此排列的康托展开值占用 
                q.push(ns);            //将此排列放入队列 
            }        
        }
    }
}
int main()
{
    char s[10];              //s[]表示初始状态 
    scanf("%s",s);
    node start;              //将初始字符型转换为int型 
    for(int i=0;i<9;i++) start.a[i]=s[i]-'0';    //start.a[i]为初始的排列 
    for(int i=0;i<9;i++)
        if(start.a[i]==0){                        //若出现空格 
            start.x=i/3;                       //start.x初始行 
            start.y=i%3;                       //start.y初始列 
            break;
        }                                     //找到初始坐标   start.x start.y 初始数列 start.a[] 
    start.step=0;                             //设开始步数为0 
    q.push(start);                            //将初始状态 start.x start.y start.a[] start.step放进队列 
    vis[result(start.a)]=1;                  //初始状态的数列康托展开值已被占用 
    int b[10]={1,2,3,8,0,4,7,6,5};            //最终状态 
    memcpy(target.a,b,sizeof(target.a));    //将b数组（最终状态）的值赋给target中的a数组 
    ss=result(target.a);                    //定义ss为最终数列的康托展开值 
    bfs();
    return 0;
}

```

---

## 作者：ww3113306 (赞：1)

作为一个蒟蒻，，这道题做了2个小时多。。最后发现居然是没有判断是不是非法移动。。

首先只用bfs是会超时的，这里我用了康托展开，主要是判重可以省时间；

康托展开大致意思就是让每一种排列都有一个唯一的数字与之对应，这样判重的时候就不用一个一个比对，直接比较算出来的数字就行了。具体实际方法和思想请自行百度。。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct abc{
    int x[10];//队列中每个都存下整个排列
    int w;//记录空格在哪
    int ans;//记录当前移动步数
};
int k[]={1,1,2,6,24,120,720,5040,40320},a[4]={3,-3,-1,1},s[10],want;
abc h[500000];
char o[10];
bool z[500000];//数组开大一点，不然会re
int kang()//康托展开
{
    int sum=0,i,j,t;
    for(i=1;i<=9;i++)
    {
        t=0;
        for(j=i;j<=9;j++)
        {
            if(s[i]>s[j]) t++;
        }
        sum+=t*k[9-i];
    }
    return sum;
} 
bool may(int kk,int p)//判断移动是否合法，这里只判断两种，因为其他的情况我在bfs中顺便判断了
{
    if(kk==3||kk==6||kk==9) 
        if(p==1) return false;
    if(kk==4||kk==7) 
        if(p==-1) return false;    
    return true;    
}
void bfs(int y)
{
    int i,head=0,tail=1;
    for(i=1;i<=9;i++)
        h[1].x[i]=s[i];    
    z[kang()]=true;    
    while(head<tail)//队列不解释
    {
        head++;
        for(i=0;i<4;i++)
        {
            y=h[head].w;
            for(int j=1;j<=9;j++)
                s[j]=h[head].x[j];//用s数组来存将要进行移动的状态
//（用另外一个数组来存，防止向另一个方向移动时这个状态被提前改变）
            if(y+a[i]>0&&y+a[i]<=9) 
            {
                if(may(y,a[i])==false) continue;
                swap(s[y],s[y+a[i]]);
                if(z[kang()]) continue;
                z[kang()]=true;
                tail++;
                for(int j=1;j<=9;j++)
                h[tail].x[j]=s[j];
                h[tail].w=y+a[i];
                h[tail].ans=h[head].ans+1;    //每移动一次，步数加1（注意要在前面的基础上加1）
            }
            if(kang()==want)//如果移动到了目标状态就输出，因为bfs的特性，所以一旦移动到，就是最少步数
            {
                printf("%d",h[tail].ans);
                return ;
            }
        }
    }
}
int main()
{
    int i,where;
    memset(z,0,50000);//初始化z数组
    cin>>o;
    for(i=0;i<=8;i++)//用字符数组读入
    {
        s[i+1]=o[i]-'0';//转化成数字存入数组
        if(s[i+1]==0) where=i+1;
    }
    want=46685;//提前算出代表目标状态的数字
    h[1].w=where;//存下空格的初始位置
    bfs(where);//开始bfs
    return 0;
}
```

---

## 作者：NeosKnight (赞：1)

这道题直接单向 BFS 加康托展开就可以了， 最慢的也只跑了 200多一点点MS；


先说下在这道题中康托展开的用途（具体怎么展开去网上看吧，只有自己看懂了才是最好的）：


其实这道题中康托展开的唯一用途就是 "方便判重"  ，展开后得到的一个值可直接对应一个下标，用 BOOL型数组存储该状态是否出现过即可；


状态存储我的是用的一个一维数组（其实是2维，因为是广搜要存储每一个节点）来存储状态，怎么交换位置的话看了我的代码自己模拟一下就可以了；


下面看代码吧





```cpp
#include<cstdio>
#include<iostream>
#include<cstdio>
#include<cstring> 
using namespace std;
const int fac[11]={1,1,2,6,24,120,720,5040,40320,362880};
int now[999999][11];
int  step[999999][2];
int gg[5000000];
int KT(int a[11])//康托展开，不知道的网上查
{
    int num=0;
    for(int i=0;i<=8;i++)
    {
        int k=0;
        for(int j=i+1;j<=8;j++)
        {
            if(a[i]>a[j]){
                k++;
            }
        }
        num+=k*fac[8-i];
    }
    return num;
}
inline bool pd(int pos,int how)//用来判断改位置交换方式是否可行（自己模拟一下就行）
{
    switch(how){
        case 1:
            if(pos>=3) return 1;
            else return 0;
        case 2:
            if(pos!=0&&pos!=3&&pos!=6) return 1;
            else return 0;
        case 3:
            if(pos!=2&&pos!=5&&pos!=8) return 1;
            else return 0;
        case 4:
            if(pos<=5) return 1;
            else return 0;
    }
}
void bfs()
{
    int h=0;int t=1;
    do{
        h++;
        for(int i=1;i<=4;i++)//枚举方式（1是上移（空位置），2是左移，3是右移，4是下移）
        {
            if(pd(step[h][1],i))
            {
                t++;
                for(int j=0;j<=8;j++)  {now[t][j]=now[h][j];}
                step[t][0]=step[h][0]+1;//记录步数
                step[t][1]=step[h][1]+2*i-5;//位置交换（自己模拟就知道了）
                swap(now[t][step[h][1]],now[t][step[t][1]]);
                int g=KT(now[t]);//计算康托展开后的数值
                if(g==46685){//这是目标状态
                    cout<<step[t][0]<<endl;return ;
                }
                if(gg[g]) {t--;}//去重
                gg[g]=1;//标记
            }
        }
    }while(h<t);
}
int main()
{
    char x=getchar();int l=0;
    while(x>'9'||x<'0') x=getchar();
    while(x>='0'&&x<='9'){//读入
        now[1][l]=x-'0';
        if(x=='0') {
            step[1][1]=l;
        }
        l++;
        x=getchar();
    }
    step[1][0]=0;
    bfs();
    return 0;
}

```

---

## 作者：Cekavis (赞：1)

### 我实在是太菜了


## 这题可行做法(不一定AC)应该是:

```cpp
    1.IDA*(启发式迭代加深)

    2.迭代加深(我菜到写不出启发式)

    3.bfs

    4.双向bfs
```
## 还有可行的判重:

```cpp
    1.map(无脑)

    2.hash

    3.康托展开
```

### 然后可以随便组合....(不保证不TLE

康托展开,限于我的水平,没去写~~(懒)~~


不用康托展开,个人感觉,一个状态用int存可能会比string等稍微好一点...方便一点,所以三个程序都是这样...


## 我写了如下三种...丑得不行(~~水平有限,无法作注释~~仅供参考)



```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
#define ll long long
const int N=10000002,M=1999993,go=123804765,p[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
int s,h,Hash[2000002],d[N],q[N],t;
short int a[N];
void Insert(int x){
  for(int i=0;1;i++)
    if(!Hash[(x+i*i)%M]){
      Hash[(x+i*i)%M]=x;
      break;
    }
}
bool Query(int x){
  for(int i=0;1;i++)
    if(!Hash[(x+i*i)%M]) return 0;
    else if(Hash[(x+i*i)%M]==x) return 1;
}

void work(int i,int j){
  int x=p[i],y=p[j],tmp=s-s/y%10*y+s/y%10*x;
  if(!Query(tmp)){
    if(tmp==go){
      cout<<d[h]+1;
      exit(0);
    }
    Insert(tmp);
    q[++t]=tmp;
    a[t]=j+1;
    d[t]=d[h]+1;
  }
}
int main(){
  cin>>s;
  q[t=1]=s;
  for(int i=1;i<=9;i++){
    if(s%10==0){
      a[1]=i;//从右向左数第几个...位 
      break;
    }
    s/=10;
  }
  
  while(h<t){
    s=q[++h];
    //printf("%d %d\n",s,a[h]);
    int i=a[h];
    if((i-1)%3) work(i-1,i-2);
    if(i%3) work(i-1,i);
    if(i>3) work(i-1,i-4);
    if(i<7) work(i-1,i+2);
  }
  return 0;
}
```


```cpp
#prag\
ma GCC optimize (2)
#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
const int N=200002,M=1999993,go=123804765,p[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
int s,h,Hash[M],q[N],f[M],Hash1[M],f1[M],t,t1,q1[N];
short int a[N],a1[N],d[N],d1[N];
inline void Insert(int x,int y){
  int tmp;
  for(int i=0;1;i++)
    if(!Hash[tmp=(x+i*i)%M]){
      Hash[tmp]=x;
      f[tmp]=y;
      break;
    }
}
inline int Query(int x){
  for(int i=0;1;i++)
    if(!Hash[(x+i*i)%M]) return 0;
    else if(Hash[(x+i*i)%M]==x) return f[(x+i*i)%M];
}
inline void Insert1(int x,int y){
  int tmp;
  for(int i=0;1;i++)
    if(!Hash1[tmp=(x+i*i)%M]){
      Hash1[tmp]=x;
      f1[tmp]=y;
      break;
    }
}
inline int Query1(int x){
  for(int i=0;1;i++)
    if(!Hash1[(x+i*i)%M]) return 0;
    else if(Hash1[(x+i*i)%M]==x) return f1[(x+i*i)%M];
}

inline void work(int i,int j){
  int x=p[i],y=p[j],tmp=s-s/y%10*y+s/y%10*x;
  if(!Query(tmp)){
    if(Query1(tmp)){
      cout<<d[h]+1+Query1(tmp)-2;
      //cout<<endl<<"0"<<tmp<<endl<<(Hash1[tmp%M]==tmp)<<' '<<f1[tmp%M];
      exit(0);
    }
    Insert(tmp,d[h]+1);
    q[++t]=tmp;
    a[t]=j+1;
    d[t]=d[h]+1;
  }
}

inline void work1(int i,int j){
  int x=p[i],y=p[j],tmp=s-s/y%10*y+s/y%10*x;
  if(!Query1(tmp)){
    if(Query(tmp)){
      cout<<d1[h]+1+Query(tmp)-2;
      exit(0);
    }
    Insert1(tmp,d1[h]+1);
    q1[++t1]=tmp;
    a1[t1]=j+1;
    d1[t1]=d1[h]+1;
  }
}
int main(){
  cin>>s;
  q[t=1]=s;
  for(int i=1;i<=9;i++){
    if(s%10==0){
      a[1]=i;//从右向左数第几个...位 
      break;
    }
    s/=10;
  }
  d[1]=1;
  Insert(s,1);
  
  q1[t1=1]=go;
  a1[1]=5;
  d1[1]=1;
  Insert1(go,1);
  
  while(h<t){
    s=q[++h];
    int i=a[h];
    if((i-1)%3) work(i-1,i-2);
    if(i%3) work(i-1,i);
    if(i>3) work(i-1,i-4);
    if(i<7) work(i-1,i+2);
    
    s=q1[h];
    i=a1[h];
    //printf("%d %d\n",s,d1[h]);
    if((i-1)%3) work1(i-1,i-2);
    if(i%3) work1(i-1,i);
    if(i>3) work1(i-1,i-4);
    if(i<7) work1(i-1,i+2);
  }
  return 0;
}
```


```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
#define ll long long
const int go=123804765;
int s,h;
map<int,int> a;
inline int w(int x,int y){
  return x/y%10;
}
inline void Swap(int x,int t,int k,int &n,int &d,int tmp[],int v[]){
  int xt=x/t%10,xk=x/k%10;
  tmp[++n]=x-xk*k+xk*t;
  if(a[tmp[n]]&&a[tmp[n]]>d+1){
    n--;
    return;
  }
  v[n]=(xt==go/t%10)+(xk==go/k%10)-(tmp[n]/t%10==go/t%10)-(tmp[n]/k%10==go/k%10);
}
void dfs(int s,int d){
  if(s==go){
    cout<<d;
    exit(0);
  }
  if(d==h) return;
  //printf("%d %d\n",s,d);
  a[s]=d;
  int t=1,n=0,tmp[5],v[5];
  for(int i=9;i;i--){
    if(s/t%10==0){
      if((i-1)%3) Swap(s,t,t*10,n,d,tmp,v);
      if(i%3) Swap(s,t,t/10,n,d,tmp,v);
      if(i<7) Swap(s,t,t/1000,n,d,tmp,v);
      if(i>3) Swap(s,t,t*1000,n,d,tmp,v);
      //for(int j=2;j>=-2;j--)
        for(int k=1;k<=n;k++) /*if(v[k]==j)*/ dfs(tmp[k],d+1);
      break;
    }
    t*=10;
  }
}
int main(){
  cin>>s;
  for(h=1;2333;h++){
    dfs(s,0);
    a.clear();
  }
  return 0;
}
## 1.bfs+hash(共540ms)居然神奇地AC了

## 2.双向bfs+hash(115ms,加了inline,O2什么的...最后也很慢)

## 3.迭代加深+map(46分,TLE,可以跳过了...)

```

---

## 作者：ustze (赞：1)

看到楼下那么长的代码，我就发个短点的吧!

所需知识：康托展开（楼下有讲，我就不多说了），bfs（这个应该没人不会吧）

代码如下：



```cpp
#include<iostream>
#include<cmath>
using namespace std;
int f[10]= {1,1,2,6,24,120,720,5040,40320};
int nx[4]= {1,0,0,-1};
int ny[4]= {0,1,-1,0};
int fg[500000];
bool flag=false;
struct node
{
    int x,y; //坐标
    int fa; 
    int step;
    int f1[15]; //当前的顺序
} a[500000];
int c(int a[])  //计算康托展开的值
{
    int sum=0;
    for(int i=1; i<=9; i++)
    {
        int s=0;
        for(int j=1; j<i; j++)
            if(a[j]>a[i])
                s++;
        sum+=s*f[i-1];
    }
    return sum;
}
int main()
{
    for(int i=1; i<=9; i++)
    {
        char x;
        cin>>x;
        if(x=='0')
        {
            a[0].f1[i]=0;
            a[0].x=ceil(i/3.0);
            a[0].y=(i-1)%3+1;
        }
        else
            a[0].f1[i]=x-'0';
    }
    int head=0,tail=1;
    a[0].step=0;
    while(head<tail) //bfs
    {
        for(int k=0; k<=3; k++)
        {
            int tx=a[head].x+nx[k],ty=a[head].y+ny[k];
            if(tx<1||tx>3||ty<1||ty>3)
                continue;
            for(int i=1; i<=9; i++) a[tail].f1[i]=a[head].f1[i];
            swap(a[tail].f1[(a[head].x-1)*3+a[head].y],a[tail].f1[(tx-1)*3+ty]);  //换格子
            if(!fg[c(a[tail].f1)])  //如果当前状态没遍历过
            {
                a[tail].x=tx;
                a[tail].y=ty;
                a[tail].fa=head;
                a[tail].step=a[head].step+1;
                fg[c(a[tail].f1)]=1;
                tail++;
            }
        }
        if(c(a[head].f1)==131976)  //131976就是题目中要达到的康托展开值
        {
            cout<<a[head].step;
            break;
        }
        head++;
    }
    return 0;
}
```

---

## 作者：半云_ (赞：1)

本题可以用双向广搜~~

脑袋有点炸，写的些微复杂，












    

 

```cpp
//八数码问题－双向宽度搜索演示版 
#include <iostream>
using namespace std;
int p1,p2,t1,t2,number,x[5];//p为首，t为尾，number为交换的总次数 
struct node
{
  string str;
  int pre;//前导 
}c1[70004],c2[70004];
int change(int p0)//找出可交换的可能次数，及能交换的所在位置 
{
  if(p0==0)
  { x[1]=1,x[2]=3;return 2;  }
  else if(p0==1)
  { x[1]=0,x[2]=2,x[3]=4;return 3; }
  else if(p0==2)
  { x[1]=1,x[2]=5;return 2;  }
  else if(p0==3)
  { x[1]=0,x[2]=4,x[3]=6;return 3;}
  else if(p0==4)
  { x[1]=1,x[2]=3,x[3]=5,x[4]=7;return 4; }
  else if(p0==5)
  { x[1]=2,x[2]=4,x[3]=8;return 3; }
  else if(p0==6)
  { x[1]=3,x[2]=7;return 2;  }
  else if(p0==7)
  { x[1]=4,x[2]=6,x[3]=8;return 3; }
  else if(p0==8)
  { x[1]=5,x[2]=7;return 2;  }
}
void outC1(int v)//递归逆序输出 
{
  if(v==1)
  {
    number++;
  }
  else
  { 
    outC1(c1[v].pre);
    number++;
  }  
}
void outC2(int v)
{
  while(v>=1)
  {          
    number++;          
    v=c2[v].pre;
  }
}
void out()
{
  outC1(t1);
  outC2(c2[t2].pre);
  cout<<number-1<<endl;  
  exit(0);
}
int find(int x,string tmp)//查找本队列有无重复的字符串 
{
   int i,k;
   if(x==1)
   {
     for(i=1;i<=t1;i++)
       if(tmp==c1[i].str)
         return 1;
   }
   if(x==2)
   {
     for(i=1;i<=t2;i++)
       if(tmp==c2[i].str)
         return 1;     
   }  
   return 0;    
}
int checkC1(string tmp)//检查另一队列是否有碰头 
{
  int i;
  for(i=1;i<=t1;i++)
    if(tmp==c1[i].str)
    {
      t1=i;                
      return 1;
    }
  return 0;      
}
int checkC2(string tmp)//检查另一队列是否有碰头 
{
  int i;
  for(i=1;i<=t2;i++)
    if(tmp==c2[i].str)
    {
      t2=i;                
      return 1;
    }  
  return 0;
}
void addC1()//添加队列1 
{
  int k,i,pos,v;
  string tmp,t;
  k=p1;
  pos=c1[k].str.find('0',0);//找出0在何处 
  v=change(pos);//获得可以交换的次数 
  for(i=1;i<=v;i++)//将四个方向都遍历 
  { 
    tmp=c1[k].str;  //两两替换 
    t=tmp[x[i]];
    tmp.replace(pos,1,t);
    tmp.replace(x[i],1,"0");
    if(find(1,tmp)==0)//如果本队列无该新字符串，则添加 
    {
      t1++;
      c1[t1].str=tmp;
      c1[t1].pre=p1;
      if(checkC2(tmp)==1)//如果在另一队列碰头 
        out(); 
    }   
  }
  if(p1<t1)  
    p1++;    
} 
void addC2()//添加队列2 
{
  int k,i,pos,v;
  string tmp,t;
  k=p2;
  pos=c2[k].str.find('0',0);
  v=change(pos);
  for(i=1;i<=v;i++)//将四个方向都遍历 
  { 
    tmp=c2[k].str;  //两两替换 
    t=tmp[x[i]];
    tmp.replace(pos,1,t);
    tmp.replace(x[i],1,"0");
    if(find(2,tmp)==0)//如果本队列无该字符串，则添加新串 
    {
      t2++;
      c2[t2].str=tmp;
      c2[t2].pre=p2;
      if(checkC1(tmp)==1)//如果和另一队列重合，则打印结果 
        out();
    }
  }
  if(p2<t2)  
    p2++;    
} 
int main()
{ 
  int i;  
  string start;
  cin>>start;
  string goal= "123804765";
  p1=1,p2=1;//首指针 
  t1=1,t2=1;//尾指针 
  c1[1].str=start;//从下标1开始 
  c1[1].pre=0;
  c2[1].str=goal;
  c2[1].pre=0;
  while(t1<50000 ||t2<50000) 
  {
    if(t1<=t2 )//反复扩展队列，队列短的优先考虑
      addC1();
    else
      addC2();  
  }
  cout<<"-1\n";    
}
```

---

## 作者：fastle (赞：1)

我的题解是来说明，只要你不嫌麻烦，你就可能AC

作为一个刚怎么学搜索的蒟蒻来说，这个题还是有点困难的，TLE非常多次，直到我自学了康托展开（这不是打广告）

康托展开

对于X=a[n]\*(n-1)!+a[n-1]\*(n-2)!+...+a[i]\*(i-1)!+...+a[1]\*0! ，其中a[i]为当前未出现的元素中是排在第几个（从0开始）。这就是康托展开。

我们需要记录已经出现的状态，但是用数组来记既费空间又费时间，通过观察我们发现每个数字只出现一次，符合全排列的特点，所以我们可以用康托展开记录状态，这样只需要9！的note空间  值得注意的是 0的阶乘是什么不用担心，我刚开始还奇怪为什么0的阶乘是1，后来才发现在循环中，乘以fac【0】的数字一定是0。如下是康托展开的模板 （八位的）

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int fac[8] = { 1000, 1, 2, 6, 24, 120, 720, 5040 };
char c[8];
int kangtuozhankai(char c[])
{
    int len=strlen(c);
    int ans=0;
    for(int i=0;i<len;i++)
    {
        int tot=0;
        for(int j=i+1;j<len;j++)
          if(c[j]<c[i])
            tot++;
        ans+=tot*fac[len-1-i];
    }
    return ans;
}
int main()
{
    scanf("%s",c);
    int zz=kangtuozhankai(c);
    printf("%d",zz+1);
    return 0;
} 
```
可以将空位看作是零，每走一步可以看做零和他周围的某个数字交换位置，然后将九个方格看做一个组成的九位的数，然后进行广搜即可。同时我们可以用一维数组模拟二维数组
之后我发现我还是有个地方不会，因为我要用一维的数组模拟二维，所以在零和其他的交换时特别难受，不过没关系，耐心的我只用一个switch语句就解决了问题（不过长度……）

                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                
                   
                   
                   
                   
```cpp
#include<cstdio>
#include<iostream> 
#include<string>
#include<algorithm>
using namespace std;
struct note{string op;int w0;int step;};
string biaozhun("123804765");
int jiec[10]={1,1,2,6,24,120,720,5040,40320,362880};
note train[400000];bool visited[400000];
int head=0;int tail=0;
int kangtuozhankai(string a)
{
    int ans=0;
    for(int i=0;i<9;i++)
    {
        int tot=0;
        for(int j=i+1;j<9;j++)
          if(a[j]<a[i])
            tot++;
        ans+=tot*jiec[8-i];
    }
    return ans;
}
void push(string a,int wei,int step)
{
    train[tail].op=a;
    train[tail].w0=wei;
    train[tail].step=step;
    tail++;
    visited[kangtuozhankai(a)]=1;
}
int main()
{
    string jin;
    cin>>jin;
    int where;
    for(int i=0;i<9;i++)
      if(jin[i]=='0')
        where=i;
    push(jin,where,0);
    while(head<tail)
    {
        note now=train[head];
        head++;
        string dang=now.op;
        int k=now.w0;
        int s=now.step;
        if(now.op==biaozhun)
        {
            printf("%d",now.step);
            return 0;
        }
        switch(k)
        {
            case 0:swap(dang[0],dang[1]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,1,s+1);
                   swap(dang[0],dang[1]);
                   swap(dang[0],dang[3]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,3,s+1);
                   swap(dang[0],dang[3]);
                   break;
            case 1:swap(dang[1],dang[0]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,0,s+1);
                   swap(dang[1],dang[0]);
                   swap(dang[1],dang[2]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,2,s+1);
                   swap(dang[1],dang[2]);
                   swap(dang[1],dang[4]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,4,s+1);
                   swap(dang[1],dang[4]);
                   break;
            case 2:swap(dang[2],dang[1]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,1,s+1);
                   swap(dang[2],dang[1]);
                   swap(dang[2],dang[5]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,5,s+1);
                   swap(dang[2],dang[5]);
                   break;
            case 3:swap(dang[3],dang[0]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,0,s+1);
                   swap(dang[3],dang[0]);
                   swap(dang[3],dang[4]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,4,s+1);
                   swap(dang[3],dang[4]);
                   swap(dang[3],dang[6]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,6,s+1);
                   swap(dang[3],dang[6]);
                   break;                
            case 4:swap(dang[4],dang[1]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,1,s+1);
                   swap(dang[4],dang[1]);
                   swap(dang[4],dang[3]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,3,s+1);
                   swap(dang[4],dang[3]);
                   swap(dang[4],dang[5]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,5,s+1);
                   swap(dang[4],dang[5]);
                   swap(dang[4],dang[7]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,7,s+1);
                   swap(dang[4],dang[7]);
                   break;                    
            case 5:swap(dang[5],dang[2]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,2,s+1);
                   swap(dang[5],dang[2]);
                   swap(dang[5],dang[4]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,4,s+1);
                   swap(dang[5],dang[4]);
                   swap(dang[5],dang[8]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,8,s+1);
                   swap(dang[5],dang[8]);
                   break;
            case 6:swap(dang[6],dang[7]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,7,s+1);
                   swap(dang[6],dang[7]);
                   swap(dang[6],dang[3]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,3,s+1);
                   swap(dang[6],dang[3]);
                   break;                
            case 7:swap(dang[7],dang[6]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,6,s+1);
                   swap(dang[7],dang[6]);
                   swap(dang[7],dang[4]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,4,s+1);
                   swap(dang[7],dang[4]);
                   swap(dang[7],dang[8]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,8,s+1);
                   swap(dang[7],dang[8]);
                   break;                
            case 8:swap(dang[8],dang[7]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,7,s+1);
                   swap(dang[8],dang[7]);
                   swap(dang[8],dang[5]);
                   if(visited[kangtuozhankai(dang)]==0)
                     push(dang,5,s+1);
                   swap(dang[8],dang[5]);
                   break;
        }
    }
    return 0;
}
```
最后祝大家身体健康，蒙的全对


---

## 作者：Kelin (赞：1)

双向广搜模板题50ms

不会康托展开就默默的用map或者hash吧

            
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<map>
#define mp make_pair
using namespace std;
int d[]={-3,-1,1,3};
string A,B("123804765");
inline bool judge(int nx,int ls)
{
    if(nx<0||nx>8)return 0;
    int d=nx-ls;
    if(d==-1&&(ls==3||ls==6))return 0;
    if(d==1&&(ls==2||ls==5))return 0;
    return 1;
}
int bfs()
{
    queue<pair<string,int> >q1;map<string,int>m1;
    queue<pair<string,int> >q2;map<string,int>m2;
    q1.push(mp(A,A.find("0")));q2.push(mp(B,B.find("0")));
    m1[A]=1,m2[B]=1;
    while(!q1.empty()&&!q2.empty())
    {
        pair<string,int>head=q1.front();q1.pop();
        pair<string,int>tail=q2.front();q2.pop();
        string now=head.first,next;
        if(m2[now])return m1[now]+m2[now]-2;
        for(int i=0;i<4;i++){
            int change=head.second+d[i];
            if(judge(change,head.second)){
                next=now;
                next[head.second]=now[change];
                next[change]='0';
                if(!m1[next])q1.push(mp(next,change)),m1[next]=m1[now]+1;
            }
        }
        now=tail.first;
        if(m1[now])return m1[now]+m2[now]-2;
        for(int i=0;i<4;i++){
            int change=tail.second+d[i];
            if(judge(change,tail.second)){
                next=now;
                next[tail.second]=now[change];
                next[change]='0';
                if(!m2[next])q2.push(mp(next,change)),m2[next]=m2[now]+1;
            }
        }
    }
    return 0;
}
int main()
{
    cin>>A;
    printf("%d",bfs());
return 0;
}
```

---

## 作者：magolor (赞：1)

使用map广搜压位和神奇的10进制位运算来缩短代码长度和提高代码可读性

思路同上，实现方式更便于理解：不用康托展开，不用字符串，附有注释图示









        

```cpp
#include <iostream>
#include <cstdio> 
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
#include <cmath>
using namespace std;
#define ll long long
#define BASIC 123456780
#define GOAL1 123456780
#define pli pair<ll,int>
#define x first
#define y second
// 8 7 6            1 2 3            1 2 3            1 2 3
// 5 4 3            4 5 6            4 5 0            4 0 5
// 2 1 0            7 8 0            7 8 6            7 8 6
// 876543210        BASIC            GOAL1            GOAL2
map <ll,int> f; 
pli q[1000000];
ll F(ll S, ll p, int direct)
{
    int b, c = log10(p)+.1;
    switch(direct)
    {
        case 0://left
        {
            if(!(-~c%3))
                return -1;
            else
            {
                b = S/(p*10) % 10;
                return S-b*p*9;
            }
        }
        case 1://up
        {
            if(c > 5)
                return -1;
            else
            {
                b = S/(p*1000) % 10;
                return S-b*p*999;
            }
        }
        case 2://right
        {
            if(!(c%3))
                return -1;
            else
            {
                b = (S*10)/p % 10;
                return S+b*p*9/10;
            }
        }
        case 3://down
        {
            if(c < 3)
                return -1;
            else
            {
                b = (S*1000)/p % 10;
                return S+b*p*999/1000;
            }
        }
    }
    return -1;
}
void Robot(ll S)
{
    int head = 0, tail = 1;
    f[S] = 1;
    q[0] = pli(S,1);
    ll p; 
    while(head < tail)
    { 
        pli t = q[head++];
        for(p = 1; p <= 100000000; p *= 10)
            if(!(t.x/p % 10))
                break;    
        for(int i = 0, N; i < 4; i++)
            if((N = F(t.x,p,i))+1 && !f[N])
                f[N] = t.y+1, q[tail++] = pli(N,f[N]);
    } 
    return;
}
int main()
{
    ll a;
    cin >> a;
    Robot(a);
    cout << f[123804765]-1 << endl;
    return 0;
}
```

---

## 作者：passerbyYSQ (赞：1)

## 前言
下面我只会说算法思路，具体的代码细节我就不赘述了，我贴出AC代码，希望能给各位一点帮助！由于我在不同oj上提交，代码会有些改动，我不知道会不会搞混了。如有错误，请各位指正。
为确保题解不要太长，代码我就不在这里贴。需要参考代码烦请移步：https://blog.csdn.net/qq_43290318/article/details/102764787
（~~打广告~~）

良心题解，能过么..QAQ.。求过么么哒

## 版本1
#### 单向bfs + stl set容器判重

（洛谷）总用时：7.53s

但过不了蓝桥杯那题，那题的数据点比洛谷强。。。

## 版本2
#### 单向bfs + 字典树判重 

将判重和插入分开：（洛谷）总用时：3.38s

在判重的同时实现插入：（洛谷）总用时：2.59s 

《算法竞赛入门经典》里面是以整数形式存储每种状态，我以字符串形式存储，感觉操作方便一点

手写字典树，如非必要，不要装×。在确保了我的bfs主算法正确后，我才试着手写字典树的，虽然心里还是有点虚。但很庆幸，调了2次就过了。之前师兄曾给我们展示过一个用数组实现字典树的模板，但由于这学期学数据结构，老师介绍了树的左兄弟右孩子表示法，于是我就试着用链表实现字典树。 

## 版本3
#### 单向bfs + 手写哈希表判重

（洛谷）总用时：2.67s

在判重的同时进行插入，队列我用数组模拟，但效率没有明显提高，建议都用stl提供的队列。

额，是不是觉得我很无聊。又手写哈希表。。。这学期学Java，了解了HashSet的底层实现，于是就自己模仿Java的实现原理尝试用C++写个简单的哈希表。其实这也不是我第一次手写哈希表，23333。。。

在3个oj上实测，效率一般来说比字典树高，但不太稳定。哈希表的效率主要取决于哈希函数的优略和哈希表的大小。我用的这个字符串的哈希函数是从网上找的，别人测试过的。另外哈希表的大小1000003，最好不要动它，我试过我一旦动了它，用时就边长了。至少，假如你用这个哈希函数，这个哈希表的大小就建议用1000003！针对其他哈希函数我不知道。

## 版本4
#### 双向bfs + map标记

（洛谷）总用时：351ms

大一参加蓝桥杯省赛之前，师兄曾开过一场培训，那时师兄就介绍过双向bfs，当时也讲了哈希表。。但当时听个懵懵懂懂。双向bfs，就是从起点和从终点“同时”bfs，这个同时并不是真的同时，只是两棵bfs树交替向外扩展，相当于你扩展一层后，然后轮到我扩展一层。当两棵bfs树相遇，最短路为相遇的两个状态的步数之和+1。开一个队列也可以实现！

如何判断两棵bfs树相遇呢？这个标记就很巧妙了。。这个标记我是借鉴了其它题解的。

看的出来，综合考虑，在赛场上这是首选！代码简短，效率还高。

## 版本5
#### 双向bfs优化 + map判重

（洛谷）总用时：358ms

每次出队，元素少的那个队列的对头元素出队！ 所有只能开两个队列了。

详情见大神博客：https://blog.csdn.net/ww32zz/article/details/50755225

好像用时没有减少。。但我在蓝桥杯题库和学校oj上提交，用时少了一点点。原因我盲猜一下，造成两个队列里面元素个数不相等的原因，就是其中一个bfs在扩展状态结点时碰到边界了。所以这个优化是否明显还要却决于两个bfs的起点的位置。蓝桥杯那题的终点状态不是固定的，可能这个优化对于蓝桥杯那题会比较明显吧。。快了十几ms。。如果我没记错。。当然，上述纯是我盲猜。。。也有可能我代码写错了，所以不明显。。

## 版本6  终极版本
#### 双向bfs优化 +  字典树判重

（洛谷）总用时：178ms

由于在使用双向bfs时要进行特殊标记，所以字典树要进行改动！具体实现我就不赘述了，参见代码。

在学校oj测试，最高用时：16ms

在蓝桥杯题库，最高用时：23ms


---

## 作者：跪下叫哥 (赞：1)

# 八数码难题题解
这题很明显是要用BFS，但是我有三种解决办法：
## 解决思路1

我们BFS的方法:每操作一次后形成一个新的棋盘状态,如果这个**状态**是没有遇见过的,就加入队列,如果遇见过,就丢弃,如果这个新状态是目标状态,就输出是第几步操作.当然我们要解决下面几个问题.

### 如何存状态

最简单的想法,因为最大的状态可以用数字`876543210`来表示,所以我们开一个数组`bool vis[876543210+1]`来表示某个状态是不是已经访问过了,算一下内存占用:876543211个byte就是`876543211 / 1024 /1024 = 835.9367475509644 mb`,明显超过了题目要求的`128mb`

也可以用`bool vis[9][9][9][9][9][9][9][9][9]`9维数组来表示,那共占用内存$$ 9 ^ 9 = 387420489$$byte.也就是`387420489 /1024/1024 = 369.4729700088501mb`,比上面好多了,但也超过了`128mb`.

仔细想一想我们可以用**8维数组**来存状态,只存前面的8个数值，因为最后一个数值可以推导出来，这样就不会超内存了。

### 如何操作

我用一个8位数来表示状态,可以用`state2map`函数把数字转成二维数组,然后用`find0`函数来找到0在二维数组中的位置,然后把0和上下左右的四个位置的交换一下,得到一个新的二维数组,再把这个数组用`map2state`函数转化成数字就ok了


### **代码**

修改成8给数组，todo！！！
```c
#include <cstdio>
#include <cstring>


//bool vis[876543210+1]; //876543211 byte 876543211 /1024 kb/1024mb = 835mb 根本存不下这么多的状态


//使用9维数组来存
bool vis[9][9][9][9][9][9][9][9][9] = {0}; //9*9 = 81 个byte
int fx[4][2] ={ {1,0}, {0,1}, {-1,0}, {0,-1} };

void state2map(int map[4][4],int state){
    int i;
    for(i=8;i>=0;i--){
        int t= state % 10;
        state /= 10;
        map[i/3+1][i % 3+1] = t; // 8/3+1 =3 8%3+1 = 3 
                                 // 0/3+1 =1 0%3+1 = 1
    }
}

int map2state(int map[4][4]){
    int r = 0;
    int i;
    for(i=8;i>=0;i--){
        r = r*10+map[i/3+1][i % 3+1];
    }
    return r;
}

// 找到0的位置
void find0(int map[4][4],int &x,int &y){
    int i,j;
    for(i=1;i<=3;i++)
        for(j=1;j<=3;j++){
            if( map[i][j] == 0){
                x = i,y = j;
                return ;
            }
        }
}

//--------- 设定某个状态已经访问的操作
void setVis(int state){
    int t1  = state % 10;  state /= 10;
    int t2  = state % 10;  state /= 10;
    int t3  = state % 10;  state /= 10;
    int t4  = state % 10;  state /= 10;
    int t5  = state % 10;  state /= 10;
    int t6  = state % 10;  state /= 10;
    int t7  = state % 10;  state /= 10;
    int t8  = state % 10;  state /= 10;
    int t9  = state % 10;  state /= 10;
    vis[t9][t8][t7][t6][t5][t4][t3][t2][t1] = 1;
}

// 返回0 表示没有访问过
bool isVis(int state){
    int t1  = state % 10;  state /= 10;
    int t2  = state % 10;  state /= 10;
    int t3  = state % 10;  state /= 10;
    int t4  = state % 10;  state /= 10;
    int t5  = state % 10;  state /= 10;
    int t6  = state % 10;  state /= 10;
    int t7  = state % 10;  state /= 10;
    int t8  = state % 10;  state /= 10;
    int t9  = state % 10;  state /= 10;
    return vis[t9][t8][t7][t6][t5][t4][t3][t2][t1];
}

//--------- 设定某个状态已经访问的操作 -- end


struct _node {
    int state;
    int step;
};


//-------------- 队列操作
#define qsize 1000000
_node queue[qsize]; //因为不知道最大步数,使用循环队列
int idx=0;
int head=0,tail =0;

void push(_node t){
    queue[tail]= t;
    tail = (tail+1) % qsize; //tail 最大 qsize-1
}

void pop(){ head = (head+1) % qsize; }
_node front(){ return queue[head];}
bool empty(){ return head == tail;}
//-------------- 队列操作 --- end

bool inmap(int x,int y){
    if(x >=1 && x <=3 && y>=1 && y<=3)
        return true;
    return false;
}
//进行四种操作 state 数字表示的状态,op 表示那个操作,0,1,2,3
int opt(int state,int op){
    int t_map[4][4];
    state2map(t_map,state); //转化二维
    int x,y;
    find0(t_map,x,y); //找到0的位置

    int nx = x + fx[op][0];
    int ny = y + fx[op][1]; //nx,ny 要交换的数字的位置
    if (inmap(nx,ny)){
        int t = t_map[x][y];
        t_map[x][y] = t_map[nx][ny];
        t_map[nx][ny] = t; //交换
        return map2state(t_map); //返回转换的数字
    }
    else 
        return -1; //表示不可以
}

int bfs(int state){
    _node first ;
    first.state = state;
    first.step = 0;
    push(first); //加入起点
    setVis(state); //设定已经访问

    while( !empty()){ //非空
        _node t = front(); pop(); //取出头

        int i;
        int state = t.state;
        int step = t.step;
        for(i=0;i<4;i++){
            int tn = opt(state,i);
            if( tn != -1){ // 返回一个正常的操作后的状态
                if( tn == 123804765) //找到结果
                    return step+1;
                if ( isVis(tn) == 0){ //没有被vis过
                    _node tnode;
                    tnode.state = tn;
                    tnode.step = step+1;
                    push(tnode);
                    setVis(tn); //设为已经访问过
                }
            }
        }
    }
    return -1; //表示无解
}


int main(){
    int s;
    scanf("%d",&s);
    int ans = bfs(s);
    printf("%d",ans);
    return 0;
}
```

## 解决思路2:康托展开

9维数组的vis会超内存,那应该怎么办呢?

仔细想一个,状态是9个数字的组合,一共有$$ 9! = 362880$$  种排列方案,也就是说一共有362880种状态,如果状态从0开始对应一个数字,那开一个`bool vis[362880]`就可以把所有的状态存一来.这种操作就是康托展开。

```c
#include <cstdio>
#include <cstring>

char str[100];
char dest[10] = { '1', '2', '3', '8', '0', '4', '7', '6', '5','\0'};
int dest_num;
char lx[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8'};
bool isExit[10];

bool vis[400000] = {0};

int fx[4][2] ={ {1,0}, {0,1}, {-1,0}, {0,-1} };
int fac[10];


// 找到0的位置
void find0(char map[4][4],int &x,int &y){
    int i,j;
    for(i=1;i<=3;i++)
        for(j=1;j<=3;j++){
            if( map[i][j] == '0'){
                x = i,y = j;
                return ;
            }
        }
}

int encoding(char str[],int len){
    int num =0,i,j;
    for(i=0;i<len;i++){
        int tmp = 0;
        for(j=i+1;j<len;j++)   //从后面一个数开始,计算有几个数
            if(str[j] < str[i])//比str[i]小,如果有0个比str[i]
                tmp++;         //str[i]就是第0小
        num += tmp*fac[len-i-1];
    }
    return num;
}

//逆展开
void decoding(int num,int len,char str[]){
    memset(isExit,0,sizeof(isExit));
    int i,j,cnt;
    for(i=0;i<len;i++){
        int y = num / fac[len-i-1];//需要找第y小的数
        num = num % fac[len-i-1];

        //从存在的数里找到
        cnt = -1; //找到一个数后,cnt++ == 0 表示第0小
        for(j=0;j<len;j++){
            if(isExit[j] == 0) { //存在
                cnt++;
                if(cnt == y) //
                    break;
            }
        }
        isExit[j] = 1;
        str[i] = lx[j];
    }
}



struct _node {
    int state; //存的康托展开后的数字
    int step;
};


//-------------- 队列操作
#define qsize 1000000
_node queue[qsize]; //因为不知道最大步数,使用循环队列
int idx=0;
int head=0,tail =0;

void push(_node t){
    queue[tail]= t;
    tail = (tail+1) % qsize; //tail 最大 qsize-1
}

void pop(){ head = (head+1) % qsize; }
_node front(){ return queue[head];}
bool empty(){ return head == tail;}
//-------------- 队列操作 --- end

bool inmap(int x,int y){
    if(x >=1 && x <=3 && y>=1 && y<=3)
        return true;
    return false;
}
//进行四种操作 state 数字表示的状态,op 表示那个操作,0,1,2,3
int opt(char s[],int op){
    char st[4][4];
    char sst[9];
    int i,j;
    for(i=1;i<=3;i++)
     for(j=1;j<=3;j++)
         st[i][j] = s[(i-1)*3+(j-1)];
    int x,y;
    find0(st,x,y);
    
    int nx = x +fx[op][0];
    int ny = y +fx[op][1];

    if( inmap(nx,ny)){
        char t = st[nx][ny];
        st[nx][ny] = st[x][y];
        st[x][y] = t;
        for(i=1;i<=3;i++)
            for(j=1;j<=3;j++)
                sst[(i-1)*3+(j-1)] =  st[i][j];
        return encoding(sst,9);
    }
    return -1;
}



int bfs(){
    _node first ;

    first.state = encoding(str,9);
    first.step = 0;
    push(first); //加入起点
    vis[first.state]  =1;

    while( !empty()){ //非空
        _node t = front(); pop(); //取出头

        int i;
        int state = t.state;
        int step = t.step;
        char tmp[10];
        decoding(state,9,tmp);
        for(i=0;i<4;i++){
            int tn = opt(tmp,i);
            if( tn != -1){ // 返回一个正常的操作后的状态
                if( tn == dest_num) //找到结果
                    return step+1;
                if ( vis[tn] == 0){ //没有被vis过
                    _node tnode;
                    tnode.state = tn;
                    tnode.step = step+1;
                    push(tnode);
                    vis[tn] = 1;
                }
            }
        }
    }
    return -1; //表示无解
}


int main(){
    fac[0] = 1;
    int i;
    for(i=1;i<=9;i++) fac[i] =  fac[i-1]*i;
    scanf("%s",str);
    if(strcmp(str,dest)==0){
        printf("0");
        return 0;
    }
    dest_num = encoding(dest,9);
    int ans = bfs();

    printf("%d",ans);
    return 0;
}
```

## 解决思路3:STL

既然状态只有 362880种,难点只是在于怎么标记一个状态,如果这里用STL,我们完全可以用`map`,或者`set`很轻松的写出来.


---

## 作者：Mr_Wu (赞：1)

八数码难题，很显然~~看算法标签~~就知道这是一道Bfs题，因为Bfs的特点就是：适合于找最优解。如果用Dfs，那么需要枚举所有情况，取最优解，而Bfs只要找到一个满足条件的就能确定它是最优解

----

#### 这题解法很多，在这篇题解里我阐述三种解法
1. Set
2. Hash
3. 康拓展开

~~至于双向宽搜可以去看别的题解我不会~~

~~九进制太麻烦我没写~~

~~启发式搜索你看我颓废的模样就知道我不会了~~

-----

#### Bfs一般写法

Code(伪代码):

```cpp
struct state //状态
{
	
}now, next;

queue<state> Q; //Bfs中，你需要一个队列
Q.push(first) //基础状态
while (!Q.empty()) //枚举所有方案
{
	now = Q.top();
    if (now 满足条件)
    {
    	//输出答案或者其他
    }
    Q.pop();
    if (now 与之前的答案重复)
    {
    	continue; 或者其它
    }
    for (next 符合下一步条件)
    {
    	Q.push(next);
    }
}
//如果所有可行状态全部枚举完毕却没有找到最优解，那么
//没有满足条件的结果
```
------

1. 如果你直接使用一个$vis$数组来判重，那么你的$vis$数组大小要$>=876543210$，很显然``MLE``。所以我们需要更高效的判重方式。

2. 你表示每个状态可以用$a[3][3]$或$a[9]$，如果你用前者二维数组，在判重方面可能都比较麻烦，所以我的代码都采取了$a[9]$这样的形式。

------

- Set

STLSet思路很好想，在每次访问后都将当前状态放进Set，这样每次放入和判重都是$O(logn)$的

> Tips: 
- set.insert(x) 将x放进set
- set.count(x) 询问x是否在set里，返回$0/1$
- set.empty() set是否为空

[$Luogu$评测：$5728ms / 11339KB$](https://www.luogu.org/recordnew/show/6894610)

Code:
```cpp
#include <cstdio>
#include <queue>
#include <set>
using namespace std;

struct state
{
	int a[10], s;
}now; //用结构体state存储每一个状态

queue<state> Q; //一只STL队列（我懒qwq）
set<int> S;  //一只STLset
int aim[10] = {0, 1, 2, 3, 8, 0, 4, 7, 6, 5}; //最后的目标

int main()
{
	int i;
	for (i = 1; i <= 9; i++) now.a[i] = getchar() - '0'; //输入
	now.s = 0;
	Q.push(now);  //初始状态，即输入数据
	while (!Q.empty()) //不停枚举，直到所有符合条件的状态枚举完毕
	{
		for (i = 1; i <= 9; i++) now.a[i] = Q.front().a[i];
		now.s = Q.front().s;
		Q.pop(); //这一次要处理的状态
		
        //一段简单的判断是否成功的代码
		bool flag = true;
		for (i = 1; i <= 9; i++) if (now.a[i] != aim[i]) flag = false;
		if (flag)
		{
			printf("%d", now.s);
			return 0;
		} 
        //一段简单的判断是否成功的代码
		
        //判重
		int id = 0;
		for (i = 1; i <= 9; i++) id = id * 10 + now.a[i];
		if (!S.empty() && S.count(id)) continue; //S.empty()是为了保险，如果S.empty()为false，那么不会调用S.count()函数询问
		else S.insert(id); 
        //判重
		
		for (i = 1; i <= 9; i++) if (!now.a[i]) break;
		int ni = i; //找到0项
		
        //下一个状态的转移
		now.s++;
		if ((ni - 1) / 3 != 0) //这些转换可以用纸模拟一下，看看和二维数组是否等效
		{
			swap(now.a[ni], now.a[ni - 3]);
			Q.push(now);
			swap(now.a[ni], now.a[ni - 3]);
		}
		if ((ni - 1) / 3 != 2)
		{
			swap(now.a[ni], now.a[ni + 3]);
			Q.push(now);
			swap(now.a[ni], now.a[ni + 3]);
		}
		if (ni % 3 != 1)
		{
			swap(now.a[ni], now.a[ni - 1]);
			Q.push(now);
			swap(now.a[ni], now.a[ni - 1]);
		}
		if (ni % 3 != 0)
		{
			swap(now.a[ni], now.a[ni + 1]);
			Q.push(now);
			swap(now.a[ni], now.a[ni + 1]);
		}
        //下一个状态的转移
	}
	printf("-1"); //不能到达目标状态，尽管题目没有要求
	return 0;
} 
```

------

- Hash

很显然$Map$时间很慢~~也可能是我常数太大~~，所以我们需要更高效的判重条件

我们使用Hash降低空间复杂度。

**Hash是什么？**

你可以将一个大字符串看成一个$T$进制位的整数，而每个字母都有它对应的值。

习惯上，我们直接使用每个字母的ASCII作为它代表的值。

当然，现在我们的Hash要处理的是一个大整数，所以每一位数是什么值就把他当什么值。

计算的时候，你的结果需要%一个$MOD$。

这样，$vis$数组大小就能从$876543210$降到$2000000$甚至更少~~再少下去就有点危险了~~

注意：$vis[hash(x)]=true$代表这个数很大概率出现过，$vis[hash(x)]=false$代表这个数一定没出现过，所以我们可以采用双$Hash$保险。

两个$Hash$分别用不同的$T$和$MOD$，存在$vis[]$和$vis2[]$里，如果$vis[hash(x)]=true$ && $vis2[hash2(x)]=true$，那这个数一定出现过了（当然，如果你$rp$不好，仍然可能出现矛盾）

>P.S. Hash太玄学，正式考试万不得已尽量不要用
1. [61分](https://www.luogu.org/recordnew/show/6895184)
2. [76分](https://www.luogu.org/record/show?rid=6895212)
3. [97分](https://www.luogu.org/record/show?rid=6895271)
4. [100分](https://www.luogu.org/record/show?rid=6895271)

$2832ms / 5460KB$ 比 $Set$ 好多啦

Code:
```cpp
#include <cstdio>
#include <queue>
using namespace std;

struct state
{
	int a[10], s;
}now; //用结构体state存储每一个状态

queue<state> Q; //一只STL队列（我懒qwq）
bool vis[2000000], vis2[2000000];
const int MOD1 = 1163729, T1 = 1123121, MOD2 = 1122677, T2 = 122077; //规定双hash的MOD和T 
int aim[10] = {0, 1, 2, 3, 8, 0, 4, 7, 6, 5}; //最后的目标

int hash(int a[], const int MOD, const int T)
{
	int ret = 0, i;
	for (i = 1; i <= 9; i++) ret = ((ret * T + MOD) % MOD + a[i] + MOD) % MOD;
	return ret;
} //Hash函数 

int main()
{
	int i;
	for (i = 1; i <= 9; i++) now.a[i] = getchar() - '0'; //输入
	now.s = 0;
	Q.push(now);  //初始状态，即输入数据
	while (!Q.empty()) //不停枚举，直到所有符合条件的状态枚举完毕
	{
		for (i = 1; i <= 9; i++) now.a[i] = Q.front().a[i];
		now.s = Q.front().s;
		Q.pop(); //这一次要处理的状态
		
        //一段简单的判断是否成功的代码
		bool flag = true;
		for (i = 1; i <= 9; i++) if (now.a[i] != aim[i]) flag = false;
		if (flag)
		{
			printf("%d", now.s);
			return 0;
		} 
        //一段简单的判断是否成功的代码
		
		//Hash版判重 
		int hash1 = hash(now.a, MOD1, T1), hash2 = hash(now.a, MOD2, T2);
        if (vis[hash1] && vis[hash2]) continue;
        vis[hash1] = vis[hash2] = true;
        //Hash版判重 
		
		for (i = 1; i <= 9; i++) if (!now.a[i]) break;
		int ni = i; //找到0项
		
        //下一个状态的转移
		now.s++;
		if ((ni - 1) / 3 != 0) //这些转换可以用纸模拟一下，看看和二维数组是否等效
		{
			swap(now.a[ni], now.a[ni - 3]);
			Q.push(now);
			swap(now.a[ni], now.a[ni - 3]);
		}
		if ((ni - 1) / 3 != 2)
		{
			swap(now.a[ni], now.a[ni + 3]);
			Q.push(now);
			swap(now.a[ni], now.a[ni + 3]);
		}
		if (ni % 3 != 1)
		{
			swap(now.a[ni], now.a[ni - 1]);
			Q.push(now);
			swap(now.a[ni], now.a[ni - 1]);
		}
		if (ni % 3 != 0)
		{
			swap(now.a[ni], now.a[ni + 1]);
			Q.push(now);
			swap(now.a[ni], now.a[ni + 1]);
		}
        //下一个状态的转移
	}
	printf("-1"); //不能到达目标状态，尽管题目没有要求
	return 0;
} 
```

----

- 康拓展开

想想，我们的朴素$vis$数组为什么会开到$876543210$？

很显然，这个$vis$数组造成了太大的空间浪费。

比如$100000000$，$123456789$这些状态是根本不可能出现的。

试想，我们的八数码最多有多少种？

$9! = 362880$.

显然$876543210$太浪费了。

如果我们能把每种全排列都编个号，这样$vis$数组就只用开到$362880$就够啦！

那，怎么做呢？

>康拓展开：对于每一个$n$位的全排列$a[n]$，对于每一个$a[i]$，设$X[n-i+1]$为$a[i]$右边严格小于$a[i]$的数字个数，并将这个数字乘上$(n-1)!$。

>那么这个全排列就是所有全排列中的第$X[1]+X[2]+...+X[n]+1$个。

**康拓展开实现如下：**
```cpp
int Cantor(int l, int a[]) //l是排列长度，a[]是排列数组
{
	int i, j, x[MAXN], ret = 0;
	for (i = 1; i <= l; i++) x[i] = 0;
	for (i = 1; i <= l; i++) for (j = i + 1; j <= l; j++) if (a[j] < a[i]) x[l - i + 1]++; 
	for (i = 1; i <= l; i++) ret += x[i] * jc[i - 1];
	return ret + 1;
}
```

Code:

[$Luogu$评测：$2720ms / 4742KB$](https://www.luogu.org/recordnew/show/6895835)

```cpp
#include <cstdio>
#include <queue>
using namespace std;

struct state
{
	int a[10], s;
}now; //用结构体state存储每一个状态

queue<state> Q; //一只STL队列（我懒qwq）
bool vis[362881];
int aim[10] = {0, 1, 2, 3, 8, 0, 4, 7, 6, 5}; //最后的目标
const int jc[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};

int Cantor(int l, int a[])
{
	int i, j, x[10], ret = 0;
	for (i = 1; i <= l; i++) x[i] = 0;
	for (i = 1; i <= l; i++) for (j = i + 1; j <= l; j++) if (a[j] < a[i]) x[l - i + 1]++; 
	for (i = 1; i <= l; i++) ret += x[i] * jc[i - 1];
	return ret + 1;
}

int main()
{
	int i;
	for (i = 1; i <= 9; i++) now.a[i] = getchar() - '0'; //输入
	now.s = 0;
	Q.push(now);  //初始状态，即输入数据
	while (!Q.empty()) //不停枚举，直到所有符合条件的状态枚举完毕
	{
		for (i = 1; i <= 9; i++) now.a[i] = Q.front().a[i];
		now.s = Q.front().s;
		Q.pop(); //这一次要处理的状态
		
        //一段简单的判断是否成功的代码
		bool flag = true;
		for (i = 1; i <= 9; i++) if (now.a[i] != aim[i]) flag = false;
		if (flag)
		{
			printf("%d", now.s);
			return 0;
		} 
        //一段简单的判断是否成功的代码
		
		//康托展开版判重 
		int cantor = Cantor(9, now.a);
		if (vis[cantor]) continue;
		vis[cantor] = true;
		//康托展开版判重 
		
		for (i = 1; i <= 9; i++) if (!now.a[i]) break;
		int ni = i; //找到0项
		
        //下一个状态的转移
		now.s++;
		if ((ni - 1) / 3 != 0) //这些转换可以用纸模拟一下，看看和二维数组是否等效
		{
			swap(now.a[ni], now.a[ni - 3]);
			Q.push(now);
			swap(now.a[ni], now.a[ni - 3]);
		}
		if ((ni - 1) / 3 != 2)
		{
			swap(now.a[ni], now.a[ni + 3]);
			Q.push(now);
			swap(now.a[ni], now.a[ni + 3]);
		}
		if (ni % 3 != 1)
		{
			swap(now.a[ni], now.a[ni - 1]);
			Q.push(now);
			swap(now.a[ni], now.a[ni - 1]);
		}
		if (ni % 3 != 0)
		{
			swap(now.a[ni], now.a[ni + 1]);
			Q.push(now);
			swap(now.a[ni], now.a[ni + 1]);
		}
        //下一个状态的转移
	}
	printf("-1"); //不能到达目标状态，尽管题目没有要求
	return 0;
} 
```

---------

That's All.

---

## 作者：封禁用户 (赞：1)

首先此题的难点是唯一确定这九个数码，因此我用了种类似康托展开的编码，即对应位置上的数的平方乘上该位的阶乘，再把所有位上的这些结果加起来。（我开始的时候没有平方，然后就WA了一个点，至今不知道为什么），例如，283104765的编码就是：2×2×9！+8×8×8！+3×3×7！+1×1×6！+0×0×5！+4×4×4！+7×7×3！+6×6×2！+5×5×1！，然后就可以唯一的确定这堆数。但是在bfs中我们怎么表示这9个数呢（当然不可以用编码！我们还要在位置上找数），我用位运算解决了这个问题：因为（9）10=（1001）2，而且4×9=36，所以我开了一个unsigned long long，让每个数分别占其中的4个二进制位，这样就不用开个数组存了，非常的省事。至于数的移动问题，我为了省事而打了个表，指明了这个位置的数可以往那移。然后就无脑bfs吧！

代码如下：

```cpp
    #include<cstdio>
    #include<queue>
    #include<cstring>
    using namespace std;
    unsigned char bs[40000000];//根据编码记录这个九数码是否已经搜过
    queue<unsigned long long> que;
    queue<int> steps;
    char str[10]="123804765";
    int facts[10]={1,1,2,6,24,120,720,5040,40320,362880};//阶乘表
    inline unsigned long long castdata(){//把字符串str的内容转换为按位存储的九数码
        unsigned long long tmp=0;
        for(int i=0;i<9;i++){
            tmp=tmp|(((unsigned long long)str[i]-'0')<<(32-4*i));
        }
        return(tmp);
    }
    inline int encode(unsigned long long data){//编码函数，把按位存储的九数码编码
        int tmp=0;
        unsigned long long yinzi=15;
        int cx=0;
        for(int i=1;i<=9;i++){
            int num=(data&yinzi)>>cx;
            tmp+=(num*num*facts[i]);
            yinzi=yinzi<<4;
            cx+=4;
        }
        return(tmp);
    }
    inline int findzero(unsigned long long data){//找九数码中0的位置
        unsigned long long yinzi=15;
        for(int i=8;i>=0;i--){
            if((data&yinzi)==0)return(i);
            yinzi=yinzi<<4;
        }
    }
    inline int getnum(unsigned long long data,int index){//获取按位存储的九数码中对应位置的数
        unsigned long long yinzi=15;
        int bits=32-index*4;
        return((data&(yinzi<<bits))>>bits);
    }
    inline unsigned long long setnum(unsigned long long data,int index,int num){//把数放到九数码中的对应位置
        unsigned long long yinzi=15;
        int bits=32-index*4;
        return((data&(~(yinzi<<bits)))|(((unsigned long long)num)<<bits));
    }
    int tables[10][6]={
        {2,1,3},
        {3,0,2,4},
        {2,1,5},
        {3,0,4,6},
        {4,1,3,5,7},
        {3,2,4,8},
        {2,3,7},
        {3,4,6,8},
        {2,5,7}
    };//数码移动表，第一个元素是可移动的数目，下面的则是可以移动到的目标位置
    int main(){
        unsigned long long dest=castdata();//先把123804765按位存储
        scanf("%s",str);
        unsigned long long source=castdata();//把起点数码按位存储
        if(source==dest){
            printf("%d\n",0);//起点是123804765就直接输出0
            return(0);
        }
        que.push(source);
        steps.push(0);
        bs[encode(source)]=1;
        while(1){
            unsigned long long head=que.front();
            int headstep=steps.front();
            que.pop();
            steps.pop();
            int zeroindex=findzero(head);
            int loop=tables[zeroindex][0];
            for(int i=1;i<=loop;i++){
                unsigned long long tmph=head;
                int dst=tables[zeroindex][i];
                int num=getnum(head,dst);
                tmph=setnum(tmph,dst,0);
                tmph=setnum(tmph,zeroindex,num); //交换0和旁边的数
                int encoding=encode(tmph);
                if(!bs[encoding]){//这个编码没有被记录过，就入队
                    bs[encoding]=1;
                    if(tmph==dest){//找到终点123804765，完成！
                        printf("%d\n",headstep+1);
                        return(0);
                    }
                    else{
                        que.push(tmph);
                        steps.push(headstep+1);
                    }
                }
            }
        }
        return(0);
}
```

---

## 作者：QwQ2000 (赞：1)

其实可以用一个看起来很不靠谱的估价函数 A\*水过这道题 代码非常简单

比较当前状态与目标状态 如果有cnt个位置上的数字不一样

当前步数+cnt如果超过了迭代加深的时候定的步数就直接返回

好险 最后一个点差点就T了hhhh

[codec]



                   


    

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int T[3][3]={{1,2,3},
                   {8,0,4},
                   {7,6,5}};
const int DX[]={1,-1,0,0},DY[]={0,0,-1,1};
int s[3][3],k=0,flag=0;
int end() {
    for (int i=0;i<3;++i)
        for (int j=0;j<3;++j)
            if (s[i][j]!=T[i][j])
                return 0;
    return 1;    
}
int judge(int step) {
    int cnt=0;
    for (int i=0;i<3;++i)
        for (int j=0;j<3;++j)
            if (s[i][j]!=T[i][j]) {
                ++cnt;
                if (cnt+step>k)
                    return 0;
            }
    return 1;
}
#define X x+DX[i]
#define Y y+DY[i]
void dfs(int step) {
    if (step>k || flag)
        return;
    if (end()) {
        flag=1;
        return;
    }
    int x=0,y=0;
    for (int i=0;i<3;++i)
        for (int j=0;j<3;++j)
            if (!s[i][j]) {
                x=i;
                y=j;
                break;
            }
    for (int i=0;i<4;++i)
        if (X>=0 && Y>=0 && X<3 && Y<3) {
            swap(s[x][y],s[X][Y]);
            if (judge(step))
                dfs(step+1);
            swap(s[X][Y],s[x][y]);
        }
}
```
#undef X
#undef Y


```cpp
int main(void) {
    char s0[233];
    scanf("%s",s0);
    for (int i=0;i<9;++i) 
        s[i/3][i%3]=s0[i]-'0';
    while (!flag) {
        flag=0;
        ++k;
        dfs(0);
    }
    printf("%d\n",k);
    return 0;
} 
[/codec]
```

---

## 作者：Vin_1999 (赞：1)

既然提到了打表那我们就来愉快的打表吧~

因为终状态已定，所以我们从终状态开始往外搜便可以知道所有状态到终状态的距离。

好吧我知道双向宽搜，a\*什么的很牛b。反正状态总数不会超过9!那就打表喽。

事实上状态总数是181440=9！/2。我也不知道为什么。

但是我的代码在各个oj都提交不了（too long）qoq。

然后献上丑陋的代码。












```cpp
//打表机owo~ 
#include<bits/stdc++.h>
#define rep(i,s,n) for(int (i)=(s);(i)<=(n);(i)++)
using namespace std;
const int fac[10]={1,1,2,6,24,120,720,5040,40320,362880},maxn=1000000+7,
                    mx[4]={0,0,-1,1},my[4]={1,-1,0,0};
static int biao[maxn],vis[maxn];
int cantor(int x[3][3])
{
    int m[10];
  rep(i,0,2) rep(j,0,2) m[i*3+j+1]=x[i][j];
    int s=0;
    for(int i=1;i<=9;++i)
    {
        int temp=0;
        for(int j=i+1;j<=9;++j)
          if(m[j]<m[i]) ++temp;
          s+=fac[9-i]*temp;
    }
    return s;
}
struct node
{
    int x,y;
}sp[maxn];
static int l,r,q[maxn][3][3],dep[maxn];
const int fir[3][3]={1,2,3,8,0,4,7,6,5};
int main()
{
    freopen("e:/out.txt","w",stdout);
    int kt;
     memcpy(q[0],fir,sizeof(fir));r=1;
     sp[0].x=1;sp[0].y=1;kt=cantor(q[0]);biao[kt]=0;
     vis[kt]=1;
     while(l<r)
     {
         int u[3][3],v[3][3];node vsp,usp;
         memcpy(u,q[l],sizeof(u));usp=sp[l];
         rep(i,0,3)
         {
             memcpy(v,u,sizeof(u));vsp.x=usp.x+mx[i];vsp.y=usp.y+my[i];
             if(vsp.x<0||vsp.y<0||vsp.x>2||vsp.y>2) continue;
             swap(v[usp.x][usp.y],v[vsp.x][vsp.y]);
             kt=cantor(v);
             if(!vis[kt])
             {
                 vis[kt]=1;
                 memcpy(q[r],v,sizeof(v));
                 dep[r]=dep[l]+1;
                 biao[kt]=dep[r];
                 sp[r++]=vsp;
          }
      }
      ++l;
  }
  rep(i,0,fac[9]-1) printf("%d,",biao[i]);
  printf("%d",biao[fac[9]]);
  return 0;
}//by fjlyyz-ljy
```

---

## 作者：H15teve (赞：1)

我知道代码很长，但是各位忍一下，有注释，有大量重复可以跳过。

效率较高，102ms过。

基本思路：双向宽搜+Contor验重。

/\*
P1379
Au:H15teve

\*/



```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
int n0l=0,n0r=0,n1l=0,n1r=0;//在当前深度时队列的范围，比如time=3,对应的0队列左界n0l=7,右界n0r=11之类 
struct queue
{
    queue(): cont(-1) {}
    int a[3][3],cont,x,y,depth;
    bool flag;
}map[400000][2];//结构体当中存的是本Contor值所对应的排列（a)，0点位置（x,y），操作步数（depth），是否有点 （bool，实际上不必要，检查cont即可但是我懒得改了...） 
//cont存的是队列当中对应编号的Contor值，实际上是一个指针！ 因为是双向宽搜，所以map的第二个参数0指的是从输入状态出发，1指的是从123804765出发 
int contor(int m[3][3])
{
    int fac[9]={1,1,2,6,24,120,720,5040,40320},ans=0;
    for (int i=0;i<=8;i++)
    {
        int tmp=0;
        for (int j=i+1;j<=8;j++)
          if (m[i/3][i%3]>m[j/3][j%3]) tmp++;
        ans+=tmp*fac[8-i];
    }
    return ans;
```
}//计算Contor值

bool check(int hash,int mode)

{
    return map[hash][mode].flag?1:0;

}//验重


```cpp
void copy(int m[3][3],int mode,int contcode)
{
    for (int i=0;i<=2;i++)
      for (int j=0;j<=2;j++)
      {
            map[contcode][mode].a[i][j]=m[i][j];
            if (m[i][j]==0) map[contcode][mode].x=i,map[contcode][mode].y=j;
      }
    map[contcode][mode].flag=1;   
```
}//意义如其名

void godie(int depth1,int depth2)

{
    printf("%d",depth1+depth2);

}//输出


```cpp
int main()
{
    char start;
    int tmp[3][3],a,b,tmpcont;
    for (int i=0;i<=8;i++) 
    {
        scanf("%c",&start),tmp[i/3][i%3]=start-'0';
        if (start=='0') a=i/3,b=i%3;
    }
    tmpcont=contor(tmp),map[0][0].cont=tmpcont,map[tmpcont][0].flag=1,map[tmpcont][0].x=a,map[tmpcont][0].y=b;
    for (int i=0;i<=2;i++)
      for (int j=0;j<=2;j++)
        map[tmpcont][0].a[i][j]=tmp[i][j];
    map[46685][1].a[0][0]=1,map[46685][1].a[0][1]=2,map[46685][1].a[0][2]=3,
    map[46685][1].a[1][0]=8,map[46685][1].a[1][1]=0,map[46685][1].a[1][2]=4,
    map[46685][1].a[2][0]=7,map[46685][1].a[2][1]=6,map[46685][1].a[2][2]=5;
    map[0][1].cont=46685,map[46685][1].flag=1,map[46685][1].x=1,map[46685][1].y=1;
    if(check(tmpcont,1))
        {
            godie(0,map[46685][1].depth);
            return 0;
        }
    //初始化。123804765的Contor值是46685 
    int time=0;
    while (1)
    {
        int lf=n0l,rf=n0r,now=0;
        time++;//深度 
        for (int i=lf;i<=rf;i++)
        {
```
/\*
以下有八个if，分别对应的是双向宽搜上下左右共八种状态。

首先把当前状态装到temp中，然后对应的上下左右处理（swap），计算Contor值，验重（己方为重，对方为答案），无重复制丢进队列。

\*/
```cpp
            int temp[4][3][3];
            if(map[map[i][0].cont][0].x>0)
            {
                for(int j=0;j<=2;j++)
                  for (int k=0;k<=2;k++)
                    temp[0][j][k]=map[map[i][0].cont][0].a[j][k];
                swap(temp[0][map[map[i][0].cont][0].x-1][map[map[i][0].cont][0].y],temp[0][map[map[i][0].cont][0].x][map[map[i][0].cont][0].y]);
                tmpcont=contor(temp[0]);
                if(!check(tmpcont,0))
                {
                    if(check(tmpcont,1))
                    {
                        godie(time,map[tmpcont][1].depth);
                         return 0;
                    }
                    copy(temp[0],0,tmpcont);
                    map[tmpcont][0].depth=time,map[++now+rf][0].cont=tmpcont;
                }
            }
            if(map[map[i][0].cont][0].x<2)
            {
                for(int j=0;j<=2;j++)
                  for (int k=0;k<=2;k++)
                    temp[1][j][k]=map[map[i][0].cont][0].a[j][k];
                swap(temp[1][map[map[i][0].cont][0].x+1][map[map[i][0].cont][0].y],temp[1][map[map[i][0].cont][0].x][map[map[i][0].cont][0].y]);
                tmpcont=contor(temp[1]);
                if(!check(tmpcont,0))
                {
                    if(check(tmpcont,1))
                    {
                        godie(time,map[tmpcont][1].depth);
                        return 0;
                    }
                    copy(temp[1],0,tmpcont);
                    map[tmpcont][0].depth=time,map[++now+rf][0].cont=tmpcont;
                }
            }
            if(map[map[i][0].cont][0].y>0)
            {
                for(int j=0;j<=2;j++)
                  for (int k=0;k<=2;k++)
                    temp[2][j][k]=map[map[i][0].cont][0].a[j][k];
                swap(temp[2][map[map[i][0].cont][0].x][map[map[i][0].cont][0].y-1],temp[2][map[map[i][0].cont][0].x][map[map[i][0].cont][0].y]);
                tmpcont=contor(temp[2]);
                if(!check(tmpcont,0))
                {
                    if(check(tmpcont,1))
                    {
                        godie(time,map[tmpcont][1].depth);
                        return 0;
                    }
                    copy(temp[2],0,tmpcont);
                    map[tmpcont][0].depth=time,map[++now+rf][0].cont=tmpcont;
                }
            }
            if(map[map[i][0].cont][0].y<2)
            {
                for(int j=0;j<=2;j++)
                  for (int k=0;k<=2;k++)
                    temp[3][j][k]=map[map[i][0].cont][0].a[j][k];
                swap(temp[3][map[map[i][0].cont][0].x][map[map[i][0].cont][0].y+1],temp[3][map[map[i][0].cont][0].x][map[map[i][0].cont][0].y]);
                tmpcont=contor(temp[3]);
                if(!check(tmpcont,0))
                {
                    if(check(tmpcont,1))
                    {
                        godie(time,map[tmpcont][1].depth);
                        return 0;
                    }
                    copy(temp[3],0,tmpcont);
                    map[tmpcont][0].depth=time,map[++now+rf][0].cont=tmpcont;
                }
            }
        }
        n0l=n0r+1;n0r+=now;
        lf=n1l,rf=n1r,now=0;
        for (int i=lf;i<=rf;i++)
        {
            int temp[4][3][3];
            if(map[map[i][1].cont][1].x>0)
            {
                for(int j=0;j<=2;j++)
                  for (int k=0;k<=2;k++)
                    temp[0][j][k]=map[map[i][1].cont][1].a[j][k];
                swap(temp[0][map[map[i][1].cont][1].x-1][map[map[i][1].cont][1].y],temp[0][map[map[i][1].cont][1].x][map[map[i][1].cont][1].y]);
                tmpcont=contor(temp[0]);
                if(!check(tmpcont,1))
                {
                    if(check(tmpcont,0))
                    {
                        godie(time,map[tmpcont][0].depth);
                        return 0;
                    }
                    copy(temp[0],1,tmpcont);
                    map[tmpcont][1].depth=time,map[++now+rf][1].cont=tmpcont;
                }
            }
            if(map[map[i][1].cont][1].x<2)
            {
                for(int j=0;j<=2;j++)
                  for (int k=0;k<=2;k++)
                    temp[1][j][k]=map[map[i][1].cont][1].a[j][k];
                swap(temp[1][map[map[i][1].cont][1].x+1][map[map[i][1].cont][1].y],temp[1][map[map[i][1].cont][1].x][map[map[i][1].cont][1].y]);
                tmpcont=contor(temp[1]);
                if(!check(tmpcont,1))
                {
                    if(check(tmpcont,0))
                    {
                        godie(time,map[tmpcont][0].depth);
                        return 0;
                    }
                    copy(temp[1],1,tmpcont);
                    map[tmpcont][1].depth=time,map[++now+rf][1].cont=tmpcont;
                }
            }
            if(map[map[i][1].cont][1].y>0)
            {
                for(int j=0;j<=2;j++)
                  for (int k=0;k<=2;k++)
                    temp[2][j][k]=map[map[i][1].cont][1].a[j][k];
                swap(temp[2][map[map[i][1].cont][1].x][map[map[i][1].cont][1].y-1],temp[2][map[map[i][1].cont][1].x][map[map[i][1].cont][1].y]);
                tmpcont=contor(temp[2]);
                if(!check(tmpcont,1))
                {
                    if(check(tmpcont,0))
                    {
                        godie(time,map[tmpcont][0].depth);
                        return 0;
                    }
                    copy(temp[2],1,tmpcont);
                    map[tmpcont][1].depth=time,map[++now+rf][1].cont=tmpcont;
                }
            }
            if(map[map[i][1].cont][1].y<2)
            {
                for(int j=0;j<=2;j++)
                  for (int k=0;k<=2;k++)
                    temp[3][j][k]=map[map[i][1].cont][1].a[j][k];
                swap(temp[3][map[map[i][1].cont][1].x][map[map[i][1].cont][1].y+1],temp[3][map[map[i][1].cont][1].x][map[map[i][1].cont][1].y]);
                tmpcont=contor(temp[3]);
                if(!check(tmpcont,1))
                {
                    if(check(tmpcont,0))
                    {
                        godie(time,map[tmpcont][0].depth);
                        return 0;
                    }
                    copy(temp[3],1,tmpcont);
                    map[tmpcont][1].depth=time,map[++now+rf][1].cont=tmpcont;
                }
            }
        }
        n1l=n1r+1;n1r+=now;
    }
    return 0;
}
```

---

## 作者：resftlmuttmotw (赞：0)

## 思路

由明确的两种状态可以想到

D(double)BFS即双向BFS 

输入的是个

```cpp
283104765
```

然而 凡是搜索都有个标记即vis[]

但 按题意3 * 3的地图不好标记（也许用map可以）


于是直接用一维dir数组改成

```cpp
int dir[4] = {1,-3,-1,3};
```

但九位数也是开不了的

就有一个cantor展开式

状态压缩一下

```cpp
inline int cantor(int a[])
{
	int i,j,ans = 0;
	for(i = 0;i < 9;i++)
	{
		int s = 0;
		for(j = i + 1;j < 9;j++)
			if(a[j] < a[i]) s++;
		ans += s * fac[8 - i];
	}
	return ans;
}
```

然后就行了 DBFS直接套板子啊

## 优化

其实就上面的好像就可以过了

但还有个优化

与**逆序对**有关

将3 * 3 的图 弄成序列

>可以得出结论：初始状态的逆序对模2必须等于目标状态的逆序对模2，否则无法达成，输出-1

#### 证明

可以转为 **初始状态无论如何改变其奇偶性不变**

位置图

1 2 3

4 5 6

7 8 9


将3 * 3 的图 弄成序列

1 2 3 4 5 6 7 8 9

**注意** 0 不算入队列 所以上面实际上是8个

~~

2 8 3

1 0 4

7 6 5

可见 当位置5的0与位置8的6交换会有几种情况

位置n的数 为方便简写为（n）

Case1：（6）和（7）中有0个比（8）小

则逆序对+ 2

Case2:（6）和（7）中有1个比（8）小

则逆序对- 1 + 1

Case2:（6）和（7）中有2个比（8）小

则逆序对+ 2

综上逆序对奇偶性不变

其它交换情况可以类似讨论


## 代码

```cpp
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
const int MAXN = 400000;
int step[2][MAXN],fac[10] = {1,1,2,6,24,120,720,5040,40320,362880};
bool vis[2][MAXN];
int dir[4] = {1,-3,-1,3};

//cantor状态压缩
inline int cantor(int a[])
{
	int i,j,ans = 0;
	for(i = 0;i < 9;i++)
	{
		int s = 0;
		for(j = i + 1;j < 9;j++)
			if(a[j] < a[i]) s++;
		ans += s * fac[8 - i];
	}
	return ans;
}
struct Node
{
	int word[9],loc,ca;
	bool f;
	void node(int Word[],int LOC,int CA,bool F)
	{
		for(int i = 0;i < 9;i++) word[i] = Word[i];
		loc = LOC,ca = CA,f = F;
	}
}Start,order;
inline int dbfs()
{
	queue<Node> q;
	Start.f = 1,order.f = 0;
	q.push(Start);
	q.push(order);
	int i;
	while(!q.empty())
	{
		Node tmp = q.front();
		q.pop();
		if(vis[!tmp.f][tmp.ca])
			return (step[1][tmp.ca] + step[0][tmp.ca]);
		int Step = step[tmp.f][tmp.ca];
		for(i = 0;i < 4;i++)
		{
			int poss = tmp.loc + dir[i];
            
            //由于dir数组改了 判断也得改
			if(0 <= poss&&poss < 9&&(tmp.loc % 3 == poss % 3||tmp.loc / 3 == poss / 3))
			{
				swap(tmp.word[tmp.loc],tmp.word[poss]);
				int nca = cantor(tmp.word);
				if(!vis[tmp.f][nca])
				{
					Node g;
					vis[tmp.f][nca] = 1;
					step[tmp.f][nca] = Step + 1;
					g.node(tmp.word,poss,nca,tmp.f);
					q.push(g);
				}
				swap(tmp.word[tmp.loc],tmp.word[poss]);	
			}
		}
	}
	return -1;
}

//优化 求逆序对
inline int cutdown(int a[])
{
	int i,j,q = 0;
	for(i = 0;i < 9;i++)
		for(j = i + 1;j < 9;j++)
			if(a[i] != 0&&a[j] != 0&&a[j] < a[i]) q++;
	return q;
}
int main()
{
	int i;
	for(i = 0;i < 9;i++) 
	{
		scanf("%d",&Start.word[i]);
		if(!Start.word[i]) Start.loc = i;
	}
	for(i = 0;i < 9;i++)
	{
		scanf("%d",&order.word[i]);
		if(!order.word[i]) order.loc = i;
	}
    //优化
	if(cutdown(Start.word) % 2 != cutdown(order.word) % 2)
	{
		printf("-1");
		return 0;
	}
	Start.ca = cantor(Start.word);
	vis[1][Start.ca] = 1;
	order.ca = cantor(order.word);
	vis[0][order.ca] = 1;
	printf("%d",dbfs());
	return 0;
}
```

---

## 作者：Nartsam (赞：0)

~~话说康托展开是什么玄学玩意啊。。。~~

思路很简单，在隐式图中遍历求最短步数的题一般都要用到bfs（算法竞赛入门经典【紫书】上讲过），因此直接bfs就可以了。

我们可以用一个结构体来保存当前状态，为了方便处理，我写了两个函数，用来把当前状态压到一个int里和把一个int转化为压缩前的状态，如下：
```cpp
struct State{    //保存状态的结构体
	int a[5][5];
	bool operator ==(const State &rhs)const{
		for(int i=1;i<=3;++i)
			for(int j=1;j<=3;++j)
				if(a[i][j]!=rhs.a[i][j]) return 0;
		return 1;
	}
};
//压缩
int zip(State x){
	int res=0;
	for(int i=1;i<=3;++i)
		for(int j=1;j<=3;++j)
			res=res*10+x.a[i][j];
	return res;
}
//解压
State unzip(int x){
	State res;
	for(int i=3;i>=1;--i){
		for(int j=3;j>=1;--j){
			res.a[i][j]=x%10;
			x/=10;
		}
	}
	return res;
}
```
但上述方法有一个缺点，就是会造成空间的大量浪费，比如dis数组中 19 这个位置就从来没有被使用过，因为不可能有一个状态是000000019，对吧

于是我们可以使用hash来完成离散化的操作
```cpp
struct HashTable{
	#define P 976237
	#define MAXSIZ 1000007
	struct Node{
		int data,val,nxt;
	}ct[MAXSIZ];
	int head[MAXSIZ],tot,num;
	void init(){
		memset(head,0,sizeof(head));
		memset(ct,0,sizeof(ct));
		tot=0; num=0;
	}
	int map(int x){
		int h=((long long)x*32767+17)%P+1;
		for(int i=head[h];i;i=ct[i].nxt){
			if(ct[i].data==x) return ct[i].val;
		}
		ct[++tot].data=x; ct[tot].val=++num;
		ct[tot].nxt=head[h]; head[h]=tot;
		return num;
	}
	#undef P
	#undef MAXSIZ
}hash;
```
到这里该讲的我们基本都讲完了，但有一个小技巧我感觉很有用，和大家分享一下，就是我们把初始状态的dis值赋为1，这样当产生一个新状态时我们判断它压缩+hash后在dis中的值是不是为0就可以判断该状态是否之前已经产生过了，可以省掉一个vis数组或者把dis数组memset成-1的功夫了。不过输出的时候可千万不要忘了把dis值-1啊。。。不然会WA的很惨

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
struct State{
	int a[5][5];
	bool operator ==(const State &rhs)const{
		for(int i=1;i<=3;++i)
			for(int j=1;j<=3;++j)
				if(a[i][j]!=rhs.a[i][j]) return 0;
		return 1;
	}
};
struct HashTable{
	#define P 976237
	#define MAXSIZ 1000007
	struct Node{
		int data,val,nxt;
	}ct[MAXSIZ];
	int head[MAXSIZ],tot,num;
	void init(){
		memset(head,0,sizeof(head));
		memset(ct,0,sizeof(ct));
		tot=0; num=0;
	}
	int map(int x){
		int h=((long long)x*32767+17)%P+1;
		for(int i=head[h];i;i=ct[i].nxt){
			if(ct[i].data==x) return ct[i].val;
		}
		ct[++tot].data=x; ct[tot].val=++num;
		ct[tot].nxt=head[h]; head[h]=tot;
		return num;
	}
	#undef P
	#undef MAXSIZ
}hash;
int zip(State x){
	int res=0;
	for(int i=1;i<=3;++i)
		for(int j=1;j<=3;++j)
			res=res*10+x.a[i][j];
	return res;
}
State unzip(int x){
	State res;
	for(int i=3;i>=1;--i){
		for(int j=3;j>=1;--j){
			res.a[i][j]=x%10;
			x/=10;
		}
	}
	return res;
}
int ans,dis[7000007],dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
State sta,tar;
void readin(State &x){
	for(int i=1;i<=3;++i)
		for(int j=1;j<=3;++j)
			scanf("%1d",&x.a[i][j]);
	return;
}
pair<int,int> getZero(State x){
	for(int i=1;i<=3;++i){
		for(int j=1;j<=3;++j){
			if(x.a[i][j]==0) return make_pair(i,j);
		}
	}
	return make_pair(0,0);
}
State Update(State x,int tow,int zx,int zy){
	int tarx=zx+dx[tow],tary=zy+dy[tow];
	if(tarx<1||tarx>3||tary<1||tary>3){
		x.a[1][1]=-1; return x;
	}
	swap(x.a[zx][zy],x.a[tarx][tary]);
	return x;
}
int bfs(State s){
	queue<int> q;
	int sint=zip(s);
	dis[hash.map(sint)]=1; q.push(sint);
	while(!q.empty()){
		int tmp=q.front(); q.pop();
		State tp=unzip(tmp);
		pair<int,int> pos=getZero(tp);
		for(int tow=0;tow<4;++tow){
			State upd=Update(tp,tow,pos.first,pos.second);
			if(upd==tar) return dis[hash.map(tmp)];
			if(upd.a[1][1]==-1) continue;
			int now=hash.map(zip(upd));
			if(dis[now]) continue;
			dis[now]=dis[hash.map(tmp)]+1;
			q.push(zip(upd));
		}
	}
	return -1;
}
int main(){
	int ed=123804765; tar=unzip(ed);
	readin(sta);
	ans=bfs(sta);
	if(sta==tar) ans=0;
	printf("%d\n",ans);
	return 0;
}
```

看了题解感觉我写的代码好长啊，似乎有一些操作是不必要的？但它却跑的挺快（正常1400ms左右，吸氧后700ms左右），感觉我代码里的一些小技巧还是挺有用的。。。。。

---

## 作者：only_杜春萌 (赞：0)

 此题为**路径寻找问题**的典型例题，和回溯法的不同是前者需要找到一个**满足约束的解**而后者是寻找一个从初始状态到终止状态的路径

那么这道题可以被看做是一个最短路问题，将图中节点编号的状态视为结点，求一条从初始结点（始态编号）至终点（末态编号）的最短路，这里用BFS来解决此类问题

然而此题不是简简单单的套上模板就可以了，状态怎么表示？结点怎么表示？这里选择定义一个状态类型用来保存状态
首先解决状态的定义问题，当然这可能对你不成问题如果不是，可以借鉴一下如下定义方法
```cpp
typedef int state[9];//定义一个名为状态的类型，这个类型中保存了各编号的位置信息
const int maxstate =3628802;//十的阶乘，然而实际上！9就足够了；
state st[maxstate],goal;//定义状态数组，以及目标状态；//实际上等同于st[maxstate][9];
int dist[maxstate];//定义距离数组，意义同最短路d数组

const int dx[] = {-1,1,0,0};
const int dy[] = {0,0,-1,1};//这个不需要解释了吧
```
政治课本有言：凡是皆有矛盾，我们精力有限，应当先集中解决主要矛盾，这里的主要矛盾当然就是bfs怎么写了。

```cpp
int bfs(){		
	init_lookup_table();
    int front = 1,rear = 2;
    while(front<rear)//基操自然是不能变的
	{
    	state &s = st[front]//这个是引用操作，s即为各个编号的位置信息，或者说是当前状态的信息
        if(memcmp(goal,s,sizeof(s))==0)return front;//因为搜索大名是bfs嘛，最先遍历到的自然是次数最少的了
        for(int j = 0;j<9;j++)if(!s[j])break;//寻找到零所在的位置
        int x = j/3,y = j%3;//对位置进行decoding操作,当时一直搞不明白为什么x要除以三而y要取摸三，
        //后来意识到这tm根本无所谓
        for(int d = 0;d<4;d++){
        	int newx = x+dx[d];
            int newy = y+dy[d];
            int newj = newx*3+newy;
            if(newx>=0&&new<3&&newy>=0&&newy<3)//移动合法判定
            {
            	state& t = st[rear];
                memcpy(&t,&s,sizeof(s));//实测效率明显高于循环赋值，memcmp同
                t[newz] = s[j];//构造出s【j】状态移动一个物块后的状态
                t[j] = s[newz];
                dist[rear] = front + 1;//标记rear状态是由front状态扩展一次得到的，所以加一
                if(try_to_insert(rear))rear++；
            }
        }
        front ++;    
    }
}
```


就此，主要矛盾就解决完了..








吗？
并没有，因为还有一个关键的地方没有做。
显然，滑滑块滑一次达到某个状态，和滑多次滑到这个状态，它们以后扩展的方式是相同的，也就是说如果不考虑重复状态，多次扩展之后会进行大量的无用功，所以需要判断该状态有没有遍历到，没错，记忆化搜索；

那么记忆化搜索怎么写呢？
第一种最简单的想法就是开一个九维数组，但是你很快就会发现，数组很矫情，开不下这么大，九的九次方大概是4亿，而且实际上只需要！9就可以了，用九维数组会造成大量空间浪费
第二种方法是en/de coding，也就是编码解码
怎么操作呢？将排列构造成一个整数，开一个一维数组和九的阶乘一一对应起来，代码如下

```cpp
int vis[362881],actual[9];
void init_lookup_table(){
	actual[0] = 1;
    for(int i = 1;i<9;i++)actual[i]=actual[i-1]*i;//递推存阶乘
}
int try_to_insert(int s){
	int code = 0;//将st【s】向code上进行映射
    for(int i = 0;i<9;i++){
    	int cnt = 0;
        for(int j = i+1;i<9;i++)if(st[s][j]<st[s][i])cnt++;
        code += actual[8-i] * cnt;
    }
    if(vis[code])return 0;
    return vis[code] = 1;
}
```
第三种就是利用STL中的set，然而时间效率低劣，如果不吸氧，咳咳，分数可能惨不忍
第四种利用hash技术，这里不再赘述

最后交上头文件跑路
```cpp
int main(){
	
	/*数据输入begin*/
	int a[10];
	for(int i = 1;i<=9;i++)cin>>st[1][i];
	/*end*/
	goal[] ={1,2,3,8,0,4,7,6,5}; 
	
	int ans = bfs();
	if(ans>0)printf("%d\n",dist[ans]);
	else printf("-1\n");
	return 0;
}
```

---

## 作者：minGr (赞：0)

# 【康拓展开】八数码 #


------------

> 摘自百度百科：
> 
> 康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。


------------

简单说来，康拓展开可以求得一组排列的字典序，也可以根据字典序求得一组排列。从而形成哈希映射。

关于康拓展开和逆展开的运算，需要用到排列组合的相关知识：

## 公式 ：##
![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D280/sign=bffaac6e6081800a6ae58e06813433d6/dcc451da81cb39dbd85f32b7dc160924aa1830b7.jpg)


代码实现：

#### 康拓展开： ##

    static const int FAC[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};   // 阶乘
	int cantor(int *a, int n)
	{
	    int x = 0;
	    for (int i = 0; i < n; ++i) {
	        int smaller = 0;  // 在当前位之后小于其的个数
	        for (int j = i + 1; j < n; ++j) {
	            if (a[j] < a[i])
	                smaller++;
	        }
	        x += FAC[n - i - 1] * smaller; // 康托展开累加
	    }
	    return x;  // 康托展开值
	}

#### 逆康拓展开： ##

	static const int FAC[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};   // 阶乘
  
	//康托展开逆运算
	void decantor(int x, int n)
	{
	    vector<int> v;  // 存放当前可选数
	    vector<int> a;  // 所求排列组合
	    for(int i=1;i<=n;i++)
	        v.push_back(i);
	    for(int i=m;i>=1;i--)
	    {
	        int r = x % FAC[i-1];
	        int t = x / FAC[i-1];
	        x = r;
	        sort(v.begin(),v.end());// 从小到大排序
	        a.push_back(v[t]);      // 剩余数里第t+1个数为当前位
	        v.erase(v.begin()+t);   // 移除选做当前位的数
	    }
	}

### 题目分析 ####

对于这道题来说，如果我们存储的是三维数组q[i][j][k], i 代表图的序号，j 代表图的横坐标，k代表图的纵坐标，q[i][j][k] 代表该点的值。那么判重操作会很麻烦。 把三维数组压成二维也一样。解决判重是关键。

于是我们引入了康拓展开，如果我们把一个图的康拓展开值进行存储，用vis数组判重， vis[cantor]=1 表示这张图已经遍历过。那么BFS的队列可以用结构体：

	int t[10]={0,1,2,3,8,0,4,7,6,5};//目标情况 
	int a[10]; //输入图
	int d[10]; //逆康拓图
	int tar,ans; //tar为目标图的cantor值
    struct Node{
		int cVal;//这张图的cantor值
		int dis;//从起点到这张图的距离
		int pos;//记录这张图中0的位置
	}q[400000];//因为最多有8!种排列 接近370000
	int head=1,tail=2;
	bool vis[400000];//判重数组
	
### BFS 函数： ###

在遍历时我使用的是一维，没有转成二维坐标系，
因此犯了一个错误~~（gdb一万年有木有QAQ）~~

	int dir[4]={-3,-1,1,3};

单纯以为向上向下为-3/+3，向左向右为-1/+1，因此在遍历时出现问题：

e.g. 

有[1][2][3][0][4][5][6][7][8]这种情况时，-1操作不能进行

有[1][2][0][3][4][5][6][7][8]这种情况时，+1操作不能进行

因此本蒟蒻只能进行这样的修改
	
	if(q[head].pos%3==1 && dir[i]==-1) continue;//QAQ
	if(q[head].pos%3==0 && dir[i]==1)  continue;//QAQ

~~（打死不改成用二维坐标系>w<）~~

	int bfs()
	{
		q[head].dis=0; //开始的距离为0 
		q[head].cVal = cantor(a); //计算cantor值
		vis[q[head].cVal]=1;//以及遍历
		//q[head].pre=0;//记录前驱cantor值（gdb时用）
		if(q[head].cVal==tar) return 0;//判断有无输入即为所求的情况
		while(head<=tail)//BFS
		{	
			for(int i=0;i<4;i++)//四个方向
			{
				if(q[head].pos%3==1 && dir[i]==-1) continue;//QAQ
				if(q[head].pos%3==0 && dir[i]==1)  continue;//QAQ
				int newPos=q[head].pos+dir[i];
				if(newPos>0 && newPos<10)//在边界内
				{
					decantor(q[head].cVal);
					swap(d[newPos],d[q[head].pos]);
					int tmp=cantor(d);
					if(vis[tmp]==0)//判重
					{
						q[tail].cVal=tmp;
						q[tail].dis=q[head].dis+1;
						q[tail].pos=newPos;
						vis[q[tail].cVal]=1;
						//q[tail].pre=head;
						if(q[tail].cVal==tar)//判找到所求 
							return q[tail].dis;
						tail++;
					}	
				}
			}	
			head++;
		}
	}

#### 在提交时还遇到的问题及修改 ####

- 之前的decantor写法爆TLE：
 	

		void decantor(int x)
		{
		
			int v[10];
			int cnt=1;
			for(int i=0;i<=8;i++) v[i]=i;
			for(int i=9;i>=1;i--)
			{
				int r= x% Fac[i-1];
				int t= x/ Fac[i-1];
				x = r;
				d[cnt++] = v[t];
				for(int j=t;j<=8;j++)
					v[j]=v[j+1];
			}
		
		}


## 完整代码 ##

	#include<stdio.h>
	#include<iostream>
	#include<algorithm>
	#include<cstring>
	#include<vector>
	#include<queue>
	using namespace std;
	int t[10]={0,1,2,3,8,0,4,7,6,5};//目标情况 
	int tar,ans; 
	int a[10],d[10]; 
	int dir[4]={-3,-1,1,3};
	int Fac[10]={1,1,2,6,24,120,720,5040,40320,362880};//阶乘数组 
	struct Node{
		int pos;
		int cVal;
		int dis;
		//int s[10];
		//int pre;
	}q[400000];
	bool vis[400000];
	int head=1,tail=2;
	
	int cantor(int t[])
	{
		int nu=0;
		for(int i=1;i<=9;i++)
		{
			int smaller=0;
			for(int j=i+1;j<=9;j++){
				if(t[i]>t[j]){
					smaller++;
				}
			}
			nu+=Fac[9-i]*smaller;
		}
		return nu;
			
	}
	
	void decantor(int x)
	{
	
		int v[10];
		int cnt=1;
		for(int i=0;i<=8;i++) v[i]=i;
		for(int i=9;i>=1;i--)
		{
			int r= x% Fac[i-1];
			int t= x/ Fac[i-1];
			x = r;
			d[cnt++] = v[t];
			for(int j=t;j<=8;j++)
				v[j]=v[j+1];
		}
	
	}
	
	int bfs()
	{
		q[head].dis=0; 
		q[head].cVal = cantor(a);
		vis[q[head].cVal]=1;
		//q[head].pre=0;
		if(q[head].cVal==tar) return 0;
		while(head<=tail)//BFS
		{	
			for(int i=0;i<4;i++)
			{
				if(q[head].pos%3==1 && dir[i]==-1) continue;//QAQ
				if(q[head].pos%3==0 && dir[i]==1)  continue;//QAQ
				int newPos=q[head].pos+dir[i];
				if(newPos>0 && newPos<10)
				{
					decantor(q[head].cVal);//decantor->TLE
					swap(d[newPos],d[q[head].pos]);
					int tmp=cantor(d);
					if(vis[tmp]==0)
					{
						q[tail].cVal=tmp;
						q[tail].dis=q[head].dis+1;
						q[tail].pos=newPos;
						vis[q[tail].cVal]=1;
						//q[tail].pre=head;
						if(q[tail].cVal==tar) return q[tail].dis;
						tail++;
					}	
				}
			}	
			head++;
		}
	}
	
	
	int main()
	{
		char s;
		for(int i=1;i<=9;i++) 
		{
			scanf("%c",&s);
			a[i]=s-'0';
			if(a[i]==0) q[head].pos=i;
		}
		tar =cantor(t);
		
		ans = bfs();
		printf("%d\n",ans);
			/*for(int i=tail;i>0;i=q[i].pre)
			{
				for(int j=1;j<=9;j++) cerr<<q[i].s[j]; 
				cerr<<endl;
			}*///查看路径 （gdb）
			
		return 0;
		
	 } 

---

## 作者：STLGirlfriend (赞：0)

# 题解

BFS。将初始状态压入队列，再尝试每一种变换，同时统计移动次数，直到出现目标状态。

## 状态的表示

这里使用 C++11 的新特性 `std::array<int, 9>` 来表示状态，为什么不使用普通数组的原因：

1. 可以直接作为队列元素类型~~（当然普通数组封装一个结构体也可以）~~。
2. 方便判重，具体见下文。

## 判重

这里使用一个 `std::unordered_set< std::array<int, 9> >` 来判重，现在 `std::array` 的好处就体现出来了：**可以直接作为集合类型**！

当然哈希函数还是要自己写，不过也不难，把状态压成一个 $9$ 位数就可以了。

# 代码

```c++
#include <cstdio>
#include <cctype>
#include <array>
#include <queue>
#include <unordered_set>

const int StateSize = 9;
const int Line = 3;
const int Row = 3;
typedef std::array<int, StateSize> State;
const State Goal = {1, 2, 3, 8, 0, 4, 7, 6, 5};

const int DirSize = 4;
const int Dx[DirSize] = {0, 1, 0, -1};
const int Dy[DirSize] = {1, 0, -1, 0};

struct Node {
    State st;
    int dist;

    Node(const State &st, const int &dist = 0) : st(st), dist(dist) {}
};

struct StateHash {
    size_t operator()(const State &s) const {
        size_t v = 0;
        for (int x : s)
            v = v * 10 + x;
        
        return v; 
    }
};

char getGraph() {
    char c;
    while (!isgraph(c = getchar()));

    return c;
}

void readState(State &st) {
    for (int i = 0; i < StateSize; ++i)
        st[i] = getGraph() - '0';
}

int main() {
    State st;
    readState(st);

    std::queue<Node> Q;
    std::unordered_set<State, StateHash> S;
    Q.push(Node(st));
    S.insert(st);

    while (!Q.empty()) {
        Node &node = Q.front();
        State &st = node.st;
        if (st == Goal) {
            printf("%d\n", node.dist);
            break;
        }

        int z;
        for (z = 0; z < StateSize; ++z) {
            if (!st[z]) {
                break;
            }
        }

        int x = z / Line, y = z % Row;
        for (int i = 0; i < DirSize; ++i) {
            int _x = x + Dx[i], _y = y + Dy[i];
            int _z = _x * Line + _y;
            if (_x >= 0 && _x < Line && _y >= 0 && _y < Row) {
                State _st = st;
                _st[_z] = st[z];
                _st[z] = st[_z];

                if (!S.count(_st)) {
                    S.insert(_st);
                    Q.push(Node(_st, node.dist + 1));
                }
            }
        }

        Q.pop();
    }
}
```

---

## 作者：EricWay1024 (赞：0)



刘汝佳书上原题, 照做即可. 

和书上原来的解法相比, 我有所修改的地方: 

#### 状态直接用一个9位整数表示.

- 好处: 存储空间省了

- 坏处: 交换两位数字略有些麻烦

#### 注意: 状态和状态下标

这个题目最需要注意的地方就是状态和状态下标的区别. 状态下标就是状态在st数组中的编号. 

使用状态下标表示一个状态, 而不是直接用状态本身表示, 是为了压缩存储空间, 避免造成浪费. 因为, 如果直接用状态表示其本身, 要将其的一些属性(如距离/哈希表中的下一个状态)存储起来, 就要耗费10^9大小的数组. 但我们的状态并不是随意的九位数. 这九位数是0~9的全排列, 一共只有9!=362880个, 因此上述的存储方式将有大量浪费. 

而把每一种用到的排列方式编上号, 成为状态下标, 再进行存储, 则具有较大优势. 

根据个人经验, 这样的存储方式还是比较常见的.

#### 哈希表的使用

我们不想重复计算相同的状态. 因此, 需要找到一种方式把已经计算过的状态存储起来. 较为简单的方法是直接按照状态下标存储在st数组里, 每一次从第一个到最后一个检索是否计算过. 这样的方式是低效的.

哈希表将数据增加了一个维度. 首先给状态计算一个哈希编码. 本题中直接对状态取模即可. 把所有哈希编码相同的状态归为一类. 每次在这个类别中寻找是否有计算过的状态即可.

刘汝佳书上给出的哈希表是通过链表实现的. 其实用vector也可以, 写起来稍微容易一点, 而且本题同样可以AC. 个人觉得哈希表的这两种实现方法和图论里存图的两种方法是相似的.

#### BFS

首先把开始状态入队. 每次取队首, 看看是不是目标. 是就结束. 不是, 找到0, 尝试滑动, 组成新的状态, 距离+1. 尝试把新的状态插入哈希表里. 如果以前计算过就不会插入. 如此反复, 找到答案.

书上这题的BFS没有用queue, 而是手工用数组实现. 这样的好处应该是下标比较容易对应. 我想用queue也是可以的.

#### 代码1 没有使用STL

```
//8Numbers
#include<iostream>
#include<algorithm>
#include<map>
#include<set>
#include<bitset>
#include<queue>
#include<deque>
#include<vector>
#include<string>
#include<stack>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#define INF 0x3f3f3f3f
#define MAXS 363000
#define HASH 100007
using namespace std;
int start; //起始状态 
int dist[MAXS]; //下标是n的状态的距离 
int head[HASH]; //哈希编码是h的首个状态下标 
int next[MAXS]; //状态下标n的的下一个状态下标 
int st[MAXS]; //状态下标n对应的状态 
const int goal=123804765;
const int dx[4]={0, 0, 1, -1};
const int dy[4]={1, -1, 0, 0};
const int ten[10]={1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000}; //10的n次方
inline int trans(int s, int z, int zz){
	//s原来的0在第z位, 要变成第zz位
	z=8-z;
	zz=8-zz;
	int m=(s/ten[zz])%10;
	return s-m*ten[zz]+m*ten[z];
}

inline int zero(int s){ //返回状态中0的位置 
	int z=8;
	while(1){
		if ((s%10)==0) break;
		s=s/10;
		z--;
	}
	return z;
}

bool insert(int s, int n){ //s是要插入的状态, n是状态下标 
	int h=s%HASH;//h是哈希编码
	int u=head[h];//u是状态下标 
	while(u){
		if (st[u]==s) return 0;
		u=next[u];
	}
	next[n]=head[h];
	head[h]=n;
	st[n]=s;
	return 1;
}

int bfs(){ //返回目标状态的下标 
	memset(head, 0, sizeof(head));
	int front=1; int rear=2;
	st[1]=start;
	while(front<rear){
		int s=st[front];
		if (s==goal) return front;
		int z=zero(s); 
		int x=z/3, y=z%3;
		for (int d=0; d<4; d++){
			int xx=x+dx[d];
			int yy=y+dy[d];
			int zz=xx*3+yy;
			if (xx>=0 && xx<3 && yy>=0 && yy<3){
				int t=trans(s, z, zz); //新的状态 
				dist[rear]=dist[front]+1;
				if (insert(t, rear))  rear++;
			}
		}
		front++;
	}
	return 0;
}

int main(){
	cin>>start;
	int ans=bfs();
	//dist[0]=-1; //如果题目是无解输出-1时用
	cout<<dist[ans]<<endl;
}

```

-------------


#### 代码2 哈希表用vector, BFS用queue的STL~~豪华~~版
```cpp
//8Numbers
#include<iostream>
#include<algorithm>
#include<map>
#include<set>
#include<bitset>
#include<queue>
#include<deque>
#include<vector>
#include<string>
#include<stack>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#define INF 0x3f3f3f3f
#define MAXS 363000
#define HASH 100007
using namespace std;
int start; //起始状态 
vector<int> hash[HASH]; //哈希编码是h的状态下标都存储在hash[h]中 
int dist[MAXS]; //下标是n的状态的距离 
int st[MAXS]; //状态下标n对应的状态 
const int goal=123804765;
const int dx[4]={0, 0, 1, -1};
const int dy[4]={1, -1, 0, 0};
const int ten[10]={1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};
inline int trans(int s, int z, int zz){
	//s原来的0在第z位, 要变成第zz位
	z=8-z;
	zz=8-zz;
	int m=(s/ten[zz])%10;
	return s-m*ten[zz]+m*ten[z];
}

inline int zero(int s){ //返回状态中0的位置 
	int z=8;
	while(1){
		if ((s%10)==0) break;
		s=s/10;
		z--;
	}
	return z;
}

bool insert(int s, int n){ //s是要插入的状态, n是状态下标 
	int h=s%HASH;//h是哈希编码
	for (int i=0; i<hash[h].size(); i++){
		int u=hash[h][i];
		if (st[u]==s) return 0;
	} 
	hash[h].push_back(n);
	st[n]=s;
	return 1;
}

int bfs(){ //返回目标状态的下标 
	queue<int> q;
	int tot=2;
	q.push(1);
	st[1]=start;
	while(!q.empty()){
		int front=q.front(); q.pop();
		int s=st[front];
		if (s==goal) return front;
		int z=zero(s); 
		int x=z/3, y=z%3;
		for (int d=0; d<4; d++){
			int xx=x+dx[d];
			int yy=y+dy[d];
			int zz=xx*3+yy;
			if (xx>=0 && xx<3 && yy>=0 && yy<3){
				int t=trans(s, z, zz); //新的状态
				if (insert(t, tot)){
					dist[tot]=dist[front]+1;
					q.push(tot);
					tot++;
				}
			}
		}
	}
	return 0;
}
int main(){
	cin>>start;
	int ans=bfs();
	//dist[0]=-1; 
	cout<<dist[ans]<<endl;
}

```

两份代码都是可以AC的.


---

## 作者：aiyougege (赞：0)

#### Solution
　　其实我是第一次做这个题, 主要是给像我这样比较菜既不会**双向宽搜**不会**康托展开**也不会**极限剪枝**的人看. 我们要巧妙利用**STL**给予我们的工具.具体做法如下:
  
- 宽搜, 利用stl中的`queue`, 状态用`pair<int,int>`分别表示棋盘形成的整数和当前步数.
- 用`map/set`判断状态的重复, 此处可替换为康托展开.
- 用一个整数表示棋盘, 用到时将其转化为$3\times 3$的数组, 然后再移动空白位置.也可以不转化, 就是感觉会更麻烦一点.

　　因为程序中使用了大量的`map,pair,queue`因此常数巨大, 但是写的比较轻松.

#### Code
```c++
#include<iostream>
#include<cstdio>
#include<queue>
#include<map>
using namespace std;

int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};

int st,ts;
int zt[4][4];

pair<int,int> convert(int z){
    zt[2][2]=z%10,z/=10,zt[2][1]=z%10,z/=10,zt[2][0]=z%10,z/=10,
    zt[1][2]=z%10,z/=10,zt[1][1]=z%10,z/=10,zt[1][0]=z%10,z/=10,
    zt[0][2]=z%10,z/=10,zt[0][1]=z%10,z/=10,zt[0][0]=z%10,z/=10;
    for(int i=0;i<3;++i)
        for(int j=0;j<3;++j)
            if(!zt[i][j])return make_pair(i,j);
}
void Convert(){
    ts=0;
    ts+=zt[0][0],ts*=10,ts+=zt[0][1],ts*=10,ts+=zt[0][2],ts*=10,
    ts+=zt[1][0],ts*=10,ts+=zt[1][1],ts*=10,ts+=zt[1][2],ts*=10,
    ts+=zt[2][0],ts*=10,ts+=zt[2][1],ts*=10,ts+=zt[2][2];
}
int mubiao=123804765;
bool in(int x,int y){
    if(x>-1&&y>-1&&x<3&&y<3)return true;
    return false;
}
map<int,int>ma;
int tot=0;

main(){
    scanf("%d",&st);
    queue<pair<int,int> >que;
    que.push(make_pair(st,0));
    while(!que.empty()){
        pair<int,int> top=que.front();
        if(top.first==mubiao){
            printf("%d",top.second);
            return 0;
        }
        pair<int,int> bi=convert(top.first);
        que.pop();
        for(int i=0;i<4;++i){
            int xx=bi.first+dx[i],yy=bi.second+dy[i];
            swap(zt[xx][yy],zt[bi.first][bi.second]);
            Convert();
            if(in(xx,yy)&&!ma.count(ts)){
                que.push(make_pair(ts,top.second+1));
                ma[ts]=++tot;
            }
            swap(zt[xx][yy],zt[bi.first][bi.second]);
        }
    }
    return 0;
}
```

---

## 作者：andyli (赞：0)

八数码问题其实就是图上的最短路问题，图的“节点”就是9个格子中的滑块编号（从上到下，从左到右把它们放到一个包含9个元素的数组中）。无权图上的最短路问题可以用BFS求解。


------------

树的BFS不需要判重，因为根本不会重复；但对于图来说，如果不判重，时间和空间都将产生极大的浪费。 楼下的判重方式建议不要学习，因为用一个九维数组一共有9^9=387420489项，太多了，数组可能开不下。实际结点数并没有这么多，0~8的排列总共只有9!=362880个。这样的用法存在大量的浪费…——数组中有很多项都没有被用到，但却占据了空间。


------------

第一种办法是把排列变成整数，这样只开一个一维数组就可以了。（效率还行）。但是适用范围不大：如果隐式图的总结点数非常大，编码也会很大，数组还是开不下。


------------

第二种办法是使用哈希（hash）技术（简单地说，是把结点变成整数，但不必一一对应）。（比赛中最常用）


------------

第三种方法是利用STL集合。（代码最好写），但是效率比较慢，建议在时间紧迫或对效率要求不太高的情况下使用，或者仅把它作为“跳板”——先写一个STL的程序，确保主算法正确，然后把set替换成自己写的哈希表。


------------

这里利用第二种方法，因为比赛中比较常用，而且执行效率很高。代码如下：
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

using State = int[9]; // 定义“状态”类型
const int maxstate = 1000000;
State st[maxstate], goal = {1, 2, 3, 8, 0, 4, 7, 6, 5}; // 状态数组。所有状态都保存在这里
int dist[maxstate]; // 距离数组

const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};

namespace myhash // STL有许多函数名是hash的函数，为了保险最好用名称空间（换个名字也可以），个人习惯
{
    const int hashsize = 1000003;
    int head[hashsize], next[maxstate];

    void init_lookup_table()
    {
        memset(head, 0, sizeof(head));
    }

    int hash(State& s)
    {
        int v = 0;
        // 把9个数字组合成9位数
        for (int i = 0; i < 9; i++)
            v = v * 10 + s[i];
        return v % hashsize;
        // 确保hash值是不超过hash表的大小的非负整数
    }

    int try_to_insert(int s)
    {
        int h = hash(st[s]);
        int u = head[h]; // 从表头开始查找链表
        while (u)
        {
            // 找到了，插入失败
            if (!memcmp(st[u], st[s], sizeof(st[s])))
                return 0;
            u = next[u]; // 顺着链表接着找
        }
        next[s] = head[h]; // 插入到链表中
        head[h] = s;
        return 1;
    }
}

// BFS，返回目标状态在st数组下标
int bfs()
{
    myhash::init_lookup_table(); // 初始化查找表
    int front = 1, rear = 2; // 不使用下标0，因为0被看做“不存在”
    while (front < rear)
    {
        State& s = st[front]; // 用引用简化代码
        if (!memcmp(goal, s, sizeof(s)))
            return front; // 找到目标状态，成功返回
        int z;
        for (z = 0; z < 9; z++)
            if (!s[z])
                break; // 找“0”的位置
        // 获取行列编号（0~2） 
        int x = z / 3;
        int y = z % 3;
        for (int d = 0; d < 4; d++)
        {
            int newx = x + dx[d];
            int newy = y + dy[d];
            int newz = newx * 3 + newy;
            if (newx >= 0 && newx < 3 && newy >= 0 && newy < 3)
            { // 如果移动合法
                State& t = st[rear]; // 扩展新结点
                memcpy(&t, &s, sizeof(s));
                t[newz] = s[z];
                t[z] = s[newz];
                // 更新新结点的距离值
                dist[rear] = dist[front] + 1;
                // 如果成功插入查找表，修改队尾指针
                if (myhash::try_to_insert(rear))
                    rear++;
            }
        }
        front++;
    }
    return 0; // 失败
}

int main()
{
    char tmp;
    for (int i = 0; i < 9; i++)
    {
        cin >> tmp; // 起始状态
        st[1][i] = tmp - '0';
    }
    int ans = bfs(); // 返回目标状态的下标
    if (ans > 0)
        cout << dist[ans] << endl;
    else
        cout << -1 << endl;
    return 0;
}
```
注意：本代码用的是C++11新标准，如需要C++98代码，请私信我。

提示：某些特定的STL实现还有hash_set，它正是基于前面的哈希表，但它并不是标准C++的一部分，因此不是所有情况下都可用。

---

## 作者：Uranus (赞：0)

题目链接：[【P1379】八数码难题 - 洛谷 ](https://www.luogu.org/problemnew/show/P1379)

看到题目标签“HASH”的时候我是懵逼的，然后看到了“枚举，暴力”，于是分别用判重和不判重的BFS打了一边，都是TLE。

看题解里面都是神仙，我就说一个我的BFS的简单优化方法：写两遍。我们知道，BFS是往广处去搜索，我们把这想象成一个以起点为圆心的一个圆，每向前走一步，就是圆的半径增大一个单位，而圆的每个单位面积上是一种状态，当圆增大到目标点那么大时，找到了答案，搜索结束。那么显然的，当半径较大时，每走一步就会有十分大量的状态需要来储存（ _S=πr²_ ）。通常的，我们用“判重”的方法来解决，但是在这里，还有一种优化方法：双向搜索。

双向搜索适用于起点和终点状态都很明确的搜索题。试想，我从起点推算到终点，与我从终点推算到起点，最后得到的最少步骤数一定是相等的，所以我们可以从起点和终点同时搜索。同样用圆来打比方，假设以起点为圆心画圆时，最终半径为r，以终点为圆心画圆时，最终半径为R。那么显然有：

#### πr²+πR²≤π(r+R)²


所以当害怕BFS会TLE时，不妨打一打双向BFS。

代码奉上：

```cpp
#include<iostream>
using namespace std;
const int MAXN=50000;
string l[MAXN],r[MAXN]={"123804765"};///l即从左（起点）搜索，r即从右（终点）搜索，且终点是确定的
int lstep[MAXN],rstep[MAXN],l0[MAXN],r0[MAXN]={4},lh,lt,rh,rt,anima;
///两个step数组储存步数，两个0数组储存空格的位置，两个h变量指头指针（head），t变量指尾指针（tail）
///anima用来判重以及判断是否得解（其实anima是我玩的音游deemo里的一首魔王曲）
int ljudge(string tmp)///左侧搜索的判重
{
    for(int i=0;i<rt;i++)
        if(r[i]==tmp)
            return i;///与右侧某点重合，找到答案，返回右侧该点的值
    for(int i=0;i<lt;i++)
        if(l[i]==tmp)
            return -1;///重复，返回-1
    return -2;///新状态，返回-2
}
int rjudge(string tmp)///右侧搜索的判重
{
    for(int i=0;i<lt;i++)
        if(l[i]==tmp)
            return i;///与左侧某点重合，找到答案，返回左侧该点的值
    for(int i=0;i<rt;i++)
        if(r[i]==tmp)
            return -1;///重复，返回-1
    return -2;///新状态，返回-2
}
int main()
{
    cin>>l[0];
    if(l[0]==r[0])
    {
        cout<<0;
        return 0;///起点终点相同直接结束程序
    }
    for(int i=0;i<9;i++)
    {
        if(l[0][i]=='0')
        {
            l0[0]=i;///找空格
            break;
        }
    }
    while(1)///一定会有解，所以无限循环直到找到解
    {
    	///左侧搜索开始
        if(l0[lh]>2)
        {
            l[++lt]=l[lh];
            l[lt][l0[lh]]=l[lt][l0[lh]-3];
            l[lt][l0[lh]-3]='0';
            anima=ljudge(l[lt]);
            if(anima>=0)
            {
                cout<<rstep[anima]+lstep[lh]+1;
                return 0;
            }
            else if(anima==-1) lt--;
            else if(anima==-2)
            {
                lstep[lt]=lstep[lh]+1;
                l0[lt]=l0[lh]-3;
            }
        }
        if(l0[lh]<6)
        {
            l[++lt]=l[lh];
            l[lt][l0[lh]]=l[lt][l0[lh]+3];
            l[lt][l0[lh]+3]='0';
            anima=ljudge(l[lt]);
            if(anima>=0)
            {
                cout<<rstep[anima]+lstep[lh]+1;
                return 0;
            }
            else if(anima==-1) lt--;
            else if(anima==-2)
            {
                lstep[lt]=lstep[lh]+1;
                l0[lt]=l0[lh]+3;
            }
        }
        if(l0[lh]%3!=0)
        {
            l[++lt]=l[lh];
            l[lt][l0[lh]]=l[lt][l0[lh]-1];
            l[lt][l0[lh]-1]='0';
            anima=ljudge(l[lt]);
            if(anima>=0)
            {
                cout<<rstep[anima]+lstep[lh]+1;
                return 0;
            }
            else if(anima==-1) lt--;
            else if(anima==-2)
            {
                lstep[lt]=lstep[lh]+1;
                l0[lt]=l0[lh]-1;
            }
        }
        if(l0[lh]%3!=2)
        {
            l[++lt]=l[lh];
            l[lt][l0[lh]]=l[lt][l0[lh]+1];
            l[lt][l0[lh]+1]='0';
            anima=ljudge(l[lt]);
            if(anima>=0)
            {
                cout<<rstep[anima]+lstep[lh]+1;
                return 0;
            }
            else if(anima==-1) lt--;
            else if(anima==-2)
            {
                lstep[lt]=lstep[lh]+1;
                l0[lt]=l0[lh]+1;
            }
        }
        lh++;///左侧搜索结束，头指针自加
        ///右侧搜索开始
        if(r0[rh]>2)
        {
            r[++rt]=r[rh];
            r[rt][r0[rh]]=r[rt][r0[rh]-3];
            r[rt][r0[rh]-3]='0';
            anima=rjudge(r[rt]);
            if(anima>=0)
            {
                cout<<lstep[anima]+rstep[rh]+1;
                return 0;
            }
            else if(anima==-1) rt--;
            else if(anima==-2)
            {
                rstep[rt]=rstep[rh]+1;
                r0[rt]=r0[rh]-3;
            }
        }
        if(r0[rh]<6)
        {
            r[++rt]=r[rh];
            r[rt][r0[rh]]=r[rt][r0[rh]+3];
            r[rt][r0[rh]+3]='0';
            anima=rjudge(r[rt]);
            if(anima>=0)
            {
                cout<<lstep[anima]+rstep[rh]+1;
                return 0;
            }
            else if(anima==-1) rt--;
            else if(anima==-2)
            {
                rstep[rt]=rstep[rh]+1;
                r0[rt]=r0[rh]+3;
            }
        }
        if(r0[rh]%3!=0)
        {
            r[++rt]=r[rh];
            r[rt][r0[rh]]=r[rt][r0[rh]-1];
            r[rt][r0[rh]-1]='0';
            anima=rjudge(r[rt]);
            if(anima>=0)
            {
                cout<<lstep[anima]+rstep[rh]+1;
                return 0;
            }
            else if(anima==-1) rt--;
            else if(anima==-2)
            {
                rstep[rt]=rstep[rh]+1;
                r0[rt]=r0[rh]-1;
            }
        }
        if(r0[rh]%3!=2)
        {
            r[++rt]=r[rh];
            r[rt][r0[rh]]=r[rt][r0[rh]+1];
            r[rt][r0[rh]+1]='0';
            anima=rjudge(r[rt]);
            if(anima>=0)
            {
                cout<<lstep[anima]+rstep[rh]+1;
                return 0;
            }
            else if(anima==-1) rt--;
            else if(anima==-2)
            {
                rstep[rt]=rstep[rh]+1;
                r0[rt]=r0[rh]+1;
            }
        }
        rh++;///左侧搜索结束，头指针自加
    }
}
```

---

## 作者：EternalAlexander (赞：0)

首先这题的思路bfs没什么好说的，主要还是判重方面。

说一下我判重的思路吧，貌似还没有这么做的。

首先将每个状态转换为数然后hash映射到0-100003的范围内，开一个大小为100003的二维vector。

判重：

首先还是将状态转换为数。然后找到vector中映射到的位置，遍历那个位置，如果找到了这个状态就重了。

插入：

在映射到的位置直接push\_back这一串数。

唉总觉得没说清楚，直接看代码吧（自认为代码可读性不错）

2384ms/14.54MB

    
    
    
    
    
    
        
    
    
```cpp
    #include <cstdio>
    #include <cstring>
    #include <vector>
    #include <algorithm>
    #define hashsize 100003
    using namespace std;
    struct p
    {
        int map[3][3];
        int z[2];
        int step;
    };
    struct p queue[1000000];
    struct p now;
    int directions[4][2]={{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
    vector <int> hashlist[hashsize];
    void read(); //读入数据
    struct p move(struct p a, int x, int y, int step);//移动局面
    int cheak(struct p now);//将局面转换成数
    int hash(int x);//hash函数
    int in(struct p a);//判重
    int main()
    {
        read();
        int tail = 1;
        for (int i = 0; i < tail; ++i) //bfs
        {
            if (cheak(queue[i])==123804765)
            {
                printf("%d", queue[i].step);
                return 0;
            }
            for (int j=0;j<4;++j)
            {
                now=move(queue[i], directions[j][0], directions[j][1], queue[i].step);
                if (now.step>=0&&in(now)==0)
                {
                    hashlist[hash(cheak(now))].push_back(cheak(now));
                    queue[tail]=now;
                    tail++;
                }
            }
        }
        return 0;
    }
    int hash(int x)
    {
        return x%hashsize;
    }
    int in(struct p a)
    {
        int k = cheak(a);
        int h=hash(k);
        for (int i = 0; i < hashlist[h].size(); ++i)
        {
            if (hashlist[h][i]==k) return 1;
        }
        return 0;
    }
    struct p move(struct p a, int x, int y, int step)
    {
        struct p n;
        if (a.z[0]+x<0||a.z[0]+x>2||a.z[1]+y<0||a.z[1]+y>2)
        {
            n.step=-1;
            return n;
        }
        n.step=step+1;
        n.z[0]=a.z[0]+x;
        n.z[1]=a.z[1]+y;
        for (int i = 0; i < 3; ++i)
        {
            for (int j = 0; j < 3; ++j)
            {
                n.map[i][j]=a.map[i][j];
            }
        }
        swap(n.map[a.z[0]][a.z[1]],n.map[n.z[0]][n.z[1]]); 
        return n;
    }
    int cheak(struct p now)
    {
        int k = 0;
        for (int i = 0; i < 9; ++i)
        {
            k=k*10;
            k+=now.map[i/3][i%3];
        }
        return k;
    }
    void read()
    {
        char n[10];
        scanf("%s", n);
        for (int i = 0; i < strlen(n); ++i)
        {
            queue[0].map[i/3][i%3]=n[i]-'0';
            if (n[i]-'0'==0) {queue[0].z[0]=i/3; queue[0].z[1]=i%3;}
        }
        queue[0].step=0;
        hashlist[hash(cheak(queue[0]))].push_back(cheak(queue[0]));
        return;
    }

```

---

## 作者：BeautyYu言醴 (赞：0)

本来是想拿这个题来练习双向bfs的 结果一开始连朴素写法都写不出来

终于坎坷地打完代码 所以来发个题解

**双向bfs+map判重**

如果不加双向会t一个点 加完就能ac

代码比较丑 大家将就看看吧

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <algorithm>
#include <queue>
#include <map>//个人惯用的头文件
using namespace std;
struct xxx{
    string str;
    short i;
};//i表示0在串中的位置
bool check(int i,int d){//d是0移动的方向 详见下方dic数组
    if((i + d > 8)||(i + d < 0)) return 0;
    if((i % 3 == 0)&&(d == -1)) return 0;
    if((i % 3 == 2)&&(d == 1)) return 0;
    return 1;
}//分别判断0的位置进行变化后是否合法 
int dic[4] = {1,-1,3,-3};//0变化的四种方向
map <string,int> m1,m2;
queue <xxx> q1,q2;//两个队列和map别用于两个bfs方向
xxx st,ed;//起始和终止状态存储
int c,c1 = 1,c2 = 1,cc = 0;//分别表示计数器、当前层级正方向的状态总数、当前层级负方向的状态总数、当前层级
int bfs(){
    while (!q1.empty()){
        ++ cc;//更新当前层级
        xxx lx,x;//lx用于取出队首 x用于变化操作

        c = c1;
        c1 = 0;
        for (int i = 1;i <= c;++ i){//遍历当前层级正方向的所有状态
            lx = q1.front();q1.pop();//取队头

            for (int z = 0;z < 4;++ z){//四种移动方向
                x = lx;//重置x
                int d = dic[z];
                if(!check(x.i,d)) continue;//判断移动是否合法
                swap(x.str[x.i],x.str[x.i + d]);
                x.i += d;//更新x的状态

                if (m1[x.str]) continue;
                q1.push(x);m1[x.str] = 1;++ c1;//判断是否重复 不重复时将新状态存入队 且更新c1

                if (m2[x.str]) return cc * 2 - 1;//判断是否在上一层的反方向上出现过该状态 有则返回（当前层级+上一层层级）（即cc*2 - 1）
            }
        }
        //-------------------------------以下是反方向的处理 与正方向相同
        c = c2;
        c2 = 0;
        for (int i = 1;i <= c;++ i){
            lx = q2.front();q2.pop();

            for (int z = 0;z < 4;++ z){
                x = lx;
                int d = dic[z];
                if(!check(x.i,d)) continue;
                swap(x.str[x.i],x.str[x.i + d]);
                x.i += d;

                if (m2[x.str]) continue;
                q2.push(x);m2[x.str] = 1;++ c2;

                if (m1[x.str]) return cc * 2;//这里应为判断同层级的正方向是否出现过该状态 有则返回（当前层级+当前层级）
            }
        }
    }
}
int main (){
    cin >> st.str;
    for (int i = 0;i < 9;++ i){
            if(st.str[i] == '0')    st.i = i;
    }//读入 处理0的位置
    ed = (xxx){"123804765",4};
    q1.push(st);m1[st.str] = 1;
    q2.push(ed);m2[st.str] = 1;//初始化
    if(st == ed){
        printf("0");
        return 0;
    }//特判是否只有一个状态
    printf("%d",bfs());//进入bfs
    return 0;
}

```

---

## 作者：Mashiro_ylb (赞：0)

#双向BFS + 哈希判重

这是一道公认的练习BFS的经典题

如果普通的BFS写得好的话也可以过这道题，但是由于这道题满足从结束状态反向扩展的条件，所以我选择了更省时也更省空间的

##双向BFS   ヽ(￣▽￣)ﾉ


判重也选择了比map等STL更省时的

##哈希判重    ￣ω￣=


在实现时应注意可以使用占空间较小的一维状态存储到队列中，进行状态转移时先将小状态转化成易于操作但占空间较大的二维状态，转移完成再转化成易于存储的一维状态存入队列（当然dalao们也可以直接对一维状态进行转移，不过笔者觉得有些麻烦且不直观）。

进行哈希判重是为了减小判重数组占用空间；众所周知，如果用于取模的质数不够大，则可能会产生哈希冲突；但取模的质数过大则需开更大的判重数组，与原意相悖。所以笔者采用了双哈希判重，这样可以有效降低哈希冲突的概率（也可以采用三哈希甚至四哈希判重，四哈希判重的哈希冲突概率几乎可以忽略不计）。

详情请见代码。

代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
using namespace std;

const int HASH = 10007;
const int HASH2 = 10037;
int head1 = 0, head2 = 0;
int tail1 = 1, tail2 = 1;
int pan1[2][10039];
int pan2[2][10039];
const int mubiao = 123804765 % HASH;
int map1[3][3];
int map2[3][3] = {{1, 2, 3}, {8, 0, 4}, {7, 6, 5}};
int dx[5] = {0, 1, -1, 0, 0};
int dy[5] = {0, 0, 0, 1, -1};
struct duilie
{
    int heap;
    int step;                 //用于记录BFS的层数
};
duilie a1[87390];      //用于BFS的两个队列
duilie a2[87390];
int x1, x2;   //一系列的x,y用于转移状态
int y1, y2;
int linshi;
int lx1, ly1, lx2, ly2;
int ans1 = 0;
int ans2 = 0;

template<class T>void read(T &x) //读入优化（本题不用读入和输出优化，使用仅为笔者习惯）（这份读入优化比世上所熟知的那个更快一些，也许吧）
{
    int f = 0; x = 0; char ch = getchar();
    while(ch < '0' || ch > '9') f |= (ch == '-'), ch = getchar();
    while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    x = f? -x : x;
}
void write(int x)   //输出优化
{
    if(x < 0) {putchar('-'); x = -x;}
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

void chuli(int aa[3][3], int b, int &x, int &y)  // 把用9位数存储的状态展开为二维平面状态并记录当前0的位置，这样可以方便BFS中状态的转移
{
    for(int i = 2; i >= 0; i--)
      for(int j = 2; j >= 0; j--)
        {
            aa[i][j] = b % 10;
            if(aa[i][j] == 0)
              {
                  x = i;
                  y = j;
              }
            b /= 10;
        }
}

int chuli2(int aa[3][3])  //把二维平面的数据状态转化为9位数的一维数据状态，方便状态在BFS队列中的存储
{
    int x = 0;
    for(int i = 0; i <= 2; i++)
      for(int j = 0; j <= 2; j++)
        {
            x = x * 10 + aa[i][j];
        }
    return x;
}
void change(int &a, int &b){int c = a; a = b; b = c;}  //用于交换值的函数（笔者习惯手写某些STL）

void bfs()
{
    
    do    //BFS
      {
          head1++;head2++;  //队首指针
          chuli(map1, a1[head1].heap , x1, y1);  //把压缩成9位数的一维状态转化为易于处理的二维平面状态
          chuli(map2, a2[head2].heap , x2, y2);
          for(int i = 1; i <= 4; i++)    //0可以向4个方向移动（正向BFS）
            {
                  lx1 = x1 + dx[i]; ly1 = y1 + dy[i];  //0位置的移动
                  if(lx1 >= 0 && lx1 <= 2 && ly1 <= 2 && ly1 >= 0)  //满足转移条件
                    {
                          change(map1[lx1][ly1], map1[x1][y1]);  //交换二维平面上0初始位置与移动后位置上的值                         
                          linshi = chuli2(map1);  //把二维平面状态下的数据转化为易于存储的9位数一维数据
                          if(pan1[0][linshi % HASH] == 0 || pan1[1][linshi % HASH2] == 0)  //利用哈希判断这个状态是否在之前出现过，若否，则存储
                            {
                                  tail1++;  //尾指针++
                                  a1[tail1].heap = linshi;  //存入状态
                                  a1[tail1].step = a1[head1].step + 1;  //记录当前BFS结点扩展层数
                                  pan1[0][linshi % HASH] = 1;  //记录该状态哈希值
                                  pan1[1][linshi % HASH2] = 1;  //双哈希以排除哈希冲突
                                  
                            }
                          if(pan2[0][linshi % HASH] == 1 && pan2[1][linshi % HASH2] == 1)  //如果在反向BFS存在现在这种状态，则表明已经找到答案，所以输出答案并终止程序
                            {
                                for(int i = 1; i <= tail2; i++)  //寻找正向BFS与反向BFS发生状态重复时反向BFS的扩展层数
                                    {
                                      if(a2[i].heap == linshi)
                                        {
                                          int ans = a2[i].step + a1[tail1].step;  //计算答案
                                          write(ans);  //输出答案
                                          exit(0);  //直接干净利索不带一丝迟疑的结束程序
                                        }
                                  }
                            }
                         change(map1[lx1][ly1], map1[x1][y1]);  //由于在下一次计算中还要用到这个二维数据，所以把刚才换掉的再换回来
                    }
                    
                  lx2 = x2 + dx[i]; ly2 = y2 + dy[i];
                  if(lx2 >= 0 && lx2 <= 2 && ly2 <= 2 && ly2 >= 0)  //反向BFS从终止状态开始扩展，主体与正向大致相同，变量和终止条件换换即可
                    {
                          change(map2[lx2][ly2], map2[x2][y2]);
                          linshi = chuli2(map2);
                          if(pan2[0][linshi % HASH] == 0 || pan2[1][linshi % HASH2] == 0)
                            {
                                  tail2++;
                                  a2[tail2].heap = linshi;
                                  a2[tail2].step = a2[head2].step + 1;
                                  pan2[0][linshi % HASH] = 1;
                                  pan2[1][linshi % HASH2] = 1;
                                  
                                  
                            }
                            if(pan1[0][linshi % HASH] == 1 && pan1[1][linshi % HASH2] == 1)
                            {
                                for(int i = 1; i <= tail1; i++)
                                    {
                                      if(a1[i].heap == linshi)
                                        {
                                          int ans = a2[tail2].step + a1[i].step;
                                          write(ans);
                                            exit(0);
                                        }
                                  }
                            }
                          change(map2[lx2][ly2], map2[x2][y2]);
                }
          }
      }while(head1 < tail1 || head2 < tail2);
}


int main()
{
    a1[1].step = 0;  //初始扩展层数记为0
    a2[1].step = 0; 
    int a;
    read(a);  //由题意输入起始状态
    a1[1].heap = a;  //初始状态
    a2[1].heap = 123804765;  //终止状态
    chuli(map1, a, x1, y1);
    bfs();
    return 0;
}
```

---

## 作者：asuldb (赞：0)

```cpp
//经典的bfs，难点在于去重 
//楼下的大佬们方法多种多样，什么康托展开完全没听说过 
//有用map去重的，那么为什么不用set呢 
//于是我就用set来水一波 
//还是有些慢，主站会t掉一个点，大牛可以A 
//还是上代码吧 
#include<iostream>
#include<queue>
#include<set>//set要用到的头文件 
#include<cstdio>
#include<string>
using namespace std;
const int dx[4]={-1,-3,1,3};//四向移动，不过一些边界问题在bfs里再特判 
const string ds="123804765";
struct node
{
    string s;
    int step,z;//step表示当前步数，z记录0的位置 
}start,mid;
string st;
bool check(int q,int h)
{
    if(h<0||h>8) return false;
    if(q==3&&h==2) return false;
    if(q==2&&h==3) return false;
    if(q==5&&h==6) return false;
    if(q==6&&h==5) return false;//一些边界的特殊情况 
    return true;
}
void bfs()
{
    queue<node> q;
    set<string> vis;//定义一个string型的set，用于去重 
    vis.insert(start.s);
    q.push(start);
    while(!q.empty())//如果队列非空 
    {
        mid=q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int xx=mid.z+dx[i];
            string ss=mid.s;
            int l=vis.size();//记录当前set内的元素个数 
            if(!check(mid.z,xx)) continue;//转移不合法，就continue掉 
            swap(ss[mid.z],ss[xx]);//交换得到新状态 
            if(ss==ds)
            {
                cout<<mid.step+1<<endl;
                return;
            }
            vis.insert(ss);//把新状态丢进set里 
            if(vis.size()==l+1)//因为set没有重复元素，所以如果此时set的元素个数加1，说明这个新状态以前没有得到过 
            {
                node c;
                c.s=ss;
                c.z=xx;
                c.step=mid.step+1;
                q.push(c);//让新状态入队 
            }
        }
    }
}
int main()
{
    cin>>st;
    if(st==ds)
    {
        cout<<"0"<<endl;
        return 0;//特判，如果读进来就是目标状态，输出0退出就好了 
    }
    start.s=st;
    for(int i=0;i<9;i++)
    if(st[i]=='0')
    {
        start.z=i;
        break;//记录初始状态0的位置 
    }    
    start.step=0;
    bfs();
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：0)

提供一个最朴素算法，大概是主过程长度最短的了

好像没什么好解释的吧…

map判重，所以比较慢，在大牛才能过啧

```cpp
#include<map>
#include<queue>
#include<string>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define final "123804765"
#define up pos-3
#define down pos+3
#define left pos-1
#define right pos+1
#define reg register
using namespace std;
struct node{string a;int s,loc;}; //a是当前数码的状态，s是当前答案，loc是当前0的位置 
string s;
map<string,bool>able;
queue<node>q;
int ans=2147483647;
int main()
{
    cin>>s;
    reg int loc=find(s.begin(),s.end(),48)-s.begin();  //用find找0的位置 
    q.push((node){s,0,loc});
    while (q.size())
    {
        reg string a=q.front().a,b=a;
        reg int pos=q.front().loc,now=q.front().s;
        q.pop();
        if (now>=ans)continue; //如果当前答案已经超过当前最优答案了，那么就没有继续的必要性了 
        if (a==final){ans=now;continue;}  //更新答案 
        if (able[a])continue;able[a]=1; //判重 
        if (pos>2)swap(a[up],a[pos]),q.push((node){a,now+1,up});a=b; //上面移下来 
        if (pos<6)swap(a[down],a[pos]),q.push((node){a,now+1,down});a=b;  //下面移上来 
        if (pos!=0&&pos!=3&&pos!=6)swap(a[left],a[pos]),q.push((node){a,now+1,left});a=b;  //左边移过来 
        if (pos!=2&&pos!=5&&pos!=8)swap(a[right],a[pos]),q.push((node){a,now+1,right});  //右边移回去 
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：ironwheel (赞：0)

看下面那么多康托展开的，蒟蒻表示完全不懂……

研究了一下午，自学了没学过的map语句……

思路：广搜，然后把矩阵中的数字转成字符串（矩阵每一种状态都有不同的字符串表示），通过map映射，如果之前有过（映射的数字为1）则当前坐标出队，否则将当前字符串映射的数字改为1，省下了时间，也省下了空间，如果单纯广搜，只有7分，其他的都是TLE或者MLE！！！

map大法好！！！

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<map>//头文件 
using namespace std;
short b[5000000][4],a[5000000][4][4],x[4]={0,0,1,-1},y[4]={1,-1,0,0};//为了节省空间，才用的short定义数组（反正数不大） 
char s; 
string cs=" ";//一个很有用的字符串，在下面广搜程序里也会说到 
int bfs(){//简朴的广搜，map优化…… 
    map<string,int> gd;//用map定义gd 
    register int head=0,foot=1,xx,yy,k;//为了提升速度，只好用register 
    b[1][3]=1;
    do{
        head++;
        for(register int i=0;i<4;i++){
            xx=b[head][1]+x[i];yy=b[head][2]+y[i];
            if((xx>=1)&&(xx<=3)&&(yy>=1)&&(yy<=3)){//如果符合条件 
                foot++;
                b[foot][1]=xx;b[foot][2]=yy;b[foot][3]=b[head][3]+1;//坐标xx和yy进队，累加步数 
                for(register int j=1;j<=3;j++){
                    for(register int q=1;q<=3;q++){
                        a[foot][j][q]=a[head][j][q];//copy一个副本，用来交换 
                    }
                }
                //-------------------主要部分分界线------------------------ 
                cs=" ";//重置cs字符串 
                swap(a[foot][b[head][1]][b[head][2]],a[foot][xx][yy]);//将0和另一个搜索到的数交换 
                cs+=(char)a[foot][1][1]+'A';cs+=(char)a[foot][1][2]+'A';cs+=(char)a[foot][1][3]+'A';cs+=(char)a[foot][2][1]+'A';cs+=(char)a[foot][2][2]+'A';//创造字符串 
                cs+=(char)a[foot][2][3]+'A';cs+=(char)a[foot][3][1]+'A';cs+=(char)a[foot][3][2]+'A';cs+=(char)a[foot][3][3]+'A';//为下面map判断作准备 
                if(gd[cs]){foot--;continue;}//如果字符串cs映射的整数为1（也就是重复）队头出队，直接结束本次循环，进入下一次循环 
                gd[cs]=1;//如果不重复，将cs映射的整数置为1 
                if(a[foot][1][1]==1&&a[foot][1][2]==2&&a[foot][1][3]==3&&a[foot][2][3]==4&&a[foot][3][3]==5&&a[foot][3][2]==6&&a[foot][3][1]==7&&a[foot][2][1]==8){return b[head][3];}//如果符合题目要求，输出步数 
                //-------------------主要部分结束-------------------------- 
            }
        }
    }while(head<foot); 
    return 0;
}
int main(){
    for(register int i=1;i<=3;i++){
        for(register int j=1;j<=3;j++){
            cin>>s;//字符读入 
            a[1][i][j]=s-'0';//转换成数字，存入三维数组 
            if(a[1][i][j]==0){
                b[1][1]=i;b[1][2]=j;//寻找0的位置，进入队列 
            }
        }
    }
    cout<<bfs();//广搜大法 
}
```

---

## 作者：Mychael (赞：0)

经典的八数码难题

**双向bfs+康托展开+康托逆展开**

双向bfs：

从起始和结束状态开始搜索，每次选择搜索次数最少的那一边往下搜，直至相遇为止，把步数相加即为答案


康托展开&康托逆展开：

<http://blog.csdn.net/qq\_38678604/article/details/77413715>博客链接

简而言之，就是计算一个排列的排名与利用排名计算排列

为什么要这么做呢？

因为如果直接将一个9位数作为每个状态的下表，显然会MLE，但实际上9个数的排列只有9！约等于36w中状态，所以利用康托展开我们只用开40w的数组就不重复地表示出了一个排列


所以就这样吧：











```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cctype>
#include<algorithm>
using namespace std;
const int maxn=1000005,INF=2000000000;
typedef int state[9];
int d[maxn],vis[maxn],fac[10],label[10];
void cal(){              //快速读入
    fac[0]=1;
    for(int i=1;i<=9;i++) fac[i]=fac[i-1]*i;
}
int code(state a){      //康托展开
    int ans=0;
    for(int i=0;i<=9;i++) label[i]=1;
    for(int i=0;i<9;i++){
        int cnt=0;
        for(int j=0;j<a[i];j++) if(label[j]) cnt++;
        label[a[i]]=0;
        ans+=cnt*fac[8-i];
    }
    return ans;
}
state n;
void codel(int x){     //康托逆展开
    int cnt;
    for(int i=0;i<9;i++) label[i]=1;
    for(int i=0;i<9;i++){
        cnt=x/fac[8-i];
        x=x%fac[8-i];
        for(int j=0;j<9;j++){
            if(!label[j]) continue;
            if(!cnt) {label[j]=0;n[i]=j;break;}
            cnt--;
        }
    }
}
state ori={1,2,3,8,0,4,7,6,5},S;
int aim,ans=0,X[4]={0,0,-1,1},Y[4]={-1,1,0,0};
void bfs(){          //双向广搜
    queue<int> q[2];
    int cnt[2],s,u,v,x,y,nx,ny;
    cnt[0]=cnt[1]=0;
    u=code(S);
    q[0].push(u);
    q[1].push(aim);
    vis[u]=1;vis[aim]=2;
    while(true){
        s=(cnt[0]>cnt[1]);   //选择搜索次数最少的那个搜
        cnt[s]++;
        u=q[s].front();
        q[s].pop();
        codel(u);
        for(int i=0;i<9;i++) if(!n[i]) {x=i/3;y=i%3;break;}
        for(int i=0;i<4;i++){
            nx=x+X[i];
            ny=y+Y[i];
            if(nx<0||nx>2||ny<0||ny>2) continue;
            swap(n[3*nx+ny],n[3*x+y]);
            v=code(n);
            if(!vis[v]){
                q[s].push(v);
                d[v]=d[u]+1;
                vis[v]=s+1;
            }
            else if(vis[v]==(s^1)+1) {ans=d[u]+d[v]+1;return;}
            swap(n[3*nx+ny],n[3*x+y]);
        }
    }
}
int main()
{
    cal();
    aim=code(ori);
    char c;
    for(int i=0;i<9;i++){
        c=getchar();
        while(!isdigit(c)) c=getchar();
        S[i]=c-'0';
    }
    bfs();
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：Sino_E (赞：0)

IDA\*？A\*？康托展开？不，都不用。

直接每个状态开9进制数（也不会超int）然后取模一下丢到hash表里判个重....

状态最多也就30多W种，完全不用担心超时。

最后再来个最经典的BFS....过了....

本题的重点就在于判重。以及代码量可能有点小大，细心点就不会错啦~

（其实并不难的呀XD）

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int s[3][3],e[3][3]={{1,2,3},{8,0,4},{7,6,5}},ee;//初始状态、最终状态、最终状态转int 
const int MOD=1e6+13,N=370000;
int h[MOD],val[N],nexp[N],p=1;//链式前向星，Hash用 
inline int blo2int(int x[][3]){
    int ret=0;
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            ret*=9,ret+=x[i][j];
    return ret;
}//矩阵转int 
inline void int2blo(int x,int y[][3]){
    for(int i=2;i>=0;i--)
        for(int j=2;j>=0;j--)
            y[i][j]=x%9,x/=9;
}//int转矩阵 
inline bool insHash(int c){
    int d=c%MOD;
    for(int u=h[d];u;u=nexp[u]){
        if(val[u]==c)return 0;
    }
    nexp[p]=h[d],h[d]=p,val[p]=c,p++;
    return 1;
}//丢进Hash表判重 
struct Que{
    int con,x,y,ste;//当前状态（转成了int的矩阵）、0点的坐标、步数 
};//队列结构 
inline bool valid(int x,int y){return x>=0&&x<3&&y>=0&&y<3;}//判断坐标是否合法 

int mv[]={0,1,0,-1,0};//坐标转移 
int main(){
    ee=blo2int(e);//把目标状态变成进制数 
    int sx,sy;
    char ch;
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++){
            cin>>ch;
            s[i][j]=ch-'0';
            if(!s[i][j])
                sx=i,sy=j;
        }//输入 
    queue<Que> qu;//队列 
    insHash(blo2int(s));
    qu.push((Que){blo2int(s),sx,sy,0});
    Que na;
    int nx,ny,ns;
    /*标准BFS*/ 
    while(!qu.empty()){
        na=qu.front(),qu.pop();
        int2blo(na.con,s);
        /*状态转移*/ 
        for(int i=1;i<=4;i++){
            nx=na.x+mv[i-1],ny=na.y+mv[i];
            if(valid(nx,ny)){
                swap(s[nx][ny],s[na.x][na.y]);
                ns=blo2int(s);
                if(ns==ee){//若达到目标状态 
                    printf("%d",na.ste+1);
                    return 0;
                }
                if(insHash(ns))qu.push((Que){ns,nx,ny,na.ste+1});
                swap(s[nx][ny],s[na.x][na.y]);//记得还原 
            }
        }
    }
    printf("no solution");//若无解（题目无无解情况） 
    return 0;
}
```

---

## 作者：shijunfeng00 (赞：0)

这道题细节容易错

虽然深度优先算法

但是在逻辑方面还是很不同呀

我说说我的思路

先把初始状态入队

然后while(!q.empty()){}

循环所有可延伸的状态

如何符合条件,入队

不符合,跳过

循环结束,该节点出队

要么搜到答案,输出并return

要么直到队列为空,找不到答案

以下是我朴素的纯bfs，，看变量名字应该就知道用途吧,,注释有点少,见谅

```cpp
#include<iostream>
#include<queue>
#include<cstring>
class node{public:int x,y,step,a[10];}s;    空格位置为(x,y),当前步数step,a[10]储存顺序
std::queue<node>q;
int book[526888],f[]={1,1,2,6,24,120,720,5040,40320,326880},cannot_use_next[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
using namespace std;
int inline expansion(int*a)
{
    int ans=0;
    for(int i=0;i<9;i++)
    {
        int tmp=0;
        for(int j=i+1;j<9;j++)
            if(a[i]>a[j])tmp++;
        ans+=tmp*f[8-i];
    }
    return ans;
}
int main()
{
    char temp_start[10];                            //temp_abc前缀代表abc预处理用的临时变量 
    int temp_end[]={1,2,3,8,0,4,7,6,5};
    int end=expansion(temp_end);
    cin>>temp_start;
    for(int i=0;i<9;i++)s.a[i]=temp_start[i]-'0';
    for(int i=1;i<9;i++)
    {
        if(s.a[i]==0)
        {
            s.x=i%3;
            s.y=i/3;
            s.step=0;
            break;                                         //找到空格位置 
        }
    }
    q.push(s);
    book[expansion(s.a)]=1;        //标记,康拓展开
    node temp,now_head;      /队首元素
    while(!q.empty())
    {
        int blank=q.front().x+q.front().y*3; 
        now_head=q.front();                              //当前节点的空格位置 
        for(int i=0;i<4;i++)                              //遍历四个方向 
        {
            temp=now_head;
            int tx=q.front().x+cannot_use_next[i][0];
            int ty=q.front().y+cannot_use_next[i][1];
            if(tx>=0&&tx<=2&&ty>=0&&ty<=2)
            {        //出界则跳 
                int newblank=tx+ty*3;     //四个方向遍历新空格位置 
                temp.a[blank]=temp.a[newblank];
                temp.a[newblank]=0;
                temp.step=q.front().step+1; 
                if(expansion(temp.a)==end)
                {
                    cout<<temp.step;
                    return 0;
                }
                if(book[expansion(temp.a)]==0)
                {
                    book[expansion(temp.a)]=1;
                    temp.x=tx;temp.y=ty;
                    q.push(temp);
                }
            }
        }
        q.pop();                                              //用完pop掉 
    }
}

```

---

## 作者：TBB_Nozomi (赞：0)

emmmm经典问题大讨论.jpg

虽然我不知道康托展开是什么但是不影响我用bfs啊（

在这个题里面，我认为比较经典的解法还是双向bfs，A\*如果估值函数没写好会造成部分点错误

但是为了方便表示，我们还是需要一个数，用于代替整个表的状态，而且要能够使得这个状态数与整个表产生一一对应的关系。

我下意识想到的就是九进制（），以下把这个数就叫做 位置数。

考虑整个表的总状态数为181440，而最大步数只有30，那么考虑双向bfs时只用15步的限制即可

代码地址：http://paste.ubuntu.com/25162981/

为了优化又优化，我单独做了一点处理……大概在IDE上那些30步的状态能用接近30ms解决掉（应该没有O2），绰绰有余


重点分析：

```cpp
queue<u32>    qu;
queue< pair<u32,int> >    requ;
vector< vector< pair<u32,int> > >    hash_step,rehash_step;
const u32 MOD=10009;
```
这部分分别qu和requ区分bfs和rebfs使用的队列，requ的部分直接以<u32,int>为单位，有效的快速提取出对应的状态数的步数

对每一个bfs过程中的状态，将它的位置数和步数组合起来，对位置数关于质数MOD求余，也就是得到了hash过后的表的位置塞进去

rehash\_step同理，不过不需要记录步数就是了，这里进行区分只是为了防止重复走入同一个状态


```cpp
u32 calc(const vector<int> &in)
vector<int>    recalc(int in)
```
这两个函数，前一个将数的位置分布转化为位置数，后一个则相反

```cpp
int    zero(const vector<int> &in)
inline u32     calc_left(vector<int> in,int zero_pos)
inline u32     calc_right(vector<int> in,int zero_pos)
inline u32     calc_up(vector<int> in,int zero_pos)
inline u32     calc_down(vector<int> in,int zero_pos)
```
前一个函数计算该状态下0的位置，后面四个将0进行移动并返回其位置数

```cpp
vector< pair<u32,int> >::iterator     ser(u32 ha_in)
vector< pair<u32,int> >::iterator     reser(u32 ha_in)
```
传入位置数，返回在hash表和rehash表中的迭代器。这两函数用于在bfs和rebfs中查重以及是否可以构成完整的变换路径，也是MITM的重点

```cpp
void bfs(int lim)
void rebfs(int lim)
```
使用lim限制bfs的步数

```cpp
pair<u32,int>    pa=requ.front();    
        vector< pair<u32,int> >::iterator    iter=ser(pa.first);
        if(iter!=hash_step[pa.first%MOD].end())    {
            cout<<iter->second+pa.second<<endl;
            exit(0);
        }

        vector<int>    ve=recalc(pa.first);
        int zero_pos=zero(ve);

if(pa.second>lim)    break;
        requ.pop();
```
这是rebfs的部分，前面的if用于判断此时在bfs产生的表中是否有已经走过的状态存在，如果存在则立刻判断此时步数最短并且立刻退出。zero\_pos记录此时的0的位置。后面的if使得队列中状态数超过限制时不弹出队首而是停下不再搜索

```cpp
int be_pos[9]={1,2,3,8,0,4,7,6,5};
    int en_pos[9];
    char in[10];
    scanf("%s",in);
    hash_step.resize(MOD);
    rehash_step.resize(MOD);
    for(int i=0;i<9;i++)    en_pos[i]=in[i]-'0';
    vector<int> be_ve(&be_pos[0],&be_pos[9]);
    vector<int>    en_ve(&en_pos[0],&en_pos[9]);
    int hash_be_ve=calc(be_ve);
    int hash_en_ve=calc(en_ve);
    hash_step[hash_be_ve%MOD].push_back(pair<u32,int>(hash_be_ve,0));
    qu.push(hash_be_ve);
    requ.push(pair<u32,int>(hash_en_ve,0));
    rehash_step[hash_en_ve%MOD].push_back(pair<u32,int>(hash_en_ve,0));
```
初始化，转换输入的字符串为对应的状态。顺便将hash的两个表设置为对应的MOD大小防止出错

```cpp
for(limts=0;limts<15;limts++)    {
        bfs(limts);
        rebfs(limts);
    }
```
双端出发并同时限制步数以达到最小搜索量

EOF.

---

## 作者：租酥雨 (赞：0)

八数码问题是一道很经典的搜索题，方法自然也很多，这里讲一下双向广搜。

双向广搜就是从初始节点和目标节点同时向外扩展，根据广搜的特点，得到的第一个相同节点就是最短路径中的一个节点，从而得解。至于双向广搜和广搜的效率比较，本人并没有去专门研究究竟可以快多少倍，但是事实证明就是快好多好多。

打双向广搜，我们就需要开两个队列，h[0]和h[1]，开在同一个数组里面，是为了方便调用。下面放一个简单的双向广搜模板：

```cpp
while (head[0]<tail[0]&&head[1]<tail[1])
    {
        if (tail[0]<=tail[1])
          double_BFS(0);
        else double_BFS(1);
    }
```
可以看出双向广搜优先扩展节点少的一端，一般情况下都是两个队列轮番扩展，从而加快求解速度。在输入数据预处理时，我们就要把初始节点和目标节点分别入队。
还有一个问题就是判重。康托展开是这道题的很好的判重方法，在双向广搜中，只需要与同一队列里的元素进行判重！那么我们就要开两个用于判重的bool型数组vis[0]，vis[1]，分别表示某一队列是否扩展到了该节点。这么来说，搜到正解的条件就变成了：有一个节点同时被两边访问过，即该节点在两个vis数组中均为1。那么我们在每访问到一个新节点时就做如上判断，就可以在第一时间找到正解并输出了。


其实这个双向的BFS是在原有的朴素BFS的基础上修改的，BFS跑了3000多ms，双向BFS硬是跑进了100ms，可以说效率有了很大的提升。


双向BFS：







    
    

```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
using namespace std;
int biao[]={1,1,2,6,24,120,720,5040,40320};
char c[10];
int temp[10];
bool vis[2][500000];
int h[2][500000][10];
int g[2][500000];
int head[2],tail[2]={1,1};
bool key;
int cantor(int a[10])
{
    int sum=0;
    for (int i=1;i<=9;i++)
    {
        int s=0;
        for (int j=i+1;j<=9;j++)
          if (a[j]<a[i]) s++;
        sum+=s*biao[9-i];
    }
    return sum;
}
void check(int num)
{
    if (vis[0][num]==1&&vis[1][num]==1)
    {
        printf("%d",g[0][num]+g[1][num]);
        key=1;
    }
}
bool move(int s[10],int i)
{
    int p;
    int a[10];
    for (int k=1;k<=9;k++)
    {
        a[k]=s[k];
        if (a[k]==0) p=k;
    }
    if (i==1)
    {
        if (p>=1&&p<=3) return false;
        swap(a[p],a[p-3]);
    }
    if (i==2)
    {
        if (p>=7&&p<=9) return false;
        swap(a[p],a[p+3]);
    }
    if (i==3)
    {
        if (p%3==1) return false;
        swap(a[p],a[p-1]);
    }
    if (i==4)
    {
        if (p%3==0) return false;
        swap(a[p],a[p+1]);
    }
    for (int k=1;k<=9;k++)
      temp[k]=a[k];
    return true;
}
void double_BFS(int x)
{
    head[x]++;
    int num_head=cantor(h[x][head[x]]);
    for (int i=1;i<=4;i++)
    {
        memset(temp,0,sizeof(temp));
        if ( move(h[x][head[x]],i)==false ) continue;//如果不能向这个方向移动 
        int num=cantor(temp);
        if ( vis[x][num]==1 ) continue;//判重
        tail[x]++;
        for (int k=1;k<=9;k++)
            h[x][tail[x]][k]=temp[k];
        vis[x][num]=1;
        g[x][num]=g[x][num_head]+1;
        check(num);
        if (key) return;
    }
}
int main()
{
    //freopen("eight.in","r",stdin);
    scanf("%s",c);
    for (int i=1;i<=9;i++)
      h[0][1][i]=c[i-1]-'0';
    h[1][1][1]=1;h[1][1][2]=2;h[1][1][3]=3;
    h[1][1][4]=8;h[1][1][5]=0;h[1][1][6]=4;
    h[1][1][7]=7;h[1][1][8]=6;h[1][1][9]=5;
    vis[0][cantor(h[0][1])]=1;vis[1][131976]=1;
    while (head[0]<tail[0]&&head[1]<tail[1])
    {
        if (tail[0]<=tail[1])
          double_BFS(0);
        else double_BFS(1);
        if (key) break;
    }
    return 0;
}
```
再放一个跑了3000多ms的单向BFS：




```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
using namespace std;
int biao[]={1,1,2,6,24,120,720,5040,40320};
char c[10];
int temp[10];
bool vis[500000];
int h[500000][10];
int g[500000];
int head,tail=1;
bool key;
int cantor(int a[10])
{
    int sum=0;
    for (int i=1;i<=9;i++)
    {
        int s=0;
        for (int j=i+1;j<=9;j++)
          if (a[j]<a[i]) s++;
        sum+=s*biao[9-i];
    }
    return sum;
}
bool move(int s[10],int i)
{
    int p;
    int a[10];
    for (int k=1;k<=9;k++)
    {
        a[k]=s[k];
        if (a[k]==0) p=k;
    }
    if (i==1)
    {
        if (p>=1&&p<=3) return false;
        swap(a[p],a[p-3]);
    }
    if (i==2)
    {
        if (p>=7&&p<=9) return false;
        swap(a[p],a[p+3]);
    }
    if (i==3)
    {
        if (p%3==1) return false;
        swap(a[p],a[p-1]);
    }
    if (i==4)
    {
        if (p%3==0) return false;
        swap(a[p],a[p+1]);
    }
    for (int k=1;k<=9;k++)
      temp[k]=a[k];
    return true;
}
int main()
{
    freopen("eight.in","r",stdin);
    scanf("%s",c);
    for (int i=1;i<=9;i++)
      h[1][i]=c[i-1]-'0';
    vis[cantor(h[1])]=1;
    while (head<tail)
    {
        head++;
        int num_head=cantor(h[head]);
        for (int i=1;i<=4;i++)
        {
            memset(temp,0,sizeof(temp));
            if ( move(h[head],i)==false ) continue;//如果不能向这个方向移动 
            int num=cantor(temp);
            if ( vis[num]==1 ) continue;//判重
            tail++;
            for (int k=1;k<=9;k++)
               h[tail][k]=temp[k];
            vis[num]=1;
            g[num]=g[num_head]+1;
            if (num==46685) 
            {
                printf("%d",g[num]);
                return 0;
            } 
        }
    }
}
虽说很多时候单向BFS就可以完美解决一个问题，但不得不说，对于追求速度更快，效率更高的OIer，双向BFS无疑是一个很好的选择。
```

---


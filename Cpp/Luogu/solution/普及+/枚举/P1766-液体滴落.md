# 液体滴落

## 题目描述

在平面中有若干线段 $L_i$（**不一定互不相交**），组成一个又一个轨道，有一滴液体从上方滴落下来，如果碰到轨道就沿着轨道向下滚，从轨道较低的一端离开轨道，在轨道中不受任何影响，否则就垂直滴落，问最后液滴从什么位置落出整个系统。

相信这个题目一定难不倒你。

## 说明/提示

对于 $50\%$ 的数据，$1\le n\le100$，$|x|,|y|,|S| \le500$；

对于 $100\%$ 的数据，$1\le n\le 10^5$，$|x|,|y|,|S|≤10^9$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gclp58tq.png)


## 样例 #1

### 输入

```
4 2
1 4 3 2
5 4 2 1
-2 -1 0 -2
-1 -3 4 -4```

### 输出

```
4```

# 题解

## 作者：Zhou_SY (赞：12)

考前来一波题解，rp++

从学校oj上来的，就改了几行代码。。。

本题算法：模拟+解析式

本题考点在于

# 已知一直线上两点$(x_1,y_1),(x2,y2)$，求此直线解析式（初一及以上学历可跳过）

解：不妨设（shé）此直线解析式为     
$$y=kx+b$$

代入两点坐标得

$$y_1=kx_1+b\quad(1)$$
$$y_2=kx_2+b\quad(2)$$

由$(1)$式减$(2)$式得
$$y_1-y_2=(x_1-x_2)k$$

于是
$$k=\frac{y_1-y_2}{x_1-x_2}$$

带入$(1)$式得
$$y_1=\frac{y_1-y_2}{x_1-x_2}x_1+b$$
$$∴b=y_1-\frac{y_1-y_2}{x_1-x_2}x_1$$
整理得
$$b=\frac{y_2x_1-y_1x_2}{x_1-x_2}$$

$$∴y=\frac{y_1-y_2}{x_1-x_2}x+\frac{y_2x_1-y_1x_2}{x_1-x_2}$$

话不多说上代码：

```cpp
#include<bits/stdc++.h>
#define CSP 0 
#define S_and_J_score_up 0
using namespace std;
int n;
double X,Y;//水滴的坐标
double x[3][10010];
double y[3][10010];//板子的坐标
int main()
{
	scanf("%d%lf",&n,&X);
	Y=1000000010;
    //假定水滴从最高的地方落下
    for(int i=1;i<=n;i++)scanf("%lf%lf%lf%lf",&x[1][i],&y[1][i],&x[2][i],&y[2][i]);
	
	while(1)
	{
		int l=0;
		double k=-1000000010;
		for(int i=1;i<=n;i++)
		if(Y>min(y[1][i],y[2][i])&&min(x[1][i],x[2][i])<=X&&X<=max(x[1][i],x[2][i]))
		{
			double YYY=(y[1][i]-y[2][i])/(x[1][i]-x[2][i])*X+(x[1][i]*y[2][i]-x[2][i]*y[1][i])/(x[1][i]-x[2][i]);
            //将X代入上面推出来的公式，算出坐标
			if(Y<=YYY)continue;//落不到
			if(YYY>k)//更新
			{
				l=i;
				k=YYY;
			}
		}
        /*
        这里是判断能不能落到一个板子上
        如果能就找最上面（y坐标最大）的一个
        公式推导见上
        */
		if(l==0)
        /*
        一块板子也没有接到
        那就输出
        */
		{
			printf("%.0lf\n",X);
			break;
		}
		else
        /*
        不然就落在板子上
        因为板子是斜的（显而易见）
        所以水滴就滚到了最下端（y坐标最小的那端）
        */
		{
			if(y[1][l]<y[2][l])
			{
				X=x[1][l];
				Y=y[1][l];
			}
			else
			{
				X=x[2][l];
				Y=y[2][l];
			}
		}
	}
	return CSP-S_and_J_score_up;
}
```


---

## 作者：B612Dusk (赞：9)

看了很多 $O(n^2)$ 的解法， 这里给大家一个 $O(n\sqrt{n})$ ，可能有一些纰漏， 望各位 $dalao$ 给予 $hack$ 数据， 蒟蒻将会 $update$ 更好的代码。

# 液体滴落

首先大家的方法大多都是模拟， 时间复杂度是 $O(n^2)$， ~~踹数据~~

按照正常的模拟， 肯定是氢氢松松卡一组数据， $10^5$ 个线段挨个来就会爆

那我们应该怎么优化呢？

我们先看一下我们的时间主要浪费在了哪里

“浪费在了那些八竿子打不着的边会大量重复运算”

也就是说， 我们不论是判断这条边是否有影响

还是实实在在地去算一条边 $x$ 时 $y$ 的值， 都存在无意义的重复运算， 会浪费时间

那么我们应该如何避免这样的时间的浪费呢？

# 分块
~~线段树似乎不太好做？也可能是我太弱辣~~

我们将线段的存入一个个的块。

1. 首先，考虑这条线段是否可能对我的液滴产生影响。

1. 然后， 我们考虑这条线段在 $x$ 时的高度， 进行一个擂台比大小，用  $pos$ 和 $py$ 分别记录下我们目前的 $x$ 时 , $y$ 小于下落时的高度 $h$ 并高于目前已知高度 $high$ 的点的 线段， 用 $pos$ 记录它下一次下落时的 $x$， 用 $py$ 记录它下落时的纵坐标 $y$。

我们将线段的左右端点的x值分别记为****分块前后排序的第一关键字和第二关键字****，左端点 $lx$ 从小到大拍，  $rx$ 从大到小排，后面给予解释。

这样子的好处是什么？

这样的话我们记录每个块的****左端 $lx$ 的最小值和每个块右端 $rx$ 的最大值****

先按照 $lx$ 从小到大排序， 分块， 然后在每个块的内部右端点 $rx$ 从大到小排序

这样的话就不需要每个块都扫描， 可以直接****二分****锁定扫描区间的范围，

预处理分块, 整体 $sort$ 和每个块内 $sort$ 的时间， 最高 $O(n \sqrt{n} )$.

我们用 $area_i$ 表示 $i$ 号在区间 $area_i$ 中 

 $X$ 表示初始下落坐标，$Ln_i$ 存储第 $i$ 块 $lx$ 最小值，  $Rx_i$  存储第 $i$ 块 $rx$ 最大值

把线段 $line$ 存入 $vector$ 中

```cpp
int n, X, area[N], len;
int Ln[N], Rx[N], pos, py;
struct line {
	int lx, ly, rx, ry, id;//左x， 左y， 右x， 右y， id用来打表查错
	double k, b;//斜率， 纵截距（就是和y轴交点）
}a[N]; 
vector<line>	vec[N];
bool sort_l(line a, line b) {
	return a.lx < b.lx;
}//lx从小到大排序
bool sort_r(line a, line b) {
	return a.rx > b.rx;
}//rx从大到小


//(for提前处理area[i])
sort(a + 1,a + n + 1, sort_l);//块外lx排序后分块
	for(reg int i = 1;i <= n;i ++) {
		vec[area[i]].push_back(a[i]);
		Ln[area[i]] = min(a[i].lx, Ln[area[i]]);//每个块lx最小值
		Rx[area[i]] = max(a[i].rx, Rx[area[i]]);//每个块rx最大值
	}
	for(reg int i = 1;i <= area[n];i ++)	
		sort(vec[i].begin(), vec[i].end(), sort_r);//块内rx排序
```

预处理完之后，我们开始考虑如何进行线段比大小

既然我们已经处理出来了每一块的**左端点最小和右端点最大**

那么对于目前的水滴 $x$ ， 如果左端点最小值大于 $x$ ， 右端点最大值小于 $x$ ，是不是就完全没有考虑的必要——根本碰不到

那么我们就可以进行二分查找出最大的符合要求的块 $blo$

核心：在 $1$ 到 $blo$ （因为我们的块第一关键字是左端点最小值，从小到大排， 所以 $1$ 块内的所有线段的 $lx$ 值都小于 $blo$ 中的线段的 $lx$ ）再一个一个枚举， 又因为我们内部按照右端点从大到小排序， 所以当我们搜索到第一个 $rx$  <  $x$ 的时候， 就可以 $break$ ——**本块后面的   $rx$ 只会 小于等于 前面的， 不会大于前面的**

我们用一个 $work$ 函数表示  **水滴从高度为 $h$ 的横坐标 $x$ 处掉落**

我们在找之前设一个擂台 $high$ ，初始值为极小值，在保证更新后的值小于 $h$ 的前提下取最大。

调用函数时设一个 $f = 0$ 表示 $pos$ 是否被更新过， 若更新过 $f = 1$ ，

 $work$ 结束时看 $f$ 是否为 $1$， 若为 $0$ 表示没有线段可以更新他了， 否则 $f = 1$。

重新调用 $work$ 再次求值

下面是 $work()$ 函数

```cpp
void work(int x, int h) {
	int high = -9999999999;//极小值
	int f = 0;//判断是否修改了pos 
	int blo = lower_bound(Ln + 1, Ln + area[n], x) - Ln;//二分查找到左端点最小大于x的。
	for(reg int i = 1;i <= blo;i ++) {
		for(reg int j = 0;j < vec[i].size();j ++) {
			if(x >= vec[i][j].rx)	break;
			int Y = vec[i][j].k * x + vec[i][j].b;//求出该线段x点的Y值
			if(x < vec[i][j].rx && x > vec[i][j].lx && Y <= h && Y > high) {//lx < x, rx > x
				high = Y;//擂台
				f = 1;//修改
				if(vec[i][j].ly > vec[i][j].ry)	pos = vec[i][j].rx, py = vec[i][j].ry;
				else	pos = vec[i][j].lx, py = vec[i][j].ly;//更新
			}
		}
	}
	if(f)	work(pos, py);//如果修改过了， 重新work
	return;
}
```

综合代码 $AC$
```cpp
#include<bits/stdc++.h>
#define N 100010
#define reg register
#define mod 100005
#define int long long
using namespace std;
//char in[1 << 20] ,*ss = in,*tt = in;
//#define getchar() (tt == ss && (tt = (ss = in) + fread(in, 1, 1 << 20,stdin),ss == tt) ? EOF : *ss++)
inline int read(){
	int x = 0, f = 1;  char ch = getchar();
	while(ch > '9' || ch < '0'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}

int n, X, area[N], len;
int Ln[N], Rx[N], pos, py;
struct line {
	int lx, ly, rx, ry, id;
	double k, b;
}a[N]; 
vector<line>	vec[N];//vec存线段
bool sort_l(line a, line b) {
	return a.lx < b.lx;
}
bool sort_r(line a, line b) {
	return a.rx > b.rx;
}
void work(int x, int h) {
	int high = -9999999999;
	int f = 0;//判断是否修改了pos 
	int blo = lower_bound(Ln + 1, Ln + area[n], x) - Ln;
	for(reg int i = 1;i <= blo;i ++) {
		for(reg int j = 0;j < vec[i].size();j ++) {
			if(x >= vec[i][j].rx)	break;
			int Y = vec[i][j].k * x + vec[i][j].b;
			if(x < vec[i][j].rx && x > vec[i][j].lx && Y <= h && Y > high) {
				high = Y;
				f = 1;
				if(vec[i][j].ly > vec[i][j].ry)	pos = vec[i][j].rx, py = vec[i][j].ry;
				else	pos = vec[i][j].lx, py = vec[i][j].ly;
			}
		}
	}
	if(f)	work(pos, py);
	return;
}
signed main(){
	n = read(), X = read();
	len = sqrt(n);
	for(reg int i = 1;i <= n;i ++) {
		a[i].id = i;
		a[i].lx = read(), a[i].ly = read(), a[i].rx = read(), a[i].ry = read();
		if(a[i].lx > a[i].rx)	swap(a[i].ly , a[i].ry), swap(a[i].lx, a[i].rx);
		a[i].k = 1.0 * (a[i].ry - a[i].ly) / (a[i].rx - a[i].lx);
		a[i].b = a[i].ly - a[i].lx * a[i].k;
		area[i] = (i - 1) / len + 1;
	}//预处理
	sort(a + 1,a + n + 1, sort_l);
	for(reg int i = 1;i <= n;i ++) {
		vec[area[i]].push_back(a[i]);
		Ln[area[i]] = min(a[i].lx, Ln[area[i]]);
		Rx[area[i]] = max(a[i].rx, Rx[area[i]]);
	}
	for(reg int i = 1;i <= area[n];i ++)	
		sort(vec[i].begin(), vec[i].end(), sort_r)//分块;
	pos = X;
	work(X, 0x7fffffff);
	printf("%d", pos);
	return 0;
}

```

---

## 作者：_Life_ (赞：5)

### 前置知识
一次函数

### 题意
在平面中有若干轨道，有一滴液体从上方滴落下来，如果碰到轨道就从轨道较低的一端离开轨道（垂直滴落），**在轨道中不受任何影响**，问最后液滴从什么位置落出整个系统。

### 题解

模拟，然后你就可以 $O(n^2)$ 爆艹 $10^5$ 了。~~建议把用脚出数据的出题人锕掉~~

~~为了不让题解内容显得那么单薄就~~简单推下柿子吧：

众所周知直线的方程可以这么写
$$y=kx+b$$
代入 $x_1,y_1,x_2,y_2$ 得
$$\begin{cases}y_1=kx_1+b\ \ \ \ \ \ (1)\\y_2=kx_2+b\ \ \ \ \ \ (2)\end{cases}$$
式 $(1)$ 减式 $(2)$ 得
$$y_1-y_2=k(x_1-x_2)$$
$$k=\frac{y_1-y_2}{x_1-x_2}$$
变形式 $(1)$ 得
$$b=y_1-kx_1$$

液滴显然会滴落在液滴之下的最高的那根轨道上，暴力找出那根铁轨，然后更新液滴坐标。如果液滴之下没有轨道了，输出液滴的 $x$ 坐标，结束。



### 代码
细节小多，详见注释
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,x,y,x1[100005],y1[100005],x2[100005],y2[100005],used[100005];
double k[100005],b[100005];
int main()
{
	scanf("%d %d",&n,&x),y=1e9;//从高处下落
	for(int i=0;i<n;i++)
	{
		scanf("%d %d %d %d",&x1[i],&y1[i],&x2[i],&y2[i]);
		if(x2[i]<x1[i])swap(x1[i],x2[i]),swap(y1[i],y2[i]);//令x1<=x2，便于处理
		k[i]=1.0*(y1[i]-y2[i])/(x1[i]-x2[i]);
		b[i]=y1[i]-k[i]*x1[i];
	}
	while(1)
	{
		int num=-1;double height=-1e18;
		for(int i=0;i<n;i++)
			if(!used[i])//该轨道未被使用过
				if(x1[i]<=x&&x<=x2[i]&&k[i]*x+b[i]<=y)//液滴在该轨道上方
					if(k[i]*x+b[i]>height)//最高的那一根轨道
						num=i,height=k[i]*x+b[i];
		if(num==-1)
			break;
		else
			x=k[num]>0?x1[num]:x2[num],y=min(y1[num],y2[num]);//更新液滴坐标
		used[num]=1;
		//printf("%d %d %d %d\n",x1[num],y1[num],x2[num],y2[num]);
	}
	printf("%d",x);
}
```

---

## 作者：AlexZhang (赞：5)

没有c++的，我来补一发

这道题难度还行，就是处理起来比较恶心

思路就是求出每一条线段的表达式（形如y=kx+b的形式）

x1*k+b=y1（1）

x2*k+b=y2 (2)

	那么（1）-（2）

	（x1-x2）*k=（y1-y2）
	 k=（y1-y2）/（x1-x2）

b=y1-k*x1

相信以年级大于初二的肯定都会懂

对于初始横坐标，将其带入表达式找最大纵坐标，前提是横坐标在线段范围内，然后更新水滴横坐标与纵坐标，重复以上操作直到无法滴到任何一个线段上为止

上代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
struct edge{
	int xi,yi,xj,yj;
	double k,b;//表达式参数
}e[10005];
bool cmp(edge x,edge y){
	return x.yj>y.yj;
}
int n,s,hig=2147483647;//hig为水滴纵坐标，s为横坐标（假设水滴是天上掉下来的）
int main(){
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d%d",&e[i].xi,&e[i].yi,&e[i].xj,&e[i].yj);
		e[i].k=((e[i].yi-e[i].yj)*1.0)/((e[i].xi-e[i].xj)*1.0);
		e[i].b=e[i].yi-e[i].k*e[i].xi;
	}
	while(1){
		int flag=0,maxn=-2147483647;//maxn记录水滴最高被接到是多少
		for(int i=1;i<=n;i++){
			int l=min(e[i].xi,e[i].xj);
			int r=max(e[i].xi,e[i].xj);
			//l记录线段最左面，r最右面
			if(s>=r||s<=l) continue;//不符合条件下一个
			double ls=s*e[i].k+e[i].b;//计算在多高被接到
			if(ls>hig) continue;//水滴已经在这个位置下面了
			if(maxn<ls){
				maxn=ls;flag=i;//更新最高
			}
		}
		if(!flag){
			printf("%d",s);//输出
			return 0;
		}
		if(e[flag].yi<e[flag].yj) s=e[flag].xi;
		else s=e[flag].xj;//更新横坐标
		hig=min(e[flag].yi*1.0,e[flag].yj*1.0);//更新纵坐标
	}
	return 0;
}

```

---

## 作者：qiuzijin2026 (赞：4)

# P1766 液体滴落

## [题面](https://www.luogu.com.cn/problem/P1766)

## 思路

这是一道大模拟。

由初中数学可知 

$$ y=k\times x+b$$

而

$$ k=\frac{y1-y2}{x1-x2} $$

$$ b=y1-x1\times k $$

我们就可以通过 $x$ 算出 $y$ 的值了。

剩下的就是模拟了。

枚举每一条线段，判断水滴能否落到上面，取这些线段中在 $x$ 上 $y$ 最高的一条算出水滴新的坐标。

如果水滴无法与任何一条线段相交，那么输出答案即可。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	long double x1,y1;
	long double x2,y2;
	long double k;
	long double b;
}xd[100005];
int n;
long double sx;
long double sy=INT_MAX;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d%Lf",&n,&sx);
	for(int i=1;i<=n;i++){
		scanf("%Lf%Lf%Lf%Lf",&xd[i].x1,&xd[i].y1,&xd[i].x2,&xd[i].y2);
		xd[i].k=(xd[i].y1-xd[i].y2)*1.0/(xd[i].x1-xd[i].x2)*1.0;
		xd[i].b=xd[i].y1*1.0-xd[i].x1*1.0*xd[i].k;
	}
	while(true){
		long double maxx=-0x7fffffff;
		int b=-1;
		for(int i=1;i<=n;i++)
			if(min(xd[i].x1,xd[i].x2)<sx && max(xd[i].x1,xd[i].x2)>sx && sx*xd[i].k+xd[i].b>=maxx && sx*xd[i].k+xd[i].b<=sy){
				maxx=sx*xd[i].k+xd[i].b;
				b=i;
			}
		if(b==-1) break;
		if(xd[b].y1==xd[b].y2) break;
		else if(xd[b].y1<xd[b].y2){
			sx=xd[b].x1;
			sy=xd[b].y1;
		}
		else if(xd[b].y1>xd[b].y2){
			sx=xd[b].x2;
			sy=xd[b].y2;
		}
	}
	printf("%.0Lf",sx);
	return 0;
}

```

---

## 作者：Y_B_Y (赞：3)

# 一道比较麻烦的模拟题

###### ~~一开始把"不一定互不相交"看成了"一定互不相交"害我之后的一些判断一直错误,害我改半天~~

#### 这一题$1≤n≤10,000,|x,y,S|≤1000,000,000$就是唬人的,最坏$O(n^2)$的算法都可以$90ms~~AC$,还有如果用long double转long long会变得非常诡异,用double就可以了

### 思路

- 确定每条线段(轨道可以看作线段)所在直线的方程(就是一次函数的图像),表示为$y=kx+b$并求出$k,b$值

- 确定第一滴水落到的线段

- 确定在线段上的水落到的下一个线段

- 如果没有下一个线段了,输出答案

### 做法

#### 一.得出每条线段所在直线的方程(其实就是要得出$y=kx+b$中$k,b$的值)

因为每一条线段都会给出两个点$x1,x2,y1,y2$,所以设它们所在的直线方程为$y=kx+b$

代入得

$
y1=k*x1+b ~~~~~  
$①

$
y2=k*x2+b ~~~~~$②

方程①-方程②得 $y1-y2=k*x1-k*x2$

所以 $y1-y2=k*(x1-x2)$

两边同时除以 $(x1-x2)$得

$k=\frac{y1-y2}{x1-x2}$

将$k$代入方程①得: $ y1=\frac{y1-y2}{x1-x2}*x1+b$

移项得 $ b=y1-\frac{y1-y2}{x1-x2}*x1$

所以只要存$k,b$ 的值每条线段所在的直线方程就都可以知道啦

#### 二.确定第一滴水滴到的线段与确定在线段上的水落到的下一个线段

题目说了"在轨道中不受任何影响"所以在线段上的水滴一定在线段的下端点下落,所以就知道了下落时的横纵坐标

确定上下方端点(用$x1,y1$存上方端点,$x2,y2$存下方端点)如果端点1($m1,n1$)与端点2($m2,n2$)中$n2>n1$那么端点2为上端点,小于就反过来

所以$x1=m2,y1=n2,x2=m1,y2=n1$,

为什么这两个放在一起讲呢,是因为他们其实都是已知横坐标$x1$求出将$x1$代入所以线段的直线方程得出纵坐标的最大值并记录线段号数(就是最先滴到的线段,但不能超过下落时的纵坐标,注意第一滴水没有下落的纵坐标,所以不需要判断这一点)

求纵坐标其实就是在$y=kx+b$中将$x1$代入$x$,所以纵坐标的值就是$k*x1+b$($k,b$已经求出来了)

#### 注意,因为是线段所以求出来的纵坐标不能超过线段上方端点的纵坐标也不能小于线段下方端点的纵坐标

#### 三.如果求出来的纵坐标都是不可以的说明没有下一个线段了,输出答案

代码

[代码开头define的用法](https://blog.csdn.net/u012611878/article/details/52534622)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ld double
#define ll long long
#define y1 yy//下面三个如果的变量名是关键字不能用,所以define来代替一下
#define next nest 
#define search seas
struct xd//存储线段的信息
{
	ld x1,y1,x2,y2;//x1,y1上端点,x2,y2下端点,ld,ll型都可以
	ll next=-1;//在这条线段的水滴会滴到的下一条线段,初始化为-1
	ld b,xl;//xl为上文的k
}k[10001];
ll n,s,mc;//mc为第一滴谁会滴到的线段的号数
ld llp,mm=-1000000001;//mm为第一滴水滴落到的最大纵坐标,初始化为最小横坐标(表示还没有)
ld yc(int a,int b)//水滴从线段p的下端点滴到线段i线段的纵坐标
{
	ld l=(k[a].xl*(k[b].x2*1.0)+k[a].b);//计算纵坐标
	if(l>=k[a].y1||l<=k[a].y2||l>k[b].y2) return -1000000001;//不可以,返回一个很小
	return l;//返回
}
void search(ll p)
{
     ll h=-1000000000;//表示在线段p上的水滴滴落到的最大纵坐标,初始化为最小横坐标(表示还没有)
	for(int i=1;i<=n;i++)
		{
			ld l=yc(i,p);//水滴从线段p的下端点滴到线段i线段时的纵坐标,如果为-1000000001表示没滴到一定小于h
			if(l<=k[p].y2/*滴到的纵坐标一定要小于滴落的纵坐标,不然就是向上滴了*/&&l>h/*更优,因为大于h所以一定是滴到的*/&&i!=p/*不是滴到同一条线段*/)
			{
				k[p].next=i;//更新会滴到的下一条线段
				h=l;//更新最大纵坐标
			}
		}
		if(k[p].next==-1)//如果还是初始化的值表示还有下一个滴到的
		{
			cout<<k[p].x2;//所在线段的下端点横坐标就是最后的横坐标,输出
			exit(0);//结束整个程序
		}
		search(k[p].next);//如果有就到那一条线段
}
int main()
{
	cin>>n>>s;//输入
	for(int p=1;p<=n;p++)
	{
		ld x,xx,y,yy;//ld,ll型都可以
		cin>>x>>y>>xx>>yy;//输入端点坐标
		if(y<yy)//先默认第一对输入的端点坐标为上端点,如果不是(即第二对输入的是)就交换两对端点坐标
		{
			swap(x,xx);//swap为交换的函数,数组中也可以用它
			swap(y,yy);
		}
		k[p].x1=x;//上端点横坐标
		k[p].x2=xx;//下端点横坐标
		k[p].y1=y;//上端点纵坐标
		k[p].y2=yy;//下端点纵坐标
		ld xa,xb;//等一下在算式中用
		xa=y-yy;
		xb=x-xx;
		k[p].xl=xa/xb;//得出k
		k[p].b=y-x*k[p].xl*1.0;//得出b
	}
	for(int p=1;p<=n;p++)//确定第一滴水落到的线段
	{
		llp=k[p].xl*(s*1.0)+k[p].b;//滴到这条线段的纵坐标
	    if(llp>=k[p].y1||llp<=k[p].y2)/*可以加上continue*/;//因为是滴到线段上所以不能超过
	    else//因为第一滴 水没有下落纵坐标,不用判断其它的了
	    {
	    	if(llp>mm)//更优
	    	{
	    		mm=llp;//更新最大纵坐标
	    		mc=p;//记录最先滴到的线段号数
	    	}
	    }
	}
	search(mc);//从这条线段开始
	return 0;
}
```










---

## 作者：taophee (赞：2)

想法：

这道题不是很难，稍微分析一下数据范围就可以看出来枚举是可行的，然后对于水滴的滴落方向进行枚举，然后就可以了(但是预处理最好把直线斜率算出来，这样比较方便)然后每次低落选择Y坐标最高的那个，算法：贪心+模拟.......(注意：每条线只能流过一次，注意判断)

程序：

```delphi

var
x1,x2,y1,y2:array[1..20000] of longint;
k,b:array[1..20000] of real;
f:array[1..20000] of boolean;
n,s,i,y,t,mj:longint;
max:real;

begin
  read(n,s);
  fillchar(f,sizeof(f),true);
  for i:=1 to n do
   begin
    read(x1[i],y1[i],x2[i],y2[i]);
    if x1[i]>x2[i] then
     begin
      t:=x1[i];x1[i]:=x2[i];x2[i]:=t;
      t:=y1[i];y1[i]:=y2[i];y2[i]:=t;
    end;
    k[i]:=(y1[i]-y2[i])/(x1[i]-x2[i]);
    b[i]:=y1[i]-x1[i]*k[i];
  end;
  y:=maxlongint;
  while true do
   begin
    max:=-maxlongint;mj:=-1;
    for i:=1 to n do
     begin
      if f[i] and (y>=s*k[i]+b[i]) and (y1[i]<=s*k[i]+b[i]) and (y2[i]>=s*k[i]+b[i]) and (x1[i]<=s) and (x2[i]>=s) then
       begin
        if max<s*k[i]+b[i] then begin max:=s*k[i]+b[i];mj:=i;end;
        continue;
      end;
      if f[i] and (y>=s*k[i]+b[i]) and (y1[i]>=s*k[i]+b[i]) and (y2[i]<=s*k[i]+b[i]) and (x1[i]<=s) and (x2[i]>=s) then
       begin
        if max<s*k[i]+b[i] then begin max:=s*k[i]+b[i];mj:=i;end;
        continue;
      end;
    end;
    if mj<>-1 then
     begin
      if y1[mj]<y2[mj] then begin y:=y1[mj];s:=x1[mj];end else begin y:=y2[mj];s:=x2[mj];end;
      f[mj]:=false;
    end;
    if mj=-1 then break;
  end;
  writeln(s);
end.

```

---

## 作者：mayike (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P1766)


这就是一道水模拟，但要用到一次函数知识。


------------
#### 注意：水滴垂直下落，且在一条轨道是会一直流到轨道末尾。


------------
## 思路：
我们可设一轨道上一点横坐标为 $x$，纵坐标为 $y$。

由初中所学知识可知解析式
    
  $$y=k\times x + b$$
而轨道的两端点各为 $(x_1,y_1)$ 和 $(x_2,y_2)$，可知：

 $$y_1=k\times x_1 + b$$
 
 $$y_2=k\times x_2 + b$$

 得
 $$k=\frac{y_1-y_2}{x_1-x_2}$$
 
 $$b=y_1-k\times x_1$$ 
 
 
这样就可以得出对于每条轨道的解析式了，然后判断每一条轨道在不在滴落范围，找最近且在水滴下方的轨道即可。
 
如果没有轨道满足水滴滴落条件，就输出横坐标。
 
注意：因为运算时可能出现小数，所以开浮点型，最后取整输出。
 
 ## code
 ```
#include<bits/stdc++.h>
using namespace std;
struct ssb{
	double a1,a2,b1,b2,w,v;
}x[100001];
double m,t=1000000001;int n;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>x[i].a1>>x[i].b1>>x[i].a2>>x[i].b2;
		x[i].w=(x[i].b1-x[i].b2)/(x[i].a1-x[i].a2);
		x[i].v=(x[i].a1*x[i].b2-x[i].a2*x[i].b1)/(x[i].a1-x[i].a2);
	}
	while(1){
		double p=-1000000001;int op=0;
		for(int i=1;i<=n;i++){
			if(x[i].w*m+x[i].v<t&&t>min(x[i].b1,x[i].b2)&&max(x[i].a1,x[i].a2)>=m&&min(x[i].a1,x[i].a2)<=m){
				if(p<x[i].w*m+x[i].v)op=i,p=x[i].w*m+x[i].v;
			}
		}
		if(!op){
			printf("%.0lf",m);break;
		}
		else{
			if(x[op].b1<x[op].b2){
				m=x[op].a1;t=x[op].b1;
			}
			else m=x[op].a2,t=x[op].b2;
		}
	}
	return 0;
}
```
好不容易发一次题解，希望管理大大能通过，谢谢！

---

## 作者：ModestCoder_ (赞：1)

一道比较烦的模拟题

首先求出每条线的解析式

发现本题支持$O(n^2)$做法，直接上模拟

每次枚举每条线，把横坐标代入，找到当前水滴掉落可以落到的最高的线上

然后让水滴滚到线两端较低的那端，重复此操作就行了

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 10010
#define LL long long
using namespace std;
struct data{
	LL x1, y1, x2, y2;
}a[maxn];
double k[maxn], b[maxn];
LL n, s;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int main(){
	n = read(), s = read();
	for (int i = 1; i <= n; ++i){
		a[i] = (data){read(), read(), read(), read()};
		k[i] = 1.0 * (a[i].y2- a[i].y1) / (a[i].x2 - a[i].x1);
		b[i] = 1.0 * a[i].y1 - k[i] * a[i].x1;
	}
	double hei = 1e9;
	while (1){
		double H = -1e9;
		int node = -1;
		for (int i = 1; i <= n; ++i){
			if (s <= min(a[i].x1, a[i].x2) || s >= max(a[i].x1, a[i].x2)) continue;
			double h = k[i] * s + b[i];
			if (hei <= h) continue;
			if (h > H) H = h, node = i;
		}
		if (node == -1) return printf("%d\n", s), 0;
		if (a[node].y1 > a[node].y2) hei = a[node].y2, s = a[node].x2; else
		hei = a[node].y1, s = a[node].x1;
	}
	return 0;
}
```


---

## 作者：LittleSnowy (赞：1)

这就是一道模拟水题

首先明确：

(1)水滴不会穿墙

(2)水往低处流

知道这些时，我们还要判断水滴落下的地方是否有线段，还要判断线段是否在水滴上方

若不满足，就continue

若满足，找出在最高处能接到的线段，更新高度、横坐标，直到脱离系统
```cpp
if(s>=max(x[i],xx[i])||s<=min(x[i],xx[i])||s*k[i]+b[i]>high)continue;
```
就是这句话

若全部continue，输出现在的横坐标，做完。

---

## 作者：FBW2010 (赞：0)

## 思路
题目很简单，就是一滴水滴会从高空垂直落下，如果掉到管子上就会顺着低的一边往下流，求最后的 $x$ 坐标。

很明显这就是一道纯模拟题，只需要每一次找到水滴能落到的  $y$ 坐标最高的管子，然后确定哪一边更低，再更新水滴的坐标就可以辣。

但怎么求管子的 $y$ 坐标呢？

那让我们进入第二个板块——

## 一次函数
题目不是告诉了我们每条线两个端点的坐标吗？有了坐标，就能很轻松地算出一次函数解析式了。

推导过程如下。~~忘记了怎么求而把笔记抄上来的屑~~

令一次函数的解析式为
$$
y=kx+b  
$$

带入两点坐标得

$$
\begin{cases}
y_1=kx_1+b \\
y_2=kx_2+b 
\end{cases}
$$

整理得

$$
k=\frac{y_2-y_1}{x_2-x_1}
$$

而

$$
y-y_1=k(x-x_1)
$$

所以

$$
y-y_1=\frac{y_2-y_1}{x_2-x_1}(x-x_1)
$$

而我们已经知道了 $x_1$ 与 $y_1$，$x_2$ 与 $y_2$，以及水滴的 $x$ 坐标，将其带入后就能求出水滴滴落位置的 $y$ 坐标了。

## 代码
知道了这些，代码就十分简单了。我们只需要把每个管子端点的坐标以及斜率 $k$ 记录在结构体数组 $a$ 中，然后写一个 while 循环，每次**遍历 $a$ 数组找到 $y$ 值最大的符合要求的管子**，再更新 $x$ 和 $y$ 坐标。如果全都不符合要求，就跳出循环，输出 $x$ 和 $y$ 就行了。

题目数据有亿点水，$O(n^2)$ 代码能轻松过。话不多说，直接上代码。
```cpp
#include<cstdio>
using namespace std;
int n,x;
double y=2e9; //将y坐标初始化为无穷大 
struct line{ //定义结构体方便存储  
	int x1,x2,y1,y2; //两个端点的坐标 
	double k; //斜率k 
}a[100001];
int main(){
	scanf("%d %d",&n,&x);
	for(int i=1;i<=n;i++){
		scanf("%d %d %d %d",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
		a[i].k=(a[i].y2-a[i].y1)*1.0/(a[i].x2-a[i].x1); //计算出斜率k的值 
	}
	while(1){ //无限循环 
		double maxn=-2e9; //将最大值初始化为无穷小 
		int maxi; //最大值的编号 
		bool f=1; //判断是否有符合条件的管子 
		for(int i=1;i<=n;i++){
			double ny=a[i].k*(x-a[i].x1)+a[i].y1; //计算y的值 
			//判断是否合法以及是否为最大值
			if(ny>maxn&&ny<=y&&(a[i].x1<x&&a[i].x2>x||a[i].x1>x&&a[i].x2<x)){  
				f=0; //标记为有 
				maxn=ny; //记录最大值 
				maxi=i; //记录最大值编号 
			}
		}
		if(f)break; //如果没有就跳出循环 
		//判断那一边更低 
		if(a[maxi].y1<a[maxi].y2){
			//更新xy 
			x=a[maxi].x1;  
			y=a[maxi].y1;
		}
		else{
			x=a[maxi].x2;
			y=a[maxi].y2;
		}
	}
	printf("%d",x); //输出答案 
	return 0; //华丽的结束 
}
```

温馨提示：
+ $y$、$k$ 和 $maxn$ 记得使用 **double** 类型
+ 最大值要初始化为**无穷小**
+ 找最大值时还要判断水滴**能否滴在这根管子上**

---

## 作者：Aisaka_Taiga (赞：0)

[传送门](https://www.luogu.com.cn/problem/P1766)

本蒟蒻第一次发题解~~求通过~~。


# 基本思路

首先这道题要求出每个斜面的解析式。



$ 1 : k2 = a k1 + b $



$ 2 : k4 = a k3 + b $



通过消元代入得



$ a = ( k2 - k4 ) / ( k1 - k3 ) $



$ b = k2 - a k1 $



然后再把每个斜面的y值求出来比较出最高的，流过之后标记一下，再继续寻找下一个可以流过的斜面，只要没有可以滴到的斜面就直接退出循环。

[不会的点这里](https://baijiahao.baidu.com/s?id=1714423468928385425)

# 细节处理

用结构体本来是为了让我能看的更舒服一点，但打着打着一直加变量，后面越来越乱，所以还是用数组比较好一点吧（个人意见。

在循环里面流过斜面后一定要标记一下，否则会可能出现重新流过的情况。

在输入的时候要判断一下初始的横坐标和结束的横坐标哪个大，如果结束的横坐标比初始的横坐标大就交换一下横纵坐标，保证开始的点在结束的点左边，在后面的循环里面判断的时候就可以直接把水滴的横坐标与斜面开始的横坐标和结束的横坐标相比较来判断水滴是否可以滴在上面了。

# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,y=9999999;//y是一开始水滴的纵坐标，从“高”处往下 
struct xiemian{
	int sx,sy,fx,fy;//起始横纵坐标 
	double k,b;//解析式的y=kx+b; 
	bool flag=0;//用来判断这个斜面有没有流过 
};
xiemian aa[10001];//题目说10000，不用开太大 
int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)
	{
		cin>>aa[i].sx>>aa[i].sy>>aa[i].fx>>aa[i].fy;
		if(aa[i].sx>aa[i].fx)//如果结束的横坐标比开始的横坐标小的话 
		{
			swap(aa[i].fx,aa[i].sx);//交换一下横坐标 
			swap(aa[i].fy,aa[i].sy);//交换一下纵坐标 
		}
		aa[i].k=(aa[i].sy-aa[i].fy)*1.0/(aa[i].sx-aa[i].fx);//根据公式算k值 
		aa[i].b=aa[i].sy-aa[i].k*aa[i].sx;//根据公式算b值 
	}
	while(1)//除非执行里面的break，否则一直循环 
	{
		long long xm=0,zuigao=-9999999;//赋个负数是为了防止都是负的，xm是斜面的序号 
		for(int i=1;i<=m;i++)//从第一个斜面开始找 
		  if(aa[i].flag==0&&aa[i].sx<=n&&n<=aa[i].fx&&aa[i].k*n+aa[i].b<=y)//判断一下斜面是否走过并判断一下水滴是否滴在上面，前面不交换这里就错了 
			if((aa[i].k*n+aa[i].b)>zuigao)//找到最先碰到的斜面 
			{
				xm=i;//记录斜面序号 
				zuigao=aa[i].k*n+aa[i].b;//记录最高点y值 
			}
		if(xm==0) break;//当水滴没有在滴在斜面上时，直接退出循环 
		if(aa[xm].k>0) n=aa[xm].sx,y=min(aa[xm].fy,aa[xm].sy);//判断是开始的x的y高还是结束的x的y高 
		else n=aa[xm].fx,y=min(aa[xm].fy,aa[xm].sy);//记录水滴从此斜面落下横纵坐标 
		aa[xm].flag=1;//标记已经用过 
	}
	cout<<n<<endl;//输出最后的横坐标 
	return 0;//结束了。。 
}
```


---


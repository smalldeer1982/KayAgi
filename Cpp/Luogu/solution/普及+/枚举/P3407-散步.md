# 散步

## 题目描述

一条道路上，位置点用整数 $A$ 表示。

当 $A=0$ 时，有一个王宫。当 $A>0$，就是离王宫的东边有 $A$ 米，当 $A<0$，就是离王宫的西边有 $-A$ 米。

道路上，有 $N$ 个住宅从西向东用 $1\sim N$ 来标号。每个住宅有一个人。住宅只会存在于偶数整数点。

该国国王认为，国民体质下降，必须要多运动，于是下命令所有人都必须出门散步。所有的国民，一秒钟可以走 $1$ 米。每个国民各自向东或者向西走。这些方向你是知道的。命令发出后所有人同时离开家门开始散步。

然而该国的国民个都很健谈，如果在散步途中两个人相遇，就会停下来交谈。正在走路的人碰到已经停下来的人（重合）也会停下来交谈。一但停下来，就会聊到天昏地暗，忘记了散步。

现在命令已经发出了 $T$ 秒，该国有 $Q$ 个重要人物，国王希望能够把握他们的位置。你能帮他解答吗？

## 说明/提示

$20\%$ 数据，$N\le 100,T\le 10000$。

另外 $20\%$ 数据，$N\le 5000$。

另外 $20\%$ 数据，从最西边数起连续的若干国民全部往东，剩下的全部往西。

$100\%$ 数据 $A_i$ 为偶数，$|A_i|\le 10^{18},|T|\le 10^{18},1\le Q\le N\le 100000$。


## 样例 #1

### 输入

```
6 6 4
-10 1
-6 2
-4 1
2 1
6 2
18 2
2
3
4
6```

### 输出

```
-8
2
4
12```

# 题解

## 作者：kkksc03 (赞：20)

为什么数据范围这么奇怪？因为这个范围已经剧透了。

我们先考虑“从西边数连续的人全部往东，剩下的全部往西”这个。

我们会发现，他们最后都会集中在一个点上。哪个点？就是中间的那对面对面的中间点。我们只要判断时间内，人能不能走到这个点停下来。于是20分get。

100分呢？我们是不是可以吧所有人分成若干组，然后每一组分别计算啊？

例如样例，我们将`(`认为往东，`)`往西。他们最终会停在`|`的地方。

```cpp
  第一组                   第二组
(    |    )          (  (     |     )  )
-10  -8   -6         -4 2     4     6 18
```
于是我们就很清楚了。

那最左边的人向左，最右边的人向右怎么办呢？那就让他走呗，特判一下，反正永远也停不下来。


---

## 作者：UIai (赞：17)

其实我们只需要将1~n这些人分向西向东两组扫两遍就可以了。

以向西行的第i人为例，最终停下来的无非三种情况

1.时间到了不能再走了

2.和在自己西边的向东走的i-1相撞了

3.和在自己西边的向西走的i-1相撞了（i-1与i-2相撞）

所以对于向西行的人我们只需要自西向东计算并记录每个人的位置即可，向东同理，详情见代码。

```cpp
#include<iostream>
#define maxn 100010
using namespace std;
int n,Q,q[maxn];
long long loc[maxn],p[maxn][2],t;//loc记录第i个人的位置 
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>t>>Q;
    for(int i=1;i<=n;i++)
        cin>>p[i][0]>>p[i][1];    
    for(int i=1;i<=Q;i++)
        cin>>q[i];
    for(int i=1;i<=n;i++)
        if(p[i][1]==2)
        {
            if(i==1)
                loc[i]=p[i][0]-t;
            else if(p[i-1][1]==2)
                loc[i]=max(loc[i-1],p[i][0]-t);
            else loc[i]=max(p[i][0]/2+p[i-1][0]/2,p[i][0]-t);
        }
    for(int i=n;i>=1;i--)
        if(p[i][1]==1)
        {
            if(i==n)
                loc[i]=p[i][0]+t;
            else if(p[i+1][1]==1)
                loc[i]=min(loc[i+1],p[i][0]+t);
            else loc[i]=min(p[i][0]/2+p[i+1][0]/2,p[i][0]+t);
        }
    for(int i=1;i<=Q;i++)
        cout<<loc[q[i]]<<endl;
    return 0;
}
```

---

## 作者：DоsLikе (赞：6)

# P3407 散步

**题目描述&样例输入&输出：[这里](https://www.luogu.com.cn/problem/P3407)**

**个人认为挺详细了，把整个问题的思维拐点都说了一下**

刚看到这一题，我甚至认为本题的难度应当为普及/提高-，仔细一看，发现这题并不简单。

这题最大的难点在于Ai的取值范围，很显然，如果单纯的进行模拟，我们的数组一定会爆掉。

（[想用纯模拟的方法的同学们不用试了，我帮你们试完了](https://www.luogu.com.cn/record/44101144)）

我们看一下题目最下方的提示：

**另外20%数据 从最西边数起连续的若干国民全部往东，剩下的全部往西**

这意味着什么？这意味着~~我们可以先水20%的分~~我们可以从这里发现一些规律。（注意，以下内容请认真阅读，里面隐含了我们解决这道题的正确方法）

首先我们需要明确一下几点（仅对于这种情况）：

- 在最中间，有且仅有一对国民，他们一定是相向而行的。
- 中间的两位国民，他们相向而行，如果时间足够，他们一定会停下来~~拉呱~~交谈的
- 而他们停下来的地方，就会是他们的正中间(因为这两个人速度相同啊)
- 如果这两个人的时间充足，他们会停下交谈，并且他们两边的人会向他们靠拢，而且，两边的人如果时间充足，他们一定会到达最中间两个人的中间点并且停下来交谈

- 如果时间不充足，那他们会“尽量”的向中间靠拢


明白这几点的话，这种情况就一定很好写出来了。

Tips：我知道你们在担心什么，如果中间值为奇数怎么办？事实上，我们伟大的出题人（kkk）已经帮我们解决了这个困惑：

**100%数据 Ai为偶数**

放心找中间点吧，绝对不会出现奇奇怪怪的问题的。

当你按照上述思路完成程序后，你就会获得42分的好成绩

（[提交记录](https://www.luogu.com.cn/record/44102793)）

~~这之后，我就去睡觉了。~~

Day 2：

我发现，这题和表达式计算有一点相似。

因为我们已经有了Day 1的思路，我们发现，当两个人相向而行的时候，只要时间充足，他们就一定会相遇。

因此我们把向东走的人表达为“（”，把向西的的人表达为“）”，当“（”遇到“）”时，就可以做一些判断......

计算表达式的时候，我们好像也是当“（”遇到“）”的时候进行一些操作的诶。

而那时我们通常会使用栈，这一当然也可以使用。

（仔细想一想为什么现在这种情况可以用栈呢，提示：我们找的是“最靠近”的两个点）。

以及还有一点：若两人同向而行，则两个人除非中途停下，否则永远不会相遇（还是因为速度相同）

其实我们会发现，我们的正解基本上是由好多个**稍作改动的**Day1思路组成的。

总体思路有了，代码也就好写了，细节注释里都有QWQ：

```cpp
#include <iostream>
#include <stack>
#define ll long long
#define maxn 100005
using namespace std;
int n,q; 
ll t;//变量名称与题面一致，注意，这里的 |t|<=10^18	所以要用long long去存 
struct node{//国民结构体 
	int id;//该国民的id，可以理解为身份证号 
	ll pos;//该国民的位置，初始值为家的位置 
	ll way;//该国民的行进方向 
}arr[maxn];
stack <node> st; 
int main(){
	cin>>n>>t>>q;
	for(int i=1;i<=n;i++){
			cin>>arr[i].pos>>arr[i].way;
			if(arr[i].way==2)arr[i].way=-1;//这里把2换成-1有利于计算 
			arr[i].id=i;
	}
	for(int i=1;i<=n;i++){
		if(i==1&&arr[i].way==-1){
			arr[i].pos=t*arr[i].way+arr[i].pos;
			continue;
		}
		if(i==n&&arr[i].way==1){
			arr[i].pos=t*arr[i].way+arr[i].pos;
			continue;
		}//以上两个if为特判，即当最西边的国民向西走或最东边的国民向东走时，他们永远不会与任何人相遇 
		if(arr[i].way==1)st.push(arr[i]);//如果当前国民是"("，就将其压入栈中 
		if(arr[i].way==-1){
			if(st.empty()){//先判断，如果左(西)面没有待处理的人了，说明要么处理完了，要么左边是真的没有人(或者不符合压入栈中的要求) 
				ll p=arr[i-1].pos;
				if(arr[i].pos+arr[i].way*t<=p)arr[i].pos=p;
				else arr[i].pos=arr[i].pos+arr[i].way*t;//这个时候只需要判断他向左走时能不能和左面的人相遇  
			}
			else{				
				ll l=st.top().pos;
				ll r=arr[i].pos;
				ll mid=(l+r)/2ll;//如果西面有待处理的人的话，则该")"先找到和最靠近自己 "("的位置并取中间值 
				if(arr[i].pos+arr[i].way*t<=mid){
					arr[i].pos=mid;//若")"能到达该"中间值"
					while(!st.empty()){
						node last=st.top();
						int id=last.id;
						st.pop();
						if(last.pos+last.way*t>=mid)last.pos=mid;
						else last.pos=last.pos+last.way*t;
						arr[id]=last;//id在这里用到 
					}//判断每一个西边的待处理的"(" 能否到达中间值 
				}
				else{
					arr[i].pos=arr[i].pos+arr[i].way*t;//如果无法到达 
					ll p=arr[i].pos;
					while(!st.empty()){
						node last=st.top();
						st.pop();
						int id=last.id;
						if(last.pos+last.way*t>=p)last.pos=p;
						else last.pos=last.pos+last.way*t;
						arr[id]=last;
					}//判断每一个西边的待处理的"("能否到达该")"所能到达的地方 
				}
				
			}
		}
	}
	while(!st.empty()){
		node z=st.top();
		st.pop();
		int id=z.id;
		z.pos=z.pos+z.way*t;
		arr[id]=z;
	}//这里清栈，避免最后一个方向为 1所遗留下来的问题 
	for(int i=1;i<=q;i++){
		int m;
		cin>>m;
		cout<<arr[m].pos<<endl;//查询输出即可 
	}
	return 0;
} 

```


**总结：** 可能会很啰嗦，但是这篇题解就是为了给我这种蒟蒻写的，总体来说本题难度并不高，但是需要考虑的细节不少

Tips:修改了一些格式



---

## 作者：Emplace (赞：3)

## 算法
这很明显是一个大模拟的题目~~太恶心了~~。
## 思路
首先我们可以把所有人按位置排序。然后从最后一个人枚举到第一个人，如果是东并且东边没有西则说明他会一直走，如果是西可以记录一下，然后如果是东可以看一下他是不是对于上一个西的第一个（记得在找到下一个西的时候重置），如果是，那么看他能不能与上一个西相遇，不能标记为二，直接走，能就为一，计算相遇的位置。如果不能就看标记为一还是二，如果为一就走到相遇的那个位置（如果走不到就直接走），为二就直接走。随后，我们可以从第一个枚举到最后一个，将上面东西交换一下。最后就能直接输出答案（用一个数组来记录）。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,t,q,l=LONG_LONG_MIN,r=LONG_LONG_MIN,ans[200000]; 
struct node{
	int x,c,id;
};
node a[200000];
bool cmp(node s1,node s2){
	if(s1.x!=s2.x){
		return s1.x<s2.x;
	}
	else{
		return s1.c<s2.c;
	}
}
signed main(){
	cin>>n>>t>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].c;
		a[i].id=i;
	}
	sort(a+1,a+1+n,cmp);
	int cnt=0;
	for(int i=n;i>=1;i--){
		if(a[i].c==1&&l==LONG_LONG_MIN){
			ans[a[i].id]=a[i].x+t;
			continue;
		}
		if(a[i].c==2){
			l=i;
			cnt=0;
			continue;
		}
		if(a[i].c==1&&cnt==0){
			if(a[i].x+t<a[i].x+abs(a[i].x-a[l].x)/2){
				ans[a[i].id]=a[i].x+t;
				cnt=2;
				continue;
			}
			cnt=1;
			ans[a[i].id]=a[i].x+abs(a[i].x-a[l].x)/2;
			r=i;
			continue;
		}
		if(a[i].c==1&&cnt==1){
			if(a[i].x+t<a[r].x+abs(a[r].x-a[l].x)/2){
				ans[a[i].id]=a[i].x+t;
				continue;
			}
			ans[a[i].id]=a[r].x+abs(a[r].x-a[l].x)/2;
			continue;
		}
		if(a[i].c==1&&cnt==2){
			ans[a[i].id]=a[i].x+t;
		}
	}
	l=LONG_LONG_MIN; 
	r=LONG_LONG_MIN;
	cnt=0;
	for(int i=1;i<=n;i++){
		if(a[i].c==2&&r==LONG_LONG_MIN){
			ans[a[i].id]=a[i].x-t;
			continue;
		}
		if(a[i].c==1){
			r=i;
			cnt=0;
			continue;
		}
		if(a[i].c==2&&cnt==0){
			if(a[i].x-t>a[i].x-abs(a[r].x-a[i].x)/2){
				ans[a[i].id]=a[i].x-t;
				cnt=2;
				continue;
			}
			cnt=1;
			ans[a[i].id]=a[i].x-abs(a[r].x-a[i].x)/2;
			l=i;
			continue;
		}
		if(a[i].c==2&&cnt==1){
			if(a[i].x-t>a[l].x-abs(a[r].x-a[l].x)/2){
				ans[a[i].id]=a[i].x-t;
				continue;
			}
			ans[a[i].id]=a[l].x-abs(a[r].x-a[l].x)/2;
			continue;
		}
		if(a[i].c==2&&cnt==2){
			ans[a[i].id]=a[i].x-t;
		}
	}
	for(int i=1;i<=q;i++){
		int t;
		cin>>t;
		cout<<ans[t]<<endl;
	}
	return 0;
}
```

---

## 作者：易极feng (赞：3)

蒟蒻的nlogn。
~~（竟然有Rank11 大佬们的O(N)吃土了吗）~~

我们定义，当时间趋于无穷大时位置不变的点所在位置为相聚点。

易知相聚点为所有相邻而方向不同的两人位置中点。

对于每个重要人物，二分求出最近的相聚点，与A[i]±t相比较即可。

~~P.S.每次都被long long坑惨了（⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄）（逃~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

typedef long long ll;

const int N=100005;

ll t,a[N],s[N];
int n,q;
int d[N];
int p[N];
int cnt;

int main(){
	int i;
	scanf("%d%lld%d",&n,&t,&q);
	for(i=1;i<=n;i++)scanf("%lld%d",&a[i],&d[i]);
	for(i=1;i<=q;i++)scanf("%d",&p[i]);
	
	cnt=0;
	for(i=1;i<n;i++){
		if(d[i]!=d[i+1])s[++cnt]=a[i]+a[i+1]>>1;
	}
	s[0]=-9223372036854775800,s[cnt+1]=9223372036854775800;
	
	int cur,l,r;
	for(i=1;i<=q;i++){
		l=1,r=cnt;
		if(d[p[i]]==2){
			cur=0;
			while(l<=r){
				int mid=l+r>>1;
				if(s[mid]>a[p[i]])r=mid-1;
				else l=mid+1,cur=mid;
			}
			if(a[p[i]]-t<s[cur])printf("%lld\n",s[cur]);
			else printf("%lld\n",a[p[i]]-t);
		}else{
			cur=cnt+1;
			while(l<=r){
				int mid=l+r>>1;
				if(s[mid]<a[p[i]])l=mid+1;
				else r=mid-1,cur=mid;
			}
			if(a[p[i]]+t>s[cur])printf("%lld\n",s[cur]);
			else printf("%lld\n",a[p[i]]+t);
		}
	}
	
	return 0;
}
```

---

## 作者：jyz666 (赞：2)

# 题解 P3407 【散步】

[传送门](https://www.luogu.com.cn/problem/P3407)

蒟蒻好久没写题解啦，赶紧写一篇水题题解补补咕值。

这题没想出二分啥的高级算法~~是我太菜~~，只写了一篇枚举暴力。

------------

首先我们看一眼题面，~~嗯不会！~~

然后看看数据范围，n的大小还是可以接受的

仔细一想，如果一个人运气不好，碰不到其他人，他将一直走下去。所以我们就可以在$O(1）$的时间内算出他最后的位置。

如果一个人碰到了人群，那么他就将停止走路，在人群中一起聊天。

人群个数不会超过$n/2$，这很显然对吧。我们只要掌握每一个会形成人群的点，就可以算出所有人最后的位置了。

然后某两个人可以碰到一起当且仅当i
号人向东走且$i+1$号人向西走，pos[i+1]−pos[i]⩽2∗T，那样就会在pos[i]+(pos[i+1]−pos[i])/2的地方形成人群。

这时我们再去更新上一个人群到这一个人群中向东走的人的答案，因为新人群的出现只会影响这满足上述条件的人。

然后向西走的就直接算会不会走到上一个人群里，不会的话就直接走，会的话上一个人群的位置就是他最后的位置。

### ！注意！
$|A_i|$<=10^18,$|T|$<=10^18

lastposition初始赋值一定要小于这个值！！！
所以要开longlong，我被卡了5遍！~~（血的教训）~~

_十年oi一场空，不开longlong见祖宗_

如有不懂，详见注释

### 上代码》》

```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<iostream>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
const int maxn=1e5+5;
#define inf 3e18//必须得足够大！！ 
const int mod=100003;

void read(ll &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
int dis[maxn];//记录每个人的方向
int n,q,now=1;//now是上一个人群后的第一个人的标号
ll t,lp=-inf;//t记录时间，lp记录上一个人群的位置
ll a[maxn],pos[maxn]; //a记录初始位置，pos记录最后位置

int main(){
	scanf("%d%lld%d",&n,&t,&q);
	for(int i=1;i<=n;i++){
		scanf("%lld%d",&a[i],&dis[i]);
	}
	for(int i=1;i<=n;i++){
		if(dis[i]==2) pos[i]=max(a[i]-t,lp);//如果是向西走那么直接对a[i]-t,lp取max
		else{
			pos[i]=a[i]+t;//我不管最终位置是啥，先放到a[i]+t再说。到时候形成新人群了会回过头来更新
			if(dis[i+1]==2&&a[i+1]-a[i]<=2*t){//如果会形成新人群
				lp=a[i]+(a[i+1]-a[i])/2;//更新人群位置
				while(now<i+2){
					if(dis[now]==1)
						pos[now]=min(a[now]+t,lp);
					now++;//把上一个人群到当前人群间所有向东走的人的答案都试着更新一遍。
				}
			}
		}
	}
	for(int i=1;i<=q;i++){
		int x;
		scanf("%d",&x);
		printf("%lld\n",pos[x]);
	}
	return 0;
}
```

###  _No pain， No gain_ 

---

## 作者：Frozen_Ladybug (赞：1)

题意：现在一共有 $N$ 个人同时从“家”中出发，如果两人相遇立即停下，求经过 $T$ 秒后所求的人分别都在哪个位置。

因为每个人速度相同，所以不会出现追及这种相遇情况，就不会出现分数。现在只需要将这些人分别向西和向东遍历两边即可。

而每个人停下来只有三种情况。

1. 时间到了不能再走了。

1. 和在自己西边、向东走的 $i-1$ 相遇。

1. 在 $i-1$ 和 $i-2$ 停下后，与他们相遇。

所以对于向西行的人我们只需要自西向东计算并记录每个人的位置即可，向东同理。这样分别将向西和向东的人作为两个数组，算起来会简单一些。

```
#include<bits/stdc++.h>
using namespace std;
int n,m,q[100005];
long long l[100005],p[100005][2],t;//l记录每个人的位置
int main(){
    scanf("%d%lld%d",&n,&t,&m);
    for(int i=1;i<=n;i++) scanf("%lld%lld",&p[i][0],&p[i][1]);    
    for(int i=1;i<=m;i++) scanf("%d",&q[i]);//读入
    for(int i=1;i<=n;i++)
        if(p[i][1]==2){//自东向西遍历每个向西走的人
            if(i==1) l[i]=p[i][0]-t;//1号人,一直走下去
            else if(p[i-1][1]==2) l[i]=max(l[i-1],p[i][0]-t);//前面的人向东走,算出相遇时间
            else l[i]=max(p[i][0]/2+p[i-1][0]/2,p[i][0]-t);//前面的人向西走,算出i-1和i-2停下来的时间与i的时间相减取最大
        }
    for(int i=n;i>=1;i--)
        if(p[i][1]==1){//自西向东遍历每个向东走的人
            if(i==n) l[i]=p[i][0]+t;
            else if(p[i+1][1]==1) l[i]=min(l[i+1],p[i][0]+t);
            else l[i]=min(p[i][0]/2+p[i+1][0]/2,p[i][0]+t);
        }//这里和上面基本相同
    for(int i=1;i<=m;i++) printf("%lld\n",l[q[i]]);//输出每个重要人物的位置
    return 0;
}
```


---

## 作者：新手7889456 (赞：1)

对于每个人来说：**他们都是同时动的，所以只有相遇，没有追及**

故我们可以分类来看：

> 1.  中途碰到人，故而停下来
> 2.  一直走，中途没有碰到人

对于第一种情况来说，又可以分成这样两种

> 1. 碰到走动的人，这时候，停下来的地方就是二者的开始距离加起来除以二
> 2. 碰到停下来谈话的人，显然就是直接停在这聊天的地方了

对于第二种情况来说：

只要我离得前面的人够远，或者前面没有人，我就可以在$T$的时间里面一直走，变化后的位置就是$a[i]±T$

这时我们只要维护两个东西：

**正在走的人** 和 **既已知道的停下来的有人的地方** 就可以了

剩下不懂的看代码的注释就OK了：

```
#include<iostream>
#include<cstdio>
using namespace std;

const int N = 1e5 + 10;

long long T,st[N],ans[N],a[N];//首先我们是要从西往东遍历，所以我们是要把向东走的人看做移动的人，存入栈中
int n,top,q;

int main() {
	scanf("%d%lld%d",&n,&T,&q);//令人疑惑不解的读入
	long long x;int dir;bool ok(0);
	for(int i(1);i<=n;++i){
		scanf("%lld %d",&a[i],&dir);
		if(dir==1) st[++top] = i;//这个人往东走，所以加到栈里
		else {
			if(top) {
				ok = 1;
				bool az(0);
				if(a[st[top]]+T>a[i]-T) {//显然，与这个人最先碰到的人一定是离他最近的人
					ans[st[top]] = ans[i] = a[st[top]]+a[i]>>1;
					--top,az = 1;
				}
				else ans[i] = a[i] - T;
				if(az)//az表示这两个是否碰面，没有碰面的话就不能以i的ans为定点了
				while(a[st[top]]+T>ans[i]&&top){
					ans[st[top]] = ans[i];
					--top;
				}
				while(top){
					ans[st[top]] = a[st[top]] + T;
					--top;
				}
				continue;
			}
			if(ok) {//注意是要先判断栈中是否有人，然后再去判断这个
				if(a[i]-T>=ans[i-1]) ans[i] = a[i]-T,ok = 0;
				else ans[i] = ans[i-1];//这个人加入了前面的群聊
				continue;
			}
			ans[i] = a[i] - T;//孤独
		}
	}
	while(top) {
		ans[st[top]] = a[st[top]] + T;//剩下的，一直往右走的
		--top;
	}
	while(q--) {
		scanf("%d",&dir);
		printf("%lld\n",ans[dir]);//不知道这是什么
	}
	return 0;
}
```


---

## 作者：Schwarzkopf_Henkal (赞：1)

首先，我们要记住……

十年OI一场空，不开longlong见祖宗！

这道题还是十分友好的，不过一个很小的地方错了就会导致一半的点不能AC。

朴素地思考，首先最常见的思路是直接暴力，但是$10^{18}$的范围直接导致了数组都开不够，模拟等于自爆。

然后我们考虑更玄学的算法。发现，在不考虑停下来聊天的情况，同一个方向的人是追不上前面的人的，所以后面的人如果要停下来聊天必定是走到了前面的人停下来的地方。然后我们知道，面对面走来的两组人停下来聊天的位置必定是两个最接近的面对面的人的位置的中点，前提是的确能够靠到一起。

那么我们按照位置排序，对于一个向前走的人，如果他的下一个人向后走，在符合要求的情况下，他们停下的位置是两个人的中点，而任何人在自己走路的过程中要是遇到了这样的一个“中点”，那么他就会停在距离他的起点最近且在他的路径上的中点上，否则就会一直走$t$距离。

精简思路，对于每对最近的面对面的人，创建一个在他们中点上的断点，对于每一个人，二分寻找它路径上有无断点，有则输出最近断点，否则走$t$距离。
以下为代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,q,uni[1005],p=1,bek[100005],k;//uni储存要求的人，bek保存断点
struct node{
	long long pos,dir,id;//位置，方向，Unicode
}per[100005];
bool cmp(node a,node b){
	return a.pos<b.pos;
}//按位置排序
bool cmp_id(node a,node b){
	return a.id<b.id;
}//按Unicode排序
int main(){
	cin>>n>>t>>q;
	for(int i=1;i<=n;i++){
		cin>>per[i].pos>>per[i].dir;
		per[i].id=i;
	}
	sort(per+1,per+n+1,cmp);
	for(int i=1;i<=q;i++)
		cin>>uni[i];
	for(int i=1;i<n;i++)
		if(per[i].dir==1&&per[i+1].dir==2&&per[i+1].pos-per[i].pos<=t*2)//如果有两个面对面，位置相邻，距离小于t*2的两个人，添加断点
			bek[++k]=(per[i+1].pos+per[i].pos)/2;
	sort(per+1,per+n+1,cmp_id);
	for(int i=1;i<=q;i++){
		if(per[uni[i]].dir==1&&lower_bound(bek+1,bek+k+1,per[uni[i]].pos+t)-lower_bound(bek+1,bek+k+1,per[uni[i]].pos)==0)//利用库函数lower_bound检测路程内是否含有断点
			cout<<per[uni[i]].pos+t<<'\n';
		else if(per[uni[i]].dir==2&&lower_bound(bek+1,bek+k+1,per[uni[i]].pos)-lower_bound(bek+1,bek+k+1,per[uni[i]].pos-t)==0)//同上，方向不同
			cout<<per[uni[i]].pos-t<<'\n';
		else if(per[uni[i]].dir==1)
			cout<<*lower_bound(bek+1,bek+k+1,per[uni[i]].pos)<<'\n';//确认含有断点，输出最近值
		else cout<<*(lower_bound(bek+1,bek+k+1,per[uni[i]].pos)-1)<<'\n';//同上，方向不同
	}
	return 0;
}
```
I'm Schwarzkopf Henkal.

---

## 作者：monstersecond (赞：1)

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#define INF 0x7fffffff
using namespace std;
typedef long long LL;
const int MAXN = 100000 + 5;

LL a[MAXN], ans[MAXN], r[MAXN];
int eid[MAXN];
bool used[MAXN];

struct East{
    LL pos;
    int id; //pos is 地点，id is 在 a[i]中编号 
    bool operator < (const East& x) const{
      return pos < x.pos;
    }
    East(LL x = 0, int y = 0):pos(x), id(y){}
}e[MAXN];

int main()
{
    freopen("in.txt", "r", stdin);
    LL n, t, q, cnt = 0, done = 1;
    scanf("%lld%lld%lld", &n, &t, &q);
    for(int i = 1; i <= n; i++){
      scanf("%lld%lld", &a[i], &r[i]);
      if(r[i] == 1) e[++cnt] = East(a[i], i), eid[i] = cnt;  
    }
    for(int i = 1; i <= n; i++)//eid is e[i]在a[i]编号 
      if(!eid[i])
        eid[i] = eid[i-1];
    e[cnt+1].id = INF;
    LL past = -1e18*2; 
    for(int i = 1; i <= n; i++){
      if(r[i] == 1) continue;
      int k = eid[i];
      if(k == 0 || used[k] || a[i] - a[e[k].id] > t + t){//没找到 
          if(a[i] - past > t)
          ans[i] = a[i] - t;
        else
          ans[i] = past;
        continue;
      }
      else{
        int j = e[k].id;
        LL met = a[i] / 2 + a[j] / 2;
        ans[i] = met;
        //[met-t, met] 内向东走的 
        int bri = lower_bound(e+done, e+eid[i], East(met-t, -1)) - e;
        for(int x = bri; x <= k; x++)
          ans[ e[x].id ] = met, used[x] = 1;
        //[met, met+t] 内向西走的 
        past = met;
      }
      done = k + 1;
    }
    for(int i = 1; i <= cnt; i++)
      if(!used[i])
        ans[e[i].id] = e[i].pos + t;
    for(int i = 1; i <= q; i++){
      int x;
      scanf("%d", &x);
      printf("%lld\n", ans[x]);
    }
    return 0;
}
```
注意t是long long

PS。二分没必要。。。


---

## 作者：HHC883 (赞：0)

# 题目分析
首先，若一个人初始方向为东，则他停下来的地方与他右边第一个初始方向为西的人停下来的地方是相同的；若一个人初始方向为西，则他停下来的地方与他左边第一个初始方向为东的人停下来的地方是相同的。于是，我们想到可以二分。于是，你掉进了坑里：以初始方向为东为例，若他与他右边第一个初始方向为西的人中间还有初始方向为东的人，则他右边第一个初始方向为西的人停下来的地方应当以中间的这个人为准。所以，我们要进行两次二分。注意，这个人可能永远停不下来，也有可能在特定时间内到不了他应该停下来的地方，需要特判。

时间复杂度为 $O(Q\log N)$。
# 参考代码
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
int n,t,q,ea[(int)1e5+5],we[(int)1e5+5],cnte,cntw;
struct person{
	int a,r;
} p[(int)1e5+5];
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>t>>q;
	memset(ea,0x3f,sizeof ea);
	memset(we,0x3f,sizeof we);
	for(int i=1;i<=n;i++){
		cin>>p[i].a>>p[i].r;
		if(p[i].r==1) ea[++cnte]=p[i].a;
		else we[++cntw]=p[i].a;
	}
	int x,nxt,bef,ans;
	while(q--){
		cin>>x;
		if(p[x].r==1){
			nxt=lower_bound(we+1,we+cntw+1,p[x].a)-we;
			bef=lower_bound(ea+1,ea+cnte+1,we[nxt])-ea;
			if(ea[bef]>we[nxt]) bef--;
			if(nxt>cntw) ans=p[x].a+t;
			else ans=(we[nxt]+ea[bef])>>1;
			if(ans-p[x].a>t) ans=p[x].a+t;
		}else{
			nxt=lower_bound(ea+1,ea+cnte+1,p[x].a)-ea;
			if(ea[nxt]>p[x].a) nxt--;
			bef=lower_bound(we+1,we+cntw+1,ea[nxt])-we;
			if(nxt<1) ans=p[x].a-t;
			else ans=(ea[nxt]+we[bef])>>1;
			if(p[x].a-ans>t) ans=p[x].a-t;
		}
		cout<<ans<<endl;
	}
	return 0;
}

```

---

## 作者：Supor__Shoep (赞：0)

真是一道随手写，一遍过的题目呢（~~老凡尔赛了~~）。

首先看到题目，就知道这是非常简单的小模拟题目。再看看数据范围，什么时间啊，坐标啊，都达到了 long long 级别，所以我们可以推断，这道题需要用数学计算法，解决实际应用问题。

由于当两个人相遇的时候就会停下来，之后的所有人到达这个位置后也会加入聊天，所以只要我们找到每一个相遇的位置，就相当于求出每个人左边，右边可以到达的最远的点（除了正负无穷）。但是每一个相遇的位置怎么求呢，难不成还有全部枚举一遍吗？显然没有必要，题目告诉我们，每个人的速度都是相等的，所以不存在超车这样的现象，这样的话，我们可以直接判断每一个 $i$ 和 $i+1$ 的方向是否分别为向右和向左，如果是的话，则两个点就会相遇，由于 $[1,i-1]$ 的人无法超过第 $i$ 个人，$[i+2,n]$ 的人也无法超过第 $i+1$ 个人，所以此时 $i$ 和 $i+1$ 的人相遇的地方就是一个可以让后来的人停下来的点。用代码写就是 $O(n)$ 的枚举，并且注意储存所有的相遇点。

然后我们就可以进行第 $i$ 个人左边，右边分别可以到达的最远的位置了，由于输入的位置是有序的，所以我们不用排序，直接顺次枚举。

最后输出的时候，如果方向向右，那么就加上 $t\times 1$ 的位移，与可到达最远点取最小值；如果方向向左，就减去 $t\times 1$ 的位移，与可到达最远点取最大值。注意判断左右无边界的时候。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=1e5+5;
int n,t,q;
struct node
{
	int now,fx,l,r;//初始位置，方向，左右分别可到达的最远点 
}a[MAXN];
int vis[MAXN];//0表示自己到达别人的相遇点中，1表示自己和他人创造了一个相遇点 
vector<int> v;//相遇点坐标 
signed main()
{
	cin>>n>>t>>q;
	for(int i=1;i<=n;i++)	cin>>a[i].now>>a[i].fx;
	for(int i=2;i<=n;i++)
	{
		//判断相遇点 
		if(a[i-1].fx==1&&a[i].fx==2)	vis[i]=vis[i-1]=1,v.push_back((a[i].now+a[i-1].now)/2);
	}
	v.push_back(2e18+1);//正无穷，用时间最大值(1e18)加初始坐标最大值(1e18)表示，加不加一无所谓 
	int cnt=0;//按顺序使用相遇点 
	int Last=-2e18-1;//负无穷 
	for(int i=1;i<=n;i++)
	{
		if(vis[i])	i++,Last=v[cnt++];//如果是创造相遇点的，就不用找最远点 
		a[i].l=Last,a[i].r=v[cnt];//左右可到达最远点赋值 
	}
	while(q--)
	{
		int x;
		cin>>x;
		if(vis[x])//分类讨论 
		{
			if(a[x].fx==1)	cout<<min(a[x].now+t,(a[x].now+a[x+1].now)/2)<<endl;
			else	cout<<max(a[x].now-t,(a[x].now+a[x-1].now)/2)<<endl;
			continue;
		}
		if(a[x].fx==1)	cout<<min(a[x].now+t,a[x].r)<<endl;
		else	cout<<max(a[x].now-t,a[x].l)<<endl;
	}
	return 0;
}
```

---

## 作者：ljt12138 (赞：0)

###写一个极其**诡异**的思路


**定理一**：如果从西向东顺次有A，B，C三人，再A与C发生相遇（如果会）之前，必然会有B先和A或B先和C相遇。这是显然的。换句话说，不会出现**跨过某人发生相遇**。这是一个明显的操作**具有顺序性**的提示。

**定理二**：把若干个运动状态相同的人看作一“组”，则每一组有且只有三种情况：静止，向西运动，向东运动。

**定理三**：对于任意相邻的两个组，他们相遇当且仅当他们相向而行或一个静止一个朝向另一个运动，且运动时间少于T。如果相向而行，相遇点在两组正中；否则在静止的那一组。


至此可以有一个大概的思路：维护一种元素A，包含其位置，运动状态，人。维护一个此元素栈，所有人开始视为独立的元素，自西向东按顺序入栈，如果一个元素A等待入栈：

1. 栈为空，则入栈

2. 栈顶元素与A在给定时间内不相遇，入栈

3. 栈顶元素与A在给定时间内相遇，将栈顶元素出栈，并在两者中点新建一个组，人为原先两组的人的并，标记为静止组。将栈顶元素和A中所有的人的位置更改为新位置。


由于定理1，该方法必然会使所有相遇**“顺序”**发生，因而不会出现抢人的问题。

人处于哪一组可以用并查集实现，注意对于无法与其他元素相遇的元素，输出时要特别处理。复杂度通过摊还分析，容易得知为$O(n\alpha (n))$。

语言表达能力和代码都捉急。。


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <stack>
using namespace std;
typedef long long ll;

int fa[100005];

inline int father(int i)
{
    return fa[i]?fa[i] = father(fa[i]):i;
}

inline void link(int i, int j)
{
    if (father(i) != father(j)) 
        fa[father(i)] = father(j);
}

ll pos[100005];

struct sb {
    ll first;
    int second;
    int pos;
    void print()
    {
        printf("-- %lld %d %d --\n", first, second, pos);
    }
};

sb make_p(ll a, int b, int c)
{
    sb n;
    n.first = a;
    n.second = b;
    n.pos = c;
    //cout << n.first << " " << n.second << " " << n.pos << endl;
    //n.print();
    return n;
}


sb sbs[100005];
sb sav[100005];
int did[100005];
ll n, t, q;
stack<sb> stk;

bool meet(const sb &a, const sb &b)
{
    if ((a.second == 0 && b.second == 2 && b.first - a.first <= t)
    || (a.second == 1 && b.second == 0 && b.first - a.first <= t)
    || (a.second == 1 && b.second == 2 && b.first - a.first <= 2*t)
    ) return true;
    return false;
}

ll place(const sb &a, const sb &b)
{
    if (a.second == 0) return a.first;
    if (b.second == 0) return b.first;
    return (a.first+b.first)>>1;
}

int main()
{
    memset(fa, 0, sizeof fa);
    memset(did, 0, sizeof did);
    make_p(1, -2, 3);
    scanf("%lld%lld%lld", &n, &t, &q);
    for (int i = 1; i <= n; i++) {
        ll a; int b;
        scanf("%lld%d", &a, &b);
        sbs[i] = make_p(a, b, i);
        sav[i] = sbs[i];
        //make_p(a, b, i).print();
        pos[i] = a;
    }
    for (int i = 1; i <= n; i++) {
        while (1) {
            if (stk.empty() || !meet(stk.top(), sbs[i])) {
                //stk.push(sbs[i]);
                break;
            } else {
                sb tmp = stk.top(); stk.pop();
                link(tmp.pos, sbs[i].pos);
                sb new_sb = make_p(place(tmp, sbs[i]), 0, tmp.pos);
                pos[father(tmp.pos)] = place(tmp, sbs[i]);
                did[i] = 1;
                did[tmp.pos] = 1;
                sbs[i] = new_sb;
            }
        }
        stk.push(sbs[i]);
        /*if (!stk.empty())
            stk.top().print();
        else
            puts("--nil--");*/
    }
    for (int i = 1; i <= q; i++) {
        int a;
        scanf("%d", &a);
        if (did[a] == 0) {
            if (sav[a].second == 1)
                printf("%lld\n", pos[father(a)]+t);
            else
                printf("%lld\n", pos[father(a)]-t);
        }
        else
            printf("%lld\n", pos[father(a)]);
    }
    return 0;
}
```

---


# [HAOI2014] 贴海报

## 题目描述

Bytetown 城市要进行市长竞选，所有的选民可以畅所欲言地对竞选市长的候选人发表言论。为了统一管理，城市委员会为选民准备了一个张贴海报的 electoral 墙。

张贴规则如下：

1. electoral 墙是一个长度为 $N$ 个单位的长方形，每个单位记为一个格子；

2. 所有张贴的海报的高度必须与 electoral 墙的高度一致的；

3. 每张海报以 `A B` 表示，即从第 $A$ 个格子到第 $B$ 个格子张贴海报；

4. 后贴的海报可以覆盖前面已贴的海报或部分海报。

现在请你判断，张贴完所有海报后，在 electoral 墙上还可以看见多少张海报。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/5209.png) 

**约束条件**

$10\le N \le 10000000,1\le M\le 1000,1\le A_i \le B_i \le 10000000$

所有的数据都是正整数，数据之间有一个空格。

## 样例 #1

### 输入

```
100 5
1 4
2 6
8 10
3 4
7 10
```

### 输出

```
4```

# 题解

## 作者：SovietPower✨ (赞：40)

这道题我有两种做法：线段树和浮水法（表示不会离散化，好在数据还用不到）。

1. 线段树 维护区间是否被染色：区间修改没被染色的点，标记，++ans；如果区间的点全被染过色，那ans不变。

2. 浮水法，专门解决这类区间染色问题：

记录某一个线段是不是（或者是有一部分）浮到了最上面。

上浮思想：设竖直平面中存在有一些高度不同的线段，当一个线段上方没有被其他线段挡着时，这个线段就可以上浮，如果一个线段（或是它的一部分）可以上浮到无限高，那么显然，这个线段（或这一部分）所在的高度是他所覆盖的这一个数轴范围内（将平面的无限低的地方看做有一个数轴）最高的。

浮水法其实是一个递归的过程，首先，当一条线段满足上浮的条件时，让他上浮（用 while 循环控制），但是当他不满足上浮的条件时，将他被挡住的那一段切掉，然后接着递归的让他剩下的那部分上浮。

（摘自http://www.cnblogs.com/SueMiller/archive/2011/08/05/2128794.html，网上没有很多相关的）


补代码：1.线段树

```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=10000005,M=1005;

int n,m,Ans,A[M],B[M];
bool flag,colored[N<<2];

int read()
{
    int now=0;char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')now=(now<<3)+(now<<1)+c-'0',c=getchar();
    return now;
}

void PushUp(int rt)
{
    colored[rt]= colored[rt<<1]&&colored[rt<<1|1];
}

/*void Build(int l,int r,int rt)
{
    if(l==r)
      return;
    int m=(l+r)>>1;
    Build(l,m,rt<<1);
    Build(m+1,r,rt<<1|1);
    PushUp(rt);
}*/

void Modify(int l,int r,int rt,int L,int R)
{
    if(colored[rt]) return;
    if(L<=l && r<=R)
    {
        flag=1;colored[rt]=1;
        return;
    }
    int m=(l+r)>>1;
    if(L<=m) Modify(l,m,rt<<1,L,R);
    if(m<R) Modify(m+1,r,rt<<1|1,L,R);
    PushUp(rt);
}

int main()
{
    freopen("ha14d.in","r",stdin);
    freopen("ha14d.out","w",stdout);
    n=read();m=read();
//    Build(1,n,1);
    for(int i=1;i<=m;i++)
      A[i]=read(),B[i]=read();
    for(int i=m;i>=1;i--)
    {
        flag=0;
        Modify(1,n,1,A[i],B[i]);
        if(flag) ++Ans;
    }
    printf("%d",Ans);
    fclose(stdin);fclose(stdout);
    return 0;
}
```
2.浮水法：

```cpp
#include<cstdio>
using namespace std;
const int N=10000005,M=1005;

int n,m,Ans,cur,A[M],B[M];
bool vis[M];

int read()
{
    int now=0;char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')now=(now<<3)+(now<<1)+c-'0',c=getchar();
    return now;
}

void Solve(int a,int b,int now)
{
    if(vis[cur]) return;
    while(now<=m && (a>=B[now]||b<=A[now]))//需要等于 
      ++now;
    if(now>m)
      ++Ans,vis[cur]=1;//printf("%d:%d--%d\n",Ans,a,b);
    if(a<A[now] && A[now]<b) Solve(a,A[now],now+1);//不能等于 
    if(b>B[now] && B[now]>a) Solve(B[now],b,now+1);
}

int main()
{
//    freopen("ha14d.in","r",stdin);
//    freopen("ha14d.out","w",stdout);
    n=read();m=read();
    for(int i=1;i<=m;i++)
      A[i]=read(),B[i]=read(),++B[i];//右端点再加1，因为两端点是都不能放其他海报的(看不见) 
    for(cur=m-1;cur>=1;cur--)
      Solve(A[cur],B[cur],cur+1);
    printf("%d",++Ans);
//    fclose(stdin);fclose(stdout);
    return 0;
}
```
其实还可以暴力 ：这题数据真水，暴力就能ac。cogs上加强了数据暴力只能80（还是挺高的）。


---

## 作者：yzhang (赞：25)

## [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/9932483.html)

#### woc，今天已经是day -1了

#### 再写一颗珂朵莉树来++rp吧

#### 否则就要AFO了qaq

#### 这有可能是我最后一篇题解/博客qaq

#### 原题传送门：[P3740 [HAOI2014]贴海报](https://www.luogu.org/problemnew/show/3740)

#### 考前刷水题到底是对还是错qaq

#### 反正这题是很水

## 前置芝士：珂朵莉树

### [窝博客里对珂朵莉树的介绍](https://www.cnblogs.com/yzhang-rp-inf/p/9443659.html )

### 没什么好说的自己看看吧

#### 每贴一张海报暴力assign_val

#### 最后用桶排思想统计一下即可

```cpp
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define IT set<node>::iterator
using namespace std;
inline int read()
{
    int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    return x*f;
}
struct node
{
    int l,r;
    mutable int v;
    node(int L, int R=-1, int V=0):l(L), r(R), v(V) {}
    bool operator<(const node& o) const
    {
        return l < o.l;
    }
};
set <node> s;
IT split(int pos)
{
    IT it = s.lower_bound(node(pos));
    if (it != s.end() && it->l == pos) 
        return it;
    --it;
    int L = it->l, R = it->r, V = it->v;
    s.erase(it);
    s.insert(node(L, pos-1, V));
    return s.insert(node(pos, R, V)).first;
}
void assign_val(int l,int r,int val)
{
    IT itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,val));
}
bool vis[1005];
int main()
{
    int n=read(),m=read();
    s.insert(node(1,n+5));
    for(register int i=1;i<=m;++i)
    {
        int l=read(),r=read();
        assign_val(l,r,i);
    }
    int res=0;
    IT itr=split(n+1),itl=split(1);
    for(;itl!=itr;++itl)
        if(!vis[itl->v]&&itl->v>=1&&itl->v<=m)
        {
            ++res;
            vis[itl->v]=true;
        }
    printf("%d",res);
    return 0;
}
```

# 最后，我为众大佬送上蒟蒻的祝福

```cpp
#pragma GCC optimize("O2")
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define I_ak_ioi using namespace std;
I_ak_ioi; 
struct NOIP{
	int rp;
	int score;
	int rank;
}NOIP2018;
int main()
{
	while(19260817)
	{
		++NOIP2018.rp;
		NOIP2018.score=AK;
		NOIP2018.rank=1;
	}
	return 0;
}
```

---

## 作者：Azazеl (赞：17)

$\ \ \ \ \ \ \ $本题所用的算法除了线段树,还可以用浮水法,本篇题解将详细介绍该方法
#### 1.简介  
$\ \ \ \ \ \ \ $这个算法的受众面似乎很小呢,目前好像除了**区间染色问题**之外没有什么其他的题可用了。但它可以节省不少码量的,调试难度更小一些。~~想想区间染色问题一般是什么算法~~  

#### 2.大致思路  
$\ \ \ \ \ \ \ $我们先放一道 ~~板~~ 例题[浴谷链接](https://www.luogu.com.cn/problem/P3740)  
 
$\ \ \ \ \ \ \ $上面这道题浮水法的思路其实很简单。我们只要把整个看成一池池水。（雾  
$\ \ \ \ \ \ \ $具体的话,我们举个例子。  
```
100 3
1 9
2 4 
6 8
```
$\ \ \ \ \ \ \ $首先建一个平面直角坐标系,每一个整点我们都可以放上一个数字表示那是第几幅海报。  
$\ \ \ \ \ \ \ $倒序(最后贴上去的一定是能看到的)遍历每一幅海报,把第 $i$ 幅海报先在 $y=i$ 这条直线上对应的位置放好。  
$\ \ \ \ \ \ \ $举个例子,最后两幅海报放上去就会成这个样子。    
![THEVZZ82~6D5QA1__3QZYJ7.png](https://i.loli.net/2020/01/29/y2QTm5P163aSJzW.png)  
$\ \ \ \ \ \ \ $由于棕色海报前面没有任何遮挡,因此它是可以被看见的,$ans+1$ 。  
$\ \ \ \ \ \ \ $再放一幅上去,图就是这个样子.  
![YRZ_NM8_JDV61P_SD9~Y989.png](https://i.loli.net/2020/01/29/tHa7JgrTN6chjns.png)  
$\ \ \ \ \ \ \ $由于紫色海报一部分前面还是没有遮挡,因此它可以被看见。  
$\ \ \ \ \ \ \ $可惜电脑不像人一样,能够一眼看出来之前有没有遮挡。所以对于每一幅海报,我们可以将它没有被上一幅海报覆盖的区间上浮,其余的留在原处.最后只要有任意一部分浮到最顶端就可以判断它能被看到.    
$\ \ \ \ \ \ \ $刚刚那幅图上浮一次变成  
![6U_JG8KFU_B8_`WW~H_DE8A.png](https://i.loli.net/2020/01/29/hEImnUPfu6v3C8L.png)  
$\ \ \ \ \ \ \ $再上浮一次变成  
![`5F5JM7`_2P5DQL~_9ALVX2.png](https://i.loli.net/2020/01/29/shSGLETg6crPfRu.png)  
$\ \ \ \ \ \ \ $然后由于它已经上浮到最表面了,因此它是可以被记入答案的.  
$\ \ \ \ \ \ \ $对于之后的每一幅海报,我们都做一次这样的上浮即可.  

#### 3.实际实现  
$\ \ \ \ \ \ \ $首先先声明,这个算法其实是玄学复杂度( $\Theta(N+$很小的常数$)$ )(不会证明),但是它跟线段树是差不多的.请放心食用。  
$\ \ \ \ \ \ \ $对于每一幅先贴上去的海报,它最多有三种情况,**左半部分、被挡住部分、右半部分**  
$\ \ \ \ \ \ \ $所以我们用 $while$ 循环不停地对比它是否能整体直接上浮并进行操作,如果不能就只能把它拆成两部分(**左半部分、右半部分**)进行上浮,依次类推,直到上浮至最高层.  
$\ \ \ \ \ \ \ $所以这个操作也告诉我们这是**递归**。

$\ \ \ \ \ \ \ $具体操作时还有两个注意事项:  
$\ \ \ \ \ \ \ 1.$如果有线段刚好端点相接的情况也是要算覆盖的,但是实际时不会被计算,因此我们让右端点延长 $1$ 个单位长度即可.  
$\ \ \ \ \ \ \ 2.$它有可能会在递归过程中多次上浮同一条线段的不同部分,因此我们需要开 $vis$  

$$\mathcal{CODE}$$  
```cpp
#include <cstdio>
bool vis[1005];
int n,m,ans,A[1005],B[1005];
void Solve(int a,int b,int now,int num)
{
    if(vis[num]) return;//Warning 2
    while(now<=m&&(a>=B[now]||b<=A[now])) now++;
    if(now>m) ans++,vis[num]=1;
    if(a<A[now]&&A[now]<b) Solve(a,A[now],now+1,num); 
    if(b>B[now]&&B[now]>a) Solve(B[now],b,now+1,num);
}

int main() {
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++) 
	{
		scanf("%d %d",&A[i],&B[i]);	
		B[i]++;//Warning 1
	}
    for(int i=m-1;i>=1;i--) Solve(A[i],B[i],i+1,i);
    printf("%d",ans+1);
    return 0;
}
```



---

## 作者：心灵间的跳跃 (赞：17)

## 本蒟蒻发布下题解，请勿喷
## 我比较弱，在老师（~~超神犇~~）和同学（~~神犇~~）的全力讲解下，终于会了线段树的解题方法（~~然而只会线段树~~）
# 区间树和点树都可以，先讲区间树(只讲大意)
![69519](https://cdn.luogu.com.cn/upload/pic/69519.png )
## 看清题目的输入要求，虽然题目输入的是1到4，但是因为题目给的数据是单位区间而不是坐标，所以真实的坐标表示应该是1到5
```cpp
for(int j=1;j<=m;j++)     
      {
      scanf("%d%d",&b[j].l,&b[j].r); 
       b[j].r++;//需要加1，来表示真实坐标    
       k[++id]=b[j].l;
       k[++id]=b[j].r;
       //k数组把坐标记下来，待会要用
      } 
```
## 然后，再注意一下，题目给的海报长度n<=10000000,因为线段树的构造原理，我们至少要建4乘以长度，同时时间复杂度（n*log(n)），所以直接处理的话，肯定就炸了，所以我们要离散化
```cpp
    sort(k+1,k+2*m+1);//排序操作
    int num=unique(k+1,k+2*m+1)-k;//去重操作
    get(1,1,num);//这时候进行建树操作，树最长也就是2*m，当然就不会炸了
    for(int j=1;j<=m;j++)
     {
      int l=lower_bound(k+1,k+num,b[j].l)-k;  
      //lower_bound()用来找出第一个大于等于你的数的位置
      int r=lower_bound(k+1,k+num,b[j].r)-k;        
      ins(1,l,r,j);//插入操作。   
     }
```
## 在这里要着重的一个问题，就是去重，因为如果你不去重的话，原来与你共点的点，和原来和你相邻的点，都会增加一段不存在的距离，而导致数据错误，这里其实还涉及了一个问题，但我们在点树讲
# 插入操作
```cpp
void ins(int rt,int l,int r,int k)
{
 if(l>=a[rt].r || r<=a[rt].l)    
     return;//因为是区间树，所以重点无交集，算是相离状况
      //而点树不算相离状况
 if(l<=a[rt].l && a[rt].r<=r)
    {
      a[rt].c=k;         
      return;//只有在覆盖区间的时候，才进行染色
    }    
 pushd(rt);
 ins(rt<<1,l,r,k);
 ins(rt<<1|1,l,r,k);
 pushup(rt);
}
 ```
# pushd()与pushup()涉及了线段树的延迟操作（lazy）
## 当你要覆盖颜色的区域与你当前节点的区域相交时，你不能直接去改变子节点的颜色，因为上一次的改变只停留在父节点，所以要把父节点的信息传给子节点
```cpp
void pushd(int rt)
{
 if(a[rt].c!=-1)//-1表示杂色，如果本身是杂色，则不需要向下传递    
  {
  a[rt<<1].c=a[rt<<1|1].c=a[rt].c;                                    
  }   
}
```
## 然而子节点的情况也会影响父节点（改变子节点可把父节点由纯色改为杂色，也可由杂色改为纯色）
```cpp
void pushup(int rt)
{
 if(a[rt<<1].c==a[rt<<1|1].c)
    a[rt].c=a[rt<<1].c;    
 else
   a[rt].c=-1;    
}
```

# 然后查询
```cpp
void an(int rt)
{
  if(a[rt].c>0)
  {
   if(!col[a[rt].c])//用一个数组，来看颜色是否出现过，避免重复             
     {
      col[a[rt].c]=1;
      ans++;                           
     }    
   return;//查到纯色，便不再往下查     
  }
 if(a[rt].l+1==a[rt].r)
     return;//最终叶节点
 pushd(rt);//因为可能插入的时候没有穿越
         //所以仍要往下传递
 an(rt<<1);
 an(rt<<1|1);
}
```

## 从树的根节点开始查，查询有多少种颜色，注意：在建树的时候，必须要给树上底色，查询的时候查到底色，是不能算作海报的
# 现在来讲点树（区别在离散化，其余都一样）
## 前面说到题目在输入数据的时候，是在输入单位区间，所以右界要加加，但那是因为区间树的叶节点是一个区间
## 但是点树的叶节点是单独的一个点，所以我们就可以把单位区间看作一个点，所以右界不需要加加，直接输入就好了
## 然后重点来了，离散化（认真看，难点就在这里）![69544](https://cdn.luogu.com.cn/upload/pic/69544.png )
## 这是离散化的效果图（假设底部还有颜色）
## 如果是区间树的话，（1,2）与（2,3）是相离的，（2,3）与（3,4）是相离的，所以（2,3）区间代表了原（3,5）区间，所以（3,5）区间仍然存在（有同学可能会想这会不会把原相邻的改为不相邻，不用担心，在区间树时，我们把r进行了加加，所以离散化时处理的是二次数据，原相邻的变成了交集，而原空一个的变成了相邻，所以不影响）
## 但如果是点树，（2,2）和(3,3)都是点，而它们共同影响了（2,3），所以原（3,5）区间消失了，所以在离散化时要判断这一点与上一点是否相邻，如果不相邻，则要隔开
```cpp
    sort(x+1,x+k+1);
      x[0]=-1;//预防第一位是0的情况
      k=0;//计数
      for(int i=1;i<=n*2;i++)
      {
        
         if(x[i]!=x[i-1])
           x[++k]=x[i];//去重操作
      }
      for(int i=k;i>=1;i--)
      {
        if(x[i]！=x[i-1]+1)
          x[++k]=x[i-1]+1;//有空隙则创造新数据
      }
      sort(x+1,x+k+1);//再排序，原相邻的数据就隔开了
      get(1,1,k);
      for(int i=1;i<=n;i++)
      {

        int l,r;
        l=lower_bound(x+1,x+k+1,b[i][0])-x;
        r=lower_bound(x+1,x+k+1,b[i][1])-x;
        ins(1,l,r,i);   
      }
```










---

## 作者：0x80mem (赞：8)

这题可以换一个思路，将海报倒着“贴”，每一个海报贴到之前海报的下面，如果没有被遮挡，则ans++

具体内容见代码:
```cpp
#include <cstdio>
#include <algorithm>
#include <set>

using namespace std;

const int INF = 0x3f3f3f3f;

struct Seg
{
    int a;
    int b;
    bool operator < (const Seg& s) const 
    { return a < s.a; }
};

int N, M;
int ans = 0;
set<Seg> S; //墙上被海报覆盖的区域
Seg A[1005];

inline int Union(Seg a, Seg b)
{
    if (a.b < b.a || b.b < a.a) return 0;
    return min(a.b, b.b) - max(a.a, b.a) + 1;
}

int main()
{
    scanf("%d%d", &N, &M);
    for (int i = 1; i <= M; i++) scanf("%d%d", &A[i].a, &A[i].b);
        
    S.empty();   
    for (int i = M; i >= 1; i--)
    {
        Seg& p = A[i];
        Seg seg = (Seg){INF, 0};
    	int spac = p.b - p.a + 1;//海报在墙上的面积
        //防止海报贴在 "————  ————" 中间的区域
        
        for (set<Seg>::iterator j = S.begin(); j != S.end() && spac > 0;)
        {
            Seg s = (Seg)(*j); j++;
            spac -= Union(s, p);
            if (!(s.b < p.a || p.b < s.a)) //海报与已覆盖区域相交
            {
                seg = (Seg){min(seg.a, s.a), max(seg.b, s.b)};//取并集
                S.erase(s);
            }
        }
        
        if (spac > 0) ans++; //海报露出
        
        if (seg.b < p.a || p.b < seg.a) S.insert(p); 
        //海报与所有已覆盖区域不相交, 建立一个新区域
        else S.insert((Seg){min(seg.a, p.a), max(seg.b, p.b)});
    }
    printf("%d\n", ans);
    return 0;
} 
```

---

## 作者：BLUESKY007 (赞：6)

（呃。。。本蒟蒻的第一篇题解qwq）。。不废话了讲正题。。思路来源于铺地毯（[-->传送门](https://www.luogu.org/problemnew/show/P1003)）。。先算出每一个格子上覆盖的海报并把可见的海报做标记然后算出有多少海报是可见的。。但是作为省选题怎么可能会那么简单。。所以加了两个小优化。。缩小范围和标配快读。。。下面放AC代码。。。
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>

using namespace std;

void R(int &x){
    int f=1;
    x=0;
    char s=getchar();
    while(s<'0'||s>'9'){
        if(s=='-'){
            f=-1;
        }
        s=getchar(); 
    }
    while(s>='0'&&s<='9'){
        x=x*10+s-'0';
        s=getchar();
    }
    x*=f;
}

const int MAXN=10000001;

int main(){
    int n,m;
    R(n);
    R(m);
    int a[m+1],b[m+1],f[m+1];
    int beginmi=MAXN,endma=0;
    for(int i=1;i<=m;i++){
        R(a[i]);
        R(b[i]);
        f[i]=0;
        beginmi=min(beginmi,a[i]);
        endma=max(endma,b[i]);
    }
    for(int i=beginmi;i<=endma;i++){
        for(int j=m;j>=1;j--){
            if(i<=b[j]&&i>=a[j]){
                f[j]=1;
                break;
            }
        }
    }
    int ans=0;
    for(int i=1;i<=m;i++){
        ans+=f[i];
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：fastle (赞：5)

这里写题解

倒序染色（这样染完的颜色就不会被覆盖），线段树维护是否染色，每次染色时加入区间，若成功染色，答案 ++

线段树更新时更新到最底层子节点及不需要下传标记，但需要回溯时的上传更新

```cpp
#include<cstdio>
#define maxn 10000001
using namespace std;
int n,m,ans = 0;
bool flag;
int b[2001];
int e[2001];
bool tree[maxn * 4];
void update(int now)//左右两个区间 都染色了，那么这个区间也染完了
{
    tree[now] = tree[now << 1] && tree[now << 1 | 1];
}
int read()
{
    int num = 0;
    int f = 1;
    char c = getchar();
    while (c > '9' || c <'0')
    {
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        num *= 10;
        num += c - '0';
        c = getchar();
    }
    return f * num;
}
void add(int l,int r,int now,int ln,int rn)
{
    if(l > rn ||r < ln)return;
    if(tree[now])return;
    if( l == r) //染色的最底层节点
    {
        flag = true;
        tree[now] = true;
        return;
    }
    int mid = (l + r) >> 1;
    add(l,mid,now << 1,ln,rn);
    add(mid + 1,r,now << 1 | 1,ln,rn);
    update(now);
}
int main()
{
    n = read();m = read();
    for(int i = 1;i <= m;i ++)
    {
        b[i] = read();e[i] = read();
    }
    for(int i = m;i >= 1;i --)
    {
        flag = false;
        add(1,n,1,b[i],e[i]);
        if(flag)ans ++;    //若染色增加计数器
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：万物一 (赞：5)

# 年纪轻轻写什么线段树，你说珂朵莉树不香么？？？

不懂珂朵莉树的同学可以看看oi wiki的[介绍](https://oi-wiki.org/ds/odt/)

简单来说珂朵莉树的原理就是维护拥有相同元素的区间

```cpp
struct Node {
	mutable int l, r;
	mutable int id;
	auto operator<(const Node & o) const -> bool {
		return l < o.l;
	}
};
```
具体到本题就是将一整张海报的区间当作一个节点，每个不同的海报的区间染上不同的颜色，加入新的海报就相当于珂朵莉树的  _assign_  操作

最后暴力的扫一遍[1, 0] (整个墙)这个区间 记录访问到的颜色的种类(初始时整个墙围一整个区间 颜色id为0)

```cpp
#include <iostream>
#include <algorithm>
#include <set>

using namespace std;

struct Node {
	mutable int l, r;
	mutable int id;
	auto operator<(const Node & o) const -> bool {
		return l < o.l;
	}
};
using Iter = set<Node>::iterator;

set<Node> odt;

//用于记录颜色的集合
set<int> colors;

auto split(int p) -> Iter {
	auto it = odt.lower_bound(Node {p, 0, 0});
	if(it != odt.end() && it->l == p) {
		return it;
	}
	--it;
	auto x = *it;
	odt.erase(it);
	odt.insert(Node {x.l, p - 1, x.id});
	return odt.insert(Node {p, x.r, x.id}).first;
}

auto assign(int x, int y, int id) -> void {
	//记得先split y + 1 再 split x
	auto iterR = split(y + 1);
	auto iterL = split(x);
	odt.erase(iterL, iterR);
	odt.insert(Node {x, y, id});
}

auto countColor(int x, int y) -> int {
	auto iterR = split(y + 1);
	auto iterL = split(x);
	for(; iterL != iterR; ++iterL) {
		if(iterL->id != 0) {
			colors.insert(iterL->id);
		}
	}
	//size即为颜色数
	return colors.size();
}

int main() {
	//加速cin cout
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n, m;
	cin >> n >> m;
	//初始时整个区间颜色id为0
	odt.insert(Node {1, n, 0});
	for (int i = 1; i <= m; ++i) {
		int l, r;
		cin >> l >> r;
		//给海报区间染色 每个区间颜色不同
		assign(l, r, i);
	}
	cout << countColor(1, n) << endl;

	return 0;
}
```
 

---

## 作者：hehelego (赞：5)

# talk is cheep show me the code

本题可以当作模板题，算是比较经典的。

这种线段覆盖的问题的套路，一般是“浮水法”，或者搞个并不需要写完整的线段树。

思路还是很清楚的，倒序处理：
	
        对于某张海报：若存在某一部分没有被完全覆盖
        那么 1. 在它之前的对它没有影响
             2.在它之后的海报已经被处理过了。
        所以这张海报可见
        
为什么说线段树并不需要写完整呢，emmm

1. build可以省了，懒得解释
1. lazy标记可以扔了，如果某个区间被完全覆盖了，那也不用向它的子区间搜索了，所以不向下传递覆盖信息也是没问题的。
1. 维护？不存在的。

本题数据量很小，不需要离散化，但是您要是写了这样的东西
```
int L[N<<2],R[N<<2]
```
那也是会MLE的，所以我们写成下面这个样子，调用insert(modify)时，把当前区间的左右边界传进去。见代码。
线段树这个东西，最好还是背两套模板，一套简单容易理解的（可以看sol的讲义，或者juruo的我发的题解），一套省了存储每个区间左右端点的（可能比起前者多写个10行左右）


```
//P3740 [HAOI2014]
#include <iostream>
#include <algorithm>

using namespace std;
const int N=10000000+1;
const int M=1000+10;
int Cover[N<<2];
int n,m;
int ans;
int a[M],b[M];
#define lc(o) (o<<1)
#define rc(o) ((o<<1)|1)
void pushup(int o){
  Cover[o]=(Cover[lc(o)]&Cover[rc(o)]);
}
int beCovered=1;
void insert(int o,int l,int r,int L,int R){
  if(Cover[o]) return ;
  if(l<=L&&R<=r&&(!Cover[o])){
    Cover[o]=1;
    beCovered=0;
    return ;
  }
  int mid=(L+R)>>1;
  if(l<=mid)
    insert(lc(o),l,r,L,mid);
  if(r>mid)
    insert(rc(o),l,r,mid+1,R);

  pushup(o);
}
int main(){
  cin>>n>>m;
  for(int i=0;i<m;i++)
    cin>>a[i]>>b[i];

  for(int i=m-1;i>=0;i--){
    beCovered=1;
    insert(1,a[i],b[i],1,n);
    if(!beCovered) ans++;
  }
  cout<<ans<<endl;

  return 0;
}

```



---

## 作者：fkxr (赞：4)

大家好，我非常喜欢分块，看题解区没有讲分块的，所以来水一篇分块题解

题目实际在求经过 $m$ 次染色，还可以看到颜色的种类数。

把表示颜色数组分为若干个块长不超过 $\sqrt{n}$ 的块。建一个数组 $tag$ 表示每块的“统一染色标记”，为 $0$ 表示没有统一被染色，否则这一块被统一染成 $tag_i$。

对一个大的区间染色需单独处理两端（有标记先清空标记并染上标记的颜色，再修改每个被大的区间包含的数），中间可以打标记，查询一个位置时，如果它所在的区间被打了标记则他的颜色是它区间所打的标记。

### Code：

```
#include <bits/stdc++.h>
using namespace std;
int n,m;
unsigned short id[10000007];
unsigned short c[10000007];
int tag[3503];
int len=0;//块长
inline void change(int l,int r,int sum){
    int q=id[l],w=id[r];
    if(q==w){
        for(int i=q*len;id[i]==q;++i){
            if(i>=l&&i<=r){
                c[i]=sum;
            }else if(tag[q]){
                c[i]=tag[q];
            }
        }
        tag[q]=0;
        return ;
    }
    for(int i=q*len;id[i]==q;++i){
        if(i>=l&&i<=r){
            c[i]=sum;
        }else if(tag[q]){
            c[i]=tag[q];
        }
    }
    tag[q]=0;
    for(int i=w*len;id[i]==w&&i<=n;++i){
        if(i>=l&&i<=r){
            c[i]=sum;
        }else if(tag[w]){
            c[i]=tag[w];
        }
    }
    tag[w]=0;
    for(int i=q+1;i<w;++i){
        tag[i]=sum;
    }
}
inline void rr(int &a){
    a=0;
    char ch=getchar_unlocked();
    for(;!(ch>='0'&&ch<='9');){
        ch=getchar_unlocked();
    }
    for(;(ch>='0'&&ch<='9');){
        a=(a<<1)+(a<<3)+(ch^48);
        ch=getchar_unlocked();
    }
}
int vis[1003];
signed main() {
    rr(n),rr(m);
    len=sqrt(n);
    for(int i=0;i<=n;++i){
        id[i]=i/len;
        //第i个点在第i/len块（下标0开始）
    }
    for(int i=1;i<=m;++i){
        int l,r;rr(l),rr(r);
        change(l,r,i);
    }
    for(int i=1;i<=n;++i){
        vis[(tag[id[i]]?tag[id[i]]:c[i])]=1;
    }
    int ans=0;
    for(int i=1;i<=m;++i){
        ans+=vis[i];
    }
    cout<<ans;
	return 0;
}
/*
显然时间复杂度是O(m*sqrt(n))的
常数小，可以通过测试
*/
```
[AC记录](https://www.luogu.com.cn/record/185874748)

---

## 作者：Flanksy (赞：4)

### 并查集

------------

#### 分析

题意：给出一个长度为 $n$ 的序列和 $m$ 次操作，第 $i$ 次操作指定一个区间 $[l,r]$ 使得区间中所有元素的颜色都变为 $i$。求所有操作结束后序列中不同颜色的数量。

由于只需要所有操作结束后序列的信息，该问题可以离线求解。

**性质：时间较晚的染色操作覆盖时间较早的染色操作。**

反转时间轴，从最后一次操作开始染色。元素第一次被染上的颜色就是所有操作结束后的颜色，一旦被染色就可以不再考虑。

------------

#### 实现

因为元素只会从未染色的变成已染色的，可以使用**并查集**维护序列。具体地，维护序列的**连通性**。

使用 $f_i$ 表示元素 $i$ 在并查集中的根节点。类比最小生成树，当 $f_u = f_v$ 时节点 $u$ 与 $v$ 连通。**维护序列时，当且仅当所有符合 $i \in [u,v]$ 的元素 $i$ 被染色时认为 $u,v$ 连通。** 当 $l,r$ 连通且 $l-1$ 与 $r+1$ 未被染色或超出序列范围时，称 $[l,r]$ 为一个极长连通块。

**每个极长连通块与其左边的第一个元素形成一个集合，集合的根节点为连通块左边第一个元素（不在连通块内）。** 这个元素显然是未染色的，否则就不符合极长连通块的定义。如此一来，通过询问元素在并查集中的祖先就可以快速找到该元素左边第一个未染色的元素（如果元素未染色则找到的是元素本身）。**可以发现一个元素未被染色当且仅当 $f_i=i$。**

删除操作只需要让被删除的元素不再被遍历到，如果想要删除元素 $i$，简单地将元素 $i$ 所在的集合合并到元素 $i-1$ 所在的集合即可。**删除操作的合并是有次序的，如果将 $i-1$ 所在的集合合并到 $i$ 所在的集合，并查集找到的就不是每个元素左边第一个未染色的元素了。** 每个元素一旦被染色就需要删除，因此删除操作至多执行 $n$ 次。

代码总体时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$，**由于空间开销过大无法通过此题**。代码中从右到左染色是为了防止越界。

注意：如果在开始染色时没有调用并查集初始化，可能会修改到已经染色的元素。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Post{int l,r;}s[1001];
int n,m,ans,f[10000001],c[10000001];
bool on[1001];
int ask(int x){return x==f[x] ? x:f[x]=ask(f[x]);}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=1;i<=m;i++) scanf("%d%d",&s[i].l,&s[i].r);
    for(int i=m;i>=1;i--)
        for(int j=ask(s[i].r);j>=s[i].l;j=ask(j-1))//调用并查集初始化
            c[j]=i,f[j]=j-1;
    for(int i=1;i<=n;i++) if(c[i]&&!on[c[i]]) on[c[i]]=1,++ans;
    printf("%d\n",ans);
    return 0;
}
```

**递归实现**的路径压缩并查集会开爆栈，而使用**循环实现**的路径压缩并查集可以通过本题。

代码总体时间复杂度 $O(n \log n)$，空间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Post{int l,r;}s[1001];
int n,m,ans,top,f[10000001],c[10000001],v[10000001];
bool on[1001];
int ask(int x){
	while(f[x]!=x) v[++top]=x,x=f[x];
	while(top) f[v[top]]=x,--top;//路径压缩 
	return x;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=1;i<=m;i++) scanf("%d%d",&s[i].l,&s[i].r);
    for(int i=m;i>=1;i--)
        for(int j=ask(s[i].r);j>=s[i].l;j=ask(j-1))//调用并查集初始化
            c[j]=i,f[j]=j-1;
    for(int i=1;i<=n;i++) if(c[i]&&!on[c[i]]) on[c[i]]=1,++ans;
    printf("%d\n",ans);
    return 0;
}
```

------------

#### 离散化

将序列**离散化**后再染色可以通过此题。事实上离散化后暴力染色的做法时间复杂度为 $O(m^2)$，空间复杂度为 $O(m)$，完全可以通过本题，但笔者是为了并查集做法写的题解，所以还是写并查集了。

**只对区间的左右端点离散化无法通过此题。** 这会导致序列原有的信息丢失。

在离散化时额外加入**区间右端点右边的元素**和**区间左端点左边的元素**即可使染色操作在正确位置中止。实际上从右到左染色时加入左端点左边的元素已经足够保证正确性，从左到右则相反。

[Code](https://www.luogu.com.cn/paste/nqsg47yh)

时间复杂度 $O(m\log m)$，空间复杂度 $O(m)$，能够通过全部测试点。

---

## 作者：ddwqwq (赞：3)

这道题我算了算空间，发现线段树恐怕要动态开点，太麻烦了，于是就写了离散化加上暴力。  
但是直接离散化是不行的。考虑这样的三个区间：[1,5][1,2][4,5]，如果用标准的离散化，就会出现错误。因为标准的离散化把区间二和区间三的两个端点放在了一起，导致第一个区间被完全覆盖。  
考虑离散化的本质：在不改变数据的可用性质的情况下，减小其范围。一般情况下，我们离散化只需要保留数据间的大小关系这一个性质，所以可以直接用排序后的编号代替原本数值。但是现在，我们需要同时保留两个性质：大小关系和是否相邻。怎么办呢？还是排序，之后，对于两个差大于2的数，把他们的差缩小到2。也就是说，把所有大于2的间隔改为2。这样就可以同时保留两个性质了。
代码：
```
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>

#pragma warning(disable:4996)
#define INF 2000000005//2 * 10^9
#define lowbit(a) ((a)&-(a))
inline long long max(long long a, long long b)
{
	return a > b ? a : b;
}
inline long long min(long long a, long long b)
{
	return a < b ? a : b;
}

const int MAXN = 5005;

struct data {
	int id;
	int w;
	bool operator < (data t)
	{
		return w < t.w;
	}
};

data temp[MAXN];

void msort(data *a, int l, int r)
{
	if (l == r)
		return;
	int mid = (l + r) / 2;
	msort(a, l, mid);
	msort(a, mid + 1, r);
	int i = l, j = mid + 1, k = l;
	while (k <= r)
	{
		if (j > r || i <= mid&&a[i] < a[j])
			temp[k++] = a[i++];
		else
			temp[k++] = a[j++];
	}
	for (i = l; i <= r; i++)
		a[i] = temp[i];
}

int xxx, N;
int l[MAXN], r[MAXN];
data a[MAXN];

void init()
{
	int i;

	scanf("%d %d", &xxx, &N);
	for (i = 1; i <= N; i++)
	{
		scanf("%d %d", &a[i * 2].w, &a[i * 2 + 1].w);
		a[i * 2].id = i * 2;
		a[i * 2 + 1].id = i * 2 + 1;
	}
	msort(a, 2, N * 2 + 1);

	int cnt = 0;
	for (i = 2; i <= N * 2 + 1; i++)
	{
		if (i == 2 || a[i].w != a[i - 1].w)
			cnt++;
		if (a[i].w - a[i - 1].w > 1)
			cnt++;
		if (a[i].id & 1)
			r[a[i].id / 2] = cnt;
		else
			l[a[i].id / 2] = cnt;
	}
}

int t[MAXN];

void cover(int l, int r, int k)
{
	for (int i = l; i <= r; i++)
		t[i] = k;
}
bool judge(int l, int r)
{
	for (int i = l; i <= r; i++)
		if (!t[i])
			return true;
	return false;
}

int main()
{
	init();

	int cnt = 0;
	for (int i = N; i >= 1; i--)
		if (judge(l[i], r[i]))
		{
			cnt++;
			cover(l[i], r[i], 1);
		}

	printf("%d", cnt);

	system("pause");
	return 0;
}
```

---

## 作者：_Arahc_ (赞：2)

这道题题解里各位都用的线段树、浮水法，本蒟蒻完全不会，这里给出我的方法，既没有线段树也没有浮水法，较为易懂（?）。

可以发现$n$的范围极其大，但是$m$的范围很小，只有1000，所以可以想到一个大致为$m^2$的算法。

假设输入顺序代表时间顺序，一行为一天（这样好理解）

每当一张海报贴到墙上时，只需要知道这张海报对以前贴的海报造成了什么影响即可。

具体修改方法：通过修改一张海报左端点右端点位置实现。

假设一张海报左端点为$l_i$，右端点为$r_i$

（注：下列图中红色表示以前贴的海报，蓝色表示今天贴的海报）

-  情况一：完全覆盖，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/mdti1arm.png)

可以专门设计一个bool数组，$u_i=1$表示这个海报没有用了。

- 情况二：毫不相关，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/t5zacxo1.png)

这时我们不用管就行。

- 情况三：覆盖了左边部分，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/kp7szukv.png)

此时要将红色海报的左端点挪到蓝色海报右端点的右边。

因为红色海报的地盘被蓝色海报盖掉了一部分，那一部分已经不再是红色海报的地盘了，可以视为红色海报本来就没有这个地盘。

- 情况四：覆盖了右边部分，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/vbca6gly.png)

将红色海报的右端点挪到蓝色海报左端点的左边。

- 情况五，也是最麻烦的，刚好劈开了以前的海报，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/p3fisct3.png)

这时候我们可以视为这个红色海报不再是一个整体了，而是变成了颜色相同的两张海报。

第一张海报的$l_j$还是原来的红色海报的$l_i$，而$r_j$变成了蓝色海报左端点的左边。

第二张海报的$l_k$变成了蓝色海报右端点的右边，而$r_k$还是原来的红色海报的$r_i$。

为了避免统计时认成两张不同的海报，我们还需要一个数组$d$，$d_i$来标记它的颜色，多张海报颜色相同就视为这些海报是同一张海报。

到这里，每张海报的信息点就出来了，$l$表示左端点位置，$r$表示右端点位置，$u$表示是否永远离开了这面墙，$d$表示颜色。

因为我们随时有可能在增加新海报，海报总数是不可估量的，所以要用C++的STL中的vector

如果不清楚vector的话，直接把他理解成一个可以自动伸缩长短的数组，有一个叫push_back的函数可以在这个数组后面挤进去一个数。

 ```cpp
struct photo{
	int l,r,d;
	bool u;
};
vector<photo> a;
```
下面的码风过丑，需要逐行理解。
 ```cpp
for(register int i=1;i<=m;++i){
	photo p;
    s=a.size(); //因为海报总数不一定是m了（情况五会增加海报数），所以需要实时更新海报数量
	p.l=read();
    p.r=read();
    p.d=i;// 第i个海报颜色标记为i，绝对就不会搞混了
    p.u=0;//刚贴的海报不可能全被覆盖

    // 贴海报前需要审核，看看这张海报造成的影响

	for(register int j=s-1;j>=0;--j) if(!a[j].u){  // 如果这张海报已经阵亡就跳过
   
		if(p.l>a[j].r || p.r<a[j].l) continue;// 毫无关系就跳过（情况二）
		if(p.l<=a[j].l && p.r>=a[j].r) {a[j].u=1;continue;} //完全覆盖，标记一下这张海报凉了，然后不管了（情况一）
        
		if(p.l>a[j].l && p.l<a[j].r && p.r>a[j].l && p.r<a[j].r) a.push_back((photo){p.r+1,a[j].r,a[j].d,0}),a[j].r=p.l-1;
        /*
         * 如果是要劈成两半（情况五），
         * 放一个新的海报（和原来海报颜色一样），再更新原来海报大小，
         * if里面的条件需要仔细咀嚼
         */
        
		if(p.l>a[j].l && p.l<a[j].r) a[j].r=p.l-1; //情况四
		if(p.r>=a[j].l && p.r<a[j].r) a[j].l=p.r+1;//情况三

		if(a[j].l>a[j].r) a[j].u=1; 
       // 如果一张海报被折磨到左端点在右端点右边，说明他SPFA了
	}
	a.push_back(p); //所有事情搞完后，这张临时海报就审核通过贴墙上了
}
```
最终我们把所有海报审核通过了，然后把这几天的活着的海报数一数就行。
 ```cpp
map<int,bool> k;	// k存储一个颜色是否出现过了
/*
  * C++中的map可以视为一个万能数组，它的下标可以是任何东西
  * map<int,bool> 类似于创建一个 bool 类型的数组，它的下标的类型是 int
  * 需要注意的是，map的查询和修改不是O(1)，是O(logn)
  */
s=a.size();
for(register int i=0;i<s;++i)
	if(!a[i].u && !k[a[i].d]){ // 如果这张海报还“活着”而且还没出现过
    	++ans; // 墙上又多了一张能被看见过的海报
        k[a[i].d]=1; // 标记这张海报出现过了，避免以后又遇到它就重复累加
    }
write(ans);
```
$\color{Red}\text{基本完整代码}$（省略了快读快写函数）

 ```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,ans,s; // n，m和题意一样，ans表示答案，s表示vector的长度
struct photo{
	int l,r,d;
	bool u;
};// 每个变量什么意思见上文

vector<photo> a; // 存海报
map<int,bool> k; // 判重

int main(){
	n=read(),m=read();
   
	for(register int i=1;i<=m;++i){
	photo p;
    s=a.size(); //因为海报总数不一定是m了（情况五会增加海报数），所以需要实时更新海报数量
	p.l=read();
    p.r=read();
    p.d=i;// 第i个海报颜色标记为i，绝对就不会搞混了
    p.u=0;//刚贴的海报不可能全被覆盖

    // 贴海报前需要审核，看看这张海报造成的影响

	for(register int j=s-1;j>=0;--j) if(!a[j].u){  // 如果这张海报已经阵亡就跳过
   
		if(p.l>a[j].r || p.r<a[j].l) continue;// 毫无关系就跳过（情况二）
		if(p.l<=a[j].l && p.r>=a[j].r) {a[j].u=1;continue;} //完全覆盖，标记一下这张海报凉了，然后不管了（情况一）
        
		if(p.l>a[j].l && p.l<a[j].r && p.r>a[j].l && p.r<a[j].r) a.push_back((photo){p.r+1,a[j].r,a[j].d,0}),a[j].r=p.l-1;
        /* 如果是要劈成两半（情况五），
         * 放一个新的海报（和原来海报颜色一样），再更新原来海报大小，
         * if里面的条件需要仔细咀嚼
         */
		if(p.l>a[j].l && p.l<a[j].r) a[j].r=p.l-1; //情况四
		if(p.r>=a[j].l && p.r<a[j].r) a[j].l=p.r+1;//情况三

		if(a[j].l>a[j].r) a[j].u=1; 
       // 如果一张海报被折磨到左端点在右端点右边，说明他SPFA了
	}
	a.push_back(p); //所有事情搞完后，这张临时海报就审核通过贴墙上了
}
	s=a.size();
	for(register int i=0;i<s;++i)
		if(!a[i].u && !k[a[i].d]){ // 如果这张海报还“活着”而且还没出现过
  	     ++ans; // 墙上又多了一张能被看见过的海报
   	     k[a[i].d]=1; // 标记这张海报出现过了，避免以后又遇到它就重复累加
    	}
	write(ans);
	return 0;
}

```


---

## 作者：le_星辰 (赞：2)

  这道题可以理解为给连续的一段区间染色，然后最后询问可以看见多少种颜色。题目并不复杂，我们可以这样考虑，最后放上去的海报一定不会被任何海报遮挡，于是可以先把海报存下来，然后在区间上逆序操作，需要的操作有：
 -  1、询问一个区间是否被完全染色。
 - 2、使一个区间全部染色。
 
  很明显这可以线段树来维护，用一个标记来表示区间是否被完全染色，传递信息可以用按位与“&”来支持， 然后spread等下传操作同线段树模板。
  
   但这题数据范围很大，需要离散化，第一次做这道题的时候只有70分，关键就在于离散化是分为两种类型的，第一种是连续性，第二种是离散型，所谓离散型的区间就是区间中的点集，例如[3,8]就代表了{3,4,5,6,7,8}，而另一种连续性则在数轴上是以一条线段来体现的，这道题就是连续型的离散化，于是就要进行一些操作以防相邻的区间将两个端点给误覆盖了，我的解决办法是离散三个关键点，除了左右端点外，再离散一个右端点+1的点，问题就解决了。
   
  上代码：
  ```cpp
#include <bits/stdc++.h>
using namespace std;
const int SIZE=1e4+10;
struct node {
	int l,r;
	bool data,add;
} t[4*SIZE];
int n,Left[SIZE],Right[SIZE],m;
int num[5*SIZE],ans,cnt,tot;
void build(int p,int l,int r) {
	t[p].l=l,t[p].r=r;
	if(l==r) {
		t[p].data=false;
		return;
	}
	int mid=(l+r)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
void spread(int p) {
	if(t[p].add) {
		t[p*2].data=1;
		t[p*2+1].data=1;
		t[p*2].add=1;
		t[p*2+1].add=1;
		t[p].add=0;
	}
}
void change(int p,int l,int r) {
	if(l<=t[p].l&&r>=t[p].r) {
		t[p].data=1;
		t[p].add=1;
		return;
	}
	spread(p);
	int mid=(t[p].l+t[p].r)/2;
	if(l<=mid) change(p*2,l,r);
	if(r>mid) change(p*2+1,l,r);
	t[p].data=(t[p*2].data&t[p*2+1].data);
}
bool ask(int p,int l,int r) {
	if(l<=t[p].l&&r>=t[p].r) {
		return t[p].data;
	}
	spread(p);
	int mid=(t[p].l+t[p].r)/2;
	bool val=1;
	if(l<=mid) val&=ask(p*2,l,r);
	if(r>mid) val&=ask(p*2+1,l,r);
	return val;
}
int query(int x){
	return lower_bound(num+1,num+tot+1,x)-num;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=m; i++){
		scanf("%d%d",&Left[i],&Right[i]);
		num[++cnt]=Left[i];
		num[++cnt]=Right[i];
		num[++cnt]=Right[i]+1;//这就是离散右端点+1的点
	}
	sort(num+1,num+cnt+1);
	tot=unique(num+1,num+cnt+1)-(num+1);
	build(1,1,tot+10);
	for(int i=m; i>=1; i--) {
		int Le=query(Left[i]),Ri=query(Right[i]);
		if(!ask(1,Le,Ri)){
			ans++;
			change(1,Le,Ri);
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：治涨的馒头 (赞：2)

## 感觉本题真不难
一看题目，便觉得应是数组上的操作

#### 正常思维肯定是从第一块想后覆盖，最后顺着扫一遍计数输出。

这应该会**TLE**的。~~但据说过了。（真水）~~

首先来看离散化，并不是太好办的。

##### …………而且难写，这是关键！！！

所以嘛，从最后贴上取得一个开始就可以了，不覆盖，只添加。

### ~~（一下解说有点脑洞）~~

既然从头往后不行，为何不从结束状态考虑：覆在同一层上的，只有最后一个可以看见。那么，没覆过的记为0，覆盖过的记录编号，遇上已被覆盖过的格子，直接跳到该格子编号对应的末尾（应为保证中间任何一个格子是已经被覆盖的）。

废话不多说，献上31行的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int num[10000010];
int n,m,out; 
int in[10010][2];
int main()
{
	cin>>n>>m;
	for(int i = 1;i <= m;i++)
	{
		cin>>in[i][0]>>in[i][1];		//先读下来
	}
	for(int i = m;i >= 1;i--)			//从后向前
	{
		bool l = 0;
		for(int j = in[i][0];j <= in[i][1];j++)
		{
			if(num[j] == 0)
			{
				if(l == 0)
				out++;			//记数
				num[j] = i;		//填充
				l = 1;			//标记，以免重复技术
			}
			else
			j = in[num[j]][1];  		//跳跃
		}
	}
	cout<<out;
	return 0;
}
```


---

## 作者：木木！ (赞：1)

看到这题，差点手抖拍了个线段树上去。然后一看数据范围，$0\leq N\leq10^7\space\space 1\leq M\leq1000$

$\Theta(nlogn)$不太稳，但是$\Theta(m^2)$稳如狗啊。

所以可以读入n然后扔掉n，直接离线读入然后对每个海报枚举其有没有被覆盖。在判覆盖的时候，先按照l排序，然后扫一遍就好。

~~线段树的题为什么要用线段树做呢~~

附暴力代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

struct poster
{
	int l;
	int r;
	int time;
};

poster pi[1005];

bool cmp(poster a,poster b)
{
	return a.l<b.l;
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=m; ++i)
	{
		scanf("%d%d",&pi[i].l,&pi[i].r);
		pi[i].time = i;
	}
	
	sort(pi+1,pi+1+m,cmp);
	
	int ans = 0;
	for(int i=1; i<=m; ++i)
	{
		int thl = pi[i].l;
		for(int j=1; j<=m; ++j) //必须从1开始扫
		{
			if(pi[j].l > thl) //肯定漏风了
			{
				break;
			}
			if(pi[j].time>pi[i].time && pi[j].r>=thl)
			{
				thl = pi[j].r+1;
			}
			if(thl>pi[i].r) //肯定没了
			{
				break;
			}
		}
		if(thl<=pi[i].r)
		{
			++ans;
		}
	}
	
	printf("%d",ans);
}
```

---

## 作者：csyakuoi (赞：1)

先将线段按左端点排序，按时间从前到后枚举每一个线段，判断出现时间在它后面的线段能否完全覆盖它，如果能则答案减一（初始答案为$n$）。

对于每一条线段$s_i$，求出$s_{i+1}$到$s_n$这些线段的并集。扫描每一条线段，如果其$id$小于或等于$i$，则忽略这条线段。记录当前所有线段最靠右的右端点$maxr$，以及$minl$，$minl$代表目前连续线段中最靠左的左端点。对于每一条线段，如果其左端点小于$maxr$，则更新$maxr$。否则，将$maxr$设为其右端点，将$minl$设为其左端点。任何时候，只要$minl<s_i.l$且$s_i.r<maxr$,那么$s_i$后面的线段能完全覆盖$s_i$。

本质上是一种暴力，时间复杂度$O(m^2)$。

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int n,m,ans;
struct Seg{
	int l,r,id;
}seg[1000];
bool comp(Seg a,Seg b)
{
	return a.l<b.l;
}

int main(void)
{
	scanf("%d%d",&n,&m);
	ans=m;
	for(int i=0;i<m;i++){
		scanf("%d%d",&seg[i].l,&seg[i].r);
		seg[i].id=i;
	}
	sort(seg,seg+m,comp);排序
	for(int i=0;i<m;i++){
		int pos,minl,maxr=-100;
		for(int j=0;j<m;j++)
			if(seg[j].id==i){
				pos=j;
				break;找到该线段的位置
			}
		for(int j=0;j<m;j++){
			if(seg[j].id<=seg[pos].id)
				continue;去除之前的线段
            
            求线段并集中的一段
			if(seg[j].l<=maxr+1)
				maxr=max(maxr,seg[j].r);
			else{
				minl=seg[j].l;
				if(seg[pos].r>maxr&&seg[pos].l<minl)
					break;
				if(seg[pos].l>=minl)
					maxr=seg[j].r;
			}
            
            该线段在它后面的线段并集中的线段里面
			if(minl<=seg[pos].l&&seg[pos].r<=maxr){
				ans--;
				break;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：JustinRochester (赞：0)

这里来一个指针版的线段树

暴力弄一弄就可以过了

(当然，也可能是数据水......)

---

**【分析】**
--

首先，肯定是把贴纸都扔进一个栈中，越后面的越先判断

这边做一个简要的说明：

如果一个海报能被看到，即它存在一部分未被遮挡

也就是说后面的海报为把该海报所在的所有区间覆盖

那么就是说我们开一个线段树，从后往前枚举海报，如果有部分未被遮挡就答案 $Ans+1$ ，并且将它的所有覆盖区间打上标记

暴力开线段树理论上存得下，但是很危险

所以我们这么考虑：如果一个区间已经完整地被覆盖了，那么访问所有它的子区间都一定是无解的

所以对于一个**完全被覆盖的区间**，它的左右孩子已经没有存在的必要了。

这个时候，如果我们使用的是指针，就可以把**指向左右孩子的指针**、**它们**和**它们孩子**的指针全部删除，释放空间，避免 $MLE$

删除子节点及其子节点的指针可以用析构函数实现

而标记的转移也很方便，我们这么想，如果有往下访问，一定是当前区域没有被覆盖

而且如果它的左右孩子都被完全覆盖，它一定也会被完全覆盖

因此我们可以很动态的申请空间并比较高效的执行

具体的步骤可以参考本蒟蒻的代码

---

**【代码】**
--

那本蒟蒻就放  ~~我码风极丑的~~  代码了：

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c) for(register int a=b,LIMA=c;a<=LIMA;a++)
#define g(a,b,c) for(register int a=b,LIMA=c;a>=LIMA;a--)
#define Min(a,b) ((a<b)?a:b)
#define Max(a,b) ((a>b)?a:b)
#define File(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
typedef long long int ll;
typedef unsigned long long int ull;
const int MAXN=1010;
typedef int ar[MAXN];
inline ll read(){
    register ll ans=0;register char c=getchar();register bool neg=0;
    while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
    return neg?-ans:ans;
}//条件反射的结果
struct Node{
	int L,R;
	bool Used;//Used==1 表示该区间被完全覆盖
	Node *Lc,*Rc;
	Node(int Head,int Tail):L(Head),R(Tail) {
		Used=0;
		Lc=Rc=0;
	}
    //构造函数，初始情况下都未覆盖，且一开始不需要知道子节点
	~Node() { if(Lc) delete(Lc); if(Rc) delete(Rc); }//析构函数
	bool Query(int Head,int Tail){
		bool Alw=0;//表示该区间是否存在空位
		if(Used) return Alw;//已经被完全覆盖
		if(Head==L&&Tail==R){
			Used=1;
			return 1;
		}//覆盖该区间
		int Mid=L+R>>1;
		if(Tail<=Mid){
			if(!Lc) Lc=new Node(L,Mid);
			Alw=Lc->Query(Head,Tail);
		}
		else if(Head>Mid){
			if(!Rc) Rc=new Node(Mid+1,R);
			Alw=Rc->Query(Head,Tail);
		}
		else{
			if(!Lc) Lc=new Node(L,Mid);
			if(!Rc) Rc=new Node(Mid+1,R);
			Alw=(Lc->Query(Head,Lc->R))|(Rc->Query(Rc->L,Tail));
		}
		if(!Alw) return 0;
        //不存在空位，一定没有修改，可以直接跳出
		if(Lc!=0&&Rc!=0) Used=Lc->Used&Rc->Used;
        //更新Used
		if(Used) delete(Lc),delete(Rc),Lc=Rc=0;
        //如果该区间被完全覆盖，则其子节点以无意义
		return 1;
	}
}*Root;
int main(){
	Root=new Node(1,read());
	int M=read(),Ans=0;
	ar Start,End;
	f(i,1,M) Start[i]=read(),End[i]=read();
    //进栈
	g(i,M,1) if(Root->Query(Start[i],End[i])) Ans++;
    //若该海报的区间存在空位，则看得到
	printf("%d",Ans);
	return 0;
}
```

---


# [中山市选] 生成树

## 题目描述

有一种图形叫做五角形圈。一个五角形圈的中心有1个由n个顶点和n条边组成的圈。在中心的这个n边圈的每一条边同时也是某一个五角形的一条边，一共有n个不同的五角形。这些五角形只在五角形圈的中心的圈上有公共的顶点。如图0所示是一个4-五角形圈。

![https://cdn.luogu.com.cn/upload/pic/22665.png](https://cdn.luogu.com.cn/upload/pic/22665.png)

现在给定一个n五角形圈，你的任务就是求出n五角形圈的不同生成树的数目。还记得什么是图的生成树吗？一个图的生成树是保留原图的所有顶点以及顶点的数目减去一这么多条边,从而生成的一棵树。
注意：在给定的n五角形圈中所有顶点均视为不同的顶点。

## 样例 #1

### 输入

```
1
2```

### 输出

```
40```

# 题解

## 作者：da32s1da (赞：11)

本题有**两个**做法，均可AC。

### 方法1：矩阵树

先建图。

![](https://cdn.luogu.com.cn/upload/pic/22665.png)

我的建图方法是先把正多边形的一个顶点当做0点，然后向外连接，这样$4*i$的也是正多边形的顶点。

随即做好矩阵

```
for(int i=0;i<n;i++)f[i][i]=2;
for(int i=0;i<n;i+=4)f[i][i]+=2;
for(int i=0;i<n;i++)f[i][(i+1)%n]--,f[i][(i-1+n)%n]--;
for(int i=0;i<n;i+=4)f[i][(i+4)%n]--,f[i][(i-4+n)%n]--;
```

然后就是个矩阵树的板子了。

### 方法2：快速幂（暴力）

考虑每一个五边形，显然，每个五边形都要删去其中的一条边。

这时候是肯定不可以的，图中必然还有一个环。

这就意味着我们还要删去一条边，也就是说，有一个多边形要删两条边。

有$n$个五边形可以选择，其中在正多边形上的边必删，其他4条边随意，剩下$n-1$个五边形随意删一条，所以答案是$4\times n \times 5^{n-1}$。

```
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int N=505;
const int mod=2007;
int t,n,rt;
int f[N][N],ans;
bool mat_tree(){
	for(scanf("%d",&t);t;t--){
		scanf("%d",&n);ans=1;n*=4;
		for(int i=0;i<n;i++)f[i][i]=2;
		for(int i=0;i<n;i+=4)f[i][i]+=2;
		for(int i=0;i<n;i++)f[i][(i+1)%n]--,f[i][(i-1+n)%n]--;
		for(int i=0;i<n;i+=4)f[i][(i+4)%n]--,f[i][(i-4+n)%n]--;
		n--;
		for(int i=0;i<n;i++){
			for(int j=i+1;j<n;j++){
				while(f[j][i]){
					int r=f[i][i]/f[j][i];
					for(int k=0;k<n;k++)
					f[i][k]=(f[i][k]-r*f[j][k]%mod+mod)%mod,swap(f[i][k],f[j][k]);
					ans=(mod-ans)%mod;
				}
			}
			ans=(ans*f[i][i]+mod)%mod;
		}
		printf("%d\n",ans);
		if(t)memset(f,0,sizeof(f));
	}
}
bool ksm(){
	for(scanf("%d",&t);t;t--){
		scanf("%d",&n);ans=1;rt=5;
		for(int v=n-1;v;v>>=1,rt=rt*rt%mod)
		if(v&1)ans=ans*rt%mod;
		printf("%d\n",ans*4*n%mod);
	}
}
int main(){
	mat_tree() or ksm();
}
```

---

## 作者：Rigel (赞：10)

生成树无环。考虑删边破环。

图中有 $1$ 个 $n$ 边形以及 $n$ 个 $5$ 边形。

首先删去中间的 $n$ 边形中的一条边，共有 $n$ 种删法。

观察剩余的图形，为 $(n-1)$ 个完整的 $5$ 边形与 $1$ 个少一条边的 $5$ 边形。对于每个完整的 $5$ 边形，有 $5$ 种删法；对于少一条边的 $5$ 边形，有 $4$ 种删法。

因此答案为 $n\times 5^{n-1}\times 4$。

[Submission](https://www.luogu.com.cn/record/190330793)。

---

## 作者：junble19768 (赞：7)

一向擅长找规律的我又来啦(~~虽然规律是老师给的~~)

# **思考过程：**

    把这个n五角形圈变成一个生成树，那么我们需要在每一个环上去掉一条边
    一个环上去掉一条边总共有环的长度种方案
    根据乘法原理，把每一个环上的方案数相乘即为答案
    
    但是这一题不同（肯定不同啊...）
    每一个五角形的环都和中间的n边形重叠一条边
    所以有一些方案数是取不到的
    
### 对此我们可以有两种做法：
#### 1.枚举在n边形上去掉边的个数1,2,3...n

根据每一种情况计算对应方案数然后加起来；

O（n）枚举，O（n）计算，至少要O（n²）的做法；

不管能不能过这都是我们不想要的；~~如果是在考场上要先骗一下分的啦~~

#### 2.人类的智慧~~
我们可以先解决掉这个特殊的n边形，先把n边形变成一个~~废环~~

去掉n边形中的任意一条边，有n种做法

去掉一条边后，此时肯定有一个五边形和残余的n边形形成一个新环![](https://cdn.luogu.com.cn/upload/pic/52593.png)
	
如图，原n边形（n=4）ABCD中去掉AD边，和五边形ADEFG形成新环

我们需要在新环上再去掉一条边（准确的来说是在五边形ADEFG上去边，方案为4，因为如果去掉AB或BC或CD的话就干涉到其他环的选择）然后按照思考过程对剩下的n-1个五边形去边，有5^（n-1）种方案

所以乘起来就得到ans=4 * n * 5^（n-1）；

至于怎么乘起来5的n-1次方...

模板题在此=>[P1226](https://www.luogu.org/problemnew/show/P1226)


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#define mod 2007
#define ll long long
using namespace std;
inline long long kp(long long base,long long a);

ll t,n;
long long ans=0;
int main()
{
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld",&n);
		ans=kp(5,n-1)*4*n%2007;
		printf("%lld\n",ans);
		ans=0;
	}
	return 0;
}

inline long long kp(ll base,ll a)
{
	long long turn =1;
	while(a)
	{
		if(a&1) turn*=base;
		a>>=1;
		base*=base;
		
		turn%=mod;
		base%=mod;
	}
	return turn;
}
```
不要抄，自己写！
这么简单还抄？


---

## 作者：sounds_666 (赞：3)

#### [题目传送门](https://www.luogu.org/problem/P4821)
首先来看看[AC代码](https://www.luogu.org/record/22229257)吧。

```cpp
#include<cstdio>
using namespace std;
int ans[120]={0,4,40,300,2000,458,741,1981,1285,1458,518,842,1491,1888,
1675,1662,836,929,432,1165,850,1452,1298,764,1281,1738,1411,765,473,1661,
771,304,1828,645,890,803,1836,292,1174,426,1001,1367,687,793,790,117,1490,
1940,213,1798,613,1320,1889,1946,333,841,85,1902,839,980,867,226,655,900,653,
86,591,1753,748,1788,1187,1289,1278,625,391,327,1523,1034,363,1864,1537,882,500,
1013,1644,1150,505,384,1250,893,1764,1336,1372,390,1712,1349,795,316,1348,1566,
23,1220,1590,1456,901,708,611,452,1287,1570,1588} ;
int main(){
	int n;
	scanf("%d",&n);
	while(n--){
		int a;
		scanf("%d",&a);
		printf("%d\n",ans[a]);
	}
	return 0;
}
```

显然这是一个打表的代码，怎么来的呢？

![](https://cdn.luogu.com.cn/upload/pic/22665.png)

仔细观察我们不难发现，其实这道题是有规律的。首先五边形的一个点一定会与相邻五边形的点构成一个图形，而这个图形的边恰好是每个五边形的一条边，所以每个五边形都要减少一条边，从而可推5^n,又因为是棵树，所以要减去一条边，也就要少一种情况所以可得递推式：
### $5^{i-1}*4n$

推表代码：
```cpp
#include<cstdio>
#define mod 2007
using namespace std;
int quickPower(int a, int n){//我选择用快速幂 ，记得取模 
    int ans=1;
    while(n){
        if(n&1)ans=(ans*a)%mod;
        a=a*a%mod;
        n>>=1;
    }
    return ans%mod;
}
int main(){
	for(int i=1;i<=110;i++){
		printf("%d,",((4*i)%mod*quickPower(5,i-1)%mod)%mod) ;
	}
	return 0;
}

```
正常代码：
```cpp
#include<cstdio>
#define mod 2007
using namespace std;
int quickPower(int a, int n){
    int ans=1;
    while(n){
        if(n&1)ans=(ans*a)%mod;
        a=a*a%mod;
        n>>=1;
    }
    return ans%mod;
}
int main(){
	int n;
	scanf("%d",&n);
	while(n--){
		int i;
		scanf("%d",&i);
		printf("%d\n",((4*i)%mod*quickPower(5,i-1)%mod)%mod) ;
	}
	return 0;
}
```


---

## 作者：封禁用户 (赞：3)

# P4821 [中山市选] 生成树题解
## 思路
我们可以看一下题目中给的这张图。

首先，树是没有环的，所以我们要把所有的环上的边都删去一条。

我们可以现在每个五边形上删去一条边。

但删完之后我们会发现，里面还有一圈。

这时候，我们就要在这里面随便选一条边删去。

也就是，我们需要把 $n-1$ 个五边形删去一条边，再把剩下的一个删掉两条边。

那么方案数就是 $4 \times n \times 5^{n-1}$。
## 补充
可能有人会问，这难道不会多算吗？

我们再仔细分析一下。

为什么是 $4 \times n$ 而不是 $5 \times n$。

这个可以这么理解，删两条边的时候，我们强制删去里面的环的一条边，在删去一个五边形上的边就不会重了。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
int n,t;
const int p = 2007;
LL ksm(LL a,LL b)
{
	LL res = 1;
	for(; b; b >>= 1)
	{
		if(b & 1) res = res * a % p;
		a = a * a % p;
	}
	return res;
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		printf("%lld\n",n* 4 *ksm(5,n-1) % p);
	}
	return 0;
}
```
小中考也是顺利上岸，望各位也能获得自己想要的美好生活。

---

## 作者：DengDuck (赞：2)

还有两天中山市选了，随手写个题解。

首先一个原则，你要是生成树的话，每个环一定要删一条边。

根据此原则，我们发现环有两类：

- 中间那一个美丽诱人的 $n$ 边形。
- 四周可爱陪衬的 $n$ 个绿叶五边形。

很多人会想着先删五边形的边，那样最后剩一个环，你得再删一个$n$ 边形的边，但是可能已经删过了，不好处理。

所以先删 $n$ 边形的边，剩下的五边形（包括一个已经删了一条边的那个）每个删一条边即可。

不难发现答案应该是 $n\times 4\times 5^{n-1}$。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL mod=2007;
LL T,n;
LL ksm(LL x,LL y)
{
	LL ans=1;
	while(y)
	{
		if(y&1)ans=ans*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return ans;
}
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld",&n);
		printf("%lld\n",4*n%mod*ksm(5,n-1)%mod);
	}
	return 0;
}
```

---

## 作者：_QyGyQ_ (赞：1)

第一眼看到这道题，发现是道规律题。

首先，对于正多边形边
上的每一个五边形，需要删一条边，使它不具备环。然后再考
虑中间的正多边形。但中间的多边形可能已经有一条边被删过了，但我们无法具体得知正多边形是否被删边。

所以，我们不妨让其中一个五边形的一条边删去，剩下的五边形按照正常方式排列组合求出方案数。其共有 $5^{n-1}$ 中组合。这样就保证了正多边形一定没有环。

然后，再求出剩下一个五边形删边的方案数。因为已经删了一条边，对于一个五边形剩下一共有 $4$ 种可能。每个五边形都可能成为被删边的五边形，所以共 $4 \times n$ 种可能。

所以，对于整个图形，共 $4 \times n \times 5^{n-1}$ 种可能。

---

## 作者：封禁用户 (赞：0)

## 题目大意

给你个 $n$ 边形，其中以每一条边在向外做一个五边形。我们称这个图形叫做 $n$ 五角形圈。现在让你求出 $n$ 五角星圈的生成树个数。

## 解法

首先这个 $n$ 五角星圈有 $4\times n$ 个点和 $5\times n$ 个边。

根据数的性质，我们得到的生成树应该有 $4\times n - 1$ 条边，则我们应该要删除 $n + 1$ 条边。

如果平均每个五边形删除一条边，就有 $5^n$ 种方案，但是还剩下一条边没删。我们可以删除一条正 $n$ 边形的一条边，有 $n$ 中情况，此时选中的这条边所在的五边形就只有 $4$ 种选择，所以方案数就是 $5^{n-1} \times 4 \times n$。

由于 $n$ 很小，我们甚至可以打表通过。

## AC 代码

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<map>
#include<queue>
#include<vector>
using namespace std;
typedef long long LL;
const int MAXN = 2e5 + 10;
const int INF = 0x3f;
const int MOD = 2007;
LL n, q;
LL ksm(LL a, LL b, LL p = MOD){//a ^ b % p;
	LL ans = 1;
	while(b){
		if(b & 1)ans = ans * a % p;
		b >>= 1;
		a = a * a % p;
	}
	return ans;
} 
signed main()
{
    cin >> q;
    while(q--)
    {
        cin >>n;
        cout << (ksm(5, n - 1) % MOD *n % MOD * 4 % MOD) << endl;
    }
}
```

---

## 作者：Denny_Deng (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4821)

进入[博客](https://www.luogu.com.cn/blog/denny-deng/ans-p4821)食用更佳

------------

**第一种方法**

$\because O(n)$ 枚举，$O(n)$ 计算，
$\therefore$ 至少要 $O(n^2)$ 的做法。

这种方法不管能否通过，都不是我们想要的。

------------

**第二种方法**

1. 由于生成树的性质：$n$ 个点的图被 $n-1$ 条边所连接。故易知：图中一共有 $4n$ 个点，$5n$ 条边。

2. $\because$ 我们需要删除 $n-1$ 条边，$\therefore$ 平均每个五边形需要删去一条边，剩下一条边（也就是说有一个五边形需要删去两条边）。$\because$ 图中的正 $n$ 边形也是一个环，$\therefore$ 我们至少有一条边是需要删正 $n$ 边形的边的。

3. 由第二步知：一个五边形需要删两条边，有一条边必须删正 $n$ 边形的边，则有 $4$ 种方法。$\because$ 每个五边形都可能是这个删两条边的五边形，一共有 $n$ 个，$\therefore$ 是 $4n$ 种方法

4. $\because$ 剩下 $n-1$ 个五边形各有五条边可以删，$\therefore$ 是 $5^{n-1}$ 种方案

综上所述，总方案的个数是：
$$4\cdot n+5^{n-1}$$

$\therefore$ 这道题考虑用快速幂求解。

代码如下：
```cpp
// 头文件
#include<set>
#include<map>
#include<list>
#include<queue>
#include<stack>
#include<string>
#include<math.h>
#include<time.h>
#include<vector>
#include<bitset>
#include<memory>
#include<utility>
#include<stdio.h>
#include<sstream>
#include<iostream>
#include<stdlib.h>
#include<string.h>
#include<algorithm>
using namespace std;

typedef long long ll;

const int N = 1e5 + 10;
const int P = 2e3 + 7;
const int INF = 0x3f3f3f3f;

int T/*测试数据数目*/, n/*五角形圈中心的边数*/;
int res = 0; // n五角形圈的生成树数目

int quickpower(int base = 2, int power = 2, int mod = 1);

int main()
{
    cin >> T;
    for (int i = 1; i <= T; ++i)
    {
        cin >> n; // 输入
        res = (4 * n) % P * quickpower(5, n - 1, P); // 计算 4n+5^(n - 1)
        cout << res % P << endl; // 输出
    }
    return 0;
}

// 快速幂
int quickpower(int base, int power, int mod)
{
    int result = 1;
    while (power > 0)
	{
        if (power % 2) 
		{
            result = result * base % mod;
        }
        power /= 2;
        base = (base * base) % mod;
    }
    return result % mod;
}

```

---

## 作者：zplqwq (赞：0)

orz 出题人

------------

其实这道题没有很明显是个结论题，毕竟 $n$ 不大。

但是显然这题不能直接莽，当然你用矩阵树做除外，虽然我不是很会。

考虑推一下性质。

首先一个显然的性质，每个五边形 **至少** 删掉一条边。

但是假设我们真的只删去一条边，那么图中就会出现一个环。

那么这个问题的解决方式就是再挑一个多边形删两条边。

然后就是排列组合基础题了。

答案就是在 $n$ 个五边形上选择在正多边形上的边删掉，其余随意。

那么答案就是 $4 \times n \times 5^{n-1}$。

这个东西考虑用快速幂求解。

---

## 作者：Cocoly1990 (赞：0)

考虑把环破坏掉，形成生成树。

显然对于任意一个环，破坏的方式和环的边数相等，但显然这题不能这样 rush，因为中间的环的边和外环的边重合了。

我们不如钦定一条边必须删，然后构造出这样一个图。

![5FNhKH.png](https://z3.ax1x.com/2021/10/09/5FNhKH.png)

我们强制把这个红色的边删去。显然，这个红色变由 $n$ 种选择方案。

然后你会发现，我们可以把图上剩下的环分成两部分，一是由红色绿色围起来的奇怪环，一种是剩下的五边形环。

特别的，在删除的时候，我们**钦定绿色边只能在破坏五边形环是删除**。

![5FapOH.png](https://z3.ax1x.com/2021/10/09/5FapOH.png)

答案即为 $4 \times n\times 5^{n-1}$，用快速幂实现即可。

---

## 作者：Drinkkk (赞：0)

## $\tt Description$

有一种图形叫做五角形圈。一个五角形圈的中心有 $1$ 个由 $n$ 个顶点和 $n$ 条边组成的圈。在中心的这个 $n$ 边圈的每一条边同时也是某一个五角形的一条边，一共有 $n$ 个不同的五角形。这些五角形只在五角形圈的中心的圈上有公共的顶点。

现在给定一个 $n$ 五角形圈，你的任务就是求出 $n$ 五角形圈的不同生成树的数目。

注意：在给定的 $n$ 五角形圈中所有顶点均视为不同的顶点。

## $\tt Solution$

比赛的时候一眼下去有点懵，然后就画了一下图，写了一个 $n=2$ 的暴力，然后调试了一会儿后答案对了，然后就跑去搞 $n=3$ 、 $n=4$ 的答案。然后花了点时间找到了规律，写个了递推。然后这道题目就做完了。

> 我们再仔细观察，发现它变成一颗树，需要将所有五边形删去一条边，得方案 5 的 n 次方。
然后其中一个五边形要再删去一条边，且这条边必须要在中心圈上。所以剩下一条边只有 4 种方案，得方案 $5^{(n-1)} \times 4n$。——zdw

## $\tt Code$

```cpp
#include <cstdio>
int d[1000001];
int pow(int x,int y)
{
	if(y==0)
	{
		return 1;
	}
	else
	{
		int dq=pow(x,y/2);
		if(y%2==0)
		{
			return (dq*dq)%2007;
		}
		else
		{
			return (((dq*dq)%2007)*x)%2007;
		}
	}
}
int main()
{
	freopen("count.in","r",stdin);
	freopen("count.out","w",stdout);
	d[2]=8;
	for(int i=3;i<=100;i++)
	{
		d[i]=d[i-1]+4;
	}
	int T=0;
	scanf("%d",&T);
	while(T--)
	{
		int n=0;
		scanf("%d",&n);
		printf("%d\n",(d[n]*pow(5,n-1))%2007);
	}
	return 0;
}
```

---

## 作者：鹭天 (赞：0)

##### [题目传送门](https://www.luogu.org/problemnew/show/P4821)
#### [博客传送门](https://blog.csdn.net/huang_ke_hai/article/details/87918858)

题目描述：
有一种图形叫做五角形圈。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190225155738159.png)

一个五角形圈的中心有1个由n个顶点和n条边组成的圈。在中心的这个n边圈的每一条边同时也是某一个五角形的一条边，一共有n个不同的五角形。这些五角形只在五角形圈的中心的圈上有公共的顶点。如图0所示是一个4-五角形圈。
现在给定一个n五角形圈，你的任务就是求出n五角形圈的不同生成树的数目。还记得什么是图的生成树吗？一个图的生成树是保留原图的所有顶点以及顶点的数目减去一这么多条边,从而生成的一棵树。
注意：在给定的n五角形圈中所有顶点均视为不同的顶点。
***
输入格式
输入包含多组测试数据。
第一行包含一个正整数T，表示测试数据数目。
每组测试数据包含一个整数n( 2<=N<=100)，代表你需要求解的五角形圈中心的边数。
***
输出格式
对每一组测试数据，输出一行包含一个整数x，表示n五角形圈的生成树数目模2007之后的结果。

分析：
一道数学推导题（$wc$居然放在图论专讲里。。）。

* 我们首先考虑生成树的概念：$n$个点的图被$n-1$条边所连。

不难得出，图中一共有$4n$个点,$5n$条边。
* 根据生成树的性质，我们需要删除$n-1$条边。

均摊下来，每个五边形需要删去一条边，剩下一条边。（也就是说有一个五边形需要删去两条边）

因为图中的正$n$变形也是一个环，所以我们必须有一条边是需要删正$n$边形的边的。

* 一个五边形需要删两条边，有一条边必须删正$n$边形的边，有4种方法，每个五边形都可能是这个删两条边的五边形，一共有$n$个，是$4n$种方法
* 剩下n-1个五边形各有五条边可以删，一共是$5^{n-1}$种方案

所以总方案个数是：
$$4*n\ +\ 5^{n-1}$$

那么具体代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define P 2007
int t;
int main(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
	scanf("%d",&t);
	while (t--){
	    int n;
	    scanf("%d",&n);
	    LL Pow=1;
	    for (int i=1;i<n;i++) Pow=(Pow*5)%P;
	    printf("%lld\n",(Pow*4*n)%P);
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}

```


---


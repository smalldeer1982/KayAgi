# 赌神：决斗

## 题目背景

**赌神 $\mathcal{CYJian}$，他回来了！**


## 题目描述

**$\mathcal{tomoo}$** 决定与 **$\mathcal{CYJian}$** 进行决斗！

已知 **$\mathcal{tomoo}$** 有 $\mathcal{N}$ 张扑克牌，每张扑克牌有一个$\mathcal{RP}$值$\mathcal{A_i}$， **$\mathcal{CYJian}$** 有$\mathcal{M}$张扑克牌，每张扑克牌有一个$\mathcal{RP}$值$\mathcal{B_i}$。

**$\mathcal{CYJian}$** 与 **$\mathcal{tomoo}$** 将会各自从他们的牌里任意取一段**连续区间**的牌决斗，谁的区间内的牌的$\mathcal{RP}$值的和更大，谁就赢了，请你帮忙求出 **$\mathcal{tomoo}$** 赢的概率。

## 说明/提示

### 样例解释
- 样例 $3$：不管怎么抽都是平均，胜率为 $0$
- 样例 $5$：共有 $9$ 种方案，其中 $3$ 次 **tomoo** 会赢，胜率为 $1/3$

### 数据范围
- 对于 $20\%$ 的数据，$0<N,M\le50$
- 对于另外 $20\%$ 的数据，$\sum_{i=1}^NA_i\le10^6,\sum_{j=1}^MB_j\le10^6$
- 对于$100\%$的数据，$0<N,M\le2000,0<A_i,B_i\le10^9$

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 3 5 7 9```

### 输出

```
754229067```

## 样例 #2

### 输入

```
10 15
7 8 5 1 2 3 6 5 4 1 
52 10 5 6 3 2 1 4 5 8 7 4 5 6 3```

### 输出

```
181952721```

## 样例 #3

### 输入

```
1 1
5
5```

### 输出

```
0```

## 样例 #4

### 输入

```
5 5
1254125 36521421 25362142 12514221 25362142
857412252 36322411 2236232 1254112 36224125```

### 输出

```
261761853```

## 样例 #5

### 输入

```
2 2
2 4
2 5```

### 输出

```
332748118```

# 题解

## 作者：Hope2075 (赞：5)

给出两种做法

1.双指针

首先每个人取出的牌的组合很有限，最多2001000个

所以求出每个人的组合就行

求出前缀和，然后枚举两个端点作差就可以

求完后，对两个人的所有组合排序

然后用双指针扫一遍

具体是这样的：

枚举i，随后移动j，如果j指向一个更大的元素，就停止移动

随后计数器加上j

这样就能求出所有能胜利的方案数

最后求答案就简单了，直接用合法方案数除以总方案数就行

这样时间复杂度是$O(N^2\log N)$的

如果排序改成基数排序，就可以做到$O(n^2)$

我就是这么干的

然后总用时1749ms（氧化），但是内存开销比较大

[记录](https://www.luogu.org/recordnew/show/17867900)

~~就这样成为了最优解第一名~~

2.二分

对一个数组排序，然后枚举另一个

随后二分一个位置，使得在另一个数组中满足要求

这样时间复杂度是$O(N^2\log N)$的

总用时5372ms（氧化），明显较慢，但能过

[记录](https://www.luogu.org/recordnew/show/17870692)

最后是代码

双指针法：
```cpp
#include<cstdio>
using namespace std;
const int N=2048;
const long long M=998244353;
int n,m;
long long a[N],b[N];
long long p[N*N/2],q[N*N/2];
int read(){
	int n=0;char c;
	c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){
		n=n*10+c-'0';
		c=getchar();
	}
	return n;
}
void sort(long long *beg,long long *end){
	long long* s=new long long[end-beg];
	long long* t=s+(end-beg);
	long long*ss;
	int* cnt=new int[65537];
	for(int p=0;p<4;p++){
		long long r=((1ll<<((p+1)*16))-1);
		for(int i=0;i<=65536;i++)cnt[i]=0;
		cnt++;
		for(long long *i=beg;i<end;i++)cnt[((*i)&r)>>(p*16)]++;
		cnt--;
		for(int i=1;i<65536;i++)cnt[i]+=cnt[i-1];
		for(long long *i=beg;i<end;i++)s[cnt[((*i)&r)>>(p*16)]++]=(*i);
		ss=beg;beg=s;s=ss;
		ss=end;end=t;t=ss;
	}
	delete[] s;
	delete[] cnt;
}
long long cnt;
long long arc(long long a){
	int p=M-2;
	long long ans=1;
	while(p){
		if(p&1)ans=ans*a%M;
		p>>=1;
		a=a*a%M;
	}
	return ans;
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		a[i]=read()+a[i-1];
	}
	for(int i=1;i<=m;i++){
		b[i]=read()+b[i-1];
	}
	int t1=0;
	for(int i=0;i<=n;i++){
		for(int j=0;j<i;j++){
			p[t1++]=a[i]-a[j];
		}
	}
	int t2=0;
	for(int i=0;i<=m;i++){
		for(int j=0;j<i;j++){
			q[t2++]=b[i]-b[j];
		}
	}
	sort(p,p+t1);
	sort(q,q+t2);
	int i,j;
	i=0;j=0;
	while(i<t1){
		while(p[i]>q[j]&&j<t2)j++;
		cnt+=j;
		cnt%=M;
		i++;
	}
	printf("%lld\n",cnt);
	cnt=cnt*arc(t1)%M*arc(t2)%M;
	printf("%lld\n",cnt);
}
```
二分法
```cpp
#include<cstdio>
using namespace std;
const int N=2048;
const long long M=998244353;
int n,m;
long long a[N],b[N];
long long p[N*N/2],q[N*N/2];
int read(){
    int n=0;char c;
    c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9'){
        n=n*10+c-'0';
        c=getchar();
    }
    return n;
}
void sort(long long *beg,long long *end){
    long long* s=new long long[end-beg];
    long long* t=s+(end-beg);
    long long*ss;
    int* cnt=new int[65537];
    for(int p=0;p<4;p++){
        long long r=((1ll<<((p+1)*16))-1);
        for(int i=0;i<=65536;i++)cnt[i]=0;
        cnt++;
        for(long long *i=beg;i<end;i++)cnt[((*i)&r)>>(p*16)]++;
        cnt--;
        for(int i=1;i<65536;i++)cnt[i]+=cnt[i-1];
        for(long long *i=beg;i<end;i++)s[cnt[((*i)&r)>>(p*16)]++]=(*i);
        ss=beg;beg=s;s=ss;
        ss=end;end=t;t=ss;
    }
    delete[] s;
    delete[] cnt;
}
long long cnt;
long long arc(long long a){
    int p=M-2;
    long long ans=1;
    while(p){
        if(p&1)ans=ans*a%M;
        p>>=1;
        a=a*a%M;
    }
    return ans;
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        a[i]=read()+a[i-1];
    }
    for(int i=1;i<=m;i++){
        b[i]=read()+b[i-1];
    }
    int t1=1;
    for(int i=0;i<=n;i++){
        for(int j=0;j<i;j++){
            p[t1++]=a[i]-a[j];
        }
    }
    int t2=1;
    for(int i=0;i<=m;i++){
        for(int j=0;j<i;j++){
            q[t2++]=b[i]-b[j];
        }
    }
    sort(q+1,q+t2);
    q[t2]=0x7fffffffffffffffLL;
    for(int i=1;i<=t1;i++){
        int l=1,r=t2+1,mid;
        while(l!=r){
            mid=((l+r)>>1);
            if(q[mid]>=p[i]){
                r=mid;
            }else{
                l=mid+1;
            }
        }
        cnt+=l-1;
        cnt%=M;
    }
    cnt=cnt*arc(t1-1)%M*arc(t2-1)%M;
    printf("%lld\n",cnt);
}
```

---

## 作者：liaoxingrui (赞：3)

## Content

给你一个长度为 $n$ 的 $a$ 数组和一个长度为 $m$ 的 $b$ 数组，从 $a$ 数组中选取一段区间的和，并从 $b$ 数组中也选取一段区间的和，哪个数组的和大则那个数组赢。

问 $a$ 数组赢的概率对 $998244353$ 取模是多少？

## Solution

由于 $n$ 和 $m$ 都很小，就可以将 $a$ 数组和 $b$ 数组所有不同区间的和都存进一个数组中，从小到大排序，将在 $a$ 数组区间和前面的所有 $b$ 数组区间和的个数加起来，就是 $a$ 数组赢的次数，最后求概率即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
const int mod=998244353;
int x,sum,tot;
long long n,m,ans;
long long sum1[N],sum2[N];
struct node{
	bool flag;
	long long val;
}cnt[N*N<<1];
bool cmp(node x,node y){
	return x.val==y.val?x.flag:x.val<y.val;
}
int Pow(int a,int b){
	long long cnt=a,ans=1;
	while(b){
		if(b&1)
			ans=cnt*ans%mod;
		cnt=cnt*cnt%mod;
		b>>=1;
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>x;
		sum1[i]=sum1[i-1]+x;
		for(int j=1;j<=i;j++){
			tot++;
			cnt[tot].flag=true;
			cnt[tot].val=sum1[i]-sum1[j-1];
		}
	}
	for(int i=1;i<=m;i++){
		cin>>x;
		sum2[i]=sum2[i-1]+x;
		for(int j=1;j<=i;j++){
			tot++;
			cnt[tot].val=sum2[i]-sum2[j-1];
		}
	}
	sort(cnt+1,cnt+tot+1,cmp);
	for(int i=1;i<=tot;i++)
		if(cnt[i].flag){
			sum++;
			ans=(ans+i-sum)%mod;
		}
	cout<<ans*Pow(n*(n+1)/2%mod*m*(m+1)/2%mod,mod-2)%mod;
	return 0;
}
```

---

## 作者：guozhetao (赞：3)

## 思路

首先，枚举两个端点显然很慢，我们先用 $c$ 数组和 $d$ 数组来存两个人出牌的所有情况。

将 $c$ 数组与 $d$ 数组排序。

此时 $c$ 数组和 $d$ 数组的大小分别是 $\dfrac{(n + 1) \times n}{2}$ 和 $\dfrac{(m + 1) \times m}{2}$。直接一个个枚举显然是不行的，我们可以枚举 $d$ 数组，然后二分 $c$ 数组，找到大于 $d_i$ 的第一个数（$l$）。因为 $c$ 数组满足单调性（排序过），所以只要 $ans \gets ans + (\dfrac{(n + 1) \times n}{2} - l + 1)$。

不会费马小定理的同学可以去[这题](https://www.luogu.com.cn/problem/P2613)学习一下，这里就不再证明。最后输出的答案为 $ans \times cnt^{p - 2} \mod p$。此时 $cnt = \dfrac{(n + 1) \times n \times (m + 1) \times m}{4}$，$p = 998244353$。因为 $p$ 很大，需要使用[快速幂](https://www.luogu.com.cn/problem/P1226)。

一定要开 `long long`！

## 代码
[吸氧记录](https://www.luogu.com.cn/record/101093326)

[不吸氧的记录](https://www.luogu.com.cn/record/101093382)

## 关键部分代码

```cpp
#define int long long
int p = 998244353;
//快速幂
int pow(int n,int m) {
	int ans = 1;
	while(m) {
		if(m & 1) {
			ans *= n;
			ans %= p;
		}
		n *= n;
		n %= p;
		m >>= 1;
	}
	return ans;
}
//求逆元
int niyuan(int n) {
	return pow(n,p - 2);
}
int n,m,a[2005],b[2005],c[4000005],d[4000005],cnt = 0,cnt1 = 0,ans = 0;
signed main() {
	n = read(),m = read();
	int sum = n * (n + 1) / 2; 
	sum %= p;
	sum *=  m * (m + 1) / 2;
	sum %= p;
	//前缀和 
	for(int i = 1;i <= n;i++) a[i] = read() + a[i - 1];
    for(int i = 1;i <= m;i++) b[i] = read() + b[i - 1];
    for(int i = 1;i <= n;i++) {
    	for(int j = i;j <= n;j++) {
    		c[++cnt] = a[j] - a[i - 1];
		}
	} 
	for(int i = 1;i <= m;i++) {
    	for(int j = i;j <= m;j++) {
    		d[++cnt1] = b[j] - b[i - 1];
		}
	} 
	sort(c + 1,c + cnt + 1);
	sort(d + 1,d + cnt1 + 1);
    //枚举 d 数组
	for(int i = 1;i <= cnt1;i++) {
		int l = 1,r = cnt,mid;
        //二分 c 数组
		while(l < r) {
			mid = (l + r) >> 1;
			if(c[mid] > d[i]) r = mid;
			else l = mid + 1;
		}
		if(c[l] > d[i]) {
			ans += (cnt - l + 1);
		}
		ans %= p;
	}
	write(ans * niyuan(sum) % p);
	return 0;
}


```


---

## 作者：桐间纱路 (赞：2)

介绍：[赌神三连]系列，本为[赌神三连II-前体]

所以说这题还是相当水的，**如果出现在了$NOIP$也是一道送分题**。

## 算法一：暴力

由于是连续的区间，每次可以枚举$tomoo$与$CYJian$所打出的牌的区间，再累加进行比较，累加时可以用前缀和来快速解决。

- 时间复杂度：$O(N^2M^2)$
- 预计得分：$20$

代码
```
// 充满喜感的纯暴力代码
#include <bits/stdc++.h>
#define r register

using namespace std;
typedef long long ll;

ll N, M, a [101], b [101], A [10001], B [10001], suma [1001], sumb [1001], ans1, ans2;

ll fpm(ll x, ll power, ll mod) {
	x %= mod;
	ll ans = 1;
	while (power) {
		if (power & 1) ans = (ans * x) % mod;
		x = (x * x) % mod;
		power >>= 1;
	}
	return ans;
}

int main () {
	cin >> N >> M;
	for (r int i = 1; i <= N; i ++) cin >> a [i];
	for (r int i = 1; i <= M; i ++) cin >> b [i];
	for (r int i = 1; i <= N; i ++) suma [i] = suma [i - 1] + a [i];
	for (r int i = 1; i <= M; i ++) sumb [i] = sumb [i - 1] + b [i];
	for (r int i = 0; i <= N - 1; i ++)
		for (r int j = i + 1; j <= N; j ++)
			for (r int x = 0; x <= M - 1; x ++)
				for (r int y = x + 1; y <= M; y ++) {
					ans1 ++;
					if (suma [j] - suma [i] > sumb [y] - sumb [x])
						ans2 ++;
				}
	ll p = 998244353 ;
	ll sm = fpm(ans1, p-2, p) ;
	cout << ans1 << " " << ans2 << endl;
	cout << ((sm % p) * (ans2 % p)) % p;
	return 0;
}
// 可笑，调这个代码比我调标程度时间还长......
```

## 算法二：装桶

**然而这个算法有人吐槽比正解更难想......本人(蒟蒻)也是这么认为的......不过这里尽职尽责地还是讲一下......**

我们看到**数据范围**里有一个$\sum_{i=1}^NA_i\le10^6,\sum_{j=1}^MB_j\le10^6$,这就是提示。

由于数据的约束，说明最大的区间和也不会超过$1000000$，于是我们可以用$2$个桶将每个区间的和装起来......然后再枚举一个桶中每一个数值的个数，同时统计另一个桶里小于这个值的区间和个数，最后加起来就行了......

- 时间复杂度：$O(N^2+M^2)$
- 预计得分：$40$

### ~~算法2.5：二分太容易打挂已被屏蔽~~

## 算法三：排序&尺取

这个算法很容易想到，而它恰好就是正解。

由于最多只有$2000$个数，我们可以算出一个长度为$N$的数列，它共有$(N+1)N/2$个区间，也就是说最多只会有$2001000$个区间和，所以我们对于每一个数列，用一个数组将每一个区间和储存下来就好了。

然后将两个数组排序(其实排一个数组就行了),再枚举其中的一个数组，同时用尺取来统计答案。

- 时间复杂度：$O(N^2+M^2)$
- 预计得分：$100$

代码：
```
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
const ll mod=998244353;
const ll size=2e3+10;
ll n,m,ans,num,tb,ta,a[size],b[size],sa[size*size/2],sb[size*size/2];
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
ll power(ll x,ll y){
    ll sum=1;
    for(;y;y>>=1){
        if(y&1) sum=sum*x%mod;
        x=x*x%mod;
    }
    return sum;
}
int main(){
    n=read();m=read();
    num=n*(n+1)/2%mod;num=num*m%mod*(m+1)%mod;num=num*power(2,mod-2)%mod;
    for(ll i=1;i<=n;i++) a[i]=read(),a[i]+=a[i-1];
    for(ll i=1;i<=m;i++) b[i]=read(),b[i]+=b[i-1];
    for(ll l=1;l<=m;l++){
        for(ll r=l;r<=m;r++){
            sb[++tb]=b[r]-b[l-1];
        }
    }
    for(ll l=1;l<=n;l++){
        for(ll r=l;r<=n;r++){
            sa[++ta]=a[r]-a[l-1];
        }
    }
    sort(sa+1,sa+1+ta);
    sort(sb+1,sb+1+tb);
    ll l=0;
    for(ll i=1;i<=ta;i++){
        while(sb[l+1]<sa[i]&&l+1<=tb) l++;
        ans=ans+l;if(ans>=mod) ans-=mod;
    }
    printf("%lld\n",ans*power(num,mod-2)%mod);
    return 0;
}
```

---

## 作者：Dream_poetry (赞：1)

### 思路

概率论。

显然的，$0<n,m\le2000$，所以可以枚举出所有的区间和，用前缀和可以快速实现。

对于枚举出的每一个 $A$ 的子区间，我们只需要找出在所有 $B$ 的子区间里有多少个比它大就行。记这些满足条件的子区间对的总数为 $C$。

显然可以排序后二分快速地求。

对于统计答案，显然答案为 $\dfrac{C}{A 的子区间个数 \times B 的子区间个数}$。


补充：长度为 $n$ 的区间的子区间个数的公式： $\dfrac{n\times(n+1)}{2}$。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int m;
int a[2005];
int b[2005];
int sa[2005005];
int sb[2005005];
int sum[2005];
int toa;
int tob;
const int mod=998244353;

inline int ksm(int a,int x){
	int ans=1;
	a%=mod;
	while (x){
		if (x&1){
			ans=ans*a%mod;
		}
		a*=a;
		a%=mod;
		x>>=1;
	}
	return ans;
}

int cnt;

signed main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
	}	
	for (int i=1;i<=n;++i){
		for (int j=i;j<=n;j++){
			sa[++toa]=sum[j]-sum[i-1];
		}
	}
	for (int i=0;i<=n;i++){
		sum[i]=0;
	}
	for (int i=1;i<=m;i++){
		cin>>b[i];
		sum[i]=sum[i-1]+b[i];
	}
	for (int i=1;i<=m;++i){
		for (int j=i;j<=m;j++){
			sb[++tob]=sum[j]-sum[i-1];
		}
	}
	sort(sa+1,sa+toa+1);
	sort(sb+1,sb+tob+1);
	for (int i=1;i<=tob;i++){
		int w=upper_bound(sa+1,sa+toa+1,sb[i])-sa;
		//if (toa-w+1<=0) break;
		cnt=cnt+(toa-w+1);
	}
	cout<<cnt%mod*ksm(tob*toa,mod-2)%mod;
	return 0;
}
```

---

## 作者：shangruolin (赞：1)

[Problem](https://www.luogu.com.cn/problem/P4978)

这么简单的题，真的有绿吗？

令 $x=\dfrac{n(n+1)}{2}$，$y=\dfrac{m(m+1)}{2}$。

$a$ 数组只有 $x$ 个区间，同理 $b$ 数组有 $y$ 个区间，可以分别 $O(n^2)$ 和 $O(m^2)$ 的去处理出各个区间的 RP 值之和。

对于 $a$ 数组的每个区间，选择该区间的概率为 $\dfrac{1}{x}$，设 $b$ 数组中有 $k$ 个区间比该区间的和要小，则 tomoo 赢的概率为 $\dfrac{1}{x}\times \dfrac{k}{y}$。

时间复杂度 $O(n^2\log m^2)$。

分母为 $x\times y$，用快速幂求个逆元即可。

```cpp
vector <LL> x, y;
signed main () {
    ios::sync_with_stdio (false);
    cin.tie (0); cout.tie (0);
    
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) cin >> b[i];
    LL res;
    for (LL i = 1, res = 0; i <= n; i++, res = 0)
        for (LL j = i; j <= n; j++)
            res += a[j], x.emplace_back (res);
    for (LL i = 1, res = 0; i <= m; i++, res = 0)
        for (LL j = i; j <= m; j++)
            res += b[j], y.emplace_back (res);
    sort (x.begin (), x.end ());
    sort (y.begin (), y.end ());
    LL l;
    for (LL i : x) {
        l = lower_bound (y.begin (), y.end (), i) - y.begin ();
        ans = (ans + l) % P;
    }
    ans = 1ll * ans * Pow (n * (n + 1) / 2, P - 2) % P * Pow (m * (m + 1) / 2, P - 2) % P;
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：hcl156 (赞：1)

## 做法：

由于最多只有 $2000$ 个数，我们可以算出一个长度为 $N$ 的数列，它共有 $ \frac {( N + 1 ) \times N}{2} $ 个区间，也就是说最多只会有 $2001000$ 个区间和，所以我们对于每一个数列，用一个数组将每一个区间和储存下来就好了。然后将两个数组排序（其实排一个数组就行了），再枚举其中的一个数组，同时用尺取来统计答案。
 
 ## CODE：
 ```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 4007
#define LL long long
#define mo 998244353
using namespace std;
int n,m,tot1,tot2,a[N],b[N],sum;
LL qa[N],qb[N];
LL suma[N*N],sumb[N*N];

LL ksm(LL a,LL b){
    LL q=1,base=a;
    while(b){
        if(b&1) q*=base,q%=mo;
        base*=base;
        base%=mo;
        b>>=1;
    }
    return q;
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),qa[i]=qa[i-1]+a[i];
    for(int i=1;i<=m;i++) scanf("%d",&b[i]),qb[i]=qb[i-1]+b[i];
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++)
            suma[++tot1]=qa[j]-qa[i-1];
    }
    for(int i=1;i<=m;i++){
        for(int j=i;j<=m;j++)
            sumb[++tot2]=qb[j]-qb[i-1];
    }
    sort(suma+1,suma+tot1+1);
    sort(sumb+1,sumb+tot2+1);
    int j=0;
    for(int i=1;i<=tot1;i++){
        while(suma[i]>sumb[j+1]&&j+1<=tot2) j++;
        sum+=j;
        if (sum>mo) sum-=mo;
    }
    LL g=n*(n+1)/2;
    g=g*m%mo*(m+1)%mo;
    g=g*ksm(2,mo-2)%mo;
    printf("%lld",sum*ksm(g,mo-2)%mo);
}
```


---

## 作者：Mobius127 (赞：1)

[题传](https://www.luogu.com.cn/problem/P4978)

因为要求的是概率，而赌局一共会进行 $\frac{nm(n+1)(m+1)}{4}$ 场，所以我们要计算的只是第二个人总共会赢多少场。

考虑直接将第一个人的所有组合 $O(n^3)$ 算出，用前缀和优化成 $O(n^2)$ 就珂以了。

搞出这玩意存进数组 $S$ 后将其排序。

那么我们用同样的方法 $O(m^2)$ 枚举第二个人的组合，这次只需要找 $S$ 内有多少严格小于当前的数的数的数量，用 upper_bound 即可。

你当然也珂以上 $\text{two-pointer}$ ，但既然你排序都是 $O(n^2\log n)$ 的了，后面 $O(m^2)$ 就没必要了。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#define int long long
using namespace std;
typedef long long ll;
const int N=2005;
const int mo=998244353;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
ll ksm(ll a, ll b){
	ll ret=1;
	for(; b; b>>=1, a=1ll*a*a%mo)
		if(b&1) ret=1ll*ret*a%mo;
	return ret;
}
int n, m, t;
ll a[N], b[N], s1[N*N], ans, d;
ll get(ll x){
	return t-(upper_bound(s1+1, s1+t+1, x)-s1-1);
}
signed main(){
	n=read(), m=read();
	d=1ll*n*(n+1)%mo*m%mo*(m+1)%mo;
	d=1ll*d*ksm(ksm(2, mo-2), 2)%mo;
	for(int i=1; i<=n; i++) 
		a[i]=read()+a[i-1];
	for(int i=1; i<=n; i++)
		for(int j=i; j<=n; j++)
			s1[++t]=a[j]-a[i-1];
	sort(s1+1, s1+t+1);
	for(int i=1; i<=m; i++) 
		b[i]=read()+b[i-1];
	for(int i=1; i<=m; i++)
		for(int j=i; j<=m; j++){
			ll now=b[j]-b[i-1];
			ans=(ans+get(now))%mo;
		}
	printf("%lld", (1ll*ans*ksm(d, mo-2)%mo+mo)%mo);
	return 0;
}

```


---

## 作者：Prean (赞：0)

首先我们很容易知道，这题的题意是求a的子区间比b的子区间大的概率。

也就是 $ \sum_{l1=1}^n\sum_{r1=l1}^n\sum_{l2=1}^m\sum_{r2=l2}^m [a(l1,r1)>b(l1,r1)] $

我们使用前缀和快速计算区间和，然后就变成了：
$$ \sum_{i=1}^n\sum_{j=1}^m[a_i>b_j] $$
假如我们把 $ a $ 和 $ b $ 拼接起来，我们就会发现我们是在求一个类似逆序对的东西。。。

假如我们将 $ a $ 和 $ b $ 分别排序，我们就会发现这正好是归并排序计算逆序对所计算的贡献。。。

于是我们嫖一眼逆序对的代码，这道题就做完了。

复杂度是 $ O(n^2\log n + m^2\log m) $
```cpp
#include<algorithm>
#include<cstdio>
const int M=2e3+5,mod=998244353;
typedef long long ll;
int n,m,la,lb,len;long long ans,a[M],b[M],sa[M*M],sb[M*M];
inline int inv(int a){
	int b=mod-2,ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
signed main(){
	register int i,j,t;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i){
		scanf("%lld",a+i);a[i]+=a[i-1];
		for(j=0;j<i;++j)sa[++la]=a[i]-a[j],++len;
	}
	for(i=1;i<=m;++i){
		scanf("%lld",b+i);b[i]+=b[i-1];
		for(j=0;j<i;++j)sb[++lb]=b[i]-b[j],++len;
	}
	std::sort(sa+1,sa+la+1);std::sort(sb+1,sb+lb+1);
	t=1ll*la*lb%mod;i=j=1;
	while(i<=la&&j<=lb){
		if(sa[i]<=sb[j])++i;
		else ans+=la-i+1,++j;
	}
	printf("%d",ans%mod*inv(t)%mod);
}
```

---

## 作者：一只书虫仔 (赞：0)

#### Description

> 两个序列 $a_i,b_i$，A 和 B 任意在两个序列中任意取出两个连续区间，如果 A 的和大于 B 的和，A 就赢了。求 A 赢的概率。

#### Solution

感谢 lmpp 推荐这题！

首先问题不难转化为求：

$$\frac{\sum\limits_{i=1}^n \sum\limits_{j=1}^m[a_i>b_j]}{n \times m}$$

分母简单，求分子。

考虑归并排序，首先先把归并排序模板套上，也就是给序列排个序，排序的同时可以直接执行计算。因为我们都知道归并排序的时候会存在一个值 $pil$，将需要排序的区间 $a_{[l,r]}$ 拆分为三个部分：$<pil$ 的，$=pil$ 的和 $>pil$ 的，然后再分别排序。那么问题其实可以转化为在区间 $b_{[l,r]}$ 中固定一个值 $k$，寻找有多少个数小于 $k$，可以直接将归并里的 $pil$ 设为 $k$，然后在函数里排序的同时进行操作。最终在题目中实现的时候就从 $1$ 到 $n$ 枚举 $a_i$ 然后在 $b_{[1,n]}$ 中归并查找即可。

复杂度 $\mathcal O(n m\log m)$。

---

## 作者：Ryo_Yamada (赞：0)

### $\text{Subtask 1}$

$N,\,M \leq 50$，相信是人人都会的 $N^2M^2$ 暴力。

### $\text{Subtask2}$

给出了 $\sum A_i,\,\sum B_i \leq 10^6$，可以想到用两个桶 $c1,\,c2$ 存下 $A$ 和 $B$ 有多少个区间的和等于 $i$。每次更新 $\text{ans}$ 加上 $c1_i \times \sum_{j=0}^{i-1} c2_j$ 即可。

```cpp
def(N, int, 2005)
def(M, int, 1e6 + 5)
def(p, int, 998244353)

int n, m;
int a[N], b[N];
int c1[M], c2[M];
int pre1[N], pre2[N];
ll ans;

int main() {
	qread(n, m);
	rep(i, 1, n) qread(a[i]), pre1[i] = pre1[i - 1] + a[i];
	rep(i, 1, m) qread(b[i]), pre2[i] = pre2[i - 1] + b[i];
	rep(i, 1, n) rep(j, i, n) ++c1[pre1[j] - pre1[i - 1]];
	rep(i, 1, m) rep(j, i, m) ++c2[pre2[j] - pre2[i - 1]];
	ll sum = (1ll * n * (n + 1) * m * (m + 1) / 4) % p;
	ll now = c2[0];
	rep(i, 1, (int)(1e6)) {
		(ans += c1[i] * now % p) %= p;
		(now += c2[i]) %= p;
	}
	printf("%lld\n", ans * qpow(p - 2, sum, p) % p);
 	return 0;
}
```

### $\text{Subtask 3}$

有了上面的 $\text{Subtask2}$ 思路，我们可以想到很相似的正解。用两个数组 $c1,\,c2$ 存下 $A,\,B$ 两数组每个区间的和，然后排序。对于每个 $c1_i$，在 $c2$ 中二分查找比 $c1_i$ 小的数的位置 $pos$，然后 $\text{ans}$ 增加 $pos - 1$。

```cpp
def(N, int, 2005)
def(M, int, 2001005)
def(p, int, 998244353)

int n, m, c1, c2;
int a[N], b[N];
ll pre1[N], pre2[N];
ll A[M], B[M];
ll ans, sum;

int main() {
	qread(n, m);
	rep(i, 1, n) qread(a[i]), pre1[i] = pre1[i - 1] + a[i];
	rep(i, 1, m) qread(b[i]), pre2[i] = pre2[i - 1] + b[i];
	rep(i, 1, n) rep(j, i, n) A[++c1] = pre1[j] - pre1[i - 1];
	rep(i, 1, m) rep(j, i, m) B[++c2] = pre2[j] - pre2[i - 1];
	sort(A + 1, A + c1 + 1);
	sort(B + 1, B + c2 + 1);
	sum = 1ll * c1 * c2 % p;
	rep(i, 1, c1) {
		int pos = lower_bound(B + 1, B + c2 + 1, A[i]) - B - 1;
		//cout << pos << endl;
		(ans += pos) %= p;
	}
	printf("%lld\n", (ans % p) * qpow(p - 2, sum, p) % p);
 	return 0;
}
```


---


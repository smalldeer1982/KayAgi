# 替换

## 题目描述

Daniel13265 有一串由各种漂亮的贝壳组成的项链，但由于各种原因，这个项链不是环形的，而仅仅是用一根普通的丝线串起来的。项链上的每个贝壳都有一个好看程度 $a_i$，相同种类的贝壳有着相同的好看程度，而不同种类的贝壳有着不同的好看程度。

Danie13265 定义， 第 $l$ 个至第 $r$ 个这一段贝壳是对称的，当且仅当

$$\sum_{i=l}^r\left(a_i-a_{l+r-i}\right)^2=0$$

Daniel13265 经常从中取出一段贝壳。如果这一段贝壳是对称的，他就会非常高兴；如果这一段贝壳不是对称的，那么他会将其中的某些贝壳替换成新的，以使得这一段贝壳成为对称的。一次替换可以任意地改变任何一个位置上贝壳的好看程度，但是过多的替换会使这一段贝壳脱离原本的模样，所以 Daniel13265 至多会进行 $k$ 次替换。如果一段贝壳在进行至多 $k$ 次替换后能够成为对称的，那么 Daniel13265 就称这一段贝壳是「可观赏的」。

Daniel13265 简单地将第 $l$ 个至第 $r$ 个这一「可观赏的」的贝壳段的「观赏指数」定义为

$$\prod_{i=l}^ra_i$$

其中 $a_i$ 表示第 $i$ 个贝壳**原本的好看程度**。

他现在很好奇，在这个贝壳组成的项链中，「可观赏的」贝壳段中「观赏指数」的最大值。但是由于这个值可能很大，所以你只需要求出它对 $10^9+7$ 取模后的结果即可。

## 说明/提示

### 样例解释 #1

「可观赏的」贝壳段有 $[1],[2],[3],[4],[1,2],[2,3],[2,4],[3,3],[3,4],[4,2],[1,2,4],[2,3,3],[2,4,2],[3,3,4],[4,2,3],[2,3,3,4],[4,2,3,3,4]$，其中「观赏指数」最大的贝壳段为 $[4,2,3,3,4]$。

### 样例解释 #2

「可观赏的」的贝壳段中「观赏指数」最大的为 $[2,250000002,1,2]$，其值为 $10^9+8$，对 $10^9+7$ 取模后结果为 $1$。

### 数据范围

**本题采用捆绑测试。你每通过一个子任务的所有数据点，就能得到该子任务的全部分数。**

| 子任务编号 | $n\le$ | $k\le$ | 分值 |
|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10$ | $10$ |
| $2$ | $100$ | $100$ | $20$ |
| $3$ | $1000$ | $0$ | $20$ |
| $4$ | $1000$ | $1000$ | $50$ |
| $5$ | $10^6$ | $0$ | $0$ |

对于 $100\%$ 的数据，满足 $1\le n\le1000$，$0\le k\le n$，$1\le a_i<10^9+7$。

## 样例 #1

### 输入

```
7 1
1 2 4 2 3 3 4
```

### 输出

```
288
```

## 样例 #2

### 输入

```
6 1
3 1 2 250000002 1 2
```

### 输出

```
1
```

# 题解

## 作者：奇米 (赞：10)

# 题解 - $\mathrm{P6297 }$ 替换

[$$\huge\color{blue}\boxed{\color{Violet}\mathfrak{There\ is \ my \ blog}}$$](https://www.luogu.com.cn/blog/wyy2020/)

### 题目意思
* [P6297](https://www.luogu.com.cn/problem/P6297)
* 求一段回文串$[l,r]$使得$\prod\limits_{i=l}^r\ a_i$ 最大

### $\mathrm{Sol}$

* 前置知识：**对数**
* 对数转换的思维可以看：[另一道题](https://www.luogu.com.cn/problem/P3237)

* 众所周知$\log(a\times b)=\log(a)+\log(b)$
* 那么我们不直接地计算$\prod\limits_{i=l}^r\ a_i$来比较大小（极限情况：$1e9^{10^3}$显然存不下的），那么我们通过比较$\sum\limits_{i=l}^r \log(a_i)$来比较大小这样就方便多了。
* 后来就是回文的判断（注意判断奇偶两种情况）
* 时间复杂度：$O(3\times n^2)$

### $\mathrm{Code}$

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define int long long 
using namespace std;

inline int read()
{
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}

const int N=1005;
const int mod=1e9+7;

int n,m,a[N],Log[N],ansx,ansy;
double b[N];

signed main()
{
	n=read();
	m=read();
	for ( int i=1;i<=n;i++ ) 
	{
		a[i]=read();
		b[i]=b[i-1]+log2(a[i]);//取对数做前缀和
	}
	double mx=0;
	for ( int i=1;i<=n;i++ )
	{
		int l=i,r=i,gs=m;
		if(log2(a[l])>mx)
		{
			mx=log2(a[l]);
			ansx=l,ansy=l;
		}
		while(l>=1&&r<=n)//寻找回文
		{
			l--,r++;
			if(a[l]!=a[r]) 
			{
				if(gs>0) gs--;
				else break;
			}
			if(b[r]-b[l-1]>mx)
			{
				mx=b[r]-b[l-1];
				ansx=l,ansy=r;//寻找最大区间
			}
		}
	}//奇数长度回文串情况
	for ( int i=1;i<=n;i++ )
	{
		int l=i-1,r=i,gs=m;
		if(a[l]!=a[i]) gs--;
		if(log2(a[l])+log2(a[i])>mx)
		{
			mx=log2(a[l])+log2(a[i]);
			ansx=l;
			ansy=i;
		}
		while(l>=1&&r<=n)
		{
			l--,r++; 
			if(a[l]!=a[r]) 
			{
				if(gs>0) gs--;
				else break;
			}
			if(b[r]-b[l-1]>mx)
			{
				mx=b[r]-b[l-1];
				ansx=l,ansy=r;
			}
		}
	}
	for ( int i=1;i<=n;i++ )
	{
		int l=i,r=i+1,gs=m;
		if(a[r]!=a[i]) gs--;
		if(log2(a[r])+log2(a[i])>mx)
		{
			mx=log2(a[r])+log2(a[i]);
			ansx=l;
			ansy=i;
		}
		while(l>=1&&r<=n)
		{
			l--,r++;
			if(a[l]!=a[r]) 
			{
				if(gs>0) gs--;
				else break;
			}
			if(b[r]-b[l-1]>mx)
			{
				mx=b[r]-b[l-1];
				ansx=l,ansy=r;
			}
		}
	}//偶数长度回文串情况
	int ans=1;
	for ( int i=ansx;i<=ansy;i++ ) ans=(ans*a[i]%mod+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：chenly8128 (赞：3)

## 前置知识
1. 对数基本性质。
2. 中心扩展算法。~~（好像是这么叫的）~~
3. 回文串的基本处理方法。
## 分析
一看 $n \leq 1000$ 就知道可以暴力水过去。

由于奇偶串很麻烦，所以我进行一个简单的变化，将所有偶串变为奇串。就是在原数组所有的相邻元素之间放一个 1。既不改变答案，又能将所有偶串变为奇串。举个例子：
![](https://cdn.luogu.com.cn/upload/image_hosting/62opz1mu.png)

图中偶串“3，4，4，3”被转换成了奇串“3，1，4，1，4，1，3”。这样方便很多。

但是 “最大值” 这个条件有点棘手，高精度碾过去貌似会超时，所以需要取对数。$\log(a \times b) = \log(a) + \log(b)$。因此在乘的时候可以很方便的记录一下对数，根据对数的大小比较就可以了。最后再取模。

因此，第一步需要枚举中心。
然后中心扩展，如果两边不一样，增加一次更改次数，如果超过了 $k$ 就剪枝掉。在中心扩展的过程中，同时记录乘积取模、乘积取对数。
最后根据对数值比较大小，更新答案。

## 代码

```cpp

// Author: chenly8128
// Created: 2024-11-14 22:13:46

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
inline int read(void) {
	int res = 0;bool flag = true;char c = getchar();
	while (c < '0' || c > '9') {flag ^= (c == '-');c = getchar();}
	while (c >= '0' && c <= '9') {res = (res << 3) + (res << 1) + (c ^ 48);c = getchar();}
	return flag ? res : -res;
}
int n,k,a[2002];
int main (void) {
	n = read();k = read();
	for (int i = 0;i < n;i++) {
		a[(i<<1)+1] = read();
		a[(i<<1)+2] = 1;
	}
	n = (n<<1)-1;
	ll ans = 1;long double rr = 0;
	for (int i = 1;i <= n;i++) {
		ll sum = 0,res = a[i];
		long double res2 = log(a[i]);
		for (int j = 1;j <= min(i-1,n-i);j++) {
			if (a[i-j] != a[i+j] && ++sum > k) break;
			res = res * a[i-j] % mod * a[i+j] % mod;
			res2 += log(a[i-j]) + log(a[i+j]);
		}
		if (res2 > rr) {
			rr = res2;
			ans = res;
		}
	}
	printf ("%lld\n",ans);
	return 0;
}
```

---

## 作者：Hexarhy (赞：2)

### Preface

比较简单套路的题目，难度大概普及组 T2。大概可以评黄？

注意细节就好了，别考场处处锅。

### Description

给出 $n$ 个数和 $k$ 次改动数字的机会，找到一个回文串，使得回文串内所有数字的积最大。输出这个积并对 $10^9+7$ 取模。

### Solution

这里就不讲部分分了，简单题直接上正解。

枚举回文串一个很套路的做法，就是**枚举回文中心，并向两边扩展**，直到不符合回文条件停止。时间复杂度为 $O(n^2)$。

由于有 $k$ 次改动机会，枚举的时候允许至多 $k$ 次回文不匹配。

当然，枚举回文总是要分奇偶的。

但是这里有个**小技巧**。借鉴 manacher 算法，我们可以在原来的数列中，在**数列首和两两之间**插入数字 $1$。因为 $1$ 乘任何数不变，所以不影响答案，而且还避免了分奇偶枚举的繁琐。

接下来考虑如何更新答案。不难想到，直接相乘肯定不可行。

如果打高精度，我无话可说。要高精乘高精取模我是不会选这种方法的。

把积转化为和不就方便了吗？于是联想到了 $\log_2(a\times b)=\log_2(a)+\log_2(b)$。不知道的请自行百度有关对数的运算。顺提一句，$\log_2(1)=0$，之前插入的 $1$ 从这里看，也对更新答案没有影响。

这个时候，我们就能用和表示积。用**前缀和**预处理可以做到 $O(1)$ 更新答案。

原来的积继续存，边乘边取模，可以的时候就更新。

至此，一道简单题就做完了。

至于 $n\le10^6,k=0$ 的 subtask，就是裸的 manacher，时间复杂度 $O(n)$。因为强行把模板二合一上去，质量太低就被出题人删了，也好。

### Notice

1. 在原数列中插入 $1$ 以避免分奇偶枚举的麻烦。

1. `<cmath>`里有`std::log2()`，直接用。前缀和数组用`double`。但实测`long long`也行，大概是因为数很大所以不会冲突？（或许数据太弱）

1. 开了 `pair`，一个存储取模后的乘积，另一个存储对数的区间和。注意更新的时候可能遇到 $\log$ 区间和相同的情况，这时比较取模后的乘积。

1. 注意枚举回文串时，左右端点的移动时机。

1. 保险起见，还是都开 `long long` 吧。

### Code

这样下来，我的好像比楼下@[奇米](https://www.luogu.com.cn/user/308464) 大佬的题解代码短得多……

分奇偶枚举的，也就是没有插入 $1$。我们可以开一个自定义函数来简化分奇偶的任务。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath> 
using namespace std;

typedef unsigned long long ll;
const ll MAXN=1e6+5;
const ll MOD=1e9+7;
ll n,k;
ll a[MAXN];
double s[MAXN];//log2的前缀和
#define pll pair<ll,ll>
#define val first//取模后的乘积
#define logg second//log2的区间和表示完整乘积
pll ans;

void update(ll l,ll r,const ll ctr)//枚举一次回文串
{
	ll t=0;
	pll sum=pll{ctr,0LL};
	while(1<=l && r<=n)
	{
		if(a[l]!=a[r])	t++;
		if(t>k)			break;
		sum.val=sum.val*a[l]%MOD*a[r]%MOD;
		sum.logg=s[r]-s[l-1];
		l--;r++;
	} 
	if(sum.logg>ans.logg || (sum.logg==ans.logg && sum.val>ans.val))//注意这里
	 ans=sum;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin>>n>>k;
    for(ll i=1;i<=n;i++)
     cin>>a[i];
    for(ll i=1;i<=n;i++)
     s[i]=s[i-1]+log2(a[i]);
    for(ll i=1;i<=n;i++)
    {
    	update(i-1,i+1,a[i]);//奇数长度
    	update(i,i+1,1LL);//偶数长度
	}
	cout<<ans.val<<endl;
	return 0;
}
```

不分奇偶的，也就是插入了 $1$ 的。代码大同小异。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath> 
using namespace std;

typedef unsigned long long ll;
const ll MAXN=1e6+5;
const ll MOD=1e9+7;
int n,k;
ll a[MAXN];
double s[MAXN];
#define pll pair<ll,ll>
#define val first
#define logg second
pll ans;

int main()
{
    ios_base::sync_with_stdio(false);
    cin>>n>>k;
    int cnt=1;
    a[cnt]=1LL;//数列首插入1
    for(int i=1;i<=n;i++)
    {
    	ll x;cin>>x;
    	a[++cnt]=x;a[++cnt]=1LL;//两两之间插入1。最后一个虽然也插入了1，但是实际枚举并没有影响
	 }
    for(int i=1;i<=cnt;i++)//注意枚举长度变成cnt而不是n
     s[i]=s[i-1]+log2(a[i]);//预处理前缀和
    for(int i=1;i<=cnt;i++)//注意枚举长度变成cnt而不是n
    {	//下面都是一样的
    	int t=0,l=i-1,r=i+1;
		pll sum=pll{a[i],0LL};
		while(1<=l && r<=cnt)
		{
			if(a[l]!=a[r])	t++;
			if(t>k)			break;
			sum.val=sum.val*a[l]%MOD*a[r]%MOD;
			sum.logg=s[r]-s[l-1];
			l--;r++;
		}
		if(sum.logg>ans.logg || (sum.logg==ans.logg && sum.val>ans.val))
		 ans=sum;
	}
	cout<<ans.val<<endl;
	return 0;
}
```

---


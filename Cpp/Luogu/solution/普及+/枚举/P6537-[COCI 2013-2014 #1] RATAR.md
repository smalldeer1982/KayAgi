# [COCI 2013/2014 #1] RATAR

## 题目描述

给出一个 $n\times n$ 的矩阵，问有多少对子矩阵有且仅有一个公共顶点，并且元素和相等。

请注意，这里的**公共顶点**是指**顶点相交**，而不是**存在一个公共格子**。请参考样例 1 来理解“**公共顶点**”的含义。

## 说明/提示

#### 数据范围
- 对于 $40\%$ 的数据，$1\le n\le 10$。
- 对于 $100\%$ 的数据，满足 $1\le n \le 50$，$- 1000\le a_{i,j}\le 1000$。

#### 样例 1 解释
可能的矩形对如下：

$(0,0)-(1,1)$ 和 $(2,2)-(2,2)$； 

$(1,0)-(1,0)$ 和 $(0,1)-(0,1)$；

$(2,0)-(2,0)$ 和 $(1,1)-(1,1)$；

$(1,1)-(1,1)$ 和 $(0,2)-(0,2)$；

$(2,1)-(2,1)$ 和 $(1,2)-(1,2)$；

$(2,0)-(2,1)$ 和 $(0,2)-(1,2)$；

$(1,0)-(2,0)$ 和 $(0,1)-(0,2)$。

共计 $7$ **对**，所以输出 $7$ 。
#### 说明
**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #1](https://hsin.hr/coci/archive/2013_2014/contest1_tasks.pdf)  _T3 RATAR_。**

------------
$\mathtt{Subtask \ 0}$ 为样例数据。（10 pts）

$\mathtt{Subtask \ 1}$ 中所有的数据满足 $1\le n\le 10$。 （30 pts）

$\mathtt{Subtask \ 2}$ 中所有的数据满足 $1\le n \le 50$，$- 1000\le a_{i,j}\le 1000$。**请注意本子任务的时限**。（60 pts）

## 样例 #1

### 输入

```
3
1 2 3
2 3 4
3 4 8```

### 输出

```
7```

## 样例 #2

### 输入

```
4
-1 -1 -1 -1
1 2 3 4
1 2 3 4
1 2 3 4```

### 输出

```
10```

## 样例 #3

### 输入

```
5
-1 -1 -1 -1 -1
-2 -2 -2 -2 -2
-3 -3 -3 -3 -3
-4 -4 -4 -4 -4
-5 -5 -5 -5 -5```

### 输出

```
36```

# 题解

## 作者：_xbn (赞：5)

对于矩阵问题，我们先对其做一遍二维前缀和。

```cpp
  for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            f[i][j]+=f[i][j-1];
    for(int j=1;j<=n;j++)
        for(int i=1;i<=n;i++)
            f[i][j]+=f[i-1][j];
```

接下来考虑和相等的矩阵，由于数的值域较小，所以我们可以用一个桶来记录每一种和出现的次数。

接着我们考虑怎么找到两个满足条件的矩形。

我们可以枚举其中一个较为靠左的矩形的右下角坐标，因为另一个只和他有一个公共点，所以可以直接找到。然后在桶中检查一下值出现的次数，记录到答案中。

最后提醒大家两个易错点：每一次枚举完一定要把桶清空。由于数组下标可能为负数，所以要加上一个数组边界数。

核心代码：

```cpp
  for(int i=1;i<=n;i++)
	{
        for(int j=1;j<=n;j++)
		{
            for(int a=1;a<i;a++)
                for(int b=1;b<j;b++)
                    cnt[cal(a,b,i-1,j-1)+c]++;
            for(int a=i;a<=n;a++)
                for(int b=j;b<=n;b++)
                    ans+=cnt[cal(i,j,a,b)+c];
            for(int a=1;a<i;a++)
                for(int b=1;b<j;b++)
                    cnt[cal(a,b,i-1,j-1)+c]--;
            for(int a=i;a<=n;a++)
                for(int b=1;b<j;b++)
                    cnt[cal(i,b,a,j-1)+c]++;
            for(int a=1;a<i;a++)
                for(int b=j;b<=n;b++)
                    ans+=cnt[cal(a,j,i-1,b)+c];
            for(int a=i;a<=n;a++)
                for(int b=1;b<j;b++)
                    cnt[cal(i,b,a,j-1)+c]--;
        }
    }
```




---

## 作者：rhyyy1 (赞：3)

很容易想到部分分的做法：

枚举两个矩形的交点 $(i,j)$ 以及两个矩形的边长 $g_1,g_2$ 和 $l_1,l_2$  ，然后利用二维前缀和计算出两个矩形的元素和。时间复杂度 $O(n^6)$ ，不能接受。


------------
上述做法给我们指明方向，再看一眼题面，发现元素和 $\le2,500,000$ ，所以
可以考虑用桶来优化。

依旧枚举交点 $(i,j)$ ，用桶统计交点左上角所有可能的元素和，然后枚举右下角矩形边长 $l_1,l_2$ ,在区间 $\left[-2500000,2500000\right]$ 查找是否有相同元素和出现。

左下角与右上角的处理和上述同理。

由于出现负数，桶中元素还需向正方向偏移 $2,500,000$ 个单位。

时间复杂度 $O(n^4)$。

一个小细节：在枚举完一遍 $(i,j)$ 之后，必须清空桶。此时千万不能用 
```cpp
memset(f,0,sizeof f);
```
不然时间复杂度扛不住。我们采取重新枚举一遍并清空的办法，具体实现见代码。

上代码：
```cpp
#include<bits/stdc++.h>
#define foi(a,b,x) for(int i=a;i<=b;i+=x)
#define foj(a,b,x) for(int j=a;j<=b;j+=x)
#define fok(a,b,x) for(int k=a;k<=b;k+=x)
#define fol(a,b,x) for(int l=a;l<=b;l+=x)
using namespace std;
const int N=55,M=2500000;
int a[N][N],s[N][N];
int f[M*2+50]; //桶 
int calc(int x,int y,int a,int b){ //计算矩形中元素和 
    return s[x][y]-s[a-1][y]-s[x][b-1]+s[a-1][b-1];
}
int main(){
	
    int n,ans=0; scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
		    scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
		    s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
		    
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
        	
            for(int k=1;k<=i;k++)
                for(int l=1;l<=j;l++)
				    f[calc(i,j,k,l)+M]++;
				    
            for(int k=i+1;k<=n;k++)
                for(int l=j+1;l<=n;l++)
                    ans+=f[calc(k,l,i+1,j+1)+M];
                    
            for(int k=1;k<=i;k++)
                for(int l=1;l<=j;l++)
				    f[calc(i,j,k,l)+M]--;
        }
        
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
        	
            for(int k=1;k<=i;k++)
                for(int l=j;l<=n;l++)
				    f[calc(i,l,k,j)+M]++;
				    
            for(int k=i+1;k<=n;k++)
                for(int l=1;l<=j-1;l++)
                    ans+=f[calc(k,j-1,i+1,l)+M];
                    
            for(int k=1;k<=i;k++)
                for(int l=j;l<=n;l++)
				    f[calc(i,l,k,j)+M]--;
       }
    printf("%d\n",ans);
}
 
```


---

## 作者：cwfxlh (赞：2)

# P6537
## [题面传送门](https://www.luogu.com.cn/problem/P6537)    
题意略   
____
### 做法1：
暴力枚举三个顶点，用二维前缀和做，时间复杂度为 
$O(n^6)$ 
但是由于数据过水，吸个氧是可以过的，代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[53][53],pre[53][53],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a[i][j]);
			pre[i][j]=pre[i][j-1]+pre[i-1][j]-pre[i-1][j-1]+a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int i2=i;i2<=n;i2++)
			{
				for(int j2=j;j2<=n;j2++)
				{
					for(int i3=i2+1;i3<=n;i3++)
					{
						for(int j3=j2+1;j3<=n;j3++)
						{
							if(pre[i2][j2]-pre[i2][j-1]-pre[i-1][j2]+pre[i-1][j-1]==pre[i3][j3]-pre[i3][j2]-pre[i2][j3]+pre[i2][j2])ans++;	
						}
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j*2<=n;j++)swap(a[i][j],a[i][n-j+1]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			pre[i][j]=pre[i][j-1]+pre[i-1][j]-pre[i-1][j-1]+a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int i2=i;i2<=n;i2++)
			{
				for(int j2=j;j2<=n;j2++)
				{
					for(int i3=i2+1;i3<=n;i3++)
					{
						for(int j3=j2+1;j3<=n;j3++)
						{
							if(pre[i2][j2]-pre[i2][j-1]-pre[i-1][j2]+pre[i-1][j-1]==pre[i3][j3]-pre[i3][j2]-pre[i2][j3]+pre[i2][j2])ans++;
						}
					}
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```
这里有一个小技巧，因为两个矩阵有两种排列方式，左上-右下以及左下-右上，所以在处理后一种情况的时候，可以把矩阵左右翻转一下，然后就会变成第一种情况，但是要记得重算前缀和。
____
### 做法2：
根据上面那个技巧，我们只用讨论第一种情况，即左上-右下，那么，朴素算法是枚举第一个矩形的左上、右下顶点与第二个矩形的右下顶点。这里可以用桶进行一个优化，我们先枚举第一个矩形的右下顶点，然后用桶来记录以这个顶点为右下的所有有可能的和，再枚举第二个矩形的右下顶点，判断第二个矩形的和在第一个矩形里有几种情况，累加起来即可，附上代码。
```cpp
#include<bits/stdc++.h>
#define M 2500000
using namespace std;
int n,a[53][53],pre[53][53],ans;
int mp1[5000003];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a[i][j]);
			pre[i][j]=pre[i][j-1]+pre[i-1][j]-pre[i-1][j-1]+a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int o=1;o<=i;o++)
			{
				for(int u=1;u<=j;u++)
				{
					mp1[pre[i][j]-pre[i][u-1]-pre[o-1][j]+pre[o-1][u-1]+M]++;
				}
			}
			for(int o=i+1;o<=n;o++)
			{
				for(int u=j+1;u<=n;u++)
				{
					ans+=mp1[pre[o][u]-pre[o][j]-pre[i][u]+pre[i][j]+M];
				}
			}
			for(int o=1;o<=i;o++)
			{
				for(int u=1;u<=j;u++)
				{
					mp1[pre[i][j]-pre[i][u-1]-pre[o-1][j]+pre[o-1][u-1]+M]--;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j*2<=n;j++)swap(a[i][j],a[i][n-j+1]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			pre[i][j]=pre[i][j-1]+pre[i-1][j]-pre[i-1][j-1]+a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int o=1;o<=i;o++)
			{
				for(int u=1;u<=j;u++)
				{
					mp1[pre[i][j]-pre[i][u-1]-pre[o-1][j]+pre[o-1][u-1]+M]++;
				}
			}
			for(int o=i+1;o<=n;o++)
			{
				for(int u=j+1;u<=n;u++)
				{
					ans+=mp1[pre[o][u]-pre[o][j]-pre[i][u]+pre[i][j]+M];
				}
			}
			for(int o=1;o<=i;o++)
			{
				for(int u=1;u<=j;u++)
				{
					mp1[pre[i][j]-pre[i][u-1]-pre[o-1][j]+pre[o-1][u-1]+M]--;
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```
注意桶下标不要出负数，还有还原时用 memset 会超时。

---

## 作者：Wf_yjqd (赞：2)

这难道不应该是橙题吗？然而我又调了半小时。。

------------

首先想到用二维前缀和维护矩阵的和，那只用枚举矩形的顶点好了。

考虑如果枚举四个顶点（其中两点重合），复杂度至少为 $\operatorname{O}(n^6)$，基本是过不了。

那可以预处理掉一个顶点，复杂度为 $\operatorname{O}(n^4)$，是可以通过的。

具体如何预处理呢？

我们枚举第一个顶点后，接着枚举第二个，然后用 map 记录每个矩阵和出现的个数。

然后枚举与他相对的矩形时，直接加上这个矩阵和的次数好了。

为了避免重复，第二个矩阵只用枚举四个方向中的不相对的两个方向即可。

------------

结合代码理解吧，多少有点细节。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=52;
int n,ans,qzh[maxn][maxn];
unordered_map<int,int> mp;
inline int sum(int lx,int ly,int rx,int ry){
    return qzh[rx][ry]-qzh[rx][ly-1]-qzh[lx-1][ry]+qzh[lx-1][ly-1];
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            scanf("%d",&qzh[i][j]);
            qzh[i][j]+=qzh[i-1][j]+qzh[i][j-1]-qzh[i-1][j-1];
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            mp.clear();
            for(int ii=i;ii<=n;ii++)
                for(int jj=j;jj<=n;jj++)
                    mp[sum(i,j,ii,jj)]++;
            for(int ii=1;ii<=i-1;ii++)
                for(int jj=1;jj<=j-1;jj++)
                    ans+=mp[sum(ii,jj,i-1,j-1)];
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            mp.clear();
            for(int ii=i;ii<=n;ii++)
                for(int jj=1;jj<=j;jj++)
                    mp[sum(i,jj,ii,j)]++;
            for(int ii=1;ii<=i-1;ii++)
                for(int jj=j+1;jj<=n;jj++)
                    ans+=mp[sum(ii,j+1,i-1,jj)];
        }
    printf("%d",ans);
    return 0;
}
```


---

## 作者：__Ginka__ (赞：0)

### 1. 前缀和的计算
首先，我们定义一个 $s$ 数组用于存储矩阵的 **前缀和**。给定矩阵 $a$，$s_{i,j}$ 表示从 $a_{1,1}$ 到 $a_{i,j}$ 的矩阵区域的总和。

### 2. 使用哈希数组统计子矩阵和
为了统计所有符合条件的子矩阵的数量，我们定义一个哈希数组 $f$ 用于统计每个可能的子矩阵和出现的次数。

对于每一个子矩阵（由两个对角点 $(k,l)$ 和 $(i,j)$ 定义），计算其和，并将其放入 $f$ 数组中。

子矩阵和的范围可能会很大，因此我们将和加上一个偏移量 $2500000$，确保数组下标为正值。

### 3. 两阶段遍历进行统计
通过两阶段遍历来统计符合条件的子矩阵：
1. 第一阶段遍历所有可能的子矩阵**起点** $(k,l)$，并更新哈希数组 $f$。
2. 第二阶段遍历所有可能的子矩阵**终点** $(i,j)$，并使用哈希数组 $f$ 来查询符合条件的子矩阵和的数量，最终累加到结果中。

### 4. 重置哈希数组
在计算过程中，每次处理完一个终点后，我们需要重置，以保证不会影响到后续的计算。

代码非常简单易懂，思路相信也很清楚了，就不放注释力。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,a[55][55],s[55][55],f[5000005];
int C(int x,int y,int a,int b)
{
    return s[x][y]-s[a-1][y]-s[x][b-1]+s[a-1][b-1];
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            for(int k=1;k<=i;k++)
                for(int l=1;l<=j;l++)
                    f[C(i,j,k,l)+2500000]++;
            for(int k=i+1;k<=n;k++)
                for(int l=j+1;l<=n;l++)
                    ans+=f[C(k,l,i+1,j+1)+2500000];
            for(int k=1;k<=i;k++)
                for(int l=1;l<=j;l++)
                    f[C(i,j,k,l)+2500000]--;
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            for(int k=1;k<=i;k++)
                for(int l=j;l<=n;l++)
                    f[C(i,l,k,j)+2500000]++;
            for(int k=i+1;k<=n;k++)
                for(int l=1;l<=j-1;l++)
                    ans+=f[C(k,j-1,i+1,l)+2500000];
            for(int k=1;k<=i;k++)
                for(int l=j;l<=n;l++)
                    f[C(i,l,k,j)+2500000]--;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P6537 题目](https://www.luogu.com.cn/problem/P6537)

### 解题思路
我们首先可以用二维前缀和预处理各个矩阵的和，不难想到，可以枚举 $2$ 个矩阵的 $4$ 个顶点，由于有两个点重合，所以只需要枚举 $3$ 个顶点，时间复杂度 $O(n^6)$，明显超限。

我们在看看数据范围：$-1000\le a_{i,j}\le1000$，所以任意一个子矩阵的和的不会超过 $1000\times50^2=2500000$，也不会低于 $-1000\times50^2=-2500000$。

所以我们可以在枚举顶点时用一个数组记录每个矩阵和出现的次数，这样我们就可以少枚举一个顶点，时间复杂度 $O(n^4)$，不会超限。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[51][51],s[51][51],m[5000001];
signed main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i==1)
			{
				s[i][j]=s[i][j-1]+a[i][j];
				continue;
			}
			if(j==1)
			{
				s[i][j]=s[i-1][j]+a[i][j];
				continue;
			}
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
		}
	}
	int s1=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=i;k++)
			{
				for(int l=1;l<=j;l++)
				{
					int ss=s[i][j]-s[k-1][j]-s[i][l-1]+s[k-1][l-1]+2500000;
					m[ss]++;
				}
			}
			for(int k=i+1;k<=n;k++)
			{
				for(int l=j+1;l<=n;l++)
				{
					int ss=s[k][l]-s[i][l]-s[k][j]+s[i][j]+2500000;
					s1+=m[ss];
				}
			}
			for(int k=1;k<=i;k++)
			{
				for(int l=1;l<=j;l++)
				{
					int ss=s[i][j]-s[k-1][j]-s[i][l-1]+s[k-1][l-1]+2500000;
					m[ss]--;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n/2;j++)
			swap(a[i][n+1-j],a[i][j]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i==1)
			{
				s[i][j]=s[i][j-1]+a[i][j];
				continue;
			}
			if(j==1)
			{
				s[i][j]=s[i-1][j]+a[i][j];
				continue;
			}
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=i;k++)
			{
				for(int l=1;l<=j;l++)
				{
					int ss=s[i][j]-s[k-1][j]-s[i][l-1]+s[k-1][l-1]+2500000;
					m[ss]++;
				}
			}
			for(int k=i+1;k<=n;k++)
			{
				for(int l=j+1;l<=n;l++)
				{
					int ss=s[k][l]-s[i][l]-s[k][j]+s[i][j]+2500000;
					s1+=m[ss];
				}
			}
			for(int k=1;k<=i;k++)
			{
				for(int l=1;l<=j;l++)
				{
					int ss=s[i][j]-s[k-1][j]-s[i][l-1]+s[k-1][l-1]+2500000;
					m[ss]--;
				}
			}
		}
	}
	cout<<s1<<"\n";
	return 0;
}
/*
hack:

Right Answer:

Wrong Answer:

*/
```

---

## 作者：T_TLucas_Yin (赞：0)

我们应当知道，使用二维前缀和的预处理可以使得 $O(1)$ 求出一个子矩阵的元素和。

如果我们暴力枚举所有的矩阵，由于两个矩阵有一个公共端点，所以总共需要枚举三个点，枚举每个点需要 $O(n^2)$，三个点就需要 $O(n^6)$。显然，这是不行的。

由于有一个点是两个矩阵共有的，所以我们其实可以把枚举矩阵的两层循环改为两次循环。方法就是枚举公共端点，然后先用标记数组存下该端点一侧每种矩阵元素和的数量，再枚举另一侧的矩阵，直接统计这其中每个矩阵的元素和在标记数组中出现的数量，即为该矩阵的对应矩阵数量。所有答案相加即为最终的结果。

注意，两个对应的矩阵有两种位置关系：一个在另一个的右下方和一个在另一个的左下方。

在用桶标记值域的时候，一般用 STL 的映射表更保险，可以防止下标非法。如果怕常数大，可以用无序映射。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005][1005],f[1005][1005],sum;
unordered_map<int,int> m;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) f[i][j]=f[i-1][j]+f[i][j-1]+a[i][j]-f[i-1][j-1];
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++){//左上-右下的位置关系
		m.clear();
		for(int x=1;x<=i;x++) for(int y=1;y<=j;y++)
			m[f[i][j]-f[i][y-1]-f[x-1][j]+f[x-1][y-1]]++;
		for(int x=i+1;x<=n;x++) for(int y=j+1;y<=n;y++)
			sum+=m[f[x][y]-f[x][j]-f[i][y]+f[i][j]];
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++){//右上-左下的位置关系
		m.clear();
		for(int x=1;x<=i;x++) for(int y=j;y<=n;y++)
			m[f[i][y]-f[i][j-1]-f[x-1][y]+f[x-1][j-1]]++;
		for(int x=i+1;x<=n;x++) for(int y=1;y<j;y++)
			sum+=m[f[x][j-1]-f[x][y-1]-f[i][j-1]+f[i][y-1]];
	}
	printf("%d",sum);
	return 0;
}
```

---

## 作者：CyberPrisoner (赞：0)

要计算满足条件的矩阵个数，对于每一个点，暴力枚举所有以该点为顶点的矩阵即使利用前缀和快速计算矩阵内所有数的和，这样时间复杂度也达到了恐怖的 $O(n^6)$。

那么我们考虑重复计算了哪些东西，关于一个点对角的两个矩阵，我们枚举了它们的所有对的情况，也就是说我们同一个矩阵可能要求 $n^2$ 次。我们考虑如何只考虑一次，我们可以用桶存一下对角矩阵中大小为 $sum(a,b,c,d)$ 的个数，发现计算出一个矩阵的大小 $sum(a,b,c,d)$，最后答案会增加它对角的矩阵大小是 $sum(a,b,c,d)$ 的的个数，最后时间复杂度应该是 $O(n^4)$。

 _code_ 

```
#include<bits/stdc++.h>
using namespace std;
const int N=52;
int s[N][N],a[N][N];
int n,ans;
map<int,int> cnt[5];//map方便处理负数，缺点是常数大
int getsum(int x1,int y1,int x2,int y2){
	return s[x1][y1]-s[x1][y2]-s[x2][y1]+s[x2][y2];
}
void solve1(int x,int y){
	cnt[1].clear();	
	for(int i=x-1;i>=0;i--){
		for(int j=y+1;j<=n;j++){
			cnt[1][getsum(x,j,i,y)]++;
		}
	}
}
void solve2(int x,int y){
	cnt[2].clear();
	for(int i=x-1;i>=0;i--){
		for(int j=y-1;j>=0;j--){
			cnt[2][getsum(x,y,i,j)]++;
		}
	}
}
void solve3(int x,int y){
	for(int i=x+1;i<=n;i++){
		for(int j=y-1;j>=0;j--){
			ans+=cnt[1][getsum(i,y,x,j)];
		}
	}
}
void solve4(int x,int y){
	for(int i=x+1;i<=n;i++){
		for(int j=y+1;j<=n;j++){
			ans+=cnt[2][getsum(i,j,x,y)];
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			s[i][j]=s[i][j-1]+s[i-1][j]-s[i-1][j-1]+a[i][j];
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<n;j++){
			solve1(i,j);solve2(i,j);
			solve3(i,j);solve4(i,j);//四个方位分别处理
		}
	}
	cout<<ans<<endl;
}
```


---

## 作者：IcyFoxer_XZY (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6537)

这题建议加强数据，暴力枚举都能过......

### 分析

首先看到这题我们可以先想到一个二维前缀和暴力的思路，枚举三个顶点。

时间复杂度 $O(n^6)$，理论上不行，可是吸氧之后竟然过了。

由于思路过于简单且码量较大，码风有点丑。

#### 代码：

```cpp
#include<cstdio>
#include<algorithm>
#define re register int
int n,a[52][52],sum[52][52],ans;
int main(){
	scanf("%d",&n);
	for(re i=1;i<=n;++i)
		for(re j=1;j<=n;++j){
			scanf("%d",&a[i][j]);
			sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+a[i][j];
		}
	for(re i=1;i<=n;++i)
	for(re j=1;j<=n;++j)
	for(re k=i;k<=n;++k)
	for(re I=j;I<=n;++I)
	for(re J=k+1;J<=n;++J)
	for(re K=I+1;K<=n;++K)
	if(sum[k][I]-sum[k][j-1]-sum[i-1][I]+sum[i-1][j-1]==sum[J][K]-sum[J][I]-sum[k][K]+sum[k][I])
	ans++;
	for(re i=1;i<=n;++i)
	for(re j=1;j*2<=n;++j)
	std::swap(a[i][j],a[i][n-j+1]);
	for(re i=1;i<=n;++i)
	for(re j=1;j<=n;++j)
	sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+a[i][j];
	for(re i=1;i<=n;++i)
	for(re j=1;j<=n;++j)
	for(re k=i;k<=n;++k)
	for(re I=j;I<=n;++I)
	for(re J=k+1;J<=n;++J)
	for(re K=I+1;K<=n;++K)
	if(sum[k][I]-sum[k][j-1]-sum[i-1][I]+sum[i-1][j-1]==sum[J][K]-sum[J][I]-sum[k][K]+sum[k][I])
	ans++;
	printf("%d",ans);
	return 0;
}
```

显然一道绿题不是让你单纯枚举那么简单。这道题可以用桶进行优化。

我们先枚举交点，然后用桶记录交点左上角可能的元素和，然后枚举右下角矩形边长，最后在区间内查找是否有相同元素和。

时间复杂度 $O(n^4)$。

#### 代码：

```cpp
#include<cstdio>
const int M=100000;
int n,ans,a[52][52],s[52][52],f[8000000];
int calc(int x,int y,int a,int b){return s[x][y]-s[a-1][y]-s[x][b-1]+s[a-1][b-1];}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
		    scanf("%d",&a[i][j]);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
		    s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j){
            for(int k=1;k<=i;++k)
                for(int l=1;l<=j;++l)
				    f[calc(i,j,k,l)+M]++;
            for(int k=i+1;k<=n;++k)
                for(int l=j+1;l<=n;++l)
                    ans+=f[calc(k,l,i+1,j+1)+M];
            for(int k=1;k<=i;++k)
                for(int l=1;l<=j;++l)
				    f[calc(i,j,k,l)+M]--;
        }
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j){
            for(int k=1;k<=i;++k)
                for(int l=j;l<=n;++l)
				    f[calc(i,l,k,j)+M]++;
            for(int k=i+1;k<=n;++k)
                for(int l=1;l<=j-1;++l)
                    ans+=f[calc(k,j-1,i+1,l)+M];
            for(int k=1;k<=i;++k)
                for(int l=j;l<=n;++l)
				    f[calc(i,l,k,j)+M]--;
       }
    printf("%d",ans);
    return 0;
}
```
Bye！

---

## 作者：zhongcy (赞：0)

### Solution

-----------

由于要统计子矩阵和，显然应该先做一遍二维前缀和。

再考虑统计和相等的矩阵个数。因为数据很小，$n\le50$，考虑直接暴力枚举相邻的顶点，再分类讨论，可以用桶来存储和进行比较，分别统计左上与右下的矩阵与右上与左下的矩阵。

注意下标可能为负，所以先加上最大的和 $2500000$ 再统计。如果直接用 map 存储常数巨大，喜提 40pts。

时间复杂度 $\mathcal{O}(n^4)$。

### Code

-----------

```cpp
#include<bits/stdc++.h>
#define N 51
#define M 2500000
#define ll long long
using namespace std;
ll n,ans;
ll a[N][N],pre[N][N];
ll mp[M<<1|1];
ll calc(ll x,ll y,ll z,ll w)
{
	return pre[x][y]-pre[z-1][y]-pre[x][w-1]+pre[z-1][w-1];
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j],pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=i;k++)
				for(int l=1;l<=j;l++)
					mp[calc(i,j,k,l)+M]++;
			for(int k=i+1;k<=n;k++)	
				for(int l=j+1;l<=n;l++)
					ans+=mp[calc(k,l,i+1,j+1)+M];
			for(int k=1;k<=i;k++)
				for(int l=1;l<=j;l++)
					mp[calc(i,j,k,l)+M]=0;
					
			for(int k=1;k<=i;k++)
				for(int l=j;l<=n;l++)
					mp[calc(i,l,k,j)+M]++;
			for(int k=i+1;k<=n;k++)	
				for(int l=1;l<=j-1;l++)
					ans+=mp[calc(k,j-1,i+1,l)+M];
			for(int k=1;k<=i;k++)
				for(int l=j;l<=n;l++)
					mp[calc(i,l,k,j)+M]=0;
		}
	cout<<ans;
	return 0;
}
```

---


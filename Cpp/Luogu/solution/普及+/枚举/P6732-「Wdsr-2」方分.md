# 「Wdsr-2」方分

## 题目描述

平面直角坐标系上有两个相离的正方形 $A$ 和 $B$。请找到任意一条直线把它们分隔到直线的两侧。

**注意：这条直线不应该和正方形有公共点。**

## 说明/提示

$1\le T\le 10000$。

输入的坐标绝对值不超过 $10^3$，小数点后最多有 $3$ 位数字。

**SPJ 使用双精度浮点数计算验证你的答案，请尽可能地避免精度误差。**

避免精度误差的方式有：不要输出绝对值过大或过小的数字，输出尽可能多的小数点后位数，比较大小时使用 eps，等等。

赛后已加入 Hack 数据。

## 样例 #1

### 输入

```
1
1.0 1.0
2.0 2.0
1.0 2.0
2.0 1.0
0.0 0.0
-0.5 -0.5
0.0 -1.0
0.5 -0.5```

### 输出

```
0.0 1.0 0.5```

# 题解

## 作者：一只书虫仔 (赞：14)

#### Description

> 给定两个正方形，求一条直线将这两个正方形分到两个平面里。

#### Solution

~~暴力枚举 + 分类讨论大屑题~~

考虑正方形 A 与正方形 B 的位置关系，我们考虑正方形 A，并将他的四条边延长成为四条直线。

![屏幕截图 2021-08-31 212629.png](https://i.loli.net/2021/08/31/ZKz5m8Aj3UHwgfR.png)

然后我们考虑正方形 B 与这四条直线的关系。

注意：下文 挪 即意为答案直线的获取过程，往外 即为往正方形所在的相反方向。

关系 1：与四条直线都没有交点。

分类 1.1：

![A.png](https://i.loli.net/2021/08/31/UT4pILW9P7csy3j.png)

![C.png](https://i.loli.net/2021/08/31/E7GvYbdkm2tOwuf.png)

![E.png](https://i.loli.net/2021/08/31/RZgT6sNOXhpWy8L.png)


只需要把直线 AD 往外挪一点点就可以了。

分类 1.2：

![G.png](https://i.loli.net/2021/08/31/gEHtKuNJXIOUqVe.png)

只需要把直线 AB 往外挪一点点就可以了。

分类 1.3：

![I.png](https://i.loli.net/2021/08/31/sZC83HwinOoGJLv.png)

![K.png](https://i.loli.net/2021/08/31/dKvJUWEaVcMopbq.png)

![M.png](https://i.loli.net/2021/08/31/1dGyeBWkSEwUap3.png)

只需要把直线 BC 往外挪一点点就可以了。

分类 1.4：

![O.png](https://i.loli.net/2021/08/31/6ImwazXVQt9TpK5.png)


只需要把直线 CD 往外挪一点点就可以了。

关系 2：与四条直线有一个交点

分类 2.1：

![B.png](https://i.loli.net/2021/08/31/wAUPqDQ52K3HNex.png)

![D.png](https://i.loli.net/2021/08/31/CynJQTSvcFfORlg.png)

只需要把直线 AD 往外挪一点点就可以了。

分类 2.2：

![F.png](https://i.loli.net/2021/08/31/yJlVPa4xHKu2gf3.png)

![H.png](https://i.loli.net/2021/08/31/7x8zAjGYuvNdm3O.png)

只需要把直线 AB 往外挪一点点就可以了。

分类 2.3：

![J.png](https://i.loli.net/2021/08/31/pfRaZdT1GY5OkgV.png)

![L.png](https://i.loli.net/2021/08/31/FYZBPMXgdL3V6Gt.png)

只需要把直线 BC 往外挪一点点就可以了。

分类 2.4：

![N.png](https://i.loli.net/2021/08/31/SHkf93CFpbExa58.png)

![P.png](https://i.loli.net/2021/08/31/Vq7NSwrpExModWc.png)

只需要把直线 CD 往外挪一点点就可以了。

关系 3：与四条直线有两个交点

分类 3.1：

![](https://cdn.luogu.com.cn/upload/image_hosting/0w35dxev.png)

只需要把直线 EH 往外挪一点点就可以了。

分类 3.2：

![](https://cdn.luogu.com.cn/upload/image_hosting/e1mu32p6.png)

只需要把直线 AD 往外挪一点点就可以了。

分类 3.3：

![](https://cdn.luogu.com.cn/upload/image_hosting/400w6cm7.png)

只需要把直线 EF 往外挪一点点就可以了。

分类 3.4：

![](https://cdn.luogu.com.cn/upload/image_hosting/o8ikmt0c.png)

只需要把直线 AB 往外挪一点点就可以了。

分类 3.5：

![](https://cdn.luogu.com.cn/upload/image_hosting/yfvxm92v.png)

只需要把直线 FG 往外挪一点点就可以了。

分类 3.6：

![](https://cdn.luogu.com.cn/upload/image_hosting/tuh0lytj.png)

只需要把直线 BC 往外挪一点点就可以了。

分类 3.7：

![](https://cdn.luogu.com.cn/upload/image_hosting/o6cxdr5f.png)

只需要把直线 GH 往外挪一点点就可以了。

分类 3.8：

![](https://cdn.luogu.com.cn/upload/image_hosting/jfo8jsna.png)

只需要把直线 CD 往外挪一点点就可以了。

与大于 $2$ 条直线相交的情况也能转化到与 $2$ 条直线相交的情况，更多的是将正方形 B 上的某一条边向外挪一点点得到的，具体情况具体判断就可以了。

然后将以上的所有分类讨论模拟成代码就可以了。

~~然后这道屑题你就做完了~~

---

## 作者：XL4453 (赞：3)

### 解题思路：

不难的构造题。

其它题解的方式大多是分类讨论，非常麻烦，提供一种更轻量级的证明方式。

考虑如下引理：如图，已知 $AD \perp AC$，且 $BD\perp BC$，有两个被直角划分出来的不相交的 $\dfrac{1}{4}$ 平面，有至少一条直线只和一种颜色的区域相切。

很明显，当 $ABCD$ 构成了一个四边形的时候，根据内角和直接可以得出结论。而当 $C$ 或者 $D$ 在有颜色区域的边缘时，另一条边一定只和一种颜色相切。引理得证。

![](https://cdn.luogu.com.cn/upload/image_hosting/eys3bb2w.png)

---

回到原题，考虑正方形靠得近的两对边，发现就是一个这样的形状，根据引理，可以发现至少有一条边只和一个正方形相切。而且引理给出的“正方形”的大小其实是无穷大，也可能出现更多的边满足条件。不过本题只需要证明至少有一条就行了。

将这个相切的边进行微调就可以将两个正方形分开了。

---
实现上直接枚举所有的边进行微调就行了，并不需要真的找出靠近的四条边。

---
### 代码：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const double eps=1e-10;
int T;
double ax[10],ay[10],bx[10],by[10],res,flag;
bool side(double a,double b,double c,double x,double y){
	return a*x+b*y<c;
}
void check(double a,double b,double c){//ax+by=c
	for(int i=2;i<=4;i++){
		if(side(a,b,c,ax[i-1],ay[i-1])!=side(a,b,c,ax[i],ay[i]))return;
		if(side(a,b,c,bx[i-1],by[i-1])!=side(a,b,c,bx[i],by[i]))return;
	}
	if(side(a,b,c,ax[1],ay[1])==side(a,b,c,bx[1],by[1]))return;
	if(flag==0)printf("%.12lf %.12lf %.12lf\n",a,b,c);
	flag=1;
}
int main(){
	scanf("%d",&T);
	while(T--){
		flag=0;
		for(int i=1;i<=4;i++)cin>>ax[i]>>ay[i];
		for(int i=1;i<=4;i++)cin>>bx[i]>>by[i];
		for(int i=1;i<=4;i++)
		for(int j=i+1;j<=4;j++){
			check(ay[i]-ay[j],ax[j]-ax[i],-ay[j]*ax[i]+ax[j]*ay[i]+eps);
			check(ay[i]-ay[j],ax[j]-ax[i],-ay[j]*ax[i]+ax[j]*ay[i]-eps);
			check(by[i]-by[j],bx[j]-bx[i],-by[j]*bx[i]+bx[j]*by[i]+eps);
			check(by[i]-by[j],bx[j]-bx[i],-by[j]*bx[i]+bx[j]*by[i]-eps);
		}
	}
	return 0;
}
```


---

## 作者：littleKtian (赞：3)

upd on 2021.8.26：据评论区反应图挂了（其实我觉得应该是 sm.ms 图床在某些电脑上不稳定导致的），所以将图片全部换成洛谷图床的了。

------------

首先要知道对于一些点 $(x_i,y_i)$ 和一条直线 $ax+by+c=0$，要判断其相对这条直线的位置可以根据 $ax_i+by_i+c$ 的正负性判断（$>0$ 的在同一侧，$<0$ 的在另一侧，$=0$ 的在这条直线上）

可以证明一定存在某条将两个正方形分开的直线，其与某条正方形的边平行。

证明：

我们把其中一个正方形四条边所在直线都画出来，研究另一个正方形与这四条直线的关系。

+ 另一个正方形与这四条直线均没有交点。

![](https://cdn.luogu.com.cn/upload/image_hosting/n6at2uy3.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/0e2tmn5k.png)

显然无论另一个正方形在这八个区域内的哪一个，都能找到一条与这四条直线中的某一条平行的直线满足要求。

+ 另一个正方形与这四条直线中的一条有交点。

![](https://cdn.luogu.com.cn/upload/image_hosting/7cw7s1g2.png)

和上面类似，一定能找出这样一条直线。

+ 另一个正方形与这四条直线中的两条或更多直线有交点。

![](https://cdn.luogu.com.cn/upload/image_hosting/u76dq9c6.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/hrlv4a1s.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/fifowjnq.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ibus9v3w.png)

发现除第一张图外第一个正方形与红线没有交点，一定存在某条与红线平行的直线满足要求。而第一张图则跟上面只与一条线有交点/没有交点的情况类似，也一定能找出。

因此我们只要对全部八条边暴力判一遍就行了。

（官方题解用的是微调，~~但我不知道微调多少能过~~就每次取一个正方形的某条边与另一个正方形的某个点中间那条线）

注意精度问题。

（考虑到可能有人因为精度问题可能会被卡，还是决定贴个代码作为参考）
```cpp
#include<bits/stdc++.h>
using namespace std;
struct point{
	double x,y;
};
point A[5],B[5];
int t;
int check(double a,double b)
{
	if(abs(a-b)<1e-10)return 0;
	else if(a<b)return -1;
	else return 1;
}
double dis(point p,point q){return sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2));}
void px(point *f)
{
	double d[4];
	for(int i=1;i<4;i++)d[i]=dis(f[0],f[i]);
	if(check(d[1],d[2])==0)swap(f[2],f[3]);
	else if(check(d[2],d[3])==0)swap(f[1],f[2]);
}
double ud(double a,double b,point x){return a*x.x+b*x.y;}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		for(int i=0;i<4;i++)scanf("%lf%lf",&A[i].x,&A[i].y);
		A[4]=A[0];
		px(A);
		for(int i=0;i<4;i++)scanf("%lf%lf",&B[i].x,&B[i].y);
		B[4]=B[0];
		px(B);
		int out=0;
		for(int i=0;i<4;i++)
		{
			for(int j=0;j<4;j++)
			{
				double a=B[j].x-B[j+1].x,b=B[j].y-B[j+1].y,c1=ud(a,b,A[i]),c2=ud(a,b,B[j]);
				c1=(c1+c2)/2;
				int fx1=0,fx2=0;
				for(int k=0;k<4;k++)fx1+=check(ud(a,b,A[k]),c1);
				for(int k=0;k<4;k++)fx2+=check(ud(a,b,B[k]),c1);
				if((fx1==4&&fx2==-4)||(fx1==-4&&fx2==4)){out=1;printf("%0.4f %0.4f %0.8f\n",a,b,c1);break;}
			}
			if(out)break;
		}
		if(out)continue;
		for(int i=0;i<4;i++)
		{
			for(int j=0;j<4;j++)
			{
				double a=A[j].x-A[j+1].x,b=A[j].y-A[j+1].y,c1=ud(a,b,B[i]),c2=ud(a,b,A[j]);
				c1=(c1+c2)/2;
				int fx1=0,fx2=0;
				for(int k=0;k<4;k++)fx1+=check(ud(a,b,A[k]),c1);
				for(int k=0;k<4;k++)fx2+=check(ud(a,b,B[k]),c1);
				if((fx1==4&&fx2==-4)||(fx1==-4&&fx2==4)){out=1;printf("%0.4f %0.4f %0.8f\n",a,b,c1);break;}
			}
			if(out)break;
		}
	}
}
```


---

## 作者：囧仙 (赞：2)

## 题目大意

平面直角坐标系中，有两个不相交的正方形。求任意一条在这两个正方形之间的直线解析式。直线不能与正方形有交点。

这里是$\stackrel{\text{咕咕咕}}{\text{迟到}}$的官方题解。

## 题解

我们只需要枚举 $8$ 条边，将其进行微调（向上移或者向下移，具体移动多少要看精度，只要 $\text{SPJ}$ 不会判相交就行），判断是否可行即可。下证这种做法的正确性。

考虑到我们只关心两个正方形的相对位置，因此我们可以把其中一个正方形固定到坐标原点，并使其边与坐标轴平行。另一个正方形可以放到它的右上角（或者说，可以通过左右翻转、上下翻转操作使得这个正方形总是处在第一个正方形的上方、右方部分）。

- 当正方形 $CDHG$ 没有点在 $EF$ 下时，显然所求直线在 $EF$ 上方平移一点点。

![_pic1.jpg](https://i.loli.net/2020/07/19/aDEmMIpdSsflUAi.jpg)

- 当正方形 $CDHG$ 没有点在 $BE$ 右时，显然所求直线在 $BE$ 右方平移一点点。

![_pic2.jpg](https://i.loli.net/2020/07/19/YX7RTrUQAzgSwd2.jpg)

- 当正方形 $CDHG$ 同时有点在 $EF$ 下方、$BE$ 右方时，取这两个点的连线即可。在下图中，所求直线即为 $GH$ 下方平移一点点。

![_pic3.jpg](https://i.loli.net/2020/07/19/RzFWH12XdTowUeb.jpg)

关于点在直线位置的判定，假设有一个直线的解析式为 $Ax+By+C=0$ ，那么带入点的坐标 $(x_0,y_0)$ ，所得的 $Ax_0+By_0+C$ 的正负即可作为判定该点在直线位置的标准。特别地，如果 $Ax_0+By_0+C=0$ ，那么就说明这个点在直线上。不过通过微调，我们总是能保证不会有正方形顶点在所求直线上。

另外，作为出题人，这里有必要谈一点细节：

- 虽然 $\text{SPJ}$ 使用双精度浮点数，但由于误差是会被平方放大的，请务必保证你的结果精度足够高（位数多一点好）。

- 因为是多测，所以大概卡掉了一些奇怪的做法。数据出的可能有些毒瘤（）

- 这题难点可能在于不容易想到构造方法。但一旦想到了，其实是比较容易构造的。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;
typedef double f64;
const f64 eps=1e-8;
bool f; f64 A[5][2],B[5][2]; int T;
bool clc(f64 x,f64 y,f64 a,f64 b,f64 c){return a*x+b*y+c>0;}
bool fnd(f64 a,f64 b,f64 c){
    if(f) return false; bool t=clc(A[1][0],A[1][1],a,b,c);
    up(1,4,i) if(clc(A[i][0],A[i][1],a,b,c)!=t) return false;
    up(1,4,i) if(clc(B[i][0],B[i][1],a,b,c)==t) return false;
    printf("%.12lf %.12lf %.12lf\n",a,b,-c); return f=true;
}
bool chk(f64 x0,f64 y0,f64 x1,f64 y1){
    if(f) return false;
    f64 a=y1-y0,b=x0-x1,c=y0*(x1-x0)-x0*(y1-y0);
    return fnd(a,b,c+eps)|fnd(a,b,c-eps);
}
int main(){
    scanf("%d",&T);
    dn(T,1,TEST){
        f=false;
        up(1,4,i) scanf("%lf%lf",&A[i][0],&A[i][1]);
        up(1,4,i) scanf("%lf%lf",&B[i][0],&B[i][1]);
        up(1,4,i) up(1,i-1,j) if(!f){
            chk(A[i][0],A[i][1],A[j][0],A[j][1]),
            chk(B[i][0],B[i][1],B[j][0],B[j][1]);
        }
    }
    return 0;
}
/*
x+y+0.005=0
y=-0.005
*/
```

---


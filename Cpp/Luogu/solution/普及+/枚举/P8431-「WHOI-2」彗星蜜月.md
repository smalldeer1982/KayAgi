# 「WHOI-2」彗星蜜月

## 题目背景

![](bilibili:BV11x411Q7PY)

看完这首 mv 的前奏之后你应该知道 $f$ 是什么鬼了（误）。

## 题目描述

定义 $f(x)$ 是 $x$ 的各位数码翻转以后形成的数。

例如：

- $f(12323)=32321$
- $f(114514)=415411$
- $f(250)=52$
---

给定一个 $n$。求最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$。

## 说明/提示

对于测试样例 $1$：
$f(1)=1,f(2)=2,f(3)=3,f(4)=4,f(5)=5,f(6)=6,f(7)=7,f(8)=8,f(9)=9,f(10)=1,f(11)=11,f(12)=21$。所以 $k$ 最大为 $11$。

---
**本题采用捆绑测试**

- $\text{subtask1(10pts)}:1\leq T,n\leq10^3$。
- $\text{subtask2(30pts)}:1\leq n\leq10^6$。
- $\text{subtask3(40pts)}:1\leq n\leq10^9$。
- $\text{subtask4(20pts)}:$ 无特殊限制。

对于 $100\%$ 的数据，$1\leq T\leq10^5,1\leq n\leq10^{18}$。

提示：`unsigned long long` 可以储存 $0$ 到 $18,446,744,073,709,551,615(2^{64}-1)$ 的自然数。 

## 样例 #1

### 输入

```
3
12
991
114514```

### 输出

```
11
298
100001```

## 样例 #2

### 输入

```
2
99999
99998```

### 输出

```
100000
99998```

# 题解

## 作者：liangbowen (赞：47)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P8431)

[更好的阅读体验？](https://www.luogu.com.cn/blog/liangbowen/solution-p8431)

这题题解都写得特别复杂，蒟蒻看不懂。因此，我补一篇简单的贪心题解。

## 思路

题目等同于求最小的 $p$ 使得 $f(p)>n$，则 $(p-1)$ 就是答案。

若 $f(p) > n$，首先要保证 $p$ 的位数大于等于 $n$ 的位数。根据贪心思想，我们**让末尾不存在** $0$。

保证了 $p$ 的末尾数不为 $0$，可以得到：$f(f(p)) = p$。

因此，我们可以贪心地枚举 $f(p)$。我们枚举 $1 \le i \le len(p)$，其中 $len(p)$ 表示 $p$ 的位数。

如何构造 $g = f(p)$ 呢？步骤如下。

+ 对于每个 $i$，让第 $i$ 位的数加一，自然进位。
+ 第 $[i+1, len(p)-1]$ 位均变为 $0$。
+ 第 $len(p)$ 位变为 $1$，因为末尾不可以是 $0$。

显而易见，这样构造出的数 $g$ 必定大于 $n$，并且反转后相对来说比较小，因为反转后靠近首位的 $0$ 较多。

因此，我们直接取 $(\min\limits_{i=1}^{len(n)}{g} - 1)$ 就是答案了。

听起来有些晦涩难懂，代码实现实际比较简单。

总时间复杂度 $O\Big(T \times len(n)\Big)$。

## 代码实现

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long LL;
int LEN(LL n) //计算 n 的位数。 
{
	int cnt = 0;
	while (n) cnt++, n /= 10;
	return cnt;	
}
LL f(LL n) //如题的 f(x) 函数。 
{
	LL ans = 0;
	while (n) ans = ans * 10 + (n % 10), n /= 10;
	return ans;
}
void solve()
{
	LL n, minn = 9e18;
	scanf("%lld", &n);
	int len = LEN(n);
	for (int i = 0; i <= len; i++)
	{
		LL p = pow(10, (LL)i); //第 i 位加一。 
		LL ni = n - (n % p) + p; //后面的位全部变成 0。 
		if (ni % 10 == 0) ni++;  // 最后一位变成 1。 
		minn = min(minn, f(ni));
		//printf("ni = %lld;\n", f(ni));
	}
	printf("%lld\n", minn - 1);
}
int main()
{
    int T;
    scanf("%d", &T);
    while (T--) solve();
    return 0;
}
```

希望能帮助到大家！

---

## 作者：EthanC_ (赞：28)

这是一道分类讨论题。
### 思路：
我们可以把数据分为 $ 2 $ 个部分。
- 不以 $ 9 $ 开头：
	1. 就输出 $ 1000...x $（$ 0 $ 的个数为字符串的长度减 $ 2 $）
    1. 例如 $ 2022 $，输出就是 $ 1002 $。
- 以 $ 9 $ 开头：
	1. 先输出一个 $ 1 $。
    1. 设字符串长度为 $ ls $，开头 $ 9 $ 的个数为 $ x $，再输出 $ ls-x-2 $ 个 $ 0 $。 
    1. 再输出从高位往低位第一个不是 $ 9 $ 的数加 $ 1 $。
    1. 再输出 $x-1$ 个 $ 9 $，最后输出一个 $ 8 $。
- 注意事项：
    1. 若输入的最后一个数是 $ 0 $，就将该数减 $ 1 $ 处理。
    1. 若 $ x=ls-1 $，就不输出开头的 $ 1 $。
    1. 特判 $ 1+x0 $。$ x0 $ 为 $ x $ 个 $ 0 $。
    1. 特判 $ x $ 个 $ 9 $。 
    
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long 
int atoi_(string s){
    int r=0;
    for (int i=0;i<s.size();i++)r=r*10+s[i]-48;
    return r;
}
void pd(string s){
    unsigned long long qwq=0;
    unsigned long long ans=0; 
    for(int i=0;i<s.size();++i){
        if(s.at(i)!='9'){
            ans=0;
            break;
        }
        else ans++;
    }
    for(int i=1;i<s.size();++i){
        if(s.at(i)!='0')
            break;
        else ans++;
    }
	unsigned long long k=0,c;
	c=atoi_(s);
    if(ans==s.size()){
        cout<<c+1<<endl;
        qwq=1;
    }
    if(ans==s.size()-1&&s.at(0)=='1'){
        cout<<s<<endl;
        qwq=1;
    }
	if(qwq==0){
        unsigned long long l=s.size();
        if(s[l-1]=='0'){
            unsigned long long x=0;
            for(int i=0;i<l;++i){
                x=x*10+(s[i]-'0');
            }
            x--;
            s="";
            while(x!=0){
                s.push_back((x%10)+'0');
                x/=10;
            }
            reverse(s.begin(),s.end());
        }
	    if(s[0]!='9'){
		    cout<<"1";
		    for(int i=0;i<s.size()-2;++i)
		    	cout<<"0";
		    cout<<s[0]<<endl;
	    }
	    else if(s[0]=='9'){
		    unsigned long long x=0;
		    for(int i=0;i<l;++i){
		    	if(s[i]=='9')
		    		x++;
		    	else break;
		    }
		    long long ww=l-x-2;
            if(x!=(l-1))cout<<"1";
		    if(ww!=(int)-1){
                for(int i=0;i<ww;++i)
		        	cout<<0;
            }
		    cout<<char(s[x]+1);
		    for(int i=0;i<x-1;++i)
		    	cout<<9;
		    cout<<8<<endl;
	    }
    }
}
signed main(){
	string s;
	unsigned long long n;
	cin>>n;
	for(int i=0;i<n;++i){
		cin>>s;
		if(s.size()>1||s=="9")pd(s);
        else cout<<s<<endl;
	}
    return 0;
}
```


---

## 作者：JackMerryYoung (赞：17)

# 前言

这题真的恶心，赛时写挂了就拿了 10 pts.

# 正文

## Subtask # 1

考虑做 $f_i$ 的前缀最大，则遇到第一个大于 $N$ 的 $f_i$ 即可知答案为 $i - 1$.

复杂度 $\mathcal{O}(TN^2)$, 能拿个 $10$ 分。

## Subtask # 2

考虑到 $f_i$ 的前缀最大序列具有单调性，可以二分查找，复杂度为 $\mathcal{O}(TN \log_2 N)$, 能拿个 $40$ 分。

## Subtask # 3 - # 4

嘿嘿，既然直接暴力会死，不妨考虑找规律。

比如 $9930843$ 对应 $1000498$, $40032$ 对应 $10004$, $99995$ 对应 $69998$.

如果你还看不出规律，那就再找找。

大量数据证明以下结论：

（第几位都是从左到右, $len$ 为该数字的总位数, $a_i$ 表示该数字的第 $i$ 位上的数）

### 1. 对于以连续的 $9$ 开头的

设 $pos$ 为第一个非 $9$ 的数字的位置，那么答案即为：

一个 $1$, $len - pos - 1$ 个 $0$, 一个 $a_{pos} + 1$, $pos - 2$ 个 $9$ 和一个 $8$.

证明：

翻转后的第一位必为 $1$, 否则一定包括了不合法情况。

$len - pos - 1$ 个 $0$ 对应 $pos$ 之后的非末位数字个数。

有一个 $a_{pos} + 1$ 是因为可以加上去，所以不加白不加就直接加。

$pos - 2$ 个 $9$ 是对应 $pos$ 之前的几个非首位 $9$.

注意：最后一个 $8$ 其实是 $9 - 1$.

这是因为前面在现在的高位（原来的低位）上大赚，这里（现在的低位，原来的高位）会小赔，不得不减去 $1$.

---

该死，还有一种情况：

注意有可能出现最后一位之前都是 $9$ 的情况，需要特判。

既然前面的 $0$ 都没了，自然首位可以取代一个 $a_{pos} + 1$. 

于是答案就是一个 $a_{pos} + 1$, 一堆 $9$, 最后输出一个 $8$.

### 2. 对于不以连续的 $9$ 开头的

这个就简单了，还是按照第一种的相同的思路思考，可以发现答案为：

一个 $1$, 一堆 $0$, 末尾输出原数首位。

证明留给读者思考，这里不在赘述啦。

### 3. 以零结尾

这个更简单，只需要减一即可。

证明：

以零结尾的数字翻转过来就一定比别人小了，那么前缀最大自然是上一个数的，而不可能是他的。

所以可以等效成求上一个数的答案。

--- 

至此，分类讨论结束。题目解法出来了。

复杂度 $\mathcal{O}(\sum{\log_{10} N})$, 十分优秀可以通过。

# 代码

``` cpp
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;

ull T, N;

signed main()
{
    cin >> T;
    for(ull i = 1; i <= T; ++ i)
    {
        cin >> N;
        bool is_all_nine = true;
        ull cnt = 0, tmp[25];
        memset(tmp, 0, sizeof(tmp));
        ull tmpN = N;
        if(N <= 8)
        {
            cout << N << endl;
            continue;
        }
        
        if(N % 10 == 0)
            -- N, -- tmpN;

        while(N)
        {
            tmp[++ cnt] = N % 10;
            N /= 10;
            if(tmp[cnt] != 9)
                is_all_nine = false;
        }

        if(is_all_nine)
            cout << tmpN + 1 << endl;
        else
        {
            if(tmp[cnt] == 9)
            {
                ull T, pos = 0;
                for(ull i = cnt; i >= 1; -- i)
                {
                    if(tmp[i] != 9)
                    {
                        T = tmp[i];
                        pos = i;
                        break;
                    }
                }

                if(pos == 1)
                {
                    printf("%d", T + 1);
                    for(ull i = 1; i <= cnt - 2; ++ i)
                        putchar('9');

                    puts("8");
                    continue;
                }

                putchar('1');
                for(ull i = 1; i <= pos - 2; ++ i)
                    putchar('0');

                putchar('0' + T + 1);
                for(ull i = 1; i <= cnt - pos - 1; ++ i)
                    putchar('9');

                puts("8");
            }
            else
            {
                cout << 1;
                for(ull i = 1; i <= cnt - 2; ++ i)
                    cout << 0;
                
                cout << tmp[cnt] << endl;
            }
        }
    }
    
    return 0;
}
```

# 后言

就离谱，绿题也这么难...

---

## 作者：Otomachi_Una_ (赞：16)

这里只介绍 $100\%$ 的解决方案。

介绍一种比较好想的方法。

本题就是求最小的 $x$ 使得 $f(x)>n$，最后输出 $x-1$。

实际上，我们观察一下所有有可能作为答案的 $x$ 必然其 $f$ 值比前数都要大。经过观察，可以发现 $x$ 前面几个是：

- 一位数：$0,1,2,3,4,5,6,7,8,9$.
- 二位数：$11,12,13,14,15,16,17,18,19,29,39,49,59,69,79,89,99$.
- 三位数：$101,102\dots 109,119\dots 199,299\dots 999$.

所以很容易就能找到规律，并且发现这样特殊的 $x$ 并不多，最多只有 $9(\lg w)^2$ 个（$w$ 为值域），结合 $f(x)$ 对特殊的 $x$ 的单调性二分即可。

时间复杂度：$O(T\log(\lg^2 w))$。完结撒花。

---

## 作者：0xFF (赞：7)

#### 题目大意


------------
定义 $f(x)$ 为 $x$ 各位翻转后形成的数码。

求出最大的 $k$ 使得在 $[1,k]$ 之间的正整数 $m$ 都有 $f(m) < n$。

#### 思路分析


------------
一道有意思的猜结论的题。

找一个最大的满足条件的数等价于找一个最小的不满足条件的数减一。

所以求一个最大的满足条件的 $k$ 等价于求一个翻转后最小的大于 $n$ 的数减一。

首先考虑一种特殊情况，如果一个数除第一位以外全部为 $0$，那么答案即为原数。因为这个数一定是和他有相同位数的数中最小的，所以所有位数和他相同的数翻转后一定大于它，同时，这个数也比所有比他位数小的数大，所以所有位数比它小的数翻转后一定小于它，综上所述答案就是原数。

对于其他的正整数我们考虑使用同样的方式进行分析。

考虑一般的情况，在保证大于 $n$ 的前提下使得这个数尽量的小，就要让在 $m$ 尽量靠前的位数大于 $n$ 与其相对应的位数，找到这样的一位之后，翻转后的 $m$ 就必定大于 $n$ 了，因为这样翻转后的这一位就会尽可能的靠后，这样就同时保证了要求的两个条件，需要注意的是，如果这一位数是 $9$，加一的话需要进位，这样 $m$ 的位数就会大于 $n$，这样求出的数一定不是最优的，所以要找到一位数非 $9$，将这个数加一，并且将这个数之后除了最后一位的数置为 $0$，最后一位为 $1$，这样就保证了 $m$ 翻转后是最小的大于 $n$ 的数。

综上所述，整个算法流程如下，如果一个数是十的倍数，那么将 $n$ 减一。设翻转后最小的大于 $n$ 的数为 $m$，从 $n$ 的第一位数开始遍历，如果这一位数是 $9$，那么 $m$ 对应的这一位也为 $9$，否则将 $m$ 这一位设为 $n$ 这一位的值加一，同时将从此位置到倒数第二个位置上所有的数设为 $0$，最后一位为 $1$，将 $m$ 翻转后减一输出即为最终答案。

时间复杂度：$\Theta(T\lg n)$。

---

## 作者：Error_Yuan (赞：6)

容易看出，我们只需要求出最小的 $m$，使得 $f(m)>n$，然后输出 $m-1$ 即可。  
这里提供一个 $O(T\log W)$（$W$ 是值域）的做法：  
设 $x$ 是正整数，则 $x$ 的位数一定 **大于等于** $f(x)$ 的位数，因此，在一般情况下，为了使 $m$ 最小，那么其一定是 $\overline{100\cdots0q}$ 的形式，并且 $m$ 与 $n$ 的位数相同。  
在这种情况下，$f(m)=\overline{q0\cdots001}$，设 $n$ 的首位是 $p$，分类讨论一下（要满足 $f(m)>n$）：  
+ 如果 $n$ 除了首位全都是 $0$，那么 $q=p$，例如：当 $n=2000$ 时，$q=p=2$，$m=1002$；
+ 其它情况下，$q=p+1$，例如：当 $n=81079$ 时，$q=p+1=9$，$m=10009$。  

但是，我们发现，当 $p=9$ 时，$q=10$，会产生进位，这显然不是最优解，怎么解决呢？其实很简单，为了使最终得到的 $m$ 的位数尽可能小，不妨将 $n$ 前面的 $9$ 全部去掉，的到新的数 $n'$，这样 $n'$ 的第一位一定不是 $9$，用前面提到的方法得到 $m'$，再在 $m'$ 的尾部接上原来删去的 $9$，得到最终的 $m$。  
举个例子：当 $n=99927$ 时，去掉前面的 $3$ 个 $9$，得到 $n'=27$，算出 $m'=18$，在 $m'$ 的尾部把删掉的 $3$ 个 $9$ 接上去，就得到 $m=18999$。  
还有一个问题：如果 $n$ 全部由 $9$ 构成呢？即 $n=\overline{999\cdots9}$，~~（分类讨论好烦）~~，这时候进位是不可避免的了，由于 $f(\overline{1000\cdots0})$ 一定等于 $1$，则 $m=n+2$。（**最终答案不要忘记减 $1$**）  
最后，不要忘记特判 $n < 9$ 的情况，此时 $m=n+1$。（但是当 $n=9$ 时，$m=11$！！）  
AC 代码如下：（$\mathrm{39ms}$，目前是最优解 $\mathrm{rk1}$）  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;

int t, n, a[20], tot;
void read() {
	memset(a, 0, sizeof(a));
	tot = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') {
		a[++tot] = ch - '0';
		ch = getchar();
	}
}
void work() {
	if (tot == 1 && a[1] == 9) {
		printf("10");
		return;
	}
	if (tot == 1) {
		putchar(a[1] + '0');
		return;
	}
	int cur = 1;
	while (a[cur] == 9) cur++;
	if (cur > tot) {
		putchar('1');
		for (int i = 1; i <= tot; i++) putchar('0');
		return;
	}
	if (cur == tot) {
		a[tot] += 1;
		reverse(a + 1, a + tot + 1);
		a[tot] -= 1;
		for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
		return;
	}
	int tmp = cur + 1;
	while (a[tmp] == 0 && tmp <= tot) tmp++;
	if (tmp > tot) {
		a[tot] = 1;
		reverse(a + 1, a + tot + 1);
		a[tot] -= 1;
		for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
		return;
	}
	a[cur] += 1;
	for (int i = cur + 1; i < tot; i++) a[i] = 0;
	a[tot] = 1;
	reverse(a + 1, a + tot + 1);
	a[tot] -= 1;
	for (int i = 1; i <= tot; i++) putchar(a[i] + '0');
	return;
}
int mian() {
	scanf("%d", &t);
	while (t--) {
		read();
		work();
		putchar('\n');
	}
}
// O(n lg W)
```

---

## 作者：qzhwlzy (赞：3)

## 题目大意
定义 $f(x)$ 值为将整数 $x$ 所有数码翻转得到的数，如 $f(123456)=654321,f(1200)=21$。给定 $n$，求出最大的 $k$ 使得 $\forall x\in[1,k]$，都有 $f(x)\le n$。

## 思路

手玩了一下样例，我们发现，对于位数小于 $n$ 的数 $x$，$f(x)$ 一定不会大于 $n$（毕竟位数小于 $n$），那么，我们直接从 $x=100\dots01$（位数恰好等于 $n$）开始看起。

此时，我直接在脑子里想象将 $x$ 翻转过后得到的数逐渐 $+1$（后面说的 $x$ 全部是翻转过的），什么时候会超过 $n$  呢？我们可以发现，首位（原数的个位）增加的速度一定是大于第二位（原数的十位），而第二位增加的速度又大于第三位（原数的百位）（这是显然的），那么，假设 $n$ 的第一位不是 $9$ 时，一旦 $x$ 的第一位超过 $9$ 就会大于 $n$，而 $n$ 的第一位是 $9$ 时，$x$ 不可能在第一位超过 $n$，我们找到 $n$ 从前往后第一个不是 $9$ 的位，当 $x$ 的这一位超过 $n$ 这一位的数时就会大于它。故答案就是：**找到 $n$ 第一位不是 $9$ 的位，将其加一并翻转**（此时是第一个比 $n$ 大的数）**，首位赋值为 $1$（首个不是 $9$ 的位不是首位的情况下）**（确保位数）**，末位减一**（询问的是 $f$ 值小于等于 $n$ 的上界）**即可**。此时还有一些问题：

首先，对于全部是 $9$ 的数，例如 $9999$ 这一类，可以直接特判掉，答案应该是 $n+1$（以 $9999$ 为例，因为 $10000$ 翻转后有前导 $0$，故从 $10001$ 开始才不符合条件）；

其次，对于 $998000$ 这类 第一个不是 $9$ 的位之后 全部是 $0$ 的数，按照我们之前的结论会得到 $100998$ 的答案，这是因为对于其他情况，只要后面有一位不是 $0$，那么翻转过后我们得到的答案都不会大于 $n$，而若后面全是 $0$ 的话，我们确保位数的那个 $1$ 就会让这个数大于 $n$ 了，故此时第一位不是 $9$ 的位在答案里就不需要加一了。例如在 $n = 998000$ 时，我们原来的结论会得到 $k = 100998$ 的答案，但是此时当 $x=100899\in[1,k]$ 时，$f(x) = f(100899) = 998001 > n$，我们占位的 $1$ 使得答案不对了，故我们要将答案改成 $100898$（毕竟占位的 $1$ 不能去掉）；

最后，一定要初始化。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 25
using namespace std;
int T,n; char a[maxn]; int ans[maxn];
int main(){
	scanf("%d",&T);
	while(T--){
		bool flag=0;
		cin>>a+1; n=strlen(a+1);
		for(int i=1;i<=n&&!flag;i++){
			if(a[i]!='9'){
				ans[i]=a[i]-'0'+1; for(int j=i+1;j<=n;j++){if(a[j]!='0') break; if(j==n) ans[i]--;}
				if(i!=n) ans[n]=1; break;
			} else ans[i]=9;
			if(i==n){ printf("1"); for(int i=1;i<=n;i++){printf("0");ans[i]=0;} flag=1; printf("\n");}
		}
		if(!flag){ans[1]--; for(int i=n;i>=1;i--){printf("%d",ans[i]);ans[i]=0;} printf("\n");}
	}
	return 0;
} 
```


---

## 作者：Register_int (赞：3)

直接找最大的 $k$ 不好找，我们考虑构造最小的反例，将其 $-1$ 即为所求。明显的一点是，当 $n=10^p-1$ 时，$k$ 一定为 $n+1$。具体证明不再赘述。  
排除这种情况，根据 $f$ 函数的特点，我们来探究最小反例的性质。不妨记他为 $t$，则 $t$ 一定满足以下几个条件：
- $t$ 反转后大于 $n$。
- $t-1$ 反转后小于 $n$。
- $t$ 和 $n$ 位数相同。

那么，就有这样一种求近似解的方法。
- 先确定 $t$ 的位数，将 $t$ 的最高位设为 $1$。
- 倒序循环 $n$ 的每一位。如果 $n_i=9$，那么将 $t_{p-i+1}$ 设为 $9$。否则，将 $t_{p-i+1}$ 设为 $n_i+1$。这样即可求出一个解 $t$，该解保证，在高位最小的情况下，低位尽量小。

在这种情况下，只有一种数是反例：个位为 $0$ 且十位不为 $0$ 或 $9$。当出现这种情况时，$f(t-1)$ 会大于 $n$。之所以会出现这种情况，是因为我们一开始就固定了 $t$ 的最高位。在这种情况下，$f(n+1)$ 则为最小反例。直接输出即可。
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline 
ll rev(ll n) {
	ll res = 0;
	while (n) res = res * 10 + n % 10, n /= 10;
	return res;
}

int t;

ll n, m, ans;

int a[20], b[20], p;

bool f;

int main() {
	scanf("%d", &t);
	while (t--) {
		memset(b, 0, sizeof b);
		f = 1, ans = p = 0;
		scanf("%lld", &n), m = n;
		while (n) a[++p] = n % 10, n /= 10;
		b[p] = 1;
		for (int i = p; i; i--) {
			if (a[i] == 9) b[p - i + 1] = 9;
			else { f = 0, b[p - i + 1] = a[i] + 1; break;}
		}
		if (f) { printf("%lld\n", m + 1); continue; }
		for (int i = p; i; i--) ans = ans * 10 + b[i];
		if (a[1] != 9) ans = min(ans, rev(m + 1));
		printf("%lld\n", ans - 1);
	}
}
```

---

## 作者：HopeAndLizz (赞：2)

# 题意：

定义 $f(x)$ 是 $x$ 的各位数码翻转以后形成的数。

给定一个 $n$。求最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$。

# 解法分析：

## 性质 $1$

>容易知道，对于给定的 $n$，$k$ 的位数一定不小于 $n$ 的位数。

这是我第一眼看出的性质。也就是说，如果 $n=666$，那么我们可以从 $100$ 开始枚举判断，直到找到所求的 $k$（然而本题很明显过不了）。

## 性质 $2$

>对于给定的 $n$，若 $k$ 的位数大于 $n$ 的位数，当且仅当 $n$ 各位全为 $9$，且此时 $k=n+1$。

意思是如果 $n=9$，那么 $k=10$；若 $n=99$, $k=100$…

为什么呢？

假设 $n$ 为三位数（其它位数同理），要想 $k$ 达到四位数，那么一定有 $f(999)\le n$，故 $n$ 必为 $999$，而 $f(1001)$ 一定大于三位数，故得证。

（我们已经知晓了 $k$ 的位数大于 $n$ 的位数的情况，现在只需考虑 $k$ 的位数等于 $n$ 的位数的情况。）

## 性质 $3$

>对于给定的 $n$，若 $n$ 只有一位数，那么 $k=n$。

这里已经排除了性质2的情况，所以这个结论显然。

接下来就是重头戏，探究如何解决更广泛的情况。


## 性质 $4$

>对于给定的有 $l$ 位数的 $n$，若 $n$ 第一位不为 $9$，那么 $k=\begin{matrix}l-2\\1\,\overbrace{0\,0\,\cdots 0\,0}\,x\end{matrix}$,其中 $x$ 为 $n$ 的第一位或其减 $1$。

这个性质分为了两种情况：

- 如果 $n=110004$，那么 $k=100001$；若 $n=21$，那么 $k=12$。

- 如果 $n=10$，那么 $k=10$；若 $n=8000$，那么 $k=1007$。

正确性？

以四位数举例子，若 $n$ 第一位不为 $9$,那么 $k$ 一定越不过 $1009$。因为 $f(1009)$ 达到了 $9001$，所以由性质1，我们的选择余地很少，只有 $1000$ 到 $1008$。

所以，如果 $n$ 不是整十整百整千等数字，那么 $k=\begin{matrix}l-2\\1\,\overbrace{0\,0\,\cdots 0\,0}\,x\end{matrix}$，$x$ 为 $n$ 的第一位。

如果 $n$ 是整十整百整千等数字，那么 $k=\begin{matrix}l-2\\1\,\overbrace{0\,0\,\cdots 0\,0}\,x\end{matrix}$，$x$ 为 $n$ 的第一位减 $1$。


## 性质 $5$

终于到了最后一个性质，马上就可以撒花了(～￣▽￣)～ 

这个用文字表示会有点抽象我们举一些例子说明。

首先对于第一位为 $9$ 的 $n$,那么 $k$ 的末尾一定为 $8$,以保证前面尽可能大。

其他位置如图。

![8431](https://cdn.luogu.com.cn/upload/image_hosting/d0ud9ezt.png)

正确性：若绿框全是 $0$，那么它必会跨过 $10..0?9..99$，这翻转后会比 $n$ 大；若绿框不全是 $0$，不仅没有上述问题，反而可以更进一步使得 $k$ 更大。


顺便举几个例子：

**输入**

```
4
999900
999910
999321
90
```

**输出**

```
109998
119998
104998
18
```


# Code

（蒟蒻代码写得很乱，轻喷）

```cpp
#include<iostream>
#include <cstdio>
#include <cstring>
#include <stack> 
using namespace std;
const int INF=0x3f3f3f3f;
#define ull unsigned long long
int t;
stack<char>st;
char s[10005];
int main()
{
 	//freopen("in.txt","r",stdin);
 	scanf("%d",&t);
 	while(t--)
 	{
 		scanf("%s",s+1);
 		int len=strlen(s+1);
 		int i; 
		for(i=1;i<=len;i++)
		{
			if(s[i]!='9')
				break;
		}
		if(i==len+1)
		{
			cout<<"1";
 			for(int i=1;i<=len;i++)
 				cout<<"0";
 			cout<<endl;
 			continue;
		}
		//性质2先做
		
		if(len==1)
 		{
 			cout<<s[1]<<endl;
 			continue;
 		}
		//性质3
		
		if(s[1]!='9') 
		{
			cout<<"1";
 			bool ff=1;
 			for(int i=2;i<len;i++)
 			{
 				cout<<"0";
 				if(s[i]!='0') ff=0;
 			}
 			if(s[len]!='0') ff=0;//判断是否为整十整百整千之类的 
 			if(ff==0)cout<<s[1]<<endl;
 			else cout<<(char)(s[1]-1)<<endl;
 			continue;
		} 
		//性质4 
		 
		st.push('8');
 		int pos;
 		for(pos=2;pos<=len;pos++)
 		{
 			if(s[pos]=='9') st.push('9');
 			else break;
 		}//寻找第一个不为9的位置
		bool fff=1;
 		for(int j=pos+1;j<len;j++)
 		{
 			if(s[j]!='0')
			 {
			 	fff=0;
			 	break;
			 } 
		} 
		if(pos==len || s[len]!='0') fff=0;
 		if(fff==0)st.push((char)(s[pos]+1));
 		else st.push(s[pos]);
 		for(pos=pos+1;pos<len;pos++)
 			st.push('0');
 		if(pos==len)st.push('1');
		while(!st.empty())
		{
			cout<<st.top();
			st.pop();
		}
		cout<<endl;
		  
 	}
}
```


---

## 作者：baiABC (赞：2)

可以对值域二分找到最大的满足条件的 $k$。

所以现在只要解决这样一个问题：求 $\max\limits_{i=1}^{m}f(i)$。

可以贪心地解决这个问题。要么取 $\texttt{a999...9}$ 反转后的数，要么最高位和原数一样，再递归解决后面的数位。

``unsigned long long`` 的最大值大于 $10^{19}$，所以不用高精。

时间复杂度： $O(T\log^2 n)$

略微卡常，要加记忆化。

具体见代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull n, po[20]; // 10 的幂
ull f(ull x, int cnt) // cnt 表示位数，考虑前导零
{
   if(cnt == 0) return 0;
   if(cnt == 1) return x;
   ull ans = f(x%po[cnt-1],cnt-1)*10+x/po[cnt-1];
   if(x/po[cnt-1]) ans = max(ans, x/po[cnt-1]-1+(po[cnt-1]-1)*10);
   return ans;
}
unordered_map <ull, ull> m; // 记忆化
bool chk(ull x)
{
   if(m.count(x)) return m[x] <= n;
   int cnt = 0;
   for(ull i = x; i; i /= 10) ++cnt;
   ull ans = f(x%po[cnt-1],cnt-1)*10+x/po[cnt-1];
   if(x/po[cnt-1] > 1) ans = max(ans, x/po[cnt-1]-1+(po[cnt-1]-1)*10);
   else ans = max(ans, po[cnt-1]-1);
   return (m[x]=ans) <= n;
}
int main()
{
   int T; ios::sync_with_stdio(0);
   cin >> T;
   po[0] = 1;
   for(int i = 1; i <= 19; ++i) po[i] = po[i-1]*10;
   while(T--)
   {
      cin >> n;
      ull l = 1, r;
      for(int i = 1; i <= 19; ++i)
         if(po[i] > n)
         {
            r = po[i];
            break;
         }
      while(l < r)
      {
         ull mid = r-((r-l)>>1);
         if(chk(mid)) l = mid;
         else r = mid-1;
      }
      cout << l << '\n';
   }
   return 0;
}
```

---

## 作者：TensorFlow_js (赞：2)

找规律题。

### 1.题目分析

考虑使 $f(m)>n$ 的第一个 $m$，下称这个数为 $M_n$。

可以发现，在 $n$ 的前面 $k$ 位都为 $9$ 的情况下，$M_n$ 的后 $k$ 位也要为 $9$，其余情况设为 $0$ 即可，$n$ 第一个非 $9$ 的那位对应到 $M_n$ 上则为 $f(M_n)$ 对应位减一，若 $n=99\cdots9$ 则要特判，$M_n=n+2$，$n$ 的最后一位为 $0$ 时也要特判，$M_n=M_{n-1}$，若 $M_n$ 的第一位被设为了 $0$ 则要改成 $1$。

答案即为 $M_n-1$。

顺便安利一下 `to_string` 函数与 `sto[i/l/ll/ui/ul/ull]` 系列函数，它们是字符串转数字与数字转字符串函数。

### 2.代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
string getans(int n) {
    string s = to_string(n);
    bool tf = s.size() > 1 && (s[s.size() - 1] == '0');
    if (tf) s = to_string(n - 1);
    string ans = "";
    bool flag = 1;
    for (int i = 0; i < s.size(); i++) {
        if (flag && i == s.size() - 1 && s[i] == '9')
            ans = string(s.size() + 1, '0'), ans[s.size()] = ans[0] = '1';
        else if (flag && s[i] == '9')
            ans += "9";
        else if (flag)
            flag = 0, ans += s[i] + 1;
        else if (i == s.size() - 1)
            ans += "1";
        else
            ans += "0";
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
signed main() {
    int t, n;
    cin >> t;
    while (t--) {
        cin >> n;
        cout << stoull(getans(n)) - 1 << endl;
    }
}
```

---

## 作者：rzh123 (赞：1)

# P8431 题解  

题目链接：[P8431 「WHOI-2」彗星蜜月](https://www.luogu.com.cn/problem/P8431)。 

奇怪的做法，$\mathcal{O}(T \log n)$。  

首先，通过观察样例可以知道，答案和 $n$ 中开头连续 $9$ 的个数、结尾连续 $0$ 的个数有关，对于每一个 $n$，先预处理出这两个信息，记为 $c_9$ 和 $c_0$，设数字长度为 $l$。  

然后分类讨论。

## $l=1$  

只有一位，翻转还是自己，所以 $0\le n \le 8$ 时，小于等于 $n$ 最大的数就是 $n$，直接输出。  

$9$ 是特殊情况，$9+1=10$ 不再是 $1$ 位数，它翻转后是 $1\le9$，而 $11$ 翻转后是 $11\gt 9$，所以 $n=9$ 时 $m=10$。  

## $l\ge 2,c_9=l$  

所有位都是 $9$，$n$ 就是 $l$ 位数中最大的，所以对于任意 $l$ 位数 $x$，$f(x)$ 一定不超过 $n$，考虑 $(l+1)$ 位数，最小的是 $10^l$，它翻转后是 $1$，一定也小于 $n$；而 $10^l+1$ 翻转后仍然是 $10^l+1$，一定大于 $n$，所以答案是 $10^l$，也就是 $1$ 后加 $l$ 个 $0$。  

## $l\ge 2,c_9=0,c_0=l-1$  

也就是 $n=k\times 10^l(k\neq 9)$ 的情况。  

**确定最高位。** 如果 $m$ 的最高位 $\gt 1$，那 $[1,m]$ 中一定存在 $19\cdots9$ 这种数字，翻转后吊打 $n$，所以 $m$ 最高位一定是 $1$。  

**确定中间位。** 如果 $2\sim (l-1)$ 位不是 $0$，也一定存在一个 $1\cdots9$ 这种情况（中间可以是任意数字），翻转也大于 $n$，所以这些位一定是 $0$。  

**确定最低位。** 如果 $m$ 最后一位大于 $n$ 的最高位，翻转后肯定大；如果等于，前面都一样，最后一位 $1\gt 0$，也不行，所以 $m$ 的最后一位是 $n$ 的最高位 $-1$。  

## $l\ge 2,c_9=0,c_0\lt l-1$  

最高位和中间位与上一种情况相同，主要说最低位。  

最低位如果大于 $n$ 最高位，毫无疑问也不行；如果等于，因为 $n\gt k\times 10^l(k\neq 9)$，所以等于也可以，所以 $m$ 的最后一位就是 $n$ 的最高位。  

## $l\ge 2,c_9=l-1$  

**最高位。** 最高位如果是 $n$ 的最低位，就算后面全是 $9$ 也只和 $n$ 相等，还可以更大；再加 $1$，只要后面处理一下也可以小；如果加 $2$，就又有了后面都是 $9$ 的情况，翻转后大于 $n$，不行。所以最高位是 $n$ 最低位 $+1$。  

**中间位。** $n$ 前面都是 $9$，$m$ 中间全是 $9$ 也超不过，$f(m)$ 和 $n$ 的大小关系是由最后一位决定的，所以中间全填 $9$。  

**最低位。** 最低位如果还是 $9$，$f(m)\gt n$，所以最低位应该是 $8$。  

## $l\ge 2,c_9\lt l-1$  

**最高位。** 最高位如果大于 $1$，还是有 $199\cdots 9$ 这种数字，翻转后大于 $n$，所以最高位是 $1$。  

**$2\sim (l-c_9-1)$。** 这些位上只要不是 $0$,就可以给它 $-1$ 然后把后面都变成 $9$,翻转后就又比 $n$ 大了。所以这些都是 $0$。  

**第 $(l-c_9)$ 位。** 这一位对应 $n$ 的第 $(c_9+1)$ 位，类似于上一种情况的中间位，如果除了 $9$ 和 $9$ 后这一位外都是 $0$，即 $c_9+c_0+1\ge l$，$m$ 的第 $(l-c_9)$ 位就应该是 $n$ 的连续 $9$ 后出现的数字，否则就要加 $1$。  

**第 $(l-c_9+1)\sim (l-1)$ 位。** 也类似于上一种情况，全填 $9$ 后大小由最后一位决定，所以全填 $9$。  

**最低位。** 也类似于上一种，需要填 $8$。  

## 代码  

```cpp
#include <bits/stdc++.h>
#define gc getchar()
#define pc(c) putchar(c)
using namespace std;
char s[29];
int len;
inline int read(){
	register int t=0,f=1;
	register char c=gc;
	while(c!='-'&&(c<'0'||c>'9')) c=gc;
	if(c=='-') c=gc,f=-1;
	while(c>='0'&&c<='9') t=10*t+(c^48),c=gc;
	return f*t;
}
signed main(){
	int t=read();
	while(t--){
		int c9=0,c0=0;
		scanf("%s",s+1);
		len=strlen(s+1);
		if(len==1){
			if(s[1]=='9'){
				puts("10");
			}
			else{
				puts(s+1);
			}
			continue;
		}
		for(int i=1;i<=len;++i){
			if(s[i]!='9'){
				break;
			}
			++c9;
		}
		for(int i=len;i>=1;--i){
			if(s[i]!='0'){
				break;
			}
			++c0;
		}
		if(c9==len){
			pc('1');
			for(int i=1;i<=len;++i) pc('0');
			puts("");
		}
		else if(c9==0){
			pc('1');
			for(int i=2;i<len;++i){
				pc('0');
			}
			if(c0==len-1) pc(s[1]-1);
			else pc(s[1]);
			puts("");
		}
		else if(c9==len-1){
			pc(s[len]+1);
			for(int i=2;i<len;++i) pc('9');
			pc('8');
			puts("");
		}
		else{
			pc('1');
			for(int i=2;i<=len-c9-1;++i) pc('0');
			if(c0+c9+1>=len) pc(s[c9+1]);
			else pc(s[c9+1]+1);
			for(int i=len-c9+1;i<len;++i) pc('9');
			pc('8');
			puts("");
		}
	}
	return 0;
}
```

---


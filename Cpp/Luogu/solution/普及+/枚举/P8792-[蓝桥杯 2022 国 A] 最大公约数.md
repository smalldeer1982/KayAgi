# [蓝桥杯 2022 国 A] 最大公约数

## 题目描述

给定一个数组，每次操作可以选择数组中任意两个相邻的元素 $x, y$ 并将其中的一个元素替换为 $\gcd(x, y)$，其中 $\gcd(x, y)$ 表示 $x$ 和 $y$ 的最大公约数。请问最少需要多少次操作才能让整个数组只含 $1$。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $30\%$ 的评测用例，$n \leq 500$，$a_i \leq 1000$；
- 对于 $50\%$ 的评测用例，$n \leq 5000$，$a_i \leq 10^6$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

蓝桥杯 2022 国赛 A 组 D 题。

## 样例 #1

### 输入

```
3
4 6 9```

### 输出

```
4```

# 题解

## 作者：gesong (赞：23)

题目传送门：[P8792 [蓝桥杯 2022 国 A] 最大公约数](https://www.luogu.com.cn/problem/P8792)。
# 思路
其实，这道题就是枚举，只需要枚举从哪个端点开始，如果合成了 $1$，就更新最大值，具体看代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1234567],cnt;
main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i],cnt+=(a[i]==1?1:0);
	if (cnt){//特判，如果有1了，就不用枚举了。
		cout <<n-cnt;
		return 0;
	}
	int ans=1e9;
	for (int i=1;i<n;i++){//枚举开始端点
		int x=a[i],sum=0;
		for (int j=i+1;j<=n;j++){
			sum++;
			x=__gcd(x,a[j]);
			if (x==1){//成功了
				ans=min(ans,sum);
				break;
			}
		}
	}
	if (ans==1e9) cout <<-1;//不合法
	else cout <<n+ans-1;
    return 0;
}
```
结果TLE了，我们要想想优化。
# 优化
我们发现，在枚举的时候，一直用 $O(n^2)$ 的算法，如果线段树，就能减少时间，代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define lc 2*k
#define rc 2*k+1
using namespace std;
int n,a[1234567],cnt;
struct nord{
	int l,r,mx;
}t[1234567];
void build(int k,int l,int r){//建树
	t[k].l=l,t[k].r=r;
	if (l==r){
		t[k].mx=a[l];
		return ;
	}
	int mid=(l+r)/2;
	build(lc,l,mid);
	build(rc,mid+1,r);
	t[k].mx=__gcd(t[lc].mx,t[rc].mx);
}
int ask(int k,int l,int r){//求区间gcd
	if (l<=t[k].l&&r>=t[k].r) return t[k].mx;
	int ans=0;
	int mid=(t[k].l+t[k].r)/2;
	if (l<=mid) ans=__gcd(ans,ask(lc,l,r));
	if (r>mid) ans=__gcd(ans,ask(rc,l,r));
	return ans;
}
main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i],cnt+=(a[i]==1?1:0);
	build(1,1,n);
	if (cnt){//特殊情况
		cout <<n-cnt;
		return 0;
	}
	int ans=1e9;
	int i=1;
	for (int j=1;j<=n;j++){//枚举
		while (i<j&&ask(1,i+1,j)==1) i++;//一直往前走
		if (ask(1,i,j)==1) ans=min(ans,j-i);//成功了
	}
	if (ans==1e9) cout <<-1;//不合法
	else cout <<n+ans-1;
    return 0;
}
```

---

## 作者：Watanabe (赞：11)

# 这里给出一个**不一样**的做法
#### (时间复杂度玄学，希望大佬帮忙分析一下 QAQ )
题外话(模拟赛上的题，但是脑子抽了没写出正解，就写了一个~~优雅的~~暴力，跑到了最优解 page 1 )

顺带一提(因为模拟赛上采用思路一的暴力**过不去**，~~但 lg 可以过，什么鬼数据，~~，所以跟大家分享一下思路二这种做法)

[传送门](https://www.luogu.com.cn/problem/P8792)

[双倍经验(思路一的代码不加优化可以过，水蓝)](https://www.luogu.com.cn/problem/CF891A)

### 题意分析
   这道题的操作其实就是求两个数的 $\gcd$  并替换其中一个数。我们知道如果要使整个数列全部变为 $1$ 的话，那么我们在进行若干次(小于 $n$ 次)操作后，必定会出现 $1$。那么我们用这个1去和其它不是 $1$ 的数求 $\gcd$，就能将整个序列变成 $1$

### 思路(还有一种带log的做法其它大佬讲了我就不讲了)
#### 一  考虑暴力(其实只要在原暴力上加个优化就过了)
  我们知道$\gcd(a,b,c)=\gcd(\gcd(a,b),\gcd(b,c))$，它满足结合律
  
  [证明](https://blog.csdn.net/weixin_43331420/article/details/120391635)
  
  那么我们对于每一个 $a[i]$，先用它和 $a[i+1]$ 取 $\gcd$ (记为 $x$)，再用 $x$ 与 $a[i+2]$ 求 $\gcd$ (记为 $x$ )，以此类推，一直到 $a[k]$ ，那么此时的 $x$ 就是 $\gcd(a[i],a[i+1],......,a[k])$,而我们假设取到 $a[k]$ 时 $x$ 为 $1$，那么相当于我们进行了 $k-i$ 次操作后得到了 1
  
  以上面的思路，我们枚举 $i$，$ans=n-1$(还有 $n-1$ 个不为 $1$)+ $\min(k-i)$，时间复杂度为 $O(n^{2})$
  
  当然，我们要特判，如果原序列中有了 $res$ 个 $1$，那么 $ans=n-res$(将不是 $1$ 的 $n-res$ 个原序列中的数和它相邻的 $1$ 进行操作)
  
  期望得分 $100$ (不加优化 $80$)(而且为哈其它题解都没有这种写法啊啊啊)
  
  代码
  ```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+100;
int n,a[N],res;
main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i],res+=(a[i]==1?1:0);
	if (res){
		cout<<n-res;
		return 0;
	}
	int step=1e9;
	for (int i=1;i<n;i++)
	{
		int x=a[i];
		for (int j=i+1;j<=n;j++)
		{
			x=__gcd(x,a[j]);//求gcd的自带函数 
                  if(j-i>step) break;//优化
			if(x==1)
			{
				step=j-i;
				break;
			}
         
		}
	}
	if (step==1e9) cout<<-1;
	else cout<<n-1+step;
    return 0;
}
```
#### 二 还是考虑暴力

我们考虑对思路一进行优化

我们可以发现，思路一中造成超时的主要原因是因为我们没法保证每次得出的 $step$ 是最优解，因此我们要跑满 $n^2$ 次(其实不算跑满，因为有个优化)

但是如果我们能保证第一次得出的答案即为最优，那么~~嘿嘿嘿~~(这里说一下，其实多数题目可以这样思考，因为出题人是知道朴素暴力怎么卡的，所以他肯定会卡，而我们只要绕开这点，就可以让出题人的**卡暴力成为我们 $AC$ 的依据**)

好了好了，进入正题

我们先借用一篇巨佬的 $blog$ 介绍一下 $\gcd$ 的求法

[here](https://blog.csdn.net/qq_40692109/article/details/105005120)

我建议大家使用第四种，因为可以处理 $a$, $b$ 为 $0$ 的情况并且速度较快(当然用 $c++$ 自带的 $\gcd$ 函数也可以 $AC$ 本题)

紧接着我们回忆一下思路一，其中的 $\gcd$ 的结合律也许可以给我们一点启发。我们知道，若有 $n$ 个数，那么我们取其中至少包含 $2$ 个数的**连续区间**求**这个区间所有数的 $\gcd$**，

一共可以得出 $\frac{n\times(n-1)}{2}$ 个结果(长度为 $2$ 的有 $n-1$ 个，为 $3$ 的有 $n-2$ 个，以此类推)

那我们要求的不就是一个连续区间使一个区间所有数的 $\gcd$ 为 $1$ 的最小长度吗

那我们只要从区间长度入手，每次枚举出长度为 $2,3$,......,$n$ 的连续区间，再来统计它们的 $\gcd$ 是否为 $1$，就可以保证我们第一次找出的答案即为最优

对一些可能的疑惑的解答(为什么只找一个)：当然，我们只需要一个连续区间的 $\gcd$ 为 $1$ 就好了，因为我们只需要一个 $1$ 就能使其它数都变成 $1$ (如果找两个区间的话那么操作次数会 $-1$ 再 $+$ 区间长度，$-1$ 是因为多变了一个 $1$，$+$ 区间长度是因为要额外进行这么多次操作)

我们接着思考，长度为 $3$ 的连续区间的 $\gcd$ 可以由两个长度为 $2$ 的连续区间的 $\gcd$ 得到，以此类推，下面给出一张图便于理解


![](https://cdn.luogu.com.cn/upload/image_hosting/n9dz8jol.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

上图以 $n=6$ 举例，$a$ 为原序列，$b$ 为相邻两个 $a$ 数组中的数的 $\gcd$，$c$ 为相邻两个 $b$ 数组中的数的 $\gcd$ (即 $a$ 中相邻三个数的 $\gcd$ )，以此类推，最后我们迭代的**层数**即为操作几次后可以得出一个 $1$。

具体实现：我们新建一个 $b$ 数组，初始有 $tot=n$ 个数，每一次迭代使 $b[i]=\gcd(b[i],b[i+1])$,检查此时  $b[i]$ 是否为 $1$，若为 $1$ 就 $break$，输出 $n-1+$ 迭代次数 即为答案(不难看出，$tot$ 每次会减 $1$，若 $tot=0$ 则说明没有解)

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<ctime>
//#define int long long
#define re register
using namespace std;
const int N=1e5+110;
int n,a[N],num,res;
bool f;
int b[N],tot,k;
inline int read()
{
	int ress=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) ress=(ress<<3)+(ress<<1)+c-'0',c=getchar();
	return ress;
}
inline int gcd_(int x2,int y2)
{
	int x=max(x2,y2),y=min(x2,y2);
	if(y) while((x%=y)&&(y%=x)) ;
	return x+y;
}
signed main()
{
	n=read();
	for(re int i=1;i<=n;++i) 
	{
		b[i]=a[i]=read();
		if(a[i]==1) ++num;
	}
	if(num) {printf("%d",n-num);return 0;}//特判，前面思路一讲过
	tot=n;
	if(n==1) return printf("-1"),0;
	int gg=gcd_(a[1],a[2]);
	for(re int i=3;i<=n;++i)gg=gcd_(gg,a[i]);
  //这个特判可以加可以不加，因为模拟赛的时候后面几个大的数据点是-1，如果最后判断的话可以卡成n^2的
	if(gg>1) return printf("-1"),0;
	while(!f&&k<n)
	{
		++k;//迭代层数
		--tot;//当前b数组中数的个数
		for(re int i=1;i<=tot;++i)
		{
			b[i]=gcd_(b[i],b[i+1]);
			if(b[i]==1)
			{
				f=1;
				break ;
			}
		}
		if(f) break ;
	}
	if(!f) printf("-1");
	else printf("%d",n-1+k);
	return 0;
}
```

至此，本题解决，在 $O2$ 的加持下可以只跑 $104ms$

最后，我再来说一个小优化思路(可以在迭代 $b$ 数组时判断，若 $b[l]$ 到 $b[r]$ 之间全部相等，$r-l+1>=2$，那么我们可以只保留 $b[l]$ 和 $b[r]$，因为两个相同的数的 $\gcd$ 永远是它们本身，可以通过链表实现)那么为什么加这个优化呢，因为这种做法被卡的话，通过此优化可以完美避免被卡掉(自行思考为什么呢)，有兴趣的同学可以自己去试试


  


---

## 作者：Register_int (赞：10)

首先要使整个数列为 $1$，必须要先有一个位置的值为 $1$，再逐步拓展。问题就转化为拼出一个 $1$ 的最少步数。又由于题目要求只能用相邻两数来进行 $\gcd$，所以要拼出 $1$ 个 $1$ 必须是一个区间内的数进行 $\gcd$。维护一个区间 $\gcd$，套个双指针就可以了。这里用的是 st 表，时间复杂度 $O(n\log n+n)$。
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;

ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
}

int n, a[MAXN];

int lg[MAXN], st[18][MAXN];

inline 
void init() {
	for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for (int i = 1; i <= n; i++) st[0][i] = a[i];
	for (int i = 1; i <= lg[n]; i++) {
		for (int j = 1; j + (1 << i) - 1 <= n; j++) {
			st[i][j] = gcd(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);
		}
	}
}

inline 
int query(int l, int r) {
	int k = lg[r - l + 1];
	return gcd(st[k][l], st[k][r - (1 << k) + 1]);
}

int ans, sum;

int main() {
	scanf("%d", &n), ans = n;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), sum += a[i] == 1;
	init();
	if (sum) return printf("%d", n - sum), 0;
	if (query(1, n) > 1) return puts("-1"), 0;
	for (int l = 1, r = 1; r <= n; r++) {
		while (l < r && query(l + 1, r) == 1) l++;
		if (query(l, r) == 1) ans = min(ans, r - l);
	}
	printf("%d", n + ans - 1);
}
```

---

## 作者：_Flame_ (赞：3)

## 思路

要将整个数列都变为 $1$，首先一定要有一个位置为 $1$。

于是题目转化成这样，给你一个序列，问替换出一个 $1$ 的最小次数的问题。

然后我们可以发现，因为是相邻两个数变为 $\gcd(x,y)$，所以当一段长度为 $k$ 的区间的 $\text{gcd}$ 为 $1$ 时，这一段区间肯定能在 $k-1$ 内全部变为一，所以我们只用二分一个 $k$，求出最小的 $k$ 即可求解。

注意，当序列里有 $1$ 的时候，输出 $n-cnt$ 即可，其中 $\text{cnt}$ 为 $1$ 的个数，当区间 $\text{gcd}$ 不等于 $1$ 时，无解即可。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define _int __int128
#define y1 _
using namespace std;

static char buf[1000000],*p1=buf,*p2=buf;

inline int read(){
	char c=getchar();
	int res=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		res=res*10+c-'0';
		c=getchar();
	}
	return res*f;
}

inline void write(int x){
	static char buf[20];
	static int len=-1;
	if(x<0){
		putchar('-');
		x=-x;
	}
	do{
		buf[++len]=x%10;
		x/=10;
	}
	while(x);
	while(len>=0){
		putchar(buf[len--]+48);
	}
}

const int maxn=101000;
const int maxm=110;
const int mod=50;
const int inf=420444186480114514;

int n;
int a[maxn];
int f[maxn];
int pw[maxn],lg[maxn];
bool flag=0;
int ans;
int cnt;

int st[maxn][20];

int gcd(int x,int y){
	x=abs(x),y=abs(y);
	return y?gcd(y,x%y):x;
}

void init(){
	for(int i=1;i<=n;i++){
		st[i][0]=a[i];
	}
	for(int j=1;(1<<j)<=n;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			st[i][j]=gcd(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
	}
}

int query(int l,int r){
	int k=log2(r-l+1);
	return gcd(st[l][k],st[r-(1<<k)+1][k]);
}

bool check(int x){
	for(int i=1;i+x-1<=n;i++){
		int j=i+x-1;
		if(query(i,j)==1){
			return 1;
		}
	}
	return 0;
}

void solve(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(a[i]==1){
			flag=1;
			cnt++;
		}
	}
	if(cnt){
		write(n-cnt);
		return ;
	}
	init();
	if(query(1,n)!=1){
		puts("-1");
		return ;
	}
	int l=1,r=n;
	while(l<=r){
		int mid=l+r>>1;
		if(check(mid)){
			ans=mid;
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	write(ans+n-2);
	puts("");
	return ;
}

signed main(){
	int T=1;
	while(T--){
		solve();
	}
	return 0;
}




```

---

## 作者：COsm0s (赞：2)

## 题意

每次操作选择数组中任意两个**相邻**的元素 $x, y$ 并将其中的一个元素替换为 $\gcd(x, y)$。请问最少需要多少次操作才能让整个数组只含 $1$。

## 思路

让整个数组变成 $1$，也就意味着只要有一个数为 $1$ 就行了（性质显然）。

那么此时问题就转化成用最少的操作数使**数组中至少有一个数变成 $1$**。

再看题目，发现操作的两数必须是相邻两数进行，也就意味着这个 $1$ 必须由一个区间内推出。换句话说要找到一个区间，使得此区间最大公因数为 $1$。

那问题就简单了，我们用线段树或 ST 表维护区间 gcd，再枚举区间（运用双指针，two-pointer），就可以求出答案了。

复杂度 $O(n\log n\log a_i)$。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 10;
inline int read() {
	int x = 0, m = 1;
	char ch = getchar();
	while(!isdigit(ch)) {
		if(ch == '-') m = -1;
		ch = getchar();
	}
	while(isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * m;
}
inline void write(int x) {
	if(x < 0) putchar('-'), write(-x);
	else {
		if(x >= 10) write(x / 10);
		putchar(x % 10 + 48);
	}
}
int n, a[N];
int Gcd[N], cnt;
inline void Build(int x, int l, int r) {
	if(l == r) {
		Gcd[x] = a[l];
		return ;
	}
	int mid = l + r >> 1;
	Build(x << 1, l, mid);
	Build(x << 1 | 1, mid + 1, r);
	Gcd[x] = __gcd(Gcd[x << 1], Gcd[x << 1 | 1]);
}
inline int Query(int x, int l, int r, int L, int R) {
	if(L <= l && r <= R) {
		return Gcd[x];
	}
	int ans = 0;
	int mid = l + r >> 1;
	if(L <= mid) ans = __gcd(ans, Query(x << 1, l, mid, L, R));
	if(R > mid) ans = __gcd(ans, Query(x << 1 | 1, mid + 1, r, L, R));
	return ans;
}
//线段树维护区间 gcd
signed main() {
	n = read();
	for(int i = 1; i <= n; i ++) a[i] = read(), cnt += (a[i] == 1);
	Build(1, 1, n);
   if (cnt) return cout << n - cnt, 0;
	int ans = 1 << 30, j = 1;
	for(int i = 1; i <= n; i ++) {
		while(j < i && Query(1, 1, n, j + 1, i) == 1) ++ j;
		if(Query(1, 1, n, j, i) == 1) ans = min(ans, i - j);
	}
    //双指针求出最小区间长度
	if(ans == (1 << 30)) write(-1);
	else write(n + ans - 1);
	return 0;
}

```


---

## 作者：gdf_yhm (赞：2)

[P8792](https://www.luogu.com.cn/problem/P8792)

[CF891A](https://www.luogu.com.cn/problem/CF891A)

### 思路

为了使数组只剩 $1$，需要从一个 $1$ 开始不断与傍边的数做 gcd 操作，需要 $n-cnt_1$ 次。

如果数组中没有 $1$，那t_么需要连续对一段数 $[l,r]$ 做 gcd 操作得出一个 $1$，再用一个 $1$ 做 $n-1$ 次操作覆盖数组。最后答案为 $n-1+r-l+1-1$。当 $[l,r]$ 区间的 gcd 为 $1$ 时，可以选择该区间。

问题转换为：求一段最短的区间使其区间 gcd 为 $1$。

有 $n^2$ 个区间，直接枚举计算复杂度是 $O(n^3)$。

由于没有修改，可以使用 ST 表 $O(n\log n)$ 预处理，$O(1)$ 得出区间的 gcd。复杂度 $O(n^2)$。

但不一定要枚举每个区间。如果最大的区间不可取，大区间下的小区间也不可取。可以用双指针弄到 $O(n)$，但比较复杂。

询问最小，考虑二分答案，$O(n\log n)$，可以接受。

CF 上的双倍经验范围较小，但有一些 hack。

### code

```cpp

#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
const int maxn=100010;
const int inf=1e18;
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48),c=getchar();}
	return x*f;
}

int n,a[maxn],st[maxn][25];
int lg[maxn],pw[25];
int gcd(int a,int b){
	if(a%b==0)return b;
	return gcd(b,a%b);
}
int query(int l,int r){
	int k=lg[r-l+1];
	return gcd(st[l][k],st[r-pw[k]+1][k]);
}
int l,r,mid,ans;
bool check(int x){
	for(int i=1;i+x-1<=n;i++){
		int j=i+x-1;
		if(query(i,j)==1)return true;
	}
	return false;
}
int cnt;
signed main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read(),st[i][0]=a[i],cnt+=(a[i]==1);
	if(cnt==n){
		printf("0\n");
		return 0;
	}
	for(int i=1;i<=n;i++){
		if(a[i]==1){
			printf("%d\n",n-cnt);
			return 0;
		}
	}
	pw[0]=1;lg[1]=0;
	for(int i=2;i<=n;i++)lg[i]=lg[i>>1]+1;
	for(int i=1;i<=20;i++)pw[i]=pw[i-1]<<1;
	for(int j=1;j<=lg[n];j++){
		for(int i=1;i+pw[j]-1<=n;i++){
			st[i][j]=gcd(st[i][j-1],st[i+pw[j-1]][j-1]);
		}
	}
	if(query(1,n)!=1){
		printf("-1\n");
		return 0;
	}
	l=1,r=n;
	while(l<=r){
		mid=l+r>>1;
		if(check(mid)){
			ans=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	printf("%d\n",ans-1+n-1);
}

```



---

## 作者：hh__hh (赞：0)

首先，我们可以观察到，无论如何操作，数组中的元素的最大公约数不会增大，只会减小或保持不变。因此，我们可以考虑将数组中的所有元素都变为1。

接下来，我们考虑如何实现这个操作。假设数组中有两个相邻的元素 $a_i$ 和 $a_{i+1}$，我们希望将它们的最大公约数变为1。

假设 $d = \gcd(a_i, a_{i+1})$，我们可以将 $a_i$ 和 $a_{i+1}$ 分别除以 $d$，得到 $a_i' = \frac{a_i}{d}$ 和 $a_{i+1}' = \frac{a_{i+1}}{d}$。显然，$\gcd(a_i', a_{i+1}') = 1$。

因此，我们可以考虑使用递归的方法来实现这个操作。具体来说，我们可以定义一个函数 solve(l, r)，表示将数组中下标从 $l$ 到 $r$ 的元素变为1所需要的最少操作次数。我们可以将数组的整个范围 $/left[1, n /right]$ 分成两个子范围 $\left[l, mid \right]$ 和 $\left[mid+1, r \right]$，其中 $mid = \lfloor \frac{l+r}{2} \rfloor$。我们假设我们已经将两个子范围分别变为1，那么我们需要的操作次数可以通过以下方式计算：

首先，我们需要将子范围 $[l, mid]$ 的最后一个元素和子范围 $[mid+1, r]$ 的第一个元素的最大公约数变为1。假设这个最大公约数为 $d$，则我们需要进行 $d$ 次操作。然后，我们可以将两个子范围分别变为1，所需的总操作次数为 solve(l, mid) + solve(mid+1, r)。

其次，我们需要将子范围 $\left[l, mid \right]$ 和子范围 $\left[mid+1, r \right]$ 的最大公约数变为1，且这个最大公约数不是 $\left[l, mid \right]$ 的最后一个元素和 $\left[mid+1, r \right]$ 的第一个元素的最大公约数的倍数。

假设 $d_1 = \gcd(a_{mid}, a_{mid+1})$，$d_2 = \gcd(a_{mid-1}, a_{mid})$，则我们需要进行 $d_1 - d_2$ 次操作。

然后，我们可以将两个子范围分别变为1，所需的总操作次数为 `solve(l, mid) + solve(mid+1, r)`。

时间复杂度：$O(n \log M)$，其中 $M$ 是数组中的最大值。

思路已出，代码就不贴了。

---

## 作者：Infinite_Eternity (赞：0)

# Description

[P8792 [蓝桥杯 2022 国 A] 最大公约数](https://www.luogu.com.cn/problem/P8792)

给定一个数组，每次操作可以选择数组中任意两个相邻的元素 $x, y$ 并将其中的一个元素替换为 $\gcd(x, y)$，其中 $\gcd(x, y)$ 表示 $x$ 和 $y$ 的最大公约数。请问最少需要多少次操作才能让整个数组只含 $1$。

数据范围：$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

# Analysis

首先，我们先考虑数组中是否存在 $1$。如果数组中存在 $1$，那么我们可以直接进行平铺，把所有数都变成 $1$。假设 $1$ 的个数为 $x$ 个，那么最终的答案应该是 $n-x$ 次。

如果原数组中不存在 $1$，又该如何呢？此时，我们应该想办法变出一个 $1$，然后用这个 $1$ 进行平推，将数组全部变成 $1$。关于 $\gcd$，我们首先要明白：**如果一段子数组的的 $\gcd$ 为 $1$，那么原数组的 $\gcd$ 也一定为 $1$。** 这非常容易理解，即如果存在一个数组的 $\gcd$ 为 $1$，那么这个数组无论再加上任何正整数，$\gcd$ 也都是 $1$，**因为 $1$ 和任何数的 $\gcd$ 都是 $1$。**

题目要求最少次数，那么在没有 $1$ 的情况下，我们需要用最少的步数来获得 $1$。这需要我们在数组中找到最短的子数组，使得它们的 $\gcd$ 为 $1$。由于会涉及到查询区间 $\gcd$ 这个操作，直接暴力肯定不可取，所以我们应该联想到用线段树来进行查询。

那么如何寻找最短的子数组满足区间 $\gcd$ 为 $1$ 呢？我们可以考虑使用**二分**。对于数组中的每个数，我们都可以固定为左端点 $l$，然后去二分它的右端点，求出使得区间 $[l,r]$ 的 $\gcd$ 为 $1$ 的**最小的右端点**。既然二分，就需要满足二段性，根据上一段的描述，我们可以知道：如果 $[l,r]$ 的 $\gcd$  为 $1$，那么 $[l,r+1],\cdots,[l,n]$ 这些区间的 $\gcd$ 也一定为 $1$，
而 $[l,l+1],\cdots,[l,r-1]$ 这些区间却并不一定符合条件。这样我们将每个数都定为左端点，去二分它的右端点，将所有答案取最小值就能找出 $gcd$ 为 $1$ 的最短区间。

当然，我们如何判断无解的情况呢？还是根据上述关于 $\gcd$ 的理论知识，如果 $[1,n]$ 的 $\gcd$ 都不为 $1$，那么任何子数组的 $\gcd$ 也不可能为 $1$，此时无解。

时间复杂度 $\mathcal{O(n \log n)}$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int inf = 0x3f3f3f3f;
const int mod = 1000000007;
const int N=100010;

int n;
int a[N];
struct node
{
    int l, r;
    int g;
}tr[N<<2];

inline int read()
{
    register char c = getchar();
    register int x = 0, f = 1;
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c >= '0' && c <= '9') {x = (x << 3) + (x << 1) + c - 48;c = getchar();}
    return x * f;
}

inline void pushup(int u)
{
    tr[u].g =__gcd(tr[u<<1].g,tr[u<<1|1].g);
}

inline void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, a[r]};
    else
    {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

inline int query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].g;
    int mid = tr[u].l + tr[u].r >> 1;
    if(r<=mid) return query(u<<1,l,r);
    else if(l>mid) return query(u<<1|1,l,r);
    else return __gcd(query(u<<1,l,r),query(u<<1|1,l,r));
}
int main() 
{
	n=read();
	int f=0;
	for(register int i=1;i<=n;++i)
	{
		a[i]=read();
		if(a[i]==1) 
		    f++;
	}
	if(f)
	{
		printf("%d\n",n-f);
		return 0;
	}
	build(1,1,n);
	if(query(1,1,n)!=1)
	{
		puts("-1");
		return 0;
	}
	int ans=inf;
	for(register int i=1;i<=n;++i)
	{
		int l=i+1,r=n+1;
		while(l<r)
		{
			int mid=l+r>>1;
			if(query(1,i,mid)==1) 
			    r=mid;
			else 
			    l=mid+1;
		}
		if(query(1,i,r)==1) 
		    ans=min(ans,r-i);
	}
	printf("%d\n",n-1+ans);
    return 0;
}
```

---


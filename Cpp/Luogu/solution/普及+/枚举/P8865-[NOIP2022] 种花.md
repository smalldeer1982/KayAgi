# [NOIP2022] 种花

## 题目描述

小 C 决定在他的花园里种出 $\texttt{CCF}$ 字样的图案，因此他想知道 $\texttt C$ 和 $\texttt F$ 两个字母各自有多少种种花的方案；不幸的是，花园中有一些土坑，这些位置无法种花，因此他希望你能帮助他解决这个问题。

花园可以看作有 $n\times m$ 个位置的网格图，从上到下分别为第 $1$ 到第 $n$ 行，从左到右分别为第 $1$ 列到第 $m$ 列，其中每个位置有可能是土坑，也有可能不是，可以用 $a_{i,j} = 1$ 表示第 $i$ 行第 $j$ 列这个位置有土坑，否则用 $a_{i,j} = 0$ 表示这个位置没土坑。

一种种花方案被称为 $\texttt{C-}$ **形**的，如果存在 $x_1, x_2 \in [1, n]$，以及 $y_0, y_1, y_2 \in [1, m]$，满足 $x_1 + 1 < x_2$，并且 $y_0 < y_1, y_2 \leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_2$ **行**都**不为土坑**，且只在上述这些位置上种花。

一种种花方案被称为 $\texttt{F-}$ **形**的，如果存在 $x_1, x_2, x_3 \in [1, n]$，以及 $y_0, y_1, y_2 \in [1, m]$，满足 $x_1 + 1 < x_2 < x_3$，并且 $y_0 < y_1, y_2 \leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_3$ **行**都**不为土坑**，且只在上述这些位置上种花。

样例一解释中给出了 $\texttt{C-}$ 形和 $\texttt{F-}$ 形种花方案的图案示例。

现在小 C 想知道，给定 $n, m$ 以及表示每个位置是否为土坑的值 $\{a_{i,j}\}$，$\texttt{C-}$ 形和 $\texttt{F-}$ 形种花方案分别有多少种可能？由于答案可能非常之大，你只需要输出其对 $998244353$ 取模的结果即可，具体输出结果请看输出格式部分。

## 说明/提示

**【样例 1 解释】**

四个 $\texttt{C-}$ 形种花方案为：

```plain
**1 **1 **1 **1
*10 *10 *10 *10
**0 *** *00 *00
000 000 **0 ***
```

其中 $\texttt*$ 表示在这个位置种花。注意 $\texttt C$ 的两横可以不一样长。

类似的，两个 $\texttt{F-}$ 形种花方案为：

```plain
**1 **1
*10 *10
**0 ***
*00 *00
```

**【样例 2】**

见附件下的 $\texttt{plant/plant2.in}$ 与 $\texttt{plant/plant2.ans}$。

**【样例 3】**

见附件下的 $\texttt{plant/plant3.in}$ 与 $\texttt{plant/plant3.ans}$。

**【数据范围】**

对于所有数据，保证：$1 \leq T \leq 5$，$1 \leq n, m \leq 10^3$，$0 \leq c, f \leq 1$，$a_{i,j} \in \{0, 1\}$。

| 测试点编号 | $n$ | $m$ | $c=$ | $f=$ | 特殊性质 | 测试点分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 1000$ | $\leq 1000$ | $0$ | $0$ | 无 | $1$ |
| $2$ | $=3$ | $=2$ | $1$ | $1$ | 无 | $2$ |
| $3$ | $=4$ | $=2$ | $1$ | $1$ | 无 | $3$ |
| $4$ | $\leq 1000$ | $=2$ | $1$ | $1$ | 无 | $4$ |
| $5$ | $\leq 1000$ | $\leq 1000$ | $1$ | $1$ | A | $4$ |
| $6$ | $\leq 1000$ | $\leq 1000$ | $1$ | $1$ | B | $6$ |
| $7$ | $\leq 10$ | $\leq 10$ | $1$ | $1$ | 无 | $10$ |
| $8$ | $\leq 20$ | $\leq 20$ | $1$ | $1$ | 无 | $6$ |
| $9$ | $\leq 30$ | $\leq 30$ | $1$ | $1$ | 无 | $6$ |
| $10$ | $\leq 50$ | $\leq 50$ | $1$ | $1$ | 无 | $8$ |
| $11$ | $\leq 100$ | $\leq 100$ | $1$ | $1$ | 无 | $10$ |
| $12$ | $\leq 200$ | $\leq 200$ | $1$ | $1$ | 无 | $6$ |
| $13$ | $\leq 300$ | $\leq 300$ | $1$ | $1$ | 无 | $6$ |
| $14$ | $\leq 500$ | $\leq 500$ | $1$ | $1$ | 无 | $8$ |
| $15$ | $\leq 1000$ | $\leq 1000$ | $1$ | $0$ | 无 | $6$ |
| $16$ | $\leq 1000$ | $\leq 1000$ | $1$ | $1$ | 无 | $14$ |

特殊性质 A：$\forall 1 \leq i \leq n, 1 \leq j \leq \left\lfloor \frac{m}{3} \right\rfloor$，$a_{i, 3 j} = 1$；

特殊性质 B：$\forall 1 \leq i \leq \left\lfloor \frac{n}{4} \right\rfloor, 1 \leq j \leq m$，$a_{4 i, j} = 1$；

## 样例 #1

### 输入

```
1 0
4 3 1 1
001
010
000
000```

### 输出

```
4 2```

# 题解

## 作者：CuSO4_and_5H2O (赞：156)

AFO 了，考场上四十分钟打完 T1，以为自己一等稳了，但是有一个地方忘记取模，以为自己今年完了，想不到 CCF  数据能让我过（。

## 考场思路

只讲思路，没有代码，配合下边代码详解食用。

考试的时候一看题面，看着像是一个 DP ， 但是细想一下，貌似不是，只是一个很简单的前缀和优化计数问题。

首先，先考虑 $C$ 因为 $F$ 是  $C$ 下边随便加一个点，所以只要求出 $C$ 就求出了  $F$  。下边来考虑如何求 $C$ 。

注意到，他并没有要求上下行一样，唯一的要求是 $C$ 的两个横要隔一行，这就是问题的突破点，这题很明显的计数，计数用到什么？乘法原理，加法原理。

假设上边的有  $a$ 个合法的横，那考虑这一行每一个合法的横（这里说的不同是长度不同）给答案的贡献是什么？是不是每一个贡献  $a$ ，那这一行有  $b$ 个不同的合法的横，那么答案就增加了  $a  \times  b$，那每一行都这么处理，然后处理完一样就加上上一行的合法的方案数（因为他要求两个横之间至少隔一行）。当遇到土坑的时候就把记录数组清零即可。

 $C$ 解决了，那就是 $F$ 了、
 
 想要求出 $F$ ，只要求出这一列上有多少合法的 $C$ 就行了（因为 $F$ 是由  $C$ 下边加上一个竖构成的），所所以我们只要复制过来记录  $C$ 的公式然后把他存在另一个数组里到时候每找到一个能种花的地方 $F$ 的答案加上这个数组就好了。
 

那问题来了，怎么 $\Theta (1)$ 查询每一行有多少个合法的横？只需要预处理就 解决了。

## 代码

这里吧不同部分代码分开，并且删掉了取模部分（我觉得加上取模不雅观，去掉更方便看，打代码的时候别忘了加上），更容易食用。

### 初始化

多少大佬损兵折将在此处。这是最重要的部分了（，希望以后的 OIer 能记得有一年 NOIP T1 因为初始化干掉了很多大佬。

`memset(f,0,sizeof f);`

多测不清空，十年 OI 一场空。

### 预处理

预处理前缀和，让我们在 $\Theta (1)$ 下查询到每一行有多少合法的横。

```
for(int i=1;i<=n;i++)
	for(int j=m-1;j>=1;j--)
	{
		if(Map[i][j]=='1') f[i][j]=-1;//如果不能种花，就变成-1 
		else  if(Map[i][j+1]=='0') f[i][j]=f[i][j+1]+1;//能种花，就加上前缀和 
	}
```

### 求 $C$ 的数量

前边讲的很清楚了，不具体说了。

```
for(int j=1;j<m/*最后一列就不用枚举了*/;j++)//j是枚举每一列 
{
	jis=jil=jilf=0;
	for(int i=1;i<=n;i++)//每一行 
	{
		if(f[i][j]==-1){jis=jilf=jil=0;continue ;}//清空答案 
		ansc+=f[i][j]*jil;
		//乘法原理应用（上文讲了C如何求 
		jil+=max(0,f[i-1][j]);//因为我设置的初值是-1，所以取max 
		//加上上一行的，因为要保证每两个横之间隔一行 
	}
}
```

### 求 $F$ 的数量

```
for(int j=1;j<m;j++)//j是枚举每一列 
{
	jis=jil=jilf=0;
	for(int i=1;i<=n;i++)//每一行 
	{
		if(f[i][j]==-1){jis=jilf=jil=0;continue ;}
		ansf+=jilf;//因为当这个是可以种花的，那只要加上之前有多少C就是F的数量了 
		jilf+=f[i][j]*jil;//求出到当前这一行有多少合法的C
      //注意这上下两行不能换，因为要保证两横之间差一行
		jil+=max(0,f[i-1][j]);//和C的一样 
	}
}
```


然后把求 $C$ 和 $F$ 得循环结合在一起就行了

## 总代码

```
#include<bits/stdc++.h>
#define ll int
#define max(A,B) (A<B?B:A)
#define min(A,B) (A<B?A:B)
#define bug cout<<"I AK NOIP!"<<'\n';
#define gc getchar
using namespace std;
const int N=1005,mod=998244353;
inline ll read(){ll res=0,f=0;char ch=gc();for(;!isdigit(ch);ch=gc()) f=(ch=='-'?1:0);for(;isdigit(ch);ch=gc()) res=(res<<3)+(res<<1)+(ch^'0');return f?-res:res;}

long long ansc,ansf,c,F;
int n,m,id,T;
int f[N][N],jil,jilf,jis;
char Map[N][N];

signed main()
{
	T=read(),id=read();
	while(T--)
	{
		memset(f,0,sizeof f);
		n=read(),m=read();c=read(),F=read();
		for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>Map[i][j];
			for(int i=1;i<=n;i++)
				for(int j=m-1;j>=1;j--)
				{
					if(Map[i][j]=='1') f[i][j]=-1;//如果不能种花，就变成-1 
					else  if(Map[i][j+1]=='0') f[i][j]=f[i][j+1]+1;//能种花，就加上前缀和 
				}
		for(int j=1;j<m;j++)
		{
			jis=jil=jilf=0;
			for(int i=1;i<=n;i++)
			{
				if(f[i][j]==-1){jis=jilf=jil=0;continue ;}
				ansc=ansc%mod+(1ll*f[i][j]*(jil%mod))%mod;
				ansf=(ansf%mod+jilf%mod)%mod;
				jilf=(jilf+(1ll*f[i][j]*(jil%mod))%mod)%mod;
				jil+=max(0,f[i-1][j]);
			}
		}
		cout<<(c*ansc)%mod<<' '<<(F*ansf)%mod<<'\n';
		ansc=ansf=0;
	}
	return 0;
}
```

---

## 作者：一扶苏一 (赞：73)

# P8865 [NOIP2022] 种花
## Analysis

### C 的方案数

首先考虑统计 $\texttt{C}$ 形图案。

考虑枚举 $\texttt{C}$ 形图案左下角的折角处，即如下用 `*` 和 `&` 表示的 $\texttt{C}$ 的 `&` 位置：
```plain
***
*00
&**
```

先确定底边的的方案数：设某个位置 $(i,j)$ 是图案的左下角，那么该点右侧所有不经过土坑的长度至少为 $2$ 的横线都可以成为底边。设 $\mathrm{right}_{i,j}$ 表示格子 $(i,j)$ 向右延申的最长连续非土坑的长度，则底边的方案数即为 $\mathrm{right}_{i,j} - 1$（这里要求 $(i,j)$ 不是土坑）。

$\mathrm{right}$ 可以很容易的通过递推得到：

$$\mathrm{right}_{i,j} = \begin{cases}0, &a_{i,j} = 1 \\ 1 , &j = m \\ \mathrm{right}_{i,j+1} + 1, & \text{otherwise}\end{cases}$$

再考虑确定其余两条边的方案数。考虑画出这两条边其实就是从枚举的左下角折点起，向上画一条长度至少为 $2$ 的边，从这条竖边的上顶点画一条横边。设当前枚举到格子 $(i,j)$，该格子正上方离它最近的土坑是 $(k,j)$，那么对于 $k < h < i+1$，$(h,j)$ 到 $(i,j)$ 可以做竖边，$(h,j)$ 右侧的边可以做 $\texttt{C}$ 的顶边。如图是两种竖边和顶边的画法。
![](https://cdn.luogu.com.cn/upload/image_hosting/yl73mngr.png)

注意到格子 $(h,j)$ 对应的顶边方案数恰好也是 $\mathrm{right}_{h,j} - 1$。确定了 $(h,j)$ 的位置以后，竖边的画法是唯一的，于是竖边和顶边的方案数是 $\sum_{h = k + 1}^{i - 2} (\mathrm{right}_{h,j} - 1)$。这里要求 $(i - 1,j)$ 不是土坑。

设 $\mathrm{up}_{i,j}$ 表示以 $(i,j)$ 为左下角折点时的竖边和顶边的方案数（也就是上式），则有递推式：
$$\mathrm{up}_{i,j} = \begin{cases}0, & i = 1 \lor i = 2\\ 0, & a_{i - 2,j} = 1 \lor a_{i - 1,j} = 1 \lor a_{i,j} = 1 \\ up_{i - 1,j} + \mathrm{right}_{i - 2,j} - 1, &\text{otherwise}\end{cases}$$

把底边和另两条边的方案乘起来就是该点对应的全部方案。于是 $\texttt{C}$ 图形的总方案数为 $\sum_{i = 1}^n \sum_{j = 1}^m \mathrm{up}_{i,j} \times (\mathrm{right}_{i,j} - 1)$

### F 的方案数

再考虑计算 $\texttt F$ 的方案数。注意到 $\texttt{F}$ 形图案能且只能在 $\texttt{C}$ 形图案的竖线下方（也就是上文字符图的 `&` 处）接上一条长度至少为 $1$ 的竖线得到。对每个 $\texttt C$ 形图案，只需要计算其下方接上的竖线的最长长度即可。

如下图是一个例子，红色表示 $\texttt C$ 的部分，接上绿色的竖线后就构成了 $\texttt F$。

![](https://cdn.luogu.com.cn/upload/image_hosting/rjid8jcf.png)

设 $\mathrm{down}_{i,j}$ 表示 $(i,j)$ 格向下延申的最长非土坑的长度，有递推式：
$$\mathrm{down}_{i,j} = \begin{cases}0, &a_{i,j} = 1 \\ 1, &i = n \\\mathrm{down}_{i + 1, j} + 1, &\text{otherwise}\end{cases}$$

于是 $(i,j)$ 点对应的 $\texttt F$ 的方案数就是 $\mathrm{up}_{i,j} \times (\mathrm{right}_{i,j} - 1) \times (\mathrm{down}_{i,j} - 1)$。总的 $\texttt{F}$ 方案数即为 $\sum_{i = 1}^n \sum_{j=1}^m \mathrm{up}_{i,j} \times (\mathrm{right}_{i,j}-1) \times (\mathrm{down}_{i,j} - 1)$。

## Code

代码中稍有不同的是，格点坐标的范围是 $[0,n - 1]$ 和 $[0, m - 1]$，其余与上文叙述一致。

在对效率没有较高要求时，熟练使用 vector 可以避免一切清空问题[狗头]

```cpp
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>

const int p = 998244353;

int T, id, n, m, c, f;

int main() {
  for (std::cin >> T >> id; T; --T) {
    std::cin >> n >> m >> c >> f;
    std::vector<std::string> a(n);
    std::vector<std::vector<int>> right(n), up(n), down(n);
    for (auto &u : right) u.resize(m + 1);
    for (auto &u : up) u.resize(m + 1);
    for (auto &u : down) u.resize(m + 1);
    std::generate_n(a.begin(), n, []() -> std::string { std::string s; std::cin >> s; return s; });
    int ans1 = 0, ans2 = 0;
    for (int i = n - 1; i; --i) {
      for (int j = 0; j < m; ++j) if (a[i][j] != '1') {
        if (i < n - 1) down[i][j] = down[i + 1][j] + 1;
        else down[i][j] = 1;
      }
    }
    for (int i = 0; i < n; ++i) {
      for (int j = m - 1; j >= 0; --j) if (a[i][j] != '1') {
        right[i][j] = right[i][j + 1] + 1;
        if (i > 1 && a[i - 1][j] != '1' && right[i - 2][j] > 0) up[i][j] = up[i - 1][j] + right[i - 2][j] - 1;
        int c = (right[i][j] - 1) * up[i][j] % p, f = 1ll * c * (down[i][j] - 1) % p;
        if ((ans1 += c) >= p) ans1 -= p;
        if ((ans2 += f) >= p) ans2 -= p;
      }
    }
    std::cout << ans1 * c << ' ' << ans2 * f << '\n';
  }
}
```

---

## 作者：wangzl (赞：52)

## 题解 [P8865 [NOIP2022] 种花](https://www.luogu.com.cn/problem/P8865)

$\texttt{Update:}$  
$2022.12.04:$ 改进了文章中难（guǐ）懂（yì）的函数；  
$2022.12.07:$ 更改了题解代码中打错的变量名；  
$2022.12.07:$ 更新了同步官方数据后的评测记录。  

## 简要题意  

给出一个 $n \times m$ 的网格图，求其中有多少种 $\texttt{C-}$ **形**种花方案，多少种 $\texttt{F-}$ **形**种花方案。其中 $\texttt{C}$ 与 $\texttt{F}$ 两横可以不一样长，但两横之间必须有空行，$\texttt{F}$ 最后一横的下方的竖必须出头。  

拿到题先看数据范围：  
> 对于所有数据，保证：$1 \leq T \leq 5$，$1 \leq n, m \leq 10^3$  

所以本题考虑 $\mathcal{O}(Tn^2)$ 算法。

**注：本题解的代码中所有的 $k$ 均与题目描述中的 $a$ 含义相同，即是否为土坑。**

## $\texttt{C-}$ **形**种花方案的处理  

**约定：每个 $\texttt{C-}$ 形方案左上角的那一个点为该方案的顶点。**  

我们将 $right[i][j]$ 定义为点 $(i,j)$ **右侧连续** $0$ 的个数。（后面会用到）  
那么可以在 $\mathcal{O}(n^2)$ 的复杂度完成这一操作：
$$right[i][j] = \begin{cases}right[i][j + 1]+1&a[i][j]=a[i][j+1]=0\\0&\text{Otherwise.}\end{cases}$$

```cpp
for (int i = 1; i <= n; ++i) 
	for (int j = m - 1; j >= 1; --j) 
		if (! k[i][j] && ! k[i][j + 1]) 
		right[i][j] = right[i][j + 1] + 1;
```

若有这样一个 $3\times3$ 的网格图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/3j3cdwo7.png)  

那么 $\texttt{C-}$ **形** 种花情况一共有如下四种：  
![](https://cdn.luogu.com.cn/upload/image_hosting/4ivc3ur8.png) 

显然，该情况的方案数为 $right[1][1] \times right[3][1] = 2 \times2=4$。  

那如果不止两行可以组成 $\texttt{C-}$ **形**呢？  

来看如下 $5\times3$ 的网格图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/0tp345y8.png)  
同理，**以** $(1,1)$ **为顶点** 的 $\texttt{C-}$ **形**方案数为 $right[1][1] \times right[3][1] + right[1][1]\times right[4][1] + right[1][1] \times right[5][1]$

推广：以 $(i,j)$ 为顶点的 $\texttt{C-}$ **形**方案数 $ansc[i][j]=right[i][j]\times\boxed{\sum\limits_{k=i+2}^{a[k+1]=1}right[k][j]}$。 

**于是对于每一点，计算的时间复杂度为 $\mathcal{O}(n)$，总时间复杂度退化到了** $\mathcal{O}(n^3)$。

怎么处理呢？  
我们不妨定义 $sumc[i][j] = \sum\limits_{k=i}^{a[k+1]=1}right[k][j]$。 

那么：  
$$sumc[i][j] = \begin{cases}sumc[i + 1][j]+right[i][j]&a[i][j]=0\\0&\text{Otherwise.}\end{cases}$$

故可以提前用 $\mathcal{O}(n^2)$ 的复杂度计算 $sumc[i][j]$ :  
```cpp
for (int j = 1; j <= m; ++j)
	for (int i = n; i >= 1; --i) 
		if (! k[i][j]) {
		sumc[i][j] = sumc[i + 1][j] + right[i][j] * 1ll;
```

所以 $ansc[i][j]=right[i][j] \times sumc[i+2][j]$。单点计算复杂度提升到 $\mathcal{O}(1)$。

故 $\texttt{C-}$ **形**总方案数：  
$$vc=\sum_{i=1}^{n}\sum_{j=1}^{m}right[i][j]\times sumc[i+2][j].$$  

```cpp
for (int i = 1; i <= n; ++i) {
	for (int j = 1; j <= m; ++j) {
		if (k[i + 1][j]) continue;
		vc = (vc + right[i][j] * down[i + 2][j]) % mod;
	}
}
```
$\texttt{C-}$ **形**方案计算完结。

### $\texttt{C-}$ **形**方案 std:
```cpp
for (int i = 1; i <= n; ++i)
	for (int j = m - 1; j >= 1; --j)
		if (!k[i][j] && !k[i][j + 1])
		right[i][j] = right[i][j + 1] + 1;
for (int j = 1; j <= m; ++j)
	for (int i = n; i >= 1; --i)
		if (!k[i][j]) 
		sumc[i][j] = sumc[i + 1][j] + right[i][j] * 1ll;
for (int i = 1; i <= n; ++i) {
	for (int j = 1; j <= m; ++j) {
		if (k[i + 1][j]) continue;
		vc = (vc + right[i][j] * sumc[i + 2][j]) % mod;
	}
}
```
## $\texttt{F-}$ **形**种花方案的处理  

**约定：每个 $\texttt{F-}$ 形方案左上角的那一个点为该方案的顶点。**  

$\texttt{F-}$ **形**与 $\texttt{C-}$ **形**大同小异，只需要多处理一下出头的方案数。  

这里，我们需要引进一个数组 $down$，$down[i][j]$ 表示 $(i,j)$ 的下方有多少个连续的 $0$。（可以参考 $right[i][j]$ 的定义规则）  
跟 $right$ 数组一样，先用 $\mathcal{O}(n^2)$ 的复杂度预处理出 $down$ 数组：  
$$down[i][j] = \begin{cases}down[i + 1][j]+1&a[i+1][j]=a[i][j]=0\\0&\text{Otherwise.}\end{cases}$$  
```cpp
for (int j = 1; j <= m; ++j)
	for (int i = n - 1; i >= 1; --i)
		if (! k[i][j] && ! k[i + 1][j])
		down[i][j] = down[i + 1][j] + 1;
```

仿照 $\texttt{C-}$ **形**种花方案来探讨，若有如下 $5\times 3$ 的网格图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/tobnjqni.png)  

那么共有如下 $8$ 种情况：  
![](https://cdn.luogu.com.cn/upload/image_hosting/v56wnqd4.png)  

显然，对于这顶点为 $(1,1)$ 的$\texttt{F-}$ 形种花方案为：  
$sumf[1][1]=right[1][1]\times right[3][1]\times down[3][1]$。   
因为对于 $\texttt{F-}$ **形**的第二横可以在不同横行，所以对于同一个顶点来说最坏运算 $n$ 次。  
同 $\texttt{C-}$ **形**的讨论我们可以得知这样计算的时间复杂度**同样退化到了** $\mathcal{O}(n^3)$。  
同 $\texttt{C-}$ **形**的方法处理：  
定义 $sumf[i][j] = \sum\limits_{k=i}^{a[k+1]=1}right[k][j]\times down[k][j]$。  

那么：  
$$sumf[i][j] = \begin{cases}sumf[i + 1][j]+right[i][j]\times down[i][j]&a[i][j]=0\\0&\text{Otherwise.}\end{cases}$$

故同样可以提前用 $\mathcal{O}(n^2)$ 的复杂度计算 $sumf[i][j]$ :  
```cpp
for (int j = 1; j <= m; ++j) 
	for (int i = n - 1; i >= 1; --i) 
		if (!k[i][j]) 
		sumf[i][j] = sumf[i + 1][j] + right[i][j] * 1ll * down[i][j];
```

故  $\texttt{F-}$ **形**总方案数：  
$$fc=\sum_{i=1}^{n}\sum_{j=1}^{m}right[i][j]\times sumf[i+2][j].$$   

```cpp
for (int i = 1; i <= n; ++i) {
	for (int j = 1; j <= m; ++j) {
		if (k[i + 1][j]) continue;
		vf = (vf + right[i][j] * sumf[i + 2][j]) % mod;
	}
}
```  
$\texttt{F-}$ **形**种花方案推倒及计算也到此结束。  
### $\texttt{F-}$ **形**方案 std:  

在 $\texttt{C-}$ **形**计算时处理过的数组处理代码不再展示（如 $right$ 等）。
```cpp
for (int j = 1; j <= m; ++j)
	for (int i = n - 1; i >= 1; --i)
		if (! k[i][j] && ! k[i + 1][j])
		down[i][j] = down[i + 1][j] + 1;
for (int j = 1; j <= m; ++j) 
	for (int i = n; i >= 1; --i) 
		if (!k[i][j])
		sumf[i][j] = sumf[i + 1][j] + right[i][j] * 1ll * down[i][j];
for (int i = 1; i <= n; ++i) {
	for (int j = 1; j <= m; ++j) {
		if (k[i + 1][j]) continue;
		vf = (vf + right[i][j] * sumf[i + 2][j]) % mod;
	}
}
```

至此，本题已解答完毕，总时间复杂度为 $\mathcal{O}(Tn^2)$。  

## $\texttt{std:}$

使用 $right$ 来定义变量名会引起歧义，故代码中统一使用 $Right$ 替代。 

```cpp
#include <bits/stdc++.h>

using namespace std;

template <class type>
void read(type& x) {
    type s = 0;
    int w = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        s = (s << 3) + (s << 1) + (c ^ 48);
        c = getchar();
    }
    x = s * w;
}

const int N = 1e3 + 10;
const int mod = 998244353;
int t, id, n, m, c, f;
bool k[N][N];
int down[N][N];
int Right[N][N];
long long sumc[N][N], sumf[N][N], vc, vf;
int main() {
    //  freopen("plant.in", "r", stdin);
    //  freopen("plant.out", "w", stdout);
    read(t), read(id);
    while (t--) {
        read(n), read(m), read(c), read(f);
        vc = vf = 0;
        memset(Right, 0, sizeof(Right));
        memset(sumc, 0, sizeof(sumc));
        memset(sumf, 0, sizeof(sumf));
        memset(down, 0, sizeof(down));
        //一定记得memset，考场上就这样挂掉了
        memset(k, 0, sizeof(k));
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                char c; cin >> c;
                k[i][j] = c ^ 48;
            }
        }
        for (int i = 1; i <= n; ++i)
            for (int j = m - 1; j >= 1; --j)
                if (!k[i][j] && !k[i][j + 1])
                Right[i][j] = Right[i][j + 1] + 1;
        for (int j = 1; j <= m; ++j)
            for (int i = n; i >= 1; --i)
                if (!k[i][j]) 
                sumc[i][j] = sumc[i + 1][j] + Right[i][j] * 1ll;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (k[i + 1][j]) continue;
                vc = (vc + Right[i][j] * sumc[i + 2][j]) % mod;
            }
        }
        for (int j = 1; j <= m; ++j)
            for (int i = n - 1; i >= 1; --i)
                if (! k[i][j] && ! k[i + 1][j])
                down[i][j] = down[i + 1][j] + 1;
        for (int j = 1; j <= m; ++j) 
            for (int i = n; i >= 1; --i) 
                if (!k[i][j])
                sumf[i][j] = sumf[i + 1][j] + Right[i][j] * 1ll * down[i][j];
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (k[i + 1][j]) continue;
                vf = (vf + Right[i][j] * sumf[i + 2][j]) % mod;
            }
        }
        printf("%lld %lld\n", c * vc, f * vf);
    }
    return 0;
}
```  

总的来说速度还行，与预期差别不大：  
![](https://cdn.luogu.com.cn/upload/image_hosting/340gz1az.png)
* * *

完结撒花~~~  

第一次给 NOIP 写题解，有问题欢迎留言评论，有帮助记得点赞哦~

---

## 作者：StarryWander (赞：38)

# P8865 [NOIP2022] 种花（详细向）
## 题意。
在一个 $n \times m$ 的矩形中求形如 $C$ 和 $F$ 的方案数，其中 $a_{i,j} = 0$ 
可以填充，$a_{i,j} = 1$ 不可填充。

其中：
 
一种种花方案被称为 $\texttt{C-}$ **形**的，如果 $\exists $  $x_1, x_2 \in [1, n]$，以及 $y_0, y_1, y_2 \in [1, m]$，满足 $x_1 + 1 < x_2$，并且 $y_0 < y_1, y_2 \leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_2$ **行**都**不为土坑**，且只在上述这些位置上种花。

一种种花方案被称为 $\texttt{F-}$ **形**的，如果$\exists $ $x_1, x_2, x_3 \in [1, n]$，以及 $y_0, y_1, y_2 \in [1, m]$，满足 $x_1 + 1 < x_2 < x_3$，并且 $y_0 < y_1, y_2 \leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_3$ **行**都**不为土坑**，且只在上述这些位置上种花。

## 暴力。
纯暴力写法相信大家都会，略。

### 暴力优化。
#### 先考虑 $C$ 。

枚举每一列 $k$，在分别枚举在第 $k$ 列的 $i$，$j$ 两个点作为 $C$ 的左上角的点和左下角的点，判断 $i$，$j$ 是否满足题意。

如何判断是否满足题意？

此时只需要分别统计从 $i$，$j$ 行第 $k$ 列出发能到达的**连续**最多的格子数。方案数就是：$i$ 的方案数 $\times$ $j$ 的方案数。当统计出来 $0$ 时，即不满足题意。

同时，还需要判断的就是 $a_{i,k}$ 到 $a_{j,k}$ 这一连续区间里是否全为 $0$。若其中夹杂着 $1$ 则不满足题意。

#### 再考虑 $F$ 。

只需在求 $C$ 的基础上，统计出 $a_{j,k}$ 这个点以下有多少个连续的 $0$ ，再乘上 $C$ 的答案即为 $F$ 的方案数。

**实现：**

- 定义 $cntn[i][j]$ 统计第 $j$ 列到 $i$为止 $1$ 的个数的前缀和。枚举时，$cntn[j][k]-cntn[i][k]=0$，此区间全部为 $0$。同时该数组还可运用在 $F$ 的统计之中。

- 定义 $mxn[i][j]$ 统计 $a_{i,j} $ 这个点能向下跳且不遇到 $1$ 的最大编号。求方案数的时，**将编号减去自身所处位置的编号即可。**

- 同理，定义 $mxm[i][j]$ 统计 $a_{i,j} $ 这个点能向右跳且不遇到 $1$ 的最大编号。求方案数的时，**将编号减去自身所处位置的编号**。

此时，复杂度为 $O(Tn^3)$，已经非常接近 AC 了。

### 具体细节见代码：
```cpp
#include<bits/stdc++.h>
#define int long long//记得开 long long。
using namespace std;
const int mod=998244353;
bool a[1005][1005];
int cntn[1005][1005];
int mxm[1005][1005];
int mxn[1005][1005];
signed main(){
	int T,id;
	scanf("%d%d",&T,&id);
	while(T--){
		memset(cntn,0,sizeof(cntn));
		memset(mxn,0,sizeof(mxn));
		memset(mxm,0,sizeof(mxm));
		int n,m,c,f;
		int ansc=0,ansf=0;
		scanf("%d%d%d%d",&n,&m,&c,&f);	
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				char c;
				cin>>c;
				a[i][j]=c-'0';
			}
		}
		
		if(c==0&&f==0){//特判。
			printf("0 0\n");
			continue;
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cntn[i][j]=cntn[i-1][j]+a[i][j];
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=m;j>=1;j--){
				if(!a[i][j]){
					mxm[i][j]=max(j,mxm[i][j+1]);
				}
			}
		}
		for(int j=1;j<=m;j++){
			for(int i=n;i>=1;i--){
				if(!a[i][j]){
					mxn[i][j]=max(i,mxn[i+1][j]);
				}
			}
		}
		for(int k=1;k<=m;k++){
			for(int i=1;i<=n;i++){
				if(a[i][k]) continue;
				for(int j=i+2;j<=n;j++){
					if(a[j][k]) break;
					int cnt1=0,cnt2=0,cnt3=0;
					if(cntn[j][k]-cntn[i][k]==0){
						cnt1=mxm[i][k]-k;//a(i,k)的方案数。
						cnt2=mxm[j][k]-k;//a(j,k)的方案数。
					}
					cnt3=mxn[j][k]-j;//a(j,k)这个点能再向下取到的
					int p=cnt1*cnt2;//乘法原理，两个方案数相乘。
					p%=mod;
					ansc=(ansc+p)%mod;//C的方案数。
					ansf=(ansf+p*cnt3)%mod;//F的方案数
				}
			}
		}
		printf("%lld ",ansc%mod);
		if(f==0) printf("0\n");
		else printf("%lld\n",ansf%mod);
	}
	return 0;
}
```

## $O(Tn^2)$ 做法。

基于暴力做法考虑再优化掉枚举 $j$ 这个点的循环。

此前我们已经统计出了 $a_{i,j} $ 这个点能向下跳的最大的编号。$j$ 直接就可以被我们枚举出来了。因为枚举的方案数是：

$mxm[i][k] \times mxm[i+2][k] +mxm[i][k] \times mxm[i+3][k]......+mxm[i][k] \times mxm[j][k]$

$=mxm[i][k] \times (mxm[i+2][k] + mxm[i+3][k]......mxm[j][k])$

这样就可以对 $mxm[i][j]$ 再进行一次每列单独的前缀和即可，这样我们就可以直接计算出 $i+2$ 到 $j$ 这一区间的方案数。

**注意，统计 $F$ 的时候不能再与暴力时候直接相加**，思路还是和统计 $C$ 一样。再开一个 $mul[i][j]$ 数组单独统计向下和向右贡献的乘积，再做一遍前缀和就可以独立出 $F$ 的统计方案数。

#### 几点注意：

- 记得开 long long 。

- 多组测试数据要把数组清空，特别是前缀和数组。

- 在**输入完成后**进行一个 $c=0$，$f=0$ 的特判。

### code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int mod=998244353;
bool a[1005][1005];
int mxm[1005][1005];
int mxn[1005][1005];
int mxn2[1005][1005];
int mul[1005][1005];
int sum[1005][1005];
int sum2[1005][1005];
char s[1005][1005];
signed main(){
	int T,id;
	T=read(),id=read();
	while(T--){
		memset(mxn,0,sizeof(mxn));
		//memset(mxn2,0,sizeof(mxn2));//可以不用初始化。
		memset(mxm,0,sizeof(mxm));
		//memset(mul,0,sizeof(mul));//同理。
		memset(sum,0,sizeof(sum));
		memset(sum2,0,sizeof(sum2));
		int n,m,c,f;
		int ansc=0,ansf=0;
		n=read(),m=read(),c=read(),f=read();
		for(int i=0;i<n;i++) scanf("%s",s[i]);
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				a[i+1][j+1]=s[i][j]-'0';
			}
		}
		if(c==0&&f==0){
			printf("０ ０\n");
			continue;
		}
		for(int i=1;i<=n;i++){
			for(int j=m;j>=1;j--){
				if(!a[i][j]){
					mxm[i][j]=max(j,mxm[i][j+1]);
				}
			}
		}
		for(int j=1;j<=m;j++){
			for(int i=n;i>=1;i--){
				if(!a[i][j]){
					mxn[i][j]=max(i,mxn[i+1][j]);
				}
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(mxn[i][j])mxn2[i][j]=mxn[i][j]-i;
				if(mxm[i][j]) mxm[i][j]-=j;
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				mul[i][j]=mxn2[i][j]*mxm[i][j];
				mul[i][j]%=mod;
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				sum[i][j]=mxm[i][j]+sum[i-1][j];//统计每个点C的方案数。
                
				sum2[i][j]=mul[i][j]+sum2[i-1][j];//统计每个点F的方案数。 
				
          		sum2[i][j]%=mod; 
			}
		}
		for(int i=1;i<=n;i++){
			for(int k=1;k<=m;k++){
				if(a[i][k]) continue;
                
				int cnt1=0,cnt2=0,cnt3=0;
                
				int j=mxn[i][k];
				if(j-i<2) continue;
                
				int p=sum[j][k]-sum[i+1][k];
				cnt1=p*mxm[i][k]%mod;
                
				int p2=sum2[j][k]-sum2[i+1][k];
				cnt2=p2*mxm[i][k]%mod;
                
				ansc=(ansc+cnt1)%mod;
				ansf=(ansf+cnt2)%mod;
			}
		}
		printf("%lld ",ansc%mod);
		if(f==0) printf("0\n");
		else printf("%lld\n",ansf%mod);
	}
	return 0;
}
```

---

## 作者：Jia_ye (赞：32)

**一些废话**

本题其实是道给**普及组选手**做的题，因为其本质知识点只用到 **暴力枚举 + 乘法原理 + 前缀和**。  
但是非常可惜，笔者在考场上仅打出本题的正解，相当于提高组算法跟没学一样，~~可能这就是信息竞赛的魅力罢~~。

仅以本题，纪念我第一次，也是最后一次的信息竞赛 NOIP 2022。


------------
#### 关于输入和输出

因为地图上 $0$ 和 $1$ 是并在一起的，所以你不得不使用字符串作为输入内容。为了方便，可以将字符转化为想要的 $0$ 和 $1$。下面是一个示例。

```cpp
char e[maxn][maxn];
bool a[maxn][maxn];

for(int i=1;i<=n;i++)
{
	cin>>e[i];
	for(int j=0;j<m;j++)
		a[i][j+1]=e[i][j]-'0';
}
```

注意到题目中给出 $0\le c,f\le 1$，同时 $c,f$ 为整数，这说明只有可能是 $0$ 和 $1$。这会导致某些答案为 $0$。考虑输出答案时，可以在对应答案为 $0$ 时，直接输出 $0$。当然也可以乘入答案，这只是一个保险的思路。

```cpp
if(c==0) cout<<"0 ";
else cout<<ansc%mod<<' ';
if(f==0) cout<<"0\n";
else cout<<ansf%mod<<'\n';
```



------------
#### $1$ 分 解法

输出 $T$ 个 `0 0` 即可获得 $1$ 分。代码略掉。

当然还有众多在考场上疏漏了一些细节的选手（多测不清空、不换行）仅得了一分，祝好。


------------
#### 再 $+21$ 分 解法

无脑的枚举。

主循环枚举的是两个点，即 $\texttt{C}$ 字型的左上角的点和左下角的点。通过枚举同一列的两个点，形成一条竖线，这条竖线便是字形左边的那条竖线。判断一下竖线是否合法，题目中告诉了我们左上和左下至少隔了一个点，所以长度必须 $\ge 3$，同时其间不能有坑。

考虑 $\texttt{C}$ 字型，左上角每**延伸**一个点，可以让左下角的一个点往后**延伸**到底，这样枚举每次延伸，把所有 $\texttt{C}$ 字型都遍历到，计数即可。

考虑 $\texttt{F}$ 字型，其实是 $\texttt{C}$ 字型的左边竖线再往下**延伸**，再多加一层循环向下延伸，遍历所有 $\texttt{F}$ 字型。

最坏复杂度达到惊人的 $O(n^3m^3)$，所以直接打暴力可以获得 $2,3,7,8$ 点的分数。但实际上官方数据能达到 $52$ 分的好成绩，这显然是因为地图不会造全是 $0$ 的数据，加入判断并不会全部跑满六次方。

```cpp
int main()
{
    cin>>t>>id;
    while(t--)
    {
        cin>>n>>m>>c>>f;
        for(int i=1;i<=n;i++)
        {
            cin>>e[i];
            for(int j=0;j<m;j++)
                a[i][j+1]=e[i][j]-'0';
        }
        
        ansc=ansf=0;
        for(int j=1;j<=m-1;j++)  //枚举列
            for(int i=1;i<=n;i++)
                for(int k=i+2;k<=n;k++) // 枚举上端点和下端点来枚举竖线
                {
                    //判断该竖线是否合法
                    int flag=0;
                    for(int l=i;l<=k;l++)
                        if(a[l][j]) flag=1;
                    if(flag) continue;
                    //如果无法向右延伸，也就没有C字了，也可以略过
                    if(a[i][j+1]) continue;
                    if(a[k][j+1]) continue;
                    
                    for(int l=j+1;l<=m;l++) //左上角向右延伸
                    {
                        if(a[i][l]) break;  //直到发现坑，就无法延伸下去
                        for(int o=j+1;o<=m;o++) //左下角往右延伸
                        {
                            if(a[k][o]) break;
                            ansc++,ansc%=mod;  //计数，C字
                            for(int p=k+1;p<=n;p++) //左下角再尝试往下
                            {
                                if(a[p][j])break;
                                ansf++,ansf%=mod; //F字
                            }
                        }
                    }
                }
                
        
        if(c==0) cout<<"0 ";
        else cout<<ansc%mod<<' ';
        if(f==0) cout<<"0\n";
        else cout<<ansf%mod<<'\n';
    }
    return 0;
}
```

------------
#### $4+4$ 分 解法

这个时候我们可以考察特殊性质 A 了。

翻译一下特殊性质 A，每一行的 $3$ 的倍数列的位置都会有坑，也就是说每三列有一整列的坑。整张地图被划分为若干个 $m=2$ 的地图。再看一眼数据范围，发现 $4$ 号测试点也是 $m=2$，所以考虑这个问题可以得 $8$ 分。

由于只有两列，左边一列的点向右延伸都只能延伸一格，只有一种情况，此时只需要枚举竖线并判断一下能否延伸，就能统计加一；而右边一列的点已经无法延伸，无需枚举。

复杂度为 $O(n^3m)$。显然跑不满，获得了 $4,5$ 两点的分数。代码略。

------------
#### 再 $+24$ 分 解法

稍微多想一步就可以知道上面**延伸**的步骤实际上就是**乘法原理**。

尝试**预处理**出每个点能够**向右延伸到达的最长长度**，记为 $r_{i,j}$。那么枚举出坐上左下两点之后，将这两个点的 $r$ 值相乘，就是以该两点为左上左下角的所有 $\texttt{C}$ 字型的方案数。

同时为了统计 $\texttt{F}$ 字，我们可以顺便预处理每个点向下延伸到达的最长长度 $d_{i,j}$。刚刚的式子乘上左下角的 $d$ 值即可。

复杂度瞬间小到 $n^3m$。预期可以跑过 $9,10,11$ 的点。实际上官方数据也是 $52$ 分。

预处理的方式多种多样，下面是一种方式来求 $r$ 和 $d$。你也可以用后缀和来求得每个点往右延伸到达最远的点。

```cpp
void init()
{
    memset(r,0,sizeof(r));
    memset(d,0,sizeof(d));
    
    int len=0;
    for(int i=1;i<=n;i++,len=0)
        for(int j=m;j>=1;j--)
            if(!a[i][j])
                r[i][j]=len++;
            else
                r[i][j]=-1,len=0;
    
    len=0;
    for(int j=1;j<=m;j++,len=0)
        for(int i=n;i>=1;i--)
            if(!a[i][j])
                d[i][j]=len++;
            else
                d[i][j]=-1,len=0;
}
```
下面是改变过的主函数。细节很多，比如 $mod$ 记得除、乘上的时候别忘了转化为 `long long`、预处理时不忘了清空。这些都为了最后打出正解奠定了基础。
```cpp
    init();
    ansc=ansf=0;
    for(int j=1;j<=m-1;j++)
        for(int i=1;i<=n;i++)
            for(int k=i+2;k<=n;k++)
            {
                int flag=0;
                for(int l=i;l<=k;l++)
                    if(a[l][j]) flag=1;
                if(flag) continue;
                
                ansc+=1ll*r[i][j]*r[k][j]%mod,ansc%=mod; // 乘法原理
                ansf+=1ll*r[i][j]*r[k][j]*d[k][j]%mod,ansf%=mod;
            }
```

------------
#### $6$ 分 解法

理解乘法原理之后，就可以考察特殊性质 B 了。

B 描述与 A 类似，只不过变成一横排一横排的坑了。整张地图被划分为若干张 $n=3$ 的地图。

哇！不用枚举竖线了。因为竖线长度至少为 $3$，但是地图只有 $3$ 行，只需要枚举列就可以了。直接判断这一列的竖线是否合法，然后乘法原理开摆即可。

复杂度为 $O(nm^2)$。获得了 $6$ 点的分数。代码略。

------------
#### 再 $+20$ 分 解法

考虑对枚举竖线进行优化。刚刚的枚举竖线方式显然过于无脑。

有一种**空间换时间**的方法叫**悬线法**，这里用了其变种。如果不会也没关系，因为其实这本身沿用了上面**延伸**的思想。

如果预处理出每个点**向上延伸能延伸的最长长度** $u_{i,j}$。当你想要枚举一条竖线时，只需要枚举下端点，考察这个点的 $u$ 值，发现向上延伸 $2$ 到 $u$ 格都是合法的竖线，这样从 $2$ 枚举到 $u$ 就能枚举出所有的竖线。

相比于无脑做法，省去了判断竖线是否合法的步骤，因此降低了一维复杂度。$O(n^2m)$ 能胜任 $12,13,14$ 的点。实际上官方数据已经拿满，民间数据也只剩下最后两点没有拿到分数，非常可观，考场上就可以开 T2 去了。

预处理 $u$ 的步骤略去。

```cpp
void ans()
{
    ansc=0,ansf=0;
    for(int i=3;i<=n;i++)
        for(int j=1;j<=m-1;j++) //枚举左下角
        {
            int h=u[i][j];
            if(!a[i][j] && h>=2)
                for(int k=i-h;k<=i-2;k++) //枚举合法的左上角
                {
                    ansc+=(1ll*r[k][j]*r[i][j])%mod,ansc%=mod;  //乘法原理
                    if(d[i][j]>=1)
                        ansf+=(1ll*r[k][j]*r[i][j]*d[i][j])%mod,ansf%=mod;
                }
        }
}

```

------------
#### 满分 正解

现在你已经拿了 $80$ 分，且在 官方数据 下，你拿到了满分。然而你仍心存疑虑，想着能不能再进行一步优化给它整到 $O(nm)$。

想一想最后一层循环，最后一层循环的 $k$ 其实只会对乘法原理的 $r_{k,j}$ 产生影响，而其余可以提出来当公因式，也就是
$$V_C=\sum\limits_{k=i-h}^{i-2}(r_{k,j}\times r_{i,j})=r_{i,j}\times\sum\limits_{k=i-h}^{i-2}r_{k,j}$$
$$V_F=\sum\limits_{k=i-h}^{i-2}(r_{k,j}\times r_{i,j}\times d_{i,j})=r_{i,j}d_{i,j}\times \sum\limits_{k=i-h}^{i-2}r_{k,j}$$

诶！右边那个求和只不过是 **$i$ 维度上的一段区间和诶**！这样的话，对 $r$ 的 $i$ 维做一个前缀和即可。设前缀和为  $s_{i,j}$。有
$$V_C=\sum\limits_{k=i-h}^{i-2}(r_{k,j}\times r_{i,j})=r_{i,j}\times(s_{i-2,j}-s_{i-h-1,j})$$

只需要预处理一个 $s$ 数组就大获全胜了。复杂度仅 $O(nm)$，输入的时候就已经达到了该复杂度，所以已经最优了，能够轻松满分。

$\mathtt{1.13s /  17.93MB /  1.92KB}$ 换成 `scanf` 还能更快，但是足够了。

```cpp
#include<iostream>
#include<cstring>
using namespace std;

const int maxn=1e3+9;
const int mod=998244353;
int t,id,n,m,c,f;
long long ansc,ansf;
char e[maxn][maxn];
bool a[maxn][maxn];
int u[maxn][maxn];
int r[maxn][maxn];
int s[maxn][maxn];
int d[maxn][maxn];

void init()
{
    memset(u,0,sizeof(u));
    memset(r,0,sizeof(r));
    memset(s,0,sizeof(s));
    memset(d,0,sizeof(d));
    
    int len=0;
    for(int j=1;j<=m;j++,len=0)
        for(int i=1;i<=n;i++)
            if(!a[i][j])
                u[i][j]=len++;
            else
                u[i][j]=-1,len=0;
    
    len=0;
    for(int i=1;i<=n;i++,len=0)
        for(int j=m;j>=1;j--)
            if(!a[i][j])
                r[i][j]=len++;
            else
                r[i][j]=-1,len=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(!a[i][j])
                s[i][j]=s[i-1][j]+r[i][j];
                
    
    len=0;
    for(int j=1;j<=m;j++,len=0)
        for(int i=n;i>=1;i--)
            if(!a[i][j])
                d[i][j]=len++;
            else
                d[i][j]=-1,len=0;
}

void ans()
{
    ansc=0,ansf=0;
    for(int i=3;i<=n;i++)
        for(int j=1;j<=m-1;j++)
        {
            int h=u[i][j];
            if(!a[i][j] && h>=2)
                ansc+=(1ll*(s[i-2][j]-s[i-h-1][j])*r[i][j])%mod,ansc%=mod;
            if(!a[i][j] && h>=2 && d[i][j]>=1)
                ansf+=(1ll*(s[i-2][j]-s[i-h-1][j])*r[i][j]*d[i][j])%mod,ansf%=mod;
        }
}

int main()
{
    cin>>t>>id;
    while(t--)
    {
        cin>>n>>m>>c>>f;
        for(int i=1;i<=n;i++)
        {
            cin>>e[i];
            for(int j=0;j<m;j++)
                a[i][j+1]=e[i][j]-'0';
        }
        
        init();
        ans();
        
        if(c==0) cout<<"0 ";
        else cout<<ansc%mod<<' ';
        if(f==0) cout<<"0\n";
        else cout<<ansf%mod<<'\n';
    }
    return 0;
}
```

------------
**感谢上帝**

神奇的是，这个做法不用清空数组也能拿到满分，而且官方也满，民间也满了。我就是在阴差阳错之下莫名其妙每清空还拿满，~~显然对我的 OI 生涯有不可磨灭的作用~~。

复盘出了我的正解之后发现，啊，我的各个数组都是直接覆盖进去的，确实不用清空，那没事了。

BY 迦叶  
2022/12/07


---

## 作者：dbxxx (赞：17)

[您可在我的博客中查看本文，谢谢！](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p8865.html)

[P8865 NOIP2022 种花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P8865)。

记 $a(x, y)$ 代表原文的 $a_{x, y}$。

考虑对每个点统计：**左上角**在该点的 $\texttt{C-}$，$\texttt{F-}$ 的数量。最终答案累加每个点对应的答案即可。

那么接下来我们想：对于一个点怎么计算对应的答案？我们生成一个地图来看看：

![](https://cdn.luogu.com.cn/upload/image_hosting/z74o0ypf.png)

其中白色代表可以放置花，红色代表不可放置。现在，我们要计算左上角在 $(1, 1)$ 的 $\texttt{C-}$ 的数量。

较容易看出，$\texttt{C-}$ 的最上面那一横总共有 $3$ 种画法，下面是其中一种：

![](https://cdn.luogu.com.cn/upload/image_hosting/pu9fbzry.png)

考虑 $3$ 的意义，其实它是从 $(1, 1)$ 开始，往右最多有几个连续的白色方块（不统计 $(1, 1)$ 本身）。

据此，我们考虑预处理 $r(x, y)$ 表示 $(x, y)$ 开始向右最多有几个连续的 $0$（不统计 $(x, y)$ 本身）。特别地，当 $a(x, y) = 1$ 时，记 $r(x, y) = -1$。

$r$ 可以通过 $\Theta(nm)$ 的递推（或者说后缀和）得到，具体来说，当 $a(x, y) = 1$ 时，$r(x, y) = -1$，否则 $r(x, y) = r(x, y + 1) + 1$。边界是 $r(x, m +1) = -1$。

那么 $\texttt{C-}$ 的剩下一部分（先下再右的整个一个折线）有多少种画法呢？我们发现：

- 当 $\texttt{C-}$ 的一竖延伸到 $(3, 1)$ 时，剩下一部分有 $r(3, 1) = 3$ 种画法；
- 当 $\texttt{C-}$ 的一竖延伸到 $(4, 1)$ 时，剩下一部分有 $r(4, 1) = 0$ 种画法；
- 当 $\texttt{C-}$ 的一竖延伸到 $(5, 1)$ 时，剩下一部分有 $r(5, 1) = 5$ 种画法；
- 当 $\texttt{C-}$ 的一竖延伸到 $(6, 1)$ 时，剩下一部分有 $r(6, 1) = 1$ 种画法。

因此剩下这部分总共有 $r(3, 1) + r(4, 1) + r(5, 1) + r(6, 1) = 9$ 种画法。根据乘法原理可以得到，以 $(1, 1)$ 为左上角的 $\texttt{C-}$ 数量有 $3 \times 9 = 27$ 个。

一般地，$(x, y)$ 对应的 $\texttt{C-}$ 数量可以表示为 $r(x, y) \times \sum\limits_{t = x + 2} ^ k r(t, y)$，其中 $k$ 满足：$a(x, y) = a(x + 1, y) = \cdots = a(k, y) = 0$，而 $a(k + 1, y) = 1$，此处我们认为 $a(n + 1, y) = 1$。

这里 $k$ 的存在是考虑 $\texttt{C-}$ 的那一竖，有时并不能像上面那个例子一样无限向下延伸，如果遇到一个红色方块就需要停止了。比如，若上面的 $(5, 1)$ 是红色，那么 $(1, 1)$ 对应的 $\texttt{C-}$ 中，除去上面一横的剩下一部分，只剩下 $r(3, 1) +r(4, 1) = 3$ 种画法。

为了让式子仍然可以 $\Theta(1)$ 直接计算，我们考虑预处理 $g(x, y) = \sum \limits _{t=x} ^ k r(t, y)$，$k$ 的含义和上面相同。递推和 $r$ 差不多：当 $a(x, y) = 1$ 时，$g(x, y) = 0$，否则 $g(x, y) = g(x + 1, y) +r(x, y)$。边界是 $g(n + 1, y) = 0$。

这样以来，当 $a(x, y) = 0$ 且 $a(x + 1, y) = 0$ 时，$(x, y)$ 对应的 $\texttt{C-}$ 数量就为 $r(x, y) \times g(x + 2, y)$，否则显然为 $0$。**请注意检验 $a(x + 1, y)$ 为 $0$ 的必要性**。

接下来计算 $\texttt{F-}$。还是上面这个例子，上面那一横的画法显然还是 $r(1, 1) = 3$。

剩下一部分因为形状的变化，画法数量也会有变化。当 $\texttt{F-}$ 的上半竖延伸到 $(3, 1)$ 时，第二个横有 $r(3, 1) = 3$ 种画法，这个仍然不变。但此时我们还要考虑下半竖，总共还有 $6 - 3 = 3$ 种画法。因此，当 $\texttt{F-}$ 的上半竖延伸到 $(3, 1)$ 时，除了第一横的剩下一部分总共有 $3 \times 3 = 9$ 种画法。而当 $\texttt{F-}$ 上半竖延伸到 $(5, 1)$ 时，总共有 $r(5, 1) \times (6 - 5) = 5$ 种。其实也就是在 $\texttt{C-}$ 的基础上，再套一个乘法原理将下半竖的画法统计进去。

类似一般地，$(x, y)$ 对应的 $\texttt{F-}$ 数量可以表示为 $r(x, y) \times \sum \limits _{t = x +2} ^ k r(t, y) \times (k - t)$，其中 $k$ 满足：$a(x, y) = a(x + 1, y) = \cdots = a(k, y) = 0$，而 $a(k + 1, y) = 1$，我们认为 $a(n + 1, y) = 1$。

预处理 $h(x, y) = \sum \limits _{t = x} ^ k r(t, y)$，当 $a(x, y) = 1$ 时，$h(x, y) = 0$，否则 $h(x, y) = h(x +1, y) + r(x, y) \times (k - t)$。边界是 $h(n +1, y) = 0$。

这样以来，当 $a(x, y) = 0$ 且 $a(x + 1, y) = 0$ 时，$(x, y)$ 对应的 $\texttt{F-}$ 数量就为 $r(x, y) \times h(x + 2, y)$，否则显然为 $0$。

时间复杂度 $\Theta(nm)$。

```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2022-12-01 11:11:02 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2022-12-01 12:02:12
 */
#include <bits/stdc++.h>
#define int long long
inline int read() {
    int x = 0;
    bool f = true;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = false;
    for (; isdigit(ch); ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    return f ? x : (~(x - 1));
}
inline std :: pair <std :: string, int> rest(bool space = true) {
    std :: string s;
    char ch = getchar();
    for (; !isgraph(ch); ch = getchar());
    for (; isgraph(ch); ch = getchar())
        s.push_back(ch);
    return {space ? " " + s : s, s.length()};
}

const int maxn = 1005;
const int maxm = 1005;
const int mod = 998244353;

bool a[maxn][maxm];
int r[maxn][maxm], g[maxn][maxm], h[maxn][maxm];

signed main() {
    int T = read(); read();
    while (T--) {
        std :: memset(r, -1, sizeof(r));
        std :: memset(g, 0, sizeof(g));
        std :: memset(h, 0, sizeof(h));

        int n = read(), m = read(), C = read(), F = read();

        for (int i = 1; i <= n; ++i) {
            std :: string s = rest().first;
            for (int j = 1; j <= m; ++j)
                a[i][j] = (s[j] == '1');
        }

        for (int i = 1; i <= n; ++i)
            for (int j = m; j; --j)
                r[i][j] = a[i][j] ? -1 : (r[i][j + 1] + 1);
        
        for (int i = n; i; --i)
            for (int j = 1; j <= m; ++j)
                g[i][j] = a[i][j] ? 0 : ((g[i + 1][j] + r[i][j]) % mod);

        for (int j = 1; j <= m; ++j) {
            for (int i = n, k = n; i; --i) {
                if (a[i][j])
                    k = i - 1;
                else
                    h[i][j] = (h[i + 1][j] + r[i][j] * (k - i)) % mod;
            }
        }
        
        int c = 0, f = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (a[i][j] || a[i + 1][j])
                    continue;
                (c += r[i][j] * g[i + 2][j]) %= mod;
                (f += r[i][j] * h[i + 2][j]) %= mod;
            }
        }

        printf("%lld %lld\n", c * C, f * F);
    }

    return 0;
}
```

如果觉得这篇题解写得好，请不要忘记点赞，谢谢！

---

## 作者：滑_稽 (赞：12)

[题目传送门](/problem/P8865)

又来给考场上唯一想出正解的题目写题解了，顺便给 NOIP 2023 上香。

# 解题思路

方案数题，不是组合数就是 dp，或者二者兼有之。当然这题其实就个自上而下的递推，不知道我这种做法严格意义上来说算不算动态规划，没对此深入了解过。个人理解，错了骂我。蒟蒻考场想法，大佬轻喷。

我们发现 $\texttt{F-}$ 形和 $\texttt{C-}$ 形非常相似，于是先考察如何求出 $\texttt{C-}$ 形的方案。以下为了方便，将 $\texttt{C-}$ 形和 $\texttt{F-}$ 形各部分这样称呼：

```txt
C-形
0000←顶边（长度记为U）
0↖左上端点
0↙左下端点
00000←底边（长度记为D）
↑
直边（长度记为S）

F-形
0000←顶边（长度记为U）
0
0
00000←底边（长度记为D）
0
0←下端点
↑
直边（长度记为S）
```

假设我们已经求出了前 $i-1$ 行有多少个种 $\texttt{C-}$ 形的方案即 $dpc_{i-1}$，那么第 $i$ 行的方案 $dpc_i$ 一定 $\ge dpc_{i-1}$。想一想就知道，$dpc_i$ 比 $dpc_{i-1}$ 多出来的那部分 $\texttt{C-}$ 形的底边**一定是属于第 $i$ 行的**。底边属于第 $i$ 行之前的早已被计入 $dpc_{i-1}$ 中了。那么只需统计底边属于第 $i$ 行的 $\texttt{C-}$ 形即可。

由乘法原理可知，一个 $\texttt{C-}$ 形的无土坑连通块种花的方案数为 $(U-1)\times(D-1)$。例如上面代码框里的 $\texttt{C-}$ 形总共方案数是 $(4-1)\times(5-1)=12$。可以发现，$U,D$ 均是左端点向右延伸的无土坑最大距离，所以可以预处理一个 $r_{i,j}$ 表示 $(i,j)$ 向右延伸的无土坑最大距离（**不含本身**）。

我们记 $v_{i,j}$ 表示 $(i,j)$ 上方二点是否不为土坑，那么 $v_{i,j}=1$ 是点 $(i,j)$ 能作为 $\texttt{C-}$ 形左下端点的**必要条件**。而对于第 $i$ 行的每一个点 $(i,j)$，若它能作为左下端点，其上可能会有很多个点能与第 $i$ 行构成 $\texttt{C-}$ 形的左上端点和左下端点。于是记 $c_{i,j}$ 为以 $(i,j)$ 为左下端点的 $\texttt{C-}$ 形的数量，有

$$c_{i,j}=\sum\limits_{1\le k<i,\ r_{k,j}>0}r_{k,j}\times r_{i,j}$$

考虑预处理 $\sum r_{k,j}$，记 $s_{i,j}=\begin{cases}s_{i-1,j}+r_{i,j},&a_{i,j}=0\\0,&a_{i,j}=1\end{cases}$，则 $c_{i,j}$ 的求值变为 $c_{i,j}=s_{i-2,j}\times r_{i,j}$。

对于第 $i$ 行，要把该行所有点的 $c$ 值都考虑上，有

$$dpc_i=dpc_{i-1}+\sum\limits_{1\le j\le m,\ v_{i,j}=1}c_{i,j}$$
 
于是我们愉快地得到了 $\Theta(n^2)$ 的递推式：

$$dpc_i=\begin{cases}0,&1\le i\le2\\dpc_{i-1}+\sum\limits_{1\le j\le m,v_{i,j}=1}c_{i,j},&3\le i\le n\end{cases}$$

而对于 $\texttt{F-}$ 形，我们发现，如果以某点 $(i,j)$ 作为 $\texttt{F-}$ 形的下端点，那么所有左下端点为 $(x,j)(1\le x<i)$ 且 $(x,j)$ 到 $(i,j)$ 之间都没土坑的 $\texttt{C-}$ 形都可以与 $(i,j)$ 构成 $\texttt{F-}$ 形。那么这样的 $\texttt{C-}$ 形怎么统计呢？我们想到可以给 $c$ 做一个类似 $s_{i,j}$ 的前缀和，$sumc_{i,j}=\begin{cases}sumc_{i-1,j}+c_{i,j},&v_{i,j}=1\\0,&v_{i,j}=0\end{cases}$。$sumc_{i,j}$ 即为从 $(i,j)$ 之上第一个为土坑的地方 $(x,j)$（不含）到 $(i,j)$（含），左下端点在这之间的 $\texttt{C-}$ 形数量。于是$\texttt{F-}$ 形方案

$$dpf_i=\begin{cases}0,&1\le i\le3\\dpf_{i-1}+\sum\limits_{1\le j\le m,\ a_{i,j}=0}sumc_{i-1,j},&4\le i\le n\end{cases}$$

# code

奉上屎山代码：

```cpp
#include<iostream>
#include<cstdio>
#define rep(i,x,n) for(int i=x;i<=n;i++)
#include<cstring>
using namespace std;

inline int Read(){
	int dat=0,f=1; char ch=getchar();
	while(ch<'0' || '9'<ch){ if(ch=='-') f=-f; ch=getchar(); }
	while('0'<=ch && ch<='9'){ dat=(dat<<3)+(dat<<1)+ch-'0'; ch=getchar(); }
	return dat*f;
}

void _write(int dat){
	if(dat/10) _write(dat/10);
	putchar('0'+dat%10);
}

void Write(int dat){
	if(dat<0){ putchar('-'); dat=-dat; }
	_write(dat);
}

const int maxN=1e3+5,mod=998244353;
int n,m,t,id,c,f;
long long dpc[maxN],add[maxN][maxN],ccfNB666[maxN][maxN],dpf[maxN],r[maxN][maxN],sum[maxN][maxN];
char s[maxN][maxN];
bool a[maxN][maxN],space[maxN][maxN];

int main(){
	//freopen("plant.in","r",stdin);
	//freopen("plant.out","w",stdout);
	t=Read(),id=Read();
	while(t--){
    	n=Read(),m=Read(),c=Read(),f=Read();
    	for(int i=0;i<n;i++) scanf("%s",s[i]);
    	memset(space,0,sizeof space);
    	memset(r,0,sizeof r);
    	memset(add,0,sizeof add);
    	memset(dpc,0,sizeof dpc);
    	memset(dpf,0,sizeof dpf);
    	memset(sum,0,sizeof sum);
    	memset(ccfNB666,0,sizeof ccfNB666);
    	for(int i=0;i<n;i++)
    		for(int j=0;j<m;j++)
    			a[i+1][j+1]=s[i][j]=='1' ? 1 : 0;
    	for(int cnt,j=1;j<=m;j++){//calculate space
    		cnt=0;
    		for(int i=1;i<=n;i++){
    			if(!a[i][j]){
    				cnt++;
    				if(cnt>=3) space[i][j]=1;
    			}
    			else cnt=0;
    		}
    	}
    	for(int cnt,i=1;i<=n;i++){//calculate r
    		cnt=0;
    		for(int j=m;j>=1;j--){
    			if(a[i][j]) cnt=0;
    			else{
    				r[i][j]=cnt;
    				cnt++;
    			}
    		}
    	}
    	for(int i=1;i<=n;i++){//calculate sum
    		for(int j=1;j<=m;j++){//这里的sum即为上文中的s
    			if(a[i][j]) continue;
    			sum[i][j]=(sum[i-1][j]+r[i][j])%mod;
    		}
    	}
    	for(int i=1;i<=n;i++){
    		if(i<3) continue;
    		dpc[i]=dpc[i-1];
    		for(int j=1;j<=m;j++){
    			if(!space[i][j]) continue;
    			dpc[i]=(dpc[i]+(add[i][j]=(sum[i-2][j]*r[i][j])%mod))%mod;//这里的add即为上文中的c
    		}
    	}
    	for(int i=1;i<=n;i++)
    		for(int j=1;j<=m;j++){
    			if(!space[i][j]) continue;
    			ccfNB666[i][j]=(ccfNB666[i-1][j]+add[i][j])%mod;
    		}//这里的ccfNB666即为上文中的sumc
    	for(int i=1;i<=n;i++){
    		if(i<4) continue;
    		dpf[i]=dpf[i-1];
    		for(int j=1;j<=m;j++){
    			if(a[i][j]) continue;
    			dpf[i]=(dpf[i]+ccfNB666[i-1][j])%mod;
    		}
    	}
    	Write(c*dpc[n]%mod); putchar(' '); Write(f*dpf[n]%mod); puts("");
	}
	return 0;
}
```

---

## 作者：许多 (赞：7)

作为考场上唯一做出来的题，写篇题解纪念一下。

# 思路

首先我们把矩阵进行非运算，方便处理，即：

```cpp
for(int i=1;i<=n;i++){
	char QWQ[N];
	scanf("%s",QWQ+1);
	for(int j=1;j<=m;j++)
		a[i][j]=!(int(QWQ[j]-'0'));
}
```


我们用数组 $f1$ 表示**横**向的**后**缀和，$f2$ 表示**纵**向的**后**缀和。$f3[i][j]$ 表示左上坐标为 $(i,j)$ L型有多少个（高度 $\geq3$），$f4[i][j]$ 表示左上坐标为 $(i,j)$ $\vdash$ 型有多少个（高度 $\geq3$）。

## 为什么 $f3$ 和 $f4$ 数组这样定义？

如果我们用 $f3[i][j]$ 表示左上坐标为 $(i,j)$ C型有多少个（高度 $\geq3$），$f4[i][j]$ 表示左上坐标为 $(i,j)$ F 型有多少个（高度 $\geq3$），那我们的递推式就很难表达出来。我们这样定义，在统计答案时只要处理一下即可。

### 答案统计
```cpp
void C(){
	ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(f1[i][j]>1&&f2[i][j]>2){
				long long now=f1[i][j]-1;
				ans=(ans+(now*f3[i][j]%mod))%mod;
			}
	printf("%lld ",ans*c%mod);
}
void F(){
	ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(f1[i][j]>1&&f2[i][j]>3){
				long long now=f1[i][j]-1;
				ans=(ans+(now*f4[i][j]%mod))%mod;
			}
	printf("%lld\n",ans*f%mod);
}
```
# 代码

```cpp
#include<bits/stdc++.h>
#include<cstdio>
#define N 1111
#define mod 998244353
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x*f;
}
int T,id;
int n,m,c,f;
int a[N][N],f1[N][N],f2[N][N],f3[N][N],f4[N][N];
long long ans;
void C(){
	ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(f1[i][j]>1&&f2[i][j]>2){
				long long now=f1[i][j]-1;
				ans=(ans+(now*f3[i][j]%mod))%mod;
			}
	printf("%lld ",ans*c%mod);
}
void F(){
	ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(f1[i][j]>1&&f2[i][j]>3){
				long long now=f1[i][j]-1;
				ans=(ans+(now*f4[i][j]%mod))%mod;
			}
	printf("%lld\n",ans*f%mod);
}
int main(){
	//freopen("plant.in","r",stdin);
	//freopen("plant.out","w",stdout);
	T=read();id=read();
	while(T--){
		n=read();m=read();c=read();f=read();
		for(int i=0;i<=1010;i++)
			for(int j=0;j<=1010;j++)
				f1[i][j]=f2[i][j]=f3[i][j]=f4[i][j]=0;
		for(int i=1;i<=n;i++){
			char QWQ[N];
			scanf("%s",QWQ+1);
			for(int j=1;j<=m;j++)
				a[i][j]=!(int(QWQ[j]-'0'));
		}
		for(int i=n;i>=1;i--)
			for(int j=m;j>=1;j--)
				if(a[i][j]==1)
					f1[i][j]=f1[i][j+1]+1,f2[i][j]=f2[i+1][j]+1;
					
		for(int i=n;i>=1;i--)
			for(int j=m;j>=1;j--){//注意递推式
				if(f2[i][j]>2)
					f3[i][j]=(f3[i+1][j]+f1[i+2][j]-1)%mod;
				if(f2[i][j]>3)
					f4[i][j]=(f4[i+1][j]+(f2[i+2][j]-1)*(f1[i+2][j]-1)%mod)%mod;
			}
				
		C();
		F();
	}
	return 0;
}
```


---

## 作者：Epoch_L (赞：7)

没进 noip 的场外菜鸡选手。

## Solution
可以发现 `C` 和 `F` 的相似之处在于左侧都有一条竖线，可以枚举这一条竖线，设它的上顶点向右可以拓展 $a$ 个格子，下顶点向右可以拓展 $b$ 个，下顶点向下可以拓展 $c$ 个（ `F` 可以看作 `C` 再加一条竖线得到，这里的竖线指的是 `C` 左侧的竖线）。

那么显然，该竖线对于 `C` 的贡献就是 $a\times b$，对于 `F` 的贡献就是 $a\times b\times c$。可以做到预处理 $O(n^2)$，枚举竖线 $O(n^3)$。

考虑优化，计算一个上顶点对于答案的贡献，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/k2cl0t9c.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

红色节点最多拓展到绿色节点，那么在我们枚举竖线的过程中，该上顶点对 `C` 的贡献为 $\sum a\times b_i$ 即 $a\sum b_i$，其中 $i$ 为向下能够拓展到的节点。预处理 $b_i$ 前缀和。

同理，设一个点能向下拓展 $c$ 格，枚举上顶点，对 `F` 的贡献为 $\sum a\times b_i\times c_i$ 即 $a\sum b_i\times c_i$。预处理 $b_i\times c_i$ 前缀和。

这样，就可以枚举每个点然后 $O(1)$ 计算贡献了，预处理和计算答案的复杂度均为 $O(n^2)$。

## Code
可能稍微繁琐一点，有注释。
```cpp
#include<bits/stdc++.h>
#define int long long
#define fi first
#define se second
#define pb push_back
#define mkp make_pair
using namespace std;
using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using ull=unsigned long long;
inline void read(int &x){
  char ch=getchar();
  int r=0,w=1;
  while(!isdigit(ch))w=ch=='-'?-1:1,ch=getchar();
  while(isdigit(ch))r=(r<<1)+(r<<3)+(ch^48),ch=getchar();
  x=r*w;
}
const int N=1007,mod=998244353;
int n,m,c,f,r[N][N],dn[N][N],sum[N][N],sum2[N][N];
char ok[N][N];
int getc(){
  int ans=0;
  for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
    if(dn[i][j]>=3&&ok[i][j]=='0')//至少3格
    ans=(ans+(r[i][j]-1)*(sum[i+dn[i][j]-1][j]-sum[i+1][j])%mod)%mod;//注意顶点下方的第一个没有贡献
  return ans;
}
int getf(){
  int ans=0;
  for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
    if(dn[i][j]>3&&ok[i][j]=='0')//至少4格
    ans=(ans+(r[i][j]-1)*(sum2[i+dn[i][j]-2][j]-sum2[i+1][j])%mod)%mod;
  return ans;
}
void init(){
  memset(r,0,sizeof r);memset(dn,0,sizeof dn);
  for(int i=1;i<=n;i++)for(int j=m;j>=1;j--)
    r[i][j]=ok[i][j]=='1'?0:r[i][j+1]+1;//向右最多拓展几个
  for(int j=1;j<=m;j++)for(int i=n;i>=1;i--)
    dn[i][j]=ok[i][j]=='1'?0:dn[i+1][j]+1;//向下
  //这里拓展的都包含了自己本身，所以调用时要减1
  for(int j=1;j<=m;j++)for(int i=1;i<=n;i++)sum[i][j]=sum[i-1][j]+r[i][j]-1;//前缀和
  for(int j=1;j<=m;j++)for(int i=1;i<=n;i++)sum2[i][j]=sum2[i-1][j]+(r[i][j]-1)*(dn[i][j]-1);
}
void solve(){
  read(n);read(m);read(c);read(f);
  for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>ok[i][j];
  init();
  printf("%lld %lld\n",getc()*c,getf()*f);
}
main(){
  int T,id;read(T);read(id);
  while(T--)solve();
  return 0;
}
```

---

## 作者：二叉苹果树 (赞：5)

## 题意分析

求出分别种出 ```C``` 和 ```F``` 型图案花的方案数。

首先明确怎样的 ```C``` 和 ```F``` 型图案是合法的。

仔细阅读题意和样例及其说明可知，对于每一个个合法的 ```C``` 型图案，有如下限制要求。

- ```C``` 的最上面一横和下面一横的长度不小于 $2$。
- ```C``` 左侧一竖的长度的长度不小于 $3$。

题目中已经指出：```C``` 的两横可以不一样长。

根据以上要求，不难推断出样例 #1的说明中给出的第一种 ```C``` 的构造是所有符合题意中的，种花总数最小的构造方式。

```
**
*
**
```

也就是说，对于其他的合法的 ```C``` 的构造，**至少**满足以下条件的其中之一。

- 上面一横的长度大于 $2$。
- 下面一横的长度大于 $2$。
- 左侧一竖的长度大于 $3$。

分析完合法的 ```C``` 的构造后，不难看出对于每一种合法的 ```F``` 的构造，都是在某一种合法的 ```C``` 的构造其中 ```C``` 的左侧一竖下添加若干的花构造而成的。

## 解法思路
以下用 $0$ 点代指位置上对应字符是 $0$ 的点，用 $1$ 点代指位置上对应字符是 $1$ 的点。


对于每个 $0$ 点，统计出在这个点的右边和下面还有多少个 $0$ 点。得到这些信息之后，枚举每一个 $0$ 点，计算出以这个点作为左上角的点，可以构造出的 ```C``` 和 ```F``` 的方案数即可。

直接对于每个点暴力计算的话，时间复杂度最坏情况下会来到 $\mathcal{O} \left(n^3 \right)$。加上前缀和优化后，时间复杂度变为 $\mathcal{O} \left(n^2 \right)$。

尤其要注意的是，本题的每个测试点含有**多组数据**，考虑 $0$ 点的同时，一定要把 $1$ 点统计如上两种信息的数组全部清零，否则就会因为这个原因取得个位数分数的好成绩。并且，本题的三个样例均给出 $T=1$，有的同学可能过了三个样例，并且时间复杂度正确，就会认为自己可以通过此题了。事实上，这里隐藏着本题的最大陷阱。把三个样例组合成一个 $T=3$ 的大样例再进行测试是一个不错的选择。

以上说的同学就是我自己。

## 实现步骤

对于每个 $0$ 点统计的这个点的右边和下面还有多少个 $0$ 点，可以直接枚举，并用递推的方法直接统计得出。考场上时，我把这个统计理解成这个点右边和下面第一个 $1$ 的位置，也就是第一个比 $0$ 点大的数的位置。如此，成了一个裸的只有两种数的弱化版**单调栈**的板子。

首先是前文提到的初始化。默认对于 $0$ 点的统计信息设置为边界情况，更重要的是对于 $1$ 点的统计信息**清零**。

```cpp
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			 std::cin >> ch[i][j];
			 if(ch[i][j] == '0')
			 {
			 	r[i][j] = m - j + 1;
				d[i][j] = n - i + 1;
			}
			else
			{
			 	r[i][j] = 0;
				d[i][j] = 0;
			}
		}
	}
```

接下来是用单调栈统计出我们需要的信息。将 $0$ 点的位置入栈，遇到 $1$ 点时更新栈内 $0$ 点的统计信息，用两者的位置差即可得出 $0$ 点的统计信息。

```cpp
	std::stack<int> s;
	for (int i = 1; i <= n; i++)
	{
		s = std::stack<int> ();
		for (int j = 1; j <= m; j++)
		{
		    if(ch[i][j] == '1')
		    	while (!s.empty())
		    		r[i][s.top()] = j - s.top(), s.pop();
		    if(ch[i][j] == '0')
		        s.push(j);
		}
	}

	for (int i = 1; i <= m; i++)
	{
		s = std::stack<int> ();
		for (int j = 1; j <= n; j++)
		{
		    if (ch[j][i] == '1')
		    	while (!s.empty())
		    		d[s.top()][i] = j - s.top(), s.pop();
		    if (ch[j][i] == '0')
		        s.push(j);
		}
	}
```

~~面向数据可以忽略地~~，计算出 $0$ 点的统计信息及其前缀和。对于 ```C``` 的构造方案，实际上是对于相同长度的左侧一竖的长度时，上面一横的长度从 $2$ 取到最长，下面一横的长度从 $2$ 取到最长。再将左侧一竖的长度从 $3$ 取到最长。对于 ```F``` 的构造方案，是在以上枚举左侧一竖的长度时基础上再乘以左侧多出的数的长度。

形象地说，与上面给出的代码一致，记每个 $0$ 点向左延伸的横的长度和向下延伸的数的长度分别记为 $r_{i,j}$ 和 $d_{i,j}$，枚举左侧一竖的长度为 $k$。记以点 $\left(i,j \right)$ 为左上角，左侧一竖的长度为 $k$ 时 ```C``` 的构造方案数为 $C_{i,j,k}$。有如下表达式。

$$C_{i,j,k}=\left(r_{i,j} - 1\right) \times \left(r_{k,j} - 1\right) $$

若对于点 $\left(i,j \right)$，符合条件的 $k$ 满足 $k \in \left[L,R \right]$。

$$\sum\limits_{k=L}^{R}C_{i,j,k}=\left(r_{i,j} - 1\right) \times \sum\limits_{k=L}^{R}r_{k,j}$$

很显然，这里的 $\sum\limits_{k=L}^{R}r_{k,j}$ 可以使用前缀和计算得出。

省略对于 ```F``` 的构造方案计算，基本同理，详见代码。

```cpp
	for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
            {
                sum[i][j] = sum[i - 1][j] + r[i][j] - 1;
                sum2[i][j] = (sum2[i - 1][j] + (r[i][j] - 1) * (d[i][j] - 1) % MOD) % MOD;
            }
            
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			if(r[i][j] >= 2 && d[i][j] >=3)
				{
                	C = (C + (r[i][j] - 1) * (sum[i + d[i][j] -1][j] - sum[i + 2 - 1][j])) % MOD;
                	F = (F + (r[i][j] - 1) * (sum2[i + d[i][j] - 1][j] - sum2[i + 2 - 1][j])) % MOD;
					//for(int k = i + 2; k <= i + d[i][j] - 1; k++)
					//	if(r[k][j] >= 2)
					//	{
					//		long long ans = (r[i][j] - 1) * (r[k][j] - 1) % MOD;
					//		C = (C + ans) % MOD;
					//		//printf("C ans:ch[%d][%d] = %lld\n", i, j, ans);
					//		if(d[k][j] >= 2)
					//		{
					//			F = (F + (ans * (d[k][j] - 1) % MOD)) % MOD; 
					//			//printf("F ans:ch[%d][%d] = %lld\n", i, j, ans);
					//		}
					//	}
				}
```

这部分代码中被注释掉的部分是不使用前缀和时的暴力计算方法，可以加深对前面计算公式的理解。

[完整代码](https://www.luogu.com.cn/paste/3wbsoyj3)，祝各位 $\rm{NOIP}\ \rm{RP++}$。

---

## 作者：王君诺 (赞：4)

### 前言

由于疫情反弹，北京的 NOIp 取消了。在家里做的时候，感觉这题挺有意思的，就有了这篇题解。

### 题意简述

[题目链接](https://www.luogu.com.cn/problem/P8865)

- 给定一个 01 矩阵。

- 求在这个矩阵中 `C` 和 `F` 这两种图形的数量。图形的上底和下底的间隔至少一行，并且图形覆盖范围全部是 `0` ，上底下底长度至少为 2。具体定义见题目。

- 数据范围：$1 \leq T \leq 5$ ，$1 \leq n, m \leq 10^3$。

### 题目分析

看到题目很明显是一道计数 DP，由数据范围可以推断出我们需要 $O(nm)$ 的算法。由两个图形的定义可以看出， `F` 就是在 `C` 后面加一段“尾巴”，所以对于每个 `C` 的方案乘上可以加的“尾巴”的长度，就是增加的 `F` 的方案数。

定义数组 $fx[i][j]$ 表示位于第 i 行第 j 列的元素同一**行**后没有 `1` 阻隔的 `0` 的个数，即以这个点为左端点取一行的方案数，考虑用双指针求出每一行的 $fx$ ，则可以 $O(nm)$ 预处理出 $fx$。再定义数组 $fy[i][j]$ 表示位于第 i 行第 j 列的元素同一**列**后没有 `1` 阻隔的 `0` 的个数，用同样的方法预处理。

考虑枚举图形的左上角 `(x1,y0)`，再枚举图形中间的横的左端点 `(x2,y0)`。易得出，新增 `C` 的方案数为 $fx[x1][y0] \cdot fx[x2][y1]$，新增 `F` 的方案数为 $fx[x1][y0] \cdot fx[x2][y1] \cdot fy[x2][y0]$。很显然这个算法是 $O(n^2m)$ 的，我们考虑优化。

对于每个左上角，它能产生 `C` 的方案数是：

$$\sum_{}^{} fx[x1][y0] \cdot fx[x2][y1]$$

考虑提出 $fx[x1][y0]$ :

$$fx[x1][y0] \cdot\sum_{}^{}  fx[x2][y1]$$

前缀和维护即可，对于 `F` 的方案数，维护 $\sum_{}^{}  fx[x2][y1] \cdot fy[x2][y1]$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5,Mod=998244353;
#define int long long
int a[N][N],n,m,c,f;
int fx[N][N];//第i行从第j列开始的方案数
int fy[N][N];//从第i行第j列往后数0的个数
int sum[N][N],su[N][N];
int anc,anf,T,idd;
char x;
signed main(){
	cin>>T>>idd;
	while(T--){
		scanf("%d%d%d%d",&n,&m,&c,&f);
		
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				cin>>x;
				if(x=='0'){
					a[i][j]=0;
				}else{
					a[i][j]=1;
				}
			}
		}
		if(c==0&&f==0){
			cout<<"0 0\n";
			continue;
		}
		int l,r;
		memset(fx,0,sizeof fx);
		memset(fy,0,sizeof fy);
		//预处理
		for(int i=1;i<=n;++i){
			l=r=1;
			while(l<m){
				for(;!a[i][r]&&r<=m;++r);
				//cout<<r<<endl;
				while(l<r){
					fx[i][l]=r-l-1;
					
					++l;
				}
				l+=1;
				r=l;
			}
			
		}
		for(int j=1;j<=m;++j){
			l=r=1;
			while(l<n){
				for(;!a[r][j]&&r<=n;++r);
				while(l<r){
					fy[l][j]=r-l-1;
					++l;
				}
				l+=1;
				r=l;
			}
		}
		
		anc=anf=0;
		for(int j=1;j<=m;++j){
			for(int i=1;i<=n;++i){
				sum[i][j]=sum[i-1][j]+fx[i][j];
				sum[i][j]%=Mod;
			}
		}
		for(int j=1;j<=m;++j){
			for(int i=1;i<=n;++i){
				su[i][j]=su[i-1][j]+fx[i][j]*fy[i][j];
				su[i][j]%=Mod;
			}
		}
		for(int i=1;i<n-1;++i){
			for(int j=1;j<=m;++j){
				anc+=fx[i][j]*(sum[i+fy[i][j]][j]-sum[i+1][j]);
				anc%=Mod;
				anf+=fx[i][j]*(su[i+fy[i][j]][j]-su[i+1][j]);
				anf%=Mod;
			}
		}
		
		cout<<anc*c<<" "<<anf*f<<endl;
	}
	return 0;
}
```

---

## 作者：wangyibo201026 (赞：4)

## 前提一笔

**请注意 $\LaTeX$ 对眼睛的损伤！**

## 思路

为了方便，我们设 $hang_{i, j}$ 为一个点向右最多能扩展多少个 $0$（不包含其本身）。**特殊的**，如果 $a_{i, j} = 1$ 则 $hang_{i, j} = 0$。再设 $lie_{i, j}$ 为向下最多能拓展多少个 $0$（包含其本身）。

那么对于一组 $(i, j)$ 和一组 $(k, j)$，能构成 `C` 当且仅当 $i \sim k$ 中间这一列的 $a$ 全部为 $0$，且 $k > i + 1$ ，那么构成的个数为：

$$hang_{i, j} \times hang_{k, j}$$

我们考虑对于每一组 $(i, j)$ 对答案的贡献化简为：

$$hang_{i, j} \times (hang_{i + 2, j} + hang_{i + 3, j} + ... + hang_{i + lie_{i, j} - 1, j})$$

括号里的东西显然可以前缀和维护，时间复杂度就是 $O(n^2)$。我们定义这个前缀和数组为 $sum_{i, j}$，其记录值为：

$$hang_{i, j} + hang_{i + 1, j} + ... + hang_{n, j}$$

现在我们考虑难一点的 `F`，虽然只是在 `C` 的基础上加了一个小尾巴，却难倒了作者一个小时。

还是一样，对于一组 $(i, j)$ 和一组 $(k, j)$，能够构成 `F` 当且仅当 $i \sim k$ 中间这一列的 $a$ 全部为 $0$，且 $k > i + 1$，那么构成的个数为：

$$hang_{i, j} \times hang_{k, j} \times (lie_{i, j} - k + i - 1)$$

我们又考虑对于每一组 $(i, j)$ 的答案的贡献化简为：

$$hang_{i, j} \times \left[hang_{i + 2, j} \times (lie_{i, j} - 3) + hang_{i + 3} \times (lie_{i, j} - 4) +  ... + hang_{i + lie_{i, j} - 1, j} \times 0\right]$$

我们发现这个式子好像不是普通的前缀和，那么我们再记录一个前缀和数组 $sum2_{i, j}$，其记录值为：

$$i \times hang_{i, j} + (i + 1) \times hang_{i + 1, j} + ... + n \times hang_{n, j}$$

此时我们把 $sum2_{i + lie_{i, j} - 1, j} - sum2_{i + 1, j}$ 和上面那个求 $(i, j)$ 贡献的式子相加可得：

$$(i + lie_{i, j} - 1) \times (hang_{i + 2, j} + hang_{i + 3, j} + ... hang_{i + lie_{i, j} - 1, j})$$

那么这个式子又是 $(i + lie_{i, j} - 1) \times (sum_{i + lie_{i, j} - 1, j} - sum_{i + 1, j})$，所以一组 $(i, j)$ 的 `F` 贡献就是：

$$(i + lie_{i, j} - 1) \times (sum_{i + lie_{i, j} - 1, j} - sum_{i + 1, j}) - (sum2_{i + lie_{i, j} - 1, j} - sum2_{i + 1, j})$$

所以求 `F` 的时间复杂度为 $O(n^2)$。

所以总时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$。

## 代码

Code（代码写得丑，勿喷）：

```cpp
// 100 pts
#include<bits/stdc++.h>
#define int long long    //不开 long long 见祖宗

using namespace std;

const int N = 1005;
const int mod = 998244353;

int t, id;

int n, m, c, f;
char a[N][N];
int hang[N][N], lie[N][N], sum[N][N], sum2[N][N];

signed main(){
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
	cin >> t >> id;
	while(t--){
	  memset(hang, 0, sizeof(hang));
	  memset(lie, 0, sizeof(lie));
		cin >> n >> m >> c >> f;
    for(int i = 1; i <= n; i++){
      for(int j = 1; j <= m; j++){
        cin >> a[i][j];
      }
    }
    for(int i = 1; i <= n; i++){    //O(n^2) 计算 hang
      int cnt = 0;
      for(int j = m; j >= 1; j--){
        if(a[i][j] == '1'){
          cnt = 0;
        }
        else{
          cnt++;
        }
        hang[i][j] = max(cnt - 1, (int)0);   //这里和 0 取个 max
      }
    }
    for(int j = 1; j <= m; j++){  // O(n^2) 计算 lie
      int cnt = 0;
      for(int i = n; i >= 1; i--){
        if(a[i][j] == '1'){
          cnt = 0;
        }
        else{
          cnt++;
        }
        lie[i][j] = cnt;
      }
    }
    for(int j = 1; j <= m; j++){
      for(int i = 1; i <= n; i++){
        sum[i][j] = sum[i - 1][j] + hang[i][j];
        sum2[i][j] = sum2[i - 1][j] + i * hang[i][j];
        sum[i][j] %= mod;     //这里没必要取模
        sum2[i][j] %= mod;    //取模要到位
      }
    }
    int ans = 0, ans2 = 0;
    for(int i = 1; i <= n; i++){
      for(int j = 1; j <= m; j++){
        if(i + 2 <= i + lie[i][j] - 1){
          ans += (hang[i][j] * (((sum[i + lie[i][j] - 1][j] - sum[i + 1][j]) % mod + mod) % mod)) % mod;
          ans %= mod;
          int tmp = ((sum[i + lie[i][j] - 1][j] - sum[i + 1][j]) % mod + mod) % mod;   //这里不可能有负数，因为上面的值不会超过 1e6
          int tmp2 = ((sum2[i + lie[i][j] - 1][j] - sum2[i + 1][j]) % mod + mod) % mod;   //这里是一个很大的坑，里面的值可能为负数!!!所以取模要到位
          ans2 += (hang[i][j] * ((((i + lie[i][j] - 1) * tmp - tmp2) + mod % mod) % mod)) % mod;    //用 tmp 和 tmp2 计算 (i, j) 贡献即可。
        }
      }
    }
    cout << c * ((ans % mod + mod) % mod) << " " << f * ((ans2 % mod + mod) % mod) << '\n';   //要乘上 c 和 f，要换行!!!
	}
	return 0;
}
```

## Q / A

1. 为什么里面调用了 $sum_{n + 1, j}$ 和 $sum2_{n + 1, j}$ 没有出错，因为上面判断了 $i + 2 \le i + lie_{i, j} - 1$，不会调用到 $sum_{n + 1, j}$ 和 $sum2_{n + 1, j}$。

2. 为什么 $hang_{i, j}$ 要定义为不包含，因为 `C` 和 `F` 的两条横杠长度均不能为 $1$。

---

## 作者：郑朝曦zzx (赞：3)

## 前言
由于疫情，今年北京 NOIP 取消，在家里 VP 了一下，本篇题解将会介绍我 VP 时思路的形成。

总体来说今年的 T1 比去年难一点吧，但也还好。

## 解题思路

1. 初读题目，很显然 $c = f = 0$ 的情况是送的，一分到手。

2. 发现字母 $C$ 和 $F$ 长得很像，$F$ 的那一竖要出头，考略把 $F$ 转化成 $C$ 加一竖，我们先考虑 $C$。

3. 考略朴素算法，枚举左上角的点，暴力枚举向右能延伸多少，暴力枚举向下延伸多少，再暴力枚举第二横。

4. 很显然上面的方法并不优，考略优化：

- 向右延伸真的需要每次枚举吗？ （优化 $1$）

不需要，我们可以预处理，这样就能优化掉 $O(n)$ 的时间复杂度。

```cpp
for (int i = 1; i <= n; ++i)
{
	for (int j = m - 1; j >= 1; --j)
		if (mp[i][j] == '0' && mp[i][j + 1] == '0')
			r[i][j] = r[i][j + 1] + 1;
}
```
类似于动态规划，$r_{i,j}$ 表示第 $i$ 行第 $j$ 列的格子能向右延伸多少格。从右边转移过来。

- 我们真的要枚举第二行吗，其实也不要，在 $r$ 数组上打上前缀和就可以了，又优化掉一个 $O(n)$。 （优化 $2$）

```cpp
sum[i][j] = sum[i - 1][j] + (LL)r[i][j];
```


配合前缀和，我们好要预处理每个格子最多能向下多少格，方法和优化 $1$ 相似。
```cpp
for (int i = 1; i <= m; ++i)
{
	for (int j = n - 1; j >= 1; --j)
		if (mp[j][i] == '0' && mp[j + 1][i] == '0')
			d[j][i] = d[j + 1][i] + 1;
}
```

- 这样我们优化 $C$ 的工作就基本做完了，发现 $F$ 比 $C$ 多一竖，那么我们打前缀和的时候打 $r_{i,j} \times d_{i,j}$ 就可以。

其实就是把往右边能延伸的量乘上往下能延伸的量。
```cpp
sum2[i][j] = sum2[i - 1][j] + (LL)r[i][j] * (LL)d[i][j];
```

最终时间复杂度：$O(nm)$

## 题目细节

- 多测清空，我 VP 的时候反正把题目给的几个样例拼接在一起测了一下。

- 取模，每次取模比较麻烦，我前缀和数组开的 `long long`，应该能存下数据范围才 $1000$。

- 读入效率，虽然没测，但是 $5\times10^6$ 的输入量还是挺大的，如果您不想去处理行末换行符问题，建议 `cin` + 关同步。

## 代码
最终放一下 VP 时写的完整代码，洛谷、infoj 民间数据 $100$，如果对代码的正确性有异议，欢迎随时留言。
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
typedef long long LL;
int T, n, m, id;
LL ansc, ansf, c, f;
const int mxn = 1010;
const LL mod = 998244353ll;
char mp[mxn][mxn];
int d[mxn][mxn], r[mxn][mxn];
LL sum[mxn][mxn], sum2[mxn][mxn];
void Get_d()
{
	for (int i = 1; i <= m; ++i)
	{
		for (int j = n - 1; j >= 1; --j)
			if (mp[j][i] == '0' && mp[j + 1][i] == '0')
				d[j][i] = d[j + 1][i] + 1;
	}
}
void Get_r()
{
	for (int i = 1; i <= n; ++i)
	{
		for (int j = m - 1; j >= 1; --j)
			if (mp[i][j] == '0' && mp[i][j + 1] == '0')
				r[i][j] = r[i][j + 1] + 1;
	}
	for (int j = 1; j <= m; ++j)
	{
		for (int i = 1; i <= n; ++i)
			if (mp[i][j] == '0')
			{
				sum[i][j] = sum[i - 1][j] + (LL)r[i][j];
				sum2[i][j] = sum2[i - 1][j] + (LL)r[i][j] * (LL)d[i][j];
			}
	}
}
int main()
{
	//freopen("plant4.in", "r", stdin);
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> T >> id;
	while (T--)
	{
		ansc = 0ll; ansf = 0ll;
		cin >> n >> m >> c >> f;
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				cin >> mp[i][j];
		Get_d();
		Get_r();
		for (int i = 1; i <= n; ++i)
		{
			for (int j = 1; j <= m; ++j)
			{ 
				if (mp[i][j] == '1' || d[i][j] == 0) continue;
				ansc += (sum[i + d[i][j]][j] - sum[i + 1][j]) * (LL)r[i][j];
				ansf += (sum2[i + d[i][j]][j] - sum2[i + 1][j]) * (LL)r[i][j];
			}
		}
		cout << ansc * c % mod << " " << ansf * f % mod << endl;
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				{r[i][j] = 0; d[i][j] = 0; sum[i][j] = 0ll; sum2[i][j] = 0ll; }
	}
	return 0;
}
```
## 写在最后
祝各位选手在本次 NOIP 获得理想成绩。

---

## 作者：xzy090626 (赞：3)

# [P8865 种花](https://www.luogu.com.cn/problem/P8865?contestId=93176) 题解
## 前言
作为场外选手（S 组初赛被 JS 的分数线送走了），在家里给洛谷造了一份数据。

没错那份数据很水，然后学长的代码在 infoj 上 10 分在小图灵上 45 分，然后切了我的数据/hsh

如果您的洛谷数据得分和实际得分相差太大，我对此表示歉意。
## 思路
我们看到这个题目被鲜明地分成了两个部分：求出 `C` 的个数和求出 `F` 的个数。

### 求出 `C` 的个数
我们发现 `C` 由三个部分组成：
```
1* 1 1 1
0
0
0 2 2 2
```
上面的 `0`，`1`，`2` 分别代表了每一个 `C` 的组成部分。

那么我们可以选择统计对于每一个点，如果将它作为左上角的那个点（也就是带 `*` 的那个 `1`），有多少种可能。

那么我们现在可以对每个点所贡献的方案数进行统计，而且这种方法的好处就是避免了计算的重复。

考虑一种前（后）缀和的做法：对于每个可能为左上角的点，分别统计它右边和下面的连续的不为土坑的点的数量 $a_{i,j},b_{i,j}$。

然后，对于每一列，从后往前计算 $a_{i,j}$ 的后缀和 $f_{i,j}$。

即
$$f_{i,j} = f_{i+1,j}+a_{i,j}$$
当 $(i+1,j)$ 不为土坑时。

这样，我们就能以 $O(1)$ 的时间复杂度求出每个点贡献的方案数了。

具体地，对于每个点 $(i,j)$，它的贡献为 

$$(f[i+1][j] - f[i+b[i][j]+1][j] - a[i+1][j])\times a[i][j]$$

这样讲可能过于生硬，我们拿样例作为解释。

为什么拿样例解释呢？因为只有左上角一个满足条件（

---
```
**1 **1 **1 **1
*10 *10 *10 *10
**0 *** *00 *00
000 000 **0 ***

```
我们对于左上角的这个点进行计算。

我们发现：

$a_{1,1} = 1$，即它右边连续的不为土坑的点数为 $1$。

$b_{1,1} = 3$，即它下边连续的不为土坑的点数为 $3$。

而且，$a_{2,1}=0$，$a_{3,1}=2$，$a_{4,1}=2$。

那么，$f_{1,1} = 4$。

故它对于总贡献即为 $4\times 1=4$。
### 求出 `F` 的个数
我们发现 `F` 也可以是由三个部分组成，它甚至就是平移后的 `C`。

它的贡献为
$$(f[i+1][j] - f[i+b[i][j]][j] - a[i+1][j]\times b[i+1][j]) \times a[i][j]$$


为什么呢？因为最后一列就不能算是 `F` 了，而是 `C` 了。但是后面再跟着多少个 `0` 仍然需要计入可能。

当然，计算 `F` 和 `C` 的时候都要注意去掉下一行的贡献。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e3 + 5,mod = 998244353;
int n,m,c,F;
char s[N][N];
int a[N][N],b[N][N],f[N][N];
void init(){
	memset(s,0,sizeof s);
	memset(a,0,sizeof a);
	memset(b,0,sizeof b);
	memset(f,0,sizeof f);
	cin>>n>>m>>c>>F;
	for(int i=0;i<n;++i){
		for(int j=0;j<m;++j){
			cin>>s[i][j];
		}
	}
}
void solvec(){
	for(int i=0;i<n;++i){
		for(int j=m-1;j>=0;--j){
			if(s[i][j]=='1') a[i][j] = 0;
			else a[i][j] = a[i][j+1] + 1;
		}
	}
	for(int j=0;j<m;++j){
		for(int i=n-1;i>=0;--i){
			if(s[i][j]=='1') b[i][j] = 0;
			else b[i][j] = b[i+1][j] + 1;
		}
	}
	for(int i=0;i<n;++i){
		for(int j=0;j<m;++j){
			if(a[i][j]) a[i][j]--;
			if(b[i][j]) b[i][j]--;
		}
	}
	for(int i=n-1;i>=0;--i){
		for(int j=0;j<m;++j){
			if(s[i][j]!='1') f[i][j] = f[i+1][j] + a[i][j];
			else f[i][j] = 0;
		}
	}
	int cnt = 0;
	for(int i=0;i<n;++i){
		for(int j=0;j+1<m;++j){
			cnt += (f[i+1][j] - f[i+b[i][j]+1][j] - a[i+1][j])*a[i][j];
			cnt %= mod;
		}
	}
	cout<<(cnt*c)%mod<<' ';
}
void solvef(){
	int cnt = 0;
	memset(f,0,sizeof f);
	for(int i=n-1;i>=0;--i){
		for(int j=0;j<m;++j){
			if(s[i][j]!='1') f[i][j] = f[i+1][j] + a[i][j]*b[i][j];
			f[i][j] %= mod;
		}
	}
	for(int i=0;i<n;++i){
		for(int j=0;j+1<m;++j){
			if(b[i][j]) cnt += (f[i+1][j] - f[i+b[i][j]][j] - a[i+1][j]*b[i+1][j])*a[i][j];
			cnt %= mod;
		}
	}
	cout<<(cnt*F)%mod<<'\n';
}
void solve(){
	init();
	solvec();
	solvef();
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int T,id;cin>>T>>id;
	while(T--) solve();
	return 0;
}
```
## 最后
祝大家 rp++。

---

## 作者：JuRuoOIer (赞：2)

# P8865 种花 题解

### Part1 题意

一个 $n\times m$ 的方格，其中有一些格不能种花。求在能种花的格子里种 $\texttt{C}$ 形及 $\texttt{F}$ 形的方案数。

$\texttt{C}$ 形及 $\texttt{F}$ 形的定义如下：

- $\texttt{C}$ 形要有两横一竖，其中“横”的长度不要求相等但至少是两格；“竖”的长度至少是三格。几种合法形式如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/ty4fim03.png)

- $\texttt{F}$ 形就是在合法的 $\texttt{C}$ 形的“竖”底下加一段，上图的 $\texttt{C}$ 形加长“竖（蓝色）”变成的 $\texttt{F}$ 形如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/r7kecp26.png)

### Part2 注意点

- 两种**不**合法的情况：

	- **重合型**（对于 $\texttt{C}$ 形）和站立型（对于 $\texttt{F}$ 形）：即两横重合，如图。
   ![](https://cdn.luogu.com.cn/upload/image_hosting/gdz9i6vh.png)
   
   - **缺竖型**：即两横相邻，竖的长度只有两格，如图（只做了 $\texttt{C}$ 形）。
   ![](https://cdn.luogu.com.cn/upload/image_hosting/b6ihzcyo.png)
   
- 注意本题单个测试点内有多组数据。多测不清空，爆零两行泪。同时请注意换行。

- 注意输出时先乘给定常数再取模，取完模输出。

### Part3 $\operatorname{O}(n^2m^2)$ 暴力做法

对于每一个格子，暴力找以这一格为左上角的所有可能性，一个个累加结果。时间复杂度 $O(n^2m^2)$。

- 先找这一格往右有多少格；再从这一格向下走，从它下面的**第二格**（第一格会变成上文的“缺竖型”）开始每格向右找，累计每行的格子数，最后乘开始那格往右的格数就是 $\texttt{C}$ 形的数量。$\texttt{F}$ 形还要乘上可以作为竖的格子数。样例1中前三格运行过程如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/eefi45dw.png)

### Part4 如何优化到 $\operatorname{O}(nm)$？

显然，$\operatorname{O}(n^2m^2)$ 的做法最多只有 $39$ 分。依据数据范围，可以猜出，想通过就必须要 $\operatorname{O}(nm)$。

可以发现在上面的图中，只求三个点就把最后两行的格数计算了两次。我们就不能用 $\operatorname{O}(nm)$ 的时间把每个点向右及向下到不能种花的位置/边缘预处理出来吗？

显然是可以的。从右往左、从下往上一个个计数即可。例如样例可以这么干：

![](https://cdn.luogu.com.cn/upload/image_hosting/t47gnw3r.png)

这样复杂度就变成了 $\operatorname{O}(n^2m)$。

接着考虑，为什么非要枚举左上角，每次从上往下找呢？直接枚举第二横与竖（即 $\texttt{C}$ 形左下角）的交点，就可以边枚举边计数，不需要每次都重新算上面的可能性有多少了。这样，我们的代码就变成了 $\operatorname{O}(nm)$。程序运行原理如下（格中的两个数字分别代表向右有几格和向下有几格，`all` 记录除上一行外有几种可能，`last` 记录上一行有几种可能）：

![](https://cdn.luogu.com.cn/upload/image_hosting/fc6midpm.png)

### Part5 AC代码

注释在代码里啦！

```cpp
#include<iostream>
#include<cstring>
#define ll long long
using namespace std;
ll t,id,n,m,x,y,a[1010][1010],b[1010][1010],c[1010][1010],last,all,cs,fs;
//x,y分别代表题目中的c,f
//b,c分别代表每格向下、向右有几格（含自己，注意在求解时-1）
//last,all含义见Part4最后 
int main(){
	cin>>t>>id;
	while(t--){//注意多组数据 
		cin>>n>>m>>x>>y;
		cs=fs=0;//多测不清空，爆零两行泪 
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(c,0,sizeof(c));
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				char ch;//注意它中间没有空格，需要按字符读入 
				cin>>ch;
				a[i][j]=ch-'0';
			}
		}
		for(int i=0;i<n;i++){//处理b,c数组，注意顺序及范围 
			if(a[i][m-1]==0)b[i][m-1]=1;
			for(int j=m-2;j>=0;j--){
				if(a[i][j]==0){
					b[i][j]=b[i][j+1]+1;
				}
			}
		}
		for(int j=0;j<m;j++){
			if(a[n-1][j]==0)c[n-1][j]=1;
			for(int i=n-2;i>=0;i--){
				if(a[i][j]==0){
					c[i][j]=c[i+1][j]+1;
				}
			}
		}
		for(int j=0;j<m;j++){//求解 
			last=all=0;//注意初始化 
			for(int i=0;i<n;i++){
				if(a[i][j]==1){//如果是障碍格 
					last=all=0;
					continue;
				}
				//累加，像我一样处理的注意-1！！！！！ 
				cs+=(b[i][j]-1)*all;
				fs+=(c[i][j]-1)*(b[i][j]-1)*all;
				cs%=998244353;//宁可多模千次，不可少模一次 
				fs%=998244353;
				//更新all,last 
				all+=last;
				last=b[i][j]-1;
			}
		}
		//输出，注意换行！！！！！ 
		cout<<x*cs%998244353<<' '<<y*fs%998244353<<endl;
	}
	return 0;
} 
```

---

## 作者：__vector__ (赞：2)

以此篇题解纪念我第一次参加 NOIP，并通过此题。  
## 思路  
这道题如果做过 CSP-S2022 T1，就可以想到枚举一个点，并快速求出其他点的位置。   

本题我赛时先想到了一个暴力做法，然后发现可以优化。  

所以先来说说暴力。  
## 暴力做法 1  
暴力枚举所有点的坐标，复杂度 $O(n^3m^3)$。  
## 暴力做法 2  
可以发现，做法 1 进行了大量不必要的枚举。  

以较为简单的 C 形举例。  

当左上和左下端点被枚举之后，显然，另外两个端点选择的方案数就分别是左上端点和左下端点能向右伸展的长度（即向右伸展多少个点不会遇到土坑）。  

所以可以用 $O(nm)$ 的时间预处理出每个点向右能伸展的长度，然后和做法 1 一样，枚举左上和左下端点，计算方案数。  

另外对于 F 形，做法也差不多。  

其实就是在 C 形的左下端点下方增加了一个点，只需要再用 $O(nm)$ 的时间预处理每个点能**向下**伸展的长度。  

现在复杂度 $O(n^2m)$。  

本做法同时求出来了每个点作为左下端点时的方案数（向右伸展的方案数和向下伸展的方案数），下面的做法会用到。  

## 可通过做法  
考虑怎样把枚举左下端点的复杂度也砍了。  

还是以 C 形举例，F 形类似。  

由题意可知左上端点和左下端点之间不能有土坑，也就是说左下端点只可能出现在从左上端点开始向下的一段连续区间内。  

而这段连续区间就是左上端点最长能向下伸展而不遇到土坑的区间，每个点对应的这样的一段连续区间已经在做法 2 中的预处理求出来了。  

而总方案数就是这段连续区间内每个点作为左下端点方案数的总和。  

对每列，把每个点作为左下端点的方案数做前缀和，枚举了左上端点后就能 $O(1)$ 查询左下端点的方案数总和了。  

时间复杂度 $O(nm)$。  
## 关于坑  
记录一下，大概有这些错，能过大样例：  
1. 没看见多测。  
2. 前缀和写反或者忘写（这个比较离谱，大样例精心构造能过）。  
3. 模数打错。  
4. 数组忘清空。  
5. 忘乘 c 或 f。  

## Code  
```cpp  
/*
NOIP rp++
*/
#include <bits/stdc++.h>
using namespace std;
namespace mychengxu
{
	typedef long long ll;
	const ll mod=998244353;
	const int maxn=1e3+5;
	int T,id;
	char a[maxn][maxn];
	int n,m,c,f;
	int hang_len[maxn][maxn];
    // i 行 j 列，可以向右延伸多长
	int lie_len[maxn][maxn];
    // i 行 j 列，可以向下延伸多长
	void dfs_hang(int i,int j)
	{
		if(a[i][j]=='1')return;
		hang_len[i][j]=1;
		if(j==m)return;
		dfs_hang(i,j+1);
		hang_len[i][j]=hang_len[i][j+1]+1;
	}
	void dfs_lie(int i,int j)
	{
		if(a[i][j]=='1')return;
		lie_len[i][j]=1;
		if(i==n)return;
		dfs_lie(i+1,j);
		lie_len[i][j]=lie_len[i+1][j]+1;
	}
	ll prefix_hengxiang[maxn][maxn];
    // (i,j): 第 i 列 从上到下前 j 个点作为左下端点总和 (C 形)
	ll prefix_hengxiang_calcdw[maxn][maxn];
    // (i,j): 第 i 列 从上到下前 j 个点作为左下端点总和 (F 形)

    void main()
	{
		freopen("plant.in","r",stdin);
		freopen("plant.out","w",stdout);
		scanf("%d%d",&T,&id);
		while(T--)
		{
			memset(hang_len,0,sizeof(hang_len));
			memset(lie_len,0,sizeof(lie_len));
			scanf("%d%d%d%d",&n,&m,&c,&f);
			for(int i=1;i<=n;i++)
			{
				scanf("%s",a[i]+1);
			}
			for(int i=1;i<=n;i++)
			{
				for(int j=1;j<=m;j++)
				{
					if(a[i][j]=='0')
					{
						if(!hang_len[i][j])
						{
							dfs_hang(i,j);
						}
					}
				}
			}	
			for(int j=1;j<=m;j++)
			{
				for(int i=1;i<=n;i++)
				{
					if(a[i][j]=='0')
					{
						if(!lie_len[i][j])
						{
							dfs_lie(i,j);
						}
					}		
				}
			}
			for(int i=1;i<=m;i++)
			{// 第 i 列
				for(int j=1;j<=n;j++)
				{
					prefix_hengxiang[j][i]=prefix_hengxiang[j-1][i]+(ll)(hang_len[j][i]-1);
					prefix_hengxiang[j][i]%=mod;
				}
			}
			for(int i=1;i<=m;i++)
			{// 第 i 列
				for(int j=1;j<=n;j++)
				{
					prefix_hengxiang_calcdw[j][i]=prefix_hengxiang_calcdw[j-1][i]+(ll)(hang_len[j][i]-1)*ll(lie_len[j][i]-1);
					prefix_hengxiang_calcdw[j][i]%=mod;
				}
			}
			// C
			ll ans_c=0;
			for(int i=1;i<=n;i++)
			{
				for(int j=1;j<=m;j++)
				{// 枚举左上角
					if(a[i][j]=='1')continue;
					ll col1=hang_len[i][j]-1;
					// (i,j) 向右长度
					int dwpos=i+lie_len[i][j]-1;// (i,j) 向下延伸长度
					if(dwpos<=i+1)continue;
					ll col2=(prefix_hengxiang[dwpos][j]-prefix_hengxiang[i+1][j]);
					ans_c+=col1*col2%mod;
					ans_c%=mod;
				}
			}
			// F
			ll ans_f=0;
			for(int i=1;i<=n;i++)
			{
				for(int j=1;j<=m;j++)
				{
					if(a[i][j]=='1')continue;
					ll col1=hang_len[i][j]-1;
					int dwpos=i+lie_len[i][j]-1;
					if(dwpos<=i+1)continue;
					ll col2=(prefix_hengxiang_calcdw[dwpos][j]-prefix_hengxiang_calcdw[i+1][j]);
					ans_f+=col1*col2%mod;
					ans_f%=mod;
				}
			}
			printf("%lld %lld\n",ans_c*(ll)c,ans_f*(ll)f);
		}
	}
}
int main()
{
	mychengxu::main();
	return 0;
}  
```

---

## 作者：Dregen_Yor (赞：1)

# 思路

一道魔改悬线法的题。

根据题意，`C` 和 `F` 的可以向右延伸的距离是任意的，`F` 向下延伸的距离也是任意的（只要有向下延伸的点）。

我们考虑记录每个点向右延伸的最大距离和向下延伸的最大距离，用一个数组记录下来，分别记为 $r_{i,j}$ 和 $d_{i,j}$，时间复杂度为 $\mathcal O(n^2)$。

我们考虑枚举花园中的所有的点，设当前枚举的点为 $(i,j)$。若 $(i,j)$ 和 $(i+1,j)$ 都为 $0$，则从 $k=i+2$ 处开始向下枚举 $(k,j)$，若当前点为 $1$ 则直接终止循环，否则对于 `c`，根据乘法原理，答案加上 $r_{i,j} \times r_{k,j}$，对于 `F`，答案加上 $r_{i,j} \times r_{k,j} \times d_{k,j}$。

但如果这样做，构造一组全部为 $0$ 的数据可以把时间复杂度卡到 $\mathcal O(n^3)$，这样会超时，我们不难发现，对于每一次统计答案时，$r_{i,j}$ 是不变的，根据乘法的结合律，我们可以将 $r_{i,j}$ 提出来，用一个前缀和来分别维护每个点向下的 $r_{k,j}$ 和 $r_{k,j} \times d_{k,j}$ 的和，这样预处理一遍只需要 $\mathcal O(n^2)$ 的复杂度，我们在遍历每个点，若 $(i,j)$ 和 $(i+1,j)$ 均为 $0$，则将答案加上 $(i+2,j)$ 处向下的前缀和和即可。

注意判断 $i+2$ 是否越界。

时间复杂度 $\mathcal O(n^2)$。

---

## 作者：Tsawke (赞：1)

# [P8865 [NOIP2022] 种花](https://www.luogu.com.cn/problem/P8865) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P8865-Solution)

### 题面

大概就是在有障碍的网格图里分别问能填充多少 `C` 和 `F` 形状的图形。严谨地叙述太复杂了，这里就不多叙述，直接去看 [洛谷题面](https://www.luogu.com.cn/problem/P8865?contestId=93176) 吧。

然后顺便吐槽一下，这不愧是经典的 NOIP T1，感觉和上次的报数差不多，难度有点低了，比 CSP 的 T1 T2 都要简单，可惜考试取消了没考上。

### Solution

做完之后翻了一下讨论区，似乎还有一些高妙的悬线法之类的解法，可以很简短地切掉这题。不过~~我不会~~我感觉不是很好像，所以这里提供一个思维难度极低，代码略长的做法，比较无脑，但是是妥妥的 $ O(n^2) $。

大概就是手画一下找性质，然后发现，对于 `C` 型来说，当我们固定其上下两行之后，若最左侧列从上至下都是 $ 0 $，那么这样的方案书就是上端横行向右最大延申的 $ 0 $ 乘上下端延伸的。换句话说，我们就是要枚举确定每个 `C` 的左侧的竖直的部分，然后把上下两侧可以延伸的乘起来加到方案里。

然后这东西是 $ O(n^3) $ 的，也就是枚举每个点然后再枚举竖直能延申多少。

然后我们发现这东西实际上是可以优化的，也就是说当我们确定一个竖直部分上端点所在行为 $ i $ 的时候，如果这个点竖直向下最长可以延申 $ \xi $，那么我们要的就是行数为 $ [i + 2, i + \xi] $ 之间的所有可能水平延伸的长度之和。

这样的话我们就随便做一个竖直方向上的前缀和即可优化 $ O(n^3) \longrightarrow O(n^2) $，则对于 `C` 型的就过了。

对于维护最长能延申的距离，随便写一个 `deque` 即可，也就是双端队列，里面存下标，对于每个值如果为 $ 0 $ 那么直接插进去，如果为 $ 1 $ 那么更新队列里所有的下标的值即可，具体可看代码，很好理解。

然后考虑 `F` 型，这个需要想一下，发现对于一个确定的 `C` 型，变成 `F` 型就是乘上其下端点能够延伸的距离。这个正常做还是 $ O(n^3) $ 的，优化方式也类似，类比之前的方式，维护水平延申长度的时候直接乘上竖直延申长度，然后再做个前缀和即可，具体实现可以参考代码。

Tips：有一些循环能压在一起，会让代码可读性变差这里就不压了。然后因为是 VP 也没打对拍，交上去最后两个点 WA 了，随便写了个满的数据才发现是最后加法没有取模。。。不过这种错误随便拍一下就能调出来，然后这题本身也很好调，思路非常直观，一步一步检查即可。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW(arr) void* Edge::operator new(size_t){static Edge* P = arr; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

#define MOD (ll)(998244353)

template < typename T = int >
inline T read(void);

int N, M, C, F;
bool mp[1100][1100];
int cline[1100][1100];
int srow[1100][1100];
int crow[1100][1100];
int line_x_row[1100][1100];
ll srowF[1100][1100];
ll cntC(0), cntF(0);

int main(){
    int T = read(); (void)read();
    while(T--){
        memset(mp, 0, sizeof mp);
        memset(cline, 0, sizeof cline);
        memset(srow, 0, sizeof srow);
        memset(crow, 0, sizeof crow);
        memset(line_x_row, 0, sizeof line_x_row);
        memset(srowF, 0, sizeof srowF);
        cntC = cntF = 0;
        N = read(), M = read(), C = read(), F = read();
        for(int i = 1; i <= N; ++i)
            for(int j = 1; j <= M; ++j){
                char c = getchar();
                while(c != '1' && c != '0')c = getchar();
                mp[i][j] = c - '0';
            }
        for(int i = 1; i <= N; ++i){//i = line, j - row
            deque < int > cur;
            for(int j = 1; j <= M; ++j)
                if(!mp[i][j])cur.emplace_back(j);
                else while(!cur.empty())cline[i][cur.front()] = cur.size() - 1, cur.pop_front();
            while(!cur.empty())cline[i][cur.front()] = cur.size() - 1, cur.pop_front();
        }
        // for(int i = 1; i <= N; ++i)for(int j = 1; j <= M; ++j)printf("%d%c", cline[i][j], j == M ? '\n' : ' ');
        for(int i = 1; i <= M; ++i){//i - row, j - line
            deque < int > cur;
            for(int j = 1; j <= N; ++j)
                if(!mp[j][i])cur.emplace_back(j);
                else while(!cur.empty())crow[i][cur.front()] = cur.size() - 1, cur.pop_front();
            while(!cur.empty())crow[i][cur.front()] = cur.size() - 1, cur.pop_front();
        }
        // for(int i = 1; i <= N; ++i)for(int j = 1; j <= M; ++j)printf("%d%c", crow[j][i], j == M ? '\n' : ' ');
        for(int i = 1; i <= M; ++i)//i - row, j - line
            for(int j = 1; j <= N; ++j)
                srow[i][j] = srow[i][j - 1] + cline[j][i];
        for(int i = 1; i <= M; ++i)
            for(int j = 1; j <= N; ++j)
                line_x_row[i][j] = crow[i][j] * cline[j][i] % MOD;
        for(int i = 1; i <= M; ++i)
            for(int j = 1; j <= N; ++j)
                srowF[i][j] = (srowF[i][j - 1] + line_x_row[i][j]) % MOD;
        for(int i = 1; i <= M; ++i)
            for(int j = 1; j <= N - 2; ++j){
                if(crow[i][j] < 2)continue;
                (cntC += (ll)cline[j][i] * (srow[i][j + crow[i][j]] - srow[i][j + 1]) % MOD) %= MOD;
                if(!crow[i][j + 2])continue;
                (cntF += (ll)cline[j][i] * (srowF[i][j + crow[i][j]] - srowF[i][j + 1]) % MOD) %= MOD;
            }
        printf("%lld %lld\n", cntC * C, cntF * F);
    }
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2022_11_28 初稿

---

## 作者：Moeebius (赞：1)

##  Analysis

> 此处约定先叙述列，再叙述行。

题目有点长，大体意思就是统计一张图中 $\mathtt{C}$ 和 $\mathtt{F}$ 的数目，其中两横可以不一样长，且两横间不可以相邻。

对于这种网格图求方案数的题，第一反应就是**悬线法**。

首先我们预处理出每一个位置向右能走的距离 $ri$ 和向上能走的距离 $up$。

然后我们维护两个数组 $sum1$ 和 $sum2$。

$sum1_{i,j}$ 表示位置 $(\bold{i-2},j)$ 及上方，相连所有「横」的点数之和。

$sum2_{i,j,0}$ 表示位置 $(i-1,j)$ 及上方，相连所有「横」的点数之和。

$sum2_{i,j,0}$ 表示位置 $(i-1,j)$ 及上方，相连所有**画出两条不相邻的「横」**的方案数之和。

转移：
```cpp
if(a[i][j]=='1') // 注意被障碍隔开的情况！
{
    sum1[j]=sum2[j][0]=sum2[j][1]=0;
    continue;
}
(sum2[j][1]+=(ri[i][j]-1)*sum1[j])%=mod; // 加上当前行（这一行和 sum1 中所有点绘制都合法）
sum1[j]=sum2[j][0]; // 把「缓存」的数据更新
(sum2[j][0]+=ri[i][j]-1)%=mod; // 加上当前行
```

计算：
```cpp
if(a[i][j]=='1') continue;
(Ccnt+=(ri[i][j]-1)*sum1[j])%=mod; // 画 C，使用当前行和之前的「不相邻行」
(Fcnt+=sum2[j][1])%=mod; // 画 F，直接用 sum2，当前行是 F 的一竖底部
```

## Code

```cpp

int T,id;
const ll mod=998244353;

namespace Sol
{
    static int n,m,c,f;
    static ll ri[1005][1005],up[1005][1005],sum1[1005],sum2[1005][2],Ccnt,Fcnt;
    static char a[1005][1005];
    il void solve()
    {
        memset(ri,0,sizeof(ri));
        memset(up,0,sizeof(up));
        memset(sum1,0,sizeof(sum1));
        memset(sum2,0,sizeof(sum2));
        Ccnt=Fcnt=0;

        read(n,m,c,f);
        For(i,1,n) scanf("%s",a[i]+1);
        For(i,1,n)
        {
            ForDown(j,m,1) 
            {
                if(a[i][j]=='1') ri[i][j]=up[i][j]=0;
                else ri[i][j]=ri[i][j+1]+1,up[i][j]=up[i-1][j]+1;
            }
        }
        For(i,1,n)
        {
            For(j,1,m)
            {
                if(a[i][j]=='1') continue;
                (Ccnt+=(ri[i][j]-1)*sum1[j])%=mod;
                (Fcnt+=sum2[j][1])%=mod;
                // cerr<<i<<' ' <<j<<' '<<sum1[j]<<' '<<sum2[j]<<' '<<ri[i][j]<<endl;
            }
            For(j,1,m)
            {
                if(a[i][j]=='1')
                {
                    sum1[j]=sum2[j][0]=sum2[j][1]=0;
                    continue;
                }
                (sum2[j][1]+=(ri[i][j]-1)*sum1[j])%=mod;
                sum1[j]=sum2[j][0];
                (sum2[j][0]+=ri[i][j]-1)%=mod;
            }
        }
        (Ccnt*=c)%=mod, (Fcnt*=f)%=mod;
        printf("%lld %lld\n",Ccnt,Fcnt);
    }
};

signed main()
{
    // FileIO("plant");
    read(T,id);
    while(T--)
    {
        Sol::solve();
    }
    return 0;
}
```

---

## 作者：spdarkle (赞：1)

观察数据范围，考虑 $O(nm)$ 求解，我们发现，$F$ 型就是 $C$ 型扩展，考虑先求解 $C$ 型。

因为 $C$ 型涉及到了三段 $0$，并且一个足够大的 $C$ 能够通过上下两段的收缩来得到其他的合法方案。考虑对于枚举左上角，求解出合法的 $C$。

可以这样考虑，对于每一个左上角，需要往右和往下伸展，那么不妨用 $O(nm)$ 的小DP求解出每一个点往右和往下最多伸展多少。由于这个 $C$ 要求段的长度不能小于 $2$ ,而一个 $C$ 型如果确定了竖着的一段，那么横着的那两段，设最长为 $x_1,x_2$ 那么每一段都可以从 $2$ 取到最大值构成合法的 $C$ ,总方案数就是 $(x_1-1)(x_2-1)$ ，考虑直接在这个长度减一

设 $S1_{x,y},S2_{x,y}$ 分别表示点 $(x,y)$ 向右和向下最长段的长度 $-1$ ,可以采用如下DP。
```cpp
	//预处理S1
		for(int y=1;y<=m;y++){
			for(int x=n;x;--x){
				if(a[x][y]==1)s2[x][y]=-1;
				else s2[x][y]=s2[x+1][y]+1;
			}
		}
	//预处理S2
		for(int x=1;x<=n;x++){
			for(int y=m;y;--y){
				if(a[x][y]==1)s1[x][y]=-1;
				else s1[x][y]=s1[x][y+1]+1;
			}
		} 
```

那么考虑如何才能对一个点求出所有合法的 $C$，容易想到，总方案数中的 $x_1$ 是确定的，我们可以将所有的 $x_2$ 加上，很简单，再搞一个前缀和即可，设这个前缀和为 $S3$。

接着扩展到 $F$，$F$ 本质上是对 $C$ 进行的扩展，可以求出一个 $C$ 最多向下扩展多少，这就可以求解出 $C$ 能够向下组合出 $F$ 的总方案数，可以进行维护，就是再做一个前缀和 $S4$，$S4_{x,y}$ 即为对于 $(x,y)$ 向下扩展的每一个数的 $S2,S1$ 的乘积求和，这样最终的答案即为：


$$Ans_{C}=\sum_{x=1}^n\sum_{y=1}^m[a[x,y]\neq 1][a[x+1,y]\neq 1]S1[x,y]\times S3[x+2,y]$$

$$Ans_{F}=\sum_{x=1}^n\sum_{y=1}^m[a[x,y]\neq 1][a[x+1,y]\neq 1]S1[x,y]\times S4[x+2,y]$$

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
#define N 1050
#define p 998244353
int n,m,f1,f2,a[N][N],s1[N][N],s2[N][N],s3[N][N],s4[N][N],T,id;
int main(){
	ios::sync_with_stdio(false);
	cin>>T>>id;
	while(T--){
		memset(s1,-1,sizeof s1);
		memset(s2,-1,sizeof s2);
		memset(s3,0,sizeof s3);
		memset(s4,0,sizeof s4);
		cin>>n>>m>>f1>>f2;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				char x;
				cin>>x;
				a[i][j]=x-'0';
			}
		}
	//预处理S1
		for(int y=1;y<=m;y++){
			for(int x=n;x;--x){
				if(a[x][y]==1)s2[x][y]=-1;
				else s2[x][y]=s2[x+1][y]+1;
			}
		}
	//预处理S2
		for(int x=1;x<=n;x++){
			for(int y=m;y;--y){
				if(a[x][y]==1)s1[x][y]=-1;
				else s1[x][y]=s1[x][y+1]+1;
			}
		} 
	//预处理S3
		for(int y=1;y<=m;y++){
			for(int x=n;x;--x){
				if(a[x][y]==1)s3[x][y]=0;
				else s3[x][y]=s3[x+1][y]+s1[x][y];
			}
		}
	//预处理S4
		for(int y=1;y<=m;y++){
			for(int x=n;x;--x){
				if(a[x][y]==1)s4[x][y]=0;
				else s4[x][y]=(1ll*s4[x+1][y]+1ll*s1[x][y]*s2[x][y])%p;
			}
		} 
	//
		int ans1=0,ans2=0;
		for(int x=1;x<=n-2;x++){
			for(int y=1;y<=m;y++){
				if(a[x][y]==1)continue;
				ans1=(1ll*ans1+1ll*s1[x][y]*s3[x+2][y]*(a[x+1][y]!=1)%p)%p;
				ans2=(1ll*ans2+1ll*s1[x][y]*s4[x+2][y]*(a[x+1][y]!=1)%p)%p;
			}
		}
		cout<<1ll*ans1*f1%p<<" "<<1ll*ans2*f2%p<<endl;
	}
} 
```

---


# [THUPC 2023 决赛] 总投票数

## 题目背景

各位亲爱的《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》玩家：

非常荣幸能与您携手度过了这四年的美好时光，衷心感谢大家的支持与陪伴！

现在，我们非常遗憾的宣布，《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》将于 2023 年 5 月 28 日 15:00 停止运营服务。

停止运营相关时间表如下：

……

## 题目描述

在关服前，运营发起了一系列投票，调查哪些游戏内容给玩家带来了更深的印象。

作为系列的忠实玩家，你想知道有多少人参加了关服前的投票，但是运营只公开了最终的投票结果：对于一项包含 $N$ 个选项的投票，选择第 $i$ 个选项的玩家比例为 $P_i$（$1\le i\le N$）。运营在公布结果时进行了四舍五入，所有的 $P_i$ 仅保留到小数点后第 $L$ 位。假设实际有 $K$ 位玩家参加了投票，其中有 $D_i$ 位玩家选择了第 $i$ 个选项，则应该有

$$
P_i-\frac{1}{2}\times 10^{-L}\le\frac{D_i}{K}< P_i+\frac{1}{2}\times 10^{-L}
$$

显然，所有的 $D_i$ 必须是非负整数，而 $K=\sum_{i=1}^N D_i$ 则必须是正整数。现在，给定 $N$ 和 $P_i$，请你求出满足 $D_i$ 有非负整数解的最小的总投票数 $K$。

## 说明/提示

**【样例解释 #1】**

最小的总投票数为 $6$，对应每个选项的投票数为 $1, 2, 3$。

**【样例解释 #2】**

最小的总投票数为 $73$，对应每个选项的投票数为 $3, 8, 8, 12, 22, 5, 15$。

**【样例解释 #3】**

最小的总投票数为 $7766$，对应每个选项的投票数为 $12, 301, 123, 403, 629, 530, 1216, 808, 205, 1113, 1005, 1206, 215$。

**【数据范围】**

对于所有测试数据，$1\le N\le 100$，$0\le P_i\le 1$，$\sum_{i=1}^N P_i=1$，且 $P_i$ 最多统一保留到小数点后 $6$ 位。

**【题目来源】**


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
3
0.166667
0.333333
0.500000
```

### 输出

```
6
```

## 样例 #2

### 输入

```
7
0.041096
0.109589
0.109589
0.164384
0.301370
0.068493
0.205479
```

### 输出

```
73
```

## 样例 #3

### 输入

```
13
0.00155
0.03876
0.01584
0.05189
0.08099
0.06825
0.15658
0.10404
0.02640
0.14332
0.12941
0.15529
0.02768
```

### 输出

```
7766
```

# 题解

## 作者：rui_er (赞：2)

首先，若存在 $P_i=1$，那么 $K=1$。

否则，设小数点后位数为 $L$，则有 $K\le 10^L$。这是因为任意一个 $L$ 位小数，都显然可以通过一个整数除以 $10^L$ 得到。

于是枚举分母 $k\le 10^L$，枚举每个 $P_i$，找到与其最接近的 $\frac{x_i}{k}$，判断精度是否符合要求，以及是否满足 $\sum\frac{x_i}{k}=1$ 即 $\sum x_i=k$ 的条件即可。如果满足，则 $k$ 即为所求的 $K$。

时间复杂度 $\mathcal O({10}^LN)$。

```cpp
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(ll x=(y);x<=(z);x++)
#define per(x,y,z) for(ll x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
ll randint(ll L, ll R) {
    uniform_int_distribution<ll> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

const ll N = 105;

ll n, L, val[N];
char s[N][10];

int main() {
    scanf("%lld", &n);
    rep(i, 1, n) {
        scanf("%s", s[i]+1);
        L = (ll)strlen(s[i]+1);
        if(s[i][1] == '1') return puts("1")&0;
        rep(j, 3, L) val[i] = 10 * val[i] + (s[i][j] ^ 48);
    }
    L -= 2; // "0."
    ll lim = 1;
    rep(i, 1, L) lim *= 10;
    rep(i, 2, lim) {
        ll sum = 0, ok = 1;
        rep(j, 1, n) {
            ll now = ll(round(1.0 * val[j] / lim * i));
            sum += now; // check sum to 1
            if(ll(round(1.0 * now / i * lim)) != val[j]) {ok = 0; break;} // check precision
        }
        if(sum == i && ok) return printf("%lld\n", i)&0;
    }
    return 0;
}
```

---

## 作者：I_will_AKIOI (赞：1)

数据范围非常小。$N\le100,L\le6$，所以我们用枚举做。

枚举一下 $1\sim 10^L$ 的所有数，然后判断一下是否成立。

考虑将枚举出的 $K$ 乘以 $P_i$，发现全部是整数就得到答案。但是，由于 C++ 的特性，会被卡精度。

所以我们换一种思路做。由于 $P_i$ 表示一个比例，所以 $D_i=P_i\times K$。再判断其是否符合 $P_i-\frac{1}{2}\times 10^{-L}\le\frac{D_i}{K}< P_i+\frac{1}{2}\times 10^{-L}$ 即可。

读入比较麻烦，我们需要先读入字符串获取位数。一行的长度 $-2$ 就是 $L$。然后再找到小数点，两边就分别是整数和小数了。

```
#include<bits/stdc++.h>
using namespace std;
int n,l;
double inf,a[101],f[10]={1,0.1,0.01,0.001,0.0001,0.00001,0.000001};
bool check(int k)
{
  int sum=0;
  for(int i=1;i<=n;i++)
  {
  	int w=a[i]*k+0.5;
	if(a[i]-inf>(double)w/double(k)||(double)w/double(k)>=a[i]+inf) return 0;//不符合要求，退出
	sum+=w;
  }
  return sum==k;
}
int main()
{
  cin>>n;
  for(int i=1;i<=n;i++)//读入浮点数
  {
  	string s;
  	cin>>s;
  	l=s.size()-2;
  	if(s[0]=='0') a[i]=0;
  	else a[i]=1;
  	for(int j=2;j<s.size();j++) a[i]+=f[j-1]*(s[j]-48);//枚举每一位的小数
  }
  inf=f[l]*0.5;
  for(int i=1;i<=1000000;i++) if(check(i)) {cout<<i;break;}
  return 0;
}
```

---

## 作者：ainivolAGEM (赞：0)

**前情提要：**[更好的阅读体验。](https://www.luogu.com.cn/blog/tomby-gz-2011/solution-p9380)

## 题目大意

[题目](https://www.luogu.com.cn/problem/P9380)有一个投票，选项有 $N$ 个，每人都选且只选一个，投票率四舍五入后保留到小数点第 $L$ 位。现知所有选项的投票率，求至少有多少人参与投票。

## 题目分析

根据题目可以知道，所有投票率加起来为 $1$。那么看数据范围，$1 \leq N \leq 100$，居然挺小，再看 $K$ 的值，$1 \leq K \leq 6$，都非常小，那么考虑枚举。

根据题意，本题一定有解，则说明答案必定不大于 $10^L$，因为 $10^L$ 时一定有解。

那么我们可以直接暴力枚举人数，然后枚举 $N$ 每个数据四舍五入与总人数是否都合法，如果合法则直接输出，由于人数到 $10^K$ 时一定合法，所以搜到 $10^6$ 时就直接输出 $10^6$ 即可，最大时间复杂度为 $O ( 10^L N )$。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=104;
const int K=1e6;
ll n,lng;
double x,sum,p[N];
string inp;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		cin>>p[i];
		sum+=p[i];
	}
	cin>>inp;
	p[n]=1-sum;
	lng=inp.size()-2;
	x=pow(10,-lng)/2;
	for(int i=1;i<K;i++){
		ll cnt=0;
		for(int j=1;j<=n;j++){
			ll t=(ll)(p[j]*i+(double)0.4999999);
			if(p[j]-x<=(double)t/i&&(double)t/i<p[j]+x){
				cnt+=t;
			}else{
				cnt=-1;
				break;
			}
		}
		if(cnt==i){
			cout<<cnt;
			exit(0);
		}
	}
	cout<<"1000000";
}
```

---

## 作者：船酱魔王 (赞：0)

# P9380 [THUPC 2023 决赛] 总投票数 题解

## 题意回顾

有一个投票活动，$ N $ 个选项，每人选且只选一个，投票率四舍五入保留到小数点后第 $ L $ 位。已知各选项投票率，求最少参与人数。

$ N \le 100 $，$ L \le 6 $，投票率总和为 $ 1 $。

## 分析

首先考虑数学方法数论分析，感觉不太好弄。

看到 $ N $ 为什么这么小呢？而 $ L $ 也不大，考虑暴力。

我们发现没有无解输出和保证有解的提示，想一想为什么一定有解呢？可以发现当人数为 $ 10^L $ 的时候一定是可以的，因此解不会超过 $ 10^L $。

我们暴力枚举人数，算出每个选项人数并判断四舍五入是否合法和总人数是否合法，时间复杂度是 $ O(10^LN) $ 的。

实现细节见代码。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 105;
int n;
double p[N];
int main() {
	cin >> n;
	double sum = 0;
	for(int i = 1; i < n; i++) {
		cin >> p[i];
		sum += p[i];
	}
	string s;
	cin >> s;
	p[n] = 1 - sum;
	int l = s.size() - 2;
	double d = pow(10, -l) / 2;
	for(int x = 1; x < 1e6; x++) {
		int tmp = 0;
		for(int i = 1; i <= n; i++) {
			int t1 = (int)(p[i] * x + (double)0.4999999);
			if(p[i] - d <= (double)t1 / x && (double)t1 / x < p[i] + d) {
				tmp += t1;
			} else {
				tmp = -1;
				break;
			}
		}
		if(tmp == x) {
			cout << x << endl;
			return 0;
		}
	}
	cout << 1000000 << endl;
	return 0;
}
```

## 总结与评价

小清新题，挺签到的，表白良心出题人！

---

## 作者：bobo2007 (赞：0)

## P9380  [THUPC 2023 决赛] 总投票数 题解

考场上成为了少有没有过这一题的队伍（悲）。

### 解法

观察题面中的式子，其实就是 $\frac{D_i}{K}$ 对 $10^{-L}$ 四舍五入等于 $P_i$。

由于 $1 \le L \le 6$，所以当 $K = 10^6$ 时令 $D_i = P_i \times 10^6$ 能使得 $\forall i,\frac{D_i}{K}=P_i$，而且所有 $D_i$ 都为整数。 

而这显然是满足题目中的条件的。

于是 $K_{min} \le 10^6$。

然后发现 $1 \le n \le 100$ 于是想到可以枚举答案。

先让 $A_i = P_i \times 10^L$。

假设当前答案是 $x$，要验证是否合法，设 $B_i = \frac{A_i \times x}{10^L}$，然后将 $B_i$ 四舍五入取整。

即得到了在 $K = x$ 时每个人的票数。

要判断这个票数是否合法可以判断 $\frac{B_i}{x}$ 四舍五入是否等于 $P_i$，即根据题目条件来判断。

最后还要判断 $B_i$ 之和是否等于 $x$，即每个人的票数之和等于总票数。

找到合法解输出即可。

时间复杂度 $O(N\times 10^L)$，可过。

### Code

码风有些丑请见谅。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l=0,a[110];double ex=1;
int main()
{
    scanf("%d",&n);int i,j;
    if(n==1) {printf("1");return 0;}
    for(i=1;i<=n;i++)
    {
        string s;cin>>s;
        l=s.size()-2;a[i]=s[0]-'0';
        for(j=2;j<s.size();j++) a[i]=a[i]*10.0+s[j]-'0';
    }//这里得到的l与题面上的一致
    ex=pow(10,-l);l=pow(10,l);//ex为10^-L,l为10^L
    for(i=1;i<=1000000;i++)
    {
        int ans=0;
        for(j=1;j<=n;j++)
        {
            int x=ex*a[j]*i+0.5;//四舍五入求Bi
            if((int)(((double)x/i)*l+0.5)!=a[j]) {ans=-1;break;}//判断解是否合法
            ans+=x;
        }
        if(ans==i) {printf("%d",i);return 0;}
    }
    return 0;
}
```

### 花絮

考场上把 $N$ 的范围看成 $10^5$ 了 。

由于没打出来这道题，H 题也卡题了，于是我们顺利的成为了考场倒数。

---


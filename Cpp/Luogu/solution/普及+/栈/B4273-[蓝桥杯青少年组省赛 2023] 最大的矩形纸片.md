# [蓝桥杯青少年组省赛 2023] 最大的矩形纸片

## 题目描述

一张半边参差不齐的网格纸（网格边长均为 $1$），有一边是完整没有破损的。现要从中剪出一片面积最大的矩形纸片。

给定网格纸中完整边的长度 $N$（$1 \leq N \leq 1\,000\,000$），以及网格中每一列残存部分的高度（$1 \leq$ 高度 $\leq 10\,000$），输出能够剪出的最大矩形纸片面积。

## 样例 #1

### 输入

```
6
3 2 1 4 5 2```

### 输出

```
8```

# 题解

## 作者：raincs (赞：5)

# **解题过程**
先读题，给定 $n$ 个宽为 $1$ 的矩形，每个矩形的高各不相同。将它们拼在一起，要求在从中剪出一块最大的矩形纸片。  
我们很自然可以想到枚举左右起始位置，在枚举中间的位置来计算当前区间内的最大矩形长度，再来更新答案。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int h[1000001];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
	}
	int maxn=0;
	for(int i=1;i<=n;i++){
		int m=1e9+1;
		for(int j=i;j<=n;j++){
			for(int k=i;k<=j;k++){
				m=min(m,h[k]);
			} 
			maxn=max(maxn,m*(j-i+1));
		}
	}
	cout<<maxn<<endl;
	return 0;
}
```
结果……$30$ 分  
我们可以发现该解法的时间复杂度为 $O(n^3 )$。 
所以我们得换一种方法来写。
我们可以先假设矩形长度递增，那么我们该如何做？  
很显然，我们可以尝试将当前的矩形的高度作为最后矩形的高度，并将该矩形的宽一直延伸到右边界，再算出矩形的面积用来更新答案。  
所以我们看回这道题，我们可以利用上面的结论，如果下一个矩形的高度比上一个小，那么该矩形想与前面的矩形拼成一个更大的矩形，那么之前的矩形高于当前矩形的面积就没有任何用处了(如下图中打叉的部分)。  
![](https://cdn.luogu.com.cn/upload/image_hosting/2jt88bp6.png)  

所以我们就可以用到一种算法来解决这种问题————**单调栈**。  
我们只需要建立一个栈，用来维护一个高度始终单调的序列，这样我们就可以解决这个问题了。  
我们先从左到右依次扫描每个矩形，如果当前的矩形高度高于栈顶矩形，就让其进栈；否则就不断取出栈顶，直至栈为空或栈顶矩形的高度比当前矩形小。出栈过程中我们累加弹出矩形的宽度，并且在每次弹出时，就用其高度乘以累加的宽度去更新答案。出栈结束后，我们再把一个高度为当前矩形高度、宽度为累加值的矩形入栈。注意，结束后，要将栈中剩下的矩形依次弹出，采用上面相同的方法来更新答案。所以我们可以增加一个高度为 $0$ 的矩形，避免再扫描结束后有剩余矩形。

# **AC_code**  
数组模拟
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[1000001];
int s[1000001];
int w[1000001];
int n;
signed main(){
	int p=0,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]; 
	a[n+1]=0; 
	for(int i=1;i<=n+1;i++){
		if(a[i]>s[p]){
			s[++p]=a[i];
			w[p]=1;
		}
		else{
			int width=0;
			while(s[p]>a[i]){
				width+=w[p];
				ans=max(ans,(long long)width*s[p]);
				p--;
			}
			s[++p]=a[i];
			w[p]=width+1;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
STL
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int h,w;
};
stack<node>s;
long long a[1000001];
long long ans=0;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	a[n+1]=0;
	for(int i=1;i<=n+1;i++){
		long long width=0;
		while(!s.empty() && a[i]<s.top().h){//单调递增
			width=width+s.top().w;
			ans=max(ans,width*s.top().h);
			s.pop();
		}
		s.push( (node){a[i],width+1} );
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：wangxiaochai (赞：4)

这道题的算法标签是单调栈，那就提供一种用单调栈的解法吧。

核心思路：用一个栈来维护单调不下降序列。如果新来的元素大于等于栈顶，那么加入栈，成为新的栈顶。否则，就持续推出栈顶，直到新来的元素可以成为单调不下降的栈顶。再每次推出栈顶的时候，计算一下这个以这个元素为高可以围成的矩形面积，并且维护这个最大值。

在每次执行弹出操作的时候，都需要检查栈是否为空，否则会 runtime error。为了防止对空栈进行弹出操作，也可以先压入一个值为 $0$ 的元素作为哨兵。按照本题的题意，所有高度都是 $1≤ 正整数 ≤10000$ 的，这个压箱底的元素 $0$ 会一直在栈底沉着，起到防止操作空栈的作用。

每次需要弹出栈顶时，以栈顶元素为高度，以栈顶元素与栈内下一个元素之间的距离为宽度，计算矩形面积，并维护最大值。
```cpp
    stack<int> s;
    s.push(0);
    for (int i = 1; i <= n; ++i) 
    {
        while (a[i] < a[s.top()]) 
        {
            long long h = a[s.top()];
            s.pop();
            long long w = i - s.top()-1;
            MAX = max(MAX, h * w);
        }
        s.push(i);
    }
```
需要注意的是，在整个循环结束的时候，栈内可能还有元素。举个极端的例子，假如整个序列是单调上升的，那么在上述循环中，将只会有压栈，没有出栈，没有计算过任何一次面积。

接下来要对栈内剩余元素进行一次处理。

```cpp
    while (s.top()!=0)
    {
        long long h = a[s.top()];
        s.pop();
        int w = n - s.top();
        MAX = max(MAX, h*w);
    }
```
这里有个概念：隐式右边界。在循环结束之后，第 $n$ 个元素肯定在栈内，并且是栈顶，因为没有元素可以弹出它。那么处理栈内剩余元素时，每次右边界都是 $n$。

在处理这些元素时，高度仍然是栈顶，宽度是栈内第二个元素到 $n$ 的距离。

最后输出即可。

---

## 作者：_Deer_Peach_ (赞：3)

多倍经验。

很模板的单调栈题目，只需要前后各做一遍单调栈即可。以每一列作为标准，分别找前面和后面高度小于它的再求面积即可。可以证明，这样剪出来的矩形一定是以这一列为高能够减出的最大矩形。那么只需要遍历每一列就可以了。

代码：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=1e6+5;
int n;
int h[N];
int l[N],r[N];
signed main(){
	IOS;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
	}
	stack<int>s,ss;
	for(int i=1;i<=n;i++){
		while(!s.empty()&&h[s.top()]>h[i])r[s.top()]=i,s.pop();
		s.push(i);
	}
	for(int i=n;i>=1;i--){
		while(!ss.empty()&&h[ss.top()]>h[i])l[ss.top()]=i,ss.pop();
		ss.push(i);
	}
	int res=0;
	for(int i=1;i<=n;i++){
		int L=(l[i]==0?1:l[i]+1),R=(r[i]==0?n:r[i]-1);
		res=max(res,(R-L+1)*h[i]);
	}
	cout<<res;
	return 0;
}

```

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

考虑暴力，枚举高度 $h_i$，对于每个高度再去枚举其最大宽度，即往左以及往右最远能扩展多远，时间复杂度 $O(n^2)$。

往左最远能扩展多远相当于找左侧第一个小于 $h_i$ 的高度 $h_j$，那么我们可以使用单调栈进行求解，右侧同理，时间复杂度 $O(n)$。

### AC_Code

```cpp
#include <iostream>
#include <stack>

using namespace std;

typedef long long LL;

const int N = 1e6 + 10;

int n;
int a[N];
int l[N], r[N];

void get_left()
{
    stack<int> stk;
    stk.push(0);
    
    for (int i = 1; i <= n; ++ i )
    {
        while (stk.size() && a[i] <= a[stk.top()])
            stk.pop();
        l[i] = stk.top();
        stk.push(i);
    }
}

void get_right()
{
    stack<int> stk;
    stk.push(n + 1);

    for (int i = n; i; -- i )
    {
        while (stk.size() && a[i] <= a[stk.top()])
            stk.pop();
        r[i] = stk.top();
        stk.push(i);
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n;
    for (int i = 1; i <= n; ++ i )
        cin >> a[i];

    get_left();
    get_right();

    LL res = 0;
    for (int i = 1; i <= n; ++ i )
        res = max(res, (LL)(r[i] - l[i] - 1) * a[i]);

    cout << res << endl;
    
    return 0;
}
```

---

## 作者：guoshengyu1231 (赞：1)

# 前言
由于这是一道绿题，所以还是挺有难度的。虽然这道题用到的算法比较简单，但这里我还是写得详细些。
# 题意分析
给定 $n$ 个宽为 $1$ 的矩行，每个矩形的高各不相同。将他们拼起来，要求在从中剪出一块最大的矩形纸片。
1. **输入要求‌：** 网格完整边长度 $N$（最多 $10^6$ 列），每列高度范围 $1$ 到 $10^4$。
2. **输出目标‌：** 找出能剪出的最大矩形面积（面积 $=$ 宽度 $\times$ 最小高度）。
3. **示例说明‌：** 当输入为 $6$ 列高度 $[3,2,1,4,5,2]$ 时，最大面积为 $8$（高 $2$ $\times$ 宽 $4$）。
# 算法思路
考虑到 $1\le N\le 10^6$，所以应该不是动态规划啥的。他应该是要一种线性时间复杂度的算法。这样大部分的高级数据结构也应该是不可能了，那就只有一些线性数据结构可能可以做了。接下来我们就需要考虑如何将这个问题**转化**一下，因为直接枚举矩形显然是不可能的。考虑到面积 $=$ 宽度 $\times$ 最小高度，那么我们可以枚举每一个矩形，然后我们以这个矩形的高为公式中的最小高度，然后我们再计算出以这个矩形为最小高度能剪出的最长宽度。这里可能讲得比较抽象，所以还是给个图理解一下吧。

![](https://cdn.luogu.com.cn/upload/image_hosting/i7iaznh3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可以看到，对于红色的矩形，以他的高度为最低高度可剪出的最大矩形用蓝色边框标记。可以看到，用蓝色箭头指出的两个矩形分别为从红色矩形开始往左和右第一个高度比红色矩形低的矩形。那这样子就可以轻易算出这个矩形的宽了。
 $\\$ 

但是现在问题又来了，那我们该如何快速计算出每个矩形开始从左或右第一个高度比这个矩形高或低的矩形呢？这里，我们需要用到一种非常常用的数据结构：**单调栈**。
## 什么是单调栈？
单调栈，顾名思义就是呈单调性的栈，具体的来讲应该是内部元素呈单调性的栈。也就是栈内元素都是有序的，要么从小到大，要么从大到小。
## 单调栈有什么用处？
单调栈看上去就就是一个普普通通的栈，只是栈内元素有序而已。但是，我们可以通过维护单调栈来做的其他数据结构做不到的事。 $\\$ 
单调栈最常用的用法那就是来再一个序列中以 $O(n)$ 的时间复杂度来计算**每个**数的前面第一个比他大或小的数，就像这一题。
## 单调栈是如何运行的？
以求每个数从左往右第一个比他小的数为例。因为是第一个比他小的数，所以我们的单调栈的内部元素需要是从顶到底单调递减的，反之则为单调递增的。为什么这么说呢？首先，我们维护这个栈的单调性肯定是为了计算方便，那既然是要求去求第一个比他小的数，那肯定是让最大的数放到栈顶，这样如果新来的数比栈顶元素大，那他肯定也比剩下的元素都大，所以也就不用枚举了。 $\\$ 
说了那么多，现在我来讲一下单调栈是如何运行的。 $\\$ 
假设此时栈顶元素**的下标**为 $top$，此时正枚举到第 $i$ 个数。现在进行以下操作：
-  如果栈不空并且 $a_i<a_{top}$，此时记录第 $top$ 个数的答案为 $i$，接着弹出栈顶元素并重复此过程。
-  否则将 $i$ 弹入栈中，因为此时站内所有元素都是比 $a_i$ 小的，所以正好维护了栈的单调性。
  
示例代码：
```cpp
//栈内元素均为下标
stack<int> st;
for(int i=1;i<=n+1;i++)
 {
    while(!st.empty()&&a[i]<a[st.top()])
     {
        ans[st.top()]=i;
        st.pop();
     }
    st.push(i);
 }
```
# 具体实现
由于本题需要计算两个下标，因此需要跑两遍单调栈，很明显，最终答案 $ans=\max\{(r_i-l_i-1)*a_i\}$，遍历 $i$ 即可。
# 参考代码
这里需要注意一点，由于 $n\times a_i$ 最大为 $10^6\times10^4=10^{10}$，所以一定要开`long long`! 
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e6+5;
int l[maxn],r[maxn];
int n,a[maxn],ans;
stack<int> st;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n+1;i++)
	 {
	 	while(!st.empty()&&a[i]<a[st.top()])
	 	 {
	 	 	r[st.top()]=i;
	 	 	st.pop();
		 }
		st.push(i);
	 }
	for(int i=n;i>=0;i--)
	 {
	 	while(!st.empty()&&a[i]<a[st.top()])
	 	 {
	 	 	l[st.top()]=i;
	 	 	st.pop();
		 }
		st.push(i);
	 }
	for(int i=1;i<=n;i++) ans=max(ans,(r[i]-l[i]-1)*a[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：meifan666 (赞：1)

### 题目大意
在一张半边参差不齐的网格纸中，剪出最大的矩形纸片，并求出它的面积。
### 思路
若要一个区间内剪一个最大的矩形，则它的高一定受这个区间中的某一高度的限制（因为它的高不能大于这一区间的任意高度，即不大于这个区间的最小高度）。相反地，若剪一个矩形时用到了某一列，那么这个矩形的高就不能大于这一列的高。

于是我们想到枚举每一列，计算若用到这列格子，矩形的高度为多少。方法就是以这列格子的高度为基准，看它向左向右最多能扩展几个，并将总的个数乘上它的高度，就是最大矩形面积。判断向某一方向能否扩展，就是看这个方向的某一列的高度是否大于这个基准。

若朴素的这样判断，则时间复杂度为
$O(n^2)$，不可接受。于是我们采用**单调栈**优化，快速找到每列往左第一个高度小于它的列的下标，往右也一样，这样就可以在
$O(n)$
的时间复杂度求解了。

下面贴上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[1000100],ans;
int l[1000100],r[1000100];
deque<int>p;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		l[i]=1,r[i]=n;
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		while(!p.empty()&&a[p.back()]>=a[i])p.pop_back();
		if(!p.empty())l[i]=p.back()+1;
		p.push_back(i);
	}
	p.clear();
	for(int i=n;i>=1;i--){
		while(!p.empty()&&a[p.back()]>=a[i])p.pop_back();
		if(!p.empty())r[i]=p.back()-1;
		p.push_back(i);
	}
	for(int i=1;i<=n;i++)
		ans=max(ans,(r[i]-l[i]+1)*a[i]);
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：huxuanrui19 (赞：1)

# B4273题解

题目传送门 [点击此处](https://www.luogu.com.cn/problem/B4273)

## 题目描述
现要从一张半边参差不齐的网格纸（网格边长均为 $1$）中剪出一片面积最大的矩形纸片。

给出网格纸中完整边的长度 $\text{N}$（$1 \le N \le 1\times10^{6}$），网格中每一列残存部分的高度（$1 \le \text{高度} \le 1\times10^{5}$），输出能够剪出的最大矩形纸片面积。

## 思路
注意到 $N\le1\times10^{6}$，所以 $O(n^{2})$ 的时间复杂度是一定会 TLE。

我们将高度记为 $h[i]$，

观察可发现，对于每一个以位置为 $i$ 的高度来画一个最大的矩形，应该找到位置为 $i$ 的两边第一个比他小的位置，记为$pre[i]$ 和 $next[i]$,则面积 $area=(next[i]-pre[i]-1)\times h[i]$。

没理解的见此图
![](https://cdn.luogu.com.cn/upload/image_hosting/gj41gock.png)

对于 $pre[i]$ 和 $next[i]$ 的维护，我们考虑单调栈（[初学者见此](https://www.luogu.com.cn/problem/P5788)），分别顺序和倒序遍历一次。这样便可以在 $O(n)$ 的时间复杂度实现。

正序如下：

## 部分代码
```cpp
st.push(1);
pre[1]=0;
for(int i=2;i<=n;i++){	 
    while(!st.empty()&&h[st.top()]>=h[i]){
	st.pop();
    }
    pre[i]=st.empty()?0:st.top();
    st.push(i);
}
```
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int h[int(1e6+10)],pre[int(1e6+10)],_next[int(1e6+10)];
stack<ll> st;
ll maxn=-1;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
	}
	st.push(1);
	pre[1]=0;
	for(int i=2;i<=n;i++){
		while(!st.empty()&&h[st.top()]>=h[i]){
			st.pop();
		}
		pre[i]=st.empty()?0:st.top();
		st.push(i);
	}
	while(!st.empty()){
		st.pop();
	}
	st.push(n);
	_next[n]=n+1;
	for(int i=n-1;i>=1;i--){
		while(!st.empty()&&h[st.top()]>=h[i]){
			st.pop();
		}
		_next[i]=st.empty()?n+1:st.top();
		st.push(i);
	}
	for(int i=1;i<=n;i++){
		maxn=max(maxn,1ll*(_next[i]-1-pre[i])*h[i]);
	}
	cout<<maxn;
	return 0;
}
```

如果有帮助的话就点个赞吧，

谢谢阅读。

---

## 作者：superLouis (赞：1)

## 题解：B4273 [蓝桥杯青少年组省赛 2023] 最大的矩形纸片

这题一眼就是单调栈嘛。

----------
### 1. 解题思路

老规矩，我们先来算算样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/3jkb1sxu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

样例输出是 `8`，也就是第 $4$ 到第 $5$ 列，高为 $4$ 的矩形，面积是 $8$。

题目要求的就是上面这种图（下边固定）中最大矩形的面积。那我们思考一下，矩形面积是由一个底面长度乘上高所得来的。

解题的思路就是不妨固定一个高，求这个高的最长底面长度。具体一点，就是对于每一个竖列（假设高度是 $h$），算出第一个比它靠右并且低于它高度的（我们不妨设是第 $r$ 列）和第一个比它靠左并且低于它高度的（设为第 $l$ 列），求出所有竖列中 $h \times [(r - 1) - (l + 1) + 1]$ 的最大值，也就是每个竖列 $h \times (r - l - 1)$ 的最大值。

再思考一下，怎样算出第一个比它靠右并且低于它高度的和第一个比它靠左并且低于它高度的？

其实这就是单调栈解决的基本问题啦，不懂的可以去看看 [【模板】单调栈](https://www.luogu.com.cn/problem/P5788)，这里的问题就是现在解决的问题。只是这里需要两个单调栈维护（不是求左边的和右边，一共两个方向嘛）即可了。

----------
### 2. 时间复杂度

对于单调栈，也就是预处理部分，每个元素都只进出栈一次，$O(n)$ 时间复杂度（其实是自带二倍常数的，因为有两个单调栈）。

对于处理的部分，$O(1)$ 查询第一个比它靠右并且低于它高度的和第一个比它靠左并且低于它高度的，一共遍历 $n$ 次，总共时间复杂度 $O(n)$。

最后这个思路时间复杂度 $O(n)$，最优秀的时间复杂度啦。

----------
### 3. 代码实现

就知道你们最想要这个。。。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 1e6 + 10;
int n, a[maxn], l[maxn], r[maxn]; 
ll ans;
struct node { int idx, num; };
stack<node> lstk, rstk;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        while (lstk.size() && lstk.top().num > a[i]) {
            l[lstk.top().idx] = i;
            lstk.pop();
        }
        lstk.push(node({i, a[i]}));
    }
    for (int i = n; i >= 1; i--) {
        while (rstk.size() && rstk.top().num > a[i]) {
            r[rstk.top().idx] = i;
            rstk.pop();
        }
        rstk.push(node({i, a[i]}));
    }
    for (int i = 1; i <= n; i++) if (l[i] == 0) l[i] = n + 1;
    for (int i = 1; i <= n; i++) ans = max(ans, (ll)(l[i] - r[i] - 1) * (ll)a[i]);
    cout << ans << "\n";
    return 0;
}
```

自认为码风良好。（我是不是太自恋了？？？）

[通过记录（不要质疑我～）](https://www.luogu.com.cn/record/211624491)

---

## 作者：YBa2Cu3O7 (赞：1)

约定输入数据的长度为 `n`，存储在数组 `vector<long long> nums` 中。

首先，面积最大矩形的高度一定是 `nums` 中的元素，否则可以直接“拔高”它到最近的 `nums[i]`。

固定下标 `i`，对于高为 `nums[i]` 的矩形，我们想要让它面积最大化，就是要找左右两侧第一个高度小于 `nums[i]` 的 `nums[j]` 和 `nums[k]`，其中 $j\le i\le k$。如果左侧的值均大于，则令 `j = -1`，右侧也是类似地令 `k = n`。此时这个最大矩形的面积就是 `nums[i] * (k - j - 1)`。

通过上面分析，问题转化为，对于每个下标 `i`，求它左右两侧第一个小于 `nums[i]` 的下标。这个问题可以通过**单调栈**来解决。

用一个栈 `stk` 存储下标，从左侧开始遍历，对于每个下标 `i`，检查栈顶下标 `j = stk.top()` 对应的值 `nums[j]` 是否大于等于当前值 `nums[i]`，持续出栈直到小于或栈空，此时栈顶下标对应的就是左侧第一个小于的下标，栈空说明左侧均大于等于，记录为 `-1`。右侧也同理，只需要从右侧开始遍历一遍。

两次遍历找最近小于的下标，再一次遍历找最大面积，时间复杂度 $O(n)$。


```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int n;
	cin >> n;
	vector<long long> nums(n);
	for (int i = 0; i < n; ++i) {
		cin >> nums[i];
	}
    
	vector<long long> l(n, -1);
	vector<long long> r(n, n);
	stack<long long> stk;
	for (int i = 0; i < n; ++i) {
		while (!stk.empty() && nums[stk.top()] >= nums[i]) {
			stk.pop();
		}
		if (!stk.empty()) l[i] = stk.top();
		stk.push(i);
	}
	stk = stack<long long>();//置空
	for (int i = n - 1; i >= 0; --i) {
		while (!stk.empty() && nums[stk.top()] >= nums[i]) {
			stk.pop();
		}
	    if (!stk.empty()) r[i] = stk.top();
		stk.push(i);
	}
    
	long long ans = 0;
	for (int i = 0; i < n; ++i) {
		ans = max(ans, nums[i] * (r[i] - l[i] - 1));
	}
	cout << ans;
}
```

---

## 作者：xinxin2022 (赞：1)

显然，我们需要在相同的区间内使所取高度尽可能高，因此答案的高一定为某一个 $a_i$。

那么考虑设 $p_i$ 为高度取 $a_i$ 且区间包含 $i$ 时的最大矩形。

不妨记 $i$ 之前最远能扩展到的连续的高 $\ge a_i$ 的点为 $l$，$i$ 之后最远能扩展到的连续的高 $\ge a_i$ 的点为 $r$，那么有 $p_i=a_i(i-l+1)+a_i(r-i)$。

那么考虑令 $i$ 前和 $i$ 后分别计算贡献。

对于 $i$ 前，可以维护一个递增单调栈，当栈顶高大于等于 $a_i$ 时说明 $l$ 可扩展至栈顶元素位置，否则此时栈顶元素位置 $+1$ 即为 $l$。

同理，$i$ 之后的贡献相当于反向做单调栈，只令循环方向改变即可。

时间复杂度显然为 $O(n)$，常数较大但足以应对 $10^6$。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans,a[1000005],minn,cnt;
stack<long long> st;
long long val[1000005];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    st.push(0);
    for(int i=1;i<=n;i++){
        while(a[i]<=a[st.top()]) st.pop();
        val[i]=(i-st.top())*a[i];
        st.push(i);
        //前半部分贡献
    }
    while(!st.empty()) st.pop();
    st.push(n+1);
    for(int i=n;i;i--){
        while(a[i]<=a[st.top()]) st.pop();
        val[i]+=(st.top()-i-1)*a[i];
        st.push(i);
        //后半部分贡献
        ans=max(ans,val[i]);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Ag2WO4 (赞：1)

使用单调栈记录某高度 $h$ 及其开始点和最低点（后面的数更高也不能越过最低点），后面的数若更低则删除该高度连续段并统计块大小，否则将其数据压入栈，最终得到结果。复杂度 $O(n)$。

```python
input();i=j=0;a=[[0,0,0]]
for b in map(int,input().split()):
    i+=1
    while a[-1][0]>b:j=max(j,a[-1][0]*(i-a[-1][1]));a.pop()
    a.append([b,a[-1][2]+1,i])
print(max(j,*(k[0]*(i+1-k[1])for k in a)))
```

---

## 作者：yyycj (赞：0)

## 形式化题意
给定长度为 $n$（$1\le n \le 10^{6}$）的序列 $a$（$1\le a_{i} \le 10^{4}$），求一段连续子序列中的最小值乘长度的最大值。

## 主要思路
考虑二分。我们可以枚举每个 $a_{i}$ 作为一段连续子序列的最小值，为了保证最小值乘长度最大，这段连续子序列的左边界就应该是从 $a_{i}$ 开始使 $i$ 不断减 $1$ 第一个**小于** $a_{i}$ 的数的下标加 $1$；右边界就应该是从 $a_{i}$ 开始使 $i$ 不断加 $1$ 第一个**小于** $a_{i}$ 的数的下标减 $1$。

要求这两个数，可以将所有小于 $a_{i}$ 的数的下标统一放在一个 `set`，这样就可以形成有序，就可以二分求两个边界了。

### 时间复杂度
$O(n\log n)$

### 注意事项
1. $n\times a$ 最大为 $10^{10}$，所以十年 OI 一场空，_____________________。

## AC Code
```cpp
#include<map>
#include<set>
#include<stack>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

#define gc getchar
#define pc putchar
typedef long long ll;
typedef long double db;
const int N = 1e6 + 10;
const int INT_INF = 0x3f3f3f3f;
const ll LL_INF = 0x3f3f3f3f3f3f3f3f;
// ----------------------------

// ----------------------------
set<ll> st;
pair<ll, ll> h[N];
// ----------------------------


int main() {
	ll n; cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> h[i].first;
		h[i].second = i;
	}
	// ----------------------------
	ll idx, ans = 0;
	sort(h + 1, h + n + 1);  // 保证在求 ai 时 set 存的下标对应的数都小于 ai
	for (int i = 1; i <= n; i++) {
		idx = h[i].second;
		if (i == 1) ans = max(ans, h[i].first * n);
		else {
			auto l = st.upper_bound(idx);
			auto r = st.upper_bound(idx);
			if (l == st.begin()) ans = max(ans, h[i].first * (*r - 1));  // 如果没有比 ai 小的数，边界为 1
			else if (r == st.end()) {  // 如果没有比 ai 大的数，边界为 n
				l--;
				ans = max(ans, h[i].first * (n - *l));
			}
			else {
				l--;
				ans = max(ans, h[i].first * (*r - *l - 1));
			}
			
		}
		st.insert(idx);
	}
	// ----------------------------
	cout << ans;
	return 0;
}
```

---


# [UESTCPC 2024] 饮料

## 题目描述

有一个果汁机，每分钟可以制作一杯任意体积的果汁。

有 $n$ 个人排成一队。第 $i$ 个人将在第 $t_i$ 分钟走到果汁机前，并拿走当前已经制作的果汁中体积最大的一杯。第 $i$ 个人拿到体积大于等于 $a_i$ 的果汁就会满意。如果此时没有果汁，则第 $i$ 个人也会不满意。

问是否能够让所有人满意。如果是，输出让所有人满意所需的果汁体积之和的最小值。

## 说明/提示

样例一解释如下：

| 时间 | 制作 | 取走 |
| :----------: | :----------: | :----------: |
| $1$ | $3$ | $3$ |
| $2$ | $-$ | $-$ |
| $3$ | $8$ | $8$ |
| $4$ | $2$ | $2$ |
| $5$ | $4$ | $-$ |
| $6$ | $7$ | $7,4$ |

样例二解释如下：

| 时间 | 制作 | 取走 |
| :----------: | :----------: | :----------: |
| $1$ | $3$ | $3$ |
| $2$ | $4$ | $-$ |
| $3$ | $8$ | $8$ |
| $4$ | $4$ | $4$ |
| $5$ | $7$ | $7,4$ |
| $6$ | $-$ | $-$ |

## 样例 #1

### 输入

```
5
1 3 4 6 6
3 8 2 7 4```

### 输出

```
24```

## 样例 #2

### 输入

```
5
1 3 4 5 5
3 8 2 7 4```

### 输出

```
26```

# 题解

## 作者：sccc_ (赞：19)

## Solution

一道单调栈题。

### 贪心原则：

饮品能当时做就当时做，不能就提前做。

### 无解情况：
当任意时间 $i$ 我们需要做 $\geq i$ 数量的饮品，那就不成立。

***

如果有多个重复的时间，我们分类。

- 如果单调栈顶元素 $\geq$ 当前元素，我们当然要加上栈顶元素，否则顾客就会选择栈里的元素，条件不成立。
  
- 否则，我们不能加上栈里元素，需要加上当前元素，否则顾客就不满意了。

否则，我们就去制作在栈里的元素，再判断刚刚需要判断的操作。

注意开 `long long`。

## Code

```c++
#include <bits/stdc++.h> 
using namespace std;

#define int long long
const int N = 200005;
int n;
int t[N];
int a[N];
int s[N];
int top;

signed main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> t[i];
		if (i > t[i])
		 	return cout << -1, 0;
	}
	for (int i = 1; i <= n; i ++)
		cin >> a[i];
	s[++ top] = a[n];
	int sum = a[n];
	for (int i = n - 1; i >= 1; i --)
	{
		if (t[i] == t[i + 1])
		{
			if (s[top] >= a[i])
			{
				int x = s[top];
				sum += x;
				s[++ top] = x;
			}
			else
			{
				sum += a[i];
				s[++ top] = a[i];
			}
		}
		else
		{
			for (int j = 1; j <= t[i + 1] - t[i]; j ++)
			{
				if (top != 0)
					top --;
				else
					break;
			}
            if (s[top] >= a[i])
            {
                int x = s[top];
                s[++ top] = x;
                sum += x;
            }
            else
            {
                s[++ top] = a[i];
                sum += a[i];
            }
		}
	}
	cout << sum;
	return 0;
} 
```

---

## 作者：pocafup (赞：18)

2024/04/09：添加了代码
### P0：写在前面

出题人题解。

古老题，之前发果汁的时候每次拿最多的，突发奇想造了这个题。

### P1：题解

观察发现对于第 $i$ 个人，如果他的到达时间为第 $j$ 秒且 $j < i$，则不存在任何制作方式能使他满意，否则必然存在一种方法。

注意到制作果汁顺序将会对答案造成影响。如果提前将果汁做好，在取果汁时队列前面要求不高的人也会取走体积大的果汁。理想的情况一定是做一杯拿一杯。由于允许可能同时到达，因此有时需要提前制作。为了不影响前面的制作，这个制作时间一定是越晚越好。

首先考虑对于果汁的最晚制作时间。发现对于一杯果汁，如果不存在多杯果汁需要同时派发，则第 $i$ 杯果汁可以在第 $t_i$ 秒制作。如果存在多杯果汁 $i,j$ 存在 $i<j$ 且 $t_i=t_j$，则最晚必须在 $t_i-1$ 秒开始制作果汁才能保证同时满足 $i,j$ 两个人。同时，如果存在一个人 $w = i-1, t_w = t_i-1$，则 $t_w$ 的最晚制作时间会变成 $t_i-2$，以此推类。

考虑从后往前处理序列。对于每个时间片处理需要制作的果汁。发现对于一个时间片，如果后面还有需要制作的果汁，则当前制作果汁体积必然不能小于之后需要的果汁。

证明：记当前需要制作的果汁体积为 $a_i$，后面需要制作的果汁体积为 $a_j$ 有 $a_i<a_j$。若 $i,j$ 均制作完成，则第 $i$ 个人会优先选择 $a_j$。 而最后仍需制作 $a_j$ 体积的果汁才能满足 $a_j$。

考虑用单调栈维护未制作的果汁。每次时间变化时弹出栈顶元素（后面需要的果汁），插入栈时和栈顶取 max。最终答案即为栈弹出所有元素的和。

时间复杂度 $O(n)$。

```cpp
signed main() {
    n = read();
    stack<int> q;
    For(i, 1, n) t[i] = read();
    For(i, 1, n) val[i] = read();
    For(i, 1, n) if (t[i] < i) {//判无解
            cout << -1 << endl;
            return 0;
    }
    FOR(j,n,0){//倒着做
        if (j != n) {
            For(k,1,t[j+1]-t[j]){//若时间变化则更新
                if (q.size()) {
                    ans += q.top();
                    q.pop();
                } else break;
            }
        }
        if(!j)break;
        if (q.size()) q.push(chkmax(q.top(), val[j]));//每次将未更新和之前取 max 后的丢栈顶
        else q.push(val[j]);
    }
    writeln(ans);
}
```

### P2：其他做法

主要发现的做法就是优先队列代替栈。复杂度 $O(n\log n)$。由于做法没有本质区别没卡

---

## 作者：LYZ0602 (赞：10)

这是一道单调栈的题目，同时还需要贪心。直接说代码思路：

### 首先特判无解：
每单位时间只可以制作一杯任意体积的果汁。如果第六位顾客要在第五单位时间取走饮料，也就是说我们要在 $5$ 单位时间内做 $6$ 杯饮料，此时便无解，输出 $-1$ 随后终止程序。

### 然后贪心:
因为每个人都会拿走当前已经制作的果汁中体积最大的一杯,所以我们在提前制作时要保证当前制作饮料 $\ge$ 后面提前制作的饮料,也就是单调性（递减），因此在分配时间的时候要倒序（容易计算）。

当 $t_{now}=i$ 时，此时有人来取饮料，那我们就先给他做，也不要忘了维护栈的单调性（当前制作饮料 $\ge$ 后面提前制作的饮料）。

当 $t_{now}>i$ 时，此人取走饮料的时间在这之后（注意，由于此时代码里是倒序循环遍历，所以“之后”一词代表从1到当前杯数），需要我们提前制作。

当 $t_{now}<i$ 时，这种情况正好与上面相反，代表这个人取走饮料的时间在此之前（同样是倒序循环遍历，“之前”一词代表从当前杯数到 $n$ 杯），所以此时我们暂且不用管它。

接着继续提前制作饮料。

 $ans$ 累加栈顶，接着弹出，最后输出。

剩下的请看代码注释。

# Code，启动！

```cpp
#include<iostream>
#include<stack>
using namespace std;
const char endl='\n';//加速输出 
const int N=2e5+10;
stack<int>st;
int now;
int t[N],a[N];
int n;
long long ans; 
int main()
{
	ios::sync_with_stdio(false);//加速输出
	cin.tie(0);
	cin >> n;
	for ( int i = 1 ; i <= n ; i ++)
	{
		cin >> t[i];
	}
	for ( int i = 1 ; i <= n ; i ++)
	{
		cin >> a[i];//输入 
	}
	for ( int i = 1 ; i <= n ; i ++)
	{
		if (t[i] < i)//特判无解，上面解释 
		{
			cout << -1 << '\n';
			exit(0);//终止程序 
		}
	}
	now=n;
	for ( int i = t[n] ; i >= 1 ; i --)
	{
		if(t[now] == i)//如果当前有人来取先做他的 
		{
			if(!st.empty() )//判空 
			{
				st.push(max(st.top(), a[now]));
			//当前体积不能小于（倒序）后面饮料防止被抢走 
			}
			else
			{
				st.push(a[now]);//第一个元素直接插入 
			}
			now--;i++;//再跑一遍 
		}
		else if (t[now] < i)//注意倒序所以反着来 
		{//在他之前（当前到n）取饮料，不用管 
			//提前制作饮料
			if (!st.empty() )//查找前判空 
			{
				ans += st.top();
				st.pop(); //弹出 
			} 
		}
		else//t[now]>i
		{//在他之后（1到当前） 需要提前制作 
			now--;i++; 
		}
	}
	while ( !st.empty() )//制作剩下的 
	{
		ans += st.top();
		st.pop();
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：__qkj__ (赞：8)

## 解题思路
显然是一题单调栈题。

因为每分钟制作一杯果汁，所以只要 $t_i<i$，即需要的杯的数量大于分钟数，输出 $-1$。

然后 $i$ 从 $n$ 到 $1$ 进行单调栈。当还有人在等候，那么最多操作 $t_{i+1}-t_i$ 次（即在这段时间内最多能做多少果汁），体积和加上栈顶，再弹出栈顶。

接下来就是压栈了。当栈内还有元素，压入栈顶、第 $i$ 个人所需体积的最大值（因为万一栈顶这个人所需体积大于第 $i$ 个人所需体积，第 $i$ 个人就会拿走栈顶这个人的那份，栈顶这个人就会不满意，所以只能都给栈顶的所需体积）。当栈内没有元素了，直接压入 $a_i$ 即可。

最后，加上栈内剩余元素就可以了。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
stack<int>s;
int t[200010],a[200010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,sum=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>t[i];
		if(t[i]<i)
		{
			cout<<-1;
			return 0;
		}
	}
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=n;i>=1;i--)
	{
		int now=t[i+1]-t[i];
		while(!s.empty()&&now--)sum+=s.top(),s.pop();
		if(!s.empty())s.push(max(a[i],s.top()));
		else s.push(a[i]);
	}
	while(!s.empty())sum+=s.top(),s.pop();
	cout<<sum;
	return 0;
}
```

---

## 作者：chrisgr_pretty_girl (赞：3)

## 无解

容易发现前 $t$ 分钟最多做 $t$ 瓶饮料，所以当 第 $i$ 个人需要在小于 $i$ 的时间取走饮料时，无解。  
即存在 $t_i>i$ 时无解，其余情况均有解。

## 求解

注意到第 $i$ 个人会取走当前最大的饮料，所以我们可以反向枚举 $i$ 进行求解，先分配大于 $t_i$ 的时间里制作的饮料大小，并将当前的饮料与栈顶饮料的最大值入栈作为当前会拿走的饮料大小。

正确性显然，时间复杂度 $\mathcal{O}(n)$ 轻松切过本题。

## CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, t[N], a[N], stk[N], tp;
long long ans;
int main() {
    scanf("%d", &n);
    bool as = 0;
    for(int i = 1; i <= n; ++i) {
        scanf("%d", t + i);
        if(t[i] < i) as = 1;
    }
    for(int i = 1; i <= n; ++i) scanf("%d", a + i);
    if(as) puts("-1");
    else {
        int now = t[n];
        for(int i = n; i; --i) {
            while(tp && now > t[i]) --now, ans += stk[tp--];
            stk[tp] = max(stk[tp++], a[i]);
            now = t[i];
        }
        while(tp) ans += stk[tp--];
        printf("%lld", ans);
    }
    return 0;
}
```

---

## 作者：Tsuki091117 (赞：2)

## 题目大意
 给定 $n$ 个人取饮料的时间及希望得到饮料的体积。

每个人拿饮料时都会拿走当前所剩饮料中体积最大的那一个。

求是否有解使得每个人拿到的饮料体积大于等于期望得到的饮料体积，无解输出 $-1$，有解输出最小体积和。

## 题目分析
### 无解情况
 由于机器每分钟都可以制作任意体积的饮料，那么只要我取饮料的时间大于等于我排队的编号就一定有解，故当取饮料的时间小于排队的编号就一定无解，此时输出 $-1$ 即可。
### 有解情况
 因为有些人会同时取饮料，如果正着走有些麻烦，那么我们就反着走（正难则反）。

情况如下

1.当 $t_{now}=i$ 时，说明当前时间有人来取饮料，那么我们先给他制作，但当前所制作饮料不能小于后面提前制作的饮料（因为要保证提前制作的饮料不会被抢走）。

2.当 $t_{now} <i$ 时，说明这个人在此之前取饮料，所以不用管它，当前时间就可以用来做后面需要提前制作的饮料。

3.当 $t_{now}>i$ 时，说明这个人取饮料的时间在此之后，也就是说他需要提前制作饮料。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;
int n,ans;
stack<int> stk;//存储未制作的饮料（需提前制作的饮料） 
struct node{
	int a,t,k;
}p[N];//a:期望得到的体积  t:取饮料时间 k:出现编号，便于下面的排序 
bool cmp(node a,node b){
	return a.t<b.t||(a.t==b.t&&a.k<b.k);//排序（如果同时取饮料，根据出现时间排序） 
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>p[i].t;
		p[i].k=i;//记录出现的编号 
	}
	for(int i=1;i<=n;i++){
		cin>>p[i].a;
	}
	sort(p+1,p+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(p[i].t<p[i].k){
			cout<<"-1";
			return 0;
		}//如果取饮料的时间小于编号，机器无法制作，无解 
	}
	int now=n;//逆向 
	for(int i=p[n].t;i>=1;i--){
		if(p[now].t==i){
			if(stk.size()) stk.push(max(p[now].a,stk.top()));
			else stk.push(p[now].a);
			now--;
			i++;
		}//如果当前时间有人来取饮料，先给他制作 
		else if(p[now].t<i){
			if(stk.size()){
				ans+=stk.top();
				stk.pop();
			}
		}//如果这个人不着急，先制作需提前制作的 
		else{
			now--;
			i++;
		}//这个人需提前制作 
	}
	while(stk.size()){
		ans+=stk.top();
		stk.pop();
	}//加上stk中剩余的 
	cout<<ans;//输出答案 
	return 0;
}

```

---

## 作者：Atserckcn (赞：2)

## [P10334 [UESTCPC 2024] 饮料](https://www.luogu.com.cn/problem/P10334) 题解

### 题目简述

有 $n$ 个人领果汁，第 $i$ 个人领的时间为 $t_i$，会拿走当前果汁机内体积最大的果汁，若此果汁体积 $\ge a_i$ 则会满意，否则不满意。求让所有人都满意的果汁体积之和，不满意则输出 -1。

### 思路简述

首先判断不能满足的情况。

注意到，有个人 $i$ 在第 $t_i$ 分钟时来领果汁，若 $t_i\le i$，即还没做好就来了，则直接无解。

那么如何计算体积呢？

考虑贪心。即每杯果汁尽量放后面做，可以避免类似做好了被另外的顾客抢走的现象。

若有 $p\ge 2$ 个人**同时**来拿果汁呢？

可以想到的一个基本思路是，提前做好这 $p$ 杯果汁，但是如果做完后又有人来抢呢？

那么 $p$ 杯果汁就必须比那些人的小。

如何判断呢？

通过枚举每分钟，用一个变量 `last` 来表示当前正在为第 last 号顾客制作果汁。

分析情况：

+ 下一个客人还没取，就先做后边的。
+ 下一个客人来了，就做他的。
+ 有若干个人同时来取，需要提前制作，思路同上，需放入栈中。

### 代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//不开 long long 见祖宗 
ll ans,n,last;
const ll MAXN=2e5+5;
ll a[MAXN],t[MAXN];
stack<ll> s;
int main(){
	scanf("%lld",&n);
	last=n;
	for(ll i=1;i<=n;i++)
	{
		scanf("%lld",&t[i]);
		if(t[i]<i)//还没做好你就来 
		{
			printf("-1\n");
			return 0;
		}
	}
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(ll i=t[n];i;i--)//枚举每一个时间 
	{
		if(t[last]<i)//还没来呢，先做后边的 
		{
			if(!s.empty())
			{
				ans+=s.top();
				s.pop();
			}	
		}
		else
		{
			if(t[last]==i)//来了，做他的 
			{
				if(!s.empty())
					s.push(max(s.top(),a[last]));
				else s.push(a[last]);
				last--;i++;
			}
			else
				if(t[last]>i)//一起来？提前做！ 
					last--,i++;
		}
	}
	while(!s.empty())
	{
		ans+=s.top();
		s.pop();
	}
	printf("%lld\n",ans);
	return 0;
}
```

**[AC 记录](https://www.luogu.com.cn/record/163024209)**

---

## 作者：Richard_Whr (赞：1)

感觉没啥人说清楚贪心策略啊。

有一点是清楚的，就是如果所有时间都不相同的话，那我们就人来的那个时刻做，防止被别人拿走。

否则就需要提前做，提前做就有个问题是，让前面的整体左移一位在最后做，还是直接把他插在前面第一个 $0$ 的位置呢？这里就用 $0,1$ 表示某个时刻是否已经被占用。

首先考虑刻画两种放置方案对需要饮料体积的影响。

整体左移一位后，所有人本来能拿到的东西暴露再上一个人前面，因此需要循环无限轮 $a_i \leftarrow \max(a_i,a_{i+1})$，知道序列不再变化。注意到这个东西的本质是进行后缀 $\max$。

对于插在前面，那么插得位置后面不能有比他小的否则就会被别人抢走，这个是对于后面的每一位进行 $a_j \leftarrow \max(a_i,a_j)$。

如果你仔细想一下你会发现这两个是对称的啊，一个是前缀 $\max$ 一个是后缀 $\max$，但是问题出现在两个 $1$ 段拼接的时候。

如果采用左移一位的操作，会强制让左边的一段和右边一段的最大值取 $\max$，而插在前面只会让他们和 $a_i$ 取 $\max$，显然是更划算的。

至此已经有了一个策略是依次考虑每一个人，在时间轴上找到第一个 $0$ 的位置，然后填入 $a_i$，同时让后面的 $a_j$ 对 $a_i$ 取 $\max$。

正着做其实不好做，而倒着做其实就是一个栈模拟有地方放置就弹栈，然后那个取 $\max$ 的操作实际上是入栈的时候，当前还在栈里面的东西是会填到它前面的，对栈内元素的 $\max$ 取 $\max$，这个值其实就是栈顶元素值。

很多人说是单调栈，其实和传统意义上的单调栈不一样，这个栈只是用来模拟放置的。

代码很短：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10; 
int t[N],a[N];
int stk[N],top;
int n;

signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	
	cin>>n;
	bool F=true;
	for(int i=1;i<=n;i++) cin>>t[i],F&=(t[i]>=i);
	for(int i=1;i<=n;i++) cin>>a[i];
	
	if(!F) cout<<"-1\n",exit(0);
	
	int res=0;
	for(int i=n;i>=1;i--)
	{
		a[i]=max(a[i],a[stk[top]]);
		stk[++top]=i;
		while(t[i]>t[i-1] && top) res+=a[stk[top]],top--,t[i]--;
	}	
	cout<<res<<"\n";
	
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：1)

## 我的博客

更多相关（或者不相关）知识点快戳：[oi-beats](https://ntsc-yrx.github.io/oi-beats/site/)，[个人博客](https://ntsc.flowus.cn/)。

## 摘要

一个非常非常无脑的做法，码量较大，但是~~拿了模拟赛首 A~~。

## 做法

首先我们直接考虑模拟。

我们考虑将每个时间段看成一个块。由多少个**不同的** $t_i$ 就有多少个时间块。令 $t_i$ 是从前往后第 $j$ 个不同的时间，那么它就对应了第 $j$ 个时间块。第 $j$ 个时间块 $v_j$ 的长度是 $t_{i}-t_{p}$，$t_p$ 是与 $t_i$ 不同的上一个时间。块长代表这个时间块内可以生产多少饮料。

我们来模拟一下。从前往后枚举每一个需求 $a_i$，其属于时间块 $v_j$。

对于最简单的做法，我们就把当前需要的饮料放在当前的时间块末尾生产即可。

接下来考虑一个时间块不能满足需求的情况。此时我们就需要往前找到最靠后的还有空余的时间块 $v_{pre}$。

那么我们是把这个 $a_i$ 放在 $v_{pre}$ 的前面，还是将 $v_j$ 到 $v_{pre}$ 之间的所有生产都往前移动一位呢？

应该是前面一种情况。

那么此时我们就要要求这些时间块内的生产的饮料都 $≥a_i$。否则 $a_i$ 就会被提前拿走。于是我们维护一个 tag。

我们的 tag 由两部分组成。一部分是 $pre+1$ 到 $j$ 之间的块，我们对整个块打 tag（下称块 tag）。一部分是对 $v_{pre}$ 来说，我们只要求当前有饮料的一段后缀 $≥a_i$，至于后来还有加入 $v_{pre}$ 的我们不管。

第一个 tag 我们用线段树维护，第二个我们直接在那个位置上打一个。

在统计答案时，对于每个块都从前往后考虑。将块内的元素对块 tag 取最大值，还要对这个块内的前缀 tag 取最大值。

参考代码。时间复杂度 $O(n \log n)$。

```C++
#include<bits/stdc++.h>
using namespace std;
#define int long long 
#define itn int
#define pb push_back
#define rd read()
inline int read() {
	int xx = 0, ff = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-')
			ff = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
		xx = xx * 10 + (ch - '0'), ch = getchar();
	return xx * ff;
}
void write(int out) {
	if (out < 0)
		putchar('-'), out = -out;
	if (out > 9)
		write(out / 10);
	putchar(out % 10 + '0');
}
#define cdbg(x) cerr<<#x<<" : "<<x<<endl;


const int INF=1e9;
const int N=2e5+5;


/*
策略：
- 若后面的a比前面的大，尽量在后面生产
- 反之在前面生产

从前往后考虑每一个取法


*/

// int tag[N];
int len[N];
int fa[N];

int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
vector<int> v[N];
vector<int> tag[N];
int t[N],a[N];
int tot;
int ans;


namespace SGT{
	//区间max单点求值

	int t[N<<2];
	int tag[N<<2];

	void pushup(int x){
		t[x]=max(t[x<<1],t[x<<1|1]);
	}
	void addtag(int x,int v){
		tag[x]=max(tag[x],v);
		t[x]=max(t[x],v);
	}

	void pushdown(int x){
		if(tag[x]){
			addtag(x<<1,tag[x]);
			addtag(x<<1|1,tag[x]);

			tag[x]=0;
		}
	}

	void change(int x,int l,int r,int pl,int pr,int v){
		if(l>=pl&&r<=pr){
			addtag(x,v);
			return ;
		}
		pushdown(x);
		int mid=l+r>>1;
		if(pl<=mid)change(x<<1,l,mid,pl,pr,v);
		if(pr>mid)change(x<<1|1,mid+1,r,pl,pr,v);
		pushup(x);
	}	

	int query(int x,int l,int r,int p){
		if(l==r){
			return t[x];

		}
		pushdown(x);
		int mid=l+r>>1;
		if(p<=mid)return query(x<<1,l,mid,p);
		return query(x<<1|1,mid+1,r,p);
	}
	
}


signed main(){
	 freopen("pie.in","r",stdin);
	 freopen("pie.out","w",stdout);



	int n=rd;	
	for(int i=1;i<=n;i++){
		t[i]=rd;
	}


	for(int i=1;i<=n;i++){
		a[i]=rd;
	}

	for(int i=1;i<=n;i++){
		fa[i]=i;
	}

	for(int i=1;i<=n;i++){
		if(t[i]!=t[i-1]){
			tot++;
			len[tot]=t[i]-t[i-1];
			v[tot].push_back(a[i]);
			tag[tot].pb(0);
			if(len[tot]==1)fa[tot]=find(tot-1);
		}else{
			int pre=find(tot);//找到最近的有空位的块
			if(pre==0){
				puts("-1");
				return 0;
			}
			//pre~tot中间的都不能<a[i]
			//pre块前面的不一定要大于他
			tag[pre].pb(a[i]);
			SGT::change(1,1,n,pre+1,tot,a[i]);
			v[pre].push_back(a[i]);
			if(v[pre].size()==len[pre])fa[pre]=find(pre-1);

		}
	}

	for(int i=1;i<=tot;i++){
		int sz=v[i].size();
		int mx=0;
		tag[i][sz-1]=max(tag[i][sz-1],SGT::query(1,1,n,i));
		for(int j=sz-1;j>=0;j--){
			mx=max(mx,tag[i][j]);
			v[i][j]=max(v[i][j],mx);
		}

		for(auto c:v[i]){
			ans+=c;
		}
	}

	cout<<ans<<endl;


	return 0;
}
```

---

## 作者：ys2012 (赞：1)

## [题目链接](https://www.luogu.com.cn/problem/P10334)

题目大意：有 $n$ 个人来取果汁，果汁机每分钟可以制作任意体积的果汁，每个人需要一定体积的果汁才能满足，如果全部人能满足输出需要的果汁总体积，如果不能则输出 $-1$。

### 分析：

- 发现第 $i$ 个人，取果汁的时间小于 $i$ 则不能满意，直接输出 $-1$ 并结束程序，否则要输出最优解。

- 根据样例，可以看出同一时间可能会有两个人来取果汁，如果要全部人满意必须要在前面做出果汁。

- 特别的每个人都会拿走果汁体积最多的，存在抢果汁的情况

这道题没什么好说的，下面是代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define fast ios::sync_with_stdio(0);cout.tie(0);cin.tie(0);
ll n;//来取果汁的人数 
ll t[1000005];//第i个人来取果汁的时间 
ll a[1000005];//第i个人希望得到的果汁 
stack <ll> q;//栈 
ll cnt=0;//求出需要最小的果汁体积 
int main()
{
	//fast
	cin>>n;//输入有n人
	for(int i=1;i<=n;++i){
		cin>>t[i];
		if(t[i]<i){//如果 t[i]<i 就会有人不满意，直接输出-1结束 
			cout<<-1;
			return 0; 
		}	
	}
	for(int i=1;i<=n;++i)
		cin>>a[i];
	ll w=n;
	for(int i=t[n];i>=1;--i){
		if(t[w]<i){//当t[w]分钟没有人取果汁 
			if(q.size()){//制作后面需要的果汁 
				cnt+=q.top();
				q.pop();
			}
		}else if(t[w]==i){//当t[w]分钟有人取果汁 
			if(q.size()){//如果之前做个，给最多的 
				q.push(max(q.top(),a[w]));
				w--;
				i++;
			}else{//如果没有就现做 
				q.push(a[w]);
				w--;
				i++;
			}
		}else if(t[w]>i){//当t[w]分钟有两个人取果汁 
			w--;
			i++;
		}
	}
	while(q.size()){//将栈里面的元素累加进答案 
		cnt+=q.top();
		q.pop();
	}
	cout<<cnt;//输出
	return 0;//结束 
}
```

---

## 作者：OIer_ACMer (赞：1)

题面内容描述很清晰，笔者在这就不过多解释。

题目很简单，我们可以想到，当一个人来到果汁机前，我们可以**立刻给它做一杯他想要的果汁**，如果此时他还没来，我们就先给他做好，像预定一样，但是情况往往不会这么简单~~不然就不会标注为绿题~~。

很明显，我们可以发现，当我们遇到这样一组数据：

![](https://cdn.luogu.com.cn/upload/image_hosting/vx2x6kb6.png)

我们可以发现，当我们遇到两个五都在同一时刻取走果汁时，我们就会和第三个人产生冲突，因为每次都要去除**最大的一杯果汁**，那么贪心的三号便有可能取走两位五号的饮料，这时，为了满足四号的胃口，我们就要用这种方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/dbe9nige.png)

在时刻三，也就是**三号来的时候制作一杯比前面的两位五号最大要求更大的饮料**，即体积为 $8$ 的饮料，尽管这会有所代价，但是顾客就是上帝，我们必须以满足顾客要求为标准，之后就和之前一样，来什么做什么。

为了更好地方便记录答案，同时为了更好地处理什么时候付出更大的代价给后一位顾客准备更大的饮料，我们就需要引入单调栈的思想，**将每一次我们所做的饮料存入单调栈，同时记录栈顶得出此时的最大值**，方便我们判断要多付出多大的代价。

例如，当我们遇到了七和四，而前面还有人（也就是我们刚才的例子），且我们知道此时的栈顶饮料最大体积是 $7$，那么我们就可以根据前面的推理得出，现在我们要做一杯**体积为 $8$ 的饮料，至少要比 $7$ 大且又不能太大，因为我们要保证答案尽量小**，来满足三号人的需求。

还有一个重点：怎么才能够得出我们现在栈顶的饮料体积是 $7$ 呢？这个时候我们就要通过倒序遍历时间刻度来得到这个答案，因为我们是提前预定，提前预定就意味着我们要**从后面的人就是预定好的人开始进行计算**，相当于知道了未来一定会发生什么，这也是本题一个比较难的点。


## 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
stack<int> sta;
int dd[1000009];
int needs[1000009];
int maxn = INT_MIN;
int ans = 0;
signed main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> dd[i];
        maxn = max(maxn, dd[i]);
        if (dd[i] < i)
        {
            cout << -1 << endl;
            return 0;
        } // 如果还没准备好，则直接选择无法满足，输出-1
    }
    for (int i = 1; i <= n; i++)
    {
        cin >> needs[i];
    }
    for (int i = maxn, now = n; i >= 1; i--)
    {
        if (dd[now] < i && !sta.empty())
        {
            ans += sta.top();
            sta.pop();
        }
        else
        {
            if (dd[now] == i)
            {
                if (!sta.empty())
                {
                    sta.push(max(sta.top(), needs[now]));
                }
                else
                {
                    sta.push(needs[now]);
                }
                now--;
                i++;
            }
            else if (dd[now] > i)
            {
                now--;
                i++;
            }
        }
    }
    while (!sta.empty())
    {
        ans += sta.top();
        sta.pop();
    }
    cout << ans << endl;
    return 0;
}

```

---

## 作者：jinfanhao (赞：0)

很好的单调栈练习题。\
首先我们可以明显的看出来因为供需之间存在时间的差异，导致获取饮料制造时间也存在差别。\
根据样例可以知道提前做不一定是一件好事情。所以这种供需关系的题目，直接处理供需关系冲突的情况，所以转换思路。\
直接按照时间顺序倒着处理，这样可以知道后面的饮料是否要提前准备。\
根据以上可以知道为了避免每个人拿到容量大的果汁，所以从后往前的时候，对于大容量的果汁优先制作，优先弹出。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+1;
int n,t[N],op[N],st[N],pos=1,sum;
signed main(){
	scanf("%lld",&n);
	for(int i=1; i<=n; ++i){
		scanf("%lld",&t[i]);
		if(t[i]<i){
			printf("-1");
			return 0;
		} 
	} 
	for(int i=1; i<=n; ++i)scanf("%lld",&op[i]);
	st[1]=op[n];
	sum=op[n];
	for(int i=n-1; i>=1; --i){
		if(t[i]==t[i+1]){
			if(st[pos]>=op[i]){
				int val=st[pos];
				sum+=val;
				st[++pos]=val;
			}else{
				sum+=op[i];
				st[++pos]=op[i];
			}
		}else{
			pos=max(pos-(t[i+1]-t[i]),0LL);
			if(st[pos]>=op[i]){
				int val=st[pos];
				sum+=val;
				st[++pos]=val;
			}else{
				sum+=op[i];
				st[++pos]=op[i];
			}
		}
	}
	printf("%lld",sum);
	return 0;
} 
```

---


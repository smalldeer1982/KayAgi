# 表达式计算4

## 题目描述

给出一个表达式，其中运算符仅包含 +，-，*，/，^，要求求出表达式的最终值。

数据可能会出现括号情况，还有可能出现多余括号情况。

数据保证不会出现超过 int 范围的数据，数据可能会出现负数情况。

## 说明/提示

表达式总长度不超过 $30$。

## 样例 #1

### 输入

```
(2+2)^(1+1)```

### 输出

```
16```

# 题解

## 作者：LionBlaze (赞：61)

总：本文中介绍了方法一和方法二，方法一可能偏难，方法二偏简单（本人主观判断），方法一实现 $184$ 行，方法二 $134$ 行（没有压行，不删注释，不删空行）。

# 方法 $1$（2024/5/18）

## 如何进行表达式计算？

我们通常使用的表达式，比如 $(2+2)^{(1+1)}$、$1+1$、$11 \times 11 - 11 + 11 \div 11^{(11 - 11) + (11 \div 11)} $，都叫做**中缀表达式**，意思是符号在两个运算符中间。

中缀表达式虽然好理解（对于人类），但是对于计算机不好计算。具体为什么，可以试一试，不是完全不可以但是特别难写（比如优先级）。

既然有中缀表达式，那肯定还有：

- **前缀表达式**：符号在数字的前面。比如中缀表达式 `(2+2)^(1+1)` 的前缀表达式就是 `^ + 2 2 + 1 1`。这种表达式便于程序求值，也绝对不会有括号，但是把中缀表达式变为前缀表达式比较困难。
- **后缀表达式**：符号在数字的后面。比如中缀表达式 `(2+2)^(1+1)` 的后缀表达式就是 `2 2 + 1 1 + ^`。这种表达式既便于程序求值，也不会有括号，从中缀转成后缀也不难。所以我们就选用后缀表达式进行计算。

## 中缀表达式转后缀表达式

首先，中缀表达式转后缀表达式，具体流程：

1. 定义一个运算符栈。
2. 如果是数字，直接加入后缀表达式。
3. 如果是字符，按以下流程处理：
5. 如果为 `(`，直接压栈。
8. 若为 `)`，依次弹出栈顶元素加入后缀表达式，直到遇到 `(`，停止，然后将 `(` 出栈。
13. 如果比栈顶运算符的优先级高，或者栈顶元素为 `(`，或者栈为空，直接压栈。
21. 否则，依次弹出栈顶元素加入后缀表达式，直到遇到比它优先级**低**的元素，或者遇到 `(`。
34. 如果最后还剩下，直接依次出栈加入后缀表达式。

update:这里有个细节问题没讲到，由于 `^` 乘方运算是从右往左计算的，所以在第 $7$ 步，如果是乘方运算，就要把“优先级低”改成“优先级低或相等”。

以样例为例：

```
(2+2)^(1+1)
```

| 字符或数字 | 操作 | 栈（左底右顶） | 后缀表达式 |
|:---:|:---:|:---:|:---:|
| `(` | 直接入栈 | `(` | （空） |
| $2$ | 直接加入后缀表达式 | `(` | `2` |
| `+` | 此时栈顶元素为 `(`，压栈 | `( +` | `2` |
| $2$ | 直接加入后缀表达式 | `( +` | `2 2` |
| `)` | 依次出栈直到 `(`，最后将 `(` 出栈 | （空） | `2 2 +` |
| `^` | 此时栈为空，直接入栈 | `^` | `2 2 +` |
| `(` | 直接入栈 | `^ (` | `2 2 +` |
| $1$ | 直接加入后缀表达式 | `^ (` | `2 2 + 1` |
| `+` | 此时栈顶元素为 `(`，压栈 | `^ ( +` | `2 2 + 1` |
| $1$ | 直接加入后缀表达式 | `^ ( +` | `2 2 + 1 1` |
| `)` | 依次出栈直到 `(`，最后将 `(` 出栈 | `^` | `2 2 + 1 1 +` |
| （EOF） | 此时栈未空，依次出栈 | （空） | `2 2 + 1 1 + ^` |

细节：

判断 `+`、`-` 是正负号还是加减号。如果左边是数字或右括号，就是加减号。否则就是正负号。

## 计算

计算流程：

1. 定义一个数字栈。
2. 如果是数字，直接压栈。
3. 如果是运算符，取两个栈顶元素，将运算结果重新压栈。

最后栈中剩下的就是结果。

以样例为例（后缀表达式我们刚才一起求了，``2 2 + 1 1 + ^``）：

| 字符或数字 | 操作 | 栈（左底右顶） |
|:---:|:---:|:---:|
| $2$ | 入栈 | $2$ |
| $2$ | 入栈 | $2,2$ |
| `+` | 取出两个栈顶元素，相加后放回去 | $4$ |
| $1$ | 入栈 | $4,1$ |
| $1$ | 入栈 | $4,1,1$ |
| `+` | 取出两个栈顶元素，相加后放回去 | $4,2$ |
| `^` | 取出两个栈顶元素，进行乘方操作后后放回去 | $16$ |
| （EOF） | 最后剩下 $16$，答案为 $16$ | $16$ |

细节：因为栈是先进先出，所以取出的时候也会反过来，比如（左底右顶）栈为 `1 2`，伪代码：

```
a ← top; //将a赋值为栈顶
pop(); //出栈
b ← top; //将b赋值为栈顶
pop(); //出栈
```

得到的结果是 `a = 2, b = 1`，此时如果要进行不满足交换律的运算（`-`、`/` 和 `^`），直接计算 `a -,/,^ b` 就会导致错误（比如减法，应为 $-1$ 计算为 $1$）。有两种方法，一是先赋值 `b`，再赋值 `a`，另一种是计算时颠倒顺序，总之就是要颠倒顺序。

## 时间复杂度

线性，但不知道如何证明。主要纠结与快速幂复杂度。

## 附：帮助
我这题提交了 $28$ 次才过，自认为坑已经踩得很全面了。

如果你 $20$ 分，像这样：[RE+RE+AC+WA+WA](https://www.luogu.com.cn/record/159794454)，可能是两个错误：一是没判断多余括号，二是正负号判断错误。你的正负号可能是这样判断的：左右两边都是数字。

如果你 $40$ 分，像这样：[RE+RE+AC+AC+WA](https://www.luogu.com.cn/record/159798847)，可能是两个错误：一是没判断多余括号，二是正负号判断错误。你的正负号可能是这样判断的：左边是数字。

如果你 $80$ 分，像这样：[AC+AC+AC+AC+WA](https://www.luogu.com.cn/record/159799367)，可能是正负号判断错误，错误同上。

如果你 $100$ 分，像这样：[AC+AC+AC+AC+AC](https://www.luogu.com.cn/record/159812846)，那么恭喜，因为这道题截止到现在一共还只有 $25$ 人通过。

# 方法 $2$（2024/7/15）

## 表达式树

顾名思义，肯定是一棵树，代表一个表达式，每个节点要么是数字，要么是运算符。

对于每个节点：
- 数字节点：没有儿子。
- 运算符节点：这种运算有几个操作数就有几个儿子，代表这个运算的所有操作数（或式）。

而对于这道题，所有的运算都有且只有两个操作数，所以是一颗二叉树。

比如中缀表达式 `(2+2)^(1+1)` 转换成表达式树是这样的：

![画得不好请原谅](https://cdn.luogu.com.cn/upload/image_hosting/lxniqse3.png)

比如根节点 `^`，左子树是 `2 + 2`，右子树是 `1 + 1`，分别是两个操作数。

再比如根节点的左子结点 `+`，左子树和右子树都是 `2`，也分别是两个操作数。

易知，每个表达式都对应一个表达式树。

## 表达式树和前/中/后缀表达式的联系

回顾：

前缀表达式是：符号在前。

中缀表达式是：符号在中间。

后缀表达式是：符号在后。

如果我们换一种方法表达呢？

前缀表达式是：符号 $\to$ 操作数 $1 \to$ 操作数 $2$。

中缀表达式是：操作数 $1 \to$ 符号 $\to$ 操作数 $2$。

后缀表达式是：操作数 $1 \to$ 操作数 $2 \to$ 符号。

二叉树的三种遍历：

前序遍历：根节点 $\to$ 左子结点 $\to$ 右子节点。

中序遍历：左子结点 $\to$ 根节点 $\to$ 右子节点。

后序遍历：左子结点 $\to$ 右子节点 $\to$ 根节点。

是不是感觉一模一样？

所以，表达式树的前序遍历就是前缀表达式，中序遍历就是中序表达式，后序遍历就是后续表达式，但是注意中序遍历（中缀表达式）要适当加括号。

## 中缀表达式转表达式树

1. 找到最后计算的运算，以及它的两个操作数。
1. 将它的两个操作数分别当做左子树和右子树，递归计算。

没了，只有细节：

### 如何找到最后计算的运算？

首先，如果整个表达式都被括号套着，把括号（可能是多层）去掉。

然后扫三边，扫的时候直接忽略括号中的内容。

第一遍找 `+,-`，**从右往左**，如果找到了就是最后计算的运算。

第二遍找 `*,/`，**从右往左**，如果找到了就是最后计算的运算。

第三遍找 `^`，**从左往右**，如果找到了就是最后计算的运算。

如果三遍都没找到，说明：
1. 所有都被括号套着 - 前面已经处理过，不可能的。
2. 括号外都没有运算符 - 说明全是数字，结果就是数字。

注意一个点，判断是否整个表达式被括号套着，不能只判断是否开头是 `(` 且结尾是 `)`，样例就可以 hack，需要使用类似[这道题](https://www.luogu.com.cn/problem/P1739)的方法，扫一遍，扫的时候括号嵌套层数的最小值就是整个表达式被套了多少层。

### 如何找到最后计算的运算左右两边的操作数？

既然是最后计算的运算，左边必定是左操作数，右边必定是右操作数。

## 如何计算

实在没什么好讲的。递归即可。

## 时间复杂度

线性，但是如果你在建树的时候直接使用 `string::substr`，会导致时间复杂度变为平方级别，可以维护两个变量，分别是当前字串的左右边界下标。但是我在实现中使用的是平方级别的。（虽然但是，最大长度为 $30$ 的话……）

# 处理多余括号

题目中说**还有可能出现多余括号情况**，感觉不太好处理。但是其实可以这样做：

多了左括号和右括号，既然左右是配对的，所以多左括号相当于少右括号，多右括号相当于少左括号。如果少了某种括号，那么在算式的最左边或最右边添加就好了。

给出伪代码：

```
bracnt ← 0 //当前括号的嵌套个数
for ch in input: //对于输入中每一个字符，从左到右遍历
	if(ch == '('): //如果是左括号
		bracnt++; //说明括号嵌套深了一层
   if(ch == ')'): //如果是右括号
		bracnt--; //说明括号嵌套少了一层
if(bracnt < 0): //括号嵌套 < 0，说明右括号多，也就是缺少左括号
	input = '(' * (-bracnt) + input; //缺少左括号，在左边加上。
if(bracnt > 0): //括号嵌套 > 0，说明左括号多，也就是缺少右括号
	input = input + ')' * bracnt; //缺少右括号，在左边加上。
```

$$ \color{red}{\text{注意！这样做是错误的！}} $$

给出 hack 数据：

```
)1+1(
```

最后，左括号和右括号数量相等，但是括号仍然不匹配！所以应该过程中就判断（最后仍然要判断一遍）。

完结撒花！~~我好像把另一个我忘了叫什么的题也讲了。~~

# 代码

为了不使题解太长，两个方法的代码放在云剪贴板里：[click me](https://www.luogu.com.cn/paste/ngr8uowc)。

另：码了这么多次，如有错误（比如错别字）请指出！

---

## 作者：KyleShen1213 (赞：14)

## 题目思路
先将它转换为后缀表达式，再求值。

但是转换过程中可能有多余括号，那我们就要把它删去。

用栈，左括号进栈后，之后对应一个右括号。如果多余，就出栈。
### 中缀转后缀方法：
定义一个栈。
输入原算式。


如果是数字，直接加入后缀表达式。
如果检测到字符：
如果为左括号，直接进栈。
若为右括号，依次将栈中的符号出栈后缀表达式，直到遇到 左括号，就将左括号出栈，然后停止。
如果比栈顶运算符的优先级高，或者栈顶元素为左括号，直接进栈。
否则，依次弹出栈顶元素加入后缀表达式，直到遇到比它优先级高的元素，或者遇到左括号。
如果最后还剩下东西在栈里，直接出栈加到后缀表达式里。

做完之后就是正常的了，求值方法：P1449	后缀表达式

## AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
stack <ll> s;
string str,ans,ss;
ll p[130],k,len;
int main()
{
	p['+']=1;
	p['-']=1;
	p['*']=2;
	p['/']=2;
	p['^']=3;
	cin>>str;
	str='(' + str + ')';//为了避开一些边界的情况 
	for(int i=0;i<str.length();i++)
	{
		if(str[i]=='(')  s.push(i);
		else if(str[i]==')')
		{
			if(s.empty())
			{
				str.erase(i,1);
				i--;
			}
			else s.pop();
		}
	}
	while(!s.empty())
	{
		str.erase(s.top(),1);//从后往前删，不影响下标 
		s.pop();
	}
	for(int i=0;i<str.length();i++)
	    if(str[i]=='('&&str[i+1]=='-')  str.insert(i+1,"0");
	//cout << str <<endl;
	for(int i=0;i<str.length();i++)
	{
		if(str[i]<='9'&&str[i]>='0') 
		{
			ans+=str[i];
			if(!(str[i+1]<='9' && str[i+1]>='0'))  ans+='.';
		}
		else if(str[i]=='(' )  s.push('(');
		else if(str[i]==')' )
		{
			while(s.top() != '(')
			{
				ans+=s.top();
				s.pop();
			}
			s.pop();//将左括号出栈 
		}
		else
		{
			while(!s.empty()&&p[s.top()]>=p[str[i]])
			{
			    ans+=s.top();
				s.pop();
			}
			s.push(str[i]); 
		} 
	} 
	while(!s.empty())
	{
		ans+=s.top();
		s.pop();
    }
	str=ans;
	for( int i=0;i<str.length();i++)
	{
		if(str[i]>='0' && str[i]<='9')  k=k*10+str[i]-'0';
		else if(str[i]=='.')
		{
			s.push(k);
			k=0;
		}
		else
		{
			ll a,b;
			b=s.top();s.pop();a=s.top();s.pop();
			if(str[i] == '+')  s.push(a+b);
			if(str[i] == '-')  s.push(a-b);
			if(str[i] == '*')  s.push(a*b);
			if(str[i] == '/')  s.push(a/b); 
			if(str[i] == '^')  s.push(pow(a,b));
		} 
	} 
	cout<<s.top()<<endl;
    return 0;
}
```

---

## 作者：shentianxing (赞：10)

## P10473 表达式计算4 题解
### 前言
模拟题，所以 C++ 代码特别长。要注意的点也很多。
### 题目思路
**中缀表达式转后缀表达式**   
首先要确定各种运算符号的优先级。
```cpp
map<char,int> mp;
mp['+']=1;
mp['-']=1;
mp['*']=2;
mp['/']=2;
mp['^']=3;
```
使用两个储存 int 的栈 $num$ 和 $d$，分别储存数字和运算符号。$d$ 用于储存运算符号，储存的是 ASCII 码。  
如果输入为数字，注意，此处数字可能是多位数，使用一个辅助整数变量 $nownum$。   
如果输入为运算符，表示一个数输入完成，把 $nownum$ 压入 $num$，然后重置。当栈 $d$ 为空或输入的运算符优先级大于（不是大于等于）$d$ 栈顶符号时，直接压入栈 $d$ ，如果两个条件都不符合，就循环：先把 $d$ 栈顶符号压入 $num$，再把 $d$ 的栈顶符号弹出。直到符合了任意一个条件后结束循环。最后把输入的符号压入 $d$。

假设输入的表达式字符串为 `20+1`：
| 输入的字符 | $nownum$ | $num$ | $d$ |
| :----------: | :----------: | :----------: | :----------: |
| 2 | 2 | 空 | 空 |
| 0 | 20 | 空 | 空 |
| + | 0 | 20 | + |
| 1 | 1 | 20 | + |


最后要进行三项收尾操作：   
1. 把 $nownum$ 压入 $num$。
2. 把 $d$ 里的运算符依次压入 $num$ 然后弹出。
3. 把 $num$ 里的所有字符依次压入 $d$ 并弹出。 

这样就成功转换成了后缀表达式。  
**转换时的特殊情况**   
1. 括号：当输入左括号时，直接压入 $d$。当输入右括号时，若栈顶字符不是左括号，循环：先把 $d$ 栈顶符号压入 $num$，再把 $d$ 的栈顶符号弹出。直到 $d$ 的栈顶符号为左括号为止。最后弹出左括号。
2. 多位数储存：为了最后在 $d$ 中可以区分数和符号 ASCII 码，$nownum$ 初始设置和每次重置时设为 $10$，而不是 $0$。当输入为数字时，$nownum$ 先乘 $10$ 再加上输入的数，相当于在 $nownum$ 后面添加一位。像这样，每个数 $x$ 储存在栈中时前面都加上了`10`，即使 $x$ 为 $0$，储存时也储存为 $100$。就可以区分符号ASCII码和数字了。
3. 若输入 '^'，$d$ 栈顶符号也是 '^'，直接压入 $d$。
4. 负数判断：在转换前判断，先在整个字符串外面套一组括号，然后循环：
```cpp
s='('+s+')';
for(int i=1;i<=s.size();i++){
	if(s[i-1]=='('&&s[i]=='-'){
		s.insert(i,"0");
	}
}
```
转换过程代码：
```cpp
s='('+s+')'; 
for(int i=1;i<=s.size();i++){
	if(s[i-1]=='('&&s[i]=='-'){
		s.insert(i,"0");
	}
}
int nownum=10;
for(int i=0;s[i];i++){
	if(isdigit(s[i])){
		nownum=nownum*10+s[i]-'0';
	}else{
		if(nownum!=10){
			num.push(nownum);
			nownum=10;
		}
       if(d.empty()||mp[s[i]]>mp[d.top()]||
       s[i]=='^'&&d.top()=='^'||s[i]=='('){
			d.push(s[i]);
			continue;
		}
		if(s[i]==')'){
			while(d.top()!='('){
				num.push(d.top());d.pop();
			}
			d.pop();
			continue;
		}
		if(!d.empty()||mp[s[i]]<=mp[d.top()]){
			while(!d.empty()&&mp[s[i]]<=mp[d.top()]){
				num.push(d.top());d.pop();
			}
			d.push(s[i]);
		}
	}
}
if(nownum!=10) num.push(nownum);
while(!d.empty()){	
	num.push(d.top());d.pop();
}
while(!num.empty()){
	d.push(num.top());num.pop();
}
```
**计算后缀表达式结果**   
设整数变量 $t$ 为 $d$ 的栈顶数，若 $t \geq 100$，则压入 $num$。但是在压入 $num$ 之前，要先去掉前面的两位`10`。
```cpp
int fun(int a){
	if(a==0) return 0;
	if(a<0){
		a=-a;
		int g;
	for(g=1;g<=a;g*=10);
	return a%(g/10)*-1;
	}
	int g;
	for(g=1;g<=a;g*=10);
	return a%(g/10);
}
```
若 $t < 100$，设 $x$ 为 $num$ 的栈顶数，$num$ 再弹出。用同样的方式，设 $y$ 为 $num$ 的栈顶数，$num$ 再弹出。由于是从栈中取出，所以 $x$ 和 $y$ 的顺序要反过来。$t$ 是什么符号就做什么运算，最后把运算结果压入 $num$。
```cpp
while(!d.empty()){
	int t=d.top();
	if(t>=100||t<0){
		num.push(fun(t));
		d.pop();
	}else{
		d.pop();
		int x=num.top();
		num.pop();
		int y=num.top();
		num.pop();
		if(t=='+'){
			num.push(y+x);
		}else if(t=='-'){
			num.push(y-x);
		}else if(t=='*'){
			num.push(y*x);
		}else if(t=='/'){
			num.push(y/x);
		}else{
			num.push(pow(y,x));
		}
	}
}
```
最后输出 $num$ 里唯一的数就行了。   
**括号问题**   
题目里写了“可能会有多余的括号”。   
定义整数栈 $l$，用于储存左括号的下标。  
```cpp
for(int i=0;s[i];i++){
	if(s[i]=='('){
		l.push(i);//储存左括号下标
	}else if(s[i]==')'){
		if(l.empty()){
			s.erase(i,1);
			i--;//识别到右括号时，若还没有左括号，直接删除
		}else{
			l.pop();//若有左括号，弹出栈顶左括号。
		}
	}
}
while(!l.empty()){
	s.erase(l.top(),1);
	l.pop();
  //去掉最后未匹配的
}
```
注意：括号判断要在输入表达式后立即执行，不要搞错顺序。   
然后漫长的一题就做完了。

---

## 作者：LG086 (赞：4)

### 分析

给出一个表达式，求出表达式的值。  
模拟题。  
P1981 的加强版。

用栈来解，需要一个字符栈，一个数字栈。

有一些需要考虑的问题：
- 数据可能会出现括号情况，还有可能出现多余括号情况。
- 数据可能会出现负数情况。

判负数很简单，因为一个负数等于 $0$ 减去它的绝对值，在最初的字符串 $s$ 最前面加上一个字符 $\texttt 0$ 即可。  
这样表达式开头的负数会变成减运算。如，读入字符串 $\texttt{-1+3}$ 会变成 $\texttt{0-1+3}$。

判多余括号可以先计算出字符串内左右括号的个数，用 $cnt1$ 数 `(`，用 $cnt2$ 数 `)`。  
使用 $cnt$ 计算 $\max(cnt1,cnt2)+1$，这样得出，若保证表达式内括号匹配，则至少还需要 $cnt-cnt1$ 个 `(` 和 $cnt-cnt2$ 个 `)`。  
在字符串 $s$ 开头添加 $cnt-cnt1$ 个 `(` ，在末尾添加 $cnt-cnt2$ 个 `)` 防止多余括号的干扰。如，输入 $\texttt{)1+1(}$ 会转化为 $\texttt{()1+1()}$。

牢记名言，先乘除后加减。

------------
### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s="0";//开头添0
char x;
stack<int>vi;
stack<char>vc;
int T;
int cnt1,cnt2,cnt;
signed main(){
        while(cin>>x){
            if(x==' ')continue;
            s+=(char)x;
        }
        for(int i = 0;i < s.size();i ++){
            char c = s[i];
            if(c=='(')cnt1++;
            if(c==')')cnt2++;
        }
        cnt=max(cnt1,cnt2),cnt++;//记住cnt++，防止")1+1("
        for(int i = 0;i < cnt-cnt1;i ++)
        s='('+s;
        for(int i = 0;i < cnt-cnt2;i ++)
        s=s+')';//添加括号
        for(int i = 0;i < s.size();i ++){
            char c = s[i];
            int flag=1;
            if(c=='-'&&(s[i-1]<'0'||s[i-1]>'9'))
            flag = -1;
            if(c>='0'&&c<='9'){
                int a = 0;
                while (i < s.size() && (s[i] >= '0' && s[i] <= '9')) {
                    a = a * 10 + s[i] - '0';
                    i++;
                }
                i--;
                vi.push(a * flag);
            }else if(c=='(')vc.push(c);//遇到括号
            else if (c==')'){
                while(!vc.empty() && vc.top() != '(' ){
                    int b=vi.top();
                    vi.pop();
                    int a=vi.top();
                    vi.pop();
                    char op=vc.top();
                    vc.pop();
                    if(op=='*')vi.push(a*b);
                    if(op=='/')vi.push(a/b);
                    if(op=='+')vi.push(a+b);
                    if(op=='-')vi.push(a-b);
                    if(op=='^')vi.push((int)(pow(a,b)));
                }
                vc.pop();//先算括号里的
            }else if(c=='+'||c=='-'||c=='*'||c=='^'||c=='/'){
                while(!vc.empty() && vc.top()!='(' && ((c!='*' && vc.top()!='*' || vc.top()=='*')&&(c!='^' && vc.top()!='^' || vc.top()=='^')&&(c!='/' && vc.top()!='/' || vc.top()=='/'))){
                    int b=vi.top();
                    vi.pop();
                    int a=vi.top();
                    vi.pop();
                    char op=vc.top();
                    vc.pop();
                    if(op=='*')vi.push(a*b);
                    if(op=='/')vi.push(a/b);
                    if(op=='+')vi.push(a+b);
                    if(op=='-')vi.push(a-b);
                    if(op=='^')vi.push((int)(pow(a,b)));
                }
                vc.push(c);
            }
        }
        while(!vc.empty()){
            int b=vi.top();
            vi.pop();
            int a=vi.top();
            vi.pop();
            char op=vc.top();
            vc.pop();
            if(op=='*')vi.push(a*b);
            if(op=='/')vi.push(a/b);
            if(op=='+')vi.push(a+b);
            if(op=='-')vi.push(a-b);
            if(op=='^')vi.push((int)(pow(a,b)));
        }//计算
        cout<<vi.top()<<endl;//输出
}
```

---

## 作者：xiaoyang111 (赞：3)

## 前言

[题目传送门。](https://www.luogu.com.cn/problem/P10473)

这是一篇用 `python` 水过的做法，想看正解去其他地方看。

在阅读本文前，你需要知道下面的知识。

- `python` 语言中的 `s.replace(str1,str2)`，可以把字符串 `s` 中所有的 `str1` 替换成 `str2`。它是有返回值的，返回值就是改完后的字符串。

- `python` 语言中的 `eval(s)`，可以把 `s` 当作 `python` 语言编译，结果就是编译后的结果，比如我给他一个能在 `python` 中编译通过的算式，他能给你这个算式在 `python` 中运行后的结果。如果语法不正确，就直接报错。

## 题解

读完前置知识发现 `eval` 似乎可以直接解决题目？

代码：

```python
s = input()
print(eval(s))
```

然后你交上去发现全错。

发现题目中的乘方是 `^`，而 `python` 中的乘方是 `**`，所以你要把所有的 `^` 改成 `**`，直接 `replace` 就可以了。

代码：

```python
s = input()
s = s.replace('^','**')
print(eval(s))
```

交上去发现只过了两个点。

当我们输入除法的时候，发现怎么后面多了个小数啊。是因为 `python` 语言的特性，当有 `/` 的时候，整个计算的类型就直接变成了小数，所以还要把所有的 `/` 换成 `//`，把小数搞掉。还是直接 `replace` 就可以了。

代码：

```python
s = input()
s = s.replace('^','**')
s = s.replace('/','//')
print(eval(s))
```

交上去发现还有两个点返回值错误。

当 `python` 语言报错的时候，就会直接返回值错误，说明了在 `eval` 的时候错了。

那么说明算是还有一些地方和 `python` 的语法不同，导致 `eval` 报错，所以还有一些地方要判断。

直接开始找数据，发现题面中的可能出现多余括号的情况没有判断，所以给他判断了。从左到右扫一遍字符串，拿一个变量标记一下。

如果扫到左括号，就把变量加一。如果扫到右括号，就把变量减一，如果变量是负的了，就说明左括号少了，在字符串前面加左括号，变量搞成 `0`。

如果扫完后变量不是 `0`，说明左括号多了，在字符串末尾加上这么多个右括号补齐。

直接 `eval` 就可以了。

代码：

```python
t = input().replace('^','**').replace('/','//')
r = t
top = 0
for i in t:
    if i == ')':
        if top > 0: top -= 1
        else: r = '(' + r;
    elif i == '(': top += 1;
if top > 0:
    r = r + ')' * top
print(eval(r))
```

---

## 作者：YuzhenQin (赞：3)

本题 Python 题解都太长了，这里提供一种 3 行的 Python 做法。

首先 Python 中的乘方是 `**`，对应 C++ 中的除法是 `//`，所以使用 `str.replace()` 函数替换对应符号。

由于数据**可能出现多余括号情况**，可以使用 `str.count()` 函数计算字符串中指定字符串的数量。然后计算出左括号和右括号的数量的差。如果多左括号，则在字符串最右边补右括号，反之亦然。

最后使用 `eval()` 函数对表达式求值即可。

```python3
a = input().replace('/', '//').replace('^', '**')
cnt = a.count('(') - a.count(')')
print(eval('(' * -cnt + a + ')' * cnt))
```

---

## 作者：__delta_epsilon__ (赞：0)

### 题目大意

给定一个表达式并求值。可能会有多余的括号。

### 思路

**人生苦短，我用 Python。**

显然 Python 中的 `eval` 求值对本题来说很有用。

由于输入中乘方为 `^` 且除法为 `/` 需要进行一些调整。

但不要急。问题在于，这里的除法是整数除法还是小数除法呢？题目里没有说（只说了不出现超过 int 范围的数据），所以我们通过一发提交试了一下，发现如果用小数除法提交，会 WA 一发，但将结果取整之后就能过，所以我们姑且认为这不是重点。

---

先说一些基础知识。

字符串的替换。将 string 中 `count` 个子串 `old` 替换为 `new`。`count` 非必填，默认为 $-1$，表示全部替换。

```
string.replace(old, new, [count])
```

字符串的统计。统计 string 从 `start` 到 `end` 之间 `sub` 子串出现的个数，`start`、`end` 若不填，默认为对整个字符串进行统计。

```
string.count(sub[, start[, end]])
```

---

思路就是读入字符串后见 `^` 替换为 `**`，然后补上缺的括号，`eval()` 并取整后输出。（至于 `/` 要不要换成 `//`，反正能过就行）

代码如下：

```python
print(int(eval((_:=input().replace('^','**'))+')'*(_.count('(')-_.count(')')))))
```

解释一下，

- `_:=input().replace('^','**')` 表示将输入中的 `^` 替换为 `**` 并赋值给 `_`，同时返回 `_` 的值。
- `_.count('(')-_.count(')')` 表示统计 `_` 中左括号比右括号多的个数。
- `+')'*(_.count('(')-_.count(')'))` 表示将缺少的括号组成的字符串补在 `_` 后。
- `print(int(eval(...)))` 表示计算取整并输出。

代码总长 80 B，顺利 AC。

---


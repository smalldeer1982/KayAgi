# 表达式的转换

## 题目描述

平常我们书写的表达式称为中缀表达式，因为它将运算符放在两个操作数中间，许多情况下为了确定运算顺序，括号是不可少的，而后缀表达式就不必用括号了。

后缀标记法：书写表达式时采用运算紧跟在两个操作数之后，从而实现了无括号处理和优先级处理，使计算机的处理规则简化为：从左到右顺序完成计算，并用结果取而代之。

例如：`8-(3+2*6)/5+4` 可以写为：`8 3 2 6 * + 5 / - 4 +`

其计算步骤为：

```
8 3 2 6 * + 5 / - 4 +
8 3 12 + 5 / - 4 +
8 15 5 / - 4 +
8 3 - 4 +
5 4 +
9
```

编写一个程序，完成这个转换，要求输出的每一个数据间都留一个空格。

## 说明/提示

运算的结果可能为负数，`/` 以整除运算。并且中间每一步都不会超过 $2^{31}$。字符串长度不超过 $100$。

注意乘方运算 `^` 是从右向左结合的，即 `2 ^ 2 ^ 3` 为 `2 ^ (2 ^ 3)`，后缀表达式为 `2 2 3 ^ ^`。

其他同优先级的运算是从左向右结合的，即 `4 / 2 / 2 * 2` 为 `((4 / 2) / 2) * 2`，后缀表达式为 `4 2 / 2 / 2 *`。

保证不会出现计算乘方时幂次为负数的情况，故保证一切中间结果为整数。

## 样例 #1

### 输入

```
8-(3+2*6)/5+4
```

### 输出

```
8 3 2 6 * + 5 / - 4 + 
8 3 12 + 5 / - 4 + 
8 15 5 / - 4 + 
8 3 - 4 + 
5 4 + 
9
```

## 样例 #2

### 输入

```
2^2^3
```

### 输出

```
2 2 3 ^ ^
2 8 ^
256
```

# 题解

## 作者：sunyizhe (赞：149)

这题难度并不是很大，就是模拟，只是代码很长而已。只要思路明确，就可通过此题。

[题目传送门](https://www.luogu.com.cn/problem/P1175)

## 一、题意

1. 写出给定字符串的后缀表达式。

2. 写出计算过程。

## 二、数据范围

- 字符只有 ```0123456789+-\*/^``` 几种。

- 基本数字只有一位数，不会出现多位数。

- 输入数字不会出现负数，中间一切结果为整数。

- 字符串长度小于 $100$。

## 三、思路

### 3.1 第一问

#### 3.1.1 认识后缀表达式的转换方法 

首先，我们要知道如何手算得出后缀表达式。下面是题目样例的后缀表达式转换方法。

```
8 - (3 + 2 * 6) / 5 + 4
8 - (3 + 2 6 *) / 5 + 4
8 - 3 2 6 * + / 5 + 4 （去括号）
8 - 3 2 6 * + 5 / + 4 
8 3 2 6 * + 5 / - + 4
8 3 2 6 * + 5 / - 4 +
```

那么如何用编程来实现呢？

#### 3.1.2 程序基本实现

用字符串 $s$ 存储中缀表达式。

我们定义一个函数来判断运算符的优先级。如下：

```cpp
int check(char c)
{
	switch(c)
	{
		case '+':return 1;
		case '-':return 1;
		case '*':return 2;
		case '/':return 2;
		case '^':return 3;
		case '(':return 0;
		case ')':return 0;
		default:return -1;//程序不会执行这句，保险起见要加上
	}
}
```

定义两个栈 $dat$ 和 $op$，它们存的分别是后缀表达式和符号。


来看例子：```2 + 3 * 4```

模拟一下：

|栈dat|栈op|操作|
| -----------: | -----------: | -----------: |
|2 |Null |将 2 入栈|
|2 |+ |op 栈为空，将 + 入栈|
|3 2 |+ |将 3 入栈|
|3 2 |\* + |\* 比 + 优先级高，入栈|
|4 3 2 |* + |将 4 入栈|
|+ * 4 3 2 |Null |弹空 op 栈，依次进入 dat 栈|

这时，逆序输出栈 $dat$，得到式子的后缀表达式 ```2 3 4 * +```。

再看一个：```2 * 4 + 3```

|栈dat|栈op|操作|
| -----------: | -----------: | ----------: |
|2 |Null |将 2 入栈|
|2 |\* |op 栈为空，将 \* 入栈|
|4 2 |\* |将 4 入栈|
|\* 4 2 |+ |+ 比 \* 优先级低，将 \* 弹出|
|3 \* 4 2 |\* + |将 3 入栈|
|+ 3 \* 4 2 |Null |弹空 op 栈，依次进入 dat 栈|

这时，逆序输出栈 $dat$，得到式子的后缀表达式 ```2 4 * 3 +```。

经过尝试和拼凑，我们发现：

- $s_i$ 为数字时，直接压进 $dat$ 栈。

- $s_i$ 为运算符时，优先级若比 $op$ 栈栈顶符号高（是 $>$ 而不是 $\ge$，可以自己模拟看看），就压进栈，否则就弹出 $op$ 的栈顶元素到 $dat$ 栈里，直到比栈顶符号优先级高或栈空。

- 最后，将 $op$ 栈里的剩余元素弹出到 $dat$ 栈。

上面这些是最基本的情况。但如果有括号呢？

#### 3.1.3 特殊情况

当 $s_i$ 为左括号时，可以直接压进 $op$ 栈里。当 $s_i$ 为右括号时，一直弹出 $op$ 栈栈顶到 $dat$ 里，直到栈顶为左括号，再弹出左括号。这些也可以通过模拟得出答案。

看例子：```2 + (3 + 4) * 3```

|栈 dat |栈 op |操作|
| -----------: | -----------: | -----------: |
|2 |Null |将 2 压进栈|
|2 |+ |op 栈空，将 + 压进栈|
|2 |( + |将左括号压进栈|
|3 2 |( + |将 3 压进栈|
|3 2 |+ ( + |+ 比 ( 优先级高，将 + 压进栈|
|4 3 2 |+ ( + |将 4 压进栈|
|+ 4 3 2 |+ |将右括号与左括号之间的 + 弹出到 dat 栈|
|+ 4 3 2 |\* + |\* 比 + 优先级高，将 \* 压进栈|
|3 + 4 3 2 |\* + |将 3 压进栈|
|+ \* 3 + 4 3 2 |Null |将 op 栈里的元素压进 dat 栈|

最后逆序输出 $dat$ 栈，得到：```2 3 4 + 3 * +```。

当然，我们不能忽略题目中特殊的乘方运算。模拟样例 2：```2 ^ 2 ^ 3```。如下：

|栈 dat |栈 op |操作|
| -----------: | -----------: | -----------: |
|2 |Null |将 2 压进栈|
|2 |^ |op 栈空，将 ^ 压进栈|
|2 2 |^ |将 3 压进栈|
|2 2 |^ ^ |^ 与 ^相同，将 ^ 压进栈（特殊）|
|3 2 2 |^ ^ |将 3 压进栈|
|^ ^ 3 2 2 |Null |将 op 栈里的元素压进 dat 栈|

我们得到：```2 2 3 ^ ^```

所以，当 $s_i$ 为乘方运算符时且 $op$ 栈栈顶也是乘方运算符时，也可直接压进栈中。

#### 3.1.4 表达式输出

如果你用的是数组版栈，直接遍历即可。但如果你跟我一样用的是 STL 版栈，可以把栈 $op$ 用来临时存放数据。先把 $dat$ 里的元素全部压进 $op$ 栈，再倒回来，同时输出字符即可。输出记得换行。这样，第一问就结束了。

### 3.2 第二问

第二问相对简单，我们同样可以定义 $calc$ 函数完成第二问。

#### 3.2.1 基本运算

为了方便，定义函数用来计算两个数的计算结果。这个很简单，代码如下：

```cpp
int js(int x,int y,char t)//x和y为计算的两个数，t为运算符
{
	switch(t)
	{
		case '+':return x+y;
		case '-':return x-y;
		case '*':return x*y;
		case '/':return x/y;
		case '^':return pow(x,y);
		default:return -0x3f3f3f3f;//程序不会执行到这里，同样为了保险
	}
}
```

#### 3.2.2 后缀表达式计算

定义两个栈 $num$ 与 $dat2$，$num$ 存储计算过程，$dat2$ 用来临时存放数据，之前的 $dat$ 和 $op$ 可以继续使用。

把 $dat$ 全部弹出到 $op$ 里，接下来进行计算。

1. 变量 $t$ 获取 $op$ 栈顶，$op$ 弹出。

2. 若 $t$ 为数字，减去 ```'0'``` 再进入 $num$。若 $t$ 为运算符，弹出 $num$ 栈顶 $2$ 个元素并记录，将运算结果压进栈，同时输出过程。

3. 重复 1 和 2 两个步骤，直到 $op$ 为空。

#### 3.2.3 过程输出

输出过程时，反序输出 $num$，正序输出 $op$。

同样利用 $dat2$ 与 $dat$，反序与正序差不多，只是前者在倒回来时输出，后者在倒出去时输出。最后记得换行。

## 四、代码

```cpp
#include <bits/stdc++.h>
using namespace std;
stack<char> dat,op;
stack<int> num,dat2;
int check(char c)
{
	switch(c)
	{
		case '+':return 1;
		case '-':return 1;
		case '*':return 2;
		case '/':return 2;
		case '^':return 3;
		case '(':return 0;
		case ')':return 0;
		default:return -1;
	}
}
int js(int x,int y,char t)
{
	switch(t)
	{
		case '+':return x+y;
		case '-':return x-y;
		case '*':return x*y;
		case '/':return x/y;
		case '^':return pow(x,y);
		default:return -0x3f3f3f3f;
	}
}
void change(string s)
{
	int len=s.size();
	for(int i=0;i<len;i++)
	{
		if(isdigit(s[i]))dat.push(s[i]);
		else if(s[i]=='(')op.push(s[i]);
		else if(s[i]==')')
		{
			char t=op.top();
			while(t!='(')
			{
				op.pop();
				dat.push(t);
				t=op.top();
			}
			op.pop();//要弹出左括号
		}
		else if(check(s[i])>=1&&check(s[i])<=3)//为运算符
		{
			if(!op.empty())
			{
				char t=op.top();
				while(!op.empty()&&check(s[i])<=check(t))
				{
					if(check(s[i])==check(t)&&s[i]=='^')break;//在s[i]与栈顶都是^号时也能进栈
					op.pop();
					dat.push(t);
					if(!op.empty())t=op.top();
				}
			}
			op.push(s[i]);
		}
	}
	while(!op.empty())
	{
		char t=op.top();
		op.pop();
		dat.push(t);
	}
	while(!dat.empty())
	{
		char t=dat.top();
		dat.pop();
		op.push(t);
	}
	while(!op.empty())
	{
		char t=op.top();
		cout<<t<<' ';
		op.pop();
		dat.push(t);
	}
	cout<<endl;
}
void calc()
{
	while(!dat.empty())
	{
		char t=dat.top();
		dat.pop();
		op.push(t);
	}
	while(!op.empty())
	{
		char t=op.top();
		op.pop();
		if(isdigit(t))num.push(t-'0');
		else
		{
			int x=num.top();
			num.pop();
			int y=num.top();
			num.pop();
			num.push(js(y,x,t));//传参数时要把x和y反过来
			while(!num.empty())
			{
				int t=num.top();
				num.pop();
				dat2.push(t); 
			}
			while(!dat2.empty())
			{
				int t=dat2.top();
				cout<<t<<' ';
				dat2.pop();
				num.push(t);
			}
			while(!op.empty())
			{
				char t=op.top();
				cout<<t<<' ';
				op.pop();
				dat.push(t);
			}
			while(!dat.empty())
			{
				char t=dat.top();
				dat.pop();
				op.push(t);
			}
			cout<<endl;
		}
	}
}
int main()
{
	string s;
	cin>>s;   
	change(s);
	calc();
	return 0;
}
```

P.S. 表格不知道咋回事，为什么没有线啊……

---

## 作者：xuhanxi_dada117 (赞：51)

~~艾玛表达式树高斯我了~~
# P1175 表达式的转换

## 题目描述

平常我们书写的表达式称为中缀表达式，因为它将运算符放在两个操作数中间，许多情况下为了确定运算顺序，括号是不可少的，而后缀表达式就不必用括号了。

后缀标记法：书写表达式时采用运算紧跟在两个操作数之后，从而实现了无括号处理和优先级处理，使计算机的处理规则简化为：从左到右顺序完成计算，并用结果取而代之。

例如：`8-(3+2*6)/5+4` 可以写为：`8 3 2 6 * + 5 / - 4 +`

其计算步骤为：

```
8 3 2 6 * + 5 / - 4 +
8 3 12 + 5 / - 4 +
8 15 5 / - 4 +
8 3 - 4 +
5 4 +
9
```

编写一个程序，完成这个转换，要求输出的每一个数据间都留一个空格。

## 题目大意
给你一个表达式，让你写成后缀形式，然后输出解的过程。

（这题很离谱，前方高能！）

## 题目解法
表达式转后缀化简，表达式树裸题了
### 建树
最烦的一步

先找根：

有加减找最后一个加减，

有乘除找最后一个乘除，

否则找**第一个幂**（找最后一个 $Sub1$ 过不掉）

注意括号内要看成一个整体（不然递归到后面会出错）
但是！！

如果整个柿子是形如 $(xxxxx)$ 型要先把外括号干掉！
但是！！

**一定要是对应**！！否则 $(2+3) \times (4+5)$ 卡死你！

找到根就好做了，直接分开两边继续递归就行了。
最后我们要知道：

+ 树的结构
+ 叶子结点的数值
+ 每个节点的符号（叶子结点就是" "）

### 计算+输出答案

从根节点开始往下搜，搜出可以算的节点就算（一定在叶子附近），计算完了对树后序遍历输出就好了。

（注：你可能还要写一个武则天计算器）

详情请见注释

## 代码
嗨害嗨  


```cpp
#include<bits/stdc++.h>
#define N 114514
using namespace std;
string op;
char ch[N];int num[N],lf[N],rf[N],cnt=0;// ch是运算符，num是值，cnt是节点个数，lf,rf左右儿子
void build(int l,int r){//建表达式树
	if(l==r){
		num[++cnt]=op[l]-'0';
		ch[cnt]=' ';
		return;
	}//叶子结点存好
	if(op[l]=='('){//判断是否为(xxxxx)型
		int go=1;
		for(int i=l+1;i<=r;++i){
			if(op[i]=='(') ++go;
			else if(op[i]==')') --go;
			if(go==0){//找到对应的')'了
				if(i==r) ++l,--r;//判断是否为首尾
				break;
			}
		}
	}
	int p,typo=5;//p为根的坐标
    //typo:+1-1*2/2^3
	for(int i=r;i>=l;--i){
		if(op[i]==')'){//跳过括号
			int go=1,j;
			for(j=i-1;j>=l;--j){
				if(op[j]==')') ++go;
				else if(op[j]=='(') --go;
				if(go==0) break;
			}
			i=j;continue;
		}else if(op[i]<='9'&&op[i]>='0') continue;//跳过数字
		else{//对符号分类讨论
			if((op[i]=='+'||op[i]=='-')&&typo>1) p=i,typo=1;//有加减就加减
			else if((op[i]=='*'||op[i]=='/')&&typo>2) p=i,typo=2;//有乘除就乘除
			else if(op[i]=='^'&&typo>3) p=i,typo=4;//找幂
		}
	}
	int x=++cnt;
	ch[x]=op[p];//更新自己
	lf[x]=cnt+1;
	build(l,p-1);//向左子树递归
	rf[x]=cnt+1;
	build(p+1,r);//向右子树递归
}
int calc(int a,int b,char gk){
	switch(gk){
		case '+':return a+b;
		case '-':return a-b;
		case '*':return a*b;
		case '/':return a/b;
		case '^':return pow(a,b);
	}
}//武则天计算器
void print(int u){//后序遍历输出
	if(ch[u]==' '){
		cout<<num[u]<<" ";
		return;
	}
	print(lf[u]);print(rf[u]);
	cout<<ch[u]<<" ";
}
void dfs(int x){//递归计算
	if(ch[x]==' ') return;
	dfs(lf[x]);dfs(rf[x]);//算左右子树
	num[x]=calc(num[lf[x]],num[rf[x]],ch[x]);//计算本节点
	ch[x]=' ';//复位叶子
	print(1);cout<<endl;//输出运算过程
}
int main(){
	cin>>op;
	build(0,op.size()-1);
	print(1);cout<<endl;
	dfs(1);
	return 0;
}
```

珍爱账号，远离抄袭！

（记得点赞

---

## 作者：ShenTianYi_ (赞：50)

这一题的思路并不难，但是现在却只有5篇题解，于是我也来写一篇

[P1175 表达式的转换  题目传送门](https://www.luogu.com.cn/problem/P1175)


# 

# 第一部分 解题思路

本题分为两个小问：一个是 _中缀表达式转成后缀表达式_ ，一个是 _计算后缀表达式并将每一步输出_ 。

### 输入：

一个字符数组，用于存储输入的字符串

```cpp
char s[101]={};						//我的数组一般从1开始使用，不使用0
```

### 第一小问：中缀转后缀

首先我们要写一个函数来计算各个运算符的优先级：

```cpp
int pr(char x){
	if(x=='^'){
		return 3;					//乘方运算的优先级最高
	}
	else if(x=='*' || x=='/'){
		return 2;					//乘除的优先级第二
	}
	else if(x=='+' || x=='-'){
		return 1;					//加减的优先级最低
	}
	else{
		return 0;					//将括号的优先级设为0
	}
}
```

之后我们还要写两个栈，一个用来存储符号，一个用来存储结果：

```cpp
int lens=0,lenf=0;					//lens是stack的长度，而不是s的长度，
									//以下的pops()、pushs()同理，特此声明
char stack[101]={},f[101]={};		//stack是符号栈，f是结果栈
									//一些大佬在这里用的是联合体 union ，像我这种蒟蒻就只会用 char ，但是也能做
char pushs(char x){
	stack[++lens]=x;
	return x;
}
char pops(){
	char ret=stack[lens];
	stack[lens--]=0;
	return ret;
}
char pushf(char x){
	f[++lenf]=x;
	return x;
}
char popf(){
	char ret=f[lenf];
	f[lenf--]=0;
	return ret;
}
```

按照题目中所给的运算符号结合顺序，我们不难发现：

对于字符数组中的每一项 $s_{i}$ ：

- 如果 $s_{i}$ 是数字 `0~9` ，那么可以直接压入结果栈；
- 如果 $s_{i}$ 是乘方 `^` ，那么可以直接压入符号栈；
- 如果 $s_{i}$ 是 `+-*/` 中的一个，那么就将符号栈顶部比 $s_{i}$ 优先级高或相同的符号一一弹出，并压入结果栈，然后将 $s_{i}$ 压入符号栈；
- 如果 $s_{i}$ 是左括号 `(` ，那么可以直接压入符号栈；
- 如果 $s_{i}$ 是右括号 `)` ，那么就将符号栈顶部第一个左括号之前的符号一一弹出并压入结果栈，并弹出该左括号。

我们令 $n = |s|$，那么我们就可以遍历 $s_{i} (0 \le i \le n)$，并对每一个 $s_{i}$ 都进行上述的操作，最后将符号栈中剩余的符号都弹出并压入结果栈，第一小问就做完了！~~（撒花）~~  

举个例子，让大家能够理解得更透彻：

$s = $‘ 8\*(2+3\*2+2^2^3)/9 ’

```
i			s[i]			stack			f

1			8				Empty			8
2			*				*				8
3			(				* (				8
4			2				* (				8 2
5			+				* ( +			8 2
6			3				* ( +			8 2 3
7			*				* ( + *			8 2 3
8			2				* ( + *			8 2 3 2
9			+				* ( +			8 2 3 2 * +
10			2				* ( +			8 2 3 2 * + 2
11			^				* ( + ^			8 2 3 2 * + 2
12			2				* ( + ^			8 2 3 2 * + 2 2
13			^				* ( + ^ ^		8 2 3 2 * + 2 2
14			3				* ( + ^ ^		8 2 3 2 * + 2 2 3
15			)				*				8 2 3 2 * + 2 2 3 ^ ^ +
16			/				/				8 2 3 2 * + 2 2 3 ^ ^ + *
17			9				/				8 2 3 2 * + 2 2 3 ^ ^ + * 9
End			None			Empty			8 2 3 2 * + 2 2 3 ^ ^ + * 9 /
```

自己在心里模拟一遍，就会做第一小问了。

####

**本部分代码：**

```cpp
cin>>s+1;
n=strlen(s+1);
for(int i=1;i<=n;i++){
	if(s[i]>='0' && s[i]<='9'){
		pushf(s[i]);
	}
	else if(s[i]=='^' || s[i]=='('){
		pushs(s[i]);
	}
	else if(s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/'){
		int t=pr(s[i]);
		for(int j=lens;j>=1;j--){
			if(pr(stack[j])<t){
				break;
			}
			else{
				pushf(pops());
			}
		}
		pushs(s[i]);
	}
	else if(s[i]==')'){
		for(int j=lens;j>=1;j--){
			if(stack[j]=='('){
				pops();
				break;
			}
			else{
				pushf(pops());
			}
		}
	}
}
while(lens){
	pushf(pops());
}
for(int i=1;i<=lenf;i++){
	cout<<f[i]<<" ";
}
cout<<endl;
```

### 第二小问：后缀表达式计算和输出

这个就很简单了，做过[P1449 后缀表达式](https://www.luogu.com.cn/problem/P1449)的都会了 ~~（不会的去做一做就会了）~~ ，把 $f$ 中的每个值一一压入到计算栈中，如果是运算符就把当前符号和前两个数弹出，进行运算后再压回去。

这里我用了一个结构体，就可以把数字和字符存在同一个数组里了：

```cpp
struct Node{
	bool is_digit;
	int dg;
	char ch;
};
```

还是刚才那个例子：

$s = $‘ 8 2 3 2 \* + 2 2 3 ^ ^ + \* 9 / ’

```
i			s[i]		calc

1			8			8
2			2			8 2
3			3			8 2 3
4			2			8 2 3 2
5			*			8 2 6
6			+			8 8
7			2			8 8 2
8			2			8 8 2 2
9			3			8 8 2 2 3
10			^			8 8 2 8
11			^			8 8 256
12			+			8 264
13			*			2112
14			9			2112 9
15			/			234
```

有一点需要注意，输出时需要把后面还没有参与运算的部分也输出。

####

**本部分代码：**

```cpp
Node c[101],calc[101];
Node pushc(Node x){
	c[++lenc]=x;
	return x;
}
Node popc(){
	Node ret=c[lenc];
	c[lenc--]=init;							//这里的 init 是一个 Node 变量，init.is_digit = 0，init.dg = 0，init.ch = 0
	return ret;
}
Node pushcalc(Node x){
	calc[++lencalc]=x;
	return x;
}
Node popcalc(){
	Node ret=calc[lencalc];
	calc[lencalc--]=init;
	return ret;
}
void print2(int ii){
	for(int i=1;i<=lencalc;i++){
		if(calc[i].is_digit){
			cout<<calc[i].dg<<" ";
		}
		else{
			cout<<calc[i].ch<<" ";
		}
	}
	for(int i=ii;i<=lenc;i++){
		if(c[i].is_digit){
			cout<<c[i].dg<<" ";
		}
		else{
			cout<<c[i].ch<<" ";
		}
	}
	cout<<endl;
}
for(int i=1;i<=lenf;i++)
{
	char x=f[i];
	Node m;
	if(x=='+' || x=='-' || x=='*' || x=='/' || x=='^'){
		m.is_digit=0;
		m.ch=x;
		m.dg=0;
	}
	else{
		m.is_digit=1;
		m.ch=0;
		m.dg=x-48;
	}
	pushc(m);
}
									//这里我先将 char 类型的 f 转成了 Node 类型的 c ，方便后续存储和计算
for(int i=1;i<=lenc;i++){
	Node m=c[i];
	if(m.is_digit){
		pushcalc(m);
	}
	else{
		int x1,x2;
		Node r;
		r.is_digit=1;
		r.ch=0;
		x1=popcalc().dg;
		x2=popcalc().dg;
		switch(m.ch){
			case '+':
				r.dg=x2+x1;
				break;
			case '-':
				r.dg=x2-x1;
				break;
			case '*':
				r.dg=x2*x1;
				break;
			case '/':
				r.dg=x2/x1;
				break;
			case '^':
				r.dg=1;
				for(int j=0;j<x1;j++){
					r.dg*=x2;				//我知道有一种东西叫做快速幂，但是直接乘这题也能过
				}
		}
		pushcalc(r);
		print2(i+1);
	}
}
```

# 第二部分 AC代码

代码与之前展示的相差无几，就是多了一个`print()`，因此注释不再展示。

理论上中间过程最大可能出现 $2^{31}$ ，所以本来应该开 `long long` ，但是数据比较水，并没有出现 $2^{31}$ ，所以 `int` 就够了。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
struct Node{
	bool is_digit;
	int dg;
	char ch;
};
int n,lens=0,lenf=0,lenc=0,lencalc=0;
char stack[101]={},s[101]={},f[101]={};
Node init,c[101],calc[101];
char pushs(char x){
	stack[++lens]=x;
	return x;
}
char pops(){
	char ret=stack[lens];
	stack[lens--]=0;
	return ret;
}
char pushf(char x){
	f[++lenf]=x;
	return x;
}
char popf(){
	char ret=f[lenf];
	f[lenf--]=0;
	return ret;
}
Node pushc(Node x){
	c[++lenc]=x;
	return x;
}
Node popc(){
	Node ret=c[lenc];
	c[lenc--]=init;
	return ret;
}
Node pushcalc(Node x){
	calc[++lencalc]=x;
	return x;
}
Node popcalc(){
	Node ret=calc[lencalc];
	calc[lencalc--]=init;
	return ret;
}
int pr(char x){
	if(x=='^'){
		return 3;
	}
	else if(x=='*' || x=='/'){
		return 2;
	}
	else if(x=='+' || x=='-'){
		return 1;
	}
	else{
		return 0;
	}
}
void print(){
	for(int i=1;i<=lenf;i++){
		cout<<f[i]<<" ";
	}
	cout<<endl;
}
void print2(int ii){
	for(int i=1;i<=lencalc;i++){
		if(calc[i].is_digit){
			cout<<calc[i].dg<<" ";
		}
		else{
			cout<<calc[i].ch<<" ";
		}
	}
	for(int i=ii;i<=lenc;i++){
		if(c[i].is_digit){
			cout<<c[i].dg<<" ";
		}
		else{
			cout<<c[i].ch<<" ";
		}
	}
	cout<<endl;
}
int main(){
	init.ch=0;
	init.dg=0;
	init.is_digit=0;
	cin>>s+1;
	n=strlen(s+1);
	for(int i=1;i<=n;i++){
		if(s[i]>='0' && s[i]<='9'){
			pushf(s[i]);
		}
		else if(s[i]=='^' || s[i]=='('){
			pushs(s[i]);
		}
		else if(s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/'){
			int t=pr(s[i]);
			for(int j=lens;j>=1;j--){
				if(pr(stack[j])<t){
					break;
				}
				else{
					pushf(pops());
				}
			}
			pushs(s[i]);
		}
		else if(s[i]==')'){
			for(int j=lens;j>=1;j--){
				if(stack[j]=='('){
					pops();
					break;
				}
				else{
					pushf(pops());
				}
			}
		}
	}
	while(lens){
		pushf(pops());
	}
	for(int i=1;i<=lenf;i++)
	{
		char x=f[i];
		Node m;
		if(x=='+' || x=='-' || x=='*' || x=='/' || x=='^'){
			m.is_digit=0;
			m.ch=x;
			m.dg=0;
		}
		else{
			m.is_digit=1;
			m.ch=0;
			m.dg=x-48;
		}
		pushc(m);
	}
	print();
	for(int i=1;i<=lenc;i++){
		Node m=c[i];
		if(m.is_digit){
			pushcalc(m);
		}
		else{
			int x1,x2;
			Node r;
			r.is_digit=1;
			r.ch=0;
			x1=popcalc().dg;
			x2=popcalc().dg;
			switch(m.ch){
				case '+':
					r.dg=x2+x1;
					break;
				case '-':
					r.dg=x2-x1;
					break;
				case '*':
					r.dg=x2*x1;
					break;
				case '/':
					r.dg=x2/x1;
					break;
				case '^':
					r.dg=1;
					for(int j=0;j<x1;j++){
						r.dg*=x2;
					}
			}
			pushcalc(r);
			print2(i+1);
		}
	}
	return 0;
}
```

**完结撒花！**

# 

这篇题解所用到的语法都很基础，可能不如大佬们的高级语法方便，但是绝对方便理解也方便写 ~~（对于和我一样的蒟蒻而言，大佬们请忽略这句话）~~ 。

这是本蒟蒻的第一篇题解，如果您觉得还可以的话麻烦您点上一个免费的赞，谢谢！

如果题解有什么错误，请直接指出！

---

## 作者：rui_er (赞：28)

本题题解貌似已经比较多了，但是我在本题卡了一段时间，写出了好几处错误，因此写一篇题解梳理一下思路。

题意：模拟 `+-*/^()` 以及数字初始为一位数的后缀表达式运算过程。

**注意这里有一个运算符 `^`，我一开始就没有注意到，然后样例也没有，硬是对着代码和题面看了半天才发现！**

---

思路：

模拟。先转化为后缀表达式，再模拟运算过程，逐步求解。

**子问题一：中缀表达式转后缀表达式。**

我们考虑运算符的优先级，可以对于每个运算符给定一个数为优先级，方便后续比较。这里，我设置的优先级为：

```cpp
int priority(char c) {
	if(c == '^') return 3;
	if(c == '*' || c == '/') return 2;
	if(c == '+' || c == '-') return 1;
	if(c == '(' || c == ')') return 0;
	throw "WA! Unexpected operator";
}
```

其中 throw 行是为了防止出现错误添加的异常，实际上也并没有进行处理，可以忽略。

然后考虑转化，遍历原字符串每一位，按照如下规则处理：

- 如果是数字，直接输出到后缀表达式。
- 如果是左括号 `(`，可以压进符号栈中。
- 如果是右括号 `)`，将符号栈中符号弹出到后缀表达式，直到遇到第一个左括号 `(`，并将其弹出。
- 如果是乘方 `^`，可以压进符号栈中。
- 如果是加减乘除 `+-*/`，利用上面的优先级，将符号栈中符号弹出到后缀表达式，直到遇到第一个优先级低于（不含）它的符号，然后将其压进符号栈。

那么问题来了，怎么存储后缀表达式呢？这里我使用了一个结构体 `struct`，一个指示变量表示这个是数字还是符号，一个联合体 `union` 来存储具体内容，然后使用向量容器 `vector` 来按顺序存储后缀表达式。

结构体定义和转换后缀表达式部分代码如下：

```cpp
struct Node {
	int type;
	union {
		int x;
		char op;
	}data;
	Node() {}
	Node(int x) : type(1) {data.x = x;}
	Node(char c) : type(0) {data.op = c;}
};
void toSuffix() {
	rep(i, 0, n-1) {
		if(isdigit(c[i])) v.push_back(Node(int(c[i]^'0')));
		else {
			if(c[i] == '(') op.push(c[i]);
			else if(c[i] == ')') {
				while(op.top() != '(') {
					v.push_back(Node(char(op.top())));
					op.pop();
				}
				op.pop();
			}
			else if(c[i] == '^') op.push(c[i]);
			else {
				while(!op.empty() && priority(op.top()) >= priority(c[i])) {
					v.push_back(Node(char(op.top())));
					op.pop();
				}
				op.push(c[i]);
			}
		}
	}
	while(!op.empty()) {
		v.push_back(Node(char(op.top())));
		op.pop();
	}
}
```

**子问题二：模拟运算步骤得出结果。**

这部分比较简单，做过 [P1449 后缀表达式](/problem/P1449) 的同学都应该基本会了。我们按顺序读取后缀表达式内存储的数据，如果是数字则压入数字栈，否则弹出两个数字做运算后压回。**注意运算的顺序，应该是第二个弹出的数作为被减数（加数、乘数、被除数、底数），第一个弹出的数作为减数（加数、乘数、除数、指数）！**

然后每处理一个运算符，输出一次即可。

这部分代码：

```cpp
void prtall() {
	int sz = v.size();
	rep(i, 0, sz-1) {
		if(v[i].type) printf("%d%c", v[i].data.x, " \n"[i==sz-1]);
		else printf("%c%c", v[i].data.op, " \n"[i==sz-1]);
	}
}
void prtsec(int u) {
	int sz = v.size();
	while(!s.empty()) {t.push(s.top()); s.pop();}
	while(!t.empty()) {printf("%d ", t.top()); s.push(t.top()); t.pop();}
	rep(i, u, sz-1) {
		if(v[i].type) printf("%d ", v[i].data.x);
		else printf("%c ", v[i].data.op);
	}
	puts("");
}
void calc() {
	prtall();
	int sz = v.size();
	rep(i, 0, sz-1) {
		if(v[i].type) s.push(v[i].data.x);
		else {
			int a, b; char _;
			b = s.top(); s.pop();
			a = s.top(); s.pop();
			_ = v[i].data.op;
			if(_ == '+') s.push(a+b);
			else if(_ == '-') s.push(a-b);
			else if(_ == '*') s.push(a*b);
			else if(_ == '/') s.push(a/b);
			else s.push(qpow(a, b));
			prtsec(i+1);
		}
	}
}
```

这就是本题的主体代码，我也取得了 AC，代码长度 107 行、共 2441 个字符（本地统计），可以算是一个中模拟。

由于主要代码在上面都贴过了，为了防止影响篇幅和版面，将完整代码放到 [云剪贴板](/paste/713luey5)。

完结撒花！

---

## 作者：icaijy (赞：9)

~~蒟蒻的第一篇题解，请多多关照。~~

# 前言
这个题目 dalao 们有的是用二叉树之类的做的，因为我一个蒟蒻，所以我只好使用 `if else` 之类的代码来模拟，所以代码比较长。但是这篇题解比较适合初学者，dalao 参考一下就彳亍了。

# 题意
相信各位同学来到这道题一定已经了解了后缀表达式的相关知识吧！如果您还不太了解后缀表达式的相关计算，可以前往[这篇](https://blog.csdn.net/antineutrino/article/details/6763722)文章了解一下。

这题其实有 2 个子任务：
- **中缀转后缀。**
- **后缀计算，输出计算的每一步。**

# 中缀转后缀
在我刚刚给的那篇文章里已经给出了比较详细中缀转后缀的步骤。简单总结一下发现应该这样的步骤：

ps：在表达式的计算几乎全部是**栈**的，不过我为了输出方便，**将一些栈改成了双向队列** `deque` 来存储，但**本质还是一个栈**。（下面我还是会使用“栈”代替 `deque` 写这篇题解）。

1. 数字：直接进入 $s2$ 栈。
2. 括号：
    * 左括号 $($ 直接进 $s1$ 栈。
    * 右括号 $)$ 则一直弹出 $s1$ 的运算符到 $s2$，直到碰到左括号 $($。
3. 运算符：一直弹出 $s1$ 栈顶大于等于自己运算级的运算符到 $s2$，然后入栈。

扫描完后一直弹出 $s1$ 剩余的运算符到 $s2$。

当然了，这道题也有一些恶心的地方。比如**乘方** ^ 是**从右向左结合的**，所以这里的 ^ 直接进 $s1$ 栈。而**不用弹出栈顶和 ^ 运算级相同的运算符**。

还有，因为我选择把运算符和数字存到一起，所以肯定会出现冲突的情况。题目里说了每一步不会超过 $2^{31}$，所以我选择开 `long long`。**每个运算符使用一个大于 $2^{31}$ 的数来存储**，输出的时候解过来就彳亍了。

这一部分的代码：
```cpp
int fh[256];
// 符号对照表 
// "m" 是2的31次方
char fh2[17]; 
string a; // 题目的字符串
stack<long long> s1;
deque<long long> s2;
deque<long long> s3;

// 初始化成后缀 
void init() {
	for (int i=0;i<a.length();i++) {
		int n=fh[a[i]];
		if (n>=0 && n<=9) s2.push_back(n);
		//是数字直接入栈 
		else {
			// 是符号 
			// (
			if (n==16) {
				s1.push(n);
				continue;
			}
			if (n==fh['^']) {
				// ^ 
				s1.push(n);
				continue;
			}
			// )
			if (n==17) {
				while (s1.top()!=16) {
					// 一直循环直到 “(” 
					s2.push_back(s1.top()+m);
					// 弹出栈顶
					s1.pop();
				}
				s1.pop();
				// 弹出 (
			} else if (n==fh['+'] || n==fh['-']) {
				// +或- 
				while (!s1.empty() && (s1.top()==fh['+'] || s1.top()==fh['-'] || s1.top()==fh['*'] || s1.top()==fh['/'] || s1.top()==fh['^'])) {
					s2.push_back(s1.top()+m);
					// 弹出栈顶
					s1.pop();
				}
				s1.push(n);
			} else if (n==fh['*'] || n==fh['/']) {
				// *或/ 
				while (!s1.empty() && (s1.top()==fh['*'] || s1.top()==fh['/'] || s1.top()==fh['^'])) {
					s2.push_back(s1.top()+m);
					// 弹出栈顶
					s1.pop();
				}
				s1.push(n);
			}
		}
	}
	while (!s1.empty()) {
		s2.push_back(s1.top()+m);
		s1.pop();
	}
}

```

# 输出中缀的计算过程
首先，这里的计算是要输出过程的，所以每计算一次就得等下一轮再计算。

计算简单来说，就是如果扫描到了**运算符**，就对栈顶的两个数弹出做运算之后再压进去。这样一直循环直到栈只剩一个元素就结束了。后缀表达式应当将栈顶的**第一个元素**作为**第二个运算符**，即减法里面的减数。栈顶的**第二个元素**作为**第一个运算符**，即减法里的被减数。

所以实现的办法是：一直循环知道 $s2$ 只剩一个元素，然后一直把 $s2$ 栈顶的元素弹出并压入 $s3$，如果 $s3$ 栈顶的元素是运算符，则弹出 $s3$ 栈顶的两个数做运算，然后将运算的结果压入 $s3$，标记变量 $cal$ 为 `true` 以记录本轮计算过了。压入剩余元素，用 $s3$ 更新 $s2$ 并且输出栈后，进行下一轮。

这一部分的代码：
```cpp
// 这个函数是判断是不是只有一个元素在栈里面
bool one(deque<long long> s) {
	s.pop_back();
	return s.empty();
}
// 计算 
void calc() {
	int i2,i1;
	while (!one(s2) && !s2.empty()) {
		while (!s3.empty()) s3.pop_back();
		// 清空s3 
		bool cal=false;
		// 算过1次就不算了 
		// 一直计算直到没了 
		while (!s2.empty()) {
			s3.push_back(s2.front());
			s2.pop_front();
			// 如果是运算符 
			long long b=s3.back();
			if (b>m+1 && !cal) {
				s3.pop_back();
				cal=true;
				// 标记算过了 
				i2=s3.back();
				s3.pop_back();
				i1=s3.back();
				s3.pop_back();
				// 分类讨论运算符
				if (b==11+m) {
					s3.push_back(i1+i2);
				}
				if (b==12+m) {
					s3.push_back(i1-i2);
				}
				if (b==13+m) {
					s3.push_back((i1*i2));
				}
				if (b==14+m) {
					s3.push_back(i1/i2);
				}
				if (b==15+m) {
					s3.push_back(pow(i1,i2));
				}
			}
		}
		codq(s3);
		s2=s3;
		// 更新
	}
}
```

# 输出栈
当我们栈都弄好之后，就是输出的时候了。输出的话就是不断抽出队列的前端 `s.front()`。因为后缀是要逆序输出的，队列比较方便。输出队列的前端，就是逆序输出了。如果是运算符就将运算符解开（我用了一个数字来存）然后输出。碰到数就直接输出就行了。


------------

这部分的代码：
```cpp
// 输出双向队列 
void codq(deque<long long> s) {
	while (!s.empty()) {
		if (s.front()>m) cout << fh2[s.front()-m] << " "; else cout << s.front() << " ";
		s.pop_front();
	}
	cout << endl;
}
```

# 总结
总结一下遇到的问题吧：
1. **RE**：我刚写的时候总是 RE，原因是抽栈顶的运算符要判断运算级，然后要执行一次 `stack.top()`，如果栈是空的，那么就会 RE，所以以后写这种一定要先判断一下栈是否不为空。
2. 关于**运算符**。我后来被怎么存运算符困扰了很久。不过后来我发现其实开个 long long 不仅轻松的完成了任务，还完全不影响 MLE，所以大多数题开 `long long` 完全是没事的。

ps：`long` 是没用的！它的范围和 `int` 一样！

# 最终代码
大家最爱的代码环节！
```cpp
#include <iostream>
#include <queue>
#include <stack>
#include <deque>
#include <cstring>
#include <math.h>
using namespace std;
/*
0:+
1:-
2:*
3:/
4:^
*/
int fh[256];
// 符号对照表 
char fh2[17];
string a;
stack<long long> s1;
// 初始用 
deque<long long> s2;
// 初始用 
deque<long long> s3;
// 计算用 双向队列，可以删掉前面的 , 因为运算符和数字要区分开，所以开long 
long long m;
// 2的31次方-1，存运算符 
// cout deque
// 输出双向队列 
void codq(deque<long long> s) {
	while (!s.empty()) {
		if (s.front()>m) cout << fh2[s.front()-m] << " "; else cout << s.front() << " ";
		s.pop_front();
	}
	cout << endl;
}
// 初始化成后缀 
void init() {
	for (int i=0;i<a.length();i++) {
		int n=fh[a[i]];
		if (n>=0 && n<=9) s2.push_back(n);
		//是数字直接入栈 
		else {
			// 是符号 
			// (
			if (n==16) {
				s1.push(n);
				continue;
			}
			if (n==fh['^']) {
				// ^ 
				s1.push(n);
				continue;
			}
			// )
			if (n==17) {
				while (s1.top()!=16) {
					// 一直循环直到 “(” 
					s2.push_back(s1.top()+m);
					// 弹出栈顶
					s1.pop();
				}
				s1.pop();
				// 弹出 (
			} else if (n==fh['+'] || n==fh['-']) {
				// +或- 
				while (!s1.empty() && (s1.top()==fh['+'] || s1.top()==fh['-'] || s1.top()==fh['*'] || s1.top()==fh['/'] || s1.top()==fh['^'])) {
					s2.push_back(s1.top()+m);
					// 弹出栈顶
					s1.pop();
				}
				s1.push(n);
			} else if (n==fh['*'] || n==fh['/']) {
				// *或/ 
				while (!s1.empty() && (s1.top()==fh['*'] || s1.top()==fh['/'] || s1.top()==fh['^'])) {
					s2.push_back(s1.top()+m);
					// 弹出栈顶
					s1.pop();
				}
				s1.push(n);
			}
		}
	}
	while (!s1.empty()) {
		s2.push_back(s1.top()+m);
		s1.pop();
	}
}
// 栈（此处我用的是队列因为输出方便）是否只有1个元素，如果只有一个那就结束了 
bool one(deque<long long> s) {
	s.pop_back();
	return s.empty();
}
// 计算 
void calc() {
	int i2,i1;
	while (!one(s2) && !s2.empty()) {
		while (!s3.empty()) s3.pop_back();
		// 清空s3 
		bool cal=false;
		// 算过1次就不算了 
		// 一直计算直到没了 
		while (!s2.empty()) {
			s3.push_back(s2.front());
			s2.pop_front();
			// 如果是运算符 
			long long b=s3.back();
			if (b>m+1 && !cal) {
				s3.pop_back();
				cal=true;
				// 标记算过了 
				i2=s3.back();
				s3.pop_back();
				i1=s3.back();
				s3.pop_back();
				// 分类讨论运算符
				if (b==11+m) {
					s3.push_back(i1+i2);
				}
				if (b==12+m) {
					s3.push_back(i1-i2);
				}
				if (b==13+m) {
					s3.push_back((i1*i2));
				}
				if (b==14+m) {
					s3.push_back(i1/i2);
				}
				if (b==15+m) {
					s3.push_back(pow(i1,i2));
				}
			}
		}
		codq(s3);
		s2=s3;
		// 更新
	}
}
int main() {
	m=pow(2,31)-1;
	// 建表 
	fh['+']=11;
	fh['-']=12;
	fh['*']=13;
	fh['/']=14;
	fh['^']=15;
	fh['(']=16;
	fh[')']=17;
	fh2[11]='+';
	fh2[12]='-';
	fh2[13]='*';
	fh2[14]='/';
	fh2[15]='^';
	for (int i=0;i<=9;i++) {
		fh[i+'0']=i;
		fh2[i]=i+'0';
	}
	cin >> a;
	init();
	// 输出第一轮 
	codq(s2);
	calc();
	return 0;
}
```






---

## 作者：technopolis_2085 (赞：7)

调了 1 天，终于调出来了！

没有用栈就过了这道题。

本方法极其需要耐心，也很考验编程能力和查错能力，慎用。


------------

### P1175 表达式的转换 题解

本题是道大模拟，主要步骤：

1. 将题目输入的中缀表达式转换成后缀表达式。
2. 计算。

------------
### 1. 将中缀表达式转换成后缀表达式

方法：

采用分治的思想，每一次找到优先级最低的一个运算，将它分成两半，左右两边分治，求出后缀表达式，最后加上这个运算符。

------------
### 2. 计算

这部分我认为比第一部分难（如果使用栈的话会很简单）。

方法：

用两个字符串交替模拟该过程。

找到第一个运算符，再找到它之前的两个数，将这两个数和这个运算符进行运算，结果再放回字符串中。

注意：运算过程中可能会出现负数。

具体细节看代码吧。

------------

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
char s[maxn];
int sum[maxn];//用来判断一个字符是否在括号里
int n;
string ans;
//是否是操作符
bool isop(char ch){
	if (ch=='^'||ch=='*'||ch=='/'||ch=='+'||ch=='-') return true;
	return false;
}
//是否是数字字符
bool isnum(char ch){
	return ch>='0'&&ch<='9';
}
//分治的思想求后缀表达式 复杂度趋近于平方级别
void build(int l,int r){
	if (l==r){
		ans+=s[l];
		ans+=" ";
		return;
	}
	if (l>r) return;	
	sum[l-1]=0;
	for (int i=l;i<=r;i++){
		sum[i]=sum[i-1]; 
		if (s[i]=='(') sum[i]++;
		else if (s[i]==')') sum[i]--;
	}
	int mi=1e9+7,id=-1;
	for (int i=l;i<=r;i++){
		if (sum[i]) continue;
		if (s[i]=='^'){//注意乘方是从右向左结合
			if (mi>3){
				mi=3;
				id=i;
			}
		}else if (s[i]=='*'||s[i]=='/'){
			if (mi>=2){
				mi=2;
				id=i;
			}
		}else if (s[i]=='+'||s[i]=='-'){
			if (mi>=1){
				mi=1;
				id=i;
			}
		}
	}//找到第运算级最低的一个运算符
    //如果全部在括号里
	if (id==-1){
		build(l+1,r-1);//去掉括号，递归求解
		return;
	}
	build(l,id-1);//左边
	build(id+1,r);//右边
	ans+=s[id];//加上该运算符
	ans+=" ";
}
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);	
	build(1,n);
	printf("%s\n",ans.c_str());
	int cnt=0;
	for (int i=0;i<ans.length();i++){
		if (isop(s[i])) cnt++;
	}
	string str; 
   //有cnt个运算符，计算cnt次
   //输出的是str串，ans串作为上一次的答案，用于构造下一次的后缀表达式使用
	while (cnt){
		cnt--;
		int flag=0;//标记是否做过运算
		str="";
		int num=0;//此次的运算结果
       
      //此部分极其容易出错，建议仔细思考后再提交

		for (int i=0;i<ans.length();i++){
			if ((isop(ans[i])&&!isnum(ans[i+1]))&&flag==0){
				flag=1;//做过运算了
				ans[i-1]='.';//这个运算符前面的空格标记掉
				int j=i-2;//数字的最后一位	
				int nega_a=1,nega_b=1;//注意可能会有负数
				while (j>=0&&ans[j]>='0'&&ans[j]<='9') j--;	//将j移到这个数字的开头
				if (ans[j]=='-'){
					ans[j-1]='.';
					ans[j]='.';
					nega_b=-1;
				}//负数
				ans[j]='.';
				int b=0,a=0;	
				j++;
				while (j<ans.length()&&ans[j]>='0'&&ans[j]<='9'){
					b=b*10+(ans[j]-'0');
					ans[j]='.';//将这些字符标记掉
					j++;
				}//求出b
				j=i-2;
				while (j>=0&&ans[j]!=' ') j--;//移到数字的开头
				j++;
				if (ans[j]=='-'){
					ans[j]='.';
					nega_a=-1;
					j++;
				}//负数
				while (j<ans.length()&&ans[j]>='0'&&ans[j]<='9'){
					a=a*10+(ans[j]-'0');
					ans[j]='.';//将这些字符标记掉
					j++;
				}//求出a
				b*=nega_b;
				a*=nega_a;
				if (ans[i]=='+') num=a+b;
				else if (ans[i]=='-') num=a-b;
				else if (ans[i]=='*') num=a*b;
				else if (ans[i]=='/') num=a/b;
				else if (ans[i]=='^') num=(int)pow(a,b);//运算
				ans[i]='.';//运算符标记掉
				break;
			}
		}
      //替换
		for (int i=0;i<ans.length();i++){
			if (ans[i]=='.'){
				while (i<ans.length()){
					if (ans[i]>='0'&&ans[i]<='9') break;
					if (isop(ans[i])) break;	
					i++;
				}//向右移动到第一个没有被标记，且是数字或运算符的字符
				i--;//移到这个数字或运算符之前
				vector<int> k;
				k.clear();
				if (num<0){
					str+="-";
					num=-num;
				}
				while (num>0){
					k.push_back(num%10);
					num/=10;
				}//将运算结果倒序放入vector中
				reverse(k.begin(),k.end());//k中存的是倒过来的，应该将其翻转。
				for (int x=0;x<(int)k.size();x++) str+=(k[x]+'0');//放入字符串中
				str+=" ";
			}
			else str+=ans[i];
		}
		printf("%s\n",str.c_str());                                                                                                                                                                                                                                  
		ans="";
		ans+=str;
	}
	return 0;
}
```



------------
此题运算过程中有可能会出现负数，请大家注意。

给大家提供一个负数样例，仅供参考：

<https://www.luogu.com.cn/paste/l9xjcmp1>

---

## 作者：NeosKnight (赞：7)

全真模拟AC 不要问我怎么有毅力这样做出来 （至今为止我写过的最长的代码就这题了）


1.中转后   数字直接输出 每在表达式中插入一个算符就输出他（记得加空格） 最后记得栈中算符全部出栈并依次输出

2.预先计算出需要运算的次数（即算符个数）

3.从前往后扫 扫到一个算符就从他前面找两个数运算并将找过的位置置为空，再将得出的结果写回去（这里比较复杂，具体看代码）

然后输出；（还要注意负数的处理，我写的也很麻烦）

4.继续从原来的位置扫描，重复操作；




                
                
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
char sz[100001];
char hz[100001];
char stack[100001];
int top=0;
inline int doit(int x,int y,char how); 
inline bool cmp(char ch,char cr)
{
    if(ch==')'&&cr!='(') return 0;//右括号在没有遇到左括号时优先度最低；
    else if(ch==')'&&cr=='(') return 1;//为括号的情况优先考虑 （两括号相遇要删除） 
    if(cr=='(') return 1;//在没有找到右括号之前左括号不能动； 
    if(ch=='+'||ch=='-') return 0;//加减法优先度一定不比之前的任何算符高； 
    if(ch=='^') return 1; 
    if(cr=='^') return 0;//'^'在所有除括号外的算符中优先度最高;
    if((ch=='*'||ch=='/'||ch=='^')&&(cr=='+'||cr=='-')) return 1;//剩下的就只有当 ch （要入栈的算符）为乘除时  cr 为加减时 ch 优先度才比cr（top指向的算符）高 
    return 0;
}
void push(char ch,int &l)
{
    if(ch=='(')
    {
        stack[++top]=ch;
    }
    else {
        while(!cmp(ch,stack[top])&&stack[top]!='@')//未成功匹配到合适位置且未到栈底则top减1出栈 
        {
            if(stack[top]!='('&&stack[top]!=')')
            {hz[++l]=stack[top];cout<<stack[top]<<" ";}//每从栈中取出一个算符 就要输出（也可以最后再扫一遍，这样可能更方便） 
            top--;
        }
        stack[++top]=ch;//找到合适的位置放置运算符 
        if(stack[top]==')'&&stack[top-1]=='(')
        top-=2;//抵消；
    }
}
int main()
{
    scanf("%s",sz);
    stack[top]='@';
    int len=strlen(sz);int j=0;
    //hz[++j]='.';hz[++j]='.';hz[++j]='.';//防止出错多加几个空格 
    for(int i=0;i<len;i++)
    {
        if(sz[i]>='0'&&sz[i]<='9')
        {
            hz[j]=sz[i];cout<<sz[i]<<" ";
        }
        else if(sz[i]=='-'||sz[i]=='+'||sz[i]=='*'||sz[i]=='^'||sz[i]=='/')
        {
            hz[j]='.';//标记 (后缀表达式中)
            hz[++j]='.';
            hz[++j]='.';hz[++j]='.';
            push(sz[i],j);
        }
        else if(sz[i]=='('||sz[i]==')')//括号不输出 
        {
            hz[j]='.';
            hz[++j]='.';
            hz[++j]='.';hz[++j]='.';//多放几个空格 
            push(sz[i],j);    
        }
        j++; 
    }
    while(top!=0){
        if(stack[top]!='('&&stack[top]!=')') 
        {hz[j++]=stack[top];cout<<stack[top]<<" ";}//输出算符
        top--;//剩余算符全部出栈
    }
    top=0;len=strlen(hz);
    int tot=0;
    for(int i=0;i<len;i++) {
        if(hz[i]=='+'||hz[i]=='*'||hz[i]=='-'||hz[i]=='^'||hz[i]=='/') tot++;//计算算符个数，确定计算次数； 
    }
    int head=0;j=0;
    cout<<endl;
    while(tot)
    {
        tot--;
        for(;head<len;head++)//头指针，指向算符，进行运算 (注意不要初始化，之后可以接着用)
        {
            if(hz[head]=='+'||hz[head]=='*'||hz[head]=='-'||hz[head]=='^'||hz[head]=='/')
            {
                int a=0,b=0;//寻找两个运算数
                int p=head-1;while(hz[p]=='.') p--;//找到第一个数字 
                int l=1;//存储一个数有多少位； 
                while(233&&p>=0)
                {
                    if(hz[p]=='.') break;//找到了退出
                    if(hz[p]=='-')
                    {a=-a;hz[p]='.';p--;break;}
                    a+=(hz[p]-'0')*l;
                    l*=10;
                    hz[p]='.';//使用过的标为空（就不往前挪了，浪费时间，也没必要） 
                    p--;
                }
                l=1;
                while(hz[p]=='.') p--;//找第二个数； 
                while(233&&p>=0)
                {
                    if(hz[p]=='.') break;
                    if(hz[p]=='-')
                    {b=-b;hz[p]='.';p--;break;}
                    b+=(hz[p]-'0')*l;l*=10;
                    hz[p]='.';
                    p--; 
                }
                int ans=doit(b,a,hz[head]);//后找到的数要放在前面！（因为是从后往前扫） 
                hz[head]='.';//标为空
                if(tot==0)
                {
                    cout<<ans<<endl;return 0;
                } 
                for(int q=0;q<len;q++)
                {
                    if(q==head) {cout<<ans<<" ";continue;}
                    if(hz[q]=='.') continue;
                    if(hz[q]=='-'&&q<=head) {
                        cout<<"-";continue;
                    }
                    if(hz[q]>='0'&&hz[q]<='9')
                    {
                        while(hz[q]>='0'&&hz[q]<='9'&&q<len)
                        {
                            cout<<hz[q];
                            q++;
                        }
                        cout<<" ";
                        q--;//for会加上去；
                    }
                    else cout<<hz[q]<<" ";
                }
                cout<<endl;
```
/*********************把数给填上去*************************/
                
            
```cpp
                bool fu=false;if(ans<0) {fu=true;ans*=-1;}
                if(ans==0){
                    hz[head-1]='0';
                }
                else
                {
                    int q;
                    for(q=head-1;hz[q-1]=='.'&&ans!=0;q--) 
                    {
                        hz[q]=ans%10+'0';
                        ans/=10;
                    }
                    if(fu==true){
                        hz[q]='-';
                    }
                }
                break;
            }
        }
    }
}
inline int doit(int x,int y,char how)//运算
{
    int sum=0;
    switch(how)
    {
        case '*':
            sum=x*y;return sum;
        case '-':
            sum=x-y;return sum;
        case '+':
            sum=x+y;return sum;
        case '/':
            sum=x/y;return sum;
        case '^':
            sum=1;
            for(int i=1;i<=y;i++)
            {
                sum*=x;
            }
            return sum;
        default: return 0;
    }
}
```

---


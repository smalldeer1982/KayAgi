# [蓝桥杯 2025 省 A 第二场] 栈与乘积

## 题目背景

目前测试数据可能较水，我们之后会加强数据。

## 题目描述

给定一个栈，给出若干次如下类型的操作：

1. $1 \ x$: 将 $x$ 加入栈顶。
2. $2$: 将栈顶的数弹出（如果栈是空的，则什么都不做）。
3. $3 \ y$: 查询栈内的最顶端 $y$ 个数的乘积。如果大于等于 $2^{32}$，输出 `OVERFLOW`。如果栈内不足 $y$ 个数，输出 `ERROR`。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$Q \leq 5000$；
- 对于所有评测用例，$1 \leq Q \leq 10^5$，$0 \leq x < 2^{30}$，$1 \leq y < 2^{30}$。

## 样例 #1

### 输入

```
9
1 65536
1 65536
3 2
3 3
2
1 1024
1 2
3 2
3 3```

### 输出

```
OVERFLOW
ERROR
2048
134217728```

# 题解

## 作者：张英毛 (赞：9)

# 双栈模拟即可
大佬们都用线段树，退休 OIer 在考场上不想写。
所以强行模拟了一下，私以为是可行的，敬请斧正。
## 想法
### 将入栈元素分为三类：
  - $0$。
  - $1$。
  - 其他正整数。
### 为什么要这么分类呢？
如果按照题意直接去模拟，对于操作 $3$ 会超时，超时的原因就是因为 $0$ 和 $1$ 的存在！针对操作 $3$，我们做如下讨论：
- 普普通通的**其他正整数**：累乘到 $2^{32}$，最多需要 $32$ 次罢了，常数而已！——不需要特殊处理。
- 毫无意义的**数字 $1$**：对它做乘法，对答案毫无贡献，反而会导致超时！——数字 $1$ 不配入栈。
- 毁天灭地的**数字 $0$**：如果累乘区间里有数字 $0$，那么其他数字都不再有意义！——数字 $0$ 单独处理。
## 思路
1. 创建两个栈（普通栈、零栈）去模拟题意中的一个栈（实际栈）：
    - **普通栈**：存放其他正整数及其在实际栈中的位置，也就是普通栈的入栈元素是数对<数值，位置>。
    - **零栈**：存放数字 $0$ 在实际栈中的位置。
    - **实际栈**:只维护其栈顶指针 $top$ 即可。
    - 那么没有记录的就是毫无意义的数字 $1$ 了。
2. 对于操作 $1$，就分门别类的入栈就行了，该去哪去哪。
3. 对于操作 $2$，出栈时先判断那两个栈的栈顶元素与当前要出实际栈的栈顶位置是不是一致，如果一致就一块出栈；否则说明要出栈的是数字 $1$，只更改实际栈的栈顶即可。
4. 对于操作 $3$：
   - 先判断是否 $y \le top$，如果否，则输出 `ERROR`。
   - 再根据零栈的栈顶元素，判断数字 $0$ 是否在实际栈的前 $y$ 个元素中，如果是，则输出 $0$。
   - 然后累乘普通栈的栈顶前几个元素计算答案就可以了，根据元素的位置信息就可判断其是否在实际栈的前 $y$ 个元素中，并且最多累乘 $32$ 次就会超出大小限制，如果超出限制则输出 `OVERFLOW`，否则就输出累乘的结果。
## 时间复杂度：$O(Q)$
- 操作 $1$：$O(1)$。
- 操作 $2$：$O(1)$。
- 操作 $3$：最多累乘 $32$ 次。
## 实现：
```
#include<iostream>
#include<cstring>
#include<string>
using namespace std;
struct lp{
	long long val;
	int pos;
}a[100005];
int Q,op,y,top,cnt,zero[100005],tz;
long long ans,x; 
int main() {
	cin>>Q;
	while (Q--) {
		cin>>op;
		if (op==1) {
			cin>>x;
			top++;
			if (x==0) zero[++tz] = top; //零 入栈 
			else if (x!=1) {  //非1正整数  入栈 
				cnt++;
				a[cnt].val=x;
				a[cnt].pos=top;	
			}
		}
		else if (op==2) {
			if (top) {
				if (top==zero[tz]) { //零 出栈 
					top--;
					tz--;
				}
				else if (top==a[cnt].pos) {//非1正整数 出栈 
					top--;
					cnt--;
				} 
				else top--;//壹 出栈 
			}
		}
		else if (op==3) {
			cin>>y;
			if (y>top) cout<<"ERROR"<<endl;
			else if (tz&&top-zero[tz]+1<=y) cout<<0<<endl; //零 
			else {  			//累积 
				ans=1;
				int t=0;
				while (top-a[cnt-t].pos+1<=y) {
					ans*=a[cnt-t].val;
					if (ans>=4294967296) break;
					t++;
				} 
				if (ans>=4294967296) cout<<"OVERFLOW"<<endl;
				else cout<<ans<<endl;
			}
		}
	}
	
}
```

---

## 作者：seika27 (赞：4)

### 思路
题解区有线性大神，还是太厉害。

我们这里考虑易于想到的线段树做法。

根据题目要求我们先拉上来一颗维护乘积的线段树。

不难发现第一第二条操作都是单点修改。

第三条操作是区间查询。

那么这道题和普通线段树的区别在哪里？

其实在于这道题限制如果答案大于等于 $2^{32}$ 就输出 $-1$。

目前也很好处理，你在线段树内有乘法的地方判断一下，如果两数之积不满足了就给一个特殊值，最后输出的时候判一下。

但是在这里我们要考虑诡计多端的 $0$ 的问题。

因为 $0$ 的优先级永远是最高的，不管打没打标记，是不是合法，有 $0$ 就会一直是 $0$。

这里建议定义一个函数来表示乘法。

```cpp
inline int multiply(int x,int y)
{
    if(!x||!y)return 0;
    if(x==-1||y==-1||x*y>=V)return -1;
    else return x*y;
}
```

然后就没有然后，最后给个代码。

### code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
const int V=4294967296ll;
int q;
int cnt;
struct sgt
{
#define lx (x<<1)
#define rx (x<<1|1)
#define mid (L+R>>1)
	int mul[N<<2];
	inline int multiply(int x,int y)
	{
		if(!x||!y)return 0;
		if(x==-1||y==-1||x*y>=V)return -1;
		else return x*y;
	}
	inline void up(int x)
	{
		mul[x]=multiply(mul[lx],mul[rx]);
		return;
	}
	void update(int x,int L,int R,int p,int c)
	{
		if(L==R){mul[x]=c;return;}
		if(p<=mid)update(lx,L,mid,p,c);
		else update(rx,mid+1,R,p,c);
		up(x);
		return;
	}
	int query(int x,int L,int R,int l,int r)
	{
		if(l<=L&&R<=r)return mul[x];
		int lmul=1,rmul=1;
		if(l<=mid)lmul=query(lx,L,mid,l,r);
		if(r>mid)rmul=query(rx,mid+1,R,l,r);
		return multiply(lmul,rmul);
	}
}subaru;
signed main()
{
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
	cin>>q;
	for(int i=1;i<=q;++i)
	{
		int op,x;
		cin>>op;
		if(op==1)
		{
			cin>>x;
			++cnt;
			subaru.update(1,1,q,q-cnt+1,x);
		}
		if(op==2&&cnt)subaru.update(1,1,q,q-cnt+1,0),--cnt;
		if(op==3)
		{
			cin>>x;
			if(x>cnt){cout<<"ERROR\n";continue;}
			int ans=subaru.query(1,1,q,q-cnt+1,q-cnt+x);
			if(ans==-1)cout<<"OVERFLOW\n";
			else cout<<ans<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：l15130880055 (赞：3)

## P12347 [蓝桥杯 2025 省 A 第二场] 栈与乘积 题解

### Problem

给你一个初始为空的序列，实现 $q$ 次操作。

1. 将 $x$ 加入序列末端。
2. 若序列大小大于 $0$，删掉序列最后一个数。
3. 查询序列末尾 $y$ 个数的乘积。如果大于等于 $2^{32}$，输出 `OVERFLOW`。如果栈内不足 $y$ 个数，输出 `ERROR`。

### Solution
能把题目转化到我上面说的这个其实就差不多做完了，也比较好转化。

首先栈不好做到第三种操作，然后注意到答案是栈顶一段区间乘起来的，再加上前面两种操作，很自然的转化为序列问题。

然后就好办了，操作一等价于单点加，操作二等价于序列长度减一，操作二想直接减的话操作一就可以变成单点覆盖。

然后这个单点覆盖区间求乘积就很自然的想到了线段树，然后和我一样懒的可以直接粘下来自己 [P3373](https://www.luogu.com.cn/problem/P3373) 的代码，单点覆盖就是单点乘上 $0$ 再加上 $x$，你会发现这个题其实就是 [P3373](https://www.luogu.com.cn/problem/P3373)。

注意直接做可能会乘爆，线段树里面加几个特判就好。

---

## 作者：Hanggoash (赞：1)

# P12347 栈与乘积 题解

## 题意
维护一个栈，并要求能够实现查询栈顶 $x$ 个元素的乘积的操作。
## 分析
直接遍历查询肯定是会超时的，思考一下然后发现“乘积”对于区间来说是可以合并的，联想到可以用线段树一类的数据结构，至于判断 `OVERFLOW` 的情况，额外维护一个布尔变量，或者是更新的时候加上一个特判都行。下面就用分块做了，假设这里块长取为 $L$。 

### 修改

即入栈和出栈，在加入一个 $x$ 的时候，直接把 $x$ 的值乘入对应块的累乘值，然后判断一下是否超过了题目的限制，如果是的话，那么之后大概率我们不会对这个块的值进行更新了，因为无论如何都是 `OVERFLOW` 的情况。但是有一个例外，如果当前的 $x$ 是 $0$ 的话，那么直接把块的累乘值变成 $0$。也就是说，在入栈 $x$ 的时候，要综合 $x$ 是否非零，和当前是否溢出来判断之后再进行更新。复杂度 $O(1)$。

在出栈的时候，为了避免除以 $0$ 以及一系列比较难以处理的情况，我们将暴力贯彻到底，直接 $O(L)$ 遍历当前块，重构一下这个块的信息也无妨，需要注意的是，如果当前这个块只有栈顶这一个元素，然而又要把这个元素出栈，那么就直接把当前块的累乘值重新设置为 $1$ 。

### 查询

把需要查询的元素分为“块内的”和“零散的”，分别进行遍历累乘即可，不过在遍历的过程中不能一遇到 `OVERFLOW` 就直接退出，如果之后的元素里面有 $0$ 的存在，那就会出错。单次询问的复杂度为 $O(\frac{Q}{L}+L)$ 。

### 总复杂度

由均值不等式，当 $L=\sqrt{Q}$ 的时候，询问的复杂度达到最小的 $O(\sqrt{Q})$ ，这时候对应的入栈操作仍是 $O(1)$，出栈是 $O(\sqrt Q)$，总复杂度为 $O(Q\sqrt{Q})$。

## Code

```c++
#include<bits/stdc++.h>
#define overflow cout<<"OVERFLOW\n";
#define error cout<<"ERROR\n";
using namespace std;
using ll =long long ;
const int N=2e5+10;
const ll LIMIT=1ll<<32ll;
ll val[N],a[N];
ll s[N],top;
int siz;
inline int id(int x){return (x+siz-1)/siz;}
inline void reconstruct(int idx)
{
    int l=(idx-1)*siz+1,r=top-1;
    val[idx]=1;
    for(int i=l;i<=r;++i)
    {
        if(s[i]&&val[idx]>=LIMIT)continue;
        val[idx]*=s[i];
    }
}
inline void query(ll cnt)
{
    if(top<cnt){error;return;}
    int l=top-cnt+1,r=top;
    int lid=id(l),rid=id(r);
    ll ans=1;
    if(lid==rid)
    {
        for(int i=l;i<=r;++i)
        {
            if(ans>=LIMIT&&s[i])continue;
            ans*=s[i];
        }
    }
    else 
    {
        for(int idx=lid+1;idx<rid;++idx)
        {
            if(ans>=LIMIT&&val[idx])continue;
            ans*=val[idx];
        }
        for(int i=l;i<=lid*siz;++i)
        {
            if(ans>=LIMIT&&s[i])continue;
            ans*=s[i];
        }
        for(int i=(rid-1)*siz+1;i<=r;++i)
        {
            if(ans>=LIMIT&&s[i])continue;
            ans*=s[i];
        }
    }
    if(ans<LIMIT)cout<<ans<<'\n';
    else overflow;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int q,opt;cin>>q;
    siz=(int)sqrt(q);
    ll x;
    for(int i=1;i<=q;++i)val[i]=1;
    while(q--)
    {
        cin>>opt;
        if(opt==1)
        {
            cin>>x;
            s[++top]=x;
            int idx=id(top);
            if(x&&val[idx]>=LIMIT)continue;
            val[idx]*=x;
        }
        else if(opt==2)
        {
            if(!top)continue;
            int idx=id(top),tmpid=id(top-1);
            if(idx==tmpid)reconstruct(idx);
            else val[idx]=1;
            top--;
        }
        else
        {
            cin>>x;
            query(x);
        }
    }
    return 0;
}
```

---

## 作者：_zhangcx (赞：1)

题解：P12347 [蓝桥杯 2025 省 A 第二场] 栈与乘积

考虑按题意模拟，手搓一个栈，加入和删除操作一模一样，询问操作暴力枚举栈顶往下的 $y$ 个元素乘起来即为答案，时间复杂度最坏能达到 $O(Q^2)$。

于是考虑优化。注意到把 $y$ 个元素乘起来很费时，我们可以用某种数据结构在线维护一下。

具体地，设栈的序列为 $s$，栈顶下标为 $t$，则：

- 操作 1：$t \gets t + 1$，然后 $s_t \gets s_t \times x$；

- 操作 2：$s_t \gets 1$，然后 $t \gets t - 1$；

- 操作 3：答案为 $\prod _ {i = t} ^ {t - x + 1} s_i$。

不难发现只涉及单点乘、单点修改和区间查询，使用线段树在线维护一下栈的序列的区间乘积即可，时间复杂度 $O(Q \log Q)$。

~~等等真的结束了吗？~~

如何处理溢出？我的处理方法是一段区间乘积是溢出的则标记为 -1，那么要修改一下乘法运算：

$$
\operatorname{mul}(x, y)=\begin{cases}
0 & \text{if } x = 0 \text{ or } y = 0\\
-1 & \text{if } x = -1 \text{ or } y = -1 \text{ or } x \times y \ge 2 ^ {32}\\
x \times y & \text{otherwise}
\end{cases}
$$

代码时间：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long int

const int N = 1e5, LIM = 1LL << 32;
int mul(int x, int y) {
    if (!x || !y) return 0;
    if (x == -1 || y == -1) return -1;
    return x * y >= LIM ? -1 : x * y;
} // 注意溢出，如果溢出则返回-1

int Q, tr[(N << 2) + 20];
#define ls (p << 1)
#define rs (p << 1 | 1)
#define mid (l + r >> 1)
void maintain(int p) { tr[p] = mul(tr[ls], tr[rs]); }
void build(int p = 1, int l = 1, int r = N) {
    if (l == r) return void(tr[p] = 1);
    build(ls, l, mid), build(rs, mid + 1, r);
    maintain(p);
} // 建树，初始化tr[p]=1
void update(int x, int val, int p = 1, int l = 1, int r = N) {
    if (x < l || r < x) return;
    if (l == r) return void(tr[p] = mul(tr[p], val));
    update(x, val, ls, l, mid), update(x, val, rs, mid + 1, r);
    maintain(p);
} // 单点乘法
void modify(int x, int val, int p = 1, int l = 1, int r = N) {
    if (x < l || r < x) return;
    if (l == r) return void(tr[p] = val);
    modify(x, val, ls, l, mid), modify(x, val, rs, mid + 1, r);
    maintain(p);
} // 单点修改
int query(int x, int y, int p = 1, int l = 1, int r = N) {
    if (y < l || r < x) return 1;
    if (x <= l && r <= y) return tr[p];
    int res = query(x, y, ls, l, mid);
    res = mul(res, query(x, y, rs, mid + 1, r));
    return res;
} // 区间查询，以上是线段树板子
main() {
    ios::sync_with_stdio(false), cin.tie(0);
    // freopen("stack.in", "r", stdin);
    // freopen("stack.out", "w", stdout);
    build();
    int idx = 0, op, x;
    for (cin >> Q; Q; Q--) {
        cin >> op;
        if (op == 1) {
            cin >> x;
            update(++idx, x);
        } else if (op == 2) {
            if (idx) modify(idx--, 1); // 有元素时才操作
        } else {
            cin >> x;
            if (idx - x + 1 <= 0) cout << "ERROR\n"; // 元素数量不足
            else {
                int ans = query(idx - x + 1, idx);
                if (ans == -1) cout << "OVERFLOW\n"; // 溢出
                else cout << ans << '\n';
            }
        }
    }
    return 0;
}

```

---

## 作者：W_C_B_H (赞：1)

考虑将栈看作一个数列（栈底对应下标 $1$，栈顶对应下标 $n$，其中 $n$ 为当前栈中数字个数），则操作 $1$ 可以看作将 $n$ 加上 $1$ 后把第 $n$ 个数赋值为 $x$，操作 $2$ 可以看作把 $n$ 减去 $1$（如果 $n=0$ 则不作处理），操作 $3$ 可以看作在操作合法时查询第 $[n-y+1,n]$ 个数字的乘积。故可以使用线段树维护这个序列，又因为本题中只有单点修改，所以无需使用懒标记。

对于大于等于 $2^{32}$ 的值，可以用 $-1$ 表示；在合并两个区间时，可以进行如下判断（假设两个子区间的乘积分别为 $x,y$）：

- 若 $x=0$ 或 $y=0$，则合并后一定不超限（因为 $0$ 乘任何数都得 $0$）。
- 否则，当且仅当 $x=-1$ 或 $y=-1$（即有任何一个已经超限）或 $x\times y\ge2^{32}$ 时判定为超限。

总时间复杂度 $O(Q\log Q)$，可以通过本题。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long	// 不开 long long 见祖宗 
#define ctn continue
#define Q 100005
const int lim=1ll<<32;	// 超过上限的记为 -1 
int q,n=0,seg[Q<<2],l[Q<<2],r[Q<<2];
bool check(int x,int y)
{
	if(x==0 || y==0)	// 0 乘任何数都得 0, 所以有 0 必不超限 
	{
		return 0;
	}
	// 已有超过 lim 的, 或相乘超过 lim 
	return x<0 || y<0 || x*y>=lim;
}
void pushup(int p)	// 更新节点 p 的值 
{	
	seg[p] = check(seg[p<<1],seg[p<<1|1]) ? -1 : seg[p<<1]*seg[p<<1|1];
}
void build(int p,int x,int y)	// 建树, 节点 p 管辖区间 [x,y] 
{
	l[p]=x;
	r[p]=y;
	if(x==y)
	{
		seg[p]=1;
		return;
	}
	int mid=(x+y)>>1;
	build(p<<1,x,mid);
	build(p<<1|1,mid+1,y);
	pushup(p);
}
void update(int p,int x,int k)	// 将位置 x 修改为 k 
{
	if(r[p]<x || x<l[p])	// 位置 x 不在节点 p 管辖范围内 
	{
		return;
	}
	if(l[p]==r[p])
	{
		seg[p] = k>=lim ? -1 : k;
		return;
	}
	update(p<<1,x,k);
	update(p<<1|1,x,k);
	pushup(p);
}
int query(int p,int x,int y)	// 查询区间 [x,y] 的乘积, 若超限则返回 -1 
{
	if(r[p]<x || y<l[p])	// 区间 [x,y] 完全不在节点 p 管辖范围内 
	{
		return 1;
	}
	if(x<=l[p] && r[p]<=y)	// 区间 [x,y] 是节点 p 管辖范围的子集 
	{
		return seg[p];
	}
	int ls=query(p<<1,x,y), rs=query(p<<1|1,x,y);	// 左右儿子的查询结果 
	return check(ls,rs) ? -1 : ls*rs;
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>q;
	build(1,1,q);
	for(int i=1;i<=q;i++)
	{
		int op,x;
		cin>>op;
		if(op==1)
		{
			cin>>x;
			n++;
			update(1,n,x);
		}
		else if(op==2)
		{
			if(n)	// 如果栈已经是空的就不能再弹出了 
			{
				n--;
			}
		}
		else
		{
			cin>>x;
			if(n<x)
			{
				cout<<"ERROR\n";
				ctn;
			}
			int ans=query(1,n-x+1,n);
			if(ans<0)
			{
				cout<<"OVERFLOW\n";
				ctn;
			}
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：HasNoName (赞：0)

### 思路
不难想到线段树。

注意到数列总长小于等于 $10^5$，所以不妨将变化长度的栈转化为定长的线段树。

记录当前栈内有多少元素，记为 $idx$，询问时就是求 $idx-y+1$ 到 $idx$ 之间的总乘积和。

`ERROR` 的情况非常好判断，即 $idx-y+1\ge 1$。对于 `OVERFLOW` 的情况可以把大于等于 $2^{32}$ 的数设为 $2^{32}$ 再计算。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
//如果会了模板线段树1的话这题代码应该是没有任何难度的
const int N=100005;
typedef unsigned long long ll;
ll w[8*N],n=100000;
void pushup(int u)
{
	__int128 c=(__int128)w[u<<1]*w[u<<1|1];//2^32*2^32=2^64会炸long long
	if(c>1ll<<32)c=1ll<<32;
	w[u]=c;
}
void to(int u,int l,int r,int x,ll k)
{
	if(l==r)
	{
		w[u]=k;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=x)to(u<<1,l,mid,x,k);
	else to(u<<1|1,mid+1,r,x,k);
	pushup(u);
}
ll get(int u,int l,int r,int x,int y)
{
	if(l>=x&&r<=y)return w[u];
	int mid=(l+r)>>1;
	__int128 c=1;
	if(mid>=x)c*=get(u<<1,l,mid,x,y);
	if(mid<y)c*=get(u<<1|1,mid+1,r,x,y);
	if(c>1ll<<32)c=1ll<<32;
	return (ll)c;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T,idx=0;
	cin>>T;
	while(T--)
	{
		int op,x;
		cin>>op;
		if(op==1)
		{
			cin>>x;
			to(1,1,n,++idx,x);
		}
		else if(op==2)idx=max(0,idx-1);
		else
		{
			cin>>x;
			if(idx-x+1<1)cout<<"ERROR\n";
			else
			{
				ll ans=get(1,1,n,idx-x+1,idx);
				if(ans==1ll<<32)cout<<"OVERFLOW\n";
				else cout<<ans<<'\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：__liujy (赞：0)

我们可以抽象拟定一个有 $Q$ 个数的数组 $a$，又令 $n$ 为当前数列的长度，每一次插入的时候就相当于把数组 $a$ 第 $n+1$ 变为 $x$，而将栈顶弹出时只用将 $n$ 减一即可，而询问的时候，就是在求 $n-y+1$ 到 $n$ 之间的数的乘积，而判断是否大于等于 $2^{32}$，可以判断如果当前的乘积就大于等于 $2^{32}$，就将当前数设为负数，最后判断是否为负数即可。

---

## 作者：CandyGodOfWar (赞：0)

我们可以将栈的每一个位置看成数组的下标，这样就只用去维护一个数组，再用线段树维护乘积就行了。

可是，题目中说了，若答案大于等于 $2^{32}$，要输出一长串，这个该怎么维护呢？

直接维护值肯定不行，因为上限是 $10^{5} \times (2^{30}-1)$ 答案很大，那么我们就必须再思考。

发现如果当前的值已经大于等于 $2^{32}$，那么可以将答案设为负数，因为 $x$ 的最小值是 $0$，答案肯定不会有负数。

发现可以用线段树维护，这样只用维护数组长度，因为元素已经在线段树里了。

这样在写线段树的时候，把已经大于等于 $2^{32}$ 的数设成负数，最后统计答案的时候若是负数，就代表答案已经大于等于 $2^{32}$ 了，否则就是 $2^{32}$ 次方以内，直接输出即可。

顺带提一下，在维护数组长度时只需要像手写栈一样维护就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
typedef long long LL;
typedef unsigned int UI;
typedef unsigned long long ULL;
int Q,n;
inline bool check(LL x,LL y){return (x!=0&&y!=0)&&(x<0||y<0||x*y>=(1LL<<32));}
struct SegmentTree
{
	int l,r;
	LL mul;
	#define l(p) tr[p].l
	#define r(p) tr[p].r
	#define mul(p) tr[p].mul
}tr[N<<2];
inline int ls(int x){return x<<1;}
inline int rs(int x){return x<<1|1;}
inline void pushup(int p){mul(p)=check(mul(ls(p)),mul(rs(p)))?-1:mul(ls(p))*mul(rs(p));}
inline void build(int p,int l,int r)
{
	l(p)=l,r(p)=r;
	if(l==r)
	{
		mul(p)=1;
		return;
	}
	int mid=l+((r-l)>>1);
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	pushup(p);
}
inline void update(int p,int x,LL k)
{
	if(r(p)<x||x<l(p)) return;
	else if(l(p)==r(p)){mul(p)=(k>=(1LL<<32)?-1:k);return;}
	update(ls(p),x,k);
	update(rs(p),x,k);
	pushup(p);
}
inline LL query(int p,int l,int r)
{
	if(r(p)<l||r<l(p)) return 1;
	else if(l<=l(p)&&r(p)<=r) return mul(p);
	LL p1=query(ls(p),l,r),p2=query(rs(p),l,r);
	return check(p1,p2)?-1:p1*p2;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>Q;
	build(1,1,Q);
	while(Q--){
		int type;cin>>type;
		if(type==1)
		{
			LL x;cin>>x;
			update(1,++n,x);
		} 
		else if(type==2) n=max(0LL,n-1);
		else
		{
			int x;cin>>x;
			if(n<x){cout<<"ERROR"<<'\n';continue;}
			int ans=query(1,n-x+1,n); 
			if(ans<0) cout<<"OVERFLOW"<<'\n';
			else cout<<ans<<'\n';
		}
	}
	return 0;
}
```

---


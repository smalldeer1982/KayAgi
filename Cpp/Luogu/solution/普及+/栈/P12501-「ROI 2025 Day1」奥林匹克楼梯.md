# 「ROI 2025 Day1」奥林匹克楼梯

## 题目描述

**译自 [ROI 2025](https://neerc.ifmo.ru/school/archive/2024-2025.html) Day1 T1.** ***[Лестница для участников олимпиады](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-roi-2025-day1.pdf)***

在天狼星教育中心，学生们最喜欢聚集和交流的地方莫过于各式各样的楼梯。然而，信息学奥林匹克的参与者数量远远超过了其他任何教育项目的学生，现有的楼梯已无法满足需求。因此，装备部门决定利用一块特殊的模板，打造一座全新的楼梯。

这块模板是一个由 $h$ 行 $w$ 列组成的表格，行从上到下、列从左到右依次编号。表格的每个格子中记录了一个数字，要么是 `0`，要么是 `1`。而所谓的楼梯，只能由那些格子中填有 `1` 的格子构成。

楼梯是由若干连续行中填有 `1` 的格子集合组成的。在每一行中，被选中的格子必须形成一个连续的段。  
同时，满足以下条件：  
- 每下一行的选中格子数量不得少于紧邻其上的上一行；  
- 每行中最左边的选中格子必须位于同一列。

下图展示了一个楼梯的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/l57xqjcb.png)

你的任务是找出给定表格中，能够构成楼梯的最大格子数量。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/prkfqb5m.png)

详细子任务附加限制及分值如下表所示。其中子任务 $0$ 是样例。

| 子任务 | 分值 | 附加限制 | 
| :-: | :-: | :-: |
| $1$        | $25$ | $h, w \le 50$ |
| $2$        | $25$ | $h, w \le 400$ |
| $3$        | $25$ | $h \cdot w \le 200\,000$ |
| $4$        | $25$ | 无附加限制 |

## 样例 #1

### 输入

```
6 4
0011
1101
0111
1110
0111
0100```

### 输出

```
8```

# 题解

## 作者：__liujy (赞：4)

题目中的 $h$ 和 $w$ 在文中用 $T$ 和 $n$ 代替。

设一个楼梯的最下端在第 $T$ 行，这样就能从改行往上枚举。

设楼梯的左下角为 $(T,l)$，从左往右贪心，每一次让楼梯尽量高就是最优的。

这个过程可以用单调栈优化，优化的部分为 $i=l$ 开始，考虑 $a_{i}$ 贡献了多少次，找出 $i$ 后第一个小于 $i$ 的位置 $r_{i}$，则 $a_{i}$ 的贡献为 $a_{i} \times (r_{i}-i)$，然后每一次 $i=r_{i}$ 往下继续枚举。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e6+5;
int T,n,a[N],r[N],val[N],ans;
int main()
{
	cin>>T>>n;
	while(T--)
	{
		for(int i=1;i<=n;i++)
		{
			char ch;
			cin>>ch;
			a[i]=(ch=='0'?0:a[i]+1);
		}
		stack<int> st;
		for(int i=1;i<=n;i++)
		{
			while(st.size()&&a[st.top()]>a[i])
			{
				r[st.top()]=i;
				st.pop();
			}
			st.push(i);
		}
		while(st.size())
		{
			r[st.top()]=n+1;
			st.pop();
		}
		for(int i=n;i>=1;i--)
		{
			val[i]=val[r[i]]+a[i]*(r[i]-i);
			ans=max(ans,val[i]);
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Mr_Az (赞：2)

# [P12501 「ROI 2025 Day1」奥林匹克楼梯](https://www.luogu.com.cn/problem/P12501)

### Algorithm:

单调栈。

### Solution:

本人赛时想麻烦了，先讲正解。

#### 正解：

**以下讨论定义长度为固定列 $j$ 时，第 $i$ 行的 $nxt_{i,j}$。后缀的意思为从下到上。**

我们可以先 $\text{O}(hw)$ 预处理出一个**数组** $nxt_{x,y}$ 表示 $(x,y)$ 的这个点**往右边多少格都为 $1$**。转移是显然的。特别的，如果 $(x,y)$ 为 $0$，那么 $nxt_{x,y}=0$。那题目所求的内容就变为 $\displaystyle \sum_{i=y}^{n} (\min_{j=i}^{y} nxt_{x,j})$。

暴力计算即为每次枚举一个点 $(x,y)$，计算上面的式子。对于每个点的答案取 $\max$ 即为最后答案，时间复杂度为 $\text{O}(h^2w)$。

考虑如何优化，发现这个形式很符合**单调栈**的形式，因为最后的形状一定是**单调递增**的，其中突出的部分会和下面行中最短的取 $\min$。所以每一行的长度即为**后缀最小值**。用单调栈维护后缀最小值的位置，计算当前行的长度能贡献到的地方，用 $f_i$ 存一下第 $i$ 行的时候的答案转移即可。时间复杂度为 $\text{O}(hw)$。

### Code:

```cpp
namespace Mr_Az{
	const int N=4e6+8;
	int T=1;
	int n,m,ans;
	int nxt[N],f[N];
	bool a[N];
	inline int id(int x,int y){return (x-1)*m+y;}
	inline void solve(){
		read(n,m);
		for(rint i=1;i<=n;i++) for(rint j=1;j<=m;j++){
			char ch;scanf(" %c",&ch);
			a[id(i,j)]=ch-'0';
		}
		for(rint i=1;i<=n;i++){
			for(rint j=m;j>=1;j--){
				if(a[id(i,j)]){
					if(j==m) nxt[id(i,j)]=1;
					else nxt[id(i,j)]=nxt[id(i,j+1)]+1;
				}
			}
		}
		for(rint j=1;j<=m;j++){
			stack<int> st;
			while(st.size()) st.pop();
			for(rint i=1;i<=n;i++){
				while(st.size()){
					if(nxt[id(i,j)]<=nxt[id(st.top(),j)]) st.pop();
					else break;
				}// 维护后缀最小值。
				if(st.size()) f[i]=f[st.top()]+(i-st.top())*nxt[id(i,j)];// 如果这一行不是最短的，那么可以从前面的位置加上一个矩形。
				else f[i]=i*nxt[id(i,j)];// 如果这一行是最短的，那么此时楼梯就是一个矩形。
				st.push(i);
				ans=max(ans,f[i]);
			}
		}
		printf("%lld\n",ans);
	}
	inline void mian(){if(!T) read(T);while(T--) solve();}
}
```

#### 赛时做法：（读者可以直接跳过）

扯完了正解，讲一下赛时的做法。

我们发现加入一行相当于对前面行的长度全部取 $\min$，一个暴力的想法是直接建立权值线段树硬做，实现区间求和，区间覆盖，单点加即可，但是卡不过去。时间复杂度 $\text{O}(hw \log w)$。

~~后面去写单调栈了。~~

---

## 作者：Sliarae (赞：2)

枚举楼梯的最下端位于第 $t$ 行，自第 $t$ 行向上扩展，设 $a_i$ 表示格子 $(t, i)$ 向上能拓展多少的长度。如果从小到大每次将 $t$ 增大 $1$，$a_i$ 容易动态维护。

枚举楼梯的左下角为 $(t, l)$，考虑从左到右贪心，肯定每一步都让楼梯尽量高是最优的，所以楼梯的最大大小就是 $\sum\limits_{i = l}^{n} \min\limits_{j = l}^{i} a_j$（假设楼梯列数为 $n$）。

换一种方式算这个式子，从 $p = l$ 开始，考虑 $a_p$ 会贡献多少次，找 $p$ 后第一个小于 $p$ 的位置为 $R_p$，$a_p$ 的贡献为 $a_p \times (R_p - p)$，然后令 $p = R_p$ 继续算下去。

这个过程显然可以优化，因为从 $p$ 跳到 $R_p$ 后的过程与 $R_p$ 完全一样，所以设 $val_i$ 为左下角为 $(t, i)$ 时，楼梯的最大大小，递推式为 $val_i = val_{R_i} + a_i(R_i - i)$。最后将所有 $val_i$ 取 $\max$ 即可得到答案。

时间复杂度 $O(hw)$。

```cpp
#include <iostream>
#include <stack>

using namespace std;

const int kN = 4e6 + 5; 

int T, n; 
int a[kN], R[kN];
int val[kN], ans;

int main () {
  cin.tie(0)->sync_with_stdio(0);
  cin >> T >> n;
  for (int t = 1; t <= T; ++t) {
    for (int i = 1; i <= n; ++i) {
      char c;
      cin >> c;
      a[i] = (c == '0' ? 0 : a[i] + 1);
    }
    stack<int> st;
    for (int i = 1; i <= n; ++i) {
      while (!st.empty() && a[i] < a[st.top()]) {
        R[st.top()] = i;
        st.pop();
      }
      st.push(i);
    }
    while (!st.empty()) R[st.top()] = n + 1, st.pop();
    for (int i = n; i; --i) {
      val[i] = val[R[i]] + a[i] * (R[i] - i); 
      ans = max(ans, val[i]);
    }
  }
  cout << ans << '\n';
  return 0; 
}
```

---

## 作者：Alcl000000 (赞：1)

首先，我们处理出来每个点向上连续 $1$ 的个数，记为 $h_{i,j}$，然后首先枚举行，算出每一个点 $i$ 后面第一个 $h$ 值小于这个点的点 $j$（若没有，令 $j=w+1$），$i$ 到 $j$ 的楼梯格子数就是 $h_{i,j}(j-i)$，那么 $i$ 到最后的楼梯格子数就等于 $j$ 到最后的楼梯格子数加上 $h_{i,j}(j-i)$，对于每个 $i$ 取一个 $\max$ 即可。

```cpp
#include<bits/stdc++.h>
//#define int long long
#define deb(x) cerr<<"deb:"<<__LINE__<<" "<<#x<<"="<<x<<"\n"
#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
const int N=2e5+5,P=0,G=3;
const double PI=acos(-1);
using namespace std;
namespace IO{
	void output(int x){if(!x) return ;output(x/10);putchar(x%10+'0');}
	inline int read(){int f=1,res=0;char ch=getchar();while(ch>'9'||ch<'0'){if(ch=='-') f=-1;ch=getchar();}while(ch<='9'&&ch>='0'){res=(res<<3)+(res<<1)+(ch-'0');ch=getchar();}return res*f;}
	inline void write(int x,char endch){if(x<0){putchar('-');x=-x;}if(x==0) putchar('0');else output(x);putchar(endch);}
	inline void read(int &a){a=read();}
	inline void read(int &a,int &b){a=read();b=read();}
	inline void read(int &a,int &b,int &c){a=read();b=read();c=read();}
}
using namespace IO;
vector<int> vec[N],h[N];
int H,w,tmp[N],nxt[N],f[N];
int calc(){
	stack<int> stk;
	for(int i=w;i>=1;i--){
		while(!stk.empty()&&tmp[i]<=tmp[stk.top()]) stk.pop();
		if(stk.empty()) nxt[i]=w+1;
		else nxt[i]=stk.top();
		stk.push(i);
	}
	for(int i=w;i>=1;i--) f[i]=0;
	int ans=0;
	for(int i=w;i>=1;i--){
		f[i]=f[nxt[i]]+(nxt[i]-i)*tmp[i];
		ans=max(ans,f[i]);
	} 
	return ans;
} 
signed main(){
	cin>>H>>w;
	for(int i=0;i<=w;i++) h[0].push_back(0);
	for(int i=1;i<=H;i++){
		vec[i].push_back(0);
		h[i].push_back(w);
		for(int j=1;j<=w;j++){
			char x;
			cin>>x;
			vec[i].push_back((int)(x-'0'));
			h[i].push_back(0);
		}
	} 
	for(int i=1;i<=H;i++){
		for(int j=1;j<=w;j++){
			if(vec[i][j]==0) h[i][j]=0;
			else h[i][j]=h[i-1][j]+1; 
		}
	}
	int ans=0;
	for(int i=1;i<=H;i++){
		for(int j=1;j<=w;j++){
			tmp[j]=h[i][j];
		}
		ans=max(ans,calc());
	} 
	cout<<ans;
//	cerr<<1.0*clock()/CLOCKS_PER_SEC;
	return 0;
}
```

---

## 作者：liheyang123 (赞：1)

~~很好的模拟赛 T1 使我的时间旋转~~

---

记 $s_{x,y}$ 为坐标 $(x, y)$ 及其上方连续的 $1$ 的个数。

考虑单调栈，逐行遍历，对于每一个 $(x,y)$，求最小的 $x_1$ 满足 $s_{x_1,y} < s_{x,y}$ 且 $x_1 > x$，记为 $R_x$，然后从右往左计算答案，式子是 $sum_x = sum_{R_x} + (R_x - x) \times s_(x,y)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 4e6 + 10;

int T, h, w, ans = 0; 
int s[N], R[N], sum[N];
char g[N]; 
int getid(int x, int y){return (x - 1) * w + y;}

signed main(){
//	scanf("%d", &T);
//	while(T --> 0){
		ans = 0;
		scanf("%d %d", &h, &w);
		for(int i = 1; i <= w * h; i += w) scanf("%s", g + i);
		for(int i = 1; i <= h; i++) for(int j = 1; j <= w; j++)
			s[getid(i, j)] = (i != 1) * (g[getid(i, j)] == '1') * 
					s[getid(i - 1, j)] + (g[getid(i, j)] == '1');
		for(int i = 1; i <= h; i++){
			stack<int> st;
			for(int j = 1; j <= w; j++){
				sum[j] = 0;
				while(!st.empty() && s[getid(i, j)] < s[getid(i, st.top())]){
					R[st.top()] = j;
        			st.pop();
				}st.push(j);
			}
			while(!st.empty()){
				R[st.top()] = w + 1;
				st.pop();
			}
			for (int j = w; j; --j) {
		      	sum[j] = sum[R[j]] + (s[getid(i, j)]) * (R[j] - j); 
		      	ans = max(ans, sum[j]);
		    }
		}
		printf("%d\n", ans);
//	}
	return 0;
} 
```

---

## 作者：jyh8221 (赞：1)

设 ${pre}_{i,j}$ 表示点 $(i,j)$ 往上有几个连续的 $1$，
即：
$$

{pre}_{i,j} = 
\begin{cases} 
0 & \text{当 } a_{i,j} = 0 \\
{pre}_{i-1,j} + 1 & \text{当 } a_{i,j} \neq 0 
\end{cases}

$$
对于样例，${pre}_{i,j}$ 为：

|||||
|:-:|:-:|:-:|:-:|
|0|0|1|1|
|1|1|0|2|
|0|2|1|3|
|1|3|2|0|
|0|4|3|1|
|0|5|0|0|

考虑对于每一个连续，$\displaystyle \min_{j=l}^{r}  {pre}_{i,j} \neq 0$ 的极大（不可扩展）区间 $[l,r]$。\
令目前区间为 $[j,r]$，$j$ 初始为 $1$。\
不难发现，如果维护一个单调栈，向左扩展当前区间是简单的。\
如果当前的 $pre_j$ 小于栈顶元素的 $pre$ 值时，删除栈顶，撤销加入栈顶时的贡献，重复直到不满足条件为止。\
然后加入区间 $[j,top+1]$，再令 $j \gets j+1$，直到 $pre_{i,j} = 0$。
过程中维护最大值即可。

[AC 记录](https://www.luogu.com.cn/record/217278675)

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() { int n, m;
    cin>>n>>m    ;
    vector<vector<int>> a(n + 10, vector<int>(m + 10));
    for (int i = 1; i <= n;i++){
        for (int j = 1; j <= m;j++){
            char c;
            cin >> c;
            a[i][j] = c - '0';
        }
    }
    vector<vector<int>> pre(n + 10, vector<int>(m + 10));
    for (int j = 1; j <= m;j++){
        for (int i = 1; i <= n;i++){
            if(a[i][j]==0)
                pre[i][j] = 0;
            else{
                pre[i][j] = pre[i - 1][j] + 1;
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n;i++){
        int cntl = 1, cntr = 0;
        while(cntr<=m){
            cntr++;
            if(a[i][cntr]==0){
                if(a[i][cntr-1]==1){
                    //找到了合法区间
                    int l = cntl, r = cntr - 1;
                    int sum = pre[i][r];
                    vector<int> st;
                    st.push_back(r);
                    
                        ans = max(ans, sum);
                    for (int j = r-1; j >= l;j--){
                        
                        if(pre[i][j]>=pre[i][st.back()]){
                            sum += (st.back() - j) * pre[i][j];
                        }
                        else{
                            while(st.size()>1&&pre[i][j]<pre[i][st.back()]){
                                sum -= (st[st.size() - 2] - st[st.size() - 1]) *
                                       pre[i][st[st.size() - 1]];
                                st.pop_back();
                            }
                            if(pre[i][j]<pre[i][st.back()]){
                                sum = pre[i][j];
                            }
                            int bk = st.back();
                            sum += (bk - j) * pre[i][j];
                        }
                        st.push_back(j);
                        ans = max(ans, sum);
                    }
                }
                cntl = cntr + 1;}
            
        }
    }
    cout << ans << endl;
}
```

ps：声明一个大小为 $n \times m$ 的二维`vector`的方式是：\
`
    vector<vector<int>> a(n, vector<int>(m));`

---

## 作者：__FL__ (赞：0)

## Solution
楼梯的形状是一个矩形的残缺，我们不妨考虑它完整的那一个角。考虑当一个方格作为楼梯的**左下角**时，它的最大格子数量是确定且好求的。显然，从下往上每一行都尽量往右拓展，得到的值是最大的。

考虑单调栈维护。设 $sum_{i,j}$ 表示方格 $(i,j)$ 往右最多能拓展多少个 $1$；枚举每一列，从上往下将 $sum_{i,j}$ 加入单调栈，对于每一个格子，取它的最大值。

时间复杂度 $O(hw)$。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int h,w,ans;
stack<pair<int,int>>s;
signed main()
{
	ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin >> h >> w;
	char a[h+5][w+5];
	int sum[h+5][w+5];
	for (int i = 1; i <= h; i++)
		for (int j = 1; j <= w; j++)
		{
			cin >> a[i][j];
			if (j == w) sum[i][j] = a[i][j]-'0';
			else sum[i][j] = 0;
		}
	for (int i = 1; i <= h; i++)
		for (int j = w-1; j >= 1; j--)
			if (a[i][j] == '1') sum[i][j] = sum[i][j+1]+1;
	for (int i = 1; i <= w; i++)
	{
		while (!s.empty()) s.pop();
		int tot = 0;
		for (int j = 1; j <= h; j++)
		{
			int p = 1;
			while (!s.empty() && sum[j][i] <= s.top().first) tot += (sum[j][i]-s.top().first)*s.top().second,p+=s.top().second,s.pop();
			s.push({sum[j][i],p});
			tot += sum[j][i];
			ans = max(ans,tot);
		}
	}
	cout << ans;
	return 0;
}
```

---


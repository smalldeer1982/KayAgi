# 幻象迷宫

## 题目背景

（喵星人 LHX 和 WD 同心协力击退了汪星人的入侵，不幸的是，汪星人撤退之前给它们制造了一片幻象迷宫。）

WD：呜呜，肿么办啊……

LHX：momo...我们一定能走出去的！

WD：嗯，+U+U！

## 题目描述

幻象迷宫可以认为是无限大的，不过它由若干个 $N\times M$ 的矩阵重复组成。矩阵中有的地方是道路，用 $\verb!.!$ 表示；有的地方是墙，用 $\verb!#!$ 表示。LHX 和 WD 所在的位置用 $\verb!S!$ 表示。也就是对于迷宫中的一个点$(x,y)$，如果 $(x \bmod n,y \bmod m)$ 是 $\verb!.!$ 或者 $\verb!S!$，那么这个地方是道路；如果 $(x \bmod n,y \bmod m)$ 是$\verb!#!$，那么这个地方是墙。LHX 和 WD 可以向上下左右四个方向移动，当然不能移动到墙上。

请你告诉 LHX 和 WD，它们能否走出幻象迷宫（如果它们能走到距离起点无限远处，就认为能走出去）。如果不能的话，LHX 就只好启动城堡的毁灭程序了……当然不到万不得已，他不想这么做。

## 说明/提示

- 对于 $30\%$ 的数据，$1\le N,M\le 20$；
- 对于 $50\%$ 的数据，$1\le N,M\le 100$；
- 对于 $100\%$ 的数据，$1\le N,M\le 1500$，每个测试点不超过 $10$ 组数据。

## 样例 #1

### 输入

```
5 4
##.#
##S#
#..#
#.##
#..#
5 4
##.#
##S#
#..#
..#.
#.##
```

### 输出

```
Yes
No

```

# 题解

## 作者：DEVILK (赞：193)

更好的阅读体验点这里：[博客传送门](https://www.cnblogs.com/devilk-sjj/p/9070465.html)

搜索时判断能否重复到达某个点，当然迷宫的四个边界是分别相通的。

一开始想的是：

如果从上（下）边界的某个点能到达同一列下（上）边界的某个点，或者是从左（右）边界的某个点能够到达同一行右（左）边界的某个点，则可以走无限远

但这样的数据就会判断错误：
```cpp
3 5
S.#..
#####
#...# 
```
并不能直接从上面到达下面但也是可以到达的，而且枚举边界上的点再搜索会超时

 

然后想了一个比较正确~~（但还是不正确）~~的方法：

把读入的一个迷宫变成九个迷宫，判断从起点$(x,\ y)$能否走到$(x + n,\ y)$或$(x - n,\ y)$或$(x,\ y + m)$或$(x,\ y - m)$.

但这么做如果要走不止一个迷宫才能回到起点就$GG$了

比如这组数据：
```cpp
6 20
#.##.##.##.##.##.##.
#.##.##.##.##.##.##.
#.##.##.##.##.##.##.
S.#..#..#..#..#..#..
##..#..#..#..#..#..#
#..#..#..#..#..#..##
```
愉快地从下面跑到上面再跑到下面再...

显然这种情况把$1 * 1$迷宫拓展成$3 * 3$是不可取的，而如果拓展成$9 * 9$（或$81 * 81$）那一定是会爆内存的。

#### 下面是正解：

所以不能拓展迷宫而对坐标取模就好了.

如果走到过某个点现在又走到了这个点，那显然是可以走无限远的。

现在出现了一些~~（堆）~~问题：

如何判断是否走到过这个点呢？

有一个比较巧妙的方法：

记录取模的横纵坐标$x,\ y$时，同时记录没有取模的坐标$lx,\ ly$

当第一次走这个迷宫的时候，$x,\ y$和$lx,\ ly$肯定是分别相等的

所以只要走到的一个点的$x,\ y$和$lx,\ ly$不相等（$x≠lx\ ||\ y≠ly$），那这个点一定是被走了第二遍.

### **$[Code:]$**
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int MAXN = 1500 + 1;
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};

int n, m;
int st_x, st_y;
int vis[MAXN][MAXN][3];
bool fl, a[MAXN][MAXN];
char ch;

void dfs(int x, int y, int lx, int ly) {
	if(fl) return;
	if(vis[x][y][0] && (vis[x][y][1]!=lx || vis[x][y][2]!=ly)) {
		fl = 1;
		return;
	}
	vis[x][y][1] = lx, vis[x][y][2] = ly, vis[x][y][0] = 1;
	for(int i=0; i<4; ++i) {
		int xx = (x + dx[i] + n) % n, yy = (y + dy[i] + m) % m;
		int lxx = lx + dx[i], lyy = ly + dy[i];
		if(!a[xx][yy]) {
			if(vis[xx][yy][1]!=lxx || vis[xx][yy][2]!=lyy || !vis[xx][yy][0])
				dfs(xx, yy, lxx, lyy);
		}
	}
}
int main() {
	ios::sync_with_stdio(false);
	while(cin >> n >> m) {
		fl = 0;
		memset(a, 0, sizeof(a));
		memset(vis, 0, sizeof(vis));
		for(int i=0; i<n; ++i)
			for(int j=0; j<m; ++j) {
				cin >> ch;
				if(ch == '#') a[i][j] = 1;
				if(ch == 'S') st_x = i, st_y = j;
			}
		dfs(st_x, st_y, st_x, st_y);
		if(fl) puts("Yes");
		else puts("No");
	}
}
```

---

## 作者：GNAQ (赞：74)

也是好久之前做的题了，一开始被题意卡了好久，果然语文不好毁一生啊……

大概就是说给出一个01迷宫类的地图，按照这个地图来扩展新地图，类似这样



 ![](https://cdn.luogu.com.cn/upload/pic/9195.png) 

然后问你是不是###可以走无限远。


###那么，我们可以很清晰的意识到，如果可以从点(x,y)出发，达到比如(-x,y)或者(x,-y) , (-x,-y) , (x+m,y+n) [假设宽m高n]  ， 就可以从这个点再次达到相同的点（即可以从(x,y)出发，达到(i,j)且|i|%n=x , |j|%m=y。），一直这么走下去。

那就搜好了。开一个三维vis数组第一维记录有无被访问，第二维记录被访问时横坐标，第三维纵坐标。

判断重复到达且横纵坐标不同即可。应该注意先判什么后判什么。**如果是同一个分矩阵走过去的话自然tx==vis[x][y][0] **（此处x为|tx|%n，y为|ty|%m，即映射到中心矩阵的位置），就会被判掉。
**而且注意tx!=vis[x][y][0] 和ty!=vis[x][y][1]满足一个即可。**


没啥好说的了。。。数据很大注意搜索优化。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;

bool mapx[1510][1510]={false};
int vis[1510][1510][3]={0};
int m,n,sx,sy,wayx[4]={0,-1,0,1},wayy[4]={-1,0,1,0},ans=0;

void dfs(int x,int y,int posx,int posy)
{
    if (vis[posx][posy][2] && (vis[posx][posy][0]!=x || vis[posx][posy][1]!=y))
    {
        ans=1;
        return;
    }
    
    if (vis[posx][posy][2] && vis[posx][posy][0]==x && vis[posx][posy][1]==y) return;
    vis[posx][posy][0]=x; vis[posx][posy][1]=y; vis[posx][posy][2]=1;
    register int tox,toy;

    for (int w=0;w<=3;w++)
    {
        tox=(posx+wayx[w]+n)%n; toy=(posy+wayy[w]+m)%m;    
        if (mapx[tox][toy])dfs(x+wayx[w],y+wayy[w],tox,toy);
    }
}

int main()
{
    ios::sync_with_stdio(false);
    register char ch;
    while (cin>>n>>m)
    {
        memset(mapx,false,sizeof(mapx));
        memset(vis,false,sizeof(vis));
        ans=0;
        
        for (int i=0;i<n;i++)
        {    
            for (int j=0;j<m;j++)
            {
                cin>>ch;
                if (ch=='.') mapx[i][j]=true;
                else if (ch=='S')
                {
                    sx=i; sy=j;
                    mapx[i][j]=true; 
                }
            }
        }
        dfs(sx,sy,sx,sy);
        if (ans) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

---

## 作者：ygsldr (赞：44)

咳，这题卡了很久，很大原因是思路走错~~(看不懂题解)~~

具体思路：放大~~放大再放大~~，然后走到边界就传送

很明显，假如能走到之前走到过的环境相同的点（即(x mod n,y mod m)），记作A->B，那么就一定有B->同一个环境（(x mod n,y mod m)）的点

//同一个环境就是他的映射位置相同

细节见下面：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define MEM(arr,num) memset(arr,num,sizeof(arr))
#define FOR(i,l,r) for(int i(l);i < r;++i)
#define SIZE 1511
using namespace std;

char board[SIZE][SIZE];
bool map1[SIZE * 2][SIZE * 2], map2[SIZE][SIZE];
//map1表示有无走到过这个点，map2表示有无走到过映射点
int n, m, dn, dm;

bool dfs(int x,int y)
{
    if(x == -1)
    {
        if(dfs(dn - 1, y))return true;
        return false;
    }
    if(x == dn)
    {
        if(dfs(0, y))return true;
        return false;
    }
    if(y == -1)
    {
        if(dfs(x, dm - 1))return true;
        return false;
    }
    if(y == dm)
    {
        if(dfs(x, 0))return true;
        return false;
    }//上面四个if表示是否到边界，是就传送
    if(map1[x][y] || board[x % n][y % m] == '#')
    {
        return false;
    }//判断能不能走
    if(map2[x % n][y % m])
    {
        return true;
    }//判断这有没有走到这个点的映射
    map1[x][y] = true;
    map2[x % n][y % m] = true;
    //记录
    if(dfs(x + 1, y))return true;
    if(dfs(x - 1, y))return true;
    if(dfs(x, y + 1))return true;
    if(dfs(x, y - 1))return true;
    //遍历
    return false;
}

int main()
{
    while(cin >> n >> m)
    {
        dn = n * 2;
        dm = m * 2;
        int sx, sy;
        FOR(i, 0, n)
        {
            FOR(j, 0, m)
            {
                cin >> board[i][j];
                if(board[i][j] == 'S')
                {
                    sx = i;
                    sy = j;
                }
            }
        }//输入+找起点
        MEM(map1, 0);
        MEM(map2, 0);
        if(dfs(sx, sy))    printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

---

## 作者：TheOldDriver (赞：26)

翻了翻题解，发现没有思路和我一样的，来写一篇

我是通过标签 精选题库-->图论 找到这道题的，于是我就  建图-->A了这题

思路大概是这样：

1.找包括边界点的联通块，每个联通块视为图中一个节点
```
##...#
.##..#
..#.S.
..#.#.
..###.
...#..

经处理

##111#
2##11#
22#111
22#1#1
22###1
222#11

1和2节点间连边
```
2.如果一个边节点可以走到其对面的点，则对应联通块连边
    
   如上例中1—2间（1，3）——（6，3）
    
3.二维边权，用边权来实现排除绕圈情况
	
   上例中（1，3）——（6，3）边权（1，0）
   
   （3，1）——（3，6）边权（0，1）

4.直接广搜查找

   当第二次搜到一个点且，路径长和上次到达时不相等即为Yes
   
   若路径相等，那就是在绕圈
   
   代码
   ```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int N=1505;
char cc;
int n,m,a[N][N],x0,y0,flag,inq[N*4],v[N][N];
int c[N][N],cnt,h[N],t,d[N][2];
int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
struct edge{int ver,val_x,val_y,next;}f[N*N];
queue<int> qx,qy,q;
void add(int x,int y,int vx,int vy){
	f[++t].ver=y;
	f[t].val_x=vx;
	f[t].val_y=vy;
	f[t].next=h[x];
	h[x]=t;
}
void bfs(int x,int y){
	cnt++;
	qx.push(x);qy.push(y);
	v[x][y]=1;
	c[x][y]=cnt;
	while(qx.size()){
		x=qx.front();y=qy.front();
		qx.pop();qy.pop();
		for(int i=0;i<4;++i){
			int xx=x+dx[i];
			int yy=y+dy[i];
			if(xx<1||yy<1||xx>n||yy>m||a[xx][yy]||v[xx][yy]) continue;
			qx.push(xx);qy.push(yy);v[xx][yy]=1;c[xx][yy]=cnt;
		}
	}
}
void bfs2(int x){
	q.push(x);inq[x]=1;
	while(q.size()){
		x=q.front();
		q.pop();
		for(int i=h[x];i;i=f[i].next){
			int y=f[i].ver;
			if(inq[y]&&(d[x][0]+f[i].val_x!=d[y][0]||d[x][1]+f[i].val_y!=d[y][1])){
				flag=1;
				return;
			}
			else if(!inq[y]){
				d[y][0]=d[x][0]+f[i].val_x;
				d[y][1]=d[x][1]+f[i].val_y;
				inq[y]=1;
				q.push(y);
			}
		}
	}
}
int main(){
	while(scanf("%d%d",&n,&m)!=EOF){
		while(q.size()) q.pop();
		memset(inq,0,sizeof(inq));
		memset(v,0,sizeof(v));
		memset(c,0,sizeof(c));
		memset(d,0,sizeof(d));
		memset(h,0,sizeof(h));
		t=cnt=flag=0;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j){
				cin>>cc;
				if(cc=='#') a[i][j]=1;
				else a[i][j]=0;
				if(cc=='S') x0=i,y0=j;
			}
		for(int i=1;i<=n;++i){
			if(!v[i][m]&&!a[i][m]) bfs(i,m);
			if(!v[i][1]&&!a[i][1]) bfs(i,1);
		}
		for(int i=1;i<=m;++i){
			if(!v[1][i]&&!a[1][i]) bfs(1,i);
			if(!v[n][i]&&!a[n][i]) bfs(n,i);
		}
		if(!v[x0][y0]){
			printf("No\n");
			continue;
		}
		for(int i=1;i<=n;++i)
			if(v[i][1]&&v[i][m]) 
				add(c[i][1],c[i][m],1,0),add(c[i][m],c[i][1],-1,0);
		for(int i=1;i<=m;++i) 
			if(v[1][i]&&v[n][i]) 
				add(c[1][i],c[n][i],0,1),add(c[n][i],c[1][i],0,-1);
		if(!flag) bfs2(c[x0][y0]);
		if(flag) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

---

## 作者：crpboy (赞：25)

这道题我的思路有些不同。

迷宫可以在各个方向伸展，也就等价于碰到边界传送到另一边，我们可以在传送的时候用$stepx,stepy$记录传送次数的序号。在上/左传送时记录的变量$stepN--$，在下/右传送的时候记录的变量$stepN++$。

可以证明，在一次搜索中遇到了已经标记访问的、$stepx$或$stepy$值与当前值有不同的点，就已经陷入循环。因此我们可以直接返回并输出$Yes$。

AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
char a[1505][1505];
int n,m,sx,sy;
short s[1505][1505][2];//s[i][j][0]存上下传送次数 s[i][j][1]存左右传送次数 
bool vis[1505][1505];
bool flag;//flag用来表示是否找到答案 
void dfs(int x,int y,short stepx,short stepy)//stepx表示上下两面的传送次数 stepy表示左右两面的传送次数
{
	
	if(x>=n)x=0,stepx++;
	else if(y>=m)y=0,stepy++;
	else if(x<0)x=n-1,stepx--;
	else if(y<0)y=m-1,stepy--;//传送并对stepN进行操作 
	if(a[x][y]=='#')return;
	if(vis[x][y])//如果已经访问过该点 return 
	{
		if(s[x][y][0]!=stepx||s[x][y][1]!=stepy)
			flag=true;
		return;
	}
	vis[x][y]=true;
	s[x][y][0]=stepx;
	s[x][y][1]=stepy;//标记 
	for(int i=0;i<4;i++)
	{
		int xx=x+dx[i],yy=y+dy[i];
		dfs(xx,yy,stepx,stepy);
		if(flag)return;
	}//四个方向dfs 
}
int main()
{
	while(scanf("%d%d",&n,&m)!=EOF)//多组数据 
	{
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				cin>>a[i][j];//这里如果用getchar()会被测试数据坑
				if(a[i][j]=='S')
					a[i][j]='.',sx=i,sy=j;
			}
		}
		memset(s,0,sizeof(s));
		memset(vis,false,sizeof(vis));
		flag=false;//初始化 
		dfs(sx,sy,1,1);
		if(flag)puts("Yes");
		else puts("No");
	}
	return 0;
}qwq
```

---

## 作者：LengChu (赞：22)

考虑什么时候才能走出这个迷宫。

**当你在其中一个迷宫走到了(x,y)这个点，在另一个迷宫也走到了(x,y)这个点，你就走出去了。**

所以这道题只需要在普通bfs的基础上，改变book数组的含义。

以前book数组表示(x,y)这个点是否被访问过，现在book数组有了双重含义，还表示了这个点是在哪一个迷宫中被访问的。

所以我们记录当前的实际坐标(x,y)，和在原迷宫中映射的坐标(tx,ty)=(x%n,y%m)。

对于实际坐标(x,y)，建立一个**hash值f(x,y)**。

**当拓展到一个点时，如果(tx,ty)这个点是障碍，直接continue。**

**如果f(x,y)==book[tx][ty]，就表示这个点曾经来过，continue。**

**如果f(x,y)!=book[tx][ty]&&book[tx][ty]!=0，就表示曾经在另一个迷宫中来过这个点，走出去了。**

**如果book[tx][ty]==0，表示这个点没有走过，继续bfs。**

f(x,y)这个函数看心情随便写就好啦，但是要注意不要和其他的f(x,y)重复。

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int ne[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
int book[1510][1510];
char s[1510][1510];
struct p { int x,y; };
int f(int x,int y) { return (x+n*4)/n*131+(y+m*4)/m*13; }//随便写的hash函数 
bool bfs(int x,int y)
{
	queue<p> q;
	q.push((p){x,y});
	book[x][y]=f(x,y);
	while(!q.empty())
	{
		p u=q.front(),v; q.pop();
		for(int i=0;i<4;i++)
		{
			v.x=u.x+ne[i][0]; v.y=u.y+ne[i][1];
			int tx=(v.x+n*4)%n,ty=(v.y+m*4)%m,t=f(v.x,v.y);//怕负数取模出问题 所以加上了n*4 
			if(s[tx][ty]=='#') continue;
			if(!book[tx][ty]) book[tx][ty]=t,q.push(v);
			else if(book[tx][ty]!=t) return 1; 
		}
	}
	return 0;
}
int main()
{
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		memset(book,0,sizeof(book));
		for(int i=0;i<n;i++) scanf("%s",s[i]);
		int x,y;
		for(int i=0;i<n;i++) 
			for(int j=0;j<m;j++)
				if(s[i][j]=='S')
				{
					x=i; y=j;
					break;
				}
		if(bfs(x,y)) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

---

## 作者：George1123 (赞：15)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1363 【幻象迷宫】传送门](https://www.luogu.org/problem/P1363)

### 此题算法：$dfs$(用$bfs$应该也行

错误思路1：

走到边界就行了

反例：

```cpp
3 3
.##
.S#
#..
```
错误思路2:

找到两个$S$可走到的对应出口

反例：
```cpp
5 3
#.#
S.#
.#.
#..
#.#
```
错误思路3：

拿出9个迷宫拼成9宫格并走到边界

反例：

```cpp
6 6
#.#.##
#.#...
#.###.
#...#.
###.#.
#S#.#.
```
## 正解：

1.把图存进$g[i][j]$数组,数组值为$1$表示墙，为$0$表示空地，为$2$表示走过的空地

2.把每个点的$g$数组值看成它在$n\times m$的矩阵中的映射点($Mapg$函数)的$g$值

3.把每个$n\times m$图中的点做上记号($sign$数组、$Mapt$函数)，表示$S$第一次在哪个$n\times m$的图上走到过这个点

4.如果一个点在不同的图上走到过$2$次，说明该幻象迷宫可通，答案为$Yes$，跳出$dfs$

5.如果图不通，可走的点个数必定有限，当$dfs$结束时，得出答案为$No$

以下是代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
struct point{
	int x,y;
	void make(int xl,int yl){
		x=xl; y=yl;
	} point Mapg(int n,int m){
		point ret;
		ret.x=((x-1)%n+n)%n+1;
		ret.y=((y-1)%m+m)%m+1;
		return ret;
	} point Mapt(int n,int m){
		point ret;
		if(x<=0) ret.x=x/n-1;
		else ret.x=(x-1)/n;
		if(y<=0) ret.y=y/m-1;
		else ret.y=(y-1)/m;
		return ret;
	}
}s,sign[1510][1510];
string in;
int g[1510][1510];
int f[4][2]={{0,1},
{0,-1},{1,0},{-1,0}};
bool ans;
void dfs(point st){
//	cout<<st.x<<" "<<st.y<<endl;
	if(ans) return;
	for(int i=0;i<4;i++){
		point nw,mp,sn;
		nw.make(st.x+f[i][0],
		st.y+f[i][1]);
		mp=nw.Mapg(n,m);
		sn=nw.Mapt(n,m);
		if(g[mp.x][mp.y]==2&&
		(sn.x!=sign[mp.x][mp.y].x
		||sn.y!=sign[mp.x][mp.y].y)){
			ans=1;
			return;
		} if(!g[mp.x][mp.y]){
			g[mp.x][mp.y]=2;
			sign[mp.x][mp.y]=sn;
			dfs(nw);
			if(ans) return; 
		}
	}
} int main(){
	while(cin>>n>>m){
		ans=0;
		memset(sign,0,sizeof(sign));
		memset(g,0,sizeof(g));
		for(int i=1;i<=n;i++){
			cin>>in;
			for(int j=1;j<=m;j++){
				g[i][j]=(in[j-1]=='#');
				if(in[j-1]=='S')
					s.make(i,j);
			}
		} sign[s.x][s.y].make(0,0);
		g[s.x][s.y]=2;
		dfs(s);
		if(ans) printf("Yes\n");
		else printf("No\n");
	} return 0;
}
```
最后注意一下输入格式就行了

谢谢大家！！


---

## 作者：Itst (赞：15)

#### 翻了题解为什么没有bfs做法的题解？？？
#### ~~所以我来发一个好了~~
#### 可能思路有bug还请指出，希望各位能在调试过程中举出该思路的一些反例（鞠躬）
#### 说实话这道题卡了好久，主要还是思路问题
#### 第一次的思路是如果能从S开始走回S就是Yes,否则就是No
#### 但当最后看到这个数据的我眼泪掉下来qwq
```
3 4
..#.
#.#S
#.##
```
#### 这个数据不能从S回到S，却能通过第二列无限走，所以上述思路直接被扔进垃圾桶
#### 那么第二次的想法就应运而生：如果在bfs过程中，找到了一个之前已经走过的点，而且从S开始走到这个点的两条道路不构成自环（比如说下面的数据就会构成自环，所以输出No），那么就可以无限走出去
```
4 4
####
.##S
.##.
####
```
#### 那么对于**不构成自环**要如何判断？想了很久想到了一个~~绝妙的~~方法：（我们令输入的数据为一个迷宫块）记录经过某个点时向左穿过迷宫块边界的次数（向右穿过了一个就记为-1）与向上穿过迷宫块边界的次数（向下穿过了一个也记为-1）

#### For example，在上面第二个数据中，S从（1,3）点走到（1,0）点，就是向右穿过了一个连通块边界

#### Then，通过bfs找到一个之前已经经过的点的时候，比较两次的向左穿过迷宫块边界与向上穿过迷宫块边界的次数，只要两个中有一个不相等，就表示这两条道路不构成自环，所以就可以愉快地输出Yes了


------------
#### 废话不多说上900ms蒟蒻代码（我是不会让你们抄袭的233）
```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[1501][1501];
//记录某个点是否被走过 
short UpL[1501][1501][2];
//记录到达某个点向左穿过迷宫块边界与向上穿过迷宫块边界的次数 
short dir[4][2] = {1 , 0 , -1 , 0 , 0 , 1 , 0 , -1} , a , b , pp , qq;
//short省空间 
int mian（） 
{
	ios::sync_with_stdio（false）;
	while（cin >> a >> b）
	{
		memset（vis , 0 , sizeof（vis））;
		memset（UpL , 0 , sizeof（UpL））;
		//一定要记得初始化！ 
		for（int i = 0 ; i < a ; i++）
			for（int j = 0 ; j < b ; j++）
			{
				char c;
				cin >> c;
				if（c == '#'）
				{
					vis[i][j] = 1;
					UpL[i][j][0] = 32767;
				}
				else	if（c == 'S'）{
					pp = i;
					qq = j;
				}
			}
		bool f = 0;
		//记录是否已经找到解 
		queue < pair<short , short> > q;
		//不知道pair的请自行百度STL  
		vis[pp][qq] = 1;
		q.push（make_pair（pp , qq））;
		while（!q.empty（） && !f）
		{
			pair < int , int > p = q.front（）;
			q.pop（）;
			for（int i = 0 ; i < 4 && !f ; i++）
			{
				pair < int , int > t （p.first + dir[i][0] , p.second + dir[i][1]）;
				int n = UpL[p.first][p.second][0] , m = UpL[p.first][p.second][1];
				if（t.first < 0）{//向上穿过了一个迷宫块边界 
					t.first += a;
					m++;
				}
				else	if（t.first >= a）{//向下穿过了一个迷宫块边界 
					t.first -= a;
					m--;
				}
				if（t.second < 0）{//向左穿过了一个迷宫块边界 
					t.second += b;
					n++;
				}
				else	if（t.second >= b）{//向右穿过了一个迷宫块边界 
					t.second -= b;
					n--;
				}
				if（!vis[t.first][t.second]）//如果没有走过 
				{
					vis[t.first][t.second] = 1;
					UpL[t.first][t.second][0] = n;
					UpL[t.first][t.second][1] = m;
					q.push（t）;
				}
				//如果走过了、不是障碍且向左穿过迷宫块边界与向上穿过迷宫块边界次数至少有一个不相同，表示已经找到解 
				else	if（UpL[t.first][t.second][0] - 32767 && （UpL[t.first][t.second][0] - n || UpL[t.first][t.second][1] - m））
					f = 1;
			}
		}
		if（f）	cout << "Yes" << endl;
		else	cout << "No" << endl;
	}
	return 0;
}
```

---

## 作者：阿尔萨斯 (赞：9)

[来看看原题？](https://www.luogu.org/problemnew/show/P1363)
这道题目是由超级经典的深搜走迷宫衍生而来的。大家应该都会简单的走迷宫，以及通过判断是否走过这个点来进行优化，下面我讲讲这题的大致思路。

首先这题的思路可能不同的人第一眼看到后想到的不太一样。这里有几个样例可以让你大致判断一下你的思路可不可行。
```
#.##
..#S
#.##
#.##
Yes
```

```cpp
###.###
##..###
#..####
..###..
####..#
###..##
###S###
Yes
```

```cpp
#####
..#..
#S#.#
..#..
#####
No

```
如果这些样例你的思路都没问题，那就应该没太大问题了。欢迎评论补充或指正！

首先我的第一思路是如果能走回原点就可以走出去，碰边就传送去地图的另外一侧，模拟一个无尽迷宫。当然，迷宫不能是真的模拟无尽的，时间不允许。所以我们加入数组bj[]用来标记是否走过。

1、关于走回原点:
```cpp
#####
#.S.#
#.#.#
#...#
#####
No
```
走回原点，但只是真正的原点，所以这很蠢。

有个大佬说这种思路可以丢进垃圾桶了，但我们为什么不想想怎么改进？
想想，如果迷宫是无限的，走进下一个可以称作“原点”但又不是真正原来的点，也就是说坐标相同，但实质不同的点，是必须要穿过边界的。所以我们深搜时引入一个变量记录不就好了？
```cpp
#####
..#..
#S#.#
..#..
#####
No
```
emmm很明显这样简单的做法是没办法成功的。穿过两次边，和回原点没什么两样。嗯，所以判断下穿过边的次数是不是奇数不就好了？
```cpp
###.###
##..###
#..####
..###..
####..#
###..##
###S###
Yes
```
穿过了两次边，然而还是能走出去。两者之间有什么不同？

对了，前者是穿左右的边两次，后者是穿左右和上下的边各一次，还是奇数！

我没法证明这个结论的正确性，至少对luogu的样例而言它相对正确。
2、关于bj[]

```
#.###
..#S.
#.###
#.###
Yes
```
根本走不回去，因为S右边的点一定会被标记走过。

怎么办？结合上述内容，尝试和穿边的次数结合起来，在不同情况下使用不同的bj[]，穿两次同向边后和回到原地没什么两样，被bj[]堵回去是应该的。

说了这么多，看看代码吧 _qwq_ 

请不要抄袭代码，而是试着跟着思路和代码中给的解释和大致结构打一下吧。代码中留了~~大量~~一些小小的陷阱，别对着打，更别想着ctrl+C  _qwq_ 


------------

```cpp
#include<iostremmm>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iomanip>
#define ll long
using namespace std;
ll read()//快读
{
	ll s=0;
	char c=getchar();
	while(c<='0'||c>='9')c=getchar();
	while(c>'0'&&c<'9')
	{
		s=s*10+c-'0';
		c=getchar();
	}
	return s;
} 
ll m,n;
bool bj[1500][1500][2][2];
ll yesorno;
char a[1500][1500];
void f(ll x,ll y,ll nn,ll mm,ll j,ll k)//喜闻乐见的搜索
{
	if(x<0)
	{
		x=nn-1;
		if(j==1)j=0;else j=1;
	}
	if(y<0)
	{
		y=mm-1;
		if(k==1)k=0;else k=1;
	}
	if(x>=nn)
	{
		x=0;
		if(j==1)j=0;else j=1;
	}
	if(y>=mm)
	{
		y=0;
		if(k==1)k=0;else k=1;
	}//这四块是判断是否到边并更改走边的次数
	if(a[x][y]=='#')return;
	if(a[x][y]=='S'&&(j==1||k==1))yesorno++;//如果回到原点且走边的次数（不论是上下边还是左右边）为奇数，则确定可以走出去
	if(bj[x][y][j][k]!=0)return;//走过再走就会浪费时间，优化一波
	
	if(yesorno>0)return;
	
	bj[x][y][j][k]=1;
	f(x-1,y,nn,mm,j,k);
	f(x,y-1,nn,mm,j,k);
	f(x+1,y,nn,mm,j,k);
	f(x,y+1,nn,mm,j,k);//简单易懂的四向搜索
	return;
}
int ma1n()
{
	while(cin>>n>>m)//不知道为什么不用这种输入方式就会被卡掉
	{
		ll lox,loy;
		for(ll i=0;i<n;i++)
		{
			for(ll o=0;o<m;o++)
			{
				cin>>a[i][o];
				bj[i][o][0][0]=bj[i][o][0][1]=bj[i][o][1][0]=bj[i][o][1][1]=0; //读入并初始化这个点的bj[]为0,不用memset浪费时间
				if(a[i][o]=='S')
				{
					lox=i;
					loy=o;
				}//记录原点位置
			} 
			getchar();//不知道是回车符还是怎么回事，一定要用这个把回车符滤掉，不然读入出错
		}
		yesorno=0;
		f(lox,loy,n,m,0,0);//从原点出发再穿边后回到原点才是正解
		if(yesorno>0)printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```


------------

压着时空过关……第一次写这么长的题解，希望帮到大家！

---

## 作者：revenger (赞：6)

把原来的矩阵边长扩充到2倍(2n\*2m) 从S点开始洪水填充 超过边界就传送到另一边对应的位置

如果在洪水的过程中填充到了一个不在原来矩阵的点 这个点在4个子矩阵中任一矩阵的对应点已经被洪水填充过了的话 返回YES

非常暴力 但是居然过了 我都做好TLE的准备了

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int f[3001][3001],n,m,a,b,p;
char ch;
void dfs(int x,int y)
{
    if(p)
    return;
    if(x>=n||y>=m)
    {
        if(f[x%n][y%m]==2||f[x%n+n][y%m]==2||f[x%n][y%m+m]==2||f[x%n+n][y%m+m]==2)
        {
            p=1;
            f[x%n][y%m]=3;
            return;
        }
    }
    f[x][y]=2;
    if(f[(x+1+2*n)%(2*n)][y]==0) dfs((x+1+2*n)%(2*n),y);
    if(f[(x-1+2*n)%(2*n)][y]==0) dfs((x-1+2*n)%(2*n),y);
    if(f[x][(y-1+2*m)%(2*m)]==0) dfs(x,(y-1+2*m)%(2*m));
    if(f[x][(y+1+2*m)%(2*m)]==0) dfs(x,(y+1+2*m)%(2*m));
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    while(cin>>n>>m)
    {
        memset(f,0,sizeof(f));
        p=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                cin>>ch;
                if(ch=='#')
                f[i][j]=1;
                if(ch=='S')
                a=i,b=j;
            }
        }
        for(int i=0;i<n;i++)
        for(int j=m;j<2*m;j++)
        f[i][j]=f[i][j-m];
        for(int i=n;i<2*n;i++)
        for(int j=0;j<2*m;j++)
        f[i][j]=f[i-n][j];//矩阵扩充 
        dfs(a,b);
        if(p)
        printf("Yes\n");
        else
        printf("No\n");
//        for(int i=0;i<2*n;i++)
//        {
//        for(int j=0;j<2*m;j++)
//        {
//            cout<<f[i][j];
//        }
//        cout<<endl;
//        }
    }
}
```

---

## 作者：xiejinhao (赞：4)

# P1363 幻想迷宫 题解

之前膜拜了一下Dalao们的题解，很多人说复制成到原来的3倍的矩阵会超空间，可是为什么要把1*1的迷宫拓展成3*3的呢？不如我们就拓展成2*2的，这样保证了内存是绝对不会超的，我做完内存36M。

那么复制矩阵的操作就不用解释了，接着很明显，深搜就完了。

思路如下：

1. 走到的点标记下，一开始输入的墙标记为1，走过的地方标记为2；每次走的时候都对长宽的两倍取余，保证不越界，这一点和别人写的思想应该是差不多的。

1. 以上，那么越界的时候我们就传送回去；但是，在这传送之前，我们就可以判断这个地方是否被走过了（上述的越界是超过n*m），如果走过，就意味着我们可以从原来的矩阵走到下一矩阵的该位置，因为地图是无限大的，那么我们是不是就可以认为可以走的出去呢？这么想就是正确的。

对于以上第二点，我们可以把边界写出来。

在此之前，有些读者可能不理解，我下面给出进行解释：

```cpp
                  if(x>=n || y>=m)
```


边界一：

```cpp
                  f[x%n][y%m]==2
```
**由于我们的填充方式，我们不会重复走我们走过的**，这意味着虽然我们越界会被“传送”回来，但是这个**位置被填充过了就不能走**，那么如果我们回来了，这是不是意味着我们可以无限走呢？那么我们就“离开”了迷宫。

边界二：

```cpp
                  f[x%n+n][y%m]==2
```

这个与边界一很像，如果我们到了其他矩阵的相应位置，那么貌似也是可以无限走的，所以其他边界也就很容易得出：

```cpp
                  f[x%n][y%m+m]==2
                  f[x%n+n][y%m+m]==2
```

遇到以上条件，那么我们就可以停止了。那么我们需要一个标志变量，表示我们找到了答案，然后以这个标志变量为边界退出其他搜索（第一次搜到能走出去就行了）。

特别的，我还准备了几张图供读者理解：

![](https://i.loli.net/2019/05/10/5cd585cf12f9c.png)

![](https://i.loli.net/2019/05/10/5cd585cf12f15.png)

![](https://i.loli.net/2019/05/10/5cd585cf12fcd.png)

这三张图表示的都是我们可以走到其他矩阵的相应位置，当然，**不一定是S走到下一个S**。虽然**对于二三图在该样例中是不能实现的，但是遇到其他地图就可能了**，这里只是给出图片供大家理解。

那么要是以上步骤都不执行，就判断是否越界，不越界就走到下一步，越界就传送回来。

给出两个部分的代码：



$code1$ 复制矩阵操作
------------

```cpp
  for(int i=0;i<n;i++) {
      for(int j=0;j<m;j++) {
          cin>>c;
          if(c=='#') //复制操作
              f[i][j]=f[i+n][j]=f[i][j+m]=f[i+n][j+m]=1;
          if(c=='S') x=i,y=j;//记录出发位置
      }
  }
```


$code2$ 搜索部分（~~核心~~）
------------

```cpp
inline void dfs(int x,int y) {
	if(flag) return;
	if(x>=n || y>=m) {
		if(f[x%n][y%m]==2||f[x%n+n][y%m]==2||f[x%n][y%m+m]==2||f[x%n+n][y%m+m]==2) { //边界
			flag=true;
			return;
		}
	}
        //这个位置走过了
	f[x][y]=2;
        //判断是不是能走
	if(!f[(x+1+2*n)%(2*n)][y]) dfs((x+1+2*n)%(2*n),y);
	if(!f[(x-1+2*n)%(2*n)][y]) dfs((x-1+2*n)%(2*n),y);
	if(!f[x][(y+1+2*m)%(2*m)]) dfs(x,(y+1+2*m)%(2*m));
	if(!f[x][(y-1+2*m)%(2*m)]) dfs(x,(y-1+2*m)%(2*m));
}
```
当然，剩下的就大家去补充吧（~~我都写了这么多不要说你不会~~）

~~然后我们就成功AC了~~

复杂度大约是$O(NM)+$递归时间复杂度?（反正不高）

**特别的：第二段代码中的flag的变量和是全局的，如果搜索完后是假那么就输出$NO$，并且，由于有多组测试数据，读入和清零是需要注意的。**

![](https://i.loli.net/2019/05/10/5cd58a5637575.png)

![](https://i.loli.net/2019/05/10/5cd58a5651555.png)


~~不点个赞再走吗orz~~
------------



---

## 作者：YTand17 (赞：3)

作为有个蒟蒻，我想记录下我这题的自闭的那些坑！

做的时候想错了思路：

- 以为只要走到边界就是答案

- 想简单了，以为只要能够一直走，不会被拦下来就是成功 
结果看到了这个测试点：

		#.#.#
		..#..
		#####
		.S#..
		#.#.# 
        
 
    可以尝试把它填满9宫格矩阵，会发现从任何一个点
	开始走，最后都会回到这个点，那么这就相当于在
	绕圈圈，这样也可以一直走。但是这样根本不是答案 

- 以为每经过一个地图，就必须经过S点，直到我看见这个样例：


		3 4
		..#.
		#.#S
		#.##  
        
第二列可以一直走下去
		
 
~~敲黑板~~

注意：题意是地图无限大!有无限个一样的矩阵连接起来，所以只需要 
有一条道路能够一直走下去，而不是绕圈，不是返回到S点
而是找到一条可以一直走下去的路，要远离S点。不撞南墙不回头 那种 

```cpp
所以我想到了，虚拟坐标，它走让它走。
声明：
		flag[x][y][0]标记这个点是否走过
		flag[x][y][1]记录虚拟坐标的rx的坐标
	    flag[x][y][2]记录虚拟坐标的ry的坐标
	(rx,ry)坐标下面说明： 
```

	  
DFS中的 3 4 参数是（rx,ry）坐标，这个坐标不做任何处理，无论是正是负，都让它走。
     
	 1.如果走到走过的点，(x,y)也就是flag[x][y][0]==1
	 2.判断这个点的虚拟坐标(rx,ry)是否等于==(rx,ry)
	 	如果相等(==)：说明原来走得路都是在绕圈！ 
	 	如果不相等(!=)：说明可以无限走下去！ 

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,flag[2001][2001][4],yes=0;
char a[2001][2001];
int fz[][2]={0,1,1,0,0,-1,-1,0};
 //正常取模(x,y)坐标，不做任何处理的虚拟坐标(rx,ry) 
void DFS(int x,int y,int rx,int ry){
	if(yes || a[x][y]!='.') return ; //如果找到答案或者不是路 
	//printf("%d %d\n",x,y);
	if(flag[x][y][0]){ //如果这个点之前走过 
		if(flag[x][y][1]!=rx || flag[x][y][2]!=ry){
			yes=1; //如果正常取模坐标(x,y)!=虚拟坐标(rx,ry) 
		}         //成功！ 
		return ;
	}
	flag[x][y][0]=1; //标记这个走过 
	flag[x][y][1]=rx; //而且记录此时的虚拟坐标 (rx,ry)
	flag[x][y][2]=ry;// 
	for(int i=0;i<4;i++){
		int xx=(x+fz[i][0]+n)%n,yy=(y+fz[i][1]+m)%m;
		//看这里：(xx,yy)是正常取模坐标 
		DFS(xx,yy,rx+fz[i][0],ry+fz[i][1]);
	}  //而(rx+fz[i][0],ry+fz[i][1])是不做任何处理的虚拟坐标 
}
int main(){
	while(scanf("%d%d",&n,&m)!=EOF){
		int x,y;
		for(int i=0;i<n;i++){ //输入有个小坑 
		    scanf("%s",&a[i]);//需要不读空格和回车的输入 
			for(int j=0;j<m;j++){
				if(a[i][j]=='S') x=i,y=j,a[i][j]='.';
			}
		} 
		DFS(x,y,x,y); 
		if(yes==1) printf("Yes\n");
		else printf("No\n");
		yes=0;
		memset(fla//g,0,sizeof(flag)); //防！
	}
} 
```
求审核大大让过~蒟蒻的无能狂怒

---

## 作者：Hexarhy (赞：3)

### 这道题目的重点在于读题$QAQ$

------------

开头先放：

1. 参考了@[$ygsldr$](https://www.luogu.org/space/show?uid=32576)的题解和程序。

1. 本篇文章只是为了巩固小编编程能力知识点，并没有恶意抄袭之意（求管理员大大放过惩罚，不求过$QAQ$）。

1. 本篇题解思路基本与$ygsldr$相同，小编只做细讲。

1. 最后，请原作者见谅！$STO$

------------

【题目描述】简化版，也许能帮助你理解题目。

> 迷宫认为是**无限大**的，由**若干个$N\times M$的矩阵重复**组成。

> $1.$ 矩阵中有的地方是道路，用'.'表示；

> $2.$ 有的地方是墙，用'#'表示。

> $3.$ 起点用'S'表示。

> $4.$ 也就是对于迷宫中的一个点$(x,y)$，如果 $(x\ \% \ n,y\ \% \ m)$ 是 '.' 或者 'S' ，那么这个地方是**道路**；
 
> $5.$ 如果 $(x\ \% \ n,y\ \% \ m)$ 是 '#'，那么这个地方是**墙**。


> $6.$ 可以向**上下左右**四个方向移动，当然不能移动到墙上。

> $7.$ 如果它们能**无限走下去**，就认为能走出去。


------------
此时很明显，如果要无限走下去，那么我们只要表示成，遇到墙就**穿越**到对面过去，继续走。

$\color{red} \text{那么此时问题就好办了！}$

此时的样例解释解释图就可以这样画：

![](https://cdn.luogu.com.cn/upload/pic/48809.png)

那么接下来就是比较基础的搜索，我们还是采用bool返回，判断是否是同一个位置，即：
> 很明显，假如能走到之前走到过的环境相同的点即$(x\ \% \ n,y\ \% \ m)$，记作$A->B$，那么就一定有$B->$同一个环境$(x\ \% \ n,y\ \% \ m)$的点
> 
> 同一个环境就是他的**映射位置相同**

$\color {blue} \text{稍微注意：迷宫最好从0开始，因为mod的时候会有0产生。}$


------------


那么其他的细节请参考程序：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

const int MAXN=1600;
const int dx[4]={1,-1,0,0};
const int dy[4]={0,0,1,-1};
//这里是为了方便表示四个方向，学过坐标轴的应该都懂。
char a[MAXN][MAXN];
bool map1[MAXN<<1][MAXN<<1],map2[MAXN][MAXN];
//map1表示有无走到过这个点，map2表示有无走到过映射点
//扩展2倍的原因只是为了方便穿越以及映射
int n,m,dn,dm;
//dn,dm是扩展后的迷宫长宽。

//本文的迷宫都是从0开始。

bool dfs(int x,int y)//bool表示是否符合要求
{
	if(x==-1)
	 return dfs(dn-1,y);
	if(x==dn)
	 return dfs(0,y);
	if(y==-1)
	 return dfs(x,dm-1);
	if(y==dm)
	 return dfs(x,0);
    //上面四个就是遇到边界时“穿越”。
	const int xx=x%n;
	const int yy=y%m;
    //方便表示扩展后的迷宫与实际迷宫的对应坐标。
	if(map1[x][y] || a[xx][yy]=='#')
	 return false;//映射是墙或者在扩展迷宫里走过就不符要求
	if(map2[xx][yy])
	 return true;//一一对应了，就返回true
	map1[x][y]=true;
	map2[xx][yy]=true;
    //记得标记
	for(int i=0;i<4;i++)
	 if(dfs(x+dx[i],y+dy[i]))
	  return true;//遍历四个方向
	return false;//防止到了结尾还没有return的保险措施
 } 
 
void input(void)
{
	while(cin>>n>>m)
	{
		dn=n<<1;
		dm=m<<1;
		int beginx,beginy;
		for(int i=0;i<n;i++)//迷宫从0开始哦
		 for(int j=0;j<m;j++)
		 {
		 	cin>>a[i][j];
		 	if(a[i][j]=='S')
		 	{
		 		beginx=i;
		 		beginy=j;
			 }//别忘了记录起始点
		 }
		memset(map1,0,sizeof(map1));
		memset(map2,0,sizeof(map2));
        //别忘了每次清零映射数组
		cout<<((dfs(beginx,beginy))?"Yes":"No")<<endl;
	}
}

int main()
{
	input();
	return 0;
}
```

#### 华丽丽的结束！

---

## 作者：Garrison (赞：2)

本蒟蒻被这道题卡了很久，将近一个小时才过，其原因就是坑人的MLE。特别是我那90分的代码，加了很多优化才过。

（在大家阅读文章之前先阅读一下90分的程序并想一想如何省空间）
```
#include<iostream>
#include<string.h>
#define N 4505
int n,m,sx,sy;
char c;
int wx[5]={0,0,1,-1};int wy[5]={1,-1,0,0};
bool ok;int b[N][N];
inline void dfs(int x,int y){
	if(x>3*n) x-=3*n; if(y>3*m) y-=3*m;  if(x<1) x+=3*n; if(y<1) y+=3*m;
	if(b[x][y]==1||ok||x>3*n||x<1||y>3*m||y<1)
		return;
	if(b[x][y]==2){
		ok=true;
		return;
	}
	b[x][y]=1;
	for(register int i=0;i<4;++i)
		dfs(x+wx[i],y+wy[i]);
	return;
}
signed main(){
	std::ios::sync_with_stdio(false);
	std::cout.tie(0);
	while(std::cin>>n>>m){
		ok=false;memset(b,0,sizeof b);
		for(register int i=n+1;i<=2*n;++i)
			for(register int j=m+1;j<=2*m;++j){
				std::cin>>c;
				if(c=='S')
					sx=i,sy=j,b[i-n][j-m]=b[i-n][j]=b[i-n][j+m]=b[i][j-m]=b[i+n][j+m]=b[i+n][j]=b[i][j+m]=b[i+n][j-m]=2;
				if(c=='#')
					b[i-n][j-m]=b[i-n][j]=b[i-n][j+m]=b[i][j-m]=b[i+n][j+m]=b[i+n][j]=b[i][j+m]=b[i+n][j-m]=b[i][j]=1;
			}
		dfs(sx,sy);
		if(ok)
			std::cout<<"Yes"<<std::endl;
		else std::cout<<"No"<<std::endl;
	}	
	return 0;
}

```
观察题目，不难想到一种DFS算法，将原有一幅图复制成九份
```
对于“a”
我们将其变为
	aaa
	aaa
	aaa
所以对于样例第一个
##.#
##S#
#..#
#.##
#..#
可以变为
##.# ##.# ##.#
##S# ##S# ##S#
#..# #..# #..#
#.## #.## #.##
#..# #..# #..#

##.# ##.# ##.#
##S# ##S# ##S#
#..# #..# #..#
#.## #.## #.##
#..# #..# #..#

##.# ##.# ##.#
##S# ##S# ##S#
#..# #..# #..#
#.## #.## #.##
#..# #..# #..#
```
所以我们只要将原本的数组开个三倍，再对于输入如此处理（先输入中间的）就可以达成复制9份的想法：（在此，我们将‘S’看为2，‘#’看做1，‘.’看做0）
```
for(register int i=n+1;i<=2*n;++i)
	for(register int j=m+1;j<=2*m;++j){
		std::cin>>c;
		if(c=='S')
			sx=i,sy=j,b[i-n][j-m]=b[i-n][j]=b[i-n][j+m]=b[i][j-m]=b[i+n][j+m]=b[i+n][j]=b[i][j+m]=b[i+n][j-m]=2;
		if(c=='#')
			b[i-n][j-m]=b[i-n][j]=b[i-n][j+m]=b[i][j-m]=b[i+n][j+m]=b[i+n][j]=b[i][j+m]=b[i+n][j-m]=b[i][j]=1;
			}
```
题目告诉我们，无限远就可以走出此城堡，那么我们根据样例以及自己大胆的猜测可以得出一个结论
#### 只要我们从中间那一份的起点开始走，走到别份的起点S位置（及标号2）就是yes，相反为no
所以我们可以写出如下dfs：
```
inline void dfs(int x,int y){
	if(x>3*n) x-=3*n; if(y>3*m) y-=3*m;  if(x<1) x+=3*n; if(y<1) y+=3*m;
	if(b[x][y]==1||ok||x>3*n||x<1||y>3*m||y<1)
		return;
	if(b[x][y]==2){
		ok=true;
		return;
	}
	b[x][y]=1;
	for(register int i=0;i<4;++i)
		dfs(x+wx[i],y+wy[i]);
	return;
}
```
那么如果ok==true 输出yes，否则输出no

但是只有九十分，那我们如何改呢？

![](https://s2.ax1x.com/2020/01/13/lHNpIf.png)

发现最后一点爆了空间MLE，倒数第二个点卡过去了，看了看代码，发现int a数组真正用到的只有几个数字：0,1,2，那么我们用char来代替int如何？
### char的所占字节比int小得多

说试就试，果不其然：
![](https://s2.ax1x.com/2020/01/13/lHNNo6.png)

# Code
（满分：将int改成char的已标注）
```
#include<iostream>
#include<string.h>
#define N 4505
int n,m,sx,sy;
char c;/*a数组没有用，所以换成了c*/
int wx[5]={0,0,1,-1};int wy[5]={1,-1,0,0};
bool ok;char b[N][N];/*int 变成了 char*/
inline void dfs(int x,int y){
	if(x>3*n) x-=3*n; if(y>3*m) y-=3*m;  if(x<1) x+=3*n; if(y<1) y+=3*m;
	if(b[x][y]=='1'||ok||x>3*n||x<1||y>3*m||y<1)
		return;
	if(b[x][y]=='2'){
		ok=true;
		return;
	}
	b[x][y]='1';
	for(register int i=0;i<4;++i)
		dfs(x+wx[i],y+wy[i]);
	return;
}
signed main(){
	std::ios::sync_with_stdio(false);
	std::cout.tie(0);
	while(std::cin>>n>>m){
		ok=false;memset(b,0,sizeof b);
		for(register int i=n+1;i<=2*n;++i)
			for(register int j=m+1;j<=2*m;++j){
				std::cin>>c;
				if(c=='S')
					sx=i,sy=j,b[i-n][j-m]=b[i-n][j]=b[i-n][j+m]=b[i][j-m]=b[i+n][j+m]=b[i+n][j]=b[i][j+m]=b[i+n][j-m]='2';/*there*/
				if(c=='#')
					b[i-n][j-m]=b[i-n][j]=b[i-n][j+m]=b[i][j-m]=b[i+n][j+m]=b[i+n][j]=b[i][j+m]=b[i+n][j-m]=b[i][j]='1';/*there*/
			}
		dfs(sx,sy);
		if(ok)
			std::cout<<"Yes"<<std::endl;
		else std::cout<<"No"<<std::endl;
	}	
	return 0;
}

```




---

## 作者：AkiwaZawa (赞：2)

## DFS



#### 简化题目


现在有一个无限扩张的矩阵
问，点S能否遍历


#### 思路分析

    如果不同矩阵上的点可以遍历两次则说明他可以遍历往无限远处
    所以可以把幻阵映射到原阵上，把幻阵DFS一遍
    两次幻阵不一样则说明同一个点在不同阵上被遍历到了
    (具体注释请看代码）


#### 打上代码

```
#include<bits/stdc++.h>
#define ll long long
#define fo(i,j,n) for(register int i=j; i<=n; ++i)
#define R register int
using namespace std;
const int dx[] = {-1,1,0,0};
const int dy[] = {0,0,-1,1};
int n,m,vis[3][1600][1600];
char mp[1600][1600];
bool ans;
// (x,y)为原阵上的点，(fx,fy)为幻阵上的点(未取模) 
inline void dfs(int x, int y, int fx, int fy)
{ // falsex 
	if(ans)return;
	// 如果已经访问过，并且两次幻阵坐标不同，说明访问过两次原阵 
	if(vis[0][x][y] && (vis[1][x][y]!=fx || vis[2][x][y]!=fy))
    {
		ans = 1;
		return;
	}
	// 标记原阵已经访问过，并且记录幻阵坐标 
	vis[0][x][y]=1,vis[1][x][y]=fx,vis[2][x][y]=fy; 
	fo(i,0,3)
    {
		int nowx=x+dx[i]+n)%n;
		int nowy=(y+dy[i]+m)%m;
		int nowfx=fx+dx[i];
		int nowfy=fy+dy[i];
		if(mp[nowx][nowy]!='#')
        {
			// 未访问过，或者访问不同的点 
			if(!vis[0][nowx][nowy] || vis[1][nowx][nowy]!=nowfx || vis[2][nowx][nowy]!=nowfy){
				dfs(nowx,nowy,nowfx,nowfy); 
			}
		}
	} 
}

int main()
{
	while(scanf("%d%d",&n,&m)!=EOF)
    {
		int x,y,flag=0;
		for(R i=0; i<n; i++)
        {
			scanf("%s",mp[i]);
			if(flag)continue;
			for(R j=0; j<m; j++)
            {
				if(mp[i][j]=='S')
                {
					x=i;
					y=j;
					flag=1;
				}
			}
		}
		ans = 0;
		memset(vis[0], 0, sizeof(vis[0]));	
		dfs(x,y,x,y);
		if(ans)puts("Yes");
		else puts("No");
	}
	return 0;
} 

```


---

## 作者：qwertyuiopywh (赞：2)

因为幻象迷宫可以认为是无限大的，所以就可以把原来的矩阵扩大2倍（**注意 不可以是3倍会超时**）。
首先先读入，并且建图。
```cpp
for(int i=0;i<n;i++)
{
    for(int j=0;j<m;j++)
    {
        cin>>a;
        if(a=='#')
       {
            f[i][j]=1;
	    f[i][j]=1;
	    f[i+n][j+m]=1;
	    f[i][j+m]=1;
	    f[i+n][j]=1;
        }
        if(a=='S')
        {
             xa=i;
	     ya=j;
        }
                
     }
}
```
接着是搜索！！！（因为要去“%”，所以我没用增量数组）
```cpp
void dg(int x,int y)
{
    if(ans==1)
    {
    	return;
    }
    if(x>=n||y>=m)
    {
	if(f[x%n][y%m]==1||f[x%n+n][y%m]==1||f[x%n][y%m+m]==1||f[x%n+n][y%m+m]==1)
        {
     	    ans=1;
     	    return;
    	}
   	}
   	f[x][y]=1;//标记要统一，不然会全“No”
    if(f[(x+1+2*n)%(2*n)][y]==0) 
	{
		dg((x+1+2*n)%(2*n),y);
	}
    if(f[(x-1+2*n)%(2*n)][y]==0)
	{
		dg((x-1+2*n)%(2*n),y);
	}
    if(f[x][(y+1+2*m)%(2*m)]==0) 
	{
		dg(x,(y+1+2*m)%(2*m));
	}
    if(f[x][(y-1+2*m)%(2*m)]==0)
	{
		dg(x,(y-1+2*m)%(2*m));
	} 
}
```
**ans和f数组最后都要清零**。


完整代码
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<string>
#include<cstdio>
using namespace std;
int n,m,xa,ya,xx,yy;
char a;
bool f[4500][4500],ans=0;
void dg(int x,int y)
{
    if(ans==1)
    {
    	return;
    }
	if(x>=n||y>=m)
    {
	    if(f[x%n][y%m]==1||f[x%n+n][y%m]==1||f[x%n][y%m+m]==1||f[x%n+n][y%m+m]==1)
        {
     	    ans=1;
     	    return;
    	}
   	}
   	f[x][y]=1;
    if(f[(x+1+2*n)%(2*n)][y]==0) 
	{
		dg((x+1+2*n)%(2*n),y);
	}
    if(f[(x-1+2*n)%(2*n)][y]==0)
	{
		dg((x-1+2*n)%(2*n),y);
	}
    if(f[x][(y+1+2*m)%(2*m)]==0) 
	{
		dg(x,(y+1+2*m)%(2*m));
	}
    if(f[x][(y-1+2*m)%(2*m)]==0)
	{
		dg(x,(y-1+2*m)%(2*m));
	} 
}
int main()
{
    while(cin>>n>>m)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                cin>>a;
                if(a=='#')
                {
                	f[i][j]=1;
					f[i][j]=1;
					f[i+n][j+m]=1;
					f[i][j+m]=1;
					f[i+n][j]=1;
                }
                if(a=='S')
                {
                	xa=i;
					ya=j;
                }
                
            }
        }
        dg(xa,ya);
        if(ans==1)
		{
			ans=0;
			printf("Yes\n");
		} 
        else
        {
        	printf("No\n");
        }
        memset(f,0,sizeof(f));
    }
}
```


---

## 作者：Huami360 (赞：2)

这题其实可以很简单。

题目叫做“幻想迷宫”，那么我们就幻想一个迷宫。

借用一下@FancyDreams的图片

![](https://cdn.luogu.com.cn/upload/pic/9195.png)

只有左上角第一个$5*4$的迷宫是真的,
其他都是我们幻想出来的。

并且，我们幻想自己在中间那个$5*4$的迷宫里的S处，我们并不需要开多很多倍的数组，要获取这个位置是'.'还是'#'，只需对当前坐标取余$n,m$即可。注意一个细节，直接取余的话若$x=n$，那么取余后就变成0了，所以我们要这样：

$$(x-1)\ mod\ n + 1$$
y坐标同理。每走到一个点标记vis[取模后的坐标] = 当前迷宫的坐标，比如上图中，左上角的迷宫坐标是1，中上那个是2，最中间的是5，右下角的是9。

然后向4个方向拓展，如果这里不是'#'，再判断，如果这个位置走过了并且不是在当前幻想的迷宫走的，那么恭喜，$flag = 1; return;$。否则继续搜。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#define rep(i,m,n) for(int i=m;i<=n;++i)
#define dop(i,m,n) for(int i=m;i>=n;--i)
using namespace std;
inline int read(){
    int s = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')w = -1;if(ch==-1) exit(0); ch = getchar();} //快读小细节，getchar()==-1时直接exit(0);
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0',ch = getchar();
    return s * w;
}
const int MAXN = 1600;
char a[MAXN][MAXN];
int n, m, sx, sy;
int vis[MAXN][MAXN], flag;
int l[] = { 233, -1, 1, 0, 0 }, r[] = { 666, 0, 0, -1, 1 };
inline char get(int x, int y){//获取当前的位置能不能走
    return a[(x - 1) % n + 1][(y - 1) % m + 1];
}
void dfs(int x, int y){
    if(flag) return; //找到了，直接返回
    vis[(x - 1) % n + 1][(y - 1) % m + 1] = ((x / n - !(x % n)) * 3 + (y / m - !(y % m)) + 1); //标记这个位置是在当前幻想的迷宫走的
    rep(i, 1, 4){ //向四个方向拓展
       int X = x + l[i], Y = y + r[i];//X,Y为要到的位置
       if(vis[(X - 1) % n + 1][(Y - 1) % m + 1] && vis[(X - 1) % n + 1][(Y - 1) % m + 1] != ((X / n - !(X % n)) * 3 + (Y / m - !(Y % m)) + 1)){ //如果走过了并且不是在当前迷宫走的，说明可以重复到达这个位置，也就是可以无限的走
         flag = 1;
         return ;
       }
       if(get(X, Y) != '#' && !vis[(X - 1) % n + 1][(Y - 1) % m + 1]) dfs(X, Y); //如果能走，dfs
    }
}
int main(){
    while(233){
      n = read(); m = read();
      rep(i, 1, n) rep(j, 1, m){
         a[i][j] = getchar();
         while(a[i][j] != '.' && a[i][j] != '#' && a[i][j] != 'S')
           a[i][j] = getchar();
         if(a[i][j] == 'S') sx = i, sy = j;
      }
      dfs(sx + n * 100, sy + m * 100);
      memset(vis, 0, sizeof(vis));
      if(flag){
        printf("Yes\n");
        flag = 0;
      }
      else printf("No\n");
    }
    return 0;
}

```

---

## 作者：mike_he (赞：2)

看到貌似没有代码的题解，我写一个吧。

第一次写了个bfs发现很无语，爆了20(模运算处理不当)

后来发现那些测试点速度都不是很慢，所以应该DFS不会爆栈(而且dfs特别好写)

事实上这道题可以记忆化：

设当前坐标为(x,y)时(x,y>=0且起始下标为0)，则映射在这个地图上坐标为[(x%M+M)%M , (y%N+N)%N]，这是因为如果当x or y达到M or N时直接取模会出现0....（第一次写BFS爆了也是因为这个）。记x'=(x%M+M)%M y'=(y%N+N)%N,这时我们设置数组vis[x'][y'][1]记录这次访问点(x,y)时的坐标的x值，vis[x'][y'][1]记录这次访问(x,y)时的坐标y值，即vis[x'][y'][0]=x vis[x'][y'][1]=y。于是乎我们每次dfs时可以直接判断，如果vis[x'][y'][1]==x && vis[x'][y'][1]==y，说明我们退回去了;相反则我们走到了下一个“轮回”

AC代码如下：

[codec]





```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <cstdlib>
using namespace std;
int M,N;
bool f=false;
char g[1501][1501];
int vis[1501][1501][2];
const int D[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
bool dfs(int x,int y){
    int xx=(x%M+M)%M;
    int yy=(y%N+N)%N;
    if(g[xx][yy]=='#') return false;
    if(vis[xx][yy][0]!=0x3f3f3f){
        return vis[xx][yy][1]!=y || vis[xx][yy][0]!=x; //返回是否退回 or 走到下一轮回
    }
    vis[xx][yy][0]=x; //记录访问值
    vis[xx][yy][1]=y; //记录访问值
    for(int i=0;i<4;++i){ //四个方向DFS
        if(dfs(x+D[i][0],y+D[i][1])) return true;
    }
    return false; //哪个方向都没有就返回false
}
int main(){
    while(cin>>M>>N){
        int x1,y1;
        f=false;
        for(int i=0;i<M;i++){
            for(int j=0;j<N;j++){
                cin>>g[i][j];
                if(g[i][j]=='S'){
                    x1=i;
                    y1=j;
                }
                vis[i][j][0]=0x3f3f3f; //设置初始值
            }
        }
        if(dfs(x1,y1))
            cout<<"Yes\n";
        else cout<<"No\n";
    }
    return 0;
}
[/codec]
```

---

## 作者：Asurudo (赞：1)

~~因为太蒻所以花了一下午来研究此题~~

看了最高赞的题解，受到了极大的启发(Orz%%%
接下来切入正题

----------


本题核心之处在于，明晰对于从起点可到达的任意点$(i,j)(i,j∈∞surface)$若从其出发能到达

$(i-N,j-M),(i-N,j),(i-N,j+M),(i,j-M),(i,j+M),(i+N,j-M),(i+N,j),(i+N,j+M)$

八个点中的**任意一个**，则认定主角能走到距离起点无穷远处，也就是输出 $yes$。

为什么呢？因为既然主角可走到点$(i,j)$，且可通过$(i,j)$走到上述八点之一，则主角同样可以将上述八点作为新的$(i,j)$，从而到达以此为中心的下一个八点。

注意，程序应特别注意不能将从$(i,j)$走到$(i,j)$作为可以走通的理由，因为这其中产生了闭环，对于情况

```
# # #
S # .
. # .
# # #
```
很明显主角团只能在有限的四格中活动，而不满足题设条件无穷远处。

有其他很多想法，诸如拼成 3×3 的大方格再深广搜看能否触及边界的，还有看能不能回到起点的，都是错误的想法，在其他题解都有反例，这里就不一一列举了。


这里使用了BFS来解决，AC代码见下：


```cpp
#include <bits/stdc++.h>
#define _for(i,a,b) for(int i = (a);i < b;i ++)
typedef long long ll;
using namespace std;
struct point
{
	int x;
	int y;
	bool operator == (point b)
	{
		return this->x==b.x && this->y==b.y;
	}
};
typedef pair<point,point> pir;

inline ll read()
{
	ll ans = 0;
	char ch = getchar(), last = ' ';
	while(!isdigit(ch)) last = ch, ch = getchar();
	while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
	if(last == '-') ans = -ans;
	return ans;
}
inline void write(ll x)
{
	if(x < 0) x = -x, putchar('-');
	if(x >= 10) write(x / 10);
	putchar(x % 10 + '0');
}

int N,M;
//m数组用来存图 
char m[1504][1504];
//vis数组用来标记是否到达过(相对位置) 
bool vis[1504][1504];
//pre数组用来记录上一个到达此相对位置的绝对位置 
point pre[1504][1504];

point st;
int dx[] = {1,-1,0,0};
int dy[] = {0,0,1,-1};
bool bfs()
{
	//point 为 一个点，point.x行坐标，point.y列坐标
	//pir为将两个点捆绑成一个的pair 
	queue<pir> q;
	//初始入队 
	q.push({st,st});
	vis[st.x][st.y] = 1;
	pre[st.x][st.y] = st;
	while(!q.empty())
	{
		pir cur = q.front();q.pop();
		point a = cur.first;
		point b = cur.second;

		_for(i,0,4)
		{
			//ta为目前所走到的相对点坐标位置
			//tb为目前所走到的绝对点坐标位置 
			point ta;
			ta.x = (a.x+dx[i]+N)%N;
			ta.y = (a.y+dy[i]+M)%M;
			point tb;
			tb.x = b.x+dx[i];
			tb.y = b.y+dy[i];
			
			//如果之前已访问过该点且是八点之一(没绕回去)，说明可走到无穷远处 
			if(vis[ta.x][ta.y] && !(tb==pre[ta.x][ta.y]))
				return true;
			
			//如果访问过该点但又绕回来了，说明想回头(走闭环)或者撞墙了，直接继续循环 
			if(vis[ta.x][ta.y] || m[ta.x][ta.y]=='#')
				continue;
			
			//标记该点为已访问，并把绝对位置放入该点的pre 
			vis[ta.x][ta.y] = 1,pre[ta.x][ta.y] = tb;
			q.push({ta,tb});
		}
	}
	return false;
}
int main()
{
	while(scanf("%d%d",&N,&M)!=EOF)
	{
		memset(m,0,sizeof(m));
		memset(vis,0,sizeof(vis));
		memset(pre,0,sizeof(pre));
		//读入数据，用cin读，scanf读不好 
		_for(i,0,N)
		_for(j,0,M)
		{
			cin >> m[i][j];
			if(m[i][j]=='S')
				st.x = i,st.y = j,m[i][j] = '.';
		}
		
		if(bfs())
			printf("Yes\n");
		else
			printf("No\n");
	}
	return 0;
}
```




---

## 作者：H15teve (赞：1)

为了方便，定义（0，0）到（n-1，m-1）为元表，因为在搜索的过程中不可避免地会走出元表，因此visited存储的是对应元表位置的最后访问位置。与另一题解不同的是，本题解中使用了set来存储已访问的路线。显然，在插入set后，除了新一组数据到来，不必清空set或删除其中某一数据，因为我们只需要知道某个坐标是不是可以被到达。

/\*
P1363 Code

Author:H15teve

Date:19/10/2016

\*/





```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <set>
using namespace std;
struct loc 
{
    int x,y;
    bool operator < (const loc &n) const
    {
        if(x<n.x) return 1;
        if(x==n.x)
            if(y<n.y) return 1;
        return 0;
    }
};//定义一个loc类型用来扔进set判断这个点是否访问过，防止回头、重复 
int m,n,visited[1500][1500][2],dir[4][2]={0,1,1,0,0,-1,-1,0};
bool map[1500][1500];
set <loc> route;
bool dfs(int x,int y)
{
    if((visited[(x%n+n)%n][(y%m+m)%m][0]!=x||visited[(x%n+n)%n][(y%m+m)%m][1]!=y)&&visited[(x%n+n)%n][(y%m+m)%m][0]!=0x3f3f3f3f&&visited[(x%n+n)%n][(y%m+m)%m][1]!=0x3f3f3f3f)
      return 1;//注意如果最后访问坐标为(x,y)的话可能出现环的情况，所以不能判定 
    loc tmp;
    tmp.x=x;tmp.y=y;
    route.insert(tmp);
    visited[(x%n+n)%n][(y%m+m)%m][0]=x;
    visited[(x%n+n)%n][(y%m+m)%m][1]=y;//visited记录元表中某一坐标的最后访问坐标，也就是说(x,y)，在经过dfs后在例如(x+n,y+m)的地方再次被访问 
    for (int i=0;i<=3;i++)
    {
        tmp.x=x+dir[i][0];
        tmp.y=y+dir[i][1];
        if(map[(tmp.x%n+n)%n][(tmp.y%m+m)%m]&&!route.count(tmp)&&dfs(x+dir[i][0],y+dir[i][1])) 
          return 1;
    }
    return 0;
}
int main()
{
    while(scanf("%d%d",&n,&m)==2)
    {
        int startx,starty;
        memset(visited,0x3f,sizeof(visited));
        route.clear();
        bool flag=0;
        for(int i=0;i<n;i++)
          for (int j=0;j<m;j++)
          {
              char c;
              scanf("\n%c",&c);
              if(c=='#') map[i][j]=0;
              else map[i][j]=1;
              if(c=='S') startx=i,starty=j;
              if(j==m-1&&map[i][j]&&map[i][0]) flag=1;
              if(i==n-1&&map[i][j]&&map[0][j]) flag=1;//轻度剪枝，如果根本接不起来那就直接输出No 
          }
        if(flag&&dfs(startx,starty)) printf("Yes\n");else printf("No\n");
    }
    return 0;
}
```

---

## 作者：魁拔 (赞：1)

简单的bfs或者dfs即可。

在搜索时考虑当前所处的r\*c的区域相对于初始点所处的r\*c的区域的偏移量。

e.g
r=5 c=4       x点相对于S点所在的区域的偏移时（-1,0）

# #  。 #     这样我们每次搜索时如果向左超出边界，下一个点的偏移为（row,col-1），向右则是（row,col+1）

# #  S  #      横坐标同理。

# 。 。#     如果在搜到相同点的时候，发现原先点的偏移量和现在点的偏移量不同，则出现循环。输出Yes

# 。 #  #

# 。 。#

# #  。 #    p.s：按理说dfs对于本题效率应该更高，但是dfs会出现崩栈，所以bfs还是更保险一点。

# #  。 #             当然也可以想偶一样吧dfs改成非递归。之后发现竟然可以0ms AC

# 。 。#

# 。 #  #

# 。 X #

另外：Tune神犇用的是递归的dfs，却没有崩掉，据说时看这儿的题解：

http://endlesscount.blog.163.com/blog/static/821197872012515111314821/

无限YM

本题题目来源：Codeforces Infinite Maze


---

## 作者：Hoshimiya (赞：0)

**这道题可以这样想：**

------------

想要从当前S走到无限远处的途中一定能走到另一个S处（不一定经过），因此只要找到这个S，便可以输出YES

------------
代码如下

------------
```cpp
#include<iostream>
#include<cstring>
using namespace std;

int zz[4][2]={0,1,1,0,0,-1,-1,0};//走法
int queue[1000000][2];
int m,n;
struct node
{
	int x,y;//相对于初始S的相对位置
	char z;//地图信息
 } map[1500][1500];

int  bfs(int a,int b)
{
    int head=0,tail=1;
    queue[1][0]=a;
    queue[1][1]=b;
    do
    {
    	head++;
    	for(int i=0;i<=3;i++)
    	  {
    	  	 int x=queue[head][0]+zz[i][0]，
                     y=queue[head][1]+zz[i][1];
   
		 x%=m;y%=n;
	         if(x<0)x+=m;
	         if(y<0)y+=n;
	         if(map[x][y].z!='#')
	           { 			      	
                    if(map[x][y].x==100000)
		      {
			map[x][y].x=queue[head][0]+zz[i][0];
			map[x][y].y=queue[head][1]+zz[i][1];
			tail++;
			queue[tail][0]=map[x][y].x;
			queue[tail][1]=map[x][y].y;
					 }
		  else if(map[x][y].x!=queue[head][0]+zz[i][0]||map[x][y].y!=queue[head][1]+zz[i][1])
		      {
			cout<<"Yes"<<endl;
			return 0;
		       }
	  }
			   
        }
   }while(head<tail);
  cout<<"No"<<endl;
  return 0;
}

void chuli(int m,int n)
{
    int a,b;
    for(int i=0;i<m;i++)
       for(int j=0;j<n;j++)
           cin>>map[i][j].z,map[i][j].x=100000,map[i][j].y=100000;
    for(int i=0;i<m;i++)
       for(int j=0;j<n;j++)
          if(map[i][j].z=='S')
            {
            	a=i;
            	b=j;
            	break;
            }//找初始S
    map[a][b].x=a;
    map[a][b].y=b;
    bfs(a,b);
}

int main()
{
    while(cin>>m>>n)chuli(m,n);
    return 0;
}

```


---


# 修改

## 题目描述

给定一个长度为 $n$ 的整数序列 $a_i$，再给定一个长度为 $n$ 的整数序列 $b_i$。

你可以进行一些修改，每次你可以将一个 $a_i$ 增加 $1$，花费为 $b_i$，你需要使所有的 $a_i$ 不相等，且同时满足花费最少。

但 zbw 认为太过简单，于是他规定，你可以在修改前进行**无限**次如下操作：交换 $b_i,b_j(1 \leq i,j \leq n)$。

求最小的花费。

**由于答案可能很大，请输出答案对  $2^{64}$ 取模后的值。**




## 说明/提示

样例 $1$：不改变 $b$，让 $a_1$ 增加 $2$，$a_2$ 增加 $1$，总花费为 $4$。

样例 $2$：交换 $b_1,b_3$，让 $a_1$ 增加 $2$，总花费为 $2$。

样例 $3$：不做任何改变。

**本题输入量较大，请使用读入优化。**



| 测试点 |$n$  |$a_i$  |特殊性质|
| :----------: | :----------: | :----------: |  :----------: |
| $1,2$ |$\leq10$  |$\leq10^9$  |无 |
| $3\sim6$ |$\leq10^3$  |$\leq10^9$  |无| 
| $7\sim10$ |$\leq10^6$  |$\leq10^6$  | 无|
| $11\sim14$ |$\leq10^6$  |$\leq10^9$  |所有 $b_i$ 相等 |
| $15\sim20$ |$\leq10^6$  |$\leq10^9$  |无|

对于所有数据 $1 \leq n \leq 10^6$，$1\leq a_i,b_i\leq10^9$。

## 样例 #1

### 输入

```
3
3 3 3
1 2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
3
3 3 4
3 2 1```

### 输出

```
2```

## 样例 #3

### 输入

```
3
3 4 5
2 1 3```

### 输出

```
0```

# 题解

## 作者：gyh20 (赞：26)

一道很水的贪心题，由于太水了，就直接对正解进行讲解。

首先，如果没有 $b_i$ 的限制。我们可以用一个队列，枚举每个位置，如果这个位置上有点，则将这个位置的所有 $a_i$ 加入。然后，将一个 $a_i$ 放在这个位置。

举个例子。

假如有 $2,2,3$ 三个点：

枚举位置 $1$，没有点。

枚举位置 $2$，将两个 $2$ 加入队列，将一个 $2$ 弹出。

枚举位置 $3$，将 $3$ 加入队列，将另一个 $2$ 弹出。

枚举位置 $4$，将 $3$ 弹出。

每个点被修改的次数即为 出队时间 $-$ 入队时间。然后按修改的次数排序再乘上 $b_i$ 即可。

但有时有多种选择，比如在上述样例中，时间 $3$ 时，既可以弹出 $2$ 又可以弹出 $3$ ，但弹出 $2$ 肯定是更优的，因为 $2$ 的入队时间比 $3$ 靠前，乘上的 $b_i$ 一定比 $3$ 少，所以多修改一次 $2$ 的代价更小。

所以将上述的队列改为栈。

但时间复杂度还是 $O(n\log n+\max a_i)$ 的。

但可以发现，其实很多时候栈都是空的，优化就是在栈为空的时候跳到下一个 $a_i$。

可以证明栈有值的点至多有 $2n$ 个。

总复杂度 $O(n\log n)$ (排序)。

```cpp
#pragma GCC optimize(2,3,4,5)
#include<bits/stdc++.h>
#define re register
using namespace std;
struct node{
	int x,id;
};
struct d{
	int ans,pos;
}p[1000002];
int n,a[1000002],b[1000002],x,l;
unsigned long long ans;
inline int read(){
	int t=0;
	char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0'){
		t=(t<<3)+(t<<1)+v-48;
		v=getchar();
	}
	return t;
}
inline bool cmp(re d x,re d y){
	return x.ans>y.ans;
}
stack <node> q;
signed main(){
	n=read();
	for(re int i=1;i<=n;++i)a[i]=read();
	sort(a+1,a+n+1);
	for(re int i=1;i<=n;++i)b[i]=read();
	sort(b+1,b+n+1);
	l=1;
	x=1;
	while(1){
		if(q.empty()){
			if(l<=n)
			x=a[l];
			else break;
		}
		while(a[l]==x){
			q.push(node{a[l],l});
			++l;
		}
		node tmp=q.top();
		q.pop();
		p[tmp.id].ans=x-tmp.x;
		++x;
	}
	sort(p+1,p+n+1,cmp);
	for(re int i=1;i<=n;++i){ans+=1llu*p[i].ans*b[i];
	}
	printf("%llu",ans);
}
```


---

## 作者：kradcigam (赞：10)

# 前言
其实我感觉这道题比第 $2$ 道题还略微的简单了一些。

# 正文
## 分析
### 性质
这道题，我们显而易见地可以得出一个结论，**最小化花费的情况下，改变的数，一定要尽量少。**

所以我们要先把数组排一遍序。
### 方法

这道题，我用了一个类似并查集的方法。

```cpp
int find(int x){
	if(f[x]==0)return f[x]=x+1;
	return f[x]=find(f[x]);
}
```
这里的 $f$ 数组就是表示以 $x$ 数组往后的最近的**可能**空位
## 总代码
会了以上 $2$ 个东西，我们就可以做这道题了。
```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &FF){
	T RR=1;FF=0;char CH=getchar();
	for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
	for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
	FF*=RR;
}
template<typename T>void write(T x){
	if(x<0)putchar('-'),x*=-1;
	if(x>9)write(x/10);
	putchar(x%10+48);
}
const int MAXN=1e6;
int a[MAXN];
unsigned long long b[MAXN],ans,n;
unordered_map<int,int>f;
int find(int x){
	if(f[x]==0)return f[x]=x+1;
	return f[x]=find(f[x]);
}
vector<int>v;
bool cmp(int a,int b){
	return a>b;
}
int main(){
	read(n);
	for(int i=1;i<=n;i++)read(a[i]);//读入a数组
	sort(a+1,a+n+1,cmp);//排序
	for(int i=1;i<=n;i++){
		int x=find(a[i])-a[i]-1;//当然是要减1的
		if(x)v.push_back(x);//插入
	}
	for(int i=1;i<=n;i++)read(b[i]);
	sort(b+1,b+n+1);//排序b数组，显然
	sort(v.begin(),v.end());
	for(int i=v.size()-1,j=1;i>=0;i--,j++)ans+=v[i]*b[j];//算和
	write(ans);//输出
	return 0;
}
```
# 后记
这道题，我程序运行的时间想对还是比较慢的，但是这种是可以过的。

欢迎在评论区指出错误，也欢迎优化此算法。

感谢 @北辰yama 和 @天下我有 的提醒，本算法已经从原来的 $9.42s$ 变成了 $5.70s$，这个优化的效果还是很显著的。

---

## 作者：Leap_Frog (赞：8)

### Description.
见题目，感觉原题已经够简洁了。  
### Solution.
首先，很显然，我们只需要对那些 $a_i$ 相等的数进行操作。  
然后，我们会发现，只有那些 $a_i$ 相同的才需要被进行操作。  
如果我们尽量贪心，能少加就少加，那我们操作序列是唯一的。  
（这里对相同的定义：对值一样的数操作方式一样，和位置无关。  
那么，我们只需要处理出这些值，再从大到小一一匹配最小值就好了。  
完结撒花，~~话说还莫名其妙抢了个最优解，还比第二名快了1.5s，我真的没怎么卡常啊~~
### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	if(f) x=-x;
}
int n,cnt=0,a[1000005],b[1000005],r[1000005];stack<int>s;
int main()
{
	read(n),cnt=0;unsigned long long res=0;//直接自然溢出啥事没有
	for(int i=1;i<=n;i++) read(a[i]);
	for(int i=1;i<=n;i++) read(b[i]);
	sort(a+1,a+n+1),sort(b+1,b+n+1);//从小到大排序
	for(int i=1,x=a[1];x<=a[n]||!s.empty();)//x是当前处理的位置
	{
		while(a[i]==x) s.push(i++);
		if(!s.empty())
		{
			if(x!=a[s.top()]) r[++cnt]=x-a[s.top()];
			s.pop(),++x;
			//如果当前还有需要处理的东西，那么需要对这个数执行操作
			//操作次数是这个数原来的大小和现在需要让他变成的大小
		}
		else x=a[i];//否则，直接跳到下一个地方就好了
	}
	sort(r+1,r+cnt+1,greater<int>());
	for(int i=1;i<=cnt;i++) res=res+1ull*r[i]*b[i];
	return printf("%llu\n",res),0;
}
```

---

## 作者：VectorChange (赞：5)

[原题传送门](https://www.luogu.com.cn/problem/P6155)

首先声明，写这篇题解的笔者是吸了氧个才过的，~~最慢 989ms~~，这篇题解专为懒人提供。

## 正片开始
初看题目还比较水，正解也比较容易，但是笔者决定不走寻常路，写一个懒人专用码。

我用了一个递推函数来求 $f_i$， $f_i$ 为大于 $i$ 的第一个可用数。

一个 for 得到每个 $f_i$ 然后用 $f_i$ 减去 $a_i$,得到每个数要增加几，然后让最小的 $f_i$ 去乘以最大的 $b_i$（贪心的思想），然后求和，就可以求出最小花费了。

但笔者用优先队列存可用的 $f_i$ 时，复杂度可能稍稍有点高，所以也就 T 了 $14$ 个点，吸氧~~极限~~轻松 AC。 

上代码（仅供参考，内含说明）：

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6;
int a[MAXN];
unsigned long long b[MAXN],ans,n;
map<int ,int> f;//用数组下标太大，提交只会RE+MLE
int find(int x){
  if(f[x]==0)return f[x]=x+1;
  return f[x]=find(f[x]);
}//递推函数
priority_queue<int> v;//优先队列存f[i]
bool cmp(int a,int b){
  return a>b;
}
int main(){
  cin>>n;
  for(int i=1;i<=n;i++)cin>>a[i];
  sort(a+1,a+n+1,cmp);//a数组排序
  for(int i=1;i<=n;i++){
    int x=find(a[i])-a[i]-1;//记得减去a[i]再存，因为是a[i]每加1总值才加b[i]
    if(x)v.push(x);//不为0就存入
  }
  for(int i=1;i<=n;i++)cin>>b[i];
  sort(b+1,b+n+1);//b数组排序
  for(int i=v.size()-1,j=1;i>=0;i--,j++)ans+=v.top()*b[j],v.pop();
  //求值。
  cout<<ans;
  return 0;
}
//记得开O2（doge）
```
当然，笔者此处采用的是优先队列存储，读者可以采用数组存储，然后对数组进行排序，也是可以的。

---

## 作者：Daniel_yao (赞：4)

## Problem
给定一个长度为 $n$ 的数列 $a_i$ 和数列 $b_i$，在满足花费最少的情况下，每次将 $a_i$ 加 $1$，花费为 $b_i$，需要使 $a_i$ 两两不同。在操作前，你可以随意的交换 $b_i$ 的顺序。最小化花费。
## Solve
首先，有一个很显然的结论，就是对于一个数列 $a_i$，我更希望修改的位置相对集中。比如样例 $2$ 给出的 $a_i=\{3,3,4\}$，最优的操作应该是将第一个 $3$ 直接改成 $5$，而不是将 $\{3,4\}$ 的数值往后平移，然后将 $b_1$ 和 $b_3$ 交换。感性理解一下：如果更改的位置相对集中，则能用更小的代价 $b_i$ 贡献花费。

按照这个去做，直觉上非常的完美，实际上会被这个样例给 hack 掉：
```
10
1 1 4 5 1 4 1 9 1 9
9 8 1 1 4 5 6 2 3 5
```
你会发现，有 $5$ 个 $1$，$2$ 个 $4$。这时 $1$ 和 $4$ 之间有 $2,3$ 没有填，$5$ 和 $9$ 之间有 $6,7,8$ 没有填。首先肯定是拿两个 $1$ 去填 $2,3$。但是，问题来了，是拿另外三个 $1$ 去填 $6,7,8$，还是用一个 $1$ 和两个 $4$ 去填 $6,7,8$。**显然是后者**，因为 $4$ 的数值距离 $6,7,8$ 更近，而 $1$ 到 $6,7,8$ 甚至是更远的距离，产生的贡献是无法避免的，也就是说我们无法做到在填 $1$ 的时候，总贡献方案最优。因此，我们希望 $4$ 产生的贡献尽可能少。也就是说，**对于一个尚未填的空位来说，我们希望一个距离空位更近的数去填补它，并且产生的贡献要尽可能小。**

可以用一个栈去实现，因为每次都要用距离空位更近的数去填补，所以每次将数压入栈内，当遇到空位是，栈顶元素，也就是最后压入的点，就是我要将其填补的数。

时间复杂度 $O(n)$，非常的优秀。

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
#define H 19260817
#define rint register int
#define For(i,l,r) for(rint i=l;i<=r;++i)
#define FOR(i,r,l) for(rint i=r;i>=l;--i)
#define MOD 1000003

using namespace std;

inline int read() {
  rint x=0,f=1;char ch=getchar();
  while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
  return x*f;
}

void print(__int128 x){
  if(x<0){putchar('-');x=-x;}
  if(x>9){print(x/10);putchar(x%10+'0');}
  else putchar(x+'0');
  return;
}

const int N = 2e6 + 10;

int n, a[N], b[N], res[N], k, tot, stk[N], top;

long long cnt = 0;

int ans;

signed main() {
  n = read();
  For(i,1,n) a[i] = read();
  For(i,1,n) b[i] = read();
  sort(b + 1, b + n + 1);
  sort(a + 1, a + n + 1);
  a[n+1] = 1e18;
  For(i,2,n+1) {
    if(a[i] == a[i-1]) stk[++top] = i;
    else {
      int l = a[i-1];
      while(top && l < a[i] - 1) {
        l++;
        res[++tot] = (l - a[stk[top]]);
        top--;
      }
    }
  }
  sort(res + 1, res + tot + 1, [](int a, int b){return a > b;});
  For(i,1,tot) k++, ans += 1ull * res[i] * b[k];
  print(ans);
  puts("");
  return 0;
}
```

---

## 作者：李34 (赞：4)

[P6155 修改](https://www.luogu.com.cn/problem/P6155)

~~随便交了一发竟然跑到了最优解！~~

不过这道题还是挺有思维含量的。

题意比较易懂，不再赘述。

首先可以发现一个性质：可以任意交换 $b$ 意味着可以任意交换 $a$ 。

既然如此，我们不妨将 $a,b$ 都排好序（从小到大）。现在我们来看 $a$ 数组中的元素。

如果 $a_i$ 是唯一的，那么一定不会操作它，也一定不会有数移到和他相同的值。

假如有 $a_j$ 移动到 $a_i$ ，代价是 $(a_i-a_j)\cdot b_x$ ，那么 $a_i$ 就要移动到 $x$ ，代价是 $(x-a_i)\cdot b_y$ 。但如果我们直接将 $a_j$ 移动到 $x$ ，距离相同，却可以少浪费一个 $b$ 。所以 $a_i$ 不移动更划算。

那么我们可以将所有出现过的元素都删除一个，剩下的都是必须挪动的元素。

然后我们可以发现最优方案中总移动距离一定是最少的。因为如果总移动距离不是最少的，那这种方案一定是某一种使总移动距离最少的方案在移动若干步得到的。

由于 $b$ 数组对最终答案的影响，我们应当让总移动距离最小的情况下让移动距离大的数移动距离更大一些，这样可以减少花费。

我给出的处理办法是：对 $a$ **从大到小**循环，同时用一个栈维护能到达的数，每次都贪心地到达最近的点。这样可以减少跑得近的点的距离，增加跑得远的点的距离。

表述能力太差了捏，其实代码是很短的：

[简洁易懂的代码](https://www.luogu.com.cn/paste/6rbl74mj)

实现是非常容易的，主要还是考思维。

---

## 作者：konnyaku_cstdio (赞：4)

# 这是一篇题解，也是一篇卡常教学

## 思路

两个字：贪心。思路为走得越远的安排的权值尽量小

![](https://cdn.luogu.com.cn/upload/image_hosting/6cqoy1vd.png)

比如这里，粉色的呆着不动就把最大的权值给他，然后绿色到红色依次减小

## 实现：

1. 把a[i]排序，方便从小到大扫

2. 用栈进行操作，如果一个位置k上面有数$a[i]=k$，那么就把所有=k的数字入栈。再把栈顶出栈，填到这个位置上，记录下 $dis=poptime-pushtime$

3. 对dis进行小到大排序，把b进行大到小排序，一一对应算出答案是 $\sum {dis \times b[i]}$

好的但是分析复杂度为 $3\times nlogn$，最坏大约要进行6e7次操作，只能30pts ~~，但是开了O2可以AC~~

## 卡常！

首先先从代码本身来看，如果我们把所有的dis都记录下来，里面会有很大一部分是0，并不会对答案产生贡献反而会拖慢排序，可以考虑忽略他们。


```cpp
if(pla!=a[tmp])
	an[++cnt]=((pla-a[tmp]));
```

这样可以30->80+pts

----

然后我们发现，a[i]和a[i+1]之间有一些空当，假如栈为空，既目前已经填完，我们可以直接跳跃：

```cpp
if(!s.size()&&pla!=a[top])
	pla=a[top];
```

85-90 pts有了

---

还有一种比较硬核的方式是针对把

```cpp
#define ll long long
```

写成习惯的人的。注意，int在常数方面是要比long long快很多的

这样可以稳稳地满分

---
最后，如果大家真的不想give up long long，那就用快读罢！！！

fread是个好东西

或者可以用这个（能过学校龟速评测机的，实测！）：

```cpp
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)

char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
inline long long read() {
    long long x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
```

当然，快读可以说是最稳的

-------------------------------

最后附上AC代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring> 
#include <cstring>
#include <queue>
#include <algorithm>
#include <stack>
#include <cctype>
#define ll long long
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
using namespace std;
ll n,t;
ll t1,t2,cnt=0;
ll a[1000001],b[1000001];
stack <ll> s;
ll an[1000001];
ll top,pla,tmp;
unsigned long long ans=0;
bool cmp(unsigned long long a,unsigned long long b){
	return a>b;
}
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
inline long long read() {
    long long x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
int main(){	
//	scanf("%d",&n);
	n=read();
	a[0]=-1;
	for(int i=1;i<=n;i++){
	//	scanf("%d",&a[i]);
		a[i]=read();
	}
		
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
	//	scanf("%d",&b[i]);
		b[i]=read();
	}
		
	sort(b+1,b+1+n);
	top=1;
	pla=a[1];
	while(pla<=a[n]||s.size()){
		while(a[top]==pla){
			s.push(top);
			top++;
		}
		if(s.size()){
			tmp=s.top();
			s.pop();
			if(pla!=a[tmp])
				an[++cnt]=((pla-a[tmp]));
			pla+=1;
		}
		else
			pla=a[top]; 
		
	}
	sort(an+1,an+1+cnt,cmp);
	for(int i=1;i<=cnt;i++){
		ans+=(unsigned long long)an[i]*(unsigned long long)b[i];
	}
	printf("%llu",ans);
	return 0;
}
```


本篇题解到此为止，请各位大佬多多指教TOT


---

## 作者：MspAInt (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6155)

略有思维含量的题。

将所有数视为一条轴，$1$ 处在位置一，$2$ 处在位置二……

对于任何一个需要修改的数，我们应当与未来避免冲突，那么如何避免呢？直接**先把后来的数处理好**就行了（当然是从小到大处理），最后将当前的数补到没用的空位处就可以。

这里的“补空位”指利用**修改操作将该数大小改变，移动到数轴上未被使用的位置。**

那么我们开一个栈存入所有拿过的但未被操作的数，定义 $now$ 为“即将把栈顶的数修改至数轴上的 $now$ 位置”（如果两者相等，表示不移动）。如果出现冲突（即 $now$ 已被未来的数占领），将该数入栈，先将其移到未使用的空位，再回头处理。这类似于一个递归的过程。

显然修改次数等于补到的位置与原数的差，全部存在一个数组里。根据贪心思想，操作次数越多，就分配越少的代价。

这里 $2^{64}$ 爆 `long long`，于是使用了 `__int128`。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,a[N],b[N],pos=1,now=1,t[N];
__int128 ans,MOD=1;
stack<pair<int,int>>s;
void print(__int128 x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)print(x/10);
	putchar(x%10+'0');
	return;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]);
	sort(a+1,a+n+1);sort(b+1,b+n+1);//贪
	while(true){
		if(s.empty())//栈空时直接跳到下一个
			if(pos<=n)now=a[pos];
			else break;
		while(a[pos]==now)//pos指向当前的数
			s.push(make_pair(a[pos],pos)),pos++;//相同的数共同处理，一个一个地向后补
		pair<int,int>k=s.top();s.pop();
		t[k.second]=now-k.first;
		now++;//往后取空位
	}
	sort(t+1,t+n+1);MOD=pow(2,64);
	for(int i=1;i<=n;i++)
		ans=(ans+__int128(t[i])*__int128(b[n-i+1]))%MOD;
	print(ans);
    return 0;
}
```

[record](https://www.luogu.com.cn/record/104232854)

---

## 作者：bryce (赞：2)

## 思路分析
首先一个明显的性质是，修改的数的个数越少越好，因为一个数更改值使得与其他值不相等，与其他值更改值使得与这个数不相等的修改次数相等，但只修改那一个值花费的代价肯定最少，因为我们可以把最小的 $b_i$ 分配给它，而修改多个数，修改次数虽然相等，但需要用到多个 $b_i$，代价可能比只修改一个数的代价更高。

于是思路就出来了，找到每个数修改后的值，且使修改的数的个数最少，然后修改次数多的数分配小的 $b_i$。

以下代码中的函数用来找到每个数修改后的值，前提是 $a_i$ 要从大到小排序，因为要使修改的数的个数最少。

最后由于代码时间复杂度有点高，需要吸氧才能过。

## 代码
```cpp
#include<iostream>
#include<algorithm>
#include<map>
#define int long long

using namespace std;

inline int read(){register int x = 0, f = 1;register char c = getchar();while (c < '0' || c > '9'){if (c == '-') f = -1;c = getchar();}while (c >= '0' && c <= '9'){x = (x << 1) + (x << 3) + (c ^ 48);c = getchar();}return x * f;}
inline void write(int x){if (x < 0) putchar('-'), x = -x;if (x > 9) write(x / 10);putchar(x % 10 + '0');}

const int N = 1e6 + 10;
unsigned long long n, ans;
unsigned long long a[N], b[N], p[N], cnt;
bool cmp(const int &a, const int &b){
	return a > b;
}
map<int, int> f;
int solve(int x){
	if (!f[x]) return f[x] = x + 1;
	return f[x] = solve(f[x]);
}

signed main(){
	n = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int i = 1; i <= n; i++) b[i] = read();
	sort(a + 1, a + n + 1, cmp);
	sort(b + 1, b + n + 1, cmp);
	for (int i = 1; i <= n; i++) p[++cnt] = solve(a[i]) - a[i] - 1;
	sort(p + 1, p + cnt + 1);
	for (int i = 1; i <= cnt; i++){
		ans += p[i] * b[i];
	}
	cout << ans;
	return 0;
}
```

---


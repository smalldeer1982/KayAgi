# [CSP-J 2022] 逻辑表达式

## 题目描述

逻辑表达式是计算机科学中的重要概念和工具，包含逻辑值、逻辑运算、逻辑运算优先级等内容。

在一个逻辑表达式中，元素的值只有两种可能：$0$（表示假）和 $1$（表示真）。元素之间有多种可能的逻辑运算，本题中只需考虑如下两种：“与”（符号为 `&`）和“或”（符号为 `|`）。其运算规则如下：

$0 \mathbin{\&} 0 = 0 \mathbin{\&} 1 = 1 \mathbin{\&} 0 = 0$，$1 \mathbin{\&} 1 = 1$；  
$0 \mathbin{|} 0 = 0$，$0 \mathbin{|} 1 = 1 \mathbin{|} 0 = 1 \mathbin{|} 1 = 1$。

在一个逻辑表达式中还可能有括号。规定在运算时，括号内的部分先运算；两种运算并列时，`&` 运算优先于 `|` 运算；同种运算并列时，从左向右运算。

比如，表达式 `0|1&0` 的运算顺序等同于 `0|(1&0)`；表达式 `0&1&0|1` 的运算顺序等同于 `((0&1)&0)|1`。

此外，在 C++ 等语言的有些编译器中，对逻辑表达式的计算会采用一种“短路”的策略：在形如 `a&b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 0$，那么整个逻辑表达式的值就一定为 $0$，故无需再计算 `b` 部分的值；同理，在形如 `a|b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 1$，那么整个逻辑表达式的值就一定为 $1$，无需再计算 `b` 部分的值。

现在给你一个逻辑表达式，你需要计算出它的值，并且统计出在计算过程中，两种类型的“短路”各出现了多少次。需要注意的是，如果某处“短路”包含在更外层被“短路”的部分内则不被统计，如表达式 `1|(0&1)` 中，尽管 `0&1` 是一处“短路”，但由于外层的 `1|(0&1)` 本身就是一处“短路”，无需再计算 `0&1` 部分的值，因此不应当把这里的 `0&1` 计入一处“短路”。

## 说明/提示

**【样例解释 \#1】**

该逻辑表达式的计算过程如下，每一行的注释表示上一行计算的过程：

```plain
0&(1|0)|(1|1|1&0)
=(0&(1|0))|((1|1)|(1&0)) //用括号标明计算顺序
=0|((1|1)|(1&0))   //先计算最左侧的 &，是一次形如 a&b 的“短路”
=0|(1|(1&0))       //再计算中间的 |，是一次形如 a|b 的“短路”
=0|1               //再计算中间的 |，是一次形如 a|b 的“短路”
=1
```

**【样例 \#3】**

见附件中的 `expr/expr3.in` 与 `expr/expr3.ans`。

**【样例 \#4】**

见附件中的 `expr/expr4.in` 与 `expr/expr4.ans`。

**【数据范围】**

设 $\lvert s \rvert$ 为字符串 $s$ 的长度。

对于所有数据，$1 \le \lvert s \rvert \le {10}^6$。保证 $s$ 中仅含有字符 `0`、`1`、`&`、`|`、`(`、`)` 且是一个符合规范的逻辑表达式。保证输入字符串的开头、中间和结尾均无额外的空格。保证 $s$
中没有重复的括号嵌套（即没有形如 `((a))` 形式的子串，其中 `a` 是符合规范的逻辑表
达式）。

| 测试点编号 | $\lvert s \rvert \le$ | 特殊条件 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $3$ | 无 |
| $3 \sim 4$ | $5$ | 无 |
| $5$ | $2000$ | 1 |
| $6$ | $2000$ | 2 |
| $7$ | $2000$ | 3 |
| $8 \sim 10$ | $2000$ | 无 |
| $11 \sim 12$ | ${10}^6$ | 1 |
| $13 \sim 14$ | ${10}^6$ | 2 |
| $15 \sim 17$ | ${10}^6$ | 3 |
| $18 \sim 20$ | ${10}^6$ | 无 |

其中：  
特殊性质 1 为：保证 $s$ 中没有字符 `&`。  
特殊性质 2 为：保证 $s$ 中没有字符 `|`。  
特殊性质 3 为：保证 $s$ 中没有字符 `(` 和 `)`。

**【提示】**

以下给出一个“符合规范的逻辑表达式”的形式化定义：

- 字符串 `0` 和 `1` 是符合规范的；
- 如果字符串 `s` 是符合规范的，且 `s` 不是形如 `(t)` 的字符串（其中 `t` 是符合规范的），那么字符串 `(s)` 也是符合规范的；
- 如果字符串 `a` 和 `b` 均是符合规范的，那么字符串 `a&b`、`a|b` 均是符合规范的；
- 所有符合规范的逻辑表达式均可由以上方法生成。

## 样例 #1

### 输入

```
0&(1|0)|(1|1|1&0)
```

### 输出

```
1
1 2
```

## 样例 #2

### 输入

```
(0|1&0|1|1|(1|1))&(0&1&(1|0)|0|1|0)&0
```

### 输出

```
0
2 3
```

# 题解

## 作者：SkyWave (赞：496)

本题解亮点：不用建表达式树或者用栈

这道题没有那么难，大家都想复杂了

# 思路

分治/伪表达式树

vp 完的那个夜晚，大家讨论做法时都一致认定这道题在考表达式树，于是我就看了看他们发的代码。清一色的要么是建表达式树，最后跑一遍遍历，要么是用一个栈弹来弹去，还有厉害的则先将中缀表达式转成前/后缀表达式，然后再求值。

我还是太弱了，看着大佬们一百多行的代码陷入了沉思。

我的评价是：太抽象了！有没有一种方法既不用建表达式树，不用栈弹来弹去，也不用转成前/后缀表达式，实现直接在中缀表达式求值呢？

我们可以先来思考一下人类是怎么算中缀表达式的：

就先拿样例 1 举例：

```
0&(1|0)|(1|1|1&0)
```

人类会先看向第一层的 ```|``` 左边的 ```0&(1|0)```，再看向 ```&``` 左边的 0，此时形成了一个短路，所以这部分的值为 0。

此时式子为 ```0|(1|1|1&0)```。

此时 ```|``` 左边的值计算完毕，我们该看 第一层的 ```|``` 右边的 ```(1|1|1&0)```。

此时我们会先看到 ```1|1|1&0```，发现第二层的 ```|``` 左边为 1，构成短路，此部分的值为 1，后面的操作都不用算。

此时式子变为 ```0|(1|1&0)```

我们会看到 ```(1|1&0)```，发现又构成一次短路，此部分的值为 1。

此时式子会变成 ```0|1```，最后算出答案为 1。

为什么要分析的那么仔细？因为我们等会就要实现通过模拟人脑计算中缀表达式的过程计算中缀表达式。

我们先来分析一下我们做的过程。我们会先找到第一层优先级最高的，先算这个符号的左半边，判断存不存在短路，如果不存在，继续找找到第二层优先级最高的，算这个符号的左半边，判断存不存在短路……以此类推。当不存在比他优先级更高的时候，计算这一层的值并将当前算式替换成这部分的值继续求解。

对于刚才样例的人脑操作，流程图如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/5gqfx5zu.png)

我们会先找到第一层优先级最高的，也就是第一层的 ```|``` 左半边，然后我们进入左半边，找这个左半边里优先级最高的，自然是第二层的 ```&```。看他的左半边，是一个 0，造成了短路，所以这一部分的值就是 0。然后我们回到第一层，第一层的左半边我们算完了，值为 0，但因为第一层是 ```|```，所以不造成短路。我们继续找 ```｜``` 号的右半边优先级最高的，发现是第二层的 ```|``` ，于是我们再去左半边找优先级最高的运算符，此时我们会找到第三层的 ```|```，看他的左半边。发现没有运算符，只有一个数字，为 1！并且他右边的运算符为 ```|```，构成一个短路，于是这部分的值就是 1。第三层算完了，我们回到第二层，发现是一个 ```|```，并且我们刚才的计算结果为 1，于是又构成一次短路。此时回到第一层，我们只需要计算出 ```0|1``` 的结果就行，答案为 1。

我们来回顾一下刚才的过程。我们每次都会重复寻找当前层优先级最高的符号，并先到符号左边继续寻找当前层优先级最高的符号……直到当前层没有符号，即只有数字为止，此时我们当前层的结果就是这个数字，返回到上一层。此时我们通过刚才计算的结果和这一层的符号判断是否存在短路，如果没有短路就计算出符号右边的值后再计算在这一层的值，并回到上层。否则我们不用计算右边的值，直接回到上一层利用已算出的值继续计算……

把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并，这个算法叫什么？

对了！分治。

那我们该怎么分解问题呢？

我们每次会找到这一层不在括号里的最后一个运算级最低的运算符，然后递归到他的左半边和右半边分别求解，这一层的值就等于左半边的值和右半边的值做这个运算符的操作。（如果是 ```|``` 那么就是左半边的值 ```|``` 右半边的值，```&``` 同理。

那问题来了，我们不是优先级高的先算吗？为什么要“找到这一层不在括号里的最后一个运算级最低的运算符”呢？

好问题！恰恰因为先找，所以才后算。递归是用类似于栈的先进后出机制，我们每次把运算级最低的先进栈，最后回溯的时候反而运算级最低的在最底下了。此时我们回溯就会先从运算级最高的开始算并返回到上一层了。大家可以在纸上画个表达式，自己玩一玩。

那如果这一层没有“不在括号里的最后一个运算级最低的运算符”怎么办？那就要分两种情况了。一种情况是整个算式都被括号包起来了，此时我们把括号去掉就行了。还有一种是只有数字，此时我们只要返回这个数字就行了，也就是我们分治的边界条件。

那我为什么要叫它伪表达式树呢？

来看这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ee6pawgp.png)

通过中缀表达式树的建立也可以用上面的代码实现——找到最后一个在括号外的符号，让他作为根节点，符号的左边就是他的左子树，右边就是他的右子树。但有没有必要把它存下来再遍历呢？多此一举！因为我们在遍历的时候就相当于在通过计算机能理解的顺序访问这棵树了，可以边访问边计算。

思路部分完结撒花！

# 代码

边上代码边讲！

```cpp
//
//  main.cpp
//  P8815 [CSP-J2022] 逻辑表达式（暂无数据）
//
//  Created by SkyWave Sun on 2022/10/29.
//

#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
#define N (int)1e6 + 1
char str[N];
int sum1;
int sum2;
int dfs(int l,int r) {
    int x = 0,orpos = 0, andpos = 0;//记录括号层数、最后一个 | 出现的位置、最后一个 & 出现的位置
    for (int i = l; i<=r; ++i) {//遍历左右区间查找运算符
        if (str[i] == '(') {
            ++x;//增加一层括号
        }else {
            if (str[i] == ')') {
                --x;//减少一层括号
            }else {
                if (!x) {//不在括号中
                    if (str[i] == '|') {
                        orpos = i;
                    }else {
                        if (str[i] == '&') {
                            andpos = i;
                        }
                    }
                }
            }
        }
    }
    if (orpos) {//注意，因为 | 比 &优先级低，要先判断存不存在 |
        if (str[orpos] == '|') {
            int tmp1 = dfs(l, orpos - 1);//遍历左区间
            if (tmp1 == 1) {//如果是 1，触发了 | 短路
                ++sum1;
                return 1;//不需要计算右区间，直接返回 1
            }else {
                int tmp2 = dfs(orpos + 1, r);//计算右区间
                return (tmp1 | tmp2);
            }
        }
    }
    if (andpos) {
        if (str[andpos] == '&') {
            int tmp1 = dfs(l, andpos - 1);
            if (tmp1 == 0) {//如果是 0，触发了 & 短路
                ++sum2;
                return 0;//不需要计算右区间，直接返回 0
            }else {
                int tmp2 = dfs(andpos + 1, r);
                return (tmp1 & tmp2);
            }
        }
    }
    //不在括号内的运算符不存在
    if (str[l] == '(' && str[r] == ')') {//如果都被括号包裹着
        return dfs(l + 1, r - 1);//去掉括号
    }else {
        return str[l] - '0';//否则左右区间一定重合，返回数字就行了
    }
}
int main(int argc, const char * argv[]) {
    scanf("%s",str + 1);
    int len = strlen(str + 1);
    int sum = dfs(1, len);
    printf("%d\n%d %d\n",sum, sum2, sum1);//注意！一定要开个 sum 把dfs结果先记下来，否则直接输出会导致 UB
    return 0;
}
```
![](https://cdn.luogu.com.cn/upload/image_hosting/xrr7qepe.png)

为什么会这样呢？

原因很简单——刚才的程序时间复杂度为 $O(n^2)$。因为我们在每次分治求解的时候都遍历一遍字符串，时间效率太低。如果我们能预处理出来字符串，那时间复杂度将降低为 $O(n)$。

那我们怎么预处理呢？好办，我们对每个位置，处理出这个位置左侧和它同层的最后一个（离它最近的）运算符。这样一来，我们在递归时，想看这一层的最后一个运算符，也就只需访问与右边界同层的最后一个运算符就行了，省掉了每次都遍历一遍的过程。注意，别忘了判断一下这个运算符的位置是否在左边界的右边，否则就说明这一层没有运算符。

依然是结合代码讲解。

优化版：

```cpp
//
//  main.cpp
//  P8815 [CSP-J 2022] 逻辑表达式（民间数据）
//
//  Created by SkyWave Sun on 2022/11/3.
//

#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
#define N (int)1e6 + 1
char str[N];
int c1[N];
int c2[N];
int l1[N];
int l2[N];
int cnt1;
int cnt2;
int dfs(int l,int r) {//记得先看主函数的预处理
    if (c1[r] >= l) {//如果最后一个和 r 同层的 ｜ 在 l 和 r 的范围内
        int ans = dfs(l, c1[r] - 1);
        if (ans == 1) {
            ++cnt1;
            return 1;
        }
        return (ans | dfs(c1[r] + 1, r));
    }
    if (c2[r] >= l) {//如果最后一个和 r 同层的 & 在 l 和 r 的范围内
        int ans = dfs(l, c2[r] - 1);
        if (ans == 0) {
            ++cnt2;
            return 0;
        }
        return (ans & dfs(c2[r] + 1, r));
    }
    if (str[l] == '(' && str[r] == ')') {
        return dfs(l + 1, r - 1);
    }
    return str[l] - '0';
}
int main(int argc, const char * argv[]) {
    scanf("%s",str + 1);
    int len = strlen(str + 1);
    int x = 0;//括号层数
    //l1[x] 代表目前最后一个在 x 层括号的 ｜ 运算符
    //l2[x] 代表目前最后一个在 x 层括号的 & 运算符
    //c1[i] 代表目前和 i 同层的最后一个 | 运算符
    //c2[i] 代表目前和 i 同层的最后一个 & 运算符
    for (int i = 1; i<=len; ++i) {
        if (str[i] == '(') {
            ++x;
        }else if (str[i] == ')') {
            --x;
        }else if (str[i] == '|') {
            l1[x] = i;
        }else if (str[i] == '&') {
            l2[x] = i;
        }
        c1[i] = l1[x];//最后一个在 i 这个位置前且与 i 同层的 | 运算符
        c2[i] = l2[x];//最后一个在 i 这个位置前且与 i 同层的 & 运算符
    }
    int ans = dfs(1, len);
    printf("%d\n%d %d\n",ans,cnt2,cnt1);
    return 0;
}

```

![](https://cdn.luogu.com.cn/upload/image_hosting/l5mb56m8.png)

一片绿色，蔚为壮观！

完结撒花！

我是 SkyWave，这是我的第四篇题解，有不足之处请多多指出，有任何看不懂的地方欢迎留言或者私信！

---

## 作者：Fishing_Boat (赞：441)

~~CCF 又在 t3 放大模拟~~

这道题大部分人貌似都是表达式求值的，不过其实可以有更简单的做法，直接从左到有一遍扫过去即可。

首先，我们先想清楚在什么情况下一段表达式没有贡献。如果是 ```0&``` ，则在下一次出现 ```|``` 或和它前面 一个 ```(``` 匹配的 ```)``` 之后才会产生贡献，而前面一段则为 ```0```。如果是 ```1|```，则出现和它前面 一个 ```(``` 匹配的 ```)``` 之后才会产生贡献。

其次，我们要想清楚优先级怎么搞，但事实上，优先级并不会影响到结果，因为如果出现 ```1|```，则会一直调到后面的括号，所以它的优先级一定高于 ```&```，如果是 ```0|```，那它并不会对结果产生影响，``` & ``` 同理。如果不是很明白上面说的，我们可以模拟一下数据：
```
0&(1|0)|(1|1|1&0)
```
出现 ```0&```，则一直跳到 ```0&(1|0)|```，第一个 ```|``` 因为在括号内，所以可以忽略，此时变成 ```0|(1|1|1&0)```，因为 ```0|```不会产生贡献，所以表达式可以变为 ```(1|1|1&0)```，直接一口气跳到最后的括号，于是就做完了。

## AC code ##
```cpp
#include<bits/stdc++.h>
using namespace std;

bool st;
string str;
bool val;// 表达式的值 
int ans1,ans2,off; //off 判断是否要跳掉，1 为 0&，2 为 1|，0 不用跳 
bool ed;

int main(){
	ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
//	freopen("expr.in","r",stdin);
//	freopen("expr.out","w",stdout);
//	cerr<<(&st-&ed)/1024.0/1024.0;
	cin>>str;
	for(int i=0;i<str.size();i++){
		if(off){
			if(str[i]=='('){// 跳括号 
				int x=1;
				while(x){
					i++;
					if(str[i]=='(') x++;
					if(str[i]==')') x--;
				}
			}else if(off==1&&str[i]=='|'){
				off=0;
			}else if(str[i]==')'){
				off=0;
			}else if(off==1&&str[i]=='&'){
				ans1++;
			}else if(off==2&&str[i]=='|'){
				ans2++;
			}
		}else{
			if(str[i]=='1') val=1;
			if(str[i]=='0') val=0;
			if(str[i]=='&'&&val==0){
				off=1;
				ans1++;
			}
			if(str[i]=='|'&&val==1){
				off=2;
				ans2++;
			} 
		}
	}
	cout<<val<<endl<<ans1<<' '<<ans2<<endl;

	return 0;
}
```
这是赛时代码，代码算是挺短的，并且跑到了全谷最优解，随着官方数据的加入，大概不太可能被超了。

---

## 作者：Wi_Fi (赞：76)

还是一样，CCF 保留了出题传统——大模拟/最难题放T3。

## Step1-中缀转后缀
首先看题目中给出的是中缀表达式。中缀表达式人看着舒服，但计算机读取很是难受。所以，想要解决问题，必须先要将中缀表达式转为后缀表达式。

显而易见，这里需要借助栈来实现中缀表达式到后缀表达式的转换。

相信大家备战J1时也知道了，中缀转后缀有如下规则：  
1. 如果是数字，直接入后缀表达式。  
2. 如果是 ```(``` ，入运算符栈。  
3. 如果是 ```)``` ，运算符栈不断出栈到后缀表达式，直到碰到 ```(``` ，  ```(``` 要出栈。  
4. 如果是运算符，运算符栈不断出栈到后缀表达式，直到碰到一个优先级更低的运算符或者栈为空。然后当前运算符入栈。  
5. 结束时，运算符栈可能不空，要不断出栈到后缀表达式。


```cpp
void change()
{
	for(int i=0;i<s.size();i++)
	{
		if(s[i]=='0'||s[i]=='1')sf.push_back(s[i]); // 数字直接写下
		else if(s[i]=='(')ops.push(s[i]); // 是 (，直接入运算符栈
		else if(s[i]==')') // 是 )
		{
			while(!ops.empty()&&ops.top()!='(')
			{
				sf.push_back(ops.top()); // 一直输出，直到碰到左括号
				ops.pop();
			}
			ops.pop(); // 弹出额外的 '('
		}
		else if(s[i] == '&') // 是 &
		{
			while(!ops.empty()&&ops.top()=='&')
			{
				sf.push_back(ops.top());
				ops.pop();
			}
			ops.push('&');
		}
		else // 是 |
		{
			while(!ops.empty()&&ops.top() != '(')
			{
				sf.push_back(ops.top());
				ops.pop();
			}
			ops.push('|');
		}
	}
	while(!ops.empty())
	{
		sf.push_back(ops.top());
		ops.pop();
	}
}
```


## Step2-建表达式树

逐次读取后缀表达式的每一个符号。
如果符号是操作数，那么我们就建立一个单节点树并将一个指向它的指针推入栈中；  
如果符号不是操作数，则从栈中弹出两棵树 T1 和 T2（先弹出 T1），并形成一颗以操作符为根的树，其中 T1 为右儿子，T2 为左儿子；  
然后将新的树压入栈中，继续上述过程。

```cpp
void build()
{
	for(int i=0;i<sf.size();i++)
	{
		if(sf[i]=='0'||sf[i] == '1') 
		{
			tr[++num]={sf[i]-'0',-1,-1};
			sta.push(num);
		}
		else
		{
			int r=sta.top();sta.pop();
			int l=sta.top();sta.pop();
			int v=(sf[i]=='&'?2:3);
			tr[++num]={v,l,r};
			sta.push(num);
		}
	}
}
```
## Step3-遍历表达式树求结果

```DFS``` 遍历即可。  
表达式树中，叶子一定是数值 0 或 1，非叶子一定是 ```&``` 或者  ```|``` 。

DFS 过程：  
遍历到叶子直接返回叶子的值；  
遍历到非叶子时，先递归遍历左子树返回对应的子树的值。  
然后基于左子树的返回值和当前结点的运算符判断是否会短路：  
```1|``` 会发生“或短路”，并且返回 1；  
```0&``` 会发生“与短路”，并且返回 0。  
非上面两种情况，计算右子树的值并返回其结果即可：  
```1&``` ，不管是 0 还是 1，结果都是那个数；  
```0|``` ，不管是 0 还是 1，结果都是那个数。  

```cpp
int dfs(int u)
{
	if(tr[u].v==0||tr[u].v==1)return tr[u].v; // 是叶子（数字）结点
	int l=dfs(tr[u].l);
	if(l==0&&tr[u].v == 2) // 0&
	{
		ans1++;
		return 0;
	}
	if(l==1&&tr[u].v == 3) // 1|
	{
		ans2++;
		return 1;
	}
	int r=dfs(tr[u].r); 
	return r; // 只要不短路，结果肯定就取决于右值  1&  0|
}
```


**完整代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6+5;
string s;
struct Node
{
    int v,l,r;
} tr[N];
int num, ans1, ans2;
stack<char> ops;
stack<int> sta;
vector<char> sf; // suffix 后缀表达式
void change()
{
	for(int i=0;i<s.size();i++)
	{
		if(s[i]=='0'||s[i]=='1')sf.push_back(s[i]); // 数字直接写下
		else if(s[i]=='(')ops.push(s[i]); // 是 (，直接入运算符栈
		else if(s[i]==')') // 是 )
		{
			while(!ops.empty()&&ops.top()!='(')
			{
				sf.push_back(ops.top()); // 一直输出，直到碰到左括号
				ops.pop();
			}
			ops.pop(); // 弹出额外的 '('
		}
		else if(s[i] == '&') // 是 &
		{
			while(!ops.empty()&&ops.top()=='&')
			{
				sf.push_back(ops.top());
				ops.pop();
			}
			ops.push('&');
		}
		else // 是 |
		{
			while(!ops.empty()&&ops.top() != '(')
			{
				sf.push_back(ops.top());
				ops.pop();
			}
			ops.push('|');
		}
	}
	while(!ops.empty())
	{
		sf.push_back(ops.top());
		ops.pop();
	}
}
void build()
{
	for(int i=0;i<sf.size();i++)
	{
		if(sf[i]=='0'||sf[i] == '1') 
		{
			tr[++num]={sf[i]-'0',-1,-1};
			sta.push(num);
		}
		else
		{
			int r=sta.top();sta.pop();
			int l=sta.top();sta.pop();
			int v=(sf[i]=='&'?2:3);
			tr[++num]={v,l,r};
			sta.push(num);
		}
	}
}
int dfs(int u)
{
	if(tr[u].v==0||tr[u].v==1)return tr[u].v; // 是叶子（数字）结点
	int l=dfs(tr[u].l);
	if(l==0&&tr[u].v == 2) // 0&
	{
		ans1++;
		return 0;
	}
	if(l==1&&tr[u].v == 3) // 1|
	{
		ans2++;
		return 1;
	}
	int r=dfs(tr[u].r); 
	return r; // 只要不短路，结果肯定就取决于右值  1&  0|
}
int main()
{
	//freopen("expr.in", "r", stdin);
	//freopen("expr.out", "w", stdout);
	cin>>s;
	change(); // 在构建表达式树前，需要把中缀表达式转后缀
	build(); // 利用后缀表达式构建表达式树
	cout<<dfs(num)<<'\n'; // 后缀表达式下，根在末尾，从根 dfs
	cout<<ans1<<' '<<ans2;
	return 0;
}
```

Update 2023.9.25 修改了一个搁置了近一年的错误。  
Update 2023.9.29 又修改了一处。

---

## 作者：liujy_ (赞：24)

 考试中打了将近100行然后就没调完，赛后有了一种更简洁的办法。  
 $1.$ 有括号怎么办？我们可以碰到左括号就往下递归，碰到右括号就返回当前的值。于是我们解决掉了括号。   
 $2.$ 解决掉括号之后怎么办？听说有大佬直接建表达式树中缀转后缀，但是本人太菜了。有一个性质，一个数与一个 $1$ 对它的值是没有影响的，同样，或上一个 $0$ 也是没有影响的。我们可以在表达式一开始与一个 $1$，在最后或一个 $0$。这样对于表达式的最终值是没有影响的。然后我们定义两个变量，$res$ 表示最近的一段连续的与运算的值，$ans$ 表示表达式最后的答案。  
 我们每次碰到一个与号，说明它前面这个数是参与与运算的，$res$ 就与上这个数。假设这个与号前面也是个与号，那么它前面的与运算的答案已经存在 $res$ 里面了，如果它前面不是与号，我们设 $res$ 初值为 $1$，不影响最后的答案。  
 如果碰到或的话，假设他前面有一个与号，让它前面的这个数字先与上 $res$，然后 $ans$ 在或上 $res$。因为此时当前或号前面的运算都已经完成了，所以可以之间或。如果它前面其实并没有与号，但是我们先将 $res$ 与上了它前面那个数，所有不影响。注意已经碰到或了，说明连续的一段与号已经被打断了，需要给 $res$ 重新赋初值。  
 因为我们碰到一个符号是处理它前面的数，所有是保证了如果一个数前面是或后面是与，它会优先参与后面的运算。  
 $3.$ 短路如何处理？我们可以定义结构体，重载运算符，结构体存储三个信息，一个是它的值，一个是得到这个值的过程中与运算产生的短路，最后是或运算产生的短路。计算直接依照题意写在重载运算符中即可。  
 代码应该比较好理解，很方便。  
 ```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char ch;
int n;
struct node{
	bool p;int yu,huo;
};
node operator & (node a,node b){
	if(a.p==0)return (node){0,a.yu+1,a.huo};
	else return (node){a.p&b.p,a.yu+b.yu,a.huo+b.huo};
}
node operator | (node a,node b){
	if(a.p==1)return (node){1,a.yu,a.huo+1};
	else return (node){a.p|b.p,a.yu+b.yu,a.huo+b.huo};
}
node f(){
	node t=(node){0,0,0},res=(node){1,0,0},ans=(node){0,0,0};
	while(cin>>ch){
		if(ch=='0'||ch=='1')t=(node){ch-'0',0,0};
		else if(ch=='&')res=res&t;
		else if(ch=='|'){
			res=res&t;
			ans=ans|res;
			res=(node){1,0,0};
		}else if(ch=='(')t=f();
		else {
			res=res&t;
			ans=ans|res;
			return ans;
		}
	}
	res=res&t;
	ans=ans|res;
	return ans;
}
int main(){
	node ans=f();
	cout<<ans.p<<endl;
	cout<<ans.yu<<" "<<ans.huo;
	return 0;
}
```


---

## 作者：MspAInt (赞：17)

[题目传送门](https://www.luogu.com.cn/problem/P8815)

本题是非常经典的中缀表达式求解，让我们来逐步分析该题。

我们不妨设 $S$ 为该表达式；$mi_{l,r,k}$ 为 $S_{l,r}$（指表达式 $l$ to $r$ 的位置区间）中优先级**第 $k$ 低**的运算符所处的**下标**；$ma_{l,r,k}$ 为 $S_{l,r}$ 中优先级**第 $k$ 高**的运算符所处的**下标**；$cnt_{l,r}$ 为 $S_{l,r}$ 中运算符的数量。

对于第 $1$ 问，想要直接求出表达式的值，我们不妨使用人脑模拟。想象一下，你现在有一个算式，运算符带有各异的优先级，那么你会如何去计算它呢？显然，正常人都会先找到 $ma_{l,r,1}$对应的运算符，计算完毕后，再次找到  $ma_{l,r,2}$ 对应的运算符……以此类推。

上述是一个**递归的过程**。然而在计算机中，我们要**反过来优先递归 $mi_{l,r,1}$**，因为这样才能使其放在最后被计算。

具体实现方面，我们大可每次在一定区间内扫一遍，得到 $mi_{l,r,1}$，接着将区间以 $mi_{l,r,1}$ 分为两部分递归（$[l,mi_{l,r,1}-1]$、$[mi_{l,r,1}+1,r]$），而这两个区间内的 $mi_{l,mi_{l,r,1}-1,1}$ 和 $mi_{mi_{l,r,1}+1,r,1}$ 对应的优先级一定高于 $mi_{l,r,1}$。当 $cnt_{l,r}=0$ 时，说明该区间内只有一个值，直接返回。但此时 $l$ 不一定等于 $r$（想一想，为什么？），所以也需要一个循环。这整个过程结束后，函数会一层层地计算，并往回跳，相当于逐步计算优先级高的运算符。

至于第 $2$ 问的找短路数量，我们在递归下去之前判断一下就 ok 了。

在此给出 [50pts 代码](https://www.luogu.com.cn/paste/b45x5j5z)。

[record](https://www.luogu.com.cn/record/98981480)

不出所料地 TLE 了，那么我们开始思考如何优化。

考虑到每次找 $mi_{l,r,1}$ 都需要扫一遍区间，才导致了 $\Theta(n^2)$ 的时间复杂度。那么有没有什么可以 $\Theta(1)$ 查询区间最值的数据结构呢？没错，就是 [st 表](https://oi-wiki.org/ds/sparse-table/)。

~~其实是我不会建后缀树qwq~~

这样复杂度就成功地从 $\Theta(n^2)$ 降到了 $\Theta(n\log n)$。

[100pts 代码](https://www.luogu.com.cn/paste/o4tfdymj)

[几乎是最劣解了吧](https://www.luogu.com.cn/record/98987624)

那么我们就愉快地水过了本题。

---

## 作者：六楼溜刘 (赞：16)

# P8815 逻辑表达式 题解
~~我膨胀了敢写题解了~~
**洛谷100AC祭**
## 题意
- 模拟一个包括与、或、是、否和括号的逻辑表达式
- 与的优先级高于或
- 括号内优先计算。

## 分析
第一眼看过去感觉像是模拟，实际上模拟确实可做，但是~~我调不出来~~调出来需要大量时间，这显然是不可承受的。

因为中缀表达式很难直接处理，我们考虑构造成一棵表达式树的形式（像这样）。

![样例1](https://cdn.luogu.com.cn/upload/image_hosting/8655liox.png)

但是如何化成这样呢，首先最简单的方法就是 $O(n^2)$ 的搜索，但是时间复杂度无法承受，我们需要一种 $O(n)$ 的算法来解决这个问题。

> 我们可以发现后缀表达式就是这棵树的后序遍历，那么我们就可以用类似构造后序遍历的方法构造这棵树。

> **核心思路就是利用栈后进先出的性质，维护一个关于运算符号优先级的单调栈**

我们可以建两个栈，栈A存储运算符，栈B存储已经处理过的子树的根节点，视作处理过的表达式的值。

假如读到数字，因为其必定是叶节点，直接存到节点数组里，把节点数组的下标压到栈B里。

如果是运算符就要考虑一下优先级问题，假如栈A为**空**当然可以**直接压入**，如果不为空就需要进行一些处理。若栈顶是**需要优先计算**的运算符就应将其取出存入节点数组中，并取出栈B顶部的两个节点作为此节点的两个儿子建两条边，把该节点的下标压进栈B，并将当前运算符压入。**注意，因为同级运算符从左到右计算，所以在这一种情况应该把它取出来**。但是假如栈顶的优先级较低，可以直接把当前运算符压入栈A，因为栈后进先出的性质这个运算符会优先被处理。此处需要注意一下，因为后文dfs会考虑左子树来计算短路，但节点会以原序列入栈，所以应**将后弹出的当做左子树**。

下面我们还剩最后一种（两种？）情况需要考虑：括号。对于右括号，因为括号内会优先计算，所以读到右括号就代表栈A顶部有若干个元素需要处理，并且在同一棵子树下。但是处理到何时为止？此时左括号就派上用场了，遇到左括号**直接**压入栈A，作为右括号的结束标志（**处理到括号时一定要记得把括号弹出来**）。

假如此时我们已经读完了字符串，但还需要注意一个问题，栈里面还可能有元素没被处理，比如样例1，此时只需要循环按照上文方式出栈至栈B**有且只有一个元素**（即**根节点**，或者视作整个表达式的值）。

此时还剩比较简单的一步，就是dfs算出整个表达式的值，此处可以分两种情况讨论。**如果左子树计算出来的值可以形成短路就不考虑右子树，直接返回值**，对应答案加一。如果不形成短路就分别计算两子树算出答案返回。

建树时间复杂度 $O(n)$ ，因为dfs时每个节点最多访问一遍所以时间复杂度也是 $O(n)$ ，可过。

## 样例1图像示意
~~有亿点糊~~请结合样例食用

![1](https://cdn.luogu.com.cn/upload/image_hosting/y4r1dz5r.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![2](https://cdn.luogu.com.cn/upload/image_hosting/n46dtyq9.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![3](https://cdn.luogu.com.cn/upload/image_hosting/ilj4kx0o.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![4](https://cdn.luogu.com.cn/upload/image_hosting/0i2b6ywk.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![5](https://cdn.luogu.com.cn/upload/image_hosting/zsqkndz7.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

这里为了后面写的方便把AB的位置换了一下

![6](https://cdn.luogu.com.cn/upload/image_hosting/4tgvwh01.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![7](https://cdn.luogu.com.cn/upload/image_hosting/inbzxjdf.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

![8](https://cdn.luogu.com.cn/upload/image_hosting/bm338tzi.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![9](https://cdn.luogu.com.cn/upload/image_hosting/yq2j0p2a.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![10](https://cdn.luogu.com.cn/upload/image_hosting/wntjmwvl.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![11](https://cdn.luogu.com.cn/upload/image_hosting/adtjb6qj.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![12](https://cdn.luogu.com.cn/upload/image_hosting/bzpuhbql.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![13](https://cdn.luogu.com.cn/upload/image_hosting/asytyji0.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![](https://cdn.luogu.com.cn/upload/image_hosting/zldflikp.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

![](https://cdn.luogu.com.cn/upload/image_hosting/qinomcqx.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

![](https://cdn.luogu.com.cn/upload/image_hosting/pn3nbqgf.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

![](https://cdn.luogu.com.cn/upload/image_hosting/3mytvo74.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

注意，在这里已经读入完成，但是栈A还未清空，所以处理剩余元素

![](https://cdn.luogu.com.cn/upload/image_hosting/s9kxlpgi.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

> 然后你会惊奇地发现这样构造出的树和手动构建的一模一样

## Code
~~我觉得我讲的很详细就不写注释了吧~~

```cpp
#include<bits/stdc++.h>
#define AND 10
#define OR 20
#define LFT 30 //左括号
using namespace std;
const int N=2e6+5;
int ans_for_or,ans_for_and,son[N][2],fa[N],pt[N],K;
//pt数组存储节点信息，K是末尾标记，因为我不熟悉vector所以用数组
stack<int> A,B;
char c=' ';
void work(){
	pt[++K]=A.top();A.pop();
	son[K][1]=B.top();B.pop();
	son[K][0]=B.top();B.pop();
	fa[son[K][1]]=fa[son[K][0]]=K;
	B.push(K);
//因为处理过的这一棵子树已经不会再有修改了
//所以可以直接视作单个值,即这棵子树所代表的表达式的值压入
}
bool dfs(int x){
	if(pt[x]==0||pt[x]==1){
		return pt[x];
	}
	int ls=dfs(son[x][0]);
	if(ls==0&&pt[x]==AND){ //短路
		ans_for_and++;return 0;
	}
	if(ls==1&&pt[x]==OR){
		ans_for_or++;return 1;
	}
	int rs=dfs(son[x][1]);
	if(pt[x]==AND){
		return ls&rs;
	}
	if(pt[x]==OR){
		return ls|rs;
	}
	return printf("This sentence will never be printed."),0;
}
signed main(){
	while(c!=EOF){
		c=getchar();
		if(c=='('){
			A.push(LFT);
		}else if(c=='1'){
			pt[++K]=1;B.push(K);
		}else if(c=='0'){
			pt[++K]=0;B.push(K);
		}else if(c=='|'){
			while(!A.empty()&&(A.top()==OR||A.top()==AND)){
				work();
			}
			A.push(OR);
		}else if(c=='&'){
			while(!A.empty()&&(A.top()==AND)){
				work();
			}
			A.push(AND);
		}else if(c==')'){
			while(!A.empty()&&A.top()!=LFT){
				work();
			}
			A.pop(); //一定记得弹出左括号！
		}
	}
	while(B.size()>1){ //处理剩余运算符
		work();
	}
	int ans=dfs(K);
	printf("%d\n%d %d",ans,ans_for_and,ans_for_or);
}
```

---

## 作者：E1_de5truct0r (赞：12)

## 思路

### 1.1 求值

我们考虑这样一个思路：

1. 把所有带括号的都递归求解，替换为其值（相当于把那个式子缩成一个值），记录一个字符串。

	例：把 `1|0|(0|1)&1` 替换成 `1|0|1&1`。

2. 那么剩下的一定是类似 `abababa` 的这种结构，其中 `a` 为 $0/1$，`b` 为运算符（`&` 或者 `|`）。

这个东西是容易处理的，因为我记得有这么一个表达式求值：

> 给定一个表达式（只包含 $+$、$\times$ 和数字），求它的值。

显然上述那个题可以先处理乘法，然后变成只有加法的，于是扫一遍即可。

类似的，我们把 `&` 看成乘法，`|` 看成加法，然后类似的求值即可。

### 1.2 求短路数量

为方便，下文令 $\oplus$ 表示按位或，$\otimes$ 表示按位与。

> 如果有一个式子 $a \otimes b$，且 $a=0$，则短路。

> 如果有一个式子 $a \oplus b$，且 $a=1$，则短路。

由此，我们可以推得如果 $a_1 \otimes a_2 \otimes \cdots \otimes a_n$ 这个式子中，某个位置 $a_i$ 是第一个 $0$ 出现的位置，则短路了 $n-i$ 次。

同理，我们可以得到如果 $a_1 \oplus a_2 \oplus \cdots \otimes a_n$ 中，某个位置 $a_i$ 是第一个 $1$ 出现的位置，则短路了 $n-i$ 次。

不难注意我们可以在求值的时候，顺便求出它的解。但是这个有一个问题，即我们如果直接做完了括号内的求解，但是发现括号内的被短路了，那么这个求解的值就是多余的，应该再减掉。

所以，我们直接对每一个式子求值之后，记录它的贡献，然后减去被短路的那些式子的贡献即可。具体可以用一个 `vector` 实现。

至此就做完了，复杂度稍加分析不难发现是 $O(n)$ 的。

代码也比较简洁。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int cnt1,cnt2;
bool calc(int &now){
    string t=""; // 这个存储用值替换掉带括号的式子之后的表达式串
    vector<pair<int,int> > Cnt;
    while(now<s.size()){ // 递归求解带括号的
        if(s[now]=='('){
            int re1=cnt1,re2=cnt2;
            t+=(char)(calc(++now)+'0');
            Cnt.push_back(make_pair(cnt1-re1,cnt2-re2));
        }
        else if(isdigit(s[now])){
            t+=s[now];
            Cnt.push_back(make_pair(0,0));
        }
        else if(s[now]=='|' || s[now]=='&'){
            t+=s[now];
            Cnt.push_back(make_pair(0,0));
        }
        else break;
        now++;
    }
    int r1=cnt1,r2=cnt2;
    string t1=""; // 这个是去掉所有 & 运算之后的表达式串
    vector<pair<int,int> > wz; // 这个存储的是每个位置的贡献
    for(int i=0;i<t.size();i++){ // 先处理 & 运算
        if(t[i+1]=='&'){
            bool flag=0,ans=(t[i]-'0');
            int j,s1=Cnt[i].first,s2=Cnt[i].second;
            for(j=i+2;j<t.size() && t[j-1]=='&';j+=2){
                if(!ans) cnt1++,s1++,flag=1;
                if(flag) cnt1-=Cnt[j].first,cnt2-=Cnt[j].second;
                else s1+=Cnt[j].first,s2+=Cnt[j].second;
                ans&=(t[j]-'0');
            }
            wz.push_back(make_pair(s1,s2));
            t1+=(char)(ans+'0');
            i=j-2;
        }
        else wz.push_back(Cnt[i]),t1+=t[i];
    }
    int ans=0,flag=0;
    for(int i=0;i<t1.size();i+=2){ // 处理 | 运算
        if(ans) cnt2++,flag=1;
        if(flag) cnt1-=wz[i].first,cnt2-=wz[i].second; // 减去短路的贡献
        ans|=(t1[i]-'0');
    }
    return ans;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>s;

    int st=0;
    cout<<calc(st)<<endl;
    cout<<cnt1<<" "<<cnt2<<endl;
    return 0;
}
```

---

## 作者：王江睿 (赞：12)

直到 11:53 才调出来，那个吓得我……

### 思路大抵如下：

根据两种运算，分别写出它们的 “skip”（「短路」）函数。注意，`^`（and，逻辑与）和 `|`（or，逻辑或）作为二元运算符，只有可能在 `a|b` 或 `a&b` 中跳过 `b` 的计算。

- ### skipa/b 函数

`void skipa()` 用于跳过 `a|b` 中，`a` 为真时不计算 `b` 的情况。原则是降层级（`t < stk`，即遇到括号）或遇到优先级更高（包括相同）的运算符（这里只有 `|`）时，就跳出循环。返回时 `pos` 指向 `b` 后（亦低层级〔括号后〕）的首个字符（或字符串末尾）。

`void skipb()` 同理。需要注意的是，优先级更高（包括相同）的运算符这里有`|` 和 `&`。

`p`、`q` 用来保存“短路”的次数。

- ### calc 函数

`bool x = false` 用于保存当前 `stk` 下 `|` 运算的结果；`bool y = true` 用于保存当前 `stk` 下部分 `&` 运算的结果。默认行使 `&` 运算，遇到 `|` 运算符时将 `x |= y, y = true`，同步 `y` 至 `x` 并将 `y` 重初始化。

原则是降层级即返回。返回值是当前层级下（括号中）全部运算的值。谨记将 `x` 和 `y` 在结束时同步。返回时 `stk` 指向低层级（括号后）的首个字符。

升层级时 `++stk` 并递归调用 `bool calc()` 函数。其返回值一如常量，作为单个数，参与当前层级的计算。

对于需要进行“短路”操作的，调整 `pos` 至 `b` 的第一个字符，调用 `skipa/b()` 函数。由于返回时 `for` 循环会进行 `++pos` 操作，为避免利用 `goto`，`--pos` 予以代替之。




```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int t, pos, p, q;
inline void skipa()
{
    int stk = t;
    for (++q; pos < s.size(); ++pos) {
        if (t < stk || (s[pos] == '|' && t == stk))
            break;
        if (s[pos] == '(') ++t;
        if (s[pos] == ')') --t;
    }
    return;
} // for |
inline void skipb()
{
    int stk = t;
    for (++p; pos < s.size(); ++pos) {
        if (t < stk || ((s[pos] == '|' || s[pos] == '&') 
            && t == stk)) break;
        if (s[pos] == '(') ++t;
        if (s[pos] == ')') --t;
    }
    return;
} // for &
inline bool calc(){
    bool x = false, y = true;
    int stk = t;
    for (;; ++pos) {
        if (t < stk || pos >= s.size())
            break;
        if (s[pos] == '(')
            ++t, ++pos, y &= calc(), --pos;
        else if (s[pos] == ')') --t;
        else if (s[pos] == '0' || s[pos] == '1')
            y &= s[pos] - '0';
        else if (s[pos] == '&' && !y)
            ++pos, skipb(), --pos;
        else if (s[pos] == '|') {
            x |= y, y = true;
            if (x) ++pos, skipa(), --pos;
        }
    }
    return x |= y;
}
int main()
{
    cin >> s;
    cout << calc() << '\n'
         << p << ' ' << q;
    return 0;
}
```

此题解。

---

## 作者：Imken (赞：12)

嗯……感觉很多人都在写中缀转后缀。

今天咱来看工程上编译器「语法分析」用得比较多的方法，「递归下降」。感觉会有所启发。

首先，表达式可以被表示为树形结构，在本题背景下是「二叉树」，这一点翻一下其他题解就可以看到了，这里不再赘述。

然后是「递归下降」对表达式进行语法分析。

最先说明一句，为了表达式的运算足够清晰，我们先考虑根据原表达式建立「表达式树」，或者 AST (Abstract Syntax Tree)，而不会在分析表达式时进行求值。

------

既然叫「递归下降」，那么肯定是逃不了递归的啦～

而且，是几个函数按照各自的顺序和优先级来递归。但也没有来回递归看起来的那样吓人啦，先别着急走开。

考虑以下几个函数：

```
parse_or()
parse_and()
parse_value()
```

优先级从低往高依次递归。这些函数的作用是：

- `parse_or()`：在表达式中寻找 `|` 符号，并把左值和右值交给 `parse_and()` 进行下一级处理。找不到就说明整个表达式处理完了。
- `parse_and()`：在表达式中寻找 `&` 符号，并把左值和右值交给 `parse_value()` 进行下一级处理。找不到就返回已经处理的表达式。
- `parse_value()`：如果交给这个函数处理的左值 / 右值就是 `0` / `1` 的话就返回值，否则，如果是括号表达式的话，则将括号表达式里的内容进一步交给 `parse_or()` 里继续处理。

你会发现，诶，不就是分治的思想吗？

实现起来还真和分治不一样，因为全程只维护了一个全局且不会回溯的字符串指针。这个递归的实现就非常妙了。

对于下面这个表达式：

`1&0|0&(1&1)&0`

我们对它 parse 一下：

- `parse_or()` 先处理左值。左值全部交给 `parse_and()` 处理。因为 `parse_and()` 在找到不是 `&` 的字符会返回，所以不用担心会处理多。
- `parse_and()` 把左值全部交给 `parse_value()` 处理。`parse_value()` 一定会处理好之前的表达式，所以无需担心。
- `parse_value()` 发现数值 `1` 并返回，并将字符串指针右移一位。
- `parse_and()` 发现 `&` 符号，字符串指针右移一位，让 `parse_value()` 处理右值。
- `parse_value()` 发现 `0` 并返回，并将字符串指针右移一位。
- `parse_and()` 发现当前字符不是 `&`，并返回给 `parse_or()` 处理。
- `parse_or()` 发现 `|`，字符串指针右移一位，然后让 `parse_and()` 处理右值。
- 省略一点，在 `parse_and()` 处理 `0&` 之后，将右值交给 `parse_value()` 处理。
- `parse_value()` 发现括号。指针右移一位，交给 `parse_or()` 处理。`parse_or()` 在遇到不是 `|` 的字符时会返回，因此不必担心 `parse_or()` 处理到 `)`。
  - `parse_or()` 处理左值递归到 `parse_and()`，`parse_and()` 处理了 `1&1` 之后发现了不是 `&` 的字符（`)`）并返回。
  - `parse_or()` 从 `parse_and()` 返回后发现了不是 `|` 的字符（`)`）并返回。
- 然后这一层的 `parse_value()` 将指针右移一位并返回上一层递归进去的 `parse_or()` 查找到的子表达式。
- 返回到 `parse_and()`，查找到另外一个 `&`，把左边的表达式打包成左值，指针右移一位，`parse_value()` 查找到 `0` 并返回。
- `parse_or()` 发现指针抵达字符串末尾并返回了最终的表达式。

然后就 parse 完了。

这么模拟下来似乎比转后缀要复杂一些，但是代码写起来感觉比后缀好理解。单个函数处理的逻辑很简单的其实。

代码拿指针写的，还算是通俗吧感觉。

```cpp
struct Expr {
	enum exptype { OR, AND, VALUE };
	exptype type;
	Expr *lvalue, *rvalue;
	int value;
};

class Parser {
public:
	Parser(const std::string& input): input(input), index(0) { }
	Expr* parse() { return parse_or(); }
private:
	Expr* parse_or()
	{
		Expr* left = parse_and();

		while (index < input.length() && input[index] == '|') {
			index++;
			auto right = parse_and(), new_expr = new Expr;
			new_expr->type = Expr::OR;
			new_expr->lvalue = left, new_expr->rvalue = right;
			left = new_expr;
		}

		return left;
	}

	Expr* parse_and()
	{
		Expr* left = parse_value();

		while (index < input.length() && input[index] == '&') {
			index++;
			auto right = parse_value(), new_expr = new Expr;
			new_expr->type = Expr::AND;
			new_expr->lvalue = left, new_expr->rvalue = right;
			left = new_expr;
		}

		return left;
	}

	Expr* parse_value()
	{
		if (index < input.length() && input[index] == '(') {
			index++;
			auto expr = parse_or();
			if (index < input.length() && input[index] == ')') {
				index++;
				return expr;
			} else {
				// 保证了表达式合法所以就不会执行到这里。
				// 所以当前指针这里「绝对」是 `)`
				throw std::runtime_error("Missing closing parenthesis.");
			}
		} else if (index < input.length() && (input[index] == '0' || input[index] == '1')) {
			Expr* expr = new Expr;
			expr->type = Expr::VALUE;
			expr->value = input[index] - '0';
			index++;
			return expr;
		} else {
			// 同上。
			throw std::runtime_error("Invalid character.");
		}
	}

	std::string input;
	// 全局维护的指针
	size_t index;
};
```

把 AST 建出来之后，就可以深搜解决问题啦～

```cpp
int or_circuit, and_circuit;

void dfs(Expr* expr)
{
	switch (expr->type) {
	case Expr::OR: {
		dfs(expr->lvalue);
		// 短路
		if (expr->lvalue->value == 1) {
			or_circuit++;
			expr->type = Expr::VALUE; expr->value = 1;
			break;
		}
		dfs(expr->rvalue);
		expr->value = expr->lvalue->value | expr->rvalue->value;
		expr->type = Expr::VALUE;
		break;
	}
	case Expr::AND: {
		dfs(expr->lvalue);
		// 短路
		if (expr->lvalue->value == 0) {
			and_circuit++;
			expr->type = Expr::VALUE; expr->value = 0;
			break;
		}
		dfs(expr->rvalue);
		expr->value = expr->lvalue->value & expr->rvalue->value;
		expr->type = Expr::VALUE;
		break;
	}
	case Expr::VALUE: { break; }
	}
}

int main()
{
	std::string input;
	std::cin >> input;
	Parser parser(input);
	Expr* result = parser.parse();

	dfs(result);
	std::cout << result->value << "\n"
			  << and_circuit << ' ' << or_circuit << '\n';

	return 0;
}
```

非常感谢你可以看到这里，如果之后有兴趣的话，可以再去用这个方法手动实现一下「加减乘除」一类的东西。实现这个基本逻辑不难。


---

## 作者：ChenZQ (赞：11)

这个思路是听我教练讲的，感觉很妙。

这道题你只需要会表达式求值这道经典题目，其实就可以很轻松地解出来。

首先以下是表达式求值代码：
```
#include <bits/stdc++.h>
using namespace std;

stack<int> stk;
stack<char> op;
char s[1000010];
map<char,int> mp;

void calc()
{
	int b=stk.top();stk.pop();
	int a=stk.top();stk.pop();
	int num=0;
	if(op.top()=='+') num=a+b;
	else if(op.top()=='-') num=a-b;
	else if(op.top()=='*') num=a*b;
	else
	{
		if(b==0) puts("error"),exit(0);
		else num=a/b;
	}
	stk.push(num);
	op.pop();
	return;
}
void solve()
{
	int t=strlen(s);
	for(int i=0;i<t;i++)
	{
		if(isdigit(s[i]))
		{
			int j=i;
			int num=0;
			while(j<t && isdigit(s[j]))
			{
				num=num*10+s[j]-'0';
				j++;
			}
			i=j-1;
			stk.push(num);
		}
		else 
		{
			if(s[i]=='-')
			{
				if(i==0 || s[i-1]=='(')
				{
					stk.push(0),op.push('-');
				}
			}
			if(s[i]=='(') op.push('(');
			if(s[i]==')')
			{
				while(!op.empty() && op.top()!='(') 
				{
					calc();
				}
				if(!op.empty()) op.pop();
			}
			if(s[i]!='(' && s[i]!=')')
			{
				while(!op.empty() && mp[op.top()]>=mp[s[i]]) 
				{
					calc();
				}
				op.push(s[i]);
			}
		}
	}
	while(!op.empty() && op.top()!='(') 
	{
		calc();
		}
	printf("%s=%d",s,stk.top());
}
int main()
{
	scanf("%s",s);
	mp['+']=1;
	mp['-']=1;
	mp['*']=2;//mp表示优先级的大小。
	mp['/']=2;
	solve();
}
```

首先我们考虑用以上代码算出此题中表达式的结果。

很简单，首先就是把 `map` 的优先级符号改了，然后把 `calc` 函数里面的内容改了，剩下的细节就不多说了。

然后下面就是重点了，**如何算出短路的个数**？

以下拿位运算符号或来举例。

首先，假设现在有一个符号或：

![](https://cdn.luogu.com.cn/upload/image_hosting/a2wr5lr7.png)

我们已经通过表达式求值算出了他左右两边的值，假设为 $a$ 和 $b$。再假设我们已经算出左右两边或的短路，与的短路，我们分别假设为 $x1$，$y1$，$x2$，$y2$。

那么如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/eklm8fs0.png)

如果 $a$ 为为 $1$，这里是不是就构成一个短路了？

那么其实，此表达式的短路数就是 $a$ 的短路或次数加一（与和或分开来算），与运算短路与 $a$ 的短路次数相同。因为题目要求，所以我们 $b$ 算出来的短路次数就直接作废。多加的一就是现在或的短路。

而如果 $a$ 为 $0$，那么不构成短路，$a$ 和 $b$ 的值都有效。所以这个表达式的短路数就是 $a$ 的短路数加 $b$ 的短路数。

而位运算与其实也可以像或一样分类讨论运算。

这便是思路的核心。

可能有人会问，怎么实现？

其实我们只需要套个表达式求值模板跑一遍就好了。

因为表达式求值的模板可以算出优先级高的部分，然后慢慢算出低的部分，每次运算时，都是拿栈顶的两个元素计算，我们只需要按照上述内容，用栈顶的两个元素进行短路合并就好了。

可能我语文水平不行，上面讲的很多内容大家会看不懂，但是你们看完代码一定会茅塞顿开的。

```
#include <bits/stdc++.h>
using namespace std;

stack<int> stk;
stack<pair<int,int>> duan;
stack<char> op;
char s[1000010];
map<char,int> mp;

void merge_duan(pair<int,int> aa,pair<int,int> bb,int a,int b,char op)
{
	pair<int,int> c;
	if(a==1 && op=='|')
	{
		c.first=aa.first+1;//跟上述内容相符。
		c.second=aa.second;
	
	}
	else if(a==0 && op=='&')
	{
		c=aa;
		c.second++;//如果a为0并且符号为与，那么构成了一个短路，为a的与的短路数加一，或的短路不变，b的短路数直接作废。
	}
	else
	{
		c.first=aa.first+bb.first;
		c.second=aa.second+bb.second;
	}
   duan.push(c);//把算好的短路次数放回去，准备下一次运算。
}
void calc()
{
	int b=stk.top();stk.pop();
	int a=stk.top();stk.pop();//表达式求值模板。
	int num=0;
	pair<int,int> bb=duan.top();duan.pop();
	pair<int,int> aa=duan.top();duan.pop();//跟表达式求值一样，每次从栈顶弹出两个元素进行运算。
	merge_duan(aa,bb,a,b,op.top());//合并。
	if(op.top()=='|') num=a|b;
	else if(op.top()=='&') num=a&b;
	stk.push(num);
	op.pop();
	return;
}
void solve()
{
	int t=strlen(s);
	for(int i=0;i<t;i++)
	{
		if(isdigit(s[i])) stk.push(s[i]-'0'),duan.push({0,0});//如果遇到数就直接放入栈中，并且为这个数创建一个新的空间，代表他目前算出的短路次数，第一个代表或，第二个代表与。
		else 
		{
			if(s[i]=='(') op.push('(');
			if(s[i]==')')
			{
				while(!op.empty() && op.top()!='(') calc();//表达式求值模板。
				if(!op.empty()) op.pop();
			}
			if(s[i]!='(' && s[i]!=')')
			{
				while(!op.empty() && mp[op.top()]>=mp[s[i]]) calc();
				op.push(s[i]);
			}
		}
	}
	while(!op.empty()) calc();
	printf("%d\n",stk.top());
	printf("%d %d",duan.top().second,duan.top().first);
}
int main()
{
	scanf("%s",s);
	mp['|']=1;
	mp['&']=2;//优先级。
	solve();
}
```

这道题其实感觉没有绿题的难度，就是跑了一遍表达式求值。

---


# [GESP202406 七级] 黑白翻转

## 题目描述

小杨有一棵包含 $n$ 个节点的树，这棵树上的任意一个节点要么是白色，要么是黑色。小杨认为一棵树是美丽树当且仅当在删除所有白色节点之后，剩余节点仍然组成一棵树。

小杨每次操作可以选择一个白色节点将它的颜色变为黑色，他想知道自己最少要执行多少次操作可以使得这棵树变为美丽树。


## 说明/提示

### 样例解释

将节点 $1$ 和 $3$ 变为黑色即可使这棵树变为美丽树，此时删除白色节点 $5$，剩余黑色节点仍然组成一棵树。

### 数据范围
子任务编号|数据点占比|$n$ |$a_i$ |特殊条件
:-:|:-:|:-:|:-:|:-:
$1$|$30\%$ |$\leq 10^5$ | $0\leq a_i\leq 1$|树的形态为一条链
$2$|$30\%$ | $\leq 10^5$ | $0\leq a_i\leq 1$| 只有两个节点颜色为黑色
$3$|$40\%$|$\leq 10^5$|$0\leq a_i\leq 1$|

对于全部数据，保证有 $1\leq n\leq 10^5$，$0\leq a_i\leq 1$。

## 样例 #1

### 输入

```
5
0 1 0 1 0
1 2
1 3
3 4
3 5
```

### 输出

```
2```

# 题解

## 作者：WZWZWZWY (赞：14)

~~第一眼：水题，感觉橙。~~

~~提交 WA 四次后，开始思考正解……~~

------------

就不放错误思路了，以免误导大家。

正确思路：任意两个黑点之间的所有白点都不能被删除，所以只需要把两个黑点之间的所有白点都变成黑点就可以。

为什么这样是正确的？因为这是一颗树，若两个黑点之间有一个白点，那么删掉它肯定是不行的，否则图会不连通。

所以我们只要以一个黑点为根，向下，若能到另外一个黑点，这期间的所有白点都会变成黑点。




```
#include <bits/stdc++.h>
using namespace std;

bool color[100005];
int ans, n;
vector <int> e[100005];

bool dfs(int x, int fa) {
	bool t = 0;
	for (int i = 0; i < e[x].size(); i++) {
		int to = e[x][i];
		if (to != fa && dfs(to, x)) t = 1; // 永远不要将该写 && 的地方写成 &，因为 && 会短路， & 不会 
	}
	if (!color[x] && t) ans++; // 白点的子树里有黑点，而根又是个黑点，所以白点被“两芝士夹一面包”了
	return (color[x] || t); // 返回这个点和这个点的子树是否有黑点
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> color[i];
	for (int i = 1; i < n; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y); e[y].push_back(x);
	}
	int x = -1;
	for (int i = 1; i <= n; i++)
		if (color[i]) { // 找到黑色点 
			x = i; break;
		}
	dfs(x, 0);
	cout << ans;
}
```

---

## 作者：fishing_cat (赞：14)

[传送门](https://www.luogu.com.cn/problem/P10723)及[双倍经验](https://www.luogu.com.cn/problem/AT_abc368_d)

### 题意
换掉染色的说法，可以这样理解。  
一棵树有黑白两种点，找到包含所有黑点的最小树，输出这颗最小树中的白点个数（即原题中白染黑的操作数）。

### 思路
要找到这样的一棵树，可以先假定一个根，选黑点中的任意一个为根一定是可行的。

为了方便计算，可以先统计整个最小树的大小，最后再减去黑点总数。如何统计整个最小树的大小？见这段代码。

```cpp
void dfs(ll u,ll f){
	for(int v : eg[u]){// 遍历与 now 相连的所有点
		if(v == f) continue;// 是父亲节点，直接跳出，保证只向深度更深的方向
		dfs(v, u);// 向子节点dfs
		vis[u] += vis[v];
    // vis 标记是否在要求的最小树中
	}
	return;
}
```

为什么是可行的？   
函数操作到深度最深的点，开始回溯。回溯中会将 $vis$ 的值加上其子节点的 $vis$ 值，效果就是所有的在最小树上的点的 $vis$ 都累加为一个整数，遍历 $vis$，并统计非零的数个数，就是整个包含所有黑点最小树的大小了。

具体证明，假定的总根也是最小树的根，所以每一黑点到根的路径及这个路径经过的点都会被包含在这个最小黑点树中。   
回溯中，如果一个点的子节点为黑点或已经被标记包含在黑点最小树中（即 $vis$ 的值非零），这个点应该也被标记；而如果子节点未被标记，这个点的状态不变。     
可以分类讨论，但 $vis$ 累加就可以完美解决，手推一下，这两种情况都是可以被正确解决的。

### 具体代码

[AC记录](https://www.luogu.com.cn/record/174691099)

```cpp
// 前面都有了，这里就只给主函数啦
int main(){
	read(n); 
	for(int i = 1; i <= n; i++){
		read(c);
		if(c == 1){
			vis[i] = 1; // 黑点开始就标记
			num1++; // 统计黑点总数
			root = i; //
		}
	}
	for(int i = 1; i <= n-1; i++){
		read(a); read(b);
		eg[a].push_back(b);
		eg[b].push_back(a);
	}
	dfs(root, 0);
	for(int i = 1; i <= n; i++) 
		ans += bool(vis[i]); // 统计黑点最小树大小
	printf("%lld\n", ans - num1);
	return 0;
    // 完结撒花~~
}
```

---

## 作者：Heldivis (赞：11)

看到题解区都是树形 DP，这里提供一种类似拓扑排序的方法。

按照题意，每次删去一个白点，原图仍然保持树的形态。考虑一个白点，如果不需要它来连接其他黑点，那么它一定是没用的，可以删去；否则就要付出代价来修改它。

每次删点，一定是**度数小于等于 $1$ 的白点，即某一个白色叶子节点**。这种点删去后都不影响树的结构。

删完所有可以删的白点后，剩下了一个**每个叶子节点都是黑色的树**（或所有点都删完了）。这时，为了黑点还在树上，必须进行操作了，此时的白点数量即为答案。

代码：

```cpp
// w[i] == 1 表示 i 被删过了，或者是黑点，总之不能再删了
n = read();
for (int i = 1; i <= n; i++)
  res += ((w[i] = read()) == 0); 
for (int i = 1; i < n; i++) {
  int x = read(), y = read();
  e[x].push_back(y);
  e[y].push_back(x);
  d[x]++, d[y]++;
}
queue<int> q;
for (int i = 1; i <= n; i++)
  if (d[i] <= 1 && !w[i])  // 度数为 0 也删去，也算是特判吧
    q.push(i), w[i] = 1, res--;
while (q.size()) {
  int x = q.front();
  q.pop();
  for (int y : e[x])
    if (!w[y] && --d[y] <= 1)  // 度数为 0 也删去，这是删到最后一个点了
      q.push(y), w[y] = 1, res--;
}
return 0 * printf("%lld", res);
```

---

## 作者：穼柗° (赞：9)

#### 温馨提示：在[专栏](https://www.luogu.com/article/oragh0d9)食用效果更佳。

根据题意，输入的是无根树。而删白点后使剩余节点任为一棵树，相当于使剩余节点联通，因此删时白点是叶节点（度为 $1$）。

可以用拓扑排序，每次把所有白色叶节点删掉，剩余的白色节点就只能染黑。

### Code
```cpp
#include <cstdio>
#include <vector>
#include <queue>
using namespace std;
queue<int> q;
vector<int> g[100001]; // vector存图
int n,cnt,d[100001],a[100001]; // cnt表示白点数，d[u]表示u的度
int main() {
	scanf("%d",&n);
	if(n==1) return putchar('0'),0; // 如果输入只有一个白点会输出 1，所以要特判
	else for(int i=1;i<=n;i++) {
		scanf("%d",a+i);
		cnt+=a[i]^1;
	} for(int u,v,i=1;i<n;i++) {
		scanf("%d%d",&u,&v);
		g[u].push_back(v),
		g[v].push_back(u),
		d[u]++,d[v]++;
	} for(int i=1;i<=n;i++)
		if(d[i]==1&&!a[i])
			q.push(i),
			d[i]=0,
			cnt--;
	int u;
	while(q.size()) {
		u=q.front(); q.pop();
		for(int v: g[u]) {
			d[v]--;
			if(!a[v]&&d[v]==1)
				q.push(v),cnt--,d[v]=0;
		}
	} printf("%d",cnt);
	return 0;
}
```

#### 注：禁止抄代码！

---

## 作者：Redamancy_Lydic (赞：7)

## 背景

汗流浃背了。

## 分析

容易想到一个显然的思路：以任意节点为根，开始遍历。如果一个节点的子树里面有黑点，那么它必须保留，否则如果它是白点，则可以删去。

但这个方法很容易举出反例：

![](https://cdn.luogu.com.cn/upload/image_hosting/pg1ohyis.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

在这颗树中，如果以最上面的白点为根，那么手推发现算法显然错误。

尝试进行修改，容易发现，对于类似的情况，我们只需要以一个黑点为根，就可以轻松解决。

还有一类特殊情况，如果原树里面全是白点，那么输出 $0$ 即可。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=1e9+7;
const int maxn=1e6+10;
int n,d[maxn];
vector<int> G[maxn];
bool siz[maxn];
void dfs(int x,int fa)
{
	if(d[x])siz[x]=1;
	for(auto y : G[x])
	{
		if(y==fa)continue;
		dfs(y,x);
		siz[x]|=siz[y];
	}
}
int du[maxn];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)d[i]=read();
	bool ff=0;
	for(int i=1;i<=n;i++)ff|=d[i];
	if(!ff)return 0*printf("%lld\n",0);
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		G[x].push_back(y);
		G[y].push_back(x);
		du[x]++;du[y]++;
	}
	int root=1;
	for(int i=1;i<=n;i++)if(d[i]==1)root=i;
	dfs(root,0);
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(d[i]==0&&siz[i])ans++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：whrwlx (赞：4)

## 题意
 
因为只能把白变黑，所以该题可理解为找到包含黑点的点数最小的树。

## 分析

我们从部分分入手。

### 链

很明显，只要将所有黑点连起来，把经过的白点变黑就行。

~~很好理解，代码就不放了。~~

### 两个黑点

首先我们从样例入手：

```
5
0 1 0 1 0
1 2
1 3
3 4
3 5
```

那么它长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/5k0fgt3k.png)

逗号前的是编号，逗号后的是黑白。（$1$ 是黑，$0$ 是白）

那么 $2$，$4$ 点为黑色，很容易发现要选 $1$，$3$ 号点，为什么呢？

考虑要求“点数最小的树”，那么肯定是两个黑点的最短路径（即最简单路径），这个我们可以用 LCA 或 DFS 找到最短路径，然后染色即可。

~~还是很好理解，代码还是不放了。~~

### 满分思路（不一定是正解）

很明显，我们每次找一对黑点，将他们最简单路径上的点染黑，最后统计答案，但是这样的最劣时间复杂度是 $O{(nk^2)}$ 的（$k$ 为黑点个数），那么考虑优化：

我们在两个黑点的情况中也想到了 LCA 的做法，可不可以用上呢？

假如有这么一组数据：

![](https://cdn.luogu.com.cn/upload/image_hosting/sgnstidv.png)

逗号前的是编号，逗号后的是黑白。（$1$ 是黑，$0$ 是白）

考虑先连 $4$，$5$ 两个黑点，然后再加上 $2$ 这个黑点，依次合并。

那么我们有什么办法把前面的节点的的染色信息储存起来并降低时间复杂度呢？

我们发现，只需要找到前面点的共同 LCA 就行了！

于是我们可以先找到所有黑点共同的 LCA，然后从每个黑点出发，向共同的 LCA 连线并染色，染色的过程可以用记忆化搜索，这样时间复杂度降到了 $O{(n \log n)}$！

代码：~~（马蜂又臭又长）~~

```c++
#include<bits/stdc++.h>
#define int long long
#define ll long long
#define fd(i,a,b) for(int i=a,_i=b;i<=_i;i=-~i)
#define bd(i,a,b) for(int i=a,_i=b;i>=_i;i=~-i)
using namespace std;

const int N=2e5+509,M=1e6+509,mod=1e9+7;
int n,m,ss,tot,head[N],a[N],v[N],fl[N];//这个v数组没用但是懒得删了QAQ
int d[N],f[N][20],t;

struct edge
{
	int to,w,nxt;
}e[N<<1];

inline void add(int a,int b,int c)
{
	e[++tot].nxt=head[a];
	e[tot].to=b;
	e[tot].w=c;
	head[a]=tot;
}

void bfs()//LCA板子
{
	queue<int> q;
	q.push(1);
	d[1]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt)
		{
			int y=e[i].to;
			if(d[y]) continue;
			d[y]=d[x]+1;
			f[y][0]=x;
			fd(j,1,t)
			{
				f[y][j]=f[f[y][j-1]][j-1];
			}
			q.push(y);
		}
	}
}

int lca(int a,int b)//LCA板子
{
	if(d[a]>d[b]) swap(a,b);
	bd(i,t,0)
	{
		if(d[f[b][i]]>=d[a]) b=f[b][i];
	}
	if(a==b) return a;
	bd(i,t,0)
	{
		if(f[a][i]!=f[b][i]) a=f[a][i],b=f[b][i];
	}
	return f[a][0];
}

void dfs(int x,int fa,int en)
{
//	cout<<x<<';'<<d[x]<<' '<<d[fa]<<endl
	if(fa!=0&&(d[x]>d[fa]||x==fa||fl[x])) return;
  //这里用到了d数组，即到了上级之后，不让他往另一个儿子递归，否则答案会变大
	fl[x]=1;
	if(x==en) return;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa) continue;
		dfs(y,x,en);
	}
}

signed main()
{
	
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	
	cin>>n;
	fd(i,1,n) cin>>a[i];
	fd(i,1,n-1)
	{
		int x,y;
		cin>>x>>y;
		add(x,y,0);
		add(y,x,0);
		v[x]++,v[y]++;
	}
  
	t=log(n)/log(2);
	int ans=0;
	bfs();
	int Lca=-1;
	fd(i,1,n)
	{
		if(a[i]==1&&Lca<0) Lca=i; 
		else if(a[i]==1) Lca=lca(Lca,i);
	}//找共同 LCA

	fd(i,1,n)
	{
		if(a[i]) dfs(i,0,Lca);
	}
	
//	fd(i,1,n) cout<<d[i]<<' '<<fl[i]<<endl;
	fd(i,1,n) if(a[i]==0&&fl[i]==1) ans++;
	cout<<ans<<endl;
	
	return 0;
}
```

### 继续优化

~~考虑这是一道绿题，而且题目标签为树的遍历。~~

感觉用 LCA 有点大材小用，找最简单路径不是也可以用 DFS 吗，那么我们能否在 DFS 上做一些修改，可以在一次遍历染完色呢？

这里借鉴了 [yxans](https://www.luogu.com.cn/user/739226) 大佬的想法（即为在回溯时修改）：

[大佬の代码](https://www.luogu.com/article/0p43nnc5)

复杂度可以降到 $O{(n)}$。

#### 后续

其实 [xuQAQ](https://www.luogu.com.cn/user/796963) 还有一种拓扑排序的做法。

---

## 作者：MnZnOIer (赞：4)

打开这道题，看到了：“树”“最少要执行多少次操作”等关键词。好，又是一道树形 DP。

没学过树形 DP 的请跳转至 [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)。

并且请大家谨记，一定要存双向边，别问我怎么知道的。

### 初次思路
我们令 $1$ 号点为树的根，建单向边，从 $1$ 向下遍历。

使 `dfs(d)` 为 $d$ 是否需要**成为**黑点。

如果 $d$ 的子节点（下称为 $v$）其中包含黑点（以及需要成为黑点的点），那么 $d$ 需要成为黑点，需要操作的次数加一。因为如果 $d$ 不是黑点，那么 $v$ 与 $d$ 的祖先黑点群必然断开，不符合题意。

当 $d$ 已经为黑点时，就不需要增加操作数。

### 综上反思
但是写出来之后，我们会发现，这个代码可以被轻而易举地 hack 掉。

如：
~~~
7
0 0 0 1 0 1 0
1 2
1 3
2 4
2 5
5 6
5 7
~~~

![](https://cdn.luogu.com.cn/upload/image_hosting/g755eo3p.png)

按以上思路写出的代码输出的结果为 3，但是稍稍动手分析，就可以知道，只需要把 $2,5$ 号节点变成黑色即可。

### 二次思考
为什么会导致程序运行结果不是最优结果？

因为程序是从一个子节点逐渐上推到根节点的，也就是从一个黑子节点往上推到根节点，把这一条路径全部变成黑色，但没有保证根节点是黑色的，导致没有得到最优结果。

那么，我们可以令一个黑色点为根，中间的 `dfs` 部分不变，并建双向边，这样，就可以得到最优结果了。

当我们把图变成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/uy2p2kjg.png)

然后替换掉节点序号，前面的代码就可以输出正确的答案。

### 主干代码
下面给出 `dfs` 部分的代码。
```cpp
bool dfs (int d, int fa)//fa 可以防止走回头路
{
	bool f = a[d];
	for (int i = h[d]; i; i = e[i].nxt)//链式前向星
	{
		if (e[i].v == fa)continue;
		bool vv = dfs (e[i].v, d);//先向下递归
		if (! f && vv)++ cnt, f = 1;//再统计答案
	}
	return f;//最后返回是否需要是黑点
}
```

---

## 作者：Kendieer (赞：3)

题目传送门：[**\[ P10723 \]**](https://www.luogu.com.cn/problem/P10723)

## 思路构建

一开始乍一看，这不就是树形 DP 吗？

但是细想总有些不对劲。

因此我们可以分出一下情况进行讨论:

### 1.当黑色节点为根节点时

#### 1.1 子树不含有黑色节点

对于这种情况，我们的最优情况是把子节点全部删除。

#### 1.2 子树包含黑色节点

我们只需要将该子树的最优操作方案的操作数上传到父节点即可。

### 2.当白色节点为根节点时

#### 2.1 子树不包含黑色节点

对于这种情况，我们选择把子树删除是最优情况。

#### 2.2 子树包含黑色节点

当子树包含黑色节点时，我们需要按照子树数量考虑不同情况: 

##### 2.2.1 当子树数量 $\ge 2$ 时

![](https://cdn.luogu.com.cn/upload/image_hosting/67lm53c6.png)

**注:图中的白色实心节点为题目中的黑色节点，白色空心节点为题目中的白色节点，红色节点为当前处理的白色节点。**

对于图中的父亲节点，我们可以发现该节点不能被删除，因为它是两个黑色节点的唯一连接路径。

因此，对于该种情况，该树的操作数量之和为各子树操作数之和。

##### 2.2.2 当子树数量为 $1$ 时

![](https://cdn.luogu.com.cn/upload/image_hosting/avgz0wbx.png)

不难发现，对于红色的节点，我们发现倘若删除了依然能够构建出一棵符合题意的树。

因此，我们需要上传当前操作数以及无用操作数。

**为什么要传无用操作数？**

当该父亲节点的所有祖先节点中，含有黑色节点的子树数量均小于 $2$ 时，那么我们可以认为从该节点到根节点的操作是无意义的，这些节点应该被删除。

### 总结

综上所述，我们可以通过 **DFS** 对树遍历，然后向父亲节点上传数据，从而汇总所有数据到根节点。

由于我们对无用操作进行了处理，从根节点到对应有效操作子树之间的距离可以通过总操作数减去相应的无用操作数来得到最终结果，**因此，我们可以任意选择一个节点作为根节点进行建树**。

参考代码: [**\[ link \]**](https://www.luogu.com.cn/paste/ziegs6kc)

---

## 作者：lihe_qwq (赞：2)

## 题意简析
给出一棵树，每个点都有一个颜色黑或白，你可以选择一些白点改为黑点，要求删除白点后，剩下的黑点仍组成一棵树，求改成白点的黑点的最小数量。

## 分析
考虑哪些白点删除后余下点仍是一棵树，这些点删完，余下的点则必须是黑色或被染为黑色。则统计所有白点数量与可删白点数，其差值则为答案。

再讨论哪些白点是可删的，很明显，若一个白点是叶子是可删的，删除后新产生的白色叶子节点也是可删的，如图。
![](https://cdn.luogu.com.cn/upload/image_hosting/jhzx1h0m.png)

删除白色叶子节点。
![](https://cdn.luogu.com.cn/upload/image_hosting/qke1fcne.png)
删除新出现的白色节点。
![](https://cdn.luogu.com.cn/upload/image_hosting/kf0kdj4a.png)
余下的点是必须染为黑色的点。
![](https://cdn.luogu.com.cn/upload/image_hosting/wv8kawe7.png)
用拓扑排序就可以很简单的解决该问题。


## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+100;
int n,p[N],sum2,sum1,in[N],x,y,ans,vis[N];

struct ooo//链式前向星存边 。
{
	int nxt,to;
}e[N<<1];
int len,lin[N<<1];
void add(int x,int y)
{
	e[++len].nxt=lin[x];
	lin[x]=len;
	e[len].to=y;
}

queue<int>q;
void tuopu()
{
	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		for(int i=lin[t];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(vis[v]==1||p[v]==1)//进过队列的点与颜色为一的点不入队列 。
				continue;
			in[v]--;
			if(in[v]==1)
			{
				vis[v]=1;
				q.push(v);
				sum2++;
			}
		}
	}
	return;
}

signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&p[i]);
	for(int i=1;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		add(x,y);add(y,x);//无向图 
		in[x]++;in[y]++;//统计入度
	}
	for(int i=1;i<=n;i++)//统计颜色为零的点的数量，若入度为一，则加入队列 。
		if(p[i]==0)
		{
			sum1++;
			if(in[i]<=1)//可能只有一个点没有边  所以<=。 
			{
				q.push(i);
				vis[i]=1;
				sum2++;
			}
		}
	tuopu();
	ans=sum1-sum2;
	printf("%lld",ans);
	return 0;
}
```
~~蒟蒻，第一次写题解，审核大大手下留情。~~

---

## 作者：XYzero (赞：1)

## 题目大意

### [题目传送门](https://www.luogu.com.cn/problem/P10723)

给定一棵树，有 $n$ 个节点，节点有的是黑色，有的是白色，问最少要让多少白色节点变成黑色节点，才能使在去除所有白色节点后剩下的节点仍可以构成一棵树。

## 分析

我们考虑什么样的白色节点是一定要变成黑色的？

可以发现，如果一个节点的子节点中，有黑色的节点，那么这个节点一定变成黑色。

为什么呢？

看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dpfe7cai.png)

我们可以观察到第 $2$ 和 $3$ 个节点一定得变成黑色，否则无法让这两的节点的子节点 $4$ 和 $6$ 在删除掉所有白色节点后和其他黑色节点联通，也就是构成一棵树。

于是，我们可以先遍历一遍整棵树，如果存在节点 $u$ 和他的子节点 $v$，满足`a[v] && !a[u]`，就让节点 $u$ 变成黑色。

时间复杂度 $O(n)$，可以通过本题。
### 坑点

在遍历前，初始时应任选一个黑色节点为根来遍历，否则就会出现答案变多的情况，就是因为多会把不必要的白色节点也变黑。

## 代码实现


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
bool flg[N];
int n,a[N],ans,S;
vector<int>e[N];
void dfs(int x,int fa){
	for(auto to : e[x]){
		if(to == fa)continue;
		dfs(to,x);
		if(a[to] && !a[x]){//子节点是黑色但父节点不是
			ans ++;
			a[x] = 1;//变成黑色
		}
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	
	
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
		if(a[i])S = i;//找到黑色节点的根
	} 
	for(int i = 1;i < n;i++){
	    int u,v;
		cin >> u >> v;
		e[u].emplace_back(v);
		e[v].emplace_back(u); 
	}
	dfs(S,0);
	cout << ans;
	
	
	
	return 0;
}
```

---

## 作者：andycode (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10723)

 # 题目大意

给出一颗无根树，每个节点都为白色或黑色。求至少需要将多少白色的结点变成黑色，使得删除完所有白点后，剩余的黑点可构成一棵树。

 # 思路讲解

由于黑点不可变为白点，所以删点后的树中必然包含所有原来为黑色的结点，所以我们可以任取一个黑色的结点作为删点后的树和原来的树的根节点。

因为删点后只能剩下一棵树，所以所有黑点和根节点的路径中包含的所有的点必需为黑色。也就是说如果一个白点在一条黑点与根节点间的路径中，则必需将这个白点变为黑色。

于是我们可以对这颗树进行 `dfs`。创建一个返回值类型为 `bool` 的函数 `dfs(x)`。如果 `dfs(x)` 的返回值为 `true`，则节点 $x$ 所包含的子树中至少有一个黑色的结点，否则返回 `false`，即子树中没有黑色的结点。

这样我们遍历时，如果一个结点的直接连接的深度比该点大的点中的 `dfs` 值为 `true`，则说明存在一条黑点与根节点的路径，包含该节点。如果发生这种情况，我们需要将返回值定为 `true`，如果该点为**白色**，则再将这个白点变为黑色，并让答案加 $1$。

如果点 $x$ 为黑色或出现上一段出现的情况，则函数 `dfs(x)` 返回的值为 `true`，否则为 `false`。

这里需要注意的是，即使我们确定了返回值，也不能直接返回返回值结束函数。只有遍历完后返回，才能得到正确答案。

算法复杂度为 $O(n)$。

 # 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100005],ans;
bool mark[100005];
vector<int> g[100005];
bool dfs(int x){
    bool flag=bool(a[x]);
    //用flag存储返回值，如果a[x]为黑色，flag为true
    mark[x]=true;//标记该结点已被遍历
    int len=g[x].size();
    for(int i=0;i<len;i++)
        if(!mark[g[x][i]])//深度大的点都已被遍历
            if(dfs(g[x][i]))//如果出现黑点，将返回值赋值为true，如果a[x]为白色，ans就+1，a[x]不管怎样都变成黑色
                flag=true,ans+=(a[x]==0),a[x]=1;
    return flag;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for(int i=1;i<=n;i++)
        if(a[i]){
            dfs(i);//如果结点为黑色，则作为根节点遍历
            break;
        }
    cout<<ans;
    return 0;
}
```

完结撒花！

---

（如果该文章有表述错误或可以改进的地方，欢迎在评论区提出）

---

## 作者：lyz0427 (赞：1)

### 题目描述
小杨有一棵包含 $n$ 个节点的树，这棵树上的任意一个节点要么是白色，要么是黑色。小杨认为一棵树是美丽树当且仅当在删除所有白色节点之后，剩余节点仍然组成一棵树。

小杨每次操作可以选择一个白色节点将它的颜色变为黑色，他想知道自己最少要执行多少次操作可以使得这棵树变为美丽树。
### 题目大意
选出最少白色子节点变成黑色使它成为黑子节点居上，白子节点居下这样删除剩下的白子节点全在下面，使它还是树。
### 算法分析
- 从这棵树中的最后一个黑色子节点开始遍历，如果遇到黑色的节点，把他的父亲也改成黑色，这样就可以造出美丽树。
- 这题考树的遍历，那肯定要用深搜啊，简单方便好打。
### AC代码
```cpp
#include<bits/stdc++.h>
#define int long long  
#define ma 100005
using namespace std;
int ans;
int n;
int s[ma];
vector<int> a[ma];//存储关系
void dfs(int k,int f)
{
	for(int i=0;i<a[k].size();i++)
	{
	    int y=a[k][i];//找关系 
		if(y==f) continue;//和上一个子节点一样就不用在遍历了 
		dfs(y,k);//继续遍历 
		if(s[y]==1&&!s[k]) s[k]=1,ans++;//看父亲是否是黑的，不是就“黑”他 
	}
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)
	{
    	cin>>s[i]; 
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		a[x].push_back(y);
		a[y].push_back(x);//构建父子关系 
	}
    int t=0;
	for(int i=1;i<=n;i++)
	{
	    if(s[i]==1)
		{
		    t=i;
	    }   //找到编号最大的子节点 
    }
    dfs(t,0);//开始遍历 
    cout<<ans;//输出个数 
	return 0;
}
```
#### 原创不易，如有雷同，纯属巧合。

---

## 作者：I_Love_DS (赞：1)

## 思路

### 子任务 1 做法

找到度数为 $1$ 的两个点，令之为链首 $l$ 和链尾 $r$。

分别 dfs 找到两端第一个颜色为黑的节点。

把这两个节点中间的白色节点染黑即可。

时间复杂度 $O(n)$。

### 子任务 2 做法

把这两个黑色节点中间的白色节点染黑即可。

时间复杂度 $O(n)$。

### 100pts 做法

考虑到树的特性：**连通**。

那么就是说，如果两个黑色节点中间有白色节点，就必须把这些白色节点**全部染黑**。

然后，剩下的白色节点就不用改了，因为现在黑色节点**已经连通**。

时间复杂度 $O(n)$。

代码实现方面见下。

#### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 50;

vector <int> e[N];
int n, a[N], d[N], ans = 0, root = -1;
// root：指定一个颜色为黑的节点为根。
bool vis[N];

int dfs(int u) {
	vis[u] = 1;
	for (auto v : e[u]) 
		if (!vis[v]) 
			if (dfs(v) && !a[u]) 
				++ans, a[u] = 1;
	return a[u];
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		if (a[i]) root = i;
	}
	if (root == -1) {//空树也是树
		assert(0);//只是测试一下有没有节点全白的测试点
		printf("0");
		return 0;
	}
	for (int i = 1; i < n; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(root);
	printf("%d", ans);
	return 0;
}
```

解释一下：`assert(0)` 的作用是：执行到这句话会立刻 RE，作者就是测试一下有没有节点全白的测试点。

---

## 作者：zhangxiao666 (赞：1)

其实根本不用树形 dp。

考虑哪些点删完还是树，显然是叶子节点，因此先把白色叶子结点删掉，直到所有叶子结点都为黑色。

那么剩下的白点显然都不能删，必须改成黑色。

这时树中剩下的白点数量就是答案。

记录白点数量，类似拓扑排序删点即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
const int INF = 1e9;
int n, ans;
int a[N], du[N];
vector<int> e[N];

void Solve()
{
	queue<int> q;
	for (int i = 1; i <= n; i++)
	{
		if (!a[i] && du[i] <= 1)
			du[i] = INF, ans--, q.push(i);
	}
	while (!q.empty())
	{
		int h = q.front(); q.pop();
		for (int v : e[h])
		{
			du[v] --;
			if (!a[v] && du[v] <= 1)
				du[v] = INF, ans--, q.push(v);
		}
	}
}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i], ans += (a[i] == 0);
	for (int i = 1; i < n; i++)
	{
		int x, y; cin >> x >> y;
		e[x].push_back(y);
		e[y].push_back(x);
		du[x]++, du[y]++;
	}
	Solve();
	cout << ans << "\n";
	return 0;
}

```

---

## 作者：Hrz_OIer (赞：1)

**小重点**：题目给出的树是无根树，且仍选一个节点当树根也没有实质上的影响，所以我们直接选用编号为 $1$ 的节点作为根。

存图方法：用 `vector` 存图即可。

## 解法
1. 用 `dfs1` 函数计算出任意节点的子树的黑色节点个数，用 `siz` 数组存储。
2. 用 `dfs2` 函数计算答案。

**如果当前节点的子树中有黑点，并且这个点是白点，这个点一定需要染黑。**
## code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
vector<int>g[N];
int c[N],n,siz[N],ans,cnt; //c数组存颜色
inline void dfs1(int u,int fa){
	siz[u]=c[u];
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa) continue;//避免死循环
		dfs1(v,u);
		siz[u]+=siz[v];}
	return;}
inline void dfs2(int u,int fa){
	int f1=0,f2=0; 
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa)continue;
		dfs2(v,u);
		if(siz[v]!=0)f2=f1&1,f1=1;}//装一下小佬
	if(c[u]==1) return;//如果当前节点颜色为黑色，跳过
	if((f1&&!f2&&!c[u]&&siz[u]==cnt)||(siz[u]==0)) return;
	++ans;}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>c[i],cnt+=c[i];
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);}//vector存图
	dfs1(1,0);
	dfs2(1,0);
	cout<<ans;
	return 0;}
```

---

## 作者：CaiZi (赞：1)

## [GESP202406 七级] 黑白翻转 题解
**[题目链接](https://www.luogu.com.cn/problem/P10723)**
### 题目分析
我们考虑一个树的哪些节点删除后，依然为一棵树。显然是所有叶子节点。在把所有叶子节点删去后，新的树的叶子节点依然可以继续删除。以此类推。

因此我们进行 DFS（或是树形 DP），对于所有 $a_i=0$ 的叶子节点，回溯时返回 true，表示可以向上扩展，并令 $b_i\gets1$；对于所有 $a_i=1$ 的叶子节点，回溯时返回 false，表示不可以向上扩展，并令 $b_i\gets0$。

接下来我们对于所有非叶子节点，先将 $b_i$ 改为其所有子节点 $j$ 的 $b_j$ 再加 $1$。如果该节点满足 $a_i=0$，且其所有子节点都返回 true，则继续返回 true，再将 $b_i$ 加 $1$；否则返回 false。

最后所有 $a_i=0$ 的数量减去 $b_r$ 就是答案（$r$ 为 DFS 时选择的根）。我们的 $r$ 需要满足 $a_r=1$，这样无需额外考虑根节点为白色点的情况。如果 $\forall a_i=0$，直接输出 $0$。

时间复杂度 $O(n)$。
### 代码展示
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],b[100001],r,x,y,w;
vector<int>g[100001];
inline bool dfs(int u,int v){
	if(g[u].size()==1&&u!=r){
		if(a[u]==1){
			return false;
		}
		else{
			b[u]=1;
			return true;
		}
	}
	bool c,d=true;
	if(a[u]==1){
		d=false;
	}
	for(int i:g[u]){
		if(i!=v){
			c=dfs(i,u);
			b[u]+=b[i];
			if(!c){
				d=false;
			}
		}
	}
	if(d&&a[u]==0){
		b[u]++;
	}
	return d;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==0){
			w++;
		}
		if(r==0&&a[i]==1){
			r=i;
		}
	}
	for(int i=2;i<=n;i++){
		cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	if(r==0){
		cout<<"0";
	}
	else{
		dfs(r,0);
		cout<<w-b[r];
	}
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/164845382)**

---

## 作者：mysterys (赞：1)

# 前言
蒟蒻一看到这道题就想到了思路，只不过不知道这种思路能不能被算作树形 dp。
# 思路
##  根的影响
因为原本给出的就是一棵树，所以无论以谁为根，树的形态不变。换句话说，以谁为根并不影响黑色节点是否连成一棵树。

**所以，我们钦定编号为 $1$ 的节点为根即可。**
## 如何判断当前节点是否需要改变颜色
我们逆向思考，什么时候当前节点不需要改变颜色，不难得出共有以下两种情况：

1. 当前节点的子节点没有黑色节点，所以当前节点颜色不会影响黑色节点连成树的情况。
1. 所有黑色节点都在当前节点的**同一棵**子树上，所以无论当前节点是否变色，都与黑色节点的成树情况无关。

## 具体实现
两遍 dfs。

第一遍处理出每一节点的子树中黑色节点个数。第二遍决定当前节点是否要变色。
## 时间复杂度
只有两遍 dfs 遍历这颗树，所以总复杂度：$O(N)$。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=1e5+10;
vector<int>g[N];
int col[N],n,siz[N],ans,cnt; 
inline void dfs1(int u,int dad){
	siz[u]=col[u];//处理出子树中黑色节点个数。 
	for(int v:g[u]){
		if(v==dad) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
	}
} 
inline void dfs2(int u,int dad){
	bool flag1=0,flag2=0; 
	for(int v:g[u]){
		if(v==dad) continue;
		dfs2(v,u);
		if(siz[v]!=0){
			if(!flag1) flag1=1;
			else flag2=1; 
		}
	}
	//cout<<u<<' '<<siz[u]<<endl;
	if(col[u]==1) return;//当前节点是黑色，不需要变色。 
	if((flag1&&!flag2&&!col[u]&&siz[u]==cnt)||(siz[u]==0)) return;
	//黑色节点都在当前节点的子树上，但不在同一棵子树上。
	//子树中没有黑色节点的情况。   
	++ans;//其他则是可行的方案。 
}
signed main(){
	cin.tie(nullptr)->ios::sync_with_stdio(false);
	cout.tie(nullptr);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>col[i];
		cnt+=col[i];
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs1(1,0);
	dfs2(1,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：Lijiangjun4 (赞：1)

# P10723 题解
## 解题思路
这道题就是树上的深搜。对于每个白色节点，如果它的儿子中有一个黑色节点，则这个白色节点就不能删去，必须染成黑色。

注意这组数据：
![](https://cdn.luogu.com.cn/upload/image_hosting/ur4k30dz.png)

按照上面的算法，图中最上面的白色节点需要染色，但实际上这棵树并不需要染色。所以，dfs 的时候要以一个黑色节点作为根节点。

## AC Code

```cpp
#include<iostream>
using namespace std;
int n,a[100005],ans;
int head[100005],to[200005],nxt[200005];
void add(int u,int v)
{
	static int cnt=0;
	++cnt;
	to[cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}
void dfs(int x,int fa)
{
	bool flag=false;
	for(int i=head[x];i;i=nxt[i])
	{
		int e=to[i];
		if(e==fa) continue;
		dfs(e,x);
		if(a[e]) flag=true;
	}
	if(!a[x]&&flag)
	{
		a[x]=1;
		ans++;
	}
}
int main()
{
	cin>>n;
	int root=1;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(a[i]) root=i;
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs(root,0);
	cout<<ans;
	return 0;
}
```

[ac记录](https://www.luogu.com.cn/record/173509409)

---

## 作者：ty_mxzhn (赞：1)

题意：树上有一些节点，有黑白两色，求最少将多少个白点染成黑点才能让黑点构成连通块。

贪心。任取一个黑点作为树根，然后从这个点开始 dfs。在每个节点上记录这个点的子树中有多少个黑点。

那么假如这个点的子树中有黑点，并且这个点是白点，这个点一定需要染黑。这些点的个数是答案的下界。

我们发现这个下界显然可以满足条件，所以这个下界就是原题的答案了。

总结：在遇到一些题目的时候可以分析答案的上下界，以来获得重要信息。同类题目：[ABC362F](https://www.luogu.com.cn/problem/AT_abc362_f)。

---

## 作者：DecemberFox (赞：1)

# P10723 [GESP202406 七级] 黑白翻转 题解

## 题目分析

本题给出了一棵由黑白色节点组成的树，可以通过若干次操作将白色节点变为黑色节点。现在要将所有白色节点删除，并使剩下的黑色节点构成一棵树，问最少要进行多少次操作。

## 解法分析

由于原本就是一棵树，此时取出若干个节点组成的一定是一棵或者多棵树。因此问题就转变为了根据原树的形态添加若干个节点，使得构成一棵树。

因此就需要将树上多个部分的黑色联通块连接起来并计算出需要使用的黑色节点数量。

这时问题就变得简单许多了，可以直接使用 dfs 计算需要的节点数量，从任意一个黑色节点开始，只要找到一个没有连上的黑色节点就将路径（此时路径有且只有一条）上的点全部变为黑色即可。

每个节点仅需计算一次，因此时间复杂度为 $O(n)$。

```cpp
#include<iostream>
#include<cstdio>
namespace io
{
	void read()
	{
		return;
	}
	template<typename nowtype,typename ...nexttype>
	void read(nowtype &now,nexttype &...next)
	{
		register char c=getchar();
		register int n(1);
		now=0;
#define isdigit(c) ((c)>='0'&&(c)<='9')
		while(!isdigit(c)){if(c=='-') n=-1;c=getchar();}
		while(isdigit(c)){now=(now<<1)+(now<<3)+(c^48);c=getchar();}
#undef isdigit
		now*=n;
		read(next...);
	}
	template<typename nowtype>
	void write(nowtype num,char end='\n')
	{
		register unsigned long long unum(0);
		if(num<0) putchar('-'),unum=-num;
		else unum=num;
		register int c[35],top(0);
		do c[top++]=unum%10,unum/=10;while(unum);
		while(top) putchar(c[--top]+48);
		putchar(end);
	}
	template<typename nowtype,typename ...nexttype>
	void write(nowtype num,char end,nexttype ...next)
	{
		register unsigned long long unum(0);
		if(num<0) putchar('-'),unum=-num;
		else unum=num;
		register int c[35],top(0);
		do c[top++]=unum%10,unum/=10;while(unum);
		while(top) putchar(c[--top]+48);
		putchar(end);
		write(next...);
	}
}
using namespace io;
//以上为快读快写
namespace SOLVE
{
	typedef long long ll;
	typedef unsigned long long ull;
	typedef __int128 lll;
	typedef unsigned __int128 ulll;
	const int const1=2e5+10;
	struct edges
	{
		int next,to;
	}edge[const1];
	int a[const1],Head[const1],cnt,cost;
	void AddEdge(int from,int to)
	{
		edge[++cnt].to=to;
		edge[cnt].next=Head[from];
		Head[from]=cnt;
	}
	bool dfs(int now,int f)
	{
		int i;
		bool add(false);
		if(a[now]) add=true;
		for(i=Head[now];i;i=edge[i].next)
		{
			if(edge[i].to==f) continue;
			add=dfs(edge[i].to,now)||add;
		}
		if(add&&!a[now]) ++cost;
		return add;
	}
	void solve()
	{
		int i,n,u,v,s(0);
		read(n);
		for(i=1;i<=n;++i)
		{
			read(a[i]);
			if(a[i]) s=i;
		}
		for(i=1;i<n;++i)
		{
			read(u,v);
			AddEdge(u,v);
			AddEdge(v,u);
		}
		dfs(s,s);
		write(cost);
	}
}
int main()
{
	SOLVE::solve();
	return 0;
}
```

---

## 作者：FJ_OIer (赞：1)

其实是一道非常简单的 dfs。

他要求删去白点后黑点能形成一棵树，其实就是让我们把最少的点染黑，使得黑点形成一个连通块。

那我们就可以随便拉一个黑点当做树根，从这个黑点开始 dfs。如果当前点的子孙节点中有黑点，那么就必须把这个点染黑用以连通。统计并输出即可。

~~这题能有绿？？~~

```cpp
#include <bits/stdc++.h>
#define N 100001
using namespace std;
int n,u,v,s,ans;
bool a[N];
vector<int> e[N];
void dfs(int u,int fa){
	for (int v:e[u]){
		if (v==fa){
			continue;
		}
		dfs(v,u);
		if (a[v]&&!a[u]){//子孙节点黑色&自身未被染色
			ans++;
			a[u]=1;//染色
		}
	}
}
int main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>a[i];
		if (a[i]){
			s=i;//黑点树根
		}
	}
	for (int i=1;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(s,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：xinxin2022 (赞：1)

## 题意

每次可以将一个白节点变为黑节点，问至少操作多少次后删除全部白节点，这棵树仍然成立。

## 思路

其实就是要通过最少的操作让所有黑节点之间联通，能删除的白节点其实就是树最根部出现的白节点，并且能删除的白节点必定没有含有黑节点的子树。

那么我们就可以使用深搜，找每棵子树最深的黑节点，在返回时统计需要染色的格子的数量。

需要注意的是，要从一个黑色节点开始深搜，否则可能会多统计需要染色的格子。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> p[100005];
//存储树
int a[100005],ans,start;
int u,v;
int n;
bool vis[100005];
inline bool dfs(int now){
    //inline优化
    bool flag=a[now];
    vis[now]=true;
    //已经遍历到，标记
    for(int i=0;i<p[now].size();i++){
    	if(vis[p[now][i]]) continue;
    	//防止陷入双向边造成的死循环
        if(dfs(p[now][i])){
            if(a[now]==0&&!flag) ans++;
            //如果这个格子是白格子且下面有黑格子，就需要对这个格子染色
            flag=true;//更改状态（染色）
        }
    }
    return flag;
    //返回子树是否有黑节点
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]) start=i;
        //找到任意一个黑格子作为起点
    }
    for(int i=1;i<n;i++){
        cin>>u>>v;
        p[u].push_back(v);
		p[v].push_back(u); 
		//建树
    }
    dfs(start);
    cout<<ans;
    return 0;
}
```

---

## 作者：Fantasy_Segment_Tree (赞：0)

这道题与 ABC 本周的 D 题非常像。考虑一种新奇的写法。

很显然所有黑色节点到他们的 LCA 都需要选，于是问题转化为判定每个点是否要被选。

考虑树上差分爆切。

对于每个点，把它到所有点 LCA 的所有点权值 $+1$。具体操作为将这个点权值 $+1$，LCA 父亲的权值 $-1$，最后每个节点的权值就是子树内权值的和。

非零点的个数就是最后是黑点的点的个数。再减去已有的黑点个数即可。

---

## 作者：遥遥领先 (赞：0)

# 题解：P10723 [GESP202406 七级] 黑白翻转

题意：给你一棵有白色和黑色结点的树，求最少将多少白色结点转成黑色结点才能使剩下的黑色结点能组成一棵树。

思路：相当于让你把所有黑色结点都连起来，多以可以先预处理出每个结点子树的黑色结点个数，然后随便 dfs 一个黑色节点，一一遍历子结点的子树是否有黑色结点，如果有，就可以往下搜，边搜边记录答案。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;
int n,a[N],ans,sz[N],vis[N],pos;
vector <int> v[N];

int dfs(int u)
{
	if (vis[u])
		return 0;
	vis[u] = 1;
	int sum = a[u];
	for (int i = 0;i < v[u].size();i++)
		sum += dfs(v[u][i]);
	return sz[u] = sum;
}

void _dfs(int u)
{
	if (vis[u])
		return ;
	vis[u] = 1;
	if (a[u] == 0 && sz[u])
	{
		ans++;
		for (int i = 0;i < v[u].size();i++)
			_dfs(v[u][i]);
	}
	if (a[u] == 1 && sz[u] >= 2)
		for (int i = 0;i < v[u].size();i++)
			_dfs(v[u][i]);
}

void solve()
{
	int flag = 0;
	cin >> n;
	for (int i = 1;i <= n;i++)
		cin >> a[i],flag = (flag || a[i]);
	if (!flag)
	{
		cout << 0;
		return ;
	}
	for (int i = 1;i < n;i++)
	{
		int x,y;
		cin >> x >> y;
		v[x].push_back(y);
		v[y].push_back(x);
	}
	for (int i = 1;i <= n;i++)
		if (a[i])
			pos = i;
	dfs(pos);
	memset(vis,0,sizeof(vis));
	_dfs(pos);
	cout << ans;
}

signed main()
{
	solve();
	printf("\n");
	return 0;
}
```

---

## 作者：nightwatch.ryan (赞：0)

### 思路
考察深度优先搜索。

首先用链式前向星建个无向图，注意一定要建无向图。然后找一个黑点（随便哪个都行，只要是黑点就行）作为深度优先搜索的起点。如果当前遍历到的点是白点，但是这个点的孩子节点是黑点，那么就必须将当前遍历到的点染色成黑点，这样这个点的孩子节点才能和其他的黑点形成连通块。

最后输出将几个白点染成了黑点。
### 代码
```cpp
#include<iostream>
#define int long long
#define N 200005
int to[N],head[N],nxt[N],cnt;
int col[N],start,n,ans;
void add(int u,int v){
	cnt++;
	to[cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}
void dfs(int cur,int fa){
	for(int i=head[cur];i;i=nxt[i]){
		if(to[i]!=fa){
			dfs(to[i],cur);
			if(col[cur]==0){
				if(col[to[i]]==1){
					ans++;
					col[cur]=1;
				}
			}
		}
	}
}
signed main(){
	std::ios::sync_with_stdio(0);
	std::cin>>n;
	for(int i=1;i<=n;i++)std::cin>>col[i];
	for(int i=1;i<n;i++){
		int u,v;
		std::cin>>u>>v;
		add(u,v),add(v,u);
	}
	for(int i=1;i<=n;i++){
		if(col[i]==1){
			start=i;
		}
	}
	dfs(start,0);
	std::cout<<ans;
}
```

---

## 作者：Weekoder (赞：0)

### 题意

给定一棵树，每个点是白点或者黑点。要求通过将最少的点变为黑点后，所有黑点是否能形成一整个连通块。输出最少的操作次数。

### 思路

将题目进一步转化为：初始时，所有白点皆处于**未激活状态**，不能前往，而每次操作则可以激活一个点。问用最少多少次操作，才能使所有黑点连通。

设有 $tot$ 个黑点。我们知道连通是相互的，即 $i$ 连通 $j$ 必然代表 $j$ 连通 $i$。既然要让所有黑点连通，那可以这样理解：让第一个黑点与所有黑点连通即可，等价于让 $1$ 连通 $2$，$1$ 连通 $3$，$1$ 连通 $4$，......，$1$ 连通 $tot$。那问题也就迎刃而解了，由于树上每个点之间的路径都是唯一且最短的，所以连通 $i$ 和 $j$ 只需要激活 $i$ 到 $j$ 上的简单路径上的所有点就可以了。标记点可以使用 LCA $+$ 差分。不能直接统计 $1$ 到 $i$ 的路径长度，因为会有重叠！

代码：

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 1e5 + 5;

int n, diff[N], deep[N], dp[N][30], ans;

bool vis[N];

vector<int> nbr[N], blck;

void pre_lca(int cur, int fa) {
    deep[cur] = deep[fa] + 1;
    dp[cur][0] = fa;
    for (int j = 1; (1 << j) <= deep[cur]; j++)
        dp[cur][j] = dp[dp[cur][j - 1]][j - 1];
    for (auto nxt : nbr[cur]) if (nxt != fa) {
        pre_lca(nxt, cur);
    } 
}

int lca(int x, int y) {
    if (deep[x] > deep[y])
        swap(x, y);
    for (int i = 20; i >= 0; i--) if (deep[dp[y][i]] >= deep[x]) {
        y = dp[y][i];
    }
    if (x == y)
        return x;
    for (int i = 20; i >= 0; i--) if (dp[x][i] != dp[y][i]) {
        x = dp[x][i], y = dp[y][i];
    }
    return dp[x][0];
}

void get_sum(int cur, int fa) {
    for (auto nxt : nbr[cur]) if (nxt != fa) {
        get_sum(nxt, cur);
        diff[cur] += diff[nxt];
    }
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
    cin >> n;
    for (int i = 1, a; i <= n; i++) {
        cin >> a;
        if (a) blck.emplace_back(i), vis[i] = 1;
    }
    for (int i = 1, u, v; i < n; i++) {
        cin >> u >> v;
        nbr[u].emplace_back(v);
        nbr[v].emplace_back(u);
    }
    if (blck.size() <= 1) return cout << 0, 0;
    pre_lca(1, 0);
    for (int i = 1; i < blck.size(); i++) {
        diff[blck[0]]++, diff[blck[i]]++;
        int LCA = lca(blck[0], blck[i]);
        diff[LCA]--, diff[dp[LCA][0]]--;
    }
    get_sum(1, 0);
    for (int i = 1; i <= n; i++)
        ans += !vis[i] && diff[i];
    cout << ans;
	return 0;
}
```

---

## 作者：Dechancer (赞：0)

### 题意：
题意非常简洁，求一颗只有黑白节点的树上，删除所有白色节点后，剩下的黑色节点仍然为一棵树的最少操作次数。每次操作可以使一个白色节点变为黑色节点。
### 性质：
- 任意两个黑色节点路径上的白色节点都是不能删除的。

### 为什么？
- 树上任意两点的路径是唯一的，删除了该路径上任意一个节点都会破坏这两点的连通性。而题目要求删除树上所有白色节点后，剩下的黑色节点仍然是一棵树，这就要求所有黑色节点连通，所以性质得证。

### 代码逻辑：
- 先初始化操作次数为白色节点数，用 vector 模拟邻接表存图，然后随便找一个黑色节点开始树形 dp 。当要搜索的子树内不存在黑色节点，显然可以直接将这个白色子树删除来减少操作次数，否则继续往该子树递归搜索。
- 为什么要选择黑色节点作为根呢？因为采用白色节点为根时，当前的白色节点显然是可以删除的，但是按照上述代码逻辑无法删除该点。
- 时间复杂度：$O(n)$

**代码中你可能不知道的 c++ 内容：**
- c++17
   - 推导指引
- c++14
	- 泛型 lambda
- c++11
	- lambda 表达式
   - find_if()，STL 中的算法
   - 基于范围的 for 循环

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n;
  cin >> n;

  vector color(n, 0);
  for (auto& i : color) {
    cin >> i;
  }

  // 点下标从0开始
  vector adj(n, vector(0, 0));
  for (int i = 1, u, v; i < n; i++) {
    cin >> u >> v;
    u--, v--;
    adj[u].push_back(v);
    adj[v].push_back(u);
  }
	
  // 寻找一个黑色节点作为根
  int root =
      find_if(color.begin(), color.end(), [&](int x) { return x == 1; }) -
      color.begin();
	
  // root == n表示没有黑色节点，那么把整颗树删除
  if (root == n) {
    cout << 0;
    return 0;
  }

  // sz表示子树大小，black表示子树内黑色节点个数
  vector sz(n, 0), black(n, 0);
  auto dfs = [&](auto&& self, int u, int fa) -> void {
    sz[u] = 1;
    black[u] = color[u];
    for (auto& v : adj[u]) {
      if (v == fa) {
        continue;
      }
      self(self, v, u);
      sz[u] += sz[v];
      black[u] += black[v];
    }
  };
  dfs(dfs, root, -1);

  // 第二次dfs开始统计答案
  int ans = n - black[root];
  auto dfs1 = [&](auto&& self, int u, int fa) -> void {
    for (auto& v : adj[u]) {
      if (v == fa) {
        continue;
      }
      if (black[v] == 0) {
        ans -= sz[v];
      } else {
        self(self, v, u);
      }
    }
  };
  dfs1(dfs1, root, -1);

  cout << ans;

  return 0;
}
```

---


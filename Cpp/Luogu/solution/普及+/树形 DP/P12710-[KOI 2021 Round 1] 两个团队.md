# [KOI 2021 Round 1] 两个团队

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

某公司的组织架构可以用一棵有根树（rooted tree）来表示。树中的每个节点表示一名员工，边表示直属上下级关系。每位员工从 $1$ 到 $N$ 编号，其中编号 $1$ 的员工是公司的总裁，即树的根节点。每位员工都有一个整数形式的“能力值”，该能力值可能为负数。

下面是一棵示意组织树的例子，节点内的数字表示员工编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/yblc9z43.png)

现在希望从中选择若干人担任“团队负责人”。每位团队负责人必须组成自己的团队，团队必须满足以下条件：

1. 团队成员必须是该负责人下属员工（不一定是直属下属）。例如，如果员工 $3$ 是负责人，那么员工 $8$ 或 $11$ 可以是团队成员，但员工 $1$ 或 $9$ 不可以。
2. 如果某员工被包含为团队成员，那么该员工的直属上司也必须被包含为团队成员（负责人除外）。例如，若员工 $3$ 是负责人，则团队为 $\{3, 6, 11\}$ 是合法的，但 $\{3, 8, 11\}$ 是不合法的，因为员工 $11$ 的上司 $6$ 没有被包含。
3. 团队的得分定义为团队负责人及所有成员的能力值总和，团队成员的选择必须使团队得分最大。（若得分最大的团队组成不唯一，可任选其一。）例如，在所有员工的能力值均为正的情况下，若员工 $3$ 被选为负责人，则其团队必须为 $\{3, 6, 7, 8, 11, 12\}$，其中任何一人缺席都不被允许。
4. 员工不能同时属于两个团队（包括不能作为另一个团队的负责人）。也就是说，若某员工 $A$ 是负责人，其下属 $B$ 由于第 3 条必须包含进 $A$ 的团队，则 $A$ 和 $B$ 都不能被选为负责人。

公司最终希望选出两名团队负责人，组成两个团队，使这两个团队的得分总和（即所有成员能力值之和的总和）最大。

请你编写一个程序，计算在满足所有约束条件的前提下，这两个团队得分之和的最大值。

输入保证一定存在合法的两个团队的构成方式。

## 说明/提示

**约束条件**

- $2 \leq N \leq 200\,000$
- 每名员工的能力值在 $-1\,000\,000\,000$ 到 $1\,000\,000\,000$ 之间
- 除员工 $1$ 外的每位员工 $i$ 的直属上司编号不超过 $i - 1$
- 输入保证一定可以构成符合要求的两个团队

**子任务**

1. （17 分）所有员工的能力值均为正数  
2. （12 分）$N \leq 5\,000$，且员工 $i$ 的直属上司为 $i - 1$（员工 $1$ 除外）  
3. （20 分）员工 $i$ 的直属上司为 $i - 1$（员工 $1$ 除外）  
4. （16 分）$N \leq 400$  
5. （17 分）$N \leq 5\,000$  
6. （18 分）无附加约束条件

## 样例 #1

### 输入

```
4
3 -1
-2 1
2 2
-1 1```

### 输出

```
5```

# 题解

## 作者：sLMxf (赞：1)

这不是奶龙都会的题目吗。
# P12710 [KOI 2021 Round 1] 两个团队
## 简述题意
请选择两个连通块，连通块需要满足：
- 一定在一颗子树内，且根必须选择。
- 是联通块。（？）
- 连通块权值之和需要尽量大。
- 任意一个点不能两个联通块中。

请输出最大的权值之和。
## 算法分析
显然的树形 DP。

一颗子树内的答案，要么是选择根往下的一个连通块和一个不与上述连通块相交的连通块，要么选择两棵子树的最优。

维护这些值。定义 $maxk$ 表示连通块中最大的一块连通块（符合上述定义，下同），$f$ 表示选根的最优解，$g$ 表示不选根且不被 $f$ 所在连通块包含的连通块。那么这颗子树的答案为：

$$\max\{f_i+g_i,maxk_{v_1}+maxk_{v_2}\}\{v_1,v_2\in son_x,v1\ne v2\}$$

那么不难得到三个东西的转移：

- 当 $f_v> 0$ 时：
  - $f_x\gets f_x+f_v$。
  - $g_x\gets \max(g_x,g_v)$。
- 否则：
  - $f_x\gets f_x$。
  - $g_x\gets \max(g_x,maxk_v)$。
- $maxk_x=\max(f_x,maxk_v)(v\in son_x)$。

然后这道题做完了。

时间复杂度 $O(n)$。
## 代码实现
:::success[AC code]
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int inf=100000000000000000;
int w[200005],max_k[200005],f[200005],g[200005],ans=-inf;
vector<int>G[200005];
void dfs(int x)
{
	int maxx=-inf,cmax=-inf;
	g[x]=max_k[x]=-inf;f[x]=w[x];
	for(auto v:G[x])
	{
		dfs(v);
		if(f[v]>0) f[x]+=f[v],g[x]=max(g[x],g[v]);
		else g[x]=max(g[x],max_k[v]);
		max_k[x]=max(max_k[x],max_k[v]);
		if(max_k[v]>=maxx) cmax=maxx,maxx=max_k[v];
		else if(max_k[v]>=cmax) cmax=max_k[v];
	}
	max_k[x]=max(max_k[x],f[x]);
	ans=max(ans,max(g[x]+f[x],maxx+cmax));
}
signed main()
{
	int n,fa;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>w[i]>>fa;
		if(i!=1) G[fa].push_back(i);
	}
	dfs(1);
	cout<<ans;
	return 0;
}
```
:::

---


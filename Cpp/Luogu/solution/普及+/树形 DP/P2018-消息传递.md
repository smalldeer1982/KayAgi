# 消息传递

## 题目描述

巴蜀国的社会等级森严，除了国王之外，每个人均有且只有一个直接上级，当然国王没有上级。如果 $A$ 是 $B$ 的上级，$B$ 是 $C$ 的上级，那么 $A$ 就是 $C$ 的上级。绝对不会出现这样的关系：$A$ 是 $B$ 的上级，$B$ 也是 $A$ 的上级。

最开始的时刻是 $0$，你要做的就是用 $1$ 单位的时间把一个消息告诉某一个人，让他们自行散布消息。在任意一个时间单位中，任何一个已经接到消息的人，都可以把消息告诉他的一个直接上级或者直接下属。

现在，你想知道：

1. 到底需要多长时间，消息才能传遍整个巴蜀国的所有人？
2. 要使消息在传递过程中消耗的时间最短，可供选择的人有那些？


## 样例 #1

### 输入

```
8
1
1
3
4
4
4
3```

### 输出

```
5
3 4 5 6 7```

# 题解

## 作者：zzw4257 (赞：27)

这里主要介绍一个$O(n\log_2n)$的算法

虽然对于这道题$O(n^2\log_2n)$暴力枚举根已经可以$AC$了，但**优化是无止境的**

首先可以想出这道题对于一个确定的根的$dp$

再以任意点$root$为主根前提下

我们设$f_{i}$表示以$i$为根**不计算根被传递到消息时间,把消息传到$i$为根的子树**的最短时间

当$i$的子树均被计算完毕时

$\displaystyle{f_i=\max_{j\in son_i}}\{f_j+order_j\}$

其中$order_j$表示$j$是$i$的孩子中第$order_j$个选的，也就是他在$i$收到消息后第$order_j$个时间收到消息的

很容易想到贪心，我们让$f_j$值大的先传

单次复杂度$O(n\log_2n)$

但这样做需要枚举根，最终复杂度$O(n^2\log_2n)$

瓶颈在于什么,仔细思考我们会发现其实是**我们确定了向“下”传的顺序，而因此很多子树的信息在不同的根下实际上是一样的**

什么意思，我们看一下这幅图

![graph.png](https://i.loli.net/2019/08/22/uhWxZiXpgz7VFeD.png)

在$fa$,$i$,$brother1$,$brother2$作根的时候,以$j$为根的子树的形态没有一点改变

我们有没有办法一次计算这些信息呢

有的，那就是所谓的**二次扫描与换根法**

在李煜东的书里介绍了这个算法并给出了一个例题，但这个例题会更为复杂一些

我先重复一下这个算法流程
- 一次**树形dp**,求出每个点以$root$为根的子树中信息$down$
- 一次**DFS**求出每个点以$root$为根来自父亲的信息$up$,同时合并$up$和$down$

我们用这道题来看如何实现

对于$down$部分是类似的

设$down_{i}$表示**不计算根被传递到消息时间,把消息传到$i$为根的子树**的最短时间

我们在计算完了$i$的儿子$j$后来更新$i$

$\displaystyle{down_i=\max_{j\in son_i}}\{down_j+order_j\}$

$order$可以直接通过排序得到

```cpp
inline void tree_dp(re int x){
	re int i,y,res=0;re vector<int> son;
	for(i=h[x];i;i=e[i].next){
		y=e[i].to;
		tree_dp(y);
		son.push_back(dpson[y]);
	}
	sort(son.begin(),son.end(),cmp);
	for(i=0;i<(int)son.size();++i)res=max(res,son[i]+i+1);
	dpson[x]=res;
}
```

而对于$up$部分

设$up_{i}$表示**不计算根被传递到消息时间,把消息传到除了$i$为根的子树的节点**的最短时间

可能很难理解，我们用一张图来展示

![upanddown.png](https://i.loli.net/2019/08/22/GOwKhgEe9qmdTya.png)

可以形象的理解为$down$对应的部分是在有根情况下向“下”的很多支子树,而$up$对应的部分是向“上”的那一支

我们在计算完了$j$的父亲$i$后来更新$j$

$\displaystyle{up_j=\max\{up_i+order'_i~,\max_{k\in son_i\vee k\ne j}}~\{down_k~+~order'_k\}~\}$

用这幅图理解一下,$up_j$保存的是来自父亲$i$的一支,其中包含了他父亲的父亲那一支$up_j$,也包含了$i$的父亲除了$i$的其他儿子支

![upandup.png](https://i.loli.net/2019/08/22/RVHoL4eAlr9PSz3.png)

注意一下:为了处理方便，我们并不一开始显式去掉$i$的儿子$j$,而是吧$down_k$和$up_i$加进去排序,在需要求出$up_j$时我们二分查找$j$的位置,并把这个位置后面的位置的$order$值减一，因为我们在我们一开始的假设中，选$j$实际上是花了一个时间的，但实际并没有.实际操作上可以利用前缀和后缀$\max$来实现

```
inline void change_root(re int x){
	re int i,y,pos;re vector<int> son;
	for(i=h[x];i;i=e[i].next){y=e[i].to;son.push_back(dpson[y]);}if(fa[x])son.push_back(dpfa[x]);
	sort(son.begin(),son.end(),cmp);
	for(i=0;i<(int)son.size();++i)t[i]=son[i]+i+1;
	*maxl=t[0];for(i=1;i<(int)son.size();++i)maxl[i]=max(maxl[i-1],t[i]);
	maxr[son.size()-1]=t[son.size()-1];for(i=son.size()-2;i>=0;--i)maxr[i]=max(maxr[i+1],t[i]);
	reverse(son.begin(),son.end());
	for(i=h[x];i;i=e[i].next){
		y=e[i].to;
		pos=lower_bound(son.begin(),son.end(),dpson[y])-son.begin();pos=son.size()-pos-1;
		if(!pos)dpfa[y]=max(0,maxr[1]-1);
		else if(pos==(int)son.size()-1)dpfa[y]=max(0,maxl[pos-1]);
		dpfa[y]=max(maxl[pos-1],maxr[pos+1]-1); 
	}
	dp[x]=maxl[son.size()-1];for(i=h[x];i;i=e[i].next){y=e[i].to;change_root(y);} 
}
```



其他细节比如边界什么的需要做了才知道

```cpp
#include<bits/stdc++.h>
#define N 200005
#define re register
#define INF 0x3f3f3f3f
using namespace std;
struct read{
	char buf[1<<25],*opt;
	read():opt(buf){buf[fread(buf,1,sizeof buf,stdin)]=0;}
	template<typename _int>
	operator _int(){
		_int res=0,flag=1;
		while(*opt<48&&*opt!='-')++opt;
		if(*opt=='-'){flag=-1;++opt;}
		while(*opt>32)res=(res<<1)+(res<<3)+(*opt++)-48;
		return res*flag;
	}
}it;
inline char cmp(re int x,re int y){return y<x;}
struct Edge{int to,next;}e[N<<1];
int n,cnt,h[N],t[N],dpson[N],dpfa[N],maxl[N],maxr[N],fa[N],dp[N],ans=INF,Ans[N];
inline void AddEdge(re int x,re int y){e[++cnt]=(Edge){y,h[x]};h[x]=cnt;}
inline void tree_dp(re int x){
	re int i,y,res=0;re vector<int> son;
	for(i=h[x];i;i=e[i].next){
		y=e[i].to;
		tree_dp(y);
		son.push_back(dpson[y]);
	}
	sort(son.begin(),son.end(),cmp);
	for(i=0;i<(int)son.size();++i)res=max(res,son[i]+i+1);
	dpson[x]=res;
}
inline void change_root(re int x){
	re int i,y,pos;re vector<int> son;
	for(i=h[x];i;i=e[i].next){y=e[i].to;son.push_back(dpson[y]);}if(fa[x])son.push_back(dpfa[x]);
	sort(son.begin(),son.end(),cmp);
	for(i=0;i<(int)son.size();++i)t[i]=son[i]+i+1;
	*maxl=t[0];for(i=1;i<(int)son.size();++i)maxl[i]=max(maxl[i-1],t[i]);
	maxr[son.size()-1]=t[son.size()-1];for(i=son.size()-2;i>=0;--i)maxr[i]=max(maxr[i+1],t[i]);
	reverse(son.begin(),son.end());
	for(i=h[x];i;i=e[i].next){
		y=e[i].to;
		pos=lower_bound(son.begin(),son.end(),dpson[y])-son.begin();pos=son.size()-pos-1;
		if(!pos)dpfa[y]=max(0,maxr[1]-1);
		else if(pos==(int)son.size()-1)dpfa[y]=max(0,maxl[pos-1]);
		else dpfa[y]=max(maxl[pos-1],maxr[pos+1]-1); 
	}
	dp[x]=maxl[son.size()-1];for(i=h[x];i;i=e[i].next){y=e[i].to;change_root(y);} 
}
int main(void){
	n=it;
	re int i;
	for(i=2;i<=n;++i){fa[i]=it;AddEdge(fa[i],i);}
	tree_dp(1);change_root(1);
	for(i=1;i<=n;++i)if(dp[i]<ans){ans=dp[i];Ans[*Ans=1]=i;}else if(ans==dp[i])Ans[++*Ans]=i;
	printf("%d\n",ans+1);
	for(i=1;i<=*Ans;++i)printf("%d ",Ans[i]);
	return 0;
}
```

---

## 作者：素质玩家孙1超 (赞：25)

这是一篇复杂度优秀的做法，随手一交 rank3 ，并且代码更加简洁易懂。

---

题目：[消息传递](https://www.luogu.com.cn/problem/P2018) 。

首先看到题目不难想到直接枚举每一个点作为根进行DP，方程如下

$$ f_i = \max _{j \in son_i} {\{f_j + order_j\}} $$ 


其中 $order $ 表示选择的顺序为 $1,2,3,4......$ 。

在此直接贪心让最大的 $f_j$ 匹配最小的 $order_j$ 即可。

这样直接做树形DP时间复杂度是 $O(n^2 \log  \ n ) $ 的，但并不是本题的最优解。（当然应为本题的 $n \leq 1000$，这样的算法可以通过）。

---

考虑如何优化：

我们若仔细思考上面的DP过程不难发现：若对于 $a \not= b$ 有 $a$ 做根和 $b$ 做根时的 $son_x $ 相同 ，那么我们就可以直接拿第一次计算出来的 $f_x$ 直接作为返回值，这样就可以减少许多运算量。

具体化上面的过程：对于每个相同的 $son_x$ 他们都会对应相同的 $father_x$ ，可以用 $dp[x][father_x]$ 纪录答案， 这样记忆化搜索就完成了。

但是空间复杂度不够优，我们把 $dp[x][father_x] $ 用 $father_x$ 连向 $x$ 的单向边代替，这样空间只要开 $O(n)$ 即可。

来**大致**算一下这样的时间复杂度：

第一次DP时可以把 $n-1$ 条边的DP值纪录，显然一次DP的复杂度是 $O(n \log n)$ ，然而我们只有 $2n-2$ 条单向变，所以总时间大概相当于两次的第一次DP，复杂度仍然是 $O(n \log n)$。

---

我自认为我的代码比一些题解写的简洁清晰，当然速度也可以：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int Maxn=1e3+5;
inline int max(int a,int b){return a>b?a:b;}
inline int R()
{
    char c;int res,sign=1;
    while((c=getchar())>'9'||c<'0') if(c=='-') sign=-1;res=c-'0';
    while((c=getchar())>='0'&&c<='9') res=res*10+c-'0';
    return res*sign;
}
int n,m,First[Maxn],to[Maxn*2],Next[Maxn*2],dp[Maxn*2],cnt,ans[Maxn],M=1<<30,num;
inline void add(int z,int y)
{
    Next[++cnt]=First[z];
    First[z]=cnt;
    to[cnt]=y;
}
int dfs(int pos,int father ,int fr)
{
    if(fr&&dp[fr]) return dp[fr];
    int res=0;
    priority_queue<int>q;
    for(int k=First[pos];k;k=Next[k])
    {
        if(to[k]==father) continue;
        q.push(dfs(to[k],pos,k));
    }
    for(int i=1;!q.empty();i++,q.pop())
    res=max(res,q.top()+i);
    return dp[fr]=res;
}
int main()
{
    n=R();
    int x;
    for(int i=2;i<=n;i++)
    {
        x=R();
        add(i,x);
        add(x,i);
    }
    for(int i=1;i<=n;i++)
    {
        ans[i]=dfs(i,0,0);
        if(ans[i]<M)
            M=ans[i];
    }
    printf("%d\n",M);
    for(int i=1;i<=n;i++)
    if(ans[i]==M) printf("%d ",i);
    return 0;
}
```



---

## 作者：刘备 (赞：14)

人生第一次靠自己拿到最优解（估计只是暂时的）
其实这一题有一个简单而高效的优化貌似已有题解没有提到。**我这篇题解主要是讲这个优化**，至于核心思路则和已有题解大同小异。可以参考其他优秀题解，我就不做赘述了，**请务必理解了标准算法后再看此题解**

进入正题，我们先看看普通的做法，开一个一维dp数组，枚举根节点，然后对于每个根节点通过dp求当前节点为出发点时传播完成的最小值,每次出发点即根节点转移时都将dp数组清零重新开始。但其实每次以根节点计算后的一些计算结果对之后的运算是有帮助的，我们要做的就是把这些结果利用起来，这里就要运用记忆化搜索的思想了。

如何利用？

拿出草稿纸，画一棵树如下：
1->2,3; 2->4,5; 3->6

这是把1当成根的情况，再画一棵树：
3->1,6; 1->2; 2->4,5

显然这是同一棵树，只是根不同，在常规解法中的作用是分别求出从1和3出发的最小值，但我们发现，在这两棵树中，dp[2]相等，因为他们都表示同一颗子树，体现在这两棵树中2的父亲都是1，这就是突破口。

我们把状态加一维，变成dp[i][fa] (空间换时间，血赚不亏)，表示以i节点为根的子树遍历完成的最小值，而fa值是根节点i的父亲，（若i是整棵树的根，那么fa=0），那么这样在以不同根节点遍历树的时候，若以节点i为根的子树与之前计算过的以i为根节点的子树相同，即i的父亲相同，就可以直接调用。

用文字描述的确抽象，看代码吧，如果你理解了常规解法想必你可以轻易看懂:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int fst[N],nxt[N*2],u[N*2],v[N*2];
int n,cnt;
int dp[N][N];
inline int read() {
    int ans=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-') f=-1; ch=getchar();}
    while(isdigit(ch)) {ans=ans*10+ch-48; ch=getchar();}
    return ans*f;
}
void add(int uu,int vv) {
    u[++cnt]=uu; v[cnt]=vv;
    nxt[cnt]=fst[uu];
    fst[uu]=cnt;
}
int dfs(int uu,int fa) {
    if(dp[uu][fa]) return dp[uu][fa];//优化的核心
    int gg=0,a[N];
    for(int k=fst[uu];k;k=nxt[k]) {		
        if(v[k]==fa) continue;
        a[++gg]=dfs(v[k],uu);
    }
    if(gg) {
        sort(a+1,a+1+gg);
        for(int i=1;i<=gg;i++) dp[uu][fa]=max(dp[uu][fa],a[i]+gg-i+1);
    } else dp[uu][fa]=1;
    return dp[uu][fa];
}
int main() {
    n=read();
    for(int i=2;i<=n;i++) {
        int uu=read();
        add(uu,i); add(i,uu);
    }
    int ans=INT_MAX;
    for(int i=1;i<=n;i++) ans=min(ans,dfs(i,0));
    printf("%d\n",ans);
    for(int i=1;i<=n;i++) if(dp[i][0]==ans) printf("%d ",i);
    return 0;
}
```



---

## 作者：ww3113306 (赞：11)


突然觉得以前写的可能有点不太清晰，修改一下。

可以发现选了一个点作为根之后，所有剩下的节点都相当于它的儿子。因为上属和下属没有本质区别，只是限制了这是一棵树而已。所以相当于每个点只能向下传递消息。

由于n很小，我们可以枚举每一个点作为第一个节点，计算其时间花费

那么问题就转化为对于给点节点求花费时间。

我们设f[x]表示当x这个节点得到消息后，还需要至少花费多少时间可以使得以x为root的子树全部得知消息。

通过观察，显然我们会发现先传给花费时间多的人(f[x]最大的人)更加合算，因为这样可以最大限度的避免一个人还在辛苦的传递信息，另一个人却悠闲的喝下午茶（雾）的局面

所以我们可以每次都记录下对于一个节点而言，它的所有子节点的时长，

并对其排序，排序后先传给耗时最多的人，但这样传递了之后，由于耗时最多的人最先被传递，

那么这个本应耗时最多的人就不一定还是耗时最多的人了，因此我们要分别计算所有子节点的耗时，并取max计入ans。

最后dp数组即代表一旦这个节点得知消息，要多久才可以把消息传给
所有其他的人（除了传给它的那个人）,即完成任务。树的结构保证了其正确性

why是ans=min(son[i]+cnt-i+1)?

因为这里为了方便是从小到大排序，又因为是优先大的

cnt-i即为还有多少个才能到它，然后+1是因为高斯这个点信息需要1的时间。

son[i]则是加上自身的时间
```cpp
#include<bits/stdc++.h>
using namespace std;
#define AC 1100
#define ACway 2500
#define R register int
#define D printf("line in %d\n",__LINE__);
/*非常妙的树形DP：由于n很小，我们可以枚举每一个点作为第一个节点，计算其时间花费
那么问题就转化为对于给点节点求花费时间。
通过观察，显然我们会发现先传给花费时间多的人更加合算，因为这样可以最大限度的避免
一个人还在辛苦的传递信息，另一个人却悠闲的喝下午茶（雾）的局面
所以我们可以每次都记录下对于一个节点而言，它的所有子节点的时长，
并对其排序，排序后先传给耗时最多的人，但这样传递了之后，由于耗时最多的人最先被传递，
那么这个本应耗时最多的人就不一定还是耗时最多的人了，因此我们要分别计算所有子节点
的耗时，并取max计入ans，最后dp数组即代表一旦这个节点得知消息，要多久才可以把消息传给
所有其他的人（除了传给它的那个人）,即完成任务。树的结构保证了其正确性
why是ans=min(son[i]+cnt-i+1)?
因为这里为了方便是从小到大排序，又因为是优先大的
cnt-i即为还有多少个才能到它，然后+1是因为高斯这个点信息需要1的时间。
son[i]则是加上自身的时间
*/
int n;
int Head[AC],Next[ACway],date[ACway],tot;
int ans[AC],minn=INT_MAX,f[AC];//use用来存储每个节点的儿子(DFS中临时存储)
inline int read()
{
    int x=0;char c;
    while(isspace(c=getchar()));
    while(c>='0' && c<='9')x=x*10+c-'0',c=getchar();
    return x;
}

inline void add(int f,int w)
{
    date[++tot]=w , Next[tot]=Head[f] , Head[f]=tot;
    date[++tot]=f , Next[tot]=Head[w] , Head[w]=tot; 
}	

void upmax(int &a,int b)
{
    if(b>a)a=b;
}

void upmin(int &a,int b)
{
    if(b<a)a=b;
}

void DFS(int x,int fa)
{
    R now;
    int cnt=0,son[AC];//开在DFS里面更加方便？
    for(R i=Head[x]; i ;i=Next[i])//枚举子节点
    {
        now=date[i];
        if(now!=fa)//如果不是父亲，即为儿子
        {
            DFS(now,x);
            son[++cnt]=f[now];
        }
    }
    sort(son+1,son+cnt+1);
    for(R i=1;i<=cnt;i++) upmax(f[x],son[i]+cnt-i+1);
}

void pre()
{
    R a;
    n=read();
    for(R i=2;i<=n;i++)
    {
        a=read();//读入i的上级
        add(a,i);
    }
}

void work()
{
    for(R i=1;i<n;i++)//枚举第一个节点
    {
        memset(f,0,sizeof(f));
        DFS(i,0);
        ans[i]=f[i];//ans[i]存以i为第一个节点的最小耗时
        upmin(minn,ans[i]);
    }
    printf("%d\n",minn+1);//还包括告诉别人的时间
    for(R i=1;i<=n;i++) 
        if(ans[i]==minn) printf("%d ",i);
}

int main()
{
//	freopen("in.in","r",stdin);
    pre();
    work();
//	fclose(stdin);
    return 0;
}

```


---

## 作者：real60t (赞：9)

#### 1.思路
 
 一道树形DP的题，我们通过枚举根结点求解。设 $f[i]$ 为以 $i$ 为根节点消息传播的最快时间。$f[i]$ 等于其子树消息传播的最快时间 $f[to]$ 加上节点 $i$ 把消息传到结点 $to$ 的用时 $d_{to}$ 的最大值。即：   
 $f[i]=\max(f[i],f[to]+d_{to})$   
 初始化： $f[k]=0$ ( $k$ 为叶节点）       
 每个结点每分钟只能传播一条消息，怎没安排结点 $i$ 给子结点传播的顺序呢？运用贪心的思想，先传播给传播时间多的子结点，在传播给传播时间少的子节点，以此来节约时间，求到最优解。   
 
 **注意：由于花了一分钟时间将消息传给根节点，所以最后答案要加 $1$ 。**
#### 2.代码
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int cnt,n,anst=0x7fffffff,f[1005],ans[1005],h[2005];
bool v[1005];
struct edge{int n,t;}e[2005];  //前向星 
void add(int x,int y) {
	e[++cnt].t=y;
	e[cnt].n=h[x];
	h[x]=cnt;
}
void dp(int x) {
	int d[1005]={0},y;
	v[x]=1;  //标记x已访问 
	for(int i=h[x];i;i=e[i].n) {
		y=e[i].t;
		if(!v[y]) {
			dp(y);  //计算子结点 
			d[++d[0]]=f[y];
		}
	}
	sort(d+1,d+d[0]+1);  
	//将x的子结点的传播时间从小到大排序 
	for(int i=1;i<=d[0];i++)f[x]=max(f[x],d[i]+d[0]-i+1);
} 
int main() {
	cin>>n;
	for(int i=2;i<=n;i++) {
		int x;
		cin>>x;
		add(i,x);
		add(x,i);
	}
	for(int i=1;i<=n;i++) {
		memset(f,0,sizeof(f));
		memset(v,0,sizeof(v));  //每次枚举初始化 
		dp(i);
		if(anst>f[i]) {
			anst=f[i];
			ans[0]=0;
			ans[++ans[0]]=i;  
		}else if(anst==f[i])ans[++ans[0]]=i;  
		//更新最快传播时间并记录根结点 
	}
	cout<<anst+1<<endl;  //答案要加1 
	for(int i=1;i<=ans[0];i++)cout<<ans[i]<<" ";
	return 0;
}
```


 

---

## 作者：greenheadstrange (赞：6)

##### 树形DP=dfs+dp=记忆化


思路：n次dfs，分别找从i开始传消息的结果，dfs时进行优化（主要用到了贪心的思想）


转移方程：dp[u]=max(dp[u],dp[v]+i-1)


下件代码：


```cpp
void dfs(int x,int fa){
	int p[3005];
	p[0]=0;
	for(int i=0;i<c[x].size();i++){
		if(c[x][i]==fa)continue;
		dfs(c[x][i],x);
		p[++p[0]]=f[c[x][i]];
	}
	sort(p+1,p+p[0]+1);
	for(int i=1;i<=p[0];i++)f[x]=max(f[x],p[i]+p[0]-i+1);
}
```
完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>c[3005];
int n,minn=0x7fffffff,f[3005],ans[3005];
void dfs(int x,int fa){
	int p[3005];
	p[0]=0;
	for(int i=0;i<c[x].size();i++){
		if(c[x][i]==fa)continue;
		dfs(c[x][i],x);
		p[++p[0]]=f[c[x][i]];
	}
	sort(p+1,p+p[0]+1);
	for(int i=1;i<=p[0];i++)f[x]=max(f[x],p[i]+p[0]-i+1);
}
int main(){
	scanf("%d",&n);
	int a;
	for(int i=2;i<=n;i++)scanf("%d",&a),c[a].push_back(i),c[i].push_back(a);
	for(int i=1;i<=n;i++){
		memset(f,0,sizeof(f));
		dfs(i,0);
		ans[i]=f[i];
		minn=min(minn,ans[i]);
	}
	printf("%d\n",minn+1);
	for(int i=1;i<=n;i++)if(ans[i]==minn)printf("%d ",i);
	return 0;
}
```

小贴士：数组p不能开成全局变量（10分透心凉），因为开成全局后下一次的dfs会影响结果。

---

## 作者：Prean (赞：5)

虽然这道题的数据只有1000，用枚举根节点的方式就可以做出来，但是，~~为了装X~~为了训练自己，枚举根节点的$O(n^2\log_2n)$我是不会满足的，我要尝试更快的方法。

所以，我们就不能枚举根节点，用树形DP去做。~~要你说！~~

那用树形DP该怎么做呢？首先对于一棵树的根节点，让他来传递消息的最短时间有多长呢？假设他的儿子分别是$ k_1 $，$ k_2 $，$ k_3 $……$ k_m $，然后我们根据贪心的原则，就可以让传递时间更长的节点先传，时间短的后传，转移方程就是
```cpp
f[i]=max(f[i],f[kj]+j);
```
其中，j是在所有儿子需要的的时间排序之后的下标。

该部分代码如下：
```cpp
inline void D1(int fa)
{
	if(!h[fa]){p[fa]=1;return;}int i;vector<int>a;
	for(i=h[fa];i;i=e[i].nx)D1(e[i].to),a.ph(f1[e[i].to]);
	f1[fa]=st(a);//这里的st函数放在最后在给大家，其实是因为我懒得多写几次
}
```
我们再回过头来想假如该点不是根节点的情况，就是说它多了一条爸爸的边。这时我们可以发现：我们可以直接把他爸爸当做儿子，然后像上面那样去推真正的$ f_i $。不过这棵树是有根树，并且明确了父子边，所以我们有两种选择：

1. 建边的时候建双边。

2. 计算的时候“屏蔽”掉本身的节点。

因为本人的习惯，使用的是第二种方法。该部分代码如下：
```cpp
inline void D2(int fa)
{
	int i;vector<int>a;
	if(fa!=1)//记得要特判，不然……不然也不会怎样的啦~
	{
		for(i=h[f[fa]];i;i=e[i].nx)if(e[i].to!=fa)
		a.ph(p[e[i].to]);a.ph(f2[f[fa]]);f2[fa]=st(a);
		a.clear();a.ph(f2[fa]);//记得清空，还要记得加入f2[fa]
	}for(i=h[fa];i;i=e[i].nx)D2(e[i].to),a.ph(f2[e[i].to]);
	f3[fa]=st(a);
}
```
最终代码如下：
```cpp
#define ph push_back//这个是因为push_back成员函数因为要多次使用，所以偷懒打了个宏定义，不然我也没办法压行
#include<algorithm>
#include<iostream>
#include<vector>
using namespace std;
int n,h[3005],f[3005],f1[3005],f2[3005],f3[3005];
inline bool cmp(const int&a,const int&b){return a>b;}
class Edge{public:int to,nx;}e[3000];
inline int st(vector<int>a)//st函数其实就是给在集合内的元素排序，然后就是转移方程
{
	int mx=0,i;sort(a.begin(),a.end(),cmp);
	for(i=0;i<a.size();++i)mx=max(mx,a[i]+i);return ++mx;
}
inline void D1(int fa)
{
	if(!h[fa]){f1[fa]=1;return;}//边界条件！一定要注意！
   int i;vector<int>a;
	for(i=h[fa];i;i=e[i].nx)D1(e[i].to),a.ph(f1[e[i].to]);
	f1[fa]=st(a);
}
inline void D2(int fa)
{
	int i;vector<int>a;
	if(fa!=1)
	{
		for(i=h[f[fa]];i;i=e[i].nx)if(e[i].to!=fa)
		a.ph(f1[e[i].to]);a.ph(f2[f[fa]]);f2[fa]=st(a);
		a.clear();a.ph(f2[fa]);
	}
	for(i=h[fa];i;i=e[i].nx)D2(e[i].to),a.ph(f1[e[i].to]);
	f3[fa]=st(a);
}
int main()
{
	int i=2;vector<int>a;
	cin>>n;
	for(;i<=n;++i)cin>>f[i],e[i-1]={i,h[f[i]]},h[f[i]]=i-1;
	D1(1);D2(1);a.ph(1);//第一个一定要先塞进去，不然的话会RE
	for(i=2;i<=n;++i)if(f3[i]<f3[a[0]])a.clear(),a.ph(i);
	else if(f3[i]==f3[a[0]])a.ph(i);//这里比较的部分一定要看懂
	sort(a.begin(),a.end());cout<<f3[a[0]]<<"\n";//其实我在打这段代码的时候因为把题看错了而误打成cout<<a.size();……
	for(i=0;i<a.size();++i)cout<<a[i]<<" ";
}
```

---

## 作者：abandentsky (赞：3)

感谢楼下大佬给的思路：（我是一台复读机，我来复述一下大佬的思想）。
题意：每个时刻可以选择一个与自己相邻的节点访问，现在问最开始选几号才能花费最小的时间。题目给的树是一棵无根树，每次可以直接访问上一级节点或者下一级节点。你把直接上一级和下一级放到无根树上，你就会发现什么上下级就不重要直接忽视了把。根节点root有三个孩子节点a,b,c;那么root节点该先传递给谁呢（因为题目要求每个时刻只能传递到相邻的一个节点）？当然是给花时间最多的孩子了。比如说a要全部访问完自己的子树需要a3个时间，b要8个，c要4个。肯定先给b传递啊。root何时访问完全部子节点是由子节点adc三者的最大值决定的。所以每一次我们给子节点排个序，由大到小。时间分配是一个单调增序列，子节点序列是一个非减序列。三个子节点，开始时间分别为1 2 3，那么他们各自的完成时间为1+8,2+4,3+3。root需要取得就是他们的最大值，就是1+8了。
答案输出的时候第一问要加1.（别问我为什么，我也不知道，再问就自杀。）
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 1005
#define mod 100000000
#define INF 0x3f3f3f3f
using namespace std;

int n;
vector<int> G[MAXN];
bool vis[MAXN];
int dp[MAXN];

bool cmp(int a,int b)
{
    return a>b;
}

int dfs(int root)
{
    vis[root]=true;
    int maxn=0;
    int Q[MAXN],cnt=0;                          //开一个队列进行排序
    for(int i=0;i<G[root].size();i++)
    {
        int v=G[root][i];
        if(vis[v])
            continue;
        Q[++cnt]=dfs(v);
    }
    if(cnt==0)
        return 0;
    sort(Q+1,Q+1+cnt,cmp);
    for(int i=1;i<=cnt;i++)
        maxn=max(maxn,Q[i]+i);            //我们先把消息传递给花费时间最多的人
    return maxn;                                     //我们发现时间序列是一个单调增序列，儿子节点信息排序后是非减序列，所以需要重新计算
}

void solve()
{
    int minn=INF;
    for(int i=1;i<=n;i++)
    {
        memset(vis,false,sizeof(vis));
        dp[i]=dfs(i);
        minn=min(minn,dp[i]);
    }
    printf("%d\n",minn+1);
    for(int i=1;i<=n;i++)
    {
        if(dp[i]==minn)
            printf("%d ",i);
    }
}

int main()
{
    scanf("%d",&n);
    int fa;
    for(int i=2;i<=n;i++)
    {
        scanf("%d",&fa);                      //i号节点的直接上级为fa，那么fa和i之间有一条边
        G[fa].push_back(i);
        G[i].push_back(fa);
    }
    solve();
    return 0;
}

```


---

## 作者：我没有小白 (赞：3)


安利一发自己博客，这里阅读体验更好
[博客传送门](https://www.cnblogs.com/ifmyt/p/9638724.html)

# 消息传递

## 解题思路
一开始怎么觉得那么难，后来稍微一问mjt大佬怎么那么简单？
意思就是你选一个人进行消息传递，然后求最少时间。

所以每个点都有当根节点的机会，遍历根节点。
然后就是儿子节点的问题了，然后就用到了贪心思想。
因为你要先告诉花费时间长的呗，然后再告诉时间短的。
然后就是很简单的树形dp了，转移方程$$dp[u]=max(dp[u],dp[v]+i-1)$$

## 代码
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

int n;
struct edge
{
    int next,to;
}e[2000];
int head[2000],tot,dp[2000],ins[2000];
void add(int x,int y){
    e[++tot].next = head[x];
    head[x] = tot;
    e[tot].to = y;
}
bool cmp(int x,int y){
    return x>y;
}
int minn=0x7fffffff,a[1001];
void dfs(int x,int f){
    int b[550] = {0},cnt = 0;
    for(int i=head[x];i;i=e[i].next){
        int v=e[i].to;
        if(v==f)continue;
        dfs(v,x);
        b[++cnt]=dp[v];
    }
    sort(b+1,b+1+cnt,cmp);
    for(int i=1;i<=cnt;i++)
        dp[x]=max(dp[x],b[i]+i-1);
    dp[x] += 1;
}
int main(){
    scanf("%d",&n);
    for(int i=2;i<=n;i++){
        int a;
        scanf("%d",&a);
        add(a,i);
        add(i,a);
    }
    for(int i=1;i<=n;i++){
        memset(dp,0,sizeof(dp));
        dfs(i,0);
        minn=min(minn,dp[i]);
        ins[i]=dp[i];
    }
    printf("%d\n",minn);
    for(int i=1;i<=n;i++)if(minn==ins[i])printf("%d ",i);
}
```

---

## 作者：Patrickpwq (赞：3)

由于根是不一定的 所以需要遍历所有点 作为根

设dp[i]是以i为根的子树传遍它所有子树需要的最少时间

dp[i]取决于花费时间最多的那颗子树（当然还要加上每次一秒的传递时间） 不过也不是一定的 万一话费时间最多的和次多(或者第三多 第四多....)的只差了一秒之类的情况也会出现 所以需要遍历所有的儿子~

方程：dp[i]=max{dp[i.son]+i.son.number(传递时间)}
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3005;
int n,tot,first[N],dp[N],son[N],cnt,ans=0,num;
struct Edge
{
	int to,next;
}edge[N*10];
inline void addedge(int x,int y)
{
	tot++;
	edge[tot].to=y;
	edge[tot].next=first[x];
	first[x]=tot;
}
inline bool cmp(const int &a,const int &b)
{
	return a>b;
}
inline void dfs(int now,int fa)
{
	for(int u=first[now];u;u=edge[u].next)
	{
		int vis=edge[u].to;
		if(vis==fa)	continue;
		dfs(vis,now); 
	}
	int cnt=0;
	for(int u=first[now];u;u=edge[u].next)
	{
		int vis=edge[u].to;
		if(vis==fa)	continue;
		son[++cnt]=dp[vis];
	}
	sort(son+1,son+cnt+1);
	int ret=0;
	for(int i=1;i<=cnt;i++)
	{
		ret=max(ret,son[i]+cnt-i); 
	}
	dp[now]=ret+1;	//加1是因为仔细看了样例后发现默认时间是从一秒开始的orz 
}
vector <int> con;
int main()
{
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		int x;
		cin>>x;
		addedge(i,x);
		addedge(x,i);
	}
	for(int i=1;i<=n;i++)
	{
		dfs(i,0);
		int tmp=dp[i];
		if(!ans||tmp<ans)
		{
			ans=tmp;
			con.clear();
			con.push_back(i);
		} 
		else if(tmp==ans)	con.push_back(i);
	}
	cout<<ans<<endl;
	for(int i=0;i<con.size();i++)	cout<<con[i]<<" ";
	return 0;
}
```

---

## 作者：方方小逗逼 (赞：3)

p党；

为什么要树形dp，暴力模拟也可以过呀！


a数组--邻接表

b数组--储存从i开始扩散的解

d，e数组--给c数组排序用的

c数组--当前节点向其他节点扩散所得解

f函数--求当k节点由n节点扩散所得时，向下扩散的最优解


假定i为原点，调用f函数求解

每个点都有许多点要扩散，根据贪心的原则，优先向耗时更多的点先扩散，所以在函数中先求当前节点能扩散的各个节点向下扩散所需的时间，再推导当前节点向下扩散所需的时间



```cpp
uses math;
var
  a:array [0..1001,0..1001] of longint;
  b,d,e:array [0..1001] of longint;
  n,i,k,min:longint;
procedure p(l,r:longint);
var
  i,j,m,k:longint;
begin
  if l=r then exit;
  m:=(l+r) div 2;
  p(l,m);
  p(m+1,r);
  i:=l;
  j:=m+1;
  k:=l;
  while (i<=m)and(j<=r) do
    if d[i]<d[j] then
    begin
      e[k]:=d[i];
      inc(i);
      inc(k);
    end
      else
    begin
      e[k]:=d[j];
      inc(j);
      inc(k);
    end;
  while i<=m do
    begin
      e[k]:=d[i];
      inc(i);
      inc(k);
    end;
  while j<=r do
    begin
      e[k]:=d[j];
      inc(j);
      inc(k);
    end;
  for k:=l to r do d[k]:=e[k];
end;
function f(k,n:longint):longint;
var
  c:array [0..1001] of longint;
  i,j,l,r,m:longint;
begin
  if (n<>0)and(a[k,0]=1) then exit(1);
  l:=0;
  i:=0;
  for j:=1 to a[k,0] do
    if a[k,j]<>n then
    begin
      inc(i);
      c[i]:=f(a[k,j],k);
    end;
  for i:=1 to i do d[i]:=c[i];
  p(1,i);
  for j:=i downto 1 do
    if l<d[j]+i-j then l:=d[j]+i-j;
  f:=l+1;
end;
begin
  read(n);
  for i:=2 to n do
  begin
    read(k);
    inc(a[i,0]);
    a[i,a[i,0]]:=k;
    inc(a[k,0]);
    a[k,a[k,0]]:=i;
  end;
  min:=maxlongint div 3;
  for i:=1 to n do
  begin
    b[i]:=f(i,0);
    if min>b[i] then min:=b[i];
  end;
  writeln(min);
  for i:=1 to n do
    if b[i]=min then write(i,' ');
  close(input);
  close(output);
end.
代码较长，本人蒟蒻，神犇勿喷！！！
```

---

## 作者：panda_eater (赞：3)

树形dp

思路：枚举第一个放的位置，dfs递归处理出当前节点u的子节点v需要的传递时间，然后从大到小排序，对于传递时间长的节点，就先传递给它。



```cpp
//P2018 消息传递
#include<iostream>
#include<vector>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#define ll long long
#define fo(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
const int mxn=1005;
vector <int> f[mxn];
int n,x,mx=1e8;
int ans[mxn],dp[mxn],du[mxn];
inline void dfs(int u,int fa)
{
    if(fa && du[u]==1) 
      return;
    int tmp[mxn],cnt=0;
    for(int i=0;i<f[u].size();i++)
    {
        int v=f[u][i];
        if(v==fa) continue;
        dfs(v,u);
        tmp[++cnt]=dp[v];
    }
    sort(tmp+1,tmp+cnt+1);
    fo(i,1,cnt) dp[u]=max(dp[u],tmp[i]+cnt-i+1);
}
int main()
{
    scanf("%d",&n);
    fo(i,2,n)
    {
        scanf("%d",&x);
        f[x].push_back(i);
        f[i].push_back(x);
    }
    fo(i,1,n)
    {
        memset(dp,0,sizeof dp);
        dfs(i,0);
        ans[i]=dp[i];
        mx=min(mx,ans[i]);
    }
    printf("%d\n",mx+1);
    fo(i,1,n) if(ans[i]==mx) printf("%d ",i);
    printf("\n");
    return 0;
}
```

---

## 作者：Jayun (赞：1)

# 消息传递

## 链接：

[洛谷](https://www.luogu.com.cn/problem/P2018)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/15008540.html)

## 题目大意：

一个点在某一秒可向相邻节点扩散，问哪些节点开始扩散能最快多少秒将所有节点全部覆盖。

## 思路：

先想暴力，对于每个点求出 $f_i$ 表示从以 $i$ 为根的子树中扩散到 $i$，最长花费的时间。则有：

$$f_u=\max_{v\in\mathrm{son}(x)}\{f_v+\mathrm{order}_v\}$$

其中 $\mathrm{order}_v$ 表示 $u$ 扩散到 $v$ 的顺序，可以贪心排序求出。然后每个点都作为根算一遍，时间复杂度 $\mathcal{O}(n^2\log n)$。

但是如果暴力算法，很多状态都重复算了：

![](https://img2020.cnblogs.com/blog/1748322/202107/1748322-20210713212334207-1424913332.png)

如图，两个灰点作根，与深灰点的 $f_i$ 无关。

则设 $g_i$ 表示从以 $i$ 为根的子树**外**扩散到 $i$，最长花费的时间：

![](https://img2020.cnblogs.com/blog/1748322/202107/1748322-20210713211619371-203522207.png)

如图，黑框内则表示为灰点的 $g_i$。则有：

$$g_u=\max_{k=\mathrm{fa}(x)}(g_k+\mathrm{order}_k,\max_{v\in\mathrm{son}(k),v\ne u}\{f_v+\mathrm{order}_v\})$$

实现时建议由当前节点推出子节点的 $g_i$。

统计答案时就在排 $\mathrm{order}_i$ 时顺便找到最大的即可。


---

## 作者：loceaner (赞：1)

# 洛谷 P2018 消息传递

## 题目分析

> 贪心+树形DP

本来还以为要大费周折地换根，然后发现 $n$ 很小，可以直接 $O(n^2\log n)$ 枚举。

枚举每个节点作为根，用 $f_x$ 表示走完以 $x$ 为根的子树花费的最小时间。 

那么如何更新呢？这个时候就要用到贪心的思想了。假设我们现在已经知道了 $x$ 的儿子个数 $tot$ 以及所有儿子 $to$ 的 $f$ 值。那么 $x$ 必定要把信息传给每一个儿子，所以要尽量早地把信息传给 $f$ 值较大的儿子，因此要把所有儿子的 $f$ 值从小到大排序，并得出如下 DP 方程：

$$f_{x}=\max\limits_{i=1}^{tot}(f_{to}+i)$$

最后的答案需要加 $1$，因为最开始要花费 $1$ 的时间把消息传播到根节点。

计算出以每个点为根的答案之后取最小值，再扫描一遍找可以作为根的点即可。

## 特别注意

在更新当前节点时，需要记录所有儿子的 $f$ 值，如果要定义临时数组只能在函数内定义，因为在接下来的 dfs 过程中又用到了此数组，数组中的值会因此发生改变，所以不能在外面定义。

## 代码

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int A = 1e3 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

struct node { int to, nxt; } e[A << 1];
int n, ans[A], f[A], head[A], cnt = 0, res = inf; 

inline void add(int from, int to) {
  e[++cnt].to = to;
  e[cnt].nxt = head[from];
  head[from] = cnt;
}

bool cmp(int x, int y) {
  return x > y;
}

inline void dfs(int x, int fa) {
  int tot = 0, b[1000] = {0};
  
  for (int i = head[x]; i; i = e[i].nxt) {
    int to = e[i].to;
    if (to == fa) continue;
    dfs(to, x);
    b[++tot] = f[to];
  }
  sort(b + 1, b + 1 + tot, cmp);
  for (int i = 1; i <= tot; i++) 
    f[x] = max(f[x], b[i] + i);
}

int main() {
  n = read();
  for (int i = 2; i <= n; i++) {
    int x = read();
    add(x, i), add(i, x);
  }
  for (int i = 1; i <= n; i++) {
    memset(f, 0, sizeof(f));
    dfs(i, 0);
    res = min(f[i], res);
    ans[i] = f[i];
  }
  cout << res + 1 << '\n';
  for (int i = 1; i <= n; i++) 
    if (ans[i] == res) cout << i << " ";
  puts("");
  return 0;
}
```



---

## 作者：Boxxxxxx (赞：0)

[博客连接，给点点击量吧！！！](https://blog.csdn.net/qq_43804974/article/details/104336166)

首先，本做法和其他的O(N^2logn)做法是完全不一样的，那种做法比较好理解，我说一下我的做法，~~*感jio是O(Nlogn)，不太会算*~~ 

首先思考如何获得每一点要如何知道由当前点出发的答案是什么？对于绝大部分点，都有父亲节点和儿子节点，那么对于每一个点都是这么抉择走的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ukbu093u.png)

这里先不看now点，看节点1，如果第一个人从节点1开始要怎么走呢？就是花4次时间， 分别走4跳荧光笔的路径对吧，然后就没节点1什么事情了，接下来的路要靠其他点他们自己去走。

我们假设**f[i]为从i点开始往下走完所有节点的最短时间**，
**g[i]为从i点开始往上走完所有节点的最短时间**

那么对于上图而言，要获得节点1的答案就需要获取f数组和g数组。

现在我们考虑如何得出这两个东西。
先思考f[i]怎么获得，f[i]是往下走的所有节点的最短时间，那么对于每一个i节点，我们可以对他所有的儿子f[z]去进行排序！！

然后从f[z]比较大的这个儿子节点先走，在走其他的，从大到小走，为什么要这么走呢？这是用了个贪心的做法！！！

从一个点要走的步数多，那么你先走他就可以比较快的完成嘛，所以排个序后贪心的拿就好了，第一个拿的就加0，第二个拿的就加1（因为要多花额外的时间才能走这条路线是不是），。。。。。。

最后取一个max，一个点的完成的时间取决于最慢的那个时间。
f[i] = max(f[son] + v)

下一步是考虑g[i],思考一下g[i]怎么来的还是这个图
![](https://cdn.luogu.com.cn/upload/image_hosting/ukbu093u.png)

现在我们看now点，要算g[now]就是要算now点往上要多久才能覆盖全部，所以类比f数组的排序操作，我们需要对

1 - 2，1 - 3， 1 - 4

这些边进行排序，然后计算附加权值取max，这些都和f一样，只是不同的是1-now这条边的必定要先走，因为一个点只有一个父亲嘛.

你往上走就只会走这条路，然后走到now点的父亲节点就出现了分支，你就需要对这些分支去进行进行排序操作取max就可以得到g啦


在这个图里面，就是比较g[2], f[3],f[4]的大小，这些你看是不是我们在之前都算出来了呢。

最后答案什么算?列举f[i]和g[i]的行走顺序去得答案吗？
很遗憾我们不能简单粗暴的用这个，在代码里面也有注释说不能那么写。


这样就是对于先走下面全部走完在走上面或者先走上面在走下面，这样子会wa一个点（就是他数据水才AC这么多），你可能是先在下面走一两条边， 在走上面，在继续走下面， 所以还需要对于该点连着的所有边进行一次排序操作就可以了。


对于上面那个图，要算节点1，就是对g[2],f[3],f[now],f[4]去排序算权值就好了。


这样总来说是就是跑两遍dfs就可以出答案拉。感觉就是nlogn，如果不是请教我算~最后代码方面不开O2是跑了48ms，开了o2是跑了33ms

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const long long max_ = 5000 + 7;
int read() {
	int s = 0, f = 1;
	char ch = getchar();
	while (ch<'0' || ch>'9') {
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0'&&ch <= '9') {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s * f;
}
bool cmp(int a, int b) {
	return a > b;
}
int temp[max_], tn = 0, n, f[max_], g[max_], father[max_], value[max_];
vector<int> xian[max_];
void dfs(int now, int fa) {
	father[now] = fa;
	//算i往下需要多少才可以传递完所有人
	for (int i = 0; i < xian[now].size(); i++) {
		int to = xian[now][i];
		if (to == fa)continue;
		dfs(to, now);
	}
	tn = 0;
	for (int i = 0; i < xian[now].size(); i++) {
		int to = xian[now][i];
		if (to == fa)continue;
		temp[++tn] = f[to];
	}
	sort(temp + 1, temp + 1 + tn, cmp);
	int v = 0;
	for (int i = 1, j = 1; i <= tn; j++, i++) {
		v = max(v, temp[i] + j);
	}
	f[now] = v;
}
void dfs2(int now, int fa) {
	tn = 0;
	//首先花费1的价值到达父亲节点，然后判断从父亲节点往哪里走
	if (father[fa])
		temp[++tn] = g[fa];
	for (int i = 0; i < xian[fa].size(); i++) {
		int to = xian[fa][i];
		if (to == father[fa] || to == now)continue;
		temp[++tn] = f[to] + 1;
	}
	sort(temp + 1, temp + 1 + tn, cmp);
	int v = 0;
	for (int i = 1, j = 0; i <= tn; j++, i++) {
		v = max(v, temp[i] + j);
	}
	g[now] = v; if (now != 1)g[now]++;
	for (int i = 0; i < xian[now].size(); i++) {
		int to = xian[now][i];
		if (to == fa)continue;
		dfs2(to, now);
	}
}
int main() {
	n = read();
	for (int i = 2; i <= n; i++) {
		int a = read();
		xian[a].push_back(i);
		xian[i].push_back(a);
	}
	dfs(1, 0);
	dfs2(1, 0);
	int ans = f[1];
	value[1] = f[1];
	for (int i = 2; i <= n; i++) {
	/*	value[i] = max(max(f[i], g[i]), min(f[i], g[i]) + 1);这是错误的！！
		ans = min(ans, value[i]);*/
		tn = 0;
		temp[++tn] = g[i] - 1;
		for (int j = 0; j < xian[i].size(); j++) {
			int to = xian[i][j];
			if (to == father[i])continue;
			temp[++tn] = f[to];
		}
		sort(temp + 1, temp + 1 + tn, cmp);
		int v = 0;
		for (int x = 1, j = 1; x <= tn; j++, x++) {
			v = max(v, temp[x] + j);
		}
		value[i] = v;
		ans = min(ans, value[i]);
	}
	cout << ans + 1 << endl;
	for (int i = 1; i <= n; i++) {
		if (value[i] == ans) {
			cout << i << " ";
		}
	}
	
	return 0;
}
```


---

## 作者：Polaris_Dane (赞：0)

很基本的一道树形DP的模板题

只要对每个点记忆化搜索即可

搜完每个子节点，排序后，将要花时间最多的节点先运行

取最后运行时间的最大值

人傻常数大

跑了41ms

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<time.h>
#include<queue>
#include<stack>
#define M 10100
#define inf 0x3f3f3f3f
#define LL long long
using namespace std;
int n,dp[1100][1100],head[M],cnt,ans[M],minx=inf;
struct edge{
	int next,to;
}e[M];
void add(int a,int b)
{
	e[++cnt].next=head[a];
	e[cnt].to=b;
	head[a]=cnt;
}
int read()
{
	int f=1;char s=getchar();int x=0;
	while (!('0'<=s&&s<='9'))
	{
		if (s=='-')
			f=-1;
		s=getchar();
	}
	while ('0'<=s&&s<='9')
	{
		x=(x<<3)+(x<<1)+(s^48);
		s=getchar(); 
	}
	x*=f;
	return x;
}
void dfs(int now,int fa)
{
	int tmp[M],cnte=0,maxx=0;
	if(dp[now][fa])
	{
		return;
	}
	for (int i=head[now];i;i=e[i].next)
	{
		if (e[i].to==fa)
		{
			continue;
		}
		dfs(e[i].to,now);
		tmp[++cnte]=dp[e[i].to][now];
	}
	sort(tmp+1,tmp+cnte+1,greater<int>());
	for (int i=1;i<=cnte;i++)
	{
		tmp[i]+=i;
		maxx=max(maxx,tmp[i]);
	}
	dp[now][fa]=maxx;
}
int main()
{
	n=read();
	for (int i=2;i<=n;i++)
	{
		int r=read();
		add(i,r);
		add(r,i);
	}
	for (int i=1;i<=n;i++)
	{
		dfs(i,0);
		if (dp[i][0]<minx)
		{
			ans[0]=0;
			minx=dp[i][0];
		}
		if (minx==dp[i][0])
		{
			ans[++ans[0]]=i;
		}
	}
	printf("%d\n",minx+1);
	for (int i=1;i<=ans[0];i++)
	{
		printf("%d ",ans[i]);
	}
	return 0;
}
```


---


# [HAOI2009] 毛毛虫

## 题目背景

感谢由@ScanfN 提供的两组 hack 数据。

## 题目描述

对于一棵树，我们可以将某条链和与该链相连的边抽出来，看上去就象成一个毛毛虫，点数越多，毛毛虫就越大。例如下图左边的树（图 $1$）抽出一部分就变成了右边的一个毛毛虫了（图 $2$）。

![](https://cdn.luogu.com.cn/upload/pic/7967.png)


## 说明/提示

对于 $40\%$ 的数据，$1\leq N \le 50000$。

对于 $100\%$ 的数据，$1\leq N \le 300000$。

## 样例 #1

### 输入

```
13 12 
1 2 
1 5 
1 6 
3 2 
4 2 
5 7 
5 8 
7 9 
7 10 
7 11 
8 12 
8 13 ```

### 输出

```
11```

# 题解

## 作者：lgswdn_SA (赞：121)

近乎一年后的纠错：

感谢 @tommy0103 指出了本题解的一个小错误（

原本的代码在根节点时因为没有父亲节点所以原本的代码没法准确得到父亲节点的 cnt。然后现在改过来了。

---


树形 DP

记 $f_u$ 为在 $u$ 子树中，以 $u$ 为毛毛虫的头的最大毛毛虫。这是一个由下向上的树形 $dp$。

那么我们从叶节点看。

首先看叶节点（即最基础的状态）。

![image.png](https://i.loli.net/2020/05/05/uaA6eT8lJjYcbV1.png)

显然答案肯定为 $1$。

然后我们把一个向上推的过程看作毛毛虫增长的过程。最简单的比如只有一个节点，那么它这个毛毛虫与世无争，自己一个人在这里生长即可。

![image.png](https://i.loli.net/2020/05/05/pWq2mC8OGobnYhf.png)

如果不止这一个，那么这些生长的毛毛虫就需要面临残酷的竞争，选出一个儿子继续存活（成为这个子树的以 $u$ 为头的毛毛虫），其他儿子只能沦落成这个毛毛虫的脚。（绿色为原来的小毛毛虫加上父节点，黄色为新的脚。）

![image.png](https://i.loli.net/2020/05/05/sh7B1r4lmZ6SetW.png)

于是我们发现对于非叶节点的点，我们只要找到最大的子毛毛虫即可，然后再加上其他叶节点的个数。

$f_u=\max_{v\in son_u}{f_v+1}+(cnt_u-1)$，其中 $cnt$ 指儿子数量。

其实我们发现，如果我们的转移方程改为 $f_u=\max_{v\in son_u}{f_v+1}+\max(0,cnt_u-1)$，那么就不需要叶节点的特判。

~~但这真的是个很简单的转移方程。~~

但一条最大的毛毛虫可能是趴在一个节点上的，比如：

![image.png](https://i.loli.net/2020/05/05/Y1CyBIEXVljtJ4D.png)

但由于最多是两条链组成这样一个大的毛毛虫。所以我们~~乱搞一番~~计算答案时找出最大和次大，然后更新答案即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=300009;
vector<int>e[N];
int f[N],ans; 
void dfs(int u,int fa) {
	int mx0=0,mx1=0;
	for(int i=0,v;i<e[u].size();i++)
		if((v=e[u][i])!=fa){
			dfs(v,u);
			f[u]=max(f[u],f[v]);
			if(f[v]>mx0) mx1=mx0,mx0=f[v];
			else if(f[v]>mx1) mx1=f[v];
		}
	int cnt=e[u].size()-(fa!=-1);
	f[u]+=(1+max(0,cnt-1));
	ans=max(ans,mx0+mx1+1+max(0,cnt-1-(fa==-1)));
}
int main() {
	int n,m; scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++)
		scanf("%d%d",&u,&v),e[u].push_back(v),e[v].push_back(u);
	dfs(1,-1);
	printf("%d",ans);
	return 0;
}
```



---

## 作者：那一条变阻器 (赞：34)

一看这道题立马想到了树的直径

~~还没有两遍$dfs$求树的直径的做法，赶快来水一发~~

------------

### 已经会树的直径的大佬可以跳过这一段$qwq$

**树的直径：树上最长的一条链**

具体求法有两种，一种是树形$DP$，这里就不细讲了，我着重讲下两遍$dfs$求树的直径的做法，可以说很经典了。

**做法：** 先从任意一点出发，找到离出发点的最远点，然后再从找到的那个点出发，找一次最远点，这两点就是树的直径的两个端点。

------------

以下是证明（也不是必须会证明啦，不想看的$dalao$可以跳过）

$dis$的意思是两点直接的长度，图片中两点之间的长度是不确定的，比如$1$，$2$之间可能有多个节点，只是简洁点画

![](https://cdn.luogu.com.cn/upload/image_hosting/tv0ekb3y.png)

------------

接下来回到这道题，跟树的直径是不是就有点联系了，树的直径的$dfs$的时候每延申$1$个点，我们只需要加上$1$个长度，而这道题应该这样加：

假设我们$dfs$从$x$开始，那么我们一开始初始的总和为$dis[x]$（$dis$为这个点连到的所有点），设$nx$为$x$的儿子，那么往$nx$展的时候，应该加上$dis[nx]-2$，因为当搜到$nx$的时候，首先他自己这个点，已经被他的父亲$x$加过了，而且$nx$还连了一个$x$，$x$被父亲自己加过了，所以不需要再加了，所以减$2$

思路讲完了，下面是代码时间~

```cpp
#include <bits/stdc++.h>
using namespace std;
int n , m , ans1 , ans2 , maxx , tot , f = 0;	//ans1为第一次的最远点，ans2为第二次的最远点 
int dis[300010];
vector<int> e[300010]; 
stack<int> s;
void dfs1(int x , int sum , int fa){
	if(maxx < sum){
		maxx = sum;
		ans1 = x;
	}
	for(int i = 0; i < e[x].size(); i++){
		int nx = e[x][i];
		if(nx == fa) continue;
		dfs1(nx , sum + dis[nx] - 2 , x);
	}
} 
void dfs2(int x , int sum , int fa){
	if(tot < sum){
		ans2 = x;
		tot = sum;
	}
	for(int i = 0; i < e[x].size(); i++){
		int nx = e[x][i];
		if(nx == fa) continue;
		dfs2(nx , sum + dis[nx] - 2 , x);
	}
}
int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++) dis[i]++;	//自己也算连到了 
	for(int i = 1; i <= m; i++){
		int x , y;
		cin >> x >> y;
		e[x].push_back(y);
		e[y].push_back(x);
		dis[x]++;
		dis[y]++;
	}
	dfs1(1 , dis[1] , 0);
	dfs2(ans1 , dis[ans1] , 0);
	cout << tot;
	return 0;
}
```


---

## 作者：几何之舞丶 (赞：15)

#### 树上最长路径模板题

简单看了看题解,应该是没有和我做法一样的..

这里提供两种写法.

1:从节点的思路去考虑.

定义val[i]表示在以i为根的子树中最长链的长度,size[i]表示i这个节点的点权(即与i直接相连的点的个数)

每次更新时,先更新答案,再去更新val;主要锅点在代码中写明了.

```cpp
inline void dfs(int now ,int fa){
	val[now]=size[now];//初始化每个节点的最长链是自己 
	for(int i=head[now];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==fa)continue;
		dfs(v,now);
		ans=max(ans,val[now]+val[v]-1);// 注意除去重复计算. 
		val[now]=max(val[now],val[v]+size[now]-1);
	}
}
```

2:从LCA的角度去考虑,记录一个节点内的最长链和次长链.

考虑以点i作为两条链的交点来进行计算,分两种情况讨论,

1)答案在子树中,则答案为 最长链+次长链;

2)答案不在子树中,则子树对于答案的可能贡献为最长链.

详情见代码

```cpp
inline void dfs(int now ,int fa){
	int maxn=1;int minn=1;val[now]=1;
	for(int i=head[now];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==fa)continue;
		dfs(v,now);
		if(val[v]>maxn)
		minn=maxn,maxn=val[v];
		else
		if(val[v]>minn)
		minn=val[v];
		val[now]=max(val[now],val[v]+size[now]-1);
	}
	ans=max(ans,minn+maxn+size[now]-1);
}
```

这两种方法不仅仅可以用于本道题,在多数情况下求树上最长路径时都可以使用.

总代码如下:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<algorithm>
#define INF 0x7fffffff
#define inf 0x3f
#define int long long
#define ll long long
#define lson (now<<1)
#define rson (now<<1|1)
#define pii pair<int ,int >
#define pushup1(now)  tr[now].sum=(tr[lson].sum+tr[rson].sum);
#define pushup2(now)  tr[now].sq=(tr[lson].sq+tr[rson].sq);
using namespace std;
const int mod=1e9+7;
inline int read() {
	int now=0;
	char c=getchar();
	int f=1;
	while(c<'0'||c>'9') {
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		now=(now<<1)+(now<<3)+(c^48);
		c=getchar();
	} 
	return f*now;
}
const int N =300000+50; 
int n,m,ans,head[N],tot,size[N],val[N],son[N];
struct node{int v,next;}edge[N<<1];
inline void add(int x,int y){edge[++tot].next=head[x];edge[tot].v=y;head[x]=tot;size[y]++;} 
inline void dfs(int now ,int fa){
	val[now]=size[now];//初始化每个节点的最长链是自己 
	for(int i=head[now];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==fa)continue;
		dfs(v,now);
		ans=max(ans,val[now]+val[v]-1);// 注意除去重复计算. 
		val[now]=max(val[now],val[v]+size[now]-1);
	}
}
signed main(){
	n=read();m=read();
	for(int i=1;i<=m;i++){
		int x=read();int y=read();
		add(x,y);add(y,x);
	}
	dfs(1,-1);
	cout<<ans+1<<endl;
	return 0;
}
```

求过,谢谢!

---

## 作者：Wenoide (赞：12)

对任意一条链，「链上的节点」和「与该链**直接**相连且不在链上的节点」构成一条「毛毛虫」。求树上「毛毛虫」节点数的最大值。

------------

设树的根节点为 $1$。

$size(x)$ 表示以 $x$ 为根节点的**子树**中，以 $x$ 为一端的链所构成的「毛毛虫」节点数的最大值。（父节点不在「毛毛虫」上）

$deg(x)$ 表示 $x$ 节点的度。（包括父节点）

$i,j$ 为 $x$ 的子节点中，$size$ 值最大、次大的两个节点。（$size$ 值可能为 $0$，即 $x$ 没有更多子节点的情况）

------------

现计算 $size(x)$：

$$size(x)=
\begin{cases}
	1					&size(i)=0\bigwedge x\not=1		\\
	size(i)+deg(x)-1	&size(i)\not=0\bigwedge x\not=1	\\
	size(i)+deg(x)		&x=1							\\
\end{cases}
$$

- $size(i)=0$ 时，$x$ 没有子节点。显然 $size(x)=1$。

- 否则，$size(x)$ 应为子节点中最大的 $size(i)$ 加上 $deg(x)$ 与 $x$ 自身，再减去 $x$ 的父节点与被重复计算的 $i$ 节点。

- $x=1$ 时则无需减去不存在的父节点。

------------

现更新答案：

$$ans=\max(ans,
\begin{cases}
	deg(x)+1					&size(i)=0\bigwedge size(j)=0			\\
	size(i)+deg(x)				&size(i)\not=0\bigwedge size(j)=0		\\
	size(i)+size(j)+deg(x)-1	&size(i)\not=0\bigwedge size(j)\not=0	\\
\end{cases})
$$

- $size(i)=0\bigwedge size(j)=0$ 时，$x$ 没有子节点。其能贡献的答案为可能存在的父节点与 $x$ 自身。

- $size(i)\not=0\bigwedge size(j)=0$ 时，$x$ 仅有一个子节点。其能贡献的答案为子节点中最大的 $size(i)$ 加上 $deg(x)$ 与 $x$ 自身，再减去被重复计算的 $i$ 节点。

- $size(i)\not=0\bigwedge size(j)\not=0$ 时，$x$ 有至少 $2$ 个子节点。其能贡献的答案为子节点中最大的 $size(i)$ 与次大的 $size(j)$ 之和加上 $deg(x)$ 与 $x$ 自身，再减去被重复计算的 $i,j$ 节点。

------------

参考代码：
```
#include<cstdio>
int max(int x,int y){return x>y?x:y;}
const int MAXN=300000+10;
int next[MAXN<<1],to[MAXN<<1];
int head[MAXN],cnt;
void add(int u,int v){
	next[cnt]=head[u];
	to[cnt]=v;
	head[u]=cnt++;
	return;
}

int ans;
int size[MAXN];
void dp(int x,int fa){
	int tot=0;
	//tot 计算节点的度。
	int u=0,v=0;
	//u,v 记录 size(i) 与 size(j)。
	for(int i=head[x];~i;i=next[i]){
		int t=to[i];
		++tot;
		if(t!=fa){
			dp(t,x);
   			size[x]=max(size[x],size[t]);
			if(size[t]>u)v=u,u=size[t];
			else if(size[t]>v)v=size[t];
		}
	}
	if(u==0)ans=max(ans,tot+1);
	else if(v==0)ans=max(ans,u+tot);
	else ans=max(ans,u+v+tot-1);
	size[x]+=(tot==1?1:tot-1);
	//x 为根节点时 size(x) 无用，不进行特判。
	//tot 为 1 即表示仅有父节点与 x 相连，即 x 无子节点。
	return;
}

int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)head[i]=-1;
	while(m--){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dp(1,0);
	printf("%d",ans);
	return 0;
}

---

## 作者：jdsb (赞：11)

## 题意
给定一棵树，让你求出一条链，使得这条链上的点和与这条链直接相连的点（链上的点不算）的总点数最大。
## 分析
对于这道题要求的答案，我们其实可以转换成求一条链，使得链上的点的点权最大，而链上的点权就是与这个点的度数有关。我们可以通过一张图来理解。
![](https://cdn.luogu.com.cn/upload/image_hosting/nxraua21.png)

红色是我们选的点，橙色是与链相连的点，这就是最大的答案。我们可以发现，对于链上的点，他们对答案的贡献就是他们的度数减一，然后链的两端对答案还有一个点的贡献。我们设每第$i$个点的度数为$du[i]$，我们就要求$max\{\sum_i du[i]-1\}+2$ $(i\in$ 同一链 $)$。而求最长链，我们就先任选一个点$x$，以$x$为根求最长链，找到另一个端点$y$，再以$y$为根，求出最长链，即是答案，如果不会求最长链可以先做一下这道题[SP1437](https://www.luogu.com.cn/problem/SP1437)。
要注意特判当$n=1$时输出$1$，否则会把同一个点当成两个端点，计算两次。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
struct edge
{
	int y,next;
}e[N<<1];
int cnt,first[N];
void add(int x,int y)
{
	e[++cnt]={y,first[x]};
	first[x]=cnt;
}
int ans,pos,du[N],n,m;
void dfs(int x,int fa,int sum)
{
	if(sum>ans)
	{
		ans=sum;
		pos=x;
	}
	for(int i=first[x];i;i=e[i].next)
	{
		int y=e[i].y;
		if(y==fa) continue;
		dfs(y,x,sum+du[y]);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	if(n==1)
	{
		puts("1");
		return 0;
	}
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
		du[x]++;
		du[y]++;
	}
	for(int i=1;i<=n;i++) du[i]--;
	dfs(1,0,du[1]);
	ans=0;
	dfs(pos,0,du[pos]);
	printf("%d\n",ans+2);
	return 0;
}
```


---

## 作者：RedreamMer (赞：9)

[$\Large\texttt{P3174}$](https://www.luogu.com.cn/problem/P3174)

做法：树形 $DP$ 

Update：改了很多东西，更加详细了。

$\Large\texttt{Meaning}$

题目“抽”字我一开始看还是有点迷惑的，其实实意就是在一棵树中取一条链，求 链上的点和与它们相邻的点的个数最大。

$\Large\texttt{Solution}$

考虑每一个点 $n$ （我们先把它看做拥有至少两个儿子），若这条链经过点 $n$ ，且 $n$ 在这条链的最顶端，那么这条链一定是从 $n$ 的一棵子树的叶子开始，到另一棵子树的叶子。

这样，我们就要记录每个点两个值：

1. 与它相邻的节点个数（包括这个节点，但不包括父节点）

2. 从这个节点到它子树的某个叶子节点，这条链上对这条链的值有贡献的节点个数（不包括这个节点的父节点）

令第一个记录值为数组 $s$ ，第二个记录值数组 $h$ 。

$s[n]$ 很好求，即为 $1+\sum_{v\in son(n)}$。

$h[n]$ 即为 $s[n]-1+\max_{v\in son(n)} h[v]$（因为 $s[n]$ 和 $h[v]$ 都包括了 $v$ 这个节点，要减一），但是注意若 $n$ 是叶子节点，不用减一。

然后就可以求我们想要求的链了，记录子节点中最大和次大的的 $h$ 值，	加上这个节点的相邻节点个数( $s[n]$ )就好了，但要注意判重，和细节（见代码）。

时间复杂度 $O(N)$。

$\Large\texttt{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PB push_back
const int N = 300000;

int a, siz[N + 10], ans, dp[N + 10], s[N + 10], h[N + 10];
vector<int> st[N + 10];

inline void dfs(int n, int fa)
{
    s[n] = 1;
    h[n] = 1;
    int mx1 = 0, mx2 = 0;
    for (int i = 0; i < st[n].size(); i++)
    {
        int v = st[n][i];
        if (v == fa)
            continue;
        dfs(v, n);
        s[n]++;
        h[n] = max(h[n], h[v]);
        if (h[v] >= mx1)
        {
            mx2 = mx1;//顺序不要错
            mx1 = h[v];
        }
        else if (h[v] > mx2)
            mx2 = h[v];
    }
    h[n] += s[n];
    if (st[n].size())//不是叶子节点的时候
        h[n]--;
    int tmp = mx1 + mx2 + s[n] - (mx1 != 0) - (mx2 != 0) + (fa != 0);//注意孩子节点的个数少于2的时候，和没有父节点的时候。
    ans = max(ans, tmp);//记录当前最大值
}

signed main()
{
    scanf("%d%*d", &a);
    int x, y;
    for (int i = 1; i < a; i++)
    {
        scanf("%d%d", &x, &y);
        st[x].PB(y);
        st[y].PB(x);
    }
    dfs(1, 0);
    printf("%d", ans);
    return 0;
}
```

[$\large\texttt{My Blog}$](https://www.cnblogs.com/RedreamMer/p/13428408.html)

---

## 作者：Clouder (赞：6)

## Before the Beginning  

本文同步发表于[笔者博客](https://www.codein.icu/lp3174/)。  

## 题意  

[题目传送门](https://www.luogu.com.cn/problem/P3174)  

定义毛毛虫：  
在树上选一条链，链上每个点所连接的点都被包括在毛毛虫上。  

定义毛毛虫的大小：  
毛毛虫包含的节点数。  

求一棵树上最大的毛毛虫的大小。   

## 解法   

使用**动态规划**的方法。   

### 定义状态   

类比树上最长链的求法。   
定义 $f[i]$ 为以 $i$ 为一个端点、在以 $i$ 为根的子树中最大的毛毛虫包含的节点数量。   

![ExampleFor_F5](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/lp3174ExampleF.png)  

上图中，标红节点为 $f_5$ 所覆盖的节点，加粗边为毛毛虫的链。   

### 状态转移   

考虑如何进行转移。    
儿子数不同时分类讨论。   

#### 无儿子   

单个点的情况， $f_i = 1$。   

#### 单儿子

只有一个儿子的情况。   

![SingleSon](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/lp3174SingleSon.png)   

将父亲节点接上作为新的端点。   

$f_i = f_{son} + 1$  

#### 多儿子  

![MultiSon](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/lp3174multison.png)   

选择 $f_{son}$ 最大的儿子接上。     
其他儿子也被挂在毛毛虫上，加上儿子数，减去在 $f_{son}$ 中被计入的儿子。   

$f_i = f_{son} + num + 1 - 1$  
即 $f_i = f_{son} + num$   

### 统计答案

确定状态后，用状态统计出答案。    
依然分类讨论。    

#### 无儿子   

没有儿子，单点情况。   

如果当前点有父亲：  

$ans = f_u + 1$  

如果当前点无父亲：  

$ans = f_u$  

可以处理单个根节点的情况。  

#### 单儿子  

如果当前点有父亲，父亲会挂在毛毛虫上。  

$ans = f_u + 1$   

如果当前点无父亲：  

$ans = f_u$  

#### 多儿子  

类比求树上最长链可知，最长毛毛虫可能在两个儿子中取得。  

![MultiSonAns](https://cdn.jsdelivr.net/gh/Clouder0/myPics/img/lp3174multisongetans.png)   

记录 $f$ 最大和第二大的儿子，记为 $a,b$。  

如果当前点有父亲：  

$ans = f_a + f_b + num - 2 + 1 + 1$，减去被重复计算的两个儿子，加上当前点和父亲点。  

即 $ans = f_a + f_b + num$。  

如果当前点无父亲：  

$ans = f_a + f_b + num - 1$  

## 代码  

按照文章中的分类方法写的，可能略显繁琐。  

```cpp
#include <cstdio>
using namespace std;
template <typename T>
inline T _max(const T &a, const T &b) { return a > b ? a : b; }
template <typename T>
inline void read(T &r)
{
    static char c;
    r = 0;
    for (c = getchar(); c > '9' || c < '0'; c = getchar());
    for (; c >= '0' && c <= '9'; r = (r << 1) + (r << 3) + (c ^ 48), c = getchar());
}
const int maxn = 3e5 + 100;
struct node
{
    int to, next;
} E[maxn << 1];
int head[maxn];
inline void add(const int &x, const int &y)
{
    static int tot;
    E[++tot].next = head[x];
    E[tot].to = y;
    head[x] = tot;
}
int n, m, ans;
int f[maxn];
void dfs(int u, int from)
{
    int num = 0, maxx = 0, secx = 0;
    int v;
    for (int p = head[u]; p; p = E[p].next)
    {
        v = E[p].to;
        if (v == from)
            continue;
        dfs(v, u);
        ++num;
        if (f[v] > maxx)
            secx = maxx, maxx = f[v];
        else if (f[v] > secx)
            secx = f[v];
    }
    if (num == 0)
    {
        f[u] = 1;
        if (from == 0)
            ans = _max(ans, f[u]);
        else
            ans = _max(ans, f[u] + 1);
        return;
    }
    if (num == 1)
    {
        f[u] = maxx + 1;
        if (from == 0)
            ans = _max(ans, f[u]);
        else
            ans = _max(ans, f[u] + 1);
        return;
    }
    //multison
    f[u] = maxx + num;
    if (from == 0)
        ans = _max(ans, maxx + secx + num - 1);
    else
        ans = _max(ans, maxx + secx + num);
}
int main()
{
    read(n);
    read(m);
    int a, b;
    for (int i = 1; i <= m; ++i)
    {
        read(a);
        read(b);
        add(a, b);
        add(b, a);
    }
    dfs(1, 0);
    printf("%d", ans);
    return 0;
}
```

---

## 作者：JohnJoeZhu (赞：3)

[题面传送门](https://www.luogu.com.cn/problem/P3174)

~~为什么写题解的人这么少?~~

希望能够用通俗易懂的语言来讲这道省选题
## 算法
- 树上问题 显然
- 树形dp
既然是树论了，要求最大的毛毛虫，自然想到了dp和贪心，~~在乱搞一波后~~，发现dp是更形象直观可行的方法

## 树形dp
既然是dp了，那就逃不掉dp三部曲了
#### 1.设计状态
既然是求毛毛虫，那状态肯定就是

	f[i]:在以i为根的子树中，毛毛虫的大小
如果你考场上这样写，肯定是不够的

因为这个状态不能够限制这条毛毛虫的形态，也就是说，我们要考虑完善状态设计

然后我们就观察到，毛毛虫其实就是一条链+毛茸茸的东西

那么对于一条链，忽略毛茸茸，我们可以想到**拆链**，也就是从i这里把链劈成两段，所以可以得到

	f[i]:在以i为根的子树中，以i为链头的最大毛毛虫的大小
    ff[i]:在i的儿子的子树中的最大毛毛虫的大小
    答案为max(f[i]+ff[i])
为什么我们要这样子设计呢？主要是考虑到我们的转移，这个在下面详细讲
#### 2.状态转移
为了使转移方程服务于答案，上面留下了一个问题，我们来解决它

我们可以发现，在拆链之后，对于i，我们要知道的是两段信息
- i向下的最大毛毛虫
- i向下的最大毛毛虫

![](https://cdn.luogu.com.cn/upload/image_hosting/c8we4in3.png)图片

但是在统计的时候，出现了混乱啊，~~（此处省略1万字）~~，我们应该对目标信息做调整
- i向下的最大毛毛虫
- i的儿子的最大毛毛虫

![](https://cdn.luogu.com.cn/upload/image_hosting/vk3q9n3c.png)

从边向点转化

![](https://cdn.luogu.com.cn/upload/image_hosting/567femio.png)

然后就发现了一些问题

为什么会有双色点？！

显然是在统计的时候重复计算了，所以就要来加加减减qwq

~~乱搞1万字后~~，所以有

	f[u]=max(f[v]+in[u]-1)(in[u]是u点的度)
    ff[u]=max(f[v])
    上面的式子和下面的式子的v是不能重复的，因为毛毛虫不能够路径重复

#### 3.边界条件
我们在~~乱搞1万字以后~~，显然是可以得到

	f[u]=in[u]
然后涉及到HACK了

第一次交一发，发现被HACK了？！

然后就随手试了纯链，发现炸了？！

说明我们的设计有缺陷啊？！

然后就手动查错

![](https://cdn.luogu.com.cn/upload/image_hosting/41ydewhr.png)

因为链的特殊性质，加上本人是用边来转移的，所以还有一个应该初始化的地方就是
	
    ff[u]=1
## 代码
在N万字的查错之后，终于可以给出代码了
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=3e5+5;
int n,m,ans=0,f[N],ff[N],in[N],son[N];
struct pp{
	int v,nex;
}edge[N<<1];
int head[N],top=0;
void add(int u,int v)
{
	edge[++top].v=v;
	edge[top].nex=head[u];
	head[u]=top;
}
int dfs(int u,int fa)
{
	f[u]=in[u],ff[u]=1;
	int last;
	for(int i=head[u];i;i=edge[i].nex)
	{
		int v=edge[i].v;
		if(v!=fa)
		{
			dfs(v,u);
			if(f[v]+in[u]-1>f[u]) last=v,f[u]=max(f[u],f[v]+in[u]-1);//last要保证毛毛虫在两棵子树内
		}
	}
	for(int i=head[u];i;i=edge[i].nex)
		if(edge[i].v!=fa&&edge[i].v!=last) 
			ff[u]=max(ff[u],f[edge[i].v]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<n;i++) scanf("%d%d",&u,&v),add(u,v),add(v,u),in[u]++,in[v]++;
	dfs(1,0);
	for(int i=1;i<=n;i++) ans=max(ans,f[i]+ff[i]),printf("%d %d\n",f[i],ff[i]);//debug
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Piwry (赞：2)

没看到换根 dp 的写法就来写一个

相对来说转移方程会简单很多

（正好刚做完几道换根 dp，没忍住就往换根方面想了）

## 解析

设 `dp[u]` 表示以 $u$ 为毛毛虫链的一个端点，在以 $u$ 为根的子树内的最大贡献

可以想到转移时只要选某个儿子结点的链接上（也可不接），并使贡献最大就可以了

或者说：$dp(u)=\max(\max\limits_{v}(dp(v)+cntson(u)-1+1), cntson(u)+1)$

其中 $v$ 满足是 $u$ 的儿子，$cntson(u)$ 的值是 $u$ 的儿子个数（要求和 $u$ **有一条边直接相连**）

&nbsp;

再考虑换根，

设 $f_u(x)$ 代表以 $u$ 为根时 $x$ 结点的上述函数值，其中 $f$ 可以替换为某个函数的名称。

若将根从 $u$ 换到 $v$，可以想到 $dp_v(u)=dp_u(u)-1$ 即为 $u$ 作为 $v$ 儿子时的贡献

另外还要考虑恰好 $dp_u(u)=dp_u(v)+cntson_u(u)-1+1$ 的情况；此时只要记录一个**次大的** $dp_u(u)$ 值用于换根时的转移即可

## CODE

```cpp
#include <cstdio>
#include <iostream>
#define ll long long
using std::max;

const int MAXN =3e5+50;

/*------------------------------Map------------------------------*/

int first[MAXN], tote;
struct edge{
	int net, to;
}e[MAXN<<1];

inline void addedge(int u, int v){
	++tote;
	e[tote].to =v, e[tote].net =first[u];
	first[u] =tote;
	++tote;
	e[tote].to =u, e[tote].net =first[v];
	first[v] =tote;
}

/*------------------------------Dfs------------------------------*/

int dp[MAXN], dp2[MAXN]/*该结点为毛毛虫链端点时的该子树的最大/次大贡献*/;
int Ans =0;
int cntson[MAXN]/*一层儿子数量*/, chose[MAXN];

void predfs(int u, int fa){
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa){
			++cntson[u];
			predfs(e[l].to, u);
		}
}

void dfs(int u, int fa){
	dp[u] =cntson[u]+1;/*链直接在该结点终止*/
	dp2[u] =-0x3f3f3f3f;
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa){
			dfs(e[l].to, u);
			if(dp[e[l].to]+cntson[u]-1+1 > dp[u]){
				dp2[u] =dp[u];
				dp[u] =dp[e[l].to]+cntson[u]-1+1;
				chose[u] =e[l].to;
			}
			else if(dp[e[l].to]+cntson[u]-1+1 > dp2[u])
				dp2[u] =dp[e[l].to]+cntson[u]-1+1;
		}
}

void dfs2(int u, int fa){
	Ans =max(Ans, dp[u]);
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa){
			++cntson[e[l].to];
			++dp[e[l].to], ++dp2[e[l].to];
			int res;
			if(chose[u] == e[l].to)
				res =dp2[u]-1;
			else
				res =dp[u]-1;
			if(res+cntson[e[l].to]-1+1 > dp[e[l].to]){
				dp2[e[l].to] =dp[e[l].to];
				dp[e[l].to] =res+cntson[e[l].to]-1+1;
				chose[e[l].to] =u;
			}
			else if(res+cntson[e[l].to]-1+1 > dp2[e[l].to])
				dp2[e[l].to] =res+cntson[e[l].to]-1+1;
			dfs2(e[l].to, u);
		}
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	int n =read(), m =read();
	for(int i =0; i < n-1; ++i){
		int u =read(), v =read();
		addedge(u, v);
	}
	predfs(1, 0);
	dfs(1, 0);
	dfs2(1, 0);
	printf("%d", Ans);
}
```

---

## 作者：Starlight237 (赞：1)

显然对于树上的一条链，连接这条链和所有与链上结点**直接相连**的点，便形成了一条毛毛虫 $\mathcal{F}$。为了方便讨论，这条链定义为毛毛虫的**关键链**。我们将毛毛虫 $\mathcal{F}$ 的**最小关键链**记作 $\mathcal{L(F)}$

定义 $f_x$ 为满足如下条件的最大毛毛虫 $\mathcal{F}$ 的大小(这个毛毛虫记作 $F_x$)：
1. $\mathcal{L(F)}$ 在 x 的子树中且过 x。
2. x 为 $\mathcal{L(F)}$ 的顶点。

感性理解一下，满足这两个条件的毛毛虫的最顶端一定是 x 和与 x 相连的所有结点。

定义 $g_x$ 为满足如上条件**且满足** $\mathcal{L}(F_x)\cap\mathcal{L(F)}=\{x\}$ 的最大毛毛虫 $\mathcal{F}$ 的大小。

考虑转移这两个东西，$f_x$ 应由两部分组成，即 $f_v$ 和所有与x相连的点。这两部分中 v 是重复的，所以要减掉。

故有：$f_x=\max\{f_v\}+nson_x$，$g_x=\text{submax}\{f_v\}+nson_x$

其中 $nson_x=deg_x-1$，即 x 的儿子数目，其实也等于与x相连的点的数量-1（为啥要减一已经解释过了）。

对于任意一个点 x，最小关键链经过 x 的最大毛毛虫的大小记作 $ans_x$。则所有 ans 取最大值即为答案。

ans 由两部分组成：
- $f_x$
- $g_x$

这些东西里面有重复。手绘可得，$f_x$ 与 $g_x$ 中重复的结点数为 $deg_x+1$ 即 $nson_x + 2$，故 $ans_x=f_x+g_x-nson_x-2$。

一些细节：
- 若 x 只有一个子节点，$g_x$ 是没有意义的。此时直接令 $ans_x=f_x$。
- 当 x 为根节点的时候，因为 x 是没有父节点的，所以统计的时候应当用 $ans_1-1$ 作为正确的 $ans_1$。


Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define ll int
extern "C" {
namespace io{
#define BUFS 100000
	static char in[BUFS], *p = in, *pp = in;
#define gc() (p == pp && (pp = (p = in) + fread(in, 1, BUFS, stdin), p == pp) ? EOF : *p++)
	inline char gtc() {while (isspace(*p)) ++p; return *p++;}
	inline ll read() {
		reg ll x = 0; reg char ch, f = 0;
		while (!isdigit(ch = gc())) f |= ch == '-';
		while (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = gc();
		return f ? -x : x;
	}
}}
#define rd io :: read
#define gtc io :: gtc
const int N = 300001;
int n, m, tot, head[N], f[N], g[N], ans[N], nson[N];
struct Edge{int v, nxt;} eg[N << 1];
inline void addedge(int u, int v) {
	eg[++tot] = Edge{v, head[u]}, head[u] = tot;
}
void dfs1(int x, int Fa) {
	for (reg int i = head[x], v; i; i = eg[i].nxt)
		(v = eg[i].v) != Fa && (++nson[x], dfs1(v, x), 0);
}
void dfs2(int x, int Fa) {
	if (!nson[x]) f[x] = 2;
	for (reg int i = head[x], v; i; i = eg[i].nxt)
		(v = eg[i].v) != Fa && (
			dfs2(v, x),
			f[v] <= f[x] && f[v] > g[x] && (g[x] = f[v]),
			f[v] > f[x] && (g[x] = f[x], f[x] = f[v])
		);
	f[x] += nson[x], g[x] += nson[x];
	if (nson[x] > 1) ans[x] = f[x] + g[x] - nson[x] - 2;
	else ans[x] = f[x];
}
int main() {
	n = rd(), m = rd();
	for (reg int i = 1, u, v; i <= m; ++i)
		u = rd(), v = rd(), addedge(u, v), addedge(v, u);
	dfs1(1, 0), dfs2(1, 0);
	reg int res = 0;
	for (reg int i = 2; i <= n; ++i)
		res = max(res, ans[i]);
	res = max(res, ans[1] - 1);
	printf("%d", res);
	return 0;
}
```


---

## 作者：_Anchor (赞：1)

### 杂谈

深夜写过这道题......

~~奇迹般的对样例编程首A~~

~~我很好奇这个m有什么卵用~~

------------


### 1.分析

题目保证是一棵树，题目大意是让我们去求一棵树上的一条链，

使得与这条链直接相连的点的数量最大

那么看见这个最大，加上数据范围，以及**树的直径**的知识

（不知道的请BDFS）

(1)我们可以联想到**树形dp**

并且我们可以很容易发现：

最后的答案一定是**两个**“毛毛虫”拼在一起的结果（不懂的可以联想树的直径）

所以我们需要求出：

(2)**对于一个根节点为起点，一个叶子节点为终点**的所有“毛毛虫”中**最大的**和**次大的**，再把答案加起来

再想想我们又可以发现：

最后的“毛毛虫”不一定经过所有节点

所以

(3)**将每个点都假设为根节点，将它们的答案与maxn之间取max**

(4)**最后的答案即为maxn**


------------


### 2.总结流程

(1) **期望树形dp求解**~~（废话）~~

(2) **对于一个根节点为起点，一个叶子节点为终点**的
所有“毛毛虫”中**最大的**和**次大的**，再把答案加起来

(3) **将每个点都假设为根节点，将它们的答案与maxn之间取max**

(4) **最后的答案即为maxn**


------------


### 3.解决dp

用f[x]表示以x为根，在这棵子树上满足题意的最大的“毛毛虫”

用g[x]表示以x为根，在这棵子树上满足题意第二大的“毛毛虫”

则：

$f[x]=max(f[son[x]])$

$g[x]=max(min(f[x],f[son[x]]),g[x])$

（实际编写代码时**g的转移需放在f的前面**）


DFS求出所有的f和g后，我们再执行(3)(4)步即可求出答案

### 4.代码实现

（1）dp方程按上述过程来写

结论：1.24s，亲测跑得飞慢

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
inline int inc(int x,int v,int mod){x+=v;return x>=mod?x-mod:x;}
inline int dec(int x,int v,int mod){x-=v;return x<0?x+mod:x;}
inline int read(){int x=0,f=1;char ch=getchar();while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}return x*f;}
inline void write(int x){if(x==0){putchar(48);return;}int len=0,dg[20];while(x>0){dg[++len]=x%10;x/=10;}for(register int i=len;i>=1;i--)putchar(dg[i]+48);}
const int N=200005;
ll ans;
int n,m,head[N],nex[N],to[N],idx,val[N],f[N],g[N],maxn;
bool vis[N],vis1[N],vis2[N],flag;
void add(int u,int v){
	nex[++idx]=head[u];
	to[idx]=v;
	head[u]=idx;
	return ;
}
void dfs(int x,int fa){
	for(int i=head[x];i;i=nex[i]){
		if(to[i]==fa) continue;
		int y=to[i];
		dfs(y,x);
		g[x]=max(min(f[x],f[y]),g[x]);
		f[x]=max(f[y],f[x]);
	}
	f[x]+=val[x]-1;
	return ;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int u,v;
		u=read(),v=read();
		val[u]++;
		val[v]++;
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++){
		maxn=max(maxn,f[i]+g[i]+2);
	}
	cout<<maxn;
	system("Pause");
	return 0;
}
```
（2）dp方程改成if判断

结论：340ms，比上面那个~~垃圾~~办法快了不知道多少......

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
inline int inc(int x,int v,int mod){x+=v;return x>=mod?x-mod:x;}
inline int dec(int x,int v,int mod){x-=v;return x<0?x+mod:x;}
inline int read(){int x=0,f=1;char ch=getchar();while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}return x*f;}
inline void write(int x){if(x==0){putchar(48);return;}int len=0,dg[20];while(x>0){dg[++len]=x%10;x/=10;}for(register int i=len;i>=1;i--)putchar(dg[i]+48);}
const int N=2000005;
ll ans;
int n,m,head[N],nex[N],to[N],idx,val[N],f[N],g[N],maxn;
void add(int u,int v){
	nex[++idx]=head[u];
	to[idx]=v;
	head[u]=idx;
	return ;
}
void dfs(int x,int fa){
	for(int i=head[x];i;i=nex[i]){
		if(to[i]==fa) continue;
		int y=to[i];
		dfs(y,x);
		if(f[x]<=f[y]){
			g[x]=f[x];
			f[x]=f[y];
			continue;
		}
		if(f[y]>g[x]){
			g[x]=f[y];
		}
	}
	f[x]+=val[x]-1;
	return ;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int u,v;
		u=read(),v=read();
		val[u]++;
		val[v]++;
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++){
		maxn=max(maxn,f[i]+g[i]+2);
	}
	cout<<maxn;
	return 0;
}
```

### 5.后记

其实关于那个求g数组的dp方程，

我~~是闲的没事干才~~写了个只有max和min形式的方程

我最开始是写的if，至于为什么慢这么多，我想大概是因为max和min比起比较语句要慢吧？（太蒻了看不出来惹/kk


---

## 作者：Dzhao (赞：1)

树形DP~~一眼题~~

分析题目，题目中说的所谓毛毛虫的东西，就是提起一条链，链上连了一堆点的东西（题目已经说的很清楚了）

我们来考虑一下，这样的题怎么做。

我们发现，对于每一个点，他的孩子所能组成的最大毛毛虫是**不会**互相影响的，于是我们就可以对每个点求出他向下所能组成的最大毛毛虫数，每次更新答案只需要将子节点中最大和次大的毛毛虫找出来，然后把他们通过父节点连在一起便构成了一个新的毛毛虫。注意，由于这样的毛毛虫不一定最大，该节点向上还可以连一条边，如果是根节点则不能连边（特判一下）

接着我们考虑，会不会一个毛毛虫是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/xc42m7ei.png)

有人可能会说，那这不是 $u_1$ 点往上往下各一只毛毛虫吗，这怎么解决？

我们会发现，这个毛毛虫在处理 $u_2$ 点时就被考虑了，不用担心有这种情况。

讲解完了，我们来看一下代码

$View\ Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T> //快读 
inline void rd(T &x)
{
	x=0;bool f=0;char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f=1;c=getchar();}
	while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f) x=-x;
}
const int N=300005;
struct Edge //邻接表存图 
{
	int nxt,ed;
}a[N<<1];
int h[N],tot,f[N],n,m,ans;
inline void add(int x,int y)
{
	a[++tot].ed=y;
	a[tot].nxt=h[x];
	h[x]=tot;
} 
void dfs(int u,int fa)
{
	int sum1=0,sum2=0,cnt=0,flag=0; /*类似树直径求法，flag表示该点有没有向上的边，cnt表示与u相连
	的边的个数，sum1,sum2分别表示最大与次大的毛毛虫*/
	for(int i=h[u];i;i=a[i].nxt)
	{
		int v=a[i].ed;
		if(v==fa) //往回走，说明有向上边 
		{
			flag=1;
			continue;
		}
		cnt++;dfs(v,u);
		if(sum1<f[v]) swap(sum1,sum2),sum1=f[v]; //若比sum1大,sum1->sum2,f[v]->sum1 
		else if(sum2<f[v]) sum2=f[v]; //若比sum1小,sum2大,f[v]->sum2 
	}
	f[u]=sum1+cnt; //将该节点最大毛毛虫更改 最大+叶子节点个数 
	ans=max(sum1+sum2+cnt+1+flag,ans); //更新答案,最大+次大+叶子节点个数+该节点+上方的边(0/1) 
}
int main()
{
	rd(n),rd(m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		rd(x),rd(y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	printf("%d\n",ans);
	return 0;
}
```
$Thanks\ for\ watching$

---


# [蓝桥杯 2025 省 B] 生产车间

## 题目描述

小明正在改造一个生产车间的生产流水线。这个车间共有 $n$ 台设备，构成以 $1$ 为根结点的一棵树，结点 $i$ 有权值 $w_i$。其中叶节点的权值 $w_i$ 表示每单位时间将产出 $w_i$ 单位的材料并送往父结点，根结点的权值 $w_i$ 表示每单位时间内能打包多少单位成品，其他结点的权值 $w_i$ 表示每单位时间最多能加工 $w_i$ 单位的材料并送往父结点。

由于当前生产线中某些结点存在产能不够的问题导致生产线无法正常运行，即存在某些结点每单位时间收到的材料超过了当前结点的加工能力上限。小明计划删除一些结点使得所有结点都能正常运行。他想知道删除一些结点后根结点每单位时间内最多能打包多少单位的成品？

## 说明/提示

### 样例说明

删掉结点 $4$、$9$ 后生产线满足条件，根结点 $1$ 每单位时间将打包出 $8$ 单位的成品。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$2 \leq n \leq 100$。
- 对于 $100\%$ 的评测用例，$2 \leq n \leq 1000$，$1\leq w_i \leq 1000$。

## 样例 #1

### 输入

```
9
9 7 3 7 1 6 2 2 7
1 2
1 3
2 4
2 5
2 6
6 7
6 8
6 9```

### 输出

```
8```

# 题解

## 作者：Untitled_unrevised (赞：12)

> 能意识到 G 有多难就能意识到 G 有多简单。

本文将介绍 [P12136 [蓝桥杯 2025 省 B] 生产车间](https://www.luogu.com.cn/problem/P12136) 与子集和问题之间的关联，并给出基于此得出的做法，以及可能的时间优化方式。

## 题意简述

给定一棵有根树，忽略若干个节点使得对于剩下的非叶节点 $u$，它所包含的剩下的叶节点权值之和都 $\le w_u$；并对于根节点 $1$，最大化它所包含的剩下的叶节点权值之和。

## 题目分析

树上问题，自然想到要用树形 dp 来做。然后注意到数据范围 $n \le 1,000$ 和 $w \le 1,000$，应该能意识到这题只要求平方时间的做法。

这意味着，或许，这个题很难，使得更低复杂度的做法可能是不存在的。但到底有多难？我们可以拿另一个已经有明确难度的题来比较。

### 与子集和问题的联系

考虑一种比较极端的数据：除了 $1$ 之外的所有节点全都是叶节点，编号构成的集合为 $L = \{2, 3, \dots, n\}$。此时问题转化成找出一个子集 $T \sube L$ 使得 $\sum_{v \in T} w_v \le w_1$ 且 $\sum_{v \in T} w_v$ 最大。

如果你解决了该问题，那么通过判定 $\sum_{v \in T} w_v$ 是否等于 $w_1$，你就直接判定了 $L$ 是否存在一子集，它的权值和为 $w_1$。而这就是著名的**子集和问题**，在值域没有限制的时候是 NP-Complete 的。

综上，该问题是严格不弱于子集和问题的，如果 $w$ 没有限制，$n \le 1000$ 这样大的范围是难以短时间做出来的。

### 小值域子集和问题

现在应该就能看出 $w \le 1,000$ 的作用了。子集和问题虽然是 NP-Complete 的，但是其存在 $O(n\sum w)$ 的伪多项式时间的做法。对于本题而言，$w$ 是限制在每一个节点上的，从而对每一个节点，它的子集和的范围都不过 $O(w)$ 而已。

到了这里，应该就能够得出 $O(nw^2)$ 的做法了：

-   对于每一个叶节点 $u$，它有选与不选两种选择，从而所有可能的子集和为 $S_u = \{0, w_u\}$；
-   对于每一个枝节点 $v$，从它所有子节点可能的子集和计算出自己可能的的子集和然后除去 $\gt w_v$ 的，具体而言：

$$
S_v = (S_{r_1} + S_{r_2} + \dots + S_{r_{d^+(v)}}) \cap [0, w_v]
$$

其中 $S + T = \{s + t \mid \forall s \in S, \forall t \in T\}$，$r_i$ 是 $v$ 的第 $i$ 个子节点。

最后对于 $S_1$，输出 $\max S_1$ 即可。

### 可能的优化

尽管 $O(nw^2)$ 很有可能跑不满但仍然是可达到的，一旦达到了就可能超时。由于瓶颈在子集和问题上且不可能比子集和问题简单，唯一的方法就是优化解决子集和问题的算法。

可以使用 [C++ 的 `std::bitset`](https://zh.cppreference.com/w/cpp/utility/bitset) 来优化常数，此时单次合并子集和可以优化到 $O\bigg(\dfrac{w^2}{\omega}\bigg)$，其中 $\omega$ 是 `std::bitset` 所用的字长，一般为 32 或 64。总时间复杂度 $O\bigg(\dfrac{nw^2}{\omega}\bigg)$。

另一种更狠的优化方式超出了本题的难度范围，本人赛场上懒得想了就直接写了这个：使用 FFT 优化单次合并子集和，可以做到 $O(w \log w)$。对于有兴趣的，这里讲解一下：

给定子集和 $S,T$ 生成 $S + T$，你要优化的本质上是生成 $s + t$ 的过程。对 $S$ 构造生成函数 $F_S(z) = \sum_{s \in S} z^s$，此时有：

$$
F_S(z)F_T(z) = \sum_{s \in S} z^s \sum_{t \in T} z^t = \sum_{s \in S, t \in T} z^{s + t}
$$

从而 $F_S(z)F_T(z)$ 中 $z^k$ 的系数表示有多少对 $s, t$ 满足 $s + t = k$，若系数 $\ge 1$ 则表示存在这样的 $s, t$。

而计算 $F_S(z)F_T(z)$ 显然就是多项式乘法，使用 FFT 就可以做到 $O(w \log w)$ 的时间复杂度。此时本题的时间复杂度为 $O(nw \log w)$，时间绰绰有余。

## 参考代码

```cpp
#include <algorithm>
#include <array>
#include <iostream>
#include <vector>

using std::cin;
using std::cout;
using std::vector;

using u64 = unsigned long long;

constexpr u64 P = 998'244'353;

template<class Grp, class Exp, class Ty>
Ty pow(Grp base, Exp exp, Ty id) {
	for(; exp; exp >>= 1, base *= base)
		if(exp & 1)
			id *= base;
	return id;
}

template<class Grp, class Exp, class Ty>
Ty& powass(Grp base, Exp exp, Ty &id) {
	for(; exp; exp >>= 1, base *= base)
		if(exp & 1)
			id *= base;
	return id;
}

struct Fp {

	u64 x;

	constexpr Fp(u64 val = 0) : x(val) {}

	Fp& operator+=(const Fp &other) {
		x += other.x;
		if(x >= P) x -= P;
		return *this;
	}
	Fp& operator-=(const Fp &other) {
		if(x < other.x) x += P;
		x -= other.x;
		return *this;
	}
	Fp& operator*=(const Fp &other) {
		x = x * other.x % P;
		return *this;
	}
	Fp& operator/=(const Fp &other) {
		return powass(other, P - 2, *this);
	}
	friend Fp operator+(Fp lhs, const Fp &rhs) { return lhs += rhs; }
	friend Fp operator-(Fp lhs, const Fp &rhs) { return lhs -= rhs; }
	friend Fp operator*(Fp lhs, const Fp &rhs) { return lhs *= rhs; }
	friend Fp operator/(Fp lhs, const Fp &rhs) { return lhs /= rhs; }
};

Fp prim(3);
Fp coprim = Fp(1) / prim;

vector<u64> graph[1001];
vector<u64> subset[1001];
bool visited[1001] = {};
u64 w[1001] = {};

template<class RanIt>
void FFT(RanIt arr, bool type) {
	for(int logseg = 0; logseg < 11; ++logseg) {
		size_t seg = 1ull << logseg;
		Fp omega = pow(type ? coprim : prim, (P - 1) >> (logseg + 1), Fp(1));
		for(RanIt lhs = arr; lhs != arr + 2048; lhs += (seg + seg)) {
			RanIt rhs = lhs + seg;
			Fp phi = Fp(1);
			for(size_t off = 0; off < seg; ++off) {
				Fp g = lhs[off];
				Fp hw = rhs[off] * phi;
				lhs[off] = g + hw;
				rhs[off] = g - hw;
				phi *= omega;
			}
		}
	}
	if(type) {
		Fp div = Fp(1) / Fp(2048);
		for(size_t i = 0; i < 2048; ++i)
			arr[i] *= div;
	}
}

vector<u64> subsetmerge(u64 u, const vector<u64> &lset, const vector<u64> &rset) {
	if(lset.size() * rset.size() < 2048) {
		bool contains[2001] = {};
		for(u64 x : lset) {
			for(u64 y : rset) {
				contains[x + y] = true;
			}
		}
		vector<u64> res;
		for(u64 z = 0; z <= w[u]; ++z)
			if(contains[z])
				res.push_back(z);
		return res;
	}
	std::array<Fp, 2048> lff{}, rff{};
	for(u64 x : lset) lff[x] = Fp(1);
	for(u64 x : rset) rff[x] = Fp(1);
	FFT(lff.begin(), false);
	FFT(rff.begin(), false);
	for(size_t i = 0; i < 2048; ++i)
		lff[i] *= rff[i];
	FFT(lff.begin(), true);
	vector<u64> res;
	for(u64 z = 0; z <= w[u]; ++z)
		if(lff[z].x)
			res.push_back(z);
	return res;
}

void dfs(u64 u) {
	visited[u] = true;
	bool isleaf = true;
	for(u64 v : graph[u]) {
		if(!visited[v]) {
			isleaf = false;
			dfs(v);
			subset[u] = subsetmerge(u, subset[u], subset[v]);
		}
	}
	if(isleaf) {
		subset[u].push_back(w[u]);
	}
}

int main() {

	size_t n;
	cin >> n; 
	for(u64 u = 1; u <= n; ++u) {
		cin >> w[u];
		subset[u].push_back(0);
	}
	for(u64 i = 1; i < n; ++i) {
		u64 u, v;
		cin >> u >> v;
		graph[u].push_back(v);
		graph[v].push_back(u);
	}
	dfs(1);
	cout << subset[1].back();
	return 0;
}
```

---

## 作者：gu51yo (赞：10)

组合问题，观察到数据范围 $1000$，考虑**树形 DP**。因为每个节点的可能提供的值不确定，所以还需要利用**分组背包**来实现。

### 思路分析

**状态定义**

定义 $dp[u]$ 为 bitset 类型。例如 $dp[u][x] = true$ 表示在以节点 $u$ 为根的子树中，通过删除部分节点，可以使得子树提供**恰好** $x$ 的价值。

**状态转移**

采用树形 DP 的经典形式，DFS，从叶子节点开始，自底向上。

- **叶子节点**：

  只有两种状态。保留或删除，向父节点贡献 $w[u]$ 或 $0$ 价值。
    
- **非叶子节点**：

  有多种状态，状态集合即它可能贡献的价值。设 $u$ 的子节点集合为 $g(u)$。$dp_u$ 即 $u$ 的子节点 $v$ 们的价值组合集合。

  再递归向上，直到根节点。这就是一个**树上的，分组背包问题**了。我们可以维护一个 bitset 来高效地解决这个问题。

### 时间复杂度

- DFS 遍历整棵树需要 $O(n)$ 时间。在每个非叶子节点 $u$，我们需要对其子节点 $v$ 的价值集合进行组合。总时间复杂度为 $O(n \cdot W^2)$。

  对于 $n=1000,W=1000$，理论时间复杂度是 $10^9$，但因为终止条件 $s+f \leq w[u]$ 会节省很多计算。实测运行效率远好于理论上界，即使不解绑同步，依然可以 200ms 通过此题。

- 实际上可以用位运算优化来降低时间复杂度。感谢 MattL 提出。同时感谢 Dr_Gilbert 的多次审核。
```
        for (int s = 0; s <= w[u]; s++) if (cur[s] == 1)    // 分组背包 DP, 未优化，O(W^2)
            for (int f = 0; s + f <= w[u]; f++)
                if (dp[v][f] == 1) nxt[s + f] = 1;
```
```
    for (int i = 0; i <= w[u]; ++i) mask.set(i); // mask存节点u的所有合法值
    ...
    ...
    for (int s = cur._Find_first(); s <= w[u]; s = cur._Find_next(s)) nxt |= (dp[v] << s);
    nxt &= mask;  // 避免位运算后出现非法值，&一下。位运算优化后，时间复杂度常数可以除以64。
```

### 具体实现详细见代码：
```
const int N = 1e3+9;
int n, ans=0;
vector<int> w(N);
vector<vector<int>> g(N);
vector<bitset<N>> dp(N);

void dfs(int u, int p) {
    if (g[u].size() == 1 && p != -1) {  // 叶子节点判断
        dp[u][0] = 1;
        if (w[u] <= N) dp[u][w[u]] = 1;
        return;
    }

    bitset<N> cur, mask; cur[0] = 1;
    for (int i = 0; i <= w[u]; ++i) mask.set(i);

    for (int v : g[u]) if (v != p) {
        dfs(v, u);
        bitset<N> nxt; nxt[0] = 1;
        for (int s = cur._Find_first(); s <= w[u]; s = cur._Find_next(s)) nxt |= (dp[v] << s);
        nxt &= mask;
        cur = nxt;
    }
    dp[u] = cur;
}

signed main () {
    cin >> n;   // 输入
    for (int i = 1; i <= n; i++) cin >> w[i];   
    for (int i = 1; i < n; i++) {
        int u, v; cin >> u >> v;
        g[u].push_back(v); g[v].push_back(u);
    }

    dfs(1, -1); // 树形 DP

    for (int x = w[1]; x >= 0; x--) if (dp[1][x] == 1) {ans = x; break;}    // 输出
    cout << ans << '\n';
}
```

值得一提的是，这可能是一道假题。因为题目并没有提到“若将 $u$ 的所有子节点都删除后，$u$ 不会因为转变为叶子节点而转变为产出材料”。

---

## 作者：Sekiro__ (赞：6)

# 树上背包做法

## 题意

删除一些节点，使得剩余的所有节点正常工作，且根节点的单位时间打包数最大。  

初看会想到 01 背包模型，即每个节点尽量在不超过自身权值的情况下，尽可能将多的权值装入背包。  

但是，并非背包价值越大越好，从整体来看，子节点背包价值越高，父节点背包容量反而可能装不下如此大的价值，造成父节点背包价值并非最优解的情况。  

因此，与其求出每个节点背包的最大价值，不如找到该节点背包价值的所有可能（在不超过自身权值的情况下）。

## 分析

题目要求删除一些节点，反过来想就是问我们保留哪些节点，即选择某些节点加入背包。  
以叶子节点举例：

![](https://cdn.luogu.com.cn/upload/image_hosting/bbfknsmc.png)

可以看到 $A$ 作为叶子节点，只能提供 $8$（选）或 $0$（不选），同理，$B$ 能提供 $5$ 或 $0$，$C$ 能提供 $4$ 或 $0$，而他们的父节点 $D$ 只能接收这三个孩子节点提供的权值，且权重之和不能超过自身的 $10$。  

显而易见，这是一个**分组背包**的模型：$A$ 分组中的值为 $\left\{ 0,8 \right\}$，$B$ 分组中的值为 $\left\{ 0,5 \right\}$，$C$ 分组中的值为 $\left\{ 0,4 \right\}$。对于每一分组，我们只能选择分组中的一个值放入背包。

每一个非叶子节点都有一个背包，而我们要求的是这个节点放入孩子节点提供的权值后，能产生的所有容量的可能。    

比如：$D$ 节点能产生背包容量的可能为 $\left\{ 0,8,5,4,9 \right\}$。

更详细的，我们以下图举例，其中 $\left\{ \right\}$ 内容为该节点背包价值的所有可能，对于其父级来说就是分组背包中的“分组”。

![](https://cdn.luogu.com.cn/upload/image_hosting/c53h0fuq.png?x-oss-process=image/resize,m_lfit,h_1000,w_450)

## 状态转移方程

**状态方程**：

$$
\text{dp}[i][j] = 
\begin{cases}
1, & \text{前}\space j \space\text{组能够产生}\space i\space\text{价值} \\
0, & \text{前}\space j\space\text{组不能产生}\space i\space\text{价值}
\end{cases}
$$

**转移方程**：

$$
\text{dp}[i][j] = \bigvee_{k=0}^{m_{j}} (i - v[j][k] \geq 0 \wedge \text{dp}[i - v[j][k]][j-1])
$$

**注**：$v[j]$ 表示第 $j$ 分组，$m_{j}$ 表示 $j$ 分组内元素个数。

## 优化建议

求解背包问题部分可以用滚动数组降维，以达到优化空间复杂度的作用（但是给的空间够用就不管了）。

如果有别的优化建议欢迎评论区讨论！

## 易错点

如果你的代码只能通过大部分后面的测试点，而在前面测试点 WA 了，可以考虑数据输入的问题。

具体来讲，输入边的时候并没有指定谁是父节点，谁是子节点！

 ## AC 代码

```cpp
#include <bits/stdc++.h>
#include <iostream>
#include <string.h>
using namespace std;
// 树上背包

int w[1005],N,ans=0;
vector<vector<int>> cap(1005,vector<int> ()); //每个节点背包价值的所有可能
vector<vector<int>> adj(1005,vector<int> ()); //邻接表

int work(int u)
{
    if(adj[u].size()==0) //如果当前节点是叶子节点
    {
        cap[u].push_back(w[u]);
        return cap[u].size();
    }
    // 若不是叶子节点
    vector<vector<bool>> dp(1005,vector<bool> (1005,0)); //dp数组
    dp[0][0]=1;
    for(int i=0;i<=w[u];i++)
        for(int j=1;j<=adj[u].size();j++)
        {
            if(i==0) dp[i][j]=1; //价值为0一定可以成立
            else if(dp[i][j-1]) dp[i][j]=1; //此组之前已经满足了i，直接转移
            else
            {   
                int v=adj[u][j-1],len;
                if(cap[v].size()==0) len=work(v); //递归调用
                else len=cap[v].size();
                for(int k=0;k<len;k++)
                    if(i-cap[v][k]>=0 && dp[i-cap[v][k]][j-1]) //转移方程
                        {dp[i][j]=1; break;}
            }
            if(j==adj[u].size() && dp[i][j]) cap[u].push_back(i); //遍历到行末再加入分组，防止重复加入
        }
    
    return cap[u].size(); //返回分组内元素个数
}

int main()
{
    cin>>N;
    for(int i=1;i<=N;i++)
        cin>>w[i];
    for(int i=1;i<=N-1;i++)
    {
        int u,v; cin>>u>>v;
        if(u>v) swap(u,v);
        adj[u].push_back(v);
    }

    work(1);
    for(int i=0;i<cap[1].size();i++)
        ans=max(ans,cap[1][i]); //找根节点背包价值的最大可能
    cout<<ans;  

    system("pause");
    return 0;
}
```

---

## 作者：CommandSR (赞：4)

## 题意简化

我们有一个树形结构的车间生产线：
1. 根节点是打包点，其权值表示打包能力。
2. 叶节点是原材料生产点，其权值表示产量。
3. 中间节点是加工点，其权值表示加工能力。

某些节点可能收到的材料超过其加工能力。我们需要删除一些节点，使得所有剩余节点的材料输入不超过其加工能力，最大化根节点的打包量。

## 基本思路

首先，要删除的节点必然是叶子节点，否则则会使这棵树不连通。

考虑树形 DP，设 $f_{i, j}$ 为 $i$ 节点加工 $j$ 单位材料是否可行。

考虑状态转移，设 $v$ 是 $u$ 的子节点，若状态 $f_{u, j}$ 存在，状态 $f_{v, k}$ 存在，且 $j+k \leq a_u$，则状态 $f_{u, j+k}$ 存在。

```cpp
_F(j, a[u], 0)
  _F(k, a[v], 0)
    if (dp[u][j] && dp[v][k] && j+k <= a[u])
      dp[u][j+k] = 1;
```

考虑初始状态，对于每一个节点 $f_{u, 0} = 1$，对于叶子节点 $f_{u, a[u]} = 1$。 

考虑答案，从大到小枚举 $j$，找到第一个满足 $f_{1,j} = 1$ 的 $j$ 就是答案。




## AC Code

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for (ll i = a; i <= b; ++i)
#define _F(i, a, b) for (ll i = a; i >= b; --i)
#define ll long long
#define pb push_back
#define inf 1e14
using namespace std;
int rd() {
	ll p = 0, f = 1; char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
const int N = 2010;
ll n, a[N], dp[N][N];
vector <int> g[N];
void dfs(int u, int p) {
	if (g[u].size() == 1 && u != 1) {
		dp[u][a[u]] = 1;
		return ;
	} 
	F(i, 1, 1000) dp[u][i] = 0; dp[u][0] = 1;
	for (int v : g[u]) {
		if (v == p) continue ;
		dfs(v, u);
		_F(j, a[u], 0) {
			_F(k, a[v], 0) {
				if (dp[u][j] && dp[v][k] && j+k <= a[u]) {
					dp[u][j+k] = 1;
				}
			}
		}
	}
}
int main() {
	n = rd(); F(i, 1, n) a[i] = rd();
	F(i, 1, n-1) {
		int u = rd(), v = rd();
		g[u].pb(v); g[v].pb(u);
	}
	dfs(1, 0);
	_F(j, a[1], 0) {
		if (dp[1][j]) {
			cout << j << '\n';
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：huanhuanonly (赞：3)

## 分析

根据题意可知，每个叶子结点都有**选**和**不选**两种状态，最多有 $n\,(n\le{1000})$ 个结点，且每个节点的值 $w_i$ 最大为 $1000$，考虑**树上 0/1 背包**。

我们将叶子结点视作物品，叶子结点 $i$ 的值 $w_i$ 作为物品的大小，且**大小同等于价值**；

将非叶子节点视作背包，背包容量为父节点 $fa$ 的值 $w_{fa}$，背包可以装子节点（物品，或小背包），注意，如果装的是小背包，小背包的大小为其物品之和，而非小背包容量。

显而易见，我们可以对每一个节点做一次 0/1 背包。考虑到物品大小等同于价值，我们可以使用 `std::bitset` 充当第 $i$ 个结点的 $dp_i$ 数组，大小开 $\max\left\{w_i\right\}+1\,(w_i\leq{1000})$：

```cpp
std::vector<std::bitset<1000 + 1>> dp(n + 1);
```

- 第 $j$ 位为 $1$，则表示背包容量为 $j$ 时的最大价值为 $j$，且存在物品大小之和为 $j$；
- 第 $j$ 位为 $0$，则表示背包容量为 $j$ 时的最大价值为 $\max_{k=1}^{j-1}{k}\quad(dp_{i,k}=1)$。

## 状态转移

- 对于叶子结点 $u$，统一视作只有一个物品的小背包：

$$dp_{u,w_u}\coloneqq{1}$$

- 对于非叶子结点 $u$，有若干个小背包，依次进行合并：

$$
dp_{u,i}\coloneqq\max\left\{dp_{u,i},dp_{son_k,i},dp_{son_k,i-j}\right\}\quad
\left(\forall{i}\leq{w_{son_k}},\forall{j}\leq{w_u},dp_{son_k,i}={1}\right)
$$

正常代码如下：
```cpp
// 对于当前节点的所有的子节点
for (int son : e[u])
{
    // 枚举小背包中的物品（可能是几个小物品组合成的大物品）
    for (int i = 1; i <= w[son]; ++i)
    {
        if (dp[son][i] == 0)
        {
            continue;
        }

        // 做一次 0/1 背包，尝试将该物品放入当前结点背包
        for (int j = i; j <= w[u]; ++j)
        {
            dp[u][i] = std::max(dp[u][i], dp[son][i - j]);
        }
    }

    for (int i = 1; i <= w[son]; ++i)
    {
        dp[u][i] = std::max(dp[u][i], dp[son][i]);
    }
}
```

利用 `std::bitset` 优化后：
```cpp
for (int son : e[u])
{
    for (int i = dp[son]._Find_first(); i <= w[son]; i = dp[son]._Find_next(i))
    {
        dp[u] |= dp[u] << i;
    }
    
    dp[u] |= dp[son] & std::bitset<1000 + 1>(std::string(w[son] + 1, '1'));
}
```

**总时间复杂度：**$\mathcal{O}(n\cdot\left(\frac{\max\left\{w_i\right\}}{m}\right)^2),m\in\left\{32,64\right\}$。

PS：实际上以下操作的完整复杂度为 $\Theta(2\cdot\left(w_{son_k}+\frac{\max\left\{w_i\right\}}{m}\right))$，但存在 $\Theta(\frac{w_i}{m})$ 的方案。
```cpp
dp[u] |= dp[son] & std::bitset<1000 + 1>(std::string(w[son] + 1, '1'));
```

## 完整代码
```cpp
#include <bits/stdc++.h>

int main(void)
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);

    int n;
    std::cin >> n;

    std::vector<int> w(n + 1);
    
    for (auto& i : w | std::views::drop(1))
    {
        std::cin >> i;
    }

    std::vector<std::vector<int>> e(n + 1);

    for (int i = 0; i < n - 1; ++i)
    {
        int u, v;
        std::cin >> u >> v;

        e[u].push_back(v);
        e[v].push_back(u);
    }

    using bs = std::bitset<1000 + 1>;

    std::vector dp(n + 1, bs());

    auto dfs = [&](const auto& self, int u, int fa) -> void
    {
        bool has = false;

        for (const auto& son : e[u] | std::views::filter([&](int i) -> bool { return i != fa; }))
        {
            self(self, son, u);
            
            for (int i = dp[son]._Find_first(); i <= w[son]; i = dp[son]._Find_next(i))
            {
                dp[u] |= dp[u] << i;
            }
            
            dp[u] |= dp[son] & bs(std::string(w[son] + 1, '1'));

            has = true;
        }

        if (not has)
        {
            dp[u][w[u]] = true;
        }
    };

    dfs(dfs, 1, 1);

    int ans = 0;

    for (int i = dp[1]._Find_first(); i <= w[1]; i = dp[1]._Find_next(i))
    {
        ans = i;
    }

    std::cout << ans;

    return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/215810528) ExecTime：$94$ms，Memory：$1012$KB。

---


# 有线电视网

## 题目描述

某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。

从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。

现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。

写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。


## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/7yj4u55m.png)

如图所示，共有五个结点。结点 ① 为根结点，即现场直播站，② 为一个中转站，③④⑤ 为用户端，共 $M$ 个，编号从 $N-M+1$ 到 $N$，他们为观看比赛分别准备的钱数为 $3$、$4$、$2$。

从结点 ① 可以传送信号到结点 ②，费用为 $2$；

也可以传送信号到结点 ⑤，费用为 $3$（第二行数据所示）；

从结点 ② 可以传输信号到结点 ③，费用为$2$；

也可传输信号到结点 ④，费用为 $3$（第三行数据所示）。

如果要让所有用户（③④⑤）都能看上比赛，则信号传输的总费用为：$2+3+2+3=10$，大于用户愿意支付的总费用 $3+4+2=9$，有线电视网就亏本了，而只让 ③④ 两个用户看比赛就不亏本了。

[](https://paste.ubuntu.com/p/H9BMGJvFHH/)

## 样例 #1

### 输入

```
5 3
2 2 2 5 3
2 3 2 4 3
3 4 2```

### 输出

```
2
```

# 题解

## 作者：w36557658 (赞：23)

欢迎访问我的博客：[https://www.cnblogs.com/luyouqi233](https://www.cnblogs.com/luyouqi233)

本题解的目的是想给大家一个显然的时间复杂度为$O(nm)$的做法，~~从此再也不用苦苦去纠结代码时间复杂度到底是多少~~。

首先仍然安利这位大佬对$O(nm)$树形背包的讲解，配合观看效果更佳：[https://www.luogu.com.cn/blog/P6174/solution-p2014](https://www.luogu.com.cn/blog/P6174/solution-p2014)

这道题是一道裸的树形背包题，设$f[i][j]$表示以$i$为根往下找$j$个叶子的最大价值，那么答案就是所有$f[1][j]\ge 0$当中最大的$j$。

在dp之前，我们按照后序遍历序列重新编号（即遍历到一个节点时，先搜索节点的子树，为它们编号后再为这个节点编号）。

然后开始dp，首先初始化，对$f[i][j]$赋值$-INF$，当$j==0$时$f[i][j]=0$。

之后转移：

如果$i$点是叶子节点那么有$f[i][j]=max(f[i-1][j-1]+c[i],f[i-1][j])$和一般的0/1背包没什么区别

如果不是的话就有意思了，如果我们取$i$的话$f[i][j]=f[i-1][j]+c[i]$没什么问题，但是如果不取的话它和它的子树就一个都不能取了。

巧的是，由后序遍历定义不难推出$i$的子树节点编号在$[i-sz[i]+1,i]$之间（$sz[i]$为子树$i$的大小）。

所以不取的话$f[i][j]=f[i-sz[i]][j]$，综上$f[i][j]=max(f[i-1][j]+c[i],f[i-sz[i]][j])$

时间复杂度很容易看出是$O(nm)$的，这也是我写这篇题解的原因。

```cpp
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=3010; 
const int INF=1e9;
inline int read(){
	int X=0,w=0;char ch=0;
	while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
	while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
	return w?-X:X;
}
struct node{
	int to,nxt;
}e[N];
int n,m,cnt,head[N],c[N];
inline void add(int u,int v){
	e[++cnt].to=v;e[cnt].nxt=head[u];head[u]=cnt;
}
int f[N][N],idx[N],sz[N],tot;
void dfs(int u){
	sz[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		dfs(v);sz[u]+=sz[v];
	}
	idx[++tot]=u;
}
int main(){
	n=read(),m=read();
	for(int u=1;u<=n-m;u++){
		int k=read();
		for(int j=1;j<=k;j++){
			int v=read();c[v]=-read();
			add(u,v);
		}
	}
	for(int u=n-m+1;u<=n;u++)c[u]+=read();
	dfs(1);
	for(int i=0;i<=tot;i++)
		for(int j=1;j<=m;j++)
			f[i][j]=-INF;
	for(int i=1;i<=tot;i++){
		int u=idx[i];
		for(int j=1;j<=m;j++){
			if(n-m+1<=u)f[i][j]=max(f[i-1][j-1]+c[u],f[i-1][j]);
			else f[i][j]=max(f[i-1][j]+c[u],f[i-sz[u]][j]);
		}
	}
	for(int i=m;i>=0;i--){
		if(f[tot][i]>=0){
			printf("%d\n",i);return 0;
		}
	}
	return 0;
}
```


---

## 作者：zimindaada (赞：20)

## P1273 有线电视网

[题面](https://www.luogu.com.cn/problem/P1273)

这一道题可以看作一道很好的树形背包```DP```的入门题。由于有很多题解都没有讲的很透彻，当时看的我一脸懵圈，于是我决定好好写一篇题解。

我们令$dp_{u,i,j}$看作是以$u$为根，在用前$i$个儿子的时候，满足$j$个客户的要求时候的最大钱数。那么，转移方程就是$dp_{u,i,j} = max(dp_{u,i-1,j-k} + dp_{v,son_y,k}-w_{u,v})$,其中$son_y$表示$y$的儿子个数。

为什么呢？我们想一下，当我们```dfs```到了第$i$号儿子的时候，我们把前面$i-1$儿子都搞完了，并且我们先```dfs```第$i$号儿子的儿子，再进行```dp```,所以在进行```dp```的时候，$dp_{u,i-1}$和$dp_{v}$都算出来了。那么，我们可以寻找每一个$j$（表示当前要更新的状态的满足要求的客户数量）和$k$（帮助转移的上一个儿子的状态的儿子个数），其中$j<u$下管理的叶子节点的个数, $k < min(j,v$（即当前所枚举的儿子）所管的叶子节点个数$)$，来用已知的$dp_{u,i-1}$和$dp_{v}$来转移更新的节点的```dp```了。

然后，我们可以发现，转移方程$dp_{u,i,j} = dp_{u,i-1,j-k} + dp_{v,son_y,k}-w_{u,v}$中，状态是从第二维为$i-1$和$son_y$的状态转移过来的。我们可以考虑省掉第二维，这么做有什么问题吗？$dp_{u,i-1,j-k}$去掉i-1，转移的时候可以直接调用$dp_{u,j-k}$，毕竟这保留着$dp_{u,i-1,j-k}$的数据，而$dp_{v,son_y,k}$呢？也没问题。像这样自己调用自己，最后$dp_{u,j}$就表示以$u$为根，满足$j$个客户的要求时候的最大钱数，相当于原来的状态，所以省掉也没有任何问题。所以最后转移方程就会变成$dp_{u,j} = max(dp_{u,j-k} + dp_{v,k}-w_{u,v})$了。

剩下的细节会在代码注释里面讲一下。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 3005;
const int inf = 0x3f;
inline int read() {//快读
    int ret=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9') {if (ch=='-') f=-f;ch=getchar();}
    while (ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}


int n, m, a[maxn];
int last[maxn], cnt;
struct edge{int y, w, gg;} e[maxn<<1];
inline void add(int x, int y, int w){
    e[++cnt] = (edge){y,w,last[x]};
    last[x] = cnt;
}


int f[maxn][maxn];
inline int dfs(int x, int fa){

    if(x > n-m){//当自己是叶子节点（电视网用户）的时候
        f[x][1] = a[x];//那么只去自己所花费的代价就是自己愿意花的钱
        return 1;//以叶子节点为根的子树就只有自己一个叶子
    }
    
    int siz = 0, g;//siz表示自己为根的子树的叶子节点个数
    for(int i = last[x]; i; i = e[i].gg){
        int y = e[i].y;
        if(y == fa) continue;
        siz += (g = dfs(y,x));//g存自己每一个儿子所管辖的叶子个数
        //dp//
        for(int j = siz; j; --j){
            for(int k = 1; k <= min(j,g); ++k){
            /*
            为什么是k <=min(j,g)呢？
            因为不可能从y这个儿子下面有负数个人愿意办电视，所以k<=j
            又因为不可能底下只有g个用户，然后有比g多的人愿意看电视，所以k<=g
            */
                f[x][j] = max(f[x][j], f[x][j-k] + f[y][k] - e[i].w);
            }
        }
    }
    return siz;
}
int main(){
    memset(f,-inf,sizeof(f));//因为挣的最大钱数可能是负数，所以初始化成-inf
    n = read(), m = read();
    for(int i = 1; i <= n; ++i) 
        f[i][0] = 0;//因为每个下面没人愿意看电视时，不挣不亏，所以初始为0
    int kksk, aa, cc;
    for(int i = 1; i <= n-m; ++i){
        kksk = read();
        for(int j = 1; j <= kksk; ++j){
            aa = read(), cc = read();
            add(i,aa,cc); add(aa,i,cc);
        }
    }
    for(int i = n-m+1; i <= n; ++i) scanf("%d", &a[i]);

    dfs(1,-1);
    
    //统计答案，由题意和状态易得知答案是第一个大于0的f[1][i]
    for (int i = m; i >= 1; --i){
        if (f[1][i] >= 0){
            printf("%d",i);
            return 0;
        }
    }
}
```

[博客推广](https://www.luogu.com.cn/blog/zimindaada/)

---

## 作者：daklqw (赞：6)

补一发试炼场

题解里没有人讲$O(n^2)$的做法

很明显是一个树形背包

可以化成dfs序上的问题

有两种转移

1. 转移到子节点（就是dfs序为dfn[u] + 1的节点），这时候要加上自己的贡献，相当于选了自己
2. 转移到相同父亲的下一棵子树（就是dfs序为dfn[u] + size[u]的节点），这时候不能算上自己贡献，相当于自己没选

最后答案在$n+1$处

这种做法同时可以运用到[\[JSOI2016\]最佳团体](/problemnew/show/P4322)

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

const int MAXN = 3010;
const int INF = 0x3f3f3f3f;
inline void getmax(int & x, const int y) { if (y > x) x = y; }
int f[MAXN][MAXN], head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot, val[MAXN];
inline void addedge(int b, int e) {
	nxt[++tot] = head[b]; to[head[b] = tot] = e;
}
int n, m;
int dfn[MAXN], sz[MAXN], t0t, out[MAXN], vv[MAXN], ww[MAXN];
int dfs(int u) {
	sz[u] = 1; dfn[u] = ++t0t;
    vv[t0t] = val[u];
    ww[t0t] = u + m - 1 >= n;
	for (int i = head[u]; i; i = nxt[i]) 
		sz[u] += dfs(to[i]);
	out[dfn[u]] = t0t + 1;
	return sz[u];
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n - m; ++i) {
		int t, t1, t2;
		scanf("%d", &t);
		for (int j = 1; j <= t; ++j) {
			scanf("%d%d", &t1, &t2);
			addedge(i, t1);
			val[t1] -= t2;
		}
	}
	for (int i = n - m + 1; i <= n; ++i) {
		int t; scanf("%d", &t); val[i] += t;
	}
	dfs(1);
	for (int i = 0; i <= n + 1; ++i)
		for (int j = 0; j <= n; ++j)
			f[i][j] = -INF;
	f[1][0] = 0;
	for (int i = 1; i <= n; ++i) {
		for (int j = n; ~j; --j) if (f[i][j] > -INF) {
			getmax(f[out[i]][j], f[i][j]);
			getmax(f[i + 1][j + ww[i]], f[i][j] + vv[i]);
		}
	}
	for (int i = n; ~i; --i) if (f[n + 1][i] >= 0) {
		printf("%d\n", i);
		break;
	}
	return 0;
}
```

---

## 作者：上天台 (赞：4)

到目前为止，本题O(n^3)的题解（即分组背包）均可以被二叉树状（1500个转播站，1500个终点站）的数据卡掉，只有那篇真·O(n^2)的题解还活着。
如果n<=1000，采用这种构造方法可以以4kw左右跑过，因为实际上是O(sigma(sz[k]^2))，所以是O(n^3/某常数)，可以过；但是当n<=3000时，虽然在大部分情况下仍很快，但在这种特殊情况下转移次数高达11亿+。

此时应当学习有依赖的树形背包。

求出每个点的dfs序，按dfs序排序。令f[i][j]表示已经加入了**后**i个点，选了j个用户收到转播时，最大的盈利（可以是负数）。令cst[i]表示i是否是观众，是则为1；val[i]表示选i获得的盈利；如果第i个选了，f[i][j]=f[i+1][j-cst[i]]+val[i]；如果第i个未选，因为i不选则其子树一定不能被选，且如果子树全不选，i的兄弟之类dfs序>i的点选不选都不影响i，则f[i][j]=f[i+sz[i]][j]。

也就是说，是逆着完成的。不难发现，父亲的限制比儿子小，先把儿子点放进图里则父亲做时就不用考虑限制，每个点的val就变成了该点上观众付的钱-它到它父亲那条边的边权。

我的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(x,y,z) for(register int x=y; x<=z; x++)
#define downrep(x,y,z) for(register int x=y; x>=z; x--)
#define LL long long
#define ms(x,y,z) memset(x,y,sizeof(z))
#define repedge(x,y) for(register int x=hed[y]; ~x; x=edge[x].nex)
inline int read(){
    int x=0; int w=0; char ch=0;
    while(ch<'0' || ch>'9') w|=ch=='-',ch=getchar();
    while(ch>='0' && ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return w? (-x):x;
}
const int N=3005;
const int inf=0x3f3f3f3f;
int n,m,nedge,hed[N],sz[N],cst[N],val[N],id[N],tot,dfn[N],dp[N][N];
struct Edge{ int to,nex; }edge[N];
void addedge(int a,int b){
	edge[nedge].to=b; edge[nedge].nex=hed[a]; hed[a]=nedge++;
}
void dfs(int k){
	dfn[k]=++tot; sz[k]=1;
	repedge(i,k){
		int v=edge[i].to;
		dfs(v); 
		sz[k]+=sz[v]; 
	}
}
int cmp(int a,int b){ return (dfn[a]>dfn[b]); }
int main(){
	scanf("%d%d",&n,&m);
	nedge=0; rep(i,1,n) hed[i]=-1;
	rep(i,1,n-m){
		int x; scanf("%d",&x);
		rep(j,1,x){
			int y,z; scanf("%d%d",&y,&z);
			addedge(i,y); val[y]-=z; 			
		}
	}
	rep(i,n-m+1,n){ int x; scanf("%d",&x); val[i]+=x; } 
	rep(i,n-m+1,n) cst[i]=1; dfs(1); 
	rep(i,1,n) id[i]=i; sort(id+1,id+n+1,cmp);
	rep(i,0,n) rep(j,0,n) dp[i][j]=-inf;
	dp[0][0]=0;
	rep(i,1,n){
		int x=id[i]; 
		rep(j,0,n){
			if ((j>=cst[x])&&(dp[i-1][j-cst[x]]>-inf)) 
			dp[i][j]=max(dp[i][j],dp[i-1][j-cst[x]]+val[x]);
			if (dp[i-sz[x]][j]>-inf)
			dp[i][j]=max(dp[i][j],dp[i-sz[x]][j]);
		}
	}
	downrep(i,n,0)
		if (dp[n][i]>=0){
			printf("%d\n",i);
			break;
		}
	return 0;
} 
```



---

## 作者：封禁用户 (赞：4)

### 关于本题，楼下dalao已经讲得十分清楚了，这里提供一种泛化物品的理解。如果有误，烦请指出。

什么是泛化物品？泛化物品本质上是一个函数$\operatorname{value(v)}$，**它的价值由给它分配的体积$v$决定**。

举个例子，
>一个费用为$c$价值为$w$的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了$h(c)=w$其它函数值都为0的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当$v$被$c$整除时有$h(v)=v/c \times w$，其它函数值均为0。

（来自dd_engi的背包九讲）

我们定义$dp[u][j]$表示在以$u$为根节点的子树中，选择$j$个用户可以获得的最大利润。这同样可以看作是一个泛化物品。因为根据我们给这个子树分配的用户个数$j$，可以得到不同的价值$dp[u][j]$。

显然，对于每一个叶子结点，只有一个用户，则初始化$\operatorname{dp[leave][1] = userPayment[leave]}$。等式右边是每个用户愿意支付的金额，leave是叶子结点编号。

关键是如何转移。事实上，这是**泛化物品的求和问题**。假如某个节点$u$有两个儿子，这两个儿子的在各个用户个数上的最优解是相同子问题，我们只需要枚举给这两个儿子分配的用户个数即可：
```cpp
for (int j = sumUserInvolved/*已经发现的子树中叶子结点总数*/;j >= 0;--j)
{
	for (int k = 0;k <= sumUserInvolved/*!*/;++k)
	{
		if (k > sonUserInvolved) break;
		dp[u][j] = max(dp[u][j],dp[u][j - k] + dp[v][k]);
	}
}
```
不难看出，泛化物品的求和问题，仍然是一个泛化物品，因为我们在计算给节点$u$分配不同用户个数下，可以获得的最大利润。

最终，得到$dp[0][0...m]$后，我们只需倒序枚举用户数$m$，一旦发现利润大于等于0，就可以输出结果了。

需要注意的是，无论是在《选课》还是《金明的预算方案》中，每一个节点都有自己的体积，则在上述枚举k时，要减去根节点的体积。
```cpp
for (int k = 0;k <= sumUserInvolved - volume[u]/*!*/;++k)
```
只不过本题中用户全部在叶子节点上，所以不用减。

以上是我对本题的一些薄见，若有谬误，敬请斧正。
```cpp
int dfs(int u)
{
	int sumUserInvolved = 0,sonUserInvolved = 0;
	dp[u][0] = 0;
	if (isUser(u))
	{
		sumUserInvolved = 1;
		dp[u][1] = userPayment[u];
	}
	for (int i = head[u];i;i = info[i].nxt)
	{
		int v = info[i].to;
		int w = info[i].wgt;
		sonUserInvolved = dfs(v);
		sumUserInvolved += sonUserInvolved;
		for (int j = 1;j <= sonUserInvolved;++j) dp[v][j] -= w;
		for (int j = sumUserInvolved;j >= 0;--j)
		{
			for (int k = 0;k <= sumUserInvolved;++k)
			{
				if (k > sonUserInvolved) break;
				dp[u][j] = max(dp[u][j],dp[u][j - k] + dp[v][k]);
			}
		}
	}
	return sumUserInvolved;
}
```

---

## 作者：scallop (赞：3)

我们令 $f(i,j)$ 表示以 $i$ 为根节点的子树中，选择 $j$ 个客户后剩余的金钱。

那么转移方程为

$f(i,j)=max(f(i,j),f(i)(j-k)+f(p)(k))$

其中 $p$ 表示 $i$ 的所有儿子。我们一个个的枚举它们。

代码如下。

```cpp
#include <algorithm>
#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <vector>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <map>
using namespace std;

struct edge
{
    int v;
    int w;
     edge operator = (const edge &x)
     {
         v = x.v;
         w = x.w;
         return *this;
     }
};

const int MAXN = 5000;
int n, m;
int w[MAXN], s[MAXN], f[MAXN][MAXN];
vector<edge> e[MAXN];

void dfs(int p, int fa)
{
    f[p][0] = 0;
    for (auto i : e[p])
    {
        int v = i.v;
        if (v != fa)
        {
            dfs(v, p);
            for (int j = s[p]; j > -1; --j)
            {
                for (int k = s[v]; k > -1; --k)
                    f[p][j + k] = max(f[p][j + k], f[p][j] + f[v][k] - i.w);
            }
            s[p] += s[v];
        }
    }
    if (e[p].size() == 1)
    {
        f[p][1] = w[p];
        s[p] = 1;
    }
    return; 
} 

int read()
{
    int x;
    scanf("%d", &x);
    return x;
}

int main()
{
    n = read();
    m = read();
    for (int i = 0; i < 3000; ++i)
    {
        for (int j = 0; j < 3000; ++j)
            f[i][j] = -1e9;
    }
    for (int i = 1; i < n - m + 1; ++i)
    {
        int k = read();
        for (int j = 0; j < k; ++j)
        {
            int A = read(), C = read();
            e[i].push_back((edge){A, C});
            e[A].push_back((edge){i, C});
        }
    }
    for (int i = n - m + 1; i < n + 1; ++i)
        w[i] = read();
    dfs(1, -1);
    for (int i = m; i > -1; --i)
    {
        if (f[1][i] >= 0)
        {
            printf("%d\n", i);
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：AK_IOI的琪琪 (赞：2)

# 一、题目大意
有一棵有根树，每个叶子节点都有一个可赚的钱数，每走一条路都有相应的花费，问在不亏本的情况下从根节点能到达至多几个叶子节点。
# 二、分组背包
先理解一下分组背包~

一共有n组物品，背包容量v，每组物品至多选一个，每个物品至多选一次，物品有相应的重量w[i]，权值c[i]，问在不超过背包容量的情况下权值和最大为多少。我们用f[i]表示容量不超过i的情况下的最大权值
```
for (int i = 1; i <= n; i++) //遍历每一组
	for (int j = v; j >= 0; j--) //倒序枚举
		for (int k = 第一个物品; k <= 最后一个物品; k++) //枚举组内物品
			if (j >= w[k]) f[j] = max(f[j], f[j - w[k]] + c[k]); //转移 
```
可以看出第二行枚举时是倒序的，接下来我来说一下为什么

我们先看一下不加空间优化的原始版本：f[i][j]表示前i组物品选容量不超过j的最大权值。如果是正序枚举的，那么f[j-w[k]]一定比f[j]早被第k个物品更新过，那么在更新一次的话，第k个物品就被选了多次，就变成完全背包了

而对于这道题来讲，把每个节点都当成一个背包，把他的所有的子节点当成一个组，每组的物品的重量为1,2,3...每组的物品的权值为选1个用户、选2个用户、选3个用户...所能得到的利润。容易发现，这是满足分组背包的定义的。所以最终状态和转移也就出来了
```
f[i][j]表示以第i号节点为根的子树中，选取j个用户所能获得的最大利润
siz[i]表示以第i号节点为根的子树中，有这么多个叶子节点(相当于容量)
for (int i = head[rt]; i; i = e[i].nxt) { //枚举子节点 
        int x = e[i].id;
        if (x == fa) continue; //遍历到父亲跳过 
        dfs(x, rt);
        siz[rt] += siz[x];
        for (int j = siz[rt]; j >= 0; j--)
            for (int k = 0; k <= siz[x] && k <= j; k++)
                f[rt][j] = max(f[rt][j], f[rt][j - k] + f[x][k] - e[i].w); //转移 
    } 
```
可以发现，当遍历到第i个儿子时，siz[rt]还是前i个子节点的总叶节点数，这刚是最大的容量数。最后的答案就是最大的i使得f[1][i]>=0，只需倒序枚举一下就行了。
# 三、细节
~~细节决定成败~~

dp一定不要忘了赋初值！！！由于选大于0个用户的利润可能为负，而dp还取与本身的最大值，所以必须要赋负无穷
```
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) f[i][j] = -1e9;
```
最后附上code：
```
# include <bits/stdc++.h>
# define MAXN 3005
using namespace std;

struct edge {
    int id, nxt, w;
} e[2 * MAXN];

int n, m;
int tot, head[MAXN], siz[MAXN];
int f[MAXN][MAXN];

void add_edge(int x, int y, int z) {
    e[++tot].id = y;
    e[tot].nxt = head[x];
    e[tot].w = z;
    head[x] = tot;
}

void dfs(int rt, int fa) {
    if (rt >= n - m + 1) {
        siz[rt] = 1;
        return;
    }
    for (int i = head[rt]; i; i = e[i].nxt) {
        int x = e[i].id;
        if (x == fa) continue;
        dfs(x, rt);
        siz[rt] += siz[x];
        for (int j = siz[rt]; j >= 0; j--)
            for (int k = 0; k <= siz[x] && k <= j; k++)
                f[rt][j] = max(f[rt][j], f[rt][j - k] + f[x][k] - e[i].w);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    int num, v, w;
    for (int i = 1; i <= n - m; i++) {
        scanf("%d", &num);
        for (int j = 1; j <= num; j++) {
            scanf("%d%d", &v, &w);
            add_edge(i, v, w);
        }
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) f[i][j] = -1e9;
    for (int i = n - m + 1; i <= n; i++) scanf("%d", &f[i][1]);
    dfs(1, 0);
    for (int i = siz[1]; i >= 0; i--)
        if (f[1][i] >= 0) {
            printf("%d\n", i);
            break;
        }
    return 0;
}

```


---

## 作者：Tanktt (赞：2)

~~感觉大家讲得好复杂...~~


------------

首先先把题目读懂（特别是输入，看得清楚些）。
这道题就是求最大可以满足的用户数，保证这些叶子到根的每条边的和（重叠的边只记一次）<=叶子的支付费用和

那么就可以写转移方程了：

-  f[u][p][i]表示当前结点为u，在搜第p个儿子，总共可以满足i个用户的最大收益。

- ####  f[u][p][i]=max{ Σ(0<=j<=v下面的用户总数) f[v][p][j]+f[u][p-1][i-j]-w[u][v]  }       (v=son[u][p])

	为什么是这样呢？【当前儿子有j个用户，那么只有p之前的儿子总用户为i-j才行，同时也要减去u->v边的费用。】
    
- 但是我们还是会MLE。需要滚动一下，把p给滚掉——
	
   观察一下，p只与p-1有关，但是如果从前往后扫会有后效性（f[u][p][i]和f[u][p-1][i-j]，i-j<i，修改了再调用前面的自然会错）
  
  ####   因此i要从后往前扫。
   
### - 最后的方程：f[u][i]=max{f[v][j]+f[u][i-j]-w[u][v]}

另外f可能是负的，因此初始化需要定为-oo。


------------

### CODE

```cpp
#include<cstdio>
#include<algorithm>
#define reg register
#define FOR(x,l,r) for(reg int x=l; x<=r; x++)
using namespace std;
const int N=3012;
int n,m,head[N],nex[N*2],vet[N*2],val[N*2],edge;
int f[N][N],a[N];
inline void addedge(int u,int v,int c)
{
	nex[++edge]=head[u];
	head[u]=edge;
	vet[edge]=v;
	val[edge]=c;
}
inline int dfs(int u)
{
	if (u>=n-m+1) {f[u][1]=a[u];return 1;}//扫到叶子了
	int sum=0,s=0,v;
	for (reg int e=head[u];v=vet[e],e;e=nex[e])
	{
		s=dfs(v);sum+=s;
		for (int i=sum; i>=0; i--)//倒着扫
		{
			FOR(j,0,s)
			f[u][i]=max(f[u][i],f[v][j]+f[u][i-j]-val[e]);
		}
	}
	return sum;//把当前结点下的用户数传上去
}
int main()
{
	scanf("%d%d",&n,&m);
	int pp,x,y;
	FOR(i,1,n-m)
	{
		scanf("%d",&pp);
		FOR(j,1,pp)
		{
			scanf("%d%d",&x,&y);
			addedge(i,x,y);
		}
	}
	FOR(i,1,n)
		FOR(j,1,m) f[i][j]=-1000000012;//初始化
	FOR(i,n-m+1,n)
	scanf("%d",&a[i]);
	dfs(1);
	for (reg int i=m; i>0; i--)
	if (f[1][i]>=0) {printf("%d\n",i);break;}//只要f有收益就可以直接输出
	return 0;
}
```

~~OVER~~

---

## 作者：Cloyir (赞：2)

### 蒟蒻第一次发题解
这道题刚看到(直到现在)我还是没看懂怎么开二维的背包，于是开了一个一维的,~~居然~~过了。
#### 具体思路：
主题还是围绕着背包来写的,设dp[i]表示如果给i个用户放电视后的最大钱数(注意这个钱是可以为负数的),即:
```cpp
dp[i]=max(dp[i],dp[i-1]+x);
//x表示顾客给你的钱-给这个顾客放电视要多少钱
```
那有同学就会问了：转播站到转播站要的钱怎么破?其实,从转播站到转播站的钱可以用dfs的思想解决。先临时存储一下dp数组的值,把dp数组每个值都减去这个路径要的钱,扫一遍后再把dp和临时存储的数组比一下大小,保证dp的每一种情况都是最优的。最后的找答案也很简单,从m(一共就m个顾客)往下找,找到的第一个不为负数的值时停止,输出答案就好了。
dp数组的初始化也很好理解，~~显然~~：

```cpp
for(int i=1;i<=n;i++)dp[i]=-inf;
dp[0]=0;
```
然后就是怎么具体实现的问题了:
```cpp
#include<iostream>
#include<vector>
using namespace std;
const int inf = 0x7f7f7f7f-1,M = 3001;
struct Node{
	int x,y;
	Node(int x,int y):x(x),y(y){}
};vector <Node> v[M];
int n,m,son[M],w[M],dp[M];
void search(int x){
	for(int i=m;i>0;i--)if(dp[i-1]!=-inf)
		dp[i]=max(dp[i],dp[i-1]+x);
}//其实这里更新dp和普通的01背包很像
void dfs(int x){
	for(int i=0;i<son[x];i++){
		Node t = v[x][i];
		if(son[t.x]){
			int tot[M];
			for(int i=0;i<=m;i++){
				tot[i]=dp[i];
				if(dp[i]!=-inf)dp[i]-=t.y;
			}
			dfs(t.x);
			for(int i=0;i<=m;i++)dp[i]=max(dp[i],tot[i]);
		}
		else search(w[t.x]-t.y);
	}
}
int main(){
	cin>>n>>m;
	for(int i=0;i<=n;i++)w[i]=-1,dp[i]=-inf;dp[0]=0;
	//初始化，其实w[i]=-1应该可以去掉，个人习惯
	for(int i=1;i<=n-m;++i){
		cin>>son[i];
		for(int j=0;j<son[i];j++){
			int x,y;cin>>x>>y;
			v[i].push_back(Node(x,y));
		}
	}
	for(int i=n-m+1;i<=n;++i)cin>>w[i];
	dfs(1);//用dfs去找树形背包难道不香吗
	for(int i=m;i;i--)if(dp[i]>=0){
		cout<<i;return 0;
	}
}
```
本蒟蒻语文不好,所以题解写的很菜,请谅解。~~如果还有不懂的地方,当我就懂了吗,问写其他题解的julao们呀~~

---

## 作者：Tweetuzki (赞：2)

我用的是多叉树转二叉树的方法，这题只要分四种情况考虑就行了：

① 这是用户节点，且没有兄弟（右儿子）；

② 这是一个用户节点，但有右子（兄弟节点）；

③ 这是转播站，且没有兄弟节点；

④ 这是个转播站，且有兄弟节点。

时间复杂度只有O(n^2logn)，跑得比背包还快（神奇）

```cpp
#include <cstdio>

struct tree {
    int lc,rc; //多叉树转二叉树：左儿子右兄弟 
    int val; //选择选择节点i时能赚多少钱（该节点的值（如果是中转站则为0）-父节点连到这个节点的边的值） 
    int num; //表示该节点为根的树，最多有多少个用户节点 
};

const int maxn=3000;
int n,m;
tree a[maxn+1];
int dp[maxn+1][maxn+1];

int maximum(int x, int y) {
    if (x>y) return x;
    return y;
}

//计算以x为根的树最多有多少个用户节点 
int count(int x) {
    int res=0;
    //如果自己是用户节点，答案+1 
    if (a[x].lc==0)
        res++;
    //如果有左右子，则递归统计 
    if (a[x].rc!=0)
        res+=count(a[x].rc);
    if (a[x].lc!=0)
        res+=count(a[x].lc);
    a[x].num=res;
    return res;
}

void init() {
    scanf("%d%d",&n,&m);
    //第i个转播站的信息 
    for (int i=1; i<=n-m; i++) {
        int ii,k,vv;
        scanf("%d",&k);
        //对k=1的特殊处理，要放在这个转播站的左儿子上 
        scanf("%d%d",&ii,&vv);
        a[i].lc=ii;
        a[ii].val-=vv;
        //其余的放在之前处理过的兄弟节点的右儿子上 
        for (int j=2; j<=k; j++) {
            int x,v;
            scanf("%d%d",&x,&v);
            a[ii].rc=x;
            a[x].val-=v;
            ii=x;
        }
    }
    //用户节点的数据 
    for (int i=n-m+1; i<=n; i++) {
        int x;
        scanf("%d",&x);
        a[i].val+=x;
    }
    //计算结构体中的num的值，搜索时有用 
    count(1);
}

//dp[root][x]表示以root为根的树，里面有x个用户节点，所能赚到的最多的钱数 
int dfs(int root, int x) {
    if (dp[root][x]!=0) return dp[root][x]; //记忆化搜索 
    if (x==0) return 0; //如果没有连任何一个用户节点，则不赚不亏，返回0 
    //如果这是用户节点，且没有兄弟（右儿子），那么就加上这个节点的值
    if (a[root].lc==0&&a[root].rc==0)
        return dp[root][x]=a[root].val;  
    //如果这是转播站且没有兄弟节点，那么只能往左子（儿子节点）走 
    //因为经过这个节点，所以要加上这个答案。再递归左子树。  
    if (a[root].lc!=0&&a[root].rc==0)
        return dp[root][x]=dfs(a[root].lc,x)+a[root].val;
    //如果是一个用户节点，但有右子（兄弟节点）
    //那么分选与不选两种情况考虑 
    if (a[root].lc==0&&a[root].rc!=0) {
        //选的话要加上它的值
        int res=dfs(a[root].rc,x-1)+a[root].val;
        //不选的话有限制条件：现在要保留的用户节点数(x)不大于它右子树里的用户节点数（保证它的右子里至少有x个用户节点） 
        if (a[a[root].rc].num>=x)
            res=maximum(res,dfs(a[root].rc,x)); //取两种情况中的较优情况 
        return dp[root][x]=res;
    }
    //否则这是个转播站，且有兄弟节点 
    int res=-0x7F7F7F7F;
    //枚举在分给左子树i个用户节点，右子树x-i个用户节点的可能性，取最优 
    //特别注意：当不传给这个中转站，只给它的兄弟节点（右子）时，可以不取这个节点的值！
    //故i从1开始，而非0（我因为这个WA了好多次） 
    for (int i=1; i<=x; i++) {
        if (a[a[root].lc].num<i) continue; //如果左子树里只有不到i个用户节点，不满足条件 
        if (a[a[root].rc].num<x-i) continue; //右子同理 
        res=maximum(res,dfs(a[root].lc,i)+dfs(a[root].rc,x-i)+a[root].val);
    }
    //如果全给其兄弟节点时兄弟节点里可以有这么多用户节点(num>=x)，则取较优值 
    if (a[a[root].rc].num>=x)
        res=maximum(res,dfs(a[root].rc,x));
    return dp[root][x]=res;
}

int main() {
    init();
    for (int i=m; i>=0; i--) { //从m~0逆序枚举给i个用户信号的情况 
        int ans=dfs(1,i); //从根节点(1)开始记忆化搜索 
        //如果不会亏本，则跳出循环，直接输出答案 
        if (ans>=0) {
            printf("%d\n",i);
            break;
        }
    }
    return 0;
}
```

---

## 作者：QWsin (赞：1)

**
。是我智商不够还是怎么的题解看了好半天还看了源程序才看懂

确实比较像背包问题 只不过换成树状的了（表示之前没做过）

物品是用户

dp[i][j]表示i节点 在它的后代中选了j个的最大收入

dp[i][j]=max(dp[i][j],dp[i][j-k]+dp[v][k]-w)

意思是在当前儿子中选了k个用户 并减去和儿子中间那一条边的权值

儿子就一个一个搜啦= =

注意k的范围是在1至儿子后代中的用户数

并且j是要从大到小循环

所以递归函数要传回节点的用户数

存边什么的就邻接表搞一搞就好啦 存单向就行

另外dp[n][0]都等于0；（找了十分钟才找出来这个错）

最后输出答案就从大往小找收入大于等于0的点

**

```cpp

#include<cstdio> 
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=3000+10;

int n,m,first[maxn],next[maxn],w[maxn],v[maxn],money[maxn];
int cnt=0;
void add_edge(int uu,int vv,int ww)
{
    v[++cnt]=vv;
    w[cnt]=ww;
    next[cnt]=first[uu];
    first[uu]=cnt;
}

void init_data()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
      first[i]=-1;
    for(int u=1,son;u<=n-m;u++)
    {
        scanf("%d",&son);
        for(int j=1,v,w;j<=son;j++)
        {
            scanf("%d%d",&v,&w);
            add_edge(u,v,w);
        }
    }
    for(int u=n-m+1;u<=n;u++)scanf("%d",money+u);
}

int dp[maxn][maxn];
int f(int u)
{
    if(u>n-m)
    {
        dp[u][1]=money[u];
        return 1;
    }
    int sum=0;
    for(int i=first[u];i!=-1;i=next[i])
    {
        int x=f(v[i]);sum+=x;
        for(int j=sum;j;j--)
          for(int k=1;k<=x;k++)
            dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v[i]][k]-w[i]);
    }
    return sum;
}

int main()
{
    init_data();
    memset(dp,-60,sizeof(dp));
    for(int u=1;u<=n;u++)
      dp[u][0]=0;
    f(1);
    int i=m;
    for(;i;i--) if(dp[1][i]>=0) break;
    printf("%d",i);
    return 0;
}

```(c/c++)


---

## 作者：你祖奶我很ok (赞：1)

|  |  |
| :----------: | :----------: |
|  |  |
|  |  |
做过一些题目，应该就能看出这是一个树上的分组背包。

我们设dp[i][j]表示在以i为根的子树中，满足j个客户的需求所能获得的最大收益，

那么在最终求最多客户时，只要求最大的dp[1][i]>=0的i就行了。

至于分组背包，我们设dp[i][u][j]表示以u为根的子树，仅用前i个儿子，满足j个客户取得最大价值，

那么dp[i][u][j]=max(dp[i-1][u][j-k]+dp[full_son_size[v]][v][k]);

而i这一维可以直接用滚动数组优化掉。

而这个背包，有些细节优化是可以过掉讨论中的那个极限数据。

如，将下面题解代码中sum+=x改到dp后。然后把dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v][k])

改为dp[u][j+k]=max(dp[u][j+k],dp[u][j]+dp[v][k])，最后把dp[u][j]先用一个数组t保存一下就行了。

多叉树上的背包详解。

参考代码：

```c
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=3010;
int n,m,EdgeCnt=0;
int dp[N][N],val[N],a[N],t[N];
struct Edge{
    int to,w,next;
}e[N*N];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void addedge(int u,int v,int w){
    int p=++EdgeCnt;
    e[p].to=v;e[p].w=w;e[p].next=a[u];
    a[u]=p;
}
int dfs(int u){
    if (u>n-m){
        dp[u][1]=val[u];
        return 1;
    }
    int sum=0;
    for (int p=a[u];p;p=e[p].next){
        int v=e[p].to;
        int tk=dfs(v);
        for (int j=0;j<=sum;j++)t[j]=dp[u][j];
        for (int j=0;j<=sum;j++)
            for (int k=0;k<=tk;k++)
                dp[u][j+k]=max(dp[u][j+k],t[j]+dp[v][k]-e[p].w);
        sum+=tk;
    }
    return sum;
}
int main(){
    n=read(),m=read();
    memset(dp,~0x3f,sizeof(dp));
    for (int u=1;u<=n-m;u++){
        int size=read();
        for (int j=1;j<=size;j++){
            int v=read(),w=read();
            addedge(u,v,w);
        }
    }
    for (int i=n-m+1;i<=n;i++)
        val[i]=read();
    for (int i=1;i<=n;i++)
        dp[i][0]=0;
    dfs(1);
    for (int i=m;i>0;i--)
        if (dp[1][i]>=0){
            printf("%d",i);
            break;
        }
    return 0;
}
```

---

## 作者：wzhhahah (赞：1)

### 这个题解可能会有些麻烦但是用二叉树解决挺棒的（本人蒟蒻）

树转二叉树的方式挺简单的就是节点的儿子成为左儿子，节点右边的兄弟成为右儿子

这道题的输入是有序的所以二叉树建起来比较容易


状态转移方程：f[i][j]=max(f[left[i]][k]+f[right[i]][j-k-1]+v[i],f[right[i]][j])

f[i][j]代表在节点i下及其兄弟中选择j个叶子节点（用户点）的最大盈利

v[i]代表该节点挣的钱（转播站不赚钱）减去该节点与其父节点相连所花的费用


可惜用二叉树的话需要分出4种情况：

1. 该节点有左儿子（不是叶子节点）且有右儿子（右边有兄弟）的话就用上面的方程

2. 该节点只有左儿子，那么只能找他的子树 f[i][j] = f[left[i]] [j,deep+1] + v[i]

3. 该节点只有右儿子，那么最大盈利是选择该节点（叶子节点）和其兄弟或不选择该节点只选兄弟中的较优情况

4. 该节点什么都没有，那他就是没兄弟的叶子节点，只有j=1时有效其余情况取极小值


写出的代码T了4个点，想了好久写出了个小优化：使j不大于该节点最多可选的叶子（第十点304ms很慢）


代码如下：


```cpp
#include <cstdio>
int n, m, t;
int left[3001], right[3001], v[3001];
int link[3001][3001];        //与i节点相连的节点（离散化邻接矩阵）
int count[3001];
int f[3001][3001];
bool cal[3001][3001];    //是否已计算过
int minv;        //极小值
int ans;
int max(const int& a, const int& b)
{
    return a > b ? a : b;
}
int getC(const int& i)
{
    for (int j = link[i][0]; j >= 1; j--)
    {
        count[i] += getC(link[i][j]);
        count[link[i][j]] = count[i];
    }
    count[i]++;
    return count[i];
}
int getF(const int& i, const int& j)
{
    if (i <= n - m&&j > count[i]) return f[i][j] = minv;        //优化
    if (!j) return 0;
    if (cal[i][j]) return f[i][j];
    f[i][j] = minv;
    if (left[i] && right[i])        //该节点有子树可以向下找 有兄弟节点可以向右找
        for (int k = 1; k <= j; k++)
            f[i][j] = max(f[i][j], max(getF(left[i], k) + getF(right[i], j - k) + v[i], getF(right[i], j)));
    else if (left[i])                //该节点只有子树只能向下找
        f[i][j] = getF(left[i], j) + v[i];
    else if (right[i])                //该节点是叶子节点且有兄弟节点
        f[i][j] = max(getF(right[i], j - 1) + v[i], getF(right[i], j));
    else if (j == 1)                //该节点是叶子节点但没有右兄弟了    若要找的个数大于一则不存在
        f[i][j] = v[i];
    cal[i][j] = 1;
    return f[i][j];
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1, to, w; i <= n - m; i++)
    {
        scanf("%d", &t);
        scanf("%d%d", &to, &w);
        link[i][0] = t;
        link[i][1] = to;
        left[i] = to;
        v[to] -= w;
        minv -= w;
        int last = to;
        for (int j = 1; j < t; j++)
        {
            scanf("%d%d", &to, &w);
            link[i][j + 1] = to;
            right[last] = to;
            v[to] -= w;
            minv -= w;
            last = to;
        }
    }
    for (int i = 1; i <= m; i++)
    {
        scanf("%d", &t);
        v[n - m + i] += t;
    }
    getC(1);
    for (int i = 1; i <= m; i++)
        if (getF(1, i) >= 0)
            ans = i;
    printf("%d", ans);
    return 0;
}
```

---

## 作者：jins3599 (赞：0)

裸的树上分组背包...

其实刚开始做这类题的时候觉得很难，多做几道套路就出来的。

我们设计`f[i][j]`为以i为根的子树，选择j个叶子结点的最大收益.

转移非常显然`f[i][j] = f[i][j - k] + f[son][k] - w`

然而我们在转移的时候有一个细节，就是`j`需要用到`j - k`的数据，于是我们可以倒序枚举`j`来避免数据覆盖的情况。

初始化：
对于所有叶子结点`f[i][1] = w[i]` 即可。

其余的结点赋值为```-inf```.

$Code:$
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 3000 + 5;

int head[N] , cnt , m , n;
int f[N][N];

struct Edge {
	int to , nxt , w;
}e[N << 1];

void add(int u , int v , int w) {
	e[++ cnt].to = v;
	e[cnt].w = w;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

int sz[N];
void pre(int now , int fa) {
	for(int i = head[now] ; i ; i = e[i].nxt) {
		int v = e[i].to;
		if(v == fa) continue;
		pre(v , now);
		sz[now] += sz[v];
	}
}

void dfs(int now , int fa) {
	for(int i = head[now] ; i ; i = e[i].nxt) {
		int v = e[i].to , w = e[i].w;
		if(v == fa) continue;
		dfs(v , now);
		for(int j = sz[now] ; j >= 1 ; j -- ) {
			for(int k = 1 ; k <= sz[v] ; ++ k) {
				f[now][j] = max(f[now][j] , f[now][j - k] + f[v][k] - w);
			}
		}
	}
}

int main () {
	//freopen("data.txt" , "r" ,stdin);
	scanf("%d %d" , &n , &m);
	for(int i = 1 ; i <= n - m ; ++ i) {
		int k; scanf("%d" , &k);
		while(k -- ) {
			int v , w; scanf("%d %d" , &v , &w);
			add(i , v , w); add(v , i , w);
		}
	}
	for(int i = 1 ; i <= n ; ++ i)
		for(int j = 1 ; j <= m ; ++ j) f[i][j] = -0x3f3f3f3f; 
	for(int i = n - m + 1 ; i <= n ; ++ i) scanf("%d" , &f[i][1]) , sz[i] = 1;
	
	pre(1 , 1);
	dfs(1 , 1);
	int ans = 0;
	for(int i = 1 ; i <= sz[1] ; i ++) {
		if(f[1][i] >= 0) ans = i; 
	}
	
	printf("%d\n" , ans);
	return 0;
}
```

---

## 作者：Azuree (赞：0)

[查看原题请戳这里](https://www.luogu.org/problem/P1273)

我们通过在树上跑分组背包的方式来完成这道题。

## 状态设计

我们设计状态$f[i][j]$表示在以$i$为根的子树上选取$j$个叶子节点（用户）共给信号能够获得的最大价值（当然，这个最大价值可能是负的，这都没有关系）。

## 状态转移

我们考虑泛化物品。

>泛化物品的背包:
这种背包，没有固定的费用和价值，它的价值是随着分配给它的费用而定。在背包容量为  的背包问题中，当分配给它的费用为$v_i$时，能得到的价值就是$h(v_i)$。这时，将固定的价值换成函数的引用即可。--OI-wiki

我们把以每个节点$k$为根的子树的所有选取节点数量的状态分成一组（因为我们不能在某一颗子树上先选了$i$个节点，然后又选了$j$个节点，这样会重复）。

我们遍历这颗树的过程相当于在枚举组别，每当我们便利到某个儿子节点，我们对其做完一轮0/1背包（分组背包的第$2$、$3$层循环）后，就用该子节点的状态去尝试更新当前节点的所有状态。

## 代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register
#define int long long 

using namespace std;

int read()
{
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

int n,p,m,k,cnt,ans,x,y,z,d[1000005],f[3005][3005],siz[100005],sum,v[100005];

struct edge{
	int to,nex,w;
}e[2000005];

void add(int x,int y,int z)
{
	e[++cnt].to = y;
	e[cnt].w = z; 
	e[cnt].nex = d[x];
	d[x] = cnt;
}

int dfs(int u)
{
	if(u > n - m)
	{
		f[u][1] = v[u];
		return 1;
	}
	int tj = 0,k;
	for(int i = d[u]; i; i = e[i].nex)
	{
		int v = e[i].to;
		k = dfs(v);
		tj += k;
		for(int l = tj; l > 0; l--)
			for(int j = k; j >= 0; j--)
				f[u][l] = max(f[u][l],f[u][l - j] + f[v][j] - e[i].w);
	}
	return tj;
}

signed main()
{
	n = read(); m = read();
	for(int i = 1; i <= n - m; i++)
	{
		k = read();
		for(int j = 1; j <= k; j++) y = read(), z = read(), add(i,y,z);
	}
	for(int i = n - m + 1; i <= n; i++) v[i] = read(),sum += v[i];
	memset(f,-100,sizeof(f));
	for(int i = 1; i <= n; i++) f[i][0] = 0; 
	dfs(1);
	for(int i = m; i >= 0; i--)
		if(f[1][i] >= 0)
    	{
    		printf("%d\n",i);
    		return 0;
		}
	return 0;
}
```

---

## 作者：Sakurajima_Mai (赞：0)

# 树形动规
-----------
若令$dp[u][k]$表示以$u$为根的子树中，选择$k$个用户是所得到的最大收益，则对于每个子树$u$来说存在两种可能：


 1.选择在当前的子树中$num$个的结点最大价值
 
 2.不选择当前的子树中$num$个结点的价值
 
 故考虑每颗子树$dp[u][k]$，选择一颗子树中的结点相当于$dp[u][k-num]+dp[v][num]-w[i]$,而不选择则为$dp[u][k]$
 
- 其中$w[i]$为从$u$到其儿子的边权，$num$取值为$[1,size(son)]$,表示选取结点数量
 
 故得到转移方程$dp[u][k] = max(dp[u][k-num]+dp[v][num]-w[i],dp[u][k])$
 
 最后统计$dp[1][k]$,$k$取值为$[1,size(tree)]$是最大的$k$是的$dp$值大于0的即可。

---

## 作者：huiwang17 (赞：0)

树上分组背包。
令$f[i][j]$表示以结点$i$为根节点的子树开始，满足了$j$个叶子节点的需求所能获得的最大利润值，那么使利润值$f[1][i]$大于等于0的最大的$i$就是答案。

再考虑一下怎么求$f[i][j]$的值，树形DP肯定是会从儿子的属性更新到父亲的属性的，这里首先枚举父亲一共满足了多少个叶子的需求，然后每次都从一个新的儿子【背包】中掏出$k$个底层计算好了的能带来最大利润的叶子，考虑新儿子在这$j$个叶子中贡献了$k$个叶子时，是否能更新答案。

这个儿子所能贡献的$k$的范围是$[1,  sum[child] ]$【$sum$数组表示子树中有多少个叶子】】，$k$等于0️⃣的时候相当于对父亲结点的值没有造成影响，所以可以不考虑。枚举到更新$k$个叶子时，父亲的$temp$利润应该是：【本儿子贡献的$k$个叶子带来的利润】+【前面的叶子节点贡献剩余的叶子带来的利润 -【父亲修到本儿子的一条路所用的花费】

如果考虑到本儿子贡献的$k$个叶子利润更大的话，那么父亲的利润应该被更新。

这里枚举父亲一共满足了多少个叶子时要倒序，否则比较优的叶子会更新答案很多次。

关于初始条件，首先所有的利润都应该初始化为负无穷，然后对所有子树，完全不选的利润是0️⃣；对所有叶子，选一个的利润$f[leaf][1]$就是他给的钱

```cpp
#include <iostream>
#include <cstdlib>
#include <algorithm>

using namespace std;
#define ll long long
const ll MAXN = 2e5 + 7;
const ll INF = 1e9;
const ll mod = 1e9 + 7;

struct edge{
    int to;
    int cost;
    edge(int aa, int bb){to = aa; cost = bb;}
    edge(){}
};

int n, m;
vector<edge> son[3005];
int val[3005];
int sum[3005];
int f[3005][3005];

void cal(int x){ //DP部分
    f[x][0] = 0;
    if(son[x].empty()){
        f[x][1] = val[x];
        sum[x] = 1;
        return;
    }
    for(int i = 0; i < son[x].size(); i++)
        cal(son[x][i].to);
    for(int i = 0; i < son[x].size(); i++){
        sum[x] += sum[son[x][i].to];
        for(int j = sum[x]; j >= 0; j--){
            int child = son[x][i].to;
            for(int k = 1; k <= sum[child]; k++){
                f[x][j] = max(f[x][j], f[x][j-k] + f[child][k] - son[x][i].cost);
            }
        }
    }
}

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n - m; i++){
        int k;
        cin >> k;
        for(int j = 0; j < k; j++){
            int a, c;
            cin >> a >> c;
            son[i].push_back(edge(a, c));
        }
    }
    for(int i = 1; i <= n; i++){
        if(son[i].empty()){
            int x;
            cin >> x;
            val[i] = x;
        }
    }
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++)
            f[i][j] = -INF;
    cal(1);
    for(int i = sum[1]; i >= 0; i--)
        if(f[1][i] >= 0){
            cout << i << endl;
            return 0;
        }
}

```


---

## 作者：_YYY_ (赞：0)

博客食用效果Max
[$$\text{$\color{red}\large\mathfrak{blog}$}$$](https://www.cnblogs.com/IcedMoon/p/11427914.html)





# 题目简介

## 题目描述

> 某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。
>
> 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。
>
> 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。
>
> 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。

## 输入输出

> 输入文件的第一行包含两个用空格隔开的整数N和M，其中2≤N≤3000，1≤M≤N-1，N为整个有线电视网的结点总数，M为用户终端的数量。
>
> 第一个转播站即树的根结点编号为1，其他的转播站编号为2到N-M，用户终端编号为N-M+1到N。
>
> 接下来的N-M行每行表示—个转播站的数据，第i+1行表示第i个转播站的数据，其格式如下：
>
> K A1 C1 A2 C2 … Ak Ck
>
> K表示该转播站下接K个结点(转播站或用户)，每个结点对应一对整数A与C，A表示结点编号，C表示从当前转播站传输信号到结点A的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。

> 输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。$$

# 题目分析

## 思路分析

应该很简单能看出这是一个树上分组背包，考虑状态

设f[u][i]代表以u为节点，选i个用户所能得到的钱的最大值

转移方程:

对于节点v，分配其j个用户，则节点u只需要分配到i-j个用户，如此进行枚举

有:f[u][i]=max(f[u][i],f[[v][j]+f[u][i-j]-e(w))

# 代码
```
#include<bits/stdc++.h>
#define re register
#define ll long long
using namespace std;
inline int read()
{
	ll k=1,sum=0;
	char c=getchar();
	for(;c<'0' || c>'9';c=getchar()) if(c=='-') k=-1;
	for(;c>='0' && c<='9';c=getchar()) sum=sum*10+c-'0';
	return sum*k;
} 
const int N=3e3+10;
int n,m;
int val[N];
int dp[N][N];
int head[N],cnt;
struct Edge{
	int to,nxt,w;
}edge[N<<1]; 
inline void Add(int x,int y,int w){
	edge[++cnt].to=y;edge[cnt].nxt=head[x];edge[cnt].w=w;head[x]=cnt;
}
inline int dfs(int x){
	if(x>n-m){
		dp[x][1]=val[x];
		return 1;
	}int sum=0;
	for(re int i=head[x];i;i=edge[i].nxt){
		int y=edge[i].to;
		int t=dfs(y);sum+=t;
		for(re int j=sum;j>0;--j){
			for(re int k=t;k;--k){
				if(j-k>=0) dp[x][j]=max(dp[x][j],dp[y][k]+dp[x][j-k]-edge[i].w);
			}
		}
	}
	return sum;
}
int main()
{
	memset(dp,~0x3f,sizeof(dp));
	n=read();m=read();
	for(re int i=1;i<=n-m;++i){
		int Arknights=read();
		for(re int j=1;j<=Arknights;++j){
			int v=read(),w=read();
			Add(i,v,w);
		}
	}
	for(re int i=n-m+1;i<=n;++i) val[i]=read();
	for(re int i=1;i<=n;++i) dp[i][0]=0;
	dfs(1);
	for(re int i=m;i;--i){
		if(dp[1][i]>=0) {
			cout<<i;return 0;
		}
	}
	return 0;
}
```

---

## 作者：鸭鸭菌dlctfu (赞：0)

###### 太难了这题。。。被一个小细节爆卡
###### 当时开始做的时候是下午两点，做完一看已经4点了。。。。
###### 思路：
###### 设f[i][j]为第i个节点可满足j个用户的最大利益，于是结合树状背包模板的状态转移方程，
###### 得出：f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w)
###### 直接代码吧，里面有注释：
```cpp
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
struct edge{
	int u,v,w;
};
vector<edge> g[5001];//我是用vector+结构体存图的。。
int n,m,u,v,w,f[5001][5001];
int val[100001];
int dfs(int u,int fa){//u是遍历到的节点，fa是该节点的父亲
    if(u>n-m){//假如该节点就是根节点（用户终端）
        f[u][1]=val[u];//赋值
        return 1;
    }
    int sum=0,t;//t是以u为根的子树大小,结合下面代码理解
    for(int i=0;i<g[u].size();i++){
        int v=g[u][i].v,w=g[u][i].w;
        if(v==fa)continue;//这两行不解释，树形dp常规套路
        t=dfs(v,u),sum+=t;//结合上面代码理解
        for(int j=sum;j>=0;j--){
            for(int k=1;k<=t;k++){//遍历一下组的元素
                f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w);
            }
        }
    }
    return sum;
}
int main(){
    memset(f,-0x7f,sizeof(f));//我就是这里卡的两小时。。。必须得将f数组初始化为一个极小的负数，因为f数组也有可能是负数，而且不能太小，也不能太大
    cin>>n>>m;
    for(int i=1;i<=n-m;i++){
        int k;cin>>k;
        for(int j=1;j<=k;j++){
            int x,y;cin>>x>>y;
            g[i].push_back((edge){i,x,y});
            g[x].push_back((edge){x,i,y});
        }
    }
    for(int i=n-m+1;i<=n;i++)cin>>val[i];
    for(int i=1;i<=n;i++)f[i][0]=0;//初始化一下不选的情况
    dfs(1,0);
    for(int i=m;i>=1;i--){
        if(f[1][i]>=0){
            cout<<i;
            break;
        }
    }
    return 0;
}

```


---

## 作者：panhuachao (赞：0)

刚看到这题目时，真的有些懵逼

第一感觉：设个一维数组，记f[i]为第i个节点所能满足的最大用户数

然而，经典的bug：
```
5 3
2 2 4 5 10
2 3 10 4 10
1 1 10000
```
显然，对于这种~~鬼~~数据就不成立了。

#### 于是，学习了题解大佬的方法：设f[i][j]表示第i个节点满足j个用户的最大利益。

于是，程序的大体框架就可以打好了
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#define INF 0x6ffffff
using namespace std;
int n,m,k;
struct Edge{ int son,cost; };
vector<Edge> tree[3100];
int f[3100][3100];
int dp(int now){
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) tree[i].clear();
	for(int i=1;i<=n-m;i++){
		scanf("%d",&k);
		for(int j=1;j<=k;j++){
			int a,c;
			scanf("%d%d",&a,&c);
			tree[i].push_back(Edge{a,c});
		}
		for(int j=1;j<=m;j++) f[i][j]=-INF; f[i][0]=0;
	}
	for(int i=n-m+1;i<=n;i++){
		int w;
		scanf("%d",&w);
		f[i][1]=w; f[i][0]=0;
		for(int j=2;j<=m;j++) f[i][j]=-INF; f[i][0]=0;
	}
	dp(1);
	for(int i=m;i>=1;i--)
		if(f[1][i]>=0){
			printf("%d\n",i);
			return 0;
		}
	printf("%d\n",0);
	return 0;
} 
```
（这段代码是从完整代码中截取的，初始化看不懂没关系）

#### 然而，还少一个最头痛的dp()  ~~/流汗~~

于是，我们开始想：如何递推？？？

显然，我们要找到一个数列c使c的和为j。

这时，f[i][j]=数列c的最大收益

~~所以，我这种蒟蒻的第一感觉是深搜~~

### 然而，大佬会想到动规。。。。~~/顶礼膜拜~~

于是，我们开始想动规。

我成功地抛弃了树来思考：

于是写了一句

```now:g[j][user]=max(g[j-1][user],g[j-1][user-k]+f[j][k]-w)   k=1..j```

大概就是当 当前节点为now的时候，我新建一个数组g，表示1..j个叶子结点满足user个用户的最大收益。可以得到这个关系式（图中叶子结点就用1..j来表示，递推式清楚点）

#### 然而显然，这也不大现实：要么是函数里设置数组MLE，要么就是循环嵌套（可能跟我的写法也有关系，因为我对于叶子结点的更新和对于g的更新是同步的，这就意味着要是我设在主函数里会在嵌套函数时改动g值）

于是，我想到了滚动数组，即把g的第1维j压缩掉，这样user就是f[i][j]中的j了

观察一下，是user-k，所以要倒序递推

于是，g就被成功压缩到f中了

```cpp
	for(vector<Edge>::iterator i=tree[now].begin();i<tree[now].end();i++){
		int nowson=dp(i->son); totson+=nowson;
		for(int j=totson;j>=1;j--)
			for(int k=1;k<=j;k++)
		    	if(f[i->son][k]!=-INF&&f[now][j-k]!=-INF)
				    f[now][j]=max(f[now][j],f[now][j-k]+f[i->son][k]-i->cost);
	}
```
以-INF标识能不能实现（一般只有用户超限才会出现-INF），加了保险

注意点：

  1.必须要totson而不能直接用m，不然会TLE
  
  2.除f[叶子节点][1]和f[节点][0]外其他的都要为-INF，不然会造成更新过多，而出现bug（~~40分，直接卡掉6个点~~）
  
  
完整代码：
```cpp
/*  now:g[j][user]=max(g[j-1][user],g[j-1][user-k]+f[j][k]-w)  */ 
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#define INF 0x6ffffff
using namespace std;
int n,m,k;
struct Edge{ int son,cost; };
vector<Edge> tree[3100];
int f[3100][3100];
int dp(int now){
	if(tree[now].empty()) return 1;
	int totson=0;
	for(vector<Edge>::iterator i=tree[now].begin();i<tree[now].end();i++){
		int nowson=dp(i->son); totson+=nowson;
		for(int j=totson;j>=1;j--)
			for(int k=1;k<=j;k++)
		    	if(f[i->son][k]!=-INF&&f[now][j-k]!=-INF)
				    f[now][j]=max(f[now][j],f[now][j-k]+f[i->son][k]-i->cost);
	}
	return totson;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) tree[i].clear();
	for(int i=1;i<=n-m;i++){
		scanf("%d",&k);
		for(int j=1;j<=k;j++){
			int a,c;
			scanf("%d%d",&a,&c);
			tree[i].push_back(Edge{a,c});
		}
		for(int j=1;j<=m;j++) f[i][j]=-INF; f[i][0]=0;
	}
	for(int i=n-m+1;i<=n;i++){
		int w;
		scanf("%d",&w);
		f[i][1]=w; f[i][0]=0;
		for(int j=2;j<=m;j++) f[i][j]=-INF; f[i][0]=0;
	}
	dp(1);
/*	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++)
		    printf("%4d",f[i][j]==-INF?-1:f[i][j]);
		printf("\n");
	} */
	for(int i=m;i>=1;i--)
		if(f[1][i]>=0){
			printf("%d\n",i);
			return 0;
		}
	printf("%d\n",0);
	return 0;
} 
```


---

## 作者：李寻欢 (赞：0)

这是一道树形dp......

f[i][j]表示在第i个节点可有j个观众的最大money数(注意可以为负).

转移的话一个一个枚举父亲的最大观众数和儿子节点的最大观众数即可,每个节点的最大观众数可以预处理出来.

最后答案就是f[1][最大的j]>=0,如果全小于0则输出0.

上代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 3010
#define inf 0x7f7f7f7f
using namespace std;
int f[N][N],n,cnt,head[N],m,b[N],son[N];
struct Edge{
	int v,w,nxt;
}E[N<<1];
int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
void addedge(int u,int v,int w)
{
	E[++cnt].v=v;
	E[cnt].w=w;
	E[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs1(int u,int fa)//预处理
{
	if(b[u])son[u]=1,f[u][1]=b[u];//son是每个节点的最大观众数
	for(int i=head[u];i;i=E[i].nxt)
	{
		int v=E[i].v;
		if(v==fa)continue;
		dfs1(v,u);
		son[u]+=son[v];
	}
}
void dfs(int u,int fa)
{
	for(int i=head[u];i;i=E[i].nxt)
	{
		int v=E[i].v;
		if(v==fa)continue;
		dfs(v,u);
		for(int j=son[u];j>=1;--j)//枚举父亲
			for(int k=son[v];k>=1;--k)//枚举儿子
				f[u][j]=max(f[u][j],f[v][k]+f[u][j-k]-E[i].w);
		for(int j=son[v];j>=1;--j)f[u][j]=max(f[u][j],f[v][j]-E[i].w);
	}
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=n-m;++i)
	{
		int k=read(),a,c;
		for(int j=1;j<=k;++j)
		{
			a=read();c=read();
			addedge(i,a,c);addedge(a,i,c);
		}
	}
	for(int i=n-m+1;i<=n;++i)b[i]=read();
	memset(f,-inf,sizeof f);
	dfs1(1,0);dfs(1,0);
	for(int i=son[1];i>=1;--i)if(f[1][i]>=0){printf("%d\n",i);return 0;}
	printf("0\n");
	return 0;
}
```

~~~~

---

## 作者：mrwalking (赞：0)

/\*
f(i, j)，表示子树i转播给j个用户的最大收益值

这题可以看作是树上的分组背包，每个子树看作是一组物品，这一组物品可以取1个，2个...j个

然后就是套用分组背包的算法了

\*/





















```cpp
//程序有两个地方比较难理解：
//1、如何保证在取数过程中，叶结点无重复，如f[i][i-j]中的叶结点 f[v][j]中的叶结点不重复
//2、for(i=ye[u];i>0;i--)正确 for(i=1;i<=ye[u];i++)错误
//针对样例1，列出动态规划过程，能说明上述问题
//for(i=ye[u];i>0;i--)正确 过程如下：
f[1][1]=max(f[1][1],f[1][1]+f[5][0]-3)
f[1][1]=max(f[1][1],f[1][0]+f[5][1]-3)    1->5 取一个 最大值
f[2][1]=max(f[2][1],f[2][1]+f[4][0]-3)
f[2][1]=max(f[2][1],f[2][0]+f[4][1]-3)    2->4 取一个 最大值
f[2][2]=max(f[2][2],f[2][2]+f[3][0]-2)
f[2][2]=max(f[2][2],f[2][1]+f[3][1]-2)
f[2][2]=max(f[2][2],f[2][0]+f[3][2]-2)    2->4 2->3 取两个 最大值
f[2][1]=max(f[2][1],f[2][1]+f[3][0]-2)
f[2][1]=max(f[2][1],f[2][0]+f[3][1]-2)    2->4 2->3 取一个 最大值
f[1][3]=max(f[1][3],f[1][3]+f[2][0]-2)
f[1][3]=max(f[1][3],f[1][2]+f[2][1]-2)
f[1][3]=max(f[1][3],f[1][1]+f[2][2]-2)
f[1][3]=max(f[1][3],f[1][0]+f[2][3]-2)    1->5 1->4 1->3 取三个 最大值
f[1][2]=max(f[1][2],f[1][2]+f[2][0]-2)
f[1][2]=max(f[1][2],f[1][1]+f[2][1]-2)
f[1][2]=max(f[1][2],f[1][0]+f[2][2]-2)    1->5 1->4 1->3 取两个 最大值
f[1][1]=max(f[1][1],f[1][1]+f[2][0]-2)
f[1][1]=max(f[1][1],f[1][0]+f[2][1]-2)    1->5 1->4 1->3 取一个 最大值
//for(i=1;i<=ye[u];i++)错误 过程如下：
f[1][1]=max(f[1][1],f[1][1]+f[5][0]-3)
f[1][1]=max(f[1][1],f[1][0]+f[5][1]-3)    1->5 取一个 最大值
f[2][1]=max(f[2][1],f[2][1]+f[4][0]-3)
f[2][1]=max(f[2][1],f[2][0]+f[4][1]-3)    2->4 取一个 最大值
f[2][1]=max(f[2][1],f[2][1]+f[3][0]-2)
f[2][1]=max(f[2][1],f[2][0]+f[3][1]-2)    2->4 2->3 取一个 最大值
f[2][2]=max(f[2][2],f[2][2]+f[3][0]-2)
f[2][2]=max(f[2][2],f[2][1]+f[3][1]-2)
f[2][2]=max(f[2][2],f[2][0]+f[3][2]-2)    2->4 2->3 取两个 最大值
f[1][1]=max(f[1][1],f[1][1]+f[2][0]-2)
f[1][1]=max(f[1][1],f[1][0]+f[2][1]-2)    1->5 1->4 1->3 取一个 最大值
f[1][2]=max(f[1][2],f[1][2]+f[2][0]-2)
f[1][2]=max(f[1][2],f[1][1]+f[2][1]-2)    
//此处有问题 f[1][1]可能是1->4 故f[1][2]有可能取成 1->4 1->4 错误从此处开始
f[1][2]=max(f[1][2],f[1][0]+f[2][2]-2)    1->5 1->4 1->3 取两个 最大值
f[1][3]=max(f[1][3],f[1][3]+f[2][0]-2)
f[1][3]=max(f[1][3],f[1][2]+f[2][1]-2)
f[1][3]=max(f[1][3],f[1][1]+f[2][2]-2)
f[1][3]=max(f[1][3],f[1][0]+f[2][3]-2)    1->5 1->4 1->3 取三个 最大值    
//分析的过程中，同时将上述的两个顾虑问题解决。
#include <stdio.h>
#include <string.h>
#define INF 999999
int head[3100],cnt=0,ye[3100],f[3100][3100];//f[i][j] i节点及以下共j个用户的最大收益 因收益有正有负，故初始化为绝对值比较大的负数
struct node{//邻接表
    int to,next,c;
}e[3100];//有向图
void addedge(int u,int v,int c){
    cnt++,e[cnt].to=v,e[cnt].c=c,e[cnt].next=head[u],head[u]=cnt;
}
int max(int a,int b){
    return a>b?a:b;
}
void dfs(int u){
    int v,b,i,j,c;//b边
    b=head[u];
    while(b){
        v=e[b].to,c=e[b].c;
        dfs(v);
        ye[u]+=ye[v];
        for(i=ye[u];i>=1;i--)
            for(j=0;j<=i;j++)
                f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]-c);//1 此处写成 f[u][j]=max(f[i][j],f[u][i-j]+f[v][j]-c);
        b=e[b].next;
    }
}
int main(){
    int n,m,i,j,p,k,a,c,ans=-INF;
    memset(head,0,sizeof(head));
    memset(ye,0,sizeof(ye));
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            f[i][j]=-INF;
    for(i=1;i<=n;i++)
        f[i][0]=0;//取0个，值为0
    p=n-m;
    for(i=1;i<=p;i++){
        scanf("%d",&k);
        for(j=1;j<=k;j++){
            scanf("%d%d",&a,&c);
            addedge(i,a,c);
        }
    }
    for(i=p+1;i<=n;i++){
        scanf("%d",&c);
        f[i][1]=c,ye[i]=1;
    }
    dfs(1);
    for(i=ye[1];i>=1;i--){
        ans=i;
        if(f[1][i]>=0)break;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Skywalker_David (赞：0)

这道题有其他做法,但也可以看做树形背包,这里只讨论他的树形背包做法.首先根据题目描述建立一棵树,每个叶节点的体积为1,价值为p[i]-cost[i],非叶节点体积为0,价值为-cost[i].求出取各个体积时最大的费用即可求出在不亏本的情况下的最大用户数.接着直接从后往前扫一遍就可以得出答案.

代码如下(我的):

```delphi

type  
        int=longint;  
  
const  
        oo=99999999;  
  
var  
        i,j,k,m,n:int;  
        l,r,p,w:array[-1..3000]of int;  
        f:array[-1..3000,0..3000]of int;  
        x,y:int;  
  
function max(x,y:int):int;  
begin  
        if x>y then exit(x)  
                else exit(y);  
end;  
  
procedure dfs(rt,v:int);  
var i,j:int;  
begin  
        if v<1 then exit;  
        j:=l[rt];  
        while j<>-1 do begin  
                for i:=0 to v do f[j,i]:=f[rt,i];  
                dfs(j,v-w[j]);  
                for i:=1 to v do f[rt,i]:=max(f[rt,i],f[j,i-w[j]]+p[j]);  
                j:=r[j];  
        end;  
end;  
  
begin  
        fillchar(l,sizeof(l),$FF);  
        f[1,0]:=0;r[-1]:=-1;  
        read(n,m);  
        for i:=1 to n-m do begin  
                read(k);  
                for j:=1 to k do begin  
                        read(x,y);  
                        r[x]:=l[i];l[i]:=x;  
                        p[x]:=-y;  
                end;  
        end;  
        for i:=1 to m do begin  
                read(x);  
                inc(p[n-m+i],x);  
                f[1,i]:=-oo;  
                w[n-m+i]:=1;  
        end;  
        dfs(1,m);  
        i:=m;  
        while (f[1,i]<0) do dec(i);  
        write(i);  
end.  

```
需要留心的是f[1]的初值,想一想为什么要这么赋值.

细心的同学可能会注意到,我的过程与徐持衡的不同,但两者是完全等价的,效率上也没有很大的区别.树形背包的基本算法就是这样.具体的题目中,往往会给你一棵树,然后给每个节点一个权值之类的东西和一些限制,然你求这么选得到最大/最小收益,这种题目就有可能是树形背包的模型.


---

## 作者：TsReaper (赞：0)

树上的背包。对于某一个点，它的每个儿子都能被看作一类物品，该类物品能取0，1，2，...num个（num是以该儿子为根的子树有多少叶子节点）。我们算出每个点供应0~num个用户能获得的最大利润。最后在根节点中查找，最大的利润≥0的用户数就是答案。

虽然分析起来似乎是一个O(n^3)的算法，但是由于无效的状态比较多，可以AC。


---


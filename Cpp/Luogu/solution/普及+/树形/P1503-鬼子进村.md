# 鬼子进村

## 题目背景

小卡正在新家的客厅中看电视。电视里正在播放放了千八百次依旧重播的《亮剑》，剧中李云龙带领的独立团在一个县城遇到了一个鬼子小队，于是独立团与鬼子展开游击战。


## 题目描述

县城里有 $n$ 个用地道相连的房子，第 $i$ 个只与第 $i-1$ 和第 $i+1$ 个相连。这时有 $m$ 个消息依次传来：

1. 若消息为 ```D x```：鬼子将 $x$ 号房子摧毁了，地道被堵上。

1. 若消息为 ```R``` ：村民们将鬼子上一个摧毁的房子修复了。

2. 若消息为 ```Q x```：有一名士兵被围堵在 $x$ 号房子中。

李云龙收到信息很紧张，他想知道每一个被围堵的士兵能够到达的房子有几个。


## 说明/提示

$1\leq n,m\leq 5\times 10^4$。

若士兵被围堵在摧毁了的房子中，那只能等死了。。。。。。

## 样例 #1

### 输入

```
7 9
D 3
D 6
D 5
Q 4
Q 5
R
Q 4
R
Q 4
```

### 输出

```
1
0
2
4
```

# 题解

## 作者：66666a (赞：56)

这题用线段树，平衡树都能过

但是其实我们可以用STL中的set

设一个set记录当前被炸的房子编号，并且维护编号从小到大，当我们查询x时，找到在s中比x大的第一个和比x小的最后一个，位置之差减1即为答案。

代码出奇的短

```cpp
#include<bits/stdc++.h>
#define M 50010
using namespace std;
int q[M],tail,n,m;
set<int> s;
set<int>:: iterator it;
int main()
{
    scanf("%d%d",&n,&m);
    s.insert(0);
    s.insert(n+1);
    for(int i=1;i<=m;i++)
    {
        char c;
    cin>>c;//用scanf会把空格读进来
        if(c=='D')
        {
            int x;                      // 加入x
            scanf("%d",&x);
            s.insert(x);
            q[++tail]=x;
        }
        if(c=='Q')
        {
            int x;                       //查询
            scanf("%d",&x);
            it=s.lower_bound(x);
            if(*it==x)
            {
                printf("0\n");
                continue;
            }
            int ans=*it-*(--it);
            printf("%d\n",ans-1);
        }
        if(c=='R')                    //删除
        {
            it=s.find(q[tail--]);
            s.erase(it);
        }
    }
    return 0;
}
```

---

## 作者：凌幽 (赞：31)

    
    
    
    
    
    
    
```cpp
    // 有点小惊讶，暴力模拟就A掉了
    // 题目说这n个房子，其中第i个只与第i-1个和第i+1个相连，那么这一定是一条链
    // 样例很贴心，连续两次修复上次（最后）被摧毁的房子
    // 这就启示着我们需要记录一下被摧毁的房子，并且这些被摧毁的房子一定是越晚摧毁越早被修好，那就用一个栈呗，先进后出
    // 被围困的士兵只能向两边走，走到下一个房子被摧毁为止
    // 我们可以扫一遍n个房子，选取士兵所在的这段区间，但是这样并不是很优美
    // 既然士兵能够活动的区间端点是被摧毁的房子（开区间），那我们直接从栈里遍历找端点不就好了吗
    //AC code
    #include<bits/stdc++.h>
    using namespace std;
    #define R register
    #define N 50005
    #define max(a,b) (a)>(b) ? (a) : (b)
    #define min(a,b) (a)<(b) ? (a) : (b)
    int n,m;
    int top,s[N];
    bool vis[N];
    inline int dy(){
        scanf("%d%d",&n,&m);
        while(m--){
            R char op[2]; scanf("%s",op);
            if(op[0]=='R'){vis[s[top--]]=0;continue;} // 修好上一个被摧毁的
            R int a; scanf("%d",&a);
            if(op[0]=='D') vis[a]=1,s[++top]=a;// 被摧毁
            else { // 被围堵
                R int l=0,r=n+1;
                for(R int i=1;i<=top;++i){
                    if(s[i]<=a) l=max(s[i],l);
                    if(s[i]>=a) r=min(s[i],r);
                }
                if(l==r) printf("%d\n",0); // 开区间的左右端点相同，那么一定为空
                else printf("%d\n",r-l-1); // 开区间
            }
        }
        return 0;
    }
    int QAQ = dy();
    int main(){;}

```

---

## 作者：LordLeft (赞：30)

~~震惊，平衡树题目没人写朴素treap？~~

首先，我们看到前两项操作，很自然地就能想到用栈，把每次$D$操作炸毁的屋子记录下来，$R$操作就把栈顶元素弹出

那么对于查询操作，我们考虑用平衡树记录被炸毁的屋子，也就是在栈操作中加上平衡树操作，将被炸毁的屋子的编号插入平衡树中。

在求解$Q$操作时，我们可以利用平衡树查前驱后继的操作方便的求出围堵每个士兵的两个房子的编号，~~利用小学数学~~可以得到士兵$i$能到达的村庄个数为 $\text{nxt(i)}-\text{pre(i)}-1$ 。为了防止一些奇怪的问题(如越界)，预先插入$0$号和$n+1$号节点，与一般的插入$\infty$和$-\infty$不同

然后发现过不了样例，因为题目中有这么一句话

>若士兵被围堵在摧毁了的房子中，那只能等死了。。。。。。

这里只要用一个$bool$数组记录哪些屋子被炸掉就行了

朴素treap代码奉上

```cpp
#include<iostream>
#include<ctime>
#include<cstdlib>
#include<stack>
using namespace std;
const int N=100005,inf=((1<<30)-1)<<1;
int n,m,cnt,root;	
int son[N][2],val[N],wei[N],size[N],cpy[N];	//左右儿子，权值，重量，子树大小，相同权值个数(不需要)
int add(int v){	//新建节点
	val[++cnt]=v;
	size[cnt]=1;
	cpy[cnt]=1;
	wei[cnt]=rand();
	return cnt;
	}
void mix(int id){	//更新子树大小
	size[id]=size[son[id][0]]+size[son[id][1]]+cpy[id];
	}
void build(){	//初始化，插入哨兵节点
	root=add(0);
	son[root][1]=add(n+1);
	mix(root);
	}
void rotate(int &id,int d){	//treap核心操作，旋转
	int e=son[id][d^1];
	son[id][d^1]=son[e][d];
	son[e][d]=id;
	id=e;
	mix(son[id][d]);
	mix(id);
	}	
void insert(int &id,int v){	//插入权值为v的节点
	if(!id){
		id=add(v);
		return;
		}
	if(v==val[id]){
		cpy[id]++;
		}	
	else{
		int d=(v<val[id]?0:1);
		insert(son[id][d],v);
		if(wei[id]<wei[son[id][d]]){
			rotate(id,d^1);
			}
		}
	mix(id);
	}	
void remove(int &id,int v){	//删除权值为v的节点
	if(!id){
		return;
		}
	if(v==val[id]){
		if(cpy[id]>1){
			cpy[id]--;
			mix(id);
			return;
			}	
		else if(son[id][0]||son[id][1]){
			if(!son[id][1]||wei[son[id][0]]>wei[son[id][1]]){
				rotate(id,1);
				remove(son[id][1],v);
				}
			else{
				rotate(id,0);
				remove(son[id][0],v);
				}	
			}
		else{
			id=0;
			}	
		return;	
		}	
	else if(v<val[id]){
		remove(son[id][0],v);
		}
	else{
		remove(son[id][1],v);
		}	
	mix(id);
	}	
int rank(int id,int v){	//查询v的排名(不需要)
	if(!id){
		return 0;
		}
	if(v==val[id]){
		return size[son[id][0]]+1;
		}	
	else if(v<val[id]){
		return rank(son[id][0],v);
		}	
	else{
		return size[son[id][0]]+cpy[id]+rank(son[id][1],v);
		}	
	}
int value(int id,int v){//查询第v大的权值(不需要)
	if(!id){
		return inf;
		}	
	if(v<=size[son[id][0]]){
		return value(son[id][0],v);
		}	
	else if(v<=size[son[id][0]]+cpy[id]){
		return val[id];
		}	
	else{
		return value(son[id][1],v-size[son[id][0]]-cpy[id]);
		}	
	}
int pre(int v){	//查询v的前驱
	int id=root,prev;
	while(id){
		if(val[id]<v){
			prev=val[id];
			id=son[id][1];
			}
		else{
			id=son[id][0];
			}	
		}
	return prev;	
	}
int nxt(int v){	//查询v的后继
	int id=root,next;
	while(id){
		if(val[id]>v){
			next=val[id];
			id=son[id][0];
			}
		else{
			id=son[id][1];
			}	
		}
	return next;	
	}
stack<int>des;	//记录用的栈
bool vis[N];	//和bool数组
int main(){
	srand((int)time(0));
	cin>>n>>m;
	build();
	char opt;
	int x;
	for(int i=1;i<=m;i++){
		cin>>opt;
		if(opt=='D'){	//摧毁房子
			cin>>x;
			des.push(x);
			vis[x]=1;
			insert(root,x);
			}
		if(opt=='R'){	//修复房子
			remove(root,des.top());
			vis[des.top()]=0;
			des.pop();
			}	
		if(opt=='Q'){	//查询士兵能到达的房子个数
			cin>>x;
			if(vis[x]){
				cout<<0<<endl;
				}
			else{	
				cout<<nxt(x)-pre(x)-1<<endl;
				}
			}	
		}
	return 0;
	}
```

GL～

---

## 作者：dlhham (赞：20)

这道题可以这么做：

对于每一次询问来说，其实就是想知道，从X这个点，向右能有多少个连续的点，向左能有多少个连续的点，那么对于一个方向考虑，另一个方向同理。以向左为例：

我们用a[i]=1代表i这个方式没有被摧毁，a[i]=0表示已经被摧毁，那么sum[i]就表示从1~i一共有多少个房子没有被摧毁，有了这个东西以后，则有如下发现：对于0<=j<i，如果sum[i]-sum[j]=i-j,则说明[i+1,j]这个连续的区间的房子都是完好的。

有了这个发现，我们可以用一个树状数组来表示每个点是否是完好的，如果从完好到被摧毁，则insert(i,-1),如果从摧毁到修复，则insert(i,1)。维护了这个东西以后，每次查询的时候，for循环从i开始到左边，找到最远的sum[i]-sum[j]=i-j即可。

考虑到如果最远的那个点是k,那么k的右边一定都满足sum[i]-sum[j]=i-j，而k的左边一定都不满足，因此可以二分来做。

时间复杂度O(m\*log(n)\*log(n))


---

## 作者：Forever丶CIL (赞：13)

可以用线段树来解决，建一棵树来维护每段区间的没被炸毁的

房子数，然后对于每次炸毁，就把炸毁的节点修改为零，对于每次修复

就把修复节点修改为一（这都是线段树的单点修改操作）

关键是如何进行查询操作：

对于每一个点，它向左，最多到它左边第一个为零的节点

它向右，最多到它右边第一个为零的点，所以，我们的目的就是找出

这两个点的坐标，然后一减再加一就是答案

如何找呢？

因为我们记录了每个区间的完好的房子数，所以对于一个区间，如果

它的值，比它右端点-左端点+1小，就说明这个区间里有零了，所以每次

递归线段树查询就可以了


------------

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int op=0;
int h[500000];
int n,m,ans,a,anst;
int sl[500000];
int cc1,cc2;
char si;
struct house
{
    int l;
    int r;
    int v;
};
struct house T[500001*4];
//建树 
void buildtree(int f,int ne,int poi)
{
    T[poi].l=f;
    T[poi].r=ne;
    if(f==ne)
    {
        T[poi].v=h[f];
        return ;
    }
    buildtree(f,(f+ne)/2,poi*2);
    buildtree((f+ne)/2+1,ne,poi*2+1);
    T[poi].v=(T[poi*2].v+T[poi*2+1].v);
}
//修改操作 
void insert(int go,int val,int poi)
{
    if(T[poi].l==go&&T[poi].r==go)
    {
        T[poi].v=val;
        h[go]=val;    
        return ;
    }
    int mid=(T[poi].l+T[poi].r)/2;
    if(go>mid) insert(go,val,poi*2+1);
    else if(go<=mid) insert(go,val,poi*2);
    T[poi].v=T[poi*2].v+T[poi*2+1].v;
}
/*
qh函数用来计算要找的区间中完好的房子数

（就是一个线段树区间查询啦）

*/
void qh(int f,int ne,int poi)
{
    if(T[poi].l==f&&T[poi].r==ne)
    {
        anst+=T[poi].v;
        return ;
    }
    int mid=(T[poi].l+T[poi].r)/2;
    if(f>mid) qh(f,ne,poi*2+1);
    else if(ne<=mid) qh(f,ne,poi*2);
    else 
    {
        qh(f,mid,poi*2);
        qh(mid+1,ne,poi*2+1);
    }
}
void search1(int f,int ne,int poi)
{
	if(T[poi].l==f&&T[poi].r==ne&&T[poi].v==0&&f==ne)
    {
        cc1=f;//找到了在询问点左端最近的一个零 
        return ;
    }
    if(T[poi].l==f&&T[poi].r==ne&&T[poi].v==1&&f==ne)
    {
        cc1=0;//这里有一个特判，如果找到最后，发现左边所有的点都是1，那么最左边记为0 
        return ;
    }
    int mid=(T[poi].r+T[poi].l)/2;
    if(f>mid) search1(f,ne,poi*2+1);
    else if(ne<=mid) search1(f,ne,poi*2);
    else 
    {
        anst=0;
        qh(T[poi*2+1].l,ne,poi);//因为我们找的是最左边的那个，所以如果现在所在的节点左右子树中都有零，优先往右跳 
        if(anst<ne-T[poi*2+1].l+1)
            search1(mid+1,ne,poi*2+1);//往右跳，继续递归 
        else search1(f,mid,poi*2);
    }
}
//对于寻找在询问点右边最近为零的点，道理同上 
void search2(int f,int ne,int poi)
{
    if(T[poi].l==f&&T[poi].r==ne&&T[poi].v==0&&f==ne)
    {
        cc2=f;
        return ;
    }
    if(T[poi].l==f&&T[poi].r==ne&&T[poi].v==1&&f==ne)
    {
        cc2=n+1;
        return ;
    }
    int mid=(T[poi].l+T[poi].r)/2;
    if(f>mid) search2(f,ne,poi*2+1);
    else if(ne<=mid) search2(f,ne,poi*2);
    else 
    {
        anst=0;
        qh(f,T[poi*2].r,poi);
        if(anst<T[poi*2].r-f+1)//if(anst<T[poi*2].r-f+1)
            search2(f,mid,poi*2);
        else search2(mid+1,ne,poi*2+1);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        h[i]=1;
    }
    buildtree(1,n,1);
    for(int i=1;i<=m;i++)
    {
        cin>>si;
        //scanf("%c",&si);
        if(si=='D')
        {
            scanf("%d",&a);
            insert(a,0,1);
            sl[++op]=a;
        }
        if(si=='Q')
        {
            ans=0;
            scanf("%d",&a);
            if(!h[a])
            {
                printf("0\n");
                continue ;
            }
            if(a==1) 
            {
                search2(a+1,n,1);
                cc1=0;
            }
            else if(a==n)
            {
                search1(1,a-1,1);
                cc2=n+1;
            }
            else
            {
                search1(1,a-1,1);
                //printf("* %d *",cc1);
                search2(a+1,n,1);
                //printf("* %d *",cc2);
            }
            printf("%d\n",cc2-cc1-1);
        }
        if(si=='R')
        {
            int t=sl[op--];
            insert(t,1,1);
        }
    }
    return 0;
}
```


------------

可能不是很好理解吧，不懂的话可以画出线段树的图来，自己模拟着走一遍。

RP++ 


---

## 作者：Hugo_Minion (赞：13)

这道题可以用treap来写，我用的是fhq-treap，虽然代码有点长，但是思路其实很简单：  
先把0和n+1插入treap，之后每次D操作都把小鬼子炸掉的房子插入treap，并用一个栈存储炸掉的房子，每次R操作就把栈里最外面的炸掉的房子取出，从treap中删除。  
对于Q操作，我们首先需要判断x房是否被炸掉了，如果被炸掉就输出0，只需要用一个bool数组记录每个点是否被炸掉即可，如果没有被炸掉，就求出x的前缀和后缀，然后用后缀-前缀-1即可。
直接上代码：
```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;

const int maxn=100005,inf=1e9+1;
int son[maxn][2],rnd[maxn],num[maxn],size[maxn];//son[x][0]：x的左子结点，son[x][1]：x的右子结点，rnd[x]：x的rand值，num[x]：x的结点值，size[x]：以x为根的树的大小
int root,tot;
bool vis[maxn];//记录x是否被炸
int stack[maxn],idx;//栈存储已炸的房子

void build(int &x,int delta){	//建造结点
    rnd[x=++tot]=rand();
    num[x]=delta;
    size[x]=1;
}	

void update(int x){	//向上推size，每个结点的size=左子结点的size+右子结点的size+1
    if(!x)	return;
    size[x]=size[son[x][0]]+size[son[x][1]]+1;
}

void merge(int &x,int l,int r){//fhq-treap的合并操作，将两颗树合并成一棵
    if(!l or !r)	x=l+r;
    else if(rnd[l]<=rnd[r])
        x=l,merge(son[x][1],son[x][1],r),update(x);
    else
        x=r,merge(son[x][0],l,son[x][0]),update(x);
}

void split(int x,int &l,int &r,int k){//fhq-treap的分裂操作，将两棵树以结点值序号分裂，序号<=k的分在左子树，反之分在右子树
    if(!k)	l=0,r=x;
    else if(k==size[x])	l=x,r=0;
    else if(k<=size[son[x][0]])
        r=x,split(son[x][0],l,son[x][0],k),update(x);
    else
        l=x,split(son[x][1],son[x][1],r,k-size[son[x][0]]-1),update(x);
}

int rank(int x,int k){	//得到某个数在树中的序号-1 
    if(!x)	return 0;
    if(k<=num[x])	
        return rank(son[x][0],k);
    else
        return rank(son[x][1],k)+size[son[x][0]]+1;
}

void insert(int delta){	//插入操作
    int x,y,z,rk=rank(root,delta);
    split(root,x,y,rk);
    build(z,delta);
    merge(x,x,z);
    merge(root,x,y);
}

void del(int delta){	//删除操作
    int x,y,z,rk=rank(root,delta)+1;
    split(root,x,y,rk);
    split(x,x,z,rk-1);
    merge(root,x,y);
}

int pre(int delta){ 	//求出值为delta的结点的前缀的值
    int x,y,z,rk=rank(root,delta);
    split(root,x,y,rk);
    split(x,x,z,rk-1);
    int ans=num[z];
    merge(x,x,z);
    merge(root,x,y);
    return ans;
}

int succ(int delta){ 	//求出值为delta的结点的后缀的值
    int x,y,z,rk=rank(root,delta+1);
    split(root,x,y,rk+1);
    split(x,x,z,rk);
    int ans=num[z];
    merge(x,x,z);
    merge(root,x,y);
    return ans;
}

int main(){ 
    int n,m;
    scanf("%d %d" ,&n,&m);
    insert(0);				//先把边界0和n+1插入treap
    insert(n+1);
    while(m--){
        char opt;
        int x;
        scanf(" %c ",&opt);
        if(opt=='D'){
        	scanf("%d",&x);
        	vis[x]=1;
        	insert(x);
        	stack[++idx]=x;
        }
        else if(opt=='R'){
        	int tmp=stack[idx--];
            del(tmp);
        	vis[tmp]=0;
        }
        else{
        	scanf("%d",&x);
        	if(!vis[x])
                printf("%d\n",succ(x)-pre(x)-1);	//答案为后缀-前缀-1
            else printf("0\n");
        }
    }
    return 0;
}
```
如果对fhq-treap的操作有不理解的地方，可以移步我的博客[fhq-treap学习笔记](https://www.luogu.org/blog/2662945155-minions/fhq-treap-xue-xi-bi-ji)

---

## 作者：L______ (赞：11)

我们很容易可以看出题目需要我们维护的操作是1.单点修改，2.查询一个点所在最长的连续1区间。

我们可以考虑使用线段树维护，这里提供一个新的查询思路。对于第一个操作，都是线段树基本操作了。对于第二个操作，我们可以发现我们需要找的是这个位置往左第一个0的位置l，和这个位置往右第一个0的位置r。最终所求答案既是$r-l-1$。

我们不难发现这个序列中的数均由0和1组成，所以我们用线段树维护区间最小值，如果是0则说明有0，如果是1则说明不包含0。以查询左边第一个0为例，我们在查询时如果发现区间在线段树中被分为了两段，那么我们肯定优先查询右边那段是否包含0，如果不包含那么我们再查询左边那段，我们对于全部是1的区间值直接返回极大值，然后进行判断即可。

```cpp
int queryl(int t,int l,int r,int pos){
	if(tr[t].minn) return inf;
	if(l==r) return l;
	int mid=(l+r)>>1;
	if(r==pos){
		if(tr[t*2+1].minn==0) return queryl(t*2+1,mid+1,r,pos);
		return queryl(t*2,l,mid,mid);
	}
	if(pos<=mid) return queryl(t*2,l,mid,pos);
	else{
		int flag=queryl(t*2+1,mid+1,r,pos);
		if(flag==inf) return queryl(t*2,l,mid,mid);
		else return flag;
	}
}
```

对于查询右边第一个0的位置也是相同的原理。

最终求值时有一点小细节需要注意，如果当前查询的是1位置，那么左边第一个0的位置查询出来是inf，我们判断一下即可。

Code

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define inf 0x7f7f7f7f
#define N 50010
using namespace std;
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}

int n,m,a[N],stac[N],top;
char opt[2];

struct TR{
	int minn;
}tr[N*4];

void up(int t){
	tr[t].minn=min(tr[t*2].minn,tr[t*2+1].minn);
}

void build(int t,int l,int r){
	if(l==r){
		tr[t].minn=a[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(t*2,l,mid);build(t*2+1,mid+1,r);
	up(t);
}

void update(int t,int L,int R,int pos,int k){
	if(L==R){
		tr[t].minn=k;
		return ;
	}
	int mid=(L+R)>>1;
	if(pos<=mid) update(t*2,L,mid,pos,k);
	else update(t*2+1,mid+1,R,pos,k);
	up(t);
}

int queryl(int t,int l,int r,int pos){
	if(tr[t].minn) return inf;
	if(l==r) return l;
	int mid=(l+r)>>1;
	if(r==pos){
		if(tr[t*2+1].minn==0) return queryl(t*2+1,mid+1,r,pos);
		return queryl(t*2,l,mid,mid);
	}
	if(pos<=mid) return queryl(t*2,l,mid,pos);
	else{
		int flag=queryl(t*2+1,mid+1,r,pos);
		if(flag==inf) return queryl(t*2,l,mid,mid);
		else return flag;
	}
}

int queryr(int t,int l,int r,int pos){
	if(tr[t].minn) return inf;
	if(l==r) return l;
	int mid=(l+r)>>1;
	if(l==pos){
		if(tr[t*2].minn==0) return queryr(t*2,l,mid,pos);
		else return queryr(t*2+1,mid+1,r,mid+1);
	}
	if(pos>mid) return queryr(t*2+1,mid+1,r,pos);
	else{
		int flag=queryr(t*2,l,mid,pos);
		if(flag==inf) return queryr(t*2+1,mid+1,r,mid+1);
		else return flag;
	}
}

int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=1;
	build(1,1,n);
	for(int i=1;i<=m;i++){
		scanf("%s",opt);
		if(opt[0]=='D'){
			int x=read();
			a[x]=0;
			update(1,1,n,x,0);
			stac[++top]=x;
		}
		else if(opt[0]=='R'){
			a[stac[top]]=1;
			update(1,1,n,stac[top--],1);
		}
		else{
			int x=read();
			if(a[x]==0){
				printf("0\n");
				continue;
			}
			int l=max(queryl(1,1,n,x-1),0),r=min(queryr(1,1,n,x+1),n+1);
			l=(l==inf)?0:l;
			printf("%d\n",r-l-1);
		}
	}
	return 0;
}
```


---

## 作者：wuzhoupei (赞：11)

![Peipei](http://img.blog.csdn.net/20180120093509502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJldGVuZF9mYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

上面是我的 Logo  >\_<


~~这个我不会用平衡树，线段树之类的搞~~

我一开始想平衡树了，fhq Treap

但是我是真心没想到怎么操作

根据某白的话

>遇事不决先分块  

所以
我用的分块啊

简单暴力  而且稳定O(nsqrt(n))

超级棒


```cpp
#include <bits/stdc++.h>
#define II int
#define IL inline
#define R register
#define I 123456
using namespace std;

IL void of(R II &a) {
    R char c=getchar(); R II w=1,p=0;
    while (c<'0' || c>'9') { if(c=='-') w=-1; c=getchar(); }
    while (c>='0' && c<='9') { p=p*10+c-'0'; c=getchar(); }
    a=p*w; 
}

/* -------------------- Peipei -------------------- */

II Stack[I], had[I], lazy[I], belong[I];

II block,n,m,_top;

IL II Ll(R II x) {
    R II ans=0; 
    while (x>0 && !lazy[x/block]) ans+=min(x,block), x-=block;
    while (x>0 && !had[x]) ans++, x--;
    return ans;
}

IL II Rr(R II x) {
    R II ans=0; if(x==n+1) return 0;
    while (x<=n && !lazy[belong[x]]) ans+=block, x+=block;
    if(x>n+1) ans-=block-(n-n/block*block);
    while (x<=n && !had[x]) ans++, x++;
    return ans;
}

IL II todo(R II x) {
    R II ans=0,l=x,r=x,flag=0;
    if(had[x]) return 0;
    while (l && belong[l]==belong[x]) {
        ans++; l--;
        if(had[l]) { flag=1; break ; }
    }
    if(!flag) ans+=Ll(l);
    flag=0;
    r++;
    while (r<=n && belong[r]==belong[x]) {
        if(had[r]) { flag=1; break ; }
        ans++; r++;
    }
    if(!flag) ans+=Rr(r);
    return ans;
}

int main()
{
//    freopen("1.in","r",stdin);
    
    of(n); of(m); block=sqrt(n);
    for(R II i=1;i<=n;i++) belong[i]=(i-1)/block+1;
    R char opt; R II x;
    while (m --) {
        cin>> opt; 
        if(opt=='D') {
            of(x); Stack[++_top]=x;
            had[x]=1;
            lazy[belong[x]]++;
        }
        if(opt=='R') {
            x=Stack[_top--];
            had[x]=0;
            lazy[belong[x]]--;
        }
        if(opt=='Q') {
            of(x);
            printf("%d\n",todo(x));
        }
    }
}
```

根本不用去讲细节实现

裸的分块啦


---

## 作者：樱初音斗橡皮 (赞：8)

翻了六页题解，却没有一篇用树状数组而且 $O(NlogN)$ 的，大多是线段树/平衡树 $O(NlogN)$ 和树状数组上二分 $O(Nlog^2N)$ 的。这篇题解就讲一下树状数组的 $O(NlogN)$ 解法。

题意简述：

给定一个长为 $N$ 的 $01$ 序列 $a$，初始为全 $0$，有三种操作，一种是修改 $x$ 为 $1$，一种是撤回一次修改，一种是给定 $x$ 求第 $x$ 个元素所在的全部是 $0$ 的联通块的大小。

题目分析：

首先，由于只会撤回修改操作，我们维护一个栈，每次修改操作把该位修改为 $1$ 后把修改的位置入栈，每次撤回操作弹出栈顶元素并把该位修改成 $0$，这样我们的前两个操作就变成了单点修改（$0$ 变 $1$，$1$ 变 $0$）；

其次，要求第 $x$ 个元素所在的全部是 $0$ 的联通块大小，我们要找到它左边和右边的第一个 $1$，即最小的 $y\geq x$ 满足 $a_y=1$ 和最大的 $z\leq x$ 满足 $a_z=1$，则 $y-z-1$ 就是答案；

考虑 $y$ 的求法，等价于求最大的 $y'\geq x$ 使得  $a_x$ 到 $a_{y'}$ 全部是 $0$，则 $y=y'+1$。因此设 $sum_t=\sum_{i=1}^ta_i$，则问题等价于求最大的 $y'\geq x$ 使得 $sum_{y'}=sum_x$。当然，因为 $sum_x=sum_x$，$y'$ 一定 $\geq x$，故条件可以省去。求 $z$ 也同理求出一个类似的 $z'$，再用 $z=z'-1$ 求出答案。

那么，这样的 $y'$ 怎么求呢？可以考虑用倍增的方法，先求出 $sum_x$，循环 `i=logN...0`，维护变量 `ind` 和 `cur`（初始均为0），每次如果 $ind+2^i\leq N$ 且 $cur+\sum_{j=ind+1}^{ind+2^i}a_j\leq sum_x$，则把 $ind$ 更新为 $ind+2^i$，$cur$ 也相应更新。

容易发现，由于 $ind$ 是从高到低一位位考虑这一位是 $1$ 还是 $0$ 的，$ind+2^i$ 的二进制最低位一定是从右到左第 $i+1$ 位（从 $1$ 开始计数），因此 $lowbit(ind+2^i)$ 一定为 $2^i$。所以，$\sum_{j=ind+1}^{ind+2^i}a_j=\sum_{j=lowbit(ind+2^i)}^{ind+2^i}a_j=bit_{ind+2^i}$，其中 $bit_t$ 表示树状数组第 $t$ 位存储的值。

这样，我们就有了一个优秀做法。对数组 $a$ 建树状数组，查询的时候先 $O(logN)$ 查询 $sum_x$，再 $O(logN)$ 用上述方法倍增，得出 $y'$。对于 $z'$ 的求法，因为和 $y'$ 的求法是对称的，可以把数组翻转之后，用相似的方法求出，故此处不再赘述，详情可见代码。最后无需算 $y$ 和 $z$，由 $answer=y-z-1=(y'+1)-(z'-1)-1=y'-z'+1$，算出 $y'$ 与 $z'$ 即可求出。

代码如下（吸氧 $46ms$，不吸氧 $63ms$，可见其常数之小）：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>

const int N=50000;
const int LOGN=15;
const int M=50000;

inline void readi(int& i)
{
	static char ch;
	while ((ch=getchar())>'9'||ch<'0');
	i=ch-'0';
	while ((ch=getchar())<='9'&&ch>='0')
		i=i*10+(ch-'0');
	return;
}

inline void readc(char& ch)
{
	while ((ch=getchar())>'Z'||ch<'A');
	return;
}

int n, m;

bool del[N+10];

struct binaryit
{
	int c[N+10];
	void modify(int i, int k)
	{
		for (int j=i; j<=n; j+=j&-j)
			c[j]+=k;
		return;
	}
	int query1(int i)
	{
		int tmpans=0;
		for (int j=i; j; j&=j-1)
			tmpans+=c[j];
		return tmpans;
	}
	int query2(int k)
	{
		int ind=0, cur=0;
		for (int i=LOGN; i>=0; --i)
			if (ind+(1<<i)<=n&&cur+c[ind+(1<<i)]<=k)
				ind+=(1<<i), cur+=c[ind];
		return ind;
	}
} b1, b2;

int des[N+10], cnt=0;

int main()
{
	readi(n), readi(m);
	for (int i=1; i<=m; ++i)
	{
		char cmd;
		readc(cmd);
		int x;
		if (cmd=='D')
		{
			readi(x);
			del[x]=true;
			b1.modify(x, 1);
			b2.modify(n-x+1, 1);
			des[++cnt]=x;
		}
		else if (cmd=='R')
		{
			x=des[cnt--];
			del[x]=false;
			b1.modify(x, -1);
			b2.modify(n-x+1, -1);
		}
		else if (cmd=='Q')
		{
			readi(x);
			if (del[x])
			{
				printf("0\n");
			}
			else
			{
				printf("%d\n", b1.query2(b1.query1(x))+b2.query2(b2.query1(n-x+1))-n);
			}
		}
		else
		{
			printf("stupid yyc\n");
		}
	}
	return 0;
}
```

---

## 作者：yzhang (赞：8)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/9960345.html)

### 平衡树好题

### [原题传送门](https://www.luogu.org/problemnew/show/P1503)

### 这道题要用Splay，我博客里有[对Splay的详细介绍](https://www.cnblogs.com/yzhang-rp-inf/p/9957906.html)

这道题思维有点难，要把被摧毁的节点插入平衡树，而不是把没有摧毁的节点插入

先把0和n+1插入平衡树，作为边界

操作1：摧毁节点，把该点插入平衡树

操作2：修复最后一个被摧毁节点的位置的可以用栈来求出，并把该点位置从平衡树中删除

操作三：搞一个vis数组，记录是否被摧毁，如果被摧毁了，直接输出0，没被摧毁的话，输出该点后继的位置-该点前驱的位置-1，这应该也很好理解qaq

剩下就没什么问题了~~（除了代码有点长）~~

```cpp
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define root tree[0].ch[1]
#define inf 1000000005
using namespace std;
inline int read()
{
	register int x=0,f=1;register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}
inline void write(register int x)
{
	if(!x)putchar('0');if(x<0)x=-x,putchar('-');
	static int sta[36];int cnt=0;
	while(x)sta[cnt++]=x%10,x/=10;
	while(cnt)putchar(sta[--cnt]+48);
}
inline int Min(register int a,register int b)
{
	return a<b?a:b;
}
inline int Max(register int a,register int b)
{
	return a>b?a:b;
}
struct Splay{
	int fa,ch[2],v,sum,rec;
}tree[50005];
int tot=0;
inline bool findd(register int x)
{
	return x==tree[tree[x].fa].ch[0]?0:1;
}
inline void connect(register int x,register int fa,register int son)
{
	tree[x].fa=fa;
	tree[fa].ch[son]=x;
}
inline void update(register int x)
{
	tree[x].sum=tree[tree[x].ch[0]].sum+tree[tree[x].ch[1]].sum+tree[x].rec;
}
inline void rotate(register int x)
{
	int Y=tree[x].fa;
	int R=tree[Y].fa;
	int Yson=findd(x);
	int Rson=findd(Y);
	int B=tree[x].ch[Yson^1];
	connect(B,Y,Yson);
	connect(Y,x,Yson^1);
	connect(x,R,Rson);
	update(Y),update(x);
}
inline void splay(register int x,register int to)
{
	to=tree[to].fa;
	while(tree[x].fa!=to)
	{
		int y=tree[x].fa;
		if(tree[y].fa==to)
			rotate(x);
		else if(findd(x)==findd(y))
			rotate(y),rotate(x);
		else
			rotate(x),rotate(x);
	}
}
inline int newpoint(register int v,register int fa)
{
	tree[++tot].v=v;
	tree[tot].fa=fa;
	tree[tot].sum=tree[tot].rec=1;
	return tot;
}
inline void Insert(register int x)
{
	int now=root;
	if(root==0)
	{
		newpoint(x,0);
		root=tot;
	}
	else
	{
		while(19260817)
		{
			++tree[now].sum;
			if(x==tree[now].v)
			{
				++tree[now].rec;
				splay(now,root);
				return;
			}
			int nxt=x<tree[now].v?0:1;
			if(!tree[now].ch[nxt])
			{
				int p=newpoint(x,now);
				tree[now].ch[nxt]=p;
				splay(p,root);
				return;
			}
			now=tree[now].ch[nxt];
		}
	}
}
inline int find(register int x)
{
	int now=root;
	while(19260817)
	{
		if(x==tree[now].v)
		{
			splay(now,root);
			return now;
		}
		int nxt=x<tree[now].v?0:1;
		if(!tree[now].ch[nxt])
			return 0;
		now=tree[now].ch[nxt];
	}
}
inline void delet(register int x)
{
	int pos=find(x);
	if(!pos)
		return;
	if(tree[pos].rec>1)
	{
		--tree[pos].rec;
		--tree[pos].sum;
	}
	else
	{
		if(!tree[pos].ch[0]&&!tree[pos].ch[1])
			root=0;
		else if(!tree[pos].ch[0])
		{
			root=tree[pos].ch[1];
			tree[root].fa=0;
		}
		else
		{
			int left=tree[pos].ch[0];
			while(tree[left].ch[1])
				left=tree[left].ch[1];
			splay(left,tree[pos].ch[0]);
			connect(tree[pos].ch[1],left,1);
			connect(left,0,1);
			update(left);
		}
	}
}
inline int lower(register int v)
{
	int now=root,ans=-inf;
	while(now)
	{
		if(tree[now].v<v&&tree[now].v>ans)
			ans=tree[now].v;
		if(tree[now].v>v)
			now=tree[now].ch[0];
		else
			now=tree[now].ch[1];
	}
	return ans;
}
inline int upper(register int v)
{
	int now=root,ans=inf;
	while(now)
	{
		if(tree[now].v>v&&tree[now].v<ans)
			ans=tree[now].v;
		if(tree[now].v>v)
			now=tree[now].ch[0];
		else
			now=tree[now].ch[1];
	}
	return ans;
}
bool vis[50005];
int stac[50005],top=-1;
int main()
{
	memset(vis,false,sizeof(vis));
	int n=read(),m=read();
	Insert(0);
	Insert(n+1);
	while(m--)
	{
		char ch=getchar();
		while(ch!='D'&&ch!='R'&&ch!='Q')
			ch=getchar();
		if(ch=='D')
		{
			int x=read();
			vis[x]=true;
			stac[++top]=x;
			Insert(x);
		}
		else if(ch=='R')
		{
			vis[stac[top]]=false;
			delet(stac[top--]);
		}
		else
		{
			int x=read();
			if(vis[x])
				puts("0");
			else
			{
				write(upper(x)-lower(x)-1);
				printf("\n");
			}
		}
	}
	return 0;
}
```

---

## 作者：xryjr233 (赞：5)

被我拿来当Splay的练手题。。。是我使用Splay AC的第一道题。

有关Splay可以参照这位dalao详尽的解释->[Splay入门解析](https://blog.csdn.net/qq_30974369/article/details/77587168)，或者看看[本蒟蒻的理解](https://www.luogu.org/blog/xryjr233/post-20181024splay-shen-zhan-shu-shuo-ju-jie-gou-post)

这题的询问x,就是求目前被炸毁的房子中x的前驱和后继,设前驱为$last$,后继为$next$,则答案为$next-last+1$。

于是就变成了Splay裸题。

需要使用的操作有:旋转(rotate)、伸展(splay)、查找(find)、插入(insert)、删除(delete)、前驱/后继(next/last，代码中统一为next)。

对于操作D x，我们将一个值为x的点插入Splay;

对于操作R，用栈记录D操作过的x，并将堆首元素从Splay中删除，再从栈中删除；

对于询问Q x，如果它在Splay中，答案为0；否则查询它在Splay中的前驱$last$和后继$next$，答案为$next-last+1$。

注意代码中一些操作里的x代表的意义不一样。

具体的一些小细节见代码。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int f,c[2],val;
}d[50010];
int n,m,t,dest[50010],sz,rt,cnt;
char info;
void getc(char &c){//防止读入奇怪字符
	c=getchar();
	while(c!='D'&&c!='R'&&c!='Q'){
		c=getchar();
	}
}
void Rotate(int x){//旋转编号为x的节点
	int f=d[x].f;
	int gf=d[f].f;
	int ws=(d[f].c[1]==x),gws=(d[gf].c[1]==f);
	d[gf].c[gws]=x;
	d[x].f=gf;
	d[f].c[ws]=d[x].c[ws^1];
	d[d[x].c[ws^1]].f=f;
	d[x].c[ws^1]=f;
	d[f].f=x;
}
void Splay(int x,int fa){//将编号为x的节点伸展为fa的儿子，fa=0伸展到根
	while(d[x].f!=fa){
		if(d[d[x].f].f==fa){
			Rotate(x);
		}else{
			int f=d[x].f;
			int gf=d[f].f;
			int ws=(d[f].c[1]==x),gws=(d[gf].c[1]==f);
			if(ws==gws){
				Rotate(f);
			}else{
				Rotate(x);
			}
			Rotate(x);
		}
	}
	if(!fa){
		rt=x;
	}
}
void Find(int x){//查找值为x的节点
	int nd=rt;
	if(!nd){
		return;
	}
	while(d[nd].val!=x){
		if(d[nd].val>x){
			if(!d[nd].c[0]){
				break;
			}
			nd=d[nd].c[0];
		}else{
			if(!d[nd].c[1]){
				break;
			}
			nd=d[nd].c[1];
		}
	}
	Splay(nd,0);
}
void Insert(int x){//插入值为x的节点
	int nd;
	if(!rt){
		rt=++cnt;
		d[rt].f=0;
		d[rt].c[0]=0;
		d[rt].c[1]=0;
		d[rt].val=x;
		nd=cnt;
	}else{
		nd=rt;
		while(d[nd].val!=x){
			if(d[nd].val>x){
				if(!d[nd].c[0]){
					d[nd].c[0]=++cnt;
					break;
				}
				nd=d[nd].c[0];
			}else{
				if(!d[nd].c[1]){
					d[nd].c[1]=++cnt;
					break;
				}
				nd=d[nd].c[1];
			}
		}
		if(d[nd].val!=x){
			d[cnt].f=nd;
			d[cnt].c[0]=0;
			d[cnt].c[1]=0;
			d[cnt].val=x;
			nd=cnt;
		}
	}
	Splay(nd,0);
}
int Next(int x,int op){//值为x的前驱(op=0)、后继(op=1)节点
	Find(x);
	if(op==0&&d[rt].val<x){
		return rt;
	}
	if(op==1&&d[rt].val>x){
		return rt;
	}
	int nd=d[rt].c[op];
	while(d[nd].c[op^1]){
		nd=d[nd].c[op^1];
	}
	return nd;
}
void Delete(int x){//删除值为x的节点
	int lst=Next(x,0);
	int nxt=Next(x,1);
	Splay(lst,0);
	Splay(nxt,lst);
	d[nxt].c[0]=0;
}
int main(){
	scanf("%d%d",&n,&m);
	Insert(0);//开始将0和n+1加入Splay，确保每个元素存在前驱后继。
	Insert(n+1);
	for(int i=1;i<=m;i++){
		getc(info);
		if(info=='D'){//插入操作
			scanf("%d",&t);
			Insert(t);
			dest[++sz]=t;
		}else if(info=='R'){//删除操作
			Delete(dest[sz--]);
		}else{
			scanf("%d",&t);
			Find(t);
			if(d[rt].val==t){//这栋房子被摧毁了
				puts("0");
			}else{//这栋房子没有被摧毁，查找前驱后继。
				int nxt=Next(t,1);
				int lst=Next(t,0);
				printf("%d\n",d[nxt].val-d[lst].val-1);
			}
		}
	}
	return 0;
}
```

---

## 作者：ChenHacker (赞：3)

平衡树过的是一般大佬，暴力过的才是局佬

数据太水了

然鹅我用树状数组+二分过，复杂度$（n*logn^2）$

树状数组好房子打1,坏房子打0

对于每次Q，分别往左右二分（用树状数组check中间是否有断点），最远段点求距离就行了

还要注意输入的时候小心处理（用cin最好，自己getchar容错性太低）

下面是AC代码
```
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
#define sum(l,r) (ask(r)-ask(l-1))
using namespace std;

int read() {
	register int x=1,ans=0;register char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') x*=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {ans=(ans<<3)+(ans<<1)+ch-48;ch=getchar();}
	return x*ans;
}

const int N=50005;
int c[N],n,m;

void add(int x,int val) {
	for(;x<=n;x+=lowbit(x)) c[x]+=val;
}

int ask(int x) {
	int ans=0;
	for(;x>=1;x-=lowbit(x)) ans+=c[x];
	return ans;
}

int main() {
	n=read(); m=read();
	for(register int i=1;i<=n;++i) add(i,1);
	stack<int> w;
	while(m--) {
		char ch; cin>>ch;
		if(ch=='D') {
			int x=read(); 
			add(x,-1);
			w.push(x);
		}
		else if(ch=='R') {
			int x=w.top(); w.pop(); add(x,1);
		} 
		else {
			int x=read(); 
			if(sum(x,x)==0) puts("0");
			else {
				int l=1,r=x,res=0;
				while(l<=r) {
					int mid=(l+r)>>1;
					if(sum(mid,x)==x-mid+1) res=mid,r=mid-1;
					else l=mid+1;
				}
				int ll=res;
				l=x,r=n;
				while(l<=r) {
					int mid=(l+r)>>1;
					if(sum(x,mid)==mid-x+1) res=mid,l=mid+1;
					else r=mid-1;
				}
				int rr=res;
				printf("%d\n",rr-ll+1);
			}
		}
	}
	return 0;
}
```

---

## 作者：CQ_Bob (赞：2)

## 分析

分块。

我们定义 $\mathit{cnt}_i$ 表示房子 $i$ 是否出现过，$\mathit{sum}_i$ 表示在第 $i$ 个块内没有被摧毁的房子数量，维护的房子是 $(i-1)\times S-1$ 到 $i \times S$，其中 $S=\sqrt{n}$ 也就是块长。

操作 $1$。写一个栈，根据后进先出的特点，讲摧毁的房子 $x$ 入栈，以便后面修复。将 $\mathit{cnt}_x$ 与 $x$ 对应块的 $\mathit{sum}$ 减 $1$ 即可。

操作 $2$。先从栈里找到被修复的房子 $x$。与操作 $1$ 同理，将减 $1$ 变成加 $1$ 即可。

操作 $3$。对于 $x$ 能走到的房子，一定是在 $[l,r]$ 满足 $\sum\limits_{i=l}^r \mathit{cnt}_i =(r-l+1)$ 的情况下的最大区间。我们可以分开来求。对于暴力，我们从 $x$ 开始一直走，直到某一个 $\mathit{cnt}_i=0$ 为止，能证明这是最大区间的 $l$。$r$ 同理，不在此赘述。考虑优化，我们可以先找到 $x$ 所在的块 $k_x$，暴力求 $k_x$ 中的贡献，再对于整块求贡献，最后对于不完整的块（答案边界）暴力。这里需要特别对 $k_x=k_n$ 进行判断，因为 $k_n \times S$ 可能大于 $n$，即最后一个块不完整。这时候直接暴力。由于我们是分开求 $l,r$ 两边的贡献的，这时候在 $\mathit{cnt}_x=1$ 的情况会将 $x$ 的贡献重复加 $1$ 遍，所以要对贡献和减 $1$。

复杂度是 $O(n\sqrt{n})$ 的。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline

const int N=5e4+10;
int cnt[N],sum[N],block,len;
int n,m;
int st[N],tt;

il int get(int x){return (x-1)/len+1;}
il int findl(int x){
	block=get(x);
	int ans=0;
	for(re int i=x;i>=((block-1)*len)+1;--i)
		if(!cnt[i]) return ans;
		else ans++;
	--block;
	for(;block>=1;--block)
		if(sum[block]==len) ans+=len;
		else for(re int i=block*len;i>=((block-1)*len)+1;--i)
			if(!cnt[i]) return ans;
			else ans++;
	return ans;
}
il int findr(int x){
	int maxx=get(n);
	block=get(x);
	int ans=0;
	for(re int i=x;i<=block*len&&i<=n;++i)
		if(!cnt[i]) return ans;
		else ans++;
	++block;
	for(;block<maxx;++block)
		if(sum[block]==len) ans+=len;
		else for(re int i=(block-1)*len+1;i<=block*len;++i)
			if(!cnt[i]) return ans;
			else ans++;
	for(re int i=(block-1)*len+1;i<=n;++i)
		if(!cnt[i]) return ans;
		else ans++;
	return ans;
}

il void solve(){
	cin>>n>>m;len=sqrt(n);
	for(re int i=1;i<=n;++i) ++cnt[i],++sum[get(i)];
	for(re int i=1;i<=m;++i){
		char op;int x,now;cin>>op;
		if(op=='D') cin>>x,st[++tt]=x,--cnt[x],--sum[get(x)];
		else if(op=='R') now=st[tt--],++cnt[now],++sum[get(now)];
		else cin>>x,cout<<((!cnt[x])?0:findl(x)+findr(x)-1)<<"\n";
	}
	return ;
}

signed main(){
	solve();
	return 0;
}
```


---

## 作者：LightningUZ (赞：2)

翻了一下题解，发现，
# 居然没人用$STL$？？？
（还是我瞎了）

### 题意简述

给定一个长度为$n(<=5e4)$的$01$序列，一开始都是$1$。支持三种操作：
1. 修改某一个位置为$0$
2. 撤销上一次修改
3. 询问包含某个位置的最长的连续的$1$的个数。

### 思路

$multiset$维护位置，二分得到左右，相减即珂。

### 实现注意点

1. 左右边界。左：$upper\_bound-1$，右:$lower\_bound$
2. 关于撤销的操作：用一个栈维护删除的位置，每一次撤销就是取栈顶。（我是用$vector$实现的栈，因为我不是很会用$stack$，不要在意）

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i))
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    multiset<int> S;
    multiset<int>::iterator it;
    vector<int> D;
    void Erase1(int x)
    {
        it=S.find(x);
        S.erase(it);
    }

    int n,m;
    void R1(int &x)
    {
        x=0;char c=getchar();int f=1;
        while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();
        while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
        x=(f==1)?x:-x;
    }
    void Input_Soviet()
    {
        R1(n),R1(m);
        S.insert(0);
        S.insert(n+1);
        F(i,1,m)
        {
            char o[4];scanf("%s",o);
            if (o[0]=='D')
            {
                int x;R1(x);
                S.insert(x);
                D.push_back(x);
            }
            if (o[0]=='R')
            {
                int last=*(D.end()-1);
                if (S.find(last)!=S.end())
                {
                    Erase1(last);
                    D.pop_back();
                }
            }
            if (o[0]=='Q')
            {
                int x;R1(x);
                it=S.upper_bound(x);it--;
                int ll=*it;
                int rr=*(S.lower_bound(x));
                printf("%d\n",max(rr-ll-1,0));
            }
        }
    }

    #define Flan void
    Flan IsMyWife()
    {
        Input_Soviet();
    }
}
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();getchar();
    return 0;
}
```

---

## 作者：royzhu (赞：2)

大佬们都用splay做这题

200+行的是play令我望而生畏

我还是乖乖地用线段树吧

# 思路：
1.直接改点

2.通过最大最小值求最靠近被围房子的两房子，

最大值表示区间内编号最大（最右）的被摧毁的房子，

最小值表示区间内编号最小（最左）的被摧毁的房子。

# 注意：

1注意题中的说明：

若士兵被围堵在摧毁了的房子中，那只能等死了。。。。。。（特判，输出0）

2.对于x以左区间，最大值（最右）最靠近x 。对于x以右区间，最小值（最左）最靠近x。

我求的是最靠近x的被摧毁的房子，所以两编号之差-1才是答案,相当于植树问题两边都不种
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
using namespace std;
#define M 50010
int c[M],len=0,t=0,d[M],n,m;//c是便于直接查看房子，记录第i个房子在线段树中的编号 
struct tree{int l,r,lc,rc,c,maxx,minn;}tr[M<<1];

void bt(int l,int r)//建树 
{
	int now=++len;tr[now].l=l;tr[now].r=r;
	tr[now].lc=tr[now].rc=tr[now].c=tr[now].maxx=0;tr[now].minn=n+1;
	//初始化 ，一开始都没有被摧毁，最小的是0，最大的是n+1 （最大值初始化为最小，最小值初始化为最大） 
	if(l<r)
	{
		int mid=(l+r)>>1,lc,rc;
		lc=tr[now].lc=len+1;bt(l,mid);
		rc=tr[now].rc=len+1;bt(mid+1,r);
		tr[now].c=tr[lc].c+tr[rc].c;
	}
	else c[l]=now,tr[now].c=1;//记录编号，初始化 
}

void change(int now,int x,int k)//改点 ，k等于0表示被摧毁 ，k等于1表示完好  
{
	if(tr[now].l==tr[now].r)
	{
		tr[now].c=k;
		(!k)?(tr[now].maxx=tr[now].minn=x):(tr[now].maxx=0,tr[now].minn=n+1);//！等价于==0  
		/*
		等价于
		if(k==0)
		{
		 	tr[now].maxx=x;tr[now].minn=x;
		}
		else
		{
			tr[now].maxx=0;tr[now].minn=n+1;//注意初始化 
		}
		*/ 
		return;
	}
	int lc=tr[now].lc,rc=tr[now].rc,mid=(tr[now].l+tr[now].r)>>1;
	if(x<=mid)change(lc,x,k);
	else change(rc,x,k);
	tr[now].c=tr[lc].c+tr[rc].c;
	tr[now].maxx=max(tr[lc].maxx,tr[rc].maxx);
	tr[now].minn=min(tr[lc].minn,tr[rc].minn);//维护最大最小值 
}

int comp(int x,int y,bool v){return !v?min(x,y):max(x,y);}
//emmmm...因为懒得打两个findsum（一个求最大值，一个求最小值） 

int findsum(int now,int l,int r,bool v)//v等于0表示求最小值 ，v等于1表示求最大值  
{
	if(tr[now].l==l&&tr[now].r==r)
	{
		return !v?tr[now].minn:tr[now].maxx;
	}
	int lc=tr[now].lc,rc=tr[now].rc,mid=(tr[now].l+tr[now].r)/2;
	if(r<=mid)return findsum(lc,l,r,v);
	else if(l>mid)return findsum(rc,l,r,v);
	else {return comp(findsum(lc,l,mid,v),findsum(rc,mid+1,r,v),v);}
}

int main()
{
	scanf("%d %d",&n,&m);
	len=0;bt(1,n);char s[100];
	for(int i=1;i<=m;i++)
	{
		scanf("%s",s);
		if(s[0]=='D')
		{
			int x;scanf("%d",&x);
			change(1,x,0);d[++t]=x;
		}
		else if(s[0]=='Q')
		{
			int x;scanf("%d",&x);
			if(tr[c[x]].c==0)
			{printf("0\n");continue;}
			printf("%d\n",findsum(1,x,n,0)-findsum(1,1,x,1)-1);
			/*
			对于x以左区间，最大值（最右）最靠近x 。对于x以右区间，最小值（最左）最靠近x。 
			我求的是最靠近x的被摧毁的房子，所以两编号之差-1才是答案,相当于植树问题两边都不种 
			*/ 
		}
		else
		{
			change(1,d[t],1);--t;
		}
	}
	return 0;
}
```


---

## 作者：汇文客 (赞：2)

//用一棵平衡树和一个栈存储被摧毁的房屋编号。

```cpp
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#include<bits/stdc++.h> 
using namespace  __gnu_pbds;
using namespace std; 
tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update>t;
int main()
{
    long long n,m,i,x,l,r;
    char ch;
    stack<long long> s;
    scanf("%lld%lld",&n,&m);scanf("\n");
    while(m--)
    {
        ch=getchar();
        while(ch<'A'||ch>'Z')ch=getchar();//cout<<ch<<endl;
        if(ch=='D')//遇到D就添结点、入栈。
        {
            scanf(" %lld",&i);scanf("\n");
            i=i<<20;
            t.insert(i);
            s.push(i);
        }
        else if(ch=='R')//遇到R就删结点、弹栈。
        {
            i=s.top();
            t.erase(i);
            s.pop();
            scanf("\n");
        }
        else//分四种情况讨论
        {
            scanf(" %lld",&i);scanf("\n");
            long long j=((i+1)<<20);i=i<<20;
            x=*t.find_by_order(s.size()-1);
            if(i>x){printf("%d\n",n-(x>>20));continue;}
            x=*t.find_by_order(0);
            if(i<x){printf("%d\n",(x>>20)-1);continue;}
            x=*t.find_by_order(t.order_of_key(i));
            if(i==x){printf("%d\n",0);continue;}
            t.insert(i);
            l=*--t.lower_bound(i);
            r=*t.lower_bound(j);
            printf("%d\n",(r>>20)-(l>>20)-1);
            t.erase(i);
        }
    }
    return 0;
}
这是pbds库与stl的一次完美合作。
```

---

## 作者：blackjack (赞：2)

思路跳得很快。

以每个村子为叶子节点，建立线段树，线段树维护区间和。初始时每个村子中sum为1。我们从另一个角度看，理解D x为将x号节点更改成0，这样R x和D x都只不过是点修改。我们只需要查找包括x号村子的连续1的个数。

怎么找呢？我一开始的思路是仿照维护区间和最值的维护方法，维护前缀连续1，后缀连续1，但我很快发现这并没有什么用处。(当然，后来发现，这在正解中是可以的)。然后我又想到，对于包含x号房间的节点，如果这个区间上连续，那么我们可以继续找这个区间的前一个区间和后一个区间，加起来。

然后这里就巧妙了！由于我们是在满二叉树上递归，所以不用考虑什么同一层上一排节点的情况，对我们当前状态来说，只有三个点：当前节点，左儿子，右儿子。假定x节点在左儿子，我们判断这个区间上1是否连续，如果不连续，递归继续以左儿子为根细分区间，如果连续，我们停止以当前节点为根的递归，转而以最靠近左儿子的右儿子上的叶子节点所对应房间为x，和以最靠近左儿子的左节点的最右边的叶子节点所对应房间为x，查找包含x的连续区间最大值。如此递归下去，最终我们将不重不漏地得到连续区间大小。

为了不重复访问区间，我们要在getsum函数的参数上加个direction，表示来的方向，不走回头路。

时间复杂度的话，我一开始认为这样递归可能会有调用很多次找其他点的情况，但实际上并不会，因为这些点会被合并掉，所以我们不能从访问树的角度分析时间复杂度，而应该从“区间被拆分成2进制数”的角度进行分析，因此时间复杂度是O((logn)^2)，因为二进制数拆分是logn，在树上找又是logn。
代码如下。

（此题在POJ上卡常，我的代码需要快读，也有可能是我的方法太麻烦了吧）
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<stack>
 
using namespace std;
 
stack<int>sta;
 
struct node{
   int left,right;
   int sum;
#define sum(x) (tree[x].sum)
#define l(x) (tree[x].left)
#define r(x) (tree[x].right)
};
node tree[200001];
int n;
 
void readp(int &x){
   x=0;
   char c;
   c=getchar();
   while (c<'0' or c>'9')
      c=getchar();
   while (c<='9' and c>='0'){
      x=x*10+c-'0';

      c=getchar();
   }
}
 
void build(int p,int l,int r){
   l(p)=l;
   r(p)=r;
   if (l==r){
      sum(p)=1;
      return ;
   }
   build(p*2,l,(l+r)/2);
   build(p*2+1,(l+r)/2+1,r);
   sum(p)=sum(p*2)+sum(p*2+1);
}
 
void add_point(int p,int k,int d){
   if (l(p)==r(p)){
      sum(p)+=d;
      return ;
   }
   int mid=(l(p)+r(p))/2;
   if (k<=mid)
      add_point(p*2,k,d);
   else
      add_point(p*2+1,k,d);
   sum(p)=sum(p*2)+sum(p*2+1);
}
 
int getsum(int p,int k,int dir){
   if (l(p)==r(p))
      return sum(p);
   if (!k or k>n)
      return 0;
   int ans=0;
   int lc=p*2,rc=lc+1;
   int mid=(l(p)+r(p))/2;
   if (k<=mid){
      if (sum(lc)==(r(lc)-l(lc)+1)){
         ans+=sum(lc);
         if (!dir or dir==-1)
            ans+=getsum(1,r(lc)+1,-1);//更改目标
         if (!dir or dir==1)
            ans+=getsum(1,l(lc)-1,1);
         return ans;
      }
      else
         return getsum(p*2,k,dir);
   }
   else{
      if(sum(rc)==(r(rc)-l(rc)+1)){
         ans+=sum(rc);
         if (!dir or dir==1)
            ans+=getsum(1,l(rc)-1,1);
         if (!dir or dir==-1)
            ans+=getsum(1,r(rc)+1,-1);
         return ans;
      }
      else
         return getsum(p*2+1,k,dir);
   }
}


int main(){
   freopen("test.in","r",stdin);
//   freopen("test.out","w",stdout);
   int m,x,ans,last;
   cin>>n>>m;
   build(1,1,n);
   char opt;
   for (int i=1;i<=m;++i){
      cin>>opt;
      if (opt=='D'){
         cin>>x;
         add_point(1,x,-1);
         sta.push(x);
      }
      if (opt=='Q'){
         cin>>x;
         ans=getsum(1,x,0);
         cout<<ans<<'\n';
      }
      if (opt=='R'){
         last=sta.top();
         sta.pop();
         add_point(1,last,1);
      }
   }
   return 0;
}

```

---

## 作者：Hope2075 (赞：1)

给一种~~无脑~~的做法

用可回退化线段树~~不是hope~~

### 先考虑没有修复房子时怎么做：

可以维护每个点向左和向右右能到达的最远房子的编号，这实际就是区间赋值

询问的时候，就把这个点对应的两个边界相减再加1（就是r-l+1）

而对于被摧毁的房子，完全可以通过修改两个边界的数值来保证输出为0（见代码）

具体实现就是线段树每个节点记录区间内的值，用-1表示区间内值不一致

修改时：

如果这个节点被完全包含，就修改节点记录的值

如果完全不被包含，就直接结束

否则，先下放标记（如有，直接改左右两个节点的值），再递归处理

询问时：

如果当前位置是一个带标记的区间（区间内值相同），就返回值

否则，根据位置选择一个孩子递归（注意边界）

### 然后就到了最关键的一步：可回退化

发现每次修复都是撤销操作，并且询问不会影响线段树的数据

所以就把线段树可持久化一下

具体做法：

每次执行区间修改操作时，记录并修改时间戳，并记录每步对数组的操作（记录位置和原值）

询问正常处理

撤销时，就按照之前的记录把数组的内容恢复到对应时间戳

### 效率&代码难度

时间复杂度和空间复杂度都是$O(n\log n)$，空间开销偏大

几乎没有思维量（代码写对就基本随便搞了）

代码难度略高

### 代码

为了便于同时处理两个数组，我封装了一下

```cpp
#include<cstdio>
const int N=50007;
class seq {
	private:
		class opt {
			public:
				int pl,num,t;
				opt(int _pl,int _num,int _t) {
					pl=_pl;
					num=_num;
					t=_t;
				}
				opt() {}
		};
		int num[N*4];
		opt list[N*4*20];
		int cnt;
		int time;
		int len;

		void set(int pl,int n) {
        //记录一次数组修改操作
			list[cnt++]=opt(pl,num[pl],time);
			num[pl]=n;
		}
		void _undo() {
        //撤销一次数组修改操作
			--cnt;
			num[list[cnt].pl]=list[cnt].num;
		}
		void rset(int l,int r,int n,int ll,int rr,int id) {
        //区间赋值
			if(l<=ll&&rr<=r) {
				set(id,n);
				return;
			}
			if(l>rr||ll>r)return;
			if(num[id]!=-1) {
				set(id<<1,num[id]);
				set((id<<1)|1,num[id]);
				set(id,-1);
			}
			int mid=((ll+rr)>>1);
			rset(l,r,n,ll,mid,id<<1);
			rset(l,r,n,mid+1,rr,(id<<1)|1);
		}
		int qnum(int ll,int rr,int id,int pl) {
        //单点查询
			if(num[id]!=-1)return num[id];
			if(ll==rr)return num[id];
			int mid=((ll+rr)>>1);
			if(pl<=mid)return qnum(ll,mid,id<<1,pl);
			else return qnum(mid+1,rr,(id<<1)|1,pl);
		}
	public:
		seq(int _len) {
        //初始化
			for(int i=0; i<=_len*4; i++)num[i]=-1;
			cnt=time=0;
			len=_len;
		}
		void rset(int l,int r,int n) {
        //这里负责记录时间戳，下同
			if(l>r) {
				time++;
				return;
			}
			rset(l,r,n,1,len,1);
			time++;
		}
		void undo() {
        //
			time--;
			while(cnt&&list[cnt-1].t==time)_undo();
		}
		int qnum(int pl) {
			return qnum(1,len,1,pl);
		}
};
seq lb(0),rb(0);
int n,m;
char c[1];
int a;
int main() {
	scanf("%d%d",&n,&m);
	lb=seq(n);
	rb=seq(n);
	lb.rset(1,n,1);
	rb.rset(1,n,n);
	while(m--) {
		scanf("%s",c);
		if(c[0]=='D') {
			scanf("%d",&a);
			int l=lb.qnum(a);
			int r=rb.qnum(a);
			lb.rset(a,a,a);
			rb.rset(a,a,a-1);//可以不处理特殊情况（在被摧毁的房子里）
			lb.rset(a+1,r,a+1);
			rb.rset(l,a-1,a-1);
            //每个数组会恰好修改两次时间戳，便于撤销
		} else if(c[0]=='R') {
			lb.undo();
			lb.undo();
			rb.undo();
			rb.undo();
		} else {
			scanf("%d",&a);
			int l=lb.qnum(a);
			int r=rb.qnum(a);
			printf("%d\n",r-l+1);
		}
	}
}
```


---

## 作者：设计涉及社稷 (赞：1)

提供两种做法，fhq_treap和set

思路：
- 首先在平衡树中加入0节点和n+1节点，是左右边界
- 'D x':在平衡树中加入x节点(为什么是加入而不是删除，我后面会详细讲到)
- 'R':既然是上一个点恢复了，而样例的最后一个询问为我们贴心地考虑了连续恢复的情况，那么就是要维护一个后进先出的`栈`来保存您删除的点啦~
- 'Q x'查询x点的前驱pre上一个被删除的点），和x的后继suc下一个被删除的点，那么x能到达的点的个数就是suc-pre-1个（题目给的是一条编号连续的链，那么根据编号来查找个数就很方便啦^ _ ^）

### fhq_treap
```
#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define dwn(i,a,b) for(int i=a;i>=b;--i) 
template <typename T> inline void rd(T &x){x=0;char c=getchar();int f=0;while(!isdigit(c)){f|=c=='-';c=getchar();}while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x=f?-x:x;} 

const int N=5e4+10;
int tot,siz[N],val[N],rnd[N],son[N][2];
int x,y,n,rt,m;  

inline void upd(int x){siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;}
inline int new_node(int x){siz[++tot]=1;val[tot]=x;rnd[tot]=rand();return tot;}

inline void split(int now,int k,int &x,int &y){
	if(!now)x=y=0;
	else{
		if(val[now]<=k)
			x=now,split(son[now][1],k,son[now][1],y);
		else
			y=now,split(son[now][0],k,x,son[now][0]);
		upd(now);
	}
}

inline int merge(int x,int y){
	if(!x || !y)return x^y;
	if(rnd[x]<rnd[y]){
		son[x][1]=merge(son[x][1],y);
		upd(x);
		return x;
	}
	else{
		son[y][0]=merge(x,son[y][0]);
		upd(y);
		return y;
	}
}

int kth(int x,int k){
	while(1){
		if(siz[son[x][0]]>=k)
			x=son[x][0];
		else if(siz[son[x][0]]+1==k)
			return x;
		else 
			k-=siz[son[x][0]]+1,x=son[x][1];
	}
}

int del[N];
stack<int>s;

int main(){
	#ifdef WIN32
	freopen("guizi.txt","r",stdin);  
    #endif
	srand((unsigned)time(NULL));
    rd(n),rd(m);
    split(rt,0,x,y);
	rt=merge(merge(x,new_node(0)),y);
    split(rt,(n+1),x,y);
	rt=merge(merge(x,new_node((n+1))),y);
    rep(i,1,m){
    	char op[3];cin>>op;
		if(op[0]=='R'){
			int z=0;
			int last=s.top();
			split(rt,last,x,z);
			split(x,last-1,x,y);
			y=merge(son[y][0],son[y][1]);
			rt=merge(merge(x,y),z);
			s.pop();
			del[last]=0;
		}
		else if(op[0]=='D'){
			int a;rd(a); 
			split(rt,a,x,y);
			rt=merge(merge(x,new_node(a)),y);
			s.push(a);
			del[a]=1;
		}
		else if(op[0]=='Q'){
			int a;rd(a);
			if(del[a]){
				puts("0");
				continue;
			}
			split(rt,a-1,x,y);
			int pre=val[kth(x,siz[x])];
//			printf("%d的前驱为%d\n",a,pre);
			rt=merge(x,y);
			split(rt,a,x,y);
			int suc=val[kth(y,1)];
			rt=merge(x,y);
//			printf("%d的后继为%d\n",a,suc);
			printf("%d\n",suc-pre-1);
		}
    }
    return 0;
}
```

### set
用set真是太太太方便啦
```
#include<bits/stdc++.h>
using namespace std;

template <typename T>inline void rd(T &x){x=0;char c=getchar();int f=0;while(!isdigit(c)){f|=c=='-';c=getchar();}while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x=f?-x:x;} 
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define dwn(i,a,b) for(int i=a;i>=b;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#define ee(i,u) for(int i=head[u];i;i=e[i].next)

const int M=5e4+10; 
int q[M],tail,n,m;

set<int> s;
set<int>:: iterator it;
stack<int>sta;

int main(){
	#ifdef WIN32
	freopen("guizi.txt","r",stdin);  
    #endif
    rd(n),rd(m);
	s.insert(0);
	s.insert(n+1);
	while(m--){
        char c;cin>>c;
        if(c=='D'){
        	int x;rd(x);
        	s.insert(x);
        	sta.push(x);
		}
        else if(c=='Q'){
            int x;rd(x);
            it=s.lower_bound(x);
            if(*it==x){
            	puts("0");
            	continue;
			}
            printf("%d\n",*it-*(--it)-1);
        }
        else if(c=='R'){
        	it=s.find(sta.top());
        	sta.pop();
        	s.erase(it);
        }
    }
    return 0;
}
```

---

## 作者：Ireliaღ (赞：1)

**对于非毒瘤数据，替罪羊树是所有平衡树中跑的最快的**

这道题思路就是开栈记录每次毁掉的房子，开数组记录每一个房子是否被毁，每次查询前驱和后继即可。

提供指针版替罪羊树的代码

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <stack>
#include <vector>

using namespace std;

const int INF = 0x7f7f7f7f;
const int MAXN = 5e4 + 5;
const float Alpha = 0.7;

int n, m;
bool vis[MAXN];
stack<int> stk;
char op[5];

struct Node{
    int val, siz, cov;
    bool exist;
    Node *ch[2];
    
    Node(int val) : val(val) {
        exist = true;
        ch[0] = ch[1] = NULL;
        siz = cov = 1;
    }
};

Node *rt;
vector<Node*> vec;
stack<Node*> tsh;

Node *newNode(int val) {
	if (tsh.empty()) return new Node(val);
	Node *ret = tsh.top(); tsh.pop();
	*ret = Node(val);
	return ret;
}

void Update(Node *now) {
    now->siz = now->exist + (now->ch[0] ? now->ch[0]->siz : 0) + (now->ch[1] ? now->ch[1]->siz : 0);
    now->cov = 1 + (now->ch[0] ? now->ch[0]->cov : 0) + (now->ch[1] ? now->ch[1]->cov : 0);
}

bool Bad(Node *now) {
    int ls = now->ch[0] ? now->ch[0]->cov : 0;
    int rs = now->ch[1] ? now->ch[1]->cov : 0;
    return (float)ls / now->cov > Alpha || (float)rs / now->cov > Alpha;
}

void Dfs(Node *now) {
    if (!now) return;
    Node *tmp = now;
    Dfs(now->ch[0]);
    if (now->exist) vec.push_back(now);
    else tsh.push(now);
    Dfs(now->ch[1]);
    tmp->ch[0] = tmp->ch[1] = NULL;
}

void Rebuild(Node *&now, int l, int r) {
    if (l > r) return;
    int mid = l + r >> 1;
    now = vec[mid];
    Rebuild(now->ch[0], l, mid - 1);
    Rebuild(now->ch[1], mid + 1, r);
    Update(now);
}

void Insert(Node *&now, int k) {
    if (!now) {
        now = newNode(k);
        return;
    }
    if (now->val == k) now->exist = true;
    else if (k < now->val) Insert(now->ch[0], k);
    else if (k > now->val) Insert(now->ch[1], k);
    Update(now);
    if (!Bad(now)) return;
    vec.clear();
    Dfs(now);
    int len = vec.size();
    Rebuild(now, 0, len - 1);
}

void Remove(Node *now, int k) {
    if (!now) return;
    if (now->val == k) now->exist = false;
    else if (k < now->val) Remove(now->ch[0], k);
    else if (k > now->val) Remove(now->ch[1], k);
    Update(now);
    if (!Bad(now)) return;
    vec.clear();
    Dfs(now);
    int len = vec.size();
    Rebuild(now, 0, len - 1);
}

int GetPre(Node *now, int k) {
    if (!now) return -INF;
    if (now->val >= k) return GetPre(now->ch[0], k);
    int ret = GetPre(now->ch[1], k);
    return ret == -INF ? (now->exist ? now->val : GetPre(now->ch[0], k)) : ret;
}

int GetSuc(Node *now, int k) {
    if (!now) return INF;
    if (now->val <= k) return GetSuc(now->ch[1], k);
    int ret = GetSuc(now->ch[0], k);
    return ret == INF ? (now->exist ? now->val : GetSuc(now->ch[1], k)) : ret;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> n >> m;
    while (m--) {
        cin >> op;
        if (op[0] == 'D') {
            int x;
            cin >> x;
            Insert(rt, x);
            stk.push(x);
            vis[x] = true;
        } else if (op[0] == 'R') {
            int x = stk.top(); stk.pop();
            Remove(rt, x);
            vis[x] = false;
        } else if (op[0] == 'Q') {
            int x;
            cin >> x;
            if (vis[x]) {
                cout << '0' << endl;
                continue;
            }
            int l = GetPre(rt, x), r = GetSuc(rt, x);
            cerr << "L:" << l << ' ' << "R:" << r << endl;
            cout << (r == INF ? n + 1 : r) - (l == -INF ? 0 : l) - 1 << endl;
        }
    }
    return 0;
}
```

---

## 作者：suyiheng (赞：1)

这道题要求他被围堵都士兵可以到达几个房子，其实就是要求比这个房子编号大并且被的房子中编号最小的房子的编号-比这个房子编号小并且被的房子中编号最大的房子的编号-1。所以这道题其实就可以用两个线段树来维护这个最大值与最小值。每次查询就是求min(x~n)-max(1~x)。
```
#include<iostream>
#include<cstdio>
#include<stack>
using namespace std;
int n,m,x,y,f1[200001],f2[200001];//f1为最大值，f2为最小值。
char ch;
bool t[50001];
stack<int> st;
void change1(int s,int l,int r,int v){//修复、破坏对max的改变(v==1为破坏，v==0为修复)
	if(l>x||r<x)return;
	if(l==r){
		if(v==0)f1[s]=0;
		else f1[s]=l;
		return;
	}
	int mid=(l+r)/2;
	change1(s*2,l,mid,v);
	change1(s*2+1,mid+1,r,v);
	f1[s]=max(f1[s*2],f1[s*2+1]);
}
void change2(int s,int l,int r,int v){//修复、破坏对min的改变
	if(l>x||r<x)return;
	if(l==r){
		if(v==0)f2[s]=n+1;
		else f2[s]=l;
		return;
	}
	int mid=(l+r)/2;
	change2(s*2,l,mid,v);
	change2(s*2+1,mid+1,r,v);
	f2[s]=min(f2[s*2],f2[s*2+1]);
}
int find1(int s,int l,int r){//求1~x的max值
	if(1>r||x<l)return 0;
    if(1<=l&&x>=r)return f1[s];
    int mid=(l+r)/2;
    int p1=find1(s*2,l,mid),p2=find1(s*2+1,mid+1,r);
    return max(p1,p2);
}
int find2(int s,int l,int r){//求x~n的min值
	if(x>r||n<l)return 100000000;
    if(x<=l&&n>=r)return f2[s];
    int mid=(l+r)/2;
    int p1=find2(s*2,l,mid),p2=find2(s*2+1,mid+1,r);
    return min(p1,p2);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n*4;i++)f2[i]=n+1;
	for(int i=1;i<=m;i++){
		cin>>ch;
		if(ch=='R'){
			if(!st.empty()){
				x=st.top();//修复最后一个被破坏的房子
				t[x]=false;
				st.pop();
				change1(1,1,n,0);
				change2(1,1,n,0);
			}
		}else if(ch=='D'){
			scanf("%d",&x);
			st.push(x);//将最后一个被破坏的房子压入栈
			t[x]=true;
			change1(1,1,n,1);
			change2(1,1,n,1);
		}else{
			scanf("%d",&x);
			if(!t[x]){
				int p1=find1(1,1,n),p2=find2(1,1,n);
				printf("%d\n",p2-p1-1);
			}else printf("0\n");
		}
	}
}
```

---

## 作者：zhengrunzhe (赞：1)

提供指针splay

将被摧毁的房子存进树中

对于每次询问 查询它树中的前驱和后继

则答案为后继-前驱-1

特别地，如果它在树中就输出0了

注意添加边界点0和n+1

开个stack存被摧毁尚待修复的房子

每次R重建就在树中删除栈顶 并弹出
```cpp
#include<stack>
#include<cstdio>
using namespace std;
class Splay
{
	public:
		struct tree
		{
			int value,size;
			tree *fa,*son[2];
			inline tree(int key)
			{
				size=1;
				value=key;
				fa=son[0]=son[1]=NULL;
			}
			inline void pushup()
			{
				size=1;
				if (son[0])size+=son[0]->size;
				if (son[1])size+=son[1]->size;
			}
		}*root;
		inline bool relation(tree *p)
		{
			if (p&&p->fa)return p->fa->son[1]==p;
		}
		inline void connect(tree *&p,tree *&fa,bool which)
		{
			if (p)p->fa=fa;
			if (fa)fa->son[which]=p;
		}
		inline void rotate(tree *&p)
		{
			tree *fa=p->fa;
			bool lr=relation(p);
			connect(p,fa->fa,relation(fa));
			connect(p->son[lr^1],fa,lr);
			connect(fa,p,lr^1);
			fa->pushup();p->pushup();
		}
		inline void splay(tree *&p,tree *goal)
		{
			for (tree *fa;(fa=p->fa)!=goal;rotate(p))
				if (fa->fa!=goal)
					rotate(relation(fa)==relation(p)?fa:p);
			if (goal==NULL)root=p;
		}
		inline void insert(int insertion)
		{
			if (root==NULL)
			{
				root=new tree(insertion);
				return;
			}
			tree *p=root;
			while (1)
			{
				if (p->value==insertion)return;
				tree *fa=p;
				bool direction=p->value<insertion;
				p=fa->son[direction];
				if (p==NULL)
				{
					p=new tree(insertion);
					connect(p,fa,direction);
					fa->pushup();
					splay(p,NULL);
					return;
				}
			}
		}
		inline void find(int key)
		{
			tree *p=root;
			while (p->son[p->value<key]&&p->value!=key)
				p=p->son[p->value<key];
			splay(p,NULL);
		}
		inline tree *precursor(int x)
		{
			find(x);
			if (root->value<x)return root;
			tree *p=root->son[0];
			while (p->son[1])p=p->son[1];
			return p;
		}
		inline tree *successor(int x)
		{
			find(x);
			if (root->value>x)return root;
			tree *p=root->son[1];
			while (p->son[0])p=p->son[0];
			return p;
		}
		inline void Delete(int x)
		{
			tree *pre=precursor(x),*nxt=successor(x);
			splay(pre,NULL);splay(nxt,pre);
			delete nxt->son[0];
			nxt->son[0]=NULL;
			nxt->pushup();
		}
}splay;
int n,m,last;
stack<int>destruction;
int main()
{
	scanf("%d%d",&n,&m);
	splay.insert(0);splay.insert(n+1); //注意边界 否则可能爆炸
	while (m--)
	{
		char opt;int x;
		scanf(" %c",&opt);
		if (opt=='R')
			splay.Delete(destruction.top()),
			destruction.pop(); //取出栈顶并弹出
		if (opt=='D')
			scanf("%d",&x),
			splay.insert(x),
			destruction.push(x); //入栈
		if (opt=='Q')
		{
			scanf("%d",&x);
			splay.find(x);
			if (splay.root->value==x)puts("0"); //特判为0
			else
			{
				int pre=splay.precursor(x)->value,
					nxt=splay.successor(x)->value;
				printf("%d\n",nxt-pre-1);
			}
		}
	}
	return 0;
}
```

---

## 作者：ButterflyDew (赞：1)

来[Dew](https://www.cnblogs.com/ppprseter/p/9600868.html)的博客看看？

这道题方法好多啊QAQ

提供一种点分裂合并的平衡树做法

平衡树每个节点维护一个$segl$和一个$segr$,表示这个节点所代表的**连续**区间

这样我们在询问的时候只需要找到对应的点，看看这个点有多大就行了

对于删除，我们直接找到点，然后分情况把这个点分裂掉删掉就行了

对于修改，我们塞进去的时候看看可不可以和左右节点进行合并，如果可以，就把节点合并成一个

事实上实现起来有些麻烦，我用的是fhqtreap，写起来还算方便叭

-------------
**Code:**
```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define ls ch[now][0]
#define rs ch[now][1]
const int N=1e5+10;
int ch[N][2],segl[N],segr[N],val[N],tot,root,s[N],n,m,tot0,in[N];
void split(int now,int k,int &x,int &y)
{
    if(!now){x=y=0;return;}
    if(k>=segl[now])
        x=now,split(rs,k,rs,y);
    else
        y=now,split(ls,k,x,ls);
}
int Merge(int x,int y)
{
    if(!x||!y) return x+y;
    if(val[x]<val[y])
    {
        ch[x][1]=Merge(ch[x][1],y);
        return x;
    }
    else
    {
        ch[y][0]=Merge(x,ch[y][0]);
        return y;
    }
}
int New(int l,int r)
{
    val[++tot]=rand(),segl[tot]=l,segr[tot]=r;
    return tot;
}
void Insert(int k)
{
    int x,y,z;
    in[k]=0;
    split(root,k,x,y);
    split(y,k+1,z,y);
    int now=x;while(rs) now=rs;
    if(segr[now]==k-1)
    {
        ++segr[now];
        if(segr[now]==segl[z]-1)
        {
            segr[now]=segr[z];
            root=Merge(x,y);//三个全合并
        }
        else
            root=Merge(x,Merge(z,y));
    }
    else if(k==segl[z]-1)
    {
        --segl[z];
        root=Merge(x,Merge(z,y));
    }
    else
        root=Merge(Merge(x,New(k,k)),Merge(z,y));
}
int query(int k)
{
    int x,y,ans,now;
    split(root,k,x,y);
    now=x;while(rs) now=rs;
    ans=segr[now]+1-segl[now];
    root=Merge(x,y);
    return ans;
}
void destroy(int k)
{
    int x,y,z;
    in[k]=1;
    split(root,k,x,y);
    int now=x,rr;while(rs) now=rs;
    rr=segr[now];
    if(segl[now]==segr[now]) split(x,segl[now]-1,x,z);
    else segr[now]=k-1;
    if(k<rr) x=Merge(x,New(k+1,rr));
    root=Merge(x,y);
}
int main()
{
    scanf("%d%d",&n,&m);
    root=New(1,n);
    char op[3];
    for(int x,i=1;i<=m;i++)
    {
        scanf("%s",op);
        if(op[0]=='D')
        {
            scanf("%d",&x);
            destroy(s[++tot0]=x);
        }
        else if(op[0]=='R')
            Insert(s[tot0--]);
        else
        {
            scanf("%d",&x);
            if(in[x]) printf("0\n");
            else printf("%d\n",query(x));
        }
    }
    return 0;
}

```

---

## 作者：AFOier (赞：0)

$Splay+$栈
-
对于D（摧毁）操作，只需要将当前摧毁节点插入平衡树，并且将其放在栈顶即可

对于R（修复）操作，将当前栈顶节点在平衡树中删除，并且删除栈顶

对于Q（询问）操作，查询当前x的前驱和后继，并且求出它们包含的区间大小即可。但是要注意这里的前驱和后继是可以包含与查询数相等的数的，所以如果find后发现树根是查询数，直接输出。

$Ps:$在我的代码中由于删除操作需要用到严格的前驱后继，所以我的pre和suc函数都分两类，zl=0是不严格的前驱后继，zl=1是严格的

$Code:$~~(码风丑勿怪）~~
```
#include <cstdio>
#include <iostream>
using namespace std;
int n,m,x;
char opt;
int root,tot;
int stack[100001],head;
const int INF=0x7fffffff;
struct tree{
	int val,siz,cnt;
	int son[2],fa;
}a[100000];
void update(int p){
	if(!p)return;
	a[p].siz=a[a[p].son[0]].siz+a[a[p].son[1]].siz+a[p].cnt;
}
int fson(int p){
	return p==a[a[p].fa].son[1];
}
void contact(int son,int father,int lr){
	a[father].son[lr]=son;
	a[son].fa=father;
}
void rotate(int p){
	int father=a[p].fa,gfather=a[father].fa,lr=fson(p);
	contact(a[p].son[!lr],father,lr);
	contact(p,gfather,fson(father));
	contact(father,p,!lr);
	update(p);update(father);update(gfather);
}
void splay(int p,int to){
	if(p==to||!p)return;
	while(a[p].fa!=to){
		int father=a[p].fa,gfather=a[father].fa;
		if(gfather==to)rotate(p);
		else{
			if(fson(p)==fson(father))rotate(father);
			else rotate(p);
		}
		update(p);update(father);update(gfather);
	}
	if(!to)root=p;
}
void New(int val,int father){
	a[++tot].val=val;
	a[tot].siz=a[tot].cnt=1;
	contact(tot,father,val>a[father].val);
	if(!root)root=tot;
	splay(tot,0);
}
void find(int val){
	if(!root)return;
	int now=root;
	while(a[now].son[val>a[now].val]&&a[now].val!=val)
	now=a[now].son[val>a[now].val];
	splay(now,0);
}
void ins(int p,int val,int las){
	if(!p){New(val,las);return;}
	if(a[p].val==val){a[p].cnt++;update(p);return;}
	ins(a[p].son[val>a[p].val],val,p);
	update(p);
}
int precursor(int val,int zl){
	find(val);
	if(zl==0&&val>=a[root].val)return root;
	if(zl==1&&val>a[root].val)return root;
	int now=a[root].son[0];
	while(a[now].son[1])now=a[now].son[1];
	return now;
}
int successor(int val,int zl){
	find(val);
	if(zl==0&&val<=a[root].val)return root;
	if(zl==1&&val<a[root].val)return root;
	int now=a[root].son[1];
	while(a[now].son[0])now=a[now].son[0];
	return now;
}
void del(int val){
	int pre=precursor(val,1),suc=successor(val,1);
	splay(pre,0);splay(suc,pre);
	int remove=a[suc].son[0];
	if(!suc)remove=a[pre].son[1];
	if(remove==root)root=0;
	if(a[remove].cnt>1){a[remove].cnt--;update(remove);splay(remove,0);}
	else a[a[remove].fa].son[fson(remove)]=0;
}
int main(){
	scanf("%d%d",&n,&m);
	New(0,0);New(n+1,1);
	for(int i=1;i<=m;i++){
		cin>>opt;
		if(opt=='D'){
			scanf("%d",&x);
			ins(root,x,0);stack[++head]=x;
		}
		if(opt=='R'){
			del(stack[head]);head--;
		}
		if(opt=='Q'){
			scanf("%d",&x);
			find(x);
			if(a[root].val==x)printf("%d\n",0);
			else{
				printf("%d\n",(a[successor(x,0)].val-a[precursor(x,0)].val-1));
			}
		}
	}
}
```

---

## 作者：dqnstry (赞：0)

应用平衡树可以在nlgn的复杂度内求解

平衡树维护被毁的地方，每次找前驱后继，一减就是答案。

当然这个题也可以通过把线段树提出来，树上二分复杂度也是nlgn

第一种思路代码如下













        



```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 50005;
int cnt,c[MAXN][2],fa[MAXN],sz[MAXN],v[MAXN],rt,pr,af,loc,n,m;
int mes[MAXN],s;
char str[100];
void pushup(int x){
    int l=c[x][0],r=c[x][1];
    sz[x]=sz[l]+sz[r]+1;
}
void rotate(int x,int &k){
    int y=fa[x],z=fa[y],l,r;
    if(c[y][0]==x)l=0;else l=1;r=l^1;
    if(y==k)k=x;
    else{if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
    fa[y]=x;fa[x]=z;fa[c[x][r]]=y;
    c[y][l]=c[x][r];c[x][r]=y;
    pushup(y);pushup(x);
}
void splay(int x,int &k){
    int y,z;
    while(x!=k){
        y=fa[x];z=fa[y];
        if(y!=k){
            if((c[z][0]==y)^(c[y][0]==x))rotate(y,k);
            else rotate(x,k);
        }
        rotate(x,k);
    }
}
void getpr(int x,int val){
    int l=c[x][0],r=c[x][1];
    if(x==0)return;
    if(v[x]<val){if(v[x]>pr){pr=v[x];loc=x;}getpr(r,val);}
    else getpr(l,val);
}
void getaf(int x,int val){
    int l=c[x][0],r=c[x][1];
    if(x==0)return;
    if(v[x]>val){if(v[x]<af){af=v[x];loc=x;}getaf(l,val);}
    else getaf(r,val);
}
void dfs(int x){
    if(x==0)return;
    dfs(c[x][0]);
    printf("%d ",v[x]);
    dfs(c[x][1]);
}
bool find(int x,int k){
    if(x==0)return 0;
    if(v[x]==k)return 1;
    if(k<v[x])return find(c[x][0],k);
    else return find(c[x][1],k);
}
void del(int v){
    pr=-0x3f3f3f3f;loc=0;
    getpr(rt,v+1);
    splay(loc,rt);
    if(c[rt][0]*c[rt][1]==0)
        rt=c[rt][0]+c[rt][1];
    else{
        pr=-0x3f3f3f3f;loc=0;
        getpr(c[rt][0],0x3f3f3f3f);
        splay(loc,c[rt][0]);
        fa[c[rt][1]]=c[rt][0];
        c[c[rt][0]][1]=c[rt][1];
        rt=c[rt][0];
    }
}
void ins(int &x,int val,int pr){
    if(x==0){x=++cnt;v[x]=val;sz[x]=1;fa[x]=pr;splay(x,rt);return;}
    if(val<v[x])ins(c[x][0],val,x);
    else ins(c[x][1],val,x);
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        int a;
        scanf("%s",str);
        if(str[0]=='D'){
            scanf("%d",&a);
            ins(rt,a,0);
            mes[++s]=a;
        }else if(str[0]=='R'){
            del(mes[s]);
            s--;
        }else{
            scanf("%d",&a);
            af=0x3f3f3f3f;pr=-0x3f3f3f3f;
            getaf(rt,a);getpr(rt,a);
            if(af>n)af=n+1;
            if(pr<1)pr=0;
            af--;pr++;
            if(find(rt,a))puts("0");
            else printf("%d\n",af-pr+1);
        }
    }
    return 0;
}
```

---

## 作者：LVYOUYW (赞：0)

这道题我们抽象成基本模型，问题就是给你一个开始全是1的序列，然后有2个操作，1是将一个位置的值 xor 1，2是询问x这个位置最左边的连续1的位置和最右边连续1的位置。我们可以怎么做呢？感觉一般的数据结构不太好弄，即使可以也要套一个二分什么的，那么我们可以考虑分块来做，我们将其分成根号n块，对于每一块，我们维护一个flag[i]，flag[i]=1表示第i块全部是1，否则表示存在0，那么对于一次修改操作，我们只需要用根号n的时间维护flag[i]，对于一次查询操作，我们先将x到x所在块的右区间扫一遍，如果发现0就返回，否则我们开始看x所在块的下一块的flag值，如果flag[i]=1，跳到下一块，否则暴力的扫找到1的位置，这样每次查询的复杂度也是根号n的，这样我们就能在m根号n的时间内解决，而且常数非常小。

      
      
      
      
```cpp
    #include<cstdio>  
    #include<cstring>  
    #include<algorithm>  
    using namespace std;  
    #define maxn 200005   
    const int block=224;  
    int a[maxn],L[450],R[450],b[maxn],cnt,n,m,last[maxn],tot;  
    bool flag[450];  
    int queryl(int x)  
    {  
        int temp=x-1;  
        for (int i=x-1;i>=L[b[x]];i--)   
            if (a[i]!=1) return temp-i;  
        x=L[b[x]]-1;  
        while (flag[b[x]]&&x>0) x=L[b[x]]-1;  
        if (x<=0) return temp;  
        for (int i=x;i>=L[b[x]];i--)   
            if (a[i]!=1) return temp-i;  
    }  
    int queryr(int x)  
    {  
        int temp=x;  
        for (int i=x;i<=R[b[x]];i++)   
            if (a[i]!=1) return i-temp;  
        x=R[b[x]]+1;  
        while (flag[b[x]]&&x<=n) x=R[b[x]]+1;  
        if (x>n) return n+1-temp;  
        for (int i=x;i<=R[b[x]];i++)   
            if (a[i]!=1) return i-temp;  
    }  
    void change(int x,int y)  
    {  
        a[x]=y;  
        bool ok=1;  
        for (int i=L[b[x]];i<=R[b[x]];i++)   
        {  
            if (a[i]!=1)   
            {  
                ok=0;  
                break;    
            }  
        }  
        if (ok) flag[b[x]]=1;  
        else flag[b[x]]=0;  
    }  
    int main()  
    {  
        scanf("%d",&n);  
        for (int i=1;i<=n;i++) a[i]=1;  
        for (int i=1;i<=n;i++)   
        {  
            b[i]=(i-1)/block+1;  
            if (b[i]!=b[i-1]) L[b[i]]=i,R[b[i-1]]=i-1;    
        }  
        L[1]=1;R[b[n]]=n;  
        for (int i=1;i<=b[n];i++)   
        {  
            bool ok=1;  
            for (int j=L[i];j<=R[i];j++)  
                if (a[j]!=1) {ok=0;break;}  
            if (ok) flag[i]=1;    
        }  
        scanf("%d",&m);  
        for (int i=1;i<=m;i++)   
        {  
            char opt[3];  
            int x;  
            scanf("%s",opt);      
            if (opt[0]=='R')   
            {  
                change(last[tot],1);  
                tot--;  
                continue;  
            }  
            scanf("%d",&x);  
            if (opt[0]=='D') {change(x,0);last[++tot]=x;}  
            if (opt[0]=='Q')   
                if (a[x]==0) printf("0\n");  
                else printf("%d\n",queryl(x)+queryr(x));  
        }  
        return 0;     
}
```

---


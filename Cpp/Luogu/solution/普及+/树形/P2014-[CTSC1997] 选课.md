# [CTSC1997] 选课

## 题目描述

在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？

## 样例 #1

### 输入

```
7  4
2  2
0  1
0  4
2  1
7  1
7  6
2  2
```

### 输出

```
13```

# 题解

## 作者：He_Ren (赞：824)

[题目传送门](https://www.luogu.org/problemnew/show/P2014)

首行求赞，反正不FA钱$\ \text{qwq}$

## 0. 前置

- 动态规划基础
- 知道树是什么，以及存图方式

## 1. 题意简述

- 一堆树构成的森林，共$N$个点。
- 每个点有一个权值$s_i$
- 一个点可以被选择，当且仅当它到根节点的路径上的**所有点**都被选择。

共选择$M$个点，求被选择的点的权值和的最大值

## 2. 一个小技巧

我们发现，如果0算一个节点的话，整张图就是一棵树了

这样的好处：

1. 一棵树就不用分别考虑各棵树然后合并了
2. 输入方便很多，不用特别处理$0$的情况


但是$M$就会受影响

因为根节点$0$是必选的，所以只要让$M$增加$1$就好了

---

**确保您理解了以上内容再看下面的部分，如果不理解可以自己画图体会**

---


## 3. dp及初步设计状态

首先，不难看出，父节点的信息可以由子节点合并得到并且不会影响子节点

所以使用 dp/记忆化搜索 就好了$\ \text{qwq}$

不难想到，用$\text{dp[u][i]}$表示以节点$u$为根的子树 ，选择$i$个点可以获得的最大权值和

然后想如何转移

。。。好像遇到麻烦了

显然合并子节点的信息一定能得到父节点的信息，但使用简单的算法好像不行了

~~没事反正数据范围小~~

可以考虑dp套dp（当然这个题算比较简单的）

## 4. 背包

继续观察，发现每个子节点都会占用父节点$i$的一部分，又有一个贡献，可以选择或不选择

重量。。。价值。。。总重。。。

这不是01背包吗？

不同之处在于，每个子节点的重量都是变量

### 重新设计状态

用$dp[u][i][j]$表示节点$u$的前$i$个子节点，限重为$j$能得到的最大权值和（价值和）

像01背包一样压缩空间，得到：

```dp[u][j]表示节点u，限重j的最大权值和（价值和）```

代码：

```cpp
for(int i=head[u]; i; i=e[i].next)//遍历所有子节点
	for(int j=m, v=e[i].to; j>0; --j)//这里和01背包一样，总重从大到小循环
		for(int k=0; k<j; ++k)//这里是不同之处，子节点的重量需要规定
			chk_max(dp[u][j], dp[u][j-k]+dp[v][k]);//此函数是将前一个参数设为二者的最大值（您不会不知道吧），不明白下面有代码
```

5. code

```cpp
#include<cstdio>
const int MAXN = 300 + 5;
const int MAXM = 300 + 5;

inline void chk_max(int &a,int b){ if(a<b) a=b;}

//前向星存图
struct Edge
{
	int next,to;
}e[MAXN];
int head[MAXN],ecnt=0;
inline void add(int u,int v)
{
	++ecnt;
	e[ecnt].next=head[u];
	e[ecnt].to=v;
	head[u]=ecnt;
}

int m;
int dp[MAXN][MAXM];

void solve(int u)
{
	for(int i=head[u]; i; i=e[i].next)
		solve(e[i].to);//先处理子节点
	
    //背包部分
	for(int i=head[u]; i; i=e[i].next)
		for(int j=m, v=e[i].to; j>0; --j)
			for(int k=0; k<j; ++k)
				chk_max(dp[u][j], dp[u][j-k]+dp[v][k]);
}

int main(void)
{
	
	int n;
	scanf("%d%d",&n,&m);
	++m;//上文提到了
	for(int i=1; i<=n; ++i)
	{
		int fa;
		scanf("%d%d",&fa,&dp[i][1]);//思考：为什么直接用dp[i][1]？
		add(fa,i);
	}
	
	solve(0);
	printf("%d",dp[0][m]);
	return 0;
}
```

本题解主要用于理清自己思路，如果有与他人方法重复也不要喷qaq

实际还写了蛮长时间的。。。码字手酸，见谅qwq

如果您觉得题解有错误，可以私信或者评论

当然别忘了点赞qwq

---

## 作者：HullEssien (赞：537)

给树形DPの初学者(其实就是我哈哈(๑•̀ㅂ•́)و✧)


其实这个题不知道为什么是提高+/省选-

还是比较简单的

瞄一眼下去就是DP

但是怎么DP呢?

可以发现学习课程是有顺序的

我马上想到了DAG

然后又发现每门课有最多有一个先修课

所以这一定是一个森林

为了方便处理也是为了迎合输入数据

就把0号节点看做根节点即可

这样实质上就什么也不用处理

只需要在考虑的时候

把0号节点列入必选的范围即可

即要选m+1门课


(我看楼下这些问题都有讲,但是唯独状态转移方程是怎么推出来的没有讲,可能是觉得太简单了吧.但是DP最核心的部分就是推状态转移方程啊,而且这恰恰是新手最欠缺的地方,我觉得来看题解的人都是来看这个的吧(划掉))


解决了这个问题之后

我们就考虑怎么在树上DP就行了

DP的核心是状态的设计和重叠的子问题结构

我们发现

树本身就是一个递归的结构

所以考虑在每棵子树上DP

然后合并就行了


怎么在子树上DP呐(ㆀ˘･з･˘)?

因为DP的一个核心思想是**从最简单的子问题开始,逐步扩大子问题规模**

所以我们当然要从最简单的状态讲起

一棵子树最简单的状态是啥?

对一棵子树,要想选其中的点,根节点是必须选的

所以不妨设根节点为1号节点

然后按我们存图的顺序依次给每个儿子编号(从2(到儿子的个数+1))

这样状态就好设计了

不妨设f[now][j][k]表示以now为根节点的子树

考虑**前j个节点**选k门课的方案数

因为1号节点是根节点,显然递推起点f[now][1][1]=val[now]

这样很容易得到状态转移方程

f[now][j][k]=max(f[now][j-1][k],f[son][所有节点数][l]+f[now][j-1][k-l]);


然后我们观察等式两边的特点

**哪些是我们已知的?**

在对now求解前

我们至少已经处理完了前面的子树

所以f[son][所有节点数][l]

是可以直接用的

然后
在处理第j个节点前

前j-1个节点是我们已经处理过的

所以f[now][j-1][k]和f[now][j-1][k-l]也不用考虑循环顺序问题


但是问题来了

这样开三维数组不会炸空间吗

也许本题不会

但是我们可以很显然的发现

**空间是可以优化的**

只要稍稍改变循环顺序即可

我要用到j-1的内容

都是满足l<k的

所以倒着循环k

这样就可以使我们在一个数组中当前值和上面我们用到的值完全不影响

就酱~

最后的状态转移方程在代码里



代码:







```cpp
#include<iostream>
#include<cstdio>
#define maxn 1000
using namespace std;
int n,m,f[maxn][maxn],head[maxn],cnt;
struct edge
{
    int to,pre; 
}e[maxn];
inline int in()
{
    char a=getchar();
    while(a<'0'||a>'9')
    {
        a=getchar();
    }
    int t=0;
    while(a>='0'&&a<='9')
    {
        t=(t<<1)+(t<<3)+a-'0';
        a=getchar();
    }
    return t;
}
void add(int from,int to)
{
    e[++cnt].pre=head[from];
    e[cnt].to=to;
    head[from]=cnt;
}
void dp(int now)
{
//    f[now][0]=0;
    for(int i=head[now];i;i=e[i].pre)
    {
        int go=e[i].to;
        dp(go);
        for(int j=m+1;j>=1;j--)
        {
            for(int k=0;k<j;k++)
            {
                f[now][j]=max(f[now][j],f[go][k]+f[now][j-k]);
            }
        }
    }
}
int main()
{
    n=in(),m=in();
    for(int i=1;i<=n;i++)
    {
        int fa=in();
        f[i][1]=in();
        add(fa,i);
    }
    dp(0);
    printf("%d\n",f[0][m+1]);
    return 0;
}
```

---

## 作者：我没有小白 (赞：257)

初学树形$dp$的可以来这里的博客观摩一下
[树形dp学习笔记](https://www.cnblogs.com/ifmyt/p/9588872.html)

>今天学习了树形$dp$，一开始浏览各大$blog$，发现都$TM$是题，连个入门的$blog$都没有，体验极差。所以我立志要写一篇可以让初学树形$dp$的童鞋快速入门。

# 树形$dp$

## 概念类

树形$dp$是一种很优美的动态规划，真的很优美真的，前提是在你学会它之后。

## 实现形式

树形$dp$的主要实现形式是$dfs$，在$dfs$中$dp$，主要的实现形式是$dp[i][j][0/1]$，$i$是以$i$为根的子树，$j$是表示在以$i$为根的子树中选择$j$个子节点，$0$表示这个节点不选，$1$表示选择这个节点。有的时候$j$或$0/1$这一维可以压掉

## 基本的$dp$方程

### 选择节点类
$$\begin{cases}dp[i][0]=dp[j][1]\\dp[i][1]=\max/\min(dp[j][0],dp[j][1])\\\end{cases}$$

### 树形背包类
$$\begin{cases}dp[v][k]=dp[u][k]+val\\dp[u][k]=max(dp[u][k],dp[v][k-1])\\\end{cases}$$
## 例题类

以上就是对树形$dp$的基本介绍，因为树形$dp$没有基本的形式，然后其也没有固定的做法，一般一种题目有一种做法。

### [没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)

这道题是一树形$dp$入门级别的题目，具体方程就用到了上述的选择方程。
```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 6001
using namespace std;
int ind[N],n,hap[N],dp[N][2],fa[N],root,vis[N],ne[N],po[N];
void work(int x)
{
    for(int i = po[x]; i; i = ne[i])
    {
        work(i);
        dp[x][1]=max(max(dp[x][1],dp[x][1]+dp[i][0]),dp[i][0]);
        dp[x][0]=max(max(dp[x][0],dp[i][1]+dp[x][0]),max(dp[i][1],dp [i][0]));
    }
}
int main()
{
    cin >> n;
    for(int i=1; i<=n; i++)
        cin >> dp[i][1];
    for(int i=1; i<=n; i++)
    {
        int a,b;
        cin >> b >> a;
        ind[b]++;
        ne[b] = po[a];
        po[a] = b;
    }
    for(int i=1; i<=n; i++)
        if(!ind[i])
        {
            root=i;
            break;
        }
    work(root);
    cout << max(dp[root][0],dp[root][1]);
}
```
### [最大子树和](https://www.luogu.org/problemnew/show/P1122)

这道题的$dp$方程有变，因为你的操作是切掉这个点，所以你的子树要么加上价值，要么价值为$0$，所以$dp$方程是
$$dp[u]+=max(dp[v],0)$$
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>

using namespace std;
struct edge
{
    int next,to;
} e[40000];
int head[40000],tot,rt,maxn;
void add(int x,int y)
{
    e[++tot].next=head[x];
    head[x]=tot;
    e[tot].to=y;
}
int n,dp[20000],ind[20000];
int val[20000],f[20000];
void dfs_f__k(int x,int fa)
{
    f[x]=fa;
    for(int i=head[x]; i; i=e[i].next)
    {
        int v=e[i].to;
        if(v!=fa)
            dfs_f__k(v,x);
    }
}
void dfs(int x)
{
    dp[x]=val[x];
    for(int i=head[x]; i; i=e[i].next)
    {
        int v=e[i].to;
        if(v!=f[x])
        {
            dfs(v);
            dp[x]+=max(0,dp[v]);
        }
    }
    maxn=max(maxn,dp[x]);
}
int main()
{
    scanf("%d",&n);
    for(int i=1; i<=n; i++)scanf("%d",&val[i]);
    for(int i=1; i<=n-1; i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);
    }
    rt=1;
    dfs_f__k(rt,0);
    dfs(rt);
    printf("%d",maxn);
}
```
### [选课](https://www.luogu.org/problemnew/show/P2014)
这道题的意思是每本书要想选择一门课，必须要先学会它的必修课，所以这就形成了一种依赖行为，即选择一门课必须要选择必修课。那么他又说要选择的价值最大，这就要用到树形背包的知识了。
树形背包的基本代码形式（即上面的树形背包类）
```cpp
/*
设dp[i][j]表示选择以i为根的子树中j个节点。
u代表当前根节点，tot代表其选择的节点的总额。
*/
void dfs(int u,int tot)
{
	for(int i=head[x];i;i=e[i].next)
	{
		int v=e[i].to;
		for(int k=0;k<tot;k++)//这里k从o开始到tot-1，因为v的子树可以选择的节点是u的子树的节点数减一
			dp[v][k]=dp[u][k]+val[u];
		dfs(v,tot-1)
		for(int k=1;k<=tot;k++)
			dp[u][k]=max(dp[u][k],dp[v][k-1]);//这里是把子树的值赋给了根节点，因为u选择k个点v只能选择k-1个点。
	}
}
```
然后这就是树形背包的基本形式，基本就是这样做
代码
```cpp
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;

int n,m;
struct edge
{
    int next,to;
}e[1000];
int rt,head[1000],tot,val[1000],dp[1000][1000];
void add(int x,int y)
{
    e[++tot].next=head[x];
    head[x]=tot;
    e[tot].to=y;
}
void dfs(int u,int t)
{
    if (t<=0) return ;
    for (int i=head[u]; i; i=e[i].next)
    {
        int v = e[i].to;
        for (int k=0; k<t; ++k) 
            dp[v][k] = dp[u][k]+val[v];
        dfs(v,t-1);
        for (int k=1; k<=t; ++k) 
            dp[u][k] = max(dp[u][k],dp[v][k-1]);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int a;
        scanf("%d%d",&a,&val[i]);
        if(a)
          add(a,i);
        if(!a)add(0,i);
    }
    dfs(0,m);
    printf("%d",dp[0][m]);
}
```
### [Strategic game](https://www.luogu.org/problemnew/show/UVA1292)

这道题的意思是选择最少的点来覆盖一棵树，可以用最小点覆盖（也就是二分图最大匹配）或者树形$dp$来做，因为这里我们的专题是树形$dp$，所以我们现在就讲树形$dp$的做法。
我们做这道题的方法是用选择方程来做，因为你要做最小点覆盖，要么选这个点要么不选对吧。
于是$dp$的转移方程就是上述一方程
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
int n;
struct edge
{
    int next,to;
} e[4000];
int head[4000],tot,dp[4000][2],ind[4000];
void add(int x,int y)
{
    e[++tot].next=head[x];
    head[x]=tot;
    e[tot].to=y;
}
void dfs(int x)
{
    dp[x][1]=1;
    for(int i=head[x]; i; i=e[i].next)
    {
        int v=e[i].to;
        dfs(v);
        dp[x][0]+=dp[v][1];
        dp[x][1]+=min(dp[v][0],dp[v][1]);
    }
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        memset(dp,0,sizeof(dp));
        memset(head,0,sizeof(head));
        memset(ind,0,sizeof(ind));
        tot=0;
        for(int j=1; j<=n; j++)
        {
            int a,b;
            scanf("%d:(%d)",&a,&b);
            for(int i=1; i<=b; i++)
            {
                int c;
                scanf("%d",&c);
                ind[c]++;
                add(a,c);
            }
        }
        int rt;
        for(int i=0; i<=n; i++)
            if(!ind[i])
            {
                rt=i;
                break;
            }
        dfs(rt);
        printf("%d\n",min(dp[rt][1],dp[rt][0]));
    }
}
```

---

## 作者：wjyyy (赞：152)

【选课】这道题看上去是一道进阶版的树形DP，因为其中嵌套了一定的背包的思想

代码流程：首先建树存图，这里的处理有一个小技巧，就是如果有多个根结点，那么不容易进行DFS，所以我们构造出一个$0$结点，刚好，输入时也是用$0$来代替的，这样只用在最后输出时调用$\mathrm{[m+1]}$即可。s数组代表该结点有几个儿子，之后在DFS中更新为后代个数，p数组代表结点的权值，（图中黑色数字）![样例](https://cdn.luogu.com.cn/upload/pic/15192.png)
然后开始DFS，DFS的回溯是树形DP的重点以及核心。

我们DFS的搜索边界是链表的尾端，**当回溯结束后，$root$的子树已经被遍历完并处理完了。**这便是树形DP的最重要的特点。

**背包**过程中嵌套了三重循环（实际加上DFS的是四重），
首先$\mathrm {r=root->next}$枚举了$\mathrm {root}$的子树 _子树间不会互相影响，所以这些可以分开做。_ 但是$j$和$k$的顺序一定要分好，因为是相当于$01$背包，所以$k$要倒序，$j$是用来枚举$\mathrm {r->data}$即正在遍历的点的儿子个数，因为现在正在遍历的点已经被DFS过了（要不然不会退到这个$x$结点的），则它是当前状况的最优解，可以从那边转移过来。**但是$k$一定要在$j$前面，因为当$k$相同时，不同的$j$可能存在包含相同点的情况，为了避免这种情况，我们选择把k放在外面。这样$f[x][k]$就不会重复更新涉及相同的点了——举个栗子** ![栗子](https://cdn.luogu.com.cn/upload/pic/15194.png)

```cpp
如果k循环在j里面的话，当我们更新到图中2号结点后，1号结点的f[x][k]会被更新，
在k++;后，f[x][k]在符合情况时会继续更新，这样就会导致结果出错（偏大）的情况出现
```
**背包核心：**

```cpp
    while(r!=0)
    {
        for(int k=s[x];k>=1;k--)
            for(int j=1;j<=k;j++)//j是枚举r->data的选科个数
            //其中j<=k防止数组越界
                    f[x][k]=max(f[x][k],f[x][k-j]+f[r->data][j]);
        r=r->next;//链表继续遍历
    }
    for(int i=s[x];i>=0;i--)
        f[x][i+1]=f[x][i]+p[x];
```
为什么最后两行要单独拿出来做呢？
```
for(int i=s[x];i>=0;i--)
        f[x][i+1]=f[x][i]+p[x];
```
我们回到题面上，父亲是儿子的先修课，所以没有父亲时，儿子再多也没有用，背包中处理的子树是不带根结点的，我们要加上，否则会出现下面这种状况：![否则](https://cdn.luogu.com.cn/upload/pic/15195.png)

如果在做的过程中将根结点算入子树，那么$\mathrm f[1][2]$最终值将会是$11$（在正确的过程中也是$11$，但是会被更新到$f[1][3]$），不做更新或再去做一遍更新就不对了，核心思想结束。

最后输出的是$f[0][m+1]$，所以$0$这个“根结点“”是非常方便的。

总结：
1. 树形DP要根据实际情况，改变循环顺序和方向；
1. 要判断根结点是否包含在子树，并在这个判断最终稍加处理
1. 状态要保存准确，不能丢失要用到的状态

------------
## Code:

```cpp
#include<cstdio>
#include<cstring>
int max(int x,int y){return x>y?x:y;}
struct node
{
    int data;
    node *next;
    node()
    {
        next=NULL;
    }
};
node head[301],*tail[301];//用于链表
int f[301][301],s[301],n,m,p[301];
void dfs(int x)
{
    node *root;
    root=&head[x];
    node *r=root->next;
    while(root->next!=0)
    {
        root=root->next;
        dfs(root->data);
        s[x]+=s[root->data];
    }
    //开始背包
    while(r!=0)
    {
        for(int k=s[x];k>=1;k--)
            for(int j=1;j<=k;j++)//j是枚举r->data的选科个数
                    f[x][k]=max(f[x][k],f[x][k-j]+f[r->data][j]);
        r=r->next;
    }
    for(int i=s[x];i>=0;i--)
        f[x][i+1]=f[x][i]+p[x];
    return ;
}
int main()
{
    memset(s,0,sizeof(s));
    memset(f,0,sizeof(f));
    int a,b;
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n;i++)
        tail[i]=&head[i];
    for(int i=1;i<=n;i++)//建树存图
    {
        scanf("%d%d",&a,&b);
        s[a]++;
        node *t=new node();
        t->data=i;
        p[i]=b;
        tail[a]->next=t;
        tail[a]=t;
    }
    dfs(0);
    printf("%d\n",f[0][m+1]);//m+1是因为把0当做一个结点（课程）
    return 0;
}

```

---

## 作者：Planet6174 (赞：111)

我过来口胡一下 DFS 序的奇妙做法。

我们把原树叫做 A。

定义　 多叉树的**后序遍历**指的是：在搜索某个结点的过程中，先记录它的所有子树，再记录它本身。注意，如果有多个子树，则后序遍历的顺序不限。

定义　 多叉树的**后序遍历序列**指的是在上述过程中所记录下来的序列。

我们不妨在 DFS 后把结点按照后序遍历序列**重新编号**。下图就是一个例子，左图为原树 A，右图为重新编号的树 B。

![](https://i.loli.net/2019/02/19/5c6bd9547ffd1.png)

现在，如果我们要复制一棵树 B（不妨称复制品为 C），将新树 B 里面的结点**按编号**（也就是按照 A 树的后序遍历序列）**依次**加入 C 中，我们会发现，**每次加入的结点在当前情况下都是根结点**。下图展示了放入 4, 7, 8, 9 号结点时，新图的情况。

![](https://i.loli.net/2019/02/19/5c6bd9f4ca063.png)


因此，设 $\mathrm{dp}(i,j)$ 表示将树 B 的结点 $1\ldots i$ 放入新图，背包容量为 $j$ 时，所能取得的最大价值。设 $\mathrm{size}_i$ 表示以 $i$ 为根的子树的大小。

- 若取物品 $i$（前提是此时的背包容量放得下物品 $i$），则可以取它的子树，则
  * 问题转化为「将结点 $1\ldots i-1$ 加入 C，且背包容量为 $j-1$ 时，所能取到的最大价值」加上物品 $i$ 的价值，
  * 所以答案为 $\mathrm{dp}(i-1,j-1)+v_i$；
- 若不取物品 $i$，则不可以取它的子树，则
  * 问题转化为「将『结点 $1\ldots i-1$ 中不属于 $i$ 的子树的结点』加入 C，背包容量不变时，所能取到的最大价值」
  * 答案为 $\mathrm{dp}(i-\mathrm{size}_i,j)$；

综上可得 $\mathrm{dp}(i,j)=\begin{cases}\max(\mathrm{dp}(i-1,j-1)+v_i,\;\mathrm{dp}(i-\mathrm{size}_i,j)) & j\ge w_i \\ \mathrm{dp}(i-\mathrm{size}_i,j) & j<w_i \end{cases}$ 。

易证其时间复杂度为 $O(NM)$。

最后打个广告，LOJ 已上线树形背包模板题 https://loj.ac/p/160 ，欢迎大家来玩~

---

## 作者：Snitro (赞：98)

题目中提到每门课的直接先修课最多只有一门，将每门课的先修课与其相连，将会构成一颗或者多颗树。为此我们可以建立一个 0 号节点，将所有树的根节点都连向 0 号节点。0 号节点的学分为 0，并且允许选修的课数量要自加一。


将森林拼接成一棵树之后我们就需要对这一颗树进行树上的动态规划了。


考虑树上的每一个节点：这个节点可能是一个或者多个节点的父节点(先修课)，也有可能没有。用 f[i][j] 表示对于节点 i ， 一共选择 j 门课所能得到的最大学分(j 门科目中包括他本身)。选择他的所有子节点的前提是一定要选择这个节点，所 f[i][1] 一定等于 i 节点的权值(学分)


按照一定的顺序遍历 i 节点的所有子节点。当遍历到 x 节点的时候，我们假设已经得到了所有 f[x][k] 的值。由于 f[i][k] 中是没有 x 节点及其子树的权值的，所以可以通过 x 节点来更新 i 节点的 f 数组。即 f[i][k] = max(f[i][k], f[i][k - p] + f[x][p]) (1 ≤ k ≤ m ， 0 ≤ p < k)


p < k 的原因是当 p = k 的时候 f[i][k - p] 中 k - p 的值等于 0，这说明 i 这个节点无法被选择到，由于 i 是 x 节点的先修课，不选择 i 节点便无法选择 x 节点，所以应满足 p < k


在枚举 k 的时候需要注意：由于 f[i][k] 由 f[i][k - p] 更新得到，那么就需要保证更新 f[i][k] 的时候 f[i][k - p] 没有被更新，由于 p 是一个正整数，所以我们倒序枚举 k 即可


源代码






















```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int n, m;
int score[305], fa[305];
bool vis[305];
int f[305][305];
int head[305], edge_len;
struct Edge {
    int to;
    int next;
} edges[605];
void add(int from, int to) {//加边
    edges[++edge_len].to = to;
    edges[edge_len].next = head[from];
    head[from] = edge_len;
}
void dfs(int x) {
    f[x][1] = score[x];
    int to;
    for (int i = head[x]; ~i; i = edges[i].next) { // 遍历 x 的所有子节点
        to = edges[i].to; // to 是 x 的一个子节点
        dfs(to); // 计算 to 节点的 f 数组
        for (int j = m; j >= 1; j--)//倒序枚举，使用 to 节点的 f 数组更新 x 节点的 f 数组
            for (int i = j - 1; i >= 1; i--)
                f[x][j] = max(f[x][j], f[x][j - i] + f[to][i]);
    }
}
int main() {
    freopen("in.txt", "r", stdin);
    scanf("%d%d", &n, &m);
    memset(head, -1, sizeof(head));
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &fa[i], &score[i]);
        add(fa[i], i);//由父节点指向子节点的单向边
    }
    m++; // 由于 0 号节点的参与，m 需要自加1
    dfs(0);//搜索 0 号节点
    cout << f[0][m];
    return 0;
}
```

---

## 作者：dph754132771 (赞：41)

/\*
\* P2014

\* Au:Small\_Ash

\* 好多人这题用多叉转二叉啊，就我用树形DP强行么。。。

\* 有树形的，但是没有讲详细啊。

\* 大家可以参考题目P1273 有线电视网来做做看

\* 两题都是树形DP

\* 然而我前几天才知道树形DP的实现要用到DFS。。。怪不得我上个月做这题只有60。。。

\* 下面来讲树形DP了

\* F[i][j]表示第i个节点取j个子节点（不包括自己）所取得的最大（最小）收益。

\* 当然F[i][j]的第二维j要根据题目来定，像1273的第二维用来存接受端的数量比较好。

\* 但是大部分的第一维都是指第i个节点（毕竟它还是一个DP啊）。

\* 树形DP和线性的最大区别就是——DP的顺序有讲究。没错，就是先DP儿子。

\* 然后就有了转移方程F[i][j]=max/min(f[i][j],f[i][j-k]+f[儿子节点编号][k]=....)【根据题目省略号可能会有东西】

\* 可是问题就来了，怎么知道自己究竟有多少个子节点，并且保证DP该点之前子节点已经被DP过了呢（我上个月就因为这个问题才60 QAQ）

\* 没错，就是搜索树的神器——DFS

\* 为了方便编写，我们可以直接在DFS的过程中DP，DP时用到了子节点的话就DFS子节点。

\* 这样就不会出现DP顺序的错误啦！

\* 下面是代码。

\*/
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int n,m,f[2005][2005];
int head[2005],next[2005],w[2005];
int dfs(int x){
    if (head[x]==-1) return 0;
    int sum=0;
    for (int i=head[x];i!=-1;i=next[i]){
        int t=dfs(i);
        sum+=t+1;
        for (int j=sum;j>=0;j--){//注意，一定要是降序，我忘了降序于是就0分了一次 QAQ 
            for (int k=0;k<=t;k++)
                if (j-k-1>=0) f[x][j]=max(f[x][j],f[x][j-k-1]+f[i][k]);
        }
    }
    return sum;
}
int main(){
    scanf("%d%d",&n,&m);
    memset(f,0,sizeof(f));
    memset(head,-1,sizeof(head));
    for (int i=1;i<=n;i++){
        int a;
        scanf("%d%d",&a,&w[i]);
        next[i]=head[a];
        head[a]=i;
    }
    for (int i=1;i<=n;i++) f[i][0]=w[i];
    f[0][0]=0;
    dfs(0);
    printf("%d",f[0][m]);
    return 0;
```
}//是的，代码就是那么短。。。就35行。。。

---

## 作者：KevinYu (赞：28)

一道树形dp题，两种解法。      
这道题是一道多叉树资源分配问题(说的通俗一些就是书上背包)。     
我们来过一遍算法流程:      
解法一(根据dfs时的顺序求解):       
我们的dfs过程是这样的:     
定义```dfs(int u,int d)```表示现在的节点是u，深度是d。   
1.遍历每一条边     
```cpp
void dfs(int u,int d)
{
    for(int i=head[u];i!=-1;i=a[i].next)
    {
        int v=a[i].to;
```
2.对于其能到达的每一条点的值进行初始化，并继续dfs过程。
```cpp
        for(int j=d+1;j<=m+1;j++)f[v][j]=f[u][j-1]+w[v];
        dfs(v,d+1);
```
3.根据转移方程完成一个dfs过程。
```
        for(int j=d+1;j<=m+1;j++)f[u][j]=max(f[u][j],f[v][j]);
    }
}
```
蒟蒻的转移方程推导:      
```
对于一个点u，我们可以选它或不选它。
若要选的话，我们就可以选择它的孩子dp[u][j]=max{dp[v][j]}+w[u];
若不选的话，它的孩子也不能选择了。
所以有
for(int j=d+1;j<=m+1;j++)f[v][j]=f[u][j-1]+w[v];
for(int j=d+1;j<=m+1;j++)f[u][j]=max(f[u][j],f[v][j]);
```
完整代码:
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<climits>
#include<ctime>
#include<algorithm>
#include<complex>
#include<iostream>
#include<map>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define ll long long
using namespace std;
struct edge
{
    int to,next;
}a[1100];
int head[550];
int f[550][550];
int w[550];
int cnt(0);
int n,m;
void addedge(int xi,int yi)
{
    a[cnt].to=yi;
    a[cnt].next=head[xi];
    head[xi]=cnt++;
}
void dfs(int u,int d)
{
    for(int i=head[u];i!=-1;i=a[i].next)
    {
        int v=a[i].to;
        for(int j=d+1;j<=m+1;j++)f[v][j]=f[u][j-1]+w[v];
        dfs(v,d+1);
        for(int j=d+1;j<=m+1;j++)f[u][j]=max(f[u][j],f[v][j]);
    }
}
int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;++i)
    {
        int x;
        scanf("%d%d",&x,w+i);
        addedge(x,i);
    }
    for(int i=0;i<=m+2;i++)f[0][i]=0;
    dfs(0,1);
    printf("%d",f[0][m+1]);
}

```
解法二(多叉树转二叉树求解):
我们发现多叉树上运用树形dp太玄学了，所以我们把其转换为二叉树求解。       
我们读入时不用前向星存图，而是用另外一种方法：    
```cpp
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        a[i]=y;
        if(x==0)x=n+1;
        rs[i]=ls[x];
        ls[x]=i;
    }
```
我们用节点在二叉树上的x的左孩子(即```ls[x]```
)来存储节点x实际结构中的第一个孩子，用其在二叉树上的右孩子(即```rs[x]```)来存储其在实际树上的右边第一个兄弟。     
然后我们记忆化搜索一遍来完成这个过程。     
算法流程：  
我们规定dfs(i,j)表示当前节点是i，可以更新j次。
1.初始化(如果我们已经更新过了，就不再更新):
```cpp
void dfs(int i,int j)
{
    if(f[i][j]>0||!j||!i)return;
```
2.同样的，我们可以选择选i或不选i：     
①.若不选，我们就搜它的右孩子：
```cpp
    dfs(rs[i],j);
    f[i][j]=max(f[i][j],f[rs[i]][j]);
```
②.若选，我们就搜它的左孩子：
```
    for(int k=0;k<=j-1;k++)
	{
        dfs(ls[i],j-k-1);
        dfs(rs[i],k);
        f[i][j]=max(f[i][j],f[rs[i]][k]+f[ls[i]][j-k-1]+a[i]);
    }
}
```
状态转移方程：
```
f[i][j]=max(f[rs[i]][j],f[ls[i]][k]+f[i][j-k-1]+a[i]);
```
完整代码；
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<climits>
#include<ctime>
#include<algorithm>
#include<complex>
#include<iostream>
#include<map>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define ll long long
using namespace std;
int f[550][550];
int ls[550];
int rs[550];
int a[550];
int n,m;
void dfs(int i,int j)
{
    if(f[i][j]>0||!j||!i)return;
    dfs(rs[i],j);
    f[i][j]=max(f[i][j],f[rs[i]][j]);
    for(int k=0;k<=j-1;k++)
	{
        dfs(ls[i],j-k-1);
        dfs(rs[i],k);
        f[i][j]=max(f[i][j],f[rs[i]][k]+f[ls[i]][j-k-1]+a[i]);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        a[i]=y;
        if(x==0)x=n+1;
        rs[i]=ls[x];
        ls[x]=i;
    }
    dfs(ls[n+1],m);
    printf("%d",f[ls[n+1]][m]);
}

```


---

## 作者：caoyihong (赞：22)

看不懂下面的题解，自己写了一个记忆化。

先将树转换成左儿子右兄弟树。对于每一个 i 节点，定义dp( i , j ) 为 i 的所有兄弟和 i 的所有儿子， 和 i 自己，学 j 门课的最大学分总和。

那么，可以分成两种情况：

1. 不学 i 这门课，全部学兄弟的课程，dp( i , j ) = dp( bro[ i ] , j)

2. 学 i 以及以 i 为先修课的课程， dp( i , j ) = dp( bro[ i ] ,  j - 1 - k ) + dp( son[ i ] , k ) + v[ i ]

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 320;
int f[maxn][maxn] , bro[maxn] , son[maxn], v[maxn];
void add(int fa, int s)
{
    bro[s] = son[fa];
    son[fa] = s;
}

int dp(int i, int j)
{
    if (i == -1) return 0;
    if (j == 0) return 0;
    if (f[i][j] != -1) return f[i][j];
    int m = -1<<30; //最小值 
    
    // 全分兄弟
    m = max( m, dp(bro[i] , j));
    
    for (int k = 0; k <= j-1; k++)
    {
        m = max( m , dp(son[i] , k) + dp(bro[i] , j-1-k) + v[i]);
    }
    f[i][j] = m;
    return m;
}
int main()
{
    memset(son , -1, sizeof(son));
    memset(bro , -1, sizeof(bro));
    memset(f   , -1, sizeof(f  ));
    int n, m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int fa,vx;
        cin>>fa>>vx;
        add(fa,i);
        v[i] = vx;
    }
    cout<<dp(0, m+1);
    return 0;
}
```

---

## 作者：zcysky (赞：21)

不用多叉转二叉的题解

题意很好理解：如果我们要选择一个节点，那么这个节点一直到根节点的路径我们必须选中。然后我们就发现了几个问题：

1.转移方程：设dp[i][j]是在完成第i个结点的决策时，已经取到了第j个物品。

dp[i][j]=max(dp[i][j],dp[v][j-1]+val[v])(v=sons of i)

2.注意到这是一个森林。方法：借鉴网络流的思想，建立超级根节点，并且让他的权值=0，记录下所有单独树的根节点，跟超级根节点相连。同时注意可选择的节点数+1，因为这个超级根节点你是肯定要选中的。

3.注意到这是一棵多叉树。方法：不转化成二叉树，在dfs同时，计算出子节点的权值，然后当做一个单独物品，参与父节点的决策。

4.可能有类似题出现负数，一个点都不选可能更优。方法：最后跟0比较。

贯彻上述思想的简单代码：

```cpp
#include<bits/stdc++.h>
#define N 10010
using namespace std;
struct Edge{
    int u,v,next;
}G[4*N];
int tot=0,head[4*N],dp[301][301],n,m;
int a[N],f[N];
vector<int>g;
int read(){
    int x=0,f=1;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
void addedge(int u,int v){
    G[++tot].u=u;G[tot].v=v;G[tot].next=head[u];head[u]=tot;
    G[++tot].u=v;G[tot].v=u;G[tot].next=head[v];head[v]=tot;
}
void dfs(int u){
    for (register int i=head[u];i;i=G[i].next){
        int v=G[i].v;
        if (v!=f[u]){f[v]=u;
            for (int j=m;j>=0;j--)dp[v][j]=dp[u][j]+a[v];
            dfs(v);
            for (int j=m;j>=0;j--){
            dp[u][j]=max(dp[u][j],dp[v][j-1]);
            //printf("dp[%d][%d]=%d\n",u,j,dp[u][j]);
            } 
        }
    }
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++){
        int f=read(),v=read();
        if(f)addedge(i,f);else g.push_back(i);
        a[i]=v;
    }int s=0;a[s]=0;m++;
    for(int i=0;i<g.size();i++)addedge(s,g[i]);
    dfs(s);
    printf("%d",max(0,dp[0][m-1]+a[0]));
    return 0;
}
```

---

## 作者：zeroy0410 (赞：14)

#### 题目
在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？

#### 思路
各种课程之间的关系显然是树形结构，显然可以用背包求解。

我们用$dp[x][j]$表示在当前子树中选择了j门课所能获得的最大学分，之后每个点就都可以由它的子节点转移了。

```c++
#include<bits/stdc++.h>
#define M 305
using namespace std;
int n,m;
vector<int>G[M];
int A[M],sz[M];
int dp[M][M];
void dfs(int x,int f){
    int k=G[x].size();
    dp[x][1]=A[x];sz[x]=1;
    for(int i=0;i<k;i++){
        int u=G[x][i];
        if(u==f)continue;
        dfs(u,x);
        sz[x]+=sz[u];
        for(int j=min(m+1,sz[x]);j>=2;j--)
            for(int k=1;k<j;k++)
                dp[x][j]=max(dp[x][j],dp[x][k]+dp[u][j-k]);
    }
}
int main(){
    cin>>n>>m;
    for(int i=1,a;i<=n;i++){
        scanf("%d%d",&a,&A[i]);
        G[a].push_back(i);
    }
    dfs(0,-1);
    cout<<dp[0][m+1]<<endl;
    return 0;
}
```

#### **然而,这不是重点**

我们会发现以上的思路的复杂度是$O(n*m^2)$，那我们能不能寻求更优的复杂度呢？

对于一棵子树而言，对于它我们只有两种状态，要么将其选中，同时选它子树中的点，要么直接跳过这一棵子树，所以我们不妨这样定义dp数组：

$dp[x][j]$表示当前节点和它的兄弟节点中选j门课的最小值。

对于每个点，我们要记录子树的大小，和dfs序。

不难发现以下状态转移方程：

$dp[i][j]=max(dp[i+sz[ln[i]]][j],dp[i+1][j-1]+A[ln[i]]);$

即对于当前点而言，直接跳过这棵子树的情况，和搜集它子树内的信息。

因为树上的问题有着天然的顺序，所以，我们按dfs序倒着循环一遍就行了。

```c++
#include<bits/stdc++.h>
#define M 505
using namespace std;
int n,m,dp[M][M],A[M],sz[M];
vector<int>G[M];
int ln[M],tt;
void dfs(int x){
    ln[++tt]=x;sz[x]=1;
    for(int i=0;i<G[x].size();i++){
        int u=G[x][i];
        dfs(u);
        sz[x]+=sz[u];
    }
}
int main(){
    cin>>n>>m;
    for(int i=1,a,b;i<=n;i++)
        scanf("%d%d",&a,&A[i]),G[a].push_back(i);
    dfs(0);
    for(int i=n+1;i>=1;i--)
        for(int j=1;j<=m+1;j++)
            dp[i][j]=max(dp[i+sz[ln[i]]][j],dp[i+1][j-1]+A[ln[i]]);
    cout<<dp[1][m+1]<<endl;
    return 0;
}
```

对先序遍历优化树形背包不是很熟悉的同学可以去看看这个：[网页链接](http://note.youdao.com/noteshare?id=07619acf27a64381650dbb9dc2000f68&sub=4FCC06D686104EA19BFFBF85E614343D)

---

## 作者：天泽龟 (赞：11)

老实说，各个题解都把这题写的太麻烦了。。

由于树形背包=树形DP+背包DP，所以我们只需把树形的板子拎出来，单独分析背包问题即可。

----

1. ### 首先套上树形DP板子：
```cpp
void dfs(int v)
{
	for (int i=fir[v];i;i=e[i].next)
	{
		int u=e[i].u; dfs(u); 
		//~~枚举子状态，选取最值的过程~~
	}
}
```

好多题解都认为这是树形DP入门，个人认为[没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)更可以胜任这个身份，~~NOIP2018的D2T3部分分就是这道题魔改。~~


特殊地，我们可以知道题目给定的是一个森林，你要跑树形DP必须要**建一个虚节点O，连接所有有向树的根**，这步骤是所有题解公认的，也很直观。

2. ### 再考虑背包DP的部分。

**树形DP的通性就是他维护的子结构一定是一个子树**，这样就很好定义转移方程。我们设$f[i][j]$为以i为根的子树，选了j节课且必选自己的最大利益。

那么显然的，初始状态即为$f[i][1]=s[i]$。且对于每一个子树，我们可以利用**泛化物品**的概念去构造一个泛化物品代替一棵子树。

_对于每个子树$u$所控制的泛化物品$A$,给他分配的容量$k$当然指选j节课，造成了收益$w[k]=f[u][k]$，由于我们执行$DFS$之后已经搞出每个子树的信息，所以直接调用即可。_

_很显然，每个子树的泛化物品在$~0 ~to ~(m+1)$中枚举与父亲取极值后不断向上合并，最后可以汇聚成一个以虚节点O为根的总泛化物品。这应该就是DD大佬在背包九讲的本意。_

~~以上内容均为个人理解，不代表背包九讲的作者，若有错误请务必在评论区指出。~~

当然我们解题时不需要这种乱七八糟的概念，我们只用把一个子树与父亲的关系看作一个**分组背包**，对于不同的容量$j$，价值应该是**在子树里选$k$个与非该子树中选$j-k$个的价值**。写作转移方程即为：
$$f[v][j]=max\begin{Bmatrix}f[v_{son}][j]+f[v][j-k]\end{Bmatrix} $$

这样的话，对于每棵子树的组合，可以保证只能至多选一个物品，且每棵子树只搜一次，于是就是裸的分组背包了。
```cpp
void dfs(int v)
{
	for (int i=fir[v];i;i=e[i].next)
	{
		int u=e[i].u; dfs(u); 
		for (int j=m+1;j>=1;j--)  //容量 
			for (int k=0;k<j;k++)  //选这个子树的k节课 
				f[v][j]=max(f[v][j],f[u][k]+f[v][j-k]);
	}
}
```

## 以上，部分内容借鉴于李煜东《算法竞赛》。


---

## 作者：Panthera_AFO (赞：8)

这题是个裸的可行性01依赖背包

然而我翻了翻题解，发现都没说到点上，所以我决定考前发一波福利

这道题实际上就是有依赖性质的机器分配（P2066），因此，依赖背包实质上就是一个**树形分组背包**，他与分组背包唯一的差别在于**他的转移是树上相邻点的转移**

结合代码解释一下为什么叫他分组背包

```
void dfs(int u)
{
//每个点都是一个组，代表以u为根的子树的最优解
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        //每次向与他相连的v转移
        dfs(v);
        for(int j=V+1;j>=1;j--)
        //第二重循环枚举体积（第一重循环实质上就是dfs搜索点u）
            for(int k=0;k<j;k++)
            //第三重循环枚举组内物品
            //我们把上多少v内的课作为物品k
            //第u组第k个物品的体积是k，准确的说，是num[u][k]=k
            //价值就是f[v][k]
                f[u][j]=std::max(f[u][j],f[u][j-k]+f[v][k]);
    }
}
```

再说几点细节
+ Q：为什么我的第二重循环上限是V+1？

+ A：因为我把0点当做了一个必选的点，这样可以直接从0访问到各森林的根


+ Q：楼上题解的压维是什么意思？没看懂...

+ A：因为是分组背包啊，最优解分组背包可以压维，方案数分组背包不能压维，自己试试就明白了，~~我测试了一下午~~，话说如果有人会方案数分组背包的压维，请务必@我一下

想想还是放一下AC代码吧

[~~顺便宣传一波我的博客~~](https://blog.csdn.net/qq_40828060/article/details/83064425#P2409_Y_300)
```
#include<iostream>
#include<cstdio>
#include<cstring>
int const maxn=324,maxm=324;
struct E
{
    int to,next;
    E(int to=0,int next=0):
        to(to),next(next){}
}e[maxn];
int head[maxn],cnt;
inline void add(int u,int v)
{
    e[++cnt]=(E){v,head[u]};
    head[u]=cnt;
}
int n,V;
int f[maxn][maxm];
void dfs(int u)
{
    for(int i=head[u];i;i=e[i].next)
    //每一组
    {
        int v=e[i].to;
        dfs(v);
        for(int j=V+1;j>=1;j--)
        //当前总体积:V+1!!!
            for(int k=0;k<j;k++)
            //组内物品
                f[u][j]=std::max(f[u][j],f[u][j-k]+f[v][k]);
    }
}
int main()
{
    scanf("%d%d",&n,&V);
    memset(f,0xcf,sizeof(f));
    for(int i=1;i<=V+1;i++)
        f[0][i]=0;
    //这题似乎没有用，但毕竟是个可行性背包问题，加上吧 
    for(int u,i=1;i<=n;i++)
        scanf("%d%d",&u,&f[i][1]),add(u,i);
    dfs(0);
    printf("%d",f[0][V+1]);
    return 0;
}
```

---

## 作者：GoldenPotato137 (赞：7)

蒟蒻博客传送门：[QAQ](https://www.cnblogs.com/GoldenPotato/p/9440154.html)


------------


### Solution

这是一道十分经典的树形DP题，这种类型的树形DP有一种很普遍的解法。

.


 

首先，观察题目，我们把这道题转换一下：**给定一颗树，选出包含1号节点（根)的一颗子树，使得点权和最大**。

.

我们可以这样子定义状态：

设**f[i][j] 表示以i为根节点的子树，选出j个节点，所能达到的最大点权值。**

.

对于二叉树来说，转移很显然，就是枚举左子树分配多少个节点，就可以对应的得出右子树能分配到多少个节点，对所有情况取最大值就好。

对于多叉树来说，问题就没有那么简单了，这里，我们有两个方案可以解决这个问题：

1. **多叉树转二叉树**，

2. **树上背包**。

 

~~因为我不会多叉树转二叉树~~，所以在这里我主要讲一讲第二种方法。

.


我们在树上做背包**本质上一般是多重背包问题**。

我以本题为例子，讲一下树上如何做多重背包。

首先，我们肯定要**一层循环枚举子树(可以类似为背包问题中枚举第几件物品)。**

**第二层循环我们得枚举当前以节点的子树能分配的节点数（可以类似为背包问题中枚举背包容量）**

 **这一层循环一定要从后往前枚举，类似与背包压在一维做的做法** 

**第三层循环我们就可以枚举当前子树分配多少个节点了（可以类似多重背包中枚举第i件物品要几件）**

下面是这种枚举在这道题应用的代码：
```cpp

     for(int i=0;i<int(e[x].size());i++)//枚举子树
     {
         int temp=dfs(e[x][i]);//先把子树的f递归下去算出来
         tot+=temp;//tot记录到当前子树为止总节点数
         for(int j=tot;j>=1;j--)//枚举自己这颗树的总分配数
            for(int k=0;k<=temp;k++)//枚举子树分配多少个节点
                if(j-k>=1)
                     f[x][j]=max(f[x][j],f[x][j-k]+f[e[x][i]][k]);
     }

```

 .

树上背包一般看上去是三重循环，非常恐怖。

但事实上，根据一堆证明~~（不会证）~~，其复杂度为两重循环。

~~所以复杂度应该是O（能过）~~

**复杂度是O(N^2xM)**



------------

### Code
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
long long read()
{
    long long x=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=300+10;
vector <int> e[N];
long long n,m,f[N][N],v[N];
int dfs(int x)
{
    int tot=1;
    f[x][1]=v[x];
    for(int i=0;i<int(e[x].size());i++)
    {
        int temp=dfs(e[x][i]);
        tot+=temp;
        for(int j=tot;j>=1;j--)
            for(int k=0;k<=temp;k++)
                if(j-k>=1)
                    f[x][j]=max(f[x][j],f[x][j-k]+f[e[x][i]][k]);
    }
    return tot;
}
int main()
{
    n=read(),m=read();
    for(int i=0;i<=n;i++)
        e[i].reserve(4);
    for(int i=1;i<=n;i++)
    {
        e[read()].push_back(i);
        v[i]=read();
    }
    
    dfs(0);
    
    printf("%lld",f[0][m+1]);
    return 0;
}

```


---

## 作者：囧人232 (赞：7)

这道题是一个非常明显的树形dp，建议和加分二叉树，有线电视网一起写一下；

这道题有一个细节需要注意一下，我是设一个虚根0，所有的主课（父亲节点是虚根的节点）都与虚根相连，使m+1；

大概思路是建树（dfs）的时候处理好f[i][j]数组（选i和其儿子共j节）

最后求出f【0】【m】；

状态转移方程如下

 for(int j=m;j>=1;j--)

  for(int k=0;k<j;k++)

  f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]);//f【u】【j】为它儿子v选k节再加上u的其他儿子选j-k节的最大值

附上代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=300+10;
int f[maxn][maxn],s[maxn]={0};//s数组存的是选某节课可以给的值；
int n,m;
vector<int>g[maxn];//存树用的g数组
void dfs(int u){
    int x=g[u].size();
    f[u][0]=0;//什么课都不选即为0
    for(int i=0;i<x;i++)
    {
        int v=g[u][i];
        dfs(v);
        for(int j=m;j>=1;j--)
        for(int k=0;k<j;k++)
        f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]);//状态转移方程
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
    f[i][j]=-10086;//初始化
    }
    for(int i=1;i<=n;i++)
    {
        int a;
        scanf("%d%d",&a,&s[i]);
        g[a].push_back(i); //存图
        f[i][1]=s[i]; //F[I][1]即为只选i不选其子节点，等于S[I]；
    }
    //f[0][1]=0;
    m++;//虚根操作=v=，好像很高大上，其实就一句话
    dfs(0);//dfs的同时处理好f数组
    printf("%d",f[0][m]);
}
//蒟蒻写的题解，希望对你们有帮助
```

---

## 作者：flrs (赞：6)

## 背景

在浏览题解的时候看到这么一句话:“好多人这题用多叉转二叉啊，就我用树形DP强行么。。。” （黑人问号？？） 我怎么没看出有人用了多叉转二叉（还有听说那个人本质上其实用的也是左儿子右兄弟表示法）？ 然后老师给的题我又做不出来，就只能为了耗时间来发题解了 qwq （捂脸哭）。

# 正文：

## 分析：
同样，这道题目给出的数据是以树形结构连接的。

这题比[苹果树](https://www.luogu.org/problemnew/show/P2015)（题目传送门）多了一个步骤就是**把一棵多叉树转化为二叉树**。

读入数据时把二叉树建好：把一门课的先修课作为它的父亲。**一个结点的第一个孩子作为自己的左子树，其它孩子作为第一个孩子的最右树枝链，即分别做第一个孩子的右儿子、右儿子的右儿子……（左儿子右兄弟表示法）。** 如下图（图源：∞∑的CSDN博客）：
![1](https://i.loli.net/2019/07/24/5d3855359740521231.png)

# **-->**
![2](https://i.loli.net/2019/07/24/5d38556b5165196910.png)

# **-->**
![3](https://i.loli.net/2019/07/24/5d38558e4080912136.png)

# **-->**
![4](https://i.loli.net/2019/07/24/5d385612be86b73758.png)

因为这道题还有可能出现森林，所以需要设一个虚根0然后用m+1来dp

正好这道题输入有0，可以将题就题。

# **-->**
![5](https://i.loli.net/2019/07/24/5d3856da7d77342715.png)

（吐槽一下，实际操作的时候还要把第一个图中图中第一个根节点连到虚根0作为其左儿子）
## 状态的确定：
dp[x][y]：表示节点x取y门课得最高学分，则

dp[x][y]=max{dp[x.r][y], dp[x.l][k-1]+x.v+dp[x.r,y-k]|k=1,2,..y}

dp[x.r][y]：表示不选课程x，右孩子选k门课。

dp[x.l][k-1]+x.v(课程x的学分) ：表示选了课程x,左孩子选k-1门课,共k门课。

dp[x.r,y-k]表示右孩子只能选y-k门课。

标程中节点-1表示空节点，0是根节点，1-n是n门可选课程的节点。

## 代码
这些都干完了当然是要写代码啊 ~~（兴奋）~~ ！！！

新人OIer怯怯地放上了自己的代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
struct node{
	int lson,rson;
}a[305];
bool gotson[305];
int dp[305][305],s[305];
void DP(int rc,int rm)
{//if一定要打，要不然会回到虚根导致dp错误
	if(dp[rc][rm]) return;
	if(a[rc].rson)
	DP(a[rc].rson,rm);
	dp[rc][rm]=dp[a[rc].rson][rm];
	for(int k=1;k<=rm;k++){
		if(a[rc].lson)
		DP(a[rc].lson,k-1);
		if(a[rc].rson)
		DP(a[rc].rson,rm-k);
		dp[rc][rm]=max(dp[rc][rm],dp[a[rc].lson][k-1]+dp[a[rc].rson][rm-k]+s[rc]);
	}
	
}
int main(void)
{
	scanf("%d%d",&n,&m);
	for(int i=1,k;i<=n;++i)
	{
		scanf("%d%d",&k,s+i);
		if(gotson[k])
		{
			k=a[k].lson;
			while(a[k].rson) k=a[k].rson;//找最深的右儿子
			a[k].rson=i;
		}
		else {
			gotson[k]=1;a[k].lson=i;
		}//多叉转二叉树
	}
	DP(0,m+1);
	printf("%d",dp[0][m+1]);
}
```
~~看来蒟蒻无论如何也不能逃避老师的题目了 qwq~~

全文终。

---

## 作者：Macesuted (赞：6)

[题面](https://www.luogu.com.cn/problem/P2014)

对于这道题，我们考虑在树形dp上套背包。我们会非常自然的采用dfs扫描整棵树，然后对树上的每个节点都进行一次背包。

计$dp[i][j]$为在以第$i$号节点为根结点的子树中，用题目中选法选取$j$项的最大值。

我们在dfs的过程中，采用递归的方式，在子节点都处理完之后，便考虑将所有子节点的答案综合，得到当前节点的答案。

很显然，就是在容量为$j$的01背包中放下$i$节点的所有子节点背包中的答案，我们很容易想到下面的DP方程
$$f[x][j]=max(f[to][k]+f[x][j-k])$$
$x$为当前节点，$to$为它的某个孩子节点，$j$和$k$是枚举的两个变量。

就得到了
```cpp
for(int i=0;j<G[x].size();i++){
	int to=G[x][i];
    dfs(to,x);
    for(int j=m+1;j>=1;j--){
    	for(int k=m;k>=0;k--){
        	if(j-k<1) continue;
            f[x][j]=max(f[x][j],f[to][k]+f[x][j-k]);
		}
	}
}
```
最终的答案就是$f[0][m+1]$了，因为所有没有前提条件的课程都可以指向$0$，即让第$0$号课程成为他们的先决条件，因为$0$号课程自身也算一个课程，所以第二项就是$m+1$了

## 优化

显然，上述算法时间复杂度为$O(N*M^2)$,~~虽然在本题已经可以通过~~，但是如果数据量增加到$n<=2000$时，应该如何应对

由于对于每一个节点上的背包，我们每一次都枚举到了$m+1$，但是大部分情况下实际背包一般不会那么大，所以在时间上会产生很大的开销。

考虑下面的这份代码
```cpp
int dfs(int node)
{
	int sum=0;
	f[node][1]=cost[node];
	for(int i=0;j<G[x].size();i++){
		int to=G[node][i];
        int cnt=dfs(to);
		sum+=cnt;
		for(int j=m+1;j>=1;j--)
			for(int k=min(cnt,j);k>=0;k--){
				if(j<k+1) continue;
				f[node][j]=max(f[node][j],f[to][k]+f[node][j-k]);
			}
	}
	sum++;
	return sum;
}
```
用$sum$存放当前节点为根的子树的大小，同时dfs值为子树大小直接进行传值。

显然背包的第二重循环是可以像这样优化的，毕竟子节点产生的序列大小也才那么点，这样的话整个子树上的所有情况都只会在这个节点上体现一次（显然之前的方法大量冗余的计算会使得它制造的无用情况会大大多于现在），所以整棵树一共是$n$个节点，对于每个节点它的孩子的若干个$m$情况只会经过一次，并且在$O(1)$时间内直接取出每组情况最优值，所以对于每个点的复杂度是$O(m)$的，所以总的算法时间复杂度就为$O(N*M)$了，就可以对付增强后的数据了。

[完整代码](https://www.luogu.com.cn/blog/Kysic-Studio/code-P2014)

---

## 作者：D愚者 (赞：5)

- 前言

	这题是一道背包类树形DP

	
------------

 - 思路
	

    依题意：
    
    每门课的先修课最多只有一门。但有可能有多门课有相同的一门先修课。所以我们需建一个“伪节点”——0节点作为根节点，连接没有先修课的课程，作为它们的先修课。
    
    状态转移方程：
    
    设f[i][j] 为以i为根节点的子树中选j门课能获得的最多学分。
    

- Code：
------------
```cpp#include<cstdio>
    #include<iostream>
    #include<cstring>
    #include<vector>
    using namespace std;
    int n,m,x,s[350];
    int f[350][350];
    int son[350][350],cnt[350];
    void DP(int x){
        f[x][0]=0;
        int p=cnt[x];
        for(int i=0;i<p;i++){//先算出不加上第x门课的学分
            int k=son[x][i];
            DP(k);
            for(int t=m;t>=0;t--)//背包倒序循环
                for(int l=t;l>=0;l--)
                    f[x][t]=max(f[x][t],f[x][t-l]+f[k][l]);
        }
        if(x!=0)//如果不为0节点，也就是虚拟根节点时
            for(int i=m;i>0;i--)//还要加上这门课的学分
                f[x][i]=f[x][i-1]+s[x];
    }
    int main(){
        memset(f,0xcf,sizeof(f));//把f数组初始成一个很小的数
        scanf("%d %d",&n,&m);
        for(int i=1;i<=n;i++){
            scanf("%d %d",&x,&s[i]);
            son[x][cnt[x]++]=i;//存x的儿子节点
        }
        DP(0);
        printf("%d ",f[0][m]);
        return 0;
    }
```

    
------------
- 后记

	本文部分摘自蓝书，且本人思路自蓝书。
    
   [无耻地安利blog](https://www.luogu.org/blog/2713840045cheng/)
  	

---

## 作者：huihao (赞：5)

看了楼下大神的题解感觉会了好多，也来发一个。

我们知道做树型动规时，二叉树要比多叉树要好写方程，所以我就用二叉树做了。

转换成二叉树后，思路其实和二叉苹果树就有点类似了。分三种情况

1.只有儿子选2.只有兄弟选3.既有儿子选也有兄弟选

对于第三种情况直接枚举选多少就行了。

还有，由于本题的图形是一个森林（好多树的集合），我们可以构造一个虚拟的根节点，把它转化为一棵树就OK了。f[i][j]表示以i为根的子树选j个的最优值。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cctype>
using namespace std;
inline void read(int &x){
    int f=1; x=0; char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    x= f<0? ~x+1:x;
}
int n,m;
int w[305],b[305],c[305],f[305][305];
void dfs(int x,int v){
    if(f[x][v]>=0) return;//记忆化搜索
    if(x==0||v==0) {f[x][v]=0; return;}
    dfs(b[x],v); f[x][v]=max(f[x][v],f[b[x]][v]);//只有兄弟选的情况
    for(int i=0;i<v;++i){//当i==0时是只有儿子选的情况
        dfs(c[x],v-i-1);//既有兄弟又有儿子选
        dfs(b[x],i);
        f[x][v]=max(f[x][v],f[b[x]][i]+f[c[x]][v-i-1]+w[x]);
    }
}        
int main(){
    read(n);read(m);
    int fa;
    for(int i=1;i<=n;++i){
        read(fa); read(w[i]);
        if(fa==0) fa=n+1;
        b[i]=c[fa];//用类似储存链式前向星的方法
        c[fa]=i;//将多叉树转换为二叉树
    }
    memset(f,-1,sizeof(f));
    dfs(c[n+1],m);
    printf("%d\n",f[c[n+1]][m]);
    return 0;
}
```

---

## 作者：xcyy (赞：5)

这题其实完全没有提高+/省选-的难度，但对于我这种dp蒟蒻来说还是需要思考一段时间的，说正事，分析题目。

首先我们发现数据范围很小只有300，哪怕是爆搜可能也会有大佬能过，但我这里没有这样写，这题思路比较容易想到，一共有n个课程，但同样有n条边，这时候我们设0节点为根节点，就有n+1个点，n条边,刚好构成树形结构，然后这道题是求最多m个课程所能获得的最大学分，很显然是一道dp题，而且是背包。

我们设f[x][t]为以x为根的子树中选t门课所能得到的最高学分，设x的子节点集合为son(x)，我们可以建一个vector数组保存，子节点个数就为son[x].size(),然后我们循环子节点，再倒序循环当前选课门数，继续循环更深子树上的选课门数就可以了。
直接上代码，35行简洁明了。

```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<cstdio>
using namespace std;
#define N 305
int f[N][N],s[N],n,m;
vector<int>son[N];
inline void dp(int x)
{
	f[x][0]=0;
	for(int i=0;i<son[x].size();i++)
	{
		int y=son[x][i];dp(y);for(int t=m;t>=0;t--)for(int j=t;j>=0;j--)
		if(t-j>=0)f[x][t]=max(f[x][t],f[x][t-j]+f[y][j]);
	}
	if(x!=0)
	for(int t=m;t>=0;t--)f[x][t]=f[x][t-1]+s[x];
} 
 int main()
 {
 	scanf("%d%d",&n,&m);
 	for(int i=1;i<=n;i++)
 	{
 		int x;
 		scanf("%d%d",&x,&s[i]);
 		son[x].push_back(i);
	 }
	 memset(f,-1*0x3f,sizeof(f));
	 dp(0);
	 printf("%d",f[0][m]);
	 return 0;
 }
```


---

## 作者：qwerta (赞：5)

为什么都用dfs 拓扑序多好用2333

```cpp
首先我们把k==0的课程 的先修课 当作课程0

然后对每个点往它的先修课连一条边 会形成一棵以0为根的树形结构

对每个点记录它连出边的终点编号（to[x]）和它的入度(rd[x])
```
```
然后就可以按拓扑序dp了

记f[i][j]为 在i号点 选了i的子树上（一定包括i 共j个点 最多能拿到的学分

每次用当前节点更新它的父亲节点 跑01背包

转移方程：f[to[x]][i]=max(f[to[x]][i],f[to[x]][i-j]+f[x][j]);

最后结果在f[0][m+1]上
```
```cpp
 1 #include<iostream>
 2 #include<cstdio>
 3 #include<queue>
 4 #include<cmath>
 5 using namespace std;
 6 #define R register
 7 int f[307][307];
 8 int to[307];
 9 int rd[307];
10 queue<int>q;
11 int main()
12 {
13     int n,m;
14     scanf("%d%d",&n,&m);
15     for(R int i=1;i<=n;++i)
16     {
17         scanf("%d%d",&to[i],&f[i][1]);
18         rd[to[i]]++;//终点入度++
19     }
20     for(R int i=1;i<=n;++i)
21     if(!rd[i])q.push(i);
22     while(!q.empty())
23     {
24         int x=q.front();q.pop();
25         for(R int i=m+1;i>=1;--i)
26         for(R int j=i-1;j>=1;--j)
27         f[to[x]][i]=max(f[to[x]][i],f[to[x]][i-j]+f[x][j]);//01背包
28         //
29         rd[to[x]]--;
30         if(!rd[to[x]])q.push(to[x]);
31     }
32     cout<<f[0][m+1];
33     return 0;
34 }
```
[~~夹带私货安利博客~~](https://www.cnblogs.com/qwerta/p/9389955.html)

---

## 作者：Thinking (赞：4)

每一门课都只有一个先修课，所以这其实是一个无向无环图（也就是森林啦）；所以，整个问题就变成了：已知一个森林，每个节点都有一个权，选择一个节点必须选择它的根节点，求选择m个节点的最优解。

树状DP？是的！那么，唯一的问题就是如何把一个森林转化成一个二叉树。

首先，增加一个总根（0节点），然后对于每个节点，记录两个指针，son和brother（当然也可以用left和right）；它的最左儿子和右兄弟。然后做树状DP即可。但是要注意一个特殊情况：因为brother是它的兄弟，所以可以不选它本身，只选brother。

接下来就很简单啦~~~

pascal代码如下：

```pascal
type
  node=record
    s,b,x:integer
  end;
var
  tree:array[0..300] of node;  //记录整棵树
  f:array[0..300,0..301] of integer;  //记录结果
  n,m,i,a,b:integer;
function max(a,b:integer):integer;
  begin
    if a>b then exit(a)
    else exit(b)
  end;
function dp(root,q:integer):integer;  //root是当前节点，q是选的节点数
  var
    i,s:integer;
  begin
    if f[root,q]>0 then exit(f[root,q]);
    if q=0 then exit(0);
    if tree[root].s=0 then if tree[root].b=0 then f[root,q]:=tree[root].x
    else f[root,q]:=max(dp(tree[root].b,q-1)+tree[root].x,dp(tree[root].b,q))
    else if tree[root].b=0 then f[root,q]:=dp(tree[root].s,q-1)+tree[root].x  //特判
    else begin
      s:=0;
      for i:=0 to q-1 do s:=max(s,dp(tree[root].s,i)+dp(tree[root].b,q-i-1));
      inc(s,tree[root].x);
      s:=max(s,dp(tree[root].b,q));  //特殊情况
      f[root,q]:=s
    end;
    exit(f[root,q])
  end;
//树状DP（其实是记忆化搜索实现）
begin
  readln(n,m);
  fillchar(tree,sizeof(tree),0);
  for i:=1 to n do begin
    readln(a,b);
    if tree[a].s=0 then tree[a].s:=i
    else begin
      tree[i].b:=tree[a].s;
      tree[a].s:=i
    end;  //这里并没有记录最左儿子，不过节约了效率，而且树的形态无关紧要
    tree[i].x:=b
  end;  //初始化
  fillchar(f,sizeof(f),0);
  write(dp(0,m+1))
end.
```

---

## 作者：BrandonSoong (赞：4)

# 一个17ms的优化版本
#### 首言
对《竞赛一本通》的做法进行了小小优化，希望同时也可以帮助没有看懂的同学更清晰地理解树形背包的本质
***
#### 这道题是模板的树形背包：

```cpp
给定n个物体
有一些物体需要事先购买其他物体才能购买
问购买m个物体所可以获得的最大价值
```
***

#### 这种“依赖关系”我们可以转化成“树”里面的“父子关系”
```cpp
用一条边把有要求的物体连接上它所需要事先购买的物体

这样子我们就得到一棵树！（没有要求的节点连接0）

现在我们的问题就转成了在一颗树子上面寻找以0节点为根节点，size为m+1（0号节点不算大小，所以+1）的所有子树中total_value最大的那一棵的value。

所以我们可以考虑通过一种DP的思想来实现这个目的，也就是通过某种方式通过一个节点的子节点来更新这个节点的max_value。
```

***
#### 状态
```cpp
我们用f[u][i]表示以u为根节点的子树中选择i个物体所可以获得的最大价值

对于f[u][i]来说，我们考虑它的最大DP所需要的体积，是min(m,leaf[u].size)【这是一个优化】。

而物体可以从每个儿子中选择一个（或者不选），比如y是u的一个儿子节点，那么f[y][j]可以表示一个体积为j，价值为f[y][j]的物品。

但是每个儿子里面只能最多选择一个，所以对于每个儿子都要遍历一遍它的所有的f[y][j]。

由于只有当j<=min(m,leaf[y].size)的时候才有意义，所以j只需要从min(m,leaf[y].size)遍历到1就行了【这是另一个优化】。
```
***
#### 整体布局
```cpp
那么这道题就转化成为了一道分组背包问题，对于每个节点来说，有多少个儿子就有多少组物品可以选择，对于每种物品我们可以选择其中的一个。
所以在每个dfs中我们有三重循环：
第一重循环儿子（组别）。
第二重循环体积（min(m,leaf[u].size)）。
第三重循环每个儿子的可选物品（min(m,leaf[y].size)）。
至于每个节点的size需要事先跑一遍dfs处理出来。
这样子做的复杂度很迷，但是远远小于《竞赛一本通》上面的复杂度，因为去除了许多没有意义的状态（当m>leaf[u].size的时候，大于的那一部分），跑出来的时间是书上的程序的时间的1/4.（17ms）
```
***
#### 代码
```cpp
#include<bits/stdc++.h>
#define maxn 800
using namespace std;
int n,m,cal;
struct lines{
	int nex,to;
}line[maxn];
struct leaves{
	int head,size,value,f[maxn];
}leaf[maxn];
inline int qr()
{
	int sum=0;
	char j=0;
	bool flag=0;
	while(!isdigit(j))
	{
		flag|=j=='-';
		j=getchar();
	} 
	while(isdigit(j))
	{
		sum=(sum<<1)+(sum<<3)+(j^48);
		j=getchar();
	}
	return flag? -sum:sum; 
}
inline void add(int u,int v)
{
	line[++cal].nex=leaf[u].head;
	line[cal].to=v;
	leaf[u].head=cal;
	line[++cal].nex=leaf[v].head;
	line[cal].to=u;
	leaf[v].head=cal;
	return;
}
inline void readin()
{
	n=qr();
	m=qr();
	int a,b;
	for(int i=1;i<=n;i++)
	{
		a=qr();
		b=qr();
		add(i,a);
		leaf[i].value=b;
	}
	return;
} 
void dfs1(int u,int fa)
{
	leaf[u].size=1;
	for(int i=leaf[u].head;i;i=line[i].nex)
	{
		int y=line[i].to;
		if(y!=fa)
		{
			dfs1(y,u);
			leaf[u].size+=leaf[y].size;
		}
	}
	return;
}
void dfs2(int u,int fa)
{
	for(int i=leaf[u].head;i;i=line[i].nex)
	{
		int y=line[i].to;
		if(y!=fa)
		{
			dfs2(y,u);
			for(int v=min(leaf[u].size,m);v;v--)
			for(int vo=min(v,leaf[y].size);vo;vo--)
			leaf[u].f[v]=max(leaf[u].f[v],leaf[u].f[v-vo]+leaf[y].f[vo]);
		}
	}
	if(u)
	for(int v=min(leaf[u].size,m);v;v--)
	leaf[u].f[v]=leaf[u].f[v-1]+leaf[u].value;
	return;
}
inline void Solve()
{
	dfs1(0,-1);
	dfs2(0,-1);
	return;
}
inline void print()
{
	printf("%d",leaf[0].f[m]);
	return;
}
int main()
{
	readin();
	Solve();
	print();
	return 0;
}
```


---

## 作者：龙神哈迪斯 (赞：3)

/\*我是利用树形dp来做的这道题，猛然发现这比那个二叉树苹果更加容易，再外加一下链式前向星来优化了一下算法（没有使用指针），void add其实就是构树的过程，u代表起点，v代表终点，w代表连接起点与终点之间边的权值（此题为学分），然后在用dp来做，这是这个题目构造树的思想，顺便提一下，这个链式前向星是我认为很好的方法来构造树，据说以后图也会用到\*/

/\*这里是讲解状态转移方程的版块，f[u][j]表示此时走到树的第u个点在保存j门课下的最大学分，其一定等于f[v][k]（它的子节点在k门课下的最大学分）+f[u][j-k-1]（它本身除去这一个子节点外能够上的课的门树，不要忘记在j-k后还有-1，因为子节点和父节点之间也有一条边！)+a[i].w（是存v与u之间边的权值（学分）），取个max就可以了，其实主要是第一层循环很难想到，就是你走的这个点，你要去搜索到它的所有子节点所有情况，你才能保证当前这点取得是最大学分）\*/

/\*论一下优化，有些同学可能还会做特判来排除那些没有选修课的直修课，但其实不必要，我可以自己添加一个（0,0）的结点来作为这些直修课的父节点，这样并不违背题意，还能大大减少我们对于特判的思考，只不过这个父节点没有学分罢了。话不多说，代码里有注释\*/

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
struct bian
{
    int to;
    int next;
    int w;
}a[601];
int head[301];
int F[301][301];
int cnt,n,m,x,y;
void Add(int u,int v,int w)
{
    cnt++;
    a[cnt].to=v;
    a[cnt].next=head[u];
    a[cnt].w=w;
    head[u]=cnt;
}
int dfs(int u,int fa)
{
    int num=0;
    for (int i=head[u];i!=-1;i=a[i].next)
    {
        int v=a[i].to;
        if (v==fa) continue;
        num+=dfs(v,u)+1;
        for (int j=min(num,m);j>=1;j--)
          for (int k=j-1;k>=0;k--)
            F[u][j]=max(F[u][j],F[u][j-k-1]+F[v][k]+a[i].w);
    }
    return num;
}
int main()
{
    cin>>n>>m;
    memset(head,-1,sizeof(head));
    for (int i=1;i<=n;i++)
    {
        cin>>x>>y;
        Add(x,i,y);
    }
    dfs(0,0);//要从0开始计算更方便，因为0,0表示没课学分是0，而且对于那些直修课来说他们的父节点就是0，只不过没学分罢了 
    printf("%d",F[0][m]);//所以学分也存到了那个我添加的父节点上了 
    return 0;
}
//推荐同学们可以去做下二叉树苹果，跟这个题目类似，要学会举一反三
```

---

## 作者：wwq123 (赞：2)

1.看了楼下许多篇题解，大同小异，但令我不解的是，许多篇题解都用了很多冗余的变量，这很令我不解，方法固定的话，代码就应该写得简洁，况且他们变量名的意义也没有清晰地标注，所以我写了这篇题解

2.add函数中head[u]指的是最后一个与节点u连接的节点，pre[i]则是将上一个与u连接的节点转移过去，不理解的可以将样例画出，再模拟下

3.f[i][j]用来存储第i个节点选j节课的最大价值，动态转移方程的意义可以详细参考下面的题解，这里不多赘述

4.原本的图是森林，为了转化，我们设立一个0节点，这样就成一棵树了，相应的，m也应该+1，因为从0开始算，相当于多选一节没有任何价值的课

5.下面是代码

```cpp
#include<iostream>
using namespace std;
const int MAXN=300+2;
int f[MAXN][MAXN],head[MAXN],pre[MAXN];
int n,m;
void add(int u,int i){
    pre[i]=head[u];
    head[u]=i;
}
void dp(int x){
    for(int i=head[x];i;i=pre[i]){
        dp(i);
        for(int j=m+1;j>1;j--)
            for(int k=j-1;k>=1;k--)
                f[x][j]=max(f[x][j],f[x][j-k]+f[i][k]);
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int fa,v;
        cin>>fa>>v;
        f[i][1]=v;
        add(fa,i);
    }
    dp(0);
    cout<<f[0][m+1]<<endl;
    return 0;
}
```

---

## 作者：fighter_OI (赞：2)

乍一看就是树结构。啥？指针？还是用模拟指针吧（神犇请无视本文）……树结构嘛，组织自然费力我说了多少遍这是坑 ，啥？你说这是森林？老办法，还得变二叉树。

森林嘛，自然是这么组织的：一个节点的父辈代表它的先修课，因为一门课只有一个先修课，正好符合树的要求（否则还是有向图……）。

变二叉树，还是孩子-兄弟表示法：一个节点的左孩子代表它的第一个孩子（或称大孩子），右孩子代表它的第一个兄弟，右孩子的右孩子，右孩子的右孩子的右孩子……组成它的所有兄弟们。啥？你说它的其他孩子？不就是它左孩子的兄弟（右孩子）们嘛！

现在要说模拟指针了。这个好理解，a[i]代表第i课的学分，l[i]代表i的左孩子，r[i]代表i的右孩子。

言归正传，回到难点上来（刚刚都是浮云……）动规题的核心：动规方程。

假设在以i为根节点的子树上选j个节点的最大价值为f[i,j],那么考虑两种情况：Ⅰ如果选根节点，那就左右子树中的节点都可以选,即f[i,j]=max(f[l[i],k]+f[r[i],j-1-k]+a[i]|0<=k<=j；Ⅱ如果不选根节点，那么只能选右子树上的节点（为什么？根节点是左孩子的先修课啊！）即f[i,j]=f[r[i],j]。总而言之，动规方程为：

f[i,j]=max(max(f[l[i],k]+f[r[i],j-1-k]+a[i]|0<=k<=j，f[r[i],j])

至此，即有两种解法。

①树状动规

方程已出，多说无益然而我就喜欢废话，但这里的重点是动规的次序。

不难看出，要从叶节点向上动规，所以就得以该节点为根的子树的节点个数为标准排序，但万万不可直接调a数组，否则树就倒了……所以要再用一个数组作为指针（当然是模拟指针），存储排序结果。标程略。


②记忆化搜索

跟动规一比，毫无技术含量可言……递归+存储，OK。标称附上：

```cpp
const maxn=500;
type arr1=array[1..maxn] of longint;
     arr2=array[-1..maxn,0..maxn] of longint;
var a,l,r:arr1;
    f:arr2;
    n,m,i,j,k,root:longint;
function max(x,y:longint):longint;
begin
   if x>y then exit(x);
   exit(y);
end;
function work(i,j:longint):longint;
var tmp,k:longint;
begin
  if (i=-1)or(j=0) then f[i,j]:=0;
  if f[i,j]>=0 then exit(f[i,j]);
  tmp:=work(r[i],j);
  for k:=0 to j-1 do
    tmp:=max(tmp,work(l[i],k)+work(r[i],j-1-k)+a[i]);
  f[i,j]:=tmp; 
  exit(f[i,j]);
end;
begin
  readln(n,m);
  for i:=1 to n do begin l[i]:=-1; r[i]:=-1;end;
  root:=-1;
  for i:=1 to n do 
    begin
      readln(j,a[i]);
      if j=0 then begin
                    if root=-1 then root:=i
                               else begin
                                      k:=root;
                                      while r[k]<>-1 do k:=r[k];
                                      r[k]:=i;
                                    end
                  end
             else if l[j]=-1 then l[j]:=i
                             else begin
                                    k:=l[j];
                                    while r[k]<>-1 do k:=r[k];
                                    r[k]:=i;
                                  end; 
    end;
  fillchar(f,sizeof(f),255);
  f[root,m]:=work(root,m);
  writeln(f[root,m]);
end.

```

---

## 作者：切格瓦·星 (赞：1)

大佬们都用的树形DP写的.....

## ~~那就让我来介绍一下玄学的DFS序写法吧~~

(极易发现这种写法的时间复杂度为O(NM),而dalao们的树形DP写法一般是N三方的.....

具体思路就是：先按照课与课之间的关系建一棵树，如果没有先行课就连在虚拟节点上(保证建出的是一棵树)，之后求出这棵树的DFS序，DP在DFS序上操作，DP部分的具体注释在代码里

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,DFS[100000],len,size[100000],ans,dp[1000][1000];
struct leason{
	int k,s;
}l[100000];
struct edge{
	int v,next;
}e[100000];
int cnt,head[10000];
void add(int u,int v){
	e[++cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
void dfs(int u,int fa){
	size[u]=1;
	DFS[++len]=u;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,u);
		size[u]+=size[v];
	}
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d %d",&l[i].k,&l[i].s);
		add(i,l[i].k);
		add(l[i].k,i);
	}
	dfs(0,-1);
	dp[n+1+1][0]=0;
	for(int i=len;i>=1;i--)
		for(int j=1;j<=m+1;j++)
			dp[i][j]=max(dp[i+size[DFS[i]]][j],dp[i+1][j-1]+l[DFS[i]].s);
	//这里分两种情况:若i不选,则i的子树都不能选,于是跳过i及i的子树
	//若i要选,则进入i的子树中接着选; 
	cout<<dp[1][m+1]<<endl;
	return 0;
}

```



---

## 作者：娃哈哈 (赞：1)

一道显然的树形dp。

但是比起二叉苹果树，本题多了一个操作在于多叉树转二叉树：左儿子右兄弟树。

具体实现也比较容易：开一个r[a ]数组，纪录a节点的右儿子的右儿子、、、（知道最下边没有右儿子的节点），然后把a节点的兄弟节点接到r【a】的右儿子上即可。

二叉树建好后，dp方程类似于二叉苹果树（个人认为如果没做过二叉苹果树，先去做那题比较好）。

下面是AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int son[305],bro[305],n,m,v[305],r[305],f[305][305],bj[305][305];
int dp(int x,int y)
{
    int k;
    if(bj[x][y]!=0)return f[x][y];
    if(x==0||x==-1||y==0)return 0;
    int s=0;
    s=max(dp(bro[x],y),s);
    for(k=0;k<y;k++){
        //if(son[x]==-1&&bro[x]==0&&y>1)return 0;
        s=max(dp(son[x],k)+dp(bro[x],y-1-k)+v[x],s);
    }
    bj[x][y]=1;
    return f[x][y]=s;
}
int main()
{
    cin>>n>>m;
    int i,j,k,x,w;
    memset(son,-1,sizeof(son));
    for(i=1;i<=n;i++)
    {
        cin>>x>>w;
        v[i]=w;
```
/\*7  4
2  2
0  1
0  4
2  1
7  1
7  6
2  2\*/
```cpp
        if(son[x]==-1){
            r[x]=son[x]=i;
        }
        else {
            bro[r[x]]=i;
            r[x]=i;
        }
    }
        cout<<dp(son[0],m);
}
```

---

## 作者：pisceskkk (赞：1)

嘻嘻，第一次写题解，不喜勿喷……

下边的大神不是转二叉树，就是dfs+dp……由于种种原（bu）因（hui），我写了一个比较基础的记忆化搜索+剪枝+某种背包。

一看到这个题，第一感觉 这是个treedp，第二感觉 这不是二叉树，然后就懵逼了……

于是我就自己琢磨出一个神奇的记忆化搜索。

首先，这个解法是以树形dp为模版的搜索；

然后，由于这不是二叉树，不能直接套模板，因此对每一层做一个背包问题的解法（具体是那种，不要问我，自己悟吧，反正我是没悟出来）；

其次，此种解法时间复杂度较高，第四五个点TLE了，所以需要剪枝（详见代码及注释）。

最后，貌似没法说这到底是个什么算法，也没有可算术式化的转移方程  ←.←

附c++代码：

···



```cpp
#include<cstdio>
#include<cstring>
#define Max(a,b) (a>b?a:b)
#define N 310
using namespace std;
struct point            //每一个点的信息 
{ 
    int sn,sum,s[N];    //儿子个数，子孙个数（剪枝用的），每个儿子的编号 
    point(){sn=0;sum=1;}//初始化 
}p[N];
int n,m,f[N][N],v[N][N],w[N];
int dp(int x,int l)//第x个课及其附带课程中选l门的最大学分 
{
    if(l<=0)return 0;//主要是l==0起作用 
    if(l>p[x].sum)return 0;//剪枝，当l多于x课的子孙时，
                          //必然不符合题意（这一处剪枝对这种解法很有必要） 
    if(v[x][l])return f[x][l];//记忆化 
    v[x][l]=1;
    int sn=p[x].sn;
    int ff[l+2];//用于跑某种背包（真的不要问我是什么背包） 
```
.//对于x的叶子层，选l-1门课时的最大学分
    
            

```cpp
    for(int i=1;i<=l+2;i++)
    ff[i]=-100000;//要求恰好选满l-1门课 的初始化 
    ff[0]=0;
    for(int i=1;i<=sn;i++)//跑背包 
    {
        int son=p[x].s[i],sonw=0//枚举儿子及其学分 
        for(int j=l-1;j>0;j--)
        {
            for(int k=j;k>0;k--)//对于每一个儿子，都有多种选课数，不是确定的，因此都有必要搜一遍 
            {
                sonw=dp(son,k);
                ff[j]=Max(ff[j],ff[j-k]+sonw);
            }
        }
    }
    f[x][l]=ff[l-1]+w[x];
    return f[x][l];
}
int si(int x)//把儿子，孙子，曾孙，重孙，玄孙……的数记下 
{
    for(int i=1;i<=p[x].sn;i++)
    p[x].sum+=si(p[x].s[i]);
    return     p[x].sum;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int a,b;scanf("%d%d",&a,&b);
        p[a].sn++;
        p[a].s[p[a].sn]=i;
        w[i]=b;
    }
    si(0);//准备剪枝 
    for(int i=1;i<=n;i++)//初始化边界 
    {
        v[i][1]=1;
        f[i][1]=w[i];
    }
    printf("%d",dp(0,m+1));//把零当做没有先修课的课的先修课，
                          //由于状态设的特别，因此需要m+1 
    return 0;
}
···
```

---

## 作者：Deny_小田 (赞：1)

小田又来发题解啦~~~


其实严格来说这不是我的题解，这是我&我的老师（xiao233）的题解。感谢~


树形DP，非常简单，就是之前时间炸了，有个数据是300 160，开小了数组。

附20分代码（后四个ＴＬＥ）







    

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define Size 305
using namespace std;
struct _node{
    int l,r,x;
}a[Size];
int f[Size][Size],b[Size],i,j,k,m,n,x,y,z;
int dp(int x,int y){
    int i,j,k,p,q;
    if(f[x][y] >= 0) return f[x][y];
    p = dp(a[x].r,y);
    for(i = 1; i <= y; i++){
        j = dp(a[x].l,i-1);
        k = dp(a[x].r,y-i);
        k += (j+a[x].x);
        if(k > p) p = k;
    }
    return p;
}
int main(){
    scanf("%d %d",&n,&m);
    memset(f,0,sizeof(f));
    for(i = 1; i <= n; i++) a[i].l = 205,a[i].r = 205,a[i].x = 0;
    memset(b,0,sizeof(b));
    for(i = 1; i <= n; i++){
        scanf("%d %d",&x,&y);
        a[i].x = y;
        if(!b[x]) a[x].l = i;
        else a[b[x]].r = i;
        b[x] = i;
    }
    for(i = 0; i <= 200; i++) for(j = 0; j <= 150; j++) if(i == 205||j == 0) f[i][j] = 0;else f[i][j] = -1;
    f[0][m] = dp(a[0].l,m);
    printf("%d\n",f[0][m]);
    return 0;
}
```
最后我的老师发现了错误，给我指正：







```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define Size 306
using namespace std;
struct _node
{
    int l,r,x;
} a[Size];
int f[Size][Size],b[Size],i,j,k,m,n,x,y,z;
int dp(int x,int y)
{
    int i,j,k,p,q;
    if(f[x][y] >= 0) return f[x][y];
    p = dp(a[x].r,y);
    for(i = 1; i <= y; i++)
    {
        j = dp(a[x].l,i-1);
        k = dp(a[x].r,y-i);
        k += (j+a[x].x);
        if(k > p) p = k;
    }
    f[x][y]=p;
    return p;
}
int main()
{
    scanf("%d %d",&n,&m);
    memset(f,0,sizeof(f));
    for(i = 1; i <= n; i++) a[i].l = 305,a[i].r = 305,a[i].x = 0;
    memset(b,0,sizeof(b));
    for(i = 1; i <= n; i++)
    {
        scanf("%d %d",&x,&y);
        a[i].x = y;
        if(!b[x]) a[x].l = i;
        else a[b[x]].r = i;
        b[x] = i;
    }
    for(i = 0; i <= 305; i++) for(j = 0; j <= 200; j++) if(i == 305||j == 0) f[i][j] = 0;
            else f[i][j] = -1;
    f[0][m] = dp(a[0].l,m);
    printf("%d\n",f[0][m]);
    return 0;
}
so and so ，没有了，谢谢阅读~~~
```

---

## 作者：lqylqylqy (赞：1)

裸的树形DP+记忆化,dp[i,j]表示第i门课,它以及它的后代可以选j门课的最大得分

注意要多叉转二叉

```delphi


program Project1;
type node=record
            l,r,fen:longint;
          end;
var a:array[-1..410]of node;
    jyh:array[-1..410,-1..310]of longint;
    f:array[-1..410]of longint;
    i,j,n,m,k,s:longint;

function treedp(x,y:longint):longint;
var i,t,max:longint;
begin
  if jyh[x,y]>=0 then exit(jyh[x,y]);
  max:=treedp(a[x].r,y);
  for i:=1 to y do
    begin
      t:=a[x].fen+treedp(a[x].l,i-1)+treedp(a[x].r,y-i);
      if t>max then max:=t;
    end;
  jyh[x,y]:=max;
  exit(max);
end;

begin
  readln(n,m);
  for i:=-1 to n do
    begin
      f[i]:=0;
      a[i].l:=-1;
      a[i].r:=-1;
      for j:=0 to m do
        if (i=-1)or(j=0)then jyh[i,j]:=0
                        else jyh[i,j]:=-1;
    end;
  for i:=1 to n do
    begin
      readln(k,s);
      a[i].fen:=s;
      if f[k]=0 then a[k].l:=i
                else a[f[k]].r:=i;
      f[k]:=i;
    end;
  writeln(treedp(a[0].l,m));
end.  


```

---

## 作者：cscy (赞：1)

比较基础的树形dp我竟然搞了三天，不说了，过于蒟蒻。

首先我们知道所有dp其实都是爆搜的优化，那么优先想爆搜怎么办。

对于一个节点，假如必须选它，你要在这个节点的子树上选一些点， 然后让结果最大。那显然要枚举这个节点的每一个子树上要选几个节点，然后递归解决。

就比如某节点node有两个子节点，然后你可以选5个节点，除去node节点自己算一个，那么就要分配名额了，方案如下：

左0，右4

左1，右3

左2，右2

左3，右1

左4，右0

但若果节点数不止两个，那么枚举起来复杂度相当高，但是你观察发现左边选3个好像不会影响右边选1个的结果，而且每个子节点的子树最多就选4个，那就好办了，枚举每一个子节点所分配到的结果0到m-1不就好了。这样就把指数级的枚举降到了平方级。

但每个节点都有平方级别的分支，还是吃不消啊。
但是如果你写出所有分支的话，就会发现好像很多分支是重的，就比如左4会枚举自己的子节点0-3，但是左3也会枚举0-2，同理左2也计算了0-1
这样就做了大量重复运算，十分浪费。因此考虑dp

这时候你发现每一个节点的选择只有一个，且必须选一个作为最终结果，那么是不是很想分组背包？每一个节点所有的选择作为一组，每一个选择是个物品。

那好，不需要每个节点都开一大堆分分支枚举了，每个节点都做一次分组背包，复杂度n^3，一看数据量：300，妥了！

当然分组背包怎么做呢？

对于叶节点直接把它自己算上就完事了。
对于其他节点先计算每组带来的收益，最后加上自己带来的收益。
对于超级根节点0节点，没有自己，所以不做加自己的操作。

不会分组背包那就真没救了（就是我）

完事。

---

## 作者：Max__HE (赞：1)

## [题目描述](https://www.luogu.org/problemnew/show/P2014)

点开旁边的算法标签，发现是树形dp;
好的，开始找转移方程：

实际上这道题与二叉苹果树很像；

一个是剪不剪当前这个树枝以及它儿子剪多少枝谋求最大值；

而这道是修到i科目后，在它儿子上再修k门课，再在不是他儿子的科目上选m-k-1门；

（这说的有点绕，待会就清晰了）

### 但是

二叉苹果树已经是一颗好的二叉树了~~废话~~

而选课给的是一个多叉树，所以要将其转化为二叉

此题目若不转换为二叉树，则状态需定义为dp[i][j][k](k=1或0,0代表不选i，1代表选i（有点麻烦）


## 多叉树转换二叉树：

方法非常简单,“左儿子,右兄弟” 。

就是将一个节点的第一个儿子放在左儿子的位置

下一个儿子，即左儿子的第一个兄弟,放在左儿子的右儿子位置上

再下一个兄弟接着放在右儿子的右儿子，以此类推。

代码：
```
scanf(“%d%d”,&u,&v)  //v的父亲是u
if(last[u]==0)l[u]=v;    //将v作为u的左儿子
else r[last[u]]=v;   //将v作为u的最后一个子孙的右儿子
last[u]=v;   //last数组记录u的最后一个子孙
```
(可以用样例自行模拟一下)

——————————————————————

在转化后的二叉树上，我们如果选第1，就必须先选2，如果选3，不一定要选2。

设dp[i][j]表示选到第i门课，
还要选j门课的最大学分，

那么分两种情况讨论：
如果选i，则还要在l[i]上选k门，并且在r[i]上选就j-k-1门

如果不选i，则只能在r[i]上选j门，0<=k<j。

![转化后的样例](https://cdn.luogu.com.cn/upload/pic/58803.png)


因为是树形，所以我们的搜索顺序当然是dfs，从根结点向叶子结点搜索，这样就实现叶子向根传值，记得记忆化哦。


```cpp
#include<bits/stdc++.h>
using namespace std;
int read() 
{
	int x=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}

int last[1010],l[1010],r[1010];//l代表左儿子（即要有先修），r代表右儿子（即无先需修） 
int dp[1010][1010],s[1010];
int n,m;

int work(int k,int t)//k表示此课程，t表示还需修t门课 
{
	if(dp[k][t]>=0) return dp[k][t];//记忆化 
	if(k==0) return 0;//叶子节点，即接下来没有课可修 
	dp[k][t]=work(r[k],t); //如果不选k，则只能在r[k]上选t门 
	for(int i=0;i<t;++i)
	{
		dp[k][t]=max(dp[k][t],(work(l[k],i)+work(r[k],t-i-1)+s[k]));//如果选k，则还要在l[k]上选i门，并且在r[k]上选就t-i-1门
	}
	return dp[k][t];
}

int readdate()
{
	n=read(),m=read();
    //转二叉 
	for(int i=1;i<=n;++i)
	{
		int v=i,u=read();
		s[i]=read();
		if(last[u]==0) l[u]=v;
		else r[last[u]]=v;
		last[u]=v;
	}
	memset(dp,-1,sizeof(dp));
	printf("%d",work(1,m));
}

int main()
{
	readdate();
	return 0;
} 
```

实际上还是有点小问题的（~~因为没过样例~~），但还是ac了;

所以同学们可以自行修正









---

## 作者：管仲 (赞：1)

//近几天我学习了树状背包，对于一名从7月份才开始学的蒟蒻，还是有些难以理解

//在此我来以一名蒟蒻的角度来解析一下题目

//看到题目，我的第一想法就是画图（好理解） 然而我发现，组成的貌似不是一棵树

//我们很轻松可以想到要将2,3找一个fa，没有就造一个（0）；

//这样我们就把n个节点的森林转化成n+1个节点的树，其中节点0为根节点
```cpp
#include<bits/stdc++.h>
#define maxn 200000
using namespace std;
struct Edge
{
	int v,next;
} e[maxn*2];
int n,m;
int f[2000][2000];
int head[maxn*2],cnt=0;
void add(int u,int v)
{
	e[++cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
void dp(int now)
{
	for(int i=head[now]; i!=-1; i=e[i].next)
	{
		int go=e[i].v;
		dp(go);
		for(int j=m+1; j>=1; j--)
			for(int k=0; k<j; k++)
			{
			f[now][j]=max(f[now][j],f[go][k]+f[now][j-k]);
			}//蒟蒻可以先背一下，之后再理解
	}
}
int main()
{	memset(head,-1,sizeof(head));//一定要写memset
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
	int fa;
	cin>>fa;
	cin>>f[i][1];
	add(fa,i);
	}
	dp(0);
	cout<<f[0][m+1];//因为建了一个节点
}
```

---

## 作者：安好 (赞：1)

/\*
树形dp:f[i][j]表示以i为根节点的子树不包括i选了j门课的最大收益

转移的时候枚举i的子节点选多少门课

f[i][j]=max(f[i][j],f[i][j-k]+f[to][k]); 

\*/







```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 307
#define M 2007
using namespace std;
int f[N][N],size,cnt,n,m;
int head[M];
struct edge
{
    int u,to,pre;
}e[M<<1];
inline int init()
{
    int x=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
inline void add(int u,int to)
{
    e[++cnt].to=to;e[cnt].pre=head[u];head[u]=cnt;
}
void dp(int x)
{
    for (int i=head[x];i;i=e[i].pre)
    {
        int y=e[i].to;dp(y);
        for(int i=m+1;i>1;i--)
          for(int j=i-1;j>0;j--)
            f[x][i]=max(f[x][i],f[x][i-j]+f[y][j]);
    } 
}
int main() 
{
    int x,y;
    n=init();m=init();
    for(int i=1;i<=n;i++)
    {
        x=init();y=init();
        f[i][1]=y;
        add(x,i);
    }
    dp(0);//
    printf("%d",f[0][m+1]);
    return 0;
}
```

---

## 作者：king_xbz (赞：0)

蒟蒻的第一道树形背包题，在看了Lancy大佬的树形动规学习笔记后完成了这道题，做法比较像，但做了一定的优化，代码比较简洁易懂

祝大家ac

code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define fread ios::sync_with_stdio
#define fint register int
#define p 37324
#define h 2001
//头文件与宏定义 
using namespace std;
struct node
{
	int to;
	int next;
}
e[p];
int head[p];
int cnt;
//链式前向星存图 
int f[h][h];
int a,b[p];
int n,m;
inline void adds(int u,int v);
void dp(int x,int y);
signed main()
{
    fread(false);
    //流输入优化 
	cin>>n>>m;
	for(fint i=1;i<=n;i++)
	{
	cin>>a>>b[i];
	adds(a,i);
}
//储存边和权 
    dp(0,m);
    //以0为根开始搜 
   /* for(fint i=0;i<=n;i++)
    {
    for(fint j=0;j<=n;j++)
    {
    cout<<f[i][j]<<" ";
}
cout<<endl;
}*/
    cout<<f[0][m];
    exit(0);
    //快速退出 
} 
inline void adds(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
//链式前向星存图 
void dp(int x,int y)//用x储存点，y储存次数 
{
	if(y==0)
	return ;
	//如果已经选了m个，就退出 
	for(fint i=head[x];i;i=e[i].next)
	{
	int tt=e[i].to;
	f[tt][0]=f[x][0]+b[tt]; 
	for(fint j=1;j<=y;j++)
	f[tt][j]=f[x][j]+b[tt];
	//储存这个点权值加上之前权值和 
	dp(tt,y-1);
	//进行下一次搜索 
	for(fint k=1;k<=y;k++)
	f[x][k]=max(f[x][k],f[tt][k-1]);
	//对比求出最大得分
}
}

---

## 作者：wanxiang_zx (赞：0)

```
//来一手搜索解法，用记忆化提高效率
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=800;
int n,q,id=0;
int head[maxn],nxt[maxn],lt[maxn],rt[maxn],W[maxn];
int f[maxn][maxn],e[maxn];
void add(int x,int y)
{
     e[++id]=y;
     nxt[id]=head[x];
     head[x]=id;
}
void create(int x)
{
     //以x为根建树 
     if(!head[x])
       return;
     //如果它没有邻接点，说明它就是叶节点 
     int p=e[head[x]];
     //p为x的第一个子节点 
     lt[x]=p;
     create(p);
     for(int i=nxt[head[x]];i;i=nxt[i])
     {
       int y=e[i];
       rt[p]=y;
       //长子的rt指向它的兄弟 
       create(y);
       p=y;
       //目标是把兄弟的rt继续指向兄弟的兄弟
       //最后就是以长子为头的一串儿 
     }
     /*
         利用长子兄弟法把多叉树转化为二叉树：
             即lt[x]存x的第一个子节点，而rt[x]存x点的兄弟节点 
     */
}
int dfs(int x,int k)
{
     //表示在以x为根的树中挑选k个点 
     if(!k)
       return 0;
     //如果k==0，就说明不能继续选择了，因为名额已经用光了，返回0 
     if(!lt[x] && !rt[x])
       return W[x];
     //如果x点既没有子树，也没有兄弟，也就是说它是一个孤单的叶节点
     //就返回自己的点权，因为最多只能选个自己 
     if(f[x][k]<0)
     {
       //这里用记忆化搜索提高效率
       //f数组初值设为-1，所以如果没处理过就处理 
       for(int i=k-1;i>=0;i--)
         f[x][k]=max(f[x][k],dfs(lt[x],i)+dfs(rt[x],k-1-i)+W[x]);
       //i枚举给x点的子树分多少个点  剩余数量留给x的所有兄弟们 
       if(rt[x])
         f[x][k]=max(f[x][k],dfs(rt[x],k));
       //如果x点有兄弟的话，也可以全部分给兄弟们 
     }
     return f[x][k];
}
void init()
{
     memset(W,0,sizeof(W));
 	 memset(f,-1,sizeof(f));
	 memset(lt,0,sizeof(lt));
	 memset(rt,0,sizeof(rt));
	 memset(nxt,0,sizeof(nxt));
	 memset(head,0,sizeof(head));
}
int main()
{
	init();//反正f数组要初始化为-1，别的做不做都行 
    cin>>n>>q;
    for(int i=1;i<=n;i++)
    {
      int x,y;
      cin>>x>>y;
      W[i]=y;
      //这里选择以n+1为原点，所以如果必修科目是0，就改为n+1; 
      if(!x)
        x=n+1;
      add(x,i);
    }
    create(n+1);
    cout<<dfs(n+1,q+1)<<endl;
    system("pause");
    return 0;
}
     

```


---

## 作者：Piwry (赞：0)

什么树形dp总结我就不讲了（太多了），这里只讲下**这道题**（~~主要是第一次接触题解我没一个看懂的~~），
### 但是
注意对于**树形dp的dfs**，其回溯时**已访问的节点**（**也就是子节点**）的dp值**总是处理好的**

---
### 定义


| f[ ][ ] |
| :----------: |



表示状态、



| w[ ]  |
| :----------: |




表示权值；

**f[i][j]** 代表**以i为根**的树选它的**j个子节点**和**自己**的**最大权值**

---
# 1. 
首先初始化时可以**发现**对于任意


| f[i][k] _{k属于正整数}_  |
| :----------: |



总有最小值



| w[i] |
| :----------: |



（其实就是当f状态有意义时总是选**i**）

---
### 于是


```cpp
for(int tmp =m/*可能取到的最大值*/; tmp >= 0; tmp--) f[i][tmp] =w[nw];
```


---
# 2.

接着列出状态转移方程


| f[i][j] =max(f[i][j], f[i][j-k-1]+f[son][k]) _{k属于正整数， son是i的子节点}_  |
| :----------: |


可以将子节点想象为**物品**，其选了多少点想象为**花费** 

（同时可能取到的k**总不超过m**，所以程序中就将k上限**设为m**）

---
### 注意



| j-k-1 |
| :----------: |



**"-1"** 是因为这里f状态的第二个下标代表的是**选它某数量的子节点**而不包括自己，同时题目的从属关系令f状态有意义时**i**（**其实就是这颗树的父亲**）必须选

-----
# 3.
到这里其实就差不多了，剩下还有就是程序中用一个不存在的节点"0"作为森林**所有树的父节点**，方便深搜处理

```cpp
#include <cstdio>
#include <string.h>
#include <algorithm>
using namespace std;

int first[301], w[301], n, m;
int next[300], to[300];
//我也不能确定<这种>通过存边的方式来存图的方法具体叫什么...总之稀疏图这么做就对了

inline void init(){
	int x;
	//first储存每个点的第一条边的"ID"，next存这条边的“下一条边”编号...理解下
	memset(first, -1, sizeof(first));
	for(int i =1; i <= n; i++){
		scanf("%d%d", &x, &w[i]);
		to[i-1] =i;
		next[i-1] =first[x];
		first[x] =i-1;
	}
}

int tp[301][301];//tp[i][j]i点选j个子节点这棵以i为根的树的最大值 

void dfs(int nw){
	int l =first[nw];
	for(int k =m; k >= 0; k--) tp[nw][k] =w[nw];//k顺序无所谓，总之把自己的值先塞进去 
	while(l != -1){
		dfs(to[l]);
		for(int j =m; j >= 0; j--)
			for(int k =0; k < j; k++)
				//如果难以理解的话试着将子节点想象为物品，其选了多少点想象为花费 
				tp[nw][j] =max(tp[nw][j], tp[nw][j-k-1]+tp[to[l]][k]);
    	//这边的技巧是分组背包的，不知道的得恶补下背包基础知识
		l =next[l];
	}
}

int main(){
	scanf("%d%d", &n, &m);
	init();
	
	dfs(0);
	printf("%d", tp[0][m]);
   //第二个下标是m是因为"0"这个节点不需要去"学"
}
```

---

## 作者：TLE自动机 (赞：0)

介绍一种优化！（树形dp思路可以自行看上一篇题解orz）

在处理每个节点的时候，我们不用处理到m+1的范围，因为他本身就没有那么多儿子，上面的结果和F[u][最大儿子数]的结果其实是一样的QwQ

例如：对于只有2个儿子的节点，我们就只用算到F[i][3]就行了

于是就可以处理出每个节点的儿子数再dp！

本人自带巨大常数15msQAQ

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int read(){
    int x=0;char ch=getchar();bool pos=1;
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return pos?x:-x; 
}
int n,m,t,top=0,c[30001],f[305][305],sum[30001],head[30001];
struct node{
    int v,next;
}edge[30001];
inline void add(int u,int v){
    edge[++top].v=v;
    edge[top].next=head[u];
    head[u]=top;
}
inline void count(int now){
	sum[now]++;
	for(int i=head[now];i;i=edge[i].next){
		int v=edge[i].v;
		count(v);
		sum[now]+=sum[v];
	}
	return;
}
inline void dp(int now){
	//f[now][0]=0;
	for(int i=1;i<=sum[now];i++) f[now][i]=c[now];
	if(head[now]){
		for(int i=head[now];i;i=edge[i].next){
			int v=edge[i].v;
			dp(v);
			for(int w=sum[now];w>=1;w--){
				int p=min(w-1,sum[v]);//优化过程
				for(int k=0;k<=p;k++){
					f[now][w]=max(f[now][w],f[now][w-k]+f[v][k]);
				}
			}
		}
	}
	return;
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		int k=read();c[i]=read();
		add(k,i);
	}
	count(0);
	dp(0);
	cout<<f[0][m+1];
	return 0;
}
```

---

## 作者：取名好烦人 (赞：0)

```cpp
//看了好几篇题解大多都是dp
//像我这看见dp就颤抖的小蒟蒻感到十分害怕
//于是给大家来一份二叉树的题解
//第一次写题解，有什么写得不好的请大家见谅 
//解释都在注释里 
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=300+400;
int n,m;
int vis[N],val[N],dp[N][N];
struct node
{
    int lef,rig;
}tree[N*4];
void dfs(int x,int y)//x是到了哪节课 ，y是还剩多少节课可以选 
{
    int maxval=0;
    if(x==0)return;//当前分支没有课可以选了就返回 
    if(y==0)return;//选课的次数已经用完就返回 
    if(dp[x][y]> 0)return;//如果已经搜过这一 情况就返回 
    dfs(tree[x].rig,y);//先从它的兄弟搜起 
    maxval=max(maxval,dp[tree[x].rig][y]);//取最大值 
    dp[x][y]=0;
    for(int i=1;i<=y;i++)//在搜它的儿子，这里是在枚举分别给儿子和兄弟分多少节课 
    {
        dfs(tree[x].lef,i-1);
        dfs(tree[x].rig,y-i);
        if(maxval<dp[tree[x].lef][i-1]+dp[tree[x].rig][y-i]+val[x]){
            maxval=max(maxval,dp[tree[x].lef][i-1]+dp[tree[x].rig][y-i]+val[x]);//取最大值 
        }
    }
    dp[x][y]=maxval;//赋值 
}
int main()
{
    int root=0;
    memset(dp,0,sizeof(dp));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        int x,w;
        scanf("%d%d",&x,&w);
        val[i]=w;
        if(x==0&&root==0)root=i;//首先确定根节点 
        if(!vis[x])tree[x].lef=i;//如果x的父亲还没有儿子，就把它作为它父亲的左儿子 
        else tree[vis[x]].rig=i;//否则就是他父亲左儿子的兄弟 
        vis[x]=i;//更新他父亲的儿子情况 
    }
    dfs(root,m);//开始深搜 
    printf("%d",dp[root][m]);
    return 0;
}
```

---

## 作者：Dennis_MacAlistair (赞：0)

## P2014 选课 ------>[P2014 选课](https://www.luogu.org/problemnew/show/P2014)

# 题目描述
#### 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？

# 输入输出格式
### 输入格式：
####  第一行有两个整数N,M用空格隔开。(1<=N<=300,1<=M<=300)接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1<=ki<=N, 1<=si<=20）。

### 输出格式：
#### 只有一行，选M门课程的最大得分。

其实就是一个 多叉树 转 二叉树！！
变形很重要！！
先附上变形代码
```c
for(rg int i=1;i<=n;i++){
//不必纠结rg是啥，后面代码有
        int a,b;
        read(a),read(b);//i的先选课为a，学分为b 
        shu[i]=b;
        if(last[a]==0) l[a]=i;
        else r[last[a]]=i;
        last[a]=i;
    }
//l[]数组为该点的儿子
//r[]数组为该点的兄弟
//如果某x有多个兄弟，就将右子树不停延长
//直到没得
//左子树同理
//last数组为x的点的最后一个儿子
```
dp的动态转移方程很重要

code--->
```c
for(rg int k=0;k<dep;k++){

  dp[x][dep]=max(max(dp[x][dep],dfs(l[x],k)+dfs(r[x],dep-k-1)+shu[x]),dfs(r[x],dep));
  
}
```
这个转移很危险！！
一是l[x]=0 就是叶子结点的儿子没得，但在数组里我们认为0是整个森林的终结点，所以要特判
---->
```c
if (x<1||dep<1||x>n||dep>m) return 0;
```

二是已经dp数组 要剪枝，很烦！！

就是已经有值的不改了就是这样的
```c

if(dp[x][dep]!=0)return dp[x][dep];

```
好了接下来就是全部代码

```c
#include<cstdio>
#include<string>
#define il inline
#define rg register
#define maxn 305
using namespace std;

il void read(int & x){
   	x=0;int f=1;char chr=getchar();
	while(chr<'0'||chr>'9'){if(chr=='-')f=-1;chr=getchar();}
	while(chr>='0'&&chr<='9'){x=x*10+(chr-'0');chr=getchar();}x=x*f;return ;
}

il void print(int x){if(x<0)putchar('-'),x=-x;if(x>9)print(x/10);putchar(x%10+'0');return ;}

il void clear(int a[],int n,int x){for(rg int i=1;i<=n;i++) a[i]=x;}

/*-----------------------------------------------------------------------------------------------*/ 
int n,m,dp[maxn][maxn];
int l[maxn],r[maxn],last[maxn],shu[maxn];//左儿子右兄弟 

/*-----------------------------------------------------------------------------------------------*/ 

il int dfs(int x,int dep){
//	print(233333333),
//	puts("");
//	print(x),putchar(' '),print(dep),puts("");
	if (x<1||dep<1||x>n||dep>m) return 0;
	if(dp[x][dep]!=0)return dp[x][dep];
	for(rg int k=0;k<dep;k++){
		dp[x][dep]=max( max( dp[x][dep] , dfs(l[x],k)+dfs(r[x],dep-k-1)+shu[x] )  ,  dfs(r[x],dep) );
	}
	return dp[x][dep];
}

/*-----------------------------------------------------------------------------------------------*/ 

int main(){
	read(n),read(m);
	for(rg int i=1;i<=n;i++){
		int a,b;
		read(a),read(b);//i的先选课为a，学分为b 
		shu[i]=b;
		if(last[a]==0) l[a]=i;
		else r[last[a]]=i;
		last[a]=i;
	}
	int root=l[0];
	dfs(root,m);
	print(dp[l[0]][m]);
	return 0;
}

```
爽！！----->END<-----

---

## 作者：Celebrate (赞：0)

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
struct node
{
	int lc,rc,c,v;//c表示值
	//v表示他最后一个孩子 
	node()
	{
		lc=rc=-1;//初始 
		v=0;
	}
}tr[110000];
int f[1100][1100];//f[x][y]表示以x为根节点，保留y个点的最大值 
int treedp(int x,int y)
{
	if(x<0 || y<0) return 0;//怎么可能小于0呢 
	if(f[x][y]!=-1) return f[x][y];//记忆化搜索 
	int  maxx=0;//记录最大值 
	for(int i=0;i<=y;i++)
	{
		int ls=y-1-i,rs=i;//左边留y-1-i,右边留i个点,注：x自己也要保留所以要-1 
		int lss=0,rss=0;
		if(tr[x].lc!=-1) lss=f[tr[x].lc][ls]=treedp(tr[x].lc,ls);//如果左子树存在 
		if(tr[x].rc!=-1) rss=f[tr[x].rc][rs]=treedp(tr[x].rc,rs);//如果右子树存在 
		if(ls<0) maxx=max(maxx,rss);
		else	 maxx=max(maxx,lss+rss+tr[x].c);
	}
	return maxx;
}
int main()
{
	int i,n,m,xx;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		scanf("%d%d",&xx,&tr[i].c);
		if(tr[xx].v==0) tr[xx].lc=i;
		else			tr[tr[xx].v].rc=i;
		tr[xx].v=i;
	}
	memset(f,-1,sizeof(f));
	for(i=0;i<=n;i++) f[i][0]=0;
	printf("%d\n",treedp(0,m+1));
	return 0;
}
```

---

## 作者：星星之火 (赞：0)

选课这题，摆明了是一个树形的DP（因为课程之前存在从属关系），有同学就会质疑，这边数摆明不是树结构啊，但个人认为不会有环的存在，因此下面我们采用一种常用方法构建树。

构建一个虚的根节点0，把没有直接先修课的节点连上，我们最后的答案就是f[0][m+1]，指在节点0中选m+1个结点的最大学分。

f[i][j]表示在子树i中选了j门课的最大学分（包括本身）

我们在记录下每个点之前的联系关系之后，我们要开始不可缺少的一步———dfs，当然是从根节点开始，dfs（0）

在对每个儿子开始DP前，我们首先要处理完这个儿子，因此dfs(儿子)应该放在DP之前

    for (int i=head[x];i;i=next[i])
	{
		dfs(i);
		for (int j=m+1;j>=0;j--)
		for (int z=j-1;z>=0;z--)//之所以减一是因为必须要选了第x门课才能继续选
		f[x][j]=max(f[x][j],f[x][j-z]+f[i][z]);
	}
怎么样？这段代码是不是很像背包问题，那么我来解释一下状态转移方程

在第x节点中选j个点的最大学分等于在i节点（i是他的孩子）选z个点加上在x上选剩下的点的最大学分（说实话我自己也有些无法理解，但根据本蒟蒻的经验有的树形DP就是这样，具体原因我还没有细想）

那么其实就是这样了

---

## 作者：lvjiyuan (赞：0)

我用的是多叉树转二叉树；

用f[root][k]表示第root节课为根且还剩k个自由选课数时，学分的最大值；

如果不选此课，它与它的后续值皆为零；

或者选，

最终求max（它的值+兄弟与左孩子瓜分剩余选课数时最优解，原状态，不选它（但它兄弟的状态要与它合并，因为左孩子只有一个））；

不多说，上代码；


    
     
    
    
```cpp
#include<bits/stdc++.h> 
using namespace std;
const int N=320;
int n,m;
int f[N][N],b[N],c[N],s[N];
void dp(int root,int k)
{
    if(f[root][k]>=0)return ;
    if(root==0||k==0){f[root][k]=0;return ;    }
    dp(b[root],k);//兄弟与左孩子享有同等权利；
    for(int i=0;i<k;i++)
    {
        dp(c[root],k-i-1);//选第root门课； 
        dp(b[root],i);// 因为根节点给下一代指标时，只会给左孩子，所以下一代的左孩子要分给兄弟指标； 
        f[root][k]=max(f[root][k],max(f[b[root]][k],f[b[root]][i]+f[c[root]][k-i-1]+s[root]));
        //求三个状态最大值：选此状态（原封不动），不选，选此状态（更新，此节点+瓜分指标后的兄弟与左孩子的最优解） 
    }
}
int main()
{
    cin>>n>>m;
    int fa;
    for(int i=1;i<=n;i++)
    {
        cin>>fa>>s[i];
        if(fa==0)fa=n+1; 
        b[i]=c[fa];//c【i】记录的是长子，长子把‘长子’的位子让给i,原长子成为了新长子兄弟， 
        c[fa]=i;//父亲直辖原长子； 
    }
    memset(f,-1,sizeof(f));
    dp(c[n+1],m);
    cout<<f[c[n+1]][m];//无先修课的的最优值会集中于c【n+1】； 
    return 0;
}
```

---

## 作者：kczno1 (赞：0)

给一楼作一个补充:

多叉树转换为二叉树，左儿子存原儿子，右儿子存原兄弟。

加x->y，则:

        if last[x]=0 then l[x]:=y 

             else r[last[x]]:=y;

        last[x]:=y;

这是我向他学的，写的漂亮。

但他的转移是O(M)的，而实际上可以O(1)。

f[x][m]表示到了点x有m门课可以选的max值。

考虑一个点只有选不选两种情况，所以f[x][m]=max(f[r[x]][m],f[l[x]][m-1]+v[x])

考虑儿子跑完了还要跑兄弟的，所以给最后一个儿子连个向兄弟的边,即:r[last[x]]=r[x]。(这是我处理这种问题的通用方式。)

```pascal
const mn=505;mm=355;
var
 n,m,i:longint;
 fa:longint;
 v,last,l,r:array[0..mn] of longint;
 f:array[0..mn,0..mm] of longint;

function max(x,y:longint):longint;
begin
 if x>y then exit(x);
 exit(y);
end;
function dfs(x,m:longint):longint;
begin
 if f[x,m]=0 then
 begin
  if (m=0)or(x=0) then exit(0);

  f[x,m]:=max(dfs(r[x],m),dfs(l[x],m-1)+v[x]);
 end;

 exit(f[x,m]);
end;

var vis:array[0..mn] of boolean;
procedure go(x:longint);
begin
 if vis[x] then exit;vis[x]:=true;
 r[last[x]]:=r[x];
 if l[x]=0 then l[x]:=r[x]
 else go(l[x]);
 go(r[x]);
end;

begin
 assign(input,'1.in');reset(input);
 readln(n,m);
 for i:=1 to n do
 begin
  read(fa,v[i]);
  if last[fa]=0 then l[fa]:=i
  else r[last[fa]]:=i;
  last[fa]:=i;
 end;

 go(l[0]);
 writeln(dfs(l[0],m));
end.
```

---

## 作者：dolphin (赞：0)

补一发……

这道题我是直接dp的（个人感觉转二叉没什么用？）

将所有没有先修的节点作为0号节点的子节点

f[i][j]表示以i为根的子树中，**不选根i**，选j门课的最大价值

转移时我们枚举当前以x为根的子树选课的数量（i），以及分配给x的子节点多少节课（j）

不难写出方程：f[x][i]=max(f[x][i],f[x][i-j]+f[y][j]);

···cpp

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=305,M=2001;
int f[N][N],size=0,n,m;
int head[M],nxt[M],son[M];
void uni(int x,int y){
    size++;
    nxt[size]=head[x];
    head[x]=size;
    son[size]=y;
}
void dp(int x){
    for (int e=head[x];e;e=nxt[e]){
        int y=son[e];
        dp(y);
        for (int i=m+1;i>1;i--)//totle tree x
            for (int j=i-1;j>0;j--)//totle:sons of x
                f[x][i]=max(f[x][i],f[x][i-j]+f[y][j]);
    }
}
int main(){
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++){
        int a,tmp;
        scanf("%d %d",&a,&tmp);
        f[i][1]=tmp;
        uni(a,i);
    }
    dp(0);
    printf("%d",f[0][m+1]);
    return 0;
}
···
```

---

## 作者：ghj1222 (赞：0)

一拿到这个题时，看着跟“金明的预算方案”有点像，结果一看完全不像。。（好吧是今明的预算方案像这道题，我也茫然了）

正如楼下说的，要把多叉树变成二叉树。那么这颗二叉树长啥样呢？看下面一句话

一个节点的左孩子是这个节点的第一个孩子，一个节点的右孩子是这个节点的第一个兄弟。

//有人问：那么这个节点的别的孩子呢？答：就是他第一个孩子的兄弟啊！


然后dp[i][j]是以第i个节点为根的二叉树（注意是二叉树），能选择j门课程时候的最大学分。

convert是多叉树转二叉树的代码（巧妙地把森林变成了树，根节点为0）

dfs是记忆化搜索，相信大家能看懂滴（反正有注释）

main函数，一如既往的 读入->计算->输出

PS.数组一开始我开的201，然后前三个点AC，第四个RE，第五个TLE。。于是听了旁人的建议，开大了点，意想不到的事情发生了。。AC了。。

/*********************************/

```cpp
#include <iostream>
using namespace std;
int n,m;
int a[2001],f[2001];//a[i]是某一门课程的学分 f[i]是某一门课程在多叉树中的爹
int lChild[2001],rChild[2001];//二叉树的左子树和柚子树
int dp[2001][2001];//dp[i][j]是以第i个节点为根的二叉树（注意是二叉树），能选择j门课程时候的最大学分。
void convert()//多叉树 -> 二叉树 
{
        for(int i=1;i<=n;i++)
        {
                int fa=f[i];
                if(lChild[fa]==0)lChild[fa]=i;//爹没有儿子 
                else//爹有儿子 
                {
                        fa=lChild[fa];
                        while(rChild[fa])fa=rChild[fa];
                            rChild[fa]=i;
                }
        }
}
int dfs(int i,int j)//i是当前节点，j是剩余的课程数目 
{
        if(i<1||j<1||i>n||j>m)return 0;//边界判断，你懂得
        if(dp[i][j]!=0)return dp[i][j];//查备忘录，你也懂得
        for(int k=0;k<j;k++)//选给左子树k个，自己留一个（得选自己），剩下的给右
                dp[i][j]=max(dp[i][j],a[i]+dfs(lChild[i],k)+dfs(rChild[i],j-k-1));//更新dp[i][j] 后面得就是自己的学分+左子树k个剩余课程的学分
        dp[i][j]=max(dp[i][j],dfs(rChild[i],j));//不选择自己，都给自己的兄弟（右子树）
        return dp[i][j];//最后返回答案
}
int main()
{
        cin >> n >> m;
        for(int i=1;i<=n;i++)
                cin >> f[i] >> a[i];
        convert();
        cout << dfs(lChild[0],m) << endl;
        return 0;
}

```

---


# 二叉苹果树

## 题目描述

有一棵苹果树，如果树枝有分叉，一定是分二叉（就是说没有只有一个儿子的结点）

这棵树共有 $N$ 个结点（叶子点或者树枝分叉点），编号为 $1 \sim N$，树根编号一定是 $1$。

我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有 $4$ 个树枝的树：

```
2   5
 \ / 
  3   4
   \ /
    1
```

现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。

给定需要保留的树枝数量，求出最多能留住多少苹果。


## 说明/提示

$1 \leqslant Q < N \leqslant 100$，每根树枝上的苹果 $\leqslant 3 \times 10^4$。

## 样例 #1

### 输入

```
5 2
1 3 1
1 4 10
2 3 20
3 5 20
```

### 输出

```
21```

# 题解

## 作者：子谦。 (赞：517)

PS：这只是个更新啊，求管理员给个通过

$update:2019-3-6$

之前说的话很多地方比较模糊，重新组织一下语言，改成了更易理解的描述方式，希望管理员给个通过\托腮

-----

一道题意清晰的树形DP模板题，不会树形DP的可以去看我的博客[**树形DP入门详解**](https://www.cnblogs.com/hanruyun/p/9788170.html)

这道题有一个隐含的条件，当某条边被保留下来时，从根节点到这条边的路径上的所有边也都必须保留下来

设$f[u][i]$表示$u$的子树上保留$i$条边，至多保留的苹果数目

那么状态转移方程也就显而易见了

$f[u][i]=max(f[u][i],f[u][i-j-1]+f[v][j]+e[i].w)(~1 \le i \le min(q,sz[u]),0 \le j \le min(sz[v],i-1)~)$

$u$表示当前节点，$v$是$u$的一个子节点，$sz[u]$表示$u$的子树上的边数，q就是题目中要求的最多保留边数

那么为什么是这个方程呢？

首先，为什么是$f[u][i-j-1]$而不是$f[u][i-j]$？

为前文提到了，保留一条边必须保留从根节点到这条边路径上的所有边，那么如果你想从$u$的子节点$v$的子树上留边的话，也要留下$u,v$之间的连边

那么取值范围$k$为什么要小于等于$i-1$而不是$i$呢？

同上，因为要保留$u,v$连边

对了，别忘了$i,j$要倒序枚举因为这是$01$背包

下放代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#define ll long long
#define gc getchar
#define maxn 105
using namespace std;

inline ll read(){
	ll a=0;int f=0;char p=gc();
	while(!isdigit(p)){f|=p=='-';p=gc();}
	while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}
	return f?-a:a;
}int n,m,f[maxn][maxn];

struct ahaha{
	int w,to,next;
}e[maxn<<1];int tot,head[maxn];
inline void add(int u,int v,int w){
	e[tot]={w,v,head[u]};head[u]=tot++;
}

int sz[maxn];
void dfs(int u,int fa){
	for(int i=head[u];~i;i=e[i].next){
		int v=e[i].to;if(v==fa)continue;
		dfs(v,u);sz[u]+=sz[v]+1;
		for(int j=min(sz[u],m);j;--j)
			for(int k=min(sz[v],j-1);k>=0;--k)
				f[u][j]=max(f[u][j],f[u][j-k-1]+f[v][k]+e[i].w);
	}
}

int main(){memset(head,-1,sizeof head);
	n=read();m=read();
	for(int i=1;i<n;++i){
		int u=read(),v=read(),w=read();
		add(u,v,w);add(v,u,w);
	}
	dfs(1,-1);
	printf("%d\n",f[1][m]);
	return 0;
}
```

如果有不明白的地方，欢迎私信向我提问，如果对你有帮助，请点个赞吧

## 感谢观看 请勿抄袭

---

## 作者：stone_juice石汁 (赞：341)

- ## 前言

本蒟蒻初次接触树形$dp$，不是很懂DALAO们把树枝上苹果转化为结点上苹果的做法，状态转移方程沃也不知道DALAO们怎么把$3$个方程合在一起的。我只好发一篇题解，介绍一下我的蒟蒻做法，顺便帮助一下有同样困惑的童鞋qaq。

- ## 思路

这道题正解是树形$dp$，还算一道比较基础的树形$dp$吧。

观察题目条件，我们得知，至少需要保留$q$条树枝。

那么，树枝的保留条数是要一定要加入状态转移方程的。加上我们要在扫整棵树时必须得知的结点信息，所以我们自然可以定义这么一个二维$dp$数组。

**定义$dp[maxn][maxm]$数组，$dp[i][j]$表示为，当前结点为$i$，保留树枝条数为$j$的情况下，所留下苹果数的最大值。**

既然这是一个树形结构，那么我们自然还要维护下面这么几个值：

- $ls[x],rs[x]$ 分别表示$x$的左儿子和右儿子结点

- $la[x],ra[x]$ 分别表示连向左右儿子的树枝上的苹果 

**这四个值均可以在递归建树的时候求得。我们现在要用这四个值写状态转移方程。**

首先来看几个特殊情况：

- $1$、当 $ls[i]==0$ && $rs[i]==0$ ，此时，这个结点没有左右儿子。这代表这是叶子结点。叶子节点固然是没有连向儿子的树枝的（因为它儿子都没有），所以直接返回$0$ 。

- $2$、当 $j == 0$ ，说明保留树枝条数为$0$，也就是不保留树枝。树枝都不保留，苹果自然也没有，所以也是返回$0$

**然后就是状态转移方程了。**

我们枚举一个中间量 $k$ 。**这个 $k$ 代表为我们给左儿子分配的树枝数**。这是什么意思呢？其实就是给左边的子树的树枝不能超过 $k$条 的意思。**也就是令左子树的树枝数最多为$k$。**

**我们令左子树的树枝数最多为$k$，右子树的树枝数显然最多为$j-k$。** 显然我们可以得到一个粗略的转移方程：

$dp[i][j] = max(dp[ls(i)][k-1] + dp[rs(i)][j - k-1] + la[i] + ra[i])$

**这里有些人注意到了，转移方程里写分配数分别是$k-1$和$j-k-1$，而非$k$和$j-k$。这是因为往左右儿子方向走，你还要再走过一条树枝才能到达儿子结点，所以实际上分配数是比原来少$1$的**

但是且慢，我们看似这个转移方程是对的，但是这里却分了$2$种特殊的情况。

- $1$、若$k==0$，此时$k-1==-1$，这代表我们根本不可能往左儿子方向走（走了的话我们就要亏边了）。所以不能加上$la[i]$。

- $2$、若$k==j$，此时$j-k-1==-1$，同样，这代表我们不会走向右儿子。所以不能加上$ra[i]$。

**所以，最后最终的转移方程实际上是这个样子的：**


- $dp[rs[i]][j-1] + ra[i] ~~~ (k=0)$

- $dp[ls[i]][j-1] + la[i] ~~~ (k=j)$

- $dp[ls[i]][k-1] + dp[rs[i]][j - k-1] + la[i] + ra[i] ~~~ (k \ne0,k\ne j)$



当然这个转移方程不是直接写上去的。由于要不断选取左子树和右子树，**所以上述过程实际上是递归完成的。**

这就是最主要的部分了。

- ## $Code$

主要的转移方程我觉得应该是讲清楚了。关于建树的问题，代码注释里有详细的解答。

所以直接看代码吧$qaq$

```cpp
#include <bits/stdc++.h>
#define mian main
#define QWQ puts("QWQ");
#define inf 0x3f3f3f3f
#define maxn 1005
#define maxm 105

using namespace std;

int n, q, ls[maxm], rs[maxm], la[maxm], ra[maxm];
//n,q如题，ls[x],rs[x]代表x的左右儿子，la[x],ra[x]代表连向左右儿子的边上的苹果 
int dp[maxn][maxm]; 
int head[maxn], nxt[maxn], to[maxn], val[maxn], cnt;//这是一堆建边要用的东西qaq 

void add_edge(int u, int v, int w)//邻接链表建边..貌似没什么好说的 
{
	nxt[++ cnt] = head[u];
	head[u] = cnt;
	to[cnt] = v;
	val[cnt] = w;
}

void build(int x, int fa)//x,fa分别是当前节点和父亲节点,此函数为建树 
{
	int g = 0;//g是计数器，用来分配左儿子和右儿子，下面有解释
	for(int i = head[x]; i; i = nxt[i])
	{
		int y = to[i];
		if(y != fa)//如果不为父节点，就一定为儿子节点 
		{
			g ++;
			if(g == 1) ls[x] = y, la[x] = val[i];//g==1分配到左儿子。顺便处理边权 
			else rs[x] = y, ra[x] = val[i];//g==2说明左儿子分配过了，分配到右儿子 
			build(y, x);//向下递归建树 
		}
	}
}

int _find(int i, int j) //dp[i][j]以i为根，保留j个树枝的最大值
{
	if(ls[i] == 0 && rs[i] == 0) return 0;//无左右儿子说明为叶子，叶子没有儿子树枝。 
	if(j == 0) return 0;//一个树枝都不分配，也就没有苹果了。 
	if(dp[i][j] > 0) return dp[i][j];//一个优化剪枝：这个点已经被更新过了就直接返回。 
	for(int k = 0; k <= j; k ++)//枚举给左儿子分配的树枝数k，给右儿子分配的即为 j-k。 
	{
		if(k == 0) dp[i][j] = max(dp[i][j], _find(rs[i], j - 1) + ra[i]);//k==0，相当于全给右儿子分配 
		else if(k == j) dp[i][j] = max(dp[i][j], _find(ls[i], j - 1) + la[i]);//k==j，相当于全给左儿子分配 
		dp[i][j] = max(dp[i][j], _find(ls[i], k - 1) + _find(rs[i], j - k - 1) + la[i] + ra[i]);
		//这种情况两边均有分配。
		//由于走到儿子结点都需要经过一条树枝，所以实际上分配数都要-1。 
	}
	return dp[i][j];
}

int main()
{
	scanf("%d%d", &n, &q);
	for(int i = 1; i <= n - 1; i ++)
	{
		int ui, vi, wi;
		scanf("%d%d%d", &ui, &vi, &wi);
		add_edge(ui, vi, wi);
		add_edge(vi, ui, wi);//建无向边 
	}
	build(1, 0);//建树 
	printf("%d", _find(1, q));//输出 
	return 0;
}
```
~~码字不易，悄悄要个赞没关系吧~~

---

## 作者：zhz小蒟蒻 (赞：151)

[题目链接](https://www.luogu.org/problemnew/show/P2015)  
$\mathcal{}$
**  
	这题是我在某奥赛一本通（提高篇）——树形DP中的第一道例题，抱着试一试的心态，本蒟蒻尝试了这道题。~~在过了n小时后，终于做出了这题~~  
    ~~以上纯属扯淡~~
**  
### 切入正题：
  首先，我们仔细看一下题目，可以发现——这是一棵树呀！所以，我们就需要用到树上DP。  
   那么，我们应该怎么设置状态呢？
   ![](https://cdn.luogu.com.cn/upload/pic/52119.png)  
   观看上面这张丑陋的图，红色的数字表示这条树枝所有的苹果数量。  
   **我们有没有了一些灵感，如果没有，那么我在来给一些提示**  
### **这道题的决策**
#### 1.保留这根树枝，获得它的苹果数  
#### 2.不保留这根树枝  
**So，我们的状态有一维是树枝的数量**  
** 那还有什么和状态相关的变量呢？没错，以第i个节点为根的子树  
（因为我们可以将这一棵大的子树分成若干个子树的值来求出），所以，我们的状态就出来了，设$f[i][j]$表示以 $i$ 为根节点保存 $j$ 根树枝的可以获得的最大苹果数**  
那么,$f[i][j]=max(f[i][j],f[left][j]+e[left].apple+f[right][k-j]+e[right].apple)$  
但是，这个转移方程是有问题的,$Why???$  
**我们来仔细看一下方程，$left$表示$i$节点的左儿子,$right$表示$i$的右儿子,$e[i].apple$表示第i条树枝的苹果数，看上去没毛病。但是，我们结合以下上面丑陋的图，再来看一下**  
当 $i=3$时，$f[i][1]=20$，$f[i][2]=40$，但是，当 $i=1$时，我们如果给 $3$号节点分配两根树枝，那么它会给你一个值，40，也就是说 $f[1][2]=40$，不对啊！如果我们给了3号节点2根树枝，那么1号节点就没有与3号节点相连的树枝，那么根本就不可能有 $40$个苹果呀（如果不能理解，可以这么想象，虽然然每条树枝上都有可以获得到的 $apple$,但是如果你没有放到 $1$号节点，这些苹果就都不是你的）！  
回到转移方程里面，我们可以发现，我们直接分配给了 $left$节点和 $right$节点 $j$根树枝和 $i-j$根树枝, $but$，我们并没有考虑 $left$节点和 $i$节点之间相连的树枝, $right$节点也是一样的，$So,$我们得将转移方程改一下  
$f[i][j]=max(f[i][j],f[left][j-1]+e[left].apple+f[right][k-j-1]+e[right].apple$
好了现在的就应该对了，我们把细节留在程序里面  
$\mathcal{Code:}$  
```
#include <iostream>
#include <cstdio>
using namespace std;
struct node
{
    int t; //这条边通向的节点
    int apple; //第i条树枝的苹果数
    int next; //第i条边的下一条边
};
node e[2*101];
int dp[101][101];
int head[101],n,q,tot=0;
void add(int x,int y,int z)  //邻接表存数
{
    e[++tot].t=y;
    e[tot].apple=z;
    e[tot].next=head[x];
    head[x]=tot;
}
void dfs(int f,int fa,int apple) //递归遍历这棵树
{
    int son[101]={0},cnt=0; //son[1]表示f的左儿子在第几条边,son[2]表示f的右儿子在第几条边
    bool flag=false;
    for(int xun=head[f];xun;xun=e[xun].next)
    {
        if(e[xun].t!=fa)
        {
        	flag=true;
            son[++cnt]=xun;
            dfs(e[xun].t,f,e[xun].apple);
        }
    }
    if(!flag) //如果没有儿子，说明它是叶子结点，直接回溯
    {
        return;
    }
    for(int i=1;i<=q;i++) //DP部分
    {
        for(int j=0;j<=i;j++)
        {
        	int t1=0;
        	if(j-1>=0) t1+=e[son[1]].apple;  //j-1>=0表示分配给了左儿子与i节点的一条相连的树枝
        	if(i-j-1>=0) t1+=e[son[2]].apple;//i-j-1>=0表示分配给了右儿子与i节点的一条相连的树枝
        	if(j!=0)
         		dp[f][i]=max(dp[f][i],dp[e[son[1]].t][j-1]+t1+dp[e[son[2]].t][i-j-1]);  //j!=0，表示两个儿子都分配了
         	else //j==0，表示只分配给了右儿子树枝
         		dp[f][i]=max(dp[f][i],dp[e[son[2]].t][i-j-1]+t1);
        }
    }
}
int main()
{
    scanf("%d %d",&n,&q);
    for(int i=1;i<=n-1;i++)
    {
        int x,y,z;
        scanf("%d %d %d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
    dfs(1,0,0);
    printf("%d",dp[1][q]); //因为最终我们要求的苹果数是以1为根节点的子树中保留q根树枝的最大苹果数，所以最终的结果等于dp[1][q]
    return 0;
}
```
### 谢谢观看，如果本题解有什么不对的地方或有什么不懂的地方，请私信本人（~~反正我也是这么过来的~~）

---

## 作者：sy_zmq_001 (赞：112)

##  前言：1 树形动归

  树形动归就是在树上的动归，树形动归一般是依赖于dfs的，根据动归的后效性，父节点的状态一般都依赖子节点的状态以某种方式转移而来，而每一个父节点的孩子的数量不定，这就很难以寻常的递推式通过几个for解决掉，而树这种东西它的遍历本身就依赖于dfs，可以说是比较暴力的打法了!
  
  差不多是这个样子的：
  
  先存图，以dfs进去找到叶节点，先处理叶节点的信息再一层层向父节点推进，根据题意进行选择列出转移方程
  ```
void dfs(int nx){
    f[nx][0]=0;
    f[nx][1]=val[nx];
    for(int i=0;i<son[nx].size();i++){
        int ny=son[nx][i];
        dfs(ny);
        f[nx][0]+=max(f[ny][0],f[ny][1]);
        f[nx][1]+=f[ny][0];
    }
}
```

  
  这里是一道树形DP的经典题，新手最好先打打这个
  
  
  没有上司的舞会
  [https://www.luogu.org/problemnew/show/P1352](https://www.luogu.org/problemnew/show/P1352)
  
## 前言：2 树形背包
树形背包就是原始的树上动归+背包，一般用来处理以一棵树中选多少点为扩展的一类题，基本做法与树上dp无异，不过在状态转移方程中会用到背包的思想。


它基本上是这个样子的：


存图（看个人喜好吧，我比较习惯邻接表），然后dfs进去补全子节点的信息，f数组的意思是以fa为中转点，找出fa往下的可取1~j个点时各自的最大收益。

```
void dfs(int fa){
	for(int i=0;i<son[fa].size();i++){
		int ny=son[fa][i];
		dfs(ny);
		for(int j=m+1;j>=1;j--){
			for(int k=j-1;k>=1;k--){
				f[fa][j]=max(f[fa][j],f[fa][j-k]+f[ny][k]);
			}
		} 
	}
}

```

这道题与p2014除了细节的处理外大体思路一样，都可以算是树形背包的板子题了，这里给出p2014的链接


选课
[https://www.luogu.org/problemnew/show/P2014](https://www.luogu.org/problemnew/show/P2014)

## 某某苹果树

做题的思路应该是首先从出题人千奇百怪的题目描述中抽离出它的本质，
然后我们就发现了


#### 1这是个二叉树
#### 2 n和q的范围不大
（~~当然这都是废话~~）

#### 分析题意：从树根往下找q条边使得最后得到的苹果数最多，最后得到的还得是个完整的树


#### 思路相同：从叶节点向上翻，每一个点找出以它为根节点的1~q的最大利益，除叶节点外，因为父节点不可能只从一个子节点那里要q-1条边（连接父、子节点还有一条边），所以就用到了背包的思想。其实有种随机搭配的感觉，父节点的大儿子要m条边，小儿子要w条边，自己留q-m-w-1条用来连接根节点求最大。


val保存子、父边的苹果数，所以f[x][j-k-1]中，父节点自己留的可用边-1。

```
		for(int j=q;j>=1;j--){
			for(int k=j-1;k>=0;k--){
				f[x][j]=max(f[x][j],val[x][ny]+f[ny][k]+f[x][j-k-1]);
			}
		}
```
这里有几个点需要注意：

#### 1这里注意苹果是长到边上的，但我们存的f数组是存的点。这里可以把边上的苹果直接给这条边连接的子节点，因为一条边连2个点，如果取则两个点都要，不取子节点一定不要但父节点还有可能作为别人的子点被用。

#### 2输入的边子、父关系未给，需要双向存但遍历时要特判。（苹果数也要存两遍）

#### 3还有就是刚才所说的父节点-1的问题了


给一下代码
```
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

vector <int> son[109];
int  n,q;
int f[109][109],val[109][109],used[109];

void dfs(int x){
	used[x]=1;//防止死循环做的标记		
	for(int i=0;i<son[x].size();i++){
		int ny=son[x][i];
		if(used[ny]==1)	continue;//如果标记过则代表这是它的父节点，直接跳过
		used[ny]=1;
		dfs(ny);
		for(int j=q;j>=1;j--){
			for(int k=j-1;k>=0;k--){
				f[x][j]=max(f[x][j],val[x][ny]+f[ny][k]+f[x][j-k-1]);
			}
		}
	}
}

int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		val[a][b]=c;//因为不知道关系存的两次价值（但只会用到一个）
		val[b][a]=c;
		son[a].push_back(b);
		son[b].push_back(a);
	}
	dfs(1);
	printf("%d",f[1][q]);
	return 0;
}
```



---

## 作者：Caicz (赞：93)

# 树！！！
#### 这是一道比较适合初学树形DP的人做的题（~~本蒟蒻楞是做了一下午在做出来~~）
**本题用树形DP就可以较~~轻松~~的做出来，但有几个问题**

**1.输入时不知道谁是父结点，谁是子结点**

这时候就应该双向存值，把两个点分别作为父结点的情况都记录下来，但是**注意DP时特判父、子结点**

**2.状态的转移**

这里直接就把动态方程写出来自己看 

dp[ i ][ j ] = max(dp[ i ][ j ] , dp[ son ][ k ] + dp[ i ][ j-son-1 ] + w[ i ][ son ])

**下面直接上代码，具体关键部分有注释**
```cpp
#include<bits/stdc++.h>
using namespace std;
int son[105][105],f[105][105];
int n,m,w[105][105],cnt[105],vis[105];

void dfs(int k)
{
	vis[k]=1;// 每次循环时，给父结点一个标记，防止无限循环 
	for(int i=1;i<=cnt[k];i++)
	{
		int ny=son[k][i];// 给 ny 赋上 k 结点的第 i 个 子结点 
		if(vis[ny]==1)continue;// 如果 ny 是 k 的 父结点，直接跳过循环 
		vis[ny]=1;
		dfs(ny);// 以  ny 为 父结点 进行搜索 
		for(int j=m;j>=1;j--) //逆序枚举当前可以选的树枝根数 
			for(int g=j-1;g>=0;g--) //逆序枚举留给 子结点 的树枝根数 
			{
				f[k][j]=max(f[k][j],f[ny][g]+f[k][j-g-1]+w[k][ny]);
				// f[ny][g] 表示以 ny 为 子结点 可以选 g 条边
				// f[k][j-g-1] 表示剩余给 k 结点的 兄弟结点 j-g-1 条边
				// w[k][ny] 表示 k 结点和 ny 结点之间的苹果数  
			}
	}
	return;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<n;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		w[x][y]=w[y][x]=z;//因为不知道 父结点 和 子结点分别是谁，所以同时存值 
		son[x][++cnt[x]]=y;// 每输入一次 当前结点，该节点的儿子数就 + 1 
		son[y][++cnt[y]]=x;
	}
	dfs(1);
	cout<<f[1][m]<<endl;//输出一 1 为根，选了 m 条边的树 
}
```



---

## 作者：Twilight_ (赞：46)

主要思路：树形dp+背包。在“二叉xx树”+“保留q根树枝”的条件下这个思路应该很容易形成。


那么状态转移方程：dp[i][j]=max(dp[i][j],dp[v][k]+dp[i][j-k]);

解释：dp[i][j]表示选择了i号点后保留i下方的j-1（j包含了i号节点上方的那一条边--为什么？若要选择保留i节点与i节点以下的树枝，显然必须保留i点上方与根节点相连的树枝）根树枝所能保留的最大苹果树。


顺便提一句没有人觉得这道题和2014选课有异曲同工之妙吗？欢迎同步食用：https://www.luogu.org/problemnew/show/2014

自认为代码简洁清晰，其他细节详见代码~


```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 200
int n,q,cnp=1,cnt=1,head[maxn],dp[maxn][maxn];
struct xxx
{
    int to,last,co,u;
}T[maxn];
int read()
{
    int x=0,k=1;
    char c;
    c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x*k;
}
void init()
{
    for(int i=1;i<=n;i++)head[i]=-1;
}
void addT(int u,int v,int w)
{
    T[cnp].to=v;
    T[cnp].last=head[u];
    T[cnp].u=u;
    T[cnp].co=w;
    head[u]=cnp++;
}
void work(int u,int fa)
{
    for(int i=head[u];i!=-1;i=T[i].last)
    {
         int v=T[i].to;
         if(v==fa)continue;
         dp[v][1]=T[i].co;
        work(v,u);
        for(int j=q;j>=1;j--)
            for(int k=0;k<=j;k++)
                if((k!=j&&j!=1)||u==1)dp[u][j]=max(dp[u][j],dp[v][k]+dp[u][j-k]);//一个对1号节点的特判：只有1号节点不存在在它上方的边
     }
}
int main()
{
    n=read(),q=read();
    init();
    for(int i=1;i<n;i++)
    {
        int x=read(),y=read(),z=read();
        addT(x,y,z);
        addT(y,x,z);
    }
    work(1,0);
    printf("%d",dp[1][q]);
    return 0;
}
```

---

## 作者：Kirisame_Marisa_ (赞：38)

应该算是树形dp的入门题了吧...

上课的时候直接把代码抄下来改了改名字，回家又乱搞半天终于理解这种做法。

树形dp，就是在（二叉）树上~~搞~~做dp。

因为这题保证输入为二叉树（这种做法好像n叉数也可以），所以会方便一些。

我们定义dp[i][j]为保留了i号节点和j条边时最大保留apple数。

为了给大家~~提神醒脑~~巩固基础，我们重复一下以上定义。



#### 我们定义dp[i][j]为保留了i号节点和j条边时最大保留apple数。

（划重点！~~做笔记！~~）

可得dp[1][m]即为答案。

转移方程...不太好想。当时课上完全是懵逼的状态。



枚举子节点nxt，计算这个节点为根的子树的边的个数d

设当前节点为now，已经枚举到了节点nxt，共统计了sum条边，那么转移方程：

dp[now][j]=max(dp[now][j],dp[now][j-k]+dp[nxt][k-1]+w[now][nxt])

(1<=j<=min(d,m),1<=k<=min(d,j),w[now][nxt]代表节点i到j的边的权值)



接下来我们来解释这个方程。

首先，去max是必然。

dp[now][j-k]，为什么是j-k呢？

因为我们枚举了子树的边数k，总边数j。

既然我们的子树已经占去了k条边，留给剩余边的数量自然只剩j-k条了。



接下来是这个dp[nxt][k-1]，为什么是k-1？

这里我们应该将k具体定义一下。

j定义为：目前节点now保留的边数，是没问题的。

k要怎么定义呢？

想一想：



k：nxt节点为根的子树保留的边数再+1(nxt到now这条边)

因为我们的nxt节点的子树的边数只有k-1条，所以dp数组的第二维就是[k-1]



最后，为什么要加上w[now][nxt]?

我们来看一下，dp[now][j-k]中有j-k条边，dp[nxt][k-1]有k-1条边。

两数相加，我们有j-1条边。为什么还差一条边？

就是now~nxt这条边。

那为什么不直接用dp[now][j-k]+dp[nxt][k]?

因为nxt子树并没有k条边......



至此，我们完成了这个dp方程的解析。

（建树方式？你要用邻接矩阵都行啊。）

main code：


```cpp
    int dfs(int now,int fa)
    {
        int d=0;
        for(int i=head[now];i;i=e[i].l)
        {
            int nxt=e[i].t,ow=e[i].v;//nxt为下一个枚举的子树，ow为当前节点与nxt的边的权值
            if(nxt==fa)continue;//如果找到父节点则跳过
            d+=dfs(nxt,now)+1;//计算以now为根的树有几条边
            for(int j=min(d,m);j;--j)//当前节点留j条边
                for(int k=min(d,j);k;--k)//当前子树留k-1条边，加上两点所连的一边
                    dp[now][j]=max(dp[now][j],dp[now][j-k]+dp[nxt][k-1]+ow);
            //子树留k-1条边，当前节点还能再留j-k条边，还有当前节点与枚举的节点边的权值
        }
        return d;
}
```

# #UPD1 (2019/3/16)  
现在重新复习树dp发现打错了。。。  
```dp[i][j]```代表的就是以$i$为根节点的子树中，保留$j$条边的答案  
转移方程为```dp[i][j]=max{dp[son][k]+dp[i][siz-k-1]+v[k][son]}```   
```son为i的子节点,siz为 以i为根的子树所包含的边数```  
```0<=k<siz```

---

## 作者：ShineEternal (赞：34)


$f[i][j]$ 表⽰以i节点为根，保留j个树枝最多留下
多少个苹果。
只给左⼉⼦：$f[i][j]=f[lson[i]][j-1]+vlson[i]$
只给右⼉⼦：$f[i][j]=f[rson[i]][j-1]+vrson[i]$
都分⼀点：$f[i][j]=max(f[lson[i]][k]+f[rson[i]][j-k-2]+vlson[i],vrson[i]). 0<=k<=j-2$.


code及注释在[这里](https://blog.csdn.net/kkkksc03/article/details/83018645)

---

## 作者：中二病 (赞：13)

最近树上分组背包也做了好几道了，发个博客记录一下。  
这是一道很典型的树上分组背包模板，但也有一些特别，因为他的权值不是在点上，而是在边上。  
所以就用f[i][j]来表示以i为根节点，拓展j条边所能取到的最多的苹果数，可以推出dp方程dp[u][j]=max(dp[u][j],dp[u][j-k-1]+dp[v][k]+W)，其中v是u的子节点，W是边u->v上的苹果树。  
先用一遍dfs求出每个点下的边数
```
int dfs(int u,int fa)
{
    int v;
    for(int i=0;i<edge[u].size();i++)
    {
        v=edge[u][i];
        if(v!=fa)
        {
            sum[u]+=dfs(v,u);
        }
    }
    if(!sum[u])return 1;
    else return sum[u]+1;
}
```
然后就是树上分组背包的主要思想，通过01背包用子节点来更新父节点的dp值,y=用滚动数组压掉一维
```
for(int j=q;j>=1;j--)
{
   for(int k=0;k<j&&k<=sum[u];k++)
   {
      dp[u][j]=max(dp[u][j],dp[u][j-k-1]+dp[v][k]+W);
   }
}
```
要注意因为父节点到子节点还要一条边，所以是dp[u][j-k-1]  
贴上完整代码```

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
vector <int> edge[110];
vector <int> w[110];
int n,q,dp[110][110],sum[110];
int dfs(int u,int fa)
{
    int v;
    for(int i=0;i<edge[u].size();i++)
    {
        v=edge[u][i];
        if(v!=fa)
        {
            sum[u]+=dfs(v,u);
        }
    }
    if(!sum[u])return 1;
    else return sum[u]+1;
}
bool solve(int u,int fa)
{
    int v,W;
    bool bo;
    for(int i=0;i<edge[u].size();i++)
    {
        v=edge[u][i];
        W=w[u][i];
        if(v!=fa)
        {
            bo=1;
            solve(v,u);
            //dp[v][1]=max(dp[v][1],W);
            //for(int j=sum[u];j>=1;j--)
            //dp[u][j]=max(dp[u][j],dp[u][j-1]+W);
            for(int j=q;j>=1;j--)
            {
                for(int k=0;k<j&&k<=sum[u];k++)
                {
                    dp[u][j]=max(dp[u][j],dp[u][j-k-1]+dp[v][k]+W);
                }
            }
        }
    }
    return bo;
}
int main()
{
    cin>>n>>q;
    int x,y,z;
    for(int i=1;i<n;i++)
    {
        cin>>x>>y>>z;
        edge[x].push_back(y);
        w[x].push_back(z);
        edge[y].push_back(x);
        w[y].push_back(z);
    }
    dfs(1,1);
    solve(1,1);
    int ans=0;
    //for(int i=1;i<=n;i++)
    //ans=max(ans,dp[i][q]);
    cout<<dp[1][q];
    return 0;
}
```




---

## 作者：离陌´¢笙歌ღ (赞：11)

## 昨天jr我翻了6页题解
## 也没有看到后序遍历写的树形依赖背包
### ~~今天我就来水一篇题解~~



------------


我们考虑树形dp的后序遍历优化

后序遍历中编号由小到大依次是左子树，右子树，根

同一棵树一定保证根节点是这棵树最后的编号

我们设dfn[cnt]=x数组表示后序遍历的第cnt个编号是节点x

size[x]表示x节点的子树大小

val[x]表示节点x的数值（预处理遍历树时把边权转化为点权，把题意保留q个树枝转变为保留q+1个节点）

dp[i][j] 表示当前dp到的后序遍历编号为i，保留j个节点（代码中当作节点 处理）时，所剩苹果的最大值

当选取节点dfn[i]时，dp[i]显然可以从dp[i-1]转移而来

可得方程dp[i][j]=max(dp[i-size[dfn[i]]][j]，dp[i-1][j-1]+val[dfn[i]]);

当不选取节点dfn[i]时，代表整个子树都不选，直接从dp[i-size[dfn[i]]]复制过来

可得方程dp[i][j]=max(dp[i][j]，dp[i-size[dfn[i]]][j]);

~~这只是个普遍的转移方法，而此题过水看下面代码好了~~

放代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 255 ;
struct Tree {
    int nxt,to,dist;
}e[N];
int	head[N],tot=0;
inline void add(int from,int to,int dist) {
    e[++tot].to=to; e[tot].dist=dist;
    e[tot].nxt=head[from]; head[from]=tot;
}
int dp[N][N],val[N],size[N],dfn[N];
int n,q,cnt=0;
void dfs(int x,int fa) {
    size[x]=1;
    for(int i=head[x];i;i=e[i].nxt) {
        int y=e[i].to;
        if(y==fa) continue ;
        val[y]=e[i].dist;//把边权的转化为点权，便于dp
        dfs(y,x);
        size[x]+=size[y];
    }
    dfn[++cnt]=x;//后序遍历（左子树->右子树->根）应该都能看懂qwq
}
int main() {
    scanf("%d%d",&n,&q);
    for(int i=1;i<n;++i) {
        int x,y,d;
        scanf("%d%d%d",&x,&y,&d);
        add(x,y,d); add(y,x,d);//树是要加双向边的
    }
    q++; //保留q个枝条=保留q+1个节点（包括了根节点）
    val[1]=0;  dfs(1,0); 
    for(int i=1;i<=cnt;++i) 
        for(int S=q;S>=0;S--) {
            if(S>=1) 
                dp[i][S]=max(dp[i-size[dfn[i]]][S],dp[i-1][S-1]+val[dfn[i]]);
            //考虑dfn[i]选还是不选
            else dp[i][S]=max(dp[i][S],dp[i-size[dfn[i]]][S]);//不选dfn[i]就直接从上一棵树的状态转来
        }
        printf("%d",dp[cnt][q]);
    return 0;
}
```
其实我原代码写麻烦了，大家自己体会，这道题其实dp方程这样写就可以了，但是其他题就不一定了，因为在其他题目中每个节点的体积可能不定，所以必须判断

```cpp
for(int i=1;i<=cnt;++i) 
        for(int S=q;S>=1;S--) 
            dp[i][S]=max(dp[i-size[dfn[i]]][S],dp[i-1][S-1]+val[dfn[i]]);
```


---

## 作者：TheAutumnGlory (赞：8)

### 今天讲了树形dp，正好在luogu上看到这道题，仔细一看，~~这不是板题吗~~（滑稽）。

**咳咳，强行切入正题**

首先，我们根据样例画出一张无比丑陋的图：
![](https://s2.ax1x.com/2019/08/24/msIzmq.png)

**现在我们减去1的右枝就得到了下面这张图：**
![](https://s2.ax1x.com/2019/08/24/msoIgJ.png)

**如果减去1的左枝：**
![](https://s2.ax1x.com/2019/08/24/msozgH.png)

**如果保留1的左右枝，左子树保留$x$条，右子树保留$y$条，使得$x+y+2=M$**
![](https://s2.ax1x.com/2019/08/24/msTRsA.png)

**由此可以推出：对于任意子树，若要保留其$M$条枝，均可按减掉左枝，减掉右枝（剪后判断剩下的枝数是否等于$M$）和将左右子树分为两部分（即上图红色区域），分别保留$X$和$Y$条边，使得$X+Y+2=M$
来进行讨论。**

## 既然是树形dp，那就按dp的套路来分析：

首先一遍dfs建好二叉树

阶段：依次讨论以每个节点为根的子树

状态：设f[x][y]表示以x为根的子树共保留y条树枝的最大苹果数

决策：剪掉x的左枝，还是剪掉右枝，还是保留左右枝。
```
方程：f[x][y]=max{
	            f[left[x]][y-1]+a[x][left[x]]//剪右枝
                    f[right[x]][y-1]+a[x][right[x]]//剪左枝
                    f[left[x]][k]+f[right[x]][y-2-k]+a[x][left[x]]+a[x][right[x]]//都不剪
		}
 ```
边界条件：1$\leq$x$\leq$n 1$\leq$y$\leq$m 0$\leq$k$\leq$y-2

时间复杂度：O(n$m^2$）

### 但是上面方程太复杂，~~懒的写~~，所以我们换一种解决方法： 

## $<center>边权下放点权$

![](https://s2.ax1x.com/2019/08/24/msbDI0.png)


**状态**：设$f[x][y]$表示以$x$为根的子树共保留$y$个节点的最大苹果数

**决策**：$x$的左右两棵子树分别保留多少个节点

**方程**：$f[x][y]= max${ $f[left[x]][k]+f[right[x]][y-1-k]+v[x]$ }
$(0\leq$$k<y)$

**$f[left[x]][k]$表示$x$的左子树保留$k$个节点的最优值**

**$f[right[x]][y-1-k]$表示$x$的右子树保留$y-1-k$个节点的最优值**
       
**最后答案为**:$f[1][m+1]$

**然后其余部分同上**

```
#include<bits/stdc++.h>
using namespace std;
int n,q,f[105][105];
int Last[105],End[205],Next[205],len[205],tot;
bool vis[105];
struct node{
	int l,r;
}tree[105];
void cb(int x,int y,int k){链式前向星
	End[++tot]=y;
	Next[tot]=Last[x];
	len[tot]=k;
	Last[x]=tot;
}
void dfs(int x){深搜建树
	vis[x]=true;标记为已经搜过
	for(int i=Last[x];i;i=Next[i]){
		int y=End[i];
		if(!vis[y]){
			if(!tree[x].l)记录儿子节点
				tree[x].l=y;
			else
				tree[x].r=y;
			f[y][1]=len[i];
			dfs(y);
		}
	}
}
int tree_dp(int x,int y){
	if(f[x][y])记忆化搜索
		return f[x][y];
	if(x==0)
		return 0;
	int maxn=0;
	for(int k=0;k<y;k++){
		int orz=tree_dp(tree[x].l,k);
		int sto=tree_dp(tree[x].r,y-k-1);
		maxn=max(maxn,orz+sto+f[x][1]);
	}
	f[x][y]=maxn;
	return f[x][y];
}
int main(){
	scanf("%d %d",&n,&q);
	for(int i=1;i<n;i++){
		int x,y,k;
		scanf("%d %d %d",&x,&y,&k);
		cb(x,y,k);
		cb(y,x,k);
	}
	dfs(1);
	printf("%d",tree_dp(1,q+1));因为是边权下放点权，所以是q+1
	return 0;
}
```

# $<center> 树形dp 小结$
  
## 树形动态规划就是在“树”的数据结构上的动态规划
  
**阶段：以每节点所代表的子树作为一个阶段。**
  
**状态：以每棵子树的最优值作为状态**
  
**决策：当前节点的最优值由其子节点代表的子树的最优值选择而来**
  
**实现：递归程序实现DP（记忆化搜索）**
  
  ## $<center> 谢谢观看$

---

## 作者：AnChun999 (赞：7)

这道题目很**神奇**

下面的代码样例过不了不是很懂（但是可以过），路过大佬帮我看看。

一眼看出树形dp

先建树

再深搜

f[i][j] i是当前节点，j是还剩多少需要留的枝干

把树枝上的苹果放在节点上。

状态转移方程半分钟想出

**f[i][j]=max(f[i][j],f[tree[i].l][k]+f[tree[i].r][j-k-1]+tree[i].v);**

**K=0~j-1**

代码在下面，大家自己看吧。


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
int N,Q,x,y,z,father[150][3],pingguo[150],f[150][150];
int dfs(int root,int j)//root为当前节点，j为余下的枝干 
{
    if(j==0)f[root][j]=0;//判断枝干是否用完 
    else
    if(father[root][0]==0)//判断是否为叶节点 
    f[root][j]=pingguo[root];//是就收苹果 
    else
    for(int i=0;i<j;i++)
    {
            if(f[father[root][1]][i]==0)//判断左子树有没有值 
            dfs(father[root][1],i);
            if(f[father[root][2]][j-i-1]==0)//判断右字数有没有值 
            dfs(father[root][2],j-i-1);
            f[root][j]=max(f[root][j],f[father[root][1]][i]+f[father[root][2]][j-i-1]+pingguo[root]);//这个耐心点看吧，我就不bb了 
    }
}
int main()
{
    scanf("%d%d",&N,&Q);
    for(int i=1;i<=N-1;i++)
    {
        scanf("%d%d%d",&x,&y,&z); 
        father[x][0]++;//0列存有几个子节点 
        father[x][father[x][0]]=y;//根据有几个子节点存子节点编号 
        pingguo[y]=z;//存苹果在子节点上 
    }
    dfs(1,Q+1);//Q+1很精髓 
    printf("%d",f[1][Q+1]);
    return 0;
}
```

---

## 作者：Priori_Incantatem (赞：6)

对于一个树枝，我们考虑取或不取

对于一个被取了的树枝，要想获得他的苹果，就要保证该边到跟的路径上没有树枝被剪掉  
我们考虑 $f[x][i]$ 为以节点 $x$ 为根的子树，保留 $i$ 根树枝后能获得的最大苹果数

对于每一个 dfs 到的 $x$，我们枚举 $i,j$，它们分别为 以$x$为根的子树保留的边数，和左儿子为根的子树保留的边数。则，以右儿子为根的子树保留的边数就是 $i-j$

但是，为了能保留住左右子树中的苹果，根一定还要向左右儿子连边，所以左右子树**内部**还能用的边就是有$j-1$ 和 $i-j-1$了

这样，转移方程就出来了：
$f[x][i]=max(f[lc][j-1]+w(x,lc)+f[rc][i-j-1]+w(x,lc))$  
其中 $lc,rc$ 分别为 $x$ 的左右儿子，$w(x,y)$ 为连接点 $x,y$ 的边上的苹果

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
using namespace std;
const int Maxn=110,inf=0x3f3f3f3f;
struct edge{
	int v,len;
};
int n,m;
vector <edge> e[Maxn];
int f[Maxn][Maxn];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void dfs(int x,int fa)
{
	int lc=0,rc; // 左右儿子
	int v1,v2; // 连向左右儿子的边权
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i].v;
		if(y==fa)continue;
		if(lc)rc=y,v2=e[x][i].len;
		else lc=y,v1=e[x][i].len;
		dfs(y,x);
	}
	if(!lc)return; // 如果是叶子节点，直接退出
	for(int i=1;i<=m;++i)
	{
		for(int j=0;j<=i;++j)
		{
			int tmp=0; // 储存是否有向左右儿子连边
			if(j>=1)tmp+=v1; //如果有给左右儿子分配边，肯定要优先将根与左右儿子连起来
			if(i-j>=1)tmp+=v2; // 与上同理
			
			f[x][i]=max(f[x][i],f[lc][j-1]+f[rc][i-j-1]+tmp);
		}
	}
}
int main()
{
//	freopen("in.txt","r",stdin);
	n=read(),m=read();
	for(int i=1;i<n;++i)
	{
		int x=read(),y=read(),c=read();
		e[x].push_back(edge{y,c});
		e[y].push_back(edge{x,c});
	}
	dfs(1,0);
	
	printf("%d\n",f[1][m]);
	
	return 0;
}
```

**有不懂的地方可以私信我，我经常在线**

---

## 作者：0104154308_f (赞：6)

~~我好难啊~~

##### 蒟蒻之解巨佬请略
树状dp本质：

（树状dp主要是背包问题这里用背包问题进行简述）

1.通常而言在写动规的时候尤其是背包我们发自内心的无意识的认为这是线性的而往往dp就是建立在线性的基础上存在的

2.树状dp就是将一个线性的dp的操作顺序进行了改编往往改变成为了一个顺序构成树的样子

总结：树状dp就是将普通dp的操作顺序改变形成的本身一般不具有特殊的性质

#### 题解思路：
按上文所述从根节点开始深搜的遍历到每一个节点以其本身作为一个子树的根节点得出该点付出代价为（0-min(q,tree[i].size))的情况下获得的最大价值很典型的背包问题


转移方程

dp[u][j]=max(dp[u][j],dp[u][j-k-1]+dp[v][k]+e[u][i].w);

###### code：
```
#include<stdio.h>
#include<vector>
#include<algorithm>
using namespace std;
int n,q,dp[110][110],cnt[110]={};
struct edge
{
	int w,e;
}t;
vector<edge>e[220];
void dfs(int u,int p)
{
	for(int i=0;i<e[u].size();i++)
	{
		int v=e[u][i].e;
		if(v==p)
		continue;
		dfs(v,u);
        //不断遍历到无法继续当前节点为第一个叶子节点开始返回
		cnt[u]+=cnt[v]+1;
        //cnt为以该点为根节点的子树大小
        //普通背包
		for(int j=min(cnt[u],q);j;j--)
		{
			for(int k=min(j-1,cnt[v]);k>=0;k--)
			{
				dp[u][j]=max(dp[u][j],dp[u][j-k-1]+dp[v][k]+e[u][i].w);
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++)
	{
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		t.e=y,t.w=w;
		e[x].push_back(t);
		t.e=x;
		e[y].push_back(t);
        //加边
	}
	dfs(1,0);
	printf("%d",dp[1][q]);
	return 0;
 } 
```
rp++


巨佬与学习党可撤离


~~书接上文~~
我好难啊才上高一

被教练第一节课叫去说

让我给各位巨佬讲讲树状dp

看看我的能力我好难啊

---

## 作者：llldx03 (赞：6)

一道比较不错的**树形dp**题，拿来给新手练习是最好不过的。

进入正题，这道题的要求就是让我们对树进行删边，在保证整棵树联通的情况下把树的边删到目标数。

回忆一下树的特点，一棵树是由n个点和(n-1)条边构成的，题目中让我们保留q条边，实际上就是让我们保留(q+1)个点，并保证这些点是连通的，所以我们做的时候就直接把边权转到点权上，然后开始删点，最后算保留的点的点权之和就好了！

很显然，这道题是根的子结点传递信息给根节点，之后由根得出最优解，那么递归方向就是：**叶→根**

对于每个非叶结点i，若要求以i为根的子树保留j个结点，实际上就是i的左子树和右子树总共保留(j-1)个结点，可能是左子树不保留结点，右子树保留(j-1)个结点，也有可能是左子树保留1个结点，右子树保留(j-2)个结点……，是不是看到这里自己就想出状态转移方程了？

f[i][j]表示**以i为根的树上保留j个结点的最大权值和**,ch[i][0]表示i的左儿子，ch[i][1]表示i的右儿子，a[i]表示i的点权，则状态转移方程为：

f[i][j]=max(f[i][j],f[ch[i][0]][k]+f[ch[i][1]][j-k-1]+a[i])(k∈[0,j-1])

那么我这里是使用的记忆化搜索，详细内容请看代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,q,head[110],cnt,f[110][110],tot[110],a[110],ch[110][3];
struct node
{
	int nxt,v,dis;
}e[500];
void add(int u,int v,int dis)
{
	e[++cnt].nxt=head[u];
	e[cnt].v=v;
	e[cnt].dis=dis;
	head[u]=cnt;
}
void build(int u,int fa)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa)continue;//因为是无向图，防止从儿子又遍历回父亲 
		ch[u][tot[u]++]=v;//存儿子 
		a[v]=e[i].dis;//边权转点权 
		build(v,u);//递归建树 
	}
}
int mdfs(int i,int j)
{
	if(j==0)return 0;//假设要保留0个结点，那么肯定就是权值和为0啦 
	if(ch[i][0]==0&&ch[i][1]==0)return a[i];//如果这是叶子结点，那么直接返回叶子结点的权值就ok 
	if(f[i][j])return f[i][j];//记忆化搜索，说明f[i][j]已被计算过 
	for(int k=0;k<j;k++)
		f[i][j]=max(f[i][j],mdfs(ch[i][0],k)+mdfs(ch[i][1],j-k-1)+a[i]);//状态转移方程 
	return f[i][j];
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);//要注意无向图要add两次
	}//这里是简单的邻接表存图 
	build(1,0);//这里就是开始建二叉树了 
	printf("%d\n",mdfs(1,q+1));//记忆化搜索 
	return 0;
}
```
如果看懂了别忘了给本蒟蒻点个赞~，看不懂或题解有啥问题也可以私信联系我~

---

## 作者：Jianuo_Zhu (赞：6)

这题是个经典的树形DP，我们用$f[i][j]$表示在第i个点后面选j条边能取得的最大价值。

则有

### $f[i][j] = max(f[i][j], f[i][j-k-1] + f[v][k] + w[edge])$
(v为i的子节点,w[edge]为i到v这条边上的苹果。注意到选了v就必须选u->i这这条边，所以是f[i][j-k-1])

## 但是，这都不是我要讲的重点

如果你直接按照这个思路DP是23分的，为什么呢？~~因为我太弱了~~ 翻了翻题解都没有将这个问题的。那就是要倒序枚举j和k。

为什么呢？假设你先用dp[2][3]把dp[1][3]求出来了，这时你求到了dp[1][6]，你发现他可以从dp[v][3]转移过来，于是你愉快的这么做了。但就是这里出了问题。你前面已经用过一次这三条边了，转移不就是相当于再把这三条边用一遍吗？这就变成了完全背包了。而如果你用倒序则就没有这些问题了。因为当你求dp[1][6]时那三条边还没有被使用过，dp[1][3]要么还没有求要么就是其他的v转移过来的。

说直接点就是顺序枚举是完全背包，倒序枚举是01背包。

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
const int maxn = 1001;
using namespace std;
struct edge{
    int v, w, nxt;
}e[maxn];
int n, q, cnt, h[maxn], siz[maxn], f[maxn][maxn];
void add(int u, int v, int w){
    e[++cnt].v = v; e[cnt].w = w;
    e[cnt].nxt = h[u]; h[u] = cnt;
}
void DFS(int x, int fa){
    for(int i=h[x]; i; i=e[i].nxt){
        int v = e[i].v;
        if(v == fa) continue;
        DFS(v, x); siz[x] += (siz[v]+1);
        for(int j=siz[x]; j>=0; j--){
            for(int k=min(siz[v], j-1); k>=0; k--){
                f[x][j] = max(f[x][j], f[x][j-k-1] + f[v][k] + e[i].w);
            }
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin >> n >> q;
    int x, y, w;
    for(int i=1; i<n; i++){
        cin >> x >> y >> w;
        add(x, y, w); add(y, x, w);
    }
    DFS(1, 0);
    cout << f[1][q];
}
//f[u][j] = max(f[u][j], f[u][j-k-1] + f[v][k] + e[i].w)
```

---

## 作者：jins3599 (赞：5)

蒟蒻写的第一个树上dp+背包。

其实这道题思路还是很明确的，我们设计方程如下：

`f[i][j][k]`代表以`i`为根的子树，已经考虑了前`j`个结点，选择了`k`条边时候的最大价值。

转移方程其实就比较显然了，我们对左右子树分别进行转移。

`f[i][j][k] = max(f[i][j][k] , f[i][j - 1][k - l - 1] + f[son][son的大小][l] + e[i].w);`

为什么是`k - l - 1`？

这个其实是比较显然的，我们从当前节点到子树的那条边是不可以去掉的，不然的话他的子树就被切断了，也就无法转移过来了。

我们直接对这个三维的方程进行转移，或许能AC。（我没试过）

我们再仔细看看这个方程，有点类似于背包的转移？那是否可以用背包的思想来优化它呢？

我们考虑我们每次对`f[i][j][k]`进行转移时，是要用到上一层的`f[i][j-1][k]`的数据的。

那么我们可以对`k`进行倒序枚举，类似于01背包，这样的话就可以把中间的$j$给搞下去了。

因此我们的转移方程发生了变化：

`f[i][k] = max(f[i][k] , f[i][k - l - 1] + f[son][l] + e[i].w);`

倒序枚举$k$，$l$~~随意~~枚举即可.
//其实代码中k对应的是j，l对应的是k。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 500;

struct Edge {
	int to , nxt , w;
}e[N];

int head[N] , cnt , n , q , root = 1 , ind[N] , out[N];

void add(int u , int v , int w) {
	e[++cnt].w = w;
	e[cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

int a[N] , size[N] , f[N][N];
void dfs1(int now , int fa) {
	size[now] = 1;
	for(int i = head[now] ; i ; i = e[i].nxt) {
		int v = e[i].to , w = e[i].w;
		if(v == fa) continue;
		a[v] = w;
		dfs1(v , now);
		size[now] += size[v];
	}
}

void dfs2(int now , int fa) {
	for(int i = head[now] ; i ; i = e[i].nxt) {
		int v = e[i].to;
		if(v == fa) continue;
		dfs2(v , now);
		for(int j = size[now] ; j >= 1 ; j --) {
			for(int k = 0 ; k <= min(j - 1, size[v]) ; k ++) {
				f[now][j] = max(f[now][j] , f[now][j - k - 1] + f[v][k] + e[i].w);
			}
		}
	}
}

int main () {
	scanf("%d %d" , &n , &q); 
	for(int i = 1 ; i < n ; ++ i) {
		int u , v , w;
		scanf("%d %d %d" , &u , &v , &w);
		add(u , v , w); add(v , u , w);
	}
	dfs1(root , root);
	dfs2(root , root);
	printf("%d" , f[root][q]);
	return 0;
}
```




---

## 作者：这谁顶得住啊 (赞：5)

树形DP的入门题+树形01背包

接下来是正文
------------
还是DP，只不过到树上去了

所以我们要去寻找的仍是状态和状态转移方程

以本题为例，我们要求的是，从根节点出发，保留q条边，使得可以取得的边权值最大

这题一看就不能直接从根节点暴力dfs啊，100%TLE

所以我们会想到DP

但是怎么DP呢？

------------
DP之本：找状态

从根节点开始很难，所以考虑从子树推到根节点

初步得出：$dp[u]$表示以u为根节点时能得到的最大的边权值


------------
但是很明显这点根本不够，不还有一个限制条件吗?

那就是当前该点已经使用的边数

 **所以我们找到了状态的第二维:当前根节点已经包含的所有边数$j$**

**最终得出本题的状态$dp[u][j]$**


------------
接下来是状态转移方程的寻找


------------
对于每一条边，只能取一次，取后会对总的结果造成影响，是不是感觉挺熟悉，是的，**01背包！**~~学到这了不会01背包都不知道是啥吧~~(如果01背包现在还不会，请出门[右转](https://www.cnblogs.com/zyacmer/p/9961710.html))


------------
到了这里，你是不是对AC这题已经有了信心？


------------
最后，贴出状态转移方程以及解释：
**$dp[u][j]=max(dp[u][j],dp[u][j-1-k]+dp[v[i]][k]+w[i])$**
**$dp[u][j]$：根节点为u时，取j条边所能得到的最大边权值**
**$0<j<=min$($q$,$u$这点所有的边的总数)**
**$0<=k<=min$(与$u$相连的该点所有的边的总数，$j-1$)**\
**$i$为当前已经枚举到哪条边(邻接表建边)**


------------
### 细节方面：
1.本题求解答案需要用到边权值，应用邻接表建图

2.状态转移方程里用$j-1-k$而不是$j-k$是因为：子树和该根节点之间必须有边相连(本题的隐藏条件)，$k$的范围为$0$~$j-1$同理(~~毕竟这是树好吧~~)

**3.一定要双向建边，这是一棵树，应该父节点子节点都是互相可达的(~~又不是图论题~~)**

4.边界条件：这个就与上面的双向建边有关了,**如果该节点的下一个节点是它的父亲**，那么说明这里已经是子节点，不能继续往下递推（儿子不能回推父亲，否则会**死循环**）（continue的原因也是双向建边，该节点可能还有孩子，但如果与它相连的第一条边连接的节点却是它的父亲节点，就不能递推，所以continue掉**这一条边**）（至于$i!=-1$就不解释了，邻接表基础）


------------
## 最后，上代码(代码里还会有一些解释)
```cpp
#include<bits/stdc++.h>
using namespace std;
int fir[2000],nxt[2000],v[2000],w[2000],tot;
void add(int a,int b,int c){//邻接表建图
	tot++;
	nxt[tot]=fir[a];
	fir[a]=tot;
	v[tot]=b;
	w[tot]=c;
}
int n,q,bian[2000],dp[200][2000];//bian数组指的是在bian[i](第i个节点)包含所有子树共连接了多少条边
void dp1(int u,int father){//father指的是u由哪个节点递推而来
	for(int i=fir[u];i!=-1;i=nxt[i]){//邻接表基础：枚举与u相连的边i
		if(v[i]==father) continue;//子节点不能递推到父亲节点
		dp1(v[i],u);//继续递归
		bian[u]+=bian[v[i]]+1;//v[i]为u的一个子节点，它们之间至少要有一条边相连，u可能不止v[i]这一个子节点，所以应该用++
		for(int j=min(bian[u],q);j>0;j--){//j为目前u用了几条边，j既不能超过要取的边的总数，也不能超过u所有的边的总数
			for(int k=min(bian[v[i]],j-1);k>=0;k--){//u和v[i]之间至少要有一条边用于连接
				dp[u][j]=max(dp[u][j],dp[u][j-1-k]+dp[v[i]][k]+w[i]);//w[i]：u和v[i]之间连接的边的边权
			}
		}
	}
}
int main(){
	memset(fir,-1,sizeof(fir));
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);//双向建边
		add(b,a,c);
	}
	dp1(1,-1);//father一开始为-1的原因：1是根节点，不可能有父亲，该题中无负数节点，故取-1
	printf("%d",dp[1][q]);//q为应取多少条边
	return 0;
}
```
### 完结撒花花^-^

---

## 作者：最喜欢saber了 (赞：4)

[题目传送门](https://www.luogu.org/problemnew/show/P2015)

这道题是一道树形DP类型的题(来自蓝书)，我来苟一个蓝书上的做法。

由题可知，需要保留的树枝数量为 $Q$ 条，即保留$j=Q+1$个。树根必须保留。

所以可以分三种情况来讨论保留苹果的最大数量。

1. 树根的左子树为空，全保留右子树，右子树中保留$j-1$个结点。
2. 树根的右子树为空，全保留左子树，左子树中保留$j-1$个结点。
3. 树根的两棵子树都为非空，设左子树保留$k$个结点，则右子树保留$j-k-1$个结点。

 
要得到保留树根时的苹果最大数量，只需要求上述三个方案的最大值。

设树根为$i$，左儿子为$l_{i}$，右儿子为$r_{i}$，对于 $ 1 $ 方案，若要取得该方案的最大值，则需取得以$r_{i}$为根的子树保留$j-1$个结点的最大值。

这时，同样具有上述三种方案。$2$ 和 $3$ 方案同理。由此可以看出，该问题具有明显的最优子结构性质，每个问题都与左右儿子结点有关系，但不与孙子结点发生关系，具备无后效性；且计算方案时，搜索子结构时具备重叠性，所以可以用DP解决。

下面开始搞事：

阶段和状态：$f_{i,j}$ ：表示以 $i $ 为根的树上保留 $j$ 个结点的最大权值和。设$l_{i} $ ，$r_{i}$分别存储$i$结点的左右儿子。

状态转移方程：

$f_{i,j} = max(f_{l_{i},k}+f_{r_{i},j-k-1}+a_{i})$ $(0<=k<=j-1)$。

初始化：$f_{i,j}=0 $  $(j=0)$；
        $f_{i,j}=a_{i}$    ($j!=0$ 且  $l_{i}=0$ 且 $r_{i}=0$).
 
Ans $ = $ $f_{1,Q+1}$。

下面献上代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxa = 105;
int n,q,i,j;
int l[maxa],r[maxa],f[maxa][maxa]={0},map[maxa][maxa],a[maxa];
void maketree(int v){
	for(int i=1;i<=n;i++)
	if(map[v][i]>=0){
		l[v]=i;
		a[i]=map[v][i];
		map[v][i]=map[i][v]=-1;
		maketree(i);
		break;
	}
	for(int i=1;i<=n;i++)
	if(map[v][i]>=0){
		r[v]=i;
		a[i]=map[v][i];
		map[v][i]=map[i][v]=-1;
		maketree(i);
		break;
	}
}
int dp(int i,int j){
	if(j==0)return 0;
	if((l[i]==0)&&(r[i]==0))return a[i];
	if(f[i][j]>0)return f[i][j];
	for(int k=0;k<=j-1;k++)
	f[i][j]=max(f[i][j],dp(l[i],k)+dp(r[i],j-k-1)+a[i]);
	return f[i][j];
}
int main(){
	int x,y,z;
	scanf("%d%d",&n,&q);
	q++;
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)map[i][j]=-1;
	for(i=1;i<=n-1;i++){
		scanf("%d%d%d",&x,&y,&z);
		map[x][y]=map[y][x]=z;
	}
	maketree(1);
	printf("%d\n",dp(1,q));
	return 0;
}
```

逃.........

---

## 作者：the_same_prayers (赞：2)

# 分析（主要存在三个问题）：
## 1.首先输入的时候没有标明谁是父节点，谁是子节点；
 如何解决？首先我们知道一个节点只有一个父节点，那么如果第二次输入同一个节点的父亲，就交换父子关系：
```cpp
		int baba,erzi,k;
		cin>>baba>>erzi>>k;
		if(father[erzi])
		{
			int t=baba;
			baba=erzi;
			erzi=t;
		}
```
## 2.如何转化二叉树（关键）
 此二叉树非彼二叉树————我们应该将它转化为“左儿子，右兄弟”的二叉树（为什么？因为不转化难以访问兄弟节点；转化后方便很多，便于枚举情况，详见3）
```cpp
		if(last[baba]==0) l[baba]=erzi;
		else r[last[baba]]=erzi;
		last[baba]=erzi;
```
## 3.最后，作为树形dp，dp当然最核心啦
#### 状态转移方程如下*：
```cpp
	for(int i=0;i<b;i++)
	{
		f[a][b]=max(f[a][b],work(l[a],i)+work(r[a],b-i-1)+w[a]);
        //w即这个枝条的价值，我们存储一个节点时同时存储它与父节点连接枝条的价值；
           //f[a][b]即第a个节点还可以保留b个枝条时能得的最大苹果数,它的值等于儿子最大值+兄弟最大值+加自身价值
	}
```

### 于是，一道树形dp~~水题~~就做好了qwq
附AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int l[105],r[105],n,q,last[105],w[105],f[105][105],vis[105][105],father[105],m,ans;//f[a][b]表示第a个节点还可以保留b个枝条时能得的最大苹果数
//l[i]即i的左儿子，r[i]同理 
int work(int a,int b)//a个节点保留b个枝条时能得的最大苹果数
{
	if(vis[a][b]==1)
	return f[a][b];
	vis[a][b]=1;
	f[a][b]=work(r[a],b); //f[a][b]就等于它儿子保留b个枝条所得最大苹果数(类似于初始化)
	for(int i=0;i<b;i++)
	{
		f[a][b]=max(f[a][b],work(l[a],i)+work(r[a],b-i-1)+w[a]);//枚举比较：儿子留i根枝条，自己留一根枝条，所以兄弟留b-i-1根枝条 
	}
	return f[a][b];
}
int main()
{
	cin>>n>>q;
	for(int i=1;i<=n-1;i++)
	{
		int baba,erzi,k;
		cin>>baba>>erzi>>k;//顾名思义
		if(father[erzi])//如果儿子有爸爸了，那么第一个输入的为儿子，第二个输入的为爸爸 
		{
			int t=baba;
			baba=erzi;
			erzi=t;
		}
		w[erzi]=k; 
		father[erzi]=1;
		if(last[baba]==0) l[baba]=erzi;
		else r[last[baba]]=erzi;
		last[baba]=erzi;
	} 
	cout<<work(l[1],q);//一号节点没有兄弟，输出儿子即可
	return 0;
}
```


---

## 作者：柳逸君 (赞：2)


### 题目描述

有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点）

这棵树共有N个结点（叶子点或者树枝分叉点），编号为1-N,树根编号一定是1。

我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有4个树枝的树

    2   5
     \ / 
      3   4
       \ /
        1

现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。

给定需要保留的树枝数量，求出最多能留住多少苹果。
输入输出格式
输入格式：

第1行2个数，N和Q(1<=Q<= N,1<N<=100)。

N表示树的结点数，Q表示要保留的树枝数量。接下来N-1行描述树枝的信息。

每行3个整数，前两个是它连接的结点的编号。第3个数是这根树枝上苹果的数量。

每根树枝上的苹果不超过30000个。

### 输出格式：

一个数，最多能留住的苹果的数量。

### 输入输出样例
#### 输入样例#1：

5 2
1 3 1
1 4 10
2 3 20
3 5 20

#### 输出样例#1：

21

在树中选择一定数目的边使边权和最大，显然是一个树形背包，但是因为不会搞边的背包，所以机智（~~傻缺~~）的我就花了一个小时的时间建了一棵新树，把边都搞成了点，GG；
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
#define ll long long
using namespace std;
const int maxn=200;
ll n,si[maxn],head1[maxn],head2[maxn],ap[maxn];
ll num1,num2,q,cnt;  
ll f[maxn][maxn];  //f[i][j]表示在节点选择j个节点的最大值
struct E{
	int nxt,to,dis;
} edge[maxn<<1],edg[maxn<<1];
void add1(int from,int to,int dis)
{
	edge[++num1].to=to;
	edge[num1].nxt=head1[from];
	edge[num1].dis=dis;
	head1[from]=num1;
}
void add2(int from,int to)
{
	edg[++num2].to=to;
	edg[num2].nxt=head2[from];
	edg[num2].dis=from;
	head2[from]=num2;
}
void build(int fa,int x,int cur)  //emm~~,sx
{
	for(int i=head1[x];i;i=edge[i].nxt)
	{
		int xx=edge[i].to;
		if(xx==fa) continue;
        add2(cur,++cnt);
		ap[cnt]=edge[i].dis;
		//cout<<x<<' '<<xx<<' '<<cnt<<endl;
		build(x,xx,cnt);
	}
}
void dfs(int x)
{
	int temp=1;   //子树的大小
	f[x][1]=ap[x];  //初始化
  for(int i=head2[x];i;i=edg[i].nxt)
    {
  	  int xx=edg[i].to;
  	  temp+=dfs(xx);  //dfs向下求子树大小并将下层处理好
  	  for(int j=temp;j>0;j--)
  	   for(int k=0;k<=temp;k++)
  	    if(j-k>=1)    //枚举子树节点两侧分别的贡献
  	     f[x][j]=max(f[x][j],f[x][j-k]+f[xx][k]);
    }	
  	return temp;
}
int main()
{
   scanf("%lld%lld",&n,&q);
   for(int i=1;i<n;i++)
   {
   	 int a,b,c;
   	 scanf("%d%d%d",&a,&b,&c);
   	 add1(a,b,c);
   	 add1(b,a,c);
   }
   for(int i=1;i<=n;i++) si[i]=1;
   cnt=1;  build(0,1,1);
   dfs(1);
   cout<<f[1][q+1]<<endl;
    //q+1是因为将根节点设为了在原图中并不存在的0->1这条边
return 0;
}

```


---

## 作者：猪脑子 (赞：2)

这显然是一道树形DP的题……

当我们找到一个结点后，有两种情况：

1、这是一个叶子结点。2、这是一个有两个儿子的父亲结点。

**我们考虑以该结点为根的子树，在保留树枝数量一定时，能保留下来的苹果最多有多少。**

对于情况1，显然该值为0（没有树枝）。

对于情况2，我们分三种选择：

	1、只选择左子树
    2、只选择右子树
    3、既选择左子树又选择右子树

当然，在选择子树的同时，**我们必须选择该结点到该子结点的树枝**。

**我们定义dp[ i ][ j ]表示以i为根的子树，保留j个树枝，能保留多少苹果。**

那么，

	if(这是一个叶子节点)dp[i][j]=0;
    else dp[i][j]=min{
    	dp[i的左儿子][j-1]+到i的左儿子的树枝的苹果数,
    	dp[i的右儿子][j-1]+到i的右儿子的树枝的苹果数,
    	dp[i的左儿子][k]+dp[i的右儿子][j-2-k]
    	+到i的左儿子的树枝的苹果数+到i的右儿子的树枝的苹果数
    	(0<=k<=j-2)
    }

这道题我们就可以这么做：

1、读入边，建树。

2、从1开始记忆化搜索。

（细节看代码）

Code:

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
inline void re(int &x)
{
	x=0;bool flag=false;
	char c=getchar();
	while(c<'0'||c>'9'){
		flag= c=='-';
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	if(flag)x=-x;
	return ;
}
struct Edge{
	int v,c,nxt;
}e[220];int tot;
int first[220];
struct Node{
	int l,r;
	int lc,rc;
	bool is_fa;
	int siz;
}a[110];
int n,q;
void build(int u,int v,int c)
{
	e[++tot]=(Edge){v,c,first[u]};
	first[u]=tot;
	return ;
}
bool book[110];
void build_a_tree(int k)//build a tree
{
	book[k]=true;
	for(int i=first[k];i;i=e[i].nxt)
		if(!book[e[i].v]){
			a[k].is_fa=true;
			if(!a[k].l)a[k].l=e[i].v,a[k].lc=e[i].c;
			else a[k].r=e[i].v,a[k].rc=e[i].c;
			build_a_tree(e[i].v);
			a[k].siz+=a[e[i].v].siz;
		}
	a[k].siz++;
	return ;
}
int dp[110][110];
int dfs(int k,int m)
{
	if(m==0)return 0;
	if(dp[k][m])return dp[k][m];
	if(!a[k].is_fa)return 0;//leaf
	dp[k][m]=max(dfs(a[k].l,m-1)+a[k].lc,dfs(a[k].r,m-1)+a[k].rc);//1 2
	for(int i=0;i<=m-2;i++)
		dp[k][m]=max(dp[k][m],dfs(a[k].l,i)+a[k].lc+dfs(a[k].r,m-2-i)+a[k].rc);//3
	return dp[k][m];
}
int main()
{
	re(n);re(q);
	for(int i=1;i<n;i++)
	{
		int u,v,c;
		re(u);re(v);re(c);
		build(u,v,c);
		build(v,u,c);
	}
	build_a_tree(1);//build the tree
	printf("%d\n",dfs(1,q));
	return 0;
}
```
然后就~~轻松~~AC了

时空复杂度...

O(n*q^2) O(n*q)

**如果不对，请在讨论区发帖……**

---

## 作者：小样儿鸣 (赞：1)

萌新写的题解，应该对萌新更友好吧。~~毕竟高端操作我也学不来~~

这一道题非常适合理解树形DP+背包这一类型的题，~~因为蒟蒻的我在这里卡了三天~~

### 前置知识：邻接表

我当初图省事没学邻接表，结果在这里付出了血的代价。。。**邻接表适合用结构体表示，因为它就是由一个作用等同于指针的数组和许多代表边（点）的节点构成的。（关键是这样写不容易迷）就像这样：**

```cpp
struct mmp		//相当于一个节点
{
	int xnext;	//兄弟节点的下标（就是兄弟节点的结构体的下标）	
	int to;		//边指向的终点（图中的真实点）
	int val;	//边权
}hp[202];		//定义了202个节点，下标0~201
int xfirst[202];	//xfirst[真实点编号]=子节点的结构体的下标
```
既然是无向图，那就要存两个方向的边，我是这样存的：

```cpp
scanf("%d%d",&z.n,&z.q);
for(int k=1;k<z.n;k++)
{
	int a,b,c,i=2*k;
	scanf("%d%d%d",&a,&b,&c);
	hp[i].xnext=xfirst[a];
	xfirst[a]=i;
	hp[i].to=b;
	hp[i].val=c;
	i++;			//i++后上下几乎不变，不亦说乎？
	hp[i].xnext=xfirst[b];
	xfirst[b]=i;
	hp[i].to=a;
	hp[i].val=c;
}
```

从输入我们也能看到，hp[i]中这个i就是一个**用来定位的**下标，而xfirst数组和hp[i].xnext则是分别提供**孩子下标**和**兄弟下标**的工具，一个串一个地把一个点所有的孩子全都联系了起来，也正是这样，遍历的时候就比较舒服了：

```cpp
for(int i=xfirst[t];i;i=hp[i].xnext)
//i是存储子节点的结构体的下标，一个串一个直到没有，一个点的子节点也就遍历完了。
```

### 解决问题：

（这段话全是自己理解）
DP的三要素是什么？阶段、状态、决策，从大到小依次循环。树上DP阶段基本是遍历子树（大小由小到大），状态往往是你的选择造成的影响，决策则是你的选择。

对于这道题，可以发现：当所有子节点在所有可能的情况下的最大值都确定的时候，根节点在所有情况下的最大值也就确定了。

简而言之：子节点所有情况（状态）完全已知时根节点的状态就可以推出来了。所以要**后序遍历**它。代码如下：

```cpp
void dfs(int t)		//根节点t即是阶段标志
{
	//f[i][j]=以第i个点为根节点，取j个时的最大值 
	for(int i=xfirst[t];i;i=hp[i].xnext)
	{
		if(visited[hp[i].to])continue;	//这是用来递归的（判重）
		visited[hp[i].to]=1;		//这也是用来递归的（标记，已遍历） 
		dfs(hp[i].to);			//这当然是用来递归的 
		//j枚举根节点可能会得到的树枝的数量
		//j==0时f[t][j]必为零，不必枚举 
		for(int j=z.n;j>0;j--) 
		{
			//k用来枚举（上一棵）子树可能会得到的树枝的数量
			//k==j-1时当前子树仍然获得了连向根节点的一个树枝
			//而“抛弃”当前子树的状态已经包含在初始的f[t][j]中了 
			for(int k=j-1;k>=0;k--)
			{
				f[t][j]=max(f[t][j],f[t][k]+f[hp[i].to][j-k-1]+hp[i].val);
			}
		}
	}
}
```

f[t]数组包含了t为根时已遍历子节点所能提供的最大值，每个子节点相当于一个有一堆状态的物品，按照01背包理解即可。用样例测试过，j,k的遍历顺序好像没有影响。。。

建议大家多写写题解、博客，加深记忆和理解。~~然而我本身就对这道A了三天才过的题印象深刻~~

下面是AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct xyem
{
	int n,q;
}z;
struct mmp				//相当于一个节点 
{
	int xnext;		//编码的下一个	
	int to;			//边指向的终点
	int val;		//边权
}hp[202];
int xfirst[202];
int visited[101];
int f[202][202];
void dfs(int t)
{
	//f[i][j]=以第i个点为根节点，取j个时的最大值 
	for(int i=xfirst[t];i;i=hp[i].xnext)
	{
		if(visited[hp[i].to])continue;	//这是用来递归的 
		visited[hp[i].to]=1;			//这也是用来递归的 
		dfs(hp[i].to);					//这当然是用来递归的 
		//j枚举根节点可能会得到的树枝的数量
		//j==0时f[t][j]必为零，不必枚举 
		for(int j=z.n;j>0;j--) 
		{
			//k用来枚举（上一棵）子树可能会得到的树枝的数量
			//k==-1时椎鼻坝树仍然获得了连向根节点的一个树枝
			//而“抛弃”当前子树的状态已经包含在初始的f[t][j]中了 
			for(int k=j-1;k>=0;k--)
			{
				f[t][j]=max(f[t][j],f[t][k]+f[hp[i].to][j-k-1]+hp[i].val);
			}
		}
	}
}
int main()
{
	scanf("%d%d",&z.n,&z.q);
	for(int k=1;k<z.n;k++)
	{
		int a,b,c,i=2*k;
		scanf("%d%d%d",&a,&b,&c);
		hp[i].xnext=xfirst[a];
		xfirst[a]=i;
		hp[i].to=b;
		hp[i].val=c;
		i++;
		hp[i].xnext=xfirst[b];
		xfirst[b]=i;
		hp[i].to=a;
		hp[i].val=c;
	}
	visited[1]=1;
	dfs(1);
	printf("%d",f[1][z.q]);
	return 0;
}
```


---

## 作者：HYR2018 (赞：1)

话不多说，直接上代码，解释都在代码中
```cpp
#include<bits/stdc++.h>
#define N 100
using namespace std;
bool check_line[N][N],vis[N];
int line_apple[N][N],dp[N][N],sum[N];
int n,q,ans,root_sum;

struct Node{
	int l,r;
}son[N];

void build_tree(int fa)
{
	bool flag=0;//标记左儿子节点是否被标记过
	for(int i=2;i<=n;i++)
	{//因为1已经被默认为根节点了，所以搜索儿子时应该从2开始
		if(!check_line[fa][i]) continue;//如果fa节点到i没有边直接跳过
		if(vis[i]) continue; //如果i号节点标记过，直接跳过
		vis[i]=true;
		if(!flag)
		{//左儿子没有接东西，那就先往左儿子上加上东西
			son[fa].l=i;
			sum[i]=line_apple[fa][i];//将苹果存在儿子节点上
			flag=true;
		}
		else
		{//左儿子上有了东西，那么只能往右儿子上接
			son[fa].r=i;
			sum[i]=line_apple[fa][i];
		}
		build_tree(i);
	}
}

int dfs(int fa,int k)//父亲节点和此父亲节点下保留的节点数
{
	if(k==0) return 0;//父亲节点下如果没有数，则表示这棵树下没有苹果
	if(son[fa].l==0&&son[fa].r==0) return sum[fa];
	//如果左儿子和右儿子上都没有苹果，那么表示只有父亲节点上有苹果
	if(dp[fa][k]!=0) return dp[fa][k];//这句必须要，记忆化搜索，不然会超时
	for(int i=0;i<k;i++)
	{//dp找到最大的苹果数
		dp[fa][k]=max(dp[fa][k],dfs(son[fa].l,i)+dfs(son[fa].r,k-i-1)+sum[fa]);
	}//如果下面接的左儿子和右儿子加父亲节点的苹果更大，则更新dp[fa][k]
	return dp[fa][k];
}

int main()
{
	cin>>n>>q;//n个节点，保留q条边
	root_sum=q+1;//即保留q+1个节点
	for(int i=1;i<=n-1;i++)
	{//因为为二叉数，所以只有n-1条边
		int u,v,w;
		cin>>u>>v>>w;
		line_apple[u][v]=w;//u到v条边上w个苹果
		check_line[u][v]=true;//表示u到v有苹果
	}//邻接矩阵存图
	vis[1]=true;//因为根节点默认为1，所以标记1号节点
	build_tree(1);//从根节点开始建树//多叉树转二叉树的思想
	ans=dfs(1,root_sum);//开始深搜//从节点1开始搜，保留d个点
	cout<<ans;
	return 0;
}

```
本题是练dp的一个好题，我的思想最主要是多叉转二叉

不过本题用邻接表存图会更加优化，但我个人认为邻接矩阵更好理解

---

## 作者：Randyhoads (赞：1)

[贪玩蓝月----你没有van过的全新版本，更吼的阅读体验请点击](https://www.cnblogs.com/wlzs1432/p/9277905.html)

很显然的树形DP。

留下Q个树枝，就是留下Q+1个节点。

对于一棵有x个节点的子树：

1.全剪完

2.没有全剪完：这是一定要留下根节点(假设它为i），假设在左子树中留下k各节点，右子树就留下了剩下的x-k-1个节点

状态转移方程：f[i][j]=max(f[i][j],f[lc][k]+f[rc][x-k-1]+a[i])

其中f[i][j]表示以i为根的子树保留k个节点，a[i]表示保留i后直接影响到的苹果树。

代码写的很奇怪
```cpp

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

#define MAXN 310

inline int read()
{
    int f=1,x=0;
    char ch;
    do
    {
        ch=getchar();
        if(ch=='-') f=-1;
    }while(ch<'0'||ch>'9');
    do
    {
        x=(x<<3)+(x<<1)+ch-'0';
        ch=getchar();
    }while(ch>='0'&&ch<='9');
    return f*x;
}

struct node
{
    int to;
    int val;
};

vector<node>son[MAXN];
int n,q;
int x,y,z;
int f[MAXN][MAXN];

inline int dp(int i,int j,int fa,int w)
{
    if(j==0) return 0;
    if(son[i].size()==1) return son[i][0].val;
    if(f[i][j]!=0) return f[i][j];
    int v1=0,v2=1;
    if(son[i][v1].to==fa) v1=2;
    else if(son[i][v2].to==fa) v2=2;
    for(int k=0;k<=j-1;k++)
         f[i][j]=max(f[i][j],dp(son[i][v1].to,k,i,son[i][v1].val)+dp(son[i][v2].to,j-k-1,i,son[i][v2].val)+w);
    return f[i][j];
}

int main()
{
    n=read(),q=read();
    for(int i=1;i<n;i++){
        x=read(),y=read(),z=read();
        son[x].push_back(node{y,z});
        son[y].push_back(node{x,z});
    }
    printf("%d\n",dp(1,q+1,0,0));
} 
```

---

## 作者：Mark_ZZY (赞：1)

```cpp
//树形DP
#include<cstdio>
#include<cstring>
int next[5001],pre[5001],last[5001],apple[5001],dp[5001][5001],n,m,tot=0;
```
/\*
dp[i][j]表示节点i保留j个枝条的所剩苹果最大值

apple[i]表示第i条边上的苹果数

next,pre,last是用来建边的数组

tot来统计边的序号

\*/
```cpp
int minn(int x,int y)
{
    return x<y?x:y;
}
int maxx(int x,int y)
{
    return x>y?x:y;
}
void jl(int u,int v,int w)
{
    tot++;
    next[tot]=v;
    pre[tot]=last[u];
    last[u]=tot;
    apple[tot]=w;
}
int dfs(int u,int father)
{
    int ans=0;//ans表示u节点的子节点数目
    for(int i=last[u];i!=0;i=pre[i])
    {
        int v=next[i],value=apple[i];
        if(v==father) continue;//如果下一个相邻节点就是父节点，则证明到底层了，开始递归父节点的兄弟节点
        ans+=dfs(v,u)+1;//递归到最上层的根节点1
        for(int j=minn(ans,m);j>=1;j--)//因为有限制枝条的数目，取个min
        {
            for(int k=minn(j,ans);k>=1;k--)
                dp[u][j]=maxx(dp[u][j],dp[u][j-k]+dp[v][k-1]+value);
```
/\*
对于u节点下的子节点j，对j保留多少枝条最优进行dp

在这里好好说明下，因为建树是我们是按照递归建的树。

进行比较时，dp[u][j]都是前面选择除i外的子节点得到的最优解结果

所以dp的时候不可能重复或者漏掉某节点

\*/
```cpp
        }
    }
    return ans;
}
int main()
{
    memset(last,0,sizeof(last));
    memset(next,0,sizeof(next));
    memset(pre,0,sizeof(pre));
    memset(dp,0,sizeof(dp));
    scanf("%d %d",&n,&m);
    for(int i=1;i<n;++i)
    {
        int x,y,z;
        scanf("%d %d %d",&x,&y,&z);
        jl(x,y,z);
        jl(y,x,z);
    }
    dfs(1,0);
    printf("%d",dp[1][m]);
}
```

---

## 作者：ghd123 (赞：1)

```cpp
//将树枝上的苹果平移向子节点
//在根节点下创造一个虚拟树枝，使树枝数=节点数
type
  tree=record
    l,r,data:longint;
  end;
var
  a:array[0..110]of tree;
  b,f:array[0..110,0..110]of longint;
  z:array[0..110]of boolean;
  n,q,x,y,i,j,t:longint;
procedure mt(k:longint);//maketree 创建二叉树
var
  i:longint;
begin
  z[k]:=true;
  for i:=1 to n do
    if not z[i] and (b[k,i]>-1) then
    begin
      if a[k].l=0 then a[k].l:=i//保存为左子树
      else a[k].r:=i;//保存为右子树
      a[i].data:=b[k,i];//记录苹果数
      mt(i);//深搜
    end;
end;
function dp(n,q:longint):longint;//记忆化搜索
var
  i,max,t:longint;
begin
  max:=0;
  if (n=0) or (q=0) then exit(0);//边界
  if f[n,q]=-1 then//未计算
  begin
    for i:=0 to q-1 do//枚举左子树枝条数量
    begin
      t:=dp(a[n].l,i)+dp(a[n].r,q-1-i);
      if t>max then max:=t;
    end;
    f[n,q]:=max+a[n].data;
  end;
  exit(f[n,q]);
end;
begin
  fillchar(b,sizeof(b),255);
  fillchar(f,sizeof(f),255);
  readln(n,q);
  for i:=1 to n-1 do
  begin
    readln(x,y,t);
    b[x,y]:=t;
    b[y,x]:=t;
  end;
  mt(1);
  writeln(dp(1,q+1));
end.

```

---

## 作者：KesdiaelKen (赞：1)

这道题可以用树形DP+记忆化+链式前向星来做（有点太low了吗？）（二叉树用前向星？没必要吧）

具体思想和做法见代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<cstdlib>
using namespace std;
int head[500];
struct Edge
{
    int z;
    int gs;
    int nexty;
    Edge(){gs=0;}
}edge[1000];
int cnt=0;
int visit[500]={0};
int f[200][200][200]={0};
inline void _add(int a,int b,int c)//建边函数
{
    cnt++;
    edge[cnt].z=b;
    edge[cnt].gs=c;
    edge[cnt].nexty=head[a];
    head[a]=cnt;
}
int dfs(int root,int bh,int hs)//DP函数，用dfs实现（root：当前根节点；bh：当前边cnt编号；hs：还要在这个（子）树上保留多少条变）
{
    if(visit[root])return 0;//有可能边导到它的父节点，所以加个判重，避免死循环
    if(f[root][bh][hs]!=0)return f[root][bh][hs];//记忆化搜索（由于我的蒟蒻，开了3维数组，其实只要2维就够了）
    if(hs==-1)return f[root][bh][hs]=0;//边界-1：不需要加边，直接返回0
    if(hs==0)return f[root][bh][hs]=edge[bh].gs;//边界0：子树中无需加边，而需要取父节点连接它的边
    int za,zb;//存root树的两个子节点
    int a,b;
    za=zb=1;//有可能只有一个子节点，所以赋初始值为1，搜索因重复会自动返回0，不影响答案
    int maxn=0;
    for(int now=head[root];now!=-1;now=edge[now].nexty)//前向星遍历边
    if(!visit[edge[now].z])za==1?za=now:zb=now;
    if(za==1)return f[root][bh][hs]=edge[bh].gs;//若无子节点，则同边界0的情况
    for(int i=0;i<=hs;i++)//可能的左右子树保留边数情况
    {
        visit[root]=true;
        a=dfs(edge[za].z,za,i-1);
        b=dfs(edge[zb].z,zb,hs-i-1);//重点：取a-1，hs-i-1——减一表示说到下一个节点，已取edge[zb]，所以-1。
//        visit[root]=false;
        maxn=max(maxn,a+b+edge[bh].gs);
    }
    return f[root][bh][hs]=maxn; 
}
int main()
{
    int n,q;
    int a,b,c;
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&q);
    for(int i=0;i<n-1;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        _add(a,b,c);
        _add(b,a,c);//前向星建边（由于是有向边，所以要两向建边）
    }
    printf("%d",dfs(1,0,q));
    return 0;
}
```

---

## 作者：ysner (赞：1)

/\* 此题因为求最大的苹果数量，一定使用树形动态规划，否则超时！（或者说是树形依赖背包）

对于每一个节点来说，它的存在与否都是关系到他下边的苹果数量的，题目要求最后是留下几条枝，那么如果不要这个点的左子树的话，他右子树的就可以留k-1条边，因为要抛去这个点和右子树点的边，那么现在就有两个状态，要左子树或要右子树，还有一个状态就是两边都要，那么分给左子树的边为i，分给右子树的边为k-2-i，for i=1 to k-2 do。从这里找一个最大值和上两个状态比求出最大就是这个点的最优值。

这道题还应该注意建树，因为右不一定是左的孩子。

状态转移方程f[x][j]=max(f[x][j],f[x][j-k]+f[s][k-1]+jz[x][i]);\*/

```cpp
#includde<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<algorithm>
using namespace std;
vector<int> jz[200],b[200];
int q,n,f[200][200]={};
int work(int x,int y)
{
  int son=0;
  for(int i=0;i<b[x].size();i++)
  {
    int s=b[x][i];//点u的儿子结点 
    if(s==y) continue;
    son+=(work(s,x)+1);//数搜到的结点（多加一个点） 
    for(int j=min(son,q);j>0;j--)//j代表保留的树枝数 
      for(int k=min(j,q);k>0;k--)
        f[x][j]=max(f[x][j],f[x][j-k]+f[s][k-1]+jz[x][i]);//程序核心：状态转移方程
  }
  return son;
}
int main() 
{
  int i,j,k,l;
  cin>>n>>q;
  for(i=1;i<n;i++)
  {
    cin>>j>>k>>l;
    b[j].push_back(k);
    b[k].push_back(j);//构造边 
    jz[j].push_back(l);
    jz[k].push_back(l);//存价值 
  }
  work(1,1);
  cout<<f[1][q]<<endl;
  return 0;
}
```

---

## 作者：KevinYu (赞：1)

这道题是典型的树形DP题。      
我们发现根据边进行处理十分的麻烦，所以我们把留下q条边化为留下q+1个点。      
我们来过一遍算法流程:      
首先是一遍addedge添加双向边：     
```cpp
	for(int i=1;i<=n-1;i++)
	{
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		addedge(x,y,w);
		addedge(y,x,w);
	}
```
然后我们dfs一遍:     
```
void dfs(int u,int fa)
{
	for(int i=head[u];i!=-1;i=t[i].next)
	{
		int v=t[i].to;
		if(v!=fa)
		{
```
我们先(从根开始)开始进行树的遍历，过程中完成以下几个工作:                
1.存储每一个节点的左孩子与右孩子(重新建立一颗二叉树):   
```cpp
			if(!lc[u])lc[u]=v;
			else rc[u]=v;
```
2.把边权化为点权：    
我们有两种方法实现这个过程   
①:一个点的点权是其所有连出去的边(除了到它父亲的那一条)的边权和：
```cpp
			a[u]+=t[i].weight;
```
②:一个点的点权是其父亲指向它的边权:
```cpp
			a[v]=t[i].weight;
```
在这里我们采用第二种方式。      
3.继续dfs过程:
```cpp
			dfs(v,u);
		}
	}
}
```
最后是dp过程:      
我们用```f[u][k]```来表示以u为根的子树保留k个点的状态。        
推算出边界条件:
```cpp
	f[i][0]=0;
	f[u(u为叶节点)][k]=a[u];
```
我们用记忆化搜索来实现dp过程:      
首先是边界条件以及记忆化:      
```cpp
    if(f[u][k])return f[u][k];
    if(!lc[u]&&!rc[u]&&k!=1)return 0;
    if(!lc[u]&&!rc[u]&&k==1)return a[u];
```
然后是只有左子树的情况：
```cpp
	else if(lc[u]&&!rc[u])return solve(lc[u],k-1)+a[lc[u]];
```
在进行下一步前，我们先写出转移方程:
```cpp
f[u][k]=max{res,solve(lc[u],i)+solve(rc[u],k-i-1)+a[u]}(i∈{0-k-1});
```
于是得完整dp过程:      
```cpp
int solve(int u,int k)
{
    if(f[u][k])return f[u][k];
    if(!lc[u]&&!rc[u]&&k!=1)return 0;
    if(!lc[u]&&!rc[u]&&k==1)return a[u];
    else if(lc[u]&&!rc[u])return solve(lc[u],k-1)+a[lc[u]];
    else
    {
        int res=0;
        for(int i=0;i<k;i++)res=max(res,solve(lc[u],i)+solve(rc[u],k-i-1)+a[u]);
        f[u][k]=res;
        return res;
    }
}
```
最后```printf("%d",solve(1,m+1));```就好了。   
完整代码:       
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<climits>
#include<ctime>
#include<algorithm>
#include<complex>
#include<iostream>
#include<map>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define ll long long
using namespace std;
struct edge
{
	int to,next,weight;
}t[220];
int lc[110];
int rc[110];
int a[110];
int cnt(0);
int head[110];
int f[110][110];
int n,m;
void addedge(int xi,int yi,int wi)
{
	t[cnt].to=yi;
	t[cnt].next=head[xi];
	t[cnt].weight=wi;
	head[xi]=cnt++;
}
int solve(int u,int k)
{
    if(f[u][k])return f[u][k];
    if(!lc[u]&&!rc[u]&&k!=1)return 0;
    if(!lc[u]&&!rc[u]&&k==1)return a[u];
    else if(lc[u]&&!rc[u])return solve(lc[u],k-1)+a[lc[u]];
    else
    {
        int res=0;
        for(int i=0;i<k;i++)res=max(res,solve(lc[u],i)+solve(rc[u],k-i-1)+a[u]);
        f[u][k]=res;
        return res;
    }
}
void dfs(int u,int fa)
{
	for(int i=head[u];i!=-1;i=t[i].next)
	{
		int v=t[i].to;
		if(v!=fa)
		{
			if(!lc[u])lc[u]=v;
			else rc[u]=v;
			a[v]=t[i].weight;
			dfs(v,u);
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n-1;i++)
	{
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		addedge(x,y,w);
		addedge(y,x,w);
	}
	for(int i=1;i<=n;i++)f[i][0]=0;
	dfs(1,0);
	printf("%d",solve(1,m+1));
	return 0;
}

```


---

## 作者：luoyue123 (赞：1)

这道题可以把边权转化为点权来做，然后dp找出深度。状态转移方程就是枚举一个j是以u为根的子树中选了几个点。以u为根，u是一定要选的，所以我们要从他的子树中选出j-1个点，枚举从左子树中选了k个点来更新状态。具体见代码。









```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=205;
int head[MAXN],cnt=0;
struct edge{
    int to,next,w;
}e[MAXN<<1];
inline void add(int u,int v,int w){e[++cnt]=(edge){v,head[u],w},head[u]=cnt;}
int n,m,tem1,tem2,tem3,dw[MAXN],size[MAXN],dp[MAXN][MAXN],lson[MAXN<<5],rson[MAXN<<5]; //开够大小 
void dfs1(int u,int fa){
    size[u]=1;
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==fa)continue;
        dw[v]=e[i].w;
        if(!lson[u])lson[u]=v;
        else rson[u]=v;
        dfs1(v,u);
        size[u]+=size[v];
    }
}
//dp[i][j]=max(dp[i][j],dp[lson][j-1-k]+dp[rson][k]+w[i])   0<=k<=j-1   状态转移 
void dfs2(int u,int fa){
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==fa)continue;
        dfs2(v,u);
        for(int j=2;j<=size[u];j++){
            for(int k=0;k<=j-1;k++){
                dp[u][j]=max(dp[u][j],dp[lson[u]][j-1-k]+dp[rson[u]][k]+dw[u]);//转移 
            }
        }
    }
}
int main(){
    memset(dw,0,sizeof(dw));
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++){
        scanf("%d%d%d",&tem1,&tem2,&tem3);
        add(tem1,tem2,tem3);
        add(tem2,tem1,tem3);
    }
    dfs1(1,1);//预处理 
    for(int i=1;i<=n;i++){
        dp[i][1]=dw[i];
    }
    dfs2(1,1);
    printf("%d",dp[1][m+1]);
    return 0;
} 

```

---

## 作者：xcyy (赞：0)

#### **先来分析题目**

由题意可知，需要保留的树枝为Q，所以留下的点为Q+1,树根必须保留，可以分3种情况讨论保留苹果的最大保留数量：

1，树根的左子树为空，右子树保留Q个点。

2，树根的右子树为空，左子树保留Q个点。

3，树根的左右子树都有点，设左子树取k个点，则右子树取Q-k个点。

设树根为i，树根的左儿子为l[i]，右儿子为r[i]，此题有明显的最优子结构性质，每个问题都只与左右儿子有关，与孙子无关，并且满足无后效性原则，所以可以用动态规划来解决。

我们设f[i][j]表示以i为根节点的树上保留j个点的最大权值。l[i]，r[i]，分别存i的左右儿子。


可得状态转移方程为:

f[i][j]=max(f[i][j],f[l[i]][k]+f[r[i]][j-k-1]+a[i])

贴代码

```c
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<queue>
#include<cstdio>
using namespace std;
#define N 105
int f[N][N],mapp[N][N],r[N],l[N],n,m,q;
int x,y,z;
int a[N];

inline void maketree(int v)
{
	for(int i=1;i<=n;i++)
	{
		if(mapp[v][i]>=0)
		{
			l[v]=i;a[i]=mapp[v][i];
			mapp[v][i]=-1;
			mapp[i][v]=-1;
			maketree(i);
			break;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(mapp[v][i]>=0)
		{
			r[v]=i;a[i]=mapp[v][i];
			mapp[i][v]=mapp[v][i]=-1;
			maketree(i);
			break;
		}
	}
}

inline int dp(int i,int j)
{
	if(j==0)return 0;
	if(l[i]==0&&r[i]==0)return a[i];
	if(f[i][j]>0)return f[i][j];
	for(int k=0;k<=j-1;k++)
	f[i][j]=max(f[i][j],dp(l[i],k)+dp(r[i],j-k-1)+a[i]);
	return f[i][j];
}
int main()
{
	scanf("%d%d",&n,&q);q++;
	memset(mapp,-1,sizeof(mapp));
	for(int i=1;i<=n-1;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		mapp[x][y]=z;mapp[y][x]=z;
	}
	maketree(1);
	printf("%d\n",dp(1,q));
	return 0;
}
```


---

## 作者：风说我活了 (赞：0)

这个就按照一本通上面来，很容易懂的

需要保留Q个树枝，则保留j=Q+1个节点

分三种情况：

1.树根的左子树为空，全部保留右子树，则左子树不连根则保留j-1个节点

2.树根的右子树为空，全部保留左子树，则右子树不连根则保留j-1个节点

3.两棵子树都不为空，设左子树保留k个点，右子树则保留j-k-1个点

转移方程：
f[i][j]=max{f[l[i]][k]+f[r[i]][j-k-1]+a[i]}

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(register int i=(a);i<=(b);i++)
#define don(i,a,b) for(register int i=(a);i>=(b);i--)
#define ll long long
using namespace std;
const int maxn=1e2+10;
const int maxm=1e3+10;
int n,q;
int mapp[maxm][maxm],f[maxm][maxn],a[maxn],r[maxn],l[maxn];

template <class t> inline void read(t &x)
{
	int f=1;x=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=10*x+ch-'0';ch=getchar();}
	x*=f;
}

template <class t> inline void write(t x) 
{
	if(x<0) {putchar('-');x=~x+1;}
	if(x>9) write(x/10);
	putchar(x%10+48);
}
/*--------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------*/

void biludtree(int root)
{
	rep(i,1,n) {
		if(mapp[root][i]>=0) {//建左子树
			l[root]=i;
			a[i]=mapp[root][i];
			mapp[root][i]=mapp[i][root]=-1;//打标记
			biludtree(i);
			break;
		}
	}
	rep(i,1,n) {
		if(mapp[root][i]>=0) {//建右子树
			r[root]=i;
			a[i]=mapp[root][i];
			mapp[root][i]=mapp[i][root]=-1;
			biludtree(i);
			break;
		}
	}
}

void readdata()
{
	memset(f,false,sizeof(f));
	memset(mapp,-1,sizeof(mapp));
	read(n),read(q);
	q++;
	rep(i,1,n-1) {
		int x,y,z;
		read(x),read(y),read(z);
		mapp[x][y]=z;
		mapp[y][x]=z;
	}
}

inline int dp(int i,int j)
{
	if(j==0) return 0;
	if(l[i]==0 && r[i]==0) return a[i];
	if(f[i][j]>0) return f[i][j];//记忆化搜索
	rep(k,0,j-1) {
		f[i][j]=max(f[i][j],dp(l[i],k)+dp(r[i],j-k-1)+a[i]);
	}
	return f[i][j];
}

void work()
{
	biludtree(1);
	int ans=dp(1,q);
	write(ans);
	printf("\n");
}

int main()
{
	//freopen("input.txt","r",stdin);
	readdata();
	work();
	return 0;
}
```
求过！！！！！~~虽然是看的一本通~~


---

## 作者：风随逐影 (赞：0)

## 树上背包
一道很**显然**的树上背包？**（没看出来）**

依据大概是可以把保留的树枝数看作体积，把苹果的数量看作价值。

由贪心可知如果保留了子树上的边，那么父节点到该子树的边也会被保留。而若父节点到该子树没有边，f值为0，就是初值，所以我们在处理的时候，默认保留父节点到该子树的边

由于是01背包，倒叙枚举即可

题目如下：
[二叉苹果树](https://www.luogu.org/problemnew/show/P2015)

```c
#include<bits/stdc++.h>
using namespace std;
#define go(i,a,b) for(int i=(a);i<=(b);++(i))
#define com(i,a,b) for(int i=(a);i>=(b);--(i))
#define mem(a,b) memset((a),(b),sizeof(a))
#define inf 0x3f3f3f3f
#define fin freopen("input.txt","r",stdin)
#define fout freopen("output.txt","w",stdout)
typedef long long ll;
const int maxn=110;
int cnt=0,f[maxn][maxn],head[maxn],siz[maxn],q;
struct edge{
    int nxt,v,w;
}e[maxn*2];
void add(int u,int v,int w){
    e[cnt]=(edge){head[u],v,w};
    head[u]=cnt++;
}
void read(int &x){
    int f=1;char s=getchar();x=0;
    while(!isdigit(s)){
    	if(s=='-') f=-1;s=getchar();
    }
    while(isdigit(s)){
   		x=(x<<3)+(x<<1)+s-'0';s=getchar();
    }
    x*=f;
}//读入优化

void dp(int u,int fa){
    for(int i=head[u];i+1;i=e[i].nxt){
        int v=e[i].v,w=e[i].w;if(v==fa) continue;
        dp(v,u);
        siz[u]+=siz[v]+1;
        for(int j=min(q,siz[u]);j;j--){
        	for(int k=min(siz[v],j-1);k>=0;k--){
        		f[u][j]=max(f[u][j],f[u][j-k-1]+f[v][k]+w);
            }
        }
    }
    return;
}

signed main()
{
    //fin;
    int n;read(n),read(q);
    mem(head,-1);
    int x,y,w;
    go(i,1,n-1){
        read(x),read(y),read(w);
        add(x,y,w),add(y,x,w);
    }
    dp(1,0);
    printf("%d",f[1][q]);
    return 0;
}
```


---

## 作者：Celebrate (赞：0)

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
struct node
{
    int x,y,d,next;
}a[210];int len,last[110];
void ins(int x,int y,int d)//建立边 
{
    len++;
    a[len].x=x;a[len].y=y;a[len].d=d;
    a[len].next=last[x];last[x]=len;
}
struct trnode
{
    int l,r;//左孩子和右孩子，表示根节点的两个子节点
    trnode(){l=r=0;}//一开始是没有的，初始化0
}tr[110];
int f[110][110];//f[i][j]表示第i个节点的子树保留j个点能保障的最大值
int n,k;
bool bk[110];//bk[i]表示i这个点是否被搜过 
void dfs(int x)//搜索第x个点
{
    for(int k=last[x];k;k=a[k].next)
    {
        int y=a[k].y;
        if(bk[y]==true)//没有访问过的就进来
        {
            bk[y]=false;
            f[y][1]=a[k].d;//保留自己一个点的最大值
            if(tr[x].l==0) tr[x].l=y;//如果x的左孩子没有人 
            else           tr[x].r=y;//不然就是右孩子
            dfs(y);//让y访问自己的亲朋好友 
        }
    }
}
int treedp(int x,int kk)//以x为根的子树保留kk个点
{
    if(x==0) return 0;//没有0节点
    if(f[x][kk]!=-1) return f[x][kk];//记忆化搜索
    int maxx=0; 
    for(int i=0;i<kk;i++)//自己要保留
    {
        int ls,rs;
        ls=i;rs=kk-1-i;//左边留i个，剩下的就是右边的
        int tpl=treedp(tr[x].l,ls);//左边的最大值 
        int tpr=treedp(tr[x].r,rs);//右边的最大值 
        maxx=max(maxx,tpl+tpr+f[x][1]);//更新自己的最大值
    }
    f[x][kk]=maxx;//存储剪纸
    return maxx;
}
int main()
{
    scanf("%d%d",&n,&k);
    len=0;memset(last,0,sizeof(last));
    int x,y,c;
    for(int i=1;i<n;i++)
    {
        scanf("%d%d%d",&x,&y,&c);
        ins(x,y,c);//双向边 
        ins(y,x,c);
    }
    memset(bk,true,sizeof(bk));//初始化 
    memset(f,-1,sizeof(f));
    bk[1]=false;dfs(1);
    for(int i=1;i<=n;i++) f[i][0]=0;//每个点不保留自然没有啊
    f[1][1]=0;//第一个点只留下一个点也是没有的
    printf("%d\n",treedp(1,k+1));//k条边，k+1个点
    return 0;
}
```

---

## 作者：shadowice1984 (赞：0)

树形dp

性质，对于这道题的决策就是在左子树上留i条边，在右子树上留j条边。

限制，i，j>=0，i+j=q,且选择的边中至少有一条和根节点相连。(q是子问题的q，就是说总共选几个）

定义：我们定义dp[i][j]表示决策以i为根的二叉树，在**###该**二叉树上需要选择j条边使得限制成立

dp[i][j]的值表示在该方案下的最大收益。

定义s[i][0]为左孩子，s[i][1]为右孩子。定义k[i][0]为链接左孩子的边权，k[i][1]为链接右孩子的边权。

转移，暴力枚举在左子树选了几条边，那么右子树就要选q-i-1个(为什么减一见下文)

然后记忆化搜索即可。

好了我们发现上述转移并没有满足限制中的“选择的边中至少有一条和根节点相连”这个条件

那么我们从选的边中预留1个或两个边给和根节点相连的边用，

一个就是彻底不选一侧的子树，两个就是两侧子树都选，哪怕有一个选零个

\_（请反复阅读状态定义，不选这个子树和这个子树上选了0条边是有差别的！！！）\_

这样的话方程就是

dp[i][j]=max(dp[i][j],dfs(s[i][0],j-1+k[i][0])),

dp[i][j]=max(dp[i][j],dfs(s[i][0],p-1)+dfs(s[i][1],j-p-1)+k[i][0]+k[i][1])(1<=p<=j-1),

dp[i][j]=max(dp[i][j],dfs(s[i][1],j-1+k[i][1])

边界条件：不需要~

上代码~

```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
struct data
{
    int v;int next;int val;
}edge[220];int cnt;int alist[110];
void add(int u,int v,int val)
{
    edge[++cnt].v=v;
    edge[cnt].val=val;
    edge[cnt].next=alist[u];
    alist[u]=cnt;
    return;
}
bool book[110];
int dp[110][110];
int k[110][2];
int s[110][2];
void dfs(int x)//dfs预处理孩子和孩子的边权
{
    book[x]=true;int p=0;
    int next=alist[x];
    while(next)
    {
        int v=edge[next].v;
        int val=edge[next].val;
        if(book[v]==false)
        {        
            dfs(v);
            s[x][p]=v;k[x][p]=val;p++;
        }
        next=edge[next].next;
    }
    return;
}
int dfs1(int x,int ban)//额这里ban是要留下多少边，一开始变量名起错了就懒得改了
{
    if(dp[x][ban]!=0)//记忆化
    return dp[x][ban];
    if(ban==0)//如果选零个return 0
    {
        dp[x][ban]=0;
        return dp[x][ban];
    }
    if(s[x][0]==0||s[x][1]==0)//如果没有孩子return 0
    {
        return 0;
    }
    dp[x][ban]=dfs1(s[x][0],ban-1)+k[x][0];//状态转移
    for(int i=1;i<=ban-1;i++)
    {
        dp[x][ban]=max(dp[x][ban],
        dfs1(s[x][0],i-1)+dfs1(s[x][1],ban-i-1)+k[x][0]+k[x][1]);
    }
    dp[x][ban]=max(dp[x][ban],dfs1(s[x][1],ban-1)+k[x][1]);
    return dp[x][ban];
}
int n;int q;
int main()
{
    scanf("%d%d",&n,&q);
    for(int i=1;i<n;i++)
    {
        int u;int v;int val;
        scanf("%d%d%d",&u,&v,&val);
        add(u,v,val);add(v,u,val);
    }    
    dfs(1);
    dfs1(1,q);
    printf("%d",dp[1][q]);
    return 0;//拜拜程序~
}

```

---

## 作者：封癫 (赞：0)

博客[链接](http://www.cnblogs.com/cellular-automaton/p/7573779.html)。


设f[i][j][k]表示给以i为根节点的子树分配j条可保留的树枝名额的时候，状态为k时能保留的最多苹果。

k有三种情况。

k=1：我只考虑子树的左叉，不考虑子树的右叉，此时子树能保留的最多的苹果。

k=2：我只考虑子树的右叉，不考虑子树的左叉，此时子树能保留的最多的苹果。

k=3：我既考虑子树的左叉，又考虑子树的右叉，此时子树能保留的最多的苹果。

这样状态转移方程就出来了。

f[i][j][1]=max(f[i][j][1],f[leftson[i]][j-1][3]+val[i][leftson[i]])

f[i][j][2]=max(f[i][j][2],f[rightson[i]][j-1][3]+val[i][rightson[i]])

f[i][j][3]=max(f[i][j][3],f[i][v][1]+f[i][j-v][2])   其中v从0到j枚举。

最后f[1][q][3]就是最终的答案。

注意记忆化搜索。我因为这个T了四次。

  ```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
inline long long read(){
    long long num=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        num=num\*10+ch-'0';
        ch=getchar();
    }
    return num\*f;
}

struct Edge{
    int next,to,val;
}edge[100010];
int head[100010],num;
int father[100010];
int size[100010];
inline void add(int from,int to,int val){
    edge[++num]=(Edge){head[from],to,val};
    head[from]=num;
}

void find(int x,int fa){
    father[x]=fa;
    size[x]=1;
    for(int i=head[x];i;i=edge[i].next){
        int to=edge[i].to;
        if(to!=fa){
            find(to,x);
            size[x]+=size[to];
        }
    }
}

int f[103][103][4];

void dfs(int x,int s){
    if(size[x]==1||f[x][s][3])    return;
    int cnt=0;
    for(int i=head[x];i;i=edge[i].next){
        int to=edge[i].to;
        if(to==father[x])    continue;
        cnt++;
        for(int v=0;v<size[to]&&v<s;++v){
            dfs(to,v);
            f[x][v+1][cnt]=f[to][v][3]+edge[i].val;
        }
    }
    for(int v=0;v<=s;++v)
        f[x][s][3]=max(f[x][s][3],f[x][v][1]+f[x][s-v][2]);
    return;
}

int main(){
    int n=read(),q=read();
    for(int i=1;i<n;++i){
        int from=read(),to=read(),val=read();
        add(from,to,val);
        add(to,from,val);
    }
    find(1,1);
    dfs(1,q);
    printf("%d",f[1][q][3]);
    return 0;
}

---

## 作者：fl_334 (赞：0)

诡异の码风

dfs+dp
```cpp
#include <iostream>
#include <vector>
using namespace std;
int N,M;
struct Node{
    int d,v;
    Node(){}
    Node(int dd,int vv):d(dd),v(vv){}
};
vector < vector<Node> > G;
int dp[110][110];
int visited[110];
int dfsDP(int son,int father){
    int ans = 0;
    for (int i = 0; i < G[son].size();i++) {
        int nNode = G[son][i].d;
        if(nNode == father)
            continue;
        ans += dfsDP(nNode,son) + 1;                //先搜
        for (int j = min(M,ans) ;j >= 0; --j) {          //一定要逆着循环~
            for (int k = j; k > 0; --k) {
                dp[son][j] = max(dp[son][j],dp[son][j-k] + dp[nNode][k-1] + G[son][i].v);            //转移方程在前面
            }
        }
    }
    return ans;
}
int main() {
    cin >> N >> M;
    G.clear();
    G.resize(N+10);
    for (int i = 1; i < N; ++i) {
        int s,d,v;
        cin >> s >> d >> v;
        G[s].push_back(Node(d,v));
        G[d].push_back(Node(s,v));
    }
    dfsDP(1,-1);
    cout << dp[1][M] << endl;
    return 0;
}
```

---

## 作者：xtx2004 (赞：0)

这题只要将状态转移方程求出来即可，状态转移方程如下所示：

∵f [ i ] [ j ] = max { f [ l [ i ] ] [ k ] + f [ r [ i ] ] [ j - m - 1 ] + a [ i ] } ( 0 <= m <= j-1 ) 。

∴ 初始化：f [ i ] [ j ] = 0; ( j = 0 )

f [ i ] [ j ] = a [ i ] (j != 0  &&  l [ i ] = 0 && r [ i ] = 0)

∴ ans = f [ 1 ] [ q + 1 ]。

这里是代码：
```
#include <bits/stdc++.h>
using namespace std;
const int maxn=105;
int n,q,l[maxn],r[maxn],f[maxn][maxn]={0},Map[maxn][maxn],a[maxn];
void tree(int v)
{
	for(int i=1;i<=n;i++)
	{
		if(Map[v][i]>=0)
		{
			l[v]=i;
			a[i]=Map[v][i];
			Map[v][i]=-1;
			Map[i][v]=-1;
			tree(i);
			break;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(Map[v][i]>=0)
		{
			r[v]=i;
			a[i]=Map[v][i];
			Map[v][i]=-1;
			Map[i][v]=-1;
			tree(i);
			break;
		}
	}
}
int dp(int i,int j)
{
	if(j==0)	return 0;
	if(l[i]==0 && r[i]==0)	return a[i];
	if(f[i][j]>0)	return f[i][j];
	for(int m=0;m<=j-1;m++)
	{
		f[i][j]=max(f[i][j],dp(l[i],m)+dp(r[i],j-m-1)+a[i]);
	}
	return f[i][j];
}
int main()
{
	int x,y,z;
	cin>>n>>q;
	q=q+1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			Map[i][j]=-1;
		}
	}
	for(int i=1;i<=n-1;i++)
	{
		cin>>x>>y>>z;
		Map[x][y]=z;
		Map[y][x]=z;
	}
	tree(1);
	int ans=dp(1,q);
	cout<<ans<<endl;
	return 0;
}
```

---


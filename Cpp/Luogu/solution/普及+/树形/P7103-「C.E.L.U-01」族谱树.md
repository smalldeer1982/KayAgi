# 「C.E.L.U-01」族谱树

## 题目背景

小 Soup 正在翻看他们家的族谱，他们家的族谱构成了一棵树。小 Soup 发现，由于年代久远，他们家族中的一些分支已经绝迹，他对此十分好奇。

## 题目描述

小 Soup 给你他们家的族谱树，想要问你在这棵树中**所有**第 $k$ 层的孩子（树中深度为 $k$ 的点，根节点的深度为 $1$ ,根节点编号为 $1$ ）的 $\text{最近公共祖先}$ 是谁。

## 说明/提示


样例解释1：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zgcgu0da.png)

样例解释2：  
![](https://cdn.luogu.com.cn/upload/image_hosting/l02zvtkv.png)

#### 数据保证存在深度为 $k$ 的点

$\begin{array}{|c|c|c|}数据编号&n,m&特殊性质\\1&\le10&\diagdown\\2&\le100&\diagdown\\3\sim4&\le10^3&\diagdown\\5&\le3\times10^5&树为一条链\\6&\le3\times10^5&\diagdown\\7\sim10&\le3\times10^6&\diagdown\\11\sim12&\le5\times10^6&\diagdown\end{array}$


对于 $100\%$ 的数据，$n\le5\times10^6,m\le n$。

温馨提示：此题较卡常，请注意大常数带来的影响以及时空复杂度。如果你被卡常了，可以试试使用快速读入。

## 样例 #1

### 输入

```
8 3
0 1 1 2 2 3 4 5
2
1
4
```

### 输出

```
1
1
2```

## 样例 #2

### 输入

```
11 4
0 1 1 3 3 3 4 5 8 8 10
3
4
5
6```

### 输出

```
3
3
8
11```

# 题解

## 作者：abruce (赞：28)

这道题还是很有趣而巧妙的，先来看一下部分分吧。  
### 40pts  
你是不是暴力爬树了，或者说你没有预处理。  
### 60pts  
大部分 $O(nlogn)$ 做法会TLE7,8;MLE9,10。  （可惜有些没卡掉）
## 100pts  
要想得到正解，就必须在这道题中间挖掘性质。  
这道题最明显的一个性质就是每一次查询的一层的节点，我们就可以往树的深度这一方面想。  
首先1号点是根节点肯定是所有层节点的公共祖先，从它开始搜肯定没有问题。  
但是我们可以想到如果一个点 $u$ 是第 $k$ 层所有节点的公共祖先，那么它一定是第 $k+1$ 层所有节点的公共祖先。通过这个性质，我们可以大大减少搜索量。  
但是怎么搜索呢，我们可以想到记录每个点子树内深度最大的节点深度是多少，设点 $u$ 的子树最大深度为 $f(u)$。  
知道每一个点的子树最大深度是多少，我们就可以来判断已知节点 $u$ 是第 $k$ 层的最近公共祖先，它的儿子 $v$ 能否成为第 $k+1$ 层的公共祖先了。  
1. $f(v)\ge k+1$。  
2. 在 $u$ 除了 $v$ 的其它儿子中，没有一个儿子 $w$ 使得$f(w)\ge k+1$  解释：如果有两个以上的儿子到达第 $k+1$ 层，那么肯定一边分了一些，所以都不是公共祖先。  

因此，可以搜索两遍，第一遍计算出 $f(u)$，并计算出儿子中 $f$ 值最大和次大的 $v$ 和 $w$，这样在第二遍搜索时就能很快计算出答案。
还有，一定记得如果 $u$ 的儿子 $v$ 是合法的，一定要将其作为新的 $u$ 继续搜索。  
最后，时间复杂度可以这么计算，在搜索过程中：  
1. 假如当前发生了更新，那么所有更新加起来不会超过 $n$ 次。
2. 假如不发生更新，则是一个常数。  

综上所述，这个算法的时间复杂度是 $O(n)$ 的。
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace io {
	inline int read() {
		int __x=0,__f=1;
		char __c=getchar();
		while(__c<'0'||__c>'9') {
			if(__c=='-')__f=-1;
			__c=getchar();
		}
		while(__c>='0'&&__c<='9') {
			__x=__x*10+__c-'0';
			__c=getchar();
		}
		return __x*__f;
	}
	char __F[200];
	inline void write(int __x) {
		if(__x==0) {
			putchar('0');
			return;
		}
		int __tmp,__cnt=0;
		if(__x>0) {
			__tmp=__x;
		} else {
			__tmp=-__x;
		}
		if(__x<0) {
			putchar('-');
		}
		while(__tmp>0) {
			__F[__cnt++]=__tmp%10+'0';
			__tmp/=10;
		}
		while(__cnt>0) {
			putchar(__F[--__cnt]);
		}
	}
}
using namespace io;
const int maxn=5e6+5;
int d[maxn],md[maxn],ans[maxn],h[maxn],f[maxn],n,m,pos,cnt,nowd,maxd,mx1[maxn],mx2[maxn];
struct edge {
	int next,to;
} e[maxn];
void addedge(int x,int y) {
	e[++cnt].next=h[x];
	e[cnt].to=y;
	h[x]=cnt;
}
int dfs1(int x,int dep) {
	md[x]=d[x]=dep;
	maxd=max(maxd,d[x]);
	for(register int i=h[x]; i; i=e[i].next) {
		int j=e[i].to;
		md[x]=max(md[x],dfs1(j,dep+1));
		if(md[j]>md[mx1[x]]) {
			mx2[x]=mx1[x];
			mx1[x]=j;
		} else if(md[j]>md[mx2[x]]) {
			mx2[x]=j;
		}
        //第一遍搜索，计算出f(u)，f值最大和次大的儿子
	}
	return md[x];
}
int dfs2(int x,int now) {
	if(md[mx2[x]]>=now) {
		return x;//如果有多于两个可以到now这个深度
	}
	if(!md[mx1[x]]||d[x]==now) {
		return x;//特判深度等于now及最大的儿子到不了这么远
	}
	return dfs2(mx1[x],now);//往儿子走
}
int main() {
	int x;
	n=read(),m=read();
	for(register int i=1; i<=n; i++) {
		f[i]=read();
		addedge(f[i],i);
	}
	dfs1(1,1);
	ans[0]=1;
	for(register int i=1; i<=maxd; i++) {
		ans[i]=dfs2(ans[i-1],i);//按照深度预处理
	}
	for(register int i=1; i<=m; i++) {
    		x=read();
		write(ans[x]);
		puts("");
	}
	return 0;
}
```  
最后，提示一下大家第二种想法（由于我无法证明复杂度正确性但是能过而没有写在题解里）按照每一个结点子树所覆盖的DFS序进行搜索。[备用标](https://www.luogu.com.cn/record/41450112)（完成题目后可查看）

---

## 作者：无尽星空 (赞：25)

##
## 前言

看见题解有 树剖 求 $LCA$ 过了加强的数据.

惊了，树剖 $(pao)$ 不是 $O(n log^2n)$ 吗？这是多么强悍的卡常大佬啊！

这里介绍一种代码短的板子做法.

##
## 正文

看见这题，第一眼想到了 $Tarjan$ 求 $LCA$ ( $Tarjan$ 老人家 $tql$ ).

### 没错，就是 $Tarjan$ .

```cpp
void add(int x,int y)  {e[++cnt].to=y;e[cnt].nx=h[x];h[x]=cnt;}
void qadd(int x,int y)  {qe[++qcnt].to=y;qe[qcnt].nx=qh[x];qh[x]=qcnt;}
int find(int p)  {return fa[p]==p?p:fa[p]=find(fa[p]);}
void tarjan(int x)
{
	vis[x]=1;
	for(int i=h[x];i;i=e[i].nx)
	{
		int u=e[i].to;
		if(vis[u])  continue;
		tarjan(u);fa[u]=x;
	}
	for(int i=qh[x];i;i=qe[i].nx)
	{
		int u=qe[i].to;
		if(vis[u])  lct[(i&1?(i+1):(i-1))]=lct[i]=find(u);
	}
}
```
就是这个 $Tarjan$ ！

不会 $Tarjan$ 求 $LCA$ 的同志请 [出门左转](https://www.cnblogs.com/JVxie/p/4854719.html)（不要看背景）.

但是 $Tarjan$ 是离线的，如果是 $Tarjan$ 可能无法处理（假如有三个深度为 $k$ 的点，最暴力的做法需要先求第一和第二个点的 $LCA$，再求 $LCA$ 和第三个点的 $LCA$）这样动态的询问.

似乎倍增可以应对动态询问，但妥妥 $TLE$ 到飞起（ 这题必须 $O(n+q)$ 呢 ），所以我们坚持 $Tarjan$ .

注意到 $Tarjan$ 求 $LCA$ 需要在要求 $LCA$ 的点上挂询问，那么，我们不妨开一个数组 $ans$，设当前点为 $x$ ，深度为 $d[x]$ ，则 $ans[d[x]]$ 表示处理到 $x$ 点之前所有深度为 $d[x]$ 的点的 $LCA$ , 那么这个数组就可以近似地认为是挂在点 $x$ 上的询问（实际上就是这样的）.

$dfs$ 到 $x$ 点时，若 $ans[d[x]]=0$ (之前没有深度为 $d[x]$ 的点），就令 $ans[d[x]]=x$ ，否则就像 $Tarjan$ 求 $LCA$ 一样令 $ans[d[x]]=find(ans[d[x]])$ .

其实就相当于 $Tarjan$ 求 $LCA$ 中的 $lct[i]=find(u)$ 这句：

```
for(int i=qh[x];i;i=qe[i].nx)
{
	int u=qe[i].to;
	if(vis[u])  lct[(i&1?(i+1):(i-1))]=lct[i]=find(u);
}
```
最后 $ans$ 数组存的就是答案 ( $ans[i]$ 就是所有深度为 $i$ 的点的 $LCA$ )

### 最后

上代码

###### ~~（可能这才是你最期待的）~~ ：

##### 代码真的挺短的

```cpp
#include<bits/stdc++.h>
#define R register int
using namespace std;
const int N=5e6+5;
int n,d[N],to[N],nx[N],h[N],fa[N],q,in,ans[N];
inline int read()//快读就不用说了吧
{
	int s=0;char c=getchar();
	while(!isdigit(c))  c=getchar();
	while(isdigit(c))  s=(s<<3)+(s<<1)+(c^48),c=getchar();
	return s;
}
int find(int p) {return fa[p]==p?p:fa[p]=find(fa[p]);}//并查集
void dfs(int x,int f)
{
	d[x]=d[f]+1;
	for(R i=h[x];i;i=nx[i])  dfs(to[i],x),fa[to[i]]=x;//tarjan 求LCA的合并
	ans[d[x]]=ans[d[x]]?find(ans[d[x]]):x;//核心部分，tarjan求LCA中的求答案部分
}
int main()
{
	n=read();q=read();
	for(R i=1;i<=n;i++)  fa[i]=i,in=read(),to[i]=i,nx[i]=h[in],h[in]=i;//读入+加边+并查集init
	dfs(1,0);
	while(q--)  printf("%d\n",ans[read()]);//O(1) 处理询问
	return 0;
}
```

##
### 感谢阅读

---

## 作者：itisover (赞：8)

介绍一个 $O(n)$ 的做法，是大佬[lsy](https://www.luogu.com.cn/user/100806)秒想到的，orz。

可以找到1个规律：
+ 所有深度的LCA都一定在最深点到树根的链上（显而易见）

有了这个规律，就可以直接从最深处一个一个点向上跳找LCA，判断这个点是不是这个深度的点的LCA，可以直接用dfn序来判断。


------------

实现：
+ 一遍dfs求dfn
+ 从深度最大的点一个一个向上跳找LCA
+ 询问，每次 $O(1)$ 输出


------------

题外话：

这题卡常很离谱，就连出题人的题解在你谷的评测机都可能会T，所以这里用了 ``fast io`` 和 ``register`` 卡了卡常，确保我的码能保证 $100$% 卡过。最后，这题卡树剖还是没卡掉，同机房的树剖在开大空间后用了fast io过了。


------------

码：

```cpp
#include<bits/stdc++.h>
using namespace std;
/* --------------- fast io --------------- */ // begin
namespace Fread {
  const int SIZE = 1 << 21;
  char buf[SIZE], *S, *T;
  inline char getchar() {
    if (S == T) {
      T = (S = buf) + fread(buf, 1, SIZE, stdin);
      if (S == T) return EOF;
    }
    return *S++;
  }
} // namespace Fread
namespace Fwrite {
  const int SIZE = 1 << 21;
  char buf[SIZE], *S = buf, *T = buf + SIZE;
  inline void flush() {
    fwrite(buf, 1, S - buf, stdout);
    S = buf;
  }
  inline void putchar(char c) {
    *S++ = c;
    if (S == T) flush();
  }
  struct NTR {
    ~ NTR() { flush(); }
  }ztr;
} // namespace Fwrite
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio {
  struct Reader {
    template<typename T>
    Reader& operator >> (T& x) {
      char c = getchar();
      T f = 1;
      while (c < '0' || c > '9') {
	if (c == '-') f = -1;
	c = getchar();
      }
      x = 0;
      while (c >= '0' && c <= '9') {
	x = x * 10 + (c - '0');
	c = getchar();
      }
      x *= f;
      return *this;
    }
    Reader& operator >> (char& c) {
      c = getchar();
      while (c == '\n' || c == ' ') c = getchar();
      return *this;
    }
    Reader& operator >> (char* str) {
      int len = 0;
      char c = getchar();
      while (c == '\n' || c == ' ') c = getchar();
      while (c != '\n' && c != ' ') {
	str[len++] = c;
	c = getchar();
      }
      str[len] = '\0';
      return *this;
    }
    Reader(){}
  }cin;
  const char endl = '\n';
  struct Writer {
    template<typename T>
    Writer& operator << (T x) {
      if (x == 0) { putchar('0'); return *this; }
      if (x < 0) { putchar('-'); x = -x; }
      static int sta[45];
      int top = 0;
      while (x) { sta[++top] = x % 10; x /= 10; }
      while (top) { putchar(sta[top] + '0'); --top; }
      return *this;
    }
    Writer& operator << (char c) {
      putchar(c);
      return *this;
    }
    Writer& operator << (char* str) {
      int cur = 0;
      while (str[cur]) putchar(str[cur++]);
      return *this;
    }
    Writer& operator << (const char* str) {
      int cur = 0;
      while (str[cur]) putchar(str[cur++]);
      return *this;
    }
    Writer(){}
  }cout;
} // namespace Fastio
#define cin Fastio :: cin
#define cout Fastio :: cout
#define endl Fastio :: endl
/* --------------- fast io --------------- */ // end
const int N=5e6+5;
int n,Q,ans[N],fa[N];
int hd[N],nx[N],to[N],tot;
void adde(int u,int v){
  nx[++tot]=hd[u];to[tot]=v;hd[u]=tot;
}
int dfn[N],mi[N],mx[N],ed[N],dep[N],dfstime,maxdep,dopoint;
void dfs(int v){
  dfn[v]=++dfstime;
  if(dep[v]>maxdep) maxdep=dep[v],dopoint=v;
  if(!mi[dep[v]]) mi[dep[v]]=mx[dep[v]]=dfn[v];
  else mi[dep[v]]=min(mi[dep[v]],dfn[v]),mx[dep[v]]=max(mx[dep[v]],dfn[v]);
  for(register int i=hd[v];i;i=nx[i]){
    register int u=to[i];
    dep[u]=dep[v]+1;
    dfs(u);
  }
  ed[v]=dfstime;
}
bool checkin(int x,int y){
  return x>=dfn[y]&&x<=ed[y];
}
int main(){
  cin>>n>>Q;
  for(int i=1;i<=n;i++){
    cin>>fa[i];
    if(fa[i]) adde(fa[i],i);
  }
  dep[1]=1;dfs(1);
  for(int i=maxdep;i>=1;i--){
    while(!checkin(mi[i],dopoint)||!checkin(mx[i],dopoint)) dopoint=fa[dopoint];
    ans[i]=dopoint;
  }
  while(Q--){
    int k;
    cin>>k;
    cout<<ans[k]<<endl;
  }
  return 0;
}
```



---

## 作者：素质玩家孙1超 (赞：7)

为什么 5 篇题解 3 篇过不去加强数据……

---

题意：给一个树，多次询问所有深度为 $k$ 的节点的 $\rm LCA$ 。

$n\leq 5\times 10^6$ 。

时限：$\texttt{1.2s}$ 。


---

正解当然是 $O(n)$ 的，但是我这篇题解讲的并不是正解，而是实际运行速度相当可以的 $n\log n$ 的直接 $\rm LCA$ 做法，和他的常数优化。

这里用的是树剖求 $\rm LCA$ ，当然倍增求铁 $\rm MLE$，并且倍增是跑满 $\log $ 的。

#### 1. $\texttt{优化1}$：

在数据为 $5\times 10^6$ 的情况下， $\rm dfs$ 一遍树所话的时间是 $\rm 0.8s$ 左右（这里使用的是标程的 $\rm dfs$），也就是说，两遍 $\rm dfs$ 时间就不够了，甚至比后面带 $\log $ 的部分还慢。

考虑优化 $\rm dfs$，第一个$\rm dfs$ 里有从儿子转移的部分，若要模拟可能有些麻烦（可以用栈模拟，但不知道时间是否更快），若是搞个队列正着一遍，反着一遍那更是速度比 $\rm dfs$ 还慢。但是第二个 $\rm dfs$ 却所有转移都是父亲到儿子的，所以直接用队列模拟即可（实测 $\rm STL $ 的 queue 比手写的数组快）。

其中 @荣耀南冥 巨佬用的长链剖分，将第二遍 $\rm dfs$ 剪枝实测也可以过。
#### 2. $\texttt{优化2}$：

在统计答案的时候不 $\rm dfs$，而是直接遍历每个点，一次性把所有点统计，我在统计的时候还搞了个循环展开，不知实际优化效果如何 。


#### 3. $\texttt{优化3}$：

统计答案的时候每次把 $ans[dep[x]]$ 和 $x$ 取 $\rm LCA$ 的时候，若$ans[dep[x]]$  是 $x$ 的祖先，则可不必操作。

询问是否有祖先关系，可以用两个 $\rm dfn$ 数组搞定（一个记录第一次到这个点的时间戳，一个记录回溯到这个点的时间戳）。

#### 4. $\texttt{优化4}$：

加边的时候记得只加父亲到儿子的单向边。

#### 5. $\texttt{优化5}$：

这题大量读入/输出，使用比较快的读入/输出模板。

---

大概就是这么些小优化，合起来过了此时的数据 $n \leq 5\times 10^6$ ，$1.2s$ ，然而标程最慢的点也跑了 $\rm 973ms$，标程是 $O(n)$的。 

代码只放部分，舍去读入输出模板，这个东西花了我 $\rm 2h$ ，本人卡常技术不佳，望读者见谅。

```cpp
#define For(pos) for(register int k=First[pos];k;k=Next[k])
inline void add(int z,int y)
{
    Next[++cnt]=First[z];
    First[z]=cnt;
    to[cnt]=y;
}
void dfs1(int p,int dep,int father)
{
	dfn1[p]=++dfn1[0];
    depth[p]=dep;
    fa[p]=father;
    int maxv=-1;
    siz[p]=1;
    For(p)
        {
            dfs1(to[k],dep+1,p);
            siz[p]+=siz[to[k]];
            if(siz[to[k]]>maxv)
            {
                maxv=siz[to[k]];
                son[p]=to[k];
            }
        }
    dfn2[p]=dfn1[0];
}
int LCA( int x, int y)
{
    while(top[x]!=top[y])
    (depth[top[x]]>=depth[top[y]])? x=fa[top[x]]:y=fa[top[y]];
    return depth[x]<depth[y]?x:y;
}
void work()//跑出每个点对应深度的LCA
{
	int pos=1;
	for(;pos+6<=n;pos+=6)
	{
	if(ANS[depth[pos]]!=1)
	{
		if(!ANS[depth[pos]])ANS[depth[pos]]=pos;
		else if(dfn1[ANS[depth[pos]]]>dfn1[pos]||dfn2[ANS[depth[pos]]]<dfn2[pos])//如果没有祖先关系
		ANS[depth[pos]]=LCA(pos,ANS[depth[pos]]);
	}
	if(ANS[depth[pos+1]]!=1)
	{
		if(!ANS[depth[pos+1]])ANS[depth[pos+1]]=pos+1; 
		else if(dfn1[ANS[depth[pos+1]]]>dfn1[pos+1]||dfn2[ANS[depth[pos+1]]]<dfn2[pos+1])
		
		ANS[depth[pos+1]]=LCA(pos+1,ANS[depth[pos+1]]);
	}
	if(ANS[depth[pos+2]]!=1)
	{
		if(!ANS[depth[pos+2]])ANS[depth[pos+2]]=pos+2; 
		else if(dfn1[ANS[depth[pos+2]]]>dfn1[pos+2]||dfn2[ANS[depth[pos+2]]]<dfn2[pos+2])
		
		ANS[depth[pos+2]]=LCA(pos+2,ANS[depth[pos+2]]);
	}
	if(ANS[depth[pos+3]]!=1)
	{
		if(!ANS[depth[pos+3]])ANS[depth[pos+3]]=pos+3; 
		else if(dfn1[ANS[depth[pos+3]]]>dfn1[pos+3]||dfn2[ANS[depth[pos+3]]]<dfn2[pos+3])
		
		ANS[depth[pos+3]]=LCA(pos+3,ANS[depth[pos+3]]);
	}
	if(ANS[depth[pos+4]]!=1)
	{
		if(!ANS[depth[pos+4]])ANS[depth[pos+4]]=pos+4; 
		else if(dfn1[ANS[depth[pos+4]]]>dfn1[pos+4]||dfn2[ANS[depth[pos+4]]]<dfn2[pos+4])
		
		ANS[depth[pos+4]]=LCA(pos+4,ANS[depth[pos+4]]);
	}
	if(ANS[depth[pos+5]]!=1)
	{
		if(!ANS[depth[pos+5]])ANS[depth[pos+5]]=pos+5; 
		else if(dfn1[ANS[depth[pos+5]]]>dfn1[pos+5]||dfn2[ANS[depth[pos+5]]]<dfn2[pos+5])
		
		ANS[depth[pos+5]]=LCA(pos+5,ANS[depth[pos+5]]);
	}
	}
	for(;pos<=n;pos++)
	if(ANS[depth[pos]]!=1)
	{
		if(!ANS[depth[pos]])ANS[depth[pos]]=pos;
		else 
		if(dfn1[ANS[depth[pos]]]>dfn1[pos]||dfn2[ANS[depth[pos]]]<dfn2[pos])
		ANS[depth[pos]]=LCA(pos,ANS[depth[pos]]);
	}
}
int main(){
	n=read();m=read();
	x=read();
	for(register int i=2;i<=n;i++)add(read(),i);
	dfs1(1,1,0);
	queue<pair<int,int > >q;
	q.push(make_pair(1,1));
	pair<int,int>p;
	while(!q.empty())
	{
		p=q.front();
		q.pop();
		top[p.first]=p.second;
    	For(p.first)
    	q.push(make_pair(to[k],to[k]==son[p.first]?p.second:to[k]));
	}
	work();
	while(m--) write(ANS[R()]),puts("");
}
```



---

## 作者：Asrit (赞：5)

由于本蒟蒻LCA功底太差，只会倍增LCA，看到这道题就想了些奇怪的做法。

以下指的长度都是指子树最深的深度，某个点的子树包含这个点。

对于一个节点，如果它的次长儿子在第$k$层还有节点，那么它的子树上第k层的LCA就是这个节点。

（为什么呢？如果第$k$层上有节点并且它的次长儿子在第$k$层上没有节点，那第$k$层的节点只会在他最长儿子上，那LCA会在最长儿子和最长儿子的子树上取得而不会是这个节点。）

这样，我们只需要处理出每个节点的最长儿子的长度和次长儿子的长度，然后找到这棵树最长链，用最长链上的点来得出每一层的答案，输出即可。

如果上面说的不是很清楚，不太理解的话请看代码：

```cpp
#include<iostream>
#include<cstdio>
#define rep(i,a,b) for(register int i=(a);i<=b;i++)
#define rop(i,a,b) for(register int i=(a);i<b;i++)
#define per(i,a,b) for(register int i=(a);i>=b;i--)
#define por(i,a,b) for(register int i=(a);i>b;i--)
using namespace std;
int n,m,q,cnt,cntt,maxd,maxi,fa[5000006],dep[5000006],m2xk[5000006],maxk[5000006],ans[5000006],lian[5000006],h[5000006];
//cnt是处理答案时枚举到的深度，cntt是链式前向星用到的，maxd是最深的深度，maxi是最深的点，fa[x]是x的父亲，dep[x]是x的深度，maxk[x]是x的最长子树的长度，m2xk[x]是x的次长子树的长度，ans[x]是深度为x时的答案，lian[x]是最长链，h[x]是链式前向星用到的。

struct node{	//链式前向星
	int nx,to;
}e[5000006];

void add(int x,int y){	//加边
	cntt++;
	e[cntt].nx=h[x];
	e[cntt].to=y;
	h[x]=cntt;
}

inline int read(){	//快读
	int s=0;char c=getchar();
	while(!isdigit(c))  c=getchar();
	while(isdigit(c))  s=(s<<3)+(s<<1)+(c^48),c=getchar();
	return s;
}

void dfs(int x){
	dep[x]=dep[fa[x]]+1;	//x节点的深度是x的父亲+1
	if(dep[x]>=maxd)	maxd=dep[x],maxi=x;		//找最大深度和它的编号（加不加=都行）
	for(int i=h[x];i;i=e[i].nx){
		dfs(e[i].to);	//dfs儿子
		m2xk[x]=max(m2xk[x],maxk[e[i].to]+1);	//如果现在子树比次长子树长，次长子树变为现在子树。
		if(m2xk[x]>maxk[x])	swap(m2xk[x],maxk[x]);	//如果次长子树比最长子树长了，交换。经过这两步就可以求出次长子树的最长子树的长度了
	}
}

void find(int x){	//找最长链
	lian[dep[x]]=x;
	if(fa[x])	find(fa[x]);
}

int main(){
	n=read();m=read();
	rep(i,1,n){
		fa[i]=read();
		add(fa[i],i);	//建从父亲到儿子的边
	}
	dfs(1);	//从根开始dfs
	find(maxi);	//从最深点找最长链
	rep(i,1,maxd){
		while(cnt+m2xk[lian[cnt]]<i)	cnt++;	//从链的最顶端开始往下，如果当前点的深度+次长子树的长度不能到达i这个深度，说明第i层的LCA在它的最长子树上，那么到链的下一个点
		ans[i]=lian[cnt];	//能到达答案就是这个点
	}
	rep(i,1,m){
		q=read();
		printf("%d\n",ans[q]);
	}
	return 0;
}
```

不难看出，复杂度$O(N+N+K+2K+M)$($K$是最大深度)。

## 注意：

1.不要读入时计算$dep$，父亲编号可能大于该点编号。

2.不要用$vector$存图！！！！！时空被卡了好久，改用链式前向星瞬间过。

（$vector$是人类发明的最无用的STL。——〇佬）

（其实还是有那么一点点用的kk）

---

## 作者：Farkas_W (赞：4)

$$\text{前言}$$

$\quad$~~毒瘤出题人造的什么鬼数据，硬生生变成一道卡常题，我足足交了一页才过的。~~

$$\text{关于此题}$$

$\quad$先说说 $80$ 分做法，就是数据加强前 $100$ 分做法，现在被卡了，会T最后一个点。

$\quad$就是简单的树剖求LCA，在手推样例中可以发现对于同一深度的点的LCA就是这一层深度中最左和最右的点的LCA，即同一深度中dfs序最小的和最大的点的LCA，这个性质一发现就可以快速求出答案了。

$\quad$因为是错解，所以只展示部分代码。(据说机房 $dalao$ [@slzs](https://www.luogu.com.cn/user/109212) 用树剖 $+$ fast io卡过了)
```cpp

il void dfs1(int x,int fa)
{
  dep[x]=dep[fa]+1;size[x]=1;
  if(!ans[dep[x]][0])ans[dep[x]][0]=x;//记录最先搜到的点，dfs序最小
  else ans[dep[x]][1]=x;//记录最后搜到的点，dfs序最大
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      dfs1(y,x);size[x]+=size[y];
      if(size[y]>size[son[x]])son[x]=y;
    }
}
il void dfs2(int x,int topf)
{
  top[x]=topf;
  if(!son[x])return;
  dfs2(son[x],topf);
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      if(y==son[x])continue;
      dfs2(y,y);
    }
}
il int LCA(int x,int y)
{
  int fx=top[x],fy=top[y];
  while(fx!=fy)
    {
      if(dep[fx]<dep[fy])y=father[fy],fy=top[y];
      else x=father[fx],fx=top[x];
    }if(dep[x]>dep[y])return y;
  return x;
}
signed main()
{
  n=read();m=read();
  for(re i=1,x;i<=n;i++){x=read();if(i>1)father[i]=x,Add(x,i);}
  dfs1(1,0);dfs2(1,1);
  for(re i=1,x;i<=m;i++)
    {
      x=read();
      if(!ans[x][1])print(ans[x][0]);
      else print(LCA(ans[x][0],ans[x][1]));putchar('\n');}
  return 0;
}
```

$\quad$现在再来说说正解。

$\quad$在 [@lyyi2003](https://www.luogu.com.cn/user/100806#practice) $dalao$ 的提示下，我又发现了答案的一个性质，所有答案(就是各个深度的点的公共LCA)在一条链上，因为深度大的点是由深度小的点扩展得到的(显然，下面的点是由上面的点扩展而来的)，所以对于两个不同的深度 $i,j$ ，满足 $i<j$，可以发现深度为 $i$ 的点的公共LCA一定是深度为 $j$ 的点的公共LCA。

$\quad$发现这个性质后就很好做了，只需要找到这条链即可，不用特意找，从深度最大的点循环上来即可，每次判断这个点的子树中是否包含所有同一深度的点，看代码更好理解。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define re register int
#define il inline
#define next nee
il int read()
{
  int x=0,f=1;char ch=getchar();
  while(!isdigit(ch)&&ch!='-')ch=getchar();
  if(ch=='-')f=-1,ch=getchar();
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
  return x*f;
}
il void print(int x)
{
  if(x<0)putchar('-'),x=-x;
  if(x/10)print(x/10);
  putchar(x%10+'0');
}
const int N=5e6+5;
int n,m,ans[N],dep[N],seg[N],size[N],f[N][2],next[N],go[N],father[N],head[N],tot,Maxdep;
il void Add(int x,int y)
{
  next[++tot]=head[x];
  head[x]=tot;go[tot]=y;
}
il void dfs(int x,int fa)
{
  dep[x]=dep[fa]+1;size[x]=1;seg[x]=++seg[0];
  if(dep[x]>Maxdep)Maxdep=dep[x],f[dep[x]][0]=f[dep[x]][1]=x;//记录最先搜到的点，dfs序最小
  else f[dep[x]][1]=x;//记录最后搜到的点，dfs序最大
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      dfs(y,x);size[x]+=size[y];
    }
}
il bool check(int x,int y)//判断x是否在y的子树中
{return seg[x]>=seg[y]&&seg[x]<=seg[y]+size[y]-1;}
signed main()
{
  n=read();m=read();
  for(re i=1,x;i<=n;i++){x=read();if(x)Add(x,i),father[i]=x;}
  dfs(1,0);
  int cte=f[Maxdep][0];
  for(re i=Maxdep;i>=1;i--)//统计答案
    {
      while(!check(f[i][0],cte)||!check(f[i][1],cte))cte=father[cte];//向上跳直到一个点将深度为i的所有点包含
      ans[i]=cte;
    }
  for(re i=1,x;i<=m;i++)
    {x=read();print(ans[x]);putchar('\n');}
  return 0;
}

```
$\quad$最后如果还是卡不过去，推荐使用[高级快读(fast io)](https://www.luogu.com.cn/paste/efcyocpd)，可以让你们的速度更上一层楼(700ms+变成500ms+)。

---

## 作者：BJEA赵子潇 (赞：3)

### 题意：
给定一棵树，多次询问这棵树所有第k层节点的LCA（最近公共祖先）$n\le 5*10^6，m<=n$

### 提供一种好像有点奇怪的做法

$Max[i]$表示编号为$i$的点的子树最大深度，$aMax[dep]$表示深度为$dep$的所有节点的子树最大深度的最大值，$acMax[dep]$表示深度为$dep$的所有节点子树最大深度的次大值。

考虑一个节点能作为某层节点LCA的要求：

如果$acMax[dep[i]]==0$，意味着同一层只有它这一个节点。那么所有深度在$[dep[i],Max[i]]$层的节点，如果$i$的儿子没有作为这些层的LCA，那么$i$就作为这些层的LCA

如果$acMax[dep[i]]!=0$，意味着同一层$i$还有兄弟。那么所有深度在$[acMax[dep[i]]+1,Max[i]]$层的节点，如果$i$的儿子没有作为这些层的LCA，那么$i$就作为这些层的LCA

对于当前点，在枚举作为哪个深度层所有点的LCA时，一旦遇到了第一个**儿子已经成为该层节点的LCA**时，就break，因为再深的点一定也有LCA了。这样保证了时间复杂度$O(n)$


---

## 作者：tommymio (赞：3)

这个深度为 $k$ 的所有点的 $\text{LCA}$，事实上是求一个深度最小的点包含所有深度为 $k$ 的点。可以想到用桶？但是桶必须暴力遍历，时间复杂度是 $O(n^2)$ 的。考虑换一种方法。

我们发现有性质：若点 $x$ 是深度为 $i$ 的所有点的 $\text{LCA}$，则它必然也是深度为 $j$ 的所有点的 $\text{LCA}$，其中 $i<j$。这样我们可以发现，答案分布在一条链上，链的一个端点是某个深度最大的点，另一个点是根节点 $1$。从深度最大的点开始向上跳到根节点 $1$，判断当前点 $x$ 的子树是否包含所有深度为 $d$ 的点，时间复杂度为 $O(n)$，对时间复杂度的分析同 $\text{two-pointer}$。而判断一个点 $y$ 是否在子树 $x$ 内，使用 $\text{dfs}$ 序即可。

```cpp
#include<cstdio>
int mx=0,num=0,cnt=0;
int h[5000005],to[5000005],ver[5000005];
int dfn[5000005],pos1[5000005],pos2[5000005],dep[5000005],res[5000005],fa[5000005],size[5000005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void add(int x,int y) {to[++cnt]=y;ver[cnt]=h[x];h[x]=cnt;}
inline void dfs(int x) {
	dfn[x]=++num; size[x]=1;
	if(mx<dep[x]) {mx=dep[x];}
	if(!pos1[dep[x]]) pos1[dep[x]]=x;
	else pos2[dep[x]]=x;
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i]; 
		dep[y]=dep[x]+1; 
		dfs(y); size[x]+=size[y];
	}
}
int main() {
	int n=read(),Q=read();
	for(register int i=1;i<=n;++i) {fa[i]=read(); add(fa[i],i);} 
	dep[1]=1; dfs(1); int cur=(pos2[mx]? pos2[mx]:pos1[mx]);
	for(register int d=mx;d>=1;--d) {
		int x=pos1[d],y=pos2[d];
		while(!(dfn[cur]<=dfn[x]&&dfn[x]<=dfn[cur]+size[cur]-1)||!((!y)||(dfn[cur]<=dfn[y]&&dfn[y]<=dfn[cur]+size[cur]-1))) cur=fa[cur];
		res[d]=cur;
	}
	while(Q--) {int x=read(); printf("%d\n",res[x]);}
	return 0;
}
```

---

## 作者：荣耀南冥 (赞：3)

# P7103 「C.E.L.U-01」族谱树

[原题传送门](https://www.luogu.com.cn/problem/P7103)

PS: 打比赛的时候过了这道题，后来应该是数据加强了，长剖被卡了，T了，~~(大雾)~~，然后我灵机一动，想到了优化，然后成功过掉了，然后数据加强到 5e6 又被卡了，卡了一天终于想到办法了，于是写一篇题解纪念一下。

首先根据题中的意思，就是要求图中各个深度的 $ LCA$ ，$ LCA $一般用树剖（一般是重链剖分）和倍增 $ LCA $ 来求，这里不再赘述，首先会树剖 $ LCA $ 的都会知道一个性质 
> 一个点与树上任意店的LCA一定在这个点到根节点的路径上（包括这个点和根节点）

既然如此，根据这条性质，我们发现最终所有深度的 $ LCA $ 必定在这条最长的链上，道理很简单，通过染色法我们可以发现求两个点的 $ LCA $ 就是是这个点到根路径的重合部分的深度最大值的点，拓展一下，多个点的 $ LCA $ 就是求多个点到根节点路径重合部分的深度最大值的点，又因为最长链上必定会出现所有深度的点，所以答案就必定在最长链，那么我们就想到直接长链剖分，暴力向最长链跳，跳到最长链后更新这个深度的答案，数据加强前应该可拿60分

$Code$
```cpp
register int k;
for(register int i=1;i<=n;++i){
	k=i;
	while(top[k]!=1)k=f[top[k]];
	if(dep[k]<dep[ans[dep[i]]])ans[dep[i]]=k;
}
```
复杂度我不会太分析，大概是也是 $ O(nlogn)  $ 吧。反正 $ O(过不了，会被卡) $ 就完了。

考虑优化，我们可以在第二遍 DFS 的时候更新这个点到最长链第一个点，用 $ f $ 数组保存，可知，最长链上的点 $ f $ 为自身，如果不是，那 $ f $ 值就是 $ f[ \ top \ ] $
```cpp
#define v edge[i].to
void dfs(register int u,register int fa){
	ddep[u]=dep[u]=dep[fa]+1;//ddep数组表示能够到达的最大深度
	for(register int i=head[u];i;i=edge[i].next){
		if(dep[v])continue;
		dfs(v,u);
		if(ddep[v]>ddep[u])ddep[u]=ddep[v],son[u]=v;
	}
}

void DFS(register int u,register int fa,register bool ff){//ff表示是否是在最长链上
	top[u]=fa;vs[u]=1;
	if(son[u])DFS(son[u],fa,ff);
	if(!ff)f[u]=f[fa];
	for(register int i=head[u];i;i=edge[i].next){
		if(vs[v])continue;
		DFS(v,f[u],0);
	}
}
#undef v
```
最后更新答案就是 $ O(n) $ ，但是丧心病狂的出题人把数据加强到 5e6 ，导致一遍DFS的时间变成了大约 0.8 秒，这就导致树剖的两遍 DFS 会直接 T 掉，而 DFS1 是基本不可减枝的，于是我们考虑在 DFS2 减枝，我们发现在 DFS2 中，我们并不需要遍历所有的点了，我们只需要遍历最长链上的点，对于不是最长链上的点，我们只关心他对应的最长链上的第一个点是谁，所以我们每次从最长链上的点 u 遍历到不是最长链的点 v 时，只需要记录 u ，然后更新 dep[v] 到 v 所在的链能够到达的最大深度的答案是谁即可，统计完之后直接 return 。时间效率优化了许多。上次刚出现的 $ f $ 数组可以光荣退役了。由于是在 DFS2 直接更新答案，于是我们的 top 数组也可以光荣退役了 ~~（没有 top 数组的树剖还能叫树剖吗）~~ 。最大的点跑了0.7秒左右，至于为什么我的代码吸氧之后变慢了 3ms 我也说不明白，~~(大概是卡常卡太死了)~~这道题最好用快输， 5e6 的输出感觉 printf 有点吃力

修改后的 DFS2 
```cpp
void DFS(register int u,register int fa,register bool ff){
	if(!ff){
		for(int i=dep[u];i<=ddep[u];++i)
			if(dep[fa]<dep[ans[i]])ans[i]=fa;
		return;
	}else if(dep[fa]<dep[ans[dep[u]]])ans[dep[u]]=fa;
	for(register int i=head[u];i;i=edge[i].next){
		if(v==son[u]&&ff)DFS(v,v,1);
		else DFS(v,fa,0);
	}
}
```

下面奉上完整 $ Code $
```cpp
#include <bits/stdc++.h>
using namespace std;
#define gc() (p1 == p2 ? (p2 = buf + fread(p1 = buf, 1, 1 << 20, stdin), p1 == p2 ? EOF : *p1++) : *p1++)
#define read() ({ register int x = 0, f = 1; register char c = gc(); while(c < '0' || c > '9') { if (c == '-') f = -1; c = gc();} while(c >= '0' && c <= '9') x = x * 10 + (c & 15), c = gc(); f * x; })
char buf[1 << 20], *p1, *p2;

const int maxn=5e6+10;
struct node{
	int to,next;
}edge[maxn];
int head[maxn],dep[maxn],ans[maxn],ddep[maxn],son[maxn];

void print(register int x){
	if(x>=10)print(x/10);
	putchar(x%10+'0');
}

inline void add(register int x,register int y,register int z){
	edge[z]=(buyaochao){y,head[x]};
	head[x]=z;
}

#define v edge[i].to
void dfs(register int u,register int fa){
	dep[u]=dep[fa]+1;
	for(register int i=head[u];i;i=edge[i].next){
		dfs(v,u);
		if(ddep[v]>ddep[u])ddep[u]=ddep[v],son[u]=v;
	}
	if(!ddep[u])ddep[u]=dep[u];
}

void DFS(register int u,register int fa,register bool ff){
	if(!ff){
		for(int i=dep[u];i<=ddep[u];++i)
			if(dep[fa]<dep[ans[i]])ans[i]=fa;
		return;
	}else if(dep[fa]<dep[ans[dep[u]]])ans[dep[u]]=fa;
	for(register int i=head[u];i;i=edge[i].next){
		if(v==son[u]&&ff)DFS(v,v,1);
		else DFS(v,fa,0);
	}
}
#undef v

int main(){
	register int n=read(),m=read();
	for(register int i=1;i<=n;++i){
		add(read(),i,i);
	}dep[0]=0x3f3f3f3f;
	dfs(1,1);DFS(1,1,1);
	for(register int i=1;i<=m;++i)
		print(ans[read()]),putchar('\n');
	return 0;
}
```
祝大家 noip  rp++

---

## 作者：cmll02 (赞：2)

提供一个长剖做法。

长剖可以快速维护出一个点子树的深度信息。

这个题很显然，

先一次记录下每个深度有多少个点。

只要在合并轻儿子的时候判断这个深度的点有没有全在这棵子树里。

```cpp
#include <stdio.h>
#include <string.h>
#define odl(x) printf("%d\n",x)
inline int read()
{
	int num=0,f=1;char c=getchar();
	while(c<48||c>57){if(c=='-')f=-1;c=getchar();}
	while(c>47&&c<58)num=num*10+(c^48),c=getchar();
	return num*f;
}
struct Edge{
	int v,nxt;
}e[10000005];
int h[10000005],cnt=1;
inline void addedge(int u,int v)
{
	e[cnt]=(Edge){v,h[u]};
	h[u]=cnt++;
}
int buf[10000005],ans[10000005],dep[10000005],son[10000005],Q[10000005];
int *f[10000005],*g[10000005],*now=buf;
void dfs(int u,int fa=0,int s=1)
{
	for(int i=h[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa)continue;
		dfs(v,u,s+1);
		if(dep[v]>dep[son[u]])son[u]=v;
	}
	dep[u]=dep[son[u]]+1;
	Q[s]++;
}
void dfs2(int u,int fa=0,int s=1)
{
    f[u][0]=1;
    if(Q[s]==1)ans[s]=u;
    if(son[u])
    {
        f[son[u]]=f[u]+1;
        dfs2(son[u],u,s+1);
    }
    for(int i=h[u];i;i=e[i].nxt)
    {
        int v=e[i].v;
        if (v==son[u]||v==fa)continue;
        f[v]=now;now+=dep[v];
        dfs2(v,u,s+1);
        for (int i=1;i<=dep[v];i++)
        {
            f[u][i]+=f[v][i-1];
            if(f[u][i]==Q[s+i])ans[s+i]=u;
        }
    }
}
signed main()
{
	int n=read(),m=read();
	for(int i=1;i<=n;i++){int x=read();addedge(x,i);}
	dfs(1);f[1]=now,now+=dep[1];
	dfs2(1);
	for(int i=1;i<=m;i++)odl(ans[read()]);
	return 0;
}
```

---

## 作者：wenye05 (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P7103)

upd:继续完善了下题解，改了格式，希望这次能过。

感谢出题人给我们出了一道卡时间好题，让我在这题上感受到了坚持不懈的精神

给大家看看，出题人所行的善事

![](https://cdn.luogu.com.cn/upload/image_hosting/dtuicvhm.png)

[关于如何让出题人甘心](https://www.luogu.com.cn/record/42531508)

# Solve 1

当你辛辛苦苦发现某条性质——

第 $k$ 层 dfn 最小与 dfn 最大的两点的 lca 即为答案（显然这个 lca 可将第 $k$ 层 dfn 值处于中间水平的那些点囊括进子树，且"最近"也是显然的）

然后激动地**调**出了树剖

如下

## code

```cpp
#include<vector>
#include<cstdio>
using namespace std;
inline int read() {
    int num=0;
    char c=getchar();
    while(c<'0' || c>'9')c=getchar();
    while(c>='0' && c<='9') {
        num=(num<<3)+(num<<1)+c-'0';
        c=getchar();
    }
    return num;
}
struct Edge{
	int to,nxt;
}e[5000005];
int n,m,head[5000005],cnt,siz[5000005],fa[5000005],top[5000005],son[5000005],dep[2][5000005],dpth[5000005];
inline void insert( int u,int v) {
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
inline void dfs (int u,int depth ) {
	//dep[0][depth]存储当前层dfn最小的点，dep[1][depth]与之相反
	if(!dep[0][depth])dep[0][depth]=u;
	dep[1][depth]=u;
    dpth[u]=depth;
	int mx=-1,mxs;
	for(int i=head[u];i;i=e[i].nxt){
		dfs(e[i].to,depth+1);
		siz[u]+=siz[e[i].to]+1;//siz存储子树大小，不包括当前节点
		if(siz[e[i].to]>mx)mx=siz[e[i].to],mxs=e[i].to;
	}
	son[u]=mxs;
}
void dfs1(int u){
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==son[u])top[v]=top[u];
        else top[v]=v;
        dfs1(v);
    }
}
inline int lca(int x,int y)
{
    if(x==y)return x;
    while(top[x]!=top[y]){
        if(dpth[top[x]]<dpth[top[y]])swap(x,y);
        x=fa[top[x]];
    }
    return dpth[x]>dpth[y]?y:x;
}
int main() {
    n=read();m=read();
    for(int i=1;i<=n;i++) {
        fa[i]=read();
    	insert(fa[i],i);
	}
	cnt=0;
	dfs(1,1);
	top[1]=1;
	dfs1(1);
	while(m--) {
		int k=read();
		printf("%d\n",lca(dep[0][k],dep[1][k]));
	}
    return 0;
}
```

结果只因毒瘤出题人加强了数据而以失败告终。

# Solve 2

不难发现，答案点均在一探到最深的链上，如果这样的链有多条，也不需管具体是哪条，因为这条链上点在树上各个层都有分布，而所求第 $k$ 层lca必然是第 $k$ 层点的祖先，故在这条链上取第 $k$ 层点，由其向上找祖先，再结合Solve 1找到的那个关于dfn的性质就可以了。

不过这样还是不能过，于是我们还可以找到另一层性质。

第 $k$ 层祖先深度一定不大于第 $k+1$ 层祖先。因为第 $k$ 层祖先一定是第 $k+1$ 层祖先，所以第 $k+1$ 层祖先顶多只会离下面更近而不会比第 $k$ 层祖先更靠上。当然，考虑的是第 $k+1$ 层存在的情况。

通过这条性质，就可以像std一样类似dp来做了。当然，寻找方向相反。

## code

```cpp
#include<vector>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
inline int read() {
    int num=0;
    char c=getchar();
    while(c<'0' || c>'9')c=getchar();
    while(c>='0' && c<='9') {
        num=(num<<3)+(num<<1)+c-'0';
        c=getchar();
    }
    return num;
}
struct Edge{
	int to,nxt;
}e[5000005];
int n,m,head[5000005],cnt,dfn[5000005],siz[5000005],fa[5000005],lca[5000005],mxdp,dep[2][5000005],dpth[5000005];
inline void insert( int u,int v) {
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
inline void dfs (int u,int depth ) {
    dfn[u]=++cnt;
	if(!dep[0][depth])dep[0][depth]=u;
	dep[1][depth]=u;
    dpth[u]=depth;
    mxdp=max(mxdp,depth);
	for(int i=head[u];i;i=e[i].nxt){
		dfs(e[i].to,depth+1);
		siz[u]+=siz[e[i].to]+1;
	}
}
int main() {
    n=read();m=read();
    for(int i=1;i<=n;i++) {
        fa[i]=read();
    	insert(fa[i],i);
	}
	cnt=0;
	dfs(1,1);
	lca[mxdp+1]=dep[0][mxdp];
	for(int i=mxdp;i;i--){
		int u = lca[i+1];
		while(dfn[dep[0][i]]<dfn[u] || dfn[dep[1][i]]>dfn[u]+siz[u])u=fa[u];
		lca[i]=u;
	}
	while(m--) {
		int k=read();
		printf("%d\n",lca[k]);
	}
    return 0;
}
```

感谢观看！

---

## 作者：yewanxingkong (赞：1)

一道究极离谱卡空间卡时间题。

//出题人又加强了数据。。。那我只好讲讲正解了。

# **80分解题思路**
这道题我觉得仔细想想暴力思路就出来了。把第 $k$ 层所有的点都求一遍 $lca$ 然后记录下来，最后 $O(1)$ 查询输出。时间复杂度 $O(nlogn)$ ，理论上是能卡过的。

一开始我用的倍增，但是最后几个点全部 $MLE$ 。然后发现毒瘤出题人把空间给卡了。在一番思索后我想到了树剖。

树剖 $lca$ 并不占太多空间，而且常数很小。我试了一下发现完全可过。但是常数方面还是要好好卡一下的。

下面是代码
```cpp
#include<iostream>
#include<cstdio> 
#include<cstring>
#include<vector>
using namespace std;
int n,m,f[3000010],dep[3000010],top[3000010],hd[3000010];
int maxn,zu[3000010],siz[3000010],zher[3000010],ji;
struct nod{
	int xu,nxt;
}cun[3000010];
inline void add(int x,int y){
	cun[++ji].xu=y;
	cun[ji].nxt=hd[x];
	hd[x]=ji;
}
inline void dfs1(int xu){
	dep[xu]=dep[f[xu]]+1;
	siz[xu]=1;
	int maxn=-1;
	for(int i=hd[xu];i;i=cun[i].nxt)
		if(cun[i].xu!=f[xu]){
			dfs1(cun[i].xu);
			siz[xu]+=siz[cun[i].xu];
			if(siz[cun[i].xu]>maxn){
				maxn=siz[cun[i].xu];
				zher[xu]=cun[i].xu;
			}
		}
}
inline void dfs2(int xu,int topp){
	top[xu]=topp;
	if(!zher[xu])return;
	dfs2(zher[xu],topp);
	for(int i=hd[xu];i;i=cun[i].nxt)
		if(cun[i].xu!=f[xu]&&cun[i].xu!=zher[xu])
			dfs2(cun[i].xu,cun[i].xu);
}
inline int LCA(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	return x;
}
inline int read(){
	int date=0,W=1;char ch=0;
	while(!isdigit(ch)){if(ch=='-')W=-1;ch=getchar();}
	while(isdigit(ch)){date=date*10+ch-'0';ch=getchar();}
	return date*W;
}
int main(){
    n=read();
    m=read();
    for(int i=1;i<=n;++i){
    	int x=read();
    	add(x,i);
    	f[i]=x;
	}
	dfs1(1);
	dfs2(1,1);
	for(int i=1;i<=n;++i)
		if(!zu[dep[i]])zu[dep[i]]=i;
		else{
			int x=zu[dep[i]],y=i;
			while(top[x]!=top[y]){
				if(dep[top[x]]<dep[top[y]])swap(x,y);
				x=f[top[x]];
			}
			zu[dep[i]]=dep[x]<dep[y]?x:y;
		}
	for(int i=1;i<=m;++i)
		printf("%d\n",zu[read()]);
    return 0;
}
```
但是由于出题人又加强了数据，那么在这里讲讲另外一种思路。
# **100分思路**
这里首先要感谢一下[@wqy_03](https://www.luogu.com.cn/user/250699)和[@rcxkk](https://www.luogu.com.cn/user/235121)给的思路。

要想不后期 $lca$ ，那只能尝试在 $dfs$ 里就求出它们的最近公共祖先。

首先我们要想到一个思路，如果一个点有多个子树，那么次深的那个子树的深度到该点的深度的每一层深度的最近公共祖先都不可能在该点深度之下，也就是最深就是该点。

因为由于是子树的原因，所以显然他们的最近道路必然要经过该点。而又因为是次深的一个子树，所以该深度必然有两个或两个以上的节点在该点的不同子树里面。

这样子从下往上推，不断更新，最终得到的就是答案。

下面是代码
```cpp
#include<iostream>
#include<cstdio> 
#include<cstring>
using namespace std;
int n,m,idx=1;
int head[10000010],ans[10000010];
struct node{
	int nxt,to;
}edge[10000010];
inline void add(int u,int v){
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	head[u]=idx;
}
inline int dfs(int x,int dep){
	int maxn=dep,maxn2=dep;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;
		int s=dfs(v,dep+1);
		if(s>maxn){
			maxn2=maxn;
			maxn=s;
		}
		else if(s>maxn2)maxn2=s;
	}
	for(int i=dep;i<=maxn2;i++)
		ans[i]=x;
	return maxn;
}
inline int read(){
	int date=0,W=1;char ch=0;
	while(!isdigit(ch)){if(ch=='-')W=-1;ch=getchar();}
	while(isdigit(ch)){date=date*10+ch-'0';ch=getchar();}
	return date*W;
}
int main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++){
		int x=read();
		add(x,i);
	}
	dfs(1,1);
	for(int i=1;i<=m;i++){
		int x=read();
		printf("%lld\n",ans[x]);
	}
	return 0;
}
```



---

## 作者：Watermatter (赞：1)

丧心病狂啊这出题人，倍增LCA都卡。


### 40pts

既然要求出某一个深度的共同LCA，可以计算两个点的LCA，再和第三个点再计算LCA，尽管可以提前预处理出每两个点的LCA，但是还是得T飞。~~不贴代码了~~

### 60pts

抛开暴力思路不想，我们从中去找一些规律。（~~其实这个思路是机房大佬告诉我的，非常感谢这位巨佬~~）。多生几组小数据，我们可以发现，答案就是这棵树在深度为$k$时dfs序第一个点和最后一个点的LCA。

可以将$dep_i=k$的点扔进vector里，然后找到第一个节点和最后一个节点并求出LCA即可。

代码如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3000001;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
struct node{
	int nxt,to;
}e[N<<1];
int head[N],cnt=0,dep[N],n,m,fa,q;
int f[N][20];
vector<int>D[N];
void add(int u,int v){
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
void base(){
	for(int i=1;i<=19;i++)
		for(int j=1;j<=n;j++)
			f[j][i]=f[f[j][i-1]][i-1];
}
void dfs(int u,int fa,int d){
	dep[u]=d;D[d].push_back(u);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa)continue;
		f[v][0]=u;
		dfs(v,u,d+1);
	}
}
int LCA(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i=19;i>=0;i--)if(dep[f[x][i]]>=dep[y])x=f[x][i];
    if(x==y)return x;
    for(int i=19;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
    return f[x][0];
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		fa=read();
		add(i,fa),add(fa,i);
	}
	dep[1]=1;
	dfs(1,0,1);base();
	for(int i=1;i<=m;i++){
		scanf("%d",&q);
//		printf("%d %d\n",D[q][0],D[q][D[q].size()-1]);
//		printf("%d\n",LCA(7,8));
		printf("%d\n",LCA(D[q][0],D[q][D[q].size()-1]));
	}
	return 0;
}
```

发现这个题的$N$非常大，所以倍增数组会导致MLE。所以还是上树剖LCA吧，但是因为vector占的内存太大，还是只有60pts。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3000001;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
struct node{
	int nxt,to;
}e[N<<1];
vector<int>D[1500001];
int head[N],cnt=0,fa[N],siz[N],num[N],son[N],top[N],n,m,x,dep[N];
void add(int u,int v){
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
void dfs1(int u){
	siz[u]=1;
	dep[u]=dep[fa[u]]+1;
	D[dep[u]].push_back(u);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa[u])continue;
		fa[v]=u;
		dfs1(v);
		siz[u]+=siz[v];
		if(siz[v]>num[u])num[u]=siz[v],son[u]=v;
	}
}
void dfs2(int u,int t){
	top[u]=t;
	if(son[u])dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].nxt)
		if(e[i].to!=fa[u]&&e[i].to!=son[u])dfs2(e[i].to,e[i].to);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		x=read();
		add(x,i);
	}
	dfs1(1),dfs2(1,1);
	for(int i=1,q;i<=m;i++){
		q=read();
		int x=D[q][0],y=D[q][D[q].size()-1];
		while(top[x]!=top[y]){
			if(dep[top[x]]>=dep[top[y]])x=fa[top[x]];
			else y=fa[top[y]];
		}
		if(dep[x]<dep[y])printf("%d\n",x);
		else printf("%d\n",y);
	}
}

```
## 100pts
是我太蠢了，为什么偏要开个vector来存所有深度为k的结点，我们只要存两个点就可以了。

$now[dep][0/1]$表示深度为dep的dfs序的第一个点和最后一个点,$check[dep]$判断dep深度的点出现的次数。注意当树是一条链的时候，$now[dep][1]=0$,此时答案就是$now[dep][0]$.
```
#include<bits/stdc++.h>
using namespace std;
const int N=3000001;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
struct node{
	int nxt,to;
}e[N<<1];
int head[N],cnt=0,fa[N],siz[N],num[N],son[N],top[N],n,m,x,dep[N],now[N][2],check[N];
void add(int u,int v){
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
void dfs1(int u){
	siz[u]=1;
	dep[u]=dep[fa[u]]+1;
	if(!check[dep[u]])now[dep[u]][0]=u;
	else now[dep[u]][1]=u;
	check[dep[u]]++;
//	D[dep[u]].push_back(u);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa[u])continue;
		fa[v]=u;
		dfs1(v);
		siz[u]+=siz[v];
		if(siz[v]>num[u])num[u]=siz[v],son[u]=v;
	}
}
void dfs2(int u,int t){
	top[u]=t;
	if(son[u])dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].nxt)
		if(e[i].to!=fa[u]&&e[i].to!=son[u])dfs2(e[i].to,e[i].to);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		x=read();
		add(x,i);
	}
	dfs1(1),dfs2(1,1);
	for(int i=1,q;i<=m;i++){
		q=read();
		if(check[q]==1){
			printf("%d\n",now[q][0]);
			continue;
		}
		int x=now[q][0],y=now[q][1];
		while(top[x]!=top[y]){
			if(dep[top[x]]>=dep[top[y]])x=fa[top[x]];
			else y=fa[top[y]];
		}
		if(dep[x]<dep[y])printf("%d\n",x);
		else printf("%d\n",y);
	}
}
```




---

## 作者：老壁灯 (赞：0)

被机房大佬怂恿来卡这题的常，~~没想到直接过了~~。

一个很显然的性质是,令深度$i>j$,有$deep_{lca_i}\ge deep_{lca_j}$(既然它能作为深度为$j$的点集的$lca$，那么一定能覆盖点集$i$的所有点,即一定是点集$i$的$lca$)。

于是选择深度最深的点往上跳,跳跃的过程是$O(n)$的。在向上跳的过程中第一个能把深度为$i$的点全部包含的子树的根就是$lca_i$,用欧拉序判定当前的根能否作为答案,否则直接向父亲跳。


```cpp
#include<cstdio>
#include<algorithm>
#define maxn 5001000
using namespace std;
int min(int x,int y){return x>y?y:x;}
int max(int x,int y){return x>y?x:y;}
int rd(){
	int x=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){
		x=x*10+c-48;
		c=getchar();
	}
	return x;
}
void print(int x){
	if(x>9)print(x/10);
	putchar(x%10^48);
}
struct edge{
	int to,next;
}e[maxn];
int n,m,k=0,tot=0;
int head[maxn],ans[maxn],l[maxn],r[maxn],maxl[maxn],maxr[maxn],pos=0,maxx=0,fa[maxn];
void js(int u,int v){
	e[++k]=(edge){v,head[u]};
	head[u]=k;
}
void dfs(int u,int dep){
	if(dep>maxx){
		maxx=dep;
		pos=u;
	}
	l[u]=++tot;
	for(int i=head[u];i;i=e[i].next)fa[e[i].to]=u,dfs(e[i].to,dep+1);
	r[u]=tot;
	maxl[dep]=!maxl[dep]?l[u]:min(l[u],maxl[dep]);
	maxr[dep]=max(l[u],maxr[dep]);
   //记录dep点集的欧拉序的最小值(最大值)
}
int main(){
	n=rd(),m=rd();
	for(int v=1,u;v<=n;++v){
		u=rd();js(u,v);
	}
	dfs(1,1);
	for(int i=maxx;i>0;--i){
		while(l[pos]>maxl[i]||r[pos]<maxr[i])pos=fa[pos];
		ans[i]=pos;
	}
	for(int i=1,x;i<=m;++i){
		x=rd();print(ans[x]),putchar('\n');
	}
	return 0;
}
```


---


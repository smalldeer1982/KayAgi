# Trees

## 题目背景

ZHY 有很多树，每个树上都有很多点，每个点上都有一个数，但他忘记了每个点上写的数是什么了。

## 题目描述

ZHY 拥有 $m$ 棵树，每棵树形态相同，且均有 $n$ 个点。定义 $(i,j)$ 是第 $i$ 棵树上的第 $j$ 个点，你需要为每个点 $(i,j)$ 赋一个值 $a_{(i,j)}$，且满足以下条件：

- 对于 $\forall i \in [1,m],\forall j \in [1,n]$，有 $a_{(i,j)}\in\{0,1\}$。

- 对于 $\forall i \in [1,n]$，有 $\sum_{j=1}^m a_{(j,i)}\le 1$。

- 对于任意的一条边 $(u,v)$ 和 $i \in [1,m]$，有 $a_{(i,u)}+a_{(i,v)}\le 1$。

请你计算有多少种赋值方式，对 $10^9+7$ 取模。注意这 $m$ 棵树是有序的。

## 说明/提示

**本题使用捆绑数据。**

对于所有的数据，$1 \le n \le 10^6$，$1 \le m \le 10^9$。

- Subtask 0（10 pts）：$n,m \le 4$。
- Subtask 1（30 pts）：$n,m \le 10^3$。
- Subtask 2（15 pts）：$n \le 10^3$。
- Subtask 3（25 pts）：$m=1$。
- Subtask 4（20 pts）：无特殊限制。

## 样例 #1

### 输入

```
3 1
1 2
2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5 2
1 2
1 3
2 4
2 5```

### 输出

```
103```

# 题解

## 作者：2024sdhkdj (赞：15)

**[题面传送门](https://www.luogu.com.cn/problem/P9161)**

**[我的 BLOG](https://www.luogu.com.cn/blog/hsb0507/)**
## 前置知识： 树形 DP

## 题意描述
给定两个数 $m$、$n$，表示有 $m$ 棵 $n$ 个点的树。其中每棵树形态、结构相同，给定它们的 $n-1$ 条边。需要你为每棵树上的所有结点赋值，令 $a(i,j)$ 表示为第 $i$ 棵树上的第 $j$ 个点被赋的值。赋值规则如下：

- 对于每棵树上任何一个结点，**只能**赋值为 $0$ 或 $1$。

- 对于每棵树上相同位置的节点，允许有其中**一个**结点赋值为 $1$。

- 对于每棵树上任意一条边，允许有其中**一个**端点赋值为 $1$。

要求出有多少种**赋值方案数**。

## 算法分析

因为要求**方案数**，可以想到使用 DP。而题目要求是在树上操作，可以确定是**树形 DP**。

### 定义状态
树形 DP 的状态比较套路，一般设两维（$dp[i][j]$）。第一维表示“以 $i$ 为根结点的字树”，第二维根据题意要求，表示 $i$ 号位置为 $j$。意义什么呢？因为题目所求是赋值方案，于是可以断定：

$dp[i][j]$ 表示，以 $i$ 为根结点的子树，第 $i$ 号位置为 $j$ 的方案数。

但这个状态有一个小**错误**，假如其中一棵树 $i$ 号位置为 $1$，则其他树必须为 $0$，而不能全部为 $1$。因此需要分类讨论：

1. 当 $j=0$ 时：

	$dp[i][j]$ 表示，以 $i$ 为根结点的子树，第 $i$ 号位置为 $0$ 的方案数。
    
2. 当 $j=1$ 时：

	$dp[i][j]$ 表示，以 $i$ 为根结点的子树，其中一棵树第 $i$ 号位置为 $1$，其他树为 $0$ 的方案数。
    
### 状态转移方程
个人认为，找状态转移方程是此题的难点。一旦推出来了，剩下的就只是打板子了。

根据我们定义的状态，需要分两种情况讨论：

1. 当第 $i$ 位为 $0$ 时：
	
   - 当它的儿子为 $0$ 时：
   
   	 为以前的方案数乘以这个儿子的方案数：$dp[i][0] = dp[i][0] \times dp[son][0]$。
     
   - 当它的儿子为 $1$ 时：
   
   	 对于每棵树的它的这个儿子的位置，都可以为 $1$，根据乘法原理，为以前的方案数乘以 $m$ 种为 $1$ 的方案数：$dp[i][0] = dp[i][0] \times m \times dp[son][1]$。
		
2. 当第 $i$ 位为 $1$ 时：
	
   - 当它的儿子为 $0$ 时：
   
     同样为以前的方案数乘以这个儿子的方案数：$dp[i][1] =dp[i][1] \times dp[son][0]$。
   - 当它的儿子为 $1$ 时：
   
		对于每棵树的它的这个儿子的位置，除了它本身的儿子，其他的都可以为 $1$，根据乘法原理，为以前的方案数乘以 $m-1$ 种为 $1$ 的方案数：$dp[i][1] =dp[i][1]\times (m-1) \times dp[son][1]$。
        

合并得：

1. $dp[i][0] =dp[i][0]\times (dp[son][0]+m \times dp[son][1])$。

2. $dp[i][1] =dp[i][1] \times (dp[son][0]+(m-1) \times dp[son][1])$。

### 答案
根据我们定义的状态，答案为：以根结点为根的树，所有树根结点为 $0$ 或任意一棵树根结点 $1$ 的方案数之和。即：

$$ans=dp[1][0]+m \times dp[1][1]$$

### 初始状态
根据状态转移方程，因为需要乘，如果每个 $dp[i][j]$ 设为 $0$，则最终答案只能为 $0$。因此将所有 $dp[i][j]$ 设为 $1$，即： $\forall i \in [1,n],\forall j \in [0,1]$，有 $a_{(i,j)}\in\{1\}$。

## 注意事项
- 因为是树，要建**双向边**，且在 dfs 时**需要判父亲**，不然会不断走重复的路，直至卡死。

- 方案数可能很大，记得**每转移一次就取模一次**，并开 long long。

- **一定记得先搜索再转移**，不然它的儿子的方案数还未算出，转移是无效的。

- 有表达不当出可以辅以代码注释理解。

## 代码
~~~
#include<bits/stdc++.h>
#define mod 1000000007//模数
using namespace std;
const int N=1e6+10;
int n,m;
long long dp[N][2];//记得开long long
vector<int> vec[N];
void dfs(int cur,int fa){//因为是无向边，需要记录它的父亲以避免重复
	for(int i=0;i<vec[cur].size();i++){
		int to=vec[cur][i];
		if(to==fa)//判断父亲
			continue;
		dfs(to,cur);//先搜索，再转移，不然dp[to][0/1]还没有算出来，转移无效
		dp[cur][0]=(dp[cur][0]*(dp[to][0]+m*dp[to][1]%mod))%mod;
		dp[cur][1]=(dp[cur][1]*(dp[to][0]+(m-1)*dp[to][1]%mod))%mod;//状态转移
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		vec[u].push_back(v);
		vec[v].push_back(u);//记得存双向边
	}
    for(int i=1;i<=n;i++)
        dp[i][0]=dp[i][1]=1;//初始状态
	dfs(1,0);//从根结点深搜
	cout<<(dp[1][0]+m*dp[1][1]%mod)%mod;//答案
	return 0;
}
~~~
**[AC 记录](https://www.luogu.com.cn/record/127023868)**

## 总结
此题的难点主要是找出**状态转移方程**，一旦找到了，其他问题也迎刃而解。如何找到呢？最重要的是理解题意和所求。在理清他们的关系后，经过模拟与假设，逐渐摸索出正解。当然，树形 DP 这一类题的细节也挺多的，~~我深有体会，有可能就是一个符号的差距，就是一片红和一片绿的差距。~~ 因此，多注重细节，才能在考场上稳中求胜。

插句题外话，CSP2023 即将到来，这有可能是我考前最后一次写题解了。在此预祝各位： **CSP2023** $RP+\infty$!!!

---

## 作者：Chengjintian (赞：6)

# 树形DP

**前置知识：$\forall$ 与 $\sum$ 的含义。**

例子：对于 $\forall i \in [1,n]$，有 XXXXXX。

>表示所有的在区间 $1 \sim n$ 整数 $i$ 都满足条件 XXXXXX。

-------------------------------------------

例子：$\sum ^n_{i=1} a_i$

>表示：

>$a_1+a_2+a_3+\dots+a_n$

以上两种符号在本题解中出现，请提前了解它们代表的含义。

[题目传送门](https://www.luogu.com.cn/problem/P9161)

Part 1 题目翻译：
-------
我们先规定：定义 $(i,j)$ 是第 $i$ 颗树上的第 $j$ 个点的值。

给定 $m$ 棵相同的树，有 $n$ 个节点，现在你对这 $m$ 棵树的每一个节点上色成 $1$ 或 $0$，一个合格的上色方案的规则是：
>1. 对于所有树上的同一个点 $k$，你**最多**涂一个色 $1$（可以不涂）。也就是说如果 $(1,k)=1$，那么 $(2,3,4,5 \dots m,k)$ 都不能涂成 $1$。
>2. 对于一条边所连的两个点，最多涂一个 $1$。

问你有多少种方案满足上述规则。

Part 2 思路
-------
从下至上涂色。显而易见，对于一个点 $k$，它能否涂成 $1$ 取决于 $\sum^m_{i=1}(i,k)$ 和它儿子的值，如果上式均等于 $0$，则 $(i,k)$ 可以取 $1$，否则不可以。

这不是符合 DP 的无后效性要求吗？一个点的状态，只取决于与它有关联的点的状态，不被与它不关联的点的状态影响。我们可以用 DP。

我们用 $dp_{i,j}$ 表示在点 $i$ 中 $\sum^m_{t=1}(t,i)=j$，其中 $j \in [0,1]$。

其实也可以用 $dp_{z,i,j}$ 表示第 $z$ 棵树的第 $i$ 个点的状态 $j$，但是读者读到后面就会知道，多设的一维 $z$ 没有多大的用。请看下面约 $7$ 行的内容：“那么……”。

考虑转移式：

- 当 $j=0$ 时：

>代表它们的儿子们点 $son$ 中的一个可以取 $1$（也可以都取 $0$）。

>具体是哪个儿子呢？哪个儿子都可以。

>比如：我们知道了点 $i$ 的儿子 $son$，有 $3$ 棵树，以及 对于 $\forall t \in [1,3]$，有 $(t,i)=0$，那么所有的 $son$ 点的状态方案是：

>>以下的花括号的含义：$\{(1,son),(2,son),(3,son)\}$ 
>>
>>$\{0,0,0\};\{1,0,0\};\{0,1,0\};\{0,0,1\}$
>>


>**那么，点 $i$ 的儿子 $son$ 中有一个取 $1$ 可以组成的方案数是:** 
>
>$\sum^m_{t=1}dp_{t,{son},1}$（即每个儿子取一的方案数之和）

>（这里的 $dp$ 数组采用的是上面约 $7$ 行的内容的三维定义方法，为了说明多设一维没用）
>
>又因为 $m$ 棵树的各种数据相同，所以：

>$dp_{1,son,1}=dp_{2,son,1}=\dots=dp_{m,son,1}$

>所以我们消掉第一维，用 $m\times dp_{son,1}$ 代替 $\sum^m_{t=1}dp_{t,{son},1}$。

>**根据定义，点 $i$ 的儿子 $son$ 取 $0$ 的方案是 $dp_{son,0}$。**

>根据组合数学的乘法原理，同时整理，得**递推式 $1$**：

>$dp_{i,0}=dp_{i,0}\times (m \times dp_{son,1}+dp_{son,0})$
>
>当它有多个儿子，重复带入 $son$ 计算。

- 当 $j=1$ 时：

>代表在 $m$ 棵树中，有一个编号为 $i$ 的点取了 $1$，它的儿子们中，除了取 $1$ 点 $i$ 的 $son$ 只能取 $0$ 以外，其他 $(m-1)$ 个树上的 $son$ 中有一个可以取 $1$（可以都取 $0$），同时满足构造树的要求。即：

>**递推式 $2$：**

>$dp_{i,1}=dp_{i,1}\times ((m-1)\times dp_{son,1}+dp_{son,0})$
>
>当它有多个儿子，重复带入 $son$ 计算。

临界值：

对于 $\forall i \in[1,n],\forall j \in [0,1]$，有 $dp_{i,j}=1$。（想想为什么）

这上面的递推式 $1,2$ 就是本题的全部考点（~~取模问题也挺好考的~~）。推出递推式后，按照树状 DP 的套路 dfs 计算即可。或者你可以这样理解：

>我们从下往上涂色，即搜到树的最低端，按公式向上计算（即向上涂色）。

结合不长的代码理解：

Part 3 代码
-----
```#include <bits/stdc++.h>
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,dp[(ll)1e6+15][3];
vector<ll>d[(ll)1e6+15];
const ll mod=(ll)1e9+7;
void dfs(ll id,ll fa){//dfs模拟从下往上涂色
	for(int i=0;i<d[id].size();i++){
		ll son=d[id][i];
		if(son!=fa){//它不能走回它的父亲，不然就死循环了
			dfs(son,id);
			dp[id][0]=dp[id][0]*(dp[son][0]+m*dp[son][1]%mod)%mod;//注意取模
			dp[id][1]=dp[id][1]*(dp[son][0]+(m-1)*dp[son][1]%mod)%mod;
		}
	}
}
int main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);//关闭同步流，使得cin和cout所用时间与printf和scanf相差无几。用了这句话就不能用printf和scanf等了。
	cin>>n>>m;
	for(int i=1;i<n;i++){
		ll u,v;
		cin>>u>>v;
		d[u].push_back(v);
		d[v].push_back(u);//vector双向建边
	}
	for(int i=1;i<=n;i++)dp[i][0]=dp[i][1]=1;//每一个点的方案最开始都是1
	dfs(1,-1145114);//1是根节点，没有父亲（怎么感觉怪怪的），这里的 fa 可以取除了 1~n 以外的任意整数
	cout<<((dp[1][1]*m+dp[1][0])%mod)%mod;
	return 0;
}

```

---

## 作者：wuhan1234 (赞：3)

## 1.编程思路。

本题采用树形 DP 求解。

根据题意，有 $m$ 棵形态相同的树，每棵树上都有 $n$ 个结点。现在要求对这 $m\times n$ 个结点赋值，赋值要求要满足 $3$ 点：

1）每个结点可以赋值为 $0$ 或 $1$。

2）处于同一位置的结点若某棵树中赋值为 $1$，则其他 $m-1$ 棵树中该同一位置都只能赋值为 $0$。

3）在任一棵树中，任意一条边所连接的两个结点不能同时赋值为 $1$。

为了较好地理解后面的公式，先以 $m=3,n=2$，即有 $3$ 棵树，每棵树上有 $2$ 个结点，每棵树上的两个结点编号为 $1$（表示根结点）和 $2$（表示叶子结点）。

先看编号为 $2$ 的结点的赋值情况，$3$ 棵树有 $4$ 种赋值方法：$3$ 棵树中的编号为 $2$ 的结点均赋值为 $0$，记为 $(0,0,0)$；第 $1$ 棵树中编号为 $2$ 的结点赋值为 $1$，其余两个结点赋值为 $0$，记为 $(1,0,0)$；第 $2$ 棵树中编号为 $2$ 的结点赋值为 $1$，其余两个结点赋值为 $0$，记为 $(0,1,0)$；第 $3$ 棵树中编号为 $2$ 的结点赋值为 $1$，其余两个结点赋值为 $0$，记为 $(0,0,1)$。

在这 $4$ 种情况中，第 $1$ 种情况是所有 $3$ 棵树中编号为 $2$ 的结点全部赋值为 $0$，其情况数用 $\mathit{dp}_{2,0}$ 来表示，则有 $\mathit{dp}_{2,0}=1$。

后面三种情况是类似的，就是某一棵树的 $2$ 号结点赋值为 $1$，其余树中 $2$ 号结点赋值为 $0$，将这 $3$ 种情况视为一种类型，其类型数用 $\mathit{dp}_{2,1}$ 来表示，则有 $\mathit{dp}_{2,1}=1$。

再看编号为 $1$ 的结点的赋值情况，若编号为 $1$ 的结点全部赋值为 $0$，则编号为 $2$ 的结点可随意赋值 $0$ 或 $1$。 因此，$\mathit{dp}_{1,0}=\mathit{dp}_{2,0}+3\times \mathit{dp}_{2,1}=4$。

某一棵树编号为 $1$ 的结点赋值为 $1$，其余树中 $1$ 号结点赋值为 $0$，则编号为 $2$ 的结点赋值全部为 $0$ 肯定是符合要求的；若某一棵树中的 $2$ 号结点赋值为 $1$，则一定不能在 $3$ 棵树中选 $1$ 号结点也赋值为 $1$ 的那棵树。因此，$\mathit{dp}_{1,1}=\mathit{dp}_{2,0}+(3-1)\times \mathit{dp}_{2,1}=3$。

总的赋值方法数为 $\mathit{dp}_{1,0}+3\times \mathit{dp}_{1,1}=13$。

更一般地，设 $\mathit{dp}_{u,0}$ 表示所有 $m$ 棵树中编号为 $u$ 的结点全部赋值为 $0$ 的方案数，$\mathit{dp}_{u,1}$ 表示某一棵树中编号为 $u$ 的结点赋值为 $1$，其余 $m-1$ 棵树中编号为 $u$ 的结点赋值为 $0$ 的同一类型数，则有状态转移方程如下：

$$ \mathit{dp}_{u,0}= \prod(\mathit{dp}_{v,0}+m\times \mathit{dp}_{v,1})$$

$$ \mathit{dp}_{u,1}= \prod(\mathit{dp}_{v,0}+(m-1)\times \mathit{dp}_{v,1})$$
状态方程中，$v$ 是 $u$ 的子结点。

若 $u$ 是叶子结点，则有 $ \mathit{dp}_{u,0}= \mathit{dp}_{u,1}= 1$。

所求的答案为 $\mathit{dp}_{1,0}+m\times \mathit{dp}_{1,1}$。

## 2.源程序。
```c
#include <stdio.h>
#define MOD 1000000007
struct Edge
{
    int to,next;
}e[2000005];
int head[1000005]={0};
long long dp[1000005][2];
int n,m;
void dfs(int u, int fa)
{
    dp[u][0] = dp[u][1] = 1;
	int i;
    for (i=head[u];i;i=e[i].next)
    {
        int v = e[i].to ;
        if (v==fa) continue;
		dfs(v, u);
		dp[u][0] = dp[u][0] * (dp[v][0] + dp[v][1] * m % MOD) % MOD;
		dp[u][1] = dp[u][1] * (dp[v][0] + dp[v][1] * (m - 1) % MOD) % MOD;
    }
}
int main()
{
	scanf("%d%d",&n,&m);
	int i,cnt=0;
	for (i = 1; i < n; i++)
    {
		int u,v;
        scanf("%d%d",&u,&v);
        e[++cnt].next = head[u];   // 边数组中加入2条边
        head[u] = cnt;
        e[cnt].to = v;
        e[++cnt].next = head[v];
        head[v] = cnt;
        e[cnt].to = u;
	}
	dfs(1, 0);
	printf("%lld\n", (dp[1][0] + dp[1][1] * m % MOD) % MOD);
	return 0;
}

```


---

## 作者：Galex (赞：3)

考虑树形 dp。

设 $dp_{u,0}$ 表示在 $m$ 颗以 $u$ 为根节点的子树中，没有任何一棵子树的 $u$ 节点是 $1$ 所对应的方案数。 $dp_{u,1}$ 表示存在一颗子树 $u$ 节点为 $1$ 且已经知道了是哪棵树所对应的方案数。

考虑转移，如果 $u$ 位置没有任何一个树放的话他的子节点可以选择放或者不放，如果放的话在 $m$ 棵树中都能放：

$dp_{u,0}= \prod\limits_{v\in son_u} (dp_{v,0}+m \times dp_{v,1})$

如果 $u$ 号点放，那么子节点想放的话必须选一个 $u$ 节点为 $0$ 的树放，有 $m-1$ 种可能：

$dp_{u,1}= \prod\limits_{v\in son_u} (dp_{v,0}+(m-1) \times dp_{v,1})$

叶子结点的方案即为 $dp_{u,0}=dp_{u,1}=1$。

那么最后的答案就是 $dp_{1,0}+m \times dp_{1,1}$，复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	int s = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
		f = (ch == '-' ? -1 : 1), ch = getchar();
	while (ch >= '0' && ch <= '9')
		s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
	return s * f;
}

const int mod = 1000000007;

int n, m;
vector<int> e[1000005];
int dp[1000005][2];

void DP(int x, int fa) {
	dp[x][0] = dp[x][1] = 1;
	for (int y : e[x])
		if (y != fa)
			DP(y, x), dp[x][0] = dp[x][0] * (dp[y][0] + dp[y][1] * m % mod) % mod, dp[x][1] = dp[x][1] * (dp[y][0] + dp[y][1] * (m - 1) % mod) % mod;
}

signed main() {
	n = read(), m = read();
	for (int i = 1; i < n; i++) {
		int u = read(), v = read();
		e[u].push_back(v), e[v].push_back(u);
	}
	DP(1, 0);
	printf("%lld", (dp[1][0] + dp[1][1] * m % mod) % mod);
	return 0;
}
```

---

## 作者：__yun__ (赞：1)

先把题目翻译成人话：

有 $m$ 棵形态相同, 且均有 $n$ 个点的树。为每个点赋权值，满足：
- 每个节点可以赋值为 $0$ 或 $1$。
- 对于任意一个节点，$m$ 棵树中最多有一棵树。
- 相邻的两个节点不能同时赋值为 $1$。

求方案数对 $10^9+7$ 取模的值。

不难想到树形 dp。

设 $f_{u,1}$ 表示编号为 $u$ 的节点有一棵树赋值为 $1$ 的方案数， $f_{u,0}$ 表示编号为 $u$ 的节点在 $m$ 棵树中全部为 $0$ 的方案数。

若编号为 $u$ 的节点在一棵树中赋值为 $1$，则它的孩子只能为 $0$，其他 $m-1$ 棵树中编号为 $u$ 的节点的孩子可以为 $0$ 也可以为 $1$，转移方程为：
$$f_{u,1}=\prod_{v \in son_u}(f_{u,0}+(m-1)\times f_{u,1})$$ 

若编号为 $u$ 的节点在 $m$ 棵树中全部为 $0$ ，那么他们的孩子可以为 $0$ 也可以为 $1$，转移方程为：
$$f_{u,0}=\prod_{v \in son_u}(f_{u,0}+m\times f_{u,1})$$ 

若编号为 $u$ 的节点为叶子结点，则 $f_{u,1}=f_{u,0}=1$。

最后答案为 $f_{1,1}+f_{1,0}$。

### $Code:$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int M=1919810;
const int mod=1e9+7;
vector<int> eg[M];
int n,m,a[M],f[M][2];
void dfs(int u,int fa){
	f[u][1]=f[u][0]=1;
	for(int v:eg[u]){
		if(fa==v) continue;
		dfs(v,u);
		f[u][1]=f[u][1]*((f[v][0]+(m-1)*f[v][1]%mod)%mod)%mod;
		f[u][0]=f[u][0]*((f[v][0]+m*f[v][1]%mod)%mod)%mod;
	}
	return ;
}
signed main(){
    cin>>n>>m;
	int u,v;
	for(int i=1;i<n;i++){
		cin>>u>>v;
		eg[u].push_back(v);
		eg[v].push_back(u);
	}
	dfs(1,1);
	cout<<(m*f[1][1]+f[1][0])%mod;
    return 0;
}
```
记得开 long long 和取模


---

## 作者：xler0915 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9161) / [可能有更好的阅读体验](https://www.luogu.com.cn/blog/hen-you-so-beautiful/solution-p9161)

### 题意

有 $m$ 棵形态相同, 且均有 $n$ 个点的树。你需要为每个点赋权值，满足：

1. 赋的权值为 $0$ 或 $1$。

2. 对于任意一个点，若有一棵树在该点的权值为 $1$，则其余 $m-1$ 棵树在该点的权值均为 $0$。

3. 在任意一棵树中，任意一条边的两个点的权值不能全是 $1$。

问赋值方案数对 $10^9 + 7$ 取模的值。**注意这 $m$ 棵树是有序的。**

### 思路：树形 dp

我们将 $1$ 作为这 $m$ 棵树的根，那么这 $m$ 棵树的层次关系就确定了，用 $u \to v$ 表示 $v$ 是 $u$ 的儿子。

令 $dp_{u,0}$ 表示这 $m$ 棵树中在 $u$ 点的权值均为 $0$ 的方案数，$dp_{u,1}$ 表示这 $m$ 棵树中，有一棵树在 $u$ 点的权值为 $1$，其余 $m - 1$ 棵树在 $u$ 点的权值均为 $0$ 的方案数，考虑状态转移方程：

- 如果这 $m$ 棵树中在 $u$ 点的权值都为 $0$，则对于 $u$ 的任意一个儿子 $v$，**可以选择这 $m$ 棵树在 $v$ 点的权值均为 $0$，也可以选择只有一棵树在 $v$ 点的权值为 $1$，此时有 $m$ 种可能性，** 由乘法原理知 $dp_{u,0} = \prod_{u \to v} (dp_{v,0} + m \times dp_{v,1})$。

- 如果这 $m$ 棵树中，只有一棵树在 $u$ 点的权值为 $1$，则对于 $u$ 的任意一个儿子 $v$，**可以选择这 $m$ 棵树在 $v$ 点的权值均为 $0$，也可以选择只有一棵树在 $v$ 点的权值为 $1$，此时有 $m - 1$ 种可能性，** 由乘法原理知 $dp_{u,1} = \prod_{u \to v} (dp_{v,0} + (m - 1) \times dp_{v,1})$。

故得到状态转移方程为：

$$dp_{u,0} = \prod_{u \to v} (dp_{v,0} + m \times dp_{v,1})$$

$$dp_{u,1} = \prod_{u \to v} (dp_{v,0} + (m - 1) \times dp_{v,1})$$

base case 为当 $u$ 是叶子结点时，$dp_{u,0} = dp_{u,1} = 1$。最终答案即为 $dp_{1,0} + m \times dp_{1,1}$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
	int v, nxt;
} edge[2000005];
int head[1000005], cnt = 0;
void add(int u, int v) {
	edge[++cnt] = {v, head[u]};
	head[u] = cnt;
} 
// 链式前向星

const int mod = 1e9 + 7;
int n, m;
long long dp[1000005][2];
void dfs(int u, int fa) {
	dp[u][0] = dp[u][1] = 1;
	for(int i = head[u]; i; i = edge[i].nxt) {
		int v = edge[i].v;
		if(v == fa) continue;
		dfs(v, u);
		dp[u][0] = dp[u][0] * (dp[v][0] + dp[v][1] * m % mod) % mod;
		dp[u][1] = dp[u][1] * (dp[v][0] + dp[v][1] * (m - 1) % mod) % mod; // 状态转移方程
	}
}
 
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i < n; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v); add(v, u);
	}
	dfs(1, 0);
	printf("%lld", (dp[1][0] + dp[1][1] * m % mod) % mod);
	return 0;
}
```

**时间复杂度：$\Theta(n)$。**

**空间复杂度：$\Theta(n)$。**

---


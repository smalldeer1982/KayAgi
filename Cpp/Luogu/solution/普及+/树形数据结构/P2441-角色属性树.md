# 角色属性树

## 题目描述

绪萌同人社是一个有趣的组织，该组织结构是一个树形结构。有一个社长，直接下属一些副社长。每个副社长又直接下属一些部长……。

每个成员都有一个萌点的属性，萌点属性是由一些质数的萌元素乘积构成（例如，猫耳的值是 $2$，弱气的值是 $3$，黄毛的值是 $5$，病娇的值是 $7$，双马尾的值是 $11$ 等等）

举个例子，正妹是双份的猫耳，而且有一份弱气，她的属性值为 $2\times 2\times 3=12$。

现在组员关心一个问题，希望知道离自己最近且有相同萌元素上司是谁，例如，属性值为 $2、4、6、45$ 这样的属性值都算是和正妹有相同的属性。


然而，组员可能会随时变化自己的属性。啊。。感觉好麻烦啊。。


## 说明/提示

对于 $20\%$ 的数据，没有修改的操作。

对于 $50\%$ 的数据，$n\le 100$，修改次数 $<10$。

对于 $100\%$ 的数据，$n\le 200000$，$k<100000$，修改次数 $\le 50,a\_i\le 2^{31}-1$

UPD：本题测试数据随机，可能是假题。

## 样例 #1

### 输入

```
4 6
10 8 4 3
1 2
2 3
3 4
1 1
1 2
1 3
1 4
2 1 9
1 4```

### 输出

```
-1
1
2
-1
1```

# 题解

## 作者：Zilljy258 (赞：45)

## 暴力：编程界最热门的算法。



[题目传送门](https://www.luogu.com.cn/problem/P2441)



------------


### 大体思路：

建一棵树，对于每次询问暴力搜索，对于每次更改进行实时的更改。

#### 怎么暴力搜索？
其实“两个成员有相同的属性”说白了就是“两个成员的属性值的 $\gcd(a_x,a_y) > 1$”

所以只要顺着 $father$ 数组顺藤摸瓜，一个一个的枚举上司的属性值问题就解决了。

------------

### 代码：


```c++
#include<bits/stdc++.h>
using namespace std;
int a[200001]={0};
int fa[200001]={0};  // father 数组
int dfs(int x,int y){     //搜索。
	if(x == 0) return -1;
	if(__gcd(a[x],a[y]) > 1) return x;  //偷一下懒~直接使用gcd函数。
	return dfs(fa[x],y);
}
int main(){
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n-1;i++){
		int x,y;
		cin>>x>>y;
		fa[y]=x;  //建树
	}
	for(int i=1;i<=k;i++){
		int x,y;
		cin>>x;
		if(x==1){
			cin>>y;
			cout<<dfs(fa[y],y)<<endl;  //搜索
		}
		else{
			cin>>x>>y;
			a[x]=y;
		}
	} 
	return 0;
} 
```

---

### 总结：

~~学好暴力很重要。~~

此题并不难，注意枚举和建树就好了。

------------

后记：这是萌新第二次写题解，可能有不足之处，如果大家有要我补充的或改进的，一定要提出来！谢谢大家。

---

## 作者：WZKQWQ (赞：16)

题解区也有暴力的题解，但都没讲为什么这题能暴力。

我看到这道题第一眼就是暴力处理。

然鹅 $n \le 2 \times 10^5$。

然后一句话如同久旱的甘雨让原本哒咩的暴力又行了起来：

- UPD：本题测试数据随机，可能是假题。

不懂暴力的人可能不懂这句话的意义。

举个栗子，你在 `int` 正整数范围内随机两个数 $a,b$。

利用高超的小学数学计算你会发现 $\operatorname{gcd}(a,b)>1$ 的概率高达 $31\%$。

(ps:三个数的概率是 $47\%$，四个是 $55\%$)

所以对于每次询问，暴力一次有 $31\%$ 机率做出，两次 $47\%$，三次 $55\%$。

虽然最坏复杂度高达 $\operatorname{O}(n \times k)$，但随机下期望复杂度只有 $O(k \log n)$。

最后讲一下暴力。

对于操作一：暴力递归；

对于操作二：物理修改。

~~应该没有人暴力都不会打把。~~

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200005;
vector <int> e[N];
int n,k,fa[N],a[N];
void build(int x){//朴实建树 
	for(int i = 0;i < e[x].size();i++){
		int to = e[x][i];
		if(to == fa[x]) continue;
		fa[to] = x;
		build(to);
	}
}
int dfs(int x,int y){//朴实递归 
	if(x == 0) return -1;
	if(__gcd(a[x],a[y]) > 1) return x;
	return dfs(fa[x],y);
}
int main() {
	cin >> n >> k;
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]);
	int x,y,o;
    for(int i = 1;i < n;i++){
    	scanf("%d%d",&x,&y);
    	e[x].push_back(y);
    	e[y].push_back(x);
	}
	build(1);
	for(int i = 1;i <= k;i++){
		scanf("%d",&o);
		if(o == 1){
			scanf("%d",&x);
			printf("%d\n",dfs(fa[x],x));
		} else if(o == 2) {
			scanf("%d%d",&x,&y);
			a[x] = y;
		}
	}
    return 0;
}
```

~~完结撒花~~

---

## 作者：quanjun (赞：7)

题目链接：[https://www.luogu.com.cn/problem/P2441](https://www.luogu.com.cn/problem/P2441)  

题目大意：  
给你一棵树，涉及两种操作：
1. 修改某个节点u的权值；
2. 找某个节点u的满足他们的最大公约数 $\lt 1$ 的最近祖先。

数据范围很大（n<=200000,k<100000），而数据非常水。以至于直接往父节点遍历竟然能够AC囧。  

解决办法就是：
- 如果是修改，则直接修改；
- 如果是查询，则沿着节点u一直向上找最近的那个跟他gcd>1的节点，如果找到根节点都没有找到，则输出“-1”

这个算法的时间复杂度是 $O(n \times k)$ ，然而神奇地过了。  

实现代码如下：  
```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 200020;
int n, k, a[maxn], fa[maxn], rt;
map<int, int> mp;

int solve(int u) {
    for (int v = fa[u]; v; v = fa[v]) if (__gcd(a[u], a[v]) > 1) return v;
    return -1;
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i ++) cin >> a[i];
    for (int i = 1; i < n; i ++) {
        int x, y;
        cin >> x >> y;
        fa[y] = x;
    }
    for (int i = 1; i <= n; i ++) if (!fa[i]) { rt = i; break; }
    while (k --) {
        int op, u, val;
        cin >> op >> u;
        if (op == 1) cout << solve(u) << endl;
        else {
            cin >> val;
            a[u] = val;
        }
    }
    return 0;
}
```

---

## 作者：Creroity (赞：6)

### 大水题【bushi

每个人都只有一个上司，所以就可以用并查集啦！

假设一个人的上司是他爸【doge

也就是 $a_{i.fa}$ 就是一个人的上司，一开始假设每个人的上司就是他自己，然后从这个人的上司开始查找，若两个人的最大公约数大于 $1$ 则这个人和某位上司有相同萌元素，此时输出并直接跳出查找。因为是从下往上找的，所以此时找到的必定是与这个人最近的上司。

至于修改属性，这个其实不需要太担心，因为不用手动分解质因数，所以直接改就行了，~~毕竟数据挺水的~~。

#### 注意一下找不到的情况要输出 $-1$
也就是当这个人的上司是他自己时，输出 $-1$ 并停止循环。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
struct node{
	int u,fa;
}a[200005];
int find(int p){
	int q=p;//记住，找公因数是上面的上司和这个人，不是上司的第一个下属！！！ 
	while(a[q].fa!=q){
		q=a[q].fa;
		if(__gcd(a[p].u,a[q].u)>1)return q;//若最大公约数大于1，直接退出并返还上司编号 
	}
	return -1;//这是最后找不到的情况，输出-1 
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].u;
		a[i].fa=i;//初始化i的上司为i自己 
	}
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		a[y].fa=x;//将y的上司改为x 
	}
	for(int i=1;i<=k;i++){
		int x,y;
		cin>>x>>y;
		if(x==1)cout<<find(y)<<'\n';
		else{
			cin>>x;
			a[y].u=x;
		}
	}
	return 0;
}
```
求赞！QWQ

---

## 作者：小柯 (赞：6)

## 题目

$\text{给定一棵带有权值的树，有少量权值修改操作，每次询问求一个点最近的有相同质因子的祖先。}$

## 想法

最近的祖先？是$LCA$吗？

题目可以转化为：树上最近和自己权值的$gcd$大于一的祖先
~~等于没说~~

为什么呢？因为~~楼上有人讲了~~。

那现在考虑如何倍增求这个东西。

和$LCA$一样，从当前这个点出发，往上以$2$的次幂递减的步长往上跳，能跳则跳。那怎样才算能跳呢？

显然，对于每个点只维护自己的权值是远远不够的，这启发我们还要维护一些关于区间的信息，即倍增时的那些$2$次幂的区间。

那现在再来考虑需要什么：

还是那个问题：怎样才算能跳。能跳的前提是跳了不会错过答案，即跳的区间里没有答案。这个区间里的数比深度更小的数更近，故这些数必须满足的条件是：这里的数都和询问的数没有相同质因子！！！

举个栗子：

5 -> 9 -> 8 -> 53 -> 16

17本想跳到$2^2$处，但这中间有8和16有相同质因子，所以不能跳，再考虑$2^1$处，同样有8，所以也不能跳，最后考虑$2^0$，欸，没有了，可以跳了！于是跳到了53。因为这是跳到了答案的下一个，所以还得再跳一次就可以了。

现在需要维护什么就维护什么就好了。但怎么维护嘞？很明显，如果一个区间中任何一个都和询问的数没有相同质因子，那就算把它们都乘起来也没有，反之也成立。

现在只需要维护区间乘积了！！！有两种方法：

1.倍增时另计$g[i][j]=g[i][j-1]*g[f[f[i][j-1]][0]][j-1]$，时间空间复杂度均为$O(nlogn)$

2.计算每个点到根的乘积，~~可以叫树上前缀积吧~~？查询一个区间时，用两端的前缀积作商即可，时间空间复杂度均为$O(n)$

显然后者更优。~~废话~~。但是有一个问题，就是单纯的乘积一定会算术上溢，怎么办呢？

> 孩子不想写高精度，怎么办呢？

> 不想写高精度，一定是用c++的，转python就好了。

算一算，$k$次询问，每次倍增时有$logn$的尝试和每次尝试的$gcd$有$logsum=log(2^{32}*n)=32*logn=logn$，还有$50$次暴力修改，所以理论复杂度为$O((klog^2n+50n)*$~~巨大常数~~$)$。

## 声明

理论复杂度是可以接受的，但也许是常数太大了吧，连我自己都[没过](https://www.luogu.com.cn/record/29832083)。虽然数据是随机的，但我$\color{lightgreen}{AC}$7个点，$\color{blue}{TLE}$3个点。如果哪位大佬能救这位蒟蒻，请在评论区指点迷津，谢谢！！！

## 代码

码风很奇怪，不要介意。

```python
def gcd(x,y):
    if y==0:
        return x
    return gcd(y,x%y)
n,k=map(int,input().split())
a=list(map(int,input().split()))
a.insert(0,1)
b=[] 
c=[]   #children
d=[]   #depth
f=[]   #father
lg=[0] #log(2,i)
root=0 #root
def DFS(u):
    for v in c[u]:
        b[v]=a[v]*b[u]
        d[v]=d[u]+1
        DFS(v)
def ask(x):
    y=x
    for i in range(lg[d[x]]-1,-1,-1):
        if gcd(b[y]//a[y]//b[f[f[y][i]][0]],a[x])==1:
            y=f[y][i]
    if f[y][0]==0:
        return -1
    return f[y][0]
for i in range(1,n+3):
    b.append(1)
    d.append(0)
    c.append(list())
    f.append(list())
    lg.append(lg[i//2]+1)
for i in range(1,n):
    x,y=map(int,input().split())
    c[x].append(y)
    f[y].append(x)
for i in range(1,lg[n]+2):
    for j in range(0,n+2):
        f[j].append(0)
for i in range(1,lg[n]):
    for j in range(1,n+1):
        f[j][i]=f[f[j][i-1]][i-1]
for i in range(1,n+1):
    if f[i][0]==0:
        root=i
        break
b[root]=a[root]
DFS(root)
for i in range(k):
    q=list(map(int,input().split()))
    if q[0]==1:
        print(ask(q[1]))
    else:
        a[q[1]]=q[2]
        b[root]=a[root]
        DFS(root)
        DFS(root)

```


---

## 作者：ws_fqk (赞：6)

这题貌似我就不该发题解了，数据太水……自己弱也没想出正解搞完暴力就交了。没想到竟然过了。

```cpp

#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<cmath>
#define ll long long
using namespace std;
int n,k,cnt,w[200005],fa[200005],head[200005],next[200005],list[200005];
inline int read()
{
    int a=0,f=1; char c=getchar();
    while (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}
    while (c>='0'&&c<='9') {a=a*10+c-'0'; c=getchar();}
    return a*f;
}
inline void insert(int x,int y)
{
    next[++cnt]=head[x];
    head[x]=cnt;
    list[cnt]=y;
}
int gcd(int a,int b) {return b==0?a:gcd(b,a%b);}
void dfs(int x)
{
    for (int i=head[x];i;i=next[i]) fa[list[i]]=x,dfs(list[i]);
}
int main()
{
    n=read(); k=read();
    for (int i=1;i<=n;i++) w[i]=read();
    for (int i=1;i<n;i++)
    {
        int u=read(),v=read();
        insert(u,v);
    }
    dfs(1);
    for (int i=1;i<=k;i++)
    {
        int x=read(),y=read(),z,ans=-1;
        if (x==2) z=read(),w[y]=z;
        else
        {
            for (int j=fa[y];j;j=fa[j])
            {
                int a=w[y],b=w[j];
                if (a<b) swap(a,b);
                if (gcd(a,b)!=1) {ans=j; break;}
            }
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：linaonao (赞：2)

（水题）
## 简单讲解
kkk已经讲了这道题**数据随机**，我就直接暴力啦

我们从一个点$u$出发，不停向父亲遍历，比较$gcd(a[u],a[fa[u]])$是否$>1$

于是一道本该是绿题但简单的向红题的题就被水过去了
## 代码
```cpp
#include<bits/stdc++.h>
template<typename T>inline void read(T &x){
	T f=0;x=0;char ch=getchar();
    for(;!isdigit(ch);ch=getchar())f|=ch=='-';
    for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    x=f?-x:x;
}
template<typename T>inline void write(T x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+48);
}
using namespace std;
int n,m;
int a[200005],fa[200005];
inline int gcd(int x,int y){
	if(!y) return x;
	return gcd(y,x%y);
}
inline int baoli(int u){
	for(int v=fa[u];v;v=fa[v]){
		if(gcd(a[u],a[v])>1) return v;
	}
	return -1;
}
int main(){
	read(n),read(m);
	for(int i=1;i<=n;++i) read(a[i]);
	for(int i=1;i<n;++i){
		int u,v;read(u),read(v);
		fa[v]=u;
	}
	while(m--){
		int op;read(op);
		if(op==1){
			int u;read(u);
			write(baoli(u)); putchar('\n');
		}else{
			int u,change;read(u),read(change);
			a[u]=change;
		}
	}
	return 0;
}

```


---

## 作者：tobie (赞：2)

首先我们分析一下数据范围

数据随机，说明平均树高为 $\log(n)$，所以树高大约是17。

所以我们就可以直接用暴力来解决这道题。对于每一个询问，把询问节点一层一层往父亲跳，如果发现满足要求的直接返回答案即可。

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=200009;
int a[N],fa[N];
int n,k,x,y,opt;
int gcd(int x,int y)//求出两数的gcd
{
	if(y==0) return x;
	return gcd(y,x%y);
}
int solve(int x)//找答案的过程
{
	int now=fa[x];
	while(now!=0)
	{
		if(gcd(a[x],a[now])>1) return now;//如果发现gcd值大于1，说明他和他的这位上司一定有一个相同的萌元素
		now=fa[now];//没找到就继续往上找
	}
	return -1;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		fa[y]=x;
	}
	while(k--)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d",&x);
			printf("%d\n",solve(x));
		}
		else
		{
			scanf("%d%d",&x,&y);
			a[x]=y;
		}
	}
	return 0;
}
```

---

## 作者：_acat_ (赞：2)

### 思路
判断是否有相同萌元素及判断 $2$ 个数的 gcd 不为 $1$ 即可。

最近的肯定是父亲，如果不满足，则继续往上找即可，直到找到根节点为止。

---

## 作者：Coros_Trusds (赞：1)

# 题目大意

给定一棵树，每个节点有相应的权值，第 $i$ 个节点权值为 $val_i$。

你的程序需要支持以下操作：

1. 格式为 `1  x`，表示在求 $x$ 的祖先节点中，最近的满足 $\gcd(val_{v},val_x)\neq1$ 的节点 $v$。

2. 格式为 `2 x v`，表示令 $val_x=v$。

# 题目分析

题目的数据非常水，可以暴力卡过。

我们把树存下来，对于每个操作：

第一个指令时，暴力在 $x$ 的祖先节点中寻找即可，$\gcd$ 使用较高效的欧几里得算法计算，找到满足条件的祖先节点，输出该节点编号即可。

第二个指令时，直接朴素 $val_x\gets v$。

给出 $\rm dfs$ 代码：

```cpp
inline int dfs(int now)
{
	for(register int i=fa[now];i;i=fa[i])
	{
		if(gcd(a[now],a[i])!=1)
		{
			return i;
		}
	}
	
	return -1;
}
```

----

考虑第一个指令，容易发现这个指令和求 $\rm LCA$ 的朴素过程非常相似，于是容易想到使用倍增法计算。

第一个指令时，按倍增的步骤跳，其他同朴素算法。

由于数据较弱，该算法实际优化作用不大，甚至会比暴力更为缓慢（当然也可能我的 $\rm LCA$ 常数巨大/kk）。



---

## 作者：CyaNgw_DyG (赞：0)

#### · 此题数据随机，可能是假题



------------

## 题意 ：
有一棵 $n$ 个节点的树，每个节点有初始的权值。

有 $k$ 次操作：
1. 询问指定节点第一个与自己的权值不互质的祖先编号。

2. 修改指定节点权值。


## 思路 ：暴力

首先建树，本题查询祖先，用父亲表示法即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,t[200002],f[200002],opt,a,b,flag;//t数组为节点权值，用f数组父亲，建树 
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>t[i];
	for(int i=1;i<=n-1;i++)
	{cin>>a>>b;f[b]=a;}//rt
}
```

接下来处理 $k$ 次操作。

1. 询问：从起点开始往上爬，一旦遇到与起点不互质的祖先就输出。

2. 修改：直接修改即可。

```cpp
	while(k--){
		cin>>opt;//操作符
		if(opt==1){
			cin>>a;b=a,flag=0;//b作为起点，flag用来记录是否有祖先满足条件
			while(f[a]){//爬到根节点为止
				a=f[a];//往上爬
				if(__gcd(t[a],t[b])!=1){//gcd判断是否互质
					cout<<a<<endl;flag=1;//输出，记录有结果
					break;
				}
			}if(flag==0)cout<<-1<<endl;//无解
		}else {
			cin>>a>>b;
			t[a]=b;//修改
		}
	}
```

如果有问题的话可以私信我。

---


# [NOIP 2018 普及组] 对称二叉树

## 题目背景

NOIP2018 普及组 T4

## 题目描述

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： 

1.  二叉树； 
2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  

![](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。   

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。 

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/4lfen5aa.png)    
最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/vhzzc587.png)

最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 

**数据规模与约定**

共 $25$ 个测试点。    

$v_i ≤ 1000$。 

- 测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。 
- 测试点 $4 \sim 8, n ≤ 10$。
- 测试点 $9 \sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。 
- 测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。
- 测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。
- 测试点 $21 \sim 25, n ≤ 10^6$。

本题约定： 

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 
 
 树的深度：树中节点的最大层次称为树的深度。 
 
 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

## 样例 #1

### 输入

```
2 
1 3 
2 -1 
-1 -1 
```

### 输出

```
1```

## 样例 #2

### 输入

```
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8```

### 输出

```
3```

# 题解

## 作者：何俞均 (赞：52)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/9991305.html)体验更佳

看到这一题全都是用$O(nlogn)$的算法过的

考场上写$O(n)$算法的我很不开心

然后就发了此篇题解。。。

首先我们可以像树上莫队一样按照 左-右-根 的顺序将这棵树的欧拉序跑下来，
记下开始访问点$x$的$dfs$序$L[x]$，和回溯时的$dfs$序$R[x]$

再将记录欧拉序的数组记为$P$
```cpp
void dfs(int x) { 
    P[L[x] = ++cnt] = x; 
    if (t[x].ch[0]) dfs(t[x].ch[0]); 
    if (t[x].ch[1]) dfs(t[x].ch[1]); 
    P[R[x] = ++cnt] = x; 
	t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1; 
} 
```
统计出数组$P$的两个哈希值，一个是记录点权($hs1[0][x]$)，

另一个是记录当前点是左儿子还是右儿子($hs2[0][x]$)
```cpp
for (int i = 1; i <= cnt; i++) hs1[0][i] = hs1[0][i - 1] * base + t[P[i]].v; 
for (int i = 1; i <= cnt; i++) hs2[0][i] = hs2[0][i - 1] * base + get(P[i]); 
```
再将这棵树按照 右-左-根 的顺序将这棵树的另一个欧拉序跑下来(记得清空)，

记下开始访问点$x$的$dfs$序$rL[x]$，和回溯时的$dfs$序$rR[x]$
```cpp
void rdfs(int x) { 
    P[rL[x] = ++cnt] = x; 
    if (t[x].ch[1]) rdfs(t[x].ch[1]); 
    if (t[x].ch[0]) rdfs(t[x].ch[0]); 
    P[rR[x] = ++cnt] = x; 
}
```
再记录一次统计出数组$P$的两个哈希值，

一个是记录点权($hs1[1][x]$)，

另一个是记录当前点是左儿子还是右儿子($hs2[1][x]$)(这时候要取异或一下)
```cpp
    for (int i = 1; i <= cnt; i++) hs1[1][i] = hs1[1][i - 1] * base + t[P[i]].v; 
    for (int i = 1; i <= cnt; i++) hs2[1][i] = hs2[1][i - 1] * base + (get(P[i]) ^ 1); 
```
其中$get$函数：
```cpp 
inline int get(int x) { return t[t[x].fa].ch[1] == x; } 
```
然后我们要怎么判断呢？
先判断左右儿子$ls$和$rs$的$size$是否相等

然后再判断第一遍$dfs$左儿子所覆盖的欧拉序内和

第二遍$dfs$右儿子所覆盖的欧拉序内两个哈希值相不相等即可
```cpp
if (getHash(hs1[0], L[ls], R[ls]) != getHash(hs1[1], rL[rs], rR[rs])) continue; 
if (getHash(hs2[0], L[ls], R[ls]) != getHash(hs2[1], rL[rs], rR[rs])) continue; 
```
~~然而常数过大，速度被nlogn吊打~~

完整代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
namespace IO { 
    const int BUFSIZE = 1 << 20; 
    char ibuf[BUFSIZE], *is = ibuf, *it = ibuf; 
    inline char gc() { 
        if (is == it) it = (is = ibuf) + fread(ibuf, 1, BUFSIZE, stdin); 
        return *is++; 
    } 
} 
inline int gi() {
    register int data = 0, w = 1;
    register char ch = 0;
    while (ch != '-' && (ch > '9' || ch < '0')) ch = IO::gc();
    if (ch == '-') w = -1 , ch = IO::gc();
    while (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = IO::gc();
    return w * data;
} 
#define MAX_N 1000005 
struct Node { int ch[2], fa, size, v; } t[MAX_N]; 
inline int get(int x) { return t[t[x].fa].ch[1] == x; } 
typedef unsigned long long ull; 
const ull base = 100007; 
ull pw[MAX_N << 1]; 
ull hs1[2][MAX_N << 1], hs2[2][MAX_N << 1]; 
ull getHash(ull *hs, int l, int r) { return hs[r] - hs[l - 1] * pw[r - l + 1]; } 
int N, L[MAX_N], R[MAX_N], rL[MAX_N], rR[MAX_N], P[MAX_N << 1], cnt; 
void dfs(int x) { 
    P[L[x] = ++cnt] = x; 
    if (t[x].ch[0]) dfs(t[x].ch[0]); 
    if (t[x].ch[1]) dfs(t[x].ch[1]); 
    P[R[x] = ++cnt] = x; 
    t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1; 
} 
void rdfs(int x) { 
    P[rL[x] = ++cnt] = x; 
    if (t[x].ch[1]) rdfs(t[x].ch[1]); 
    if (t[x].ch[0]) rdfs(t[x].ch[0]); 
    P[rR[x] = ++cnt] = x; 
} 
int main () { 
    N = gi(); pw[0] = 1; 
    for (int i = 1; i <= 2 * N; i++) pw[i] = pw[i - 1] * base; 
    for (int i = 1; i <= N; i++) t[i].v = gi(); 
    for (int x = 1; x <= N; x++) { 
        int ls = gi(), rs = gi(); 
        if (ls != -1) t[x].ch[0] = ls, t[ls].fa = x; 
        if (rs != -1) t[x].ch[1] = rs, t[rs].fa = x; 
    } 
    dfs(1); 
    for (int i = 1; i <= cnt; i++) hs1[0][i] = hs1[0][i - 1] * base + t[P[i]].v; 
    for (int i = 1; i <= cnt; i++) hs2[0][i] = hs2[0][i - 1] * base + get(P[i]); 
    cnt = 0; rdfs(1); 
    for (int i = 1; i <= cnt; i++) hs1[1][i] = hs1[1][i - 1] * base + t[P[i]].v; 
    for (int i = 1; i <= cnt; i++) hs2[1][i] = hs2[1][i - 1] * base + (get(P[i]) ^ 1); 
    int ans = 1; 
    for (int x = 1; x <= N; x++) { 
        int ls = t[x].ch[0], rs = t[x].ch[1]; 
        if (t[ls].size != t[rs].size) continue; 
        if (getHash(hs1[0], L[ls], R[ls]) != getHash(hs1[1], rL[rs], rR[rs])) continue; 
        if (getHash(hs2[0], L[ls], R[ls]) != getHash(hs2[1], rL[rs], rR[rs])) continue; 
        ans = max(ans, t[x].size); 
    } 
    printf("%d\n", ans); 
    return 0; 
} 
```

---

## 作者：Cheng_yf (赞：29)

~~看到竟然没有manacher的题解，蒟蒻我今天发一波~~

看到题目，在一棵二叉树上找对称，中序遍历求回文啊！

我们可以把权值的中序遍历求出来，把回文找出来。

于是权值就结束了...

------------

# $\color{red}\text{树的结构又在一旁嘿嘿的笑}$

我们需要一个值来维护这个形状

我用的是这可自述的节点数，因为一但一个点变了，这颗子树的节点数序列一定有变
化，

于是，同样求回文...

------------

manacher模板:

```cpp
void manacher(node &x,node &len){
	int mx=0,po=0;
	for(int i=1;i<=n;i++){
		if(mx>i)
		len.s[i]=min(mx-i,len.s[2*po-i]);
		else len.s[i]=1;
		while(x.s[i-len.s[i]]==x.s[i+len.s[i]]) 
		len.s[i]++;
		if(i+len.s[i]>mx) 
		mx=i+len.s[i],po=i;
	}
}
```

------------

最后判断一下与子树大小是否符合要求就行啦QAQ

Code：

```cpp
#include<cstdio>
#include<iostream>
#define N 1000005
using namespace std;
struct node{
    int s[N];
}a,siz,l1,l2; 
int n;
int l[N],r[N];
int date[N];
void manacher(node &x,node &len){
    int mx=0,po=0;
    for(int i=1;i<=n;i++){
        if(mx>i)
        len.s[i]=min(mx-i,len.s[2*po-i]);
        else len.s[i]=1;
        while(x.s[i-len.s[i]]==x.s[i+len.s[i]]) 
        len.s[i]++;
        if(i+len.s[i]>mx) 
        mx=i+len.s[i],po=i;
    }
}
int cnt=0;
int rak[N];
void dfs(int u){
    if(u==-1)return;
    dfs(l[u]);
    a.s[++cnt]=date[u];
    rak[u]=cnt;
    int ct=cnt;
    dfs(r[u]);
    siz.s[ct]=siz.s[rak[max(0,l[u])]]+siz.s[rak[max(0,r[u])]]+1;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%d",&date[i]);
    fill(a.s,a.s+N,1e9);
    fill(siz.s+1,siz.s+N,-1);
    for(int i=1;i<=n;i++)
    scanf("%d%d",&l[i],&r[i]);
    dfs(1);
    manacher(a,l1);
    manacher(siz,l2);
    int ans=0;
    for(int i=1;i<=n;i++)
    if(l1.s[i]*2-1>=siz.s[i]&&l2.s[i]*2-1==siz.s[i])
    ans=max(ans,siz.s[i]);
    printf("%d",ans);
    return 0;
}

```

# manacher大法吼

---

## 作者：wsm52 (赞：19)

# 前言
这么简单的 T4。
# 思路
只需要判断每个节点的子树是否为对称二叉树，然后计算该子树的节点个数就行了。

怎么判断是否为对称二叉树呢？先看一个图。
![](https://cdn.luogu.com.cn/upload/image_hosting/i7uonvng.png)

当到节点 $x$ 时，需要满足 $v_{l_x}=v_{r_x}$。到节点 $y$ 和 $z$ 时，需要满足 $v_{l_y}=v_{r_z}$ 和 $v_{r_y}=v_{l_z}$。若其中 $l,r$ 其中一个的值为 $-1$ 或 $v$ 不相等，那么它就不是对称二叉树。
# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,v[N],l[N],r[N],son[N];
bool dfs(int x,int y){
	if(x==-1&&y==-1) return true;//都是叶子节点时满足条件
	if(x==-1||y==-1) return false;//其中一个为叶子节点不满足
	if(v[x]!=v[y]) return false;//v值不同不满足
	return dfs(l[x],r[y])&&dfs(r[x],l[y]);
}
int count(int x){
	if(x==-1) return 0;
	son[x]=count(l[x])+count(r[x])+1;
	return son[x];
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&v[i]);
	for(int i=1;i<=n;i++) scanf("%d%d",&l[i],&r[i]);
	count(1); //计算子树的节点个数
	int sum=0;
	for(int i=1;i<=n;i++) if(dfs(i,i)) sum=max(sum,son[i]);
	printf("%d\n",sum);
	return 0;
}
```

---

## 作者：WsW_ (赞：8)

### 前言
提供一种超级好写的做法及时间复杂度证明。  
没有给时间复杂度证明的题解为什么能过呢？  

---
### 思路
对于以 $p$ 为子树根的一棵子树，该子树为对称二叉树的**必要条件**包括：$size_{l_p}=size_{r_p},dep_{l_p}=dep_{r_p}$ 等条件。我们可以运用这些条件剪枝，对于满足这些必要条件的子树根，暴力判断这棵子树是否为对称二叉树。  

实际上，只要用到 $size_{l_p}=size_{r_p}$ 这一个条件进行剪枝就够了，这样单次暴力判断的最坏时间复杂度为 $O(\log size_p)$，最坏总时间复杂度为 $O(n\log n)$。  
$size_i$ 可以通过预处理 $O(n)$ 得出。  

下面给出这个单次暴力判断的时间复杂度证明。  

容易发现，时间复杂度和**被递归到的点的个数**是同级的，我们来算**每个点最多会被递归到多少次**。  
定义函数 $f_{i}(n)$ 表示在一个有 $n$ 个节点的树上，节点 $i$ 最多会被递归到多少次。容易得出以下式子：
$$
f_{i}(n) =
\begin{cases}
1, & n=1 \\
1+f_{i}(\frac{n-1}{2}), & n\neq 1\wedge size_l=size_r \\
f_{i}(n-1), & \text{otherwise}
\end{cases}
$$
易得 $f_{i}(n)\le 1+\log n$。  
所以每一个点在暴力判断的时候最多被递归到的次数大概是 $\log n$，时间复杂度也就是 $O(n\log n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+3;
int n;
int v[maxn],l[maxn],r[maxn];
int size[maxn];
int ans;
void dfs(int p){
	if(!p)return ;
	dfs(l[p]);
	dfs(r[p]);
	size[p]=1+size[l[p]]+size[r[p]];
}

bool check(int lp,int rp){
	if(!lp&&!rp)return 1;
	if(size[lp]!=size[rp]||v[lp]!=v[rp])return 0;
	return check(l[lp],r[rp])&check(r[lp],l[rp]);
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>v[i];
	for(int i=1;i<=n;i++){
		cin>>l[i]>>r[i];
		if(l[i]==-1)l[i]=0;
		if(r[i]==-1)r[i]=0;
	}
	dfs(1);
	for(int i=1;i<=n;i++)
		if(size[i]>ans&&check(l[i],r[i]))ans=size[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：qhr2023 (赞：5)

## solution

这个对称很有递归性，所以我们暴力枚举每个点作为根，递归判断此时是否对称，求最大对称子树，子树大小可以预处理。

递归过程如下，对于当前树，将左子树的左子树与右子树的右子树比较，左子树的右子树与右子树的左子树比较，当这两组比较都合法时当前树才对称。

对于边界条件，若有一个子树为空了，则递归应该终止，此时若两个子树都为空则对称，若只有一个为空（保证结构相同）或两点的点权不等（保证点权相等）则不对称。

时间复杂度是 $\mathcal O(n \log n)$。考虑最坏情况，为了让递归尽可能跑满，我们构造完全对称的满二叉树，进行实测，发现跑不满 $1$ 秒。粗略地证明一下，这个判断对称的过程是等价[树上启发式合并](https://oi-wiki.org/graph/dsu-on-tree/#%E8%BF%87%E7%A8%8B)的，每个点在暴力判断时最多被递归到的次数大概是 $\log n$ 级别，总复杂度就是 $\mathcal O(n \log n)$。或者这么考虑，一个 $n$ 个点的满二叉树，有 $\log n$ 层，第 $i$ 层有 $2^{i-1}$ 个点，并且每个点子树大小是 $2^{\log n-i+1} - 1$，那么复杂度应该是层数乘每层节点的子树大小之和。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
int n, v[N], l[N], r[N], siz[N], ans;
void dfs (int x) {
	if (x==-1) 
		return ;
	dfs(l[x]);
	dfs(r[x]);
	siz[x]=siz[l[x]]+siz[r[x]]+1;
}
bool pd (int x, int y) {
	if (x==-1&&y==-1)
		return 1;
	if (x==-1||y==-1||v[x]!=v[y])
		return 0;
	return pd(l[x], r[y])&&pd(r[x], l[y]);
}
signed main () {
	cin >> n;
	for (int i=1; i<=n; ++i)
		cin >> v[i];
	for (int i=1; i<=n; ++i)
		cin >> l[i] >> r[i];
	dfs(1);
	for (int i=1; i<=n; ++i)
		if (pd(l[i], r[i])) 
			ans=max(ans, siz[i]);
	cout << ans;
	return 0;
}
```

---

## 作者：Tweetuzki (赞：5)

~~看到好多暴力过了让我这个考场码了 6097B 哈希的蒟蒻好难过啊~~

我们不妨先把所有节点的左右儿子交换，建出一棵新的二叉树。那么这时，可以枚举所有节点，只要检查它在原树和新树中的子树，是否结构相同且权值相等即可。

我们知道：前序遍历和中序遍历可以确定一棵二叉树的结构。那么我们对这两棵二叉树都求出它们的前序和中序遍历。遍历中的每个位置存储的不是这个位置的节点编号，而是这个位置的节点的权值乘上根据它的深度而确定的一个随机数（为了防止出题人卡，导致值相同而判错），即 $v_i \times R_{depth_i}$，因为点的深度要相同才能满足同构。

这样，对于一个点，记它在前序遍历中的位置为 $qx_i$，记它在中序遍历中的位置为 $zx_i$，那么这个点对应的子树，在前序遍历中对应着 $[qx_i, qx_i + size_i - 1]$ 这段区间，而在中序遍历中对应着 $[zx_i - size_{lson_i}, zx_i + size_{rson_i}]$ 这段区间。用字符串哈希，就可以做到 $O(1)$ 检查这棵子树是否满足要求了。

预处理哈希需要 $O(n)$ 的复杂度，枚举每个点需要 $O(n)$，但是判断只需要 $O(1)$，因此时间复杂度是 $O(n)$ 的。可以通过 $10^6$ 的数据。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
using namespace std;

typedef long long llt;

const int MaxN = 1000000 + 5;
const llt H1 = 17, H2 = 29;
const llt Mod1 = 998244353, Mod2 = 998244853;

int N;
int V[MaxN];
int ch[2][MaxN];
int qx[2][MaxN], zx[2][MaxN], cntv[2];
int dfn_qx[2][MaxN], dfn_zx[2][MaxN];
int A[2][MaxN], B[2][MaxN];
int Size[MaxN], depth[MaxN];

llt R[MaxN];
llt Power_H1[MaxN], Power_H2[MaxN];
llt Hash_A1[2][MaxN], Hash_B1[2][MaxN];
llt Hash_A2[2][MaxN], Hash_B2[2][MaxN];

inline int read() {
    int x = 0, f = 1; char c;
    do {
        c = getchar();
        if (c == '-') f = -1;
    } while (c < '0' || c > '9');
    do x = (x << 1) + (x << 3) + c - '0', c = getchar(); while (c >= '0' && c <= '9');
    return x * f;
}

void init() {
    scanf("%d", &N);
    for (int i = 1; i <= N; ++i) V[i] = read();
    for (int i = 1; i <= N; ++i) {
        ch[0][i] = read();
        ch[1][i] = read();
    }
}

// 求前序遍历
void dfs_qx(int u, int t) {
    dfn_qx[t][u] = ++cntv[t];
    qx[t][cntv[t]] = u;
    if (ch[t][u] != -1) dfs_qx(ch[t][u], t);
    if (ch[t^1][u] != -1) dfs_qx(ch[t^1][u], t);
}

// 求中序遍历
void dfs_zx(int u, int t) {
    if (ch[t][u] != -1) dfs_zx(ch[t][u], t);
    dfn_zx[t][u] = ++cntv[t];
    zx[t][cntv[t]] = u;
    if (ch[t^1][u] != -1) dfs_zx(ch[t^1][u], t);
}

// 计算子树大小及深度
void calc_size(int u) {
    Size[u] = 1;
    if (ch[0][u] != -1) {
        depth[ch[0][u]] = depth[u] + 1;
        calc_size(ch[0][u]);
        Size[u] += Size[ch[0][u]];
    }
    if (ch[1][u] != -1) {
        depth[ch[1][u]] = depth[u] + 1;
        calc_size(ch[1][u]);
        Size[u] += Size[ch[1][u]];
    }
}

void init_Hash() {
    Power_H1[0] = Power_H2[0] = 1;
    for (int i = 1; i <= N; ++i) {
        Power_H1[i] = Power_H1[i - 1] * H1 % Mod1;
        Power_H2[i] = Power_H2[i - 1] * H2 % Mod2;
    }
    for (int i = 1; i <= N; ++i) {
        Hash_A1[0][i] = (Hash_A1[0][i - 1] * H1 + A[0][i]) % Mod1;
        Hash_A2[0][i] = (Hash_A2[0][i - 1] * H2 + A[0][i]) % Mod2;
        Hash_A1[1][i] = (Hash_A1[1][i - 1] * H1 + A[1][i]) % Mod1;
        Hash_A2[1][i] = (Hash_A2[1][i - 1] * H2 + A[1][i]) % Mod2;
        Hash_B1[0][i] = (Hash_B1[0][i - 1] * H1 + B[0][i]) % Mod1;
        Hash_B2[0][i] = (Hash_B2[0][i - 1] * H2 + B[0][i]) % Mod2;
        Hash_B1[1][i] = (Hash_B1[1][i - 1] * H1 + B[1][i]) % Mod1;
        Hash_B2[1][i] = (Hash_B2[1][i - 1] * H2 + B[1][i]) % Mod2;
    }
}

// 检验该子树是否满足要求
bool check(int id) {
    int l1 = dfn_qx[0][id], l2 = dfn_qx[1][id],
        r1 = l1 + Size[id] - 1, r2 = l2 + Size[id] - 1;
    llt Hash1A1 = (Hash_A1[0][r1] - Hash_A1[0][l1 - 1] * Power_H1[r1 - l1 + 1]) % Mod1,
        Hash1A2 = (Hash_A1[1][r2] - Hash_A1[1][l2 - 1] * Power_H1[r2 - l2 + 1]) % Mod1,
        Hash2A1 = (Hash_A2[0][r1] - Hash_A2[0][l1 - 1] * Power_H2[r1 - l1 + 1]) % Mod2,
        Hash2A2 = (Hash_A2[1][r2] - Hash_A2[1][l2 - 1] * Power_H2[r2 - l2 + 1]) % Mod2;
    Hash1A1 = (Hash1A1 % Mod1 + Mod1) % Mod1;
    Hash1A2 = (Hash1A2 % Mod1 + Mod1) % Mod1;
    Hash2A1 = (Hash2A1 % Mod2 + Mod2) % Mod2;
    Hash2A2 = (Hash2A2 % Mod2 + Mod2) % Mod2;

    if (Hash1A1 != Hash1A2 || Hash2A1 != Hash2A2) return false;

    l1 = (ch[0][id] == -1 ? dfn_zx[0][id] : dfn_zx[0][id] - Size[ch[0][id]]),
    r1 = (ch[1][id] == -1 ? dfn_zx[0][id] : dfn_zx[0][id] + Size[ch[1][id]]),
    l2 = (ch[1][id] == -1 ? dfn_zx[1][id] : dfn_zx[1][id] - Size[ch[1][id]]),
    r2 = (ch[0][id] == -1 ? dfn_zx[1][id] : dfn_zx[1][id] + Size[ch[0][id]]);

    llt Hash1B1 = (Hash_B1[0][r1] - Hash_B1[0][l1 - 1] * Power_H1[r1 - l1 + 1]) % Mod1,
        Hash1B2 = (Hash_B1[1][r2] - Hash_B1[1][l2 - 1] * Power_H1[r2 - l2 + 1]) % Mod1,
        Hash2B1 = (Hash_B2[0][r1] - Hash_B2[0][l1 - 1] * Power_H2[r1 - l1 + 1]) % Mod2,
        Hash2B2 = (Hash_B2[1][r2] - Hash_B2[1][l2 - 1] * Power_H2[r2 - l2 + 1]) % Mod2;
    Hash1B1 = (Hash1B1 % Mod1 + Mod1) % Mod1;
    Hash1B2 = (Hash1B2 % Mod1 + Mod1) % Mod1;
    Hash2B1 = (Hash2B1 % Mod2 + Mod2) % Mod2;
    Hash2B2 = (Hash2B2 % Mod2 + Mod2) % Mod2;

    if (Hash1B1 != Hash1B2 || Hash2B1 != Hash2B2) return false;

    return true;
}

void solve() {
    dfs_qx(1, 0); dfs_qx(1, 1);
    cntv[0] = cntv[1] = 0;
    dfs_zx(1, 0); dfs_zx(1, 1);
    depth[1] = 1; calc_size(1);

    // 生成随机数，防止被出题人卡
    srand(2018);
    for (int i = 1; i <= N; ++i) R[i] = rand() + 1;

    for (int i = 1; i <= N; ++i) {
        A[0][i] = 1ll * V[qx[0][i]] * R[depth[qx[0][i]]];
        A[1][i] = 1ll * V[qx[1][i]] * R[depth[qx[1][i]]];
        B[0][i] = 1ll * V[zx[0][i]] * R[depth[zx[0][i]]];
        B[1][i] = 1ll * V[zx[1][i]] * R[depth[zx[1][i]]];
    }

    init_Hash();

    int Max_size = 1;
    for (int i = 1; i <= N; ++i) {
        if (check(i) == true) {
            Max_size = max(Max_size, Size[i]);
        }
    }

    printf("%d\n", Max_size);
}

int main() {
    init();
    solve();
    return 0;
}
```

---

## 作者：zhoujunchen (赞：4)

做题思路
--

一种超级好写，代码量短的思路。

枚举所有节点的子树，用一个 dfs 判断她是否为对称二叉树。

`dfs(x,y)` 表示要比较的两个节点，如果左右都是叶节点，就是对称的，如果有一个是叶节点，另一个不是叶节点那么结构不对称，如果两个节点的权值不相等也不是对称的，如果两个节点是对称的，就递归他们的左右儿子，不过是要交叉的递归。

如果这个节点的子树是对称的，就计算节点数，可以用 `sum(x)` 表示以 $x$ 为根的子树的节点数。

具体就看代码吧。


```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r,v;
}g[(int)1e6+6];
int n,ans;
bool dfs(int x,int y){
	if(x==-1&&y==-1)return 1;//左右都是叶节点
	if(x==-1||y==-1)return 0;//结构不对称
	if(g[x].v!=g[y].v)return 0;//权值不对称
	if(dfs(g[x].l,g[y].r)&&dfs(g[x].r,g[y].l))return 1;
	return 0;
}
int sum(int x){//计算节点数
	if(x==-1)return 0;//叶节点
	return sum(g[x].l)+sum(g[x].r)+1;
} 
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>g[i].v;
	for(int i=1;i<=n;i++)cin>>g[i].l>>g[i].r;
	for(int i=1;i<=n;i++)if(dfs(i,i))ans=max(ans,sum(i));
	cout<<ans;
	return 0;
}
```

---

## 作者：exprosic (赞：3)

算法很简单，对于每个节点，暴力比较其左右子树。只需要在空节点处停止比较，此外**不需要任何剪枝**。

代码就不贴了，很多人都贴过了，这里只说两点：
1. 在比较两棵树 $x$ 和 $y$ 时，不妨假设 $\textsf{size}[l[x]] \le \textsf{size}[r[x]]$，此时可以**递归**比较 $l[x]\sim r[y]$ 并**循环**比较 $r[x] \sim l[y]$. 这样的尾递归优化可以保证栈深度为 $O(\log(n))$.
2. 暴力的复杂度是 $O(n\log(n))$，而不仅仅是 $O(n^2)$。问题的关键在于，总比较次数不只是小于所有子树大小之和，而且小于所有**节点数较少的儿子**的大小之和。比如对于只有左儿子的树（即链），实际上总比较次数为  0。下面是严格证明。

令
$$f(n):= \max_{T=\textsf{大小为}n\textsf{的树}}\Bigg\{\sum_{t=T\textsf{内的节点}}\min\big\{\textsf{size}[l[t]], \textsf{size}[r[t]]\big\}\Bigg\}$$
即大小为 $n$ 的树中所有**节点数较少的儿子**的大小之和的最大值，也是总比较次数的一个上限。易知：
$$f(n) = \max\Big\{f(t) + f(n-1-t) + t \mathrel{\Big|} t=0,1,\dots, \left \lfloor{\frac{n-1}{2}}\right \rfloor \Big\}$$
其中 $t$ 代表较小的那棵子树的大小。特别定义 $f(0) = \max\{\} := 0$.

欲归纳证 $f(n) \le n\log_2(n)$.

对于 $n=0$ 和 $n=1$，$f(n) = 0 \le n\log_2(n)$.
- 注：虽然 $\log_2(n)$ 在 $n=0$ 无定义，但 $n\log_2(n)$ 在 $n=0$ 有极限 $0$，因而不影响下文依赖函数连续性的极值分析。

对于 $n>1$，由归纳假设知
$$f(n) \le \max\Big\{t\log_2(t) + (n-1-t)\log_2(n-1-t) + t \mathrel{\Big|} t \in \Big[0, \frac{n-1}{2}\Big]\Big\}$$

右边连续且关于 $t$ 的二阶导 $\frac{1}{t}+\frac{1}{n-1-t}$ 在定义区间内部恒为正，因此为闭区间内的下凸函数，存在最大值且只可能位于两端，即 $t=0$ 或 $t=\frac{n-1}{2}$. 带入可得
$$f(n)\le \max\Big\{(n-1)\log_2(n-1),\;\frac{n-1}{2}\log_2\frac{n-1}{2} \times 2 + \frac{n-1}{2}\Big\} \le n\log_2(n)$$

证毕。

考虑满二叉树可知，$O(n\log(n))$ 为暴力复杂度的精确上界。

---

## 作者：abs20187 (赞：2)

暴力做法很简单，$O(n)$ 判断两棵树是否相等，可惜要 TLE。

判断两个子字符串是否相等时，我们用一个哈希值代替字符串进行比较，判断两个子树相等也是如此。

设 $h1(x)$ 为哈希函数，$h2(x)$ 也是一个哈希函数，则一棵树以节点 $t$ 为根节点的子树不交换左右节点的哈希值为：

$$ h1(hs_{lson_t})+h2(hs_{rson_t})+a_t $$

其中，$hs_i$ 为以 $i$ 节点为根节点的哈希值，$lson_i$ 表示 $i$ 的左儿子的编号，$rson_i$ 表示 $i$ 的右儿子的编号，$a_i$ 表示第 $i$ 个点的权值。

交换左右节点的哈希值为：

$$ h2(hs_{lson_t})+h1(hs_{rson_t})+a_t $$

因此，我们可以求出每个子树交换和不交换左右儿子的哈希值。

如果这两个哈希值相等，则这个子树是对称二叉树。

这样，这道题就可做了。遍历每个子树，如其交换左右节点的哈希值与不交换左右节点的哈希值相等，则把当前子树的节点个数与当前最大对称二叉子树的节点数比较，进行更新即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1000005],l[1000005],r[1000005];
long long h1[1000005],h2[1000005],sz[1000005];
constexpr long long p1=100003,q1=100043;
constexpr long long p2=4000037,q2=4000079;
constexpr long long mod1=100000000003,mod2=100000000019;
long long ans=0;
long long hc1(long long x)
{
	x^=x>>4;
	return x*p2;
}
long long hc2(long long x)
{
	x^=x<<2;
	return x*q2;
}
void init(int id)
{
	if(id==0)
	{
		return ;
	}
	init(l[id]);
	init(r[id]);
	h1[id]=h2[id]=a[id];
	sz[id]=1;
	h1[id]+=hc1(h1[l[id]])+hc2(h1[r[id]]);
	h1[id]%=mod1;
	h2[id]+=hc2(h2[l[id]])+hc1(h2[r[id]]);
	h2[id]%=mod1;
	sz[id]+=sz[l[id]]+sz[r[id]];
	if(h1[l[id]]!=h2[r[id]]||sz[l[id]]!=sz[r[id]])
	{
		return ;
	}
	ans=max(ans,sz[id]);
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		cin>>l[i]>>r[i];
		l[i]=max(l[i],0);
		r[i]=max(r[i],0);
	}
	init(1);
	cout<<ans;
}
```

---

## 作者：Shunpower (赞：2)

提供一个 $\mathcal O(n\log n)$ 做法更简单的证明。

------------------

考虑一个暴力状的做法：我们直接枚举所有节点，让它作为对称二叉树的子树根 $rt$，检查它的左右子树是否是对称的。

具体来说，我们直接在它的两边同时从上至下搜索以匹配对称。维护左右两侧正在匹配的节点 $(i,j)$（初始时显然是 $(ls_{rt},rs_{rt})$）。如果出现 $i,j$ 中恰有一个是空节点或者都不空但权值不同，就返回不匹配。否则继续匹配 $(ls_i,rs_j)$ 和 $(rs_i,ls_j)$，把匹配结果返回回去与起来合并即可。

这样做看上去像是 $\mathcal O(n^2)$ 的，但实际上并不是。

考虑我们转化一下枚举子树根节点 $rt$ 的顺序，从下至上枚举。那么每次判定对称可以看成是合并左右子树在一起，并且复杂度不超过两倍的较小子树大小（因为较小子树匹配完之后要么就构成对称要么就一定不对称了）。

可以发现这等价于启发式合并，所以实际上是 $\mathcal O(n\log n)$ 的。

如果我们在判定开始时加上 $siz_{ls_{rt}}=siz_{rs_{rt}}$，那么复杂度可以更简单地得到：这至少可以放缩为对原树进行极大满二叉树划分。每个大小为 $a$ 的满二叉树的复杂度都显然是 $\mathcal O(\sum siz)=\mathcal O(a\log a)$，鉴于这是一个划分。所以 $\sum\mathcal O(a\log a)=\mathcal O(n\log n)$。

好写程度非常无敌，并且跑得比写得丑的哈希还快。

```cpp
int n;
int val[N];
int ls[N],rs[N];
int siz[N];
void dfs(int x){
    if(!(~x)) return;
    siz[x]=1;
    dfs(ls[x]);
    siz[x]+=((~ls[x])?siz[ls[x]]:0);
    dfs(rs[x]);
    siz[x]+=((~rs[x])?siz[rs[x]]:0);
}
bool same(int rt1,int rt2){
    bool f1=~rt1,f2=~rt2;
    if(!f1&&!f2) return 1;
    if(f1^f2) return 0;
    if(val[rt1]!=val[rt2]) return 0;
    return same(ls[rt1],rs[rt2])&same(rs[rt1],ls[rt2]);
}
int main(){
#ifdef Shun
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n;
    fr1(i,1,n) cin>>val[i];
    fr1(i,1,n) cin>>ls[i]>>rs[i];
    dfs(1);
    int ans=1;
    fr1(i,1,n){
        if(same(ls[i],rs[i])) ans=max(ans,siz[i]);
    }
    cout<<ans<<'\n';
    ET;
}
```

---

## 作者：kind_Ygg (赞：1)

这是一道证明复杂度的好题，前提是你没有学过树上启发式合并。
## 题目大意
给定一颗二叉树，并且左右对称（相对应的权值相等）。
## 思路
最开始我是并没有想出怎么写正解的（当时没学树上启发式合并），就糊了个自认为是暴力的代码上去，没想到就 AC 了。

主要思路是暴力匹配，非常简单，也没什么要说的，就直接贴上代码了：

```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e6+5;
int n;
int val[N];
int l[N],r[N];
bool check(int left,int right)
{
	if(val[right]!=val[left])
		return 0;
	else if(right==-1&&left==-1)
		return 1;
	return check(l[left],r[right])&&check(l[right],r[left]);
}
int sum(int rt)
{
	if(rt==-1)
		return 0;
	return sum(l[rt])+sum(r[rt])+1;
}
int maxn=-1;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>val[i];
	for(int i=1;i<=n;i++)
		cin>>l[i]>>r[i];
	for(int i=1;i<=n;i++)
		if(check(i,i))
			maxn=max(maxn,sum(i));
	cout<<maxn<<'\n';
	return 0;
}
```
## 时间复杂度证明
这题的大头就是证明。  
理论上来说应该是 $O(n^2)$。但具体式子是：

$\sum_{i=1}^{\log n}\sum_{j=1}^{2^{i-1}} (2^{\log n-i+1}-1)$

化简（整棵树减去第 $i$ 层级以下的）：

$\sum_{i=1}^{\log n}n-2^{i-2}$

约为 $O(n \log n)$。
## 闲语
考试的时候考了这一题，老师在考前还为数不多地提醒我们要把暴力打满，就是因为有了这道题。（~~但我就是没打~~）

---

## 作者：lusq (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5018)

## 思路

题目大意：给出一棵二叉树，找到最大的对称子树。

我们可以把题目分为两部分实现：最大、对称子树。

“最大”比较简单，只要把对称子树的节点数求出来，然后求最大值就行了。

而本题的重点在于如何判断对称子树：

很明显，对称子树的判断与子树的根节点没有关系，只要左右子树 $ls_i$ 和 $rs_i$ 对称即可。

而判断左右子树对称，只需左子树的左子树 $ls_l$ 与右子树的右子树 $rs_r$ 对称，左子树的右子树 $rs_l$ 与右子树的左子树 $ls_r$ 对称即可。

看到这里，你也许明白了：可以用递归判断对称子树。

既然是递归，就一定要有边界值：

1. 如果判断对称的两棵子树 $l$ 和 $r$ 都为空，那么一定对称。

2. 如果 $l$ 和 $r$ 其中一棵为空，那么一定不对称。

3. 如果 $l$ 和 $r$ 根节点权值不同，那么一定不对称。

现在，你已经可以通过本题，但是我们还可以做一点优化：

1. 如果 $l$ 和 $r$ 节点数不同，那么一定不对称。

2. 如果一棵子树的节点数小于等于已经找到的最大对称子树节点数，那么一定不是最大的对称子树。

## code

~~大佬们的代码都好长~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005],l[1000005],r[1000005],c[1000005],maxn=0;
bool check(int le,int ri){//判断两棵子树是否对称
	if(le==-1 && ri==-1){//两棵子树都为空
		return true;
	}
	if(le==-1 || ri==-1){//两棵子树有一棵为空
		return false;
	}
	if(c[le]!=c[ri]){//两棵子树节点数不同
		return false;
	}
	if(a[le]!=a[ri]){//两棵子树根节点权值不同
		return false;
	}
	return check(l[le],r[ri]) && check(l[ri],r[le]);//递归判断
}
void dfs(int ro){//判断一棵子树是否对称
	if(ro==-1){
		return;
	}
	c[ro]=1;//当前子树节点数
	if(l[ro]!=-1){
		dfs(l[ro]);
		c[ro]+=c[l[ro]];
	}
	if(r[ro]!=-1){
		dfs(r[ro]);
		c[ro]+=c[r[ro]];
	}
	if(c[ro]>maxn && check(l[ro],r[ro])){//当前子树节点数大于已经找到的最大节点数，并且当前子树对称，就更新答案
		maxn=c[ro];
	}
	return;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>l[i]>>r[i];
	}
	dfs(1);
	cout<<maxn;
 	return 0;
}
```

---

## 作者：yr409892525 (赞：1)

## [P5018 [NOIP2018 普及组] 对称二叉树](https://www.luogu.com.cn/problem/P5018)
这道题的对称二叉树的规则为：两个子树不仅结构对称，还有点权对称。   

那么如何判断结构对称呢。   

我们知道，如果节点 $i$ 的左右子树对称，我们就可以合成一个长度为原来的两倍**加一**的对称二叉树，因为根可以不对称。   

这样我们就可以枚举节点，每个节点我们都去判断它的左右子树是否对称，递归向下找。   

如果左右子树都为空，对称。   
如果左右子树不同，不对称。  

如何判断结构相同，直接判断子树大小是否相同，节点 $i$ 的子树大小是以 $i$ 为根节点的节点数量。
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n;
struct code{
	int l,r;
	int siz,x;
}a[1000005];
int dfs(int u){
	if(u==-1) return 0;
	a[u].siz=1+dfs(a[u].l)+dfs(a[u].r);
	return a[u].siz;
}
bool check(int l,int r){
	if(l==-1 && r==-1) return 1;
	if(a[l].x!=a[r].x) return 0;
	if(l!=-1 && r!=-1){
		if(check(a[l].l,a[r].r) && check(a[l].r,a[r].l)){
			return 1;
		}
	}
	return 0;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].l>>a[i].r;
	}
	dfs(1);
	int ma=1;
	for(int i=1;i<=n;i++){
		if(a[i].l!=-1 && a[i].r!=-1){
			if(check(a[i].l,a[i].r)){
				ma=max(ma,a[i].siz);
			}
		}
	}
	cout<<ma<<"\n";
	return 0;
}
```

---

## 作者：cqsunny (赞：1)

建议在 [博客](https://blog.csdn.net/m0_64542522/article/details/144783664) 查看。

---

考虑如何求解树的对称性问题。

---

假如我们现在在 $i$ 号结点，其左儿子为 $l_i$，右儿子为 $r_i$。

若 $l_i$ 和 $r_i$ 都为 $-1$，即都不存在，则以 $i$ 为根的子树是对称的。

若 $l_i$ 和 $r_i$ 有一个为 $-1$，则以 $i$ 为根的子树必定不是对称的。

剩下了 $l_i$ 和 $r_i$ 都不为 $-1$ 的情况，即两棵子树都不为空。

若 $i$ 是对称的，则 $l_i$ 和 $r_i$ 的子树大小必须相等（用来剪枝），并且 $l[l_i]$ 和 $r[r_i]$ 的子树相同，$r[l_i]$ 和 $l[r_i]$ 的子树相同。

---

如果递归中只记录一个变量，就不好处理。

在递归中记录两个变量，表示两边递归到的变量。

先判断为空的情况，再判断两个变量的 $a$ 值是否相等，不是的话就一定不对称。

最后对于两棵子树不为空的情况，直接递归 $(l[l_i], r[r_i])$ 和 $(r[l_i], l[r_i])$。

---

如果加上大小的剪枝，就再写一个计算子树大小的 `dfs` 即可。

```cpp
void dfs1(int x){//计算子树大小
	if(x == -1){
		return;
	}
	dfs1(l[x]);
	dfs1(r[x]);
	size[x] = 1 + size[l[x]] + size[r[x]];//自己 + 左子树 + 右子树
}
bool dfs2(int x, int y){
	if(size[x] != size[y]){//子树大小不相等
		return 0;
	}
	if(a[x] != a[y]){//值不相等
		return 0;
	}
	if((x == -1) && (y == -1)){//两个子树为空
		return 1;
	}
	if((x == -1) || (y == -1)){//子树有一个为空
		return 0;
	}
	return dfs2(l[x], r[y]) && dfs2(r[x], l[y]);//向下递归
}
int main(){
	dfs1(1);
	for(int i = 1; i <= n; ++ i){
		if(dfs2(i, i)){//根为 i 的子树是对称的
			ans = max(ans, size[i]);
		}
	}
}
```

---

## 作者：chrispang (赞：0)

### 题目大意

给出一个二叉树，判断给定的树的最大对称二叉子树的节点数。

对称二叉树的定义：

1. 二叉树
2. 将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等

### 题目思路

~~哎不是为啥 T4 这么简单？比 T3 简单多了~~

枚举每棵子树，判断递归的判断左右子树分别相等。相等就记数，更新答案即可（是的，只有一行分析）。

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
using namespace std;

inline int read() { //快读 
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

inline void write(int x) { //快写 
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

int n, ans, siz[maxn]; //siz[i]表示下标为i的子树的大小 
struct node {
	int val, left, right;
}a[maxn]; //记录一个节点的权值，左右子树的下标 

inline bool work(int l, int r) {
	if(l == -1 && r == -1) return 1; //如果都搜到了空节点，则返回true 
	if(l == -1 || r == -1) return 0; //如果有一个搜到了空节点，则返回false 
	if(a[l].val != a[r].val) return 0; //如果权值不相等，则返回false
	return work(a[l].left, a[r].right) && work(a[l].right, a[r].left); //递归判断左右子树是否相等 
}

inline int dfs(int x) { //用来计算子树大小 
	return x == -1 ? 0 : siz[x] = dfs(a[x].left) + dfs(a[x].right) + 1; //如果搜到空节点，则大小为0；否则接着往下搜 
}

signed main() {
	n = read();
	for (int i = 1; i <= n; i++) a[i].val = read();
	for (int i = 1; i <= n; i++) a[i].left = read(), a[i].right = read();
	dfs(1); //先预处理 
	for (int i = 1; i <= n; i++) if(work(i, i)) ans = ans > siz[i] ? ans : siz[i]; //如果发现可以更新，则更新 
	write(ans);
	return 0;
}
```

---

## 作者：collegiate (赞：0)

### 前言
好吧，这种题对我这种蒟蒻来说好像是有点难度的。

### [题目传送门](https://www.luogu.com.cn/problem/P5018)

### 思路
我们知道，对称二叉树要满足**结构对称**和**权值对称**才能被称为对称二叉树。

我们要求的是**树的最大对称二叉子树的节点数**，那就求节点个数呗，反正还是简简单单的：


```cpp
void count_son(ll x){
	if(x==-1) return ;
	ll ans=1;
	count_son(l[x]);
	ans+=son[l[x]];
	count_son(r[x]);
	ans+=son[r[x]];
	son[x]=ans;
}
```

**解释一下**：当前的子树就是**左子树的节点个数**加上**右子树的节点个数**即可，但是输入有没有子节点的，所以特判一下，如果是 $-1$ 就退出呗。

那么改判断对称二叉树了，怎么判断呢？非常简单！

> 首先，如果两个节点 $x$ 和 $y$ 是叶子结点的话，那么这两个节点就是**对称的**。
>
> 然后，如果两个节点 $x$ 和 $y$ 有一个是叶子结点而有一个不是，那么就**不是对称的**。
>
> 最后，如果 $val_x$ 和 $val_y$ 不同的话，也是**不对称的**，因为权值不同。
>
> 好了，我们已经判断完了，但是还要判断他们的左右孩子，看看是否也是对称的，但是要**交叉判断**，因为是对称的嘛。
>

#### 时间复杂度证明
由于时间复杂度与**被递归到的点的个数**是同级的，所以只用求**每个点最多会被递归到的次数**即可。

那么显而易见，若一共有 $\log n$ 那么对于一个第 $i$ 层的一个节点的子树大小就为 $2^{\log n-i+1} - 1$,而对于第 $i$ 层又有 $2^{i-1}$ 个节点，所以时间复杂度就为：

$$\sum_{i=1}^{\log n} \sum_{j=1}^{2^{i-1}} (2^{\log n-i+1} - 1)$$

最后化简一下就能得出此题的时间复杂度为 $O(n \log n)$ 了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+5;
ll l[N],r[N],son[N],val[N];
ll n,ans=1;
void count_son(ll x){//找节点数
	if(x==-1) return ;
	ll ans=1;
	count_son(l[x]);
	ans+=son[l[x]];
	count_son(r[x]);
	ans+=son[r[x]];
	son[x]=ans;
}
bool check(ll x,ll y){//判断是否是对称二叉树
	if(x==-1 && y==-1) return 1;//对应上文
	if(x==-1 || y==-1) return 0;
	if(val[x] != val[y]) return 0;
	return min(check(l[x],r[y]),check(r[x],l[y]));
  //交叉判断！！！不要忘了
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>val[i];
	for(int i=1;i<=n;i++) cin>>l[i]>>r[i];
	count_son(1);
//	for(int i=1;i<=n;i++) cout<<son[i]<<' ';
//	cout<<endl;
	for(int i=1;i<=n;i++) if(check(l[i],r[i])) ans=max(ans,son[i]);//注意是求最大值不是和QWQ
	cout<<ans;
	return 0;
}
```

---

## 作者：Lcm_simida (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P5018)

思路：考虑枚举每个子树的根节点，此时只需判断该子树是否为对称二叉树并且存入该子树的节点数。

对于每个子树的节点数提前预处理出来即可。

对于判断该树是否为对称二叉树可以从根节点开始遍历，递归判断左儿子的左节点与右儿子的右节点构成的子树相等且都是对称二叉树，再用同样的方法递归判断左儿子的右节点与右儿子的左节点构成的子树即可。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000005],l[1000005],r[1000005],f[1000005];
void find(long long x){
	long long cnt=1;
	if(l[x]!=-1){
		find(l[x]);
		cnt+=f[l[x]];
	}
	if(r[x]!=-1){
		find(r[x]);
		cnt+=f[r[x]];
	}
	f[x]=cnt;
	//return cnt;
}
long long dfs(long long la,long long ra){
	if(la==-1&&ra==-1) return 1;
	if(la==-1||ra==-1) return 0;
	if(a[la]!=a[ra]) return 0;
	return min(dfs(l[la],r[ra]),dfs(r[la],l[ra]));
}
int main(){
	cin>>n;
	for(long long i=1;i<=n;i++){
		cin>>a[i];
	}
	for(long long i=1;i<=n;i++){
		cin>>l[i]>>r[i];
	}
	find(1);
	long long ans=1;
	for(long long i=1;i<=n;i++){
		if(dfs(l[i],r[i])==1){
			ans=max(ans,f[i]);
		}
	}
	cout<<ans;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

考虑枚举每个点，进行搜索来判断对称。

怎么搜呢？与正常的搜索参数当前根节点不同，要放俩参数分别表示左右两部分，递归的时候两边分别去不一样的方向就行。

这样看起来是暴力，但是随手造了个数据发现过了。考虑验证。

由于我太菜了，我决定使用实际测试的方法。显然不对称的时候完全跑不满，不能用于验证。考虑让每个子树对称——构造满二叉树即可。

数据范围是 $n\le 10^6$，同时 $2^{20}-1$ 只是大了一点点，所以可以构建一个深度是 $20$ 的满二叉树。同时权值相同保证数据也对称。

结果发现即使卡满也不到 $1$ 秒。

考虑如何证明。设深度 $d=\log n$。这样的一棵树第 $i$ 层任意一个节点的子树大小是 $2^{d-i+1}-1$，同时第 $i$ 层一共 $2^{i-1}$ 个节点，忽略常数总共是 $2^d=n$，一共有 $d$ 层所以用复杂度是 $O(n\log n)$。

再说卡不满的话也就是一长一短、一多一少，显然也是严格满足这个证明的。

## 代码实现

```cpp
#include<bits/stdc++.h>

using namespace std;

constexpr int N=1e6+1;

int n,f[N],siz[N];

bool mir[N];

struct TreeNode{

	int fa,ls,rs,val;

	TreeNode(int fa=-1,int ls=-1,int rs=-1,int val=0):fa(fa),ls(ls),rs(rs),val(val){}

}p[N];

bool check(int u1,int u2){

	bool k=(p[u1].ls==-1)==(p[u2].rs==-1)&&(p[u1].rs==-1)==(p[u2].ls==-1)&&p[u1].val==p[u2].val;

	if(!k)

		return 0;

	if(p[u1].ls!=-1&&p[u2].rs!=-1)

		k&=check(p[u1].ls,p[u2].rs);

	if(p[u1].rs!=-1&&p[u2].ls!=-1)

		k&=check(p[u1].rs,p[u2].ls);

	return k;

}

int dfs1(int u){

	if(p[u].ls==-1&&p[u].rs==-1){

		siz[u]=1,mir[u]=1;

		return siz[u];

	}

	if(p[u].ls==-1){

		mir[u]=0;

		return siz[u]=dfs1(p[u].rs)+1;

	}

	if(p[u].rs==-1){

		mir[u]=0;

		return siz[u]=dfs1(p[u].ls)+1;

	}

	mir[u]=check(p[u].ls,p[u].rs);

	return siz[u]=dfs1(p[u].ls)+dfs1(p[u].rs)+1;

}

int dfs2(int u){

	if(p[u].ls!=-1)

		f[u]=max(f[u],dfs2(p[u].ls));

	if(p[u].rs!=-1)

		f[u]=max(f[u],dfs2(p[u].rs));

	if(mir[u])

		f[u]=max(f[u],siz[u]);

	return f[u];

}

int main(){

	cin>>n;

	for(int i=1;i<=n;i++)

		cin>>p[i].val;

	for(int i=1,ls,rs;i<=n;i++){

		cin>>ls>>rs;

		p[i].ls=ls,p[ls].fa=i;

		p[i].rs=rs,p[rs].fa=i;

	}

	dfs1(1);

	cout<<dfs2(1);

	return 0;

}
```

---


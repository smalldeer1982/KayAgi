# [CSP-J2020] 表达式

## 题目描述

小 C 热衷于学习数理逻辑。有一天，他发现了一种特别的逻辑表达式。在这种逻辑表达式中，所有操作数都是变量，且它们的取值只能为 $0$ 或 $1$，运算从左往右进行。如果表达式中有括号，则先计算括号内的子表达式的值。特别的，这种表达式有且仅有以下几种运算：
1. 与运算：`a & b`。当且仅当 $a$ 和 $b$ 的值都为 $1$ 时，该表达式的值为 $1$。其余情况该表达式的值为 $0$。
2. 或运算：`a | b`。当且仅当 $a$ 和 $b$ 的值都为 $0$ 时，该表达式的值为 $0$。其余情况该表达式的值为 $1$。
3. 取反运算：`!a`。当且仅当 $a$ 的值为 $0$ 时，该表达式的值为 $1$。其余情况该表达式的值为 $0$。

小 C 想知道，给定一个逻辑表达式和其中每一个操作数的初始取值后，再取反某一个操作数的值时，原表达式的值为多少。

为了化简对表达式的处理，我们有如下约定：

表达式将采用**后缀表达式**的方式输入。

后缀表达式的定义如下：
1. 如果 $E$ 是一个操作数，则 $E$ 的后缀表达式是它本身。
2. 如果 $E$ 是 $E_1~\texttt{op}~E_2$ 形式的表达式，其中 $\texttt{op}$ 是任何二元操作符，且优先级不高于 $E_1$ 、$E_2$ 中括号外的操作符，则 $E$ 的后缀式为 $E_1' E_2' \texttt{op}$，其中 $E_1'$ 、$E_2'$ 分别为 $E_1$、$E_2$ 的后缀式。
3. 如果 $E$ 是 $E_1$ 形式的表达式，则 $E_1$ 的后缀式就是 $E$ 的后缀式。

同时为了方便，输入中：

1. 与运算符（&）、或运算符（|）、取反运算符（！）的左右**均有一个空格**，但**表达式末尾没有空格**。
2. 操作数由小写字母 $x$ 与一个正整数拼接而成，正整数表示这个变量的下标。例如：`x10`，表示下标为 $10$ 的变量 $x_{10}$。数据保证**每个变量在表达式中出现恰好一次**。

## 说明/提示

### 样例 1 解释


该后缀表达式的中缀表达式形式为 $(x_1 \operatorname{and} x_2) \operatorname{or} x_3$。

- 对于第一次询问，将 $x_1$ 的值取反。此时，三个操作数对应的赋值依次为 $0$，$0$，$1$。原表达式的值为 $(0\&0)|1=1$。
- 对于第二次询问，将 $x_2$ 的值取反。此时，三个操作数对应的赋值依次为 $1$，$1$，$1$。原表达式的值为 $(1\&1)|1=1$。
- 对于第三次询问，将 $x_3$ 的值取反。此时，三个操作数对应的赋值依次为 $1$，$0$，$0$。原表达式的值为 $(1\&0)|0=0$。

### 样例 2 解释


该表达式的中缀表达式形式为 $(\operatorname{not}x_1)\operatorname{and}(\operatorname{not}((x_2\operatorname{or}x_4)\operatorname{and}(x_3\operatorname{and}(\operatorname{not}x_5))))$。

### 数据规模与约定

- 对于 $20\%$ 的数据，表达式中有且仅有与运算（&）或者或运算（|）。
- 对于另外 $30\%$ 的数据，$|s| \le 1000$，$q \le 1000$，$n \le 1000$。
- 对于另外 $20\%$ 的数据，变量的初值全为 $0$ 或全为 $1$。
- 对于 $100\%$ 的数据，$1 \le |s| \le 1 \times 10^6$，$1 \le q \le 1 \times 10^5$，$2 \le n \le 1 \times 10^5$。

其中，$|s|$ 表示字符串 $s$ 的长度。

## 样例 #1

### 输入

```
x1 x2 & x3 |
3
1 0 1
3
1
2
3
```

### 输出

```
1
1
0```

## 样例 #2

### 输入

```
x1 ! x2 x4 | x3 x5 ! & & ! &
5
0 1 0 1 1
3
1
3
5
```

### 输出

```
0
1
1
```

# 题解

## 作者：OMG_wc (赞：167)

本场比赛最难的题目，难度远远大于T4，其实是一道模拟+结论题。

首先输入的一坨字符串要先解析，利用栈来建表达式树，这就是一个小模拟，相信正常人都会吧。

对于非运算，我直接用德·摩根定律，下传标记让子树信息都反一下。（其实没必要，当初这样写是因为觉得每个结点都二叉比较美，方便后续处理）

题目里有个信息是“每个变量在表达式中出现恰好一次”，而每个询问只改变一个变量的值，这对原答案来说就产生两个可能：变或不变。这听起来是一句废话，其实蕴含的意思是：有些变量对整个表达式其决定作用，其改变则原答案也改变；有些变量对整个表达式根本没用，其变不变原答案都不变。

说明白一点，就是`1 & x = x` ，`0 | x= x`  ，这两个公式里的 $x$ 就起了决定性作用，而 `0 & x = 0` ，`1 | x= 1` 的 $x$ 就是一个废物。

那我们就给树上每个结点建一个废物标记，对`&` 来说，如果一棵子树是 $0$，那另外一棵子树内所有叶结点都应该打上废物标记，对`|`同理。

先计算出原表示答案`ans`，这样我们在查询的时候，没被标记的就说明它往上到根节点都不存在一种让它变成废物的运算，所以答案是`!ans`，如果有标记则答案依旧为`ans`。

时间复杂度 $O(n+q)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
const int N = 1000005;

char s[N];
int a[N];
int son[N][2], ck;
int flag[N], c[N];
int n, q;
int dfs(int u, int g) {
    a[u] ^= g;
    if (u <= n) {
        return a[u];
    }
    int x = dfs(son[u][0], g ^ flag[son[u][0]]);
    int y = dfs(son[u][1], g ^ flag[son[u][1]]);
    if (a[u] == 2) {
        if (x == 0) c[son[u][1]] = 1;
        if (y == 0) c[son[u][0]] = 1;
        return x & y;
    } else {
        if (x == 1) c[son[u][1]] = 1;
        if (y == 1) c[son[u][0]] = 1;
        return x | y;
    }
}
void dfs2(int u) {
    if (u <= n) return;
    c[son[u][0]] |= c[u];
    c[son[u][1]] |= c[u];
    dfs2(son[u][0]);
    dfs2(son[u][1]);
}
int main() {
    // freopen("expr.in", "r", stdin);
    // freopen("expr.out", "w", stdout);
    gets(s);
    scanf("%d", &n);
    ck = n;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }
    stack<int> b;
    for (int i = 0; s[i]; i += 2) {
        if (s[i] == 'x') {
            int x = 0;
            i++;
            while (s[i] != ' ') {
                x = x * 10 + s[i] - '0';
                i++;
            }
            i--;
            b.push(x);
        } else if (s[i] == '&') {
            int x = b.top();
            b.pop();
            int y = b.top();
            b.pop();
            b.push(++ck);
            a[ck] = 2;
            son[ck][0] = x;
            son[ck][1] = y;
        } else if (s[i] == '|') {
            int x = b.top();
            b.pop();
            int y = b.top();
            b.pop();
            b.push(++ck);
            a[ck] = 3;
            son[ck][0] = x;
            son[ck][1] = y;
        } else if(s[i] == '!'){
            flag[b.top()] ^= 1;
        }
    }
    int ans = dfs(ck, flag[ck]);
    dfs2(ck);
    scanf("%d", &q);
    while (q--) {
        int x;
        scanf("%d", &x);
        printf("%d\n", c[x] ? ans : !ans);
    }
    return 0;
}
```


---

## 作者：Aleph1022 (赞：56)

讲个非普及的没脑子做法。  
考场怒码 4.5KB，民间数据貌似还都过了（

首先建表达式树的过程很简单，别的题解都讲了，我就不赘述了（

考虑设 $f_u$ 表示结点 $u$ 的子树内计算出的布尔值。  
若 $u$ 是一个与运算符，则 $f_u = \prod\limits_{v \in {\rm son}(u)} f_v$。  
若 $u$ 是一个或运算符，则 $f_u = 1 - \prod\limits_{v \in {\rm son}(u)}(1-f_v)$。

考场上写出来这个，我当即就想到了 [P5281](/problem/P5281)（  
于是由于我太弱还没写过全局平衡二叉树不敢太莽，我只写了个 $O((n+q) \log^2 n)$ 的树剖 + 线段树维护动态链分治（或者说动态 DP）。

这个做法也可以支持：
 - 修改非临时而是永久生效
 - 非布尔值而是概率

代码：
```cpp
#include <cstdio>
#include <cassert>
#include <cstring>
#define ls (p << 1)
#define rs (ls | 1)
using namespace std;
const int S = 2e6;
const int N = 2e5;
int n,q,len,a[N + 5],tot;
char s[S + 5];
int rev[N + 5],type[N + 5];
int to[N + 5],pre[N + 5],first[N + 5];
inline void add(int u,int v)
{
	static int tot = 0;
	to[++tot] = v,pre[tot] = first[u],first[u] = tot;
}
int fa[N + 5],dep[N + 5],son[N + 5],sz[N + 5],top[N + 5],id[N + 5],ed[N + 5],rt;
namespace BUILDER
{
	int st[N + 5],top;
	char x;
	int num;
	void build()
	{
		tot = n;
		s[len] ^ ' ' && (s[++len] = ' ');
		for(register int i = 1;i <= len;++i)
			if(s[i] == ' ')
			{
				if(x == '!')
					rev[st[top]] ^= 1;
				else if(x == 'x')
					st[++top] = num,num = 0;
				else
					type[++tot] = x == '|',
					fa[st[top]] = fa[st[top - 1]] = tot,
					add(tot,st[top]),add(tot,st[top - 1]),
					st[--top] = tot;
				x = 0;
			}
			else if(s[i] >= '0' && s[i] <= '9')
				num = num * 10 + (s[i] ^ '0');
			else
				x = s[i];
	}
}
struct Value
{
	int cnt,v;
	inline Value(int x = 0)
	{
		if(x)
			cnt = 0,v = x;
		else
			cnt = v = 1;
	}
	inline Value(int a,int b)
	{
		cnt = a,v = b;
	}
	inline Value operator*(const Value &o) const
	{
		return Value(cnt + o.cnt,v * o.v);
	}
	inline Value operator/(const Value &o) const
	{
		return Value(cnt - o.cnt,v / o.v);
	}
	inline int operator()() const
	{
		return cnt ? 0 : v;
	}
} g[N + 5];
int f[N + 5];
struct func
{
	int k,b;
	inline func(int x = 1,int y = 0)
	{
		k = x,b = y;
	}
	inline func operator*(const func &o) const
	{
		return func(k * o.k,k * o.b + b);
	}
} seg[(N << 2) + 5],w[N + 5];
void build(int p,int tl,int tr)
{
	if(tl == tr)
	{
		seg[p] = w[tl];
		return ;
	}
	int mid = tl + tr >> 1;
	build(ls,tl,mid),build(rs,mid + 1,tr);
	seg[p] = seg[ls] * seg[rs];
}
void insert(int x,func k,int p,int tl,int tr)
{
	if(tl == tr)
	{
		seg[p] = k;
		return ;
	}
	int mid = tl + tr >> 1;
	x <= mid ? insert(x,k,ls,tl,mid) : insert(x,k,rs,mid + 1,tr);
	seg[p] = seg[ls] * seg[rs];
}
inline void insert(int p)
{
	if(!rev[p] && !type[p])
		insert(id[p],func(g[p](),0),1,1,tot);
	else if(!rev[p] && type[p])
		insert(id[p],func(g[p](),1 - g[p]()),1,1,tot);
	else if(rev[p] && !type[p])
		insert(id[p],func(-g[p](),1),1,1,tot);
	else if(rev[p] && type[p])
		insert(id[p],func(-g[p](),g[p]()),1,1,tot);
}
func query(int l,int r,int p,int tl,int tr)
{
	if(l <= tl && tr <= r)
		return seg[p];
	int mid = tl + tr >> 1;
	if(l <= mid && r > mid)
		return query(l,r,ls,tl,mid) * query(l,r,rs,mid + 1,tr);
	else if(l <= mid)
		return query(l,r,ls,tl,mid);
	else
		return query(l,r,rs,mid + 1,tr);
}
void dfs1(int p)
{
	sz[p] = 1,f[p] = p <= n ? a[p] : 1;
	for(register int i = first[p];i;i = pre[i])
	{
		dep[to[i]] = dep[p] + 1,dfs1(to[i]),sz[p] += sz[to[i]],f[p] *= (type[p] ? 1 - f[to[i]] : f[to[i]]);
		if(!son[p] || sz[son[p]] < sz[to[i]])
			son[p] = to[i];
	}
	(type[p] ^ rev[p]) && (f[p] ^= 1);
}
void dfs2(int p)
{
	static int tot = 0;
	id[p] = ++tot,g[p] = p <= n ? a[p] : 1;
	if(son[p])
		top[son[p]] = top[p],dfs2(son[p]),ed[p] = ed[son[p]];
	else
		ed[p] = p;
	for(register int i = first[p];i;i = pre[i])
		if(to[i] ^ son[p])
			top[to[i]] = to[i],dfs2(to[i]),g[p] = g[p] * (type[p] ? 1 - f[to[i]] : f[to[i]]);
}
void update(int p)
{
	for(;p;p = fa[p])
	{
		insert(p),p = top[p];
		func x = query(id[p],id[ed[p]],1,1,tot);
		g[fa[p]] = g[fa[p]] / (type[fa[p]] ? 1 - f[p] : f[p]),
		f[p] = x.k * (type[ed[p]] ^ 1) + x.b,
		g[fa[p]] = g[fa[p]] * (type[fa[p]] ? 1 - f[p] : f[p]);
	}
}
int main()
{
	//freopen("expr.in","r",stdin),freopen("expr.out","w",stdout);
	char ch = getchar();
	do
		s[++len] = ch,ch = getchar();
	while(ch ^ '\r' && ch ^ '\n');
	scanf("%d",&n),BUILDER::build();
	for(register int i = 1;i <= tot;++i)
		if(!fa[i])
			rt = i;
	for(register int i = 1;i <= n;++i)
		scanf("%d",a + i);
	dep[rt] = 1,top[rt] = rt,dfs1(rt),dfs2(rt);
	for(register int i = 1;i <= tot;++i)
		if(!rev[i] && !type[i])
			w[id[i]] = func(g[i](),0);
		else if(!rev[i] && type[i])
			w[id[i]] = func(g[i](),1 - g[i]());
		else if(rev[i] && !type[i])
			w[id[i]] = func(-g[i](),1);
		else if(rev[i] && type[i])
			w[id[i]] = func(-g[i](),g[i]());
	build(1,1,tot);
	scanf("%d",&q);
	for(int x;q;--q)
		scanf("%d",&x),
		rev[x] ^= 1,update(x),
		printf("%d\n",f[rt]),
		rev[x] ^= 1,update(x);
	fclose(stdin),fclose(stdout);
	return 0;
}
```

---

## 作者：_LHF_ (赞：28)

# 给出一种O(n)的做法
这一题可谓是CSP-J2020最难的一道题了
## 瞎扯部分
#### ~~某组织貌似把题目顺序弄错了~~
按照以往的规则，第三道题都应该是动态规划的题目，第四道题目才应该是需要用到数据结构的题目。

因为这一点，我是先做完了T4再来弄T3的。

本人T3代码较长，不喜勿喷。
## 正题
看到这种东西，肯定是要先转化一下的，该转化成什么呢？

呃呃，如果你愿意，你可以转化成一个中缀表达式，但本人更喜欢转化成一棵树。~~如果你不会如何把一个后缀表达式转化成一棵树的话可以走了，Have a nice day!~~

第一步，我们先求出什么都不变时候的值，那我们可以做到 $O(n)$，而且在每一个节点标记了当前子树的表达式的值。

考虑到每一次只会修改一个点，而且修改之后下一次会变回来，我们可以考虑暴力。

就是暴力从修改的节点往上跳。
### 不会超时吗！？
那当然……会啦。

但我们可以这样想，假设我们要修改这一个点，如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/3dvlsbkn.png)

优化：在一个点被改变后往上跳的过程中，如果跳到的那个点的值没有发生改变，那么肯定不会影响答案。

但这样好像还是不可以……

再优化：如果一个点被改变不会影响答案，那么直接标记一下，下一次经过这个点就直接返回。
![](https://cdn.luogu.com.cn/upload/image_hosting/9idfutno.png)

这样的话，每一个点最多被访问一次。
#### 这样的话，我们就成功的把时间复杂度降到了 $O(n)$

好了，上代码：
```cpp
#include<cstdio>
#define N 200010
#define gc getchar()
using namespace std;
struct node{
	bool p1,p2,p3;
	int ls,rs,fa;
}k[N];
int tot;
int add_node(bool type,int a)
{
	tot++;
	if(type) k[tot].p1=a;
	return tot;
}
void chg_node(int a)
{
	k[a].p2^=1;
}
int first[N],cnt;
void add_edge(int a,int ls,int rs)
{
	k[a].ls=ls;
	k[a].rs=rs;
	k[ls].fa=a;
	k[rs].fa=a;
}
char str[N];
int len,top,t[N],tt[N],x;
void work()
{
	if(len<2)
	{
		if(str[0]=='&')
		{
			x=add_node(1,0);
			add_edge(x,t[top],t[top-1]);
			t[--top]=x;
		}
		if(str[0]=='|')
		{
			x=add_node(1,1);
			add_edge(x,t[top],t[top-1]);
			t[--top]=x;
		}
		if(str[0]=='!') chg_node(t[top]);
	}
	else
	{
		int s=0;
		for(int i=1;i<len;i++)
			s=s*10+str[i]-'0';
		t[++top]=add_node(0,s);
		tt[s]=t[top];
	}
	len=0;
}
int size[N],son[N],d[N],head,tail;
void bfs(int rt)
{
	tail=1;
	d[0]=rt;
	while(head<tail)
	{
		x=d[head++];
		if(k[x].ls)
		{
			d[tail++]=k[x].ls;
			d[tail++]=k[x].rs;
		}
	}
	for(int i=tail-1;i>=0;i--)
	{
		x=d[i];
		if(k[x].ls)
		{
			if(k[x].p1) k[x].p3=k[k[x].ls].p3|k[k[x].rs].p3;
			else k[x].p3=k[k[x].ls].p3&k[k[x].rs].p3;
			if(k[x].p2) k[x].p3=!k[x].p3;
		}
	}
	head=0;
	tail=1;
}
int ppp[N],rt,xx,ls,rs;
bool p,pp;
bool gett(int a)
{
	x=tt[a];
	p=(!k[x].p3);
	while(x!=rt)
	{
		xx=x;
		pp=k[xx].p3;
		k[xx].p3=p;
		x=k[x].fa;
		ls=k[x].ls;
		rs=k[x].rs;
		if(k[x].p1) p=k[ls].p3|k[rs].p3;
		else p=k[ls].p3&k[rs].p3;
		if(k[x].p2) p=!p;
		k[xx].p3=pp;
		if(k[x].p3==p) break;
		if(k[x].p3!=p&&ppp[x]) break;
	}
	if(k[x].p3!=p&&ppp[x]==1)
	{
		for(int i=tt[a];i!=x;i=k[i].fa)
			ppp[i]=1;
		return 1;
	}
	else
	{
		for(int i=tt[a];i!=x;i=k[i].fa)
			ppp[i]=2;
		return 0;
	}
}
int main()
{
//	freopen("expr.in","r",stdin);
//	freopen("expr.out","w",stdout);
	for(char c=gc;c!='\n';c=gc)
	{
		if(c==' ') work();
		else str[len++]=c;
	}
	work();
	rt=t[top];
	ppp[rt]=1;
	int n,a,Q;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		k[tt[i]].p3=a;
		if(k[tt[i]].p2) k[tt[i]].p3^=1;
	}
	bfs(rt);
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%d",&a);
		printf("%d\n",k[rt].p3^gett(a));
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```

---

## 作者：JS_TZ_ZHR (赞：11)

给出一种复杂度保证正确的线性做法。

首先$30$分的做法很好想，每次暴力计算就可以了，$O(|s|q)$。有一个优化是先根据后缀表达式建树，预先计算，只递归计算修改的值，但复杂度很玄学，会退化，于是要换个思路。

容易发现取值只有两种，每次只有一个变量会被改变。还是先建树，考虑每个节点的值改变会不会改变根节点，即表达式的值。

对于每个节点，有：

如果为变量，直接标记会改变表达式的值

如果为非运算，递归子树。

如果为或运算：

左儿子值为$1$，右儿子值为$1$，改变哪个都没有用，直接返回。

左儿子值为$1$，右儿子值为$0$，递归左儿子（只有左儿子会改变这个节点的值）。

左儿子值为$0$，右儿子值为$1$，递归右儿子（只有右儿子会改变这个节点的值）。

左儿子值为$1$，右儿子值为$1$，递归两个子树。

如果为与运算：

在做法上同上，可以参考代码。

### 注意，每次改变的只有一个变量的值，且不会延续！

综上，先建树，再求值，最后再来一次dfs标记对表达式的值有影响的变量即可，询问$O(1)$，总复杂度$O(|s|  +q)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],cnt,root,son[1000005][2],opt[1000005];
int val[1000005],num[1000005],q;
bool flag[1000005];
string s;
stack<int>x;
void input() {
	while(cin>>s) {
		if(s=="!")a[++cnt]=-1;
		else if(s=="|")a[++cnt]=-2;
		else if(s=="&")a[++cnt]=-3;
		else {
			int sum=0;
			for(int i=0; i<s.size(); i++)
				if(s[i]>='0'&&s[i]<='9')
					sum=sum*10+s[i]-'0';
			if(s[0]=='x')a[++cnt]=sum;
			else {
				n=sum;
				return;
			}
		}
	}
}
void query() {
	for(int i=1; i<=cnt; i++) {
		opt[i]=a[i];
		if(a[i]>=1)x.push(i);
		else if(a[i]==-1) {
			int sum=x.top();
			x.pop();
			son[i][0]=sum;
			x.push(i);
		} else {
			int sum1=x.top();
			x.pop();
			int sum2=x.top();
			x.pop();
			son[i][0]=sum1;
			son[i][1]=sum2;
			x.push(i);
		}
	}
	root=x.top();
	return;
}
void dfs1(int now) {
	if(opt[now]>=1) {
		num[now]=val[opt[now]];
		return;
	} else if(opt[now]==-1) {
		dfs1(son[now][0]);
		num[now]=!num[son[now][0]];
	} else if(opt[now]==-2) {
		dfs1(son[now][0]);
		dfs1(son[now][1]);
		num[now]=num[son[now][0]]|num[son[now][1]];
	} else {
		dfs1(son[now][0]);
		dfs1(son[now][1]);
		num[now]=num[son[now][0]]&num[son[now][1]];
	}
}
void dfs2(int now) {
	if(opt[now]>=1)flag[opt[now]]=true;
	else if(opt[now]==-1)dfs2(son[now][0]);
	else if(opt[now]==-3) {
		if(num[son[now][0]]==1&&num[son[now][1]]==1) {
			dfs2(son[now][0]);
			dfs2(son[now][1]);
		} else if(num[son[now][0]]==1&&num[son[now][1]]==0)
			dfs2(son[now][1]);
		else if(num[son[now][0]]==0&&num[son[now][1]]==1)
			dfs2(son[now][0]);
		else return;
	} else {
		if(num[son[now][0]]==0&&num[son[now][1]]==0) {
			dfs2(son[now][0]);
			dfs2(son[now][1]);
		} else if(num[son[now][0]]==1&&num[son[now][1]]==0)
			dfs2(son[now][0]);
		else if(num[son[now][0]]==0&&num[son[now][1]]==1)
			dfs2(son[now][1]);
		else return;
	}
}
int main() {
	input();
	query();
	for(int i=1;i<=n;i++)scanf("%d",&val[i]);
	dfs1(root);
	dfs2(root);
	cin>>q;
	while(q--) {
		int x;
		scanf("%d",&x);
		if(flag[x])printf("%d\n",!num[root]);
		else printf("%d\n",num[root]);
	}
	return 0;
}
```



---

## 作者：rainygame (赞：8)

感觉第一篇题解的想法很妙呀，不过可能我的讲解和实现更加易于理解。

首先解释一下“无用值”的定义：就是值对表达式的结果不起作用的 $x$。一般来说有两种，分别为 `1|x=1` 和 `0&x=0`，此时 `x` 无论取何值都无法改变表达式的结果。

那么我们的思路就清晰了：只需要求出到底哪些结点是“无用值”，然后求出整个表达式的值。每次询问时如果这个点对于整个表达式是“无用值”，就直接输出表达式的值，否则取反输出表达式的值。

我们考虑建立一颗表达式树。对每个结点设一个 `val` 表示它的值。对于表达式的非叶子结点（即符号结点），我们可以快速地通过左右儿子的 `val` 求出它的 `val`。而对于取反运算，我们直接将其 `val` 取反即可。

对于“无用值”，我们在每个符号结点处判断两个左右儿子是否为“无用值”。以 `&` 为例：当 `0&1` 时，右儿子为“无用值”；当 `1&0` 时，左儿子为“无用值”；当 `0&0` 时，两个儿子都是“无用值”；当 `1&1` 时，两个儿子都不是“无用值”。`|` 也差不多，读者可尝试自行推导。

但是还有一种情况，就是当一个结点的任意祖先为“无用值”的时候，它也会变成“无用值”。理解也很容易：既然上面的东西已经没用了，那下面的东西无论取何值，都无法改变最终的结果。

所以我们可以从根节点对这颗表达式树进行 DFS 下传“无用值”标记。实现也非常简单，看看代码就可以理解。

还有一个提示：对于第一行这种神奇的字符串读入方式，我们可以使用 `stringstream` 来完成处理。

时间复杂度 $O(n+q)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 200001

int n, q, x, ind, tmp1, tmp2, ind1, ind2, res;
int lson[MAXN], rson[MAXN];
stack<int> st;
string str;
bitset<MAXN> fw, val;

void dfs(int x, bool res){
	res = res || fw.test(x);  // 看看这个结点是否为“无用值” 
	fw.set(x, res);
	if (!lson[x]) return;  // 如果是叶子结点就停下 
	dfs(lson[x], res);  // 往左右子树搜 
	dfs(rson[x], res);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    getline(cin, str);
	stringstream scin(str);  // 使用 stringstream 更方便！ 
	
	cin >> n;
	for (int i(1); i<=n; ++i){
		cin >> tmp1;
		val.set(i, tmp1);
	}
	
	ind = n;  // 新建的结点从 n+1 开始算 
	while (scin >> str){
		if (str[0] == 'x') st.push(atoi(str.substr(1, str.size()-1).c_str()));  // 将下标存进栈内 
		else if (str == "!"){
			ind1 = st.top();
			val.set(ind1, val.test(ind1) ^ 1);  // 取反这个结点的值 
		}else if (str == "&"){
			ind1 = st.top();  // 取出两个结点 
			tmp1 = val.test(ind1);
			st.pop();
			ind2 = st.top();
			tmp2 = val.test(ind2);
			st.pop();
			
			res = 0;
			if (!tmp1 && tmp2) fw.set(ind2);  // 0&1 的情况 
			else if (!tmp2 && tmp1) fw.set(ind1);  // 1&0 的情况 
			else if (tmp1 && tmp2) res = 1;  // 否则表达式的值为 1 
			else{  // 0&0 的情况，两个都是“无用值” 
				fw.set(ind1);
				fw.set(ind2);
			}
			
			st.push(++ind);  // 新建一个结点 
			val.set(ind, res);  // 设值 
			lson[ind] = ind1;
			rson[ind] = ind2;
		}else{
			ind1 = st.top(); // 取出两个结点 
			tmp1 = val.test(ind1);
			st.pop();
			ind2 = st.top();
			tmp2 = val.test(ind2);
			st.pop();
			
			res = 1;
			if (!tmp1 && tmp2) fw.set(ind1);  // 0|1 的情况 
			else if (!tmp2 && tmp1) fw.set(ind2);  // 1|0 的情况 
			else if (!tmp1 && !tmp2) res = 0;  // 否则表达式的值为 0 
			else{  // 1|1 的情况，两个都是“无用值” 
				fw.set(ind1);
				fw.set(ind2);
			}
			
			st.push(++ind); // 新建一个结点
			val.set(ind, res);  // 设值 
			lson[ind] = ind1;
			rson[ind] = ind2;
		}
	}
	dfs(ind, 0);  // 下传“无用值”标记 
	
	res = val.test(ind);  // 可以直接求出表达式的值，非常方便 
	cin >> q;
	while (q--){
		cin >> x;
		cout << (fw.test(x) ? res : !res) << '\n';
	}

    return 0;
}

```


---

## 作者：Amoribus (赞：4)

前置知识：德摩根定律

取反运算的性质如下：

- $\lnot (a\operatorname{or}b)=a\operatorname{an d}b$
- $\lnot (a\operatorname{and}b)=a\operatorname{or}b$

即取反运算具有“分配律”，会将括号内的符号取反（与变成或，或变成与）。

然后建树，进行搜索操作就可以了。

注意这里有一个小 trick，我们遍历到某棵子树时，我们需要考虑它的符号是否被取反。

假设我们用 $y$（可取 $0,1$）表示一棵子树的结果是否被取反，那我们就用 $op$（可取 $2,3$）表示与运算和或运算。

注意到 $2\operatorname{xor}1=3,3\operatorname{xor}1=2$。

因此我们直接用 $op$ 异或 $y$ 就可以巧妙实现对符号取反的操作。

这样我们可以求出表达式的初始值。

然后我们考虑哪些修改操作是没用的。

这里我们运用一种短路的想法：

将废物节点定义为，即使改变取值也不影响最终答案的点。

当运算为 $a\operatorname{and}b$ 时，若 $a=0$ 则子树 $b$ 是“废物”。

当运算为 $a\operatorname{or}b$ 时，若 $a=1$ 则子树 $b$ 是“废物”。

先搜索找到废物节点，然后对“废物标记” 进行下传，标记完表达式树的每个节点。

对于每个询问：

- 该节点是“废物”，直接输出初始答案。
- 不是“废物”，将答案取反后输出。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r;
}node[400001];
int a[400001],fan[400001],n,m,fw[400001];
string s;
stack<int> zhan;
int dfs(int x,int y){
	a[x]^=y;
	if(x<=n) return a[x];
	int l=dfs(node[x].l,fan[node[x].l]^y);
	int r=dfs(node[x].r,fan[node[x].r]^y);
	if(a[x]==2){
		if(!l) fw[node[x].r]=1;
		if(!r) fw[node[x].l]=1;
		return l&r; 
	}
	if(a[x]==3){
		if(l) fw[node[x].r]=1;
		if(r) fw[node[x].l]=1;
		return l|r;
	}
}
void dfs1(int x){
	if(x<=n) return;
	fw[node[x].r]|=fw[x];
	fw[node[x].l]|=fw[x];
	dfs1(node[x].l);
	dfs1(node[x].r);
}
int main()
{
	getline(cin,s);cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int sum=n,len=s.length();
	for(int i=0;i<len;i++){
		if(s[i]=='x'){
			int x=0;
			while(s[++i]!=' ') x=10*x+s[i]-'0'; 
			zhan.push(x);
		}else if(s[i]=='&'){
			int x=zhan.top();zhan.pop();
			int y=zhan.top();zhan.pop();
			node[++sum].l=x,node[sum].r=y;
			zhan.push(sum);a[sum]=2; 
		}else if(s[i]=='|'){
			int x=zhan.top();zhan.pop();
			int y=zhan.top();zhan.pop();
			node[++sum].l=x,node[sum].r=y;
			zhan.push(sum);a[sum]=3;
		}
		else if(s[i]=='!') {int x=zhan.top();fan[x]=!fan[x];}
	} 

	int ans=dfs(sum,fan[sum]);dfs1(sum);
	cin>>m;
	while(m--){
		int k;
		scanf("%d",&k);
		printf("%d\n",fw[k]?ans:!ans);
	} 
	return 0;
}
```

---

## 作者：xmy201315 (赞：2)

这道题是一道非常难的关于树的题目。

[前置芝士](https://oi-wiki.org/dp/tree/)

### 思路
我们要先字符串处理（也就是输入，预处理等事情。较简单，不在此描述了）。接着，我们在建一颗表达式树。我们假设在每次询问时，都修改表达式树，然后算出结果。这时我们会发现 TLE 了，因为每次遍历都是 $\mathcal O(n q)$，所以我们用到了树形 DP。大多数题目树形 DP 都是从下往上做，但是这道题得从上往下做。然后我们假设 $u$ 这个节点发生了变化，我们要看它的父亲节点是否有变化。如果没有，最后结果不变；如果父亲节点的值变了，就看这个父亲节点是否会导致父亲节点的父亲的值改变，然后一直做这个操作。最后我们把答案都预处理出来就好啦！

还有很多细节，看代码吧！

**AC code:**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1010000;
struct node{
	int l,r;
	int type;
	int val;
	bool dp;
}a[N];
stack <int> s;
int n,m,q;
int p[N];
void dfs1(int u){
	if(a[u].type>0)return;
	if(a[u].type==-1){
		dfs1(a[u].l);
		a[u].val= !a[a[u].l].val;
	}else{
		dfs1(a[u].l);
		dfs1(a[u].r);
		if(a[u].type==-2)
			a[u].val=a[a[u].l].val & a[a[u].r].val;
		else
			a[u].val=a[a[u].l].val | a[a[u].r].val;
	}
}
void dfs2(int u){
	if(a[u].type>0)return;
	int L=a[u].l,R=a[u].r;
	if(a[u].type==-1){
		a[L].dp=a[u].dp;
		dfs2(L);
	}else{
		if(a[u].type==-2){
			if(a[R].val==0)a[L].dp=false;
			else a[L].dp=a[u].dp;
			if(a[L].val==0)a[R].dp=false;
			else a[R].dp=a[u].dp;
		}else{
			if(a[R].val==1)a[L].dp=false;
			else a[L].dp=a[u].dp;
			if(a[L].val==1)a[R].dp=false;
			else a[R].dp=a[u].dp;
		}
		dfs2(L);
		dfs2(R);
	}
}
int main(){
	while(true){
		char ch; 
		scanf("%c",&ch);
		if(ch=='x'){
			++n;
			int id=0;
			while(true){
				scanf("%c",&ch);
				if(ch>='0'&&ch<='9')
					id=id*10+ch-'0';
				else break;
			}
			a[n].type=id;
			p[id]=n;
			s.push(n);
		}else{
			assert((ch=='|')||(ch=='&')||(ch=='!'));
			if(ch=='|'||ch=='&'){
				++n;
				int r=s.top();s.pop();
				int l=s.top();s.pop();
				a[n].l=l;a[n].r=r;
				if(ch=='|')a[n].type=-3;
				else a[n].type=-2;
				s.push(n);
			}
			else{
				++n;
				int l=s.top();s.pop();
				a[n].l=l;
				a[n].type=-1;
				s.push(n);
			}
			scanf("%c",&ch);
		}
		if(ch!=' ')break;
	}
	int root=s.top();
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		int x;
		scanf("%d",&x);
		a[p[i]].val=x;
	}
	dfs1(root);
	a[root].dp=true;
	dfs2(root);
	scanf("%d",&q);
	for(int i=0;i<q;i++){
		int x;
		scanf("%d",&x);
		if(a[p[x]].dp)printf("%d\n",a[root].val^1);
		else printf("%d\n",a[root].val);
	}
}
```

---

## 作者：zlqwq (赞：2)

这里题目有一个比较好的地方，那就是输入的直接就是后缀表达式，所以我们边输入边处理就行。

然后解后缀表达式只需要开一个栈，如果遇到数字就加入到栈里面。如果有运算符，就弹出前两个数，然后做位运算再放到栈里就行了。

然后我们要跑一遍 dfs 把最后的贡献求出来。

然后建树的话，就直接把位运算结果当做根，把两个参数当做左右儿子就建好了。

代码：


```cpp
#include<iostream>
#include<cstring> 
#include<stack>
#define int long long
#define PII pair<int,int>

using namespace std;

int n;
const int N=1e6+5;
int a[N];
stack<int> stk;
string s; 
char c[N];
struct node {
	int to,next;
};
int head[N],idx;
node ed[N];
void add(int u,int v){
	idx++;
	ed[idx].to=v;
	ed[idx].next=head[u];
	head[u]=idx;
	return;
}
bool vis[N];
void dfs(int dep){
	vis[dep]=1;
	if(dep<=n)return;
	if(c[dep]=='!')dfs(ed[head[dep]].to);
	else {
		int v=ed[head[dep]].to;
		int vv=ed[ed[head[dep]].next].to;
		if(c[dep]=='&'){
			if(a[v]==1)dfs(vv);
			if(a[vv]==1)dfs(v);
		}
		if(c[dep]=='|') {
			if(a[v]==0)dfs(vv);
			if(a[vv]==0)dfs(v);
		}
	}
}
signed main() {
	getline(cin,s);
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	string w="";
	int l=s.size();
	int m=n;
	int x=0;
	int y=0;
	for(int i=0;i<l;++i){
		if(isdigit(s[i])){
			w+=s[i];
			if(i==l-1||!isdigit(s[i+1])){
				stk.push(atoi(w.c_str()));
				w="";
			}
		}
		else if(s[i]=='!'){
			m++;
			c[m]=s[i];
			x=stk.top();
			stk.pop();
			a[m]=!(a[x]);
			stk.push(m);
			add(m,x);
		} 
		else if(s[i]=='&'||s[i]=='|'){
			m++;
			c[m]=s[i];
			x=stk.top();
			stk.pop();
			y=stk.top();
			stk.pop();
			if(s[i]=='&'){
				a[m]=a[x]&a[y];
			}
			else if(s[i]=='|'){
				a[m]=a[x]|a[y];
			}
			stk.push(m);
			add(m,x);
			add(m,y);
		}
	}
	int root=stk.top();
	int ans=a[root];
	dfs(root);
	int q;
	cin>>q;
	while(q--) {
		int x;
		cin>>x;
		if(vis[x])cout<<!ans<<'\n';
		else cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：wsm52 (赞：1)

# 前言
是一道很传统的建树题。
# 思路
显然，肯定不能一个一个该值后，然后再带入计算。我们用**样例 #2**来建树。
![](https://cdn.luogu.com.cn/upload/image_hosting/wu2l5hhy.png)

然后我们需要知道一个很重要的性质。对于 $\land$ 运算，左右两边若出现 $0$ 的结果那么这个运算结果一定为 $0$。对于 $\lor$ 运算，左右两边若出现 $1$，那么运算结果一定为 $0$。即
> $0 \land x=0,(x=0,1)$，$1 \lor x=1,(x \in 0,1)$

知道这个性质后就很好做了。我们先遍历一遍树，将初始答案算出来。然后，再遍历一遍树，没走到一个节点就打上标记，看看这个节点子树的算出来的值是否满足上述性质，如果不满足，那就继续遍历，否则，那就不能继续遍历。以**样例 #2**为例（图中红色圈为打上了标记）。

![](https://cdn.luogu.com.cn/upload/image_hosting/8zflkqky.png)

这些都知道后就可以得出结论了。如果所改的值被打了标记，那么它一定会影响结果，答案就是原来的值取反，否则就是原来的答案。
# AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+10;
struct nb{
	char x;
	int lf,rt;
};
nb f[N];
stack<int> stn;
int n;
bool val[N],vis[N];
void dfs(int x){//计算每个子树的值
	if(x<=1e5) return;
	if(f[x].lf) dfs(f[x].lf);
	if(f[x].rt) dfs(f[x].rt);
	if(f[x].x=='!') val[x]=!val[f[x].lf];
	else if(f[x].x=='&') val[x]=val[f[x].lf]&val[f[x].rt];
	else val[x]=val[f[x].lf]|val[f[x].rt];
}
void dfs2(int x){//打标记
	vis[x]=true;
	if(f[x].x=='!'){
		dfs2(f[x].lf);
		return;
	}
	if(f[x].x=='&'&&val[f[x].lf]) dfs2(f[x].rt);
	if(f[x].x=='&'&&val[f[x].rt]) dfs2(f[x].lf);
	if(f[x].x=='|'&&!val[f[x].lf]) dfs2(f[x].rt);
	if(f[x].x=='|'&&!val[f[x].rt]) dfs2(f[x].lf);
}
int main(){
	char a;
	int pos=1e5;//pos为1e5的原因是防止子树的下标和操作数下标冲突
	while(a=getchar(),a!='\n'){
		if(a==' ') continue;
		if(a=='x'){
			int y;
			scanf("%d",&y);
			stn.push(y);
		}else{
			pos++;
			int ty=stn.top();stn.pop();
			if(a=='!'){
				f[pos]={a,ty,0};
				stn.push(pos);
			}else{
				int tx=stn.top();stn.pop();
				f[pos]={a,tx,ty};
				stn.push(pos);
			}
		}
	}
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&val[i]);
	dfs(pos);
	dfs2(pos);
	int q,y;
	scanf("%d",&q);
	while(q--){
		scanf("%d",&y);
		if(vis[y]) printf("%d\n",!val[pos]);
		else printf("%d\n",val[pos]);
	}
	return 0;
}
```

---

## 作者：emmoy (赞：1)

## 题目大意
给你一个后缀表达式，每个数都是 `0` 或 `1`，运算只有 `|`、`&` 和 `!`，即与、或、非。

然后有 $q$ 个询问，每个询问给出一个 $i$，求出将第 $i$ 个元素取反后表达式的值。
## 思路
### 读入
题目十分良心，直接给了我们后缀表达式，所以我们可以边读入边转换，不用考虑优先级。

会后缀表达式的朋友可以直接跳到下一步。
#### 后缀表达式的计算规则

后缀表达式的计算通常使用栈这种数据结构来实现，计算过程遵循以下规则：

当遇到数字时，直接将其推入栈中。

当遇到运算符时，从栈中弹出两个元素，先弹出的元素作为右操作数，后弹出的元素作为左操作数，执行运算后，将结果再次推入栈中。

例如，后缀表达式 `1 0 & 1 ! | 1 0 | &` 的计算过程如下：

从左到右扫描，首先将 `1` 和 `0` 依次推入栈中。

遇到并运算 `&`，弹出 `1` 和 `0`，计算 `1&0` 得 `0`，将 `0` 推入栈中。

接下来是 `1`，推入栈中。

遇到非运算 `!`，弹出 `1`，计算 `!1` 得 `0`，将 `0` 推入栈中。

遇到或运算 `|`，弹出 `0` 和 `0`，计算 `0|0` 得 `0`，将 `0` 推入栈中。

接着是 `1` 和 `0`，依次推入栈中。

遇到或运算 `|`，弹出 `1` 和 `0`，计算 `1|0` 得 `1`，将 `1` 推入栈中。

最后一个运算符是并运算 `&`，弹出 `0` 和 `1`，计算 `0&1` 得 `0`，将 `0` 推入栈中。

最终，栈中只剩下一个元素 `0`，这就是后缀表达式的计算结果。
### 询问
求出表达式的值就十分简单了，但是每一个元素都跑一次表达式复杂度会到达 $\mathcal{O}(q|s|)$，是不允许的。

我们考虑将一个值取反后，表达式只会有两种情况，分别是取反和不变。

于是我们可以预处理出每个元素取反后表达式的值会不会取反，单次查询的复杂度就可以变成 $\mathcal{O}(1)$ 了。

我们可以对其建一棵二叉树，每个节点由两个儿子运算得来，叶子节点即为输入节点。

具体预处理请看代码。

### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int s[1000008],cnt,p;
// s是栈，cnt是栈内元素个数，p是树的节点个数。
int n,m,b[1000009],flag[1000008],son[1000009][3],k[1000009];
//b[i]表示树上节点i的运算符类型（非叶子结点）或真假（叶子结点）。
//flag[i]表示i点是否取反。
//son[i][1]和son[i][2]分别表示左右儿子。
//k[i]=1表示这个点的变动不会影响结果，k[i]=0反之。
string t;
int dfs(int c,int f)//c是哪个节点，f是是否取反。
{
	b[c]^=f;//表达式a|b取反后是(!a)&(!b)，a&b取反后是(!a)|(!b)，运算符会改变。
    //而由于2^1=3，3^1=2，正好完成取反。
	if(c<=n) return b[c];//如果是叶子结点，则直接返回。
	int x=dfs(son[c][1],f^flag[son[c][1]]);//祖先是否取反和该节点是否取反可能会抵消。
	int y=dfs(son[c][2],f^flag[son[c][2]]);
	if(b[c]==2)
	{
        //当a&0或0&a时，表达式的值绝对与a无关，标记即可。
		if(x==0) k[son[c][2]]=1;
		if(y==0) k[son[c][1]]=1;
		return x&y;
	}
	else
	{
      //同理当a|1或1|a时，表达式的值绝对与a无关，标记即可。
		if(x==1) k[son[c][2]]=1;
		if(y==1) k[son[c][1]]=1;
		return x|y;
	}
}
void dfs2(int c)//下传k，因为如果x的祖先与表达式的值无关，那么x也肯定无关。
{
	if(c<=n) return;
	k[son[c][1]]|=k[c];
	k[son[c][2]]|=k[c];
	dfs2(son[c][1]);
	dfs2(son[c][2]);
}
int main()
{
	getline(cin,t);
	scanf("%d",&n);
	p=n;//原来就有n个点。
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int i=0;i<t.size();i+=2)//i+=2是因为有空格。
	{
		if(t[i]=='x')
		{
			int x=0;
			i++;
			while(t[i]!=' ') x=x*10+t[i]-'0',i++;
			i--;
			s[++cnt]=x;
		}
		if(t[i]=='&')
		{
			int x=s[cnt];
			cnt--;
			int y=s[cnt];
			cnt--;
			s[++cnt]=++p;
			b[p]=2;//2代表&运算。
			son[p][1]=x,son[p][2]=y;
		}
		if(t[i]=='|')
		{
			int x=s[cnt];
			cnt--;
			int y=s[cnt];
			cnt--;
			s[++cnt]=++p;
			b[p]=3;//3代表|运算。
			son[p][1]=x,son[p][2]=y;
		}
		if(t[i]=='!') flag[s[cnt]]^=1;//取反操作。
	}
	int ans=dfs(p,flag[p]);//ans为原表达式的值。
	dfs2(p);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int x;
		scanf("%d",&x);
		printf("%d\n",(k[x]?ans:!ans));
	}
	return 0;
}
```

---

## 作者：liuhaoyan0323 (赞：1)

这题是 $2020$ J 组最难的一题了。如果考场上从零开始手推是非常困难的。  

对于普及组的表达式计算，其实都可以用表达式树做。在时隔两年之后的 $2022$ 年又一次考到了这个，也就是说如果你做过 [P8815](https://www.luogu.com.cn/problem/P8815)，这题其实会很简单。

## 思路
### $30$ pts
首先最简单的我们考虑暴力，直接用栈做。

### $70$ pts
  注意到我们仅对单个变量进行操作，而对表达式本身不进行操作。
  
据此，考虑预处理建好表达式树，每次改变变量值时，我们就改变叶节点的值。再做一遍运算。
  
这样的好处是：省略栈做法每次重新扫描表达式。

### $100$ pts
本题难点：**短路**！  （下文给出 CCF 官方解释。）

注意到一个细节，对于逻辑表达式树，我们永远取根作为答案。   
而由于逻辑表达式的短路性质，对于一个叶节点改变它的值，仅有在他之上所有父节点都不产生短路，才可能改变根的值。换句话说：**对于一个已经短路的子表达式，无论如何改变其中变量的值，答案始终不变！**    

  
而由于这是逻辑表达式对答案的影响仅可能是取反。

综上所述，我们考虑建立一个 $fa$ 表，$fa_x$ 表示若  $x$ 节点能否短路，若能则为 $0$，否则为自己的祖先。初始时，我们建立完表达式树计算出答案记作 ```ans``` 并维护 $fa$ 表。对于每次询问我们只需遍历 $fa_x$ 的祖先（```while(fa[pa]!=0){x=fa[x];}```），直到找到 $0$，若此时 $x$ 为 $1$，显然它会影响最终答案的值，将```ans```取反输出，否则直接输出 ```ans```。

### 短路是什么？
对逻辑表达式的计算会采用一种“短路”的策略：在形如 `a&b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 0$，那么整个逻辑表达式的值就一定为 $0$，故无需再计算 `b` 部分的值；同理，在形如 `a|b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 1$，那么整个逻辑表达式的值就一定为 $1$，无需再计算 `b` 部分的值。

## 代码
### $30$ pts
[提交记录](https://www.luogu.com.cn/record/183189357)  
代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;
string str;
int n,q,arr[N];
stack<int> stk;
inline void read(int &num){
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	num=x*f;
}
inline bool check(char ch){
	return ch=='|'||ch=='&'||ch=='!';
}
inline void solve(int cnt){
	int len=str.size();
	for(int i=0;i<len;++i){
		if(str[i]==' ')continue;
		int num=0;
		if(str[i]=='x'){
			++i;
			while(str[i]>='0'&&str[i]<='9'){
				num=(num<<3)+(num<<1)+(str[i]^48);
				++i;
			}
			if(num==cnt){
				stk.push(!arr[num]);
			}else{
				stk.push(arr[num]);
			}
		}else if(check(str[i])){
			char opt=str[i];
			int v1,v2;
			v1=stk.top();
			stk.pop();
			switch(opt){
				case '!':
					stk.push(!v1);
					break;
				case '|':
					v2=stk.top();
					stk.pop();
					stk.push(v1|v2);
					break;
				case '&':
					v2=stk.top();
					stk.pop();
					stk.push(v1&v2);
					break;
			}
		}
	}
}
signed main(){
	getline(cin,str);
	read(n);
	for(int i=1;i<=n;++i){
		read(arr[i]);
	}
	read(q);
	while(q--){
		int cnt;
		read(cnt);
		solve(cnt);
		printf("%lld\n",stk.top());
	}
}
```


### $75$ pts
[提交记录](https://www.luogu.com.cn/record/183269302)  
代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005
using namespace std;
string str;
int n,q,cnt,arr[N];
stack<string> stk;
typedef struct TreeNode{
	string ch;
	TreeNode *lc,*rc;
}TreeNode,*TreePoint;
TreePoint root=NULL;
inline void read(int &num){
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	num=x*f;
}
inline bool check(char ch){
	return ch=='|'||ch=='&'||ch=='!';
}
inline void solve(){
	int len=str.size();
	for(int i=0;i<len;++i){
		if(str[i]==' '||str[i]=='\n')continue;
		string num="";
		if(str[i]=='x'){
			while(str[i+1]>='0'&&str[i+1]<='9'){
				num+=str[i+1];
				++i;
			}
			stk.push(num);
		}
		if(check(str[i])){
			string tmp="";
			tmp+=str[i];
			stk.push(tmp);
		}
	}
}
inline TreePoint buildTree(){
	TreePoint tp=NULL;
	string s;
	while(stk.size()){
		tp=new TreeNode;
		s=stk.top();
		stk.pop();
		tp->ch=s;
		if(s[0]>='0'&&s[0]<='9'){
			tp->lc=NULL;
			tp->rc=NULL;
			return tp;
		}else{
			if(s[0]=='!'){
				tp->lc=NULL;
				tp->rc=buildTree();
			}else if(s[0]=='|'||s[0]=='&'){
				tp->rc=buildTree();
				tp->lc=buildTree();
			}			
			return tp;
		}
	}
}
inline int getValue(char opt,int lv,int rv) {
	int ret;
	switch(opt) {
		case '&':
			ret = lv & rv;
			break;
		case '|':
			ret = lv | rv;
			break;
		case '!':
			ret = !rv;
			break;
		//default:
		//	break;
	}
	return ret;
}
inline int calculateTree(TreePoint root){
	int res=0;
	if(root!=NULL){
		if(root->lc==NULL&&root->rc==NULL){
			int idx=atoi(root->ch.c_str());
			if(idx==cnt){
				return !arr[idx];
			}else{
				return arr[idx];
			}
		}else{
			char opt=root->ch[0];
			int lv=0,rv=0;
			if(opt=='&'||opt=='|'){
				lv=calculateTree(root->lc);
				if(opt=='&'&&lv==0){
					return 0;
				}
				if(opt=='|'&&lv==1){
					return 1;
				}
			}
			rv=calculateTree(root->rc);
			res=getValue(opt,lv,rv);
			return res;
		}
	}
}
signed main(){
	getline(cin,str);
	solve();
	root=buildTree();
	read(n);
	for(int i=1;i<=n;++i){
		read(arr[i]);
	}
	read(q);
	while(q--){
		read(cnt);
		printf("%lld\n",calculateTree(root));
	}
}
```


### $100$ pts
[提交记录](https://www.luogu.com.cn/record/183300750)  
代码：
```cpp
#include <bits/stdc++.h>
#define int long long
#define N 1000005
using namespace std;
const int MAXLEN = 1000001;
char exp_post[N];
stack<string> post_stk;
int n,q,q_idx,len,cnt,initData[N];
int ans,fa[N],ord[N];
typedef struct TreeNode {
	string v;
	TreeNode *lchild,*rchild;
	int od;
} TreeNode,*TreePoint;
TreePoint root = NULL;
inline void read(int &num){
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	num=x*f;
}

inline bool isnumber(char ch) {
	return ch>='0'&&ch<='9';
}
inline void str2Skt() {
	string str = "";
	for(int i=0; i<len; i++) {
		if(exp_post[i]==' ' || exp_post[i]=='\n')continue;
		str = "";
		if(exp_post[i]=='x') {
			while(isnumber(exp_post[i+1])) {
				str += exp_post[i+1];
				i++;
			}
			post_stk.push(str);
			str = "";
		}
		if(exp_post[i]=='&' || exp_post[i]=='|' || exp_post[i]=='!') {
			str += exp_post[i];
			post_stk.push(str);
			str = "";
		}
	}
}
inline int str2num(string str) {
	int data = 0;
	for(int i=0; i<str.size(); i++) {
		data = data*10 + str[i]-'0';
	}
	return data;
}
inline TreePoint createTree() {
	string str = "";
	while(!post_stk.empty()) {
		TreePoint tp = new TreeNode;
		str = post_stk.top();
		post_stk.pop();
		cnt++;
		tp->v = str;
		tp->od = cnt;
		if(isnumber(str[0])) {
			tp->rchild = NULL;
			tp->lchild = NULL;
			ord[atoi(str.c_str())]=cnt;
			return tp;
		} else {
			if(str[0]=='!') {
				tp->lchild = NULL;
				tp->rchild = createTree();
			} else {
				tp->rchild = createTree();
				tp->lchild = createTree();
			}
			return tp;
		}
	}
}
inline int getValue(char opt,int lv,int rv) {
	int ret;
	switch(opt) {
		case '&':
			ret = lv && rv;
			break;
		case '|':
			ret = lv || rv;
			break;
		case '!':
			ret = !rv;
			break;
		default:
			break;
	}
	return ret;
}
inline int calculateByTree(TreePoint t) {
	int ret = 0;
	if(t!=NULL) {
		if(t->lchild==NULL && t->rchild==NULL) {
			int idx = str2num(t->v);
			if(idx==q_idx) {
				return !initData[idx];
			} else {
				return initData[idx];
			}
		} else {
			int lv=0,rv=0;
			char opt;
			opt = (t->v)[0];
			lv = calculateByTree(t->lchild);
			rv = calculateByTree(t->rchild);
			ret = getValue(opt,lv,rv);
			if(opt == '&' || opt == '|') {
				if(opt=='&' && lv==1) {
					fa[t->rchild->od]=t->od;
				}
				if(opt=='&' && rv==1) {
					fa[t->lchild->od]=t->od;
				}
				if(opt=='|' && lv==0) {
					fa[t->rchild->od]=t->od;
				}
				if(opt=='|' && rv==0) {
					fa[t->lchild->od]=t->od;
				}
			}
			if(opt=='!') {
				fa[t->rchild->od]=t->od;
			}
			return ret;
		}
	}
	return ret;
}
signed main() {
	memset(initData,false,sizeof(initData));
	fgets(exp_post,sizeof(exp_post),stdin);
	len = strlen(exp_post)-1;
	read(n);
	for(int i=1; i<=n; i++) {
		read(initData[i]);
	}
	str2Skt();
	root = createTree();
	ans = calculateByTree(root);
	read(q);
	for(int j=1; j<=q; j++) {
		int res = 0;
		read(q_idx);
		int pa;
		pa = ord[q_idx];
		while(fa[pa]!=0) {
			pa = fa[pa];
		}
		printf("%lld\n", (pa == 1) ? (!ans) : ans);
	}
}
```

---

## 作者：hnczy (赞：1)

根据题意做表达式求值得到三十分，然后还有二十分的分数可以特判，得到五十分。

但是怎么得到满分呢。首先，可以用建树的方法求表达式，正好这还是一个后缀表达式，建树较易。

```c++
	cnt=n;
	for(int i=0; i<len; i++) {
		if(s[i]=='x') {
			i++;
			int f=0;
			while(isdigit(s[i])) {
				f=f*10+s[i]-'0';
				i++;
			}
			sta[++p]=f;
		} else if(s[i]=='&') {
			what[++cnt]=1;
			tree[cnt][1]=sta[p--];
			tree[cnt][0]=sta[p--];
			a[cnt]=a[tree[cnt][0]]&a[tree[cnt][1]];
			sta[++p]=cnt;
		} else if(s[i]=='|') {
			what[++cnt]=2;
			tree[cnt][1]=sta[p--];
			tree[cnt][0]=sta[p--];
			a[cnt]=a[tree[cnt][0]]|a[tree[cnt][1]];
			sta[++p]=cnt;
		} else if(s[i]=='!') {
			what[++cnt]=3;
			tree[cnt][0]=sta[p--];
			a[cnt]=!a[tree[cnt][0]];
			sta[++p]=cnt;
		}
	}
```

这一个树上，如果左子树改变，那么这一棵树的值变化了，那就进行下传标记，反之亦然，即以此节点为根的表达式的值取反之后是否改变全表达式的值，如果难理解，可以看一下代码辅助理解：

```c++
c[cnt]=1;
	for(int i=cnt; i>n; i--) {
		int l=tree[i][0],r=tree[i][1];
		if(what[i]==1) {
			if(((!a[l])&a[r])!=a[i])c[l]=c[i];
			if(((!a[r])&a[l])!=a[i])c[r]=c[i];
		}
		else if(what[i]==2) {
			if(((!a[l])|a[r])!=a[i])c[l]=c[i];
			if(((!a[r])|a[l])!=a[i])c[r]=c[i];
		}
		else if(what[i]==3)
			c[l]=c[i];
	}
```

因为 $!$ 是单目运算符，可以直接下传。$c$ 数组是记录这一个子树取反之后是否影响全局。

嫁接一下即可：

```c++
#include<bits/stdc++.h>
using namespace std;
string s;
int n,q,len,a[1000005],cnt,sta[1000005],what[1000005],tree[1000005][2],p,c[1000005];
int main() {
	getline(cin,s);
	len=s.size();
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
		scanf("%d",a+i);
	cnt=n;
	for(int i=0; i<len; i++) {
		if(s[i]=='x') {
			i++;
			int f=0;
			while(isdigit(s[i])) {
				f=f*10+s[i]-'0';
				i++;
			}
			sta[++p]=f;
		} else if(s[i]=='&') {
			what[++cnt]=1;
			tree[cnt][1]=sta[p--];
			tree[cnt][0]=sta[p--];
			a[cnt]=a[tree[cnt][0]]&a[tree[cnt][1]];
			sta[++p]=cnt;
		} else if(s[i]=='|') {
			what[++cnt]=2;
			tree[cnt][1]=sta[p--];
			tree[cnt][0]=sta[p--];
			a[cnt]=a[tree[cnt][0]]|a[tree[cnt][1]];
			sta[++p]=cnt;
		} else if(s[i]=='!') {
			what[++cnt]=3;
			tree[cnt][0]=sta[p--];
			a[cnt]=!a[tree[cnt][0]];
			sta[++p]=cnt;
		}
	}
	c[cnt]=1;
	for(int i=cnt; i>n; i--) {
		int l=tree[i][0],r=tree[i][1];
		if(what[i]==1) {
			if(((!a[l])&a[r])!=a[i])c[l]=c[i];
			if(((!a[r])&a[l])!=a[i])c[r]=c[i];
		}
		else if(what[i]==2) {
			if(((!a[l])|a[r])!=a[i])c[l]=c[i];
			if(((!a[r])|a[l])!=a[i])c[r]=c[i];
		}
		else if(what[i]==3)
			c[l]=c[i];
	}
	scanf("%d",&q);
	while(q--){
		int x;
		scanf("%d",&x);
		printf("%d\n",a[cnt]^c[x]); 
	}
	return 0;
}
```

---

## 作者：qwer6 (赞：0)

首先，大家都知道的，看到表达式，我们先尝试建树。

建完树呢？所有的值可以分为两类，一类是会影响到答案的，一类是不会影响到答案的，我们想一想什么时候一个位置可能会影响到答案。

对于与运算，我们知道 $0 \& 0 = 0$，$0 \& 1 = 0$，所以与运算的一侧为 $0$ 的时候，显然无论如何改变另一侧都不可能改变答案，而当一侧为 $1$ 的时候，答案与另一侧的值相同，所以当一侧为 $1$ 的时候，另一侧的值改变可能对答案有影响。

对于或运算，我们知道 $1 | 1 = 1$，$1 | 0 = 0$，所以或运算的一侧为 $1$ 的时候，无论如何改变另一侧都不可能改变答案，而当一侧为 $0$ 的时候，答案与另一侧相同，所以当一侧为 $0$ 的时候，另一侧的值的改变可能对答案有影响。

至于取反？那当然是有影响的。

这样，我们遍历表达式树，如果当前节点的左儿子有影响，就遍历左儿子，如果当前节点的右儿子有影响，就遍历右儿子，如果到达叶子节点，就说明这个节点对答案有影响。

那这道题就写完了。

```c++
/*by qwer6*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
string s;
int n,x[N<<2],q,l,t,cnt,ls[N<<2],rs[N<<2],place;
char opt[N<<2];
bool flag[N<<2];
int build(){
	stack<int>st;
	for(int i=0;i<l;i++){
		if(s[i]=='x'){
			i++;
			int sum=0;
			while(isdigit(s[i])){
				sum=sum*10+s[i]-'0';
				i++;
			}
			st.push(sum);
		}else if(s[i]!=' '){
			opt[++cnt]=s[i];
			if(s[i]=='!'){
				ls[cnt]=st.top();
				st.pop();	
			}else{
				ls[cnt]=st.top();
				st.pop();
				rs[cnt]=st.top();
				st.pop();
			}
			st.push(cnt);
		}
	}
	return st.top();
}
bool dfs(int rt){
	if(rt<=n)return x[rt];
	if(opt[rt]=='!')return x[rt]=!dfs(ls[rt]);
	if(opt[rt]=='&')return x[rt]=dfs(ls[rt])&dfs(rs[rt]);
	return x[rt]=dfs(ls[rt])|dfs(rs[rt]);
}
void redfs(int rt){
	if(rt<=n){
		flag[rt]=1;
		return ;
	}
	if(opt[rt]=='!'){
		redfs(ls[rt]);
		return ;
	}
	if(opt[rt]=='&'){
		if(x[ls[rt]]&&x[rs[rt]]){
			redfs(ls[rt]);
			redfs(rs[rt]);
			return ;
		}
		if(x[ls[rt]]){
			redfs(rs[rt]);
			return ;
		}
		if(x[rs[rt]]){
			redfs(ls[rt]);
			return ;
		}
	}
	if(opt[rt]=='|'){
		if(!x[ls[rt]]&&!x[rs[rt]]){
			redfs(ls[rt]);
			redfs(rs[rt]);
			return ;
		}
		if(!x[ls[rt]]){
			redfs(rs[rt]);
			return ;
		}
		if(!x[rs[rt]]){
			redfs(ls[rt]);
			return ;
		}
	}
}
int main(){
	getline(cin,s);
	l=s.size();
	scanf("%d",&n);
	cnt=n;
	for(int i=1;i<=n;i++)
		scanf("%d",x+i);
	int rt=build();
	dfs(rt);
	redfs(rt);
	int ans=x[rt];
	scanf("%d",&q);
	while(q--){
		scanf("%d",&place);
		if(flag[place])printf("%d\n",!ans);
		else printf("%d\n",ans);
	}
}
```

---


# 虚人「无」

## 题目背景

一点也不美丽的不死鸟。

那双锐爪，沾染了无辜的鲜血。

## 题目描述

给定二元序列 $\{(v_i,c_i)\}$ 和一棵以 $1$ 为根的有根树。第 $i$ 个点的点权是 $(v_i,c_i)$。

- 定义一个非根节点的权值为其子树内的 $c$ 的积乘上其子树补的 $v$ 的积。
- 定义一个根节点的权值为其子树内的 $c$ 的积。

形式化的讲，若 $u$ 不为根节点，则 $u$ 的权值 $f_u$ 为：

$$f_u=\prod\limits_{v\in \operatorname{substree}(u)} c_v\times \prod\limits_{v\notin \operatorname{substree}(u)} v_v$$

否则，其权值 $f_u$ 为：

$$f_u=\prod\limits_{v=1}^n c_v$$

试求整棵树**所有节点的权值之和**，答案对 $m$ 取模。请注意：**保证 $\bm m$ 是质数**。




## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/olehwn2w.png)

（图片有误，应该交换 $v,c$ 的权值。）

### 数据范围及约定

对于 $100\%$ 的数据，满足 $1\le n\leq 3\times 10^5$，$1\leq v_i,c_i,m\leq 10^9$。


## 样例 #1

### 输入

```
3 998244853
1 2
1 3
2 1 2
1 2 2```

### 输出

```
10```

## 样例 #2

### 输入

```
5 998244353
1 2
1 3
1 4
4 5
5 5 5 2 3
6 6 1 5 3```

### 输出

```
4656```

# 题解

## 作者：Flanksy (赞：3)

### 线段树

------------

#### 乘法逆元

用 dfs 序把树映射到序列上，然后分别维护 $c,v$ 的前缀积，由于节点的子树在 dfs 序中为一段连续区间，可以用逆元取出子树中 $c$ 的乘积，同样可以用逆元计算不包括当前子树所有 $v$ 的乘积，时间复杂度 $O(n\log n)$，线性求逆元可将复杂度降至 $O(n)$。

使用逆元求解的条件是所有参与计算的值都存在逆元，需要模数与任意 $c,v$ 互质。题目中没有给出相关性质，即使模数为质数也可以构造出不存在逆元的情况。

------------

#### 线段树

现在需要一种不依赖逆元的方法快速求出某个区间内数字的乘积，不难想到线段树。

前置知识是线段树维护区间乘积，这里是[模板题](https://www.luogu.com.cn/problem/P3373)。

用线段树维护区间内 $c,v$ 的乘积，支持区间查询即可，不需要延迟标记。

记得对答案取模，题目是 ACM 赛制的，同样的代码多次 WA 反馈的数据点可能不同，对查错不是很友好。如果被卡常，使用链式前向星代替 `vector` 可以获得一定程度提速。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Segment{int l,r,c,v;}s[1200001];
constexpr Segment emp=Segment{0,0,1,1};
int n,mod,pos,c[300001],v[300001],w[300001],ex[300001],dfn[300001];
vector<int> e[300001];//ex[x]记录dfs序中位置x对应点的编号,建树用
long long ans;
void dfs(int x,int las){
	w[x]=1,dfn[x]=++pos,ex[pos]=x;
	for(int i:e[x]) if(i!=las) dfs(i,x),w[x]+=w[i];
}
void pushup(Segment &u,const Segment &ls,const Segment &rs){
	u.c=1ll*ls.c*rs.c%mod,u.v=1ll*ls.v*rs.v%mod;
}
void build(int u,int l,int r){
	s[u].l=l,s[u].r=r;
	if(l==r) return s[u].c=c[ex[l]],s[u].v=v[ex[l]],void();
	build(u*2,l,(l+r)/2);
	build(u*2+1,(l+r)/2+1,r);
	pushup(s[u],s[u*2],s[u*2+1]);
}
Segment query(int u,int l,int r){
	if(s[u].l>r||s[u].r<l) return emp;
	if(s[u].l>=l&&s[u].r<=r) return s[u];
	auto ret=emp,ls=query(u*2,l,r),rs=query(u*2+1,l,r);
	pushup(ret,ls,rs);
	return ret;
}
int main(){
	scanf("%d%d",&n,&mod);
	for(int i=1;i<=n-1;i++){
		static int x,y;
		scanf("%d%d",&x,&y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
	for(int i=1;i<=n;i++) scanf("%d",&v[i]);
	dfs(1,0),build(1,1,n),ans=s[1].c;//根节点答案独立统计 
	for(int i=2;i<=n;i++){
		static Segment lot,son,rot;//dfs序左边 子树 dfs序右边 
		lot=query(1,1,dfn[i]-1);
		son=query(1,dfn[i],dfn[i]+w[i]-1);
		rot=query(1,dfn[i]+w[i],n);
		ans+=1ll*lot.v*rot.v%mod*son.c%mod;
	}
	ans%=mod;
	printf("%lld\n",ans);
	return 0;
}
```
------------

#### 前缀积 & 后缀积

**Updated on 2023/4/15**

可以发现线段树只需要维护 $c$ 的区间乘积，dfs 序左右两端的查询实际上是 $v$ 的一段前缀积和一段后缀积。维护 $v$ 的前缀积和后缀积可以大幅降低常数。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Segment{int l,r,w;}s[1200001];
int n,mod,pos,c[300001],v[300001],w[300001],ex[300001],dfn[300001],mul[300001],pre[300005],suf[300005];
vector<int> e[300001];
long long ans;
void dfs(int x,int las){
	w[x]=1,dfn[x]=++pos,ex[pos]=x;
	for(int i:e[x]) if(i!=las) dfs(i,x),w[x]+=w[i];
}
void build(int u,int l,int r){
	s[u].l=l,s[u].r=r;
	if(l==r) return s[u].w=c[ex[l]],mul[l]=v[ex[l]],void();
	build(u*2,l,(l+r)/2),build(u*2+1,(l+r)/2+1,r);
	s[u].w=1ll*s[u*2].w*s[u*2+1].w%mod;
}
int query(int u,int l,int r){
	if(s[u].l>r||s[u].r<l) return 1;//注意返回值 
	if(s[u].l>=l&&s[u].r<=r) return s[u].w;
	return 1ll*query(u*2,l,r)*query(u*2+1,l,r)%mod;
}
int main(){
	scanf("%d%d",&n,&mod);
	for(int i=1;i<=n-1;i++){
		static int x,y;
		scanf("%d%d",&x,&y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
	for(int i=1;i<=n;i++) scanf("%d",&v[i]);
	dfs(1,0),build(1,1,n),ans=s[1].w;
	pre[0]=1,suf[n+1]=1;//在pre和suf的越界处设置极值,无需特判 
	for(int i=1;i<=n;i++) pre[i]=1ll*mul[i]*pre[i-1]%mod;//前缀积 
	for(int i=n;i>=1;i--) suf[i]=1ll*mul[i]*suf[i+1]%mod;//后缀积 
	for(int i=2;i<=n;i++){
		static int lot,son,rot;
		lot=pre[dfn[i]-1];
		son=query(1,dfn[i],dfn[i]+w[i]-1);
		rot=suf[dfn[i]+w[i]];
		ans+=1ll*lot*rot%mod*son%mod;
	}
	ans%=mod;
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：0zhouyq (赞：3)

[传送门](https://www.luogu.com.cn/problem/P9208)

### 思路：

当 $m$ 为质数，这题可以用逆元做。

开几个数组：$x_i$ 表示 $\prod_{v \in \operatorname{substree}(i)} c_{v}$ 除以 $m$ 的余数，$y_i$ 表示把 $\prod_{v \in \operatorname{substree}(i)} v_{v}$ 中的所有因子 $m$ 约去后，这个数除以 $m$ 的余数，$mod_i$ 表示 $\prod_{v \in \operatorname{substree}(i)} v_{v}$ 中有多少个因子 $m$。

先建树，在树上进行 dfs，可以处理出三个数组。

最后从 $i=2$ 开始统计。在统计的时候，如果发现 $mod_i < mod_1$，说明 $\prod_{v \notin \text { substree }(u)} v_{v}$ 含有因子 $m$，所以这个点对答案就没有贡献。否则，所有的因子 $m$ 都会在除法中约去，答案就是 $x_i\times\dfrac{y_1}{y_i}$，求出 $y_i$ 在模 $m$ 下的的逆元即可。

这种做法在 $m$ 不为质数时也可以做，对 $m$ 的每一个质因子都进行统计就行了。

下面代码是 $m$ 为质数时通过的代码。

### AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,m,home[300001],cnt,c[300001],v[300001],mod[300001];//c是题解中的x，v是题解中的y。
struct node{
	ll next,to;
}e[600001];
void add(ll a,ll b){
	e[++cnt].to=b;
	e[cnt].next=home[a];
	home[a]=cnt;
}
void dfs(ll h,ll fa){
	while(v[h]%m==0){
		mod[h]++;
		v[h]/=m;
	}
	for(ll i=home[h];i;i=e[i].next){
		ll t=e[i].to;
		if(t==fa) continue;
		dfs(t,h);
		c[h]=c[h]*c[t]%m;
		v[h]=v[h]*v[t];
		mod[h]+=mod[t];
		while(v[h]&&v[h]%m==0){
			mod[h]++;
			v[h]/=m;
		}
		v[h]%=m;
	}
}
void exgcd(ll a,ll b,ll &x,ll &y){
	if(!b) x=1,y=0;
	else{
		exgcd(b,a%b,y,x);
		y-=a/b*x;
	}
}
int main(){
	scanf("%lld %lld",&n,&m);
	ll x,y;
	for(ll i=1;i<n;i++){
		scanf("%lld %lld",&x,&y);
		add(x,y);
		add(y,x);
	}
	for(ll i=1;i<=n;i++){
		scanf("%lld",&c[i]);
		c[i]%=m;
	}
	for(ll j=1;j<=n;j++){
		scanf("%lld",&v[j]);
	}
	dfs(1,-1);
	ll vsum=v[1];
	ll ans=c[1]%m;
	for(ll i=2;i<=n;i++){
		if(mod[1]>mod[i]) continue;
		ll x=0,y=0;
		exgcd(v[i],m,x,y);
		x=(x%m+m)%m;
		ans=(ans+c[i]*vsum%m*x%m)%m;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：翟翟 (赞：3)

本题用到了 dfs 序、前缀积和后缀积。

先一遍 dfs 求出每个节点在 dfs 序中的位置（记为 $w_i$）、每个节点子树的大小（记为 $sz_i$）、每个节点子树 $c$ 的乘积（记为 $zs_i$）。记 $qz_i,hz_i$ 为 dfs 序的 $v$ 的前缀积和后缀积，则每个节点的权值等于 $zs_i\times qz_{w_i-1}\times hz_{w_i+sz_i}$。

时间复杂度 $\mathcal{O}(n)$。

## Code
```
#include<cstdio>
const int N=3e5+5;
int n,m,a,b,tot,head[N],nxt[N<<1],to[N<<1],ans;
int c[N],v[N],cnt,dx[N],zs[N],qz[N],hz[N],sz[N],w[N];
void add(int u,int v){
	nxt[++tot]=head[u];
	head[u]=tot;
	to[tot]=v;
}//链式前向星
void dfs(int u,int fa,const int mod){
	dx[++cnt]=u;w[dx[i]]=i;
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		dfs(v,u,mod);
		zs[u]=1ll*zs[u]*zs[v]%mod;
		sz[u]+=sz[v];
	}
}
void prez(const int mod){
	qz[0]=hz[n+1]=1;
	for(int i=1;i<=n;++i)
		qz[i]=1ll*qz[i-1]*v[dx[i]]%mod;
	for(int i=n;i;--i)
		hz[i]=1ll*hz[i+1]*v[dx[i]]%mod;
	for(int i=1;i<=n;++i)
		ans=(ans+1ll*zs[i]*qz[w[i]-1]%mod*hz[w[i]+sz[i]])%mod;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;++i){
		scanf("%d%d",&a,&b);
		add(a,b);
		add(b,a);//连边
	}
	for(int i=1;i<=n;++i){
		scanf("%d",c+i);
		zs[i]=c[i];
		sz[i]=1;
	}
	for(int i=1;i<=n;++i)
		scanf("%d",v+i);
	dfs(1,0,m);
	/*预处理出dfs序，及每个点在dfs序中的位置，
	和每个节点子树的权值积、子树大小*/
	prez(m);//计算答案
	printf("%d\n",ans);
	return 0;
}
```

**注意：本题不要使用逆元，因为子树权值积可能是 $m$ 的倍数。**

---

## 作者：Mr_Az (赞：2)

## Question 问题 [P9208 虚人「无」](https://www.luogu.com.cn/problem/P9208)

给定二元序列 $\{(v_i,c_i)\}$ 和一棵以 $1$ 为根的有根树。第 $i$ 个点的点权是 $(v_i,c_i)$。

- 定义一个非根节点的权值为其子树内的 $c$ 的积乘上其子树补的 $v$ 的积。
- 定义一个根节点的权值为其子树内的 $c$ 的积。

形式化的讲，若 $u$ 不为根节点，则 $u$ 的权值 $f_u$ 为：

$$f_u=\prod\limits_{v\in \operatorname{substree}(u)} c_v\times \prod\limits_{v\notin \operatorname{substree}(u)} v_v$$

否则，其权值 $f_u$ 为：

$$f_u=\prod\limits_{v=1}^n c_v$$

试求整棵树**所有节点的权值之和**，答案对 $m$ 取模。请注意：**保证 $\bm m$ 是质数**。

## Analysis 分析 

#### 定义：

$dfn_x$ 为 $x$ 的 $dfs$ 序。

$siz_x$ 为 $x$ 的子树大小。

### 先讲正解：dfs 序 & 线段树查询

我们跑一遍 $dfs$ 序之后，思考对于一个点 $x$，其子节点所在的 $dfs$ 序必然在区间 $dfn_{x} \sim dfn_{x}+siz_{x}-1$ 之中。

接下来我们只需要维护区间内 $c,v$ 的乘积，显然我们只需要用线段树维护一下乘积就行了。

### 以下是错解：逆元(可选择不看)

考虑一个非常自然就能想到的方法，看到取模，想用逆元。但是在本题不行。因为使用逆元需要当所有参与计算答案的值均存在逆元，即模数 $m \perp c_i,v_i$。

所以这道题可以通过特殊构造卡掉逆元做法。

## Code 代码

```cpp
#include<bits/stdc++.h>
#define rint register int
#define ls (p<<1)
#define rs (p<<1|1)
using namespace std;
typedef long long ll;
const int N=3e5+8;
int n,x,y,tot,cnt,mod;
int head[N],siz[N],dfn[N];
ll c[N],v[N],ans;
struct edge{
	int nxt,to;
}e[N<<1];
struct tree{
	int l,r;
	ll csum,vsum;
	#define l(p) t[p].l
	#define r(p) t[p].r
	#define cs(p) t[p].csum
	#define vs(p) t[p].vsum
}t[N<<2];
inline void add(int a,int b){e[++tot]={head[a],b};head[a]=tot;}
inline void add(int a,int b,string s){add(a,b);add(b,a);}
inline void dfs(int x,int fa){
	siz[x]=1;dfn[x]=++cnt;
	for(rint i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(y!=fa){
			dfs(y,x);
			siz[x]+=siz[y];
		}
	}
}
void build(int p,int l,int r){
	l(p)=l;r(p)=r;
	if(l==r){cs(p)=c[l],vs(p)=v[l];return;}
	int Mid=l+r>>1;
	build(ls,l,Mid),build(rs,Mid+1,r);
	cs(p)=cs(ls)*cs(rs)%mod;
	vs(p)=vs(ls)*vs(rs)%mod;
	return ;
}
ll query(int p,int l,int r,int cmd){
	if(l<=l(p)&&r(p)<=r){
		if(cmd) return vs(p);
		else return cs(p);
	}
	ll res=1;int Mid=l(p)+r(p)>>1;
	if(l<=Mid) res=query(ls,l,r,cmd);
	if(r>Mid) res=res*query(rs,l,r,cmd)%mod;
	return res;
}
int main(){
	read(n,mod);
	for(rint i=1;i<n;i++) read(x,y),add(x,y,"Mr.Az");
	dfs(1,0);
	for(rint i=1;i<=n;i++) read(c[dfn[i]]);
	for(rint i=1;i<=n;i++) read(v[dfn[i]]);
	build(1,1,n);
	for(rint i=1;i<=n;i++){
		ll res=1;
		if(dfn[i]!=1) res=query(1,1,dfn[i]-1,1);
		res=res*query(1,dfn[i],dfn[i]+siz[i]-1,0)%mod;
		if(dfn[i]+siz[i]<=n) res=res*query(1,dfn[i]+siz[i],n,1)%mod;
		ans=(ans+res)%mod;
	}
	printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：InoueTakina (赞：1)

一眼丁真，鉴定为牛子题。

注意到 $m$ 即使为质数，点权也不一定（事实上数据是一定不）存在逆元，因此这题是个牛子题。

子树内 $c$ 的积容易用树形 dp 求出，故重点考虑子树补的 $v$ 积。

将树按 dfn 序拍平到序列上，考察某个点子树补在序列上的结构，显然是一段前缀拼上一段后缀的形式，维护前缀积和后缀积，然后乘起来即可。

心情好，给个代码吧。

```
#include<bits/stdc++.h>
#define Maxn 1000007
using namespace std;
int fa[Maxn], dfn[Maxn], c[Maxn], v[Maxn], p, n, vpre[Maxn], g[Maxn], f[Maxn], vsuf[Maxn], cnt, L[Maxn], R[Maxn]; vector<int> e[Maxn];
char buf[1<<21], *p1, *p2;
#define GC p1 == p2 and (p2 = (p1 = buf) + fread(buf, 1, 1<<21, stdin), p1 == p2) ? EOF : *p1++
inline int read() {
	int x = 0; char ch = GC;
	while(ch > '9' || ch < '0') ch = GC;
	while(ch >= '0' && ch <= '9') x = (x<<1) + (x<<3) + (ch^48), ch = GC;
	return x;
}
void dfs(int u, int fa) {
	L[u] = dfn[u], R[u] = dfn[u];
	for(auto v : e[u]) if(v != fa) dfn[v] = ++ cnt, dfs(v, u);
	for(auto v : e[u]) if(v != fa) L[u] = min(L[u], L[v]), R[u] = max(R[u], R[v]);
}
void dp(int u, int fa) {
	g[u] = c[u]; for(auto v : e[u]) if(v != fa) dp(v, u), g[u] = 1ll * g[u] * g[v] % p;
	f[u] = 1ll * g[u] * vpre[L[u] - 1] % p * vsuf[R[u] + 1] % p;
}
int main() {
	n = read(); p = read(); // 4 + 2 + 4;
	for(int i = 2, u, v; i <= n; i ++) u = read(), v = read(), e[u].push_back(v), e[v].push_back(u); dfn[1] = ++ cnt; dfs(1, 0);
	for(int i = 1; i <= n; i ++) c[i] = read(); for(int i = 1; i <= n; i ++) v[i] = read();
	for(int i = 1; i <= n; i ++) vpre[dfn[i]] = vsuf[dfn[i]] = v[i]; vpre[0] = 1; 
	for(int i = 2; i <= n; i ++) vpre[i] = 1ll * vpre[i] * vpre[i - 1] % p; vsuf[n + 1] = 1;
	for(int i = n - 1; i; i --) vsuf[i] = 1ll * vsuf[i] * vsuf[i + 1] % p; int ans = 0; dp(1, 0);
	for(int i = 1; i <= n; i ++) ans = (ans + f[i]) % p; cout << ans;
}
```

---

## 作者：comcopy (赞：1)

首先了解下 dfn 的性质。

对于一个点 $x$，其子节点所在的 dfn 序必然在区间 $dfn[x]\sim dfn[x]+size[x]-1$，其中 `size[x]` 为点 $x$ 的子树大小。

显然我们用两个线段树维护一下区间的乘积就行了,枚举每个点，将它是根节点与否的权值求和就行。

```cpp
#include<bits/stdc++.h>
#define mi(...) <%__VA_ARGS__%>
#define int long long
using namespace std;

const int N=3e5+5;
int n,m,dfn[N],d[N],c[2][N],siz[N],id;
vector<int> vec[N];
void dfs(int x,int fa) {
	dfn[++id]=x;
	d[x]=id;
	siz[x]=1;
	for(auto u:vec[x]) {
		if(u==fa)continue;
		dfs(u,x);
		siz[x]+=siz[u];
	}
}
int mul[2][N<<2];
void pushup(int p,int op) {
	mul[op][p]=(mul[op][p<<1]*mul[op][p<<1|1])%m;
}
void build(int p,int l,int r,int op) {
	if(l==r) {
		mul[op][p]=c[op][dfn[l]];
		return ;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid,op);
	build(p<<1|1,mid+1,r,op);
	pushup(p,op);
}
int query(int p,int l,int r,int L,int R,int op) {
	if(L>R)return 1;
	int res=1;
	if(l>=L && r<=R)return mul[op][p];
	int mid=l+r>>1;
	if(L<=mid)(res*=query(p<<1,l,mid,L,R,op))%=m;
	if(R>mid)(res*=query(p<<1|1,mid+1,r,L,R,op))%=m;
	return res;
}
signed main() {
	n=read(),m=read();
	for(int i=1,u,v; i<n; ++i)
		u=read(),v=read(),
		vec[u].push_back(v),
		vec[v].push_back(u);
	int ans=1;
	for(int i=1; i<=n; ++i)(ans*=(c[0][i]=read())%m)%=m;
	for(int i=1; i<=n; ++i)c[1][i]=read();
	dfs(1,0);
	build(1,1,n,0);
	build(1,1,n,1);
	for(int i=2;i<=n;++i)
		(ans+=query(1,1,n,d[i],d[i]+siz[i]-1,0)*query(1,1,n,1,d[i]-1,1)%m*query(1,1,n,d[i]+siz[i],n,1)%m)%=m;
	write(ans),puts("");
	return(0-0);
}
```



---

## 作者：Emily666 (赞：0)

这道题的关键就是求子树内/外的乘积。

子树内的乘积：这个比较简单，在 dfs 遍历树时就可以顺便算出来了。

**代码：**
```cpp
void dfs(int x,int f){
	sc[x]=c[x];//算上自己
	L[x]=++tot,id[tot]=x;//计算 dfs 序（后面有用），L[x] 是这个节点本身的序号（也是这个子树的第一个序号），id[tot] 是反过来的映射
	for(auto y:e[x]){
		if(y==f) continue;
		dfs(y,x);
		sc[x]=(sc[x]*sc[y])%m; //累加儿子的子树积
	}
	R[x]=tot;//还是 dfs 序，表示这棵子树的最后一个序号
}
```

子树外的乘积：不难想到用整棵树的乘积除以子树的乘积，但是这样要用逆元（因为有取模），这里说的是不用逆元，也就是用 dfs 序的方法。

dfs 序，是一棵树在 dfs 过程中遍历的顺序。因此它有一个很奇妙的性质：一个子树在 dfs 序中是连续的（毕竟遍历这棵子树的过程中你不可能跳到别的子树上）。

所以，“整棵树的乘积除以子树的乘积”就可以用 dfs 序转化为“子树前面的部分”乘“子树后面的部分”，再在 dfs 序序列上用前缀和、后缀和维护即可。

**代码：**
```cpp
dfs(1,0);//先遍历树，处理出子树乘积
lv[0]=rv[n+1]=1;//初始化开头（这里的 lv 表示 dfs 序的前缀和，rv 表示后缀和）
for(int i=1;i<=n;i++) lv[i]=(lv[i-1]*v[id[i]])%m;
for(int i=n;i>0;i--) rv[i]=(rv[i+1]*v[id[i]])%m;
//计算
ans=sc[1]%m;//先算整棵树的答案
for(int i=2;i<=n;i++) ans=(((lv[L[i]-1]*rv[R[i]+1])%m*sc[i])%m+ans)%m;
//lv[L[i]-1]：子树左边  rv[R[i]+1]：子树右边
```

### 最后是完整代码：
```cpp
//主要部分的注释都在前面，这里就不放啦
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=3e5+3;
int n,m;
ll c[N],v[N],L[N],R[N],id[N],tot,ans;
ll sc[N],lv[N],rv[N];
vector<int>e[N];
void dfs(int x,int f){
	sc[x]=c[x];
	L[x]=++tot,id[tot]=x;
	for(auto y:e[x]){
		if(y==f) continue;
		dfs(y,x);
		sc[x]=(sc[x]*sc[y])%m;
	}
	R[x]=tot;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//个人习惯，输入输出优化
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=n;i++) cin>>v[i];
	dfs(1,0);
	lv[0]=rv[n+1]=1;
	for(int i=1;i<=n;i++) lv[i]=(lv[i-1]*v[id[i]])%m;
	for(int i=n;i>0;i--) rv[i]=(rv[i+1]*v[id[i]])%m;
	ans=sc[1]%m;
	for(int i=2;i<=n;i++) ans=(((lv[L[i]-1]*rv[R[i]+1])%m*sc[i])%m+ans)%m;
	cout<<ans;
	return 0;
} 
```

---

## 作者：ダ月 (赞：0)

### 题目分析：

起先的做法是预处理出每个结点其子树的 $c_i$ 和 $v_i$ 之积，分别记作 $S1_i$ 和 $S2_i$，显然答案就是 $\begin{aligned}\sum_{i=1}^n S1_i\times S2_1\times \operatorname{inv}(S2_i)\end{aligned}$ 。但是这道题 $m$ 起先不是质数，即使后来改成质数仍然存在没有逆元的情况。这种做法不行。

那么换种做法。将这棵树拍扁成 dfs 序，显然对于第 $i$ 个结点，其对应的 dfs 序为 $id_i$，子树大小 $sz_i$，那么其子树对应序列 $id_i\sim id_i+sz_i-1$，其余部分对应其补树。

考虑一个能区间询问的数据结构或算法，显然前缀和和树状数组不行。因为他们涉及到逆元。所以可以用线段树来维护区间和。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3e5+10;
//===
//缺省源
//===
int n;
ll mod;
vector<int> a[N];
ll c[N],v[N],w1[N],w2[N],s1[N],s2[N],id[N],cnt=0;
int sz[N];
void dfs1(int x,int F){
	id[x]=++cnt;w1[cnt]=c[x],w2[cnt]=v[x];sz[x]=1;
	for(auto y:a[x]){
		if(y==F)continue;
		dfs1(y,x);sz[x]+=sz[y];
	}
}ll ans=0;
ll tr1[N<<2],tr2[N<<2];
void pushup(int rt){tr1[rt]=tr1[rt<<1]*tr1[rt<<1|1]%mod,tr2[rt]=tr2[rt<<1]*tr2[rt<<1|1]%mod;}
void build(int rt,int l,int r){
	if(l==r)return tr1[rt]=w1[l],tr2[rt]=w2[l],void();
	int mid=l+r>>1;
	build(rt<<1,l,mid);
	build(rt<<1|1,mid+1,r);
	pushup(rt);
}ll query1(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tr1[rt];
	int mid=l+r>>1;ll ans=1;
	if(x<=mid)ans=ans*query1(rt<<1,l,mid,x,y)%mod;
	if(y>mid)ans=ans*query1(rt<<1|1,mid+1,r,x,y)%mod;
	return ans;
}ll query2(int rt,int l,int r,int x,int y){
	if(x>y||x>n)return 1;//特判
	if(x<=l&&r<=y)return tr2[rt];
	int mid=l+r>>1;ll ans=1;
	if(x<=mid)ans=ans*query2(rt<<1,l,mid,x,y)%mod;
	if(y>mid)ans=ans*query2(rt<<1|1,mid+1,r,x,y)%mod;
	return ans;
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=IO::readInt(),mod=IO::readInt();
	for(int i=1;i<n;i++){
		int x=IO::readInt(),y=IO::readInt();
		a[x].pd(y),a[y].pd(x);
	}for(int i=1;i<=n;i++)c[i]=IO::readInt();
	for(int i=1;i<=n;i++)v[i]=IO::readInt();
	for(int i=1;i<=n*4;i++)tr1[i]=tr2[i]=1;
	dfs1(1,0);build(1,1,n);
	ll ans=0;
	for(int i=1;i<=n;i++)
		ans=(ans+query1(1,1,n,id[i],id[i]+sz[i]-1)*query2(1,1,n,1,id[i]-1)%mod*query2(1,1,n,id[i]+sz[i],n)%mod)%mod;
	printf("%lld\n",ans);
	return 0;
}


```

时间复杂度：$O(n\log n)$。

---


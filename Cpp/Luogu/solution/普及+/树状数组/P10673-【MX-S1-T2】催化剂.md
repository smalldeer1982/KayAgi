# 【MX-S1-T2】催化剂

## 题目背景

原题链接：<https://oier.team/problems/S1B>。

## 题目描述

小朋友们很喜欢糖果。

现在，小 K 有一些糖果，每个糖果上有一个数字代表它的种类。

有 $q$ 次事件，每次事件会加入一个糖果、或删除一个糖果、或提出一次询问。

每次询问会给出一个 $k$，表示小 K 现在需要将所有糖果分给 $k$ 个小朋友，并且每个小朋友都需要得到至少一个糖果。同时，小朋友们不喜欢得到相同的糖果。具体的，在一个小朋友得到了糖果 $i$ 时，如果 Ta 在这个糖果之前就已经获得过糖果 $i$，那么 Ta 就会感到非常生气，Ta 的愤怒值就会增加 $1$。

小 K 不喜欢看到小朋友们生气，但小 K 无法解决这么困难的问题，所以你需要帮小 K 求出一种分糖果的方式，最小化所有小朋友的愤怒值之和。

保证存在一种分糖果的方案，使得每个小朋友都分到至少一个糖果。

每次询问并没有真正的分糖果，即每次询问后小 K 拥有的糖果不会改变。

注意，分糖果的过程可以理解为将小 K 拥有的所有糖果划分到 $k$ 个非空序列，可以重排。

## 说明/提示

__【样例解释 1】__

第一次询问时，小 K 手上的糖果为 $\{3,5,2,5,5\}$，分给 $2$ 个小朋友的糖果为 $\{2,3,5\},\{5,5\}$，小朋友的愤怒值为 $0,1$。可以证明没有愤怒值之和更小的方案。

__【数据范围】__

__本题使用子任务捆绑测试。__

对于 $100\%$ 的数据，$1\le n,q\le 10^6$，$1\le a_i,x\le n$。每次询问时，令 $S$ 表示此时小 K 拥有的糖果数量，保证 $1\le k\le S$。

| 子任务编号 | $n\le $ | $q\le $ | 特殊性质      | 分值 |
| ---------- | ------- | ------- | ------------- | ---- |
| $1$        | $5$     | $15$    | 无            | $20$ |
| $2$        | $2000$  | $2000$  | 无            | $20$ |
| $3$        | $10^5$  | $10^5$  | 无            | $20$ |
| $4$        | $10^6$  | $10^6$  | $a_i,x\le 50$ | $10$ |
| $5$        | $10^6$  | $10^6$  | $k\le 50$     | $10$ |
| $6$        | $10^6$  | $10^6$  | 无            | $20$ |


## 样例 #1

### 输入

```
5 4
3 5 2 5 5
3 2
2 5
1 5
3 1```

### 输出

```
1
2```

## 样例 #2

### 输入

```
5 15
2 5 2 5 1
2 1
1 1
1 2
1 4
1 1
3 2
1 1
3 1
1 5
3 1
1 2
3 1
2 1
3 3
2 2
```

### 输出

```
1
5
6
7
1
```

# 题解

## 作者：wimg6_ (赞：12)

因为要使每个小朋友拿到的糖种类尽量多，所以我们可以让一个小朋友取所有有剩余的糖各一颗，然后剩下的糖的总数就是答案。

那么对于第 $i$ 种糖，答案就是 $f_i-k(f_i\geq k)$，其中 $f_i$ 表示目前还有多少颗第 $i$ 种糖，但是我们会发现这个方向很难继续优化。

于是我们转换思路，记录 $s_i$ 表示有 $i$ 颗糖的糖果种类的数量，那么答案就是 $(i-k)\times s_i(i>k)$，同时注意到 $\sum_{i=x}^y i\times s_i$ 和 $\sum_{i=x}^y s_i$ 都可以用线段树在 $O(\log n)$ 时间内得出。

故对于前两个操作就是线段树单点修改，最后一个操作就是线段树区间查询，复杂度是 $O((n+q)\log n)$。

值得注意的是，正常数组需要开 $2\times 10^6$，因为有可能会出现非常多的一号操作。线段树记得开四倍。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const long long N=2e6;
int n,q,k,a[N+10],f[N+10],s[N+10],tree[4*N+10],t[4*N+10];
int read(){
    int x=0;char ac=getchar();
    while(ac<'0' || ac>'9') ac=getchar();
    while(ac>='0' && ac<='9') x=x*10+ac-'0',ac=getchar();
    return x;
}
void push_up(int id){
    tree[id]=tree[id*2]+tree[id*2+1];
    t[id]=t[id*2]+t[id*2+1];
}
void build_tree(int id,int l,int r){
    if(l==r){
        tree[id]=s[l]*l,t[id]=s[l];
        return ;
    }
    int mid=(l+r)/2;
    build_tree(id*2,l,mid);
    build_tree(id*2+1,mid+1,r);
    push_up(id);
}
void change(int id,int l,int r,int x){
    if(l==r){
        tree[id]=s[l]*l,t[id]=s[l];
        return ;
    }
    int mid=(l+r)/2;
    if(x<=mid) change(id*2,l,mid,x);
    else change(id*2+1,mid+1,r,x);
    push_up(id);
}
int cal(int id,int l,int r,int x,int y){
    if(x<=l && r<=y) return tree[id]-k*t[id];
    int mid=(l+r)/2,ans=0;
    if(x<=mid) ans+=cal(id*2,l,mid,x,y);
    if(y>mid) ans+=cal(id*2+1,mid+1,r,x,y);
    return ans;
}
signed main(){
    n=read(),q=read();
    for(int i=1;i<=n;i++)
        a[i]=read(),f[a[i]]++;
    for(int i=1;i<=n;i++)
        s[f[i]]++;
    //for(int i=1;i<=n;i++)
    //    printf("%d ",s[i]);
    build_tree(1,1,N);
    while(q--){
        int op=read();
        if(op==1){
            int x=read();
            s[f[x]]--,change(1,1,N,f[x]),f[x]++,s[f[x]]++,change(1,1,N,f[x]);
        }
        else if(op==2){
            int x=read();
            s[f[x]]--,change(1,1,N,f[x]),f[x]--,s[f[x]]++,change(1,1,N,f[x]);
        }
        else if(op==3){
            k=read();
            //printf("%d %d %d ",tree[1],t[1],cal(1,1,n,1,k));
            printf("%lld\n",cal(1,1,N,k+1,N));
        }
    }
    return 0;
}
```

---

## 作者：saixingzhe (赞：7)

# 思路
有点意思的一道题。

很显然要开桶存糖果的数量，然后我们对题意进行转换，发现是求整个桶中大于 $k$ 的数和 $k$ 的差值的和，还带着修改。

求所有大于等于 $k$ 的很容易想到树状数组，思考如何求差值的和和操作一，我们发现每种糖的个数加一，所有人数小于等于原来个的小朋友的愤怒值都会加一，于是可以区间修改，操作二同理。

但是树状数组要开 $n+q$ 并且**修改也要是这个大小**，我赛时因为这个痛失 AC。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,s,op,k,a[2000001],Max,T[2000001];
int ans(int x){
	int sum=0;
	for(;x>0;x-=(x&-x))	sum+=T[x];
	x--;
	for(;x>0;x-=(x&-x))	sum-=T[x];
	return sum;
}
void pl(int x,int y,int k){
	if(x>y)	return ;
	y++;
	for(;x<=2*n;x+=(x&-x)) T[x]+=k;
	for(;y<=2*n;y+=(y&-y)) T[y]-=k;
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%d",&s);
		pl(1,a[s],1);
		a[s]++;
	}
	for(int i=1;i<=q;i++){
		scanf("%d%d",&op,&k);
		if(op==1)	pl(1,a[k],1),a[k]++;
		else	if(op==2)	a[k]--,pl(1,a[k],-1);
		else	printf("%d\n",ans(k));
	}
    return 0;
}
```

---

## 作者：_zuoqingyuan (赞：4)

# 思路分析

因为题目中保证当前糖果总和大于小朋友数，所以一定不存在小朋友没有糖果的情况。

理解：“最小化怒气值”，通俗来讲，在发糖果时尽量不给同一个小朋友发同一种糖果。可以理解为，对于第 $i$ 种糖果，有 $a_i$ 颗，而仅仅有 $k$ 个小朋友，恰巧 $a_i>k$。则先给每个小朋友发一个，如果有剩余的，在另作处理。

我们发现，在给每个小朋友一个糖果后，剩下的 $a_i-k$ 颗糖果，发给一个人也好，分散发给其他人也罢，总的怒气值都增加了 $a_i-k$。这样我们就可以将问题的三种操作转换一下。

1. $a_i\to a_i+1$。

2. $a_i\to a_i-1$。

3. 求 $\sum\limits_{a_i>k}a_i-k$ 的值。

应为 $n,q\le 10^6$，数据规模较大，我们应当用常数较小的数据结构，这里我用的是树状数组。

我们设 $cnt_x$ 表示 $a_i=x$ 的 $i$ 的**个数**，$Cnt_x$ 表示 $a_i=x$ 的 $a_i$ **之和**，显然，对于 $x\in [1,k]$ 的 $cnt_x$ 和 $Cnt_x$ 并不会对答案产生影响。因为糖果数只有大于 $k$ 才会怒气值产生影响。

化简操作 $3$ 的原式，$\sum\limits_{a_i>k}a_i-k=\sum\limits_{i=k+1}^{limit}Cnt_i-k\sum\limits_{i=k+1}^{limit}[a_i>k]$，后半部分等价于 $\sum\limits_{i=k+1}^{limit}cnt_i$。其中 $limit$ 为一种糖果最多的个数。理论为 $n+q$。

对于第操作 $1,2$，比较简单，就不细说了，**重点提醒**：注意特判 $a_i=0$ 的情况。

# $\text{Code}$：
```cpp
#include <iostream>
#include <cstdio>
#define int long long
using namespace std;
const int N=1e6+10;
int c[2][2*N],n,q,maxn,a[N],op,t;
void add(int x,int t,int op){
    while(x<=maxn){
        c[op][x]+=t;
        x+=(x&-x);
    }
    return;
}
int query(int x,int op){
    int cnt=0;
    while(x>0){
        cnt+=c[op][x];
        x-=(x&-x);
    }
    return cnt;
}
int ask(int l,int r,int op){
    return query(r,op)-query(l-1,op);
}
signed main(){
    scanf("%lld %lld",&n,&q);
    for(int i=1,x;i<=n;i++){
        scanf("%lld",&x);
        a[x]++;maxn=max(maxn,x);
    }
    maxn=n+q-1;
    for(int i=1;i<=n;i++){
        if(a[i])add(a[i],1,0),add(a[i],a[i],1);
    }
    while(q--){
        scanf("%lld %lld",&op,&t);
        if(op==1){
            if(a[t])add(a[t],-1,0),add(a[t],-a[t],1);
            a[t]++;
            add(a[t],1,0),add(a[t],a[t],1);
        }
        if(op==2){
            add(a[t],-1,0),add(a[t],-a[t],1);
            a[t]--;
            if(a[t])add(a[t],1,0),add(a[t],a[t],1);
        }
        if(op==3){
            printf("%lld\n",ask(t+1,maxn,1)-ask(t+1,maxn,0)*t);
        }
    }
    return 0;
}
```

蒟蒻第一次场切绿题。~~话说不开 long long 都能过。~~

如有错误，请指出。

---

## 作者：Butterfly_qwq (赞：3)

比较 tricky 的一道题。

分析题面，易证题面可以转换为 https://www.luogu.com.cn/paste/mk7r4ym2 所示形式。

然后考虑对于 $c$ 数组建立值域两个树状数组，一个把 $c_i$ 放进去，一个把 $i\times c_i$ 放进去，这个东西是很好维护的。

然后对于答案，就可以把所有比 $k$ 大的元素之和 $x$ 和元素个数 $y$ 求出来，答案就是 $y-k\times x$。

时间复杂度 $O(n\log n)$。

下面的代码有可能过不了，因为没写快读。把快读加上就能过。为了代码的美观性，我把快读删去了。

Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,ct[1000005];
struct BIT
{
	int c[2000005];
	void reset()
	{
		memset(c,0,sizeof(c));
	}
	void update(int u,int w)
	{
		if(!u)return;
		for(int i=u;i<=n+q;i+=i&-i)c[i]+=w;
	}
	int query(int u)
	{
		if(!u)return 0;
		int res=0;
		for(int i=u;i;i-=i&-i)res+=c[i];
		return res;
	}
}t1,t2;
signed main()
{
	cin>>n>>q;
	t1.reset();t2.reset();
	for(int i=1,a;i<=n;i++)
	{
		cin>>a;
		t1.update(ct[a],-1);
		t1.update(ct[a]+1,1);
		t2.update(ct[a],-ct[a]);
		t2.update(ct[a]+1,ct[a]+1);
		ct[a]++;
	}
	for(int i=1,op,x,ans;i<=q;i++)
	{
		cin>>op>>x;
		if(op==1)
		{
			t1.update(ct[x],-1);
			t1.update(ct[x]+1,1);
			t2.update(ct[x],-ct[x]);
			t2.update(ct[x]+1,ct[x]+1);
			ct[x]++;
		}
		if(op==2)
		{
			t1.update(ct[x],-1);
			t1.update(ct[x]-1,1);
			t2.update(ct[x],-ct[x]);
			t2.update(ct[x]-1,ct[x]-1);
			ct[x]--;
		}
		if(op==3)cout<<t2.query(n+q)-t2.query(x)-(t1.query(n+q)-t1.query(x))*x<<'\n';
	}
}
```

---

## 作者：sbno333 (赞：2)

题目质量很高，我很喜欢，但是觉得难度应该只能算下位绿。

我们考虑只有一次询问该怎么做，从一般到特殊是所有题都可以用的极好的方法。

我们考虑把每种糖分开考虑，显然每种糖产生的贡献互不干扰。

对于有 $a_i$ 个的一种糖，考虑贪心，每次给到没有这种糖的人，不贡献。但是如果 $a_i>k$，根据万恶的抽屉原理，得到从第 $k+1$ 次分糖开始，必定会产生贡献（或者让以前某一次产生贡献，这次不产生，但不影响结果，同时这也会让问题变得复杂，所以不考虑）。

所以贡献就是 $\max(0,a_i-k)$。

这时你会发现好难啊我不会！

~~考虑疯狂练习 Ynoi 然后维护~~，然后你就会发现代码量又大又不好调。

于是我们偶然想到可以记录询问 $k$ 时的答案。

考虑维护。

询问时直接输出即可。

增加时，对于 $k>a_i$ 的不变，其它加一（细节可以自行思考或参考代码，这里仅提供大体思路）。

减少时也是 $k>a_i$ 的不变，其它加一。

$a_i$ 是可以~~线段树维护~~简单维护的。

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
int a[2000009];
struct st{
	int f[2000009];
	int lowbit(int x){
		return x&(-x);
	}
	void pu(int x,int y){
		while(x<=2000000&&x>0){
			f[x]+=y;
			x+=lowbit(x);
		}
	}
	void push(int r,int k){
		pu(1,k);
		pu(r+1,-k);
	}
	int que(int x){
		int ans;
		ans=0;
		while(x>0){
			ans+=f[x];
			x-=lowbit(x);
		}
		return ans;
	}
}f;
void add(int x){//int add(int x)->die
	if(a[x]>0)
	f.push(a[x],1);
	a[x]++;
}
void pop(int x){
	a[x]--;
	if(a[x]>0)
	f.push(a[x],-1);
}
int que(int x){
	return f.que(x);
}
signed main(){
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		int z;
		cin>>z;
		add(z);
	}
	for(int i=1;i<=q;i++){
		int o,z;
		cin>>o>>z;
		if(o==1){
			add(z);
		}else if(o==2){
			pop(z);
		}else{
			cout<<que(z)<<endl;
		}
	}
	return 0;
}
```

学生：那还应该注意点什么呢？

我：别把 `void` 写成 `int`，省选就是这么死的~~不这么失误也死，只不过死状好看点罢了~~，否则你会调试整整 $15$ 分钟加一车罚时，别问我怎么知道的。

---

## 作者：_O_v_O_ (赞：2)

我们设 $b_i$ 为糖果 $i$ 的个数，$c_i$ 为 $i$ 在 $b$ 中的出现次数，很显然 $c$ 的大小要开到 $n+q$。

那么一次询问就相当于问我们 $\sum_{i=k}^{n+q} c_i\times(i-k)$，因为一个出现次数为 $x$ 的糖果会产生 $x-k$ 的愤怒值。

那么一次 $1$ 操作就相当于 $b_i\leftarrow b_i+1$，那么 $c_{b_i-1}\leftarrow c_{b_i-1}-1,c_{b_i}\leftarrow c_{b_i}+1$。

同理，一次 $2$ 操作等价于 $b_i\leftarrow b_i-1,c_{b_i+1}\leftarrow c_{b_i+1}-1,c_{b_i}\leftarrow c_{b_i}+1$。

我们发现这个很像线段树，可是无法快速维护操作 $3$ 的式子。

那么我们如何快速维护那个式子呢？我们把式子拆成 $\sum_{i=k}^{n+q} (c_i\times i)-\sum_{i=k}^{n+q} c_i\times k$，那么我们只用维护 $\sum_{i=k}^{n+q}( c_i\times i)$ 和 $\sum_{i=k}^{n+q} c_i\times k$ 即可。

---

## 作者：HasNoName (赞：1)

### 思路

可以使用一个数组 $ans$ 来计算答案。$ans_i$ 表示分给 $i$ 个人的最小愤怒值之和，再用 $b_i$ 表示第 $i$ 种糖的个数。

可以发现当增加一个种类为 $k$ 的糖时，$ans_1$ 到 $ans_{b_k-1}$ 都要增加 $1$。当减少一个种类为 $k$ 的糖时，$ans_1$ 到 $ans_{b_k}$ 都要减少一。

考虑使用线段树。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int a[N],b[N],n,q,w[16*N],tag[16*N];
void pushdown(int u,int l,int r)//懒标记下传
{
	int t=tag[u];
	tag[u]=0;
	tag[u<<1]+=t;
	tag[(u<<1)+1]+=t;
	int mid=(l+r)>>1;
	w[u<<1]+=t*(mid-l+1);
	w[(u<<1)+1]+=t*(r-mid);
}
bool jiao(int l,int r,int x,int y)//(l,r)和(x,y)是否有交集
{
	return !(r<x||l>y);
}
void add(int u,int l,int r,int x,int y,int k)//将x~y的位置增加k
{
	pushdown(u,l,r);
	if(x<=l&&y>=r)
	{
		w[u]+=k*(r-l+1);
		tag[u]+=k;
		return;
	}
	int mid=(l+r)>>1;
	if(jiao(x,y,l,mid))add(u<<1,l,mid,x,y,k);
	if(jiao(x,y,mid+1,r))add((u<<1)+1,mid+1,r,x,y,k);
}
int get(int u,int l,int r,int x)//得到ans的第x项
{
	pushdown(u,l,r);
	if(l==r&&l==x)return w[u];
	int mid=(l+r)>>1,ans=0;
	if(mid>=x&&l<=x)ans+=get(u<<1,l,mid,x);
	if(r>=x&&mid+1<=x)ans+=get((u<<1)+1,mid+1,r,x);
	return ans;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q;
	int T=q;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		b[a[i]]++;//开始的时候可以假设没有糖，每次输入时增加一个糖
		if(b[a[i]]-1)add(1,1,n+T,1,b[a[i]]-1,1);//如果y<x，则会RE，故需要保证b[a[i]]-1为正数
	}
	int op,k;
	while(q--)
	{
		cin>>op>>k;
		if(op==1)
		{
			b[k]++;
			if(b[k]-1)add(1,1,n+T,1,b[k]-1,1);//因为后续增加后总数（ans的项数）最多会增加到n+q
		}
		if(op==2)
		{
			b[k]--;
			if(b[k])add(1,1,n+T,1,b[k],-1);
		}
		if(op==3)
		{
			cout<<get(1,1,n+T,k)<<'\n';//ans
		}
	}
	return 0;
}
```

---

## 作者：osfly (赞：1)

### something interesting

好久没写题解了。赛时切了，感觉退役后实力大不如从前。

### 正文

先只考虑静态的问题怎么做。

令 $a_i$ 表示糖果 $i$ 的数量。

我们发现可以贪心，发现答案为：

$$
\sum_{i=1}^n(a_i-k)\times[a_i>k]
$$

为什么呢？显然是对于第 $i$ 种糖果，先分给所有的小朋友，如果还有剩的，则把剩下的全部给第一个小朋友，这个小朋友就会贡献 $a_i-k$ 的愤怒值；如果不足则没有一个小朋友对答案有贡献。

然后考虑动态怎么做。

首先能考虑到我们所需要的只有 $> k$ 的部分。我们可以动态维护 $c_i$ 数组，其中 $c_i$ 表示数量为 $i$ 的糖果的种类数。这个东西是可以直接用线段树维护的。

那么对于加糖果和删糖果，直接在线段树上把原来这种糖果数量的位置 $-1$，然后在修改后糖果数量的位置 $+1$。查询只需要查 $[k+1,n+q]$ 的部分即可。

注意，这里查询的右端点是 $n+q$，因为可能在操作时加了一大堆相同的糖果。但是很奇怪的，本人赛时右端点写了 $n+q$ 会挂，故右端点定为了 $3n$，原因未明。

时间复杂度 $O(q\log n)$。

---

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long

const int N=3e6+10;

int n,q,a[N];

struct seg
{
	struct node
	{
		int l,r;
		int val,cnt;
	}t[N<<2];
	#define ls (k<<1)
	#define rs (k<<1|1)
	#define L t[k].l
	#define R t[k].r
	#define mid ((L+R)>>1)
	void build(int k,int l,int r)
	{
		L=l,R=r;
		if(L==R) return ;
		build(ls,l,mid);
		build(rs,mid+1,r);
	}
	void update(int k,int x,int d)
	{
		if(L==R)
		{
			t[k].val+=d*L;
			t[k].cnt+=d;
//			printf("sakana~\n");
			return ;
		}
		if(x<=mid) update(ls,x,d);
		if(x>mid) update(rs,x,d);
		t[k].val=t[ls].val+t[rs].val;
		t[k].cnt=t[ls].cnt+t[rs].cnt;
	}
	int q1(int k,int l,int r)
	{
		if(l<=L&&R<=r) return t[k].val;
		int res=0;
		if(l<=mid) res+=q1(ls,l,r);
		if(r>mid) res+=q1(rs,l,r);
		return res;
	}
	int q2(int k,int l,int r)
	{
		if(l<=L&&R<=r) return t[k].cnt;
		int res=0;
		if(l<=mid) res+=q2(ls,l,r);
		if(r>mid) res+=q2(rs,l,r);
		return res;
	}
	void print(int k)
	{
		printf("%d %d %d %d\n",L,R,t[k].val,t[k].cnt);
		if(L==R) return ;
		print(ls),print(rs);
	}
	#undef ls
	#undef rs
	#undef L
	#undef R
	#undef mid
}tree;

int main()
{
	scanf("%d%d",&n,&q);
	tree.build(1,1,n*3);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		a[x]++;
	}
	for(int i=1;i<=n;i++)
		if(a[i]) tree.update(1,a[i],1);
	while(q--)
	{
		int opt,x;
		scanf("%d%d",&opt,&x);
		if(opt==1)
		{
			if(a[x]) tree.update(1,a[x],-1);
			a[x]++;
			tree.update(1,a[x],1);
		}
		if(opt==2)
		{
			tree.update(1,a[x],-1);
			a[x]--;
			if(a[x]) tree.update(1,a[x],1);
		}
		if(opt==3)
		{
//			printf("!%d %d\n",tree.q1(1,x+1,n),tree.q2(1,x+1,n));
			printf("%d\n",tree.q1(1,x+1,n*3)-tree.q2(1,x+1,n*3)*x);
		}
//		printf("===============\n");
//		tree.print(1);
//		printf("===============\n");
	}
	return 0;
}
```

---

## 作者：_Yonder_ (赞：1)

很明显，要想让所有小朋友的愤怒值之和最小，就要让不同的糖果平均分给每个小朋友，于是我们令 $t_i=$ 种类为 $i$ 的糖果的数量，则答案为：$\displaystyle\sum_{i = 1}^{n}{t_i-k}[t_i>k]$，树状数组即可。

对于一、二操作，那就是普通的单点修改了。
# Code
```
#include<bits/stdc++.h>
#define int long long
#define S std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define per(i,r,l) for(int i=r;i>=l;i--)
using namespace std;
const int N=2e6+5;
struct{
	int tr[N];
	void add(int x,int d){x++;while(x<N) tr[x]+=d,x+=x&-x;}
	int ask(int x){x++;int ans=0;while(x) ans+=tr[x],x-=x&-x;return ans;}
}A,B;
int n,q,a[N],t[N],op,x;
signed main(){
	S;cin>>n>>q;rep(i,1,n) cin>>a[i],t[a[i]]++;
	rep(i,1,n) if(t[i]) A.add(t[i],1),B.add(t[i],t[i]);
	while(q--){
		cin>>op>>x;
		if(op==1){
			A.add(t[x],-1),B.add(t[x],-t[x]);
			t[x]++;
			A.add(t[x],1),B.add(t[x],t[x]);
		}else if(op==2){
			A.add(t[x],-1),B.add(t[x],-t[x]);
			t[x]--;
			A.add(t[x],1),B.add(t[x],t[x]);
		}else cout<<B.ask(2e6)-B.ask(x)-(A.ask(2e6)-A.ask(x))*x<<endl;
	}
    return 0;
}
```

---

## 作者：junee (赞：1)

# P10673 题解

## 前置知识

树状数组。

## 题目分析

我们发现本题要求维护元素个数大于 $k$ 和元素个数大于 $k$ 的元素个数之和，考虑用树状数组维护。

用 $cnt$ 维护元素个数大于 $k$ 的个数，用 $sum$维护元素个数大于 $k$ 的元素个数之和。

最后答案即为 $\sum\limits_{i=k}^N sum_i - k \times \sum\limits_{i=k}^N cnt_i$。

注意 $ 1 \le N \le 2000000 $。

## Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<map>
using namespace std;
const int N=2e6+10;
typedef long long LL;
LL n,q;
LL a[N];
LL cnt[N],sum[N];
void add_cnt(LL x,LL k){
	for(;x<=N;x+=x&-x)cnt[x]+=k;
}
LL ask_cnt(LL x){
	LL res=0;
	for(;x;x-=x&-x)res+=cnt[x];
	return res;
}
void add_sum(LL x,LL k){
	for(;x<=N;x+=x&-x)sum[x]+=k;
}
LL ask_sum(LL x){
	LL res=0;
	for(;x;x-=x&-x)res+=sum[x];
	return res;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>q;
	memset(cnt,0,sizeof cnt);
	memset(sum,0,sizeof sum);
	for(LL i=1,x;i<=n;i++){
		cin>>x;
		a[x]++;
		add_cnt(a[x],1);
		if(a[x]>1)add_cnt(a[x]-1,-1),add_sum(a[x]-1,-a[x]+1);
		add_sum(a[x],a[x]);
	}
	while(q--){
		LL op,x;
		cin>>op>>x;
		if(op==1){
			a[x]++;
			add_cnt(a[x],1);
			if(a[x]>1)add_cnt(a[x]-1,-1),add_sum(a[x]-1,-a[x]+1);
			add_sum(a[x],a[x]);
		}
		else if(op==2){
			add_cnt(a[x],-1);
			if(a[x]>1)add_cnt(a[x]-1,1),add_sum(a[x]-1,a[x]-1);
			add_sum(a[x],-a[x]);
			a[x]--;
		}
		else{
			cout<<(ask_sum(N)-ask_sum(x-1))-x*(ask_cnt(N)-ask_cnt(x-1))<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Targanzqq (赞：1)

### 主要算法：树状数组的基础使用
这个题涉及的是单点修改和出现次数的查询、值域上的查询，我们可以轻易地想到树状数组。

我们开两个树状数组，一个维护数量，一个维护个数。我们先把原来的加进去，当我们每次增加的时候，我们去掉之前的值的贡献，加上当前值的贡献，减少的时候就反过来（对于原来没有和修改完没有的特判一下）。

对于查询，我们可以列一个式子：$\sum_{i=1}^n[b_i>k](b_i-k)$。我们转化一下，就变成了 $\sum_{i=1}^n[b_i>k]b_i-k\sum_{i=1}^n[b_i>k]$。看起来好像没什么用，但是我们发现前者和后者都可以用树状数组处理，前者需要处理出现次数的和，后者需要处理指定值域的数的个数。

源代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n,q,a[2000001],b[2000001];

struct tree_array{
    int c[2000001],d[2000001];
    int lowbit(int i){
    	return i&(-i);
	}
    void change(int i,int num){
    	for(;i<=n+q;i+=lowbit(i)){
    		c[i]+=num;
		}
	}
	int query(int i){
		int res=0;
		for(;i>=1;i-=lowbit(i)){
			res+=c[i];
		}
		return res;
	}
	void change2(int i,int num){
    	for(;i<=n+q;i+=lowbit(i)){
    		d[i]+=num;
		}
	}
	int query2(int i){
		int res=0;
		for(;i>=1;i-=lowbit(i)){
			res+=d[i];
		}
		return res;
	}
}tr;

signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b[a[i]]++;
	}
	for(int i=1;i<=n;i++){
		if(b[i]>0){
			tr.change(b[i],b[i]);
			tr.change2(b[i],1);
		}
	}
    for(int i=1;i<=q;i++){
    	int opt,k;
    	cin>>opt>>k;
    	if(opt==1){
    		if(b[k]>0){
    			tr.change(b[k],-b[k]);
    			tr.change2(b[k],-1);
			}
    		b[k]++;
    		tr.change(b[k],b[k]);
    		tr.change2(b[k],1);
		}
    	if(opt==2){
    		tr.change(b[k],-b[k]);tr.change2(b[k],-1);
    		b[k]--;
    		if(b[k]>0){
    			tr.change(b[k],b[k]);tr.change2(b[k],1);
			}
		}
    	if(opt==3){
    		cout<<(tr.query(n+q)-tr.query(k))-(tr.query2(n+q)-tr.query2(k))*k<<"\n";
		}
	}
}
```

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10673)

# 前置知识

[权值树状数组及应用](https://oi-wiki.org/ds/fenwick/#%E6%9D%83%E5%80%BC%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8F%8A%E5%BA%94%E7%94%A8)

# 解法

从贪心的角度分析，当小 K 有 $x(x \ge k)$ 个同种糖果时，将其分给 $k$ 个小朋友时尽可能平均发是最优情况，此时产生的愤怒值为 $x-k$。

那么，设出现次数 $\ge k$ 的糖果分别为 $b_{1},b_{2},b_{3}, \dots ,b_{m}$，其出现次数分别为 $c_{1},c_{2},c_{3}, \dots ,c_{m}$，最终有 $\sum\limits_{i=1}^{m}c_{i}-mk$ 即为所求。其中，$\sum\limits_{i=1}^{m}c_{i}$ 和 $m$ 均可通过权值树状数组维护。

注意及时删除因修改造成的影响及树状数组中下标为 $0$ 对操作中的影响。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
ll c[2][3000010],vis[3000010];
ll lowbit(ll x)
{
	return x&(-x);
}
void add(ll n,ll x,ll key,ll c[])
{
	for(ll i=x;i<=n;i+=lowbit(i))
	{
		c[i]+=key;
	}
}
ll getsum(ll x,ll c[])
{
	ll ans=0;
	for(ll i=x;i>=1;i-=lowbit(i))
	{
		ans+=c[i];
	}
	return ans;
}
int main()
{
	ll n,q,pd,x,i;
	scanf("%lld%lld",&n,&q);
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&x);
		if(vis[x]!=0)
		{
			add(3000000,vis[x],-1,c[0]);
			add(3000000,vis[x],-vis[x],c[1]);
		}
		vis[x]++;
		if(vis[x]!=0)
		{
			add(3000000,vis[x],1,c[0]);
			add(3000000,vis[x],vis[x],c[1]);
		}
	}
	for(i=1;i<=q;i++)
	{
		scanf("%lld%lld",&pd,&x);
		if(pd==1)
		{
			if(vis[x]!=0)
			{
				add(3000000,vis[x],-1,c[0]);
				add(3000000,vis[x],-vis[x],c[1]);
			}
			vis[x]++;
			if(vis[x]!=0)
			{
				add(3000000,vis[x],1,c[0]);
				add(3000000,vis[x],vis[x],c[1]);
			}
		}
		if(pd==2)
		{
			if(vis[x]!=0)
			{
				add(3000000,vis[x],-1,c[0]);
				add(3000000,vis[x],-vis[x],c[1]);
			}
			vis[x]--;
			if(vis[x]!=0)
			{
				add(3000000,vis[x],1,c[0]);
				add(3000000,vis[x],vis[x],c[1]);
			}
		}
		if(pd==3)
		{
			printf("%lld\n",getsum(3000000,c[1])-getsum(x-1,c[1])-(getsum(3000000,c[0])-getsum(x-1,c[0]))*x);
		}
	}
	return 0;
}
```

---


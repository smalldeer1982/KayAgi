# 【模板】离线二维数点

## 题目背景

青蛙。

## 题目描述

给你一个长为 $n$ 的序列 $a$，有 $m$ 次询问，每次询问给定 $l,r,x$，求 $[l,r]$ 区间中小于等于 $x$ 的元素个数。

## 说明/提示

对于 $20\%$ 的数据，满足 $1\le n,m,a_i,l,r,x\le 100$。

对于 $40\%$ 的数据，满足 $1\le n,m,a_i,l,r,x\le 10^4$。

对于 $60\%$ 的数据，满足 $1\le n,m,a_i,l,r,x\le 10^5$。

对于 $80\%$ 的数据，满足 $1\le n,m,a_i,l,r,x\le 10^6$。

对于 $100\%$ 的数据，满足 $1\le n,m,a_i,l,r,x\le 2\times10^6$。

## 样例 #1

### 输入

```
6 4
1 1 4 5 1 4
1 6 3
1 6 4
1 1 4
1 5 4```

### 输出

```
3
5
1
4```

# 题解

## 作者：可爱的小棉羊 (赞：79)

经典板子。

我们不妨这样理解：

把 $a_i$ 看成平面直角坐标系上的一个点 $(i,a_i)$。

以样例为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/unketdrl.png)

好的现在我们来看询问是不是在问一个长方形内有多少的点，还是那第一问为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/zra7xj1g.png)

答案显然是 $5$。

这个长方形显然是 $[l,r][0,x]$ 的范围。

我们不妨这样想 $[l,r]$ 的点相当于 $[1,r]$ 的点减去 $[1,l-1]$ 的点。

那么我们离线，用一条线从左往右的扫：

![](https://cdn.luogu.com.cn/upload/image_hosting/u5dv6xr3.png)

每遇到一个点我们把他加入一个集合 $S$，表示当前所有扫到过的点，那么我就要维护 $S$ 内比 $x$ 小的个数，显然的权值线段树或者树状数组。

这样就可以解决问题时间复杂度 $O((n+m)\log m)$

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,id,val;
};
int lowbit(int i){
	return i&(-i);
}
int f[2000005];
void add(int x){
	for(int i=x;i<=2000000;i+=lowbit(i))f[i]++;
}
int ask(int x){
	int ans=0;
	for(int i=x;i>=1;i-=lowbit(i))ans+=f[i];
	return ans;
}
vector<node>vec[2000005];
int ans[2000005],n,m,a[2000006];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++){
		int l,r,x;
		cin>>l>>r>>x;
		vec[l-1].push_back({x,i,-1});
		vec[r].push_back({x,i,1});
	}
	for(int i=1;i<=n;i++){
		add(a[i]);
		for(int j=0;j<vec[i].size();j++){
			ans[vec[i][j].id]+=vec[i][j].val*ask(vec[i][j].x);
		}
	}
	for(int i=1;i<=m;i++)cout<<ans[i]<<"\n";
	return 0;
}
```

这个板子很版，很重要！

---

## 作者：jiayixuan1205 (赞：17)

## 题意
在一段区间内查询小于等于 $x$ 的元素数量。
## 分析
可以将每个点看作平面直角坐标系上以横坐标为下标，纵坐标为该点值的一个点，那么该问题就可以转化为一个在矩形中扫描寻找值小于等于 $x$ 的点的问题（容易想到这个矩形横坐标是从 $l$ 到 $r$，纵坐标是从 $0$ 到 $x$），用树状数组维护即可。
## 代码展示
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 2e6+10;
int l,r,x,n,m;
int a[N],ans[N],tree[N];//ans用来存储每次询问的答案，a存储序列，tree用于树状数组的操作 

struct node{
	int id,x,v;
};

vector<node> c[N];//相当于差分处理的一个数组 

inline int lowbit(int x)
{
	return x&(-x);
}

inline void add(int x)
{
	for(int i=x;i<N;i+=lowbit(i))
	{
		tree[i]++;
	}
}

inline int ask(int x)
{
	int ans=0;
	for(int i=x;i>=1;i-=lowbit(i)) ans+=tree[i];//记录区间内的答案 
	return ans;
}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++)
	{
		cin>>l>>r>>x;
		c[l-1].push_back({i,x,-1});
		c[r].push_back({i,x,1});//记录每个询问的左右端点差分 
	}
	for(int i=1;i<=n;i++)
	{
		add(a[i]);//计入树状数组 
		for(int j=0;j<c[i].size();j++)
		{
			ans[c[i][j].id]+=c[i][j].v*(ask(c[i][j].x));//记录答案 
		}
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：Loser_Syx (赞：16)

我们考虑一个 $[l,r]$ 的答案，可以想到用 $[1,r]$ 的答案减去 $[1,l-1]$ 的答案，于是可以直接差分为两段计算。

考虑对每个 $[1,k]$ 计算答案，我们将 $k$ 排序后发现数组是有序的，可以直接 $1\sim n$ 加点，现在就是要维护 $[1,k]$ 中存在多少个元素 $\leq x$，权值树状数组可以做到，故复杂度 $O(n \log n)$。

```cpp
const int N = 2e6 + 19;
struct node {
	int k, id, x, val;
	bool operator < (const node &a) const {
		return k < a.k;
	}
} q[N << 1];
int a[N], cnt, ans[N];
struct BinaryTree {
	int t[N];
	void add(int x) {
		while (x < N) {
			t[x]++;
			x += lowbit(x);
		}
	}
	int query(int x) {
		int res = 0;
		while (x) {
			res += t[x];
			x -= lowbit(x);
		}
		return res;
	}
} bit;
signed main() {
	int n = read(), m = read();
	for (int i = 1; i <= n; ++i) {
		read(a[i]);
	}
	for (int i = 1; i <= m; ++i) {
		int l, r, x; read(l, r, x);
		q[++cnt] = {l-1, i, x, -1};
		q[++cnt] = {r, i, x, 1};
	}
	sort(q + 1, q + 1 + cnt);
	for (int i = 1, j = 1; i <= cnt; ++i) {
		for (; j <= q[i].k; ++j) bit.add(a[j]);
		ans[q[i].id] += q[i].val * bit.query(q[i].x);
	}
	for (int i = 1; i <= m; ++i) write(ans[i]);
	return 0;
}
```

---

## 作者：Milthm (赞：9)

拿到题一眼主席树，虽然不是不能做，但是还是太难写了。

有一种基于离线的思想，叫做离线二维数点。这样写的好处在于码量小，常数小。缺点也是当然有的：不支持强制在线。

我们拿这道题举例，首先把所有操作进行离线，然后将原数组从小到大排序，操作也按照 $x$ 值从小到大排序。

现在我们再按照顺序处理问题，我们发现，假设一个值在之前就比某个 $x$ 小了，那么现在它只要在这个区间里，就一定能被统计到。

所以我们可以用树状数组来维护，类似双指针的移动思想，每次把满足条件的值的原来的编号位置在树状数组上加一，这样每次的答案就是 $[l,r]$ 的区间和了。

于是我们就做出了这道题，假设 $n,m$ 同阶，时间复杂度 $O(n \log n)$。


```cpp
#include<bits/stdc++.h>
#define N 2000005
using namespace std;
int n,m,ans[N];
struct node{
	int l,r,x,id;
}a[N],q[N];
bool cmp(node a,node b){
	return a.x<b.x; 
}
struct BIT{
	int c[N];
	BIT(){
		memset(c,0,sizeof(c));
	}
	void add(int x,int k){
		while(x<=n){
			c[x]+=k;x+=x&-x;
		}
	}
	int ask(int x){
		int ans=0;
		while(x){
			ans+=c[x];x-=x&-x;
		}
		return ans;
	}
	int query(int l,int r){
		return ask(r)-ask(l-1);
	}
}A;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m; 
	for(int i=1;i<=n;++i){
		int x;
		cin>>x,a[i]={0,0,x,i};
	}
	for(int i=1;i<=m;++i){
		int l,r,x;cin>>l>>r>>x;q[i]={l,r,x,i};
	}
	sort(a+1,a+n+1,cmp);sort(q+1,q+m+1,cmp);
	int now=1;
	for(int i=1;i<=m;++i){
		while(a[now].x<=q[i].x&&now<=n)A.add(a[now].id,1),++now;
		ans[q[i].id]=A.query(q[i].l,q[i].r);
	}
	for(int i=1;i<=m;++i)cout<<ans[i]<<'\n';
	return 0;
}

```

---

## 作者：zyn_ (赞：4)

二维数点板子。

给定长为 $n$ 的序列 $\{a_i\}$，$m$ 次询问 $a_l$ 至 $a_r$ 中不超过 $x$ 的数的个数。允许离线。数据范围在 $10^6$ 量级。

显然时间复杂度至多 $O(n\log n)$。既然可以离线，考虑将询问按 $x$ 从小到大排序。

维护初始全为 $0$ 的序列 $\{c_i\}$，将 $\{a_i\}$ 按数值从小到大遍历，遍历 $a_i$ 时将 $c_i$ 设为 $1$。在遍历完所有 $\le x_0$ 的 $a_i$ 时处理 $x=x_0$ 的询问，询问的答案就是 $\sum_{i=l}^r c_i$。

开一个结构体 `struct{int id,l,r,x;}` 存储 $a_i$ 的遍历与询问的信息。具体地，对于 $a_i$ 的遍历，$id=i$，$l=r=-1$，$x=a_i$；对于询问，$l,r,x$ 就是原本的意思，$id$ 表示这是第几个询问。

按照 $x$ 的大小将这 $n+m$ 个结构体排序（注意：**$x$ 相同时，$a_i$ 的遍历应当排在询问前**）。然后遍历结构体，依次处理即可。需要维护单点加，区间和，用树状数组即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2000009
int n,m,x[N],ans[N];
struct apple{int id,l,r,x;}y[N<<1];
inline bool cmp(const apple&a,const apple&b){return a.x==b.x?a.l<b.l:a.x<b.x;}
void upd(int p,int d){for(;p<=n;p+=p&-p)x[p]+=d;}
int qr(int p){static int r;r=0;for(;p;p-=p&-p)r+=x[p];return r;}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&y[i].x),y[i].id=i,y[i].l=y[i].r=-1;
	for(int i=1;i<=m;++i)scanf("%d%d%d",&y[i+n].l,&y[i+n].r,&y[i+n].x),y[i+n].id=i;
	sort(y+1,y+n+m+1,cmp);
	for(int i=1;i<=n+m;++i){
		if(y[i].l==-1)upd(y[i].id,1);
		else ans[y[i].id]=qr(y[i].r)-qr(y[i].l-1);
	}
	for(int i=1;i<=m;++i)printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：3)

第一次写【模版】开头的题解。

# 思路分析

因为询问对左右边界都有限制，所以直接解决询问比较困难，如果用主席树之类的数据结构时间又太慢。

注意到询问是可差分的，具体的说，记 $a$ 为 区间 $[1,r]$ 内小于等于 $x$ 的数的个数，$b$ 为区间 $[1,l-1]$ 内小于等于 $x$ 的数的个数（如果 $l=1$ 则默认为 $0$）。则询问的答案即为 $a-b$。

这样做就把一个询问转化成了两个只对右边界有限制的询问。先将询问按照其限制的右边界排序，同时用树状数组维护值域，用一个指针 $it$ 从左扫到右，依次处理这些询问，最后再统计在一起。

时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$，可以通过本题。

# Code：


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=2e6+10;
inline void read(int &a){//快读
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return a=x*f,void();
}
struct node{
	int id,x,val,op;
}q[2*N];//询问
bool cmp(node a,node b){
	return a.x<b.x;
}
int n,m,a[N],ans[N],it,c[N],w;
inline void add(int x){//树状数组点修
	for(;x<=w;x+=(x&-x))c[x]++;
	return;
}
inline int ask(int x){//树状数组区查
	int cnt=0;
	for(;x>0;x-=(x&-x))cnt+=c[x];
	return cnt; 
}
int main(){
	read(n),read(m);
	for(int i=1;i<=n;i++){
		read(a[i]);w=max(w,a[i]);//值域上界
	}
	for(int i=1,l,r,v;i<=m;i++){
		read(l),read(r),read(v);
		q[2*i-1]=node{i,l-1,v,-1};
		q[2*i]=node{i,r,v,1};
	}
	sort(q+1,q+1+2*m,cmp);//排序
	m*=2;
	for(int i=1;i<=m;i++){
		while(it<q[i].x)add(a[++it]);
		ans[q[i].id]+=q[i].op*ask(q[i].val);
	}
	for(int i=1;i*2<=m;i++)printf("%d\n",ans[i]);
	return 0;
}
```

如有错误，请指出。

---

## 作者：__O_v_O__ (赞：3)

首先，一个区间询问可以转化为两个前缀询问相减，则我们把询问 $[l,r]$ 中 $x$ 的个数拆分为询问 $[1,r]$ 中 $x$ 的个数减去 $[1,l-1]$ 中 $x$ 的个数。

把所有拆分后的询问离线，使用一个 `vector` 存储每一个位置上（即右端点为该位置）的询问。

然后，从小到大枚举每个位置 $i$，先把 $a_i$ 加入树状数组，然后处理这个位置上的所有询问。对于一个查询 $x$ 的个数的询问，只需在树状数组上查询 $x$ 的前缀和即可。

注意，因为询问拆分后有加的有减的，所以我们对于离线的每个询问还要存一个加减标记，统计答案时需乘上这个标记。

**AC code:**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lb(x) x&(-x)
int n,a[5000001],c[5000001];
int nu,an[5000001],m;
struct Q{int r,x,fl,id;}q[5000001];//r是右端点，x是查询数，fl是加减标记，id是询问编号
vector<int>vec[5000001];
void ad(int x,int v){//树状数组模板
	while(x<=n)c[x]+=v,x+=lb(x);
}
int qr(int x){
	int an=0;
	while(x)an+=c[x],x-=lb(x);
	return an;
}
signed main(){
	ios::sync_with_stdio(0),cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++){
		int l,r,x;cin>>l>>r>>x;
		q[++nu]={r,x,1,i};//存询问
		q[++nu]={l-1,x,-1,i};
		vec[l-1].push_back(nu);//记录每个位置上的询问
		vec[r].push_back(nu-1);
	}
	for(int i=1;i<=n;i++){
		ad(a[i],1);//加入a[i]
		for(int j=0;j<vec[i].size();j++){//遍历这个位置的询问
			Q nw=q[vec[i][j]];//当前询问
			an[nw.id]+=nw.fl*qr(nw.x);//注意要乘上fl
		}
	}
	for(int i=1;i<=m;i++)
		cout<<an[i]<<'\n';
	return 0;
}
```

---

## 作者：kevinZ99 (赞：2)

# 题意
都读的懂吧

# 思路
很明显将询问离线，然后将询问的 $x$ 排序，然后将 $a$，数组排序，每一次询问将小于 $x$ 的数的位置标成 1 ，然后求一下区间和就行了。

# 代码


```cpp
//Author:Kevin Z K Y
#include <bits/stdc++.h>
#define up(a,b,c) for(int (a)=(b);(a)<=(c);(a)++)
#define dn(a,b,c) for(int (a)=(b);(a)>=(c);(a)--)
#define fst first
#define sed second
using namespace std;
using ll = long long ;
using pii = pair<int,int> ;using pll = pair<ll,ll> ;
using vi = vector<int> ;using vl = vector<ll> ;
using vpi = vector<pii> ;using vpl = vector<pll> ;
using db = double ;namespace mystl{
	#define gc() getchar()
	ll qpow(ll a,ll b,const ll&p){if (a==0ll) return 0ll; ll c=1ll;
		while(b) { if(b & 1) c=a*c%p; a=a*a%p; b>>=1; } return c; }
	template<typename T>void read(T&x) {x=0; bool f=false; char ch;
		ch = gc(); while(ch<'0'||ch>'9') f |= ( ch=='-') , ch=gc();
		while(ch>='0'&&ch<='9') x=x*10+ch-'0' , ch=gc(); x=f?-x:x;}
	template<typename T>void write(T x){char s[40];short d=0;T y=x;
		if(x<0) putchar('-'),y=-y;if(x==0){ putchar('0'); return; }
		while(y){s[++d]=y%10+'0';y/=10;}while(d>0)putchar(s[d--]);}
	template<typename T>void wris(T x,char c){write(x);putchar(c);}
}using namespace mystl;
namespace my{
	const int N=2000005;
	int n,m;
	struct question{
		int l,r,x,id;
	};
	bool cmp(question x,question y){
		return x.x<y.x;
	}
	vector<question> q;
	int ans[N];
	struct node{
		int x,id;
	}a[N];
	bool cmpd(node x,node y){
		return x.x<y.x;
	}
	int c[N];
	void add(int x,int y){for(;x<=n;x+=x&-x)c[x]+=y;}
	int ask(int x){int y=0;for(;x;x=x-=x&(-x))y+=c[x];return y;}
	void solve(){
		cin>>n>>m;
		up(i,1,n)cin>>a[i].x,a[i].id=i;
		sort(a+1,a+1+n,cmpd);
		up(i,1,m){
			int l,r,x;cin>>l>>r>>x;
			q.emplace_back((question){l,r,x,i});
		}
		sort(q.begin(),q.end(),cmp);
		int idx=1;
		up(i,0,m-1){
			while(a[idx].x<=q[i].x&&idx<=n){
				add(a[idx].id,1);
				idx++;
			}
//			cout<<q[i].l<<' '<<q[i].r<<' '<<q[i].x<<"\n";
			ans[q[i].id]=ask(q[i].r)-ask(q[i].l-1);
		}up(i,1,m)cout<<ans[i]<<'\n';
	}
}
int main(){
//  freopen("","r",stdin);
//  freopen("","w",stdout);
	ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	int _=1;while(_--)my::solve();return 0;
}

```

---

## 作者：Dazlin7 (赞：1)

### 思路

这个问题一个典型的二维数点问题，其中数组元素的值和索引可以看作是二维平面上的点，查询要求在给定范围内统计满足条件的点个数。我们可以使用离线处理的方式，通过扫描线和树状数组相结合的方法来实现。

我们将所有的查询和数组离线下来，然后通过扫描线方法将静态的二维问题转换为动态的一维问题，再利用树状数组进行维护和查询。的核心思想是：通过扫描线处理，我们可以按照某个维度（在这里是 $x$ 值）进行排序和处理，从而将二维问题转化为一维问题。

排序复杂度为 $O((n + m) \log (n + m))$，更新查询复杂度为 $O(\log n)$，总时间复杂度为 $O((n + m) \log (n + m))$
### 代码


```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 2000005; 
int n, m, bit[N]; // 分别表示数组长度，查询次数，树状数组
struct Event {
    int x, l, r, type, idx; 
};

vector<Event> G;
int res[N]; 

// 树状数组更新
void add(int i, int v) {
    while (i < N) {
        bit[i] += v;
        i += i & -i;
    }
}

// 树状数组查询
int sum(int i) {
    int s = 0;
    while (i > 0) {
        s += bit[i];
        i -= i & -i; 
    }
    return s;
}

int main() {
    ios::sync_with_stdio(false); 
    cin.tie(0);

    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        int a;
        cin >> a;
        G.push_back({a, i, 0, 1, 0}); 
    }

    for (int i = 1; i <= m; ++i) {
        int l, r, x;
        cin >> l >> r >> x;
        G.push_back({x, l, r, 2, i});
    }

    // 对按x值排序
    sort(G.begin(), G.end(), [](const Event &a, const Event &b) {
        if (a.x == b.x) return a.type < b.type;
        return a.x < b.x;
    });

    for (auto &e : G) {
        if (e.type == 1) {
            add(e.l, 1);
        } else if (e.type == 2) { 
            res[e.idx] = sum(e.r) - sum(e.l - 1); // 前缀和
        }
    }
    for (int i = 1; i <= m; ++i) {
        cout << res[i] << endl;
    }
    return 0;
}

```

---

## 作者：Genius_Star (赞：1)

### 思路：

考虑离线~毕竟标题提示的那么明显~。

首先一个询问 $[l,r]$ 可以拆为 $[1,r]-[1,l-1]$。

那么现在我们只需要处理一个前缀小于 $x$ 的数量。

考虑扫描线右端点，使用树状数组维护在前缀范围的数的个数即可。

时间复杂度为 $O((N+Q) \log W)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=2e6+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,q,t;
ll a[N],h[N],ans[N];
vector<iip> Q[N];
void add(ll x){
	for(int i=x;i<=t;i+=lowbit(i))
	  h[i]++;
}
ll query(ll x){
	ll ans=0;
	for(int i=x;i;i-=lowbit(i))
	  ans+=h[i];
	return ans;
}
bool End;
int main(){
	n=read(),q=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		t=max(t,a[i]);
	}
	for(int l,r,x,i=1;i<=q;i++){
		l=read(),r=read(),x=read();
		Q[l-1].push_back({{-1,i},x});
		Q[r].push_back({{1,i},x});
	}
	for(int i=1;i<=n;i++){
		add(a[i]);
		for(auto t:Q[i])
		  ans[t.fi.se]+=t.fi.fi*query(t.se);
	}
	for(int i=1;i<=q;i++){
		write(ans[i]);
		putchar('\n');
	}
	cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB";
	return 0;
}
```

---

## 作者：qhr2023 (赞：0)

## 闲话

除出题人外第一个 AC，写一篇题解庆祝。

## solution

二维数点问题，我们离线下来，用扫描线加树状数组实现。

很显然，这个是一个静态的二维问题，我们通过扫描线可以将静态的二维问题转换为动态的一维问题。维护动态的一维问题，这里可以使用树状数组。

先将所有的询问离线，按 $x$ 升序查询，套个树状数组模版维护权值，没学过见这里，[树状数组模版](https://www.luogu.com.cn/problem/P3374)。

注意这里要先修改再求答案。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int n, m, ans[N], t[N];
struct node {
	int l, r, t;
} ;
vector<int> data[N];
vector<node> q[N];
void modify (int x) {
	for ( ; x<=N; x+=x&-x)
		t[x]++;
}
int find (int x) {
	int ans=0;
	for (int i=x; i; i-=i&-i)
		ans+=t[i];
	return ans;
}
int main () {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	for (int i=1, x; i<=n; i++) 
		cin >> x,
		data[x].push_back(i);
	for (int i=1, l, r, t; i<=m; i++) 
		cin >> l >> r >> t,
		q[t].push_back({l, r, i});
	for (int i=1; i<=2000000; i++) {
		for (auto j:data[i])
			modify(j);
		for (auto j:q[i])
			ans[j.t]=find(j.r)-find(j.l-1);
	}
	for (int i=1; i<=m; i++)
		cout << ans[i] << '\n';
	return 0;
}
```

---

## 作者：_7thRC_CB_CRP_ (赞：0)

## 题解

首先我们会想到主席树，但是就会发现很有问题。

那么我们想用主席树维护的是每个位置的值，相似的我们会想到维护每个值的位置。那么之前我们枚举位置的先后，那我们现在枚举值的先后。我们就离线排序，并用树状数组记录位置。然后只需要让值满足条件后，在用树状数组找这些里面多少在区间内。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int id,val;
}a[2000011];
struct que{
	int id,l,r,x;
}q[2000011];
bool cmpa(node&a,node&b) {
	return a.val<b.val;
}
bool cmpq(que&a,que&b) {
	return a.x<b.x; 
}
int ans[2000011];
int tr[2000011];
int lowbit(int x) {
	return x&(-x);
}
void add(int n) {
	while(n<=2000000) {
		tr[n]++;
		n+=lowbit(n); 
	}
}
int ask(int n) {
	if(n==0)
		return 0;
	int res=0;
	while(n) {
		res+=tr[n];
		n-=lowbit(n);
	}
	return res;
}
int main() {
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i].val,a[i].id=i;
	for(int i=1;i<=m;i++)
		cin>>q[i].l>>q[i].r>>q[i].x,q[i].id=i;
	sort(a+1,a+1+n,cmpa);
	sort(q+1,q+1+m,cmpq);
	long long cnt=1;
	for(int i=1;i<=m;i++) {
		while(a[cnt].val<=q[i].x&&cnt<=n) {
			add(a[cnt].id);
			cnt++;
		}
		ans[q[i].id]=ask(q[i].r)-ask(q[i].l-1);
	} 
	for(int i=1;i<=m;i++)
		cout<<ans[i]<<'\n';
}
```

---


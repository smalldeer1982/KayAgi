# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# 题解

## 作者：decoqwq (赞：720)

$vector$轻松水过

或成此题最短代码？

首先介绍一下$STL$容器$vector$

$vector$基本操作：

$vc.push\_back()$在$vector$末尾插入一个数据

$vc.insert()$在$vecter$中插入一个元素

$vc.erase()$在$vector$中删除一个元素

$vc.at()$在$vector$中获取某个元素($vc[a]$等价于$vc.at(i)$)

因为每次插入后排序时间代价太大，则插入采用$lower\_bound$来二分大于等于该数的数的指针，使得每次插入完都是已经排好序

然后每次插入后，直接输出当前容器内第$\frac{size()-1}{2}$项即可($vector$是从第$0$项开始存储的)

好了，上代码
```
#include <bits/stdc++.h>
using namespace std;
int n;
vector<int>a;
int main()
{
    cin>>n;
    for(int i=1,x;i<=n;i++)
    {
        scanf("%d",&x);
        a.insert(upper_bound(a.begin(),a.end(),x),x);//二分插入保证单调性
        if(i%2==1)
        {
        	printf("%d\n",a[(i-1)/2]);//是奇数个就输出
        }
    }
    return 0;
}
```

---

## 作者：肖恩Sean (赞：527)

使用两个堆，大根堆维护较小的值，小根堆维护较大的值

即小根堆的堆顶是较大的数中最小的，大根堆的堆顶是较小的数中最大的

将大于大根堆堆顶的数（比所有大根堆中的元素都大）的数放入小根堆，小于等于大根堆堆顶的数（比所有小根堆中的元素都小）的数放入大根堆

那么就保证了所有大根堆中的元素都小于小根堆中的元素

于是我们发现对于大根堆的堆顶元素，有【小根堆的元素个数】个元素比该元素大，【大根堆的元素个数-1】个元素比该元素小；

同理，对于小跟堆的堆顶元素，有【大根堆的元素个数】个元素比该元素小，【小根堆的元素个数-1】个元素比该元素大；

那么维护【大根堆的元素个数】和【小根堆的元素个数】差值不大于1之后，元素个数较多的堆的堆顶元素即为当前中位数；（如果元素个数相同，那么就是两个堆堆顶元素的平均数，本题不会出现这种情况）

根据这两个堆的定义，维护方式也很简单，把元素个数多的堆的堆顶元素取出，放入元素个数少的堆即可

对于部分不会堆的同学，请参照下面各位神犇的算法，或者自行学习堆

下面是代码实现，使用了STL的优先队列作为堆，经过压行仅有24行代码，可读性可能比较低，如果觉得阅读困难可以参照下面各位神犇的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){//读入优化
	int x=0;bool f=0;char c=getchar();
	while (c<'0'||c>'9'){if (c=='-')f=1;c=getchar();}
	while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return f?-x:x;
}
priority_queue<int,vector<int> > q1;//大根堆
priority_queue<int,vector<int>,greater<int> > q2;//小根堆
int main(){
	int n=read();q1.push(read());
	cout<<q1.top()<<endl; 
	for (int i=2;i<=n;i++){
		int input=read();//等同于cin>>input
		if (input>q1.top()) q2.push(input);
			else q1.push(input);
		while (abs(q1.size()-q2.size())>1)
			if (q1.size()>q2.size()){q2.push(q1.top());q1.pop();}
				else{q1.push(q2.top());q2.pop();}
		if (i%2) cout<<(q1.size()>q2.size()?q1.top():q2.top())<<endl;
	}
	return 0;
}
```

---

## 作者：IRipple (赞：365)

因为~~自认为~~比题解第一篇好理解一点~~（可能没有）~~ 所以就敲了一篇简单的题解w

首先记录一个变量$mid$，记录答案（中位数）。建立两个堆，一个大根堆一个小根堆，大根堆存$≤mid$的数，小根堆存 $>mid$的的数。

所以我们向堆中加入元素时，就通过与$mid$的比较，选择加入哪一个堆
```
scanf("%d",&a[i]);
if(a[i]>mid) q2.push(a[i]);
else q1.push(a[i]);
```
显然，小根堆的堆顶是第一个大于$mid$的数，大根堆堆顶是第一个小于等于$mid$的数字。
![](https://i.loli.net/2019/02/13/5c63c5bf7fe93.png)

但我们在输出答案前需要对$mid$进行调整，如果**小根堆和大根堆内元素相同**，就无需处理，此时$mid$仍然是当前的中位数。

如果两个堆中元素个数不同，那我们就需要进行调整。
![无标题.png](https://i.loli.net/2019/02/13/5c63c6b654bbe.png)

**具体是把元素个数较多的堆的堆顶作为$mid$，$mid$加入元素较少的堆。**

![无标题.png](https://i.loli.net/2019/02/13/5c63c8350d450.png)

代码如下：
```
if(q1.size()>q2.size()){
	q2.push(mid);
	mid=q1.top();
	q1.pop();
}
```
同理，如果q2中元素比q1多，同理转移。

最后，在奇数个元素加入时输出此时的中位数$mid$即可。

完整代码如下
```
#include<bits/stdc++.h>
#include<queue>
using namespace std;
int n;
int a[100100];
int mid;
priority_queue<int,vector<int>,less<int> >q1;//大根堆
priority_queue<int,vector<int>,greater<int> >q2;//小根堆
int main(){
    cin>>n;
    scanf("%d",&a[1]);
    mid=a[1];
    cout<<mid<<endl;//mid初值是a[1]
    for(int i=2;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i]>mid) q2.push(a[i]);
        else q1.push(a[i]);
        if(i%2==1){//第奇数次加入
            while(q1.size()!=q2.size()){
                if(q1.size()>q2.size()){
                    q2.push(mid);
                    mid=q1.top();
                    q1.pop();
                }
                else{
                    q1.push(mid);
                    mid=q2.top();
                    q2.pop();
                }
            }
            cout<<mid<<endl;
        }
    }
    return 0;
}
```





---

## 作者：ysj1173886760 (赞：113)

这道题看各路dalao各显神通，对顶堆的思路十分不错，类似的一道题是P1801黑匣子。

但是我是按照树状数组的标签找过来了的...所以说标签害死人。

于是我就用树状数组做了。

这里给出树状数组的思路，其实完全类比权值线段树

那么好处就是常数小，好调试，而且写起来十分方便。。。劣势的话就是不能很有效的维护不满足区间减法的信息？

找前2k-1个数的中位数就是找第k小。同时我们还看到权值较大


于是我们的思路就很明确了，先离散化，然后权值bit找kth就行了

由于树状数组本身的结构就可以看成二级制拆分，（天然的倍增结构），我们倍增查询第k小就可以了。。

上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

int n,tot;
const int maxn=1e5+10;
int bit[maxn];
int a[maxn],b[maxn];

inline int lowbit(int x)
{
	return x&-x;
}
inline void add(int pos,int x)
{
	for(int i=pos;i<=tot;i+=lowbit(i))bit[i]+=x;
}
inline int find_kth(int k)
{
	int ans=0,now=0;				//这里主要解释一下这个的原理 ans就是答案，now是比当前找到的数的小的数字的个数。 
	for(int i=20;i>=0;i--)			//2^20可以说很大了，满足我们的需求了，我们按照20倍增就可以 
	{
		ans+=(1<<i);			//先让答案加上去，试试 
		if(ans>tot||now+bit[ans]>=k)ans-=(1<<i);//如果超了总体的最大值（防止数组越界），或者是 超过了k个，就退回去，这里注意是大于等于，因为要考虑有重复元素，所以我们找的其实是一个满足小于他的个数小于k的最大数。。（可能不好理解，跑两遍样例就行了） 
		else now+=bit[ans];//能加就加上，这里不用怕加到了原来的数，因为树状数组的结构使这个新倍增出来的数就是多出来的那一条枝 
	}
	return ans+1;//然后加上1就是答案啦 
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[++tot]);		//读个入 
		b[tot]=a[tot];
	}
	sort(a+1,a+1+n);				//排个序 
	tot=unique(a+1,a+1+tot)-a-1;	//去个重 
	for(int i=1;i<=n;i++)b[i]=lower_bound(a+1,a+1+tot,b[i])-a;//离散化一下 
	for(int i=1;i<=n;i++)
	{
		add(b[i],1);			//动态加点 
		if(i&1)printf("%d\n",a[find_kth((i+1)>>1)]);//查kth 
	}
	return 0;
}

```

---

## 作者：婷菡 (赞：47)

#### 题目链接——[中位数](https://www.luogu.org/problemnew/show/P1168)
——对于这道题，我们可以在每次输入奇数个整数时用sort函数进行一次快排。然后输出中间的数。

——于是 代码如下
```
#include<bits/stdc++.h>
using namespace std;
int n,a[100001];
int main(){
	scanf("%d",&n);//输入n；
	for(int i=1;i<=n;i++){
		cin>>a[i];//输入非负整数Ai
		if(i==1)printf("%d\n",a[i]);//第1个数直接输出
		if(i!=1&&i%2==1){
			sort(a+1,a+i+1);快排
			printf("%d\n",a[(1+i)/2]);//输出中位数
		}
	}return 0;//结束
}
```

——~~这样这道题就完美的结束了~~。

——开个玩笑，这样写只能过40%的数据。而对于100%的数据，我们肯定是要进行优化的。

——而对于这道题我们可以用**对顶堆**来实现。

——**对顶堆，顾名思义，就是建立一个大根堆和一个小根堆**。

——形象的解释![坟头对撞](https://i.loli.net/2019/06/25/5d11f067496d176042.jpg)

——这道题主要做法就是先来一个**大根堆**和一个**小根堆**，而对于一个序列，我们把**大数**放在**小根堆里**，**小数**放在**大根堆**里，并且维护一个状态：
```
当序列的长度为奇数时，
——保证小根堆的深度等于大根堆的深度加一。
当序列的长度为偶数时，
——保证小根堆的深度等于大根堆的深度。
```
——这样我们发现对于一个序列，小根堆里的是比其堆顶大的一部分数，大根堆里的是比小根堆的堆顶小的一部分数。
——我们很容易发现，当序列的长度为奇数时，小根堆的堆顶就是序列的中位数

——说完了思想，接下来是代码实现

——首先是**建堆**，这里我们可以用C++自带的STL库中的**poriority_queue**来实现，当然手打堆也是可以的不过我懒得打了。

——建堆
```
priority_queue<int> x;//小根堆
priority_queue<int> d;//大根堆
```
——值得注意的是，**priority_queue**只能维护一个大根堆，要实现小根堆，就需要再放入堆中时乘以个负一，将其变为负数，取出时再乘回来，这样就能
实现一个小根堆

——~~其实是因为我不会重载运算符之类的实现小根堆的方法，所以只能这样做~~

——接下来是代码实现

—— 首先，对于i为偶数时，由于i-1为奇数，所以对于长度为i-1的序列 **lx==ln+1**，因此我们需要将一个数放入大根堆内来保证此时 **lx==ln**

```
——若此时Ai比小根堆的堆顶要小，说明Ai比小根堆内所有元素都要小，这时我们便可以直接将Ai放入大根堆内：

——而如果Ai比小根堆的堆顶要大的话，我们要将小根堆的堆顶取出放入大根堆内，Ai放入小根堆内才能保证小根堆内所有元素都比大根堆内的所有元素大
```
——i为奇数时同理。

——下面才是代码实现

```
#include<bits/stdc++.h>//万能的头文件
using namespace std;
priority_queue<int> x;//小根堆
priority_queue<int> d;//大根堆
int p,k,m,a,z[10001];
int main(){
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
            cin>>a;
            if(i==1){
            x.push(-1*a);//将第一个数放入小根堆
            cout<<-1*x.top()<<endl;//输出
            }
            if(i>1&&i%2==0)//如果i为偶数
            {
            int c=x.top();
                if(a<=-1*c)//Ai比小根堆堆顶小
                d.push(a);//直接插入大根堆
                else//Ai比小根堆堆顶大
                {
                x.pop();x.push(-1*a);d.push(-1*c);//小根堆堆顶放入大根堆，Ai放入小根堆
                }
            }if(i>1&&i%2==1)//如果i为奇数
            {
            int c=d.top();
                if(a>=c)//Ai比大根堆的堆顶大
                x.push(-1*a);//直接插入小根堆
                else//Ai比大根堆的堆顶小
                {
                d.pop();d.push(a);x.push(-1*c);//大根堆的堆顶放入小根堆，Ai放入大根堆
                }
                printf("%d\n",-1*x.top());//i为奇数时输出中位数
            }
    }
    return 0;//结束
}
```

---

## 作者：Drifterming (赞：41)

/\*
将a数组去重后存在b数组里，用b数组的大小建树。

用树的l作为数字，num记录这个数出现的次数，

则 更新时，找到a在b数组中的位置，让此位置的数++，表示这个数出现了一次

查询的时候，输出第i/2+1个数，则让x=i/2+1，

如果root的左儿子的num>=x，则说明要找的数在左子树里，否则在右子树里，

如果是去右子树里找，则让x-=tree[root<<1].num，因为我们在右子树里要找的是第x-=tree[root<<1].num个。

\*/







```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+5;
int n;
int a[N],b[N];
struct Tree
{
    int l,r,mid;
    int num;
}tree[N<<2];
int read()
{
    char c=getchar();int num=0;
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())
        num=num*10+c-'0';
    return num;
}
void build(int root,int l,int r)
{
    tree[root].l=l,tree[root].r=r,tree[root].mid=l+r>>1;
    if(l==r)
        return;
    build(root<<1,l,tree[root].mid);
    build(root<<1|1,tree[root].mid+1,r);
}
void update(int root,int x)
{
    ++tree[root].num;
    if(tree[root].l==tree[root].r)
        return;
    if(x<=tree[root].mid)
        update(root<<1,x);
    else
        update(root<<1|1,x);
}
int query(int root,int num)
{
    if(tree[root].l==tree[root].r)
        return tree[root].l;
    if(num<=tree[root<<1].num)
        return(query(root<<1,num));
    else
        return(query(root<<1|1,num-tree[root<<1].num));
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
        a[i]=read(),b[i]=a[i];
    sort(b+1,b+n+1);
    int bound=unique(b+1,b+n+1)-b;
    build(1,1,n);
    for(int i=1;i<=n;++i)
    {
        int pos=lower_bound(b+1,b+bound+1,a[i])-b;
        update(1,pos);
        if(i%2)
            printf("%d\n",b[query(1,i/2+1)]);
    }
    return 0;
}
```

---

## 作者：lonely_log (赞：34)

# 权值树状数组+二分查找+离散化

### **C++**

1.部分分的想法，就是用类似通排的方法，用一个数组k，每次在k[a[i]]和k[a[i-1]]加1，然后从下标1开始往后扫，当扫到的数的个数是序列的“中位数”就输出。（当然因为a[i]太大而且最多100000个数所以我们要离散一下）

2.这种想法可以改一下，就是用一个前缀和+二分查找（前缀和数组sum），sum[i]表式小于等于i的数有多少个。二分时当sum[mid]大于等于(想一想为什么要等于）“中位数”，上界缩小。反之，下界缩小。因为k[a[i]]不是一次性加完（就是在线），所以前缀和数组每次都要更改，很费时间。

3.诶！！前缀和数组要更改！不就是线段树或树状数组吗！我们可以将前缀和数组更改的部分换成树状数组（这里只需要单点修改和区间查询，所以树状数组就够了）。

于是我们就十分愉快地得出了正解！！！

如果不是很理解“中位数”可以看一下代码


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<math>
#include<cstring>
using namespace std;
const int N=100005;
struct asd
{
	int id,val;
}z[N];
bool cmp(asd a,asd b)
{
	return a.val<b.val;
}
int a[N],b[N],c[N],n;
int lowbit(int x)
{
	return x&(-x);
}
void add(int x,int val)//单点修改 
{
	while(x<=n)
	{
		c[x]+=val;
		x+=lowbit(x);
	}
}
int getsum(int x)//区间查询 
{
	int s=0;
	while(x)
	{
		s+=c[x];
		x-=lowbit(x);
	}
	return s;
}
int Find(int x)//二分查找
{
	int l=1,r=n,mid;
	while(l<=r)
	{
		mid=(l+r)>>1;//这个写法等价于mid=(l+r)/2，老师说用位运算比较有逼格 :D
		int s=getsum(mid);//小于等于mid的数的个数 
		if(s>=x/2+1)r=mid-1;//个数大于等于“中位数”，上界缩小（x是要求中位数的序列的长度） 
		else l=mid+1;//反之，下界缩小 
	}
	return b[l];
}
void Disc()//离散化 
{
	sort(z+1,z+n+1,cmp);//按照值的大小排序，相等也无所谓 
	for(int i=1;i<=n;i++)
	{
		a[z[i].id]=i;//z[i].id是这个数在未排序的序列中的编号，用i替换原来的值 
		b[i]=z[i].val;//b[i]表示的是离散后的数值为i的数的真实值 
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&z[i].val);
		z[i].id=i;
	}
	Disc(); //离散化 
	cout<<b[a[1]]<<endl;
	add(a[1],1);
	for(int i=3;i<=n;i+=2)
	{
		add(a[i],1);//在a[i]位加一 
		add(a[i-1],1);//在a[i-1]位加一
		printf("%d\n",Find(i));//二分查找 
	}
	return 0;
}
```

# **Hope you enjoy!**

## ~~人如其名~~

---

## 作者：小黑AWM (赞：24)

> **这么有趣的一道链表思路题，你谷真的没有人写链表吗（翻了全部8页题解未见链表）？？？对顶堆是多么的枯燥乏味** 

> *"使用链表来解此题有在线和离线两种算法，本文主要介绍离线算法，不过会用一句话来介绍在线算法。"*

### 在线算法
***
利用本题的特殊性，我们通过使用块状链表，对于每一个新插入的数二分后插入然后每次返回位置在中间的元素，将块大小设置为 $nlog_2n$ 即可实现 $O(n\sqrt{nlog_2n})$ 的复杂度，应该是没错了。


### 离线算法
***
相较于平衡树，对顶堆，分块的暴力，离线的做法更能体现出一种思维的美感。我们通过预先将所有的数字存储，标记其在原数组中的位置，然后将一个与原数组相同的数组排序，构建一个 $A_n\rightarrow POS_n$ 的一一映射，其中 $A_n$ 表示原序列中的第 $n$ 个元素，而 $POS_n$ 表示原序列中第 $n$ 个元素在排序后的序列 $\{B_n\}$ 中的位置，将 $\{B_n\}$ 按照排序后的顺序连成链表，即从链头至结尾元素大小单调递增。所以 $POS_n$ 就是 $A_n$ 在链表中的节点标号。

然后我们倒序做，原数列中每添加一个元素我们就把这个元素从链表中删去，而且如果这个元素在链表中在中位数的元素的左边那么就把中位数的指针往右移，如果在右边就往左移，保证有一个指针始终指向中位数所在的链表的节点。

code: 代码因为有读优+模板的原因略长，直接从using namespace IO;之后看起即可

```cpp
//It's supposed to die.
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<ctime>
#include<utility>
#include<functional>
#include<cmath>
#include<vector>
#include<assert.h>
using namespace std;
#define reg register
#define endfile fclose(stdin);fclose(stdout);
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef std::pair<int,int> pii;
typedef std::pair<ll,ll> pll;
namespace IO{
    char buf[1<<15],*S,*T;
    inline char gc(){
        if (S==T){
            T=(S=buf)+fread(buf,1,1<<15,stdin);
            if (S==T)return EOF;
        }
        return *S++;
    }
    inline int read(){
        reg int x;reg bool f;reg char c;
        for(f=0;(c=gc())<'0'||c>'9';f=c=='-');
        for(x=c^'0';(c=gc())>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^'0'));
        return f?-x:x;
    }
    inline ll readll(){
        reg ll x;reg bool f;reg char c;
        for(f=0;(c=gc())<'0'||c>'9';f=c=='-');
        for(x=c^'0';(c=gc())>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^'0'));
        return f?-x:x;
    }
}
using namespace IO;
const int maxn = 1e6 + 10;
int n, a[maxn], pos[maxn], mid, mov, cnt, ans[maxn];
pii b[maxn];
struct Node{
    int pre, nxt, val;
} List[maxn];
void insert(int node, int val){
    List[++cnt].val = val;
    List[cnt].pre = node;
    List[cnt].nxt = List[node].nxt;
    List[List[node].nxt].pre = cnt;
    List[node].nxt = cnt;
}
void erase(int node){
    List[List[node].pre].nxt = List[node].nxt;
    List[List[node].nxt].pre = List[node].pre;
}
bool cmp(pii u, pii v){
    if(u.first == v.first)
        return u.second < v.second;
    return u.first < v.first;
}
int main(){
    n = read();
    if(!(n & 1))
        n--;
    mid = (n+1) >> 1;
    for(int i = 1; i <= n ; i++)
        b[i].first = a[i] = read(), b[i].second = i;
    sort(b+1, b+1+n, cmp);
    for(int i = 1; i <= n; i++){
        insert(cnt, b[i].first);
        pos[b[i].second] = cnt;
    }
    for(int i = n; i >= 1; i--){
        if(i & 1){
            if(mov > 0)
                mid = List[mid].nxt;
            if(mov < 0)
                mid = List[mid].pre;
            mov = 0;
            ans[i] = List[mid].val;
        }
        if(pos[i] < mid)
            mov++;
        if(pos[i] > mid)
            mov--;
        erase(pos[i]);
    }
    for(int i = 1; i <= n; i++)
        if(i & 1)
            cout << ans[i] << endl;
    return 0;
}

```


---

## 作者：静默之光 (赞：24)

本来觉得方法挺奇特的，没想到居然和楼下大佬思路差不多，不过我比较懒直接用的stl里的queue

建立两个queue，分别时从小到大和从大到小（命名为que1，que2），首先que1中有一个数a[1]，que2为空。

然后每次进来两个数，小的给que1，大的给que2，然后如果que1最大的数比que2最小的数大了就替换他们俩。

因为只进来两个数，所以最多更换一次，保证了复杂度为O（nlgn）

代码挺丑的勿喷……


···cpp

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
struct cmp1
{
    bool operator () (int &a,int &b)
    {
        return a<b;
    }
};
struct cmp2
{
    bool operator () (int &a,int &b)
    {
        return a>b;
    }
};
int n,x,y;
int main()
{
    priority_queue<int,vector<int>,cmp1>que1;
    priority_queue<int,vector<int>,cmp2>que2;
    scanf("%d",&n);
    scanf("%d",&x);
    que1.push(x);
    printf("%d\n",x);
    for(int i=3;i<=n;i+=2)
    {
        scanf("%d%d",&x,&y);
        if(x>y)
        {
            int t=x;x=y;y=t;
        }
        que1.push(x);
        que2.push(y);
        if(que1.top()>que2.top())
        {
            int a=que1.top(),b=que2.top();
            que1.pop();
            que1.push(b);
            que2.pop();
            que2.push(a);
        }
        printf("%d\n",que1.top());
    }
    return 0;
}
···
```

---

## 作者：张小源 (赞：21)

这题可以用两个堆做。。。左堆为大根堆右堆，为小根堆，遇到大于大根堆堆顶的就放在小根堆里。。。反之放入大根堆。。让他们的元素个数差值为一，如果不为一就从多的一个拿出来放入少的一个中。。。之后元素多的堆顶的元素就是中位数了。。哈哈。。下面是代码

```cpp
 #include<cstdio>
#include<iostream>
#include<queue>
#include<cmath>
#include<algorithm>
#include<ctime>
using namespace std;
inline int read()
{
    char ch=getchar();
    int a=0,t=1;
    while(ch<'0'||ch>'9') {if(ch=='-') t=-1;ch=getchar();}
    while(ch<='9'&&ch>='0') {a=a*10+ch-'0';ch=getchar();}
    return a*t;
}
priority_queue<int,vector<int> > l;
priority_queue<int,vector<int>,greater<int> > r;
int n;
int num=0;
int leftnum=0,rightnum=0;
int x,y;
int a[5000001];
int main()
{
    //int th=clock();
    freopen("wq.in","r",stdin);freopen("wq.out","w",stdout);
    n=read();
    //l.resize(1000001);r.resize(1000001);
    a[1]=read();a[2]=read();a[3]=read();
    printf("%d\n",a[1]);
    sort(a+1,a+4);
    printf("%d\n",a[2]);
    l.push(a[1]);leftnum++;
    l.push(a[2]);leftnum++;
    r.push(a[3]);rightnum++;
    for(int q=5;q<=n;q+=2)
    {
        for(int i=q-1;i<=q;++i)
        {
            a[i]=read();
            //if(l.empty()==1) {l.push(a[i]);leftnum++;continue;}
            //if(r.empty()==1) {r.push(a[i]);rightnum++;continue;}
            x=l.top();y=r.top();
            int bo=0;
            if(a[i]<=x) {l.push(a[i]),leftnum++,bo=1;continue;}
            if(a[i]>=y) {r.push(a[i]),rightnum++,bo=1;continue;}
            if(a[i]>x) {r.push(a[i]),rightnum++,bo=1;continue;}
            if(a[i]<y) {l.push(a[i]),leftnum++,bo=1;continue;}
            //if(bo==0) l.push(a[i]),leftnum++;
        }
        while(abs(leftnum-rightnum)!=1)
        {
            if(leftnum>rightnum)
            {
                x=l.top();
                l.pop();
                leftnum--;
                r.push(x);
                rightnum++;
                continue;
            }
            if(leftnum<rightnum)
            {
                x=r.top();
                r.pop();
                rightnum--;
                l.push(x);
                leftnum++;
                continue;
            }
        }
        if(leftnum>rightnum) 
        {
            x=l.top();
            //num++;
            printf("%d\n",x);
            continue;
        } 
        if(leftnum<rightnum) 
        {
            //num++;
            x=r.top();
            printf("%d\n",x);
            continue;
        }
    } 
    //while(l.empty()!=0)
    //printf("%d",th-clock());
    //printf("%d",num);
    return 0;
}
```

---

## 作者：frankchenfu (赞：19)

### 1 O(n logn)算法

$\;$很显然，我们求得中位数就是在当前数列排序之后，排在第$\frac{i+1}{2}$的位置的数。所以，我们需要一个动态维护数列中$k$大的数据结构，并且支持动态插入。怎么办呢？当然找平衡树啊！于是我写了一个Treap。复杂度$O(n log_2n)$，结果常数很大。

$\;$然后我们发现，堆也可以完成以上操作。设计两个堆，然后一个是大根堆，一个是小根堆，满足大根堆的最大元素比小根堆的最小元素小。查询时取堆首。复杂度$O(n log_2n)$，常数优于平衡树。

### 2 常数再优化

$\;$于是，@Too\_Young 神犇认为，我们可以把上面常数再优化。注意到平衡树和堆的插入、查询都是$O(log_2 n)$的，于是他提出，可以用斐波那契堆来优化，这样，除了维护时的删除以外都是$O(1)$的。常数优化完成。

### 3 Treap代码

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<vector>
using namespace std;
const int MAXN=400010;

struct Treap
{
    static const int NaN=-2;
    struct node
    {
        node *ch[2];
        int r,v,sz,c;
        node(int v,node* tmp):v(v)
        {
            ch[0]=ch[1]=tmp;
            r=rand();sz=c=1;
        }
        bool operator<(const node& cpr)const
        {
            return r<cpr.r;
        }
        void upd()
        {
            sz=c+ch[0]->sz+ch[1]->sz;
        }
    }*root,*null;
    Treap()
    {
        null=new node(0,0);
        null->sz=null->c=0;
        null->r=NaN;
        root=null;
    }
    
    void rotate(node* &o,int d)//turn{0:left;1:right}
    {
        node* k=o->ch[d^1];
        o->ch[d^1]=k->ch[d];
        k->ch[d]=o;
        o->upd();k->upd();o=k;
    }
    void insert(node* &o,int x)
    {
        if(o==null)
            o=new node(x,null);
        else
        {
            if(o->v==x)
            {
                o->c++;
                o->sz++;
            }
            else
            {
                bool d=(x>o->v);
                insert(o->ch[d],x);
                if(o->ch[d]<o)
                    rotate(o,d^1);
                o->upd();
            }
        }
    }
    int kth(node* &o,int k)
    {
        int o_sz=o->ch[0]->sz+o->c;
        if(k>o->ch[0]->sz&&k<=o_sz)
            return o->v;
        else if(k<=o->ch[0]->sz)
            return kth(o->ch[0],k);
        else
            return kth(o->ch[1],k-o_sz);
    }
}mid;

int main()
{
    srand(time(NULL));
    int n,x,y;scanf("%d%d",&n,&x);
    mid.insert(mid.root,x);printf("%d\n",x);
    for(int i=2;i<=n;i++)
        if(i&1)
        {
            scanf("%d",&x);mid.insert(mid.root,x);
            printf("%d\n",mid.kth(mid.root,i+1>>1));
        }
        else
        {
            scanf("%d",&x);
            mid.insert(mid.root,x);
        }
    return 0;
}
```

---

## 作者：Masky (赞：13)

本蒟蒻的第一篇题解。~~QAQ~~

很明显，我们可以通过维护的手段优化复杂度，就可以仅仅从左到右扫一遍，加上维护的复杂度，$O(~nlogn~)$ 左右应该是正解的。

题解里好多写了什么堆 $vector$ 的，蒟蒻懒得想那么多，就把平衡树的代码复制粘贴了一遍改一改就 $A$ 了。

为什么可以用平衡树呢？

我们考虑到每次插入一个值，因为使从左往右插入的，我们不需要考虑他的位置，仅考虑当前状态下的权值大小序列。那么我们可以每次扫一遍，把当前权值入队（准确说应该叫树，但我感觉叫队更好理解，因为平衡树本质就是一个序列），然后查询当前平衡树的中位数即可。
```code
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define Mid (l+r)/2
#define maxn 100005
#define inf 0x3f3f3f3f

const int mod=1e9+7;

int n,m,Q;

int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    return x*f;
}
int a[maxn];
int fa[maxn],siz[maxn],cnt[maxn],ch[maxn][2],key[maxn];
int rt,len;
int get(int x)
{
    return ch[fa[x]][1]==x;
}
void clear(int x)
{
    fa[x]=cnt[x]=siz[x]=ch[x][1]=ch[x][0]=key[x]=0;
}
void pushup(int x)
{
    if(!x)return;
    siz[x]=cnt[x]+siz[ch[x][0]]+siz[ch[x][1]];
}
void rotate(int x)
{
    int fu=fa[x],ye=fa[fu],k=get(x);
    ch[fu][k]=ch[x][!k];fa[ch[fu][k]]=fu;
    ch[x][!k]=fu;fa[fu]=x;
    fa[x]=ye;if(ye)ch[ye][ch[ye][1]==fu]=x;
    pushup(fu);pushup(x);
}
void splay(int x)
{
    for(int fu;fu=fa[x];rotate(x))
        if(fa[fu])
            rotate((get(x)==get(fu))?fu:x);
    rt=x;
}
void insert(int x)
{
    if(rt==0)
    {
        len++;rt=len;key[len]=x;
        siz[len]=cnt[len]=1;return;
    }
    int now=rt,fu=0;
    while(1)
    {
        if(key[now]==x)
        {
            cnt[now]++;pushup(now);pushup(fu);
            splay(now);return;
        }
        fu=now;now=ch[now][key[now]<x];
        if(!now)
        {
            len++;key[len]=x;siz[len]=cnt[len]=1;
            fa[len]=fu;ch[fu][key[fu]<x]=len;
            pushup(fu);splay(len);return;
        }
    }
}
int firnk(int x)
{
    int now=rt;
    while(1)
    {
        if(ch[now][0]&&x<=siz[ch[now][0]])now=ch[now][0];
        else
        {
            if(siz[ch[now][0]]+cnt[now]>=x)
                return key[now];
            x-=siz[ch[now][0]]+cnt[now];
            now=ch[now][1];
        }
    }
}
signed main(){
//  freopen("a.in","r",stdin);
//  freopen("a.out","w",stdout);
    int x,y,z,l,r,k,opt;
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();insert(a[i]);
        if(i%2==1)cout<<firnk(i/2+1)<<endl;
    }





    return 0;
}
```

---

## 作者：Capella (赞：11)

中位数可以转化为区间第k大问题，当然是选择Treap实现名次树了啊。（笑）


功能十分简单的Treap即能满足需求——只需要插入与查找第大的功能。


插入第i个数时，如果i是奇数，随即询问当前排名第(i+1>>1)的数。


注意是一边插入一边询问，这样可以保留原序列的顺序，而不是所有插入完后再询问。


这样一趟下来，所有数都插入完毕了，询问也处理完毕了。


很好理解，话不多说啦，代码如下。


两个版本，封装版献给像我一样追求可读性的人；精简版献给喜欢代码比较少的人。


## 封装版代码


```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
const int MAXN=100010;
int n;
class Treap
{
    public:
        Treap(void)
        {
            rt=cnt=0;
            memset(a,0,sizeof a);
            memset(s,0,sizeof s);
        }
        void Insert(int x)
        {
            _Insert(rt,x);
        }
        int Xth(int x)
        {
            return _Xth(rt,x);
        }
    private:
        bool a[MAXN];
        int rt,cnt;
        struct node
        {
            int l,r,v,p,size,num;
        }s[MAXN];
        int Random(void)
        {
            int x;
            while(a[x=rand()%MAXN]);
            a[x]=1;
            return x;
        }
        void Update(int i)
        {
            s[i].size=s[s[i].l].size+s[s[i].r].size+s[i].num;
        }
        void L_Rotate(int &i)
        {
            int t=s[i].r;
            s[i].r=s[t].l,s[t].l=i;
            s[t].size=s[i].size;
            Update(i),i=t;
        }
        void R_Rotate(int &i)
        {
            int t=s[i].l;
            s[i].l=s[t].r,s[t].r=i;
            s[t].size=s[i].size;
            Update(i),i=t;
        }
        void _Insert(int &i,int x)
        {
            if(!i)
            {
                s[i=++cnt].v=x,s[i].p=Random();
                s[i].size=s[i].num=1;
                return;
            }
            ++s[i].size;
            if(x==s[i].v)
                ++s[i].num;
            else if(x<s[i].v)
            {
                _Insert(s[i].l,x);
                R_Rotate(i);
            }
            else
            {
                _Insert(s[i].r,x);
                L_Rotate(i);
            }
        }
        int _Xth(int i,int x)
        {
            if(!i)
                return 0;
            int t;
            if(x<=s[s[i].l].size)
                return _Xth(s[i].l,x);
            else if(x>(t=s[s[i].l].size+s[i].num))
                return _Xth(s[i].r,x-t);
            else
                return s[i].v;
        }
}T;
int main(int argc,char *argv[])
{
    scanf("%d",&n);
    srand((unsigned)time(NULL));
    for(int i=1,x;i<=n;++i)
    {
        scanf("%d",&x);
        T.Insert(x);
        if(i&1)
            printf("%d\n",T.Xth(i+1>>1));
    }
    return 0;
}
```



## 精简版代码


```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
const int MAXN=100010;
bool a[MAXN];
int n,rt,cnt;
struct node
{
    int l,r,v,p,size,num;
}s[MAXN];
int Random(void)
{
    int x;
    while(a[x=rand()%MAXN]);
    a[x]=1;
    return x;
}
void Update(int i)
{
    s[i].size=s[s[i].l].size+s[s[i].r].size+s[i].num;
}
void L_Rotate(int &i)
{
    int t=s[i].r;
    s[i].r=s[t].l,s[t].l=i;
    s[t].size=s[i].size;
    Update(i),i=t;
}
void R_Rotate(int &i)
{
    int t=s[i].l;
    s[i].l=s[t].r,s[t].r=i;
    s[t].size=s[i].size;
    Update(i),i=t;
}
void Insert(int &i,int x)
{
    if(!i)
    {
        s[i=++cnt].v=x,s[i].p=Random();
        s[i].size=s[i].num=1;
        return;
    }
    ++s[i].size;
    if(x==s[i].v)
        ++s[i].num;
    else if(x<s[i].v)
    {
        Insert(s[i].l,x);
        R_Rotate(i);
    }
    else
    {
        Insert(s[i].r,x);
        L_Rotate(i);
    }
}
int Xth(int i,int x)
{
    if(!i)
        return 0;
    int t;
    if(x<=s[s[i].l].size)
        return Xth(s[i].l,x);
    else if(x>(t=s[s[i].l].size+s[i].num))
        return Xth(s[i].r,x-t);
    else
        return s[i].v;
}
int main(int argc,char *argv[])
{
    scanf("%d",&n);
    srand((unsigned)time(NULL));
    for(int i=1,x;i<=n;++i)
    {
        scanf("%d",&x);
        Insert(rt,x);
        if(i&1)
            printf("%d\n",Xth(rt,i+1>>1));
    }
    return 0;
}
```

> 谢谢阅读。


---

## 作者：Jack_Homes_Huang (赞：9)

自己模拟了好久才终于明白该怎么用堆的。。。。。。

1.首先，中位数的左边都小于这个中位数；

2.其次，中位数的右边都大于这个中位数；

3.中位数的右边是有次序从小往大排的；

4.中位数的左边是有次序从大往小排的。

###于是，就可以发现堆的应用了：

- 用一个小根堆来存放中位数右边的一坨数，小根堆保证了里面的数是由小到大的；

- 用一个大根堆来存放中位数左边的一坨数，大根堆保证了里面的数是由大到小的；

- 用大根堆的堆顶来存放中位数（当然可以用小根堆）

接下来是操作上的问题:

因为求每次中位数的时候个数一定为奇数，所以正常情况下，大根堆的数要比小根堆的数多1（因为多了那个中位数）

每次读2个数，两个数分别进行：如果它比上一次的中位数大，就塞入小根堆（为什么？思考一下）；否则就塞入大根堆；

如果小根堆的数量比大根堆的数量-1还要少，那么就把大根堆堆顶塞到小根堆中进行维护；

如果小根堆的数量比大根堆的数量-1还要大，那么就把小根堆堆顶塞到大根堆中进行维护。

其他的，就没有了。

附上代码:








```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#define oo 1000000000
using namespace std;
int n;
void exchange(int &x,int &y){ //交换函数 
    int t; t=x,x=y,y=t;
}
struct Max_Heap{
    int size,h[4000005];
    void Max_Heapify(int i){
        int l=i << 1;
        int r=i << 1 | 1;
        int largest;
        if (l<=size && h[l]>h[i])
            largest=l;
        else
            largest=i;
        if (r<=size && h[r]>h[largest])
            largest=r;
        if (largest!=i){
            exchange(h[i],h[largest]);
            Max_Heapify(largest);
        }
    }
    void Heap_Inc(int i,int key){
        h[i]=key;
        while (i>1 && h[i >> 1]<h[i]){
            exchange(h[i],h[i >> 1]);
            i>>=1;
        }
    }
    int top(){
        return h[1];
    }
    void pop(){
        h[1]=h[size];
        size--;
        Max_Heapify(1);
    }
    void push(int key){
        size++;
        h[size]=key;
        Heap_Inc(size,key);
    }
} max_h; //大根堆的操作 
struct Min_Heap{
    int size,h[4000005];
    void Min_Heapify(int i){
        int l=i << 1;
        int r=i << 1 | 1;
        int smallest;
        if (l<=size && h[l]<h[i])
            smallest=l;
        else
            smallest=i;
        if (r<=size && h[r]<h[smallest])
            smallest=r;
        if (smallest!=i){
            exchange(h[i],h[smallest]);
            Min_Heapify(smallest);
        }
    }
    void Heap_Inc(int i,int key){
        h[i]=key;
        while (i>1 && h[i >> 1]>h[i]){
            exchange(h[i],h[i >> 1]);
            i>>=1;
        }
    }
    int top(){
        return h[1];
    }
    void pop(){
        h[1]=h[size];
        size--;
        Min_Heapify(1);
    }
    void push(int key){
        size++;
        h[size]=key;
        Heap_Inc(size,key);
    }
} min_h; //小根堆的操作 
int main()
{
    scanf("%d",&n);
    int x; scanf("%d",&x);
    max_h.push(x);   //把第一个数读入并输出，不解释 
    printf("%d\n",x);
    for (int i=1; i << 1 < n; i++){
        int mid=max_h.top();
        int v1,v2;
        scanf("%d%d",&v1,&v2); //一次读两个 
        if (v1>mid) 
            min_h.push(v1); else
            max_h.push(v1);
        if (v2>mid)
            min_h.push(v2); else
            max_h.push(v2);
        if (min_h.size>max_h.size-1){
            max_h.push(min_h.top());
            min_h.pop();
        }
        if (min_h.size<max_h.size-1){
            min_h.push(max_h.top());
            max_h.pop();
        }  //我就是喜欢把手写堆打成STL的样子 
        printf("%dAAAAA\n",max_h.top()); //输出答案 
    }
    return 0;
}

```

---

## 作者：Mychael (赞：8)

怎么没人用主席树呢？这明显是区间第K大问题，典型的主席树板子啊。

读入每个数后离散化建树，当建到奇数个时输出一次询问区间第k小【k为当前已建点数的一半+1】

就是主席树呐。不过数组别开小了，5\*10^6够了





```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=100005,INF=200000000;
inline int read()
{
    int out=0,flag=1;char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57) {out=out*10+c-48;c=getchar();}
    return out*flag;
}
int A[maxn],B[maxn],num[maxn],numi=0,h[maxn],N;
class node{
```
public:





```cpp
        int l,r,sl,sr,sum;
}e[50*maxn];
int root[maxn],pos,siz=0;
void build(int& u,int l,int r){
    u=++siz;
    e[u].l=l;
    e[u].r=r;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(e[u].sl,l,mid);
    build(e[u].sr,mid+1,r);
}
void insert(int pre,int& u){
    u=++siz;
    e[u]=e[pre];
    e[u].sum++;
    if(e[u].l==e[u].r) return;
    int mid=(e[u].l+e[u].r)>>1;
    if(pos<=mid) insert(e[pre].sl,e[u].sl);
    else insert(e[pre].sr,e[u].sr);
}
int Query(int pre,int u,int k){
    if(e[u].l==e[u].r) return num[e[u].l];
    int sum=e[e[u].sl].sum-e[e[pre].sl].sum;
    if(k<=sum) return Query(e[pre].sl,e[u].sl,k);
    else return Query(e[pre].sr,e[u].sr,k-sum);
}
int main()
{
    N=read();
    for(int i=1;i<=N;i++) B[i]=A[i]=read();
    sort(B+1,B+1+N);
    B[0]=-1;
    for(int i=1;i<=N;i++){
        if(B[i]!=B[i-1]) numi++;
        num[numi]=B[i];
        h[i]=numi;
    }
    build(root[0],1,N);
    for(int i=1;i<=N;i++){
        pos=h[lower_bound(B+1,B+1+N,A[i])-B];
        insert(root[i-1],root[i]);
        if(i&1) printf("%d\n",Query(root[0],root[i],(i>>1)+1));
    }
    return 0;
}

```

---

## 作者：王半仙 (赞：7)

每插入两个元素就输出一次中位数。如果能维护数组单调递增的话，则每次输出的数要么原来的数相等（插入一个大数、一个小数），要么是大一号的数（插入两个大数），要么小一号的数（插入两个小数）。
使用类似插入排序的方法维护数组的单调递增，时间复杂度有点高。刚好STL中有个数据结构满足数列有序，且支持查找大一号或小一号的元素。那就是set。
set插入和查找时间都是O(logn)。
上代码
```cpp
#include <iostream>
#include <set>
using namespace std;
multiset<int> st;
multiset<int>::iterator it;

int main(){
	int n,t,k=0;
	cin>>n;
	cin>>t;
	st.insert(t);
	it = st.begin();
	cout<<t<<endl;
	for(int i=2;i<=n;i++)
	{
		cin>>t;
		st.insert(t);
		if(t<*it)
			--k;
		else
			++k;
		if(i&1)
		{
			//插入两个大的，就往后一个 
			if(k>0)	it++;
			//插入两个小的，就往前一个 
			else if(k<0) it--;
			cout<<*it<<endl;
			k = 0;
		}
	}
}
```


---

## 作者：KobeBeanBryantCox (赞：6)

# P1168 中位数 题解

[题目传送门](https://www.luogu.com.cn/problem/P1168)。

**本题解用 $5$ 种方法过这个题，讲述顺序由易到难。**

**本文最后会比较各个方法的用时、空间、码量和好写程度。**

**代码放在云剪贴板，链接在最后。**

---------------

## 题意

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

--------------------

## 1. 暴力 vector

保证每次插入的时候原序列有序就行了。

所以用一个二分查找找到插入的位置插入就行了。

理论时间复杂度 $O(n^2\log n)$，但是常数极小，而且跑不满。

不保证加强数据以后能过。

-------------------

## 2. 优先队列（堆）

维护两个堆：比当前中位数小的和比它大的。

插入，就与中位数比较，选择哪个插入；

输出，把中位数放入元素少的，把元素多的设置成中位数，循环操作。

由于不平衡的状态次数不多，理论时间复杂度 $O(n\log n)$。

------------------------------------

## 3. 值域线段树

先离散化。

然后插入就直接插入；输出就在线段树上二分，找到中位数就行。

理论时间复杂度 $O(n\log n)$。

------------------------------------

## 4. 分块

我这里的分块比[这篇题解](https://www.luogu.com.cn/article/6oq9o5ax)的分块好理解。

先离散化，对值域分块，维护每一块的和。

插入就直接插入，更新值域数组以及块和；

输出有点麻烦。

暴力算一个块内和的前缀和，二分查找中位数在哪一个块。

然后再暴力算这个块的前缀和，二分查找中位数在这个块的哪个位置。

块长取 $\sqrt n$，理论时间复杂度 $O(n\times(\sqrt n+\log n))$。

当然块长如果改一下还有可能更快，不过蒟蒻不会算块长。

-------------------------------------------

## 5. 平衡树

这是平衡树模板题啊 QWQ。

我采用的是 FHQ-Treap。

理论时间复杂度 $O(n\log n)$。

-----------------

## 代码 & 比较分析

代码放[云剪贴板](https://www.luogu.com.cn/paste/ar8ab2fb)。

评测环境：

`-std=c++17 -O2`，开快读快输。

|      做法      |         用时          |     空间     |   码量    |      好写程度      |
| :------------: | :-------------------: | :----------: | :-------: | :----------------: |
|  暴力 vector   |       $766$ ms        |  $1.05$ MB   |  $661$ B  |       极好写       |
| 优先队列（堆） | $55$ ms（最优解第三） | $1008.00$ KB |  $962$ B  |        好写        |
|   值域线段树   |       $141$ ms        |  $4.36$ MB   | $1.64$ KB |        中等        |
|      分块      |       $152$ ms        |  $2.08$ MB   | $1.40$ KB | 极难写（细节很多） |
|     平衡树     |       $185$ ms        |  $2.31$ MB   | $1.87$ KB |        难写        |

综上：优先队列最快，优先队列用空间少，暴力码量少，暴力最好写。

~~分块比平衡树快的原因应该是平衡树常数太大了。~~

---------------

## 后记

如果哪里有讲错的欢迎提出，如果讲得不清楚欢迎提问。

麻烦点个赞，点个关注。

~~说句闲话：研究珂学的最好方法是：~~

~~A 了这道题。~~

~~祝你们成功（滑稽。~~

---

## 作者：a13518354766 (赞：6)

		看了此题,发现是求中位数,自然而然的想到了求kth

		求kth有多种,我用的是权值线段树,即记录x的个数,但,我们看题，发现a[i]可以高达1e9,一个数组是开不完的,不过万幸的是n只到了1e5,而求kth只需要知道大小关系就行,不需要知道具体的值,所以,我们可以用离散化来搞定它！

		这里说一下stable_sort,它其实跟sort差不多,不过区别在于相同元素sort后的值是一样的！所以stable_sort极适合用于离散化

		那么问题来了,假如我们用离线算法,各种判断,骚操作,眼花缭乱,本蒟蒻的内心qwq

		所以,我们可以考虑在线算法！

		我们动态将此时的a[i] (离散化后) 的个数+1,然后每到i为奇数时我们就求出的(i+1)/2大的数即可了~
        
        以下是代码:
        
        #include<bits/stdc++.h>//离散化+权值线段树求kth 
		using namespace std;
        const int N=1e5+1;
        long long a[N];
        long long e[N],b[N];
        int c[N];
        int d[N<<2];
        inline long long read(){
            long long X=0,w=0; char ch=0;
            while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
            while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
            return w?-X:X;
        }//快读 
        inline bool kk(int x,int y){
            return a[x]<a[y];
        }
        inline void up(int now,int l,int r,int x){
            d[now]++;//范围中有x的都加一,不用左儿子加右儿子那么麻烦~ 
            if(l==r){
                return;
            }
            int mid=((l+r)>>1);
            if(x<=mid){
                up(now<<1,l,mid,x);//向左查找 
                return;
            }
            up(now<<1|1,mid+1,r,x);//向右查找 
        }
        inline int kth(int now,int l,int r,int x){
            if(l==r){
                return l;
            }
            int ls=now*2;
            int mid=((l+r)>>1);
            if(d[ls]>=x){//如果前面的数的个数大于x 
                return kth(ls,l,mid,x);//向前搜 
            }
            return kth(ls|1,mid+1,r,x-d[ls]);//注意这里是x-d[ls],因为前半段有d[ls]个数,那么,kth在后半段的排名应为x-d[ls]
        }
        int main(){
            int n;
            n=read();
            long long x;
            for(int i=1;i<=n;++i){
                a[i]=read();
                e[i]=a[i];//记录存值 
                c[i]=i;//用于之后离散化 
            }
            stable_sort(c+1,c+n+1,kk);//stable排序 
            for(int i=1;i<=n;++i){
                a[c[i]]=i;//离散化值,离散化后a[i]表示原来第i个数第a[i]大
            }
            for(int i=1;i<=n;++i){
                b[a[i]]=e[i];//记录值,用于输出 
            }
            for(int i=1;i<=n;++i){
                up(1,1,1e5,a[i]);//a[i]加一 
                if(i%2){
                    int zhong=(i+1)>>1;
                    printf("%lld\n",b[kth(1,1,1e5,zhong)]);
                } 
            }
            return 0;
        }


---

## 作者：ModestCoder_ (赞：6)

此题方法层出不穷，这里讲解一下树状数组的

首先ai<=10^9，想到离散化

不过离散好以后，原数与新数需要对应，因为最后还要输出原数

接下来是树状数组的区间查询

怎么查询？

我们令c[i]为当前序列中i为第几小

比如序列：1 3 5 7 9

c数组就为：1 1 2 2 3 3 4 4 5

没有的数跟前面一致，所以每次问题转化为：区间查找第(i+1)/2小数

即为查找：c[i]=(i+1)/2，i最小

方法？

二分。














```cpp
var
    a,b,c,number,print:array[0..1000000] of int64;
    p,n,i:longint;
function lowbit(x:int64):int64;
begin
    exit(x and -x);
end;
procedure add(x:int64);
begin
    while x<=n do
        begin
            inc(c[x]);
            inc(x,lowbit(x));
        end;
end;
function getsum(x:int64):int64;
begin
    getsum:=0;
    while x>0 do
        begin
            inc(getsum,c[x]);
            dec(x,lowbit(x));
        end;
end;
function find(x:int64):int64;//二分区间查询
var
    l,r,mid:int64;
begin
    l:=0;
    r:=n;
    while l<=r do
        begin
            mid:=(l+r) div 2;
            if getsum(mid)>=x then
                r:=mid-1 else
                begin
                    find:=mid+1;
                    l:=mid+1;
                end;
        end;
end;
procedure swap(var x,y:int64);
var
    t:int64;
begin
    t:=x;
    x:=y;
    y:=t;
end;
procedure sort(l,r:longint);
var
    i,j,mid:longint;
begin
    i:=l;
    j:=r;
    mid:=a[(l+r) div 2];
    repeat
        while a[i]<mid do
            inc(i);
        while a[j]>mid do
            dec(j);
        if i<=j then
            begin
                swap(a[i],a[j]);
                swap(number[i],number[j]);
                inc(i);
                dec(j);
            end;
    until i>j;
    if l<j then
        sort(l,j);
    if i<r then
        sort(i,r);
end;
begin
    readln(n);
    for i:=1 to n do
        begin
            read(a[i]);
            number[i]:=i;
        end;
    sort(1,n);
    a[0]:=a[i]-1;
    for i:=1 to n do
        if a[i]<>a[i-1] then //离散
            begin
                inc(p);
                print[p]:=a[i]; //对应，用于输出
                b[number[i]]:=p;
            end else
            b[number[i]]:=p;
    for i:=1 to n do
        begin
            add(b[i]); //更改，在所有比自己大的数中+1
            if odd(i) then //i为奇数时，要输出了
                writeln(print[find((i+1) div 2)]); //find查找的下标
        end;
end.

```

---

## 作者：fighter_OI (赞：6)

看完题目，区间中位数，

既然是区间中位数，就可以写区间第k大

###主席树闪亮登场###

所谓主席树，就是对于键值，[1,1],[1,2][1,3]……每个区间建一棵线段树，再用前缀和求要求区间出现个数，

然后就可以按普通第k大求了

[1,2\*k-1]的中位数，不就是第k大吗？


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct Node{
    int a,b,rs,ls,sum;
}tr[2000010];
int a[100010],b[100010];
int rt[100010],pos,cnt;
void Build(int &node,int a,int b)
{
    node=++cnt;
    tr[node].a=a;
    tr[node].b=b;
    if(a==b)return;
    int mid=(a+b)>>1;
    Build(tr[node].ls,a,mid);
    Build(tr[node].rs,mid+1,b);
}
void Insert(int pre,int &node)
{
    node=++cnt;
    tr[node].ls=tr[pre].ls;
    tr[node].rs=tr[pre].rs;
    tr[node].a=tr[pre].a;
    tr[node].b=tr[pre].b;
    tr[node].sum=tr[pre].sum+1;
    if(tr[node].a==tr[node].b)return;
    int mid=(tr[node].a+tr[node].b)>>1;
    if(mid>=pos)Insert(tr[pre].ls,tr[node].ls);
    else Insert(tr[pre].rs,tr[node].rs);
}
int Query(int pre,int node,int k)
{
    if(tr[node].ls==tr[node].rs)return b[tr[node].a];
    int cmp=tr[tr[node].ls].sum-tr[tr[pre].ls].sum;
    if(cmp>=k)return Query(tr[pre].ls,tr[node].ls,k);
    else return Query(tr[pre].rs,tr[node].rs,k-cmp);
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;b[i]=a[i],i++)
        scanf("%d",&a[i]);
    sort(b+1,b+n+1);
    Build(rt[0],1,n);
    for(int i=1;i<=n;i++)
    {
        pos=lower_bound(b+1,b+n+1,a[i])-b;
        Insert(rt[i-1],rt[i]);
    } 
    for(int i=1;i<=(n+1)/2;i++)
    {
        printf("%d\n",Query(rt[0],rt[i*2-1],i));
    }
    return 0;
}
```

---

## 作者：Sky_valley (赞：5)

最近做了些单调队列～ 看完题目后果断打了单调队列(题目看错了)，结果 Ti 3个点(O n2)(共5个点)。。。
也想过线段树，但不太会。。。

后来发现可以用堆做，而且是比较神奇的做法。。--用两个堆(一个大根堆，一个小根堆)来维护就好啦！

大根堆记录小于中位数的数，小根堆记录中位数及大于中位数的元素，维护元素个数差值为1。元素多的堆的堆顶即为ans。。。
遇到大于大根堆堆顶的数就丢进小根堆，否则丢进大根堆。

写堆的话STL很方便(但习惯手写。。。) 下面见代码。。。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define rg register
#define il inline
#define fp(i,a,b) for(rg int i=a;i<=b;++i)
#define Max 200000
using namespace std;
int max_heap[Max],min_heap[Max]; 
int a[Max],n,Max_n,Min_n; //Max_n 记录大根堆元素数,Min_n记录小根堆元素数
il int gi() //读入优化
{
	int res=0; char ch=0;
	while(ch<'0'|| ch>'9'){ ch=getchar(); }
	while(ch>='0'&&ch<='9') res=res*10+ch-'0',ch=getchar();
	return res;
}
il void we(int x) //输出优化
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) we(x/10);
	putchar(x%10+'0');
}
il void swap(int &q,int &p) //加 & 后变量可修改(需注意)
{
	int temp=p; p=q;
	q=temp;
}
il void push_max(int x) //丢进大根堆
{
	max_heap[++Max_n]=x; int now=Max_n;
	while((now>>1)>=1)
	{
		int ne=now>>1;
		if(max_heap[ne]>=max_heap[now]) return;
		swap(max_heap[now],max_heap[ne]);
		now=ne;
	}
}
il void push_min(int x) //丢进小根堆
{
	min_heap[++Min_n]=x; int now=Min_n;
	while((now>>1)>=1)
	{
		int ne=now>>1;
		if(min_heap[ne]<=min_heap[now]) return;			
		swap(min_heap[now],min_heap[ne]);
		now=ne;
	}
}
il int getmax() //取大根堆的值并维护
{
	int ans=max_heap[1];
	max_heap[1]=max_heap[Max_n--];
	int now=1;
	while((now<<1)<=Max_n)
	{
		int ne=now<<1;
		if(max_heap[ne+1]>max_heap[ne]&&ne<Max_n) ++ne;
		if(max_heap[ne]<=max_heap[now]) return ans;
		swap(max_heap[now],max_heap[ne]);
		now=ne;
	}
	return ans;
}
il int getmin() //取小根堆的值并维护
{
	int ans=min_heap[1];
	min_heap[1]=min_heap[Min_n--];
	int now=1;
	while((now<<1)<=Min_n)
	{
		int ne=now<<1;
		if(min_heap[ne+1]<min_heap[ne]&&ne<Min_n) ++ne;
		if(min_heap[ne]>=min_heap[now]) return ans;	
		swap(min_heap[now],min_heap[ne]);
		now=ne;
	}
	return ans;
}
il void solve()
{
	fp(i,1,n)
	{
		if(a[i]>=max_heap[1]) push_min(a[i]); // 如果大于等于大根堆的最大值,就丢进小根堆
		if(a[i]< max_heap[1]) push_max(a[i]); // 反之,丢进大根堆
		if(Min_n-Max_n > 1){ // 若小根堆元素 的数量多于大根堆元素数量 1 个以上 取小根堆最小元素丢进大根堆
			int t=getmin();
			push_max(t);
		}
		if(Max_n-Min_n > 1){ // 同理，取大根堆最大元素丢进小根堆
			int t=getmax();
			push_min(t);
		}
		if(i%2!=0) { 
			if(Max_n>Min_n) we(max_heap[1]),printf("\n"); 
			if(Max_n<Min_n) we(min_heap[1]),printf("\n");
			}
	}
}
int main()
{
	n=gi(); fp(i,1,n) a[i]=gi();
	solve();
	return 0;
}

```

---

## 作者：坚决杀毒2008 (赞：5)

维护一个最大堆和一个最小堆，使得最大堆的最大元素总小于等于最小堆的最小元素，并且最大堆元素个数总是比最小堆元素个数少1。当有新元素时，总是把比最小堆最小元素小的元素加入最大堆，把比最小堆最小元素大的元素加入最大堆，每一次操作后最小堆的最小元素就是序列的中位数。

本题中元素数量都是单数，元素个数是双数的情况，只需使得最大堆元素个数和最小堆元素个数相等。


```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
int n,a1;
priority_queue<int,vector<int> ,greater<int> >minheap;
priority_queue<int>maxheap;
int main()
{
    scanf("%d",&n);
    scanf("%d",&a1);
    printf("%d\n",a1);
    minheap.push(a1);
    for(int i=1;i<=(n-1)/2;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        if(a<minheap.top())
        {
            maxheap.push(a);
        }
        else
        {
            minheap.push(a);
        }
        if(b<minheap.top())
        {
            maxheap.push(b);
        }
        else
        {
            minheap.push(b);
        }
        while(maxheap.size()>=minheap.size())
        {
            minheap.push(maxheap.top());
            maxheap.pop();
        }
        while(maxheap.size()<minheap.size()-1)
        {
            maxheap.push(minheap.top());
            minheap.pop();
        }
        printf("%d\n",minheap.top());
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：5)

树状数组练手的好题，顺便练习了一下二分，离散化，，，，，，

首先这一题要求我们找中位数，那么我们用树状数组c[x]存储当前

x-x and -x+1-------x这个区间中数字的个数

当然之前要离散化。

然后我们二分一个数，判断比这个数小的数的个数是否等于比这个数大的数的个数。

这样可以做到O(n\*log(n)\*log(n))不会超时。





```cpp
var a,b,c,e:array[0..270000]of int64;
i,j,k,m,n,p,l,r,mid:longint;
ans,wer:int64;
procedure sort(l,r: longint);
var
i,j,x,y: longint;
begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2];
  repeat
    while a[i]>x do inc(i);
    while x>a[j] do dec(j);
    if not(i>j) then
    begin
      y:=a[i];
      a[i]:=a[j];
      a[j]:=y;
      y:=b[i];
      b[i]:=b[j];
      b[j]:=y;
      inc(i);
      j:=j-1;
    end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;
function six(x:longint):longint;
begin
  exit(x and -x);
end;
procedure up(x:longint);
begin
  if x>n then exit;
  c[x]:=c[x]+1;
  up(x+six(x));
end;
procedure de(x:longint);
var a:longint;
begin
  a:=1;
  while a<=x do a:=a*2;
  a:=a div 2;
  ans:=ans+c[a+k];  //writeln(a+k);
  k:=a+k;
  x:=x-a;
  if x=0 then exit else de(x);
end;
begin
  read(n);
  for i:=1 to n do read(a[i]);  p:=a[1];
  for i:=1 to n do b[i]:=i;
  sort(1,n);
  for i:=1 to n do e[n+1-i]:=a[i];
  for i:=1 to n do a[b[i]]:=n+1-i;
  ans:=0;
  for i:=1 to n do
  begin
    k:=0;ans:=0;
    up(a[i]);
    if i mod 2=1 then
    begin
      l:=0;r:=250000;ans:=0;k:=0;
      while l<r do
      begin
        ans:=0;k:=0;
        mid:=(l+r)div 2;
        de(mid);
     //   if ans<i div 2+1 then l:=mid+1 else r:=mid;
      end;
      writeln(e[l]) ;
    end;
  end;
  k:=0; ans:=0;
  //write(a[5]);
 // write(e[5]);
end.

```

---

## 作者：无名之雾 (赞：4)

> 大家好，我是个毒瘤，我非常喜欢暴力数据结构，于是我就用分块过了这个题。

![](https://cdn.luogu.com.cn/upload/image_hosting/7i5qgxgu.png)
## 题意转换

求前 $n$ 个的数字的中位数不难转换为求区间第 $k$ 大问题。其中 $k=n/2+1$。

## 思路

$n\le 10^5$，根号完全能跑。果断考虑值域分块。

我们维护两个数组，$cnt1_{i,j}$ 表示前 $i$ 个数列块中第 $j$ 个值域块中数字出现的次数和，$cnt2_{i,j}$ 表示前 $i$ 个数列块中第 $j$ 这个数字出现的次数。

接下来进行查询：

- 对于每个散块。我们暴力维护 $ans1$ 与 $ans2$ 这两个数组来记录散块中的信息。

- 对于整块，直接从头开始扫值域块。累加每个块的 $ans1$ 至 $cnt1$ 数组已确定第 $k$ 大在那个值域块里。然后通过 $ans2$ 与 $cnt2$ 两个数组扫一遍确定答案。

## 实现

注意不要开 `long long` 同时数组不要开太大，不然 MLE。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[10005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
const int N=1e5+5;
int block,block2;
int nw[N],a[N],pos[N],pos2[N],cnt1[400][400],cnt2[400][N],z[N],o;
int ans[400],ans2[N];
int ask(int x,int y,int k) {
    int res=0,pd=0;
    for(int i=x;i<=min(y,pos[x]*block);i++)ans[pos2[nw[i]]]++,ans2[nw[i]]++;
    if(pos[x]!=pos[y]){
    	for(int i=(pos[y]-1)*block+1;i<=y;i++)ans[pos2[nw[i]]]++,ans2[nw[i]]++;
	}
    for(int i=1;i<=pos2[o];i++){
    	int ld=cnt1[pos[y]-1][i]-cnt1[pos[x]][i];
    	if(ld<0)ld=0;
        if(res+(ld+ans[i])<k){ 
        	res+=ans[i];
        	if(cnt1[pos[y]-1][i]-cnt1[pos[x]][i]>0)res+=cnt1[pos[y]-1][i]-cnt1[pos[x]][i];
        }
        else{
        	pd=i;	
        	break;
        }
    }
    int anss=-1;
    for(int i=(pd-1)*block2+1;i<=pd*block2;i++){
    	res+=ans2[i];
    	if(cnt2[pos[y]-1][i]-cnt2[pos[x]][i]>0)res+=cnt2[pos[y]-1][i]-cnt2[pos[x]][i];
        if(res>=k){
        	anss=z[i];
        	break;
        }
    }
    for(int i=x;i<=min(y,pos[x]*block);i++)ans[pos2[nw[i]]]--,ans2[nw[i]]--;
    if(pos[x]!=pos[y]){
      for(int i=(pos[y]-1)*block+1;i<=y;i++)ans[pos2[nw[i]]]--, ans2[nw[i]]--;
    }
    return anss;
}
signed main() {
    int n=read();
    block=sqrt(n);
    for(int i=1;i<=n;i++){
    	a[i]=read();
    	pos[i]=(i-1)/block+1;
    	z[++o]=a[i];
	}
    sort(z+1,z+o+1);
    o=unique(z+1,z+o+1)-z-1;
    block2=sqrt(o);
    for(int i=1;i<=o;i++)pos2[i]=(i-1)/block2+1;
    for(int i=1;i<=n;i++){
        nw[i]=lower_bound(z+1,z+o+1,a[i])-z;
        cnt1[pos[i]][pos2[nw[i]]]++;
        cnt2[pos[i]][nw[i]]++;
    }
    for(int i=1;i<=pos[n];i++){
    	for(int j=1;j<=pos2[o];j++){
    		cnt1[i][j]+=cnt1[i-1][j];
		}
        for(int j=1;j<=o;j++){
        	cnt2[i][j]+=cnt2[i-1][j];
		}
    }
    for(int i=1;i<=n;i+=2){
        write(ask(1,i,i/2+1));
        puts("");
    }
    return 0; 
}
```

---

## 作者：ZhYic (赞：4)

# P1168中位数

### --第K大的数问题

先上代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define N 230000
int a[N],b[N];
int n,m;
struct node
{
    int l,r,ls;
    int val;
}t[N*4];
inline void build(int p,int l,int r)
{
    t[p].l=l,t[p].r=r;
    if(l==r)return;
    int m=(l+r)>>1;
    build(p<<1,l,m);build(p<<1|1,m+1,r);
}
void query(int p,int pos)
{
    if(t[p].l==t[p].r&&t[p].ls>=pos){printf("%d\n",t[p].val);return;}
    if(t[p].ls>=pos)query(p<<1,pos);
    else query(p<<1|1,pos-t[p].ls);
}
void Insert(int p,int &pos,int &val)
{
    if(t[p].l==t[p].r&&t[p].l==pos){t[p].val=val;t[p].ls++;return;}
    int m=(t[p].l+t[p].r)>>1;
    if(pos>m)Insert(p<<1|1,pos,val);
    else {Insert(p<<1,pos,val);t[p].ls++;}
}
int main()
{
    //freopen("out.txt","w",stdout);
    //ios::sync_with_stdio(false);
    cin>>n;
    m=(n+1)>>1;
    build(1,1,n);
    for(int i=1;i<=n;i++){scanf("%d",&a[i]);b[i]=a[i];}
    sort(b+1,b+1+n);
    for(int i=1;i<=n;i++)
        if(b[i]!=b[i+1])b[++b[0]]=b[i];
    n=b[0];
    int k=lower_bound(b+1,b+n+1,a[1])-b;
    Insert(1,k,a[1]);
    query(1,1);
    for(int i=1;i<m;i++)
    {
        k=lower_bound(b+1,b+n+1,a[i<<1])-b;
        Insert(1,k,a[i<<1]);
        k=lower_bound(b+1,b+n+1,a[i<<1|1])-b;
        Insert(1,k,a[i<<1|1]);
        query(1,i+1);
    }
    return 0;
}
```
思路：[lwc](http://vixbob-lwc.pw)和[xlj](http://edgration.com)神犇教我的。

先sort一遍，每次询问向树上对应位置加入对应大小的数。因为寻找第k大的数需要一个大小顺序，所以每个数的位置都是确定的。

如果节点p的左儿子下有li个数，k>li，则k是位于右儿子的第k-li个数。否则进入左子树寻找第k个。（k是什么我想思考过的都知道吧）

其实用堆也是可以的，而且很优良。诸位巨佬已经写过了，我就不班门弄斧了。


------------


------------

这题让我学会了对拍。然而不知是写错了还是没有强制类型转换，longlong改为int后就AC了。。。

附一组数据。

```cpp
/*100
796 354 743 791 1054 1036 115 391 727 784 1027 273 45 937 384 504 29 180 307 219 944 857 325 1003 229 18 34 20 68 92 79 81 63 79 41 59 6 49 7 93 39 54 94 9 93 56 75 32 28 2 49 59 57 17 3 65 66 68 85 38 95 67 53 61 81 94 24 87 77 31 17 20 20 14 60 47 71 38 79 2 71 62 92 31 79 29 96 49 1 18 21 30 20 8 91 4 5 18 25 83*/```

---

## 作者：智之星 (赞：4)

pascal版——线段树（加快排，加二分查找）；

由于数据为10^9；故不能用线段树表示1到10^9内的数的有无（毕竟求中位数不满足裸的线段树条件——区间加法）；

可以先保留原数列，复制一遍进行快排（记得要去重）；

在从原数列中1->n中分别想线段树插入数字（此时线段树底层（该数字在快排中的位置）记录该数字出现次数）；

由此满足区间加法；



```cpp
type qwe=record
    l,r,num:longint;
end;
var tree:array[1..400000] of qwe;//线段树；
    line1,line2,line3:array[1..100000] of longint;//快排数组，去重数组（line2为最终数组）（空间有点浪费，但简单易懂）；
    n,m,j,k,l,i,b,c,l1,l2,l3:longint;
procedure qsort(l,r:longint);//快排；
var i,j,k,mid:longint;
begin
  i:=l;
  j:=r;
  mid:=line2[(l+r) div 2];
  repeat
    while line2[i]<mid do inc(i);
    while line2[j]>mid do j:=j-1;
    if i<=j then
       begin
         k:=line2[i];
         line2[i]:=line2[j];
         line2[j]:=k;
         inc(i);
         j:=j-1;
       end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
procedure bt(p,l,r:longint);//建树；
      var mid:longint;
begin
   tree[p].l:=l;
   tree[p].r:=r;
   if tree[p].l=tree[p].r then exit;
   mid:=(l+r) div 2;
   bt(2*p,l,mid);
   bt(2*p+1,mid+1,r);
end;
function find(x:longint):longint;//二分查找；
     var r,i,j,mid,l:longint;
begin
  r:=l2;
  l:=1;
  while l<r do
  begin
    mid:=(l+r)div 2;
    if line2[mid]>=x then r:=mid else l:=mid+1;
  end;
  exit(l);
end;
procedure change(p,x:longint);//插入数字；
      var i,j,mid,l:longint;
begin
  if tree[p].l=tree[p].r then
    begin
      inc(tree[p].num);
      exit;
    end;
    inc(tree[p].num);
  mid:=(tree[p].l+tree[p].r) div 2;
  if mid>=x then change(2*p,x)
  else change(2*p+1,x);
end;
function sort(p,x:longint):longint;//查找中位数；
     var mid,i,j:longint;
begin
  if tree[p].l=tree[p].r then exit(tree[p].l);
  if tree[2*p].num>=x then exit(sort(2*p,x))
  else exit(sort(2*p+1,x-tree[2*p].num));
end;
begin
    readln(n);
    for i:=1 to n do read(line1[i]);
    for i:=1 to n do line2[i]:=line1[i];
    qsort(1,n);
    line3[1]:=line2[1];
    k:=1;
    for i:=2 to n do//去重；
        if line2[i]<>line2[i-1] then
               begin
                 inc(k);
                 line3[k]:=line2[i];
               end;
    l2:=k;
    for i:=1 to n do line2[i]:=line3[i];
    bt(1,1,l2);
    for i:=1 to n do
    begin
     k:=find(line1[i]);
     change(1,k);
     if i mod 2=1 then
       begin
         k:=sort(1,(i div 2)+1);
         writeln(line2[k]);
       end;
    end;
end.
```

---

## 作者：A4paper (赞：3)

这里我给大家提供一种 $vector$ 的做法，

先上代码为敬：

```cpp
#include <vector>
#include <stdio.h>
#include <iostream>
using namespace std;
vector <int> a;
int main(void)
{
	int n,F,K=0; cin >> n;
	for(int i=1;i<=n;i++)
	{	cin >> F;
		a.insert(lower_bound(a.begin(),a.end(),F),F);
		if(!(i&1)) continue;
		cout << a[K++] << endl;
	}
	return 0;
}
```

其中利用了 $vector$ 中的 $insert()$ 函数和 $lower\_bound()$

$insert(a,b)$ 表示在 $a$ **位置前**插入元素 $b$ ，

$lower\_bound(s,t,a)$ 表示在 $s$ 到 $t$ 连续的一段中找出第一个大于等于 $a$ 的**位置**。

就是这么简单就过了！

最后，感谢[大佬](https://www.luogu.org/space/show?uid=107960)安利此题~~~

求过求过，安利[博客](https://www.luogu.org/blog/A4paper/)


---

## 作者：斯德哥尔摩 (赞：3)

看了题目，发现 Splay 是一个不错的选择。。。

（普及组巨佬的 大根堆+小根堆 表示懒得写，太烦了。。。普及巨佬不要打我。。。）

头一次写 Splay 没有 RE，开森。。。

想学 Spaly 自行右转 试炼场\_省选斗兽场\_平衡树\_Treap树

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 100010
using namespace std;
int n,root=0,c=1;
struct node{//带父亲Splay树结构体
    int son[2];
    int f,v,s,flag;
}a[MAXN];
inline int read(){//读优
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
inline void pushup(int rt){//维护
    if(!rt)return;//不要忘了判断空节点。。。
    a[rt].s=a[rt].flag;
    if(a[rt].son[0])a[rt].s+=a[a[rt].son[0]].s;
    if(a[rt].son[1])a[rt].s+=a[a[rt].son[1]].s;
}
inline void turn(int rt,int k){//正常的旋转
    int x=a[rt].f,y=a[x].f;
    a[x].son[!k]=a[rt].son[k];
    if(a[rt].son[k])a[a[rt].son[k]].f=x;
    a[rt].f=y;
    if(y)a[y].son[a[y].son[1]==x]=rt;
    a[x].f=rt;
    a[rt].son[k]=x;
    pushup(x);pushup(rt);//别忘了维护
}
void splay(int rt,int ancestry){//正常的伸展
    while(a[rt].f!=ancestry){
        int x=a[rt].f,y=a[x].f;
        if(y==ancestry)turn(rt,a[x].son[0]==rt);
        else{
            int k=a[y].son[0]==x?1:0;
            if(a[x].son[k]==rt){turn(rt,!k);turn(rt,k);}
            else{turn(x,k);turn(rt,k);}//压缩了6种情况
        }
    }
    if(ancestry==0)root=rt;//赋到根
}
void insert(int rt,int x){//插入
    int fa=0;
    while(rt&&x!=a[rt].v){
        fa=rt;
        rt=a[rt].son[a[rt].v<x];//一直向下找
    }
    if(rt)a[rt].flag++;//找到
    else{//未找到
        rt=c++;//新建
        if(fa)a[fa].son[a[fa].v<x]=rt;//与父亲连一条边
        a[rt].son[0]=a[rt].son[1]=0;
        a[rt].f=fa;a[rt].v=x;
        a[rt].s=a[rt].flag=1;//初始化
    }
    splay(rt,0);//伸展到根
}
int kth(int rt,int x){//kth基本套路。。。
    if(x>a[rt].s)return 0;//判断，好像是多余的，算了，不管了
    while(1){
        int y=a[rt].son[0];
        if(x>a[y].s+a[rt].flag){//在右边
            x-=a[y].s+a[rt].flag;
            rt=a[rt].son[1];
        }
        else if(a[y].s>=x)rt=y;//在左边
        else return a[rt].v;//已找到
    }
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){//主过程So easy!
        int x=read();
        insert(root,x);
        if(i%2)printf("%d\n",kth(root,i/2+1));//Splay大法好。。。
    }
    return 0;
}

```

---

## 作者：Right (赞：3)

其实，这道题也可以用STL水过：

虽然不建议这样做，但也是一种方法：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
int n,x;
vector<int> a;
inline int read()
{
    int x=0,f=1; char ch=getchar();
    while ((ch<'0' || ch>'9')&&ch!='-') ch=getchar();
    if (ch=='-')
    {
        f=0; ch=getchar();
    }
    while (ch>='0' && ch<='9')
    {
        x=(x<<3)+(x<<1)+ch-48; ch=getchar();
    }
    return f?x:-x;
}
int main()
{
    scanf("%d",&n);
    a.reserve(n);
    for (int i=1; i<=n; ++i)
    {
        scanf("%d",&x);
        a.insert(upper_bound(a.begin(),a.end(),x),x);
        if (i&1) printf("%d\n", a[i>>1]);
    }
}
为了水过，必须要读入优化一下，不然可能会TLE
```

---

## 作者：b_f_small_cow (赞：3)

看到这道题,我们就可以想到一个O(N2*logN)的想法:
```cpp
#include<bits/stdc++.h>//万能头万岁
using namespace std;
int a,b[100005];
int main(){
	cin>>a;
  	for(int i=1;i<=a;i++){
   		cin>>b[i];
   		sort(b+1,b+i+1);
  		if(i&1)cout<<b[(i+1)/2]<<endl;
  	}
  	return 0;
}
```
其中可以非常~~一点也不容易~~容易发现可以把sort()这个时间复杂度给优化下来

我为了~~偷懒~~方便,使用了STL里的set,每次添加进一个数,就会自动排好序，但因为set无法直接读取到其中具体的数,只能通过指针访问.所以我们可以~~一点也不自然~~自然地想到控制指针在set的中间,其中我们在set内为偶数个数时,控制指针处在i/2的位置;

一共有四种情况：

 **1:set里面为奇数个数,插入一个比中位数小的数,因为要控制指针在i/2的位置,所以指针向左移一位,it--;**

  **2:set里面为偶数个数,插入一个比中位数小的数,因为指针原本在i/2的位置,前面加进去一个数,原本的指针位置刚好就是中位数,所以不变**

  **3:set里面为偶数个数,插入一个比中位数大的数,因为指针原本在i/2的位置,后面加进去一个数,原本的指针位置是中位数后面一位,所以要把指针向右移一位,it++;**

**4:set里面为奇数个数,插入一个比中位数大的数,不变;**


以下是简化后的代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s;
multiset<int>a;//因为有可能有重复数据所以得开multiset 
multiset<int>::iterator it;
int main(){
	cin>>n;
	it=a.begin();
	for(int i=1;i<=n;i++){
		cin>>s;
		a.insert(s);//插入数据 
		if(s>*it&&!((i-1)&1))it++; //set里面为偶数个数,插入一个比中位数大的数,指针右移 
		else if(s<*it&&(i-1)&1)it--;//判断set里面为奇数个数,插入一个比中位数小的数,指针左移 
		if(i&1)cout<<*it<<endl;//判断输出 
	}
	return 0;
}
```

PS:[i&1](https://zdgodzzz.blog.luogu.org/guan-yu-i1-pan-duan-ji-ou-xing)解释;

完结撒花zzz;



---

## 作者：YouAreMySunshine (赞：3)

这题也可以用Treap做 大概就是维护size 边读边插入，然后读到1，3，5，7……个数的时候就查找中位数并输出，时间复杂度为O（nlogn）.

```cpp
#include <iostream>
#include <cstdio>
#include <ctime>
#include <cstdlib>
#include <cstring>
    using namespace std;
struct Node{
    Node *ch[2];
    int r,v,s;
    int cmp(int x) const {
        return x<v?0:1;
    }
    void maintain(){
        s=ch[0]->s+ch[1]->s+1;
    }
}*null,*root;

void rot(Node* &o,int d) {
    Node* k=o->ch[d^1];
    o->ch[d^1]=k->ch[d];
    o->maintain();
    k->maintain();
    k->ch[d]=o;
    o=k;
}
void insert(Node* &o,int x){
    if (o==null) {
        o=new Node();
        o->ch[0]=o->ch[1]=null;
        o->v=x;
        o->r=rand();
        o->maintain();
    }
    else {
        int d=o->cmp(x);
        insert(o->ch[d],x); if (o->ch[d]->r > o->r ) rot(o,d^1);
        o->maintain();
    }
}
void init(){
    null=new Node(); null->s=0; root=null;
}
void print(Node *o){
    if (o==null) return;
    print(o->ch[0]);
    printf("%d %d\n",o->v,o->s);
    print(o->ch[1]);
}
void find(Node* o,int x) {
    if (o==null) return;
    int d=o->ch[0]->s;
    if (x==d+1) {
        printf("%d\n",o->v);
        return;
    }
    if (x<d+1) find(o->ch[0],x);
    else find(o->ch[1],x-d-1);
}
int main(){
    srand(time(NULL));
    int n;
    cin>>n;
    int k;
    init();
    for (int i=1;i<=n;i++) {
        cin>>k;
        insert(root,k);
        if (i&1) find(root,i/2+1);
    }
    return 0;
}
```

---

## 作者：uniquantum (赞：2)

### 对顶堆

（个人认为较易理解的一篇题解）

维护两个堆：

1.	大根堆存储较小的一半

2.	小根堆存储较大的一半

3.	默认大根堆的$size\geq $小根堆

4.	在读入时，若该数为第奇数个，则将它入大根堆

5.	若为第偶数个，则入小根堆

6.	一旦大根堆堆顶$>$小根堆堆顶，则交换

7.	逢第奇数个输出大根堆堆顶

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return f*x;
}
int a,b,c,n;
priority_queue<int>Max;
priority_queue<int,vector<int>,greater<int> >Min;
int main()
{
	n=read();
	for(int i=1;i<=n;++i)
	{
		a=read();
		if(i&1)
		{
			Max.push(a);
		}
		else
		{
			Min.push(a);
		}
		if(!Max.empty()&&!Min.empty()&&Max.top()>Min.top())
		{
			a=Max.top();
			b=Min.top();
			Max.pop();
			Min.pop();
			Max.push(b);
			Min.push(a);
		}
		if(i&1)printf("%d\n",Max.top());
	}
	return 0;
}
```

---

## 作者：神之右大臣 (赞：2)

我来用通俗易懂的语言来讲讲对顶堆~


这个玩意是可以动态维护第k大的值，每次操作logn。

大根堆q1：维护集合中较小值的部分的最大值。

小根堆q2：维护集合中较大值的部分的最小值。

 

听不懂？没关系，接着看

为了方便，我们用鸡和凤来比喻这两个堆

换句话来说，以鸡头凤尾来比喻这两个堆，q1的堆顶就是鸡头，q2的堆顶就是凤尾；

由此可见，q2.top()>q1.top();

关于插入：

     如果新来的小崽比鸡头还厉害，那么它就进入凤堆(否则它会对上天的选择不满)；否则进入鸡堆；可以发现，这样操作并不破坏原有的特性；

关于调整：

     有时小鸡的数量比凤的数量要小得多，那么为了让凤得到优越感，她们会将凤群中的弱者打回小鸡(别问我怎么打的)，也就是把凤堆的尾巴改成鸡头，直到两者的数量处于平衡态(目前你不需要理解什么是平衡态，下面会说到)；如果反之，那么小鸡中的佼佼者便会经历涅槃成凤，成为凤尾。

关于询问:

     如果问第k大的值，我们发现,如果凤堆中一共有k只凤，那么凤尾(堆顶)便是答案,那么之前所说的调整中的平衡态便是维持凤堆中的凤的数量等于k；

 

看懂凤鸡之间的关系了吗？如果看懂了那么你就会对顶堆了；

下面简述对顶堆:

维护小根堆的数量是k，通过和大根堆之间的元素转移来维护这个性质；
对于每次询问小根堆的堆顶便是答案；

那么中位数就是动态改变k，使k=目前的总元素-1；

```cpp
#include <bits/stdc++.h>
using namespace std;
priority_queue<int> q1;
priority_queue<int, vector<int>, greater<int> > q2;
int main()
{
	int n;
	cin>>n;
	int x;
	cin>>x;
	q1.push(x);
	cout<<x<<endl;
	for(int i=2;i<=n;i++){
		int tmp;
		scanf("%d",&tmp);
		if(tmp>q1.top()){
			q2.push(tmp);
		}
		else{
			q1.push(tmp);
		}
		while (abs((int)q1.size()-(int)q2.size())>1){
			if (q1.size()>q2.size()){
				q2.push(q1.top());
				q1.pop();
			}
			else{
				q1.push(q2.top());
				q2.pop();
			}
		}               
		if(q2.size()>q1.size()){
			cout<<q2.top()<<endl;
		}
		else if(i%2!=0){
			cout<<q1.top()<<endl;
		}
	}
}
```


---

## 作者：KING__Arthur (赞：2)

###     这个题第一眼看，好像比较容易，但一开始实现起来并没有很好的思路        ~~我太弱了~~
  
  主要思路还是先建立两个queue（STL的堆），每次进来两个数，小的给A，大的给B，然后如果A最大的数比B最小的数大,执行替换语句。
   #### 其实这不是一个新颖的思路了！，好几个大佬已经在题解了提到了这种方法！
   但STL的精髓还是没有全部展现出来，所以我还是决定在发一篇这样的题解，算是蒟蒻福利了吧。
   ![](http://m.qpic.cn/psb?/V11EH39W1MoxbF/APVeXPttd4KlGJxi8FEyp1tUqnuyv8GlpR8yvuGDpcA!/b/dEABAAAAAAAA&bo=LAGoAAAAAAACd9Y!&rf=viewer_4)
   
  
  # 代码：
   ```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#include<iostream>
using namespace std;
struct cmp    
{
    inline bool operator () (int &a,int &b)//stl自带大根堆，所以小根堆需要写比较函数
    {
        return a>b;
    }
};
priority_queue<int,vector<int> >big1;//大根堆
priority_queue<int,vector<int>,cmp>small2;//小根堆
int n,x,y;
int main()
{
    cin>>n;
    cin>>x;
    big1.push(x);
    cout<<x<<endl;
    for(int i=3;i<=n;i+=2)//开始输入
    {
        cin>>x>>y;
        if(x>y)
        {
            int t=x;x=y;y=t;
        }
        big1.push(x);
        small2.push(y);
        if(big1.top()>=small2.top())
        {
            int a=big1.top(),b=small2.top();
            big1.pop();
            big1.push(b);
            small2.pop();
            small2.push(a);
        }
        cout<<big1.top()<<endl;//输出结果
    }
    return 0;
}
```
复杂度约为O（nlgn）

---

## 作者：芬特 (赞：2)

pb\_ds大法好，$p14y\_7r33把你保

这道题可以使用splay做，维护size，边插边查，使用pb\_ds内嵌的splay需要注意tree\_tag的用法，一定要挂tree\_order\_statistics\_node\_update！一定要挂tree\_order\_statistics\_node\_update！一定要挂tree\_order\_statistics\_node\_update！

大概比手写的slpay要慢上2500ms+但是编程时间要快不少，能ac就行……

```cpp
#include<iostream>
#include<stdio.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Node pair<int,int>
#pra\
gma GCC optimize("-O2")
using namespace std;
using namespace __gnu_pbds;
map<int,int>s;
tree<Node,null_type,less<Node>,splay_tree_tag,tree_order_statistics_node_update>T;

int main()
{
    ios::sync_with_stdio(false);
    int n,t,x;
    cin>>n;
    for(register int i=1;i<=n;i++)
    {
    cin>>x;
    T.insert(Node(x,s[x]++));
    if(i==1||i%2) printf("%d\n",T.find_by_order(((i+1)>>1)-1)->first);
    }            
    return 0;
}
```

---

## 作者：never_see (赞：2)

就没有正常点的题解吗？


不要总用stl


这题也没有那么麻烦


直接离散化


然后用权值线段树

只要插入

和类似于平衡树的查询第k个数


用zkw实现比较方便


```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

#define For( i , _Begin , _End ) for( int i = (_Begin) , i##END = (_End) ; i <= (i##END) ; i++ )

template< typename Type >inline void Read( Type &In ){
    In = 0;char ch = getchar();
    for( ;ch> '9'||ch< '0';ch=getchar() );
    for( ;ch>='0'&&ch<='9';ch=getchar() )In = In*10 + ch-'0';
}

static const int MAXN = 1e6;

int n;
int A[MAXN];
pair< int , int >pt[MAXN];

namespace Zkw{
    
    int M;
    int Sz[MAXN];
    
    void Insert( int x ){ for( x += M ; x ; x >>= 1 )Sz[x]++; }
    
    int Query( int x ){
        int rt = 1;
        while( rt < M )
            if( x <= Sz[ rt<<1 ] )rt <<= 1;
            else x -= Sz[ rt<<1 ] , rt = rt<<1|1;
        return pt[ rt - M ].first;
    }
    
}using namespace Zkw;

int main(){
    
    Read( n );
    For( i , 1 , n )Read( pt[i].first ) , pt[i].second = i;
    
    for( M = 1 ; M < n + 2 ; M <<= 1 );
    sort( 1 + pt , 1 + n + pt );
    For( i , 1 , n )A[ pt[i].second ] = i;
    
    For( i , 1 , n ){
        Insert( A[i] );
        if( i & 1 )printf("%d\n",Query( ( i >> 1 ) + 1 ));
    }
    
    return 0;
}
```

---

## 作者：嚯呀嚯呀 (赞：2)

题目说明很简单，能用上的数据结构也挺多，我看到楼下大佬有用单调队列的，我也没看懂怎么操作，还有平衡树啊，都写不来(你们都太强了)

但是可以写平衡树的退化版二叉排序树。
中位数就是求第（i+1） div 2 大的数，所以很显然就想到了这个数据结构。

找第K大的数就是要累计左右子树节点的个数

如果k<=左子树个数就说明在左子树里

如果k<=左子树个数加该节点个数，说明答案就是该节点

否则就在右子树里找（简单粗暴）

二叉排序树好像不能处理有相同的数，但只要没有删除操作就没有问题

有些人会说二叉排序树会退化成一个线性结构，不过根据我的亲身试验不会炸，数据还是有点水

下面看
```
var
  len:longint;
  i,j,m,n,k:longint;
  f,numl,numr,l,r,num:array[0..1000005]of longint;
procedure put(now,p:longint);
begin
  if f[now]=p then inc(num[now])
  else if f[now]>p then
    begin
      inc(numl[now]);
      if l[now]<>0 then put(l[now],p)
      else
        begin
          inc(len); l[now]:=len; f[len]:=p;
          num[len]:=1;
        end;
    end
  else
    begin
      inc(numr[now]);
      if r[now]<>0 then put(r[now],p)
      else
        begin
          inc(len); r[now]:=len; f[len]:=p;
          num[len]:=1;
        end;
    end;
end;
function get(now,tot:longint):longint;
begin
  if tot<=numl[now] then exit(get(l[now],tot))
  else if tot<=numl[now]+num[now] then exit(f[now])
  else
    exit(get(r[now],tot-numl[now]-num[now]));
end;
begin
  readln(n);
  read(k); writeln(k);
  len:=1; f[1]:=k; num[1]:=1;
  for i:=2 to n do
    begin
      read(k);
      put(1,k);
      if i mod 2=1 then
        writeln(get(1,(i+1) div 2));
    end;
end.
```




---

## 作者：Running_Coder (赞：2)

本来想找个树状数组的题练练来着。。。

找到了这题。。。

然后发现。。。

嗯，不会做，我果然是个只会打板子的蒟蒻TAT。。。

于是。。。只好用平衡树了QwQ。。。

进入正题：

这题要求以递增顺序输出那些个区间的中位数；

于是，我们就可以边读边将值插入平衡树，如果当前数是奇数个的话，那么就对整棵树求一次区间第k大并输出即可。

代码如下（传统旋转式Treap）：




    
    
    





    
        
        
    

    
    
    

    
    
    

    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cstdlib>
#include<stack>
#include<queue>
#include<vector>
#include<map>
#include<string>
#include<algorithm>
using namespace std;
void read(int &x){
    x=0;
    char t=getchar();
    bool f=0;
    while(t<'0' || t>'9'){
        if(t=='-')f=1;
        t=getchar();
    }
    while(t>='0' && t<='9'){
        x=(x<<3)+(x<<1)+t-'0';
        t=getchar();
    }
    if(f)x=-x;
}
struct node{
    int key,yx;
    int size,num;
    node *ch[2];
};
void rotate(node* &,bool);
void insert(node* &,int);
int kth(node *,int);
node *root=NULL;
int n,t,i;
int main(){
    read(n);
    for(i=1;i<=n;i++){
        read(t);
        insert(root,t);
        if(i&1)printf("%d\n",kth(root,(i>>1)+1));
    }
    return 0;
}
void rotate(node* &p,bool f){
    node *t=p->ch[f^1];
    p->ch[f^1]=t->ch[f];
    t->ch[f]=p;
    p->size=p->num;
    if(p->ch[0]!=NULL)p->size+=p->ch[0]->size;
    if(p->ch[1]!=NULL)p->size+=p->ch[1]->size;
    t->size=t->num;
    if(t->ch[0]!=NULL)t->size+=t->ch[0]->size;
    if(t->ch[1]!=NULL)t->size+=t->ch[1]->size;
    p=t;
}
void insert(node* &p,int x){
    if(p==NULL){
        p=(node *)malloc(sizeof(node));
        p->key=x;
        p->yx=rand();
        p->size=p->num=1;
        p->ch[0]=p->ch[1]=NULL;
        return;
    }
    if(x==p->key){
        p->size++;
        p->num++;
        return;
    }
    if(x<p->key){
        insert(p->ch[0],x);
        if(p->ch[0]->yx<p->yx)rotate(p,1);
        else p->size++;
    }
    else{
        insert(p->ch[1],x);
        if(p->ch[1]->yx<p->yx)rotate(p,0);
        else p->size++;
    }
}
int kth(node *p,int x){
    int s=0;
    if(p->ch[0]!=NULL)s=p->ch[0]->size;
    if(x<=s)return kth(p->ch[0],x);
    else if(x<=s+p->num)return p->key;
    else return kth(p->ch[1],x-s-p->num);
}
```

---

## 作者：why_always_china (赞：2)

维护两个堆，一个大根堆存放<=中位数的值，小根堆存放>=中位数的值，保证小根堆比大根堆规模大1。

维护的时候可以先根据上次mid暴力插入，再调整规模。复杂度显然是O(nlogn)的。

放两个版本的

手写堆

```cpp

#include<cstdio>
#include<algorithm>
#define maxn 200009
using namespace std;
int a[maxn], b[maxn], len = 0, len2 = 0;
void add(int x){
    a[++len] = x; int p = len;
    while (p > 1 && a[p >> 1] > a[p]) {swap(a[p], a[p >> 1]);p >>= 1;}
}
int put(){
    int x = a[1], p = 1, son; a[1] = a[len--];
    while ((p << 1) <= len){
        son = p << 1;
        if (son < len && a[son + 1] < a[son]) ++son;
        if (a[son] < a[p]) {
            swap(a[p], a[son]);
            p = son;
        }
        else p = len + 1;
    }
    return x;
}
void add2(int x){
    b[++len2] = x; int p = len2;
    while (p > 1 && b[p >> 1] < b[p]) {swap(b[p], b[p >> 1]);p >>= 1;}
}
int put2(){
    int x = b[1], p = 1, son; b[1] = b[len2--];
    while ((p << 1) <= len2){
        son = p << 1;
        if (son < len2 && b[son + 1] > b[son]) ++son;
        if (b[son] > b[p]) {
            swap(b[p], b[son]);
            p = son;
        }
        else p = len2 + 1;
    }
    return x;
}
int main(){
    int n, x1, x2, mid;
    scanf("%d", &n);
    scanf("%d", &x1);
    add(x1); printf("%d\n", mid = x1);
    for (int i = 1; i <= ((n-1)>>1); i++){
        scanf("%d%d", &x1, &x2);
        if (x1 < mid)add2(x1); else add(x1);
        if (x2 < mid)add2(x2); else add(x2);
        while (len2 >= len) add(put2());
        while (len2 < len - 1) add2(put());
        printf("%d\n", mid = a[1]);
    }
    return 0;
}


```


STL大法好

```cpp

#include<cstdio>
#include<queue>
#define ins(x) ((x) < mid ? L.push(x) : R.push(x))
using namespace std;
priority_queue<int> L;
priority_queue<int, vector<int>, greater<int> > R;
int main(){
    int n, x1, x2, mid;
    scanf("%d%d", &n, &x1);
    R.push(x1);
    printf("%d\n", mid = x1);
    for (int i = 1; i <= ((n-1)>>1); i++){
        scanf("%d%d", &x1, &x2);
        ins(x1); ins(x2);
        while (L.size() >= R.size()) {R.push(L.top()); L.pop();}
        while (L.size() < R.size() - 1){L.push(R.top()); R.pop();}
        printf("%d\n", mid = R.top());
    }
    return 0;
}


```

---

## 作者：life_w_back (赞：2)

## 区间查询平衡树是一个高效的方法
## 下面是平衡树做法

------------

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<queue>
#include<vector>
#include<cstring>
#include<cmath>
using namespace std;
const int INF=0x4f4f4f4f;
int pool,rt;
struct tree{
    int lc,rc,key,pri,cnt,sze;
    #define lc(x)t[x].lc
    #define rc(x)t[x].rc
    #define v(x)t[x].key
    #define p(x)t[x].pri
    #define c(x)t[x].cnt
    #define s(x)t[x].sze
}t[1000010];
inline int read(){
    int out=0,flag=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')flag=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        out=out*10+c-'0';
        c=getchar();
    }
    return flag*out;
}
inline void Upt(const int &k){
    s(k)=s(lc(k))+s(rc(k))+c(k);
}
inline void Zig(int &k){    //右旋
    int y=lc(k);
    lc(k)=rc(y);
    rc(y)=k;
    s(y)=s(k);
    Upt(k);
    k=y;
}
inline void Zag(int &k){    //左旋
    int y=rc(k);
    rc(k)=lc(y);
    lc(y)=k;
    s(y)=s(k);
    Upt(k);
    k=y;
}
inline void Insert(int &k,const int &key){    //插入
    if(!k){
        k=++pool;
        v(k)=key;
        p(k)=rand();
        c(k)=1;
        s(k)=1;
        lc(k)=0;
        rc(k)=0;
        return ;
    }
    else ++s(k);
    if(v(k)==key) ++c(k);
    else if(key<v(k)){
        Insert(lc(k),key);
        if(p(lc(k))<p(k)) Zig(k);
    }
    else {
        Insert(rc(k),key);
        if(p(rc(k))<p(k)) Zag(k);
    }
    return ;
}
inline int Kth(int k){     //查询排名为K的数，求中位数。
    int x=rt;
    while(x){
        if(s(lc(x))<k&&s(lc(x))+c(x)>=k) return v(x);
        if(s(lc(x))>=k) x=lc(x);
        if(s(lc(x))+c(x)<k){
            k-=s(lc(x))+c(x);
            x=rc(x);
        }
    }
    return 0;
}
int main(){
    int n,m,x=1;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&m);
        Insert(rt,m);
        if(i%2==1){      //个数为奇数
            printf("%d\n",Kth(x));
            x++;       //每个区间的中位数。
        }
    }
    return 0;
}
```

---

## 作者：老咸鱼了 (赞：1)

题解区里面区间第K大求法好像都是用主席树写的，其实线段树也是能求区间第K大的，只是速度上不如主席树，这里介绍线段树的区间第K大求法。

建树部分和归并排序很像，把每个子区间的第K大求出来
```cpp
void build(int p,int l,int r)
{
	if(l==r)
	{
		q[p].push_back(0);
		q[p].push_back(a[l]);
		return ;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	int ls=q[p<<1].size()-1,rs=q[p<<1|1].size()-1;
	q[p].push_back(0);
	int i=1,j=1;
	while(i<=ls&&j<=rs)
	{
		if(q[p<<1][i]<q[p<<1|1][j])		
		q[p].push_back(q[p<<1][i++]);		
		else
		q[p].push_back(q[p<<1|1][j++]);
	}
	while(i<=ls)
	q[p].push_back(q[p<<1][i++]);
	while(j<=rs)
	q[p].push_back(q[p<<1|1][j++]);
	return ;
}
```

查找的话就是二分查找了，因为我们之前已经算好了每个区间内的数的大小，因为已经排好序了，所以我们只要通过判断小于他的数有没有K个来判断就行了，有的话右移，没有的话左移。
```cpp
int serch(int l,int r,int k)
{
	int L=0,R=0x7fffffff;
	int num=a[l];
	while(L<=R)
	{
		int mid=(L+R)>>1;
		if(query(1,1,n,l,r,mid)>=k)
		{
			num=mid;
			R=mid-1;
		}
		else
		L=mid+1;
	}
	return num;
}
```

注意数组要用不定长数组，不然n^2的空间开不了那么大。

最后附上完整代码因为数据比较大，所以通过的非常极限，~~我同一份代码第一次T了2个点，第二次才通过的~~

```cpp
#include<bits/stdc++.h>
#define N 555555
using namespace std;
int n,m;
int a[N];
vector<int>q[N];
int read()//加快读，不加快读可能都过不去。
{
	int s=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		s=(s<<3)+(s<<1)+c-'0';
		c=getchar();
	}
	return s*f;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		q[p].push_back(0);
		q[p].push_back(a[l]);
		return ;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	int ls=q[p<<1].size()-1,rs=q[p<<1|1].size()-1;
	q[p].push_back(0);
	int i=1,j=1;
	while(i<=ls&&j<=rs)
	{
		if(q[p<<1][i]<q[p<<1|1][j])		
		q[p].push_back(q[p<<1][i++]);		
		else
		q[p].push_back(q[p<<1|1][j++]);
	}
	while(i<=ls)
	q[p].push_back(q[p<<1][i++]);
	while(j<=rs)
	q[p].push_back(q[p<<1|1][j++]);
	return ;
}
int low_bound(int p,int k)
{
	int l=1,r=q[p].size()-1,ans=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(q[p][mid]<=k)
		{
			l=mid+1;
			ans=mid;
		}
		else
		r=mid-1;
	}
	return ans;
}
int query(int p,int l,int r,int L,int R,int k)
{
	if(R<l||r<L)
	return 0;
	if(l>=L&&R>=r)
	{
		return low_bound(p,k);
	}
	int mid=(l+r)>>1;
	return query(p<<1,l,mid,L,R,k)+query(p<<1|1,mid+1,r,L,R,k);
}
int serch(int l,int r,int k)
{
	int L=0,R=0x7fffffff;//可能把R开小点能快点？？数据1e9
	int num=a[l];
	while(L<=R)
	{
		int mid=(L+R)>>1;
		if(query(1,1,n,l,r,mid)>=k)
		{
			num=mid;
			R=mid-1;
		}
		else
		L=mid+1;
	}
	return num;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	a[i]=read();
	build(1,1,n);
	for(int i=1;i<=n;i+=2)
	{
		printf("%d\n",serch(1,i,((i>>1)+1)));
	}
	return 0;
}
```
~~这个不是本题正解，建议大家还是去写正解，毕竟题目数据有点大~~

---

## 作者：Jelly_Goat (赞：1)

~~尝试在一个大佬众多的题解区写动态中位数QAQ~~  

-------

首先先想想我们能怎么做

最暴力的大概是每次加入数字，sort，奇数输出

然后复杂度是$O(n^2logn)$

再想想

我们会二分

那么vector就可以做

复杂度$O(nlogn)$

但是注意常数有点大

另外能过普通平衡树那个题的算法基本都行

线段树（动态开点或者不开点离散化都行），平衡树，树状数组应该都是$O(nlogn)$

然而回归本心

动态中位数，经典做法是**对顶堆**

--------

对顶堆，顾名思义，两个堆的顶端相对构成原先的数列

左边一个堆是大根堆，存放小的一半数字  
右边一个堆是小根堆，存放大的一半数字  

中间两个数字保证其中一个或者两个堆顶的平均值构成中位数

每次拿到一个新的数字对应插入堆里  
注意插入的堆要判断一下：  
1. 如果比右面堆顶要大，那就插入到右边  
2. 如果比左面堆顶小，那就插入到左边   
3. 如果介于两者之间，那就随心情挑一个

然后根据堆内元素的个数进行平衡  
如果个数差大于1，那么从多的里面取出顶来放到另外一个里面

然后二叉堆、左偏树、配对堆....都行...  
~~由于小金羊太菜了就只能写二叉堆~~  
反正保证弹出和插入最多$O(logn)$的堆都可以胜任  
不过STL的优先队列常数实在是太大了QAQ  
~~再加上RE无数遍，小金羊的内心收到的`打击*n`~~  
就手写二叉堆了QAQ

--------

code:
```cpp
#include <iostream>
#include <string>
#include <cstdio>
#include <algorithm>

using namespace std;
typedef long long int lli;
template <class Tp>
inline void Read(Tp &num)
{
    num = 0;
    char ch = getchar();
    bool flag = false;
    while (!isdigit(ch))
        flag |= ch == '-', ch = getchar();
    while (isdigit(ch))
        num = (num << 1) + (num << 3) + (ch ^ 48), ch = getchar();
    if (flag)
        num *= -1;
}
struct Heap1
{ // 小根堆，是大的一边
    lli data[250043];
    int cnt;
    lli Top()
    {
        return data[1];
    }
    lli Size()
    {
        return cnt;
    }
    void update(int pos)
    {
        while (true)
        {
            if (pos == 1)
                break;
            if (data[pos] < data[pos >> 1])
            {
                swap(data[pos], data[pos >> 1]);
                pos >>= 1;
            }
            else
                break;
        }
    }
    void downdate(int pos)
    {
        while (true)
        {
            if ((pos << 1) > cnt)
                break;
            int son = pos << 1;
            if ((pos << 1 | 1) <= cnt && data[pos << 1 | 1] < data[son])
                son = pos << 1 | 1;
            if (data[pos] > data[son])
            {
                swap(data[son], data[pos]);
                pos = son;
            }
            else
                break;
        }
    }
    void Push(lli val)
    {
        data[++cnt] = val;
        update(cnt);
    }
    void Pop()
    {
        if (cnt == 0)
            return;
        swap(data[1], data[cnt]);
        cnt--;
        downdate(1);
    }
};
struct Heap2
{ // 大根堆，是小的一边
    lli data[250043];
    int cnt;
    lli Top()
    {
        return data[1];
    }
    lli Size()
    {
        return cnt;
    }
    void update(int pos)
    {
        while (true)
        {
            if (pos == 1)
                break;
            if (data[pos] > data[pos >> 1])
            {
                swap(data[pos], data[pos >> 1]);
                pos >>= 1;
            }
            else
                break;
        }
    }
    void downdate(int pos)
    {
        while (true)
        {
            if ((pos << 1) > cnt)
                break;
            int son = pos << 1;
            if ((pos << 1 | 1) <= cnt && data[pos << 1 | 1] > data[son])
                son = pos << 1 | 1;
            if (data[pos] < data[son])
            {
                swap(data[son], data[pos]);
                pos = son;
            }
            else
                break;
        }
    }
    void Push(lli val)
    {
        data[++cnt] = val;
        update(cnt);
    }
    void Pop()
    {
        if (cnt == 0)
            return;
        swap(data[1], data[cnt]);
        cnt--;
        downdate(1);
    }
};
Heap2 little; //小的半边
Heap1 big;    //大的半边

void stabler() //平衡两个堆
{
    while (big.Size() - little.Size() > 1)
    {
        little.Push(big.Top());
        big.Pop();
    }
    while (little.Size() - big.Size() > 1)
    {
        big.Push(little.Top());
        little.Pop();
    }
}

inline void Print() //输出
{
    if (little.Size() > big.Size())
        printf("%lld\n", little.Top());
    else if (big.Size() > little.Size())
        printf("%lld\n", big.Top());
    else
    {
        if ((little.Top() + big.Top()) & 1)
            printf("%lld.5\n", (little.Top() + big.Top()) >> 1);
        else
            printf("%lld\n", (little.Top() + big.Top()) >> 1);
    }
}

int main()
{
    // freopen("mid.in","r",stdin);
    // freopen("mid.out","w+",stdout);
    int n;
    Read(n);
    for (int i = 1; i <= n; i++)
    {
        int num;
        Read(num);
        if (num < big.Top())
        {
            little.Push(num);
        }
        else
        {
            big.Push(num);
        }
        stabler();
        if (i & 1) // 奇数个数字输入后输出
            Print();
    }
    return 0;
}
```

------

关于这个题没有提及的

是如果两个堆个数一样多时  

输出两个堆顶的平均数（带小数`.5`）  

这个我也写到`print()`里面了

~~偷偷撒花~~

---

## 作者：蔡俊黠 (赞：1)

#### 刚刚学了priority_queue，就拿这道题来练练手吧！
一般的小根堆或大根堆都是存一组数的最大或最小值，可是这道题要求的是输出中位数，怎么办呢？
# 把堆切开来！
hhh别慌，就是第一篇题解所说的建两个堆，一个是大根堆，一个是小根堆

小根堆的堆顶是较大的数中最小的，大根堆的堆顶是较小的数中最大的

这样一来答案就是小根堆的堆顶，因为小根堆内的元素个数要不就是等于大根堆的元素个数（当i为偶数时），要不就是比大根堆的元素个数多1（当i为奇数时）

当两个堆的元素个数不符合我们的要求的时候，就把多的那堆的堆顶分给少的那堆的堆顶

#### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
priority_queue <int> q1;//大根堆 
priority_queue <int ,vector<int>,greater<int> > q2;//小根堆 
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		int a;
		scanf("%d",&a);
		if (i==1) //特判 
		{
			q1.push(a);
			printf("%d\n",a);
			continue;
		}
		if (a<=q1.top()) q1.push(a);
		else q2.push(a); 
		 /*q1小根堆的堆顶是较大的数中最小的，q2大根堆的堆顶是较小的数中最大的
		   所以当a小于等于q1的堆顶时，也就是a比q1中所有的数都小，就放进q1中
		   否则a比q2的堆顶大，放进q2 
		 */
		while (q2.size()>q1.size()) 
		{
			q1.push(q2.top());
			q2.pop();
		}
		while (q1.size()>q2.size()+1) 
		//q2.size()+1是因为当i为奇数的时候q1的元素个数总是要比q2的元素个数大1 
		{
			q2.push(q1.top());
			q1.pop();
		} 
		if (i%2!=0) printf("%d\n",q1.top()); //i为奇数的时候q1的堆顶就是答案 
	}
	return 0;
}
```

最后欢迎来康康俺的[CSDN](https://blog.csdn.net/weixin_45485187/article/list/1)博客啊★~★

---

## 作者：loceaner (赞：1)

## 思路

用两个优先队列，一个大根堆，一个小根堆

这里我们要保证小根堆里的数都比大根堆里的数要大，每次输入一个数，看这个树是否比大根堆的堆顶要大，如果比大根堆堆顶大的话放进小根堆中，否则放入大根堆中

如果两个堆中元素个数差大于了1，那就看看是哪个堆的元素更多一些，将这个元素的堆顶放到另一个堆中，保证了两个堆的堆顶之中一定有一个数是目前中位数，然后输出的时候看看哪个堆元素多输出哪个堆的堆顶就好了

需要注意的是，第一个数需要特殊处理，直接输出即可

还有就是，在洛谷上用$size()$函数不行，会$CE$，所以这里用了两个$cnt$


## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f;
}

priority_queue<int> qb;
priority_queue<int, vector<int>, greater<int> > qs;
int n, topp, a, cnts, cntb;

int main() {
	n = read();
	topp = read();
	qb.push(topp);
	cntb++;
	cout << qb.top() << '\n';
	for(int i = 2; i <= n; i++) {
		a = read();
		if(a > qb.top()) qs.push(a), cnts++;
		else qb.push(a), cntb++;
		while(abs(cntb - cnts) > 1) {
			if(cntb > cnts) {
				qs.push(qb.top());
				cnts++;
				qb.pop();
				cntb--;
			}
			else {
				qb.push(qs.top());
				cntb++;
				qs.pop();
				cnts--;
			}
		}
		if(i & 1) printf("%d\n", cntb > cnts ? qb.top() : qs.top());
	}
	return 0;
}
```

---

## 作者：Zofia (赞：1)

平衡树可以查询排名为k的元素,中位数就是排名为（当前i）i/2+1的元素嘛;
~~Slay~~Splay是一种很稳的平衡树,当然其他平衡树也是可以的，不会的同学可以去[学习一个，提高一下自己的姿势水平](https://www.luogu.org/problem/P3369)

所以直接按照题意模拟就完事了:

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;

class Splaybuild{

    private:

        #define root tree[0].ch[1]
        
        struct Splaynode{
            int v,fa,rec,size;
            int ch[2];
        }tree[1000001];
        int ni;

        inline void Connect(int id,int fid,int son){
            tree[fid].ch[son]=id;
            tree[id].fa=fid;
        }

        inline void update(int p){
            tree[p].size=tree[tree[p].ch[0]].size+tree[tree[p].ch[1]].size+tree[p].rec;
        }

        inline void Rotate(int x){
            int y=tree[x].fa,z=tree[y].fa;
            int p,q;
            if(x==tree[y].ch[1]){p=1;}
            else{p=0;}
            if(y==tree[z].ch[1]){q=1;}
            else{q=0;}
            Connect(tree[x].ch[p^1],y,p);
            Connect(y,x,p^1);
            Connect(x,z,q);update(y);update(x);
        }

        inline void Splay(int x,int to){
            int father=tree[to].fa;
            while(tree[x].fa!=father){
                int y=tree[x].fa,z=tree[y].fa;
                int p,q;
                if(x==tree[y].ch[1]){p=1;}
                else{p=0;}
                if(y==tree[z].ch[1]){q=1;}
                else{q=0;}
                if(to==y){Rotate(x);}//到任意点to;
                else if(p==q){
                    Rotate(y);Rotate(x);
                }else{
                    Rotate(x);Rotate(x);
                }
            }
        }

        inline int find(int v){
            int p=root;
            while(p!=0){
                if(tree[p].v==v){Splay(p,root);return p;}
                if(tree[p].v<v){p=tree[p].ch[1];}
                else{p=tree[p].ch[0];}
            }return 0;
        }

        inline void addnode(int fa,int v){
            tree[++ni].v=v;
            tree[ni].fa=fa;
            tree[ni].rec++;
            tree[ni].size++;
        }

    public:

        inline void insert(int v){
            int p=root,nodeid;
            if(root==0){addnode(0,v);root=ni;return;}
            while(p!=0){
                tree[p].size++;
                if(v==tree[p].v){nodeid=p;tree[p].rec++;break;}
                if(v<tree[p].v){
                    if(tree[p].ch[0]==0){
                        addnode(p,v);nodeid=tree[p].ch[0]=ni;break;
                    }else{p=tree[p].ch[0];}
                }else if(v>tree[p].v){
                    if(tree[p].ch[1]==0){
                        addnode(p,v);nodeid=tree[p].ch[1]=ni;break;
                    }else{p=tree[p].ch[1];}
                }
            }Splay(nodeid,root);
        }

        inline void erase(int v){
            int id=find(v);if(id==0){return;}
            if(tree[id].rec>1){tree[id].rec--;tree[id].size--;}
            else if(id!=0){
                if(tree[id].ch[0]==0&&tree[id].ch[1]==0){
                    root=0;
                }else if(tree[id].ch[0]&&tree[id].ch[1]==0){
                    Connect(tree[id].ch[0],0,1);
                }else if(tree[id].ch[1]&&tree[id].ch[0]==0){
                    Connect(tree[id].ch[1],0,1);
                }else{
                    int maxson=tree[id].ch[0];
                    while(tree[maxson].ch[1]!=0){
                        tree[maxson].size--;
                        maxson=tree[maxson].ch[1];
                    }Splay(maxson,root);
                    Connect(tree[id].ch[1],maxson,1);
                    Connect(maxson,0,1);//接到根上;
                    update(maxson);
                }
            }
        }

        inline int levelquery(int v){
            int id=find(v);
            return tree[tree[id].ch[0]].size+1;
        }

        inline int valquery(int i){
            int p=root;
            while(p!=0){
                int size=tree[tree[p].ch[0]].size;
                if(size<i&&size+tree[p].rec>=i){
                    Splay(p,root);return tree[p].v;
                }else if(size+tree[p].rec<i){
                    i-=size+tree[p].rec;p=tree[p].ch[1];
                }else{
                    p=tree[p].ch[0];
                }
            }return 0;
        }

        inline int frontsearch(int v){
            int p=root,re=0x80000000;
            while(p!=0){
                if(tree[p].v>=v){
                    p=tree[p].ch[0];
                }else{
                    re=max(re,tree[p].v);
                    p=tree[p].ch[1];
                }
            }return re;
        }

        inline int backsearch(int v){
            int p=root,re=0x7fffffff;
            while(p!=0){
                if(tree[p].v>v){
                    re=min(re,tree[p].v);
                    p=tree[p].ch[0];
                }else{
                    p=tree[p].ch[1];
                }
            }return re;
        }

        inline int frontquery(int v){//非严格前驱;
            if(find(v)){return v;}
            else{return Frontsearch(v);}
        }

        inline int backquery(int v){//非严格后驱;
            if(find(v)){return v;}
            else{return Backsearch(v);}
        }
}s;//封装了一发

inline int read(){
	int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){f=-1;}ch=getchar();
    }while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);ch=getchar();
    }return x*f;
}

int main(){
	n=read();
	for(int i=1;i<=n;i++){
		s.insert(read());
		if(i&1){printf("%d\n",s.valquery(i/2+1));}
	}return 0;
}
```


---

## 作者：星之海 (赞：1)

呀  
这道题  
一看就是  
我们熟知的  **主席树**  啊！  
求中位数也就是求在一段区间中第k位数  
~~骚气冲天~~的主席树便可以解决诸类问题  
好吧，上AC代码 
```cpp
//这就是主席树模板，我认为没有什么要解释的，直接套模板就能出来
#include<algorithm>
#include<iostream>
#include<cstdio>
#define N 100010
using namespace std;
int n,tot,size,a[N],b[N],rt[N],lc[N<<5],rc[N<<5],sum[N<<5];
int build(int l,int r)//建树
{
    int now=++tot;
    sum[now]=0;
    if(l==r)
	return now;
    int mid=(l+r)>>1;
    lc[now]=build(l,mid);
    rc[now]=build(mid+1,r);
    return now;
}
int fun(int x)
{
	return lower_bound(b+1,b+1+size,x)-b;
    //不了解lower_bound的，戳本文末尾的诡异蓝字
}
void modify(int l,int r,int x,int &y,int t)
{
    y=++tot;
    sum[y]=sum[x]+1;
    if(l==r)
	return;
    lc[y]=lc[x];
    rc[y]=rc[x];
    int mid=(l+r)>>1;
    if(t<=mid)
	modify(l,mid,lc[x],lc[y],t);
    else
	modify(mid+1,r,rc[x],rc[y],t);
}
int query(int l,int r,int x,int y,int k)
{
    if(l==r) return l;
    int mid=(l+r)>>1;
    if(sum[lc[y]]-sum[lc[x]]>=k)
	return query(l,mid,lc[x],lc[y],k);
    else
	{
		k-=sum[lc[y]]-sum[lc[x]];
		return query(mid+1,r,rc[x],rc[y],k);
	} 
}
int main()
{
	int i;
    cin>>n;
    for(i=1;i<=n;++i)
	cin>>a[i],b[i]=a[i];
    sort(b+1,b+1+n);
    size=unique(b+1,b+1+n)-b-1;//离散b
    rt[0]=build(1,size);
    for(i=1;i<=n;++i)
	modify(1,size,rt[i-1],rt[i],fun(a[i]));
    for(i=1;i<=n;i+=2)
    cout<<b[query(1,size,rt[0],rt[i],i/2+1)]<<endl;
    return 0;
}
```
https://baike.so.com/doc/5146817-5376788.html

---

## 作者：water_mi (赞：1)

这一题核心在于为什么可以用堆做，下面的大佬们貌似并没有人详细地说明原因：

这道题重点在于：数据量大，数据无序，排序一般超时。

假设我们并不知道此题可以用堆去做。

首先，我们至少可以知道，第一个数字肯定是一个中位数，我们可以把它置为第一个中位数

在一串升序数列中，任意一个数它左边的数总是小于等于它，右边的数总是大于等于它

又因为k始终为一个奇数，所以，其任意一个中位数,左边数的个数恒等于右边数的个数

这时，我们需要一个数据结构去维护它，从上面的废话中摘取几个有效条件：

1.任意一个数它左边的数总是小于等于它，右边的数总是大于等于它

2.任意一个中位数,左边数的个数恒等于右边数的个数

经过一系列暴力搜索所有数据结构的定义，堆显然是满足上述条件的：

1.大根堆中，根永远是最大的，符合：左边的数总是小于等于它

2.小根堆中，根永远是最小的，符合：右边的数总是大于等于它

为了更好地保证左边数的个数恒等于右边数的个数，所以，我们需要一次循环读入两个数

当其中某一个数字大于当前中位数时，把它放入小根堆，反之亦反

当然，由于k恒为一奇数，所以，不可能使得左边数的个数恒等于右边数的个数，但这并不要紧

我们可以令大根堆的根为中位数（其实也可以令小根堆的根为中位数 PS：下面有大佬写了）

令big\_heap为大根堆，lit\_heap为小根堆，对应的，lit\_heap\_size = big\_heap\_size - 1

接下来要做的，就是继续维护这两个堆，使得：lit\_heap\_size = big\_heap\_size - 1

当lit\_heap\_size > big\_heap\_size - 1(lit\_heap\_size >= big\_heap\_size)时：

将小根堆中的最小值移向大根堆。

当lit\_heap\_size < big\_heap\_size - 1时：

将大根堆中的最大值移向小根堆。

则上述过程过后，大根堆中的根，即为答案。

```cpp
#include<cstdio>
void swap(int &a,int &b){int tmp = a;a = b;b = tmp;}
int n,value,val,big_heap[100010],lit_heap[100010],big_heap_size,lit_heap_size,mid;
void big_put(int v){
    big_heap[++big_heap_size] = v;
    int now = big_heap_size,next;
    while(now > 1){
        next = now >> 1;
        if(big_heap[now] <= big_heap[next]) return;
        swap(big_heap[next],big_heap[now]);
        now = next;
    }
}
int big_get(){
    int now = 1,next,v = big_heap[1];
    big_heap[1] = big_heap[big_heap_size--];
    while(now << 1 <= big_heap_size){
        next = now << 1;
        if(next < big_heap_size && big_heap[next + 1] > big_heap[next]) next++;
        if(big_heap[now] >= big_heap[next]) break;
        swap(big_heap[next],big_heap[now]);
        now = next;
    }
    return v;
}
void lit_put(int v){
    lit_heap[++lit_heap_size] = v;
    int now = lit_heap_size,next;
    while(now > 1){
        next = now >> 1;
        if(lit_heap[now] >= lit_heap[next]) return;
        swap(lit_heap[next],lit_heap[now]);
        now = next;
    }
} 
int lit_get(){
    int now = 1,next,v = lit_heap[1];
    lit_heap[1] = lit_heap[lit_heap_size--];
    while(now << 1 <= lit_heap_size){
        next = now << 1;
        if(next < lit_heap_size && lit_heap[next + 1] < lit_heap[next]) next++;
        if(lit_heap[now] <= lit_heap[next]) break;
        swap(lit_heap[next],lit_heap[now]);
        now = next;
    }
    return v;
}
//日常堆操作 
int main(){
    scanf("%d %d",&n,&value);
    big_put(value);//将第一个中位数置入大根堆中 
    printf("%d",mid = value);//巧妙地输出 
    //i << 1 < n表示i * 2 <= n - 1
    for(int i = 1;i << 1 < n;i++){
        scanf("%d %d",&value,&val);
        if(value > mid) lit_put(value); else big_put(value);
        if(val > mid) lit_put(val); else big_put(val);
        if(lit_heap_size >= big_heap_size) big_put(lit_get());
        if(lit_heap_size < big_heap_size - 1) lit_put(big_get());
        printf("\n%d",mid = big_heap[1]);//将大根堆中的根置为新的中位数
        //详情请见分析 
    }
    return 0;
}
```
【接下来的内容不建议大家食用】STL版本

```cpp
#include<cstdio>
#include<iterator>
#include<algorithm>
void swap(int &a,int &b){int tmp = a;a = b;b = tmp;}
int n,value,val,big_heap[100010],lit_heap[100010],big_heap_size,lit_heap_size,mid;
void big_put(int v){
    big_heap[++big_heap_size] = v;
    std::push_heap(big_heap + 1,big_heap + big_heap_size + 1);
}
int big_get(){
    std::pop_heap(big_heap + 1,big_heap + big_heap_size + 1);
    return big_heap[big_heap_size--];
}
void lit_put(int v){
    lit_heap[++lit_heap_size] = v;
    std::push_heap(lit_heap + 1,lit_heap + lit_heap_size + 1,std::greater<int>());
} 
int lit_get(){
    std::pop_heap(lit_heap + 1,lit_heap + lit_heap_size + 1,std::greater<int>());
    return lit_heap[lit_heap_size--];
}
//STL堆操作 
int main(){
    scanf("%d %d",&n,&value);
    big_put(value);//将第一个中位数置入大根堆中 
    printf("%d",mid = value);//巧妙地输出 
    //i << 1 < n表示i * 2 <= n - 1
    for(int i = 1;i << 1 < n;i++){
        scanf("%d %d",&value,&val);
        if(value > mid) lit_put(value); else big_put(value);
        if(val > mid) lit_put(val); else big_put(val);
        if(lit_heap_size >= big_heap_size) big_put(lit_get());
        if(lit_heap_size < big_heap_size - 1) lit_put(big_get());
        printf("\n%d",mid = big_heap[1]);//将大根堆中的根置为新的中位数
        //详情请见分析 
    }
    return 0;
}
```

---

## 作者：pupuvovovovovo (赞：1)

某蒟蒻不会平衡树。。

手写BIT+Binary还炸掉了。。

于是写heap，跑得贼快，共150ms上下。

参照楼下一位大佬的思路，现在详细的阐释一下。

就是维护两个堆，一个小根堆，一个大根堆，并保证如下几点：

1、开始时小根堆有一个元素a[1]，大根堆为空；

2、每步插入共两个元素；

3、每步操作后，保证小根堆规模比大根堆规模大1，且小根堆顶>=大根堆顶。

这样每次中位数就是小根堆顶。

 ![](https://cdn.luogu.com.cn/upload/pic/6273.png) 

插入数的时候，每次一个，与小、大根堆顶比较，决定插入哪个堆。

（这是本蒟蒻想到的办法，可能还有更优方式，不喜勿喷）

···cpp

```cpp
#include<bits/stdc++.h>
#define mem(a) memset(a,0,sizeof(a))
using namespace std;
int t;
void Swap(int &x,int &y){
    t=x;
    x=y;
    y=t;
}//STL的swap慢得有理有据，所以手写
struct b_heap{
    int a[50010],top,i,k;//开一半就够
    int getop(){
        return a[1];
    }
    void up(int x){
        while (x>1){
            i=x>>1;
            if (a[i]<a[x]){
                Swap(a[i],a[x]);
                x=i;
            }else break;
        }
    }
    int maxi(int x,int y){
        if (y>top||a[x]>a[y]) return x;
        return y;
    }
    void down(){
        k=1;
        while (k<<1<=top){
            i=maxi(k<<1,k<<1|1);
            if (a[i]>a[k]){
                Swap(a[i],a[k]);
                k=i;
            }else break;
        }
    }
    void ins(int x){
        a[++top]=x;
        up(top);
    }
    void del(){
        a[1]=a[top];
        a[top--]=0;
        down();
    }
    void clear(){
        mem(a);
        top=0;
    }
    void print(){
        for (i=1;i<=top;i++) printf("%d ",a[i]);
        printf("\n");
    }
}bd;
struct s_heap{
    int a[50010],top,i,k;
    int getop(){
        return a[1];
    }
    void up(int x){
        while (x>1){
            i=x>>1;
            if (a[i]>a[x]){
                Swap(a[i],a[x]);
                x=i;
            }else break;
        }
    }
    int mini(int x,int y){
        if (y>top||a[x]<a[y]) return x;
        return y;
    }
    void down(){
        k=1;
        while (k<<1<=top){
            i=mini(k<<1,k<<1|1);
            if (a[i]<a[k]){
                Swap(a[i],a[k]);
                k=i;
            }else break;
        }
    }
    void ins(int x){
        a[++top]=x;
        up(top);
    }
    void del(){
        a[1]=a[top];
        a[top--]=0;
        down();
    }
    void clear(){
        mem(a);
        top=0;
    }
    void print(){
        for (i=1;i<=top;i++) printf("%d ",a[i]);
        printf("\n");
    }
}sd;
int n,a[100001],i,x,y;
int main(){
    scanf("%d",&n);
    for (i=1;i<=n;i++) scanf("%d",&a[i]);
    sd.ins(a[1]);
    printf("%d\n",a[1]);
    for (i=3;i<=n;i+=2){
        x=a[i-1],y=sd.getop();
        if (x>y){
            sd.ins(x);
            sd.del();
            bd.ins(y);
        }else bd.ins(x);
        x=a[i],y=bd.getop();
        if (x<y){
            bd.ins(x);
            bd.del();
            sd.ins(y);
        }else sd.ins(x);//神奇操作
        printf("%d\n",sd.getop());
    }
    return 0;
}
···
```

---

## 作者：Night_Aurora (赞：1)

用了超纲的SBT做出来的==

既然是BST(二叉搜索树) 可以轻易做到logn的加入元素

然后通过size域来找到中位数

反正不用重合相同元素也不用删除就简单多了(x(√)

以下代码

虽说左旋右旋不需要但还是习惯性写上了 正好复习一下



    

```cpp
#include <stdio.h>
#define L_ROTATE(b) {bfa=b->R;b->R=bfa->L;bfa->L=b;bfa->Size=b->Size;b->Size=b->R->Size+b->L->Size+1;b=bfa;}
#define R_ROTATE(b) {bfa=b->L;b->L=bfa->R;bfa->R=b;bfa->Size=b->Size;b->Size=b->L->Size+b->R->Size+1;b=bfa;}
int N,Ns[110000];
typedef struct Node
{
    int Value;
    int Size;
    Node*R,*L;
    Node* AutoRotate(int yl);
}ND,*LPND;
LPND bfa;
LPND ND::AutoRotate(int yl)
{
    LPND d=this;
    if(yl)
    {
        if(d->L->L->Size>d->R->Size)
            R_ROTATE(d)
        else
            if(d->L->R->Size>d->R->Size)
            {
                L_ROTATE(d->L);
                R_ROTATE(d);
            }
    }
    else
    {
        if(d->R->R->Size>d->L->Size)
            L_ROTATE(d)
        else
            if(d->R->L->Size>d->L->Size)
            {
                R_ROTATE(d->R);
                L_ROTATE(d);
            }
    }
    return d;
}
typedef struct SBTree
{
    LPND Null;
    LPND Root;
    SBTree(){Null=new ND;Null->R=Null->L=0;Null->Size=0;Root=Null;}
    void Insert(int a){Root=Insert_(Root,a);}
    int GetMid(){return GetMid_(Root,0,0);}
```
private:




    

```cpp
    LPND Insert_(LPND P,int a);
    int GetMid_(LPND p,int lw,int rw);
}SBT;
LPND SBT::Insert_(LPND P,int a)
{
    if(P==Null)
    {
        LPND p=new ND;
        p->Value=a;
        p->Size=1;
        p->L=p->R=Null;
        return p;
    }
    ++P->Size;
    if(a>P->Value)
    {
        P->R=Insert_(P->R,a);
        P=P->AutoRotate(0);
    }
    else
    {
        P->L=Insert_(P->L,a);
        P=P->AutoRotate(1);
    }
    return P;
}
int SBT::GetMid_(LPND p,int lr,int rr)
{
    if(lr+p->L->Size==rr+p->R->Size)
        return p->Value;
    if(lr+p->L->Size<rr+p->R->Size)
        return GetMid_(p->R,lr+p->L->Size+1,rr);
    else return GetMid_(p->L,lr,rr+p->R->Size+1);
}
void Input()
{
    scanf("%d",&N);
    int wi;
    for(wi=1;wi<=N;++wi)
        scanf("%d",Ns+wi);
}
SBT Tr;
int main()
{
    Input();
    int wi;
    for(wi=1;wi<=N;++wi)
    {
        Tr.Insert(Ns[wi]);
        if(wi%2)
            printf("%d\n",Tr.GetMid());
    }
    return 0;
}

```

---

## 作者：汇文客 (赞：1)

这道题用二叉排序树可得80分。每次插入两个数，皆比现中位数大则求后继，若皆小则求前驱。那么万一等于呢？用了一个比较猥琐的办法，大家自己看吧……

```delphi

type tree=^node;
     node=record
     k:real;
     l,r,f:tree;
end;
var bst,p,mid:tree;
    n,i:longint;
    a,b:real;
procedure insert(var bst:tree;p:tree);
begin
  if bst=nil then bst:=p
  else
  begin
    p^.f:=bst;
    if bst^.k<=p^.k then
    insert(bst^.r,p)
    else insert(bst^.l,p);
  end;
end;

function min(bst:tree):tree;
var p:tree;
begin
  p:=bst;
  while p^.l<>nil do p:=p^.l;
  min:=p;
end;

function max(bst:tree):tree;
var p:tree;
begin
  p:=bst;
  while p^.r<>nil do p:=p^.r;
  max:=p;
end;

function pre(t:tree):tree;
var p:tree;
begin
  if t^.l<>nil then pre:=max(t^.l) else
  begin
    p:=t^.f;
    while(p^.f<>nil)and(t=p^.l)do
    begin t:=p;p:=p^.f;end;
    pre:=p;
  end;
end;

function suc(t:tree):tree;
var p:tree;
begin
  if t^.r<>nil then suc:=min(t^.r) else
  begin
    p:=t^.f;
    while(p^.f<>nil)and(t=p^.r)do
    begin t:=p;p:=p^.f;end;
    suc:=p;
  end;
end;

function search(bst,t:tree):tree;
begin
  if bst^.k=t^.k then exit(bst) else
  if bst^.k<=t^.k then search:=search(bst^.r,t)
  else search:=search(bst^.l,t);
end;

begin
  readln(n);
  read(a);writeln(trunc(a));
  new(bst);bst^.k:=a;
  bst^.f:=nil;bst^.l:=nil;bst^.r:=nil;
  mid:=bst;
  for i:=2 to (n+1)div 2 do
  begin
    read(a,b);
    new(p);p^.k:=a+2*(i-1)/(n+1);
    p^.f:=nil;p^.l:=nil;p^.r:=nil;
    insert(bst,p);
    new(p);p^.k:=b+(2*i-1)/(n+1);
    p^.f:=nil;p^.l:=nil;p^.r:=nil;
    insert(bst,p);
    mid:=search(bst,mid);
    if(a>mid^.k)and(b>mid^.k)then mid:=suc(mid)
    else if(a<mid^.k)and(b<mid^.k) then mid:=pre(mid);
    writeln(trunc(mid^.k));
  end;
  if not odd(n)then read(a);
end.

```

---

## 作者：Sym_Je (赞：1)

              堆
  [1168](https://www.luogu.org/problemnew/show/P1168)   
  这道题做法类似于黑匣子    
  [1801](https://www.luogu.org/problemnew/show/P1801)    
  首先我们发现这道题只有查询，没有修改，所以我们就可以不用呢些高难的数据结构。        
  
  我们发现我们每次是在基数时查询，而且此时的数一定是奇数个，而且还要取中位数我们第一反应一定是排序，但每次排序肯定会被搞到n^2logn，显然过不了,我们肯定又会想到用堆来搞，因为这样每个数，可以达到logn，所以我们可以发现用堆就很ok。  
  但是我们要查询中间值，这样堆没有自带函数，于是我们考虑用两个堆，一个大根堆，一个小根堆，然后呢，我们就先把大根堆里存的是前1~n/2+1,小根堆里存的是后面的，     
  于是我们发现大根堆里有n/2+1个数，其余的在小根堆中，我们每次比较两个堆的堆顶，如果大根堆的堆顶大于小根堆的堆顶，就交换一下。但有些小细节要注意一下。   
  ```cpp
#include<iostream> 
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;

priority_queue<int,vector<int>,greater<int> >q;//xiao
priority_queue<int,vector<int>,less<int> >Q; //da

int n;

int a[500001];

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);
    }
    if(a[1]>a[2])
    {
    	Q.push(a[2]);
    	q.push(a[1]);
    }
    else 
    {
    	Q.push(a[1]);
    	q.push(a[2]);
    }
    printf("%d\n",a[1]);
    if(n>=3)
    {
    	Q.push(a[3]);
    	while(Q.top()>q.top())
    	{
    		int tmp=Q.top();
    		Q.pop();
    		int tmp2=q.top();
    		q.pop();
    		Q.push(tmp2);
    		q.push(tmp);
    	}
    }
    printf("%d\n",Q.top());
    for(int i=4;i<=n;i+=2)
    {
    	if(i==n)
    	{
    		return 0;
    	}
    	if(a[i]>a[i+1])
    	{
    		Q.push(a[i+1]);
    		q.push(a[i]);
    	}
    	else
    	{
    		Q.push(a[i]);
    		q.push(a[i+1]);
    	}
    	while(Q.top()>q.top())
    	{
    		int tmp=Q.top();
    		Q.pop();
    		int tmp2=q.top();
    		q.pop();
    		Q.push(tmp2);
    		q.push(tmp);
    	}
    	printf("%d\n",Q.top());
    }
    return 0;
}
```
黑匣子

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<queue>
using namespace std;

priority_queue<int,vector<int>,greater<int> >q2;
priority_queue<int,vector<int>,less<int> >q1;

int n,m;
int a[200403];
int b[200403];


int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&b[i]);		
    }
    
    sort(b+1,b+m+1); 
    int now=1;
    int V=0;
    for(int i=1;i<=n;i++)
    {
        q1.push(a[i]);
        if(q1.size()>V)
        {
            int x=q1.top();
            q1.pop();
            q2.push(x);
        } 
        while(i==b[now])
        {
            int x=q2.top();
            printf("%d\n",x);
            
            q2.pop();
            q1.push(x);
            V++;
            now++;
            if(now==m+1)
            break; 
        }
    }
        
    return 0;
        
    
}



```

---

## 作者：MakotoTSK (赞：0)

求1~2k+1范围内的中位数，也就是求1~2k+1范围内第k+1小的数。

显然，我们可以使用主席树来解决这个问题。

```cpp
#include <cstdio>
#include <algorithm>
#define maxn 100010
using namespace std;
int n,m,cnt,p;
int a[maxn],b[maxn];
int ls[maxn<<5],rs[maxn<<5],rt[maxn],sum[maxn<<5];
void build(int &now,int l,int r)
{
	now=++cnt;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(ls[now],l,mid);
	build(rs[now],mid+1,r);
}
int modify(int oldroot,int l,int r)
{
	int newroot=++cnt;
	ls[newroot]=ls[oldroot];
	rs[newroot]=rs[oldroot];
	sum[newroot]=sum[oldroot]+1;
	if(l==r)return newroot;
	int mid=(l+r)>>1;
	if(p<=mid)ls[newroot]=modify(ls[newroot],l,mid);
	else rs[newroot]=modify(rs[newroot],mid+1,r);
	return newroot;
}
int query(int lef,int rig,int l,int r,int k)
{
	int ans;
	int mid=(l+r)>>1;
	int x=sum[ls[rig]]-sum[ls[lef]];
	if(l==r)return l;
	if(x>=k)ans=query(ls[lef],ls[rig],l,mid,k);
	else ans=query(rs[lef],rs[rig],mid+1,r,k-x);
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+n+1);
	int q=unique(b+1,b+n+1)-b-1;       //q记录离散化数组最后一个位置
	build(rt[0],1,q);
	for(int i=1;i<=n;i++)
	{
		p=lower_bound(b+1,b+q+1,a[i])-b;
		rt[i]=modify(rt[i-1],1,q);
	}
	for(int i=1;i<=n;i+=2)
	{
		int l=1,r=i,k=(l+r)>>1;
		printf("%d\n",b[query(rt[l-1],rt[r],1,q,k)]);
	}
	return 0;
}
```


---

## 作者：三金Elsa (赞：0)

全新阅读体验：[请点击此处](https://blog.csdn.net/qq_40960885/article/details/102052330)

#### [【题目描述】](https://www.luogu.org/problem/P1168)
给出一个长度为N的非负整数序列Ai，对于所有1≤k≤(N+1)/2，输出A1, A3, …, A2k-1的中位数。即前1,3,5,…个数的中位数。
n<=100000

#### 【思路】

第一步：考虑求1~n的中位数,把数组排序最中间的数就是答案.

⇒考虑怎么用堆来维护这个答案.

对于一个长为i的序列,（i为奇数.）

记x表示这个序列的中位数,然后我们用大根堆维护前一半小的数,用小根堆维护后一半小的数,这样序列分为了[1,(i-1)/2]∪[(i+1)/2,i]（x放在哪一半都可以）

现在考虑加进去一个数w
让w和前一半大根堆的堆顶元素比较，大放入后半部分小根堆中，反之，放到前半部分大根堆中

维护两个堆大小差在1以内，然后输出大小较大的堆顶的元素，就是中位数

#### 【代码】

```cpp
#include<cstdio>
#include<queue>
#include<cmath>//abs头文件
using namespace std;
priority_queue<int,vector<int> >q1;
priority_queue<int,vector<int>,greater<int> >q2;
int main(){
    int n,x;
    scanf("%d",&n);
    scanf("%d",&x);
	q1.push(x);
    printf("%d\n",x); 
    for (int i=2;i<=n;i++){
        scanf("%d",&x);
        if (x>q1.top()) q2.push(x);//新加入的x放进去
            else q1.push(x);
        while(abs((int)q1.size()-(int)q2.size())>1){ //维护两个大小差1以内，abs——取绝对值函数
            if (q1.size()>q2.size()){
			    q2.push(q1.top());q1.pop();
			}
            else{
			   q1.push(q2.top());q2.pop();
			}
		}
        if(i%2==1) printf("%d\n",q1.size()>q2.size()?q1.top():q2.top());//输出大小大的那个堆的堆定元素
    }
    return 0;
}
```

P.S代码实现及评测中的一点小问题，abs在本机可以编译，但是在洛谷上会出现CE情况


这是由于size()函数返回的是无符号整数，所以使用int转换一下即可【卡了很久】


---

## 作者：Chloris (赞：0)

**中位数：一段区间内排序后排在最中间的数**

题目里要求是求前**1,3,5...**奇数区间的中位数，因此中位数只有一个

很容易想到中位数是求第k大

所以用平衡树维护一下即可，每次插入$ \ a[i] \ $

当 $ \ i \ $为奇数的时候，查询第$ \ (i \ / \ 2 \ + 1) \ $大即可

**注意开long long**

code:

```cpp

#include <bits/stdc++.h>
#define pushup(u) if(u -> ls -> siz) u -> siz = u -> ls -> siz + u -> rs -> siz, u -> val = u -> rs -> val 
#define new_Node(a, b, c, d) (&(*st[cnt++] = Node(a, b, c, d)))
#define merge(a, b) new_Node(a -> siz + b -> siz, b -> val, a, b)
#define ratio 4
#define int long long 
using namespace std;
const int N = 200005 * 4;
int a[N];

template <typename T>
inline void read(T &t) {
    t = 0; T m = 1; char ch = getchar();
    while(ch < '0' || ch > '9') { if(ch == '-') m = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') { t = (t << 3) + (t << 1) + (ch & 15); ch = getchar(); }
    t *= m;
}

struct Node {
    int siz, val;
    Node *ls, *rs;
    Node () {}
    Node (int a, int b, Node *c, Node *d) : siz(a), val(b), ls(c), rs(d) {}
}*root, *null, *st[N], t[N], *father;

int n, cnt = 0;

void maintain(Node *u) {
    if(u -> ls -> siz > u -> rs -> siz * ratio) u -> rs = merge(u -> ls -> rs, u -> rs), st[--cnt] = u -> ls, u -> ls = u -> ls -> ls;
    if(u -> rs -> siz > u -> ls -> siz * ratio) u -> ls = merge(u -> ls, u -> rs -> ls), st[--cnt] = u -> rs, u -> rs = u -> rs -> rs;
}
void ins(Node *u, int x) {
    if(u -> siz == 1) u -> ls = new_Node(1, min(x, u -> val), null, null), u -> rs = new_Node(1, max(x, u -> val), null, null);
    else ins(x > u -> ls -> val ? u -> rs : u -> ls, x);
    pushup(u); maintain(u);
}

int kth(Node *u, int x) {
    if(u -> siz == 1) return u -> val;
    return x > u -> ls -> siz ? kth(u -> rs, x - u -> ls -> siz) : kth(u -> ls, x);
}

signed main() {
    null = new Node(0, 0, 0, 0);
    root = new Node(1, 999999999999, null, null);
    for(int i = 0; i < 200005; i++) st[i] = &t[i];
    read(n);
    for(int i = 1; i <= n; i++) {
        read(a[i]);
        ins(root, a[i]);
        if(i % 2 == 1) {
            printf("%lld\n", kth(root, i / 2 + 1));
        }
    }
    return 0;
}


```

---


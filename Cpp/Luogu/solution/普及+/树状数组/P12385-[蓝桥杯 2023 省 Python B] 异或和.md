# [蓝桥杯 2023 省 Python B] 异或和

## 题目描述

给一棵含有 $n$ 个结点的有根树，根结点为 $1$，编号为 $i$ 的点有点权 $a_i$ $(i \in [1, n])$。现在有两种操作，格式如下：

- $1\ x\ y$ 该操作表示将点 $x$ 的点权改为 $y$。
- $2\ x$ 该操作表示查询以结点 $x$ 为根的子树内的所有点的点权的异或和。

现有长度为 $m$ 的操作序列，请对于每个第二类操作给出正确的结果。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$n, m \leq 1000$；
- 对于所有评测用例，$1 \leq n, m \leq 100000$，$0 \leq a_i, y \leq 100000$，$1 \leq u_i, v_i, x \leq n$。

## 样例 #1

### 输入

```
4 4
1 2 3 4
1 2
1 3
2 4
2 1
1 1 0
2 1
2 2```

### 输出

```
4
5
6```

# 题解

## 作者：Zskioaert1106 (赞：4)

题目传送门：[P12385 [蓝桥杯 2023 省 Python B] 异或和](https://www.luogu.com.cn/problem/P12385)

- 本文提供了 Python 代码。

### 做题过程

我们发现一颗子树内的所有结点在 DFS 序下都是连续的一段，因此可以通过一遍 DFS 将树转化为序列上问题。

记录结点编号和对应的 DFS 序，然后建立树状数组。只需在操作时将树上编号转化为序列即可。

#### 单点修改

改结点权值时，需要先将原来的值异或一遍回去，再将新的值异或上。也就是说树状数组上相关的每个值都要异或上 $y \oplus a_x$，其中 $a_x$ 是原值。

#### 区间查询

记录每个结点子树的大小 $siz$（此处选择不计根结点），则以 $x$ 为根的子树中所有点的 DFS 序是 $t_x,t_x+1,\dots,t_x+siz_x$ 的连续段。用树状数组的方法取得前缀异或和即可。（其中 $t_x$ 代表结点编号对应的 DFS 序编号）

### 代码编写

树根为 $1$，深搜后按 DFS 序用 $a_i$ 前缀异或建 BIT，处理修改和查询。

#### C++

```cpp
#include<iostream>
#include<vector>
using namespace std;
const int N=100001;
int n,m,a[N],d[N],s[N];
int fa[N],siz[N],lt[N],tl[N];
vector<int>e[N];
void dfs(int x){
	lt[++lt[0]]=x,tl[x]=lt[0]; // 链转树和树转链序
	for(int u:e[x]){
		if(u==fa[x])continue;
		fa[u]=x;
		dfs(u);
		siz[x]+=siz[u]+1;
	}
}
void update(int x,int k){
	k^=a[x];
	for(int i=tl[x];i<=n;i+=i&-i)s[i]^=k;
}
int query(int x){
	int ans=0;
	for(int i=x;i;i-=i&-i)ans^=s[i];
	return ans;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v),e[v].push_back(u);
	}
	dfs(1);
	for(int i=1;i<=n;i++){
		d[i]=a[lt[i]]^d[i-1]; // 按 DFS 序初始化
		s[i]=d[i]^d[i-(i&-i)];
	}
	while(m--){
		short op;
		cin>>op;
		if(op==1){
			int x,y;
			cin>>x>>y;
			update(x,y);
			a[x]=y;
		}
		else{
			int x;
			cin>>x;
			cout<<(query(tl[x]+siz[x])^query(tl[x]-1))<<'\n';
		}
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/215595101)。

#### Python


```python
import sys
sys.setrecursionlimit(114514) # 控制递归栈最大深度

lowbit = lambda x:x&-x

n,m = map(int,input().split())
a = [0]+list(map(int,input().split()))
e = [[] for _ in range(n+1)]
fa = [0 for _ in range(n+1)]
siz = [0 for _ in range(n+1)]
lt = [0 for _ in range(n+1)]
tl = [0 for _ in range(n+1)]
d = [0 for _ in range(n+1)]
s = [0 for _ in range(n+1)]

def dfs(x):
    lt[0] += 1
    lt[lt[0]],tl[x] = x,lt[0]
    for u in e[x]:
        if u == fa[x]:
            continue
        fa[u] = x
        dfs(u)
        siz[x] += siz[u] + 1

for i in range(1,n):
    u,v = map(int,input().split())
    e[u].append(v)
    e[v].append(u)
dfs(1)

for i in range(1,n+1):
    d[i] = a[lt[i]] ^ d[i-1]
    s[i] = d[i] ^ d[i-lowbit(i)]

def update(x,k):
    k ^= a[x]
    i = tl[x]
    while i <= n:
        s[i] ^= k
        i += lowbit(i)

def query(x):
    ans,i = 0,x
    while i > 0:
        ans ^= s[i]
        i -= lowbit(i)
    return ans

while m>0:
    op = list(map(int,input().split()))
    if op[0] == 1:
        x,y = op[1],op[2]
        update(x,y)
        a[x] = y
    else:
        x = op[1]
        print(query(tl[x]+siz[x])^(query(tl[x]-1)))

    m -= 1
```

[AC 记录](https://www.luogu.com.cn/record/215600933)。

---

## 作者：LS_Z_66066 (赞：3)

一道树状数组结合 dfs 序的简单应用。

题目要求点修区间查，考虑树状数组。

首先求出每个节点的 dfs 序，按照深搜的性质可得同一子树内的 dfs 序一定是连续的一段，即可把题目从树上问题转换成序列问题，之后就是单点修改和查询区间异或和。

Code：
```cpp
#include <bits/stdc++.h>//
//#define Ri register int
//#define int long long
#define eb emplace_back
#define pb push_back

typedef long long ll;

inline int read(){
	int x = 0; bool f = 1;
	char ch = getchar();
	while(ch < 48 || ch > 57){
		if(ch == 45) f = 0;
		ch = getchar();
	}
	while(ch <= 57 && ch >= 48){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f ? x : -x;
}

const int N = 1e5 + 3;

int n, m;

int a[N];

int dfn[N], tot, siz[N];

std :: vector<int> e[N];

inline void dfs(int u, int fath = 0) {
	dfn[u] = ++tot;
	siz[u] = 1;
	for(auto &v : e[u]) if(v ^ fath) {
		dfs(v, u);
		siz[u] += siz[v];
	}
}

int c[N];

inline void add(int x, int k) {
	for(; x <= n; x += (x & -x)) c[x] ^= k;
}

inline int qry(int x, int res = 0) {
	for(; x >= 1; x -= (x & -x)) res ^= c[x];
	return res;
}

signed main(){
	n = read(), m = read();
	for(int i = 1; i <= n; ++i) a[i] = read();
	
	int op, x, y;
	for(int i = 1; i < n; ++i) x = read(), y = read(), e[x].eb(y), e[y].eb(x);
	
	dfs(1);
	
	for(int i = 1; i <= n; ++i) add(dfn[i], a[i]);
	
	while(m--) {
		op = read(), x = read();
		if(op & 1) {
			y = read();
			add(dfn[x], a[x]);
			add(dfn[x], a[x] = y);
		}
		else {
			std :: cout << (qry(dfn[x] + siz[x] - 1) ^ qry(dfn[x] - 1)) << "\n";
		}
	}

	return 0;
}


```

已更正格式。

---

## 作者：Ice09 (赞：3)

可以当作一道树上线段树的新手题。

我们先将这棵树标好每个节点的 dfs 序。比如现在建一棵如下的树，并标上 dfs 序。

![](https://cdn.luogu.com.cn/upload/image_hosting/hiwxy7z5.png)

（在学校机房画的图，有点丑陋，凑合看吧 QwQ）

由图可知，节点 3 子树的 dfs 序是一串连续的序列：```2 3 4```，节点 6 子树的 dfs 序：```5 6 7```。我们可以发现其中任意一棵子树的 dfs 序都是连续的。记录下每个节点的子树 dfs 序的起点与终点后，这题就能改为：在这个树的 dfs 序上进行单点修改和区间异或和查询。

随后是代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f3f3f3f3f
#define mid ((l + r) / 2)
#define ls (u << 1)
#define rs (u << 1 | 1)
const int N = 1e5 + 7;
struct stree {
	int sum;
};
int n, m, a[N], cnt = 0, b[N], st[N], ed[N], opt, X, Y, u, v, kk[N];
stree tr[N * 4];
vector<int> vec[N];
void dfs(int u, int fa) {
	if (b[u]) return;
	b[u] = ++cnt;
	st[u] = cnt;
	kk[cnt] = u;
	for (int i = 0; i < (int)vec[u].size(); i++) {
		if (vec[u][i] != fa) {
			dfs(vec[u][i], u);
		}
	}
	ed[u] = cnt;
	return;
}
void pushup(int u) {
	tr[u].sum = tr[ls].sum ^ tr[rs].sum;
	return;
}
void build(int u, int l, int r) {
	if (l == r) {
		tr[u].sum = a[kk[l]];
		return;
	}
	build(ls, l, mid);
	build(rs, mid + 1, r);
	pushup(u);
	return;
}
void modify(int u, int l, int r, int x, int y) {
	if (l == r) {
		tr[u].sum = y;
		return;
	}
	if (x <= mid) modify(ls, l, mid, x, y);
	else modify(rs, mid + 1, r, x, y);
	pushup(u);
	return;
}
int query(int u, int l, int r, int L, int R) {
	if (L <= l && r <= R) {
		return tr[u].sum;
	}
	int res = 0;
	if (L <= mid) res ^= query(ls, l, mid, L, R);
	if (R > mid) res ^= query(rs, mid + 1, r, L, R);
	return res;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		vec[u].push_back(v);
		vec[v].push_back(u);
	}
	dfs(1, 0);
	build(1, 1, n);
	while (m--) {
		cin >> opt;
		if (opt == 1) {
			cin >> X >> Y;
			modify(1, 1, n, b[X], Y);
		} else {
			cin >> X;
			cout << query(1, 1, n, st[X], ed[X]) << '\n';
		}
	}
	return 0;
}
```

---

## 作者：aaa1145141919810 (赞：3)

# [P12385 [蓝桥杯 2023 省 Python B] 异或和](https://www.luogu.com.cn/problem/P12385)

观察题目，我们可以看出这题有单点修改、子树查询。细心的朋友们就能想起来：这简直就是道树状数组模板题！

于是我们建立一个树状数组，用于查询一段区间的异或和，并支持单点赋值操作。

不会树状数组的同学可以看[这里](https://www.luogu.com.cn/problem/P3374)。

想到这里，这道题最大的难点就变成如何将对一个子树的查询变成对区间的查询。有树的题就画张图找性质，以样例为例，如图：

![好看的图](https://cdn.luogu.com.cn/upload/image_hosting/q8sg2ghr.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

从图中我们可以发现，对于一颗以 $x$ 为根的子树，它节点的 dfs 序（$dfn$）是连续的，且其范围是 $[dfn_x, dfn_x+size_x-1]$（其中 $size_x$ 表示以 $x$ 为根的子树的大小）

那么我们就可以将对子树的查询变为查询一个区间，大概这样：

```cpp
query(dfn[x], dfn[x]+size[x]-1);
```

至于单点赋值操作，我们可以将新值与原值异或，将赋值操作变成异或操作，即：

$$x \gets k \iff x \gets x \oplus k \oplus x$$

而异或操作可以用树状数组维护，具体方式如下：

```cpp
void update(int x, int k)
{
	while(x <= n)tree[x]^=k,x += lowbit(x);
}
```

那么这道题就已经完成了，AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5+5;
int n, m, tree[N], a[N], dfn[N], size[N], dn = 1;

vector<int> G[N];

int lowbit(int x){return (x&-x);}

//树状数组基本组件 
void update(int x, int k)
{
	k ^= a[x];
	a[x] = k^a[x];//顺带修改a[x] 
	x = dfn[x];
	while(x <= n)tree[x]^=k,x += lowbit(x);
}
int get(int x)
{
	int res = 0;
	while(x >= 1)res ^= tree[x],x -= lowbit(x);
	return res;
}
int query(int l, int r)
{
	return get(r)^get(l-1);
}

//初始化dfs序 
void dfs(int u, int fa)
{
	size[u] = 1;
	for(int v : G[u])
	{
		if(v == fa)continue;
		dfn[v] = ++dn;
		dfs(v, u);
		size[u] += size[v];
	}
	return;
}

int main()
{
	//读入 
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
	}
	
	for(int i = 1; i < n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		G[u].push_back(v); G[v].push_back(u);
	}
	
	//初始化 
	dfn[1] = 1;
	dfs(1, 0);
	for(int i = 1; i <= n; i++)
	{
		int x = a[i];
		a[i] = 0;
		update(i, x);
	}
	
	//开始处理提问 
	while(m--)
	{
		int opt;
		scanf("%d", &opt);
		if(opt == 1)
		{
			int x, y;
			scanf("%d%d", &x, &y);
			update(x, y);
		}
		else
		{
			int x;
			scanf("%d", &x);
			printf("%d\n", query(dfn[x], dfn[x]+size[x]-1));
		}
	}
	
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/215918140)。

蒟蒻的第一篇题解，求点赞。

---

## 作者：LostKeyToReach (赞：3)

我们先做一次树链剖分，再开一颗树状数组用于单点异或，区间查询。设每个节点 $x$ 的 dfn 序为 $pos_x$，对于操作 $1$，我们只要对 $pos_x$ 进行修改。对于操作 $2$，我们查询 $[pos_x, pos_x + size_x - 1]$ 的异或和即可。时间复杂度 $\mathcal{O}((n + m) \log n)$。

如果没有学过树链剖分，可以看看 [P3384](https://www.luogu.com.cn/problem/P3384)。

代码就不给了。

---

## 作者：fush (赞：2)

用树剖就是大炮打蚊子了吧。   
这题没有链上的部分，且子树在 dfn 序中连续。    
我们直接用 dfn 序转换成序列问题。  
而每次询问区间是 $[dfn_x, dfn_x + siz_x - 1]$。  
我们用树状数组维护即可。

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a,b,c) for(int a=(b),a##end=(c);a<=a##end;++a)
#define FR(a,b,c) for(int a=(b),a##end=(c);a>=a##end;--a)
#define lowbit(x) ((x)&-(x))
#define eb emplace_back
#define SZ(x) (int)((x).size())
#define ll long long
#define vt vector
#define fr first
#define se second
#define ar(x) array<int,x>
#define PII pair<int, int>
#define max(a, b)({auto f7r=(a);auto j3h=(b);f7r<j3h?j3h:f7r;})
#define cmax(a, b)({auto j3h=(b);(j3h>a)&&(a=j3h);})
#define min(a, b)({auto f7r=(a);auto j3h=(b);f7r>j3h?j3h:f7r;})
#define cmin(a, b)({auto j3h=(b);(j3h<a)&&(a=j3h);})
constexpr int N = 1e6 + 10;
int a[N], w[N], siz[N], dfn[N], tot;
void add(int x, int v){while(x < N)w[x] ^= v, x += lowbit(x);}
int query(int x){int s = 0;while(x)s ^= w[x], x -= lowbit(x);return s;}
vt<int>e[N];
void dfs(int x, int f){
    add(dfn[x] = ++tot, a[x]), siz[x] = 1;
    for(auto&v : e[x])if(v != f)dfs(v, x), siz[x] += siz[v];
}
int32_t main(){
    cin.tie(0)->sync_with_stdio(0);
    int n, m, u, v;
    cin >> n >> m;
    FL(i, 1, n)cin >> a[i];
    FL(i, 2, n)cin >> u >> v, e[u].eb(v), e[v].eb(u);
    dfs(1, 0);
    while(m--){
        int op, x, v;
        cin >> op >> x;
        if(op == 1)cin >> v, add(dfn[x], a[x]), add(dfn[x], v), a[x] = v;
        else cout << (query(dfn[x] + siz[x] - 1) ^ query(dfn[x] - 1)) << endl;
    }
    return 0;
}
```

---

## 作者：Epitome (赞：2)

## 题意

最简洁的题目已经在题目描述里了。

## 解法

有脑树剖，然后发现只需要维护单点的修改和区间查询，上树状数组。

详细一点就是：

先树链剖分让一条树链上的编号连续，然后 `1` 操作就是点修改，`2` 操作根据树链剖分的性质，一个点 $x$ 和它的子树的编号为 $x$ 的编号到 $x$ 的编号加上 $x$ 的字数大小减一，画一下图就李姐了，然后就是对 $x$ 单点修改，设 $a$ 的编号为 $dfs_a$ 那么就是对 $dfs_x, dfs_x + 1, \dots, dfs_x + size_x - 1$ 区间查询异或和，树状数组就能无脑完成了。

## 代码

因为题目求的是异或和，所以不用开 `long long`。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 1e5 + 5;

struct Node {
  int dep, siz, fat, top, hvy;
} t[N];

int n, m, a[N], sum, dfs[N], ta[N];

vector<int> g[N];

void s1( int x, int fa ) {
  t[x].dep = t[fa].dep + 1, t[x].siz = 1, t[x].fat = fa;
  int cnt = 0;
  for (auto to : g[x]) {
    if (!(to ^ fa)) {
      continue;
    }
    s1(to, x);
    if (t[to].siz > cnt) {
      cnt = t[to].siz, t[x].hvy = to;
    }
    t[x].siz += t[to].siz;
  }
}

void s2( int x, int fa, int topx ) {
  t[x].top = topx, dfs[x] = ++sum;
  if (t[x].hvy) {
    s2(t[x].hvy, x, topx);
  }
  for (auto to : g[x]) {
    if (!(to ^ fa)) {
      continue;
    }
    if (to ^ t[x].hvy) {
      s2(to, x, to);
    }
  }
}

void add( int x, int k ) {
  for (; x <= n; x += (x & -x)) {
    ta[x] ^= k;
  }
}

int ask( int x ) {
  int res = 0;
  for (; x; x -= (x & -x)) {
    res ^= ta[x];
  }
  return res;
}

int main() {
  ios :: sync_with_stdio(0), cin.tie(0);
  cin >> n >> m;
  for (int i = 1; i <= n; cin >> a[i++]) {
  }
  for (int i = 1, x, y; i < n; ++i) {
    cin >> x >> y, g[x].push_back(y), g[y].push_back(x); // 建边
  }
  s1(1, 0), s2(1, 1, 0); // 树剖
  for (int i = 1; i <= n; ++i) {
    add(dfs[i], a[i]); // 初始化点权
  }
  for (int x, y, op; m--; ) {
    cin >> op >> x;
    if (op == 1) {
      cin >> y;
      add(dfs[x], a[x]); // 两次异或 a[x] 就是消掉
      a[x] = y, add(dfs[x], a[x]); // 修改后再异或上去
    } else {
      cout << (ask(dfs[x] + t[x].siz - 1) ^ ask(dfs[x] - 1)) << endl; // 树状数组区间异或查询
    }
  }
  return 0;
}

```

---

## 作者：Firsry (赞：1)

# 树状数组 +dfn 序

操作如此简单，信息如此单一，为何不进精简？

首先这个题并不需要完成链的操作，而只需要完成子树操作，所以只需要保存 $dfn,siz$ 两个信息即可，也就不需要完整的树剖，一遍深搜直接带走；

其次关于树状数组的单点覆盖，可以分成抵消原来的值以及加上当前的值，对于维护和的就是加减法，对于维护异或和的，就是对于两个值分别异或一下，之前的异或没了，现在的异或进去。

对于树转链的新手来说，注意进行修改、查询的时候一定一定一定代入的是 $dfn_{pos}$ 而不是 $pos$！


```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x & (-x))

using namespace std;

const int MAXN = 100005;

int n, m;

int edgeCount;
int head[MAXN], toNode[MAXN << 1], nextEdge[MAXN << 1];

int countDfn, dfn[MAXN], siz[MAXN], val[MAXN];

int bit[MAXN];

inline void addEdge(int from, int to) {
	edgeCount++;
	toNode[edgeCount] = to;
	nextEdge[edgeCount] = head[from];
	head[from] = edgeCount;
	return;
}

inline void changeBit(int pos, int val) {
	for (int i = pos; i <= n; i += lowbit(i))
		bit[i] ^= val;
	return;
}
inline int queryBit(int l, int r) {
	int res1 = 0, res2 = 0;
	for (int i = l - 1; i; i -= lowbit(i))
		res1 ^= bit[i];
	for (int i = r; i; i -= lowbit(i))
		res2 ^= bit[i];
	return res1 ^ res2;
}

inline void dfs(int from, int father) {
	siz[from]++;
	countDfn++;
	dfn[from] = countDfn;
	for (int i = head[from]; i; i = nextEdge[i]) {
		int to = toNode[i];
		if (to != father) {
			dfs(to, from);
			siz[from] += siz[to];
		}
	}
	return;
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)
		scanf("%d", &val[i]);
	for (int i = 1; i < n; ++i) {
		int from, to;
		scanf("%d%d", &from, &to);
		addEdge(from, to), addEdge(to, from);
	}
	dfs(1, 0);
	for (int i = 1; i <= n; ++i)
		changeBit(dfn[i], val[i]);
	while (m--) {
		int opt, pos, curVal;
		scanf("%d%d", &opt, &pos);
		if (opt == 1) {
			scanf("%d", &curVal);
			changeBit(dfn[pos], val[pos]);
			changeBit(dfn[pos], curVal);
			val[pos] = curVal;
		} else
			cout << queryBit(dfn[pos], dfn[pos] + siz[pos] - 1) << '\n';
	}
	return 0;
}
```

---

## 作者：MonKeySort_ZYczc (赞：1)

想起了 [CF877E](https://www.luogu.com.cn/problem/CF877E) 这题，都是将简单的序列操作强行扔到树上，要么路径查询要么子树查询，~~有点无聊~~。  
## 思路流程
假如不是树而是一个序列，我们又该如何解决呢？  
单点操作区间查询还可以差分，树状数组无疑比相对麻烦且常数较大的线段树好。  
区间查询很简单，设 $c_i=\bigoplus_{j=1}^i a_j$，假如询问 $\bigoplus_{i=x}^y a_i$ 那么输出 $c_y\oplus c_{x-1}$ 即可。  
单点修改，由于异或可差分的特性，让 $a_x$ 变为 $a_x\oplus a_x \oplus y$（为啥这么麻烦？结合树状数组维护前缀和的方法仔细想想）再维护前缀和即可。  

接下来考虑树的影响。  
对于子树，有个小技巧，设 $dfs_i$ 为 $i$ 的 dfs 序， $size_i$ 为 $i$ 的子树大小，那么 $[dfs_i,size_i+dfs_i-1]$ 表示的就是子树中的所有点。  
毕竟 dfs 时在 $i$ 点被遍历过后其子树中所有的点在接下来都会被遍历，共 $size_i$ 个点，的确满足该规律。  

把两个方法结合思路便明了了。  
先 dfs 无根树转有根树顺便求出 $dfs$ 与 $size$，结合树状数组即可。  
总时间复杂度 $O(n\log n)$。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,c[N],a[N],seg[N],sz[N],cnt;
int tot,head[N],to[2*N],nxt[2*N];
inline void add(int a,int b)
{
	tot++;
	nxt[tot]=head[a];to[tot]=b;head[a]=tot;
}
void dfs(int p,int f)
{
	sz[p]=1;seg[p]=++cnt;
	for(int i=head[p];i;i=nxt[i])
	{
		int t=to[i];
		if(t==f) continue;
		dfs(t,p);
		sz[p]+=sz[t];
	}
}
inline void update(int p,int a){for(;p<=n;p+=p&-p) c[p]^=a;}
inline int query(int p)
{
	int ans=0;
	for(;p;p-=p&-p) ans^=c[p];
	return ans;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++)
	{
		int a,b;cin>>a>>b;add(a,b);add(b,a); 
	 } 
	dfs(1,0);
	for(int i=1;i<=n;i++) update(seg[i],a[i]);
	for(int i=1;i<=m;i++)
	{
		int op,x;cin>>op>>x;
		if(op==2) cout<<(query(seg[x]+sz[x]-1)^query(seg[x]-1))<<'\n';
		else
		{
			int y;cin>>y;
			update(seg[x],a[x]);update(seg[x],y);a[x]=y;
		}
	}
 } 
```

---

## 作者：_Weslie_ (赞：0)

建议改名：【模板】树上树状数组。

## Solution P12385

### Idea

把子树问题转化为区间问题。

遍历树，对每个节点 $u$ 记录 dfs 序，并且记录它子树的 dfs 序最大值 $r_u$ 和最小值 $l_u$。不难发现 $l_u$ 就是 $u$ 节点的 dfs 序，因为你只有先遍历到 $u$ 点才能遍历到它的子树。

树于是转化为区间，然后操作转化为：

- 单点修改。
- 区间查询。

树状数组完成即可。注意修改是直接赋值，转化为先异或原先的值然后再异或新值的操作。

### Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
int tr[N],l[N],r[N],n,q;
struct node{
	int u,v,nxt;
}e[N<<1];
int head[N],cnt;
void add(int u,int v){
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int idx,a[N];
void dfs(int now,int fa){
	l[now]=++idx;
	for(int i=head[now],v;i;i=e[i].nxt){
		v=e[i].v;if(v==fa)continue;
		dfs(v,now);
	}
	r[now]=idx;
}
int lowbit(int x){
	return x&(-x);
}
void addtr(int now,int y){
	while(now<=n){
		tr[now]^=y;
		now+=lowbit(now);
	}
}
int query(int now){
	int res=0;
	while(now){
		res^=tr[now];
		now-=lowbit(now);
	}
	return res;
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1,u,v;i<n;i++){
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)addtr(l[i],a[i]);
	for(int i=1,opt,x,y;i<=q;i++){
		scanf("%d%d",&opt,&x);
		if(opt==1){
			scanf("%d",&y);
			addtr(l[x],a[x]);
			addtr(l[x],y);
			a[x]=y;//这里 tr[l[x]] 与 a[x] 的意义不同
		}
		else{
			printf("%d\n",query(r[x])^query(l[x]-1));
		}
	}
}
```

---

## 作者：hhy11_ (赞：0)

## P12385 [蓝桥杯 2023 省 Python B] 异或和

[题目传送门](https://www.luogu.com.cn/problem/P12385)

先看一眼题目，有两种操作：


1. 单点修改
2. 异或和

马上可以想到**树状数组**。但是回头一看，怎么是在树上的？

其实没有问题。只需要先用一个 dfs 遍历整个树，记录下 dfs 序，即 $dfn$ 数组，有点类似 tarjan 算法。因为每个子树在 dfs 序上都是连续的，所以此时一个树就转化为了一个数组，我们设以 $x$ 为根的子树大小为 $siz_x$，dfs 序为 $dfn_x$，然后可得这个子树在数组上的区间是从 $dfn_x$ 到 $siz_x+dfn_x-1$ 的。

然后修改操作也可以实现了。因为一个数异或他自身为 $0$，所以修改操作也可以转化为异或。设要把 $a$ 变成 $b$，只要把 $a$ 异或上一个 $a$ 再异或 $b$ 即可。所以代码就很清晰了。只是本题有点绕，有很多细节要注意。

## 代码


```cpp
#include<iostream>
#include<vector>
using namespace std;
typedef long long ll;
const ll N = 2e5 + 7;
void read(ll &inp){
	//快读 
	inp = 0;
	char c;
	while(1){
		c = getchar();
		if(isdigit(c))break;
	}
	while(1){
		inp *= 10;
		inp += c - '0';
		c = getchar();
		if(!isdigit(c))break;
	}
}
ll lowbit(ll a){
	return a & (-a);
}
ll a[N], b[N], c[N];
vector<int> g[N];
ll n, m;
//这个是处理从1(数字)到r的异或和
ll query(int r){
	ll sum = 0;
	for(int i = r;i >= 1;i -= lowbit(i)){
		sum ^= c[i];
	}
	return sum;
}
//从l(字母)到r的异或和 
ll ask(int l, int r){
	return query(r) ^ query(l - 1);
}
//更新位置为u的元素 
void update(int u, ll k){
	for(int i = u;i <= n;i += lowbit(i)){
		c[i] ^= k;
	}
}
//计算dfs序 、子树大小 
ll dfn[N], siz[N], siz2[N], cnt = 0;
void dfs(int u, int fa){
	dfn[u] = ++cnt;
	siz[u] = 1;
	for(int i = 0;i < g[u].size();i++){
		if(g[u][i] != fa){
			dfs(g[u][i], u);
			siz[u] += siz[g[u][i]];
		}
	}
}
//初始化 
void init(){
	for(int i = 1;i <= n;i++){
		update(dfn[i], a[i]);
	}
}
int main(){
	read(n);
	read(m);
	for(int i = 1;i <= n;i++){
		read(a[i]);
	}
	for(int i = 1;i < n;i++){
		ll u, v;
		read(u);
		read(v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, -1);
	init();//建立树状数组
	for(int i = 1;i <= m;i++){
		ll op,x,y;
		read(op);
		if(op == 1){
			read(x);
			read(y);
			update(dfn[x], a[x]);//记得用dfn数组的值
			update(dfn[x], y);
			a[x] = y; 
		}
		else{
			read(x);
			cout << ask(dfn[x], dfn[x] + siz[x]-1) << '\n';
		}
	}
	return 0;
}
```

---

## 作者：ZZ_junning (赞：0)

## 思路

~~一道简单的树状数组问题。~~

首先 DFS 把 $ 1 \sim n $ 的 $ dfn $ 序求出。

接着把 $ a_i $ 按照 $ dfn $ 序放到树状数组中。

对于 $ m $ 次操作，有两种情况：

1. 修改操作，现有 `add` 函数把树状数组的原值异或成 `0` ，接着再把赋的值异或到树桩数组中。注意 $ x $ 要先转换为 $ dfn $ 序。

2. 询问操作，因为 $x$ 的子树的 $dfn$ 序一定是一段连续的区间，树状数组支持区间查询，直接套用异或前缀和的公式 $ \operatorname{query(x,y)} = \operatorname{query(1,y)} \wedge \operatorname{query(1,x-1)} $ 即可。

这里就不过多阐明为什么一个结点的子树的 $ dfn $ 序为一段连续的区间了。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid (l+r>>1)
#define lson (u<<1)
#define rson (u<<1|1)
#define eb emplace_back
#define pii pair<int,int>
#define lowbit(x) ((x)&(-(x)))
#define swap(x,y) (x)^=(y)^=(x)^=(y)
using namespace std;
inline void out(int k){if(k<0)putchar('-'),k=-k;if(k<10)putchar(k+'0');else out(k/10),putchar(k%10+'0');}
inline int read(){int x=0,f=1;char ch=getchar();while(ch>57||ch<48){if(ch==45)f=-1;ch=getchar();}while(ch>=48&&ch<=57){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
const int N=1e5+3;
int tr[N],n,m,dfn[N],tot,siz[N],a[N];
vector<int> g[N];
inline void add(int x,int k){
    for(;x<=n;x+=lowbit(x))tr[x]^=k;
}
inline int query(int x){
    int res=0;
    for(;x;x-=lowbit(x))res^=tr[x];
    return res;
}
inline void dfs(int x,int father){
    dfn[x]=++tot;
    siz[x]=1;
    for(auto to:g[x]){
        if(to==father)continue;
        dfs(to,x);
        siz[x]+=siz[to];
    }
}
signed main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        g[u].eb(v);
        g[v].eb(u);
    }
    dfs(1,0);
    for(int i=1;i<=n;i++)add(dfn[i],a[i]);
    while(m--){
        int opt=read(),x=read(),y;
        if(opt==1)y=read(),add(dfn[x],a[x]),a[x]=y,add(dfn[x],y);
        else printf("%lld\n",query(dfn[x]+siz[x]-1)^query(dfn[x]-1));
    }
    return 0;
}
```

---

## 作者：Invisible_H (赞：0)

## P12385 [蓝桥杯 2023 省 Python B] 异或和

### Problem
树上单点修改，查询子树异或和。
### Solution

树剖板子，没学过树剖的出门左转 [P3384](https://www.luogu.com.cn/problem/P3384)。

其实就是对于一棵树，它的子树上的点的 dfs 序是连续的，按 dfs 序建线段树。

唯一不同的在于这个维护的是单点修改，子树异或和，所以这个不用线段树，直接树状数组就能做，剩下的树状数组或者线段树维护区间异或和就很简单了。

---

## 作者：W_C_B_H (赞：0)

如下图（红色的数字是节点的 dfs 序），我们可以观察到：一个节点的子树内所有节点的 dfs 序是连续的，所以我们可以先对原树进行 dfs，求出每个节点的 dfs 序（记作 $dfn$）和子树大小（记作 $siz$），那么一个节点 $i$ 的子树中的节点的 dfs 序范围为 $[dfn_i,dfn_i+siz_i-1]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/nsn0x2cx.png)

设 $b_i$ 为 dfs 序为 $i$ 的节点的点权，则操作 $1$ 相当于将 $b_{dfn_x}$ 修改为 $y$，操作 $2$ 相当于查询 $b_{dfn_x}$ 到 $b_{dfn_x+siz_x-1}$ 的异或和。故数列 $b$ 可以使用线段树进行维护。总时间复杂度 $O(n+m\log n)$，可以通过本题。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
int n,m,a[N],tot=0,dfn[N],nfd[N],siz[N],seg[N<<2],l[N<<2],r[N<<2];
vector<int>e[N];
void dfs(int u,int fa)	// 深搜, 确定 dfn 和 siz 
{
	dfn[u]=++tot;	// 节点对应的 dfs 序 
	nfd[tot]=u;		// dfs 序对应的节点 (因为英语不好只能把 dfn 倒过来了) 
	siz[u]=1;		// 子树大小 
	for(int v:e[u])
	{
		if(v^fa)
		{
			dfs(v,u);
			siz[u]+=siz[v];
		}
	}
}
void build(int p,int x,int y)	// 建立线段树, 节点 p 管辖区间 [x,y] 
{
	l[p]=x, r[p]=y;			// 记录节点 p 管辖的区间 
	if(x==y)
	{
		seg[p]=a[nfd[x]];	// 记录节点 p 的初始值 
		return;
	}
	int mid=(x+y)>>1;
	build(p<<1,x,mid);
	build(p<<1|1,mid+1,y);
	seg[p]=seg[p<<1]^seg[p<<1|1];	// 记录节点 p 的初始值 
}
void update(int p,int x,int k)	// 将第 x 个节点的值改为 k 
{
	if(r[p]<x || x<l[p])
	{
		return;
	}
	if(l[p]==r[p])
	{
		seg[p]=k;
		return;
	}
	update(p<<1,x,k);
	update(p<<1|1,x,k);
	seg[p]=seg[p<<1]^seg[p<<1|1];
}
int query(int p,int x,int y)	// 查询区间 [x,y] 的异或和 
{
	if(r[p]<x || y<l[p])
	{
		return 0;
	}
	if(x<=l[p] && r[p]<=y)
	{
		return seg[p];
	}
	return query(p<<1,x,y)^query(p<<1|1,x,y);
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	
	// 输入 
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1,u,v;i<n;i++)
	{
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
		// 建边 
	}
	
	// 处理 
	dfs(1,0);
	build(1,1,n);
	while(m--)
	{
		int op,x,y;
		cin>>op>>x;
		// 注意这里传参不要忘了传的是 dfn 
		if(op==1)
		{
			cin>>y;
			update(1,dfn[x],y);
		}
		else
		{
			cout<<query(1,dfn[x],dfn[x]+siz[x]-1)<<"\n";
		}
	}
	return 0;
}
```

---


# [蓝桥杯 2025 国 Java B] 道具摆放

## 题目描述

小蓝是社区剧团的道具员，他负责管理一排编号为 $1$ 到 $N$ 的道具箱。平常，这些道具箱会按编号升序排列在舞台上。

今天晚上有一场重要的演出，演出开始前，导演小李递给小蓝一份清单，上面写着他想要的道具箱排列顺序：$P_1, P_2, \ldots, P_N$。导演希望小蓝在演出过程中将这排箱子调整成这个顺序。由于舞台空间狭小，每次调整只能交换相邻两个箱子的位置。且每完成一次交换，舞台灯光就会闪烁一次作为提示。

灯光系统有个特别的节奏设定：每进行 $M$ 次闪烁，灯光就会切换一种模式。为了配合这种节奏，导演强调：必须在某次灯光切换模式的那一瞬间完成所有调整工作。这意味着，小蓝完成调整所需的交换次数必须是 $M$ 的整数倍。

现在，请你帮小蓝计算一下，他最少需要多少次交换操作才能按照导演的要求完成调整。如果无论如何都无法满足要求，则输出 $-1$。


## 说明/提示

**【评测用例规模与约定】**

对于 $50\%$ 的评测用例，$1 \leq N, M \leq 10^2$，$1 \leq P_i \leq N$，$P_1, P_2, \ldots, P_N$ 互不相同。

对于 $100\%$ 的评测用例，$1 \leq N \leq 10^5$，$1 \leq M \leq 10^9$，$1 \leq P_i \leq N$，$P_1, P_2, \ldots, P_N$ 互不相同。


## 样例 #1

### 输入

```
3 2
3 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3
1 2 3```

### 输出

```
0```

## 样例 #3

### 输入

```
3 2
1 3 2```

### 输出

```
-1```

# 题解

## 作者：CSP_S_2023_T2 (赞：3)

### 思路

将道具箱从 $1$ 到 $N$ 的顺序变为给定排列，可以看成由给定排列变为 $1$ 到 $N$ 的顺序。

最少交换次数即为给定排列的逆序对数量（不懂出门右转[这里](https://www.luogu.com.cn/problem/P1774)），记为 $k$。

发现每进行一次交换，逆序对的数量会 $+1$ 或 $-1$，奇偶性会变化。

想使逆序对数量 $=0$，在交换 $k$ 次使数列升序的情况下，还要交换偶数次（此时逆序对数量为偶数）才有可能。

所以合法的交换次数为 $k+2n$，其中 $n$ 为任意自然数。

题目转化为求 $\ge k$ 的**最小**的与 $k$ 奇偶性相同，且能够被 $m$ 整除的数。

注意：若 $m$ 为偶数，$k$ 为奇数时无解。

树状数组求出 $k$，算出答案即可。

### 代码（Java）

```java
import java.util.Scanner;

public class Main{
    static final int N=100010;
    static int n,m;
    static long ans;
    static int[] a=new int[N],c=new int[N];
    
    static void add(int x,int v){
        for(int i=x;i<N;i+=(i&-i)) c[i]+=v;
    }
    
    static int query(int x){
        int cnt=0;
        for(int i=x;i>0;i-=(i&-i)) cnt+=c[i];
        return cnt;
    }
    
    public static void main(String[] args){
        Scanner scanner=new Scanner(System.in);
        n=scanner.nextInt();
        m=scanner.nextInt();
        for(int i=1;i<=n;i++) a[i]=scanner.nextInt();
        
        //求逆序对（这里 a 是一个排列，所以不用离散化）
        for(int i=1;i<=n;i++){
            ans+=i-1-query(a[i]);
            add(a[i],1);
        }
        
        //计算答案
        long t=0;
        if(ans!=0) t=(ans-1)/m+1;
        if(t*m%2==ans%2) System.out.print(t*m);
        else if((t*m+m)%2==ans%2) System.out.print(t*m+m);
        else System.out.print(-1);
    }
}
```


### 代码（C++）

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=1e5+10;
int n,m,a[N],c[N];
long long ans;

void add(int x,int v){
	for(int i=x;i<N;i+=(i&-i)) c[i]+=v;
}

int query(int x){
	int cnt=0;
	for(int i=x;i;i-=(i&-i)) cnt+=c[i];
	return cnt;
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    //求逆序对
	for(int i=1;i<=n;i++){
		ans+=i-1-query(a[i]);
		add(a[i],1);
	}
	
//	cout<<ans;
    
    //计算答案 
	long long t=0;
	if(ans) t=(ans-1)/m+1;
	if(t*m%2==ans%2) cout<<t*m;
	else if((t*m+m)%2==ans%2) cout<<t*m+m;
	else cout<<-1;
    return 0;  //完结撒花
}
```

---

## 作者：CommandSR (赞：2)

## 题意

小蓝需要将一排编号为 $1$ 到 $N$ 的道具箱从初始顺序（$1, 2, \ldots, N$）调整为导演指定的顺序 $P_1, P_2, \ldots, P_N$。每次只能交换相邻两个箱子，且交换次数必须是 $M$ 的整数倍（因为灯光系统每 $M$ 次闪烁切换一次模式，调整必须在切换时完成）。求最少需要多少次交换才能满足要求，如果无法满足则输出 $-1$。

## 题解

注意到对于一个目标序列的“最少交换次数”是固定的，且等于逆序对数量。

所以可以使用树状数组预处理逆序对数量，每次答案加上先前出现的数中比当前数大的个数。时间复杂度 $O(n \log n)$。

这样就得到了一个合法答案，接下来考虑满足 $m$ 的倍数要求。

注意到可以通过把相邻两个数交换 $2$ 次的操作，在不改变序列的基础上“凑出”操作次数。

因此计算和逆序数量奇偶性相同，且和逆序对数量最接近的 $m$ 的倍数即可。

```cpp
// ans 为逆序对数量
ll res = ceil(1.0*ans/m) * m;
if ((res-ans)&1) res += m; // 奇偶性相同
```

若逆序对数量为奇数且 $m$ 为偶数，无解。

注意特判逆序对数量等于 $0$。


## AC Code

### C++ 

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for (int i = a; i <= b; ++i)
#define _F(i, a, b) for (int i = a; i >= b; --i)
#define ll long long
using namespace std;
ll rd() {
	ll p = 0, f = 1; char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
const int N = 1e5 + 5;
ll n, m;
ll c[N];
void Upd(ll p, ll x) {
	for (int i = p; i <= n; i += (i&-i)) c[i] += x;
}
ll Qry(ll p) {
	ll res = 0;
	for (int i = p; i; i -= (i&-i)) res += c[i];
	return res;
}
int main() {
	n = rd(), m = rd();
	ll ans = 0;
	F(i, 1, n) {
		ll x = rd();
		ans += Qry(n) - Qry(x);
		Upd(x, 1);
	}
	if (!ans) cout << 0;
	else if ((ans&1) && !(m&1)) cout << -1;
	else {
		ll res = ceil(1.0*ans/m) * m;
		((res-ans)&1) && (res += m);
		cout << res << '\n';
	}
	return 0;
}
```

### Java

```java
import java.io.*;

public class Main {
    static final int N = (int)1e5 + 5;
    static long[] c = new long[N];
    static long n, m;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        n = Long.parseLong(input[0]);
        m = Long.parseLong(input[1]);
        
        long ans = 0;
        input = br.readLine().split(" ");
        for (int i = 0; i < n; i++) {
            long x = Long.parseLong(input[i]);
            ans += query(n) - query(x);
            update(x, 1);
        }
        
        if (ans == 0) {
            System.out.println(0);
        } else if ((ans & 1) == 1 && (m & 1) == 0) {
            System.out.println(-1);
        } else {
            long res = (long)Math.ceil((double)ans / m) * m;
            if (((res - ans) & 1) == 1) {
                res += m;
            }
            System.out.println(res);
        }
    }

    static void update(long p, long x) {
        for (int i = (int)p; i <= n; i += (i & -i)) {
            c[i] += x;
        }
    }

    static long query(long p) {
        long res = 0;
        for (int i = (int)p; i > 0; i -= (i & -i)) {
            res += c[i];
        }
        return res;
    }
}
```

---


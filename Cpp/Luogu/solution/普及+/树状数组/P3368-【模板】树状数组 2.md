# 【模板】树状数组 2

## 题目描述

如题，已知一个数列，你需要进行下面两种操作：

1. 将某区间每一个数加上 $x$；

2. 求出某一个数的值。

## 说明/提示

#### 样例 1 解释：

 ![](https://cdn.luogu.com.cn/upload/pic/2258.png) 

故输出结果为 6、10。

---

#### 数据规模与约定

对于 $30\%$ 的数据：$N\le8$，$M\le10$；

对于 $70\%$ 的数据：$N\le 10000$，$M\le10000$；

对于 $100\%$ 的数据：$1 \leq N, M\le 500000$，$1 \leq x, y \leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。

## 样例 #1

### 输入

```
5 5
1 5 4 2 3
1 2 4 2
2 3
1 1 5 -1
1 3 5 7
2 4```

### 输出

```
6
10```

# 题解

## 作者：Lyp10000 (赞：992)

来介绍一下差分


设数组a[]={1,6,8,5,10}，那么差分数组b[]={1,5,2,-3,5}


也就是说b[i]=a[i]-a[i-1];(a[0]=0;)，那么a[i]=b[1]+....+b[i];(这个很好证的)。


假如区间[2,4]都加上2的话


a数组变为a[]={1,8,10,7,10}，b数组变为b={1,7,2,-3,3};


发现了没有，b数组只有b[2]和b[5]变了，因为区间[2,4]是同时加上2的,所以在区间内b[i]-b[i-1]是不变的.


所以对区间[x,y]进行修改,只用修改b[x]与b[y+1]:


b[x]=b[x]+k;b[y+1]=b[y+1]-k;


---

## 作者：Banjamin (赞：655)

## 概括
树状数组是个好东西啊~（代码量少orz）
## 简介
树状数组是用数据压缩的思想由二进制实现的数据结构。有单点修改+区间查询或区间修改+单点查询的作用。
## 实现单点修改&区间查询
首先我们来看看暴力的效率。q组询问，极端情况下n个数的修改，效率为 _O(n q)_ 。n，q为500000时一定会炸。
### 切入点：lowbit函数
由于电脑一种叫做补码的操作（由于电脑是二进制，它们存的相反数是它的取反+1），一个数与它的相反数做与操作时会返回二进制下最右边的1的位置。举个例子：
6&-6=2
将6变成二进制：110。其中最右侧的1加粗字体：1**1**0则返回的是二进制下10的值：2。得到代码：
```
//ll就是long long
ll lowbit(ll num){
	return num&-num;
}
```
### 利用这个性质建立树状数组：
为了简化区间修改的效率，我们需要建立这样的一个数组：数组中第k位的值为原数组中的一段区间和，这个区间的长度是lowbit(k),终点是k。
比如：输入一个数组，那么我们所建立的数组：
- 第一位（1在二进制下=**1** 二进制下的1=1）的值为输入的数组的第一位往前的一位的和，也就是第一位。
- 第二位（2在二进制下=**1**0 二进制下的10=2）的值为输入的数组的第二位往前两位的和，第一位和第二位。
- 第三位（3在二进制下=1**1** 二进制下的1=1）的值为输入的数组的第三位往前一位的和，也就是第三位。
- 第四位的值（4在二进制下=**1**00 二进制下的100=4）的值为输入的数组的第四位往前四位的和，也就是第一位，第二位，第三位以及第四位。

我们就称这种数组为树状数组
#### 代码
```
void build(ll s,ll num){
	for(ll i=s;i<=n;i+=lowbit(i)) tree[i]+=num;//当s在i的范围内 第num位数组加上num 
}
```
跟着代码走一遍：
- 假设输入的n=5，输入的数为1 5 4 2 3（样例）
- 输入第一个数时s=1，num=1。加上的树状数组数组位数为第一位，第二位，第四位。树状数组为：1 1 0 1 0
- 输入第二个数时s=2，num=5，加上的位置为第二位，第四位。数组为1 6 0 6 0
- 输入第三个数时s=3，num=4，加上的位置为第三位。数组为1 6 4 10 0
- 输入第四个数时s=4，num=2，加上的位置为第四位。数组为1 6 4 12 0
- 输入第五个数时s=5，num=3，加上的位置为第五位。数组为1 6 4 12 3

至此，建树操作已经完成了。可以发现这个操作的本质就是修改树状数组的值，所以它**也是单点修改的函数**。
### 查询也是一样的。注意我们的操作不是区间求和，而是求两个前缀和的差！
```
//反着的建树。此操作是求输入的数据第1到第s位的和。
ll ask(ll s){
	ll ans=0;
	for(ll i=s;i>=1;i-=lowbit(i)) ans+=tree[i];//建树的反操作 
	return ans;
}
```
举一个sample（example）
求第三项和第五项之间的和。 本质上就是求5的前缀和与2的前缀和的差。（1 2 3 4 5）-（1 2）=（3 4 5）

- 先求5的前缀和。所求的就是第5（10**1**）项+第4（**1**00）项就是12+3=15。
- 再求2的前缀和。所求的就是第2（**1**0）项就是6。
- 最后作差就是15-6=9。

检验一下，3到5位的求和就是4+2+3=9。没有问题！
### 把所有的结合起来就是树状数组啦~
## 代码
```
//树状数组代码 
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
ll n,q,m,mod,x,y,tree[500001];
ll lowbit(ll num){
	return num&-num;//返回值为二进制下num从左往右第一个1的位置 
}
void build(ll s,ll num){
	for(ll i=s;i<=n;i+=lowbit(i)) tree[i]+=num;//当s在i的范围内 第num位数组加上num 
}
ll ask(ll s){
	ll ans=0;
	for(ll i=s;i>=1;i-=lowbit(i)) ans+=tree[i];//建树的反操作 
	return ans;
}
int main(){
	scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%lld",&m);
		build(i,m);//建立树状数组 
	}
	for(int i=1;i<=q;i++){
		scanf("%lld%lld%lld",&mod,&x,&y);//输入1或2 
		if(mod==1) build(x,y);//修改与建树可以共用一个函数 
		if(mod==2) printf("%lld\n",ask(y)-ask(x-1)/*思考为什么是x-1*/);//区间查询则为右边界前缀和减去左边界前缀和 
	}
}
//copy不是好习惯 
```
其中的效率为 _O（q logn）_ 。与 _O（nq）_ 有着质的差别。
## 实现区间修改&单点查询
这看起来与单点修改&区间查询差不多，但实际上有很大的区别。如果我们按照原来的效率，得到的就是 _O(n q)_ ，稳炸。
### 突破口：差分
思考一下，如果区间修改2到4位之后求第3位，我们就可以加上修改的数。而如果求第5位，我们只需要在第3位的基础上减去修改的数就可以了。举个例子：在数组第2位和第4位之间加上2，只需要将数组从0 0 0 0 0变成0 2 0 0 -2即可。当询问第3位时，答案就是输入的3的值+0+2+0即可。当询问5时，答案就是输入的5的值+0+2+0+0+-2=输入的5的值+0。这就是解法了！
### 代码
```
void add(ll s,ll num){
	chafen[s]+=num;//修改得到x,y,s时,只需要求add(x,s)和add(y,-s) 
}
```
如何让它再快一些呢？如果我们将我们刚刚打出来的树状数组来维护差分的这个数组，效率就达到最高啦~
```
void add(ll s,ll num){
	for(ll i=s;i<=n;i+=lowbit(i)) tree[i]+=num;//树状数组维护差分修改
}
```
## 查询
上文已经提过了，直接上代码~
```
ll ask(ll s){
	ll ans=0;
	for(ll i=s;i>=1;i-=lowbit(i)) ans+=tree[i];//寻找差分的标记 
	return ans;
}
```
## 最后的最后—代码
```
//树状数组代码 
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
ll n,q,mod,x,y,s,inn[500001],tree[500001];
ll lowbit(ll num){
	return num&-num;//返回值为二进制下num从左往右第一个1的位置 
}
void add(ll s,ll num){
	for(ll i=s;i<=n;i+=lowbit(i)) tree[i]+=num;//差分的思想 
}
ll ask(ll s){
	ll ans=0;
	for(ll i=s;i>=1;i-=lowbit(i)) ans+=tree[i];//寻找差分的标记 
	return ans;
}
int main(){
	scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++) scanf("%lld",&inn[i]);
	for(int i=1;i<=q;i++){
		scanf("%lld",&mod);//输入1或2 
		if(mod==1){
			scanf("%lld%lld%lld",&x,&y,&s);
			add(x,s);
			add(y+1,-s);
		}
		if(mod==2){
			scanf("%lld",&x);
			printf("%lld\n",inn[x]+ask(x));//区间查询则为右边界前缀和减去左边界前缀和 
		}
	}
}
//copy不是好习惯 
```
至此，树状数组算是完结啦~

---

## 作者：Snitro (赞：514)

这个题目是树状数组的一个拓展,在树状数组中可以用前 i 项的和来表示第 i 个数.

那么当对 x ~ y 的区间进行修改的时候需要在树状数组中的第 x 个位置 + k, 第 y + 1 个位置 -k

这样便维护了这个树状数组

输出时候直接输出查询即可









    
    

    
    

    
    
        
            
            
            
    
```cpp
#include <iostream>
#include <cstdio>
#define lowbit(x) x & -x
using namespace std;
long long tree[500005];
int n, m;
void add(int x, long long num) {
    while (x <= n) {
        tree[x] += num;
        x += lowbit(x);
    }
}
long long query(int x) {
    long long ans = 0;
    while (x) {
        ans += tree[x];
        x -= lowbit(x);
    }
    return ans;
}
int main() {
    freopen("in.txt", "r", stdin);
    scanf("%d%d", &n, &m);
    long long last = 0, now;
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &now);
        add(i, now - last);
        last = now;
    }
    int flg;
    while (m--) {
        scanf("%d", &flg);
        if (flg == 1) {
            int x, y;
            long long k;
            scanf("%d%d%lld", &x, &y, &k);
            add(x, k);
            add(y + 1, -k);
        } else if (flg == 2) {
            int x;
            scanf("%d", &x);
            printf("%lld\n", query(x));
        }
    }
    return 0;
}
```

---

## 作者：ZhYic (赞：56)

##就是常规写法
用树状数组维护一个差分数组的前缀和，因为可推得若b[i]=a[i]-a[i-1]，则a[i]=b[1]+...+b[i] *(b[1]=a[1]-a[0],a[0]=0)* 。
可发现a[i]只与b[j] (j<=i)有关，若将b[j]加上delta，其后所有值都将加dlt，因此只需改变b[i]就可实现b[i]到b[n]的区间修改。而将b[j+1]减去dlt，对a[j]无影响，其后所有值也减去dlt，恢复原值，即实现了区间修改操作。
因为求取a值用到的是前缀和，因此设t[i]为b[1]到b[i]的前缀和，a[i]=t[i]=b[1]+...b[i]，即可大大降低时间复杂度。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define N 530000
long int t[N<<2],n,op,l,r,type,x,k,a[N];
inline long int lowbit(long int &x){return x&(-x);}
long int getsum(long int x)
{
    long int sum=0;
    while(x>0)
    {
        sum+=t[x];
        x-=lowbit(x);
    }
    return sum;
}
void update(long int x,long int dlt)
{
    while(x<=n)
    {
        t[x]+=dlt;
        x+=lowbit(x);
    }
}
int main()
{
    //ios::sync_with_stdio(false);
    cin>>n>>op;
    for(int i=1;i<=n;i++)
        {scanf("%ld",&a[i]);update(i,a[i]-a[i-1]);}
    while(op--)
    {
        scanf("%d",&type);
        if(type==2){scanf("%d",&l);printf("%ld\n",getsum(l));}
        else
        {
            scanf("%ld%ld%ld",&l,&r,&k);
            update(r+1,-k);
            //区间操作就直接把1到右端点r+1的差分数组前缀和减去k，1到l的差分前缀和加上k
            update(l,k);
        }
    }
    return 0;
}

```
#####树状数组解释如下：

![来源：百度图片搜索](https://ss1.bdstatic.com/70cFuXSh\_Q1YnxGkpoWK1HF6hhy/it/u=2531321565,556560620&fm=27&gp=0.jpg)

树状数组每个节点所存的值都有不同含义，具体意义则为C[i]=A[i]+A[i-1]+....+A[i-2^k+1]（k表示i的二进制末尾连续0的个数）;

** 举个粟子 **

```cpp
C[1]=a[1];
C[2]=a[2]+a[1];
C[3]=a[3];(3='11'[2]，所以k=0，i-2^k+1=3-1+1=3)
C[4]=a[4]+a[3]+a[2]+a[1];(4='100'，k=2，i-2^k+1=4-2^2+1=1)
```
依此类推。
而如何得到一个数二进制末尾0的个数呢？这就需要用到[补码（戳这里）](http://blog.csdn.net/chen\_lady/article/details/51105535 )了，具体解释见此[完全认识树状数组](https://www.cnblogs.com/GeniusYang/p/5756975.html)。

易知（假的，二进制数A在第k位有个1且最低位不为1，则表示的是第1～k位有1，且小于A的C[ ]的和。

如：3=11，C3=C'11';4=100，C4=C'001'+C'010'+C'011'+C'100'；

**最后，一定要记住：**看不懂也不要紧，会用就可以。



---

## 作者：MoXiaodu (赞：50)

### 说明：

>题解存在了懒标记传递时会多传一层导致正常的4倍n空间无法通过，现已修改完毕，望通过！

------------
首先，我们可以想到用线段树来做这道题。~~不会告诉你其实我不会树状数组~~

数据太大就会超时，怎么办？这样就要引出我们的好帮手懒标记了！

一个支持区间修改的线段树, 就要用到lazy标记. 用到哪一个结点, 有效数据就更新到哪一个结点, 避免浪费更新那些不必要的结点的时间. 从根部向下找一个结点, 一路下来根据lazy的设定进行相关的更新操作, 就能快速完成任务.

下面就示范一组样例：

8 2

3 3 3 3 3 3 3 3

1 2 7 1

2 3

相信大家对线段树已经有了一定的了解（没了解过的看这里[洛谷日报4](https://baijiahao.baidu.com/s?id=1605870136961096251&wfr=spider&for=pc)）那我们就开始构造线段树，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bfin1kn3.png)

这就是基本的线段树了，然后开始进行第一步，从2到7，一次给区间加上1：

![](https://cdn.luogu.com.cn/upload/image_hosting/o2b3xfnp.png)

来解释这一幅图，首先看我们存线段树的下标1，L（左节点）=1，R（右节点）=8，没有被包含且懒标记=0，所以取中点mid=(1+8)/2=4,查找左右子树。

来到左子树2，L=L(father's)，R=mid(father's)，没有被完全包含且懒标记=0，所以继续查找左右子树。

来到2的左子树4，没有被包含且懒标记=0，所以查找左右子树，因为左子树的右节点大于2，所以不进入。来到右子树9，被包含，所以dis[9]+=1，懒标记+=1，返回。

返回到2，查找右子树5，被包含，所以dis[5]+=(4-3+1)* 1，懒标记+=1，返回。

回到1，查找右节点3……以此类推，dis[6]+=(6-5+1)* 1,懒标记+=1;dis[14]+=1,懒标记+=1;

这样，区间修改就完成了。

来到第二步，查找3：

![](https://cdn.luogu.com.cn/upload/image_hosting/fgku6jbj.png)

从1开始找到2，在找到5，发现有懒标记，所以把懒标记下传到10和11,
dis[10]+=1;懒标记[10]+=1;dis[11]+=1,懒标记[11]+=1,懒标记[5]=0;
到10，L=R=3，return dis[10];查询就完成了。

可能有人会说懒标记看起来没有什么用，但数据一旦很大，递归传递就显得尤为方便，可以为我们节省很多时间。

接下来是对代码的详细讲解：

初始化：


```cpp

struct Tree{
	long long l,r;//l:左节点 r:右节点 
	long long dat,laze_tag;//dat:当前节点的值 laze_tag:懒标记，记录改变的值，递归传值 
}t[2000001];//四倍n 
```
然后是我们的懒标记传递：

```cpp
inline void f(long long p,long long k){
	t[p].laze_tag+=k;//懒标记传递 
	t[p].dat+=k*(t[p].r-t[p].l+1);//当前值加上所有节点总数*值 
} 
inline void pushdown(long long p){
	f(p*2,t[p].laze_tag);
	f(p*2+1,t[p].laze_tag);
	//将懒标记的值传给下面的左右儿子节点
	t[p].laze_tag=0;//复原懒标记 
}
```
（下面会有再查找和修改时的懒标记处理）

开始先要构造我们的线段树


```cpp
void js(int p,int l,int r){//建树 
	t[p].l=l;t[p].r=r;//记录左右节点 
	if(l==r){//到达底部返回值 
		t[p].dat=a[l];return;
	}
	long long mid=(l+r)/2;//中点 
	js(p*2,l,mid);
	js(p*2+1,mid+1,r);
	//递归初始化 
	t[p].dat=t[p*2].dat+t[p*2+1].dat;
	//加上左右儿子节点 
}
```
第二步，就要写我们的区间加减了

```cpp
void pushs(long long p,long long l,long long r,long long v){//区间加减 
	if(t[p].l>=l&&t[p].r<=r){//如果区间被包含就修改并打上懒标记 
		t[p].dat+=v*(t[p].r-t[p].l+1);//加上所有值 
		t[p].laze_tag+=v;//懒标记修改 
		return;
	}
	pushdown(p);//查询懒标记，因为下面要递归 
	long long mid=(t[p].r+t[p].l)/2;//取中点 
	if(l<=mid)pushs(p*2,l,r,v);//修改左边 
	if(r>mid) pushs(p*2+1,l,r,v);//修改右边 
	t[p].dat=t[p*2].dat+t[p*2+1].dat;//回溯时加上左右儿子节点的值 
}
```
最后是最容易的单点查询
```cpp
long long outt(long long p,long long l){//单点查询 
	 
	if(t[p].l==l&&t[p].r==l)return t[p].dat;//找到目标点就返回 
    pushdown(p);//先回复懒标记的值再传递，因为下面可能递归（要判断是否到了底部，就是这里出了问题QwQ）
	long long mid=(t[p].l+t[p].r)/2;//记录中点 
	if(l<=mid)return outt(p*2,l);//找左边 
	if(l>mid)return outt(p*2+1,l);//找右边 
}
```
看完了，那就贴上完整的代码啦！
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;//n:长度 m: 询问 
long long a[500001];
struct Tree{
	long long l,r;//l:左节点 r:右节点 
	long long dat,laze_tag;
}t[2000001];
inline long long read(){
	long long f=1,outt=0;char a=getchar();
	while(a>'9'||a<'0'){if(a=='-')f=-1;a=getchar();}
	while(a<='9'&&a>='0'){outt*=10;outt+=a-'0';a=getchar();}
	return f*outt;
}//读入优化 
inline void f(long long p,long long k){
	t[p].laze_tag+=k;
	t[p].dat+=k*(t[p].r-t[p].l+1);
} 
inline void pushdown(long long p){
	f(p*2,t[p].laze_tag);
	f(p*2+1,t[p].laze_tag);
	t[p].laze_tag=0;
}
void js(int p,int l,int r){
	t[p].l=l;t[p].r=r;
	if(l==r){
		t[p].dat=a[l];return;
	}
	long long mid=(l+r)/2;//中点 
	js(p*2,l,mid);
	js(p*2+1,mid+1,r);
	t[p].dat=t[p*2].dat+t[p*2+1].dat;
}
long long outt(long long p,long long l){
	if(t[p].l==l&&t[p].r==l)return t[p].dat;
    pushdown(p);
	long long mid=(t[p].l+t[p].r)/2;
	if(l<=mid)return outt(p*2,l);
	if(l>mid)return outt(p*2+1,l);
}
void pushs(long long p,long long l,long long r,long long v){
	if(t[p].l>=l&&t[p].r<=r){
		t[p].dat+=v*(t[p].r-t[p].l+1);
		t[p].laze_tag+=v;
		return;
	}
	pushdown(p);
	long long mid=(t[p].r+t[p].l)/2;
	if(l<=mid)pushs(p*2,l,r,v); 
	if(r>mid) pushs(p*2+1,l,r,v);
	t[p].dat=t[p*2].dat+t[p*2+1].dat;
}
void change(long long p,int x,int v){//单点修改，不必在意，是区间修改的子问题，连标记都不用(而且本题不需要)
	if(t[p].l==t[p].r){
		t[p].dat+=v;return;
	}
	int mid=(t[p].r+t[p].l)/2;
	if(x<=mid)change(p*2,x,v);
	else change(p*2+1,x,v);
	t[p].dat=t[p*2].dat+t[p*2+1].dat;
}
int main(){
	n=read();m=read();//读入 
	for(int i=1;i<=n;i++)
		a[i]=read();
	js(1,1,n);//建树 
	for(int i=1;i<=m;i++){
		long long pd=read();
		if(pd==2){
			long long ll=read();
			printf("%lld\n",outt(1,ll));//查询ll的值 
		}
		else 
		if(pd==1){
			long long ll=read(),rr=read(),x=read();
			pushs(1,ll,rr,x);//修改从ll到rr的值加上x 
		}
		else
		if(pd==3){
			int k=read(),y=read();
			change(1,k,y);
		}
	}
	return 0;//华丽丽的结束，可以A掉树状数组2了！！！ 
}
```
第一次写正经的题解，有错误请指出，码风什么的还请多多包涵啦！

---

## 作者：AcceleratorX (赞：44)

其实这道题说是“树状数组模板”，但是要用到差分的思想

也许是差分经常和树状数组一起用吧。。

差分思想：

设b[i]为a[i]-a[i-1],则a[i]就可以表示为b[i]+b[i-1]+..+b[1]。

一操作：

可以用差分来快速解决，将b[l]和b[r+1]加上x，就可以将整个区间加x（证明好证）

二操作：

光枚举1~n求和太慢了，可以用树状数组来优化。这时的c数组便是差分和

code:


```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int n,m,l,r,x;
    long long c[500010],k,a;
    int lowbit(int x){
        return x&(-x);
    }
    void change(int x,long long y){
        while(x<=n){
            c[x]+=y;
            x+=lowbit(x);
        }
    }
    long long solve(int x){
        long long cnt=0;
        while(x){
            cnt+=c[x];
            x-=lowbit(x);
        }
        return cnt; 
    }
    int main(){
        scanf("%d%d",&n,&m);
        long long now=0;
        for(int i=1;i<=n;i++){
            scanf("%lld",&a);//这里的now相当于上一个a[i-1]
            change(i,a-now);
            now=a;//更新
        }
        while(m--){
            scanf("%d",&x);
            if(x==1){
                scanf("%d%d%lld",&l,&r,&k);
                change(l,k);//差分
                change(r+1,-k);//差分
            }
            else{
                int s;
                scanf("%d",&s);
                printf("%lld\n",solve(s));//求和
            }
        }
        return 0;
}
```

---

## 作者：Hexarhy (赞：20)

逛了一圈题解，发现大都没有合格的思路讲解和 $\LaTeX$ 的应用。

这里来补发一篇，顺便涨咕值。

本篇题解将把**重心**偏向为什么且如何通过差分来实现本题要求，因而将淡化甚至略过树状数组的相关知识。

有关树状数组的详情请看[这里](https://www.luogu.com.cn/problemnew/solution/P3374)。

-----------

### 解题思路

**前置知识**：

- 树状数组入门。详情点[这里](https://www.luogu.com.cn/problemnew/solution/P3374)。本题是一个小小的拓展而已。
- 差分基础知识。

我们知道，普通的树状数组维护的是一个**前缀和**数组，支持**单点修改**和**区间查询**。

但是这道题目，要我们实现**区间修改**和**单点查询**。

对于区间修改，有一种很暴力思路是：

- 遍历 $[L,R]$ 的区间，每次进行一次单点修改。

然而时间复杂度最劣为 $O(n^2\log n)$，显然这是会超时的。

想到这，学过的同学就能很敏感的想到，**差分**可以轻松解决。

----------

**提示：下面大部分内容关于差分。若您已经非常熟悉请跳过。**

举个例子：记差分数组为 $T$。

原来的序列为：

| 1 |2  | 3 | 4 |5  |
| :----------: | :----------: | :----------: | :----------: | :----------: |

差分数组为：

| 1 |1  | 1 | 1 |1  |
| :----------: | :----------: | :----------: | :----------: | :----------: |

在 $[2,4]$ 之间 $+2$，则序列为：

| 1 |4 | 5 | 6 |5  |
| :----------: | :----------: | :----------: | :----------: | :----------: |

差分数组变为：

| 1 |3 | 1 | 1 |-1  |
| :----------: | :----------: | :----------: | :----------: | :----------: |

对比发现，只有 $T_2+2$，以及 $T_5-2$。只用了两次单点修改。

推广一下：

对于序列 $a_1,a_2,a_3,\cdots,a_n$，在区间 $[L,R]$ 内加上 $\Delta$，不难发现：

- $[L,R]$ 由于加上同一个数，**相对大小是不变**的，因此 $(L,R]$ 区间内的 $T$ 不需要修改。

- 而 $T_L=a_L-a_{L-1}$，$a_{L-1}$ 大小不变，只有 $a_L$ 增加了 $\Delta$，因此 $T_L$ 增加了 $\Delta$。同理，$T_{R+1}$ 减少 $\Delta$。

通过上述方法，就可以实现只修改 $T_L$ 和 $T_{R+1}$ 共两次就完成了 $[L,R]$ 的区间修改。时间复杂度大大降低。

我们只需用树状数组维护这个 $T$ 就可以了。

但是对于**单点查询**，需要略微改动。

我们直接输出`query(x)`即可，因为$a_x=\sum^x_{i=1}T_i$，而树状数组询问恰好是**差分数组的前缀和**。

时间复杂度依然为 $O(n\log n)$。

------------

### 其它方法

模板题自然有很多解法，这里顺带一提。详情请看其它题解。

- 分块。
- 线段树。
- 差分。
- ~~cdq分治。~~

----

### 参考代码

其实也就是略加改动。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN=6e5+5;
int n,m;
int tree[MAXN],a[MAXN];

inline int lowbit(const int x)
{
	return x&(-x);
}

void modify(int x,const int k)
{
	while(x<=n)
	{
		tree[x]+=k;
		x+=lowbit(x);
	}
}

int query(int x)
{
	int res=0;
	while(x)
	{
		res+=tree[x];
		x-=lowbit(x);
	}
	return res;
}
//以上都是树状数组模板
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		modify(i,a[i]-a[i-1]);//a[i]-a[i-1]就是求差分数组
	}
	for(int i=1;i<=m;i++)
	{
		int opt,x,y,k;
		cin>>opt>>x;
		if(opt==1)
		{
			cin>>y>>k;
			modify(x,k);
			modify(y+1,-k);//修改两次差分数组，就完成区间修改序列
		}
		if(opt==2)
		 cout<<query(x)<<endl;//直接输出即可，原因说过
	}
	return 0;
}
```

---

## 作者：Phecda (赞：20)

看到题解里，没有用线段树的~~（我线段树这么不受人待见吗？！）~~
于是，我来写一发线段树的题解，~~很简单就是在线段树1那个板子的基础上修改了一点点~~

同样是用一棵线段树来维护整个数列，我们只需要做到区间修改和单点查询两个操作。
区间修改？怎么改呢？

```cpp
inline void addval(int rt){
	int l=t[rt].left,r=t[rt].right;
	if(a<=l&&r<=b){//判断我们当前是否应该进行修改
		t[rt].tag+=x;//先打上懒标记
		t[rt].data+=(t[rt].right-t[rt].left+1)*x;
        //由于线段树的节点是管理一个区间
        //所以我们在修改节点值的时候，应该用区间去乘需要加入的值x
		return ;
	}
	if(t[rt].tag) pushdown(rt);//有标记要先下传标记
	if(a<=mid) addval(ls);
    //如果要查询的区间有部分在左子树，那么向左子树修改
	if(b>mid) addval(rs);
    //同上，向右子树修改
	update(rt);//同pushup
	return ;
}
```
好了，解决了区间修改，我们要考虑单点查询了！
线段树是以区间查询著称，那么怎么才能做到单点修改呢？
```cpp
inline void query(int rt){
	a=pos,b=pos;//这里是我修改的地方
    //我们用线段树修改时，是修改一个区间，它的左右端点分别是a，b
    //单点查询，我们把它看作是一个长度为1的区间，左右端点相同
    //所以我们把要查询的位置都赋值给a和b，这样就达到了单点查询的目的
	int l=t[rt].left,r=t[rt].right;
	if(a<=l&&r<=b){//同上一段代码
		ans+=t[rt].data;
		return ;
	}
	if(t[rt].tag) pushdown(rt);
	if(a<=mid) query(ls);
	if(b>mid) query(rs);
	return ;
}
```

接下来附上完整代码：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define ls (rt<<1)
#define rs (rt<<1|1)
#define mid ((l+r)>>1)
#define update(rt) t[rt].data=t[ls].data+t[rs].data
#define N 500005
//宏定义大法好

using namespace std;

struct tree{
	ll tag,data;
	int left,right;
}t[(N<<4)+5];//之前因为数组开小了，RE了3个点

int n,m,pos;
ll s[N],ans;
int a,b,x,k;

inline void build(int rt,int l,int r){
//递归建树
	t[rt].left=l;t[rt].right=r;t[rt].tag=0;
	if(l==r){
		t[rt].data=s[l];
		return ;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	update(rt);
	return ;
}

inline void pushdown(int rt){//标记下传
	t[ls].tag+=t[rt].tag;
	t[rs].tag+=t[rt].tag;
	t[ls].data+=t[rt].tag*(t[ls].right-t[ls].left+1);
	t[rs].data+=t[rt].tag*(t[rs].right-t[rs].left+1);
	t[rt].tag=0;
	return ;
}

inline void addval(int rt){
//区间修改
	int l=t[rt].left,r=t[rt].right;
	if(a<=l&&r<=b){
		t[rt].tag+=x;
		t[rt].data+=(t[rt].right-t[rt].left+1)*x;
		return ;
	}
	if(t[rt].tag) pushdown(rt);
	if(a<=mid) addval(ls);
	if(b>mid) addval(rs);
	update(rt);
	return ;
}

inline void query(int rt){
//单点查询
	a=pos,b=pos;
	int l=t[rt].left,r=t[rt].right;
	if(a<=l&&r<=b){
		ans+=t[rt].data;
		return ;
	}
	if(t[rt].tag) pushdown(rt);
	if(a<=mid) query(ls);
	if(b>mid) query(rs);
	return ;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%lld",&s[i]);
	build(1,1,n);
	for(int i=1;i<=m;++i){
		scanf("%d",&k);
		if(k==1){
			scanf("%d%d%d",&a,&b,&x);
			addval(1);//区间修改
		}
		else{
			scanf("%d",&pos);//要查询的位置
			query(1);
			printf("%lld\n",ans);
			ans=0;
		}
	}
	return 0;
}
```


---

## 作者：you_xiao (赞：18)

# 树状数组还行吧
###### ~~我还是想叫他树数组~~

今天我们学树状数组，老师的题我不会，就来看看模板，顺便发一条处女题解。大佬们都在刷蓝题紫题，也就我这样的蒟蒻写模板。。。
于是看看我的成果

### 应该是差分来搞

之前没研究，刚刚发现差分挺好用

### 差分
对于一个数组，有差分序列 b[1]=a[1];b[i]=a[i]-a[i-1];

比如A={a1,a2,a3,a4,a5};

则有B={a1,a2-a1,a3-a2,a4-a3,a5-a4};

#### 他和前缀可以互逆运算

对B有S={a1,a2-a1+a1,a3-a2+a2-a1+a1....}

及S={a1,a2,a3,a4,a5}

差分的前缀就是原数组，同理，前缀的差分是原数组

```cpp
b[1]=a[1];
for(int i=1;i<=n;i++){//维护一下差分
	b[i]=a[i]-a[i-1];
}       
cin>>x>>y>>k;
b[x]+=k;//修改左右节点的差分值（连起来读）
b[y+1]-=k;//这样就能够使只有这一段的数据改变
for(int i=1;i<=n;i++){//因为要再算前缀b[y]-k
	s[i]=b[i]+b[i-1];//后，后面就不影响了
}

```
这样一来，美滋滋。

差分 树数组（叫着挺舒服的）
### 原数组
原数组每次读入时，减去前一个，再加到树数组里，这样就差分了。
### 操作
每次读入操作，有左右两个节点，中间加k，

根据树状数组的性质，只需要前后节点都维护就行了
```
void add(int x,int k){

	while(x<=n){
		c[x]+=k;
		x+=lowbit(x);
	}
}

add(x,k);
add(y+1,-k);
```


### 提取

因为我们用的是差分，该节点的结束值就是此时差分数组的前缀，于是

```
int ans(int x){
	int an=0;
	while(x>0){
		an+=c[x];
		x-=lowbit(x);
	}
	return an;
}
printf("%d\n",ans(a));
```
最后是完整代码
```
#include<bits/stdc++.h>
using namespace std;
int c[500050],n,m;

int lowbit(int x){	//lowbit操作
	return x&(-x);
}

void add(int a,int x){	//更改数值
	while(x<=n){
		c[x]+=a;
		x+=lowbit(x);
	}
}

int ans(int x){	//提取数值
	int an=0;
	while(x>0){
		an+=c[x];
		x-=lowbit(x);
	}
	return an;
}

int main(){
	scanf("%d",&n);
	int la=0,a;
	memset(c,0,sizeof(c));	//好习惯（学长血的教训
	for(int i=1;i<=n;i++){	//读入时差分
		scanf("%d",&a);
		add(a-la,i);
		la=a;
	}
	
	int k,a,b,aa;
	for(int i=1;i<=m;i++){	//千万不要直接scanf("%d%d%d%d"&k,&a,&b,&aa);会爆0
		scanf("%d",&k);
		if(k==1){
			scanf("%d%d%d",&a,&b,&aa);
			add(aa,a);
			add(-aa,b+1);
		}
		else {
			scanf("%d",&a);
			printf("%d\n",ans(a));
		}
	}
	return 0;
} 

```
码风比较垃圾，请见谅

新玩家，比较菜，希望大佬指导



---

## 作者：Drug__Lover (赞：17)

**楼下众神犇好像都用了一个这个东西**

```cpp
change(i,a1[i]-a1[i-1]); 
```
**对于蒟蒻的我当时并不理解**

**只好半懵逼半清醒的抄上AC了**

**很久之后的现在又来做了一下这道题**

**发现了一个好理解的？（题解并没有看到底，不知道有没有重复的）**

**对于修改我们可以用树状数组维护差分数组**

**但是用树状数组我们仅维护修改的值（也就是改变的值）**

**最后查询的时候加上初始值就好了**


```cpp
#include<iostream>
#include<cstdio>
#define maxn 500100
using namespace std;
int n,m;
int c[maxn];
int a[maxn];
int add(int x,int k)
{
    for(int i=x;i<=n;i+=i&(-i)) c[i]+=k;
}
int query(int x)
{
    int sum=0;
    for(int i=x;i>0;i-=i&(-i)) sum+=c[i];
    return sum;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)  scanf("%d",&a[i]);
    while(m--)
    {
        int k;
        scanf("%d",&k);
        if(k==1)
        {
            int x,y,z;
            scanf("%d%d%d",&x,&y,&z);
            add(x,z);           //维护查分数组
            add(y+1,-z);
        }
        else
        {
            int x;
                        scanf("%d",&x);
            printf("%d\n",a[x]+query(x));   //query()求的是改变的值，再加上原来的值就可以了
        }
    }
    return 0;
}

```

---

## 作者：小小小朋友 (赞：9)

#### 题目描述

区间修改，单点询问

#### 思路简述

我们看到题目是"树状数组"，但是身为蒟蒻的我总是写不对差分，于是我们来看一看一种**最坏**复杂度为$O(m\sqrt n)$的想法——分块！

分块的优点在于其极其好写，思路简单，可视为一种暴力的改进版

我们把这个数组分为$\sqrt n$块，这样做的好处很明显，每次进行修改可直接对整块进行加法，不是整块则一个一个加，两个操作的复杂度均为$\sqrt n$。询问时只需直接输出块所积累的和加上在处理单个时所积累的和即可。

我们发现这玩意最大跑了500多ms，过了本题。

#### 代码及解释

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll z,y,x,t,L,n,m,a[500005],b[500005],c[10005];
//a数组存储单个累计的和
//b数组存储改数位于哪一块
//c数组存储整块累计的和
void add(ll x,ll y,ll z){
	if(b[x]==b[y])//这里要特判
		for(ll i=x;i<=y;i++) a[i]+=z;
	else {
		for(ll i=x;b[i]==b[x];i++) a[i]+=z;//单块的和
		for(ll i=y;b[i]==b[y];i--) a[i]+=z;
		for(ll k=b[x]+1;k<=b[y]-1;k++) c[k]+=z;//整块的和
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	L=sqrt(n);//块的大小
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(ll i=1;i<=n;i++) b[i]=(i-1)/L+1;//填写b数组
	for(ll i=1;i<=m;i++){//没什么要说的
		scanf("%lld%lld",&t,&x);
		if(t==1){
		    scanf("%lld%lld",&y,&z);
			add(x,y,z);
		}
		else printf("%lld\n",(a[x]+c[b[x]]));
	}
	return 0;
}
```

---

## 作者：vectorwyx (赞：8)

之前看了许多大佬的题解蒟蒻都不太明白

最后还是自己看的小伙伴的代码才恍然大悟（可能是因为我太蒻了）

因此我决定写一篇详细的题解

（如果您还未接触过树状数组，请左转[【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)）


------------

通过之前的学习我们学会了运用树状数组进行单点修改和区间查询

但是这一题要求是**区间修改，单点查询**

那我们就**想办法把区间修改、单点查询转化为单点修改、区间查询**呗


------------
怎么转化呢？这里我们要引入一个新概念：**差分**

差分是啥？简单的说，差分就是指**两项之差**

如果我们对一个含有$n$个元素的数组$a$进行差分的话，会得到另一个数组$b$

其中，$b_{i}=a_{i}-a_{i-1}$ $(2<=i<=n)$

特别地，$b_{1}=a_{1}$

我们姑且把$b$数组称为$a$数组的**差分数组**

举个例子：
```
如果原数组a为：1 3 6 7 9 13
则差分数组b为：1 2 3 1 2 4
```
------------
好，理解了差分，我们终于要步入正题了

仔细观察刚才的例子，有没有发现什么规律？

$a_{1}=b_{1};$

$a_{2}=b_{1}+b_{2};$

$a_{3}=b_{1}+b_{2}+b_{3};$

……

不难证明$a_{i} =$ $\sum_{k=1}^{i}b_{k}$

因此，如果我们先把给定数组$a$的差分数组$b$求出来

那我们的单点查询$a_{i}$不就变成区间查询$\sum_{k=1}^{i}b_{k}$了吗？

您可能觉得这有点傻，不要着急，我们接着来看区间修改


------------
在这一题中，差分数组最大的好处就体现在区间修改上

还是之前那个例子：
```
a：1 3 6 7 9 13 原数组
b：1 2 3 1 2 4  差分数组
```

现在我要求把区间[2,5]的元素都加上4

那么就变成了这个亚子：
```
a: 1 7 10 11 13 13
b: 1 6 3  1  2  0
```
诶？貌似b数组中只有$b_{2}$和$b_{6}$发生了改变

那我们可以大胆猜测一下：

**区间修改[$i$,$j$]，都加上$v$，b数组中只有$b_{i}$和$b_{j+1}$会发生改变**


------------

 为什么？因为对于$b_{k}$ $(k\in{i+1,j})$

由于$b_ {k}=a_ {k} -a _ {k-1}$ **且$a_ {k}$和$a_ {k-1}$同时加上了$v$**

所以$a_ {k}$和$a_ {k-1}$的差不会变，故$b_{k}$的值不变

那么$b_ {i}$和 $b_ {j+1}$的值又会怎么变化呢？

因为$b_ {i}=a_ {i}-a_ {i-1}$ 

又因为$a_ {i-1}$的值没有改变，$a_ {i}$的值加上了$v$

故$b_ {i}$的值会加上$v$

同理，$b_ {j+1}$的值会减去$v$，也就是加上$-v$


------------
总结一下，**将区间[$i$,$j$]的值都加上$v$**

**就相当于把$b_{i}$的值加上v，把$b_{j+1}$的值加上$-v$**

我们又把区间修改转化成了两次单点修改，真是太棒了！


------------
那我们对于给定的数组$a$，**用树状数组维护其差分数组**$b$

单点查询$a_{i}$=区间查询$\sum_{k=1}^{i}b_{k}$

区间修改$a_{i,j}$，将其加上v =单点修改$a_{i}$,$a_{j+1}$

特别要注意的是，这里我们**维护的是差分数组**


------------
代码来了~
```cpp
#include<iostream>
#include<cstdio>
#define maxn 500001
#define fo(x,y) for(register int i=x;i<=y;++i)
//宏定义简化for循环
using namespace std;
int n,tree[maxn];//n为元素个数，tree数组用来维护差分数组
inline int lowbit(int x){//老生常谈的lowbit函数
	return (x-(x&(x-1)));//这里换了一种形式
} 
inline void update(int x,int v){
//单点修改：将下标为x的元素加上v
	while(x<=n){
		tree[x]+=v;
		x+=lowbit(x);
	}
}
inline int ask(int x){
//区间查询[1,x]，在这一题中等价于单点查询x
	int ans=0;
	while(x){
		ans+=tree[x];
		x-=lowbit(x);
	}
	return ans;
} 
int main(){
	int m,last=0,t,x,y,k;
//last用来记录上一个元素，t用来记录当前元素
//两者相减可得到差分数组
	cin>>n>>m;
	fo(1,n){
		scanf("%d",&t);
		update(i,t-last);//单点修改，维护差分数组
		last=t;
	}
	fo(1,m){
		scanf("%d%d",&t,&x);
		if(t==1){//区间修改
			scanf("%d%d",&y,&k);
			update(x,k);//等价于两次单点修改
			update(y+1,-k);
		}
		else{//单点查询
			printf("%d\n",ask(x));//等价于区间查询
		}
	}
	return 0;
}

```
点个赞再走吧~

---

## 作者：hfee (赞：7)

### 引入
**树状数组是什么？**

树状数组是一个查询和修改复杂度都为log(n)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值;经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。（by 百度百科）

简单点说，就是一个可以很快区间修改，单点修改，区间查询，单点查询的数据结构

题外话：其实线段树也可以做到这一点，并且比树状数组可实现的东西多得多，但是因为树状数组简单好写，且效率还要高些，所以在这题我们写树状数组

### 怎么做？

遥想我当年一道黄题没做过就点开了这题，欸？这么简单？难道人生第一道黄题就是这道了吗？然后我就交了一个这样的程序：
```
for(int j=l;j<=r;j++) a[j]+=k;
```
欸，怎么不对？点开题解两分钟后，我默默地关掉了页面...

扯远了，讲正经的,其实树状数组跟树的关系并不太大，当n=8时，它是下面这个样子的：
(A是输入的数组，C是我们的树状数组）
![](http://images.cnblogs.com/cnblogs_com/wxl-Ezio/1173002/o_QQ%e6%88%aa%e5%9b%be20180412203826.png)
其中

$C[1]=A[1]$

$C[2]=A[1]+A[2]$

$C[3]=A[3]$

$C[4]=A[1]+A[2]+A[3]+A[4]$

$C[5]=A[5]$

$C[6]=A[5]+A[6]$

$C[7]=A[7]$

$C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]$

以此类推

那么这颗树有什么用呢？

假设我们要给$A[1]$加上1，哪些数值会被改变？

$C[1],C[2],C[4],C[8],C[16]...$

$A[2]$呢？

$C[2],C[4],C[8],C[16]$

$A[3]$

$C[3],C[4],C[8],C[16]$

$A[5]$

$C[5],C[6],C[8],C[16]$

我相信你看出规律了，对吧（逃

好吧你只要知道，如果给$A[I]+K$，设$I$二进制最后一位$1$所在的位置是$q$,那么$C[I]$和$C[I+q]$都会$+K$就行了（$I$和$q$不断更新）

//这LATEX给我写吐了

比如说$A[5]$

$5$用二进制是$101$,所以$C[5]+=k$的值会使$C[101+1]$即$C[6]+=k$

而$C[6]+=k$时,因为$6=110$同时又会使$C[110+10]$即$C[8]+=k$

然后$C[8]+=k$又会使$C[16]+=k$

以此类推,直到要超过$n$

//呕~呸

### 代码实现

首先，**单点修改**怎么做？

介绍一个东西叫$lowbit$，这个东西是用来求出一个数转化为二进制后，最后一个1所在的位置

别想了，不是系统自带的函数，要自己写的

它的写法是

```
int lowbit(int k){
	return k&-k;
}
```
神奇吗？为什么呢？首先，&符号是与，-k因为补码的原因，从右向左遇到第一个1为止，这个1前面的位取反，首位不动

那么再利用与运算只取两个1的特性，我们就返回了
$2^p$(其中$p: k$ 的二进制表示数中， 右向左数第一个1的位置)

好了，那么怎么add呢？刚刚已经讲过了，如果给$A[I]+K$，设$I$二进制最后一位$1$所在的位置是$q$,那么$C[I]$和$C[I+q]$都会$+K$

代码就是
```
void add(int x,int q){
	while(x<=n){
		a[x]+=q;
		x+=lowbit(x);
	}
}
```
很简单，不是吗

那么第二个，**区间查询**呢？

我们用前缀和的思想，$x$到$y$的和，那么就将从$1$到$y$的和减去从$1$到$x-1$的和。

$1$到$x$的和求法是，将$x$转为$2$进制，然后一直减去$lowbit(x)$，直到$0$

```
int sum(int x){
	ans=0;
	while(x){
		ans+=a[x];
		x-=lowbit(x);
	}
	return ans;
}
```
好了，那么我们已经可以ACP3374了，但我们还要ACP3368

那么就要讲到差分

差分是什么？设数组$a=${$1,2,3,6,4$}，那么差分数组$b=${$1,1,1,3,-2$}，$b[i]=a[i]-a[i-1]$,那么很显然，求$a[i]$就是$b[1]+b[2]+...+b[i]$

假设我们位区间{2，4}都+3，那么数组$a$变为{$1,5,6,9,4$},$b$变为{$1,4,1,3,-5$}

看，只有$b[2]$和$b[5]$变了，这是因为2到4都加了2，那么差并不会变

所以怎样给区间加和呢？我们先把树状数组变为差分数组，然后再加时直接加b[x-1]和b[y]，这题就解决了

P3374 【模板】树状数组 1 代码
```
#include<bits/stdc++.h>
int n,m,a[500005],ans,w,xx,yy,zz; 
using namespace std;
int lowbit(int k){
	return k&-k;
}
void add(int x,int q){
	while(x<=n){
		a[x]+=q;
		x+=lowbit(x);
	}
}
int sum(int x){
	ans=0;
	while(x){
		ans+=a[x];
		x-=lowbit(x);
	}
	return ans;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w;
		add(i,w);
	}
	for(int i=1;i<=m;i++){
		cin>>xx>>yy>>zz;
		if(xx==1) add(yy,zz);
		else cout<<sum(zz)-sum(yy-1)<<endl;
	}
	return 0;
}

```
P3368 【模板】树状数组 2 代码
```
#include<bits/stdc++.h>
int n,m,a[500005],ans,w,xx,yy,zz,kk,lst; 
using namespace std;
int lowbit(int k){
	return k&-k;
}
void add(int x,int q){
	while(x<=n){
		a[x]+=q;
		x+=lowbit(x);
	}
}
int cx(int x){
	ans=0;
	while(x){
		ans+=a[x];
		x-=lowbit(x);
	}
	return ans;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w;
		add(i,w-lst);
		lst=w;
	}
	for(int i=1;i<=m;i++){
		cin>>xx;
		if(xx==1){
			cin>>yy>>zz>>kk;
			add(yy,kk);
			add(zz+1,-kk);
		} 
		else{
			cin>>yy;
			cout<<cx(yy)<<endl;
		} 
	}
	return 0;
}

```
写了非常久，甚至丧心病狂的把所有数字和字母都加了LATEX

我疯了，管理员过吧

---

## 作者：Purple_wzy (赞：5)

	   看到所有人的做法无非就是线段树或者树状数组+差分，
	本蒟蒻就“大材小用”一波——
# cdq分治
## 	1.基本思想
	我们依然是将一个大区间[l,r]划分为2个小区间[l,mid]
    和[mid+1,r]。对于一般的分治，两个子区间是完全的两
    个子问题，没有任何瓜葛（本蒟蒻2018NOIPD1T1打了100
    多行的分治），cdq分治的特别之处就是，一个区间会对
    另一个区间产生影响。
##  2.经典应用
	诸如求逆序对，二维偏序，三维甚至n维偏序都能用到cdq
    分治。在此就不多加赘述了。
###     ps:如果只是想快速A掉此题，请看下一篇题解。
# P3368
##  树状数组区间修改，单点查询
	我们考虑把这个问题转化成一个二维偏序问题。用一个结
    构体来保存每次操作。结构体里有3个变量：sit(状态）,
    posi(位置坐标),w(权值)。当sit=1时，w存的是本次加上
    的数W；sit=2时，w存的是本次查询的编号，即0，1，2,
    ......
    我们采用归并排序的思想，先搞定两个子区间的问题，再
    和起来解决当前区间的问题。这样操作的好处就是两个子
    区间已经完全有序。这样，因为左区间的操作时间都比右
    边要早，我们就可以利用
####     左边的修改来完成右边的询问。
    还有一点，就是我们求出来的值是前缀和形式的，所以要
    用一下——
###     差分
## 	看代码
	```cpp
	#include<bits/stdc++.h>
	using namespace std;
	#define re register int
	#define F(x,y,z) for(re x=y;x<=z;x++)
	#define FOR(x,y,z) for(re x=y;x>=z;x--)
	#define I inline void
	#define IN inline int
	typedef long long ll;
	I read(int &res)
	{
    	re g=1;register char ch=getchar();res=0;
    	while(!isdigit(ch))
    	{
        if(ch=='-')g=-1;
        ch=getchar();
   		 }
    	while(isdigit(ch))
    	{
        res=(res<<3)+(res<<1)+(ch^48);
        ch=getchar();
    	}
    	res*=g;
	}
	int n,m,tot=0,cnt=0,a[600000],S,X,Y,W,ans[500000];
	struct Q
	{
		int sit,posi,w;
		friend bool operator < (Q x,Q y)
		{
		return x.posi==y.posi?x.sit<y.sit:x.posi<y.posi;	
		}
		friend bool operator <= (Q x,Q y)
		{
		return x.posi==y.posi?x.sit<=y.sit:x.posi<=y.posi;
        //按位置大小排序
        //若位置相等，先修改后查询
		}
	}q[2200000],incur[2200000];
	I cdq_divide(int x,int y)
	{
		if(x>=y)return;
		re mid=(x+y)>>1,l,r,sum=0,pos=x;
		cdq_divide(x,mid);
		cdq_divide(mid+1,y);//分治解决两个子问题
        //这样过后，两个子区间的posi都是单增的
		l=x;r=mid+1;
		while(l<=mid&&r<=y)
		{
			if(q[l]<=q[r])
			{
			if(q[l].sit==1)sum+=q[l].w;
            //记录下当前的修改值
			incur[pos++]=q[l++];
			}
			else
			{
			if(q[r].sit==2)ans[q[r].w]+=sum;
            //更新本次查询的答案
			incur[pos++]=q[r++];
            //incur是一个暂存数组，用来排序
			}	
		}
		while(l<=mid)
		{
			incur[pos++]=q[l++];
		}
		while(r<=y)
		{
			if(q[r].sit==2)ans[q[r].w]+=sum;
			incur[pos++]=q[r++];	
		}//处理完剩余的问题
		F(k,x,y)
		{
			q[k]=incur[k];	
		}//将排好序的incur传回到q中
	}
	int main()
	{
	scanf("%d %d",&n,&m);
	memset(ans,0,sizeof(ans));
	a[0]=0;
	F(i,1,n)
	{
	scanf("%d",&a[i]);
	q[tot].sit=1;
	q[tot].posi=i;
	q[tot].w=a[i]-a[i-1];
	++tot;
    //将初始权值也视为一次修改，记得要做一下差分
	}
     while(m--)
	{
		scanf("%d",&S);
		if(S==1)
		{
		scanf("%d %d %d",&X,&Y,&W);
		q[tot].sit=1;
		q[tot].posi=X;
		q[tot].w=W;tot++;
		q[tot].sit=1;
		q[tot].posi=Y+1;
		q[tot].w=W*(-1);
		++tot;	
        //差分思想，不懂的自己查
		}
		else
		{
		scanf("%d",&X);
		q[tot].sit=2;
		q[tot].posi=X;
		q[tot].w=cnt;cnt++;
		++tot;	
		}
	}
	cdq_divide(0,tot);
	F(i,0,cnt-1)
	{
	printf("%d\n",ans[i]);
	}
    return 0;
}
```
这样我们就解决了这个问题。    

顺带提一下树状数组1。
其实和这道题大同小异，只不过就是把修改改成普通的
单点修改，区间查询就转化成求r的前缀和减去l-1的前
缀和了。第一次发题解，有哪写得不好还请多多指教。。

 


---

## 作者：ZJYelizaveta (赞：5)

### 描述

用树状数组来维护大小为序列 $n$，要求支持区间修改，单点查询。

$n \leq 500000, m \leq 500000$

### 分析

树状数组的本职是支持单点修改，区间查询的。这样把操作反过来以后应该怎样才能继续用树状数组来维护呢？


这里应用 `差分` 的思想。


比如原来树状数组的每一个叶子结点都是 $a[i]$，那么现在存放的就是 $c[i] = a[i] - a[i - 1]$。


$a[i] = c[i] + c[i - 1] + c[i - 2] + \cdots + c[2] +c[1]$，因此若要单点查询，那么直接查询前缀和即可。


至于区间修改很容易理解，就是 $modify[l, +k], modify[r + 1， -k]$，至于为什么自己在树状数组上画一下就可以了。


另，这里也提一下在要支持区间修改，区间查询的时候怎么办？

一样用树状数组来维护一个差分数组，区间修改同上。

$$\because a[i] = \sum_{j = 1}^{i}c[j] $$

$$\therefore \sum_{i = 1}^{n}a[i] = \sum_{i = 1}^{n}\sum_{j = 1}^{i}c[j] = \sum_{i = 1}^{n}(n - i + 1)c[i] = (n + 1)\sum_{i = 1}^{n}c[i] - \sum_{i = 1}^{n}c[i] \times i$$

开两个树状数组来维护这两项即可。


时间复杂度 $\Theta(nlogn)$

### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
template<typename T> T readIn() {
    T x(0), f(1);
    char ch = getchar();
    while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}
const int MAX_N = 500000 + 3;
const int MAX_M = 500000 + 3;
const int INF = 0x3f3f3f3f;
int n, m;
int a[MAX_N];

namespace fenwickTree {
    int vec[MAX_N];

    inline void init() {
        memset(vec, 0, sizeof vec);
    }

    inline int lowbit(int x) {
        return x & (-x);
    }

    inline void modify(int id, int x) {
        while (id <= n) {
            vec[id] += x;
            id += lowbit(id);
        }
    }

    inline int query(int id) {
        int res = 0;
        while (id >= 1) {
            res += vec[id];
            id -= lowbit(id);
        }
        return res;
    }
}
using namespace fenwickTree;

int main()
{
    n = readIn<int>(), m = readIn<int>();
    for (int i = 1; i <= n; ++i) a[i] = readIn<int>();

    init(); int last = 0;
    for (int i = 1; i <= n; ++i) {
        modify(i, a[i] - last);
        last = a[i];
    }

    while (m--) {
        int opt = readIn<int>();
        if (opt == 1) {
            int l = readIn<int>(), r = readIn<int>(), k = readIn<int>();
            modify(l, k); modify(r + 1, -k);
        }
        else {
            int pos = readIn<int>();
            int ans = query(pos);
            printf("%d\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：_LHF_ (赞：4)

# 树状数组
其实是一个很好的东西，码量少，常数小……

当然，树状数组的题目也可以用线段树来做，不过，还是介绍一下树状数组吧。

这就是树状数组的基本模式：
```cpp
s1=a1
s2=a1+a2
s3=a3
s4=a1+a2+a3+a4
s5=a5
s6=a5+a6
s7=a7
s8=a1+a2+a3+a4+a5+a6+a7+a8
s9=a9
...
```
规律大家应该都知道了吧。

所以，有一个函数——lowbit就是来实现这一个规律的。
```cpp
int lowbit(x) {return x&(-x);}
```
原理大家应该都懂得吧。

树状数组最大的优点就是码量少，比如说像单点修改：
```cpp
将第x个节点的数值增加a
int add(int x,int a)
{
	while(x<=n)
	{
		s[x]+=a;
		x+=lowbit(x);
	}
}
```
区间查询：
```cpp
查询1~x的和
int sum(int x)
{
	int ans=0;
	while(x)
	{
		ans+=s[x];
		x-=lowbit(x);
	}
	return ans;
}
```
好了，就这个样。
---
但是，此处需要支持区间修改，怎么办呢？

先了解一下差分。

现在有一个序列，为{1 5 4 2 3}

则它的差分数组为后一项减去前一项（第一项减去0）。

之后呢？我们就得到一个差分数组{1 4 -1 -2 1}

如果将2~4区间加上2，则原数组就是{1 7 6 4 3}

它的差分数组是{1 6 -1 -2 -1}

发现了什么？它的差分数组的第2项增加了2，第4+1项增加了-2。

所以，我们可以维护差分数组，这样子就可以解决区间修改/单点查询的问题了。

代码如下：
```cpp
#include<cstdio>
#define N 5000010
using namespace std;
int lowbit(int a){return a&(-a);}
int tr[N],a,n,T,t,b,last;
void add(int x,int a)
{
	while(x<=n)
	{
		tr[x]+=a;
		x+=lowbit(x);
	}
}
int getsum(int x)
{
	int ans=0;
	while(x)
	{
		ans+=tr[x];
		x-=lowbit(x);
	}
	return ans;
}
int main()
{
	scanf("%d%d",&n,&T);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		add(i,a-last);
		last=a;
	}
	while(T--)
	{
		scanf("%d%d",&t,&a);
		if(t==1)
		{
			scanf("%d%d",&b,&t);
			add(a,t);
			add(b+1,-t);
		}
		else printf("%d\n",getsum(a));
	}
}
```
# 扩展一下
如果题目同时需要区间修改和区间查询怎么办？

其实也容易，多维护一个数组就可以了。

代码如下：
```
#include<cstdio>
#define N 1000010
using namespace std;
int lowbit(int x) {return x&(-x);}
int n,s1[N],s2[N],T,a,b; 
更改差分数组
void add(int x,int a)
{
	for(int i=x;i<=n;i+=lowbit(i))
	{
		s1[i]+=a;
		s2[i]+=a*(x-1);
	}
}
查询1~x的和
int sum(int x)
{
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i))
	{
		ans+=s1[i]*x-s2[i];
	}
	return ans;
}
int l,r,ActionEvent;
int main()
{
	scanf("%d%d",&n,&T);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		add(i,a-b);
		b=a;
	}
	while(T--)
	{
		scanf("%d",&ActionEvent);
		if(ActionEvent==1)
		{
			scanf("%d%d%d",&l,&r,&a);
			add(l,a),add(r+1,-a);
		}
		else
		{
			scanf("%d",&b);
			printf("%d\n",sum(b)-sum(b-1));
		}
	}
}
```

---

## 作者：lzxy (赞：4)

# 咳咳：
### 首先：这是一道模板题
#### 对于每一个OIer来说都是必须掌握的
这道题还可以用~~线段树来做~~这里就只讲树状数组
首先我们定义一个数组，表示原序列相邻两个的差，
即：
# b[i]=a[i]-a[i-1];
很容易就注意到a[i]=b[i]+b[i-1]+……b[1]  
刚好是一个求和的过程
对于一个区间l~r来讲，维护差分和只需维护b[l]和b[r+1]即：两端便可以了，因为中间的每一个数都加上一个相同的数，差分不变，就像：
#### a-b==(a+d）-（b+d);
用一个树状数组维护差分和即可


------------


------------
## 这里还有必要提一下线段树和树状数组的区别：
## 线段树：
代码较长，偏复杂，但可以解决的问题比树状数组广，几乎树状数组能做的线段树都能做，有什么权值线段树，平衡树套线段树，二维线段树等。
## 树状数组：
代码复杂程度低，运行速度略快线段树，写起来很方便。（~~本人超级喜欢~~）


------------
最后附上代码：
```cpp
#include<bits/stdc++.h>
#define N 501000
using namespace std;
int n,m,a,b,c[N];//c数组为差分数组 
int lowbit(int x){return x&(-x);} 
void add(int x,int w)//把差分数添加进树状数组 
{
	for(int i=x;i<=n;i+=lowbit(i))	c[i]+=w;
}
int sum(int x)//求树状数组的差分和 
{
	int ans=0;
	for(int i=x;i;i-=lowbit(i))	ans+=c[i];
	return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		add(i,a-b);//a-b即为差分 
		b=a;//转移 
	}
	for(int i=1;i<=m;i++)
	{
		int t,x,y,k;
		scanf("%d",&t);
		if(t==1)
		{
			scanf("%d%d%d",&x,&y,&k);
			add(x,k);//维护左边 
			add(y+1,-k);//维护右边 
		}
		else
		{
			scanf("%d",&x);
			printf("%d\n",sum(x));//直接输出差分和即可 
		}
	}
	return 0;
}
```


---

## 作者：rentenglong (赞：4)

#用树状数组&线段树的思想解决这个问题


##前言

惊了，看到下面的dalao们各种线段树线段树，直接惊啦。。。这明明是树状数组的题。。。杀鸡焉用牛刀。。。

但是这个和书上提供的树状数组支持的操作并不一样。因此这个题只是使用树状数组的思想和结构。

本质上讲不是树状数组，但是结构上将是树状数组。


##说说思路

首先来讲定义e[MAXN]作为树状数组的存储空间。n表示元素个数，m表示指令数。

a[MAXN]用来存储初始数据。

在树状数组中，树的节点用来存储它管辖的区间（比如说8号掌管了a[1]...a[8]，即e[4]、e[6]、e[7]、a[8]，如下图）

 ![](https://cdn.luogu.com.cn/upload/pic/4310.png) 

然后加的时候，只需要将组成这个区间的几个大管辖节点加这个数（类似于线段树中的懒操作）。

查询的时候，依层找自己的上级，然后加上自己上级的值就行了。因为在这里，上级的值就相当于懒操作的值。


##代码贴贴贴

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

#define MAXN 500005

int lb(int k)
{
    return k&(-k);
}//lowbit 

int e[MAXN];
int a[MAXN],n,m;

void addto(int x,int v)
{
    while(x>0)
    {
        e[x]+=v;
        x-=lb(x);
    }
}//实现1-x区间加v 

int query(int x)
{
    int ans=a[x];
    while(x<=n)
    {
        ans+=e[x];
        x+=lb(x);
    }
    return ans;
} 

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=m;i++)
    {
        int operate;
        scanf("%d",&operate);
        if(operate==1)
        {
            int a,b,v;
            scanf("%d%d%d",&a,&b,&v);
            addto(b,v);
            addto(a-1,-v);
        }
        else
        {
            int x;
            scanf("%d",&x);
            cout<<query(x)<<endl;
        }
    }
    return 0;
}

```

---

## 作者：L_Y_T (赞：4)

#### 既然是个区间问题,为什么我们不用神奇的分块来跑过去呢?

~~这里假设泥萌都会分快了~~

因为我写的分块的常数是在是太大了,所以说我不得不强行吸氧

所以,我就来放个code

```
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <math.h>
#define maxn 500010
using namespace std ;
int n , m ;
int blo , bl[maxn] ;
int a[maxn] ;
int tag[maxn] ;
int read() {//加一个不必要的快读
    long long x = 0 ;
    int f = 1 ; x = 0 ; char s = getchar() ;
    while(s>'9'||s<'0') {if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0') {x=x*10+(s-'0');s=getchar();}
    return x*f ;
}
void change(int x , int y , int c) {//区间加
    for(int i = x ; i <= min(y,bl[x]*blo); i ++) {//暴力加左边部分
        a[i] += c;
    } 
    if(bl[x] != bl[y]) {//处理中间的完整块
        for(int i = (bl[y]-1)*blo+1;i<=y;i ++) 
        a[i] += c ;
    }
    for(int i = bl[x]+1;i<bl[y];i++)//处理右边的部分块
    tag[i] += c ;
}
int query(int x) {
    return a[x]+tag[bl[x]] ;//不解释
}
signed main() {
    n = read() ;m = read() ;
    blo = sqrt(n) ;//据说这样分块会比较快
    for(int i = 1 ; i <= n ; i ++) {
        bl[i] = (i-1)/blo+1 ;
    }
    for(int i = 1 ; i <= n ; i ++) {
        a[i] = read() ;
    }
    for(int i = 1 ; i <= m ; i ++) {
        int opt , x , y , z ;
        opt = read() ;
        if(opt==1) {
        	x = read() ;
        	y = read() ;
        	z = read() ;
            change(x,y,z) ;
        }
        else
        if(opt == 2){
        	x = read() ;
        	cout << query(x) <<endl ;
    	}
	}
    return 0;
}
```

最后,我来附一个树状数组的裸题

[裸题](https://www.luogu.org/problemnew/show/U43260)



---

## 作者：yzhang (赞：3)

不用说，还是线段树大法好，这是线段树模板，区间修改，区间查询（单点可以扩展成长度为1的区间），上代码，详解在神奇的线段树中。~~（位运算勿喷）~~


------------

```cpp
// luogu-judger-enable-o2  吸氧是个好东西
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[500005];
int sum[4000005];
int tag[4000005];
inline void pushup(int x)
{
    sum[x]=sum[x<<1]+sum[(x<<1)+1];
}
void build(int x,int l,int r) //建树
{
    if(l==r)
    {
        sum[x]=a[l];
        return;
    }
    int m=(l+r)>>1;
    build(x<<1,l,m);
    build((x<<1)+1,m+1,r);
    pushup(x);
    return;
}
void pushdown(int x,int l,int r) //lazy_tag
{
    if(tag[x])
    {
        int m=(l+r)>>1;
        int ls=x<<1;
        int rs=ls+1;
        tag[ls]+=tag[x];
        tag[rs]+=tag[x];
        sum[ls]+=tag[x]*(m-l+1);
        sum[rs]+=tag[x]*(r-m);
        tag[x]=0;
    }
    return;
}
void update(int x,int l,int r,int L,int R,int k) //区间修改
{
    if(R<l||r<L)
        return;
    if(L<=l&&r<=R)
    {
        tag[x]+=k;
        sum[x]+=k*(r-l+1);
        return;
    }
    pushdown(x,l,r);
    int m=(l+r)>>1;
    update(x<<1,l,m,L,R,k);
    update((x<<1)+1,m+1,r,L,R,k);
    pushup(x);
    return;
}
int query(int x,int l,int r,int L,int R) //查询
{
    pushdown(x,l,r);
    if(R<l||r<L)
        return 0;
    if(L<=l&&r<=R)
        return sum[x];
    int m=(l+r)>>1;
    int ans=query(x<<1,l,m,L,R)+query((x<<1)+1,m+1,r,L,R);
    return ans;
}
int main()
{
    ios::sync_with_stdio(0); //一点小优化
    cin>>n>>m; //读入
    for(int i=1;i<=n;++i)
        cin>>a[i];
    build(1,1,n); //建树
    int cnt;
    while(m--)
    {
        cin>>cnt;
        if(cnt==1) //区间修改
        {
            int x,y,k;
            cin>>x>>y>>k;
            update(1,1,n,x,y,k);
        }
        else //区间查询（单点查询）
        {
            int x;
            cin>>x;
            int ans=query(1,1,n,x,x); //x,x表示一个长度为1的区间
            cout<<ans<<endl;
        }
    }
    return 0;
}
```


------------
码风很丑，勿喷。

---

## 作者：2015wanghongyu (赞：3)

看到题解里冷冷清清的，我就走一波树状数组的清流好了。。。

其实树状数组的优点还是很多的，长度也短，复杂度也低，代码还优美易写等。

对于已经能A掉树状数组1的同学们，2就变得相当好理解了。下面是题解。

###分析

1. 这里由于涉及到区间修改，所以我们要引入差分的思想。

2. 差分数组c[]：我们假设sigma(c，i)表示c数组的前i项和，调用一次的复杂度是log2(i)

设原数组是a[n]，**\_差分数组c[n]，c[i]=a[i]-a[i-1]，那么明显地a[i]=sigma(c,i)\_**，如果想要修改a[i]到a[j](比如+v)，只需令c[i]+=v,c[j+1]-=v

3. 明白了上面的原理以后，就可以直接看代码了QUQ

注意：区间修改维护的是一个差分数组，而单点修改维护的是一个前缀和数组。

```cpp
#include<iostream>
#include<cstdio>
#define maxn 500000+5
using namespace std;
int m,n,k,a[maxn],c[maxn];
int lowbit(int x) {return x&(-x);}//lowbit函数就不用多说了
void add(int x,int val)//添加操作，和之前一样
{
    for(int i=x;i<=n;i+=lowbit(i)) c[i]+=val;
}
int getsum(int x)//sigma操作，和之前一样
{
    int ans=0;
    for(int i=x;i>=1;i-=lowbit(i)) ans+=c[i];
    return ans;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i) {cin>>a[i];add(i,a[i]-a[i-1]);}//注意add（）的是a[]数组的差分
    for(int i=1,l,r,v,x;i<=m;++i)
    {
        cin>>k;
        if(k==1) {cin>>l>>r>>v;add(l,v);add(r+1,-v);}//区间修改
        else {cin>>x;cout<<getsum(x)<<endl;}//单点查询，至于什么看上去像是在求和，分析2里解释了
    }
    return 0;
}
```

---

## 作者：king_xbz (赞：1)

先上两道模板题蓝链[P3374树状数组1](https://www.luogu.com.cn/problem/P3374)  [P3368树状数组2](https://www.luogu.com.cn/problem/P3368)

接下来讲解开始

1.什么是树状数组

树状数组就是一个简单版的线段树，可以用数组的形式模拟树，可以完成一些简单的功能，如区间求和，建树等；

2.怎么表示树状数组

定义一个数组tree[]即可

3.什么是lowbit

```cpp
inline int lowbit(int x)
{
	return x&(-x);
}
```
x&-x的意思就是当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。我们可以通过lowbit来求出2^k；

4.如何往树状数组中加数
```cpp
void adds(int x,int y)
{
	for(int i=x;i<=n;i+=lowbit(i))
	tree[i]+=y;	
}
```
代码即为将第x数加上y

5.如何往区间里加数

我们知道在树状数组中可以用前i项的和来表示第i个数.即为前缀和思想
那么我们可以通过add(a,c),add(b+1,-c)来往[a，b]中每一个元素加上c
code:
```cpp
c=read();
			d=read();
			e=read();
			adds(c,e);
			adds(d+1,-e);
```
6.如何初始化区间

比如我们输入第i个数为a
我们将i和a添加到树状数组中
即为
```cpp
for(int i=1;i<=n;i++)
	{
	cin>>a[i];
	addup(i,a[i]);
}
```

7.如何求区间内每个数的和
```cpp
inline int tot(int x)
{
	int t=0;
	for(fint i=x;i;i-=lowbit(i))
	t+=tree[i];
	return t;
}
```
然后
```cpp
tot(c)-tot(b-1)；
```
即为区间[b,c]的和

内容差不多就这样了

接下来放代码

树状数组1：
```cpp
#include<bits/stdc++.h>
#define int long long
#define h 57823
#define p 2001
using namespace std;
int lb(int x);
void addup(int x,int y);
int tot(int x);
int f[h]; 
int tree[h];
int n,m;
int a[h];
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
	cin>>a[i];
	addup(i,a[i]);
}
    int d,b,c;
    for(int i=1;i<=m;i++)
    {
    cin>>d>>b>>c;
    if(d==1)
    addup(b,c);
    else
    if(d==2)
    cout<<tot(c)-tot(b-1)<<endl;
} 
}
int lowbit(int x)
{
	return x&(-x);
}
void addup(int x,int y)
{
	for(int i=x;i<=n;i+=lowbit(i))
	tree[i]+=y;	
}
int tot(int x)
{
	int t=0;
	for(int i=x;i;i-=lowbit(i))
	t+=tree[i];
	return t;
}
```
树状数组2
```cpp
#include<bits/stdc++.h>
#define int long long
#define fint register long long
#define p 536234
#define h 5001
using namespace std;
int tree[p];
int n,m;
int a[p];
inline int read();
inline void adds(int x,int y);
inline int lowbit(int x);
inline int tot(int x);
signed main()
{
	n=read();
	m=read();
	for(fint i=1;i<=n;i++)
	{
		a[i]=read();
		adds(i,a[i]-a[i-1]);
	}
	int num; 
    int c,d,e;
	for(int i=1;i<=m;i++)
	{
		num=read();
		if(num==1)
		{
			c=read();
			d=read();
			e=read();
			adds(c,e);
			adds(d+1,-e);
		}
		else
		if(num==2)
		{
			c=read();
			cout<<tot(c)<<endl;
		}
	}
	exit(0);
}
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
inline void adds(int x,int y)
{
	for(fint i=x;i<=n;i+=lowbit(i))
	tree[i]+=y;
}
inline int lowbit(int x)
{
	return x&(-x);
}
inline int tot(int x)
{
	int t=0;
	for(fint i=x;i;i-=lowbit(i))
	t+=tree[i];
	return t;
}
```
完结撒花！

---

## 作者：lsm123 (赞：1)

菜鸡冒泡~~ 有锅请各位dalao指出

~~
~~first of all~~

先交代故事发生的背景.........

```cpp
/*
关于lowbit的函数介绍（so easy）
lowbit是找最后一位是一的位数 
●在计算机中，负数的存储为（以八进制为例，-10 就是10001010※第一位是符号位
对于正数来说，原码，反码，补码都是同一个，对于负数来说，反码就是除去符号位以外，其余的取反
补码是反码最后加一，（加爆了也不用管，加就是了））
●按位&  例如1&1=1，是两边同时满足才可以 
●一个数和他的相反数用&，则可以求出最后一位是1的位置（就是lowbit的代码实现）（※但要注意的是如果一个数是2的k次方，那么这个数的lowbit还是这个数，手动实现验证）
★关于树状数组，一般是给某一个数加上一个值，还有就是询问某个区间的和，
给某一个数加上一个值，要求更新和这个数有关的所有数，用树状数组可以节省时间大约是O(nlogn)
每次都要update，用c数组去存a数组的值，类似于一个树开始的时候直接加一个值就可以，之后的每次增加某一个数的值要求是每次都要update
而从一个点找到下一个应该被更新的点用的就是lowbit（x）+x； 
 树状数组中c数组的所代表的数字取决于lowbit的值
 例如说lowbit 1=1那么c1就是一个数的和  lowbit 2=2那么c2就是两个数的和，lowbit3=1那么c1就是一个数的和。。。。。。 
*/
#include<iostream>
#include<cstdio>
#include<stdio.h>
using namespace std;
int n,m;int c[5000005];
int lowbit(int ii)
{
	return ii&(-ii);
}
void update(int x,int k)
{
	while(x<=n)
	{
		c[x]+=k;
		x=x+lowbit(x);
	}
}
int getsum(int x)
{
	int sum=0;
	while(x!=0)
	{
		sum+=c[x];
		x=x-lowbit(x);
	}
	return sum;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a;
		update(i,a);	
	}
	for(int i=1;i<=m;i++)
	{
		int p,x,y;
		cin>>p>>x>>y;
		if(p==1)
		{
			update(x,y);
		} 
		if(p==2)
		{
			int ckwnb=getsum(y)-getsum(x-1);
			cout<<ckwnb<<endl;
			
		}
	}	
} 

```
~~~膜以下ckw（&&ccs技术支持）


应用如下

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<stdio.h>
using namespace std;
long long int n;long long int c[500015]={0};
struct strr{
  long long int id,wei;
}map[500005];
long long int  com(strr x,strr y)
{
	if(x.wei!=y.wei)
	return x.wei>y.wei;
	if(x.wei==y.wei)
	return x.id>y.id;
}
long long int lowbit(int l)
{
	return l&(-l);
}
void update(int x)
{
	while(x<=n)
	{
		c[x]++;
		x=x+lowbit(x);
	}	
}
long long int getsum(int x)
{
	long long int sum=0;
	while(x>0)
	{
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
int main()
{
	long long int ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>map[i].wei;
		map[i].id=i;
	}
	sort(map+1,map+n+1,com);
	for(int i=1;i<=n;i++)
	{
		update(map[i].id);
		ans+=getsum(map[i].id-1);
	}
	cout<<ans;
	return 0;
}  
/*make an summary
将一个数的id和这个数的值联系到一起，对值进行排序，但是 实际用到的还是这个数的地址
用树状数组对id排玩顺序以后的数组当做原来的c数组
这是要记得用一个ans变量来记录目前已经有多少是符合要求的了，不断的运用加法即可，
比如说一开始的原数组为5 4 2 6 3 1，按着从大到小拍完顺序以后，可以得到以下的id顺序为4 1 2 5 3 6
此时，把新得到的id作为c数组，不断的加（◆原理和简单）
{
¤第一个数为4
先放进去4 ，这是4是最大的，（要知道，现在加进去的数的id如果很大，（比已经加进去的还要打，就说明这的数的id大但是数目小，这时候看看传输组中
已经加进去的，如果id比这个小但是已经放进去了，就只能说明已经放进去的数比这个id大的数数值大，就符合逆序对的要求，这样就比较明显了
只要在每放一个数的时候，找出id比当前值小的就ok了），于是有了以上代码，◎◎◎◎◎◎◎◎）
last but not least
求逆序对数目的时候要用到树状数组（这些都是小事，but 还挺好用的） 
} */
 










---

## 作者：usercjh123 (赞：1)

这里介绍三种（实际上是两种）方法。

## ~~（科学）~~暴力法

虽然是暴力，但是这个暴力可以得到$70pts$（[评测记录](https://www.luogu.org/record/23109798)）的好成绩。

思想很简单，如果是1操作，就将操作区间保存。

如果是2操作，就遍历保存过的所有区间，判断要查询的数是否在区间内部就可以了。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long LL;

const LL maxn = 5e5 + 10;

LL n, m;
LL A[maxn];
LL L[maxn], R[maxn], K[maxn];
LL add_cnt = 0;

inline LL fast_read(){
	LL f = 1, x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x * 10) + (ch - '0');
		ch = getchar();
	}
	return f * x;
}

int main(){
	LL o, x, y, k;
	n = fast_read(); m = fast_read();
	for(register LL i = 1 ; i <= n ; i++) A[i] = fast_read();
	for(register LL i = 1 ; i <= m ; i++){
		o = fast_read();
		if(o == 1){
			x = fast_read(); y = fast_read(); k = fast_read();
			L[add_cnt] = x; R[add_cnt] = y; K[add_cnt] = k;
			add_cnt += 1;
		}
		if(o == 2){
			x = fast_read();
			LL res = A[x];
			for(LL j = 0 ; j < add_cnt ; j++){
				if(L[j] <= x && R[j] >= x) res += K[j];
			}
			cout << res << endl;
		}
	}
}
```

## 树状数组的两种理解（编程）方式
第一种方式非常好理解。

考虑下面这个情况，我用括号表示当前修改过的区间，$*$表示要查询的位置

$\{\quad[\quad (\quad\; )\quad*\;]\quad\}$

想象你从最左边向$*$的位置走去，如果撞到了左括号，那么就说明你进入了一个修改过的区间，如果撞到了右括号，那么说明你从某个区间出去了。

比如上面的情况，你先撞见了$\{$，就进入了$\{\;\}$区间的范围，又撞见了$[$，就进入$[\;]$区间的范围，接着你撞见了$($，但是你又撞见了$)$，于是你就走出了$(\;)$区间的范围。再往前走就到了$*$。

总计一下，你一共进入了两个区间$\{\}$与$[]$，所以说$*$的值一定是原来的值再加上这两个区间的修改。

我们整理一下，就可以得出以下算法：

起初，$B$数组（以$1$开始）的值全部为$0$。

对于每一次修改$(x, y, k)$，将$B[x]$的值增加$k$,$B[y+1]$（为什么是$y+1$在下面说明）的值减少$k$。

对于每一次查询$x$，计算$B[1]$值$B[x]$的和（若$x$正好在某个区间的右端，那么它还是在这个区间内的，所以要将$B[y+1]$而不是$B[y]$减少$k$）

这就是树状数组的标准操作（单点修改&区间查询），将模板题1的代码略微改动一下就可以$AC$。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long LL;

const LL maxn = 5e5 + 100;
LL C[maxn], A[maxn];
LL n, m;

inline LL fast_read(){
	LL f = 1, x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + (ch - '0');
		ch = getchar();
	}
	return f * x;
}

inline LL lowbit(LL x){
	return x & (-x);
}

LL prefix_sum(LL x){
	if(x == 0) return 0;
	LL res = 0;
	while(x > 0){
		res += C[x];
		x -= lowbit(x);
	}
	return res;
}

void add(LL x, LL k){
	while(x <= n){
		C[x] += k;
		x += lowbit(x);
	}
}

int main(){
	cin >> n >> m;
	LL o, x, y, k;
	memset(C, 0, sizeof(C));
	for(register LL i = 1 ; i <= n ; i++) A[i] = fast_read();
	for(register LL i = 1 ; i <= m ; i++){
		o = fast_read();
		if(o == 1){
			x = fast_read(); y = fast_read(); k = fast_read();
			add(x, k); add(y + 1, -k);
		}
		if(o == 2){
			x = fast_read();
			cout << A[x] + prefix_sum(x) << endl;
		}
	}
}
```

第二种方法不太容易理解。

我们发现，树状数组支持单点修改&区间查询。但是这道题需要区间修改&单点查询。

我们不妨将区间查询的代码改动一下，变为区间修改的代码。

```
void prefix_add(LL x, LL k){
	if(x == 0) return;
	while(x > 0){
		C[x] += k;
		x -= lowbit(x);
	}
}
```

同样，将单点修改的代码修改一下，变为单点查询的代码。

```
LL get(LL x){
	LL res = 0;
	while(x <= n){
		res += C[x];
		x += lowbit(x);
	}
	return res;
}
```

进而得来了下面的代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long LL;

const LL maxn = 5e5 + 100;
LL C[maxn], A[maxn];
LL n, m;

inline LL fast_read(){
	LL f = 1, x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + (ch - '0');
		ch = getchar();
	}
	return f * x;
}

inline LL lowbit(LL x){
	return x & (-x);
}

void prefix_add(LL x, LL k){
	if(x == 0) return;
	while(x > 0){
		C[x] += k;
		x -= lowbit(x);
	}
}

LL get(LL x){
	LL res = 0;
	while(x <= n){
		res += C[x];
		x += lowbit(x);
	}
	return res;
}

int main(){
	cin >> n >> m;
	LL o, x, y, k;
	memset(C, 0, sizeof(C));
	for(register LL i = 1 ; i <= n ; i++){
		A[i] = fast_read();
	}
	for(register LL i = 1 ; i <= m ; i++){
		o = fast_read();
		if(o == 1){
			x = fast_read(); y = fast_read(); k = fast_read();
			prefix_add(y, k); prefix_add(x - 1, -k);
		}
		if(o == 2){
			x = fast_read();
			cout << A[x] + get(x) << endl;
		}
	}
}
```

大体思路就是在区间修改时，将$[1, y]$区间加$k$，$[1, x-1$区间减$k$。

---

## 作者：塔罗兰 (赞：1)

前置知识:[P3374 【模板】树状数组 1](https://www.luogu.org/problemnew/show/P3374)

如果你没有学过,点击[这里](https://www.luogu.org/blog/rezerotime/solution-p3374)

这题的修改操作与查询操作正好与P3374【模板】树状数组1相反,那我们应该怎么去写呢？

差分！

差分,就是记录后一个数的值减去前一个数。

那么问题来了:差分有什么用呢？

巨佬们:这题解居然还能提出这么ZZ的问题,作者想必蒻到爆炸,也没什么好看的,散了散了

诶,别走啊,让我们来看一看差分在这题中的妙处

差分后,每次修改区间只需要修改差分数组中区间左端和右端右边一个元素的值就够了,时间复杂度O(1)

至于查询,就是被查询的元素与其之前的差分数组之和,时间复杂度O(x)

由于我们知道出题人肯定会毒瘤地出很多很多查询操作卡暴力,所以我们用树状数组来储存差分数组

这样时间复杂度大大均衡,修改为O(logn),查询为O(logx)

代码:
```cpp
#include<bits/stdc++.h>
#define MAX 500005
using namespace std;
int n,m,tree[MAX];
inline void add(int k,int num)
{
    while(k<=n)
    {
        tree[k]+=num;
        k+=k&-k;
    }
}//修改
inline int sum(int k)
{
   int sum(0);
   while(k)
   {
	sum+=tree[k];
	k-=k&-k;
   }
   return sum;
}//查询
int main()
{
	scanf("%d%d",&n,&m);
	int s(0);
	for(int i(1);i<=n;++i)
	{
		int x;
		scanf("%d",&x);
		add(i,x-s);//初始化
		s=x;//滚动数组记差分
	}
	for(int i(1);i<=m;++i)
	{
		scanf("%d",&s);
		if(s==1)
		{
			int x,y,z;
			scanf("%d%d%d",&x,&y,&z);
			add(x,z),add(y+1,-z);//前一个+z,后一个-z就实现了修改
		}
		else
		{
			int x;
			scanf("%d",&x);
			printf("%d\n",sum(x));
		}
	}
}
```


---

## 作者：AC机 (赞：1)

如题目的标题，我们可以用树状数组，但是呢，其实我发现用分块也可以过这题的。

[评测记录](https://www.luogu.org/recordnew/show/16528023)

虽然三个点比较慢，但是不管提交多少次都不会TLE的。

好的，那么，我们来说一下，什么是分块。分块又叫做优雅的暴力（就是暴力），但是呢，不是纯暴力，而已将暴力的原序列进行分割，变成几个块，一般我们都是分成$\sqrt(n)$个的，这样可以让我们在遇到不完整的块时，纯暴力的次数均摊最少。但是，注意，我们所要分块的序列必须是个静态序列，不是说元素不能变，而是不能将个数进行改变，如果要做动态序列的分快的话，需要借助数据结构，在这里就不说了。（因为我太弱了QAQ不敢班门弄斧）

那么我们来说一下这一题。  
其实这题用不到分块的全部，只需要用到标志的tag数组，即可求值。
$belong_i$表示第i个元素所在的是第几个块，$l_i\ \ r_i$表示第i个块的左边界和右边界。

下面请看程序，附有注释。

如果想学习分块基础，可以看[cn苏卿念的博客](https://www.cnblogs.com/cn-suqingnian/p/9302143.html)  
如果想学习多种分块，可以看[这位爷的博客](http://hzwer.com/8053.html)  
（这不是宣传…………挂的又不是我的博客…………）

PS：分块不止可以过这题，线段树的模板也是可以过得。[评测记录](https://www.luogu.org/recordnew/show/16554702)
```cpp
#include<stdio.h>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
typedef unsigned long long ull;
typedef unsigned long int ul;
typedef long long ll;
char buf[1<<21],*p1=buf,*p2=buf;
inline int getch()
{
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
}
char buf2[1<<21],pr[20];
int p,p3=-1;
inline void flush()
{
    fwrite(buf2,1,p3+1,stdout),p3=-1;
}
inline void print(int x)
{
    if(p3>1<<20) flush();
    do{pr[++p]=x%10+48;}while(x/=10);
    do{buf2[++p3]=pr[p];}while(--p);
    buf2[++p3]='\n';
}
template <class code>inline code read(const code &a)
{
    code x=0;short w=0;char ch=getch();
    while(!isdigit(ch)) {w|=ch=='-';ch=getch();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getch();}
    return w?-x:x;
}
int n;
const int N=500000;
const int M=50000;
int a[N+5];
int tag[M+5];
int belong[N+5];
int l[M+5];
int r[M+5];
int block;//分块的块数，为sqrt(n)
int num;
int m;
int main ()
{
    //freopen("blocking.in","r",stdin);
    //freopen("blocking.out","w",stdout);
    n=read(n),m=read(m);
    block=sqrt(n);
    num=ceil(1.0*n/block);
    for(register int i=1;i<=n;i++)
    {
        a[i]=read(a[i]);
        belong[i]=(i-1)/block+1;
    }
    for(register int i=1;i<=num;i++)
    {
        l[i]=r[i-1]+1;
        r[i]=r[i-1]+block;
    }
    r[num]=n;
    while(m--)
    {
        int f,b;
        f=read(f);
        if(f==1)//最重要的在这里，如何区间修改
        {
            /*我们将要修改的地方分成3部分a,b,c（变量意义与代码中的变量无关）。
            a的部分是左边不完整的块，b的部分是完整的块，c的部分是右边不完整的块，我们只需要单独处理a,c（纯暴力处理）即可*/
            /*单独处理的部分是修改序列，完整的块的话，是修改tag，最后输出是只需输出原序列的数加上tag即可*/
            int q,c;
            q=read(q),b=read(b),c=read(c);
            int left=q,right=b,x=c;
            for(register int i=left;i<=min(right,r[belong[left]]);i++)
            {
                a[i]+=x;
            }
            if(belong[left]!=belong[right])
            {
                for(register int i=l[belong[right]];i<=right;i++)
                {
                    a[i]+=x;
                }
            }
            for(register int i=belong[left]+1;i<=belong[right]-1;i++)
            {
                tag[i]+=x;
            }
        }
        else
        {
            b=read(b);
            print(a[b]+tag[belong[b]]); 
        }
    }
    flush();
    return 0;
}
```


---

## 作者：chongxinzailaile (赞：1)

道题很明显可以用暴力啊，而且数据果然为70%，
也就是说，他让我们干什么，咋们就干什么，这样可以得70分
代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500020];
int n,m;
void jia(){//让你干什么你就干什么，让我们加咋们就加 
	int x,y,z;
	cin>>x>>y>>z;
	for(int i=x;i<=y;i++){
		a[i]+=z;//此处为not AC埋下了伏笔 
	}
}
void shu(){
	int x;
	cin>>x;
	cout<<a[x]<<endl;
} 
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		int o;
		cin>>o; 
		if(o==1){
			jia();
		}else{
			shu();
		}
	}
	return 0;
}

```
喜闻乐见，果然真是70分，看来背不过模板还真能骗到分啊
我去这么好的思路，竟然挂了，仔细一看，发现数据是500000，真是..（其实是故意的）
换一种思路，等等这道题的题目叫树状数组，那我们就用这个模板吧 
貌似和树状数组一的区别是需要差分（积木competition）的思想 
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[500020];
int c[500020];
int n,m;
void jia(int x,int y) {//让你干啥你就干啥..
	for(int i=x;i<=n;i+=i&-i){//模板标准循环 
		c[i]+=y; //y为每次加的数，x为在此上加的数 
	} 	
} //和上一题没啥区别，不过我们需要知道一点东西
/*lowbit(i) 定为二进制最低位的1
大概得到

lowbit(6) = 2     110//为什么？因为1在倒数第二位，2的1次方为2 
lowbit(1024) = 1024  10000000000
lowbit(x) = x & -x
x - lowbit(x) = (x & (x - 1))

a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8]
c[i] = sum(a[i - lowbit(i) + 1 .. i])

c[1] = a[1]
c[2] = a[1] + a[2]
c[3] = a[3]
c[4] = a[1] + a[2] + a[3] + a[4]
c[5] = a[5]
c[6] = a[5] + a[6]
c[7] = a[7]
c[8] = a[1] + a[2] + ... + a[7] + a[8] 
好处在于把上一题n^2优化成nlogn
好了把什么是i&-i解释完了 
*/ 
int shu(int x){//乍一看和上一题一样，其实略有改动
	int re=0;
	for(int i=x;i;i-=i&-i){
		re+=c[i];
	} //和上一块只是倒过来啊 
	return re;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];//读入每一个数字 
	}
	for(int i=1;i<=m;i++){
		int o,x,y,k;
		cin>>o;
		if(o==1){ 
			cin>>x>>y>>k;
			jia(x,k);//每次+k，题目说了 
			jia(y+1,-k);//差分 
		}else{
			int x;
			cin>>x;
			cout<<shu(x)+a[x]<<endl;//差分的思想 
		}
	}
	return 0; 
} 
```
果然AC了
```cpp
//完全可以用线段树的方法，这方法是我最不熟的 
//一下为模板，可背过 
#include <bits/stdc++.h>
using namespace std;
long long n, m;
long long a[10000020];
long long sm[10000020];
long long ad[10000020];
long long read(){
	long long ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}//快读优化 
void build(long long x, long long l, long long r) {
	if (l == r) {
		sm[x] = a[l];
		return;
	}
	long long mid = (l + r) / 2;
	build(x * 2, l, mid);
	build(x * 2 + 1, mid + 1, r);
	sm[x] = sm[x * 2] + sm[x * 2 + 1];
}
void add(long long x, long long l, long long r, long long v) {
	sm[x] += (r - l + 1) * v;
	ad[x] += v;
}
void push(long long x, long long l, long long r) {
	int mid = (l + r) / 2;
	add(x * 2, l, mid, ad[x]);
	add(x * 2 + 1, mid + 1, r, ad[x]);
	ad[x] = 0;
}
void change(long long x, long long l,long long r, long long L, long long R, long long v) {
	if (r < L || R < l) {
		return;
	}
	if (L <= l && r <= R) {
		add(x, l, r, v);
		return;
	}
	push(x, l, r);
	int mid = (l + r) / 2;
	change(x * 2, l, mid, L, R, v);
	change(x * 2 + 1, mid + 1, r, L, R, v);
	sm[x] = sm[x * 2] + sm[x * 2 + 1];
}
long long query(long long x, long long l, long long r, long long L, long long R) {
	if (r < L || R < l) {
		return 0;
	}
	if (L <= l && r <= R) {
		return sm[x];
	}
	push(x, l, r);
	long long mid = (l + r) / 2;
	return query(x * 2, l, mid, L, R) + query(x * 2 + 1, mid + 1, r, L, R);
}
int main() {	
	n=read();
	m=read();
	for (int i = 1; i <= n; i++) {
	a[i]=read();
	}
	build(1, 1, n);
	for (int i = 0; i < m; i++) {
		long long o, x, y,z;
		o=read();
		if (o == 1) {
		x=read();
		y=read();
		z=read();
			change(1, 1, n, x, y, z);
		} else {
		x=read();
			printf("%lld\n", query(1, 1, n, x, x));
		}
	}
	return 0;
}
```



---

## 作者：Edgration (赞：1)

## 分块

貌似题解里面没有**分块**啊...我来发一个吧。

虽然是树状数组模板，用**分块解决**也是一个很好的方法。


简单说一下就是将序列分为$sqrt(n)$块，每一块长度$sqrt(n)$。修改的时候在一个块里面就直接给块打标，不在块里面就暴力修改（不会超过$2 * sqrt(n)$个）。


复杂度$O(n*sqrt(n))$

不开$O2$和开$O2$都是可以$AC$的

没有O2：2000+ms O2:1000+ms

不得不说Luogu的评测机是很快的

## 代码


```cpp
#include <bits/stdc++.h>
#define rep(x, y, z) for(register int x = y; x <= z; x ++) 
inline int read(){
    char ch = getchar(); int u = 0, f = 1;
    while (!isdigit(ch)){ if (ch == '-') f = -1; ch = getchar();}
    while (isdigit(ch)) {u = (u << 3) + (u << 1) + ch - 48; ch = getchar();}
    return u * f;
}
const int maxn = 500500;
int n, m, blo;
int v[maxn], tag[maxn], bl[maxn];
namespace Blo{//分块
    inline void Add(int l, int r, int c){
        rep (i, l, std::min(bl[l] * blo, r))
            v[i] += c;
        if (bl[l] != bl[r])
        rep (i, (bl[r] - 1) * blo + 1, r)
            v[i] += c;
        rep (i, bl[l] + 1, bl[r] - 1)
            tag[i] += c;
    }
    inline int query(int pos){//查询的时候就返回单点+块的标记
        return v[pos] + tag[bl[pos]];
    }
}
int main(){
    n = read(), m = read(); blo = sqrt(n);//块的大小
    for (int i = 1; i <= n; i++) bl[i] = (i - 1)/blo + 1;
    for (int i = 1; i <= n; i++) v[i] = read();
    while (m--){
        int opt = read();
        if (opt == 1) {int l = read(), r = read(), c = read(); Blo::Add(l, r, c);} 
        else {
            int x = read();
            printf("%d\n",Blo::query(x));
        }
    }
    return 0;
}
```

---

## 作者：jiezi (赞：1)

#“改段取点”型，差分最高效（自认为，不喜勿喷）

##十分钟打完差分，虽然第一次交T了一个点，但加完快读后就过了，大佬也可以帮我看看，哪里可以降低时间复杂度

###差分即用另一数组表示a[i],d[i]=a[i]-a[i-1],之后用树状数组c[i]维护；



```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m;
const int maxn=500005;
int a[maxn],d[maxn],c[maxn];
inline void read(int &x){//快读（有许多方式，可百度）
    char c;bool flag=0;//flag判断读入是否为负数
    while((c=getchar())<'0'||c>'9')
      if(c=='-') flag=1;
    x=c-'0';
    while((c=getchar())>='0'&&c<='9') 
      x=x*10+c-'0';
    if(flag) x=-x;
}
inline int lowbit(int x){//c[x]所包含所维护树状数组的大小
    return x&(-x);
}
inline void add(int pos,int x){//pos位置加x，典型单点修改
    while(pos<=n){//不超过范围
        c[pos]+=x;//依次改变树状数组c[]的值
        pos+=lowbit(pos);//跳到下一个被包含的c[];
    }
}
inline int getsum(int pos){//树状数组求和
    int ans=0;
    while(pos>0){
        ans+=c[pos];
        pos-=lowbit(pos);
    }
    return ans;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        d[i]=a[i]-a[i-1];//差分
        add(i,d[i]);//也可以建树状数组，但由于数组初始化为0，修改即新建，只是有些懒，想少打一个函数
    }
//    for(int i=1;i<=n;i++)
//      cout<<a[i]<<" "<<d[i]<<"\n";
    int t1,x,y,ad;
    for(int i=1;i<=m;i++){//操作数
        scanf("%d",&t1);
        if(t1==1){
            scanf("%d%d%d",&x,&y,&ad);
                       //差分核心，表示a[x->y]+ad
            d[x]+=ad;add(x,ad);
            d[y+1]-=ad,add(y+1,-ad);
        }
        else if(t1==2){
            scanf("%d",&x);
            printf("%d\n",getsum(x));求d数组前x项和，即求a数组x点值
        }
    }
    return 0;
}
```

---

## 作者：GadTD (赞：1)

起初这些题解我根本看不懂，后面我恍惚间明白了什么，于是我欢天喜地来做分享。


一开始我不明白

```cpp
for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
          change(i,a[i]-a[i-1]);这一步是什么鬼
    }
```
后来结合
printf("%d\n",getsum(x));这个

我明白了。

这就是个数学数列中由递推公式求通项公式的基本方法

- - - - - - 累加法！！！

a[n]=(a[n]-a[n-1])+(a[n-1]-a[n-2])~~~~+(a[1]-a[0])+a[0]

在全局变量种a【】默认为0；故可忽略

其他查分思想什么楼下大佬说的很清楚

我觉得这位讲得很清楚


kanate\_saikou


就在遥远的楼下

他代码也很漂亮，我就不讲也不贴了


---

## 作者：707001933K (赞：1)

这一题的树状数组拓展显得简单。

如果是区间修改和区间查询该怎么办？

详见我的博客：<http://blog.csdn.net/no1\_terminator/article/details/51713474>


这里就是一个偷换概念，于是我们得到一个著名的等式

区间修改+点查询+imos=前缀和+区间查询+点修改


imos是啥？可见我的博客。


上代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int n,m;
int a[500010],b[500010];
void add(int i,int x){
    while (i<=n){
        b[i]+=x;
        i+=i&(-i);
    }
}
int query(int i){
    int sum=0;
    while (i>0){
        sum+=b[i];
        i-=i&(-i);
    }
    return sum;
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        int x;
        scanf("%d",&x);
        a[i]=x;
    }
    for (int i=1;i<=m;i++){
        int opt,x,y;
        scanf("%d%d",&opt,&x);
        if (opt==1){
            int k;
            scanf("%d%d",&y,&k);
            add(x,k);
            add(y+1,-k);
        }else{
            printf("%d\n",a[x]+query(x));
        }
    }
    return 0;
}
```

---

## 作者：Running_Coder (赞：1)

1.对于区间修改：

直接修改数组c[]，即进行n次add，肯定会TLE；

于是在此引入一个新数组：addv[]，addv[i]指的是以结点i为根的树的所有元素加上addv[i]。

设将区间[a,b]中每个数加上x，

则只需自b向左，将相应的addv[]加上x，再自a-1向左，将多修改的结点的addv[]减去x即可。

2.对于单点查询：

设查询结点i，则其原值为：

（以结点i为根的树的所有元素的和）-（此树中除结点i之外的所有节点的和）；

然后从结点i向树根遍历，将遍历到的节点的addv[]值加给之前已计算出的结点i的原值，最终结果就是结点i现在的值。

代码如下：









    


    
    
        

        
    
    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
//#include<cmath>
#include<ctime>
#include<cstdlib>
#include<algorithm>
#include<string>
#include<stack>
#include<queue>
#include<vector>
using namespace std;
void add(int,int);
void update(int,int,int);
int query(int);
int c[500010];
int addv[500010];
int n,m;
int i,t;
int f;
int x,y,k;
int main(){
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++){
        scanf("%d",&t);
        add(i,t);
    }
    for(i=1;i<=m;i++){
        scanf("%d",&f);
        if(f==1){
            scanf("%d%d%d",&x,&y,&k);
            update(x,y,k);
        }
        else{
            scanf("%d",&x);
            printf("%d\n",query(x));
        }
    }
    return 0;
}
void add(int p,int x){
    while(p<=n){
        c[p]+=x;
        p+=p&-p;
    }
}
void update(int a,int b,int x){
    while(b>=a){     //区间加
        addv[b]+=x;
        b-=b&-b;
    }
    a--;
    while(a>b){     //区间减
        addv[a]-=x;
        a-=a&-a;
    }
}
int query(int p){
    int p1=p-(p&-p);
    int p2=p-1;
    int t=c[p];
    while(p2>p1){
        t-=c[p2];
        p2-=p2&-p2;
    }         //计算结点原值
    while(p<=n){
        t+=addv[p];
        p+=p&-p;
    }     //追加addv[]
    return t;
}
```

---

## 作者：kanate_saikou (赞：1)

这模板题名字就是树状数组..干嘛用线段树..代码还贼长..

这里介绍树状数组+差分思想，算是对下面大神的补充吧。

###何为差分

现在我们有一个从小到大的数列a[]

- a 1 3 6 8 9

然后还有一个差分数组b[]

- b 1 2 3 2 1

相信某些小伙伴已经看出端倪了..这里**b[i]=a[i]-a[i-1]**，我令a[0]=0，故b[1]=a[1]。

拥有了b数组，我们就可以很简单的求出bit[]中任意一个数，只需**bit[i]=sigma(k=1 to i) b[k]**（这个很好推吧..）

我觉得现在该有人说我zz了..何必不直接查询a[i]而是找这么麻烦一个方法..这里我们转回正题！别忘了，题目要我们进行区间修改..

我们知道，树状数组对于单点值的修改十分方便（不懂的去看树状数组1），对于区间的修改就比较尴尬..而我们又不想敲死长的线段树..怎么办呢，这时候差分就显出优势

还是上面的a[]和b[]，现在我们使区间[2,4]的所有数均+2，则a[]/b[]变为

- a 1 5 8 10 9

- b 1 4 3 2 -1

事实上，这里只有b[2]和b[5]发生了变化，因为区间内元素均增加了同一个值，所以b[3]，b[4]是不会变化的。

这里我们就有了第二个式子：对于区间[x,y]的修改（增加值为d）在b数组内引起变化的只有 **b[x]+=d，b[y+1]-=d**。（这个也很好推的..）

这样，我们就把树状数组的软肋用差分解决了。

附代码

```cpp
#include<iostream>
using namespace std;

int n,m,a[1000000],t[1000000];

int lowbit(int x) {
    return x&(-x);
}

void add(int x,int d) {
    while(x<=n) {
        t[x]+=d;
        x+=lowbit(x);
    }
}

int sum(int x) {
    int ans=0;
    while(x) {
        ans+=t[x];
        x-=lowbit(x);
    }
    return ans;
}

int main() {
    cin>>n>>m;
    for(int i=1;i<=n;i++) {
        cin>>a[i];
        add(i,a[i]-a[i-1]);   //直接将树状数组存为差分后数列 #**b[i]=a[i]-a[i-1]**#
    }
    for(int p=1,op,x,y,k;p<=m;p++) {
        cin>>op;
        if(op==1) {
            cin>>x>>y>>k;
            add(x,k); add(y+1,-k);   // #**b[x]+=d，b[y+1]-=d**#
        }
        if(op==2) {
            cin>>x;
            int ans=sum(x);   //#**bit[i]=sigma(k=1 to i) b[k]**#
            cout<<ans<<endl;
        }
    }
}
```

---

## 作者：飞翔 (赞：1)

其实很多关于树状数组的教程里都说的是[树状数组1](/problem/show?pid=3374)。

但是对于这题还是可以转化的。

在树状数组1中，大家应该有这么一个过程：

```c
void add(long long x,long long d)//把a[x]加上d
{
    if (x==0) return;
    while (x<=n) {
        c[x]+=d;
        x+=lowbit(x);
    }
}
```

然后在主程序里写

```c
scanf("%d",&t);
if (t==1) {
  scanf("%d%d%d",&x,&y,&k);
  add(x,k);
}
```
这样的add操作其实把x到n的结点全部加上了k，所以再次调用一个add(y+1,-k)就可以把多增加的结点再减回去。

好了，第一个操作转化完毕。

对于第二个操作就更简单了，直接scanf("%d",&x); printf("%d\n",sum(x)); 就可以了。

//此为给楼下的题解完善一些


---

## 作者：时光_Memory (赞：1)

```cpp
//对于30%的数据：N<=8，M<=10
//对于70%的数据：N<=10000，M<=10000
//对于100%的数据：N<=500000，M<=500000
//n个点，m次操作 
//树状数组变形 
//思路：c[x]存树状数组，假设a[i]为每个数的值（题目中未出现，此处便于理解）
//a[x]=sum(c[i])(i1=x,i2=i1-lowbit(i1),i3=i2-lowbit(i2),...)
//简单来说，原本树状数组管制的区间不再是和，而是a[i]的离散 
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<algorithm>
#define maxn 500000
//#define lb(x) (x&(-x))//好像这里可以，保险起见还是写函数吧 
using namespace std;
//////////////////////////
int n,m;
int c[maxn];
//////////////////////////
int lb(int x)
{
    return (x&(-x));
}
void add(int x,int num)
{
    if(x==0)
      return ;
    int k=x;
    while(k<=n)
      {
        c[k]+=num;
        k+=lb(k);
      }
}
int read(int x)
{
    int sum=0,k=x;
    while(k>=1)
      {
          sum+=c[k];
          k-=lb(k);
      }
    return sum;
}
//////////////////////////
int main()
{
    freopen("shu(2).in","r",stdin);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
      {
          int num;
          scanf("%d",&num);
          add(i,num);
          add(i+1,-num);
      }
    for(int i=1;i<=m;i++)
      {
          int caozuo;
          scanf("%d",&caozuo);
          if(caozuo==1)
            {
                int x,y,nnum;
                scanf("%d %d %d",&x,&y,&nnum);
                add(x,nnum);
                add(y+1,-nnum);//这一步是关键，上传到y就不上传了 
              }
        if(caozuo==2)
          {
              int a;
              scanf("%d",&a);
              cout<<read(a)<<endl;//单点求值变为树状数组求sum 
          }
      }
}
```

---

## 作者：EarthGiao (赞：0)

## 【思路】
树状数组   

### 【题目大意】 
区间修改和单点查询    

### 【题目分析】
~~明显就是要用线段树的好吧~~    
但是既然是树状数组的模板还是要给他个面子的   
所以还得用树状数组写    
区间修改和单点查询   
第一瞬间想到的时候暴力枚举每一个区间内的点修改   
然后求x位置的时候用sum(x) - sum(x - 1)就行了    
没有问题    
但是这样真的优美吗？    
 
### 【核心思路】
想要快速修改一个区间的值   
除了线段树还有什么呢？     
当然是差分了！     
差分之后不仅可以用树状数组轻松修改一个区间内的值    
而且求某个点的值得时候    
也不需要做差    
因为在差分数组中1-i的值加起来就是i原本的值    
而且sum(x)又是求得1 - x的值      
所以很好的可以应用上去     
## 【思路】
```cpp
#include<iostream>
#include<cstdio>
#define int long long

using namespace std;
const int Max = 500005;
int a[Max];
int n,m;
int read()
{
	int sum = 0,fg = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')fg = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		sum = sum * 10 + c - '0';
		c = getchar();
	}
	return sum * fg;
}

int lowbit(int x)
{
	return x & -x;
}

void add(int x,int y)
{
	while(x <= n)
	{
		a[x] += y;
		x += lowbit(x);
	}
}

int sum(int x)
{
	int ans = 0;
	while(x > 0)
	{
		ans += a[x];
		x -= lowbit(x);
	}
	return ans;
}

signed main()
{
	n = read(),m = read();
	int last = 0;
	for(register int i = 1;i <= n;++ i)
	{
		int qwq = read();
		add(i,qwq - last);
		last = qwq;
	}
	for(register int i = 1;i <= m;++ i)
	{
		int qwq = read();
		if(qwq == 1)
		{
			int x = read(),y = read(),z = read();
			add(x,z);
			add(y + 1,-z);
		}
		else
		{
			int x = read();
			cout << sum(x) << endl;
		}
	}
	return 0;
}
```

---

## 作者：Randyhoads (赞：0)

**70 分做法**

这道题单纯用类似差分的做法会Tle 3 个点

具体的思路是声明一个数组c，若要在l-r之间增加k,就c[l]+=k,c[l]-=k。

每次要求x的值就用x这个位置原来的值加上c[1]，c[2]....c[x]

但显然这样要超时

**70分代码**






        
      
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int f=1,x=0;
    char ch;
    do{
      ch=getchar();
      if(ch=='-')
         f=-1;
    }while(ch<'0'||ch>'9');
    do{
       x=x*10+ch-'0';
       ch=getchar();
    }while(ch>='0'&&ch<='9');
    return f*x;
}
const int MN=500005;
int n,m;
int a[MN],c[MN]={0};
int x,l,r,k,y;
inline int  sums(int x)
{
    int s=0;
    for (int i=1;i<=x;i++)
        s += c[i];
    return s;
}
int main()
{
    n= read();m=read();
    for (int i=1;i<=n;i++)
      a[i]=read();
    for (int i=1;i<=m;i++)
    {
        x= read();
        if (x==1)
        {
            l= read();
            r = read();
            k = read();
            c[l]+= k;
            c[r+1] -= k;
        }
        if (x==2)
        {
            y =read();
            cout<<a[y]+sums(y)<<endl;
        }
    }
    return 0;
}
```
**100分做法**
树状数组+差分的做法，下面的dalao已经讲的很明白了

主要的思路就是用树状数组来维护（这个做法是蒟蒻我看了题解写的）

主要就是用c数组的第i项表示第i个数

如果是区间修改要依赖差分，如果搞懂了树状数组的基本原理这个差分很容易理解

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int f=1,x=0;
    char ch;
    do{
      ch=getchar();
      if(ch=='-')
         f=-1;
    }while(ch<'0'||ch>'9');
    do{
       x=x*10+ch-'0';
       ch=getchar();
    }while(ch>='0'&&ch<='9');
    return f*x;
}
int c[1000001];
int lb(int x){return x&-x;};
int n,m; 
int a1[1000001];
int s;
int a2,b1,k;
void change(int a,int b)
{
    if(a)
    { 
    while(a<=n)
    {
        c[a]+=b;
        a+=lb(a);
    }
    }
}
int g_sum(int x)
{
    int re=0;
    while(x>=1)
    {
        re+=c[x];
        x-=lb(x);
    }
    return re;
}
int main()
{
    n=read();
    m=read();
    for(int i=1;i<=n;i++)
    { 
           a1[i]=read();
        change(i,a1[i]-a1[i-1]); 
    } 
    for(int i=1;i<=m;i++)
    {
        s=read();
        if(s==1)
        {
            a2=read();
            b1=read();
            k=read();
            change(a2,k);
            change(b1+1,-1*k);
        }
        if(s==2)
        {
            a2=read();
            cout<<g_sum(a2)<<endl;
        }
    } 
}
```

---


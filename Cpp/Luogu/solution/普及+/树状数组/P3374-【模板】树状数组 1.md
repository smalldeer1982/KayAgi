# 【模板】树状数组 1

## 题目描述

如题，已知一个数列，你需要进行下面两种操作：

- 将某一个数加上 $x$

- 求出某区间每一个数的和


## 说明/提示

【数据范围】

对于 $30\%$ 的数据，$1 \le n \le 8$，$1\le m \le 10$；   
对于 $70\%$ 的数据，$1\le n,m \le 10^4$；   
对于 $100\%$ 的数据，$1\le n,m \le 5\times 10^5$。

数据保证对于任意时刻，$a$ 的任意子区间（包括长度为 $1$ 和 $n$ 的子区间）和均在 $[-2^{31}, 2^{31})$ 范围内。


样例说明：

 ![](https://cdn.luogu.com.cn/upload/pic/2256.png) 

故输出结果14、16


## 样例 #1

### 输入

```
5 5
1 5 4 2 3
1 1 3
2 2 5
1 3 -1
1 4 2
2 1 4```

### 输出

```
14
16```

# 题解

## 作者：TJor (赞：1425)

## 引入

线段树和树状数组，是两个十分相似的数据结构。他们能使对一个区间的数修改以及查询的速度提升许多。两个结构本质相同，各有优缺点，今天我们来从单点修改，单点查询，区间修改，区间查询。

## 概念

###### 线段树

线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。

比如讲一个有4个数的线段树，是长这个样子的：

![](http://images2017.cnblogs.com/blog/987049/201708/987049-20170818161013115-871509071.png)

一号节点，代表着区间1~4

二号节点，代表区间1~2

三号节点，代表区间3~4

以此类推。。。。。。

很容易发现，对于n号节点来说，n×2代表着它的区间的前半段，n×2+1代表着它的区间的后半段。

###### 树状数组

树状数组是一个很奇特的树，它的节点会比线段树少一些，也能表示一个数组。

比如一个数组叫做a有8个数，那么它的树状数组样子就长这样

![](http://img2.imgtn.bdimg.com/it/u=2402068639,1966957079&fm=27&gp=0.jpg)

c数组就是树状数组，能看出来

```cpp
c1=a1;
c2=a1+a2;
c3=a3;
c4=a1+a2+a3+a4;
```
以此类推。。。。。。
很难说出他们的关系，但是如果把它们变为二进制

```cpp
c0001=a0001
c0010=a0001+a0010
c0011=a0011
c0100=a0001+a0010+a0011+a0100
```
你会发现，将每一个二进制，去掉所有高位1，只留下最低位的1，然后从那个数一直加到1，看一看是不是这样。
## 线段树构造

因为树状数组不需要构造这一过程，所以先讲线段树的构造

就是用到递归：先设left=1,right=n，然后每一次递归，left、mid和mid+1、right。代码如下：


```cpp
    void build(int left,int right,int index)
    {
        tree[index].left=left;
        tree[index].right=right;
           if(left==right)
            return ;
        int mid=(right+left)/2;
        build(left,mid,index*2);
        build(mid+1,right,index*2+1);
    }
```
``
## 线段树单点修改

单点修改就是每到一个节点，看这个节点代表着的区间包括不包括这个点，包括就加上。


```cpp
    void my_plus(int index,int dis,int k)
    {
        tree[index].num+=k;
        if(tree[index].left==tree[index].right)
            return ;
        if(dis<=tree[index*2].right)
            my_plus(index*2,dis,k);
        if(dis>=tree[index*2+1].left)
            my_plus(index*2+1,dis,k);
    }
```
## 树状数组单点修改
这里有一个很关键的东西，叫做lowbit，lowbit是将一个二进制数的所有高位一都去掉，只留下最低位的1，比如lowbit（5）=lowbit（0101（二进制））=0001（二进制）

而如果改变x的值，就要加上自己的lowbit，一直加到n，这些节点都要加，比如一共有8个数第3个数要加上k，那么c[0011]+=k;

c[0011+0001] (c[0100])+=k;

c[0100+0100] (c[1000])+=k;

这样就能维护树状数组


```cpp
    void add(int x,int k)
    {
        while(x<=n)
        {
            tree[x]+=k;
            x+=lowbit(x);
        }
    }
```
## 线段树区间查询
区间查询就是，每查到一个区间，有三种选择：

1、如果这个区间被完全包括在目标区间内，那么加上这个区间的和，然后return；

2、如果这个区间的right>目标区间的left，那么查询这个区间；

3、如果这个区间的left<目标区间的right，也查询这个区间;


```cpp
    void search(int index,int l,int r)
    {
        if(tree[index].left>=l && tree[index].right<=r)
        {
            ans+=tree[index].num;
            return ;
        }
        if(tree[index*2].right>=l)
            search(index*2,l,r);
        if(tree[index*2+1].left<=r)
            search(index*2+1,l,r);
    }
```
## 树状数组区间查询
就是前缀和，比如查询x到y区间的和，那么就将从1到y的和-从1到x的和。

从1到y的和求法是，将y转为2进制，然后一直减去lowbit(y)，一直到0

比如求1到7的和


```cpp
ans+=c[0111];
ans+=c[0111-0001(0110)];
ans+=c[0110-0010(0100)];
ans+=c[0100-0100(c[0]无意义，结束)]
    int sum(int x)
    {
        int ans=0;
        while(x!=0)
        {
            ans+=tree[x];
            x-=lowbit(x);
        }
        return ans;
    }
```
## 线段树区间修改
和线段树区间查询类似，分为三种

1、如果当前区间完全属于要加的区间，那么这个区间，也就是节点加上，然后return；

2、如果这个区间的right>目标区间的left，那么查询这个区间；

3、如果这个区间的left<目标区间的right，也查询这个区间;


```cpp
    void pls(int index,int l,int r,int k)
    {
        if(tree[index].left>=l && tree[index].right<=r)
        {
            tree[index].num+=k;
            return ;
        }
        if(tree[index*2].right>=l)
           pls(index*2,l,r,k);
        if(tree[index*2+1].left<=r)
           pls(index*2+1,l,r,k);
    }
```
##树状数组区间修改
这就会变的很好玩。如果将x到y区间加上一个k，那就是从x到n都加上一个k，再从y+1到n加上一个-k

加的移动还是i+=lowbit(i);


```cpp
    void add(int x,int k)
    {
        while(x<=n)
        {
            tree[x]+=k;
            x+=lowbit(x);
        }
    }
```
## 线段树单点查询
就是从根节点，一直搜索到目标节点，然后一路上都加上就好了。


    
```cpp
    void search(int index,int dis)
    {
        ans+=tree[index].num;
        if(tree[index].left==tree[index].right)
            return ;
        if(dis<=tree[index*2].right)
            search(index*2,dis);
        if(dis>=tree[index*2+1].left)
            search(index*2+1,dis);
    }
```
## 树状数组单点查询
从x点，一直x-=lowbit(x)，沿途都加上就好啦


    
```cpp
    int search(int x)
    {
        int ans=0;
        while(x!=0)
        {
            ans+=tree[x];
            x-=lowbit(x);
        }
        return ans;
    }
```
下面给大家分别发一下落谷树状数组1、2的AC代码
（线段树和树状数组都可以做这些题）

[树状数组1](https://www.luogu.org/problemnew/show/3374 "树状数组1")

###### 线段树代码：


```cpp
    #include <iostream>
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <cmath>
    #include <queue>
    using namespace std;
    int n,m;
    int ans;
    int he=0;
    int input[500010];
    struct node
    {
        int left,right;
        int num;
    }tree[2000010];
    void build(int left,int right,int index)
    {
        he++;
        tree[index].left=left;
        tree[index].right=right;
           if(left==right)
            return ;
        int mid=(right+left)/2;
        build(left,mid,index*2);
        build(mid+1,right,index*2+1);
    }
    int add(int index)
    {
        if(tree[index].left==tree[index].right)
        {
            //cout<<index<<" "<<input[tree[index].right]<<endl;
            tree[index].num=input[tree[index].right];
            return tree[index].num;
        }
        tree[index].num=add(index*2)+add(index*2+1);
        return tree[index].num;
    }
    void my_plus(int index,int dis,int k)
    {
        tree[index].num+=k;
        if(tree[index].left==tree[index].right)
            return ;
        if(dis<=tree[index*2].right)
            my_plus(index*2,dis,k);
        if(dis>=tree[index*2+1].left)
            my_plus(index*2+1,dis,k);
    }
    void search(int index,int l,int r)
    {
        //cout<<index<<" ";
        if(tree[index].left>=l && tree[index].right<=r)
        {
            ans+=tree[index].num;
            return ;
        }
        if(tree[index*2].right>=l)
            search(index*2,l,r);
        if(tree[index*2+1].left<=r)
            search(index*2+1,l,r);
    }
    int main()
    {
        cin>>n>>m;
        for(int i=1;i<=n;i++)
            scanf("%d",&input[i]);
        build(1,n,1);
        add(1);
        for(int i=1;i<=m;i++)
        {
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);
            if(a==1)
            {
                my_plus(1,b,c);
            }
            if(a==2)
            {
                ans=0;
                search(1,b,c);
                printf("%d\n",ans);
            }
        }
    }
```
###### 树状数组代码：

```cpp
    #include <iostream>
    #include <cstdio>
    #include <algorithm>
    #include <cmath>
    #include <cstring>
    using namespace std;
    int n,m,tree[2000010];
    int lowbit(int k)
    {
        return k & -k;
    }
    void add(int x,int k)
    {
        while(x<=n)
        {
            tree[x]+=k;
            x+=lowbit(x);
        }
    }
    int sum(int x)
    {
        int ans=0;
        while(x!=0)
        {
            ans+=tree[x];
            x-=lowbit(x);
        }
        return ans;
    }
    int main()
    {
        cin>>n>>m;
        for(int i=1;i<=n;i++)
        {
            int a;
            scanf("%d",&a);
            add(i,a);
        }
        for(int i=1;i<=m;i++)
        {
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);
            if(a==1)
                add(b,c);
            if(a==2)
                cout<<sum(c)-sum(b-1)<<endl;
        }
    }
```
[树状数组2](https://www.luogu.org/problemnew/show/3368 "树状数组2")
###### 线段树代码：


```cpp
    #include <iostream>
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <cmath>
    #include <queue>
    using namespace std;
    int n,m;
    int ans;
    int input[500010];
    struct node
    {
        int left,right;
        int num;
    }tree[2000010];
    void build(int left,int right,int index)
    {
        tree[index].num=0;
        tree[index].left=left;
        tree[index].right=right;
           if(left==right)
            return ;
        int mid=(right+left)/2;
        build(left,mid,index*2);
        build(mid+1,right,index*2+1);
    }
    /*int add(int index)
    {
        if(tree[index].left==tree[index].right)
        {
            tree[index].num=input[tree[index].right];
            return tree[index].num;
        }
        tree[index].num=add(index*2)+add(index*2+1);
        return tree[index].num;
    }
```
\*/
    
```cpp
    void pls(int index,int l,int r,int k)
    {
        if(tree[index].left>=l && tree[index].right<=r)
        {
            tree[index].num+=k;
            return ;
        }
        if(tree[index*2].right>=l)
           pls(index*2,l,r,k);
        if(tree[index*2+1].left<=r)
           pls(index*2+1,l,r,k);
    }
    void search(int index,int dis)
    {
        ans+=tree[index].num;
        if(tree[index].left==tree[index].right)
            return ;
        if(dis<=tree[index*2].right)
            search(index*2,dis);
        if(dis>=tree[index*2+1].left)
            search(index*2+1,dis);
    }
    int main()
    {
        int n,m;
        cin>>n>>m;
        build(1,n,1);
        for(int i=1;i<=n;i++)
            scanf("%d",&input[i]);
        for(int i=1;i<=m;i++)
        {
            int a;
            scanf("%d",&a);
            if(a==1)
            {
                int x,y,z;
                scanf("%d%d%d",&x,&y,&z);
                pls(1,x,y,z);
            }
            if(a==2)
            {
                ans=0;
                int x;
                scanf("%d",&x);
                search(1,x);
                printf("%d\n",ans+input[x]);
            }
        }
    }
```
###### 树状数组代码：

    
```cpp
    #include <iostream>
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <cmath>
    #include <queue>
    using namespace std;
    int n,m;
    int input[500010];
    int tree[500100];
    int lowbit(int x)
    {
        return x & -x;
    }
    void add(int x,int k)
    {
        while(x<=n)
        {
            tree[x]+=k;
            x+=lowbit(x);
        }
    }
    int search(int x)
    {
        int ans=0;
        while(x!=0)
        {
            ans+=tree[x];
            x-=lowbit(x);
        }
        return ans;
    }
    int main()
    {
        cin>>n>>m;
        for(int i=1;i<=n;i++)
            cin>>input[i];
        for(int i=1;i<=m;i++)
        {
            int a;
            scanf("%d",&a);
            if(a==1)
            {
                int x,y,z;
                scanf("%d%d%d",&x,&y,&z);
                add(x,z);
                add(y+1,-z);
            }
            if(a==2)
            {
                int x;
                scanf("%d",&x);
                printf("%d\n",input[x]+search(x));
            }
        }
    }
```
## 总结
最后，再来总结一下

###### 时间复杂度

虽然它们都是nlogn，但是，你会发现，在查询时，树状数组最坏情况是logn（比如8个数，然后查询8），但是线段树是所有情况都是nlogn，稍慢于树状数组。


######空间复杂度

树状数组完胜于线段树，线段树要开2倍到4倍内存（推荐4倍），但是树状数组一倍就够了。


######适用范围

线段树之所以存在的理由是因为它能适用于很多方面，不仅仅是区间、单点的查询修改，还有标记等等，可以用于模拟、DP等等，而且空间经过离散化以后也可以相对压缩，所以适用范围线段树更加广一些。


---

## 作者：皎月半洒花 (赞：703)

# 一、浅析数据结构之用处和高级数据结构之特性

数据结构者，谓之**数据之关系**。单论数据特性，也不过是数据之间的存储方式罢。但要说更深层次之作用，是**运用其存储之特性，建立数学之模型，更方便地才处理数据尔**。

以上是鲁迅同志说的（鲁迅：$exm$？？？），其实一切的数据结构不过就是一种**用于处理数据的、成熟的、合理的结构封装**。较低级的数据结构不会支持什么操作，仅是维护自身的存储秩序；而高级数据结构则可以支持许多操作——其实也不过是维护自身数据的秩序而已，只不过在维护其自身秩序的同时，由于其本身结构复杂且特点鲜明，所以会产生许多很优化的算法。
（鲁迅：看在你讲得这么好饶了你！）

而今天我们主要介绍有关 RMQ、RSQ 问题的、较为基础的高级数据结构。

# 二、先来介绍分块思想吧

## （一）基本性质与证明

其实从本质上来讲，分快更像是一种思想。分块，顾名思义，就是将一个区间分成几块，然后对于每个询问，整合一个或者多个甚至全部区间的信息。但是在这种整合不是随便整合，必须要有技巧、有目的地整合，才会减小时间复杂度。

先看一道例题：

现在你有一个长度为 $n$ 的序列，有 $m$ 个操作：

1.修改某位置的元素的值。

2.将一段区间的元素加上或减去一个值。

3.求一段区间的元素的最大值。

$n,m\leq 50000$。

让我们考虑分块:
首先第一步，进行区间划分，在这一步我们考虑将整个序列划分成 $\sqrt{n}$ 块，这可以使得其总查询时间最快

证明：

对于搜查整个序列中的一段区间，设这段区间内的完整分块块数是 $C$ 块，每一段均匀的分块都 $S$ 个元素，那么这一段区间的最复杂形式为:有 $C$ 个完整区间，并且闭区间 [$l$,$r$] 还在两端包括有不完整的分好的块：

```cpp
——|—【————|——————|——————|————】—|————
```

上图中【】表示区间，| 与 | 之间表示分好的均匀块（博主不知道怎么画精美的图啦）

我们可以发现该区间内有 $C$ 段完整区间，$2$ 段不完整区间；而同时，不完整区间的元素数量之和，绝对小于等于 $2S$；那么我们对于这一个区间而言，共需要进行最多 $C+2S$ 次查询——因为一个分块可以供给块内所有元素的信息。那么查询的时间复杂度便是 $O(C+2S)$。从渐进意义上来讲，时间复杂度为 $O(C+S)$，渐进整合后便是 $O(\max\{C,S\})$（**渐进的时间复杂度，可以认为等于对数值改变影响最大的数值的复杂度**）。

在知道这一点之后，我们可以这么想：

因为 

$$
C\times{S}+2S\geq r-l+1
$$

所以我们可以近似地看做有

$$
C\times{S}=r-l+1
$$

所以在同一区间内 $C×S$ 之积可以看作是个定值。那么当且仅当 $S=C$ 时，才会使得 $\max\{C,S\}$ 最小，此时 $S=C=\sqrt{n}$。

## （二）分块的运行机制

首先就是确立所分的块与被包含元素之间的关系，我们在此用一个 `belong` 数组记录每个点与所分的块之间的关系，同时进行区间记录。

```cpp
	int n,a[MAXN],belong[MAXN];
	int S,C=0,st[MAXN],ed[MAXN];//sum[MAXN],ma_x[MAXN],mi_n[MAXN]; 
	/*
	n:元素个数，a[]：元素，belong[]:每个元素所属的块的编号 
	S:每个块有多少元素 C:分块个数 st/ed:每个块的左边界、右边界 
	sum[MAXN]/ma_x[MAXN]/mi_n[MAXN]用于记录区间信息 
	*/ 
	void pretreat()
	{
		S=int(sqrt(double(n)));
		for(int i=1;i<=n;i+=S){
			st[++C]=i;
			ed[C]=min(i+S-1,n);//有可能会越界（sqrt必然有精度误差） 
		}
		for(int i=1;i<=C;i++)
			for(int j=st[i];j<=ed[i];j++)
				{
				belong[j]=i;//初始化belong 
				/*
    //区间操作  sum[i]+=a[j];
				ma_x[i]=max(ma_x[i],j);
				*/
				}
	}
```

其次便是区间修改 & 单点修改：由于区间操作只能针对于某个已经被分好的块，所以对于某些不完整区间的改动，需要进行单点修改。

对于区间修改，还有一点，为了帮助我们对区间讯息的整合，所以会引进一个`delta mark`，记录某个区间整体的变化情况。

注意：**当且仅当一个块被统一修改，才会改变这个块的 `delta` 值。**

```cpp
//区间单点修改 ，此处以求区间和为例 
	inline void updata_single(int x,int k)
	{
		a[x]+=k;
		sum[belong[x]]+=k;
	}
	
	//区间修改，同上
	int delta[MAXN];//用于记录一个！完整！区间的修改 
	void updata_range(int x,int y,int k)
	{
	    int l=belong[x],r=belong[y];
		if(l==r&&st[l]==x&&st[r]==y)
		{delta[l]=k; return ;}//ma_x[]
		//这个if纯粹是为了减少底下的运算，毕竟判断只有O(1) qwq
		else
		{
			for(int i=x;i<=ed[l];i++)
				updata_single(i,k);//如果不是完整区间，就单点修改 
			if(st[l]>x&&st[r]<y)return ; 
			//如果查询区间被某个块完全包含且不相等，
			//不需要进行以下操作 
			for(int i=st[r];i<=y;i++)
				updata_single(i,k);
			//如果所查询区间与块有交集且不想等
			//不需进行以下操作 
			for(int i=l+1;i<r;i++)
				delta[i]+=k;;
		}
	}
	
```

紧接着就是区间询问了，此时我们的 `delta` 就派上用场啦！
```cpp
	int query(int x,int y)//依然为区间和 
	{
		int l=belong[x],r=belong[y],ans=0;
		if(l==r){
			for(int i=x;i<=y;i++)
				ans+=a[i]+delta[belong[i]];
		}
		else{
			for(int i=x;i<=ed[l];i++)
				ans+=a[i]+delta[belong[i]];
			for(int i=l+1;i<r;i++)
				ans+=sum[i]+delta[i]*(ed[i]-st[i]+1);
				//对于每个区间的O(1)运算 
			for(int i=st[r];i<=y;i++)
				ans+=a[i]+delta[belong[i]];
		}
		return ans;
	}
```
我们会发现，对于一个分块程序来说，期望的时间总复杂度为：$O(m\sqrt n)$，对于 $50000$ 来说完全能跑开。

# 三、树状数组浅谈
 
## （一）关于树状数组的正确释义

首先要知道一个很重要的点：

**树状数组用的是树结构的思想(也就是树型逻辑结构)，而不是真正的“树形结构”**，初学者不要被强行拉入坑啊（换句话说，从某种意义上，树状数组跟树其实——————没有特别大的关系）。

那它为什么被叫作树状数组呢？

## （二）树状数组的存储特点

首先解释，树状数组支持的操作：

1、区间和、区间异或和、区间乘积和 RMQ（**显然，支持的操作都具有交换律，这也算是树状数组的一大特性吧**）

2、单点修改（**朴素的树状数组结构不支持区间修改，当然也可以普及成区间修改结构但我们先不提**）

那为什么不直接用前缀和或者差分数组呢？

我们知道，前缀和数组的维护是 $O(n)$ 的，查询、修改是 $O(1)$ 的。然而，树状数组的维护却是 $O(\log n)$ 的。并且查询、修改也是 $O(1)$ 的——这便是一个很大的优化。

等等，$\log n$？有点眼熟诶。再提示提示，这个 $\log$ 实际意义其实是 $\log$ 以 $2$ 为底———————

对，没猜错，就是二进制表示法，也就是二叉树上数据之间的特殊逻辑关系！

实际上，对于树状数组的每一个 i，其实际意义应该为：

**算上其本身的讯息，总共存储了 $2^k$ 个元素的信息，其中 $k$ 表示 $i$ 在二进制下，末尾零的个数，同时也可以表示最小的含 1 位的二进制权值——换句话讲，$2^k$ 即可表示成：对于每个二进制意义下的 $i$，从最末位数 $k+1$ 位，保留这 $k+1$ 位并删除 $k+1$ 位以左的所有数位上的数，留下的新二进制数的实际大小。**

而对于每一个x的最低含一位，即上文中的 $2^k$，可以借助一个 $\rm lowbit$ 函数实现——而这个的实现方式是很玄学的：

```cpp
	inline int lowbit(int x)
	{
		//return (x^(x-1))&x;
		return x&(-x);
	}
```
上文代码中给了两种不同的实现方式，而这两种中，有一种是通过数学+二进制的方式得出，另一种则是通过计算机编码特性得出——我实在懒得证了。

（三）树状数组的建立、维护和查询

建立：此处拿求区间和为样例

```
void build() 
{
for(int i=1;i<=n;i++)       
{cin>>a[i];tree[i]=i;}//一开始先赋初值
}
```

维护：看注释
```cpp
void updata(int x,int k)
{
	for(;x<=n;x+=lowbit(x))
		tree[x]+=k;
//此处可以如是想：lowbit取出的是当前x的最低含一位
//权值位，相加后等于向高位进位，并且已有的数位永远为零
//这就可以推出：每当x值+=lowbit(x)时，都会有进位，并且
//进位后的新x值一定包含所有原来的x值，也就是说，这一步
//充分地向上进位，达到区间和更新的目的。 
}
```

询问：从大到小枚举，比较方便。

```cpp
	long long query(int x){
		int ans;
		for(;x;x-=lowbit(x))
			ans=ans+tree[x];
		return ans;
	}
```

整合：相减即可。

```cpp
    inline long long my_union(int x,int y)
	{
		return query(x)-query(y-1);
     }
```

因此操作的复杂度均为单次 $O(\log n)$。





---

## 作者：何其所幸 (赞：109)

**树状数组** 是什么呢？
其实就是一棵长歪的线段树吧 其中c[]数组表示自己所管辖的a[]数组的数的和 比如 从图中可以看出来 c[4]=a[1]+a[2]+a[3]+a[4]; c[6]=c[5]+c[6];

然后我们看一下4和6的二进制数 4 ->100   6->110 我们发现 二进制的最低位的1转成十进制后（我们设转成十进制后是x） 就是这个数组所管辖的个数 即c[4]管4个 c[6]管2个 如果我们仔细仔细看一下这个图 看一下每个 c[]数组管辖的特点.........

我们发现每个c[]管辖的数都是连续的 从另一个角度来说 每个c[]管从自己开始往前x个连续的数 （嗯...意味着搜了一个c[]就等于搜了x个a[]） 
![](https://cdn.luogu.com.cn/upload/pic/32832.png)
那么可以看出来 这个x非常重要 那么这个二进制最低位转十进制怎么算呢？

代码在这里：

```cpp
long long lowbit(int x)
{
return x&-x;
}
```
具体解释，需要利用计算机存储原理的补码的相关知识
二进制存储？
原码→反码→补码？
位运算？

我们有前面的铺垫很容易得到一个结论：节点编号+区间长度=父亲编号



------------
根据这些那么这个 树状数组一就可以解决了

需要解决的问题

1.在第x个数上加k
2.求[x,y]区间的和

1.要将a[x]+=w，就要在c[]中所有覆盖到x的位置全部加上w ,第一个覆盖x的恰好就是c[x],节点编号+区间长度=父亲编号
那就从x开始，每次x+=lowbit(x)向上爬就好了
2.求[x,y]的和，可以用[1,y]的和减掉[1，x-1]的和；
例如求[1,7]的和 那么ans=c[4]+c[6]+c[7]

我们从c[7]开始，首先使ans+=c[7]
由于c[7]包含了一段区间的总和，我们令7减去lowbit(7)，得到6，接下来只要求a[1..6]
同样，ans+=c[6]
6-lowbit(6)=4 重复上述过程 直到位置变为0。

那么 代码就好看多了


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int const maxn=500005;
int n,m,p,x,y;
long long a,c[maxn];
long long lowbit(int x)//lowbit是求得区间范围 
{
return x&-x;
}
void add(int u,int v)
{
for(int i=u;i<=n;i+=lowbit(i))
c[i]+=v;
}//在u位置add上v  从赋值处往上修改 u+lowbit(u) 
long long sum(int u)
{
int ans=0;
for(int i=u;i>0;i-=lowbit(i))
ans+=c[i];
return ans;
}//从末开始往前找 每次加上自己所管辖的数
//比如搜索sum(7)则 sum=c[7]+c[6]+c[4] 
int main()
{
scanf("%d %d",&n,&m);
for(int i=1;i<=n;i++)
{
  scanf("%lld",&a);
  add(i,a);
}
for(int i=1;i<=m;i++)
{
  scanf("%d%d%d",&p,&x,&y);
  if(p==1)
  {
   add(x,y);
  }
  if(p==2)
  {
   printf("%lld\n",sum(y)-sum(x-1));
  }
}
return 0;
}
```
依依不舍的第一篇题解.......(*^▽^*)

---

## 作者：feecle6418 (赞：95)

这里是一篇 **CDQ分治** 的题解！

CDQ分治的基本思想可以概括为：把这些询问排成一个序列（离线），递归处理相对于左区间和右区间的询问，在计算答案时，**合并两个子问题（类似于归并排序求逆序对），即考虑左半区间内的修改对右半区间内的询问产生的影响**。也就是，用左边的子问题来帮助解决右边的子问题。因此，CDQ分治可以支持修改。

对于这道题，我们把两个操作拆成三个操作：
1. 修改。
2. 对于查询操作 $[l,r]$ 的 $[1,l-1]$ 查询前缀和。在此时，我们需要把此次查询的结果**减去**当前前缀和。
3. 对于查询操作 $[l,r]$ 的 $[1,r]$ 查询前缀和。在此时，我们需要把此次查询的结果**加上**当前前缀和。

然后，我们对于整个**询问序列**进行CDQ分治，即可出解。相比于树状数组，常数较大，最大的点跑了540ms。若有不理解的地方可自行对照代码。

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct Query{
    int type,id,val;
    bool operator <(const Query sasa) const {
        return id==sasa.id?type<sasa.type:id<sasa.id;
    }
}a[2000005];
int qid,ans[2000005];
int aid=0;
Query tmp[2000005];
void CDQ(int l,int r){
    if(l==r)return ;
    int mid=(l+r)>>1;
    CDQ(l,mid);
    CDQ(mid+1,r);
    int sum=0,p=l,q=mid+1,o=l;
    while(p<=mid&&q<=r){
        if(a[p]<a[q]){
            if(a[p].type==1)sum+=a[p].val;
            tmp[o++]=a[p++];
        }
        else {
            if(a[q].type==2)ans[a[q].val]-=sum;
            if(a[q].type==3)ans[a[q].val]+=sum;
            tmp[o++]=a[q++];
        }
    }
    while(p<=mid)tmp[o++]=a[p++];
    while(q<=r){
        if(a[q].type==2)ans[a[q].val]-=sum;
        if(a[q].type==3)ans[a[q].val]+=sum;
        tmp[o++]=a[q++];
    }
    for(int i=l;i<=r;i++)a[i]=tmp[i];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        int t;
        scanf("%d",&t);
        a[++qid].type=1;
        a[qid].id=i;
        a[qid].val=t;//把最初的N个数也看成修改操作
    }
    for(int i=1;i<=m;i++){
        int opt,x,y;
        scanf("%d%d%d",&opt,&x,&y);
        if(opt==1){
            a[++qid].type=1;
            a[qid].id=x;
            a[qid].val=y;
        }
        else {
            a[++qid].type=2;
            a[qid].id=x-1;
            a[qid].val=++aid;
            a[++qid].type=3;
            a[qid].id=y;
            a[qid].val=aid;
        }
    }
    CDQ(1,qid);
    for(int i=1;i<=aid;i++)printf("%d\n",ans[i]);
}
```

---

## 作者：冈崎梦美 (赞：62)

# 分块大法

## 1.1 概念
分块是一种~~暴力~~数据结构。分块的基本思想是把一个整体数列分成多块，使得查询时可以调用已经处理好的每块的信息。它的查询复杂度一般为$ O(\sqrt{n}) $。修改复杂度不一定，在这一题中修改复杂度为$ O(1) $。

## 1.2 为何选择分块？何时使用分块？
当然是因为它比较好想好写了！当题目中出现各种~~傻逼毒瘤一般~~比较难以实现的更新操作时，线段树、树状数组的更新操作均需进行较大改动才可使用时，就是分块派上用场的时候！

~~这道题好像更新很好实现啊，你是不是在打自己的脸啊?~~

## 2.1 一切的开始
要分块，首先要确定块的大小。一般来说，块的大小都为$\sqrt{n}$。这样大小的块可以保证整个序列被分成$\sqrt{n}$块。这样查询的时间复杂度可以达到平均。

分块算法中需要记录的信息有：
```
int sum[maxn];//一个块的和
int l[maxn];//一个块的左端点（起始点）
int r[maxn];//一个块的右端点（终结点）
int a[maxn];//原数组
int belong[maxn];//第i个元素属于第belong[i]个块
int block,num;//block表示块的大小，num表示块的数量。
```

分块的build函数代码为：
```
void build()
{
    block=sqrt(n);//块的大小是根号n
    num=n/block;if (n%block) num++;//有可能n不是完全平方数，这时块数需要加一
    for(int i=1;i<=num;i++)
    {
        l[i]=(i-1)*block+1;r[i]=i*block;
    }//对于左端点和右端点处理
    for(int i=1;i<=n;i++) belong[i]=(i-1)/block+1;
    r[num]=n;//最后一个块的右端点一定为n
    for(int i=1;i<=num;i++)
        for(int j=l[i];j<=r[i];j++)
            sum[i]+=a[j];//预处理出所有块的和
}
```

## 2.2 更新操作
很简单，无须赘述，基本上代码一看就懂。
```
inline void updata(int x,int y)//第x个元素加上y
{
    a[x]+=y;
    sum[belong[x]]+=y;//第x个元素所在的块的总和也要加上y
}
```

## 2.3 查询操作
这基本上是分块最难的点。但实际也很简单。

查询共有两种情况：
### A. 区间被一个块完整包含
直接暴力求解。因为块的大小最大为$\sqrt{n}$，所以复杂度为$O(\sqrt{n})$。
```
if (belong[x]==belong[y])
{
    for(int i=x;i<=y;i++) ans+=a[i];
    return ans;
}
```

### B. 区间横跨多个块
这是我们讲述的重点。请看下面这张图：

![查询区间](https://cdn.luogu.com.cn/upload/pic/16820.png)

如图，我们需要查询x至y的区间和。

首先，我们先暴力求出x到它所属的块的右端点的区间和。如下图所示：

![上述操作即为暴力求解图中黑箭头到红箭头之间的区间和](https://cdn.luogu.com.cn/upload/pic/16827.png)

上述操作即为暴力求解图中黑箭头到红箭头之间的区间和。代码如下
：
```
for(int i=x;i<=r[belong[x]];i++) ans+=a[i];
```

接下来，我们会发现：

![](https://cdn.luogu.com.cn/upload/pic/16830.png)

** 从x所属的下一个块开始，到y之前的一个块的区间内，所有块都是完整的 **

所以我们只需要使用之前处理出来的块的信息就可以啦。代码如下：
```
for(int i=belong[x]+1;i<=belong[y]-1;i++) ans+=sum[i];
```
然后重复类似开始的操作，暴力求解途中蓝箭头至y那一段即可。
```
for(int i=l[belong[y]];i<=y;i++) ans+=a[i];
```
所以分块中查询的函数部分如下：
```
inline int query(int x,int y)
{
    int ans=0;
    if (belong[x]==belong[y])
    {
        for(int i=x;i<=y;i++) ans+=a[i];
        return ans;
    }
    for(int i=x;i<=r[belong[x]];i++) ans+=a[i];
    for(int i=belong[x]+1;i<=belong[y]-1;i++) ans+=sum[i];
    for(int i=l[belong[y]];i<=y;i++) ans+=a[i];
    return ans;
}
```

## 3.1 完整code
分块的代码还是很好写的。需要注意的是这题数据有点大，所以要用读优+内联卡常过。
```
#include<bits/stdc++.h>
#define maxn 500007
using namespace std;
int sum[maxn],r[maxn],l[maxn],a[maxn],belong[maxn],block,num,n,m;
inline void write(int x)
{
    if(x<0) x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline int read()
{
    int x=0,f=1;char ch;
    for(;!isdigit(ch);ch=getchar()) f=ch=='-'?-1:1;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return x*f;
}
inline int query(int x,int y)
{
    int ans=0;
    if (belong[x]==belong[y])
    {
        for(int i=x;i<=y;i++) ans+=a[i];
        return ans;
    }
    for(int i=x;i<=r[belong[x]];i++) ans+=a[i];
    for(int i=belong[x]+1;i<=belong[y]-1;i++) ans+=sum[i];
    for(int i=l[belong[y]];i<=y;i++) ans+=a[i];
    return ans;
}
inline void updata(int x,int y)
{
    a[x]+=y;
    sum[belong[x]]+=y;
    //for(int i=1;i<=num;i++) printf("l: %d,r: %d,sum: %d\n",l[i],r[i],sum[i]);
    //putchar('\n');
}
inline void build()
{
    block=sqrt(n);
    num=n/block;if (n%block) num++;
    for(int i=1;i<=num;i++)
    {
        l[i]=(i-1)*block+1;r[i]=i*block;
    }
    for(int i=1;i<=n;i++) belong[i]=(i-1)/block+1;
    r[num]=n;
    for(int i=1;i<=num;i++)
        for(int j=l[i];j<=r[i];j++)
            sum[i]+=a[j];
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
    }
    build();
    //for(int i=1;i<=num;i++) printf("l: %d,r: %d,sum: %d\n",l[i],r[i],sum[i]);
    for(int i=1;i<=m;i++)
    {
        int mode=read(),x=read(),y=read();
        if (mode==1) updata(x,y);
        else
        {
            write(query(x,y));
            putchar('\n');
        }
    }
    return 0;
}
```
就这么多啦。比赛临近，多写点题解攒RP。* Feather-Sea *祝您在洛谷好运连连！

---

## 作者：蒟蒻lxy (赞：43)

#### 本人树状数组的第一篇题解（~~也可以说是教程~~）
题目链接：[Link](https://www.luogu.org/problemnew/show/P3374)
## 1.思路

~~看一下题目名字你就知道了~~   
其实就是树状数组裸题（ _~~也没什么好说的~~_   
上图：

![树状数组](https://res.jisuanke.com/img/upload/20180503/a0d62ec5fe7ada70fb95cea10e943b6642ab1b41.png)
其中lowbit指：
> **lowbit 为一个数的二进制表示中最右边 11 所对应的值**   
> 或者说：   
> **lowbit=$2^k$,k为一个数的二进制表示中末尾0的个数** 

lowbit看起来不好求，**但是**，有一种简单版的~~无脑~~操作：
```
int lowbit(int x)
{
	return x&(-x);
}
```
~~为什么不早点说~~

   树状数组就是由lowbit分段的一种~~实用的~~数据结构，它的每一个节点管一个区间，存的是这个节点管的区间的最大值
## 2:分析
看到题目的要求：
> 1.将某一个数加上x

> 2.求出某区间每一个数的和

所以我们需要支持修改和查询操作

在这里我们设原数组为s，树状数组为c

### 修改：
修改即在x位置加上d   
想想看，树状数组的每一个节点存的是它管的区间的最大值，所以，如果修改最底层的一个点的值，受影响的是不是一条链？

修改节点11的值（红线即为受影响的）
![树状数组2](https://cdn.luogu.com.cn/upload/pic/62210.png)
由此可以推出此代码：
```cpp
void add(int x,int d)
{
	s[x]+=d;
	for(int i=x;i<=n;i+=lowbit(i))
		c[i]+=d;
}
```
### 查询：

查询比较复杂。

假设我们要求区间[L,R]的和     
那我们可以由[1,r]的和-[1,L]的和求出次结果    
问题就在于怎么求[1,X]的和

其实很简单
> 1. 设sum为和值
> 2. sum加上区间[X-lowbit(X)**+1**,X]的值（记住一定要+1）
> 3. x=X-lowbit(X)
> 4. 如果(x==0)则结束，否则回到步骤2

~~没毛病~~      
所以代码来了：
```
int sum(int x)
{
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i))
		ans+=c[i];
	return ans;
}
```
## 3.整体代码
树状数组完全可以被封装为一个类   
在这里我实现一下。

其他代码：   
```
//初始化
void init()
{
	memset(c,0,sizeof(c));
	for(int i=1;i<=n;i++)
		for(int j=i-lowbit(i)+1;j<=i;j++)
			c[i]=c[i]+s[j];
}
```
```
//调试用的输出
void print()
{
	for(int i=1;i<=n;i++)
		printf("%d ",s[i]);
	cout <<"     ";
	for(int i=1;i<=n;i++)
		printf("%d ",c[i]);
	cout << endl;
}
```

### 整体 ~~(终于要写完了啊啊啊）~~
```
#include<bits/stdc++.h>
using namespace std;
const int Maxn=500005;
int n,s[Maxn],m;
int lowbit(int x)
{
	return x&(-x);
}
struct node
{
	int c[Maxn];
	void add(int x,int d)//修改
	{
		s[x]+=d;
		for(int i=x;i<=n;i+=lowbit(i))
			c[i]+=d;
	}
	int sum(int x)//查询
	{
		int ans=0;
		for(int i=x;i>0;i-=lowbit(i))
			ans+=c[i];
		return ans;
	}
	void init()//初始化
	{
		memset(c,0,sizeof(c));
		for(int i=1;i<=n;i++)
			for(int j=i-lowbit(i)+1;j<=i;j++)
				c[i]=c[i]+s[j];
	}
	void print()//用来调试的输出
	{
		for(int i=1;i<=n;i++)
			printf("%d ",s[i]);
		cout <<"     ";
		for(int i=1;i<=n;i++)
			printf("%d ",c[i]);
		cout << endl;
	}
}a;
int main()
{
	cin >> n >> m;
	for(int i=1;i<=n;i++)//输入
		scanf("%d",&s[i]);
	a.init();//初始化
	for(int i=1;i<=m;i++)
	{
		//a.print();//调试
		int b,x,y;
		scanf("%d%d%d",&b,&x,&y);
		if(b==1)//操作1
			a.add(x,y);//把x为加上y
		else//操作2
			printf("%d\n",a.sum(y)-a.sum(x-1));//如上“查询”章所说
	}
	//a.print();//调试
	return 0;
}
```
这应该是我最长的一篇题解~~~QWQ

---

## 作者：密期望 (赞：43)

自己写库的时候无聊，想封装一个树状数组，于是就写了起来，但是写着写着我就感觉不舒服，代码里会出现很多类似于
```
a.add(1);
a.get_sum(1,3);
```
这样的东西。我就觉得总像是在写Java一样，根本不像是一个数组。

我想要我的数组能够这么玩
```
void test(){
	tree_array<int>a(10);//定义一个int数组，最多访问a[10]
	a[2]=3;//赋值
	int b=a[2];//也可以读取
	a[3]+=a[2][5];//a[2][5]表示a.get_sum(2,5)，区间查询
}
```
于是就诞生了这个疯狂重载运算符的这个东西
```#include<cstdio>
template < typename data_type >
//数组类型为data_type，请传入一个可以用树状数组维护的类型 
class tree_array{
	private:
		static int lowbit(int x){
			return x&-x;
		}
		class iterator{//用一个迭代器的对象来完成各种黑科技 
			private:
				tree_array *arr;//保存迭代器指向的数组 
				int n;//保存迭代器指向的位置 
			public:
				iterator(tree_array *arr_,int n_):arr(arr_),n(n_){
				}
				operator const data_type(){//直接返回数组的值，但不允许修改 
					return arr->data[n];
				}
				data_type operator[](int n_){//重载迭代器的[]运算符，以完成区间查询 
					return arr->get_sum(n,n_);
				}
				data_type operator+=(data_type x){ 
					arr->add(n,x);
					return arr->data[n];
				}
				data_type operator=(data_type x){//用类似的方法可以重载-=,*=,/=,%=等运算符 
					arr->add(n,x-arr->data[n]);
					return arr->data[n];
				}
		};
		data_type *data;//储存原数组，主要用于支持迭代器的赋值操作 
		data_type *sum;//储存树状数组 
		int size;
		void add(int pos,data_type data_){//常规操作 
			data[pos]+=data_;
			while(pos<=size){
				sum[pos]=sum[pos]+data_;
				pos+=lowbit(pos);
			}
		}
		data_type get_sum(int begin,int end){//常规操作 
			data_type ret=0;
			while(end){
				ret=ret+sum[end];
				end-=lowbit(end);
			}
			--begin;
			while(begin){
				ret=ret-sum[begin];
				begin-=lowbit(begin);
			}
			return ret;
		}
	public:
		tree_array(int size_,data_type zero):
		//注意传入0来初始化，这里的0是指满足0+0=0的data_type对象 
		data(new data_type[size_+1]),sum(new data_type[size_+1]),size(size_){
			for(int i=0;i<=size;i++){
				sum[i]=data[i]=zero;
			}
		}//多开一位，而且不能访问数组的第0位，想必大家都懂
		/*关于安全使用的部分，既然是在洛谷的机子上跑，而且调用都是自己，这里就注释掉了
		tree_array(const tree_array &arr):
		data(new data_type[arr.size+1]),sum(new data_type[arr.size+1]),size(arr.size){
			for(int i=0;i<=size;i++){
				data[i]=arr.data[i];
				sum[i]=arr.sum[i];
			}
		}
		tree_array operator=(const tree_array &arr){
			delete data,sum;
			data=new data_type[arr.size+1];
			sum=new data_type[arr.size+1];
			size=arr.size;
			for(int i=0;i<=size;i++){
				data[i]=arr.data[i];
				sum[i]=arr.sum[i];
			}
		}
		~tree_array(){
			delete data,sum;
		}
		*/
		iterator operator[](int n){//返回一个此数组第n位的迭代器 
			return iterator(this,n);
		}
		/*想要cin输入的就重载这个运算符 
		friend std::istream &operator>>(std::istream &in,iterator it){
			data_type data_;
			in>>data_;
			it.operator=(data_);
			return in;
		}
		*/
};
int main(){
	int n,m;
	int p1,p2,p3;
	scanf("%d%d",&n,&m);
	tree_array<long long>a(n,0);
	for(int i=1;i<=n;i++){
		scanf("%d",&p1);//并不能直接scanf，但是可以重载流输入 
		a[i]=p1;
/*
a[i]返回了一个迭代器对象
由于迭代器重载了赋值运算符
就可以直接完成树状数组的修改
*/ 
	}
	for(int i=0;i<m;i++){
		scanf("%d%d%d",&p1,&p2,&p3);
		if(p1==1){
			a[p2]+=p3;
		}else{
			printf("%lld\n",a[p2][p3]);
/*
原理和上面类似，利用了迭代器的[]运算符,完成区间查询
也可以用(long long)a[p2]的方式单点查询 
比如

printf("%lld",(long long)a[p2]);
long long l=a[p2]; 
*/ 
		}
	}
	return 0;
}
```
有木有感觉这才是一个数组该有的写法。有关const的写法还没有完善（毕竟是一两个小时搞出来的半成品），有兴趣的朋友可以自己写一下完整的封装类。

---

## 作者：Cekavis (赞：15)

看到没有写cdq分治的题解。

~~cdq分治就不过多介绍了~~

1.把初值变成修改。

2.把修改加进去

3.把询问拆成两个前缀形式加进去

按照操作的位置排序。

然后处理所有操作的前一半的修改对后一半的查询的贡献。

然后分治前一半、后一半。

~~这不是归并排序？~~

```cpp
#include<cstdio>
#include<algorithm>
#include<ctype.h>
#include<string.h>
using namespace std;
#define ll long long
#define rt register int
#define reep(i,x,y) for(rt i=(x);i<(y);++i)
#define per(i,x,y) for(rt i=(x);i>=(y);--i)
#define rep(i,x,y) for(rt i=(x);i<=(y);++i)
#define travel(i,x) for(rt i=h[x];i;i=pre[i])
namespace fast_IO {
    inline char read() {
        //return getchar();
        static const int IN_LEN = 1000000;
        static char buf[IN_LEN], *s, *t;
        if (s == t) {
            t = (s = buf) + fread(buf, 1, IN_LEN, stdin);
            if (s == t) return -1;
        }
        return *s++;
    }
    template<class T>
    inline void read(T &x) {
        static bool iosig;
        static char c;
        for (iosig = false, c = read(); !isdigit(c); c = read()) {
            if (c == '-') iosig = true;
            if (c == -1) return;
        }
        for (x = 0; isdigit(c); c = read())
            x = ((x + (x << 2)) << 1) + (c ^ '0');
        if (iosig) x = -x;
    }
    const int OUT_LEN = 10000000;
    char obuf[OUT_LEN], *ooh = obuf;
    inline void print(char c) {
        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;
        *ooh++ = c;
    }
    template<class T>
    inline void print(T x) {
        static int buf[30], cnt;
        if (x == 0) {
            print('0');
        }
        else {
            if (x < 0) print('-'), x = -x;
            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;
            while (cnt) print((char)buf[cnt--]);
        }
    }
    inline void flush() {
        fwrite(obuf, 1, ooh - obuf, stdout);
    }
}
using namespace fast_IO;
const int N = 500005, M = 1500005;
int n, cnt, m, totans, ans[M];
struct querys{
    int x, pos, val, id;
    inline querys(){}
    inline querys(int x_, int pos_, int val_, int id_){
        x=x_, pos=pos_, val=val_, id=id_;
    }
    inline bool operator <(const querys &rhs)const{
        return x<rhs.x || x==rhs.x && pos<rhs.pos;
    }
}q[M], tmp[M];
void cdq(int l, int r){
    if(l==r) return;
    int mid=l+r>>1, tot=0;
    rep(i, l, r) if(!q[i].pos && q[i].id<=mid) tot+=q[i].val; else if(q[i].pos && q[i].id>mid) ans[q[i].pos]+=q[i].val*tot;
    int h1=l, h2=mid+1;
    rep(i, l, r) if(q[i].id<=mid) tmp[h1++]=q[i]; else tmp[h2++]=q[i];
    rep(i, l, r) q[i]=tmp[i];
    cdq(l, mid), cdq(mid+1, r);
}
int main() {
    read(n), read(m);
    rep(i, 1, n){
        static int tmp;
        read(tmp);
        ++cnt,     q[cnt]=querys(i, 0, tmp, cnt); 
    }
    rep(i, 1, m){
        static int opt, x, y;
        read(opt), read(x), read(y);
        if(opt==1) ++cnt, q[cnt]=querys(x, 0, y, cnt);
        else
            ++cnt, q[cnt]=querys(x-1, ++totans, -1, cnt),
            ++cnt, q[cnt]=querys(y, totans, 1, cnt);
    }
    sort(q+1, q+cnt+1);
    cdq(1, cnt);
    rep(i, 1, totans) print(ans[i]), print('\n');
    flush();
    return 0;
}
```

---

## 作者：yijan (赞：13)

~~作为刚学oi的萌新~~  
写一篇较为详细的$cdq$分治题解（前面写过但是写的不是很详细啊）。
有问题请指出！

### 1. 预处理

首先把询问离线。（强制在线？出门右转~~树套树~~树状数组

对于一个查询区间，为了方便计算贡献考虑拆成两个。查询$[l,r]$等价于查询$[1,l-1],[1,r]$ 。然后我们就可以把所有的查询和修改存下来啦
```cpp
struct query{ll x,c,opt,cnt,ct;}q[MAXN*3],t[MAXN*3];
```
x：表示这个操作的位置。显然，前面把一个询问拆成两个后，每个询问只需要一个数字表示其操作位置

opt 表示这是个查询还是个修改

当opt == 1  则这是个修改操作，其中c存修改的值

当opt == 0  则这是个查询操作，如果c=-1 则表示查询后的值应该乘以-1.比如说对于查询$[l,r]$显然查询$[1,l-1]$后得到的值应当乘以-1再加到这个查询最后的ans里面。而对于$[1,r]$显然不用乘直接放进去。

cnt：这是第几个**操作** ，每进行一次查询或修改都++

ct: 这是第几个**询问** ， 一个询问拆成了两个query，这两个点ct必须相等，用以统计答案。

### 怎么分治？

现在我们就又了很多很多很多很多很多很多很多的操作了,但是怎么解决这些操作？

我们知道每一次单点修改会对所有$cnt$在其之后，且$x$在其之后的询问产生贡献。

那么考虑这样分治：

首先把所有操作**按照x进行排序**，（x位置一样则按照先修改，再查询的顺序排）

然后**对询问分治**。

现在问题是： 对于l到r的所有询问，已知关于x排序了的序列，然后考虑所有$cnt<=m(=l+r>>1)$左边（即在中点左边）的**修改**操作，对于所有$cnt>m$（即在中点右边）的询问的影响。

### 注意:这里只考虑**左边的修改**对于**右边的查询**的影响

然后考虑合并，直接从l到r，如果$cnt<=m$ 则放在左半边，如果$cnt>m$则放在右半边。由于原序列关于x有序，这样选出来的两半的序列也一定关于x有序（很显然吧，是按照从左到右选的）

然后问题转化成了两个完全相同的子问题：关于x有序，考虑贡献。

贡献算完了的过程就很无脑了，预处理ans为询问区间的和（利用前缀和）然后ans+贡献就好了。

这个的复杂度分析很显然了$O(nlogn)$

### 有什么用？

#### “这题显然树状数组就好了啊QAQ 怕不是想变成下一个a+b”

= =然而并不是。cdq分治多数时候并不是在这种时候用。

而是在很多很麻烦的时候顶替一些高级数据结构。（~~强制在线请出门右转~~

经常出现很多树套树的题目可以用cdq分治套一层树状数组过。而且有很多优点：常数小，编码复杂度小。。

下面推荐几个cdq的题QAQ 这些你就不能一个树状数组压过去了

~~当然你说你可以树状数组套树状数组那我也没办法了~~

[BZOJ1176 Mokia](https://www.lydsy.com/JudgeOnline/problem.php?id=1176)  
[luogu3810 三维偏序](https://www.luogu.org/problemnew/show/P3810)

还是给个代码吧，都说不给代码的题解不是好题解。。  
略微压行很简短
```cpp
/*Heroes Never Die!*/
#include "cstdio"
#include "algorithm"
using namespace std;
typedef long long ll;
#define MAXN 500006
struct query{ll x,c,opt,cnt,ct;}q[MAXN*3],t[MAXN*3];
ll n,m,A[MAXN],cnt,ct,ans[MAXN],S[MAXN];
bool cmp(query a,query b){ return a.x != b.x ? a.x < b.x : a.opt > b.opt; }
void cdq(ll l,ll r);
int main(){
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=n;++i) scanf("%lld",&A[i]),S[i] = S[i-1] + A[i];
    for(ll i=1,opt,x,x2,c;i<=m;++i){
        scanf("%lld",&opt);
        if(opt == 1) ++cnt,scanf("%lld%lld",&q[cnt].x,&q[cnt].c),q[cnt].opt=1,q[cnt].cnt=cnt;
        else scanf("%lld%lld",&x,&x2),++ct,++cnt,q[cnt] = {x-1,-1,0,cnt,ct},++cnt,q[cnt] = {x2,1,0,cnt,ct},ans[ct] = S[x2] - S[x-1];
    }
    sort(q+1,q+1+cnt,cmp);
    cdq(1,cnt);
    for(ll i=1;i<=ct;++i) printf("%lld\n",ans[i]);
}
void cdq(ll l,ll r){
    if(l == r) return;
    ll m = l + r >> 1,s = 0;
    for(ll i=l;i<=r;++i)
        if(q[i].cnt <= m && q[i].opt) s += q[i].c;
        else if(q[i].cnt > m && !q[i].opt) ans[q[i].ct] += s * q[i].c;
    ll l1 = l , l2 = m + 1;
    for(ll i=l;i<=r;++i) if(q[i].cnt <= m) t[l1++] = q[i]; else t[l2++] = q[i];
    for(ll i=l;i<=r;++i) q[i] = t[i];
    cdq(l,m),cdq(m+1,r);
}
```

广告：blog：[yihan.ac.cn](yihan.ac.cn)欢迎互换友联

---

## 作者：yizimi远欣 (赞：11)

### 主要思路：zkw线段树
最简单的zkw线段树就十分适合这道题，为什么用zkw线段树，可以看一下以下精简代码：

我们只需要用到单点修改，区间查询就好了。

```cpp
#include<cstdio>
#define go(i,j,n,k) for(int i=j;i<=n;i+=k)
#define fo(i,j,n,k) for(int i=j;i>=n;i-=k)
#define mn 500010
#define ll long long
inline ll read(){int x=0,f=1;char ch=getchar();while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
				while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
ll z[mn << 2], M, n, m;
inline void update(int rt){z[rt] = z[rt<<1] + z[rt<<1|1];}
inline void build(){for(M=1;M<n+2;M<<=1);go(i,M+1,M+n,1)z[i]=read();fo(i,M,1,1) update(i);}
inline void modify(int now,ll v){for(z[now+=M]+=v,now>>=1;now;now>>=1)update(now);}
inline ll query(int l,int r){int ans=0;for(--l+=M,++r+=M;l^r^1;l>>=1,r>>=1){if(~l&1)ans+=z[l^1];if(r&1)ans+=z[r^1];}return ans;}
int main(){
	n=read(),m=read();build();
	go(i,1,m,1){
		int s=read(),x=read(),y=read();
		if(s==1)modify(x,y);else printf("%lld\n",query(x,y));
	}
}
```

不用数，只有19行（不强制换行），，，

为什么这么简单？实测树状数组1004ms，而zkw线段树只有562ms：

[text:lowbit](https://www.luogu.org/record/show?rid=8721834)

[text:zkw](https://www.luogu.org/record/show?rid=11376007)

---

## 作者：jins3599 (赞：10)

最近这几天被树状数组折磨的不轻，发博客来帮自己理顺一下思路。


## 一.引入。

## 问题1：给你一个数列，如何完成快速的单点修改与区间查询？（例题luoguP3374）

#### 1.单点修改指的是：把某个点的值进行修改，且仅涉及这一个点的值的变化。

#### 2.而区间查询指的是查询区间值的和。



好了，以上，我们就顺利的把题目读懂了。一般来说，我们会有以下的思路。

#### （1）暴力相加法。

直接开一个数组，每次单点修改的操作$ O(1)$ 进行修改，查询时暴力相加。
    
我们观察到，区间查询的复杂度为$O(n)$，单点修改的复杂度为$O(1)$.
    
显然，如果查询次数很多，会超时。

#### （2）前缀和数组。

众所周知，前缀和的维护为$O(n)$,查询为$O(1)$，但是如果要是修改，就需要$O(n)$重新维护，有些情况还是会超时。

因此，两种暴力算法都各有利弊，那么我们如何中和一下他们，得到一个更加快捷的方法呢？

树状数组就因此诞生了。
## 二.树状数组入门。

#### 什么是树状数组？

顾名思异，树状数组是以树形结构为思想的一类数据结构，并不是树形结构！！，和线段树相似，不过空间比线段树更优。

树状数组比前面的两种暴力算法之所以更优，是因为树状数组的查询修改操作均为$O(logn)$。

这样看来，树状数组的确比之前两种方法快上不少。

（请自行百度树状数组图片，蒟蒻不会插图。。）

#### 1.树状数组的构建

我们假设a[]为原数组，c[]为树状数组，树状数组的大致对应关系如下

$c[1]=a[1];$

$c[2]=a[1]+a[2];$

$c[3]=a[3];$

$c[4]=a[1]+a[2]+a[3]+a[4];$

$......$

树状数组与原数组宏观之间的关系很难说，我们来观察一下他们二进制下的对应关系。

$c[0001]=a[0001]$

$c[0010]=a[0001]+a[0010]$

$c[0011]=a[0011]$

$c[0100]=a[0001]+a[0010]+a[0011]+a[0100]$

$......$

首先，先扔上一波定义：

对于树状数组的每一个c[i]，其实际意义为：

> 算上其本身的讯息，总共存储了$2^k$个元素的信息，
> 其中k表示i在二进制下，末尾零的个数.


看不懂？再多读几遍试试？

还是看不懂？

没关系，下面我们~~简单的描述一下~~。

#### 由于存储的信息数量为二进制下最后一个1所在位置决定，
#### 我们可以假设最后一个1在倒数第$i$个位置

#### 由此，我们可以得到，对于树状数组中$C[n]$,所存储的区间信息为：

### $C[n] = a[n-2^i] +a[n-2^i+1]+......+a[n].$

### 即$C[n] = \sum_{k=n-2^i}^n{a[k]}.$

下面我们举几个简单的例子便于理解。

如$C[4]=C[0100]$

由于最后一个1在第三位，所以说该数组中存储$2^2=4$个数。

且存储的区间为$a[1]+a[2]+a[3]+a[4]$

又比如$C[9]=C[1001]$

最后一个1在最后一位，所以该数组存储$2^0=1$个数。

即$C[9] = a[9].$

理解了这个，树状数组应该就很简单了。

不过，我们如何获得最后一位1所在位置的值呢？

这早已经被大牛们所研究出来了，即

lowbit(x)=x&-x.

这种方法很玄学，但是可以证明，有兴趣的可以自行百度。

```cpp
//写法1
inline int lowbit (int x)
{
	return x&(-x);
} 
这里，返回的就是x对应二进制中最后的1的值。

//写法2

inline int lowbit(int x)
{
	return (x^(x-1))&x;
}
```
两种写法没有本质的区别，个人比较喜欢写第一种（只是因为好记..

掌握了树状数组与原数组的对应关系，下面我们要对树状数组进行修改和查询了。

单点修改函数如下:
由于我们要把所有包括 x 的树状数组进行修改，因此我们要每次向上找一个lowbit，找到最后一位n的时候停止。

```cpp
inline void add(int x,int k)
{
	for(int i=x;i<=n;i+=lowbit(i))
		tree[i]+=k;
}

```

区间查询函数如下：

和单点修改类似的，我们需要向下找，把这个区间一点点的加起来。

```cpp
inline int sum(int x)
{
	int ans=0;
	for(int i=x;i;i-=lowbit(i))
	{
		ans+=tree[i]; 
	}
	return ans;
}

```
完整代码如下
```
#include <bits/stdc++.h>
using namespace std;
int tree[3000000],n,m;

inline int lowbit(int x)
{
	return x&(-x);
}

inline void add(int x,int y)
{
	for(int i=x;i<=n;i+=lowbit(i))
	{
		tree[i]+=y;
	}
}

inline int sum(int x)
{
	if(x==0) return 0;
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i))
	{
		ans+=tree[i]; 
	}
	return ans;
}

int main ()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		int a;
		scanf("%d",&a);
		add(i,a);
	}
	
	for(int i=1;i<=m;++i)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		if(x==1)
		{
			add(y,z); 
		}
		if(x==2)
		{
			int end=sum(z)-sum(y-1);
			printf("%d\n",end);
		}
		 
	}
	return 0;
 } 
 ```
 
 总之树状数组是一个很有用的数据结构，常数很小，不过有的时候适用的范围可能不是很广。
 


---

## 作者：dl__hh6 (赞：5)

 **~~~好像没人发pascal的题解~~~~**

1、定义
树状数组(Binary Indexed Tree(B.I.T), Fenwick 、、
Tree)、是一个查询和修改复杂度都为log(n)的数据结构。
主、要用于查询任意两位之间的所有元素之和，但是每次只能
修改一个元素的值；经过简单修改可以在log(n)的复杂度下
进行范围修改。


假设A[]数组为存储原来的值的数组，C[]为树状数组。我们
定义：C[i] = A[i - 2^k + 1] + ..... + A[i]  其中k
为i用二进制表示时的末尾0的个数。例如：i= 10100,则k = 
2，i = 11000，则k = 3；C[i] 它里面包含了2^k个A[]元
素，这2^k个元素是从A[i]往后一直递减的2^k个元素。Cn = 
A(n – 2^k + 1) + ... + An。K的计算为2^k=lowbit（x 
and (-x)）。


当然，利用位运算，我们可以直接计算出2^k=i&(i^(i-1)) ）同时，我们也发
现，这个k就是该节点在树
中的高度，因而这个树的高度不会超过logn。
所以,当我们修改A[i]的值时，可以从C[i]往根节点一路上
溯，调整这条路上的所有C[]即可，这个操作的复杂度在最坏
情况下就是树的高度即O(logn)。另外，对于求数列的前n项
和，只需找到n以前的所有最大子树，把其根节点的C加起来即
可。
不难发现，这些子树的数目是n在二进制时1的个数，或
者说是把n展开成2的幂方和时的项数, 对于数组元素x，x的
父亲是x+lowbit(x)。 x的子树是(x-lowbit(x)。


2、算法描述
当想要查询一个SUM(n)(求a[n]的和），可以依据如下算法即
可：
step1:　令sum = 0，转第二步；
step2:　假如n <= 0，算法结束，返回sum值，否则sum = sum + Cn，转第三、
步；
step3: 令n = n – lowbit(n)，转第二步。可以看出，这个算法就是将这一个个
区间的和全部加起来，为什么是效率是log(n)的呢？以下给出证明： n = n–
lowbit(n)这一步实际上等价于将n的二进制的最后一个1减去。而n的二进制里最
多有log(n)个1，所以查询效率是log(n)的。那么修改呢，修改一个节点，必须修
改其所有祖先，最坏情况下为修改第一个元素，最多有log(n)的祖先。所以修改
算法如下（给某个结点i加上x）：

step1: 当i > n时，算法结束，否则转第二步；
step2: Ci = Ci + x， i = i + lowbit(i)转第一步。i = i +lowbit(i)这
个过程实际上也只是一个把末尾1补为的过程。
对于数组求和来说树状数组简直太快了!
 
 ~~话不多说~~
 
 上代码AC：
 ```pascal
var 
  i,n,m,tt,x,y:longint;
  c:array[0..500010] of longint;
  function lowbit(x:longint):longint;
begin
  exit(x and (-x));
end;
procedure add(x,v:longint);
begin
  while (x<=n) do
   begin
     inc(c[x],v);
     inc(x,lowbit(x));
   end;
end;

function sum(x:longint):longint;
var 
ans:longint;
begin
  ans:=0;
  while (x>0) do
   begin
     inc(ans,c[x]);
     dec(x,lowbit(x));
   end;
   exit(ans)；
end;
//主程序
begin
  read(n,m);
   for i:=1 to n do
   begin
     read(x);
      add(i,x);
   end;
   for i:=1 to m do
begin
    read(tt,x,y);
    if (tt=1) then add(x,y) else writeln(sum(y)-sum(x-1));
 end;
end.
```
~~请管理员大人手下留情~~

---

## 作者：zsj123 (赞：4)

#既然是模板，那么就得把相关操作列清楚。

一切按照树状数组的常用套路走就行，具体详见代码


code：









```cpp
//树状数组求和,变值,加值
//Time:2017/11/1
const maxn=500005;
var a,c:array[1..maxn] of longint;
    n,m,i,tot,l,r:longint;
function Lowbit(x:longint):longint;
begin
  exit(x and (-x));
end;
Procedure Build(x,w:longint);  //建树(将w放入x位置)
begin
  while x<=n do
   begin
    inc(c[x],w);
    inc(x,lowbit(x));
   end;
end;
Procedure Sum(i:longint);  //计算1-i的总和
begin
  if i<=0 then exit
   else
    begin
     inc(tot,c[i]);
     Sum(i-lowbit(i));
    end;
end;
Procedure Add(i,x:longint); //将第i个数+x
begin
  if i>n then exit
   else
    begin
     c[i]:=c[i]+x;
     Add(i+lowbit(i),x);
    end;
end;
Function SumLR(l,r:longint):longint; //获得区间[l,r]的和
var temp1,temp2:longint;
begin
  tot:=0; Sum(L-1); temp1:=tot;
  tot:=0; Sum(R);   temp2:=tot;
  exit(temp2-temp1);
end;
Procedure Change(i,x:longint); //将第i个数改变为x
begin
  if i>n then exit
   else 
    begin
     c[i]:=c[i]+x-a[i];
     Change(i+lowbit(i),x);
    end;
end;
var v,s1,s2:longint;
begin
  readln(n,m);
  for i:=1 to n do 
   begin
    read(a[i]);
    Build(i,a[i]);
   end;
  readln;
  for i:=1 to m do
   begin
    readln(v,s1,s2);
    if v=1 then Add(s1,s2);
    if v=2 then writeln(SumLR(s1,s2));
   end;
end.
```

---

## 作者：Parabola (赞：4)

为什么泥萌欺负$cdq$分治，呜呜呜

泥萌都不写$cdq$！

这么好的二维偏序模板题怎么能没有$cdq$呢，是时候来篇搞搞了

----

我们都知道，$cdq$分治在处理操作题（非模板偏序题）是基于时间的分治算法，换句话来说，我们的第一维--时间已经有序

那么合并的时候就只需要按照修改位置合并就好了

然后把询问操作拆成两个前缀查询，$S[r] - S[l -1]$

至于具体实现，我们可以这么搞


```
struct Node{
	int opt , id , v;
	Node(int opt = 0 , id = 0 , v = 0) {}
};
```

$opt = 1$时，$id$代表修改的位置，v代表加上的值

$opt = 2$时，$id$代表遇上了一个左端点，也就是$L - 1$，而$v$代表它是第几个询问

$opt = 3$时，$id$代表遇上了一个右端点，也就是$R$，而$v$代表它是第几个询问

---

那么我们如果按照$id$合并，对于每个点，它前面的所有点都应当是满足时间轴上在它前面，操作的位置也在它前面。所以对于点$i$，如果它是$1$操作，那么它后面的所有操作的答案都应当加上$v$。$2$，$3$操作泥萌可以自己想想。因为是最重要的。

想完再看下去哦！

$2$操作的话，我们就把第$v$个询问的答案减去它前面的增加

$3$操作的话，我们就把第$v$个询问的答案加上他前面的增加

---

$Code$

```
#include<iostream>
#include<cstdio>
#define mid ((l + r) >> 1)
using namespace std;

const int MAXN = 5e5 + 5;

struct Node{
	int opt , id , v;
	Node(int opt = 0 , int id = 0 , int v = 0) : opt(opt) , id(id) , v(v) {}
	#define opt(i) A[i].opt
	#define id(i) A[i].id
	#define v(i) A[i].v
};

int n , m , cnt , qry , ans[MAXN];
Node A[MAXN << 1] , tmp[MAXN << 1];

inline void insert(int opt , int id , int v) {A[++cnt] = Node(opt , id , v);}

void cdq(int l , int r) {
	if(l >= r) return ;
	cdq(l , mid); cdq(mid + 1 , r);
	int pos1 = l , pos2 = mid + 1 , sum = 0;
	for(int tot = l ; tot <= r ; ++tot) {
		//pos1 入队 
		if((id(pos1) <= id(pos2) && pos1 <= mid) || pos2 > r) {
			if(opt(pos1) == 1) //那么后面的所有询问操作都应该受到它的影响 
				sum += v(pos1);
			//至于其它的opt，证明它是询问，一个询问对后面应该没有任何影响 
			tmp[tot] = A[pos1++];
		}
		//pos2 入队  
		else {
			if(opt(pos2) == 2)//它入队了，证明后面的无论所有东西都对我没有任何关系了，因为id一定比我小，时间轴也在我后面，我肯定不会被那些修改而影响 
				ans[v(pos2)] -= sum;
			else if(opt(pos2) == 3)//同上
				ans[v(pos2)] += sum; 
			//至于其它的opt，证明它是修改，那么修改对它前面 
			tmp[tot] = A[pos2++];
		}
 	}
 	for(int i = l ; i <= r ; ++i) A[i] = tmp[i];
}

int main() {
	scanf("%d %d" , &n , &m);
	for(int i = 1 , x ; i <= n ; ++i) {
		scanf("%d" , &x);
		insert(1 , i , x);
	}
	for(int i = 1 , opt , x , k ; i <= m ; ++i) {
		scanf("%d %d %d" , &opt , &x , &k);
		if(opt == 1) insert(1 , x , k);
		else {
			insert(2 , x - 1 , ++qry);
			insert(3 , k , qry);
		}	
	}
	cdq(1 , cnt);
	for(int i = 1 ; i <= qry ; ++i) printf("%d\n" , ans[i]);
	return 0;
} 
```
---

最后说一句，左闭右闭大法好！

---

## 作者：ACgod (赞：4)

~~对于这种明显就是【树状数组 or 线段树】的题目，当然就要用分块搞搞了~~，
没想到，分块真的水过去了。【\滑稽】



------------

[点击这里，获得更好的观赏体验](https://www.luogu.org/blog/113613/ti-xie-p3374-shu-zhuang-shuo-zu-yi)

### 0、分块用途

分块的用途很广泛，一般情况下，只要是线段树或树状数组的题目都可以用分块试试看，~~但很容易超时，慎用！！！~~还有一些线段树，树状数组难以更新的题目（例如区间众数），用分块也可以很好的解决。当然，分块一定要慎用！
我只有在那些复杂的数据结构调不出来或时间不够时才会打分块。

### 1、Lv.1 单点修改，区间查询

这部分十分简单，对于单点修改，就跟暴力没啥两样，直接改就行了。看代码
```cpp
void change(int x,int k)
{
  int p=pos[x];//pos储存的是这个节点储存在pos[x]这个块中
  sum[p]+=k;//维护区间加和
  a[x]+=k;//暴力修改
}
```
看到没有，真的只要$O(1)$！！！

那么接下来是区间修改了。对于分块，有一点思想非常重要，那就是**“大段维护，小段暴力”**。任何分块算法都是满足上述思想的。

对于查询区间$(l,r)$，有以下几种情况：

1、$pos[l]==pos[r]$ 也就是说$l,r$在同一个块内，此时我们就直接暴力求解$O(l-r+1)$算出答案。

2、$pos[l]!=pos[r]$ 即$l,r$不在同一个块内。那我们直接累加中间满足整块的区间，用维护好的区间和累加起来。对于左右两边不完整的块，我们直接暴力求解。
```cpp
int ask(int l,int r)
{
  int p=pos[l],q=pos[r];
  int s=0;
  if(p==q)//情况1
  {
  	for(int i=l;i<=r;i++)
  	{
  		s+=a[i];//暴力
  	}
  	return s;
  }
  else//情况2
  {
  	for(int i=p+1;i<=q-1;i++)//大段维护
  	{
  			s+=sum[i];
  	}
  	for(int i=l;i<=R[p];i++)//小段暴力
  	{
  			s+=a[i];
  	}
  	for(int i=L[q];i<=r;i++)
  	{
  			s+=a[i];
  	}
	return s;
  }
}
```
查询的时间复杂度为$O(\sqrt n)$,因为每次查询最多就是用到所有的块，也就是$\sqrt n$个块，所以是这样。但相比$log_2 n$来说，还是稍微逊色的。

### 3、Lv.2 区间修改、区间询问

类似于线段树**“懒标记”**的思想，我们分块也会专门用一个数组，来记录**整个区间一起加的值**。注意！是整个区间一起加的值，如果是修改时左右两边不完整的块时，我们还是暴力修改。
```cpp
void change(int l,int r,long long d)
{
	int p=pos[l],q=pos[r];
	if(p==q){
		for(int i=l;i<=r;i++) a[i]+=d;
		sum[p]+=d*(r-l+1);//维护区间和
	}
	else{
		for(int i=p+1;i<=q-1;i++)//大段暴力
		{
			add[i]+=d;//维护区间加值
		}
		for(int i=l;i<=R[p];i++)//小段暴力
		{
			a[i]+=d;
		}
		sum[p]+=d*(R[p]-l+1);
		for(int i=L[q];i<=r;i++) a[i]+=d;
		
		sum[q]+=d*(r-L[q]+1);
	}
}
```
这样的时间复杂度和区间修改是一样的，证明也差不多，都是$O(\sqrt n)$。

区间查询就和之前差不多了。
```cpp
long long ask(int l,int r)
{
	int p=pos[l],q=pos[r];
	long long ans=0;
	if(p==q) {
		for(int i=l;i<=r;i++) ans+=a[i];
		ans+=add[p]*(r-l+1);//注意要加app
	}
	else{
		for(int i=p+1;i<=q-1;i++)
		{
			ans+=sum[i]+add[i]*(R[i]-L[i]+1);
		}
		for(int i=l;i<=R[p];i++)
		{
			ans+=a[i];
		}
		ans+=add[p]*(R[p]-l+1);
		for(int i=L[q];i<=r;i++)
		{
			ans+=a[i];
		}
		ans+=add[q]*(r-L[q]+1);
	}
	return ans;
}
```

### 3、初始化

初始化就是要给每一个块设置左右边界，每一个点设置它属于哪一个块，并且弄好区间加和的初始值就OK了！

```cpp
void build()
{
  int t=sqrt(n);//共有t个块
  for(int i=1;i<=t;i++)//设置左右边界
  {
	  L[i]=(i-1)*t+1;
	  R[i]=i*t;
  }
  if(R[t]<=n)//特盘最后一个快（可能不完整）
  {
	  t++;
	  L[t]=R[t-1]+1;
	  R[t]=n;
  }
  for(int i=1;i<=t;i++)//初始化区间加值和这个点属于那个块
  {
	 for(int j=L[i];j<=R[i];j++)
	 {
	  	pos[j]=i;
	  	sum[i]+=a[j];
	  }
  }
}
```
初始化的时间复杂度**应该**是$O(n)$。

那么总时间复杂度就是$O(n\sqrt{n})$。

### 4、分块，树状数组，线段树的比较
##### 1、时间复杂度
树状数组<=线段树（看常数，一般线段树比较大）<分块
##### 2、调试难度（个人观点）
分块<树状数组<线段树
##### 3、可扩展性（个人观点）
分块>=线段树>树状数组
##### 4、码长
线段树>分块>树状数组

### 5、分块的典型例题
1、P4168 [蒲公英](https://www.luogu.org/problemnew/show/P4168)
简要概括:离散化+区间众数

2、其他线段树，树状数组的模板题。(P3372~P3374，P3368)

### 6、本题代码
解释分清楚了，~~不用再注释了吧~~。
```
#include <bits/stdc++.h>
using namespace std;
int n,m,a[10000001],L[10000001],R[10000001],pos[10000001],sum[10000001];
inline void read(int &x){
    x=0; bool z=0; char c=getchar();
    while (!isdigit(c)){
        if (c=='-') z=1;
        c=getchar();
    }
    while (isdigit(c)) x=x*10+c-'0',c=getchar();
    if (z) x=-x;
}
inline void write(int x){
    int y=10;
    if (x<0) putchar('-'),x=-x;
    while (x>=y) y*=10;
    y/=10;
    while (y) putchar(x/y%10+'0'),y/=10;
    putchar('\n');
}
namespace ILoveKKK{
  void build()
  {
	  int t=sqrt(n);
	  for(int i=1;i<=t;i++)
	  {
	  	L[i]=(i-1)*t+1;
	  	R[i]=i*t;
	  }
	  if(R[t]<=n)
	  {
	  	t++;
		L[t]=R[t-1]+1;
	  	R[t]=n;
	  }
	  for(int i=1;i<=t;i++)
	  {
	  	for(int j=L[i];j<=R[i];j++)
	  	{
	  		pos[j]=i;
	  		sum[i]+=a[j];
	  	}
	  }
  }
  void change(int x,int k)
  {
  	int p=pos[x];
  	sum[p]+=k;
  	a[x]+=k;
  }
  int ask(int l,int r)
  {
  	int p=pos[l],q=pos[r];
  	int s=0;
  	if(p==q)
  	{
  		for(int i=l;i<=r;i++)
  		{
  			s+=a[i];
  		}
  		return s;
  	}
  	else{
  		for(int i=p+1;i<=q-1;i++)
  		{
  			s+=sum[i];
  		}
  		for(int i=l;i<=R[p];i++)
  		{
  			s+=a[i];
  		}
  		for(int i=L[q];i<=r;i++)
  		{
  			s+=a[i];
  		}
		return s;
  	}
  	
  }
}
int main()
{
	read(n);read(m);
	for(int i=1;i<=n;i++)
	{
		read(a[i]);
	}
	ILoveKKK::build();
	for(int i=1;i<=m;i++)
	{
		int xx;
		read(xx);
		if(xx==1)
		{
			int aa,bb;
			read(aa);read(bb);
			ILoveKKK::change(aa,bb);
		}
		else{
			int ll,rr;
			read(ll);read(rr);
			write(ILoveKKK::ask(ll,rr));
		}
	}
}
```
最后提醒大家:**分块虽好，但使用需谨慎**！！！

---

## 作者：hfee (赞：3)

### 引入
**树状数组是什么？**

树状数组是一个查询和修改复杂度都为log(n)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值;经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。（by 百度百科）

简单点说，就是一个可以很快区间修改，单点修改，区间查询，单点查询的数据结构

题外话：其实线段树也可以做到这一点，并且比树状数组可实现的东西多得多，但是因为树状数组简单好写，且效率还要高些，所以在这题我们写树状数组

### 怎么做？

遥想我当年一道黄题没做过就点开了这题，欸？这么简单？难道人生第一道黄题就是这道了吗？然后我就交了一个这样的程序：
```
for(int j=l;j<=r;j++) a[j]+=k;
```
欸，怎么不对？点开题解两分钟后，我默默地关掉了页面...

扯远了，讲正经的,其实树状数组跟树的关系并不太大，当n=8时，它是下面这个样子的：
(A是输入的数组，C是我们的树状数组）
![](http://images.cnblogs.com/cnblogs_com/wxl-Ezio/1173002/o_QQ%e6%88%aa%e5%9b%be20180412203826.png)
其中

$C[1]=A[1]$

$C[2]=A[1]+A[2]$

$C[3]=A[3]$

$C[4]=A[1]+A[2]+A[3]+A[4]$

$C[5]=A[5]$

$C[6]=A[5]+A[6]$

$C[7]=A[7]$

$C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]$

以此类推

那么这颗树有什么用呢？

假设我们要给$A[1]$加上1，哪些数值会被改变？

$C[1],C[2],C[4],C[8],C[16]...$

$A[2]$呢？

$C[2],C[4],C[8],C[16]$

$A[3]$

$C[3],C[4],C[8],C[16]$

$A[5]$

$C[5],C[6],C[8],C[16]$

我相信你看出规律了，对吧（逃

好吧你只要知道，如果给$A[I]+K$，设$I$二进制最后一位$1$所在的位置是$q$,那么$C[I]$和$C[I+q]$都会$+K$就行了（$I$和$q$不断更新）

//这LATEX给我写吐了

比如说$A[5]$

$5$用二进制是$101$,所以$C[5]+=k$的值会使$C[101+1]$即$C[6]+=k$

而$C[6]+=k$时,因为$6=110$同时又会使$C[110+10]$即$C[8]+=k$

然后$C[8]+=k$又会使$C[16]+=k$

以此类推,直到要超过$n$

//呕~呸

### 代码实现

首先，**单点修改**怎么做？

介绍一个东西叫$lowbit$，这个东西是用来求出一个数转化为二进制后，最后一个1所在的位置

别想了，不是系统自带的函数，要自己写的

它的写法是

```
int lowbit(int k){
	return k&-k;
}
```
神奇吗？为什么呢？首先，&符号是与，-k因为补码的原因，从右向左遇到第一个1为止，这个1前面的位取反，首位不动

那么再利用与运算只取两个1的特性，我们就返回了
$2^p$(其中$p: k$ 的二进制表示数中， 右向左数第一个1的位置)

好了，那么怎么add呢？刚刚已经讲过了，如果给$A[I]+K$，设$I$二进制最后一位$1$所在的位置是$q$,那么$C[I]$和$C[I+q]$都会$+K$

代码就是
```
void add(int x,int q){
	while(x<=n){
		a[x]+=q;
		x+=lowbit(x);
	}
}
```
很简单，不是吗

那么第二个，**区间查询**呢？

我们用前缀和的思想，$x$到$y$的和，那么就将从$1$到$y$的和减去从$1$到$x-1$的和。

$1$到$x$的和求法是，将$x$转为$2$进制，然后一直减去$lowbit(x)$，直到$0$

```
int sum(int x){
	ans=0;
	while(x){
		ans+=a[x];
		x-=lowbit(x);
	}
	return ans;
}
```
好了，那么我们已经可以ACP3374了，但我们还要ACP3368

那么就要讲到差分

差分是什么？设数组$a=${$1,2,3,6,4$}，那么差分数组$b=${$1,1,1,3,-2$}，$b[i]=a[i]-a[i-1]$,那么很显然，求$a[i]$就是$b[1]+b[2]+...+b[i]$

假设我们位区间{2，4}都+3，那么数组$a$变为{$1,5,6,9,4$},$b$变为{$1,4,1,3,-5$}

看，只有$b[2]$和$b[5]$变了，这是因为2到4都加了2，那么差并不会变

所以怎样给区间加和呢？我们先把树状数组变为差分数组，然后再加时直接加b[x-1]和b[y]，这题就解决了

P3374 【模板】树状数组 1 代码
```
#include<bits/stdc++.h>
int n,m,a[500005],ans,w,xx,yy,zz; 
using namespace std;
int lowbit(int k){
	return k&-k;
}
void add(int x,int q){
	while(x<=n){
		a[x]+=q;
		x+=lowbit(x);
	}
}
int sum(int x){
	ans=0;
	while(x){
		ans+=a[x];
		x-=lowbit(x);
	}
	return ans;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w;
		add(i,w);
	}
	for(int i=1;i<=m;i++){
		cin>>xx>>yy>>zz;
		if(xx==1) add(yy,zz);
		else cout<<sum(zz)-sum(yy-1)<<endl;
	}
	return 0;
}

```
P3368 【模板】树状数组 2 代码
```
#include<bits/stdc++.h>
int n,m,a[500005],ans,w,xx,yy,zz,kk,lst; 
using namespace std;
int lowbit(int k){
	return k&-k;
}
void add(int x,int q){
	while(x<=n){
		a[x]+=q;
		x+=lowbit(x);
	}
}
int cx(int x){
	ans=0;
	while(x){
		ans+=a[x];
		x-=lowbit(x);
	}
	return ans;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w;
		add(i,w-lst);
		lst=w;
	}
	for(int i=1;i<=m;i++){
		cin>>xx;
		if(xx==1){
			cin>>yy>>zz>>kk;
			add(yy,kk);
			add(zz+1,-kk);
		} 
		else{
			cin>>yy;
			cout<<cx(yy)<<endl;
		} 
	}
	return 0;
}

```
写了非常久，甚至丧心病狂的把所有数字和字母都加了LATEX

我疯了，管理员过吧

---

## 作者：彼岸朱砂 (赞：3)

[P3374 【模板】树状数组 1](https://www.luogu.org/problemnew/show/P3374)

树状数组

树状数组，是一个查询和修改复杂度都为log(n)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值。

经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。

这种数据结构（算法）并没有C++和Java的库支持，需要自己手动实现。

在Competitive Programming的竞赛中被广泛的使用。树状数组和线段树很像，但能用树状数组解决的问题，基本上都能用线段树解决，而线段树能解决的树状数组不一定能解决。

相比较而言，树状数组效率要高很多。

树状数组概念

假设数组a[1..n]，那么查询a[1]+...+a[n]的时间是log级别的，而且是一个在线的数据结构，支持随时修改某个元素的值，复杂度也为log级别。

![](http://odwv9d2u8.bkt.clouddn.com/17-10-22/33371936.jpg)

令这棵树的结点编号为C1，C2...Cn。令每个结点的值为这棵树的值的总和，那么容易发现：

C1 = A1

C2 = A1 + A2

C3 = A3

C4 = A1 + A2 + A3 + A4

C5 = A5

C6 = A5 + A6

C7 = A7

C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8

...

C16 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10 + A11 + A12 + A13 + A14 + A15 + A16

这里有一个有趣的性质：

设节点编号为x，那么这个节点管辖的区间为2^k（其中k为x二进制末尾0的个数）个元素。因为这个区间最后一个元素必然为Ax，

所以很明显：Cn = A(n – 2^k + 1) + ... + An

算这个2^k有一个快捷的办法。

lowbit这个函数的功能就是求某一个数的二进制表示中最低的一位1，举个例子，x = 6，它的二进制为110，那么lowbit(x)就返回2，因为最后一位1表示2。

定义一个函数如下即可：
```
int lowbit(int x)
{
	return x&(x^(x-1));
}
```

利用机器补码特性，也可以写成
```
int lowbit(int x)
{
	return x&-x;
}
```

当想要查询一个SUM(n)(求a[n]的和），可以依据如下算法即可：

step1:　令sum = 0，转第二步；
step2:　假如n <= 0，算法结束，返回sum值，否则sum = sum + Cn，转第三步；
step3: 令n = n – lowbit(n)，转第二步。
可以看出，这个算法就是将这一个个区间的和全部加起来，为什么是效率是log(n)的呢？以下给出证明：

n = n – lowbit(n)这一步实际上等价于将n的二进制的最后一个1减去。而n的二进制里最多有log(n)个1，所以查询效率是log(n)的。

那么修改呢，修改一个节点，必须修改其所有祖先，最坏情况下为修改第一个元素，最多有log(n)的祖先。

所以修改算法如下（给某个结点i加上x）：

step1: 当i > n时，算法结束，否则转第二步；
step2: Ci = Ci + x， i = i + lowbit(i)转第一步。
i = i +lowbit(i)这个过程实际上也只是一个把末尾1补为0的过程。

对于数组求和来说树状数组简直太快了!
```
注：
求lowbit(x)的建议公式：

lowbit(x):=x&-x;
lowbit(x):=x&(x^(x-1));
lowbit(x)即为2^k的值。
```
充分性

很容易知道C8表示A1～A8的和，但是C6却是表示A5～A6的和，为什么会产生这样的区![]别的呢？或者说发明她的人为什么这样区别对待呢？

答案是，这样会使操作更简单！看到这相信有些人就有些感觉了，为什么复杂度被log了呢？

可以看到，C8可以看作A1～A8的左半边和+右半边和，而其中左半边和是确定的C4，右半边其实也是同样的规则把A5～A8一分为二……继续下去都是一分为二直到不能分树状数组巧妙地利用了二分，树状数组并不神秘，关键是巧妙！
(https://s1.ax1x.com/2018/08/09/PyKpDg.png)

```
#include<iostream>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<set>
#include<map>
#include<queue>
#include<stack>
#include<vector>
using namespace std; 
const int N = 5*1e5 +100;
int arr[N],c[N],n;

int lowbit(int x)
{
    return x & (-x);
}
void update(int id,int x)
{
    while(id<=n)
    {
        c[id]+=x;
        id += lowbit(id);
    }
}

int query(int id)
{
    int ans = 0;
    while(id!=0)
    {
        ans+=c[id];
        id-=lowbit(id);
    }
    return ans;
}

int main()
{
    int m;
    cin >> n >> m;
    for(int i=1;i<=n;i++)
    {
        cin>>arr[i];
        update(i,arr[i]);
    }
    while(m--)
    {
       int op,x,y;
       cin >> op >> x >> y;
       if(op==1)
        update(x,y);
       if(op==2)
        cout << query(y) - query(x-1) << endl;
    }
    return 0;
}
```

---

## 作者：Nero_Claudius (赞：3)

恩，这是AC的第一道树状数组呢。

本蒟蒻以前遇到RMQ问题一般都用线段树或ST表，可惜ST表不支持在线修改，而线段树代码量又太大。。

如今终于找到了折中方案：**树状数组！！！！**
###### 代码量小，还支持修改！


------------

**树状数组**也就是**二叉索引树**，又被称为**Fenwick树**，然而我个人认为它不能被严谨地成为树，因为充其量只是借用的树形结构的思想，于实现上有着较大的区别。

树状数组虽然运用范围没有线段树那么广，但是它的效率要高很多，比如线段树是nlogn，但树状数组是logn。

还有一点需要注意的是：树状数组可以区间查询，但不能运用于任意区间查询。这一点在后面会提到。


------------

那么这个树状数组的基本思路就是

![](http://p0.so.qhimgs1.com/bdr/_240_/t01b3cd94b11782f024.png)

用节点ci储存和，比如：

- c1=a1
- c2=a1+a2
- c3=a3
- c4=a1+a2+a3+a4
- c5=a5
- c6=a5+a6
- c7=a7
- c8=a1+...+a8

当然这样子可能不是很容易看出内在的联系，因此不妨将其转化为二进制来观察：

- c0001=a0001
- c0010=a0001+a0010
- c0011=a0011
- c0100=a0001+a0010+a0011+a0100
- c0101=a0101
- c0110=a0101+a0110
- c0111=a0111
- c1000=a0001+...+a1000

是不是发现了什么？

没有吗？好吧。

事实上这里的规律就是**cn=a(n–2^k+1)+...+an**，这里的k指的是**n二进制末尾0的数量**。

获取2^k的操作我们称之为lowbit，其实现如下：

```cpp
int lowbit(int k){
	return k&(-k);
}
```

有了lowbit操作之后，求和就很好写了：

```cpp
int query(int x){
	int ans=0;
	while(x!=0){
		ans+=tree[x];
		x-=lowbit(x);
	}
	return ans;
}
```

要注意一点，这里求的ans是区间[1,x]的和，想要[y,x]的和只能query(x)-query(y-1)。

因此我们回到了之前那个问题：树状数组不能解决所有区间查询，**它只能解决如上的有关联的区间查询。**

emmmm.....还有update操作：

```cpp
void update(int x,int k){
	while(x<=n){
		tree[x]+=k;
		x+=lowbit(x);
	}
}
```

这个在明白了树状数组的本质之后也很好理解，就不多做叙述了。


------------

总的来说，树状数组挺好用的，值得一学。但切记，**无论如何都必须掌握线段树**，因为能用树状数组解决的都能用线段树，而反之不一定如此。

另附AC代码见下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int maxn=500500;

int n,m;
int tree[maxn<<2];

int lowbit(int k){
	return k&(-k);
}

void update(int x,int k){
	while(x<=n){
		tree[x]+=k;
		x+=lowbit(x);
	}
}

int query(int x){
	int ans=0;
	while(x!=0){
		ans+=tree[x];
		x-=lowbit(x);
	}
	return ans;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		int a;
		scanf("%d",&a);
		update(i,a);
	}
	for(int i=1;i<=m;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		if(a==1)update(b,c);
		else printf("%d\n",query(c)-query(b-1));
	}
}
```

---

## 作者：林昱凯 (赞：3)

# 蒟蒻的第二篇题解：
废话不说，扣1开车

操作1： 格式：1 x k 含义：将第x个数加上k 

操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和

那么这该如何实现呢？
### 操作1：
### a[x]加Y以后，维护所有包含x这一项的c 
```
void add(int x, int y){
	for (; x <= n; x += x & -x) c[x] += y;	
}
```
### 操作2：
### 求a[1]到a[n]之间的和
```
int sum(int n){
	int ret = 0;
	for ( ; n ; n ^= n & -n) ret += c[n];  
        // n ^= n & -n 就是n减去n的二进制最后1个1 
	return ret;
} 
```
这样代码就基本好了

# AC完整代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int n, m;//题目中的变量
int c[500005];
void add(int x, int y){
    for (; x <= n; x += x & -x) c[x] += y;	
}
int sum(int n){
    int ret = 0;
    for ( ; n ; n ^= n & -n) ret += c[n];
    return ret;
}
int main(){
    cin>>n>>m;//读入
    for (int i=1;i<=n;i++){
        int x;
        cin>>x;//读入数列第i项的初始值
        add(i, x);//a[i]=x 
    }
    for (int i=1;i<=m;i++){
        int ope,x,y;
        cin>>ope>>x>>y;//读入操作
        if (ope == 1) add(x, y);//操作1的操作
        else cout<<sum(y)-sum(x - 1)<<endl;//操作2的操作
    }
    return
}
```

## 管理员求通过
# 就此为止了,希望对你有帮助哦~

---

## 作者：人殇物已非 (赞：3)

### cdq分治延续
这道题把cdq分治可以代替一层数据结构的作用体现的淋漓尽致。

继续采用分治思想，把所有的操作拿出来，做分治，递归把区间分成两半$(l,mid)$ $(mid+1,l)$；显然，对于一般的分治，我们在统计每个区间时，没办法考虑到别的区间的贡献，在后面的区间内的查询会被在前面的修改影响，所以答案显然有问题。

故此，需要cdq分治的思想，在分治时，同时考虑前面区间内的操作（修改）对后面区间内的操作（查询）的影响。然后，就能保证了查询操作的正确性。

分治显然没办法初始化，故此把最开始的$n$个数，转换成$n$次修改。

具体细节摘自可爱的std_call姐姐的博客~:

 _"我们定义结构体Query包含3个元素：type，idx，val，其中idx表示操作的位置，type为1表示修改，val表示“加上的值”。而对于查询，我们用前缀和的思想把他分解成两个操作：sum[1,y]-sum[1,x-1]，即分解成两次前缀和的查询。在合并的过程中，type为2表示遇到了一个查询的左端点x-1，需要把该查询的结果减去当前“加上的值的前缀和”，type为3表示遇到了一个查询的右端点y，需要把查询的结果加上当前“加上的值的前缀和”，val表示“是第几个查询”。这样，我们就把每个操作转换成了带有附加信息的有序对(时间，位置)，然后对整个序列进行CDQ分治。"_ 
 
- 但是std_call姐姐没有解释在cdq分治（归并排序）时的比较是按什么比较的（emmm其实大概是因为觉得太显然了吧），让我卡了很久。（太弱了怎么办呀呜呜呜呜）
```cpp
bool operator < (const query &rhs) const{
        return id<rhs.id || (id==rhs.id && ty<rhs.ty); 
    }
```
根据这个函数，我们看出我们是先按照$id$（操作位置）排序，再按照类型排序让修改操作放在前面。

我们都能理解修改操作在前面来完成把所有的**修改操作先完成**。但是，为什么要“**先**”按$id$呢？

因为，**我们要满足前缀和。**

对于$sum$，我们必须按照从前到后维护出正确的前缀和，（如果某个位置的操作并不存在，那么就只是不贡献$sum$，把前缀和继续传下去就好了。），只有这样，在查询的时候，我们才能得到正确的答案。而不会造成一些明明在对后面的位置修改的修改操作乱入到了前面的查询里。

- ### 其实我们可以更简单地理解这个问题 ~~（纯粹是博主突然类比了一下偏序发现原来真的是“显然”。。。）~~

把这个题当成一个二维偏序，那么，第一维是时间，第二维是操作位置。

**很显然，对$X$（查询）有影响的修改操作的位置一定在$X$之前。。**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500001; // 原数组大小
const int maxm=500001; // 操作数量
const int maxq=(maxm<<1)+maxn;
struct query{
    int id,ty;int val;
    bool operator < (const query &rhs) const{
        return id<rhs.id || (id==rhs.id && ty<rhs.ty); 
    }
}q[maxq],tmp[maxq];
int ans[maxq],aid,qid,n,m;
void cdq(int l,int r){
    if(l==r) return;
    int mid=(l+r)>>1;
    cdq(l,mid),cdq(mid+1,r);
    int sum=0;
    int i=l,j=mid+1,k=l;
    while(i<=mid && j<=r){
        if(q[i]<q[j]){
            if(q[i].ty==1) sum+=q[i].val;
            tmp[k++]=q[i++];
        }
        else{
            if(q[j].ty==2) ans[q[j].val]-=sum;
            else if(q[j].ty==3) ans[q[j].val]+=sum;
            tmp[k++]=q[j++]; 
        } 
    }
    while(i<=mid) tmp[k++]=q[i++];
    while(j<=r){
        if(q[j].ty==2) ans[q[j].val]-=sum;
        else if(q[j].ty==3) ans[q[j].val]+=sum;
        tmp[k++]=q[j++]; 
    }
    for(int i=l;i<=r;i++) q[i]=tmp[i];
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        scanf("%d",&q[i].val);
        q[i].id=i,q[i].ty=1;
    }
    qid=n;
    for(int i=1,t,x,y;i<=m;i++){
        scanf("%d%d%d",&t,&x,&y);
        q[++qid].ty=t;
        if(t==1) q[qid].id=x,q[qid].val=y;
        else{
            q[qid].id=x-1,q[qid].val=++aid;
            q[++qid].ty=3;q[qid].id=y;q[qid].val=aid;
        }
    }
//	sort(q+1,q+1+qid);已经最开始按时间排序了 
    cdq(1,qid);
    for(int i=1;i<=aid;i++){
        printf("%d\n",ans[i]);
    }
    return 0;
} 
```

---

## 作者：CSHwang (赞：3)

~~这么好的二维偏序裸题居然没人水一发。~~


询问$[x,y]$区间内的数字和其实等价于询问$[1,x-1]$和$[1,y]$区间内的数字和。


然后，对于每个修改操作或询问操作都可以是看做一个二元组$(a,b)$，其中$a$是时间序，$b$是位置。这个具体的表示可以看程序。


然后对$a$排序(默认有序)，$b$进行CDQ分治就好了。


时间复杂度$O(nlogn)$


---

对代码做点解释。


1、每个二元组用$query$这个数组保存，下面是每个元素的作用。


> type: 1表示修改，2表示加上，3表示减去
>
> idx: 这个是二元组的$b$，CDQ分治时的关键字。
>
> val: 对于修改操作，val是修改的数；对于询问操作，val是答案存储的位置(或者可以理解为询问的下标)。

2、对于位置相同的操作，应该先修改后询问。因此比较的cmp函数是query[x].idx <= query[y].idx。


3、合并子问题时，左半部分只用累加，而右半部分只用统计答案。


AC代码：


```cpp
#include <stdio.h>
#include <stdlib.h>

const int MAX_N = 5e5 + 10 ;

struct data {
    int type , idx , val ;
}query[MAX_N << 2] , temp[MAX_N << 2] ;

int n , m , qt , tot , ans[MAX_N] ;

bool cmp(int x , int y) {
    return query[x].idx <= query[y].idx ;
}

void cdq(int x , int y) {
    if (x == y) return ;
    int mid = (x + y) >> 1 ;
    cdq(x , mid) ; cdq(mid + 1 , y) ;

    int p1 = x , p2 = mid + 1 , sum = 0 , t = 0 ;
    while (p1 <= mid && p2 <= y) {
        if (cmp(p1 , p2)) {
            data *p = &query[p1] ;
            if (p->type == 1) sum += p->val ;
            temp[t++] = *p ; ++p1 ;
        }
        else {
            data *p = &query[p2] ;
            if (p->type == 2) ans[p->val] += sum ;
            else if (p->type == 3) ans[p->val] -= sum ;
            temp[t++] = *p ; ++p2 ;
        }
    }

    for (; p1 <= mid ; ++p1) temp[t++] = query[p1] ;
    for (; p2 <= y ; ++p2) {
        data *p = &query[p2] ;
        if (p->type == 2) ans[p->val] += sum ;
        else if (p->type == 3) ans[p->val] -= sum ;
        temp[t++] = *p ;
    }

    for (int i = 0 ; i < t ; ++i) query[i + x] = temp[i] ;
}

int main() {
    scanf("%d %d" , &n , &m) ;
    for (int i = 1 ; i <= n ; ++i) {
        int a ; scanf("%d" , &a) ;
        query[++tot] = (data){1 , i , a} ;
    }
    for (int i = 0 ; i < m ; ++i) {
        int ty , x , y ;
        scanf("%d %d %d" , &ty , &x , &y) ;

        if (ty == 1) query[++tot] = (data){1 , x , y} ;
        else {
            if (x - 1 > 0) query[++tot] = (data){3 , x - 1 , qt} ;
            query[++tot] = (data){2 , y , qt} ;
            ++qt ;
        }
    }

    ///
    
    cdq(1 , tot) ;
    for (int i = 0 ; i < qt ; ++i)
        printf("%d\n" , ans[i]) ;

    return 0 ;
}
```

---

## 作者：Rapiz (赞：3)

模板题就该比谁的代码短！

```cpp
#include<cstdio>
#include<cstring>
const int MAXN=500010;
inline int lowbit(int x){return x&-x;}
int a[MAXN],n,m;
void add(int p,int v){
    while(p<=n) a[p]+=v,p+=lowbit(p);
}
int pre(int p){
    if(!p) return 0;
    int s;
    for(s=0;p;p-=lowbit(p)) s+=a[p];
    return s;
}
int main(){
    scanf("%d%d",&n,&m);
    int t,x,y;
    for(int i=1;i<=n;i++) scanf("%d",&t),add(i,t);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&t,&x,&y);
        if(t==1) add(x,y);
        else printf("%d\n",pre(y)-pre(x-1));
    }
}
```

---

## 作者：EarthGiao (赞：2)

## 【思路】
之前做过现在是拿出来复习一下，没想到由于太久不写导致生疏到什么东西都忘掉了。。    
只能重学树状数组    
详细的讲解很多题解和博客都写得很好了，    
所以我只在这里说一下易错或者难懂的地方     

### 【题目大意】
单点修改，区间查询     

### 【树状数组复杂度】
树状数组的查询和修改的复杂度都是最坏情况nlogn    
比线段树要少而且比普通数组要好写      
 
### 【什么是lowbit】
lowbit求的是这个数在二进制的情况下最低位的1表示的数    
比如6：      
先转化为二进制—— 110    
最低位的1表示的数就是10,   
转化为十进制就是2    

### 【lowbit有什么用】
知道了一个数的lowbit这个数修改之后会影响的数是哪一个    
感性理解一下就好   
还是比如6：   
lowbit(6) = 2,     
所以修改了6之后会影响的下一个数就是6 + 2 = 8      
然后8在继续影响8 + lowbit(8) 之后的数     
直达到达n     

### 【求1-i的值】
也就是下面代码中sum函数的作用    
求出1-i的值    
因为a[i]代表的不一定是i位置的数    
还有可能是和前面的某些数数加起来的和      
所以要不重复的找出1-i中的某些a[i]     
使他们代表的数刚好是不重复而且不少的出现1-i中的每一个数        
减去lowbit就是跳过那些它包括的数    
感性理解一下就好      
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long

using namespace std;

int read()
{
	int sum = 0,fg = 1;
	char c = getchar();
	while(c < '0' || c > '9'){if(c == '-')fg = -1;c = getchar();}
	while(c >= '0' && c <= '9'){sum = sum * 10 + c - '0';c = getchar();}
	return sum * fg;
}
const int Max = 500005;
int a[Max];
int n,m;

int lowbit(int x)
{
	return x & -x;
}

void add(int x,int y)
{
	while(x <= n)
	{
		a[x] += y;
		x += lowbit(x);
	}
}

int sum(int x)
{
	int ans = 0;
	while(x > 0)
	{
		ans += a[x];
		x -= lowbit(x);
	}
	return ans;
}

signed main()
{
	n = read(),m = read();
	for(register int i = 1;i <= n;++ i)
	{
		int qwq = read();
		add(i,qwq);
	}
	for(register int i = 1;i <= m;++ i)
	{
		int x = read(),y = read(),z = read();
		if(x == 1)
			add(y,z);
		else
			cout << sum(z) - sum(y - 1) << endl;
	}
	return 0;
}
```

---

## 作者：YuntianZhao (赞：2)

# 树状数组（Binary Index Tree）

树状数组是一种树状数据结构，支持区间查询，单点修改。

## 概览

约定节点`Node`如下。

```c++
struct Node {
  int num; 
  int key;
};
```

将树状数组（Binary Index Tree）作为一类。

```c++
class BIT {
 public:
  int n;
  Node a[maxn], c[maxn];
  int lowbit(int x);
  void update(int k, int x);
  int getSum(int x);
  int ask(int l, int r);
  int findKth(int k);
};
```

## lowbit

`lowbit`是一种返回最后一个为1的bit位的操作。

```c++
inline int lowbit(int x) {
  return x & (-x);
}
```

## update

更新操作，修改单点的数据。

单次更新的复杂度是$log N$级别的。

```c++
void BIT::update(int k, int x) {
  for (int i = k; i <= n; i += lowbit(i)) {
    c[i].key += x;
  }
}
```

## getSum

查询操作，获得$[1, x]$的值。

单次查询复杂度是$log N$级别的。

```c++
int BIT::getSum(int x) {
  int ans = 0;
  for (int i = x; i; i -= lowbit(i)) {
    ans += c[i].key;
  }
  return ans;
}
```

## ask

查询操作，获得$[l, r]$的值。

实现方法是求两次`getSum`的差。

```c++
int BIT::ask(int l, int r) {
  return getSum(r) - getSum(l - 1);
}
```

## 完整代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 500005;

struct Node {
  int num;
  int key;
};

class BIT {
 public:
  unsigned int n;
  Node a[maxn], c[maxn];
  int lowbit(int x);
  void update(int k, int x);
  int getSum(int x);
  int ask(int l, int r);
}; 

BIT t;

int main() {
  ios::sync_with_stdio(false);  
  unsigned int m;
  cin >> t.n >> m;
  for (int i = 1; i <= t.n; i++) {
    cin >> t.a[i].key;
    t.update(i, t.a[i].key);
  }
  int opt, x, y;
  for (int i = 1; i <= m; i++) {
    cin >> opt;
    if (opt == 1) {
      cin >> x >> y;
      t.update(x, y);
    }
    if (opt == 2) {
      cin >> x >> y; 
      cout << t.ask(x, y) << endl; 
    }
  }
}

inline int BIT::lowbit(int x) {
  return x & (-x);
}

void BIT::update(int k, int x) {
  for (int i = k; i <= n; i += lowbit(i)) {
    c[i].key += x;
  }
}

int BIT::getSum(int x) {
  int ans = 0;
  for (int i = x; i; i -= lowbit(i)) {
    ans += c[i].key;
  }
  return ans;
}

int BIT::ask(int l, int r) {
  return getSum(r) - getSum(l - 1);
}

```



---

## 作者：pantw (赞：2)

这里是Fenwick Tree Lite Edition!（C，236B，Accepted 2017-11-09 16:08:23）

（压代码仅供娱乐，请勿沉迷压代码）

C语言的一些特性使得我们可以使我们的代码变得简短。

1. 变量类型，函数的返回值还有参数类型默认为int

2. 三目运算及其短路性

3. 逗号运算符可以节省一对大括号



4. 200010改成1<<19能省一个字符QAQ

我估计这个还能缩emmm但是我暂时想不出来了QAQ

奉上本蒻的代码QAQ

（得用C语言提交哦）

（我估计用其他语言可能可以更短？）


```c
n,c[1<<19],m,i=1,t,x,y;
A(p,q){for(;p<=n;p+=p&-p)c[p]+=q;}
P(p){for(t=0;p;p-=p&-p)t+=c[p];return t;}
main(){
    for(scanf("%d%d",&n,&m);i<=n;i++)scanf("%d",&t),A(i,t);
    for(;m--;)scanf("%d%d%d",&t,&x,&y),t-1?printf("%d\n",P(y)-P(x-1)):A(x,y);
}
```

---

## 作者：traceson (赞：2)

**这就是一道裸的树状数组，适合非常新手练题，完全就是模板，没有什么好解释的**

\_代码如下：\_

>还是大概提一下注释一下，方便新手，多的就不解释了>
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,q;
int c[1000000];
int lowbit(int x)//树状数组的核心 
{
    return x&(-x);
}
void add(int p,int x)
{
    while(p<=n) 
    {
        c[p]+=x;
        p+=lowbit(p);//因为是添加应该从下至上,故不停+lowbit 
    }
}
int ask(int p)
{
    int ans=0;
    while(p>0)
    {
        ans+=c[p];
        p-=lowbit(p);//因为是查询所以应该从上至下，故不停地-lowbit 进行统计 
    }
    return ans;
}
int main()
{
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++)
    {
        int a;
        scanf("%d",&a);
        add(i,a);//等价于一个一个地添加元素 
    }
    for(int i=1;i<=q;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        if(x==1) add(y,z);//添加元素 
        else printf("%d\n",ask(z)-ask(y-1));//利用前缀和思想分别求出1~y-1和1~z的和然后再相减 
    }
    return 0;
}
当然，如有不妥，请多指教！
```

---

## 作者：kZime (赞：2)

谁把我的题解举报了quq, 我写的注释那么认真(哇.., 而且我才是第一篇zkw题解啊quq

作为zkw线段树的入门题吧，其中比较难懂的区间查询部分建议配合 统计的力量里的代码和**我的注释** ![](http://218.28.19.228/upload/image/20170508/20170508190124\_55300.png) 然后粘代码qwq

```cpp
# include <bits/stdc++.h>
using namespace std;
inline int get_num() {
    int k = 0, f = 1;
    char c = getchar();
    for(; !isdigit(c); c = getchar()) if(c == '-') f = -1;
    for(; isdigit(c); c = getchar()) k = k * 10 + c - '0';
    return k * f;
}
int n, m;
struct zkw_segtree{
    int M, nd[1500001];
    inline zkw_segtree(){
        M = 1;
        memset(nd, 0, sizeof(nd));
    }
    inline void push_up(int x) { // 上传函数
        nd[x] = nd[x << 1] + nd[x << 1 | 1];
    }
    inline void build() {
        for(M = 1; M <= n + 1; M <<= 1);// M可以等于n 所以要M <= n + 1
        for(int i = M + 1; i <= M + n; i++) { // 处理叶子节点
            nd[i] = get_num();
        }
        for(int i = M; i >= 1; i--) { // 处理父节点
            push_up(i);
        }
    }
    inline void change_one_point(int x , int k) {
        x += M;
        nd[x] += k;
        for(x >>= 1; x; x >>= 1) {
            push_up(x);
        }
    }
    inline int query(int l, int r) {
        int ans = 0;
        for(l = M + l - 1, r = M + r + 1; l ^ r ^ 1; l >>= 1, r >>= 1) { // l = M + l - 1, r = M + r + 1, 意思是将l 和 r 变成开区间，l ^ r ^ 1  -->  not l ^ r == 1  -->  l 和 r不是同一节点的两个子节点
            if(~l & 1) ans += nd[l + 1];// l是左子区间                       
            if(r & 1) ans += nd[r - 1]; // r是右子区间                       
        }
        return ans;
    }
}T;
int main() {
    n = get_num();
    m = get_num();
    T.build();
    while(m--) {
        int opr = get_num();
        int x = get_num();
        int y = get_num();
        if(opr & 1) { // 其实就是opr == 1.....
            T.change(x, y);
        } else {
            printf("%d\n", T.query(x, y));
        }
    }
}
```
注释很良心哦quq

顺便附赠一个一篇博客

<http://kzime.xyz/2017/05/08/zkw/>



---

## 作者：Jμdge (赞：1)

咱要来贡献一篇 PY 题解，没想到吧！

居然不会打树状数组了我...


理论上的玩意儿不用说太多？反正树状数组大家都会？


咱来谈谈语言好了！

首先一个全局变量 f 数组，我们怎么开呢？

上网搜索可得： $f=[0 ~for~ i ~in~ range(500005)]$ 就是代码打开的正确方式

其他的变量的话，其实写在前面，然后付个初值 0 就好了（虽说咱并没有这么做，以至于传参数 +1 ）

至于别的操作貌似和 c++ 没什么区别

注意 split 就是了（~~尤其是 $A+B~ problem$ WA 掉的同学，特指自己~~）

# Code 

这份代码还是肥肠优秀的，尽管它 T 上了天

```

f=[0 for i in range(500005)]


def lowbit(x):
    return x&(-x)

def add(x, n, k):
    while x<=n :
        f[x]+=k
        x+=lowbit(x)

def ask(x):
    Res=0
    while x>0:
        Res+=f[x]
        x-=lowbit(x)
    return Res



s=input().split()
n=int(s[0])
m=int(s[1])
s=input().split()
for i in range(1,n+1):
    add(i, n, int(s[i-1]))

while m>0:
    s=input().split()
    op=int(s[0])
    x=int(s[1])
    y=int(s[2])
    if op==1:
        add(x, n, y)
    else:
        print(ask(y)-ask(x-1))
    m=m-1

```






---

## 作者：little_gift (赞：1)

## 表示直接把线段树模板copy过来(这样是不是有点对不起树状数组) ##

### 直接把线段树的区间加的左右端点重合即可~~(其实是我懒得改)~~ ###





```cpp
#include <bits/stdc++.h>
using namespace std;
typedef int ll;
const int maxn = 500000;
ll a[maxn << 2], c[maxn << 2], n, m, x, y, k, d;
void push_up(ll h); //更新当前节点 
void push_down(ll h, ll len); //下放lazy tag 
void build(ll h, ll l, ll r); //建树 
void update(ll h, ll l, ll r, ll x, ll y, ll k); //区间加(大材小用啊) 
ll query(ll h, ll l, ll r, ll x, ll y); //查询 
int main()
{
    scanf("%d%d", &n, &m);
    build(1, 1, n);
    for (ll i = 1; i <= m; ++i)
    {
        scanf("%d%d%d", &d, &x, &y);
        if (d == 1)    update(1, 1, n, x, x, y); //l == r
        else printf("%d\n", query(1, 1, n, x, y));
    }
}
void push_up(ll h)
{
    a[h] = a[h << 1] + a[h << 1 | 1];
}
void push_down(ll h, ll len)
{
    a[h << 1] += c[h] * (len - (len >> 1));
    a[h << 1 | 1] += c[h] * (len >> 1);
    c[h << 1] += c[h];
    c[h << 1 | 1] += c[h];
    c[h] = 0; //然而我第一次交的时候没打 
}
void build(ll h, ll l, ll r)
{
    if (l == r)
    {
        scanf("%d", &a[h]);
        return;
    }
    ll mid = l + r >> 1;
    build(h << 1, l, mid);
    build(h << 1 | 1, mid + 1, r); //∵h << 1必为偶数 ∴h << 1 | 1 == h * 2 + 1
    push_up(h);
}
void update(ll h, ll l, ll r, ll x, ll y, ll k)
{
    if ((x <= l) && (r <= y))
    {
        a[h] += k * (r - l + 1); //总值加 
        c[h] += k; //lazy tag
        return;
    }
    if (c[h]) push_down(h, r - l + 1);
    ll mid = l + r >> 1;
    if (x <= mid) update(h << 1, l, mid, x, y, k);
    if (y > mid) update(h << 1 | 1, mid + 1, r, x, y, k); //左边和右边 
    push_up(h);
}
ll query(ll h, ll l, ll r, ll x, ll y)
{
    if ((x <= l) && (r <= y))
        return a[h];
    if (c[h]) push_down(h, r - l + 1);
    ll mid = l + r >> 1, s = 0;
    if (x <= mid) s += query(h << 1, l, mid, x, y);
    if (y > mid) s += query(h << 1 | 1, mid + 1, r, x, y); //查询的是左右两区间的和 
    return s;
}
```

---

## 作者：zty61211 (赞：1)

没人贴pascal的代码，那我就贴一下吧

算法思想百度还是挺多的

代码：





```cpp
const maxn=600000;
var tree,a:array [0..maxn] of longint;
    n,m,i,x,y,k:longint;
function lowbit(x:longint):longint;   //树状数组求子父节点的精髓，表示x二进制下最低位的1的位权
  begin
    exit(x and -x);
  end;
procedure add(x,y:longint);     //给第x个数增加y
  begin
    while x<=n do
    begin
      inc(tree[x],y);
      inc(x,lowbit(x));
    end;
  end;
function sum(x:longint):longint;    //求1~x的和
  begin
    sum:=0;
    while x>0 do
    begin
      inc(sum,tree[x]);
      dec(x,lowbit(x));
    end;
  end;
Begin
  fillchar(tree,sizeof(tree),0);
  readln(n,m);
  for i:=1 to n do read(a[i]);
  for i:=1 to n do add(i,a[i]);    //建树
  for i:=1 to m do
  begin
    readln(k,x,y);
    case k of
      1:add(x,y);
      2:writeln(sum(y)-sum(x-1));      //前缀和思想
    end;
  end;
End.
```

---

## 作者：dph754132771 (赞：1)

/\*
\* P3374

\* Au:Small\_Ash

\* 本题就是裸的树状数组，也就是BIT，关于BIT的实现原理，大家可以自行百度或者看我的程序理解

\* 本题解主要是如何将思路转换为实现。

\* 具体实现看代码注释

\*/
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
int tree[500005],n,m;//tree 就是传说中的BIT啦，是不是很惊讶 
void add(int k,int num)//给k节点加上num 
{  
    while(k<=n)// 
    {  
        tree[k]+=num;//k节点包括其以上的父节点的sum都需要加上num 
        k+=k&-k;//这就是BIT最神奇的实现部分了，也就是lowbit。lowbit就是节点在树中的层级。
```
/\* 这里的计算是利用了计算机补码的性质。
例如      000001111  (15)

补码就是  111110001

取与就是  000000001 所以15的lowbit就是1啦（关于lowbit的意义详见百度）

\*/
```cpp
         //  k+=k&-k; 就是向上走啦 
    }  
}
int find(int k)//计算从1到k的节点的总数 
{  
    int sum=0;//累计器 
    while(k)  
    {  
        sum+=tree[k];// 每一个下级都要加入 
        k-=k&-k;// 就是向下走啦 
    }  
    return sum;  
}  
int main(){
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++){
        int a;
        scanf("%d",&a);
        add(i,a);
    }
    for (int i=1;i<=m;i++){
        int k,a,b;
        scanf("%d",&k);
        if (k==1){
            scanf("%d%d",&a,&b);
            add(a,b);
        }
        if (k==2){
            scanf("%d%d",&a,&b);
            printf("%d\n",find(b)-find(a-1));//前缀和思想，d[y]-d[x-1]=x到y的总和。 
        }
    }
    return 0;
}

```

---

## 作者：wffms69_8 (赞：1)

代码好记呀

```cpp
#include<bits/stdc++.h>
using namespace std;

#define lowbit(x) (-(x)&(x))

int n, c[666666];

void update(int pos, int val) {
    for (; pos <= n; pos += lowbit(pos))
        c[pos] += val;
}

int query(int pos) {
    int ans(0);
    for (; pos; pos -= lowbit(pos))
        ans += c[pos];
    return ans;
}

int main() {
    int m;
    cin >> n >> m;
    for (int i(1); i <= n; ++i) {
        int v;
        cin >> v;
        update(i, v);
    } 
    for (int i(0); i < m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a == 1)
            update(b, c);
        else
            cout << query(c) - query(b - 1) << endl;
    }
    return 0;
}
```

---

## 作者：littlegagaduck (赞：0)

reviewing for csp

树状数组可以实现单点修改和区间查询，如果以此数据结构维护差分数组可以实现区间修改和单点查询。

lowbit返回这个位置下标二进制拆分后的最小值，比如lowbit(4)=4,二进制100；lowbit(5)=1,二进制101.

update修改，这个位置每次加上自己的lowbit值正好返回父节点的位置

sum求的是这个位置为末尾的前缀和，每次减去自己的lowbit值可以到它之前的一个根节点，这个节点覆盖很多数，是很多数的和，因此可以减少运算次数，而当这个数减去自己的lowbit值时，正好跳过自己所包含的这个区间。

建树的过程相当于单点修改加上所需的数。

```cpp
#include<iostream>
using namespace std;
int a[500010],c[500010],n,m;
inline int lowbit(int p)
{
	return (p)&(-p);
}
inline void update(int x,int p)
{
	while(p<=n)
	{
		c[p]+=x;
		p+=lowbit(p);
	}
}
inline int sum(int p)
{
	int ans=0;
	while(p>0)
	{
		ans+=c[p];
		p-=lowbit(p);
	}
	return ans;
}
int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
	{
		int x;
		cin>>x;
		update(x,i);
	}
	while(m--)
	{
		int judge;
		cin>>judge;
		if(judge==1)
		{
			int p,x;
			cin>>p>>x;
			update(x,p);
		}
		else if(judge==2)
		{
			int l,r;
			cin>>l>>r;
			cout<<sum(r)-sum(l-1)<<endl;
		}
	}
	return 0;
}
```


---

## 作者：opened (赞：0)

树状数组该结构满足一下性质：

1. 每个结点 $c[x]$ 保存以它为根的子树所有叶节点的和

1. 每个节点 $c[x]$ 的子节点个数等于 $lowbit(x)$ 的大小

1. 每个内部节点 $c[x]$ 的父节点是 $c[x+lobit(x)]$

1. 从一个子树根结点到另一个 $x-lowbit(x)$

**其实 $lowbit(x)$ 可以表示这棵子树的宽度**
 

```
#include<cstdio>
  
using namespace std;

int n,m,c[500010];

int lowbit(int x){return x&(-x);}

int ask(int x){

        int sum=0;
        while(x){
            sum+=c[x];
            x-=lowbit(x);
        }
        return sum;
}

void add(int i,int x){

        while(i<=n){
            c[i]+=x;
            i+=lowbit(i);
        }
        return;
}

int main(){

        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++){
            int a;
            scanf("%d",&a);
            add(i,a);
        }
        for(int i=1;i<=m;i++){
            int w,y,z;
            scanf("%d%d%d",&w,&y,&z);
            if(w==1)
                add(y,z);
            else
                printf("%d\n",ask(z)-ask(y-1));
        }
        return 0;
}
```

---

## 作者：彼岸朱砂 (赞：0)

定义：

线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数， 时间复杂度 为O(logN)。

而未优化的 空间复杂度 为2N，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。

线段树是一种能够有效处理区间操作的高级数据结构，利用这种数据结构，我们能够设计出针对上述问题更加高效的算法。

线段树的题目通常比较明显，一般一个很明显的特征是m次对某一区间长度的查询。或者是修改。所以我们通常需要的只是将线段树的模型稍加修改，进而套入题目中即可。
![](https://s1.ax1x.com/2018/08/10/P690HK.png)
应用：

上面的都是些基本的线段树结构，但只有这些并不能做什么，就好比一个程序有输入没输出，根本没有任何用处。

最简单的应用就是记录线段是否被覆盖，随时查询当前被覆盖线段的总长度。那么此时可以在结点结构中加入一个变量int count;代表当前结点代表的子树中被覆盖的线段长度和。这样就要在插入(删除)当中维护这个count值，于是当前的覆盖总值就是根节点的count值了。

另外也可以将count换成bool cover;支持查找一个结点或线段是否被覆盖。

实际上，通过在结点上记录不同的数据，线段树还可以完成很多不同的任务。例如，如果每次插入操作是在一条线段上每个位置均加k，而查询操作是计算一条线段上的总和，那么在结点上需要记录的值为sum。

这里会遇到一个问题:为了使所有sum值都保持正确，每一次插入操作可能要更新O(N)个sum值，从而使时间复杂度退化为O(N)。

解决方案是Lazy思想:对整个结点进行的操作，先在结点上做标记，而并非真正执行，直到根据查询操作的需要分成两部分。

根据Lazy思想，我们可以在不代表原线段的结点上增加一个值toadd，即为对这个结点，留待以后执行的插入操作k值的总和。对整个结点插入时，只更新sum和toadd值而不向下进行，这样时间复杂度可证明为O(logN)。

对一个toadd值为0的结点整个进行查询时，直接返回存储在其中的sum值;而若对toadd不为0的一部分进行查询，则要更新其左右子结点的sum值，然后把toadd值传递下去，再对这个查询本身，左右子结点分别递归下去。 时间复杂度 也是O(nlogN)。

模板：

对单个点的修改，和对一段区间的查询：
```
//线段树单个点修改&区间查询
#include<iostream>
#include<iomanip>
#include<cstring>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<queue>
#include<vector>
#include<map>
#include<algorithm>
#include<string>
#include<memory>
using namespace std;

const int e=100006;
struct qq
{
    int maxx;
}tree[4*e];//线段树要开4倍的点的个数
int n,t,a,b;

void updata(int l,int r,int root)
{
    if(r<a || l>a)    return;
    if(r==l)
    {
        tree[root].maxx=b;
        return;
    }

    int mid=(l+r)/2;
    updata(l,mid,root*2);
    updata(mid+1,r,root*2+1);
    tree[root].maxx=max(tree[root*2].maxx,tree[root*2+1].maxx);
}

int search(int l,int r,int root)
{
    if(l>b || r<a)    return(-999999999);

    if(l>=a && r<=b)    return(tree[root].maxx);

    int mid=(l+r)/2;
    return(max( search(l,mid,root*2), search(mid+1,r,root*2+1)));
}

int main()
{
    memset(tree,0,sizeof(tree));
    cin>>n;

    for(int i=0;i<n;i++)
    {
        scanf("%d%d%d",&t,&a,&b);

        if(t==1)    updata(1,n,1);//将点a的值改为b
        if(t==2)    cout<< search(1,n,1) << endl;//查找区间a(含)到b(含)的最大值;
    }

    return 0;
}
```

对一段区间的修改和查询：
```
//线段树 区间 修改&查询
#include<iostream>
#include<iomanip>
#include<cstring>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<queue>
#include<vector>
#include<map>
#include<algorithm>
#include<string>
#include<memory>
using namespace std;

const int e=100006;
struct qq
{
    int maxx,delta;
}tree[4*e];//线段树要开4倍的点的个数
int n,t,a,b;

void updata(int l,int r,int root)//更新数据
{
    if(b<l || r<a)    return;

    if(l>=a && r<=b)//这句是核心，若当前区间包含于修改区间，就不往下传,(未传到叶子节点)；
    {
        tree[root].maxx++;
        tree[root].delta++;
        return;
    }

    int mid=(l+r)/2,delta=tree[root].delta;
    tree[root*2].maxx+=delta;
    tree[root*2].delta+=delta;
    tree[root*2+1].maxx+=delta;
    tree[root*2+1].delta+=delta;
    tree[root].delta=0;//这句很关键，根的偏移量传递到子树后清零
    updata(l,mid,root*2);
    updata(mid+1,r,root*2+1);
    tree[root].maxx=max( tree[root*2].maxx, tree[root*2+1].maxx);
    return;
}

int search(int l,int r,int root)
{
    if(l>b || r<a)    return(-99999999);

    if(l>=a && r<=b)    return(tree[root].maxx);

    int mid=(l+r)/2,delta=tree[root].delta;
    tree[root*2].maxx+=delta;
    tree[root*2].delta+=delta;
    tree[root*2+1].maxx+=delta;
    tree[root*2+1].delta+=delta;
    tree[root].delta=0;      //这句很关键，根的偏移量传递到子树后清零
    return(max( search(l,mid,root*2), search(mid+1,r,root*2+1)));
}

int main()
{
    memset(tree,0,sizeof(tree));
    cin>>n;

    for(int i=0;i<n;i++)
    {
        scanf("%d%d%d",&t,&a,&b);

        if(t==1)    updata(1,n,1);
        if(t==2)    cout<< search(1,n,1) << endl;
    }

    return 0;
}
```

[ P3374 【模板】树状数组 1](https://www.luogu.org/problemnew/show/P3374)
```
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 5*1e5 + 100;
int tree[N*4],ans;

void built(int id,int l,int r,int x,int val)
{
    if(l==r && l == x)
    {
        tree[id] += val;
        return;
    }
    int mid = (l+r) / 2;
    if(x<=mid) built(id*2,l,mid,x,val);
    if(x>mid) built(id*2+1,mid+1,r,x,val);
    tree[id] = tree[id*2] + tree[id*2+1];
    return;
}

void query(int id,int l,int r,int x,int y)
{
    if(l>=x && r <=y)
    {
        ans += tree[id];
        return;
    }
    int mid = (l+r)/ 2;
    if(x<=mid) query(id*2,l,mid,x,y);
    if(y>mid) query(id*2+1,mid+1,r,x,y);
}

int main()
{
    int n,m;
    cin >> n >> m;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin >> x;
        built(1,1,n,i,x);
    }
    while(m--)
    {
        int op,x,y;
        cin >> op >> x >> y;
        if(op==1) built(1,1,n,x,y);
        else
        {
            ans = 0;
            query(1,1,n,x,y);
            cout << ans << endl;
        }
    }
    return 0;
}

```

[ P3372 【模板】线段树 1](https://www.luogu.org/problemnew/show/P3372#sub)
```
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio> 
using namespace std;

const int N=1e5+100;
long long tr[N*4],flag[N*4],ans;

void built(int i,int l,int r,int x,long long val)
{
    if(l==r)//找到了叶子节点 
    {
        tr[i]+=val;//把叶子节点的初始更新 
        return;
    }
    int mid=(l+r)/2;
    if(x<=mid) built(i*2,l,mid,x,val);//左子树 
    if(x>mid) built(i*2+1,mid+1,r,x,val);//右子树 
    tr[i]=tr[i*2]+tr[i*2+1];//回溯时更新节点 
    return;
}
void pushdown(int i,int l,int r)//lazy操作,用到才更新 
{
    int mid=(l+r)/2;
    tr[i*2]+=flag[i]*(mid-l+1);//mid-l+1是区间内元素的个数,flag[i]是记录当前节点下的节点每个元素应更新的值 //左子树 
    tr[i*2+1]+=flag[i]*(r-mid);//本是r-(mid+1)+1,化简后是r-mid//右子树 
    flag[i*2]+=flag[i];
    flag[i*2+1]+=flag[i];//应为我们用过的节点的子节点没有标记过,所以标记一下 
    flag[i]=0;//已经更新过了,清空标记 
    return;
}
void update(int i,int l,int r,long long x,long long y,long long k)//更新//操作一 
{
    if(l>=x&&r<=y)//如果(l,r)在(x,y)//体会一下,也不知生不生动{X(l,r)Y}//表明是我们要更新的点 
    {
        tr[i]+=k*(r-l+1);//因为lazy操作,我们只需要更新我们要求的点 ,没更新的用到才更新 
        flag[i]+=k;//标记当前节点表示当前节点的子节点每个值都需要加上flag[i],现在不加,要用到才更新 
        return;
    }
    if(flag[i]>0) pushdown(i,l,r);//因为么有满足if,说明要用当前节点以及它的子节点,所以要更新
    /*这里可能会看不懂,如果第一次我们更新了(5,8)但它的子节点没有更新,如果下次要更新(5,6),但原来(5,6)就有值没更新所以会少加,所以把原来
    的值更新,再更新当前值*/ 
    int mid=(l+r)/2;
    if(mid>=x) update(i*2,l,mid,x,y,k);//一直dfs,直到是我们要更新的值//左子树 
    if(mid<y) update(i*2+1,mid+1,r,x,y,k);//右子树 
    tr[i]=tr[i*2]+tr[i*2+1];
    return;
}
void query(int i,int l,int r,long long x,long long y)//操作二 
{
    if(l>=x&&r<=y)//如果(l,r)在(x,y)//体会一下,也不知生不生动{X(l,r)Y}//表明是我们要更新的点(同上update虽然还是打了一遍) 
    {
        ans+=tr[i];//更新ans把区间内的值加上 
        return;
    }
    if(flag[i]>0) pushdown(i,l,r);//因为lazy操作,当前节点的子节点没更新,所以要更新一遍 
    int mid=(l+r)/2;
    if(mid>=x) query(i*2,l,mid,x,y);//一直dfs,直到是我们要加的值//左子树 
    if(mid<y) query(i*2+1,mid+1,r,x,y);//右子树 
}
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        long long x;//题目说了要用long long 
        cin>>x;
        built(1,1,n,i,x);
    }
    while(m--)
    {
        int op;
        cin>>op;
        if(op==1)//操作一 
        {
            long long x,y,k;
            cin>>x>>y>>k;
            update(1,1,n,x,y,k);
        }
        if(op==2)//操作二 
        {
            long long x,y;
            cin>>x>>y;
            ans=0;
            query(1,1,n,x,y);
            cout<<ans<<endl;
        }
    }
    return 0;
}
```

---

## 作者：八重樱 (赞：0)

/\*
看到那么多神犇

各种树状数组和线段树的递归

手动模拟好麻烦

于是我来一发简化版的

ZKW线段树吧

非递归哦

\*/
```cpp
#include<cstdio>
using namespace std;
inline bool bin(){register char c=getchar();while(c<49||c>50)c=getchar();return c&1;}
inline int intin(){register char c=getchar();while(c!=45&&(c<48||c>57))c=getchar();register int a=0;register bool b=0;if(c==45){c=getchar();b=1;}while(c>47&&c<58){a=(a<<1)+(a<<3)+c-48;c=getchar();}if(b)a*=(-1);return a;}
inline void intot(int a){if(a<0){putchar(45);a*=(-1);}if(a>9)intot(a/10);putchar(a%10+48);}
int n,ljj[22]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152},zyh[2097155];
int main()
{
    int m=intin(),q=intin();
    for(int i=0;i<22;i++)if(m<ljj[i]){n=ljj[i];i=23;}//直接视为满二叉树 
    for(int i=1;i<=m;i++)zyh[i+n]=intin();//读入数组 
    for(int i=n;i>0;i--)zyh[i]=zyh[i<<1]+zyh[i<<1|1];//建树 
    while(q--)if(bin())//修改操作 
    {
        int k=intin()+n,x=intin();
        while(k>0)
        {
            zyh[k]+=x;
            k=k>>1;
        }
    }else{//查询操作 
        int l=intin()+n-1,r=intin()+n,a=0,b=0,h=n;
        while(r!=h)
        {
            if(r%2==0)a+=zyh[r];
            r=(r-1)>>1;h=h>>1;
        }
        a+=zyh[r];
        h=n;
        while(l!=h)
        {
            if(l%2==0)b+=zyh[l];
            l=(l-1)>>1;h=h>>1;
        }
        b+=zyh[l];
        a-=b;
        intot(a);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：Lyrics (赞：0)

（发现没有人发线段树的题解，那我就来一波线段树题解吧！）

线段树教程详细解析（本人的博客哦）： http://www.cnblogs.com/ACworker/p/7703537.html

CODE：

    
    
    

    
    
    
    
    
    
    
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL op,n,m,x,y,k,a[1500005],low_bit,tempt;
struct fkt{
    LL left;
    LL right;
    LL tot;
    LL add;
}tree[1500005];
namespace qaq{
    LL change(LL test){LL ans=0;while(test){test>>=1;ans++;}test=1;while(ans--)test*=2;return test;}//为了建立完全树 
    //建立一棵线段树 
    void build(LL lef,LL rig,LL root){//从lef到rig的距离以root为根建树（前提是要求rig-lef+1能够构成一个完全树） 
        tree[root].left=lef;
        tree[root].right=rig;
        tree[root].add=0;//延迟标记 
        if(lef==rig){tree[root].tot=a[lef];}
        else{
            LL mid=(lef+rig)>>1;
            build(lef,mid,root<<1);
            build(mid+1,rig,root<<1|1);
            tree[root].tot=tree[root<<1].tot+tree[root<<1|1].tot;
        }
    }
    //向下传递延迟标记
    void pushdown(LL root){
        if(tree[root].add){
            tree[root<<1].add+=tree[root].add;
            tree[root<<1|1].add+=tree[root].add;
            tree[root<<1].tot+=tree[root].add*(tree[root<<1].right-tree[root<<1].left+1);
            tree[root<<1|1].tot+=tree[root].add*(tree[root<<1|1].right-tree[root<<1|1].left+1);
            tree[root].add=0;
        }
    } 
    //向上推传递值
    void pushup(LL root){
        tree[root].tot=tree[root<<1].tot+tree[root<<1|1].tot;
    }     
    //区间更新
    void update(LL nl,LL nr,LL root,LL c){
        if(tree[root].left>nr||tree[root].right<nl)    return;
        if(tree[root].left>=nl&&tree[root].right<=nr){
            tree[root].add+=c;
            tree[root].tot+=c*(tree[root].right-tree[root].left+1);
            return;
        }
        pushdown(root);
        LL mid=(tree[root].left+tree[root].right)>>1;
        if(nl<=mid)        update(nl,nr,root<<1,c);
        if(mid+1<=nr)    update(nl,nr,root<<1|1,c);
        pushup(root);
    } 
    //查询工作,在[nl,nr]的区间内查找，当前查找[l,r]区间 
    LL query(LL nl,LL nr,LL root){
        if(tree[root].left>nr||tree[root].right<nl)    return 0;//返回一个极小的值 
        if(tree[root].left>=nl&&tree[root].right<=nr)    return tree[root].tot;
        pushdown(root);//向下传递才能计算求和。
        return query(nl,nr,root<<1)+query(nl,nr,root<<1|1);
    }
    int main(){
        scanf("%lld%lld",&n,&m);
        for(LL i=1;i<=n;i++)    scanf("%lld",&a[i]);
        tempt=change(n);
        build(1,tempt,1);
        while(m--){
            scanf("%lld",&op);
            if(op==1){
                scanf("%lld%lld",&x,&k);
                update(x,x,1,k);
            }
            else{
                scanf("%lld%lld",&x,&y);
                printf("%lld\n",query(x,y,1));
            }
        }
        return 0;
    }
}
int main(){
    qaq::main();
    return 0;
}
```

---

## 作者：Little_Jian (赞：0)

看到没人用zkw的线段树那我就来发一波了


大致思路是各种二进制优化


update是更新

quer是查询

firstbit是转成满二叉树


详细内容可以去看zkw的ppt


```cpp
#include <bits/stdc++.h>
using namespace std;
int tree[1050005],n,m;
int firstbit(int x){
int k=0;
    while(x)k++,x>>=1;
    return 1<<k;
}
int query(int l,int r){
int ans=0;
    for(l=l+m-1,r=r+m+1;l^r^1;l>>=1,r>>=1){
        if(~l&1)ans+=tree[l^1];
        if( r&1)ans+=tree[r^1];
    }
    return ans;
}
int update(int n,int v){
    for(tree[n+=m]+=v,n>>=1;n;n>>=1)
        tree[n]=tree[n<<1]+tree[n<<1|1];
}
int main(){
int k;
    ios::sync_with_stdio(false);
    cin>>n>>k;
    m=firstbit(n);
    for(int i=1;i<=n;i++)
        cin>>tree[i+m];
    for(int i=m-1;i>=1;i--)
        tree[i]=tree[i<<1]+tree[i<<1|1];
    while(k--){
        int flag;
        cin>>flag;
        if(flag==1){
            int a,b;
            cin>>a>>b;
            update(a,b);
        }
        else {
            int a,b;
            cin>>a>>b;
            cout<<query(a,b)<<endl;
        }
    }
    return 0;
}
```

---

## 作者：2到正无穷 (赞：0)

树状数组模板题。

这是一个树状数组的模板，包含2个操作：单点修改，求前缀和

如果treearray的data存储的是原数据，则支持单点修改，区间求和（区间求和是前缀和相减）

如果treearray的data存储的是源数据的差分（即：若是让源数据的第2~5个点+1，则在t的data域中：t.data[2]++;t.data[6]--;)则支持区间修改，单点查询（单点查询就是把标记都收集起来）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 500003
struct treearray{
    #define lowbit(x) ((x)&(-x))
    int data[N],n;
    treearray(){
        memset(data,0,sizeof(data));
    }
    void add(int x,int p){
        for (int i=x;i<=n;i+=lowbit(i)) data[i]+=p;
    }
    int query(int x){
        int ans=0;
        for (int i=x;i>=1;i-=lowbit(i)) ans+=data[i];
        return ans;
    }
}t;
int m;
int main(){
    scanf("%d%d",&t.n,&m);
    for (int i=1,w;i<=t.n;i++){
        scanf("%d",&w);
        t.add(i,w);
    }
    for (int i=1,c,x,y;i<=m;i++){
        scanf("%d%d%d",&c,&x,&y);
        if (c==1) t.add(x,y);
        if (c==2) printf("%d\n",t.query(y)-t.query(x-1));
    }
    return 0;    
}
```

---

## 作者：Tgotp (赞：0)

树状数组的模版题

方法如下：

一个一维数组tree[]

其中tree[i]表示

[i-(i&(-i))+1,i]这个区间内a数组元素的和

执行的次数和二进制中‘1’的位数有关

read(int pos) 求 sum[1,pos]的答案

update(int pos,int v) 把a[pos]加上v

查询sum[l,r]  ： read(r)-read(l-1)



这些就是树状数组的一般解法了！








```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 500000+5;
int n,M,tree[N];
int read(int pos)
{
        int ans=0;
        while (pos>0)
        {
            ans+=tree[pos];
            pos-=pos&-pos;
        }
        return ans;
}
void update(int pos,int val)
{
    while(pos<=n)
    {
        tree[pos]+=val;
        pos+=pos&-pos;
    }
}
int main()
{
    scanf("%d%d",&n,&M);
    for(int i=0;i<n;i++)
    {
        int num;
        scanf("%d",&num);
        update(i+1,num);
    }
    for(int i=0;i<M;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        if(a==1) update(b,c);
        else printf("%d\n",read(c)-read(b-1));
    }
    return 0;
}
```

---

## 作者：Enzymii (赞：0)

##这个这么好的模板竟然没有题解，导致我想入树状数组坑的人都无所适从……

##所以打完板子就想造福大众呢~

###所以就把我的板子打过来了~

树状数组其实本身好像并不是多么太难。。

但初始化却又费了我好长时间

一个局部变量没初始化费了我一晚上来调。。

这个模板的码风有点清奇大家凑合着看 不喜勿喷


//树状数组模板 2016.09.26 By Zyan

//==================================================== 

//头文件及namespace 

【这里的井号感人啊】include<iostream>

```cpp
using namespace std;
//lowbit
#define lowbit(i) (i&(-i))   //lowbit提出二进制位最小的一个1【能理解吧
//全局变量 
int c[1000001];                //树状数组  
int n=0;                      //树状数组的元素总个数  
//操作 
void init(void);              //初始化
void add(int,int);            //单点加
int sum(int);                 //区间求和
int main() 
{
    init();
}
//初始化【请随题目改动】
void init()
{
    int m,k;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>k;
        add(i,k);
    }
    while(m--)
    {
        int i,j,k;
        cin>>i>>j>>k;
        if(i-1) cout<<sum(k)-sum(j-1)<<endl;
        else add(j,k);
    }
}
//第x位的元素 +data
void add(int x,int data)      
{
    while(x<=n)
    {
        c[x]+=data;
        x+=lowbit(x);
    }
}
//前x位的和 
int sum(int x)
{
    int s=0;                         
    //mdzz记住这里的自己 局部变量一定要初始化
    while(x>0)
    {
        s+=c[x];
        x-=lowbit(x);
    }
    return s;
}
```

---


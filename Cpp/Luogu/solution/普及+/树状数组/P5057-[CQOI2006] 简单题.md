# [CQOI2006] 简单题

## 题目描述

有一个 $n$ 个元素的数组，每个元素初始均为 $0$。有 $m$ 条指令，每条指令为两种操作中的一种：
1. 让其中一段连续序列数字反转；（即 $0$ 变 $1$，$1$ 变 $0$）
2. 询问某个元素的值。

例如当 $n=20$ 时，$10$ 条指令如下：

![](https://cdn.luogu.com.cn/upload/pic/44663.png)


## 说明/提示

对于 $50\%$ 的数据，$1 \le n \le 10^3$，$1 \le m \le 10^4$；

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le m \le 5 \times 10^5$，保证 $L \le R$。

## 样例 #1

### 输入

```
20 10
1 1 10
2 6
2 12
1 5 12
2 6
2 15
1 6 16
1 11 17
2 12
2 6```

### 输出

```
1
0
0
0
1
1```

# 题解

## 作者：小粉兔 (赞：227)

简单题，果然很简单。  
考虑差分序列（用异或代替减法），则每个元素的真实值是差分序列的异或前缀和，修改的时候只需要改 $l$ 和 $r + 1$ 两个位置的差分。  
用树状数组维护。

```cpp
#include <cstdio>

int N, M, B[100001];
inline void A(int i) { for (; i <= N; i += i & -i) B[i] ^= 1; }
inline int Q(int i) { int A = 0; for (; i; i -= i & -i) A ^= B[i]; return A; }

int main() {
	scanf("%d%d", &N, &M);
	while (M--) {
		int opt, l, r;
		scanf("%d%d", &opt, &l);
		if (opt == 1) A(l), scanf("%d", &r), A(r + 1);
		else printf("%d\n", Q(l));
	}
	return 0;
}
```

---

## 作者：Knight_Master (赞：48)

~~**这道题确实有点水**~~

看各位大佬解法不一，我也来提供一种较为容易理解的解法，前提是会**树状数组和前缀和，差分**

~~（不会的可以去刷一下板子题）~~

首先我们看题，发现最后结果**只有0或者1**（只有两种输出情况），我们就可以想到 **“ %2 ”**。

然后我们可以用一波简单的**差分**：

设d[x] 为**从1到x每一个数的总和**

假设初始一串数据 0 0 0 0 0  ~~（共五个）~~

我们要将（1，3）反过来，我们就可以将第一个数**加上1**，即：

**1 0 0 0 0**

然后我们在将第四个数**加上1**，即：

**1 0 0 1 0**

然后我们可以发现：

查询第一个数 == d[1] **% 2** = 1 **% 2** =1;

查询第二个数 == d[2] **% 2** = (1+0) **% 2**  =1;

查询第三个数 == d[3] **% 2** = (1+0+0) **% 2**  =1;

查询第四个数 == d[4] **% 2** = (1+0+0+1)  **% 2** =0;

查询第五个数 == d[5] **% 2** = (1+0+0+1+0)  **% 2** =0;

话不多说，直接上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long d[100010], n ,m;

long long lowbit( long long x ){
	return x & (-x);
}

//树状数组的lowbit 运算，可以百度一下

void add(long long x,long long v){
	while(x<=n){
		d[x]+=v; //给每一个数的前缀和加上v;
		x+=lowbit(x); //下一个祖先
	}
}
                
long long res; //定义在函数内部容易超时
                
//询问a的前缀和
long long ask(long long a){
	res=0;
	while(a!=0){
		res+=d[a];
		a-=lowbit(a);
	}
	return res;
}
                
long long h,x,y;
                
int main(){
	cin>>n>>m;
	while(m--){
		cin>>h;
		if(h==1) {
			cin>>x>>y;

  			//后面两步是重点！！！
			add(x,1); 
			add(y+1,1);
  
		}
		if(h==2){
			cin>>x;
			cout<<ask(x)%2<<endl;
		}	
	}
}
```
就这样，这道题难度中等，可以试着用线段树做一下。


---

## 作者：Refined_heart (赞：44)

这是我第一道用线段树A过的紫题啊……卡了三四次

这道题其实就是线段树区间修改和单点查询的模板啊……然而我却在区间修改的地方卡了几次……

感谢 @disangan233 的指导

唯一的坑点在于取反吧……其实每次只需要lazy_tag++就好，最后&1就完事了

（话说楼上各位大佬的函数参数好多啊……我的就一个参数……

话不多说，上代码（注释版）

CODE：

```cpp
#include<iostream>
#include<cstdio>
#define MAXN 500000
#include<cstring>
#include<string>
using namespace std;
struct node{
    long long l,r,w,f;//l 左子树编号 r 右子树编号  w  权值  f lazy_tag 
}tree[MAXN<<2];//四倍空间 
long long n,m,ans,x,y;
long long read(){//快读模板 
    long long s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
          w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        s=s*10+(ch-'0');
        ch=getchar();
    }
    return s*w;
}
void build(long long l,long long r,long long k){//建树 
    tree[k].l=l;
    tree[k].r=r;
    if(l==r){
        tree[k].w=0;//根据题意，每个叶子结点都是0
        return;
    }
    long long mid=(l+r)>>1;
    build(l,mid,k<<1);
    build(mid+1,r,k<<1|1);
    tree[k].w=tree[k<<1].w+tree[k<<1|1].w;
}
void down(long long k){//lazy_tag下传 
    tree[k<<1].f+=tree[k].f;
    tree[k<<1|1].f+=tree[k].f;
    tree[k<<1].w+=tree[k].f*(tree[k<<1].r-tree[k<<1].l+1);
    tree[k<<1|1].w+=tree[k].f*(tree[k<<1|1].r-tree[k<<1|1].l+1);
    tree[k].f=0;
}
void add(long long k){//区间修改 
    if(tree[k].l>=x&&tree[k].r<=y){
        tree[k].w+=(tree[k].r-tree[k].l+1);//此处只需要加就好，下面单点查询的时候&1就好 
		tree[k].f++;//同理 
        return;
    }
    if(tree[k].f)//lazy_tag 下传 
      down(k);
    long long mid=(tree[k].l+tree[k].r)>>1;
    if(x<=mid)//线段树优化所在：二分 
      add(k<<1);
    if(y>mid)
      add(k<<1|1);
    tree[k].w=tree[k<<1].w+tree[k<<1|1].w;
}
void ask(long long k){//单点查询 
    if(tree[k].l==tree[k].r){
        ans=tree[k].w&1;//同上所述 ，取反只需要输出时&1 
        return;
    }
    if(tree[k].f)//lazy_tag 下传 
      down(k);
    int mid=(tree[k].l+tree[k].r)>>1;
    if(x<=mid)
      ask(k<<1);
    else
      ask(k<<1|1);
}
int main(){
    n=read();
    m=read();
    build(1,n,1);
    for(register int i=1;i<=m;i++){
        int p=read();
        ans=-1;//此处无所谓 
        if(p==1){
            x=read();
            y=read();
            add(1);
        }
        else{
            x=read();
            ask(1);
            printf("%lld\n",ans);
        }
    }
    return 0;//完美结束~ 
}
```

（看在我第一次发题解给我过了吧~

---

## 作者：XY_cpp (赞：30)

~~吧咔吧咔~~

让我写一篇题解

这题显然线段树可以解决，但是编程复杂度很大，考虑树状数组。

上图，方便讲解

![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=a565892f4790f60310bd9415587bd87e/0dd7912397dda14482d369acbfb7d0a20df486d1.jpg)

~~树状数组不懂的自行刷模板~~

###  对于操作1


用C[i]表示对其区间表示范围内的元素修改了几次

故可以用类似于树状数组中点修改的操作

考虑修改区间[3,6]

先把[1,6]的元素全部进行一次操作，具体为C[6]++,C[4]++

但是我们修改的是[3,6]，故再对[1,2]内的元素进行一次操作，具体为C[2]++

所以有代码

```cpp

void fix(int x)
{
    while(x>0)
    {
        c[x]++;
        x-=lowbit(x);
    }
}

```
主函数内调用fix(r),fix(l-1)即可

###  对于操作2

累加它所有祖先的权值,如果为偶数，该数为0，反则为1


所以有代码

```cpp
int ask(int x)
{
    int res=0;
    while(x<=n)
    {
        res+=c[x];
        x+=lowbit(x);
    }
    return res;
}
```

完整代码
```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&(-x))
using namespace std;
int n,m;
const int maxn=1e5+5;
int c[maxn];
void fix(int x)
{
    while(x>0)
    {
        c[x]++;
        x-=lowbit(x);
    }
}
int ask(int x)
{
    int res=0;
    while(x<=n)
    {
        res+=c[x];
        x+=lowbit(x);
    }
    return res;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int t;
        scanf("%d",&t);
        if(t==1)
        {
            int l,r;
            scanf("%d%d",&l,&r);
            fix(r),fix(l-1);
        }
        else if(t==2)
        {
            int x;
            scanf("%d",&x);
            printf("%d\n",ask(x)%2);
        }
    }
    return 0;
}
```



---

## 作者：hht2005 (赞：15)

看大家用的都是树状数组，赶紧来一发线段树。

思路：简单线段树，只要把区间加改成区间xor即可。
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int t[400010];//如果t[i]不为叶子节点，t[i]为标记，否则t[i]为数值
void down(int k)
{
    if(t[k])
    {
        t[k<<1]^=1;
        t[k<<1|1]^=1;
        t[k]=0;
    }
}
void change(int k,int l,int r,int x,int y)
{
    if(x<=l&&r<=y)//如果当前区间完全被修改区间包含，整体xor
    {
        t[k]^=1;
        return;
    }
    down(k);//下传标记
    int mid=(l+r)>>1;
    if(x<=mid)change(k<<1,l,mid,x,y);
    if(mid<y)change(k<<1|1,mid+1,r,x,y);
}
int ask(int k,int l,int r,int x)
{
    if(l==r)return t[k];
    down(k);//下传标记
    int mid=(l+r)>>1;
    if(x<=mid)return ask(k<<1,l,mid,x);
    else return ask(k<<1|1,mid+1,r,x);
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int k,x,y;
        scanf("%d%d",&k,&x);
        if(k==1)
        {
            scanf("%d",&y);
            change(1,1,n,x,y);
        }
        else
            printf("%d\n",ask(1,1,n,x));
    }
    return 0;
}


```


---

## 作者：da32s1da (赞：12)

一句话题意：区间取反，单点查询。

很明显答案就是这个点被取反的次数mod 2 的值。

所以现在把问题转化成：区间加1，单点查询。

树状数组裸题。

```
#include<cstdio>
const int N=1e5+50;
int n,m,opt,x,y,ans;
int a[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d%d",&x,&y);
			for(int j=x;j<N;j+=(j&-j))a[j]++;
			for(int j=y+1;j<N;j+=(j&-j))a[j]--;
            //[x-N)+1,[y+1,N)-1
		}else{
			scanf("%d",&x);ans=0;
			for(int j=x;j;j-=(j&-j))ans+=a[j];
            //统计被取反了多少次
			printf("%d\n",ans&1);//取反次数mod 2
		}
	}
}
```

---

## 作者：地铁dixiatielu (赞：9)

## 吸氧分块做法
看到TJ里好像没有用分块做的，于是蒟蒻就来发一条用bitset分块的TJ

分块，是一种时间复杂度带根号的做法。虽然劣于线段树和树状数组，导致此题分块需要吸氧才能跑过，但是个人觉得分块代码比线段树好打多了，也比树状数组更容易理解...

### 题意分析
------------
一个01数组，给出两个操作，分别是区间翻转01和单点查询.要求输出查询结果
### 思路1-暴力
------------
看到题目，首先想到的就是直接暴力大模拟，实测大模拟加快读可拿80pts
![](https://cdn.luogu.com.cn/upload/image_hosting/7x3xbe05.png)
**暴力核心代码($\text{qin}$是快读)：**
```cpp
int ccf,a[N],poo;
signed main()
{
   	qin >> n >> m;
	while(m--)
	{
		qin >> ccf;
		if(ccf == 1)
		{
			qin >> l >> r;
			for(reg int i = l;i <= r;i++)
			{
				a[i] = !a[i];
			}
		}
		else
		{
			qin >> poo;
			printf("%d\n",a[poo]);
		}
	}
    return 0;
}
```
### 思路2-~~优雅的暴力~~-分块
~~分块其实真的是一种优雅的暴力~~

**分块的思路**

由于暴力明显会T掉，我们可以把数组中的$n$个元素分成$\sqrt{n}$个有着$\sqrt{n}$个元素的小块，即开$\sqrt{n}$个大小为$\sqrt{n}$的$\text{bitset}$。说到$\text{bitset}$，下面介绍一下$\text{bitset}$的一些用法：

$\text{bitset}$是$\text{C++STL}$容器之一，使用$\text{bitset}$，可以代替一定大小的$\text{bool}$数组，而且$\text{bitset}$由于一位就使用一个$\text{bit}$的空间，所以还比$\text{bool}$数组省空间。此外，$\text{bitset}$还有二进制与10进制互转，2进制与字符串互转等功能。此题中主要使用它的代替$\text{bool}$数组的功能。

**$\text{bitset}$的声明**
```cpp
std::bitset<[size]> s;//size为bitset大小，s为bitset变量名（当然可以开数组）
```
**$\text{bitset}$的某些用法(默认已使用标准命名空间)**
```cpp
s.test(i)//查询s中的第i位是否为1，是返回true，否返回false
s.set([i])//将s的第i位设置为1，不填i则将整个bitset全部设为1
s.reset([i])//将s的第i位设置为0，不填i则将整个bitset全部设为0
s.flip([i])//将s的第i位取反，不填i则将整个bitset全部取反（比用for循环异或稍微快一点）
```
看题目数据范围，发现:
$$1 \leq n \leq 10^5, 1 \leq m \leq 5 × 10^5$$
~~窝当时把数据范围看成$50\%$的了...还导致我发了个贴qwq~~

于是我们就可以直接定义每一块的大小：
```cpp
const int blk_sze = 320;
bitset<blk_sze> s[319];//每一块下标从0开始，块的编号下标也从0开始
```
做好了准备，了解了前置知识，我们终于可以开始写代码了$\text{AwA}$

### 以下是完整代码

```cpp
#include <cstdio>
#include <bitset>
#define reg register
using namespace std;
int n,m,l,r,op,pos,lid,rid,llid,rrid,blkid,in_blkid;
const int blk_sze = 320;//320个1块(0~319) 320~639 640~959......
bitset<blk_sze> s[319];
int main()
{
	scanf("%d%d",&n,&m);//读入
	for(reg int i = 1;i <= m;i++)
	{
		scanf("%d",&op);//读入
		if(op == 1)//操作1
		{
			scanf("%d%d",&l,&r);//读入左端点和右断点
			l--;
			r--;//由于我们的块的下标和块内下标都是从0开始，而读入数据默认是从1开始，所以这里l和r都要-1
			lid = l / blk_sze;
			rid = r / blk_sze;//计算左端点所处块，右端点所处块的编号
			for(reg int j = lid + 1;j < rid;j++)
			{
				s[j].flip();
			}//把左右端点之间的块全部直接整块取反
			llid = l % blk_sze;//左边界在左端点所处块内的位置
			rrid = r % blk_sze;//右边界在右端点所处块内的位置
			if(lid != rid)//如果左右边界不在同一块中
			{
				for(reg int j = llid;j < blk_sze;j++)
				{
					s[lid].flip(j);
				}
				for(reg int j = 0;j <= rrid;j++)
				{
					s[rid].flip(j);
				}
			}
			else//如果左右端点在一个块中
			{
				for(reg int j = llid;j <= rrid;j++)
				{
					s[lid].flip(j);//这里的lid也可以改成rid，是一样的
				}
			}//进行这样的判断是为了防止左右端点在同一块的情况导致那整个块都被直接取反
		}
		else//操作2
		{
			scanf("%d",&pos);//读入位置
			pos--;
			blkid = pos / blk_sze;//pos所处块的编号
			in_blkid = pos % blk_sze;//pos所处块的块内位置
			printf("%d\n",s[blkid].test(in_blkid));//输出答案
		}
	}
	return 0;
}
```
### 最终结果
![](https://cdn.luogu.com.cn/upload/image_hosting/qk70ekif.png)
### 后言
可能用打标记开数组的那种分块能不吸氧A掉此题？我没试过...不知道有没有神犇能写出来试试$\text{QwQ}$?

---

## 作者：xiejinhao (赞：8)

#  P5057 [CQOI2006]简单题 题解

### 名副其实的简单题


------------


$Part \  1$：题目解析
------------
- 有一个 $n$ 个元素的数组，每个元素初始均为 $0$。有 $m$ 条指令，有两种操作：

 1. 形如$1 \ \ l \ \ r$，将区间 $[l,r]$ 之间的数反转，反转规则是：$0$ 变为 $1$，$1$ 变为 $0$。

 1. 形如 $2 \ \ x$，输出数组下标为 $x$ 的值。
 
**样例：**

当 $n = 20, \ m = 10$时：

![](https://i.loli.net/2019/07/18/5d300df793c2441541.png)

~~~
    输入样例：       输出样例：
    20 10            1
    1 1 10           0
    2 6              0
    2 12             0
    1 5 12           1
    2 6
    2 15
    1 6 16
    1 11 17
    2 12
    2 6
~~~
原题链接：[P5057 [CQOI2006]简单题](https://www.luogu.org/problemnew/show/P5057)

- 由$1$变$0$，$0$变$1$这一波操作你们想到了什么？其实这就是**异或**，也叫作**不进位加法**：

$$10111010 \ xor \ 10001011=10111010 \ \text{不进位加} \ 10001011=00110001$$

我们只需要把**单点异或**一个 $1$ 即可。然后就是线段树的裸题，但与线段树不同的是，**这一题线段树只维护区间标记即可，不需要维护其他区间的值。**

为什么呢？**因为我们需要单点查询，维护的是单点的值，而不是区间的值。**

（但是很多人有写区间值，我觉得没有必要吧）

那么，我们就只需要负责打懒标记，在查询的时候，若有懒标记，那就更新，否则不更新；并且，我们不要要任何上传操作。



------------

$Part \ 2:Code$
------------

```cpp
    #include<bits/stdc++.h>
    #define ls(x) x<<1
    #define rs(x) x<<1|1
    using namespace std;

    const int SIZE = 1e5 + 10;

    struct SegmentTree {
        int l, r, val;
        int tag;
        //区间不修改，val用于存单点 
    }t[SIZE << 2];

    //建树 
    void build(int p, int l, int r) {
        t[p].l = l, t[p].r = r;
        if(l == r) return;
        int mid = (l + r) >> 1;
        build(ls(p), l, mid);
        build(rs(p), mid + 1, r);
    }

    //标记下传 
    void spread(int p) {
        //只需要维护标记即可 
        if(t[p].tag) {
            t[ls(p)].tag ^= 1;
            t[rs(p)].tag ^= 1;
            t[p].tag = 0;
        }	
    }

    //区间修改，实为单点修改 
    void change(int p, int l, int r) {
        if(l <=t[p].l && r >= t[p].r) {
            t[p].tag ^= 1;
            return;
        }
        spread(p);
        int mid = (t[p].l + t[p].r) >> 1;
        if(l <= mid) change(ls(p), l, r);
        if(r > mid) change(rs(p), l, r);
    }

    //单点查询 
    int ask(int p, int x) {
        if(t[p].l == t[p].r) {
            if(t[p].tag) {
                t[p].val ^= 1;
                t[p].tag = 0;
            }
            return t[p].val;
        }
        spread(p);
        int mid = (t[p].l + t[p].r) >> 1;
        if(x <= mid) return ask(ls(p), x);
        else return ask(rs(p), x);
    }

    int main() {
        int n, m;
        scanf("%d %d", &n, &m);
        build(1, 1, n);
        for(int i = 1; i <= m; i++) {
            int p, l, r;
            scanf("%d", &p);
            if(p == 1) {
                scanf("%d %d", &l, &r);
                change(1, l, r);
            }
            else {
                scanf("%d", &l);
                printf("%d\n", ask(1, l));
            }
        }
        return 0;
    }
```

$END$
------------
**~~线段树大法好~~**

对于线段树的学习，个人认为有以下几点：

 1. 学会灵活运用，找到属于自己的风格，不要死记。

 1. 多做题，不会要多问，心态要好，不要做题做到心态爆炸。

 1. 熟练之后要多拓展，比如主席树等，题型也要广泛，不能只做单一类型的线段树的题目。

这对于其他算法甚至其他学科的学习应该也是差不多的吧？

### 最后祝大家$CSP \ 2019$  $ \ \ \ rp++$

----------------------------

## $Update \ 2019.11.14$

把 $NOIP$ 改成了 $CSP$，希望管理重审哇$QwQ$

---

## 作者：skydogli (赞：8)

### 大家好,我是一个连分块都不会~~不想打~~的蒟蒻,于是我就用$bitset$水过了这题

**另外,小蒟蒻其实不是很熟悉$bitset$,如果写得不优,还请大佬轻D**

en...让我们理性分析一下时间复杂度:$O(\frac{nm}{w})$,$w$为64,那也到了接近$8e8$的复杂度.....可以说是相当硬核的$AC$了.

本题的题意相当清晰,只需要提供$2$种操作:

$1$.区间异或

$2$.求某一位上的值

很明显都是可以用$bitset$来做的,这里讲讲$bitset$的基本操作(也可以去看[洛谷日报](https://www.luogu.org/blog/fusu2333/fu-su-di-bitset-qian-tan):

##### 头文件
~~都9102年了还不用万能库?~~
```cpp
#include<bitset>
```

##### 定义

```cpp 
std::bitset<位数>bit;

```

##### 初始化
```cpp
bit.set();//全部变成1
bit.reset();//全部变成0
```

##### 位运算
和正常位运算一样

##### 求某1位的值
和数组一致

然后回到这题,对于区间异或,我们可以先全部赋值为1,然后先右移使$bitset$中正好有$r-l+1$个1,再将它左移(l-1)位($bitset$也是从0开始),与原来的$bitset$进行异或操作就行了

询问?直接输出$s[i-1]$(从$0$
开始)

#### 然后这题就愉快地水过啦!
**另外自带大常数的同学们,$O_3$和$Ofast$可以在$O_2$的基础上再减小50%的常数哦(逃**

#### 代码:
```cpp
// luogu-judger-enable-o2
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
#define getchar() (p1==p2 and (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
//fread快读优化模板拿走不谢
inline void read(int &a){
    a=0;
    char c=getchar();
    while(c>57 or c<48)c=getchar();
    while(47<c and c<58){
        a=a*10+c-48;
        c=getchar();
    }
}
int n,m,opt,l,r;
std::bitset<100000>bit,ha;//bit为原来的bitset
//乱取的变量名是因为真的想不到能AC(逃)
int main(){
    read(n);read(m);
    for(int i=1;i<=m;++i){
        read(opt);
        if(opt&1){
            read(l);read(r);
            int lon=r-l+1;
            int p=100000-lon;
            ha.set();
            ha>>=p;
            //右移至只剩r-l+1个1
            ha<<=(l-1);//移到l-r的位置
            bit^=ha;
        }
        else{
            read(l);
            puts(bit[l-1]?"1":"0");
            //bitset用print会警告,不过也无所谓
        }
    }
    return 0;
} 
```

---

## 作者：mrsrz (赞：8)

我不会数据结构咋办啊？

别慌，咱们来分个块/xyx

对每个块内打翻转标记。

翻转操作，块内的直接修改翻转标记，边角的直接暴力修改。

时间复杂度$O(m\sqrt n)$，能用bitset做到比较优秀的空间复杂度（所以这题空间限制为啥不是1MB啊）。

## Code：
```cpp
#define scanf __builtin_scanf
#define putchar __builtin_putchar
#define bel(a)((a-1)/318+1)
template<int MAXN>
struct BitSet{
	static const int SIZE=MAXN/64+1;
	long long b[SIZE];
	inline void flip(int i){b[i>>6]^=(1uLL<<(i&63));}
	inline int test(int i){return b[i>>6]>>(i&63)&1;}
};
BitSet<100001>b;
BitSet<319>t;
int main(){
	int n,m;
	for(scanf("%d%d",&n,&m);m--;){
		int o;
		scanf("%d",&o);
		if(o==1){
			int l,r;scanf("%d%d",&l,&r);
			const int L=bel(l),R=bel(r);
			if(L==R)for(int i=l;i<=r;++i)b.flip(i);else{
				for(int i=L+1;i<R;++i)t.flip(i);
				for(int i=l;bel(i)==L;++i)b.flip(i);
				for(int i=r;bel(i)==R;--i)b.flip(i);
			}
		}else{
			int x;
			scanf("%d",&x);
			putchar(b.test(x)^t.test(bel(x))^'0');
			putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：花里心爱 (赞：2)

水一篇题解qwq

一道区间修改，单点查询的数据结构题。

这题可以用线段树轻松维护~~然而我太懒了想用树状数组水过去~~

考虑差分，设$b[i]$为差分数组，那么元素$a[i]$的值为前$i$个$b[j]$的异或和。

每次修改的时候只需要修改差分数组$l$和$r+1$即可。

根据这样的思路，我们就把它转化为了一道单点修改，区间查询的题。

用树状数组维护$b[i]$即可。

下面上代码 :
```
#include <cstdio>
#include <cctype>
#define maxn 100005
inline int read() {
	int d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
	while(isdigit(ch)){d=d*10+ch-48;ch=getchar();}return d;
}
inline int lowbit(int x) {
	return x&(-x);
}

int n, m, c[maxn];
int op, l, r;

void modify(int pos) {
	for(; pos <= n; pos += lowbit(pos))
		c[pos] ^= 1;
}
int query(int pos) {
	int ans = 0;
	for(; pos; pos -= lowbit(pos))
		ans ^= c[pos];
	return ans;
}

int main() {
	n = read(), m = read();
	while(m--) {
		op = read();
		if(op == 1) {
			l = read(), r = read();
			modify(r+1), modify(l);
		}
		else {
			l = read();
			printf("%d\n", query(l));
		}
	}
	return 0;
}
```

---

## 作者：ciwomuli (赞：1)

翻了翻题解区，发现并没有人用线段树做这道题。  
区间修改，单点查询，线段树模板改一改就过了。  
连update都不用。
代码：
```cpp
#include <algorithm>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#include <stack>
#include <vector>
#define LL long long
#define P pair<int,int>
using namespace std;
template <typename T>
inline void read(T &t)
{
    int f = 0, c = getchar();
    t = 0;
    while (!isdigit(c))
        f |= c == '-', c = getchar();
    while (isdigit(c))
        t = t * 10 + c - 48, c = getchar();
    if (f)
        t = -t;
}
template <typename T, typename... Args>
inline void read(T &t, Args &... args)
{
    read(t);
    read(args...);
}
const int maxn=500005;
int lch[maxn<<2],rch[maxn<<2];
bool rev[maxn];
int tot;
void pushdown(int cur){//标记下传
    if(rev[cur]){
    	rev[lch[cur]]^=1;
    	rev[rch[cur]]^=1;
		rev[cur]=0;
	}
}
void build(int &cur,int l,int r){
    cur=++tot;
    if(l==r){
    	rev[cur]=0;
        return;
    }
    int mid=(l+r)>>1;
    build(lch[cur],l,mid);
    build(rch[cur],mid+1,r);
}
void modify(int cur,int l,int r,int ml,int mr){
    if(ml<=l && r<=mr){
        rev[cur]^=1;
        return;
    }
    int mid=(l+r)>>1;
    pushdown(cur);
    if(ml<=mid) modify(lch[cur],l,mid,ml,mr);
    if(mr>=mid+1) modify(rch[cur],mid+1,r,ml,mr);
}
bool qurry(int cur,int l,int r,int a){  //单点查询
    LL ans=0;
    if(l==r) return rev[cur]; 
    int mid=(l+r)>>1;
    pushdown(cur);
    if(a<=mid) return qurry(lch[cur],l,mid,a);
    if(a>=mid+1) return qurry(rch[cur],mid+1,r,a);
}
int n,m;
int root;
int main(){
    read(n,m);
    build(root,1,n);
    for(int i=1;i<=m;i++){
        int t,x,y;
        read(t);
        if(t==1){
        	read(x,y);
            modify(root,1,n,x,y);
        }else{
        	read(x);
            printf("%d\n",(int)qurry(root,1,n,x));
        }
    }
}
```

---

## 作者：decoqwq (赞：1)

线段树裸题

我们对每个区间反转操作，就相当于对这个区间的值异或$1$，然后就是线段树基本操作，打上标记下次$pushdown$就行了...

要注意反转的时候要一起把值也更新了，这里求的是单点值，可以看作求区间和的退化版，更新值只需要$sum[o]=(rg-lf+1)-sum[o]$就行了

然后单点查询，直接按套路来就行啦QAQ

```cpp
#include <bits/stdc++.h>
using namespace std;
int sum[400040],addv[400040],a[100010];
void pushdown(int o,int lf,int rg)
{
	if(addv[o])
	{
		addv[o<<1]^=1;
		addv[o<<1|1]^=1;
		int mid=(lf+rg)>>1;
		sum[o<<1]=(mid-lf+1)-sum[o<<1];
		sum[o<<1|1]=(rg-mid)-sum[o<<1|1];
		addv[o]=0;
	}
}
void rev(int o,int lf,int rg,int l,int r)
{
	if(l<=lf&&rg<=r)
	{
		addv[o]^=1;
		sum[o]=(rg-lf+1)-sum[o];
		return ;
	}
	pushdown(o,lf,rg);
	int mid=(lf+rg)>>1;
	if(l<=mid)
	{
		rev(o<<1,lf,mid,l,r);
	}
	if(mid<r)
	{
		rev(o<<1|1,mid+1,rg,l,r);
	}
	sum[o]=sum[o<<1]+sum[o<<1|1];
}
int query(int o,int lf,int rg,int w)
{
	if(lf==rg)
	{
		return sum[o];
	}
	pushdown(o,lf,rg);
	int mid=(lf+rg)>>1;
	if(w<=mid)
	{
		return query(o<<1,lf,mid,w);
	}
	if(mid<w)
	{
		return query(o<<1|1,mid+1,rg,w);
	}
}
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int opt,l,r;
		scanf("%d%d",&opt,&l);
		if(opt==1)
		{
			scanf("%d",&r);
			rev(1,1,n,l,r);
		}
		else
		{
			printf("%d\n",query(1,1,n,l));
		}
	}
}
```

---

## 作者：installb (赞：1)

## 0.前言  
有些题看上去很奇怪 比如什么**连续序列数字反转**之类的 但是要看清这些东西的本质是什么  
这题解法很多 我这里先列两种吧  

## 1.主要思路  
每次区间操作处理 是 $0$变$1$ $1$变$0$  
这种区间操作 容易想到线段树这类的东西  
那就尝试往这个方向靠  
这时候我们把每一个点的数看作一个二进制数 每一次操作视为这个二进制数+1 我们需要查询的就是这个二进制数的最后一位 就可以了  
**不够直观? 其实就是直接加1 查询时判断数的奇偶性**  

## 2.0 解法1 - 线段树  
区间修改型的题目 当然线段树可以做  
线段树应该是所有数据结构的入门了  
[模板题传送门](https://www.luogu.org/problemnew/show/P3372)
### code:  
```cpp
#include <map>
#include <list>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define mid ((l + r) >> 1)
#define lson (x << 1)
#define rson ((x << 1) | 1)
// 这里我define的时候用了位运算  
// define的时候一定不要忘了在外面套一层括号
using namespace std;
typedef long long LL;

LL a[100005] = {0};
LL val[800005] = {0};
LL add[800005] = {0};

void build(int x,int l,int r){
    if(l == r){
        val[x] = a[l];
        return;
    }
    build(lson,l,mid);
    build(rson,mid + 1,r);
    val[x] = val[lson] + val[rson];
}

void pushdown(int x,int l,int r){
    if(!add[x]) return;
    add[lson] += add[x]; val[lson] += (mid - l + 1) * add[x];
    add[rson] += add[x]; val[rson] += (r - mid) * add[x];
    add[x] = 0;
}

void modify(int x,int l,int r,int L,int R,int v){ // 区间加
    if(L <= l && r <= R){
        val[x] += (r - l + 1) * v;
        add[x] += v;
        return;
    }
    pushdown(x,l,r);
    if(L <= mid) modify(lson,l,mid,L,R,v);
    if(R > mid) modify(rson,mid + 1,r,L,R,v);
    val[x] = val[lson] + val[rson];
}

LL query(int x,int l,int r,int L,int R){ // 区间求和
    if(L <= l && r <= R) return val[x];
    LL res = 0;
    pushdown(x,l,r);
    if(L <= mid) res += query(lson,l,mid,L,R);
    if(R > mid) res += query(rson,mid + 1,r,L,R);
    val[x] = val[lson] + val[rson];
    return res;
}

int n,m,op,f,t,c;

int main(){
    scanf("%d %d",&n,&m);
    build(1,1,n); // 别忘了建树
    while(m --){
        scanf("%d",&op);
        if(op == 1){ scanf("%d %d",&f,&t); modify(1,1,n,f,t,1); }
        // 每次+1即可
        if(op == 2){ scanf("%d",&f); printf("%lld\n",query(1,1,n,f,f) & 1); }
        // 单点查询a就是查询区间[a,a]
        // 这里&1操作就是取该位置值的最后一位是1还是0了
    } 
    return 0;
}
```
优点:模板 好想  
缺点:代码长度偏大 常数大 ~~其实也不差这一点~~

## 2.1 解法2 - 树状数组  
不会树状数组点[这里](https://www.luogu.org/problemnew/show/P3374)  
这个就不那么模板了 基础的树状数组是不支持区间修改的  
~~但是在洛谷有一个这样的模板~~  
[传送门](https://www.luogu.org/problemnew/show/P3368)  
由于这题是单点查询 所以是可以用这个模板题的解法做的  
大概讲一下 运用差分的思想  
比如这样一个数组 $1\ ,3\ ,7\ ,4\ ,8$  
我们取每两个数之间的差 产生另外一个数组  
$1-0\ ,3-1\ ,7-3\ ,4-7\ ,8-4$  
$1\ ,2\ ,4\ ,{-3}\ ,4$  
而前$i$个数的和就是原数组第$i$位的值  
修改时 由于一个区间的数同加同减 只需要改变区间两端所对应的差分数组的值就可以了  

~~不需要注释了吧~~
### code:
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#define lowbit(x) (x & (-(x)))
//lowbit直接define掉 还是注意括号
using namespace std;
typedef long long LL;

LL n,m,q,a,b,c;
LL tr[1000005] = {0};

void add(LL x,LL val){ for(;x <= n;x += lowbit(x)) tr[x] += val; }
// 单点加
LL query(LL x){ LL res = 0; for(;x;x -= lowbit(x)) res += tr[x]; return res; }
// 前缀和  
// 这里习惯性压行了

int main(){
    scanf("%lld %lld",&n,&m);
    while(m --){
        scanf("%lld",&q);
        if(q == 1){ scanf("%lld %lld",&b,&c); add(b,1); add(c + 1,-1); }
        // 修改
        if(q == 2){ scanf("%lld",&a); printf("%lld\n",query(a) & 1); }
        // 查询 &1 输出
    }
    return 0;
}
```  
优点:短 常数小  
缺点:比较难想?  

## what's more?  
线段树的题都很多可以用分块做 这题也可以  
但是分块$n\sqrt{n}$的复杂度 和$log$比确实大了点  
而且这题使用分块也有点杀鸡用牛刀了 没必要吧  
~~不过分块作为一种优雅的暴力确实可以做很多数据结构题 而且相对好写~~

---

## 作者：Caicz (赞：0)

### 数据结构---树状数组
**第一眼看到这道题时，当时的想法是线段树，可蒟蒻不会线段树，所以------就有了树状数组**

先看看题目，**区间修改**，额....似乎用树状数组无法处理，
再仔细一看，**01序列，每次修改都为 _翻转_** ，那么我们就可以把区间修改转化为端点修改

首先，用两个数组记录  l [ n ] 与 r [ n ],每一次区间修改[ax,bx]，用 l[ax] 记录**左区间个数的前缀和**，r[bx] 记录**右区间个数的前缀和**，每一次输入进行**两次插入操作**
```cpp
void init2(int x)
{
	for(;x<=n;x+=lowbit(x))r[x]+=1;
}

void init1(int x)
{
	for(;x<=n;x+=lowbit(x))l[x]+=1;
}
```
接着，就可以用当前端点的左区间前缀和减去右区间前缀和，即**sum1（x）- sum2（x-1）**,

注意，因为区间修改为**闭区间**修改，所以当端点为该区间最大值时，计算右区间前缀和时，应计算前一个端点前缀和。
完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int l[100005],r[100005];
int n,m;

int lowbit(int a)
{
	return a&~(a-1);
}

void init2(int x)
{
	for(;x<=n;x+=lowbit(x))r[x]+=1;
}

void init1(int x)
{
	for(;x<=n;x+=lowbit(x))l[x]+=1;
}

int sum1(int x)
{
	int ret=0;
	for(;x;x-=lowbit(x))ret+=l[x];
	return ret;
}

int sum2(int x)
{
	int ret=0;
	for(;x;x-=lowbit(x))ret+=r[x];
	return ret;
}

int main()
{
	cin>>n>>m;
	int k,a,b;
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&k);
		if(k==1)
		{
			scanf("%d%d",&a,&b);
			init1(a);
			init2(b);
		}
		else
		{
			scanf("%d",&a);
			printf("%d\n",(sum1(a)-sum2(a-1))%2);
		}
	}
	return 0;
}
```


---

## 作者：EarthGiao (赞：0)

# 【树状数组】
## 【思路】
树状数组   

### 【题目大意】
区间反转和单点询问    

### 【题目分析】
区间反转我首先想到了是线段树      
用lazy标记某个区间反转过几次     
但是我是抱着练习树状数组的目的   
来做的这道题     
所以必须用树状数组做!!!   
不过树状数组该怎么办呢？    
难不成枚举每一个点然后修改？  
不对   
这个时候情不自禁想到了那个优美的东西   
差分    
类似树状数组模板2的方法     
差分一下下就可以很轻松标记翻转次数了     

### 【核心思路】
树状数组维护差分数组     
差分数组修改区间   
只需要在区间左端点加上修改的值    
在右端点之后减去修改的值就好了    
求某个位置上的值    
就是这个位置之前（包括这个位置）的和    
也符合树状数组里面的sum    
就不需要做差了   
最后按照%2来输出就好了    
因为翻转两次之后会回到原来的情况      
## 【思路】
```cpp
#include<iostream>
#include<cstdio>
#define int long long 
using namespace std;
const int Max = 100006;
int a[Max];
int n,m;
int read()
{
	int sum = 0,fg = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')fg = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		sum = sum * 10 + c - '0';
		c = getchar();
	}
	return sum * fg;
}

int lowbit(int x)
{
	return x & -x;
}

void add(int x,int y)
{
	while(x <= n)
	{
		a[x] += y;
		x += lowbit(x);
	}
}

int sum(int x)
{
	int ans = 0;
	while(x > 0)
	{
		ans += a[x];
		x -= lowbit(x);
	}
	return ans;
}

signed main()
{
	n = read(),m = read();
	for(register int i = 1;i <= m;++ i)
	{
		int t = read();
		if(t == 1)
		{
			int l = read(),r = read();
			add(l,1);
			add(r + 1,-1);
		}
		else
		{
			int qwq = read();
			cout << sum(qwq) % 2 << endl;
		}
	}
	return 0;
}
```

# 【线段树】
## 【思路】
线段树    
首先感谢@大魔鬼灿灿 巨佬帮我滑鼠标        
用树状数组做过了，但是还是可以用线段树做的       
所以也拿线段树来做回顾一下线段树，    
然后没想到调试了两个小时     

### 【核心思路】
sum记录这个点被修改的次数     
因为是区间修改和单点查询     
所以线段树中只要不是叶子节点的sum就不需要求了   
只用来lazy标记就可以了    
然后该下放到叶子节点的时候就下发好了    
最后输出记录的修改次数%2    

### 【注意事项】
不管不是叶子节点的sum没问题    
但是有的修改的时候却是单点修改    
所以该sum++还是得sum++的    
把全部节点的sum都当叶子节点的来处理    
加上修改的次数     
也就是lazy值就好了      

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define lson (k << 1)
#define rson (k << 1 | 1)

using namespace std;

int read()
{
	int sum = 0,fg = 1;
	char c = getchar();
	while(c < '0' || c > '9'){if(c == '-')fg = -1;c = getchar();}
	while(c >= '0' && c <= '9'){sum = sum * 10 + c - '0';c = getchar();}
	return sum * fg;
}
const int Max = 100004;
struct node
{
	int l,r;
	int lazy;
	int sum;
}a[Max << 2];
int n,m;
int opx,opl,opr;

void build(int k,int l,int r)
{
	a[k].l = l;a[k].r = r;
	if(l == r)
		return;
	int mid = (l + r) >> 1;
	build(lson,l,mid);
	build(rson,mid + 1,r);
	return;
}

void down(int k)
{
	if(a[k].lazy)
	{
		a[lson].sum += a[k].lazy;
		a[rson].sum += a[k].lazy;
		a[lson].lazy += a[k].lazy;
		a[rson].lazy += a[k].lazy;
		a[k].lazy = 0;
	}
}

void change(int k)
{
	if(opl <= a[k].l && opr >= a[k].r)
	{
		a[k].lazy ++;
        a[k].sum++;
		return;
	}
	down(k);
	int mid = (a[k].l + a[k].r) >> 1;
	if(opl <= mid)change(lson);
	if(opr > mid)change(rson);
	a[k].sum = a[lson].sum + a[rson].sum;
}

void query(int k)
{
	if(a[k].l == opx && a[k].r == opx)
	{
		cout << a[k].sum % 2 << endl;
        return;
	}
	down(k);
	int mid = (a[k].l + a[k].r) >> 1;
	if(opx <= mid) query(lson);
	if(opx > mid) query(rson);
}

int main()
{
	n = read(),m = read(); 
	build(1,1,n);
	for(register int i = 1;i <= m;++ i)
	{
		int qwq = read();
		if(qwq == 1)
		{
			opl = read(),opr = read();
			change(1);
		}
		else
		{
			opx = read();query(1);
		}
	}
	return 0;
}
```

---

## 作者：Derpy (赞：0)

快要~~noip~~CSP了，考前最后几天接触到了~~重口味~~zkw线段树这种神奇的东西，再被各种各样的骚操作震惊到之后，打算抓一道~~水~~题试试水。做完之后发现还没有zkw线段树的题解，所以来补一篇

具体实现看代码吧，毕竟这题比较板子，就没写的很详细，想学zkw线段树的同学可以找点别的文章~~（我讲也讲不好不是，自己都没完全弄懂）~~

附两篇大佬的教程吧[洛谷日报里的](https://www.luogu.org/blog/khong-biet/Introduction-of-zkwSegmentTree) , [另一篇也是很优秀的别的大佬写的文章](https://www.cnblogs.com/Judge/p/9514862.html)


代码：
```cpp
#include <bits/stdc++.h>
#define mx 500005
using namespace std;
int n, m, N = 1;
bool lazy[mx];
inline int FS()//快读 
{
    int x = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch))
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (isdigit(ch))
    {
        x = (x << 3) + (x << 1) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
void build()
{
    for (; N <= n + 1; N <<= 1)//计算出叶节点数量 
        ;
}
void change(int l, int r)
{
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1)//比较标准的区间修改 
    {
        if (~l & 1)
        {
            lazy[l ^ 1] = !lazy[l ^ 1];
        }
        if (r & 1)
        {
            lazy[r ^ 1] = !lazy[r ^ 1];
        }
    }
}
bool query(int p) 
{
    bool tmp = 0;
    for (int i = N + p; i; i >>= 1)//从上往下查询
    {
        if (lazy[i])
            tmp = !tmp;
    }
    return tmp;
}
int main()
{
    n = FS() ;
    m = FS();
    build();//本来用来初始化的，但这题不需要 
    while (m--)
    {
        int c1, c2, c3;
        c1 = FS();
        if (c1 == 2)
        {
            c2 = FS();
            cout << query(c2) << endl;
        }
        else
        {
            c2 = FS();
            c3 = FS() ;
            change(c2, c3);
        }
    }
    return 0;
}
```


---

## 作者：Erusel (赞：0)

~~据说这题好像有六倍经验~~

我们简单分析一下

题目要求支持两种操作，一种是区间异或1，还有一种是区间查询1的个数

考虑到所有数中只有0和1

所以查询可以改为查询区间和

区间异或1也可以从区间和的角度取考虑问题

---

假设我们原来有$k$个1，区间长度为$l$

现在就有$l-k$个1

所以$sum_{now}=l-sum_{pre}$

标记下传也可以维护了

时间复杂度就是维护一颗线段树的时间$O(nlogn)$

code:

```
// luogu-judger-enable-o2
#include<bits/stdc++.h>

#define rd(x) x=read()
#define N 200005 
 
using namespace std;

int n,m;
struct T{
	int l,r,mid,v,tag;
}t[N<<2];

inline int read()
{
    int f=1,x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    return x*f;
}

void pushdown(int rt,int len)
{
	if(t[rt].tag)
    {
        t[rt<<1].tag^=1; 
        t[rt<<1|1].tag^=1;
        t[rt<<1].v=(len-(len>>1))-t[rt<<1].v;
        t[rt<<1|1].v=(len>>1)-t[rt<<1|1].v;
        t[rt].tag=0;
    }
}

void build(int rt,int l,int r)
{
	int mid=(l+r)>>1;
	t[rt].l=l,t[rt].r=r,t[rt].mid=mid,t[rt].tag=0;
	if(l==r)
	{
		t[rt].v=0;
		return;
	}
	build(rt<<1,l,mid);
	build(rt<<1|1,mid+1,r);
	t[rt].v=t[rt<<1].v+t[rt<<1|1].v;
}

void update(int rt,int l,int r)
{
    if(l<=t[rt].l&&t[rt].r<=r)
    {
        t[rt].tag^=1;     
        t[rt].v=t[rt].r-t[rt].l+1-t[rt].v;    
        return;
    }
    pushdown(rt,t[rt].r-t[rt].l+1);
    if(l<=t[rt].mid)update(rt<<1,l,r);    
    if(t[rt].mid<r)update(rt<<1|1,l,r);        
    t[rt].v=t[rt<<1].v+t[rt<<1|1].v; 
}
int query(int rt,int l,int r)
{
    if(l<=t[rt].l&&t[rt].r<=r)return t[rt].v;
    pushdown(rt,t[rt].r-t[rt].l+1);
    int sum=0;
    if(l<=t[rt].mid)sum+=query(rt<<1,l,r); 
    if(t[rt].mid<r)sum+=query(rt<<1|1,l,r);        
    return sum;
}

int main()
{
	rd(n),rd(m);
	build(1,1,n);
	while(m--)
	{
		int opt,l,r;
		rd(opt),rd(l);
		if(opt==1)rd(r),update(1,l,r);
		else printf("%d\n",query(1,l,l));
	}
	
	return 0;
}

```

---

## 作者：Hydra_Shouko (赞：0)

### 分块题解

看题目，维护一个01序列，支持区间异或，单点查询，强制在线

看到这相信大家都知道了这道题是数据结构，这道题线段树，树状数组，分块都能AC

线段树$O(nlogn)$ 大常数，树状数组$O(nlogn)$ 小常数，分块O（$n$$\sqrt{n}$）大常数。

分块在更多场合有用 ~~(指骗分场合)~~

与线段树相比，分块的pushdown操作就是完全暴力，但线段树的pushdown或者pushup往往需要观察题目性质，或是巧妙转换维护的数据来让答案可维护，从这点上来说，分块思维难度比线段树小

考试时面对看起来像数据结构题的东西，如果意识到正解很难写时间不够调不出来，打个分块耐心调块长才是明智之举

上代码

```
#include<bits/stdc++.h>

using namespace std ;

const int MAXN = 100010;
int n,m;
struct Block{
	int l,r;
	int tag;
}blo[1000];
int fab[MAXN],a[MAXN],sq,bctr;

void set_up(){
	sq = sqrt(n);
	bctr = n/sq;
	if(n%sq) ++bctr;
	for(int i=1;i<=n;i++)
		fab[i] = (i-1)/sq+1;
	for(int i=1;i<bctr;i++){
		blo[i].l = (i-1) * sq + 1;
		blo[i].r = i * sq; 
	}
	blo[bctr].l = (bctr-1) * sq + 1;
	blo[bctr].r = n;
}

void pushdown(int x){
	for(int i=blo[x].l;i<=blo[x].r;i++)
		a[i] ^= 1;
	blo[x].tag = 0;
}

void change (int x,int y){
	if(fab[x] == fab[y]){
		if(blo[fab[x]].tag) pushdown(fab[x]);
		for(int i=x;i<=y;i++)
			a[i] ^= 1;
		return;
	}
	if(blo[fab[x]].l != x){
		if(blo[fab[x]].tag) pushdown(fab[x]);
		for(int i=x;i<=blo[fab[x]].r;i++)
			a[i] ^= 1;
	}
	else blo[fab[x]].tag ^= 1;
	if(blo[fab[y]].r != y){
		if(blo[fab[y]].tag) pushdown(fab[y]);
		for(int i=blo[fab[y]].l;i<=y;i++)
			a[i] ^= 1;
	}
	else blo[fab[y]].tag ^= 1;
	for(int i=fab[x]+1;i<=fab[y]-1;i++)
		blo[i].tag ^= 1;
	return;
}

int ask(int x){
	return a[x]^blo[fab[x]].tag;
}

int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	set_up();
	for(int i=1;i<=m;i++){
		int t,x,y;
		cin>>t;
		if(t == 1){
			cin>>x>>y;
			change(x,y);
		}
		if(t == 2){
			cin>>x;
			cout<<ask(x)<<endl;
		}
	}
	return 0;
}
```
### TAG ： SIN_XIII ⑨

---

## 作者：cyn2006 (赞：0)

**所有题解中可能我用的方法最 ~~慢~~ 暴力**

此题可以很好地练一练分块算法


------------


## 分块

首先观察到$t=1$时操作是区间取反，再仔细观察一下发现

* $a_i$^$=1$

* 暴力加$1$，即$a_i=(a_i+1)$&$1$

~~异或取反就不讲了~~

对于操作一，可以感性地理解为区间加一

查询意味着单点$%2$

于是压一压常数，分块代码就出来啦~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 100005
#define rep(i,x,y) for(int i=x;i<=y;i++)
ll pre[N],add[N],a[N];
int bel[N],cnt,n,m;
template<typename T> inline void read(T&x) {
    char ch=getchar();
    x=0;
    bool f=0;
    for(; ch<'0'||ch>'9'; ch=getchar())if(ch=='-')f=1;
    for(; ch>='0'&&ch<='9'; x=(x<<1)+(x<<3)+(ch&15),ch=getchar());
    if(f)x=-x;
}
template<typename T> inline void write(T x) {
    if(x<0)x=-x,putchar('-');
    if(x>9)write(x/10);
    putchar(x%10|48);
}
template<typename T> inline void writeln(T x) {
    write(x),putchar('\n');
}
void Res(int x){
	pre[x]=0;
	rep(i,(x-1)*cnt+1,min(cnt*x,n))pre[x]+=a[i];
}
void update(int l,int r){
	rep(i,l,min(bel[l]*cnt,r))a[i]++;
	Res(bel[l]);
	if(bel[l]!=bel[r]){
		rep(i,(bel[r]-1)*cnt+1,r)a[i]++;
		Res(bel[r]);
	}
	rep(i,bel[l]+1,bel[r]-1)add[i]++;
}
ll query(int l,int r){
	ll ans=0;
	rep(i,l,min(bel[l]*cnt,r))ans+=a[i]+add[bel[i]];
	if(bel[l]!=bel[r]){
		rep(i,(bel[r]-1)*cnt+1,r)ans+=a[i]+add[bel[i]];
	}
	rep(i,bel[l]+1,bel[r]-1)ans+=pre[i]+add[i]*cnt;
	return ans;
}
int main(){
	cin>>n>>m;
	cnt=(int)sqrt(n);
	rep(i,1,n){
		//scanf("%lld",&a[i]);
		bel[i]=(i-1)/cnt+1;
	}
	//for(int i=1;i<=n;i++)pre[bel[i]]+=a[i];
	while(m--){
		int opt,x,y;
		read(opt),read(x);
		if(opt==1){
			read(y),update(x,y);
		}else{
			writeln(query(x,x)&1);
		}
	}
	return 0;
} 
//BY CYN 
```

### $Update$ $on$ $4.25$ , $2019$：

块的大小改为$n^{\frac{1}{3}}$更快

---

## 作者：muller (赞：0)

因为是单点查询与区间修改

我们可以考虑差分，结果既是前缀和

修改的时候改 l 和 r+1 两个点。

l产生影响，r+1消除影响

用树状数组或线段树维护。

其实也可以不差分，直接分块的qwq

当然你也可以线段树，就有点像usaco的一道题，维护lazy标记

然后不断下穿即可

注意操作是异或1不是清零

代码有点丑，不给了！（放我一码吧ths）

---

## 作者：__QL__ (赞：0)

可以用一个数组记录序列每一位被翻转了多少次

>1操作就对数组区间+1; 

>2操作就是单点查询

显然可以用树状数组维护这个数组

如果翻转次数为奇数, 结果为1, 否则为0

```cpp
#include<cstdio>
using namespace std;

inline int read()
{
    int x = 0, k = getchar();
    while(k > '9' or k < '0')
    {
        k = getchar();
    }
    while(k <= '9' and k >= '0')
    {
        x = (x * 10) + (k & 15);
        k = getchar();
    }
    return x;
}

const int MAXN = 100005;
int N, M, a[MAXN], c[MAXN];

inline int Lowbit(int x){ return x & (-x); }

inline void Update(int pos, int val)
{
    while(pos <= N)
    {
        c[pos] += val;
        pos += Lowbit(pos);
    }
    return;
}

inline int Query(int pos)
{
    int res = 0;
    while(pos > 0)
    {
        res += c[pos];
        pos -= Lowbit(pos);
    }
    return res;
}

int main()
{
    N = read(), M = read();
    int a_, b_, c_;
    for(int i = 1; i <= M; ++i)
    {
        a_ = read();
        if(a_ == 1)
        {
            b_ = read(), c_ = read();
            Update(b_, 1); Update(c_ + 1, -1);
        }
        else
        {
            b_ = read();
            printf("%d\n", Query(b_) & 1 );
        }
    }
    return 0;
}
```


---

## 作者：iodwad (赞：0)

[Welcome to my Blog](https://zcdhj.org)

可以看成是翻转奇偶性，那么用树状数组来维护区间修改/单点查询就行了。

```cpp
#include <iostream>
#include <cstdio>

const int MAXN = 1e5;

int n, m;
int bit[MAXN | 1];

inline int read() {
    register int x = 0;
    register char ch = getchar();
    while(!isdigit(ch)) ch = getchar();
    while(isdigit(ch)) {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x;
}

inline void modify(int x, int y) {
    for(x; x <= n; x += x & (-x)) {
        bit[x] += y;
    }
}

inline int query(int x) {
    int res = 0;
    while(x > 0) {
        res += bit[x];
        x -= x & (-x);
    }
    return res;
}

int main() {
    n = read();
    m = read();
    while(m--) {
        int opt = read();
        if(opt == 1) {
            int a = read();
            int b = read();
            modify(a, 1);
            modify(b + 1, -1);
        } else printf("%d\n", query(read()) & 1);
    }
    return 0;
}
```



---

## 作者：DukeLv (赞：0)

这个题算是一道线段树练手题，而且该题的特点是不用维护原数组，查询的时候直接可以查lazy标记即可，区间翻转自然位运算更优秀啦。其中有些易错的细节在代码里说。

有部分大佬觉得做完这道题不过瘾，可以试一下这道题[[SCOI2010]序列操作](https://www.luogu.org/problemnew/show/P2572)，是这道题的升级版，可以考验大家是否真正掌握了线段树这种数据结构。大家可以试试呀。

代码:

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<ctime>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
#define duke(i,a,n) for(register int i = a;i <= n;i++)
#define lv(i,a,n) for(register int i = a;i >= n;i--)
#define clean(a) memset(a,0,sizeof(a))
const int INF = 1 << 30;
typedef long long ll;
typedef double db;
template <class T>
void read(T &x)
{
	char c;
	bool op = 0;
	while(c = getchar(), c < '0' || c > '9')
		if(c == '-') op = 1;
	x = c - '0';
	while(c = getchar(), c >= '0' && c <= '9')
		x = x * 10 + c - '0';
	if(op) x = -x;
}
template <class T>
void write(T x)
{
	if(x < 0) putchar('-'), x = -x;
	if(x >= 10) write(x / 10);
	putchar('0' + x % 10);
}
const int N = 5e5 + 5;
int lazy[N << 2];
void push_down(int o) //标记下放
{
	if(lazy[o])
	{
		lazy[o << 1] ^= 1; 
		lazy[o << 1 | 1] ^= 1;
		lazy[o] ^= 1;  //不要忘了把原标记清除
    }
}
void change(int o,int l,int r,int x,int y) //区间修改模板
{
	if(l == x && r == y)
	{
		lazy[o] ^= 1;
		return;
	}
	push_down(o);
	int mid = (l + r) >> 1;
	if(y <= mid) //所谓的三分式写法，不太难理解
	change(o << 1,l,mid,x,y);
	else if(x > mid)
	change(o << 1 | 1,mid + 1,r,x,y);
	else
	{
		change(o << 1,l,mid,x,mid);
		change(o << 1 | 1,mid + 1,r,mid + 1,y);
	}
}
int query(int o,int l,int r,int x) //线段树上单点查询
{
	if(l == r)
	{
		return lazy[o];
	}
	push_down(o);
	int mid = (l + r) >> 1;
	if(x <= mid)
	return query(o << 1,l,mid,x);
	else
	return query(o << 1 | 1,mid + 1,r,x);
}
int n,m; 
int main() //主程序
{
	read(n);read(m);
	while(m--)
	{
		int op = 0;
		read(op);
		if(op == 1)
		{
			int l,r;
			read(l);read(r);
			change(1,1,n,l,r);
		}
		else
		{
			int x;
			read(x);
			printf("%d\n",query(1,1,n,x));
		}
	}
	return 0; //拜拜
}

```

---


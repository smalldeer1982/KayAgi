# 【模板】康托展开

## 题目描述

求 $1\sim N$ 的一个给定全排列在所有 $1\sim N$ 全排列中的排名。结果对 $998244353$ 取模。

## 说明/提示

对于$10\%$数据，$1\le N\le 10$。

对于$50\%$数据，$1\le N\le 5000$。

对于$100\%$数据，$1\le N\le 1000000$。

## 样例 #1

### 输入

```
3
2 1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
4
1 2 4 3```

### 输出

```
2```

# 题解

## 作者：_louhc (赞：73)

康托展开真是个神奇的东西。  
除了本题用于求某排列的排名外，康托展开一般用于哈希，不过我也没做到过这样的哈希题。

# 康托展开

先给你柿子。
$$ans=1+\sum_{i=1}^{n} A[i]\times(n-i)!$$
其中$A[i]$代表$\sum_{j=i}^{n}[a[j] < a[i]]$  
怎么来理解这个柿子呢？想象构造出字典序比当前排列小的有几个排列  
枚举到$i$表示 1到i-1和原来的排列一样，i位肯定不一样，之后咋样都行。  
既然到i位不一样，那么字典序大小其实就是取决于i位。很明显，第i位肯定要小于a[i]。然后只要把i后面小于a[i]的数交换到i位，后面随便排就行了。  
很明显，这样枚举可以做到不重不漏。因为要求的是排名，所以ans+=1。  
当然要用树状数组优化一下，复杂度是O(nlgn)的。

## 双语代码（滑稽
~~写Pascal就是为了卡常数,加O2秒杀C++)~~

### C++98/11/14/17

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 1000005
#define rgt register
#define mod 998244353

int N, a[MAXN], fac, c[MAXN], ans;
char *p;

inline void read( rgt int &x ){
	x = 0; while( !isdigit(*p) ) ++p;
	while( isdigit(*p) ) x = x * 10 + ( *p & 15 ), ++p;
}

int main(){
	scanf( "%d", &N ), fac = 1;
	p = new char[N * 8 + 100],
	fread( p, 1, N * 8 + 100, stdin );
	for ( rgt int i = N; i; --i ) read(a[i]);
	for ( rgt int i = 1, s, j; i <= N; ++i ){
		for ( s = 0, j = a[i]; j; j -= j & -j ) s += c[j];
		ans = ( ans + 1ll * fac * s ) % mod, fac = 1ll * fac * i % mod;
		for ( j = a[i]; j <= N; j += j & -j ) ++c[j];
	} printf( "%d\n", ans + 1 );
	return 0;
}
```

### Pascal

```pas
var
n, fac, s, ans, i, j:longint;
a, c:array[1..1000000] of longint;
begin
    read(n); fac := 1; ans := 0;
    for i := n downto 1 do
    begin
        read(a[i]);
        c[i] := 0;
    end;
    for i := 1 to n do
    begin
        j := a[i]; s := 0;
        while j > 0 do
        begin
            s := s + c[j];
            j := j - ( j and -j ); 
        end;
        ans := ( QWORD(ans) + QWORD(fac) * QWORD(s) ) mod 998244353;
        fac := QWORD(fac) * QWORD(i) mod 998244353;
        j := a[i];
        while j <= n do
        begin
            c[j] := c[j] + 1;
            j := j + ( j and -j );
        end;
    end;
    writeln((ans + 1) mod 998244353);
end.
```
# 逆康托展开

类似于进制转换，不断 % (n-i)!, /(n-1)!就可以得到A数组，然后就可以还原出原排列。  

**Update on 2019.7.23**  
~~昨天刚刚集训回来，于是就来填坑了~~

[例题](https://www.luogu.org/problemnew/show/UVA11525)  
这题十分好心地为我们省去了求出A数组的过程（否则要高精度除法？  
问题说白了就是在每一个`[i,n]`区间内求K大值。可以使用权值线段树+二分来解决这一问题。这应该比较基础，所以看代码吧qaq。

## 代码

~~没怎么卡常数，本来想搞zkw线段树非递归减小常数，但是懒。。。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 50005

int T, N, tr[MAXN << 2];

void Build( int c, int l, int r ){ //建树
	if ( l == r ) return tr[c] = 1, void();
	int mid((l + r) >> 1), ls(c << 1), rs(c << 1 | 1);
	Build( ls, l, mid ), Build( rs, mid + 1, r ),
	tr[c] = tr[ls] + tr[rs];
}

int Get( int c, int l, int r, int k ){ //找到k大值的同时删除k大值
	--tr[c]; if ( l == r ) return l;
	int mid((l + r) >> 1), ls(c << 1), rs(ls | 1);
	if ( tr[ls] < k ) return Get( rs, mid + 1, r, k - tr[ls] );//线段树上二分找到k大值
	return Get( ls, l, mid, k );
}

int main(){
	scanf( "%d", &T );
	while( T-- ){
		scanf( "%d", &N ), Build( 1, 1, N );
		for ( int i = 1, s; i <= N; ++i )
			scanf( "%d", &s ), printf( "%d%c", Get(1, 1, N, s + 1), "\n "[i < N] );
	} return 0;
}
```

---

## 作者：bovine__kebi (赞：24)

首先我们来了解一下什么是康拓展开：

康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的

 听起来很高深其实一句话概括：**求全排列**
 我们先来了解一下康托展开的基本操作方法，一个数的的排列的排名就相当于：  
$$\small a_n·(n-1)!+a_{n-1}·(n-2)!+\cdots+a_1·0!+1$$
其中"（n）!"表示从$n$一直乘到$1$，也就是$n$的阶乘，$a_i$表示原数的第i位在当前未出现的元素中是排在第几个的。举个例子：  
$3\quad 2\quad 1$的排名就是:  
$2·2+1·1+0·1+1=6$  
$2\quad 3\quad 1$的排名就是：  
$1·2+1·1+0·1+1=4$

计算一下复杂度，从计算阶乘一直到求和，总复杂度$O(n^2)$,先放一下暴力的代码，期望得分$40\sim50$分

于是我们重新审视一下这个式子，发现阶乘是可以预处理的，但是瓶颈在于不知道怎么寻找出$a_i$,往优化的方向想，还要能够加和减的，就只有两个东西，一个树状数组，一个线段树，线段树码量。。。堪忧，所以我们选择树状数组。

下面我们来思考如何维护$a_i$,我们可以把树状数组的每一个位置上的值都加$1$,只要$a_i$这个数出现了，我们就把它减去$1$（也就是加上$-1$），然后需要查询$a_i$的值的时候，直接树状数组套路求和就好了，复杂度就这样降到了$O(n\log n)$，期望得分:$100$  
码风不毒瘤，请放心食用：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;//上界
const int Mod=998244353；//神圣的模数
typedef long long ll;//加上这个很有用的，可以避免过多的重复long long
int n;
ll jc[maxn];//阶乘
ll tree[maxn];//树状数组
ll lowbit(ll x){return x&(-x);}//树状数组实现的支撑-取最低位,不知道的请翻到最后
ll sum(ll x)//求和
{
    ll ans=0;
    while(x!=0)
    {
        ans+=tree[x]%Mod;
        x-=lowbit(x);
    }
    return ans%Mod;
}
void add(ll x,ll k)//加法
{
    while(x<=n)
    {
        tree[x]+=k;
        x+=lowbit(x);
    }
}
int main()
{
    scanf("%d",&n);
    jc[0]=1;
    for(int i=1;i<=n;i++)//预处理阶乘
    {
        jc[i]=jc[i-1]*i%Mod;
        jc[i]%=Mod;
    }
    for(int i=1;i<=n;i++)
    {
        add(i,1);//如前面所说的那样，每一位都加上1
    }
    ll ans=1;//求排名，所以位置的值为1
    for(int i=1;i<=n;i++)
    {
        ll a;
        scanf("%lld",&a);//读入
        ans+=((sum(a)-1)*jc[n-i]%Mod)%Mod;//取模运算分进去，不知道的往后看
        add(a,-1);//这一个位置的值出现了，就把他减掉
    }
    printf("%lld\n",ans%Mod)；
    return 0;
}
```
树状数组：[看这里](https://www.luogu.com.cn/problem/P3374)  
取余运算：[看这里](https://www.luogu.com.cn/problem/P1226)  
管理员求过（づ￣3￣）づ╭❤～

---

## 作者：xuezhe (赞：15)

### 简介
康托展开是一种哈希的方法，其作用是将全排列映射成一个整数，该整数为全排列的排名。

### 解题过程
我们先拿一组数据来手玩：

求全排列 $1,3,2,5,4$ 的排名。

第 1 位是 1 ，这个全排列之前除 1 以外没有任何数会放在第 1 位，故不增加排名。

第 2 位是 3 ，在以 $1$ 为开头的全排列中，这个全排列之前还有以 2 作为第 2 位的全排列，共 1 个数。故前面存在 $1 \times (5-2)!$ 个全排列。

第 3 位是 2 ，在以 $1,3$ 为开头的全排列中，这个全排列之前除 2 以外没有任何数会放在第 3 为，故不增加排名。

第 4 位是 5 ，在以 $1,3,2$ 为开头的全排列中，这个全排列之前还有以 4 作为第 4 位的全排列，共 1 个数。故前面存在 $1 \times (5-4)!$ 个全排列。

第 5 位自然稳定，无需考虑。

所以该全排列的前面共有 $1 \times (5-2)! + 1 \times (5-4)! = 7$ 个全排列，排名则是前面全排列的数量加1，即第 8 。

给出核心代码，时间复杂度为 $O(n^2)$ ：
```cpp
/*给出全排列长度n和全排列a[1..n]，用康托展开求其排名*/
int cantor(int n,int *a){
    int i,j;
    int ranking=1,s;
    for(i=1;i<n;++i){
        s=0;
        for(j=i+1;j<=n;++j){
            if(a[j]<a[i]){
                ++s;
            }
        }
        ranking+=s*f[n-i];
    }
    return ranking;
}
```

这种做法的时间复杂度，对于这道题的数据来说，必然超时。我们就需要对其进行优化。

我们把大量的时间耗在了查找上面，但实际上，我们可以使用树状数组/线段树来进行优化。这里推荐树状数组，常数小，代码短， ~~好背~~ 。

我们只需要将左边小于 $a_i$ 的数的数量 $x$ 记录下来，右边小于 $a_i$ 的数的数量即为 $a_i-1-x$ 。

这个时候，我们可以将树状数组当作一个桶来使用。遍历过程中每次将桶中的 $b_{a_i}$ 置为1，对树状数组进行对应的操作即可。要求左边小于 $a_i$ 的数时，只要做一个前缀和即可。

时间复杂度为$O(nlogn)$

给出AC代码：
```cpp
#include <iostream>
#include <cstdio>
#define MOD (998244353)
using namespace std;
int n,a[1000000];
int c[1000001]={};
inline int lowbit(int x){
    return x&(-x);
}
inline void modify(int p){
    while(p<=n){
        ++c[p];
        p+=lowbit(p);
    }
    return;
}
inline int ask(int p){
    int s=0;
    while(p){
        s+=c[p];
        p-=lowbit(p);
    }
    return s;
}
inline void readInt(int &x){
    char c;
    while((c=getchar())<'0' || c>'9');
    x=(c^48);
    while('0'<=(c=getchar()) && c<='9'){
        x=x*10+(c^48);
    }
    return;
}
int fac[1000000]={1,1};
int main(){
    int i,s=0;
    readInt(n);
    for(i=0;i<n;++i){
        readInt(a[i]);
    }
    for(i=2;i<1000000;++i){
        fac[i]=(long long)fac[i-1]*i%MOD;
    }
    for(i=0;i<n;++i){
        s=(s+(long long)fac[n-1-i]*(a[i]-1-ask(a[i]-1))%MOD)%MOD;
        modify(a[i]);
    }
    printf("%d\n",(s+1)%MOD);
    return 0;
}
```

### 相关题目
[P1379 八数码游戏](https://www.luogu.org/problemnew/show/P1379)

利用康托展开可以进行状态压缩，便于BFS开记忆数组。

~~map流玩家当我什么也没说好了~~

---

## 作者：皎月半洒花 (赞：13)

一道zz题。

首先我们知道的康托展开，根据给定排列算位次的结论是以下代码：

```cpp
inline void work_contor(ll *now){
	ll k, l, t, res = 0; 
	for(k = 1; k <= N; k ++){
		t = 0 ; 
		for(l = k + 1; l <= N; l ++)
			if(now[l] < now[k]) t ++ ;
		res += t * Flr[N - k] ; 
	}
	cout << res + 1 << endl ;  
}	   
```

我们试图优化这个东西。我们发现时间复杂度的瓶颈就在于，对于$a_i$我们不能快速统计$a_j < a_i,j > i$的二元组$<a_i, a_j>$的个数。我们发现这就是个逆序对，就可以直接上权值线段树来统计。

不得不说迄今为止这个题的数据还是太弱了。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>

#define rr register 
#define MAXN 1000100
#define Mod 998244353

using namespace std ; int T[MAXN << 1] ;
int query[MAXN], Flr[MAXN], N, K, i, j, q ;

inline void push_up(int rt){
	T[rt] = T[rt << 1] + T[rt << 1 | 1] ; 
}
inline void update(int rt, int l, int r, int p){
	if (l == p && r == p) { T[rt] ++ ; return ; } rr int mid = (l + r) >> 1 ; 
	if (p <= mid) update(rt << 1, l, mid, p) ; else update(rt << 1 | 1, mid + 1, r, p) ; push_up(rt) ; 
}
inline int que(int rt, int l, int r, int ql, int qr){
	if (ql > qr) return 0 ; 
	if (ql <= l && qr >= r) return T[rt] ; rr int mid = (l + r) >> 1, res = 0 ; 
	if (ql <= mid) res += que(rt << 1, l, mid, ql, qr) ; if (qr > mid) res += que(rt << 1 | 1, mid + 1, r, ql, qr) ; return res ; 
}
inline void work_contor(int *now){
	int k, l, t = 0, res = 0; 
	for (k = 1 ; k <= N ; ++ k, t = 0)
		res = (1ll * res + 1ll * (now[k] - que(1, 1, N, 1, now[k] - 1) - 1) * Flr[N - k]) % Mod, update(1, 1, N, now[k]) ;  
	cout << (res + 1) % Mod << endl ;  
}
int main(){
	cin >> N ; Flr[1] = Flr[0] = 1 ; 
	for (i = 2; i <= N ; i ++) Flr[i] = 1ll * Flr[i - 1] * i % Mod ;
	for (j = 1; j <= N ; j ++) scanf("%d", &query[j]) ; work_contor(query) ; return 0 ;
}

```

---

## 作者：UperFicial (赞：10)

# 康托展开模板

### 前言

~~看了亿眼题解就会写了~~

~~但是爆了亿次零/dk/dk~~

这里说说自己对康托展开的理解。

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/P5367)

### 题意简述

给定一个 $1$ 至 $n$ 的排列，求它在 $1$ 至 $n$ 的全排列中的排名。

### 题目分析

假设给定的 $n$ 个正整数分别是 $a_1,a_2,\cdots,a_n$。

我们先看一个柿子：

$$\sum_{i=1}^n(v_{a_i}\times (n-i)!)+1$$

其中 $v_{a_i}$ 表示在第 $i+1$ 至 $n$ 位的比 $a_i$ 小的数的个数。

这个柿子就是最终的答案，我们来解释一下。

单考虑第 $i$ 位，它本身可以放 $v_{a_i}$ 个的，因为要计算它的排名的话比它小的数都可以放上去。而剩下的 $(n-i)$ 个位置一共就可以放 $(n-i)$ 个数，你怎么放都行，所以一共有 $(n-i)!$ 种方法。最后需要加上 $1$ 是因为要计算它本身的排名。

那怎么维护 $v$ 呢？我们设 $h_{x}$ 表示到了目前第 $i$ 个位置，数 $x$ 有没有出现过，没出现过为 $1$，出现过为 $0$，显然，一开始所有数都没出现过，$h$ 数组就都应该赋值成 $1$。

当我们要计算 $v_{a_i}$ 时，可以考虑这样一个柿子：$\sum_{j=1}^{a_i-1}h_j$，意思是先把所有比 $a_i$ 小的加上，而那些已经出现过的都已经成为 $0$ 了，完美的维护了 $v$。

显然 $h$ 需要树状数组维护。

阶乘用一个 $O(n)$ 的预处理也维护出来了，不过中间要注意精度的问题。

时间复杂度：$O(n\log n)$。

空间复杂度：$O(n)$。

[$AC$ 记录](https://www.luogu.com.cn/record/47700389)

[$code$](https://paste.ubuntu.com/p/fWCx2WVVX2/)

$$\texttt{The End.by UF}$$



---

## 作者：Anita_Hailey (赞：4)

## 序

~~果冻要买啥口味的？~~

## 正文

**康托展开** 求一个全排列的 **rank**，是一种特殊的 hash

考虑对于每一位进行计算，比如计算 2143 的 rank

1. 第一位是 2 比它小的有 1 个 于是 ans += 1 * 3!
2. 第二位是 1 比它小的是 0 个，于是 ans += 0 * 2!
3. 第三位是 4 比他小的是 1 个，于是 ans += 1 *  1!
4. 第四位是 3 比它小的没有于是 ans += 0 * 0!

ans = 7

但是最后应该加一，因为最小的那个算的是 0.。

所以，我们显而易见的可以得到一个 $O(n^2)$ 的做法，于是，在这个题目里 TLE 了。

这里我们不妨假定开了 O2.

那么，事实上 $O(n\sqrt n)$ 可以通过此题，来说说思路。把数分成 $\sqrt n$ 个块，我们每次对于一个块内做 erase 操作，即可，然后统计只要枚举每个块的元素个数即可，在整块里直接就是块中元素个数，在分出来的就是一个二分出位置即可。

```c++
#include <bits/stdc++.h>

#define gc(  ) std::getchar(  )
#define pc( i ) std::putchar( i )

template < typename T >
inline
T read(  )
{
	register T x = 0;
	register char ch = gc(  );
	register bool f = 0;
	while( !std::isdigit( ch ) )
	{
		f = ( ch == '-' );
		ch = gc(  );
	}
	while( std::isdigit( ch ) )
	{
		x = x * 10 + ( ch - '0' );
		ch = gc(  );
	}
	return f ? -x : x;
}

template < typename T >
void
put( T x )
{
	if( x < 0 )
	{
		x = -x;
		pc( '-' );
	}
	if( x < 10 ) {
		pc( x + 48 );
		return;
	}
	put < T > ( x / 10 );
	pc( x % 10 + 48 );
	return ;
}

#define Rep( i, j, k ) for( int i = j; i >= k; --i )
#define rdi(  ) read < int > (  )
#define rdl(  ) read < long long > (  )
#define pti( i ) put < int > ( i ), putchar( ' ' )
#define ptl( i ) put < long long > ( i ), putchar( ' ' )
#define For( i, j, k ) for( int i = j; i <= k; ++i )

const int mod = 998244353, Maxn = 1000001;

int a[ Maxn ], n, fac[ Maxn ], bl[ Maxn ], bol;

long long ans;

std::vector < int > v[ 10000 ];

void
fakemain(  )
{
	bol = sqrt( n = rdi( ) );
	For( i, 1, n ) v[ bl[ i ] = ( i - 1 ) / bol + 1 ].push_back( i ), a[ i ] = rdi( );
	fac[ 0 ] = 1;
	For( i, 1, n - 1 ) fac[ i ] = ( long long ) fac[ i - 1 ] * i % 998244353;
	ans = 1;
	For( i, 1, n )
	{
		std::vector < int >::iterator it = std::lower_bound( v[ bl[ a[ i ] ] ].begin( ), v[ bl[ a[ i ] ] ].end( ), a[ i ] );
		int tmp = 0;
		For( j, 1, bl[ a[ i ] ] - 1 ) tmp += v[ j ].size( );
		tmp += it - v[ bl[ a[ i ] ] ].begin( );
		ans = ( ans + ( long long ) fac[ n - i ] * tmp ) % 998244353;
		v[ bl[ a[ i ] ] ].erase( it );
	}
	ptl( ans );
	return;
}


int
main( int argc, char* argv[] )
{
	fakemain(  );
	return 0;
}
```

## 嵬

二模了，慌得一批

---

## 作者：Register (赞：4)

### 康托展开是什么
求$1\sim n$的全排列某个排列按字典序的排名
### 康托展开有什么用
对一个排列进行状压
### 康托展开解法

- $O(n^2)$解法

从第$1$位开始枚举，到第$n$位

枚举第$i$位还能选多少个，这个排列第$i$位是还能选的中的排名

有多少个比它还小的，加上个数乘上$n-i$的全排列（还剩$n-i$个任意选）

- $O(n$ $log$ $n)$解法

$O(n^2)$很明显要超时，数据要求必须$O(n$ $log$ $n)$

枚举每一位是必然不可省的，不过排名可以使用树状数组维护

再用龟速乘卡个常，此题就过了

### 代码

```cpp
#include <cstdio>
const int mod=998244353;
int n,ans=1,a[1000001],mul[1000001],tree[1000001];
int read(){
    char ch=getchar();int res=0,w=1;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
    return res*w;
}
inline int qmod(int x){
	if(x<(mod<<1)) return x<mod?x:x-mod;
	return x%mod;
} 
inline int qmul(int x,int y){
	int res=0;
	while(y)
	{
		if(y&1) res=qmod(res+x);
		x=qmod(x<<1);y>>=1;
	}
	return res;
}
inline int lowbit(int x){
	return x&(-x);
}
void add(int x){
	while(x<=n) {tree[x]++;x+=lowbit(x);}
}
int query(int x){
	int res=0;
	while(x) {res+=tree[x];x-=lowbit(x);}
	return res;
}
int main(){
	n=read();mul[0]=1;
	for(register int i=1;i<=n;i++) {a[i]=read();mul[i]=qmul(mul[i-1],i);}
	for(register int i=1;i<=n;i++) {ans=qmod(ans+qmul(a[i]-1-query(a[i]),mul[n-i]));add(a[i]);}
    printf("%d\n",ans);
	return 0;
}
```


---

## 作者：G我就是菜G (赞：1)

## 用途
给定一个 $1$ ~ $n$ 的排列，求该排列在 $1$ ~ $n$ 全部排列中的字典序排名
## 做法
$$
ans=1+\sum^n_{i=1}((n-i)!\times\sum^n_{j=i}(a[j]<a[i]))
$$

直接求 $\sum^n_{j=i}(a[j]<a[i])$ 显然是超时

考虑线段树 $&$ 树状数组优化
## 证明
考虑第 $i$ 个数，其后面有 $n-i$ 个数，共有 $(n-i)!$ 种全排列

可以发现对于一个排列，往后 $(n-i)!$ 个字典序名次，$a[i+1]$ ~ $a[n]$ 中比 $a[i]$ 小的数多了一个 (即 $\sum^n_{j=i}(a[j]<a[i])$ 多了 $1$)

那么就能推出以上公式

## 代码
``` cpp
#include <bits/stdc++.h>
#define int long long
#define N 1000010

using namespace std;

int k,ans,a[N],t[N<<2],n,Mod=998244353;

inline int read()
{
	int __=0,___=1;
	char _=getchar();
	for (;_<'0' || _>'9';_=getchar()) if (_=='-') ___=-1;
	for (;_>='0' && _<='9';_=getchar()) __=(__<<1)+(__<<3)+_-'0';
	return __*___;
}

void modify(int l,int r,int i,int x)     \\线段树插入数值
{
	if (l==r) {t[i]=1;return;}
	int mid=(l+r)>>1;
	if (x<=mid) modify(l,mid,i<<1,x);
	else modify(mid+1,r,i<<1|1,x);
	t[i]=t[i<<1]+t[i<<1|1];
}

int query(int l,int r,int L,int R,int i)   \\查询比当前位置小的数字个数
{
	if (L<=l && r<=R) return t[i];
	int mid=(l+r)>>1,ans=0;
	if (L<=mid) ans=query(l,mid,L,R,i<<1);
	if (mid<R) (ans+=query(mid+1,r,L,R,i<<1|1))%=Mod;
	return ans;
}

signed main()
{
	n=read();
	for (int i=1;i<=n;i++)
		a[i]=read();
	k=1,ans=1;
	modify(1,n,1,a[n]);
	for (int i=n-1;i;i--)
	{
		(ans+=query(1,n,1,a[i],1)*k)%=Mod;
		(k*=n-i+1)%=Mod;
		modify(1,n,1,a[i]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：超级玛丽王子 (赞：1)

康托展开=好东西。

这个东西在状态压缩方面用的很多，把全排列压缩成大小可以接受的数。具体的使用可以看看[这里](https://www.cnblogs.com/cjoierljl/p/9147579.html)。

首先讲一下基础做法：$O(n^2)$ 求解康托展开。

## 例题：判断 $2143$ 是数码集合 $\{1,2,3,4\}$ 的全排列中第几大的数。

计算排在 $2143$ 前面的排列数目，可以将问题转换为以下排列的和：
1. 首位小于 $2$ 的所有排列。首位小于 $2$ 的数只有 $1$，后面三个数的排列有 $A_3^3$，即 $6$ 种，记作 $1\times 3!$。
2. 首位为 $2$，第二位小鱼 $1$ 的所有排列。然而，$1$ 已经是最小的数了，没有符合条件的排列，共 $0$ 种，记作 $0\times2!$；
3. 前两位为 $21$，第三位小于 $4$ 的所有排列。由于 $1,2$ 已经用过了，符合条件的只有 $3$，共 $1$ 种，记作 $1\times1!$；
4. 前 $3$ 位为 $214$，第四位小于 $3$ 的所有排列。无，共 $0$ 种，记作 $0\times0!$。

求和得到 $2143$ 之前有 $7$ 种排列，所以它是第 $8$ 大的。

根据上面的例子我们可以得到康托展开的公式：

把一个集合产生的全排列按字典序排序，第 $X$ 个排列的计算公式为：
$$X=a_n\times(n-1)!+a_{n-1}*(n-2)!+\cdots+a_i*(i-1)!+\cdots+a_2\times1!+a_1\times0!$$

其中，$a_i$ 表示原数的第 $i$ 位在当前未出现的元素中排在第几个（从 $0$ 开始），并且有 $0\le a[i]<i\ \ (1\le i\le n)$

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=998244353;
int str[1000005],n;
long long fac[1000005];
void init() {
    scanf("%d",&n);
    fac[0]=fac[1]=1;
    for(int i=2;i<=n;i++) fac[i]=(fac[i-1]*i)%mod;
    for(int i=0;i<n;i++) scanf("%d",str+i),str[i]--;
}
void Cantor() {
    long long result=0;
    for(int i=0;i<n;i++) {
        int counted=0;
        for(int j=i+1;j<n;j++) 
            if(str[i]>str[j]) ++counted;
        result=(result+(counted*fac[n-i-1])%mod)%mod;
    }
    printf("%lld",(result+1)%mod);
}
int main(void) {
    init();
    Cantor();
    return 0;
}
```

## 然而，这个复杂度显然是不可承受的！
$O(n^2)$ 只能[得 $50$ 分](https://www.luogu.com.cn/record/39778591)。因此，我们采用树状数组优化的方式，将 $O(n)$ 判断出现排名的算法优化到 $O(\log_2n)$。

完整代码就不放了，仅仅把处理 `counted` 的部分换成树状数组就好了。

## 完结撒花~ 求赞求互关QAQ

---

## 作者：Forgetember (赞：1)

这道题就两个要注意的点：

1.是用康托展开

2.是要取模且取模的时候注意法则

# 1：康托展开
康托展开链接：[康托展开](https://baike.baidu.com/item/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/7968428?fr=aladdin)

用第一个样例做解释：
子串“213”

先看第一位：2.在后面两位中比2小的只有一位所以sum[1]=1；

再看第二位：1.在后面一位中比1小的为零位所以sum[2]=0;

再看第三位：3.显然因为后面已经没有位数了所以sum[3]=0;

最后就是求康托展开值：套公式：

$\color{red}\text{cantor=sum[1]*(3-1)!+sum[2]*(2-1)!+sum[3]*(1-1)!=2}$

$\color{blue}\text{（0！=1）}$

# 2：取模运算

### 还有要注意的取模运算就在代码里看吧

```c
#include<bits/stdc++.h>
using namespace std;
int fac[1000001];
long long int p = 998244353;
int FAC(int n)////阶乘
{
	fac[0] = 0;
	fac[1] = 1;
	for(int i = 2;i <= n;i++)
	fac[i] = (fac[i-1] % p * i % p) % p;
     //////(x * y) % p = (x % p * y % p) % p
}
int main()
{
	int n , a[1000001];
	cin >> n;
	for(int i = 0;i < n;i++)
	cin >> a[i];
	FAC(n);
	int can = 0;
	for(int i = 0;i < n;i++)
	{
		int sum = 0;
		for(int j = i + 1;j < n;j++)
		    if(a[i] > a[j])sum++;
		can = (can % p + (sum % p * fac[n-i-1]) % p) % p;
        /////(x + y) % p = (x % p + y % p) % p;
        ////即使上面算阶乘的时候已经取过模了，但是做加法的时候还要再模
		}////康托展开；
	cout<<can + 1;/////别忘了加1，因为这个康托从0开始，但题意是从1开始排序的
	return 0;
}
```


---

## 作者：Jμdge (赞：0)

这题卡 python！ 举报了

此题讲的是康拓展开，咱分析一下，我们可以从前往后考虑点的排名（因为前面的点对于后面的点是没有影响的），这个树状数组维护一下就行，然后乘乘阶乘再累加


# Proof

对于某个位置 i ，如果它的值 a[i] 是后面几个数之中第 k 大的，那么显然比他小的 k-1 个值的所有排列的排名都比当前序列小，然后这样的排列有 $(k-1)*fac[x]$ 个（x 为当前点后面的数字个数），然后我们考虑当前位同样是 a[i] 的序列有多少个比他小，那么其实我们固定当前点为 a[i] ，然后向后用同样的方法计算就好了



本觉得是道模板题应该是 $n^2$ 可以过的，然后看了数据范围就自闭了，这貌似得用树状数组维护？出题人还是有点毒瘤的呢，对咱这样的菜鸡这么不友好...

# Code

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
using namespace std;
const int mod=998244353;
const int M=1e6+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline void Pls(int& x,int y){if((x+=y)>=mod)x-=mod;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,ans=1; arr fac,a,f;
#define lowbit(x) (x&-x) 
inline void add(int x,int v){
	while(x<=n) f[x]+=v,x+=lowbit(x);
}
inline int ask(int x){ Rg int s=0;
	while(x) s+=f[x],x^=lowbit(x); return s;
}
int main(){ n=read(),fac[0]=1;
	fp(i,1,n) a[i]=read(),fac[i]=mul(fac[i-1],i),add(i,1);
	fp(i,1,n) add(a[i],-1),Pls(ans,mul(ask(a[i]),fac[n-i]));
	return !printf("%d\n",ans);
}
```



# Code+1

空间较小导致了 MLE （虽说空间足够可能还是会T上天）


```
fac=[0 for i in range(1000003)]
mod=998244353
n=0;ans=1
a=[0 for i in range(1000003)]

f=[0 for i in range(500005)]

def lowbit(x):
    return x&(-x)

def add(x, k):
    while x<=n :
        f[x]+=k
        x+=lowbit(x)

def ask(x):
    Res=0
    while x>0:
        Res+=f[x]
        x-=lowbit(x)
    return Res


if __name__=='__main__':
    n=int(input())
    s=input().split()
    
    fac[0]=1
    for i in range(1,n+1):
        fac[i]=fac[i-1]*i%mod
        a[i]=int(s[i-1])
        add(i,1)
    
    for i in range(1,n+1):
#        print(ask(a[i]-1))
        ans+=(ask(a[i]-1))*fac[n-i]%mod
        add(a[i],-1)

    print(ans)

```



---

## 作者：hgoicjl (赞：0)

#### [博客](https://www.luogu.org/blog/cmine/)内食用更佳
---
### 算法
康托展开 ~~(这不模板题吗)~~ 树状数组

### 知识

康托展开是一个全排列到一个自然数的双射

实质是计算当前排列在所有由小到大全排列中的顺序

它的公式是这样子

$X=\sum_{i=1}^{n}{a_i(i-1)!}$

---

### 一些不是很严谨的推论

我们假设有一个递增数列$\{a_n\}$，考虑其中一种排序$A$的$Rank$

对于这个排序第一个数$a_{m_1}$,显然有以$a_k,k<m_1$开头的排列的$Rank$比该排序小

对于每一个$k<m_1$，以$a_k$开头的排列就有$(m_1-1)\times(n-1)!$种情况(即所做贡献)

我们考虑该排列每位上所做的贡献之和即该排列的$Rank$

---
最后再用树状数组来维护每位上所做的贡献即可

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=(1e6)+5;
const int MOD=998244353;
typedef long long LL;
struct Fenwick
{
	#define lowbit(x) x&(-x)
	int A[MAXN],C[MAXN],size;
	void init(int n)
	{
		size=n;
	}
	inline void modify(int l,int r,int val)
	{
		A[l]+=val;
		for(;l<=size;C[l]+=val,l+=lowbit(l));
		A[++r]-=val;
		for(;r<=size;C[r]-=val,r+=lowbit(r));
	}
	inline int query(int pos)
	{
		int ans=0;
		for(;pos>=1;ans+=C[pos],pos-=lowbit(pos));
		return ans;
	}
	#undef lowbit
}tree;
inline LL read()
{
	LL fh=1,s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			fh=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		s=s*10+ch-'0';
		ch=getchar();
	}
	return fh*s;
}
LL fact[MAXN];
int main()
{
	LL n=read(),ans=1;
	tree.init(n);
	for(int i=1;i<=n;i++)
		tree.modify(i,i,i-1);
	fact[0]=1;
	for(int i=1;i<=n;i++)
		fact[i]=(fact[i-1]*i)%MOD;
	for(int i=1;i<=n;i++)
	{
		int x=read();
		ans+=tree.query(x)*fact[n-i];
		ans%=MOD;
		tree.modify(x+1,n,-1);
	}
	cout<<ans<<endl;
	return 0;
}
```

---


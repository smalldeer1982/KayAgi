# [eJOI 2019] 异或橙子

## 题目描述

Janez 喜欢橙子！他制造了一个橙子扫描仪，但是这个扫描仪对于扫描的每个橙子的图像只能输出一个  $32$ 位整数。

他一共扫描了 $n$ 个橙子，但有时他也会重新扫描一个橙子，导致这个橙子的 $32$ 位整数发生更新。

Janez 想要分析这些橙子，他觉得异或操作非常有趣，他每次选取一个区间从 $l$  至 $u$，他想要得到这个区间内所有子区间的异或和的异或和。

例如 $l=2,u=4$ 的情况，记橙子序列 $A$ 中第 $i$ 个橙子的整数是 $a_i$，那么他要求的就是：

$$a_2 \oplus a_3 \oplus a_4 \oplus (a_2\oplus a_3)\oplus(a_3\oplus a_4)\oplus(a_2\oplus a_3 \oplus a_4)$$

-------------------------------------

注：式子中的 $\oplus$ 代表按位异或运算。异或的运算规则如下。

对于两个数的第 $i$ 位，记为 $x,y$，那么：

|$x$|$y$|$x\oplus y$|
| :-----------: | :-----------: | :-----------: |
|$0$|$1$|$1$|
|$1$|$0$|$1$|
|$0$|$0$|$0$|
|$1$|$1$|$0$|

例：$13\oplus 23=26$

|$13=$|$0\cdots 001101$|
| --------: | :------: |
|$23=$|$0\cdots 010111$|
|$13\oplus 23=$|$0\cdots 011010$|

## 说明/提示

#### 输入输出样例 1 解释

- 最初，$A=[1,2,3]$，询问结果为 $1\oplus 2\oplus 3\oplus(1\oplus 2)\oplus (2\oplus 3)\oplus(1\oplus 2\oplus 3)=2$

- 修改后，第一个位置被修改为 $3$ ，询问的结果是 $3\oplus 2\oplus 3\oplus(3\oplus 2)\oplus (2\oplus 3)\oplus(3\oplus 2\oplus 3)=0$。

----------------------------

#### 数据规模与约定：

**本题采用多测试点捆绑测试，共有 5 个子任务**。

- Subtask 1(12 points)：$1\le n,q\le 10^2$，无特殊限制
- Subtask 2(18 points)：$1\le n,q\le 5\times 10^2$，且没有修改操作。
- Subtask 3(25 points)：$1\le n,q\le 5\times 10^3$，无特殊限制
- Subtask 4(20 points)：$1\le n,q\le 2\times 10^5$，且没有修改操作。
- Subtask 5(25 points)：$1\le n,q\le 2\times 10^5$，无特殊限制

对于所有数据，$0\le a_i\le 10^9,1\le n,q\le 2\times 10^5$

--------------------------

#### 说明

原题来自：[eJOI2019](http://ejoi2019.si/) Problem A. [XORanges](https://www.ejoi2019.si/static/media/uploads/tasks/xoranges-isc(1).pdf)

题面&数据来自：[LibreOJ](https://loj.ac/problem/3195)

## 样例 #1

### 输入

```
3 3
1 2 3
2 1 3
1 1 3
2 1 3```

### 输出

```
2
0```

## 样例 #2

### 输入

```
5 6
1 2 3 4 5
2 1 3
1 1 3
2 1 5
2 4 4
1 1 1
2 4 4```

### 输出

```
2
5
4
4```

# 题解

## 作者：Lice (赞：98)

### Description

给定一个数列，长度为 $n$，第 $i$ 项为 $a_i$。

两种操作：

- 单点修改

- 给定 $l,u$ ，求 $\large\oplus_{i=l}^{u}(\oplus_{j=i}^{u}a_j)$

其中 $\oplus_{i=l}^r a_i=a_l\oplus a_{l+1} \oplus \cdots \oplus a_r$

### Solution

本题的突破口： **异或的特殊性质**

- $a \oplus 0=a$

- $a\oplus a=0$

那么对于原题目给的例子：

$a_2 \oplus a_3 \oplus a_4 \oplus (a_2\oplus a_3)\oplus(a_3\oplus a_4)\oplus(a_2\oplus a_3 \oplus a_4)$

$=a_2\oplus a_4$（$4$ 个 $a_3$ 异或直接归零）

这样原来如此冗长的式子就很简单了。

再来几个：

- 当 $l=1,u=4$ 时，就是 $0$

- 当 $l=1,u=5$ 时，就是 $a_1\oplus a_3\oplus a_5$

手玩几下，发现点什么？

显然易见的一个结论：

- 当 $l,u$ 奇偶性不同时，$[l,u]$ **中所有元素都会对答案贡献偶数次** ，那么答案就是 $0$。

- 当 $l,u$ 奇偶性相同时，$[l,u]$ **中所有** $l,u$ **奇偶性相同的位置的值会对答案贡献奇数次，其他位置的值则会贡献偶数次**，那么答案就是 $a_l \oplus a_{l+2} \oplus \cdots \oplus a_u$。

实现？树状数组是个不错的选择。

我们保存两个树状数组，分别存奇数、偶数位置的信息。

详见代码。

### Code

```cpp
#include<cstdio>
using namespace std;

const int N=2e5+5;
int n,q,a[N];

#define lowbit(x) (x&(-x))
struct bit{
	int dat[N];
	inline void update(int x,int p){
		for(;p<=n;p+=lowbit(p)) dat[p]^=x;
	}
	inline int xor_sum(int p){
		int x=0;
		for(;p;p-=lowbit(p)) x^=dat[p];
		return x;
	}
};
#undef lowbit

bit tree[2];

signed main()
{
	scanf("%d%d",&n,&q);
	for(register int i=1;i<=n;i++)
		scanf("%d",a+i),tree[i&1].update(a[i],i);
	while(q--)
	{
		int opt,x,y;
		scanf("%d%d%d",&opt,&x,&y);
		if(opt==1) tree[x&1].update(a[x]^y,x),a[x]=y;
		else
		{
			if((x+y)&1) printf("0\n");
			else printf("%d\n",tree[x&1].xor_sum(y)^tree[x&1].xor_sum(x-1));
		}
	}
	return 0;
}
```

最后来求个赞 QwQ

---

## 作者：Warriors_Cat (赞：19)

### $Solution:$

一道树状数组好题。

我们直接分析询问操作。

设 $f_{l, r, i}$ 表示一个区间 $\left[l, r
\right]$ 包含 $a_i$ 的子区间个数。$(l \le i \le r)$

那么，$i$ 的左边的 $i - 1$ 个数有 $i - l $ 种取法，当然可以不取，于是有 $i - l + 1$ 种，同理右边有 $r - i + 1$ 种。

根据乘法原理，可得 $f_{l,r,i}=(i-l+1)(r-i+1)$。

又因为异或的一个性质：

```cpp
a^0=a
a^a=0
```
所以我们只需要考虑 $f_{l, r, i}$ 的奇偶性即可。

由于 $(i-l+1)+(r-i+1)=r-l+2$，所以当 $l, r$ 奇偶性不同时，$f_{l,r,i}$ 一定是偶数，反之有可能为奇数。

那，当 $f_{l, r, i}$ 为奇数时，$i-l+1$ 与 $r-i+1$ 也必须都是奇数。那么 $i$ 与 $l, r$ 的奇偶性都相同。

至此，询问操作就搞定了：

当 $l, r$ 奇偶性不同时，答案为 $0$。

当 $l, r$ 奇偶性相同时，所有在 $\left[l, r\right]$ 的于 $l, r$ 奇偶性相同的 $i$ 所对应的数 $a_i$ 都要异或一次。

然后再看看题。单点修改 + 区间查询？嗯，树状数组预定。

于是，我们可以维护两棵树状数组，一棵维护 $a_1, a_3, a_5...$  ，一棵维护 $a_2, a_4, a_6...$ 即可。

对于单点修改的话，我们可以异或上原来的数，再异或上修改的数，因为 ``a^a=0``，于是完成了修改，同时修改单点就行了。

下面放代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n, m, a[200010], opt, x, y;
struct BIT{
	int c[200010];
	inline int lowbit(int x){return x & (-x);}
	inline void change(int x, int y){
		while(x <= n){
			c[x] ^= y;
			x += lowbit(x);
		}
	}//单点修改
	inline int query(int x){
		int ans = 0;
		while(x){
			ans ^= c[x];
			x -= lowbit(x);
		} 
		return ans;
	}//区间查询
}tree[2]; //写在结构体里，方便一些。
int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; ++i) scanf("%d", a + i), tree[i & 1].change(i, a[i]);//先维护原序列
	for(int i = 1; i <= m; ++i){
		scanf("%d%d%d", &opt, &x, &y);
		if(opt == 1) tree[x & 1].change(x, a[x] ^ y), a[x] = y;//记得改 a[x]
		else{
			if((x & 1) ^ (y & 1)) puts("0");
			else printf("%d\n", tree[x & 1].query(y) ^ tree[x & 1].query(x - 1));
		}//如上所述
	}
	return 0;
}
```

---

## 作者：Hexarhy (赞：12)

树状数组进阶题，结合按位异或的性质，但是难度不大。

--------

### Solution

原来的式子很长，但是别忘了出题人特地给了按位异或 $\oplus$ 的运算，意思就是要用到某些性质。

我们知道四个常见性质：

$$a\oplus a=0,a\oplus 0=a,a\oplus b=b\oplus a,(a\oplus b)\oplus c=a\oplus (b\oplus c)$$

运用到本题来看，对于区间 $[2,4]$

$$a_2\oplus a_3\oplus a_4\oplus (a_2\oplus a_3)\oplus(a_3\oplus a_4)\oplus(a_2\oplus a_3\oplus a_4)$$

化简一下得到：$a_2\oplus a_4$

显然，根据按位异或的性质，区间内的 $a$ 的出现次数将决定是否产生贡献，也就是 $l,r$ 的奇偶性，或者说是区间长度的奇偶性。

- 当 $l,r$ 奇偶性不同，也就是区间长度 $r-l+1$ 为偶数，所有 $a$ 的出现次数都是偶数次，没有产生贡献，答案为 $0$。

- 当 $l,r$ 奇偶性相同，也就是区间长度 $r-l+1$ 为奇数，所有下标与 $l$ 奇偶性相同的数产生了贡献。

多列举几个可知。

题目要求**单点修改，区间查询**，我们就可以把树状数组从维护前缀和改成维护异或和，下标分奇偶，各用一个树状数组维护。

对于**单点修改**，由于 $a\oplus a=0$，维护的数列中的值原本是 `a[x]`，通过`modify(x,a[x]^y)`，就能得到 `a[x]^a[x]^y=y`，成功达成修改的目的。记得修改原数列 $a$，即 $a_x=y$。

对于**区间查询**，类似前缀和。只是对于区间长度为偶数的，我们可以直接输出 `0`。

### Notice

- 为了快速区分两个树状数组，我们可以对下标按位与 $1$ （`&1`），`tree[0]` 就是维护下标为偶数，`tree[1]` 就是维护下标为奇数。

- 别忘了单点修改的时候也要 `a[x]=y`。

- 注意位运算符的优先级很低。不要吝啬代码中的`()`。

### Code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int MAXN=2e5+5;
int n,Q;
int a[MAXN];

class BIT
{
	private:
	int tree[MAXN];
	public:
	int lowbit(const int x)
	{
		return x&-x;
	}
	void modify(int pos,const int x)
	{
		for(;pos<=n;pos+=lowbit(pos))
		 tree[pos]^=x;//维护异或和
	}
	int query(int pos)
	{
		int res=0;
		for(;pos;pos-=lowbit(pos))
		 res^=tree[pos];//同理
		return res;
	}
}tree[2];//tree[0]是维护下标为偶数，tree[1]则是奇数

int main()
{
    ios_base::sync_with_stdio(false);
    cin>>n>>Q;
	for(int i=1;i<=n;i++)
	 cin>>a[i];
	for(int i=1;i<=n;i++)
	 tree[i&1].modify(i,a[i]);//建树
	while(Q--)
	{
		int opt,x,y;cin>>opt>>x>>y;
		if(opt==1)
		{
			tree[x&1].modify(x,a[x]^y);//解释过了
			a[x]=y;
		}
		if(opt==2)
		{
			int ans=0;
			if(!((x&1)^(y&1)))//l,r奇偶性相同
			 ans=tree[x&1].query(y)^tree[x&1].query(x-1);
			cout<<ans<<endl; 
		}
	}
	return 0;
}
```

---

## 作者：VinstaG173 (赞：5)

首先我们看到单点修改和区间查询和数据范围就想到树状数组。

然后我们可以发现我们只要讨论区间里每个数出现的次数的奇偶性。

我们会列出这样一个三角形：

```
1
2 2
3 4 3
4 6 6 4
5 8 9 8 5
```

其中第 $i$ 行第 $j$ 列的数（记为 $a_{i,j}$）表示选择的区间长度为 $i$，其中从左至右第 $j$ 个数在最终结果的表达式中被异或的次数。

容易发现 $a_{i,j}=j(i-j+1)$。所以我们容易发现对于 $i$ 为偶数的情况，答案为 $0$；否则，有 $j$ 为奇数时对答案有贡献。即其奇偶性如下：

```
1
0 0
1 0 1
0 0 0 0
1 0 1 0 1
```

于是我们将原数列奇偶位各用一个树状数组维护就做完了。

Code:
```cpp
#include<cstdio>
int n,m,k,opt,x,y;
int a[200011];
int s[2][100007],l[100007];
inline void cng(int t,int x,int y)
{
	while(x<=k)
	{
		s[t][x]^=y;
		x+=l[x];
	}
}
inline void upd(int x,int y)
{
	int tmp=a[x]^y;a[x]=y;
	cng(x&1,(x>>1)+1,tmp);
}
inline int clc(int t,int x)
{
	int res=0;
	while(x)
	{
		res^=s[t][x];
		x-=l[x];
	}
	return res;
}
int main()
{
	scanf(" %d %d",&n,&m);k=(n>>1)+1;
	for(int i=1;i<=k;++i)l[i]=i&(-i);
	for(int i=1;i<=n;++i)
	{
		scanf(" %d",&y);
		upd(i,y);
	}
	while(m--)
	{
		scanf(" %d %d %d",&opt,&x,&y);
		if(opt==1)upd(x,y);
		else
		{
			if(x&1^y&1)printf("0\n");
			else printf("%d\n",clc(y&1,(y>>1)+1)^clc(x&1,x>>1));
		}
	}
	return 0;
}
```

---

## 作者：囧仙 (赞：3)

发现本题目前所有题解都是 树状数组 + 分奇偶分别维护，就我傻乎乎地直接用一颗线段树维护，深感奇妙，于是来写一下线段树的做法

- 分析询问

   首先，可以发现下标 $i$ 的数会被 $(i - l + 1) \times (r - i + 1)$ 个区间包含

   因为对答案异或偶数次一个数不会产生影响，对答案异或奇数次一个数等同于对答案异或一次这个数，所以也就是查询所有 $(i - l + 1) \times (r - i + 1)$ 为奇数的数的异或和
   
   因为 奇数 $\times$ 奇数 $=$ 奇数，偶数 $\times$ 奇数 $=$ 偶数，偶数 $\times$ 偶数 $=$ 偶数，所以 $(i - l + 1) \times (r - i + 1)$ 为奇数 的条件是 $i - l + 1,r - i + 1$ 都为奇数 
   
   所以 $i - l,r - i$ 都为偶数
   
   所有满足 $i - l$ 为偶数的下标可以表示为 $l + 2k$，所以满足 $r - i$ 为偶数的下标可以表示为 $r - 2k$
   
   不难发现，若 $2  \nmid r- l$，那么不存在同时满足这两个条件的下标
   
   若 $2 \nmid r - l$，那么满足这两个条件的下标实际上就是 $l + 2k$
   
- 如何用一颗线段树如何维护这个操作

   现在要干这两件事：
   
   - 单点修改
   
   - 查询 $[l,r]$ 中所有奇偶性与 $l$ 相同的数的 $\operatorname{xor}$ 和
   
   那么显然要对线段树上的每个节点维护，与其左端点奇偶性相同的数的 $\operatorname{xor}$ 和 $val_0$ ，以及与其左端点奇偶性不同的数的 $\operatorname{xor}$ 和 $val_1$
   
   考虑如何 $pushup$：
   
   - 如果左子区间的长度是 $2$ 的倍数
   
     那么实际上 $val_{fa,0} = val_{ls,0} \operatorname{xor} val_{rs,0}$
     
     $val_{fa,1} = val_{ls,1} \operatorname{xor} val_{rs,1}$
     
   - 如果左子区间得长度不是 $2$ 的倍数
   
     $val_{fa,0} = val_{ls,0} \operatorname{xor} val_{rs,1}$
     
     $val_{fa,1} = val_{ls,1} \operatorname{xor} val_{rs,0}$
     
  同理，在进行查询的时候，可能你查询的区间是与当前节点左段点奇偶性相同的，也可能不是，要进行分类讨论
  
  在将一个查询分解到对于左右儿子的查询时，也要进行分类讨论，具体看代码：
  
```cpp
#include <cstdio>
int n,q;

struct node{
	int len,val[2];//val[0] 含区间左端点,val[1] 不含区间左端点
}tree[800005];
#define ls (rt * 2)
#define rs (rt * 2 + 1)

void pushup(int rt){
	if(tree[ls].len % 2 == 0){
		tree[rt].val[0] = tree[ls].val[0] ^ tree[rs].val[0];
		tree[rt].val[1] = tree[ls].val[1] ^ tree[rs].val[1];
	}else{
		tree[rt].val[0] = tree[ls].val[0] ^ tree[rs].val[1];
		tree[rt].val[1] = tree[ls].val[1] ^ tree[rs].val[0];
	}
}

void build(int rt,int l,int r){
	tree[rt].len = r - l + 1;
    if(l == r){
    	scanf("%d",&tree[rt].val[0]);
    	return;
    }
    int mid = l + r >> 1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    pushup(rt);
}

void modify(int rt,int l,int r,int id,int C){
	if(l == r){
		tree[rt].val[0] = C;
		return;
	}
	int mid = l + r >> 1;
	if(id <= mid){
		modify(ls,l,mid,id,C);
	}else{
		modify(rs,mid+1,r,id,C);
	}
	pushup(rt);
}

int query(int rt,int l,int r,int L,int R,int op){//op = 0 含左端点,op = 1 不含左端点
    if(l == L && r == R) return tree[rt].val[op];
    int mid = l + r >> 1;
    if(R <= mid){
    	return query(ls,l,mid,L,R,op);
    }else if(L > mid){
    	return query(rs,mid+1,r,L,R,op);
    }else{
    	if((mid - L + 1) % 2 == 0){
    		return query(ls,l,mid,L,mid,op) ^ query(rs,mid+1,r,mid+1,R,op);
    	}else{
    		return query(ls,l,mid,L,mid,op) ^ query(rs,mid+1,r,mid+1,R,!op);
    	}
    }
}

int main(){
    scanf("%d%d",&n,&q);
    build(1,1,n);
    int op,l,r,x,y;
    for(int i = 1;i <= q;i++){
        scanf("%d",&op);
        if(op == 1){
        	scanf("%d%d",&x,&y);
        	modify(1,1,n,x,y);
        }else{
        	scanf("%d%d",&l,&r);
        	if((r - l) % 2){
        		printf("0\n");
        	}else{
        		printf("%d\n",query(1,1,n,l,r,0));
        	}
        }
    }
	return 0;
}
```

- 这个做法有什么用

   实际上在本题中，它是完全劣于那个树状数组分奇偶性分别维护的做法的
   
   但是在一些题目中，就会只能用这个做法，比如我曾经做过一道题，题目大意是：
   
   给你一个序列，初始所有点的值都为 $0$，动态修改点权，保证左边的点的权值大于等于右边的权值，多次查询 $[1,x]$ 前缀内最多选 $k$ 个点，且没有两个点相邻的最大点权和
   
   这个时候就只能对于线段树上每个节点分类讨论，记录是否能选最左边的点，是否能选最右边的点的最大独立点权和，然后每次查询在线段树上二分了
   
   所以这个做法是更具拓展性的

---

## 作者：寒冰大大 (赞：2)


我们考虑一下一个长度为$x$的期区间它的子区间。

考虑$j$对答案的贡献。

对长度为$n$的区间，$j$显然贡献了$1$次。

对长度为$n-1$的区间，$j$贡献了一次或者两次。

这相当于我们用一个长方形去截这个区间，每秒移动一格，停留的时间即为对答案贡献次数。

在最边上的点自然只会贡献区间长度次答案，也就是说和区间长度奇偶性有关。

然后进一步地，一个整数$=2$个整数之和，假设我们全部分成了$x=2$的子区间，那么很容易得到每个子区间对答案贡献为$0$，也就是说$(r-l+1)$&$1==0$的时候，答案为$0$。

那么不是偶数的整么办呢？

我们也这样分开，现在两边端点贡献了奇数次，还是分成$x=2$的子区间，发现右端点对答案贡献次数都为偶数（即为$0$），即为下标奇偶性与$l$相同的$a[i]$的异或和。

由于用一个线段树/树状数组非常不好处理，所以我们用两个。

由于树状数组不能$pushup$，所以我们先让要成的数先异或一下原来的值，这样就相当于负负得正抵消了。

```cpp
#include<touwenjian.h>

using namespace std;

const int maxn=200100; 

int n,m; 
int a[maxn];

struct ctree{
	int c[maxn];
	inline int lowbit(int x){return x&(-x);}
	inline void add(int pos,int target){while(pos<=n) c[pos]^=target,pos+=lowbit(pos);}
	inline int ask(int pos){int ans=0; while(pos) ans^=c[pos],pos-=lowbit(pos); return ans;}
}ct[2]; 

int main()
{
	ios::sync_with_stdio(false);
	register int i,j;
	cin>>n>>m;
	int opt,l,r;
	for(i=1;i<=n;i++) 
	{
		cin>>a[i];
		ct[i&1].add(i,a[i]);
	}
	for(i=1;i<=m;i++)
	{
		cin>>opt>>l>>r;
		if(opt==1)
		{
			ct[l&1].add(l,a[l]^r);
			a[l]=r;
		}
		else 
		{
			if((r+l)&1) {cout<<0<<endl; continue;}
			else cout<<(ct[l&1].ask(r)^ct[l&1].ask(l-1))<<endl;
		}
	}
}

```



---

## 作者：Fairicle (赞：2)

这题看上去十分复杂，展开的一连串式子十分吓人。然而异或有这样一种性质：

$$a\ xor\ a\ =\ 0$$

观察一下样例，可以较容易发现当两个端点奇偶性不同的时候，每个点出现的次数都是偶数次，答案是 $0$。

而两个端点奇偶性相同的时候，每个与 $l$ 奇偶性相同的位置会出现奇数次（也就是有贡献产生），奇偶性不同的位置会出现偶数次，所以答案就是

$$a_l\ xor\ a_{l+2}\ ...\ xor\ a_{r}$$

~~所以题目故意展开式子是来唬你的~~由于是单点修改区间查询奇偶分开维护树状数组即可。

树状数组的实现需要作出一些改变：原本的操作是加，现在我们把它替换成了异或。所以change函数和change前要写成这个样子：

```
void change(int x,int v){
		for(ri i=x;i<=n;i+=lowbit(i)) c[i]^=v;
}

if(op==1) tree[x&1].change(x,a[x]^y),a[x]=y;//是操作1，即修改
```

类比一下普通的树状数组，就可以理解为什么change的第二个参数写成了 $a[x]\ xor\ y$（把 $a[x]$ 修改成 $y$，即把 $a[x]$ 异或上 $a[x]\ xor\ y$）。

code：
```cpp
#include"bits/stdc++.h"
using namespace std;
#define ll long long
#define ul unsigned long long
#define ui unsigned int
#define ri register int
inline int rd(){
	int x=0,flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') flag=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}
	return x*flag;
}
int n,q;
inline int lowbit(int x){return x & ( - x ) ;}
struct node{
	int c[200010];
	void change(int x,int v){
		for(ri i=x;i<=n;i+=lowbit(i)) c[i]^=v;
	}
	int sum(int x){
		int ans=0;
		for(ri i=x;i;i-=lowbit(i)) ans^=c[i];
		return ans;
	}
};
node t[2];
int a[200010];
int main()
{
	n=rd(),q=rd();
	for(ri i=1;i<=n;++i)
	a[i]=rd(),t[i&1].change(i,a[i]);
	while(q--)
	{
		int op=rd();
		int x=rd(),y=rd();
		if(op==1) t[x&1].change(x,a[x]^y),a[x]=y;
		else
		{
			if(((x^y)&1)) puts("0"); 
			else printf("%d\n",(t[x&1].sum(x-1))^(t[x&1].sum(y)));
		}
	}
    return 0;
}
```


---

## 作者：chenxia25 (赞：1)

> [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6225)

>给定$n$个自然数，第$i$个为$a_i$，支持$2$种$q$次操作：

>1. $\texttt1\ x\ v$：令$a_x=v$；
>2. $\texttt2\ l\ r$：求区间$[l,r]$的所有子区间的异或和的异或和。

>$n,q\in\left[1,2\times10^5\right]$。

对于操作$\texttt2$，考虑算贡献法，即考虑$[l,r]$内所有数被异或进答案多少次。由于是异或，偶数次相当于没有，奇数次相当于$1$次。分成$2$种情况：
1. $l\bmod2=r\bmod2$：此时$a_i$会被算$(i-l+1)(r-i+1)$次。因为$l,r$奇偶性相同，所以$i-l+1,r-i+1$奇偶性相同，那么$(i-l+1)(r-i+1)$是奇数当且仅当$i\bmod2=l\bmod2$。由于还有单点修改操作，只需维护一个BIT，里面分别维护位置奇、偶$2$种的区间异或和即可；
2. $l\bmod2\neq r\bmod2$：此时$a_i$依然会被算$(i-l+1)(r-i+1)$次。因为$l,r$奇偶性不同，所以$i-l+1,r-i+1$奇偶性不同，一奇一偶，乘积肯定偶，所以答案为$0$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int lowbit(int x){return x&-x;}
const int N=200000;
int n,qu;
int a[N+1];
struct bitree{//BIT 
	int xsm[N+1][2];//2种异或和 
	void init(){//预处理 
		static int Xsm[N+1][2]={};
		for(int i=1;i<=n;i++){
			Xsm[i][0]=Xsm[i-1][0];Xsm[i][1]=Xsm[i-1][1];
			Xsm[i][i&1]^=a[i];
			xsm[i][0]=Xsm[i][0]^Xsm[i-lowbit(i)][0];xsm[i][1]=Xsm[i][1]^Xsm[i-lowbit(i)][1];
		}
	}
	void chg(int x,int v){//单点修改 
		int p=x;
		while(x<=n)xsm[x][p&1]^=a[p]^v,x+=lowbit(x);
		a[p]=v;
	}
	int Xsm(int x,int p){//前缀异或和 
		int res=0;
		while(x)res^=xsm[x][p&1],x-=lowbit(x);
		return res;
	}
	int _xsm(int l,int r){return Xsm(r,l&1)^Xsm(l-1,l&1);}//区间异或和 
}bit;
int main(){
	cin>>n>>qu;
	for(int i=1;i<=n;i++)cin>>a[i];
	bit.init();//BIT初始化 
	while(qu--){
		int tp,x,y;
		cin>>tp>>x>>y;
		if(tp==1)bit.chg(x,y);
		else{
			if((x&1)==(y&1))cout<<bit._xsm(x,y)<<"\n";
			else puts("0");
		}
	}
	return 0;
}
```

---


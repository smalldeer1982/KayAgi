# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$0\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$0\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$0 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# 题解

## 作者：Priori_Incantatem (赞：35)

**Update 2020.08.25**：修改了一些错别字与不通顺的地方

### 题目大意

给出一个 $n$ 个点，$m$ 条边组成的森林，有 $q$ 组询问：  

1. 给出点 $x$，求点 $x$ 所在的树的直径  
2. 给出点 $x,y$，要求将 $x,y$ 所在的树之间连一条边并构成一棵新的树，满足这个新的树的直径最小

### 解题思路

首先，我们用树形DP（或bfs）求出每棵树的直径，并用并查集维护连通情况  
维护 $c$ 数组：对于每棵树的根节点 $x$，$c[x]=$ 该树的直径长度

接下来，对于每个询问 $2$（如果给出的两点在同一棵树内则忽略），利用并查集找出两棵树的根节点 $x,y$，并用并查集合并两棵树；合并后的树的直径则为 $max\{ \lceil\frac{c[x]}{2}\rceil  + \lceil\frac{c[y]}{2}\rceil +1,c[x],c[y] \}$，这里讲一下原因

要想直径最短，我们选择加边的点一定要在直径上，因为其他的点走到直径还要一段距离，从而增长了路径

那么直径就被选择的点分成了两段。因为我们要最小化较长的那一段，所以要让选择的点尽量靠近直径的中点。最后的答案就是 直径长度的一半向上取整

**注意**：后边的 $c[x],c[y]$ 一定要加上，不然只有三十分（像我一样QwQ）  
因为在合并后的树里，原来两棵树的直径还是存在的，所以新的树的直径至少是 $max(c[x],c[y])$

比如说下图：

![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDEvMjcvWmROVGdpdjdrcmhDc21jLnBuZw?x-oss-process=image/format,png)


$c[x]=4,c[y]=0$  
那么，按 $\lceil\frac{c[x]}{2}\rceil  + \lceil\frac{c[y]}{2}\rceil +1$ 算出的直径应该是 $3$。  
而正确的直径该是 $4$，所以一定要考虑 $c[x],c[y]$

最后，对于每个询问 $1$，输出该树根节点对应的 $c$ 数组值就可以了

**AC代码**

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
const int Maxn=300000+10,inf=0x3f3f3f3f;
int d[Maxn],g[Maxn];
int f[Maxn],c[Maxn]; // 这里的c数组的含义不是跟上面对应的
bool vis[Maxn];
vector <int> e[Maxn];
int n,m,q,len;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
int find(int x)
{
	if(f[x]==x)return x;
	return f[x]=find(f[x]);
}
void dfs(int x,int fa) // 树形DP求树的直径
{
	int m1=-1,m2=-1;
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i];
		if(y==fa)continue;
		dfs(y,x);
		int tmp=d[y]+1;
		d[x]=max(d[x],tmp);
		if(tmp>m1)m2=m1,m1=tmp;
		else if(tmp>m2)m2=tmp;
	}
	g[x]=max(max(0,m1+m2),max(m1,m2));
	len=max(len,g[x]);
}
void calc(int x) // 寻找树的直径
{
	len=0;
	dfs(x,0);
	c[x]=len;
}
int main()
{
//	freopen("in.txt","r",stdin);
	n=read(),m=read(),q=read();
	
	for(int i=1;i<=n;++i)
	f[i]=i;
	
	for(int i=1;i<=m;++i)
	{
		int x=read(),y=read();
		f[find(x)]=find(y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	
	for(int i=1;i<=n;++i)
	{
		if(f[i]!=i || vis[i])continue;
		calc(i);
		vis[i]=1;
	}
	
	while(q--)
	{
		int opt=read(),x=read();
		if(opt==1)
		{
			printf("%d\n",c[find(x)]);
			continue;
		}
		int y=read();
		x=find(x),y=find(y);
		if(x==y)continue;
		int tmp=((c[x]+1)>>1)+((c[y]+1)>>1)+1; //一个巧妙的向上取整的方法
		
		tmp=max(tmp,max(c[x],c[y]));
		
		f[find(x)]=find(y);
		c[find(x)]=tmp;
	}
	
	return 0;
}
```

---

## 作者：noall (赞：18)

好题啊……

又是一道让人头秃的好题啊……

真是愉悦……

居然卡memset……

看完记得点赞啊

#### 思路

这道题光读题就读了半天……

~~My vegetable has exploded……~~咳咳……看题

先看我的艰辛历程：

[历程1](https://img.langlangago.xyz/2019/06/25/5d11c47510448.png)

[历程2](https://img.langlangago.xyz/2019/06/25/5d11c4752112f.png)

[历程3](https://img.langlangago.xyz/2019/06/25/5d11c4752a4ef.png)

[历程4](https://img.langlangago.xyz/2019/06/25/5d11c47527b57.png)

树的直径大家都知道吧……不知道的可以看[这篇博客](https://big-news.github.io/2019/04/11/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/)。

这里，我用的是跑两遍大法师（$dfs$）求直径。

题目中所说的连边，也就是树的合并，那么，很明显，我们要用并查集来解决问题。

我们可以先根据已知的边，来将已知的所有树（**注意集合的合并**）都建好。然后对于这每个树，都单独跑两遍大法师，求出这棵树（**这个集合**）所拥有的直径（也就是第一问）。

哦对，顺便说一下，在跑这几遍大法师的时候，不要用$memset$初始化$vis$数组，直接在大法师$return$前$vis[x]=false$即可，否则……请看历程3。

然后，进行操作。

当$opt=1$时，直接输出x所在的树（集合）所拥有的直径（$dis[find(x)]$）即可。

当$opt=2$时，将x和y所在的集合合并($merge(x,y)$)，更新合并后的树（集合）所拥有的直径即可。

怎么更新呢？这就是这个题的难点所在了吧……~~也许~~

首先，我们可以很容易证明，一个点越靠近一个链（直径）的中点，这个点所能达到两端的最长距离最短。

来个图bb一下：

![graph.png](https://img.langlangago.xyz/2019/06/25/5d11ce16eb380.png)

我们可以看到，在该链中，两端为$0$和$4$。

我们假如取$0$这个点，那么$0$到两端的最长距离为$0$到$4$的距离，为$4$.

我们假如取最靠近该链的中点的$2$（也就是中点），那么$2$到两端的最长距离为$2$到$4$的距离，为$2$。也就是这个点所能达到两端的最长距离最短。

那么，我们连接这两棵树中的直径上最靠近中点的两个点，就可以满足“最长路径的长度最小”。

也就是$dis[yy]=max(max((dis[xx]+1)/2+(dis[yy]+1)/2+1,dis[xx]),dis[yy]);$

$xx$为$find(x)$,$yy$为$find(y)$

#### code

```c++
#include<cstdio>
#include<cstring>

#define in inline
#define re register
#define mian int main()

const int maxn=3e6+10;

struct edge{
	int to,next;
}map[maxn];

int n,m,q,fa[maxn],maxx,dis[maxn],st;
int cnt,head[maxn];
bool vis[maxn],vis2[maxn];

in int read(){
    char ch=getchar();int x=0,f=1;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

in void add(int x,int y){
	map[++cnt].to=y;
	map[cnt].next=head[x];
	head[x]=cnt;
}

in int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
in void merge(int x,int y){
	int xx=find(x),yy=find(y);
	fa[xx]=yy;
}

in void dfs(int x,int val){
	if(maxx<val) maxx=val,st=x;
	for(int i=head[x];i;i=map[i].next){
		int y=map[i].to;
		if(!vis[y]){
			vis[y]=true;
			dfs(y,val+1);
		}
	}
	vis[x]=false;//TLE的惨痛教训
}

in void dfs2(int x,int val){
	if(maxx<val) maxx=val;
	for(int i=head[x];i;i=map[i].next){
		int y=map[i].to;
		if(!vis[y]){
			vis[y]=true;
			dfs2(y,val+1);
		}
	}
	vis[x]=false;//TLE的惨痛教训
}

in int max(int a,int b){return a>b?a:b;}

mian{
	n=read(),m=read(),q=read();
	for(re int i=1;i<=n;i++) fa[i]=i;//初始化 
	for(re int i=1;i<=m;i++){
		int x=read(),y=read();
		add(x,y),add(y,x);
		merge(x,y);
	}
	for(re int i=1;i<=n;i++){
		int x=find(i);
		if(vis2[x]) continue;
		maxx=-1;
		//memset(vis,false,sizeof(vis));->TLE的罪魁祸首
		vis[x]=true;
		dfs(x,0);//大法师1
		maxx=-1;
		//memset(vis,false,sizeof(vis));->TLE的罪魁祸首
		vis[st]=true;
		dfs2(st,0);//大法师2
		vis2[x]=true;
		dis[x]=maxx;//将这棵树（这个集合）所拥有的直径记录下来
	}
	for(re int i=1;i<=q;i++){
		int opt=read(),x=read(),y;
		if(opt==1) printf("%d\n",dis[find(x)]);
		else{
			y=read();int xx=find(x),yy=find(y);
			if(xx==yy) continue;
			dis[yy]=max(max((dis[xx]+1)/2+(dis[yy]+1)/2+1,dis[xx]),dis[yy]);
			merge(x,y);
		}
	}
	return 0;
}
```

更好的体验：https://www.langlangago.xyz/index.php/archives/76/


---

## 作者：caozy623 (赞：16)

这题涉及的知识是树的直径（树上最远点对）+并查集……当时是看前三题太水加的……不过感觉可能放在普及的话也许难度是大了点……其实如果知道这个知识点的话还是比较显然的。当然还有一个难点是正确得出连接两个区域时的最优策略及怎么得出最优解，还要保证复杂度。首先，比较容易想到用并查集来动态合并+维护区域信息。然后是要输出区域中的最长路径……合并的时候也要维护最长路，使得其合并后是最短的，那么容易想到预处理出每个区域的直径……（其实就是树的直径，因为保证无环），然后合并的时候因为要求新的区域的最长路最短，那么我们定义一个点的最远距离是它到其他点的最远距离，我们合并直径是各选一个最远距离最小的点，可以证明这个点一定是直径的中点。那么接下来就比较显然了，这个新的最长路一定是max((path[y]+1)/2+(path[x]+1)/2+1,path[x],path[y])。（具体可以自己搞个样例模拟模拟就能理解了）

还有求树的直径的话两次BFS或者DFS即可，我是用的BFS。具体过程就是先选取一点u，跑出u的最远点yuan，然后从yuan跑出yuan的最远点y2，这时候y2和yuan之间的距离即为树的直径。证明这里就不证了，其实挺显然的……


  
  
```cpp
#include<iostream>  
#include<cstring>  
#include<cstdio>  
#include<algorithm>  
#include<vector>  
#include<string>  
#include<set>  
#include<queue>  
#include<stack>  
#include<map>  
#include<cmath>  
#include<cstdlib>  
#define ll long long  
#define maxn 600010  
#define inf 1000000000  
#define linf (1LL<<50)  
using namespace std;  
inline ll read()  
{  
    ll x=0,f=1;char ch=getchar();  
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}  
    while(ch>='0'&&ch<='9'){x*=10;x+=ch-'0';ch=getchar();}  
    return x*f;  
}  
inline void read(char *s,int &ts)  
{  
    char x=getchar();  
    while(!(x>='a'&&x<='z'))x=getchar();  
    while(x>='a'&&x<='z')s[++ts]=x,x=getchar();  
}  
int n,m,que,tot=0;  
int q[maxn];  
struct data{  
    int to,next;  
}e[2*maxn];  
int head[maxn];  
int path[maxn];  
int d[maxn];  
int flag[maxn];  
int f[maxn];  
void line(int a,int b)  
{  
    tot++;  
    e[tot].to=b;  
    e[tot].next=head[a];  
    head[a]=tot;  
}  
int get(int x)  
{   
    return(x==f[x])?x:f[x]=get(f[x]);  
}  
int find(int x)  
{  
    d[x]=0;  
    flag[x]=x;  
    q[q[0]=1]=x;  
    int yuan=x;  
    for(int i=1;i<=q[0];i++)  
    {  
        int y=q[i];  
        for(int u=head[y];u;u=e[u].next)  
        if(flag[e[u].to]!=x)  
        {  
            flag[e[u].to]=x;  
            q[++q[0]]=e[u].to;  
            d[e[u].to]=d[y]+1;  
            if(d[e[u].to]>d[yuan])   
            yuan=e[u].to;  
        }  
    }  
    int y2=yuan;  
    d[yuan]=0;  
    q[q[0]=1]=yuan;  
    flag[yuan]=yuan;  
    for(int i=1;i<=q[0];i++)  
    {  
        int y=q[i];  
        for(int u=head[y];u;u=e[u].next)  
        if(flag[e[u].to]!=yuan)  
        {  
            flag[e[u].to]=yuan;  
            q[++q[0]]=e[u].to;  
            d[e[u].to]=d[y]+1;  
            if(d[e[u].to]>d[y2])  
            y2=e[u].to;  
        }  
    }  
    return d[y2];  
}  
int main()  
{  
    scanf("%d%d%d",&n,&m,&que);  
    for(int i=1;i<=n;i++)  
    f[i]=i;  
    for(int i=1;i<=m;i++)  
    {  
        int x,y;  
        scanf("%d%d",&x,&y);  
        line(x,y);  
        line(y,x);  
        if(get(x)!=get(y))  
        f[get(x)]=get(y);  
    }  
    for(int i=1;i<=n;i++)  
    if(i==get(i)) path[i]=find(i);  
    for(int i=1;i<=que;i++)  
    {  
        int pos;  
        scanf("%d",&pos);  
        if(pos==1)  
        {  
            int x;  
            scanf("%d",&x);  
            printf("%d\n",path[get(x)]);  
        }  
        else  
        {  
            int x,y;  
            scanf("%d%d",&x,&y);  
            x=get(x);y=get(y);  
            if(x==y) continue;  
            int u1=path[x];  
            int u2=path[y];  
            f[x]=y;  
            path[y]=(u1+1)/2+(u2+1)/2+1;  
            if(path[y]<u1) path[y]=u1;  
            if(path[y]<u2) path[y]=u2;  
        }  
    }  
    return 0;  
}
```

---

## 作者：pengyule (赞：9)

## 题意
>  给定不一定连通的无向图，每一个连通块都是一棵无根树，进行操作：
> 1. `1 x` 查询 $x$ 所在连通块的直径
> 2. `2 x y` 【$x,y$ **联通则忽略**】在 $x,y$ 所在连通块中各取任一点并在两点间连边，使得合并后的树直径最短
>
> $n,m,q\leq3\cdot10^5$

## 分析
想到合并时可以用并查集，那么：

并查集基本操作：`find(),unite()`

**操作序列开始后**$^*$，记 $F_{find(x)}$ 表示 $x$ 的连通块内目前的直径。（$*$：指在预处理都做完，现在准备 `q--` 回答问题的时候之后）
1. 对于操作1，直接查询 $F_{find(x)}$ 输出即可
2. 对于操作2，那么记 $rx,ry$ 为 $x,y$ 所在子集的并查集根，则：首先，怎样让一棵无根树的深度最小：让直径的中点（直径长为奇数就是中间两个点中的任何一个）成为根，在此简称最小根；合并后的树的直径的最小方案为并查集 $rx,ry$ 的最小根之间连边，此时直径为 $\max\{D_{rx},D_{ry},D_{rx}'+D_{ry}'+1\}$，其中，1为所连新边，易算 $D_{rx}'=\dfrac{D_{rx}+1}{2},D_{ry}'=\dfrac{D_{ry}+1}{2}$

值得注意的是，输入时的初始连边我们同样需要将两个连通块（并查集）合并，但此时并非策略合并，而暴力合并我们就需要直接连边。在所有边输入完毕后，我们把每一并査子集的根 $rt$ 所在的连通块求一个直径作为 $F_{rt}$ 的初始值。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=3e5+5;
int n,m,q,u,l;
int fa[N],f[N];
vector<int>G[N];
void findfur(int x,int fa,int s){
	if(s>=l)l=s,u=x;
	for(int i=0;i<G[x].size();i++){
		int y=G[x][i];
		if(y^fa)findfur(y,x,s+1);
	}
}
int gd(int st){
	l=0,findfur(st,0,0);
	l=0,findfur(u,0,0);
	return l;
}
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);};
void con(int u,int v){G[u].push_back(v),G[v].push_back(u);}
void un(int u,int v){
    con(u,v);
    fa[find(v)]=find(u);
}
int main()
{
    cin>>n>>m>>q;
    int u,v,o,x,y;
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<=m;i++){
        cin>>u>>v;
        un(u,v);
    }
    for(int i=1;i<=n;i++)if(i==fa[i])f[i]=gd(i);
    while(q--){
        cin>>o;
        if(o==1){
            cin>>x;
            cout<<f[find(x)]<<endl;
        }else{
            cin>>x>>y;
            x=find(x),y=find(y);
            if(x==y)continue;
            f[x]=max(max(f[x],f[y]),(f[x]+1)/2+(f[y]+1)/2+1);
            fa[find(y)]=find(x);
        }
    }
}
```

---

## 作者：walk_alone (赞：4)

首先这个题是若干个树。特征很明显：1.路径无环 2.$m<n$ 3.已经联通的点不再处理。

然后，题目里基本挑明了要维护树的直径。先摆上树的直径的树形DP版本（感觉没什么人写这种因而放上代码）。这样主函数中就比较简洁。

```cpp
//本质就是维护最长和次长延申出去的距离。
void dfs(int place,int fa)
{
    d1[place] = d2[place] = 0;//d1表示这个节点延申出去的最长路径，d2表示这个节点延申出去次长的路径。
    for (int i = headers[place]; i;i=que[i].next)
        if(que[i].to!=fa)
        {
            dfs(que[i].to, place);
            int now = d1[que[i].to] + 1;//注意+1：因为从子节点到该节点还有1的路径长
            //注意：一个儿子只能更新一个值，不能两个同时变成全新的值，保证不会一个儿子延申出去的被计算两次导致错误
            if (now > d1[place])//now比最长的还长
            {
                d2[place] = d1[place];//移动位置，更新次长
                d1[place] = now;//更新最长
            }
            else
                if (now > d2[place])//比次长长
                    d2[place] = now;//更新次长
        }
    diameter = max(diameter, d1[place] + d2[place]);//diameter指树的直径。显然，树的直径可以由它的不同儿子延申出去的长度的和来更新。这种路径才是必然经过place节点
}
```

上述操作要对每个树进行。

然后看下面的操作。1是查询，这没话说，直接打印就好，统计下每棵树的直径然后存起来。麻烦的是2，合并操作。但是这里只有合并没有拆分操作。**并查集的用处就是维护不断合并的一些节点的可加和信息**，因此这里应该使用并查集。

有了并查集，我们判断这个点走过没走过都变得方便起来：只需要在计算树的直径的时候多加一句：

```cpp
	father[place] = fa;
```
就行。初始化的时候连那个循环都省了。没访问的节点的father为0，而走过的节点father的祖先必为根节点。

这是处理后的并查集初始化部分：

```cpp
    for (int i = 1; i <= n; i++)
        if(!father[i])//还没访问过
            dfs(i, i);//注意：此时的第二个参数不可赋为-1，因为这是并查集的初始化
```

然后就是合并操作。我们如何求两个树合并后的最小树的直径呢？

这里其实是一个贪心，结论就是**尽量取直径上的中点**。凡贪心，必证明。因而在下面进行证明：

在树上操作的时候我们通常可以画这样的一个图来进行分析：

[![sjD1A0.png](https://s3.ax1x.com/2021/01/26/sjD1A0.png)](https://imgchr.com/i/sjD1A0)

记1-4为树的直径，不妨令$dis[1][3]<dis[3][4]$。同时，1，2，4只是叶子节点，3为这两个边的交汇点。1-3，3-4，2-3中还有大量的节点未画出。那么由定义，$dis[2][3]<dis[1][3]<dis[3][4]$。

我们在合并的时候只用考察这一边的情况，另一边的情况和这边是一样的。我们需要贪心的，是让这个点到树上其他点的最大距离最小。

考虑待链接的点$x$的位置，有三种情况：在1-3上，在3-4上，在2-3上。

如果在2-3上，那么最长距离必会大于$dis[3][4]$——考虑4的贡献。

如果在1-3上，那么最长距离也会大于$dis[3][4]$——考虑4的贡献。

如果在3-4上，最长距离**可能不会大于**$dis[3][4]$——因为本身在这条边上，那么到4的距离就不会大于$dis[3][4]$。考虑1和2，由于到2的距离等于$dis[2][3]+dis[3][x]$，小于到1的距离$dis[1][3]+dis[3][x]$，因而只考虑1对答案的贡献。

显然我们只需要最小化$\max{dis[1][x],dis[x][4]}$了。那么显然，在中点的时候上述值最小（这应该是显然了），因而**每次尽量取直径上的中点**。

那么，新的直径在这颗树上的长度就应该是$\frac{diameter[1]+1}{2}$了——直径长度为偶数的时候对半取，长度为奇数的时候取一半更长的那一部分。

因此合并的时候的新直径长为$\frac{diameter[1]+1}{2}+\frac{diameter[2]+1}{2}+1$——别忘了连接的长度1。

但是！有可能一棵树很大，另一棵树很小，以至于新长度还小于大树的老长度，因而最后的合并方程（2向1合并）为：

$$diameter[1]=\max \{ \max \{diameter[1],diameter[2]\},\frac{diameter[1]+1}{2}+\frac{diameter[2]+1}{2}+1 \} $$

合并函数如下：

```cpp
void merge(int x,int y)
{
    diameter[getfather(y)] = max(max(diameter[getfather(y)], diameter[getfather(x)]), 1 + (diameter[getfather(y)] + 1) / 2 + (diameter[getfather(x)] + 1) / 2);//合并方程解释如上
    father[getfather(x)] = getfather(y);//一定注意次序！更新的信息一定要在归并前进行！
    return;
}
```
剩下的部分代码较为基础，请读者自行完成。

---

## 作者：览遍千秋 (赞：3)

## 问题描述

[LG-CF455C](https://www.luogu.org/problem/CF455C)

双倍经验.jpg

---

## 题解

首先，题目给出了 $m$ 条边，对这 $n$ 个点， $m$ 条边组成的森林，跑出每棵树的直径，同时使用并查集维护树的连通性。

考虑合并两棵树的情况：设这两棵树的代表元为 $u,v$ ，这棵树的直径有三种来源：

- $u$ 这棵树的直径

- $v$ 这棵树的直径

- 穿过 $u,v$ 合并边的一条路径

$u,v$ 两棵树的直径是已知的，所以我们只需要考虑最小化第三种情况。

设树 $u,v$ 合并时的点为 $rt_u,rt_v$ ，此时第三种情况的值为 $\frac{maxdis_{rt_u}}{2}+\frac{maxdis_{rt_v}}{2}+1$

显然，为了最小化两个 $maxdis$ ，这两个点选取的一定是原来两棵树直径的中点。

---

## $\mathrm{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

template <typename Tp>
void read(Tp &x){
	x=0;char ch=1;int fh;
	while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
	if(ch=='-') ch=getchar(),fh=-1;
	else fh=1;
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	x*=fh;
}

const int maxn=300007;
const int maxm=600007;

int n,m,T;
vector<int> G[maxn];
int fa[maxn];

int bel[maxn],cnt;

void add(int x,int y){
	G[x].push_back(y);
}

int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}

int dep[maxn],ans[maxn];

int pos,lst;

void merge(int x,int y){
	if(find(x)!=find(y)) fa[fa[x]]=fa[y];
}

void dfs(int x,int col,int dis){
	if(bel[x]==col) return;
	if(dis>=lst) lst=dis,pos=x;
	bel[x]=col;
	for(int i=0;i<G[x].size();i++){
		int y=G[x][i];
		merge(x,y);
		dfs(y,col,dis+1);
	}
}

void Getmax(){
	int mx=-1;
	for(int i=1;i<=n;i++){
		if(dep[i]>mx) mx=dep[i],pos=i;
	}
}

void cz1(){
	int x;read(x);
	printf("%d\n",ans[find(x)]);
}

void cz2(){
	int x,y;read(x);read(y);
	int xx=find(x),yy=find(y);
	if(xx==yy) return;
	fa[xx]=yy;
	ans[yy]=max(ans[xx],max(ans[yy],(ans[xx]+1)/2+(ans[yy]+1)/2+1));
}

void preprocess(){
	for(int i=1;i<=n;i++) fa[i]=i;
}

int main(){
	read(n);read(m);read(T);
	
	preprocess();
	
	for(int i=1,x,y;i<=m;i++){
		read(x);read(y);
		add(x,y);add(y,x);
	}
	
	for(int i=1;i<=n;i++){
		if(bel[i]) continue;
		lst=0,pos=i;
		dfs(i,i,0);
		lst=0;
		dfs(pos,pos,0);
		ans[find(i)]=lst;
	}
	
	int op;
	while(T--){
		read(op);
		if(op==1) cz1();
		else cz2();
	}
	
	return 0;
}
```

---

## 作者：Nero_Claudius (赞：3)

天哪这道题竟然只有一篇题解！

------------

emm，首先读题看完两个操作就已经有很明确的思路了，显然是并查集+树的直径 一波解决。

并查集不多说了，如果不了解的可以[看这里](https://www.luogu.org/blog/aaronlee/bing-zha-ji).

树的直径的思路很朴实，就是两边DFS（BFS也OK）。具体先随便找一个节点，然后搜一遍，找到最远的，然后再搜一遍，这样合在一起就一定是最长的了。

不过呢这道题还是注意一下求直径的公式，具体如下：

D_new=max(D_u,D_v,[D_u/2]+[D_v/2]+1)

那个方括号指的是取整（没找到在哪里打出来）。

en除此之外好像没什么好说的。。。

AC代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

const int maxn=300300;

int n,m,q,max_i,max_v;
int f[maxn],len[maxn],sz[maxn];
bool used[maxn];
vector<int>g[maxn];

void dfs(int val,int depth,int pos){
	if(depth>max_i){
		max_i=depth;
		max_v=val;
	}
	for(int i=0;i<g[val].size();i++){
		if(g[val][i]!=pos)dfs(g[val][i],depth+1,val);
	}
}

int calc(int val){
	max_i=-1;
	dfs(val,0,-1);
	max_i=-1;
	dfs(max_v,0,-1);
	return max_i;
}

int find(int x){
	if(x==f[x])return x;
	return f[x]=find(f[x]);
}

void merge(int x,int y){
	x=find(x),y=find(y);
	if(sz[x]>sz[y])swap(x,y);
	sz[y]+=sz[x];
	f[x]=y;
}

int radius(int x){
    return (len[x]+1)/2;
}

void merge2(int x,int y){
    x=find(x),y=find(y);
    if(x==y)return;
    if(sz[x]>sz[y])swap(x,y);
    sz[y]+=sz[x];
    f[x]=y;
    len[y]=max(max(radius(x)+radius(y)+1,len[x]),len[y]);
}

int main() {
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++){
    	f[i]=i;
    	sz[i]=i;
    	len[i]=0;
	}
    for(int i=1;i<=m;i++){
        int x,y;
    	scanf("%d%d",&x,&y);
        g[x].push_back(y);
        g[y].push_back(x);
        merge(x,y);
    }
    for(int i=1;i<=n;i++){
        int p=find(i);
        if(!used[p]){
            used[p]=1;
            len[p]=calc(i);
        }
    }
    while(q--){
        int t,x,y;
        scanf("%d",&t);
        if(t==1){
        	scanf("%d",&x);
            printf("%d\n",len[find(x)]);
        }else{
        	scanf("%d%d",&x,&y);
            merge2(x,y);
        }
    }
}
```

---

## 作者：KEBrantily (赞：2)

[Double！](https://www.luogu.com.cn/problem/CF455C)

### Description

要求完成两种操作：

- 查询一个点所在树的直径；
- 添加一条边合并两个点所在的树，要求合并后新树的直径最小。

### Solution

显然我们无法每次真的合并两棵树再重新跑一遍直径，那我们看一下树的合并有什么特殊的性质。

通过手玩几个简单的样例我们可以发现，直径为 $x$ 的树与直径为 $y$ 的树合并后形成的新树直径为 $\max\{x,y,\lceil \frac{x}{2} \rceil+\lceil \frac{y}{2}\rceil+1\}$。

因为要保证新树直径最小，那我们肯定会连接两棵树的直径的中点。

若两棵树的直径 $x>y$，那我们连接后可以发现，新树的直径大小仍然是 $x$。$x<y$ 时同理为 $y$。

若两棵树的直径 $x=y$，那我们连接后可以发现，新树的直径大小为
$\lceil \frac{x}{2} \rceil+\lceil \frac{y}{2}\rceil+1$。

因为在长度不同时前者大于后者，长度相同时后者大于前者。所以三者直接去最大值即可。

我们先求出初始的森林中每棵树的直径，合并与判断操作靠并查集实现，然后更新所在树的直径即可。


```cpp
int n,m,q,tot,len,sec;
int head[maxn],fa[maxn];
int ans[maxn],Dis[maxn];
struct edge{int fr,to,nxt;}e[maxn<<1];

void add(int fr,int to){
  e[++tot]=(edge){fr,to,head[fr]};
  head[fr]=tot;
}

int findf(int x){
  return fa[x]^x?fa[x]=findf(fa[x]):x;
}

void dfs(int u,int fat){
  Dis[u]=Dis[fat]+1;
  if(Dis[u]>len)len=Dis[u],sec=u;
  for(int i=head[u];i;i=e[i].nxt){
    int to=e[i].to;
    if(to==fat) continue;
    dfs(to,u);
  }
}

int main(){
  n=read();m=read();q=read();
  for(int i=1;i<=n;i++) fa[i]=i;
  for(int i=1,fr,to,dis;i<=m;i++){
    fr=read();to=read();
    add(fr,to);add(to,fr);
    fr=findf(fr),to=findf(to);
    if(fr!=to) fa[to]=fr;
  }
  for(int i=1;i<=n;i++){
    if(findf(i)!=i) continue;
    dfs(i,0);len=0;dfs(sec,0);
    ans[i]=len-1;len=0;sec=0;
  }
  for(int i=1,opt,x,y;i<=q;i++){
    opt=read();x=read();
    if(opt==1) printf("%d\n",ans[findf(x)]);
    else{
      y=read();x=findf(x);y=findf(y);if(x==y) continue;fa[y]=x;
      ans[x]=max(max(ans[x],ans[y]),(ans[x]+1)/2+(ans[y]+1)/2+1);
    }
  }
  return 0;
}
```

---

## 作者：Rusalka (赞：2)

~~又水了一道紫题~~

双倍经验：[CF455C Civilization](https://www.luogu.com.cn/problem/CF455C)
~~连样例都一样~~

### 一. 题意

原题连接：[P2195 HXY造公园](https://www.luogu.com.cn/problem/P2195)

- 给定 $n$ 个点 $m$ 条边的森林，一共 $q$ 次操作，每次操作包括以下两种：  

1. `1 x` ：输出点 $x$ 所在的树的直径。  

2. `2 x y` ：用一条边连接点 $x$ 和 $y$ 所在的树，并使新树的直径最小。若点 $x$，$y$ 已连通则忽视该操作。

- $1 \le m \lt n \le 3 \times10^{5} , 1 \le q \le 3\times10^{5}$

### 二. 分析与解答

首先显然需要预处理初始时森林中每棵树的直径。  
  
这个可以用树形dp $O(n)$ 解决。

具体就是记录每个结点子树中到该结点的最大长度和次大长度（不能在同一棵子树中），然后用最大长度和次大长度的和更新当前直径。

如果上面的没看懂可以看代码。

在这里，可以使用并查集维护树的连通，并且用并查集的根存储这棵树的直径长度。至于为什么，等您看完后面就知道啦。

---

然后考虑如何处理两个操作。  
  
首先观察操作 2，要求维护集合的连通性，那么很容易想到并查集。

那么不妨用并查集的根来代表这棵树。

记 $val$ 表示连通块中的直径长度。

在合并两棵树 $x$，$y$ 时，这里不妨直接设 $x$、$y$ 都为树根。由于要求新的直径最小，所以容易想到取两棵树的直径的中点连边。这样新树直径的长度就为：
$$ max(val_x,val_y,\lceil\dfrac{val_x}{2}\rceil + \lceil\dfrac{val_y}{2}\rceil+1) $$

也就是在原来 $x$ 的直径和 $y$ 的直径以及新产生的跨越两棵树的最长路径中取最大值。

在最后一个式子中，上取整表示取较长的一段，因为要算上新连上的边所以要 +1 。

---

接下来再看操作 1，就会发现只需要输出处理好的 $x$ 所在的连通块直径即可。

就做完了。

### Code

```cpp
#include <cstdio>
#include <cmath>
#include <iostream>

using namespace std;

const int MAXN = 300010;

int n, m, q;

struct edge{
	int ne, to;
	edge(int N=0,int T=0):ne(N),to(T){}
}e[MAXN<<1];
int fir[MAXN], num = 0;
inline void join(int a, int b)
{
	e[++num] = edge(fir[a], b);
	fir[a] = num;
}

int f[MAXN], val[MAXN];
int find(int x)
{
	return f[x] == x ? x : f[x] = find(f[x]);
}
inline void merge(int x, int y) // 合并两棵树 
{
	int fx = find(x), fy = find(y);
	if(fx == fy) return ;
	val[fx] =  max((val[fx]+1)/2+(val[fy]+1)/2+1, max(val[fx], val[fy]));
	// 更新新的直径 
	f[fy] = fx;
}

int maxx[MAXN][2];
void dfs(int u, int fa, int rt) // 处理直径 
{
	maxx[u][0] = maxx[u][1] = 0;
	for(int i=fir[u];i;i=e[i].ne)
	{
		int v = e[i].to;
		if(v == fa) continue;
		dfs(v, u, rt);
		int now = maxx[v][0] + 1;
		if(now > maxx[u][1])
		{
			if(now > maxx[u][0])
			{
				maxx[u][1] = maxx[u][0];
				maxx[u][0] = now;
			}
			else maxx[u][1] = now;
		}
	}
	val[rt] = max(val[rt], maxx[u][0] + maxx[u][1]);
}

int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++)
		f[i] = i;
	for(int i=1;i<=m;i++)
	{
		int a, b;
		scanf("%d%d",&a,&b);
		join(a, b);
		join(b, a);
		int fx = find(a), fy = find(b);
		if(fx != fy) f[fx] = fy;
	}
	for(int i=1;i<=n;i++)
		if(f[i] == i)
			dfs(i, 0, i);
	while(q--)
	{
		int opt, x, y;
		scanf("%d",&opt);
		if(opt == 1) 
		{
			scanf("%d",&x);
			printf("%d\n",val[find(x)]);
		}
		else 
		{
			scanf("%d%d",&x,&y);
			merge(x, y);
		}
	}
	return 0;
}
```


---

## 作者：yanxu20191617 (赞：2)

因为洛谷上 C 语言题解比较少，所以我来一发题解(虽然这道题 c 语言和 c++都差不多)。

进入主题：

看题意题目会给出一个森林，我们首先需要处理出森林中每棵无向树的直径（直径：一棵树上两个节点距离的最大值），求解树的直径主要有两种方法：树状DP和跑两遍BFS，本文中用的是两遍 bfs，对树状 DP 方法感兴趣的可以百度一下。

简单来说，第一遍 bfs 是找到距离根节点最远的节点，代码如下：

```c
int dep[N];

  dep[fa]=1; //fa 是这棵树的根节点

  int queue[N<<2],head=0,tail=1;

  queue[0]=fa;

  while(tail>head){

​    int u=queue[head++];

  for(int i=last[u];i;i=e[i].next){

​    int v=e[i].v;

​    root[v]=fa;// 并查集，下面讲

​    if(!dep[v]){

​      dep[v]=dep[u]+1;

​      queue[tail++]=v;

​    }

  }

  }

  s=queue[--head];//s 就是距离根节点最远的节点
```

 

找到s节点第一步就完成啦。

接下来第二步，从 s 节点出发，找出最大距离。

```c
 int depp[N];

  head=0;

  tail=1;

  depp[s]=1;

  queue[0]=s;

  while(tail>head){

​    int u=queue[head++];

​    for(int i=last[u];i;i=e[i].next){

​      int v=e[i].v;

​      if(!depp[v]){

​        depp[v]=depp[u]+1;

​        queue[tail++]=v;

​      }

​    }

  }

  diameter[fa]=depp[queue[--head]]-1;//di diameter[i] 记录 i 节点所在的树的直径
```





那么怎么知道要以哪个点为顶点进行 bfs，并且保证一棵树上的节点只bfs一次呢？

分离集(声明：分离集指的是并查集，下面就用分离集了)就派上用场了，在第一次bfs的时候我写了这样一条语句：root[v]=fa； 其中 root[v] 记录的是v点的祖先（不一保证是根节点）。

比如在一棵树上，

![1](https://yanx57.gitee.io/photo/tree.jpg)

 D 节点所在树的根节点为 A，但是在某一时刻不保证 root[D] 存的是 A 而是 B，但但是，只要   root[B] 存的是 A ，我们总有办法从 D 找到 A，就算 D 节点的高度再大，有这样一条链在，我们都是能最终找到 A 的。回到第一次 bfs，每一次有节点 v 进入队列 queue，我们就将 root[v] 设置为 fa，即这棵树上的根节点。进入 bfs 条件： 

```c
for(int i=1;i<=n;i++){

​    if(root[i]==i&&alone[i]){//alone[i] 为0表示 i 是一个孤立点，孤立点就没必要 bfs 了

​      bfs1(i);

​    }

  }


```



接下来，查询操作，直接输出数组 diameter 对应的记录就好。

合并操作，可以推出：对于两个点 u,v, 它们的根节点分别是 rootu，rootv，将 rootv 为根的树合并到 rootu 为根的树中，显然，在 rootv 为根的树中的最长路径的中点，向 rootu 为根的树中的最长路径的中点建边，得到的树的直径会最小，可以证明：

设 rootu 为根的树直径为 l1,rootv 为根的树直径为 l2,将 l1和 l2都分为两部分：

x1,x2,x3,x4, 则 x1+x2=l1,x3+x4=l2, 假设 x1>=x2,x3>=x4, 则x1+x3>=1/2✖️l1 的上取整+1/2✖️l2 的上取整，c语言可以写成为1/2(l1+1)+1/2(l2+1),再与原来合并前的两个树的直径取最大值即可。

完整代码：

```c
#include<stdio.h>

#include<string.h>

#include<stdlib.h>

#include<limits.h>

#include<stdbool.h>



#define N 300050

#define M 300050

int n,m,q;

int root[N],diameter[N],alone[N];



struct edge{

  int u,v;

  int next;

}e[M<<2];





int last[N],tot=0;

void addEdge(int u,int v){

  e[++tot].u=u;e[tot].v=v;

  e[tot].next=last[u];last[u]=tot;

}



int find(int x){

  if(root[x]==x) return x;

  root[x]=find(root[x]);

  return root[x];

}





int max(int x,int y){

  return x>y?x:y;

}



int min(int x,int y){

  return x<y?x:y;

}

 

int s;

void bfs1(int fa){

  int dep[N];

  dep[fa]=1;

  int queue[N<<2],head=0,tail=1;

  queue[0]=fa;

  while(tail>head){

​    int u=queue[head++];

  for(int i=last[u];i;i=e[i].next){

​    int v=e[i].v;

​    root[v]=fa;

​    if(!dep[v]){

​      dep[v]=dep[u]+1;

​      queue[tail++]=v;

​    }

  }

  }

  s=queue[--head];

  int depp[N];

  head=0;

  tail=1;

  depp[s]=1;

  queue[0]=s;

  while(tail>head){

​    int u=queue[head++];

​    for(int i=last[u];i;i=e[i].next){

​      int v=e[i].v;

​      if(!depp[v]){

​        depp[v]=depp[u]+1;

​        queue[tail++]=v;

​      }

​    }

  }

  diameter[fa]=depp[queue[--head]]-1;

}







int quickRead(){

  int a=0,b=1;

  char ch=getchar();

  while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();

  if(ch=='-') {b=-1;ch=getchar();}

  while(ch>='0'&&ch<='9') {a=a*10+ch-'0';ch=getchar();}

  return a*b;

}



int main(){

  n=quickRead();m=quickRead();q=quickRead();

  int p,u,v;

  for(int i=1;i<=n;i++) root[i]=i;

  for(int i=1;i<=m;i++){

​    u=quickRead();v=quickRead();

​    alone[u]=1;

​    alone[v]=1;

​    addEdge(u, v);

​    addEdge(v, u);

  }

  for(int i=1;i<=n;i++){

​    if(root[i]==i&&alone[i]){

​      bfs1(i);

​    }

  }



  for(int i=1;i<=q;i++){

​    p=quickRead();

​    if(p==1){

​      u=quickRead();

​      printf("%dn",diameter[find(root[u])]);

​    }else{

​      u=quickRead();v=quickRead();

​      int rootu=find(u);

​      int rootv=find(v);

​      if(rootu!=rootv){



​        int l1=diameter[rootu],l2=diameter[rootv];

​        diameter[rootu]=max(((l1+1)>>1)+((l2+1)>>1)+1,max(l1,l2));

​        root[rootv]=rootu;



​      }

​    }

  }

  return 0;

}
```



---

## 作者：Sora1336 (赞：1)

## 题意

给你一个森林。要求支持以下两个操作：

- 选中一个节点，求这个节点所在树的直径。
- 选中两棵树，连接一条能使得两棵树连接后直径最小的边。

## 解法

节点合并用并查集判断，预处理出每棵树的直径。

我们观察操作 2 。发现一个很显然的结论，就是两棵树中的直径中点连边，连后的直径最小。然后观察这两棵树的最长链上的节点个数。

- 如果两个都是奇链，合并后的中点选合并前的中点的任意一个就可以。
- 如果一个是奇链，一个是偶链，合并后的中点选偶链上的那个中点。
- 如果两个都是偶链，合并后的中点选合并前的中点的任意一个就可以。

设连结前 A 树的直径为 $d_a$，B 树的直径为 $d_b$。很显然，合并后的直径为 $l_c = \left\lceil\frac{d_a + 1}{2}\right\rceil + \left\lceil\frac{d_b + 1}{2}\right\rceil$ 。（这里的直径长为直径上点的数量）

然后在并查集上进行合并和信息向上传递即可。

## 代码

本题代码相对来说较为简单，请读者经思考后自行完成。

---

## 作者：ModestCoder_ (赞：1)

对于两个连通块连起来，肯定是在两个直径中点之间连一条边使得新的直径最短

并查集维护连通性，同时记录连通块的直径大小

令两个连通块的直径分别为$len_{s1}>len_{s2}$

则新的直径是$max(len_{s1},\frac{len_{s1}+1}{2}+\frac{len_{s2}+1}{2}+1)$

除法是上取整的意思

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 300010
using namespace std;
struct Edge{
	int to, next;
}edge[maxn << 1];
int num, head[maxn], rt, Max;
int n, m, q, f[maxn], len[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }
int getfa(int k){ return f[k] == k ? k : f[k] = getfa(f[k]); }

void dfs(int u, int pre, int s){
	if (s > Max) Max = s, rt = u;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (v != pre) dfs(v, u, s + 1);
	}
}

void merge(int x, int y){
	int s1 = getfa(x), s2 = getfa(y);
	if (len[s1] < len[s2]) swap(s1, s2);
	f[s2] = s1, len[s1] = max(len[s1], (len[s1] + 1) / 2 + (len[s2] + 1) / 2 + 1);
}

int main(){
//	freopen("1.txt", "r", stdin);
//	freopen("21.out", "w", stdout);
	n = read(), m = read(), q = read();
	for (int i = 1; i <= n; ++i) f[i] = i;
	while (m--){
		int x = read(), y = read(), s1 = getfa(x), s2 = getfa(y);
		addedge(x, y), addedge(y, x);
		f[s1] = s2;
	}
	for (int i = 1; i <= n; ++i){
		int x = getfa(i);
		if (!len[x]){
			rt = 0, Max = 0;
			dfs(i, 0, 0);
			Max = 0;
			dfs(rt, 0, 0);
			len[x] = Max;
		}
	}
	while (q--){
		int opt = read();
		if (opt == 1) printf("%d\n", len[getfa(read())]); else{
			int x = read(), y = read();
			if (getfa(x) != getfa(y)) merge(x, y);
		}
	}
	return 0;
}
```


---


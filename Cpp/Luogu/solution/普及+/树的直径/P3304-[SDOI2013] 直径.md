# [SDOI2013] 直径

## 题目描述

小 Q 最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有 $N$ 个节点，可以证明其有且仅有 $N-1$ 条边。

路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 $\text{dis}(a,b)$ 表示点 $a$ 和点 $b$ 的路径上各边长度之和。称 $\text{dis}(a,b)$ 为 $a,b$ 两个节点间的距离。

直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。

现在小 Q 想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。

## 说明/提示

【样例说明】 

直径共有两条，$3$ 到 $2$ 的路径和 $3$ 到 $6$ 的路径。这两条直径都经过边 $(3,1)$ 和边 $(1, 4)$。

对于 $100\%$ 的测试数据：$2\le N\le 2\times 10^5$，$1\le a,b\le N$，$0\le c \le10^9$。输入的图构成一棵树。

## 样例 #1

### 输入

```
6
3 1 1000
1 4 10
4 2 100
4 5 50
4 6 100```

### 输出

```
1110 
2```

# 题解

## 作者：破壁人 (赞：100)

首先求出直径这个简单，只要dfs一遍就行了。

我们再考虑第二问。要求的是所有直径都经过的边数。

所以我们先任意求出一条直径，记录这条直径上的点。

再对每个直径上的点都dfs，求出以这个点为起点的最长链（当然不能包括直径上的其它点），长度用dis[i]表示。

ls[i]表示这个点到直径左端点的距离。

rs[i]表示这个点到直径右端点的距离。（左右随意定）

从左端点开始向右遍历直径，若到了j号点发现，dis[j]=rs[j]就可以跳出循环，因为j的右边的所有边都不可能是必经边。

因为我们找到了一条不经过它们的直径。

那么是不是左端点到j就是必经边了呢？显然不是的。

因为还有可能出现这种情况，即dis[k]=ls[k],这样就变成了k的左边的所有边都不可能是必经边。

所以我们还要类似的从刚才跳出循环的点开始向左寻找这个k点。

那么j到k的所有边就是必经边了。








```cpp
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
vector<int> a[200001],b[200001];
int last[200001],u,v,next[200001];
long long dis[200001],mmm[200001],op;
bool vv[200001];
void dfs1(int o,long long p,int q)
{
    if(p>op){op=p;u=o;}
    for(int i=0;i<a[o].size();i++)
        if((!vv[a[o][i]])&&(a[o][i]!=q))
        {
            vv[a[o][i]]=true;
            dfs1(a[o][i],p+b[o][i],o);
        }
}
void dfs2(int o,long long p,int q)
{
    last[o]=q;
    dis[o]=p;
    if(p>op){op=p;v=o;}
    for(int i=0;i<a[o].size();i++)
        if((!vv[a[o][i]])&&(a[o][i]!=q))
        {
            vv[a[o][i]]=true;
            dfs2(a[o][i],p+b[o][i],o);
        }
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        a[x].push_back(y);
        b[x].push_back(z);
        a[y].push_back(x);
        b[y].push_back(z);
    }
    memset(vv,0,sizeof(vv));op=0;
    dfs1(1,0,0);
    memset(vv,0,sizeof(vv));op=0;
    dfs2(u,0,0);
    int distance=dis[v];
    cout<<dis[v]<<endl;
    memset(vv,0,sizeof(vv));
    for(int i=v;i!=0;i=last[i]) vv[i]=true;
    for(int i=v;i!=0;i=last[i])
    {
        op=0;
        dfs1(i,0,0);
        mmm[i]=op;
    }
    int j=v;
    for(int i=last[v];i!=0;i=last[i]) next[i]=j,j=i;
    int ans=0;
    int i;
    for(i=j;i!=0;i=next[i])
        if(dis[v]-dis[i]==mmm[i]) break;
    for(;i!=0;i=last[i])
    {
        if(dis[i]==mmm[i]) break;
        ans++;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：i207M (赞：60)

发现自己的做法和其他题解的都不一样，感觉自己的做法更简单，细节更少一点，不用考虑各种情况。

回想最短路的必经边如何求？我们统计S到T的最短路条数，如果一条边$cnt[S][u]\times cnt[v][T]=cnt[S][T]$，那么这条边就是必经边。

这道题同理，我们可以两次dfs时树形DP，求出dp值和最优解的方案数，如果由这条边构成的直径的方案数等于全局方案数，那么这条边就必选。

```cpp
#define N 200005
int n;
int head[N],cnte=1,v[N*2],nx[N*2],w[N*2];
il void adde(int uu,int vv,int ww)
{
	v[++cnte]=vv,nx[cnte]=head[uu],head[uu]=cnte,w[cnte]=ww;
}
struct Data
{
	LL w,cnt;
	Data() {}
	Data(const LL &_w,const LL &_cnt) {w=_w,cnt=_cnt;}
	il void comb(const Data &v)
	{
		if(v.w>w) w=v.w,cnt=v.cnt;
		else if(v.w==w) cnt+=v.cnt;
	}
};
Data f[N],D,g[N];
int fe[N];
void dfs(int x,int _fa)
{
	f[x].w=0,f[x].cnt=1;
	for(ri i=head[x]; i; i=nx[i])
	{
		if(v[i]==_fa) continue;
		fe[v[i]]=w[i];
		dfs(v[i],x);
		D.comb(Data(f[x].w+f[v[i]].w+w[i],f[x].cnt*f[v[i]].cnt));
		f[x].comb(Data(f[v[i]].w+w[i],f[v[i]].cnt));
	}
}
int ans;
Data qz[N],hz[N];
il void check(const Data &v)
{
	if(D.w==v.w&&D.cnt==v.cnt) ++ans;
}
void efs(int x,int _fa)
{
	if(!_fa) g[x].cnt=1;
	else
	{
		g[x]=Data(g[_fa].w+fe[x],g[_fa].cnt);
		g[x].comb(Data(qz[x].w+fe[x],qz[x].cnt)),g[x].comb(Data(hz[x].w+fe[x],hz[x].cnt));
		check(Data(g[x].w+f[x].w,g[x].cnt*f[x].cnt));
	}
	static int st[N]; int tp=0;
	Data t; t.w=t.cnt=0;
	for(ri i=head[x]; i; i=nx[i])
	{
		if(v[i]==_fa) continue;
		st[++tp]=v[i];
		qz[v[i]]=t;
		t.comb(Data(f[v[i]].w+w[i],f[v[i]].cnt));
	}
	t.w=t.cnt=0;
	for(ri i=tp; i>=1; --i)
	{
		hz[st[i]]=t;
		t.comb(Data(f[st[i]].w+fe[st[i]],f[st[i]].cnt));
	}
	for(ri i=head[x]; i; i=nx[i])
	{
		if(v[i]==_fa) continue;
		efs(v[i],x);
	}
}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	in(n);
	for(ri i=1,a,b,c; i<n; ++i)
	{
		in(a,b,c);
		adde(a,b,c),adde(b,a,c);
	}
	dfs(1,0);
	efs(1,0);
	out(D.w);
	out(ans);
	return 0;
}
```


---

## 作者：wu3412790 (赞：42)

这道题用到了一个非常有用的引理，树的所有直径拥有相同的中点！NOI2013有个叫快餐店的题也可以用这个引理。

这里中点可能在一条边的内部。证明的话用反证法，大家自己一画就明白。

这样一来，随便找一条直径，如果中点在某条边内部，那么这条边毫无疑问是在所有直径上的，然后我们去掉这条边，在剩下的两棵有根树里分别找从根到叶子的最长路上哪些边是必须的，递归解决即可。这个子问题非常有用，我们在这里叫他RootLeafPath。

另一种情况是中点是某个顶点，这时我们以中点为根dfs,那么所有直径都经过根，怎么看哪些边是必须的呢？显然要挑两个根的儿子往下走，我们设f[x]表示从一个节点向下走的最大深度，并挑出根的儿子中f[x]+(根到x的边权)中前三大的，不妨设他们是a,b,c。分为三种情况|：(1)如果b>c,那么在a,b对应的子树里做RootLeafPath即可。
(2)如果a>b=c,那么只在a对应子树里做RootLeafPath即可。
(3)如果a=b=c，这时没有任何一条边是必须的，输出0。
```cpp
#include <stdio.h>
#include <queue>
using namespace std;
int const N=4e5+1;
struct node{
	int x;
	long long val;
	friend bool operator <(node a, node b){
		return a.val<b.val;
	}
};
int n,tot,to[N],pre[N],last[N],fa[N],ans=0;
long long v[N],d[N],f[N];
priority_queue<node> h;
void add(int a, int b, int c){
	to[++tot]=b;
	pre[tot]=last[a];
	last[a]=tot;
	v[tot]=c;
}
void dfs(int x, int father, long long deep){
	d[x]=deep;
	fa[x]=father;
	f[x]=0;
	for (int i=last[x];i;i=pre[i])
		if (to[i]!=father) {
			dfs(to[i],x,d[x]+v[i]);
			f[x]=max(f[x],f[to[i]]+v[i]);
		}
}
void work(int x, int father, int deep){
	dfs(x,father,deep);
	while (true){
		int y=0,cnt=0;
		for (int i=last[x];i;i=pre[i])
			if (to[i]!=father && f[x]==f[to[i]]+v[i]) y=to[i],cnt++;
		if (cnt==0 || cnt>=2) break;
		father=x;
		x=y;
		ans++;
	}
}
int main(){
	freopen("p3304.in","r",stdin);
	scanf("%d",&n);
	if (n==2){
		printf("1");
		return 0;
	}
	for (int i=1;i<=n-1;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c); 
		add(a,b,c);
		add(b,a,c);
	}
	dfs(1,0,0);
	int now=0;
	for (int i=1;i<=n;i++)
		if (d[i]>d[now]) now=i;
	dfs(now,0,0);
	now=0;
	for (int i=1;i<=n;i++)
		if (d[i]>d[now]) now=i;
	long long L=d[now];
	while (d[fa[now]]*2>=L) now=fa[now];
	if (d[now]*2==L){
		dfs(now,0,0);
		for (int i=last[now];i;i=pre[i])
			h.push((node){to[i],v[i]+f[to[i]]});
		node a=h.top();
		h.pop();
		node b=h.top();
		h.pop();
		if (h.empty()){
			ans+=2;
			work(a.x,now,0);
			work(b.x,now,0);
		} else{
			node c=h.top();
			if (b.val>c.val){
				ans+=2;
				work(a.x,now,0);
				work(b.x,now,0);
			} else{
				if (a.val>b.val){
					ans++;
					work(a.x,now,0);
				}
			}
		}
	}
	else{
		ans++;
		work(now,fa[now],0);
		work(fa[now],now,0); 
	}
	printf("%lld\n",L);
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：_J_C_ (赞：24)

~~[悄咪咪的给题解加标签:树型结构，bfs，dfs，链表]~~

T.T想了快一天了，~~最后瞄了一眼题解~~，重构之后写出来了QwQ

[楼下有一位大佬题解详尽而且很通俗易懂，不过他大概是忘了给代码加注释了……**我主要分享一下具体实现**]

题意是给定一棵有权的树，求树的直径大小及有多少边在所有直径中都出现了。

首先先**随便找一条直径**。稍微具体的说就是先任意选取一个点，bfs/dfs出树上离这个点最远的一个点right（可能有多个，但一个就好），然后在以right为起点重复bfs/dfs一次，得到left。那么left

与right就是树上某一条直径的两端了。（证明略←w←）

好了，我们找到了一条直径。我们不妨把它**看做是直的**。

![](https://cdn.luogu.com.cn/upload/pic/24329.png)

对，就中间最粗的那个条，就是我们找到的直径。

看下面，我们发现了一处很**不和谐**的地方：（红色圈内）

![](https://cdn.luogu.com.cn/upload/pic/24332.png)

哪里不和谐呢？这两条边看(ji)上(suan)去(chu)是相等的！

这意味这什么呢，这说明这里还有一条隐藏的树的直径：

![](https://cdn.luogu.com.cn/upload/pic/24330.png)

而很显然的是：这两条直径有分叉，或者说不相交的地方：

![](https://cdn.luogu.com.cn/upload/pic/24332.png)

那么这个分叉点之下就都没机会了，**因为已经有两条直径不在这边相交了**，可以丢了。

如果我们对left与right(上文中我们找到的树的直径的两端)间任意一点都判断了它是否分叉，最后我们就能得到一个不分叉的区间，区间内所有的边就是我们要的答案了。

为什么呢？因为所有直径间必然互相有交点（否则，交叉的“直径”可以通过连接它们的边“**取长补短**”从而延长）。所以我们只要沿着当前直径间的点走，向两侧延伸查找最长距离，判断是否分叉即可保证我们考虑了所有的直径与所有可能被所有直径经过的边。

###  _[系统提示:]恭喜你，思路到此结束。如果你对如何实现有困惑，不妨继续往下阅读。_ 

考虑一下如何实现。

建图就不多说了，记得加双向边和开两倍数组（邻接表）。

首先用广搜bfs(int start, int& faraway)找到距离start最远的点faraway。具体的实现方式是**用bVis[]表示这个点是否被访问过**（树上广搜时不可能返回，又不是有环图的最短路233），**用dis[]表示从start搜到当前点的距离**。如果dix[x]>dis[faraway]，则更新faraway。

对于这个bfs,更加具体的细节是:faraway先初始化为0，因为没有0号点，dis[0]一直是0，很“容易”被更远的点覆盖。

更值得一提的是，**这个用驼峰命名法出来的bVis[]居然不是bool，而是个int，而且还要用一个NextVis与它比较**。这是因为我们需要多次使用bVis[]数组（还有下面的dfs呢），每次使用当然都要初始化它，这就浪费了大把的时间。我的做法是使用一个变量NextVis来代表真值——如果bVis[x]==NextVis，则为真：否则为假。这样子每次初始化只要++NextVis就好了。（这样子跑出来670ms,每次都memset跑出来是3576ms）当然，读者可能有不同的操作来避免反复初始化，或者有根本不需要这个数组的做法233。

还有就是**为了知道这个点是否分叉，我们需要知道它到直径左、右端点的距离**。如果这个距离等于它向侧面延伸出去的最长长度，那么就分叉了。（如果这个距离小于它延伸的最长长度，恭喜你，直径找错了）而且同时我们最好先把left与right间的点分出来，这样处理起来方便。

我的做法是在bfs时使用链表forward[x]记录x这个点是从哪里走过来的，并用disforward[x]记录走过来的边长（或者直接查找也行，毕竟这是一棵树）。在解析时沿着forward[x]走并写入mid[]，**累加/累减得到它到两端点的距离**并用end存mid里有多少个元素，同时标记bInList表示它在直径里。


烦人的bfs和解析终于过去了，现在考虑一下怎么让一个点找到向侧面延伸的最长长度length[]。**这个**~~简直~~**就是搜索**。在点x处枚举它相邻的点，并排除相邻点在直径内的情况，dfs递归并从这些点中取出一个最大值。

最后，用for循环枚举mid里所有点，依次调用dfs，比较长度得知是否分叉；获取左右极限点后就可以输出答案了（**看着洛谷AC的花蹦出来真是一件快乐的事情23333**）

顺便说一句，记得long long……（并不知道不写会不会过，但是**200000个点，边权在1e9内怕还是很玄**）

如果还有疑惑，下面还有完整的、加了注释的代码：

```cpp
#include <cstdio>
#include <cstdlib>

#include <queue>

#define FOR_EDGE(i, pt) for (int i(iHead[pt]); i; i = all[i].next)//这个宏用来枚举这个点连出去的所有边

class edge
{
public:
	int fr, to, next;
	long long len;
}all[412345];
int iHead[212345];//邻接表

int iEnd(2);

void add(int fr, int to, long long len)//加边
{
	all[iEnd].fr = fr;
	all[iEnd].to = to;
	all[iEnd].len = len;
	all[iEnd].next = iHead[fr];
	iHead[fr] = iEnd++;
}

int n;

int left, right;//第一条直径的左右端（理解上可以是左右，实际上鬼知道呢2333）
int NextVis;
int bVis[212345], forward[212345];
long long disforward[212345];
long long dis[212345];

void bfs(int start, int& faraway)//寻找距离start最远的点faraway
{
	faraway = 0;
	dis[start] = 0;
	bVis[start] = ++NextVis;
	std::queue<int> que;
	que.push(start);
	while (!que.empty())
	{
		int now(que.front());
		que.pop();
		FOR_EDGE(i, now)
		{
			if (bVis[all[i].to] ^ NextVis)//不要多虑，就是"!="的意思
			{
				bVis[all[i].to] = NextVis;
				dis[all[i].to] = dis[now] + all[i].len;
				forward[all[i].to] = now;//链表记录这个点来处
				disforward[all[i].to] = all[i].len;
				que.push(all[i].to);
				if (dis[all[i].to] > dis[faraway]) faraway = all[i].to;
			}
		}
	}
}


int mid[212345], end;//直径端点间的点
bool bInList[212345];
long long leftlen[212345], rightlen[212345];//这个点到直径左/右端的距离，用它在mid中的下标访问
long long length[212345];//这个点向两侧延伸的最大长度，用点的标号访问（比较人家dfs还要用）

int dfs(int now)
{
	FOR_EDGE(i, now)
	{
		if (!bInList[all[i].to] && bVis[all[i].to] ^ NextVis)//这个点不在直径内 且 这个点未被访问
		{
			bVis[all[i].to] = NextVis;
			long long val(all[i].len + dfs(all[i].to));//
			if (val > length[now]) length[now] = val;
		}
	}
	return length[now];
}


inline int max(int a, int b) { return a > b ? a : b; }

int main()
{
	scanf("%d", &n);
	for (int i(1); i != n; ++i)
	{
		int fr, to;
		long long len;
		scanf("%d%d%lld", &fr, &to, &len);
		add(fr, to, len);
		add(to, fr, len);
	}
	left = 1;
	bfs(left, right);//两次bfs得到直径
	bfs(right, left);
	long long ans(dis[left]);
	int pos(left), disleft(0), disright(dis[left]);//由于pos从左端点开始，它最初到右端距离即左端点到右端点的距离dis[left]
	bInList[left] = true;
	bInList[right] = true;//左右端点当然在直径里啦
	while (pos != right)//这里pos开始从left向right（从"左"到"右"）
	{
		leftlen[end] = disleft += disforward[pos];//累加它到左端的距离
		rightlen[end] = disright -= disforward[pos];
		pos = forward[pos];
		mid[end] = pos;
		bInList[pos] = true;
		++end;
	}
	int leftend(0), rightend(end - 1);
	for (int i(0); i != end; ++i)
	{
		++NextVis; dfs(mid[i]);
		if (length[mid[i]] == leftlen[i]) leftend = i;
		if (length[mid[i]] == rightlen[i])
		{
			rightend = i;//如果右边分叉掉了，在向右枚举i就没有必要了：因为右边都可以扔了
			break;
		}
	}
	printf("%lld\n%d\n", ans, max(0, rightend - leftend));
	return 0;
}
//The newline at the end of file :)
```

忽然想起来，dfs之前是可以不用memset的，因为它能搜到的位置被直径限制了……所以即使memset，用的好也不用3700ms。
]




---

## 作者：lx_zjk (赞：21)

来写一份题解吧 这好像是近期我的第一篇题解 

首先这道题目需要了解树的直径的一个性质 

数的直径必须经过一个点 且这个点为这个直径的中点 

反证法:
		
    假设有两条不相交的直径
	
    因为树上任意两点都有一条唯一的路径
   	
    那么假设连接两个中点的长度为len, 直径长度为max_d
    
    那么两条直径的两端距离为max_d + len > max_d
    
   	那么直径长度不是len
     
    矛盾
    
    所以两条直径必须经过一个点

同理证明这个点是中点 也可以用相同方法 ~~易证~~

那么有了这个的话 做这道题应该好做多了 先两遍$dfs$跑出$l$$和r$ 

然后对于两个端点所经过的路径上 跑一遍$dfs$ 如果$maxd == dis$那么就说明那个点不是必须点 可以$pass$ 然后就可以了

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <set>
#include <map>
#include <queue>

using namespace std;

typedef long long ll;

const int INF = 2139062143;

#define DEBUG(x) std::cerr << #x << " = " << x << std::endl

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 2e5 + 7;

struct EDGE {
	int to, next, w;
} edge[MAX_N << 1];

int head[MAX_N], E;

void addedge (int u, int v, int w) {
	edge[++E].to = v;
	edge[E].next = head[u];
	edge[E].w = w;
	head[u] = E;
}

int n, ans, f[MAX_N], vis[MAX_N], p, l, r;

ll dep[MAX_N], max_d;

inline void dfs (int u, int fa) {
	f[u] = fa;
	for (int i = head[u]; i; i = edge[i].next ) {
		int v = edge[i].to, w = edge[i].w;
		if (v == fa) continue;
		dep[v] = dep[u] + w;
		if (dep[v] > max_d) {
			max_d = dep[v];
			p = v;
		}
		dfs (v, u);
	}
}

inline void dfs2 (int u, int fa) {
	for (int i = head[u]; i; i = edge[i].next ) {
		int v = edge[i].to, w = edge[i].w;
		if (vis[v] || fa == v) continue;
		dep[v] = dep[u] + w;
		if (dep[v] > max_d) max_d = dep[v];
		dfs2 (v, u);
	}
}

int main() {
	n = read ();
	for (int i = 1; i < n; i ++ ) {
		int u = read (), v = read (), w = read ();
		addedge (u, v, w);
		addedge (v, u, w);
	}
	dfs (1, 0);
	l = p;
	max_d = 0;
	dep[p] = 0;
	dfs (l, 0);
	r = p;
	printf ("%lld\n", max_d);//开longlong
	bool flag = 0;
	for (int i = r; i; i = f[i]) vis[i] = 1;
	int ll = l, rr = r;
	for (int i = f[rr]; i != ll; i = f[i]) {
		int l_dis = dep[i], r_dis = dep[rr] - dep[i];
		dep[i] = max_d = 0;
		dfs2 (i, 0);
     //l找最右 r找最左 所以l只需要找一次就行了
		if (max_d == r_dis)
			r = i;
		if (max_d == l_dis && !flag) {
			flag = 1;
			l = i;
		}
	}
	int ans = 1;//为什么初始化ans = 1 因为后面 (i != l) 没有把l算进去
	for (int i = f[r]; i != l; i = f[i]) ans ++ ;
	cout << ans << endl;
	return 0;
}



```

---

## 作者：ShuYuMo (赞：10)

# 【luogu-3304】【SDOI2013】直径
## 前提
我们需要明确以下几个条件：
 - 树的直径会有很多条
 - 一般地，树的这些直径有且只有一段重合。特殊地，这一段可能是一个点。
 ![例子](https://cdn.luogu.com.cn/upload/pic/61338.png)
 ![2](https://cdn.luogu.com.cn/upload/pic/61339.png)
 如图路径$3-1-4$是重合的。
## 思路
求出重合的这一段的长度，就是最终答案。
## 求法
要求这条路径的长度，由于是在树上的，所以只需要求出路径两端的端点即可

这端点是什么呢	

就是各直径在这条重合路径同侧的端点的`LCA`

例子就是上图中，第一条路径是$3-2$,第二条路径是$3 - 6$,重合路径是$3-4$。
两条直径的端点$6$和$2$在重合路径$3-4$的同侧。我们只需要求端点$6$和$2$的`LCA`即点$4$就是重合路径的一个端点。

同理，求出另一个端点即可。

特殊地，对于一个点的`LCA`就是它本身。

但是多个点的`LCA`我不会用倍增求……呜呜呜呜呜。

然后用欧拉序求出`LCA`即可，然后求两个`LCA`的距离。
## 代码
```cpp
/*!
 * FileName: luogu-3304.cpp
 * This Problem is on luogu. The ID of the problem is 3304. 
 * Copyright(c) 2019 Shu_Yu_Mo
 * MIT Licensed
 * Luogu: https://www.luogu.org/space/show?uid=44615
 * Github: https://github.com/oldsuold/
 * Gitee: https://gitee.com/Shu_Yu_Mo/
 * These words were created by an amazing tool written by Shu_Yu_Mo.
 */
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
#include<queue>
#include<algorithm>
#define inf 0x7fffffff
#define int long long
using namespace std;
const int _N = 200100;
const int _M = _N;
inline int read()
{
    char c = getchar(); int sign = 1; int x = 0;
    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); } 
    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }
    return x * sign;
}
void swap(int & x, int & y)
{
	int t = x;
	x = y;
	y = t;
}
int n, m; 
struct edges{
    int node;
    int w;
    int nxt;
}edge[_M << 1];
int tot = 0;
int head[_N];
void add(int u, int v, int w)
{
    edge[++tot].nxt = head[u];
    edge[tot].node = v;
    edge[tot].w = w;
    head[u] = tot;
}
bool vis[_N];
int dist[_N];
void dfs(int nowNode)
{
//	if(vis[edge[i].node]) continue;
	vis[nowNode] = true;
	for(register int i = head[nowNode];i;i = edge[i].nxt)
	{
		if(vis[edge[i].node]) continue;
		dist[edge[i].node] = dist[nowNode] +  edge[i].w;
		dfs(edge[i].node);
	}
}
bool B[_N];
int Er[_N << 1], tot_Er = 0;
int first[_N], tot_F = 0;
int MinId = inf;
int MaxId = -inf;
void dfsForLCA(int k)
{
	vis[k] = true;
	first[k] = ++tot_F;
	Er[++tot_Er] = k;
	for(register int i = head[k];i;i = edge[i].nxt)
	{
		int SonNode = edge[i].node;
		if(vis[SonNode]) continue;
		dfsForLCA(SonNode);
		Er[++tot_Er] = k;
	}
}
int To;//, ansB;
int ans = 0;
int RunningAns = 0;
void dfsLast(int k)
{
	if(k == To)
	{
		ans = RunningAns;
		return;
	}
	vis[k] = true;
	for(register int i = head[k];i;i = edge[i].nxt)
	{
		int SonNode = edge[i].node;
		if(vis[SonNode]) continue;
		RunningAns++;
		dfsLast(SonNode);
		RunningAns--;
	}
}
signed main()
{	
//	freopen("test.in.txt", "r", stdin);
	int k = 1;
	memset(vis, false, sizeof(vis));
	n = read(), m = n - 1;
	for(register int i = 1;i <= m;i++)
	{
		int tmpx = read(), tmpy = read(), tmpz = read();
		add(tmpx, tmpy, tmpz);
		add(tmpy, tmpx, tmpz);
		k = tmpx;
	}
	int MaxDis = 0, MaxId;
	memset(dist, 0, sizeof(dist));
//	printf("Start at %d\n", k);
	dfs(k);
	for(register int i = 1;i <= n;i++)
	{
//		printf("%d ", dist[i]);
		if(dist[i] > MaxDis)
		{
			MaxDis = dist[i];
			MaxId = i;
		}
	}
//	printf("%d\n", MaxId);
	
	memset(dist, 0, sizeof(dist));
	memset(vis, false, sizeof(vis));
	dfs(MaxId);
	int MaxDis_ = 0;
	int MaxAns = -inf;
	for(register int i = 1;i <= n;i++)
		MaxDis_ = max(MaxDis_, dist[i]);
	MaxAns = MaxDis_;
	for(register int i = 1;i <= n;i++)
		B[i] = (dist[i] == MaxDis_);
	
	memset(first, -1, sizeof(first));
	memset(vis, false, sizeof(vis));
	dfsForLCA(MaxId);
	
	for(register int i = 1;i <= tot_Er;i++) 
	{
//		printf("%d ", Er[i]);
		if(B[Er[i]])
		{
			MinId = min(MinId, i);
			MaxId = max(MaxId, i);
		}
	}//cout<<endl;
//	for(register int i = 1;i <= tot_Er;i++) 
//		printf("%d ", first[Er[i]]);
	//printf("\n%d %d\n", MinId, MaxId);
	int F_Min = inf;
	int LCA_Id; 
	for(register int i = MinId;i <= MaxId;i ++)
	{
		//printf("at %d , Er[%d] = %d, First[%d] = %d\n", i, i, Er[i], Er[i], first[Er[i]]);
		if(F_Min > first[Er[i]])
		{
			F_Min = first[Er[i]];
			LCA_Id = Er[i];
		}
	}
	//printf("LCA = %d\n", LCA_Id);
//	printf("MaxDist = %d, node = %d ,%d\n", MaxDis2, MaxId2, MaxId);
	
	memset(dist, 0, sizeof(dist));
	memset(vis, false, sizeof(vis));
	int S = Er[MinId];
	dfs(S);//printf("%d", S);
	memset(first, -1, sizeof(first));
	tot_Er = 0;
	tot_F = 0;
	for(register int i = 1;i <= n;i++)
		B[i] = (dist[i] == MaxDis_);
	memset(vis, false, sizeof(vis));
	dfsForLCA(S);
	MinId = inf; MaxId = -inf;//cout<<endl<<endl<<"&"<<endl;
	for(register int i = 1;i <= tot_Er;i++) 
	{
//		printf("%d ", Er[i]);
		if(B[Er[i]])
		{
			MinId = min(MinId, i);
			MaxId = max(MaxId, i);
		}
	}
//	printf("MaxId = %d, MinId = %d\n", MaxId, MinId);
	F_Min = inf;
	int LCA_Id2; 
	for(register int i = MinId;i <= MaxId;i ++)
	{
//		printf("at %d , Er[%d] = %d, First[%d] = %d\n", i, i, Er[i], Er[i], first[Er[i]]);
		if(F_Min > first[Er[i]])
		{
			F_Min = first[Er[i]];
			LCA_Id2 = Er[i];
		}
	}
//	printf("\n###%d %d\n", LCA_Id2, LCA_Id);
	To = LCA_Id;
	memset(vis, false, sizeof(vis));
	dfsLast(LCA_Id2);
	printf("%lld\n%lld", MaxAns, ans);
	
    return 0;
}

```


---

## 作者：Toheart (赞：10)

#洛谷首题解！

##第一问：裸求树的直径，跑两遍DFS/DFS/树形DP，原理请百度。

##第二问：易知答案边一定在开始求的直径上，易知将所有的直径覆盖在一起形似一个两边有分叉的树干，所以要缩小左右端点的范围。具体要遍历直径，并判断每个点是否为两直径交点，若是则将分叉的点舍弃掉。

···





```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 200010;
int n, tot, far;
long long maxd;
int st[maxn], fa[maxn];
long long dis[maxn];
bool isol[maxn];
struct node{
    int v, w, nxt;
} edge[2*maxn];
inline void in(int x, int y, int z){
    edge[++tot].v = y;
    edge[tot].w = z;
    edge[tot].nxt = st[x];
    st[x] = tot; 
}
void DFS(int now, int f){
    fa[now] = f;
    if(maxd < dis[now]){
        far = now;
        maxd = dis[now];
    }
    for(int i = st[now]; i; i = edge[i].nxt){
        int to = edge[i].v;
        if(to != f){
            dis[to] = dis[now] + edge[i].w;
            DFS(to, now);
        }
    }
}
void Liuhaoyu(int now, int f){
    if(maxd < dis[now])    maxd = dis[now];
    for(int i = st[now]; i; i = edge[i].nxt){
        int to = edge[i].v;
        if(to != f && !isol[to]){
            dis[to] = dis[now] + edge[i].w;
            Liuhaoyu(to, now);
        }
    }
}
int main(){
    scanf("%d", &n);
    for(int i = 1, x, y, z; i < n; i++){
        scanf("%d%d%d", &x, &y, &z);
        in(x, y, z);
        in(y, x, z);
    }
    DFS(1, 0);
    //printf("%d\n", far);
    int op = far;
    maxd = dis[op] = 0;
    //memset(fa, 0, sizeof(fa));
    DFS(op, 0);
    //printf("%d\n", far);
    /*for(int i = 1; i <= n; i++)
        printf("%d ", dis[i]);*/
    printf("%lld\n", maxd);
    for(int i = far; i; i = fa[i])
        isol[i] = 1;
    int l = op, r = far;
    bool flag = 0;
    for(int i = fa[far]; i != op; i = fa[i]){
        int ld = dis[i];
        int rd = dis[far] - dis[i];
        maxd = dis[i] = 0;
        Liuhaoyu(i, 0);
        if(maxd == ld && !flag){
            l = i;
            flag = 1;
```
}//左端点只能缩一次，因为点从右端遍历过来，若再改变左端点范围会扩大。
```cpp
        if(maxd == rd)    r = i;
    }
    long long ans = 0;
    for(int i = r; i != l; i = fa[i])//注意是边，所以少一个 
        ans++;
    printf("%lld\n", ans);
    return 0;
}
···
```

---

## 作者：codesonic (赞：8)

应该是第一篇随机化...

因为看到题解有人统计每条边作为方案的次数，那条边使用的次数=直径数量就是答案

于是我萌生了这个随机化的想法

求直径dfs大家都会

随机抓出来一条直径，然后把直径上的边打个tag

然后随机抓几次，如果某条边每次都被抓到就假装他是必经边

~~所以这道题是树的直径板子题！~~

正确性没法保证

感觉挺容易卡，卡法是构造一条边使得**大部分直径**（而不是全部直径）经过。

比如以下这个图

![](https://cdn.luogu.com.cn/upload/image_hosting/e51tkayh.png)

然后让6号连一大堆节点，然后祈祷上天随机抓出来的直径都经过边$(4,6)$就行了。

~~写了题解然后把自己给叉了（x）~~

对于这个卡法也有针对的方案，dfs算直径的时候优先走被打tag次数少的边

这样会变得更难叉

那么，我这个做法放在这里看看有没有人能叉掉我了（

然而我这里只**纯随机**拎出来十条直径就过了...

没开longlong调了好久TAT..

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

const int maxn=400010;
int n;
struct node{
	int to,nxt,w,id;
}tr[maxn];int head[maxn],tot=0;
struct edge{
	int U,V,W,id;
}s[maxn];
int rt1,rt2;
inline void addedge(int u,int v,int w,int id){
	tr[++tot].to=v;
	tr[tot].id=id;
	tr[tot].w=w;
	tr[tot].nxt=head[u];
	head[u]=tot;
}

int dep[maxn],mxdep=0,mxid;
void dfs(int u,int fa){
	if(dep[u]>mxdep) {
		mxid=u;
		mxdep=dep[u];
	}
	for(int i=head[u];i;i=tr[i].nxt){
		int to=tr[i].to;
		if(to==fa) continue;
		dep[to]=dep[u]+tr[i].w;
		dfs(to,u);
	}
}//找深度最深的点

int isans[maxn];

bool getans(int now,int V,int fa){
	if(now==V) return 1;
	for(int i=head[now];i;i=tr[i].nxt){
		int to=tr[i].to;
		if(to==fa) continue;
		if(getans(to,V,now)){
			isans[tr[i].id]++;
			return 1;
		}
	}
	return 0;
}//给直径打tag

signed main(){
	scanf("%lld",&n);
	for(int i=1;i<n;i++){
		scanf("%lld%lld%lld",&s[i].U,&s[i].V,&s[i].W);
		s[i].id=i;
	}//这里通过改变加边顺序来获得不同的直径
    //不知道有没有其他更好的方法，我比较菜就这么写了/kel
	int Tim=10;
	for(int limit=1;limit<=Tim;limit++){
		random_shuffle(s+1,s+n);
		memset(head,0,sizeof head);tot=0;memset(dep,0,sizeof dep);memset(tr,0,sizeof tr);
		for(int i=1;i<n;i++) addedge(s[i].U,s[i].V,s[i].W,s[i].id),addedge(s[i].V,s[i].U,s[i].W,s[i].id);
		dfs(1,0);rt1=mxid;
		mxdep=0;memset(dep,0,sizeof dep);
		dfs(rt1,0);
		rt2=mxid;
		getans(rt1,rt2,0);
	}
	int Ans=0;
	for(int i=1;i<n;i++) if(isans[i]==Tim) Ans++;
	printf("%lld\n%lld\n",mxdep,Ans);
}
```

---

## 作者：ljc20020730 (赞：7)

先将树的任意一条直径找出来，考虑树的直径一定是交于一条线段上的。
那么从直径两段往中间搜一定是中间这一段路径是唯一的。

设直径是$[s,t]$，把这个直径拉出来，左侧是$s$，右侧是$t$;

- 先以$s$为根，然后跑整一棵树，求出子树最长链和它的条数.
- 从$t$开始向左遍历整个直径，找到最左侧的一个点$v$使得其右侧相邻的一条边不是必经边(即使得当前点的右侧最长链条数不发生变化)
- 然后以$t$为根，然后跑整一棵树，求出子树最长链和它的条数.
- 从$s$开始向右遍历整个直径，找到最右侧的一个点$u$使得其左侧相邻的一条边不是必经边(即使得当前点的左侧最长链条数不发生变化)
- 链$[u,v]$中所有的边都是必经边。

上述过程显然是一个线性过程，复杂度是$O(n)$

```cpp
# include <cstdio>
# include <iostream>
# include <cstring>
# define int long long
using namespace std;
const int N=2e5+10;
struct rec{ int pre,to,w;}a[N<<1];
int n,tot;
int d[N],head[N],tim[N],f[N],path[N],pre[N];
void adde(int u,int v,int w)
{
	a[++tot].pre=head[u];
	a[tot].to=v;
	a[tot].w=w;
	head[u]=tot;
}
void dfs1(int u,int fa,int L)
{
	d[u]=L;
	for (int i=head[u];i;i=a[i].pre) {
		int v=a[i].to; if (v==fa) continue;
		dfs1(v,u,L+a[i].w);
	}
}
void dfs2(int u,int fa,int L)
{
	d[u]=L;
	for (int i=head[u];i;i=a[i].pre) {
		int v=a[i].to; if (v==fa) continue;
		pre[v]=u; dfs2(v,u,L+a[i].w);
	}
}
void dfs3(int u,int fa)
{
	int cnt=0,mx=0; bool leaf=1;
	for (int i=head[u];i;i=a[i].pre) {
		int v=a[i].to; if (v==fa) continue; leaf=0;
		dfs3(v,u);
		if (f[v]+a[i].w>mx) mx=f[v]+a[i].w,cnt=tim[v];
		else if (f[v]+a[i].w==mx) cnt+=tim[v];
	}
	if (leaf) f[u]=0,tim[u]=1;
	else f[u]=mx,tim[u]=cnt;
}
signed main()
{
	scanf("%lld",&n);
	for (int i=1;i<n;i++) {
		int u,v,w; scanf("%lld%lld%lld",&u,&v,&w);
		adde(u,v,w); adde(v,u,w);
	}
	memset(d,0,sizeof(d));
	dfs1(1,0,0); int s=0;
	for (int i=1;i<=n;i++) if (d[i]>d[s]) s=i;
	memset(d,0,sizeof(d));
	dfs2(s,0,0); int t=0; pre[s]=-1;
	for (int i=1;i<=n;i++) if (d[i]>d[t]) t=i;
	printf("%lld\n",d[t]);
	int u=t,v; while (pre[u]!=-1) path[++path[0]]=u,u=pre[u]; path[++path[0]]=u;
	for (int i=1;i<=path[0]/2;i++) swap(path[i],path[path[0]-i+1]);
	memset(f,0,sizeof(f)); memset(tim,0,sizeof(tim)); dfs3(s,0);
	v=path[0];
	for (int i=path[0]-1;i>=1;i--)
	 if (tim[path[i]]-tim[path[i+1]]>0) v=i;
	memset(f,0,sizeof(f)); memset(tim,0,sizeof(tim)); dfs3(t,0);
	u=1;
	for (int i=2;i<=path[0];i++)
	 if (tim[path[i]]-tim[path[i-1]]>0) u=i;
	printf("%lld\n",v-u);
 	return 0;
}
```

---

## 作者：pengyule (赞：7)

树的遍历、树的直径、LCA。

> 求一无根树所有直径的必经边条数。

发现所有直径呈这样的特性：

![图片.png](https://i.loli.net/2021/02/26/v7BMToC8y2qf4mE.png)

必经边指**所有**直径的公共边，相齐指从必经边尾端到每个“细枝末节”的长度相等。之所以这样（相齐），是因为：假如不相齐，直径就“会变长”，与当前“有这么多条直径成这样的状态”矛盾！

于是现在我们要做的事情就是寻找必经边的俩端点。

发现必经边两头那两块儿形成俩子树结构，于是我们容易想到对每一边的细枝末节求公共的 LCA，上头的答案就得到必经边的上端点，下头得到另一个端点，从树的直径的节点序列中找到这一段，将它包含的节点个数减一得到边数然后输出答案。

值得注意的是这俩子树根咋找，也就是 LCA 的深度是基于哪个点作为根的。

假如此直径（我们任找的一条）的一端属于上头那块儿，就以此直径另一端为根求上头子树的 LCA；反之同理。你会发现指定其他节点为根求 LCA 并不能正确地找到必经边端点。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
int dep[N],fa[N][20];
map<int,int> e[N];
vector<pair<int,int> > G[N];
vector<int> route,s;
inline void dfs(int x,int p){//普通dfs，处理出深度、2^k辈父节点
    dep[x]=dep[p]+1; fa[x][0]=p;
    for(int i=1;i<=19;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int i=0;i<G[x].size();i++){
        int y=G[x][i].first;
        if(y^p) dfs(y,x);
    }
}
inline void findfur(int x,int fa,int sum,int &v,int &len){ //找距一点最远的点为v，该距离为len
    if(len<sum) len=sum,v=x;
    for(int i=0;i<G[x].size();i++){
        int y=G[x][i].first;
        if(y^fa) findfur(y,x,sum+G[x][i].second,v,len);
    }
}
bool notice;
inline void ggdfs(int x,int fa,int target){ //x到target的路径为route
    route.push_back(x);
    if(target==x) {notice=1;return;}
    for(int i=0;i<G[x].size();i++){
        int y=G[x][i].first;
        if(y^fa) ggdfs(y,x,target);
        if(notice) return;
    }
    route.pop_back();
}
inline int getdia(){ //返回直径，同时内部求出直径节点序列route
    int u1,l1=0; findfur(1,0,0,u1,l1);
    int u2,l2=0; findfur(u1,0,0,u2,l2);
    ggdfs(u1,0,u2); //从u1到u2的节点路径储存到route中
    return l2;
}
inline void stcdfs(int x,int fa,int sum,int tl){ //从一点出发找所有长为tl的路径的另一端
    if(tl==sum) s.push_back(x);
    for(int i=0;i<G[x].size();i++){
        int y=G[x][i].first;
        if(y^fa) stcdfs(y,x,sum+G[x][i].second,tl);
    }
}
inline int lca(int u,int v){ 
    if(dep[u]>dep[v]) swap(u,v);
    for(int i=19;i>=0;i--) if(dep[fa[v][i]]>=dep[u]) v=fa[v][i];
    if(u==v) return u;
    for(int i=19;i>=0;i--) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
    return fa[u][0];
}
inline int findall(int st,int d){ //找一头的细枝末节的公共LCA
    s.clear();
    stcdfs(st,0,0,d);
    int l=s[0];
    for(int i=1;i<s.size();i++) l=lca(l,s[i]);
    return l;
}
signed main()
{
    ios::sync_with_stdio(false);
    int n;
    cin>>n;
    for(int i=1;i<=n-1;i++){
        int u,v,w;
        cin>>u>>v>>w;
        G[u].push_back(make_pair(v,w));
        G[v].push_back(make_pair(u,w));
        e[u][v]=e[v][u]=1;
    }
    int d=getdia();
    dfs(route[0],0);int beg=findall(route[0],d);
    dfs(route.back(),0);int end=findall(route.back(),d);
    int flag=0,ans=0;
    for(int i=0;i<route.size();i++){
        if(end==route[i]) flag=1;
        ans+=flag;
        if(route[i]==beg) flag=0;
    }
    cout<<d<<endl<<ans-1<<endl;
    return 0;
}
```

---

## 作者：一念佛_万念魔 (赞：4)

# 神题！！！

考场代码0分；

~~加输出直径0分；~~

加$long$ $long$0分；

~~去$freopen$100分~~


------------
### 一道~~简单的~~树上直径问题。

不禁让我想到了[	 P2726 [SHOI2005]树的双中心](https://www.luogu.com.cn/problem/P2726)
的鬼畜思想，有兴趣的可以一肝；


## 题意简化
在一个树中求所有的直径都经过的边的边数（~~言简意赅~~）

------------

首先，要明白，题目要求的边（们）是连在一起的（画图易证）；其次，都在已知的一条直径上；

### 于是有了一个奇妙的思想：去掉某条边后，要是分裂的两颗树中较长的直径小于原直径，说明这条边是所求之边。在直径上遍历上下两次找到第一个（直径等于原直径的所断裂的树）即为题目所要求的边（们）的左右端点，记录答案即可。QWQ

又到了$CODING$...时刻

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
const int maxn=221880;
int head[maxn<<1],tmp=0,n;
int ph[maxn],pre[maxn],vis[maxn],maid;
ll ma,maxzhi[maxn],dis[maxn],kkk;
struct cjc{
	int to,next;
	ll val;
}e[maxn<<1];
void adda(int u,int v,ll y){
	e[++tmp]=(cjc){v,head[u],y};head[u]=tmp;
}
void dfs(int u,int fa){
	if(dis[u]>ma)ma=dis[u],maid=u;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(v==fa)continue; 
		pre[v]=u;
		dis[v]=dis[u]+e[i].val;
		dfs(v,u);
		maxzhi[u]=max(maxzhi[u],maxzhi[v]+e[i].val);
	}
}
ll dfs1(int u){
	while(u){
		ll maj=0;
		ma=0;
		for(ll i=head[u];i;i=e[i].next){
			ll v=e[i].to;
			if(v==pre[u])continue;
			if(maxzhi[e[i].to]+e[i].val>maj)maj=maxzhi[e[i].to]+e[i].val;
			if(maj>ma)swap(ma,maj);
		}
		if(kkk==ma+maj)return u;
		u=pre[u];
	}
	return 0;
}
int main(){
	scanf("%d",&n);
	for(int i=1,a,b;i<n;i++){
		ll c;
		scanf("%d%d%lld",&a,&b,&c);
		adda(a,b,c);adda(b,a,c);
	}
	dfs(1,0);
	int l=maid;
	dis[l]=ma=0;
	pre[l]=0;
	memset(maxzhi,0,sizeof(maxzhi));
	dfs(l,0);
	int r=maid;
	kkk=ma;
	int p=r;
	while(p)vis[p]=1,p=pre[p];
	int you=dfs1(r);
	pre[r]=0;
	memset(maxzhi,0,sizeof(maxzhi));
	dfs(r,0);
	int zuo=dfs1(l);
	int ans=0;
	while(you!=zuo){
		you=pre[you];
		ans++;
	}
	cout<<kkk<<endl<<ans;
	return 0;
}
```

### 结尾散花。。。。。













---

## 作者：crh1272336175 (赞：1)

# 树的直径
本题思路不难想。第一问就是树的直径的模板，此处不再赘述。重点看第二问。

第二问要求的是被所有直径覆盖的边的条数。首先自然要求出任意一条直径，并把该直径上的点用vector存储下来(代码中用的是p)，然后从每个直径上的点开始dfs，求出在不经过直径上其他点的条件下，该点能够到达的树上最远距离，记录在dis数组中。

接下去考虑一个L数组和R数组，分别表示到st点和ed点的距离。如果某个点的dis值和L值相等，说明该点到直径起点的距离和该点能够到达的树上最远距离相等，说明该点左侧不可能再存在“直径边”。把这个点记为j。

同理，若某个点的dis值和R值相等，说明该点到直径终点的距离和该点能够到达的树上最远距离相等，说明该点右侧不可能再存在“直径边”。把这个点记为k

那么j和k之间的边的条数即为第二问的答案。这个可以用LCA中的dep数组得到

AC代码：
```cpp
#include<bits/stdc++.h>
#pragma GCC opitimize(2)
using namespace std;
typedef long long ll;
typedef pair<ll,ll> PLL;
const int N=2e5+5,M=2e5+5,t=18; 
namespace Read
{
	inline ll read()
	{
		ll s=0,f=1; char ch=getchar();
		while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
		while(isdigit(ch)) s=s*10+(ch^48),ch=getchar();
		return s*f;
	}
	inline void write(ll x)
	{
		if(x<0) putchar('-'),x=-x;
		if(x>9) write(x/10);
		putchar(x%10+'0');
	}
}using namespace Read;
namespace Gragh
{
	ll n,m,tot=0;
	ll head[N],Next[M<<1],des[M<<1],len[M<<1];
	inline void add(ll a,ll b,ll c)
	{
		Next[++tot]=head[a]; des[tot]=b; len[tot]=c;
		head[a]=tot;
	}
}using namespace Gragh;
namespace Diameter
{
	ll st,ed;
	ll v[N],dist[N],pre[N];
	vector<ll> p;
	void bfs(ll x)
	{	
    	memset(v,0,sizeof v);
    	memset(dist,0,sizeof dist);
    	memset(pre,0,sizeof pre);
    	queue<ll> q;
    	q.push(x);  v[x]=1;
   	 	while(!q.empty())
    	{
    		ll x=q.front(); q.pop();
    		for(ll i=head[x]; i; i=Next[i])
    		{
    			ll y=des[i],z=len[i];
    			if(v[y]) continue;
    			q.push(y); v[y]=1;
    			dist[y]=dist[x]+z;
    			pre[y]=x;
			}
		}
	}
	inline void diameter()
	{
		bfs(1);
		st=1;
		for(ll i=2; i<=n; i++)
		    if(dist[i]>dist[st]) st=i;
		bfs(st);
		ed=st;
		for(ll i=1; i<=n; i++)
		    if(dist[i]>dist[ed]) ed=i;
	}
	inline void get_path()
	{
		memset(v,0,sizeof v);
		ll t=ed;
		while(t){v[t]=1; p.push_back(t); t=pre[t];}
	}
}using namespace Diameter;
namespace LCA
{
    ll dep[N],f[N][20],Dist[N];
	inline void Bfs(ll s)
	{
		memset(dep,0,sizeof dep);
		memset(f,0,sizeof f);
		memset(Dist,0,sizeof Dist);
		queue<ll> q;
		q.push(s); dep[s]=1;
		while(!q.empty())
		{
			ll x=q.front(); q.pop();
			for(ll i=head[x]; i; i=Next[i])
			{
				ll y=des[i],z=len[i];
				if(dep[y]) continue;
				dep[y]=dep[x]+1;
				f[y][0]=x;
				Dist[y]=Dist[x]+z;//dist可以用于计算树上两点间距离 
				for(ll j=1; j<=t; j++)
				    f[y][j]=f[f[y][j-1]][j-1];
				q.push(y); 
			} 
		}
	} 
	inline ll lca(ll x,ll y)
	{
		if(dep[x]>dep[y]) swap(x,y);
		for(ll i=t; i>=0; i--) if(dep[f[y][i]]>=dep[x]) y=f[y][i];
		if(x==y) return x;
		for(ll i=t; i>=0; i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
		return f[x][0]; 
	}
}using namespace LCA;
namespace Ans
{
	ll j,k;
	ll dis[N],L[N],R[N];
	void dfs(ll x,ll pre)
	{
		for(ll i=head[x]; i; i=Next[i])
		{
			ll y=des[i],z=len[i];
			if(y==pre || v[y]) continue;
			dfs(y,x);
			dis[x]=max(dis[x],dis[y]+z);
		}
	}	
	inline void get_LR()
	{
		Bfs(st);
		for(ll i=1; i<=n; i++)
		    if(i!=st) L[i]=Dist[i];
		Bfs(ed); 
		for(ll i=1; i<=n; i++)
		    if(i!=ed) R[i]=Dist[i];
	}
	inline void get_jk()
	{
		vector<PLL> t1,t2;
		for(ll i=1; i<=n; i++)
		    if(R[i]==dis[i]) t1.push_back({dis[i],i});
		sort(t1.begin(),t1.end());
		j=t1.back().second;
		
		for(ll i=1; i<=n; i++)
		    if(L[i]==dis[i]) t2.push_back({dis[i],i});
		sort(t2.begin(),t2.end());
	 	k=t2.back().second;
	} 
}using namespace Ans;
int main()
{
	n=read();
	for(ll i=1; i<n; i++)
	{
		ll a=read(),b=read(),c=read();
		add(a,b,c); add(b,a,c);
	}
	diameter();
	write(dist[ed]),puts("");
	get_path();
	for(ll i=0; i<p.size(); i++) dfs(p[i],0);
	get_LR();//计算L数组和R数组 
	get_jk();//得到j和k两个点 
	ll ans=dep[k]+dep[j]-2*dep[lca(k,j)];//j和k之间边的条数 
	write(ans);   
	return 0;
}
```


---

## 作者：Object_ (赞：1)

**基本思路：**

- 题目要求树直径的必经边，那么首先应当获取一条直径.
- 获取直径后从直径上的两个端点分别遍历一次直径，每次遍历直径时从直径上的每个点分别dfs一次并不经过直径上的点，如果深度可以被替换则说明非必经边.



------------
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>
#define ll long long
using namespace std;
const int MAXN=2e5+10,MAXM=MAXN*2;
struct Edge{
    ll from,to,w,nxt;
}e[MAXM];
int head[MAXN],edgeCnt=1;
void addEdge(ll u,ll v,ll w){
    e[++edgeCnt].from=u;
    e[edgeCnt].to=v;
    e[edgeCnt].w=w;
    e[edgeCnt].nxt=head[u];
    head[u]=edgeCnt;
}
ll dep[MAXN];
bool vis[MAXN];
int n;
int from[MAXN];
bool inDiameter[MAXN];//是否在直径上
ll st,ed;//直径端点
void markDiameter(){//标记直径
    int tmp=ed;
    while(tmp){
        inDiameter[tmp]=1;
        tmp=from[tmp];
    }
}
ll bfs(int s){//求直径
    memset(dep,0,sizeof(dep));
    memset(vis,0,sizeof(vis));
    memset(from,0,sizeof(from));
    queue<int> q;
    q.push(s);
    vis[s]=1;
    while(!q.empty()){
        int nowU=q.front();
        q.pop();
        for(int i=head[nowU];i;i=e[i].nxt){
            int nowV=e[i].to;
            if(!vis[nowV]){
                dep[nowV]=dep[nowU]+e[i].w;
                vis[nowV]=1;
                from[nowV]=nowU;
                q.push(nowV);
            }
        }
    }
    ll ans=0,ansDep=0;
    for(int i=1;i<=n;i++){
        if(dep[i]>ansDep){
            ans=i,ansDep=dep[i];
        }
    }
    return ans;
}
ll dis_fromST[MAXN];//每个点到直径st端点的距离
bool vis_getDisFromST[MAXN];
void bfs_getDisFromST(){
    queue<int> q;
    q.push(st);
    vis_getDisFromST[st]=1;
    while(!q.empty()){
        int nowU=q.front();
        q.pop();
        for(int i=head[nowU];i;i=e[i].nxt){
            int nowV=e[i].to;
            if(!vis_getDisFromST[nowV]){
                vis_getDisFromST[nowV]=1;
                dis_fromST[nowV]=dis_fromST[nowU]+e[i].w;
                q.push(nowV);
            }
        }
    }
}
ll dis_fromED[MAXN];//每个点到直径ed端点的距离
bool vis_getDisFromED[MAXN];
void bfs_getDisFromED(){
    queue<int> q;
    q.push(ed);
    vis_getDisFromED[ed]=1;
    while(!q.empty()){
        int nowU=q.front();
        q.pop();
        for(int i=head[nowU];i;i=e[i].nxt){
            int nowV=e[i].to;
            if(!vis_getDisFromED[nowV]){
                vis_getDisFromED[nowV]=1;
                dis_fromED[nowV]=dis_fromED[nowU]+e[i].w;
                q.push(nowV);
            }
        }
    }
}
ll dep_noDiameter[MAXN];//不经过直径的最大深度
ll dfs_noDiameter(int x,int fa){
    ll maxDep=dep_noDiameter[x];
    for(int i=head[x];i;i=e[i].nxt){
        int nowV=e[i].to;
        if(nowV==fa||inDiameter[nowV])continue;
        dep_noDiameter[nowV]=dep_noDiameter[x]+e[i].w;
        ll tmp=dfs_noDiameter(nowV,x);
        maxDep=max(maxDep,tmp);
    }
    return maxDep;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n-1;i++){
        ll a,b,c;
        cin>>a>>b>>c;
        addEdge(a,b,c);
        addEdge(b,a,c);
    }
    st=bfs(1);
    ed=bfs(st);//直径
    cout<<dep[ed]<<endl;
    markDiameter();//标记直径上点
    bfs_getDisFromST();
    bfs_getDisFromED();//获取每个点到两个端点的距离
    int l=st,r=ed;//必经边端点
    int tmp=from[ed];
    while(tmp){//r
        if(tmp==st)break;
        dep_noDiameter[tmp]=0;
        ll nowMaxDep=dfs_noDiameter(tmp,0);
        if(nowMaxDep==dis_fromED[tmp]){
            r=tmp;
        }
        tmp=from[tmp];
    }
    bfs(ed);//重新获取from数组
    tmp=from[st];
    while(tmp){//l
        if(tmp==ed||tmp==r)break;
        ll nowMaxDep=dfs_noDiameter(tmp,0);
        if(nowMaxDep==dis_fromST[tmp])l=tmp;
        tmp=from[tmp];
    }
    int cnt=0;
    tmp=l;
    while(tmp){
        if(tmp==r)break;
        cnt++;
        tmp=from[tmp];
    }
    printf("%d\n",cnt);
    return 0;
}
```


---

## 作者：59percent (赞：1)

```cpp
/*
直径： 正权求法两次dfs：
1. 任意选一个点做为根，找最长的一个点p1
2. 用p1做根，找最长一个点q,  p1->q就是一条直径

2.1 p1做根，找出所有最长的点qi，
2.2 p1 -> qi都是直径，找出p1->qi的公共LCA,  lcaq
2.3 任意选一个q1，找出所有最长的点pi
            lcap    lcaq
    p1 ---- Y-----X-----> q1
    p2  ----|     |____> q2
                 |-- q3

3. dep[lcaq] - dep[lcap] -> 边的数目
*/    
```
# 朴素算法
```cpp
#include <iostream>
#include <vector>

#define N 200005

using namespace std;

typedef long long ll;

struct Edge {
    int y, w;
};

vector<Edge> g[N];
int n, fa[N], dep[N];
ll len[N], mx = 0;
int p[N], last;

void getMaxs() {
    last = 0;
    mx = 0;
    for (int i = 1; i <= n; i++)
        mx = max(mx, len[i]);

    for (int i = 1; i <= n; i++)
        if (len[i] == mx)
            p[++last] = i;
}

void dfs(int x, int _fa, int _dep, ll _len) {
    fa[x] = _fa;
    dep[x] = _dep;
    len[x] = _len;
    for (int i = 0; i < g[x].size(); i++) {
        int y = g[x][i].y, w = g[x][i].w;
        if (y == _fa) continue;
        dfs(y, x, _dep + 1, _len + w);
    }
}

int lca(int x, int y) {
    if (dep[x] < dep[y]) swap(x, y);
    while (dep[x] > dep[y])
        x = fa[x];
    while (x != y) {
        x = fa[x];
        y = fa[y];
    }
    return x;
}

int getCommonLca() {
    int x = p[1];
    for (int i = 2; i <= last; i++)
        x = lca(x, p[i]);
    return x;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n - 1; i++) {
        int x, y, w;
        cin >> x >> y >> w;
        Edge e1 = {y, w};
        g[x].push_back(e1);
        Edge e2 = {x, w};
        g[y].push_back(e2);
    }
    dfs(1, 0, 1, 0);
    getMaxs();
    dfs(p[1], 0, 1, 0);
    getMaxs();
    int lca_u = getCommonLca();
    dfs(p[1], 0, 1, 0);
    getMaxs();
    int lca_v = getCommonLca();
    cout << mx << endl;
    cout << (dep[lca_v] - dep[lca_u]) << endl;
    return 0;
}

```
![](https://cdn.luogu.com.cn/upload/pic/66165.png)
# 正解
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
typedef long long ll;
struct Edge {
  int y, w;
};
const int N=200005;
int n,dep[N],fa[N], lgn, st[N][18];
ll dis[N], mx;
int p[N], last;
vector<Edge> g[N];

void calcMaxs() {
  last = 0, mx=0;
  for(int i=1; i<=n; i++)
    mx = max(mx, dis[i]);
  for(int i=1; i<=n; i++)
    if(dis[i]==mx)
      p[++last] = i;
}

void dfs(int x, int _fa, int _dep, ll _dis) {
  fa[x] = _fa;
  dep[x] = _dep;
  dis[x] = _dis;
  st[x][0] = _fa;
  for(int i=0; i<g[x].size(); i++) {
    int y = g[x][i].y, w=g[x][i].w;
    if(y == _fa) continue;
    dfs(y, x, _dep+1, _dis+w);
  }
}

void initSt() {
  for(int j=1; j<=lgn; j++)
    for(int i=1; i<=n; i++)
      st[i][j] = st[st[i][j-1]][j-1];
}

int lca(int x, int y) {
  if(dep[x]<dep[y]) swap(x, y);
  /*while(dep[x]>dep[y])
    x = fa[x];
  while(x!=y) {
    x = fa[x];
    y = fa[y];
  }*/
  int d = dep[x] - dep[y];
	for(int i=0; i<=lgn; i++)
	  if((d>>i)&1)
		  x = st[x][i];

  if(x==y) return x;

  for(int i=lgn; i>=0; i--) {
    if(st[x][i]==st[y][i]) continue;
    x = st[x][i];
    y = st[y][i];
  }
  return st[x][0];
}

int commonLca() {
  int cl = p[1];
  for(int i=2; i<=last; i++)
    cl = lca(cl, p[i]);
  return cl;
}

int main() {
  cin>>n;
  lgn = log2(n);
  for(int i=1; i<=n-1; i++) {
    int x, y, w;
    cin>>x>>y>>w;
    g[x].push_back((Edge){y, w});
    g[y].push_back((Edge){x, w});
  }
  //第一个端点u
  dfs(1, 0, 1, 0);
  calcMaxs();
  int u = p[1];
  
  //第二个端点v
  dfs(u, 0, 1, 0);
  calcMaxs();
  int v = p[1];
  //u为根的时候，p[i]的公共lca
  initSt();
  int lca_u = commonLca();

  //v为根的时候，p[i]的公共lca
  dfs(v, 0, 1, 0);
  calcMaxs();
  initSt();
  int lca_v = commonLca();
  
  //求公共边的数目, dep[lca_v]-dep[lca_u]
  cout<<mx<<endl;
  cout<<dep[lca_v]-dep[lca_u]<<endl;
  
  return 0;
}


```


---

## 作者：Zekrom (赞：0)

直径必经边  

说说主要思路：   
首先必经边一定在一条直径上，枚举每一条点（记录前驱），dfs求出该点到非直径上的最长路（树的最长路一遍dfs即可，不用多此一举dijk），如果最长路到直径两端点的距离相同，我们意识到，这条最长路也是直径的一个选择，对于直径的起点和终点，如果都有这样一个断点，两个断点在直径上的距离就为必经边长度    

注意：  
枚举每一个点dfs求最长路时，在dfs过程中求出最长路的值，避免d数组的重新赋值和循环求出最长路，否则时间复杂度将上升到O（n^2）~~，第一次没注意就这样T了~~   
上代码  ：  
```cpp
#include<iostream>
#include<cstdio>
#define N 200010
#include<queue>
#include<cmath>
#include<cstring> 
using namespace std;
int n,pos[N][2],head[N],route[N],num,tot,ans,s,e;
long long ls[N],re[N],d[N],dis[N] ,len,sum;
bool vis[N],v[N];
struct Edge{
	int v,next,val;
}edge[N*2]; 
inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();};while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();return x*f;}
inline void add(int x,int y,int z){edge[++tot].v=y;edge[tot].next=head[x];edge[tot].val=z;head[x]=tot;}
int bfs(int s){
	queue<int>q;q.push(s);memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++)d[i]=0;memset(pos,0,sizeof(pos));long long maxn=0;
	int maxi;
	while(q.size()){
		int u=q.front();q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].v,z=edge[i].val;
			if(vis[v])continue;
			d[v]=d[u]+z;
			q.push(v);
			pos[v][0]=u,pos[v][1]=z;
			if(d[v]>maxn)maxn=d[v],maxi=v; 
		}
	}
	len=maxn;
	return maxi;   //被机房称为毒瘤bfs写法求直径（他们都dfs6行orz）
}
void dfs(int s,int fa,int x){
	if(!head[s])return ;
	for(int i=head[s];i;i=edge[i].next){
		int to=edge[i].v,z=edge[i].val;
		if(to==fa||v[to])continue;
		d[to]=d[s]+z;
		dis[x]=max(dis[x],d[to]);  //dfs过程中求出dis
		dfs(to,s,x);
	}
}
int main(){
	n=read();
	for(int i=1;i<=n-1;i++){int x=read(),y=read(),z=read();add(x,y,z);add(y,x,z);}
	s=bfs(1);
	e=bfs(s);
	int t=e;
	route[++num]=e;
	v[e]=1;
	while(t!=s){//标记路径
		re[pos[t][0]]=re[t]+pos[t][1];    //在标记路径时求出直径上点到终点e距离，到起点s距离为直径长len-re[x]
		t=pos[t][0];
		route[++num]=t;
		v[t]=1;
	}
	for(int i=1;i<=num;i++){
		int x=route[i];
		d[x]=0;
		dfs(x,0,x);    //求出dis最长路
	}
	int tr=1;
	for(tr=1;tr<=num;tr++){
		int x=route[tr];
		if(dis[x]==len-re[x])break;  //如果到s距离为最长路,断点1set
	}
	int tl=num;
	for(tl=num;tl>=1;tl--){
		int x=route[tl];
		if(dis[x]==re[x])break;//同理断点2
	} 
	ans=abs(tr-tl);//这就是必经边数
	printf("%lld\n",len);
	printf("%d",ans);
	return 0;
}

```


---

## 作者：dfkdsmbd (赞：0)

这是由一次题解都没有过审核的菜鸡为您带来的题解qwq
这个题我做的时候没有看题解，也没有想到所有直径交于一些连续的边这种事情，其实也很好想，但我的思路并不在这上面。
首先第一问可以dfs/bfs/dp，这个无所谓，但是要注意记得求出一种直径方案，便于我们处理第二问
我们首先分析，如果一个边一定在直径上的话，那么很显然，我去掉这个边之后，所分成的两棵子树，它们的直径一定小于原树的直径，不然这个边就不一定在直径上了，有可能会存在别的直径方案不覆盖这条边。
那么问题可以转化成求去掉某种直径的某一条边后，新形成的两棵子树的直径，这个东西如果暴力枚举去掉哪条边的话，很显然坠坏的时间复杂度是n^2的。然后我们想这个地方有没有重复的，可以优化的部分。回想一下树形dp求树的直径的过程，我们求一棵树的直径的时候，它的所有子树一定都是处理好的。那么很显然我们如果断开一条边的时候，有直径起点的那一部分子树，很显然可以通过以直径终点为根跑树形dp来处理看，反之亦然。
这样我们就轻松去掉了一个n，总的时间复杂度变为了O(n)。当然两边bfs+两边dfs会使得常数比较大，但是总的来说还是很轻松的就能过的。
如果有写的不好的地方请多指教qwq。
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<queue>
#define ri register int

using namespace std;

inline char gch()
{
    static char buf[100010], *h = buf, *t = buf;
    return h == t && (t = (h = buf) + fread(buf, 1, 100000, stdin), h == t) ? EOF : *h ++;
}

typedef long long lo;

inline void re(int &x)
{
    x = 0;
    char a; bool b = 0;
    while(!isdigit(a = gch()))
        b = a == '-';
    while(isdigit(a))
        x = (x << 1) + (x << 3) + a - '0', a = gch();
    if(b == 1)
        x *= -1;
}

int n, s, t, he, ta, tot = -1, pos, q[200020], head[200020], pre[200020], lx, ly, lz; 

struct in
{
    int to, ne; lo co;
}ter[400040];

inline void build(int f, int l, lo c)
{
    ter[++ tot] = (in){l, head[f], c}, head[f] = tot;
    ter[++ tot] = (in){f, head[l], c}, head[l] = tot;
}

lo ans, sx[200020], tx[200020], sy[200020], ty[200020], de[200020];//x 联通块直径 y最深深度 

inline void bfs(int x)
{
    memset(de, 0, sizeof(de)), memset(pre, 0, sizeof(pre));
    de[q[he = ta = 0] = x] = 1, pos = 0;
    while(he <= ta)
    {
        int qaq = q[he ++]; pos = (de[pos] < de[qaq]) ? qaq : pos;//更新最深的点 
        for(ri i = head[qaq]; i >= 0; i = ter[i].ne)
        {
            int to = ter[i].to;
            if(de[to] == 0)
                pre[to] = qaq, de[q[++ ta] = to] = de[qaq] + ter[i].co;
        }
    }
}

void dfs(lo *a, lo *b, int no, int fa)
{
    lo lx = 0, ly = 0;
    for(ri i = head[no]; i >= 0; i = ter[i].ne)
    {
        int to = ter[i].to;
        if(to == fa)
            continue;
        dfs(a, b, to, no);
        b[no] = (b[no] < b[to] + ter[i].co) ? b[to] + ter[i].co : b[no];
        if(lx < b[to] + ter[i].co)
            ly = lx, lx = b[to] + ter[i].co;
        else if(ly < b[to] + ter[i].co)
            ly = b[to] + ter[i].co; 
        a[no] = (a[no] < a[to]) ? a[to] : a[no];//维护子树内部的直径 
    } 
    a[no] = (lx + ly < a[no]) ? a[no] : lx + ly;
}

int main()
{
    re(n); memset(head, -1, sizeof(head)); s = t = 0;
    memset(sx, 0, sizeof(sx)), memset(sy, 0, sizeof(sy));
    memset(tx, 0, sizeof(tx)), memset(ty, 0, sizeof(ty));
    for(ri i = 1; i < n; i ++)
        re(lx), re(ly), re(lz), build(lx, ly, lz);
    bfs(1), s = pos, bfs(s), t = pos;//两边bfs确定任意一条直径 
    dfs(sx, sy, s, 0), dfs(tx, ty, t, 0);//分别以起点和终点为根再去处理子树的信息 
    for(ri i = t; i != s; i = pre[i])
    	if(tx[pre[i]] < sx[s] && sx[i] < sx[s])//如果删除这条边之后，两个子树内的直径都小于原树直径 
           ans ++;//说明这个边一定被所有直径经过 
    printf("%lld\n%lld", sx[s], ans);
}
```

---


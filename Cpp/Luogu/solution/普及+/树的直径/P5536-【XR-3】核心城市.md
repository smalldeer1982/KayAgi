# 【XR-3】核心城市

## 题目描述

X 国有 $n$ 座城市，$n - 1$ 条长度为 $1$ 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。

X 国国王决定将 $k$ 座城市钦定为 X 国的核心城市，这 $k$ 座城市需满足以下两个条件：

1. 这 $k$ 座城市可以通过道路，在不经过其他城市的情况下两两相互到达。
2. 定义某个非核心城市与这 $k$ 座核心城市的距离为，这座城市与 $k$ 座核心城市的距离的最小值。那么所有非核心城市中，与核心城市的距离最大的城市，其与核心城市的距离最小。你需要求出这个最小值。

## 说明/提示

【样例说明】

钦定 $1,2,5$ 这 $3$ 座城市为核心城市，这样 $3,4,6$ 另外 $3$ 座非核心城市与核心城市的距离均为 $1$，因此答案为 $1$。

## 样例 #1

### 输入

```
6 3
1 2
2 3
2 4
1 5
5 6
```

### 输出

```
1
```

# 题解

## 作者：SCAU_Lnn (赞：337)

# 这道题看得晕？大佬们的题解看不懂？
# 快看过来~

## 看完这篇题解你可以获得什么？
#### 1.树上直径求法的详细易懂的证明。
#### 2.一篇启发式的题解帮助你思考。

#### 一.题意

首先看明白这道题的题意，在一棵树上取k个点作为核心城市（群），其他点到核心城市的距离为他们到这些城市的最短距离si。这些最短距离中有一个最大距离，你可以把这个最大距离作为这个核心城市群的参考值ans，要你求所有不同核心城市(群)中ans最小的。（是真的很绕，好好理解一下吧）

#### 二.思路

看懂题目后，我们会发现逻辑有点复杂，首先不知道k个城市要取在哪里，其次又不知道参考值ans怎么求。~~这个时候我们就可以放弃这道题了~~

没关系，一步一步来。某大佬曾经说过，**遇到复杂的题，先尝试把它变得简单些。**
比如说，有k个城市需要考虑，是不是很烦？那么我们先化简一下，只考虑一个城市，那么这个城市会在哪里呢？为什么？（**可以先适当的思考一下再继续看题解**）

取一个点，要求其他所有的点到这个点的最大距离最小，那我们就要考虑什么时候出现这个最大距离。**任取一个点a，它的最远端点是直径的端点**，那么最大距离也就是a与两直径端点的距离中的较大值d（什么？你跟我说不懂树的直径？去看下面的求法与证明吧）**那么当a作为直径的中点时**，可以保证d保持最小值。
（不懂就画图~）

好，我们已经确定一个点的时候要选直径的中点了，（**多个点的时候也要选中点，请自行思考**）那么接下来要确定其他k-1个点。没头绪？我也没有头绪，Lnn蒟蒻曾说过，没头绪就画图。

![树](https://cdn.luogu.com.cn/upload/image_hosting/5snmtcf0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

好，对于这个图，选了4以后，要选哪个点？首先这个点要与4相连，就只剩10号，5号，3号三位选手了。你可以都试试，选了10号后（非核心城市到核心城市最小距离的最大值）ans为5（4到11），选了5号之后ans为5（4到11），选3号之后ans为4（3到11或者4到12）。**选了三号之后ans变小了**，所以我们要选的点是3号。好，凭你的直觉和实际距离你继续选，你应该能发现什么。**每一次选的时候都有一种贪心的思想在里面，尽量在选完之后使得ans变小。**

经过这些思考，你应该能明白要选的点的性质了，总结一下就是按照当前点能走到的最远距离dis**降序排序**之后，在一个一个选。其中设d[i]为当前深度，maxd[i]为i能走到的最深的深度。那么dis[i]=maxd[i]-d[i]。

按照dis排序之后，前k个点是核心城市，这样子核心城市确定你要找的ans就是其他点到核心城市的距离的最小距离最大值。那么ans如何求得？比如k==3，还是按照上面那个图，**排序之后**，dis[1]=5,dis[2]=4,dis[3]=3。正确答案是4，是4到12那条路，**如果此时你从核心城市下手，会发现很难求，但是如果你换一下思路，从非核心城市下手**，只要找到非核心城市中dis最大的那个值，dis[k+1]+1就是你要的答案。

下面给出直径求法和证明。

#### 三.树的直径

求法：**任选**一点a，保存其dfs遍历到最远的一点b。b为直径的一个端点。
	  再以b点dfs到最远的一点c。**bc即为直径**。
      
证明：三种情况，见图

**1.设xy为树上直径，a为直径上一点，b为a找到的最远端点。**

![](https://cdn.luogu.com.cn/upload/image_hosting/pm3fa55l.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**既然a找到的最远端点不是x或者y**，那么ab>=ax,ab>=ay。
所以只有两种可能：1.（等于时）yb与xy同为直径，所以b为直径端点。2.（大于时）yb>xy，xy不是直径，与假设有误。

2.设xy为直径，a为直径外一点，a在延申时经过xy上一点b。

![](https://cdn.luogu.com.cn/upload/image_hosting/y3i9zbdk.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**由证明1知**，b继续延申一定会延申到x或者y（直径端点），得证。

3.设xy为直径，a延申到b端点，并且不经过xy，取ab上一点o，xy上一点c。

![](https://cdn.luogu.com.cn/upload/image_hosting/dv0jfhrr.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**既然a延申的最远点为b，那么ob>=oc+cy**，这条式子改一下，有

co+ob>cy

xc+co+ob>xc+cy

得xb>xy，xy不是直径，与假设有误。

**证明完毕，树上一点延申到最远的点是直径端点。**

主要是利用反证法证明如果延申到的端点不是直径端点的话，就与假设有误。如果还不懂的话可以参考其他大佬的。

至于代码的话可以参考其他大佬的，思路是差不多的。~~我的太差了就不拿出来了~~

#### 如果觉得我菜的话请在评论区刷Lnnnb

#### 如果对你有帮助的话请给我点赞~




---

## 作者：Cylete (赞：114)

update 2020.10.04

更新图片

————————————————————

# 树的直径板子题

~~QwQ大佬的题解我都看不懂啊~~

~~所以自己发一篇吧~~

# 树的直径

树的直径有两种方法

## 树形DP求树的直径

```
void dp(int x,int fa){//x表示当前的节点，fa是x
的父节点
	for(int i=head[x];i;i=next[i]){//前向星
		int y=ver[i],z=w[i];//y是下一个节点，z是x，y的距离，在本题就是1
		if(y==fa)continue;//只用遍历一次，不用回到父节点
		dp(y);
		ans=max(ans,dis[x]+dis[y]+z);
		dis[x]=max(dis[x],dis[y]+z);
        //dis[x]表示从节点x出发走到以x为根的子树
        //能够到的最远距离
	}
}
```
树形DP难以求出直径上的节点

~~反正我不会QwQ~~

顺便提供几道树形DP的题目

[P1352 没有上司的舞会](https://www.luogu.org/problem/P1352)

[P1273 有线电视网](https://www.luogu.org/problem/P1273)

[P2014 选课](https://www.luogu.org/problem/P2014)

## 两次DFS求树的直径

其实两次BFS也可以，这里介绍DFS的

第一次DFS我们从任意一个节点开始走

记录下离它最远的节点

它就是直径的一端了

为什么呢

#### 我们假设它不是直径一端上的点

可是这样就违背了直径的定义

直径是树的最长链

如果它不是直径一端上的节点

那么就肯定会有一条比直径更长的链

所以不成立

#### 证毕

然后用这个点再一次DFS，记录下路径就ok

```
void dfs1(int x,int fa){
	if(deep[x]>zj){
		zj=deep[x];
		num=x;
	}
	for(int i=head[x];i;i=next[i]){
		int y=ver[i];
		if(y==fa)continue;
		deep[y]=deep[x]+1;
		dfs1(y,x);
	}
}
void dfs2(int x,int fa){
	if(deep[x]>zj){
		zj=deep[x];
		num=x;
	}
	for(int i=head[x];i;i=next[i]){
		int y=ver[i];
		if(y==fa)continue;
		deep[y]=deep[x]+1;
		f[y]=x;//记录路径，表示y的父节点为x
		dfs2(y,x);
	}
}
```


然后我们来看题意

这 kk 座城市可以通过道路，在不经过其他城市的情况下**两两相互到达**

定义某个非核心城市与这k座核心城市的距离为，这座城市与k座核心城市的距离的最小值。那么所有非核心城市中，**与核心城市的距离最大的城市，其与核心城市的距离最小**。你需要求出这个最小值。

显然，k座城市的核心城市为直径中间那个城市

然后用这个城市向下搜就ok辽

用样例解释下

这是已经找了直径中点1的树

黑色是deep，表示树的深度

绿色表示maxdeep，表示这个点可以到达的最深的深度

对于节点x，离他最远的节点相距显然为maxdeep[x]-deep[x]

![](https://cdn.luogu.com.cn/upload/image_hosting/ocjummj5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然k座城市要取上面的

即maxdeep[x]-deep[x]前k大的

排序一下

那么剩下最大距离的最小值就一个一个比较就好了
```
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
#define N 100010
int n,k,zj,num,ans_k;
int cut,head[N],ver[2*N],next[2*N];
int deep[N],f[N],maxdeep[N],ans[N];
bool cmp(int a,int b){
	return a>b;
}
void add(int x,int y){
	ver[++cut]=y;next[cut]=head[x];head[x]=cut;
}
//求直径
void dfs1(int x,int fa){
	if(deep[x]>zj){
		zj=deep[x];
		num=x;
	}
	for(int i=head[x];i;i=next[i]){
		int y=ver[i];
		if(y==fa)continue;
		deep[y]=deep[x]+1;
		dfs1(y,x);
	}
}
void dfs2(int x,int fa){
	if(deep[x]>zj){
		zj=deep[x];
		num=x;
	}
	for(int i=head[x];i;i=next[i]){
		int y=ver[i];
		if(y==fa)continue;
		deep[y]=deep[x]+1;
		f[y]=x;
		dfs2(y,x);
	}
}
//
void dfs_k(int x,int fa){
	maxdeep[x]=deep[x];
	for(int i=head[x];i;i=next[i]){
		int y=ver[i];
		if(y==fa)continue;
		deep[y]=deep[x]+1;
		dfs_k(y,x);
		maxdeep[x]=max(maxdeep[x],maxdeep[y]);
	}
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<n;++i){
    	int x,y;
    	scanf("%d%d",&x,&y);
    	add(x,y);
    	add(y,x);
	}
    //直径
	dfs1(1,0);
	memset(deep,0,sizeof(deep));
	zj=0;
	dfs2(num,0);
    //
	int kkk=num;
    //找直径的中点
	for(int i=1;i<=(deep[num]+1)/2;++i)kkk=f[kkk];
	memset(deep,0,sizeof(deep));
    //再搜一次
	dfs_k(kkk,0);
	for(int i=1;i<=n;++i)ans[i]=maxdeep[i]-deep[i];
	sort(ans+1,ans+n+1,cmp);
    //QwQ结合图片不难想
	for(int i=k+1;i<=n;++i)ans_k=max(ans_k,ans[i]+1);
	printf("%d\n",ans_k);
    return 0;
}
```
再来几道树的直径的题目吧

[P1099 树网的核](https://www.luogu.org/problem/P1099)

[P3629 [APIO2010]巡逻](https://www.luogu.org/problem/P3629)

[P2195 HXY造公园](https://www.luogu.org/problem/P2195)

QwQ加一个题单吧

[一个动态更新的洛谷综合题单](https://studyingfather.blog.luogu.org/luogu-problem-list?tdsourcetag=s_pcqq_aiomsg)

---

## 作者：wheneveright (赞：67)

[P5536 【XR-3】核心城市](https://www.luogu.com.cn/problem/P5536)


## 解法

看了下好像题解都是写以直径为基础的算法，我来讲一下鄙人自己对于这道题的认识。

![](https://cdn.luogu.com.cn/upload/image_hosting/vsr4sayg.png)

如图，这是一颗满足题目要求的无根树

这时，如果 $k=2$ 那么显然 2 号城市和 4 号城市会成为核心城市，原因是此时所有非叶子节点都是非核心城市，答案为 1。

那么来看看下面这个图：
![](https://cdn.luogu.com.cn/upload/image_hosting/4m5xd9he.png)

先设它的根为 1 号节点。

让我们看看 $k=13$ 时是怎样的，很明显，所有的城市都可以成为核心城市，所以答案为0。

那当 $k=7$ 时呢（有 6 个城市被排出在外时）？

![](https://cdn.luogu.com.cn/upload/image_hosting/n3dtbz8i.png)

你可以这样，此时答案是1且最优。

![](https://cdn.luogu.com.cn/upload/image_hosting/xoysopvt.png)

你也可以这样，此时答案是1且最优。

多画几个图，不难发现，当 $5 \leq k \leq 12$ 时，答案都是1，此时所有非核心城市都有一个共同点：都是叶子节点（如下图）。
![](https://cdn.luogu.com.cn/upload/image_hosting/q8s6wtlr.png)

于是我们就可以想到由叶子节点一层层往内推统计城市个数，最后答案就是所有非核心城市的深度的最大值，这里的深度是由叶子节点为为第一层往根上推的，而根是什么根本无所谓。

用拓扑排序即可想法很像。

## 代码

```cpp
# include <bits/stdc++.h>
using namespace std;

const int maxn = 100005;
const int maxe = 200005;

struct reader {
	template <typename Type>
	reader&operator>> (Type&ret) {
		register int f = 1; ret = 0; register char ch = getchar ();
		for (;!isdigit (ch); ch = getchar ()) if (ch=='-') f=-f;
		for (; isdigit (ch); ch = getchar ()) ret = (ret << 1) + (ret << 3) + ch - '0';
		ret *= f; return *this;
	}
}fin;

int N, K, x, y, du[maxn], ans;
int lnk[maxn], nxt[maxe], son[maxe], tot;
void add_e (register int x, register int y) {
	son[++tot] = y; nxt[tot] = lnk[x];
	lnk[x] = tot; du[y]++; return;
} // 邻接表存图
int que[maxn], dep[maxn], L, R; bool vis[maxn];
//这里的变量和数组都是字面意思，初中的教练一直要求代码要可以望文生义
void topo () {
	while (L ^ R) {
		L++;
		for (register int j = lnk[que[L]]; j; j = nxt[j]) {
			if (--du[son[j]] != 1) continue
			if (vis[son[j]]) continue; vis[son[j]] = true;
			dep[son[j]] = dep[que[L]] + 1; ans = max (ans, dep[son[j]]);
			//这里随时刷新 ans 的最大值
			que[++R] = son[j]; K--; if (K < 1) return;
		}
	}
	return;
} //其他的就是普通的 topo 写法了

int main () {
	freopen("P5536.in","r",stdin);
	freopen("P5536.out","w",stdout);
	fin >> N >> K; K = N - K; // 将 K 的含义转为非核心城市的个数
	for (register int i = 2; i <= N; i++) {
		fin >> x >> y;
		add_e (x, y); add_e (y, x);
	}	L = R = 0; ans = 0; // 建图
	for (register int i = 1; i <= N; i++) if (du[i] == 1 && K >= 1)
	que[++R] = i, vis[i] = true, K--, ans = 1, dep[i] = 1;
	//这一块原本是应该放在topo函数中的，但是因为加了个特判，所有写在主函数里
	if (K) topo (); cout << ans << endl;
	return 0;
}
```

最后，安利一波[这个画图网站，真的超级好](https://csacademy.com/app/graph_editor/)！

---

## 作者：神之蒟蒻xyk (赞：31)

我发现了一种奇奇怪怪的做法

大佬们都用的是树的直径，考虑选出这k个城市

本蒟蒻做题时从反面，也就是剩下的n-k个城市出发思考

用du【i】表示与i号点相连的边数，每次取du为1的点作为n-k个城市之一，然后再从这个点出发更新与之相连的城市的du，知道取完n-k个城市

就有点类似拓补排序的样子。。（实在是太菜了没想到树的直径）

代码：

```cpp
#include<bits/stdc++.h>
#define fir(a, b, c) for(register int a = b; a <= c; a ++)
#define ll long long
using namespace std;

inline int read(){
	int x = 0; bool flag = 1; char c = getchar();
	for(; !isdigit(c); c = getchar())  if(c == '-') flag = 0;
	for(; isdigit(c); c = getchar()) x = x * 10 + c - '0';
	return flag ? x : -x;
}

queue <int> q1, q2; 
const int N = 5e5 + 10;
int n, k, head[N], ans;
struct node {
	int v, nxt;
}edge[N];

int tot = 0;
inline void add(int x, int y) {
	tot ++;
	edge[tot].v = y;
	edge[tot].nxt = head[x];
	head[x] = tot;
}

int du[N];

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n = read(); k = read();
	fir (i, 1, n) head[i] =-1;
	fir (i, 1, n-1) {
		int x, y;
		x = read(); y = read();
		add(x, y); add(y, x);
		du[x] ++; du[y] ++;
	}
	int sum = n;
	fir (i, 1, n) {
		if (du[i] == 1) {
			q1.push(i);
			du[i] --;
		}
	}
	while(sum > 0) {
		ans ++;
		while (!q1.empty()) {
			int x = q1.front();
			q1.pop();
			sum --;
			if (sum ==  k) {
				cout<<ans<<endl;
				return 0;
			}
			for (int i = head[x]; i != -1; i = edge[i].nxt) {
				int y = edge[i].v;
				du[y] --;
				if (du[y] == 1) q2.push(y);
			}
		}
		swap(q1, q2);
	}
	return 0;
}



```


---

## 作者：localhost (赞：22)

我们可以考虑放$n-k$个节点然后使深度最大的最小



一开始的时候可以反过来想：树里面长度最大的路径就是树的直径，它的两个端点的度都是$1$（也就是叶子节点）



我们可以从每个叶子结点开始，向中心包围。可以用队列的方式实现。

（代码很短）

```cpp
#include<bits/stdc++.h>
namespace ZDY{
    #pragma GCC optimize(3)
    #define il __inline__ __attribute__ ((always_inline))
    #define rg register
    #define ll long long
    #define ull unsigned long long
    #define db double
    #define sht short
    #define MB template <class T>il
    #define Fur(i,x,y) for(int i=x;i<=y;++i)
    #define Fdr(i,x,y) for(int i=x;i>=y;--i)
    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)
    #define clr(x,y) memset(x,y,sizeof(x))
    #define cpy(x,y) memcpy(x,y,sizeof(x))
    #define fin(s) freopen(s".in","r",stdin)
    #define fout(s) freopen(s".out","w",stdout)
    #define fcin ios::sync_with_stdio(false)
    #define l2(n) (int(log2(n)))
    #define inf 0x3f3f3f3f
    MB T ABS(T x){return x>0?x:-x;}
    MB T MAX(T x,T y){return x>y?x:y;}
    MB T MIN(T x,T y){return x<y?x:y;}
    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}
    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}
}using namespace ZDY;using namespace std;
namespace IO{const char* ln="\n";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;
#define N 100001
int n,cnt(0),k,head[N],q[N],c[N],d[N];
struct edge{
	int to,nxt;
}e[N*2];
il void add(int x,int y){
	e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;
}
int main(){
	fin("in");
	in>>n>>k;
	int x,y;
	Fur(i,1,n-1)
		in>>x>>y,
		add(x,y),add(y,x),c[x]++,c[y]++;
	
	int h=0,t=0,cnt=n-k;
	Fur(i,1,n)if(c[i]==1)q[t++]=i,d[i]=1;
	while(h<t){
		x=q[h++];
		if(!--cnt)return out<<d[x]<<ln,0;
		fl(i,x)if(--c[to]==1)
			d[to]=d[x]+1,q[t++]=to;
	}
}
```

---

## 作者：Catalan1906 (赞：17)

我们知道，直径是树里面最长的路径。

要想找到k个点，这k个点中必然有直径的中点。

然后我们以这个直径的中点为根，把其他节点按照`以这个节点为根的子树中节点的最大深度-这个点的深度`排序

选前$k-1$个节点，易证它们互相连通

代码较丑，勿喷qwq

```cpp
#include <bits/stdc++.h>

using namespace std;

struct edge {
	int t, nxt;
} e[200010];

struct qwqqwq {
	int a, b;
} qwqwqwq[100010];

bool cmp(qwqqwq a, qwqqwq b) {
	return a.a > b.a;
}

int head[100010], ep, dis[100010], father[100010], n, k, maxdis[100010], vis[100010], cnt, qqwq[100010];
// queue < int > q;

void add_edge(int s, int t) {
	ep++;
	e[ep].t = t;
	e[ep].nxt = head[s];
	head[s] = ep;
}

void dfs1(int now, int fa) {
	for(int i = head[now]; i; i = e[i].nxt) {
		if(e[i].t == fa) continue;
		dis[e[i].t] = dis[now] + 1;
		dfs1(e[i].t, now);
	}
}

void dfs2(int now, int fa) {
	for(int i = head[now]; i ; i = e[i].nxt) {
		if(e[i].t == fa) continue;
		father[e[i].t] = now;
		dis[e[i].t] = dis[now] + 1;
		dfs2(e[i].t, now);
	}
}

void dfs3(int now, int fa) {
	maxdis[now] = dis[now];
	for(int i = head[now]; i; i = e[i].nxt) {
		if(e[i].t == fa) continue;
		dis[e[i].t] = dis[now] + 1; 
		father[e[i].t] = now;
		dfs3(e[i].t, now);
		maxdis[now] = max(maxdis[now], maxdis[e[i].t]);
	} 
}

int main() {
	cin >> n >> k;
	for(int i = 1; i < n; i++) {
		int s, t;
		cin >> s >> t;
		add_edge(s, t);
		add_edge(t, s); 
	}
	dfs1(1, 0);
	int qwq = 0, pwp = 1;
	for(int i = 1; i <= n; i++) {
		if(dis[i] > qwq) {
			pwp = i, qwq = dis[i];
		}
	}
	memset(dis, 0, sizeof(dis));
	dfs2(pwp, 0);
	int qvq = 0; qwq = 1;
	for(int i = 1; i <= n; i++) {
		if(dis[i] > qvq) {
			qwq = i, qvq = dis[i];
		}
	}
	int pos1 = qwq;
	for(int i = 1; i <= (dis[qwq] + 1) / 2; i++) {
		pos1 = father[pos1];
	}
	memset(father, 0, sizeof(father));
	memset(dis, 0, sizeof(dis));
	dfs3(pos1, 0);
	// q.push(qwq);
	for(int i = 1; i <= n; i++) {
		qwqwqwq[i].a = maxdis[i] - dis[i];
		//cout << qwqwqwq[i].a << endl;
		qwqwqwq[i].b = i;
		qqwq[i] = qwqwqwq[i].a;
	}
	sort(qwqwqwq + 1, qwqwqwq + n + 1, cmp);
	for(int i = 1; i <= k; i++) {
		vis[qwqwqwq[i].b] = 1;
	}
	// cout << pos1 << endl;
	int ans = 0; 
	for(int i = 1; i <= n; i++) {
		if(!vis[i]) ans = max(qqwq[i] + 1, ans);
	}
	cout << ans << endl;
	return 0;
}
```

说句闲话：随机抽到的第85名有奖品，结果我这个蔡鸡第86名QAQ

---

## 作者：Y_B_Y (赞：9)

首先我们来看一下什么是树的直径,简单来说直径就是树中**最长一条路径**(不唯一)

至于求直径我这里是用@e_e_thinker大佬的方法,先从任意点搜索搜到的最远点位直径的一端,再重一段开始搜搜到的最远点即为另一端,再找完整路径就可以了

注意到最长路径,我们再看看题目要求我们**使与核心城市的距离最大的城市**，其与核心城市的**距离最小**

###### (注:下文如果出现类似一个点到多个点的距离,指一个点到多个点的距离中的最大值)

由于直径是最长的路径,我们可以先考虑解决它,那么我们首先来看那个点作为核心城市可以使直径的两端点到其的距离的较大值最小,不难知道是直径的中点(直径的中点,如果直径上有1~n号节点,**n为奇数时,中点为(n+1)/2号,为偶数时为(n/2)号**)

然后我们再来看其他点到中点的距离,由于直径的定义其他点到中点的距离一定不大于直径两端到中点的距离(因为如果大于,就一定能找到一条比直径更长的路径,如下图)

![](https://cdn.luogu.com.cn/upload/image_hosting/g5qqmxdh.png)


所以直径中点一定是核心城市(其他点到直径两端的大于直径中点),由题意得其他核心城市一定和中点相连,所以我们可以**以中点为根建一颗有根树**(代码中只是改变了搜索的起点罢了)

我们先来看题目中的一句话,定义某个非核心城市与这k座核心城市的距离为，这座城市**与k座核心城市的距离的最小值**。

###### warning:后面可能会有点绕,可以直接看结论加图食用

建树有什么用呢,一开始我们只确定了一个核心城市,就是直径的中点(根),由于核心城市都是相邻的,所以里核心城市最远的节点一定是叶子节点(可以画图看看),根据定义,且其到核心城市的**距离**一定是其**到它第一个为核心城市的祖先节点的距离**,由于树上路径长为1,所以距离也就是**它的深度减一个为核心城市的祖先节点的深度**

所以如果一个非核心城市他到它往下走到的叶子节点的距离很大,那么它一定要作为核心城市(**如果不做,那个叶子节点到其他核心城市的距离更大**)

所以得出**结论**

所以我们可以将每个非核心城市到**可以到达的最深叶子节点的深度减其自身的深度**的值$k[i]$进行排序,值大的优先成为核心城市(易证值从大到小加入核心城市他们都是相连的),然后答案就是最大非核心城市$j$的$k[j]$+1(因为$k[j]$最大,所以它一定和核心城市相连,它到其最远叶节点的距离为$k[j]$那和它相连的核心城市到也节点的距离为$k[j]+1$),如图

![](https://cdn.luogu.com.cn/upload/image_hosting/cw5u2q3j.png)


具体看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int n,k,zj[N],yd,zjs,maxn,ryd,ft[N],nx[N],to[N],gx[N];//zj[i]为直径路径上i第i点,n,k看题目,yd为一端,ryd为另一端(lyd???),ft,nx,to建图,gx[i]为上文的k[i]
int cnt;//add函数用
struct hh{int dep,mep;}d[N];
void f1(int,int,int);
void f2(int,int,int);
bool f3(int,int,int);
void add(int,int);
int fd(int x,int sd,int f)//f为防止往父亲节点重复走
{
	d[x].dep=sd;
	int b=0;bool ok=0;
	for(int i=ft[x];i;i=nx[i]) if(to[i]!=f) ok=1,b=max(b,fd(to[i],sd+1,x));//最大深度
	if(!ok) b=sd;//如果没路走(叶节点),可以走到的最大深度为自生
	d[x].mep=b;
	return b;
}
int cmp(int s1,int s2){return s1>s2;}//从大到小
inline int read()
{
    char c=getchar();int sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
int main()
{
	n=read();k=read();
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		add(x,y);add(y,x);
	}
	f1(1,1,0);//第一次搜
	maxn=0;//由于maxn是公用的,所以要清零
	f2(yd,1,0);//第二次
	maxn=0;
	f3(yd,1,0);//找直径的完整路径
	fd(zj[(zjs+1)/2],1,0);//从中点开始求可以到达的最深叶子节点的深度和其自身的深度
	for(int i=1;i<=n;i++) gx[i]=d[i].mep-d[i].dep;//求gx
	sort(gx+1,gx+n+1,cmp);//排序
	int ans=0;
	for(int i=k+1;i<=n;i++) ans=max(ans,gx[i]+1);//非核心城市里找最大值
	printf("%d\n",ans);
	return 0;
}
void f1(int x,int st,int f)
{
    bool ok=0;
	for(int i=ft[x];i;i=nx[i]) if(to[i]!=f) ok=1,f1(to[i],st+1,x);
	if(!ok) //如果没路走,判断是不是最大值
	{
		if(st>maxn) yd=x,maxn=st;
		return;
	}
	return;
}
void f2(int x,int st,int f)
{
	bool ok=0;
	for(int i=ft[x];i;i=nx[i])
	{
	  if(to[i]!=f) ok=1;
    }
	if(!ok) //如果没路走,判断是不是最大值
	{
		if(st>maxn) ryd=x,maxn=st;
		return;
	}
	for(int i=ft[x];i;i=nx[i]) if(to[i]!=f) f2(to[i],st+1,x);
	return;
}
bool f3(int x,int st,int f)//用bool的原因看下面
{
	if(x==ryd)
	{
		zj[st]=x;
		zjs=st;
		return 1;//走到另一端返回1
	}
	for(int i=ft[x];i;i=nx[i])
	if(to[i]!=f)
	if(f3(to[i],st+1,x))//如果返回1说明这样走可以走到另一端,可以记录路径,这样就不容易记错
	{
		zj[st]=x;//记录
		return 1;//返回1
	}
	return 0;//怎么都找不到返回0
}
void add(int x,int y)
{
    nx[++cnt]=ft[x];
    ft[x]=cnt;
    to[cnt]=y;
    return ;
}
```





---

## 作者：Hexarhy (赞：8)

### Preface

CSP AFO 选手报到，做道树论题平复下心情~~差点降智自闭~~。

### Solution

题目要求最大值的最小值，像极了二分的套路。机房同学口胡了一下貌似可做。不够细节和实现略难也没码，留给读者思考。

不过二分的解法是针对于边权任意的，但这题边权均为 $1$，因此应该有些很好的性质。

从更好的角度切入找思路，因此避开了树的直径，也就是直接思考 $k$ 个核心城市的策略~~这对我来说正确性和动机不太显然~~。

思考对于这 $n-k$ 个非核心城市对于答案的贡献。显然，每次**从叶子节点开始**，向上安排为非核心城市，选满 $n-k$ 个。剩下 $k$ 个核心城市就都集中在树的深度浅的地方。

具体地说，BFS 每次选取度为 $1$ 的节点，向上扩展，进行类似拓扑排序的操作。

答案就是 BFS 的层数。这可以用一个临时的队列存下一层的节点。具体看代码。

时间复杂度 $\Theta(n)$。代码量和程序效率都很优秀。

### Code

**本代码需要 C++11。**

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>
using namespace std;

template<typename tp>
void read(tp& a)
{
    register tp num=0;register int f=1;register char ch=getchar();
    while(!isdigit(ch) && ch!='-') ch=getchar();
    if(ch=='-') f=-1,ch=getchar();
    do
        num=num*10+int(ch-'0'),ch=getchar();
    while(isdigit(ch));
    a=num*f;
}
template<typename tp,typename...Args>
void read(tp& a,Args&...args){	read(a);read(args...);	}

typedef const int cint;
cint MAXN=1e5+5;
int n,k,cnt,ans;
vector<int> edge[MAXN];
int deg[MAXN];

void solve(void)
{
    queue <int> q;
    for(int i=1;i<=n;i++)
        if(deg[i]==1)
        {
            q.emplace(i);
            deg[i]=0;//清零是因为避免父节点再次选中这个节点。当然也可以用 visit[] 来实现
        }
    while(cnt<=n-k)
    {
        ans++;
        queue<int> tmp;//临时存储 bfs 下一层的节点
        while(!q.empty())
        {
            cint u=q.front();
            q.pop();
            cnt++;
            if(cnt==n-k)    return;
            for(const auto& v:edge[u])
            {
                deg[v]--;
                if(deg[v]==1)
                {
                    deg[v]=0;
                    tmp.emplace(v);
                }
            }
        }
        q=tmp;
    }
}

int main()
{
    read(n,k);
    for(int i=1;i<=n-1;i++)
    {
        int u,v;read(u,v);
        edge[u].emplace_back(v);
        edge[v].emplace_back(u);
        deg[u]++;deg[v]++;
    }
    solve();
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Provicy (赞：7)

根据题目这段话：

```
定义某个非核心城市与这 kk 座核心城市的距离为，这座城市与 kk 座核心城市的距离的最小值。那么所有非核心城市中，与核心城市的距离最大的城市，其与核心城市的距离最小。你需要求出这个最小值。
```
我们可以得出这是一道求**树的直径**的题。

一般的，求树的直径有两种方法，一种是**树形$DP$**，代码如下：

```cpp
void Dp_Tree(int x,int before)
{
    for(int i=head[x];i;i=e[i].nxt)//前向星存边，至于结构体大家应该都能看懂是什么意思
    {
        if(e[i].to==before) continue;//Check 是否回溯了
        Dp_Tree(e[i].to,before);
        maxx=max(maxx,dep[x]+dep[e[i].to]+e[i].dis);//更新直径的值
        dep[x]=max(dep[x],dep[e[i].to]+e[i].dis);//dep[x]表示以x为根其子树的深度
    }
}
```
这个方法代码简洁，但有一个坏处，就是我们难以记录**直径上的节点**（反正我是不会）

然后我们想到一种朴素的做法，但是它可以记录直径上的节点：

### 两遍$DFS$ （其实这才是大暴力好吧）

我们就假定节点编号为$1$的节点是第一次遍历的根算了，然后找到以$1$为根的树的深度最大的节点，显然，它为树的直径的一端。

然后以这个节点为根，再遍历一遍，以它为根的树的深度最大的节点与它本身连通的路径就是这个树的直径了，这是显而易见的（不明白的话可以手画一张图，其实对于我这个才学OI三个月的萌新来说，刚学那几天听XK指导讲这个完全听不懂。。。如果不懂的可以去找 [Xukuan](https://www.luogu.org/space/show?uid=27924) 问）。

两次$DFS$的好处就是我们发现这个直径的路径是很好记录的。

知道了树的直径以及其路径上的节点后，再观察本文开头那一段题目文本文字，我们易知道这$k$个核心城市中一定有树的直径的中点（因为树的直径是树上最长的一条链）。

#### 那么，我们把这树的直径的中点作为建的新树的根，其他节点以：

### 以树的直径的中点为根的这课树的最大深度$-$这个节点的深度，即$maxdep[x]-dep[x]$

然后我们取其前$k$大的值即可作为这$k$个核心城市，剩下城市排个序取个最大值就行了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=210000;
int n,k,head[N],maxE,d[N],maxd,stx;
int p,f[N],vd[N],pro[N],maxx;
struct Edge{int nxt,to;}e[N];
inline void Add(int u,int v)
{
	e[++maxE].nxt=head[u];
	head[u]=maxE;
	e[maxE].to=v;
}
bool cp(int x,int y){return x>y;}
void DFSFind1(int x,int before)
{
	if(d[x]>maxd) maxd=d[x],stx=x;
	for(int i=head[x];i;i=e[i].nxt) 
	{
		if(e[i].to==before) continue;
		d[e[i].to]=d[x]+1;
		DFSFind1(e[i].to,x);
	}
}
void DFSFind2(int x,int before)
{
	if(d[x]>maxd) maxd=d[x],stx=x;
	for(int i=head[x];i;i=e[i].nxt) 
	{
		if(e[i].to==before) continue;
		d[e[i].to]=d[x]+1;f[e[i].to]=x;
		DFSFind2(e[i].to,x);
	}
}
void DFSFind3(int x,int before)
{
	d[x]=d[before]+1;vd[x]=d[x];
	for(int i=head[x];i;i=e[i].nxt)
	{
		if(e[i].to==before) continue;
		DFSFind3(e[i].to,x);
		vd[x]=max(vd[x],vd[e[i].to]);
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1,u,v;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		Add(u,v);Add(v,u);
	}
    DFSFind1(1,0);memset(d,0,sizeof(d));
    maxd=0;DFSFind2(stx,0);p=stx;
    for(int i=1;i<=(d[stx]+1)/2;i++) p=f[p]; 
	memset(d,0,sizeof(d));
	DFSFind3(p,0);
	for(int i=1;i<=n;i++) pro[i]=vd[i]-d[i];
	sort(pro+1,pro+1+n,cp);
	for(int i=k+1;i<=n;i++) maxx=max(maxx,pro[i]+1);
	printf("%d\n",maxx);
	return 0;
}
```


---

## 作者：Mysterious_Cat (赞：4)

### 题目思路：

以树的直径中点为根，设每个节点的深度为 $dep_i$，其后代节点最大深度为 $Maxdep_i$，则 $k$ 个核心节点为 $Maxdep_i - dep_i$ 最小的 $k$ 个点。

先求出树的直径，过程中记录每个节点的父亲以及树的直径的叶子节点。然后递归遍历找中点。最后贪心求答案即可。

### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int NR = 2e5 + 5;

int tot = 0, x, y, len, ans, h[NR], dep[NR], father[NR], Maxdep[NR], deplen[NR];

struct Edge
{
    int u, v, w, next;
}e[NR];

void add(int u, int v, int w)
{
    tot++;
    e[tot].u = u, e[tot].v = v, e[tot].w = w;
    e[tot].next = h[u], h[u] = tot;
}

void dfs(int u, int f)
{
    if(len < dep[u]) len = dep[u], y = u;
    for(int i =  h[u]; i; i = e[i].next)
    {
        int v = e[i].v, w = e[i].w;
        if(f != v) 
        {
            dep[v] = dep[u] + 1;
            father[v] = u;
            dfs(v, u);
        }
    }
}

void dfs2(int u, int f)
{
    Maxdep[u] = dep[u];
    for(int i = h[u]; i; i = e[i].next)
    {
        int v = e[i].v, w = e[i].w;
        if(f != v)
        {
            dep[v] = dep[u] + 1;
            father[v] = u;
            dfs2(v, u);
            Maxdep[u] = max(Maxdep[u], Maxdep[v]);
        }
    }
}

bool cmp(int a, int b) {return a > b;}

int main()
{
    int n, k;
    scanf("%d %d", &n, &k);
    for(int i = 1; i <= n; i++)
    {
        int u, v;
        scanf("%d %d", &u, &v);
        add(u, v, 1);
        add(v, u, 1);
    }//输入
    
    x = 1, y = 0, len = 0;
    dfs(x, -1);
    memset(father, 0, sizeof(father));
    memset(dep, 0, sizeof(dep));
    len = 0;
    dfs(y, -1);//求直径
    
    int pos = y;
    for(int i = 1; i <= (dep[y] + 1) / 2; i++, pos = father[pos])
        ;//找中点
    
    memset(father, 0, sizeof(father));
    memset(dep, 0, sizeof(dep));
    dfs2(pos, -1);
    for(int i = 1; i <= n; i++)
        deplen[i] = Maxdep[i] - dep[i];//求深度与后代深度        
        
    sort(deplen + 1, deplen + n + 1, cmp);
    for(int i = k + 1; i <= n; i++) 
        ans = max(ans, deplen[i] + 1);//贪心
    cout << ans;
    
    return 0;
}
```


---

## 作者：caidzh (赞：4)

~~就一sb题，可是我还交了三遍才过~~

很显然想到直径上的点：

如果$k=1$，那么肯定是要选择直径的中点

显然如果$k>1$，直径的中点也是必选的

接下来考虑剩下的点，对于剩下的点，如果将它选入$k$个点的集合，得到更新的距离一定在它的子树里，因为就不在它子树里的点而言它的父亲一定比它更优

因此以直径中点为根，再跑一遍$dfs$，得到$dis_i$：$i$到它子树内的点的距离的最大值，然后从根节点每次取$dis$大的节点不断地向外扩展就行了，这可以用一个堆来维护

代码不是很好看，尽量不要参考，但先放上
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define INF 2147483647
#define LLINF 9223372036854775807
#define LL long long
#define xyx AKIOI
#define Dilute AKIOI
#define Chtholly_Tree AKIOI
#define time_interspace AKIOI
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
int n,k,head[100010],cnt;
struct Edge{int nxt,to;}edge[200010];
void add_edge(int x,int y){edge[++cnt].nxt=head[x];edge[cnt].to=y;head[x]=cnt;}
struct Node{
	int id,dep;
	bool operator <(Node x)const{return x.dep>dep;}
};
int dep[100010],ID,maxdep,id1,id2,Min=INF,Dep[100010],len[100010],Fa[100010];
void dfs(int x,int fa){
	dep[x]=dep[fa]+1;if(dep[x]>maxdep)maxdep=dep[x],ID=x;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==fa)continue;dfs(v,x);
	}
}
void dfs1(int x,int fa){
	int flag=0;Fa[x]=fa;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;if(v==fa)continue;dfs1(v,x);
		len[x]=max(len[v]+1,len[x]);
	}
}
priority_queue<Node>que;
int main()
{
	n=read();k=read();
	for(int i=1;i<n;i++){int u=read(),v=read();add_edge(u,v);add_edge(v,u);}
	dfs(1,0);id1=ID;maxdep=0;dfs(ID,0);id2=ID;
	for(int i=1;i<=n;i++)Dep[i]=dep[i];dfs(id2,0);
	for(int i=1;i<=n;i++){
		if(maxdep%2==1)if(Dep[i]==dep[i]&&Min>=Dep[i])ID=i,Min=Dep[i];
		if(maxdep%2==0)if(abs(Dep[i]-dep[i])==1&&Min>=Dep[i])ID=i,Min=Dep[i];
	}
	que.push((Node){ID,max(Dep[ID],dep[ID])});dfs1(ID,0);
	for(int i=1;i<=k;i++){
		Node u=que.top();que.pop();
		for(int i=head[u.id];i;i=edge[i].nxt){
			int v=edge[i].to;if(v==Fa[u.id])continue;
			que.push((Node){v,len[v]});
		}
	}Node u=que.top();
	cout<<u.dep+1;
	return 0;
}
```


---

## 作者：waOooo (赞：4)

# 往这看，往这看，最简单的题解

主体思路和前面的是一样的；

**但是求以直径中点为根的每个子节点的子树最大深度不一样**

前面题解都是求什么差值，明显不要这么复杂；

直接上代码；

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pa pair<int,int>
#define ls k<<1
#define rs k<<1|1
#define inf 0x3f3f3f3f
using namespace std;
const int N=100010;
const int M=2000100;
const LL mod=1e9+7;
int n,k,cnt,head[N],ans=0;
int st1,st2,max1,max2,len1[N],len2[N],len3[N],pre[N];
vector<int>ve;
bool cmp(int x,int y){return x>y;} 
struct Node{
	int to,nex;
}edge[M];
void add(int p,int q){
	edge[cnt].to=q;
	edge[cnt].nex=head[p];
	head[p]=cnt++;
}
void dfs1(int sn,int fa){
	if(len1[sn]>=max1){
		max1=len1[sn];
		st1=sn;
	}
	for(int i=head[sn];~i;i=edge[i].nex){
		int v=edge[i].to;
		if(v!=fa) len1[v]=len1[sn]+1,dfs1(v,sn);
	}
}
void dfs2(int sn,int fa){
	if(len2[sn]>=max2){
		max2=len2[sn];
		st2=sn;
	}
	for(int i=head[sn];~i;i=edge[i].nex){
		int v=edge[i].to;
		if(v!=fa){
			pre[v]=sn;
			len2[v]=len2[sn]+1;
			dfs2(v,sn);
		}
	}
}
void dfs3(int sn,int fa){
	len3[sn]=0;
	for(int i=head[sn];~i;i=edge[i].nex){
		int v=edge[i].to;
		if(v!=fa){
			dfs3(v,sn);
			len3[sn]=max(len3[sn],len3[v]+1);
		}
	}
}
int main(){
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&k);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v),add(v,u);
	}	
	dfs1(1,-1);
	dfs2(st1,-1);
	for(int i=1;i<=(max2+1)/2;i++) st2=pre[st2];//找到直径中点 
	dfs3(st2,-1);
	for(int i=1;i<=n;i++) ve.push_back(len3[i]);
	sort(ve.begin(),ve.end(),cmp); 
	cout<<ve[k]+1<<endl;//第k+1个点明显最大 
	return 0;
}

```


---

## 作者：_Aghost (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5536)
## 前置知识
树的直径定义：
我们将一棵树T = ( V，E )的直径定义为**maxδ ( u，v ) ( u，v ∈ V )**，也就是说，树中所有**最短路径距离的最大值**即为树的直径。

做法：
### 1. 两次dfs(或bfs)

先从任意一点P出发，找离它最远的点Q，再从点Q出发，找离它最远的点W，W到Q的距离就是是的直径。
### 2. 树形DP
对于每个节点我们要记录两个值：

f1[i] 表示以 i 为根的子树中，i 到叶子结点距离的最大值

f2[i] 表示以 i 为根的子树中，i 到叶子结点距离的次大值

对于一个节点，它到叶子结点距离的最大值和次大致所经过的路径肯定是不一样的

若j是i的儿子，那么（下面的 w [ i ][ j ] 表示 i 到 j 的路径长度）：

若 f1 [ i ] < f1 [ j ] + w [ i ][ j ]，f2 [ i ] = f1 [ i ]，f1 [ i ] = f1 [ j ] + w [ i ][ j ]；

否则，若 f2 [ i ] < f1 [ j ] + w [ i ][ j ]，f2 [ i ] = f1 [ j ] + w [ i ][ j ]；

## 题目大意：
找到一种选点的方法，使得所有非核心城市中离核心城市的最大距离最小。

思路1：二分 但是我们能发现题目中的边权都为1，考虑其他算法。

若k=1，那么显然应该放在树的直径的中点处，k如果再加，就尽可能让答案小一些。	定义dep为深度，mdep为向下能到的最大深度，那么就把mdep-dep当做关键字从大到小排序，前k个可以放入核心城市 那么答案就是mdep[k+1]-dep[k+1]+1。

## 代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
const int N =5e5+1;
using namespace std;
int n,m,x,y,ru[N],f[N];
int dep[N],mdep[N],maxx,maxx2,zj1,zj2,root,ans[N];
int fir[N],nex[N<<1],poi[N<<1],w[N<<1],sum;
void add(int x,int y)
{
	nex[++sum]=fir[x];
	poi[sum]=y;
	fir[x]=sum;
}
void dfs(int x,int fa)
{
	dep[x]=dep[fa]+1;
	for(int i=fir[x];i;i=nex[i])
	{
		if(fa==poi[i]) continue;
		dfs(poi[i],x);
	}
}
void dfss(int x,int fa)
{
	mdep[x]=dep[x];
	for(int i=fir[x];i;i=nex[i])
	{
		int p=poi[i];
		if(fa==p) continue;
		dfss(p,x);
		mdep[x]=max(mdep[p],mdep[x]);
	}
}
void dfs_1(int x,int fa,int d)
{
	if(d>maxx)
	{
		zj1=x;
		maxx=d;
	}
	for(int i=fir[x];i;i=nex[i])
	{
		int p=poi[i];
		if(p==fa)  continue;
		dfs_1(p,x,d+1);
		f[poi[i]]=x;
	}
}
void dfs_2(int x,int fa,int d)
{
	if(d>maxx2)
	{
		zj2=x;
		maxx2=d;
	}
	for(int i=fir[x];i;i=nex[i])
	{
		int p=poi[i];
		if(p==fa) continue;
		dfs_2(p,x,d+1);
	}
}
bool cmp(int a,int b)
{
	return a>b;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n-1;i++)
	{
		int x,y,z;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs_1(1,0,0);
	dfs_2(zj1,0,0);
	root=zj1;
	int pan=maxx2;
	for(int i=1;i<=(maxx2)/2;i++)
	root=f[root];	
	dfs(root,0);
	dfss(root,0);
	for(int i=1;i<=n;i++)
	ans[i]=mdep[i]-dep[i];
	sort(ans+1,ans+1+n,cmp);
	printf("%d\n",ans[m+1]+1);
}
/*
6 3
1 2
2 3
2 4
1 5
5 6*/
```



---

## 作者：LCGUO (赞：1)

这题的前置知识是会求直径。

我们可以~~显然~~证明，直径的中点肯定是 $k$ 座核心城市之一。

---

~~伪证~~证明：  
我们可以假设一个节点 $x$ 是直径外，离直径最近的一个点。

显然，直径上的任意一个点到核心城市的距离，就是他到 $x$ 的距离。

并且由于直径是树中最长的一条路径，所以没有其他点到 $x$ 的距离大于直径端点到 $x$ 的距离。

所以 $x$ 在直径的时候，可以使与核心城市的距离最大的城市，其与核心城市的距离最小。

再证明 $x$ 必须为直径的中点。

当 $x$ 不为直径的中点时，必定有一个直径端点到 $x$ 的距离稍稍的大那么一点点，只有当 $x$ 为直径中点时，两个直径端点到 $x$ 的最大值才会最小。

---

在找直径的时候，记录每个点的父亲，找到端点后，进行回溯，找到直径的中点。

然后贪心的思想，对于每个节点 $i$，按照，以直径的中点为根，设 $deep_i$ 为 $i$ 节点的深度，$maxdeep_i$ 表示 $i$ 能到的最大深度。

按照能到达的最大深度减该节点的深度排序，取前 $k$ 个数，就可以保证，与核心城市的距离最大的城市，其与核心城市的距离最小。

而且所选的点肯定是联通的。

---

代码如下：

```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
int read(){
    int s=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=0;c=getchar();}
    while(c>='0'&&c<='9')s=(s<<1)+(s<<3)+(c^48),c=getchar();
    return f?s:-s;
}
int n,k,dis[100010],vis[100010],point,faq;
int tot,head[200010],ver[200010],nxt[200010];
int pl[100010],maxdeep[100010],deep[100010];
int ans[100010],minn=-1;
bool cmp(int x,int y){
    return x>y;
}
void add(int x,int y){
    nxt[++tot]=head[x]; ver[tot]=y;
    head[x]=tot;
}
void bfs(int s){ //找直径
    memset(dis,0,sizeof dis);
    memset(vis,0,sizeof vis);
    queue<int>q; q.push(s); vis[s]=1;
    while(q.size()) {
        int x=q.front(); q.pop();
        for(rint i=head[x];i;i=nxt[i]){
            int y=ver[i];
            if(!vis[y]){
                pl[y]=x;
                dis[y]=dis[x]+1;
                q.push(y); vis[y]=1;
            }
        }
    }
    faq=0;
    for(rint i=1;i<=n;++i)
        if(dis[i]>faq) faq=dis[i],point=i;
}
void dfs(int x,int fa){ //处理深度
    maxdeep[x]=deep[x];
    for(rint i=head[x];i;i=nxt[i]){
        int y=ver[i];
        if(y==fa) continue;
        deep[y]=deep[x]+1; dfs(y,x);
        maxdeep[x]=max(maxdeep[x],maxdeep[y]);
    }
}
int main(){
    n=read(); k=read();
    for(rint i=1,x,y;i<n;++i){
        x=read(); y=read();
        add(x,y); add(y,x);
    }
    bfs(1); bfs(point);
    int mid_point=point;
    for(rint i=1;i<=faq+1>>1;++i) mid_point=pl[mid_point];
    dfs(mid_point,0);
    for(rint i=1;i<=n;++i) ans[i]=maxdeep[i]-deep[i];
    sort(ans+1,ans+1+n,cmp);
    for(rint i=k+1;i<=n;++i) minn=max(ans[i]+1,minn);
    printf("%d",minn);
    return 0;
}
```

---


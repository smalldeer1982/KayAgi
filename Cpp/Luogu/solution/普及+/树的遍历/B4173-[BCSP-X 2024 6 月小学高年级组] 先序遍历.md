# [BCSP-X 2024 6 月小学高年级组] 先序遍历

## 题目描述

按照根-左-右的顺序遍历**二叉树**：

- 先序遍历 = 根 + 左子树先序遍历 + 右子树先序遍历
- 空树的先序遍历 = 空

![](https://cdn.luogu.com.cn/upload/image_hosting/rz3z5ke0.png)

给一棵 $n$ 个点的二叉树（根节点为 $1$），你可以进行以下操作至多 $1$ 次：

- 选择 $1$ 个（除了根之外的）点 $u$，断开 $u$ 和其父节点之间的边；然后重新选择另一个点作为 $u$ 的父节点、将 $u$ 接上去，需要保证操作之后仍然是一棵以 $1$ 为根的二叉树。

你想要操作之后的二叉树有字典序最小的先序遍历序列，输出这个序列。

## 说明/提示

### 样例解释 #1

- 对于第一个样例，可以把 3 号结点连在 2 号结点的左儿子处。
- 对于第二个样例，可以把 4 号结点连在 3 号结点的左儿子处。

### 数据范围

对于所有数据，令 $\sum n$ 代表每组数据中 $n$ 的和，$1 \leq T \leq 100, 1 \leq n \leq 10^5, 1 \leq \sum n \leq 3 \times 10^5$，保证输入是一棵以 1 为根的二叉树。

- 对于测试点 1~3：$n \leq 10$；
- 对于测试点 4~8：$n \leq 200$；
- 对于测试点 9~11：$n \leq 1000$；
- 对于测试点 12~14：$n \leq 10^5$ 且所有 $ls[i] = 0$；
- 对于测试点 15：$n \leq 10^5$ 且所有 $rs[i] = 0$；
- 对于测试点 16~20：$n \leq 10^5$；

## 样例 #1

### 输入

```
12
4
2 3
0 4
0 0
0 0
5
2 3
0 4
0 5
0 0
0 0
6
5 2
3 6
4 0
0 0
0 0
0 0
6
2 3
6 4
0 5
0 0
0 0
0 0
6
5 2
3 0
4 0
6 0
0 0
0 0
6
3 2
4 6
0 0
5 0
0 0
0 0
6
4 2
5 3
0 0
0 0
0 6
0 0
6
3 2
0 0
5 4
0 6
0 0
0 0
6
2 3
0 0
5 4
0 6
0 0
0 0
6
3 2
4 5
0 0
0 6
0 0
0 0
6
2 3
0 4
0 0
0 5
0 6
0 0
6
2 5
3 4
0 0
0 0
6 0
0 0```

### 输出

```
1 2 3 4
1 2 3 4 5
1 2 3 4 5 6
1 2 4 3 5 6
1 2 3 4 6 5
1 2 4 5 3 6
1 2 5 4 6 3
1 2 3 5 4 6
1 2 3 4 5 6
1 2 4 3 6 5
1 2 3 4 5 6
1 2 3 4 5 6```

# 题解

## 作者：Ag2WO4 (赞：2)

Python 的致命卡常题。其实无非就是贪心两种情况：将靠前的大节点扔到比它小的节点后面、更大的节点前面；将后面的小节点提到靠前的左儿子位置。

就这点题把记忆化搜索（子树大小）、前缀和优化（找后缀最小值）、特殊值字典（快速定位需要迁移的最小值）、手推 $O(1)$ 公式、代码块拷贝、读写优化（其实没优化写操作）全用上来了，喜提 $649ms$ 的好成绩。

```python
import sys;sys.setrecursionlimit(1<<30)
def g(i):
    if i:h.append(i);g(a[i][0]);g(a[i][1])
def u(i):
    if 0<i<=n:global x;x[i]=1+u(a[i][0])+u(a[i][1]);return x[i]
    return 0
for _ in range(int(sys.stdin.readline())):
    n=int(sys.stdin.readline());a=[(0,0)]+[tuple(map(int,sys.stdin.readline().split()))for i in range(n)];h=[];g(1);h.append(n+1);z=1;q=[n+1];r={};x=[0]*(n+1);u(1)
    for i in range(n):
        if h[n+~i]<q[-1]:q.append(h[n+~i]);r[h[n+~i]]=n+~i
        else:q.append(q[-1])
    for i in range(n-1):
        if a[h[i]][0]>a[h[i]][1]>0:
            for j in range(i+x[h[i+1]]+1,n):
                if 0==a[h[j]][0]and h[i+1]<h[j+1]:print(*h[:i+1]+h[i+x[h[i+1]]+1:j+1]+h[i+1:i+x[h[i+1]]+1]+h[j+1:-1]);z=0;break
            break
        elif 0==a[h[i]][0]and h[i+1]>q[n+~i]:
            if h[i+x[h[i+1]]+1]>q[n+~i]:print(*h[:i+1]+h[r[q[n+~i]]:r[q[n+~i]]+x[h[r[q[n+~i]]]]]+h[i+1:r[q[n+~i]]]+h[r[q[n+~i]]+x[h[r[q[n+~i]]]]:-1]);z=0;break
            else:
                for j in range(i+x[h[i+1]]+1,n):
                    if 0==a[h[j]][0]and h[i+1]<h[j+1]:print(*h[:i+1]+h[i+x[h[i+1]]+1:j+1]+h[i+1:i+x[h[i+1]]+1]+h[j+1:-1]);z=0;break
                break
        elif 0==a[h[i]][1]and h[i+1]>h[i+x[h[i+1]]+1]:
            for j in range(i+x[h[i+1]]+1,n):
                if 0==a[h[j]][0]and h[i+1]<h[j+1]:print(*h[:i+1]+h[i+x[h[i+1]]+1:j+1]+h[i+1:i+x[h[i+1]]+1]+h[j+1:-1]);z=0;break
            break
    if z:print(*h[:-1])
```

---


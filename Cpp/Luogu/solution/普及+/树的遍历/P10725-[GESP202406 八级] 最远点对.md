# [GESP202406 八级] 最远点对

## 题目描述

小杨有⼀棵包含 $n$ 个节点的树，这棵树上的任意⼀个节点要么是白色，要么是黑色。

小杨想知道相距最远的一对不同颜色节点的距离是多少。

## 说明/提示

#### 样例解释

相距最远的不同颜色的一对节点为节点 $2$ 和 $5$。

#### 数据范围

**本题采用捆绑测试。**

| 子任务编号 | 得分 | $n$ | $a_i$ | 特殊条件 |
| :--: | :--: | :--: | :--: | :--: |
| $1$ |  $30$ | $\le 10^5$ | $0\le a_i\le 1$ | 树的形态为一条链 |
| $2$ | $30$ | $\le 10^3$ | $0\le a_i\le 1$ | |	
| $3$ | $40$ | $\le 10^5$ | $0\le a_i\le 1$ | |	

对于全部数据，保证有 $1\le n\le 10^5$，$0\le a_i\le 1$。

## 样例 #1

### 输入

```
5
0 1 0 1 0
1 2
1 3
3 4
3 5```

### 输出

```
3```

# 题解

## 作者：_zuoqingyuan (赞：20)

# 思路分析

对于题目中所描述的最长路径 $x\to y$，我们将其拆成两部分，分别是 $x\to z,z\to y$，其中 $z$ 为 $x,y$ 的**最近公共祖先**。可以枚举 $z$，找到对应的 $x,y$。

因为 $x,y$ 的选择互不干扰，我们枚举 $z$，同时记录 $z$ 的子树中距离节点 $z$ 最远的黑色点/白色点到 $z$ 的距离，然后更新答案即可。具体的，我们**设 $dp_{u,1/0}$ 表示 $u$ 的子树中距离 $u$ 最远的黑/白点到 $u$ 的距离**，如果 $s$ 为 $u$ 的一个儿子，可以写出转移方程：

$$dp_{u,1/0}=\max\{dp_{s,1/0}\}+1$$

更新答案时，为了**避免 $x,y$ 位于节点 $z$ 同一儿子的子树中**，我们用 $dp_{s,1/0}$ 更新 $dp_{u,1/0}$ 之前，先统计答案。假设路径右端 $y$ 在节点 $s$ 的子树中，路径左端 $x$ 则是在 $u$ 其他子节点的子树中（子节点 $s$ 之前）。则答案 $ans$ 为：

$$ans=\max\{dp_{u,1/0}+(dp_{s,0/1}+1)\}$$

此时就避免了位于同一个子树中的问题。初始时所有 $dp_{u,a_u}=0$，其余 $dp$ 值均为 $-\infty$。

树形 dp，时间复杂度 $\mathcal{O}(n)$。

# $\text{Code}$：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N=1e5+10,inf=1e9+10;
int n,to[2*N],nxt[2*N],ver[N],c[N],idx,ans,dp[N][2];
void add(int x,int y){
    to[++idx]=y,nxt[idx]=ver[x],ver[x]=idx;
}
void dfs(int x,int fa){
    dp[x][0]=dp[x][1]=-inf;
    dp[x][c[x]]=0;
    for(int i=ver[x];i;i=nxt[i]){
        if(to[i]==fa)continue;
        int y=to[i];dfs(y,x);
        ans=max(ans,max(dp[x][1]+dp[y][0],dp[x][0]+dp[y][1])+1);
        dp[x][0]=max(dp[x][0],dp[y][0]+1);
        dp[x][1]=max(dp[x][1],dp[y][1]+1);
    }
    return;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",c+i);
    for(int i=1,u,v;i<n;i++){
        scanf("%d %d",&u,&v);
        add(u,v),add(v,u);
    }
    dfs(1,0);
    printf("%d\n",ans);
    return 0;
}
```

如有错误，请指出。

---

## 作者：CaiZi (赞：7)

## [GESP202406 八级] 最远点对 题解
**[题目链接](https://www.luogu.com.cn/problem/P10725)**
### 题目分析
这题其实就是树的直径的加强版。

对于无色的情况，我们可以使用两次 DFS 解决，由于过于基础这里不做讲解，可以看 [OI-Wiki](https://oi-wiki.org/graph/tree-diameter/#%E5%81%9A%E6%B3%95-1-%E4%B8%A4%E6%AC%A1-dfs)。

对于异色的情况，我们第一遍 DFS 从任意一个点开始，比如 $1$ 号点，求出：与该点距离最远的**白色点** $x$、与该点距离最远的**黑色点** $y$。

第二遍 DFS 我们从点 $x$ 开始，求出：该点与任意**黑色点**最远的距离。

第三遍 DFS 我们从点 $y$ 开始，求出：该点与任意**白色点**最远的距离。

第二遍 DFS 和第三遍 DFS 求出的值取最大值即可。

时间复杂度 $O(n)$。
### 代码展示
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],x,y,z,c,d,s[100001];
vector<int>g[100001];
inline void dfs(int u,int v,int w){
	s[u]=w;
	if(a[u]==0&&s[u]>s[c]){
		c=u;
	}
	if(a[u]==1&&s[u]>s[d]){
		d=u;
	}
	for(int i:g[u]){
		if(i!=v){
			dfs(i,u,w+1);
		}
	}
	return;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=2;i<=n;i++){
		cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(1,0,0);
	x=c;
	y=d;
	c=d=0;
	dfs(x,0,0);
	z=s[d];
	dfs(y,0,0);
	cout<<max(z,s[c]);
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/164865202)**

---

## 作者：54188_you_Dad (赞：5)

# 前言

在夏令营的时候学了树的直径，看完了题目描述之后就觉得应该差不多。

# 思路

用 $\_1[i]$ 来存离 $i$ 最远的黑色节点的距离。

用 $\_0[i]$ 来存离 $i$ 最远的白色节点的距离。

考虑两种情况：

1. 左端点是黑，右端点是白。

2. 左端点是白，右端点是黑。

分别更新一次答案。

遍历完一个点还有更新 $\_1$ 和 $\_0$ 。

具体见代码注释。

# 代码

```
#include <bits/stdc++.h>
using namespace std;
//个人习惯
//#define int long long
vector<int> a[100005];
bool c[100005];
int ans = -1e9;
int _1[100005];//离 i 最远的黑色节点的距离
int _0[100005];//离 i 最远的白色节点的距离
void AAA(int x,int fa)
{
//	x 是当前节点
//	fa 是父节点
	if(c[x]) _1[x] = 0;
	else _0[x] = 0;
	for(int i=0;i<a[x].size();i++)
	{
		int y = a[x][i];
		if(y==fa) continue;
//		不是父节点就往下搜
		AAA(y,x);
//		更新答案
		if(_0[x]>=0&&_1[y]>=0) ans = max(ans,_1[y]+_0[x]+1);
		if(_1[x]>=0&&_0[y]>=0) ans = max(ans,_0[y]+_1[x]+1);
		_1[x] = max(_1[x],_1[y]+1);
		_0[x] = max(_0[x],_0[y]+1);
	}
}
signed main()
{
//	个人习惯
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
//	初始化
	for(int i=1;i<=n;i++)
	{
		cin>>c[i];
//		一定要小于 -1e5 ，不然会 WA
		_1[i] = -1e9;
		_0[i] = -1e9;
	}
//	输入+建图
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		a[u].push_back(v);
		a[v].push_back(u);
	}
	AAA(1,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：nb_jzy (赞：5)

# 题意
给你一棵树，每个节点有两个颜色，让你求起点和终点为**不同颜色的**最长路径是多少。
# 做法
首先，如果没有颜色限制，那么就是求直径。

加上颜色后，因为**只有两种颜色**，所以我们可以采用**求直径的方法**，分别维护出每个点到自己子树内的**最远的黑点和白点的距离**。然后再考虑拼接两条链就行了。

时间复杂度就跟求直径一样，是线性 $\mathcal{O}(n)$ 的。

还有一些**小细节**，比如当前子树内**只有一种颜色的时候**，另一种颜色的距离**不能赋值为0**，不然每次都会加一，会有问题。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int ans,bl[maxn],wh[maxn],a[maxn],n;
vector<int> g[maxn];
void dfs(int u,int fa){
	int maxx1=-1,maxx2=-1;
	for(auto v:g[u]){
		if(v!=fa){
			dfs(v,u);
			if(maxx1!=-1&&wh[v]!=-1){
				ans=max(ans,maxx1+wh[v]+2); 
			}
			if(maxx2!=-1&&bl[v]!=-1){
				ans=max(ans,maxx2+bl[v]+2);
			}//考虑拼接
			maxx1=max(maxx1,bl[v]);
			maxx2=max(maxx2,wh[v]);
			if(bl[v]!=-1){
				bl[u]=max(bl[u],bl[v]+1);
			}
			if(wh[v]!=-1){
				wh[u]=max(wh[u],wh[v]+1);
			}
		}
	}
	if(a[u]==0){
		wh[u]=max(wh[u],0);
		ans=max(ans,maxx1+1);
	}
	else{
		bl[u]=max(bl[u],0);
		ans=max(ans,maxx2+1);
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];bl[i]=wh[i]=-1;//赋初值
	}
	int u,v;
	for(int i=1;i<n;i++){
		cin>>u>>v;
		g[u].push_back(v),g[v].push_back(u);
	}
	dfs(1,0);
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：MARSandEARTH (赞：4)

6 月份 GESP 原题，赛时过了。

### 前置知识

树上 BFS。

### 题目大意

有⼀棵包含 $n$ 个节点的树，这棵树上的任意⼀个节点有白黑两种颜色。

求相距最远的一对不同颜色节点的距离是多少。

### 思路

既然题目说了求最远不同颜色点对，那么就必定是一黑一白~~废话~~。所以我们可以先假定一点为根节点，分别用 BFS 寻找距离该点最远的白点与黑点，然后分别用 BFS 寻找最远的不同颜色节点，最后两个距离取最大值即可。时间复杂度 $O(n)$。

代码太长了，就不放了，还请读者自行写出。

---

## 作者：DLJdouliangjian (赞：3)

## [GESP202406 八级] 最远点对 双 `dfs` 解法题解  
这题题意很好理解，就是树上的每个节点都有自己的颜色，我们要找出两个不同颜色的节点的最远距离。  
### 思路：  
这题我们可以用两个 `dfs` 解决。  
第一个 `dfs`：  
主体是一个洪泛，在洪泛过程中求出每个节点的深度。  
在第一个 `dfs` 结束后，我们已经求出了每个节点的深度，要想要两个节点距离最远，我们就可以**让其中一个节点** **$k$** **的深度尽可能的低**，再**向上做** **`dfs`**，求出最远距离。  
那这里我们就要分**两类**来讨论：  

第一类，**$k$** **为白色**，那我们在向上做 `dfs` 时就要找出一个离 $k$ 最远的**黑色节点**。  
第二类，**$k$** **为黑色**，那我们在向上做 `dfs` 时就要找出一个离 $k$ 最远的**白色节点**。

这样我们就可以写出第二个 `dfs`，也是一个洪泛。  

代码：

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define INF 0x3f3f3f3f
using namespace std;
int n;
int a[MAXN],depth[MAXN];
int maxdepth=-INF,id,colur;
int ans=-INF;
int vis[MAXN];
vector<int> g[MAXN];
void judge(int u,int father){
    depth[u]=depth[father]+1;
    for(int i=0;i<g[u].size();i++){
        int v=g[u][i];
        if(v==father){
            continue;
        }
        judge(v,u);
    }
}
void dfs(int u,int s){
    for(int i=0;i<g[u].size();i++){
        int e=g[u][i];
        if(vis[e]==-1){
            vis[e]=s+1;
            dfs(e,s+1);
        }
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1,x,y,z;i<n;i++){
        cin>>x>>y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    judge(1,0);
    for(int i=1;i<=n;i++){
        if(a[i]==0) continue;
        if(depth[i]>maxdepth){
            maxdepth=depth[i];
            id=i;
            colur=a[i];
        }
    }
    memset(vis,-1,sizeof(vis));
    vis[id]=0;
    dfs(id,0);
    for(int i=1;i<=n;i++){
        //cout<<vis[i]<<endl;
        if(a[i]==0){
            ans=max(ans,vis[i]);
        }
    }
    memset(vis,-1,sizeof(vis));
    maxdepth=-1;
    for(int i=1;i<=n;i++){
        if(a[i]==1) continue;
        if(depth[i]>maxdepth){
            maxdepth=depth[i];
            id=i;
            colur=a[i];
        }
    }
    vis[id]=0;
    dfs(id,0);
    for(int i=1;i<=n;i++){
        if(a[i]==1){
            ans=max(ans,vis[i]);
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：huangzixi071018 (赞：2)

## 题目大意：
在一棵 $n$ 个节点的树上找 $2$ 个颜色不同的节点，使这两个节点的距离最远，输出这个距离。

## 思路：
本题难度不高，可以用两个数组 $o$ 和 $z$ 记录离当前节点距离最远的 $1$ 和 $0$ 的距离。答案只会有有两种情况，以当前点为公共祖先，一种情况是当前分支中的 $1$ 和其他分支中的 $0$ 构成，另一种是当前分支中的 $0$ 和其他分支中的 $1$ 构成，只需要枚举和前面的分支构成的答案，取最大值即可。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>e[100005];
int a[100005],o[100005],z[100005],ans;
void dfs(int x,int f){
	if(a[x]==1){
		o[x]=0;
	}else{
		z[x]=0;
	}
	for(int i=0;i<e[x].size();i++){
		int y=e[x][i];
		if(y==f)continue;
		dfs(y,x);
		if(o[x]>=0&&z[y]>=0){
			ans=max(ans,o[x]+z[y]+1);
		}
		if(z[x]>=0&&o[y]>=0){
			ans=max(ans,z[x]+o[y]+1);
		}
		o[x]=max(o[x],o[y]+1);
		z[x]=max(z[x],z[y]+1);
	}
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		o[i]=-1e9;
		z[i]=-1e9;
	}
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	dfs(1,0);
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：chatoudp (赞：2)

### 前置知识

树的直径

### 正文

首先我们先不考虑树上的颜色，那么这题就是求树的直径。先找到距离任意一点最远的点，设它为点 $x$。再找到距离点 $x$ 最远的点，设它为点 $y$。$x$ 与 $y$ 的距离就是该树直径的长度。

但这题需要考虑颜色，我们可以分别找距离任意一个点距离最远的白点、黑点，设它们分别为 $x_1$、$x_2$。再找到距离 $x_1$ 最远的黑点，设它为 $y_1$。找到距离 $x_2$ 最远的白点,设它为 $y_2$。最后输出 $x_1$ 到 $y_1$ 的距离和 $x_2$ 到 $y_2$ 的距离较大的一个。

### AC 代码：
```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;
typedef long long ll;
int n,a[100005],dis[100005];
int maxn1,maxn2,maxid1,maxid2,k1,k1d,k2,k2d;
vector<int> v[100005];
void dfs(int x){
	for(auto p:v[x])
		if(dis[p]==dis[0]){
			dis[p]=dis[x]+1;
			dfs(p);
		}
}
int main(){//'_' T_T ^_^
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<n;i++){
		int x,y; scanf("%d%d",&x,&y);
		v[x].push_back(y),v[y].push_back(x);
	}
	memset(dis,-0x3f,sizeof(dis));
	dis[1]=0;
	dfs(1);
	maxn1=maxn2=-1;
	for(int i=1;i<=n;i++){
		if(a[i]&&maxn2<dis[i]) maxid2=i,maxn2=dis[i];
		if(!a[i]&&maxn1<dis[i]) maxid1=i,maxn1=dis[i]; 
	}
	memset(dis,-0x3f,sizeof(dis));
	dis[maxid1]=0;
	dfs(maxid1);
	k1=-1;
	for(int i=1;i<=n;i++)
		if(a[i]&&k1<dis[i]) k1d=i,k1=dis[i];
	memset(dis,-0x3f,sizeof(dis));
	dis[maxid2]=0;
	dfs(maxid2);
	k2=-1;
	for(int i=1;i<=n;i++)
		if(!a[i]&&k2<dis[i]) k2d=i,k2=dis[i];
	printf("%d",max(k1,k2));
	return 0;
}

```

---

## 作者：Lele_Programmer (赞：2)

# P10725 题解

~~祝贺本蒟蒻 GESP 8 级水了 92 分。~~

## 思路

在树上求最值，貌似可以用树形动态规划来写。~~感觉自己开的数组好像有点多。~~

对于第 $i$ 个点，用 $f_{i,0}$ 表示以 $i$ 为根的子树中，$i$ 作为一端，另一端连接到颜色为 $0$ 的点的最大距离，$f_{i,1}$ 同理，$g_i$ 表示以 $i$ 为根的子树中，$i$ 作为一段，另一端连接到颜色与 $i$ 不同的点的最大距离，这里其实可以不用这个数组，不过便于理解，还是写出来了，然后，$p_i$ 表示先取了一个颜色 $0$ 的点，再取了一个颜色 $1$ 的点，这两个点的路径最长长度，$q_i$ 表示先取了一个颜色 $1$ 的点，再取了一个颜色 $0$ 的点，这两个点的路径最长长度。

所以状态转移的核心部分就这么简单：

```cpp
void dfs(int u,int fa) {
    f[u][arr[u]]=0;
    for (int i=h[u];~i;i=ne[i]) {
        if (e[i]==fa) continue;
        dfs(e[i],u);
        p[u]=max(p[u],f[u][0]+f[e[i]][1]+1);
        q[u]=max(q[u],f[u][1]+f[e[i]][0]+1);
        f[u][0]=max(f[u][0],f[e[i]][0]+1);
        f[u][1]=max(f[u][1],f[e[i]][1]+1);
        g[u]=max(g[u],f[u][arr[u]^1]);
    }
}
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100005;
const int M=200005;
const int inf=1e8;

int n;
int arr[N];
int e[M],ne[M],h[N],tot;
int f[N][2];
int g[N];
int p[N];
int q[N];

void add(int a,int b) {
    e[tot]=b,ne[tot]=h[a],h[a]=tot++;
}

void dfs(int u,int fa) {
    f[u][arr[u]]=0;
    for (int i=h[u];~i;i=ne[i]) {
        if (e[i]==fa) continue;
        dfs(e[i],u);
        p[u]=max(p[u],f[u][0]+f[e[i]][1]+1);
        q[u]=max(q[u],f[u][1]+f[e[i]][0]+1);
        f[u][0]=max(f[u][0],f[e[i]][0]+1);
        f[u][1]=max(f[u][1],f[e[i]][1]+1);
        g[u]=max(g[u],f[u][arr[u]^1]);
    }
}

int main() {
    memset(h,-1,sizeof(h));
    scanf("%d",&n);
    for (int i=1;i<=n;++i) {
        scanf("%d",&arr[i]);
    }
    for (int i=1;i<=n-1;++i) {
        int a,b;
        scanf("%d %d",&a,&b);
        add(a,b);
        add(b,a);
    }
    for (int i=0;i<N;++i) {
        f[i][0]=f[i][1]=g[i]=p[i]=q[i]=-inf;
    }
    dfs(1,0);
    int ans=0;
    for (int i=1;i<=n;++i) {
        ans=max(ans,max(g[i],max(p[i],q[i])));
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Frozen_Ladybug (赞：0)

### 题目大意

给定一棵树，求距离最远的异色节点的距离。

### 分析

考虑在树上使用最短路搜索。从任意一个节点开始，该点的深度为它到父节点的距离加一。

在记录后进行搜索，遍历任何与其相连的子节点。接着从任意一个未被访问的子节点继续向下搜索。

在每一次访问结束后，将深度减去子节点的深度。访问后的答案和距离均取较大者。

### 代码

```c
#include<bits/stdc++.h>
using namespace std;
vector<int> g[100005];//向量数组，记录以每一个节点为出发点的下一个节点
int col[100005],n,dep[100005],d[100005][2],ans;
void dfs(int x,int fa){
    dep[x]=dep[fa]+1;//自己的深度为父节点深度+1
    d[x][col[x]]=dep[x];
    for(int i:g[x])//遍历以x为父节点的向量数组
        if(i!=fa){
            dfs(i,x);
            for(int j=0;j<2;j++)
                if(d[x][j]!=-1&&d[i][j^1]!=-1)
                    ans=max(ans,d[x][j]-dep[x]+d[i][j^1]-dep[x]);
            for(int j=0;j<2;j++) d[x][j]=max(d[x][j],d[i][j]);
        }
    ans=max(ans,d[x][col[x]^1]-dep[x]);
}
int main(){
    scanf("%d",&n);
    memset(d,-1,sizeof(d));
    for(int i=1;i<=n;i++) scanf("%d",&col[i]);
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);//输入，u,v建立双向边
    }
    dfs(1,0);//从1号节点开始，深度为0
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：SamHJD (赞：0)

> 给出一棵树，每个点黑白染色，求黑白点对的最远距离。

先处理出每个点的子树中最大的黑点和白点深度 $f_{u,0/1}$。枚举点 $u$ 作为答案黑白点对的 LCA，那么只需要找出 $u$ 的两棵子树 $v_1,v_2$ 使得 $f_{v_1,1}+f_{v_2,0}$ 或 $f_{v_1,0}+f_{v_2,1}$ 最大。

枚举子树时记录当前 $f_{v,0},f_{v,1}$ 的最大值，与新枚举到的子树更新答案即可。

```cpp
#include<bits/stdc++.h>
#define rep(i,k,n) for(int i=k;i<=n;++i)
#define per(i,n,k) for(int i=n;i>=k;--i)
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;int f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}
const int N=1e5+10;
int n,c[N],ecnt,head[N],f[N][2],dep[N],ans;
struct E{
	int v,next;
}e[N*2];
void add(int u,int v){
	e[++ecnt]={v,head[u]};
	head[u]=ecnt;
}
void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	if(c[u]==0) f[u][0]=dep[u];
	else f[u][1]=dep[u];
	for(int i=head[u];i;i=e[i].next){
		if(e[i].v==fa) continue;
		dfs(e[i].v,u);
		ans=max(ans,f[u][0]+f[e[i].v][1]-2*dep[u]);
		ans=max(ans,f[u][1]+f[e[i].v][0]-2*dep[u]);
		f[u][0]=max(f[u][0],f[e[i].v][0]);
		f[u][1]=max(f[u][1],f[e[i].v][1]);
        //先更新答案再更新 f，保证更新答案时 f 不包含当前子树
	}
}
int main(){
	memset(f,-0x3f,sizeof(f));
	read(n);
	rep(i,1,n) read(c[i]);
	rep(i,1,n-1){
		int u,v;read(u);read(v);
		add(u,v);add(v,u);
	}
	dfs(1,0);
	printf("%d\n",ans);
	return 0;
}

```

---


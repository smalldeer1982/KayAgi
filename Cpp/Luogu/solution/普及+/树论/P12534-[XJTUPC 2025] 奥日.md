# [XJTUPC 2025] 奥日

## 题目描述

精灵古树是尼博尔山的生命之源，其根系中流淌的流光维系着整片森林的生态平衡。古树的躯体由 $n$ 枚光之核心构成，这些璀璨如星的光点通过 $n−1$ 条能量枝干交织成无环的树状脉络。任意两枚核心之间，都有一条唯一的能量枝干通道蜿蜒相连，仿佛命运编织的丝线。

而奥日，本是古树孕育的守护灵体，却在雷霆撕裂苍穹的雨夜，被狂暴的飓风卷入深渊。失去奥日的古树试图通过光之仪式呼唤他归来，但失控的能量反噬让它陷入永夜，原本澄澈的核心如今爬满黑暗的纹路。

如今，归来的奥日必须激活所有被侵蚀的核心：当他首次触碰某个核心时，纯净能量会驱散黑暗；但重复经过时，紊乱的能量将累计形成过载波动。古树的法则严苛限定------整条路径中，重复触发的波动总和不得超过 $k$ 次。

此刻，奥日悬浮在星网交织的虚空中。他可以从任意核心启程，沿着能量枝干的轨迹穿梭。奥日需要在蜿蜒的能量枝干间规划路径，在限制内点亮最多的核心。

唯有让尽可能多的光之核心重新共鸣，才能唤醒古树真正的力量，让治愈的流光再次奔涌在尼博尔山的每一片叶脉中！尼博尔山将迎来破晓，而黑暗，终会在这片星网的共振中灰飞烟灭……

形式化的，给定一个非负整数 $k$，给出一颗无根树 $T=(V,E)$，$V=\{1,2,\dots,n\}$。

定义一条由 $m$ 个可重点构成的路径 $l=(u_1,u_2,u_3,\dots,u_m)$ 满足：对于任意的 $1\le i\le m-1$ 有 $(u_i,u_{i+1})\in E$。如果存在 $1\le i<j\le m$，使得 $u_i=u_j$，则仍然认为 $l$ 是一条路径。

定义路径 $l$ 上的本质不同点集 $V'=\{v\mid v=u_i,\exists i\in [1, m]\}$。记 $|V'|$ 为集合 $V'$ 的大小。记路径 $l$ 上的重复点数量为 $s$，有 $s=m-|V'|$。

你需要找到一条路径 $l$，在满足 $s\le k$ 的情况下，最大化 $|V'|$。

你需要输出这条路径。如果存在多组路径满足条件，输出任意一条满足题意的路径，就会被认为正确。

## 说明/提示

对于第一组测试用例，$n=9$ 且 $k=3$，组成的树如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tqnhdaph.png)

一组可行的解为：$l=(9,3,1,5,7,5,6,5,1,2,8)$。可以被证明的，此时本质不同点集大小 $|V'|$ 达到最大值 $8$，且重复点数量 $s=3\le k$。

对于第二组测试用例，$n=4$ 且 $k=4$，组成的树如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/0awmv421.png)

一组可行的解为：$l=(3,2,1,2,4)$。可以被证明的，此时本质不同点集大小 $|V'|$ 达到最大值 $4$，且重复点数量 $s=1\le k$。

由于本题输入输出数据规模较大，建议使用较为快速的输入输出方式。

## 样例 #1

### 输入

```
2
9 3
1 3
2 1
7 5
9 3
2 8
1 5
4 1
6 5
4 4
1 2
2 3
4 2```

### 输出

```
11
9 3 1 5 7 5 6 5 1 2 8
5
3 2 1 2 4```

# 题解

## 作者：modfish_ (赞：5)

## 思路
题意是要你在树上走一条非简单路径，使得遍历到的点数量最多，且路径经过的总点数与其差值不超过 $k$。

假设你已经知道要遍历哪一个连通块了，你肯定也知道怎么走最优：找到直径，从它的一端开始 DFS 遍历，最后到直径另一端结束。

这样为何最优？因为如果要回到出发点 $s$，无论你怎么走都要走过 $2x-1$ 个点，其中 $x$ 为连通块大小（因为你要经过 $2(x-1)$ 条边）。那你如果不回到出发点，而是停在 $t$，你就能少走 $\text{dis}(s,t)$ 个点（$\text{dis}(s,t)$ 是 $s$ 到 $t$ 路径上的边数）。按照前文所述的方案，你走过的点数是 $2x-1-D$（其中 $D$ 为直径长度），自然是最少的。

注意到，题目的限制是 $2x-1-D-x=x-D-1\le k$，故增长直径不会影响合法性。直接取原树直径即可。剩下还可以选 $k$ 个点，只要保证与直径连通，随便任选即可。

最后把你选出的连通块跑一遍 DFS，保证直径最后遍历，即可得到答案。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2e5 + 5;

vector<int> T[maxn];

static inline int read(){
    int x = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
    return x;
}
int dep[maxn], fa[maxn], vis[maxn];
void diameter(int x, int f, int &p){
    dep[x] = dep[f] + 1, fa[x] = f;
    if(dep[x] > dep[p]) p = x;
    for(int i = 0; i < T[x].size(); i ++){
        int j = T[x][i];
        if(j == f) continue;
        diameter(j, x, p);
    }
}
int ans[maxn << 2], ant = 0;
bool print(int x, int f, int &rest){
    if(!vis[x]){
        if(!rest) return false;
        rest --;
    }
    ans[++ ant] = x;
    int tag = 0;
    for(int i = 0; i < T[x].size(); i ++){
        int j = T[x][i];
        if(j == f) continue;
        if(vis[j]){
            tag = j;
            continue;
        }
        bool fl = print(j, x, rest);
        if(fl) ans[++ ant] = x;
    }
    if(tag) print(tag, x, rest);
    return true;
}

int main(){
    int TT = read();
    while(TT --){
        int n = read(), k = read();
        for(int i = 1; i < n; i ++){
            int u = read(), v = read();
            T[u].push_back(v), T[v].push_back(u);
        }
        int a = 0, b = 0;
        diameter(1, 0, a), diameter(a, 0, b);
        for(int i = b; i; i = fa[i]) vis[i] = 1;
        int D = dep[b], rest = k;
        print(a, 0, rest);
        printf("%d\n", ant);
        for(int i = 1; i <= ant; i ++) printf("%d ", ans[i]);
        printf("\n");
        ant = 0;
        for(int i = 1; i <= n; i ++) T[i].clear(), vis[i] = dep[i] = fa[i] = 0;
    }
    return 0;
}
```

---

一开始看成每个点经过不超过 $k$ 次，于是爆调 1h 树形 DP。

---

## 作者：liuxinying886 (赞：1)

# P12534 [XJTUPC 2025] 奥日
考虑 $k=0$ 时，最长路径就是树的直径，现在允许走 $k$ 个重复点，想要走的点数量最多，选择在走直径时发现该点有其他分叉时先走分叉，直到 $k$ 个点走完或者走到尽头了返回，继续走直径上的点（枝干到尽头了选择寻找下一个有枝干的点继续，直到 $k$ 用完）。

其他见代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,k,t,vis[200100],f[200100],visp,maxd;
vector<int> v[200100],ansn;
void dfs(int u,int fa,int dep){
	f[u]=fa;
	if(dep>=maxd){
		maxd=dep;
		visp=u;//标记最大深度最后落在哪个点上 
	}//更新最大深度记录直径长度 
	for(int i=0;i<v[u].size();i++){
		int now=v[u][i];
		if(now==fa)continue;
		dfs(now,u,dep+1);//不断dfs往下标记
	}
}
void write(int x){
	vis[x]=1;//记录已经走过了 
	ansn.push_back(x);
	for(int i=0;i<v[x].size();i++){ 
		int now=v[x][i];
		if(!vis[now]&&k){//脱离直径找旁边的点（k个重合点限制没有用完时一直往下走） 
			k--;
			write(now);
			ansn.push_back(x);//一去一回存两次q-x-y-x-q 
		}
	}
}
int main(){
	ios::sync_with_stdio(false); 
	cin>>t;
	while(t--){
		cin>>n>>k;
		for(int i=1;i<=n;i++){
			v[i].clear();
			vis[i]=0;
		}//快速清空 
		ansn.clear();
		for(int i=1;i<n;i++){
			int x,y;
			cin>>x>>y;
			v[x].push_back(y);
			v[y].push_back(x);//连边 
		}
		maxd=0;
		dfs(1,0,1);//从一边开始找最大深度和其最后的点 
		dfs(visp,0,1); //从最后的点开始存储整条直径的路径 
		for(int i=visp;i;i=f[i])vis[i]=1; //先标记一次，防止接下来存答案时在往旁边延伸时实际走了直径上的点 
		for(int i=visp;i;i=f[i])write(i);//从标记的点向另一边延展存答案 
		cout<<ansn.size()<<"\n";
		for(int i=0;i<ansn.size();i++)cout<<ansn[i]<<" ";
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：bluewindde (赞：1)

对于一棵树，从 $s$ 出发，经过 $t$ 个点，最终返回 $s$，这样的一条可重路径共包含 $2t$ 个节点，其中有 $t$ 个重复节点（考虑欧拉环游序）。这说明如果起点为 $u$，终点为 $v$，至多经过 $k$ 个路径 $u \to v$ 之外的点。选择树的直径作为路径 $u \to v$ 时总共经过的节点数最多，答案最优。

时间复杂度 $O(n)$。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int n, k;
vector<int> vec[200005];

int d, du;
int f[200005];
static inline void dfs(int u, int fa, int dep) {
    f[u] = fa;
    if (dep >= d)
        d = dep, du = u;
    for (auto v : vec[u])
        if (v != fa)
            dfs(v, u, dep + 1);
}
bool vis[200005];
vector<int> ans;
static inline void dfs(int u) {
    vis[u] = true;
    ans.push_back(u);
    for (auto v : vec[u])
        if (!vis[v] && k) {
            --k;
            dfs(v);
            ans.push_back(u);
        }
}

static inline void solve() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        vec[i].clear();
        vis[i] = false;
    }
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        vec[u].push_back(v);
        vec[v].push_back(u);
    }
    d = 0;
    dfs(1, 0, 1);
    dfs(du, 0, 1);
    for (int u = du; u; u = f[u])
        vis[u] = true;
    ans.clear();
    for (int u = du; u; u = f[u])
        dfs(u);
    cout << ans.size() << '\n';
    for (auto x : ans)
        cout << x << ' ';
    cout << '\n';
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--)
        solve();
    return 0;
}
```

---

